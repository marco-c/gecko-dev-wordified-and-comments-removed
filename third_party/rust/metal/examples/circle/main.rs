use
metal
:
:
*
;
use
winit
:
:
platform
:
:
macos
:
:
WindowExtMacOS
;
use
winit
:
:
{
event
:
:
{
Event
WindowEvent
}
event_loop
:
:
{
ControlFlow
EventLoop
}
}
;
use
cocoa
:
:
{
appkit
:
:
NSView
base
:
:
id
as
cocoa_id
}
;
use
objc
:
:
{
rc
:
:
autoreleasepool
runtime
:
:
YES
}
;
use
std
:
:
mem
;
#
[
repr
(
C
)
]
#
[
derive
(
Debug
)
]
pub
struct
position
(
cty
:
:
c_float
cty
:
:
c_float
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Debug
)
]
pub
struct
color
(
cty
:
:
c_float
cty
:
:
c_float
cty
:
:
c_float
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Debug
)
]
pub
struct
AAPLVertex
{
p
:
position
c
:
color
}
fn
main
(
)
{
let
event_loop
=
EventLoop
:
:
new
(
)
;
let
events_loop
=
winit
:
:
event_loop
:
:
EventLoop
:
:
new
(
)
;
let
size
=
winit
:
:
dpi
:
:
LogicalSize
:
:
new
(
800
600
)
;
let
window
=
winit
:
:
window
:
:
WindowBuilder
:
:
new
(
)
.
with_inner_size
(
size
)
.
with_title
(
"
Metal
"
.
to_string
(
)
)
.
build
(
&
events_loop
)
.
unwrap
(
)
;
let
device
=
Device
:
:
system_default
(
)
.
expect
(
"
no
device
found
"
)
;
println
!
(
"
Your
device
is
:
{
}
"
device
.
name
(
)
)
;
let
library_path
=
std
:
:
path
:
:
PathBuf
:
:
from
(
env
!
(
"
CARGO_MANIFEST_DIR
"
)
)
.
join
(
"
examples
/
circle
/
shaders
.
metallib
"
)
;
let
library
=
device
.
new_library_with_file
(
library_path
)
.
unwrap
(
)
;
let
pipeline_state
=
prepare_pipeline_state
(
&
device
&
library
)
;
let
command_queue
=
device
.
new_command_queue
(
)
;
let
layer
=
MetalLayer
:
:
new
(
)
;
layer
.
set_device
(
&
device
)
;
layer
.
set_pixel_format
(
MTLPixelFormat
:
:
BGRA8Unorm
)
;
layer
.
set_presents_with_transaction
(
false
)
;
unsafe
{
let
view
=
window
.
ns_view
(
)
as
cocoa_id
;
view
.
setWantsLayer
(
YES
)
;
view
.
setLayer
(
mem
:
:
transmute
(
layer
.
as_ref
(
)
)
)
;
}
let
draw_size
=
window
.
inner_size
(
)
;
layer
.
set_drawable_size
(
CGSize
:
:
new
(
draw_size
.
width
as
f64
draw_size
.
height
as
f64
)
)
;
let
vbuf
=
{
let
vertex_data
=
create_vertex_points_for_circle
(
)
;
let
vertex_data
=
vertex_data
.
as_slice
(
)
;
device
.
new_buffer_with_data
(
vertex_data
.
as_ptr
(
)
as
*
const
_
(
vertex_data
.
len
(
)
*
mem
:
:
size_of
:
:
<
AAPLVertex
>
(
)
)
as
u64
MTLResourceOptions
:
:
CPUCacheModeDefaultCache
|
MTLResourceOptions
:
:
StorageModeManaged
)
}
;
event_loop
.
run
(
move
|
event
_
control_flow
|
{
autoreleasepool
(
|
|
{
*
control_flow
=
ControlFlow
:
:
Wait
;
match
event
{
Event
:
:
WindowEvent
{
event
:
WindowEvent
:
:
CloseRequested
.
.
}
=
>
{
println
!
(
"
The
close
button
was
pressed
;
stopping
"
)
;
*
control_flow
=
ControlFlow
:
:
Exit
}
Event
:
:
MainEventsCleared
=
>
{
window
.
request_redraw
(
)
;
}
Event
:
:
RedrawRequested
(
_
)
=
>
{
let
drawable
=
match
layer
.
next_drawable
(
)
{
Some
(
drawable
)
=
>
drawable
None
=
>
return
}
;
let
command_buffer
=
command_queue
.
new_command_buffer
(
)
;
let
render_pass_descriptor
=
RenderPassDescriptor
:
:
new
(
)
;
prepare_render_pass_descriptor
(
&
render_pass_descriptor
drawable
.
texture
(
)
)
;
let
encoder
=
command_buffer
.
new_render_command_encoder
(
&
render_pass_descriptor
)
;
encoder
.
set_render_pipeline_state
(
&
pipeline_state
)
;
encoder
.
set_vertex_buffer
(
0
Some
(
&
vbuf
)
0
)
;
encoder
.
draw_primitives
(
MTLPrimitiveType
:
:
TriangleStrip
0
1080
)
;
encoder
.
end_encoding
(
)
;
command_buffer
.
present_drawable
(
&
drawable
)
;
command_buffer
.
commit
(
)
;
}
_
=
>
(
)
}
}
)
;
}
)
;
}
fn
create_vertex_points_for_circle
(
)
-
>
Vec
<
AAPLVertex
>
{
let
mut
v
:
Vec
<
AAPLVertex
>
=
Vec
:
:
new
(
)
;
let
origin_x
:
f32
=
0
.
0
;
let
origin_y
:
f32
=
0
.
0
;
let
circle_size
=
0
.
8f32
;
for
i
in
0
.
.
720
{
let
y
=
i
as
f32
;
let
position_x
:
f32
=
y
.
to_radians
(
)
.
cos
(
)
*
100
.
0
;
let
position_x
:
f32
=
position_x
.
trunc
(
)
/
100
.
0
;
let
position_x
:
f32
=
position_x
*
circle_size
;
let
position_y
:
f32
=
y
.
to_radians
(
)
.
sin
(
)
*
100
.
0
;
let
position_y
:
f32
=
position_y
.
trunc
(
)
/
100
.
0
;
let
position_y
:
f32
=
position_y
*
circle_size
;
v
.
push
(
AAPLVertex
{
p
:
position
(
position_x
position_y
)
c
:
color
(
0
.
7
0
.
3
0
.
5
)
}
)
;
if
(
i
+
1
)
%
2
=
=
0
{
v
.
push
(
AAPLVertex
{
p
:
position
(
origin_x
origin_y
)
c
:
color
(
0
.
2
0
.
7
0
.
4
)
}
)
;
}
}
v
}
fn
prepare_render_pass_descriptor
(
descriptor
:
&
RenderPassDescriptorRef
texture
:
&
TextureRef
)
{
let
color_attachment
=
descriptor
.
color_attachments
(
)
.
object_at
(
0
)
.
unwrap
(
)
;
color_attachment
.
set_texture
(
Some
(
texture
)
)
;
color_attachment
.
set_load_action
(
MTLLoadAction
:
:
Clear
)
;
color_attachment
.
set_clear_color
(
MTLClearColor
:
:
new
(
0
.
5
0
.
5
0
.
8
1
.
0
)
)
;
color_attachment
.
set_store_action
(
MTLStoreAction
:
:
Store
)
;
}
fn
prepare_pipeline_state
(
device
:
&
Device
library
:
&
Library
)
-
>
RenderPipelineState
{
let
vert
=
library
.
get_function
(
"
vs
"
None
)
.
unwrap
(
)
;
let
frag
=
library
.
get_function
(
"
ps
"
None
)
.
unwrap
(
)
;
let
pipeline_state_descriptor
=
RenderPipelineDescriptor
:
:
new
(
)
;
pipeline_state_descriptor
.
set_vertex_function
(
Some
(
&
vert
)
)
;
pipeline_state_descriptor
.
set_fragment_function
(
Some
(
&
frag
)
)
;
pipeline_state_descriptor
.
color_attachments
(
)
.
object_at
(
0
)
.
unwrap
(
)
.
set_pixel_format
(
MTLPixelFormat
:
:
BGRA8Unorm
)
;
device
.
new_render_pipeline_state
(
&
pipeline_state_descriptor
)
.
unwrap
(
)
}
