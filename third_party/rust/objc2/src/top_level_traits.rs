use
alloc
:
:
ffi
:
:
CString
;
use
core
:
:
ptr
:
:
NonNull
;
use
crate
:
:
__macro_helpers
:
:
defined_ivars
:
:
get_initialized_ivar_ptr
;
use
crate
:
:
encode
:
:
RefEncode
;
use
crate
:
:
rc
:
:
{
Allocated
Retained
}
;
use
crate
:
:
runtime
:
:
{
AnyClass
AnyProtocol
ProtocolObject
}
;
use
crate
:
:
MainThreadMarker
;
#
[
doc
=
include_str
!
(
"
.
.
/
examples
/
class_with_lifetime
.
rs
"
)
]
pub
unsafe
trait
Message
:
RefEncode
{
#
[
inline
]
#
[
doc
(
alias
=
"
objc_retain
"
)
]
fn
retain
(
&
self
)
-
>
Retained
<
Self
>
where
Self
:
Sized
{
let
ptr
:
*
const
Self
=
self
;
let
ptr
:
*
mut
Self
=
ptr
as
_
;
let
obj
=
unsafe
{
Retained
:
:
retain
(
ptr
)
}
;
unsafe
{
obj
.
unwrap_unchecked
(
)
}
}
}
pub
unsafe
trait
ClassType
:
Message
{
type
Super
:
Message
;
type
ThreadKind
:
?
Sized
+
ThreadKind
;
const
NAME
:
&
'
static
str
;
fn
class
(
)
-
>
&
'
static
AnyClass
;
fn
as_super
(
&
self
)
-
>
&
Self
:
:
Super
;
#
[
doc
(
hidden
)
]
const
__INNER
:
(
)
;
#
[
doc
(
hidden
)
]
type
__SubclassingType
:
?
Sized
;
}
pub
trait
DefinedClass
:
ClassType
{
type
Ivars
:
Sized
;
#
[
inline
]
#
[
track_caller
]
fn
ivars
(
&
self
)
-
>
&
Self
:
:
Ivars
where
Self
:
Sized
{
let
ptr
:
NonNull
<
Self
>
=
NonNull
:
:
from
(
self
)
;
let
ivars
=
unsafe
{
get_initialized_ivar_ptr
(
ptr
)
}
;
unsafe
{
ivars
.
as_ref
(
)
}
}
#
[
doc
(
hidden
)
]
fn
__ivars_offset
(
)
-
>
isize
;
#
[
doc
(
hidden
)
]
fn
__drop_flag_offset
(
)
-
>
isize
;
#
[
doc
(
hidden
)
]
const
__UNSAFE_OFFSETS_CORRECT
:
(
)
;
}
pub
unsafe
trait
ProtocolType
{
const
NAME
:
&
'
static
str
;
fn
protocol
(
)
-
>
Option
<
&
'
static
AnyProtocol
>
{
get_protocol
(
Self
:
:
NAME
)
}
#
[
doc
(
hidden
)
]
const
__INNER
:
(
)
;
}
fn
get_protocol
(
name
:
&
str
)
-
>
Option
<
&
'
static
AnyProtocol
>
{
let
name
=
CString
:
:
new
(
name
)
.
expect
(
"
protocol
name
must
be
UTF
-
8
"
)
;
AnyProtocol
:
:
get
(
&
name
)
}
mod
private
{
pub
trait
SealedAnyThread
{
}
pub
trait
SealedMainThreadOnly
{
}
pub
trait
SealedThreadKind
{
}
}
pub
unsafe
trait
AnyThread
:
private
:
:
SealedAnyThread
{
#
[
inline
]
fn
alloc
(
)
-
>
Allocated
<
Self
>
where
Self
:
Sized
+
ClassType
{
unsafe
{
Allocated
:
:
alloc
(
Self
:
:
class
(
)
)
}
}
}
impl
<
'
a
T
:
?
Sized
+
ClassType
<
ThreadKind
=
dyn
AnyThread
+
'
a
>
>
private
:
:
SealedAnyThread
for
T
{
}
unsafe
impl
<
'
a
T
:
?
Sized
+
ClassType
<
ThreadKind
=
dyn
AnyThread
+
'
a
>
>
AnyThread
for
T
{
}
impl
<
P
:
?
Sized
>
private
:
:
SealedAnyThread
for
ProtocolObject
<
P
>
{
}
unsafe
impl
<
P
:
?
Sized
+
AnyThread
>
AnyThread
for
ProtocolObject
<
P
>
{
}
#
[
doc
(
alias
=
"
MainActor
"
)
]
pub
unsafe
trait
MainThreadOnly
:
private
:
:
SealedMainThreadOnly
{
#
[
inline
]
#
[
cfg_attr
(
debug_assertions
track_caller
)
]
fn
mtm
(
&
self
)
-
>
MainThreadMarker
{
#
[
cfg
(
debug_assertions
)
]
assert
!
(
MainThreadMarker
:
:
new
(
)
.
is_some
(
)
"
the
main
-
thread
-
only
object
that
we
tried
to
fetch
a
MainThreadMarker
from
was
somehow
not
on
the
main
thread
"
)
;
unsafe
{
MainThreadMarker
:
:
new_unchecked
(
)
}
}
#
[
inline
]
fn
alloc
(
mtm
:
MainThreadMarker
)
-
>
Allocated
<
Self
>
where
Self
:
Sized
+
ClassType
{
let
_
=
mtm
;
unsafe
{
Allocated
:
:
alloc
(
Self
:
:
class
(
)
)
}
}
}
impl
<
'
a
T
:
?
Sized
+
ClassType
<
ThreadKind
=
dyn
MainThreadOnly
+
'
a
>
>
private
:
:
SealedMainThreadOnly
for
T
{
}
unsafe
impl
<
'
a
T
:
?
Sized
+
ClassType
<
ThreadKind
=
dyn
MainThreadOnly
+
'
a
>
>
MainThreadOnly
for
T
{
}
impl
<
P
:
?
Sized
>
private
:
:
SealedMainThreadOnly
for
ProtocolObject
<
P
>
{
}
unsafe
impl
<
P
:
?
Sized
+
MainThreadOnly
>
MainThreadOnly
for
ProtocolObject
<
P
>
{
}
pub
trait
ThreadKind
:
private
:
:
SealedThreadKind
{
#
[
doc
(
hidden
)
]
const
__DYN_INCOMPATIBLE
:
(
)
;
}
impl
private
:
:
SealedThreadKind
for
dyn
AnyThread
+
'
_
{
}
impl
ThreadKind
for
dyn
AnyThread
+
'
_
{
const
__DYN_INCOMPATIBLE
:
(
)
=
(
)
;
}
impl
private
:
:
SealedThreadKind
for
dyn
MainThreadOnly
+
'
_
{
}
impl
ThreadKind
for
dyn
MainThreadOnly
+
'
_
{
const
__DYN_INCOMPATIBLE
:
(
)
=
(
)
;
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
allow
(
unused
)
]
fn
dyn_compatible
(
_
:
&
dyn
AnyThread
_
:
&
dyn
MainThreadOnly
)
{
}
}
