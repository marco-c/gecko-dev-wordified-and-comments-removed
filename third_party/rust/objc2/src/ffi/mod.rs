#
!
[
allow
(
clippy
:
:
upper_case_acronyms
)
]
#
!
[
allow
(
non_camel_case_types
)
]
#
!
[
allow
(
non_upper_case_globals
)
]
#
!
[
allow
(
non_snake_case
)
]
#
!
[
allow
(
missing_debug_implementations
)
]
#
!
[
allow
(
missing_docs
)
]
use
core
:
:
cell
:
:
UnsafeCell
;
use
core
:
:
marker
:
:
{
PhantomData
PhantomPinned
}
;
macro_rules
!
generate_linking_tests
{
{
extern
abi
:
literal
{
(
(
#
[
m
:
meta
]
)
*
v
:
vis
fn
name
:
ident
(
(
(
#
[
a_m
:
meta
]
)
*
a
:
ident
:
t
:
ty
)
*
(
)
?
)
(
-
>
r
:
ty
)
?
;
)
+
}
mod
test_name
:
ident
;
}
=
>
{
extern
abi
{
(
(
#
[
m
]
)
*
v
fn
name
(
(
(
#
[
a_m
]
)
*
a
:
t
)
*
)
(
-
>
r
)
?
;
)
+
}
#
[
allow
(
deprecated
)
]
#
[
cfg
(
test
)
]
mod
test_name
{
#
[
allow
(
unused
)
]
use
super
:
:
*
;
(
(
#
[
m
]
)
*
#
[
test
]
fn
name
(
)
{
/
/
Get
function
pointer
to
make
the
linker
require
the
/
/
symbol
to
be
available
.
let
f
:
unsafe
extern
abi
fn
(
(
(
#
[
a_m
]
)
*
t
)
*
)
(
-
>
r
)
?
=
crate
:
:
ffi
:
:
name
;
/
/
Execute
side
-
effect
to
ensure
it
is
not
optimized
away
.
std
:
:
println
!
(
"
{
:
p
}
"
f
)
;
}
)
+
}
}
;
}
macro_rules
!
extern_c
{
{
(
(
#
[
m
:
meta
]
)
*
v
:
vis
fn
name
:
ident
(
(
(
#
[
a_m
:
meta
]
)
*
a
:
ident
:
t
:
ty
)
*
(
)
?
)
(
-
>
r
:
ty
)
?
;
)
+
}
=
>
{
generate_linking_tests
!
{
extern
"
C
"
{
(
(
#
[
m
]
)
*
v
fn
name
(
(
(
#
[
a_m
]
)
*
a
:
t
)
*
)
(
-
>
r
)
?
;
)
+
}
mod
test_linkable
;
}
}
;
}
macro_rules
!
extern_c_unwind
{
{
(
(
#
[
m
:
meta
]
)
*
v
:
vis
fn
name
:
ident
(
(
(
#
[
a_m
:
meta
]
)
*
a
:
ident
:
t
:
ty
)
*
(
)
?
)
(
-
>
r
:
ty
)
?
;
)
+
}
=
>
{
generate_linking_tests
!
{
extern
"
C
-
unwind
"
{
(
(
#
[
m
]
)
*
v
fn
name
(
(
(
#
[
a_m
]
)
*
a
:
t
)
*
)
(
-
>
r
)
?
;
)
+
}
mod
test_linkable_unwind
;
}
}
;
}
mod
class
;
mod
constants
;
mod
exception
;
mod
libc
;
mod
message
;
mod
method
;
mod
object
;
mod
property
;
mod
protocol
;
mod
rc
;
mod
selector
;
mod
types
;
mod
various
;
pub
use
self
:
:
class
:
:
*
;
pub
use
self
:
:
constants
:
:
*
;
pub
use
self
:
:
exception
:
:
*
;
pub
use
self
:
:
libc
:
:
*
;
pub
use
self
:
:
message
:
:
*
;
pub
use
self
:
:
method
:
:
*
;
pub
use
self
:
:
object
:
:
*
;
pub
use
self
:
:
property
:
:
*
;
pub
use
self
:
:
protocol
:
:
*
;
pub
use
self
:
:
rc
:
:
*
;
pub
use
self
:
:
selector
:
:
*
;
pub
use
self
:
:
types
:
:
*
;
pub
use
self
:
:
various
:
:
*
;
#
[
deprecated
=
"
merged
with
runtime
:
:
AnyClass
"
]
pub
type
objc_class
=
crate
:
:
runtime
:
:
AnyClass
;
#
[
deprecated
=
"
merged
with
runtime
:
:
AnyObject
"
]
pub
type
objc_object
=
crate
:
:
runtime
:
:
AnyObject
;
#
[
deprecated
=
"
merged
with
runtime
:
:
Imp
and
made
non
-
null
"
]
pub
type
IMP
=
Option
<
crate
:
:
runtime
:
:
Imp
>
;
#
[
deprecated
=
"
merged
with
runtime
:
:
Imp
"
]
pub
type
objc_method
=
crate
:
:
runtime
:
:
Method
;
#
[
deprecated
=
"
merged
with
runtime
:
:
Ivar
"
]
pub
type
objc_ivar
=
crate
:
:
runtime
:
:
Ivar
;
#
[
deprecated
=
"
use
AnyObject
directly
"
]
pub
type
id
=
*
mut
crate
:
:
runtime
:
:
AnyObject
;
#
[
deprecated
=
"
use
runtime
:
:
Bool
or
if
using
msg_send
!
just
bool
directly
"
]
pub
type
BOOL
=
crate
:
:
runtime
:
:
Bool
;
#
[
deprecated
=
"
use
runtime
:
:
Bool
:
:
YES
"
]
pub
const
YES
:
crate
:
:
runtime
:
:
Bool
=
crate
:
:
runtime
:
:
Bool
:
:
YES
;
#
[
deprecated
=
"
use
runtime
:
:
Bool
:
:
NO
"
]
pub
const
NO
:
crate
:
:
runtime
:
:
Bool
=
crate
:
:
runtime
:
:
Bool
:
:
NO
;
pub
(
crate
)
type
OpaqueData
=
UnsafeCell
<
PhantomData
<
(
*
const
UnsafeCell
<
(
)
>
PhantomPinned
)
>
>
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
core
:
:
ffi
:
:
CStr
;
#
[
test
]
fn
smoke
(
)
{
let
name
=
CStr
:
:
from_bytes_with_nul
(
b
"
abc
:
def
:
\
0
"
)
.
unwrap
(
)
;
let
sel
=
unsafe
{
sel_registerName
(
name
.
as_ptr
(
)
)
.
unwrap
(
)
}
;
let
rtn
=
unsafe
{
CStr
:
:
from_ptr
(
sel_getName
(
sel
)
)
}
;
assert_eq
!
(
name
rtn
)
;
}
}
