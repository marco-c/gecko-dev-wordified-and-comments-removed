use
core
:
:
ffi
:
:
c_char
;
use
core
:
:
ffi
:
:
CStr
;
use
core
:
:
fmt
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
ops
:
:
Deref
;
use
core
:
:
ptr
:
:
{
self
NonNull
}
;
use
crate
:
:
ffi
;
#
[
repr
(
transparent
)
]
pub
(
crate
)
struct
MallocSlice
<
T
>
{
ptr
:
NonNull
<
[
T
]
>
_p
:
PhantomData
<
[
T
]
>
}
impl
<
T
>
MallocSlice
<
T
>
{
pub
(
crate
)
unsafe
fn
from_array
(
mut
ptr
:
*
mut
T
len
:
usize
)
-
>
Self
{
if
len
=
=
0
{
ptr
=
NonNull
:
:
dangling
(
)
.
as_ptr
(
)
;
}
let
ptr
=
ptr
:
:
slice_from_raw_parts_mut
(
ptr
len
)
;
let
ptr
=
NonNull
:
:
new
(
ptr
)
.
expect
(
"
tried
to
construct
MallocSlice
from
a
NULL
pointer
"
)
;
Self
{
ptr
_p
:
PhantomData
}
}
fn
len
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
len
(
)
}
}
impl
<
T
>
Drop
for
MallocSlice
<
T
>
{
#
[
allow
(
clippy
:
:
len_zero
)
]
fn
drop
(
&
mut
self
)
{
if
self
.
len
(
)
!
=
0
{
unsafe
{
ptr
:
:
drop_in_place
(
self
.
ptr
.
as_ptr
(
)
)
}
;
unsafe
{
ffi
:
:
free
(
self
.
ptr
.
cast
(
)
.
as_ptr
(
)
)
}
;
}
}
}
impl
<
T
>
Deref
for
MallocSlice
<
T
>
{
type
Target
=
[
T
]
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
[
T
]
{
unsafe
{
self
.
ptr
.
as_ref
(
)
}
}
}
impl
<
T
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
MallocSlice
<
T
>
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
<
T
>
AsRef
<
[
T
]
>
for
MallocSlice
<
T
>
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
[
T
]
{
self
}
}
#
[
repr
(
transparent
)
]
pub
(
crate
)
struct
MallocCStr
{
ptr
:
NonNull
<
CStr
>
}
impl
MallocCStr
{
pub
(
crate
)
unsafe
fn
from_c_str
(
ptr
:
*
mut
c_char
)
-
>
Self
{
if
ptr
.
is_null
(
)
{
panic
!
(
"
tried
to
construct
MallocStr
from
a
NULL
pointer
"
)
;
}
let
cstr
=
unsafe
{
CStr
:
:
from_ptr
(
ptr
)
}
;
let
ptr
=
NonNull
:
:
from
(
cstr
)
;
Self
{
ptr
}
}
}
impl
Drop
for
MallocCStr
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
unsafe
{
ffi
:
:
free
(
self
.
ptr
.
cast
(
)
.
as_ptr
(
)
)
}
;
}
}
impl
Deref
for
MallocCStr
{
type
Target
=
CStr
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
CStr
{
unsafe
{
self
.
ptr
.
as_ref
(
)
}
}
}
impl
fmt
:
:
Debug
for
MallocCStr
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
AsRef
<
CStr
>
for
MallocCStr
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
CStr
{
self
}
}
