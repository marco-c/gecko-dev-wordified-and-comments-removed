use
core
:
:
fmt
;
use
core
:
:
hash
;
use
core
:
:
ops
:
:
Deref
;
use
core
:
:
panic
:
:
{
RefUnwindSafe
UnwindSafe
}
;
use
crate
:
:
ffi
:
:
NSUInteger
;
use
crate
:
:
rc
:
:
{
Allocated
DefaultRetained
Retained
}
;
use
crate
:
:
runtime
:
:
{
AnyClass
AnyObject
AnyProtocol
ImplementedBy
ProtocolObject
Sel
}
;
use
crate
:
:
{
extern_conformance
extern_methods
msg_send
AnyThread
ClassType
DowncastTarget
Message
ProtocolType
}
;
#
[
repr
(
C
)
]
pub
struct
NSObject
{
__superclass
:
AnyObject
}
crate
:
:
__extern_class_impl_traits
!
{
(
)
(
unsafe
impl
)
(
NSObject
)
(
AnyObject
)
}
mod
private
{
#
[
derive
(
PartialEq
Eq
Hash
)
]
pub
struct
ForDefinedSubclasses
(
pub
(
super
)
super
:
:
NSObject
)
;
}
impl
fmt
:
:
Debug
for
private
:
:
ForDefinedSubclasses
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
Deref
for
private
:
:
ForDefinedSubclasses
{
type
Target
=
NSObject
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
unsafe
impl
Send
for
private
:
:
ForDefinedSubclasses
{
}
unsafe
impl
Sync
for
private
:
:
ForDefinedSubclasses
{
}
impl
UnwindSafe
for
private
:
:
ForDefinedSubclasses
{
}
impl
RefUnwindSafe
for
private
:
:
ForDefinedSubclasses
{
}
unsafe
impl
ClassType
for
NSObject
{
type
Super
=
AnyObject
;
type
ThreadKind
=
dyn
AnyThread
;
const
NAME
:
&
'
static
str
=
"
NSObject
"
;
#
[
inline
]
fn
class
(
)
-
>
&
'
static
AnyClass
{
crate
:
:
__class_inner
!
(
"
NSObject
"
"
NSObject
"
)
}
#
[
inline
]
fn
as_super
(
&
self
)
-
>
&
Self
:
:
Super
{
&
self
.
__superclass
}
const
__INNER
:
(
)
=
(
)
;
type
__SubclassingType
=
private
:
:
ForDefinedSubclasses
;
}
unsafe
impl
DowncastTarget
for
NSObject
{
}
#
[
allow
(
non_snake_case
)
]
pub
unsafe
trait
NSObjectProtocol
{
#
[
doc
(
alias
=
"
isEqual
:
"
)
]
fn
isEqual
(
&
self
other
:
Option
<
&
AnyObject
>
)
-
>
bool
where
Self
:
Sized
+
Message
{
unsafe
{
msg_send
!
[
self
isEqual
:
other
]
}
}
fn
hash
(
&
self
)
-
>
NSUInteger
where
Self
:
Sized
+
Message
{
unsafe
{
msg_send
!
[
self
hash
]
}
}
#
[
doc
(
alias
=
"
isKindOfClass
:
"
)
]
fn
isKindOfClass
(
&
self
cls
:
&
AnyClass
)
-
>
bool
where
Self
:
Sized
+
Message
{
unsafe
{
msg_send
!
[
self
isKindOfClass
:
cls
]
}
}
#
[
deprecated
=
"
use
isKindOfClass
directly
or
cast
your
objects
with
AnyObject
:
:
downcast_ref
"
]
fn
is_kind_of
<
T
:
ClassType
>
(
&
self
)
-
>
bool
where
Self
:
Sized
+
Message
{
self
.
isKindOfClass
(
T
:
:
class
(
)
)
}
#
[
doc
(
alias
=
"
isMemberOfClass
:
"
)
]
fn
isMemberOfClass
(
&
self
cls
:
&
AnyClass
)
-
>
bool
where
Self
:
Sized
+
Message
{
unsafe
{
msg_send
!
[
self
isMemberOfClass
:
cls
]
}
}
#
[
doc
(
alias
=
"
respondsToSelector
:
"
)
]
fn
respondsToSelector
(
&
self
aSelector
:
Sel
)
-
>
bool
where
Self
:
Sized
+
Message
{
unsafe
{
msg_send
!
[
self
respondsToSelector
:
aSelector
]
}
}
#
[
doc
(
alias
=
"
conformsToProtocol
:
"
)
]
fn
conformsToProtocol
(
&
self
aProtocol
:
&
AnyProtocol
)
-
>
bool
where
Self
:
Sized
+
Message
{
unsafe
{
msg_send
!
[
self
conformsToProtocol
:
aProtocol
]
}
}
fn
description
(
&
self
)
-
>
Retained
<
NSObject
>
where
Self
:
Sized
+
Message
{
unsafe
{
msg_send
!
[
self
description
]
}
}
fn
debugDescription
(
&
self
)
-
>
Retained
<
NSObject
>
where
Self
:
Sized
+
Message
{
unsafe
{
msg_send
!
[
self
debugDescription
]
}
}
fn
isProxy
(
&
self
)
-
>
bool
where
Self
:
Sized
+
Message
{
unsafe
{
msg_send
!
[
self
isProxy
]
}
}
fn
retainCount
(
&
self
)
-
>
NSUInteger
where
Self
:
Sized
+
Message
{
unsafe
{
msg_send
!
[
self
retainCount
]
}
}
}
unsafe
impl
<
T
>
NSObjectProtocol
for
ProtocolObject
<
T
>
where
T
:
?
Sized
+
NSObjectProtocol
{
}
unsafe
impl
ProtocolType
for
dyn
NSObjectProtocol
{
const
NAME
:
&
'
static
str
=
"
NSObject
"
;
const
__INNER
:
(
)
=
(
)
;
}
unsafe
impl
<
T
>
ImplementedBy
<
T
>
for
dyn
NSObjectProtocol
where
T
:
?
Sized
+
Message
+
NSObjectProtocol
{
const
__INNER
:
(
)
=
(
)
;
}
unsafe
impl
<
T
>
ImplementedBy
<
T
>
for
dyn
NSObjectProtocol
+
Send
where
T
:
?
Sized
+
Message
+
NSObjectProtocol
+
Send
{
const
__INNER
:
(
)
=
(
)
;
}
unsafe
impl
<
T
>
ImplementedBy
<
T
>
for
dyn
NSObjectProtocol
+
Sync
where
T
:
?
Sized
+
Message
+
NSObjectProtocol
+
Sync
{
const
__INNER
:
(
)
=
(
)
;
}
unsafe
impl
<
T
>
ImplementedBy
<
T
>
for
dyn
NSObjectProtocol
+
Send
+
Sync
where
T
:
?
Sized
+
Message
+
NSObjectProtocol
+
Send
+
Sync
{
const
__INNER
:
(
)
=
(
)
;
}
extern_conformance
!
(
unsafe
impl
NSObjectProtocol
for
NSObject
{
}
)
;
#
[
allow
(
non_snake_case
)
]
impl
NSObject
{
extern_methods
!
(
/
/
/
Create
a
new
empty
NSObject
.
#
[
unsafe
(
method
(
new
)
)
]
#
[
unsafe
(
method_family
=
new
)
]
pub
fn
new
(
)
-
>
Retained
<
Self
>
;
/
/
/
Initialize
an
already
allocated
object
.
/
/
/
/
/
/
See
[
Apple
'
s
documentation
]
[
apple
-
doc
]
for
details
.
/
/
/
/
/
/
[
apple
-
doc
]
:
https
:
/
/
developer
.
apple
.
com
/
documentation
/
objectivec
/
nsobject
/
1418641
-
init
?
language
=
objc
/
/
/
/
/
/
/
/
/
#
Example
/
/
/
/
/
/
#
[
unsafe
(
method
(
init
)
)
]
#
[
unsafe
(
method_family
=
init
)
]
pub
fn
init
(
this
:
Allocated
<
Self
>
)
-
>
Retained
<
Self
>
;
#
[
unsafe
(
method
(
doesNotRecognizeSelector
:
)
)
]
#
[
unsafe
(
method_family
=
none
)
]
fn
doesNotRecognizeSelector_inner
(
&
self
sel
:
Sel
)
;
)
;
pub
fn
doesNotRecognizeSelector
(
&
self
sel
:
Sel
)
-
>
!
{
self
.
doesNotRecognizeSelector_inner
(
sel
)
;
unreachable
!
(
"
doesNotRecognizeSelector
:
should
not
return
"
)
}
}
impl
PartialEq
for
NSObject
{
#
[
inline
]
#
[
doc
(
alias
=
"
isEqual
:
"
)
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
isEqual
(
Some
(
other
)
)
}
}
impl
Eq
for
NSObject
{
}
impl
hash
:
:
Hash
for
NSObject
{
#
[
inline
]
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
<
Self
as
NSObjectProtocol
>
:
:
hash
(
self
)
.
hash
(
state
)
;
}
}
impl
fmt
:
:
Debug
for
NSObject
{
#
[
inline
]
#
[
doc
(
alias
=
"
description
"
)
]
#
[
doc
(
alias
=
"
debugDescription
"
)
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
obj
:
&
ProtocolObject
<
dyn
NSObjectProtocol
>
=
ProtocolObject
:
:
from_ref
(
self
)
;
obj
.
fmt
(
f
)
}
}
impl
DefaultRetained
for
NSObject
{
#
[
inline
]
fn
default_retained
(
)
-
>
Retained
<
Self
>
{
Self
:
:
new
(
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
alloc
:
:
format
;
use
crate
:
:
extern_class
;
use
crate
:
:
rc
:
:
RcTestObject
;
extern_class
!
(
#
[
unsafe
(
super
(
NSObject
)
)
]
#
[
name
=
"
NSObject
"
]
#
[
derive
(
Debug
PartialEq
Eq
Hash
)
]
struct
FakeSubclass
;
)
;
impl
FakeSubclass
{
fn
new
(
)
-
>
Retained
<
Self
>
{
Retained
:
:
downcast
(
NSObject
:
:
new
(
)
)
.
unwrap
(
)
}
}
#
[
test
]
fn
test_deref
(
)
{
let
obj
:
Retained
<
FakeSubclass
>
=
FakeSubclass
:
:
new
(
)
;
let
_
:
&
FakeSubclass
=
&
obj
;
let
_
:
&
NSObject
=
&
obj
;
let
_
:
&
AnyObject
=
&
obj
;
}
#
[
test
]
fn
test_as_ref_borrow
(
)
{
use
core
:
:
borrow
:
:
Borrow
;
fn
impls_as_ref_borrow
<
T
:
AsRef
<
U
>
+
Borrow
<
U
>
+
?
Sized
U
:
?
Sized
>
(
_
:
&
T
)
{
}
let
obj
=
FakeSubclass
:
:
new
(
)
;
impls_as_ref_borrow
:
:
<
Retained
<
FakeSubclass
>
FakeSubclass
>
(
&
obj
)
;
impls_as_ref_borrow
:
:
<
FakeSubclass
FakeSubclass
>
(
&
obj
)
;
impls_as_ref_borrow
:
:
<
NSObject
NSObject
>
(
&
obj
)
;
impls_as_ref_borrow
:
:
<
NSObject
AnyObject
>
(
&
obj
)
;
let
obj
=
NSObject
:
:
new
(
)
;
impls_as_ref_borrow
:
:
<
Retained
<
NSObject
>
NSObject
>
(
&
obj
)
;
fn
impls_as_ref
<
T
:
AsRef
<
U
>
+
?
Sized
U
:
?
Sized
>
(
_
:
&
T
)
{
}
let
obj
=
FakeSubclass
:
:
new
(
)
;
impls_as_ref
:
:
<
Retained
<
FakeSubclass
>
FakeSubclass
>
(
&
obj
)
;
impls_as_ref
:
:
<
Retained
<
FakeSubclass
>
NSObject
>
(
&
obj
)
;
impls_as_ref
:
:
<
Retained
<
FakeSubclass
>
AnyObject
>
(
&
obj
)
;
}
#
[
test
]
fn
test_equality
(
)
{
let
obj1
=
NSObject
:
:
new
(
)
;
assert_eq
!
(
obj1
obj1
)
;
let
obj2
=
NSObject
:
:
new
(
)
;
assert_ne
!
(
obj1
obj2
)
;
}
#
[
test
]
fn
test_hash
(
)
{
use
core
:
:
hash
:
:
Hasher
;
use
std
:
:
collections
:
:
hash_map
:
:
DefaultHasher
;
use
std
:
:
hash
:
:
Hash
;
let
obj1
=
NSObject
:
:
new
(
)
;
let
mut
hashstate1
=
DefaultHasher
:
:
new
(
)
;
let
mut
hashstate2
=
DefaultHasher
:
:
new
(
)
;
obj1
.
hash
(
&
mut
hashstate1
)
;
obj1
.
hash
(
&
mut
hashstate2
)
;
assert_eq
!
(
hashstate1
.
finish
(
)
hashstate2
.
finish
(
)
)
;
let
obj2
=
NSObject
:
:
new
(
)
;
let
mut
hashstate2
=
DefaultHasher
:
:
new
(
)
;
obj2
.
hash
(
&
mut
hashstate2
)
;
assert_ne
!
(
hashstate1
.
finish
(
)
hashstate2
.
finish
(
)
)
;
}
#
[
test
]
fn
test_debug
(
)
{
let
obj
=
NSObject
:
:
new
(
)
;
let
expected
=
format
!
(
"
<
NSObject
:
{
:
p
}
>
"
&
*
obj
)
;
assert_eq
!
(
format
!
(
"
{
obj
:
?
}
"
)
expected
)
;
}
#
[
test
]
fn
test_is_kind_of
(
)
{
let
obj
=
NSObject
:
:
new
(
)
;
assert
!
(
obj
.
isKindOfClass
(
NSObject
:
:
class
(
)
)
)
;
assert
!
(
!
obj
.
isKindOfClass
(
RcTestObject
:
:
class
(
)
)
)
;
let
obj
=
RcTestObject
:
:
new
(
)
;
assert
!
(
obj
.
isKindOfClass
(
NSObject
:
:
class
(
)
)
)
;
assert
!
(
obj
.
isKindOfClass
(
RcTestObject
:
:
class
(
)
)
)
;
}
#
[
test
]
fn
test_retain_same
(
)
{
let
obj1
=
NSObject
:
:
new
(
)
;
let
ptr1
=
Retained
:
:
as_ptr
(
&
obj1
)
;
let
obj2
=
obj1
.
clone
(
)
;
let
ptr2
=
Retained
:
:
as_ptr
(
&
obj2
)
;
assert_eq
!
(
ptr1
ptr2
)
;
}
#
[
test
]
fn
conforms_to_nsobjectprotocol
(
)
{
let
protocol
=
<
dyn
NSObjectProtocol
>
:
:
protocol
(
)
.
unwrap
(
)
;
assert
!
(
NSObject
:
:
class
(
)
.
conforms_to
(
protocol
)
)
;
}
mod
hash_does_not_overlap_with_normal_hash_method
{
#
[
allow
(
unused_imports
)
]
use
crate
:
:
runtime
:
:
NSObjectProtocol
;
use
std
:
:
collections
:
:
hash_map
:
:
DefaultHasher
;
use
std
:
:
hash
:
:
Hash
;
#
[
test
]
fn
inner
(
)
{
let
integer
=
5
;
let
mut
hasher
=
DefaultHasher
:
:
new
(
)
;
integer
.
hash
(
&
mut
hasher
)
;
}
}
}
