#
!
[
allow
(
clippy
:
:
upper_case_acronyms
)
]
use
core
:
:
{
fmt
hash
}
;
use
crate
:
:
encode
:
:
{
Encode
Encoding
RefEncode
}
;
#
[
cfg
(
all
(
not
(
feature
=
"
gnustep
-
1
-
7
"
)
not
(
feature
=
"
unstable
-
objfw
"
)
)
)
]
mod
inner
{
#
[
cfg
(
any
(
target_arch
=
"
aarch64
"
all
(
target_os
=
"
ios
"
target_pointer_width
=
"
64
"
not
(
target_abi_macabi
)
)
all
(
target_os
=
"
tvos
"
target_pointer_width
=
"
64
"
)
target_os
=
"
watchos
"
)
)
]
pub
(
crate
)
type
BOOL
=
bool
;
#
[
cfg
(
not
(
any
(
target_arch
=
"
aarch64
"
all
(
target_os
=
"
ios
"
target_pointer_width
=
"
64
"
not
(
target_abi_macabi
)
)
all
(
target_os
=
"
tvos
"
target_pointer_width
=
"
64
"
)
target_os
=
"
watchos
"
)
)
)
]
pub
(
crate
)
type
BOOL
=
i8
;
}
#
[
cfg
(
all
(
feature
=
"
gnustep
-
1
-
7
"
feature
=
"
unstable
-
gnustep
-
strict
-
apple
-
compat
"
)
)
]
mod
inner
{
pub
(
crate
)
type
BOOL
=
i8
;
}
#
[
cfg
(
all
(
feature
=
"
gnustep
-
1
-
7
"
not
(
feature
=
"
unstable
-
gnustep
-
strict
-
apple
-
compat
"
)
)
)
]
mod
inner
{
#
[
cfg
(
all
(
windows
not
(
all
(
target_pointer_width
=
"
64
"
target_env
=
"
gnu
"
)
)
)
)
]
pub
(
crate
)
type
BOOL
=
core
:
:
ffi
:
:
c_int
;
#
[
cfg
(
not
(
all
(
windows
not
(
all
(
target_pointer_width
=
"
64
"
target_env
=
"
gnu
"
)
)
)
)
)
]
pub
(
crate
)
type
BOOL
=
u8
;
}
#
[
cfg
(
feature
=
"
unstable
-
objfw
"
)
]
mod
inner
{
pub
(
crate
)
type
BOOL
=
i8
;
}
#
[
repr
(
transparent
)
]
#
[
derive
(
Copy
Clone
Default
)
]
pub
struct
Bool
{
value
:
inner
:
:
BOOL
}
impl
Bool
{
#
[
allow
(
clippy
:
:
unnecessary_cast
)
]
pub
const
YES
:
Self
=
Self
:
:
from_raw
(
true
as
inner
:
:
BOOL
)
;
#
[
allow
(
clippy
:
:
unnecessary_cast
)
]
pub
const
NO
:
Self
=
Self
:
:
from_raw
(
false
as
inner
:
:
BOOL
)
;
#
[
inline
]
pub
const
fn
new
(
value
:
bool
)
-
>
Self
{
let
value
=
value
as
inner
:
:
BOOL
;
Self
{
value
}
}
#
[
inline
]
pub
const
fn
from_raw
(
value
:
inner
:
:
BOOL
)
-
>
Self
{
Self
{
value
}
}
#
[
inline
]
pub
const
fn
as_raw
(
self
)
-
>
inner
:
:
BOOL
{
self
.
value
}
#
[
inline
]
pub
const
fn
is_false
(
self
)
-
>
bool
{
!
self
.
as_bool
(
)
}
#
[
inline
]
pub
const
fn
is_true
(
self
)
-
>
bool
{
self
.
as_bool
(
)
}
#
[
inline
]
pub
const
fn
as_bool
(
self
)
-
>
bool
{
self
.
value
!
=
(
false
as
inner
:
:
BOOL
)
}
}
impl
From
<
bool
>
for
Bool
{
#
[
inline
]
fn
from
(
b
:
bool
)
-
>
Bool
{
Bool
:
:
new
(
b
)
}
}
impl
From
<
Bool
>
for
bool
{
#
[
inline
]
fn
from
(
b
:
Bool
)
-
>
bool
{
b
.
as_bool
(
)
}
}
impl
fmt
:
:
Debug
for
Bool
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
if
self
.
as_bool
(
)
{
"
YES
"
}
else
{
"
NO
"
}
)
}
}
impl
PartialEq
for
Bool
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
as_bool
(
)
=
=
other
.
as_bool
(
)
}
}
impl
Eq
for
Bool
{
}
impl
hash
:
:
Hash
for
Bool
{
#
[
inline
]
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
as_bool
(
)
.
hash
(
state
)
;
}
}
impl
PartialOrd
for
Bool
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
core
:
:
cmp
:
:
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
Ord
for
Bool
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
core
:
:
cmp
:
:
Ordering
{
self
.
as_bool
(
)
.
cmp
(
&
other
.
as_bool
(
)
)
}
}
trait
Helper
{
const
__ENCODING
:
Encoding
;
}
impl
<
T
:
Encode
>
Helper
for
T
{
const
__ENCODING
:
Encoding
=
T
:
:
ENCODING
;
}
impl
Helper
for
bool
{
const
__ENCODING
:
Encoding
=
Encoding
:
:
Bool
;
}
unsafe
impl
Encode
for
Bool
{
const
ENCODING
:
Encoding
=
inner
:
:
BOOL
:
:
__ENCODING
;
}
unsafe
impl
RefEncode
for
Bool
{
const
ENCODING_REF
:
Encoding
=
Encoding
:
:
Pointer
(
&
Self
:
:
ENCODING
)
;
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
__macro_helpers
:
:
{
ConvertArgument
ConvertReturn
}
;
use
alloc
:
:
format
;
#
[
test
]
fn
test_basic
(
)
{
let
b
=
Bool
:
:
new
(
true
)
;
assert
!
(
b
.
as_bool
(
)
)
;
assert
!
(
b
.
is_true
(
)
)
;
assert
!
(
!
b
.
is_false
(
)
)
;
assert
!
(
bool
:
:
from
(
b
)
)
;
assert_eq
!
(
b
.
as_raw
(
)
as
usize
1
)
;
let
b
=
Bool
:
:
new
(
false
)
;
assert
!
(
!
b
.
as_bool
(
)
)
;
assert
!
(
!
b
.
is_true
(
)
)
;
assert
!
(
b
.
is_false
(
)
)
;
assert
!
(
!
bool
:
:
from
(
b
)
)
;
assert_eq
!
(
b
.
as_raw
(
)
as
usize
0
)
;
}
#
[
test
]
fn
test_associated_constants
(
)
{
let
b
=
Bool
:
:
YES
;
assert
!
(
b
.
as_bool
(
)
)
;
assert
!
(
b
.
is_true
(
)
)
;
assert_eq
!
(
b
.
as_raw
(
)
as
usize
1
)
;
let
b
=
Bool
:
:
NO
;
assert
!
(
!
b
.
as_bool
(
)
)
;
assert
!
(
b
.
is_false
(
)
)
;
assert_eq
!
(
b
.
as_raw
(
)
as
usize
0
)
;
}
#
[
test
]
fn
test_encode
(
)
{
assert_eq
!
(
bool
:
:
__ENCODING
Encoding
:
:
Bool
)
;
assert_eq
!
(
<
bool
as
ConvertArgument
>
:
:
__Inner
:
:
__ENCODING
<
bool
as
ConvertArgument
>
:
:
__Inner
:
:
ENCODING
)
;
assert_eq
!
(
<
bool
as
ConvertReturn
<
(
)
>
>
:
:
Inner
:
:
__ENCODING
<
bool
as
ConvertReturn
<
(
)
>
>
:
:
Inner
:
:
ENCODING
)
;
}
#
[
test
]
fn
test_impls
(
)
{
let
b
:
Bool
=
Default
:
:
default
(
)
;
assert
!
(
!
b
.
as_bool
(
)
)
;
assert
!
(
b
.
is_false
(
)
)
;
assert
!
(
Bool
:
:
from
(
true
)
.
as_bool
(
)
)
;
assert
!
(
Bool
:
:
from
(
true
)
.
is_true
(
)
)
;
assert
!
(
Bool
:
:
from
(
false
)
.
is_false
(
)
)
;
assert
!
(
Bool
:
:
from
(
true
)
.
is_true
(
)
)
;
assert
!
(
Bool
:
:
from
(
false
)
.
is_false
(
)
)
;
assert_eq
!
(
Bool
:
:
new
(
true
)
Bool
:
:
new
(
true
)
)
;
assert_eq
!
(
Bool
:
:
new
(
false
)
Bool
:
:
new
(
false
)
)
;
assert
!
(
Bool
:
:
new
(
false
)
<
Bool
:
:
new
(
true
)
)
;
}
#
[
test
]
fn
test_debug
(
)
{
assert_eq
!
(
format
!
(
"
{
:
?
}
"
Bool
:
:
from
(
true
)
)
"
YES
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
Bool
:
:
from
(
false
)
)
"
NO
"
)
;
}
#
[
test
]
#
[
cfg
(
all
(
target_vendor
=
"
apple
"
target_os
=
"
macos
"
target_arch
=
"
x86_64
"
)
)
]
fn
test_outside_normal
(
)
{
let
b
=
Bool
:
:
from_raw
(
42
)
;
assert
!
(
b
.
is_true
(
)
)
;
assert
!
(
!
b
.
is_false
(
)
)
;
assert_eq
!
(
b
.
as_raw
(
)
42
)
;
assert_eq
!
(
b
Bool
:
:
new
(
true
)
)
;
assert_ne
!
(
b
Bool
:
:
new
(
false
)
)
;
}
}
