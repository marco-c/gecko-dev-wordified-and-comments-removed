#
!
[
doc
=
include_str
!
(
"
.
.
/
.
.
/
examples
/
introspection
.
rs
"
)
]
#
!
[
allow
(
clippy
:
:
missing_panics_doc
)
]
use
alloc
:
:
ffi
:
:
CString
;
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
ffi
:
:
c_char
;
use
core
:
:
ffi
:
:
c_uint
;
use
core
:
:
ffi
:
:
{
c_void
CStr
}
;
use
core
:
:
fmt
;
use
core
:
:
hash
;
use
core
:
:
panic
:
:
{
RefUnwindSafe
UnwindSafe
}
;
use
core
:
:
ptr
:
:
{
self
NonNull
}
;
#
[
doc
(
hidden
)
]
pub
mod
__nsstring
;
mod
bool
;
mod
define
;
mod
malloc
;
mod
message_receiver
;
mod
method_encoding_iter
;
mod
method_implementation
;
mod
nsobject
;
mod
nsproxy
;
mod
nszone
;
mod
protocol_object
;
mod
retain_release_fast
;
pub
(
crate
)
use
self
:
:
method_encoding_iter
:
:
{
EncodingParseError
MethodEncodingIter
}
;
pub
(
crate
)
use
self
:
:
retain_release_fast
:
:
{
objc_release_fast
objc_retain_fast
}
;
use
crate
:
:
encode
:
:
{
Encode
EncodeArguments
EncodeReturn
Encoding
OptionEncode
RefEncode
}
;
use
crate
:
:
msg_send
;
use
crate
:
:
verify
:
:
{
verify_method_signature
Inner
}
;
use
crate
:
:
{
ffi
DowncastTarget
Message
}
;
#
[
doc
(
hidden
)
]
pub
use
self
:
:
nsproxy
:
:
NSProxy
as
__NSProxy
;
pub
use
self
:
:
bool
:
:
Bool
;
pub
use
self
:
:
define
:
:
{
ClassBuilder
ProtocolBuilder
}
;
pub
use
self
:
:
message_receiver
:
:
MessageReceiver
;
pub
use
self
:
:
method_implementation
:
:
MethodImplementation
;
pub
use
self
:
:
nsobject
:
:
{
NSObject
NSObjectProtocol
}
;
pub
use
self
:
:
nszone
:
:
NSZone
;
pub
use
self
:
:
protocol_object
:
:
{
ImplementedBy
ProtocolObject
}
;
pub
use
crate
:
:
verify
:
:
VerificationError
;
#
[
allow
(
deprecated
)
]
pub
use
crate
:
:
ffi
:
:
{
BOOL
NO
YES
}
;
use
self
:
:
malloc
:
:
{
MallocCStr
MallocSlice
}
;
macro_rules
!
MallocSlice
{
(
t
:
ty
)
=
>
{
impl
std
:
:
ops
:
:
Deref
<
Target
=
[
t
]
>
+
AsRef
<
[
t
]
>
+
std
:
:
fmt
:
:
Debug
}
;
}
macro_rules
!
MallocCStr
{
(
)
=
>
{
impl
std
:
:
ops
:
:
Deref
<
Target
=
CStr
>
+
AsRef
<
CStr
>
+
std
:
:
fmt
:
:
Debug
}
;
}
macro_rules
!
standard_pointer_impls
{
(
name
:
ident
)
=
>
{
impl
PartialEq
for
name
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
ptr
:
:
eq
(
self
other
)
}
}
impl
Eq
for
name
{
}
impl
hash
:
:
Hash
for
name
{
#
[
inline
]
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
let
ptr
:
*
const
Self
=
self
;
ptr
.
hash
(
state
)
}
}
}
;
}
#
[
doc
(
alias
=
"
IMP
"
)
]
pub
type
Imp
=
unsafe
extern
"
C
-
unwind
"
fn
(
)
;
#
[
repr
(
transparent
)
]
#
[
derive
(
Copy
Clone
)
]
#
[
doc
(
alias
=
"
SEL
"
)
]
#
[
doc
(
alias
=
"
objc_selector
"
)
]
pub
struct
Sel
{
ptr
:
NonNull
<
c_void
>
}
unsafe
impl
Sync
for
Sel
{
}
unsafe
impl
Send
for
Sel
{
}
impl
UnwindSafe
for
Sel
{
}
impl
RefUnwindSafe
for
Sel
{
}
impl
Sel
{
#
[
inline
]
#
[
doc
(
hidden
)
]
pub
const
unsafe
fn
__internal_from_ptr
(
ptr
:
*
const
u8
)
-
>
Self
{
let
ptr
=
unsafe
{
NonNull
:
:
new_unchecked
(
ptr
as
*
mut
c_void
)
}
;
Self
{
ptr
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
from_ptr
(
ptr
:
*
const
c_void
)
-
>
Option
<
Self
>
{
NonNull
:
:
new
(
ptr
as
*
mut
c_void
)
.
map
(
|
ptr
|
Self
{
ptr
}
)
}
#
[
inline
]
pub
(
crate
)
const
fn
as_ptr
(
&
self
)
-
>
*
const
c_void
{
self
.
ptr
.
as_ptr
(
)
}
pub
(
crate
)
unsafe
fn
register_unchecked
(
name
:
*
const
c_char
)
-
>
Self
{
let
ptr
=
unsafe
{
ffi
:
:
sel_registerName
(
name
)
}
;
ptr
.
expect
(
"
failed
allocating
selector
"
)
}
#
[
inline
]
#
[
doc
(
alias
=
"
sel_registerName
"
)
]
pub
fn
register
(
name
:
&
CStr
)
-
>
Self
{
unsafe
{
Self
:
:
register_unchecked
(
name
.
as_ptr
(
)
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
sel_getName
"
)
]
pub
fn
name
(
self
)
-
>
&
'
static
CStr
{
let
ptr
=
unsafe
{
ffi
:
:
sel_getName
(
self
)
}
;
unsafe
{
CStr
:
:
from_ptr
(
ptr
)
}
}
pub
(
crate
)
fn
number_of_arguments
(
self
)
-
>
usize
{
self
.
name
(
)
.
to_bytes
(
)
.
iter
(
)
.
filter
(
|
&
&
b
|
b
=
=
b
'
:
'
)
.
count
(
)
}
}
impl
PartialEq
for
Sel
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
if
cfg
!
(
feature
=
"
gnustep
-
1
-
7
"
)
{
unsafe
{
ffi
:
:
sel_isEqual
(
*
self
*
other
)
.
as_bool
(
)
}
}
else
{
ptr
:
:
eq
(
self
.
as_ptr
(
)
other
.
as_ptr
(
)
)
}
}
}
impl
Eq
for
Sel
{
}
impl
hash
:
:
Hash
for
Sel
{
#
[
inline
]
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
if
cfg
!
(
feature
=
"
gnustep
-
1
-
7
"
)
{
self
.
name
(
)
.
hash
(
state
)
;
}
else
{
self
.
as_ptr
(
)
.
hash
(
state
)
;
}
}
}
unsafe
impl
Encode
for
Sel
{
const
ENCODING
:
Encoding
=
Encoding
:
:
Sel
;
}
unsafe
impl
OptionEncode
for
Sel
{
}
impl
fmt
:
:
Display
for
Sel
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
name
(
)
.
to_string_lossy
(
)
f
)
}
}
impl
fmt
:
:
Debug
for
Sel
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
Sel
"
)
.
field
(
&
self
.
name
(
)
)
.
finish
(
)
}
}
impl
fmt
:
:
Pointer
for
Sel
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Pointer
:
:
fmt
(
&
self
.
ptr
f
)
}
}
#
[
repr
(
C
)
]
#
[
doc
(
alias
=
"
objc_ivar
"
)
]
pub
struct
Ivar
{
_priv
:
[
u8
;
0
]
_p
:
ffi
:
:
OpaqueData
}
unsafe
impl
Sync
for
Ivar
{
}
unsafe
impl
Send
for
Ivar
{
}
impl
UnwindSafe
for
Ivar
{
}
impl
RefUnwindSafe
for
Ivar
{
}
impl
Ivar
{
#
[
inline
]
#
[
doc
(
alias
=
"
ivar_getName
"
)
]
pub
fn
name
(
&
self
)
-
>
&
CStr
{
unsafe
{
CStr
:
:
from_ptr
(
ffi
:
:
ivar_getName
(
self
)
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
ivar_getOffset
"
)
]
pub
fn
offset
(
&
self
)
-
>
isize
{
unsafe
{
ffi
:
:
ivar_getOffset
(
self
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
ivar_getTypeEncoding
"
)
]
pub
fn
type_encoding
(
&
self
)
-
>
&
CStr
{
unsafe
{
CStr
:
:
from_ptr
(
ffi
:
:
ivar_getTypeEncoding
(
self
)
)
}
}
#
[
inline
]
pub
(
crate
)
fn
debug_assert_encoding
(
&
self
_expected
:
&
Encoding
)
{
#
[
cfg
(
all
(
debug_assertions
not
(
feature
=
"
disable
-
encoding
-
assertions
"
)
)
)
]
{
let
encoding
=
self
.
type_encoding
(
)
;
let
encoding
=
encoding
.
to_str
(
)
.
expect
(
"
encoding
must
be
UTF
-
8
"
)
;
assert
!
(
_expected
.
equivalent_to_str
(
encoding
)
"
wrong
encoding
.
Tried
to
retrieve
ivar
with
encoding
{
encoding
}
but
the
encoding
of
the
given
type
was
{
_expected
}
"
)
;
}
}
#
[
inline
]
pub
unsafe
fn
load_ptr
<
T
:
Encode
>
(
&
self
obj
:
&
AnyObject
)
-
>
*
mut
T
{
self
.
debug_assert_encoding
(
&
T
:
:
ENCODING
)
;
let
ptr
=
NonNull
:
:
from
(
obj
)
;
let
ptr
=
unsafe
{
AnyObject
:
:
ivar_at_offset
:
:
<
T
>
(
ptr
self
.
offset
(
)
)
}
;
ptr
.
as_ptr
(
)
}
#
[
inline
]
pub
unsafe
fn
load
<
'
obj
T
:
Encode
>
(
&
self
obj
:
&
'
obj
AnyObject
)
-
>
&
'
obj
T
{
unsafe
{
self
.
load_ptr
:
:
<
T
>
(
obj
)
.
as_ref
(
)
.
unwrap_unchecked
(
)
}
}
#
[
inline
]
pub
unsafe
fn
load_mut
<
'
obj
T
:
Encode
>
(
&
self
obj
:
&
'
obj
mut
AnyObject
)
-
>
&
'
obj
mut
T
{
self
.
debug_assert_encoding
(
&
T
:
:
ENCODING
)
;
let
ptr
=
NonNull
:
:
from
(
obj
)
;
let
mut
ptr
=
unsafe
{
AnyObject
:
:
ivar_at_offset
:
:
<
T
>
(
ptr
self
.
offset
(
)
)
}
;
unsafe
{
ptr
.
as_mut
(
)
}
}
}
standard_pointer_impls
!
(
Ivar
)
;
impl
fmt
:
:
Debug
for
Ivar
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Ivar
"
)
.
field
(
"
name
"
&
self
.
name
(
)
)
.
field
(
"
offset
"
&
self
.
offset
(
)
)
.
field
(
"
type_encoding
"
&
self
.
type_encoding
(
)
)
.
finish_non_exhaustive
(
)
}
}
#
[
derive
(
Debug
PartialEq
Eq
Hash
)
]
pub
(
crate
)
struct
MethodDescription
{
pub
(
crate
)
sel
:
Sel
pub
(
crate
)
types
:
&
'
static
CStr
}
impl
MethodDescription
{
pub
(
crate
)
unsafe
fn
from_raw
(
raw
:
ffi
:
:
objc_method_description
)
-
>
Option
<
Self
>
{
let
sel
=
raw
.
name
?
;
if
raw
.
types
.
is_null
(
)
{
return
None
;
}
let
types
=
unsafe
{
CStr
:
:
from_ptr
(
raw
.
types
)
}
;
Some
(
Self
{
sel
types
}
)
}
}
#
[
repr
(
C
)
]
#
[
doc
(
alias
=
"
objc_method
"
)
]
pub
struct
Method
{
_priv
:
[
u8
;
0
]
_p
:
ffi
:
:
OpaqueData
}
unsafe
impl
Sync
for
Method
{
}
unsafe
impl
Send
for
Method
{
}
impl
UnwindSafe
for
Method
{
}
impl
RefUnwindSafe
for
Method
{
}
impl
Method
{
#
[
inline
]
fn
as_mut_ptr
(
&
self
)
-
>
*
mut
Self
{
let
ptr
:
*
const
Self
=
self
;
ptr
as
_
}
#
[
inline
]
#
[
doc
(
alias
=
"
method_getName
"
)
]
pub
fn
name
(
&
self
)
-
>
Sel
{
unsafe
{
ffi
:
:
method_getName
(
self
)
.
unwrap
(
)
}
}
#
[
doc
(
alias
=
"
method_copyReturnType
"
)
]
pub
fn
return_type
(
&
self
)
-
>
MallocCStr
!
(
)
{
unsafe
{
let
encoding
=
ffi
:
:
method_copyReturnType
(
self
)
;
MallocCStr
:
:
from_c_str
(
encoding
)
}
}
#
[
doc
(
alias
=
"
method_copyArgumentType
"
)
]
pub
fn
argument_type
(
&
self
index
:
usize
)
-
>
Option
<
MallocCStr
!
(
)
>
{
unsafe
{
let
encoding
=
ffi
:
:
method_copyArgumentType
(
self
index
as
c_uint
)
;
NonNull
:
:
new
(
encoding
)
.
map
(
|
encoding
|
MallocCStr
:
:
from_c_str
(
encoding
.
as_ptr
(
)
)
)
}
}
#
[
doc
(
alias
=
"
method_getTypeEncoding
"
)
]
pub
(
crate
)
fn
types
(
&
self
)
-
>
MethodEncodingIter
<
'
_
>
{
let
cstr
=
unsafe
{
ffi
:
:
method_getTypeEncoding
(
self
)
}
;
if
cstr
.
is_null
(
)
{
panic
!
(
"
method
type
encoding
was
NULL
"
)
;
}
let
encoding
=
unsafe
{
CStr
:
:
from_ptr
(
cstr
)
}
;
let
s
=
encoding
.
to_str
(
)
.
expect
(
"
method
type
encoding
must
be
UTF
-
8
"
)
;
MethodEncodingIter
:
:
new
(
s
)
}
#
[
inline
]
#
[
doc
(
alias
=
"
method_getNumberOfArguments
"
)
]
pub
fn
arguments_count
(
&
self
)
-
>
usize
{
unsafe
{
ffi
:
:
method_getNumberOfArguments
(
self
)
as
usize
}
}
#
[
doc
(
alias
=
"
method_getImplementation
"
)
]
pub
fn
implementation
(
&
self
)
-
>
Imp
{
unsafe
{
ffi
:
:
method_getImplementation
(
self
)
.
expect
(
"
null
IMP
"
)
}
}
#
[
doc
(
alias
=
"
method_setImplementation
"
)
]
pub
unsafe
fn
set_implementation
(
&
self
imp
:
Imp
)
-
>
Imp
{
unsafe
{
ffi
:
:
method_setImplementation
(
self
.
as_mut_ptr
(
)
imp
)
.
expect
(
"
null
IMP
"
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
method_exchangeImplementations
"
)
]
pub
unsafe
fn
exchange_implementation
(
&
self
other
:
&
Self
)
{
unsafe
{
ffi
:
:
method_exchangeImplementations
(
self
.
as_mut_ptr
(
)
other
.
as_mut_ptr
(
)
)
}
}
}
standard_pointer_impls
!
(
Method
)
;
impl
fmt
:
:
Debug
for
Method
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Method
"
)
.
field
(
"
name
"
&
self
.
name
(
)
)
.
field
(
"
types
"
&
self
.
types
(
)
)
.
field
(
"
implementation
"
&
self
.
implementation
(
)
)
.
finish_non_exhaustive
(
)
}
}
#
[
repr
(
C
)
]
#
[
doc
(
alias
=
"
Class
"
)
]
#
[
doc
(
alias
=
"
objc_class
"
)
]
pub
struct
AnyClass
{
inner
:
AnyObject
}
#
[
deprecated
=
"
renamed
to
runtime
:
:
AnyClass
"
]
pub
type
Class
=
AnyClass
;
unsafe
impl
Sync
for
AnyClass
{
}
unsafe
impl
Send
for
AnyClass
{
}
impl
UnwindSafe
for
AnyClass
{
}
impl
RefUnwindSafe
for
AnyClass
{
}
impl
AnyClass
{
#
[
inline
]
#
[
doc
(
alias
=
"
objc_getClass
"
)
]
pub
fn
get
(
name
:
&
CStr
)
-
>
Option
<
&
'
static
Self
>
{
let
cls
=
unsafe
{
ffi
:
:
objc_getClass
(
name
.
as_ptr
(
)
)
}
;
unsafe
{
cls
.
as_ref
(
)
}
}
#
[
doc
(
alias
=
"
objc_copyClassList
"
)
]
pub
fn
classes
(
)
-
>
MallocSlice
!
(
&
'
static
Self
)
{
unsafe
{
let
mut
count
:
c_uint
=
0
;
let
classes
:
*
mut
&
Self
=
ffi
:
:
objc_copyClassList
(
&
mut
count
)
.
cast
(
)
;
MallocSlice
:
:
from_array
(
classes
count
as
usize
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
objc_getClassList
"
)
]
pub
fn
classes_count
(
)
-
>
usize
{
unsafe
{
ffi
:
:
objc_getClassList
(
ptr
:
:
null_mut
(
)
0
)
as
usize
}
}
pub
(
crate
)
unsafe
fn
name_raw
<
'
a
>
(
ptr
:
*
const
Self
)
-
>
&
'
a
CStr
{
let
name
=
unsafe
{
ffi
:
:
class_getName
(
ptr
)
}
;
if
name
.
is_null
(
)
{
panic
!
(
"
class
name
was
NULL
"
)
;
}
unsafe
{
CStr
:
:
from_ptr
(
name
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
class_getName
"
)
]
pub
fn
name
(
&
self
)
-
>
&
CStr
{
unsafe
{
Self
:
:
name_raw
(
self
)
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
superclass_raw
<
'
a
>
(
ptr
:
*
const
Self
)
-
>
Option
<
&
'
a
AnyClass
>
{
let
superclass
=
unsafe
{
ffi
:
:
class_getSuperclass
(
ptr
)
}
;
unsafe
{
superclass
.
as_ref
(
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
class_getSuperclass
"
)
]
pub
fn
superclass
(
&
self
)
-
>
Option
<
&
AnyClass
>
{
unsafe
{
Self
:
:
superclass_raw
(
self
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
object_getClass
"
)
]
#
[
doc
(
alias
=
"
objc_getMetaClass
"
)
]
pub
fn
metaclass
(
&
self
)
-
>
&
Self
{
let
ptr
:
*
const
Self
=
self
;
let
ptr
=
unsafe
{
ffi
:
:
object_getClass
(
ptr
.
cast
(
)
)
}
;
unsafe
{
ptr
.
as_ref
(
)
.
unwrap_unchecked
(
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
class_isMetaClass
"
)
]
pub
fn
is_metaclass
(
&
self
)
-
>
bool
{
unsafe
{
ffi
:
:
class_isMetaClass
(
self
)
.
as_bool
(
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
class_getInstanceSize
"
)
]
pub
fn
instance_size
(
&
self
)
-
>
usize
{
unsafe
{
ffi
:
:
class_getInstanceSize
(
self
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
class_getInstanceMethod
"
)
]
pub
fn
instance_method
(
&
self
sel
:
Sel
)
-
>
Option
<
&
Method
>
{
unsafe
{
let
method
=
ffi
:
:
class_getInstanceMethod
(
self
sel
)
;
method
.
as_ref
(
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
class_getClassMethod
"
)
]
pub
fn
class_method
(
&
self
sel
:
Sel
)
-
>
Option
<
&
Method
>
{
unsafe
{
let
method
=
ffi
:
:
class_getClassMethod
(
self
sel
)
;
method
.
as_ref
(
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
class_getInstanceVariable
"
)
]
pub
fn
instance_variable
(
&
self
name
:
&
CStr
)
-
>
Option
<
&
Ivar
>
{
unsafe
{
let
ivar
=
ffi
:
:
class_getInstanceVariable
(
self
name
.
as_ptr
(
)
)
;
ivar
.
as_ref
(
)
}
}
#
[
allow
(
unused
)
]
#
[
inline
]
#
[
doc
(
alias
=
"
class_getClassVariable
"
)
]
fn
class_variable
(
&
self
name
:
&
CStr
)
-
>
Option
<
&
Ivar
>
{
let
ivar
=
unsafe
{
ffi
:
:
class_getClassVariable
(
self
name
.
as_ptr
(
)
)
}
;
unsafe
{
ivar
.
as_ref
(
)
}
}
#
[
doc
(
alias
=
"
class_copyMethodList
"
)
]
pub
fn
instance_methods
(
&
self
)
-
>
MallocSlice
!
(
&
Method
)
{
unsafe
{
let
mut
count
:
c_uint
=
0
;
let
methods
:
*
mut
&
Method
=
ffi
:
:
class_copyMethodList
(
self
&
mut
count
)
.
cast
(
)
;
MallocSlice
:
:
from_array
(
methods
count
as
usize
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
class_conformsToProtocol
"
)
]
pub
fn
conforms_to
(
&
self
proto
:
&
AnyProtocol
)
-
>
bool
{
unsafe
{
ffi
:
:
class_conformsToProtocol
(
self
proto
)
.
as_bool
(
)
}
}
#
[
doc
(
alias
=
"
class_copyProtocolList
"
)
]
pub
fn
adopted_protocols
(
&
self
)
-
>
MallocSlice
!
(
&
AnyProtocol
)
{
unsafe
{
let
mut
count
:
c_uint
=
0
;
let
protos
:
*
mut
&
AnyProtocol
=
ffi
:
:
class_copyProtocolList
(
self
&
mut
count
)
.
cast
(
)
;
MallocSlice
:
:
from_array
(
protos
count
as
usize
)
}
}
#
[
doc
(
alias
=
"
class_copyIvarList
"
)
]
pub
fn
instance_variables
(
&
self
)
-
>
MallocSlice
!
(
&
Ivar
)
{
unsafe
{
let
mut
count
:
c_uint
=
0
;
let
ivars
:
*
mut
&
Ivar
=
ffi
:
:
class_copyIvarList
(
self
&
mut
count
)
.
cast
(
)
;
MallocSlice
:
:
from_array
(
ivars
count
as
usize
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
class_respondsToSelector
"
)
]
pub
fn
responds_to
(
&
self
sel
:
Sel
)
-
>
bool
{
unsafe
{
ffi
:
:
class_respondsToSelector
(
self
sel
)
.
as_bool
(
)
}
}
#
[
allow
(
clippy
:
:
missing_errors_doc
)
]
pub
fn
verify_sel
<
A
R
>
(
&
self
sel
:
Sel
)
-
>
Result
<
(
)
VerificationError
>
where
A
:
EncodeArguments
R
:
EncodeReturn
{
let
method
=
self
.
instance_method
(
sel
)
.
ok_or
(
Inner
:
:
MethodNotFound
)
?
;
verify_method_signature
(
method
A
:
:
ENCODINGS
&
R
:
:
ENCODING_RETURN
)
}
}
standard_pointer_impls
!
(
AnyClass
)
;
unsafe
impl
RefEncode
for
AnyClass
{
const
ENCODING_REF
:
Encoding
=
Encoding
:
:
Class
;
}
unsafe
impl
Message
for
AnyClass
{
}
impl
fmt
:
:
Debug
for
AnyClass
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
AnyClass
"
)
.
field
(
"
name
"
&
self
.
name
(
)
)
.
finish_non_exhaustive
(
)
}
}
impl
fmt
:
:
Display
for
AnyClass
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
name
(
)
.
to_string_lossy
(
)
f
)
}
}
impl
AsRef
<
Self
>
for
AnyClass
{
fn
as_ref
(
&
self
)
-
>
&
Self
{
self
}
}
impl
AsRef
<
AnyObject
>
for
AnyClass
{
fn
as_ref
(
&
self
)
-
>
&
AnyObject
{
&
self
.
inner
}
}
#
[
repr
(
C
)
]
#
[
doc
(
alias
=
"
objc_protocol
"
)
]
pub
struct
AnyProtocol
{
inner
:
AnyObject
}
#
[
deprecated
=
"
renamed
to
runtime
:
:
AnyProtocol
"
]
pub
type
Protocol
=
AnyProtocol
;
unsafe
impl
Sync
for
AnyProtocol
{
}
unsafe
impl
Send
for
AnyProtocol
{
}
impl
UnwindSafe
for
AnyProtocol
{
}
impl
RefUnwindSafe
for
AnyProtocol
{
}
impl
AnyProtocol
{
#
[
inline
]
#
[
doc
(
alias
=
"
objc_getProtocol
"
)
]
pub
fn
get
(
name
:
&
CStr
)
-
>
Option
<
&
'
static
Self
>
{
unsafe
{
let
proto
=
ffi
:
:
objc_getProtocol
(
name
.
as_ptr
(
)
)
;
proto
.
cast
:
:
<
Self
>
(
)
.
as_ref
(
)
}
}
#
[
doc
(
alias
=
"
objc_copyProtocolList
"
)
]
pub
fn
protocols
(
)
-
>
MallocSlice
!
(
&
'
static
Self
)
{
unsafe
{
let
mut
count
:
c_uint
=
0
;
let
protocols
:
*
mut
&
Self
=
ffi
:
:
objc_copyProtocolList
(
&
mut
count
)
.
cast
(
)
;
MallocSlice
:
:
from_array
(
protocols
count
as
usize
)
}
}
#
[
doc
(
alias
=
"
protocol_copyProtocolList
"
)
]
pub
fn
adopted_protocols
(
&
self
)
-
>
MallocSlice
!
(
&
AnyProtocol
)
{
unsafe
{
let
mut
count
:
c_uint
=
0
;
let
protocols
:
*
mut
&
AnyProtocol
=
ffi
:
:
protocol_copyProtocolList
(
self
&
mut
count
)
.
cast
(
)
;
MallocSlice
:
:
from_array
(
protocols
count
as
usize
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
protocol_conformsToProtocol
"
)
]
pub
fn
conforms_to
(
&
self
proto
:
&
AnyProtocol
)
-
>
bool
{
unsafe
{
ffi
:
:
protocol_conformsToProtocol
(
self
proto
)
.
as_bool
(
)
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
protocol_getName
"
)
]
pub
fn
name
(
&
self
)
-
>
&
CStr
{
unsafe
{
CStr
:
:
from_ptr
(
ffi
:
:
protocol_getName
(
self
)
)
}
}
fn
method_descriptions_inner
(
&
self
required
:
bool
instance
:
bool
)
-
>
Vec
<
MethodDescription
>
{
let
mut
count
:
c_uint
=
0
;
let
descriptions
=
unsafe
{
ffi
:
:
protocol_copyMethodDescriptionList
(
self
Bool
:
:
new
(
required
)
Bool
:
:
new
(
instance
)
&
mut
count
)
}
;
if
descriptions
.
is_null
(
)
{
return
Vec
:
:
new
(
)
;
}
let
descriptions
=
unsafe
{
MallocSlice
:
:
from_array
(
descriptions
count
as
usize
)
}
;
descriptions
.
iter
(
)
.
map
(
|
desc
|
{
unsafe
{
MethodDescription
:
:
from_raw
(
*
desc
)
}
.
expect
(
"
invalid
method
description
"
)
}
)
.
collect
(
)
}
#
[
allow
(
dead_code
)
]
#
[
doc
(
alias
=
"
protocol_copyMethodDescriptionList
"
)
]
pub
(
crate
)
fn
method_descriptions
(
&
self
required
:
bool
)
-
>
Vec
<
MethodDescription
>
{
self
.
method_descriptions_inner
(
required
true
)
}
#
[
allow
(
dead_code
)
]
#
[
doc
(
alias
=
"
protocol_copyMethodDescriptionList
"
)
]
pub
(
crate
)
fn
class_method_descriptions
(
&
self
required
:
bool
)
-
>
Vec
<
MethodDescription
>
{
self
.
method_descriptions_inner
(
required
false
)
}
}
impl
PartialEq
for
AnyProtocol
{
#
[
inline
]
#
[
doc
(
alias
=
"
protocol_isEqual
"
)
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
unsafe
{
ffi
:
:
protocol_isEqual
(
self
other
)
.
as_bool
(
)
}
}
}
impl
Eq
for
AnyProtocol
{
}
unsafe
impl
RefEncode
for
AnyProtocol
{
const
ENCODING_REF
:
Encoding
=
Encoding
:
:
Object
;
}
unsafe
impl
Message
for
AnyProtocol
{
}
impl
fmt
:
:
Debug
for
AnyProtocol
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
AnyProtocol
"
)
.
field
(
"
name
"
&
self
.
name
(
)
)
.
finish_non_exhaustive
(
)
}
}
impl
fmt
:
:
Display
for
AnyProtocol
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
name
(
)
.
to_string_lossy
(
)
f
)
}
}
impl
AsRef
<
Self
>
for
AnyProtocol
{
fn
as_ref
(
&
self
)
-
>
&
Self
{
self
}
}
impl
AsRef
<
AnyObject
>
for
AnyProtocol
{
fn
as_ref
(
&
self
)
-
>
&
AnyObject
{
&
self
.
inner
}
}
#
[
doc
(
alias
=
"
id
"
)
]
#
[
doc
(
alias
=
"
objc_object
"
)
]
#
[
repr
(
C
)
]
pub
struct
AnyObject
{
_priv
:
[
u8
;
0
]
_p
:
ffi
:
:
OpaqueData
}
#
[
deprecated
=
"
renamed
to
runtime
:
:
AnyObject
.
Consider
using
the
correct
type
from
the
autogenerated
objc2
-
*
framework
crates
instead
though
"
]
pub
type
Object
=
AnyObject
;
unsafe
impl
RefEncode
for
AnyObject
{
const
ENCODING_REF
:
Encoding
=
Encoding
:
:
Object
;
}
unsafe
impl
Message
for
AnyObject
{
}
impl
AnyObject
{
#
[
inline
]
#
[
doc
(
alias
=
"
object_getClass
"
)
]
pub
fn
class
(
&
self
)
-
>
&
'
static
AnyClass
{
let
ptr
=
unsafe
{
ffi
:
:
object_getClass
(
self
)
}
;
let
cls
=
unsafe
{
ptr
.
as_ref
(
)
}
;
cls
.
unwrap_or_else
(
|
|
panic
!
(
"
invalid
object
{
:
?
}
(
had
NULL
class
)
"
self
as
*
const
Self
)
)
}
#
[
inline
]
#
[
doc
(
alias
=
"
object_setClass
"
)
]
pub
unsafe
fn
set_class
<
'
s
>
(
this
:
&
Self
cls
:
&
AnyClass
)
-
>
&
'
s
AnyClass
{
let
this
:
*
const
Self
=
this
;
let
this
=
this
as
*
mut
Self
;
let
ptr
=
unsafe
{
ffi
:
:
object_setClass
(
this
cls
)
}
;
let
old_cls
=
unsafe
{
ptr
.
as_ref
(
)
.
unwrap_unchecked
(
)
}
;
debug_assert_eq
!
(
old_cls
.
instance_size
(
)
cls
.
instance_size
(
)
"
old
and
new
class
sizes
were
not
equal
;
this
is
UB
!
"
)
;
old_cls
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
ivar_at_offset
<
T
>
(
ptr
:
NonNull
<
Self
>
offset
:
isize
)
-
>
NonNull
<
T
>
{
let
ptr
:
NonNull
<
u8
>
=
ptr
.
cast
(
)
;
let
ptr
:
*
mut
u8
=
ptr
.
as_ptr
(
)
;
let
ptr
:
*
mut
u8
=
unsafe
{
ptr
.
offset
(
offset
)
}
;
let
ptr
:
NonNull
<
u8
>
=
unsafe
{
NonNull
:
:
new_unchecked
(
ptr
)
}
;
let
ptr
:
NonNull
<
T
>
=
ptr
.
cast
(
)
;
ptr
}
pub
(
crate
)
fn
lookup_instance_variable_dynamically
(
&
self
name
:
&
str
)
-
>
&
'
static
Ivar
{
let
name
=
CString
:
:
new
(
name
)
.
unwrap
(
)
;
let
cls
=
self
.
class
(
)
;
cls
.
instance_variable
(
&
name
)
.
unwrap_or_else
(
|
|
panic
!
(
"
ivar
{
name
:
?
}
not
found
on
class
{
cls
}
"
)
)
}
#
[
deprecated
=
"
this
is
difficult
to
use
correctly
use
Ivar
:
:
load
instead
.
"
]
pub
unsafe
fn
get_ivar
<
T
:
Encode
>
(
&
self
name
:
&
str
)
-
>
&
T
{
let
ivar
=
self
.
lookup_instance_variable_dynamically
(
name
)
;
unsafe
{
ivar
.
load
:
:
<
T
>
(
self
)
}
}
#
[
deprecated
=
"
this
is
difficult
to
use
correctly
use
Ivar
:
:
load_mut
instead
.
"
]
pub
unsafe
fn
get_mut_ivar
<
T
:
Encode
>
(
&
mut
self
name
:
&
str
)
-
>
&
mut
T
{
let
ivar
=
self
.
lookup_instance_variable_dynamically
(
name
)
;
unsafe
{
ivar
.
load_mut
:
:
<
T
>
(
self
)
}
}
pub
(
crate
)
fn
is_kind_of_class
(
&
self
cls
:
&
AnyClass
)
-
>
Bool
{
unsafe
{
msg_send
!
[
self
isKindOfClass
:
cls
]
}
}
#
[
inline
]
pub
fn
downcast_ref
<
T
:
DowncastTarget
>
(
&
self
)
-
>
Option
<
&
T
>
{
if
self
.
is_kind_of_class
(
T
:
:
class
(
)
)
.
as_bool
(
)
{
Some
(
unsafe
{
&
*
(
self
as
*
const
Self
)
.
cast
:
:
<
T
>
(
)
}
)
}
else
{
None
}
}
}
impl
fmt
:
:
Debug
for
AnyObject
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
ptr
:
*
const
Self
=
self
;
write
!
(
f
"
<
{
}
:
{
:
p
}
>
"
self
.
class
(
)
ptr
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
alloc
:
:
ffi
:
:
CString
;
use
alloc
:
:
format
;
use
alloc
:
:
string
:
:
ToString
;
use
core
:
:
mem
:
:
size_of
;
use
super
:
:
*
;
use
crate
:
:
test_utils
;
use
crate
:
:
{
class
msg_send
sel
ClassType
ProtocolType
}
;
fn
c
(
s
:
&
str
)
-
>
CString
{
CString
:
:
new
(
s
)
.
unwrap
(
)
}
#
[
test
]
fn
test_selector
(
)
{
macro_rules
!
test_sel
{
(
s
:
literal
(
tt
:
tt
)
+
)
=
>
{
{
let
sel
=
sel
!
(
(
tt
)
*
)
;
let
expected
=
Sel
:
:
register
(
&
c
(
s
)
)
;
assert_eq
!
(
sel
expected
)
;
assert_eq
!
(
sel
.
name
(
)
.
to_str
(
)
Ok
(
s
)
)
;
}
}
}
test_sel
!
(
"
abc
"
abc
)
;
test_sel
!
(
"
abc
:
"
abc
:
)
;
test_sel
!
(
"
abc
:
def
:
"
abc
:
def
:
)
;
test_sel
!
(
"
abc
:
def
:
ghi
:
"
abc
:
def
:
ghi
:
)
;
test_sel
!
(
"
functionWithControlPoints
:
:
:
:
"
functionWithControlPoints
:
:
:
:
)
;
test_sel
!
(
"
initWithControlPoints
:
:
:
:
"
initWithControlPoints
:
:
:
:
)
;
test_sel
!
(
"
setFloatValue
:
:
"
setFloatValue
:
:
)
;
test_sel
!
(
"
isSupported
:
:
"
isSupported
:
:
)
;
test_sel
!
(
"
addEventListener
:
:
:
"
addEventListener
:
:
:
)
;
test_sel
!
(
"
test
:
:
arg
:
:
"
test
:
:
arg
:
:
)
;
test_sel
!
(
"
test
:
:
:
:
with
:
:
spaces
:
:
"
test
:
:
:
:
with
:
:
spaces
:
:
)
;
test_sel
!
(
"
a
:
:
b
:
"
a
:
:
b
:
)
;
}
#
[
test
]
fn
test_empty_selector
(
)
{
let
s
=
c
(
"
"
)
;
let
sel
=
Sel
:
:
register
(
&
s
)
;
assert_eq
!
(
sel
.
name
(
)
&
*
s
)
;
let
s
=
c
(
"
:
"
)
;
let
sel
=
Sel
:
:
register
(
&
s
)
;
assert_eq
!
(
sel
.
name
(
)
&
*
s
)
;
let
s
=
c
(
"
:
:
"
)
;
let
sel
=
Sel
:
:
register
(
&
s
)
;
assert_eq
!
(
sel
.
name
(
)
&
*
s
)
;
}
#
[
test
]
fn
test_ivar
(
)
{
let
cls
=
test_utils
:
:
custom_class
(
)
;
let
ivar
=
cls
.
instance_variable
(
&
c
(
"
_foo
"
)
)
.
unwrap
(
)
;
assert_eq
!
(
ivar
.
name
(
)
&
*
c
(
"
_foo
"
)
)
;
assert
!
(
<
u32
>
:
:
ENCODING
.
equivalent_to_str
(
ivar
.
type_encoding
(
)
.
to_str
(
)
.
unwrap
(
)
)
)
;
assert
!
(
ivar
.
offset
(
)
>
0
)
;
assert
!
(
cls
.
instance_variables
(
)
.
len
(
)
>
0
)
;
}
#
[
test
]
fn
test_instance_method
(
)
{
let
cls
=
test_utils
:
:
custom_class
(
)
;
let
sel
=
Sel
:
:
register
(
&
c
(
"
foo
"
)
)
;
let
method
=
cls
.
instance_method
(
sel
)
.
unwrap
(
)
;
assert_eq
!
(
method
.
name
(
)
.
name
(
)
&
*
c
(
"
foo
"
)
)
;
assert_eq
!
(
method
.
arguments_count
(
)
2
)
;
assert
!
(
<
u32
>
:
:
ENCODING
.
equivalent_to_str
(
method
.
return_type
(
)
.
to_str
(
)
.
unwrap
(
)
)
)
;
assert
!
(
Sel
:
:
ENCODING
.
equivalent_to_str
(
method
.
argument_type
(
1
)
.
unwrap
(
)
.
to_str
(
)
.
unwrap
(
)
)
)
;
assert
!
(
cls
.
instance_methods
(
)
.
contains
(
&
method
)
)
;
}
#
[
test
]
fn
test_class_method
(
)
{
let
cls
=
test_utils
:
:
custom_class
(
)
;
let
method
=
cls
.
class_method
(
sel
!
(
classFoo
)
)
.
unwrap
(
)
;
assert_eq
!
(
method
.
name
(
)
.
name
(
)
&
*
c
(
"
classFoo
"
)
)
;
assert_eq
!
(
method
.
arguments_count
(
)
2
)
;
assert
!
(
<
u32
>
:
:
ENCODING
.
equivalent_to_str
(
method
.
return_type
(
)
.
to_str
(
)
.
unwrap
(
)
)
)
;
assert
!
(
Sel
:
:
ENCODING
.
equivalent_to_str
(
method
.
argument_type
(
1
)
.
unwrap
(
)
.
to_str
(
)
.
unwrap
(
)
)
)
;
assert
!
(
cls
.
metaclass
(
)
.
instance_methods
(
)
.
contains
(
&
method
)
)
;
}
#
[
test
]
fn
test_class
(
)
{
let
cls
=
test_utils
:
:
custom_class
(
)
;
assert_eq
!
(
cls
.
name
(
)
&
*
c
(
"
CustomObject
"
)
)
;
assert
!
(
cls
.
instance_size
(
)
>
0
)
;
assert
!
(
cls
.
superclass
(
)
.
is_none
(
)
)
;
assert
!
(
cls
.
responds_to
(
sel
!
(
foo
)
)
)
;
assert
!
(
cls
.
responds_to
(
sel
!
(
setBar
:
)
)
)
;
assert
!
(
cls
.
responds_to
(
sel
!
(
test
:
:
test
:
:
)
)
)
;
assert
!
(
!
cls
.
responds_to
(
sel
!
(
abc
)
)
)
;
assert
!
(
!
cls
.
responds_to
(
sel
!
(
addNumber
:
toNumber
:
)
)
)
;
assert_eq
!
(
AnyClass
:
:
get
(
cls
.
name
(
)
)
Some
(
cls
)
)
;
let
metaclass
=
cls
.
metaclass
(
)
;
assert_eq
!
(
metaclass
.
superclass
(
)
.
unwrap
(
)
cls
)
;
assert
!
(
metaclass
.
responds_to
(
sel
!
(
addNumber
:
toNumber
:
)
)
)
;
assert
!
(
metaclass
.
responds_to
(
sel
!
(
test
:
:
test
:
:
)
)
)
;
assert
!
(
metaclass
.
responds_to
(
sel
!
(
foo
)
)
)
;
let
subclass
=
test_utils
:
:
custom_subclass
(
)
;
assert_eq
!
(
subclass
.
superclass
(
)
.
unwrap
(
)
cls
)
;
}
#
[
test
]
fn
test_classes_count
(
)
{
assert
!
(
AnyClass
:
:
classes_count
(
)
>
0
)
;
}
#
[
test
]
fn
test_classes
(
)
{
let
classes
=
AnyClass
:
:
classes
(
)
;
assert
!
(
classes
.
len
(
)
>
0
)
;
}
#
[
test
]
fn
test_protocol
(
)
{
let
proto
=
test_utils
:
:
custom_protocol
(
)
;
assert_eq
!
(
proto
.
name
(
)
&
*
c
(
"
CustomProtocol
"
)
)
;
let
class
=
test_utils
:
:
custom_class
(
)
;
assert
!
(
class
.
conforms_to
(
proto
)
)
;
if
cfg
!
(
any
(
not
(
feature
=
"
gnustep
-
1
-
7
"
)
feature
=
"
gnustep
-
2
-
0
"
)
)
{
let
desc
=
MethodDescription
{
sel
:
sel
!
(
setBar
:
)
types
:
CStr
:
:
from_bytes_with_nul
(
b
"
v
:
i
\
0
"
)
.
unwrap
(
)
}
;
assert_eq
!
(
&
proto
.
method_descriptions
(
true
)
&
[
desc
]
)
;
let
desc
=
MethodDescription
{
sel
:
sel
!
(
getName
)
types
:
CStr
:
:
from_bytes_with_nul
(
b
"
*
:
\
0
"
)
.
unwrap
(
)
}
;
assert_eq
!
(
&
proto
.
method_descriptions
(
false
)
&
[
desc
]
)
;
let
desc
=
MethodDescription
{
sel
:
sel
!
(
addNumber
:
toNumber
:
)
types
:
CStr
:
:
from_bytes_with_nul
(
b
"
i
:
ii
\
0
"
)
.
unwrap
(
)
}
;
assert_eq
!
(
&
proto
.
class_method_descriptions
(
true
)
&
[
desc
]
)
;
}
assert_eq
!
(
&
proto
.
class_method_descriptions
(
false
)
&
[
]
)
;
assert
!
(
class
.
adopted_protocols
(
)
.
contains
(
&
proto
)
)
;
}
#
[
test
]
fn
test_protocol_method
(
)
{
let
class
=
test_utils
:
:
custom_class
(
)
;
let
result
:
i32
=
unsafe
{
msg_send
!
[
class
addNumber
:
1
toNumber
:
2
]
}
;
assert_eq
!
(
result
3
)
;
}
#
[
test
]
fn
class_self
(
)
{
let
cls
=
NSObject
:
:
class
(
)
;
let
result
:
&
'
static
AnyClass
=
unsafe
{
msg_send
!
[
cls
self
]
}
;
assert_eq
!
(
cls
result
)
;
}
#
[
test
]
fn
test_subprotocols
(
)
{
let
sub_proto
=
test_utils
:
:
custom_subprotocol
(
)
;
let
super_proto
=
test_utils
:
:
custom_protocol
(
)
;
assert
!
(
sub_proto
.
conforms_to
(
super_proto
)
)
;
assert_eq
!
(
sub_proto
.
adopted_protocols
(
)
[
0
]
super_proto
)
;
}
#
[
test
]
fn
test_protocols
(
)
{
let
_
=
test_utils
:
:
custom_protocol
(
)
;
assert
!
(
AnyProtocol
:
:
protocols
(
)
.
len
(
)
>
0
)
;
}
#
[
test
]
fn
test_object
(
)
{
let
obj
=
test_utils
:
:
custom_object
(
)
;
let
cls
=
test_utils
:
:
custom_class
(
)
;
assert_eq
!
(
obj
.
class
(
)
cls
)
;
let
ivar
=
cls
.
instance_variable
(
&
c
(
"
_foo
"
)
)
.
unwrap
(
)
;
unsafe
{
*
ivar
.
load_ptr
:
:
<
u32
>
(
&
obj
)
=
4
}
;
let
result
=
unsafe
{
*
ivar
.
load
:
:
<
u32
>
(
&
obj
)
}
;
assert_eq
!
(
result
4
)
;
}
#
[
test
]
fn
test_object_ivar_unknown
(
)
{
let
cls
=
test_utils
:
:
custom_class
(
)
;
assert_eq
!
(
cls
.
instance_variable
(
&
c
(
"
unknown
"
)
)
None
)
;
}
#
[
test
]
fn
test_no_ivars
(
)
{
let
cls
=
ClassBuilder
:
:
new
(
&
c
(
"
NoIvarObject
"
)
NSObject
:
:
class
(
)
)
.
unwrap
(
)
.
register
(
)
;
assert_eq
!
(
cls
.
instance_variables
(
)
.
len
(
)
0
)
;
}
#
[
test
]
#
[
cfg_attr
(
all
(
debug_assertions
not
(
feature
=
"
disable
-
encoding
-
assertions
"
)
)
should_panic
=
"
wrong
encoding
.
Tried
to
retrieve
ivar
with
encoding
I
but
the
encoding
of
the
given
type
was
C
"
)
]
fn
test_object_ivar_wrong_type
(
)
{
let
obj
=
test_utils
:
:
custom_object
(
)
;
let
cls
=
test_utils
:
:
custom_class
(
)
;
let
ivar
=
cls
.
instance_variable
(
&
c
(
"
_foo
"
)
)
.
unwrap
(
)
;
let
_
=
unsafe
{
*
ivar
.
load
:
:
<
u8
>
(
&
obj
)
}
;
}
#
[
test
]
fn
test_encode
(
)
{
fn
assert_enc
<
T
:
Encode
>
(
expected
:
&
str
)
{
assert_eq
!
(
&
T
:
:
ENCODING
.
to_string
(
)
expected
)
;
}
assert_enc
:
:
<
&
AnyObject
>
(
"
"
)
;
assert_enc
:
:
<
*
mut
AnyObject
>
(
"
"
)
;
assert_enc
:
:
<
&
AnyClass
>
(
"
#
"
)
;
assert_enc
:
:
<
Sel
>
(
"
:
"
)
;
assert_enc
:
:
<
Option
<
Sel
>
>
(
"
:
"
)
;
assert_enc
:
:
<
Imp
>
(
"
^
?
"
)
;
assert_enc
:
:
<
Option
<
Imp
>
>
(
"
^
?
"
)
;
assert_enc
:
:
<
&
AnyProtocol
>
(
"
"
)
;
}
#
[
test
]
fn
test_send_sync
(
)
{
fn
assert_send_sync
<
T
:
Send
+
Sync
+
?
Sized
>
(
)
{
}
assert_send_sync
:
:
<
Bool
>
(
)
;
assert_send_sync
:
:
<
AnyClass
>
(
)
;
assert_send_sync
:
:
<
Ivar
>
(
)
;
assert_send_sync
:
:
<
Method
>
(
)
;
assert_send_sync
:
:
<
AnyProtocol
>
(
)
;
assert_send_sync
:
:
<
Sel
>
(
)
;
}
#
[
test
]
fn
test_debug_display
(
)
{
let
sel
=
sel
!
(
abc
:
)
;
assert_eq
!
(
format
!
(
"
{
sel
}
"
)
"
abc
:
"
)
;
assert_eq
!
(
format
!
(
"
{
sel
:
?
}
"
)
"
Sel
(
\
"
abc
:
\
"
)
"
)
;
let
cls
=
test_utils
:
:
custom_class
(
)
;
assert_eq
!
(
format
!
(
"
{
cls
}
"
)
"
CustomObject
"
)
;
assert_eq
!
(
format
!
(
"
{
cls
:
?
}
"
)
"
AnyClass
{
name
:
\
"
CustomObject
\
"
.
.
}
"
)
;
let
protocol
=
test_utils
:
:
custom_protocol
(
)
;
assert_eq
!
(
format
!
(
"
{
protocol
}
"
)
"
CustomProtocol
"
)
;
assert_eq
!
(
format
!
(
"
{
protocol
:
?
}
"
)
"
AnyProtocol
{
name
:
\
"
CustomProtocol
\
"
.
.
}
"
)
;
let
object
=
test_utils
:
:
custom_object
(
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
&
*
object
)
format
!
(
"
CustomObject
(
<
CustomObject
:
{
:
p
}
>
)
"
&
*
object
)
)
;
}
#
[
test
]
fn
test_multiple_colon
(
)
{
let
class
=
test_utils
:
:
custom_class
(
)
;
let
res
:
i32
=
unsafe
{
MessageReceiver
:
:
send_message
(
class
sel
!
(
test
:
:
test
:
:
)
(
1i32
2i32
3i32
4i32
)
)
}
;
assert_eq
!
(
res
10
)
;
let
obj
=
test_utils
:
:
custom_object
(
)
;
let
res
:
i32
=
unsafe
{
MessageReceiver
:
:
send_message
(
&
*
obj
sel
!
(
test
:
:
test
:
:
)
(
1i32
2i32
3i32
4i32
)
)
}
;
assert_eq
!
(
res
24
)
;
}
#
[
test
]
fn
test_sizes
(
)
{
assert_eq
!
(
size_of
:
:
<
Sel
>
(
)
size_of
:
:
<
*
const
(
)
>
(
)
)
;
assert_eq
!
(
size_of
:
:
<
Sel
>
(
)
size_of
:
:
<
Option
<
Sel
>
>
(
)
)
;
assert_eq
!
(
size_of
:
:
<
AnyClass
>
(
)
0
)
;
assert_eq
!
(
size_of
:
:
<
AnyObject
>
(
)
0
)
;
assert_eq
!
(
size_of
:
:
<
AnyProtocol
>
(
)
0
)
;
assert_eq
!
(
size_of
:
:
<
Ivar
>
(
)
0
)
;
assert_eq
!
(
size_of
:
:
<
Method
>
(
)
0
)
;
}
fn
get_ivar_layout
(
cls
:
&
AnyClass
)
-
>
*
const
u8
{
unsafe
{
ffi
:
:
class_getIvarLayout
(
cls
)
}
}
#
[
test
]
#
[
cfg_attr
(
feature
=
"
gnustep
-
1
-
7
"
ignore
=
"
ivar
layout
is
still
used
on
GNUStep
"
)
]
fn
test_layout_does_not_matter_any_longer
(
)
{
assert
!
(
get_ivar_layout
(
class
!
(
NSObject
)
)
.
is_null
(
)
)
;
assert
!
(
get_ivar_layout
(
class
!
(
NSArray
)
)
.
is_null
(
)
)
;
assert
!
(
get_ivar_layout
(
class
!
(
NSException
)
)
.
is_null
(
)
)
;
assert
!
(
get_ivar_layout
(
class
!
(
NSNumber
)
)
.
is_null
(
)
)
;
assert
!
(
get_ivar_layout
(
class
!
(
NSString
)
)
.
is_null
(
)
)
;
}
#
[
test
]
fn
test_non_utf8_roundtrip
(
)
{
let
s
=
CStr
:
:
from_bytes_with_nul
(
b
"
\
x9F
\
0
"
)
.
unwrap
(
)
;
let
sel
=
Sel
:
:
register
(
s
)
;
assert_eq
!
(
sel
.
name
(
)
s
)
;
assert_eq
!
(
sel
.
to_string
(
)
char
:
:
REPLACEMENT_CHARACTER
.
to_string
(
)
)
;
let
cls
=
ClassBuilder
:
:
new
(
s
NSObject
:
:
class
(
)
)
.
unwrap
(
)
.
register
(
)
;
assert_eq
!
(
cls
.
name
(
)
s
)
;
assert_eq
!
(
cls
.
to_string
(
)
char
:
:
REPLACEMENT_CHARACTER
.
to_string
(
)
)
;
let
cls_runtime
=
AnyClass
:
:
get
(
s
)
.
unwrap
(
)
;
assert_eq
!
(
cls
cls_runtime
)
;
}
#
[
test
]
fn
class_is_object
(
)
{
let
cls
=
NSObject
:
:
class
(
)
;
let
retained
=
cls
.
retain
(
)
;
assert_eq
!
(
&
*
retained
cls
)
;
let
obj
:
&
AnyObject
=
cls
.
as_ref
(
)
;
let
superclass
=
obj
.
class
(
)
;
assert
!
(
superclass
.
conforms_to
(
<
dyn
NSObjectProtocol
>
:
:
protocol
(
)
.
unwrap
(
)
)
)
;
let
ns_obj
=
retained
.
downcast
:
:
<
NSObject
>
(
)
.
unwrap
(
)
;
assert_eq
!
(
ns_obj
ns_obj
)
;
let
_
=
ns_obj
.
retainCount
(
)
;
}
#
[
test
]
fn
class_has_infinite_retain_count
(
)
{
let
obj
:
&
AnyObject
=
NSObject
:
:
class
(
)
.
as_ref
(
)
;
let
obj
=
obj
.
downcast_ref
:
:
<
NSObject
>
(
)
.
unwrap
(
)
;
let
large_retain
=
if
cfg
!
(
feature
=
"
gnustep
-
1
-
7
"
)
{
u32
:
:
MAX
as
usize
}
else
{
usize
:
:
MAX
}
;
assert_eq
!
(
obj
.
retainCount
(
)
large_retain
)
;
let
obj2
=
obj
.
retain
(
)
;
assert_eq
!
(
obj
.
retainCount
(
)
large_retain
)
;
drop
(
obj2
)
;
assert_eq
!
(
obj
.
retainCount
(
)
large_retain
)
;
}
#
[
test
]
fn
protocol_is_object
(
)
{
let
protocol
=
<
dyn
NSObjectProtocol
>
:
:
protocol
(
)
.
unwrap
(
)
;
let
retained
=
protocol
.
retain
(
)
;
assert_eq
!
(
&
*
retained
protocol
)
;
if
cfg
!
(
feature
=
"
gnustep
-
1
-
7
"
)
{
return
;
}
if
cfg
!
(
all
(
target_os
=
"
macos
"
target_arch
=
"
x86
"
)
)
{
let
_
=
retained
.
downcast
:
:
<
NSObject
>
(
)
.
unwrap_err
(
)
;
}
else
{
let
obj
=
retained
.
downcast
:
:
<
NSObject
>
(
)
.
unwrap
(
)
;
assert_eq
!
(
obj
obj
)
;
let
_
=
obj
.
retainCount
(
)
;
}
}
}
