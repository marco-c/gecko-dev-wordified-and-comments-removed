use
core
:
:
ffi
:
:
{
c_char
c_void
CStr
}
;
use
core
:
:
ptr
;
use
core
:
:
str
;
use
core
:
:
sync
:
:
atomic
:
:
{
AtomicPtr
Ordering
}
;
use
crate
:
:
ffi
;
use
crate
:
:
runtime
:
:
{
AnyClass
Sel
}
;
#
[
derive
(
Debug
)
]
pub
struct
CachedSel
{
ptr
:
AtomicPtr
<
c_void
>
}
impl
CachedSel
{
#
[
allow
(
clippy
:
:
new_without_default
)
]
pub
const
fn
new
(
)
-
>
Self
{
Self
{
ptr
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
}
}
#
[
cold
]
unsafe
fn
fetch
(
&
self
name
:
*
const
c_char
)
-
>
Sel
{
let
sel
=
unsafe
{
Sel
:
:
register_unchecked
(
name
)
}
;
self
.
ptr
.
store
(
sel
.
as_ptr
(
)
as
*
mut
_
Ordering
:
:
Relaxed
)
;
sel
}
#
[
inline
]
pub
unsafe
fn
get
(
&
self
name
:
&
str
)
-
>
Sel
{
let
ptr
=
self
.
ptr
.
load
(
Ordering
:
:
Relaxed
)
;
if
let
Some
(
sel
)
=
unsafe
{
Sel
:
:
from_ptr
(
ptr
)
}
{
sel
}
else
{
unsafe
{
self
.
fetch
(
name
.
as_ptr
(
)
.
cast
(
)
)
}
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
CachedClass
{
ptr
:
AtomicPtr
<
AnyClass
>
}
impl
CachedClass
{
#
[
allow
(
clippy
:
:
new_without_default
)
]
pub
const
fn
new
(
)
-
>
CachedClass
{
CachedClass
{
ptr
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
}
}
#
[
cold
]
#
[
track_caller
]
unsafe
fn
fetch
(
&
self
name
:
*
const
c_char
)
-
>
&
'
static
AnyClass
{
let
ptr
:
*
const
AnyClass
=
unsafe
{
ffi
:
:
objc_getClass
(
name
)
}
.
cast
(
)
;
self
.
ptr
.
store
(
ptr
as
*
mut
AnyClass
Ordering
:
:
Relaxed
)
;
if
let
Some
(
cls
)
=
unsafe
{
ptr
.
as_ref
(
)
}
{
cls
}
else
{
let
name
=
unsafe
{
CStr
:
:
from_ptr
(
name
)
}
;
let
name
=
str
:
:
from_utf8
(
name
.
to_bytes
(
)
)
.
unwrap
(
)
;
panic
!
(
"
class
{
name
}
could
not
be
found
"
)
}
}
#
[
inline
]
#
[
track_caller
]
pub
unsafe
fn
get
(
&
self
name
:
&
str
)
-
>
&
'
static
AnyClass
{
let
ptr
=
self
.
ptr
.
load
(
Ordering
:
:
Relaxed
)
;
if
let
Some
(
cls
)
=
unsafe
{
ptr
.
as_ref
(
)
}
{
cls
}
else
{
unsafe
{
self
.
fetch
(
name
.
as_ptr
(
)
.
cast
(
)
)
}
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
#
[
test
]
#
[
should_panic
=
"
class
NonExistentClass
could
not
be
found
"
]
#
[
cfg
(
not
(
feature
=
"
unstable
-
static
-
class
"
)
)
]
fn
test_not_found
(
)
{
let
_
=
crate
:
:
class
!
(
NonExistentClass
)
;
}
}
