use
crate
:
:
__sel_inner
;
use
crate
:
:
runtime
:
:
Sel
;
#
[
inline
]
pub
fn
alloc_sel
(
)
-
>
Sel
{
__sel_inner
!
(
"
alloc
\
0
"
"
alloc
"
)
}
#
[
inline
]
pub
fn
init_sel
(
)
-
>
Sel
{
__sel_inner
!
(
"
init
\
0
"
"
init
"
)
}
#
[
inline
]
pub
fn
new_sel
(
)
-
>
Sel
{
__sel_inner
!
(
"
new
\
0
"
"
new
"
)
}
#
[
inline
]
pub
fn
dealloc_sel
(
)
-
>
Sel
{
__sel_inner
!
(
"
dealloc
\
0
"
"
dealloc
"
)
}
#
[
inline
]
#
[
allow
(
dead_code
)
]
fn
cxx_construct_sel
(
)
-
>
Sel
{
__sel_inner
!
(
"
.
cxx_construct
\
0
"
"
.
cxx_construct
"
)
}
#
[
inline
]
#
[
allow
(
dead_code
)
]
fn
cxx_destruct_sel
(
)
-
>
Sel
{
__sel_inner
!
(
"
.
cxx_destruct
\
0
"
"
.
cxx_destruct
"
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
alloc
:
:
ffi
:
:
CString
;
use
core
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
crate
:
:
rc
:
:
Retained
;
use
crate
:
:
runtime
:
:
ClassBuilder
;
use
crate
:
:
runtime
:
:
NSObject
;
use
crate
:
:
{
msg_send
ClassType
}
;
use
super
:
:
*
;
#
[
test
]
fn
test_destruct_dynamic
(
)
{
static
HAS_RUN
:
AtomicBool
=
AtomicBool
:
:
new
(
false
)
;
let
name
=
CString
:
:
new
(
"
TestCxxDestruct
"
)
.
unwrap
(
)
;
let
mut
builder
=
ClassBuilder
:
:
new
(
&
name
NSObject
:
:
class
(
)
)
.
unwrap
(
)
;
unsafe
extern
"
C
"
fn
destruct
(
_
:
*
mut
NSObject
_
:
Sel
)
{
HAS_RUN
.
store
(
true
Ordering
:
:
Relaxed
)
;
}
unsafe
{
builder
.
add_method
(
cxx_destruct_sel
(
)
destruct
as
unsafe
extern
"
C
"
fn
(
_
_
)
)
}
;
let
cls
=
builder
.
register
(
)
;
let
obj
:
Retained
<
NSObject
>
=
unsafe
{
msg_send
!
[
cls
new
]
}
;
drop
(
obj
)
;
let
has_run_destruct
=
HAS_RUN
.
load
(
Ordering
:
:
Relaxed
)
;
if
cfg
!
(
feature
=
"
gnustep
-
1
-
7
"
)
{
assert
!
(
has_run_destruct
)
;
}
else
{
assert
!
(
!
has_run_destruct
)
;
}
}
}
