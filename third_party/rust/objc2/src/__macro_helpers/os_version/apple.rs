use
core
:
:
ffi
:
:
{
c_char
c_int
c_uint
c_void
CStr
}
;
use
core
:
:
ptr
:
:
null_mut
;
use
core
:
:
sync
:
:
atomic
:
:
{
AtomicU32
Ordering
}
;
use
std
:
:
env
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
fs
;
use
std
:
:
os
:
:
unix
:
:
ffi
:
:
OsStringExt
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
super
:
:
OSVersion
;
pub
(
crate
)
const
DEPLOYMENT_TARGET
:
OSVersion
=
{
#
[
cfg
(
target_os
=
"
macos
"
)
]
let
var
=
option_env
!
(
"
MACOSX_DEPLOYMENT_TARGET
"
)
;
#
[
cfg
(
target_os
=
"
ios
"
)
]
let
var
=
option_env
!
(
"
IPHONEOS_DEPLOYMENT_TARGET
"
)
;
#
[
cfg
(
target_os
=
"
tvos
"
)
]
let
var
=
option_env
!
(
"
TVOS_DEPLOYMENT_TARGET
"
)
;
#
[
cfg
(
target_os
=
"
watchos
"
)
]
let
var
=
option_env
!
(
"
WATCHOS_DEPLOYMENT_TARGET
"
)
;
#
[
cfg
(
target_os
=
"
visionos
"
)
]
let
var
=
option_env
!
(
"
XROS_DEPLOYMENT_TARGET
"
)
;
if
let
Some
(
var
)
=
var
{
OSVersion
:
:
from_str
(
var
)
}
else
{
#
[
allow
(
clippy
:
:
if_same_then_else
)
]
let
os_min
=
if
cfg
!
(
target_os
=
"
macos
"
)
{
(
10
12
0
)
}
else
if
cfg
!
(
target_os
=
"
ios
"
)
{
(
10
0
0
)
}
else
if
cfg
!
(
target_os
=
"
tvos
"
)
{
(
10
0
0
)
}
else
if
cfg
!
(
target_os
=
"
watchos
"
)
{
(
5
0
0
)
}
else
if
cfg
!
(
target_os
=
"
visionos
"
)
{
(
1
0
0
)
}
else
{
panic
!
(
"
unknown
Apple
OS
"
)
}
;
#
[
allow
(
clippy
:
:
if_same_then_else
)
]
let
min
=
if
cfg
!
(
all
(
target_os
=
"
macos
"
target_arch
=
"
aarch64
"
)
)
{
(
11
0
0
)
}
else
if
cfg
!
(
all
(
target_os
=
"
ios
"
target_arch
=
"
aarch64
"
target_abi_macabi
)
)
{
(
14
0
0
)
}
else
if
cfg
!
(
all
(
target_os
=
"
ios
"
target_arch
=
"
aarch64
"
target_simulator
)
)
{
(
14
0
0
)
}
else
if
cfg
!
(
all
(
target_os
=
"
tvos
"
target_arch
=
"
aarch64
"
)
)
{
(
14
0
0
)
}
else
if
cfg
!
(
all
(
target_os
=
"
watchos
"
target_arch
=
"
aarch64
"
)
)
{
(
7
0
0
)
}
else
{
os_min
}
;
OSVersion
{
major
:
min
.
0
minor
:
min
.
1
patch
:
min
.
2
}
}
}
;
#
[
inline
]
pub
(
crate
)
fn
current_version
(
)
-
>
OSVersion
{
static
CURRENT_VERSION
:
AtomicU32
=
AtomicU32
:
:
new
(
0
)
;
let
version
=
CURRENT_VERSION
.
load
(
Ordering
:
:
Relaxed
)
;
OSVersion
:
:
from_u32
(
if
version
=
=
0
{
let
version
=
lookup_version
(
)
;
CURRENT_VERSION
.
store
(
version
Ordering
:
:
Relaxed
)
;
version
}
else
{
version
}
)
}
#
[
cold
]
extern
"
C
"
fn
lookup_version
(
)
-
>
u32
{
let
version
=
version_from_sysctl
(
)
.
unwrap_or_else
(
version_from_plist
)
;
assert_ne
!
(
version
OSVersion
:
:
MIN
"
version
cannot
be
0
.
0
.
0
"
)
;
version
.
to_u32
(
)
}
fn
version_from_sysctl
(
)
-
>
Option
<
OSVersion
>
{
if
cfg
!
(
target_simulator
)
{
return
None
;
}
extern
"
C
"
{
fn
sysctlbyname
(
name
:
*
const
c_char
oldp
:
*
mut
c_void
oldlenp
:
*
mut
usize
newp
:
*
mut
c_void
newlen
:
usize
)
-
>
c_uint
;
}
let
sysctl_version
=
|
name
:
&
[
u8
]
|
{
let
mut
buf
:
[
u8
;
32
]
=
[
0
;
32
]
;
let
mut
size
=
buf
.
len
(
)
;
let
ptr
=
buf
.
as_mut_ptr
(
)
.
cast
(
)
;
let
ret
=
unsafe
{
sysctlbyname
(
name
.
as_ptr
(
)
.
cast
(
)
ptr
&
mut
size
null_mut
(
)
0
)
}
;
if
ret
!
=
0
{
return
None
;
}
let
buf
=
&
buf
[
.
.
(
size
-
1
)
]
;
if
buf
.
is_empty
(
)
{
return
None
;
}
Some
(
OSVersion
:
:
from_bytes
(
buf
)
)
}
;
if
cfg
!
(
target_os
=
"
ios
"
)
{
if
let
Some
(
ios_support_version
)
=
sysctl_version
(
b
"
kern
.
iossupportversion
\
0
"
)
{
return
Some
(
ios_support_version
)
;
}
if
cfg
!
(
target_abi_macabi
)
{
return
None
;
}
}
sysctl_version
(
b
"
kern
.
osproductversion
\
0
"
)
}
fn
version_from_plist
(
)
-
>
OSVersion
{
let
root
=
if
cfg
!
(
target_simulator
)
{
PathBuf
:
:
from
(
env
:
:
var_os
(
"
IPHONE_SIMULATOR_ROOT
"
)
.
expect
(
"
environment
variable
IPHONE_SIMULATOR_ROOT
must
be
set
when
executing
under
simulator
"
)
)
}
else
{
PathBuf
:
:
from
(
"
/
"
)
}
;
let
path
=
root
.
join
(
"
System
/
Library
/
CoreServices
/
SystemVersion
.
plist
"
)
;
let
plist_buffer
=
fs
:
:
read
(
&
path
)
.
unwrap_or_else
(
|
e
|
panic
!
(
"
failed
reading
{
path
:
?
}
:
{
e
}
"
)
)
;
parse_version_from_plist
(
&
root
&
plist_buffer
)
}
#
[
allow
(
non_upper_case_globals
non_snake_case
)
]
fn
parse_version_from_plist
(
root
:
&
Path
plist_buffer
:
&
[
u8
]
)
-
>
OSVersion
{
const
RTLD_LAZY
:
c_int
=
0x1
;
const
RTLD_LOCAL
:
c_int
=
0x4
;
extern
"
C
"
{
fn
dlopen
(
filename
:
*
const
c_char
flag
:
c_int
)
-
>
*
mut
c_void
;
fn
dlsym
(
handle
:
*
mut
c_void
symbol
:
*
const
c_char
)
-
>
*
mut
c_void
;
fn
dlerror
(
)
-
>
*
mut
c_char
;
fn
dlclose
(
handle
:
*
mut
c_void
)
-
>
c_int
;
}
let
cf_path
=
root
.
join
(
"
System
/
Library
/
Frameworks
/
CoreFoundation
.
framework
/
CoreFoundation
"
)
;
let
cf_path
=
CString
:
:
new
(
cf_path
.
into_os_string
(
)
.
into_vec
(
)
)
.
expect
(
"
failed
allocating
string
"
)
;
let
cf_handle
=
unsafe
{
dlopen
(
cf_path
.
as_ptr
(
)
RTLD_LAZY
|
RTLD_LOCAL
)
}
;
if
cf_handle
.
is_null
(
)
{
let
err
=
unsafe
{
CStr
:
:
from_ptr
(
dlerror
(
)
)
}
;
panic
!
(
"
could
not
open
CoreFoundation
.
framework
:
{
err
:
?
}
"
)
;
}
let
_cf_handle_free
=
Deferred
(
|
|
{
let
_
=
unsafe
{
dlclose
(
cf_handle
)
}
;
}
)
;
macro_rules
!
dlsym
{
(
unsafe
fn
name
:
ident
(
(
param
:
ident
:
param_ty
:
ty
)
*
(
)
?
)
(
-
>
ret
:
ty
)
?
;
)
=
>
{
{
let
ptr
=
unsafe
{
dlsym
(
cf_handle
concat
!
(
stringify
!
(
name
)
'
\
0
'
)
.
as_bytes
(
)
.
as_ptr
(
)
.
cast
(
)
)
}
;
if
ptr
.
is_null
(
)
{
let
err
=
unsafe
{
CStr
:
:
from_ptr
(
dlerror
(
)
)
}
;
panic
!
(
"
could
not
find
function
{
}
:
{
err
:
?
}
"
stringify
!
(
name
)
)
;
}
/
/
SAFETY
:
Just
checked
that
the
symbol
isn
'
t
NULL
and
caller
verifies
that
the
/
/
signature
is
correct
.
unsafe
{
core
:
:
mem
:
:
transmute
:
:
<
*
mut
c_void
unsafe
extern
"
C
"
fn
(
(
param_ty
)
*
)
(
-
>
ret
)
?
>
(
ptr
)
}
}
}
;
}
type
Boolean
=
u8
;
type
CFTypeID
=
usize
;
type
CFOptionFlags
=
usize
;
type
CFIndex
=
isize
;
type
CFTypeRef
=
*
mut
c_void
;
type
CFAllocatorRef
=
CFTypeRef
;
const
kCFAllocatorDefault
:
CFAllocatorRef
=
null_mut
(
)
;
let
allocator_null
=
unsafe
{
dlsym
(
cf_handle
b
"
kCFAllocatorNull
\
0
"
.
as_ptr
(
)
.
cast
(
)
)
}
;
if
allocator_null
.
is_null
(
)
{
let
err
=
unsafe
{
CStr
:
:
from_ptr
(
dlerror
(
)
)
}
;
panic
!
(
"
could
not
find
kCFAllocatorNull
:
{
err
:
?
}
"
)
;
}
let
kCFAllocatorNull
=
unsafe
{
*
allocator_null
.
cast
:
:
<
CFAllocatorRef
>
(
)
}
;
let
CFRelease
=
dlsym
!
(
/
/
Available
:
in
all
CF
versions
.
unsafe
fn
CFRelease
(
cf
:
CFTypeRef
)
;
)
;
let
CFGetTypeID
=
dlsym
!
(
/
/
Available
:
in
all
CF
versions
.
unsafe
fn
CFGetTypeID
(
cf
:
CFTypeRef
)
-
>
CFTypeID
;
)
;
type
CFErrorRef
=
CFTypeRef
;
type
CFDataRef
=
CFTypeRef
;
let
CFDataCreateWithBytesNoCopy
=
dlsym
!
(
/
/
Available
:
in
all
CF
versions
.
unsafe
fn
CFDataCreateWithBytesNoCopy
(
allocator
:
CFAllocatorRef
bytes
:
*
const
u8
length
:
CFIndex
bytes_deallocator
:
CFAllocatorRef
)
-
>
CFDataRef
;
)
;
const
kCFPropertyListImmutable
:
CFOptionFlags
=
0
;
type
CFPropertyListFormat
=
CFIndex
;
type
CFPropertyListRef
=
CFTypeRef
;
let
CFPropertyListCreateWithData
=
dlsym
!
(
/
/
Available
:
since
macOS
10
.
6
.
unsafe
fn
CFPropertyListCreateWithData
(
allocator
:
CFAllocatorRef
data
:
CFDataRef
options
:
CFOptionFlags
format
:
*
mut
CFPropertyListFormat
error
:
*
mut
CFErrorRef
)
-
>
CFPropertyListRef
;
)
;
type
CFStringRef
=
CFTypeRef
;
type
CFStringEncoding
=
u32
;
const
kCFStringEncodingUTF8
:
CFStringEncoding
=
0x08000100
;
let
CFStringGetTypeID
=
dlsym
!
(
/
/
Available
:
in
all
CF
versions
.
unsafe
fn
CFStringGetTypeID
(
)
-
>
CFTypeID
;
)
;
let
CFStringCreateWithCStringNoCopy
=
dlsym
!
(
/
/
Available
:
in
all
CF
versions
.
unsafe
fn
CFStringCreateWithCStringNoCopy
(
alloc
:
CFAllocatorRef
c_str
:
*
const
c_char
encoding
:
CFStringEncoding
contents_deallocator
:
CFAllocatorRef
)
-
>
CFStringRef
;
)
;
let
CFStringGetCString
=
dlsym
!
(
/
/
Available
:
in
all
CF
versions
.
unsafe
fn
CFStringGetCString
(
the_string
:
CFStringRef
buffer
:
*
mut
c_char
buffer_size
:
CFIndex
encoding
:
CFStringEncoding
)
-
>
Boolean
;
)
;
type
CFDictionaryRef
=
CFTypeRef
;
let
CFDictionaryGetTypeID
=
dlsym
!
(
/
/
Available
:
in
all
CF
versions
.
unsafe
fn
CFDictionaryGetTypeID
(
)
-
>
CFTypeID
;
)
;
let
CFDictionaryGetValue
=
dlsym
!
(
/
/
Available
:
in
all
CF
versions
.
unsafe
fn
CFDictionaryGetValue
(
the_dict
:
CFDictionaryRef
key
:
*
const
c_void
)
-
>
*
const
c_void
;
)
;
let
plist_data
=
unsafe
{
CFDataCreateWithBytesNoCopy
(
kCFAllocatorDefault
plist_buffer
.
as_ptr
(
)
plist_buffer
.
len
(
)
as
CFIndex
kCFAllocatorNull
)
}
;
assert
!
(
!
plist_data
.
is_null
(
)
"
failed
creating
data
"
)
;
let
_plist_data_release
=
Deferred
(
|
|
unsafe
{
CFRelease
(
plist_data
)
}
)
;
let
plist
=
unsafe
{
CFPropertyListCreateWithData
(
kCFAllocatorDefault
plist_data
kCFPropertyListImmutable
null_mut
(
)
null_mut
(
)
)
}
;
assert
!
(
!
plist
.
is_null
(
)
"
failed
reading
PList
in
SystemVersion
.
plist
"
)
;
let
_plist_release
=
Deferred
(
|
|
unsafe
{
CFRelease
(
plist
)
}
)
;
assert_eq
!
(
unsafe
{
CFGetTypeID
(
plist
)
}
unsafe
{
CFDictionaryGetTypeID
(
)
}
"
SystemVersion
.
plist
did
not
contain
a
dictionary
at
the
top
level
"
)
;
let
plist
=
plist
as
CFDictionaryRef
;
let
get_string_key
=
|
plist
lookup_key
:
&
[
u8
]
|
{
let
cf_lookup_key
=
unsafe
{
CFStringCreateWithCStringNoCopy
(
kCFAllocatorDefault
lookup_key
.
as_ptr
(
)
.
cast
(
)
kCFStringEncodingUTF8
kCFAllocatorNull
)
}
;
assert
!
(
!
cf_lookup_key
.
is_null
(
)
"
failed
creating
CFString
"
)
;
let
_lookup_key_release
=
Deferred
(
|
|
unsafe
{
CFRelease
(
cf_lookup_key
)
}
)
;
let
value
=
unsafe
{
CFDictionaryGetValue
(
plist
cf_lookup_key
)
as
CFTypeRef
}
;
if
value
.
is_null
(
)
{
return
None
;
}
assert_eq
!
(
unsafe
{
CFGetTypeID
(
value
)
}
unsafe
{
CFStringGetTypeID
(
)
}
"
key
in
SystemVersion
.
plist
must
be
a
string
"
)
;
let
value
=
value
as
CFStringRef
;
let
mut
version_str
=
[
0u8
;
32
]
;
let
ret
=
unsafe
{
CFStringGetCString
(
value
version_str
.
as_mut_ptr
(
)
.
cast
:
:
<
c_char
>
(
)
version_str
.
len
(
)
as
CFIndex
kCFStringEncodingUTF8
)
}
;
assert_ne
!
(
ret
0
"
failed
getting
string
from
CFString
"
)
;
let
version_str
=
CStr
:
:
from_bytes_until_nul
(
&
version_str
)
.
expect
(
"
failed
converting
to
CStr
"
)
;
Some
(
OSVersion
:
:
from_bytes
(
version_str
.
to_bytes
(
)
)
)
}
;
if
cfg
!
(
target_os
=
"
ios
"
)
{
if
let
Some
(
ios_support_version
)
=
get_string_key
(
plist
b
"
iOSSupportVersion
\
0
"
)
{
return
ios_support_version
;
}
if
cfg
!
(
target_abi_macabi
)
{
panic
!
(
"
expected
iOSSupportVersion
in
SystemVersion
.
plist
"
)
;
}
}
get_string_key
(
plist
b
"
ProductVersion
\
0
"
)
.
expect
(
"
expected
ProductVersion
in
SystemVersion
.
plist
"
)
}
struct
Deferred
<
F
:
FnMut
(
)
>
(
F
)
;
impl
<
F
:
FnMut
(
)
>
Drop
for
Deferred
<
F
>
{
fn
drop
(
&
mut
self
)
{
(
self
.
0
)
(
)
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
alloc
:
:
string
:
:
String
;
use
std
:
:
process
:
:
Command
;
#
[
test
]
fn
sysctl_same_as_in_plist
(
)
{
if
let
Some
(
version
)
=
version_from_sysctl
(
)
{
assert_eq
!
(
version
version_from_plist
(
)
)
;
}
}
#
[
test
]
fn
read_version
(
)
{
assert
!
(
OSVersion
:
:
MIN
<
current_version
(
)
"
version
cannot
be
min
"
)
;
assert
!
(
current_version
(
)
<
OSVersion
:
:
MAX
"
version
cannot
be
max
"
)
;
}
#
[
test
]
#
[
cfg_attr
(
not
(
target_os
=
"
macos
"
)
ignore
=
"
sw_vers
is
only
available
on
macOS
"
)
]
fn
compare_against_sw_vers
(
)
{
let
expected
=
Command
:
:
new
(
"
sw_vers
"
)
.
arg
(
"
-
productVersion
"
)
.
output
(
)
.
unwrap
(
)
.
stdout
;
let
expected
=
String
:
:
from_utf8
(
expected
)
.
unwrap
(
)
;
let
expected
=
OSVersion
:
:
from_str
(
expected
.
trim
(
)
)
;
let
actual
=
current_version
(
)
;
assert_eq
!
(
expected
actual
)
;
}
}
