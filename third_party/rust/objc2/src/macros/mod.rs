mod
__attribute_helpers
;
mod
__fallback
;
mod
__method_msg_send
;
mod
__msg_send_parse
;
mod
__rewrite_self_param
;
mod
available
;
mod
cf_objc2_type
;
mod
define_class
;
mod
extern_class
;
mod
extern_conformance
;
mod
extern_methods
;
mod
extern_protocol
;
#
[
cfg_attr
(
not
(
feature
=
"
unstable
-
static
-
class
"
)
doc
=
"
should_panic
"
)
]
#
[
cfg_attr
(
feature
=
"
unstable
-
static
-
class
"
doc
=
"
ignore
"
)
]
#
[
macro_export
]
macro_rules
!
class
{
(
name
:
ident
)
=
>
{
{
crate
:
:
__class_inner
!
(
crate
:
:
__macro_helpers
:
:
stringify
!
(
name
)
crate
:
:
__hash_idents
!
(
name
)
)
}
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
not
(
feature
=
"
unstable
-
static
-
class
"
)
)
]
macro_rules
!
__class_inner
{
(
name
:
expr
_hash
:
expr
)
=
>
{
{
static
CACHED_CLASS
:
crate
:
:
__macro_helpers
:
:
CachedClass
=
crate
:
:
__macro_helpers
:
:
CachedClass
:
:
new
(
)
;
#
[
allow
(
unused_unsafe
)
]
unsafe
{
CACHED_CLASS
.
get
(
crate
:
:
__macro_helpers
:
:
concat
!
(
name
'
\
0
'
)
)
}
}
}
;
}
#
[
cfg_attr
(
not
(
feature
=
"
unstable
-
static
-
sel
"
)
doc
=
"
no_run
"
)
]
#
[
cfg_attr
(
feature
=
"
unstable
-
static
-
sel
"
doc
=
"
compile_fail
"
)
]
#
[
macro_export
]
macro_rules
!
sel
{
(
new
)
=
>
(
{
crate
:
:
__macro_helpers
:
:
new_sel
(
)
}
)
;
(
init
)
=
>
(
{
crate
:
:
__macro_helpers
:
:
init_sel
(
)
}
)
;
(
alloc
)
=
>
(
{
crate
:
:
__macro_helpers
:
:
alloc_sel
(
)
}
)
;
(
dealloc
)
=
>
(
{
crate
:
:
__macro_helpers
:
:
dealloc_sel
(
)
}
)
;
(
sel
:
ident
)
=
>
(
{
crate
:
:
__sel_inner
!
(
crate
:
:
__sel_data
!
(
sel
)
crate
:
:
__hash_idents
!
(
sel
)
)
}
)
;
(
(
sel
:
ident
:
)
*
)
=
>
(
{
crate
:
:
__sel_inner
!
(
crate
:
:
__sel_data
!
(
(
sel
:
)
*
)
crate
:
:
__hash_idents
!
(
(
sel
:
)
*
)
)
}
)
;
(
(
sel
:
tt
)
*
)
=
>
{
crate
:
:
__sel_inner
!
(
crate
:
:
__sel_helper
!
{
(
)
(
sel
)
*
}
crate
:
:
__hash_idents
!
(
(
sel
)
*
)
)
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
__sel_helper
{
{
(
(
parsed_sel
:
tt
)
*
)
}
=
>
(
{
crate
:
:
__sel_data
!
(
(
parsed_sel
)
*
)
}
)
;
{
(
)
ident
:
ident
}
=
>
{
crate
:
:
__sel_helper
!
{
(
ident
)
}
}
;
{
(
(
parsed_sel
:
tt
)
*
)
(
ident
:
ident
)
?
:
(
rest
:
tt
)
*
}
=
>
{
crate
:
:
__sel_helper
!
{
(
(
parsed_sel
)
*
(
ident
)
?
:
)
(
rest
)
*
}
}
;
{
(
(
parsed_sel
:
tt
)
*
)
(
ident
:
ident
)
?
:
:
(
rest
:
tt
)
*
}
=
>
{
crate
:
:
__sel_helper
!
{
/
/
Notice
space
between
these
(
(
parsed_sel
)
*
(
ident
)
?
:
:
)
(
rest
)
*
}
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
__sel_data
{
(
first
:
ident
(
:
(
(
rest
:
ident
)
?
:
)
*
)
?
)
=
>
{
crate
:
:
__macro_helpers
:
:
concat
!
(
crate
:
:
__macro_helpers
:
:
stringify
!
(
first
)
(
'
:
'
(
(
crate
:
:
__macro_helpers
:
:
stringify
!
(
rest
)
)
?
'
:
'
)
*
)
?
'
\
0
'
)
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
not
(
feature
=
"
unstable
-
static
-
sel
"
)
)
]
macro_rules
!
__sel_inner
{
(
data
:
expr
_hash
:
expr
)
=
>
{
{
static
CACHED_SEL
:
crate
:
:
__macro_helpers
:
:
CachedSel
=
crate
:
:
__macro_helpers
:
:
CachedSel
:
:
new
(
)
;
#
[
allow
(
unused_unsafe
)
]
unsafe
{
CACHED_SEL
.
get
(
data
)
}
}
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
__statics_string_to_known_length_bytes
{
(
inp
:
ident
)
=
>
{
{
/
/
Convert
the
&
[
u8
]
slice
to
an
array
with
known
length
so
/
/
that
we
can
place
that
directly
in
a
static
.
let
mut
res
:
[
crate
:
:
__macro_helpers
:
:
u8
;
inp
.
len
(
)
]
=
[
0
;
inp
.
len
(
)
]
;
let
mut
i
=
0
;
while
i
<
inp
.
len
(
)
{
res
[
i
]
=
inp
[
i
]
;
i
+
=
1
;
}
res
}
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
target_vendor
=
"
apple
"
)
]
macro_rules
!
__statics_image_info
{
(
hash
:
expr
)
=
>
{
/
/
/
We
always
emit
the
image
info
tag
since
we
need
it
to
:
/
/
/
-
End
up
in
the
same
codegen
unit
as
the
other
statics
below
.
/
/
/
-
End
up
in
the
final
binary
so
it
can
be
read
by
dyld
.
/
/
/
/
/
/
If
it
'
s
not
present
in
the
codegen
unit
then
ld64
won
'
t
set
/
/
/
hasObjC
for
that
specific
object
file
and
in
turn
it
might
/
/
/
disable
processing
of
the
special
Objective
-
C
sections
(
currently
/
/
/
a
category
merging
pass
in
the
future
who
knows
what
)
.
/
/
/
/
/
/
Unfortunately
however
this
leads
to
duplicated
tags
-
the
linker
/
/
/
reports
__DATA
/
__objc_imageinfo
has
unexpectedly
large
size
XXX
#
[
cfg_attr
(
not
(
all
(
target_os
=
"
macos
"
target_arch
=
"
x86
"
)
)
link_section
=
"
__DATA
__objc_imageinfo
regular
no_dead_strip
"
)
]
#
[
cfg_attr
(
all
(
target_os
=
"
macos
"
target_arch
=
"
x86
"
)
link_section
=
"
__OBJC
__image_info
regular
"
)
]
#
[
export_name
=
crate
:
:
__macro_helpers
:
:
concat
!
(
"
\
x01L_OBJC_IMAGE_INFO_
"
hash
)
]
#
[
used
]
/
/
Make
sure
this
reaches
the
linker
static
_IMAGE_INFO
:
crate
:
:
__macro_helpers
:
:
ImageInfo
=
crate
:
:
__macro_helpers
:
:
ImageInfo
:
:
system
(
)
;
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
target_vendor
=
"
apple
"
)
]
macro_rules
!
__statics_module_info
{
(
hash
:
expr
)
=
>
{
#
[
link_section
=
"
__TEXT
__cstring
cstring_literals
"
]
#
[
export_name
=
crate
:
:
__macro_helpers
:
:
concat
!
(
"
\
x01L_OBJC_CLASS_NAME_
"
hash
"
_MODULE_INFO
"
)
]
static
MODULE_INFO_NAME
:
[
crate
:
:
__macro_helpers
:
:
u8
;
1
]
=
[
0
]
;
/
/
/
Emit
module
info
.
/
/
/
/
/
/
This
is
similar
to
image
info
and
must
be
present
in
the
final
/
/
/
binary
on
macOS
32
-
bit
.
#
[
link_section
=
"
__OBJC
__module_info
regular
no_dead_strip
"
]
#
[
export_name
=
crate
:
:
__macro_helpers
:
:
concat
!
(
"
\
x01L_OBJC_MODULES_
"
hash
)
]
#
[
used
]
/
/
Make
sure
this
reaches
the
linker
static
_MODULE_INFO
:
crate
:
:
__macro_helpers
:
:
ModuleInfo
=
crate
:
:
__macro_helpers
:
:
ModuleInfo
:
:
new
(
MODULE_INFO_NAME
.
as_ptr
(
)
)
;
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
target_vendor
=
"
apple
"
)
]
macro_rules
!
__statics_sel
{
{
(
data
:
expr
)
(
hash
:
expr
)
}
=
>
{
const
X
:
&
[
crate
:
:
__macro_helpers
:
:
u8
]
=
data
.
as_bytes
(
)
;
/
/
/
Clang
marks
this
with
LLVM
'
s
unnamed_addr
.
#
[
cfg_attr
(
not
(
all
(
target_os
=
"
macos
"
target_arch
=
"
x86
"
)
)
link_section
=
"
__TEXT
__objc_methname
cstring_literals
"
)
]
#
[
cfg_attr
(
all
(
target_os
=
"
macos
"
target_arch
=
"
x86
"
)
link_section
=
"
__TEXT
__cstring
cstring_literals
"
)
]
#
[
export_name
=
crate
:
:
__macro_helpers
:
:
concat
!
(
"
\
x01L_OBJC_METH_VAR_NAME_
"
hash
)
]
static
NAME_DATA
:
[
crate
:
:
__macro_helpers
:
:
u8
;
X
.
len
(
)
]
=
crate
:
:
__statics_string_to_known_length_bytes
!
(
X
)
;
/
/
/
Place
the
constant
value
in
the
correct
section
.
/
/
/
/
/
/
We
use
UnsafeCell
because
this
somewhat
resembles
internal
/
/
/
mutation
-
this
pointer
will
be
changed
by
dyld
at
startup
so
we
/
/
/
_must_
prevent
Rust
/
LLVM
from
trying
to
"
peek
inside
"
it
and
just
/
/
/
use
a
pointer
to
NAME_DATA
directly
.
/
/
/
/
/
/
Clang
does
this
by
marking
REF
with
LLVM
'
s
/
/
/
externally_initialized
.
#
[
cfg_attr
(
not
(
all
(
target_os
=
"
macos
"
target_arch
=
"
x86
"
)
)
/
/
Clang
uses
no_dead_strip
in
the
link
section
for
some
unknown
reason
/
/
but
it
makes
LTO
fail
to
trim
the
unused
symbols
.
/
/
https
:
/
/
github
.
com
/
madsmtm
/
objc2
/
issues
/
667
/
/
https
:
/
/
github
.
com
/
llvm
/
llvm
-
project
/
issues
/
114111
link_section
=
"
__DATA
__objc_selrefs
literal_pointers
"
)
]
#
[
cfg_attr
(
all
(
target_os
=
"
macos
"
target_arch
=
"
x86
"
)
link_section
=
"
__OBJC
__message_refs
literal_pointers
"
)
]
#
[
export_name
=
crate
:
:
__macro_helpers
:
:
concat
!
(
"
\
x01L_OBJC_SELECTOR_REFERENCES_
"
hash
)
]
static
REF
:
crate
:
:
__macro_helpers
:
:
SyncUnsafeCell
<
crate
:
:
runtime
:
:
Sel
>
=
unsafe
{
crate
:
:
__macro_helpers
:
:
SyncUnsafeCell
:
:
new
(
crate
:
:
runtime
:
:
Sel
:
:
__internal_from_ptr
(
NAME_DATA
.
as_ptr
(
)
)
)
}
;
crate
:
:
__statics_image_info
!
(
hash
)
;
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
not
(
target_vendor
=
"
apple
"
)
)
]
macro_rules
!
__statics_sel
{
(
(
args
:
tt
)
*
)
=
>
{
/
/
TODO
crate
:
:
__macro_helpers
:
:
compile_error
!
(
"
The
\
"
unstable
-
static
-
sel
\
"
feature
is
not
yet
supported
on
GNUStep
!
"
)
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
all
(
target_vendor
=
"
apple
"
not
(
all
(
target_os
=
"
macos
"
target_arch
=
"
x86
"
)
)
)
)
]
macro_rules
!
__statics_class
{
{
(
name
:
expr
)
(
hash
:
expr
)
}
=
>
{
extern
"
C
"
{
/
/
/
Link
to
the
Objective
-
C
class
static
.
/
/
/
/
/
/
This
uses
the
special
symbol
that
static
and
dynamic
linkers
/
/
/
knows
about
.
/
/
/
/
/
/
Failure
modes
:
/
/
/
-
Unknown
class
:
Static
linker
error
.
/
/
/
-
OS
version
<
Class
introduced
version
:
Dynamic
linker
error
/
/
/
on
program
startup
.
/
/
/
-
Deployment
target
>
Class
introduced
version
:
No
error
/
/
/
though
_should_
be
a
static
linker
error
.
/
/
/
/
/
/
Ideally
we
'
d
have
some
way
of
allowing
this
to
be
weakly
/
/
/
linked
and
return
Option
<
&
AnyClass
>
in
that
case
but
Rust
/
/
/
doesn
'
t
have
the
capability
to
do
so
yet
!
/
/
/
<
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
29603
>
/
/
/
<
https
:
/
/
stackoverflow
.
com
/
a
/
16936512
>
/
/
/
<
http
:
/
/
sealiesoftware
.
com
/
blog
/
archive
/
2010
/
4
/
8
/
Do
-
it
-
yourself_Objective
-
C_weak_import
.
html
>
#
[
link_name
=
crate
:
:
__macro_helpers
:
:
concat
!
(
"
OBJC_CLASS_
_
"
name
)
]
static
CLASS
:
crate
:
:
runtime
:
:
AnyClass
;
}
/
/
/
SAFETY
:
Same
as
REF
above
in
__statics_sel
!
.
#
[
link_section
=
"
__DATA
__objc_classrefs
regular
"
]
#
[
export_name
=
crate
:
:
__macro_helpers
:
:
concat
!
(
"
\
x01L_OBJC_CLASSLIST_REFERENCES_
_
"
hash
)
]
static
REF
:
crate
:
:
__macro_helpers
:
:
SyncUnsafeCell
<
&
crate
:
:
runtime
:
:
AnyClass
>
=
unsafe
{
crate
:
:
__macro_helpers
:
:
SyncUnsafeCell
:
:
new
(
&
CLASS
)
}
;
crate
:
:
__statics_image_info
!
(
hash
)
;
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
all
(
target_vendor
=
"
apple
"
all
(
target_os
=
"
macos
"
target_arch
=
"
x86
"
)
)
)
]
macro_rules
!
__statics_class
{
{
(
name
:
expr
)
(
hash
:
expr
)
}
=
>
{
const
X
:
&
[
crate
:
:
__macro_helpers
:
:
u8
]
=
name
.
as_bytes
(
)
;
/
/
/
Similar
to
NAME_DATA
above
in
__statics_sel
!
.
#
[
link_section
=
"
__TEXT
__cstring
cstring_literals
"
]
#
[
export_name
=
crate
:
:
__macro_helpers
:
:
concat
!
(
"
\
x01L_OBJC_CLASS_NAME_
"
hash
)
]
static
NAME_DATA
:
[
crate
:
:
__macro_helpers
:
:
u8
;
X
.
len
(
)
]
=
crate
:
:
__statics_string_to_known_length_bytes
!
(
X
)
;
/
/
/
SAFETY
:
Same
as
REF
above
in
__statics_sel
!
.
#
[
link_section
=
"
__OBJC
__cls_refs
literal_pointers
"
]
#
[
export_name
=
crate
:
:
__macro_helpers
:
:
concat
!
(
"
\
x01L_OBJC_CLASS_REFERENCES_
"
hash
)
]
static
REF
:
crate
:
:
__macro_helpers
:
:
SyncUnsafeCell
<
&
crate
:
:
runtime
:
:
AnyClass
>
=
unsafe
{
let
ptr
:
*
const
crate
:
:
runtime
:
:
AnyClass
=
NAME_DATA
.
as_ptr
(
)
.
cast
(
)
;
crate
:
:
__macro_helpers
:
:
SyncUnsafeCell
:
:
new
(
&
*
ptr
)
}
;
crate
:
:
__statics_image_info
!
(
hash
)
;
crate
:
:
__statics_module_info
!
(
hash
)
;
}
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
all
(
feature
=
"
unstable
-
static
-
sel
"
not
(
feature
=
"
unstable
-
static
-
sel
-
inlined
"
)
)
)
]
macro_rules
!
__sel_inner
{
(
data
:
expr
hash
:
expr
)
=
>
{
{
crate
:
:
__statics_sel
!
{
(
data
)
(
hash
)
}
/
/
/
HACK
:
Wrap
the
access
in
a
non
-
generic
#
[
inline
(
never
)
]
#
[
inline
(
never
)
]
fn
objc_static_workaround
(
)
-
>
crate
:
:
runtime
:
:
Sel
{
/
/
SAFETY
:
The
actual
selector
is
replaced
by
dyld
when
the
/
/
program
is
loaded
.
/
/
/
/
This
is
similar
to
a
volatile
read
except
it
can
be
stripped
/
/
if
unused
.
unsafe
{
*
REF
.
get
(
)
}
}
objc_static_workaround
(
)
}
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
feature
=
"
unstable
-
static
-
sel
-
inlined
"
)
]
macro_rules
!
__sel_inner
{
(
data
:
expr
hash
:
expr
)
=
>
{
{
crate
:
:
__statics_sel
!
{
(
data
)
(
hash
)
}
#
[
allow
(
unused_unsafe
)
]
/
/
SAFETY
:
See
above
unsafe
{
*
REF
.
get
(
)
}
}
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
all
(
feature
=
"
unstable
-
static
-
class
"
not
(
feature
=
"
gnustep
-
1
-
7
"
)
not
(
feature
=
"
unstable
-
static
-
class
-
inlined
"
)
)
)
]
macro_rules
!
__class_inner
{
(
name
:
expr
hash
:
expr
)
=
>
{
{
crate
:
:
__statics_class
!
{
(
name
)
(
hash
)
}
#
[
inline
(
never
)
]
fn
objc_static_workaround
(
)
-
>
&
'
static
crate
:
:
runtime
:
:
AnyClass
{
/
/
SAFETY
:
Same
as
__sel_inner
unsafe
{
*
REF
.
get
(
)
}
}
objc_static_workaround
(
)
}
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
all
(
feature
=
"
unstable
-
static
-
class
"
not
(
feature
=
"
gnustep
-
1
-
7
"
)
feature
=
"
unstable
-
static
-
class
-
inlined
"
)
)
]
macro_rules
!
__class_inner
{
(
name
:
expr
hash
:
expr
)
=
>
{
{
crate
:
:
__statics_class
!
{
(
name
)
(
hash
)
}
#
[
allow
(
unused_unsafe
)
]
/
/
SAFETY
:
See
above
unsafe
{
*
REF
.
get
(
)
}
}
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
all
(
feature
=
"
gnustep
-
1
-
7
"
not
(
feature
=
"
gnustep
-
2
-
0
"
)
)
)
]
macro_rules
!
__class_static_name
{
(
name
:
expr
)
=
>
{
crate
:
:
__macro_helpers
:
:
concat
!
(
"
_OBJC_CLASS_
"
name
)
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
feature
=
"
gnustep
-
2
-
0
"
)
]
macro_rules
!
__class_static_name
{
(
name
:
expr
)
=
>
{
crate
:
:
__macro_helpers
:
:
concat
!
(
"
.
_OBJC_CLASS_
"
name
)
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
#
[
cfg
(
all
(
feature
=
"
unstable
-
static
-
class
"
feature
=
"
gnustep
-
1
-
7
"
)
)
]
macro_rules
!
__class_inner
{
(
name
:
expr
_hash
:
expr
)
=
>
{
{
/
/
NOTE
:
This
is
not
verified
for
correctness
in
any
way
whatsoever
.
extern
"
C
"
{
#
[
link_name
=
crate
:
:
__class_static_name
!
(
name
)
]
static
CLASS
:
crate
:
:
runtime
:
:
AnyClass
;
/
/
Others
:
/
/
__objc_class_name_
/
/
_OBJC_CLASS_REF_
}
#
[
allow
(
unused_unsafe
)
]
unsafe
{
crate
:
:
__macro_helpers
:
:
disallow_in_static
(
&
CLASS
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
msg_send
{
[
super
(
obj
:
expr
)
(
selector_and_arguments
:
tt
)
+
]
=
>
{
crate
:
:
__msg_send_parse
!
{
(
)
(
)
(
(
selector_and_arguments
)
+
)
(
MsgSendSuperError
:
:
send_super_message_static_error
)
(
MsgSendSuper
:
:
send_super_message_static
)
(
crate
:
:
__msg_send_helper
)
(
obj
)
(
)
/
/
No
method
family
}
}
;
[
super
(
obj
:
expr
superclass
:
expr
)
(
selector_and_arguments
:
tt
)
+
]
=
>
{
crate
:
:
__msg_send_parse
!
{
(
)
(
)
(
(
selector_and_arguments
)
+
)
(
MsgSendSuperError
:
:
send_super_message_error
)
(
MsgSendSuper
:
:
send_super_message
)
(
crate
:
:
__msg_send_helper
)
(
obj
superclass
)
(
)
/
/
No
method
family
}
}
;
[
obj
:
expr
(
selector_and_arguments
:
tt
)
+
]
=
>
{
crate
:
:
__msg_send_parse
!
{
(
)
(
)
(
(
selector_and_arguments
)
+
)
(
MsgSendError
:
:
send_message_error
)
(
MsgSend
:
:
send_message
)
(
crate
:
:
__msg_send_helper
)
(
obj
)
(
)
/
/
No
method
family
}
}
;
}
#
[
macro_export
]
#
[
deprecated
=
"
use
a
normal
msg_send
!
instead
it
will
perform
the
conversion
for
you
"
]
macro_rules
!
msg_send_bool
{
[
(
msg_send_args
:
tt
)
+
]
=
>
(
{
/
/
Use
old
impl
for
backwards
compat
let
result
:
crate
:
:
runtime
:
:
Bool
=
crate
:
:
msg_send
!
[
(
msg_send_args
)
+
]
;
result
.
as_bool
(
)
}
)
;
}
#
[
macro_export
]
#
[
deprecated
=
"
use
a
normal
msg_send
!
instead
it
will
now
perform
the
conversion
to
/
from
Retained
for
you
"
]
macro_rules
!
msg_send_id
{
[
(
msg_send_args
:
tt
)
+
]
=
>
{
crate
:
:
msg_send
!
[
(
msg_send_args
)
*
]
}
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
__msg_send_helper
{
{
(
(
fn_args
:
tt
)
+
)
(
(
method_family
:
tt
)
*
)
(
trait
:
ident
:
:
fn
:
ident
)
(
(
selector
:
tt
)
*
)
(
(
argument
:
expr
)
*
)
}
=
>
(
{
/
/
Assign
to
intermediary
variable
for
better
UI
and
to
prevent
/
/
miscompilation
on
older
Rust
versions
(
TODO
:
Which
ones
?
)
.
/
/
/
/
Note
:
This
can
be
accessed
from
any
expression
in
fn_args
and
/
/
argument
-
we
won
'
t
(
yet
)
bother
with
preventing
that
though
.
let
result
;
/
/
Always
add
trailing
comma
after
each
argument
so
that
we
get
a
/
/
1
-
tuple
if
there
is
only
one
.
/
/
/
/
And
use
:
:
<
_
_
>
for
better
UI
.
result
=
<
crate
:
:
__method_family
!
(
(
(
method_family
)
*
)
(
(
selector
)
*
)
)
as
crate
:
:
__macro_helpers
:
:
trait
<
_
_
>
>
:
:
fn
(
(
fn_args
)
+
crate
:
:
sel
!
(
(
selector
)
*
)
(
(
argument
)
*
)
)
;
result
}
)
;
}
