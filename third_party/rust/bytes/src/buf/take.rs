use
crate
:
:
{
Buf
Bytes
}
;
use
core
:
:
cmp
;
#
[
derive
(
Debug
)
]
pub
struct
Take
<
T
>
{
inner
:
T
limit
:
usize
}
pub
fn
new
<
T
>
(
inner
:
T
limit
:
usize
)
-
>
Take
<
T
>
{
Take
{
inner
limit
}
}
impl
<
T
>
Take
<
T
>
{
pub
fn
into_inner
(
self
)
-
>
T
{
self
.
inner
}
pub
fn
get_ref
(
&
self
)
-
>
&
T
{
&
self
.
inner
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
inner
}
pub
fn
limit
(
&
self
)
-
>
usize
{
self
.
limit
}
pub
fn
set_limit
(
&
mut
self
lim
:
usize
)
{
self
.
limit
=
lim
}
}
impl
<
T
:
Buf
>
Buf
for
Take
<
T
>
{
fn
remaining
(
&
self
)
-
>
usize
{
cmp
:
:
min
(
self
.
inner
.
remaining
(
)
self
.
limit
)
}
fn
chunk
(
&
self
)
-
>
&
[
u8
]
{
let
bytes
=
self
.
inner
.
chunk
(
)
;
&
bytes
[
.
.
cmp
:
:
min
(
bytes
.
len
(
)
self
.
limit
)
]
}
fn
advance
(
&
mut
self
cnt
:
usize
)
{
assert
!
(
cnt
<
=
self
.
limit
)
;
self
.
inner
.
advance
(
cnt
)
;
self
.
limit
-
=
cnt
;
}
fn
copy_to_bytes
(
&
mut
self
len
:
usize
)
-
>
Bytes
{
assert
!
(
len
<
=
self
.
remaining
(
)
"
len
greater
than
remaining
"
)
;
let
r
=
self
.
inner
.
copy_to_bytes
(
len
)
;
self
.
limit
-
=
len
;
r
}
}
