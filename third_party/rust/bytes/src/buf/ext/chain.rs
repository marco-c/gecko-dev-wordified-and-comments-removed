use
crate
:
:
{
Buf
BufMut
}
;
use
crate
:
:
buf
:
:
IntoIter
;
use
core
:
:
mem
:
:
MaybeUninit
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
io
:
:
{
IoSlice
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
crate
:
:
buf
:
:
IoSliceMut
;
#
[
derive
(
Debug
)
]
pub
struct
Chain
<
T
U
>
{
a
:
T
b
:
U
}
impl
<
T
U
>
Chain
<
T
U
>
{
pub
fn
new
(
a
:
T
b
:
U
)
-
>
Chain
<
T
U
>
{
Chain
{
a
b
}
}
pub
fn
first_ref
(
&
self
)
-
>
&
T
{
&
self
.
a
}
pub
fn
first_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
a
}
pub
fn
last_ref
(
&
self
)
-
>
&
U
{
&
self
.
b
}
pub
fn
last_mut
(
&
mut
self
)
-
>
&
mut
U
{
&
mut
self
.
b
}
pub
fn
into_inner
(
self
)
-
>
(
T
U
)
{
(
self
.
a
self
.
b
)
}
}
impl
<
T
U
>
Buf
for
Chain
<
T
U
>
where
T
:
Buf
U
:
Buf
{
fn
remaining
(
&
self
)
-
>
usize
{
self
.
a
.
remaining
(
)
+
self
.
b
.
remaining
(
)
}
fn
bytes
(
&
self
)
-
>
&
[
u8
]
{
if
self
.
a
.
has_remaining
(
)
{
self
.
a
.
bytes
(
)
}
else
{
self
.
b
.
bytes
(
)
}
}
fn
advance
(
&
mut
self
mut
cnt
:
usize
)
{
let
a_rem
=
self
.
a
.
remaining
(
)
;
if
a_rem
!
=
0
{
if
a_rem
>
=
cnt
{
self
.
a
.
advance
(
cnt
)
;
return
;
}
self
.
a
.
advance
(
a_rem
)
;
cnt
-
=
a_rem
;
}
self
.
b
.
advance
(
cnt
)
;
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
bytes_vectored
<
'
a
>
(
&
'
a
self
dst
:
&
mut
[
IoSlice
<
'
a
>
]
)
-
>
usize
{
let
mut
n
=
self
.
a
.
bytes_vectored
(
dst
)
;
n
+
=
self
.
b
.
bytes_vectored
(
&
mut
dst
[
n
.
.
]
)
;
n
}
}
impl
<
T
U
>
BufMut
for
Chain
<
T
U
>
where
T
:
BufMut
U
:
BufMut
{
fn
remaining_mut
(
&
self
)
-
>
usize
{
self
.
a
.
remaining_mut
(
)
+
self
.
b
.
remaining_mut
(
)
}
fn
bytes_mut
(
&
mut
self
)
-
>
&
mut
[
MaybeUninit
<
u8
>
]
{
if
self
.
a
.
has_remaining_mut
(
)
{
self
.
a
.
bytes_mut
(
)
}
else
{
self
.
b
.
bytes_mut
(
)
}
}
unsafe
fn
advance_mut
(
&
mut
self
mut
cnt
:
usize
)
{
let
a_rem
=
self
.
a
.
remaining_mut
(
)
;
if
a_rem
!
=
0
{
if
a_rem
>
=
cnt
{
self
.
a
.
advance_mut
(
cnt
)
;
return
;
}
self
.
a
.
advance_mut
(
a_rem
)
;
cnt
-
=
a_rem
;
}
self
.
b
.
advance_mut
(
cnt
)
;
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
bytes_vectored_mut
<
'
a
>
(
&
'
a
mut
self
dst
:
&
mut
[
IoSliceMut
<
'
a
>
]
)
-
>
usize
{
let
mut
n
=
self
.
a
.
bytes_vectored_mut
(
dst
)
;
n
+
=
self
.
b
.
bytes_vectored_mut
(
&
mut
dst
[
n
.
.
]
)
;
n
}
}
impl
<
T
U
>
IntoIterator
for
Chain
<
T
U
>
where
T
:
Buf
U
:
Buf
{
type
Item
=
u8
;
type
IntoIter
=
IntoIter
<
Chain
<
T
U
>
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
IntoIter
:
:
new
(
self
)
}
}
