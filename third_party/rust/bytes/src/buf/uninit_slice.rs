use
core
:
:
fmt
;
use
core
:
:
mem
:
:
MaybeUninit
;
use
core
:
:
ops
:
:
{
Index
IndexMut
Range
RangeFrom
RangeFull
RangeInclusive
RangeTo
RangeToInclusive
}
;
#
[
repr
(
transparent
)
]
pub
struct
UninitSlice
(
[
MaybeUninit
<
u8
>
]
)
;
impl
UninitSlice
{
#
[
inline
]
pub
unsafe
fn
from_raw_parts_mut
<
'
a
>
(
ptr
:
*
mut
u8
len
:
usize
)
-
>
&
'
a
mut
UninitSlice
{
let
maybe_init
:
&
mut
[
MaybeUninit
<
u8
>
]
=
core
:
:
slice
:
:
from_raw_parts_mut
(
ptr
as
*
mut
_
len
)
;
&
mut
*
(
maybe_init
as
*
mut
[
MaybeUninit
<
u8
>
]
as
*
mut
UninitSlice
)
}
#
[
inline
]
pub
fn
write_byte
(
&
mut
self
index
:
usize
byte
:
u8
)
{
assert
!
(
index
<
self
.
len
(
)
)
;
unsafe
{
self
[
index
.
.
]
.
as_mut_ptr
(
)
.
write
(
byte
)
}
}
#
[
inline
]
pub
fn
copy_from_slice
(
&
mut
self
src
:
&
[
u8
]
)
{
use
core
:
:
ptr
;
assert_eq
!
(
self
.
len
(
)
src
.
len
(
)
)
;
unsafe
{
ptr
:
:
copy_nonoverlapping
(
src
.
as_ptr
(
)
self
.
as_mut_ptr
(
)
self
.
len
(
)
)
;
}
}
#
[
inline
]
pub
fn
as_mut_ptr
(
&
mut
self
)
-
>
*
mut
u8
{
self
.
0
.
as_mut_ptr
(
)
as
*
mut
_
}
#
[
inline
]
pub
unsafe
fn
as_uninit_slice_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
[
MaybeUninit
<
u8
>
]
{
&
mut
*
(
self
as
*
mut
_
as
*
mut
[
MaybeUninit
<
u8
>
]
)
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
0
.
len
(
)
}
}
impl
fmt
:
:
Debug
for
UninitSlice
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
UninitSlice
[
.
.
.
]
"
)
.
finish
(
)
}
}
macro_rules
!
impl_index
{
(
(
t
:
ty
)
*
)
=
>
{
(
impl
Index
<
t
>
for
UninitSlice
{
type
Output
=
UninitSlice
;
#
[
inline
]
fn
index
(
&
self
index
:
t
)
-
>
&
UninitSlice
{
let
maybe_uninit
:
&
[
MaybeUninit
<
u8
>
]
=
&
self
.
0
[
index
]
;
unsafe
{
&
*
(
maybe_uninit
as
*
const
[
MaybeUninit
<
u8
>
]
as
*
const
UninitSlice
)
}
}
}
impl
IndexMut
<
t
>
for
UninitSlice
{
#
[
inline
]
fn
index_mut
(
&
mut
self
index
:
t
)
-
>
&
mut
UninitSlice
{
let
maybe_uninit
:
&
mut
[
MaybeUninit
<
u8
>
]
=
&
mut
self
.
0
[
index
]
;
unsafe
{
&
mut
*
(
maybe_uninit
as
*
mut
[
MaybeUninit
<
u8
>
]
as
*
mut
UninitSlice
)
}
}
}
)
*
}
;
}
impl_index
!
(
Range
<
usize
>
RangeFrom
<
usize
>
RangeFull
RangeInclusive
<
usize
>
RangeTo
<
usize
>
RangeToInclusive
<
usize
>
)
;
