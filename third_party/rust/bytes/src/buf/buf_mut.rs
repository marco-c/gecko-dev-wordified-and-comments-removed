use
super
:
:
{
IntoBuf
Writer
}
;
use
byteorder
:
:
ByteOrder
;
use
iovec
:
:
IoVec
;
use
std
:
:
{
cmp
io
ptr
usize
}
;
pub
trait
BufMut
{
fn
remaining_mut
(
&
self
)
-
>
usize
;
unsafe
fn
advance_mut
(
&
mut
self
cnt
:
usize
)
;
fn
has_remaining_mut
(
&
self
)
-
>
bool
{
self
.
remaining_mut
(
)
>
0
}
unsafe
fn
bytes_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
;
unsafe
fn
bytes_vec_mut
<
'
a
>
(
&
'
a
mut
self
dst
:
&
mut
[
&
'
a
mut
IoVec
]
)
-
>
usize
{
if
dst
.
is_empty
(
)
{
return
0
;
}
if
self
.
has_remaining_mut
(
)
{
dst
[
0
]
=
self
.
bytes_mut
(
)
.
into
(
)
;
1
}
else
{
0
}
}
fn
put
<
T
:
IntoBuf
>
(
&
mut
self
src
:
T
)
where
Self
:
Sized
{
use
super
:
:
Buf
;
let
mut
src
=
src
.
into_buf
(
)
;
assert
!
(
self
.
remaining_mut
(
)
>
=
src
.
remaining
(
)
)
;
while
src
.
has_remaining
(
)
{
let
l
;
unsafe
{
let
s
=
src
.
bytes
(
)
;
let
d
=
self
.
bytes_mut
(
)
;
l
=
cmp
:
:
min
(
s
.
len
(
)
d
.
len
(
)
)
;
ptr
:
:
copy_nonoverlapping
(
s
.
as_ptr
(
)
d
.
as_mut_ptr
(
)
l
)
;
}
src
.
advance
(
l
)
;
unsafe
{
self
.
advance_mut
(
l
)
;
}
}
}
fn
put_slice
(
&
mut
self
src
:
&
[
u8
]
)
{
let
mut
off
=
0
;
assert
!
(
self
.
remaining_mut
(
)
>
=
src
.
len
(
)
"
buffer
overflow
"
)
;
while
off
<
src
.
len
(
)
{
let
cnt
;
unsafe
{
let
dst
=
self
.
bytes_mut
(
)
;
cnt
=
cmp
:
:
min
(
dst
.
len
(
)
src
.
len
(
)
-
off
)
;
ptr
:
:
copy_nonoverlapping
(
src
[
off
.
.
]
.
as_ptr
(
)
dst
.
as_mut_ptr
(
)
cnt
)
;
off
+
=
cnt
;
}
unsafe
{
self
.
advance_mut
(
cnt
)
;
}
}
}
fn
put_u8
(
&
mut
self
n
:
u8
)
{
let
src
=
[
n
]
;
self
.
put_slice
(
&
src
)
;
}
fn
put_i8
(
&
mut
self
n
:
i8
)
{
let
src
=
[
n
as
u8
]
;
self
.
put_slice
(
&
src
)
}
fn
put_u16
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u16
)
{
let
mut
buf
=
[
0
;
2
]
;
T
:
:
write_u16
(
&
mut
buf
n
)
;
self
.
put_slice
(
&
buf
)
}
fn
put_i16
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i16
)
{
let
mut
buf
=
[
0
;
2
]
;
T
:
:
write_i16
(
&
mut
buf
n
)
;
self
.
put_slice
(
&
buf
)
}
fn
put_u32
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u32
)
{
let
mut
buf
=
[
0
;
4
]
;
T
:
:
write_u32
(
&
mut
buf
n
)
;
self
.
put_slice
(
&
buf
)
}
fn
put_i32
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i32
)
{
let
mut
buf
=
[
0
;
4
]
;
T
:
:
write_i32
(
&
mut
buf
n
)
;
self
.
put_slice
(
&
buf
)
}
fn
put_u64
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u64
)
{
let
mut
buf
=
[
0
;
8
]
;
T
:
:
write_u64
(
&
mut
buf
n
)
;
self
.
put_slice
(
&
buf
)
}
fn
put_i64
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i64
)
{
let
mut
buf
=
[
0
;
8
]
;
T
:
:
write_i64
(
&
mut
buf
n
)
;
self
.
put_slice
(
&
buf
)
}
fn
put_uint
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u64
nbytes
:
usize
)
{
let
mut
buf
=
[
0
;
8
]
;
T
:
:
write_uint
(
&
mut
buf
n
nbytes
)
;
self
.
put_slice
(
&
buf
[
0
.
.
nbytes
]
)
}
fn
put_int
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i64
nbytes
:
usize
)
{
let
mut
buf
=
[
0
;
8
]
;
T
:
:
write_int
(
&
mut
buf
n
nbytes
)
;
self
.
put_slice
(
&
buf
[
0
.
.
nbytes
]
)
}
fn
put_f32
<
T
:
ByteOrder
>
(
&
mut
self
n
:
f32
)
{
let
mut
buf
=
[
0
;
4
]
;
T
:
:
write_f32
(
&
mut
buf
n
)
;
self
.
put_slice
(
&
buf
)
}
fn
put_f64
<
T
:
ByteOrder
>
(
&
mut
self
n
:
f64
)
{
let
mut
buf
=
[
0
;
8
]
;
T
:
:
write_f64
(
&
mut
buf
n
)
;
self
.
put_slice
(
&
buf
)
}
fn
by_ref
(
&
mut
self
)
-
>
&
mut
Self
where
Self
:
Sized
{
self
}
fn
writer
(
self
)
-
>
Writer
<
Self
>
where
Self
:
Sized
{
super
:
:
writer
:
:
new
(
self
)
}
}
impl
<
'
a
T
:
BufMut
+
?
Sized
>
BufMut
for
&
'
a
mut
T
{
fn
remaining_mut
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
remaining_mut
(
)
}
unsafe
fn
bytes_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
(
*
*
self
)
.
bytes_mut
(
)
}
unsafe
fn
bytes_vec_mut
<
'
b
>
(
&
'
b
mut
self
dst
:
&
mut
[
&
'
b
mut
IoVec
]
)
-
>
usize
{
(
*
*
self
)
.
bytes_vec_mut
(
dst
)
}
unsafe
fn
advance_mut
(
&
mut
self
cnt
:
usize
)
{
(
*
*
self
)
.
advance_mut
(
cnt
)
}
}
impl
<
T
:
BufMut
+
?
Sized
>
BufMut
for
Box
<
T
>
{
fn
remaining_mut
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
remaining_mut
(
)
}
unsafe
fn
bytes_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
(
*
*
self
)
.
bytes_mut
(
)
}
unsafe
fn
bytes_vec_mut
<
'
b
>
(
&
'
b
mut
self
dst
:
&
mut
[
&
'
b
mut
IoVec
]
)
-
>
usize
{
(
*
*
self
)
.
bytes_vec_mut
(
dst
)
}
unsafe
fn
advance_mut
(
&
mut
self
cnt
:
usize
)
{
(
*
*
self
)
.
advance_mut
(
cnt
)
}
}
impl
<
T
:
AsMut
<
[
u8
]
>
+
AsRef
<
[
u8
]
>
>
BufMut
for
io
:
:
Cursor
<
T
>
{
fn
remaining_mut
(
&
self
)
-
>
usize
{
use
Buf
;
self
.
remaining
(
)
}
unsafe
fn
advance_mut
(
&
mut
self
cnt
:
usize
)
{
use
Buf
;
self
.
advance
(
cnt
)
;
}
unsafe
fn
bytes_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
let
len
=
self
.
get_ref
(
)
.
as_ref
(
)
.
len
(
)
;
let
pos
=
self
.
position
(
)
as
usize
;
if
pos
>
=
len
{
return
Default
:
:
default
(
)
;
}
&
mut
(
self
.
get_mut
(
)
.
as_mut
(
)
)
[
pos
.
.
]
}
}
impl
BufMut
for
Vec
<
u8
>
{
#
[
inline
]
fn
remaining_mut
(
&
self
)
-
>
usize
{
usize
:
:
MAX
-
self
.
len
(
)
}
#
[
inline
]
unsafe
fn
advance_mut
(
&
mut
self
cnt
:
usize
)
{
let
len
=
self
.
len
(
)
;
let
remaining
=
self
.
capacity
(
)
-
len
;
if
cnt
>
remaining
{
self
.
reserve
(
cnt
)
;
}
self
.
set_len
(
len
+
cnt
)
;
}
#
[
inline
]
unsafe
fn
bytes_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
use
std
:
:
slice
;
if
self
.
capacity
(
)
=
=
self
.
len
(
)
{
self
.
reserve
(
64
)
;
}
let
cap
=
self
.
capacity
(
)
;
let
len
=
self
.
len
(
)
;
let
ptr
=
self
.
as_mut_ptr
(
)
;
&
mut
slice
:
:
from_raw_parts_mut
(
ptr
cap
)
[
len
.
.
]
}
}
