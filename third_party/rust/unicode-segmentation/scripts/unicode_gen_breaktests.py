#
-
*
-
coding
:
utf
-
8
import
unicode
re
os
fileinput
def
load_test_data
(
f
optsplit
=
[
]
)
:
    
outls
=
[
]
    
testRe1
=
re
.
compile
(
"
^
\
s
+
(
[
^
\
s
]
.
*
[
^
\
s
]
)
\
s
+
\
s
+
#
\
s
+
\
s
+
\
[
0
.
2
\
]
.
*
?
(
[
]
.
*
)
\
s
+
\
s
+
\
[
0
.
3
\
]
\
s
*
"
)
    
unicode
.
fetch
(
f
)
    
data
=
[
]
    
for
line
in
fileinput
.
input
(
os
.
path
.
basename
(
f
)
)
:
        
if
len
(
line
)
<
2
or
line
[
0
:
2
]
!
=
'
'
:
            
continue
        
m
=
testRe1
.
match
(
line
)
        
if
not
m
:
            
print
"
error
:
no
match
on
line
where
test
was
expected
:
%
s
"
%
line
            
continue
        
chars
=
process_split_string
(
m
.
group
(
1
)
)
        
if
not
chars
:
            
continue
        
(
chars
info
)
=
process_split_info
(
m
.
group
(
2
)
chars
optsplit
)
        
assert
len
(
chars
)
-
1
=
=
len
(
info
)
        
outls
.
append
(
(
chars
info
)
)
    
return
outls
def
process_split_info
(
s
c
o
)
:
    
outcs
=
[
]
    
outis
=
[
]
    
workcs
=
c
.
pop
(
0
)
    
isX
=
False
    
if
s
[
0
:
2
]
=
=
'
'
:
        
isX
=
True
    
while
s
:
        
sInd
=
s
.
index
(
'
[
'
)
+
1
        
eInd
=
s
.
index
(
'
]
'
)
        
if
not
isX
or
s
[
sInd
:
eInd
]
in
o
:
            
outis
.
append
(
s
[
sInd
:
eInd
]
)
            
outcs
.
append
(
workcs
)
            
workcs
=
c
.
pop
(
0
)
        
else
:
            
workcs
.
extend
(
c
.
pop
(
0
)
)
        
idx
=
1
        
while
idx
<
len
(
s
)
:
            
if
s
[
idx
:
idx
+
2
]
=
=
'
'
:
                
isX
=
True
                
break
            
if
s
[
idx
:
idx
+
2
]
=
=
'
'
:
                
isX
=
False
                
break
            
idx
+
=
1
        
s
=
s
[
idx
:
]
    
outcs
.
append
(
workcs
)
    
return
(
outcs
outis
)
def
process_split_string
(
s
)
:
    
outls
=
[
]
    
workls
=
[
]
    
inls
=
s
.
split
(
)
    
for
i
in
inls
:
        
if
i
=
=
'
'
or
i
=
=
'
'
:
            
outls
.
append
(
workls
)
            
workls
=
[
]
            
continue
        
ival
=
int
(
i
16
)
        
if
unicode
.
is_surrogate
(
ival
)
:
            
return
[
]
        
workls
.
append
(
ival
)
    
if
workls
:
        
outls
.
append
(
workls
)
    
return
outls
def
showfun
(
x
)
:
    
outstr
=
'
(
"
'
    
for
c
in
x
[
0
]
:
        
outstr
+
=
"
\
\
u
{
%
x
}
"
%
c
    
outstr
+
=
'
"
&
[
'
    
xfirst
=
True
    
for
xx
in
x
[
1
:
]
:
        
if
not
xfirst
:
            
outstr
+
=
'
]
&
[
'
        
xfirst
=
False
        
sfirst
=
True
        
for
sp
in
xx
:
            
if
not
sfirst
:
                
outstr
+
=
'
'
            
sfirst
=
False
            
outstr
+
=
'
"
'
            
for
c
in
sp
:
                
outstr
+
=
"
\
\
u
{
%
x
}
"
%
c
            
outstr
+
=
'
"
'
    
outstr
+
=
'
]
)
'
    
return
outstr
def
create_grapheme_data
(
f
)
:
    
optsplits
=
[
'
9
.
1
'
'
9
.
2
'
]
    
d
=
load_test_data
(
"
auxiliary
/
GraphemeBreakTest
.
txt
"
optsplits
)
    
test_same
=
[
]
    
test_diff
=
[
]
    
for
(
c
i
)
in
d
:
        
allchars
=
[
cn
for
s
in
c
for
cn
in
s
]
        
extgraphs
=
[
]
        
extwork
=
[
]
        
extwork
.
extend
(
c
[
0
]
)
        
for
n
in
range
(
0
len
(
i
)
)
:
            
if
i
[
n
]
in
optsplits
:
                
extwork
.
extend
(
c
[
n
+
1
]
)
            
else
:
                
extgraphs
.
append
(
extwork
)
                
extwork
=
[
]
                
extwork
.
extend
(
c
[
n
+
1
]
)
        
extgraphs
.
append
(
extwork
)
        
if
extgraphs
=
=
c
:
            
test_same
.
append
(
(
allchars
c
)
)
        
else
:
            
test_diff
.
append
(
(
allchars
extgraphs
c
)
)
    
stype
=
"
&
'
static
[
(
&
'
static
str
&
'
static
[
&
'
static
str
]
)
]
"
    
dtype
=
"
&
'
static
[
(
&
'
static
str
&
'
static
[
&
'
static
str
]
&
'
static
[
&
'
static
str
]
)
]
"
    
f
.
write
(
"
/
/
official
Unicode
test
data
\
n
"
)
    
f
.
write
(
"
/
/
http
:
/
/
www
.
unicode
.
org
/
Public
/
UNIDATA
/
auxiliary
/
GraphemeBreakTest
.
txt
\
n
"
)
    
unicode
.
emit_table
(
f
"
TEST_SAME
"
test_same
stype
True
showfun
True
)
    
unicode
.
emit_table
(
f
"
TEST_DIFF
"
test_diff
dtype
True
showfun
True
)
def
create_words_data
(
f
)
:
    
d
=
load_test_data
(
"
auxiliary
/
WordBreakTest
.
txt
"
)
    
test
=
[
]
    
for
(
c
i
)
in
d
:
        
allchars
=
[
cn
for
s
in
c
for
cn
in
s
]
        
test
.
append
(
(
allchars
c
)
)
    
wtype
=
"
&
'
static
[
(
&
'
static
str
&
'
static
[
&
'
static
str
]
)
]
"
    
f
.
write
(
"
/
/
official
Unicode
test
data
\
n
"
)
    
f
.
write
(
"
/
/
http
:
/
/
www
.
unicode
.
org
/
Public
/
UNIDATA
/
auxiliary
/
WordBreakTest
.
txt
\
n
"
)
    
unicode
.
emit_table
(
f
"
TEST_WORD
"
test
wtype
True
showfun
True
)
if
__name__
=
=
"
__main__
"
:
    
with
open
(
"
testdata
.
rs
"
"
w
"
)
as
rf
:
        
rf
.
write
(
unicode
.
preamble
)
        
create_grapheme_data
(
rf
)
        
create_words_data
(
rf
)
