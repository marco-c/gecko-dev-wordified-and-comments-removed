use
core
:
:
arch
:
:
asm
;
use
core
:
:
marker
:
:
PhantomData
;
use
super
:
:
io
:
:
Io
;
#
[
derive
(
Copy
Clone
)
]
pub
struct
Pio
<
T
>
{
port
:
u16
value
:
PhantomData
<
T
>
}
impl
<
T
>
Pio
<
T
>
{
pub
const
fn
new
(
port
:
u16
)
-
>
Self
{
Pio
:
:
<
T
>
{
port
value
:
PhantomData
}
}
}
impl
Io
for
Pio
<
u8
>
{
type
Value
=
u8
;
#
[
inline
(
always
)
]
fn
read
(
&
self
)
-
>
u8
{
let
value
:
u8
;
unsafe
{
asm
!
(
"
in
al
dx
"
in
(
"
dx
"
)
self
.
port
out
(
"
al
"
)
value
options
(
nostack
nomem
preserves_flags
)
)
;
}
value
}
#
[
inline
(
always
)
]
fn
write
(
&
mut
self
value
:
u8
)
{
unsafe
{
asm
!
(
"
out
dx
al
"
in
(
"
dx
"
)
self
.
port
in
(
"
al
"
)
value
options
(
nostack
nomem
preserves_flags
)
)
;
}
}
}
impl
Io
for
Pio
<
u16
>
{
type
Value
=
u16
;
#
[
inline
(
always
)
]
fn
read
(
&
self
)
-
>
u16
{
let
value
:
u16
;
unsafe
{
asm
!
(
"
in
ax
dx
"
in
(
"
dx
"
)
self
.
port
out
(
"
ax
"
)
value
options
(
nostack
nomem
preserves_flags
)
)
;
}
value
}
#
[
inline
(
always
)
]
fn
write
(
&
mut
self
value
:
u16
)
{
unsafe
{
asm
!
(
"
out
dx
ax
"
in
(
"
dx
"
)
self
.
port
in
(
"
ax
"
)
value
options
(
nostack
nomem
preserves_flags
)
)
;
}
}
}
impl
Io
for
Pio
<
u32
>
{
type
Value
=
u32
;
#
[
inline
(
always
)
]
fn
read
(
&
self
)
-
>
u32
{
let
value
:
u32
;
unsafe
{
asm
!
(
"
in
eax
dx
"
in
(
"
dx
"
)
self
.
port
out
(
"
eax
"
)
value
options
(
nostack
nomem
preserves_flags
)
)
;
}
value
}
#
[
inline
(
always
)
]
fn
write
(
&
mut
self
value
:
u32
)
{
unsafe
{
asm
!
(
"
out
dx
eax
"
in
(
"
dx
"
)
self
.
port
in
(
"
eax
"
)
value
options
(
nostack
nomem
preserves_flags
)
)
;
}
}
}
