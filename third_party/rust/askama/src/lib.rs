#
!
[
cfg_attr
(
docsrs
feature
(
doc_cfg
doc_auto_cfg
)
)
]
#
!
[
deny
(
elided_lifetimes_in_paths
)
]
#
!
[
deny
(
unreachable_pub
)
]
#
!
[
deny
(
missing_docs
)
]
#
!
[
no_std
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
extern
crate
alloc
;
#
[
cfg
(
feature
=
"
std
"
)
]
extern
crate
std
;
mod
ascii_str
;
mod
error
;
pub
mod
filters
;
#
[
doc
(
hidden
)
]
pub
mod
helpers
;
mod
html
;
mod
values
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
string
:
:
String
;
use
core
:
:
fmt
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
io
;
#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
askama_derive
:
:
Template
;
#
[
doc
(
hidden
)
]
pub
use
crate
as
shared
;
pub
use
crate
:
:
error
:
:
{
Error
Result
}
;
pub
use
crate
:
:
helpers
:
:
PrimitiveType
;
pub
use
crate
:
:
values
:
:
{
NO_VALUES
Value
Values
get_value
}
;
pub
trait
Template
:
fmt
:
:
Display
+
filters
:
:
FastWritable
{
#
[
inline
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
render
(
&
self
)
-
>
Result
<
String
>
{
self
.
render_with_values
(
NO_VALUES
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
render_with_values
(
&
self
values
:
&
dyn
Values
)
-
>
Result
<
String
>
{
let
mut
buf
=
String
:
:
new
(
)
;
let
_
=
buf
.
try_reserve
(
Self
:
:
SIZE_HINT
)
;
self
.
render_into_with_values
(
&
mut
buf
values
)
?
;
Ok
(
buf
)
}
#
[
inline
]
fn
render_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
)
-
>
Result
<
(
)
>
{
self
.
render_into_with_values
(
writer
NO_VALUES
)
}
fn
render_into_with_values
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
values
:
&
dyn
Values
)
-
>
Result
<
(
)
>
;
#
[
inline
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
write_into
<
W
:
io
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
write_into_with_values
(
writer
NO_VALUES
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
write_into_with_values
<
W
:
io
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
values
:
&
dyn
Values
)
-
>
io
:
:
Result
<
(
)
>
{
struct
Wrapped
<
W
:
io
:
:
Write
>
{
writer
:
W
err
:
Option
<
io
:
:
Error
>
}
impl
<
W
:
io
:
:
Write
>
fmt
:
:
Write
for
Wrapped
<
W
>
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
fmt
:
:
Result
{
if
let
Err
(
err
)
=
self
.
writer
.
write_all
(
s
.
as_bytes
(
)
)
{
self
.
err
=
Some
(
err
)
;
Err
(
fmt
:
:
Error
)
}
else
{
Ok
(
(
)
)
}
}
}
let
mut
wrapped
=
Wrapped
{
writer
err
:
None
}
;
if
self
.
render_into_with_values
(
&
mut
wrapped
values
)
.
is_ok
(
)
{
Ok
(
(
)
)
}
else
{
let
err
=
wrapped
.
err
.
take
(
)
;
Err
(
err
.
unwrap_or_else
(
|
|
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
fmt
:
:
Error
)
)
)
}
}
const
SIZE_HINT
:
usize
;
}
impl
<
T
:
Template
+
?
Sized
>
Template
for
&
T
{
#
[
inline
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
render
(
&
self
)
-
>
Result
<
String
>
{
<
T
as
Template
>
:
:
render
(
self
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
render_with_values
(
&
self
values
:
&
dyn
Values
)
-
>
Result
<
String
>
{
<
T
as
Template
>
:
:
render_with_values
(
self
values
)
}
#
[
inline
]
fn
render_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
)
-
>
Result
<
(
)
>
{
<
T
as
Template
>
:
:
render_into
(
self
writer
)
}
#
[
inline
]
fn
render_into_with_values
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
values
:
&
dyn
Values
)
-
>
Result
<
(
)
>
{
<
T
as
Template
>
:
:
render_into_with_values
(
self
writer
values
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
write_into
<
W
:
io
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
<
T
as
Template
>
:
:
write_into
(
self
writer
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
write_into_with_values
<
W
:
io
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
values
:
&
dyn
Values
)
-
>
io
:
:
Result
<
(
)
>
{
<
T
as
Template
>
:
:
write_into_with_values
(
self
writer
values
)
}
const
SIZE_HINT
:
usize
=
T
:
:
SIZE_HINT
;
}
pub
trait
DynTemplate
{
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
dyn_render
(
&
self
)
-
>
Result
<
String
>
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
dyn_render_with_values
(
&
self
values
:
&
dyn
Values
)
-
>
Result
<
String
>
;
fn
dyn_render_into
(
&
self
writer
:
&
mut
dyn
fmt
:
:
Write
)
-
>
Result
<
(
)
>
;
fn
dyn_render_into_with_values
(
&
self
writer
:
&
mut
dyn
fmt
:
:
Write
values
:
&
dyn
Values
)
-
>
Result
<
(
)
>
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
dyn_write_into
(
&
self
writer
:
&
mut
dyn
io
:
:
Write
)
-
>
io
:
:
Result
<
(
)
>
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
dyn_write_into_with_values
(
&
self
writer
:
&
mut
dyn
io
:
:
Write
values
:
&
dyn
Values
)
-
>
io
:
:
Result
<
(
)
>
;
fn
size_hint
(
&
self
)
-
>
usize
;
}
impl
<
T
:
Template
>
DynTemplate
for
T
{
#
[
inline
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
dyn_render
(
&
self
)
-
>
Result
<
String
>
{
<
Self
as
Template
>
:
:
render
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
dyn_render_with_values
(
&
self
values
:
&
dyn
Values
)
-
>
Result
<
String
>
{
<
Self
as
Template
>
:
:
render_with_values
(
self
values
)
}
#
[
inline
]
fn
dyn_render_into
(
&
self
writer
:
&
mut
dyn
fmt
:
:
Write
)
-
>
Result
<
(
)
>
{
<
Self
as
Template
>
:
:
render_into
(
self
writer
)
}
fn
dyn_render_into_with_values
(
&
self
writer
:
&
mut
dyn
fmt
:
:
Write
values
:
&
dyn
Values
)
-
>
Result
<
(
)
>
{
<
Self
as
Template
>
:
:
render_into_with_values
(
self
writer
values
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
dyn_write_into
(
&
self
writer
:
&
mut
dyn
io
:
:
Write
)
-
>
io
:
:
Result
<
(
)
>
{
<
Self
as
Template
>
:
:
write_into
(
self
writer
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
dyn_write_into_with_values
(
&
self
writer
:
&
mut
dyn
io
:
:
Write
values
:
&
dyn
Values
)
-
>
io
:
:
Result
<
(
)
>
{
<
Self
as
Template
>
:
:
write_into_with_values
(
self
writer
values
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
usize
{
<
Self
as
Template
>
:
:
SIZE_HINT
}
}
impl
fmt
:
:
Display
for
dyn
DynTemplate
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
dyn_render_into
(
f
)
.
map_err
(
|
_
|
fmt
:
:
Error
{
}
)
}
}
macro_rules
!
impl_for_ref
{
(
impl
Trait
:
ident
for
T
:
ident
body
:
tt
)
=
>
{
const
_
:
(
)
=
{
crate
:
:
impl_for_ref
!
{
impl
<
T
>
Trait
for
[
&
T
&
mut
T
core
:
:
cell
:
:
Ref
<
'
_
T
>
core
:
:
cell
:
:
RefMut
<
'
_
T
>
]
body
}
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
const
_
:
(
)
=
{
crate
:
:
impl_for_ref
!
{
impl
<
T
>
Trait
for
[
alloc
:
:
boxed
:
:
Box
<
T
>
alloc
:
:
rc
:
:
Rc
<
T
>
alloc
:
:
sync
:
:
Arc
<
T
>
]
body
}
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
const
_
:
(
)
=
{
crate
:
:
impl_for_ref
!
{
impl
<
T
>
Trait
for
[
std
:
:
sync
:
:
MutexGuard
<
'
_
T
>
std
:
:
sync
:
:
RwLockReadGuard
<
'
_
T
>
std
:
:
sync
:
:
RwLockWriteGuard
<
'
_
T
>
]
body
}
}
;
}
;
(
impl
<
T
:
ident
>
Trait
:
ident
for
[
(
ty
:
ty
)
*
]
body
:
tt
)
=
>
{
(
impl
<
T
:
Trait
+
?
Sized
>
Trait
for
ty
body
)
*
}
}
pub
(
crate
)
use
impl_for_ref
;
#
[
cfg
(
all
(
test
feature
=
"
alloc
"
)
)
]
mod
tests
{
use
std
:
:
fmt
;
use
super
:
:
*
;
use
crate
:
:
{
DynTemplate
Template
}
;
#
[
test
]
fn
dyn_template
(
)
{
use
alloc
:
:
string
:
:
ToString
;
struct
Test
;
impl
Template
for
Test
{
fn
render_into_with_values
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
_values
:
&
dyn
Values
)
-
>
Result
<
(
)
>
{
Ok
(
writer
.
write_str
(
"
test
"
)
?
)
}
const
SIZE_HINT
:
usize
=
4
;
}
impl
fmt
:
:
Display
for
Test
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
render_into
(
f
)
.
map_err
(
|
_
|
fmt
:
:
Error
{
}
)
}
}
impl
filters
:
:
FastWritable
for
Test
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
f
:
&
mut
W
)
-
>
crate
:
:
Result
<
(
)
>
{
self
.
render_into
(
f
)
}
}
fn
render
(
t
:
&
dyn
DynTemplate
)
-
>
String
{
t
.
dyn_render
(
)
.
unwrap
(
)
}
let
test
=
&
Test
as
&
dyn
DynTemplate
;
assert_eq
!
(
render
(
test
)
"
test
"
)
;
assert_eq
!
(
test
.
to_string
(
)
"
test
"
)
;
assert_eq
!
(
alloc
:
:
format
!
(
"
{
test
}
"
)
"
test
"
)
;
let
mut
vec
=
alloc
:
:
vec
!
[
]
;
test
.
dyn_write_into
(
&
mut
vec
)
.
unwrap
(
)
;
assert_eq
!
(
vec
alloc
:
:
vec
!
[
b
'
t
'
b
'
e
'
b
'
s
'
b
'
t
'
]
)
;
}
}
