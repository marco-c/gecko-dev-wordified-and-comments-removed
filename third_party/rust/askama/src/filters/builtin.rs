use
core
:
:
cell
:
:
Cell
;
use
core
:
:
convert
:
:
Infallible
;
use
core
:
:
fmt
:
:
{
self
Write
}
;
use
core
:
:
ops
:
:
Deref
;
use
core
:
:
pin
:
:
Pin
;
use
super
:
:
MAX_LEN
;
use
super
:
:
escape
:
:
FastWritable
;
use
crate
:
:
{
Error
Result
}
;
#
[
inline
]
pub
fn
truncate
<
S
:
fmt
:
:
Display
>
(
source
:
S
remaining
:
usize
)
-
>
Result
<
TruncateFilter
<
S
>
Infallible
>
{
Ok
(
TruncateFilter
{
source
remaining
}
)
}
pub
struct
TruncateFilter
<
S
>
{
source
:
S
remaining
:
usize
}
impl
<
S
:
fmt
:
:
Display
>
fmt
:
:
Display
for
TruncateFilter
<
S
>
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
TruncateWriter
:
:
new
(
f
self
.
remaining
)
"
{
}
"
self
.
source
)
}
}
impl
<
S
:
FastWritable
>
FastWritable
for
TruncateFilter
<
S
>
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
crate
:
:
Result
<
(
)
>
{
self
.
source
.
write_into
(
&
mut
TruncateWriter
:
:
new
(
dest
self
.
remaining
)
)
}
}
struct
TruncateWriter
<
W
>
{
dest
:
Option
<
W
>
remaining
:
usize
}
impl
<
W
>
TruncateWriter
<
W
>
{
fn
new
(
dest
:
W
remaining
:
usize
)
-
>
Self
{
TruncateWriter
{
dest
:
Some
(
dest
)
remaining
}
}
}
impl
<
W
:
fmt
:
:
Write
>
fmt
:
:
Write
for
TruncateWriter
<
W
>
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
fmt
:
:
Result
{
let
Some
(
dest
)
=
&
mut
self
.
dest
else
{
return
Ok
(
(
)
)
;
}
;
let
mut
rem
=
self
.
remaining
;
if
rem
>
=
s
.
len
(
)
{
dest
.
write_str
(
s
)
?
;
self
.
remaining
-
=
s
.
len
(
)
;
}
else
{
if
rem
>
0
{
while
!
s
.
is_char_boundary
(
rem
)
{
rem
+
=
1
;
}
if
rem
=
=
s
.
len
(
)
{
self
.
remaining
=
0
;
return
dest
.
write_str
(
s
)
;
}
dest
.
write_str
(
&
s
[
.
.
rem
]
)
?
;
}
dest
.
write_str
(
"
.
.
.
"
)
?
;
self
.
dest
=
None
;
}
Ok
(
(
)
)
}
#
[
inline
]
fn
write_char
(
&
mut
self
c
:
char
)
-
>
fmt
:
:
Result
{
match
self
.
dest
.
is_some
(
)
{
true
=
>
self
.
write_str
(
c
.
encode_utf8
(
&
mut
[
0
;
4
]
)
)
false
=
>
Ok
(
(
)
)
}
}
#
[
inline
]
fn
write_fmt
(
&
mut
self
args
:
fmt
:
:
Arguments
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
.
dest
.
is_some
(
)
{
true
=
>
fmt
:
:
write
(
self
args
)
false
=
>
Ok
(
(
)
)
}
}
}
#
[
inline
]
pub
fn
join
<
I
S
>
(
input
:
I
separator
:
S
)
-
>
Result
<
JoinFilter
<
I
S
>
Infallible
>
where
I
:
IntoIterator
I
:
:
Item
:
fmt
:
:
Display
S
:
fmt
:
:
Display
{
Ok
(
JoinFilter
(
Cell
:
:
new
(
Some
(
(
input
separator
)
)
)
)
)
}
pub
struct
JoinFilter
<
I
S
>
(
Cell
<
Option
<
(
I
S
)
>
>
)
;
impl
<
I
S
>
fmt
:
:
Display
for
JoinFilter
<
I
S
>
where
I
:
IntoIterator
I
:
:
Item
:
fmt
:
:
Display
S
:
fmt
:
:
Display
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
Some
(
(
iter
separator
)
)
=
self
.
0
.
take
(
)
else
{
return
Ok
(
(
)
)
;
}
;
for
(
idx
token
)
in
iter
.
into_iter
(
)
.
enumerate
(
)
{
match
idx
{
0
=
>
f
.
write_fmt
(
format_args
!
(
"
{
token
}
"
)
)
?
_
=
>
f
.
write_fmt
(
format_args
!
(
"
{
separator
}
{
token
}
"
)
)
?
}
}
Ok
(
(
)
)
}
}
#
[
inline
]
pub
fn
center
<
T
:
fmt
:
:
Display
>
(
src
:
T
width
:
usize
)
-
>
Result
<
Center
<
T
>
Infallible
>
{
Ok
(
Center
{
src
width
}
)
}
pub
struct
Center
<
T
>
{
src
:
T
width
:
usize
}
impl
<
T
:
fmt
:
:
Display
>
fmt
:
:
Display
for
Center
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
if
self
.
width
<
MAX_LEN
{
write
!
(
f
"
{
:
^
1
}
"
self
.
src
self
.
width
)
}
else
{
write
!
(
f
"
{
}
"
self
.
src
)
}
}
}
#
[
inline
]
pub
fn
pluralize
<
C
S
P
>
(
count
:
C
singular
:
S
plural
:
P
)
-
>
Result
<
Pluralize
<
S
P
>
C
:
:
Error
>
where
C
:
PluralizeCount
{
match
count
.
is_singular
(
)
?
{
true
=
>
Ok
(
Pluralize
:
:
Singular
(
singular
)
)
false
=
>
Ok
(
Pluralize
:
:
Plural
(
plural
)
)
}
}
pub
trait
PluralizeCount
{
type
Error
:
Into
<
Error
>
;
fn
is_singular
(
&
self
)
-
>
Result
<
bool
Self
:
:
Error
>
;
}
const
_
:
(
)
=
{
crate
:
:
impl_for_ref
!
{
impl
PluralizeCount
for
T
{
type
Error
=
T
:
:
Error
;
#
[
inline
]
fn
is_singular
(
&
self
)
-
>
Result
<
bool
Self
:
:
Error
>
{
<
T
>
:
:
is_singular
(
self
)
}
}
}
impl
<
T
>
PluralizeCount
for
Pin
<
T
>
where
T
:
Deref
<
T
as
Deref
>
:
:
Target
:
PluralizeCount
{
type
Error
=
<
<
T
as
Deref
>
:
:
Target
as
PluralizeCount
>
:
:
Error
;
#
[
inline
]
fn
is_singular
(
&
self
)
-
>
Result
<
bool
Self
:
:
Error
>
{
self
.
as_ref
(
)
.
get_ref
(
)
.
is_singular
(
)
}
}
macro_rules
!
impl_pluralize_for_unsigned_int
{
(
(
ty
:
ty
)
*
)
=
>
{
(
impl
PluralizeCount
for
ty
{
type
Error
=
Infallible
;
#
[
inline
]
fn
is_singular
(
&
self
)
-
>
Result
<
bool
Self
:
:
Error
>
{
Ok
(
*
self
=
=
1
)
}
}
)
*
}
;
}
impl_pluralize_for_unsigned_int
!
(
u8
u16
u32
u64
u128
usize
)
;
macro_rules
!
impl_pluralize_for_signed_int
{
(
(
ty
:
ty
)
*
)
=
>
{
(
impl
PluralizeCount
for
ty
{
type
Error
=
Infallible
;
#
[
inline
]
fn
is_singular
(
&
self
)
-
>
Result
<
bool
Self
:
:
Error
>
{
Ok
(
*
self
=
=
1
|
|
*
self
=
=
-
1
)
}
}
)
*
}
;
}
impl_pluralize_for_signed_int
!
(
i8
i16
i32
i64
i128
isize
)
;
macro_rules
!
impl_pluralize_for_non_zero
{
(
(
ty
:
ident
)
*
)
=
>
{
(
impl
PluralizeCount
for
core
:
:
num
:
:
ty
{
type
Error
=
Infallible
;
#
[
inline
]
fn
is_singular
(
&
self
)
-
>
Result
<
bool
Self
:
:
Error
>
{
self
.
get
(
)
.
is_singular
(
)
}
}
)
*
}
;
}
impl_pluralize_for_non_zero
!
{
NonZeroI8
NonZeroI16
NonZeroI32
NonZeroI64
NonZeroI128
NonZeroIsize
NonZeroU8
NonZeroU16
NonZeroU32
NonZeroU64
NonZeroU128
NonZeroUsize
}
}
;
pub
enum
Pluralize
<
S
P
>
{
Singular
(
S
)
Plural
(
P
)
}
impl
<
S
:
fmt
:
:
Display
P
:
fmt
:
:
Display
>
fmt
:
:
Display
for
Pluralize
<
S
P
>
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
Pluralize
:
:
Singular
(
value
)
=
>
write
!
(
f
"
{
value
}
"
)
Pluralize
:
:
Plural
(
value
)
=
>
write
!
(
f
"
{
value
}
"
)
}
}
}
impl
<
S
:
FastWritable
P
:
FastWritable
>
FastWritable
for
Pluralize
<
S
P
>
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
crate
:
:
Result
<
(
)
>
{
match
self
{
Pluralize
:
:
Singular
(
value
)
=
>
value
.
write_into
(
dest
)
Pluralize
:
:
Plural
(
value
)
=
>
value
.
write_into
(
dest
)
}
}
}
#
[
cfg
(
all
(
test
feature
=
"
alloc
"
)
)
]
mod
tests
{
use
alloc
:
:
string
:
:
{
String
ToString
}
;
use
alloc
:
:
vec
:
:
Vec
;
use
super
:
:
*
;
#
[
allow
(
clippy
:
:
needless_borrow
)
]
#
[
test
]
fn
test_join
(
)
{
assert_eq
!
(
join
(
(
&
[
"
hello
"
"
world
"
]
)
.
iter
(
)
"
"
)
.
unwrap
(
)
.
to_string
(
)
"
hello
world
"
)
;
assert_eq
!
(
join
(
(
&
[
"
hello
"
]
)
.
iter
(
)
"
"
)
.
unwrap
(
)
.
to_string
(
)
"
hello
"
)
;
let
empty
:
&
[
&
str
]
=
&
[
]
;
assert_eq
!
(
join
(
empty
.
iter
(
)
"
"
)
.
unwrap
(
)
.
to_string
(
)
"
"
)
;
let
input
:
Vec
<
String
>
=
alloc
:
:
vec
!
[
"
foo
"
.
into
(
)
"
bar
"
.
into
(
)
"
bazz
"
.
into
(
)
]
;
assert_eq
!
(
join
(
input
.
iter
(
)
"
:
"
)
.
unwrap
(
)
.
to_string
(
)
"
foo
:
bar
:
bazz
"
)
;
let
input
:
&
[
String
]
=
&
[
"
foo
"
.
into
(
)
"
bar
"
.
into
(
)
]
;
assert_eq
!
(
join
(
input
.
iter
(
)
"
:
"
)
.
unwrap
(
)
.
to_string
(
)
"
foo
:
bar
"
)
;
let
real
:
String
=
"
blah
"
.
into
(
)
;
let
input
:
Vec
<
&
str
>
=
alloc
:
:
vec
!
[
&
real
]
;
assert_eq
!
(
join
(
input
.
iter
(
)
"
;
"
)
.
unwrap
(
)
.
to_string
(
)
"
blah
"
)
;
assert_eq
!
(
join
(
(
&
&
&
&
&
[
"
foo
"
"
bar
"
]
)
.
iter
(
)
"
"
)
.
unwrap
(
)
.
to_string
(
)
"
foo
bar
"
)
;
}
#
[
test
]
fn
test_center
(
)
{
assert_eq
!
(
center
(
"
f
"
3
)
.
unwrap
(
)
.
to_string
(
)
"
f
"
.
to_string
(
)
)
;
assert_eq
!
(
center
(
"
f
"
4
)
.
unwrap
(
)
.
to_string
(
)
"
f
"
.
to_string
(
)
)
;
assert_eq
!
(
center
(
"
foo
"
1
)
.
unwrap
(
)
.
to_string
(
)
"
foo
"
.
to_string
(
)
)
;
assert_eq
!
(
center
(
"
foo
bar
"
8
)
.
unwrap
(
)
.
to_string
(
)
"
foo
bar
"
.
to_string
(
)
)
;
assert_eq
!
(
center
(
"
foo
"
111_669_149_696
)
.
unwrap
(
)
.
to_string
(
)
"
foo
"
.
to_string
(
)
)
;
}
}
