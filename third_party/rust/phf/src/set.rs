use
core
:
:
fmt
;
use
core
:
:
iter
:
:
FusedIterator
;
use
core
:
:
iter
:
:
IntoIterator
;
use
phf_shared
:
:
{
PhfBorrow
PhfHash
}
;
use
crate
:
:
{
map
Map
}
;
pub
struct
Set
<
T
:
'
static
>
{
#
[
doc
(
hidden
)
]
pub
map
:
Map
<
T
(
)
>
}
impl
<
T
>
fmt
:
:
Debug
for
Set
<
T
>
where
T
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_set
(
)
.
entries
(
self
)
.
finish
(
)
}
}
impl
<
T
>
PartialEq
for
Set
<
T
>
where
T
:
PartialEq
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
map
=
=
other
.
map
}
}
impl
<
T
>
Eq
for
Set
<
T
>
where
T
:
Eq
{
}
impl
<
T
>
Set
<
T
>
{
#
[
inline
]
pub
const
fn
len
(
&
self
)
-
>
usize
{
self
.
map
.
len
(
)
}
#
[
inline
]
pub
const
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
pub
fn
get_key
<
U
>
(
&
self
key
:
&
U
)
-
>
Option
<
&
T
>
where
U
:
Eq
+
PhfHash
+
?
Sized
T
:
PhfBorrow
<
U
>
{
self
.
map
.
get_key
(
key
)
}
pub
fn
contains
<
U
>
(
&
self
value
:
&
U
)
-
>
bool
where
U
:
Eq
+
PhfHash
+
?
Sized
T
:
PhfBorrow
<
U
>
{
self
.
map
.
contains_key
(
value
)
}
pub
fn
iter
(
&
self
)
-
>
Iter
<
'
_
T
>
{
Iter
{
iter
:
self
.
map
.
keys
(
)
}
}
}
impl
<
T
>
Set
<
T
>
where
T
:
Eq
+
PhfHash
+
PhfBorrow
<
T
>
{
pub
fn
is_disjoint
(
&
self
other
:
&
Set
<
T
>
)
-
>
bool
{
!
self
.
iter
(
)
.
any
(
|
value
|
other
.
contains
(
value
)
)
}
pub
fn
is_subset
(
&
self
other
:
&
Set
<
T
>
)
-
>
bool
{
self
.
iter
(
)
.
all
(
|
value
|
other
.
contains
(
value
)
)
}
pub
fn
is_superset
(
&
self
other
:
&
Set
<
T
>
)
-
>
bool
{
other
.
is_subset
(
self
)
}
}
impl
<
'
a
T
>
IntoIterator
for
&
'
a
Set
<
T
>
{
type
Item
=
&
'
a
T
;
type
IntoIter
=
Iter
<
'
a
T
>
;
fn
into_iter
(
self
)
-
>
Iter
<
'
a
T
>
{
self
.
iter
(
)
}
}
pub
struct
Iter
<
'
a
T
:
'
static
>
{
iter
:
map
:
:
Keys
<
'
a
T
(
)
>
}
impl
<
'
a
T
>
Clone
for
Iter
<
'
a
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
Self
{
iter
:
self
.
iter
.
clone
(
)
}
}
}
impl
<
'
a
T
>
fmt
:
:
Debug
for
Iter
<
'
a
T
>
where
T
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
impl
<
'
a
T
>
Iterator
for
Iter
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
self
.
iter
.
next
(
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
'
a
T
>
DoubleEndedIterator
for
Iter
<
'
a
T
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
self
.
iter
.
next_back
(
)
}
}
impl
<
'
a
T
>
ExactSizeIterator
for
Iter
<
'
a
T
>
{
}
impl
<
'
a
T
>
FusedIterator
for
Iter
<
'
a
T
>
{
}
