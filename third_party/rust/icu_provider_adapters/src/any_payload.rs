use
icu_provider
:
:
prelude
:
:
*
;
use
yoke
:
:
trait_hack
:
:
YokeTraitHack
;
use
yoke
:
:
Yokeable
;
use
zerofrom
:
:
ZeroFrom
;
#
[
derive
(
Debug
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
AnyPayloadProvider
{
key
:
DataKey
data
:
AnyPayload
}
impl
AnyPayloadProvider
{
pub
fn
from_owned
<
M
:
KeyedDataMarker
>
(
data
:
M
:
:
Yokeable
)
-
>
Self
where
M
:
:
Yokeable
:
icu_provider
:
:
MaybeSendSync
{
Self
:
:
from_payload
:
:
<
M
>
(
DataPayload
:
:
from_owned
(
data
)
)
}
pub
fn
from_static
<
M
:
KeyedDataMarker
>
(
data
:
&
'
static
M
:
:
Yokeable
)
-
>
Self
{
AnyPayloadProvider
{
key
:
M
:
:
KEY
data
:
AnyPayload
:
:
from_static_ref
(
data
)
}
}
pub
fn
from_payload
<
M
:
KeyedDataMarker
>
(
payload
:
DataPayload
<
M
>
)
-
>
Self
where
M
:
:
Yokeable
:
icu_provider
:
:
MaybeSendSync
{
AnyPayloadProvider
{
key
:
M
:
:
KEY
data
:
payload
.
wrap_into_any_payload
(
)
}
}
pub
fn
from_any_payload
<
M
:
KeyedDataMarker
>
(
payload
:
AnyPayload
)
-
>
Self
{
AnyPayloadProvider
{
key
:
M
:
:
KEY
data
:
payload
}
}
pub
fn
new_default
<
M
:
KeyedDataMarker
>
(
)
-
>
Self
where
M
:
:
Yokeable
:
Default
M
:
:
Yokeable
:
icu_provider
:
:
MaybeSendSync
{
Self
:
:
from_owned
:
:
<
M
>
(
M
:
:
Yokeable
:
:
default
(
)
)
}
}
impl
AnyProvider
for
AnyPayloadProvider
{
fn
load_any
(
&
self
key
:
DataKey
_
:
DataRequest
)
-
>
Result
<
AnyResponse
DataError
>
{
key
.
match_key
(
self
.
key
)
?
;
Ok
(
AnyResponse
{
metadata
:
DataResponseMetadata
:
:
default
(
)
payload
:
Some
(
self
.
data
.
clone
(
)
)
}
)
}
}
impl
<
M
>
DataProvider
<
M
>
for
AnyPayloadProvider
where
M
:
KeyedDataMarker
for
<
'
a
>
YokeTraitHack
<
<
M
:
:
Yokeable
as
Yokeable
<
'
a
>
>
:
:
Output
>
:
Clone
M
:
:
Yokeable
:
ZeroFrom
<
'
static
M
:
:
Yokeable
>
M
:
:
Yokeable
:
icu_provider
:
:
MaybeSendSync
{
fn
load
(
&
self
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
M
>
DataError
>
{
self
.
as_downcasting
(
)
.
load
(
req
)
}
}
