use
crate
:
:
helpers
:
:
result_is_err_missing_locale
;
use
icu_locid_transform
:
:
provider
:
:
*
;
use
icu_provider
:
:
prelude
:
:
*
;
#
[
doc
(
hidden
)
]
pub
use
icu_locid_transform
:
:
fallback
:
:
{
LocaleFallbackIterator
LocaleFallbacker
LocaleFallbackerWithConfig
}
;
#
[
doc
(
hidden
)
]
pub
use
icu_provider
:
:
fallback
:
:
LocaleFallbackConfig
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
LocaleFallbackProvider
<
P
>
{
inner
:
P
fallbacker
:
LocaleFallbacker
}
impl
<
P
>
LocaleFallbackProvider
<
P
>
where
P
:
DataProvider
<
LocaleFallbackLikelySubtagsV1Marker
>
+
DataProvider
<
LocaleFallbackParentsV1Marker
>
+
DataProvider
<
CollationFallbackSupplementV1Marker
>
{
pub
fn
try_new_unstable
(
provider
:
P
)
-
>
Result
<
Self
DataError
>
{
let
fallbacker
=
LocaleFallbacker
:
:
try_new_unstable
(
&
provider
)
?
;
Ok
(
Self
{
inner
:
provider
fallbacker
}
)
}
}
impl
<
P
>
LocaleFallbackProvider
<
P
>
where
P
:
AnyProvider
{
pub
fn
try_new_with_any_provider
(
provider
:
P
)
-
>
Result
<
Self
DataError
>
{
let
fallbacker
=
LocaleFallbacker
:
:
try_new_with_any_provider
(
&
provider
)
?
;
Ok
(
Self
{
inner
:
provider
fallbacker
}
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
P
>
LocaleFallbackProvider
<
P
>
where
P
:
BufferProvider
{
pub
fn
try_new_with_buffer_provider
(
provider
:
P
)
-
>
Result
<
Self
DataError
>
{
let
fallbacker
=
LocaleFallbacker
:
:
try_new_with_buffer_provider
(
&
provider
)
?
;
Ok
(
Self
{
inner
:
provider
fallbacker
}
)
}
}
impl
<
P
>
LocaleFallbackProvider
<
P
>
{
pub
fn
new_with_fallbacker
(
provider
:
P
fallbacker
:
LocaleFallbacker
)
-
>
Self
{
Self
{
inner
:
provider
fallbacker
}
}
pub
fn
inner
(
&
self
)
-
>
&
P
{
&
self
.
inner
}
pub
fn
inner_mut
(
&
mut
self
)
-
>
&
mut
P
{
&
mut
self
.
inner
}
pub
fn
into_inner
(
self
)
-
>
P
{
self
.
inner
}
fn
run_fallback
<
F1
F2
R
>
(
&
self
key
:
DataKey
mut
base_req
:
DataRequest
mut
f1
:
F1
mut
f2
:
F2
)
-
>
Result
<
R
DataError
>
where
F1
:
FnMut
(
DataRequest
)
-
>
Result
<
R
DataError
>
F2
:
FnMut
(
&
mut
R
)
-
>
&
mut
DataResponseMetadata
{
if
key
.
metadata
(
)
.
singleton
{
return
f1
(
base_req
)
;
}
let
mut
fallback_iterator
=
self
.
fallbacker
.
for_config
(
key
.
fallback_config
(
)
)
.
fallback_for
(
base_req
.
locale
.
clone
(
)
)
;
let
base_silent
=
core
:
:
mem
:
:
replace
(
&
mut
base_req
.
metadata
.
silent
true
)
;
loop
{
let
result
=
f1
(
DataRequest
{
locale
:
fallback_iterator
.
get
(
)
metadata
:
base_req
.
metadata
}
)
;
if
!
result_is_err_missing_locale
(
&
result
)
{
return
result
.
map
(
|
mut
res
|
{
f2
(
&
mut
res
)
.
locale
=
Some
(
fallback_iterator
.
take
(
)
)
;
res
}
)
.
map_err
(
|
e
|
{
base_req
.
metadata
.
silent
=
base_silent
;
e
.
with_req
(
key
base_req
)
}
)
;
}
if
fallback_iterator
.
get
(
)
.
is_und
(
)
{
break
;
}
fallback_iterator
.
step
(
)
;
}
base_req
.
metadata
.
silent
=
base_silent
;
Err
(
DataErrorKind
:
:
MissingLocale
.
with_req
(
key
base_req
)
)
}
}
impl
<
P
>
AnyProvider
for
LocaleFallbackProvider
<
P
>
where
P
:
AnyProvider
{
fn
load_any
(
&
self
key
:
DataKey
base_req
:
DataRequest
)
-
>
Result
<
AnyResponse
DataError
>
{
self
.
run_fallback
(
key
base_req
|
req
|
self
.
inner
.
load_any
(
key
req
)
|
res
|
&
mut
res
.
metadata
)
}
}
impl
<
P
>
BufferProvider
for
LocaleFallbackProvider
<
P
>
where
P
:
BufferProvider
{
fn
load_buffer
(
&
self
key
:
DataKey
base_req
:
DataRequest
)
-
>
Result
<
DataResponse
<
BufferMarker
>
DataError
>
{
self
.
run_fallback
(
key
base_req
|
req
|
self
.
inner
.
load_buffer
(
key
req
)
|
res
|
&
mut
res
.
metadata
)
}
}
impl
<
P
M
>
DynamicDataProvider
<
M
>
for
LocaleFallbackProvider
<
P
>
where
P
:
DynamicDataProvider
<
M
>
M
:
DataMarker
{
fn
load_data
(
&
self
key
:
DataKey
base_req
:
DataRequest
)
-
>
Result
<
DataResponse
<
M
>
DataError
>
{
self
.
run_fallback
(
key
base_req
|
req
|
self
.
inner
.
load_data
(
key
req
)
|
res
|
&
mut
res
.
metadata
)
}
}
impl
<
P
M
>
DataProvider
<
M
>
for
LocaleFallbackProvider
<
P
>
where
P
:
DataProvider
<
M
>
M
:
KeyedDataMarker
{
fn
load
(
&
self
base_req
:
DataRequest
)
-
>
Result
<
DataResponse
<
M
>
DataError
>
{
self
.
run_fallback
(
M
:
:
KEY
base_req
|
req
|
self
.
inner
.
load
(
req
)
|
res
|
&
mut
res
.
metadata
)
}
}
