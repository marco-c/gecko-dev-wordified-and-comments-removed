#
[
doc
(
no_inline
)
]
pub
use
icu_locale
:
:
LocaleFallbacker
;
use
icu_provider
:
:
prelude
:
:
*
;
use
icu_provider
:
:
DryDataProvider
;
use
icu_provider
:
:
DynamicDryDataProvider
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
LocaleFallbackProvider
<
P
>
{
inner
:
P
fallbacker
:
LocaleFallbacker
}
impl
<
P
>
LocaleFallbackProvider
<
P
>
{
pub
fn
new
(
provider
:
P
fallbacker
:
LocaleFallbacker
)
-
>
Self
{
Self
{
inner
:
provider
fallbacker
}
}
pub
fn
inner
(
&
self
)
-
>
&
P
{
&
self
.
inner
}
pub
fn
inner_mut
(
&
mut
self
)
-
>
&
mut
P
{
&
mut
self
.
inner
}
pub
fn
into_inner
(
self
)
-
>
P
{
self
.
inner
}
fn
run_fallback
<
F1
F2
R
>
(
&
self
marker
:
DataMarkerInfo
mut
base_req
:
DataRequest
mut
f1
:
F1
mut
f2
:
F2
)
-
>
Result
<
R
DataError
>
where
F1
:
FnMut
(
DataRequest
)
-
>
Result
<
R
DataError
>
F2
:
FnMut
(
&
mut
R
)
-
>
&
mut
DataResponseMetadata
{
if
marker
.
is_singleton
{
return
f1
(
base_req
)
;
}
let
mut
fallback_iterator
=
self
.
fallbacker
.
for_config
(
marker
.
fallback_config
)
.
fallback_for
(
*
base_req
.
id
.
locale
)
;
let
base_silent
=
core
:
:
mem
:
:
replace
(
&
mut
base_req
.
metadata
.
silent
true
)
;
loop
{
let
result
=
f1
(
DataRequest
{
id
:
DataIdentifierBorrowed
:
:
for_marker_attributes_and_locale
(
base_req
.
id
.
marker_attributes
fallback_iterator
.
get
(
)
)
.
.
base_req
}
)
;
match
result
.
allow_identifier_not_found
(
)
{
Ok
(
Some
(
mut
result
)
)
=
>
{
f2
(
&
mut
result
)
.
locale
=
Some
(
fallback_iterator
.
take
(
)
)
;
return
Ok
(
result
)
;
}
Ok
(
None
)
=
>
{
if
fallback_iterator
.
get
(
)
.
is_unknown
(
)
{
break
;
}
fallback_iterator
.
step
(
)
;
}
Err
(
e
)
=
>
{
base_req
.
metadata
.
silent
=
base_silent
;
return
Err
(
e
.
with_req
(
marker
base_req
)
)
;
}
}
;
}
base_req
.
metadata
.
silent
=
base_silent
;
Err
(
DataErrorKind
:
:
IdentifierNotFound
.
with_req
(
marker
base_req
)
)
}
}
impl
<
P
M
>
DynamicDataProvider
<
M
>
for
LocaleFallbackProvider
<
P
>
where
P
:
DynamicDataProvider
<
M
>
M
:
DynamicDataMarker
{
fn
load_data
(
&
self
marker
:
DataMarkerInfo
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
M
>
DataError
>
{
self
.
run_fallback
(
marker
req
|
req
|
self
.
inner
.
load_data
(
marker
req
)
|
res
|
&
mut
res
.
metadata
)
}
}
impl
<
P
M
>
DynamicDryDataProvider
<
M
>
for
LocaleFallbackProvider
<
P
>
where
P
:
DynamicDryDataProvider
<
M
>
M
:
DynamicDataMarker
{
fn
dry_load_data
(
&
self
marker
:
DataMarkerInfo
req
:
DataRequest
)
-
>
Result
<
DataResponseMetadata
DataError
>
{
self
.
run_fallback
(
marker
req
|
req
|
self
.
inner
.
dry_load_data
(
marker
req
)
|
m
|
m
)
}
}
impl
<
P
M
>
DataProvider
<
M
>
for
LocaleFallbackProvider
<
P
>
where
P
:
DataProvider
<
M
>
M
:
DataMarker
{
fn
load
(
&
self
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
M
>
DataError
>
{
self
.
run_fallback
(
M
:
:
INFO
req
|
req
|
self
.
inner
.
load
(
req
)
|
res
|
&
mut
res
.
metadata
)
}
}
impl
<
P
M
>
DryDataProvider
<
M
>
for
LocaleFallbackProvider
<
P
>
where
P
:
DryDataProvider
<
M
>
M
:
DataMarker
{
fn
dry_load
(
&
self
req
:
DataRequest
)
-
>
Result
<
DataResponseMetadata
DataError
>
{
self
.
run_fallback
(
M
:
:
INFO
req
|
req
|
self
.
inner
.
dry_load
(
req
)
|
m
|
m
)
}
}
#
[
test
]
fn
dry_test
(
)
{
use
icu_provider
:
:
hello_world
:
:
*
;
struct
TestProvider
;
impl
DataProvider
<
HelloWorldV1
>
for
TestProvider
{
fn
load
(
&
self
_
:
DataRequest
)
-
>
Result
<
DataResponse
<
HelloWorldV1
>
DataError
>
{
panic
!
(
"
pretend
this
is
super
expensive
"
)
}
}
impl
DryDataProvider
<
HelloWorldV1
>
for
TestProvider
{
fn
dry_load
(
&
self
req
:
DataRequest
)
-
>
Result
<
DataResponseMetadata
DataError
>
{
if
req
.
id
.
locale
.
region
.
is_some
(
)
|
|
req
.
id
.
locale
.
language
.
as_str
(
)
=
=
"
en
"
{
Err
(
DataErrorKind
:
:
IdentifierNotFound
.
into_error
(
)
)
}
else
{
Ok
(
Default
:
:
default
(
)
)
}
}
}
let
provider
=
LocaleFallbackProvider
:
:
new
(
TestProvider
LocaleFallbacker
:
:
new
(
)
.
static_to_owned
(
)
)
;
assert_eq
!
(
provider
.
dry_load
(
DataRequest
{
id
:
DataIdentifierBorrowed
:
:
for_locale
(
&
"
de
-
CH
"
.
parse
(
)
.
unwrap
(
)
)
.
.
Default
:
:
default
(
)
}
)
.
unwrap
(
)
.
locale
"
de
"
.
parse
:
:
<
DataLocale
>
(
)
.
ok
(
)
)
;
assert_eq
!
(
provider
.
dry_load
(
DataRequest
{
id
:
DataIdentifierBorrowed
:
:
for_locale
(
&
"
en
-
GB
"
.
parse
(
)
.
unwrap
(
)
)
.
.
Default
:
:
default
(
)
}
)
.
unwrap
(
)
.
locale
Some
(
DataLocale
:
:
default
(
)
)
)
;
}
