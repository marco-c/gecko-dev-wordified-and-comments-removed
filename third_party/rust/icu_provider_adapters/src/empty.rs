use
icu_provider
:
:
prelude
:
:
*
;
#
[
derive
(
Debug
)
]
pub
struct
EmptyDataProvider
{
error_kind
:
DataErrorKind
}
impl
Default
for
EmptyDataProvider
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
EmptyDataProvider
{
pub
fn
new
(
)
-
>
Self
{
Self
{
error_kind
:
DataErrorKind
:
:
MissingDataKey
}
}
pub
fn
new_with_error_kind
(
error_kind
:
DataErrorKind
)
-
>
Self
{
Self
{
error_kind
}
}
}
impl
AnyProvider
for
EmptyDataProvider
{
fn
load_any
(
&
self
key
:
DataKey
base_req
:
DataRequest
)
-
>
Result
<
AnyResponse
DataError
>
{
Err
(
self
.
error_kind
.
with_req
(
key
base_req
)
)
}
}
impl
BufferProvider
for
EmptyDataProvider
{
fn
load_buffer
(
&
self
key
:
DataKey
base_req
:
DataRequest
)
-
>
Result
<
DataResponse
<
BufferMarker
>
DataError
>
{
Err
(
self
.
error_kind
.
with_req
(
key
base_req
)
)
}
}
impl
<
M
>
DynamicDataProvider
<
M
>
for
EmptyDataProvider
where
M
:
DataMarker
{
fn
load_data
(
&
self
key
:
DataKey
base_req
:
DataRequest
)
-
>
Result
<
DataResponse
<
M
>
DataError
>
{
Err
(
self
.
error_kind
.
with_req
(
key
base_req
)
)
}
}
impl
<
M
>
DataProvider
<
M
>
for
EmptyDataProvider
where
M
:
KeyedDataMarker
{
fn
load
(
&
self
base_req
:
DataRequest
)
-
>
Result
<
DataResponse
<
M
>
DataError
>
{
Err
(
self
.
error_kind
.
with_req
(
M
:
:
KEY
base_req
)
)
}
}
#
[
cfg
(
feature
=
"
datagen
"
)
]
impl
<
M
>
icu_provider
:
:
datagen
:
:
IterableDataProvider
<
M
>
for
EmptyDataProvider
where
M
:
KeyedDataMarker
{
fn
supported_locales
(
&
self
)
-
>
Result
<
alloc
:
:
vec
:
:
Vec
<
DataLocale
>
DataError
>
{
Ok
(
vec
!
[
]
)
}
}
#
[
cfg
(
feature
=
"
datagen
"
)
]
impl
<
M
>
icu_provider
:
:
datagen
:
:
IterableDynamicDataProvider
<
M
>
for
EmptyDataProvider
where
M
:
DataMarker
{
fn
supported_locales_for_key
(
&
self
_
:
DataKey
)
-
>
Result
<
alloc
:
:
vec
:
:
Vec
<
DataLocale
>
DataError
>
{
Ok
(
vec
!
[
]
)
}
}
