mod
impls
;
#
[
cfg
(
feature
=
"
datagen
"
)
]
use
icu_provider
:
:
datagen
;
use
icu_provider
:
:
prelude
:
:
*
;
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
#
[
derive
(
Debug
)
]
pub
struct
RequestFilterDataProvider
<
D
F
>
where
F
:
Fn
(
DataRequest
)
-
>
bool
{
pub
inner
:
D
pub
predicate
:
F
pub
filter_name
:
&
'
static
str
}
impl
<
D
F
M
>
DynamicDataProvider
<
M
>
for
RequestFilterDataProvider
<
D
F
>
where
F
:
Fn
(
DataRequest
)
-
>
bool
M
:
DataMarker
D
:
DynamicDataProvider
<
M
>
{
fn
load_data
(
&
self
key
:
DataKey
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
M
>
DataError
>
{
if
(
self
.
predicate
)
(
req
)
{
self
.
inner
.
load_data
(
key
req
)
}
else
{
Err
(
DataErrorKind
:
:
FilteredResource
.
with_str_context
(
self
.
filter_name
)
.
with_req
(
key
req
)
)
}
}
}
impl
<
D
F
M
>
DataProvider
<
M
>
for
RequestFilterDataProvider
<
D
F
>
where
F
:
Fn
(
DataRequest
)
-
>
bool
M
:
KeyedDataMarker
D
:
DataProvider
<
M
>
{
fn
load
(
&
self
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
M
>
DataError
>
{
if
(
self
.
predicate
)
(
req
)
{
self
.
inner
.
load
(
req
)
}
else
{
Err
(
DataErrorKind
:
:
FilteredResource
.
with_str_context
(
self
.
filter_name
)
.
with_req
(
M
:
:
KEY
req
)
)
}
}
}
impl
<
D
F
>
BufferProvider
for
RequestFilterDataProvider
<
D
F
>
where
F
:
Fn
(
DataRequest
)
-
>
bool
D
:
BufferProvider
{
fn
load_buffer
(
&
self
key
:
DataKey
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
BufferMarker
>
DataError
>
{
if
(
self
.
predicate
)
(
req
)
{
self
.
inner
.
load_buffer
(
key
req
)
}
else
{
Err
(
DataErrorKind
:
:
FilteredResource
.
with_str_context
(
self
.
filter_name
)
.
with_req
(
key
req
)
)
}
}
}
impl
<
D
F
>
AnyProvider
for
RequestFilterDataProvider
<
D
F
>
where
F
:
Fn
(
DataRequest
)
-
>
bool
D
:
AnyProvider
{
fn
load_any
(
&
self
key
:
DataKey
req
:
DataRequest
)
-
>
Result
<
AnyResponse
DataError
>
{
if
(
self
.
predicate
)
(
req
)
{
self
.
inner
.
load_any
(
key
req
)
}
else
{
Err
(
DataErrorKind
:
:
FilteredResource
.
with_str_context
(
self
.
filter_name
)
.
with_req
(
key
req
)
)
}
}
}
#
[
cfg
(
feature
=
"
datagen
"
)
]
impl
<
M
D
F
>
datagen
:
:
IterableDynamicDataProvider
<
M
>
for
RequestFilterDataProvider
<
D
F
>
where
M
:
DataMarker
F
:
Fn
(
DataRequest
)
-
>
bool
D
:
datagen
:
:
IterableDynamicDataProvider
<
M
>
{
fn
supported_locales_for_key
(
&
self
key
:
DataKey
)
-
>
Result
<
alloc
:
:
vec
:
:
Vec
<
DataLocale
>
DataError
>
{
self
.
inner
.
supported_locales_for_key
(
key
)
.
map
(
|
vec
|
{
vec
.
into_iter
(
)
.
filter_map
(
|
locale
|
{
if
(
self
.
predicate
)
(
DataRequest
{
locale
:
&
locale
metadata
:
Default
:
:
default
(
)
}
)
{
Some
(
locale
)
}
else
{
None
}
}
)
.
collect
(
)
}
)
}
}
#
[
cfg
(
feature
=
"
datagen
"
)
]
impl
<
M
D
F
>
datagen
:
:
IterableDataProvider
<
M
>
for
RequestFilterDataProvider
<
D
F
>
where
M
:
KeyedDataMarker
F
:
Fn
(
DataRequest
)
-
>
bool
D
:
datagen
:
:
IterableDataProvider
<
M
>
{
fn
supported_locales
(
&
self
)
-
>
Result
<
alloc
:
:
vec
:
:
Vec
<
DataLocale
>
DataError
>
{
self
.
inner
.
supported_locales
(
)
.
map
(
|
vec
|
{
vec
.
into_iter
(
)
.
filter_map
(
|
locale
|
{
if
(
self
.
predicate
)
(
DataRequest
{
locale
:
&
locale
metadata
:
Default
:
:
default
(
)
}
)
{
Some
(
locale
)
}
else
{
None
}
}
)
.
collect
(
)
}
)
}
}
#
[
cfg
(
feature
=
"
datagen
"
)
]
impl
<
D
F
MFrom
MTo
>
datagen
:
:
DataConverter
<
MFrom
MTo
>
for
RequestFilterDataProvider
<
D
F
>
where
D
:
datagen
:
:
DataConverter
<
MFrom
MTo
>
MFrom
:
DataMarker
MTo
:
DataMarker
F
:
Fn
(
DataRequest
)
-
>
bool
{
fn
convert
(
&
self
key
:
DataKey
from
:
DataPayload
<
MFrom
>
)
-
>
Result
<
DataPayload
<
MTo
>
(
DataPayload
<
MFrom
>
DataError
)
>
{
self
.
inner
.
convert
(
key
from
)
}
}
pub
trait
Filterable
:
Sized
{
fn
filterable
(
self
filter_name
:
&
'
static
str
)
-
>
RequestFilterDataProvider
<
Self
fn
(
DataRequest
)
-
>
bool
>
;
}
impl
<
T
>
Filterable
for
T
where
T
:
Sized
{
fn
filterable
(
self
filter_name
:
&
'
static
str
)
-
>
RequestFilterDataProvider
<
Self
fn
(
DataRequest
)
-
>
bool
>
{
fn
noop
(
_
:
DataRequest
)
-
>
bool
{
true
}
RequestFilterDataProvider
{
inner
:
self
predicate
:
noop
filter_name
}
}
}
