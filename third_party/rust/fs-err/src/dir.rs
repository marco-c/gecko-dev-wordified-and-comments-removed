use
std
:
:
ffi
:
:
OsString
;
use
std
:
:
fs
;
use
std
:
:
io
;
use
std
:
:
path
:
:
PathBuf
;
use
crate
:
:
errors
:
:
{
Error
ErrorKind
}
;
pub
fn
read_dir
<
P
:
Into
<
PathBuf
>
>
(
path
:
P
)
-
>
io
:
:
Result
<
ReadDir
>
{
let
path
=
path
.
into
(
)
;
match
fs
:
:
read_dir
(
&
path
)
{
Ok
(
inner
)
=
>
Ok
(
ReadDir
{
inner
path
}
)
Err
(
source
)
=
>
Err
(
Error
:
:
build
(
source
ErrorKind
:
:
ReadDir
path
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ReadDir
{
inner
:
fs
:
:
ReadDir
path
:
PathBuf
}
impl
Iterator
for
ReadDir
{
type
Item
=
io
:
:
Result
<
DirEntry
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
Some
(
self
.
inner
.
next
(
)
?
.
map_err
(
|
source
|
Error
:
:
build
(
source
ErrorKind
:
:
ReadDir
&
self
.
path
)
)
.
map
(
|
inner
|
DirEntry
{
inner
}
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
DirEntry
{
inner
:
fs
:
:
DirEntry
}
impl
DirEntry
{
pub
fn
path
(
&
self
)
-
>
PathBuf
{
self
.
inner
.
path
(
)
}
pub
fn
metadata
(
&
self
)
-
>
io
:
:
Result
<
fs
:
:
Metadata
>
{
self
.
inner
.
metadata
(
)
.
map_err
(
|
source
|
Error
:
:
build
(
source
ErrorKind
:
:
Metadata
self
.
path
(
)
)
)
}
pub
fn
file_type
(
&
self
)
-
>
io
:
:
Result
<
fs
:
:
FileType
>
{
self
.
inner
.
file_type
(
)
.
map_err
(
|
source
|
Error
:
:
build
(
source
ErrorKind
:
:
Metadata
self
.
path
(
)
)
)
}
pub
fn
file_name
(
&
self
)
-
>
OsString
{
self
.
inner
.
file_name
(
)
}
}
#
[
cfg
(
unix
)
]
mod
unix
{
use
std
:
:
os
:
:
unix
:
:
fs
:
:
DirEntryExt
;
use
super
:
:
*
;
impl
DirEntryExt
for
DirEntry
{
fn
ino
(
&
self
)
-
>
u64
{
self
.
inner
.
ino
(
)
}
}
}
