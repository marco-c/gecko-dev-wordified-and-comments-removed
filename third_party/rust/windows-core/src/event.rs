use
super
:
:
*
;
use
core
:
:
{
iter
:
:
once
mem
:
:
transmute_copy
}
;
use
std
:
:
sync
:
:
{
Arc
RwLock
}
;
pub
struct
Event
<
T
:
Interface
>
{
delegates
:
RwLock
<
Option
<
Arc
<
[
Delegate
<
T
>
]
>
>
>
}
unsafe
impl
<
T
:
Interface
>
Send
for
Event
<
T
>
{
}
unsafe
impl
<
T
:
Interface
>
Sync
for
Event
<
T
>
{
}
impl
<
T
:
Interface
>
Default
for
Event
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
T
:
Interface
>
Event
<
T
>
{
pub
const
fn
new
(
)
-
>
Self
{
Self
{
delegates
:
RwLock
:
:
new
(
None
)
}
}
pub
fn
add
(
&
self
delegate
:
&
T
)
-
>
Result
<
i64
>
{
let
new_delegate
=
Delegate
:
:
new
(
delegate
)
?
;
let
token
=
new_delegate
.
to_token
(
)
;
let
new_iter
=
once
(
new_delegate
)
;
let
mut
guard
=
self
.
delegates
.
write
(
)
.
unwrap
(
)
;
let
new_list
=
if
let
Some
(
old_delegates
)
=
guard
.
as_ref
(
)
{
Arc
:
:
from_iter
(
old_delegates
.
iter
(
)
.
cloned
(
)
.
chain
(
new_iter
)
)
}
else
{
Arc
:
:
from_iter
(
new_iter
)
}
;
let
old_list
=
guard
.
replace
(
new_list
)
;
drop
(
guard
)
;
drop
(
old_list
)
;
Ok
(
token
)
}
pub
fn
remove
(
&
self
token
:
i64
)
{
let
mut
guard
=
self
.
delegates
.
write
(
)
.
unwrap
(
)
;
let
mut
old_list
=
None
;
if
let
Some
(
old_delegates
)
=
guard
.
as_ref
(
)
{
if
let
Some
(
i
)
=
old_delegates
.
iter
(
)
.
position
(
|
old_delegate
|
old_delegate
.
to_token
(
)
=
=
token
)
{
let
new_list
=
Arc
:
:
from_iter
(
old_delegates
[
.
.
i
]
.
iter
(
)
.
chain
(
old_delegates
[
i
+
1
.
.
]
.
iter
(
)
)
.
cloned
(
)
)
;
old_list
=
guard
.
replace
(
new_list
)
;
}
}
drop
(
guard
)
;
drop
(
old_list
)
;
}
pub
fn
clear
(
&
self
)
{
let
mut
guard
=
self
.
delegates
.
write
(
)
.
unwrap
(
)
;
let
old_list
=
guard
.
take
(
)
;
drop
(
guard
)
;
drop
(
old_list
)
;
}
pub
fn
call
<
F
:
FnMut
(
&
T
)
-
>
Result
<
(
)
>
>
(
&
self
mut
callback
:
F
)
{
let
delegates
=
{
let
guard
=
self
.
delegates
.
read
(
)
.
unwrap
(
)
;
if
let
Some
(
delegates
)
=
guard
.
as_ref
(
)
{
delegates
.
clone
(
)
}
else
{
return
;
}
}
;
for
delegate
in
delegates
.
iter
(
)
{
if
let
Err
(
error
)
=
delegate
.
call
(
&
mut
callback
)
{
const
RPC_E_SERVER_UNAVAILABLE
:
HRESULT
=
HRESULT
(
-
2147023174
)
;
if
matches
!
(
error
.
code
(
)
imp
:
:
RPC_E_DISCONNECTED
|
imp
:
:
JSCRIPT_E_CANTEXECUTE
|
RPC_E_SERVER_UNAVAILABLE
)
{
self
.
remove
(
delegate
.
to_token
(
)
)
;
}
}
}
}
}
#
[
derive
(
Clone
)
]
enum
Delegate
<
T
>
{
Direct
(
T
)
Indirect
(
AgileReference
<
T
>
)
}
impl
<
T
:
Interface
>
Delegate
<
T
>
{
fn
new
(
delegate
:
&
T
)
-
>
Result
<
Self
>
{
if
delegate
.
cast
:
:
<
imp
:
:
IAgileObject
>
(
)
.
is_ok
(
)
{
Ok
(
Self
:
:
Direct
(
delegate
.
clone
(
)
)
)
}
else
{
Ok
(
Self
:
:
Indirect
(
AgileReference
:
:
new
(
delegate
)
?
)
)
}
}
fn
to_token
(
&
self
)
-
>
i64
{
unsafe
{
match
self
{
Self
:
:
Direct
(
delegate
)
=
>
imp
:
:
EncodePointer
(
transmute_copy
(
delegate
)
)
as
i64
Self
:
:
Indirect
(
delegate
)
=
>
imp
:
:
EncodePointer
(
transmute_copy
(
delegate
)
)
as
i64
}
}
}
fn
call
<
F
:
FnMut
(
&
T
)
-
>
Result
<
(
)
>
>
(
&
self
mut
callback
:
F
)
-
>
Result
<
(
)
>
{
match
self
{
Self
:
:
Direct
(
delegate
)
=
>
callback
(
delegate
)
Self
:
:
Indirect
(
delegate
)
=
>
callback
(
&
delegate
.
resolve
(
)
?
)
}
}
}
