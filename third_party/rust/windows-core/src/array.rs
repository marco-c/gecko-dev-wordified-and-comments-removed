use
super
:
:
*
;
pub
struct
Array
<
T
:
Type
<
T
>
>
{
data
:
*
mut
T
:
:
Default
len
:
u32
}
impl
<
T
:
Type
<
T
>
>
Default
for
Array
<
T
>
{
fn
default
(
)
-
>
Self
{
Array
{
data
:
std
:
:
ptr
:
:
null_mut
(
)
len
:
0
}
}
}
impl
<
T
:
Type
<
T
>
>
Array
<
T
>
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
with_len
(
len
:
usize
)
-
>
Self
{
assert
!
(
len
<
std
:
:
u32
:
:
MAX
as
usize
)
;
let
bytes_amount
=
len
.
checked_mul
(
std
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
)
.
expect
(
"
Attempted
to
allocate
too
large
an
Array
"
)
;
let
data
=
unsafe
{
crate
:
:
imp
:
:
CoTaskMemAlloc
(
bytes_amount
)
as
*
mut
T
:
:
Default
}
;
assert
!
(
!
data
.
is_null
(
)
"
Could
not
successfully
allocate
for
Array
"
)
;
unsafe
{
std
:
:
ptr
:
:
write_bytes
(
data
0
len
)
;
}
let
len
=
len
as
u32
;
Self
{
data
len
}
}
pub
fn
from_slice
(
values
:
&
[
T
:
:
Default
]
)
-
>
Self
where
T
:
:
Default
:
Clone
{
let
mut
array
=
Self
:
:
with_len
(
values
.
len
(
)
)
;
array
.
clone_from_slice
(
values
)
;
array
}
pub
unsafe
fn
from_raw_parts
(
data
:
*
mut
T
:
:
Default
len
:
u32
)
-
>
Self
{
Self
{
data
len
}
}
pub
fn
as_slice
(
&
self
)
-
>
&
[
T
:
:
Default
]
{
self
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
=
=
0
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
len
as
usize
}
pub
fn
clear
(
&
mut
self
)
{
if
self
.
is_empty
(
)
{
return
;
}
let
mut
data
=
std
:
:
ptr
:
:
null_mut
(
)
;
let
mut
len
=
0
;
std
:
:
mem
:
:
swap
(
&
mut
data
&
mut
self
.
data
)
;
std
:
:
mem
:
:
swap
(
&
mut
len
&
mut
self
.
len
)
;
unsafe
{
std
:
:
ptr
:
:
drop_in_place
(
std
:
:
slice
:
:
from_raw_parts_mut
(
data
len
as
usize
)
)
;
crate
:
:
imp
:
:
CoTaskMemFree
(
data
as
_
)
;
}
}
#
[
doc
(
hidden
)
]
pub
unsafe
fn
set_abi_len
(
&
mut
self
)
-
>
*
mut
u32
{
&
mut
self
.
len
}
#
[
doc
(
hidden
)
]
pub
fn
into_abi
(
self
)
-
>
(
*
mut
T
:
:
Abi
u32
)
{
let
abi
=
(
self
.
data
as
*
mut
_
self
.
len
)
;
std
:
:
mem
:
:
forget
(
self
)
;
abi
}
}
impl
<
T
:
Type
<
T
>
>
std
:
:
ops
:
:
Deref
for
Array
<
T
>
{
type
Target
=
[
T
:
:
Default
]
;
fn
deref
(
&
self
)
-
>
&
[
T
:
:
Default
]
{
if
self
.
is_empty
(
)
{
return
&
[
]
;
}
unsafe
{
std
:
:
slice
:
:
from_raw_parts
(
self
.
data
self
.
len
as
usize
)
}
}
}
impl
<
T
:
Type
<
T
>
>
std
:
:
ops
:
:
DerefMut
for
Array
<
T
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
[
T
:
:
Default
]
{
if
self
.
is_empty
(
)
{
return
&
mut
[
]
;
}
unsafe
{
std
:
:
slice
:
:
from_raw_parts_mut
(
self
.
data
self
.
len
as
usize
)
}
}
}
impl
<
T
:
Type
<
T
>
>
Drop
for
Array
<
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
clear
(
)
;
}
}
#
[
doc
(
hidden
)
]
pub
struct
ArrayProxy
<
T
:
Type
<
T
>
>
{
data
:
*
mut
*
mut
T
:
:
Default
len
:
*
mut
u32
temp
:
std
:
:
mem
:
:
ManuallyDrop
<
Array
<
T
>
>
}
impl
<
T
:
Type
<
T
>
>
ArrayProxy
<
T
>
{
pub
fn
from_raw_parts
(
data
:
*
mut
*
mut
T
:
:
Default
len
:
*
mut
u32
)
-
>
Self
{
Self
{
data
len
temp
:
std
:
:
mem
:
:
ManuallyDrop
:
:
new
(
Array
:
:
new
(
)
)
}
}
pub
fn
as_array
(
&
mut
self
)
-
>
&
mut
Array
<
T
>
{
&
mut
self
.
temp
}
}
impl
<
T
:
Type
<
T
>
>
Drop
for
ArrayProxy
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
*
self
.
data
=
self
.
temp
.
data
;
*
self
.
len
=
self
.
temp
.
len
;
}
}
}
