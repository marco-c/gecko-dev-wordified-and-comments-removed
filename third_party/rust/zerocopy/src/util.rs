#
[
path
=
"
third_party
/
rust
/
layout
.
rs
"
]
pub
(
crate
)
mod
core_layout
;
use
core
:
:
{
mem
num
:
:
NonZeroUsize
}
;
pub
(
crate
)
mod
ptr
{
use
core
:
:
{
fmt
:
:
{
Debug
Formatter
}
marker
:
:
PhantomData
ptr
:
:
NonNull
}
;
use
crate
:
:
{
util
:
:
AsAddress
KnownLayout
_CastType
}
;
pub
struct
Ptr
<
'
a
T
:
'
a
+
?
Sized
>
{
ptr
:
NonNull
<
T
>
_lifetime
:
PhantomData
<
&
'
a
(
)
>
}
impl
<
'
a
T
:
?
Sized
>
Copy
for
Ptr
<
'
a
T
>
{
}
impl
<
'
a
T
:
?
Sized
>
Clone
for
Ptr
<
'
a
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
'
a
T
:
?
Sized
>
Ptr
<
'
a
T
>
{
#
[
allow
(
unused
)
]
pub
(
crate
)
unsafe
fn
as_ref
(
&
self
)
-
>
&
'
a
T
{
unsafe
{
self
.
ptr
.
as_ref
(
)
}
}
pub
(
crate
)
unsafe
fn
cast_unsized
<
U
:
'
a
+
?
Sized
F
:
FnOnce
(
*
mut
T
)
-
>
*
mut
U
>
(
self
cast
:
F
)
-
>
Ptr
<
'
a
U
>
{
let
ptr
=
cast
(
self
.
ptr
.
as_ptr
(
)
)
;
let
ptr
=
unsafe
{
NonNull
:
:
new_unchecked
(
ptr
)
}
;
Ptr
{
ptr
_lifetime
:
PhantomData
}
}
}
impl
<
'
a
>
Ptr
<
'
a
[
u8
]
>
{
pub
(
crate
)
fn
try_cast_into
<
U
:
'
a
+
?
Sized
+
KnownLayout
>
(
&
self
cast_type
:
_CastType
)
-
>
Option
<
(
Ptr
<
'
a
U
>
usize
)
>
{
let
(
elems
split_at
)
=
U
:
:
LAYOUT
.
validate_cast_and_convert_metadata
(
AsAddress
:
:
addr
(
self
.
ptr
.
as_ptr
(
)
)
self
.
len
(
)
cast_type
)
?
;
let
offset
=
match
cast_type
{
_CastType
:
:
_Prefix
=
>
0
_CastType
:
:
_Suffix
=
>
split_at
}
;
let
ptr
=
self
.
ptr
.
cast
:
:
<
u8
>
(
)
.
as_ptr
(
)
;
let
base
=
unsafe
{
ptr
.
add
(
offset
)
}
;
let
base
=
unsafe
{
NonNull
:
:
new_unchecked
(
base
)
}
;
let
ptr
=
U
:
:
raw_from_ptr_len
(
base
elems
)
;
Some
(
(
Ptr
{
ptr
_lifetime
:
PhantomData
}
split_at
)
)
}
#
[
allow
(
unused
)
]
#
[
inline
(
always
)
]
pub
(
crate
)
fn
try_cast_into_no_leftover
<
U
:
'
a
+
?
Sized
+
KnownLayout
>
(
&
self
)
-
>
Option
<
Ptr
<
'
a
U
>
>
{
#
[
allow
(
unstable_name_collisions
)
]
match
self
.
try_cast_into
(
_CastType
:
:
_Prefix
)
{
Some
(
(
slf
split_at
)
)
if
split_at
=
=
self
.
len
(
)
=
>
Some
(
slf
)
Some
(
_
)
|
None
=
>
None
}
}
}
impl
<
'
a
T
>
Ptr
<
'
a
[
T
]
>
{
fn
len
(
&
self
)
-
>
usize
{
#
[
allow
(
clippy
:
:
as_conversions
)
]
let
slc
=
self
.
ptr
.
as_ptr
(
)
as
*
const
[
(
)
]
;
let
slc
=
unsafe
{
&
*
slc
}
;
slc
.
len
(
)
}
pub
(
crate
)
fn
iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
Ptr
<
'
a
T
>
>
{
let
base
=
self
.
ptr
.
cast
:
:
<
T
>
(
)
.
as_ptr
(
)
;
(
0
.
.
self
.
len
(
)
)
.
map
(
move
|
i
|
{
let
elem
=
unsafe
{
base
.
add
(
i
)
}
;
let
elem
=
unsafe
{
NonNull
:
:
new_unchecked
(
elem
)
}
;
Ptr
{
ptr
:
elem
_lifetime
:
PhantomData
}
}
)
}
}
impl
<
'
a
T
:
'
a
+
?
Sized
>
From
<
&
'
a
T
>
for
Ptr
<
'
a
T
>
{
#
[
inline
(
always
)
]
fn
from
(
t
:
&
'
a
T
)
-
>
Ptr
<
'
a
T
>
{
Ptr
{
ptr
:
NonNull
:
:
from
(
t
)
_lifetime
:
PhantomData
}
}
}
impl
<
'
a
T
:
'
a
+
?
Sized
>
Debug
for
Ptr
<
'
a
T
>
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
self
.
ptr
.
fmt
(
f
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
core
:
:
mem
:
:
{
self
MaybeUninit
}
;
use
super
:
:
*
;
use
crate
:
:
{
util
:
:
testutil
:
:
AU64
FromBytes
}
;
#
[
test
]
fn
test_ptrtry_cast_into_soundness
(
)
{
fn
test
<
const
N
:
usize
T
:
?
Sized
+
KnownLayout
+
FromBytes
>
(
)
{
let
mut
bytes
=
[
MaybeUninit
:
:
<
u8
>
:
:
uninit
(
)
;
N
]
;
let
initialized
=
[
MaybeUninit
:
:
new
(
0u8
)
;
N
]
;
for
start
in
0
.
.
=
bytes
.
len
(
)
{
for
end
in
start
.
.
=
bytes
.
len
(
)
{
bytes
=
[
MaybeUninit
:
:
<
u8
>
:
:
uninit
(
)
;
N
]
;
let
bytes
=
&
mut
bytes
[
start
.
.
end
]
;
bytes
.
copy_from_slice
(
&
initialized
[
start
.
.
end
]
)
;
let
bytes
=
{
let
bytes
:
*
const
[
MaybeUninit
<
u8
>
]
=
bytes
;
#
[
allow
(
clippy
:
:
as_conversions
)
]
let
bytes
=
bytes
as
*
const
[
u8
]
;
unsafe
{
&
*
bytes
}
}
;
unsafe
fn
validate_and_get_len
<
T
:
?
Sized
+
KnownLayout
+
FromBytes
>
(
slf
:
Ptr
<
'
_
T
>
)
-
>
usize
{
let
t
=
unsafe
{
slf
.
as_ref
(
)
}
;
let
bytes
=
{
let
len
=
mem
:
:
size_of_val
(
t
)
;
let
t
:
*
const
T
=
t
;
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
t
.
cast
:
:
<
u8
>
(
)
len
)
}
}
;
assert_eq
!
(
bytes
vec
!
[
0u8
;
bytes
.
len
(
)
]
)
;
mem
:
:
size_of_val
(
t
)
}
for
cast_type
in
[
_CastType
:
:
_Prefix
_CastType
:
:
_Suffix
]
{
if
let
Some
(
(
slf
split_at
)
)
=
Ptr
:
:
from
(
bytes
)
.
try_cast_into
:
:
<
T
>
(
cast_type
)
{
let
len
=
unsafe
{
validate_and_get_len
(
slf
)
}
;
match
cast_type
{
_CastType
:
:
_Prefix
=
>
assert_eq
!
(
split_at
len
)
_CastType
:
:
_Suffix
=
>
assert_eq
!
(
split_at
bytes
.
len
(
)
-
len
)
}
}
}
if
let
Some
(
slf
)
=
Ptr
:
:
from
(
bytes
)
.
try_cast_into_no_leftover
:
:
<
T
>
(
)
{
let
len
=
unsafe
{
validate_and_get_len
(
slf
)
}
;
assert_eq
!
(
len
bytes
.
len
(
)
)
;
}
}
}
}
macro_rules
!
test
{
(
(
ty
:
ty
)
*
)
=
>
{
(
{
const
S
:
usize
=
core
:
:
mem
:
:
size_of
:
:
<
ty
>
(
)
;
const
N
:
usize
=
if
S
=
=
0
{
4
}
else
{
S
*
4
}
;
test
:
:
<
N
ty
>
(
)
;
/
/
We
don
'
t
support
casting
into
DSTs
whose
trailing
slice
/
/
element
is
a
ZST
.
if
S
>
0
{
test
:
:
<
N
[
ty
]
>
(
)
;
}
/
/
TODO
:
Test
with
a
slice
DST
once
we
have
any
that
/
/
implement
KnownLayout
+
FromBytes
.
}
)
*
}
;
}
test
!
(
(
)
)
;
test
!
(
u8
u16
u32
u64
u128
usize
AU64
)
;
test
!
(
i8
i16
i32
i64
i128
isize
)
;
test
!
(
f32
f64
)
;
}
}
}
pub
(
crate
)
trait
AsAddress
{
fn
addr
(
self
)
-
>
usize
;
}
impl
<
'
a
T
:
?
Sized
>
AsAddress
for
&
'
a
T
{
#
[
inline
(
always
)
]
fn
addr
(
self
)
-
>
usize
{
let
ptr
:
*
const
T
=
self
;
AsAddress
:
:
addr
(
ptr
)
}
}
impl
<
'
a
T
:
?
Sized
>
AsAddress
for
&
'
a
mut
T
{
#
[
inline
(
always
)
]
fn
addr
(
self
)
-
>
usize
{
let
ptr
:
*
const
T
=
self
;
AsAddress
:
:
addr
(
ptr
)
}
}
impl
<
T
:
?
Sized
>
AsAddress
for
*
const
T
{
#
[
inline
(
always
)
]
fn
addr
(
self
)
-
>
usize
{
#
[
allow
(
clippy
:
:
as_conversions
)
]
#
[
cfg_attr
(
__INTERNAL_USE_ONLY_NIGHLTY_FEATURES_IN_TESTS
allow
(
lossy_provenance_casts
)
)
]
return
self
.
cast
:
:
<
(
)
>
(
)
as
usize
;
}
}
impl
<
T
:
?
Sized
>
AsAddress
for
*
mut
T
{
#
[
inline
(
always
)
]
fn
addr
(
self
)
-
>
usize
{
let
ptr
:
*
const
T
=
self
;
AsAddress
:
:
addr
(
ptr
)
}
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
aligned_to
<
T
:
AsAddress
U
>
(
t
:
T
)
-
>
bool
{
#
[
allow
(
clippy
:
:
arithmetic_side_effects
)
]
let
remainder
=
t
.
addr
(
)
%
mem
:
:
align_of
:
:
<
U
>
(
)
;
remainder
=
=
0
}
#
[
inline
(
always
)
]
pub
(
crate
)
const
fn
round_down_to_next_multiple_of_alignment
(
n
:
usize
align
:
NonZeroUsize
)
-
>
usize
{
let
align
=
align
.
get
(
)
;
debug_assert
!
(
align
.
is_power_of_two
(
)
)
;
#
[
allow
(
clippy
:
:
arithmetic_side_effects
)
]
let
mask
=
!
(
align
-
1
)
;
n
&
mask
}
pub
(
crate
)
const
fn
max
(
a
:
NonZeroUsize
b
:
NonZeroUsize
)
-
>
NonZeroUsize
{
if
a
.
get
(
)
<
b
.
get
(
)
{
b
}
else
{
a
}
}
pub
(
crate
)
const
fn
min
(
a
:
NonZeroUsize
b
:
NonZeroUsize
)
-
>
NonZeroUsize
{
if
a
.
get
(
)
>
b
.
get
(
)
{
b
}
else
{
a
}
}
pub
(
crate
)
mod
polyfills
{
use
core
:
:
ptr
:
:
{
self
NonNull
}
;
pub
(
crate
)
trait
NonNullExt
<
T
>
{
fn
slice_from_raw_parts
(
data
:
Self
len
:
usize
)
-
>
NonNull
<
[
T
]
>
;
}
impl
<
T
>
NonNullExt
<
T
>
for
NonNull
<
T
>
{
#
[
inline
(
always
)
]
fn
slice_from_raw_parts
(
data
:
Self
len
:
usize
)
-
>
NonNull
<
[
T
]
>
{
let
ptr
=
ptr
:
:
slice_from_raw_parts_mut
(
data
.
as_ptr
(
)
len
)
;
unsafe
{
NonNull
:
:
new_unchecked
(
ptr
)
}
}
}
}
#
[
cfg
(
test
)
]
pub
(
crate
)
mod
testutil
{
use
core
:
:
fmt
:
:
{
self
Display
Formatter
}
;
use
crate
:
:
*
;
#
[
derive
(
Default
)
]
pub
(
crate
)
struct
Align
<
T
A
>
{
pub
(
crate
)
t
:
T
_a
:
[
A
;
0
]
}
impl
<
T
:
Default
A
>
Align
<
T
A
>
{
pub
(
crate
)
fn
set_default
(
&
mut
self
)
{
self
.
t
=
T
:
:
default
(
)
;
}
}
impl
<
T
A
>
Align
<
T
A
>
{
pub
(
crate
)
const
fn
new
(
t
:
T
)
-
>
Align
<
T
A
>
{
Align
{
t
_a
:
[
]
}
}
}
#
[
derive
(
KnownLayout
FromZeroes
FromBytes
AsBytes
Eq
PartialEq
Ord
PartialOrd
Default
Debug
Copy
Clone
)
]
#
[
repr
(
C
align
(
8
)
)
]
pub
(
crate
)
struct
AU64
(
pub
(
crate
)
u64
)
;
impl
AU64
{
pub
(
crate
)
fn
to_bytes
(
self
)
-
>
[
u8
;
8
]
{
crate
:
:
transmute
!
(
self
)
}
}
impl
Display
for
AU64
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
self
.
0
f
)
}
}
#
[
derive
(
FromZeroes
FromBytes
Eq
PartialEq
Ord
PartialOrd
Default
Debug
Copy
Clone
)
]
#
[
repr
(
C
)
]
pub
(
crate
)
struct
Nested
<
T
U
:
?
Sized
>
{
_t
:
T
_u
:
U
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
test_round_down_to_next_multiple_of_alignment
(
)
{
fn
alt_impl
(
n
:
usize
align
:
NonZeroUsize
)
-
>
usize
{
let
mul
=
n
/
align
.
get
(
)
;
mul
*
align
.
get
(
)
}
for
align
in
[
1
2
4
8
16
]
{
for
n
in
0
.
.
256
{
let
align
=
NonZeroUsize
:
:
new
(
align
)
.
unwrap
(
)
;
let
want
=
alt_impl
(
n
align
)
;
let
got
=
round_down_to_next_multiple_of_alignment
(
n
align
)
;
assert_eq
!
(
got
want
"
round_down_to_next_multiple_of_alignment
(
{
n
}
{
align
}
)
"
)
;
}
}
}
}
#
[
cfg
(
kani
)
]
mod
proofs
{
use
super
:
:
*
;
#
[
kani
:
:
proof
]
fn
prove_round_down_to_next_multiple_of_alignment
(
)
{
fn
model_impl
(
n
:
usize
align
:
NonZeroUsize
)
-
>
usize
{
assert
!
(
align
.
get
(
)
.
is_power_of_two
(
)
)
;
let
mul
=
n
/
align
.
get
(
)
;
mul
*
align
.
get
(
)
}
let
align
:
NonZeroUsize
=
kani
:
:
any
(
)
;
kani
:
:
assume
(
align
.
get
(
)
.
is_power_of_two
(
)
)
;
let
n
:
usize
=
kani
:
:
any
(
)
;
let
expected
=
model_impl
(
n
align
)
;
let
actual
=
round_down_to_next_multiple_of_alignment
(
n
align
)
;
assert_eq
!
(
expected
actual
"
round_down_to_next_multiple_of_alignment
(
{
n
}
{
align
}
)
"
)
;
}
#
[
cfg
(
__INTERNAL_USE_ONLY_NIGHLTY_FEATURES_IN_TESTS
)
]
#
[
kani
:
:
proof
]
fn
prove_padding_needed_for
(
)
{
fn
model_impl
(
len
:
usize
align
:
NonZeroUsize
)
-
>
usize
{
let
padded
=
len
.
next_multiple_of
(
align
.
get
(
)
)
;
let
padding
=
padded
-
len
;
padding
}
let
align
:
NonZeroUsize
=
kani
:
:
any
(
)
;
kani
:
:
assume
(
align
.
get
(
)
.
is_power_of_two
(
)
)
;
let
len
:
usize
=
kani
:
:
any
(
)
;
kani
:
:
assume
(
len
<
=
isize
:
:
MAX
as
usize
)
;
kani
:
:
assume
(
align
.
get
(
)
<
1
<
<
29
)
;
let
expected
=
model_impl
(
len
align
)
;
let
actual
=
core_layout
:
:
padding_needed_for
(
len
align
)
;
assert_eq
!
(
expected
actual
"
padding_needed_for
(
{
len
}
{
align
}
)
"
)
;
let
padded_len
=
actual
+
len
;
assert_eq
!
(
padded_len
%
align
0
)
;
assert
!
(
padded_len
/
align
>
=
len
/
align
)
;
}
}
