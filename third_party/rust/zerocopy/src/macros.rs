macro_rules
!
safety_comment
{
(
#
[
doc
=
r
"
SAFETY
:
"
]
(
(
#
[
attr
:
meta
]
)
*
macro
:
ident
!
args
:
tt
;
)
*
)
=
>
{
#
[
allow
(
clippy
:
:
undocumented_unsafe_blocks
unused_attributes
)
]
const
_
:
(
)
=
{
(
(
#
[
attr
]
)
*
macro
!
args
;
)
*
}
;
}
}
macro_rules
!
unsafe_impl
{
(
(
#
[
attr
:
meta
]
)
*
ty
:
ty
:
trait
:
ident
(
;
|
candidate
:
ident
:
&
repr
:
ty
|
is_bit_valid
:
expr
)
?
)
=
>
{
(
#
[
attr
]
)
*
unsafe
impl
trait
for
ty
{
unsafe_impl
!
(
method
trait
(
;
|
candidate
:
&
repr
|
is_bit_valid
)
?
)
;
}
}
;
(
ty
:
ty
:
(
traits
:
ident
)
*
)
=
>
{
(
unsafe_impl
!
(
ty
:
traits
)
;
)
*
}
;
(
(
#
[
attr
:
meta
]
)
*
const
constname
:
ident
:
constty
:
ident
(
)
?
(
tyvar
:
ident
(
:
(
?
optbound
:
ident
(
+
)
?
)
*
(
bound
:
ident
(
+
)
?
)
*
)
?
)
*
=
>
trait
:
ident
for
ty
:
ty
(
;
|
candidate
:
ident
(
:
&
ref_repr
:
ty
)
?
(
:
Ptr
<
ptr_repr
:
ty
>
)
?
|
is_bit_valid
:
expr
)
?
)
=
>
{
unsafe_impl
!
(
inner
(
#
[
attr
]
)
*
const
constname
:
constty
(
tyvar
(
:
(
?
optbound
+
)
*
+
(
bound
+
)
*
)
?
)
*
=
>
trait
for
ty
(
;
|
candidate
(
:
&
ref_repr
)
?
(
:
Ptr
<
ptr_repr
>
)
?
|
is_bit_valid
)
?
)
;
}
;
(
(
#
[
attr
:
meta
]
)
*
(
tyvar
:
ident
(
:
(
?
optbound
:
ident
(
+
)
?
)
*
(
bound
:
ident
(
+
)
?
)
*
)
?
)
*
=
>
trait
:
ident
for
ty
:
ty
(
;
|
candidate
:
ident
(
:
&
ref_repr
:
ty
)
?
(
:
Ptr
<
ptr_repr
:
ty
>
)
?
|
is_bit_valid
:
expr
)
?
)
=
>
{
unsafe_impl
!
(
inner
(
#
[
attr
]
)
*
(
tyvar
(
:
(
?
optbound
+
)
*
+
(
bound
+
)
*
)
?
)
*
=
>
trait
for
ty
(
;
|
candidate
(
:
&
ref_repr
)
?
(
:
Ptr
<
ptr_repr
>
)
?
|
is_bit_valid
)
?
)
;
}
;
(
inner
(
#
[
attr
:
meta
]
)
*
(
const
constname
:
ident
:
constty
:
ident
)
*
(
tyvar
:
ident
(
:
(
?
optbound
:
ident
+
)
*
+
(
bound
:
ident
+
)
*
)
?
)
*
=
>
trait
:
ident
for
ty
:
ty
(
;
|
candidate
:
ident
(
:
&
ref_repr
:
ty
)
?
(
:
Ptr
<
ptr_repr
:
ty
>
)
?
|
is_bit_valid
:
expr
)
?
)
=
>
{
(
#
[
attr
]
)
*
unsafe
impl
<
(
const
constname
:
constty
)
*
(
tyvar
(
:
(
?
optbound
+
)
*
(
bound
+
)
*
)
?
)
*
>
trait
for
ty
{
unsafe_impl
!
(
method
trait
(
;
|
candidate
:
(
&
ref_repr
)
?
(
Ptr
<
ptr_repr
>
)
?
|
is_bit_valid
)
?
)
;
}
}
;
(
method
TryFromBytes
;
|
candidate
:
ident
:
&
repr
:
ty
|
is_bit_valid
:
expr
)
=
>
{
#
[
inline
]
unsafe
fn
is_bit_valid
(
candidate
:
Ptr
<
'
_
Self
>
)
-
>
bool
{
/
/
SAFETY
:
/
/
-
The
argument
to
cast_unsized
is
|
p
|
p
as
*
mut
_
as
required
/
/
by
that
method
'
s
safety
precondition
.
/
/
-
The
caller
has
promised
that
the
cast
results
in
an
object
of
/
/
equal
or
lesser
size
.
/
/
-
The
caller
has
promised
that
repr
'
s
alignment
is
less
than
/
/
or
equal
to
Self
'
s
alignment
.
#
[
allow
(
clippy
:
:
as_conversions
)
]
let
candidate
=
unsafe
{
candidate
.
cast_unsized
:
:
<
repr
_
>
(
|
p
|
p
as
*
mut
_
)
}
;
/
/
SAFETY
:
/
/
-
The
caller
has
promised
that
the
referenced
memory
region
will
/
/
contain
a
valid
repr
for
'
a
.
/
/
-
The
memory
may
not
be
referenced
by
any
mutable
references
.
/
/
This
is
a
precondition
of
is_bit_valid
.
/
/
-
The
memory
may
not
be
mutated
even
via
UnsafeCell
s
.
This
is
a
/
/
precondition
of
is_bit_valid
.
/
/
-
There
must
not
exist
any
references
to
the
same
memory
region
/
/
which
contain
UnsafeCell
s
at
byte
ranges
which
are
not
/
/
identical
to
the
byte
ranges
at
which
T
contains
/
/
UnsafeCell
s
.
This
is
a
precondition
of
is_bit_valid
.
let
candidate
:
&
repr
=
unsafe
{
candidate
.
as_ref
(
)
}
;
is_bit_valid
}
}
;
(
method
TryFromBytes
;
|
candidate
:
ident
:
Ptr
<
repr
:
ty
>
|
is_bit_valid
:
expr
)
=
>
{
#
[
inline
]
unsafe
fn
is_bit_valid
(
candidate
:
Ptr
<
'
_
Self
>
)
-
>
bool
{
/
/
SAFETY
:
/
/
-
The
argument
to
cast_unsized
is
|
p
|
p
as
*
mut
_
as
required
/
/
by
that
method
'
s
safety
precondition
.
/
/
-
The
caller
has
promised
that
the
cast
results
in
an
object
of
/
/
equal
or
lesser
size
.
/
/
-
The
caller
has
promised
that
repr
'
s
alignment
is
less
than
/
/
or
equal
to
Self
'
s
alignment
.
#
[
allow
(
clippy
:
:
as_conversions
)
]
let
candidate
=
unsafe
{
candidate
.
cast_unsized
:
:
<
repr
_
>
(
|
p
|
p
as
*
mut
_
)
}
;
is_bit_valid
}
}
;
(
method
TryFromBytes
)
=
>
{
#
[
inline
(
always
)
]
unsafe
fn
is_bit_valid
(
_
:
Ptr
<
'
_
Self
>
)
-
>
bool
{
true
}
}
;
(
method
trait
:
ident
)
=
>
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
only_derive_is_allowed_to_implement_this_trait
(
)
{
}
}
;
(
method
trait
:
ident
;
|
_candidate
:
ident
(
:
&
_ref_repr
:
ty
)
?
(
:
NonNull
<
_ptr_repr
:
ty
>
)
?
|
_is_bit_valid
:
expr
)
=
>
{
compile_error
!
(
"
Can
'
t
provide
is_bit_valid
impl
for
trait
other
than
TryFromBytes
"
)
;
}
;
}
macro_rules
!
unsafe_impl_for_power_set
{
(
first
:
ident
(
rest
:
ident
)
*
(
-
>
ret
:
ident
)
?
=
>
trait
:
ident
for
macro
:
ident
!
(
.
.
.
)
)
=
>
{
unsafe_impl_for_power_set
!
(
(
rest
)
*
(
-
>
ret
)
?
=
>
trait
for
macro
!
(
.
.
.
)
)
;
unsafe_impl_for_power_set
!
(
impl
first
(
rest
)
*
(
-
>
ret
)
?
=
>
trait
for
macro
!
(
.
.
.
)
)
;
}
;
(
(
-
>
ret
:
ident
)
?
=
>
trait
:
ident
for
macro
:
ident
!
(
.
.
.
)
)
=
>
{
unsafe_impl_for_power_set
!
(
impl
(
-
>
ret
)
?
=
>
trait
for
macro
!
(
.
.
.
)
)
;
}
;
(
impl
(
vars
:
ident
)
*
(
-
>
ret
:
ident
)
?
=
>
trait
:
ident
for
macro
:
ident
!
(
.
.
.
)
)
=
>
{
unsafe
impl
<
(
vars
)
*
(
ret
)
?
>
trait
for
macro
!
(
(
vars
)
*
(
-
>
ret
)
?
)
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
only_derive_is_allowed_to_implement_this_trait
(
)
{
}
}
}
;
}
macro_rules
!
opt_extern_c_fn
{
(
(
args
:
ident
)
*
-
>
ret
:
ident
)
=
>
{
Option
<
extern
"
C
"
fn
(
(
args
)
*
)
-
>
ret
>
}
;
}
macro_rules
!
opt_fn
{
(
(
args
:
ident
)
*
-
>
ret
:
ident
)
=
>
{
Option
<
fn
(
(
args
)
*
)
-
>
ret
>
}
;
}
macro_rules
!
impl_or_verify
{
(
const
constname
:
ident
:
constty
:
ident
(
)
?
(
tyvar
:
ident
(
:
(
?
optbound
:
ident
(
+
)
?
)
*
(
bound
:
ident
(
+
)
?
)
*
)
?
)
*
=
>
trait
:
ident
for
ty
:
ty
)
=
>
{
impl_or_verify
!
(
impl
{
unsafe_impl
!
(
const
constname
:
constty
(
tyvar
(
:
(
?
optbound
+
)
*
(
bound
+
)
*
)
?
)
*
=
>
trait
for
ty
)
;
}
)
;
impl_or_verify
!
(
verify
trait
{
impl
<
const
constname
:
constty
(
tyvar
(
:
(
?
optbound
+
)
*
(
bound
+
)
*
)
?
)
*
>
Subtrait
for
ty
{
}
}
)
;
}
;
(
(
tyvar
:
ident
(
:
(
?
optbound
:
ident
(
+
)
?
)
*
(
bound
:
ident
(
+
)
?
)
*
)
?
)
*
=
>
trait
:
ident
for
ty
:
ty
)
=
>
{
impl_or_verify
!
(
impl
{
unsafe_impl
!
(
(
tyvar
(
:
(
?
optbound
+
)
*
(
bound
+
)
*
)
?
)
*
=
>
trait
for
ty
)
;
}
)
;
impl_or_verify
!
(
verify
trait
{
impl
<
(
tyvar
(
:
(
?
optbound
+
)
*
(
bound
+
)
*
)
?
)
*
>
Subtrait
for
ty
{
}
}
)
;
}
;
(
(
tyvar
:
ident
(
:
(
?
optbound
:
ident
(
+
)
?
)
*
(
bound
:
ident
(
+
)
?
)
*
)
?
)
*
=
>
trait
:
ident
for
ty
:
ty
)
=
>
{
unsafe_impl
!
(
inner
(
tyvar
(
:
(
?
optbound
+
)
*
+
(
bound
+
)
*
)
?
)
*
=
>
trait
for
ty
)
;
}
;
(
impl
impl_block
:
tt
)
=
>
{
#
[
cfg
(
not
(
any
(
feature
=
"
derive
"
test
)
)
)
]
const
_
:
(
)
=
{
impl_block
}
;
}
;
(
verify
trait
:
ident
impl_block
:
tt
)
=
>
{
#
[
cfg
(
any
(
feature
=
"
derive
"
test
)
)
]
const
_
:
(
)
=
{
trait
Subtrait
:
trait
{
}
impl_block
}
;
}
;
}
macro_rules
!
impl_known_layout
{
(
(
const
constvar
:
ident
:
constty
:
ty
tyvar
:
ident
(
:
?
optbound
:
ident
)
?
=
>
ty
:
ty
)
*
(
)
?
)
=
>
{
(
impl_known_layout
!
(
inner
const
constvar
:
constty
tyvar
(
:
?
optbound
)
?
=
>
ty
)
;
)
*
}
;
(
(
tyvar
:
ident
(
:
?
optbound
:
ident
)
?
=
>
ty
:
ty
)
*
(
)
?
)
=
>
{
(
impl_known_layout
!
(
inner
tyvar
(
:
?
optbound
)
?
=
>
ty
)
;
)
*
}
;
(
(
ty
:
ty
)
*
)
=
>
{
(
impl_known_layout
!
(
inner
=
>
ty
)
;
)
*
}
;
(
inner
(
const
constvar
:
ident
:
constty
:
ty
)
?
(
tyvar
:
ident
(
:
?
optbound
:
ident
)
?
)
?
=
>
ty
:
ty
)
=
>
{
const
_
:
(
)
=
{
use
core
:
:
ptr
:
:
NonNull
;
/
/
SAFETY
:
Delegates
safety
to
DstLayout
:
:
for_type
.
unsafe
impl
<
(
const
constvar
:
constty
)
?
(
tyvar
(
:
?
optbound
)
?
)
?
>
KnownLayout
for
ty
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
only_derive_is_allowed_to_implement_this_trait
(
)
where
Self
:
Sized
{
}
const
LAYOUT
:
DstLayout
=
DstLayout
:
:
for_type
:
:
<
ty
>
(
)
;
/
/
SAFETY
:
.
cast
preserves
address
and
provenance
.
/
/
/
/
TODO
(
#
429
)
:
Add
documentation
to
.
cast
that
promises
that
/
/
it
preserves
provenance
.
#
[
inline
(
always
)
]
fn
raw_from_ptr_len
(
bytes
:
NonNull
<
u8
>
_elems
:
usize
)
-
>
NonNull
<
Self
>
{
bytes
.
cast
:
:
<
Self
>
(
)
}
}
}
;
}
;
}
macro_rules
!
unsafe_impl_known_layout
{
(
(
tyvar
:
ident
:
?
Sized
+
KnownLayout
=
>
)
?
#
[
repr
(
repr
:
ty
)
]
ty
:
ty
)
=
>
{
const
_
:
(
)
=
{
use
core
:
:
ptr
:
:
NonNull
;
unsafe
impl
<
(
tyvar
:
?
Sized
+
KnownLayout
)
?
>
KnownLayout
for
ty
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
only_derive_is_allowed_to_implement_this_trait
(
)
{
}
const
LAYOUT
:
DstLayout
=
<
repr
as
KnownLayout
>
:
:
LAYOUT
;
/
/
SAFETY
:
All
operations
preserve
address
and
provenance
.
/
/
Caller
has
promised
that
the
as
cast
preserves
size
.
/
/
/
/
TODO
(
#
429
)
:
Add
documentation
to
NonNull
:
:
new_unchecked
/
/
that
it
preserves
provenance
.
#
[
inline
(
always
)
]
#
[
allow
(
unused_qualifications
)
]
/
/
for
core
:
:
ptr
:
:
NonNull
fn
raw_from_ptr_len
(
bytes
:
NonNull
<
u8
>
elems
:
usize
)
-
>
NonNull
<
Self
>
{
#
[
allow
(
clippy
:
:
as_conversions
)
]
let
ptr
=
<
repr
>
:
:
raw_from_ptr_len
(
bytes
elems
)
.
as_ptr
(
)
as
*
mut
Self
;
/
/
SAFETY
:
ptr
was
converted
from
bytes
which
is
non
-
null
.
unsafe
{
NonNull
:
:
new_unchecked
(
ptr
)
}
}
}
}
;
}
;
}
macro_rules
!
assert_unaligned
{
(
ty
:
ty
)
=
>
{
/
/
We
only
compile
this
assertion
under
cfg
(
test
)
to
avoid
taking
an
/
/
extra
non
-
dev
dependency
(
and
making
this
crate
more
expensive
to
/
/
compile
for
our
dependents
)
.
#
[
cfg
(
test
)
]
static_assertions
:
:
const_assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
ty
>
(
)
1
)
;
}
;
(
(
ty
:
ty
)
*
)
=
>
{
(
assert_unaligned
!
(
ty
)
;
)
*
}
;
}
