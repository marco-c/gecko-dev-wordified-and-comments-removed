#
!
[
no_std
]
#
!
[
doc
(
test
(
no_crate_inject
attr
(
deny
(
warnings
rust_2018_idioms
single_use_lifetimes
)
allow
(
dead_code
)
)
)
)
]
#
!
[
warn
(
unsafe_code
)
]
#
!
[
warn
(
future_incompatible
rust_2018_idioms
single_use_lifetimes
unreachable_pub
)
]
#
!
[
warn
(
clippy
:
:
all
clippy
:
:
default_trait_access
)
]
#
!
[
allow
(
clippy
:
:
mem_replace_with_default
clippy
:
:
manual_non_exhaustive
clippy
:
:
match_like_matches_macro
)
]
#
[
macro_export
]
macro_rules
!
pin_project
{
(
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
__pin_project_internal
!
{
(
tt
)
*
}
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
__pin_project_internal
{
(
struct_internal
;
[
proj_vis
:
vis
]
[
(
#
[
attrs
:
meta
]
)
*
vis
:
vis
struct
ident
:
ident
]
[
(
def_generics
:
tt
)
*
]
[
(
impl_generics
:
tt
)
*
]
[
(
ty_generics
:
tt
)
*
]
[
(
where
(
where_clause
:
tt
)
*
)
?
]
{
(
(
#
[
pin
:
ident
]
)
?
field_vis
:
vis
field
:
ident
:
field_ty
:
ty
)
+
}
)
=
>
{
(
#
[
attrs
]
)
*
vis
struct
ident
(
def_generics
)
*
(
where
(
where_clause
)
*
)
?
{
(
field_vis
field
:
field_ty
)
+
}
#
[
allow
(
explicit_outlives_requirements
)
]
#
[
allow
(
single_use_lifetimes
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
55058
#
[
allow
(
clippy
:
:
redundant_pub_crate
)
]
#
[
allow
(
clippy
:
:
used_underscore_binding
)
]
const
_
:
(
)
=
{
crate
:
:
__pin_project_internal
!
{
make_proj_ty_struct
;
[
proj_vis
]
[
vis
struct
ident
]
[
(
impl_generics
)
*
]
[
(
ty_generics
)
*
]
[
(
where
(
where_clause
)
*
)
?
]
{
(
(
#
[
pin
]
)
?
field_vis
field
:
field_ty
)
+
}
}
impl
<
(
impl_generics
)
*
>
ident
<
(
ty_generics
)
*
>
(
where
(
where_clause
)
*
)
?
{
proj_vis
fn
project
<
'
__pin
>
(
self
:
crate
:
:
__private
:
:
Pin
<
&
'
__pin
mut
Self
>
)
-
>
Projection
<
'
__pin
(
ty_generics
)
*
>
{
unsafe
{
let
Self
{
(
field
)
*
}
=
self
.
get_unchecked_mut
(
)
;
Projection
{
(
field
:
crate
:
:
__pin_project_internal
!
(
make_unsafe_field_proj
;
(
#
[
pin
]
)
?
field
)
)
+
}
}
}
proj_vis
fn
project_ref
<
'
__pin
>
(
self
:
crate
:
:
__private
:
:
Pin
<
&
'
__pin
Self
>
)
-
>
ProjectionRef
<
'
__pin
(
ty_generics
)
*
>
{
unsafe
{
let
Self
{
(
field
)
*
}
=
self
.
get_ref
(
)
;
ProjectionRef
{
(
field
:
crate
:
:
__pin_project_internal
!
(
make_unsafe_field_proj
;
(
#
[
pin
]
)
?
field
)
)
+
}
}
}
}
crate
:
:
__pin_project_internal
!
{
make_unpin_impl
;
[
vis
ident
]
[
(
impl_generics
)
*
]
[
(
ty_generics
)
*
]
[
(
where
(
where_clause
)
*
)
?
]
(
field
:
crate
:
:
__pin_project_internal
!
(
make_unpin_bound
;
(
#
[
pin
]
)
?
field_ty
)
)
+
}
crate
:
:
__pin_project_internal
!
{
make_drop_impl
;
[
ident
]
[
(
impl_generics
)
*
]
[
(
ty_generics
)
*
]
[
(
where
(
where_clause
)
*
)
?
]
}
/
/
Ensure
that
it
'
s
impossible
to
use
pin
projections
on
a
#
[
repr
(
packed
)
]
struct
.
/
/
/
/
Taking
a
reference
to
a
packed
field
is
UB
and
applying
/
/
#
[
forbid
(
unaligned_references
)
]
makes
sure
that
doing
this
is
a
hard
error
.
/
/
/
/
If
the
struct
ends
up
having
#
[
repr
(
packed
)
]
applied
somehow
/
/
this
will
generate
an
(
unfriendly
)
error
message
.
Under
all
reasonable
/
/
circumstances
we
'
ll
detect
the
#
[
repr
(
packed
)
]
attribute
and
generate
/
/
a
much
nicer
error
above
.
/
/
/
/
See
https
:
/
/
github
.
com
/
taiki
-
e
/
pin
-
project
/
pull
/
34
for
more
details
.
/
/
/
/
Note
:
/
/
-
Lint
-
based
tricks
aren
'
t
perfect
but
they
'
re
much
better
than
nothing
:
/
/
https
:
/
/
github
.
com
/
taiki
-
e
/
pin
-
project
-
lite
/
issues
/
26
/
/
/
/
-
Enable
both
unaligned_references
and
safe_packed_borrows
lints
/
/
because
unaligned_references
lint
does
not
exist
in
older
compilers
:
/
/
https
:
/
/
github
.
com
/
taiki
-
e
/
pin
-
project
-
lite
/
pull
/
55
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
pull
/
82525
#
[
forbid
(
unaligned_references
safe_packed_borrows
)
]
fn
__assert_not_repr_packed
<
(
impl_generics
)
*
>
(
this
:
&
ident
<
(
ty_generics
)
*
>
)
(
where
(
where_clause
)
*
)
?
{
(
let
_
=
&
this
.
field
;
)
+
}
}
;
}
;
(
make_proj_ty_struct
;
[
proj_vis
:
vis
]
[
vis
:
vis
struct
ident
:
ident
]
[
(
impl_generics
:
tt
)
*
]
[
(
ty_generics
:
tt
)
*
]
[
(
where
(
where_clause
:
tt
)
*
)
?
]
{
(
(
#
[
pin
:
ident
]
)
?
field_vis
:
vis
field
:
ident
:
field_ty
:
ty
)
+
}
)
=
>
{
#
[
allow
(
dead_code
)
]
/
/
This
lint
warns
unused
fields
/
variants
.
#
[
allow
(
clippy
:
:
mut_mut
)
]
/
/
This
lint
warns
&
mut
&
mut
<
ty
>
.
#
[
allow
(
clippy
:
:
type_repetition_in_bounds
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
-
clippy
/
issues
/
4326
proj_vis
struct
Projection
<
'
__pin
(
impl_generics
)
*
>
where
ident
<
(
ty_generics
)
*
>
:
'
__pin
(
(
where_clause
)
*
)
?
{
(
field_vis
field
:
crate
:
:
__pin_project_internal
!
(
make_proj_field
;
(
#
[
pin
]
)
?
field_ty
;
mut
)
)
+
}
#
[
allow
(
dead_code
)
]
/
/
This
lint
warns
unused
fields
/
variants
.
#
[
allow
(
clippy
:
:
type_repetition_in_bounds
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
-
clippy
/
issues
/
4326
proj_vis
struct
ProjectionRef
<
'
__pin
(
impl_generics
)
*
>
where
ident
<
(
ty_generics
)
*
>
:
'
__pin
(
(
where_clause
)
*
)
?
{
(
field_vis
field
:
crate
:
:
__pin_project_internal
!
(
make_proj_field
;
(
#
[
pin
]
)
?
field_ty
;
)
)
+
}
}
;
(
make_unpin_impl
;
[
vis
:
vis
ident
:
ident
]
[
(
impl_generics
:
tt
)
*
]
[
(
ty_generics
:
tt
)
*
]
[
(
where
(
where_clause
:
tt
)
*
)
?
]
(
field
:
tt
)
*
)
=
>
{
/
/
Automatically
create
the
appropriate
conditional
Unpin
implementation
.
/
/
/
/
Basically
this
is
equivalent
to
the
following
code
:
/
/
rust
/
/
impl
<
T
U
>
Unpin
for
Struct
<
T
U
>
where
T
:
Unpin
{
}
/
/
/
/
/
/
However
if
struct
is
public
and
there
is
a
private
type
field
/
/
this
would
cause
an
E0446
(
private
type
in
public
interface
)
.
/
/
/
/
When
RFC
2145
is
implemented
(
rust
-
lang
/
rust
#
48054
)
/
/
this
will
become
a
lint
rather
then
a
hard
error
.
/
/
/
/
As
a
workaround
for
this
we
generate
a
new
struct
containing
all
of
the
pinned
/
/
fields
from
our
#
[
pin_project
]
type
.
This
struct
is
delcared
within
/
/
a
function
which
makes
it
impossible
to
be
named
by
user
code
.
/
/
This
guarnatees
that
it
will
use
the
default
auto
-
trait
impl
for
Unpin
-
/
/
that
is
it
will
implement
Unpin
iff
all
of
its
fields
implement
Unpin
.
/
/
This
type
can
be
safely
declared
as
'
public
'
satisfiying
the
privacy
/
/
checker
without
actually
allowing
user
code
to
access
it
.
/
/
/
/
This
allows
users
to
apply
the
#
[
pin_project
]
attribute
to
types
/
/
regardless
of
the
privacy
of
the
types
of
their
fields
.
/
/
/
/
See
also
https
:
/
/
github
.
com
/
taiki
-
e
/
pin
-
project
/
pull
/
53
.
vis
struct
__Origin
<
'
__pin
(
impl_generics
)
*
>
(
where
(
where_clause
)
*
)
?
{
__dummy_lifetime
:
crate
:
:
__private
:
:
PhantomData
<
&
'
__pin
(
)
>
(
field
)
*
}
impl
<
'
__pin
(
impl_generics
)
*
>
crate
:
:
__private
:
:
Unpin
for
ident
<
(
ty_generics
)
*
>
where
__Origin
<
'
__pin
(
ty_generics
)
*
>
:
crate
:
:
__private
:
:
Unpin
(
(
where_clause
)
*
)
?
{
}
}
;
(
make_drop_impl
;
[
ident
:
ident
]
[
(
impl_generics
:
tt
)
*
]
[
(
ty_generics
:
tt
)
*
]
[
(
where
(
where_clause
:
tt
)
*
)
?
]
)
=
>
{
/
/
Ensure
that
struct
does
not
implement
Drop
.
/
/
/
/
There
are
two
possible
cases
:
/
/
1
.
The
user
type
does
not
implement
Drop
.
In
this
case
/
/
the
first
blanked
impl
will
not
apply
to
it
.
This
code
/
/
will
compile
as
there
is
only
one
impl
of
MustNotImplDrop
for
the
user
type
/
/
2
.
The
user
type
does
impl
Drop
.
This
will
make
the
blanket
impl
applicable
/
/
which
will
then
comflict
with
the
explicit
MustNotImplDrop
impl
below
.
/
/
This
will
result
in
a
compilation
error
which
is
exactly
what
we
want
.
trait
MustNotImplDrop
{
}
#
[
allow
(
clippy
:
:
drop_bounds
drop_bounds
)
]
impl
<
T
:
crate
:
:
__private
:
:
Drop
>
MustNotImplDrop
for
T
{
}
impl
<
(
impl_generics
)
*
>
MustNotImplDrop
for
ident
<
(
ty_generics
)
*
>
(
where
(
where_clause
)
*
)
?
{
}
}
;
(
make_unpin_bound
;
#
[
pin
]
field_ty
:
ty
)
=
>
{
field_ty
}
;
(
make_unpin_bound
;
field_ty
:
ty
)
=
>
{
crate
:
:
__private
:
:
AlwaysUnpin
<
field_ty
>
}
;
(
make_unsafe_field_proj
;
#
[
pin
]
field
:
ident
)
=
>
{
crate
:
:
__private
:
:
Pin
:
:
new_unchecked
(
field
)
}
;
(
make_unsafe_field_proj
;
field
:
ident
)
=
>
{
field
}
;
(
make_proj_field
;
#
[
pin
]
field_ty
:
ty
;
(
mut
:
ident
)
?
)
=
>
{
crate
:
:
__private
:
:
Pin
<
&
'
__pin
(
mut
)
?
(
field_ty
)
>
}
;
(
make_proj_field
;
field_ty
:
ty
;
(
mut
:
ident
)
?
)
=
>
{
&
'
__pin
(
mut
)
?
(
field_ty
)
}
;
(
(
#
[
attrs
:
meta
]
)
*
pub
struct
ident
:
ident
(
<
(
lifetime
:
lifetime
(
:
lifetime_bound
:
lifetime
)
?
)
*
(
)
?
(
generics
:
ident
(
:
generics_bound
:
path
)
?
(
:
?
generics_unsized_bound
:
path
)
?
(
:
generics_lifetime_bound
:
lifetime
)
?
(
=
generics_default
:
ty
)
?
)
*
(
)
?
>
)
?
(
where
(
where_clause_ty
:
ty
(
:
where_clause_bound
:
path
)
?
(
:
?
where_clause_unsized_bound
:
path
)
?
(
:
where_clause_lifetime_bound
:
lifetime
)
?
)
*
(
)
?
)
?
{
(
(
#
[
pin
:
ident
]
)
?
field_vis
:
vis
field
:
ident
:
field_ty
:
ty
)
+
(
)
?
}
)
=
>
{
crate
:
:
__pin_project_internal
!
{
struct_internal
;
[
pub
(
crate
)
]
[
(
#
[
attrs
]
)
*
pub
struct
ident
]
[
(
<
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
(
=
generics_default
)
?
)
*
>
)
?
]
[
(
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
)
*
)
?
]
[
(
(
lifetime
)
*
(
generics
)
*
)
?
]
[
(
where
(
where_clause_ty
(
:
where_clause_bound
)
?
(
:
?
where_clause_unsized_bound
)
?
(
:
where_clause_lifetime_bound
)
?
)
*
)
?
]
{
(
(
#
[
pin
]
)
?
field_vis
field
:
field_ty
)
+
}
}
}
;
(
(
#
[
attrs
:
meta
]
)
*
vis
:
vis
struct
ident
:
ident
(
<
(
lifetime
:
lifetime
(
:
lifetime_bound
:
lifetime
)
?
)
*
(
)
?
(
generics
:
ident
(
:
generics_bound
:
path
)
?
(
:
?
generics_unsized_bound
:
path
)
?
(
:
generics_lifetime_bound
:
lifetime
)
?
(
=
generics_default
:
ty
)
?
)
*
(
)
?
>
)
?
(
where
(
where_clause_ty
:
ty
(
:
where_clause_bound
:
path
)
?
(
:
?
where_clause_unsized_bound
:
path
)
?
(
:
where_clause_lifetime_bound
:
lifetime
)
?
)
*
(
)
?
)
?
{
(
(
#
[
pin
:
ident
]
)
?
field_vis
:
vis
field
:
ident
:
field_ty
:
ty
)
+
(
)
?
}
)
=
>
{
crate
:
:
__pin_project_internal
!
{
struct_internal
;
[
vis
]
[
(
#
[
attrs
]
)
*
vis
struct
ident
]
[
(
<
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
(
=
generics_default
)
?
)
*
>
)
?
]
[
(
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
)
*
)
?
]
[
(
(
lifetime
)
*
(
generics
)
*
)
?
]
[
(
where
(
where_clause_ty
(
:
where_clause_bound
)
?
(
:
?
where_clause_unsized_bound
)
?
(
:
where_clause_lifetime_bound
)
?
)
*
)
?
]
{
(
(
#
[
pin
]
)
?
field_vis
field
:
field_ty
)
+
}
}
}
;
}
#
[
doc
(
hidden
)
]
pub
mod
__private
{
#
[
doc
(
hidden
)
]
pub
use
core
:
:
{
marker
:
:
{
PhantomData
Unpin
}
ops
:
:
Drop
pin
:
:
Pin
}
;
#
[
doc
(
hidden
)
]
pub
struct
AlwaysUnpin
<
T
:
?
Sized
>
(
PhantomData
<
T
>
)
;
impl
<
T
:
?
Sized
>
Unpin
for
AlwaysUnpin
<
T
>
{
}
}
