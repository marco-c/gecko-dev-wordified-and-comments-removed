use
std
:
:
io
:
:
{
self
BufRead
}
;
use
std
:
:
mem
;
use
futures
:
:
{
Poll
Future
}
;
use
AsyncRead
;
#
[
derive
(
Debug
)
]
pub
struct
ReadUntil
<
A
>
{
state
:
State
<
A
>
}
#
[
derive
(
Debug
)
]
enum
State
<
A
>
{
Reading
{
a
:
A
byte
:
u8
buf
:
Vec
<
u8
>
}
Empty
}
pub
fn
read_until
<
A
>
(
a
:
A
byte
:
u8
buf
:
Vec
<
u8
>
)
-
>
ReadUntil
<
A
>
where
A
:
AsyncRead
+
BufRead
{
ReadUntil
{
state
:
State
:
:
Reading
{
a
:
a
byte
:
byte
buf
:
buf
}
}
}
impl
<
A
>
Future
for
ReadUntil
<
A
>
where
A
:
AsyncRead
+
BufRead
{
type
Item
=
(
A
Vec
<
u8
>
)
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
(
A
Vec
<
u8
>
)
io
:
:
Error
>
{
match
self
.
state
{
State
:
:
Reading
{
ref
mut
a
byte
ref
mut
buf
}
=
>
{
try_nb
!
(
a
.
read_until
(
byte
buf
)
)
;
}
State
:
:
Empty
=
>
panic
!
(
"
poll
ReadUntil
after
it
'
s
done
"
)
}
match
mem
:
:
replace
(
&
mut
self
.
state
State
:
:
Empty
)
{
State
:
:
Reading
{
a
byte
:
_
buf
}
=
>
Ok
(
(
a
buf
)
.
into
(
)
)
State
:
:
Empty
=
>
unreachable
!
(
)
}
}
}
