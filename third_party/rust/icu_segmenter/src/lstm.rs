use
crate
:
:
grapheme
:
:
GraphemeClusterSegmenter
;
use
crate
:
:
math_helper
:
:
{
MatrixBorrowedMut
MatrixOwned
MatrixZero
}
;
use
crate
:
:
provider
:
:
*
;
use
alloc
:
:
boxed
:
:
Box
;
use
alloc
:
:
string
:
:
String
;
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
char
:
:
{
decode_utf16
REPLACEMENT_CHARACTER
}
;
use
icu_provider
:
:
DataPayload
;
use
zerovec
:
:
{
maps
:
:
ZeroMapBorrowed
ule
:
:
UnvalidatedStr
}
;
pub
struct
LstmSegmenterIterator
<
'
s
>
{
input
:
&
'
s
str
bies_str
:
Box
<
[
Bies
]
>
pos
:
usize
pos_utf8
:
usize
}
impl
Iterator
for
LstmSegmenterIterator
<
'
_
>
{
type
Item
=
usize
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
#
[
allow
(
clippy
:
:
indexing_slicing
)
]
loop
{
let
bies
=
*
self
.
bies_str
.
get
(
self
.
pos
)
?
;
self
.
pos_utf8
+
=
self
.
input
[
self
.
pos_utf8
.
.
]
.
chars
(
)
.
next
(
)
?
.
len_utf8
(
)
;
self
.
pos
+
=
1
;
if
bies
=
=
Bies
:
:
E
|
|
self
.
pos
=
=
self
.
bies_str
.
len
(
)
{
return
Some
(
self
.
pos_utf8
)
;
}
}
}
}
pub
struct
LstmSegmenterIteratorUtf16
{
bies_str
:
Box
<
[
Bies
]
>
pos
:
usize
}
impl
Iterator
for
LstmSegmenterIteratorUtf16
{
type
Item
=
usize
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
loop
{
let
bies
=
*
self
.
bies_str
.
get
(
self
.
pos
)
?
;
self
.
pos
+
=
1
;
if
bies
=
=
Bies
:
:
E
|
|
self
.
pos
=
=
self
.
bies_str
.
len
(
)
{
return
Some
(
self
.
pos
)
;
}
}
}
}
pub
(
crate
)
struct
LstmSegmenter
<
'
l
>
{
dic
:
ZeroMapBorrowed
<
'
l
UnvalidatedStr
u16
>
embedding
:
MatrixZero
<
'
l
2
>
fw_w
:
MatrixZero
<
'
l
3
>
fw_u
:
MatrixZero
<
'
l
3
>
fw_b
:
MatrixZero
<
'
l
2
>
bw_w
:
MatrixZero
<
'
l
3
>
bw_u
:
MatrixZero
<
'
l
3
>
bw_b
:
MatrixZero
<
'
l
2
>
time_w
:
MatrixZero
<
'
l
3
>
time_b
:
MatrixZero
<
'
l
1
>
grapheme
:
Option
<
&
'
l
RuleBreakDataV1
<
'
l
>
>
}
impl
<
'
l
>
LstmSegmenter
<
'
l
>
{
pub
fn
new
(
lstm
:
&
'
l
DataPayload
<
LstmDataV1Marker
>
grapheme
:
&
'
l
DataPayload
<
GraphemeClusterBreakDataV1Marker
>
)
-
>
Self
{
let
LstmDataV1
:
:
Float32
(
lstm
)
=
lstm
.
get
(
)
;
Self
{
dic
:
lstm
.
dic
.
as_borrowed
(
)
embedding
:
lstm
.
embedding
.
as_matrix_zero
(
)
fw_w
:
lstm
.
fw_w
.
as_matrix_zero
(
)
fw_u
:
lstm
.
fw_u
.
as_matrix_zero
(
)
fw_b
:
lstm
.
fw_b
.
as_matrix_zero
(
)
bw_w
:
lstm
.
bw_w
.
as_matrix_zero
(
)
bw_u
:
lstm
.
bw_u
.
as_matrix_zero
(
)
bw_b
:
lstm
.
bw_b
.
as_matrix_zero
(
)
time_w
:
lstm
.
time_w
.
as_matrix_zero
(
)
time_b
:
lstm
.
time_b
.
as_matrix_zero
(
)
grapheme
:
(
lstm
.
model
=
=
ModelType
:
:
GraphemeClusters
)
.
then
(
|
|
grapheme
.
get
(
)
)
}
}
pub
fn
segment_str
<
'
s
>
(
&
self
input
:
&
'
s
str
)
-
>
LstmSegmenterIterator
<
'
s
>
{
let
lstm_output
=
self
.
produce_bies
(
input
)
;
LstmSegmenterIterator
{
input
bies_str
:
lstm_output
pos
:
0
pos_utf8
:
0
}
}
pub
fn
segment_utf16
(
&
self
input
:
&
[
u16
]
)
-
>
LstmSegmenterIteratorUtf16
{
let
input
:
String
=
decode_utf16
(
input
.
iter
(
)
.
copied
(
)
)
.
map
(
|
r
|
r
.
unwrap_or
(
REPLACEMENT_CHARACTER
)
)
.
collect
(
)
;
let
lstm_output
=
self
.
produce_bies
(
&
input
)
;
LstmSegmenterIteratorUtf16
{
bies_str
:
lstm_output
pos
:
0
}
}
fn
produce_bies
(
&
self
input
:
&
str
)
-
>
Box
<
[
Bies
]
>
{
let
input_seq
:
Vec
<
u16
>
=
if
let
Some
(
grapheme
)
=
self
.
grapheme
{
GraphemeClusterSegmenter
:
:
new_and_segment_str
(
input
grapheme
)
.
collect
:
:
<
Vec
<
usize
>
>
(
)
.
windows
(
2
)
.
map
(
|
chunk
|
{
let
range
=
if
let
[
first
second
.
.
]
=
chunk
{
*
first
.
.
*
second
}
else
{
unreachable
!
(
)
}
;
self
.
dic
.
get_copied
(
UnvalidatedStr
:
:
from_str
(
input
.
get
(
range
)
.
unwrap_or
(
input
)
)
)
.
unwrap_or_else
(
|
|
self
.
dic
.
len
(
)
as
u16
)
}
)
.
collect
(
)
}
else
{
input
.
chars
(
)
.
map
(
|
c
|
{
self
.
dic
.
get_copied
(
UnvalidatedStr
:
:
from_str
(
c
.
encode_utf8
(
&
mut
[
0
;
4
]
)
)
)
.
unwrap_or_else
(
|
|
self
.
dic
.
len
(
)
as
u16
)
}
)
.
collect
(
)
}
;
fn
compute_hc
<
'
a
>
(
x_t
:
MatrixZero
<
'
a
1
>
mut
h_tm1
:
MatrixBorrowedMut
<
'
a
1
>
mut
c_tm1
:
MatrixBorrowedMut
<
'
a
1
>
w
:
MatrixZero
<
'
a
3
>
u
:
MatrixZero
<
'
a
3
>
b
:
MatrixZero
<
'
a
2
>
)
{
#
[
cfg
(
debug_assertions
)
]
{
let
hunits
=
h_tm1
.
dim
(
)
;
let
embedd_dim
=
x_t
.
dim
(
)
;
c_tm1
.
as_borrowed
(
)
.
debug_assert_dims
(
[
hunits
]
)
;
w
.
debug_assert_dims
(
[
4
hunits
embedd_dim
]
)
;
u
.
debug_assert_dims
(
[
4
hunits
hunits
]
)
;
b
.
debug_assert_dims
(
[
4
hunits
]
)
;
}
let
mut
s_t
=
b
.
to_owned
(
)
;
s_t
.
as_mut
(
)
.
add_dot_3d_2
(
x_t
w
)
;
s_t
.
as_mut
(
)
.
add_dot_3d_1
(
h_tm1
.
as_borrowed
(
)
u
)
;
#
[
allow
(
clippy
:
:
unwrap_used
)
]
s_t
.
submatrix_mut
:
:
<
1
>
(
0
)
.
unwrap
(
)
.
sigmoid_transform
(
)
;
#
[
allow
(
clippy
:
:
unwrap_used
)
]
s_t
.
submatrix_mut
:
:
<
1
>
(
1
)
.
unwrap
(
)
.
sigmoid_transform
(
)
;
#
[
allow
(
clippy
:
:
unwrap_used
)
]
s_t
.
submatrix_mut
:
:
<
1
>
(
2
)
.
unwrap
(
)
.
tanh_transform
(
)
;
#
[
allow
(
clippy
:
:
unwrap_used
)
]
s_t
.
submatrix_mut
:
:
<
1
>
(
3
)
.
unwrap
(
)
.
sigmoid_transform
(
)
;
#
[
allow
(
clippy
:
:
unwrap_used
)
]
c_tm1
.
convolve
(
s_t
.
as_borrowed
(
)
.
submatrix
(
0
)
.
unwrap
(
)
s_t
.
as_borrowed
(
)
.
submatrix
(
2
)
.
unwrap
(
)
s_t
.
as_borrowed
(
)
.
submatrix
(
1
)
.
unwrap
(
)
)
;
#
[
allow
(
clippy
:
:
unwrap_used
)
]
h_tm1
.
mul_tanh
(
s_t
.
as_borrowed
(
)
.
submatrix
(
3
)
.
unwrap
(
)
c_tm1
.
as_borrowed
(
)
)
;
}
let
hunits
=
self
.
fw_u
.
dim
(
)
.
1
;
let
mut
c_fw
=
MatrixOwned
:
:
<
1
>
:
:
new_zero
(
[
hunits
]
)
;
let
mut
all_h_fw
=
MatrixOwned
:
:
<
2
>
:
:
new_zero
(
[
input_seq
.
len
(
)
hunits
]
)
;
for
(
i
&
g_id
)
in
input_seq
.
iter
(
)
.
enumerate
(
)
{
#
[
allow
(
clippy
:
:
unwrap_used
)
]
let
x_t
=
self
.
embedding
.
submatrix
:
:
<
1
>
(
g_id
as
usize
)
.
unwrap
(
)
;
if
i
>
0
{
all_h_fw
.
as_mut
(
)
.
copy_submatrix
:
:
<
1
>
(
i
-
1
i
)
;
}
#
[
allow
(
clippy
:
:
unwrap_used
)
]
compute_hc
(
x_t
all_h_fw
.
submatrix_mut
(
i
)
.
unwrap
(
)
c_fw
.
as_mut
(
)
self
.
fw_w
self
.
fw_u
self
.
fw_b
)
;
}
let
mut
c_bw
=
MatrixOwned
:
:
<
1
>
:
:
new_zero
(
[
hunits
]
)
;
let
mut
all_h_bw
=
MatrixOwned
:
:
<
2
>
:
:
new_zero
(
[
input_seq
.
len
(
)
hunits
]
)
;
for
(
i
&
g_id
)
in
input_seq
.
iter
(
)
.
enumerate
(
)
.
rev
(
)
{
#
[
allow
(
clippy
:
:
unwrap_used
)
]
let
x_t
=
self
.
embedding
.
submatrix
:
:
<
1
>
(
g_id
as
usize
)
.
unwrap
(
)
;
if
i
+
1
<
input_seq
.
len
(
)
{
all_h_bw
.
as_mut
(
)
.
copy_submatrix
:
:
<
1
>
(
i
+
1
i
)
;
}
#
[
allow
(
clippy
:
:
unwrap_used
)
]
compute_hc
(
x_t
all_h_bw
.
submatrix_mut
(
i
)
.
unwrap
(
)
c_bw
.
as_mut
(
)
self
.
bw_w
self
.
bw_u
self
.
bw_b
)
;
}
#
[
allow
(
clippy
:
:
unwrap_used
)
]
let
timew_fw
=
self
.
time_w
.
submatrix
(
0
)
.
unwrap
(
)
;
#
[
allow
(
clippy
:
:
unwrap_used
)
]
let
timew_bw
=
self
.
time_w
.
submatrix
(
1
)
.
unwrap
(
)
;
(
0
.
.
input_seq
.
len
(
)
)
.
map
(
|
i
|
{
#
[
allow
(
clippy
:
:
unwrap_used
)
]
let
curr_fw
=
all_h_fw
.
submatrix
:
:
<
1
>
(
i
)
.
unwrap
(
)
;
#
[
allow
(
clippy
:
:
unwrap_used
)
]
let
curr_bw
=
all_h_bw
.
submatrix
:
:
<
1
>
(
i
)
.
unwrap
(
)
;
let
mut
weights
=
[
0
.
0
;
4
]
;
let
mut
curr_est
=
MatrixBorrowedMut
{
data
:
&
mut
weights
dims
:
[
4
]
}
;
curr_est
.
add_dot_2d
(
curr_fw
timew_fw
)
;
curr_est
.
add_dot_2d
(
curr_bw
timew_bw
)
;
#
[
allow
(
clippy
:
:
unwrap_used
)
]
curr_est
.
add
(
self
.
time_b
)
.
unwrap
(
)
;
curr_est
.
softmax_transform
(
)
;
Bies
:
:
from_probabilities
(
weights
)
}
)
.
collect
(
)
}
}
#
[
derive
(
Debug
PartialEq
Copy
Clone
)
]
pub
enum
Bies
{
B
I
E
S
}
impl
Bies
{
fn
from_probabilities
(
arr
:
[
f32
;
4
]
)
-
>
Bies
{
let
[
b
i
e
s
]
=
arr
;
let
mut
result
=
Bies
:
:
B
;
let
mut
max
=
b
;
if
i
>
max
{
result
=
Bies
:
:
I
;
max
=
i
;
}
if
e
>
max
{
result
=
Bies
:
:
E
;
max
=
e
;
}
if
s
>
max
{
result
=
Bies
:
:
S
;
}
result
}
#
[
cfg
(
test
)
]
fn
as_char
(
&
self
)
-
>
char
{
match
self
{
Bies
:
:
B
=
>
'
b
'
Bies
:
:
I
=
>
'
i
'
Bies
:
:
E
=
>
'
e
'
Bies
:
:
S
=
>
'
s
'
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
provider
:
:
{
LstmDataV1Marker
LstmForWordLineAutoV1Marker
}
;
use
icu_locid
:
:
locale
;
use
icu_provider
:
:
prelude
:
:
*
;
use
serde
:
:
Deserialize
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
BufReader
;
#
[
derive
(
PartialEq
Debug
Deserialize
)
]
pub
struct
TestCase
{
pub
unseg
:
String
pub
expected_bies
:
String
pub
true_bies
:
String
}
#
[
derive
(
PartialEq
Debug
Deserialize
)
]
pub
struct
TestTextData
{
pub
testcases
:
Vec
<
TestCase
>
}
#
[
derive
(
Debug
)
]
pub
struct
TestText
{
pub
data
:
TestTextData
}
fn
load_test_text
(
filename
:
&
str
)
-
>
TestTextData
{
let
file
=
File
:
:
open
(
filename
)
.
expect
(
"
File
should
be
present
"
)
;
let
reader
=
BufReader
:
:
new
(
file
)
;
serde_json
:
:
from_reader
(
reader
)
.
expect
(
"
JSON
syntax
error
"
)
}
#
[
test
]
fn
segment_file_by_lstm
(
)
{
let
lstm
:
DataPayload
<
LstmDataV1Marker
>
=
DataProvider
:
:
<
LstmForWordLineAutoV1Marker
>
:
:
load
(
&
icu_testdata
:
:
buffer
(
)
.
as_deserializing
(
)
DataRequest
{
locale
:
&
locale
!
(
"
th
"
)
.
into
(
)
metadata
:
Default
:
:
default
(
)
}
)
.
unwrap
(
)
.
take_payload
(
)
.
unwrap
(
)
.
cast
(
)
;
let
grapheme
:
DataPayload
<
GraphemeClusterBreakDataV1Marker
>
=
icu_testdata
:
:
buffer
(
)
.
as_deserializing
(
)
.
load
(
Default
:
:
default
(
)
)
.
unwrap
(
)
.
take_payload
(
)
.
unwrap
(
)
;
let
lstm
=
LstmSegmenter
:
:
new
(
&
lstm
&
grapheme
)
;
let
test_text_data
=
load_test_text
(
&
format
!
(
"
tests
/
testdata
/
test_text_
{
}
.
json
"
if
lstm
.
grapheme
.
is_some
(
)
{
"
grapheme
"
}
else
{
"
codepoints
"
}
)
)
;
let
test_text
=
TestText
{
data
:
test_text_data
}
;
for
test_case
in
test_text
.
data
.
testcases
{
let
lstm_output
=
lstm
.
produce_bies
(
&
test_case
.
unseg
)
;
println
!
(
"
Test
case
:
{
}
"
test_case
.
unseg
)
;
println
!
(
"
Expected
bies
:
{
}
"
test_case
.
expected_bies
)
;
println
!
(
"
Estimated
bies
:
{
lstm_output
:
?
}
"
)
;
println
!
(
"
True
bies
:
{
}
"
test_case
.
true_bies
)
;
println
!
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
"
)
;
assert_eq
!
(
test_case
.
expected_bies
lstm_output
.
iter
(
)
.
map
(
Bies
:
:
as_char
)
.
collect
:
:
<
String
>
(
)
)
;
}
}
}
