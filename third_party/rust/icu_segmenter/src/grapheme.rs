use
alloc
:
:
vec
:
:
Vec
;
use
icu_provider
:
:
prelude
:
:
*
;
use
crate
:
:
indices
:
:
{
Latin1Indices
Utf16Indices
}
;
use
crate
:
:
iterator_helpers
:
:
derive_usize_iterator_with_type
;
use
crate
:
:
rule_segmenter
:
:
*
;
use
crate
:
:
{
provider
:
:
*
SegmenterError
}
;
use
utf8_iter
:
:
Utf8CharIndices
;
#
[
derive
(
Debug
)
]
pub
struct
GraphemeClusterBreakIterator
<
'
l
'
s
Y
:
RuleBreakType
<
'
l
'
s
>
+
?
Sized
>
(
RuleBreakIterator
<
'
l
'
s
Y
>
)
;
derive_usize_iterator_with_type
!
(
GraphemeClusterBreakIterator
)
;
pub
type
GraphemeClusterBreakIteratorUtf8
<
'
l
'
s
>
=
GraphemeClusterBreakIterator
<
'
l
'
s
RuleBreakTypeUtf8
>
;
pub
type
GraphemeClusterBreakIteratorPotentiallyIllFormedUtf8
<
'
l
'
s
>
=
GraphemeClusterBreakIterator
<
'
l
'
s
RuleBreakTypePotentiallyIllFormedUtf8
>
;
pub
type
GraphemeClusterBreakIteratorLatin1
<
'
l
'
s
>
=
GraphemeClusterBreakIterator
<
'
l
'
s
RuleBreakTypeLatin1
>
;
pub
type
GraphemeClusterBreakIteratorUtf16
<
'
l
'
s
>
=
GraphemeClusterBreakIterator
<
'
l
'
s
RuleBreakTypeUtf16
>
;
#
[
derive
(
Debug
)
]
pub
struct
GraphemeClusterSegmenter
{
payload
:
DataPayload
<
GraphemeClusterBreakDataV1Marker
>
}
impl
GraphemeClusterSegmenter
{
pub
fn
try_new_unstable
<
D
>
(
provider
:
&
D
)
-
>
Result
<
Self
SegmenterError
>
where
D
:
DataProvider
<
GraphemeClusterBreakDataV1Marker
>
+
?
Sized
{
let
payload
=
provider
.
load
(
Default
:
:
default
(
)
)
?
.
take_payload
(
)
?
;
Ok
(
Self
{
payload
}
)
}
icu_provider
:
:
gen_any_buffer_constructors
!
(
locale
:
skip
options
:
skip
error
:
SegmenterError
)
;
pub
fn
segment_str
<
'
l
'
s
>
(
&
'
l
self
input
:
&
'
s
str
)
-
>
GraphemeClusterBreakIteratorUtf8
<
'
l
'
s
>
{
GraphemeClusterSegmenter
:
:
new_and_segment_str
(
input
self
.
payload
.
get
(
)
)
}
pub
(
crate
)
fn
new_and_segment_str
<
'
l
'
s
>
(
input
:
&
'
s
str
payload
:
&
'
l
RuleBreakDataV1
<
'
l
>
)
-
>
GraphemeClusterBreakIteratorUtf8
<
'
l
'
s
>
{
GraphemeClusterBreakIterator
(
RuleBreakIterator
{
iter
:
input
.
char_indices
(
)
len
:
input
.
len
(
)
current_pos_data
:
None
result_cache
:
Vec
:
:
new
(
)
data
:
payload
complex
:
None
boundary_property
:
0
}
)
}
pub
fn
segment_utf8
<
'
l
'
s
>
(
&
'
l
self
input
:
&
'
s
[
u8
]
)
-
>
GraphemeClusterBreakIteratorPotentiallyIllFormedUtf8
<
'
l
'
s
>
{
GraphemeClusterBreakIterator
(
RuleBreakIterator
{
iter
:
Utf8CharIndices
:
:
new
(
input
)
len
:
input
.
len
(
)
current_pos_data
:
None
result_cache
:
Vec
:
:
new
(
)
data
:
self
.
payload
.
get
(
)
complex
:
None
boundary_property
:
0
}
)
}
pub
fn
segment_latin1
<
'
l
'
s
>
(
&
'
l
self
input
:
&
'
s
[
u8
]
)
-
>
GraphemeClusterBreakIteratorLatin1
<
'
l
'
s
>
{
GraphemeClusterBreakIterator
(
RuleBreakIterator
{
iter
:
Latin1Indices
:
:
new
(
input
)
len
:
input
.
len
(
)
current_pos_data
:
None
result_cache
:
Vec
:
:
new
(
)
data
:
self
.
payload
.
get
(
)
complex
:
None
boundary_property
:
0
}
)
}
pub
fn
segment_utf16
<
'
l
'
s
>
(
&
'
l
self
input
:
&
'
s
[
u16
]
)
-
>
GraphemeClusterBreakIteratorUtf16
<
'
l
'
s
>
{
GraphemeClusterSegmenter
:
:
new_and_segment_utf16
(
input
self
.
payload
.
get
(
)
)
}
pub
(
crate
)
fn
new_and_segment_utf16
<
'
l
'
s
>
(
input
:
&
'
s
[
u16
]
payload
:
&
'
l
RuleBreakDataV1
<
'
l
>
)
-
>
GraphemeClusterBreakIteratorUtf16
<
'
l
'
s
>
{
GraphemeClusterBreakIterator
(
RuleBreakIterator
{
iter
:
Utf16Indices
:
:
new
(
input
)
len
:
input
.
len
(
)
current_pos_data
:
None
result_cache
:
Vec
:
:
new
(
)
data
:
payload
complex
:
None
boundary_property
:
0
}
)
}
}
#
[
cfg
(
all
(
test
feature
=
"
serde
"
)
)
]
#
[
test
]
fn
empty_string
(
)
{
let
segmenter
=
GraphemeClusterSegmenter
:
:
try_new_with_buffer_provider
(
&
icu_testdata
:
:
buffer
(
)
)
.
unwrap
(
)
;
let
breaks
:
Vec
<
usize
>
=
segmenter
.
segment_str
(
"
"
)
.
collect
(
)
;
assert_eq
!
(
breaks
[
0
]
)
;
}
