use
{
Async
Future
IntoFuture
Poll
}
;
#
[
derive
(
Debug
)
]
pub
enum
Loop
<
T
S
>
{
Break
(
T
)
Continue
(
S
)
}
#
[
derive
(
Debug
)
]
pub
struct
LoopFn
<
A
F
>
where
A
:
IntoFuture
{
future
:
A
:
:
Future
func
:
F
}
pub
fn
loop_fn
<
S
T
A
F
>
(
initial_state
:
S
mut
func
:
F
)
-
>
LoopFn
<
A
F
>
where
F
:
FnMut
(
S
)
-
>
A
A
:
IntoFuture
<
Item
=
Loop
<
T
S
>
>
{
LoopFn
{
future
:
func
(
initial_state
)
.
into_future
(
)
func
:
func
}
}
impl
<
S
T
A
F
>
Future
for
LoopFn
<
A
F
>
where
F
:
FnMut
(
S
)
-
>
A
A
:
IntoFuture
<
Item
=
Loop
<
T
S
>
>
{
type
Item
=
T
;
type
Error
=
A
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
Self
:
:
Error
>
{
loop
{
match
try_ready
!
(
self
.
future
.
poll
(
)
)
{
Loop
:
:
Break
(
x
)
=
>
return
Ok
(
Async
:
:
Ready
(
x
)
)
Loop
:
:
Continue
(
s
)
=
>
self
.
future
=
(
self
.
func
)
(
s
)
.
into_future
(
)
}
}
}
}
