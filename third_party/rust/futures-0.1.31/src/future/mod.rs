use
core
:
:
fmt
;
use
core
:
:
result
;
mod
empty
;
mod
lazy
;
mod
poll_fn
;
#
[
path
=
"
result
.
rs
"
]
mod
result_
;
mod
loop_fn
;
mod
option
;
pub
use
self
:
:
empty
:
:
{
empty
Empty
}
;
pub
use
self
:
:
lazy
:
:
{
lazy
Lazy
}
;
pub
use
self
:
:
poll_fn
:
:
{
poll_fn
PollFn
}
;
pub
use
self
:
:
result_
:
:
{
result
ok
err
FutureResult
}
;
pub
use
self
:
:
loop_fn
:
:
{
loop_fn
Loop
LoopFn
}
;
#
[
doc
(
hidden
)
]
#
[
deprecated
(
since
=
"
0
.
1
.
4
"
note
=
"
use
ok
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
pub
use
self
:
:
{
ok
as
finished
Ok
as
Finished
}
;
#
[
doc
(
hidden
)
]
#
[
deprecated
(
since
=
"
0
.
1
.
4
"
note
=
"
use
err
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
pub
use
self
:
:
{
err
as
failed
Err
as
Failed
}
;
#
[
doc
(
hidden
)
]
#
[
deprecated
(
since
=
"
0
.
1
.
4
"
note
=
"
use
result
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
pub
use
self
:
:
{
result
as
done
FutureResult
as
Done
}
;
#
[
doc
(
hidden
)
]
#
[
deprecated
(
since
=
"
0
.
1
.
7
"
note
=
"
use
FutureResult
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
pub
use
self
:
:
{
FutureResult
as
Ok
}
;
#
[
doc
(
hidden
)
]
#
[
deprecated
(
since
=
"
0
.
1
.
7
"
note
=
"
use
FutureResult
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
pub
use
self
:
:
{
FutureResult
as
Err
}
;
mod
and_then
;
mod
flatten
;
mod
flatten_stream
;
mod
fuse
;
mod
into_stream
;
mod
join
;
mod
map
;
mod
map_err
;
mod
from_err
;
mod
or_else
;
mod
select
;
mod
select2
;
mod
then
;
mod
either
;
mod
inspect
;
mod
chain
;
pub
use
self
:
:
and_then
:
:
AndThen
;
pub
use
self
:
:
flatten
:
:
Flatten
;
pub
use
self
:
:
flatten_stream
:
:
FlattenStream
;
pub
use
self
:
:
fuse
:
:
Fuse
;
pub
use
self
:
:
into_stream
:
:
IntoStream
;
pub
use
self
:
:
join
:
:
{
Join
Join3
Join4
Join5
}
;
pub
use
self
:
:
map
:
:
Map
;
pub
use
self
:
:
map_err
:
:
MapErr
;
pub
use
self
:
:
from_err
:
:
FromErr
;
pub
use
self
:
:
or_else
:
:
OrElse
;
pub
use
self
:
:
select
:
:
{
Select
SelectNext
}
;
pub
use
self
:
:
select2
:
:
Select2
;
pub
use
self
:
:
then
:
:
Then
;
pub
use
self
:
:
either
:
:
Either
;
pub
use
self
:
:
inspect
:
:
Inspect
;
if_std
!
{
mod
catch_unwind
;
mod
join_all
;
mod
select_all
;
mod
select_ok
;
mod
shared
;
pub
use
self
:
:
catch_unwind
:
:
CatchUnwind
;
pub
use
self
:
:
join_all
:
:
{
join_all
JoinAll
}
;
pub
use
self
:
:
select_all
:
:
{
SelectAll
SelectAllNext
select_all
}
;
pub
use
self
:
:
select_ok
:
:
{
SelectOk
select_ok
}
;
pub
use
self
:
:
shared
:
:
{
Shared
SharedItem
SharedError
}
;
#
[
doc
(
hidden
)
]
#
[
deprecated
(
since
=
"
0
.
1
.
4
"
note
=
"
use
join_all
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
pub
use
self
:
:
join_all
:
:
join_all
as
collect
;
#
[
doc
(
hidden
)
]
#
[
deprecated
(
since
=
"
0
.
1
.
4
"
note
=
"
use
JoinAll
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
pub
use
self
:
:
join_all
:
:
JoinAll
as
Collect
;
/
/
/
A
type
alias
for
Box
<
Future
+
Send
>
#
[
doc
(
hidden
)
]
#
[
deprecated
(
note
=
"
removed
without
replacement
recommended
to
use
a
\
local
extension
trait
or
function
if
needed
more
\
details
in
https
:
/
/
github
.
com
/
rust
-
lang
-
nursery
/
futures
-
rs
/
issues
/
228
"
)
]
pub
type
BoxFuture
<
T
E
>
=
:
:
std
:
:
boxed
:
:
Box
<
Future
<
Item
=
T
Error
=
E
>
+
Send
>
;
impl
<
F
:
?
Sized
+
Future
>
Future
for
:
:
std
:
:
boxed
:
:
Box
<
F
>
{
type
Item
=
F
:
:
Item
;
type
Error
=
F
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
Self
:
:
Error
>
{
(
*
*
self
)
.
poll
(
)
}
}
}
use
{
Poll
stream
}
;
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
pub
trait
Future
{
type
Item
;
type
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
Self
:
:
Error
>
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
wait
(
self
)
-
>
result
:
:
Result
<
Self
:
:
Item
Self
:
:
Error
>
where
Self
:
Sized
{
:
:
executor
:
:
spawn
(
self
)
.
wait_future
(
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
#
[
doc
(
hidden
)
]
#
[
deprecated
(
note
=
"
removed
without
replacement
recommended
to
use
a
\
local
extension
trait
or
function
if
needed
more
\
details
in
https
:
/
/
github
.
com
/
rust
-
lang
-
nursery
/
futures
-
rs
/
issues
/
228
"
)
]
#
[
allow
(
deprecated
)
]
fn
boxed
(
self
)
-
>
BoxFuture
<
Self
:
:
Item
Self
:
:
Error
>
where
Self
:
Sized
+
Send
+
'
static
{
:
:
std
:
:
boxed
:
:
Box
:
:
new
(
self
)
}
fn
map
<
F
U
>
(
self
f
:
F
)
-
>
Map
<
Self
F
>
where
F
:
FnOnce
(
Self
:
:
Item
)
-
>
U
Self
:
Sized
{
assert_future
:
:
<
U
Self
:
:
Error
_
>
(
map
:
:
new
(
self
f
)
)
}
fn
map_err
<
F
E
>
(
self
f
:
F
)
-
>
MapErr
<
Self
F
>
where
F
:
FnOnce
(
Self
:
:
Error
)
-
>
E
Self
:
Sized
{
assert_future
:
:
<
Self
:
:
Item
E
_
>
(
map_err
:
:
new
(
self
f
)
)
}
fn
from_err
<
E
:
From
<
Self
:
:
Error
>
>
(
self
)
-
>
FromErr
<
Self
E
>
where
Self
:
Sized
{
assert_future
:
:
<
Self
:
:
Item
E
_
>
(
from_err
:
:
new
(
self
)
)
}
fn
then
<
F
B
>
(
self
f
:
F
)
-
>
Then
<
Self
B
F
>
where
F
:
FnOnce
(
result
:
:
Result
<
Self
:
:
Item
Self
:
:
Error
>
)
-
>
B
B
:
IntoFuture
Self
:
Sized
{
assert_future
:
:
<
B
:
:
Item
B
:
:
Error
_
>
(
then
:
:
new
(
self
f
)
)
}
fn
and_then
<
F
B
>
(
self
f
:
F
)
-
>
AndThen
<
Self
B
F
>
where
F
:
FnOnce
(
Self
:
:
Item
)
-
>
B
B
:
IntoFuture
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
assert_future
:
:
<
B
:
:
Item
Self
:
:
Error
_
>
(
and_then
:
:
new
(
self
f
)
)
}
fn
or_else
<
F
B
>
(
self
f
:
F
)
-
>
OrElse
<
Self
B
F
>
where
F
:
FnOnce
(
Self
:
:
Error
)
-
>
B
B
:
IntoFuture
<
Item
=
Self
:
:
Item
>
Self
:
Sized
{
assert_future
:
:
<
Self
:
:
Item
B
:
:
Error
_
>
(
or_else
:
:
new
(
self
f
)
)
}
fn
select
<
B
>
(
self
other
:
B
)
-
>
Select
<
Self
B
:
:
Future
>
where
B
:
IntoFuture
<
Item
=
Self
:
:
Item
Error
=
Self
:
:
Error
>
Self
:
Sized
{
let
f
=
select
:
:
new
(
self
other
.
into_future
(
)
)
;
assert_future
:
:
<
(
Self
:
:
Item
SelectNext
<
Self
B
:
:
Future
>
)
(
Self
:
:
Error
SelectNext
<
Self
B
:
:
Future
>
)
_
>
(
f
)
}
fn
select2
<
B
>
(
self
other
:
B
)
-
>
Select2
<
Self
B
:
:
Future
>
where
B
:
IntoFuture
Self
:
Sized
{
select2
:
:
new
(
self
other
.
into_future
(
)
)
}
fn
join
<
B
>
(
self
other
:
B
)
-
>
Join
<
Self
B
:
:
Future
>
where
B
:
IntoFuture
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
let
f
=
join
:
:
new
(
self
other
.
into_future
(
)
)
;
assert_future
:
:
<
(
Self
:
:
Item
B
:
:
Item
)
Self
:
:
Error
_
>
(
f
)
}
fn
join3
<
B
C
>
(
self
b
:
B
c
:
C
)
-
>
Join3
<
Self
B
:
:
Future
C
:
:
Future
>
where
B
:
IntoFuture
<
Error
=
Self
:
:
Error
>
C
:
IntoFuture
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
join
:
:
new3
(
self
b
.
into_future
(
)
c
.
into_future
(
)
)
}
fn
join4
<
B
C
D
>
(
self
b
:
B
c
:
C
d
:
D
)
-
>
Join4
<
Self
B
:
:
Future
C
:
:
Future
D
:
:
Future
>
where
B
:
IntoFuture
<
Error
=
Self
:
:
Error
>
C
:
IntoFuture
<
Error
=
Self
:
:
Error
>
D
:
IntoFuture
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
join
:
:
new4
(
self
b
.
into_future
(
)
c
.
into_future
(
)
d
.
into_future
(
)
)
}
fn
join5
<
B
C
D
E
>
(
self
b
:
B
c
:
C
d
:
D
e
:
E
)
-
>
Join5
<
Self
B
:
:
Future
C
:
:
Future
D
:
:
Future
E
:
:
Future
>
where
B
:
IntoFuture
<
Error
=
Self
:
:
Error
>
C
:
IntoFuture
<
Error
=
Self
:
:
Error
>
D
:
IntoFuture
<
Error
=
Self
:
:
Error
>
E
:
IntoFuture
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
join
:
:
new5
(
self
b
.
into_future
(
)
c
.
into_future
(
)
d
.
into_future
(
)
e
.
into_future
(
)
)
}
fn
into_stream
(
self
)
-
>
IntoStream
<
Self
>
where
Self
:
Sized
{
into_stream
:
:
new
(
self
)
}
fn
flatten
(
self
)
-
>
Flatten
<
Self
>
where
Self
:
:
Item
:
IntoFuture
<
<
Self
as
Future
>
:
:
Item
as
IntoFuture
>
:
:
Error
:
From
<
<
Self
as
Future
>
:
:
Error
>
Self
:
Sized
{
let
f
=
flatten
:
:
new
(
self
)
;
assert_future
:
:
<
<
<
Self
as
Future
>
:
:
Item
as
IntoFuture
>
:
:
Item
<
<
Self
as
Future
>
:
:
Item
as
IntoFuture
>
:
:
Error
_
>
(
f
)
}
fn
flatten_stream
(
self
)
-
>
FlattenStream
<
Self
>
where
<
Self
as
Future
>
:
:
Item
:
stream
:
:
Stream
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
flatten_stream
:
:
new
(
self
)
}
fn
fuse
(
self
)
-
>
Fuse
<
Self
>
where
Self
:
Sized
{
let
f
=
fuse
:
:
new
(
self
)
;
assert_future
:
:
<
Self
:
:
Item
Self
:
:
Error
_
>
(
f
)
}
fn
inspect
<
F
>
(
self
f
:
F
)
-
>
Inspect
<
Self
F
>
where
F
:
FnOnce
(
&
Self
:
:
Item
)
-
>
(
)
Self
:
Sized
{
assert_future
:
:
<
Self
:
:
Item
Self
:
:
Error
_
>
(
inspect
:
:
new
(
self
f
)
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
catch_unwind
(
self
)
-
>
CatchUnwind
<
Self
>
where
Self
:
Sized
+
:
:
std
:
:
panic
:
:
UnwindSafe
{
catch_unwind
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
shared
(
self
)
-
>
Shared
<
Self
>
where
Self
:
Sized
{
shared
:
:
new
(
self
)
}
}
impl
<
'
a
F
:
?
Sized
+
Future
>
Future
for
&
'
a
mut
F
{
type
Item
=
F
:
:
Item
;
type
Error
=
F
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
Self
:
:
Error
>
{
(
*
*
self
)
.
poll
(
)
}
}
fn
assert_future
<
A
B
F
>
(
t
:
F
)
-
>
F
where
F
:
Future
<
Item
=
A
Error
=
B
>
{
t
}
pub
trait
IntoFuture
{
type
Future
:
Future
<
Item
=
Self
:
:
Item
Error
=
Self
:
:
Error
>
;
type
Item
;
type
Error
;
fn
into_future
(
self
)
-
>
Self
:
:
Future
;
}
impl
<
F
:
Future
>
IntoFuture
for
F
{
type
Future
=
F
;
type
Item
=
F
:
:
Item
;
type
Error
=
F
:
:
Error
;
fn
into_future
(
self
)
-
>
F
{
self
}
}
impl
<
T
E
>
IntoFuture
for
result
:
:
Result
<
T
E
>
{
type
Future
=
FutureResult
<
T
E
>
;
type
Item
=
T
;
type
Error
=
E
;
fn
into_future
(
self
)
-
>
FutureResult
<
T
E
>
{
result
(
self
)
}
}
pub
trait
FutureFrom
<
T
>
:
Sized
{
type
Future
:
Future
<
Item
=
Self
Error
=
Self
:
:
Error
>
;
type
Error
;
fn
future_from
(
T
)
-
>
Self
:
:
Future
;
}
pub
trait
Executor
<
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
>
{
fn
execute
(
&
self
future
:
F
)
-
>
Result
<
(
)
ExecuteError
<
F
>
>
;
}
pub
struct
ExecuteError
<
F
>
{
future
:
F
kind
:
ExecuteErrorKind
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
ExecuteErrorKind
{
Shutdown
NoCapacity
#
[
doc
(
hidden
)
]
__Nonexhaustive
}
impl
<
F
>
ExecuteError
<
F
>
{
pub
fn
new
(
kind
:
ExecuteErrorKind
future
:
F
)
-
>
ExecuteError
<
F
>
{
ExecuteError
{
future
:
future
kind
:
kind
}
}
pub
fn
kind
(
&
self
)
-
>
ExecuteErrorKind
{
self
.
kind
}
pub
fn
into_future
(
self
)
-
>
F
{
self
.
future
}
}
impl
<
F
>
fmt
:
:
Debug
for
ExecuteError
<
F
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
.
kind
{
ExecuteErrorKind
:
:
Shutdown
=
>
"
executor
has
shut
down
"
.
fmt
(
f
)
ExecuteErrorKind
:
:
NoCapacity
=
>
"
executor
has
no
more
capacity
"
.
fmt
(
f
)
ExecuteErrorKind
:
:
__Nonexhaustive
=
>
panic
!
(
)
}
}
}
