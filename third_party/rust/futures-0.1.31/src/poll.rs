#
[
macro_export
]
macro_rules
!
try_ready
{
(
e
:
expr
)
=
>
(
match
e
{
Ok
(
crate
:
:
Async
:
:
Ready
(
t
)
)
=
>
t
Ok
(
crate
:
:
Async
:
:
NotReady
)
=
>
return
Ok
(
crate
:
:
Async
:
:
NotReady
)
Err
(
e
)
=
>
return
Err
(
From
:
:
from
(
e
)
)
}
)
}
pub
type
Poll
<
T
E
>
=
Result
<
Async
<
T
>
E
>
;
#
[
derive
(
Copy
Clone
Debug
PartialEq
)
]
pub
enum
Async
<
T
>
{
Ready
(
T
)
NotReady
}
impl
<
T
>
Async
<
T
>
{
pub
fn
map
<
F
U
>
(
self
f
:
F
)
-
>
Async
<
U
>
where
F
:
FnOnce
(
T
)
-
>
U
{
match
self
{
Async
:
:
Ready
(
t
)
=
>
Async
:
:
Ready
(
f
(
t
)
)
Async
:
:
NotReady
=
>
Async
:
:
NotReady
}
}
pub
fn
is_ready
(
&
self
)
-
>
bool
{
match
*
self
{
Async
:
:
Ready
(
_
)
=
>
true
Async
:
:
NotReady
=
>
false
}
}
pub
fn
is_not_ready
(
&
self
)
-
>
bool
{
!
self
.
is_ready
(
)
}
}
impl
<
T
>
From
<
T
>
for
Async
<
T
>
{
fn
from
(
t
:
T
)
-
>
Async
<
T
>
{
Async
:
:
Ready
(
t
)
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
)
]
pub
enum
AsyncSink
<
T
>
{
Ready
NotReady
(
T
)
}
impl
<
T
>
AsyncSink
<
T
>
{
pub
fn
map
<
F
U
>
(
self
f
:
F
)
-
>
AsyncSink
<
U
>
where
F
:
FnOnce
(
T
)
-
>
U
{
match
self
{
AsyncSink
:
:
Ready
=
>
AsyncSink
:
:
Ready
AsyncSink
:
:
NotReady
(
t
)
=
>
AsyncSink
:
:
NotReady
(
f
(
t
)
)
}
}
pub
fn
is_ready
(
&
self
)
-
>
bool
{
match
*
self
{
AsyncSink
:
:
Ready
=
>
true
AsyncSink
:
:
NotReady
(
_
)
=
>
false
}
}
pub
fn
is_not_ready
(
&
self
)
-
>
bool
{
!
self
.
is_ready
(
)
}
}
pub
type
StartSend
<
T
E
>
=
Result
<
AsyncSink
<
T
>
E
>
;
