#
!
[
allow
(
bare_trait_objects
unknown_lints
)
]
use
std
:
:
cell
:
:
{
Cell
RefCell
}
;
use
std
:
:
sync
:
:
{
Arc
Mutex
mpsc
}
;
use
futures
:
:
executor
:
:
{
self
Spawn
Notify
}
;
use
futures
:
:
future
:
:
{
Executor
ExecuteError
}
;
use
futures
:
:
{
Future
Async
}
;
pub
struct
Core
{
tx
:
mpsc
:
:
Sender
<
usize
>
rx
:
mpsc
:
:
Receiver
<
usize
>
notify
:
Arc
<
MyNotify
>
tasks
:
RefCell
<
Vec
<
Slot
>
>
next_vacant
:
Cell
<
usize
>
}
enum
Slot
{
Vacant
{
next_vacant
:
usize
}
Running
(
Option
<
Spawn
<
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
>
>
>
)
}
impl
Core
{
pub
fn
new
(
)
-
>
Self
{
let
(
tx
rx
)
=
mpsc
:
:
channel
(
)
;
Core
{
notify
:
Arc
:
:
new
(
MyNotify
{
tx
:
Mutex
:
:
new
(
tx
.
clone
(
)
)
}
)
tx
:
tx
rx
:
rx
next_vacant
:
Cell
:
:
new
(
0
)
tasks
:
RefCell
:
:
new
(
Vec
:
:
new
(
)
)
}
}
pub
fn
spawn
<
F
>
(
&
self
f
:
F
)
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
let
idx
=
self
.
next_vacant
.
get
(
)
;
let
mut
tasks
=
self
.
tasks
.
borrow_mut
(
)
;
match
tasks
.
get_mut
(
idx
)
{
Some
(
&
mut
Slot
:
:
Vacant
{
next_vacant
}
)
=
>
{
self
.
next_vacant
.
set
(
next_vacant
)
;
}
Some
(
&
mut
Slot
:
:
Running
(
_
)
)
=
>
{
panic
!
(
"
vacant
points
to
running
future
"
)
}
None
=
>
{
assert_eq
!
(
idx
tasks
.
len
(
)
)
;
tasks
.
push
(
Slot
:
:
Vacant
{
next_vacant
:
0
}
)
;
self
.
next_vacant
.
set
(
idx
+
1
)
;
}
}
tasks
[
idx
]
=
Slot
:
:
Running
(
Some
(
executor
:
:
spawn
(
Box
:
:
new
(
f
)
)
)
)
;
self
.
tx
.
send
(
idx
)
.
unwrap
(
)
;
}
pub
fn
run
<
F
>
(
&
self
f
:
F
)
-
>
Result
<
F
:
:
Item
F
:
:
Error
>
where
F
:
Future
{
let
id
=
usize
:
:
max_value
(
)
;
self
.
tx
.
send
(
id
)
.
unwrap
(
)
;
let
mut
f
=
executor
:
:
spawn
(
f
)
;
loop
{
if
self
.
turn
(
)
{
match
f
.
poll_future_notify
(
&
self
.
notify
id
)
?
{
Async
:
:
Ready
(
e
)
=
>
return
Ok
(
e
)
Async
:
:
NotReady
=
>
{
}
}
}
}
}
fn
turn
(
&
self
)
-
>
bool
{
let
task_id
=
self
.
rx
.
recv
(
)
.
unwrap
(
)
;
if
task_id
=
=
usize
:
:
max_value
(
)
{
return
true
}
let
mut
future
=
match
self
.
tasks
.
borrow_mut
(
)
.
get_mut
(
task_id
)
{
Some
(
&
mut
Slot
:
:
Running
(
ref
mut
future
)
)
=
>
future
.
take
(
)
.
unwrap
(
)
Some
(
&
mut
Slot
:
:
Vacant
{
.
.
}
)
=
>
return
false
None
=
>
return
false
}
;
let
done
=
match
future
.
poll_future_notify
(
&
self
.
notify
task_id
)
{
Ok
(
Async
:
:
Ready
(
(
)
)
)
|
Err
(
(
)
)
=
>
true
Ok
(
Async
:
:
NotReady
)
=
>
false
}
;
let
mut
tasks
=
self
.
tasks
.
borrow_mut
(
)
;
if
done
{
tasks
[
task_id
]
=
Slot
:
:
Vacant
{
next_vacant
:
self
.
next_vacant
.
get
(
)
}
;
self
.
next_vacant
.
set
(
task_id
)
;
}
else
{
tasks
[
task_id
]
=
Slot
:
:
Running
(
Some
(
future
)
)
;
}
return
false
}
}
impl
<
F
>
Executor
<
F
>
for
Core
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
fn
execute
(
&
self
future
:
F
)
-
>
Result
<
(
)
ExecuteError
<
F
>
>
{
self
.
spawn
(
future
)
;
Ok
(
(
)
)
}
}
struct
MyNotify
{
tx
:
Mutex
<
mpsc
:
:
Sender
<
usize
>
>
}
impl
Notify
for
MyNotify
{
fn
notify
(
&
self
id
:
usize
)
{
drop
(
self
.
tx
.
lock
(
)
.
unwrap
(
)
.
send
(
id
)
)
;
}
}
