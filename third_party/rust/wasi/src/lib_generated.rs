use
core
:
:
mem
:
:
MaybeUninit
;
pub
use
crate
:
:
error
:
:
Error
;
pub
type
Result
<
T
E
=
Error
>
=
core
:
:
result
:
:
Result
<
T
E
>
;
pub
type
Size
=
usize
;
pub
type
Filesize
=
u64
;
pub
type
Timestamp
=
u64
;
pub
type
Clockid
=
u32
;
pub
const
CLOCKID_REALTIME
:
Clockid
=
0
;
pub
const
CLOCKID_MONOTONIC
:
Clockid
=
1
;
pub
const
CLOCKID_PROCESS_CPUTIME_ID
:
Clockid
=
2
;
pub
const
CLOCKID_THREAD_CPUTIME_ID
:
Clockid
=
3
;
pub
type
Errno
=
u16
;
pub
const
ERRNO_SUCCESS
:
Errno
=
0
;
pub
const
ERRNO_2BIG
:
Errno
=
1
;
pub
const
ERRNO_ACCES
:
Errno
=
2
;
pub
const
ERRNO_ADDRINUSE
:
Errno
=
3
;
pub
const
ERRNO_ADDRNOTAVAIL
:
Errno
=
4
;
pub
const
ERRNO_AFNOSUPPORT
:
Errno
=
5
;
pub
const
ERRNO_AGAIN
:
Errno
=
6
;
pub
const
ERRNO_ALREADY
:
Errno
=
7
;
pub
const
ERRNO_BADF
:
Errno
=
8
;
pub
const
ERRNO_BADMSG
:
Errno
=
9
;
pub
const
ERRNO_BUSY
:
Errno
=
10
;
pub
const
ERRNO_CANCELED
:
Errno
=
11
;
pub
const
ERRNO_CHILD
:
Errno
=
12
;
pub
const
ERRNO_CONNABORTED
:
Errno
=
13
;
pub
const
ERRNO_CONNREFUSED
:
Errno
=
14
;
pub
const
ERRNO_CONNRESET
:
Errno
=
15
;
pub
const
ERRNO_DEADLK
:
Errno
=
16
;
pub
const
ERRNO_DESTADDRREQ
:
Errno
=
17
;
pub
const
ERRNO_DOM
:
Errno
=
18
;
pub
const
ERRNO_DQUOT
:
Errno
=
19
;
pub
const
ERRNO_EXIST
:
Errno
=
20
;
pub
const
ERRNO_FAULT
:
Errno
=
21
;
pub
const
ERRNO_FBIG
:
Errno
=
22
;
pub
const
ERRNO_HOSTUNREACH
:
Errno
=
23
;
pub
const
ERRNO_IDRM
:
Errno
=
24
;
pub
const
ERRNO_ILSEQ
:
Errno
=
25
;
pub
const
ERRNO_INPROGRESS
:
Errno
=
26
;
pub
const
ERRNO_INTR
:
Errno
=
27
;
pub
const
ERRNO_INVAL
:
Errno
=
28
;
pub
const
ERRNO_IO
:
Errno
=
29
;
pub
const
ERRNO_ISCONN
:
Errno
=
30
;
pub
const
ERRNO_ISDIR
:
Errno
=
31
;
pub
const
ERRNO_LOOP
:
Errno
=
32
;
pub
const
ERRNO_MFILE
:
Errno
=
33
;
pub
const
ERRNO_MLINK
:
Errno
=
34
;
pub
const
ERRNO_MSGSIZE
:
Errno
=
35
;
pub
const
ERRNO_MULTIHOP
:
Errno
=
36
;
pub
const
ERRNO_NAMETOOLONG
:
Errno
=
37
;
pub
const
ERRNO_NETDOWN
:
Errno
=
38
;
pub
const
ERRNO_NETRESET
:
Errno
=
39
;
pub
const
ERRNO_NETUNREACH
:
Errno
=
40
;
pub
const
ERRNO_NFILE
:
Errno
=
41
;
pub
const
ERRNO_NOBUFS
:
Errno
=
42
;
pub
const
ERRNO_NODEV
:
Errno
=
43
;
pub
const
ERRNO_NOENT
:
Errno
=
44
;
pub
const
ERRNO_NOEXEC
:
Errno
=
45
;
pub
const
ERRNO_NOLCK
:
Errno
=
46
;
pub
const
ERRNO_NOLINK
:
Errno
=
47
;
pub
const
ERRNO_NOMEM
:
Errno
=
48
;
pub
const
ERRNO_NOMSG
:
Errno
=
49
;
pub
const
ERRNO_NOPROTOOPT
:
Errno
=
50
;
pub
const
ERRNO_NOSPC
:
Errno
=
51
;
pub
const
ERRNO_NOSYS
:
Errno
=
52
;
pub
const
ERRNO_NOTCONN
:
Errno
=
53
;
pub
const
ERRNO_NOTDIR
:
Errno
=
54
;
pub
const
ERRNO_NOTEMPTY
:
Errno
=
55
;
pub
const
ERRNO_NOTRECOVERABLE
:
Errno
=
56
;
pub
const
ERRNO_NOTSOCK
:
Errno
=
57
;
pub
const
ERRNO_NOTSUP
:
Errno
=
58
;
pub
const
ERRNO_NOTTY
:
Errno
=
59
;
pub
const
ERRNO_NXIO
:
Errno
=
60
;
pub
const
ERRNO_OVERFLOW
:
Errno
=
61
;
pub
const
ERRNO_OWNERDEAD
:
Errno
=
62
;
pub
const
ERRNO_PERM
:
Errno
=
63
;
pub
const
ERRNO_PIPE
:
Errno
=
64
;
pub
const
ERRNO_PROTO
:
Errno
=
65
;
pub
const
ERRNO_PROTONOSUPPORT
:
Errno
=
66
;
pub
const
ERRNO_PROTOTYPE
:
Errno
=
67
;
pub
const
ERRNO_RANGE
:
Errno
=
68
;
pub
const
ERRNO_ROFS
:
Errno
=
69
;
pub
const
ERRNO_SPIPE
:
Errno
=
70
;
pub
const
ERRNO_SRCH
:
Errno
=
71
;
pub
const
ERRNO_STALE
:
Errno
=
72
;
pub
const
ERRNO_TIMEDOUT
:
Errno
=
73
;
pub
const
ERRNO_TXTBSY
:
Errno
=
74
;
pub
const
ERRNO_XDEV
:
Errno
=
75
;
pub
const
ERRNO_NOTCAPABLE
:
Errno
=
76
;
pub
(
crate
)
fn
strerror
(
code
:
u16
)
-
>
&
'
static
str
{
match
code
{
ERRNO_SUCCESS
=
>
"
No
error
occurred
.
System
call
completed
successfully
.
"
ERRNO_2BIG
=
>
"
Argument
list
too
long
.
"
ERRNO_ACCES
=
>
"
Permission
denied
.
"
ERRNO_ADDRINUSE
=
>
"
Address
in
use
.
"
ERRNO_ADDRNOTAVAIL
=
>
"
Address
not
available
.
"
ERRNO_AFNOSUPPORT
=
>
"
Address
family
not
supported
.
"
ERRNO_AGAIN
=
>
"
Resource
unavailable
or
operation
would
block
.
"
ERRNO_ALREADY
=
>
"
Connection
already
in
progress
.
"
ERRNO_BADF
=
>
"
Bad
file
descriptor
.
"
ERRNO_BADMSG
=
>
"
Bad
message
.
"
ERRNO_BUSY
=
>
"
Device
or
resource
busy
.
"
ERRNO_CANCELED
=
>
"
Operation
canceled
.
"
ERRNO_CHILD
=
>
"
No
child
processes
.
"
ERRNO_CONNABORTED
=
>
"
Connection
aborted
.
"
ERRNO_CONNREFUSED
=
>
"
Connection
refused
.
"
ERRNO_CONNRESET
=
>
"
Connection
reset
.
"
ERRNO_DEADLK
=
>
"
Resource
deadlock
would
occur
.
"
ERRNO_DESTADDRREQ
=
>
"
Destination
address
required
.
"
ERRNO_DOM
=
>
"
Mathematics
argument
out
of
domain
of
function
.
"
ERRNO_DQUOT
=
>
"
Reserved
.
"
ERRNO_EXIST
=
>
"
File
exists
.
"
ERRNO_FAULT
=
>
"
Bad
address
.
"
ERRNO_FBIG
=
>
"
File
too
large
.
"
ERRNO_HOSTUNREACH
=
>
"
Host
is
unreachable
.
"
ERRNO_IDRM
=
>
"
Identifier
removed
.
"
ERRNO_ILSEQ
=
>
"
Illegal
byte
sequence
.
"
ERRNO_INPROGRESS
=
>
"
Operation
in
progress
.
"
ERRNO_INTR
=
>
"
Interrupted
function
.
"
ERRNO_INVAL
=
>
"
Invalid
argument
.
"
ERRNO_IO
=
>
"
I
/
O
error
.
"
ERRNO_ISCONN
=
>
"
Socket
is
connected
.
"
ERRNO_ISDIR
=
>
"
Is
a
directory
.
"
ERRNO_LOOP
=
>
"
Too
many
levels
of
symbolic
links
.
"
ERRNO_MFILE
=
>
"
File
descriptor
value
too
large
.
"
ERRNO_MLINK
=
>
"
Too
many
links
.
"
ERRNO_MSGSIZE
=
>
"
Message
too
large
.
"
ERRNO_MULTIHOP
=
>
"
Reserved
.
"
ERRNO_NAMETOOLONG
=
>
"
Filename
too
long
.
"
ERRNO_NETDOWN
=
>
"
Network
is
down
.
"
ERRNO_NETRESET
=
>
"
Connection
aborted
by
network
.
"
ERRNO_NETUNREACH
=
>
"
Network
unreachable
.
"
ERRNO_NFILE
=
>
"
Too
many
files
open
in
system
.
"
ERRNO_NOBUFS
=
>
"
No
buffer
space
available
.
"
ERRNO_NODEV
=
>
"
No
such
device
.
"
ERRNO_NOENT
=
>
"
No
such
file
or
directory
.
"
ERRNO_NOEXEC
=
>
"
Executable
file
format
error
.
"
ERRNO_NOLCK
=
>
"
No
locks
available
.
"
ERRNO_NOLINK
=
>
"
Reserved
.
"
ERRNO_NOMEM
=
>
"
Not
enough
space
.
"
ERRNO_NOMSG
=
>
"
No
message
of
the
desired
type
.
"
ERRNO_NOPROTOOPT
=
>
"
Protocol
not
available
.
"
ERRNO_NOSPC
=
>
"
No
space
left
on
device
.
"
ERRNO_NOSYS
=
>
"
Function
not
supported
.
"
ERRNO_NOTCONN
=
>
"
The
socket
is
not
connected
.
"
ERRNO_NOTDIR
=
>
"
Not
a
directory
or
a
symbolic
link
to
a
directory
.
"
ERRNO_NOTEMPTY
=
>
"
Directory
not
empty
.
"
ERRNO_NOTRECOVERABLE
=
>
"
State
not
recoverable
.
"
ERRNO_NOTSOCK
=
>
"
Not
a
socket
.
"
ERRNO_NOTSUP
=
>
"
Not
supported
or
operation
not
supported
on
socket
.
"
ERRNO_NOTTY
=
>
"
Inappropriate
I
/
O
control
operation
.
"
ERRNO_NXIO
=
>
"
No
such
device
or
address
.
"
ERRNO_OVERFLOW
=
>
"
Value
too
large
to
be
stored
in
data
type
.
"
ERRNO_OWNERDEAD
=
>
"
Previous
owner
died
.
"
ERRNO_PERM
=
>
"
Operation
not
permitted
.
"
ERRNO_PIPE
=
>
"
Broken
pipe
.
"
ERRNO_PROTO
=
>
"
Protocol
error
.
"
ERRNO_PROTONOSUPPORT
=
>
"
Protocol
not
supported
.
"
ERRNO_PROTOTYPE
=
>
"
Protocol
wrong
type
for
socket
.
"
ERRNO_RANGE
=
>
"
Result
too
large
.
"
ERRNO_ROFS
=
>
"
Read
-
only
file
system
.
"
ERRNO_SPIPE
=
>
"
Invalid
seek
.
"
ERRNO_SRCH
=
>
"
No
such
process
.
"
ERRNO_STALE
=
>
"
Reserved
.
"
ERRNO_TIMEDOUT
=
>
"
Connection
timed
out
.
"
ERRNO_TXTBSY
=
>
"
Text
file
busy
.
"
ERRNO_XDEV
=
>
"
Cross
-
device
link
.
"
ERRNO_NOTCAPABLE
=
>
"
Extension
:
Capabilities
insufficient
.
"
_
=
>
"
Unknown
error
.
"
}
}
pub
type
Rights
=
u64
;
pub
const
RIGHTS_FD_DATASYNC
:
Rights
=
0x1
;
pub
const
RIGHTS_FD_READ
:
Rights
=
0x2
;
pub
const
RIGHTS_FD_SEEK
:
Rights
=
0x4
;
pub
const
RIGHTS_FD_FDSTAT_SET_FLAGS
:
Rights
=
0x8
;
pub
const
RIGHTS_FD_SYNC
:
Rights
=
0x10
;
pub
const
RIGHTS_FD_TELL
:
Rights
=
0x20
;
pub
const
RIGHTS_FD_WRITE
:
Rights
=
0x40
;
pub
const
RIGHTS_FD_ADVISE
:
Rights
=
0x80
;
pub
const
RIGHTS_FD_ALLOCATE
:
Rights
=
0x100
;
pub
const
RIGHTS_PATH_CREATE_DIRECTORY
:
Rights
=
0x200
;
pub
const
RIGHTS_PATH_CREATE_FILE
:
Rights
=
0x400
;
pub
const
RIGHTS_PATH_LINK_SOURCE
:
Rights
=
0x800
;
pub
const
RIGHTS_PATH_LINK_TARGET
:
Rights
=
0x1000
;
pub
const
RIGHTS_PATH_OPEN
:
Rights
=
0x2000
;
pub
const
RIGHTS_FD_READDIR
:
Rights
=
0x4000
;
pub
const
RIGHTS_PATH_READLINK
:
Rights
=
0x8000
;
pub
const
RIGHTS_PATH_RENAME_SOURCE
:
Rights
=
0x10000
;
pub
const
RIGHTS_PATH_RENAME_TARGET
:
Rights
=
0x20000
;
pub
const
RIGHTS_PATH_FILESTAT_GET
:
Rights
=
0x40000
;
pub
const
RIGHTS_PATH_FILESTAT_SET_SIZE
:
Rights
=
0x80000
;
pub
const
RIGHTS_PATH_FILESTAT_SET_TIMES
:
Rights
=
0x100000
;
pub
const
RIGHTS_FD_FILESTAT_GET
:
Rights
=
0x200000
;
pub
const
RIGHTS_FD_FILESTAT_SET_SIZE
:
Rights
=
0x400000
;
pub
const
RIGHTS_FD_FILESTAT_SET_TIMES
:
Rights
=
0x800000
;
pub
const
RIGHTS_PATH_SYMLINK
:
Rights
=
0x1000000
;
pub
const
RIGHTS_PATH_REMOVE_DIRECTORY
:
Rights
=
0x2000000
;
pub
const
RIGHTS_PATH_UNLINK_FILE
:
Rights
=
0x4000000
;
pub
const
RIGHTS_POLL_FD_READWRITE
:
Rights
=
0x8000000
;
pub
const
RIGHTS_SOCK_SHUTDOWN
:
Rights
=
0x10000000
;
pub
type
Fd
=
u32
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
Iovec
{
pub
buf
:
*
mut
u8
pub
buf_len
:
Size
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
Ciovec
{
pub
buf
:
*
const
u8
pub
buf_len
:
Size
}
pub
type
IovecArray
<
'
a
>
=
&
'
a
[
Iovec
]
;
pub
type
CiovecArray
<
'
a
>
=
&
'
a
[
Ciovec
]
;
pub
type
Filedelta
=
i64
;
pub
type
Whence
=
u8
;
pub
const
WHENCE_SET
:
Whence
=
0
;
pub
const
WHENCE_CUR
:
Whence
=
1
;
pub
const
WHENCE_END
:
Whence
=
2
;
pub
type
Dircookie
=
u64
;
pub
type
Dirnamlen
=
u32
;
pub
type
Inode
=
u64
;
pub
type
Filetype
=
u8
;
pub
const
FILETYPE_UNKNOWN
:
Filetype
=
0
;
pub
const
FILETYPE_BLOCK_DEVICE
:
Filetype
=
1
;
pub
const
FILETYPE_CHARACTER_DEVICE
:
Filetype
=
2
;
pub
const
FILETYPE_DIRECTORY
:
Filetype
=
3
;
pub
const
FILETYPE_REGULAR_FILE
:
Filetype
=
4
;
pub
const
FILETYPE_SOCKET_DGRAM
:
Filetype
=
5
;
pub
const
FILETYPE_SOCKET_STREAM
:
Filetype
=
6
;
pub
const
FILETYPE_SYMBOLIC_LINK
:
Filetype
=
7
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
Dirent
{
pub
d_next
:
Dircookie
pub
d_ino
:
Inode
pub
d_namlen
:
Dirnamlen
pub
d_type
:
Filetype
}
pub
type
Advice
=
u8
;
pub
const
ADVICE_NORMAL
:
Advice
=
0
;
pub
const
ADVICE_SEQUENTIAL
:
Advice
=
1
;
pub
const
ADVICE_RANDOM
:
Advice
=
2
;
pub
const
ADVICE_WILLNEED
:
Advice
=
3
;
pub
const
ADVICE_DONTNEED
:
Advice
=
4
;
pub
const
ADVICE_NOREUSE
:
Advice
=
5
;
pub
type
Fdflags
=
u16
;
pub
const
FDFLAGS_APPEND
:
Fdflags
=
0x1
;
pub
const
FDFLAGS_DSYNC
:
Fdflags
=
0x2
;
pub
const
FDFLAGS_NONBLOCK
:
Fdflags
=
0x4
;
pub
const
FDFLAGS_RSYNC
:
Fdflags
=
0x8
;
pub
const
FDFLAGS_SYNC
:
Fdflags
=
0x10
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
Fdstat
{
pub
fs_filetype
:
Filetype
pub
fs_flags
:
Fdflags
pub
fs_rights_base
:
Rights
pub
fs_rights_inheriting
:
Rights
}
pub
type
Device
=
u64
;
pub
type
Fstflags
=
u16
;
pub
const
FSTFLAGS_ATIM
:
Fstflags
=
0x1
;
pub
const
FSTFLAGS_ATIM_NOW
:
Fstflags
=
0x2
;
pub
const
FSTFLAGS_MTIM
:
Fstflags
=
0x4
;
pub
const
FSTFLAGS_MTIM_NOW
:
Fstflags
=
0x8
;
pub
type
Lookupflags
=
u32
;
pub
const
LOOKUPFLAGS_SYMLINK_FOLLOW
:
Lookupflags
=
0x1
;
pub
type
Oflags
=
u16
;
pub
const
OFLAGS_CREAT
:
Oflags
=
0x1
;
pub
const
OFLAGS_DIRECTORY
:
Oflags
=
0x2
;
pub
const
OFLAGS_EXCL
:
Oflags
=
0x4
;
pub
const
OFLAGS_TRUNC
:
Oflags
=
0x8
;
pub
type
Linkcount
=
u64
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
Filestat
{
pub
dev
:
Device
pub
ino
:
Inode
pub
filetype
:
Filetype
pub
nlink
:
Linkcount
pub
size
:
Filesize
pub
atim
:
Timestamp
pub
mtim
:
Timestamp
pub
ctim
:
Timestamp
}
pub
type
Userdata
=
u64
;
pub
type
Eventtype
=
u8
;
pub
const
EVENTTYPE_CLOCK
:
Eventtype
=
0
;
pub
const
EVENTTYPE_FD_READ
:
Eventtype
=
1
;
pub
const
EVENTTYPE_FD_WRITE
:
Eventtype
=
2
;
pub
type
Eventrwflags
=
u16
;
pub
const
EVENTRWFLAGS_FD_READWRITE_HANGUP
:
Eventrwflags
=
0x1
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
EventFdReadwrite
{
pub
nbytes
:
Filesize
pub
flags
:
Eventrwflags
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
Event
{
pub
userdata
:
Userdata
pub
error
:
Errno
pub
r
#
type
:
Eventtype
pub
fd_readwrite
:
EventFdReadwrite
}
pub
type
Subclockflags
=
u16
;
pub
const
SUBCLOCKFLAGS_SUBSCRIPTION_CLOCK_ABSTIME
:
Subclockflags
=
0x1
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
SubscriptionClock
{
pub
id
:
Clockid
pub
timeout
:
Timestamp
pub
precision
:
Timestamp
pub
flags
:
Subclockflags
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
SubscriptionFdReadwrite
{
pub
file_descriptor
:
Fd
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
union
SubscriptionUU
{
pub
clock
:
SubscriptionClock
pub
fd_read
:
SubscriptionFdReadwrite
pub
fd_write
:
SubscriptionFdReadwrite
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
SubscriptionU
{
pub
tag
:
Eventtype
pub
u
:
SubscriptionUU
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
Subscription
{
pub
userdata
:
Userdata
pub
u
:
SubscriptionU
}
pub
type
Exitcode
=
u32
;
pub
type
Signal
=
u8
;
pub
const
SIGNAL_NONE
:
Signal
=
0
;
pub
const
SIGNAL_HUP
:
Signal
=
1
;
pub
const
SIGNAL_INT
:
Signal
=
2
;
pub
const
SIGNAL_QUIT
:
Signal
=
3
;
pub
const
SIGNAL_ILL
:
Signal
=
4
;
pub
const
SIGNAL_TRAP
:
Signal
=
5
;
pub
const
SIGNAL_ABRT
:
Signal
=
6
;
pub
const
SIGNAL_BUS
:
Signal
=
7
;
pub
const
SIGNAL_FPE
:
Signal
=
8
;
pub
const
SIGNAL_KILL
:
Signal
=
9
;
pub
const
SIGNAL_USR1
:
Signal
=
10
;
pub
const
SIGNAL_SEGV
:
Signal
=
11
;
pub
const
SIGNAL_USR2
:
Signal
=
12
;
pub
const
SIGNAL_PIPE
:
Signal
=
13
;
pub
const
SIGNAL_ALRM
:
Signal
=
14
;
pub
const
SIGNAL_TERM
:
Signal
=
15
;
pub
const
SIGNAL_CHLD
:
Signal
=
16
;
pub
const
SIGNAL_CONT
:
Signal
=
17
;
pub
const
SIGNAL_STOP
:
Signal
=
18
;
pub
const
SIGNAL_TSTP
:
Signal
=
19
;
pub
const
SIGNAL_TTIN
:
Signal
=
20
;
pub
const
SIGNAL_TTOU
:
Signal
=
21
;
pub
const
SIGNAL_URG
:
Signal
=
22
;
pub
const
SIGNAL_XCPU
:
Signal
=
23
;
pub
const
SIGNAL_XFSZ
:
Signal
=
24
;
pub
const
SIGNAL_VTALRM
:
Signal
=
25
;
pub
const
SIGNAL_PROF
:
Signal
=
26
;
pub
const
SIGNAL_WINCH
:
Signal
=
27
;
pub
const
SIGNAL_POLL
:
Signal
=
28
;
pub
const
SIGNAL_PWR
:
Signal
=
29
;
pub
const
SIGNAL_SYS
:
Signal
=
30
;
pub
type
Riflags
=
u16
;
pub
const
RIFLAGS_RECV_PEEK
:
Riflags
=
0x1
;
pub
const
RIFLAGS_RECV_WAITALL
:
Riflags
=
0x2
;
pub
type
Roflags
=
u16
;
pub
const
ROFLAGS_RECV_DATA_TRUNCATED
:
Roflags
=
0x1
;
pub
type
Siflags
=
u16
;
pub
type
Sdflags
=
u8
;
pub
const
SDFLAGS_RD
:
Sdflags
=
0x1
;
pub
const
SDFLAGS_WR
:
Sdflags
=
0x2
;
pub
type
Preopentype
=
u8
;
pub
const
PREOPENTYPE_DIR
:
Preopentype
=
0
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
PrestatDir
{
pub
pr_name_len
:
Size
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
union
PrestatU
{
pub
dir
:
PrestatDir
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
Prestat
{
pub
tag
:
Preopentype
pub
u
:
PrestatU
}
pub
unsafe
fn
args_get
(
argv
:
*
mut
*
mut
u8
argv_buf
:
*
mut
u8
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
args_get
(
argv
argv_buf
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
args_sizes_get
(
)
-
>
Result
<
(
Size
Size
)
>
{
let
mut
argc
=
MaybeUninit
:
:
uninit
(
)
;
let
mut
argv_buf_size
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
args_sizes_get
(
argc
.
as_mut_ptr
(
)
argv_buf_size
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
argc
.
assume_init
(
)
argv_buf_size
.
assume_init
(
)
)
)
}
}
pub
unsafe
fn
environ_get
(
environ
:
*
mut
*
mut
u8
environ_buf
:
*
mut
u8
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
environ_get
(
environ
environ_buf
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
environ_sizes_get
(
)
-
>
Result
<
(
Size
Size
)
>
{
let
mut
environc
=
MaybeUninit
:
:
uninit
(
)
;
let
mut
environ_buf_size
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
environ_sizes_get
(
environc
.
as_mut_ptr
(
)
environ_buf_size
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
environc
.
assume_init
(
)
environ_buf_size
.
assume_init
(
)
)
)
}
}
pub
unsafe
fn
clock_res_get
(
id
:
Clockid
)
-
>
Result
<
Timestamp
>
{
let
mut
resolution
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
clock_res_get
(
id
resolution
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
resolution
.
assume_init
(
)
)
}
}
pub
unsafe
fn
clock_time_get
(
id
:
Clockid
precision
:
Timestamp
)
-
>
Result
<
Timestamp
>
{
let
mut
time
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
clock_time_get
(
id
precision
time
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
time
.
assume_init
(
)
)
}
}
pub
unsafe
fn
fd_advise
(
fd
:
Fd
offset
:
Filesize
len
:
Filesize
advice
:
Advice
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
fd_advise
(
fd
offset
len
advice
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
fd_allocate
(
fd
:
Fd
offset
:
Filesize
len
:
Filesize
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
fd_allocate
(
fd
offset
len
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
fd_close
(
fd
:
Fd
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
fd_close
(
fd
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
fd_datasync
(
fd
:
Fd
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
fd_datasync
(
fd
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
fd_fdstat_get
(
fd
:
Fd
)
-
>
Result
<
Fdstat
>
{
let
mut
stat
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
fd_fdstat_get
(
fd
stat
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
stat
.
assume_init
(
)
)
}
}
pub
unsafe
fn
fd_fdstat_set_flags
(
fd
:
Fd
flags
:
Fdflags
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
fd_fdstat_set_flags
(
fd
flags
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
fd_fdstat_set_rights
(
fd
:
Fd
fs_rights_base
:
Rights
fs_rights_inheriting
:
Rights
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
fd_fdstat_set_rights
(
fd
fs_rights_base
fs_rights_inheriting
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
fd_filestat_get
(
fd
:
Fd
)
-
>
Result
<
Filestat
>
{
let
mut
buf
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
fd_filestat_get
(
fd
buf
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
buf
.
assume_init
(
)
)
}
}
pub
unsafe
fn
fd_filestat_set_size
(
fd
:
Fd
size
:
Filesize
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
fd_filestat_set_size
(
fd
size
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
fd_filestat_set_times
(
fd
:
Fd
atim
:
Timestamp
mtim
:
Timestamp
fst_flags
:
Fstflags
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
fd_filestat_set_times
(
fd
atim
mtim
fst_flags
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
fd_pread
(
fd
:
Fd
iovs
:
IovecArray
offset
:
Filesize
)
-
>
Result
<
Size
>
{
let
mut
nread
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
fd_pread
(
fd
iovs
.
as_ptr
(
)
iovs
.
len
(
)
offset
nread
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
nread
.
assume_init
(
)
)
}
}
pub
unsafe
fn
fd_prestat_get
(
fd
:
Fd
)
-
>
Result
<
Prestat
>
{
let
mut
buf
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
fd_prestat_get
(
fd
buf
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
buf
.
assume_init
(
)
)
}
}
pub
unsafe
fn
fd_prestat_dir_name
(
fd
:
Fd
path
:
*
mut
u8
path_len
:
Size
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
fd_prestat_dir_name
(
fd
path
path_len
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
fd_pwrite
(
fd
:
Fd
iovs
:
CiovecArray
offset
:
Filesize
)
-
>
Result
<
Size
>
{
let
mut
nwritten
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
fd_pwrite
(
fd
iovs
.
as_ptr
(
)
iovs
.
len
(
)
offset
nwritten
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
nwritten
.
assume_init
(
)
)
}
}
pub
unsafe
fn
fd_read
(
fd
:
Fd
iovs
:
IovecArray
)
-
>
Result
<
Size
>
{
let
mut
nread
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
fd_read
(
fd
iovs
.
as_ptr
(
)
iovs
.
len
(
)
nread
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
nread
.
assume_init
(
)
)
}
}
pub
unsafe
fn
fd_readdir
(
fd
:
Fd
buf
:
*
mut
u8
buf_len
:
Size
cookie
:
Dircookie
)
-
>
Result
<
Size
>
{
let
mut
bufused
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
fd_readdir
(
fd
buf
buf_len
cookie
bufused
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
bufused
.
assume_init
(
)
)
}
}
pub
unsafe
fn
fd_renumber
(
fd
:
Fd
to
:
Fd
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
fd_renumber
(
fd
to
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
fd_seek
(
fd
:
Fd
offset
:
Filedelta
whence
:
Whence
)
-
>
Result
<
Filesize
>
{
let
mut
newoffset
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
fd_seek
(
fd
offset
whence
newoffset
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
newoffset
.
assume_init
(
)
)
}
}
pub
unsafe
fn
fd_sync
(
fd
:
Fd
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
fd_sync
(
fd
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
fd_tell
(
fd
:
Fd
)
-
>
Result
<
Filesize
>
{
let
mut
offset
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
fd_tell
(
fd
offset
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
offset
.
assume_init
(
)
)
}
}
pub
unsafe
fn
fd_write
(
fd
:
Fd
iovs
:
CiovecArray
)
-
>
Result
<
Size
>
{
let
mut
nwritten
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
fd_write
(
fd
iovs
.
as_ptr
(
)
iovs
.
len
(
)
nwritten
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
nwritten
.
assume_init
(
)
)
}
}
pub
unsafe
fn
path_create_directory
(
fd
:
Fd
path
:
&
str
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
path_create_directory
(
fd
path
.
as_ptr
(
)
path
.
len
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
path_filestat_get
(
fd
:
Fd
flags
:
Lookupflags
path
:
&
str
)
-
>
Result
<
Filestat
>
{
let
mut
buf
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
path_filestat_get
(
fd
flags
path
.
as_ptr
(
)
path
.
len
(
)
buf
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
buf
.
assume_init
(
)
)
}
}
pub
unsafe
fn
path_filestat_set_times
(
fd
:
Fd
flags
:
Lookupflags
path
:
&
str
atim
:
Timestamp
mtim
:
Timestamp
fst_flags
:
Fstflags
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
path_filestat_set_times
(
fd
flags
path
.
as_ptr
(
)
path
.
len
(
)
atim
mtim
fst_flags
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
path_link
(
old_fd
:
Fd
old_flags
:
Lookupflags
old_path
:
&
str
new_fd
:
Fd
new_path
:
&
str
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
path_link
(
old_fd
old_flags
old_path
.
as_ptr
(
)
old_path
.
len
(
)
new_fd
new_path
.
as_ptr
(
)
new_path
.
len
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
path_open
(
fd
:
Fd
dirflags
:
Lookupflags
path
:
&
str
oflags
:
Oflags
fs_rights_base
:
Rights
fs_rights_inherting
:
Rights
fdflags
:
Fdflags
)
-
>
Result
<
Fd
>
{
let
mut
opened_fd
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
path_open
(
fd
dirflags
path
.
as_ptr
(
)
path
.
len
(
)
oflags
fs_rights_base
fs_rights_inherting
fdflags
opened_fd
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
opened_fd
.
assume_init
(
)
)
}
}
pub
unsafe
fn
path_readlink
(
fd
:
Fd
path
:
&
str
buf
:
*
mut
u8
buf_len
:
Size
)
-
>
Result
<
Size
>
{
let
mut
bufused
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
path_readlink
(
fd
path
.
as_ptr
(
)
path
.
len
(
)
buf
buf_len
bufused
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
bufused
.
assume_init
(
)
)
}
}
pub
unsafe
fn
path_remove_directory
(
fd
:
Fd
path
:
&
str
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
path_remove_directory
(
fd
path
.
as_ptr
(
)
path
.
len
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
path_rename
(
fd
:
Fd
old_path
:
&
str
new_fd
:
Fd
new_path
:
&
str
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
path_rename
(
fd
old_path
.
as_ptr
(
)
old_path
.
len
(
)
new_fd
new_path
.
as_ptr
(
)
new_path
.
len
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
path_symlink
(
old_path
:
&
str
fd
:
Fd
new_path
:
&
str
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
path_symlink
(
old_path
.
as_ptr
(
)
old_path
.
len
(
)
fd
new_path
.
as_ptr
(
)
new_path
.
len
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
path_unlink_file
(
fd
:
Fd
path
:
&
str
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
path_unlink_file
(
fd
path
.
as_ptr
(
)
path
.
len
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
poll_oneoff
(
r
#
in
:
*
const
Subscription
out
:
*
mut
Event
nsubscriptions
:
Size
)
-
>
Result
<
Size
>
{
let
mut
nevents
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
poll_oneoff
(
r
#
in
out
nsubscriptions
nevents
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
nevents
.
assume_init
(
)
)
}
}
pub
unsafe
fn
proc_exit
(
rval
:
Exitcode
)
{
wasi_snapshot_preview1
:
:
proc_exit
(
rval
)
;
}
pub
unsafe
fn
proc_raise
(
sig
:
Signal
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
proc_raise
(
sig
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
sched_yield
(
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
sched_yield
(
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
random_get
(
buf
:
*
mut
u8
buf_len
:
Size
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
random_get
(
buf
buf_len
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
sock_recv
(
fd
:
Fd
ri_data
:
IovecArray
ri_flags
:
Riflags
)
-
>
Result
<
(
Size
Roflags
)
>
{
let
mut
ro_datalen
=
MaybeUninit
:
:
uninit
(
)
;
let
mut
ro_flags
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
sock_recv
(
fd
ri_data
.
as_ptr
(
)
ri_data
.
len
(
)
ri_flags
ro_datalen
.
as_mut_ptr
(
)
ro_flags
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
ro_datalen
.
assume_init
(
)
ro_flags
.
assume_init
(
)
)
)
}
}
pub
unsafe
fn
sock_send
(
fd
:
Fd
si_data
:
CiovecArray
si_flags
:
Siflags
)
-
>
Result
<
Size
>
{
let
mut
so_datalen
=
MaybeUninit
:
:
uninit
(
)
;
let
rc
=
wasi_snapshot_preview1
:
:
sock_send
(
fd
si_data
.
as_ptr
(
)
si_data
.
len
(
)
si_flags
so_datalen
.
as_mut_ptr
(
)
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
so_datalen
.
assume_init
(
)
)
}
}
pub
unsafe
fn
sock_shutdown
(
fd
:
Fd
how
:
Sdflags
)
-
>
Result
<
(
)
>
{
let
rc
=
wasi_snapshot_preview1
:
:
sock_shutdown
(
fd
how
)
;
if
let
Some
(
err
)
=
Error
:
:
from_raw_error
(
rc
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
mod
wasi_snapshot_preview1
{
use
super
:
:
*
;
#
[
link
(
wasm_import_module
=
"
wasi_snapshot_preview1
"
)
]
extern
"
C
"
{
pub
fn
args_get
(
argv
:
*
mut
*
mut
u8
argv_buf
:
*
mut
u8
)
-
>
Errno
;
pub
fn
args_sizes_get
(
argc
:
*
mut
Size
argv_buf_size
:
*
mut
Size
)
-
>
Errno
;
pub
fn
environ_get
(
environ
:
*
mut
*
mut
u8
environ_buf
:
*
mut
u8
)
-
>
Errno
;
pub
fn
environ_sizes_get
(
environc
:
*
mut
Size
environ_buf_size
:
*
mut
Size
)
-
>
Errno
;
pub
fn
clock_res_get
(
id
:
Clockid
resolution
:
*
mut
Timestamp
)
-
>
Errno
;
pub
fn
clock_time_get
(
id
:
Clockid
precision
:
Timestamp
time
:
*
mut
Timestamp
)
-
>
Errno
;
pub
fn
fd_advise
(
fd
:
Fd
offset
:
Filesize
len
:
Filesize
advice
:
Advice
)
-
>
Errno
;
pub
fn
fd_allocate
(
fd
:
Fd
offset
:
Filesize
len
:
Filesize
)
-
>
Errno
;
pub
fn
fd_close
(
fd
:
Fd
)
-
>
Errno
;
pub
fn
fd_datasync
(
fd
:
Fd
)
-
>
Errno
;
pub
fn
fd_fdstat_get
(
fd
:
Fd
stat
:
*
mut
Fdstat
)
-
>
Errno
;
pub
fn
fd_fdstat_set_flags
(
fd
:
Fd
flags
:
Fdflags
)
-
>
Errno
;
pub
fn
fd_fdstat_set_rights
(
fd
:
Fd
fs_rights_base
:
Rights
fs_rights_inheriting
:
Rights
)
-
>
Errno
;
pub
fn
fd_filestat_get
(
fd
:
Fd
buf
:
*
mut
Filestat
)
-
>
Errno
;
pub
fn
fd_filestat_set_size
(
fd
:
Fd
size
:
Filesize
)
-
>
Errno
;
pub
fn
fd_filestat_set_times
(
fd
:
Fd
atim
:
Timestamp
mtim
:
Timestamp
fst_flags
:
Fstflags
)
-
>
Errno
;
pub
fn
fd_pread
(
fd
:
Fd
iovs_ptr
:
*
const
Iovec
iovs_len
:
usize
offset
:
Filesize
nread
:
*
mut
Size
)
-
>
Errno
;
pub
fn
fd_prestat_get
(
fd
:
Fd
buf
:
*
mut
Prestat
)
-
>
Errno
;
pub
fn
fd_prestat_dir_name
(
fd
:
Fd
path
:
*
mut
u8
path_len
:
Size
)
-
>
Errno
;
pub
fn
fd_pwrite
(
fd
:
Fd
iovs_ptr
:
*
const
Ciovec
iovs_len
:
usize
offset
:
Filesize
nwritten
:
*
mut
Size
)
-
>
Errno
;
pub
fn
fd_read
(
fd
:
Fd
iovs_ptr
:
*
const
Iovec
iovs_len
:
usize
nread
:
*
mut
Size
)
-
>
Errno
;
pub
fn
fd_readdir
(
fd
:
Fd
buf
:
*
mut
u8
buf_len
:
Size
cookie
:
Dircookie
bufused
:
*
mut
Size
)
-
>
Errno
;
pub
fn
fd_renumber
(
fd
:
Fd
to
:
Fd
)
-
>
Errno
;
pub
fn
fd_seek
(
fd
:
Fd
offset
:
Filedelta
whence
:
Whence
newoffset
:
*
mut
Filesize
)
-
>
Errno
;
pub
fn
fd_sync
(
fd
:
Fd
)
-
>
Errno
;
pub
fn
fd_tell
(
fd
:
Fd
offset
:
*
mut
Filesize
)
-
>
Errno
;
pub
fn
fd_write
(
fd
:
Fd
iovs_ptr
:
*
const
Ciovec
iovs_len
:
usize
nwritten
:
*
mut
Size
)
-
>
Errno
;
pub
fn
path_create_directory
(
fd
:
Fd
path_ptr
:
*
const
u8
path_len
:
usize
)
-
>
Errno
;
pub
fn
path_filestat_get
(
fd
:
Fd
flags
:
Lookupflags
path_ptr
:
*
const
u8
path_len
:
usize
buf
:
*
mut
Filestat
)
-
>
Errno
;
pub
fn
path_filestat_set_times
(
fd
:
Fd
flags
:
Lookupflags
path_ptr
:
*
const
u8
path_len
:
usize
atim
:
Timestamp
mtim
:
Timestamp
fst_flags
:
Fstflags
)
-
>
Errno
;
pub
fn
path_link
(
old_fd
:
Fd
old_flags
:
Lookupflags
old_path_ptr
:
*
const
u8
old_path_len
:
usize
new_fd
:
Fd
new_path_ptr
:
*
const
u8
new_path_len
:
usize
)
-
>
Errno
;
pub
fn
path_open
(
fd
:
Fd
dirflags
:
Lookupflags
path_ptr
:
*
const
u8
path_len
:
usize
oflags
:
Oflags
fs_rights_base
:
Rights
fs_rights_inherting
:
Rights
fdflags
:
Fdflags
opened_fd
:
*
mut
Fd
)
-
>
Errno
;
pub
fn
path_readlink
(
fd
:
Fd
path_ptr
:
*
const
u8
path_len
:
usize
buf
:
*
mut
u8
buf_len
:
Size
bufused
:
*
mut
Size
)
-
>
Errno
;
pub
fn
path_remove_directory
(
fd
:
Fd
path_ptr
:
*
const
u8
path_len
:
usize
)
-
>
Errno
;
pub
fn
path_rename
(
fd
:
Fd
old_path_ptr
:
*
const
u8
old_path_len
:
usize
new_fd
:
Fd
new_path_ptr
:
*
const
u8
new_path_len
:
usize
)
-
>
Errno
;
pub
fn
path_symlink
(
old_path_ptr
:
*
const
u8
old_path_len
:
usize
fd
:
Fd
new_path_ptr
:
*
const
u8
new_path_len
:
usize
)
-
>
Errno
;
pub
fn
path_unlink_file
(
fd
:
Fd
path_ptr
:
*
const
u8
path_len
:
usize
)
-
>
Errno
;
pub
fn
poll_oneoff
(
r
#
in
:
*
const
Subscription
out
:
*
mut
Event
nsubscriptions
:
Size
nevents
:
*
mut
Size
)
-
>
Errno
;
pub
fn
proc_exit
(
rval
:
Exitcode
)
-
>
!
;
pub
fn
proc_raise
(
sig
:
Signal
)
-
>
Errno
;
pub
fn
sched_yield
(
)
-
>
Errno
;
pub
fn
random_get
(
buf
:
*
mut
u8
buf_len
:
Size
)
-
>
Errno
;
pub
fn
sock_recv
(
fd
:
Fd
ri_data_ptr
:
*
const
Iovec
ri_data_len
:
usize
ri_flags
:
Riflags
ro_datalen
:
*
mut
Size
ro_flags
:
*
mut
Roflags
)
-
>
Errno
;
pub
fn
sock_send
(
fd
:
Fd
si_data_ptr
:
*
const
Ciovec
si_data_len
:
usize
si_flags
:
Siflags
so_datalen
:
*
mut
Size
)
-
>
Errno
;
pub
fn
sock_shutdown
(
fd
:
Fd
how
:
Sdflags
)
-
>
Errno
;
}
}
