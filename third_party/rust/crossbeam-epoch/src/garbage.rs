use
core
:
:
fmt
;
use
arrayvec
:
:
ArrayVec
;
use
deferred
:
:
Deferred
;
#
[
cfg
(
not
(
feature
=
"
strict_gc
"
)
)
]
const
MAX_OBJECTS
:
usize
=
64
;
#
[
cfg
(
feature
=
"
strict_gc
"
)
]
const
MAX_OBJECTS
:
usize
=
4
;
pub
struct
Garbage
{
func
:
Deferred
}
unsafe
impl
Sync
for
Garbage
{
}
unsafe
impl
Send
for
Garbage
{
}
impl
fmt
:
:
Debug
for
Garbage
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
write
!
(
f
"
garbage
{
{
.
.
.
}
}
"
)
}
}
impl
Garbage
{
pub
fn
new
<
F
:
FnOnce
(
)
>
(
f
:
F
)
-
>
Self
{
Garbage
{
func
:
Deferred
:
:
new
(
move
|
|
f
(
)
)
}
}
}
impl
Drop
for
Garbage
{
fn
drop
(
&
mut
self
)
{
self
.
func
.
call
(
)
;
}
}
#
[
derive
(
Default
Debug
)
]
pub
struct
Bag
{
objects
:
ArrayVec
<
[
Garbage
;
MAX_OBJECTS
]
>
}
impl
Bag
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
objects
.
is_empty
(
)
}
pub
fn
try_push
(
&
mut
self
garbage
:
Garbage
)
-
>
Result
<
(
)
Garbage
>
{
self
.
objects
.
try_push
(
garbage
)
.
map_err
(
|
e
|
e
.
element
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
ATOMIC_USIZE_INIT
}
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
super
:
:
{
Garbage
Bag
}
;
#
[
test
]
fn
check_defer
(
)
{
static
FLAG
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
fn
set
(
)
{
FLAG
.
store
(
42
Ordering
:
:
Relaxed
)
;
}
let
g
=
Garbage
:
:
new
(
set
)
;
assert_eq
!
(
FLAG
.
load
(
Ordering
:
:
Relaxed
)
0
)
;
drop
(
g
)
;
assert_eq
!
(
FLAG
.
load
(
Ordering
:
:
Relaxed
)
42
)
;
}
#
[
test
]
fn
check_bag
(
)
{
static
FLAG
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
fn
incr
(
)
{
FLAG
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
let
mut
bag
=
Bag
:
:
new
(
)
;
assert
!
(
bag
.
is_empty
(
)
)
;
for
_
in
0
.
.
super
:
:
MAX_OBJECTS
{
assert
!
(
bag
.
try_push
(
Garbage
:
:
new
(
incr
)
)
.
is_ok
(
)
)
;
assert
!
(
!
bag
.
is_empty
(
)
)
;
assert_eq
!
(
FLAG
.
load
(
Ordering
:
:
Relaxed
)
0
)
;
}
let
result
=
bag
.
try_push
(
Garbage
:
:
new
(
incr
)
)
;
assert
!
(
result
.
is_err
(
)
)
;
assert
!
(
!
bag
.
is_empty
(
)
)
;
assert_eq
!
(
FLAG
.
load
(
Ordering
:
:
Relaxed
)
0
)
;
drop
(
bag
)
;
assert_eq
!
(
FLAG
.
load
(
Ordering
:
:
Relaxed
)
super
:
:
MAX_OBJECTS
)
;
}
}
