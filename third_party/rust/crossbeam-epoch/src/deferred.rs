use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
fmt
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
:
:
{
self
MaybeUninit
}
;
use
core
:
:
ptr
;
const
DATA_WORDS
:
usize
=
3
;
type
Data
=
[
usize
;
DATA_WORDS
]
;
pub
(
crate
)
struct
Deferred
{
call
:
unsafe
fn
(
*
mut
u8
)
data
:
MaybeUninit
<
Data
>
_marker
:
PhantomData
<
*
mut
(
)
>
}
impl
fmt
:
:
Debug
for
Deferred
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
f
.
pad
(
"
Deferred
{
.
.
}
"
)
}
}
impl
Deferred
{
pub
(
crate
)
const
NO_OP
:
Self
=
{
fn
no_op_call
(
_raw
:
*
mut
u8
)
{
}
Self
{
call
:
no_op_call
data
:
MaybeUninit
:
:
uninit
(
)
_marker
:
PhantomData
}
}
;
pub
(
crate
)
fn
new
<
F
:
FnOnce
(
)
>
(
f
:
F
)
-
>
Self
{
let
size
=
mem
:
:
size_of
:
:
<
F
>
(
)
;
let
align
=
mem
:
:
align_of
:
:
<
F
>
(
)
;
unsafe
{
if
size
<
=
mem
:
:
size_of
:
:
<
Data
>
(
)
&
&
align
<
=
mem
:
:
align_of
:
:
<
Data
>
(
)
{
let
mut
data
=
MaybeUninit
:
:
<
Data
>
:
:
uninit
(
)
;
ptr
:
:
write
(
data
.
as_mut_ptr
(
)
.
cast
:
:
<
F
>
(
)
f
)
;
unsafe
fn
call
<
F
:
FnOnce
(
)
>
(
raw
:
*
mut
u8
)
{
let
f
:
F
=
ptr
:
:
read
(
raw
.
cast
:
:
<
F
>
(
)
)
;
f
(
)
;
}
Deferred
{
call
:
call
:
:
<
F
>
data
_marker
:
PhantomData
}
}
else
{
let
b
:
Box
<
F
>
=
Box
:
:
new
(
f
)
;
let
mut
data
=
MaybeUninit
:
:
<
Data
>
:
:
uninit
(
)
;
ptr
:
:
write
(
data
.
as_mut_ptr
(
)
.
cast
:
:
<
Box
<
F
>
>
(
)
b
)
;
unsafe
fn
call
<
F
:
FnOnce
(
)
>
(
raw
:
*
mut
u8
)
{
let
b
:
Box
<
F
>
=
ptr
:
:
read
(
raw
.
cast
:
:
<
Box
<
F
>
>
(
)
)
;
(
*
b
)
(
)
;
}
Deferred
{
call
:
call
:
:
<
F
>
data
_marker
:
PhantomData
}
}
}
}
#
[
inline
]
pub
(
crate
)
fn
call
(
mut
self
)
{
let
call
=
self
.
call
;
unsafe
{
call
(
self
.
data
.
as_mut_ptr
(
)
.
cast
:
:
<
u8
>
(
)
)
}
;
}
}
#
[
cfg
(
all
(
test
not
(
crossbeam_loom
)
)
)
]
mod
tests
{
#
!
[
allow
(
clippy
:
:
drop_copy
)
]
use
super
:
:
Deferred
;
use
std
:
:
cell
:
:
Cell
;
#
[
test
]
fn
on_stack
(
)
{
let
fired
=
&
Cell
:
:
new
(
false
)
;
let
a
=
[
0usize
;
1
]
;
let
d
=
Deferred
:
:
new
(
move
|
|
{
drop
(
a
)
;
fired
.
set
(
true
)
;
}
)
;
assert
!
(
!
fired
.
get
(
)
)
;
d
.
call
(
)
;
assert
!
(
fired
.
get
(
)
)
;
}
#
[
test
]
fn
on_heap
(
)
{
let
fired
=
&
Cell
:
:
new
(
false
)
;
let
a
=
[
0usize
;
10
]
;
let
d
=
Deferred
:
:
new
(
move
|
|
{
drop
(
a
)
;
fired
.
set
(
true
)
;
}
)
;
assert
!
(
!
fired
.
get
(
)
)
;
d
.
call
(
)
;
assert
!
(
fired
.
get
(
)
)
;
}
#
[
test
]
fn
string
(
)
{
let
a
=
"
hello
"
.
to_string
(
)
;
let
d
=
Deferred
:
:
new
(
move
|
|
assert_eq
!
(
a
"
hello
"
)
)
;
d
.
call
(
)
;
}
#
[
test
]
fn
boxed_slice_i32
(
)
{
let
a
:
Box
<
[
i32
]
>
=
vec
!
[
2
3
5
7
]
.
into_boxed_slice
(
)
;
let
d
=
Deferred
:
:
new
(
move
|
|
assert_eq
!
(
*
a
[
2
3
5
7
]
)
)
;
d
.
call
(
)
;
}
#
[
test
]
fn
long_slice_usize
(
)
{
let
a
:
[
usize
;
5
]
=
[
2
3
5
7
11
]
;
let
d
=
Deferred
:
:
new
(
move
|
|
assert_eq
!
(
a
[
2
3
5
7
11
]
)
)
;
d
.
call
(
)
;
}
}
