use
core
:
:
fmt
;
use
core
:
:
mem
;
use
atomic
:
:
Shared
;
use
collector
:
:
Collector
;
use
deferred
:
:
Deferred
;
use
internal
:
:
Local
;
pub
struct
Guard
{
pub
(
crate
)
local
:
*
const
Local
}
impl
Guard
{
pub
fn
defer
<
F
R
>
(
&
self
f
:
F
)
where
F
:
FnOnce
(
)
-
>
R
F
:
Send
+
'
static
{
unsafe
{
self
.
defer_unchecked
(
f
)
;
}
}
pub
unsafe
fn
defer_unchecked
<
F
R
>
(
&
self
f
:
F
)
where
F
:
FnOnce
(
)
-
>
R
{
if
let
Some
(
local
)
=
self
.
local
.
as_ref
(
)
{
local
.
defer
(
Deferred
:
:
new
(
move
|
|
drop
(
f
(
)
)
)
self
)
;
}
}
pub
unsafe
fn
defer_destroy
<
T
>
(
&
self
ptr
:
Shared
<
T
>
)
{
self
.
defer_unchecked
(
move
|
|
ptr
.
into_owned
(
)
)
;
}
pub
fn
flush
(
&
self
)
{
if
let
Some
(
local
)
=
unsafe
{
self
.
local
.
as_ref
(
)
}
{
local
.
flush
(
self
)
;
}
}
pub
fn
repin
(
&
mut
self
)
{
if
let
Some
(
local
)
=
unsafe
{
self
.
local
.
as_ref
(
)
}
{
local
.
repin
(
)
;
}
}
pub
fn
repin_after
<
F
R
>
(
&
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
{
if
let
Some
(
local
)
=
unsafe
{
self
.
local
.
as_ref
(
)
}
{
local
.
acquire_handle
(
)
;
local
.
unpin
(
)
;
}
defer
!
{
if
let
Some
(
local
)
=
unsafe
{
self
.
local
.
as_ref
(
)
}
{
mem
:
:
forget
(
local
.
pin
(
)
)
;
local
.
release_handle
(
)
;
}
}
f
(
)
}
pub
fn
collector
(
&
self
)
-
>
Option
<
&
Collector
>
{
unsafe
{
self
.
local
.
as_ref
(
)
.
map
(
|
local
|
local
.
collector
(
)
)
}
}
}
impl
Drop
for
Guard
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
if
let
Some
(
local
)
=
unsafe
{
self
.
local
.
as_ref
(
)
}
{
local
.
unpin
(
)
;
}
}
}
impl
fmt
:
:
Debug
for
Guard
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
pad
(
"
Guard
{
.
.
}
"
)
}
}
#
[
inline
]
pub
unsafe
fn
unprotected
(
)
-
>
&
'
static
Guard
{
static
UNPROTECTED
:
usize
=
0
;
&
*
(
&
UNPROTECTED
as
*
const
_
as
*
const
Guard
)
}
