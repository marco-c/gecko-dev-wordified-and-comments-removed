use
core
:
:
ptr
;
use
core
:
:
mem
;
use
garbage
:
:
Garbage
;
use
internal
:
:
Local
;
pub
struct
Guard
{
local
:
*
const
Local
}
impl
Guard
{
#
[
doc
(
hidden
)
]
pub
unsafe
fn
new
(
local
:
*
const
Local
)
-
>
Guard
{
Guard
{
local
:
local
}
}
#
[
doc
(
hidden
)
]
pub
unsafe
fn
get_local
(
&
self
)
-
>
*
const
Local
{
self
.
local
}
pub
unsafe
fn
defer
<
F
R
>
(
&
self
f
:
F
)
where
F
:
FnOnce
(
)
-
>
R
{
let
garbage
=
Garbage
:
:
new
(
|
|
drop
(
f
(
)
)
)
;
if
let
Some
(
local
)
=
self
.
local
.
as_ref
(
)
{
local
.
defer
(
garbage
self
)
;
}
}
pub
fn
flush
(
&
self
)
{
if
let
Some
(
local
)
=
unsafe
{
self
.
local
.
as_ref
(
)
}
{
local
.
flush
(
self
)
;
}
}
pub
fn
repin
(
&
mut
self
)
{
if
let
Some
(
local
)
=
unsafe
{
self
.
local
.
as_ref
(
)
}
{
local
.
repin
(
)
;
}
}
pub
fn
repin_after
<
F
R
>
(
&
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
{
if
let
Some
(
local
)
=
unsafe
{
self
.
local
.
as_ref
(
)
}
{
local
.
acquire_handle
(
)
;
local
.
unpin
(
)
;
}
defer
!
{
if
let
Some
(
local
)
=
unsafe
{
self
.
local
.
as_ref
(
)
}
{
mem
:
:
forget
(
local
.
pin
(
)
)
;
local
.
release_handle
(
)
;
}
}
f
(
)
}
}
impl
Drop
for
Guard
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
if
let
Some
(
local
)
=
unsafe
{
self
.
local
.
as_ref
(
)
}
{
local
.
unpin
(
)
;
}
}
}
impl
Clone
for
Guard
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Guard
{
match
unsafe
{
self
.
local
.
as_ref
(
)
}
{
None
=
>
Guard
{
local
:
ptr
:
:
null
(
)
}
Some
(
local
)
=
>
local
.
pin
(
)
}
}
}
#
[
inline
]
pub
unsafe
fn
unprotected
(
)
-
>
&
'
static
Guard
{
static
UNPROTECTED
:
usize
=
0
;
&
*
(
&
UNPROTECTED
as
*
const
_
as
*
const
Guard
)
}
