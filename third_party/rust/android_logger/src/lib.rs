#
[
cfg
(
target_os
=
"
android
"
)
]
extern
crate
android_log_sys
as
log_ffi
;
#
[
macro_use
]
extern
crate
lazy_static
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
env_logger
;
use
std
:
:
sync
:
:
RwLock
;
#
[
cfg
(
target_os
=
"
android
"
)
]
use
log_ffi
:
:
LogPriority
;
use
log
:
:
{
Level
Log
Metadata
Record
}
;
use
std
:
:
ffi
:
:
{
CStr
CString
}
;
use
std
:
:
mem
;
use
std
:
:
fmt
;
use
std
:
:
ptr
;
pub
use
env_logger
:
:
filter
:
:
{
Filter
Builder
as
FilterBuilder
}
;
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
android_log
(
prio
:
log_ffi
:
:
LogPriority
tag
:
&
CStr
msg
:
&
CStr
)
{
unsafe
{
log_ffi
:
:
__android_log_write
(
prio
as
log_ffi
:
:
c_int
tag
.
as_ptr
(
)
as
*
const
log_ffi
:
:
c_char
msg
.
as_ptr
(
)
as
*
const
log_ffi
:
:
c_char
)
}
;
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
android_log
(
_priority
:
Level
_tag
:
&
CStr
_msg
:
&
CStr
)
{
}
pub
struct
AndroidLogger
{
config
:
RwLock
<
Config
>
}
impl
AndroidLogger
{
pub
fn
new
(
config
:
Config
)
-
>
AndroidLogger
{
AndroidLogger
{
config
:
RwLock
:
:
new
(
config
)
}
}
}
lazy_static
!
{
static
ref
ANDROID_LOGGER
:
AndroidLogger
=
AndroidLogger
:
:
default
(
)
;
}
const
LOGGING_TAG_MAX_LEN
:
usize
=
23
;
const
LOGGING_MSG_MAX_LEN
:
usize
=
4000
;
impl
Default
for
AndroidLogger
{
fn
default
(
)
-
>
AndroidLogger
{
AndroidLogger
{
config
:
RwLock
:
:
new
(
Config
:
:
default
(
)
)
}
}
}
impl
Log
for
AndroidLogger
{
fn
enabled
(
&
self
_
:
&
Metadata
)
-
>
bool
{
true
}
fn
log
(
&
self
record
:
&
Record
)
{
let
config
=
self
.
config
.
read
(
)
.
expect
(
"
failed
to
acquire
android_log
filter
lock
for
read
"
)
;
if
!
config
.
filter_matches
(
record
)
{
return
;
}
let
mut
tag_bytes
:
[
u8
;
LOGGING_TAG_MAX_LEN
+
1
]
=
unsafe
{
mem
:
:
uninitialized
(
)
}
;
let
module_path
=
record
.
module_path
(
)
.
unwrap_or_default
(
)
.
to_owned
(
)
;
let
custom_tag
=
&
config
.
tag
;
let
tag
=
custom_tag
.
as_ref
(
)
.
map
(
|
s
|
s
.
as_bytes
(
)
)
.
unwrap_or
(
module_path
.
as_bytes
(
)
)
;
self
.
fill_tag_bytes
(
&
mut
tag_bytes
tag
)
;
let
tag
:
&
CStr
=
unsafe
{
CStr
:
:
from_ptr
(
mem
:
:
transmute
(
tag_bytes
.
as_ptr
(
)
)
)
}
;
let
mut
writer
=
PlatformLogWriter
:
:
new
(
record
.
level
(
)
tag
)
;
let
_
=
if
custom_tag
.
is_some
(
)
{
fmt
:
:
write
(
&
mut
writer
format_args
!
(
"
{
}
:
{
}
"
module_path
*
record
.
args
(
)
)
)
}
else
{
fmt
:
:
write
(
&
mut
writer
*
record
.
args
(
)
)
}
;
writer
.
flush
(
)
;
}
fn
flush
(
&
self
)
{
}
}
impl
AndroidLogger
{
fn
fill_tag_bytes
(
&
self
array
:
&
mut
[
u8
]
tag
:
&
[
u8
]
)
{
if
tag
.
len
(
)
>
LOGGING_TAG_MAX_LEN
{
for
(
input
output
)
in
tag
.
iter
(
)
.
take
(
LOGGING_TAG_MAX_LEN
-
2
)
.
chain
(
b
"
.
.
\
0
"
.
iter
(
)
)
.
zip
(
array
.
iter_mut
(
)
)
{
*
output
=
*
input
;
}
}
else
{
for
(
input
output
)
in
tag
.
iter
(
)
.
chain
(
b
"
\
0
"
.
iter
(
)
)
.
zip
(
array
.
iter_mut
(
)
)
{
*
output
=
*
input
;
}
}
}
}
pub
struct
Config
{
log_level
:
Option
<
Level
>
filter
:
Option
<
env_logger
:
:
filter
:
:
Filter
>
tag
:
Option
<
CString
>
}
impl
Default
for
Config
{
fn
default
(
)
-
>
Self
{
Config
{
log_level
:
None
filter
:
None
tag
:
None
}
}
}
impl
Config
{
pub
fn
with_min_level
(
mut
self
level
:
Level
)
-
>
Self
{
self
.
log_level
=
Some
(
level
)
;
self
}
fn
filter_matches
(
&
self
record
:
&
Record
)
-
>
bool
{
if
let
Some
(
ref
filter
)
=
self
.
filter
{
filter
.
matches
(
&
record
)
}
else
{
true
}
}
pub
fn
with_filter
(
mut
self
filter
:
env_logger
:
:
filter
:
:
Filter
)
-
>
Self
{
self
.
filter
=
Some
(
filter
)
;
self
}
pub
fn
with_tag
<
S
:
Into
<
Vec
<
u8
>
>
>
(
mut
self
tag
:
S
)
-
>
Self
{
self
.
tag
=
Some
(
CString
:
:
new
(
tag
)
.
expect
(
"
Can
'
t
convert
tag
to
CString
"
)
)
;
self
}
}
struct
PlatformLogWriter
<
'
a
>
{
#
[
cfg
(
target_os
=
"
android
"
)
]
priority
:
LogPriority
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
priority
:
Level
len
:
usize
last_newline_index
:
usize
tag
:
&
'
a
CStr
buffer
:
[
u8
;
LOGGING_MSG_MAX_LEN
+
1
]
}
impl
<
'
a
>
PlatformLogWriter
<
'
a
>
{
#
[
cfg
(
target_os
=
"
android
"
)
]
pub
fn
new
(
level
:
Level
tag
:
&
CStr
)
-
>
PlatformLogWriter
{
PlatformLogWriter
{
priority
:
match
level
{
Level
:
:
Warn
=
>
LogPriority
:
:
WARN
Level
:
:
Info
=
>
LogPriority
:
:
INFO
Level
:
:
Debug
=
>
LogPriority
:
:
DEBUG
Level
:
:
Error
=
>
LogPriority
:
:
ERROR
Level
:
:
Trace
=
>
LogPriority
:
:
VERBOSE
}
len
:
0
last_newline_index
:
0
tag
buffer
:
unsafe
{
mem
:
:
uninitialized
(
)
}
}
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
pub
fn
new
(
level
:
Level
tag
:
&
CStr
)
-
>
PlatformLogWriter
{
PlatformLogWriter
{
priority
:
level
len
:
0
last_newline_index
:
0
tag
buffer
:
unsafe
{
mem
:
:
uninitialized
(
)
}
}
}
fn
temporal_flush
(
&
mut
self
)
{
let
total_len
=
self
.
len
;
if
total_len
=
=
0
{
return
;
}
if
self
.
last_newline_index
>
0
{
let
copy_from_index
=
self
.
last_newline_index
;
let
remaining_chunk_len
=
total_len
-
copy_from_index
;
self
.
output_specified_len
(
copy_from_index
)
;
self
.
copy_bytes_to_start
(
copy_from_index
remaining_chunk_len
)
;
self
.
len
=
remaining_chunk_len
;
}
else
{
self
.
output_specified_len
(
total_len
)
;
self
.
len
=
0
;
}
self
.
last_newline_index
=
0
;
}
fn
flush
(
&
mut
self
)
{
let
total_len
=
self
.
len
;
if
total_len
=
=
0
{
return
;
}
self
.
output_specified_len
(
total_len
)
;
self
.
len
=
0
;
self
.
last_newline_index
=
0
;
}
fn
output_specified_len
(
&
mut
self
len
:
usize
)
{
let
mut
last_byte
:
u8
=
b
'
\
0
'
;
mem
:
:
swap
(
&
mut
last_byte
unsafe
{
self
.
buffer
.
get_unchecked_mut
(
len
)
}
)
;
let
msg
:
&
CStr
=
unsafe
{
CStr
:
:
from_ptr
(
mem
:
:
transmute
(
self
.
buffer
.
as_ptr
(
)
)
)
}
;
android_log
(
self
.
priority
self
.
tag
msg
)
;
*
unsafe
{
self
.
buffer
.
get_unchecked_mut
(
len
)
}
=
last_byte
;
}
fn
copy_bytes_to_start
(
&
mut
self
index
:
usize
len
:
usize
)
{
let
src
=
unsafe
{
self
.
buffer
.
as_ptr
(
)
.
offset
(
index
as
isize
)
}
;
let
dst
=
self
.
buffer
.
as_mut_ptr
(
)
;
unsafe
{
ptr
:
:
copy
(
src
dst
len
)
}
;
}
}
impl
<
'
a
>
fmt
:
:
Write
for
PlatformLogWriter
<
'
a
>
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
fmt
:
:
Result
{
let
mut
incomming_bytes
=
s
.
as_bytes
(
)
;
while
!
incomming_bytes
.
is_empty
(
)
{
let
len
=
self
.
len
;
let
new_len
=
len
+
incomming_bytes
.
len
(
)
;
let
last_newline
=
self
.
buffer
[
len
.
.
LOGGING_MSG_MAX_LEN
]
.
iter_mut
(
)
.
zip
(
incomming_bytes
)
.
enumerate
(
)
.
fold
(
None
|
acc
(
i
(
output
input
)
)
|
{
*
output
=
*
input
;
if
*
input
=
=
b
'
\
n
'
{
Some
(
i
)
}
else
{
acc
}
}
)
;
if
let
Some
(
newline
)
=
last_newline
{
self
.
last_newline_index
=
len
+
newline
;
}
let
written_len
=
if
new_len
<
=
LOGGING_MSG_MAX_LEN
{
self
.
len
=
new_len
;
new_len
-
len
}
else
{
self
.
len
=
LOGGING_MSG_MAX_LEN
;
self
.
temporal_flush
(
)
;
LOGGING_MSG_MAX_LEN
-
len
}
;
incomming_bytes
=
&
incomming_bytes
[
written_len
.
.
]
;
}
Ok
(
(
)
)
}
}
pub
fn
log
(
record
:
&
Record
)
{
ANDROID_LOGGER
.
log
(
record
)
}
pub
fn
init_once
(
config
:
Config
)
{
if
let
Err
(
err
)
=
log
:
:
set_logger
(
&
*
ANDROID_LOGGER
)
{
debug
!
(
"
android_logger
:
log
:
:
set_logger
failed
:
{
}
"
err
)
;
}
else
{
if
let
Some
(
level
)
=
config
.
log_level
{
log
:
:
set_max_level
(
level
.
to_level_filter
(
)
)
;
}
*
ANDROID_LOGGER
.
config
.
write
(
)
.
expect
(
"
failed
to
acquire
android_log
filter
lock
for
write
"
)
=
config
;
}
}
