use
super
:
:
{
Enter
Executor
SpawnError
}
;
use
futures
:
:
{
future
Future
}
;
use
std
:
:
cell
:
:
Cell
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
DefaultExecutor
{
_dummy
:
(
)
}
impl
DefaultExecutor
{
pub
fn
current
(
)
-
>
DefaultExecutor
{
DefaultExecutor
{
_dummy
:
(
)
}
}
#
[
inline
]
fn
with_current
<
F
:
FnOnce
(
&
mut
Executor
)
-
>
R
R
>
(
f
:
F
)
-
>
Option
<
R
>
{
EXECUTOR
.
with
(
|
current_executor
|
match
current_executor
.
replace
(
State
:
:
Active
)
{
State
:
:
Ready
(
executor_ptr
)
=
>
{
let
executor
=
unsafe
{
&
mut
*
executor_ptr
}
;
let
result
=
f
(
executor
)
;
current_executor
.
set
(
State
:
:
Ready
(
executor_ptr
)
)
;
Some
(
result
)
}
State
:
:
Empty
|
State
:
:
Active
=
>
None
}
)
}
}
#
[
derive
(
Clone
Copy
)
]
enum
State
{
Empty
Ready
(
*
mut
Executor
)
Active
}
thread_local
!
{
/
/
/
Thread
-
local
tracking
the
current
executor
static
EXECUTOR
:
Cell
<
State
>
=
Cell
:
:
new
(
State
:
:
Empty
)
}
impl
super
:
:
Executor
for
DefaultExecutor
{
fn
spawn
(
&
mut
self
future
:
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
>
)
-
>
Result
<
(
)
SpawnError
>
{
DefaultExecutor
:
:
with_current
(
|
executor
|
executor
.
spawn
(
future
)
)
.
unwrap_or_else
(
|
|
Err
(
SpawnError
:
:
shutdown
(
)
)
)
}
fn
status
(
&
self
)
-
>
Result
<
(
)
SpawnError
>
{
DefaultExecutor
:
:
with_current
(
|
executor
|
executor
.
status
(
)
)
.
unwrap_or_else
(
|
|
Err
(
SpawnError
:
:
shutdown
(
)
)
)
}
}
impl
<
T
>
super
:
:
TypedExecutor
<
T
>
for
DefaultExecutor
where
T
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
fn
spawn
(
&
mut
self
future
:
T
)
-
>
Result
<
(
)
SpawnError
>
{
super
:
:
Executor
:
:
spawn
(
self
Box
:
:
new
(
future
)
)
}
fn
status
(
&
self
)
-
>
Result
<
(
)
SpawnError
>
{
super
:
:
Executor
:
:
status
(
self
)
}
}
impl
<
T
>
future
:
:
Executor
<
T
>
for
DefaultExecutor
where
T
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
fn
execute
(
&
self
future
:
T
)
-
>
Result
<
(
)
future
:
:
ExecuteError
<
T
>
>
{
if
let
Err
(
e
)
=
super
:
:
Executor
:
:
status
(
self
)
{
let
kind
=
if
e
.
is_at_capacity
(
)
{
future
:
:
ExecuteErrorKind
:
:
NoCapacity
}
else
{
future
:
:
ExecuteErrorKind
:
:
Shutdown
}
;
return
Err
(
future
:
:
ExecuteError
:
:
new
(
kind
future
)
)
;
}
let
_
=
DefaultExecutor
:
:
with_current
(
|
executor
|
executor
.
spawn
(
Box
:
:
new
(
future
)
)
)
;
Ok
(
(
)
)
}
}
pub
fn
spawn
<
T
>
(
future
:
T
)
where
T
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
DefaultExecutor
:
:
current
(
)
.
spawn
(
Box
:
:
new
(
future
)
)
.
unwrap
(
)
}
pub
fn
with_default
<
T
F
R
>
(
executor
:
&
mut
T
enter
:
&
mut
Enter
f
:
F
)
-
>
R
where
T
:
Executor
F
:
FnOnce
(
&
mut
Enter
)
-
>
R
{
EXECUTOR
.
with
(
|
cell
|
{
match
cell
.
get
(
)
{
State
:
:
Ready
(
_
)
|
State
:
:
Active
=
>
{
panic
!
(
"
default
executor
already
set
for
execution
context
"
)
}
_
=
>
{
}
}
struct
Reset
<
'
a
>
(
&
'
a
Cell
<
State
>
)
;
impl
<
'
a
>
Drop
for
Reset
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
self
.
0
.
set
(
State
:
:
Empty
)
;
}
}
let
_reset
=
Reset
(
cell
)
;
let
executor
=
unsafe
{
hide_lt
(
executor
as
&
mut
_
as
*
mut
_
)
}
;
cell
.
set
(
State
:
:
Ready
(
executor
)
)
;
f
(
enter
)
}
)
}
unsafe
fn
hide_lt
<
'
a
>
(
p
:
*
mut
(
Executor
+
'
a
)
)
-
>
*
mut
(
Executor
+
'
static
)
{
use
std
:
:
mem
;
mem
:
:
transmute
(
p
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
with_default
DefaultExecutor
Executor
}
;
#
[
test
]
fn
default_executor_is_send_and_sync
(
)
{
fn
assert_send_sync
<
T
:
Send
+
Sync
>
(
)
{
}
assert_send_sync
:
:
<
DefaultExecutor
>
(
)
;
}
#
[
test
]
fn
nested_default_executor_status
(
)
{
let
mut
enter
=
super
:
:
super
:
:
enter
(
)
.
unwrap
(
)
;
let
mut
executor
=
DefaultExecutor
:
:
current
(
)
;
let
result
=
with_default
(
&
mut
executor
&
mut
enter
|
_
|
{
DefaultExecutor
:
:
current
(
)
.
status
(
)
}
)
;
assert
!
(
result
.
err
(
)
.
unwrap
(
)
.
is_shutdown
(
)
)
}
}
