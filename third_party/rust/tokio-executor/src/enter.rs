use
std
:
:
cell
:
:
Cell
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
;
use
std
:
:
prelude
:
:
v1
:
:
*
;
use
futures
:
:
{
self
Future
}
;
thread_local
!
(
static
ENTERED
:
Cell
<
bool
>
=
Cell
:
:
new
(
false
)
)
;
pub
struct
Enter
{
on_exit
:
Vec
<
Box
<
Callback
>
>
permanent
:
bool
}
pub
struct
EnterError
{
_a
:
(
)
}
impl
fmt
:
:
Debug
for
EnterError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
EnterError
"
)
.
field
(
"
reason
"
&
self
.
description
(
)
)
.
finish
(
)
}
}
impl
fmt
:
:
Display
for
EnterError
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
{
}
"
self
.
description
(
)
)
}
}
impl
Error
for
EnterError
{
fn
description
(
&
self
)
-
>
&
str
{
"
attempted
to
run
an
executor
while
another
executor
is
already
running
"
}
}
pub
fn
enter
(
)
-
>
Result
<
Enter
EnterError
>
{
ENTERED
.
with
(
|
c
|
{
if
c
.
get
(
)
{
Err
(
EnterError
{
_a
:
(
)
}
)
}
else
{
c
.
set
(
true
)
;
Ok
(
Enter
{
on_exit
:
Vec
:
:
new
(
)
permanent
:
false
}
)
}
}
)
}
impl
Enter
{
pub
fn
on_exit
<
F
>
(
&
mut
self
f
:
F
)
where
F
:
FnOnce
(
)
+
'
static
{
self
.
on_exit
.
push
(
Box
:
:
new
(
f
)
)
;
}
pub
fn
make_permanent
(
mut
self
)
{
self
.
permanent
=
true
;
}
pub
fn
block_on
<
F
:
Future
>
(
&
mut
self
f
:
F
)
-
>
Result
<
F
:
:
Item
F
:
:
Error
>
{
futures
:
:
executor
:
:
spawn
(
f
)
.
wait_future
(
)
}
}
impl
fmt
:
:
Debug
for
Enter
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Enter
"
)
.
finish
(
)
}
}
impl
Drop
for
Enter
{
fn
drop
(
&
mut
self
)
{
ENTERED
.
with
(
|
c
|
{
assert
!
(
c
.
get
(
)
)
;
if
self
.
permanent
{
return
;
}
for
callback
in
self
.
on_exit
.
drain
(
.
.
)
{
callback
.
call
(
)
;
}
c
.
set
(
false
)
;
}
)
;
}
}
trait
Callback
:
'
static
{
fn
call
(
self
:
Box
<
Self
>
)
;
}
impl
<
F
:
FnOnce
(
)
+
'
static
>
Callback
for
F
{
fn
call
(
self
:
Box
<
Self
>
)
{
(
*
self
)
(
)
}
}
