use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
time
:
:
Duration
;
use
crossbeam_utils
:
:
sync
:
:
{
Parker
Unparker
}
;
pub
trait
Park
{
type
Unpark
:
Unpark
;
type
Error
;
fn
unpark
(
&
self
)
-
>
Self
:
:
Unpark
;
fn
park
(
&
mut
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
fn
park_timeout
(
&
mut
self
duration
:
Duration
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
}
pub
trait
Unpark
:
Sync
+
Send
+
'
static
{
fn
unpark
(
&
self
)
;
}
impl
Unpark
for
Box
<
Unpark
>
{
fn
unpark
(
&
self
)
{
(
*
*
self
)
.
unpark
(
)
}
}
impl
Unpark
for
Arc
<
Unpark
>
{
fn
unpark
(
&
self
)
{
(
*
*
self
)
.
unpark
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ParkThread
{
_anchor
:
PhantomData
<
Rc
<
(
)
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
ParkError
{
_p
:
(
)
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
UnparkThread
{
inner
:
Unparker
}
thread_local
!
{
static
CURRENT_PARKER
:
Parker
=
Parker
:
:
new
(
)
;
}
impl
ParkThread
{
pub
fn
new
(
)
-
>
ParkThread
{
ParkThread
{
_anchor
:
PhantomData
}
}
fn
with_current
<
F
R
>
(
&
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
Parker
)
-
>
R
{
CURRENT_PARKER
.
with
(
|
inner
|
f
(
inner
)
)
}
}
impl
Park
for
ParkThread
{
type
Unpark
=
UnparkThread
;
type
Error
=
ParkError
;
fn
unpark
(
&
self
)
-
>
Self
:
:
Unpark
{
let
inner
=
self
.
with_current
(
|
inner
|
inner
.
unparker
(
)
.
clone
(
)
)
;
UnparkThread
{
inner
}
}
fn
park
(
&
mut
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
with_current
(
|
inner
|
inner
.
park
(
)
)
;
Ok
(
(
)
)
}
fn
park_timeout
(
&
mut
self
duration
:
Duration
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
with_current
(
|
inner
|
inner
.
park_timeout
(
duration
)
)
;
Ok
(
(
)
)
}
}
impl
Unpark
for
UnparkThread
{
fn
unpark
(
&
self
)
{
self
.
inner
.
unpark
(
)
;
}
}
