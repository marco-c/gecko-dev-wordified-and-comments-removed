use
std
:
:
isize
;
use
std
:
:
ops
;
use
std
:
:
process
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
AtomicUsize
Ordering
}
;
struct
Counter
<
C
>
{
senders
:
AtomicUsize
receivers
:
AtomicUsize
disconnected
:
AtomicBool
chan
:
C
}
pub
fn
new
<
C
>
(
chan
:
C
)
-
>
(
Sender
<
C
>
Receiver
<
C
>
)
{
let
counter
=
Box
:
:
into_raw
(
Box
:
:
new
(
Counter
{
senders
:
AtomicUsize
:
:
new
(
1
)
receivers
:
AtomicUsize
:
:
new
(
1
)
disconnected
:
AtomicBool
:
:
new
(
false
)
chan
}
)
)
;
let
s
=
Sender
{
counter
}
;
let
r
=
Receiver
{
counter
}
;
(
s
r
)
}
pub
struct
Sender
<
C
>
{
counter
:
*
mut
Counter
<
C
>
}
impl
<
C
>
Sender
<
C
>
{
fn
counter
(
&
self
)
-
>
&
Counter
<
C
>
{
unsafe
{
&
*
self
.
counter
}
}
pub
fn
acquire
(
&
self
)
-
>
Sender
<
C
>
{
let
count
=
self
.
counter
(
)
.
senders
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
if
count
>
isize
:
:
MAX
as
usize
{
process
:
:
abort
(
)
;
}
Sender
{
counter
:
self
.
counter
}
}
pub
unsafe
fn
release
<
F
:
FnOnce
(
&
C
)
>
(
&
self
f
:
F
)
{
if
self
.
counter
(
)
.
senders
.
fetch_sub
(
1
Ordering
:
:
AcqRel
)
=
=
1
{
f
(
&
self
.
counter
(
)
.
chan
)
;
if
self
.
counter
(
)
.
disconnected
.
swap
(
true
Ordering
:
:
AcqRel
)
{
drop
(
Box
:
:
from_raw
(
self
.
counter
)
)
;
}
}
}
}
impl
<
C
>
ops
:
:
Deref
for
Sender
<
C
>
{
type
Target
=
C
;
fn
deref
(
&
self
)
-
>
&
C
{
&
self
.
counter
(
)
.
chan
}
}
pub
struct
Receiver
<
C
>
{
counter
:
*
mut
Counter
<
C
>
}
impl
<
C
>
Receiver
<
C
>
{
fn
counter
(
&
self
)
-
>
&
Counter
<
C
>
{
unsafe
{
&
*
self
.
counter
}
}
pub
fn
acquire
(
&
self
)
-
>
Receiver
<
C
>
{
let
count
=
self
.
counter
(
)
.
receivers
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
if
count
>
isize
:
:
MAX
as
usize
{
process
:
:
abort
(
)
;
}
Receiver
{
counter
:
self
.
counter
}
}
pub
unsafe
fn
release
<
F
:
FnOnce
(
&
C
)
>
(
&
self
f
:
F
)
{
if
self
.
counter
(
)
.
receivers
.
fetch_sub
(
1
Ordering
:
:
AcqRel
)
=
=
1
{
f
(
&
self
.
counter
(
)
.
chan
)
;
if
self
.
counter
(
)
.
disconnected
.
swap
(
true
Ordering
:
:
AcqRel
)
{
drop
(
Box
:
:
from_raw
(
self
.
counter
)
)
;
}
}
}
}
impl
<
C
>
ops
:
:
Deref
for
Receiver
<
C
>
{
type
Target
=
C
;
fn
deref
(
&
self
)
-
>
&
C
{
&
self
.
counter
(
)
.
chan
}
}
