use
std
:
:
ptr
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
std
:
:
thread
:
:
{
self
ThreadId
}
;
use
crate
:
:
context
:
:
Context
;
use
crate
:
:
select
:
:
{
Operation
Selected
}
;
use
crate
:
:
utils
:
:
Spinlock
;
pub
(
crate
)
struct
Entry
{
pub
(
crate
)
oper
:
Operation
pub
(
crate
)
packet
:
*
mut
(
)
pub
(
crate
)
cx
:
Context
}
pub
(
crate
)
struct
Waker
{
selectors
:
Vec
<
Entry
>
observers
:
Vec
<
Entry
>
}
impl
Waker
{
#
[
inline
]
pub
(
crate
)
fn
new
(
)
-
>
Self
{
Waker
{
selectors
:
Vec
:
:
new
(
)
observers
:
Vec
:
:
new
(
)
}
}
#
[
inline
]
pub
(
crate
)
fn
register
(
&
mut
self
oper
:
Operation
cx
:
&
Context
)
{
self
.
register_with_packet
(
oper
ptr
:
:
null_mut
(
)
cx
)
;
}
#
[
inline
]
pub
(
crate
)
fn
register_with_packet
(
&
mut
self
oper
:
Operation
packet
:
*
mut
(
)
cx
:
&
Context
)
{
self
.
selectors
.
push
(
Entry
{
oper
packet
cx
:
cx
.
clone
(
)
}
)
;
}
#
[
inline
]
pub
(
crate
)
fn
unregister
(
&
mut
self
oper
:
Operation
)
-
>
Option
<
Entry
>
{
if
let
Some
(
(
i
_
)
)
=
self
.
selectors
.
iter
(
)
.
enumerate
(
)
.
find
(
|
&
(
_
entry
)
|
entry
.
oper
=
=
oper
)
{
let
entry
=
self
.
selectors
.
remove
(
i
)
;
Some
(
entry
)
}
else
{
None
}
}
#
[
inline
]
pub
(
crate
)
fn
try_select
(
&
mut
self
)
-
>
Option
<
Entry
>
{
if
self
.
selectors
.
is_empty
(
)
{
None
}
else
{
let
thread_id
=
current_thread_id
(
)
;
self
.
selectors
.
iter
(
)
.
position
(
|
selector
|
{
selector
.
cx
.
thread_id
(
)
!
=
thread_id
&
&
selector
.
cx
.
try_select
(
Selected
:
:
Operation
(
selector
.
oper
)
)
.
is_ok
(
)
&
&
{
selector
.
cx
.
store_packet
(
selector
.
packet
)
;
selector
.
cx
.
unpark
(
)
;
true
}
}
)
.
map
(
|
pos
|
self
.
selectors
.
remove
(
pos
)
)
}
}
#
[
inline
]
pub
(
crate
)
fn
can_select
(
&
self
)
-
>
bool
{
if
self
.
selectors
.
is_empty
(
)
{
false
}
else
{
let
thread_id
=
current_thread_id
(
)
;
self
.
selectors
.
iter
(
)
.
any
(
|
entry
|
{
entry
.
cx
.
thread_id
(
)
!
=
thread_id
&
&
entry
.
cx
.
selected
(
)
=
=
Selected
:
:
Waiting
}
)
}
}
#
[
inline
]
pub
(
crate
)
fn
watch
(
&
mut
self
oper
:
Operation
cx
:
&
Context
)
{
self
.
observers
.
push
(
Entry
{
oper
packet
:
ptr
:
:
null_mut
(
)
cx
:
cx
.
clone
(
)
}
)
;
}
#
[
inline
]
pub
(
crate
)
fn
unwatch
(
&
mut
self
oper
:
Operation
)
{
self
.
observers
.
retain
(
|
e
|
e
.
oper
!
=
oper
)
;
}
#
[
inline
]
pub
(
crate
)
fn
notify
(
&
mut
self
)
{
for
entry
in
self
.
observers
.
drain
(
.
.
)
{
if
entry
.
cx
.
try_select
(
Selected
:
:
Operation
(
entry
.
oper
)
)
.
is_ok
(
)
{
entry
.
cx
.
unpark
(
)
;
}
}
}
#
[
inline
]
pub
(
crate
)
fn
disconnect
(
&
mut
self
)
{
for
entry
in
self
.
selectors
.
iter
(
)
{
if
entry
.
cx
.
try_select
(
Selected
:
:
Disconnected
)
.
is_ok
(
)
{
entry
.
cx
.
unpark
(
)
;
}
}
self
.
notify
(
)
;
}
}
impl
Drop
for
Waker
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
debug_assert_eq
!
(
self
.
selectors
.
len
(
)
0
)
;
debug_assert_eq
!
(
self
.
observers
.
len
(
)
0
)
;
}
}
pub
(
crate
)
struct
SyncWaker
{
inner
:
Spinlock
<
Waker
>
is_empty
:
AtomicBool
}
impl
SyncWaker
{
#
[
inline
]
pub
(
crate
)
fn
new
(
)
-
>
Self
{
SyncWaker
{
inner
:
Spinlock
:
:
new
(
Waker
:
:
new
(
)
)
is_empty
:
AtomicBool
:
:
new
(
true
)
}
}
#
[
inline
]
pub
(
crate
)
fn
register
(
&
self
oper
:
Operation
cx
:
&
Context
)
{
let
mut
inner
=
self
.
inner
.
lock
(
)
;
inner
.
register
(
oper
cx
)
;
self
.
is_empty
.
store
(
inner
.
selectors
.
is_empty
(
)
&
&
inner
.
observers
.
is_empty
(
)
Ordering
:
:
SeqCst
)
;
}
#
[
inline
]
pub
(
crate
)
fn
unregister
(
&
self
oper
:
Operation
)
-
>
Option
<
Entry
>
{
let
mut
inner
=
self
.
inner
.
lock
(
)
;
let
entry
=
inner
.
unregister
(
oper
)
;
self
.
is_empty
.
store
(
inner
.
selectors
.
is_empty
(
)
&
&
inner
.
observers
.
is_empty
(
)
Ordering
:
:
SeqCst
)
;
entry
}
#
[
inline
]
pub
(
crate
)
fn
notify
(
&
self
)
{
if
!
self
.
is_empty
.
load
(
Ordering
:
:
SeqCst
)
{
let
mut
inner
=
self
.
inner
.
lock
(
)
;
if
!
self
.
is_empty
.
load
(
Ordering
:
:
SeqCst
)
{
inner
.
try_select
(
)
;
inner
.
notify
(
)
;
self
.
is_empty
.
store
(
inner
.
selectors
.
is_empty
(
)
&
&
inner
.
observers
.
is_empty
(
)
Ordering
:
:
SeqCst
)
;
}
}
}
#
[
inline
]
pub
(
crate
)
fn
watch
(
&
self
oper
:
Operation
cx
:
&
Context
)
{
let
mut
inner
=
self
.
inner
.
lock
(
)
;
inner
.
watch
(
oper
cx
)
;
self
.
is_empty
.
store
(
inner
.
selectors
.
is_empty
(
)
&
&
inner
.
observers
.
is_empty
(
)
Ordering
:
:
SeqCst
)
;
}
#
[
inline
]
pub
(
crate
)
fn
unwatch
(
&
self
oper
:
Operation
)
{
let
mut
inner
=
self
.
inner
.
lock
(
)
;
inner
.
unwatch
(
oper
)
;
self
.
is_empty
.
store
(
inner
.
selectors
.
is_empty
(
)
&
&
inner
.
observers
.
is_empty
(
)
Ordering
:
:
SeqCst
)
;
}
#
[
inline
]
pub
(
crate
)
fn
disconnect
(
&
self
)
{
let
mut
inner
=
self
.
inner
.
lock
(
)
;
inner
.
disconnect
(
)
;
self
.
is_empty
.
store
(
inner
.
selectors
.
is_empty
(
)
&
&
inner
.
observers
.
is_empty
(
)
Ordering
:
:
SeqCst
)
;
}
}
impl
Drop
for
SyncWaker
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
debug_assert
!
(
self
.
is_empty
.
load
(
Ordering
:
:
SeqCst
)
)
;
}
}
#
[
inline
]
fn
current_thread_id
(
)
-
>
ThreadId
{
thread_local
!
{
/
/
/
Cached
thread
-
local
id
.
static
THREAD_ID
:
ThreadId
=
thread
:
:
current
(
)
.
id
(
)
;
}
THREAD_ID
.
try_with
(
|
id
|
*
id
)
.
unwrap_or_else
(
|
_
|
thread
:
:
current
(
)
.
id
(
)
)
}
