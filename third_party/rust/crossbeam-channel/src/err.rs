use
std
:
:
error
;
use
std
:
:
fmt
;
#
[
derive
(
PartialEq
Eq
Clone
Copy
)
]
pub
struct
SendError
<
T
>
(
pub
T
)
;
#
[
derive
(
PartialEq
Eq
Clone
Copy
)
]
pub
enum
TrySendError
<
T
>
{
Full
(
T
)
Disconnected
(
T
)
}
#
[
derive
(
PartialEq
Eq
Clone
Copy
)
]
pub
enum
SendTimeoutError
<
T
>
{
Timeout
(
T
)
Disconnected
(
T
)
}
#
[
derive
(
PartialEq
Eq
Clone
Copy
Debug
)
]
pub
struct
RecvError
;
#
[
derive
(
PartialEq
Eq
Clone
Copy
Debug
)
]
pub
enum
TryRecvError
{
Empty
Disconnected
}
#
[
derive
(
PartialEq
Eq
Clone
Copy
Debug
)
]
pub
enum
RecvTimeoutError
{
Timeout
Disconnected
}
#
[
derive
(
PartialEq
Eq
Clone
Copy
Debug
)
]
pub
struct
TrySelectError
;
#
[
derive
(
PartialEq
Eq
Clone
Copy
Debug
)
]
pub
struct
SelectTimeoutError
;
#
[
derive
(
PartialEq
Eq
Clone
Copy
Debug
)
]
pub
struct
TryReadyError
;
#
[
derive
(
PartialEq
Eq
Clone
Copy
Debug
)
]
pub
struct
ReadyTimeoutError
;
impl
<
T
>
fmt
:
:
Debug
for
SendError
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
"
SendError
(
.
.
)
"
.
fmt
(
f
)
}
}
impl
<
T
>
fmt
:
:
Display
for
SendError
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
"
sending
on
a
disconnected
channel
"
.
fmt
(
f
)
}
}
impl
<
T
:
Send
>
error
:
:
Error
for
SendError
<
T
>
{
fn
description
(
&
self
)
-
>
&
str
{
"
sending
on
a
disconnected
channel
"
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
None
}
}
impl
<
T
>
SendError
<
T
>
{
pub
fn
into_inner
(
self
)
-
>
T
{
self
.
0
}
}
impl
<
T
>
fmt
:
:
Debug
for
TrySendError
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
TrySendError
:
:
Full
(
.
.
)
=
>
"
Full
(
.
.
)
"
.
fmt
(
f
)
TrySendError
:
:
Disconnected
(
.
.
)
=
>
"
Disconnected
(
.
.
)
"
.
fmt
(
f
)
}
}
}
impl
<
T
>
fmt
:
:
Display
for
TrySendError
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
TrySendError
:
:
Full
(
.
.
)
=
>
"
sending
on
a
full
channel
"
.
fmt
(
f
)
TrySendError
:
:
Disconnected
(
.
.
)
=
>
"
sending
on
a
disconnected
channel
"
.
fmt
(
f
)
}
}
}
impl
<
T
:
Send
>
error
:
:
Error
for
TrySendError
<
T
>
{
fn
description
(
&
self
)
-
>
&
str
{
match
*
self
{
TrySendError
:
:
Full
(
.
.
)
=
>
"
sending
on
a
full
channel
"
TrySendError
:
:
Disconnected
(
.
.
)
=
>
"
sending
on
a
disconnected
channel
"
}
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
None
}
}
impl
<
T
>
From
<
SendError
<
T
>
>
for
TrySendError
<
T
>
{
fn
from
(
err
:
SendError
<
T
>
)
-
>
TrySendError
<
T
>
{
match
err
{
SendError
(
t
)
=
>
TrySendError
:
:
Disconnected
(
t
)
}
}
}
impl
<
T
>
TrySendError
<
T
>
{
pub
fn
into_inner
(
self
)
-
>
T
{
match
self
{
TrySendError
:
:
Full
(
v
)
=
>
v
TrySendError
:
:
Disconnected
(
v
)
=
>
v
}
}
pub
fn
is_full
(
&
self
)
-
>
bool
{
match
self
{
TrySendError
:
:
Full
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
is_disconnected
(
&
self
)
-
>
bool
{
match
self
{
TrySendError
:
:
Disconnected
(
_
)
=
>
true
_
=
>
false
}
}
}
impl
<
T
>
fmt
:
:
Debug
for
SendTimeoutError
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
"
SendTimeoutError
(
.
.
)
"
.
fmt
(
f
)
}
}
impl
<
T
>
fmt
:
:
Display
for
SendTimeoutError
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
SendTimeoutError
:
:
Timeout
(
.
.
)
=
>
"
timed
out
waiting
on
send
operation
"
.
fmt
(
f
)
SendTimeoutError
:
:
Disconnected
(
.
.
)
=
>
"
sending
on
a
disconnected
channel
"
.
fmt
(
f
)
}
}
}
impl
<
T
:
Send
>
error
:
:
Error
for
SendTimeoutError
<
T
>
{
fn
description
(
&
self
)
-
>
&
str
{
"
sending
on
an
empty
and
disconnected
channel
"
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
None
}
}
impl
<
T
>
From
<
SendError
<
T
>
>
for
SendTimeoutError
<
T
>
{
fn
from
(
err
:
SendError
<
T
>
)
-
>
SendTimeoutError
<
T
>
{
match
err
{
SendError
(
e
)
=
>
SendTimeoutError
:
:
Disconnected
(
e
)
}
}
}
impl
<
T
>
SendTimeoutError
<
T
>
{
pub
fn
into_inner
(
self
)
-
>
T
{
match
self
{
SendTimeoutError
:
:
Timeout
(
v
)
=
>
v
SendTimeoutError
:
:
Disconnected
(
v
)
=
>
v
}
}
pub
fn
is_timeout
(
&
self
)
-
>
bool
{
match
self
{
SendTimeoutError
:
:
Timeout
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
is_disconnected
(
&
self
)
-
>
bool
{
match
self
{
SendTimeoutError
:
:
Disconnected
(
_
)
=
>
true
_
=
>
false
}
}
}
impl
fmt
:
:
Display
for
RecvError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
"
receiving
on
an
empty
and
disconnected
channel
"
.
fmt
(
f
)
}
}
impl
error
:
:
Error
for
RecvError
{
fn
description
(
&
self
)
-
>
&
str
{
"
receiving
on
an
empty
and
disconnected
channel
"
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
None
}
}
impl
fmt
:
:
Display
for
TryRecvError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
TryRecvError
:
:
Empty
=
>
"
receiving
on
an
empty
channel
"
.
fmt
(
f
)
TryRecvError
:
:
Disconnected
=
>
"
receiving
on
an
empty
and
disconnected
channel
"
.
fmt
(
f
)
}
}
}
impl
error
:
:
Error
for
TryRecvError
{
fn
description
(
&
self
)
-
>
&
str
{
match
*
self
{
TryRecvError
:
:
Empty
=
>
"
receiving
on
an
empty
channel
"
TryRecvError
:
:
Disconnected
=
>
"
receiving
on
an
empty
and
disconnected
channel
"
}
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
None
}
}
impl
From
<
RecvError
>
for
TryRecvError
{
fn
from
(
err
:
RecvError
)
-
>
TryRecvError
{
match
err
{
RecvError
=
>
TryRecvError
:
:
Disconnected
}
}
}
impl
TryRecvError
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
match
self
{
TryRecvError
:
:
Empty
=
>
true
_
=
>
false
}
}
pub
fn
is_disconnected
(
&
self
)
-
>
bool
{
match
self
{
TryRecvError
:
:
Disconnected
=
>
true
_
=
>
false
}
}
}
impl
fmt
:
:
Display
for
RecvTimeoutError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
RecvTimeoutError
:
:
Timeout
=
>
"
timed
out
waiting
on
receive
operation
"
.
fmt
(
f
)
RecvTimeoutError
:
:
Disconnected
=
>
"
channel
is
empty
and
disconnected
"
.
fmt
(
f
)
}
}
}
impl
error
:
:
Error
for
RecvTimeoutError
{
fn
description
(
&
self
)
-
>
&
str
{
match
*
self
{
RecvTimeoutError
:
:
Timeout
=
>
"
timed
out
waiting
on
receive
operation
"
RecvTimeoutError
:
:
Disconnected
=
>
"
channel
is
empty
and
disconnected
"
}
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
None
}
}
impl
From
<
RecvError
>
for
RecvTimeoutError
{
fn
from
(
err
:
RecvError
)
-
>
RecvTimeoutError
{
match
err
{
RecvError
=
>
RecvTimeoutError
:
:
Disconnected
}
}
}
impl
RecvTimeoutError
{
pub
fn
is_timeout
(
&
self
)
-
>
bool
{
match
self
{
RecvTimeoutError
:
:
Timeout
=
>
true
_
=
>
false
}
}
pub
fn
is_disconnected
(
&
self
)
-
>
bool
{
match
self
{
RecvTimeoutError
:
:
Disconnected
=
>
true
_
=
>
false
}
}
}
impl
fmt
:
:
Display
for
TrySelectError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
"
all
operations
in
select
would
block
"
.
fmt
(
f
)
}
}
impl
error
:
:
Error
for
TrySelectError
{
fn
description
(
&
self
)
-
>
&
str
{
"
all
operations
in
select
would
block
"
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
None
}
}
impl
fmt
:
:
Display
for
SelectTimeoutError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
"
timed
out
waiting
on
select
"
.
fmt
(
f
)
}
}
impl
error
:
:
Error
for
SelectTimeoutError
{
fn
description
(
&
self
)
-
>
&
str
{
"
timed
out
waiting
on
select
"
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
None
}
}
