use
remove_dir_all
:
:
remove_dir_all
;
use
std
:
:
mem
;
use
std
:
:
path
:
:
{
self
Path
PathBuf
}
;
use
std
:
:
{
fmt
fs
io
}
;
use
crate
:
:
error
:
:
IoResultExt
;
use
crate
:
:
Builder
;
pub
fn
tempdir
(
)
-
>
io
:
:
Result
<
TempDir
>
{
TempDir
:
:
new
(
)
}
pub
fn
tempdir_in
<
P
:
AsRef
<
Path
>
>
(
dir
:
P
)
-
>
io
:
:
Result
<
TempDir
>
{
TempDir
:
:
new_in
(
dir
)
}
pub
struct
TempDir
{
path
:
Box
<
Path
>
}
impl
TempDir
{
pub
fn
new
(
)
-
>
io
:
:
Result
<
TempDir
>
{
Builder
:
:
new
(
)
.
tempdir
(
)
}
pub
fn
new_in
<
P
:
AsRef
<
Path
>
>
(
dir
:
P
)
-
>
io
:
:
Result
<
TempDir
>
{
Builder
:
:
new
(
)
.
tempdir_in
(
dir
)
}
pub
fn
path
(
&
self
)
-
>
&
path
:
:
Path
{
self
.
path
.
as_ref
(
)
}
pub
fn
into_path
(
self
)
-
>
PathBuf
{
let
mut
this
=
mem
:
:
ManuallyDrop
:
:
new
(
self
)
;
mem
:
:
replace
(
&
mut
this
.
path
PathBuf
:
:
new
(
)
.
into_boxed_path
(
)
)
.
into
(
)
}
pub
fn
close
(
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
let
result
=
remove_dir_all
(
self
.
path
(
)
)
.
with_err_path
(
|
|
self
.
path
(
)
)
;
self
.
path
=
PathBuf
:
:
new
(
)
.
into_boxed_path
(
)
;
mem
:
:
forget
(
self
)
;
result
}
}
impl
AsRef
<
Path
>
for
TempDir
{
fn
as_ref
(
&
self
)
-
>
&
Path
{
self
.
path
(
)
}
}
impl
fmt
:
:
Debug
for
TempDir
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
TempDir
"
)
.
field
(
"
path
"
&
self
.
path
(
)
)
.
finish
(
)
}
}
impl
Drop
for
TempDir
{
fn
drop
(
&
mut
self
)
{
let
_
=
remove_dir_all
(
self
.
path
(
)
)
;
}
}
pub
(
crate
)
fn
create
(
path
:
PathBuf
)
-
>
io
:
:
Result
<
TempDir
>
{
fs
:
:
create_dir
(
&
path
)
.
with_err_path
(
|
|
&
path
)
.
map
(
|
_
|
TempDir
{
path
:
path
.
into_boxed_path
(
)
}
)
}
