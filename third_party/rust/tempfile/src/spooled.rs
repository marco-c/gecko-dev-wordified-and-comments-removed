use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
self
Read
Write
Seek
SeekFrom
Cursor
}
;
use
file
:
:
tempfile
;
use
std
:
:
mem
:
:
drop
;
#
[
derive
(
Debug
)
]
enum
SpooledInner
{
InMemory
(
Cursor
<
Vec
<
u8
>
>
)
OnDisk
(
File
)
}
#
[
derive
(
Debug
)
]
pub
struct
SpooledTempFile
{
max_size
:
usize
inner
:
SpooledInner
}
#
[
inline
]
pub
fn
spooled_tempfile
(
max_size
:
usize
)
-
>
SpooledTempFile
{
SpooledTempFile
:
:
new
(
max_size
)
}
impl
SpooledTempFile
{
pub
fn
new
(
max_size
:
usize
)
-
>
SpooledTempFile
{
SpooledTempFile
{
max_size
:
max_size
inner
:
SpooledInner
:
:
InMemory
(
Cursor
:
:
new
(
Vec
:
:
new
(
)
)
)
}
}
pub
fn
is_rolled
(
&
self
)
-
>
bool
{
match
self
.
inner
{
SpooledInner
:
:
InMemory
(
_
)
=
>
false
SpooledInner
:
:
OnDisk
(
_
)
=
>
true
}
}
pub
fn
roll
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
if
!
self
.
is_rolled
(
)
{
let
mut
file
=
tempfile
(
)
?
;
if
let
SpooledInner
:
:
InMemory
(
ref
mut
cursor
)
=
self
.
inner
{
file
.
write
(
cursor
.
get_ref
(
)
)
?
;
file
.
seek
(
SeekFrom
:
:
Start
(
cursor
.
position
(
)
)
)
?
;
drop
(
cursor
)
;
}
self
.
inner
=
SpooledInner
:
:
OnDisk
(
file
)
;
}
Ok
(
(
)
)
}
pub
fn
set_len
(
&
mut
self
size
:
u64
)
-
>
Result
<
(
)
io
:
:
Error
>
{
if
size
as
usize
>
self
.
max_size
{
self
.
roll
(
)
?
;
}
match
self
.
inner
{
SpooledInner
:
:
InMemory
(
ref
mut
cursor
)
=
>
{
cursor
.
get_mut
(
)
.
resize
(
size
as
usize
0
)
;
Ok
(
(
)
)
}
SpooledInner
:
:
OnDisk
(
ref
mut
file
)
=
>
file
.
set_len
(
size
)
}
}
}
impl
Read
for
SpooledTempFile
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
match
self
.
inner
{
SpooledInner
:
:
InMemory
(
ref
mut
cursor
)
=
>
cursor
.
read
(
buf
)
SpooledInner
:
:
OnDisk
(
ref
mut
file
)
=
>
file
.
read
(
buf
)
}
}
}
impl
Write
for
SpooledTempFile
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
let
mut
rolling
=
false
;
if
let
SpooledInner
:
:
InMemory
(
ref
mut
cursor
)
=
self
.
inner
{
rolling
=
cursor
.
position
(
)
as
usize
+
buf
.
len
(
)
>
self
.
max_size
;
}
if
rolling
{
self
.
roll
(
)
?
;
}
match
self
.
inner
{
SpooledInner
:
:
InMemory
(
ref
mut
cursor
)
=
>
cursor
.
write
(
buf
)
SpooledInner
:
:
OnDisk
(
ref
mut
file
)
=
>
file
.
write
(
buf
)
}
}
#
[
inline
]
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
match
self
.
inner
{
SpooledInner
:
:
InMemory
(
ref
mut
cursor
)
=
>
cursor
.
flush
(
)
SpooledInner
:
:
OnDisk
(
ref
mut
file
)
=
>
file
.
flush
(
)
}
}
}
impl
Seek
for
SpooledTempFile
{
fn
seek
(
&
mut
self
pos
:
SeekFrom
)
-
>
io
:
:
Result
<
u64
>
{
match
self
.
inner
{
SpooledInner
:
:
InMemory
(
ref
mut
cursor
)
=
>
cursor
.
seek
(
pos
)
SpooledInner
:
:
OnDisk
(
ref
mut
file
)
=
>
file
.
seek
(
pos
)
}
}
}
