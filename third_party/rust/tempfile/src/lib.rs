#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
-
v2
.
png
"
html_favicon_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
docs
.
rs
/
tempfile
/
2
.
2
.
0
"
)
]
#
!
[
cfg_attr
(
test
deny
(
warnings
)
)
]
extern
crate
rand
;
extern
crate
remove_dir_all
;
#
[
cfg
(
unix
)
]
extern
crate
libc
;
#
[
cfg
(
windows
)
]
extern
crate
winapi
;
#
[
cfg
(
target_os
=
"
redox
"
)
]
extern
crate
syscall
;
const
NUM_RETRIES
:
u32
=
1
<
<
31
;
const
NUM_RAND_CHARS
:
usize
=
6
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
{
env
io
}
;
mod
dir
;
mod
file
;
mod
util
;
pub
use
dir
:
:
{
tempdir
tempdir_in
TempDir
}
;
pub
use
file
:
:
{
tempfile
tempfile_in
NamedTempFile
PersistError
TempPath
}
;
#
[
derive
(
Debug
Clone
Eq
PartialEq
)
]
pub
struct
Builder
<
'
a
'
b
>
{
random_len
:
usize
prefix
:
&
'
a
str
suffix
:
&
'
b
str
}
impl
<
'
a
'
b
>
Default
for
Builder
<
'
a
'
b
>
{
fn
default
(
)
-
>
Self
{
Builder
{
random_len
:
:
:
NUM_RAND_CHARS
prefix
:
"
.
tmp
"
suffix
:
"
"
}
}
}
impl
<
'
a
'
b
>
Builder
<
'
a
'
b
>
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
prefix
(
&
mut
self
prefix
:
&
'
a
str
)
-
>
&
mut
Self
{
self
.
prefix
=
prefix
;
self
}
pub
fn
suffix
(
&
mut
self
suffix
:
&
'
b
str
)
-
>
&
mut
Self
{
self
.
suffix
=
suffix
;
self
}
pub
fn
rand_bytes
(
&
mut
self
rand
:
usize
)
-
>
&
mut
Self
{
self
.
random_len
=
rand
;
self
}
pub
fn
tempfile
(
&
self
)
-
>
io
:
:
Result
<
NamedTempFile
>
{
self
.
tempfile_in
(
&
env
:
:
temp_dir
(
)
)
}
pub
fn
tempfile_in
<
P
:
AsRef
<
Path
>
>
(
&
self
dir
:
P
)
-
>
io
:
:
Result
<
NamedTempFile
>
{
util
:
:
create_helper
(
dir
.
as_ref
(
)
self
.
prefix
self
.
suffix
self
.
random_len
file
:
:
create_named
)
}
pub
fn
tempdir
(
&
self
)
-
>
io
:
:
Result
<
TempDir
>
{
self
.
tempdir_in
(
&
env
:
:
temp_dir
(
)
)
}
pub
fn
tempdir_in
<
P
:
AsRef
<
Path
>
>
(
&
self
dir
:
P
)
-
>
io
:
:
Result
<
TempDir
>
{
let
storage
;
let
mut
dir
=
dir
.
as_ref
(
)
;
if
!
dir
.
is_absolute
(
)
{
let
cur_dir
=
env
:
:
current_dir
(
)
?
;
storage
=
cur_dir
.
join
(
dir
)
;
dir
=
&
storage
;
}
util
:
:
create_helper
(
dir
self
.
prefix
self
.
suffix
self
.
random_len
dir
:
:
create
)
}
}
