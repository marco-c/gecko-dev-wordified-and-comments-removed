#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
-
v2
.
png
"
html_favicon_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
docs
.
rs
/
tempfile
/
3
.
1
.
0
"
)
]
#
!
[
cfg_attr
(
test
deny
(
warnings
)
)
]
#
!
[
deny
(
rust_2018_idioms
)
]
#
!
[
allow
(
clippy
:
:
redundant_field_names
)
]
#
!
[
cfg_attr
(
all
(
feature
=
"
nightly
"
target_os
=
"
wasi
"
)
feature
(
wasi_ext
)
)
]
#
[
cfg
(
doctest
)
]
doc_comment
:
:
doctest
!
(
"
.
.
/
README
.
md
"
)
;
const
NUM_RETRIES
:
u32
=
1
<
<
31
;
const
NUM_RAND_CHARS
:
usize
=
6
;
use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
fs
:
:
OpenOptions
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
{
env
io
}
;
mod
dir
;
mod
error
;
mod
file
;
mod
spooled
;
mod
util
;
pub
use
crate
:
:
dir
:
:
{
tempdir
tempdir_in
TempDir
}
;
pub
use
crate
:
:
file
:
:
{
tempfile
tempfile_in
NamedTempFile
PathPersistError
PersistError
TempPath
}
;
pub
use
crate
:
:
spooled
:
:
{
spooled_tempfile
SpooledTempFile
}
;
#
[
derive
(
Debug
Clone
Eq
PartialEq
)
]
pub
struct
Builder
<
'
a
'
b
>
{
random_len
:
usize
prefix
:
&
'
a
OsStr
suffix
:
&
'
b
OsStr
append
:
bool
}
impl
<
'
a
'
b
>
Default
for
Builder
<
'
a
'
b
>
{
fn
default
(
)
-
>
Self
{
Builder
{
random_len
:
crate
:
:
NUM_RAND_CHARS
prefix
:
OsStr
:
:
new
(
"
.
tmp
"
)
suffix
:
OsStr
:
:
new
(
"
"
)
append
:
false
}
}
}
impl
<
'
a
'
b
>
Builder
<
'
a
'
b
>
{
#
[
must_use
]
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
prefix
<
S
:
AsRef
<
OsStr
>
+
?
Sized
>
(
&
mut
self
prefix
:
&
'
a
S
)
-
>
&
mut
Self
{
self
.
prefix
=
prefix
.
as_ref
(
)
;
self
}
pub
fn
suffix
<
S
:
AsRef
<
OsStr
>
+
?
Sized
>
(
&
mut
self
suffix
:
&
'
b
S
)
-
>
&
mut
Self
{
self
.
suffix
=
suffix
.
as_ref
(
)
;
self
}
pub
fn
rand_bytes
(
&
mut
self
rand
:
usize
)
-
>
&
mut
Self
{
self
.
random_len
=
rand
;
self
}
pub
fn
append
(
&
mut
self
append
:
bool
)
-
>
&
mut
Self
{
self
.
append
=
append
;
self
}
pub
fn
tempfile
(
&
self
)
-
>
io
:
:
Result
<
NamedTempFile
>
{
self
.
tempfile_in
(
env
:
:
temp_dir
(
)
)
}
pub
fn
tempfile_in
<
P
:
AsRef
<
Path
>
>
(
&
self
dir
:
P
)
-
>
io
:
:
Result
<
NamedTempFile
>
{
util
:
:
create_helper
(
dir
.
as_ref
(
)
self
.
prefix
self
.
suffix
self
.
random_len
|
path
|
file
:
:
create_named
(
path
OpenOptions
:
:
new
(
)
.
append
(
self
.
append
)
)
)
}
pub
fn
tempdir
(
&
self
)
-
>
io
:
:
Result
<
TempDir
>
{
self
.
tempdir_in
(
env
:
:
temp_dir
(
)
)
}
pub
fn
tempdir_in
<
P
:
AsRef
<
Path
>
>
(
&
self
dir
:
P
)
-
>
io
:
:
Result
<
TempDir
>
{
let
storage
;
let
mut
dir
=
dir
.
as_ref
(
)
;
if
!
dir
.
is_absolute
(
)
{
let
cur_dir
=
env
:
:
current_dir
(
)
?
;
storage
=
cur_dir
.
join
(
dir
)
;
dir
=
&
storage
;
}
util
:
:
create_helper
(
dir
self
.
prefix
self
.
suffix
self
.
random_len
dir
:
:
create
)
}
pub
fn
make
<
F
R
>
(
&
self
f
:
F
)
-
>
io
:
:
Result
<
NamedTempFile
<
R
>
>
where
F
:
FnMut
(
&
Path
)
-
>
io
:
:
Result
<
R
>
{
self
.
make_in
(
env
:
:
temp_dir
(
)
f
)
}
pub
fn
make_in
<
F
R
P
>
(
&
self
dir
:
P
mut
f
:
F
)
-
>
io
:
:
Result
<
NamedTempFile
<
R
>
>
where
F
:
FnMut
(
&
Path
)
-
>
io
:
:
Result
<
R
>
P
:
AsRef
<
Path
>
{
util
:
:
create_helper
(
dir
.
as_ref
(
)
self
.
prefix
self
.
suffix
self
.
random_len
move
|
path
|
{
Ok
(
NamedTempFile
:
:
from_parts
(
f
(
&
path
)
?
TempPath
:
:
from_path
(
path
)
)
)
}
)
}
}
