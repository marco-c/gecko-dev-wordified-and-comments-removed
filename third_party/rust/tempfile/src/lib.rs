#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
-
v2
.
png
"
html_favicon_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
docs
.
rs
/
tempfile
/
latest
"
)
]
#
!
[
cfg_attr
(
test
deny
(
warnings
)
)
]
#
!
[
deny
(
rust_2018_idioms
)
]
#
!
[
allow
(
clippy
:
:
redundant_field_names
)
]
#
!
[
cfg_attr
(
all
(
feature
=
"
nightly
"
target_os
=
"
wasi
"
target_env
=
"
p2
"
)
feature
(
wasip2
)
)
]
#
!
[
cfg_attr
(
all
(
feature
=
"
nightly
"
target_os
=
"
wasi
"
)
feature
(
wasi_ext
)
)
]
#
[
cfg
(
doctest
)
]
doc_comment
:
:
doctest
!
(
"
.
.
/
README
.
md
"
)
;
const
NUM_RETRIES
:
u32
=
65536
;
const
NUM_RAND_CHARS
:
usize
=
6
;
use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
fs
:
:
OpenOptions
;
use
std
:
:
io
;
use
std
:
:
path
:
:
Path
;
mod
dir
;
mod
error
;
mod
file
;
mod
spooled
;
mod
util
;
pub
mod
env
;
pub
use
crate
:
:
dir
:
:
{
tempdir
tempdir_in
TempDir
}
;
pub
use
crate
:
:
file
:
:
{
tempfile
tempfile_in
NamedTempFile
PathPersistError
PersistError
TempPath
}
;
pub
use
crate
:
:
spooled
:
:
{
spooled_tempfile
SpooledData
SpooledTempFile
}
;
#
[
derive
(
Debug
Clone
Eq
PartialEq
)
]
pub
struct
Builder
<
'
a
'
b
>
{
random_len
:
usize
prefix
:
&
'
a
OsStr
suffix
:
&
'
b
OsStr
append
:
bool
permissions
:
Option
<
std
:
:
fs
:
:
Permissions
>
keep
:
bool
}
impl
Default
for
Builder
<
'
_
'
_
>
{
fn
default
(
)
-
>
Self
{
Builder
{
random_len
:
crate
:
:
NUM_RAND_CHARS
prefix
:
OsStr
:
:
new
(
"
.
tmp
"
)
suffix
:
OsStr
:
:
new
(
"
"
)
append
:
false
permissions
:
None
keep
:
false
}
}
}
impl
<
'
a
'
b
>
Builder
<
'
a
'
b
>
{
#
[
must_use
]
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
prefix
<
S
:
AsRef
<
OsStr
>
+
?
Sized
>
(
&
mut
self
prefix
:
&
'
a
S
)
-
>
&
mut
Self
{
self
.
prefix
=
prefix
.
as_ref
(
)
;
self
}
pub
fn
suffix
<
S
:
AsRef
<
OsStr
>
+
?
Sized
>
(
&
mut
self
suffix
:
&
'
b
S
)
-
>
&
mut
Self
{
self
.
suffix
=
suffix
.
as_ref
(
)
;
self
}
pub
fn
rand_bytes
(
&
mut
self
rand
:
usize
)
-
>
&
mut
Self
{
self
.
random_len
=
rand
;
self
}
pub
fn
append
(
&
mut
self
append
:
bool
)
-
>
&
mut
Self
{
self
.
append
=
append
;
self
}
pub
fn
permissions
(
&
mut
self
permissions
:
std
:
:
fs
:
:
Permissions
)
-
>
&
mut
Self
{
self
.
permissions
=
Some
(
permissions
)
;
self
}
pub
fn
keep
(
&
mut
self
keep
:
bool
)
-
>
&
mut
Self
{
self
.
keep
=
keep
;
self
}
pub
fn
tempfile
(
&
self
)
-
>
io
:
:
Result
<
NamedTempFile
>
{
self
.
tempfile_in
(
env
:
:
temp_dir
(
)
)
}
pub
fn
tempfile_in
<
P
:
AsRef
<
Path
>
>
(
&
self
dir
:
P
)
-
>
io
:
:
Result
<
NamedTempFile
>
{
util
:
:
create_helper
(
dir
.
as_ref
(
)
self
.
prefix
self
.
suffix
self
.
random_len
|
path
|
{
file
:
:
create_named
(
path
OpenOptions
:
:
new
(
)
.
append
(
self
.
append
)
self
.
permissions
.
as_ref
(
)
self
.
keep
)
}
)
}
pub
fn
tempdir
(
&
self
)
-
>
io
:
:
Result
<
TempDir
>
{
self
.
tempdir_in
(
env
:
:
temp_dir
(
)
)
}
pub
fn
tempdir_in
<
P
:
AsRef
<
Path
>
>
(
&
self
dir
:
P
)
-
>
io
:
:
Result
<
TempDir
>
{
let
storage
;
let
mut
dir
=
dir
.
as_ref
(
)
;
if
!
dir
.
is_absolute
(
)
{
let
cur_dir
=
std
:
:
env
:
:
current_dir
(
)
?
;
storage
=
cur_dir
.
join
(
dir
)
;
dir
=
&
storage
;
}
util
:
:
create_helper
(
dir
self
.
prefix
self
.
suffix
self
.
random_len
|
path
|
{
dir
:
:
create
(
path
self
.
permissions
.
as_ref
(
)
self
.
keep
)
}
)
}
pub
fn
make
<
F
R
>
(
&
self
f
:
F
)
-
>
io
:
:
Result
<
NamedTempFile
<
R
>
>
where
F
:
FnMut
(
&
Path
)
-
>
io
:
:
Result
<
R
>
{
self
.
make_in
(
env
:
:
temp_dir
(
)
f
)
}
pub
fn
make_in
<
F
R
P
>
(
&
self
dir
:
P
mut
f
:
F
)
-
>
io
:
:
Result
<
NamedTempFile
<
R
>
>
where
F
:
FnMut
(
&
Path
)
-
>
io
:
:
Result
<
R
>
P
:
AsRef
<
Path
>
{
util
:
:
create_helper
(
dir
.
as_ref
(
)
self
.
prefix
self
.
suffix
self
.
random_len
move
|
path
|
{
Ok
(
NamedTempFile
:
:
from_parts
(
f
(
&
path
)
?
TempPath
:
:
new
(
path
self
.
keep
)
)
)
}
)
}
}
