import
sys
import
ctypes
from
rondpoint
import
*
dico
=
Dictionnaire
(
un
=
Enumeration
.
DEUX
deux
=
True
petit_nombre
=
0
gros_nombre
=
123456789
)
copyDico
=
copie_dictionnaire
(
dico
)
assert
dico
=
=
copyDico
assert
copie_enumeration
(
Enumeration
.
DEUX
)
=
=
Enumeration
.
DEUX
assert
copie_enumerations
(
[
Enumeration
.
UN
Enumeration
.
DEUX
]
)
=
=
[
Enumeration
.
UN
Enumeration
.
DEUX
]
assert
copie_carte
(
{
    
"
0
"
:
EnumerationAvecDonnees
.
ZERO
(
)
    
"
1
"
:
EnumerationAvecDonnees
.
UN
(
1
)
    
"
2
"
:
EnumerationAvecDonnees
.
DEUX
(
2
"
deux
"
)
}
)
=
=
{
    
"
0
"
:
EnumerationAvecDonnees
.
ZERO
(
)
    
"
1
"
:
EnumerationAvecDonnees
.
UN
(
1
)
    
"
2
"
:
EnumerationAvecDonnees
.
DEUX
(
2
"
deux
"
)
}
assert
switcheroo
(
False
)
is
True
assert
EnumerationAvecDonnees
.
ZERO
(
)
!
=
EnumerationAvecDonnees
.
UN
(
1
)
assert
EnumerationAvecDonnees
.
UN
(
1
)
=
=
EnumerationAvecDonnees
.
UN
(
1
)
assert
EnumerationAvecDonnees
.
UN
(
1
)
!
=
EnumerationAvecDonnees
.
UN
(
2
)
rt
=
Retourneur
(
)
def
affirmAllerRetour
(
vals
identique
)
:
    
for
v
in
vals
:
        
id_v
=
identique
(
v
)
        
assert
id_v
=
=
v
f
"
Round
-
trip
failure
:
{
v
}
=
>
{
id_v
}
"
MIN_I8
=
-
1
*
2
*
*
7
MAX_I8
=
2
*
*
7
-
1
MIN_I16
=
-
1
*
2
*
*
15
MAX_I16
=
2
*
*
15
-
1
MIN_I32
=
-
1
*
2
*
*
31
MAX_I32
=
2
*
*
31
-
1
MIN_I64
=
-
1
*
2
*
*
31
MAX_I64
=
2
*
*
31
-
1
F32_ONE_THIRD
=
ctypes
.
c_float
(
1
.
0
/
3
)
.
value
affirmAllerRetour
(
[
True
False
]
rt
.
identique_boolean
)
affirmAllerRetour
(
[
MIN_I8
-
1
0
1
MAX_I8
]
rt
.
identique_i8
)
affirmAllerRetour
(
[
0x00
0x12
0xFF
]
rt
.
identique_u8
)
affirmAllerRetour
(
[
MIN_I16
-
1
0
1
MAX_I16
]
rt
.
identique_i16
)
affirmAllerRetour
(
[
0x0000
0x1234
0xFFFF
]
rt
.
identique_u16
)
affirmAllerRetour
(
[
MIN_I32
-
1
0
1
MAX_I32
]
rt
.
identique_i32
)
affirmAllerRetour
(
[
0x00000000
0x12345678
0xFFFFFFFF
]
rt
.
identique_u32
)
affirmAllerRetour
(
[
MIN_I64
-
1
0
1
MAX_I64
]
rt
.
identique_i64
)
affirmAllerRetour
(
[
0x0000000000000000
0x1234567890ABCDEF
0xFFFFFFFFFFFFFFFF
]
rt
.
identique_u64
)
affirmAllerRetour
(
[
0
.
0
0
.
5
0
.
25
1
.
0
F32_ONE_THIRD
]
rt
.
identique_float
)
affirmAllerRetour
(
  
[
0
.
0
0
.
5
0
.
25
1
.
0
1
.
0
/
3
sys
.
float_info
.
max
sys
.
float_info
.
min
]
  
rt
.
identique_double
)
affirmAllerRetour
(
  
[
"
"
"
abc
"
"
t
"
"
"
"
emoji
multi
-
emoji
a
flag
a
canal
panama
"
]
  
rt
.
identique_string
)
st
=
Stringifier
(
)
def
affirmEnchaine
(
vals
toString
rustyStringify
=
lambda
v
:
str
(
v
)
.
lower
(
)
)
:
    
for
v
in
vals
:
        
str_v
=
toString
(
v
)
        
assert
rustyStringify
(
v
)
=
=
str_v
f
"
String
compare
error
{
v
}
=
>
{
str_v
}
"
wellKnown
=
st
.
well_known_string
(
"
python
"
)
assert
"
uniffi
python
!
"
=
=
wellKnown
affirmEnchaine
(
[
True
False
]
st
.
to_string_boolean
)
affirmEnchaine
(
[
MIN_I8
-
1
0
1
MAX_I8
]
st
.
to_string_i8
)
affirmEnchaine
(
[
0x00
0x12
0xFF
]
st
.
to_string_u8
)
affirmEnchaine
(
[
MIN_I16
-
1
0
1
MAX_I16
]
st
.
to_string_i16
)
affirmEnchaine
(
[
0x0000
0x1234
0xFFFF
]
st
.
to_string_u16
)
affirmEnchaine
(
[
MIN_I32
-
1
0
1
MAX_I32
]
st
.
to_string_i32
)
affirmEnchaine
(
[
0x00000000
0x12345678
0xFFFFFFFF
]
st
.
to_string_u32
)
affirmEnchaine
(
[
MIN_I64
-
1
0
1
MAX_I64
]
st
.
to_string_i64
)
affirmEnchaine
(
[
0x0000000000000000
0x1234567890ABCDEF
0xFFFFFFFFFFFFFFFF
]
st
.
to_string_u64
)
def
rustyFloatToStr
(
v
)
:
    
"
"
"
Stringify
a
float
in
the
same
way
that
rust
seems
to
.
"
"
"
    
if
int
(
v
)
=
=
v
:
        
return
str
(
int
(
v
)
)
    
return
str
(
v
)
affirmEnchaine
(
[
0
.
0
0
.
5
0
.
25
1
.
0
]
st
.
to_string_float
rustyFloatToStr
)
assert
st
.
to_string_float
(
F32_ONE_THIRD
)
=
=
"
0
.
33333334
"
affirmEnchaine
(
  
[
0
.
0
0
.
5
0
.
25
1
.
0
1
.
0
/
3
]
  
st
.
to_string_double
  
rustyFloatToStr
)
