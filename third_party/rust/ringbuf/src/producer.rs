use
alloc
:
:
sync
:
:
Arc
;
use
core
:
:
{
mem
:
:
{
self
MaybeUninit
}
ptr
:
:
copy_nonoverlapping
sync
:
:
atomic
:
:
Ordering
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
io
:
:
{
self
Read
Write
}
;
use
crate
:
:
{
consumer
:
:
Consumer
ring_buffer
:
:
*
}
;
pub
struct
Producer
<
T
>
{
pub
(
crate
)
rb
:
Arc
<
RingBuffer
<
T
>
>
}
impl
<
T
:
Sized
>
Producer
<
T
>
{
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
rb
.
capacity
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
rb
.
is_empty
(
)
}
pub
fn
is_full
(
&
self
)
-
>
bool
{
self
.
rb
.
is_full
(
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
rb
.
len
(
)
}
pub
fn
remaining
(
&
self
)
-
>
usize
{
self
.
rb
.
remaining
(
)
}
pub
unsafe
fn
push_access
<
F
>
(
&
mut
self
f
:
F
)
-
>
usize
where
F
:
FnOnce
(
&
mut
[
MaybeUninit
<
T
>
]
&
mut
[
MaybeUninit
<
T
>
]
)
-
>
usize
{
let
head
=
self
.
rb
.
head
.
load
(
Ordering
:
:
Acquire
)
;
let
tail
=
self
.
rb
.
tail
.
load
(
Ordering
:
:
Acquire
)
;
let
len
=
self
.
rb
.
data
.
get_ref
(
)
.
len
(
)
;
let
ranges
=
if
tail
>
=
head
{
if
head
>
0
{
(
tail
.
.
len
0
.
.
(
head
-
1
)
)
}
else
if
tail
<
len
-
1
{
(
tail
.
.
(
len
-
1
)
0
.
.
0
)
}
else
{
(
0
.
.
0
0
.
.
0
)
}
}
else
if
tail
<
head
-
1
{
(
tail
.
.
(
head
-
1
)
0
.
.
0
)
}
else
{
(
0
.
.
0
0
.
.
0
)
}
;
let
slices
=
(
&
mut
self
.
rb
.
data
.
get_mut
(
)
[
ranges
.
0
]
&
mut
self
.
rb
.
data
.
get_mut
(
)
[
ranges
.
1
]
)
;
let
n
=
f
(
slices
.
0
slices
.
1
)
;
if
n
>
0
{
let
new_tail
=
(
tail
+
n
)
%
len
;
self
.
rb
.
tail
.
store
(
new_tail
Ordering
:
:
Release
)
;
}
n
}
pub
unsafe
fn
push_copy
(
&
mut
self
elems
:
&
[
MaybeUninit
<
T
>
]
)
-
>
usize
{
self
.
push_access
(
|
left
right
|
-
>
usize
{
if
elems
.
len
(
)
<
left
.
len
(
)
{
copy_nonoverlapping
(
elems
.
as_ptr
(
)
left
.
as_mut_ptr
(
)
elems
.
len
(
)
)
;
elems
.
len
(
)
}
else
{
copy_nonoverlapping
(
elems
.
as_ptr
(
)
left
.
as_mut_ptr
(
)
left
.
len
(
)
)
;
if
elems
.
len
(
)
<
left
.
len
(
)
+
right
.
len
(
)
{
copy_nonoverlapping
(
elems
.
as_ptr
(
)
.
add
(
left
.
len
(
)
)
right
.
as_mut_ptr
(
)
elems
.
len
(
)
-
left
.
len
(
)
)
;
elems
.
len
(
)
}
else
{
copy_nonoverlapping
(
elems
.
as_ptr
(
)
.
add
(
left
.
len
(
)
)
right
.
as_mut_ptr
(
)
right
.
len
(
)
)
;
left
.
len
(
)
+
right
.
len
(
)
}
}
}
)
}
pub
fn
push
(
&
mut
self
elem
:
T
)
-
>
Result
<
(
)
T
>
{
let
mut
elem_mu
=
MaybeUninit
:
:
new
(
elem
)
;
let
n
=
unsafe
{
self
.
push_access
(
|
slice
_
|
{
if
!
slice
.
is_empty
(
)
{
mem
:
:
swap
(
slice
.
get_unchecked_mut
(
0
)
&
mut
elem_mu
)
;
1
}
else
{
0
}
}
)
}
;
match
n
{
0
=
>
Err
(
unsafe
{
elem_mu
.
assume_init
(
)
}
)
1
=
>
Ok
(
(
)
)
_
=
>
unreachable
!
(
)
}
}
pub
fn
push_each
<
F
:
FnMut
(
)
-
>
Option
<
T
>
>
(
&
mut
self
mut
f
:
F
)
-
>
usize
{
unsafe
{
self
.
push_access
(
|
left
right
|
{
for
(
i
dst
)
in
left
.
iter_mut
(
)
.
enumerate
(
)
{
match
f
(
)
{
Some
(
e
)
=
>
dst
.
as_mut_ptr
(
)
.
write
(
e
)
None
=
>
return
i
}
;
}
for
(
i
dst
)
in
right
.
iter_mut
(
)
.
enumerate
(
)
{
match
f
(
)
{
Some
(
e
)
=
>
dst
.
as_mut_ptr
(
)
.
write
(
e
)
None
=
>
return
i
+
left
.
len
(
)
}
;
}
left
.
len
(
)
+
right
.
len
(
)
}
)
}
}
pub
fn
push_iter
<
I
:
Iterator
<
Item
=
T
>
>
(
&
mut
self
elems
:
&
mut
I
)
-
>
usize
{
self
.
push_each
(
|
|
elems
.
next
(
)
)
}
pub
fn
move_from
(
&
mut
self
other
:
&
mut
Consumer
<
T
>
count
:
Option
<
usize
>
)
-
>
usize
{
move_items
(
other
self
count
)
}
}
impl
<
T
:
Sized
+
Copy
>
Producer
<
T
>
{
pub
fn
push_slice
(
&
mut
self
elems
:
&
[
T
]
)
-
>
usize
{
unsafe
{
self
.
push_copy
(
&
*
(
elems
as
*
const
[
T
]
as
*
const
[
MaybeUninit
<
T
>
]
)
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Producer
<
u8
>
{
pub
fn
read_from
(
&
mut
self
reader
:
&
mut
dyn
Read
count
:
Option
<
usize
>
)
-
>
io
:
:
Result
<
usize
>
{
let
mut
err
=
None
;
let
n
=
unsafe
{
self
.
push_access
(
|
left
_
|
-
>
usize
{
let
left
=
match
count
{
Some
(
c
)
=
>
{
if
c
<
left
.
len
(
)
{
&
mut
left
[
0
.
.
c
]
}
else
{
left
}
}
None
=
>
left
}
;
match
reader
.
read
(
&
mut
*
(
left
as
*
mut
[
MaybeUninit
<
u8
>
]
as
*
mut
[
u8
]
)
)
.
and_then
(
|
n
|
{
if
n
<
=
left
.
len
(
)
{
Ok
(
n
)
}
else
{
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidInput
"
Read
operation
returned
an
invalid
number
"
)
)
}
}
)
{
Ok
(
n
)
=
>
n
Err
(
e
)
=
>
{
err
=
Some
(
e
)
;
0
}
}
}
)
}
;
match
err
{
Some
(
e
)
=
>
Err
(
e
)
None
=
>
Ok
(
n
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Write
for
Producer
<
u8
>
{
fn
write
(
&
mut
self
buffer
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
let
n
=
self
.
push_slice
(
buffer
)
;
if
n
=
=
0
&
&
!
buffer
.
is_empty
(
)
{
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
else
{
Ok
(
n
)
}
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
