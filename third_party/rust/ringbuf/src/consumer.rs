use
alloc
:
:
sync
:
:
Arc
;
use
core
:
:
{
cmp
:
:
{
self
min
}
mem
:
:
{
self
MaybeUninit
}
ops
:
:
Range
ptr
:
:
copy_nonoverlapping
slice
sync
:
:
atomic
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
io
:
:
{
self
Read
Write
}
;
use
crate
:
:
{
producer
:
:
Producer
ring_buffer
:
:
*
}
;
pub
struct
Consumer
<
T
>
{
pub
(
crate
)
rb
:
Arc
<
RingBuffer
<
T
>
>
}
impl
<
T
:
Sized
>
Consumer
<
T
>
{
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
rb
.
capacity
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
rb
.
is_empty
(
)
}
pub
fn
is_full
(
&
self
)
-
>
bool
{
self
.
rb
.
is_full
(
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
rb
.
len
(
)
}
pub
fn
remaining
(
&
self
)
-
>
usize
{
self
.
rb
.
remaining
(
)
}
fn
get_ranges
(
&
self
)
-
>
(
Range
<
usize
>
Range
<
usize
>
)
{
let
head
=
self
.
rb
.
head
.
load
(
atomic
:
:
Ordering
:
:
Acquire
)
;
let
tail
=
self
.
rb
.
tail
.
load
(
atomic
:
:
Ordering
:
:
Acquire
)
;
let
len
=
self
.
rb
.
data
.
len
(
)
;
match
head
.
cmp
(
&
tail
)
{
cmp
:
:
Ordering
:
:
Less
=
>
(
head
.
.
tail
0
.
.
0
)
cmp
:
:
Ordering
:
:
Greater
=
>
(
head
.
.
len
0
.
.
tail
)
cmp
:
:
Ordering
:
:
Equal
=
>
(
0
.
.
0
0
.
.
0
)
}
}
pub
fn
as_slices
(
&
self
)
-
>
(
&
[
T
]
&
[
T
]
)
{
let
ranges
=
self
.
get_ranges
(
)
;
unsafe
{
let
ptr
=
self
.
rb
.
data
.
get_ref
(
)
.
as_ptr
(
)
;
let
left
=
slice
:
:
from_raw_parts
(
ptr
.
add
(
ranges
.
0
.
start
)
ranges
.
0
.
len
(
)
)
;
let
right
=
slice
:
:
from_raw_parts
(
ptr
.
add
(
ranges
.
1
.
start
)
ranges
.
1
.
len
(
)
)
;
(
&
*
(
left
as
*
const
[
MaybeUninit
<
T
>
]
as
*
const
[
T
]
)
&
*
(
right
as
*
const
[
MaybeUninit
<
T
>
]
as
*
const
[
T
]
)
)
}
}
pub
fn
as_mut_slices
(
&
mut
self
)
-
>
(
&
mut
[
T
]
&
mut
[
T
]
)
{
let
ranges
=
self
.
get_ranges
(
)
;
unsafe
{
let
ptr
=
self
.
rb
.
data
.
get_mut
(
)
.
as_mut_ptr
(
)
;
let
left
=
slice
:
:
from_raw_parts_mut
(
ptr
.
add
(
ranges
.
0
.
start
)
ranges
.
0
.
len
(
)
)
;
let
right
=
slice
:
:
from_raw_parts_mut
(
ptr
.
add
(
ranges
.
1
.
start
)
ranges
.
1
.
len
(
)
)
;
(
&
mut
*
(
left
as
*
mut
[
MaybeUninit
<
T
>
]
as
*
mut
[
T
]
)
&
mut
*
(
right
as
*
mut
[
MaybeUninit
<
T
>
]
as
*
mut
[
T
]
)
)
}
}
#
[
deprecated
(
since
=
"
0
.
2
.
7
"
note
=
"
please
use
as_slices
instead
"
)
]
pub
fn
access
<
F
:
FnOnce
(
&
[
T
]
&
[
T
]
)
>
(
&
self
f
:
F
)
{
let
(
left
right
)
=
self
.
as_slices
(
)
;
f
(
left
right
)
;
}
#
[
deprecated
(
since
=
"
0
.
2
.
7
"
note
=
"
please
use
as_mut_slices
instead
"
)
]
pub
fn
access_mut
<
F
:
FnOnce
(
&
mut
[
T
]
&
mut
[
T
]
)
>
(
&
mut
self
f
:
F
)
{
let
(
left
right
)
=
self
.
as_mut_slices
(
)
;
f
(
left
right
)
;
}
pub
unsafe
fn
pop_access
<
F
>
(
&
mut
self
f
:
F
)
-
>
usize
where
F
:
FnOnce
(
&
mut
[
MaybeUninit
<
T
>
]
&
mut
[
MaybeUninit
<
T
>
]
)
-
>
usize
{
let
head
=
self
.
rb
.
head
.
load
(
atomic
:
:
Ordering
:
:
Acquire
)
;
let
tail
=
self
.
rb
.
tail
.
load
(
atomic
:
:
Ordering
:
:
Acquire
)
;
let
len
=
self
.
rb
.
data
.
len
(
)
;
let
ranges
=
match
head
.
cmp
(
&
tail
)
{
cmp
:
:
Ordering
:
:
Less
=
>
(
head
.
.
tail
0
.
.
0
)
cmp
:
:
Ordering
:
:
Greater
=
>
(
head
.
.
len
0
.
.
tail
)
cmp
:
:
Ordering
:
:
Equal
=
>
(
0
.
.
0
0
.
.
0
)
}
;
let
ptr
=
self
.
rb
.
data
.
get_mut
(
)
.
as_mut_ptr
(
)
;
let
slices
=
(
slice
:
:
from_raw_parts_mut
(
ptr
.
wrapping_add
(
ranges
.
0
.
start
)
ranges
.
0
.
len
(
)
)
slice
:
:
from_raw_parts_mut
(
ptr
.
wrapping_add
(
ranges
.
1
.
start
)
ranges
.
1
.
len
(
)
)
)
;
let
n
=
f
(
slices
.
0
slices
.
1
)
;
if
n
>
0
{
let
new_head
=
(
head
+
n
)
%
len
;
self
.
rb
.
head
.
store
(
new_head
atomic
:
:
Ordering
:
:
Release
)
;
}
n
}
pub
unsafe
fn
pop_copy
(
&
mut
self
elems
:
&
mut
[
MaybeUninit
<
T
>
]
)
-
>
usize
{
self
.
pop_access
(
|
left
right
|
{
if
elems
.
len
(
)
<
left
.
len
(
)
{
copy_nonoverlapping
(
left
.
as_ptr
(
)
elems
.
as_mut_ptr
(
)
elems
.
len
(
)
)
;
elems
.
len
(
)
}
else
{
copy_nonoverlapping
(
left
.
as_ptr
(
)
elems
.
as_mut_ptr
(
)
left
.
len
(
)
)
;
if
elems
.
len
(
)
<
left
.
len
(
)
+
right
.
len
(
)
{
copy_nonoverlapping
(
right
.
as_ptr
(
)
elems
.
as_mut_ptr
(
)
.
add
(
left
.
len
(
)
)
elems
.
len
(
)
-
left
.
len
(
)
)
;
elems
.
len
(
)
}
else
{
copy_nonoverlapping
(
right
.
as_ptr
(
)
elems
.
as_mut_ptr
(
)
.
add
(
left
.
len
(
)
)
right
.
len
(
)
)
;
left
.
len
(
)
+
right
.
len
(
)
}
}
}
)
}
pub
fn
pop
(
&
mut
self
)
-
>
Option
<
T
>
{
let
mut
elem_mu
=
MaybeUninit
:
:
uninit
(
)
;
let
n
=
unsafe
{
self
.
pop_access
(
|
slice
_
|
{
if
!
slice
.
is_empty
(
)
{
mem
:
:
swap
(
slice
.
get_unchecked_mut
(
0
)
&
mut
elem_mu
)
;
1
}
else
{
0
}
}
)
}
;
match
n
{
0
=
>
None
1
=
>
Some
(
unsafe
{
elem_mu
.
assume_init
(
)
}
)
_
=
>
unreachable
!
(
)
}
}
pub
fn
pop_each
<
F
:
FnMut
(
T
)
-
>
bool
>
(
&
mut
self
mut
f
:
F
count
:
Option
<
usize
>
)
-
>
usize
{
unsafe
{
self
.
pop_access
(
|
left
right
|
{
let
lb
=
match
count
{
Some
(
n
)
=
>
min
(
n
left
.
len
(
)
)
None
=
>
left
.
len
(
)
}
;
for
(
i
dst
)
in
left
[
0
.
.
lb
]
.
iter_mut
(
)
.
enumerate
(
)
{
if
!
f
(
dst
.
as_ptr
(
)
.
read
(
)
)
{
return
i
+
1
;
}
}
if
lb
<
left
.
len
(
)
{
return
lb
;
}
let
rb
=
match
count
{
Some
(
n
)
=
>
min
(
n
-
lb
right
.
len
(
)
)
None
=
>
right
.
len
(
)
}
;
for
(
i
dst
)
in
right
[
0
.
.
rb
]
.
iter_mut
(
)
.
enumerate
(
)
{
if
!
f
(
dst
.
as_ptr
(
)
.
read
(
)
)
{
return
lb
+
i
+
1
;
}
}
lb
+
rb
}
)
}
}
#
[
deprecated
(
since
=
"
0
.
2
.
7
"
note
=
"
please
use
iter
instead
"
)
]
pub
fn
for_each
<
F
:
FnMut
(
&
T
)
>
(
&
self
mut
f
:
F
)
{
let
(
left
right
)
=
self
.
as_slices
(
)
;
for
c
in
left
.
iter
(
)
{
f
(
c
)
;
}
for
c
in
right
.
iter
(
)
{
f
(
c
)
;
}
}
pub
fn
iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
T
>
+
'
_
{
let
(
left
right
)
=
self
.
as_slices
(
)
;
left
.
iter
(
)
.
chain
(
right
.
iter
(
)
)
}
#
[
deprecated
(
since
=
"
0
.
2
.
7
"
note
=
"
please
use
iter_mut
instead
"
)
]
pub
fn
for_each_mut
<
F
:
FnMut
(
&
mut
T
)
>
(
&
mut
self
mut
f
:
F
)
{
let
(
left
right
)
=
self
.
as_mut_slices
(
)
;
for
c
in
left
.
iter_mut
(
)
{
f
(
c
)
;
}
for
c
in
right
.
iter_mut
(
)
{
f
(
c
)
;
}
}
pub
fn
iter_mut
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
&
mut
T
>
+
'
_
{
let
(
left
right
)
=
self
.
as_mut_slices
(
)
;
left
.
iter_mut
(
)
.
chain
(
right
.
iter_mut
(
)
)
}
pub
fn
discard
(
&
mut
self
n
:
usize
)
-
>
usize
{
unsafe
{
self
.
pop_access
(
|
left
right
|
{
let
(
mut
cnt
mut
rem
)
=
(
0
n
)
;
let
left_elems
=
if
rem
<
=
left
.
len
(
)
{
cnt
+
=
rem
;
left
.
get_unchecked_mut
(
0
.
.
rem
)
}
else
{
cnt
+
=
left
.
len
(
)
;
left
}
;
rem
=
n
-
cnt
;
let
right_elems
=
if
rem
<
=
right
.
len
(
)
{
cnt
+
=
rem
;
right
.
get_unchecked_mut
(
0
.
.
rem
)
}
else
{
cnt
+
=
right
.
len
(
)
;
right
}
;
for
e
in
left_elems
.
iter_mut
(
)
.
chain
(
right_elems
.
iter_mut
(
)
)
{
e
.
as_mut_ptr
(
)
.
drop_in_place
(
)
;
}
cnt
}
)
}
}
pub
fn
move_to
(
&
mut
self
other
:
&
mut
Producer
<
T
>
count
:
Option
<
usize
>
)
-
>
usize
{
move_items
(
self
other
count
)
}
}
impl
<
T
:
Sized
>
Iterator
for
Consumer
<
T
>
{
type
Item
=
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
T
>
{
self
.
pop
(
)
}
}
impl
<
T
:
Sized
+
Copy
>
Consumer
<
T
>
{
pub
fn
pop_slice
(
&
mut
self
elems
:
&
mut
[
T
]
)
-
>
usize
{
unsafe
{
self
.
pop_copy
(
&
mut
*
(
elems
as
*
mut
[
T
]
as
*
mut
[
MaybeUninit
<
T
>
]
)
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Consumer
<
u8
>
{
pub
fn
write_into
(
&
mut
self
writer
:
&
mut
dyn
Write
count
:
Option
<
usize
>
)
-
>
io
:
:
Result
<
usize
>
{
let
mut
err
=
None
;
let
n
=
unsafe
{
self
.
pop_access
(
|
left
_
|
-
>
usize
{
let
left
=
match
count
{
Some
(
c
)
=
>
{
if
c
<
left
.
len
(
)
{
&
mut
left
[
0
.
.
c
]
}
else
{
left
}
}
None
=
>
left
}
;
match
writer
.
write
(
&
*
(
left
as
*
const
[
MaybeUninit
<
u8
>
]
as
*
const
[
u8
]
)
)
.
and_then
(
|
n
|
{
if
n
<
=
left
.
len
(
)
{
Ok
(
n
)
}
else
{
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidInput
"
Write
operation
returned
an
invalid
number
"
)
)
}
}
)
{
Ok
(
n
)
=
>
n
Err
(
e
)
=
>
{
err
=
Some
(
e
)
;
0
}
}
}
)
}
;
match
err
{
Some
(
e
)
=
>
Err
(
e
)
None
=
>
Ok
(
n
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Read
for
Consumer
<
u8
>
{
fn
read
(
&
mut
self
buffer
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
let
n
=
self
.
pop_slice
(
buffer
)
;
if
n
=
=
0
&
&
!
buffer
.
is_empty
(
)
{
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
else
{
Ok
(
n
)
}
}
}
