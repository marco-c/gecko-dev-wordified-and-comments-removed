#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
smawk
/
0
.
3
.
2
"
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
ndarray
"
)
forbid
(
unsafe_code
)
)
]
#
[
cfg
(
feature
=
"
ndarray
"
)
]
pub
mod
brute_force
;
pub
mod
monge
;
#
[
cfg
(
feature
=
"
ndarray
"
)
]
pub
mod
recursive
;
pub
trait
Matrix
<
T
:
Copy
>
{
fn
nrows
(
&
self
)
-
>
usize
;
fn
ncols
(
&
self
)
-
>
usize
;
fn
index
(
&
self
row
:
usize
column
:
usize
)
-
>
T
;
}
impl
<
T
:
Copy
>
Matrix
<
T
>
for
Vec
<
Vec
<
T
>
>
{
fn
nrows
(
&
self
)
-
>
usize
{
self
.
len
(
)
}
fn
ncols
(
&
self
)
-
>
usize
{
self
[
0
]
.
len
(
)
}
fn
index
(
&
self
row
:
usize
column
:
usize
)
-
>
T
{
self
[
row
]
[
column
]
}
}
#
[
cfg
(
feature
=
"
ndarray
"
)
]
impl
<
T
:
Copy
>
Matrix
<
T
>
for
ndarray
:
:
Array2
<
T
>
{
#
[
inline
]
fn
nrows
(
&
self
)
-
>
usize
{
self
.
nrows
(
)
}
#
[
inline
]
fn
ncols
(
&
self
)
-
>
usize
{
self
.
ncols
(
)
}
#
[
inline
]
fn
index
(
&
self
row
:
usize
column
:
usize
)
-
>
T
{
self
[
[
row
column
]
]
}
}
pub
fn
row_minima
<
T
:
PartialOrd
+
Copy
M
:
Matrix
<
T
>
>
(
matrix
:
&
M
)
-
>
Vec
<
usize
>
{
let
mut
minima
=
vec
!
[
0
;
matrix
.
nrows
(
)
]
;
smawk_inner
(
&
|
j
i
|
matrix
.
index
(
i
j
)
&
(
0
.
.
matrix
.
ncols
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
&
(
0
.
.
matrix
.
nrows
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
&
mut
minima
)
;
minima
}
#
[
deprecated
(
since
=
"
0
.
3
.
2
"
note
=
"
Please
use
row_minima
instead
.
"
)
]
pub
fn
smawk_row_minima
<
T
:
PartialOrd
+
Copy
M
:
Matrix
<
T
>
>
(
matrix
:
&
M
)
-
>
Vec
<
usize
>
{
row_minima
(
matrix
)
}
pub
fn
column_minima
<
T
:
PartialOrd
+
Copy
M
:
Matrix
<
T
>
>
(
matrix
:
&
M
)
-
>
Vec
<
usize
>
{
let
mut
minima
=
vec
!
[
0
;
matrix
.
ncols
(
)
]
;
smawk_inner
(
&
|
i
j
|
matrix
.
index
(
i
j
)
&
(
0
.
.
matrix
.
nrows
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
&
(
0
.
.
matrix
.
ncols
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
&
mut
minima
)
;
minima
}
#
[
deprecated
(
since
=
"
0
.
3
.
2
"
note
=
"
Please
use
column_minima
instead
.
"
)
]
pub
fn
smawk_column_minima
<
T
:
PartialOrd
+
Copy
M
:
Matrix
<
T
>
>
(
matrix
:
&
M
)
-
>
Vec
<
usize
>
{
column_minima
(
matrix
)
}
fn
smawk_inner
<
T
:
PartialOrd
+
Copy
M
:
Fn
(
usize
usize
)
-
>
T
>
(
matrix
:
&
M
rows
:
&
[
usize
]
cols
:
&
[
usize
]
minima
:
&
mut
[
usize
]
)
{
if
cols
.
is_empty
(
)
{
return
;
}
let
mut
stack
=
Vec
:
:
with_capacity
(
cols
.
len
(
)
)
;
for
r
in
rows
{
while
!
stack
.
is_empty
(
)
&
&
matrix
(
stack
[
stack
.
len
(
)
-
1
]
cols
[
stack
.
len
(
)
-
1
]
)
>
matrix
(
*
r
cols
[
stack
.
len
(
)
-
1
]
)
{
stack
.
pop
(
)
;
}
if
stack
.
len
(
)
!
=
cols
.
len
(
)
{
stack
.
push
(
*
r
)
;
}
}
let
rows
=
&
stack
;
let
mut
odd_cols
=
Vec
:
:
with_capacity
(
1
+
cols
.
len
(
)
/
2
)
;
for
(
idx
c
)
in
cols
.
iter
(
)
.
enumerate
(
)
{
if
idx
%
2
=
=
1
{
odd_cols
.
push
(
*
c
)
;
}
}
smawk_inner
(
matrix
rows
&
odd_cols
minima
)
;
let
mut
r
=
0
;
for
(
c
&
col
)
in
cols
.
iter
(
)
.
enumerate
(
)
.
filter
(
|
(
c
_
)
|
c
%
2
=
=
0
)
{
let
mut
row
=
rows
[
r
]
;
let
last_row
=
if
c
=
=
cols
.
len
(
)
-
1
{
rows
[
rows
.
len
(
)
-
1
]
}
else
{
minima
[
cols
[
c
+
1
]
]
}
;
let
mut
pair
=
(
matrix
(
row
col
)
row
)
;
while
row
!
=
last_row
{
r
+
=
1
;
row
=
rows
[
r
]
;
if
(
matrix
(
row
col
)
row
)
<
pair
{
pair
=
(
matrix
(
row
col
)
row
)
;
}
}
minima
[
col
]
=
pair
.
1
;
}
}
pub
fn
online_column_minima
<
T
:
Copy
+
PartialOrd
M
:
Fn
(
&
[
(
usize
T
)
]
usize
usize
)
-
>
T
>
(
initial
:
T
size
:
usize
matrix
:
M
)
-
>
Vec
<
(
usize
T
)
>
{
let
mut
result
=
vec
!
[
(
0
initial
)
]
;
let
mut
finished
=
0
;
let
mut
base
=
0
;
let
mut
tentative
=
0
;
macro_rules
!
m
{
(
i
:
expr
j
:
expr
)
=
>
{
{
assert
!
(
i
<
j
"
(
i
j
)
not
above
diagonal
:
(
{
}
{
}
)
"
i
j
)
;
assert
!
(
i
<
size
&
&
j
<
size
"
(
i
j
)
out
of
bounds
:
(
{
}
{
}
)
size
:
{
}
"
i
j
size
)
;
matrix
(
&
result
[
.
.
finished
+
1
]
i
j
)
}
}
;
}
while
finished
<
size
-
1
{
let
i
=
finished
+
1
;
if
i
>
tentative
{
let
rows
=
(
base
.
.
finished
+
1
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
tentative
=
std
:
:
cmp
:
:
min
(
finished
+
rows
.
len
(
)
size
-
1
)
;
let
cols
=
(
finished
+
1
.
.
tentative
+
1
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
mut
minima
=
vec
!
[
0
;
tentative
+
1
]
;
smawk_inner
(
&
|
i
j
|
m
!
[
i
j
]
&
rows
&
cols
&
mut
minima
)
;
for
col
in
cols
{
let
row
=
minima
[
col
]
;
let
v
=
m
!
[
row
col
]
;
if
col
>
=
result
.
len
(
)
{
result
.
push
(
(
row
v
)
)
;
}
else
if
v
<
result
[
col
]
.
1
{
result
[
col
]
=
(
row
v
)
;
}
}
finished
=
i
;
continue
;
}
let
diag
=
m
!
[
i
-
1
i
]
;
if
diag
<
result
[
i
]
.
1
{
result
[
i
]
=
(
i
-
1
diag
)
;
base
=
i
-
1
;
tentative
=
i
;
finished
=
i
;
continue
;
}
if
m
!
[
i
-
1
tentative
]
>
=
result
[
tentative
]
.
1
{
finished
=
i
;
continue
;
}
base
=
i
-
1
;
tentative
=
i
;
finished
=
i
;
}
result
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
smawk_1x1
(
)
{
let
matrix
=
vec
!
[
vec
!
[
2
]
]
;
assert_eq
!
(
row_minima
(
&
matrix
)
vec
!
[
0
]
)
;
assert_eq
!
(
column_minima
(
&
matrix
)
vec
!
[
0
]
)
;
}
#
[
test
]
fn
smawk_2x1
(
)
{
let
matrix
=
vec
!
[
vec
!
[
3
]
/
/
vec
!
[
2
]
]
;
assert_eq
!
(
row_minima
(
&
matrix
)
vec
!
[
0
0
]
)
;
assert_eq
!
(
column_minima
(
&
matrix
)
vec
!
[
1
]
)
;
}
#
[
test
]
fn
smawk_1x2
(
)
{
let
matrix
=
vec
!
[
vec
!
[
2
1
]
]
;
assert_eq
!
(
row_minima
(
&
matrix
)
vec
!
[
1
]
)
;
assert_eq
!
(
column_minima
(
&
matrix
)
vec
!
[
0
0
]
)
;
}
#
[
test
]
fn
smawk_2x2
(
)
{
let
matrix
=
vec
!
[
vec
!
[
3
2
]
/
/
vec
!
[
2
1
]
]
;
assert_eq
!
(
row_minima
(
&
matrix
)
vec
!
[
1
1
]
)
;
assert_eq
!
(
column_minima
(
&
matrix
)
vec
!
[
1
1
]
)
;
}
#
[
test
]
fn
smawk_3x3
(
)
{
let
matrix
=
vec
!
[
vec
!
[
3
4
4
]
/
/
vec
!
[
3
4
4
]
vec
!
[
2
3
3
]
]
;
assert_eq
!
(
row_minima
(
&
matrix
)
vec
!
[
0
0
0
]
)
;
assert_eq
!
(
column_minima
(
&
matrix
)
vec
!
[
2
2
2
]
)
;
}
#
[
test
]
fn
smawk_4x4
(
)
{
let
matrix
=
vec
!
[
vec
!
[
4
5
5
5
]
/
/
vec
!
[
2
3
3
3
]
vec
!
[
2
3
3
3
]
vec
!
[
2
2
2
2
]
]
;
assert_eq
!
(
row_minima
(
&
matrix
)
vec
!
[
0
0
0
0
]
)
;
assert_eq
!
(
column_minima
(
&
matrix
)
vec
!
[
1
3
3
3
]
)
;
}
#
[
test
]
fn
smawk_5x5
(
)
{
let
matrix
=
vec
!
[
vec
!
[
3
2
4
5
6
]
vec
!
[
2
1
3
3
4
]
vec
!
[
2
1
3
3
4
]
vec
!
[
3
2
4
3
4
]
vec
!
[
4
3
2
1
1
]
]
;
assert_eq
!
(
row_minima
(
&
matrix
)
vec
!
[
1
1
1
1
3
]
)
;
assert_eq
!
(
column_minima
(
&
matrix
)
vec
!
[
1
1
4
4
4
]
)
;
}
#
[
test
]
fn
online_1x1
(
)
{
let
matrix
=
vec
!
[
vec
!
[
0
]
]
;
let
minima
=
vec
!
[
(
0
0
)
]
;
assert_eq
!
(
online_column_minima
(
0
1
|
_
i
j
|
matrix
[
i
]
[
j
]
)
minima
)
;
}
#
[
test
]
fn
online_2x2
(
)
{
let
matrix
=
vec
!
[
vec
!
[
0
2
]
/
/
vec
!
[
0
0
]
]
;
let
minima
=
vec
!
[
(
0
0
)
(
0
2
)
]
;
assert_eq
!
(
online_column_minima
(
0
2
|
_
i
j
|
matrix
[
i
]
[
j
]
)
minima
)
;
}
#
[
test
]
fn
online_3x3
(
)
{
let
matrix
=
vec
!
[
vec
!
[
0
4
4
]
/
/
vec
!
[
0
0
4
]
vec
!
[
0
0
0
]
]
;
let
minima
=
vec
!
[
(
0
0
)
(
0
4
)
(
0
4
)
]
;
assert_eq
!
(
online_column_minima
(
0
3
|
_
i
j
|
matrix
[
i
]
[
j
]
)
minima
)
;
}
#
[
test
]
fn
online_4x4
(
)
{
let
matrix
=
vec
!
[
vec
!
[
0
5
5
5
]
/
/
vec
!
[
0
0
3
3
]
vec
!
[
0
0
0
3
]
vec
!
[
0
0
0
0
]
]
;
let
minima
=
vec
!
[
(
0
0
)
(
0
5
)
(
1
3
)
(
1
3
)
]
;
assert_eq
!
(
online_column_minima
(
0
4
|
_
i
j
|
matrix
[
i
]
[
j
]
)
minima
)
;
}
#
[
test
]
fn
online_5x5
(
)
{
let
matrix
=
vec
!
[
vec
!
[
0
2
4
6
7
]
vec
!
[
0
0
3
4
5
]
vec
!
[
0
0
0
3
4
]
vec
!
[
0
0
0
0
4
]
vec
!
[
0
0
0
0
0
]
]
;
let
minima
=
vec
!
[
(
0
0
)
(
0
2
)
(
1
3
)
(
2
3
)
(
2
4
)
]
;
assert_eq
!
(
online_column_minima
(
0
5
|
_
i
j
|
matrix
[
i
]
[
j
]
)
minima
)
;
}
#
[
test
]
fn
smawk_works_with_partial_ord
(
)
{
let
matrix
=
vec
!
[
vec
!
[
3
.
0
2
.
0
]
/
/
vec
!
[
2
.
0
1
.
0
]
]
;
assert_eq
!
(
row_minima
(
&
matrix
)
vec
!
[
1
1
]
)
;
assert_eq
!
(
column_minima
(
&
matrix
)
vec
!
[
1
1
]
)
;
}
#
[
test
]
fn
online_works_with_partial_ord
(
)
{
let
matrix
=
vec
!
[
vec
!
[
0
.
0
2
.
0
]
/
/
vec
!
[
0
.
0
0
.
0
]
]
;
let
minima
=
vec
!
[
(
0
0
.
0
)
(
0
2
.
0
)
]
;
assert_eq
!
(
online_column_minima
(
0
.
0
2
|
_
i
:
usize
j
:
usize
|
matrix
[
i
]
[
j
]
)
minima
)
;
}
}
