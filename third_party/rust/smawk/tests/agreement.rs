#
!
[
cfg
(
feature
=
"
ndarray
"
)
]
use
ndarray
:
:
{
s
Array2
}
;
use
rand
:
:
SeedableRng
;
use
rand_chacha
:
:
ChaCha20Rng
;
use
smawk
:
:
{
brute_force
online_column_minima
recursive
}
;
mod
random_monge
;
use
random_monge
:
:
random_monge_matrix
;
#
[
test
]
fn
column_minima_agree
(
)
{
let
sizes
=
vec
!
[
1
2
3
4
5
10
15
20
30
]
;
let
mut
rng
=
ChaCha20Rng
:
:
seed_from_u64
(
0
)
;
for
_
in
0
.
.
4
{
for
m
in
sizes
.
clone
(
)
.
iter
(
)
{
for
n
in
sizes
.
clone
(
)
.
iter
(
)
{
let
matrix
:
Array2
<
i32
>
=
random_monge_matrix
(
*
m
*
n
&
mut
rng
)
;
let
brute_force
=
brute_force
:
:
row_minima
(
&
matrix
)
;
let
recursive
=
recursive
:
:
row_minima
(
&
matrix
)
;
let
smawk
=
smawk
:
:
row_minima
(
&
matrix
)
;
assert_eq
!
(
brute_force
recursive
"
recursive
and
brute
force
differs
on
:
\
n
{
:
?
}
"
matrix
)
;
assert_eq
!
(
brute_force
smawk
"
SMAWK
and
brute
force
differs
on
:
\
n
{
:
?
}
"
matrix
)
;
let
brute_force
=
brute_force
:
:
column_minima
(
&
matrix
)
;
let
recursive
=
recursive
:
:
column_minima
(
&
matrix
)
;
let
smawk
=
smawk
:
:
column_minima
(
&
matrix
)
;
assert_eq
!
(
brute_force
recursive
"
recursive
and
brute
force
differs
on
:
\
n
{
:
?
}
"
matrix
)
;
assert_eq
!
(
brute_force
smawk
"
SMAWK
and
brute
force
differs
on
:
\
n
{
:
?
}
"
matrix
)
;
}
}
}
}
#
[
test
]
fn
online_agree
(
)
{
let
sizes
=
vec
!
[
1
2
3
4
5
10
15
20
30
50
]
;
let
mut
rng
=
ChaCha20Rng
:
:
seed_from_u64
(
0
)
;
for
_
in
0
.
.
5
{
for
&
size
in
&
sizes
{
let
mut
matrix
:
Array2
<
i32
>
=
random_monge_matrix
(
size
size
&
mut
rng
)
;
let
max
=
*
matrix
.
iter
(
)
.
max
(
)
.
unwrap_or
(
&
0
)
;
for
idx
in
0
.
.
(
size
as
isize
)
{
matrix
.
slice_mut
(
s
!
[
idx
.
.
idx
+
1
.
.
idx
+
1
]
)
.
fill
(
max
)
;
}
let
initial
=
42
;
matrix
.
slice_mut
(
s
!
[
0
.
.
.
.
1
]
)
.
fill
(
initial
)
;
let
brute_force
=
brute_force
:
:
column_minima
(
&
matrix
)
.
iter
(
)
.
enumerate
(
)
.
map
(
|
(
j
&
i
)
|
(
i
matrix
[
[
i
j
]
]
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
online
=
online_column_minima
(
initial
size
|
_
i
j
|
matrix
[
[
i
j
]
]
)
;
assert_eq
!
(
brute_force
online
"
brute
force
and
online
differ
on
:
\
n
{
:
3
?
}
"
matrix
)
;
}
}
}
