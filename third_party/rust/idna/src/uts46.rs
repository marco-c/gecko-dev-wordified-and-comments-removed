use
crate
:
:
punycode
:
:
Decoder
;
use
crate
:
:
punycode
:
:
InternalCaller
;
use
alloc
:
:
borrow
:
:
Cow
;
use
alloc
:
:
string
:
:
String
;
use
core
:
:
fmt
:
:
Write
;
use
icu_normalizer
:
:
properties
:
:
CanonicalCombiningClassMap
;
use
icu_normalizer
:
:
uts46
:
:
Uts46Mapper
;
use
icu_properties
:
:
maps
:
:
CodePointMapDataBorrowed
;
use
icu_properties
:
:
BidiClass
;
use
icu_properties
:
:
CanonicalCombiningClass
;
use
icu_properties
:
:
GeneralCategory
;
use
icu_properties
:
:
JoiningType
;
use
smallvec
:
:
SmallVec
;
use
utf8_iter
:
:
Utf8CharsEx
;
const
PUNYCODE_DECODE_MAX_INPUT_LENGTH
:
usize
=
2000
;
const
PUNYCODE_ENCODE_MAX_INPUT_LENGTH
:
usize
=
1000
;
#
[
derive
(
Debug
PartialEq
Eq
)
]
enum
RtlNumeralState
{
Undecided
European
Arabic
}
const
fn
upper_case_mask
(
)
-
>
u128
{
let
mut
accu
=
0u128
;
let
mut
b
=
0u8
;
while
b
<
128
{
if
(
b
>
=
b
'
A
'
)
&
&
(
b
<
=
b
'
Z
'
)
{
accu
|
=
1u128
<
<
b
;
}
b
+
=
1
;
}
accu
}
const
UPPER_CASE_MASK
:
u128
=
upper_case_mask
(
)
;
const
fn
glyphless_mask
(
)
-
>
u128
{
let
mut
accu
=
0u128
;
let
mut
b
=
0u8
;
while
b
<
128
{
if
(
b
<
=
b
'
'
)
|
|
(
b
=
=
0x7F
)
{
accu
|
=
1u128
<
<
b
;
}
b
+
=
1
;
}
accu
}
const
GLYPHLESS_MASK
:
u128
=
glyphless_mask
(
)
;
const
DOT_MASK
:
u128
=
1
<
<
b
'
.
'
;
const
fn
ldh_mask
(
)
-
>
u128
{
let
mut
accu
=
0u128
;
let
mut
b
=
0u8
;
while
b
<
128
{
if
!
(
(
b
>
=
b
'
a
'
&
&
b
<
=
b
'
z
'
)
|
|
(
b
>
=
b
'
0
'
&
&
b
<
=
b
'
9
'
)
|
|
b
=
=
b
'
-
'
|
|
b
=
=
b
'
.
'
)
{
accu
|
=
1u128
<
<
b
;
}
b
+
=
1
;
}
accu
}
const
fn
joining_type_to_mask
(
jt
:
JoiningType
)
-
>
u32
{
1u32
<
<
jt
.
0
}
const
LEFT_OR_DUAL_JOINING_MASK
:
u32
=
joining_type_to_mask
(
JoiningType
:
:
LeftJoining
)
|
joining_type_to_mask
(
JoiningType
:
:
DualJoining
)
;
const
RIGHT_OR_DUAL_JOINING_MASK
:
u32
=
joining_type_to_mask
(
JoiningType
:
:
RightJoining
)
|
joining_type_to_mask
(
JoiningType
:
:
DualJoining
)
;
const
fn
bidi_class_to_mask
(
bc
:
BidiClass
)
-
>
u32
{
1u32
<
<
bc
.
0
}
const
RTL_MASK
:
u32
=
bidi_class_to_mask
(
BidiClass
:
:
RightToLeft
)
|
bidi_class_to_mask
(
BidiClass
:
:
ArabicLetter
)
|
bidi_class_to_mask
(
BidiClass
:
:
ArabicNumber
)
;
const
FIRST_BC_MASK
:
u32
=
bidi_class_to_mask
(
BidiClass
:
:
LeftToRight
)
|
bidi_class_to_mask
(
BidiClass
:
:
RightToLeft
)
|
bidi_class_to_mask
(
BidiClass
:
:
ArabicLetter
)
;
const
LAST_LTR_MASK
:
u32
=
bidi_class_to_mask
(
BidiClass
:
:
LeftToRight
)
|
bidi_class_to_mask
(
BidiClass
:
:
EuropeanNumber
)
;
const
LAST_RTL_MASK
:
u32
=
bidi_class_to_mask
(
BidiClass
:
:
RightToLeft
)
|
bidi_class_to_mask
(
BidiClass
:
:
ArabicLetter
)
|
bidi_class_to_mask
(
BidiClass
:
:
EuropeanNumber
)
|
bidi_class_to_mask
(
BidiClass
:
:
ArabicNumber
)
;
const
MIDDLE_LTR_MASK
:
u32
=
bidi_class_to_mask
(
BidiClass
:
:
LeftToRight
)
|
bidi_class_to_mask
(
BidiClass
:
:
EuropeanNumber
)
|
bidi_class_to_mask
(
BidiClass
:
:
EuropeanSeparator
)
|
bidi_class_to_mask
(
BidiClass
:
:
CommonSeparator
)
|
bidi_class_to_mask
(
BidiClass
:
:
EuropeanTerminator
)
|
bidi_class_to_mask
(
BidiClass
:
:
OtherNeutral
)
|
bidi_class_to_mask
(
BidiClass
:
:
BoundaryNeutral
)
|
bidi_class_to_mask
(
BidiClass
:
:
NonspacingMark
)
;
const
MIDDLE_RTL_MASK
:
u32
=
bidi_class_to_mask
(
BidiClass
:
:
RightToLeft
)
|
bidi_class_to_mask
(
BidiClass
:
:
ArabicLetter
)
|
bidi_class_to_mask
(
BidiClass
:
:
ArabicNumber
)
|
bidi_class_to_mask
(
BidiClass
:
:
EuropeanNumber
)
|
bidi_class_to_mask
(
BidiClass
:
:
EuropeanSeparator
)
|
bidi_class_to_mask
(
BidiClass
:
:
CommonSeparator
)
|
bidi_class_to_mask
(
BidiClass
:
:
EuropeanTerminator
)
|
bidi_class_to_mask
(
BidiClass
:
:
OtherNeutral
)
|
bidi_class_to_mask
(
BidiClass
:
:
BoundaryNeutral
)
|
bidi_class_to_mask
(
BidiClass
:
:
NonspacingMark
)
;
const
fn
general_category_to_mask
(
gc
:
GeneralCategory
)
-
>
u32
{
1
<
<
(
gc
as
u32
)
}
const
MARK_MASK
:
u32
=
general_category_to_mask
(
GeneralCategory
:
:
NonspacingMark
)
|
general_category_to_mask
(
GeneralCategory
:
:
SpacingMark
)
|
general_category_to_mask
(
GeneralCategory
:
:
EnclosingMark
)
;
const
PUNYCODE_PREFIX
:
u32
=
(
(
b
'
-
'
as
u32
)
<
<
24
)
|
(
(
b
'
-
'
as
u32
)
<
<
16
)
|
(
(
b
'
N
'
as
u32
)
<
<
8
)
|
b
'
X
'
as
u32
;
const
PUNYCODE_PREFIX_MASK
:
u32
=
(
0xFF
<
<
24
)
|
(
0xFF
<
<
16
)
|
(
0xDF
<
<
8
)
|
0xDF
;
fn
write_punycode_label
<
W
:
Write
+
?
Sized
>
(
label
:
&
[
char
]
sink
:
&
mut
W
)
-
>
Result
<
(
)
ProcessingError
>
{
sink
.
write_str
(
"
xn
-
-
"
)
?
;
crate
:
:
punycode
:
:
encode_into
:
:
<
_
_
InternalCaller
>
(
label
.
iter
(
)
.
copied
(
)
sink
)
?
;
Ok
(
(
)
)
}
#
[
inline
(
always
)
]
fn
has_punycode_prefix
(
slice
:
&
[
u8
]
)
-
>
bool
{
if
slice
.
len
(
)
<
4
{
return
false
;
}
let
a
=
slice
[
0
]
;
let
b
=
slice
[
1
]
;
let
c
=
slice
[
2
]
;
let
d
=
slice
[
3
]
;
let
u
=
(
u32
:
:
from
(
d
)
<
<
24
)
|
(
u32
:
:
from
(
c
)
<
<
16
)
|
(
u32
:
:
from
(
b
)
<
<
8
)
|
u32
:
:
from
(
a
)
;
(
u
&
PUNYCODE_PREFIX_MASK
)
=
=
PUNYCODE_PREFIX
}
#
[
inline
(
always
)
]
fn
in_inclusive_range8
(
u
:
u8
start
:
u8
end
:
u8
)
-
>
bool
{
u
.
wrapping_sub
(
start
)
<
=
(
end
-
start
)
}
#
[
inline
(
always
)
]
fn
in_inclusive_range_char
(
c
:
char
start
:
char
end
:
char
)
-
>
bool
{
u32
:
:
from
(
c
)
.
wrapping_sub
(
u32
:
:
from
(
start
)
)
<
=
(
u32
:
:
from
(
end
)
-
u32
:
:
from
(
start
)
)
}
#
[
inline
(
always
)
]
fn
is_passthrough_ascii_label
(
label
:
&
[
u8
]
)
-
>
bool
{
if
label
.
len
(
)
>
=
4
&
&
label
[
2
]
=
=
b
'
-
'
&
&
label
[
3
]
=
=
b
'
-
'
{
return
false
;
}
if
let
Some
(
(
&
first
tail
)
)
=
label
.
split_first
(
)
{
if
!
in_inclusive_range8
(
first
b
'
a
'
b
'
z
'
)
{
return
false
;
}
for
&
b
in
tail
{
if
in_inclusive_range8
(
b
b
'
a
'
b
'
z
'
)
{
continue
;
}
if
in_inclusive_range8
(
b
b
'
0
'
b
'
9
'
)
{
continue
;
}
if
b
=
=
b
'
-
'
{
continue
;
}
return
false
;
}
label
.
last
(
)
!
=
Some
(
&
b
'
-
'
)
}
else
{
true
}
}
#
[
inline
(
always
)
]
fn
split_ascii_fast_path_prefix
(
label
:
&
[
u8
]
)
-
>
(
&
[
u8
]
&
[
u8
]
)
{
if
let
Some
(
pos
)
=
label
.
iter
(
)
.
position
(
|
b
|
!
b
.
is_ascii
(
)
)
{
if
pos
=
=
0
{
(
&
[
]
label
)
}
else
{
let
(
head
tail
)
=
label
.
split_at
(
pos
-
1
)
;
(
head
tail
)
}
}
else
{
(
label
&
[
]
)
}
}
#
[
inline
(
always
)
]
fn
apply_ascii_deny_list_to_lower_cased_unicode
(
c
:
char
deny_list
:
u128
)
-
>
char
{
if
let
Some
(
shifted
)
=
1u128
.
checked_shl
(
u32
:
:
from
(
c
)
)
{
if
(
deny_list
&
shifted
)
=
=
0
{
c
}
else
{
'
\
u
{
FFFD
}
'
}
}
else
{
c
}
}
#
[
inline
(
always
)
]
fn
apply_ascii_deny_list_to_potentially_upper_case_ascii
(
b
:
u8
deny_list
:
u128
)
-
>
char
{
if
(
deny_list
&
(
1u128
<
<
b
)
)
=
=
0
{
return
char
:
:
from
(
b
)
;
}
if
in_inclusive_range8
(
b
b
'
A
'
b
'
Z
'
)
{
return
char
:
:
from
(
b
+
0x20
)
;
}
'
\
u
{
FFFD
}
'
}
#
[
inline
(
always
)
]
fn
is_ascii
(
label
:
&
[
char
]
)
-
>
bool
{
for
c
in
label
.
iter
(
)
{
if
!
c
.
is_ascii
(
)
{
return
false
;
}
}
true
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
)
]
enum
PunycodeClassification
{
Ascii
Unicode
Error
}
#
[
inline
(
always
)
]
fn
classify_for_punycode
(
label
:
&
[
char
]
)
-
>
PunycodeClassification
{
let
mut
iter
=
label
.
iter
(
)
.
copied
(
)
;
loop
{
if
let
Some
(
c
)
=
iter
.
next
(
)
{
if
c
.
is_ascii
(
)
{
continue
;
}
if
c
=
=
'
\
u
{
FFFD
}
'
{
return
PunycodeClassification
:
:
Error
;
}
for
c
in
iter
{
if
c
=
=
'
\
u
{
FFFD
}
'
{
return
PunycodeClassification
:
:
Error
;
}
}
return
PunycodeClassification
:
:
Unicode
;
}
return
PunycodeClassification
:
:
Ascii
;
}
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
)
]
#
[
repr
(
transparent
)
]
pub
struct
AsciiDenyList
{
bits
:
u128
}
impl
AsciiDenyList
{
pub
const
fn
new
(
deny_glyphless
:
bool
deny_list
:
&
str
)
-
>
Self
{
let
mut
bits
=
UPPER_CASE_MASK
;
if
deny_glyphless
{
bits
|
=
GLYPHLESS_MASK
;
}
let
mut
i
=
0
;
let
bytes
=
deny_list
.
as_bytes
(
)
;
while
i
<
bytes
.
len
(
)
{
let
b
=
bytes
[
i
]
;
assert
!
(
b
<
0x80
"
ASCII
deny
list
must
be
ASCII
.
"
)
;
assert
!
(
b
!
=
b
'
.
'
"
ASCII
deny
list
must
not
contain
the
dot
.
"
)
;
assert
!
(
b
!
=
b
'
-
'
"
ASCII
deny
list
must
not
contain
the
hyphen
.
"
)
;
assert
!
(
!
(
(
b
>
=
b
'
0
'
)
&
&
(
b
<
=
b
'
9
'
)
)
"
ASCII
deny
list
must
not
contain
digits
.
"
)
;
assert
!
(
!
(
(
b
>
=
b
'
a
'
)
&
&
(
b
<
=
b
'
z
'
)
)
"
ASCII
deny
list
must
not
contain
letters
.
"
)
;
assert
!
(
!
(
(
b
>
=
b
'
A
'
)
&
&
(
b
<
=
b
'
Z
'
)
)
"
ASCII
deny
list
must
not
contain
letters
.
"
)
;
bits
|
=
1u128
<
<
b
;
i
+
=
1
;
}
AsciiDenyList
{
bits
}
}
pub
const
EMPTY
:
AsciiDenyList
=
AsciiDenyList
:
:
new
(
false
"
"
)
;
pub
const
STD3
:
AsciiDenyList
=
AsciiDenyList
{
bits
:
ldh_mask
(
)
}
;
pub
const
URL
:
AsciiDenyList
=
AsciiDenyList
:
:
new
(
true
"
%
#
/
:
<
>
?
[
\
\
]
^
|
"
)
;
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
)
]
#
[
non_exhaustive
]
pub
enum
Hyphens
{
Allow
CheckFirstLast
Check
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
)
]
#
[
non_exhaustive
]
pub
enum
DnsLength
{
Ignore
VerifyAllowRootDot
Verify
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
)
]
#
[
non_exhaustive
]
pub
enum
ErrorPolicy
{
FailFast
MarkErrors
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
Debug
)
]
pub
enum
ProcessingSuccess
{
Passthrough
WroteToSink
}
#
[
derive
(
PartialEq
Eq
Copy
Clone
Debug
)
]
pub
enum
ProcessingError
{
ValidityError
SinkError
}
impl
From
<
core
:
:
fmt
:
:
Error
>
for
ProcessingError
{
fn
from
(
_
:
core
:
:
fmt
:
:
Error
)
-
>
Self
{
ProcessingError
:
:
SinkError
}
}
impl
From
<
crate
:
:
punycode
:
:
PunycodeEncodeError
>
for
ProcessingError
{
fn
from
(
_
:
crate
:
:
punycode
:
:
PunycodeEncodeError
)
-
>
Self
{
unreachable
!
(
"
Punycode
overflows
should
not
be
possible
due
to
PUNYCODE_ENCODE_MAX_INPUT_LENGTH
"
)
;
}
}
#
[
derive
(
Debug
Clone
Copy
)
]
enum
AlreadyAsciiLabel
<
'
a
>
{
MixedCaseAscii
(
&
'
a
[
u8
]
)
MixedCasePunycode
(
&
'
a
[
u8
]
)
Other
}
pub
fn
verify_dns_length
(
domain_name
:
&
str
allow_trailing_dot
:
bool
)
-
>
bool
{
let
bytes
=
domain_name
.
as_bytes
(
)
;
debug_assert
!
(
bytes
.
is_ascii
(
)
)
;
let
domain_name_without_trailing_dot
=
if
let
Some
(
without
)
=
bytes
.
strip_suffix
(
b
"
.
"
)
{
if
!
allow_trailing_dot
{
return
false
;
}
without
}
else
{
bytes
}
;
if
domain_name_without_trailing_dot
.
len
(
)
>
253
{
return
false
;
}
for
label
in
domain_name_without_trailing_dot
.
split
(
|
b
|
*
b
=
=
b
'
.
'
)
{
if
label
.
is_empty
(
)
{
return
false
;
}
if
label
.
len
(
)
>
63
{
return
false
;
}
}
true
}
pub
struct
Uts46
{
mapper
:
Uts46Mapper
canonical_combining_class
:
CanonicalCombiningClassMap
general_category
:
CodePointMapDataBorrowed
<
'
static
GeneralCategory
>
bidi_class
:
CodePointMapDataBorrowed
<
'
static
BidiClass
>
joining_type
:
CodePointMapDataBorrowed
<
'
static
JoiningType
>
}
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
impl
Default
for
Uts46
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
Uts46
{
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
pub
const
fn
new
(
)
-
>
Self
{
Self
{
mapper
:
Uts46Mapper
:
:
new
(
)
canonical_combining_class
:
CanonicalCombiningClassMap
:
:
new
(
)
general_category
:
icu_properties
:
:
maps
:
:
general_category
(
)
bidi_class
:
icu_properties
:
:
maps
:
:
bidi_class
(
)
joining_type
:
icu_properties
:
:
maps
:
:
joining_type
(
)
}
}
pub
fn
to_ascii
<
'
a
>
(
&
self
domain_name
:
&
'
a
[
u8
]
ascii_deny_list
:
AsciiDenyList
hyphens
:
Hyphens
dns_length
:
DnsLength
)
-
>
Result
<
Cow
<
'
a
str
>
crate
:
:
Errors
>
{
let
mut
s
=
String
:
:
new
(
)
;
match
self
.
process
(
domain_name
ascii_deny_list
hyphens
ErrorPolicy
:
:
FailFast
|
_
_
_
|
false
&
mut
s
None
)
{
Ok
(
ProcessingSuccess
:
:
Passthrough
)
=
>
{
let
cow
=
Cow
:
:
Borrowed
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
domain_name
)
}
)
;
if
dns_length
!
=
DnsLength
:
:
Ignore
&
&
!
verify_dns_length
(
&
cow
dns_length
=
=
DnsLength
:
:
VerifyAllowRootDot
)
{
Err
(
crate
:
:
Errors
:
:
default
(
)
)
}
else
{
Ok
(
cow
)
}
}
Ok
(
ProcessingSuccess
:
:
WroteToSink
)
=
>
{
let
cow
:
Cow
<
'
_
str
>
=
Cow
:
:
Owned
(
s
)
;
if
dns_length
!
=
DnsLength
:
:
Ignore
&
&
!
verify_dns_length
(
&
cow
dns_length
=
=
DnsLength
:
:
VerifyAllowRootDot
)
{
Err
(
crate
:
:
Errors
:
:
default
(
)
)
}
else
{
Ok
(
cow
)
}
}
Err
(
ProcessingError
:
:
ValidityError
)
=
>
Err
(
crate
:
:
Errors
:
:
default
(
)
)
Err
(
ProcessingError
:
:
SinkError
)
=
>
unreachable
!
(
)
}
}
pub
fn
to_unicode
<
'
a
>
(
&
self
domain_name
:
&
'
a
[
u8
]
ascii_deny_list
:
AsciiDenyList
hyphens
:
Hyphens
)
-
>
(
Cow
<
'
a
str
>
Result
<
(
)
crate
:
:
Errors
>
)
{
self
.
to_user_interface
(
domain_name
ascii_deny_list
hyphens
|
_
_
_
|
true
)
}
pub
fn
to_user_interface
<
'
a
OutputUnicode
:
FnMut
(
&
[
char
]
&
[
char
]
bool
)
-
>
bool
>
(
&
self
domain_name
:
&
'
a
[
u8
]
ascii_deny_list
:
AsciiDenyList
hyphens
:
Hyphens
output_as_unicode
:
OutputUnicode
)
-
>
(
Cow
<
'
a
str
>
Result
<
(
)
crate
:
:
Errors
>
)
{
let
mut
s
=
String
:
:
new
(
)
;
match
self
.
process
(
domain_name
ascii_deny_list
hyphens
ErrorPolicy
:
:
MarkErrors
output_as_unicode
&
mut
s
None
)
{
Ok
(
ProcessingSuccess
:
:
Passthrough
)
=
>
(
Cow
:
:
Borrowed
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
domain_name
)
}
)
Ok
(
(
)
)
)
Ok
(
ProcessingSuccess
:
:
WroteToSink
)
=
>
(
Cow
:
:
Owned
(
s
)
Ok
(
(
)
)
)
Err
(
ProcessingError
:
:
ValidityError
)
=
>
(
Cow
:
:
Owned
(
s
)
Err
(
crate
:
:
Errors
:
:
default
(
)
)
)
Err
(
ProcessingError
:
:
SinkError
)
=
>
unreachable
!
(
)
}
}
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
pub
fn
process
<
W
:
Write
+
?
Sized
OutputUnicode
:
FnMut
(
&
[
char
]
&
[
char
]
bool
)
-
>
bool
>
(
&
self
domain_name
:
&
[
u8
]
ascii_deny_list
:
AsciiDenyList
hyphens
:
Hyphens
error_policy
:
ErrorPolicy
mut
output_as_unicode
:
OutputUnicode
sink
:
&
mut
W
ascii_sink
:
Option
<
&
mut
W
>
)
-
>
Result
<
ProcessingSuccess
ProcessingError
>
{
let
fail_fast
=
error_policy
=
=
ErrorPolicy
:
:
FailFast
;
let
mut
domain_buffer
=
SmallVec
:
:
<
[
char
;
253
]
>
:
:
new
(
)
;
let
mut
already_punycode
=
SmallVec
:
:
<
[
AlreadyAsciiLabel
;
8
]
>
:
:
new
(
)
;
let
(
passthrough_up_to
is_bidi
had_errors
)
=
self
.
process_inner
(
domain_name
ascii_deny_list
hyphens
fail_fast
&
mut
domain_buffer
&
mut
already_punycode
)
;
if
passthrough_up_to
=
=
domain_name
.
len
(
)
{
debug_assert
!
(
!
had_errors
)
;
return
Ok
(
ProcessingSuccess
:
:
Passthrough
)
;
}
if
fail_fast
&
&
had_errors
{
return
Err
(
ProcessingError
:
:
ValidityError
)
;
}
debug_assert_eq
!
(
had_errors
domain_buffer
.
contains
(
&
'
\
u
{
FFFD
}
'
)
)
;
let
without_dot
=
if
let
Some
(
without_dot
)
=
domain_buffer
.
strip_suffix
(
&
[
'
.
'
]
)
{
without_dot
}
else
{
&
domain_buffer
[
.
.
]
}
;
let
tld
=
without_dot
.
rsplit
(
|
c
|
*
c
=
=
'
.
'
)
.
next
(
)
.
unwrap
(
)
;
let
mut
had_unicode_output
=
false
;
let
mut
seen_label
=
false
;
let
mut
already_punycode_iter
=
already_punycode
.
iter
(
)
;
let
mut
passthrough_up_to_extended
=
passthrough_up_to
;
let
mut
flushed_prefix
=
false
;
for
label
in
domain_buffer
.
split
(
|
c
|
*
c
=
=
'
.
'
)
{
let
input_punycode
=
*
already_punycode_iter
.
next
(
)
.
unwrap
(
)
;
if
seen_label
{
if
flushed_prefix
{
sink
.
write_char
(
'
.
'
)
?
;
}
else
{
debug_assert_eq
!
(
domain_name
[
passthrough_up_to_extended
]
b
'
.
'
)
;
passthrough_up_to_extended
+
=
1
;
if
passthrough_up_to_extended
=
=
domain_name
.
len
(
)
{
debug_assert
!
(
!
had_errors
)
;
return
Ok
(
ProcessingSuccess
:
:
Passthrough
)
;
}
}
}
seen_label
=
true
;
if
let
AlreadyAsciiLabel
:
:
MixedCaseAscii
(
mixed_case
)
=
input_punycode
{
if
let
Some
(
first_upper_case
)
=
mixed_case
.
iter
(
)
.
position
(
|
c
|
c
.
is_ascii_uppercase
(
)
)
{
let
(
head
tail
)
=
mixed_case
.
split_at
(
first_upper_case
)
;
let
slice_to_write
=
if
flushed_prefix
{
head
}
else
{
flushed_prefix
=
true
;
passthrough_up_to_extended
+
=
head
.
len
(
)
;
debug_assert_ne
!
(
passthrough_up_to_extended
domain_name
.
len
(
)
)
;
&
domain_name
[
.
.
passthrough_up_to_extended
]
}
;
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
slice_to_write
)
}
)
?
;
for
c
in
tail
.
iter
(
)
{
sink
.
write_char
(
char
:
:
from
(
c
.
to_ascii_lowercase
(
)
)
)
?
;
}
}
else
if
flushed_prefix
{
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
mixed_case
)
}
)
?
;
}
else
{
passthrough_up_to_extended
+
=
mixed_case
.
len
(
)
;
if
passthrough_up_to_extended
=
=
domain_name
.
len
(
)
{
debug_assert
!
(
!
had_errors
)
;
return
Ok
(
ProcessingSuccess
:
:
Passthrough
)
;
}
}
continue
;
}
let
potentially_punycode
=
if
fail_fast
{
debug_assert
!
(
classify_for_punycode
(
label
)
!
=
PunycodeClassification
:
:
Error
)
;
!
is_ascii
(
label
)
}
else
{
classify_for_punycode
(
label
)
=
=
PunycodeClassification
:
:
Unicode
}
;
let
passthrough
=
if
potentially_punycode
{
let
unicode
=
output_as_unicode
(
label
tld
is_bidi
)
;
had_unicode_output
|
=
unicode
;
unicode
}
else
{
true
}
;
if
passthrough
{
if
!
flushed_prefix
{
flushed_prefix
=
true
;
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
&
domain_name
[
.
.
passthrough_up_to_extended
]
)
}
)
?
;
}
for
c
in
label
.
iter
(
)
.
copied
(
)
{
sink
.
write_char
(
c
)
?
;
}
}
else
if
let
AlreadyAsciiLabel
:
:
MixedCasePunycode
(
mixed_case
)
=
input_punycode
{
if
let
Some
(
first_upper_case
)
=
mixed_case
.
iter
(
)
.
position
(
|
c
|
c
.
is_ascii_uppercase
(
)
)
{
let
(
head
tail
)
=
mixed_case
.
split_at
(
first_upper_case
)
;
let
slice_to_write
=
if
flushed_prefix
{
head
}
else
{
flushed_prefix
=
true
;
passthrough_up_to_extended
+
=
head
.
len
(
)
;
debug_assert_ne
!
(
passthrough_up_to_extended
domain_name
.
len
(
)
)
;
&
domain_name
[
.
.
passthrough_up_to_extended
]
}
;
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
slice_to_write
)
}
)
?
;
for
c
in
tail
.
iter
(
)
{
sink
.
write_char
(
char
:
:
from
(
c
.
to_ascii_lowercase
(
)
)
)
?
;
}
}
else
if
flushed_prefix
{
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
mixed_case
)
}
)
?
;
}
else
{
passthrough_up_to_extended
+
=
mixed_case
.
len
(
)
;
if
passthrough_up_to_extended
=
=
domain_name
.
len
(
)
{
debug_assert
!
(
!
had_errors
)
;
return
Ok
(
ProcessingSuccess
:
:
Passthrough
)
;
}
}
}
else
{
if
!
flushed_prefix
{
flushed_prefix
=
true
;
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
&
domain_name
[
.
.
passthrough_up_to_extended
]
)
}
)
?
;
}
write_punycode_label
(
label
sink
)
?
;
}
}
if
had_errors
{
return
Err
(
ProcessingError
:
:
ValidityError
)
;
}
if
had_unicode_output
{
if
let
Some
(
sink
)
=
ascii_sink
{
let
mut
seen_label
=
false
;
let
mut
already_punycode_iter
=
already_punycode
.
iter
(
)
;
let
mut
passthrough_up_to_extended
=
passthrough_up_to
;
let
mut
flushed_prefix
=
false
;
for
label
in
domain_buffer
.
split
(
|
c
|
*
c
=
=
'
.
'
)
{
let
input_punycode
=
*
already_punycode_iter
.
next
(
)
.
unwrap
(
)
;
if
seen_label
{
if
flushed_prefix
{
sink
.
write_char
(
'
.
'
)
?
;
}
else
{
debug_assert_eq
!
(
domain_name
[
passthrough_up_to_extended
]
b
'
.
'
)
;
passthrough_up_to_extended
+
=
1
;
}
}
seen_label
=
true
;
if
let
AlreadyAsciiLabel
:
:
MixedCaseAscii
(
mixed_case
)
=
input_punycode
{
if
let
Some
(
first_upper_case
)
=
mixed_case
.
iter
(
)
.
position
(
|
c
|
c
.
is_ascii_uppercase
(
)
)
{
let
(
head
tail
)
=
mixed_case
.
split_at
(
first_upper_case
)
;
let
slice_to_write
=
if
flushed_prefix
{
head
}
else
{
flushed_prefix
=
true
;
passthrough_up_to_extended
+
=
head
.
len
(
)
;
debug_assert_ne
!
(
passthrough_up_to_extended
domain_name
.
len
(
)
)
;
&
domain_name
[
.
.
passthrough_up_to_extended
]
}
;
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
slice_to_write
)
}
)
?
;
for
c
in
tail
.
iter
(
)
{
sink
.
write_char
(
char
:
:
from
(
c
.
to_ascii_lowercase
(
)
)
)
?
;
}
}
else
if
flushed_prefix
{
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
mixed_case
)
}
)
?
;
}
else
{
passthrough_up_to_extended
+
=
mixed_case
.
len
(
)
;
}
continue
;
}
if
is_ascii
(
label
)
{
if
!
flushed_prefix
{
flushed_prefix
=
true
;
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
&
domain_name
[
.
.
passthrough_up_to_extended
]
)
}
)
?
;
}
for
c
in
label
.
iter
(
)
.
copied
(
)
{
sink
.
write_char
(
c
)
?
;
}
}
else
if
let
AlreadyAsciiLabel
:
:
MixedCasePunycode
(
mixed_case
)
=
input_punycode
{
if
let
Some
(
first_upper_case
)
=
mixed_case
.
iter
(
)
.
position
(
|
c
|
c
.
is_ascii_uppercase
(
)
)
{
let
(
head
tail
)
=
mixed_case
.
split_at
(
first_upper_case
)
;
let
slice_to_write
=
if
flushed_prefix
{
head
}
else
{
flushed_prefix
=
true
;
passthrough_up_to_extended
+
=
head
.
len
(
)
;
debug_assert_ne
!
(
passthrough_up_to_extended
domain_name
.
len
(
)
)
;
&
domain_name
[
.
.
passthrough_up_to_extended
]
}
;
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
slice_to_write
)
}
)
?
;
for
c
in
tail
.
iter
(
)
{
sink
.
write_char
(
char
:
:
from
(
c
.
to_ascii_lowercase
(
)
)
)
?
;
}
}
else
if
flushed_prefix
{
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
mixed_case
)
}
)
?
;
}
else
{
passthrough_up_to_extended
+
=
mixed_case
.
len
(
)
;
}
}
else
{
if
!
flushed_prefix
{
flushed_prefix
=
true
;
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
&
domain_name
[
.
.
passthrough_up_to_extended
]
)
}
)
?
;
}
write_punycode_label
(
label
sink
)
?
;
}
}
if
!
flushed_prefix
{
sink
.
write_str
(
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
&
domain_name
[
.
.
passthrough_up_to_extended
]
)
}
)
?
;
}
}
}
Ok
(
ProcessingSuccess
:
:
WroteToSink
)
}
#
[
inline
(
never
)
]
fn
process_inner
<
'
a
>
(
&
self
domain_name
:
&
'
a
[
u8
]
ascii_deny_list
:
AsciiDenyList
hyphens
:
Hyphens
fail_fast
:
bool
domain_buffer
:
&
mut
SmallVec
<
[
char
;
253
]
>
already_punycode
:
&
mut
SmallVec
<
[
AlreadyAsciiLabel
<
'
a
>
;
8
]
>
)
-
>
(
usize
bool
bool
)
{
let
mut
iter
=
domain_name
.
iter
(
)
;
let
mut
most_recent_label_start
=
iter
.
clone
(
)
;
let
tail
=
loop
{
if
let
Some
(
&
b
)
=
iter
.
next
(
)
{
if
in_inclusive_range8
(
b
b
'
a
'
b
'
z
'
)
{
continue
;
}
if
b
=
=
b
'
.
'
{
most_recent_label_start
=
iter
.
clone
(
)
;
continue
;
}
break
most_recent_label_start
.
as_slice
(
)
;
}
else
{
return
(
domain_name
.
len
(
)
false
false
)
;
}
}
;
let
deny_list
=
ascii_deny_list
.
bits
;
let
deny_list_deny_dot
=
deny_list
|
DOT_MASK
;
let
mut
had_errors
=
false
;
let
mut
passthrough_up_to
=
domain_name
.
len
(
)
-
tail
.
len
(
)
;
let
mut
current_label_start
;
let
mut
seen_label
=
false
;
let
mut
in_prefix
=
true
;
for
label
in
tail
.
split
(
|
b
|
*
b
=
=
b
'
.
'
)
{
if
in_prefix
&
&
is_passthrough_ascii_label
(
label
)
{
if
seen_label
{
debug_assert_eq
!
(
domain_name
[
passthrough_up_to
]
b
'
.
'
)
;
passthrough_up_to
+
=
1
;
}
seen_label
=
true
;
passthrough_up_to
+
=
label
.
len
(
)
;
continue
;
}
if
seen_label
{
if
in_prefix
{
debug_assert_eq
!
(
domain_name
[
passthrough_up_to
]
b
'
.
'
)
;
passthrough_up_to
+
=
1
;
}
else
{
domain_buffer
.
push
(
'
.
'
)
;
}
}
seen_label
=
true
;
in_prefix
=
false
;
current_label_start
=
domain_buffer
.
len
(
)
;
if
!
label
.
is_empty
(
)
{
let
(
ascii
non_ascii
)
=
split_ascii_fast_path_prefix
(
label
)
;
let
non_punycode_ascii_label
=
if
non_ascii
.
is_empty
(
)
{
if
has_punycode_prefix
(
ascii
)
{
if
(
ascii
.
last
(
)
!
=
Some
(
&
b
'
-
'
)
)
&
&
(
ascii
.
len
(
)
-
4
<
=
PUNYCODE_DECODE_MAX_INPUT_LENGTH
)
{
if
let
Ok
(
decode
)
=
Decoder
:
:
default
(
)
.
decode
:
:
<
u8
InternalCaller
>
(
&
ascii
[
4
.
.
]
)
{
let
mut
label_buffer
=
SmallVec
:
:
<
[
char
;
59
]
>
:
:
new
(
)
;
label_buffer
.
extend
(
decode
)
;
if
self
.
after_punycode_decode
(
domain_buffer
current_label_start
&
label_buffer
deny_list_deny_dot
fail_fast
&
mut
had_errors
)
{
return
(
0
false
true
)
;
}
if
self
.
check_label
(
hyphens
&
mut
domain_buffer
[
current_label_start
.
.
]
fail_fast
&
mut
had_errors
true
true
)
{
return
(
0
false
true
)
;
}
}
else
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
domain_buffer
.
push
(
'
\
u
{
FFFD
}
'
)
;
let
mut
iter
=
ascii
.
iter
(
)
;
let
_
=
iter
.
next
(
)
;
domain_buffer
.
extend
(
iter
.
map
(
|
c
|
{
apply_ascii_deny_list_to_potentially_upper_case_ascii
(
*
c
deny_list
)
}
)
)
;
}
;
already_punycode
.
push
(
AlreadyAsciiLabel
:
:
MixedCasePunycode
(
label
)
)
;
continue
;
}
else
if
fail_fast
{
return
(
0
false
true
)
;
}
false
}
else
{
true
}
}
else
{
false
}
;
for
c
in
ascii
.
iter
(
)
.
map
(
|
c
|
{
apply_ascii_deny_list_to_potentially_upper_case_ascii
(
*
c
deny_list
)
}
)
{
if
c
=
=
'
\
u
{
FFFD
}
'
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
}
domain_buffer
.
push
(
c
)
;
}
if
non_punycode_ascii_label
{
if
hyphens
!
=
Hyphens
:
:
Allow
&
&
check_hyphens
(
&
mut
domain_buffer
[
current_label_start
.
.
]
hyphens
=
=
Hyphens
:
:
CheckFirstLast
fail_fast
&
mut
had_errors
)
{
return
(
0
false
true
)
;
}
already_punycode
.
push
(
if
had_errors
{
AlreadyAsciiLabel
:
:
Other
}
else
{
AlreadyAsciiLabel
:
:
MixedCaseAscii
(
label
)
}
)
;
continue
;
}
already_punycode
.
push
(
AlreadyAsciiLabel
:
:
Other
)
;
let
mut
first_needs_combining_mark_check
=
ascii
.
is_empty
(
)
;
let
mut
needs_contextj_check
=
!
non_ascii
.
is_empty
(
)
;
let
mut
mapping
=
self
.
mapper
.
map_normalize
(
non_ascii
.
chars
(
)
)
.
map
(
|
c
|
apply_ascii_deny_list_to_lower_cased_unicode
(
c
deny_list
)
)
;
loop
{
let
n
=
mapping
.
next
(
)
;
match
n
{
None
|
Some
(
'
.
'
)
=
>
{
if
domain_buffer
[
current_label_start
.
.
]
.
starts_with
(
&
[
'
x
'
'
n
'
'
-
'
'
-
'
]
)
{
let
mut
punycode_precondition_failed
=
false
;
for
c
in
domain_buffer
[
current_label_start
+
4
.
.
]
.
iter_mut
(
)
{
if
!
c
.
is_ascii
(
)
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
*
c
=
'
\
u
{
FFFD
}
'
;
punycode_precondition_failed
=
true
;
}
}
if
let
Some
(
last
)
=
domain_buffer
.
last_mut
(
)
{
if
*
last
=
=
'
-
'
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
*
last
=
'
\
u
{
FFFD
}
'
;
punycode_precondition_failed
=
true
;
}
}
else
{
unreachable
!
(
)
;
}
if
domain_buffer
.
len
(
)
-
current_label_start
-
4
>
PUNYCODE_DECODE_MAX_INPUT_LENGTH
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
domain_buffer
[
current_label_start
+
4
+
PUNYCODE_DECODE_MAX_INPUT_LENGTH
]
=
'
\
u
{
FFFD
}
'
;
punycode_precondition_failed
=
true
;
}
if
!
punycode_precondition_failed
{
if
let
Ok
(
decode
)
=
Decoder
:
:
default
(
)
.
decode
:
:
<
char
InternalCaller
>
(
&
domain_buffer
[
current_label_start
+
4
.
.
]
)
{
first_needs_combining_mark_check
=
true
;
needs_contextj_check
=
true
;
let
mut
label_buffer
=
SmallVec
:
:
<
[
char
;
59
]
>
:
:
new
(
)
;
label_buffer
.
extend
(
decode
)
;
domain_buffer
.
truncate
(
current_label_start
)
;
if
self
.
after_punycode_decode
(
domain_buffer
current_label_start
&
label_buffer
deny_list_deny_dot
fail_fast
&
mut
had_errors
)
{
return
(
0
false
true
)
;
}
}
else
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
domain_buffer
[
current_label_start
]
=
'
\
u
{
FFFD
}
'
;
needs_contextj_check
=
false
;
first_needs_combining_mark_check
=
false
;
}
;
}
else
{
first_needs_combining_mark_check
=
false
;
needs_contextj_check
=
false
;
}
}
if
self
.
check_label
(
hyphens
&
mut
domain_buffer
[
current_label_start
.
.
]
fail_fast
&
mut
had_errors
first_needs_combining_mark_check
needs_contextj_check
)
{
return
(
0
false
true
)
;
}
if
n
.
is_none
(
)
{
break
;
}
domain_buffer
.
push
(
'
.
'
)
;
current_label_start
=
domain_buffer
.
len
(
)
;
first_needs_combining_mark_check
=
true
;
needs_contextj_check
=
true
;
already_punycode
.
push
(
AlreadyAsciiLabel
:
:
Other
)
;
}
Some
(
c
)
=
>
{
if
c
=
=
'
\
u
{
FFFD
}
'
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
}
domain_buffer
.
push
(
c
)
;
}
}
}
}
else
{
already_punycode
.
push
(
AlreadyAsciiLabel
:
:
MixedCaseAscii
(
label
)
)
;
}
}
let
is_bidi
=
self
.
is_bidi
(
domain_buffer
)
;
if
is_bidi
{
for
label
in
domain_buffer
.
split_mut
(
|
c
|
*
c
=
=
'
.
'
)
{
if
let
Some
(
(
first
tail
)
)
=
label
.
split_first_mut
(
)
{
let
first_bc
=
self
.
bidi_class
.
get
(
*
first
)
;
if
(
FIRST_BC_MASK
&
bidi_class_to_mask
(
first_bc
)
)
=
=
0
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
*
first
=
'
\
u
{
FFFD
}
'
;
continue
;
}
let
is_ltr
=
first_bc
=
=
BidiClass
:
:
LeftToRight
;
let
mut
middle
=
tail
;
#
[
allow
(
clippy
:
:
while_let_loop
)
]
loop
{
if
let
Some
(
(
last
prior
)
)
=
middle
.
split_last_mut
(
)
{
let
last_bc
=
self
.
bidi_class
.
get
(
*
last
)
;
if
last_bc
=
=
BidiClass
:
:
NonspacingMark
{
middle
=
prior
;
continue
;
}
let
last_mask
=
if
is_ltr
{
LAST_LTR_MASK
}
else
{
LAST_RTL_MASK
}
;
if
(
bidi_class_to_mask
(
last_bc
)
&
last_mask
)
=
=
0
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
*
last
=
'
\
u
{
FFFD
}
'
;
}
if
is_ltr
{
for
c
in
prior
.
iter_mut
(
)
{
let
bc
=
self
.
bidi_class
.
get
(
*
c
)
;
if
(
bidi_class_to_mask
(
bc
)
&
MIDDLE_LTR_MASK
)
=
=
0
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
*
c
=
'
\
u
{
FFFD
}
'
;
}
}
}
else
{
let
mut
numeral_state
=
RtlNumeralState
:
:
Undecided
;
for
c
in
prior
.
iter_mut
(
)
{
let
bc
=
self
.
bidi_class
.
get
(
*
c
)
;
if
(
bidi_class_to_mask
(
bc
)
&
MIDDLE_RTL_MASK
)
=
=
0
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
*
c
=
'
\
u
{
FFFD
}
'
;
}
else
{
match
numeral_state
{
RtlNumeralState
:
:
Undecided
=
>
{
if
bc
=
=
BidiClass
:
:
EuropeanNumber
{
numeral_state
=
RtlNumeralState
:
:
European
;
}
else
if
bc
=
=
BidiClass
:
:
ArabicNumber
{
numeral_state
=
RtlNumeralState
:
:
Arabic
;
}
}
RtlNumeralState
:
:
European
=
>
{
if
bc
=
=
BidiClass
:
:
ArabicNumber
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
*
c
=
'
\
u
{
FFFD
}
'
;
}
}
RtlNumeralState
:
:
Arabic
=
>
{
if
bc
=
=
BidiClass
:
:
EuropeanNumber
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
*
c
=
'
\
u
{
FFFD
}
'
;
}
}
}
}
}
if
(
numeral_state
=
=
RtlNumeralState
:
:
European
&
&
last_bc
=
=
BidiClass
:
:
ArabicNumber
)
|
|
(
numeral_state
=
=
RtlNumeralState
:
:
Arabic
&
&
last_bc
=
=
BidiClass
:
:
EuropeanNumber
)
{
if
fail_fast
{
return
(
0
false
true
)
;
}
had_errors
=
true
;
*
last
=
'
\
u
{
FFFD
}
'
;
}
}
break
;
}
else
{
break
;
}
}
}
}
}
(
passthrough_up_to
is_bidi
had_errors
)
}
#
[
inline
(
never
)
]
fn
after_punycode_decode
(
&
self
domain_buffer
:
&
mut
SmallVec
<
[
char
;
253
]
>
current_label_start
:
usize
label_buffer
:
&
[
char
]
deny_list_deny_dot
:
u128
fail_fast
:
bool
had_errors
:
&
mut
bool
)
-
>
bool
{
for
c
in
self
.
mapper
.
normalize_validate
(
label_buffer
.
iter
(
)
.
copied
(
)
)
.
map
(
|
c
|
apply_ascii_deny_list_to_lower_cased_unicode
(
c
deny_list_deny_dot
)
)
{
if
c
=
=
'
\
u
{
FFFD
}
'
{
if
fail_fast
{
return
true
;
}
*
had_errors
=
true
;
}
domain_buffer
.
push
(
c
)
;
}
let
normalized
=
&
mut
domain_buffer
[
current_label_start
.
.
]
;
if
let
Err
(
(
)
)
=
normalized
.
iter_mut
(
)
.
zip
(
label_buffer
.
iter
(
)
)
.
try_for_each
(
|
(
norm_c
decoded_c
)
|
{
if
*
norm_c
=
=
*
decoded_c
{
Ok
(
(
)
)
}
else
{
*
norm_c
=
'
\
u
{
FFFD
}
'
;
Err
(
(
)
)
}
}
)
{
if
fail_fast
{
return
true
;
}
*
had_errors
=
true
;
}
false
}
#
[
inline
(
never
)
]
fn
check_label
(
&
self
hyphens
:
Hyphens
mut_label
:
&
mut
[
char
]
fail_fast
:
bool
had_errors
:
&
mut
bool
first_needs_combining_mark_check
:
bool
needs_contextj_check
:
bool
)
-
>
bool
{
if
hyphens
!
=
Hyphens
:
:
Allow
&
&
check_hyphens
(
mut_label
hyphens
=
=
Hyphens
:
:
CheckFirstLast
fail_fast
had_errors
)
{
return
true
;
}
if
first_needs_combining_mark_check
{
if
let
Some
(
first
)
=
mut_label
.
first_mut
(
)
{
if
(
general_category_to_mask
(
self
.
general_category
.
get
(
*
first
)
)
&
MARK_MASK
)
!
=
0
{
if
fail_fast
{
return
true
;
}
*
had_errors
=
true
;
*
first
=
'
\
u
{
FFFD
}
'
;
}
}
}
if
needs_contextj_check
{
for
i
in
0
.
.
mut_label
.
len
(
)
{
let
c
=
mut_label
[
i
]
;
if
!
in_inclusive_range_char
(
c
'
\
u
{
200C
}
'
'
\
u
{
200D
}
'
)
{
continue
;
}
let
(
head
joiner_and_tail
)
=
mut_label
.
split_at_mut
(
i
)
;
if
let
Some
(
(
joiner
tail
)
)
=
joiner_and_tail
.
split_first_mut
(
)
{
if
let
Some
(
previous
)
=
head
.
last
(
)
{
if
self
.
canonical_combining_class
.
get
(
*
previous
)
=
=
CanonicalCombiningClass
:
:
Virama
{
continue
;
}
}
else
{
if
fail_fast
{
return
true
;
}
*
had_errors
=
true
;
*
joiner
=
'
\
u
{
FFFD
}
'
;
continue
;
}
if
c
=
=
'
\
u
{
200D
}
'
{
if
fail_fast
{
return
true
;
}
*
had_errors
=
true
;
*
joiner
=
'
\
u
{
FFFD
}
'
;
continue
;
}
debug_assert_eq
!
(
c
'
\
u
{
200C
}
'
)
;
if
!
self
.
has_appropriately_joining_char
(
head
.
iter
(
)
.
rev
(
)
.
copied
(
)
LEFT_OR_DUAL_JOINING_MASK
)
|
|
!
self
.
has_appropriately_joining_char
(
tail
.
iter
(
)
.
copied
(
)
RIGHT_OR_DUAL_JOINING_MASK
)
{
if
fail_fast
{
return
true
;
}
*
had_errors
=
true
;
*
joiner
=
'
\
u
{
FFFD
}
'
;
}
}
else
{
debug_assert
!
(
false
)
;
}
}
}
if
!
is_ascii
(
mut_label
)
&
&
mut_label
.
len
(
)
>
PUNYCODE_ENCODE_MAX_INPUT_LENGTH
{
if
fail_fast
{
return
true
;
}
*
had_errors
=
true
;
mut_label
[
PUNYCODE_ENCODE_MAX_INPUT_LENGTH
]
=
'
\
u
{
FFFD
}
'
;
}
false
}
#
[
inline
(
always
)
]
fn
has_appropriately_joining_char
<
I
:
Iterator
<
Item
=
char
>
>
(
&
self
iter
:
I
required_mask
:
u32
)
-
>
bool
{
for
c
in
iter
{
let
jt
=
self
.
joining_type
.
get
(
c
)
;
if
(
joining_type_to_mask
(
jt
)
&
required_mask
)
!
=
0
{
return
true
;
}
if
jt
=
=
JoiningType
:
:
Transparent
{
continue
;
}
return
false
;
}
false
}
#
[
inline
(
always
)
]
fn
is_bidi
(
&
self
buffer
:
&
[
char
]
)
-
>
bool
{
for
&
c
in
buffer
{
if
c
<
'
\
u
{
0590
}
'
{
continue
;
}
if
in_inclusive_range_char
(
c
'
\
u
{
0900
}
'
'
\
u
{
FB1C
}
'
)
{
debug_assert_ne
!
(
c
'
\
u
{
200F
}
'
)
;
continue
;
}
if
in_inclusive_range_char
(
c
'
\
u
{
1F000
}
'
'
\
u
{
3FFFF
}
'
)
{
continue
;
}
if
in_inclusive_range_char
(
c
'
\
u
{
FF00
}
'
'
\
u
{
107FF
}
'
)
{
continue
;
}
if
in_inclusive_range_char
(
c
'
\
u
{
11000
}
'
'
\
u
{
1E7FF
}
'
)
{
continue
;
}
if
(
RTL_MASK
&
bidi_class_to_mask
(
self
.
bidi_class
.
get
(
c
)
)
)
!
=
0
{
return
true
;
}
}
false
}
}
fn
check_hyphens
(
mut_label
:
&
mut
[
char
]
allow_third_fourth
:
bool
fail_fast
:
bool
had_errors
:
&
mut
bool
)
-
>
bool
{
if
let
Some
(
first
)
=
mut_label
.
first_mut
(
)
{
if
*
first
=
=
'
-
'
{
if
fail_fast
{
return
true
;
}
*
had_errors
=
true
;
*
first
=
'
\
u
{
FFFD
}
'
;
}
}
if
let
Some
(
last
)
=
mut_label
.
last_mut
(
)
{
if
*
last
=
=
'
-
'
{
if
fail_fast
{
return
true
;
}
*
had_errors
=
true
;
*
last
=
'
\
u
{
FFFD
}
'
;
}
}
if
allow_third_fourth
{
return
false
;
}
if
mut_label
.
len
(
)
>
=
4
&
&
mut_label
[
2
]
=
=
'
-
'
&
&
mut_label
[
3
]
=
=
'
-
'
{
if
fail_fast
{
return
true
;
}
*
had_errors
=
true
;
mut_label
[
2
]
=
'
\
u
{
FFFD
}
'
;
mut_label
[
3
]
=
'
\
u
{
FFFD
}
'
;
}
false
}
