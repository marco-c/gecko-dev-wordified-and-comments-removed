use
crate
:
:
Rng
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
ops
:
:
RangeBounds
;
const
DEFAULT_RNG_SEED
:
u64
=
0xef6f79ed30ba75a
;
impl
Default
for
Rng
{
#
[
inline
]
fn
default
(
)
-
>
Rng
{
Rng
:
:
new
(
)
}
}
impl
Rng
{
#
[
inline
]
pub
fn
new
(
)
-
>
Rng
{
try_with_rng
(
Rng
:
:
fork
)
.
unwrap_or_else
(
|
_
|
Rng
:
:
with_seed
(
0x4d595df4d0f33173
)
)
}
}
thread_local
!
{
static
RNG
:
Cell
<
Rng
>
=
Cell
:
:
new
(
Rng
(
random_seed
(
)
.
unwrap_or
(
DEFAULT_RNG_SEED
)
)
)
;
}
#
[
inline
]
fn
with_rng
<
R
>
(
f
:
impl
FnOnce
(
&
mut
Rng
)
-
>
R
)
-
>
R
{
RNG
.
with
(
|
rng
|
{
let
current
=
rng
.
replace
(
Rng
(
0
)
)
;
let
mut
restore
=
RestoreOnDrop
{
rng
current
}
;
f
(
&
mut
restore
.
current
)
}
)
}
#
[
inline
]
fn
try_with_rng
<
R
>
(
f
:
impl
FnOnce
(
&
mut
Rng
)
-
>
R
)
-
>
Result
<
R
std
:
:
thread
:
:
AccessError
>
{
RNG
.
try_with
(
|
rng
|
{
let
current
=
rng
.
replace
(
Rng
(
0
)
)
;
let
mut
restore
=
RestoreOnDrop
{
rng
current
}
;
f
(
&
mut
restore
.
current
)
}
)
}
struct
RestoreOnDrop
<
'
a
>
{
rng
:
&
'
a
Cell
<
Rng
>
current
:
Rng
}
impl
Drop
for
RestoreOnDrop
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
self
.
rng
.
set
(
Rng
(
self
.
current
.
0
)
)
;
}
}
#
[
inline
]
pub
fn
seed
(
seed
:
u64
)
{
with_rng
(
|
r
|
r
.
seed
(
seed
)
)
;
}
#
[
inline
]
pub
fn
get_seed
(
)
-
>
u64
{
with_rng
(
|
r
|
r
.
get_seed
(
)
)
}
#
[
inline
]
pub
fn
bool
(
)
-
>
bool
{
with_rng
(
|
r
|
r
.
bool
(
)
)
}
#
[
inline
]
pub
fn
alphabetic
(
)
-
>
char
{
with_rng
(
|
r
|
r
.
alphabetic
(
)
)
}
#
[
inline
]
pub
fn
alphanumeric
(
)
-
>
char
{
with_rng
(
|
r
|
r
.
alphanumeric
(
)
)
}
#
[
inline
]
pub
fn
lowercase
(
)
-
>
char
{
with_rng
(
|
r
|
r
.
lowercase
(
)
)
}
#
[
inline
]
pub
fn
uppercase
(
)
-
>
char
{
with_rng
(
|
r
|
r
.
uppercase
(
)
)
}
#
[
inline
]
pub
fn
choice
<
I
>
(
iter
:
I
)
-
>
Option
<
I
:
:
Item
>
where
I
:
IntoIterator
I
:
:
IntoIter
:
ExactSizeIterator
{
with_rng
(
|
r
|
r
.
choice
(
iter
)
)
}
#
[
inline
]
pub
fn
digit
(
base
:
u32
)
-
>
char
{
with_rng
(
|
r
|
r
.
digit
(
base
)
)
}
#
[
inline
]
pub
fn
shuffle
<
T
>
(
slice
:
&
mut
[
T
]
)
{
with_rng
(
|
r
|
r
.
shuffle
(
slice
)
)
}
macro_rules
!
integer
{
(
t
:
tt
doc
:
tt
)
=
>
{
#
[
doc
=
doc
]
/
/
/
/
/
/
Panics
if
the
range
is
empty
.
#
[
inline
]
pub
fn
t
(
range
:
impl
RangeBounds
<
t
>
)
-
>
t
{
with_rng
(
|
r
|
r
.
t
(
range
)
)
}
}
;
}
integer
!
(
u8
"
Generates
a
random
u8
in
the
given
range
.
"
)
;
integer
!
(
i8
"
Generates
a
random
i8
in
the
given
range
.
"
)
;
integer
!
(
u16
"
Generates
a
random
u16
in
the
given
range
.
"
)
;
integer
!
(
i16
"
Generates
a
random
i16
in
the
given
range
.
"
)
;
integer
!
(
u32
"
Generates
a
random
u32
in
the
given
range
.
"
)
;
integer
!
(
i32
"
Generates
a
random
i32
in
the
given
range
.
"
)
;
integer
!
(
u64
"
Generates
a
random
u64
in
the
given
range
.
"
)
;
integer
!
(
i64
"
Generates
a
random
i64
in
the
given
range
.
"
)
;
integer
!
(
u128
"
Generates
a
random
u128
in
the
given
range
.
"
)
;
integer
!
(
i128
"
Generates
a
random
i128
in
the
given
range
.
"
)
;
integer
!
(
usize
"
Generates
a
random
usize
in
the
given
range
.
"
)
;
integer
!
(
isize
"
Generates
a
random
isize
in
the
given
range
.
"
)
;
integer
!
(
char
"
Generates
a
random
char
in
the
given
range
.
"
)
;
pub
fn
f32
(
)
-
>
f32
{
with_rng
(
|
r
|
r
.
f32
(
)
)
}
pub
fn
f64
(
)
-
>
f64
{
with_rng
(
|
r
|
r
.
f64
(
)
)
}
pub
fn
choose_multiple
<
T
:
Iterator
>
(
source
:
T
amount
:
usize
)
-
>
Vec
<
T
:
:
Item
>
{
with_rng
(
|
rng
|
rng
.
choose_multiple
(
source
amount
)
)
}
#
[
cfg
(
not
(
all
(
any
(
target_arch
=
"
wasm32
"
target_arch
=
"
wasm64
"
)
target_os
=
"
unknown
"
)
)
)
]
fn
random_seed
(
)
-
>
Option
<
u64
>
{
use
std
:
:
collections
:
:
hash_map
:
:
DefaultHasher
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
thread
;
use
std
:
:
time
:
:
Instant
;
let
mut
hasher
=
DefaultHasher
:
:
new
(
)
;
Instant
:
:
now
(
)
.
hash
(
&
mut
hasher
)
;
thread
:
:
current
(
)
.
id
(
)
.
hash
(
&
mut
hasher
)
;
let
hash
=
hasher
.
finish
(
)
;
Some
(
(
hash
<
<
1
)
|
1
)
}
#
[
cfg
(
all
(
any
(
target_arch
=
"
wasm32
"
target_arch
=
"
wasm64
"
)
target_os
=
"
unknown
"
feature
=
"
js
"
)
)
]
fn
random_seed
(
)
-
>
Option
<
u64
>
{
let
mut
seed
=
[
0u8
;
8
]
;
getrandom
:
:
getrandom
(
&
mut
seed
)
.
ok
(
)
?
;
Some
(
u64
:
:
from_ne_bytes
(
seed
)
)
}
#
[
cfg
(
all
(
any
(
target_arch
=
"
wasm32
"
target_arch
=
"
wasm64
"
)
target_os
=
"
unknown
"
not
(
feature
=
"
js
"
)
)
)
]
fn
random_seed
(
)
-
>
Option
<
u64
>
{
None
}
