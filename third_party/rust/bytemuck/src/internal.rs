#
!
[
allow
(
unused_unsafe
)
]
use
crate
:
:
PodCastError
;
use
core
:
:
{
marker
:
:
*
mem
:
:
*
}
;
#
[
cfg
(
not
(
target_arch
=
"
spirv
"
)
)
]
#
[
cold
]
#
[
inline
(
never
)
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
(
crate
)
fn
something_went_wrong
<
D
:
core
:
:
fmt
:
:
Display
>
(
_src
:
&
str
_err
:
D
)
-
>
!
{
panic
!
(
"
{
src
}
>
{
err
}
"
src
=
_src
err
=
_err
)
;
}
#
[
cfg
(
target_arch
=
"
spirv
"
)
]
#
[
cold
]
#
[
inline
(
never
)
]
pub
(
crate
)
fn
something_went_wrong
<
D
>
(
_src
:
&
str
_err
:
D
)
-
>
!
{
panic
!
(
"
Called
a
panicing
helper
from
bytemuck
which
paniced
"
)
;
}
#
[
inline
(
always
)
]
pub
(
crate
)
unsafe
fn
bytes_of
<
T
:
Copy
>
(
t
:
&
T
)
-
>
&
[
u8
]
{
match
try_cast_slice
:
:
<
T
u8
>
(
core
:
:
slice
:
:
from_ref
(
t
)
)
{
Ok
(
s
)
=
>
s
Err
(
_
)
=
>
unreachable
!
(
)
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
bytes_of_mut
<
T
:
Copy
>
(
t
:
&
mut
T
)
-
>
&
mut
[
u8
]
{
match
try_cast_slice_mut
:
:
<
T
u8
>
(
core
:
:
slice
:
:
from_mut
(
t
)
)
{
Ok
(
s
)
=
>
s
Err
(
_
)
=
>
unreachable
!
(
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
(
crate
)
unsafe
fn
from_bytes
<
T
:
Copy
>
(
s
:
&
[
u8
]
)
-
>
&
T
{
match
try_from_bytes
(
s
)
{
Ok
(
t
)
=
>
t
Err
(
e
)
=
>
something_went_wrong
(
"
from_bytes
"
e
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
(
crate
)
unsafe
fn
from_bytes_mut
<
T
:
Copy
>
(
s
:
&
mut
[
u8
]
)
-
>
&
mut
T
{
match
try_from_bytes_mut
(
s
)
{
Ok
(
t
)
=
>
t
Err
(
e
)
=
>
something_went_wrong
(
"
from_bytes_mut
"
e
)
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
try_pod_read_unaligned
<
T
:
Copy
>
(
bytes
:
&
[
u8
]
)
-
>
Result
<
T
PodCastError
>
{
if
bytes
.
len
(
)
!
=
size_of
:
:
<
T
>
(
)
{
Err
(
PodCastError
:
:
SizeMismatch
)
}
else
{
Ok
(
unsafe
{
(
bytes
.
as_ptr
(
)
as
*
const
T
)
.
read_unaligned
(
)
}
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
(
crate
)
unsafe
fn
pod_read_unaligned
<
T
:
Copy
>
(
bytes
:
&
[
u8
]
)
-
>
T
{
match
try_pod_read_unaligned
(
bytes
)
{
Ok
(
t
)
=
>
t
Err
(
e
)
=
>
something_went_wrong
(
"
pod_read_unaligned
"
e
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
(
crate
)
fn
is_aligned_to
(
ptr
:
*
const
(
)
align
:
usize
)
-
>
bool
{
#
[
cfg
(
feature
=
"
align_offset
"
)
]
{
ptr
.
align_offset
(
align
)
=
=
0
}
#
[
cfg
(
not
(
feature
=
"
align_offset
"
)
)
]
{
(
(
ptr
as
usize
)
%
align
)
=
=
0
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
try_from_bytes
<
T
:
Copy
>
(
s
:
&
[
u8
]
)
-
>
Result
<
&
T
PodCastError
>
{
if
s
.
len
(
)
!
=
size_of
:
:
<
T
>
(
)
{
Err
(
PodCastError
:
:
SizeMismatch
)
}
else
if
!
is_aligned_to
(
s
.
as_ptr
(
)
as
*
const
(
)
align_of
:
:
<
T
>
(
)
)
{
Err
(
PodCastError
:
:
TargetAlignmentGreaterAndInputNotAligned
)
}
else
{
Ok
(
unsafe
{
&
*
(
s
.
as_ptr
(
)
as
*
const
T
)
}
)
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
try_from_bytes_mut
<
T
:
Copy
>
(
s
:
&
mut
[
u8
]
)
-
>
Result
<
&
mut
T
PodCastError
>
{
if
s
.
len
(
)
!
=
size_of
:
:
<
T
>
(
)
{
Err
(
PodCastError
:
:
SizeMismatch
)
}
else
if
!
is_aligned_to
(
s
.
as_ptr
(
)
as
*
const
(
)
align_of
:
:
<
T
>
(
)
)
{
Err
(
PodCastError
:
:
TargetAlignmentGreaterAndInputNotAligned
)
}
else
{
Ok
(
unsafe
{
&
mut
*
(
s
.
as_mut_ptr
(
)
as
*
mut
T
)
}
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
(
crate
)
unsafe
fn
cast
<
A
:
Copy
B
:
Copy
>
(
a
:
A
)
-
>
B
{
if
size_of
:
:
<
A
>
(
)
=
=
size_of
:
:
<
B
>
(
)
{
unsafe
{
transmute
!
(
a
)
}
}
else
{
something_went_wrong
(
"
cast
"
PodCastError
:
:
SizeMismatch
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
(
crate
)
unsafe
fn
cast_mut
<
A
:
Copy
B
:
Copy
>
(
a
:
&
mut
A
)
-
>
&
mut
B
{
if
size_of
:
:
<
A
>
(
)
=
=
size_of
:
:
<
B
>
(
)
&
&
align_of
:
:
<
A
>
(
)
>
=
align_of
:
:
<
B
>
(
)
{
match
try_cast_mut
(
a
)
{
Ok
(
b
)
=
>
b
Err
(
_
)
=
>
unreachable
!
(
)
}
}
else
{
match
try_cast_mut
(
a
)
{
Ok
(
b
)
=
>
b
Err
(
e
)
=
>
something_went_wrong
(
"
cast_mut
"
e
)
}
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
(
crate
)
unsafe
fn
cast_ref
<
A
:
Copy
B
:
Copy
>
(
a
:
&
A
)
-
>
&
B
{
if
size_of
:
:
<
A
>
(
)
=
=
size_of
:
:
<
B
>
(
)
&
&
align_of
:
:
<
A
>
(
)
>
=
align_of
:
:
<
B
>
(
)
{
match
try_cast_ref
(
a
)
{
Ok
(
b
)
=
>
b
Err
(
_
)
=
>
unreachable
!
(
)
}
}
else
{
match
try_cast_ref
(
a
)
{
Ok
(
b
)
=
>
b
Err
(
e
)
=
>
something_went_wrong
(
"
cast_ref
"
e
)
}
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
(
crate
)
unsafe
fn
cast_slice
<
A
:
Copy
B
:
Copy
>
(
a
:
&
[
A
]
)
-
>
&
[
B
]
{
match
try_cast_slice
(
a
)
{
Ok
(
b
)
=
>
b
Err
(
e
)
=
>
something_went_wrong
(
"
cast_slice
"
e
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
(
crate
)
unsafe
fn
cast_slice_mut
<
A
:
Copy
B
:
Copy
>
(
a
:
&
mut
[
A
]
)
-
>
&
mut
[
B
]
{
match
try_cast_slice_mut
(
a
)
{
Ok
(
b
)
=
>
b
Err
(
e
)
=
>
something_went_wrong
(
"
cast_slice_mut
"
e
)
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
try_cast
<
A
:
Copy
B
:
Copy
>
(
a
:
A
)
-
>
Result
<
B
PodCastError
>
{
if
size_of
:
:
<
A
>
(
)
=
=
size_of
:
:
<
B
>
(
)
{
Ok
(
unsafe
{
transmute
!
(
a
)
}
)
}
else
{
Err
(
PodCastError
:
:
SizeMismatch
)
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
try_cast_ref
<
A
:
Copy
B
:
Copy
>
(
a
:
&
A
)
-
>
Result
<
&
B
PodCastError
>
{
if
align_of
:
:
<
B
>
(
)
>
align_of
:
:
<
A
>
(
)
&
&
!
is_aligned_to
(
a
as
*
const
A
as
*
const
(
)
align_of
:
:
<
B
>
(
)
)
{
Err
(
PodCastError
:
:
TargetAlignmentGreaterAndInputNotAligned
)
}
else
if
size_of
:
:
<
B
>
(
)
=
=
size_of
:
:
<
A
>
(
)
{
Ok
(
unsafe
{
&
*
(
a
as
*
const
A
as
*
const
B
)
}
)
}
else
{
Err
(
PodCastError
:
:
SizeMismatch
)
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
try_cast_mut
<
A
:
Copy
B
:
Copy
>
(
a
:
&
mut
A
)
-
>
Result
<
&
mut
B
PodCastError
>
{
if
align_of
:
:
<
B
>
(
)
>
align_of
:
:
<
A
>
(
)
&
&
!
is_aligned_to
(
a
as
*
const
A
as
*
const
(
)
align_of
:
:
<
B
>
(
)
)
{
Err
(
PodCastError
:
:
TargetAlignmentGreaterAndInputNotAligned
)
}
else
if
size_of
:
:
<
B
>
(
)
=
=
size_of
:
:
<
A
>
(
)
{
Ok
(
unsafe
{
&
mut
*
(
a
as
*
mut
A
as
*
mut
B
)
}
)
}
else
{
Err
(
PodCastError
:
:
SizeMismatch
)
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
try_cast_slice
<
A
:
Copy
B
:
Copy
>
(
a
:
&
[
A
]
)
-
>
Result
<
&
[
B
]
PodCastError
>
{
let
input_bytes
=
core
:
:
mem
:
:
size_of_val
:
:
<
[
A
]
>
(
a
)
;
if
align_of
:
:
<
B
>
(
)
>
align_of
:
:
<
A
>
(
)
&
&
!
is_aligned_to
(
a
.
as_ptr
(
)
as
*
const
(
)
align_of
:
:
<
B
>
(
)
)
{
Err
(
PodCastError
:
:
TargetAlignmentGreaterAndInputNotAligned
)
}
else
if
size_of
:
:
<
B
>
(
)
=
=
size_of
:
:
<
A
>
(
)
{
Ok
(
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
a
.
as_ptr
(
)
as
*
const
B
a
.
len
(
)
)
}
)
}
else
if
(
size_of
:
:
<
B
>
(
)
!
=
0
&
&
input_bytes
%
size_of
:
:
<
B
>
(
)
=
=
0
)
|
|
(
size_of
:
:
<
B
>
(
)
=
=
0
&
&
input_bytes
=
=
0
)
{
let
new_len
=
if
size_of
:
:
<
B
>
(
)
!
=
0
{
input_bytes
/
size_of
:
:
<
B
>
(
)
}
else
{
0
}
;
Ok
(
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
a
.
as_ptr
(
)
as
*
const
B
new_len
)
}
)
}
else
{
Err
(
PodCastError
:
:
OutputSliceWouldHaveSlop
)
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
try_cast_slice_mut
<
A
:
Copy
B
:
Copy
>
(
a
:
&
mut
[
A
]
)
-
>
Result
<
&
mut
[
B
]
PodCastError
>
{
let
input_bytes
=
core
:
:
mem
:
:
size_of_val
:
:
<
[
A
]
>
(
a
)
;
if
align_of
:
:
<
B
>
(
)
>
align_of
:
:
<
A
>
(
)
&
&
!
is_aligned_to
(
a
.
as_ptr
(
)
as
*
const
(
)
align_of
:
:
<
B
>
(
)
)
{
Err
(
PodCastError
:
:
TargetAlignmentGreaterAndInputNotAligned
)
}
else
if
size_of
:
:
<
B
>
(
)
=
=
size_of
:
:
<
A
>
(
)
{
Ok
(
unsafe
{
core
:
:
slice
:
:
from_raw_parts_mut
(
a
.
as_mut_ptr
(
)
as
*
mut
B
a
.
len
(
)
)
}
)
}
else
if
(
size_of
:
:
<
B
>
(
)
!
=
0
&
&
input_bytes
%
size_of
:
:
<
B
>
(
)
=
=
0
)
|
|
(
size_of
:
:
<
B
>
(
)
=
=
0
&
&
input_bytes
=
=
0
)
{
let
new_len
=
if
size_of
:
:
<
B
>
(
)
!
=
0
{
input_bytes
/
size_of
:
:
<
B
>
(
)
}
else
{
0
}
;
Ok
(
unsafe
{
core
:
:
slice
:
:
from_raw_parts_mut
(
a
.
as_mut_ptr
(
)
as
*
mut
B
new_len
)
}
)
}
else
{
Err
(
PodCastError
:
:
OutputSliceWouldHaveSlop
)
}
}
