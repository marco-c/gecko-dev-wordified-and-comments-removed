use
super
:
:
*
;
#
[
cfg_attr
(
feature
=
"
derive
"
doc
=
"
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
derive
"
)
doc
=
"
ignore
/
/
This
example
requires
the
derive
feature
.
"
)
]
#
[
cfg_attr
(
feature
=
"
derive
"
doc
=
"
compile_fail
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
derive
"
)
doc
=
"
ignore
/
/
This
example
requires
the
derive
feature
.
"
)
]
pub
unsafe
trait
TransparentWrapper
<
Inner
:
?
Sized
>
{
#
[
inline
]
fn
wrap
(
s
:
Inner
)
-
>
Self
where
Self
:
Sized
Inner
:
Sized
{
unsafe
{
transmute
!
(
s
)
}
}
#
[
inline
]
fn
wrap_ref
(
s
:
&
Inner
)
-
>
&
Self
{
unsafe
{
assert
!
(
size_of
:
:
<
*
const
Inner
>
(
)
=
=
size_of
:
:
<
*
const
Self
>
(
)
)
;
let
inner_ptr
=
s
as
*
const
Inner
;
let
wrapper_ptr
:
*
const
Self
=
transmute
!
(
inner_ptr
)
;
&
*
wrapper_ptr
}
}
#
[
inline
]
fn
wrap_mut
(
s
:
&
mut
Inner
)
-
>
&
mut
Self
{
unsafe
{
assert
!
(
size_of
:
:
<
*
mut
Inner
>
(
)
=
=
size_of
:
:
<
*
mut
Self
>
(
)
)
;
let
inner_ptr
=
s
as
*
mut
Inner
;
let
wrapper_ptr
:
*
mut
Self
=
transmute
!
(
inner_ptr
)
;
&
mut
*
wrapper_ptr
}
}
#
[
inline
]
fn
wrap_slice
(
s
:
&
[
Inner
]
)
-
>
&
[
Self
]
where
Self
:
Sized
Inner
:
Sized
{
unsafe
{
assert
!
(
size_of
:
:
<
*
const
Inner
>
(
)
=
=
size_of
:
:
<
*
const
Self
>
(
)
)
;
assert
!
(
align_of
:
:
<
*
const
Inner
>
(
)
=
=
align_of
:
:
<
*
const
Self
>
(
)
)
;
core
:
:
slice
:
:
from_raw_parts
(
s
.
as_ptr
(
)
as
*
const
Self
s
.
len
(
)
)
}
}
#
[
inline
]
fn
wrap_slice_mut
(
s
:
&
mut
[
Inner
]
)
-
>
&
mut
[
Self
]
where
Self
:
Sized
Inner
:
Sized
{
unsafe
{
assert
!
(
size_of
:
:
<
*
mut
Inner
>
(
)
=
=
size_of
:
:
<
*
mut
Self
>
(
)
)
;
assert
!
(
align_of
:
:
<
*
mut
Inner
>
(
)
=
=
align_of
:
:
<
*
mut
Self
>
(
)
)
;
core
:
:
slice
:
:
from_raw_parts_mut
(
s
.
as_mut_ptr
(
)
as
*
mut
Self
s
.
len
(
)
)
}
}
#
[
inline
]
fn
peel
(
s
:
Self
)
-
>
Inner
where
Self
:
Sized
Inner
:
Sized
{
unsafe
{
transmute
!
(
s
)
}
}
#
[
inline
]
fn
peel_ref
(
s
:
&
Self
)
-
>
&
Inner
{
unsafe
{
assert
!
(
size_of
:
:
<
*
const
Inner
>
(
)
=
=
size_of
:
:
<
*
const
Self
>
(
)
)
;
let
wrapper_ptr
=
s
as
*
const
Self
;
let
inner_ptr
:
*
const
Inner
=
transmute
!
(
wrapper_ptr
)
;
&
*
inner_ptr
}
}
#
[
inline
]
fn
peel_mut
(
s
:
&
mut
Self
)
-
>
&
mut
Inner
{
unsafe
{
assert
!
(
size_of
:
:
<
*
mut
Inner
>
(
)
=
=
size_of
:
:
<
*
mut
Self
>
(
)
)
;
let
wrapper_ptr
=
s
as
*
mut
Self
;
let
inner_ptr
:
*
mut
Inner
=
transmute
!
(
wrapper_ptr
)
;
&
mut
*
inner_ptr
}
}
#
[
inline
]
fn
peel_slice
(
s
:
&
[
Self
]
)
-
>
&
[
Inner
]
where
Self
:
Sized
Inner
:
Sized
{
unsafe
{
assert
!
(
size_of
:
:
<
*
const
Inner
>
(
)
=
=
size_of
:
:
<
*
const
Self
>
(
)
)
;
assert
!
(
align_of
:
:
<
*
const
Inner
>
(
)
=
=
align_of
:
:
<
*
const
Self
>
(
)
)
;
core
:
:
slice
:
:
from_raw_parts
(
s
.
as_ptr
(
)
as
*
const
Inner
s
.
len
(
)
)
}
}
#
[
inline
]
fn
peel_slice_mut
(
s
:
&
mut
[
Self
]
)
-
>
&
mut
[
Inner
]
where
Self
:
Sized
Inner
:
Sized
{
unsafe
{
assert
!
(
size_of
:
:
<
*
mut
Inner
>
(
)
=
=
size_of
:
:
<
*
mut
Self
>
(
)
)
;
assert
!
(
align_of
:
:
<
*
mut
Inner
>
(
)
=
=
align_of
:
:
<
*
mut
Self
>
(
)
)
;
core
:
:
slice
:
:
from_raw_parts_mut
(
s
.
as_mut_ptr
(
)
as
*
mut
Inner
s
.
len
(
)
)
}
}
}
unsafe
impl
<
T
>
TransparentWrapper
<
T
>
for
core
:
:
num
:
:
Wrapping
<
T
>
{
}
