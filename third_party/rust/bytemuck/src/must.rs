#
!
[
allow
(
clippy
:
:
module_name_repetitions
)
]
#
!
[
allow
(
clippy
:
:
let_unit_value
)
]
#
!
[
allow
(
clippy
:
:
let_underscore_untyped
)
]
#
!
[
allow
(
clippy
:
:
ptr_as_ptr
)
]
use
crate
:
:
{
AnyBitPattern
NoUninit
}
;
use
core
:
:
mem
:
:
{
align_of
size_of
}
;
struct
Cast
<
A
B
>
(
(
A
B
)
)
;
impl
<
A
B
>
Cast
<
A
B
>
{
const
ASSERT_ALIGN_GREATER_THAN_EQUAL
:
(
)
=
assert
!
(
align_of
:
:
<
A
>
(
)
>
=
align_of
:
:
<
B
>
(
)
)
;
const
ASSERT_SIZE_EQUAL
:
(
)
=
assert
!
(
size_of
:
:
<
A
>
(
)
=
=
size_of
:
:
<
B
>
(
)
)
;
const
ASSERT_SIZE_MULTIPLE_OF
:
(
)
=
assert
!
(
(
size_of
:
:
<
A
>
(
)
=
=
0
)
=
=
(
size_of
:
:
<
B
>
(
)
=
=
0
)
&
&
(
size_of
:
:
<
A
>
(
)
%
size_of
:
:
<
B
>
(
)
=
=
0
)
)
;
}
#
[
cfg
(
miri
)
]
macro_rules
!
post_mono_compile_fail_doctest
{
(
)
=
>
{
"
should_panic
"
}
;
}
#
[
cfg
(
not
(
miri
)
)
]
macro_rules
!
post_mono_compile_fail_doctest
{
(
)
=
>
{
"
compile_fail
E0080
"
}
;
}
#
[
doc
=
post_mono_compile_fail_doctest
!
(
)
]
#
[
inline
]
pub
fn
must_cast
<
A
:
NoUninit
B
:
AnyBitPattern
>
(
a
:
A
)
-
>
B
{
let
_
=
Cast
:
:
<
A
B
>
:
:
ASSERT_SIZE_EQUAL
;
unsafe
{
transmute
!
(
a
)
}
}
#
[
doc
=
post_mono_compile_fail_doctest
!
(
)
]
#
[
doc
=
post_mono_compile_fail_doctest
!
(
)
]
#
[
inline
]
pub
fn
must_cast_ref
<
A
:
NoUninit
B
:
AnyBitPattern
>
(
a
:
&
A
)
-
>
&
B
{
let
_
=
Cast
:
:
<
A
B
>
:
:
ASSERT_SIZE_EQUAL
;
let
_
=
Cast
:
:
<
A
B
>
:
:
ASSERT_ALIGN_GREATER_THAN_EQUAL
;
unsafe
{
&
*
(
a
as
*
const
A
as
*
const
B
)
}
}
#
[
doc
=
post_mono_compile_fail_doctest
!
(
)
]
#
[
doc
=
post_mono_compile_fail_doctest
!
(
)
]
#
[
inline
]
pub
fn
must_cast_mut
<
A
:
NoUninit
+
AnyBitPattern
B
:
NoUninit
+
AnyBitPattern
>
(
a
:
&
mut
A
)
-
>
&
mut
B
{
let
_
=
Cast
:
:
<
A
B
>
:
:
ASSERT_SIZE_EQUAL
;
let
_
=
Cast
:
:
<
A
B
>
:
:
ASSERT_ALIGN_GREATER_THAN_EQUAL
;
unsafe
{
&
mut
*
(
a
as
*
mut
A
as
*
mut
B
)
}
}
#
[
doc
=
post_mono_compile_fail_doctest
!
(
)
]
#
[
doc
=
post_mono_compile_fail_doctest
!
(
)
]
#
[
inline
]
pub
fn
must_cast_slice
<
A
:
NoUninit
B
:
AnyBitPattern
>
(
a
:
&
[
A
]
)
-
>
&
[
B
]
{
let
_
=
Cast
:
:
<
A
B
>
:
:
ASSERT_SIZE_MULTIPLE_OF
;
let
_
=
Cast
:
:
<
A
B
>
:
:
ASSERT_ALIGN_GREATER_THAN_EQUAL
;
let
new_len
=
if
size_of
:
:
<
A
>
(
)
=
=
size_of
:
:
<
B
>
(
)
{
a
.
len
(
)
}
else
{
a
.
len
(
)
*
(
size_of
:
:
<
A
>
(
)
/
size_of
:
:
<
B
>
(
)
)
}
;
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
a
.
as_ptr
(
)
as
*
const
B
new_len
)
}
}
#
[
doc
=
post_mono_compile_fail_doctest
!
(
)
]
#
[
doc
=
post_mono_compile_fail_doctest
!
(
)
]
#
[
inline
]
pub
fn
must_cast_slice_mut
<
A
:
NoUninit
+
AnyBitPattern
B
:
NoUninit
+
AnyBitPattern
>
(
a
:
&
mut
[
A
]
)
-
>
&
mut
[
B
]
{
let
_
=
Cast
:
:
<
A
B
>
:
:
ASSERT_SIZE_MULTIPLE_OF
;
let
_
=
Cast
:
:
<
A
B
>
:
:
ASSERT_ALIGN_GREATER_THAN_EQUAL
;
let
new_len
=
if
size_of
:
:
<
A
>
(
)
=
=
size_of
:
:
<
B
>
(
)
{
a
.
len
(
)
}
else
{
a
.
len
(
)
*
(
size_of
:
:
<
A
>
(
)
/
size_of
:
:
<
B
>
(
)
)
}
;
unsafe
{
core
:
:
slice
:
:
from_raw_parts_mut
(
a
.
as_mut_ptr
(
)
as
*
mut
B
new_len
)
}
}
