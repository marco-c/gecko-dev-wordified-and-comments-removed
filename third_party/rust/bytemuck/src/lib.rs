#
!
[
no_std
]
#
!
[
warn
(
missing_docs
)
]
#
!
[
allow
(
unused_mut
)
]
#
!
[
allow
(
clippy
:
:
match_like_matches_macro
)
]
#
!
[
allow
(
clippy
:
:
uninlined_format_args
)
]
#
!
[
allow
(
clippy
:
:
result_unit_err
)
]
#
!
[
allow
(
clippy
:
:
type_complexity
)
]
#
!
[
cfg_attr
(
feature
=
"
nightly_docs
"
feature
(
doc_cfg
)
)
]
#
!
[
cfg_attr
(
feature
=
"
nightly_portable_simd
"
feature
(
portable_simd
)
)
]
#
!
[
cfg_attr
(
feature
=
"
nightly_float
"
feature
(
f16
f128
)
)
]
#
!
[
cfg_attr
(
all
(
feature
=
"
nightly_stdsimd
"
any
(
target_arch
=
"
x86_64
"
target_arch
=
"
x86
"
)
)
feature
(
stdarch_x86_avx512
)
)
]
#
[
cfg
(
all
(
target_arch
=
"
aarch64
"
feature
=
"
aarch64_simd
"
)
)
]
use
core
:
:
arch
:
:
aarch64
;
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
feature
=
"
wasm_simd
"
)
)
]
use
core
:
:
arch
:
:
wasm32
;
#
[
cfg
(
target_arch
=
"
x86
"
)
]
use
core
:
:
arch
:
:
x86
;
#
[
cfg
(
target_arch
=
"
x86_64
"
)
]
use
core
:
:
arch
:
:
x86_64
;
use
core
:
:
{
marker
:
:
*
mem
:
:
{
align_of
size_of
}
num
:
:
*
ptr
:
:
*
}
;
#
[
doc
(
hidden
)
]
pub
use
:
:
core
as
__core
;
#
[
cfg
(
not
(
feature
=
"
min_const_generics
"
)
)
]
macro_rules
!
impl_unsafe_marker_for_array
{
(
marker
:
ident
(
n
:
expr
)
*
)
=
>
{
(
unsafe
impl
<
T
>
marker
for
[
T
;
n
]
where
T
:
marker
{
}
)
*
}
}
macro_rules
!
transmute
{
(
val
:
expr
)
=
>
{
:
:
core
:
:
mem
:
:
transmute_copy
(
&
:
:
core
:
:
mem
:
:
ManuallyDrop
:
:
new
(
val
)
)
}
;
(
srcty
:
ty
;
dstty
:
ty
;
val
:
expr
)
=
>
{
{
#
[
repr
(
C
)
]
union
Transmute
<
A
B
>
{
src
:
:
:
core
:
:
mem
:
:
ManuallyDrop
<
A
>
dst
:
:
:
core
:
:
mem
:
:
ManuallyDrop
<
B
>
}
:
:
core
:
:
mem
:
:
ManuallyDrop
:
:
into_inner
(
Transmute
:
:
<
srcty
dstty
>
{
src
:
:
:
core
:
:
mem
:
:
ManuallyDrop
:
:
new
(
val
)
}
.
dst
)
}
}
;
}
#
[
allow
(
unused
)
]
macro_rules
!
impl_unsafe_marker_for_simd
{
(
(
#
[
cfg
(
cfg_predicate
:
meta
)
]
)
?
unsafe
impl
trait
:
ident
for
platform
:
ident
:
:
{
}
)
=
>
{
}
;
(
(
#
[
cfg
(
cfg_predicate
:
meta
)
]
)
?
unsafe
impl
trait
:
ident
for
platform
:
ident
:
:
{
first_type
:
ident
(
types
:
ident
)
*
(
)
?
}
)
=
>
{
(
#
[
cfg
(
cfg_predicate
)
]
)
?
(
#
[
cfg_attr
(
feature
=
"
nightly_docs
"
doc
(
cfg
(
cfg_predicate
)
)
)
]
)
?
unsafe
impl
trait
for
platform
:
:
first_type
{
}
(
#
[
cfg
(
cfg_predicate
)
]
)
?
/
/
To
prevent
recursion
errors
if
nothing
is
going
to
be
expanded
anyway
.
impl_unsafe_marker_for_simd
!
(
(
#
[
cfg
(
cfg_predicate
)
]
)
?
unsafe
impl
trait
for
platform
:
:
{
(
types
)
*
}
)
;
}
;
}
#
[
allow
(
unused
)
]
macro_rules
!
maybe_const_fn
{
(
#
[
cfg
(
cfg_predicate
:
meta
)
]
(
#
[
attr
:
meta
]
)
*
vis
:
vis
(
unsafe
(
unsafe
:
lifetime
)
?
)
?
fn
name
:
ident
(
rest
:
tt
)
*
)
=
>
{
#
[
cfg
(
cfg_predicate
)
]
(
#
[
attr
]
)
*
vis
const
(
unsafe
(
unsafe
)
?
)
?
fn
name
(
rest
)
*
#
[
cfg
(
not
(
cfg_predicate
)
)
]
(
#
[
attr
]
)
*
vis
(
unsafe
(
unsafe
)
?
)
?
fn
name
(
rest
)
*
}
;
}
#
[
cfg
(
feature
=
"
extern_crate_std
"
)
]
extern
crate
std
;
#
[
cfg
(
feature
=
"
extern_crate_alloc
"
)
]
extern
crate
alloc
;
#
[
cfg
(
feature
=
"
extern_crate_alloc
"
)
]
#
[
cfg_attr
(
feature
=
"
nightly_docs
"
doc
(
cfg
(
feature
=
"
extern_crate_alloc
"
)
)
)
]
pub
mod
allocation
;
#
[
cfg
(
feature
=
"
extern_crate_alloc
"
)
]
pub
use
allocation
:
:
*
;
mod
anybitpattern
;
pub
use
anybitpattern
:
:
*
;
pub
mod
checked
;
pub
use
checked
:
:
CheckedBitPattern
;
mod
internal
;
mod
zeroable
;
pub
use
zeroable
:
:
*
;
mod
zeroable_in_option
;
pub
use
zeroable_in_option
:
:
*
;
mod
pod
;
pub
use
pod
:
:
*
;
mod
pod_in_option
;
pub
use
pod_in_option
:
:
*
;
#
[
cfg
(
feature
=
"
must_cast
"
)
]
mod
must
;
#
[
cfg
(
feature
=
"
must_cast
"
)
]
#
[
cfg_attr
(
feature
=
"
nightly_docs
"
doc
(
cfg
(
feature
=
"
must_cast
"
)
)
)
]
pub
use
must
:
:
*
;
mod
no_uninit
;
pub
use
no_uninit
:
:
*
;
mod
contiguous
;
pub
use
contiguous
:
:
*
;
mod
offset_of
;
mod
transparent
;
pub
use
transparent
:
:
*
;
#
[
cfg
(
feature
=
"
derive
"
)
]
#
[
cfg_attr
(
feature
=
"
nightly_docs
"
doc
(
cfg
(
feature
=
"
derive
"
)
)
)
]
pub
use
bytemuck_derive
:
:
{
AnyBitPattern
ByteEq
ByteHash
CheckedBitPattern
Contiguous
NoUninit
Pod
TransparentWrapper
Zeroable
}
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
pub
enum
PodCastError
{
TargetAlignmentGreaterAndInputNotAligned
OutputSliceWouldHaveSlop
SizeMismatch
AlignmentMismatch
}
#
[
cfg
(
not
(
target_arch
=
"
spirv
"
)
)
]
impl
core
:
:
fmt
:
:
Display
for
PodCastError
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
"
self
)
}
}
#
[
cfg
(
feature
=
"
extern_crate_std
"
)
]
#
[
cfg_attr
(
feature
=
"
nightly_docs
"
doc
(
cfg
(
feature
=
"
extern_crate_std
"
)
)
)
]
impl
std
:
:
error
:
:
Error
for
PodCastError
{
}
#
[
inline
]
pub
fn
bytes_of
<
T
:
NoUninit
>
(
t
:
&
T
)
-
>
&
[
u8
]
{
unsafe
{
internal
:
:
bytes_of
(
t
)
}
}
#
[
inline
]
pub
fn
bytes_of_mut
<
T
:
NoUninit
+
AnyBitPattern
>
(
t
:
&
mut
T
)
-
>
&
mut
[
u8
]
{
unsafe
{
internal
:
:
bytes_of_mut
(
t
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
fn
from_bytes
<
T
:
AnyBitPattern
>
(
s
:
&
[
u8
]
)
-
>
&
T
{
unsafe
{
internal
:
:
from_bytes
(
s
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
fn
from_bytes_mut
<
T
:
NoUninit
+
AnyBitPattern
>
(
s
:
&
mut
[
u8
]
)
-
>
&
mut
T
{
unsafe
{
internal
:
:
from_bytes_mut
(
s
)
}
}
#
[
inline
]
pub
fn
try_pod_read_unaligned
<
T
:
AnyBitPattern
>
(
bytes
:
&
[
u8
]
)
-
>
Result
<
T
PodCastError
>
{
unsafe
{
internal
:
:
try_pod_read_unaligned
(
bytes
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
fn
pod_read_unaligned
<
T
:
AnyBitPattern
>
(
bytes
:
&
[
u8
]
)
-
>
T
{
unsafe
{
internal
:
:
pod_read_unaligned
(
bytes
)
}
}
#
[
inline
]
pub
fn
try_from_bytes
<
T
:
AnyBitPattern
>
(
s
:
&
[
u8
]
)
-
>
Result
<
&
T
PodCastError
>
{
unsafe
{
internal
:
:
try_from_bytes
(
s
)
}
}
#
[
inline
]
pub
fn
try_from_bytes_mut
<
T
:
NoUninit
+
AnyBitPattern
>
(
s
:
&
mut
[
u8
]
)
-
>
Result
<
&
mut
T
PodCastError
>
{
unsafe
{
internal
:
:
try_from_bytes_mut
(
s
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
fn
cast
<
A
:
NoUninit
B
:
AnyBitPattern
>
(
a
:
A
)
-
>
B
{
unsafe
{
internal
:
:
cast
(
a
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
fn
cast_mut
<
A
:
NoUninit
+
AnyBitPattern
B
:
NoUninit
+
AnyBitPattern
>
(
a
:
&
mut
A
)
-
>
&
mut
B
{
unsafe
{
internal
:
:
cast_mut
(
a
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
fn
cast_ref
<
A
:
NoUninit
B
:
AnyBitPattern
>
(
a
:
&
A
)
-
>
&
B
{
unsafe
{
internal
:
:
cast_ref
(
a
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
fn
cast_slice
<
A
:
NoUninit
B
:
AnyBitPattern
>
(
a
:
&
[
A
]
)
-
>
&
[
B
]
{
unsafe
{
internal
:
:
cast_slice
(
a
)
}
}
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
track_caller
"
track_caller
)
]
pub
fn
cast_slice_mut
<
A
:
NoUninit
+
AnyBitPattern
B
:
NoUninit
+
AnyBitPattern
>
(
a
:
&
mut
[
A
]
)
-
>
&
mut
[
B
]
{
unsafe
{
internal
:
:
cast_slice_mut
(
a
)
}
}
#
[
inline
]
pub
fn
pod_align_to
<
T
:
NoUninit
U
:
AnyBitPattern
>
(
vals
:
&
[
T
]
)
-
>
(
&
[
T
]
&
[
U
]
&
[
T
]
)
{
unsafe
{
vals
.
align_to
:
:
<
U
>
(
)
}
}
#
[
inline
]
pub
fn
pod_align_to_mut
<
T
:
NoUninit
+
AnyBitPattern
U
:
NoUninit
+
AnyBitPattern
>
(
vals
:
&
mut
[
T
]
)
-
>
(
&
mut
[
T
]
&
mut
[
U
]
&
mut
[
T
]
)
{
unsafe
{
vals
.
align_to_mut
:
:
<
U
>
(
)
}
}
#
[
inline
]
pub
fn
try_cast
<
A
:
NoUninit
B
:
AnyBitPattern
>
(
a
:
A
)
-
>
Result
<
B
PodCastError
>
{
unsafe
{
internal
:
:
try_cast
(
a
)
}
}
#
[
inline
]
pub
fn
try_cast_ref
<
A
:
NoUninit
B
:
AnyBitPattern
>
(
a
:
&
A
)
-
>
Result
<
&
B
PodCastError
>
{
unsafe
{
internal
:
:
try_cast_ref
(
a
)
}
}
#
[
inline
]
pub
fn
try_cast_mut
<
A
:
NoUninit
+
AnyBitPattern
B
:
NoUninit
+
AnyBitPattern
>
(
a
:
&
mut
A
)
-
>
Result
<
&
mut
B
PodCastError
>
{
unsafe
{
internal
:
:
try_cast_mut
(
a
)
}
}
#
[
inline
]
pub
fn
try_cast_slice
<
A
:
NoUninit
B
:
AnyBitPattern
>
(
a
:
&
[
A
]
)
-
>
Result
<
&
[
B
]
PodCastError
>
{
unsafe
{
internal
:
:
try_cast_slice
(
a
)
}
}
#
[
inline
]
pub
fn
try_cast_slice_mut
<
A
:
NoUninit
+
AnyBitPattern
B
:
NoUninit
+
AnyBitPattern
>
(
a
:
&
mut
[
A
]
)
-
>
Result
<
&
mut
[
B
]
PodCastError
>
{
unsafe
{
internal
:
:
try_cast_slice_mut
(
a
)
}
}
#
[
inline
]
pub
fn
write_zeroes
<
T
:
Zeroable
>
(
target
:
&
mut
T
)
{
struct
EnsureZeroWrite
<
T
>
(
*
mut
T
)
;
impl
<
T
>
Drop
for
EnsureZeroWrite
<
T
>
{
#
[
inline
(
always
)
]
fn
drop
(
&
mut
self
)
{
unsafe
{
core
:
:
ptr
:
:
write_bytes
(
self
.
0
0u8
1
)
;
}
}
}
unsafe
{
let
guard
=
EnsureZeroWrite
(
target
)
;
core
:
:
ptr
:
:
drop_in_place
(
guard
.
0
)
;
drop
(
guard
)
;
}
}
#
[
inline
]
pub
fn
fill_zeroes
<
T
:
Zeroable
>
(
slice
:
&
mut
[
T
]
)
{
if
core
:
:
mem
:
:
needs_drop
:
:
<
T
>
(
)
{
slice
.
iter_mut
(
)
.
for_each
(
write_zeroes
)
;
}
else
{
let
len
=
slice
.
len
(
)
;
unsafe
{
core
:
:
ptr
:
:
write_bytes
(
slice
.
as_mut_ptr
(
)
0u8
len
)
}
}
}
#
[
cfg
(
feature
=
"
const_zeroed
"
)
]
#
[
inline
]
#
[
must_use
]
pub
const
fn
zeroed
<
T
:
Zeroable
>
(
)
-
>
T
{
unsafe
{
core
:
:
mem
:
:
zeroed
(
)
}
}
