#
!
[
recursion_limit
=
"
128
"
]
extern
crate
phf_generator
;
extern
crate
phf_shared
;
extern
crate
string_cache_shared
as
shared
;
#
[
macro_use
]
extern
crate
quote
;
extern
crate
proc_macro2
;
use
std
:
:
collections
:
:
HashSet
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
self
Write
BufWriter
}
;
use
std
:
:
iter
;
use
std
:
:
path
:
:
Path
;
pub
struct
AtomType
{
path
:
String
atom_doc
:
Option
<
String
>
static_set_doc
:
Option
<
String
>
macro_name
:
String
macro_doc
:
Option
<
String
>
atoms
:
HashSet
<
String
>
}
impl
AtomType
{
pub
fn
new
(
path
:
&
str
macro_name
:
&
str
)
-
>
Self
{
assert
!
(
macro_name
.
ends_with
(
"
!
"
)
"
macro_name
must
end
with
'
!
'
"
)
;
AtomType
{
path
:
path
.
to_owned
(
)
macro_name
:
macro_name
[
.
.
macro_name
.
len
(
)
-
"
!
"
.
len
(
)
]
.
to_owned
(
)
atom_doc
:
None
static_set_doc
:
None
macro_doc
:
None
atoms
:
HashSet
:
:
new
(
)
}
}
pub
fn
with_atom_doc
(
&
mut
self
docs
:
&
str
)
-
>
&
mut
Self
{
self
.
atom_doc
=
Some
(
docs
.
to_owned
(
)
)
;
self
}
pub
fn
with_static_set_doc
(
&
mut
self
docs
:
&
str
)
-
>
&
mut
Self
{
self
.
static_set_doc
=
Some
(
docs
.
to_owned
(
)
)
;
self
}
pub
fn
with_macro_doc
(
&
mut
self
docs
:
&
str
)
-
>
&
mut
Self
{
self
.
macro_doc
=
Some
(
docs
.
to_owned
(
)
)
;
self
}
pub
fn
atom
(
&
mut
self
s
:
&
str
)
-
>
&
mut
Self
{
self
.
atoms
.
insert
(
s
.
to_owned
(
)
)
;
self
}
pub
fn
atoms
<
I
>
(
&
mut
self
iter
:
I
)
-
>
&
mut
Self
where
I
:
IntoIterator
I
:
:
Item
:
AsRef
<
str
>
{
self
.
atoms
.
extend
(
iter
.
into_iter
(
)
.
map
(
|
s
|
s
.
as_ref
(
)
.
to_owned
(
)
)
)
;
self
}
pub
fn
write_to
<
W
>
(
&
mut
self
mut
destination
:
W
)
-
>
io
:
:
Result
<
(
)
>
where
W
:
Write
{
destination
.
write_all
(
self
.
to_tokens
(
)
.
to_string
(
)
.
replace
(
"
[
\
"
"
"
[
\
n
\
"
"
)
.
replace
(
"
\
"
"
"
\
"
\
n
"
)
.
replace
(
"
(
\
"
"
"
\
n
(
\
"
"
)
.
replace
(
"
;
"
"
;
\
n
"
)
.
as_bytes
(
)
)
}
fn
to_tokens
(
&
mut
self
)
-
>
proc_macro2
:
:
TokenStream
{
self
.
atoms
.
insert
(
String
:
:
new
(
)
)
;
let
atoms
:
Vec
<
&
str
>
=
self
.
atoms
.
iter
(
)
.
map
(
|
s
|
&
*
*
s
)
.
collect
(
)
;
let
hash_state
=
phf_generator
:
:
generate_hash
(
&
atoms
)
;
let
phf_generator
:
:
HashState
{
key
disps
map
}
=
hash_state
;
let
(
disps0
disps1
)
:
(
Vec
<
_
>
Vec
<
_
>
)
=
disps
.
into_iter
(
)
.
unzip
(
)
;
let
atoms
:
Vec
<
&
str
>
=
map
.
iter
(
)
.
map
(
|
&
idx
|
atoms
[
idx
]
)
.
collect
(
)
;
let
atoms_ref
=
&
atoms
;
let
empty_string_index
=
atoms
.
iter
(
)
.
position
(
|
s
|
s
.
is_empty
(
)
)
.
unwrap
(
)
as
u32
;
let
data
=
(
0
.
.
atoms
.
len
(
)
)
.
map
(
|
i
|
{
format
!
(
"
0x
{
:
X
}
u64
"
shared
:
:
pack_static
(
i
as
u32
)
)
.
parse
:
:
<
proc_macro2
:
:
TokenStream
>
(
)
.
unwrap
(
)
.
into_iter
(
)
.
next
(
)
.
unwrap
(
)
}
)
;
let
hashes
:
Vec
<
u32
>
=
atoms
.
iter
(
)
.
map
(
|
string
|
{
let
hash
=
phf_shared
:
:
hash
(
string
key
)
;
(
(
hash
>
>
32
)
^
hash
)
as
u32
}
)
.
collect
(
)
;
let
type_name
=
if
let
Some
(
position
)
=
self
.
path
.
rfind
(
"
:
:
"
)
{
&
self
.
path
[
position
+
"
:
:
"
.
len
(
)
.
.
]
}
else
{
&
self
.
path
}
;
let
atom_doc
=
match
self
.
atom_doc
{
Some
(
ref
doc
)
=
>
quote
!
(
#
[
doc
=
#
doc
]
)
None
=
>
quote
!
(
)
}
;
let
static_set_doc
=
match
self
.
static_set_doc
{
Some
(
ref
doc
)
=
>
quote
!
(
#
[
doc
=
#
doc
]
)
None
=
>
quote
!
(
)
}
;
let
macro_doc
=
match
self
.
macro_doc
{
Some
(
ref
doc
)
=
>
quote
!
(
#
[
doc
=
#
doc
]
)
None
=
>
quote
!
(
)
}
;
let
new_term
=
|
string
:
&
str
|
proc_macro2
:
:
Ident
:
:
new
(
string
proc_macro2
:
:
Span
:
:
call_site
(
)
)
;
let
static_set_name
=
new_term
(
&
format
!
(
"
{
}
StaticSet
"
type_name
)
)
;
let
type_name
=
new_term
(
type_name
)
;
let
macro_name
=
new_term
(
&
*
self
.
macro_name
)
;
let
path
=
iter
:
:
repeat
(
self
.
path
.
parse
:
:
<
proc_macro2
:
:
TokenStream
>
(
)
.
unwrap
(
)
)
;
quote
!
{
#
atom_doc
pub
type
#
type_name
=
:
:
string_cache
:
:
Atom
<
#
static_set_name
>
;
#
static_set_doc
pub
struct
#
static_set_name
;
impl
:
:
string_cache
:
:
StaticAtomSet
for
#
static_set_name
{
fn
get
(
)
-
>
&
'
static
:
:
string_cache
:
:
PhfStrSet
{
static
SET
:
:
:
string_cache
:
:
PhfStrSet
=
:
:
string_cache
:
:
PhfStrSet
{
key
:
#
key
disps
:
&
[
#
(
(
#
disps0
#
disps1
)
)
*
]
atoms
:
&
[
#
(
#
atoms_ref
)
*
]
hashes
:
&
[
#
(
#
hashes
)
*
]
}
;
&
SET
}
fn
empty_string_index
(
)
-
>
u32
{
#
empty_string_index
}
}
#
macro_doc
#
[
macro_export
]
macro_rules
!
#
macro_name
{
#
(
(
#
atoms_ref
)
=
>
{
crate
:
:
#
path
{
unsafe_data
:
#
data
phantom
:
:
:
std
:
:
marker
:
:
PhantomData
}
}
;
)
*
}
}
}
pub
fn
write_to_file
(
&
mut
self
path
:
&
Path
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
write_to
(
BufWriter
:
:
new
(
try
!
(
File
:
:
create
(
path
)
)
)
)
}
}
