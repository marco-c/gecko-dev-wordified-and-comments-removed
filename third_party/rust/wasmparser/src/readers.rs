use
crate
:
:
{
BinaryReaderError
Result
}
;
use
std
:
:
ops
:
:
Range
;
mod
component
;
mod
core
;
pub
use
self
:
:
component
:
:
*
;
pub
use
self
:
:
core
:
:
*
;
pub
trait
SectionReader
{
type
Item
;
fn
read
(
&
mut
self
)
-
>
Result
<
Self
:
:
Item
>
;
fn
eof
(
&
self
)
-
>
bool
;
fn
original_position
(
&
self
)
-
>
usize
;
fn
range
(
&
self
)
-
>
Range
<
usize
>
;
fn
ensure_end
(
&
self
)
-
>
Result
<
(
)
>
{
if
self
.
eof
(
)
{
return
Ok
(
(
)
)
;
}
Err
(
BinaryReaderError
:
:
new
(
"
section
size
mismatch
:
unexpected
data
at
the
end
of
the
section
"
self
.
original_position
(
)
)
)
}
}
pub
trait
SectionWithLimitedItems
:
SectionReader
{
fn
get_count
(
&
self
)
-
>
u32
;
fn
into_iter_with_offsets
(
self
)
-
>
IntoIterWithOffsets
<
Self
>
where
Self
:
Sized
{
IntoIterWithOffsets
{
iter
:
SectionIteratorLimited
:
:
new
(
self
)
}
}
}
pub
struct
SectionIterator
<
R
>
where
R
:
SectionReader
{
reader
:
R
err
:
bool
}
impl
<
R
>
SectionIterator
<
R
>
where
R
:
SectionReader
{
pub
fn
new
(
reader
:
R
)
-
>
SectionIterator
<
R
>
{
SectionIterator
{
reader
err
:
false
}
}
}
impl
<
R
>
Iterator
for
SectionIterator
<
R
>
where
R
:
SectionReader
{
type
Item
=
Result
<
R
:
:
Item
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
err
|
|
self
.
reader
.
eof
(
)
{
return
None
;
}
let
result
=
self
.
reader
.
read
(
)
;
self
.
err
=
result
.
is_err
(
)
;
Some
(
result
)
}
}
pub
struct
SectionIteratorLimited
<
R
>
{
reader
:
R
left
:
u32
end
:
bool
}
impl
<
R
>
SectionIteratorLimited
<
R
>
where
R
:
SectionWithLimitedItems
{
pub
fn
new
(
reader
:
R
)
-
>
SectionIteratorLimited
<
R
>
{
let
left
=
reader
.
get_count
(
)
;
SectionIteratorLimited
{
reader
left
end
:
false
}
}
}
impl
<
R
>
Iterator
for
SectionIteratorLimited
<
R
>
where
R
:
SectionWithLimitedItems
{
type
Item
=
Result
<
R
:
:
Item
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
end
{
return
None
;
}
if
self
.
left
=
=
0
{
return
match
self
.
reader
.
ensure_end
(
)
{
Ok
(
(
)
)
=
>
None
Err
(
err
)
=
>
{
self
.
end
=
true
;
Some
(
Err
(
err
)
)
}
}
;
}
let
result
=
self
.
reader
.
read
(
)
;
self
.
end
=
result
.
is_err
(
)
;
self
.
left
-
=
1
;
Some
(
result
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
count
=
self
.
reader
.
get_count
(
)
as
usize
;
(
count
Some
(
count
)
)
}
}
pub
struct
IntoIterWithOffsets
<
R
>
{
iter
:
SectionIteratorLimited
<
R
>
}
impl
<
R
>
Iterator
for
IntoIterWithOffsets
<
R
>
where
R
:
SectionWithLimitedItems
{
type
Item
=
Result
<
(
usize
R
:
:
Item
)
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
pos
=
self
.
iter
.
reader
.
original_position
(
)
;
Some
(
self
.
iter
.
next
(
)
?
.
map
(
|
item
|
(
pos
item
)
)
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
