use
crate
:
:
{
BinaryReaderError
FuncType
GlobalType
HeapType
MemoryType
RefType
TableType
ValType
WasmFeatures
}
;
use
std
:
:
ops
:
:
Range
;
pub
trait
WasmFuncType
{
fn
len_inputs
(
&
self
)
-
>
usize
;
fn
len_outputs
(
&
self
)
-
>
usize
;
fn
input_at
(
&
self
at
:
u32
)
-
>
Option
<
ValType
>
;
fn
output_at
(
&
self
at
:
u32
)
-
>
Option
<
ValType
>
;
fn
inputs
(
&
self
)
-
>
WasmFuncTypeInputs
<
'
_
Self
>
where
Self
:
Sized
{
WasmFuncTypeInputs
{
func_type
:
self
range
:
0
.
.
self
.
len_inputs
(
)
as
u32
}
}
fn
outputs
(
&
self
)
-
>
WasmFuncTypeOutputs
<
'
_
Self
>
where
Self
:
Sized
{
WasmFuncTypeOutputs
{
func_type
:
self
range
:
0
.
.
self
.
len_outputs
(
)
as
u32
}
}
}
impl
<
T
>
WasmFuncType
for
&
'
_
T
where
T
:
?
Sized
+
WasmFuncType
{
fn
len_inputs
(
&
self
)
-
>
usize
{
T
:
:
len_inputs
(
self
)
}
fn
len_outputs
(
&
self
)
-
>
usize
{
T
:
:
len_outputs
(
self
)
}
fn
input_at
(
&
self
at
:
u32
)
-
>
Option
<
ValType
>
{
T
:
:
input_at
(
self
at
)
}
fn
output_at
(
&
self
at
:
u32
)
-
>
Option
<
ValType
>
{
T
:
:
output_at
(
self
at
)
}
}
pub
struct
WasmFuncTypeInputs
<
'
a
T
>
{
func_type
:
&
'
a
T
range
:
Range
<
u32
>
}
impl
<
T
>
Iterator
for
WasmFuncTypeInputs
<
'
_
T
>
where
T
:
WasmFuncType
{
type
Item
=
crate
:
:
ValType
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
range
.
next
(
)
.
map
(
|
i
|
self
.
func_type
.
input_at
(
i
)
.
unwrap
(
)
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
range
.
size_hint
(
)
}
}
impl
<
T
>
DoubleEndedIterator
for
WasmFuncTypeInputs
<
'
_
T
>
where
T
:
WasmFuncType
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
range
.
next_back
(
)
.
map
(
|
i
|
self
.
func_type
.
input_at
(
i
)
.
unwrap
(
)
)
}
}
impl
<
T
>
ExactSizeIterator
for
WasmFuncTypeInputs
<
'
_
T
>
where
T
:
WasmFuncType
{
fn
len
(
&
self
)
-
>
usize
{
self
.
range
.
len
(
)
}
}
impl
<
'
a
T
>
Clone
for
WasmFuncTypeInputs
<
'
a
T
>
{
fn
clone
(
&
self
)
-
>
WasmFuncTypeInputs
<
'
a
T
>
{
WasmFuncTypeInputs
{
func_type
:
self
.
func_type
range
:
self
.
range
.
clone
(
)
}
}
}
pub
struct
WasmFuncTypeOutputs
<
'
a
T
>
{
func_type
:
&
'
a
T
range
:
Range
<
u32
>
}
impl
<
T
>
Iterator
for
WasmFuncTypeOutputs
<
'
_
T
>
where
T
:
WasmFuncType
{
type
Item
=
crate
:
:
ValType
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
range
.
next
(
)
.
map
(
|
i
|
self
.
func_type
.
output_at
(
i
)
.
unwrap
(
)
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
range
.
size_hint
(
)
}
}
impl
<
T
>
DoubleEndedIterator
for
WasmFuncTypeOutputs
<
'
_
T
>
where
T
:
WasmFuncType
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
range
.
next_back
(
)
.
map
(
|
i
|
self
.
func_type
.
output_at
(
i
)
.
unwrap
(
)
)
}
}
impl
<
T
>
ExactSizeIterator
for
WasmFuncTypeOutputs
<
'
_
T
>
where
T
:
WasmFuncType
{
fn
len
(
&
self
)
-
>
usize
{
self
.
range
.
len
(
)
}
}
impl
<
'
a
T
>
Clone
for
WasmFuncTypeOutputs
<
'
a
T
>
{
fn
clone
(
&
self
)
-
>
WasmFuncTypeOutputs
<
'
a
T
>
{
WasmFuncTypeOutputs
{
func_type
:
self
.
func_type
range
:
self
.
range
.
clone
(
)
}
}
}
pub
trait
WasmModuleResources
{
type
FuncType
:
WasmFuncType
;
fn
table_at
(
&
self
at
:
u32
)
-
>
Option
<
TableType
>
;
fn
memory_at
(
&
self
at
:
u32
)
-
>
Option
<
MemoryType
>
;
fn
tag_at
(
&
self
at
:
u32
)
-
>
Option
<
&
Self
:
:
FuncType
>
;
fn
global_at
(
&
self
at
:
u32
)
-
>
Option
<
GlobalType
>
;
fn
func_type_at
(
&
self
type_idx
:
u32
)
-
>
Option
<
&
Self
:
:
FuncType
>
;
fn
type_index_of_function
(
&
self
func_idx
:
u32
)
-
>
Option
<
u32
>
;
fn
type_of_function
(
&
self
func_idx
:
u32
)
-
>
Option
<
&
Self
:
:
FuncType
>
;
fn
element_type_at
(
&
self
at
:
u32
)
-
>
Option
<
RefType
>
;
fn
matches
(
&
self
t1
:
ValType
t2
:
ValType
)
-
>
bool
;
fn
check_value_type
(
&
self
t
:
ValType
features
:
&
WasmFeatures
offset
:
usize
)
-
>
Result
<
(
)
BinaryReaderError
>
;
fn
check_heap_type
(
&
self
heap_type
:
HeapType
features
:
&
WasmFeatures
offset
:
usize
)
-
>
Result
<
(
)
BinaryReaderError
>
{
self
.
check_value_type
(
RefType
:
:
new
(
true
heap_type
)
.
ok_or_else
(
|
|
{
BinaryReaderError
:
:
new
(
"
heap
type
index
beyond
this
crate
'
s
implementation
limits
"
offset
)
}
)
?
.
into
(
)
features
offset
)
}
fn
element_count
(
&
self
)
-
>
u32
;
fn
data_count
(
&
self
)
-
>
Option
<
u32
>
;
fn
is_function_referenced
(
&
self
idx
:
u32
)
-
>
bool
;
}
impl
<
T
>
WasmModuleResources
for
&
'
_
T
where
T
:
?
Sized
+
WasmModuleResources
{
type
FuncType
=
T
:
:
FuncType
;
fn
table_at
(
&
self
at
:
u32
)
-
>
Option
<
TableType
>
{
T
:
:
table_at
(
self
at
)
}
fn
memory_at
(
&
self
at
:
u32
)
-
>
Option
<
MemoryType
>
{
T
:
:
memory_at
(
self
at
)
}
fn
tag_at
(
&
self
at
:
u32
)
-
>
Option
<
&
Self
:
:
FuncType
>
{
T
:
:
tag_at
(
self
at
)
}
fn
global_at
(
&
self
at
:
u32
)
-
>
Option
<
GlobalType
>
{
T
:
:
global_at
(
self
at
)
}
fn
func_type_at
(
&
self
at
:
u32
)
-
>
Option
<
&
Self
:
:
FuncType
>
{
T
:
:
func_type_at
(
self
at
)
}
fn
type_index_of_function
(
&
self
func_idx
:
u32
)
-
>
Option
<
u32
>
{
T
:
:
type_index_of_function
(
self
func_idx
)
}
fn
type_of_function
(
&
self
func_idx
:
u32
)
-
>
Option
<
&
Self
:
:
FuncType
>
{
T
:
:
type_of_function
(
self
func_idx
)
}
fn
check_value_type
(
&
self
t
:
ValType
features
:
&
WasmFeatures
offset
:
usize
)
-
>
Result
<
(
)
BinaryReaderError
>
{
T
:
:
check_value_type
(
self
t
features
offset
)
}
fn
element_type_at
(
&
self
at
:
u32
)
-
>
Option
<
RefType
>
{
T
:
:
element_type_at
(
self
at
)
}
fn
matches
(
&
self
t1
:
ValType
t2
:
ValType
)
-
>
bool
{
T
:
:
matches
(
self
t1
t2
)
}
fn
element_count
(
&
self
)
-
>
u32
{
T
:
:
element_count
(
self
)
}
fn
data_count
(
&
self
)
-
>
Option
<
u32
>
{
T
:
:
data_count
(
self
)
}
fn
is_function_referenced
(
&
self
idx
:
u32
)
-
>
bool
{
T
:
:
is_function_referenced
(
self
idx
)
}
}
impl
<
T
>
WasmModuleResources
for
std
:
:
sync
:
:
Arc
<
T
>
where
T
:
WasmModuleResources
{
type
FuncType
=
T
:
:
FuncType
;
fn
table_at
(
&
self
at
:
u32
)
-
>
Option
<
TableType
>
{
T
:
:
table_at
(
self
at
)
}
fn
memory_at
(
&
self
at
:
u32
)
-
>
Option
<
MemoryType
>
{
T
:
:
memory_at
(
self
at
)
}
fn
tag_at
(
&
self
at
:
u32
)
-
>
Option
<
&
Self
:
:
FuncType
>
{
T
:
:
tag_at
(
self
at
)
}
fn
global_at
(
&
self
at
:
u32
)
-
>
Option
<
GlobalType
>
{
T
:
:
global_at
(
self
at
)
}
fn
func_type_at
(
&
self
type_idx
:
u32
)
-
>
Option
<
&
Self
:
:
FuncType
>
{
T
:
:
func_type_at
(
self
type_idx
)
}
fn
type_index_of_function
(
&
self
func_idx
:
u32
)
-
>
Option
<
u32
>
{
T
:
:
type_index_of_function
(
self
func_idx
)
}
fn
type_of_function
(
&
self
func_idx
:
u32
)
-
>
Option
<
&
Self
:
:
FuncType
>
{
T
:
:
type_of_function
(
self
func_idx
)
}
fn
check_value_type
(
&
self
t
:
ValType
features
:
&
WasmFeatures
offset
:
usize
)
-
>
Result
<
(
)
BinaryReaderError
>
{
T
:
:
check_value_type
(
self
t
features
offset
)
}
fn
element_type_at
(
&
self
at
:
u32
)
-
>
Option
<
RefType
>
{
T
:
:
element_type_at
(
self
at
)
}
fn
matches
(
&
self
t1
:
ValType
t2
:
ValType
)
-
>
bool
{
T
:
:
matches
(
self
t1
t2
)
}
fn
element_count
(
&
self
)
-
>
u32
{
T
:
:
element_count
(
self
)
}
fn
data_count
(
&
self
)
-
>
Option
<
u32
>
{
T
:
:
data_count
(
self
)
}
fn
is_function_referenced
(
&
self
idx
:
u32
)
-
>
bool
{
T
:
:
is_function_referenced
(
self
idx
)
}
}
impl
WasmFuncType
for
FuncType
{
fn
len_inputs
(
&
self
)
-
>
usize
{
self
.
params
(
)
.
len
(
)
}
fn
len_outputs
(
&
self
)
-
>
usize
{
self
.
results
(
)
.
len
(
)
}
fn
input_at
(
&
self
at
:
u32
)
-
>
Option
<
ValType
>
{
self
.
params
(
)
.
get
(
at
as
usize
)
.
copied
(
)
}
fn
output_at
(
&
self
at
:
u32
)
-
>
Option
<
ValType
>
{
self
.
results
(
)
.
get
(
at
as
usize
)
.
copied
(
)
}
}
