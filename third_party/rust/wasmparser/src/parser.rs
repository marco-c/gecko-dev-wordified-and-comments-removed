use
crate
:
:
CoreTypeSectionReader
;
use
crate
:
:
{
limits
:
:
MAX_WASM_MODULE_SIZE
AliasSectionReader
BinaryReader
BinaryReaderError
ComponentAliasSectionReader
ComponentCanonicalSectionReader
ComponentExportSectionReader
ComponentImportSectionReader
ComponentInstanceSectionReader
ComponentStartSectionReader
ComponentTypeSectionReader
CustomSectionReader
DataSectionReader
ElementSectionReader
ExportSectionReader
FunctionBody
FunctionSectionReader
GlobalSectionReader
ImportSectionReader
InstanceSectionReader
MemorySectionReader
Result
TableSectionReader
TagSectionReader
TypeSectionReader
}
;
use
std
:
:
convert
:
:
TryInto
;
use
std
:
:
fmt
;
use
std
:
:
iter
;
use
std
:
:
ops
:
:
Range
;
pub
(
crate
)
const
WASM_EXPERIMENTAL_VERSION
:
u32
=
0xd
;
pub
(
crate
)
const
WASM_MODULE_VERSION
:
u32
=
0x1
;
pub
(
crate
)
const
WASM_COMPONENT_VERSION
:
u32
=
0x0001000a
;
#
[
derive
(
Debug
Clone
Copy
Eq
PartialEq
)
]
pub
enum
Encoding
{
Module
Component
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Parser
{
state
:
State
offset
:
u64
max_size
:
u64
encoding
:
Encoding
}
#
[
derive
(
Debug
Clone
)
]
enum
State
{
Header
SectionStart
FunctionBody
{
remaining
:
u32
len
:
u32
}
}
#
[
derive
(
Debug
)
]
pub
enum
Chunk
<
'
a
>
{
NeedMoreData
(
u64
)
Parsed
{
consumed
:
usize
payload
:
Payload
<
'
a
>
}
}
pub
enum
Payload
<
'
a
>
{
Version
{
num
:
u32
encoding
:
Encoding
range
:
Range
<
usize
>
}
TypeSection
(
TypeSectionReader
<
'
a
>
)
ImportSection
(
ImportSectionReader
<
'
a
>
)
FunctionSection
(
FunctionSectionReader
<
'
a
>
)
TableSection
(
TableSectionReader
<
'
a
>
)
MemorySection
(
MemorySectionReader
<
'
a
>
)
TagSection
(
TagSectionReader
<
'
a
>
)
GlobalSection
(
GlobalSectionReader
<
'
a
>
)
ExportSection
(
ExportSectionReader
<
'
a
>
)
StartSection
{
func
:
u32
range
:
Range
<
usize
>
}
ElementSection
(
ElementSectionReader
<
'
a
>
)
DataCountSection
{
count
:
u32
range
:
Range
<
usize
>
}
DataSection
(
DataSectionReader
<
'
a
>
)
CodeSectionStart
{
count
:
u32
range
:
Range
<
usize
>
size
:
u32
}
CodeSectionEntry
(
FunctionBody
<
'
a
>
)
ModuleSection
{
parser
:
Parser
range
:
Range
<
usize
>
}
InstanceSection
(
InstanceSectionReader
<
'
a
>
)
AliasSection
(
AliasSectionReader
<
'
a
>
)
CoreTypeSection
(
CoreTypeSectionReader
<
'
a
>
)
ComponentSection
{
parser
:
Parser
range
:
Range
<
usize
>
}
ComponentInstanceSection
(
ComponentInstanceSectionReader
<
'
a
>
)
ComponentAliasSection
(
ComponentAliasSectionReader
<
'
a
>
)
ComponentTypeSection
(
ComponentTypeSectionReader
<
'
a
>
)
ComponentCanonicalSection
(
ComponentCanonicalSectionReader
<
'
a
>
)
ComponentStartSection
(
ComponentStartSectionReader
<
'
a
>
)
ComponentImportSection
(
ComponentImportSectionReader
<
'
a
>
)
ComponentExportSection
(
ComponentExportSectionReader
<
'
a
>
)
CustomSection
(
CustomSectionReader
<
'
a
>
)
UnknownSection
{
id
:
u8
contents
:
&
'
a
[
u8
]
range
:
Range
<
usize
>
}
End
(
usize
)
}
impl
Parser
{
pub
fn
new
(
offset
:
u64
)
-
>
Parser
{
Parser
{
state
:
State
:
:
Header
offset
max_size
:
u64
:
:
max_value
(
)
encoding
:
Encoding
:
:
Module
}
}
pub
fn
parse
<
'
a
>
(
&
mut
self
data
:
&
'
a
[
u8
]
eof
:
bool
)
-
>
Result
<
Chunk
<
'
a
>
>
{
let
(
data
eof
)
=
if
usize_to_u64
(
data
.
len
(
)
)
>
self
.
max_size
{
(
&
data
[
.
.
(
self
.
max_size
as
usize
)
]
true
)
}
else
{
(
data
eof
)
}
;
let
mut
reader
=
BinaryReader
:
:
new_with_offset
(
data
self
.
offset
as
usize
)
;
match
self
.
parse_reader
(
&
mut
reader
eof
)
{
Ok
(
payload
)
=
>
{
self
.
offset
+
=
usize_to_u64
(
reader
.
position
)
;
self
.
max_size
-
=
usize_to_u64
(
reader
.
position
)
;
Ok
(
Chunk
:
:
Parsed
{
consumed
:
reader
.
position
payload
}
)
}
Err
(
e
)
=
>
{
if
eof
{
return
Err
(
e
)
;
}
match
e
.
inner
.
needed_hint
{
Some
(
hint
)
=
>
Ok
(
Chunk
:
:
NeedMoreData
(
usize_to_u64
(
hint
)
)
)
None
=
>
Err
(
e
)
}
}
}
}
fn
parse_reader
<
'
a
>
(
&
mut
self
reader
:
&
mut
BinaryReader
<
'
a
>
eof
:
bool
)
-
>
Result
<
Payload
<
'
a
>
>
{
use
Payload
:
:
*
;
match
self
.
state
{
State
:
:
Header
=
>
{
let
start
=
reader
.
original_position
(
)
;
let
num
=
reader
.
read_header_version
(
)
?
;
self
.
encoding
=
match
num
{
WASM_EXPERIMENTAL_VERSION
|
WASM_MODULE_VERSION
=
>
Encoding
:
:
Module
WASM_COMPONENT_VERSION
=
>
Encoding
:
:
Component
_
=
>
{
return
Err
(
BinaryReaderError
:
:
new
(
"
unknown
binary
version
"
reader
.
original_position
(
)
-
4
)
)
}
}
;
self
.
state
=
State
:
:
SectionStart
;
Ok
(
Version
{
num
encoding
:
self
.
encoding
range
:
start
.
.
reader
.
original_position
(
)
}
)
}
State
:
:
SectionStart
=
>
{
if
eof
&
&
reader
.
bytes_remaining
(
)
=
=
0
{
return
Ok
(
Payload
:
:
End
(
reader
.
original_position
(
)
)
)
;
}
let
id_pos
=
reader
.
position
;
let
id
=
reader
.
read_u8
(
)
?
;
if
id
&
0x80
!
=
0
{
return
Err
(
BinaryReaderError
:
:
new
(
"
malformed
section
id
"
id_pos
)
)
;
}
let
len_pos
=
reader
.
position
;
let
mut
len
=
reader
.
read_var_u32
(
)
?
;
let
section_overflow
=
self
.
max_size
.
checked_sub
(
usize_to_u64
(
reader
.
position
)
)
.
and_then
(
|
s
|
s
.
checked_sub
(
len
.
into
(
)
)
)
.
is_none
(
)
;
if
section_overflow
{
return
Err
(
BinaryReaderError
:
:
new
(
"
section
too
large
"
len_pos
)
)
;
}
if
id
=
=
0
{
}
match
(
self
.
encoding
id
)
{
(
_
0
)
=
>
section
(
reader
len
CustomSectionReader
:
:
new
CustomSection
)
(
Encoding
:
:
Module
1
)
=
>
{
section
(
reader
len
TypeSectionReader
:
:
new
TypeSection
)
}
(
Encoding
:
:
Module
2
)
=
>
{
section
(
reader
len
ImportSectionReader
:
:
new
ImportSection
)
}
(
Encoding
:
:
Module
3
)
=
>
{
section
(
reader
len
FunctionSectionReader
:
:
new
FunctionSection
)
}
(
Encoding
:
:
Module
4
)
=
>
{
section
(
reader
len
TableSectionReader
:
:
new
TableSection
)
}
(
Encoding
:
:
Module
5
)
=
>
{
section
(
reader
len
MemorySectionReader
:
:
new
MemorySection
)
}
(
Encoding
:
:
Module
6
)
=
>
{
section
(
reader
len
GlobalSectionReader
:
:
new
GlobalSection
)
}
(
Encoding
:
:
Module
7
)
=
>
{
section
(
reader
len
ExportSectionReader
:
:
new
ExportSection
)
}
(
Encoding
:
:
Module
8
)
=
>
{
let
(
func
range
)
=
single_u32
(
reader
len
"
start
"
)
?
;
Ok
(
StartSection
{
func
range
}
)
}
(
Encoding
:
:
Module
9
)
=
>
{
section
(
reader
len
ElementSectionReader
:
:
new
ElementSection
)
}
(
Encoding
:
:
Module
10
)
=
>
{
let
start
=
reader
.
original_position
(
)
;
let
count
=
delimited
(
reader
&
mut
len
|
r
|
r
.
read_var_u32
(
)
)
?
;
let
range
=
start
.
.
reader
.
original_position
(
)
+
len
as
usize
;
self
.
state
=
State
:
:
FunctionBody
{
remaining
:
count
len
}
;
Ok
(
CodeSectionStart
{
count
range
size
:
len
}
)
}
(
Encoding
:
:
Module
11
)
=
>
{
section
(
reader
len
DataSectionReader
:
:
new
DataSection
)
}
(
Encoding
:
:
Module
12
)
=
>
{
let
(
count
range
)
=
single_u32
(
reader
len
"
data
count
"
)
?
;
Ok
(
DataCountSection
{
count
range
}
)
}
(
Encoding
:
:
Module
13
)
=
>
{
section
(
reader
len
TagSectionReader
:
:
new
TagSection
)
}
(
Encoding
:
:
Component
1
)
|
(
Encoding
:
:
Component
5
)
=
>
{
if
len
as
usize
>
MAX_WASM_MODULE_SIZE
{
return
Err
(
BinaryReaderError
:
:
new
(
format
!
(
"
{
}
section
is
too
large
"
if
id
=
=
1
{
"
module
"
}
else
{
"
component
"
}
)
len_pos
)
)
;
}
let
range
=
reader
.
original_position
(
)
.
.
reader
.
original_position
(
)
+
len
as
usize
;
self
.
max_size
-
=
u64
:
:
from
(
len
)
;
self
.
offset
+
=
u64
:
:
from
(
len
)
;
let
mut
parser
=
Parser
:
:
new
(
usize_to_u64
(
reader
.
original_position
(
)
)
)
;
parser
.
max_size
=
len
.
into
(
)
;
Ok
(
match
id
{
1
=
>
ModuleSection
{
parser
range
}
5
=
>
ComponentSection
{
parser
range
}
_
=
>
unreachable
!
(
)
}
)
}
(
Encoding
:
:
Component
2
)
=
>
{
section
(
reader
len
InstanceSectionReader
:
:
new
InstanceSection
)
}
(
Encoding
:
:
Component
3
)
=
>
{
section
(
reader
len
AliasSectionReader
:
:
new
AliasSection
)
}
(
Encoding
:
:
Component
4
)
=
>
{
section
(
reader
len
CoreTypeSectionReader
:
:
new
CoreTypeSection
)
}
(
Encoding
:
:
Component
6
)
=
>
section
(
reader
len
ComponentInstanceSectionReader
:
:
new
ComponentInstanceSection
)
(
Encoding
:
:
Component
7
)
=
>
section
(
reader
len
ComponentAliasSectionReader
:
:
new
ComponentAliasSection
)
(
Encoding
:
:
Component
8
)
=
>
section
(
reader
len
ComponentTypeSectionReader
:
:
new
ComponentTypeSection
)
(
Encoding
:
:
Component
9
)
=
>
section
(
reader
len
ComponentCanonicalSectionReader
:
:
new
ComponentCanonicalSection
)
(
Encoding
:
:
Component
10
)
=
>
section
(
reader
len
ComponentStartSectionReader
:
:
new
ComponentStartSection
)
(
Encoding
:
:
Component
11
)
=
>
section
(
reader
len
ComponentImportSectionReader
:
:
new
ComponentImportSection
)
(
Encoding
:
:
Component
12
)
=
>
section
(
reader
len
ComponentExportSectionReader
:
:
new
ComponentExportSection
)
(
_
id
)
=
>
{
let
offset
=
reader
.
original_position
(
)
;
let
contents
=
reader
.
read_bytes
(
len
as
usize
)
?
;
let
range
=
offset
.
.
offset
+
len
as
usize
;
Ok
(
UnknownSection
{
id
contents
range
}
)
}
}
}
State
:
:
FunctionBody
{
remaining
:
0
len
:
0
}
=
>
{
self
.
state
=
State
:
:
SectionStart
;
self
.
parse_reader
(
reader
eof
)
}
State
:
:
FunctionBody
{
remaining
:
0
len
}
=
>
{
debug_assert
!
(
len
>
0
)
;
let
offset
=
reader
.
original_position
(
)
;
Err
(
BinaryReaderError
:
:
new
(
"
trailing
bytes
at
end
of
section
"
offset
)
)
}
State
:
:
FunctionBody
{
remaining
mut
len
}
=
>
{
let
body
=
delimited
(
reader
&
mut
len
|
r
|
{
let
size
=
r
.
read_var_u32
(
)
?
;
let
offset
=
r
.
original_position
(
)
;
Ok
(
FunctionBody
:
:
new
(
offset
r
.
read_bytes
(
size
as
usize
)
?
)
)
}
)
?
;
self
.
state
=
State
:
:
FunctionBody
{
remaining
:
remaining
-
1
len
}
;
Ok
(
CodeSectionEntry
(
body
)
)
}
}
}
pub
fn
parse_all
(
self
mut
data
:
&
[
u8
]
)
-
>
impl
Iterator
<
Item
=
Result
<
Payload
>
>
{
let
mut
stack
=
Vec
:
:
new
(
)
;
let
mut
cur
=
self
;
let
mut
done
=
false
;
iter
:
:
from_fn
(
move
|
|
{
if
done
{
return
None
;
}
let
payload
=
match
cur
.
parse
(
data
true
)
{
Err
(
e
)
=
>
{
done
=
true
;
return
Some
(
Err
(
e
)
)
;
}
Ok
(
Chunk
:
:
NeedMoreData
(
_
)
)
=
>
unreachable
!
(
)
Ok
(
Chunk
:
:
Parsed
{
payload
consumed
}
)
=
>
{
data
=
&
data
[
consumed
.
.
]
;
payload
}
}
;
match
&
payload
{
Payload
:
:
ModuleSection
{
parser
.
.
}
|
Payload
:
:
ComponentSection
{
parser
.
.
}
=
>
{
stack
.
push
(
cur
.
clone
(
)
)
;
cur
=
parser
.
clone
(
)
;
}
Payload
:
:
End
(
_
)
=
>
match
stack
.
pop
(
)
{
Some
(
p
)
=
>
cur
=
p
None
=
>
done
=
true
}
_
=
>
{
}
}
Some
(
Ok
(
payload
)
)
}
)
}
pub
fn
skip_section
(
&
mut
self
)
{
let
skip
=
match
self
.
state
{
State
:
:
FunctionBody
{
remaining
:
_
len
}
=
>
len
_
=
>
panic
!
(
"
wrong
state
to
call
skip_section
"
)
}
;
self
.
offset
+
=
u64
:
:
from
(
skip
)
;
self
.
max_size
-
=
u64
:
:
from
(
skip
)
;
self
.
state
=
State
:
:
SectionStart
;
}
}
fn
usize_to_u64
(
a
:
usize
)
-
>
u64
{
a
.
try_into
(
)
.
unwrap
(
)
}
fn
section
<
'
a
T
>
(
reader
:
&
mut
BinaryReader
<
'
a
>
len
:
u32
ctor
:
fn
(
&
'
a
[
u8
]
usize
)
-
>
Result
<
T
>
variant
:
fn
(
T
)
-
>
Payload
<
'
a
>
)
-
>
Result
<
Payload
<
'
a
>
>
{
let
offset
=
reader
.
original_position
(
)
;
let
payload
=
reader
.
read_bytes
(
len
as
usize
)
?
;
let
reader
=
ctor
(
payload
offset
)
.
map_err
(
clear_hint
)
?
;
Ok
(
variant
(
reader
)
)
}
fn
subreader
<
'
a
>
(
reader
:
&
mut
BinaryReader
<
'
a
>
len
:
u32
)
-
>
Result
<
BinaryReader
<
'
a
>
>
{
let
offset
=
reader
.
original_position
(
)
;
let
payload
=
reader
.
read_bytes
(
len
as
usize
)
?
;
Ok
(
BinaryReader
:
:
new_with_offset
(
payload
offset
)
)
}
fn
single_u32
<
'
a
>
(
reader
:
&
mut
BinaryReader
<
'
a
>
len
:
u32
desc
:
&
str
)
-
>
Result
<
(
u32
Range
<
usize
>
)
>
{
let
range
=
reader
.
original_position
(
)
.
.
reader
.
original_position
(
)
+
len
as
usize
;
let
mut
content
=
subreader
(
reader
len
)
?
;
let
index
=
content
.
read_var_u32
(
)
.
map_err
(
clear_hint
)
?
;
if
!
content
.
eof
(
)
{
return
Err
(
BinaryReaderError
:
:
new
(
format
!
(
"
unexpected
content
in
the
{
}
section
"
desc
)
content
.
original_position
(
)
)
)
;
}
Ok
(
(
index
range
)
)
}
fn
delimited
<
'
a
T
>
(
reader
:
&
mut
BinaryReader
<
'
a
>
len
:
&
mut
u32
f
:
impl
FnOnce
(
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
T
>
)
-
>
Result
<
T
>
{
let
start
=
reader
.
position
;
let
ret
=
f
(
reader
)
?
;
*
len
=
match
(
reader
.
position
-
start
)
.
try_into
(
)
.
ok
(
)
.
and_then
(
|
i
|
len
.
checked_sub
(
i
)
)
{
Some
(
i
)
=
>
i
None
=
>
return
Err
(
BinaryReaderError
:
:
new
(
"
unexpected
end
-
of
-
file
"
start
)
)
}
;
Ok
(
ret
)
}
impl
Default
for
Parser
{
fn
default
(
)
-
>
Parser
{
Parser
:
:
new
(
0
)
}
}
impl
fmt
:
:
Debug
for
Payload
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
use
Payload
:
:
*
;
match
self
{
Version
{
num
encoding
range
}
=
>
f
.
debug_struct
(
"
Version
"
)
.
field
(
"
num
"
num
)
.
field
(
"
encoding
"
encoding
)
.
field
(
"
range
"
range
)
.
finish
(
)
TypeSection
(
_
)
=
>
f
.
debug_tuple
(
"
TypeSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ImportSection
(
_
)
=
>
f
.
debug_tuple
(
"
ImportSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
FunctionSection
(
_
)
=
>
f
.
debug_tuple
(
"
FunctionSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
TableSection
(
_
)
=
>
f
.
debug_tuple
(
"
TableSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
MemorySection
(
_
)
=
>
f
.
debug_tuple
(
"
MemorySection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
TagSection
(
_
)
=
>
f
.
debug_tuple
(
"
TagSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
GlobalSection
(
_
)
=
>
f
.
debug_tuple
(
"
GlobalSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ExportSection
(
_
)
=
>
f
.
debug_tuple
(
"
ExportSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ElementSection
(
_
)
=
>
f
.
debug_tuple
(
"
ElementSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
DataSection
(
_
)
=
>
f
.
debug_tuple
(
"
DataSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
StartSection
{
func
range
}
=
>
f
.
debug_struct
(
"
StartSection
"
)
.
field
(
"
func
"
func
)
.
field
(
"
range
"
range
)
.
finish
(
)
DataCountSection
{
count
range
}
=
>
f
.
debug_struct
(
"
DataCountSection
"
)
.
field
(
"
count
"
count
)
.
field
(
"
range
"
range
)
.
finish
(
)
CodeSectionStart
{
count
range
size
}
=
>
f
.
debug_struct
(
"
CodeSectionStart
"
)
.
field
(
"
count
"
count
)
.
field
(
"
range
"
range
)
.
field
(
"
size
"
size
)
.
finish
(
)
CodeSectionEntry
(
_
)
=
>
f
.
debug_tuple
(
"
CodeSectionEntry
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ModuleSection
{
parser
:
_
range
}
=
>
f
.
debug_struct
(
"
ModuleSection
"
)
.
field
(
"
range
"
range
)
.
finish
(
)
InstanceSection
(
_
)
=
>
f
.
debug_tuple
(
"
InstanceSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
AliasSection
(
_
)
=
>
f
.
debug_tuple
(
"
AliasSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
CoreTypeSection
(
_
)
=
>
f
.
debug_tuple
(
"
CoreTypeSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ComponentSection
{
parser
:
_
range
}
=
>
f
.
debug_struct
(
"
ComponentSection
"
)
.
field
(
"
range
"
range
)
.
finish
(
)
ComponentInstanceSection
(
_
)
=
>
f
.
debug_tuple
(
"
ComponentInstanceSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ComponentAliasSection
(
_
)
=
>
f
.
debug_tuple
(
"
ComponentAliasSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ComponentTypeSection
(
_
)
=
>
f
.
debug_tuple
(
"
ComponentTypeSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ComponentCanonicalSection
(
_
)
=
>
f
.
debug_tuple
(
"
ComponentCanonicalSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ComponentStartSection
(
_
)
=
>
f
.
debug_tuple
(
"
ComponentStartSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ComponentImportSection
(
_
)
=
>
f
.
debug_tuple
(
"
ComponentImportSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ComponentExportSection
(
_
)
=
>
f
.
debug_tuple
(
"
ComponentExportSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
CustomSection
(
c
)
=
>
f
.
debug_tuple
(
"
CustomSection
"
)
.
field
(
c
)
.
finish
(
)
UnknownSection
{
id
range
.
.
}
=
>
f
.
debug_struct
(
"
UnknownSection
"
)
.
field
(
"
id
"
id
)
.
field
(
"
range
"
range
)
.
finish
(
)
End
(
offset
)
=
>
f
.
debug_tuple
(
"
End
"
)
.
field
(
offset
)
.
finish
(
)
}
}
}
fn
clear_hint
(
mut
err
:
BinaryReaderError
)
-
>
BinaryReaderError
{
err
.
inner
.
needed_hint
=
None
;
err
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
macro_rules
!
assert_matches
{
(
a
:
expr
b
:
pat
(
)
?
)
=
>
{
match
a
{
b
=
>
{
}
a
=
>
panic
!
(
"
{
:
?
}
doesn
'
t
match
{
}
"
a
stringify
!
(
b
)
)
}
}
;
}
#
[
test
]
fn
header
(
)
{
assert
!
(
Parser
:
:
default
(
)
.
parse
(
&
[
]
true
)
.
is_err
(
)
)
;
assert_matches
!
(
Parser
:
:
default
(
)
.
parse
(
&
[
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
4
)
)
)
;
assert_matches
!
(
Parser
:
:
default
(
)
.
parse
(
b
"
\
0
"
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
3
)
)
)
;
assert_matches
!
(
Parser
:
:
default
(
)
.
parse
(
b
"
\
0asm
"
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
4
)
)
)
;
assert_matches
!
(
Parser
:
:
default
(
)
.
parse
(
b
"
\
0asm
\
x01
\
0
\
0
\
0
"
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
8
payload
:
Payload
:
:
Version
{
num
:
1
.
.
}
}
)
)
;
}
#
[
test
]
fn
header_iter
(
)
{
for
_
in
Parser
:
:
default
(
)
.
parse_all
(
&
[
]
)
{
}
for
_
in
Parser
:
:
default
(
)
.
parse_all
(
b
"
\
0
"
)
{
}
for
_
in
Parser
:
:
default
(
)
.
parse_all
(
b
"
\
0asm
"
)
{
}
for
_
in
Parser
:
:
default
(
)
.
parse_all
(
b
"
\
0asm
\
x01
\
x01
\
x01
\
x01
"
)
{
}
}
fn
parser_after_header
(
)
-
>
Parser
{
let
mut
p
=
Parser
:
:
default
(
)
;
assert_matches
!
(
p
.
parse
(
b
"
\
0asm
\
x01
\
0
\
0
\
0
"
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
8
payload
:
Payload
:
:
Version
{
num
:
WASM_MODULE_VERSION
encoding
:
Encoding
:
:
Module
.
.
}
}
)
)
;
p
}
fn
parser_after_component_header
(
)
-
>
Parser
{
let
mut
p
=
Parser
:
:
default
(
)
;
assert_matches
!
(
p
.
parse
(
b
"
\
0asm
\
x0a
\
0
\
x01
\
0
"
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
8
payload
:
Payload
:
:
Version
{
num
:
WASM_COMPONENT_VERSION
encoding
:
Encoding
:
:
Component
.
.
}
}
)
)
;
p
}
#
[
test
]
fn
start_section
(
)
{
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
8
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
8
1
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
8
2
]
true
)
.
is_err
(
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
8
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
8
1
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
8
2
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
2
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
8
1
1
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
StartSection
{
func
:
1
.
.
}
}
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
8
2
1
1
]
false
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
8
0
]
false
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
end_works
(
)
{
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
]
true
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
0
payload
:
Payload
:
:
End
(
8
)
}
)
)
;
}
#
[
test
]
fn
type_section
(
)
{
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
1
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
1
0
]
false
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
8
2
]
true
)
.
is_err
(
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
1
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
1
1
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
1
1
1
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
TypeSection
(
_
)
}
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
1
1
1
2
3
4
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
TypeSection
(
_
)
}
)
)
;
}
#
[
test
]
fn
custom_section
(
)
{
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
0
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
0
0
]
false
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
0
1
1
]
false
)
.
is_err
(
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
0
2
1
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
0
1
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CustomSection
(
CustomSectionReader
{
name
:
"
"
data_offset
:
11
data
:
b
"
"
range
:
Range
{
start
:
10
end
:
11
}
}
)
}
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
0
2
1
b
'
a
'
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
4
payload
:
Payload
:
:
CustomSection
(
CustomSectionReader
{
name
:
"
a
"
data_offset
:
12
data
:
b
"
"
range
:
Range
{
start
:
10
end
:
12
}
}
)
}
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
0
2
0
b
'
a
'
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
4
payload
:
Payload
:
:
CustomSection
(
CustomSectionReader
{
name
:
"
"
data_offset
:
11
data
:
b
"
a
"
range
:
Range
{
start
:
10
end
:
12
}
}
)
}
)
)
;
}
#
[
test
]
fn
function_section
(
)
{
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
10
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
10
0
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
10
1
]
true
)
.
is_err
(
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
10
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
10
1
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
10
1
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CodeSectionStart
{
count
:
0
.
.
}
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
]
true
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
0
payload
:
Payload
:
:
End
(
11
)
}
)
)
;
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
10
2
1
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CodeSectionStart
{
count
:
1
.
.
}
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
1
payload
:
Payload
:
:
CodeSectionEntry
(
_
)
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
]
true
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
0
payload
:
Payload
:
:
End
(
12
)
}
)
)
;
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
10
1
1
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CodeSectionStart
{
count
:
1
.
.
}
}
)
)
;
assert_eq
!
(
p
.
parse
(
&
[
0
]
false
)
.
unwrap_err
(
)
.
message
(
)
"
unexpected
end
-
of
-
file
"
)
;
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
10
2
2
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CodeSectionStart
{
count
:
2
.
.
}
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
1
payload
:
Payload
:
:
CodeSectionEntry
(
_
)
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_eq
!
(
p
.
parse
(
&
[
0
]
false
)
.
unwrap_err
(
)
.
message
(
)
"
unexpected
end
-
of
-
file
"
)
;
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
10
3
1
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CodeSectionStart
{
count
:
1
.
.
}
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
1
payload
:
Payload
:
:
CodeSectionEntry
(
_
)
}
)
)
;
assert_eq
!
(
p
.
parse
(
&
[
0
]
false
)
.
unwrap_err
(
)
.
message
(
)
"
trailing
bytes
at
end
of
section
"
)
;
}
#
[
test
]
fn
single_module
(
)
{
let
mut
p
=
parser_after_component_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
4
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
let
mut
sub
=
match
p
.
parse
(
&
[
1
8
]
false
)
{
Ok
(
Chunk
:
:
Parsed
{
consumed
:
2
payload
:
Payload
:
:
ModuleSection
{
parser
.
.
}
}
)
=
>
parser
other
=
>
panic
!
(
"
bad
parse
{
:
?
}
"
other
)
}
;
assert_matches
!
(
sub
.
parse
(
&
[
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
4
)
)
)
;
assert_matches
!
(
sub
.
parse
(
b
"
\
0asm
"
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
4
)
)
)
;
assert_matches
!
(
sub
.
parse
(
b
"
\
0asm
\
x01
\
0
\
0
\
0
"
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
8
payload
:
Payload
:
:
Version
{
num
:
1
encoding
:
Encoding
:
:
Module
.
.
}
}
)
)
;
assert_matches
!
(
sub
.
parse
(
&
[
10
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
0
payload
:
Payload
:
:
End
(
18
)
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
]
true
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
0
payload
:
Payload
:
:
End
(
18
)
}
)
)
;
}
#
[
test
]
fn
nested_section_too_big
(
)
{
let
mut
p
=
parser_after_component_header
(
)
;
let
mut
sub
=
match
p
.
parse
(
&
[
1
10
]
false
)
{
Ok
(
Chunk
:
:
Parsed
{
consumed
:
2
payload
:
Payload
:
:
ModuleSection
{
parser
.
.
}
}
)
=
>
parser
other
=
>
panic
!
(
"
bad
parse
{
:
?
}
"
other
)
}
;
assert_matches
!
(
sub
.
parse
(
b
"
\
0asm
\
x01
\
0
\
0
\
0
"
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
8
payload
:
Payload
:
:
Version
{
num
:
1
.
.
}
}
)
)
;
assert_eq
!
(
sub
.
parse
(
&
[
0
1
0
]
false
)
.
unwrap_err
(
)
.
message
(
)
"
section
too
large
"
)
;
}
}
