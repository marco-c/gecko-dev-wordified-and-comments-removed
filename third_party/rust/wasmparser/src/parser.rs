use
crate
:
:
EventSectionReader
;
use
crate
:
:
{
AliasSectionReader
InstanceSectionReader
}
;
use
crate
:
:
{
BinaryReader
BinaryReaderError
FunctionBody
Range
Result
}
;
use
crate
:
:
{
DataSectionReader
ElementSectionReader
ExportSectionReader
}
;
use
crate
:
:
{
FunctionSectionReader
ImportSectionReader
TypeSectionReader
}
;
use
crate
:
:
{
GlobalSectionReader
MemorySectionReader
TableSectionReader
}
;
use
std
:
:
convert
:
:
TryInto
;
use
std
:
:
fmt
;
use
std
:
:
iter
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
Parser
{
state
:
State
offset
:
u64
max_size
:
u64
}
#
[
derive
(
Debug
Clone
)
]
enum
State
{
ModuleHeader
SectionStart
FunctionBody
{
remaining
:
u32
len
:
u32
}
Module
{
remaining
:
u32
len
:
u32
}
}
#
[
derive
(
Debug
)
]
pub
enum
Chunk
<
'
a
>
{
NeedMoreData
(
u64
)
Parsed
{
consumed
:
usize
payload
:
Payload
<
'
a
>
}
}
pub
enum
Payload
<
'
a
>
{
Version
{
num
:
u32
range
:
Range
}
TypeSection
(
crate
:
:
TypeSectionReader
<
'
a
>
)
ImportSection
(
crate
:
:
ImportSectionReader
<
'
a
>
)
AliasSection
(
crate
:
:
AliasSectionReader
<
'
a
>
)
InstanceSection
(
crate
:
:
InstanceSectionReader
<
'
a
>
)
FunctionSection
(
crate
:
:
FunctionSectionReader
<
'
a
>
)
TableSection
(
crate
:
:
TableSectionReader
<
'
a
>
)
MemorySection
(
crate
:
:
MemorySectionReader
<
'
a
>
)
EventSection
(
crate
:
:
EventSectionReader
<
'
a
>
)
GlobalSection
(
crate
:
:
GlobalSectionReader
<
'
a
>
)
ExportSection
(
crate
:
:
ExportSectionReader
<
'
a
>
)
StartSection
{
func
:
u32
range
:
Range
}
ElementSection
(
crate
:
:
ElementSectionReader
<
'
a
>
)
DataCountSection
{
count
:
u32
range
:
Range
}
DataSection
(
crate
:
:
DataSectionReader
<
'
a
>
)
CustomSection
{
name
:
&
'
a
str
data_offset
:
usize
data
:
&
'
a
[
u8
]
range
:
Range
}
CodeSectionStart
{
count
:
u32
range
:
Range
size
:
u32
}
CodeSectionEntry
(
crate
:
:
FunctionBody
<
'
a
>
)
ModuleSectionStart
{
count
:
u32
range
:
Range
size
:
u32
}
ModuleSectionEntry
{
parser
:
Parser
range
:
Range
}
UnknownSection
{
id
:
u8
contents
:
&
'
a
[
u8
]
range
:
Range
}
End
}
impl
Parser
{
pub
fn
new
(
offset
:
u64
)
-
>
Parser
{
Parser
{
state
:
State
:
:
ModuleHeader
offset
max_size
:
u64
:
:
max_value
(
)
}
}
pub
fn
parse
<
'
a
>
(
&
mut
self
data
:
&
'
a
[
u8
]
eof
:
bool
)
-
>
Result
<
Chunk
<
'
a
>
>
{
let
(
data
eof
)
=
if
usize_to_u64
(
data
.
len
(
)
)
>
self
.
max_size
{
(
&
data
[
.
.
(
self
.
max_size
as
usize
)
]
true
)
}
else
{
(
data
eof
)
}
;
let
mut
reader
=
BinaryReader
:
:
new_with_offset
(
data
self
.
offset
as
usize
)
;
match
self
.
parse_reader
(
&
mut
reader
eof
)
{
Ok
(
payload
)
=
>
{
self
.
offset
+
=
usize_to_u64
(
reader
.
position
)
;
self
.
max_size
-
=
usize_to_u64
(
reader
.
position
)
;
Ok
(
Chunk
:
:
Parsed
{
consumed
:
reader
.
position
payload
}
)
}
Err
(
e
)
=
>
{
if
eof
{
return
Err
(
e
)
;
}
match
e
.
inner
.
needed_hint
{
Some
(
hint
)
=
>
Ok
(
Chunk
:
:
NeedMoreData
(
usize_to_u64
(
hint
)
)
)
None
=
>
Err
(
e
)
}
}
}
}
fn
parse_reader
<
'
a
>
(
&
mut
self
reader
:
&
mut
BinaryReader
<
'
a
>
eof
:
bool
)
-
>
Result
<
Payload
<
'
a
>
>
{
use
Payload
:
:
*
;
match
self
.
state
{
State
:
:
ModuleHeader
=
>
{
let
start
=
reader
.
original_position
(
)
;
let
num
=
reader
.
read_file_header
(
)
?
;
self
.
state
=
State
:
:
SectionStart
;
Ok
(
Version
{
num
range
:
Range
{
start
end
:
reader
.
original_position
(
)
}
}
)
}
State
:
:
SectionStart
=
>
{
if
eof
&
&
reader
.
bytes_remaining
(
)
=
=
0
{
return
Ok
(
Payload
:
:
End
)
;
}
let
id
=
reader
.
read_var_u7
(
)
?
as
u8
;
let
len_pos
=
reader
.
position
;
let
mut
len
=
reader
.
read_var_u32
(
)
?
;
let
section_overflow
=
self
.
max_size
.
checked_sub
(
usize_to_u64
(
reader
.
position
)
)
.
and_then
(
|
s
|
s
.
checked_sub
(
len
.
into
(
)
)
)
.
is_none
(
)
;
if
section_overflow
{
return
Err
(
BinaryReaderError
:
:
new
(
"
section
too
large
"
len_pos
)
)
;
}
match
id
{
0
=
>
{
let
start
=
reader
.
original_position
(
)
;
let
range
=
Range
{
start
end
:
reader
.
original_position
(
)
+
len
as
usize
}
;
let
mut
content
=
subreader
(
reader
len
)
?
;
let
name
=
content
.
read_string
(
)
.
map_err
(
clear_hint
)
?
;
Ok
(
Payload
:
:
CustomSection
{
name
data_offset
:
content
.
original_position
(
)
data
:
content
.
remaining_buffer
(
)
range
}
)
}
1
=
>
section
(
reader
len
TypeSectionReader
:
:
new
TypeSection
)
2
=
>
section
(
reader
len
ImportSectionReader
:
:
new
ImportSection
)
3
=
>
section
(
reader
len
FunctionSectionReader
:
:
new
FunctionSection
)
4
=
>
section
(
reader
len
TableSectionReader
:
:
new
TableSection
)
5
=
>
section
(
reader
len
MemorySectionReader
:
:
new
MemorySection
)
6
=
>
section
(
reader
len
GlobalSectionReader
:
:
new
GlobalSection
)
7
=
>
section
(
reader
len
ExportSectionReader
:
:
new
ExportSection
)
8
=
>
{
let
(
func
range
)
=
single_u32
(
reader
len
"
start
"
)
?
;
Ok
(
StartSection
{
func
range
}
)
}
9
=
>
section
(
reader
len
ElementSectionReader
:
:
new
ElementSection
)
10
=
>
{
let
start
=
reader
.
original_position
(
)
;
let
count
=
delimited
(
reader
&
mut
len
|
r
|
r
.
read_var_u32
(
)
)
?
;
let
range
=
Range
{
start
end
:
reader
.
original_position
(
)
+
len
as
usize
}
;
self
.
state
=
State
:
:
FunctionBody
{
remaining
:
count
len
}
;
Ok
(
CodeSectionStart
{
count
range
size
:
len
}
)
}
11
=
>
section
(
reader
len
DataSectionReader
:
:
new
DataSection
)
12
=
>
{
let
(
count
range
)
=
single_u32
(
reader
len
"
data
count
"
)
?
;
Ok
(
DataCountSection
{
count
range
}
)
}
13
=
>
section
(
reader
len
EventSectionReader
:
:
new
EventSection
)
14
=
>
{
let
start
=
reader
.
original_position
(
)
;
let
count
=
delimited
(
reader
&
mut
len
|
r
|
r
.
read_var_u32
(
)
)
?
;
let
range
=
Range
{
start
end
:
reader
.
original_position
(
)
+
len
as
usize
}
;
self
.
state
=
State
:
:
Module
{
remaining
:
count
len
}
;
Ok
(
ModuleSectionStart
{
count
range
size
:
len
}
)
}
15
=
>
section
(
reader
len
InstanceSectionReader
:
:
new
InstanceSection
)
16
=
>
section
(
reader
len
AliasSectionReader
:
:
new
AliasSection
)
id
=
>
{
let
offset
=
reader
.
original_position
(
)
;
let
contents
=
reader
.
read_bytes
(
len
as
usize
)
?
;
let
range
=
Range
{
start
:
offset
end
:
offset
+
len
as
usize
}
;
Ok
(
UnknownSection
{
id
contents
range
}
)
}
}
}
State
:
:
FunctionBody
{
remaining
:
0
len
:
0
}
|
State
:
:
Module
{
remaining
:
0
len
:
0
}
=
>
{
self
.
state
=
State
:
:
SectionStart
;
self
.
parse_reader
(
reader
eof
)
}
State
:
:
FunctionBody
{
remaining
:
0
len
}
|
State
:
:
Module
{
remaining
:
0
len
}
=
>
{
debug_assert
!
(
len
>
0
)
;
let
offset
=
reader
.
original_position
(
)
;
Err
(
BinaryReaderError
:
:
new
(
"
trailing
bytes
at
end
of
section
"
offset
)
)
}
State
:
:
FunctionBody
{
remaining
mut
len
}
=
>
{
let
body
=
delimited
(
reader
&
mut
len
|
r
|
{
let
size
=
r
.
read_var_u32
(
)
?
;
let
offset
=
r
.
original_position
(
)
;
Ok
(
FunctionBody
:
:
new
(
offset
r
.
read_bytes
(
size
as
usize
)
?
)
)
}
)
?
;
self
.
state
=
State
:
:
FunctionBody
{
remaining
:
remaining
-
1
len
}
;
Ok
(
CodeSectionEntry
(
body
)
)
}
State
:
:
Module
{
remaining
mut
len
}
=
>
{
let
size
=
delimited
(
reader
&
mut
len
|
r
|
r
.
read_var_u32
(
)
)
?
;
match
len
.
checked_sub
(
size
)
{
Some
(
i
)
=
>
len
=
i
None
=
>
{
return
Err
(
BinaryReaderError
:
:
new
(
"
Unexpected
EOF
"
reader
.
original_position
(
)
)
)
;
}
}
self
.
state
=
State
:
:
Module
{
remaining
:
remaining
-
1
len
}
;
let
range
=
Range
{
start
:
reader
.
original_position
(
)
end
:
reader
.
original_position
(
)
+
size
as
usize
}
;
self
.
max_size
-
=
u64
:
:
from
(
size
)
;
self
.
offset
+
=
u64
:
:
from
(
size
)
;
let
mut
parser
=
Parser
:
:
new
(
usize_to_u64
(
reader
.
original_position
(
)
)
)
;
parser
.
max_size
=
size
.
into
(
)
;
Ok
(
ModuleSectionEntry
{
parser
range
}
)
}
}
}
pub
fn
parse_all
<
'
a
>
(
self
mut
data
:
&
'
a
[
u8
]
)
-
>
impl
Iterator
<
Item
=
Result
<
Payload
<
'
a
>
>
>
+
'
a
{
let
mut
stack
=
Vec
:
:
new
(
)
;
let
mut
cur
=
self
;
let
mut
done
=
false
;
iter
:
:
from_fn
(
move
|
|
{
if
done
{
return
None
;
}
let
payload
=
match
cur
.
parse
(
data
true
)
{
Err
(
e
)
=
>
return
Some
(
Err
(
e
)
)
Ok
(
Chunk
:
:
NeedMoreData
(
_
)
)
=
>
unreachable
!
(
)
Ok
(
Chunk
:
:
Parsed
{
payload
consumed
}
)
=
>
{
data
=
&
data
[
consumed
.
.
]
;
payload
}
}
;
match
&
payload
{
Payload
:
:
End
=
>
match
stack
.
pop
(
)
{
Some
(
p
)
=
>
cur
=
p
None
=
>
done
=
true
}
Payload
:
:
ModuleSectionEntry
{
parser
range
:
_
}
=
>
{
stack
.
push
(
cur
.
clone
(
)
)
;
cur
=
parser
.
clone
(
)
;
}
_
=
>
{
}
}
Some
(
Ok
(
payload
)
)
}
)
}
pub
fn
skip_section
(
&
mut
self
)
{
let
skip
=
match
self
.
state
{
State
:
:
FunctionBody
{
remaining
:
_
len
}
|
State
:
:
Module
{
remaining
:
_
len
}
=
>
len
_
=
>
panic
!
(
"
wrong
state
to
call
skip_section
"
)
}
;
self
.
offset
+
=
u64
:
:
from
(
skip
)
;
self
.
max_size
-
=
u64
:
:
from
(
skip
)
;
self
.
state
=
State
:
:
SectionStart
;
}
}
fn
usize_to_u64
(
a
:
usize
)
-
>
u64
{
a
.
try_into
(
)
.
unwrap
(
)
}
fn
section
<
'
a
T
>
(
reader
:
&
mut
BinaryReader
<
'
a
>
len
:
u32
ctor
:
fn
(
&
'
a
[
u8
]
usize
)
-
>
Result
<
T
>
variant
:
fn
(
T
)
-
>
Payload
<
'
a
>
)
-
>
Result
<
Payload
<
'
a
>
>
{
let
offset
=
reader
.
original_position
(
)
;
let
payload
=
reader
.
read_bytes
(
len
as
usize
)
?
;
let
reader
=
ctor
(
payload
offset
)
.
map_err
(
clear_hint
)
?
;
Ok
(
variant
(
reader
)
)
}
fn
subreader
<
'
a
>
(
reader
:
&
mut
BinaryReader
<
'
a
>
len
:
u32
)
-
>
Result
<
BinaryReader
<
'
a
>
>
{
let
offset
=
reader
.
original_position
(
)
;
let
payload
=
reader
.
read_bytes
(
len
as
usize
)
?
;
Ok
(
BinaryReader
:
:
new_with_offset
(
payload
offset
)
)
}
fn
single_u32
<
'
a
>
(
reader
:
&
mut
BinaryReader
<
'
a
>
len
:
u32
desc
:
&
str
)
-
>
Result
<
(
u32
Range
)
>
{
let
range
=
Range
{
start
:
reader
.
original_position
(
)
end
:
reader
.
original_position
(
)
+
len
as
usize
}
;
let
mut
content
=
subreader
(
reader
len
)
?
;
let
index
=
content
.
read_var_u32
(
)
.
map_err
(
clear_hint
)
?
;
if
!
content
.
eof
(
)
{
return
Err
(
BinaryReaderError
:
:
new
(
format
!
(
"
Unexpected
content
in
the
{
}
section
"
desc
)
content
.
original_position
(
)
)
)
;
}
Ok
(
(
index
range
)
)
}
fn
delimited
<
'
a
T
>
(
reader
:
&
mut
BinaryReader
<
'
a
>
len
:
&
mut
u32
f
:
impl
FnOnce
(
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
T
>
)
-
>
Result
<
T
>
{
let
start
=
reader
.
position
;
let
ret
=
f
(
reader
)
?
;
*
len
=
match
(
reader
.
position
-
start
)
.
try_into
(
)
.
ok
(
)
.
and_then
(
|
i
|
len
.
checked_sub
(
i
)
)
{
Some
(
i
)
=
>
i
None
=
>
return
Err
(
BinaryReaderError
:
:
new
(
"
Unexpected
EOF
"
start
)
)
}
;
Ok
(
ret
)
}
impl
Default
for
Parser
{
fn
default
(
)
-
>
Parser
{
Parser
:
:
new
(
0
)
}
}
impl
fmt
:
:
Debug
for
Payload
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
use
Payload
:
:
*
;
match
self
{
CustomSection
{
name
data_offset
data
:
_
range
}
=
>
f
.
debug_struct
(
"
CustomSection
"
)
.
field
(
"
name
"
name
)
.
field
(
"
data_offset
"
data_offset
)
.
field
(
"
range
"
range
)
.
field
(
"
data
"
&
"
.
.
.
"
)
.
finish
(
)
Version
{
num
range
}
=
>
f
.
debug_struct
(
"
Version
"
)
.
field
(
"
num
"
num
)
.
field
(
"
range
"
range
)
.
finish
(
)
TypeSection
(
_
)
=
>
f
.
debug_tuple
(
"
TypeSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ImportSection
(
_
)
=
>
f
.
debug_tuple
(
"
ImportSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
AliasSection
(
_
)
=
>
f
.
debug_tuple
(
"
AliasSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
InstanceSection
(
_
)
=
>
f
.
debug_tuple
(
"
InstanceSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
FunctionSection
(
_
)
=
>
f
.
debug_tuple
(
"
FunctionSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
TableSection
(
_
)
=
>
f
.
debug_tuple
(
"
TableSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
MemorySection
(
_
)
=
>
f
.
debug_tuple
(
"
MemorySection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
EventSection
(
_
)
=
>
f
.
debug_tuple
(
"
EventSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
GlobalSection
(
_
)
=
>
f
.
debug_tuple
(
"
GlobalSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ExportSection
(
_
)
=
>
f
.
debug_tuple
(
"
ExportSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ElementSection
(
_
)
=
>
f
.
debug_tuple
(
"
ElementSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
DataSection
(
_
)
=
>
f
.
debug_tuple
(
"
DataSection
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
StartSection
{
func
range
}
=
>
f
.
debug_struct
(
"
StartSection
"
)
.
field
(
"
func
"
func
)
.
field
(
"
range
"
range
)
.
finish
(
)
DataCountSection
{
count
range
}
=
>
f
.
debug_struct
(
"
DataCountSection
"
)
.
field
(
"
count
"
count
)
.
field
(
"
range
"
range
)
.
finish
(
)
CodeSectionStart
{
count
range
size
}
=
>
f
.
debug_struct
(
"
CodeSectionStart
"
)
.
field
(
"
count
"
count
)
.
field
(
"
range
"
range
)
.
field
(
"
size
"
size
)
.
finish
(
)
CodeSectionEntry
(
_
)
=
>
f
.
debug_tuple
(
"
CodeSectionEntry
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
ModuleSectionStart
{
count
range
size
}
=
>
f
.
debug_struct
(
"
ModuleSectionStart
"
)
.
field
(
"
count
"
count
)
.
field
(
"
range
"
range
)
.
field
(
"
size
"
size
)
.
finish
(
)
ModuleSectionEntry
{
parser
:
_
range
}
=
>
f
.
debug_struct
(
"
ModuleSectionEntry
"
)
.
field
(
"
range
"
range
)
.
finish
(
)
UnknownSection
{
id
range
.
.
}
=
>
f
.
debug_struct
(
"
UnknownSection
"
)
.
field
(
"
id
"
id
)
.
field
(
"
range
"
range
)
.
finish
(
)
End
=
>
f
.
write_str
(
"
End
"
)
}
}
}
fn
clear_hint
(
mut
err
:
BinaryReaderError
)
-
>
BinaryReaderError
{
err
.
inner
.
needed_hint
=
None
;
err
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
macro_rules
!
assert_matches
{
(
a
:
expr
b
:
pat
(
)
?
)
=
>
{
match
a
{
b
=
>
{
}
a
=
>
panic
!
(
"
{
:
?
}
doesn
'
t
match
{
}
"
a
stringify
!
(
b
)
)
}
}
;
}
#
[
test
]
fn
header
(
)
{
assert
!
(
Parser
:
:
default
(
)
.
parse
(
&
[
]
true
)
.
is_err
(
)
)
;
assert_matches
!
(
Parser
:
:
default
(
)
.
parse
(
&
[
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
4
)
)
)
;
assert_matches
!
(
Parser
:
:
default
(
)
.
parse
(
b
"
\
0
"
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
3
)
)
)
;
assert_matches
!
(
Parser
:
:
default
(
)
.
parse
(
b
"
\
0asm
"
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
4
)
)
)
;
assert_matches
!
(
Parser
:
:
default
(
)
.
parse
(
b
"
\
0asm
\
x01
\
0
\
0
\
0
"
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
8
payload
:
Payload
:
:
Version
{
num
:
1
.
.
}
}
)
)
;
}
fn
parser_after_header
(
)
-
>
Parser
{
let
mut
p
=
Parser
:
:
default
(
)
;
assert_matches
!
(
p
.
parse
(
b
"
\
0asm
\
x01
\
0
\
0
\
0
"
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
8
payload
:
Payload
:
:
Version
{
num
:
1
.
.
}
}
)
)
;
return
p
;
}
#
[
test
]
fn
start_section
(
)
{
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
8
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
8
1
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
8
2
]
true
)
.
is_err
(
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
8
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
8
1
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
8
2
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
2
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
8
1
1
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
StartSection
{
func
:
1
.
.
}
}
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
8
2
1
1
]
false
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
8
0
]
false
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
end_works
(
)
{
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
]
true
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
0
payload
:
Payload
:
:
End
}
)
)
;
}
#
[
test
]
fn
type_section
(
)
{
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
1
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
1
0
]
false
)
.
is_err
(
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
1
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
1
1
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
1
1
1
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
TypeSection
(
_
)
}
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
1
1
1
2
3
4
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
TypeSection
(
_
)
}
)
)
;
}
#
[
test
]
fn
custom_section
(
)
{
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
0
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
0
0
]
false
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
0
1
1
]
false
)
.
is_err
(
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
0
2
1
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
0
1
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CustomSection
{
name
:
"
"
data_offset
:
11
data
:
b
"
"
range
:
Range
{
start
:
10
end
:
11
}
}
}
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
0
2
1
b
'
a
'
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
4
payload
:
Payload
:
:
CustomSection
{
name
:
"
a
"
data_offset
:
12
data
:
b
"
"
range
:
Range
{
start
:
10
end
:
12
}
}
}
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
0
2
0
b
'
a
'
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
4
payload
:
Payload
:
:
CustomSection
{
name
:
"
"
data_offset
:
11
data
:
b
"
a
"
range
:
Range
{
start
:
10
end
:
12
}
}
}
)
)
;
}
#
[
test
]
fn
function_section
(
)
{
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
10
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
10
0
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
10
1
]
true
)
.
is_err
(
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
10
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
parser_after_header
(
)
.
parse
(
&
[
10
1
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
10
1
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CodeSectionStart
{
count
:
0
.
.
}
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
]
true
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
0
payload
:
Payload
:
:
End
}
)
)
;
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
10
2
1
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CodeSectionStart
{
count
:
1
.
.
}
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
1
payload
:
Payload
:
:
CodeSectionEntry
(
_
)
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
]
true
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
0
payload
:
Payload
:
:
End
}
)
)
;
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
10
1
1
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CodeSectionStart
{
count
:
1
.
.
}
}
)
)
;
assert_eq
!
(
p
.
parse
(
&
[
0
]
false
)
.
unwrap_err
(
)
.
message
(
)
"
Unexpected
EOF
"
)
;
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
10
2
2
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CodeSectionStart
{
count
:
2
.
.
}
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
1
payload
:
Payload
:
:
CodeSectionEntry
(
_
)
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_eq
!
(
p
.
parse
(
&
[
0
]
false
)
.
unwrap_err
(
)
.
message
(
)
"
Unexpected
EOF
"
)
;
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
10
3
1
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
CodeSectionStart
{
count
:
1
.
.
}
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
0
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
1
payload
:
Payload
:
:
CodeSectionEntry
(
_
)
}
)
)
;
assert_eq
!
(
p
.
parse
(
&
[
0
]
false
)
.
unwrap_err
(
)
.
message
(
)
"
trailing
bytes
at
end
of
section
"
)
;
}
#
[
test
]
fn
module_code_errors
(
)
{
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
14
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
14
0
]
true
)
.
is_err
(
)
)
;
assert
!
(
parser_after_header
(
)
.
parse
(
&
[
14
1
]
true
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
module_code_one
(
)
{
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
14
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
14
9
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
14
10
1
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
ModuleSectionStart
{
count
:
1
.
.
}
}
)
)
;
let
mut
sub
=
match
p
.
parse
(
&
[
8
]
false
)
{
Ok
(
Chunk
:
:
Parsed
{
consumed
:
1
payload
:
Payload
:
:
ModuleSectionEntry
{
parser
.
.
}
}
)
=
>
parser
other
=
>
panic
!
(
"
bad
parse
{
:
?
}
"
other
)
}
;
assert_matches
!
(
sub
.
parse
(
&
[
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
4
)
)
)
;
assert_matches
!
(
sub
.
parse
(
b
"
\
0asm
"
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
4
)
)
)
;
assert_matches
!
(
sub
.
parse
(
b
"
\
0asm
\
x01
\
0
\
0
\
0
"
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
8
payload
:
Payload
:
:
Version
{
num
:
1
.
.
}
}
)
)
;
assert_matches
!
(
sub
.
parse
(
&
[
10
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
0
payload
:
Payload
:
:
End
}
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
]
false
)
Ok
(
Chunk
:
:
NeedMoreData
(
1
)
)
)
;
assert_matches
!
(
p
.
parse
(
&
[
]
true
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
0
payload
:
Payload
:
:
End
}
)
)
;
}
#
[
test
]
fn
nested_section_too_big
(
)
{
let
mut
p
=
parser_after_header
(
)
;
assert_matches
!
(
p
.
parse
(
&
[
14
12
1
]
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
3
payload
:
Payload
:
:
ModuleSectionStart
{
count
:
1
.
.
}
}
)
)
;
let
mut
sub
=
match
p
.
parse
(
&
[
10
]
false
)
{
Ok
(
Chunk
:
:
Parsed
{
consumed
:
1
payload
:
Payload
:
:
ModuleSectionEntry
{
parser
.
.
}
}
)
=
>
parser
other
=
>
panic
!
(
"
bad
parse
{
:
?
}
"
other
)
}
;
assert_matches
!
(
sub
.
parse
(
b
"
\
0asm
\
x01
\
0
\
0
\
0
"
false
)
Ok
(
Chunk
:
:
Parsed
{
consumed
:
8
payload
:
Payload
:
:
Version
{
num
:
1
.
.
}
}
)
)
;
assert_eq
!
(
sub
.
parse
(
&
[
1
1
0
]
false
)
.
unwrap_err
(
)
.
message
(
)
"
section
too
large
"
)
;
}
}
