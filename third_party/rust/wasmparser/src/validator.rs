use
crate
:
:
prelude
:
:
*
;
use
crate
:
:
{
limits
:
:
*
AbstractHeapType
BinaryReaderError
Encoding
FromReader
FunctionBody
HeapType
Parser
Payload
RefType
Result
SectionLimited
ValType
WasmFeatures
WASM_MODULE_VERSION
}
;
use
:
:
core
:
:
mem
;
use
:
:
core
:
:
ops
:
:
Range
;
use
:
:
core
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
alloc
:
:
sync
:
:
Arc
;
pub
fn
validate
(
bytes
:
&
[
u8
]
)
-
>
Result
<
Types
>
{
Validator
:
:
new
(
)
.
validate_all
(
bytes
)
}
#
[
test
]
fn
test_validate
(
)
{
assert
!
(
validate
(
&
[
0x0
0x61
0x73
0x6d
0x1
0x0
0x0
0x0
]
)
.
is_ok
(
)
)
;
assert
!
(
validate
(
&
[
0x0
0x61
0x73
0x6d
0x2
0x0
0x0
0x0
]
)
.
is_err
(
)
)
;
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
mod
component
;
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
mod
component_types
;
mod
core
;
mod
func
;
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
mod
names
;
mod
operators
;
pub
mod
types
;
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
use
self
:
:
component
:
:
*
;
pub
use
self
:
:
core
:
:
ValidatorResources
;
use
self
:
:
core
:
:
*
;
use
self
:
:
types
:
:
{
TypeAlloc
Types
TypesRef
}
;
pub
use
func
:
:
{
FuncToValidate
FuncValidator
FuncValidatorAllocations
}
;
pub
use
operators
:
:
Frame
;
fn
check_max
(
cur_len
:
usize
amt_added
:
u32
max
:
usize
desc
:
&
str
offset
:
usize
)
-
>
Result
<
(
)
>
{
if
max
.
checked_sub
(
cur_len
)
.
and_then
(
|
amt
|
amt
.
checked_sub
(
amt_added
as
usize
)
)
.
is_none
(
)
{
if
max
=
=
1
{
bail
!
(
offset
"
multiple
{
desc
}
"
)
;
}
bail
!
(
offset
"
{
desc
}
count
exceeds
limit
of
{
max
}
"
)
;
}
Ok
(
(
)
)
}
fn
combine_type_sizes
(
a
:
u32
b
:
u32
offset
:
usize
)
-
>
Result
<
u32
>
{
match
a
.
checked_add
(
b
)
{
Some
(
sum
)
if
sum
<
MAX_WASM_TYPE_SIZE
=
>
Ok
(
sum
)
_
=
>
Err
(
format_err
!
(
offset
"
effective
type
size
exceeds
the
limit
of
{
MAX_WASM_TYPE_SIZE
}
"
)
)
}
}
#
[
derive
(
Clone
Copy
PartialEq
Eq
Debug
Hash
PartialOrd
Ord
)
]
pub
struct
ValidatorId
(
usize
)
;
impl
Default
for
ValidatorId
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
static
ID_COUNTER
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
ValidatorId
(
ID_COUNTER
.
fetch_add
(
1
Ordering
:
:
AcqRel
)
)
}
}
#
[
derive
(
Default
)
]
pub
struct
Validator
{
id
:
ValidatorId
state
:
State
types
:
TypeAlloc
module
:
Option
<
ModuleState
>
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
components
:
Vec
<
ComponentState
>
features
:
WasmFeatures
}
#
[
derive
(
Debug
Clone
Copy
Eq
PartialEq
)
]
enum
State
{
Unparsed
(
Option
<
Encoding
>
)
Module
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
Component
End
}
impl
State
{
fn
ensure_parsable
(
&
self
offset
:
usize
)
-
>
Result
<
(
)
>
{
match
self
{
Self
:
:
Module
=
>
Ok
(
(
)
)
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
Self
:
:
Component
=
>
Ok
(
(
)
)
Self
:
:
Unparsed
(
_
)
=
>
Err
(
BinaryReaderError
:
:
new
(
"
unexpected
section
before
header
was
parsed
"
offset
)
)
Self
:
:
End
=
>
Err
(
BinaryReaderError
:
:
new
(
"
unexpected
section
after
parsing
has
completed
"
offset
)
)
}
}
fn
ensure_module
(
&
self
section
:
&
str
offset
:
usize
)
-
>
Result
<
(
)
>
{
self
.
ensure_parsable
(
offset
)
?
;
let
_
=
section
;
match
self
{
Self
:
:
Module
=
>
Ok
(
(
)
)
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
Self
:
:
Component
=
>
Err
(
format_err
!
(
offset
"
unexpected
module
{
section
}
section
while
parsing
a
component
"
)
)
_
=
>
unreachable
!
(
)
}
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
fn
ensure_component
(
&
self
section
:
&
str
offset
:
usize
)
-
>
Result
<
(
)
>
{
self
.
ensure_parsable
(
offset
)
?
;
match
self
{
Self
:
:
Component
=
>
Ok
(
(
)
)
Self
:
:
Module
=
>
Err
(
format_err
!
(
offset
"
unexpected
component
{
section
}
section
while
parsing
a
module
"
)
)
_
=
>
unreachable
!
(
)
}
}
}
impl
Default
for
State
{
fn
default
(
)
-
>
Self
{
Self
:
:
Unparsed
(
None
)
}
}
impl
WasmFeatures
{
pub
(
crate
)
fn
check_value_type
(
&
self
ty
:
ValType
)
-
>
Result
<
(
)
&
'
static
str
>
{
match
ty
{
ValType
:
:
I32
|
ValType
:
:
I64
=
>
Ok
(
(
)
)
ValType
:
:
F32
|
ValType
:
:
F64
=
>
{
if
self
.
floats
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
"
floating
-
point
support
is
disabled
"
)
}
}
ValType
:
:
Ref
(
r
)
=
>
self
.
check_ref_type
(
r
)
ValType
:
:
V128
=
>
{
if
self
.
simd
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
"
SIMD
support
is
not
enabled
"
)
}
}
}
}
pub
(
crate
)
fn
check_ref_type
(
&
self
r
:
RefType
)
-
>
Result
<
(
)
&
'
static
str
>
{
if
!
self
.
reference_types
(
)
{
return
Err
(
"
reference
types
support
is
not
enabled
"
)
;
}
match
r
.
heap_type
(
)
{
HeapType
:
:
Concrete
(
_
)
=
>
{
if
self
.
function_references
(
)
|
|
self
.
gc
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
"
function
references
required
for
index
reference
types
"
)
}
}
HeapType
:
:
Abstract
{
shared
ty
}
=
>
{
use
AbstractHeapType
:
:
*
;
if
shared
&
&
!
self
.
shared_everything_threads
(
)
{
return
Err
(
"
shared
reference
types
require
the
shared
-
everything
-
threads
proposal
"
)
;
}
if
!
self
.
gc_types
(
)
&
&
ty
!
=
Func
&
&
ty
!
=
Exn
{
return
Err
(
"
gc
types
are
disallowed
but
found
type
which
requires
gc
"
)
;
}
match
(
ty
r
.
is_nullable
(
)
)
{
(
Func
true
)
|
(
Extern
true
)
=
>
Ok
(
(
)
)
(
Func
|
Extern
false
)
=
>
{
if
self
.
function_references
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
"
function
references
required
for
non
-
nullable
types
"
)
}
}
(
Any
|
None
|
Eq
|
Struct
|
Array
|
I31
|
NoExtern
|
NoFunc
_
)
=
>
{
if
self
.
gc
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
"
heap
types
not
supported
without
the
gc
feature
"
)
}
}
(
Exn
|
NoExn
_
)
=
>
{
if
self
.
exceptions
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
"
exception
refs
not
supported
without
the
exception
handling
feature
"
)
}
}
(
Cont
|
NoCont
_
)
=
>
{
if
self
.
stack_switching
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
"
continuation
refs
not
supported
without
the
stack
switching
feature
"
)
}
}
}
}
}
}
}
#
[
allow
(
clippy
:
:
large_enum_variant
)
]
pub
enum
ValidPayload
<
'
a
>
{
Ok
Parser
(
Parser
)
Func
(
FuncToValidate
<
ValidatorResources
>
FunctionBody
<
'
a
>
)
End
(
Types
)
}
impl
Validator
{
pub
fn
new
(
)
-
>
Validator
{
Validator
:
:
default
(
)
}
pub
fn
new_with_features
(
features
:
WasmFeatures
)
-
>
Validator
{
let
mut
ret
=
Validator
:
:
new
(
)
;
ret
.
features
=
features
;
ret
}
pub
fn
features
(
&
self
)
-
>
&
WasmFeatures
{
&
self
.
features
}
pub
fn
reset
(
&
mut
self
)
{
let
Validator
{
id
:
_
types
:
_
features
:
_
state
module
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
components
}
=
self
;
assert
!
(
matches
!
(
state
State
:
:
End
)
"
cannot
reset
a
validator
that
did
not
successfully
complete
validation
"
)
;
assert
!
(
module
.
is_none
(
)
)
;
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
assert
!
(
components
.
is_empty
(
)
)
;
*
state
=
State
:
:
default
(
)
;
}
pub
fn
id
(
&
self
)
-
>
ValidatorId
{
self
.
id
}
pub
fn
validate_all
(
&
mut
self
bytes
:
&
[
u8
]
)
-
>
Result
<
Types
>
{
let
mut
functions_to_validate
=
Vec
:
:
new
(
)
;
let
mut
last_types
=
None
;
let
mut
parser
=
Parser
:
:
new
(
0
)
;
let
_
=
&
mut
parser
;
#
[
cfg
(
feature
=
"
features
"
)
]
parser
.
set_features
(
self
.
features
)
;
for
payload
in
parser
.
parse_all
(
bytes
)
{
match
self
.
payload
(
&
payload
?
)
?
{
ValidPayload
:
:
Func
(
a
b
)
=
>
{
functions_to_validate
.
push
(
(
a
b
)
)
;
}
ValidPayload
:
:
End
(
types
)
=
>
{
last_types
=
Some
(
types
)
;
}
_
=
>
{
}
}
}
let
mut
allocs
=
FuncValidatorAllocations
:
:
default
(
)
;
for
(
func
body
)
in
functions_to_validate
{
let
mut
validator
=
func
.
into_validator
(
allocs
)
;
validator
.
validate
(
&
body
)
?
;
allocs
=
validator
.
into_allocations
(
)
;
}
Ok
(
last_types
.
unwrap
(
)
)
}
pub
fn
types
(
&
self
mut
level
:
usize
)
-
>
Option
<
TypesRef
>
{
if
let
Some
(
module
)
=
&
self
.
module
{
if
level
=
=
0
{
return
Some
(
TypesRef
:
:
from_module
(
self
.
id
&
self
.
types
&
module
.
module
)
)
;
}
else
{
level
-
=
1
;
let
_
=
level
;
}
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
return
self
.
components
.
iter
(
)
.
nth_back
(
level
)
.
map
(
|
component
|
TypesRef
:
:
from_component
(
self
.
id
&
self
.
types
component
)
)
;
#
[
cfg
(
not
(
feature
=
"
component
-
model
"
)
)
]
return
None
;
}
pub
fn
payload
<
'
a
>
(
&
mut
self
payload
:
&
Payload
<
'
a
>
)
-
>
Result
<
ValidPayload
<
'
a
>
>
{
use
crate
:
:
Payload
:
:
*
;
match
payload
{
Version
{
num
encoding
range
}
=
>
self
.
version
(
*
num
*
encoding
range
)
?
TypeSection
(
s
)
=
>
self
.
type_section
(
s
)
?
ImportSection
(
s
)
=
>
self
.
import_section
(
s
)
?
FunctionSection
(
s
)
=
>
self
.
function_section
(
s
)
?
TableSection
(
s
)
=
>
self
.
table_section
(
s
)
?
MemorySection
(
s
)
=
>
self
.
memory_section
(
s
)
?
TagSection
(
s
)
=
>
self
.
tag_section
(
s
)
?
GlobalSection
(
s
)
=
>
self
.
global_section
(
s
)
?
ExportSection
(
s
)
=
>
self
.
export_section
(
s
)
?
StartSection
{
func
range
}
=
>
self
.
start_section
(
*
func
range
)
?
ElementSection
(
s
)
=
>
self
.
element_section
(
s
)
?
DataCountSection
{
count
range
}
=
>
self
.
data_count_section
(
*
count
range
)
?
CodeSectionStart
{
count
range
size
:
_
}
=
>
self
.
code_section_start
(
*
count
range
)
?
CodeSectionEntry
(
body
)
=
>
{
let
func_validator
=
self
.
code_section_entry
(
body
)
?
;
return
Ok
(
ValidPayload
:
:
Func
(
func_validator
body
.
clone
(
)
)
)
;
}
DataSection
(
s
)
=
>
self
.
data_section
(
s
)
?
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
ModuleSection
{
parser
unchecked_range
:
range
.
.
}
=
>
{
self
.
module_section
(
range
)
?
;
return
Ok
(
ValidPayload
:
:
Parser
(
parser
.
clone
(
)
)
)
;
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
InstanceSection
(
s
)
=
>
self
.
instance_section
(
s
)
?
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
CoreTypeSection
(
s
)
=
>
self
.
core_type_section
(
s
)
?
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
ComponentSection
{
parser
unchecked_range
:
range
.
.
}
=
>
{
self
.
component_section
(
range
)
?
;
return
Ok
(
ValidPayload
:
:
Parser
(
parser
.
clone
(
)
)
)
;
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
ComponentInstanceSection
(
s
)
=
>
self
.
component_instance_section
(
s
)
?
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
ComponentAliasSection
(
s
)
=
>
self
.
component_alias_section
(
s
)
?
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
ComponentTypeSection
(
s
)
=
>
self
.
component_type_section
(
s
)
?
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
ComponentCanonicalSection
(
s
)
=
>
self
.
component_canonical_section
(
s
)
?
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
ComponentStartSection
{
start
range
}
=
>
self
.
component_start_section
(
start
range
)
?
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
ComponentImportSection
(
s
)
=
>
self
.
component_import_section
(
s
)
?
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
ComponentExportSection
(
s
)
=
>
self
.
component_export_section
(
s
)
?
End
(
offset
)
=
>
return
Ok
(
ValidPayload
:
:
End
(
self
.
end
(
*
offset
)
?
)
)
CustomSection
{
.
.
}
=
>
{
}
UnknownSection
{
id
range
.
.
}
=
>
self
.
unknown_section
(
*
id
range
)
?
}
Ok
(
ValidPayload
:
:
Ok
)
}
pub
fn
version
(
&
mut
self
num
:
u16
encoding
:
Encoding
range
:
&
Range
<
usize
>
)
-
>
Result
<
(
)
>
{
match
&
self
.
state
{
State
:
:
Unparsed
(
expected
)
=
>
{
if
let
Some
(
expected
)
=
expected
{
if
*
expected
!
=
encoding
{
bail
!
(
range
.
start
"
expected
a
version
header
for
a
{
}
"
match
expected
{
Encoding
:
:
Module
=
>
"
module
"
Encoding
:
:
Component
=
>
"
component
"
}
)
;
}
}
}
_
=
>
{
return
Err
(
BinaryReaderError
:
:
new
(
"
wasm
version
header
out
of
order
"
range
.
start
)
)
}
}
self
.
state
=
match
encoding
{
Encoding
:
:
Module
=
>
{
if
num
=
=
WASM_MODULE_VERSION
{
assert
!
(
self
.
module
.
is_none
(
)
)
;
self
.
module
=
Some
(
ModuleState
:
:
default
(
)
)
;
State
:
:
Module
}
else
{
bail
!
(
range
.
start
"
unknown
binary
version
:
{
num
:
#
x
}
"
)
;
}
}
Encoding
:
:
Component
=
>
{
if
!
self
.
features
.
component_model
(
)
{
bail
!
(
range
.
start
"
unknown
binary
version
and
encoding
combination
:
{
num
:
#
x
}
and
0x1
\
note
:
encoded
as
a
component
but
the
WebAssembly
component
model
feature
\
is
not
enabled
-
enable
the
feature
to
allow
component
validation
"
)
;
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
if
num
=
=
crate
:
:
WASM_COMPONENT_VERSION
{
self
.
components
.
push
(
ComponentState
:
:
new
(
ComponentKind
:
:
Component
)
)
;
State
:
:
Component
}
else
if
num
<
crate
:
:
WASM_COMPONENT_VERSION
{
bail
!
(
range
.
start
"
unsupported
component
version
:
{
num
:
#
x
}
"
)
;
}
else
{
bail
!
(
range
.
start
"
unknown
component
version
:
{
num
:
#
x
}
"
)
;
}
#
[
cfg
(
not
(
feature
=
"
component
-
model
"
)
)
]
bail
!
(
range
.
start
"
component
model
validation
support
disabled
\
at
compile
time
"
)
;
}
}
;
Ok
(
(
)
)
}
pub
fn
type_section
(
&
mut
self
section
:
&
crate
:
:
TypeSectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
process_module_section
(
Order
:
:
Type
section
"
type
"
|
state
_
_types
count
offset
|
{
check_max
(
state
.
module
.
types
.
len
(
)
count
MAX_WASM_TYPES
"
types
"
offset
)
?
;
state
.
module
.
assert_mut
(
)
.
types
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
state
features
types
rec_group
offset
|
{
state
.
module
.
assert_mut
(
)
.
add_types
(
rec_group
features
types
offset
true
)
?
;
Ok
(
(
)
)
}
)
}
pub
fn
import_section
(
&
mut
self
section
:
&
crate
:
:
ImportSectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
process_module_section
(
Order
:
:
Import
section
"
import
"
|
state
_
_
count
offset
|
{
check_max
(
state
.
module
.
imports
.
len
(
)
count
MAX_WASM_IMPORTS
"
imports
"
offset
)
?
;
state
.
module
.
assert_mut
(
)
.
imports
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
state
features
types
import
offset
|
{
state
.
module
.
assert_mut
(
)
.
add_import
(
import
features
types
offset
)
}
)
}
pub
fn
function_section
(
&
mut
self
section
:
&
crate
:
:
FunctionSectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
process_module_section
(
Order
:
:
Function
section
"
function
"
|
state
_
_
count
offset
|
{
check_max
(
state
.
module
.
functions
.
len
(
)
count
MAX_WASM_FUNCTIONS
"
functions
"
offset
)
?
;
state
.
module
.
assert_mut
(
)
.
functions
.
reserve
(
count
as
usize
)
;
debug_assert
!
(
state
.
expected_code_bodies
.
is_none
(
)
)
;
state
.
expected_code_bodies
=
Some
(
count
)
;
Ok
(
(
)
)
}
|
state
_
types
ty
offset
|
state
.
module
.
assert_mut
(
)
.
add_function
(
ty
types
offset
)
)
}
pub
fn
table_section
(
&
mut
self
section
:
&
crate
:
:
TableSectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
let
features
=
self
.
features
;
self
.
process_module_section
(
Order
:
:
Table
section
"
table
"
|
state
_
_
count
offset
|
{
check_max
(
state
.
module
.
tables
.
len
(
)
count
state
.
module
.
max_tables
(
&
features
)
"
tables
"
offset
)
?
;
state
.
module
.
assert_mut
(
)
.
tables
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
state
features
types
table
offset
|
state
.
add_table
(
table
features
types
offset
)
)
}
pub
fn
memory_section
(
&
mut
self
section
:
&
crate
:
:
MemorySectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
process_module_section
(
Order
:
:
Memory
section
"
memory
"
|
state
features
_
count
offset
|
{
check_max
(
state
.
module
.
memories
.
len
(
)
count
state
.
module
.
max_memories
(
features
)
"
memories
"
offset
)
?
;
state
.
module
.
assert_mut
(
)
.
memories
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
state
features
_
ty
offset
|
{
state
.
module
.
assert_mut
(
)
.
add_memory
(
ty
features
offset
)
}
)
}
pub
fn
tag_section
(
&
mut
self
section
:
&
crate
:
:
TagSectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
if
!
self
.
features
.
exceptions
(
)
{
return
Err
(
BinaryReaderError
:
:
new
(
"
exceptions
proposal
not
enabled
"
section
.
range
(
)
.
start
)
)
;
}
self
.
process_module_section
(
Order
:
:
Tag
section
"
tag
"
|
state
_
_
count
offset
|
{
check_max
(
state
.
module
.
tags
.
len
(
)
count
MAX_WASM_TAGS
"
tags
"
offset
)
?
;
state
.
module
.
assert_mut
(
)
.
tags
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
state
features
types
ty
offset
|
{
state
.
module
.
assert_mut
(
)
.
add_tag
(
ty
features
types
offset
)
}
)
}
pub
fn
global_section
(
&
mut
self
section
:
&
crate
:
:
GlobalSectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
process_module_section
(
Order
:
:
Global
section
"
global
"
|
state
_
_
count
offset
|
{
check_max
(
state
.
module
.
globals
.
len
(
)
count
MAX_WASM_GLOBALS
"
globals
"
offset
)
?
;
state
.
module
.
assert_mut
(
)
.
globals
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
state
features
types
global
offset
|
{
state
.
add_global
(
global
features
types
offset
)
}
)
}
pub
fn
export_section
(
&
mut
self
section
:
&
crate
:
:
ExportSectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
process_module_section
(
Order
:
:
Export
section
"
export
"
|
state
_
_
count
offset
|
{
check_max
(
state
.
module
.
exports
.
len
(
)
count
MAX_WASM_EXPORTS
"
exports
"
offset
)
?
;
state
.
module
.
assert_mut
(
)
.
exports
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
state
features
types
e
offset
|
{
let
state
=
state
.
module
.
assert_mut
(
)
;
let
ty
=
state
.
export_to_entity_type
(
&
e
offset
)
?
;
state
.
add_export
(
e
.
name
ty
features
offset
false
types
)
}
)
}
pub
fn
start_section
(
&
mut
self
func
:
u32
range
:
&
Range
<
usize
>
)
-
>
Result
<
(
)
>
{
let
offset
=
range
.
start
;
self
.
state
.
ensure_module
(
"
start
"
offset
)
?
;
let
state
=
self
.
module
.
as_mut
(
)
.
unwrap
(
)
;
state
.
update_order
(
Order
:
:
Start
offset
)
?
;
let
ty
=
state
.
module
.
get_func_type
(
func
&
self
.
types
offset
)
?
;
if
!
ty
.
params
(
)
.
is_empty
(
)
|
|
!
ty
.
results
(
)
.
is_empty
(
)
{
return
Err
(
BinaryReaderError
:
:
new
(
"
invalid
start
function
type
"
offset
)
)
;
}
Ok
(
(
)
)
}
pub
fn
element_section
(
&
mut
self
section
:
&
crate
:
:
ElementSectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
process_module_section
(
Order
:
:
Element
section
"
element
"
|
state
_
_
count
offset
|
{
check_max
(
state
.
module
.
element_types
.
len
(
)
count
MAX_WASM_ELEMENT_SEGMENTS
"
element
segments
"
offset
)
?
;
state
.
module
.
assert_mut
(
)
.
element_types
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
state
features
types
e
offset
|
{
state
.
add_element_segment
(
e
features
types
offset
)
}
)
}
pub
fn
data_count_section
(
&
mut
self
count
:
u32
range
:
&
Range
<
usize
>
)
-
>
Result
<
(
)
>
{
let
offset
=
range
.
start
;
self
.
state
.
ensure_module
(
"
data
count
"
offset
)
?
;
let
state
=
self
.
module
.
as_mut
(
)
.
unwrap
(
)
;
state
.
update_order
(
Order
:
:
DataCount
offset
)
?
;
if
count
>
MAX_WASM_DATA_SEGMENTS
as
u32
{
return
Err
(
BinaryReaderError
:
:
new
(
"
data
count
section
specifies
too
many
data
segments
"
offset
)
)
;
}
state
.
module
.
assert_mut
(
)
.
data_count
=
Some
(
count
)
;
Ok
(
(
)
)
}
pub
fn
code_section_start
(
&
mut
self
count
:
u32
range
:
&
Range
<
usize
>
)
-
>
Result
<
(
)
>
{
let
offset
=
range
.
start
;
self
.
state
.
ensure_module
(
"
code
"
offset
)
?
;
let
state
=
self
.
module
.
as_mut
(
)
.
unwrap
(
)
;
state
.
update_order
(
Order
:
:
Code
offset
)
?
;
match
state
.
expected_code_bodies
.
take
(
)
{
Some
(
n
)
if
n
=
=
count
=
>
{
}
Some
(
_
)
=
>
{
return
Err
(
BinaryReaderError
:
:
new
(
"
function
and
code
section
have
inconsistent
lengths
"
offset
)
)
;
}
None
if
count
=
=
0
=
>
{
}
None
=
>
{
return
Err
(
BinaryReaderError
:
:
new
(
"
code
section
without
function
section
"
offset
)
)
}
}
state
.
module
.
assert_mut
(
)
.
snapshot
=
Some
(
Arc
:
:
new
(
self
.
types
.
commit
(
)
)
)
;
Ok
(
(
)
)
}
pub
fn
code_section_entry
(
&
mut
self
body
:
&
crate
:
:
FunctionBody
)
-
>
Result
<
FuncToValidate
<
ValidatorResources
>
>
{
let
offset
=
body
.
range
(
)
.
start
;
self
.
state
.
ensure_module
(
"
code
"
offset
)
?
;
let
state
=
self
.
module
.
as_mut
(
)
.
unwrap
(
)
;
let
(
index
ty
)
=
state
.
next_code_index_and_type
(
offset
)
?
;
Ok
(
FuncToValidate
{
index
ty
resources
:
ValidatorResources
(
state
.
module
.
arc
(
)
.
clone
(
)
)
features
:
self
.
features
}
)
}
pub
fn
data_section
(
&
mut
self
section
:
&
crate
:
:
DataSectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
process_module_section
(
Order
:
:
Data
section
"
data
"
|
state
_
_
count
offset
|
{
state
.
data_segment_count
=
count
;
check_max
(
0
count
MAX_WASM_DATA_SEGMENTS
"
data
segments
"
offset
)
}
|
state
features
types
d
offset
|
state
.
add_data_segment
(
d
features
types
offset
)
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
fn
module_section
(
&
mut
self
range
:
&
Range
<
usize
>
)
-
>
Result
<
(
)
>
{
self
.
state
.
ensure_component
(
"
module
"
range
.
start
)
?
;
let
current
=
self
.
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
core_modules
.
len
(
)
1
MAX_WASM_MODULES
"
modules
"
range
.
start
)
?
;
match
mem
:
:
replace
(
&
mut
self
.
state
State
:
:
Unparsed
(
Some
(
Encoding
:
:
Module
)
)
)
{
State
:
:
Component
=
>
{
}
_
=
>
unreachable
!
(
)
}
Ok
(
(
)
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
fn
instance_section
(
&
mut
self
section
:
&
crate
:
:
InstanceSectionReader
)
-
>
Result
<
(
)
>
{
self
.
process_component_section
(
section
"
core
instance
"
|
components
_
count
offset
|
{
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
instance_count
(
)
count
MAX_WASM_INSTANCES
"
instances
"
offset
)
?
;
current
.
core_instances
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
components
types
_
instance
offset
|
{
components
.
last_mut
(
)
.
unwrap
(
)
.
add_core_instance
(
instance
types
offset
)
}
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
fn
core_type_section
(
&
mut
self
section
:
&
crate
:
:
CoreTypeSectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
process_component_section
(
section
"
core
type
"
|
components
_types
count
offset
|
{
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
type_count
(
)
count
MAX_WASM_TYPES
"
types
"
offset
)
?
;
current
.
core_types
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
components
types
features
ty
offset
|
{
ComponentState
:
:
add_core_type
(
components
ty
features
types
offset
false
)
}
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
fn
component_section
(
&
mut
self
range
:
&
Range
<
usize
>
)
-
>
Result
<
(
)
>
{
self
.
state
.
ensure_component
(
"
component
"
range
.
start
)
?
;
let
current
=
self
.
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
components
.
len
(
)
1
MAX_WASM_COMPONENTS
"
components
"
range
.
start
)
?
;
match
mem
:
:
replace
(
&
mut
self
.
state
State
:
:
Unparsed
(
Some
(
Encoding
:
:
Component
)
)
)
{
State
:
:
Component
=
>
{
}
_
=
>
unreachable
!
(
)
}
Ok
(
(
)
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
fn
component_instance_section
(
&
mut
self
section
:
&
crate
:
:
ComponentInstanceSectionReader
)
-
>
Result
<
(
)
>
{
self
.
process_component_section
(
section
"
instance
"
|
components
_
count
offset
|
{
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
instance_count
(
)
count
MAX_WASM_INSTANCES
"
instances
"
offset
)
?
;
current
.
instances
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
components
types
features
instance
offset
|
{
components
.
last_mut
(
)
.
unwrap
(
)
.
add_instance
(
instance
features
types
offset
)
}
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
fn
component_alias_section
(
&
mut
self
section
:
&
crate
:
:
ComponentAliasSectionReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
process_component_section
(
section
"
alias
"
|
_
_
_
_
|
Ok
(
(
)
)
|
components
types
features
alias
offset
|
-
>
Result
<
(
)
BinaryReaderError
>
{
ComponentState
:
:
add_alias
(
components
alias
features
types
offset
)
}
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
fn
component_type_section
(
&
mut
self
section
:
&
crate
:
:
ComponentTypeSectionReader
)
-
>
Result
<
(
)
>
{
self
.
process_component_section
(
section
"
type
"
|
components
_types
count
offset
|
{
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
type_count
(
)
count
MAX_WASM_TYPES
"
types
"
offset
)
?
;
current
.
types
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
components
types
features
ty
offset
|
{
ComponentState
:
:
add_type
(
components
ty
features
types
offset
false
)
}
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
fn
component_canonical_section
(
&
mut
self
section
:
&
crate
:
:
ComponentCanonicalSectionReader
)
-
>
Result
<
(
)
>
{
self
.
process_component_section
(
section
"
function
"
|
components
_
count
offset
|
{
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
function_count
(
)
count
MAX_WASM_FUNCTIONS
"
functions
"
offset
)
?
;
current
.
funcs
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
components
types
features
func
offset
|
{
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
match
func
{
crate
:
:
CanonicalFunction
:
:
Lift
{
core_func_index
type_index
options
}
=
>
current
.
lift_function
(
core_func_index
type_index
options
.
into_vec
(
)
types
offset
)
crate
:
:
CanonicalFunction
:
:
Lower
{
func_index
options
}
=
>
current
.
lower_function
(
func_index
options
.
into_vec
(
)
types
offset
)
crate
:
:
CanonicalFunction
:
:
ResourceNew
{
resource
}
=
>
{
current
.
resource_new
(
resource
types
offset
)
}
crate
:
:
CanonicalFunction
:
:
ResourceDrop
{
resource
}
=
>
{
current
.
resource_drop
(
resource
types
offset
)
}
crate
:
:
CanonicalFunction
:
:
ResourceRep
{
resource
}
=
>
{
current
.
resource_rep
(
resource
types
offset
)
}
crate
:
:
CanonicalFunction
:
:
ThreadSpawn
{
func_ty_index
}
=
>
{
current
.
thread_spawn
(
func_ty_index
types
offset
features
)
}
crate
:
:
CanonicalFunction
:
:
ThreadHwConcurrency
=
>
{
current
.
thread_hw_concurrency
(
types
offset
features
)
}
}
}
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
fn
component_start_section
(
&
mut
self
f
:
&
crate
:
:
ComponentStartFunction
range
:
&
Range
<
usize
>
)
-
>
Result
<
(
)
>
{
self
.
state
.
ensure_component
(
"
start
"
range
.
start
)
?
;
self
.
components
.
last_mut
(
)
.
unwrap
(
)
.
add_start
(
f
.
func_index
&
f
.
arguments
f
.
results
&
self
.
features
&
mut
self
.
types
range
.
start
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
fn
component_import_section
(
&
mut
self
section
:
&
crate
:
:
ComponentImportSectionReader
)
-
>
Result
<
(
)
>
{
self
.
process_component_section
(
section
"
import
"
|
_
_
_
_
|
Ok
(
(
)
)
|
components
types
features
import
offset
|
{
components
.
last_mut
(
)
.
unwrap
(
)
.
add_import
(
import
features
types
offset
)
}
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
fn
component_export_section
(
&
mut
self
section
:
&
crate
:
:
ComponentExportSectionReader
)
-
>
Result
<
(
)
>
{
self
.
process_component_section
(
section
"
export
"
|
components
_
count
offset
|
{
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
exports
.
len
(
)
count
MAX_WASM_EXPORTS
"
exports
"
offset
)
?
;
current
.
exports
.
reserve
(
count
as
usize
)
;
Ok
(
(
)
)
}
|
components
types
features
export
offset
|
{
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
let
ty
=
current
.
export_to_entity_type
(
&
export
features
types
offset
)
?
;
current
.
add_export
(
export
.
name
ty
features
types
offset
false
)
}
)
}
pub
fn
unknown_section
(
&
mut
self
id
:
u8
range
:
&
Range
<
usize
>
)
-
>
Result
<
(
)
>
{
Err
(
format_err
!
(
range
.
start
"
malformed
section
id
:
{
id
}
"
)
)
}
pub
fn
end
(
&
mut
self
offset
:
usize
)
-
>
Result
<
Types
>
{
match
mem
:
:
replace
(
&
mut
self
.
state
State
:
:
End
)
{
State
:
:
Unparsed
(
_
)
=
>
Err
(
BinaryReaderError
:
:
new
(
"
cannot
call
end
before
a
header
has
been
parsed
"
offset
)
)
State
:
:
End
=
>
Err
(
BinaryReaderError
:
:
new
(
"
cannot
call
end
after
parsing
has
completed
"
offset
)
)
State
:
:
Module
=
>
{
let
mut
state
=
self
.
module
.
take
(
)
.
unwrap
(
)
;
state
.
validate_end
(
offset
)
?
;
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
if
let
Some
(
parent
)
=
self
.
components
.
last_mut
(
)
{
parent
.
add_core_module
(
&
state
.
module
&
mut
self
.
types
offset
)
?
;
self
.
state
=
State
:
:
Component
;
}
Ok
(
Types
:
:
from_module
(
self
.
id
self
.
types
.
commit
(
)
state
.
module
.
arc
(
)
.
clone
(
)
)
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
State
:
:
Component
=
>
{
let
mut
component
=
self
.
components
.
pop
(
)
.
unwrap
(
)
;
if
let
Some
(
index
)
=
component
.
values
.
iter
(
)
.
position
(
|
(
_
used
)
|
!
*
used
)
{
bail
!
(
offset
"
value
index
{
index
}
was
not
used
as
part
of
an
\
instantiation
start
function
or
export
"
)
;
}
let
ty
=
component
.
finish
(
&
mut
self
.
types
offset
)
?
;
if
let
Some
(
parent
)
=
self
.
components
.
last_mut
(
)
{
parent
.
add_component
(
ty
&
mut
self
.
types
)
?
;
self
.
state
=
State
:
:
Component
;
}
Ok
(
Types
:
:
from_component
(
self
.
id
self
.
types
.
commit
(
)
component
)
)
}
}
}
fn
process_module_section
<
'
a
T
>
(
&
mut
self
order
:
Order
section
:
&
SectionLimited
<
'
a
T
>
name
:
&
str
validate_section
:
impl
FnOnce
(
&
mut
ModuleState
&
WasmFeatures
&
mut
TypeAlloc
u32
usize
)
-
>
Result
<
(
)
>
mut
validate_item
:
impl
FnMut
(
&
mut
ModuleState
&
WasmFeatures
&
mut
TypeAlloc
T
usize
)
-
>
Result
<
(
)
>
)
-
>
Result
<
(
)
>
where
T
:
FromReader
<
'
a
>
{
let
offset
=
section
.
range
(
)
.
start
;
self
.
state
.
ensure_module
(
name
offset
)
?
;
let
state
=
self
.
module
.
as_mut
(
)
.
unwrap
(
)
;
state
.
update_order
(
order
offset
)
?
;
validate_section
(
state
&
self
.
features
&
mut
self
.
types
section
.
count
(
)
offset
)
?
;
for
item
in
section
.
clone
(
)
.
into_iter_with_offsets
(
)
{
let
(
offset
item
)
=
item
?
;
validate_item
(
state
&
self
.
features
&
mut
self
.
types
item
offset
)
?
;
}
Ok
(
(
)
)
}
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
fn
process_component_section
<
'
a
T
>
(
&
mut
self
section
:
&
SectionLimited
<
'
a
T
>
name
:
&
str
validate_section
:
impl
FnOnce
(
&
mut
Vec
<
ComponentState
>
&
mut
TypeAlloc
u32
usize
)
-
>
Result
<
(
)
>
mut
validate_item
:
impl
FnMut
(
&
mut
Vec
<
ComponentState
>
&
mut
TypeAlloc
&
WasmFeatures
T
usize
)
-
>
Result
<
(
)
>
)
-
>
Result
<
(
)
>
where
T
:
FromReader
<
'
a
>
{
let
offset
=
section
.
range
(
)
.
start
;
if
!
self
.
features
.
component_model
(
)
{
return
Err
(
BinaryReaderError
:
:
new
(
"
component
model
feature
is
not
enabled
"
offset
)
)
;
}
self
.
state
.
ensure_component
(
name
offset
)
?
;
validate_section
(
&
mut
self
.
components
&
mut
self
.
types
section
.
count
(
)
offset
)
?
;
for
item
in
section
.
clone
(
)
.
into_iter_with_offsets
(
)
{
let
(
offset
item
)
=
item
?
;
validate_item
(
&
mut
self
.
components
&
mut
self
.
types
&
self
.
features
item
offset
)
?
;
}
Ok
(
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
crate
:
:
{
GlobalType
MemoryType
RefType
TableType
ValType
Validator
WasmFeatures
}
;
use
anyhow
:
:
Result
;
#
[
test
]
fn
test_module_type_information
(
)
-
>
Result
<
(
)
>
{
let
bytes
=
wat
:
:
parse_str
(
r
#
"
(
module
(
type
(
func
(
param
i32
i64
)
(
result
i32
)
)
)
(
memory
1
5
)
(
table
10
funcref
)
(
global
(
mut
i32
)
(
i32
.
const
0
)
)
(
func
(
type
0
)
(
i32
.
const
0
)
)
(
tag
(
param
i64
i32
)
)
(
elem
funcref
(
ref
.
func
0
)
)
)
"
#
)
?
;
let
mut
validator
=
Validator
:
:
new_with_features
(
WasmFeatures
:
:
default
(
)
|
WasmFeatures
:
:
EXCEPTIONS
)
;
let
types
=
validator
.
validate_all
(
&
bytes
)
?
;
let
types
=
types
.
as_ref
(
)
;
assert_eq
!
(
types
.
core_type_count_in_module
(
)
2
)
;
assert_eq
!
(
types
.
memory_count
(
)
1
)
;
assert_eq
!
(
types
.
table_count
(
)
1
)
;
assert_eq
!
(
types
.
global_count
(
)
1
)
;
assert_eq
!
(
types
.
function_count
(
)
1
)
;
assert_eq
!
(
types
.
tag_count
(
)
1
)
;
assert_eq
!
(
types
.
element_count
(
)
1
)
;
assert_eq
!
(
types
.
module_count
(
)
0
)
;
assert_eq
!
(
types
.
component_count
(
)
0
)
;
assert_eq
!
(
types
.
core_instance_count
(
)
0
)
;
assert_eq
!
(
types
.
value_count
(
)
0
)
;
let
id
=
types
.
core_type_at_in_module
(
0
)
;
let
ty
=
types
[
id
]
.
unwrap_func
(
)
;
assert_eq
!
(
ty
.
params
(
)
[
ValType
:
:
I32
ValType
:
:
I64
]
)
;
assert_eq
!
(
ty
.
results
(
)
[
ValType
:
:
I32
]
)
;
let
id
=
types
.
core_type_at_in_module
(
1
)
;
let
ty
=
types
[
id
]
.
unwrap_func
(
)
;
assert_eq
!
(
ty
.
params
(
)
[
ValType
:
:
I64
ValType
:
:
I32
]
)
;
assert_eq
!
(
ty
.
results
(
)
[
]
)
;
assert_eq
!
(
types
.
memory_at
(
0
)
MemoryType
{
memory64
:
false
shared
:
false
initial
:
1
maximum
:
Some
(
5
)
page_size_log2
:
None
}
)
;
assert_eq
!
(
types
.
table_at
(
0
)
TableType
{
initial
:
10
maximum
:
None
element_type
:
RefType
:
:
FUNCREF
table64
:
false
shared
:
false
}
)
;
assert_eq
!
(
types
.
global_at
(
0
)
GlobalType
{
content_type
:
ValType
:
:
I32
mutable
:
true
shared
:
false
}
)
;
let
id
=
types
.
core_function_at
(
0
)
;
let
ty
=
types
[
id
]
.
unwrap_func
(
)
;
assert_eq
!
(
ty
.
params
(
)
[
ValType
:
:
I32
ValType
:
:
I64
]
)
;
assert_eq
!
(
ty
.
results
(
)
[
ValType
:
:
I32
]
)
;
let
ty
=
types
.
tag_at
(
0
)
;
let
ty
=
types
[
ty
]
.
unwrap_func
(
)
;
assert_eq
!
(
ty
.
params
(
)
[
ValType
:
:
I64
ValType
:
:
I32
]
)
;
assert_eq
!
(
ty
.
results
(
)
[
]
)
;
assert_eq
!
(
types
.
element_at
(
0
)
RefType
:
:
FUNCREF
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
test_type_id_aliasing
(
)
-
>
Result
<
(
)
>
{
let
bytes
=
wat
:
:
parse_str
(
r
#
"
(
component
(
type
T
(
list
string
)
)
(
alias
outer
0
T
(
type
A1
)
)
(
alias
outer
0
T
(
type
A2
)
)
)
"
#
)
?
;
let
mut
validator
=
Validator
:
:
new_with_features
(
WasmFeatures
:
:
default
(
)
|
WasmFeatures
:
:
COMPONENT_MODEL
)
;
let
types
=
validator
.
validate_all
(
&
bytes
)
?
;
let
types
=
types
.
as_ref
(
)
;
let
t_id
=
types
.
component_defined_type_at
(
0
)
;
let
a1_id
=
types
.
component_defined_type_at
(
1
)
;
let
a2_id
=
types
.
component_defined_type_at
(
2
)
;
assert
!
(
t_id
=
=
a1_id
)
;
assert
!
(
t_id
=
=
a2_id
)
;
assert
!
(
a1_id
=
=
a2_id
)
;
assert
!
(
std
:
:
ptr
:
:
eq
(
&
types
[
t_id
]
&
types
[
a1_id
]
)
)
;
assert
!
(
std
:
:
ptr
:
:
eq
(
&
types
[
t_id
]
&
types
[
a2_id
]
)
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
test_type_id_exports
(
)
-
>
Result
<
(
)
>
{
let
bytes
=
wat
:
:
parse_str
(
r
#
"
(
component
(
type
T
(
list
string
)
)
(
export
A1
"
A1
"
(
type
T
)
)
(
export
A2
"
A2
"
(
type
T
)
)
)
"
#
)
?
;
let
mut
validator
=
Validator
:
:
new_with_features
(
WasmFeatures
:
:
default
(
)
|
WasmFeatures
:
:
COMPONENT_MODEL
)
;
let
types
=
validator
.
validate_all
(
&
bytes
)
?
;
let
types
=
types
.
as_ref
(
)
;
let
t_id
=
types
.
component_defined_type_at
(
0
)
;
let
a1_id
=
types
.
component_defined_type_at
(
1
)
;
let
a2_id
=
types
.
component_defined_type_at
(
2
)
;
assert
!
(
t_id
!
=
a1_id
)
;
assert
!
(
t_id
!
=
a2_id
)
;
assert
!
(
a1_id
!
=
a2_id
)
;
assert
!
(
std
:
:
ptr
:
:
eq
(
&
types
[
t_id
]
&
types
[
a1_id
]
)
)
;
assert
!
(
std
:
:
ptr
:
:
eq
(
&
types
[
t_id
]
&
types
[
a2_id
]
)
)
;
Ok
(
(
)
)
}
}
