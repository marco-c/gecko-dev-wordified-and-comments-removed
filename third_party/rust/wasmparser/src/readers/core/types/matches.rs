use
crate
:
:
{
types
:
:
{
CoreTypeId
RecGroupId
TypeList
}
ArrayType
CompositeInnerType
CompositeType
ContType
FieldType
FuncType
RefType
StorageType
StructType
SubType
ValType
}
;
pub
trait
Matches
{
fn
matches
(
types
:
&
TypeList
a
:
Self
b
:
Self
)
-
>
bool
;
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
(
crate
)
struct
WithRecGroup
<
T
>
{
inner
:
T
rec_group_id
:
RecGroupId
}
impl
<
T
>
WithRecGroup
<
T
>
{
#
[
inline
]
fn
rec_group
(
x
:
Self
)
-
>
RecGroupId
{
x
.
rec_group_id
}
}
impl
<
T
>
core
:
:
ops
:
:
Deref
for
WithRecGroup
<
T
>
{
type
Target
=
T
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
T
{
&
self
.
inner
}
}
impl
<
T
>
core
:
:
ops
:
:
DerefMut
for
WithRecGroup
<
T
>
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
inner
}
}
impl
WithRecGroup
<
CoreTypeId
>
{
pub
(
crate
)
fn
new
(
types
:
&
TypeList
id
:
CoreTypeId
)
-
>
Self
{
let
rec_group_id
=
types
.
rec_group_id_of
(
id
)
;
WithRecGroup
{
inner
:
id
rec_group_id
}
}
}
impl
<
T
>
WithRecGroup
<
T
>
{
pub
(
crate
)
fn
map
<
U
>
(
x
:
Self
f
:
impl
FnOnce
(
T
)
-
>
U
)
-
>
WithRecGroup
<
U
>
{
WithRecGroup
{
inner
:
f
(
x
.
inner
)
rec_group_id
:
x
.
rec_group_id
}
}
}
impl
<
'
a
>
Matches
for
WithRecGroup
<
&
'
a
SubType
>
{
fn
matches
(
types
:
&
TypeList
a
:
Self
b
:
Self
)
-
>
bool
{
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
a
|
a
|
&
a
.
composite_type
)
WithRecGroup
:
:
map
(
b
|
b
|
&
b
.
composite_type
)
)
}
}
impl
<
'
a
>
Matches
for
WithRecGroup
<
&
'
a
CompositeType
>
{
fn
matches
(
types
:
&
TypeList
a
:
Self
b
:
Self
)
-
>
bool
{
use
CompositeInnerType
:
:
*
;
if
(
*
a
)
.
shared
!
=
(
*
b
)
.
shared
{
return
false
;
}
match
(
&
(
*
a
)
.
inner
&
(
*
b
)
.
inner
)
{
(
Func
(
fa
)
Func
(
fb
)
)
=
>
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
a
|
_
|
fa
)
WithRecGroup
:
:
map
(
b
|
_
|
fb
)
)
(
Func
(
_
)
_
)
=
>
false
(
Array
(
aa
)
Array
(
ab
)
)
=
>
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
a
|
_
|
*
aa
)
WithRecGroup
:
:
map
(
b
|
_
|
*
ab
)
)
(
Array
(
_
)
_
)
=
>
false
(
Struct
(
sa
)
Struct
(
sb
)
)
=
>
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
a
|
_
|
sa
)
WithRecGroup
:
:
map
(
b
|
_
|
sb
)
)
(
Struct
(
_
)
_
)
=
>
false
(
Cont
(
ca
)
Cont
(
cb
)
)
=
>
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
a
|
_
|
ca
)
WithRecGroup
:
:
map
(
b
|
_
|
cb
)
)
(
Cont
(
_
)
_
)
=
>
false
}
}
}
impl
<
'
a
>
Matches
for
WithRecGroup
<
&
'
a
FuncType
>
{
fn
matches
(
types
:
&
TypeList
a
:
Self
b
:
Self
)
-
>
bool
{
if
a
.
params
(
)
.
len
(
)
!
=
b
.
params
(
)
.
len
(
)
|
|
a
.
results
(
)
.
len
(
)
!
=
b
.
results
(
)
.
len
(
)
{
return
false
;
}
let
params_match
=
a
.
params
(
)
.
iter
(
)
.
zip
(
b
.
params
(
)
)
.
all
(
|
(
pa
pb
)
|
{
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
b
|
_
|
*
pb
)
WithRecGroup
:
:
map
(
a
|
_
|
*
pa
)
)
}
)
;
if
!
params_match
{
return
false
;
}
a
.
results
(
)
.
iter
(
)
.
zip
(
b
.
results
(
)
)
.
all
(
|
(
ra
rb
)
|
{
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
a
|
_
|
*
ra
)
WithRecGroup
:
:
map
(
b
|
_
|
*
rb
)
)
}
)
}
}
impl
Matches
for
WithRecGroup
<
ArrayType
>
{
fn
matches
(
types
:
&
TypeList
a
:
Self
b
:
Self
)
-
>
bool
{
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
a
|
a
|
a
.
0
)
WithRecGroup
:
:
map
(
b
|
b
|
b
.
0
)
)
}
}
impl
<
'
a
>
Matches
for
WithRecGroup
<
&
'
a
StructType
>
{
fn
matches
(
types
:
&
TypeList
a
:
Self
b
:
Self
)
-
>
bool
{
a
.
fields
.
len
(
)
>
=
b
.
fields
.
len
(
)
&
&
a
.
fields
.
iter
(
)
.
zip
(
b
.
fields
.
iter
(
)
)
.
all
(
|
(
fa
fb
)
|
{
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
a
|
_
|
*
fa
)
WithRecGroup
:
:
map
(
b
|
_
|
*
fb
)
)
}
)
}
}
impl
Matches
for
WithRecGroup
<
FieldType
>
{
fn
matches
(
types
:
&
TypeList
a
:
Self
b
:
Self
)
-
>
bool
{
if
!
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
a
|
a
|
a
.
element_type
)
WithRecGroup
:
:
map
(
b
|
b
|
b
.
element_type
)
)
{
return
false
;
}
if
!
a
.
mutable
&
&
!
b
.
mutable
{
return
true
;
}
a
.
mutable
&
&
b
.
mutable
&
&
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
b
|
b
|
b
.
element_type
)
WithRecGroup
:
:
map
(
a
|
a
|
a
.
element_type
)
)
}
}
impl
Matches
for
WithRecGroup
<
StorageType
>
{
fn
matches
(
types
:
&
TypeList
a
:
Self
b
:
Self
)
-
>
bool
{
use
StorageType
as
ST
;
match
(
*
a
*
b
)
{
(
ST
:
:
I8
ST
:
:
I8
)
|
(
ST
:
:
I16
ST
:
:
I16
)
=
>
true
(
ST
:
:
I8
|
ST
:
:
I16
_
)
=
>
false
(
ST
:
:
Val
(
va
)
ST
:
:
Val
(
vb
)
)
=
>
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
a
|
_
|
va
)
WithRecGroup
:
:
map
(
b
|
_
|
vb
)
)
(
ST
:
:
Val
(
_
)
_
)
=
>
false
}
}
}
impl
<
'
a
>
Matches
for
WithRecGroup
<
&
'
a
ContType
>
{
fn
matches
(
types
:
&
TypeList
a
:
Self
b
:
Self
)
-
>
bool
{
match
(
*
a
*
b
)
{
(
ContType
(
ca
)
ContType
(
cb
)
)
=
>
{
ca
=
=
cb
|
|
types
.
reftype_is_subtype_impl
(
RefType
:
:
concrete
(
false
*
ca
)
Some
(
WithRecGroup
:
:
rec_group
(
a
)
)
RefType
:
:
concrete
(
false
*
cb
)
Some
(
WithRecGroup
:
:
rec_group
(
b
)
)
)
}
}
}
}
impl
Matches
for
WithRecGroup
<
ValType
>
{
fn
matches
(
types
:
&
TypeList
a
:
Self
b
:
Self
)
-
>
bool
{
match
(
*
a
*
b
)
{
(
ValType
:
:
Ref
(
ra
)
ValType
:
:
Ref
(
rb
)
)
=
>
Matches
:
:
matches
(
types
WithRecGroup
:
:
map
(
a
|
_
|
ra
)
WithRecGroup
:
:
map
(
b
|
_
|
rb
)
)
(
ValType
:
:
Ref
(
_
)
_
)
=
>
false
(
ValType
:
:
I32
|
ValType
:
:
I64
|
ValType
:
:
F32
|
ValType
:
:
F64
|
ValType
:
:
V128
_
)
=
>
{
*
a
=
=
*
b
}
}
}
}
impl
Matches
for
WithRecGroup
<
RefType
>
{
fn
matches
(
types
:
&
TypeList
a
:
Self
b
:
Self
)
-
>
bool
{
types
.
reftype_is_subtype_impl
(
*
a
Some
(
WithRecGroup
:
:
rec_group
(
a
)
)
*
b
Some
(
WithRecGroup
:
:
rec_group
(
b
)
)
)
}
}
