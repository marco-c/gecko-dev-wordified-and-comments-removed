use
crate
:
:
{
BinaryReader
ConstExpr
FromReader
Result
SectionLimited
TableType
}
;
pub
type
TableSectionReader
<
'
a
>
=
SectionLimited
<
'
a
Table
<
'
a
>
>
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
Table
<
'
a
>
{
pub
ty
:
TableType
pub
init
:
TableInit
<
'
a
>
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
TableInit
<
'
a
>
{
RefNull
Expr
(
ConstExpr
<
'
a
>
)
}
impl
<
'
a
>
FromReader
<
'
a
>
for
Table
<
'
a
>
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
has_init_expr
=
if
reader
.
peek
(
)
?
=
=
0x40
{
reader
.
read_u8
(
)
?
;
true
}
else
{
false
}
;
if
has_init_expr
{
if
reader
.
read_u8
(
)
?
!
=
0x00
{
bail
!
(
reader
.
original_position
(
)
-
1
"
invalid
table
encoding
"
)
;
}
}
let
ty
=
reader
.
read
:
:
<
TableType
>
(
)
?
;
let
init
=
if
has_init_expr
{
TableInit
:
:
Expr
(
reader
.
read
(
)
?
)
}
else
{
TableInit
:
:
RefNull
}
;
Ok
(
Table
{
ty
init
}
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
TableType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
element_type
=
reader
.
read
(
)
?
;
let
pos
=
reader
.
original_position
(
)
;
let
flags
=
reader
.
read_u8
(
)
?
;
if
(
flags
&
!
0b111
)
!
=
0
{
bail
!
(
pos
"
invalid
table
resizable
limits
flags
"
)
;
}
let
has_max
=
(
flags
&
0b001
)
!
=
0
;
let
shared
=
(
flags
&
0b010
)
!
=
0
;
let
table64
=
(
flags
&
0b100
)
!
=
0
;
Ok
(
TableType
{
element_type
table64
initial
:
if
table64
{
reader
.
read_var_u64
(
)
?
}
else
{
reader
.
read_var_u32
(
)
?
.
into
(
)
}
maximum
:
if
!
has_max
{
None
}
else
if
table64
{
Some
(
reader
.
read_var_u64
(
)
?
)
}
else
{
Some
(
reader
.
read_var_u32
(
)
?
.
into
(
)
)
}
shared
}
)
}
}
