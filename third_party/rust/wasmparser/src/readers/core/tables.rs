use
crate
:
:
{
BinaryReader
ConstExpr
FromReader
Result
SectionLimited
TableType
}
;
pub
type
TableSectionReader
<
'
a
>
=
SectionLimited
<
'
a
Table
<
'
a
>
>
;
#
[
derive
(
Debug
)
]
pub
struct
Table
<
'
a
>
{
pub
ty
:
TableType
pub
init
:
TableInit
<
'
a
>
}
#
[
derive
(
Debug
)
]
pub
enum
TableInit
<
'
a
>
{
RefNull
Expr
(
ConstExpr
<
'
a
>
)
}
impl
<
'
a
>
FromReader
<
'
a
>
for
Table
<
'
a
>
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
has_init_expr
=
if
reader
.
peek
(
)
?
=
=
0x40
{
reader
.
read_u8
(
)
?
;
true
}
else
{
false
}
;
if
has_init_expr
{
if
reader
.
read_u8
(
)
?
!
=
0x00
{
bail
!
(
reader
.
original_position
(
)
-
1
"
invalid
table
encoding
"
)
;
}
}
let
ty
=
reader
.
read
:
:
<
TableType
>
(
)
?
;
let
init
=
if
has_init_expr
{
TableInit
:
:
Expr
(
reader
.
read
(
)
?
)
}
else
{
TableInit
:
:
RefNull
}
;
Ok
(
Table
{
ty
init
}
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
TableType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
element_type
=
reader
.
read
(
)
?
;
let
has_max
=
match
reader
.
read_u8
(
)
?
{
0x00
=
>
false
0x01
=
>
true
_
=
>
{
bail
!
(
reader
.
original_position
(
)
-
1
"
invalid
table
resizable
limits
flags
"
)
}
}
;
let
initial
=
reader
.
read
(
)
?
;
let
maximum
=
if
has_max
{
Some
(
reader
.
read
(
)
?
)
}
else
{
None
}
;
Ok
(
TableType
{
element_type
initial
maximum
}
)
}
}
