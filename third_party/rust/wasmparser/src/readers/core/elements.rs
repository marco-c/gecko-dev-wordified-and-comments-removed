use
crate
:
:
{
BinaryReader
BinaryReaderError
ConstExpr
ExternalKind
FromReader
OperatorsReader
OperatorsReaderAllocations
RefType
Result
SectionLimited
}
;
use
core
:
:
ops
:
:
Range
;
#
[
derive
(
Clone
)
]
pub
struct
Element
<
'
a
>
{
pub
kind
:
ElementKind
<
'
a
>
pub
items
:
ElementItems
<
'
a
>
pub
range
:
Range
<
usize
>
}
#
[
derive
(
Clone
)
]
pub
enum
ElementKind
<
'
a
>
{
Passive
Active
{
table_index
:
Option
<
u32
>
offset_expr
:
ConstExpr
<
'
a
>
}
Declared
}
#
[
derive
(
Clone
)
]
pub
enum
ElementItems
<
'
a
>
{
Functions
(
SectionLimited
<
'
a
u32
>
)
Expressions
(
RefType
SectionLimited
<
'
a
ConstExpr
<
'
a
>
>
)
}
pub
type
ElementSectionReader
<
'
a
>
=
SectionLimited
<
'
a
Element
<
'
a
>
>
;
impl
<
'
a
>
FromReader
<
'
a
>
for
Element
<
'
a
>
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
elem_start
=
reader
.
original_position
(
)
;
let
flags
=
reader
.
read_var_u32
(
)
?
;
if
(
flags
&
!
0b111
)
!
=
0
{
return
Err
(
BinaryReaderError
:
:
new
(
"
invalid
flags
byte
in
element
segment
"
reader
.
original_position
(
)
-
1
)
)
;
}
let
kind
=
if
flags
&
0b001
!
=
0
{
if
flags
&
0b010
!
=
0
{
ElementKind
:
:
Declared
}
else
{
ElementKind
:
:
Passive
}
}
else
{
let
table_index
=
if
flags
&
0b010
=
=
0
{
None
}
else
{
Some
(
reader
.
read_var_u32
(
)
?
)
}
;
let
offset_expr
=
reader
.
read
(
)
?
;
ElementKind
:
:
Active
{
table_index
offset_expr
}
}
;
let
exprs
=
flags
&
0b100
!
=
0
;
let
ty
=
if
flags
&
0b011
!
=
0
{
if
exprs
{
Some
(
reader
.
read
(
)
?
)
}
else
{
match
reader
.
read
(
)
?
{
ExternalKind
:
:
Func
=
>
None
_
=
>
{
return
Err
(
BinaryReaderError
:
:
new
(
"
only
the
function
external
type
is
supported
in
elem
segment
"
reader
.
original_position
(
)
-
1
)
)
;
}
}
}
}
else
{
None
}
;
let
data
=
reader
.
skip
(
|
reader
|
{
let
items_count
=
reader
.
read_var_u32
(
)
?
;
let
mut
allocs
=
OperatorsReaderAllocations
:
:
default
(
)
;
if
exprs
{
for
_
in
0
.
.
items_count
{
let
mut
ops
=
OperatorsReader
:
:
new_with_allocs
(
reader
.
clone
(
)
core
:
:
mem
:
:
take
(
&
mut
allocs
)
)
;
ops
.
skip_const_expr
(
)
?
;
*
reader
=
ops
.
get_binary_reader
(
)
;
allocs
=
ops
.
into_allocations
(
)
;
}
}
else
{
for
_
in
0
.
.
items_count
{
reader
.
read_var_u32
(
)
?
;
}
}
Ok
(
(
)
)
}
)
?
;
let
items
=
if
exprs
{
ElementItems
:
:
Expressions
(
ty
.
unwrap_or
(
RefType
:
:
FUNCREF
)
SectionLimited
:
:
new
(
data
)
?
)
}
else
{
assert
!
(
ty
.
is_none
(
)
)
;
ElementItems
:
:
Functions
(
SectionLimited
:
:
new
(
data
)
?
)
}
;
let
elem_end
=
reader
.
original_position
(
)
;
let
range
=
elem_start
.
.
elem_end
;
Ok
(
Element
{
kind
items
range
}
)
}
}
