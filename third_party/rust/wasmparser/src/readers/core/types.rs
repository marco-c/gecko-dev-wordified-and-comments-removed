use
crate
:
:
binary_reader
:
:
BinaryReaderErrorKind
;
use
crate
:
:
limits
:
:
{
MAX_WASM_FUNCTION_PARAMS
MAX_WASM_FUNCTION_RETURNS
MAX_WASM_STRUCT_FIELDS
MAX_WASM_SUPERTYPES
MAX_WASM_TYPES
}
;
use
crate
:
:
prelude
:
:
*
;
#
[
cfg
(
feature
=
"
validate
"
)
]
use
crate
:
:
types
:
:
CoreTypeId
;
use
crate
:
:
{
BinaryReader
BinaryReaderError
FromReader
Result
SectionLimited
}
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
fmt
:
:
{
self
Debug
}
;
use
core
:
:
hash
:
:
{
Hash
Hasher
}
;
#
[
cfg
(
feature
=
"
validate
"
)
]
mod
matches
;
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
(
crate
)
use
self
:
:
matches
:
:
{
Matches
WithRecGroup
}
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
PackedIndex
(
u32
)
;
#
[
test
]
fn
can_fit_max_wasm_types_in_packed_index
(
)
{
assert
!
(
PackedIndex
:
:
can_represent_index
(
crate
:
:
limits
:
:
MAX_WASM_TYPES
as
u32
)
)
;
assert
!
(
PackedIndex
:
:
can_represent_index
(
0b00000000_00001111_00000000_00000000
)
)
;
assert
!
(
PackedIndex
:
:
can_represent_index
(
0b00000000_00000000_11111111_00000000
)
)
;
assert
!
(
PackedIndex
:
:
can_represent_index
(
0b00000000_00000000_00000000_11111111
)
)
;
assert
!
(
PackedIndex
:
:
can_represent_index
(
0
)
)
;
}
impl
PackedIndex
{
const
UNUSED_MASK
:
u32
=
u32
:
:
MAX
&
!
(
Self
:
:
KIND_MASK
|
Self
:
:
INDEX_MASK
)
;
const
KIND_MASK
:
u32
=
0b11
<
<
20
;
const
INDEX_MASK
:
u32
=
(
1
<
<
20
)
-
1
;
const
MODULE_KIND
:
u32
=
0b00
<
<
20
;
const
REC_GROUP_KIND
:
u32
=
0b01
<
<
20
;
#
[
cfg
(
feature
=
"
validate
"
)
]
const
ID_KIND
:
u32
=
0b10
<
<
20
;
#
[
inline
]
pub
(
crate
)
fn
unchecked_from_u32
(
x
:
u32
)
-
>
Self
{
debug_assert_eq
!
(
Self
:
:
UNUSED_MASK
&
x
0
)
;
Self
(
x
)
}
#
[
inline
]
pub
(
crate
)
fn
to_u32
(
id
:
Self
)
-
>
u32
{
let
x
=
id
.
0
;
debug_assert_eq
!
(
Self
:
:
UNUSED_MASK
&
x
0
)
;
x
}
#
[
inline
]
fn
can_represent_index
(
index
:
u32
)
-
>
bool
{
index
&
Self
:
:
INDEX_MASK
=
=
index
}
#
[
inline
]
fn
kind
(
&
self
)
-
>
u32
{
self
.
0
&
Self
:
:
KIND_MASK
}
#
[
inline
]
fn
index
(
&
self
)
-
>
u32
{
self
.
0
&
Self
:
:
INDEX_MASK
}
#
[
inline
]
pub
fn
from_module_index
(
index
:
u32
)
-
>
Option
<
Self
>
{
if
PackedIndex
:
:
can_represent_index
(
index
)
{
Some
(
PackedIndex
(
PackedIndex
:
:
MODULE_KIND
|
index
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
from_rec_group_index
(
index
:
u32
)
-
>
Option
<
Self
>
{
if
PackedIndex
:
:
can_represent_index
(
index
)
{
Some
(
PackedIndex
(
PackedIndex
:
:
REC_GROUP_KIND
|
index
)
)
}
else
{
None
}
}
#
[
inline
]
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
fn
from_id
(
id
:
CoreTypeId
)
-
>
Option
<
Self
>
{
let
index
=
u32
:
:
try_from
(
crate
:
:
types
:
:
TypeIdentifier
:
:
index
(
&
id
)
)
.
unwrap
(
)
;
if
PackedIndex
:
:
can_represent_index
(
index
)
{
Some
(
PackedIndex
(
PackedIndex
:
:
ID_KIND
|
index
)
)
}
else
{
None
}
}
#
[
inline
]
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
fn
is_canonical
(
&
self
)
-
>
bool
{
match
self
.
kind
(
)
{
Self
:
:
REC_GROUP_KIND
|
Self
:
:
ID_KIND
=
>
true
Self
:
:
MODULE_KIND
=
>
false
_
=
>
unreachable
!
(
)
}
}
#
[
inline
]
pub
fn
unpack
(
&
self
)
-
>
UnpackedIndex
{
match
self
.
kind
(
)
{
Self
:
:
MODULE_KIND
=
>
UnpackedIndex
:
:
Module
(
self
.
index
(
)
)
Self
:
:
REC_GROUP_KIND
=
>
UnpackedIndex
:
:
RecGroup
(
self
.
index
(
)
)
#
[
cfg
(
feature
=
"
validate
"
)
]
Self
:
:
ID_KIND
=
>
UnpackedIndex
:
:
Id
(
<
CoreTypeId
as
crate
:
:
types
:
:
TypeIdentifier
>
:
:
from_index
(
self
.
index
(
)
)
)
_
=
>
unreachable
!
(
)
}
}
#
[
inline
]
pub
fn
as_module_index
(
&
self
)
-
>
Option
<
u32
>
{
if
self
.
kind
(
)
=
=
Self
:
:
MODULE_KIND
{
Some
(
self
.
index
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
as_rec_group_index
(
&
self
)
-
>
Option
<
u32
>
{
if
self
.
kind
(
)
=
=
Self
:
:
REC_GROUP_KIND
{
Some
(
self
.
index
(
)
)
}
else
{
None
}
}
#
[
inline
]
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
fn
as_core_type_id
(
&
self
)
-
>
Option
<
CoreTypeId
>
{
if
self
.
kind
(
)
=
=
Self
:
:
ID_KIND
{
Some
(
<
CoreTypeId
as
crate
:
:
types
:
:
TypeIdentifier
>
:
:
from_index
(
self
.
index
(
)
)
)
}
else
{
None
}
}
}
impl
fmt
:
:
Debug
for
PackedIndex
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
CoreTypeIndex
"
)
.
field
(
"
kind
"
match
self
.
kind
(
)
{
Self
:
:
MODULE_KIND
=
>
&
"
module
"
Self
:
:
REC_GROUP_KIND
=
>
&
"
recgroup
"
#
[
cfg
(
feature
=
"
validate
"
)
]
Self
:
:
ID_KIND
=
>
&
"
id
"
_
=
>
unreachable
!
(
)
}
)
.
field
(
"
index
"
&
self
.
index
(
)
)
.
finish
(
)
}
}
impl
fmt
:
:
Display
for
PackedIndex
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
unpack
(
)
f
)
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Ord
PartialOrd
Hash
)
]
pub
enum
UnpackedIndex
{
Module
(
u32
)
RecGroup
(
u32
)
#
[
cfg
(
feature
=
"
validate
"
)
]
Id
(
CoreTypeId
)
}
impl
UnpackedIndex
{
pub
fn
pack
(
&
self
)
-
>
Option
<
PackedIndex
>
{
match
self
{
UnpackedIndex
:
:
Module
(
i
)
=
>
PackedIndex
:
:
from_module_index
(
*
i
)
UnpackedIndex
:
:
RecGroup
(
i
)
=
>
PackedIndex
:
:
from_rec_group_index
(
*
i
)
#
[
cfg
(
feature
=
"
validate
"
)
]
UnpackedIndex
:
:
Id
(
id
)
=
>
PackedIndex
:
:
from_id
(
*
id
)
}
}
#
[
inline
]
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
fn
is_canonical
(
&
self
)
-
>
bool
{
matches
!
(
self
UnpackedIndex
:
:
RecGroup
(
_
)
|
UnpackedIndex
:
:
Id
(
_
)
)
}
#
[
inline
]
pub
fn
as_module_index
(
&
self
)
-
>
Option
<
u32
>
{
if
let
Self
:
:
Module
(
i
)
=
*
self
{
Some
(
i
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
as_rec_group_index
(
&
self
)
-
>
Option
<
u32
>
{
if
let
Self
:
:
RecGroup
(
i
)
=
*
self
{
Some
(
i
)
}
else
{
None
}
}
#
[
inline
]
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
fn
as_core_type_id
(
&
self
)
-
>
Option
<
CoreTypeId
>
{
if
let
Self
:
:
Id
(
id
)
=
*
self
{
Some
(
id
)
}
else
{
None
}
}
}
impl
fmt
:
:
Display
for
UnpackedIndex
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
match
self
{
UnpackedIndex
:
:
Module
(
i
)
=
>
write
!
(
f
"
(
module
{
i
}
)
"
)
UnpackedIndex
:
:
RecGroup
(
i
)
=
>
write
!
(
f
"
(
recgroup
{
i
}
)
"
)
#
[
cfg
(
feature
=
"
validate
"
)
]
UnpackedIndex
:
:
Id
(
id
)
=
>
write
!
(
f
"
(
id
{
}
)
"
crate
:
:
types
:
:
TypeIdentifier
:
:
index
(
id
)
)
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
RecGroup
{
inner
:
RecGroupInner
}
#
[
derive
(
Debug
Clone
)
]
enum
RecGroupInner
{
Implicit
(
(
usize
SubType
)
)
Explicit
(
Vec
<
(
usize
SubType
)
>
)
}
impl
RecGroup
{
pub
(
crate
)
fn
explicit
(
types
:
Vec
<
(
usize
SubType
)
>
)
-
>
Self
{
RecGroup
{
inner
:
RecGroupInner
:
:
Explicit
(
types
)
}
}
pub
(
crate
)
fn
implicit
(
offset
:
usize
ty
:
SubType
)
-
>
Self
{
RecGroup
{
inner
:
RecGroupInner
:
:
Implicit
(
(
offset
ty
)
)
}
}
pub
fn
is_explicit_rec_group
(
&
self
)
-
>
bool
{
matches
!
(
self
.
inner
RecGroupInner
:
:
Explicit
(
.
.
)
)
}
pub
fn
types
(
&
self
)
-
>
impl
ExactSizeIterator
<
Item
=
&
SubType
>
+
'
_
{
let
types
=
match
&
self
.
inner
{
RecGroupInner
:
:
Implicit
(
ty
)
=
>
core
:
:
slice
:
:
from_ref
(
ty
)
RecGroupInner
:
:
Explicit
(
types
)
=
>
types
}
;
types
.
iter
(
)
.
map
(
|
(
_
ty
)
|
ty
)
}
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
(
crate
)
fn
types_mut
(
&
mut
self
)
-
>
impl
ExactSizeIterator
<
Item
=
&
mut
SubType
>
+
'
_
{
let
types
=
match
&
mut
self
.
inner
{
RecGroupInner
:
:
Implicit
(
ty
)
=
>
core
:
:
slice
:
:
from_mut
(
ty
)
RecGroupInner
:
:
Explicit
(
types
)
=
>
types
}
;
types
.
iter_mut
(
)
.
map
(
|
(
_
ty
)
|
ty
)
}
pub
fn
into_types
(
self
)
-
>
impl
ExactSizeIterator
<
Item
=
SubType
>
{
self
.
into_types_and_offsets
(
)
.
map
(
|
(
_
ty
)
|
ty
)
}
pub
fn
into_types_and_offsets
(
self
)
-
>
impl
ExactSizeIterator
<
Item
=
(
usize
SubType
)
>
{
return
match
self
.
inner
{
RecGroupInner
:
:
Implicit
(
tup
)
=
>
Iter
:
:
Implicit
(
Some
(
tup
)
)
RecGroupInner
:
:
Explicit
(
types
)
=
>
Iter
:
:
Explicit
(
types
.
into_iter
(
)
)
}
;
enum
Iter
{
Implicit
(
Option
<
(
usize
SubType
)
>
)
Explicit
(
alloc
:
:
vec
:
:
IntoIter
<
(
usize
SubType
)
>
)
}
impl
Iterator
for
Iter
{
type
Item
=
(
usize
SubType
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
(
usize
SubType
)
>
{
match
self
{
Self
:
:
Implicit
(
ty
)
=
>
ty
.
take
(
)
Self
:
:
Explicit
(
types
)
=
>
types
.
next
(
)
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
match
self
{
Self
:
:
Implicit
(
None
)
=
>
(
0
Some
(
0
)
)
Self
:
:
Implicit
(
Some
(
_
)
)
=
>
(
1
Some
(
1
)
)
Self
:
:
Explicit
(
types
)
=
>
types
.
size_hint
(
)
}
}
}
impl
ExactSizeIterator
for
Iter
{
}
}
}
impl
Hash
for
RecGroup
{
fn
hash
<
H
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
let
types
=
self
.
types
(
)
;
types
.
len
(
)
.
hash
(
hasher
)
;
for
ty
in
types
{
ty
.
hash
(
hasher
)
;
}
}
}
impl
PartialEq
for
RecGroup
{
fn
eq
(
&
self
other
:
&
RecGroup
)
-
>
bool
{
let
self_tys
=
self
.
types
(
)
;
let
other_tys
=
other
.
types
(
)
;
self_tys
.
len
(
)
=
=
other_tys
.
len
(
)
&
&
self_tys
.
zip
(
other_tys
)
.
all
(
|
(
a
b
)
|
a
=
=
b
)
}
}
impl
Eq
for
RecGroup
{
}
impl
Ord
for
RecGroup
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
let
self_tys
=
self
.
types
(
)
;
let
other_tys
=
other
.
types
(
)
;
self_tys
.
cmp
(
other_tys
)
}
}
impl
PartialOrd
for
RecGroup
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
core
:
:
cmp
:
:
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
#
[
derive
(
Debug
Clone
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
SubType
{
pub
is_final
:
bool
pub
supertype_idx
:
Option
<
PackedIndex
>
pub
composite_type
:
CompositeType
}
impl
fmt
:
:
Display
for
SubType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
if
self
.
is_final
&
&
self
.
supertype_idx
.
is_none
(
)
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
composite_type
f
)
}
else
{
write
!
(
f
"
(
sub
"
)
?
;
if
self
.
is_final
{
write
!
(
f
"
final
"
)
?
;
}
if
let
Some
(
idx
)
=
self
.
supertype_idx
{
write
!
(
f
"
{
idx
}
"
)
?
;
}
fmt
:
:
Display
:
:
fmt
(
&
self
.
composite_type
f
)
?
;
write
!
(
f
"
)
"
)
}
}
}
impl
SubType
{
pub
fn
unwrap_array
(
&
self
)
-
>
&
ArrayType
{
self
.
composite_type
.
unwrap_array
(
)
}
pub
fn
func
(
signature
:
FuncType
shared
:
bool
)
-
>
Self
{
Self
{
is_final
:
true
supertype_idx
:
None
composite_type
:
CompositeType
{
inner
:
CompositeInnerType
:
:
Func
(
signature
)
shared
}
}
}
pub
fn
unwrap_func
(
&
self
)
-
>
&
FuncType
{
self
.
composite_type
.
unwrap_func
(
)
}
pub
fn
unwrap_struct
(
&
self
)
-
>
&
StructType
{
self
.
composite_type
.
unwrap_struct
(
)
}
pub
fn
unwrap_cont
(
&
self
)
-
>
&
ContType
{
self
.
composite_type
.
unwrap_cont
(
)
}
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
(
crate
)
fn
remap_indices
(
&
mut
self
f
:
&
mut
dyn
FnMut
(
&
mut
PackedIndex
)
-
>
Result
<
(
)
>
)
-
>
Result
<
(
)
>
{
if
let
Some
(
idx
)
=
&
mut
self
.
supertype_idx
{
f
(
idx
)
?
;
}
match
&
mut
self
.
composite_type
.
inner
{
CompositeInnerType
:
:
Func
(
ty
)
=
>
{
for
ty
in
ty
.
params_mut
(
)
{
ty
.
remap_indices
(
f
)
?
;
}
for
ty
in
ty
.
results_mut
(
)
{
ty
.
remap_indices
(
f
)
?
;
}
}
CompositeInnerType
:
:
Array
(
ty
)
=
>
{
ty
.
0
.
remap_indices
(
f
)
?
;
}
CompositeInnerType
:
:
Struct
(
ty
)
=
>
{
for
field
in
ty
.
fields
.
iter_mut
(
)
{
field
.
remap_indices
(
f
)
?
;
}
}
CompositeInnerType
:
:
Cont
(
ty
)
=
>
{
ty
.
remap_indices
(
f
)
?
;
}
}
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
Clone
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
CompositeType
{
pub
inner
:
CompositeInnerType
pub
shared
:
bool
}
#
[
derive
(
Debug
Clone
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
enum
CompositeInnerType
{
Func
(
FuncType
)
Array
(
ArrayType
)
Struct
(
StructType
)
Cont
(
ContType
)
}
impl
fmt
:
:
Display
for
CompositeType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
use
CompositeInnerType
:
:
*
;
if
self
.
shared
{
write
!
(
f
"
(
shared
"
)
?
;
}
match
self
.
inner
{
Array
(
_
)
=
>
write
!
(
f
"
(
array
.
.
.
)
"
)
Func
(
_
)
=
>
write
!
(
f
"
(
func
.
.
.
)
"
)
Struct
(
_
)
=
>
write
!
(
f
"
(
struct
.
.
.
)
"
)
Cont
(
_
)
=
>
write
!
(
f
"
(
cont
.
.
.
)
"
)
}
?
;
if
self
.
shared
{
write
!
(
f
"
)
"
)
?
;
}
Ok
(
(
)
)
}
}
impl
CompositeType
{
pub
fn
unwrap_func
(
&
self
)
-
>
&
FuncType
{
match
&
self
.
inner
{
CompositeInnerType
:
:
Func
(
f
)
=
>
f
_
=
>
panic
!
(
"
not
a
func
"
)
}
}
pub
fn
unwrap_array
(
&
self
)
-
>
&
ArrayType
{
match
&
self
.
inner
{
CompositeInnerType
:
:
Array
(
a
)
=
>
a
_
=
>
panic
!
(
"
not
a
array
"
)
}
}
pub
fn
unwrap_struct
(
&
self
)
-
>
&
StructType
{
match
&
self
.
inner
{
CompositeInnerType
:
:
Struct
(
s
)
=
>
s
_
=
>
panic
!
(
"
not
a
struct
"
)
}
}
pub
fn
unwrap_cont
(
&
self
)
-
>
&
ContType
{
match
&
self
.
inner
{
CompositeInnerType
:
:
Cont
(
c
)
=
>
c
_
=
>
panic
!
(
"
not
a
cont
"
)
}
}
}
#
[
derive
(
Clone
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
pub
struct
FuncType
{
params_results
:
Box
<
[
ValType
]
>
len_params
:
usize
}
impl
fmt
:
:
Debug
for
FuncType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
FuncType
"
)
.
field
(
"
params
"
&
self
.
params
(
)
)
.
field
(
"
results
"
&
self
.
results
(
)
)
.
finish
(
)
}
}
impl
FuncType
{
pub
fn
new
<
P
R
>
(
params
:
P
results
:
R
)
-
>
Self
where
P
:
IntoIterator
<
Item
=
ValType
>
R
:
IntoIterator
<
Item
=
ValType
>
{
let
mut
buffer
=
params
.
into_iter
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
len_params
=
buffer
.
len
(
)
;
buffer
.
extend
(
results
)
;
Self
{
params_results
:
buffer
.
into
(
)
len_params
}
}
pub
(
crate
)
fn
from_raw_parts
(
params_results
:
Box
<
[
ValType
]
>
len_params
:
usize
)
-
>
Self
{
assert
!
(
len_params
<
=
params_results
.
len
(
)
)
;
Self
{
params_results
len_params
}
}
#
[
inline
]
pub
fn
params
(
&
self
)
-
>
&
[
ValType
]
{
&
self
.
params_results
[
.
.
self
.
len_params
]
}
#
[
inline
]
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
(
crate
)
fn
params_mut
(
&
mut
self
)
-
>
&
mut
[
ValType
]
{
&
mut
self
.
params_results
[
.
.
self
.
len_params
]
}
#
[
inline
]
pub
fn
results
(
&
self
)
-
>
&
[
ValType
]
{
&
self
.
params_results
[
self
.
len_params
.
.
]
}
#
[
inline
]
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
(
crate
)
fn
results_mut
(
&
mut
self
)
-
>
&
mut
[
ValType
]
{
&
mut
self
.
params_results
[
self
.
len_params
.
.
]
}
#
[
cfg
(
all
(
feature
=
"
validate
"
feature
=
"
component
-
model
"
)
)
]
pub
(
crate
)
fn
desc
(
&
self
)
-
>
String
{
use
core
:
:
fmt
:
:
Write
;
let
mut
s
=
String
:
:
new
(
)
;
s
.
push_str
(
"
[
"
)
;
for
(
i
param
)
in
self
.
params
(
)
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
s
.
push_str
(
"
"
)
;
}
write
!
(
s
"
{
param
}
"
)
.
unwrap
(
)
;
}
s
.
push_str
(
"
]
-
>
[
"
)
;
for
(
i
result
)
in
self
.
results
(
)
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
s
.
push_str
(
"
"
)
;
}
write
!
(
s
"
{
result
}
"
)
.
unwrap
(
)
;
}
s
.
push_str
(
"
]
"
)
;
s
}
}
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
pub
struct
ArrayType
(
pub
FieldType
)
;
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
pub
struct
FieldType
{
pub
element_type
:
StorageType
pub
mutable
:
bool
}
impl
FieldType
{
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
(
crate
)
fn
remap_indices
(
&
mut
self
f
:
&
mut
dyn
FnMut
(
&
mut
PackedIndex
)
-
>
Result
<
(
)
>
)
-
>
Result
<
(
)
>
{
match
&
mut
self
.
element_type
{
StorageType
:
:
I8
|
StorageType
:
:
I16
=
>
Ok
(
(
)
)
StorageType
:
:
Val
(
ty
)
=
>
ty
.
remap_indices
(
f
)
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
enum
StorageType
{
I8
I16
Val
(
ValType
)
}
impl
fmt
:
:
Display
for
StorageType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
Self
:
:
I8
=
>
write
!
(
f
"
i8
"
)
Self
:
:
I16
=
>
write
!
(
f
"
i16
"
)
Self
:
:
Val
(
v
)
=
>
fmt
:
:
Display
:
:
fmt
(
v
f
)
}
}
}
impl
StorageType
{
pub
fn
is_packed
(
&
self
)
-
>
bool
{
match
self
{
Self
:
:
I8
|
Self
:
:
I16
=
>
true
Self
:
:
Val
(
_
)
=
>
false
}
}
pub
fn
unpack
(
&
self
)
-
>
ValType
{
match
*
self
{
Self
:
:
Val
(
ty
)
=
>
ty
Self
:
:
I8
|
Self
:
:
I16
=
>
ValType
:
:
I32
}
}
}
#
[
derive
(
Debug
Clone
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
pub
struct
StructType
{
pub
fields
:
Box
<
[
FieldType
]
>
}
#
[
derive
(
Debug
Clone
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
pub
struct
ContType
(
pub
PackedIndex
)
;
impl
ContType
{
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
(
crate
)
fn
remap_indices
(
&
mut
self
map
:
&
mut
dyn
FnMut
(
&
mut
PackedIndex
)
-
>
Result
<
(
)
>
)
-
>
Result
<
(
)
>
{
map
(
&
mut
self
.
0
)
?
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
enum
ValType
{
I32
I64
F32
F64
V128
Ref
(
RefType
)
}
impl
From
<
RefType
>
for
ValType
{
#
[
inline
]
fn
from
(
ty
:
RefType
)
-
>
ValType
{
ValType
:
:
Ref
(
ty
)
}
}
impl
fmt
:
:
Display
for
ValType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
ValType
:
:
I32
=
>
f
.
write_str
(
"
i32
"
)
ValType
:
:
I64
=
>
f
.
write_str
(
"
i64
"
)
ValType
:
:
F32
=
>
f
.
write_str
(
"
f32
"
)
ValType
:
:
F64
=
>
f
.
write_str
(
"
f64
"
)
ValType
:
:
V128
=
>
f
.
write_str
(
"
v128
"
)
ValType
:
:
Ref
(
r
)
=
>
fmt
:
:
Display
:
:
fmt
(
r
f
)
}
}
}
impl
ValType
{
pub
const
FUNCREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
FUNCREF
)
;
pub
const
EXTERNREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
EXTERNREF
)
;
pub
const
EXNREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
EXNREF
)
;
pub
const
CONTREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
CONTREF
)
;
pub
fn
is_reference_type
(
&
self
)
-
>
bool
{
matches
!
(
self
ValType
:
:
Ref
(
_
)
)
}
pub
fn
as_reference_type
(
&
self
)
-
>
Option
<
RefType
>
{
match
*
self
{
ValType
:
:
Ref
(
r
)
=
>
Some
(
r
)
ValType
:
:
I32
|
ValType
:
:
I64
|
ValType
:
:
F32
|
ValType
:
:
F64
|
ValType
:
:
V128
=
>
None
}
}
pub
fn
is_defaultable
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
I32
|
Self
:
:
I64
|
Self
:
:
F32
|
Self
:
:
F64
|
Self
:
:
V128
=
>
true
Self
:
:
Ref
(
rt
)
=
>
rt
.
is_nullable
(
)
}
}
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
(
crate
)
fn
remap_indices
(
&
mut
self
map
:
&
mut
dyn
FnMut
(
&
mut
PackedIndex
)
-
>
Result
<
(
)
>
)
-
>
Result
<
(
)
>
{
match
self
{
ValType
:
:
Ref
(
r
)
=
>
{
if
let
Some
(
mut
idx
)
=
r
.
type_index
(
)
{
map
(
&
mut
idx
)
?
;
*
r
=
RefType
:
:
concrete
(
r
.
is_nullable
(
)
idx
)
;
}
}
ValType
:
:
I32
|
ValType
:
:
I64
|
ValType
:
:
F32
|
ValType
:
:
F64
|
ValType
:
:
V128
=
>
{
}
}
Ok
(
(
)
)
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
RefType
(
[
u8
;
3
]
)
;
impl
fmt
:
:
Debug
for
RefType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
heap_type
=
self
.
heap_type
(
)
;
match
heap_type
{
HeapType
:
:
Abstract
{
shared
ty
}
=
>
{
let
nullable
=
self
.
is_nullable
(
)
;
let
name
=
ty
.
as_str
(
nullable
)
;
match
(
nullable
shared
)
{
(
true
true
)
=
>
write
!
(
f
"
(
shared
{
}
ref
)
"
name
)
(
true
false
)
=
>
write
!
(
f
"
{
}
ref
"
name
)
(
false
true
)
=
>
write
!
(
f
"
(
ref
(
shared
{
}
)
)
"
name
)
(
false
false
)
=
>
write
!
(
f
"
(
ref
{
}
)
"
name
)
}
}
HeapType
:
:
Concrete
(
index
)
=
>
{
if
self
.
is_nullable
(
)
{
write
!
(
f
"
(
ref
null
{
}
)
"
index
)
}
else
{
write
!
(
f
"
(
ref
{
}
)
"
index
)
}
}
}
}
}
impl
fmt
:
:
Display
for
RefType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
#
[
test
]
fn
can_fit_max_wasm_types_in_ref_type
(
)
{
fn
can_roundtrip_index
(
index
:
u32
)
-
>
bool
{
assert
!
(
RefType
:
:
can_represent_type_index
(
index
)
)
;
let
rt
=
RefType
:
:
concrete
(
true
PackedIndex
:
:
from_module_index
(
index
)
.
unwrap
(
)
)
;
assert
!
(
rt
.
is_nullable
(
)
)
;
let
actual_index
=
match
rt
.
type_index
(
)
{
Some
(
i
)
=
>
i
None
=
>
panic
!
(
)
}
;
actual_index
.
as_module_index
(
)
=
=
Some
(
index
)
}
assert
!
(
can_roundtrip_index
(
crate
:
:
limits
:
:
MAX_WASM_TYPES
as
u32
)
)
;
assert
!
(
can_roundtrip_index
(
0b00000000_00001111_00000000_00000000
)
)
;
assert
!
(
can_roundtrip_index
(
0b00000000_00000000_11111111_00000000
)
)
;
assert
!
(
can_roundtrip_index
(
0b00000000_00000000_00000000_11111111
)
)
;
assert
!
(
can_roundtrip_index
(
0
)
)
;
}
impl
RefType
{
const
NULLABLE_BIT
:
u32
=
1
<
<
23
;
const
CONCRETE_BIT
:
u32
=
1
<
<
22
;
const
SHARED_BIT
:
u32
=
1
<
<
21
;
const
ABSTYPE_MASK
:
u32
=
0b1111
<
<
17
;
const
ANY_ABSTYPE
:
u32
=
0b1111
<
<
17
;
const
EQ_ABSTYPE
:
u32
=
0b1101
<
<
17
;
const
I31_ABSTYPE
:
u32
=
0b1000
<
<
17
;
const
STRUCT_ABSTYPE
:
u32
=
0b1001
<
<
17
;
const
ARRAY_ABSTYPE
:
u32
=
0b1100
<
<
17
;
const
FUNC_ABSTYPE
:
u32
=
0b0101
<
<
17
;
const
NOFUNC_ABSTYPE
:
u32
=
0b0100
<
<
17
;
const
EXTERN_ABSTYPE
:
u32
=
0b0011
<
<
17
;
const
NOEXTERN_ABSTYPE
:
u32
=
0b0010
<
<
17
;
const
EXN_ABSTYPE
:
u32
=
0b0001
<
<
17
;
const
NOEXN_ABSTYPE
:
u32
=
0b1110
<
<
17
;
const
NONE_ABSTYPE
:
u32
=
0b0000
<
<
17
;
const
CONT_ABSTYPE
:
u32
=
0b0111
<
<
17
;
const
NOCONT_ABSTYPE
:
u32
=
0b0110
<
<
17
;
const
INDEX_MASK
:
u32
=
(
1
<
<
22
)
-
1
;
pub
const
FUNCREF
:
Self
=
RefType
:
:
FUNC
.
nullable
(
)
;
pub
const
EXTERNREF
:
Self
=
RefType
:
:
EXTERN
.
nullable
(
)
;
pub
const
ANYREF
:
Self
=
RefType
:
:
ANY
.
nullable
(
)
;
pub
const
NULLREF
:
Self
=
RefType
:
:
NONE
.
nullable
(
)
;
pub
const
NULLEXTERNREF
:
Self
=
RefType
:
:
NOEXTERN
.
nullable
(
)
;
pub
const
NULLFUNCREF
:
Self
=
RefType
:
:
NOFUNC
.
nullable
(
)
;
pub
const
EQREF
:
Self
=
RefType
:
:
EQ
.
nullable
(
)
;
pub
const
STRUCTREF
:
Self
=
RefType
:
:
STRUCT
.
nullable
(
)
;
pub
const
ARRAYREF
:
Self
=
RefType
:
:
ARRAY
.
nullable
(
)
;
pub
const
I31REF
:
Self
=
RefType
:
:
I31
.
nullable
(
)
;
pub
const
EXNREF
:
Self
=
RefType
:
:
EXN
.
nullable
(
)
;
pub
const
NULLEXNREF
:
Self
=
RefType
:
:
NOEXN
.
nullable
(
)
;
pub
const
CONTREF
:
Self
=
RefType
:
:
CONT
.
nullable
(
)
;
pub
const
NULLCONTREF
:
Self
=
RefType
:
:
NOCONT
.
nullable
(
)
;
pub
const
FUNC
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
FUNC_ABSTYPE
)
;
pub
const
EXTERN
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
EXTERN_ABSTYPE
)
;
pub
const
ANY
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
ANY_ABSTYPE
)
;
pub
const
NONE
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
NONE_ABSTYPE
)
;
pub
const
NOEXTERN
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
NOEXTERN_ABSTYPE
)
;
pub
const
NOFUNC
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
NOFUNC_ABSTYPE
)
;
pub
const
EQ
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
EQ_ABSTYPE
)
;
pub
const
STRUCT
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
STRUCT_ABSTYPE
)
;
pub
const
ARRAY
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
ARRAY_ABSTYPE
)
;
pub
const
I31
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
I31_ABSTYPE
)
;
pub
const
EXN
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
EXN_ABSTYPE
)
;
pub
const
NOEXN
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
NOEXN_ABSTYPE
)
;
pub
const
CONT
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
CONT_ABSTYPE
)
;
pub
const
NOCONT
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
NOCONT_ABSTYPE
)
;
const
fn
can_represent_type_index
(
index
:
u32
)
-
>
bool
{
index
&
Self
:
:
INDEX_MASK
=
=
index
}
const
fn
u24_to_u32
(
bytes
:
[
u8
;
3
]
)
-
>
u32
{
let
expanded_bytes
=
[
bytes
[
0
]
bytes
[
1
]
bytes
[
2
]
0
]
;
u32
:
:
from_le_bytes
(
expanded_bytes
)
}
const
fn
u32_to_u24
(
x
:
u32
)
-
>
[
u8
;
3
]
{
let
bytes
=
x
.
to_le_bytes
(
)
;
debug_assert
!
(
bytes
[
3
]
=
=
0
)
;
[
bytes
[
0
]
bytes
[
1
]
bytes
[
2
]
]
}
#
[
inline
]
const
fn
as_u32
(
&
self
)
-
>
u32
{
Self
:
:
u24_to_u32
(
self
.
0
)
}
#
[
inline
]
const
fn
from_u32
(
x
:
u32
)
-
>
Self
{
debug_assert
!
(
x
&
(
0b11111111
<
<
24
)
=
=
0
)
;
debug_assert
!
(
x
&
Self
:
:
CONCRETE_BIT
!
=
0
|
|
matches
!
(
x
&
Self
:
:
ABSTYPE_MASK
Self
:
:
ANY_ABSTYPE
|
Self
:
:
EQ_ABSTYPE
|
Self
:
:
I31_ABSTYPE
|
Self
:
:
STRUCT_ABSTYPE
|
Self
:
:
ARRAY_ABSTYPE
|
Self
:
:
FUNC_ABSTYPE
|
Self
:
:
NOFUNC_ABSTYPE
|
Self
:
:
EXTERN_ABSTYPE
|
Self
:
:
NOEXTERN_ABSTYPE
|
Self
:
:
NONE_ABSTYPE
|
Self
:
:
EXN_ABSTYPE
|
Self
:
:
NOEXN_ABSTYPE
|
Self
:
:
CONT_ABSTYPE
|
Self
:
:
NOCONT_ABSTYPE
)
)
;
RefType
(
Self
:
:
u32_to_u24
(
x
)
)
}
pub
fn
concrete
(
nullable
:
bool
index
:
PackedIndex
)
-
>
Self
{
let
index
:
u32
=
PackedIndex
:
:
to_u32
(
index
)
;
debug_assert
!
(
Self
:
:
can_represent_type_index
(
index
)
)
;
let
nullable32
=
Self
:
:
NULLABLE_BIT
*
nullable
as
u32
;
RefType
:
:
from_u32
(
nullable32
|
Self
:
:
CONCRETE_BIT
|
index
)
}
pub
fn
new
(
nullable
:
bool
heap_type
:
HeapType
)
-
>
Option
<
Self
>
{
let
base32
=
Self
:
:
NULLABLE_BIT
*
(
nullable
as
u32
)
;
match
heap_type
{
HeapType
:
:
Concrete
(
index
)
=
>
Some
(
RefType
:
:
concrete
(
nullable
index
.
pack
(
)
?
)
)
HeapType
:
:
Abstract
{
shared
ty
}
=
>
{
use
AbstractHeapType
:
:
*
;
let
base32
=
base32
|
(
Self
:
:
SHARED_BIT
*
(
shared
as
u32
)
)
;
match
ty
{
Func
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
FUNC_ABSTYPE
)
)
Extern
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
EXTERN_ABSTYPE
)
)
Any
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
ANY_ABSTYPE
)
)
None
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
NONE_ABSTYPE
)
)
NoExtern
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
NOEXTERN_ABSTYPE
)
)
NoFunc
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
NOFUNC_ABSTYPE
)
)
Eq
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
EQ_ABSTYPE
)
)
Struct
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
STRUCT_ABSTYPE
)
)
Array
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
ARRAY_ABSTYPE
)
)
I31
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
I31_ABSTYPE
)
)
Exn
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
EXN_ABSTYPE
)
)
NoExn
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
NOEXN_ABSTYPE
)
)
Cont
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
CONT_ABSTYPE
)
)
NoCont
=
>
Some
(
Self
:
:
from_u32
(
base32
|
Self
:
:
NOCONT_ABSTYPE
)
)
}
}
}
}
pub
fn
difference
(
a
:
RefType
b
:
RefType
)
-
>
RefType
{
RefType
:
:
new
(
if
b
.
is_nullable
(
)
{
false
}
else
{
a
.
is_nullable
(
)
}
a
.
heap_type
(
)
)
.
unwrap
(
)
}
pub
const
fn
is_concrete_type_ref
(
&
self
)
-
>
bool
{
self
.
as_u32
(
)
&
Self
:
:
CONCRETE_BIT
!
=
0
}
pub
fn
type_index
(
&
self
)
-
>
Option
<
PackedIndex
>
{
if
self
.
is_concrete_type_ref
(
)
{
let
index
=
self
.
as_u32
(
)
&
Self
:
:
INDEX_MASK
;
Some
(
PackedIndex
:
:
unchecked_from_u32
(
index
)
)
}
else
{
None
}
}
const
fn
abstype
(
&
self
)
-
>
u32
{
debug_assert
!
(
!
self
.
is_concrete_type_ref
(
)
)
;
self
.
as_u32
(
)
&
Self
:
:
ABSTYPE_MASK
}
pub
const
fn
is_func_ref
(
&
self
)
-
>
bool
{
!
self
.
is_concrete_type_ref
(
)
&
&
self
.
abstype
(
)
=
=
Self
:
:
FUNC_ABSTYPE
}
pub
const
fn
is_extern_ref
(
&
self
)
-
>
bool
{
!
self
.
is_concrete_type_ref
(
)
&
&
self
.
abstype
(
)
=
=
Self
:
:
EXTERN_ABSTYPE
}
pub
const
fn
is_array_ref
(
&
self
)
-
>
bool
{
!
self
.
is_concrete_type_ref
(
)
&
&
self
.
abstype
(
)
=
=
Self
:
:
ARRAY_ABSTYPE
}
pub
const
fn
is_struct_ref
(
&
self
)
-
>
bool
{
!
self
.
is_concrete_type_ref
(
)
&
&
self
.
abstype
(
)
=
=
Self
:
:
STRUCT_ABSTYPE
}
pub
const
fn
is_cont_ref
(
&
self
)
-
>
bool
{
!
self
.
is_concrete_type_ref
(
)
&
&
self
.
abstype
(
)
=
=
Self
:
:
CONT_ABSTYPE
}
pub
const
fn
is_nullable
(
&
self
)
-
>
bool
{
self
.
as_u32
(
)
&
Self
:
:
NULLABLE_BIT
!
=
0
}
pub
const
fn
as_non_null
(
&
self
)
-
>
Self
{
Self
:
:
from_u32
(
self
.
as_u32
(
)
&
!
Self
:
:
NULLABLE_BIT
)
}
pub
const
fn
nullable
(
&
self
)
-
>
Self
{
Self
:
:
from_u32
(
self
.
as_u32
(
)
|
Self
:
:
NULLABLE_BIT
)
}
pub
const
fn
shared
(
&
self
)
-
>
Option
<
Self
>
{
if
self
.
is_concrete_type_ref
(
)
{
None
}
else
{
Some
(
Self
:
:
from_u32
(
self
.
as_u32
(
)
|
Self
:
:
SHARED_BIT
)
)
}
}
pub
fn
heap_type
(
&
self
)
-
>
HeapType
{
let
s
=
self
.
as_u32
(
)
;
if
self
.
is_concrete_type_ref
(
)
{
HeapType
:
:
Concrete
(
self
.
type_index
(
)
.
unwrap
(
)
.
unpack
(
)
)
}
else
{
use
AbstractHeapType
:
:
*
;
let
shared
=
s
&
Self
:
:
SHARED_BIT
!
=
0
;
let
ty
=
match
s
&
Self
:
:
ABSTYPE_MASK
{
Self
:
:
FUNC_ABSTYPE
=
>
Func
Self
:
:
EXTERN_ABSTYPE
=
>
Extern
Self
:
:
ANY_ABSTYPE
=
>
Any
Self
:
:
NONE_ABSTYPE
=
>
None
Self
:
:
NOEXTERN_ABSTYPE
=
>
NoExtern
Self
:
:
NOFUNC_ABSTYPE
=
>
NoFunc
Self
:
:
EQ_ABSTYPE
=
>
Eq
Self
:
:
STRUCT_ABSTYPE
=
>
Struct
Self
:
:
ARRAY_ABSTYPE
=
>
Array
Self
:
:
I31_ABSTYPE
=
>
I31
Self
:
:
EXN_ABSTYPE
=
>
Exn
Self
:
:
NOEXN_ABSTYPE
=
>
NoExn
Self
:
:
CONT_ABSTYPE
=
>
Cont
Self
:
:
NOCONT_ABSTYPE
=
>
NoCont
_
=
>
unreachable
!
(
)
}
;
HeapType
:
:
Abstract
{
shared
ty
}
}
}
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
(
crate
)
fn
wat
(
&
self
)
-
>
&
'
static
str
{
let
nullable
=
self
.
is_nullable
(
)
;
match
self
.
heap_type
(
)
{
HeapType
:
:
Abstract
{
shared
ty
}
=
>
{
use
AbstractHeapType
:
:
*
;
match
(
shared
nullable
ty
)
{
(
true
true
Func
)
=
>
"
(
shared
funcref
)
"
(
true
true
Extern
)
=
>
"
(
shared
externref
)
"
(
true
true
Any
)
=
>
"
(
shared
anyref
)
"
(
true
true
None
)
=
>
"
(
shared
nullref
)
"
(
true
true
NoExtern
)
=
>
"
(
shared
nullexternref
)
"
(
true
true
NoFunc
)
=
>
"
(
shared
nullfuncref
)
"
(
true
true
Eq
)
=
>
"
(
shared
eqref
)
"
(
true
true
Struct
)
=
>
"
(
shared
structref
)
"
(
true
true
Array
)
=
>
"
(
shared
arrayref
)
"
(
true
true
I31
)
=
>
"
(
shared
i31ref
)
"
(
true
true
Exn
)
=
>
"
(
shared
exnref
)
"
(
true
true
NoExn
)
=
>
"
(
shared
nullexnref
)
"
(
true
true
Cont
)
=
>
"
(
shared
contref
)
"
(
true
true
NoCont
)
=
>
"
(
shared
nullcontref
)
"
(
false
true
Func
)
=
>
"
funcref
"
(
false
true
Extern
)
=
>
"
externref
"
(
false
true
Any
)
=
>
"
anyref
"
(
false
true
None
)
=
>
"
nullref
"
(
false
true
NoExtern
)
=
>
"
nullexternref
"
(
false
true
NoFunc
)
=
>
"
nullfuncref
"
(
false
true
Eq
)
=
>
"
eqref
"
(
false
true
Struct
)
=
>
"
structref
"
(
false
true
Array
)
=
>
"
arrayref
"
(
false
true
I31
)
=
>
"
i31ref
"
(
false
true
Exn
)
=
>
"
exnref
"
(
false
true
NoExn
)
=
>
"
nullexnref
"
(
false
true
Cont
)
=
>
"
contref
"
(
false
true
NoCont
)
=
>
"
nullcontref
"
(
true
false
Func
)
=
>
"
(
ref
(
shared
func
)
)
"
(
true
false
Extern
)
=
>
"
(
ref
(
shared
extern
)
)
"
(
true
false
Any
)
=
>
"
(
ref
(
shared
any
)
)
"
(
true
false
None
)
=
>
"
(
ref
(
shared
none
)
)
"
(
true
false
NoExtern
)
=
>
"
(
ref
(
shared
noextern
)
)
"
(
true
false
NoFunc
)
=
>
"
(
ref
(
shared
nofunc
)
)
"
(
true
false
Eq
)
=
>
"
(
ref
(
shared
eq
)
)
"
(
true
false
Struct
)
=
>
"
(
ref
(
shared
struct
)
)
"
(
true
false
Array
)
=
>
"
(
ref
(
shared
array
)
)
"
(
true
false
I31
)
=
>
"
(
ref
(
shared
i31
)
)
"
(
true
false
Exn
)
=
>
"
(
ref
(
shared
exn
)
)
"
(
true
false
NoExn
)
=
>
"
(
ref
(
shared
noexn
)
)
"
(
true
false
Cont
)
=
>
"
(
ref
(
shared
cont
)
)
"
(
true
false
NoCont
)
=
>
"
(
ref
(
shared
nocont
)
)
"
(
false
false
Func
)
=
>
"
(
ref
func
)
"
(
false
false
Extern
)
=
>
"
(
ref
extern
)
"
(
false
false
Any
)
=
>
"
(
ref
any
)
"
(
false
false
None
)
=
>
"
(
ref
none
)
"
(
false
false
NoExtern
)
=
>
"
(
ref
noextern
)
"
(
false
false
NoFunc
)
=
>
"
(
ref
nofunc
)
"
(
false
false
Eq
)
=
>
"
(
ref
eq
)
"
(
false
false
Struct
)
=
>
"
(
ref
struct
)
"
(
false
false
Array
)
=
>
"
(
ref
array
)
"
(
false
false
I31
)
=
>
"
(
ref
i31
)
"
(
false
false
Exn
)
=
>
"
(
ref
exn
)
"
(
false
false
NoExn
)
=
>
"
(
ref
noexn
)
"
(
false
false
Cont
)
=
>
"
(
ref
cont
)
"
(
false
false
NoCont
)
=
>
"
(
ref
nocont
)
"
}
}
HeapType
:
:
Concrete
(
_
)
=
>
{
if
nullable
{
"
(
ref
null
type
)
"
}
else
{
"
(
ref
type
)
"
}
}
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
HeapType
{
Abstract
{
shared
:
bool
ty
:
AbstractHeapType
}
Concrete
(
UnpackedIndex
)
}
impl
HeapType
{
pub
const
FUNC
:
Self
=
Self
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
Func
}
;
pub
const
EXTERN
:
Self
=
Self
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
Extern
}
;
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
AbstractHeapType
{
Func
Extern
Any
None
NoExtern
NoFunc
Eq
Struct
Array
I31
Exn
NoExn
Cont
NoCont
}
impl
AbstractHeapType
{
pub
(
crate
)
const
fn
as_str
(
&
self
nullable
:
bool
)
-
>
&
str
{
use
AbstractHeapType
:
:
*
;
match
(
nullable
self
)
{
(
_
Any
)
=
>
"
any
"
(
true
None
)
=
>
"
null
"
(
false
None
)
=
>
"
none
"
(
true
NoExtern
)
=
>
"
nullextern
"
(
false
NoExtern
)
=
>
"
noextern
"
(
true
NoFunc
)
=
>
"
nullfunc
"
(
false
NoFunc
)
=
>
"
nofunc
"
(
_
Eq
)
=
>
"
eq
"
(
_
Struct
)
=
>
"
struct
"
(
_
Array
)
=
>
"
array
"
(
_
I31
)
=
>
"
i31
"
(
_
Extern
)
=
>
"
extern
"
(
_
Func
)
=
>
"
func
"
(
_
Exn
)
=
>
"
exn
"
(
true
NoExn
)
=
>
"
nullexn
"
(
false
NoExn
)
=
>
"
noexn
"
(
_
Cont
)
=
>
"
cont
"
(
true
NoCont
)
=
>
"
nullcont
"
(
false
NoCont
)
=
>
"
nocont
"
}
}
#
[
cfg
(
feature
=
"
validate
"
)
]
pub
(
crate
)
fn
is_subtype_of
(
&
self
other
:
AbstractHeapType
)
-
>
bool
{
use
AbstractHeapType
:
:
*
;
match
(
self
other
)
{
(
a
b
)
if
*
a
=
=
b
=
>
true
(
Eq
|
I31
|
Struct
|
Array
|
None
Any
)
=
>
true
(
I31
|
Struct
|
Array
|
None
Eq
)
=
>
true
(
NoExtern
Extern
)
=
>
true
(
NoFunc
Func
)
=
>
true
(
None
I31
|
Array
|
Struct
)
=
>
true
(
NoExn
Exn
)
=
>
true
(
NoCont
Cont
)
=
>
true
(
Func
|
Extern
|
Exn
|
Any
|
Eq
|
Array
|
I31
|
Struct
|
Cont
|
None
|
NoFunc
|
NoExtern
|
NoExn
|
NoCont
_
)
=
>
false
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
StorageType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
match
reader
.
peek
(
)
?
{
0x78
=
>
{
reader
.
read_u8
(
)
?
;
Ok
(
StorageType
:
:
I8
)
}
0x77
=
>
{
reader
.
read_u8
(
)
?
;
Ok
(
StorageType
:
:
I16
)
}
_
=
>
Ok
(
StorageType
:
:
Val
(
reader
.
read
(
)
?
)
)
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
ValType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
match
reader
.
peek
(
)
?
{
0x7F
=
>
{
reader
.
read_u8
(
)
?
;
Ok
(
ValType
:
:
I32
)
}
0x7E
=
>
{
reader
.
read_u8
(
)
?
;
Ok
(
ValType
:
:
I64
)
}
0x7D
=
>
{
reader
.
read_u8
(
)
?
;
Ok
(
ValType
:
:
F32
)
}
0x7C
=
>
{
reader
.
read_u8
(
)
?
;
Ok
(
ValType
:
:
F64
)
}
0x7B
=
>
{
reader
.
read_u8
(
)
?
;
Ok
(
ValType
:
:
V128
)
}
_
=
>
{
let
refty
=
reader
.
read
(
)
.
map_err
(
|
mut
e
|
{
if
let
BinaryReaderErrorKind
:
:
Invalid
=
e
.
kind
(
)
{
e
.
set_message
(
"
invalid
value
type
"
)
;
}
e
}
)
?
;
Ok
(
ValType
:
:
Ref
(
refty
)
)
}
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
RefType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
pos
=
reader
.
original_position
(
)
;
match
reader
.
peek
(
)
?
{
0x63
|
0x64
=
>
{
let
nullable
=
reader
.
read_u8
(
)
?
=
=
0x63
;
RefType
:
:
new
(
nullable
reader
.
read
(
)
?
)
.
ok_or_else
(
|
|
crate
:
:
BinaryReaderError
:
:
new
(
"
type
index
too
large
"
pos
)
)
}
_
=
>
{
let
hty
=
reader
.
read
(
)
.
map_err
(
|
mut
e
|
{
if
let
BinaryReaderErrorKind
:
:
Invalid
=
e
.
kind
(
)
{
e
.
set_message
(
"
malformed
reference
type
"
)
;
}
e
}
)
?
;
RefType
:
:
new
(
true
hty
)
.
ok_or_else
(
|
|
crate
:
:
BinaryReaderError
:
:
new
(
"
type
index
too
large
"
pos
)
)
}
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
HeapType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
mut
clone
=
reader
.
clone
(
)
;
let
s33
=
clone
.
read_var_s33
(
)
?
;
match
u32
:
:
try_from
(
s33
)
{
Ok
(
idx
)
=
>
{
*
reader
=
clone
;
let
idx
=
PackedIndex
:
:
from_module_index
(
idx
)
.
ok_or_else
(
|
|
{
BinaryReaderError
:
:
new
(
"
type
index
greater
than
implementation
limits
"
reader
.
original_position
(
)
)
}
)
?
;
Ok
(
HeapType
:
:
Concrete
(
idx
.
unpack
(
)
)
)
}
Err
(
_
)
=
>
match
reader
.
peek
(
)
?
{
0x65
=
>
{
reader
.
read_u8
(
)
?
;
let
ty
=
reader
.
read
(
)
?
;
Ok
(
HeapType
:
:
Abstract
{
shared
:
true
ty
}
)
}
_
=
>
{
let
ty
=
reader
.
read
(
)
.
map_err
(
|
mut
e
|
{
if
let
BinaryReaderErrorKind
:
:
Invalid
=
e
.
kind
(
)
{
e
.
set_message
(
"
invalid
heap
type
"
)
;
}
e
}
)
?
;
Ok
(
HeapType
:
:
Abstract
{
shared
:
false
ty
}
)
}
}
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
AbstractHeapType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
use
AbstractHeapType
:
:
*
;
match
reader
.
read_u8
(
)
?
{
0x70
=
>
Ok
(
Func
)
0x6F
=
>
Ok
(
Extern
)
0x6E
=
>
Ok
(
Any
)
0x71
=
>
Ok
(
None
)
0x72
=
>
Ok
(
NoExtern
)
0x73
=
>
Ok
(
NoFunc
)
0x6D
=
>
Ok
(
Eq
)
0x6B
=
>
Ok
(
Struct
)
0x6A
=
>
Ok
(
Array
)
0x6C
=
>
Ok
(
I31
)
0x69
=
>
Ok
(
Exn
)
0x74
=
>
Ok
(
NoExn
)
0x68
=
>
Ok
(
Cont
)
0x75
=
>
Ok
(
NoCont
)
_
=
>
{
return
Err
(
BinaryReaderError
:
:
invalid
(
"
invalid
abstract
heap
type
"
reader
.
original_position
(
)
-
1
)
)
}
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
TableType
{
pub
element_type
:
RefType
pub
table64
:
bool
pub
initial
:
u64
pub
maximum
:
Option
<
u64
>
pub
shared
:
bool
}
impl
TableType
{
pub
fn
index_type
(
&
self
)
-
>
ValType
{
if
self
.
table64
{
ValType
:
:
I64
}
else
{
ValType
:
:
I32
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
MemoryType
{
pub
memory64
:
bool
pub
shared
:
bool
pub
initial
:
u64
pub
maximum
:
Option
<
u64
>
pub
page_size_log2
:
Option
<
u32
>
}
impl
MemoryType
{
pub
fn
index_type
(
&
self
)
-
>
ValType
{
if
self
.
memory64
{
ValType
:
:
I64
}
else
{
ValType
:
:
I32
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
GlobalType
{
pub
content_type
:
ValType
pub
mutable
:
bool
pub
shared
:
bool
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
TagKind
{
Exception
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
struct
TagType
{
pub
kind
:
TagKind
pub
func_type_idx
:
u32
}
pub
type
TypeSectionReader
<
'
a
>
=
SectionLimited
<
'
a
RecGroup
>
;
impl
<
'
a
>
TypeSectionReader
<
'
a
>
{
pub
fn
into_iter_err_on_gc_types
(
self
)
-
>
impl
Iterator
<
Item
=
Result
<
FuncType
>
>
+
'
a
{
self
.
into_iter_with_offsets
(
)
.
map
(
|
item
|
{
let
(
offset
group
)
=
item
?
;
let
mut
types
=
group
.
into_types
(
)
;
let
ty
=
match
(
types
.
next
(
)
types
.
next
(
)
)
{
(
Some
(
ty
)
None
)
=
>
ty
_
=
>
bail
!
(
offset
"
gc
proposal
not
supported
"
)
}
;
if
!
ty
.
is_final
|
|
ty
.
supertype_idx
.
is_some
(
)
{
bail
!
(
offset
"
gc
proposal
not
supported
"
)
;
}
match
ty
.
composite_type
.
inner
{
CompositeInnerType
:
:
Func
(
f
)
=
>
Ok
(
f
)
CompositeInnerType
:
:
Array
(
_
)
|
CompositeInnerType
:
:
Struct
(
_
)
=
>
{
bail
!
(
offset
"
gc
proposal
not
supported
"
)
;
}
CompositeInnerType
:
:
Cont
(
_
)
=
>
{
bail
!
(
offset
"
stack
switching
proposal
not
supported
"
)
;
}
}
}
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
CompositeType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
read_composite_type
(
reader
.
read_u8
(
)
?
reader
)
}
}
fn
read_composite_type
(
opcode
:
u8
reader
:
&
mut
BinaryReader
)
-
>
Result
<
CompositeType
BinaryReaderError
>
{
let
(
shared
opcode
)
=
if
opcode
=
=
0x65
{
(
true
reader
.
read_u8
(
)
?
)
}
else
{
(
false
opcode
)
}
;
let
inner
=
match
opcode
{
0x60
=
>
CompositeInnerType
:
:
Func
(
reader
.
read
(
)
?
)
0x5e
=
>
CompositeInnerType
:
:
Array
(
reader
.
read
(
)
?
)
0x5f
=
>
CompositeInnerType
:
:
Struct
(
reader
.
read
(
)
?
)
0x5d
=
>
CompositeInnerType
:
:
Cont
(
reader
.
read
(
)
?
)
x
=
>
return
reader
.
invalid_leading_byte
(
x
"
type
"
)
}
;
Ok
(
CompositeType
{
shared
inner
}
)
}
impl
<
'
a
>
FromReader
<
'
a
>
for
RecGroup
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
match
reader
.
peek
(
)
?
{
0x4e
=
>
{
reader
.
read_u8
(
)
?
;
let
mut
iter
=
reader
.
read_iter
(
MAX_WASM_TYPES
"
rec
group
types
"
)
?
;
let
mut
types
=
Vec
:
:
with_capacity
(
iter
.
size_hint
(
)
.
0
)
;
let
mut
offset
=
iter
.
reader
.
original_position
(
)
;
while
let
Some
(
ty
)
=
iter
.
next
(
)
{
types
.
push
(
(
offset
ty
?
)
)
;
offset
=
iter
.
reader
.
original_position
(
)
;
}
Ok
(
RecGroup
:
:
explicit
(
types
)
)
}
_
=
>
Ok
(
RecGroup
:
:
implicit
(
reader
.
original_position
(
)
reader
.
read
(
)
?
)
)
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
SubType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
pos
=
reader
.
original_position
(
)
;
Ok
(
match
reader
.
read_u8
(
)
?
{
opcode
(
0x4f
|
0x50
)
=
>
{
let
idx_iter
=
reader
.
read_iter
(
MAX_WASM_SUPERTYPES
"
supertype
idxs
"
)
?
;
let
idxs
=
idx_iter
.
collect
:
:
<
Result
<
Vec
<
u32
>
>
>
(
)
?
;
if
idxs
.
len
(
)
>
1
{
return
Err
(
BinaryReaderError
:
:
new
(
"
multiple
supertypes
not
supported
"
pos
)
)
;
}
let
supertype_idx
=
idxs
.
first
(
)
.
copied
(
)
.
map
(
|
idx
|
{
PackedIndex
:
:
from_module_index
(
idx
)
.
ok_or_else
(
|
|
{
BinaryReaderError
:
:
new
(
"
type
index
greater
than
implementation
limits
"
reader
.
original_position
(
)
)
}
)
}
)
.
transpose
(
)
?
;
SubType
{
is_final
:
opcode
=
=
0x4f
supertype_idx
composite_type
:
read_composite_type
(
reader
.
read_u8
(
)
?
reader
)
?
}
}
opcode
=
>
SubType
{
is_final
:
true
supertype_idx
:
None
composite_type
:
read_composite_type
(
opcode
reader
)
?
}
}
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
FuncType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
mut
params_results
=
reader
.
read_iter
(
MAX_WASM_FUNCTION_PARAMS
"
function
params
"
)
?
.
collect
:
:
<
Result
<
Vec
<
_
>
>
>
(
)
?
;
let
len_params
=
params_results
.
len
(
)
;
let
results
=
reader
.
read_iter
(
MAX_WASM_FUNCTION_RETURNS
"
function
returns
"
)
?
;
params_results
.
reserve
(
results
.
size_hint
(
)
.
0
)
;
for
result
in
results
{
params_results
.
push
(
result
?
)
;
}
Ok
(
FuncType
:
:
from_raw_parts
(
params_results
.
into
(
)
len_params
)
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
FieldType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
element_type
=
reader
.
read
(
)
?
;
let
mutable
=
reader
.
read_u8
(
)
?
;
Ok
(
FieldType
{
element_type
mutable
:
match
mutable
{
0
=
>
false
1
=
>
true
_
=
>
bail
!
(
reader
.
original_position
(
)
"
malformed
mutability
byte
for
field
type
"
)
}
}
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
ArrayType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
Ok
(
ArrayType
(
FieldType
:
:
from_reader
(
reader
)
?
)
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
StructType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
fields
=
reader
.
read_iter
(
MAX_WASM_STRUCT_FIELDS
"
struct
fields
"
)
?
;
Ok
(
StructType
{
fields
:
fields
.
collect
:
:
<
Result
<
_
>
>
(
)
?
}
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
ContType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
idx
=
match
u32
:
:
try_from
(
reader
.
read_var_s33
(
)
?
)
{
Ok
(
idx
)
=
>
idx
Err
(
_
)
=
>
{
bail
!
(
reader
.
original_position
(
)
"
invalid
continuation
type
"
)
;
}
}
;
let
idx
=
PackedIndex
:
:
from_module_index
(
idx
)
.
ok_or_else
(
|
|
{
BinaryReaderError
:
:
new
(
"
type
index
greater
than
implementation
limits
"
reader
.
original_position
(
)
)
}
)
?
;
Ok
(
ContType
(
idx
)
)
}
}
