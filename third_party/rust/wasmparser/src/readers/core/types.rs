use
crate
:
:
limits
:
:
{
MAX_WASM_FUNCTION_PARAMS
MAX_WASM_FUNCTION_RETURNS
}
;
use
crate
:
:
{
BinaryReader
FromReader
Result
SectionLimited
}
;
use
std
:
:
fmt
:
:
Debug
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
ValType
{
I32
I64
F32
F64
V128
Ref
(
RefType
)
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
#
[
repr
(
packed
)
]
pub
struct
RefType
{
pub
nullable
:
bool
pub
heap_type
:
HeapType
}
impl
RefType
{
pub
const
FUNCREF
:
RefType
=
RefType
{
nullable
:
true
heap_type
:
HeapType
:
:
Func
}
;
pub
const
EXTERNREF
:
RefType
=
RefType
{
nullable
:
true
heap_type
:
HeapType
:
:
Extern
}
;
}
impl
From
<
RefType
>
for
ValType
{
fn
from
(
ty
:
RefType
)
-
>
ValType
{
ValType
:
:
Ref
(
ty
)
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
#
[
repr
(
packed
)
]
pub
struct
PackedIndex
(
u16
)
;
impl
TryFrom
<
u32
>
for
PackedIndex
{
type
Error
=
(
)
;
fn
try_from
(
idx
:
u32
)
-
>
Result
<
PackedIndex
(
)
>
{
idx
.
try_into
(
)
.
map
(
PackedIndex
)
.
map_err
(
|
_
|
(
)
)
}
}
impl
From
<
PackedIndex
>
for
u32
{
fn
from
(
x
:
PackedIndex
)
-
>
u32
{
x
.
0
as
u32
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
HeapType
{
TypedFunc
(
PackedIndex
)
Func
Extern
}
impl
ValType
{
pub
const
FUNCREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
FUNCREF
)
;
pub
const
EXTERNREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
EXTERNREF
)
;
pub
fn
is_reference_type
(
&
self
)
-
>
bool
{
matches
!
(
self
ValType
:
:
Ref
(
_
)
)
}
pub
fn
is_defaultable
(
&
self
)
-
>
bool
{
!
matches
!
(
self
ValType
:
:
Ref
(
RefType
{
nullable
:
false
.
.
}
)
)
}
pub
(
crate
)
fn
is_valtype_byte
(
byte
:
u8
)
-
>
bool
{
match
byte
{
0x7F
|
0x7E
|
0x7D
|
0x7C
|
0x7B
|
0x70
|
0x6F
|
0x6B
|
0x6C
=
>
true
_
=
>
false
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
ValType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
match
reader
.
peek
(
)
?
{
0x7F
=
>
{
reader
.
position
+
=
1
;
Ok
(
ValType
:
:
I32
)
}
0x7E
=
>
{
reader
.
position
+
=
1
;
Ok
(
ValType
:
:
I64
)
}
0x7D
=
>
{
reader
.
position
+
=
1
;
Ok
(
ValType
:
:
F32
)
}
0x7C
=
>
{
reader
.
position
+
=
1
;
Ok
(
ValType
:
:
F64
)
}
0x7B
=
>
{
reader
.
position
+
=
1
;
Ok
(
ValType
:
:
V128
)
}
0x70
|
0x6F
|
0x6B
|
0x6C
=
>
Ok
(
ValType
:
:
Ref
(
reader
.
read
(
)
?
)
)
_
=
>
bail
!
(
reader
.
original_position
(
)
"
invalid
value
type
"
)
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
RefType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
match
reader
.
read
(
)
?
{
0x70
=
>
Ok
(
RefType
:
:
FUNCREF
)
0x6F
=
>
Ok
(
RefType
:
:
EXTERNREF
)
byte
(
0x6B
|
0x6C
)
=
>
Ok
(
RefType
{
nullable
:
byte
=
=
0x6C
heap_type
:
reader
.
read
(
)
?
}
)
_
=
>
bail
!
(
reader
.
original_position
(
)
"
malformed
reference
type
"
)
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
HeapType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
match
reader
.
peek
(
)
?
{
0x70
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
Func
)
}
0x6F
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
Extern
)
}
_
=
>
{
let
idx
=
match
u32
:
:
try_from
(
reader
.
read_var_s33
(
)
?
)
{
Ok
(
idx
)
=
>
idx
Err
(
_
)
=
>
{
bail
!
(
reader
.
original_position
(
)
"
invalid
function
heap
type
"
)
;
}
}
;
match
idx
.
try_into
(
)
{
Ok
(
packed
)
=
>
Ok
(
HeapType
:
:
TypedFunc
(
packed
)
)
Err
(
_
)
=
>
{
bail
!
(
reader
.
original_position
(
)
"
function
index
too
large
"
)
;
}
}
}
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
Type
{
Func
(
FuncType
)
}
#
[
derive
(
Clone
Eq
PartialEq
Hash
)
]
pub
struct
FuncType
{
params_results
:
Box
<
[
ValType
]
>
len_params
:
usize
}
impl
Debug
for
FuncType
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
FuncType
"
)
.
field
(
"
params
"
&
self
.
params
(
)
)
.
field
(
"
returns
"
&
self
.
results
(
)
)
.
finish
(
)
}
}
impl
FuncType
{
pub
fn
new
<
P
R
>
(
params
:
P
results
:
R
)
-
>
Self
where
P
:
IntoIterator
<
Item
=
ValType
>
R
:
IntoIterator
<
Item
=
ValType
>
{
let
mut
buffer
=
params
.
into_iter
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
len_params
=
buffer
.
len
(
)
;
buffer
.
extend
(
results
)
;
Self
{
params_results
:
buffer
.
into
(
)
len_params
}
}
pub
(
crate
)
fn
from_raw_parts
(
params_results
:
Box
<
[
ValType
]
>
len_params
:
usize
)
-
>
Self
{
assert
!
(
len_params
<
=
params_results
.
len
(
)
)
;
Self
{
params_results
len_params
}
}
#
[
inline
]
pub
fn
params
(
&
self
)
-
>
&
[
ValType
]
{
&
self
.
params_results
[
.
.
self
.
len_params
]
}
#
[
inline
]
pub
fn
results
(
&
self
)
-
>
&
[
ValType
]
{
&
self
.
params_results
[
self
.
len_params
.
.
]
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
TableType
{
pub
element_type
:
RefType
pub
initial
:
u32
pub
maximum
:
Option
<
u32
>
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
MemoryType
{
pub
memory64
:
bool
pub
shared
:
bool
pub
initial
:
u64
pub
maximum
:
Option
<
u64
>
}
impl
MemoryType
{
pub
fn
index_type
(
&
self
)
-
>
ValType
{
if
self
.
memory64
{
ValType
:
:
I64
}
else
{
ValType
:
:
I32
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
GlobalType
{
pub
content_type
:
ValType
pub
mutable
:
bool
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
TagKind
{
Exception
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
TagType
{
pub
kind
:
TagKind
pub
func_type_idx
:
u32
}
pub
type
TypeSectionReader
<
'
a
>
=
SectionLimited
<
'
a
Type
>
;
impl
<
'
a
>
FromReader
<
'
a
>
for
Type
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
Ok
(
match
reader
.
read_u8
(
)
?
{
0x60
=
>
Type
:
:
Func
(
reader
.
read
(
)
?
)
x
=
>
return
reader
.
invalid_leading_byte
(
x
"
type
"
)
}
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
FuncType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
mut
params_results
=
reader
.
read_iter
(
MAX_WASM_FUNCTION_PARAMS
"
function
params
"
)
?
.
collect
:
:
<
Result
<
Vec
<
_
>
>
>
(
)
?
;
let
len_params
=
params_results
.
len
(
)
;
let
results
=
reader
.
read_iter
(
MAX_WASM_FUNCTION_RETURNS
"
function
returns
"
)
?
;
params_results
.
reserve
(
results
.
size_hint
(
)
.
0
)
;
for
result
in
results
{
params_results
.
push
(
result
?
)
;
}
Ok
(
FuncType
:
:
from_raw_parts
(
params_results
.
into
(
)
len_params
)
)
}
}
