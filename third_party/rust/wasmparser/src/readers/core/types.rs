use
crate
:
:
limits
:
:
{
MAX_WASM_FUNCTION_PARAMS
MAX_WASM_FUNCTION_RETURNS
MAX_WASM_STRUCT_FIELDS
MAX_WASM_SUPERTYPES
MAX_WASM_TYPES
}
;
use
crate
:
:
types
:
:
CoreTypeId
;
use
crate
:
:
{
BinaryReader
BinaryReaderError
FromReader
Result
SectionLimited
}
;
use
std
:
:
fmt
:
:
{
self
Debug
Write
}
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
mod
matches
;
pub
(
crate
)
use
self
:
:
matches
:
:
{
Matches
WithRecGroup
}
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
PackedIndex
(
u32
)
;
#
[
test
]
fn
can_fit_max_wasm_types_in_packed_index
(
)
{
assert
!
(
PackedIndex
:
:
can_represent_index
(
crate
:
:
limits
:
:
MAX_WASM_TYPES
as
u32
)
)
;
assert
!
(
PackedIndex
:
:
can_represent_index
(
0b00000000_00001111_00000000_00000000
)
)
;
assert
!
(
PackedIndex
:
:
can_represent_index
(
0b00000000_00000000_11111111_00000000
)
)
;
assert
!
(
PackedIndex
:
:
can_represent_index
(
0b00000000_00000000_00000000_11111111
)
)
;
assert
!
(
PackedIndex
:
:
can_represent_index
(
0
)
)
;
}
impl
PackedIndex
{
const
UNUSED_MASK
:
u32
=
u32
:
:
MAX
&
!
(
Self
:
:
KIND_MASK
|
Self
:
:
INDEX_MASK
)
;
const
KIND_MASK
:
u32
=
0b11
<
<
20
;
const
INDEX_MASK
:
u32
=
(
1
<
<
20
)
-
1
;
const
MODULE_KIND
:
u32
=
0b00
<
<
20
;
const
REC_GROUP_KIND
:
u32
=
0b01
<
<
20
;
const
ID_KIND
:
u32
=
0b10
<
<
20
;
#
[
inline
]
pub
(
crate
)
fn
unchecked_from_u32
(
x
:
u32
)
-
>
Self
{
debug_assert_eq
!
(
Self
:
:
UNUSED_MASK
&
x
0
)
;
Self
(
x
)
}
#
[
inline
]
pub
(
crate
)
fn
to_u32
(
id
:
Self
)
-
>
u32
{
let
x
=
id
.
0
;
debug_assert_eq
!
(
Self
:
:
UNUSED_MASK
&
x
0
)
;
x
}
#
[
inline
]
fn
can_represent_index
(
index
:
u32
)
-
>
bool
{
index
&
Self
:
:
INDEX_MASK
=
=
index
}
#
[
inline
]
fn
kind
(
&
self
)
-
>
u32
{
self
.
0
&
Self
:
:
KIND_MASK
}
#
[
inline
]
fn
index
(
&
self
)
-
>
u32
{
self
.
0
&
Self
:
:
INDEX_MASK
}
#
[
inline
]
pub
fn
from_module_index
(
index
:
u32
)
-
>
Option
<
Self
>
{
if
PackedIndex
:
:
can_represent_index
(
index
)
{
Some
(
PackedIndex
(
PackedIndex
:
:
MODULE_KIND
|
index
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
from_rec_group_index
(
index
:
u32
)
-
>
Option
<
Self
>
{
if
PackedIndex
:
:
can_represent_index
(
index
)
{
Some
(
PackedIndex
(
PackedIndex
:
:
REC_GROUP_KIND
|
index
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
from_id
(
id
:
CoreTypeId
)
-
>
Option
<
Self
>
{
let
index
=
u32
:
:
try_from
(
crate
:
:
types
:
:
TypeIdentifier
:
:
index
(
&
id
)
)
.
unwrap
(
)
;
if
PackedIndex
:
:
can_represent_index
(
index
)
{
Some
(
PackedIndex
(
PackedIndex
:
:
ID_KIND
|
index
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
is_canonical
(
&
self
)
-
>
bool
{
match
self
.
kind
(
)
{
Self
:
:
REC_GROUP_KIND
|
Self
:
:
ID_KIND
=
>
true
Self
:
:
MODULE_KIND
=
>
false
_
=
>
unreachable
!
(
)
}
}
#
[
inline
]
pub
fn
unpack
(
&
self
)
-
>
UnpackedIndex
{
match
self
.
kind
(
)
{
Self
:
:
MODULE_KIND
=
>
UnpackedIndex
:
:
Module
(
self
.
index
(
)
)
Self
:
:
REC_GROUP_KIND
=
>
UnpackedIndex
:
:
RecGroup
(
self
.
index
(
)
)
Self
:
:
ID_KIND
=
>
UnpackedIndex
:
:
Id
(
<
CoreTypeId
as
crate
:
:
types
:
:
TypeIdentifier
>
:
:
from_index
(
self
.
index
(
)
)
)
_
=
>
unreachable
!
(
)
}
}
#
[
inline
]
pub
fn
as_module_index
(
&
self
)
-
>
Option
<
u32
>
{
if
self
.
kind
(
)
=
=
Self
:
:
MODULE_KIND
{
Some
(
self
.
index
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
as_rec_group_index
(
&
self
)
-
>
Option
<
u32
>
{
if
self
.
kind
(
)
=
=
Self
:
:
REC_GROUP_KIND
{
Some
(
self
.
index
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
as_core_type_id
(
&
self
)
-
>
Option
<
CoreTypeId
>
{
if
self
.
kind
(
)
=
=
Self
:
:
ID_KIND
{
Some
(
<
CoreTypeId
as
crate
:
:
types
:
:
TypeIdentifier
>
:
:
from_index
(
self
.
index
(
)
)
)
}
else
{
None
}
}
}
impl
std
:
:
fmt
:
:
Debug
for
PackedIndex
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
CoreTypeIndex
"
)
.
field
(
"
kind
"
match
self
.
kind
(
)
{
Self
:
:
MODULE_KIND
=
>
&
"
module
"
Self
:
:
REC_GROUP_KIND
=
>
&
"
recgroup
"
Self
:
:
ID_KIND
=
>
&
"
id
"
_
=
>
unreachable
!
(
)
}
)
.
field
(
"
index
"
&
self
.
index
(
)
)
.
finish
(
)
}
}
impl
std
:
:
fmt
:
:
Display
for
PackedIndex
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
std
:
:
fmt
:
:
Display
:
:
fmt
(
&
self
.
unpack
(
)
f
)
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
pub
enum
UnpackedIndex
{
Module
(
u32
)
RecGroup
(
u32
)
Id
(
CoreTypeId
)
}
impl
UnpackedIndex
{
pub
fn
pack
(
&
self
)
-
>
Option
<
PackedIndex
>
{
match
self
{
UnpackedIndex
:
:
Module
(
i
)
=
>
PackedIndex
:
:
from_module_index
(
*
i
)
UnpackedIndex
:
:
RecGroup
(
i
)
=
>
PackedIndex
:
:
from_rec_group_index
(
*
i
)
UnpackedIndex
:
:
Id
(
id
)
=
>
PackedIndex
:
:
from_id
(
*
id
)
}
}
#
[
inline
]
pub
fn
is_canonical
(
&
self
)
-
>
bool
{
matches
!
(
self
UnpackedIndex
:
:
RecGroup
(
_
)
|
UnpackedIndex
:
:
Id
(
_
)
)
}
#
[
inline
]
pub
fn
as_module_index
(
&
self
)
-
>
Option
<
u32
>
{
if
let
Self
:
:
Module
(
i
)
=
*
self
{
Some
(
i
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
as_rec_group_index
(
&
self
)
-
>
Option
<
u32
>
{
if
let
Self
:
:
RecGroup
(
i
)
=
*
self
{
Some
(
i
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
as_core_type_id
(
&
self
)
-
>
Option
<
CoreTypeId
>
{
if
let
Self
:
:
Id
(
id
)
=
*
self
{
Some
(
id
)
}
else
{
None
}
}
}
impl
std
:
:
fmt
:
:
Display
for
UnpackedIndex
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
match
self
{
UnpackedIndex
:
:
Module
(
i
)
=
>
write
!
(
f
"
(
module
{
i
}
)
"
)
UnpackedIndex
:
:
RecGroup
(
i
)
=
>
write
!
(
f
"
(
recgroup
{
i
}
)
"
)
UnpackedIndex
:
:
Id
(
id
)
=
>
write
!
(
f
"
(
id
{
}
)
"
crate
:
:
types
:
:
TypeIdentifier
:
:
index
(
id
)
)
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
RecGroup
{
inner
:
RecGroupInner
}
#
[
derive
(
Debug
Clone
)
]
enum
RecGroupInner
{
Implicit
(
SubType
)
Explicit
(
Vec
<
SubType
>
)
}
impl
RecGroup
{
pub
(
crate
)
fn
explicit
(
types
:
Vec
<
SubType
>
)
-
>
Self
{
RecGroup
{
inner
:
RecGroupInner
:
:
Explicit
(
types
)
}
}
pub
(
crate
)
fn
implicit
(
ty
:
SubType
)
-
>
Self
{
RecGroup
{
inner
:
RecGroupInner
:
:
Implicit
(
ty
)
}
}
pub
fn
is_explicit_rec_group
(
&
self
)
-
>
bool
{
matches
!
(
self
.
inner
RecGroupInner
:
:
Explicit
(
_
)
)
}
pub
fn
types
(
&
self
)
-
>
&
[
SubType
]
{
match
&
self
.
inner
{
RecGroupInner
:
:
Implicit
(
ty
)
=
>
std
:
:
slice
:
:
from_ref
(
ty
)
RecGroupInner
:
:
Explicit
(
types
)
=
>
types
}
}
pub
(
crate
)
fn
types_mut
(
&
mut
self
)
-
>
&
mut
[
SubType
]
{
match
&
mut
self
.
inner
{
RecGroupInner
:
:
Implicit
(
ty
)
=
>
std
:
:
slice
:
:
from_mut
(
ty
)
RecGroupInner
:
:
Explicit
(
types
)
=
>
types
}
}
pub
fn
into_types
(
self
)
-
>
impl
ExactSizeIterator
<
Item
=
SubType
>
{
return
match
self
.
inner
{
RecGroupInner
:
:
Implicit
(
ty
)
=
>
Iter
:
:
Implicit
(
Some
(
ty
)
)
RecGroupInner
:
:
Explicit
(
types
)
=
>
Iter
:
:
Explicit
(
types
.
into_iter
(
)
)
}
;
enum
Iter
{
Implicit
(
Option
<
SubType
>
)
Explicit
(
std
:
:
vec
:
:
IntoIter
<
SubType
>
)
}
impl
Iterator
for
Iter
{
type
Item
=
SubType
;
fn
next
(
&
mut
self
)
-
>
Option
<
SubType
>
{
match
self
{
Self
:
:
Implicit
(
ty
)
=
>
ty
.
take
(
)
Self
:
:
Explicit
(
types
)
=
>
types
.
next
(
)
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
match
self
{
Self
:
:
Implicit
(
None
)
=
>
(
0
Some
(
0
)
)
Self
:
:
Implicit
(
Some
(
_
)
)
=
>
(
1
Some
(
1
)
)
Self
:
:
Explicit
(
types
)
=
>
types
.
size_hint
(
)
}
}
}
impl
ExactSizeIterator
for
Iter
{
}
}
}
impl
Hash
for
RecGroup
{
fn
hash
<
H
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
self
.
types
(
)
.
hash
(
hasher
)
}
}
impl
PartialEq
for
RecGroup
{
fn
eq
(
&
self
other
:
&
RecGroup
)
-
>
bool
{
self
.
types
(
)
=
=
other
.
types
(
)
}
}
impl
Eq
for
RecGroup
{
}
#
[
derive
(
Debug
Clone
Hash
PartialEq
Eq
)
]
pub
struct
SubType
{
pub
is_final
:
bool
pub
supertype_idx
:
Option
<
PackedIndex
>
pub
composite_type
:
CompositeType
}
impl
std
:
:
fmt
:
:
Display
for
SubType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
if
self
.
is_final
&
&
self
.
supertype_idx
.
is_none
(
)
{
std
:
:
fmt
:
:
Display
:
:
fmt
(
&
self
.
composite_type
f
)
}
else
{
write
!
(
f
"
(
sub
"
)
?
;
if
self
.
is_final
{
write
!
(
f
"
final
"
)
?
;
}
if
let
Some
(
idx
)
=
self
.
supertype_idx
{
write
!
(
f
"
{
idx
}
"
)
?
;
}
std
:
:
fmt
:
:
Display
:
:
fmt
(
&
self
.
composite_type
f
)
?
;
write
!
(
f
"
)
"
)
}
}
}
impl
SubType
{
pub
fn
unwrap_array
(
&
self
)
-
>
&
ArrayType
{
self
.
composite_type
.
unwrap_array
(
)
}
pub
fn
unwrap_func
(
&
self
)
-
>
&
FuncType
{
self
.
composite_type
.
unwrap_func
(
)
}
pub
fn
unwrap_struct
(
&
self
)
-
>
&
StructType
{
self
.
composite_type
.
unwrap_struct
(
)
}
pub
(
crate
)
fn
remap_indices
(
&
mut
self
f
:
&
mut
dyn
FnMut
(
&
mut
PackedIndex
)
-
>
Result
<
(
)
>
)
-
>
Result
<
(
)
>
{
if
let
Some
(
idx
)
=
&
mut
self
.
supertype_idx
{
f
(
idx
)
?
;
}
match
&
mut
self
.
composite_type
{
CompositeType
:
:
Func
(
ty
)
=
>
{
for
ty
in
ty
.
params_mut
(
)
{
ty
.
remap_indices
(
f
)
?
;
}
for
ty
in
ty
.
results_mut
(
)
{
ty
.
remap_indices
(
f
)
?
;
}
}
CompositeType
:
:
Array
(
ty
)
=
>
{
ty
.
0
.
remap_indices
(
f
)
?
;
}
CompositeType
:
:
Struct
(
ty
)
=
>
{
for
field
in
ty
.
fields
.
iter_mut
(
)
{
field
.
remap_indices
(
f
)
?
;
}
}
}
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
Clone
Hash
PartialEq
Eq
)
]
pub
enum
CompositeType
{
Func
(
FuncType
)
Array
(
ArrayType
)
Struct
(
StructType
)
}
impl
std
:
:
fmt
:
:
Display
for
CompositeType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
Self
:
:
Array
(
_
)
=
>
write
!
(
f
"
(
array
.
.
.
)
"
)
Self
:
:
Func
(
_
)
=
>
write
!
(
f
"
(
func
.
.
.
)
"
)
Self
:
:
Struct
(
_
)
=
>
write
!
(
f
"
(
struct
.
.
.
)
"
)
}
}
}
impl
CompositeType
{
pub
fn
unwrap_func
(
&
self
)
-
>
&
FuncType
{
match
self
{
Self
:
:
Func
(
f
)
=
>
f
_
=
>
panic
!
(
"
not
a
func
"
)
}
}
pub
fn
unwrap_array
(
&
self
)
-
>
&
ArrayType
{
match
self
{
Self
:
:
Array
(
a
)
=
>
a
_
=
>
panic
!
(
"
not
a
array
"
)
}
}
pub
fn
unwrap_struct
(
&
self
)
-
>
&
StructType
{
match
self
{
Self
:
:
Struct
(
s
)
=
>
s
_
=
>
panic
!
(
"
not
a
struct
"
)
}
}
}
#
[
derive
(
Clone
Eq
PartialEq
Hash
)
]
pub
struct
FuncType
{
params_results
:
Box
<
[
ValType
]
>
len_params
:
usize
}
impl
std
:
:
fmt
:
:
Debug
for
FuncType
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
FuncType
"
)
.
field
(
"
params
"
&
self
.
params
(
)
)
.
field
(
"
results
"
&
self
.
results
(
)
)
.
finish
(
)
}
}
impl
FuncType
{
pub
fn
new
<
P
R
>
(
params
:
P
results
:
R
)
-
>
Self
where
P
:
IntoIterator
<
Item
=
ValType
>
R
:
IntoIterator
<
Item
=
ValType
>
{
let
mut
buffer
=
params
.
into_iter
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
len_params
=
buffer
.
len
(
)
;
buffer
.
extend
(
results
)
;
Self
{
params_results
:
buffer
.
into
(
)
len_params
}
}
pub
(
crate
)
fn
from_raw_parts
(
params_results
:
Box
<
[
ValType
]
>
len_params
:
usize
)
-
>
Self
{
assert
!
(
len_params
<
=
params_results
.
len
(
)
)
;
Self
{
params_results
len_params
}
}
#
[
inline
]
pub
fn
params
(
&
self
)
-
>
&
[
ValType
]
{
&
self
.
params_results
[
.
.
self
.
len_params
]
}
#
[
inline
]
pub
(
crate
)
fn
params_mut
(
&
mut
self
)
-
>
&
mut
[
ValType
]
{
&
mut
self
.
params_results
[
.
.
self
.
len_params
]
}
#
[
inline
]
pub
fn
results
(
&
self
)
-
>
&
[
ValType
]
{
&
self
.
params_results
[
self
.
len_params
.
.
]
}
#
[
inline
]
pub
(
crate
)
fn
results_mut
(
&
mut
self
)
-
>
&
mut
[
ValType
]
{
&
mut
self
.
params_results
[
self
.
len_params
.
.
]
}
pub
(
crate
)
fn
desc
(
&
self
)
-
>
String
{
let
mut
s
=
String
:
:
new
(
)
;
s
.
push_str
(
"
[
"
)
;
for
(
i
param
)
in
self
.
params
(
)
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
s
.
push_str
(
"
"
)
;
}
write
!
(
s
"
{
param
}
"
)
.
unwrap
(
)
;
}
s
.
push_str
(
"
]
-
>
[
"
)
;
for
(
i
result
)
in
self
.
results
(
)
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
s
.
push_str
(
"
"
)
;
}
write
!
(
s
"
{
result
}
"
)
.
unwrap
(
)
;
}
s
.
push_str
(
"
]
"
)
;
s
}
}
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Hash
)
]
pub
struct
ArrayType
(
pub
FieldType
)
;
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Hash
)
]
pub
struct
FieldType
{
pub
element_type
:
StorageType
pub
mutable
:
bool
}
impl
FieldType
{
pub
(
crate
)
fn
remap_indices
(
&
mut
self
f
:
&
mut
dyn
FnMut
(
&
mut
PackedIndex
)
-
>
Result
<
(
)
>
)
-
>
Result
<
(
)
>
{
match
&
mut
self
.
element_type
{
StorageType
:
:
I8
|
StorageType
:
:
I16
=
>
Ok
(
(
)
)
StorageType
:
:
Val
(
ty
)
=
>
ty
.
remap_indices
(
f
)
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
StorageType
{
I8
I16
Val
(
ValType
)
}
impl
std
:
:
fmt
:
:
Display
for
StorageType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
Self
:
:
I8
=
>
write
!
(
f
"
i8
"
)
Self
:
:
I16
=
>
write
!
(
f
"
i16
"
)
Self
:
:
Val
(
v
)
=
>
std
:
:
fmt
:
:
Display
:
:
fmt
(
v
f
)
}
}
}
impl
StorageType
{
pub
fn
is_packed
(
&
self
)
-
>
bool
{
match
self
{
Self
:
:
I8
|
Self
:
:
I16
=
>
true
Self
:
:
Val
(
_
)
=
>
false
}
}
pub
fn
unpack
(
&
self
)
-
>
ValType
{
match
*
self
{
Self
:
:
Val
(
ty
)
=
>
ty
Self
:
:
I8
|
Self
:
:
I16
=
>
ValType
:
:
I32
}
}
}
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
)
]
pub
struct
StructType
{
pub
fields
:
Box
<
[
FieldType
]
>
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
ValType
{
I32
I64
F32
F64
V128
Ref
(
RefType
)
}
impl
From
<
RefType
>
for
ValType
{
#
[
inline
]
fn
from
(
ty
:
RefType
)
-
>
ValType
{
ValType
:
:
Ref
(
ty
)
}
}
impl
std
:
:
fmt
:
:
Display
for
ValType
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
match
self
{
ValType
:
:
I32
=
>
f
.
write_str
(
"
i32
"
)
ValType
:
:
I64
=
>
f
.
write_str
(
"
i64
"
)
ValType
:
:
F32
=
>
f
.
write_str
(
"
f32
"
)
ValType
:
:
F64
=
>
f
.
write_str
(
"
f64
"
)
ValType
:
:
V128
=
>
f
.
write_str
(
"
v128
"
)
ValType
:
:
Ref
(
r
)
=
>
std
:
:
fmt
:
:
Display
:
:
fmt
(
r
f
)
}
}
}
impl
ValType
{
pub
const
FUNCREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
FUNCREF
)
;
pub
const
EXTERNREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
EXTERNREF
)
;
pub
const
EXNREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
EXNREF
)
;
pub
fn
is_reference_type
(
&
self
)
-
>
bool
{
matches
!
(
self
ValType
:
:
Ref
(
_
)
)
}
pub
fn
as_reference_type
(
&
self
)
-
>
Option
<
RefType
>
{
match
*
self
{
ValType
:
:
Ref
(
r
)
=
>
Some
(
r
)
ValType
:
:
I32
|
ValType
:
:
I64
|
ValType
:
:
F32
|
ValType
:
:
F64
|
ValType
:
:
V128
=
>
None
}
}
pub
fn
is_defaultable
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
I32
|
Self
:
:
I64
|
Self
:
:
F32
|
Self
:
:
F64
|
Self
:
:
V128
=
>
true
Self
:
:
Ref
(
rt
)
=
>
rt
.
is_nullable
(
)
}
}
pub
(
crate
)
fn
remap_indices
(
&
mut
self
map
:
&
mut
dyn
FnMut
(
&
mut
PackedIndex
)
-
>
Result
<
(
)
>
)
-
>
Result
<
(
)
>
{
match
self
{
ValType
:
:
Ref
(
r
)
=
>
{
if
let
Some
(
mut
idx
)
=
r
.
type_index
(
)
{
map
(
&
mut
idx
)
?
;
*
r
=
RefType
:
:
concrete
(
r
.
is_nullable
(
)
idx
)
;
}
}
ValType
:
:
I32
|
ValType
:
:
I64
|
ValType
:
:
F32
|
ValType
:
:
F64
|
ValType
:
:
V128
=
>
{
}
}
Ok
(
(
)
)
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
RefType
(
[
u8
;
3
]
)
;
impl
std
:
:
fmt
:
:
Debug
for
RefType
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
match
(
self
.
is_nullable
(
)
self
.
heap_type
(
)
)
{
(
true
HeapType
:
:
Any
)
=
>
write
!
(
f
"
anyref
"
)
(
false
HeapType
:
:
Any
)
=
>
write
!
(
f
"
(
ref
any
)
"
)
(
true
HeapType
:
:
None
)
=
>
write
!
(
f
"
nullref
"
)
(
false
HeapType
:
:
None
)
=
>
write
!
(
f
"
(
ref
none
)
"
)
(
true
HeapType
:
:
NoExtern
)
=
>
write
!
(
f
"
nullexternref
"
)
(
false
HeapType
:
:
NoExtern
)
=
>
write
!
(
f
"
(
ref
noextern
)
"
)
(
true
HeapType
:
:
NoFunc
)
=
>
write
!
(
f
"
nullfuncref
"
)
(
false
HeapType
:
:
NoFunc
)
=
>
write
!
(
f
"
(
ref
nofunc
)
"
)
(
true
HeapType
:
:
Eq
)
=
>
write
!
(
f
"
eqref
"
)
(
false
HeapType
:
:
Eq
)
=
>
write
!
(
f
"
(
ref
eq
)
"
)
(
true
HeapType
:
:
Struct
)
=
>
write
!
(
f
"
structref
"
)
(
false
HeapType
:
:
Struct
)
=
>
write
!
(
f
"
(
ref
struct
)
"
)
(
true
HeapType
:
:
Array
)
=
>
write
!
(
f
"
arrayref
"
)
(
false
HeapType
:
:
Array
)
=
>
write
!
(
f
"
(
ref
array
)
"
)
(
true
HeapType
:
:
I31
)
=
>
write
!
(
f
"
i31ref
"
)
(
false
HeapType
:
:
I31
)
=
>
write
!
(
f
"
(
ref
i31
)
"
)
(
true
HeapType
:
:
Extern
)
=
>
write
!
(
f
"
externref
"
)
(
false
HeapType
:
:
Extern
)
=
>
write
!
(
f
"
(
ref
extern
)
"
)
(
true
HeapType
:
:
Func
)
=
>
write
!
(
f
"
funcref
"
)
(
false
HeapType
:
:
Func
)
=
>
write
!
(
f
"
(
ref
func
)
"
)
(
true
HeapType
:
:
Exn
)
=
>
write
!
(
f
"
exnref
"
)
(
false
HeapType
:
:
Exn
)
=
>
write
!
(
f
"
(
ref
exn
)
"
)
(
true
HeapType
:
:
Concrete
(
idx
)
)
=
>
write
!
(
f
"
(
ref
null
{
idx
}
)
"
)
(
false
HeapType
:
:
Concrete
(
idx
)
)
=
>
write
!
(
f
"
(
ref
{
idx
}
)
"
)
}
}
}
impl
std
:
:
fmt
:
:
Display
for
RefType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
std
:
:
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
#
[
test
]
fn
can_fit_max_wasm_types_in_ref_type
(
)
{
fn
can_roundtrip_index
(
index
:
u32
)
-
>
bool
{
assert
!
(
RefType
:
:
can_represent_type_index
(
index
)
)
;
let
rt
=
RefType
:
:
concrete
(
true
PackedIndex
:
:
from_module_index
(
index
)
.
unwrap
(
)
)
;
assert
!
(
rt
.
is_nullable
(
)
)
;
let
actual_index
=
match
rt
.
type_index
(
)
{
Some
(
i
)
=
>
i
None
=
>
panic
!
(
)
}
;
actual_index
.
as_module_index
(
)
=
=
Some
(
index
)
}
assert
!
(
can_roundtrip_index
(
crate
:
:
limits
:
:
MAX_WASM_TYPES
as
u32
)
)
;
assert
!
(
can_roundtrip_index
(
0b00000000_00001111_00000000_00000000
)
)
;
assert
!
(
can_roundtrip_index
(
0b00000000_00000000_11111111_00000000
)
)
;
assert
!
(
can_roundtrip_index
(
0b00000000_00000000_00000000_11111111
)
)
;
assert
!
(
can_roundtrip_index
(
0
)
)
;
}
impl
RefType
{
const
NULLABLE_BIT
:
u32
=
1
<
<
23
;
const
CONCRETE_BIT
:
u32
=
1
<
<
22
;
const
ABSTYPE_MASK
:
u32
=
0b1111
<
<
18
;
const
ANY_ABSTYPE
:
u32
=
0b1111
<
<
18
;
const
EQ_ABSTYPE
:
u32
=
0b1101
<
<
18
;
const
I31_ABSTYPE
:
u32
=
0b1000
<
<
18
;
const
STRUCT_ABSTYPE
:
u32
=
0b1001
<
<
18
;
const
ARRAY_ABSTYPE
:
u32
=
0b1100
<
<
18
;
const
FUNC_ABSTYPE
:
u32
=
0b0101
<
<
18
;
const
NOFUNC_ABSTYPE
:
u32
=
0b0100
<
<
18
;
const
EXTERN_ABSTYPE
:
u32
=
0b0011
<
<
18
;
const
NOEXTERN_ABSTYPE
:
u32
=
0b0010
<
<
18
;
const
EXN_ABSTYPE
:
u32
=
0b0001
<
<
18
;
const
NONE_ABSTYPE
:
u32
=
0b0000
<
<
18
;
const
INDEX_MASK
:
u32
=
(
1
<
<
22
)
-
1
;
pub
const
FUNCREF
:
Self
=
RefType
:
:
FUNC
.
nullable
(
)
;
pub
const
EXTERNREF
:
Self
=
RefType
:
:
EXTERN
.
nullable
(
)
;
pub
const
EXNREF
:
Self
=
RefType
:
:
EXN
.
nullable
(
)
;
pub
const
FUNC
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
FUNC_ABSTYPE
)
;
pub
const
EXTERN
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
EXTERN_ABSTYPE
)
;
pub
const
ANY
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
ANY_ABSTYPE
)
;
pub
const
NONE
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
NONE_ABSTYPE
)
;
pub
const
NOEXTERN
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
NOEXTERN_ABSTYPE
)
;
pub
const
NOFUNC
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
NOFUNC_ABSTYPE
)
;
pub
const
EQ
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
EQ_ABSTYPE
)
;
pub
const
STRUCT
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
STRUCT_ABSTYPE
)
;
pub
const
ARRAY
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
ARRAY_ABSTYPE
)
;
pub
const
I31
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
I31_ABSTYPE
)
;
pub
const
EXN
:
Self
=
RefType
:
:
from_u32
(
Self
:
:
EXN_ABSTYPE
)
;
const
fn
can_represent_type_index
(
index
:
u32
)
-
>
bool
{
index
&
Self
:
:
INDEX_MASK
=
=
index
}
const
fn
u24_to_u32
(
bytes
:
[
u8
;
3
]
)
-
>
u32
{
let
expanded_bytes
=
[
bytes
[
0
]
bytes
[
1
]
bytes
[
2
]
0
]
;
u32
:
:
from_le_bytes
(
expanded_bytes
)
}
const
fn
u32_to_u24
(
x
:
u32
)
-
>
[
u8
;
3
]
{
let
bytes
=
x
.
to_le_bytes
(
)
;
debug_assert
!
(
bytes
[
3
]
=
=
0
)
;
[
bytes
[
0
]
bytes
[
1
]
bytes
[
2
]
]
}
#
[
inline
]
const
fn
as_u32
(
&
self
)
-
>
u32
{
Self
:
:
u24_to_u32
(
self
.
0
)
}
#
[
inline
]
const
fn
from_u32
(
x
:
u32
)
-
>
Self
{
debug_assert
!
(
x
&
(
0b11111111
<
<
24
)
=
=
0
)
;
debug_assert
!
(
x
&
Self
:
:
CONCRETE_BIT
!
=
0
|
|
matches
!
(
x
&
Self
:
:
ABSTYPE_MASK
Self
:
:
ANY_ABSTYPE
|
Self
:
:
EQ_ABSTYPE
|
Self
:
:
I31_ABSTYPE
|
Self
:
:
STRUCT_ABSTYPE
|
Self
:
:
ARRAY_ABSTYPE
|
Self
:
:
FUNC_ABSTYPE
|
Self
:
:
NOFUNC_ABSTYPE
|
Self
:
:
EXTERN_ABSTYPE
|
Self
:
:
NOEXTERN_ABSTYPE
|
Self
:
:
NONE_ABSTYPE
|
Self
:
:
EXN_ABSTYPE
)
)
;
RefType
(
Self
:
:
u32_to_u24
(
x
)
)
}
pub
fn
concrete
(
nullable
:
bool
index
:
PackedIndex
)
-
>
Self
{
let
index
:
u32
=
PackedIndex
:
:
to_u32
(
index
)
;
debug_assert
!
(
Self
:
:
can_represent_type_index
(
index
)
)
;
let
nullable32
=
Self
:
:
NULLABLE_BIT
*
nullable
as
u32
;
RefType
:
:
from_u32
(
nullable32
|
Self
:
:
CONCRETE_BIT
|
index
)
}
pub
fn
new
(
nullable
:
bool
heap_type
:
HeapType
)
-
>
Option
<
Self
>
{
let
nullable32
=
Self
:
:
NULLABLE_BIT
*
(
nullable
as
u32
)
;
match
heap_type
{
HeapType
:
:
Concrete
(
index
)
=
>
Some
(
RefType
:
:
concrete
(
nullable
index
.
pack
(
)
?
)
)
HeapType
:
:
Func
=
>
Some
(
Self
:
:
from_u32
(
nullable32
|
Self
:
:
FUNC_ABSTYPE
)
)
HeapType
:
:
Extern
=
>
Some
(
Self
:
:
from_u32
(
nullable32
|
Self
:
:
EXTERN_ABSTYPE
)
)
HeapType
:
:
Any
=
>
Some
(
Self
:
:
from_u32
(
nullable32
|
Self
:
:
ANY_ABSTYPE
)
)
HeapType
:
:
None
=
>
Some
(
Self
:
:
from_u32
(
nullable32
|
Self
:
:
NONE_ABSTYPE
)
)
HeapType
:
:
NoExtern
=
>
Some
(
Self
:
:
from_u32
(
nullable32
|
Self
:
:
NOEXTERN_ABSTYPE
)
)
HeapType
:
:
NoFunc
=
>
Some
(
Self
:
:
from_u32
(
nullable32
|
Self
:
:
NOFUNC_ABSTYPE
)
)
HeapType
:
:
Eq
=
>
Some
(
Self
:
:
from_u32
(
nullable32
|
Self
:
:
EQ_ABSTYPE
)
)
HeapType
:
:
Struct
=
>
Some
(
Self
:
:
from_u32
(
nullable32
|
Self
:
:
STRUCT_ABSTYPE
)
)
HeapType
:
:
Array
=
>
Some
(
Self
:
:
from_u32
(
nullable32
|
Self
:
:
ARRAY_ABSTYPE
)
)
HeapType
:
:
I31
=
>
Some
(
Self
:
:
from_u32
(
nullable32
|
Self
:
:
I31_ABSTYPE
)
)
HeapType
:
:
Exn
=
>
Some
(
Self
:
:
from_u32
(
nullable32
|
Self
:
:
EXN_ABSTYPE
)
)
}
}
pub
fn
difference
(
a
:
RefType
b
:
RefType
)
-
>
RefType
{
RefType
:
:
new
(
if
b
.
is_nullable
(
)
{
false
}
else
{
a
.
is_nullable
(
)
}
a
.
heap_type
(
)
)
.
unwrap
(
)
}
pub
const
fn
is_concrete_type_ref
(
&
self
)
-
>
bool
{
self
.
as_u32
(
)
&
Self
:
:
CONCRETE_BIT
!
=
0
}
pub
fn
type_index
(
&
self
)
-
>
Option
<
PackedIndex
>
{
if
self
.
is_concrete_type_ref
(
)
{
let
index
=
self
.
as_u32
(
)
&
Self
:
:
INDEX_MASK
;
Some
(
PackedIndex
:
:
unchecked_from_u32
(
index
)
)
}
else
{
None
}
}
const
fn
abstype
(
&
self
)
-
>
u32
{
debug_assert
!
(
!
self
.
is_concrete_type_ref
(
)
)
;
self
.
as_u32
(
)
&
Self
:
:
ABSTYPE_MASK
}
pub
const
fn
is_func_ref
(
&
self
)
-
>
bool
{
!
self
.
is_concrete_type_ref
(
)
&
&
self
.
abstype
(
)
=
=
Self
:
:
FUNC_ABSTYPE
}
pub
const
fn
is_extern_ref
(
&
self
)
-
>
bool
{
!
self
.
is_concrete_type_ref
(
)
&
&
self
.
abstype
(
)
=
=
Self
:
:
EXTERN_ABSTYPE
}
pub
const
fn
is_array_ref
(
&
self
)
-
>
bool
{
!
self
.
is_concrete_type_ref
(
)
&
&
self
.
abstype
(
)
=
=
Self
:
:
ARRAY_ABSTYPE
}
pub
const
fn
is_struct_ref
(
&
self
)
-
>
bool
{
!
self
.
is_concrete_type_ref
(
)
&
&
self
.
abstype
(
)
=
=
Self
:
:
STRUCT_ABSTYPE
}
pub
const
fn
is_nullable
(
&
self
)
-
>
bool
{
self
.
as_u32
(
)
&
Self
:
:
NULLABLE_BIT
!
=
0
}
pub
const
fn
as_non_null
(
&
self
)
-
>
Self
{
Self
:
:
from_u32
(
self
.
as_u32
(
)
&
!
Self
:
:
NULLABLE_BIT
)
}
pub
const
fn
nullable
(
&
self
)
-
>
Self
{
Self
:
:
from_u32
(
self
.
as_u32
(
)
|
Self
:
:
NULLABLE_BIT
)
}
pub
fn
heap_type
(
&
self
)
-
>
HeapType
{
let
s
=
self
.
as_u32
(
)
;
if
self
.
is_concrete_type_ref
(
)
{
HeapType
:
:
Concrete
(
self
.
type_index
(
)
.
unwrap
(
)
.
unpack
(
)
)
}
else
{
match
s
&
Self
:
:
ABSTYPE_MASK
{
Self
:
:
FUNC_ABSTYPE
=
>
HeapType
:
:
Func
Self
:
:
EXTERN_ABSTYPE
=
>
HeapType
:
:
Extern
Self
:
:
ANY_ABSTYPE
=
>
HeapType
:
:
Any
Self
:
:
NONE_ABSTYPE
=
>
HeapType
:
:
None
Self
:
:
NOEXTERN_ABSTYPE
=
>
HeapType
:
:
NoExtern
Self
:
:
NOFUNC_ABSTYPE
=
>
HeapType
:
:
NoFunc
Self
:
:
EQ_ABSTYPE
=
>
HeapType
:
:
Eq
Self
:
:
STRUCT_ABSTYPE
=
>
HeapType
:
:
Struct
Self
:
:
ARRAY_ABSTYPE
=
>
HeapType
:
:
Array
Self
:
:
I31_ABSTYPE
=
>
HeapType
:
:
I31
Self
:
:
EXN_ABSTYPE
=
>
HeapType
:
:
Exn
_
=
>
unreachable
!
(
)
}
}
}
pub
(
crate
)
fn
wat
(
&
self
)
-
>
&
'
static
str
{
match
(
self
.
is_nullable
(
)
self
.
heap_type
(
)
)
{
(
true
HeapType
:
:
Func
)
=
>
"
funcref
"
(
true
HeapType
:
:
Extern
)
=
>
"
externref
"
(
true
HeapType
:
:
Concrete
(
_
)
)
=
>
"
(
ref
null
type
)
"
(
true
HeapType
:
:
Any
)
=
>
"
anyref
"
(
true
HeapType
:
:
None
)
=
>
"
nullref
"
(
true
HeapType
:
:
NoExtern
)
=
>
"
nullexternref
"
(
true
HeapType
:
:
NoFunc
)
=
>
"
nullfuncref
"
(
true
HeapType
:
:
Eq
)
=
>
"
eqref
"
(
true
HeapType
:
:
Struct
)
=
>
"
structref
"
(
true
HeapType
:
:
Array
)
=
>
"
arrayref
"
(
true
HeapType
:
:
I31
)
=
>
"
i31ref
"
(
true
HeapType
:
:
Exn
)
=
>
"
exnref
"
(
false
HeapType
:
:
Func
)
=
>
"
(
ref
func
)
"
(
false
HeapType
:
:
Extern
)
=
>
"
(
ref
extern
)
"
(
false
HeapType
:
:
Concrete
(
_
)
)
=
>
"
(
ref
type
)
"
(
false
HeapType
:
:
Any
)
=
>
"
(
ref
any
)
"
(
false
HeapType
:
:
None
)
=
>
"
(
ref
none
)
"
(
false
HeapType
:
:
NoExtern
)
=
>
"
(
ref
noextern
)
"
(
false
HeapType
:
:
NoFunc
)
=
>
"
(
ref
nofunc
)
"
(
false
HeapType
:
:
Eq
)
=
>
"
(
ref
eq
)
"
(
false
HeapType
:
:
Struct
)
=
>
"
(
ref
struct
)
"
(
false
HeapType
:
:
Array
)
=
>
"
(
ref
array
)
"
(
false
HeapType
:
:
I31
)
=
>
"
(
ref
i31
)
"
(
false
HeapType
:
:
Exn
)
=
>
"
(
ref
exn
)
"
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
HeapType
{
Concrete
(
UnpackedIndex
)
Func
Extern
Any
None
NoExtern
NoFunc
Eq
Struct
Array
I31
Exn
}
impl
ValType
{
pub
(
crate
)
fn
is_valtype_byte
(
byte
:
u8
)
-
>
bool
{
match
byte
{
0x7F
|
0x7E
|
0x7D
|
0x7C
|
0x7B
|
0x70
|
0x6F
|
0x64
|
0x63
|
0x6E
|
0x71
|
0x72
|
0x73
|
0x6D
|
0x6B
|
0x6A
|
0x6C
|
0x69
=
>
true
_
=
>
false
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
StorageType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
match
reader
.
peek
(
)
?
{
0x78
=
>
{
reader
.
position
+
=
1
;
Ok
(
StorageType
:
:
I8
)
}
0x77
=
>
{
reader
.
position
+
=
1
;
Ok
(
StorageType
:
:
I16
)
}
_
=
>
Ok
(
StorageType
:
:
Val
(
reader
.
read
(
)
?
)
)
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
ValType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
match
reader
.
peek
(
)
?
{
0x7F
=
>
{
reader
.
position
+
=
1
;
Ok
(
ValType
:
:
I32
)
}
0x7E
=
>
{
reader
.
position
+
=
1
;
Ok
(
ValType
:
:
I64
)
}
0x7D
=
>
{
reader
.
position
+
=
1
;
Ok
(
ValType
:
:
F32
)
}
0x7C
=
>
{
reader
.
position
+
=
1
;
Ok
(
ValType
:
:
F64
)
}
0x7B
=
>
{
reader
.
position
+
=
1
;
Ok
(
ValType
:
:
V128
)
}
0x70
|
0x6F
|
0x64
|
0x63
|
0x6E
|
0x71
|
0x72
|
0x73
|
0x6D
|
0x6B
|
0x6A
|
0x6C
|
0x69
=
>
Ok
(
ValType
:
:
Ref
(
reader
.
read
(
)
?
)
)
_
=
>
bail
!
(
reader
.
original_position
(
)
"
invalid
value
type
"
)
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
RefType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
match
reader
.
read
(
)
?
{
0x70
=
>
Ok
(
RefType
:
:
FUNC
.
nullable
(
)
)
0x6F
=
>
Ok
(
RefType
:
:
EXTERN
.
nullable
(
)
)
0x6E
=
>
Ok
(
RefType
:
:
ANY
.
nullable
(
)
)
0x71
=
>
Ok
(
RefType
:
:
NONE
.
nullable
(
)
)
0x72
=
>
Ok
(
RefType
:
:
NOEXTERN
.
nullable
(
)
)
0x73
=
>
Ok
(
RefType
:
:
NOFUNC
.
nullable
(
)
)
0x6D
=
>
Ok
(
RefType
:
:
EQ
.
nullable
(
)
)
0x6B
=
>
Ok
(
RefType
:
:
STRUCT
.
nullable
(
)
)
0x6A
=
>
Ok
(
RefType
:
:
ARRAY
.
nullable
(
)
)
0x6C
=
>
Ok
(
RefType
:
:
I31
.
nullable
(
)
)
0x69
=
>
Ok
(
RefType
:
:
EXN
.
nullable
(
)
)
byte
(
0x63
|
0x64
)
=
>
{
let
nullable
=
byte
=
=
0x63
;
let
pos
=
reader
.
original_position
(
)
;
RefType
:
:
new
(
nullable
reader
.
read
(
)
?
)
.
ok_or_else
(
|
|
crate
:
:
BinaryReaderError
:
:
new
(
"
type
index
too
large
"
pos
)
)
}
_
=
>
bail
!
(
reader
.
original_position
(
)
"
malformed
reference
type
"
)
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
HeapType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
match
reader
.
peek
(
)
?
{
0x70
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
Func
)
}
0x6F
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
Extern
)
}
0x6E
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
Any
)
}
0x71
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
None
)
}
0x72
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
NoExtern
)
}
0x73
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
NoFunc
)
}
0x6D
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
Eq
)
}
0x6B
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
Struct
)
}
0x6A
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
Array
)
}
0x6C
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
I31
)
}
0x69
=
>
{
reader
.
position
+
=
1
;
Ok
(
HeapType
:
:
Exn
)
}
_
=
>
{
let
idx
=
match
u32
:
:
try_from
(
reader
.
read_var_s33
(
)
?
)
{
Ok
(
idx
)
=
>
idx
Err
(
_
)
=
>
{
bail
!
(
reader
.
original_position
(
)
"
invalid
indexed
ref
heap
type
"
)
;
}
}
;
let
idx
=
PackedIndex
:
:
from_module_index
(
idx
)
.
ok_or_else
(
|
|
{
BinaryReaderError
:
:
new
(
"
type
index
greater
than
implementation
limits
"
reader
.
original_position
(
)
)
}
)
?
;
Ok
(
HeapType
:
:
Concrete
(
idx
.
unpack
(
)
)
)
}
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
TableType
{
pub
element_type
:
RefType
pub
initial
:
u32
pub
maximum
:
Option
<
u32
>
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
MemoryType
{
pub
memory64
:
bool
pub
shared
:
bool
pub
initial
:
u64
pub
maximum
:
Option
<
u64
>
}
impl
MemoryType
{
pub
fn
index_type
(
&
self
)
-
>
ValType
{
if
self
.
memory64
{
ValType
:
:
I64
}
else
{
ValType
:
:
I32
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
GlobalType
{
pub
content_type
:
ValType
pub
mutable
:
bool
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
TagKind
{
Exception
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
TagType
{
pub
kind
:
TagKind
pub
func_type_idx
:
u32
}
pub
type
TypeSectionReader
<
'
a
>
=
SectionLimited
<
'
a
RecGroup
>
;
impl
<
'
a
>
TypeSectionReader
<
'
a
>
{
pub
fn
into_iter_err_on_gc_types
(
self
)
-
>
impl
Iterator
<
Item
=
Result
<
FuncType
>
>
+
'
a
{
self
.
into_iter_with_offsets
(
)
.
map
(
|
item
|
{
let
(
offset
group
)
=
item
?
;
let
mut
types
=
group
.
into_types
(
)
;
let
ty
=
match
(
types
.
next
(
)
types
.
next
(
)
)
{
(
Some
(
ty
)
None
)
=
>
ty
_
=
>
bail
!
(
offset
"
gc
proposal
not
supported
"
)
}
;
if
!
ty
.
is_final
|
|
ty
.
supertype_idx
.
is_some
(
)
{
bail
!
(
offset
"
gc
proposal
not
supported
"
)
;
}
match
ty
.
composite_type
{
CompositeType
:
:
Func
(
f
)
=
>
Ok
(
f
)
CompositeType
:
:
Array
(
_
)
|
CompositeType
:
:
Struct
(
_
)
=
>
{
bail
!
(
offset
"
gc
proposal
not
supported
"
)
;
}
}
}
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
CompositeType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
read_composite_type
(
reader
.
read_u8
(
)
?
reader
)
}
}
fn
read_composite_type
(
opcode
:
u8
reader
:
&
mut
BinaryReader
)
-
>
Result
<
CompositeType
BinaryReaderError
>
{
Ok
(
match
opcode
{
0x60
=
>
CompositeType
:
:
Func
(
reader
.
read
(
)
?
)
0x5e
=
>
CompositeType
:
:
Array
(
reader
.
read
(
)
?
)
0x5f
=
>
CompositeType
:
:
Struct
(
reader
.
read
(
)
?
)
x
=
>
return
reader
.
invalid_leading_byte
(
x
"
type
"
)
}
)
}
impl
<
'
a
>
FromReader
<
'
a
>
for
RecGroup
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
match
reader
.
peek
(
)
?
{
0x4e
=
>
{
reader
.
read_u8
(
)
?
;
let
types
=
reader
.
read_iter
(
MAX_WASM_TYPES
"
rec
group
types
"
)
?
;
Ok
(
RecGroup
:
:
explicit
(
types
.
collect
:
:
<
Result
<
_
>
>
(
)
?
)
)
}
_
=
>
Ok
(
RecGroup
:
:
implicit
(
reader
.
read
(
)
?
)
)
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
SubType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
pos
=
reader
.
original_position
(
)
;
Ok
(
match
reader
.
read_u8
(
)
?
{
opcode
(
0x4f
|
0x50
)
=
>
{
let
idx_iter
=
reader
.
read_iter
(
MAX_WASM_SUPERTYPES
"
supertype
idxs
"
)
?
;
let
idxs
=
idx_iter
.
collect
:
:
<
Result
<
Vec
<
u32
>
>
>
(
)
?
;
if
idxs
.
len
(
)
>
1
{
return
Err
(
BinaryReaderError
:
:
new
(
"
multiple
supertypes
not
supported
"
pos
)
)
;
}
let
supertype_idx
=
idxs
.
first
(
)
.
copied
(
)
.
map
(
|
idx
|
{
PackedIndex
:
:
from_module_index
(
idx
)
.
ok_or_else
(
|
|
{
BinaryReaderError
:
:
new
(
"
type
index
greater
than
implementation
limits
"
reader
.
original_position
(
)
)
}
)
}
)
.
transpose
(
)
?
;
SubType
{
is_final
:
opcode
=
=
0x4f
supertype_idx
composite_type
:
read_composite_type
(
reader
.
read_u8
(
)
?
reader
)
?
}
}
opcode
=
>
SubType
{
is_final
:
true
supertype_idx
:
None
composite_type
:
read_composite_type
(
opcode
reader
)
?
}
}
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
FuncType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
mut
params_results
=
reader
.
read_iter
(
MAX_WASM_FUNCTION_PARAMS
"
function
params
"
)
?
.
collect
:
:
<
Result
<
Vec
<
_
>
>
>
(
)
?
;
let
len_params
=
params_results
.
len
(
)
;
let
results
=
reader
.
read_iter
(
MAX_WASM_FUNCTION_RETURNS
"
function
returns
"
)
?
;
params_results
.
reserve
(
results
.
size_hint
(
)
.
0
)
;
for
result
in
results
{
params_results
.
push
(
result
?
)
;
}
Ok
(
FuncType
:
:
from_raw_parts
(
params_results
.
into
(
)
len_params
)
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
FieldType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
element_type
=
reader
.
read
(
)
?
;
let
mutable
=
reader
.
read_u8
(
)
?
;
Ok
(
FieldType
{
element_type
mutable
:
match
mutable
{
0
=
>
false
1
=
>
true
_
=
>
bail
!
(
reader
.
original_position
(
)
"
malformed
mutability
byte
for
field
type
"
)
}
}
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
ArrayType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
Ok
(
ArrayType
(
FieldType
:
:
from_reader
(
reader
)
?
)
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
StructType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
fields
=
reader
.
read_iter
(
MAX_WASM_STRUCT_FIELDS
"
struct
fields
"
)
?
;
Ok
(
StructType
{
fields
:
fields
.
collect
:
:
<
Result
<
_
>
>
(
)
?
}
)
}
}
