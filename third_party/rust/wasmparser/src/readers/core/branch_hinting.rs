use
crate
:
:
{
BinaryReader
FromReader
Result
SectionLimited
}
;
pub
type
BranchHintSectionReader
<
'
a
>
=
SectionLimited
<
'
a
BranchHintFunction
<
'
a
>
>
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
BranchHintFunction
<
'
a
>
{
pub
func
:
u32
pub
hints
:
SectionLimited
<
'
a
BranchHint
>
}
impl
<
'
a
>
FromReader
<
'
a
>
for
BranchHintFunction
<
'
a
>
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
func
=
reader
.
read_var_u32
(
)
?
;
let
hints
=
reader
.
skip
(
|
reader
|
{
let
items_count
=
reader
.
read_var_u32
(
)
?
;
for
_
in
0
.
.
items_count
{
reader
.
read
:
:
<
BranchHint
>
(
)
?
;
}
Ok
(
(
)
)
}
)
?
;
Ok
(
BranchHintFunction
{
func
hints
:
SectionLimited
:
:
new
(
hints
)
?
}
)
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
BranchHint
{
pub
func_offset
:
u32
pub
taken
:
bool
}
impl
<
'
a
>
FromReader
<
'
a
>
for
BranchHint
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
func_offset
=
reader
.
read_var_u32
(
)
?
;
match
reader
.
read_u8
(
)
?
{
1
=
>
{
}
n
=
>
reader
.
invalid_leading_byte
(
n
"
invalid
branch
hint
byte
"
)
?
}
let
taken
=
match
reader
.
read_u8
(
)
?
{
0
=
>
false
1
=
>
true
n
=
>
reader
.
invalid_leading_byte
(
n
"
invalid
branch
hint
taken
byte
"
)
?
}
;
Ok
(
BranchHint
{
func_offset
taken
}
)
}
}
