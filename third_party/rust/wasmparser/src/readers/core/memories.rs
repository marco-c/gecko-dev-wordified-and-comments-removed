use
crate
:
:
{
BinaryReader
FromReader
MemoryType
Result
SectionLimited
}
;
pub
type
MemorySectionReader
<
'
a
>
=
SectionLimited
<
'
a
MemoryType
>
;
impl
<
'
a
>
FromReader
<
'
a
>
for
MemoryType
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
pos
=
reader
.
original_position
(
)
;
let
flags
=
reader
.
read_u8
(
)
?
;
if
(
flags
&
!
0b1111
)
!
=
0
{
bail
!
(
pos
"
invalid
memory
limits
flags
"
)
;
}
let
memory64
=
flags
&
0b0100
!
=
0
;
let
shared
=
flags
&
0b0010
!
=
0
;
let
has_max
=
flags
&
0b0001
!
=
0
;
let
has_page_size
=
flags
&
0b1000
!
=
0
;
Ok
(
MemoryType
{
memory64
shared
initial
:
if
reader
.
memory64
(
)
{
reader
.
read_var_u64
(
)
?
}
else
{
reader
.
read_var_u32
(
)
?
.
into
(
)
}
maximum
:
if
!
has_max
{
None
}
else
if
reader
.
memory64
(
)
{
Some
(
reader
.
read_var_u64
(
)
?
)
}
else
{
Some
(
reader
.
read_var_u32
(
)
?
.
into
(
)
)
}
page_size_log2
:
if
has_page_size
{
let
val
=
reader
.
read_var_u32
(
)
?
;
if
val
>
=
64
{
bail
!
(
pos
"
invalid
custom
page
size
"
)
;
}
Some
(
val
)
}
else
{
None
}
}
)
}
}
