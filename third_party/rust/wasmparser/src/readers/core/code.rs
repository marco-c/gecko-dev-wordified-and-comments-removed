use
crate
:
:
{
BinaryReader
FromReader
OperatorsReader
Result
SectionLimited
ValType
}
;
use
core
:
:
ops
:
:
Range
;
pub
type
CodeSectionReader
<
'
a
>
=
SectionLimited
<
'
a
FunctionBody
<
'
a
>
>
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
FunctionBody
<
'
a
>
{
reader
:
BinaryReader
<
'
a
>
}
impl
<
'
a
>
FunctionBody
<
'
a
>
{
pub
fn
new
(
reader
:
BinaryReader
<
'
a
>
)
-
>
Self
{
Self
{
reader
}
}
pub
fn
get_binary_reader
(
&
self
)
-
>
BinaryReader
<
'
a
>
{
self
.
reader
.
clone
(
)
}
fn
skip_locals
(
reader
:
&
mut
BinaryReader
)
-
>
Result
<
(
)
>
{
let
count
=
reader
.
read_var_u32
(
)
?
;
for
_
in
0
.
.
count
{
reader
.
read_var_u32
(
)
?
;
reader
.
read
:
:
<
ValType
>
(
)
?
;
}
Ok
(
(
)
)
}
pub
fn
get_locals_reader
(
&
self
)
-
>
Result
<
LocalsReader
<
'
a
>
>
{
let
mut
reader
=
self
.
reader
.
clone
(
)
;
let
declaration_count
=
reader
.
read_var_u32
(
)
?
;
Ok
(
LocalsReader
{
reader
declaration_count
total_count
:
0
}
)
}
pub
fn
get_binary_reader_for_operators
(
&
self
)
-
>
Result
<
BinaryReader
<
'
a
>
>
{
let
mut
reader
=
self
.
reader
.
clone
(
)
;
Self
:
:
skip_locals
(
&
mut
reader
)
?
;
Ok
(
reader
)
}
pub
fn
get_operators_reader
(
&
self
)
-
>
Result
<
OperatorsReader
<
'
a
>
>
{
Ok
(
OperatorsReader
:
:
new
(
self
.
get_binary_reader_for_operators
(
)
?
)
)
}
pub
fn
range
(
&
self
)
-
>
Range
<
usize
>
{
self
.
reader
.
range
(
)
}
pub
fn
as_bytes
(
&
self
)
-
>
&
'
a
[
u8
]
{
self
.
reader
.
remaining_buffer
(
)
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
FunctionBody
<
'
a
>
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
let
reader
=
reader
.
read_reader
(
)
?
;
Ok
(
FunctionBody
:
:
new
(
reader
)
)
}
}
pub
struct
LocalsReader
<
'
a
>
{
reader
:
BinaryReader
<
'
a
>
declaration_count
:
u32
total_count
:
u32
}
impl
<
'
a
>
LocalsReader
<
'
a
>
{
pub
fn
get_count
(
&
self
)
-
>
u32
{
self
.
declaration_count
}
pub
fn
original_position
(
&
self
)
-
>
usize
{
self
.
reader
.
original_position
(
)
}
pub
fn
read
(
&
mut
self
)
-
>
Result
<
(
u32
ValType
)
>
{
let
count
=
self
.
reader
.
read
(
)
?
;
match
self
.
total_count
.
checked_add
(
count
)
{
Some
(
total
)
=
>
self
.
total_count
=
total
None
=
>
bail
!
(
self
.
reader
.
original_position
(
)
"
too
many
locals
"
)
}
let
value_type
=
self
.
reader
.
read
(
)
?
;
Ok
(
(
count
value_type
)
)
}
pub
fn
get_binary_reader
(
self
)
-
>
BinaryReader
<
'
a
>
{
self
.
reader
}
}
impl
<
'
a
>
IntoIterator
for
LocalsReader
<
'
a
>
{
type
Item
=
Result
<
(
u32
ValType
)
>
;
type
IntoIter
=
LocalsIterator
<
'
a
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
let
count
=
self
.
declaration_count
;
LocalsIterator
{
reader
:
self
left
:
count
err
:
false
}
}
}
pub
struct
LocalsIterator
<
'
a
>
{
reader
:
LocalsReader
<
'
a
>
left
:
u32
err
:
bool
}
impl
<
'
a
>
Iterator
for
LocalsIterator
<
'
a
>
{
type
Item
=
Result
<
(
u32
ValType
)
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
err
|
|
self
.
left
=
=
0
{
return
None
;
}
let
result
=
self
.
reader
.
read
(
)
;
self
.
err
=
result
.
is_err
(
)
;
self
.
left
-
=
1
;
Some
(
result
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
count
=
self
.
reader
.
get_count
(
)
as
usize
;
(
count
Some
(
count
)
)
}
}
impl
<
'
a
>
LocalsIterator
<
'
a
>
{
pub
fn
into_binary_reader_for_operators
(
self
)
-
>
BinaryReader
<
'
a
>
{
debug_assert
!
(
self
.
err
|
|
self
.
left
=
=
0
)
;
self
.
reader
.
get_binary_reader
(
)
}
pub
fn
into_operators_reader
(
self
)
-
>
OperatorsReader
<
'
a
>
{
OperatorsReader
:
:
new
(
self
.
reader
.
get_binary_reader
(
)
)
}
}
