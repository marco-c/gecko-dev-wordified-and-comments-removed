use
crate
:
:
{
BinaryReader
ComponentExternalKind
ComponentValType
FromReader
Result
SectionLimited
}
;
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
TypeBounds
{
Eq
(
u32
)
SubResource
}
impl
<
'
a
>
FromReader
<
'
a
>
for
TypeBounds
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
Ok
(
match
reader
.
read_u8
(
)
?
{
0x00
=
>
TypeBounds
:
:
Eq
(
reader
.
read
(
)
?
)
0x01
=
>
TypeBounds
:
:
SubResource
x
=
>
return
reader
.
invalid_leading_byte
(
x
"
type
bound
"
)
}
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
ComponentTypeRef
{
Module
(
u32
)
Func
(
u32
)
Value
(
ComponentValType
)
Type
(
TypeBounds
)
Instance
(
u32
)
Component
(
u32
)
}
impl
ComponentTypeRef
{
pub
fn
kind
(
&
self
)
-
>
ComponentExternalKind
{
match
self
{
ComponentTypeRef
:
:
Module
(
_
)
=
>
ComponentExternalKind
:
:
Module
ComponentTypeRef
:
:
Func
(
_
)
=
>
ComponentExternalKind
:
:
Func
ComponentTypeRef
:
:
Value
(
_
)
=
>
ComponentExternalKind
:
:
Value
ComponentTypeRef
:
:
Type
(
.
.
)
=
>
ComponentExternalKind
:
:
Type
ComponentTypeRef
:
:
Instance
(
_
)
=
>
ComponentExternalKind
:
:
Instance
ComponentTypeRef
:
:
Component
(
_
)
=
>
ComponentExternalKind
:
:
Component
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
ComponentTypeRef
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
Ok
(
match
reader
.
read
(
)
?
{
ComponentExternalKind
:
:
Module
=
>
ComponentTypeRef
:
:
Module
(
reader
.
read
(
)
?
)
ComponentExternalKind
:
:
Func
=
>
ComponentTypeRef
:
:
Func
(
reader
.
read
(
)
?
)
ComponentExternalKind
:
:
Value
=
>
ComponentTypeRef
:
:
Value
(
reader
.
read
(
)
?
)
ComponentExternalKind
:
:
Type
=
>
ComponentTypeRef
:
:
Type
(
reader
.
read
(
)
?
)
ComponentExternalKind
:
:
Instance
=
>
ComponentTypeRef
:
:
Instance
(
reader
.
read
(
)
?
)
ComponentExternalKind
:
:
Component
=
>
ComponentTypeRef
:
:
Component
(
reader
.
read
(
)
?
)
}
)
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
ComponentImport
<
'
a
>
{
pub
name
:
ComponentExternName
<
'
a
>
pub
ty
:
ComponentTypeRef
}
impl
<
'
a
>
FromReader
<
'
a
>
for
ComponentImport
<
'
a
>
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
Ok
(
ComponentImport
{
name
:
reader
.
read
(
)
?
ty
:
reader
.
read
(
)
?
}
)
}
}
pub
type
ComponentImportSectionReader
<
'
a
>
=
SectionLimited
<
'
a
ComponentImport
<
'
a
>
>
;
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
ComponentExternName
<
'
a
>
{
Kebab
(
&
'
a
str
)
Interface
(
&
'
a
str
)
}
impl
<
'
a
>
ComponentExternName
<
'
a
>
{
pub
fn
as_str
(
&
self
)
-
>
&
'
a
str
{
match
self
{
ComponentExternName
:
:
Kebab
(
name
)
=
>
name
ComponentExternName
:
:
Interface
(
name
)
=
>
name
}
}
}
impl
<
'
a
>
FromReader
<
'
a
>
for
ComponentExternName
<
'
a
>
{
fn
from_reader
(
reader
:
&
mut
BinaryReader
<
'
a
>
)
-
>
Result
<
Self
>
{
Ok
(
match
reader
.
read_u8
(
)
?
{
0x00
=
>
ComponentExternName
:
:
Kebab
(
reader
.
read
(
)
?
)
0x01
=
>
ComponentExternName
:
:
Interface
(
reader
.
read
(
)
?
)
x
=
>
return
reader
.
invalid_leading_byte
(
x
"
import
name
"
)
}
)
}
}
