use
super
:
:
{
check_max
component_types
:
:
{
Abi
AliasableResourceId
ComponentAnyTypeId
ComponentCoreInstanceTypeId
ComponentCoreModuleTypeId
ComponentCoreTypeId
ComponentDefinedType
ComponentDefinedTypeId
ComponentEntityType
ComponentFuncType
ComponentFuncTypeId
ComponentInstanceType
ComponentInstanceTypeId
ComponentType
ComponentTypeId
ComponentValType
Context
CoreInstanceTypeKind
InstanceType
LoweringInfo
ModuleType
RecordType
Remap
Remapping
ResourceId
SubtypeCx
TupleType
VariantCase
VariantType
}
core
:
:
{
InternRecGroup
Module
}
types
:
:
{
CoreTypeId
EntityType
TypeAlloc
TypeInfo
TypeList
}
}
;
use
crate
:
:
collections
:
:
index_map
:
:
Entry
;
use
crate
:
:
limits
:
:
*
;
use
crate
:
:
prelude
:
:
*
;
use
crate
:
:
validator
:
:
names
:
:
{
ComponentName
ComponentNameKind
KebabStr
KebabString
}
;
use
crate
:
:
{
BinaryReaderError
CanonicalOption
ComponentExportName
ComponentExternalKind
ComponentOuterAliasKind
ComponentTypeRef
CompositeInnerType
ExternalKind
FuncType
GlobalType
InstantiationArgKind
MemoryType
PackedIndex
RefType
Result
SubType
TableType
TypeBounds
ValType
WasmFeatures
}
;
use
core
:
:
mem
;
fn
to_kebab_str
<
'
a
>
(
s
:
&
'
a
str
desc
:
&
str
offset
:
usize
)
-
>
Result
<
&
'
a
KebabStr
>
{
match
KebabStr
:
:
new
(
s
)
{
Some
(
s
)
=
>
Ok
(
s
)
None
=
>
{
if
s
.
is_empty
(
)
{
bail
!
(
offset
"
{
desc
}
name
cannot
be
empty
"
)
;
}
bail
!
(
offset
"
{
desc
}
name
{
s
}
is
not
in
kebab
case
"
)
;
}
}
}
pub
(
crate
)
struct
ComponentState
{
kind
:
ComponentKind
pub
core_types
:
Vec
<
ComponentCoreTypeId
>
pub
core_funcs
:
Vec
<
CoreTypeId
>
pub
core_tags
:
Vec
<
CoreTypeId
>
pub
core_modules
:
Vec
<
ComponentCoreModuleTypeId
>
pub
core_instances
:
Vec
<
ComponentCoreInstanceTypeId
>
pub
core_memories
:
Vec
<
MemoryType
>
pub
core_tables
:
Vec
<
TableType
>
pub
core_globals
:
Vec
<
GlobalType
>
pub
types
:
Vec
<
ComponentAnyTypeId
>
pub
funcs
:
Vec
<
ComponentFuncTypeId
>
pub
values
:
Vec
<
(
ComponentValType
bool
)
>
pub
instances
:
Vec
<
ComponentInstanceTypeId
>
pub
components
:
Vec
<
ComponentTypeId
>
pub
imports
:
IndexMap
<
String
ComponentEntityType
>
pub
import_names
:
IndexSet
<
ComponentName
>
pub
exports
:
IndexMap
<
String
ComponentEntityType
>
pub
export_names
:
IndexSet
<
ComponentName
>
has_start
:
bool
type_info
:
TypeInfo
imported_resources
:
IndexMapAppendOnly
<
ResourceId
Vec
<
usize
>
>
defined_resources
:
IndexMapAppendOnly
<
ResourceId
Option
<
ValType
>
>
explicit_resources
:
IndexMap
<
ResourceId
Vec
<
usize
>
>
exported_types
:
Set
<
ComponentAnyTypeId
>
imported_types
:
Set
<
ComponentAnyTypeId
>
toplevel_exported_resources
:
ComponentNameContext
toplevel_imported_resources
:
ComponentNameContext
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
pub
enum
ComponentKind
{
Component
InstanceType
ComponentType
}
#
[
derive
(
Default
)
]
struct
ComponentNameContext
{
resource_name_map
:
Map
<
AliasableResourceId
usize
>
all_resource_names
:
IndexSet
<
String
>
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
enum
ExternKind
{
Import
Export
}
impl
ExternKind
{
pub
fn
desc
(
&
self
)
-
>
&
'
static
str
{
match
self
{
ExternKind
:
:
Import
=
>
"
import
"
ExternKind
:
:
Export
=
>
"
export
"
}
}
}
impl
ComponentState
{
pub
fn
new
(
kind
:
ComponentKind
)
-
>
Self
{
Self
{
kind
core_types
:
Default
:
:
default
(
)
core_modules
:
Default
:
:
default
(
)
core_instances
:
Default
:
:
default
(
)
core_funcs
:
Default
:
:
default
(
)
core_memories
:
Default
:
:
default
(
)
core_tables
:
Default
:
:
default
(
)
core_globals
:
Default
:
:
default
(
)
core_tags
:
Default
:
:
default
(
)
types
:
Default
:
:
default
(
)
funcs
:
Default
:
:
default
(
)
values
:
Default
:
:
default
(
)
instances
:
Default
:
:
default
(
)
components
:
Default
:
:
default
(
)
imports
:
Default
:
:
default
(
)
exports
:
Default
:
:
default
(
)
import_names
:
Default
:
:
default
(
)
export_names
:
Default
:
:
default
(
)
has_start
:
Default
:
:
default
(
)
type_info
:
TypeInfo
:
:
new
(
)
imported_resources
:
Default
:
:
default
(
)
defined_resources
:
Default
:
:
default
(
)
explicit_resources
:
Default
:
:
default
(
)
exported_types
:
Default
:
:
default
(
)
imported_types
:
Default
:
:
default
(
)
toplevel_exported_resources
:
Default
:
:
default
(
)
toplevel_imported_resources
:
Default
:
:
default
(
)
}
}
pub
fn
type_count
(
&
self
)
-
>
usize
{
self
.
core_types
.
len
(
)
+
self
.
types
.
len
(
)
}
pub
fn
instance_count
(
&
self
)
-
>
usize
{
self
.
core_instances
.
len
(
)
+
self
.
instances
.
len
(
)
}
pub
fn
function_count
(
&
self
)
-
>
usize
{
self
.
core_funcs
.
len
(
)
+
self
.
funcs
.
len
(
)
}
pub
fn
add_core_type
(
components
:
&
mut
[
Self
]
ty
:
crate
:
:
CoreType
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
check_limit
:
bool
)
-
>
Result
<
(
)
>
{
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
if
check_limit
{
check_max
(
current
.
type_count
(
)
1
MAX_WASM_TYPES
"
types
"
offset
)
?
;
}
match
ty
{
crate
:
:
CoreType
:
:
Rec
(
rec
)
=
>
{
current
.
canonicalize_and_intern_rec_group
(
features
types
rec
offset
)
?
;
}
crate
:
:
CoreType
:
:
Module
(
decls
)
=
>
{
let
mod_ty
=
Self
:
:
create_module_type
(
components
decls
.
into_vec
(
)
features
types
offset
)
?
;
let
id
=
ComponentCoreTypeId
:
:
Module
(
types
.
push_ty
(
mod_ty
)
)
;
components
.
last_mut
(
)
.
unwrap
(
)
.
core_types
.
push
(
id
)
;
}
}
Ok
(
(
)
)
}
pub
fn
add_core_module
(
&
mut
self
module
:
&
Module
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
imports
=
module
.
imports_for_module_type
(
offset
)
?
;
let
mod_ty
=
ModuleType
{
info
:
TypeInfo
:
:
core
(
module
.
type_size
)
imports
exports
:
module
.
exports
.
clone
(
)
}
;
let
mod_id
=
types
.
push_ty
(
mod_ty
)
;
self
.
core_modules
.
push
(
mod_id
)
;
Ok
(
(
)
)
}
pub
fn
add_core_instance
(
&
mut
self
instance
:
crate
:
:
Instance
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
instance
=
match
instance
{
crate
:
:
Instance
:
:
Instantiate
{
module_index
args
}
=
>
{
self
.
instantiate_core_module
(
module_index
args
.
into_vec
(
)
types
offset
)
?
}
crate
:
:
Instance
:
:
FromExports
(
exports
)
=
>
{
self
.
instantiate_core_exports
(
exports
.
into_vec
(
)
types
offset
)
?
}
}
;
self
.
core_instances
.
push
(
instance
)
;
Ok
(
(
)
)
}
pub
fn
add_type
(
components
:
&
mut
Vec
<
Self
>
ty
:
crate
:
:
ComponentType
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
check_limit
:
bool
)
-
>
Result
<
(
)
>
{
assert
!
(
!
components
.
is_empty
(
)
)
;
fn
current
(
components
:
&
mut
Vec
<
ComponentState
>
)
-
>
&
mut
ComponentState
{
components
.
last_mut
(
)
.
unwrap
(
)
}
let
id
=
match
ty
{
crate
:
:
ComponentType
:
:
Defined
(
ty
)
=
>
{
let
ty
=
current
(
components
)
.
create_defined_type
(
ty
types
features
offset
)
?
;
types
.
push
(
ty
)
.
into
(
)
}
crate
:
:
ComponentType
:
:
Func
(
ty
)
=
>
{
let
ty
=
current
(
components
)
.
create_function_type
(
ty
types
features
offset
)
?
;
types
.
push
(
ty
)
.
into
(
)
}
crate
:
:
ComponentType
:
:
Component
(
decls
)
=
>
{
let
ty
=
Self
:
:
create_component_type
(
components
decls
.
into_vec
(
)
features
types
offset
)
?
;
types
.
push
(
ty
)
.
into
(
)
}
crate
:
:
ComponentType
:
:
Instance
(
decls
)
=
>
{
let
ty
=
Self
:
:
create_instance_type
(
components
decls
.
into_vec
(
)
features
types
offset
)
?
;
types
.
push
(
ty
)
.
into
(
)
}
crate
:
:
ComponentType
:
:
Resource
{
rep
dtor
}
=
>
{
let
component
=
current
(
components
)
;
if
component
.
kind
!
=
ComponentKind
:
:
Component
{
bail
!
(
offset
"
resources
can
only
be
defined
within
a
concrete
component
"
)
;
}
if
rep
!
=
ValType
:
:
I32
{
bail
!
(
offset
"
resources
can
only
be
represented
by
i32
"
)
;
}
if
let
Some
(
dtor
)
=
dtor
{
let
ty
=
component
.
core_function_at
(
dtor
offset
)
?
;
let
ty
=
types
[
ty
]
.
composite_type
.
unwrap_func
(
)
;
if
ty
.
params
(
)
!
=
[
rep
]
|
|
ty
.
results
(
)
!
=
[
]
{
bail
!
(
offset
"
core
function
{
dtor
}
has
wrong
signature
for
a
destructor
"
)
;
}
}
let
id
=
types
.
alloc_resource_id
(
)
;
component
.
defined_resources
.
insert
(
id
.
resource
(
)
Some
(
rep
)
)
;
id
.
into
(
)
}
}
;
let
current
=
current
(
components
)
;
if
check_limit
{
check_max
(
current
.
type_count
(
)
1
MAX_WASM_TYPES
"
types
"
offset
)
?
;
}
current
.
types
.
push
(
id
)
;
Ok
(
(
)
)
}
pub
fn
add_import
(
&
mut
self
import
:
crate
:
:
ComponentImport
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
mut
entity
=
self
.
check_type_ref
(
&
import
.
ty
features
types
offset
)
?
;
self
.
add_entity
(
&
mut
entity
Some
(
(
import
.
name
.
0
ExternKind
:
:
Import
)
)
features
types
offset
)
?
;
self
.
toplevel_imported_resources
.
validate_extern
(
import
.
name
.
0
ExternKind
:
:
Import
&
entity
types
offset
&
mut
self
.
import_names
&
mut
self
.
imports
&
mut
self
.
type_info
features
)
?
;
Ok
(
(
)
)
}
fn
add_entity
(
&
mut
self
ty
:
&
mut
ComponentEntityType
name_and_kind
:
Option
<
(
&
str
ExternKind
)
>
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
kind
=
name_and_kind
.
map
(
|
(
_
k
)
|
k
)
;
let
(
len
max
desc
)
=
match
ty
{
ComponentEntityType
:
:
Module
(
id
)
=
>
{
self
.
core_modules
.
push
(
*
id
)
;
(
self
.
core_modules
.
len
(
)
MAX_WASM_MODULES
"
modules
"
)
}
ComponentEntityType
:
:
Component
(
id
)
=
>
{
self
.
components
.
push
(
*
id
)
;
(
self
.
components
.
len
(
)
MAX_WASM_COMPONENTS
"
components
"
)
}
ComponentEntityType
:
:
Instance
(
id
)
=
>
{
match
kind
{
Some
(
ExternKind
:
:
Import
)
=
>
self
.
prepare_instance_import
(
id
types
)
Some
(
ExternKind
:
:
Export
)
=
>
self
.
prepare_instance_export
(
id
types
)
None
=
>
{
}
}
self
.
instances
.
push
(
*
id
)
;
(
self
.
instance_count
(
)
MAX_WASM_INSTANCES
"
instances
"
)
}
ComponentEntityType
:
:
Func
(
id
)
=
>
{
self
.
funcs
.
push
(
*
id
)
;
(
self
.
function_count
(
)
MAX_WASM_FUNCTIONS
"
functions
"
)
}
ComponentEntityType
:
:
Value
(
ty
)
=
>
{
self
.
check_value_support
(
features
offset
)
?
;
let
value_used
=
match
kind
{
Some
(
ExternKind
:
:
Import
)
|
None
=
>
false
Some
(
ExternKind
:
:
Export
)
=
>
true
}
;
self
.
values
.
push
(
(
*
ty
value_used
)
)
;
(
self
.
values
.
len
(
)
MAX_WASM_VALUES
"
values
"
)
}
ComponentEntityType
:
:
Type
{
created
referenced
}
=
>
{
self
.
types
.
push
(
*
created
)
;
if
let
ComponentAnyTypeId
:
:
Resource
(
id
)
=
*
created
{
match
kind
{
Some
(
ExternKind
:
:
Import
)
=
>
{
if
created
=
=
referenced
{
self
.
imported_resources
.
insert
(
id
.
resource
(
)
vec
!
[
self
.
imports
.
len
(
)
]
)
;
}
}
Some
(
ExternKind
:
:
Export
)
=
>
{
if
created
=
=
referenced
{
self
.
defined_resources
.
insert
(
id
.
resource
(
)
None
)
;
}
self
.
explicit_resources
.
insert
(
id
.
resource
(
)
vec
!
[
self
.
exports
.
len
(
)
]
)
;
}
None
=
>
{
}
}
}
(
self
.
types
.
len
(
)
MAX_WASM_TYPES
"
types
"
)
}
}
;
check_max
(
len
0
max
desc
offset
)
?
;
if
let
Some
(
(
name
kind
)
)
=
name_and_kind
{
if
!
self
.
validate_and_register_named_types
(
Some
(
name
)
kind
ty
types
)
{
bail
!
(
offset
"
{
}
not
valid
to
be
used
as
{
}
"
ty
.
desc
(
)
kind
.
desc
(
)
)
;
}
}
Ok
(
(
)
)
}
fn
validate_and_register_named_types
(
&
mut
self
toplevel_name
:
Option
<
&
str
>
kind
:
ExternKind
ty
:
&
ComponentEntityType
types
:
&
TypeAlloc
)
-
>
bool
{
if
let
ComponentEntityType
:
:
Type
{
created
.
.
}
=
ty
{
if
let
Some
(
name
)
=
toplevel_name
{
if
let
ComponentAnyTypeId
:
:
Resource
(
id
)
=
*
created
{
let
cx
=
match
kind
{
ExternKind
:
:
Import
=
>
&
mut
self
.
toplevel_imported_resources
ExternKind
:
:
Export
=
>
&
mut
self
.
toplevel_exported_resources
}
;
cx
.
register
(
name
id
)
;
}
}
}
match
self
.
kind
{
ComponentKind
:
:
Component
|
ComponentKind
:
:
ComponentType
=
>
{
}
ComponentKind
:
:
InstanceType
=
>
return
true
}
let
set
=
match
kind
{
ExternKind
:
:
Import
=
>
&
self
.
imported_types
ExternKind
:
:
Export
=
>
&
self
.
exported_types
}
;
match
ty
{
ComponentEntityType
:
:
Type
{
created
referenced
}
=
>
{
if
!
self
.
all_valtypes_named
(
types
*
referenced
set
)
{
return
false
;
}
match
kind
{
ExternKind
:
:
Import
=
>
{
self
.
imported_types
.
insert
(
*
created
)
;
self
.
exported_types
.
insert
(
*
created
)
;
}
ExternKind
:
:
Export
=
>
{
self
.
exported_types
.
insert
(
*
created
)
;
}
}
true
}
ComponentEntityType
:
:
Instance
(
i
)
=
>
types
[
*
i
]
.
exports
.
iter
(
)
.
all
(
|
(
_name
ty
)
|
self
.
validate_and_register_named_types
(
None
kind
ty
types
)
)
ComponentEntityType
:
:
Func
(
id
)
=
>
self
.
all_valtypes_named_in_func
(
types
*
id
set
)
ComponentEntityType
:
:
Value
(
ty
)
=
>
types
.
type_named_valtype
(
ty
set
)
ComponentEntityType
:
:
Component
(
_
)
|
ComponentEntityType
:
:
Module
(
_
)
=
>
true
}
}
fn
all_valtypes_named
(
&
self
types
:
&
TypeAlloc
id
:
ComponentAnyTypeId
set
:
&
Set
<
ComponentAnyTypeId
>
)
-
>
bool
{
match
id
{
ComponentAnyTypeId
:
:
Resource
(
_
)
=
>
true
ComponentAnyTypeId
:
:
Component
(
_
)
=
>
true
ComponentAnyTypeId
:
:
Defined
(
id
)
=
>
self
.
all_valtypes_named_in_defined
(
types
id
set
)
ComponentAnyTypeId
:
:
Func
(
id
)
=
>
self
.
all_valtypes_named_in_func
(
types
id
set
)
ComponentAnyTypeId
:
:
Instance
(
id
)
=
>
self
.
all_valtypes_named_in_instance
(
types
id
set
)
}
}
fn
all_valtypes_named_in_instance
(
&
self
types
:
&
TypeAlloc
id
:
ComponentInstanceTypeId
set
:
&
Set
<
ComponentAnyTypeId
>
)
-
>
bool
{
let
ty
=
&
types
[
id
]
;
ty
.
exports
.
values
(
)
.
all
(
|
ty
|
match
ty
{
ComponentEntityType
:
:
Module
(
_
)
=
>
true
ComponentEntityType
:
:
Func
(
id
)
=
>
self
.
all_valtypes_named_in_func
(
types
*
id
set
)
ComponentEntityType
:
:
Type
{
created
:
id
.
.
}
=
>
{
self
.
all_valtypes_named
(
types
*
id
set
)
}
ComponentEntityType
:
:
Value
(
ComponentValType
:
:
Type
(
id
)
)
=
>
{
self
.
all_valtypes_named_in_defined
(
types
*
id
set
)
}
ComponentEntityType
:
:
Instance
(
id
)
=
>
{
self
.
all_valtypes_named_in_instance
(
types
*
id
set
)
}
ComponentEntityType
:
:
Component
(
_
)
|
ComponentEntityType
:
:
Value
(
ComponentValType
:
:
Primitive
(
_
)
)
=
>
return
true
}
)
}
fn
all_valtypes_named_in_defined
(
&
self
types
:
&
TypeAlloc
id
:
ComponentDefinedTypeId
set
:
&
Set
<
ComponentAnyTypeId
>
)
-
>
bool
{
let
ty
=
&
types
[
id
]
;
match
ty
{
ComponentDefinedType
:
:
Primitive
(
_
)
|
ComponentDefinedType
:
:
Flags
(
_
)
|
ComponentDefinedType
:
:
Enum
(
_
)
|
ComponentDefinedType
:
:
ErrorContext
=
>
true
ComponentDefinedType
:
:
Record
(
r
)
=
>
{
r
.
fields
.
values
(
)
.
all
(
|
t
|
types
.
type_named_valtype
(
t
set
)
)
}
ComponentDefinedType
:
:
Tuple
(
r
)
=
>
{
r
.
types
.
iter
(
)
.
all
(
|
t
|
types
.
type_named_valtype
(
t
set
)
)
}
ComponentDefinedType
:
:
Variant
(
r
)
=
>
r
.
cases
.
values
(
)
.
filter_map
(
|
t
|
t
.
ty
.
as_ref
(
)
)
.
all
(
|
t
|
types
.
type_named_valtype
(
t
set
)
)
ComponentDefinedType
:
:
Result
{
ok
err
}
=
>
{
ok
.
as_ref
(
)
.
map
(
|
t
|
types
.
type_named_valtype
(
t
set
)
)
.
unwrap_or
(
true
)
&
&
err
.
as_ref
(
)
.
map
(
|
t
|
types
.
type_named_valtype
(
t
set
)
)
.
unwrap_or
(
true
)
}
ComponentDefinedType
:
:
List
(
ty
)
|
ComponentDefinedType
:
:
Option
(
ty
)
=
>
{
types
.
type_named_valtype
(
ty
set
)
}
ComponentDefinedType
:
:
Own
(
id
)
|
ComponentDefinedType
:
:
Borrow
(
id
)
=
>
{
set
.
contains
(
&
ComponentAnyTypeId
:
:
from
(
*
id
)
)
}
ComponentDefinedType
:
:
Future
(
ty
)
=
>
ty
.
as_ref
(
)
.
map
(
|
ty
|
types
.
type_named_valtype
(
ty
set
)
)
.
unwrap_or
(
true
)
ComponentDefinedType
:
:
Stream
(
ty
)
=
>
ty
.
as_ref
(
)
.
map
(
|
ty
|
types
.
type_named_valtype
(
ty
set
)
)
.
unwrap_or
(
true
)
}
}
fn
all_valtypes_named_in_func
(
&
self
types
:
&
TypeAlloc
id
:
ComponentFuncTypeId
set
:
&
Set
<
ComponentAnyTypeId
>
)
-
>
bool
{
let
ty
=
&
types
[
id
]
;
ty
.
params
.
iter
(
)
.
map
(
|
(
_
ty
)
|
ty
)
.
chain
(
ty
.
results
.
iter
(
)
.
map
(
|
(
_
ty
)
|
ty
)
)
.
all
(
|
ty
|
types
.
type_named_valtype
(
ty
set
)
)
}
fn
prepare_instance_import
(
&
mut
self
id
:
&
mut
ComponentInstanceTypeId
types
:
&
mut
TypeAlloc
)
{
let
ty
=
&
types
[
*
id
]
;
if
ty
.
defined_resources
.
is_empty
(
)
{
return
;
}
let
mut
new_ty
=
ComponentInstanceType
{
info
:
ty
.
info
exports
:
ty
.
exports
.
clone
(
)
explicit_resources
:
ty
.
explicit_resources
.
clone
(
)
defined_resources
:
Default
:
:
default
(
)
}
;
let
resources
=
(
0
.
.
ty
.
defined_resources
.
len
(
)
)
.
map
(
|
_
|
types
.
alloc_resource_id
(
)
)
.
collect
:
:
<
IndexSet
<
_
>
>
(
)
;
let
mut
mapping
=
Remapping
:
:
default
(
)
;
let
ty
=
&
types
[
*
id
]
;
for
(
old
new
)
in
ty
.
defined_resources
.
iter
(
)
.
zip
(
&
resources
)
{
let
prev
=
mapping
.
resources
.
insert
(
*
old
new
.
resource
(
)
)
;
assert
!
(
prev
.
is_none
(
)
)
;
let
mut
base
=
vec
!
[
self
.
imports
.
len
(
)
]
;
base
.
extend
(
ty
.
explicit_resources
[
old
]
.
iter
(
)
.
copied
(
)
)
;
self
.
imported_resources
.
insert
(
new
.
resource
(
)
base
)
;
}
for
ty
in
new_ty
.
exports
.
values_mut
(
)
{
types
.
remap_component_entity
(
ty
&
mut
mapping
)
;
}
for
(
id
path
)
in
mem
:
:
take
(
&
mut
new_ty
.
explicit_resources
)
{
let
id
=
*
mapping
.
resources
.
get
(
&
id
)
.
unwrap_or
(
&
id
)
;
new_ty
.
explicit_resources
.
insert
(
id
path
)
;
}
*
id
=
types
.
push_ty
(
new_ty
)
;
}
fn
prepare_instance_export
(
&
mut
self
id
:
&
mut
ComponentInstanceTypeId
types
:
&
mut
TypeAlloc
)
{
let
ty
=
&
types
[
*
id
]
;
if
!
ty
.
defined_resources
.
is_empty
(
)
{
let
mut
new_ty
=
ty
.
clone
(
)
;
let
mut
mapping
=
Remapping
:
:
default
(
)
;
for
old
in
mem
:
:
take
(
&
mut
new_ty
.
defined_resources
)
{
let
new
=
types
.
alloc_resource_id
(
)
;
mapping
.
resources
.
insert
(
old
new
.
resource
(
)
)
;
self
.
defined_resources
.
insert
(
new
.
resource
(
)
None
)
;
}
for
ty
in
new_ty
.
exports
.
values_mut
(
)
{
types
.
remap_component_entity
(
ty
&
mut
mapping
)
;
}
for
(
id
path
)
in
mem
:
:
take
(
&
mut
new_ty
.
explicit_resources
)
{
let
id
=
mapping
.
resources
.
get
(
&
id
)
.
copied
(
)
.
unwrap_or
(
id
)
;
new_ty
.
explicit_resources
.
insert
(
id
path
)
;
}
*
id
=
types
.
push_ty
(
new_ty
)
;
}
let
ty
=
&
types
[
*
id
]
;
for
(
id
path
)
in
ty
.
explicit_resources
.
iter
(
)
{
let
mut
new_path
=
vec
!
[
self
.
exports
.
len
(
)
]
;
new_path
.
extend
(
path
)
;
self
.
explicit_resources
.
insert
(
*
id
new_path
)
;
}
}
pub
fn
add_export
(
&
mut
self
name
:
ComponentExportName
<
'
_
>
mut
ty
:
ComponentEntityType
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
check_limit
:
bool
)
-
>
Result
<
(
)
>
{
if
check_limit
{
check_max
(
self
.
exports
.
len
(
)
1
MAX_WASM_EXPORTS
"
exports
"
offset
)
?
;
}
self
.
add_entity
(
&
mut
ty
Some
(
(
name
.
0
ExternKind
:
:
Export
)
)
features
types
offset
)
?
;
self
.
toplevel_exported_resources
.
validate_extern
(
name
.
0
ExternKind
:
:
Export
&
ty
types
offset
&
mut
self
.
export_names
&
mut
self
.
exports
&
mut
self
.
type_info
features
)
?
;
Ok
(
(
)
)
}
pub
fn
lift_function
(
&
mut
self
core_func_index
:
u32
type_index
:
u32
options
:
Vec
<
CanonicalOption
>
types
:
&
TypeList
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
let
ty
=
self
.
function_type_at
(
type_index
types
offset
)
?
;
let
core_ty
=
types
[
self
.
core_function_at
(
core_func_index
offset
)
?
]
.
unwrap_func
(
)
;
let
info
=
ty
.
lower
(
types
if
options
.
contains
(
&
CanonicalOption
:
:
Async
)
{
if
options
.
iter
(
)
.
any
(
|
v
|
matches
!
(
v
CanonicalOption
:
:
Callback
(
_
)
)
)
{
Abi
:
:
LiftAsync
}
else
{
Abi
:
:
LiftAsyncStackful
}
}
else
{
Abi
:
:
LiftSync
}
)
;
self
.
check_options
(
Some
(
core_ty
)
&
info
&
options
types
offset
features
true
)
?
;
if
core_ty
.
params
(
)
!
=
info
.
params
.
as_slice
(
)
{
bail
!
(
offset
"
lowered
parameter
types
{
:
?
}
do
not
match
parameter
types
\
{
:
?
}
of
core
function
{
core_func_index
}
"
info
.
params
.
as_slice
(
)
core_ty
.
params
(
)
)
;
}
if
core_ty
.
results
(
)
!
=
info
.
results
.
as_slice
(
)
{
bail
!
(
offset
"
lowered
result
types
{
:
?
}
do
not
match
result
types
\
{
:
?
}
of
core
function
{
core_func_index
}
"
info
.
results
.
as_slice
(
)
core_ty
.
results
(
)
)
;
}
self
.
funcs
.
push
(
self
.
types
[
type_index
as
usize
]
.
unwrap_func
(
)
)
;
Ok
(
(
)
)
}
pub
fn
lower_function
(
&
mut
self
func_index
:
u32
options
:
Vec
<
CanonicalOption
>
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
let
ty
=
&
types
[
self
.
function_at
(
func_index
offset
)
?
]
;
let
info
=
ty
.
lower
(
types
if
options
.
contains
(
&
CanonicalOption
:
:
Async
)
{
Abi
:
:
LowerAsync
}
else
{
Abi
:
:
LowerSync
}
)
;
self
.
check_options
(
None
&
info
&
options
types
offset
features
true
)
?
;
let
id
=
types
.
intern_func_type
(
info
.
into_func_type
(
)
offset
)
;
self
.
core_funcs
.
push
(
id
)
;
Ok
(
(
)
)
}
pub
fn
resource_new
(
&
mut
self
resource
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
rep
=
self
.
check_local_resource
(
resource
types
offset
)
?
;
let
id
=
types
.
intern_func_type
(
FuncType
:
:
new
(
[
rep
]
[
ValType
:
:
I32
]
)
offset
)
;
self
.
core_funcs
.
push
(
id
)
;
Ok
(
(
)
)
}
pub
fn
resource_drop
(
&
mut
self
resource
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
self
.
resource_at
(
resource
types
offset
)
?
;
let
id
=
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
]
)
offset
)
;
self
.
core_funcs
.
push
(
id
)
;
Ok
(
(
)
)
}
pub
fn
resource_rep
(
&
mut
self
resource
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
rep
=
self
.
check_local_resource
(
resource
types
offset
)
?
;
let
id
=
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
rep
]
)
offset
)
;
self
.
core_funcs
.
push
(
id
)
;
Ok
(
(
)
)
}
pub
fn
task_backpressure
(
&
mut
self
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
task
.
backpressure
requires
the
component
model
async
feature
"
)
}
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
task_return
(
&
mut
self
result
:
&
Option
<
crate
:
:
ComponentValType
>
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
task
.
return
requires
the
component
model
async
feature
"
)
}
let
info
=
ComponentFuncType
{
info
:
TypeInfo
:
:
new
(
)
params
:
result
.
iter
(
)
.
map
(
|
ty
|
{
Ok
(
(
KebabString
:
:
new
(
"
v
"
)
.
unwrap
(
)
match
ty
{
crate
:
:
ComponentValType
:
:
Primitive
(
ty
)
=
>
{
ComponentValType
:
:
Primitive
(
*
ty
)
}
crate
:
:
ComponentValType
:
:
Type
(
index
)
=
>
{
ComponentValType
:
:
Type
(
self
.
defined_type_at
(
*
index
offset
)
?
)
}
}
)
)
}
)
.
collect
:
:
<
Result
<
_
>
>
(
)
?
results
:
Box
:
:
new
(
[
]
)
}
.
lower
(
types
Abi
:
:
LiftSync
)
;
assert
!
(
info
.
results
.
iter
(
)
.
next
(
)
.
is_none
(
)
)
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
info
.
params
.
iter
(
)
[
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
task_wait
(
&
mut
self
_async_
:
bool
memory
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
task
.
wait
requires
the
component
model
async
feature
"
)
}
self
.
memory_at
(
memory
offset
)
?
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
task_poll
(
&
mut
self
_async_
:
bool
memory
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
task
.
poll
requires
the
component
model
async
feature
"
)
}
self
.
memory_at
(
memory
offset
)
?
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
task_yield
(
&
mut
self
_async_
:
bool
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
task
.
yield
requires
the
component
model
async
feature
"
)
}
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
]
[
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
subtask_drop
(
&
mut
self
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
subtask
.
drop
requires
the
component
model
async
feature
"
)
}
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
stream_new
(
&
mut
self
ty
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
stream
.
new
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Stream
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
stream
.
new
requires
a
stream
type
"
)
}
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
stream_read
(
&
mut
self
ty
:
u32
options
:
Vec
<
CanonicalOption
>
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
stream
.
read
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Stream
(
payload_type
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
stream
.
read
requires
a
stream
type
"
)
}
;
let
mut
info
=
LoweringInfo
:
:
default
(
)
;
info
.
requires_memory
=
true
;
info
.
requires_realloc
=
payload_type
.
map
(
|
ty
|
ty
.
contains_ptr
(
types
)
)
.
unwrap_or_default
(
)
;
self
.
check_options
(
None
&
info
&
options
types
offset
features
true
)
?
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
;
3
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
stream_write
(
&
mut
self
ty
:
u32
options
:
Vec
<
CanonicalOption
>
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
stream
.
write
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Stream
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
stream
.
write
requires
a
stream
type
"
)
}
;
let
mut
info
=
LoweringInfo
:
:
default
(
)
;
info
.
requires_memory
=
true
;
info
.
requires_realloc
=
false
;
self
.
check_options
(
None
&
info
&
options
types
offset
features
true
)
?
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
;
3
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
stream_cancel_read
(
&
mut
self
ty
:
u32
_async_
:
bool
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
stream
.
cancel
-
read
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Stream
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
stream
.
cancel
-
read
requires
a
stream
type
"
)
}
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
stream_cancel_write
(
&
mut
self
ty
:
u32
_async_
:
bool
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
stream
.
cancel
-
write
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Stream
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
stream
.
cancel
-
write
requires
a
stream
type
"
)
}
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
stream_close_readable
(
&
mut
self
ty
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
stream
.
close
-
readable
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Stream
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
stream
.
close
-
readable
requires
a
stream
type
"
)
}
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
stream_close_writable
(
&
mut
self
ty
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
stream
.
close
-
writable
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Stream
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
stream
.
close
-
writable
requires
a
stream
type
"
)
}
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
;
2
]
[
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
future_new
(
&
mut
self
ty
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
future
.
new
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Future
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
future
.
new
requires
a
future
type
"
)
}
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
future_read
(
&
mut
self
ty
:
u32
options
:
Vec
<
CanonicalOption
>
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
future
.
read
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Future
(
payload_type
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
future
.
read
requires
a
future
type
"
)
}
;
let
mut
info
=
LoweringInfo
:
:
default
(
)
;
info
.
requires_memory
=
true
;
info
.
requires_realloc
=
payload_type
.
map
(
|
ty
|
ty
.
contains_ptr
(
types
)
)
.
unwrap_or_default
(
)
;
self
.
check_options
(
None
&
info
&
options
types
offset
features
true
)
?
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
;
2
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
future_write
(
&
mut
self
ty
:
u32
options
:
Vec
<
CanonicalOption
>
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
future
.
write
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Future
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
future
.
write
requires
a
future
type
"
)
}
;
let
mut
info
=
LoweringInfo
:
:
default
(
)
;
info
.
requires_memory
=
true
;
info
.
requires_realloc
=
false
;
self
.
check_options
(
None
&
info
&
options
types
offset
features
true
)
?
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
;
2
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
future_cancel_read
(
&
mut
self
ty
:
u32
_async_
:
bool
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
future
.
cancel
-
read
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Future
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
future
.
cancel
-
read
requires
a
future
type
"
)
}
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
future_cancel_write
(
&
mut
self
ty
:
u32
_async_
:
bool
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
future
.
cancel
-
write
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Future
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
future
.
cancel
-
write
requires
a
future
type
"
)
}
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
future_close_readable
(
&
mut
self
ty
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
future
.
close
-
readable
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Future
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
future
.
close
-
readable
requires
a
future
type
"
)
}
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
future_close_writable
(
&
mut
self
ty
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
future
.
close
-
writable
requires
the
component
model
async
feature
"
)
}
let
ty
=
self
.
defined_type_at
(
ty
offset
)
?
;
let
ComponentDefinedType
:
:
Future
(
_
)
=
&
types
[
ty
]
else
{
bail
!
(
offset
"
future
.
close
-
writable
requires
a
future
type
"
)
}
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
;
2
]
[
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
error_context_new
(
&
mut
self
options
:
Vec
<
CanonicalOption
>
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
error
-
context
.
new
requires
the
component
model
async
feature
"
)
}
let
mut
info
=
LoweringInfo
:
:
default
(
)
;
info
.
requires_memory
=
true
;
info
.
requires_realloc
=
false
;
self
.
check_options
(
None
&
info
&
options
types
offset
features
false
)
?
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
;
2
]
[
ValType
:
:
I32
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
error_context_debug_message
(
&
mut
self
options
:
Vec
<
CanonicalOption
>
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
error
-
context
.
debug
-
message
requires
the
component
model
async
feature
"
)
}
let
mut
info
=
LoweringInfo
:
:
default
(
)
;
info
.
requires_memory
=
true
;
info
.
requires_realloc
=
true
;
self
.
check_options
(
None
&
info
&
options
types
offset
features
false
)
?
;
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
;
2
]
[
]
)
offset
)
)
;
Ok
(
(
)
)
}
pub
fn
error_context_drop
(
&
mut
self
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
error
-
context
.
drop
requires
the
component
model
async
feature
"
)
}
self
.
core_funcs
.
push
(
types
.
intern_func_type
(
FuncType
:
:
new
(
[
ValType
:
:
I32
]
[
]
)
offset
)
)
;
Ok
(
(
)
)
}
fn
check_local_resource
(
&
self
idx
:
u32
types
:
&
TypeList
offset
:
usize
)
-
>
Result
<
ValType
>
{
let
resource
=
self
.
resource_at
(
idx
types
offset
)
?
;
match
self
.
defined_resources
.
get
(
&
resource
.
resource
(
)
)
.
and_then
(
|
rep
|
*
rep
)
{
Some
(
ty
)
=
>
Ok
(
ty
)
None
=
>
bail
!
(
offset
"
type
{
idx
}
is
not
a
local
resource
"
)
}
}
fn
resource_at
<
'
a
>
(
&
self
idx
:
u32
_types
:
&
'
a
TypeList
offset
:
usize
)
-
>
Result
<
AliasableResourceId
>
{
if
let
ComponentAnyTypeId
:
:
Resource
(
id
)
=
self
.
component_type_at
(
idx
offset
)
?
{
return
Ok
(
id
)
;
}
bail
!
(
offset
"
type
index
{
}
is
not
a
resource
type
"
idx
)
}
pub
fn
thread_spawn
(
&
mut
self
func_ty_index
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
shared_everything_threads
(
)
{
bail
!
(
offset
"
thread
.
spawn
requires
the
shared
-
everything
-
threads
proposal
"
)
}
let
core_type_id
=
match
self
.
core_type_at
(
func_ty_index
offset
)
?
{
ComponentCoreTypeId
:
:
Sub
(
c
)
=
>
c
ComponentCoreTypeId
:
:
Module
(
_
)
=
>
bail
!
(
offset
"
expected
a
core
function
type
"
)
}
;
let
sub_ty
=
&
types
[
core_type_id
]
;
if
!
sub_ty
.
composite_type
.
shared
{
bail
!
(
offset
"
spawn
type
must
be
shared
"
)
;
}
match
&
sub_ty
.
composite_type
.
inner
{
CompositeInnerType
:
:
Func
(
func_ty
)
=
>
{
if
func_ty
.
params
(
)
!
=
[
ValType
:
:
I32
]
{
bail
!
(
offset
"
spawn
function
must
take
a
single
i32
argument
(
currently
)
"
)
;
}
if
func_ty
.
results
(
)
!
=
[
]
{
bail
!
(
offset
"
spawn
function
must
not
return
any
values
"
)
;
}
}
_
=
>
bail
!
(
offset
"
spawn
type
must
be
a
function
"
)
}
let
packed_index
=
PackedIndex
:
:
from_id
(
core_type_id
)
.
ok_or_else
(
|
|
{
format_err
!
(
offset
"
implementation
limit
:
too
many
types
in
TypeList
"
)
}
)
?
;
let
start_func_ref
=
RefType
:
:
concrete
(
true
packed_index
)
;
let
func_ty
=
FuncType
:
:
new
(
[
ValType
:
:
Ref
(
start_func_ref
)
ValType
:
:
I32
]
[
ValType
:
:
I32
]
)
;
let
core_ty
=
SubType
:
:
func
(
func_ty
true
)
;
let
id
=
types
.
intern_sub_type
(
core_ty
offset
)
;
self
.
core_funcs
.
push
(
id
)
;
Ok
(
(
)
)
}
pub
fn
thread_hw_concurrency
(
&
mut
self
types
:
&
mut
TypeAlloc
offset
:
usize
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
if
!
features
.
shared_everything_threads
(
)
{
bail
!
(
offset
"
thread
.
hw_concurrency
requires
the
shared
-
everything
-
threads
proposal
"
)
}
let
func_ty
=
FuncType
:
:
new
(
[
]
[
ValType
:
:
I32
]
)
;
let
core_ty
=
SubType
:
:
func
(
func_ty
true
)
;
let
id
=
types
.
intern_sub_type
(
core_ty
offset
)
;
self
.
core_funcs
.
push
(
id
)
;
Ok
(
(
)
)
}
pub
fn
add_component
(
&
mut
self
component
:
ComponentType
types
:
&
mut
TypeAlloc
)
-
>
Result
<
(
)
>
{
let
id
=
types
.
push_ty
(
component
)
;
self
.
components
.
push
(
id
)
;
Ok
(
(
)
)
}
pub
fn
add_instance
(
&
mut
self
instance
:
crate
:
:
ComponentInstance
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
instance
=
match
instance
{
crate
:
:
ComponentInstance
:
:
Instantiate
{
component_index
args
}
=
>
self
.
instantiate_component
(
component_index
args
.
into_vec
(
)
features
types
offset
)
?
crate
:
:
ComponentInstance
:
:
FromExports
(
exports
)
=
>
{
self
.
instantiate_component_exports
(
exports
.
into_vec
(
)
features
types
offset
)
?
}
}
;
self
.
instances
.
push
(
instance
)
;
Ok
(
(
)
)
}
pub
fn
add_alias
(
components
:
&
mut
[
Self
]
alias
:
crate
:
:
ComponentAlias
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
match
alias
{
crate
:
:
ComponentAlias
:
:
InstanceExport
{
instance_index
kind
name
}
=
>
components
.
last_mut
(
)
.
unwrap
(
)
.
alias_instance_export
(
instance_index
kind
name
features
types
offset
)
crate
:
:
ComponentAlias
:
:
CoreInstanceExport
{
instance_index
kind
name
}
=
>
components
.
last_mut
(
)
.
unwrap
(
)
.
alias_core_instance_export
(
instance_index
kind
name
types
offset
)
crate
:
:
ComponentAlias
:
:
Outer
{
kind
count
index
}
=
>
match
kind
{
ComponentOuterAliasKind
:
:
CoreModule
=
>
{
Self
:
:
alias_module
(
components
count
index
offset
)
}
ComponentOuterAliasKind
:
:
CoreType
=
>
{
Self
:
:
alias_core_type
(
components
count
index
offset
)
}
ComponentOuterAliasKind
:
:
Type
=
>
{
Self
:
:
alias_type
(
components
count
index
types
offset
)
}
ComponentOuterAliasKind
:
:
Component
=
>
{
Self
:
:
alias_component
(
components
count
index
offset
)
}
}
}
}
pub
fn
add_start
(
&
mut
self
func_index
:
u32
args
:
&
[
u32
]
results
:
u32
features
:
&
WasmFeatures
types
:
&
mut
TypeList
offset
:
usize
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_values
(
)
{
bail
!
(
offset
"
support
for
component
model
value
s
is
not
enabled
"
)
;
}
if
self
.
has_start
{
return
Err
(
BinaryReaderError
:
:
new
(
"
component
cannot
have
more
than
one
start
function
"
offset
)
)
;
}
let
ft
=
&
types
[
self
.
function_at
(
func_index
offset
)
?
]
;
if
ft
.
params
.
len
(
)
!
=
args
.
len
(
)
{
bail
!
(
offset
"
component
start
function
requires
{
}
arguments
but
was
given
{
}
"
ft
.
params
.
len
(
)
args
.
len
(
)
)
;
}
if
ft
.
results
.
len
(
)
as
u32
!
=
results
{
bail
!
(
offset
"
component
start
function
has
a
result
count
of
{
results
}
\
but
the
function
type
has
a
result
count
of
{
type_results
}
"
type_results
=
ft
.
results
.
len
(
)
)
;
}
let
cx
=
SubtypeCx
:
:
new
(
types
types
)
;
for
(
i
(
(
_
ty
)
arg
)
)
in
ft
.
params
.
iter
(
)
.
zip
(
args
)
.
enumerate
(
)
{
cx
.
component_val_type
(
self
.
value_at
(
*
arg
offset
)
?
ty
offset
)
.
with_context
(
|
|
{
format
!
(
"
value
type
mismatch
for
component
start
function
argument
{
i
}
"
)
}
)
?
;
}
for
(
_
ty
)
in
ft
.
results
.
iter
(
)
{
self
.
values
.
push
(
(
*
ty
false
)
)
;
}
self
.
has_start
=
true
;
Ok
(
(
)
)
}
fn
check_options
(
&
self
core_ty
:
Option
<
&
FuncType
>
info
:
&
LoweringInfo
options
:
&
[
CanonicalOption
]
types
:
&
TypeList
offset
:
usize
features
:
&
WasmFeatures
allow_async
:
bool
)
-
>
Result
<
(
)
>
{
fn
display
(
option
:
CanonicalOption
)
-
>
&
'
static
str
{
match
option
{
CanonicalOption
:
:
UTF8
=
>
"
utf8
"
CanonicalOption
:
:
UTF16
=
>
"
utf16
"
CanonicalOption
:
:
CompactUTF16
=
>
"
latin1
-
utf16
"
CanonicalOption
:
:
Memory
(
_
)
=
>
"
memory
"
CanonicalOption
:
:
Realloc
(
_
)
=
>
"
realloc
"
CanonicalOption
:
:
PostReturn
(
_
)
=
>
"
post
-
return
"
CanonicalOption
:
:
Async
=
>
"
async
"
CanonicalOption
:
:
Callback
(
_
)
=
>
"
callback
"
}
}
let
mut
encoding
=
None
;
let
mut
memory
=
None
;
let
mut
realloc
=
None
;
let
mut
post_return
=
None
;
let
mut
async_
=
false
;
let
mut
callback
=
None
;
for
option
in
options
{
match
option
{
CanonicalOption
:
:
UTF8
|
CanonicalOption
:
:
UTF16
|
CanonicalOption
:
:
CompactUTF16
=
>
{
match
encoding
{
Some
(
existing
)
=
>
{
bail
!
(
offset
"
canonical
encoding
option
{
}
conflicts
with
option
{
}
"
display
(
existing
)
display
(
*
option
)
)
}
None
=
>
encoding
=
Some
(
*
option
)
}
}
CanonicalOption
:
:
Memory
(
idx
)
=
>
{
memory
=
match
memory
{
None
=
>
{
self
.
memory_at
(
*
idx
offset
)
?
;
Some
(
*
idx
)
}
Some
(
_
)
=
>
{
return
Err
(
BinaryReaderError
:
:
new
(
"
canonical
option
memory
is
specified
more
than
once
"
offset
)
)
}
}
}
CanonicalOption
:
:
Realloc
(
idx
)
=
>
{
realloc
=
match
realloc
{
None
=
>
{
let
ty
=
types
[
self
.
core_function_at
(
*
idx
offset
)
?
]
.
unwrap_func
(
)
;
if
ty
.
params
(
)
!
=
[
ValType
:
:
I32
ValType
:
:
I32
ValType
:
:
I32
ValType
:
:
I32
]
|
|
ty
.
results
(
)
!
=
[
ValType
:
:
I32
]
{
return
Err
(
BinaryReaderError
:
:
new
(
"
canonical
option
realloc
uses
a
core
function
with
an
incorrect
signature
"
offset
)
)
;
}
Some
(
*
idx
)
}
Some
(
_
)
=
>
{
return
Err
(
BinaryReaderError
:
:
new
(
"
canonical
option
realloc
is
specified
more
than
once
"
offset
)
)
}
}
}
CanonicalOption
:
:
PostReturn
(
idx
)
=
>
{
post_return
=
match
post_return
{
None
=
>
{
let
core_ty
=
core_ty
.
ok_or_else
(
|
|
{
BinaryReaderError
:
:
new
(
"
canonical
option
post
-
return
cannot
be
specified
for
lowerings
"
offset
)
}
)
?
;
let
ty
=
types
[
self
.
core_function_at
(
*
idx
offset
)
?
]
.
unwrap_func
(
)
;
if
ty
.
params
(
)
!
=
core_ty
.
results
(
)
|
|
!
ty
.
results
(
)
.
is_empty
(
)
{
return
Err
(
BinaryReaderError
:
:
new
(
"
canonical
option
post
-
return
uses
a
core
function
with
an
incorrect
signature
"
offset
)
)
;
}
Some
(
*
idx
)
}
Some
(
_
)
=
>
{
return
Err
(
BinaryReaderError
:
:
new
(
"
canonical
option
post
-
return
is
specified
more
than
once
"
offset
)
)
}
}
}
CanonicalOption
:
:
Async
=
>
{
if
async_
{
return
Err
(
BinaryReaderError
:
:
new
(
"
canonical
option
async
is
specified
more
than
once
"
offset
)
)
;
}
else
{
if
!
features
.
component_model_async
(
)
{
bail
!
(
offset
"
canonical
option
async
requires
the
component
model
async
feature
"
)
;
}
async_
=
true
;
}
}
CanonicalOption
:
:
Callback
(
idx
)
=
>
{
callback
=
match
callback
{
None
=
>
{
if
core_ty
.
is_none
(
)
{
return
Err
(
BinaryReaderError
:
:
new
(
"
canonical
option
callback
cannot
be
specified
for
lowerings
"
offset
)
)
;
}
let
ty
=
types
[
self
.
core_function_at
(
*
idx
offset
)
?
]
.
unwrap_func
(
)
;
if
ty
.
params
(
)
!
=
[
ValType
:
:
I32
;
4
]
&
&
ty
.
params
(
)
!
=
[
ValType
:
:
I32
]
{
return
Err
(
BinaryReaderError
:
:
new
(
"
canonical
option
callback
uses
a
core
function
with
an
incorrect
signature
"
offset
)
)
;
}
Some
(
*
idx
)
}
Some
(
_
)
=
>
{
return
Err
(
BinaryReaderError
:
:
new
(
"
canonical
option
callback
is
specified
more
than
once
"
offset
)
)
}
}
}
}
}
if
async_
&
&
!
allow_async
{
bail
!
(
offset
"
async
option
not
allowed
here
"
)
}
if
callback
.
is_some
(
)
&
&
!
async_
{
bail
!
(
offset
"
cannot
specify
callback
without
lifting
async
"
)
}
if
post_return
.
is_some
(
)
&
&
async_
{
bail
!
(
offset
"
cannot
specify
post
-
return
function
when
lifting
async
"
)
}
if
info
.
requires_memory
&
&
memory
.
is_none
(
)
{
return
Err
(
BinaryReaderError
:
:
new
(
"
canonical
option
memory
is
required
"
offset
)
)
;
}
if
info
.
requires_realloc
&
&
realloc
.
is_none
(
)
{
return
Err
(
BinaryReaderError
:
:
new
(
"
canonical
option
realloc
is
required
"
offset
)
)
;
}
Ok
(
(
)
)
}
fn
check_type_ref
(
&
mut
self
ty
:
&
ComponentTypeRef
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
ComponentEntityType
>
{
Ok
(
match
ty
{
ComponentTypeRef
:
:
Module
(
index
)
=
>
{
let
id
=
self
.
core_type_at
(
*
index
offset
)
?
;
match
id
{
ComponentCoreTypeId
:
:
Sub
(
_
)
=
>
{
bail
!
(
offset
"
core
type
index
{
index
}
is
not
a
module
type
"
)
}
ComponentCoreTypeId
:
:
Module
(
id
)
=
>
ComponentEntityType
:
:
Module
(
id
)
}
}
ComponentTypeRef
:
:
Func
(
index
)
=
>
{
let
id
=
self
.
component_type_at
(
*
index
offset
)
?
;
match
id
{
ComponentAnyTypeId
:
:
Func
(
id
)
=
>
ComponentEntityType
:
:
Func
(
id
)
_
=
>
bail
!
(
offset
"
type
index
{
index
}
is
not
a
function
type
"
)
}
}
ComponentTypeRef
:
:
Value
(
ty
)
=
>
{
self
.
check_value_support
(
features
offset
)
?
;
let
ty
=
match
ty
{
crate
:
:
ComponentValType
:
:
Primitive
(
ty
)
=
>
ComponentValType
:
:
Primitive
(
*
ty
)
crate
:
:
ComponentValType
:
:
Type
(
index
)
=
>
{
ComponentValType
:
:
Type
(
self
.
defined_type_at
(
*
index
offset
)
?
)
}
}
;
ComponentEntityType
:
:
Value
(
ty
)
}
ComponentTypeRef
:
:
Type
(
TypeBounds
:
:
Eq
(
index
)
)
=
>
{
let
referenced
=
self
.
component_type_at
(
*
index
offset
)
?
;
let
created
=
types
.
with_unique
(
referenced
)
;
ComponentEntityType
:
:
Type
{
referenced
created
}
}
ComponentTypeRef
:
:
Type
(
TypeBounds
:
:
SubResource
)
=
>
{
let
id
=
types
.
alloc_resource_id
(
)
;
ComponentEntityType
:
:
Type
{
referenced
:
id
.
into
(
)
created
:
id
.
into
(
)
}
}
ComponentTypeRef
:
:
Instance
(
index
)
=
>
{
let
id
=
self
.
component_type_at
(
*
index
offset
)
?
;
match
id
{
ComponentAnyTypeId
:
:
Instance
(
id
)
=
>
ComponentEntityType
:
:
Instance
(
id
)
_
=
>
bail
!
(
offset
"
type
index
{
index
}
is
not
an
instance
type
"
)
}
}
ComponentTypeRef
:
:
Component
(
index
)
=
>
{
let
id
=
self
.
component_type_at
(
*
index
offset
)
?
;
match
id
{
ComponentAnyTypeId
:
:
Component
(
id
)
=
>
ComponentEntityType
:
:
Component
(
id
)
_
=
>
bail
!
(
offset
"
type
index
{
index
}
is
not
a
component
type
"
)
}
}
}
)
}
pub
fn
export_to_entity_type
(
&
mut
self
export
:
&
crate
:
:
ComponentExport
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
ComponentEntityType
>
{
let
actual
=
match
export
.
kind
{
ComponentExternalKind
:
:
Module
=
>
{
ComponentEntityType
:
:
Module
(
self
.
module_at
(
export
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Func
=
>
{
ComponentEntityType
:
:
Func
(
self
.
function_at
(
export
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Value
=
>
{
self
.
check_value_support
(
features
offset
)
?
;
ComponentEntityType
:
:
Value
(
*
self
.
value_at
(
export
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Type
=
>
{
let
referenced
=
self
.
component_type_at
(
export
.
index
offset
)
?
;
let
created
=
types
.
with_unique
(
referenced
)
;
ComponentEntityType
:
:
Type
{
referenced
created
}
}
ComponentExternalKind
:
:
Instance
=
>
{
ComponentEntityType
:
:
Instance
(
self
.
instance_at
(
export
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Component
=
>
{
ComponentEntityType
:
:
Component
(
self
.
component_at
(
export
.
index
offset
)
?
)
}
}
;
let
ascribed
=
match
&
export
.
ty
{
Some
(
ty
)
=
>
self
.
check_type_ref
(
ty
features
types
offset
)
?
None
=
>
return
Ok
(
actual
)
}
;
SubtypeCx
:
:
new
(
types
types
)
.
component_entity_type
(
&
actual
&
ascribed
offset
)
.
with_context
(
|
|
"
ascribed
type
of
export
is
not
compatible
with
item
'
s
type
"
)
?
;
Ok
(
ascribed
)
}
fn
create_module_type
(
components
:
&
[
Self
]
decls
:
Vec
<
crate
:
:
ModuleTypeDeclaration
>
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
ModuleType
>
{
let
mut
state
=
Module
:
:
default
(
)
;
for
decl
in
decls
{
match
decl
{
crate
:
:
ModuleTypeDeclaration
:
:
Type
(
rec
)
=
>
{
state
.
add_types
(
rec
features
types
offset
true
)
?
;
}
crate
:
:
ModuleTypeDeclaration
:
:
Export
{
name
mut
ty
}
=
>
{
let
ty
=
state
.
check_type_ref
(
&
mut
ty
features
types
offset
)
?
;
state
.
add_export
(
name
ty
features
offset
true
types
)
?
;
}
crate
:
:
ModuleTypeDeclaration
:
:
OuterAlias
{
kind
count
index
}
=
>
{
match
kind
{
crate
:
:
OuterAliasKind
:
:
Type
=
>
{
let
ty
=
if
count
=
=
0
{
ComponentCoreTypeId
:
:
Sub
(
state
.
type_id_at
(
index
offset
)
?
)
}
else
{
let
component
=
Self
:
:
check_alias_count
(
components
count
-
1
offset
)
?
;
component
.
core_type_at
(
index
offset
)
?
}
;
check_max
(
state
.
types
.
len
(
)
1
MAX_WASM_TYPES
"
types
"
offset
)
?
;
match
ty
{
ComponentCoreTypeId
:
:
Sub
(
ty
)
=
>
state
.
types
.
push
(
ty
)
ComponentCoreTypeId
:
:
Module
(
_
)
=
>
bail
!
(
offset
"
not
implemented
:
aliasing
core
module
types
into
a
core
\
module
'
s
types
index
space
"
)
}
}
}
}
crate
:
:
ModuleTypeDeclaration
:
:
Import
(
import
)
=
>
{
state
.
add_import
(
import
features
types
offset
)
?
;
}
}
}
let
imports
=
state
.
imports_for_module_type
(
offset
)
?
;
Ok
(
ModuleType
{
info
:
TypeInfo
:
:
core
(
state
.
type_size
)
imports
exports
:
state
.
exports
}
)
}
fn
create_component_type
(
components
:
&
mut
Vec
<
Self
>
decls
:
Vec
<
crate
:
:
ComponentTypeDeclaration
>
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
ComponentType
>
{
components
.
push
(
ComponentState
:
:
new
(
ComponentKind
:
:
ComponentType
)
)
;
for
decl
in
decls
{
match
decl
{
crate
:
:
ComponentTypeDeclaration
:
:
CoreType
(
ty
)
=
>
{
Self
:
:
add_core_type
(
components
ty
features
types
offset
true
)
?
;
}
crate
:
:
ComponentTypeDeclaration
:
:
Type
(
ty
)
=
>
{
Self
:
:
add_type
(
components
ty
features
types
offset
true
)
?
;
}
crate
:
:
ComponentTypeDeclaration
:
:
Export
{
name
ty
}
=
>
{
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
let
ty
=
current
.
check_type_ref
(
&
ty
features
types
offset
)
?
;
current
.
add_export
(
name
ty
features
types
offset
true
)
?
;
}
crate
:
:
ComponentTypeDeclaration
:
:
Import
(
import
)
=
>
{
components
.
last_mut
(
)
.
unwrap
(
)
.
add_import
(
import
features
types
offset
)
?
;
}
crate
:
:
ComponentTypeDeclaration
:
:
Alias
(
alias
)
=
>
{
Self
:
:
add_alias
(
components
alias
features
types
offset
)
?
;
}
}
;
}
components
.
pop
(
)
.
unwrap
(
)
.
finish
(
types
offset
)
}
fn
create_instance_type
(
components
:
&
mut
Vec
<
Self
>
decls
:
Vec
<
crate
:
:
InstanceTypeDeclaration
>
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
ComponentInstanceType
>
{
components
.
push
(
ComponentState
:
:
new
(
ComponentKind
:
:
InstanceType
)
)
;
for
decl
in
decls
{
match
decl
{
crate
:
:
InstanceTypeDeclaration
:
:
CoreType
(
ty
)
=
>
{
Self
:
:
add_core_type
(
components
ty
features
types
offset
true
)
?
;
}
crate
:
:
InstanceTypeDeclaration
:
:
Type
(
ty
)
=
>
{
Self
:
:
add_type
(
components
ty
features
types
offset
true
)
?
;
}
crate
:
:
InstanceTypeDeclaration
:
:
Export
{
name
ty
}
=
>
{
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
let
ty
=
current
.
check_type_ref
(
&
ty
features
types
offset
)
?
;
current
.
add_export
(
name
ty
features
types
offset
true
)
?
;
}
crate
:
:
InstanceTypeDeclaration
:
:
Alias
(
alias
)
=
>
{
Self
:
:
add_alias
(
components
alias
features
types
offset
)
?
;
}
}
;
}
let
mut
state
=
components
.
pop
(
)
.
unwrap
(
)
;
assert
!
(
state
.
imported_resources
.
is_empty
(
)
)
;
Ok
(
ComponentInstanceType
{
info
:
state
.
type_info
defined_resources
:
mem
:
:
take
(
&
mut
state
.
defined_resources
)
.
into_iter
(
)
.
map
(
|
(
id
rep
)
|
{
assert
!
(
rep
.
is_none
(
)
)
;
id
}
)
.
collect
(
)
explicit_resources
:
mem
:
:
take
(
&
mut
state
.
explicit_resources
)
exports
:
mem
:
:
take
(
&
mut
state
.
exports
)
}
)
}
fn
create_function_type
(
&
self
ty
:
crate
:
:
ComponentFuncType
types
:
&
TypeList
features
:
&
WasmFeatures
offset
:
usize
)
-
>
Result
<
ComponentFuncType
>
{
let
mut
info
=
TypeInfo
:
:
new
(
)
;
if
ty
.
results
.
type_count
(
)
>
1
&
&
!
features
.
component_model_multiple_returns
(
)
{
bail
!
(
offset
"
multiple
returns
on
a
function
is
now
a
gated
feature
\
-
-
https
:
/
/
github
.
com
/
WebAssembly
/
component
-
model
/
pull
/
368
"
)
;
}
let
mut
set
=
Set
:
:
default
(
)
;
set
.
reserve
(
core
:
:
cmp
:
:
max
(
ty
.
params
.
len
(
)
ty
.
results
.
type_count
(
)
)
)
;
let
params
=
ty
.
params
.
iter
(
)
.
map
(
|
(
name
ty
)
|
{
let
name
:
&
KebabStr
=
to_kebab_str
(
name
"
function
parameter
"
offset
)
?
;
if
!
set
.
insert
(
name
)
{
bail
!
(
offset
"
function
parameter
name
{
name
}
conflicts
with
previous
parameter
name
{
prev
}
"
prev
=
set
.
get
(
&
name
)
.
unwrap
(
)
)
;
}
let
ty
=
self
.
create_component_val_type
(
*
ty
offset
)
?
;
info
.
combine
(
ty
.
info
(
types
)
offset
)
?
;
Ok
(
(
name
.
to_owned
(
)
ty
)
)
}
)
.
collect
:
:
<
Result
<
_
>
>
(
)
?
;
set
.
clear
(
)
;
let
results
=
ty
.
results
.
iter
(
)
.
map
(
|
(
name
ty
)
|
{
let
name
=
name
.
map
(
|
name
|
{
let
name
=
to_kebab_str
(
name
"
function
result
"
offset
)
?
;
if
!
set
.
insert
(
name
)
{
bail
!
(
offset
"
function
result
name
{
name
}
conflicts
with
previous
result
name
{
prev
}
"
prev
=
set
.
get
(
name
)
.
unwrap
(
)
)
;
}
Ok
(
name
.
to_owned
(
)
)
}
)
.
transpose
(
)
?
;
let
ty
=
self
.
create_component_val_type
(
*
ty
offset
)
?
;
let
ty_info
=
ty
.
info
(
types
)
;
if
ty_info
.
contains_borrow
(
)
{
bail
!
(
offset
"
function
result
cannot
contain
a
borrow
type
"
)
;
}
info
.
combine
(
ty
.
info
(
types
)
offset
)
?
;
Ok
(
(
name
ty
)
)
}
)
.
collect
:
:
<
Result
<
_
>
>
(
)
?
;
Ok
(
ComponentFuncType
{
info
params
results
}
)
}
fn
instantiate_core_module
(
&
self
module_index
:
u32
module_args
:
Vec
<
crate
:
:
InstantiationArg
>
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
ComponentCoreInstanceTypeId
>
{
fn
insert_arg
<
'
a
>
(
name
:
&
'
a
str
arg
:
&
'
a
InstanceType
args
:
&
mut
IndexMap
<
&
'
a
str
&
'
a
InstanceType
>
offset
:
usize
)
-
>
Result
<
(
)
>
{
if
args
.
insert
(
name
arg
)
.
is_some
(
)
{
bail
!
(
offset
"
duplicate
module
instantiation
argument
named
{
name
}
"
)
;
}
Ok
(
(
)
)
}
let
module_type_id
=
self
.
module_at
(
module_index
offset
)
?
;
let
mut
args
=
IndexMap
:
:
default
(
)
;
for
module_arg
in
module_args
{
match
module_arg
.
kind
{
InstantiationArgKind
:
:
Instance
=
>
{
let
instance_type
=
&
types
[
self
.
core_instance_at
(
module_arg
.
index
offset
)
?
]
;
insert_arg
(
module_arg
.
name
instance_type
&
mut
args
offset
)
?
;
}
}
}
let
module_type
=
&
types
[
module_type_id
]
;
let
cx
=
SubtypeCx
:
:
new
(
types
types
)
;
for
(
(
module
name
)
expected
)
in
module_type
.
imports
.
iter
(
)
{
let
instance
=
args
.
get
(
module
.
as_str
(
)
)
.
ok_or_else
(
|
|
{
format_err
!
(
offset
"
missing
module
instantiation
argument
named
{
module
}
"
)
}
)
?
;
let
arg
=
instance
.
internal_exports
(
types
)
.
get
(
name
.
as_str
(
)
)
.
ok_or_else
(
|
|
{
format_err
!
(
offset
"
module
instantiation
argument
{
module
}
does
not
\
export
an
item
named
{
name
}
"
)
}
)
?
;
cx
.
entity_type
(
arg
expected
offset
)
.
with_context
(
|
|
{
format
!
(
"
type
mismatch
for
export
{
name
}
of
module
\
instantiation
argument
{
module
}
"
)
}
)
?
;
}
let
mut
info
=
TypeInfo
:
:
new
(
)
;
for
(
_
ty
)
in
module_type
.
exports
.
iter
(
)
{
info
.
combine
(
ty
.
info
(
types
)
offset
)
?
;
}
Ok
(
types
.
push_ty
(
InstanceType
{
info
kind
:
CoreInstanceTypeKind
:
:
Instantiated
(
module_type_id
)
}
)
)
}
fn
instantiate_component
(
&
mut
self
component_index
:
u32
component_args
:
Vec
<
crate
:
:
ComponentInstantiationArg
>
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
ComponentInstanceTypeId
>
{
let
component_type_id
=
self
.
component_at
(
component_index
offset
)
?
;
let
mut
args
=
IndexMap
:
:
default
(
)
;
for
component_arg
in
component_args
{
let
ty
=
match
component_arg
.
kind
{
ComponentExternalKind
:
:
Module
=
>
{
ComponentEntityType
:
:
Module
(
self
.
module_at
(
component_arg
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Component
=
>
{
ComponentEntityType
:
:
Component
(
self
.
component_at
(
component_arg
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Instance
=
>
{
ComponentEntityType
:
:
Instance
(
self
.
instance_at
(
component_arg
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Func
=
>
{
ComponentEntityType
:
:
Func
(
self
.
function_at
(
component_arg
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Value
=
>
{
self
.
check_value_support
(
features
offset
)
?
;
ComponentEntityType
:
:
Value
(
*
self
.
value_at
(
component_arg
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Type
=
>
{
let
ty
=
self
.
component_type_at
(
component_arg
.
index
offset
)
?
;
ComponentEntityType
:
:
Type
{
referenced
:
ty
created
:
ty
}
}
}
;
match
args
.
entry
(
component_arg
.
name
.
to_string
(
)
)
{
Entry
:
:
Occupied
(
e
)
=
>
{
bail
!
(
offset
"
instantiation
argument
{
name
}
conflicts
with
previous
argument
{
prev
}
"
prev
=
e
.
key
(
)
name
=
component_arg
.
name
)
;
}
Entry
:
:
Vacant
(
e
)
=
>
{
e
.
insert
(
ty
)
;
}
}
}
let
component_type
=
&
types
[
component_type_id
]
;
let
mut
exports
=
component_type
.
exports
.
clone
(
)
;
let
mut
info
=
TypeInfo
:
:
new
(
)
;
for
(
_
ty
)
in
component_type
.
exports
.
iter
(
)
{
info
.
combine
(
ty
.
info
(
types
)
offset
)
?
;
}
let
mut
mapping
=
SubtypeCx
:
:
new
(
types
types
)
.
open_instance_type
(
&
args
component_type_id
ExternKind
:
:
Import
offset
)
?
;
let
fresh_defined_resources
=
(
0
.
.
component_type
.
defined_resources
.
len
(
)
)
.
map
(
|
_
|
types
.
alloc_resource_id
(
)
.
resource
(
)
)
.
collect
:
:
<
IndexSet
<
_
>
>
(
)
;
let
component_type
=
&
types
[
component_type_id
]
;
for
(
(
old
_path
)
new
)
in
component_type
.
defined_resources
.
iter
(
)
.
zip
(
&
fresh_defined_resources
)
{
let
prev
=
mapping
.
resources
.
insert
(
*
old
*
new
)
;
assert
!
(
prev
.
is_none
(
)
)
;
}
for
entity
in
exports
.
values_mut
(
)
{
types
.
remap_component_entity
(
entity
&
mut
mapping
)
;
}
let
component_type
=
&
types
[
component_type_id
]
;
let
explicit_resources
=
component_type
.
explicit_resources
.
iter
(
)
.
map
(
|
(
id
path
)
|
{
(
mapping
.
resources
.
get
(
id
)
.
copied
(
)
.
unwrap_or
(
*
id
)
path
.
clone
(
)
)
}
)
.
collect
:
:
<
IndexMap
<
_
_
>
>
(
)
;
if
cfg
!
(
debug_assertions
)
{
let
mut
free
=
IndexSet
:
:
default
(
)
;
for
ty
in
exports
.
values
(
)
{
types
.
free_variables_component_entity
(
ty
&
mut
free
)
;
}
assert
!
(
fresh_defined_resources
.
is_subset
(
&
free
)
)
;
for
resource
in
fresh_defined_resources
.
iter
(
)
{
assert
!
(
explicit_resources
.
contains_key
(
resource
)
)
;
}
}
for
resource
in
fresh_defined_resources
{
self
.
defined_resources
.
insert
(
resource
None
)
;
}
Ok
(
types
.
push_ty
(
ComponentInstanceType
{
info
defined_resources
:
Default
:
:
default
(
)
explicit_resources
exports
}
)
)
}
fn
instantiate_component_exports
(
&
mut
self
exports
:
Vec
<
crate
:
:
ComponentExport
>
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
ComponentInstanceTypeId
>
{
let
mut
info
=
TypeInfo
:
:
new
(
)
;
let
mut
inst_exports
=
IndexMap
:
:
default
(
)
;
let
mut
explicit_resources
=
IndexMap
:
:
default
(
)
;
let
mut
export_names
=
IndexSet
:
:
default
(
)
;
let
names
=
ComponentNameContext
:
:
default
(
)
;
for
export
in
exports
{
assert
!
(
export
.
ty
.
is_none
(
)
)
;
let
ty
=
match
export
.
kind
{
ComponentExternalKind
:
:
Module
=
>
{
ComponentEntityType
:
:
Module
(
self
.
module_at
(
export
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Component
=
>
{
ComponentEntityType
:
:
Component
(
self
.
component_at
(
export
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Instance
=
>
{
let
ty
=
self
.
instance_at
(
export
.
index
offset
)
?
;
explicit_resources
.
extend
(
types
[
ty
]
.
explicit_resources
.
iter
(
)
.
map
(
|
(
id
path
)
|
{
let
mut
new_path
=
vec
!
[
inst_exports
.
len
(
)
]
;
new_path
.
extend
(
path
)
;
(
*
id
new_path
)
}
)
)
;
ComponentEntityType
:
:
Instance
(
ty
)
}
ComponentExternalKind
:
:
Func
=
>
{
ComponentEntityType
:
:
Func
(
self
.
function_at
(
export
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Value
=
>
{
self
.
check_value_support
(
features
offset
)
?
;
ComponentEntityType
:
:
Value
(
*
self
.
value_at
(
export
.
index
offset
)
?
)
}
ComponentExternalKind
:
:
Type
=
>
{
let
ty
=
self
.
component_type_at
(
export
.
index
offset
)
?
;
if
let
ComponentAnyTypeId
:
:
Resource
(
id
)
=
ty
{
explicit_resources
.
insert
(
id
.
resource
(
)
vec
!
[
inst_exports
.
len
(
)
]
)
;
}
ComponentEntityType
:
:
Type
{
referenced
:
ty
created
:
ty
}
}
}
;
names
.
validate_extern
(
export
.
name
.
0
ExternKind
:
:
Export
&
ty
types
offset
&
mut
export_names
&
mut
inst_exports
&
mut
info
features
)
?
;
}
Ok
(
types
.
push_ty
(
ComponentInstanceType
{
info
explicit_resources
exports
:
inst_exports
defined_resources
:
Default
:
:
default
(
)
}
)
)
}
fn
instantiate_core_exports
(
&
mut
self
exports
:
Vec
<
crate
:
:
Export
>
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
ComponentCoreInstanceTypeId
>
{
fn
insert_export
(
types
:
&
TypeList
name
:
&
str
export
:
EntityType
exports
:
&
mut
IndexMap
<
String
EntityType
>
info
:
&
mut
TypeInfo
offset
:
usize
)
-
>
Result
<
(
)
>
{
info
.
combine
(
export
.
info
(
types
)
offset
)
?
;
if
exports
.
insert
(
name
.
to_string
(
)
export
)
.
is_some
(
)
{
bail
!
(
offset
"
duplicate
instantiation
export
name
{
name
}
already
defined
"
)
}
Ok
(
(
)
)
}
let
mut
info
=
TypeInfo
:
:
new
(
)
;
let
mut
inst_exports
=
IndexMap
:
:
default
(
)
;
for
export
in
exports
{
match
export
.
kind
{
ExternalKind
:
:
Func
=
>
{
insert_export
(
types
export
.
name
EntityType
:
:
Func
(
self
.
core_function_at
(
export
.
index
offset
)
?
)
&
mut
inst_exports
&
mut
info
offset
)
?
;
}
ExternalKind
:
:
Table
=
>
insert_export
(
types
export
.
name
EntityType
:
:
Table
(
*
self
.
table_at
(
export
.
index
offset
)
?
)
&
mut
inst_exports
&
mut
info
offset
)
?
ExternalKind
:
:
Memory
=
>
insert_export
(
types
export
.
name
EntityType
:
:
Memory
(
*
self
.
memory_at
(
export
.
index
offset
)
?
)
&
mut
inst_exports
&
mut
info
offset
)
?
ExternalKind
:
:
Global
=
>
{
insert_export
(
types
export
.
name
EntityType
:
:
Global
(
*
self
.
global_at
(
export
.
index
offset
)
?
)
&
mut
inst_exports
&
mut
info
offset
)
?
;
}
ExternalKind
:
:
Tag
=
>
insert_export
(
types
export
.
name
EntityType
:
:
Tag
(
self
.
core_function_at
(
export
.
index
offset
)
?
)
&
mut
inst_exports
&
mut
info
offset
)
?
}
}
Ok
(
types
.
push_ty
(
InstanceType
{
info
kind
:
CoreInstanceTypeKind
:
:
Exports
(
inst_exports
)
}
)
)
}
fn
alias_core_instance_export
(
&
mut
self
instance_index
:
u32
kind
:
ExternalKind
name
:
&
str
types
:
&
TypeList
offset
:
usize
)
-
>
Result
<
(
)
>
{
macro_rules
!
push_module_export
{
(
expected
:
path
collection
:
ident
ty
:
literal
)
=
>
{
{
match
self
.
core_instance_export
(
instance_index
name
types
offset
)
?
{
expected
(
ty
)
=
>
{
self
.
collection
.
push
(
*
ty
)
;
}
_
=
>
{
bail
!
(
offset
"
export
{
name
}
for
core
instance
{
instance_index
}
is
not
a
{
}
"
ty
)
}
}
}
}
;
}
match
kind
{
ExternalKind
:
:
Func
=
>
{
check_max
(
self
.
function_count
(
)
1
MAX_WASM_FUNCTIONS
"
functions
"
offset
)
?
;
push_module_export
!
(
EntityType
:
:
Func
core_funcs
"
function
"
)
;
}
ExternalKind
:
:
Table
=
>
{
check_max
(
self
.
core_tables
.
len
(
)
1
MAX_CORE_INDEX_SPACE_ITEMS
"
tables
"
offset
)
?
;
push_module_export
!
(
EntityType
:
:
Table
core_tables
"
table
"
)
;
let
ty
=
self
.
core_tables
.
last
(
)
.
unwrap
(
)
;
if
ty
.
table64
{
bail
!
(
offset
"
64
-
bit
tables
are
not
compatible
with
components
yet
"
)
;
}
if
ty
.
shared
{
bail
!
(
offset
"
shared
tables
are
not
compatible
with
components
yet
"
)
;
}
}
ExternalKind
:
:
Memory
=
>
{
check_max
(
self
.
core_memories
.
len
(
)
1
MAX_CORE_INDEX_SPACE_ITEMS
"
memories
"
offset
)
?
;
push_module_export
!
(
EntityType
:
:
Memory
core_memories
"
memory
"
)
;
let
ty
=
self
.
core_memories
.
last
(
)
.
unwrap
(
)
;
if
ty
.
memory64
{
bail
!
(
offset
"
64
-
bit
linear
memories
are
not
compatible
with
components
yet
"
)
;
}
if
ty
.
shared
{
bail
!
(
offset
"
shared
linear
memories
are
not
compatible
with
components
yet
"
)
;
}
}
ExternalKind
:
:
Global
=
>
{
check_max
(
self
.
core_globals
.
len
(
)
1
MAX_CORE_INDEX_SPACE_ITEMS
"
globals
"
offset
)
?
;
push_module_export
!
(
EntityType
:
:
Global
core_globals
"
global
"
)
;
}
ExternalKind
:
:
Tag
=
>
{
check_max
(
self
.
core_tags
.
len
(
)
1
MAX_CORE_INDEX_SPACE_ITEMS
"
tags
"
offset
)
?
;
push_module_export
!
(
EntityType
:
:
Tag
core_tags
"
tag
"
)
;
}
}
Ok
(
(
)
)
}
fn
alias_instance_export
(
&
mut
self
instance_index
:
u32
kind
:
ComponentExternalKind
name
:
&
str
features
:
&
WasmFeatures
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
if
let
ComponentExternalKind
:
:
Value
=
kind
{
self
.
check_value_support
(
features
offset
)
?
;
}
let
mut
ty
=
match
types
[
self
.
instance_at
(
instance_index
offset
)
?
]
.
exports
.
get
(
name
)
{
Some
(
ty
)
=
>
*
ty
None
=
>
bail
!
(
offset
"
instance
{
instance_index
}
has
no
export
named
{
name
}
"
)
}
;
let
ok
=
match
(
&
ty
kind
)
{
(
ComponentEntityType
:
:
Module
(
_
)
ComponentExternalKind
:
:
Module
)
=
>
true
(
ComponentEntityType
:
:
Module
(
_
)
_
)
=
>
false
(
ComponentEntityType
:
:
Component
(
_
)
ComponentExternalKind
:
:
Component
)
=
>
true
(
ComponentEntityType
:
:
Component
(
_
)
_
)
=
>
false
(
ComponentEntityType
:
:
Func
(
_
)
ComponentExternalKind
:
:
Func
)
=
>
true
(
ComponentEntityType
:
:
Func
(
_
)
_
)
=
>
false
(
ComponentEntityType
:
:
Instance
(
_
)
ComponentExternalKind
:
:
Instance
)
=
>
true
(
ComponentEntityType
:
:
Instance
(
_
)
_
)
=
>
false
(
ComponentEntityType
:
:
Value
(
_
)
ComponentExternalKind
:
:
Value
)
=
>
true
(
ComponentEntityType
:
:
Value
(
_
)
_
)
=
>
false
(
ComponentEntityType
:
:
Type
{
.
.
}
ComponentExternalKind
:
:
Type
)
=
>
true
(
ComponentEntityType
:
:
Type
{
.
.
}
_
)
=
>
false
}
;
if
!
ok
{
bail
!
(
offset
"
export
{
name
}
for
instance
{
instance_index
}
is
not
a
{
}
"
kind
.
desc
(
)
)
;
}
self
.
add_entity
(
&
mut
ty
None
features
types
offset
)
?
;
Ok
(
(
)
)
}
fn
alias_module
(
components
:
&
mut
[
Self
]
count
:
u32
index
:
u32
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
component
=
Self
:
:
check_alias_count
(
components
count
offset
)
?
;
let
ty
=
component
.
module_at
(
index
offset
)
?
;
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
core_modules
.
len
(
)
1
MAX_WASM_MODULES
"
modules
"
offset
)
?
;
current
.
core_modules
.
push
(
ty
)
;
Ok
(
(
)
)
}
fn
alias_component
(
components
:
&
mut
[
Self
]
count
:
u32
index
:
u32
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
component
=
Self
:
:
check_alias_count
(
components
count
offset
)
?
;
let
ty
=
component
.
component_at
(
index
offset
)
?
;
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
components
.
len
(
)
1
MAX_WASM_COMPONENTS
"
components
"
offset
)
?
;
current
.
components
.
push
(
ty
)
;
Ok
(
(
)
)
}
fn
alias_core_type
(
components
:
&
mut
[
Self
]
count
:
u32
index
:
u32
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
component
=
Self
:
:
check_alias_count
(
components
count
offset
)
?
;
let
ty
=
component
.
core_type_at
(
index
offset
)
?
;
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
type_count
(
)
1
MAX_WASM_TYPES
"
types
"
offset
)
?
;
current
.
core_types
.
push
(
ty
)
;
Ok
(
(
)
)
}
fn
alias_type
(
components
:
&
mut
[
Self
]
count
:
u32
index
:
u32
types
:
&
mut
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
component
=
Self
:
:
check_alias_count
(
components
count
offset
)
?
;
let
ty
=
component
.
component_type_at
(
index
offset
)
?
;
let
pos_after_component
=
components
.
len
(
)
-
(
count
as
usize
)
;
if
let
Some
(
component
)
=
components
.
get
(
pos_after_component
)
{
if
component
.
kind
=
=
ComponentKind
:
:
Component
{
let
mut
free
=
IndexSet
:
:
default
(
)
;
types
.
free_variables_any_type_id
(
ty
&
mut
free
)
;
if
!
free
.
is_empty
(
)
{
bail
!
(
offset
"
cannot
alias
outer
type
which
transitively
refers
\
to
resources
not
defined
in
the
current
component
"
)
;
}
}
}
let
current
=
components
.
last_mut
(
)
.
unwrap
(
)
;
check_max
(
current
.
type_count
(
)
1
MAX_WASM_TYPES
"
types
"
offset
)
?
;
current
.
types
.
push
(
ty
)
;
Ok
(
(
)
)
}
fn
check_alias_count
(
components
:
&
[
Self
]
count
:
u32
offset
:
usize
)
-
>
Result
<
&
Self
>
{
let
count
=
count
as
usize
;
if
count
>
=
components
.
len
(
)
{
bail
!
(
offset
"
invalid
outer
alias
count
of
{
count
}
"
)
;
}
Ok
(
&
components
[
components
.
len
(
)
-
count
-
1
]
)
}
fn
create_defined_type
(
&
self
ty
:
crate
:
:
ComponentDefinedType
types
:
&
TypeList
features
:
&
WasmFeatures
offset
:
usize
)
-
>
Result
<
ComponentDefinedType
>
{
match
ty
{
crate
:
:
ComponentDefinedType
:
:
Primitive
(
ty
)
=
>
Ok
(
ComponentDefinedType
:
:
Primitive
(
ty
)
)
crate
:
:
ComponentDefinedType
:
:
Record
(
fields
)
=
>
{
self
.
create_record_type
(
fields
.
as_ref
(
)
types
offset
)
}
crate
:
:
ComponentDefinedType
:
:
Variant
(
cases
)
=
>
{
self
.
create_variant_type
(
cases
.
as_ref
(
)
types
offset
)
}
crate
:
:
ComponentDefinedType
:
:
List
(
ty
)
=
>
Ok
(
ComponentDefinedType
:
:
List
(
self
.
create_component_val_type
(
ty
offset
)
?
)
)
crate
:
:
ComponentDefinedType
:
:
Tuple
(
tys
)
=
>
{
self
.
create_tuple_type
(
tys
.
as_ref
(
)
types
offset
)
}
crate
:
:
ComponentDefinedType
:
:
Flags
(
names
)
=
>
{
self
.
create_flags_type
(
names
.
as_ref
(
)
features
offset
)
}
crate
:
:
ComponentDefinedType
:
:
Enum
(
cases
)
=
>
{
self
.
create_enum_type
(
cases
.
as_ref
(
)
offset
)
}
crate
:
:
ComponentDefinedType
:
:
Option
(
ty
)
=
>
Ok
(
ComponentDefinedType
:
:
Option
(
self
.
create_component_val_type
(
ty
offset
)
?
)
)
crate
:
:
ComponentDefinedType
:
:
Result
{
ok
err
}
=
>
Ok
(
ComponentDefinedType
:
:
Result
{
ok
:
ok
.
map
(
|
ty
|
self
.
create_component_val_type
(
ty
offset
)
)
.
transpose
(
)
?
err
:
err
.
map
(
|
ty
|
self
.
create_component_val_type
(
ty
offset
)
)
.
transpose
(
)
?
}
)
crate
:
:
ComponentDefinedType
:
:
Own
(
idx
)
=
>
Ok
(
ComponentDefinedType
:
:
Own
(
self
.
resource_at
(
idx
types
offset
)
?
)
)
crate
:
:
ComponentDefinedType
:
:
Borrow
(
idx
)
=
>
Ok
(
ComponentDefinedType
:
:
Borrow
(
self
.
resource_at
(
idx
types
offset
)
?
)
)
crate
:
:
ComponentDefinedType
:
:
Future
(
ty
)
=
>
Ok
(
ComponentDefinedType
:
:
Future
(
ty
.
map
(
|
ty
|
self
.
create_component_val_type
(
ty
offset
)
)
.
transpose
(
)
?
)
)
crate
:
:
ComponentDefinedType
:
:
Stream
(
ty
)
=
>
Ok
(
ComponentDefinedType
:
:
Stream
(
ty
.
map
(
|
ty
|
self
.
create_component_val_type
(
ty
offset
)
)
.
transpose
(
)
?
)
)
crate
:
:
ComponentDefinedType
:
:
ErrorContext
=
>
Ok
(
ComponentDefinedType
:
:
ErrorContext
)
}
}
fn
create_record_type
(
&
self
fields
:
&
[
(
&
str
crate
:
:
ComponentValType
)
]
types
:
&
TypeList
offset
:
usize
)
-
>
Result
<
ComponentDefinedType
>
{
let
mut
info
=
TypeInfo
:
:
new
(
)
;
let
mut
field_map
=
IndexMap
:
:
default
(
)
;
field_map
.
reserve
(
fields
.
len
(
)
)
;
if
fields
.
is_empty
(
)
{
bail
!
(
offset
"
record
type
must
have
at
least
one
field
"
)
;
}
for
(
name
ty
)
in
fields
{
let
name
=
to_kebab_str
(
name
"
record
field
"
offset
)
?
;
let
ty
=
self
.
create_component_val_type
(
*
ty
offset
)
?
;
match
field_map
.
entry
(
name
.
to_owned
(
)
)
{
Entry
:
:
Occupied
(
e
)
=
>
bail
!
(
offset
"
record
field
name
{
name
}
conflicts
with
previous
field
name
{
prev
}
"
prev
=
e
.
key
(
)
)
Entry
:
:
Vacant
(
e
)
=
>
{
info
.
combine
(
ty
.
info
(
types
)
offset
)
?
;
e
.
insert
(
ty
)
;
}
}
}
Ok
(
ComponentDefinedType
:
:
Record
(
RecordType
{
info
fields
:
field_map
}
)
)
}
fn
create_variant_type
(
&
self
cases
:
&
[
crate
:
:
VariantCase
]
types
:
&
TypeList
offset
:
usize
)
-
>
Result
<
ComponentDefinedType
>
{
let
mut
info
=
TypeInfo
:
:
new
(
)
;
let
mut
case_map
:
IndexMap
<
KebabString
VariantCase
>
=
IndexMap
:
:
default
(
)
;
case_map
.
reserve
(
cases
.
len
(
)
)
;
if
cases
.
is_empty
(
)
{
bail
!
(
offset
"
variant
type
must
have
at
least
one
case
"
)
;
}
if
cases
.
len
(
)
>
u32
:
:
MAX
as
usize
{
return
Err
(
BinaryReaderError
:
:
new
(
"
variant
type
cannot
be
represented
with
a
32
-
bit
discriminant
value
"
offset
)
)
;
}
for
(
i
case
)
in
cases
.
iter
(
)
.
enumerate
(
)
{
if
let
Some
(
refines
)
=
case
.
refines
{
if
refines
>
=
i
as
u32
{
return
Err
(
BinaryReaderError
:
:
new
(
"
variant
case
can
only
refine
a
previously
defined
case
"
offset
)
)
;
}
}
let
name
=
to_kebab_str
(
case
.
name
"
variant
case
"
offset
)
?
;
let
ty
=
case
.
ty
.
map
(
|
ty
|
self
.
create_component_val_type
(
ty
offset
)
)
.
transpose
(
)
?
;
match
case_map
.
entry
(
name
.
to_owned
(
)
)
{
Entry
:
:
Occupied
(
e
)
=
>
bail
!
(
offset
"
variant
case
name
{
name
}
conflicts
with
previous
case
name
{
prev
}
"
name
=
case
.
name
prev
=
e
.
key
(
)
)
Entry
:
:
Vacant
(
e
)
=
>
{
if
let
Some
(
ty
)
=
ty
{
info
.
combine
(
ty
.
info
(
types
)
offset
)
?
;
}
e
.
insert
(
VariantCase
{
ty
refines
:
case
.
refines
.
map
(
|
i
|
KebabStr
:
:
new_unchecked
(
cases
[
i
as
usize
]
.
name
)
.
to_owned
(
)
)
}
)
;
}
}
}
Ok
(
ComponentDefinedType
:
:
Variant
(
VariantType
{
info
cases
:
case_map
}
)
)
}
fn
create_tuple_type
(
&
self
tys
:
&
[
crate
:
:
ComponentValType
]
types
:
&
TypeList
offset
:
usize
)
-
>
Result
<
ComponentDefinedType
>
{
let
mut
info
=
TypeInfo
:
:
new
(
)
;
if
tys
.
is_empty
(
)
{
bail
!
(
offset
"
tuple
type
must
have
at
least
one
type
"
)
;
}
let
types
=
tys
.
iter
(
)
.
map
(
|
ty
|
{
let
ty
=
self
.
create_component_val_type
(
*
ty
offset
)
?
;
info
.
combine
(
ty
.
info
(
types
)
offset
)
?
;
Ok
(
ty
)
}
)
.
collect
:
:
<
Result
<
_
>
>
(
)
?
;
Ok
(
ComponentDefinedType
:
:
Tuple
(
TupleType
{
info
types
}
)
)
}
fn
create_flags_type
(
&
self
names
:
&
[
&
str
]
features
:
&
WasmFeatures
offset
:
usize
)
-
>
Result
<
ComponentDefinedType
>
{
let
mut
names_set
=
IndexSet
:
:
default
(
)
;
names_set
.
reserve
(
names
.
len
(
)
)
;
if
names
.
is_empty
(
)
{
bail
!
(
offset
"
flags
must
have
at
least
one
entry
"
)
;
}
if
names
.
len
(
)
>
32
&
&
!
features
.
component_model_more_flags
(
)
{
bail
!
(
offset
"
cannot
have
more
than
32
flags
;
this
was
previously
\
accepted
and
if
this
is
required
for
your
project
please
\
leave
a
comment
on
\
https
:
/
/
github
.
com
/
WebAssembly
/
component
-
model
/
issues
/
370
"
)
;
}
for
name
in
names
{
let
name
=
to_kebab_str
(
name
"
flag
"
offset
)
?
;
if
!
names_set
.
insert
(
name
.
to_owned
(
)
)
{
bail
!
(
offset
"
flag
name
{
name
}
conflicts
with
previous
flag
name
{
prev
}
"
prev
=
names_set
.
get
(
name
)
.
unwrap
(
)
)
;
}
}
Ok
(
ComponentDefinedType
:
:
Flags
(
names_set
)
)
}
fn
create_enum_type
(
&
self
cases
:
&
[
&
str
]
offset
:
usize
)
-
>
Result
<
ComponentDefinedType
>
{
if
cases
.
len
(
)
>
u32
:
:
MAX
as
usize
{
return
Err
(
BinaryReaderError
:
:
new
(
"
enumeration
type
cannot
be
represented
with
a
32
-
bit
discriminant
value
"
offset
)
)
;
}
if
cases
.
is_empty
(
)
{
bail
!
(
offset
"
enum
type
must
have
at
least
one
variant
"
)
;
}
let
mut
tags
=
IndexSet
:
:
default
(
)
;
tags
.
reserve
(
cases
.
len
(
)
)
;
for
tag
in
cases
{
let
tag
=
to_kebab_str
(
tag
"
enum
tag
"
offset
)
?
;
if
!
tags
.
insert
(
tag
.
to_owned
(
)
)
{
bail
!
(
offset
"
enum
tag
name
{
tag
}
conflicts
with
previous
tag
name
{
prev
}
"
prev
=
tags
.
get
(
tag
)
.
unwrap
(
)
)
;
}
}
Ok
(
ComponentDefinedType
:
:
Enum
(
tags
)
)
}
fn
create_component_val_type
(
&
self
ty
:
crate
:
:
ComponentValType
offset
:
usize
)
-
>
Result
<
ComponentValType
>
{
Ok
(
match
ty
{
crate
:
:
ComponentValType
:
:
Primitive
(
pt
)
=
>
ComponentValType
:
:
Primitive
(
pt
)
crate
:
:
ComponentValType
:
:
Type
(
idx
)
=
>
{
ComponentValType
:
:
Type
(
self
.
defined_type_at
(
idx
offset
)
?
)
}
}
)
}
pub
fn
core_type_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
ComponentCoreTypeId
>
{
self
.
core_types
.
get
(
idx
as
usize
)
.
copied
(
)
.
ok_or_else
(
|
|
format_err
!
(
offset
"
unknown
type
{
idx
}
:
type
index
out
of
bounds
"
)
)
}
pub
fn
component_type_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
ComponentAnyTypeId
>
{
self
.
types
.
get
(
idx
as
usize
)
.
copied
(
)
.
ok_or_else
(
|
|
format_err
!
(
offset
"
unknown
type
{
idx
}
:
type
index
out
of
bounds
"
)
)
}
fn
function_type_at
<
'
a
>
(
&
self
idx
:
u32
types
:
&
'
a
TypeList
offset
:
usize
)
-
>
Result
<
&
'
a
ComponentFuncType
>
{
let
id
=
self
.
component_type_at
(
idx
offset
)
?
;
match
id
{
ComponentAnyTypeId
:
:
Func
(
id
)
=
>
Ok
(
&
types
[
id
]
)
_
=
>
bail
!
(
offset
"
type
index
{
idx
}
is
not
a
function
type
"
)
}
}
fn
function_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
ComponentFuncTypeId
>
{
self
.
funcs
.
get
(
idx
as
usize
)
.
copied
(
)
.
ok_or_else
(
|
|
{
format_err
!
(
offset
"
unknown
function
{
idx
}
:
function
index
out
of
bounds
"
)
}
)
}
fn
component_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
ComponentTypeId
>
{
self
.
components
.
get
(
idx
as
usize
)
.
copied
(
)
.
ok_or_else
(
|
|
{
format_err
!
(
offset
"
unknown
component
{
idx
}
:
component
index
out
of
bounds
"
)
}
)
}
fn
instance_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
ComponentInstanceTypeId
>
{
self
.
instances
.
get
(
idx
as
usize
)
.
copied
(
)
.
ok_or_else
(
|
|
{
format_err
!
(
offset
"
unknown
instance
{
idx
}
:
instance
index
out
of
bounds
"
)
}
)
}
fn
value_at
(
&
mut
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
&
ComponentValType
>
{
match
self
.
values
.
get_mut
(
idx
as
usize
)
{
Some
(
(
ty
used
)
)
if
!
*
used
=
>
{
*
used
=
true
;
Ok
(
ty
)
}
Some
(
_
)
=
>
bail
!
(
offset
"
value
{
idx
}
cannot
be
used
more
than
once
"
)
None
=
>
bail
!
(
offset
"
unknown
value
{
idx
}
:
value
index
out
of
bounds
"
)
}
}
fn
defined_type_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
ComponentDefinedTypeId
>
{
match
self
.
component_type_at
(
idx
offset
)
?
{
ComponentAnyTypeId
:
:
Defined
(
id
)
=
>
Ok
(
id
)
_
=
>
bail
!
(
offset
"
type
index
{
idx
}
is
not
a
defined
type
"
)
}
}
fn
core_function_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
CoreTypeId
>
{
match
self
.
core_funcs
.
get
(
idx
as
usize
)
{
Some
(
id
)
=
>
Ok
(
*
id
)
None
=
>
bail
!
(
offset
"
unknown
core
function
{
idx
}
:
function
index
out
of
bounds
"
)
}
}
fn
module_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
ComponentCoreModuleTypeId
>
{
match
self
.
core_modules
.
get
(
idx
as
usize
)
{
Some
(
id
)
=
>
Ok
(
*
id
)
None
=
>
bail
!
(
offset
"
unknown
module
{
idx
}
:
module
index
out
of
bounds
"
)
}
}
fn
core_instance_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
ComponentCoreInstanceTypeId
>
{
match
self
.
core_instances
.
get
(
idx
as
usize
)
{
Some
(
id
)
=
>
Ok
(
*
id
)
None
=
>
bail
!
(
offset
"
unknown
core
instance
{
idx
}
:
instance
index
out
of
bounds
"
)
}
}
fn
core_instance_export
<
'
a
>
(
&
self
instance_index
:
u32
name
:
&
str
types
:
&
'
a
TypeList
offset
:
usize
)
-
>
Result
<
&
'
a
EntityType
>
{
match
types
[
self
.
core_instance_at
(
instance_index
offset
)
?
]
.
internal_exports
(
types
)
.
get
(
name
)
{
Some
(
export
)
=
>
Ok
(
export
)
None
=
>
bail
!
(
offset
"
core
instance
{
instance_index
}
has
no
export
named
{
name
}
"
)
}
}
fn
global_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
&
GlobalType
>
{
match
self
.
core_globals
.
get
(
idx
as
usize
)
{
Some
(
t
)
=
>
Ok
(
t
)
None
=
>
bail
!
(
offset
"
unknown
global
{
idx
}
:
global
index
out
of
bounds
"
)
}
}
fn
table_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
&
TableType
>
{
match
self
.
core_tables
.
get
(
idx
as
usize
)
{
Some
(
t
)
=
>
Ok
(
t
)
None
=
>
bail
!
(
offset
"
unknown
table
{
idx
}
:
table
index
out
of
bounds
"
)
}
}
fn
memory_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
&
MemoryType
>
{
match
self
.
core_memories
.
get
(
idx
as
usize
)
{
Some
(
t
)
=
>
Ok
(
t
)
None
=
>
bail
!
(
offset
"
unknown
memory
{
idx
}
:
memory
index
out
of
bounds
"
)
}
}
pub
fn
finish
(
&
mut
self
types
:
&
TypeAlloc
offset
:
usize
)
-
>
Result
<
ComponentType
>
{
let
mut
ty
=
ComponentType
{
info
:
self
.
type_info
imports
:
self
.
imports
.
clone
(
)
exports
:
self
.
exports
.
clone
(
)
defined_resources
:
Default
:
:
default
(
)
imported_resources
:
mem
:
:
take
(
&
mut
self
.
imported_resources
)
.
into_iter
(
)
.
collect
(
)
explicit_resources
:
mem
:
:
take
(
&
mut
self
.
explicit_resources
)
}
;
let
mut
free
=
IndexSet
:
:
default
(
)
;
for
ty
in
ty
.
imports
.
values
(
)
{
types
.
free_variables_component_entity
(
ty
&
mut
free
)
;
}
for
(
resource
_path
)
in
self
.
defined_resources
.
iter
(
)
{
if
free
.
contains
(
resource
)
{
bail
!
(
offset
"
local
resource
type
found
in
imports
"
)
;
}
}
free
.
clear
(
)
;
for
ty
in
ty
.
exports
.
values
(
)
{
types
.
free_variables_component_entity
(
ty
&
mut
free
)
;
}
for
(
id
_rep
)
in
mem
:
:
take
(
&
mut
self
.
defined_resources
)
{
if
!
free
.
contains
(
&
id
)
{
continue
;
}
let
path
=
match
ty
.
explicit_resources
.
get
(
&
id
)
.
cloned
(
)
{
Some
(
path
)
=
>
path
None
=
>
bail
!
(
offset
"
local
resource
type
found
in
export
but
not
exported
itself
"
)
}
;
ty
.
defined_resources
.
push
(
(
id
path
)
)
;
}
Ok
(
ty
)
}
fn
check_value_support
(
&
self
features
:
&
WasmFeatures
offset
:
usize
)
-
>
Result
<
(
)
>
{
if
!
features
.
component_model_values
(
)
{
bail
!
(
offset
"
support
for
component
model
value
s
is
not
enabled
"
)
;
}
Ok
(
(
)
)
}
}
impl
InternRecGroup
for
ComponentState
{
fn
add_type_id
(
&
mut
self
id
:
CoreTypeId
)
{
self
.
core_types
.
push
(
ComponentCoreTypeId
:
:
Sub
(
id
)
)
;
}
fn
type_id_at
(
&
self
idx
:
u32
offset
:
usize
)
-
>
Result
<
CoreTypeId
>
{
match
self
.
core_type_at
(
idx
offset
)
?
{
ComponentCoreTypeId
:
:
Sub
(
id
)
=
>
Ok
(
id
)
ComponentCoreTypeId
:
:
Module
(
_
)
=
>
{
bail
!
(
offset
"
type
index
{
idx
}
is
a
module
type
not
a
sub
type
"
)
;
}
}
}
fn
types_len
(
&
self
)
-
>
u32
{
u32
:
:
try_from
(
self
.
core_types
.
len
(
)
)
.
unwrap
(
)
}
}
impl
ComponentNameContext
{
fn
register
(
&
mut
self
name
:
&
str
id
:
AliasableResourceId
)
{
let
idx
=
self
.
all_resource_names
.
len
(
)
;
let
prev
=
self
.
resource_name_map
.
insert
(
id
idx
)
;
assert
!
(
prev
.
is_none
(
)
"
for
{
id
:
?
}
inserted
{
idx
:
?
}
but
already
had
{
prev
:
?
}
"
)
;
self
.
all_resource_names
.
insert
(
name
.
to_string
(
)
)
;
}
fn
validate_extern
(
&
self
name
:
&
str
kind
:
ExternKind
ty
:
&
ComponentEntityType
types
:
&
TypeAlloc
offset
:
usize
kind_names
:
&
mut
IndexSet
<
ComponentName
>
items
:
&
mut
IndexMap
<
String
ComponentEntityType
>
info
:
&
mut
TypeInfo
features
:
&
WasmFeatures
)
-
>
Result
<
(
)
>
{
let
kebab
=
ComponentName
:
:
new_with_features
(
name
offset
*
features
)
.
with_context
(
|
|
format
!
(
"
{
}
name
{
name
}
is
not
a
valid
extern
name
"
kind
.
desc
(
)
)
)
?
;
if
let
ExternKind
:
:
Export
=
kind
{
match
kebab
.
kind
(
)
{
ComponentNameKind
:
:
Label
(
_
)
|
ComponentNameKind
:
:
Method
(
_
)
|
ComponentNameKind
:
:
Static
(
_
)
|
ComponentNameKind
:
:
Constructor
(
_
)
|
ComponentNameKind
:
:
Interface
(
_
)
=
>
{
}
ComponentNameKind
:
:
Hash
(
_
)
|
ComponentNameKind
:
:
Url
(
_
)
|
ComponentNameKind
:
:
Dependency
(
_
)
=
>
{
bail
!
(
offset
"
name
{
name
}
is
not
a
valid
export
name
"
)
}
}
}
self
.
validate
(
&
kebab
ty
types
offset
)
.
with_context
(
|
|
format
!
(
"
{
}
name
{
kebab
}
is
not
valid
"
kind
.
desc
(
)
)
)
?
;
if
let
Some
(
prev
)
=
kind_names
.
replace
(
kebab
.
clone
(
)
)
{
bail
!
(
offset
"
{
}
name
{
kebab
}
conflicts
with
previous
name
{
prev
}
"
kind
.
desc
(
)
)
;
}
match
items
.
entry
(
name
.
to_string
(
)
)
{
Entry
:
:
Occupied
(
e
)
=
>
{
bail
!
(
offset
"
{
kind
}
name
{
name
}
conflicts
with
previous
name
{
prev
}
"
kind
=
kind
.
desc
(
)
prev
=
e
.
key
(
)
)
;
}
Entry
:
:
Vacant
(
e
)
=
>
{
e
.
insert
(
*
ty
)
;
info
.
combine
(
ty
.
info
(
types
)
offset
)
?
;
}
}
Ok
(
(
)
)
}
fn
validate
(
&
self
name
:
&
ComponentName
ty
:
&
ComponentEntityType
types
:
&
TypeAlloc
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
func
=
|
|
{
let
id
=
match
ty
{
ComponentEntityType
:
:
Func
(
id
)
=
>
*
id
_
=
>
bail
!
(
offset
"
item
is
not
a
func
"
)
}
;
Ok
(
&
types
[
id
]
)
}
;
match
name
.
kind
(
)
{
ComponentNameKind
:
:
Label
(
_
)
|
ComponentNameKind
:
:
Interface
(
_
)
|
ComponentNameKind
:
:
Url
(
_
)
|
ComponentNameKind
:
:
Dependency
(
_
)
|
ComponentNameKind
:
:
Hash
(
_
)
=
>
{
}
ComponentNameKind
:
:
Constructor
(
rname
)
=
>
{
let
ty
=
func
(
)
?
;
if
ty
.
results
.
len
(
)
!
=
1
{
bail
!
(
offset
"
function
should
return
one
value
"
)
;
}
let
ty
=
ty
.
results
[
0
]
.
1
;
let
resource
=
match
ty
{
ComponentValType
:
:
Primitive
(
_
)
=
>
None
ComponentValType
:
:
Type
(
ty
)
=
>
match
&
types
[
ty
]
{
ComponentDefinedType
:
:
Own
(
id
)
=
>
Some
(
id
)
_
=
>
None
}
}
;
let
resource
=
match
resource
{
Some
(
id
)
=
>
id
None
=
>
bail
!
(
offset
"
function
should
return
(
own
T
)
"
)
}
;
self
.
validate_resource_name
(
*
resource
rname
offset
)
?
;
}
ComponentNameKind
:
:
Method
(
name
)
=
>
{
let
ty
=
func
(
)
?
;
if
ty
.
params
.
len
(
)
=
=
0
{
bail
!
(
offset
"
function
should
have
at
least
one
argument
"
)
;
}
let
(
pname
pty
)
=
&
ty
.
params
[
0
]
;
if
pname
.
as_str
(
)
!
=
"
self
"
{
bail
!
(
offset
"
function
should
have
a
first
argument
called
self
"
)
;
}
let
id
=
match
pty
{
ComponentValType
:
:
Primitive
(
_
)
=
>
None
ComponentValType
:
:
Type
(
ty
)
=
>
match
&
types
[
*
ty
]
{
ComponentDefinedType
:
:
Borrow
(
id
)
=
>
Some
(
id
)
_
=
>
None
}
}
;
let
id
=
match
id
{
Some
(
id
)
=
>
id
None
=
>
bail
!
(
offset
"
function
should
take
a
first
argument
of
(
borrow
T
)
"
)
}
;
self
.
validate_resource_name
(
*
id
name
.
resource
(
)
offset
)
?
;
}
ComponentNameKind
:
:
Static
(
name
)
=
>
{
func
(
)
?
;
if
!
self
.
all_resource_names
.
contains
(
name
.
resource
(
)
.
as_str
(
)
)
{
bail
!
(
offset
"
static
resource
name
is
not
known
in
this
context
"
)
;
}
}
}
Ok
(
(
)
)
}
fn
validate_resource_name
(
&
self
id
:
AliasableResourceId
name
:
&
KebabStr
offset
:
usize
)
-
>
Result
<
(
)
>
{
let
expected_name_idx
=
match
self
.
resource_name_map
.
get
(
&
id
)
{
Some
(
idx
)
=
>
*
idx
None
=
>
{
bail
!
(
offset
"
resource
used
in
function
does
not
have
a
name
in
this
context
"
)
}
}
;
let
expected_name
=
&
self
.
all_resource_names
[
expected_name_idx
]
;
if
name
.
as_str
(
)
!
=
expected_name
{
bail
!
(
offset
"
function
does
not
match
expected
\
resource
name
{
expected_name
}
"
)
;
}
Ok
(
(
)
)
}
}
use
self
:
:
append_only
:
:
*
;
mod
append_only
{
use
crate
:
:
prelude
:
:
IndexMap
;
use
core
:
:
hash
:
:
Hash
;
use
core
:
:
ops
:
:
Deref
;
pub
struct
IndexMapAppendOnly
<
K
V
>
(
IndexMap
<
K
V
>
)
;
impl
<
K
V
>
IndexMapAppendOnly
<
K
V
>
where
K
:
Hash
+
Eq
+
Ord
+
PartialEq
+
Clone
{
pub
fn
insert
(
&
mut
self
key
:
K
value
:
V
)
{
let
prev
=
self
.
0
.
insert
(
key
value
)
;
assert
!
(
prev
.
is_none
(
)
)
;
}
}
impl
<
K
V
>
Deref
for
IndexMapAppendOnly
<
K
V
>
{
type
Target
=
IndexMap
<
K
V
>
;
fn
deref
(
&
self
)
-
>
&
IndexMap
<
K
V
>
{
&
self
.
0
}
}
impl
<
K
V
>
Default
for
IndexMapAppendOnly
<
K
V
>
{
fn
default
(
)
-
>
Self
{
Self
(
Default
:
:
default
(
)
)
}
}
impl
<
K
V
>
IntoIterator
for
IndexMapAppendOnly
<
K
V
>
{
type
IntoIter
=
<
IndexMap
<
K
V
>
as
IntoIterator
>
:
:
IntoIter
;
type
Item
=
<
IndexMap
<
K
V
>
as
IntoIterator
>
:
:
Item
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
0
.
into_iter
(
)
}
}
}
