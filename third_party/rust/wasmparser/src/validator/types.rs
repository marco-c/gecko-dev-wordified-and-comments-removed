use
super
:
:
{
component
:
:
ComponentState
core
:
:
Module
}
;
use
crate
:
:
{
FuncType
GlobalType
MemoryType
PrimitiveValType
TableType
ValType
}
;
use
indexmap
:
:
{
IndexMap
IndexSet
}
;
use
std
:
:
{
borrow
:
:
Borrow
hash
:
:
{
Hash
Hasher
}
mem
sync
:
:
Arc
}
;
const
MAX_FLAT_FUNC_PARAMS
:
usize
=
16
;
const
MAX_FLAT_FUNC_RESULTS
:
usize
=
1
;
const
MAX_LOWERED_TYPES
:
usize
=
MAX_FLAT_FUNC_PARAMS
+
1
;
pub
(
crate
)
struct
LoweredTypes
{
types
:
[
ValType
;
MAX_LOWERED_TYPES
]
len
:
usize
max
:
usize
}
impl
LoweredTypes
{
fn
new
(
max
:
usize
)
-
>
Self
{
assert
!
(
max
<
=
MAX_LOWERED_TYPES
)
;
Self
{
types
:
[
ValType
:
:
I32
;
MAX_LOWERED_TYPES
]
len
:
0
max
}
}
fn
len
(
&
self
)
-
>
usize
{
self
.
len
}
fn
maxed
(
&
self
)
-
>
bool
{
self
.
len
=
=
self
.
max
}
fn
get_mut
(
&
mut
self
index
:
usize
)
-
>
Option
<
&
mut
ValType
>
{
if
index
<
self
.
len
{
Some
(
&
mut
self
.
types
[
index
]
)
}
else
{
None
}
}
fn
push
(
&
mut
self
ty
:
ValType
)
-
>
bool
{
if
self
.
maxed
(
)
{
return
false
;
}
self
.
types
[
self
.
len
]
=
ty
;
self
.
len
+
=
1
;
true
}
fn
clear
(
&
mut
self
)
{
self
.
len
=
0
;
}
pub
fn
as_slice
(
&
self
)
-
>
&
[
ValType
]
{
&
self
.
types
[
.
.
self
.
len
]
}
pub
fn
iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
ValType
>
+
'
_
{
self
.
as_slice
(
)
.
iter
(
)
.
copied
(
)
}
}
pub
(
crate
)
struct
LoweringInfo
{
pub
(
crate
)
params
:
LoweredTypes
pub
(
crate
)
results
:
LoweredTypes
pub
(
crate
)
requires_memory
:
bool
pub
(
crate
)
requires_realloc
:
bool
}
impl
LoweringInfo
{
pub
(
crate
)
fn
into_func_type
(
self
)
-
>
FuncType
{
FuncType
{
params
:
self
.
params
.
as_slice
(
)
.
to_vec
(
)
.
into_boxed_slice
(
)
returns
:
self
.
results
.
as_slice
(
)
.
to_vec
(
)
.
into_boxed_slice
(
)
}
}
}
impl
Default
for
LoweringInfo
{
fn
default
(
)
-
>
Self
{
Self
{
params
:
LoweredTypes
:
:
new
(
MAX_FLAT_FUNC_PARAMS
)
results
:
LoweredTypes
:
:
new
(
MAX_FLAT_FUNC_RESULTS
)
requires_memory
:
false
requires_realloc
:
false
}
}
}
fn
push_primitive_wasm_types
(
ty
:
&
PrimitiveValType
lowered_types
:
&
mut
LoweredTypes
)
-
>
bool
{
match
ty
{
PrimitiveValType
:
:
Unit
=
>
true
PrimitiveValType
:
:
Bool
|
PrimitiveValType
:
:
S8
|
PrimitiveValType
:
:
U8
|
PrimitiveValType
:
:
S16
|
PrimitiveValType
:
:
U16
|
PrimitiveValType
:
:
S32
|
PrimitiveValType
:
:
U32
|
PrimitiveValType
:
:
Char
=
>
lowered_types
.
push
(
ValType
:
:
I32
)
PrimitiveValType
:
:
S64
|
PrimitiveValType
:
:
U64
=
>
lowered_types
.
push
(
ValType
:
:
I64
)
PrimitiveValType
:
:
Float32
=
>
lowered_types
.
push
(
ValType
:
:
F32
)
PrimitiveValType
:
:
Float64
=
>
lowered_types
.
push
(
ValType
:
:
F64
)
PrimitiveValType
:
:
String
=
>
{
lowered_types
.
push
(
ValType
:
:
I32
)
&
&
lowered_types
.
push
(
ValType
:
:
I32
)
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
TypeId
{
pub
(
crate
)
type_size
:
usize
pub
(
crate
)
index
:
usize
}
#
[
derive
(
Debug
)
]
pub
enum
Type
{
Func
(
FuncType
)
Module
(
ModuleType
)
Instance
(
InstanceType
)
Component
(
ComponentType
)
ComponentInstance
(
ComponentInstanceType
)
ComponentFunc
(
ComponentFuncType
)
Defined
(
ComponentDefinedType
)
}
impl
Type
{
pub
fn
as_func_type
(
&
self
)
-
>
Option
<
&
FuncType
>
{
match
self
{
Self
:
:
Func
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
pub
fn
as_module_type
(
&
self
)
-
>
Option
<
&
ModuleType
>
{
match
self
{
Self
:
:
Module
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
pub
fn
as_instance_type
(
&
self
)
-
>
Option
<
&
InstanceType
>
{
match
self
{
Self
:
:
Instance
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
pub
fn
as_component_type
(
&
self
)
-
>
Option
<
&
ComponentType
>
{
match
self
{
Self
:
:
Component
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
pub
fn
as_component_instance_type
(
&
self
)
-
>
Option
<
&
ComponentInstanceType
>
{
match
self
{
Self
:
:
ComponentInstance
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
pub
fn
as_component_func_type
(
&
self
)
-
>
Option
<
&
ComponentFuncType
>
{
match
self
{
Self
:
:
ComponentFunc
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
pub
fn
as_defined_type
(
&
self
)
-
>
Option
<
&
ComponentDefinedType
>
{
match
self
{
Self
:
:
Defined
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
pub
(
crate
)
fn
type_size
(
&
self
)
-
>
usize
{
match
self
{
Self
:
:
Func
(
ty
)
=
>
1
+
ty
.
params
.
len
(
)
+
ty
.
returns
.
len
(
)
Self
:
:
Module
(
ty
)
=
>
ty
.
type_size
Self
:
:
Instance
(
ty
)
=
>
ty
.
type_size
Self
:
:
Component
(
ty
)
=
>
ty
.
type_size
Self
:
:
ComponentInstance
(
ty
)
=
>
ty
.
type_size
Self
:
:
ComponentFunc
(
ty
)
=
>
ty
.
type_size
Self
:
:
Defined
(
ty
)
=
>
ty
.
type_size
(
)
}
}
}
#
[
derive
(
Debug
Clone
Copy
)
]
pub
enum
ComponentValType
{
Primitive
(
PrimitiveValType
)
Type
(
TypeId
)
}
impl
ComponentValType
{
pub
(
crate
)
fn
requires_realloc
(
&
self
types
:
&
TypeList
)
-
>
bool
{
match
self
{
ComponentValType
:
:
Primitive
(
ty
)
=
>
ty
.
requires_realloc
(
)
ComponentValType
:
:
Type
(
ty
)
=
>
types
[
*
ty
]
.
as_defined_type
(
)
.
unwrap
(
)
.
requires_realloc
(
types
)
}
}
pub
(
crate
)
fn
is_optional
(
&
self
types
:
&
TypeList
)
-
>
bool
{
match
self
{
ComponentValType
:
:
Primitive
(
_
)
=
>
false
ComponentValType
:
:
Type
(
ty
)
=
>
{
matches
!
(
types
[
*
ty
]
.
as_defined_type
(
)
.
unwrap
(
)
ComponentDefinedType
:
:
Option
(
_
)
)
}
}
}
pub
(
crate
)
fn
is_subtype_of
(
&
self
other
:
&
Self
types
:
&
TypeList
)
-
>
bool
{
match
(
self
other
)
{
(
ComponentValType
:
:
Primitive
(
ty
)
ComponentValType
:
:
Primitive
(
other_ty
)
)
=
>
{
ty
.
is_subtype_of
(
other_ty
)
}
(
ComponentValType
:
:
Type
(
ty
)
ComponentValType
:
:
Type
(
other_ty
)
)
=
>
types
[
*
ty
]
.
as_defined_type
(
)
.
unwrap
(
)
.
is_subtype_of
(
types
[
*
other_ty
]
.
as_defined_type
(
)
.
unwrap
(
)
types
)
_
=
>
false
}
}
fn
push_wasm_types
(
&
self
types
:
&
TypeList
lowered_types
:
&
mut
LoweredTypes
)
-
>
bool
{
match
self
{
Self
:
:
Primitive
(
ty
)
=
>
push_primitive_wasm_types
(
ty
lowered_types
)
Self
:
:
Type
(
id
)
=
>
types
[
*
id
]
.
as_defined_type
(
)
.
unwrap
(
)
.
push_wasm_types
(
types
lowered_types
)
}
}
pub
(
crate
)
fn
type_size
(
&
self
)
-
>
usize
{
match
self
{
Self
:
:
Primitive
(
ty
)
=
>
ty
.
type_size
(
)
Self
:
:
Type
(
id
)
=
>
id
.
type_size
}
}
}
#
[
derive
(
Debug
Clone
Copy
)
]
pub
enum
EntityType
{
Func
(
TypeId
)
Table
(
TableType
)
Memory
(
MemoryType
)
Global
(
GlobalType
)
Tag
(
TypeId
)
}
impl
EntityType
{
pub
(
crate
)
fn
is_subtype_of
(
&
self
b
:
&
Self
types
:
&
TypeList
)
-
>
bool
{
macro_rules
!
limits_match
{
(
a
:
expr
b
:
expr
)
=
>
{
{
let
a
=
a
;
let
b
=
b
;
a
.
initial
>
=
b
.
initial
&
&
match
b
.
maximum
{
Some
(
b_max
)
=
>
match
a
.
maximum
{
Some
(
a_max
)
=
>
a_max
<
=
b_max
None
=
>
false
}
None
=
>
true
}
}
}
;
}
match
(
self
b
)
{
(
EntityType
:
:
Func
(
a
)
EntityType
:
:
Func
(
b
)
)
=
>
{
types
[
*
a
]
.
as_func_type
(
)
.
unwrap
(
)
=
=
types
[
*
b
]
.
as_func_type
(
)
.
unwrap
(
)
}
(
EntityType
:
:
Table
(
a
)
EntityType
:
:
Table
(
b
)
)
=
>
{
a
.
element_type
=
=
b
.
element_type
&
&
limits_match
!
(
a
b
)
}
(
EntityType
:
:
Memory
(
a
)
EntityType
:
:
Memory
(
b
)
)
=
>
{
a
.
shared
=
=
b
.
shared
&
&
a
.
memory64
=
=
b
.
memory64
&
&
limits_match
!
(
a
b
)
}
(
EntityType
:
:
Global
(
a
)
EntityType
:
:
Global
(
b
)
)
=
>
a
=
=
b
(
EntityType
:
:
Tag
(
a
)
EntityType
:
:
Tag
(
b
)
)
=
>
{
types
[
*
a
]
.
as_func_type
(
)
.
unwrap
(
)
=
=
types
[
*
b
]
.
as_func_type
(
)
.
unwrap
(
)
}
_
=
>
false
}
}
pub
(
crate
)
fn
desc
(
&
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
Func
(
_
)
=
>
"
function
"
Self
:
:
Table
(
_
)
=
>
"
table
"
Self
:
:
Memory
(
_
)
=
>
"
memory
"
Self
:
:
Global
(
_
)
=
>
"
global
"
Self
:
:
Tag
(
_
)
=
>
"
tag
"
}
}
pub
(
crate
)
fn
type_size
(
&
self
)
-
>
usize
{
match
self
{
Self
:
:
Func
(
id
)
|
Self
:
:
Tag
(
id
)
=
>
id
.
type_size
Self
:
:
Table
(
_
)
|
Self
:
:
Memory
(
_
)
|
Self
:
:
Global
(
_
)
=
>
1
}
}
}
trait
ModuleImportKey
{
fn
module
(
&
self
)
-
>
&
str
;
fn
name
(
&
self
)
-
>
&
str
;
}
impl
<
'
a
>
Borrow
<
dyn
ModuleImportKey
+
'
a
>
for
(
String
String
)
{
fn
borrow
(
&
self
)
-
>
&
(
dyn
ModuleImportKey
+
'
a
)
{
self
}
}
impl
Hash
for
(
dyn
ModuleImportKey
+
'
_
)
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
module
(
)
.
hash
(
state
)
;
self
.
name
(
)
.
hash
(
state
)
;
}
}
impl
PartialEq
for
(
dyn
ModuleImportKey
+
'
_
)
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
module
(
)
=
=
other
.
module
(
)
&
&
self
.
name
(
)
=
=
other
.
name
(
)
}
}
impl
Eq
for
(
dyn
ModuleImportKey
+
'
_
)
{
}
impl
ModuleImportKey
for
(
String
String
)
{
fn
module
(
&
self
)
-
>
&
str
{
&
self
.
0
}
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
1
}
}
impl
ModuleImportKey
for
(
&
str
&
str
)
{
fn
module
(
&
self
)
-
>
&
str
{
self
.
0
}
fn
name
(
&
self
)
-
>
&
str
{
self
.
1
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ModuleType
{
pub
(
crate
)
type_size
:
usize
pub
imports
:
IndexMap
<
(
String
String
)
EntityType
>
pub
exports
:
IndexMap
<
String
EntityType
>
}
impl
ModuleType
{
pub
fn
lookup_import
(
&
self
module
:
&
str
name
:
&
str
)
-
>
Option
<
&
EntityType
>
{
self
.
imports
.
get
(
&
(
module
name
)
as
&
dyn
ModuleImportKey
)
}
pub
(
crate
)
fn
is_subtype_of
(
&
self
other
:
&
Self
types
:
&
TypeList
)
-
>
bool
{
self
.
imports
.
iter
(
)
.
all
(
|
(
k
ty
)
|
match
other
.
imports
.
get
(
k
)
{
Some
(
other
)
=
>
other
.
is_subtype_of
(
ty
types
)
None
=
>
false
}
)
&
&
other
.
exports
.
iter
(
)
.
all
(
|
(
k
other
)
|
match
self
.
exports
.
get
(
k
)
{
Some
(
ty
)
=
>
ty
.
is_subtype_of
(
other
types
)
None
=
>
false
}
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
InstanceTypeKind
{
Instantiated
(
TypeId
)
Exports
(
IndexMap
<
String
EntityType
>
)
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
InstanceType
{
pub
(
crate
)
type_size
:
usize
pub
kind
:
InstanceTypeKind
}
impl
InstanceType
{
pub
(
crate
)
fn
exports
<
'
a
>
(
&
'
a
self
types
:
&
'
a
TypeList
)
-
>
&
'
a
IndexMap
<
String
EntityType
>
{
match
&
self
.
kind
{
InstanceTypeKind
:
:
Instantiated
(
id
)
=
>
&
types
[
*
id
]
.
as_module_type
(
)
.
unwrap
(
)
.
exports
InstanceTypeKind
:
:
Exports
(
exports
)
=
>
exports
}
}
}
#
[
derive
(
Debug
Clone
Copy
)
]
pub
enum
ComponentEntityType
{
Module
(
TypeId
)
Func
(
TypeId
)
Value
(
ComponentValType
)
Type
(
TypeId
)
Instance
(
TypeId
)
Component
(
TypeId
)
}
impl
ComponentEntityType
{
pub
(
crate
)
fn
is_subtype_of
(
&
self
other
:
&
Self
types
:
&
TypeList
)
-
>
bool
{
match
(
self
other
)
{
(
Self
:
:
Module
(
ty
)
Self
:
:
Module
(
other_ty
)
)
=
>
types
[
*
ty
]
.
as_module_type
(
)
.
unwrap
(
)
.
is_subtype_of
(
types
[
*
other_ty
]
.
as_module_type
(
)
.
unwrap
(
)
types
)
(
Self
:
:
Func
(
ty
)
Self
:
:
Func
(
other_ty
)
)
=
>
types
[
*
ty
]
.
as_component_func_type
(
)
.
unwrap
(
)
.
is_subtype_of
(
types
[
*
other_ty
]
.
as_component_func_type
(
)
.
unwrap
(
)
types
)
(
Self
:
:
Value
(
ty
)
Self
:
:
Value
(
other_ty
)
)
=
>
ty
.
is_subtype_of
(
other_ty
types
)
(
Self
:
:
Type
(
ty
)
Self
:
:
Type
(
other_ty
)
)
=
>
types
[
*
ty
]
.
as_defined_type
(
)
.
unwrap
(
)
.
is_subtype_of
(
types
[
*
other_ty
]
.
as_defined_type
(
)
.
unwrap
(
)
types
)
(
Self
:
:
Instance
(
ty
)
Self
:
:
Instance
(
other_ty
)
)
=
>
types
[
*
ty
]
.
as_component_instance_type
(
)
.
unwrap
(
)
.
is_subtype_of
(
types
[
*
other_ty
]
.
as_component_instance_type
(
)
.
unwrap
(
)
types
)
(
Self
:
:
Component
(
ty
)
Self
:
:
Component
(
other_ty
)
)
=
>
types
[
*
ty
]
.
as_component_type
(
)
.
unwrap
(
)
.
is_subtype_of
(
types
[
*
other_ty
]
.
as_component_type
(
)
.
unwrap
(
)
types
)
_
=
>
false
}
}
pub
(
crate
)
fn
desc
(
&
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
Module
(
_
)
=
>
"
module
"
Self
:
:
Func
(
_
)
=
>
"
function
"
Self
:
:
Value
(
_
)
=
>
"
value
"
Self
:
:
Type
(
_
)
=
>
"
type
"
Self
:
:
Instance
(
_
)
=
>
"
instance
"
Self
:
:
Component
(
_
)
=
>
"
component
"
}
}
pub
(
crate
)
fn
type_size
(
&
self
)
-
>
usize
{
match
self
{
Self
:
:
Module
(
ty
)
|
Self
:
:
Func
(
ty
)
|
Self
:
:
Type
(
ty
)
|
Self
:
:
Instance
(
ty
)
|
Self
:
:
Component
(
ty
)
=
>
ty
.
type_size
Self
:
:
Value
(
ty
)
=
>
ty
.
type_size
(
)
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ComponentType
{
pub
(
crate
)
type_size
:
usize
pub
imports
:
IndexMap
<
String
ComponentEntityType
>
pub
exports
:
IndexMap
<
String
ComponentEntityType
>
}
impl
ComponentType
{
pub
(
crate
)
fn
is_subtype_of
(
&
self
other
:
&
Self
types
:
&
TypeList
)
-
>
bool
{
self
.
imports
.
iter
(
)
.
all
(
|
(
k
ty
)
|
match
other
.
imports
.
get
(
k
)
{
Some
(
other
)
=
>
other
.
is_subtype_of
(
ty
types
)
None
=
>
false
}
)
&
&
other
.
exports
.
iter
(
)
.
all
(
|
(
k
other
)
|
match
self
.
exports
.
get
(
k
)
{
Some
(
ty
)
=
>
ty
.
is_subtype_of
(
other
types
)
None
=
>
false
}
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
ComponentInstanceTypeKind
{
Defined
(
IndexMap
<
String
ComponentEntityType
>
)
Instantiated
(
TypeId
)
Exports
(
IndexMap
<
String
ComponentEntityType
>
)
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ComponentInstanceType
{
pub
(
crate
)
type_size
:
usize
pub
kind
:
ComponentInstanceTypeKind
}
impl
ComponentInstanceType
{
pub
(
crate
)
fn
exports
<
'
a
>
(
&
'
a
self
types
:
&
'
a
TypeList
)
-
>
&
'
a
IndexMap
<
String
ComponentEntityType
>
{
match
&
self
.
kind
{
ComponentInstanceTypeKind
:
:
Defined
(
exports
)
|
ComponentInstanceTypeKind
:
:
Exports
(
exports
)
=
>
exports
ComponentInstanceTypeKind
:
:
Instantiated
(
id
)
=
>
{
&
types
[
*
id
]
.
as_component_type
(
)
.
unwrap
(
)
.
exports
}
}
}
pub
(
crate
)
fn
is_subtype_of
(
&
self
other
:
&
Self
types
:
&
TypeList
)
-
>
bool
{
let
exports
=
self
.
exports
(
types
)
;
other
.
exports
(
types
)
.
iter
(
)
.
all
(
|
(
k
other
)
|
match
exports
.
get
(
k
)
{
Some
(
ty
)
=
>
ty
.
is_subtype_of
(
other
types
)
None
=
>
false
}
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ComponentFuncType
{
pub
(
crate
)
type_size
:
usize
pub
params
:
Box
<
[
(
Option
<
String
>
ComponentValType
)
]
>
pub
result
:
ComponentValType
}
impl
ComponentFuncType
{
pub
(
crate
)
fn
is_subtype_of
(
&
self
other
:
&
Self
types
:
&
TypeList
)
-
>
bool
{
if
!
self
.
result
.
is_subtype_of
(
&
other
.
result
types
)
{
return
false
;
}
if
other
.
params
.
len
(
)
<
self
.
params
.
len
(
)
{
return
false
;
}
for
(
(
name
ty
)
(
other_name
other_ty
)
)
in
self
.
params
.
iter
(
)
.
zip
(
other
.
params
.
iter
(
)
)
{
if
name
!
=
other_name
{
return
false
;
}
if
!
other_ty
.
is_subtype_of
(
ty
types
)
{
return
false
;
}
}
other
.
params
.
iter
(
)
.
skip
(
self
.
params
.
len
(
)
)
.
all
(
|
(
_
ty
)
|
ty
.
is_optional
(
types
)
)
}
pub
(
crate
)
fn
lower
(
&
self
types
:
&
TypeList
import
:
bool
)
-
>
LoweringInfo
{
let
mut
info
=
LoweringInfo
:
:
default
(
)
;
for
(
_
ty
)
in
self
.
params
.
iter
(
)
{
if
!
import
{
info
.
requires_realloc
=
info
.
requires_realloc
|
|
ty
.
requires_realloc
(
types
)
;
}
if
!
ty
.
push_wasm_types
(
types
&
mut
info
.
params
)
{
info
.
params
.
clear
(
)
;
assert
!
(
info
.
params
.
push
(
ValType
:
:
I32
)
)
;
info
.
requires_memory
=
true
;
break
;
}
}
if
import
{
info
.
requires_realloc
=
info
.
requires_realloc
|
|
self
.
result
.
requires_realloc
(
types
)
;
}
if
!
self
.
result
.
push_wasm_types
(
types
&
mut
info
.
results
)
{
info
.
results
.
clear
(
)
;
if
import
{
info
.
params
.
max
=
MAX_LOWERED_TYPES
;
assert
!
(
info
.
params
.
push
(
ValType
:
:
I32
)
)
;
}
else
{
assert
!
(
info
.
results
.
push
(
ValType
:
:
I32
)
)
;
}
info
.
requires_memory
=
true
;
}
info
.
requires_memory
|
=
info
.
requires_realloc
;
info
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
VariantCase
{
pub
ty
:
ComponentValType
pub
refines
:
Option
<
String
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
RecordType
{
pub
(
crate
)
type_size
:
usize
pub
fields
:
IndexMap
<
String
ComponentValType
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
VariantType
{
pub
(
crate
)
type_size
:
usize
pub
cases
:
IndexMap
<
String
VariantCase
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
TupleType
{
pub
(
crate
)
type_size
:
usize
pub
types
:
Box
<
[
ComponentValType
]
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
UnionType
{
pub
(
crate
)
type_size
:
usize
pub
types
:
Box
<
[
ComponentValType
]
>
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
ComponentDefinedType
{
Primitive
(
PrimitiveValType
)
Record
(
RecordType
)
Variant
(
VariantType
)
List
(
ComponentValType
)
Tuple
(
TupleType
)
Flags
(
IndexSet
<
String
>
)
Enum
(
IndexSet
<
String
>
)
Union
(
UnionType
)
Option
(
ComponentValType
)
Expected
(
ComponentValType
ComponentValType
)
}
impl
ComponentDefinedType
{
pub
(
crate
)
fn
requires_realloc
(
&
self
types
:
&
TypeList
)
-
>
bool
{
match
self
{
Self
:
:
Primitive
(
ty
)
=
>
ty
.
requires_realloc
(
)
Self
:
:
Record
(
r
)
=
>
r
.
fields
.
values
(
)
.
any
(
|
ty
|
ty
.
requires_realloc
(
types
)
)
Self
:
:
Variant
(
v
)
=
>
v
.
cases
.
values
(
)
.
any
(
|
case
|
case
.
ty
.
requires_realloc
(
types
)
)
Self
:
:
List
(
_
)
=
>
true
Self
:
:
Tuple
(
t
)
=
>
t
.
types
.
iter
(
)
.
any
(
|
ty
|
ty
.
requires_realloc
(
types
)
)
Self
:
:
Union
(
u
)
=
>
u
.
types
.
iter
(
)
.
any
(
|
ty
|
ty
.
requires_realloc
(
types
)
)
Self
:
:
Flags
(
_
)
|
Self
:
:
Enum
(
_
)
=
>
false
Self
:
:
Option
(
ty
)
=
>
ty
.
requires_realloc
(
types
)
Self
:
:
Expected
(
ok
error
)
=
>
{
ok
.
requires_realloc
(
types
)
|
|
error
.
requires_realloc
(
types
)
}
}
}
pub
(
crate
)
fn
is_subtype_of
(
&
self
other
:
&
Self
types
:
&
TypeList
)
-
>
bool
{
match
(
self
other
)
{
(
Self
:
:
Primitive
(
ty
)
Self
:
:
Primitive
(
other_ty
)
)
=
>
ty
.
is_subtype_of
(
other_ty
)
(
Self
:
:
Record
(
r
)
Self
:
:
Record
(
other_r
)
)
=
>
{
for
(
name
ty
)
in
r
.
fields
.
iter
(
)
{
if
let
Some
(
other_ty
)
=
other_r
.
fields
.
get
(
name
)
{
if
!
ty
.
is_subtype_of
(
other_ty
types
)
{
return
false
;
}
}
else
{
}
}
for
(
other_name
other_ty
)
in
other_r
.
fields
.
iter
(
)
{
if
!
other_ty
.
is_optional
(
types
)
&
&
!
r
.
fields
.
contains_key
(
other_name
)
{
return
false
;
}
}
true
}
(
Self
:
:
Variant
(
v
)
Self
:
:
Variant
(
other_v
)
)
=
>
{
for
(
name
case
)
in
v
.
cases
.
iter
(
)
{
if
let
Some
(
other_case
)
=
other_v
.
cases
.
get
(
name
)
{
if
!
case
.
ty
.
is_subtype_of
(
&
other_case
.
ty
types
)
{
return
false
;
}
}
else
if
let
Some
(
refines
)
=
&
case
.
refines
{
if
!
other_v
.
cases
.
contains_key
(
refines
)
{
return
false
;
}
}
else
{
return
false
;
}
}
true
}
(
Self
:
:
List
(
ty
)
Self
:
:
List
(
other_ty
)
)
|
(
Self
:
:
Option
(
ty
)
Self
:
:
Option
(
other_ty
)
)
=
>
{
ty
.
is_subtype_of
(
other_ty
types
)
}
(
Self
:
:
Tuple
(
t
)
Self
:
:
Tuple
(
other_t
)
)
=
>
{
if
t
.
types
.
len
(
)
!
=
other_t
.
types
.
len
(
)
{
return
false
;
}
t
.
types
.
iter
(
)
.
zip
(
other_t
.
types
.
iter
(
)
)
.
all
(
|
(
ty
other_ty
)
|
ty
.
is_subtype_of
(
other_ty
types
)
)
}
(
Self
:
:
Union
(
u
)
Self
:
:
Union
(
other_u
)
)
=
>
{
if
u
.
types
.
len
(
)
!
=
other_u
.
types
.
len
(
)
{
return
false
;
}
u
.
types
.
iter
(
)
.
zip
(
other_u
.
types
.
iter
(
)
)
.
all
(
|
(
ty
other_ty
)
|
ty
.
is_subtype_of
(
other_ty
types
)
)
}
(
Self
:
:
Flags
(
set
)
Self
:
:
Flags
(
other_set
)
)
|
(
Self
:
:
Enum
(
set
)
Self
:
:
Enum
(
other_set
)
)
=
>
set
.
is_subset
(
other_set
)
(
Self
:
:
Expected
(
ok
error
)
Self
:
:
Expected
(
other_ok
other_error
)
)
=
>
{
ok
.
is_subtype_of
(
other_ok
types
)
&
&
error
.
is_subtype_of
(
other_error
types
)
}
_
=
>
false
}
}
pub
(
crate
)
fn
type_size
(
&
self
)
-
>
usize
{
match
self
{
Self
:
:
Primitive
(
ty
)
=
>
ty
.
type_size
(
)
Self
:
:
Flags
(
_
)
|
Self
:
:
Enum
(
_
)
=
>
1
Self
:
:
Record
(
r
)
=
>
r
.
type_size
Self
:
:
Variant
(
v
)
=
>
v
.
type_size
Self
:
:
Tuple
(
t
)
=
>
t
.
type_size
Self
:
:
Union
(
u
)
=
>
u
.
type_size
Self
:
:
List
(
ty
)
|
Self
:
:
Option
(
ty
)
=
>
ty
.
type_size
(
)
Self
:
:
Expected
(
ok
error
)
=
>
ok
.
type_size
(
)
+
error
.
type_size
(
)
}
}
fn
push_wasm_types
(
&
self
types
:
&
TypeList
lowered_types
:
&
mut
LoweredTypes
)
-
>
bool
{
match
self
{
Self
:
:
Primitive
(
ty
)
=
>
push_primitive_wasm_types
(
ty
lowered_types
)
Self
:
:
Record
(
r
)
=
>
r
.
fields
.
iter
(
)
.
all
(
|
(
_
ty
)
|
ty
.
push_wasm_types
(
types
lowered_types
)
)
Self
:
:
Variant
(
v
)
=
>
Self
:
:
push_variant_wasm_types
(
v
.
cases
.
iter
(
)
.
map
(
|
(
_
case
)
|
&
case
.
ty
)
types
lowered_types
)
Self
:
:
List
(
_
)
=
>
lowered_types
.
push
(
ValType
:
:
I32
)
&
&
lowered_types
.
push
(
ValType
:
:
I32
)
Self
:
:
Tuple
(
t
)
=
>
t
.
types
.
iter
(
)
.
all
(
|
ty
|
ty
.
push_wasm_types
(
types
lowered_types
)
)
Self
:
:
Flags
(
names
)
=
>
{
(
0
.
.
(
names
.
len
(
)
+
31
)
/
32
)
.
all
(
|
_
|
lowered_types
.
push
(
ValType
:
:
I32
)
)
}
Self
:
:
Enum
(
_
)
=
>
lowered_types
.
push
(
ValType
:
:
I32
)
Self
:
:
Union
(
u
)
=
>
Self
:
:
push_variant_wasm_types
(
u
.
types
.
iter
(
)
types
lowered_types
)
Self
:
:
Option
(
ty
)
=
>
{
Self
:
:
push_variant_wasm_types
(
[
ty
]
.
into_iter
(
)
types
lowered_types
)
}
Self
:
:
Expected
(
ok
error
)
=
>
{
Self
:
:
push_variant_wasm_types
(
[
ok
error
]
.
into_iter
(
)
types
lowered_types
)
}
}
}
fn
push_variant_wasm_types
<
'
a
>
(
cases
:
impl
ExactSizeIterator
<
Item
=
&
'
a
ComponentValType
>
types
:
&
TypeList
lowered_types
:
&
mut
LoweredTypes
)
-
>
bool
{
let
pushed
=
if
cases
.
len
(
)
<
=
u32
:
:
max_value
(
)
as
usize
{
lowered_types
.
push
(
ValType
:
:
I32
)
}
else
{
lowered_types
.
push
(
ValType
:
:
I64
)
}
;
if
!
pushed
{
return
false
;
}
let
start
=
lowered_types
.
len
(
)
;
for
ty
in
cases
{
let
mut
temp
=
LoweredTypes
:
:
new
(
lowered_types
.
max
)
;
if
!
ty
.
push_wasm_types
(
types
&
mut
temp
)
{
return
false
;
}
for
(
i
ty
)
in
temp
.
iter
(
)
.
enumerate
(
)
{
match
lowered_types
.
get_mut
(
start
+
i
)
{
Some
(
prev
)
=
>
*
prev
=
Self
:
:
join_types
(
*
prev
ty
)
None
=
>
{
if
!
lowered_types
.
push
(
ty
)
{
return
false
;
}
}
}
}
}
true
}
fn
join_types
(
a
:
ValType
b
:
ValType
)
-
>
ValType
{
use
ValType
:
:
*
;
match
(
a
b
)
{
(
I32
I32
)
|
(
I64
I64
)
|
(
F32
F32
)
|
(
F64
F64
)
=
>
a
(
I32
F32
)
|
(
F32
I32
)
=
>
I32
(
_
I64
|
F64
)
|
(
I64
|
F64
_
)
=
>
I64
_
=
>
panic
!
(
"
unexpected
wasm
type
for
canonical
ABI
"
)
}
}
}
#
[
allow
(
clippy
:
:
large_enum_variant
)
]
enum
TypesKind
{
Module
(
Arc
<
Module
>
)
Component
(
ComponentState
)
}
pub
struct
Types
{
types
:
TypeList
kind
:
TypesKind
}
impl
Types
{
pub
(
crate
)
fn
from_module
(
types
:
TypeList
module
:
Arc
<
Module
>
)
-
>
Self
{
Self
{
types
kind
:
TypesKind
:
:
Module
(
module
)
}
}
pub
(
crate
)
fn
from_component
(
types
:
TypeList
component
:
ComponentState
)
-
>
Self
{
Self
{
types
kind
:
TypesKind
:
:
Component
(
component
)
}
}
fn
types
(
&
self
core
:
bool
)
-
>
Option
<
&
Vec
<
TypeId
>
>
{
Some
(
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
{
if
core
{
&
module
.
types
}
else
{
return
None
;
}
}
TypesKind
:
:
Component
(
component
)
=
>
{
if
core
{
&
component
.
core_types
}
else
{
&
component
.
types
}
}
}
)
}
pub
fn
type_from_id
(
&
self
id
:
TypeId
)
-
>
Option
<
&
Type
>
{
self
.
types
.
get
(
id
.
index
)
}
pub
fn
id_from_type_index
(
&
self
index
:
u32
core
:
bool
)
-
>
Option
<
TypeId
>
{
self
.
types
(
core
)
?
.
get
(
index
as
usize
)
.
copied
(
)
}
pub
fn
type_at
(
&
self
index
:
u32
core
:
bool
)
-
>
Option
<
&
Type
>
{
self
.
type_from_id
(
*
self
.
types
(
core
)
?
.
get
(
index
as
usize
)
?
)
}
pub
fn
func_type_at
(
&
self
index
:
u32
)
-
>
Option
<
&
FuncType
>
{
match
self
.
type_at
(
index
true
)
?
{
Type
:
:
Func
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
pub
fn
type_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
module
.
types
.
len
(
)
TypesKind
:
:
Component
(
component
)
=
>
component
.
core_types
.
len
(
)
}
}
pub
fn
table_at
(
&
self
index
:
u32
)
-
>
Option
<
TableType
>
{
let
tables
=
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
&
module
.
tables
TypesKind
:
:
Component
(
component
)
=
>
&
component
.
core_tables
}
;
tables
.
get
(
index
as
usize
)
.
copied
(
)
}
pub
fn
table_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
module
.
tables
.
len
(
)
TypesKind
:
:
Component
(
component
)
=
>
component
.
core_tables
.
len
(
)
}
}
pub
fn
memory_at
(
&
self
index
:
u32
)
-
>
Option
<
MemoryType
>
{
let
memories
=
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
&
module
.
memories
TypesKind
:
:
Component
(
component
)
=
>
&
component
.
core_memories
}
;
memories
.
get
(
index
as
usize
)
.
copied
(
)
}
pub
fn
memory_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
module
.
memories
.
len
(
)
TypesKind
:
:
Component
(
component
)
=
>
component
.
core_memories
.
len
(
)
}
}
pub
fn
global_at
(
&
self
index
:
u32
)
-
>
Option
<
GlobalType
>
{
let
globals
=
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
&
module
.
globals
TypesKind
:
:
Component
(
component
)
=
>
&
component
.
core_globals
}
;
globals
.
get
(
index
as
usize
)
.
copied
(
)
}
pub
fn
global_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
module
.
globals
.
len
(
)
TypesKind
:
:
Component
(
component
)
=
>
component
.
core_globals
.
len
(
)
}
}
pub
fn
tag_at
(
&
self
index
:
u32
)
-
>
Option
<
&
FuncType
>
{
let
tags
=
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
&
module
.
tags
TypesKind
:
:
Component
(
component
)
=
>
&
component
.
core_tags
}
;
Some
(
self
.
types
[
*
tags
.
get
(
index
as
usize
)
?
]
.
as_func_type
(
)
.
unwrap
(
)
)
}
pub
fn
tag_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
module
.
tags
.
len
(
)
TypesKind
:
:
Component
(
component
)
=
>
component
.
core_tags
.
len
(
)
}
}
pub
fn
function_at
(
&
self
index
:
u32
)
-
>
Option
<
&
FuncType
>
{
let
id
=
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
{
&
module
.
types
[
*
module
.
functions
.
get
(
index
as
usize
)
?
as
usize
]
}
TypesKind
:
:
Component
(
component
)
=
>
component
.
core_funcs
.
get
(
index
as
usize
)
?
}
;
match
&
self
.
types
[
*
id
]
{
Type
:
:
Func
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
pub
fn
function_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
module
.
functions
.
len
(
)
TypesKind
:
:
Component
(
component
)
=
>
component
.
core_funcs
.
len
(
)
}
}
pub
fn
element_at
(
&
self
index
:
u32
)
-
>
Option
<
ValType
>
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
module
.
element_types
.
get
(
index
as
usize
)
.
copied
(
)
TypesKind
:
:
Component
(
_
)
=
>
None
}
}
pub
fn
element_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
module
)
=
>
module
.
element_types
.
len
(
)
TypesKind
:
:
Component
(
_
)
=
>
0
}
}
pub
fn
component_function_at
(
&
self
index
:
u32
)
-
>
Option
<
&
ComponentFuncType
>
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
None
TypesKind
:
:
Component
(
component
)
=
>
Some
(
self
.
types
[
*
component
.
funcs
.
get
(
index
as
usize
)
?
]
.
as_component_func_type
(
)
.
unwrap
(
)
)
}
}
pub
fn
component_function_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
0
TypesKind
:
:
Component
(
component
)
=
>
component
.
funcs
.
len
(
)
}
}
pub
fn
module_at
(
&
self
index
:
u32
)
-
>
Option
<
&
ModuleType
>
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
None
TypesKind
:
:
Component
(
component
)
=
>
Some
(
self
.
types
[
*
component
.
core_modules
.
get
(
index
as
usize
)
?
]
.
as_module_type
(
)
.
unwrap
(
)
)
}
}
pub
fn
module_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
0
TypesKind
:
:
Component
(
component
)
=
>
component
.
core_modules
.
len
(
)
}
}
pub
fn
instance_at
(
&
self
index
:
u32
)
-
>
Option
<
&
InstanceType
>
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
None
TypesKind
:
:
Component
(
component
)
=
>
{
let
id
=
component
.
core_instances
.
get
(
index
as
usize
)
?
;
match
&
self
.
types
[
*
id
]
{
Type
:
:
Instance
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
}
}
pub
fn
instance_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
0
TypesKind
:
:
Component
(
component
)
=
>
component
.
core_instances
.
len
(
)
}
}
pub
fn
component_at
(
&
self
index
:
u32
)
-
>
Option
<
&
ComponentType
>
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
None
TypesKind
:
:
Component
(
component
)
=
>
Some
(
self
.
types
[
*
component
.
components
.
get
(
index
as
usize
)
?
]
.
as_component_type
(
)
.
unwrap
(
)
)
}
}
pub
fn
component_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
0
TypesKind
:
:
Component
(
component
)
=
>
component
.
components
.
len
(
)
}
}
pub
fn
component_instance_at
(
&
self
index
:
u32
)
-
>
Option
<
&
ComponentInstanceType
>
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
None
TypesKind
:
:
Component
(
component
)
=
>
{
let
id
=
component
.
instances
.
get
(
index
as
usize
)
?
;
match
&
self
.
types
[
*
id
]
{
Type
:
:
ComponentInstance
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
}
}
pub
fn
component_instance_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
0
TypesKind
:
:
Component
(
component
)
=
>
component
.
instances
.
len
(
)
}
}
pub
fn
value_at
(
&
self
index
:
u32
)
-
>
Option
<
ComponentValType
>
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
None
TypesKind
:
:
Component
(
component
)
=
>
{
component
.
values
.
get
(
index
as
usize
)
.
map
(
|
(
r
_
)
|
*
r
)
}
}
}
pub
fn
value_count
(
&
self
)
-
>
usize
{
match
&
self
.
kind
{
TypesKind
:
:
Module
(
_
)
=
>
0
TypesKind
:
:
Component
(
component
)
=
>
component
.
values
.
len
(
)
}
}
}
pub
(
crate
)
struct
SnapshotList
<
T
>
{
snapshots
:
Vec
<
(
usize
Arc
<
Vec
<
T
>
>
)
>
snapshots_total
:
usize
cur
:
Vec
<
T
>
}
impl
<
T
>
SnapshotList
<
T
>
{
pub
(
crate
)
fn
get
(
&
self
index
:
usize
)
-
>
Option
<
&
T
>
{
if
index
>
=
self
.
snapshots_total
{
return
self
.
cur
.
get
(
index
-
self
.
snapshots_total
)
;
}
let
i
=
match
self
.
snapshots
.
binary_search_by_key
(
&
index
|
(
i
_
)
|
*
i
)
{
Ok
(
i
)
=
>
i
Err
(
i
)
=
>
i
-
1
}
;
let
(
len
list
)
=
&
self
.
snapshots
[
i
]
;
Some
(
&
list
[
index
-
len
]
)
}
pub
(
crate
)
fn
get_mut
(
&
mut
self
index
:
usize
)
-
>
Option
<
&
mut
T
>
{
if
index
>
=
self
.
snapshots_total
{
return
self
.
cur
.
get_mut
(
index
-
self
.
snapshots_total
)
;
}
panic
!
(
"
cannot
get
a
mutable
reference
in
snapshotted
part
of
list
"
)
}
pub
(
crate
)
fn
push
(
&
mut
self
val
:
T
)
{
self
.
cur
.
push
(
val
)
;
}
pub
(
crate
)
fn
len
(
&
self
)
-
>
usize
{
self
.
cur
.
len
(
)
+
self
.
snapshots_total
}
pub
(
crate
)
fn
reserve
(
&
mut
self
additional
:
usize
)
{
self
.
cur
.
reserve
(
additional
)
;
}
pub
(
crate
)
fn
commit
(
&
mut
self
)
-
>
SnapshotList
<
T
>
{
let
len
=
self
.
cur
.
len
(
)
;
if
len
>
0
{
self
.
cur
.
shrink_to_fit
(
)
;
self
.
snapshots
.
push
(
(
self
.
snapshots_total
Arc
:
:
new
(
mem
:
:
take
(
&
mut
self
.
cur
)
)
)
)
;
self
.
snapshots_total
+
=
len
;
}
SnapshotList
{
snapshots
:
self
.
snapshots
.
clone
(
)
snapshots_total
:
self
.
snapshots_total
cur
:
Vec
:
:
new
(
)
}
}
}
impl
<
T
>
std
:
:
ops
:
:
Index
<
usize
>
for
SnapshotList
<
T
>
{
type
Output
=
T
;
fn
index
(
&
self
index
:
usize
)
-
>
&
T
{
self
.
get
(
index
)
.
unwrap
(
)
}
}
impl
<
T
>
std
:
:
ops
:
:
IndexMut
<
usize
>
for
SnapshotList
<
T
>
{
fn
index_mut
(
&
mut
self
index
:
usize
)
-
>
&
mut
T
{
self
.
get_mut
(
index
)
.
unwrap
(
)
}
}
impl
<
T
>
std
:
:
ops
:
:
Index
<
TypeId
>
for
SnapshotList
<
T
>
{
type
Output
=
T
;
fn
index
(
&
self
id
:
TypeId
)
-
>
&
T
{
self
.
get
(
id
.
index
)
.
unwrap
(
)
}
}
impl
<
T
>
std
:
:
ops
:
:
IndexMut
<
TypeId
>
for
SnapshotList
<
T
>
{
fn
index_mut
(
&
mut
self
id
:
TypeId
)
-
>
&
mut
T
{
self
.
get_mut
(
id
.
index
)
.
unwrap
(
)
}
}
impl
<
T
>
Default
for
SnapshotList
<
T
>
{
fn
default
(
)
-
>
SnapshotList
<
T
>
{
SnapshotList
{
snapshots
:
Vec
:
:
new
(
)
snapshots_total
:
0
cur
:
Vec
:
:
new
(
)
}
}
}
pub
(
crate
)
type
TypeList
=
SnapshotList
<
Type
>
;
