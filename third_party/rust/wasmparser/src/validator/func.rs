use
super
:
:
operators
:
:
{
Frame
OperatorValidator
OperatorValidatorAllocations
}
;
use
crate
:
:
{
BinaryReader
Result
ValType
VisitOperator
}
;
use
crate
:
:
{
FunctionBody
Operator
WasmFeatures
WasmModuleResources
}
;
pub
struct
FuncToValidate
<
T
>
{
resources
:
T
index
:
u32
ty
:
u32
features
:
WasmFeatures
}
impl
<
T
:
WasmModuleResources
>
FuncToValidate
<
T
>
{
pub
fn
new
(
index
:
u32
ty
:
u32
resources
:
T
features
:
&
WasmFeatures
)
-
>
FuncToValidate
<
T
>
{
FuncToValidate
{
resources
index
ty
features
:
*
features
}
}
pub
fn
into_validator
(
self
allocs
:
FuncValidatorAllocations
)
-
>
FuncValidator
<
T
>
{
let
FuncToValidate
{
resources
index
ty
features
}
=
self
;
let
validator
=
OperatorValidator
:
:
new_func
(
ty
0
&
features
&
resources
allocs
.
0
)
.
unwrap
(
)
;
FuncValidator
{
validator
resources
index
}
}
}
pub
struct
FuncValidator
<
T
>
{
validator
:
OperatorValidator
resources
:
T
index
:
u32
}
#
[
derive
(
Default
)
]
pub
struct
FuncValidatorAllocations
(
OperatorValidatorAllocations
)
;
impl
<
T
:
WasmModuleResources
>
FuncValidator
<
T
>
{
pub
fn
validate
(
&
mut
self
body
:
&
FunctionBody
<
'
_
>
)
-
>
Result
<
(
)
>
{
let
mut
reader
=
body
.
get_binary_reader
(
)
;
self
.
read_locals
(
&
mut
reader
)
?
;
reader
.
allow_memarg64
(
self
.
validator
.
features
.
memory64
)
;
while
!
reader
.
eof
(
)
{
reader
.
visit_operator
(
&
mut
self
.
visitor
(
reader
.
original_position
(
)
)
)
?
?
;
}
self
.
finish
(
reader
.
original_position
(
)
)
}
pub
fn
read_locals
(
&
mut
self
reader
:
&
mut
BinaryReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
for
_
in
0
.
.
reader
.
read_var_u32
(
)
?
{
let
offset
=
reader
.
original_position
(
)
;
let
cnt
=
reader
.
read
(
)
?
;
let
ty
=
reader
.
read
(
)
?
;
self
.
define_locals
(
offset
cnt
ty
)
?
;
}
Ok
(
(
)
)
}
pub
fn
define_locals
(
&
mut
self
offset
:
usize
count
:
u32
ty
:
ValType
)
-
>
Result
<
(
)
>
{
self
.
validator
.
define_locals
(
offset
count
ty
&
self
.
resources
)
}
pub
fn
op
(
&
mut
self
offset
:
usize
operator
:
&
Operator
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
visitor
(
offset
)
.
visit_operator
(
operator
)
}
pub
fn
visitor
<
'
this
'
a
:
'
this
>
(
&
'
this
mut
self
offset
:
usize
)
-
>
impl
VisitOperator
<
'
a
Output
=
Result
<
(
)
>
>
+
'
this
{
self
.
validator
.
with_resources
(
&
self
.
resources
offset
)
}
pub
fn
finish
(
&
mut
self
offset
:
usize
)
-
>
Result
<
(
)
>
{
self
.
validator
.
finish
(
offset
)
}
pub
fn
resources
(
&
self
)
-
>
&
T
{
&
self
.
resources
}
pub
fn
index
(
&
self
)
-
>
u32
{
self
.
index
}
pub
fn
len_locals
(
&
self
)
-
>
u32
{
self
.
validator
.
locals
.
len_locals
(
)
}
pub
fn
get_local_type
(
&
self
index
:
u32
)
-
>
Option
<
ValType
>
{
self
.
validator
.
locals
.
get
(
index
)
}
pub
fn
operand_stack_height
(
&
self
)
-
>
u32
{
self
.
validator
.
operand_stack_height
(
)
as
u32
}
pub
fn
get_operand_type
(
&
self
depth
:
usize
)
-
>
Option
<
Option
<
ValType
>
>
{
self
.
validator
.
peek_operand_at
(
depth
)
}
pub
fn
control_stack_height
(
&
self
)
-
>
u32
{
self
.
validator
.
control_stack_height
(
)
as
u32
}
pub
fn
get_control_frame
(
&
self
depth
:
usize
)
-
>
Option
<
&
Frame
>
{
self
.
validator
.
get_frame
(
depth
)
}
pub
fn
into_allocations
(
self
)
-
>
FuncValidatorAllocations
{
FuncValidatorAllocations
(
self
.
validator
.
into_allocations
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
types
:
:
CoreTypeId
;
use
crate
:
:
HeapType
;
struct
EmptyResources
(
crate
:
:
SubType
)
;
impl
Default
for
EmptyResources
{
fn
default
(
)
-
>
Self
{
EmptyResources
(
crate
:
:
SubType
{
supertype_idx
:
None
is_final
:
true
composite_type
:
crate
:
:
CompositeType
:
:
Func
(
crate
:
:
FuncType
:
:
new
(
[
]
[
]
)
)
}
)
}
}
impl
WasmModuleResources
for
EmptyResources
{
fn
table_at
(
&
self
_at
:
u32
)
-
>
Option
<
crate
:
:
TableType
>
{
todo
!
(
)
}
fn
memory_at
(
&
self
_at
:
u32
)
-
>
Option
<
crate
:
:
MemoryType
>
{
todo
!
(
)
}
fn
tag_at
(
&
self
_at
:
u32
)
-
>
Option
<
&
crate
:
:
FuncType
>
{
todo
!
(
)
}
fn
global_at
(
&
self
_at
:
u32
)
-
>
Option
<
crate
:
:
GlobalType
>
{
todo
!
(
)
}
fn
sub_type_at
(
&
self
_type_idx
:
u32
)
-
>
Option
<
&
crate
:
:
SubType
>
{
Some
(
&
self
.
0
)
}
fn
type_id_of_function
(
&
self
_at
:
u32
)
-
>
Option
<
CoreTypeId
>
{
todo
!
(
)
}
fn
type_of_function
(
&
self
_func_idx
:
u32
)
-
>
Option
<
&
crate
:
:
FuncType
>
{
todo
!
(
)
}
fn
check_heap_type
(
&
self
_t
:
&
mut
HeapType
_offset
:
usize
)
-
>
Result
<
(
)
>
{
Ok
(
(
)
)
}
fn
top_type
(
&
self
_heap_type
:
&
HeapType
)
-
>
HeapType
{
todo
!
(
)
}
fn
element_type_at
(
&
self
_at
:
u32
)
-
>
Option
<
crate
:
:
RefType
>
{
todo
!
(
)
}
fn
is_subtype
(
&
self
_t1
:
ValType
_t2
:
ValType
)
-
>
bool
{
todo
!
(
)
}
fn
element_count
(
&
self
)
-
>
u32
{
todo
!
(
)
}
fn
data_count
(
&
self
)
-
>
Option
<
u32
>
{
todo
!
(
)
}
fn
is_function_referenced
(
&
self
_idx
:
u32
)
-
>
bool
{
todo
!
(
)
}
}
#
[
test
]
fn
operand_stack_height
(
)
{
let
mut
v
=
FuncToValidate
:
:
new
(
0
0
EmptyResources
:
:
default
(
)
&
Default
:
:
default
(
)
)
.
into_validator
(
Default
:
:
default
(
)
)
;
assert_eq
!
(
v
.
operand_stack_height
(
)
0
)
;
assert
!
(
v
.
op
(
0
&
Operator
:
:
I32Const
{
value
:
0
}
)
.
is_ok
(
)
)
;
assert_eq
!
(
v
.
operand_stack_height
(
)
1
)
;
assert
!
(
v
.
op
(
1
&
Operator
:
:
Block
{
blockty
:
crate
:
:
BlockType
:
:
Empty
}
)
.
is_ok
(
)
)
;
assert_eq
!
(
v
.
operand_stack_height
(
)
1
)
;
assert
!
(
v
.
op
(
2
&
Operator
:
:
I32Const
{
value
:
99
}
)
.
is_ok
(
)
)
;
assert_eq
!
(
v
.
operand_stack_height
(
)
2
)
;
}
}
