use
super
:
:
operators
:
:
{
Frame
OperatorValidator
OperatorValidatorAllocations
}
;
use
crate
:
:
{
BinaryReader
Result
ValType
VisitOperator
}
;
use
crate
:
:
{
FunctionBody
ModuleArity
Operator
WasmFeatures
WasmModuleResources
}
;
#
[
derive
(
Debug
)
]
pub
struct
FuncToValidate
<
T
>
{
pub
resources
:
T
pub
index
:
u32
pub
ty
:
u32
pub
features
:
WasmFeatures
}
impl
<
T
:
WasmModuleResources
>
FuncToValidate
<
T
>
{
pub
fn
into_validator
(
self
allocs
:
FuncValidatorAllocations
)
-
>
FuncValidator
<
T
>
{
let
FuncToValidate
{
resources
index
ty
features
}
=
self
;
let
validator
=
OperatorValidator
:
:
new_func
(
ty
0
&
features
&
resources
allocs
.
0
)
.
unwrap
(
)
;
FuncValidator
{
validator
resources
index
}
}
}
pub
struct
FuncValidator
<
T
>
{
validator
:
OperatorValidator
resources
:
T
index
:
u32
}
#
[
derive
(
Default
)
]
pub
struct
FuncValidatorAllocations
(
OperatorValidatorAllocations
)
;
impl
<
T
:
WasmModuleResources
>
FuncValidator
<
T
>
{
pub
fn
validate
(
&
mut
self
body
:
&
FunctionBody
<
'
_
>
)
-
>
Result
<
(
)
>
{
let
mut
reader
=
body
.
get_binary_reader
(
)
;
self
.
read_locals
(
&
mut
reader
)
?
;
#
[
cfg
(
feature
=
"
features
"
)
]
{
reader
.
set_features
(
self
.
validator
.
features
)
;
}
while
!
reader
.
eof
(
)
{
#
[
cfg
(
debug_assertions
)
]
let
(
pop_push_snapshot
arity
)
=
(
self
.
validator
.
pop_push_count
reader
.
clone
(
)
.
read_operator
(
)
?
.
operator_arity
(
&
self
.
visitor
(
reader
.
original_position
(
)
)
)
)
;
reader
.
visit_operator
(
&
mut
self
.
visitor
(
reader
.
original_position
(
)
)
)
?
?
;
#
[
cfg
(
debug_assertions
)
]
{
let
(
params
results
)
=
arity
.
ok_or
(
format_err
!
(
reader
.
original_position
(
)
"
could
not
calculate
operator
arity
"
)
)
?
;
let
pop_count
=
self
.
validator
.
pop_push_count
.
0
-
pop_push_snapshot
.
0
;
let
push_count
=
self
.
validator
.
pop_push_count
.
1
-
pop_push_snapshot
.
1
;
if
pop_count
!
=
params
|
|
push_count
!
=
results
{
panic
!
(
"
arity
mismatch
in
validation
.
Expecting
{
}
operands
popped
{
}
pushed
but
got
{
}
popped
{
}
pushed
.
"
params
results
pop_count
push_count
)
;
}
}
}
self
.
finish
(
reader
.
original_position
(
)
)
}
pub
fn
read_locals
(
&
mut
self
reader
:
&
mut
BinaryReader
<
'
_
>
)
-
>
Result
<
(
)
>
{
for
_
in
0
.
.
reader
.
read_var_u32
(
)
?
{
let
offset
=
reader
.
original_position
(
)
;
let
cnt
=
reader
.
read
(
)
?
;
let
ty
=
reader
.
read
(
)
?
;
self
.
define_locals
(
offset
cnt
ty
)
?
;
}
Ok
(
(
)
)
}
pub
fn
define_locals
(
&
mut
self
offset
:
usize
count
:
u32
ty
:
ValType
)
-
>
Result
<
(
)
>
{
self
.
validator
.
define_locals
(
offset
count
ty
&
self
.
resources
)
}
pub
fn
op
(
&
mut
self
offset
:
usize
operator
:
&
Operator
<
'
_
>
)
-
>
Result
<
(
)
>
{
self
.
visitor
(
offset
)
.
visit_operator
(
operator
)
}
pub
fn
visitor
<
'
this
'
a
:
'
this
>
(
&
'
this
mut
self
offset
:
usize
)
-
>
impl
VisitOperator
<
'
a
Output
=
Result
<
(
)
>
>
+
ModuleArity
+
'
this
{
self
.
validator
.
with_resources
(
&
self
.
resources
offset
)
}
#
[
cfg
(
feature
=
"
simd
"
)
]
pub
fn
simd_visitor
<
'
this
'
a
:
'
this
>
(
&
'
this
mut
self
offset
:
usize
)
-
>
impl
crate
:
:
VisitSimdOperator
<
'
a
Output
=
Result
<
(
)
>
>
+
ModuleArity
+
'
this
{
self
.
validator
.
with_resources_simd
(
&
self
.
resources
offset
)
}
pub
fn
finish
(
&
mut
self
offset
:
usize
)
-
>
Result
<
(
)
>
{
self
.
validator
.
finish
(
offset
)
}
pub
fn
features
(
&
self
)
-
>
&
WasmFeatures
{
&
self
.
validator
.
features
}
pub
fn
resources
(
&
self
)
-
>
&
T
{
&
self
.
resources
}
pub
fn
index
(
&
self
)
-
>
u32
{
self
.
index
}
pub
fn
len_locals
(
&
self
)
-
>
u32
{
self
.
validator
.
locals
.
len_locals
(
)
}
pub
fn
get_local_type
(
&
self
index
:
u32
)
-
>
Option
<
ValType
>
{
self
.
validator
.
locals
.
get
(
index
)
}
pub
fn
operand_stack_height
(
&
self
)
-
>
u32
{
self
.
validator
.
operand_stack_height
(
)
as
u32
}
pub
fn
get_operand_type
(
&
self
depth
:
usize
)
-
>
Option
<
Option
<
ValType
>
>
{
self
.
validator
.
peek_operand_at
(
depth
)
}
pub
fn
control_stack_height
(
&
self
)
-
>
u32
{
self
.
validator
.
control_stack_height
(
)
as
u32
}
pub
fn
get_control_frame
(
&
self
depth
:
usize
)
-
>
Option
<
&
Frame
>
{
self
.
validator
.
get_frame
(
depth
)
}
pub
fn
into_allocations
(
self
)
-
>
FuncValidatorAllocations
{
FuncValidatorAllocations
(
self
.
validator
.
into_allocations
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
types
:
:
CoreTypeId
;
use
crate
:
:
{
HeapType
RefType
}
;
struct
EmptyResources
(
crate
:
:
SubType
)
;
impl
Default
for
EmptyResources
{
fn
default
(
)
-
>
Self
{
EmptyResources
(
crate
:
:
SubType
{
supertype_idx
:
None
is_final
:
true
composite_type
:
crate
:
:
CompositeType
{
inner
:
crate
:
:
CompositeInnerType
:
:
Func
(
crate
:
:
FuncType
:
:
new
(
[
]
[
]
)
)
shared
:
false
}
}
)
}
}
impl
WasmModuleResources
for
EmptyResources
{
fn
table_at
(
&
self
_at
:
u32
)
-
>
Option
<
crate
:
:
TableType
>
{
todo
!
(
)
}
fn
memory_at
(
&
self
_at
:
u32
)
-
>
Option
<
crate
:
:
MemoryType
>
{
todo
!
(
)
}
fn
tag_at
(
&
self
_at
:
u32
)
-
>
Option
<
&
crate
:
:
FuncType
>
{
todo
!
(
)
}
fn
global_at
(
&
self
_at
:
u32
)
-
>
Option
<
crate
:
:
GlobalType
>
{
todo
!
(
)
}
fn
sub_type_at
(
&
self
_type_idx
:
u32
)
-
>
Option
<
&
crate
:
:
SubType
>
{
Some
(
&
self
.
0
)
}
fn
sub_type_at_id
(
&
self
_id
:
CoreTypeId
)
-
>
&
crate
:
:
SubType
{
todo
!
(
)
}
fn
type_id_of_function
(
&
self
_at
:
u32
)
-
>
Option
<
CoreTypeId
>
{
todo
!
(
)
}
fn
type_index_of_function
(
&
self
_at
:
u32
)
-
>
Option
<
u32
>
{
todo
!
(
)
}
fn
check_heap_type
(
&
self
_t
:
&
mut
HeapType
_offset
:
usize
)
-
>
Result
<
(
)
>
{
Ok
(
(
)
)
}
fn
top_type
(
&
self
_heap_type
:
&
HeapType
)
-
>
HeapType
{
todo
!
(
)
}
fn
element_type_at
(
&
self
_at
:
u32
)
-
>
Option
<
crate
:
:
RefType
>
{
todo
!
(
)
}
fn
is_subtype
(
&
self
_t1
:
ValType
_t2
:
ValType
)
-
>
bool
{
todo
!
(
)
}
fn
is_shared
(
&
self
_ty
:
RefType
)
-
>
bool
{
todo
!
(
)
}
fn
element_count
(
&
self
)
-
>
u32
{
todo
!
(
)
}
fn
data_count
(
&
self
)
-
>
Option
<
u32
>
{
todo
!
(
)
}
fn
is_function_referenced
(
&
self
_idx
:
u32
)
-
>
bool
{
todo
!
(
)
}
}
#
[
test
]
fn
operand_stack_height
(
)
{
let
mut
v
=
FuncToValidate
{
index
:
0
ty
:
0
resources
:
EmptyResources
:
:
default
(
)
features
:
Default
:
:
default
(
)
}
.
into_validator
(
Default
:
:
default
(
)
)
;
assert_eq
!
(
v
.
operand_stack_height
(
)
0
)
;
assert
!
(
v
.
op
(
0
&
Operator
:
:
I32Const
{
value
:
0
}
)
.
is_ok
(
)
)
;
assert_eq
!
(
v
.
operand_stack_height
(
)
1
)
;
assert
!
(
v
.
op
(
1
&
Operator
:
:
Block
{
blockty
:
crate
:
:
BlockType
:
:
Empty
}
)
.
is_ok
(
)
)
;
assert_eq
!
(
v
.
operand_stack_height
(
)
1
)
;
assert
!
(
v
.
op
(
2
&
Operator
:
:
I32Const
{
value
:
99
}
)
.
is_ok
(
)
)
;
assert_eq
!
(
v
.
operand_stack_height
(
)
2
)
;
}
}
