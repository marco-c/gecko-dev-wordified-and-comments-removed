use
std
:
:
cmp
:
:
min
;
use
std
:
:
mem
:
:
uninitialized
;
use
std
:
:
ptr
:
:
{
copy_nonoverlapping
read_unaligned
}
;
use
rand
;
#
[
inline
]
pub
fn
generate_mask
(
)
-
>
[
u8
;
4
]
{
rand
:
:
random
(
)
}
#
[
inline
]
pub
fn
apply_mask
(
buf
:
&
mut
[
u8
]
mask
:
[
u8
;
4
]
)
{
apply_mask_fast32
(
buf
mask
)
}
#
[
inline
]
#
[
allow
(
dead_code
)
]
fn
apply_mask_fallback
(
buf
:
&
mut
[
u8
]
mask
:
[
u8
;
4
]
)
{
for
(
i
byte
)
in
buf
.
iter_mut
(
)
.
enumerate
(
)
{
*
byte
^
=
mask
[
i
&
3
]
;
}
}
#
[
inline
]
#
[
allow
(
dead_code
)
]
fn
apply_mask_fast32
(
buf
:
&
mut
[
u8
]
mask
:
[
u8
;
4
]
)
{
let
mask_u32
:
u32
=
unsafe
{
read_unaligned
(
mask
.
as_ptr
(
)
as
*
const
u32
)
}
;
let
mut
ptr
=
buf
.
as_mut_ptr
(
)
;
let
mut
len
=
buf
.
len
(
)
;
let
head
=
min
(
len
(
4
-
(
ptr
as
usize
&
3
)
)
&
3
)
;
let
mask_u32
=
if
head
>
0
{
unsafe
{
xor_mem
(
ptr
mask_u32
head
)
;
ptr
=
ptr
.
offset
(
head
as
isize
)
;
}
len
-
=
head
;
if
cfg
!
(
target_endian
=
"
big
"
)
{
mask_u32
.
rotate_left
(
8
*
head
as
u32
)
}
else
{
mask_u32
.
rotate_right
(
8
*
head
as
u32
)
}
}
else
{
mask_u32
}
;
if
len
>
0
{
debug_assert_eq
!
(
ptr
as
usize
%
4
0
)
;
}
while
len
>
4
{
unsafe
{
*
(
ptr
as
*
mut
u32
)
^
=
mask_u32
;
ptr
=
ptr
.
offset
(
4
)
;
len
-
=
4
;
}
}
if
len
>
0
{
unsafe
{
xor_mem
(
ptr
mask_u32
len
)
;
}
}
}
#
[
inline
]
unsafe
fn
xor_mem
(
ptr
:
*
mut
u8
mask
:
u32
len
:
usize
)
{
let
mut
b
:
u32
=
uninitialized
(
)
;
#
[
allow
(
trivial_casts
)
]
copy_nonoverlapping
(
ptr
&
mut
b
as
*
mut
_
as
*
mut
u8
len
)
;
b
^
=
mask
;
#
[
allow
(
trivial_casts
)
]
copy_nonoverlapping
(
&
b
as
*
const
_
as
*
const
u8
ptr
len
)
;
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
apply_mask_fallback
apply_mask_fast32
}
;
#
[
test
]
fn
test_apply_mask
(
)
{
let
mask
=
[
0x6d
0xb6
0xb2
0x80
]
;
let
unmasked
=
vec
!
[
0xf3
0x00
0x01
0x02
0x03
0x80
0x81
0x82
0xff
0xfe
0x00
0x17
0x74
0xf9
0x12
0x03
]
;
{
let
mut
masked
=
unmasked
.
clone
(
)
;
apply_mask_fallback
(
&
mut
masked
mask
)
;
let
mut
masked_fast
=
unmasked
.
clone
(
)
;
apply_mask_fast32
(
&
mut
masked_fast
mask
)
;
assert_eq
!
(
masked
masked_fast
)
;
}
{
let
mut
masked
=
unmasked
.
clone
(
)
;
apply_mask_fallback
(
&
mut
masked
[
1
.
.
]
mask
)
;
let
mut
masked_fast
=
unmasked
.
clone
(
)
;
apply_mask_fast32
(
&
mut
masked_fast
[
1
.
.
]
mask
)
;
assert_eq
!
(
masked
masked_fast
)
;
}
}
}
