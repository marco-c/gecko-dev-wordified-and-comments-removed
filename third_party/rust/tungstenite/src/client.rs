use
std
:
:
net
:
:
{
TcpStream
SocketAddr
ToSocketAddrs
}
;
use
std
:
:
result
:
:
Result
as
StdResult
;
use
std
:
:
io
:
:
{
Read
Write
}
;
use
url
:
:
Url
;
use
handshake
:
:
client
:
:
Response
;
use
protocol
:
:
WebSocketConfig
;
#
[
cfg
(
feature
=
"
tls
"
)
]
mod
encryption
{
use
std
:
:
net
:
:
TcpStream
;
use
native_tls
:
:
{
TlsConnector
HandshakeError
as
TlsHandshakeError
}
;
pub
use
native_tls
:
:
TlsStream
;
pub
use
stream
:
:
Stream
as
StreamSwitcher
;
pub
type
AutoStream
=
StreamSwitcher
<
TcpStream
TlsStream
<
TcpStream
>
>
;
use
stream
:
:
Mode
;
use
error
:
:
Result
;
pub
fn
wrap_stream
(
stream
:
TcpStream
domain
:
&
str
mode
:
Mode
)
-
>
Result
<
AutoStream
>
{
match
mode
{
Mode
:
:
Plain
=
>
Ok
(
StreamSwitcher
:
:
Plain
(
stream
)
)
Mode
:
:
Tls
=
>
{
let
connector
=
TlsConnector
:
:
builder
(
)
.
build
(
)
?
;
connector
.
connect
(
domain
stream
)
.
map_err
(
|
e
|
match
e
{
TlsHandshakeError
:
:
Failure
(
f
)
=
>
f
.
into
(
)
TlsHandshakeError
:
:
WouldBlock
(
_
)
=
>
panic
!
(
"
Bug
:
TLS
handshake
not
blocked
"
)
}
)
.
map
(
StreamSwitcher
:
:
Tls
)
}
}
}
}
#
[
cfg
(
not
(
feature
=
"
tls
"
)
)
]
mod
encryption
{
use
std
:
:
net
:
:
TcpStream
;
use
stream
:
:
Mode
;
use
error
:
:
{
Error
Result
}
;
pub
type
AutoStream
=
TcpStream
;
pub
fn
wrap_stream
(
stream
:
TcpStream
_domain
:
&
str
mode
:
Mode
)
-
>
Result
<
AutoStream
>
{
match
mode
{
Mode
:
:
Plain
=
>
Ok
(
stream
)
Mode
:
:
Tls
=
>
Err
(
Error
:
:
Url
(
"
TLS
support
not
compiled
in
.
"
.
into
(
)
)
)
}
}
}
pub
use
self
:
:
encryption
:
:
AutoStream
;
use
self
:
:
encryption
:
:
wrap_stream
;
use
protocol
:
:
WebSocket
;
use
handshake
:
:
HandshakeError
;
use
handshake
:
:
client
:
:
{
ClientHandshake
Request
}
;
use
stream
:
:
{
NoDelay
Mode
}
;
use
error
:
:
{
Error
Result
}
;
pub
fn
connect_with_config
<
'
t
Req
:
Into
<
Request
<
'
t
>
>
>
(
request
:
Req
config
:
Option
<
WebSocketConfig
>
)
-
>
Result
<
(
WebSocket
<
AutoStream
>
Response
)
>
{
let
request
:
Request
=
request
.
into
(
)
;
let
mode
=
url_mode
(
&
request
.
url
)
?
;
let
addrs
=
request
.
url
.
to_socket_addrs
(
)
?
;
let
mut
stream
=
connect_to_some
(
addrs
&
request
.
url
mode
)
?
;
NoDelay
:
:
set_nodelay
(
&
mut
stream
true
)
?
;
client_with_config
(
request
stream
config
)
.
map_err
(
|
e
|
match
e
{
HandshakeError
:
:
Failure
(
f
)
=
>
f
HandshakeError
:
:
Interrupted
(
_
)
=
>
panic
!
(
"
Bug
:
blocking
handshake
not
blocked
"
)
}
)
}
pub
fn
connect
<
'
t
Req
:
Into
<
Request
<
'
t
>
>
>
(
request
:
Req
)
-
>
Result
<
(
WebSocket
<
AutoStream
>
Response
)
>
{
connect_with_config
(
request
None
)
}
fn
connect_to_some
<
A
>
(
addrs
:
A
url
:
&
Url
mode
:
Mode
)
-
>
Result
<
AutoStream
>
where
A
:
Iterator
<
Item
=
SocketAddr
>
{
let
domain
=
url
.
host_str
(
)
.
ok_or_else
(
|
|
Error
:
:
Url
(
"
No
host
name
in
the
URL
"
.
into
(
)
)
)
?
;
for
addr
in
addrs
{
debug
!
(
"
Trying
to
contact
{
}
at
{
}
.
.
.
"
url
addr
)
;
if
let
Ok
(
raw_stream
)
=
TcpStream
:
:
connect
(
addr
)
{
if
let
Ok
(
stream
)
=
wrap_stream
(
raw_stream
domain
mode
)
{
return
Ok
(
stream
)
}
}
}
Err
(
Error
:
:
Url
(
format
!
(
"
Unable
to
connect
to
{
}
"
url
)
.
into
(
)
)
)
}
pub
fn
url_mode
(
url
:
&
Url
)
-
>
Result
<
Mode
>
{
match
url
.
scheme
(
)
{
"
ws
"
=
>
Ok
(
Mode
:
:
Plain
)
"
wss
"
=
>
Ok
(
Mode
:
:
Tls
)
_
=
>
Err
(
Error
:
:
Url
(
"
URL
scheme
not
supported
"
.
into
(
)
)
)
}
}
pub
fn
client_with_config
<
'
t
Stream
Req
>
(
request
:
Req
stream
:
Stream
config
:
Option
<
WebSocketConfig
>
)
-
>
StdResult
<
(
WebSocket
<
Stream
>
Response
)
HandshakeError
<
ClientHandshake
<
Stream
>
>
>
where
Stream
:
Read
+
Write
Req
:
Into
<
Request
<
'
t
>
>
{
ClientHandshake
:
:
start
(
stream
request
.
into
(
)
config
)
.
handshake
(
)
}
pub
fn
client
<
'
t
Stream
Req
>
(
request
:
Req
stream
:
Stream
)
-
>
StdResult
<
(
WebSocket
<
Stream
>
Response
)
HandshakeError
<
ClientHandshake
<
Stream
>
>
>
where
Stream
:
Read
+
Write
Req
:
Into
<
Request
<
'
t
>
>
{
client_with_config
(
request
stream
None
)
}
