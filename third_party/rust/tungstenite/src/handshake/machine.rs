use
std
:
:
io
:
:
{
Cursor
Read
Write
}
;
use
bytes
:
:
Buf
;
use
input_buffer
:
:
{
InputBuffer
MIN_READ
}
;
use
error
:
:
{
Error
Result
}
;
use
util
:
:
NonBlockingResult
;
#
[
derive
(
Debug
)
]
pub
struct
HandshakeMachine
<
Stream
>
{
stream
:
Stream
state
:
HandshakeState
}
impl
<
Stream
>
HandshakeMachine
<
Stream
>
{
pub
fn
start_read
(
stream
:
Stream
)
-
>
Self
{
HandshakeMachine
{
stream
state
:
HandshakeState
:
:
Reading
(
InputBuffer
:
:
with_capacity
(
MIN_READ
)
)
}
}
pub
fn
start_write
<
D
:
Into
<
Vec
<
u8
>
>
>
(
stream
:
Stream
data
:
D
)
-
>
Self
{
HandshakeMachine
{
stream
state
:
HandshakeState
:
:
Writing
(
Cursor
:
:
new
(
data
.
into
(
)
)
)
}
}
pub
fn
get_ref
(
&
self
)
-
>
&
Stream
{
&
self
.
stream
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
Stream
{
&
mut
self
.
stream
}
}
impl
<
Stream
:
Read
+
Write
>
HandshakeMachine
<
Stream
>
{
pub
fn
single_round
<
Obj
:
TryParse
>
(
mut
self
)
-
>
Result
<
RoundResult
<
Obj
Stream
>
>
{
trace
!
(
"
Doing
handshake
round
.
"
)
;
match
self
.
state
{
HandshakeState
:
:
Reading
(
mut
buf
)
=
>
{
let
read
=
buf
.
prepare_reserve
(
MIN_READ
)
.
with_limit
(
usize
:
:
max_value
(
)
)
.
map_err
(
|
_
|
Error
:
:
Capacity
(
"
Header
too
long
"
.
into
(
)
)
)
?
.
read_from
(
&
mut
self
.
stream
)
.
no_block
(
)
?
;
match
read
{
Some
(
0
)
=
>
{
Err
(
Error
:
:
Protocol
(
"
Handshake
not
finished
"
.
into
(
)
)
)
}
Some
(
_
)
=
>
{
Ok
(
if
let
Some
(
(
size
obj
)
)
=
Obj
:
:
try_parse
(
Buf
:
:
bytes
(
&
buf
)
)
?
{
buf
.
advance
(
size
)
;
RoundResult
:
:
StageFinished
(
StageResult
:
:
DoneReading
{
result
:
obj
stream
:
self
.
stream
tail
:
buf
.
into_vec
(
)
}
)
}
else
{
RoundResult
:
:
Incomplete
(
HandshakeMachine
{
state
:
HandshakeState
:
:
Reading
(
buf
)
.
.
self
}
)
}
)
}
None
=
>
{
Ok
(
RoundResult
:
:
WouldBlock
(
HandshakeMachine
{
state
:
HandshakeState
:
:
Reading
(
buf
)
.
.
self
}
)
)
}
}
}
HandshakeState
:
:
Writing
(
mut
buf
)
=
>
{
assert
!
(
buf
.
has_remaining
(
)
)
;
if
let
Some
(
size
)
=
self
.
stream
.
write
(
Buf
:
:
bytes
(
&
buf
)
)
.
no_block
(
)
?
{
assert
!
(
size
>
0
)
;
buf
.
advance
(
size
)
;
Ok
(
if
buf
.
has_remaining
(
)
{
RoundResult
:
:
Incomplete
(
HandshakeMachine
{
state
:
HandshakeState
:
:
Writing
(
buf
)
.
.
self
}
)
}
else
{
RoundResult
:
:
StageFinished
(
StageResult
:
:
DoneWriting
(
self
.
stream
)
)
}
)
}
else
{
Ok
(
RoundResult
:
:
WouldBlock
(
HandshakeMachine
{
state
:
HandshakeState
:
:
Writing
(
buf
)
.
.
self
}
)
)
}
}
}
}
}
#
[
derive
(
Debug
)
]
pub
enum
RoundResult
<
Obj
Stream
>
{
WouldBlock
(
HandshakeMachine
<
Stream
>
)
Incomplete
(
HandshakeMachine
<
Stream
>
)
StageFinished
(
StageResult
<
Obj
Stream
>
)
}
#
[
derive
(
Debug
)
]
pub
enum
StageResult
<
Obj
Stream
>
{
DoneReading
{
result
:
Obj
stream
:
Stream
tail
:
Vec
<
u8
>
}
DoneWriting
(
Stream
)
}
pub
trait
TryParse
:
Sized
{
fn
try_parse
(
data
:
&
[
u8
]
)
-
>
Result
<
Option
<
(
usize
Self
)
>
>
;
}
#
[
derive
(
Debug
)
]
enum
HandshakeState
{
Reading
(
InputBuffer
)
Writing
(
Cursor
<
Vec
<
u8
>
>
)
}
