use
super
:
:
size_hint
;
#
[
derive
(
Clone
)
]
#
[
must_use
=
"
iterator
adaptors
are
lazy
and
do
nothing
unless
consumed
"
]
pub
struct
Zip
<
T
>
{
t
:
T
}
pub
fn
multizip
<
T
U
>
(
t
:
U
)
-
>
Zip
<
T
>
where
Zip
<
T
>
:
From
<
U
>
Zip
<
T
>
:
Iterator
{
Zip
:
:
from
(
t
)
}
macro_rules
!
impl_zip_iter
{
(
(
B
:
ident
)
*
)
=
>
(
#
[
allow
(
non_snake_case
)
]
impl
<
(
B
:
IntoIterator
)
*
>
From
<
(
(
B
)
*
)
>
for
Zip
<
(
(
B
:
:
IntoIter
)
*
)
>
{
fn
from
(
t
:
(
(
B
)
*
)
)
-
>
Self
{
let
(
(
B
)
*
)
=
t
;
Zip
{
t
:
(
(
B
.
into_iter
(
)
)
*
)
}
}
}
#
[
allow
(
non_snake_case
)
]
#
[
allow
(
unused_assignments
)
]
impl
<
(
B
)
*
>
Iterator
for
Zip
<
(
(
B
)
*
)
>
where
(
B
:
Iterator
)
*
{
type
Item
=
(
(
B
:
:
Item
)
*
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
(
(
ref
mut
B
)
*
)
=
self
.
t
;
/
/
NOTE
:
Just
like
iter
:
:
Zip
we
check
the
iterators
/
/
for
None
in
order
.
We
may
finish
unevenly
(
some
/
/
iterators
gave
n
+
1
elements
some
only
n
)
.
(
let
B
=
match
B
.
next
(
)
{
None
=
>
return
None
Some
(
elt
)
=
>
elt
}
;
)
*
Some
(
(
(
B
)
*
)
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
sh
=
(
:
:
std
:
:
usize
:
:
MAX
None
)
;
let
(
(
ref
B
)
*
)
=
self
.
t
;
(
let
sh
=
size_hint
:
:
min
(
B
.
size_hint
(
)
sh
)
;
)
*
sh
}
}
#
[
allow
(
non_snake_case
)
]
impl
<
(
B
)
*
>
ExactSizeIterator
for
Zip
<
(
(
B
)
*
)
>
where
(
B
:
ExactSizeIterator
)
*
{
}
)
;
}
impl_zip_iter
!
(
A
)
;
impl_zip_iter
!
(
A
B
)
;
impl_zip_iter
!
(
A
B
C
)
;
impl_zip_iter
!
(
A
B
C
D
)
;
impl_zip_iter
!
(
A
B
C
D
E
)
;
impl_zip_iter
!
(
A
B
C
D
E
F
)
;
impl_zip_iter
!
(
A
B
C
D
E
F
G
)
;
impl_zip_iter
!
(
A
B
C
D
E
F
G
H
)
;
