#
!
[
allow
(
unsafe_code
)
]
use
crate
:
:
windows
:
:
errors
:
:
Error
;
use
crate
:
:
windows
:
:
ffi
:
:
{
capture_context
CloseHandle
GetCurrentProcess
GetCurrentThreadId
GetThreadContext
MiniDumpWriteDump
MinidumpType
OpenProcess
OpenThread
ResumeThread
SuspendThread
EXCEPTION_POINTERS
EXCEPTION_RECORD
FALSE
HANDLE
MINIDUMP_EXCEPTION_INFORMATION
MINIDUMP_USER_STREAM
MINIDUMP_USER_STREAM_INFORMATION
PROCESS_ALL_ACCESS
STATUS_NONCONTINUABLE_EXCEPTION
THREAD_GET_CONTEXT
THREAD_QUERY_INFORMATION
THREAD_SUSPEND_RESUME
}
;
use
minidump_common
:
:
format
:
:
{
BreakpadInfoValid
MINIDUMP_BREAKPAD_INFO
MINIDUMP_STREAM_TYPE
}
;
use
scroll
:
:
Pwrite
;
use
std
:
:
os
:
:
windows
:
:
io
:
:
AsRawHandle
;
pub
struct
MinidumpWriter
{
exc_info
:
Option
<
MINIDUMP_EXCEPTION_INFORMATION
>
crashing_process
:
HANDLE
pid
:
u32
tid
:
u32
#
[
allow
(
dead_code
)
]
exception_code
:
i32
is_external_process
:
bool
}
impl
MinidumpWriter
{
pub
fn
dump_local_context
(
exception_code
:
Option
<
i32
>
thread_id
:
Option
<
u32
>
minidump_type
:
Option
<
MinidumpType
>
destination
:
&
mut
std
:
:
fs
:
:
File
)
-
>
Result
<
(
)
Error
>
{
let
exception_code
=
exception_code
.
unwrap_or
(
STATUS_NONCONTINUABLE_EXCEPTION
)
;
unsafe
{
let
mut
exception_context
=
if
let
Some
(
tid
)
=
thread_id
{
let
mut
ec
=
std
:
:
mem
:
:
MaybeUninit
:
:
uninit
(
)
;
if
tid
=
=
GetCurrentThreadId
(
)
{
capture_context
(
ec
.
as_mut_ptr
(
)
)
;
}
else
{
let
thread_handle
=
OpenThread
(
THREAD_GET_CONTEXT
|
THREAD_QUERY_INFORMATION
|
THREAD_SUSPEND_RESUME
FALSE
tid
)
;
if
thread_handle
=
=
0
{
return
Err
(
Error
:
:
ThreadOpen
(
std
:
:
io
:
:
Error
:
:
last_os_error
(
)
)
)
;
}
struct
OwnedHandle
(
HANDLE
)
;
impl
Drop
for
OwnedHandle
{
fn
drop
(
&
mut
self
)
{
unsafe
{
CloseHandle
(
self
.
0
)
}
;
}
}
let
thread_handle
=
OwnedHandle
(
thread_handle
)
;
if
SuspendThread
(
thread_handle
.
0
)
=
=
u32
:
:
MAX
{
return
Err
(
Error
:
:
ThreadSuspend
(
std
:
:
io
:
:
Error
:
:
last_os_error
(
)
)
)
;
}
if
GetThreadContext
(
thread_handle
.
0
ec
.
as_mut_ptr
(
)
)
=
=
0
{
ResumeThread
(
thread_handle
.
0
)
;
return
Err
(
Error
:
:
ThreadContext
(
std
:
:
io
:
:
Error
:
:
last_os_error
(
)
)
)
;
}
ResumeThread
(
thread_handle
.
0
)
;
}
ec
.
assume_init
(
)
}
else
{
let
mut
ec
=
std
:
:
mem
:
:
MaybeUninit
:
:
uninit
(
)
;
capture_context
(
ec
.
as_mut_ptr
(
)
)
;
ec
.
assume_init
(
)
}
;
let
mut
exception_record
:
EXCEPTION_RECORD
=
std
:
:
mem
:
:
zeroed
(
)
;
let
exception_ptrs
=
EXCEPTION_POINTERS
{
ExceptionRecord
:
&
mut
exception_record
ContextRecord
:
&
mut
exception_context
}
;
exception_record
.
ExceptionCode
=
exception_code
;
let
cc
=
crash_context
:
:
CrashContext
{
exception_pointers
:
(
&
exception_ptrs
as
*
const
EXCEPTION_POINTERS
)
.
cast
(
)
process_id
:
std
:
:
process
:
:
id
(
)
thread_id
:
thread_id
.
unwrap_or_else
(
|
|
GetCurrentThreadId
(
)
)
exception_code
}
;
Self
:
:
dump_crash_context
(
cc
minidump_type
destination
)
}
}
pub
fn
dump_crash_context
(
crash_context
:
crash_context
:
:
CrashContext
minidump_type
:
Option
<
MinidumpType
>
destination
:
&
mut
std
:
:
fs
:
:
File
)
-
>
Result
<
(
)
Error
>
{
let
pid
=
crash_context
.
process_id
;
let
(
crashing_process
is_external_process
)
=
unsafe
{
if
pid
!
=
std
:
:
process
:
:
id
(
)
{
let
proc
=
OpenProcess
(
PROCESS_ALL_ACCESS
FALSE
pid
)
;
if
proc
=
=
0
{
return
Err
(
std
:
:
io
:
:
Error
:
:
last_os_error
(
)
.
into
(
)
)
;
}
(
proc
true
)
}
else
{
(
GetCurrentProcess
(
)
false
)
}
}
;
let
pid
=
crash_context
.
process_id
;
let
tid
=
crash_context
.
thread_id
;
let
exception_code
=
crash_context
.
exception_code
;
let
exc_info
=
(
!
crash_context
.
exception_pointers
.
is_null
(
)
)
.
then_some
(
MINIDUMP_EXCEPTION_INFORMATION
{
ThreadId
:
crash_context
.
thread_id
ExceptionPointers
:
crash_context
.
exception_pointers
as
*
mut
_
ClientPointers
:
i32
:
:
from
(
is_external_process
)
}
)
;
let
mdw
=
Self
{
exc_info
crashing_process
pid
tid
exception_code
is_external_process
}
;
mdw
.
dump
(
minidump_type
destination
)
}
fn
dump
(
mut
self
minidump_type
:
Option
<
MinidumpType
>
destination
:
&
mut
std
:
:
fs
:
:
File
)
-
>
Result
<
(
)
Error
>
{
let
exc_info
=
self
.
exc_info
.
take
(
)
;
let
mut
user_streams
=
Vec
:
:
with_capacity
(
1
)
;
let
mut
breakpad_info
=
self
.
fill_breakpad_stream
(
)
;
if
let
Some
(
bp_info
)
=
&
mut
breakpad_info
{
user_streams
.
push
(
MINIDUMP_USER_STREAM
{
Type
:
MINIDUMP_STREAM_TYPE
:
:
BreakpadInfoStream
as
u32
BufferSize
:
bp_info
.
len
(
)
as
u32
Buffer
:
bp_info
.
as_mut_ptr
(
)
.
cast
(
)
}
)
;
}
let
user_stream_infos
=
MINIDUMP_USER_STREAM_INFORMATION
{
UserStreamCount
:
user_streams
.
len
(
)
as
u32
UserStreamArray
:
user_streams
.
as_mut_ptr
(
)
}
;
let
ret
=
unsafe
{
MiniDumpWriteDump
(
self
.
crashing_process
self
.
pid
destination
.
as_raw_handle
(
)
as
HANDLE
minidump_type
.
unwrap_or
(
MinidumpType
:
:
Normal
)
exc_info
.
as_ref
(
)
.
map_or
(
std
:
:
ptr
:
:
null
(
)
|
ei
|
ei
as
*
const
_
)
&
user_stream_infos
std
:
:
ptr
:
:
null
(
)
)
}
;
if
ret
=
=
0
{
Err
(
std
:
:
io
:
:
Error
:
:
last_os_error
(
)
.
into
(
)
)
}
else
{
Ok
(
(
)
)
}
}
fn
fill_breakpad_stream
(
&
self
)
-
>
Option
<
[
u8
;
12
]
>
{
if
self
.
is_external_process
{
return
None
;
}
let
mut
breakpad_info
=
[
0u8
;
12
]
;
let
bp_info
=
MINIDUMP_BREAKPAD_INFO
{
validity
:
BreakpadInfoValid
:
:
DumpThreadId
.
bits
(
)
|
BreakpadInfoValid
:
:
RequestingThreadId
.
bits
(
)
dump_thread_id
:
self
.
tid
requesting_thread_id
:
unsafe
{
GetCurrentThreadId
(
)
}
}
;
let
mut
offset
=
0
;
breakpad_info
.
gwrite
(
bp_info
.
validity
&
mut
offset
)
.
ok
(
)
?
;
breakpad_info
.
gwrite
(
bp_info
.
dump_thread_id
&
mut
offset
)
.
ok
(
)
?
;
breakpad_info
.
gwrite
(
bp_info
.
requesting_thread_id
&
mut
offset
)
.
ok
(
)
?
;
Some
(
breakpad_info
)
}
}
impl
Drop
for
MinidumpWriter
{
fn
drop
(
&
mut
self
)
{
unsafe
{
CloseHandle
(
self
.
crashing_process
)
}
;
}
}
