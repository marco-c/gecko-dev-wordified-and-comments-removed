use
super
:
:
{
CommonThreadInfo
Pid
}
;
use
crate
:
:
{
errors
:
:
ThreadInfoError
minidump_cpu
:
:
RawContextCPU
}
;
use
nix
:
:
sys
:
:
ptrace
;
type
Result
<
T
>
=
std
:
:
result
:
:
Result
<
T
ThreadInfoError
>
;
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Eq
Hash
PartialEq
Copy
Clone
Default
)
]
pub
struct
user_fpregs
{
fpregs
:
[
u32
;
8
*
3
]
fpsr
:
u32
fpcr
:
u32
ftype
:
[
u8
;
8
]
init_flag
:
u32
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Eq
Hash
PartialEq
Copy
Clone
Default
)
]
pub
struct
user_regs
{
uregs
:
[
u32
;
18
]
}
#
[
derive
(
Debug
)
]
pub
struct
ThreadInfoArm
{
pub
stack_pointer
:
usize
pub
tgid
:
Pid
pub
ppid
:
Pid
pub
regs
:
user_regs
pub
fpregs
:
user_fpregs
}
impl
CommonThreadInfo
for
ThreadInfoArm
{
}
impl
ThreadInfoArm
{
fn
getfpregs
(
pid
:
Pid
)
-
>
Result
<
user_fpregs
>
{
Self
:
:
ptrace_get_data
:
:
<
user_fpregs
>
(
ptrace
:
:
Request
:
:
PTRACE_GETFPREGS
None
nix
:
:
unistd
:
:
Pid
:
:
from_raw
(
pid
)
)
}
fn
getregs
(
pid
:
Pid
)
-
>
Result
<
user_regs
>
{
Self
:
:
ptrace_get_data
:
:
<
user_regs
>
(
ptrace
:
:
Request
:
:
PTRACE_GETFPREGS
None
nix
:
:
unistd
:
:
Pid
:
:
from_raw
(
pid
)
)
}
pub
fn
get_instruction_pointer
(
&
self
)
-
>
usize
{
self
.
regs
.
uregs
[
15
]
as
usize
}
pub
fn
fill_cpu_context
(
&
self
out
:
&
mut
RawContextCPU
)
{
out
.
context_flags
=
crate
:
:
minidump_format
:
:
format
:
:
ContextFlagsArm
:
:
CONTEXT_ARM_FULL
.
bits
(
)
;
out
.
iregs
.
copy_from_slice
(
&
self
.
regs
.
uregs
[
.
.
16
]
)
;
out
.
cpsr
=
0
;
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
{
out
.
float_save
.
fpscr
=
self
.
fpregs
.
fpsr
as
u64
|
(
(
self
.
fpregs
.
fpcr
as
u64
)
<
<
32
)
;
}
}
pub
fn
create_impl
(
_pid
:
Pid
tid
:
Pid
)
-
>
Result
<
Self
>
{
let
(
ppid
tgid
)
=
Self
:
:
get_ppid_and_tgid
(
tid
)
?
;
let
regs
=
Self
:
:
getregs
(
tid
)
?
;
let
fpregs
=
Self
:
:
getfpregs
(
tid
)
?
;
let
stack_pointer
=
regs
.
uregs
[
13
]
as
usize
;
Ok
(
ThreadInfoArm
{
stack_pointer
tgid
ppid
regs
fpregs
}
)
}
}
