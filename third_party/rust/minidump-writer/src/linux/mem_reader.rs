use
crate
:
:
{
errors
:
:
CopyFromProcessError
ptrace_dumper
:
:
PtraceDumper
Pid
}
;
enum
Style
{
VirtualMem
File
(
std
:
:
fs
:
:
File
)
Ptrace
Unavailable
{
vmem
:
nix
:
:
Error
file
:
nix
:
:
Error
ptrace
:
nix
:
:
Error
}
}
pub
struct
MemReader
{
pid
:
nix
:
:
unistd
:
:
Pid
style
:
Option
<
Style
>
}
impl
std
:
:
fmt
:
:
Debug
for
MemReader
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
let
s
=
match
&
self
.
style
{
Some
(
Style
:
:
VirtualMem
)
=
>
"
process_vm_readv
"
Some
(
Style
:
:
File
(
_
)
)
=
>
"
/
proc
/
<
pid
>
/
mem
"
Some
(
Style
:
:
Ptrace
)
=
>
"
PTRACE_PEEKDATA
"
Some
(
Style
:
:
Unavailable
{
vmem
file
ptrace
}
)
=
>
{
return
write
!
(
f
"
process_vm_readv
:
{
vmem
}
/
proc
/
<
pid
>
/
mem
:
{
file
}
PTRACE_PEEKDATA
:
{
ptrace
}
"
)
;
}
None
=
>
"
unknown
"
}
;
f
.
write_str
(
s
)
}
}
impl
MemReader
{
#
[
inline
]
pub
fn
new
(
pid
:
i32
)
-
>
Self
{
Self
{
pid
:
nix
:
:
unistd
:
:
Pid
:
:
from_raw
(
pid
)
style
:
None
}
}
#
[
inline
]
#
[
doc
(
hidden
)
]
pub
fn
for_virtual_mem
(
pid
:
i32
)
-
>
Self
{
Self
{
pid
:
nix
:
:
unistd
:
:
Pid
:
:
from_raw
(
pid
)
style
:
Some
(
Style
:
:
VirtualMem
)
}
}
#
[
inline
]
#
[
doc
(
hidden
)
]
pub
fn
for_file
(
pid
:
i32
)
-
>
std
:
:
io
:
:
Result
<
Self
>
{
let
file
=
std
:
:
fs
:
:
File
:
:
open
(
format
!
(
"
/
proc
/
{
pid
}
/
mem
"
)
)
?
;
Ok
(
Self
{
pid
:
nix
:
:
unistd
:
:
Pid
:
:
from_raw
(
pid
)
style
:
Some
(
Style
:
:
File
(
file
)
)
}
)
}
#
[
inline
]
#
[
doc
(
hidden
)
]
pub
fn
for_ptrace
(
pid
:
i32
)
-
>
Self
{
Self
{
pid
:
nix
:
:
unistd
:
:
Pid
:
:
from_raw
(
pid
)
style
:
Some
(
Style
:
:
Ptrace
)
}
}
#
[
inline
]
pub
fn
read_to_vec
(
&
mut
self
src
:
usize
length
:
std
:
:
num
:
:
NonZeroUsize
)
-
>
Result
<
Vec
<
u8
>
CopyFromProcessError
>
{
let
length
=
length
.
into
(
)
;
let
layout
=
std
:
:
alloc
:
:
Layout
:
:
array
:
:
<
u8
>
(
length
)
.
map_err
(
|
_err
|
CopyFromProcessError
{
child
:
self
.
pid
.
as_raw
(
)
src
offset
:
0
length
source
:
nix
:
:
errno
:
:
Errno
:
:
EINVAL
}
)
?
;
let
output
=
unsafe
{
let
ptr
=
std
:
:
alloc
:
:
alloc
(
layout
)
;
if
ptr
.
is_null
(
)
{
return
Err
(
CopyFromProcessError
{
child
:
self
.
pid
.
as_raw
(
)
src
offset
:
0
length
source
:
nix
:
:
errno
:
:
Errno
:
:
ENOMEM
}
)
;
}
std
:
:
slice
:
:
from_raw_parts_mut
(
ptr
length
)
}
;
match
self
.
read
(
src
output
)
{
Ok
(
read
)
=
>
{
unsafe
{
Ok
(
Vec
:
:
from_raw_parts
(
output
.
as_mut_ptr
(
)
read
length
)
)
}
}
Err
(
err
)
=
>
{
unsafe
{
std
:
:
alloc
:
:
dealloc
(
output
.
as_mut_ptr
(
)
layout
)
;
}
Err
(
err
)
}
}
}
pub
fn
read
(
&
mut
self
src
:
usize
dst
:
&
mut
[
u8
]
)
-
>
Result
<
usize
CopyFromProcessError
>
{
if
let
Some
(
rs
)
=
&
mut
self
.
style
{
let
res
=
match
rs
{
Style
:
:
VirtualMem
=
>
Self
:
:
vmem
(
self
.
pid
src
dst
)
.
map_err
(
|
s
|
(
s
0
)
)
Style
:
:
File
(
file
)
=
>
Self
:
:
file
(
file
src
dst
)
.
map_err
(
|
s
|
(
s
0
)
)
Style
:
:
Ptrace
=
>
Self
:
:
ptrace
(
self
.
pid
src
dst
)
Style
:
:
Unavailable
{
ptrace
.
.
}
=
>
Err
(
(
*
ptrace
0
)
)
}
;
return
res
.
map_err
(
|
(
source
offset
)
|
CopyFromProcessError
{
child
:
self
.
pid
.
as_raw
(
)
src
offset
length
:
dst
.
len
(
)
source
}
)
;
}
let
vmem
=
match
Self
:
:
vmem
(
self
.
pid
src
dst
)
{
Ok
(
len
)
=
>
{
self
.
style
=
Some
(
Style
:
:
VirtualMem
)
;
return
Ok
(
len
)
;
}
Err
(
err
)
=
>
err
}
;
let
file
=
match
std
:
:
fs
:
:
File
:
:
open
(
format
!
(
"
/
proc
/
{
}
/
mem
"
self
.
pid
)
)
{
Ok
(
mut
file
)
=
>
match
Self
:
:
file
(
&
mut
file
src
dst
)
{
Ok
(
len
)
=
>
{
self
.
style
=
Some
(
Style
:
:
File
(
file
)
)
;
return
Ok
(
len
)
;
}
Err
(
err
)
=
>
err
}
Err
(
err
)
=
>
nix
:
:
Error
:
:
from_raw
(
err
.
raw_os_error
(
)
.
expect
(
"
failed
to
open
/
proc
/
<
pid
>
/
mem
and
the
I
/
O
error
doesn
'
t
have
an
OS
code
"
)
)
}
;
let
ptrace
=
match
Self
:
:
ptrace
(
self
.
pid
src
dst
)
{
Ok
(
len
)
=
>
{
self
.
style
=
Some
(
Style
:
:
Ptrace
)
;
return
Ok
(
len
)
;
}
Err
(
(
err
_
)
)
=
>
err
}
;
self
.
style
=
Some
(
Style
:
:
Unavailable
{
vmem
file
ptrace
}
)
;
Err
(
CopyFromProcessError
{
child
:
self
.
pid
.
as_raw
(
)
src
offset
:
0
length
:
dst
.
len
(
)
source
:
ptrace
}
)
}
#
[
inline
]
fn
vmem
(
pid
:
nix
:
:
unistd
:
:
Pid
src
:
usize
dst
:
&
mut
[
u8
]
)
-
>
Result
<
usize
nix
:
:
Error
>
{
let
remote
=
&
[
nix
:
:
sys
:
:
uio
:
:
RemoteIoVec
{
base
:
src
len
:
dst
.
len
(
)
}
]
;
nix
:
:
sys
:
:
uio
:
:
process_vm_readv
(
pid
&
mut
[
std
:
:
io
:
:
IoSliceMut
:
:
new
(
dst
)
]
remote
)
}
#
[
inline
]
fn
file
(
file
:
&
mut
std
:
:
fs
:
:
File
src
:
usize
dst
:
&
mut
[
u8
]
)
-
>
Result
<
usize
nix
:
:
Error
>
{
use
std
:
:
os
:
:
unix
:
:
fs
:
:
FileExt
;
file
.
read_exact_at
(
dst
src
as
u64
)
.
map_err
(
|
err
|
{
if
let
Some
(
os
)
=
err
.
raw_os_error
(
)
{
nix
:
:
Error
:
:
from_raw
(
os
)
}
else
{
nix
:
:
Error
:
:
E2BIG
}
}
)
?
;
Ok
(
dst
.
len
(
)
)
}
#
[
inline
]
fn
ptrace
(
pid
:
nix
:
:
unistd
:
:
Pid
src
:
usize
dst
:
&
mut
[
u8
]
)
-
>
Result
<
usize
(
nix
:
:
Error
usize
)
>
{
let
mut
offset
=
0
;
let
mut
chunks
=
dst
.
chunks_exact_mut
(
std
:
:
mem
:
:
size_of
:
:
<
usize
>
(
)
)
;
for
chunk
in
chunks
.
by_ref
(
)
{
let
word
=
nix
:
:
sys
:
:
ptrace
:
:
read
(
pid
(
src
+
offset
)
as
*
mut
std
:
:
ffi
:
:
c_void
)
.
map_err
(
|
err
|
(
err
offset
)
)
?
;
chunk
.
copy_from_slice
(
&
word
.
to_ne_bytes
(
)
)
;
offset
+
=
std
:
:
mem
:
:
size_of
:
:
<
usize
>
(
)
;
}
let
last
=
chunks
.
into_remainder
(
)
;
if
!
last
.
is_empty
(
)
{
let
word
=
nix
:
:
sys
:
:
ptrace
:
:
read
(
pid
(
src
+
offset
)
as
*
mut
std
:
:
ffi
:
:
c_void
)
.
map_err
(
|
err
|
(
err
offset
)
)
?
;
last
.
copy_from_slice
(
&
word
.
to_ne_bytes
(
)
[
.
.
last
.
len
(
)
]
)
;
}
Ok
(
dst
.
len
(
)
)
}
}
impl
PtraceDumper
{
#
[
inline
]
pub
fn
copy_from_process
(
pid
:
Pid
src
:
usize
length
:
usize
)
-
>
Result
<
Vec
<
u8
>
crate
:
:
errors
:
:
DumperError
>
{
let
length
=
std
:
:
num
:
:
NonZeroUsize
:
:
new
(
length
)
.
ok_or
(
crate
:
:
errors
:
:
DumperError
:
:
CopyFromProcessError
(
CopyFromProcessError
{
src
child
:
pid
offset
:
0
length
source
:
nix
:
:
errno
:
:
Errno
:
:
EINVAL
}
)
)
?
;
let
mut
mem
=
MemReader
:
:
new
(
pid
)
;
Ok
(
mem
.
read_to_vec
(
src
length
)
?
)
}
}
