#
[
cfg
(
target_os
=
"
android
"
)
]
use
crate
:
:
linux
:
:
android
:
:
late_process_mappings
;
use
crate
:
:
linux
:
:
{
auxv
:
:
AuxvDumpInfo
errors
:
:
{
DumperError
InitError
ThreadInfoError
}
maps_reader
:
:
MappingInfo
module_reader
thread_info
:
:
ThreadInfo
Pid
}
;
#
[
cfg
(
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
]
use
crate
:
:
thread_info
;
use
nix
:
:
{
errno
:
:
Errno
sys
:
:
{
ptrace
signal
wait
}
}
;
use
procfs_core
:
:
{
process
:
:
{
MMPermissions
ProcState
Stat
}
FromRead
ProcError
}
;
use
std
:
:
{
path
result
:
:
Result
time
:
:
{
Duration
Instant
}
}
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
Thread
{
pub
tid
:
Pid
pub
name
:
Option
<
String
>
}
#
[
derive
(
Debug
)
]
pub
struct
PtraceDumper
{
pub
pid
:
Pid
threads_suspended
:
bool
pub
threads
:
Vec
<
Thread
>
pub
auxv
:
AuxvDumpInfo
pub
mappings
:
Vec
<
MappingInfo
>
pub
page_size
:
usize
}
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
pub
const
AT_SYSINFO_EHDR
:
u32
=
33
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
pub
const
AT_SYSINFO_EHDR
:
u64
=
33
;
impl
Drop
for
PtraceDumper
{
fn
drop
(
&
mut
self
)
{
let
_
=
self
.
resume_threads
(
)
;
let
_
=
self
.
continue_process
(
)
;
}
}
#
[
derive
(
Debug
thiserror
:
:
Error
)
]
enum
StopProcessError
{
#
[
error
(
"
Failed
to
stop
the
process
"
)
]
Stop
(
#
[
from
]
Errno
)
#
[
error
(
"
Failed
to
get
the
process
state
"
)
]
State
(
#
[
from
]
ProcError
)
#
[
error
(
"
Timeout
waiting
for
process
to
stop
"
)
]
Timeout
}
#
[
derive
(
Debug
thiserror
:
:
Error
)
]
enum
ContinueProcessError
{
#
[
error
(
"
Failed
to
continue
the
process
"
)
]
Continue
(
#
[
from
]
Errno
)
}
fn
ptrace_detach
(
child
:
Pid
)
-
>
Result
<
(
)
DumperError
>
{
let
pid
=
nix
:
:
unistd
:
:
Pid
:
:
from_raw
(
child
)
;
ptrace
:
:
detach
(
pid
None
)
.
or_else
(
|
e
|
{
if
e
=
=
nix
:
:
Error
:
:
ESRCH
{
Ok
(
(
)
)
}
else
{
Err
(
DumperError
:
:
PtraceDetachError
(
child
e
)
)
}
}
)
}
impl
PtraceDumper
{
pub
fn
new
(
pid
:
Pid
stop_timeout
:
Duration
auxv
:
AuxvDumpInfo
)
-
>
Result
<
Self
InitError
>
{
if
pid
=
=
std
:
:
process
:
:
id
(
)
as
_
{
return
Err
(
InitError
:
:
CannotPtraceSameProcess
)
;
}
let
mut
dumper
=
Self
{
pid
threads_suspended
:
false
threads
:
Vec
:
:
new
(
)
auxv
mappings
:
Vec
:
:
new
(
)
page_size
:
0
}
;
dumper
.
init
(
stop_timeout
)
?
;
Ok
(
dumper
)
}
pub
fn
init
(
&
mut
self
stop_timeout
:
Duration
)
-
>
Result
<
(
)
InitError
>
{
if
let
Err
(
e
)
=
self
.
stop_process
(
stop_timeout
)
{
log
:
:
warn
!
(
"
failed
to
stop
process
{
}
:
{
e
}
"
self
.
pid
)
;
}
if
let
Err
(
e
)
=
self
.
auxv
.
try_filling_missing_info
(
self
.
pid
)
{
log
:
:
warn
!
(
"
failed
trying
to
fill
in
missing
auxv
info
:
{
e
}
"
)
;
}
self
.
enumerate_threads
(
)
?
;
self
.
enumerate_mappings
(
)
?
;
self
.
page_size
=
nix
:
:
unistd
:
:
sysconf
(
nix
:
:
unistd
:
:
SysconfVar
:
:
PAGE_SIZE
)
?
.
expect
(
"
page
size
apparently
unlimited
:
doesn
'
t
make
sense
.
"
)
as
usize
;
Ok
(
(
)
)
}
#
[
cfg_attr
(
not
(
target_os
=
"
android
"
)
allow
(
clippy
:
:
unused_self
)
)
]
pub
fn
late_init
(
&
mut
self
)
-
>
Result
<
(
)
InitError
>
{
#
[
cfg
(
target_os
=
"
android
"
)
]
{
late_process_mappings
(
self
.
pid
&
mut
self
.
mappings
)
?
;
}
Ok
(
(
)
)
}
pub
fn
suspend_thread
(
child
:
Pid
)
-
>
Result
<
(
)
DumperError
>
{
use
DumperError
:
:
PtraceAttachError
as
AttachErr
;
let
pid
=
nix
:
:
unistd
:
:
Pid
:
:
from_raw
(
child
)
;
ptrace
:
:
attach
(
pid
)
.
map_err
(
|
e
|
AttachErr
(
child
e
)
)
?
;
loop
{
match
wait
:
:
waitpid
(
pid
Some
(
wait
:
:
WaitPidFlag
:
:
__WALL
)
)
{
Ok
(
status
)
=
>
{
let
wait
:
:
WaitStatus
:
:
Stopped
(
_
status
)
=
status
else
{
return
Err
(
DumperError
:
:
WaitPidError
(
child
nix
:
:
errno
:
:
Errno
:
:
UnknownErrno
)
)
;
}
;
if
status
=
=
nix
:
:
sys
:
:
signal
:
:
SIGSTOP
{
break
;
}
if
let
Err
(
err
)
=
ptrace
:
:
cont
(
pid
status
)
{
return
Err
(
DumperError
:
:
WaitPidError
(
child
err
)
)
;
}
}
Err
(
Errno
:
:
EINTR
)
=
>
continue
Err
(
e
)
=
>
{
ptrace_detach
(
child
)
?
;
return
Err
(
DumperError
:
:
WaitPidError
(
child
e
)
)
;
}
}
}
#
[
cfg
(
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
]
{
let
skip_thread
;
let
regs
=
thread_info
:
:
ThreadInfo
:
:
getregs
(
pid
.
into
(
)
)
;
if
let
Ok
(
regs
)
=
regs
{
#
[
cfg
(
target_arch
=
"
x86_64
"
)
]
{
skip_thread
=
regs
.
rsp
=
=
0
;
}
#
[
cfg
(
target_arch
=
"
x86
"
)
]
{
skip_thread
=
regs
.
esp
=
=
0
;
}
}
else
{
skip_thread
=
true
;
}
if
skip_thread
{
ptrace_detach
(
child
)
?
;
return
Err
(
DumperError
:
:
DetachSkippedThread
(
child
)
)
;
}
}
Ok
(
(
)
)
}
pub
fn
resume_thread
(
child
:
Pid
)
-
>
Result
<
(
)
DumperError
>
{
ptrace_detach
(
child
)
}
pub
fn
suspend_threads
(
&
mut
self
)
-
>
Result
<
(
)
DumperError
>
{
let
threads_count
=
self
.
threads
.
len
(
)
;
self
.
threads
.
retain
(
|
x
|
Self
:
:
suspend_thread
(
x
.
tid
)
.
is_ok
(
)
)
;
if
self
.
threads
.
is_empty
(
)
{
Err
(
DumperError
:
:
SuspendNoThreadsLeft
(
threads_count
)
)
}
else
{
self
.
threads_suspended
=
true
;
Ok
(
(
)
)
}
}
pub
fn
resume_threads
(
&
mut
self
)
-
>
Result
<
(
)
DumperError
>
{
let
mut
result
=
Ok
(
(
)
)
;
if
self
.
threads_suspended
{
for
thread
in
&
self
.
threads
{
match
Self
:
:
resume_thread
(
thread
.
tid
)
{
Ok
(
_
)
=
>
{
}
x
=
>
{
result
=
x
;
}
}
}
}
self
.
threads_suspended
=
false
;
result
}
fn
stop_process
(
&
mut
self
timeout
:
Duration
)
-
>
Result
<
(
)
StopProcessError
>
{
signal
:
:
kill
(
nix
:
:
unistd
:
:
Pid
:
:
from_raw
(
self
.
pid
)
Some
(
signal
:
:
SIGSTOP
)
)
?
;
const
POLL_INTERVAL
:
Duration
=
Duration
:
:
from_millis
(
1
)
;
let
proc_file
=
format
!
(
"
/
proc
/
{
}
/
stat
"
self
.
pid
)
;
let
end
=
Instant
:
:
now
(
)
+
timeout
;
loop
{
if
let
Ok
(
ProcState
:
:
Stopped
)
=
Stat
:
:
from_file
(
&
proc_file
)
?
.
state
(
)
{
return
Ok
(
(
)
)
;
}
std
:
:
thread
:
:
sleep
(
POLL_INTERVAL
)
;
if
Instant
:
:
now
(
)
>
end
{
return
Err
(
StopProcessError
:
:
Timeout
)
;
}
}
}
fn
continue_process
(
&
mut
self
)
-
>
Result
<
(
)
ContinueProcessError
>
{
signal
:
:
kill
(
nix
:
:
unistd
:
:
Pid
:
:
from_raw
(
self
.
pid
)
Some
(
signal
:
:
SIGCONT
)
)
?
;
Ok
(
(
)
)
}
fn
enumerate_threads
(
&
mut
self
)
-
>
Result
<
(
)
InitError
>
{
let
pid
=
self
.
pid
;
let
filename
=
format
!
(
"
/
proc
/
{
}
/
task
"
pid
)
;
let
task_path
=
path
:
:
PathBuf
:
:
from
(
&
filename
)
;
if
task_path
.
is_dir
(
)
{
std
:
:
fs
:
:
read_dir
(
task_path
)
.
map_err
(
|
e
|
InitError
:
:
IOError
(
filename
e
)
)
?
.
filter_map
(
|
entry
|
entry
.
ok
(
)
)
.
filter_map
(
|
entry
|
{
entry
.
file_name
(
)
.
to_str
(
)
.
and_then
(
|
name
|
name
.
parse
:
:
<
Pid
>
(
)
.
ok
(
)
)
}
)
.
map
(
|
tid
|
{
let
name
=
std
:
:
fs
:
:
read_to_string
(
format
!
(
"
/
proc
/
{
}
/
task
/
{
}
/
comm
"
pid
tid
)
)
.
map
(
|
s
|
s
.
trim_end
(
)
.
to_string
(
)
)
.
ok
(
)
;
(
tid
name
)
}
)
.
for_each
(
|
(
tid
name
)
|
self
.
threads
.
push
(
Thread
{
tid
name
}
)
)
;
}
Ok
(
(
)
)
}
fn
enumerate_mappings
(
&
mut
self
)
-
>
Result
<
(
)
InitError
>
{
let
linux_gate_loc
=
self
.
auxv
.
get_linux_gate_address
(
)
.
unwrap_or_default
(
)
;
let
entry_point_loc
=
self
.
auxv
.
get_entry_address
(
)
.
unwrap_or_default
(
)
;
let
filename
=
format
!
(
"
/
proc
/
{
}
/
maps
"
self
.
pid
)
;
let
errmap
=
|
e
|
InitError
:
:
IOError
(
filename
.
clone
(
)
e
)
;
let
maps_path
=
path
:
:
PathBuf
:
:
from
(
&
filename
)
;
let
maps_file
=
std
:
:
fs
:
:
File
:
:
open
(
maps_path
)
.
map_err
(
errmap
)
?
;
use
procfs_core
:
:
FromRead
;
self
.
mappings
=
procfs_core
:
:
process
:
:
MemoryMaps
:
:
from_read
(
maps_file
)
.
ok
(
)
.
and_then
(
|
maps
|
MappingInfo
:
:
aggregate
(
maps
linux_gate_loc
)
.
ok
(
)
)
.
unwrap_or_default
(
)
;
if
entry_point_loc
!
=
0
{
let
mut
swap_idx
=
None
;
for
(
idx
module
)
in
self
.
mappings
.
iter
(
)
.
enumerate
(
)
{
if
entry_point_loc
>
=
module
.
start_address
.
try_into
(
)
.
unwrap
(
)
&
&
entry_point_loc
<
(
module
.
start_address
+
module
.
size
)
.
try_into
(
)
.
unwrap
(
)
{
swap_idx
=
Some
(
idx
)
;
break
;
}
}
if
let
Some
(
idx
)
=
swap_idx
{
self
.
mappings
.
swap
(
0
idx
)
;
}
}
Ok
(
(
)
)
}
pub
fn
get_thread_info_by_index
(
&
self
index
:
usize
)
-
>
Result
<
ThreadInfo
ThreadInfoError
>
{
if
index
>
self
.
threads
.
len
(
)
{
return
Err
(
ThreadInfoError
:
:
IndexOutOfBounds
(
index
self
.
threads
.
len
(
)
)
)
;
}
ThreadInfo
:
:
create
(
self
.
pid
self
.
threads
[
index
]
.
tid
)
}
pub
fn
get_stack_info
(
&
self
int_stack_pointer
:
usize
)
-
>
Result
<
(
usize
usize
)
DumperError
>
{
let
mut
stack_pointer
=
int_stack_pointer
&
!
(
self
.
page_size
-
1
)
;
let
mut
mapping
=
self
.
find_mapping
(
stack_pointer
)
;
let
guard_page_max_addr
=
stack_pointer
.
saturating_add
(
1024
*
1024
)
;
while
!
Self
:
:
may_be_stack
(
mapping
)
&
&
(
stack_pointer
<
=
guard_page_max_addr
)
{
stack_pointer
+
=
self
.
page_size
;
mapping
=
self
.
find_mapping
(
stack_pointer
)
;
}
mapping
.
map
(
|
mapping
|
{
let
valid_stack_pointer
=
if
mapping
.
contains_address
(
stack_pointer
)
{
stack_pointer
}
else
{
mapping
.
start_address
}
;
let
stack_len
=
mapping
.
size
-
(
valid_stack_pointer
-
mapping
.
start_address
)
;
(
valid_stack_pointer
stack_len
)
}
)
.
ok_or
(
DumperError
:
:
NoStackPointerMapping
)
}
fn
may_be_stack
(
mapping
:
Option
<
&
MappingInfo
>
)
-
>
bool
{
if
let
Some
(
mapping
)
=
mapping
{
return
mapping
.
permissions
.
intersects
(
MMPermissions
:
:
READ
|
MMPermissions
:
:
WRITE
)
;
}
false
}
pub
fn
sanitize_stack_copy
(
&
self
stack_copy
:
&
mut
[
u8
]
stack_pointer
:
usize
sp_offset
:
usize
)
-
>
Result
<
(
)
DumperError
>
{
let
defaced
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
{
defaced
=
0x0defaced0defacedusize
.
to_ne_bytes
(
)
;
}
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
{
defaced
=
0x0defacedusize
.
to_ne_bytes
(
)
;
}
;
let
test_bits
=
11
;
let
array_size
:
usize
=
1
<
<
(
test_bits
-
3
)
;
let
array_mask
=
array_size
-
1
;
let
shift
=
32
-
11
;
let
stack_mapping
=
self
.
find_mapping_no_bias
(
stack_pointer
)
;
let
mut
last_hit_mapping
:
Option
<
&
MappingInfo
>
=
None
;
let
small_int_magnitude
:
isize
=
4096
;
let
mut
could_hit_mapping
=
vec
!
[
0
;
array_size
]
;
for
mapping
in
&
self
.
mappings
{
if
!
mapping
.
is_executable
(
)
{
continue
;
}
let
mut
start
=
mapping
.
start_address
;
let
mut
end
=
start
+
mapping
.
size
;
start
>
>
=
shift
;
end
>
>
=
shift
;
for
bit
in
start
.
.
=
end
{
could_hit_mapping
[
(
bit
>
>
3
)
&
array_mask
]
|
=
1
<
<
(
bit
&
7
)
;
}
}
let
offset
=
(
sp_offset
+
std
:
:
mem
:
:
size_of
:
:
<
usize
>
(
)
-
1
)
&
!
(
std
:
:
mem
:
:
size_of
:
:
<
usize
>
(
)
-
1
)
;
for
x
in
&
mut
stack_copy
[
0
.
.
offset
]
{
*
x
=
0
;
}
let
mut
chunks
=
stack_copy
[
offset
.
.
]
.
chunks_exact_mut
(
std
:
:
mem
:
:
size_of
:
:
<
usize
>
(
)
)
;
for
sp
in
&
mut
chunks
{
let
addr
=
usize
:
:
from_ne_bytes
(
sp
.
to_vec
(
)
.
as_slice
(
)
.
try_into
(
)
?
)
;
let
addr_signed
=
isize
:
:
from_ne_bytes
(
sp
.
to_vec
(
)
.
as_slice
(
)
.
try_into
(
)
?
)
;
if
addr
<
=
small_int_magnitude
as
usize
&
&
addr_signed
>
=
-
small_int_magnitude
{
continue
;
}
if
let
Some
(
stack_map
)
=
stack_mapping
{
if
stack_map
.
contains_address
(
addr
)
{
continue
;
}
}
if
let
Some
(
last_hit
)
=
last_hit_mapping
{
if
last_hit
.
contains_address
(
addr
)
{
continue
;
}
}
let
test
=
addr
>
>
shift
;
if
could_hit_mapping
[
(
test
>
>
3
)
&
array_mask
]
&
(
1
<
<
(
test
&
7
)
)
!
=
0
{
if
let
Some
(
hit_mapping
)
=
self
.
find_mapping_no_bias
(
addr
)
{
if
hit_mapping
.
is_executable
(
)
{
last_hit_mapping
=
Some
(
hit_mapping
)
;
continue
;
}
}
}
sp
.
copy_from_slice
(
&
defaced
)
;
}
for
sp
in
chunks
.
into_remainder
(
)
{
*
sp
=
0
;
}
Ok
(
(
)
)
}
pub
fn
find_mapping
(
&
self
address
:
usize
)
-
>
Option
<
&
MappingInfo
>
{
self
.
mappings
.
iter
(
)
.
find
(
|
map
|
address
>
=
map
.
start_address
&
&
address
-
map
.
start_address
<
map
.
size
)
}
pub
fn
find_mapping_no_bias
(
&
self
address
:
usize
)
-
>
Option
<
&
MappingInfo
>
{
self
.
mappings
.
iter
(
)
.
find
(
|
map
|
{
address
>
=
map
.
system_mapping_info
.
start_address
&
&
address
<
map
.
system_mapping_info
.
end_address
}
)
}
pub
fn
from_process_memory_for_index
<
T
:
module_reader
:
:
ReadFromModule
>
(
&
mut
self
idx
:
usize
)
-
>
Result
<
T
DumperError
>
{
assert
!
(
idx
<
self
.
mappings
.
len
(
)
)
;
Self
:
:
from_process_memory_for_mapping
(
&
self
.
mappings
[
idx
]
self
.
pid
)
}
pub
fn
from_process_memory_for_mapping
<
T
:
module_reader
:
:
ReadFromModule
>
(
mapping
:
&
MappingInfo
pid
:
Pid
)
-
>
Result
<
T
DumperError
>
{
Ok
(
T
:
:
read_from_module
(
module_reader
:
:
ProcessReader
:
:
new
(
pid
mapping
.
start_address
)
.
into
(
)
)
?
)
}
}
