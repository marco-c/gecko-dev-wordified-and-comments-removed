use
super
:
:
*
;
impl
MinidumpWriter
{
pub
(
crate
)
fn
write_thread_names
(
&
mut
self
buffer
:
&
mut
DumpBuf
dumper
:
&
TaskDumper
)
-
>
Result
<
MDRawDirectory
WriterError
>
{
let
threads
=
self
.
threads
(
dumper
)
;
let
list_header
=
MemoryWriter
:
:
<
u32
>
:
:
alloc_with_val
(
buffer
threads
.
len
(
)
as
u32
)
?
;
let
mut
dirent
=
MDRawDirectory
{
stream_type
:
MDStreamType
:
:
ThreadNamesStream
as
u32
location
:
list_header
.
location
(
)
}
;
let
mut
names
=
MemoryArrayWriter
:
:
<
MDRawThreadName
>
:
:
alloc_array
(
buffer
threads
.
len
(
)
)
?
;
dirent
.
location
.
data_size
+
=
names
.
location
(
)
.
data_size
;
for
(
i
tid
)
in
threads
.
enumerate
(
)
{
let
name_loc
=
match
Self
:
:
write_thread_name
(
buffer
dumper
tid
)
{
Ok
(
loc
)
=
>
loc
Err
(
err
)
=
>
{
log
:
:
warn
!
(
"
failed
to
write
thread
name
for
thread
{
tid
}
:
{
err
}
"
)
;
write_string_to_location
(
buffer
"
"
)
?
}
}
;
let
thread
=
MDRawThreadName
{
thread_id
:
tid
thread_name_rva
:
name_loc
.
rva
.
into
(
)
}
;
names
.
set_value_at
(
buffer
thread
i
)
?
;
}
Ok
(
dirent
)
}
fn
write_thread_name
(
buffer
:
&
mut
Buffer
dumper
:
&
TaskDumper
tid
:
u32
)
-
>
Result
<
MDLocationDescriptor
WriterError
>
{
impl
mach
:
:
ThreadInfo
for
libc
:
:
proc_threadinfo
{
const
FLAVOR
:
u32
=
5
;
}
let
thread_info
:
libc
:
:
proc_threadinfo
=
dumper
.
thread_info
(
tid
)
?
;
let
name
=
std
:
:
str
:
:
from_utf8
(
unsafe
{
std
:
:
slice
:
:
from_raw_parts
(
thread_info
.
pth_name
.
as_ptr
(
)
.
cast
(
)
thread_info
.
pth_name
.
len
(
)
)
}
)
.
unwrap_or_default
(
)
;
let
tname
=
match
name
.
find
(
'
\
0
'
)
{
Some
(
i
)
=
>
&
name
[
.
.
i
]
None
=
>
name
}
;
Ok
(
write_string_to_location
(
buffer
tname
)
?
)
}
}
