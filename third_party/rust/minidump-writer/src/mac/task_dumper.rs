use
crate
:
:
mac
:
:
mach
;
use
mach2
:
:
mach_types
as
mt
;
use
thiserror
:
:
Error
;
#
[
derive
(
Error
Debug
)
]
pub
enum
TaskDumpError
{
#
[
error
(
"
kernel
error
{
syscall
}
{
error
}
)
"
)
]
Kernel
{
syscall
:
&
'
static
str
error
:
mach
:
:
KernelError
}
#
[
error
(
"
detected
an
invalid
mach
image
header
"
)
]
InvalidMachHeader
#
[
error
(
transparent
)
]
NonUtf8String
(
#
[
from
]
std
:
:
string
:
:
FromUtf8Error
)
#
[
error
(
"
unable
to
find
the
main
executable
image
for
the
process
"
)
]
NoExecutableImage
#
[
error
(
"
expected
load
command
{
name
}
(
{
id
:
?
}
)
was
not
found
for
an
image
"
)
]
MissingLoadCommand
{
name
:
&
'
static
str
id
:
mach
:
:
LoadCommandKind
}
}
macro_rules
!
mach_call
{
(
call
:
expr
)
=
>
{
{
/
/
SAFETY
:
syscall
let
kr
=
unsafe
{
call
}
;
if
kr
=
=
mach
:
:
KERN_SUCCESS
{
Ok
(
(
)
)
}
else
{
/
/
This
is
ugly
improvements
to
the
macro
welcome
!
let
mut
syscall
=
stringify
!
(
call
)
;
if
let
Some
(
i
)
=
syscall
.
find
(
'
(
'
)
{
syscall
=
&
syscall
[
.
.
i
]
;
}
Err
(
TaskDumpError
:
:
Kernel
{
syscall
error
:
kr
.
into
(
)
}
)
}
}
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
AllImagesInfo
{
pub
version
:
u32
info_array_count
:
u32
info_array_addr
:
u64
_notification
:
u64
_process_detached_from_shared_region
:
bool
lib_system_initialized
:
bool
pub
dyld_image_load_address
:
u64
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Clone
Copy
)
]
pub
struct
ImageInfo
{
pub
load_address
:
u64
pub
file_path
:
u64
pub
file_mod_date
:
u64
}
impl
PartialEq
for
ImageInfo
{
fn
eq
(
&
self
o
:
&
Self
)
-
>
bool
{
self
.
load_address
=
=
o
.
load_address
}
}
impl
Eq
for
ImageInfo
{
}
impl
Ord
for
ImageInfo
{
fn
cmp
(
&
self
o
:
&
Self
)
-
>
std
:
:
cmp
:
:
Ordering
{
self
.
load_address
.
cmp
(
&
o
.
load_address
)
}
}
impl
PartialOrd
for
ImageInfo
{
fn
partial_cmp
(
&
self
o
:
&
Self
)
-
>
Option
<
std
:
:
cmp
:
:
Ordering
>
{
Some
(
self
.
cmp
(
o
)
)
}
}
pub
struct
VMRegionInfo
{
pub
info
:
mach
:
:
vm_region_submap_info_64
pub
range
:
std
:
:
ops
:
:
Range
<
u64
>
}
pub
struct
TaskDumper
{
task
:
mt
:
:
task_t
page_size
:
i64
}
impl
TaskDumper
{
pub
fn
new
(
task
:
mt
:
:
task_t
)
-
>
Self
{
Self
{
task
page_size
:
unsafe
{
libc
:
:
sysconf
(
libc
:
:
_SC_PAGESIZE
)
}
as
i64
}
}
pub
fn
read_task_memory
<
T
>
(
&
self
address
:
u64
count
:
usize
)
-
>
Result
<
Vec
<
T
>
TaskDumpError
>
where
T
:
Sized
+
Clone
{
let
length
=
(
count
*
std
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
)
as
u64
;
let
page_address
=
address
&
(
-
self
.
page_size
as
u64
)
;
let
last_page_address
=
(
address
+
length
+
(
self
.
page_size
-
1
)
as
u64
)
&
(
-
self
.
page_size
as
u64
)
;
let
page_size
=
last_page_address
-
page_address
;
let
mut
local_start
=
0
;
let
mut
local_length
=
0
;
mach_call
!
(
mach
:
:
mach_vm_read
(
self
.
task
page_address
page_size
&
mut
local_start
&
mut
local_length
)
)
?
;
let
mut
buffer
=
Vec
:
:
with_capacity
(
count
)
;
let
task_buffer
=
unsafe
{
std
:
:
slice
:
:
from_raw_parts
(
(
local_start
as
*
const
u8
)
.
offset
(
(
address
-
page_address
)
as
isize
)
.
cast
(
)
count
)
}
;
buffer
.
extend_from_slice
(
task_buffer
)
;
let
_res
=
mach_call
!
(
mach
:
:
mach_vm_deallocate
(
mach
:
:
mach_task_self
(
)
local_start
as
u64
/
/
vm_read
returns
a
pointer
but
vm_deallocate
takes
a
integer
address
:
-
/
local_length
as
u64
/
/
vm_read
and
vm_deallocate
use
different
sizes
:
-
/
)
)
;
Ok
(
buffer
)
}
pub
fn
read_string
(
&
self
addr
:
u64
expected_size
:
Option
<
usize
>
)
-
>
Result
<
Option
<
String
>
TaskDumpError
>
{
let
get_region_size
=
|
|
-
>
Result
<
u64
TaskDumpError
>
{
let
region
=
self
.
get_vm_region
(
addr
)
?
;
let
mut
size_to_end
=
region
.
range
.
end
-
addr
;
if
size_to_end
<
4
*
1024
{
let
maybe_adjacent
=
self
.
get_vm_region
(
region
.
range
.
end
)
?
;
if
maybe_adjacent
.
range
.
start
=
=
region
.
range
.
end
{
size_to_end
+
=
maybe_adjacent
.
range
.
end
-
maybe_adjacent
.
range
.
start
;
}
}
Ok
(
size_to_end
)
}
;
if
let
Ok
(
size_to_end
)
=
get_region_size
(
)
{
let
mut
bytes
=
self
.
read_task_memory
(
addr
std
:
:
cmp
:
:
min
(
size_to_end
as
usize
expected_size
.
unwrap_or
(
8
*
1024
)
)
)
?
;
if
let
Some
(
null_pos
)
=
bytes
.
iter
(
)
.
position
(
|
c
|
*
c
=
=
0
)
{
bytes
.
resize
(
null_pos
0
)
;
}
Ok
(
String
:
:
from_utf8
(
bytes
)
.
map
(
Some
)
?
)
}
else
{
Ok
(
None
)
}
}
pub
fn
get_vm_region
(
&
self
addr
:
u64
)
-
>
Result
<
VMRegionInfo
TaskDumpError
>
{
let
mut
region_base
=
addr
;
let
mut
region_size
=
0
;
let
mut
nesting_level
=
0
;
let
mut
submap_info
=
std
:
:
mem
:
:
MaybeUninit
:
:
<
mach
:
:
vm_region_submap_info_64
>
:
:
uninit
(
)
;
const
VM_REGION_SUBMAP_INFO_COUNT_64
:
u32
=
(
std
:
:
mem
:
:
size_of
:
:
<
mach
:
:
vm_region_submap_info_64
>
(
)
/
std
:
:
mem
:
:
size_of
:
:
<
u32
>
(
)
)
as
u32
;
let
mut
info_count
=
VM_REGION_SUBMAP_INFO_COUNT_64
;
mach_call
!
(
mach
:
:
mach_vm_region_recurse
(
self
.
task
&
mut
region_base
&
mut
region_size
&
mut
nesting_level
submap_info
.
as_mut_ptr
(
)
.
cast
(
)
&
mut
info_count
)
)
?
;
Ok
(
VMRegionInfo
{
info
:
unsafe
{
submap_info
.
assume_init
(
)
}
range
:
region_base
.
.
region_base
+
region_size
}
)
}
pub
fn
read_thread_state
(
&
self
tid
:
u32
)
-
>
Result
<
mach
:
:
ThreadState
TaskDumpError
>
{
let
mut
thread_state
=
mach
:
:
ThreadState
:
:
default
(
)
;
mach_call
!
(
mach
:
:
thread_get_state
(
tid
mach
:
:
THREAD_STATE_FLAVOR
as
i32
thread_state
.
state
.
as_mut_ptr
(
)
&
mut
thread_state
.
state_size
)
)
?
;
Ok
(
thread_state
)
}
pub
fn
task_info
<
T
:
mach
:
:
TaskInfo
>
(
&
self
)
-
>
Result
<
T
TaskDumpError
>
{
let
mut
info
=
std
:
:
mem
:
:
MaybeUninit
:
:
<
T
>
:
:
uninit
(
)
;
let
mut
count
=
(
std
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
/
std
:
:
mem
:
:
size_of
:
:
<
u32
>
(
)
)
as
u32
;
mach_call
!
(
mach
:
:
task
:
:
task_info
(
self
.
task
T
:
:
FLAVOR
info
.
as_mut_ptr
(
)
.
cast
(
)
&
mut
count
)
)
?
;
unsafe
{
Ok
(
info
.
assume_init
(
)
)
}
}
pub
fn
thread_info
<
T
:
mach
:
:
ThreadInfo
>
(
&
self
tid
:
u32
)
-
>
Result
<
T
TaskDumpError
>
{
let
mut
thread_info
=
std
:
:
mem
:
:
MaybeUninit
:
:
<
T
>
:
:
uninit
(
)
;
let
mut
count
=
(
std
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
/
std
:
:
mem
:
:
size_of
:
:
<
u32
>
(
)
)
as
u32
;
mach_call
!
(
mach
:
:
thread_info
(
tid
T
:
:
FLAVOR
thread_info
.
as_mut_ptr
(
)
.
cast
(
)
&
mut
count
)
)
?
;
unsafe
{
Ok
(
thread_info
.
assume_init
(
)
)
}
}
pub
fn
read_images
(
&
self
)
-
>
Result
<
(
AllImagesInfo
Vec
<
ImageInfo
>
)
TaskDumpError
>
{
impl
mach
:
:
TaskInfo
for
mach
:
:
task_info
:
:
task_dyld_info
{
const
FLAVOR
:
u32
=
mach
:
:
task_info
:
:
TASK_DYLD_INFO
;
}
let
all_images_addr
=
{
let
dyld_info
=
self
.
task_info
:
:
<
mach
:
:
task_info
:
:
task_dyld_info
>
(
)
?
;
dyld_info
.
all_image_info_addr
}
;
let
dyld_all_info_buf
=
self
.
read_task_memory
:
:
<
u8
>
(
all_images_addr
std
:
:
mem
:
:
size_of
:
:
<
AllImagesInfo
>
(
)
)
?
;
let
all_images_info
:
&
AllImagesInfo
=
unsafe
{
&
*
(
dyld_all_info_buf
.
as_ptr
(
)
.
cast
(
)
)
}
;
let
images
=
self
.
read_task_memory
:
:
<
ImageInfo
>
(
all_images_info
.
info_array_addr
all_images_info
.
info_array_count
as
usize
)
?
;
Ok
(
(
*
all_images_info
images
)
)
}
pub
fn
read_executable_image
(
&
self
)
-
>
Result
<
ImageInfo
TaskDumpError
>
{
let
(
_
images
)
=
self
.
read_images
(
)
?
;
for
img
in
images
{
let
mach_header
=
self
.
read_task_memory
:
:
<
mach
:
:
MachHeader
>
(
img
.
load_address
1
)
?
;
let
header
=
&
mach_header
[
0
]
;
if
header
.
magic
!
=
mach
:
:
MH_MAGIC_64
{
return
Err
(
TaskDumpError
:
:
InvalidMachHeader
)
;
}
if
header
.
file_type
=
=
mach
:
:
MH_EXECUTE
{
return
Ok
(
img
)
;
}
}
Err
(
TaskDumpError
:
:
NoExecutableImage
)
}
pub
fn
read_load_commands
(
&
self
img
:
&
ImageInfo
)
-
>
Result
<
mach
:
:
LoadCommands
TaskDumpError
>
{
let
mach_header
=
self
.
read_task_memory
:
:
<
mach
:
:
MachHeader
>
(
img
.
load_address
1
)
?
;
let
header
=
&
mach_header
[
0
]
;
if
header
.
magic
!
=
mach
:
:
MH_MAGIC_64
{
return
Err
(
TaskDumpError
:
:
InvalidMachHeader
)
;
}
let
load_commands_buf
=
self
.
read_task_memory
:
:
<
u8
>
(
img
.
load_address
+
std
:
:
mem
:
:
size_of
:
:
<
mach
:
:
MachHeader
>
(
)
as
u64
header
.
size_commands
as
usize
)
?
;
Ok
(
mach
:
:
LoadCommands
{
buffer
:
load_commands_buf
count
:
header
.
num_commands
}
)
}
pub
fn
read_threads
(
&
self
)
-
>
Result
<
&
'
static
[
u32
]
TaskDumpError
>
{
let
mut
threads
=
std
:
:
ptr
:
:
null_mut
(
)
;
let
mut
thread_count
=
0
;
mach_call
!
(
mach
:
:
task_threads
(
self
.
task
&
mut
threads
&
mut
thread_count
)
)
?
;
Ok
(
unsafe
{
std
:
:
slice
:
:
from_raw_parts
(
threads
thread_count
as
usize
)
}
)
}
pub
fn
pid_for_task
(
&
self
)
-
>
Result
<
i32
TaskDumpError
>
{
let
mut
pid
=
0
;
mach_call
!
(
mach
:
:
pid_for_task
(
self
.
task
&
mut
pid
)
)
?
;
Ok
(
pid
)
}
}
