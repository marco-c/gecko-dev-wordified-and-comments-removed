#
!
[
cfg
(
target_os
=
"
macos
"
)
]
mod
common
;
use
common
:
:
start_child_and_return
;
use
minidump
:
:
{
CrashReason
Minidump
MinidumpBreakpadInfo
MinidumpMemoryList
MinidumpMiscInfo
MinidumpModuleList
MinidumpSystemInfo
MinidumpThreadList
}
;
use
minidump_writer
:
:
minidump_writer
:
:
MinidumpWriter
;
fn
get_crash_reason
<
'
a
T
:
std
:
:
ops
:
:
Deref
<
Target
=
[
u8
]
>
+
'
a
>
(
md
:
&
Minidump
<
'
a
T
>
)
-
>
CrashReason
{
let
exc
:
minidump
:
:
MinidumpException
<
'
_
>
=
md
.
get_stream
(
)
.
expect
(
"
unable
to
find
exception
stream
"
)
;
exc
.
get_crash_reason
(
minidump
:
:
system_info
:
:
Os
:
:
MacOs
if
cfg
!
(
target_arch
=
"
x86_64
"
)
{
minidump
:
:
system_info
:
:
Cpu
:
:
X86_64
}
else
if
cfg
!
(
target_arch
=
"
aarch64
"
)
{
minidump
:
:
system_info
:
:
Cpu
:
:
Arm64
}
else
{
unimplemented
!
(
)
}
)
}
struct
Captured
<
'
md
>
{
#
[
allow
(
dead_code
)
]
task
:
u32
thread
:
u32
minidump
:
Minidump
<
'
md
memmap2
:
:
Mmap
>
}
fn
capture_minidump
(
name
:
&
str
exception_kind
:
u32
)
-
>
Captured
<
'
_
>
{
let
mut
server
=
crash_context
:
:
ipc
:
:
Server
:
:
create
(
&
std
:
:
ffi
:
:
CString
:
:
new
(
name
)
.
unwrap
(
)
)
.
expect
(
"
failed
to
create
mach
port
service
"
)
;
let
mut
child
=
start_child_and_return
(
&
[
name
&
exception_kind
.
to_string
(
)
]
)
;
let
mut
rcc
=
server
.
try_recv_crash_context
(
Some
(
std
:
:
time
:
:
Duration
:
:
from_secs
(
5
)
)
)
.
expect
(
"
failed
to
receive
context
"
)
.
expect
(
"
receive
timed
out
"
)
;
let
mut
tmpfile
=
tempfile
:
:
Builder
:
:
new
(
)
.
prefix
(
name
)
.
tempfile
(
)
.
unwrap
(
)
;
let
task
=
rcc
.
crash_context
.
task
;
let
thread
=
rcc
.
crash_context
.
thread
;
let
mut
dumper
=
MinidumpWriter
:
:
with_crash_context
(
rcc
.
crash_context
)
;
dumper
.
dump
(
tmpfile
.
as_file_mut
(
)
)
.
expect
(
"
failed
to
write
minidump
"
)
;
rcc
.
acker
.
send_ack
(
1
Some
(
std
:
:
time
:
:
Duration
:
:
from_secs
(
2
)
)
)
.
expect
(
"
failed
to
send
ack
"
)
;
child
.
kill
(
)
.
expect
(
"
failed
to
kill
child
"
)
;
let
minidump
=
Minidump
:
:
read_path
(
tmpfile
.
path
(
)
)
.
expect
(
"
failed
to
read
minidump
"
)
;
Captured
{
task
thread
minidump
}
}
#
[
test
]
fn
dump_external_process
(
)
{
if
std
:
:
env
:
:
var
(
"
CI
"
)
.
is_ok
(
)
{
println
!
(
"
test
disabled
consistently
times
out
because
of
potato
runners
"
)
;
return
;
}
let
approximate_proc_start_time
=
std
:
:
time
:
:
SystemTime
:
:
now
(
)
.
duration_since
(
std
:
:
time
:
:
SystemTime
:
:
UNIX_EPOCH
)
.
unwrap
(
)
.
as_secs
(
)
;
let
md
=
capture_minidump
(
"
dump_external_process
"
mach2
:
:
exception_types
:
:
EXC_BREAKPOINT
)
.
minidump
;
let
crash_reason
=
get_crash_reason
(
&
md
)
;
assert
!
(
matches
!
(
crash_reason
CrashReason
:
:
MacGeneral
(
minidump_common
:
:
errors
:
:
ExceptionCodeMac
:
:
EXC_BREAKPOINT
_
)
)
)
;
let
_
:
MinidumpModuleList
=
md
.
get_stream
(
)
.
expect
(
"
Couldn
'
t
find
MinidumpModuleList
"
)
;
let
_
:
MinidumpThreadList
=
md
.
get_stream
(
)
.
expect
(
"
Couldn
'
t
find
MinidumpThreadList
"
)
;
let
_
:
MinidumpMemoryList
=
md
.
get_stream
(
)
.
expect
(
"
Couldn
'
t
find
MinidumpMemoryList
"
)
;
let
_
:
MinidumpSystemInfo
=
md
.
get_stream
(
)
.
expect
(
"
Couldn
'
t
find
MinidumpSystemInfo
"
)
;
let
_
:
MinidumpBreakpadInfo
=
md
.
get_stream
(
)
.
expect
(
"
Couldn
'
t
find
MinidumpBreakpadInfo
"
)
;
let
misc_info
:
MinidumpMiscInfo
=
md
.
get_stream
(
)
.
expect
(
"
Couldn
'
t
find
MinidumpMiscInfo
"
)
;
if
let
minidump
:
:
RawMiscInfo
:
:
MiscInfo2
(
mi
)
=
&
misc_info
.
raw
{
let
process_create_time
=
mi
.
process_create_time
as
u64
;
assert
!
(
process_create_time
>
=
approximate_proc_start_time
&
&
process_create_time
<
=
approximate_proc_start_time
+
2
)
;
if
cfg
!
(
target_arch
=
"
x86_64
"
)
{
assert
!
(
mi
.
processor_max_mhz
>
0
)
;
assert
!
(
mi
.
processor_current_mhz
>
0
)
;
}
}
else
{
panic
!
(
"
unexpected
misc
info
type
{
:
?
}
"
misc_info
)
;
}
}
