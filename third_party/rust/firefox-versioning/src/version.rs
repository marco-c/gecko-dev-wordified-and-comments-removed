use
crate
:
:
error
:
:
VersionParsingError
;
use
std
:
:
cmp
:
:
Ordering
;
#
[
derive
(
Debug
Default
Clone
PartialEq
)
]
pub
struct
VersionPart
{
pub
num_a
:
i32
pub
str_b
:
String
pub
num_c
:
i32
pub
extra_d
:
String
}
#
[
derive
(
Debug
Default
Clone
)
]
pub
struct
Version
(
pub
Vec
<
VersionPart
>
)
;
impl
PartialEq
for
Version
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
let
default_version_part
:
VersionPart
=
Default
:
:
default
(
)
;
let
mut
curr_idx
=
0
;
while
curr_idx
<
self
.
0
.
len
(
)
|
|
curr_idx
<
other
.
0
.
len
(
)
{
let
version_part
=
self
.
0
.
get
(
curr_idx
)
.
unwrap_or
(
&
default_version_part
)
;
let
other_version_part
=
other
.
0
.
get
(
curr_idx
)
.
unwrap_or
(
&
default_version_part
)
;
if
!
version_part
.
eq
(
other_version_part
)
{
return
false
;
}
curr_idx
+
=
1
}
true
}
}
impl
PartialOrd
for
Version
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
let
mut
idx
=
0
;
let
default_version
:
VersionPart
=
Default
:
:
default
(
)
;
while
idx
<
self
.
0
.
len
(
)
|
|
idx
<
other
.
0
.
len
(
)
{
let
version_part
=
self
.
0
.
get
(
idx
)
.
unwrap_or
(
&
default_version
)
;
let
other_version_part
=
other
.
0
.
get
(
idx
)
.
unwrap_or
(
&
default_version
)
;
let
ord
=
version_part
.
partial_cmp
(
other_version_part
)
;
match
ord
{
Some
(
Ordering
:
:
Greater
)
|
Some
(
Ordering
:
:
Less
)
=
>
return
ord
_
=
>
(
)
}
idx
+
=
1
;
}
Some
(
Ordering
:
:
Equal
)
}
}
impl
PartialOrd
for
VersionPart
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
let
num_a_ord
=
self
.
num_a
.
partial_cmp
(
&
other
.
num_a
)
;
match
num_a_ord
{
Some
(
Ordering
:
:
Greater
)
|
Some
(
Ordering
:
:
Less
)
=
>
return
num_a_ord
_
=
>
(
)
}
;
if
self
.
str_b
.
is_empty
(
)
&
&
!
other
.
str_b
.
is_empty
(
)
{
return
Some
(
Ordering
:
:
Greater
)
;
}
else
if
other
.
str_b
.
is_empty
(
)
&
&
!
self
.
str_b
.
is_empty
(
)
{
return
Some
(
Ordering
:
:
Less
)
;
}
let
str_b_ord
=
self
.
str_b
.
partial_cmp
(
&
other
.
str_b
)
;
match
str_b_ord
{
Some
(
Ordering
:
:
Greater
)
|
Some
(
Ordering
:
:
Less
)
=
>
return
str_b_ord
_
=
>
(
)
}
;
let
num_c_ord
=
self
.
num_c
.
partial_cmp
(
&
other
.
num_c
)
;
match
num_c_ord
{
Some
(
Ordering
:
:
Greater
)
|
Some
(
Ordering
:
:
Less
)
=
>
return
num_c_ord
_
=
>
(
)
}
;
if
self
.
extra_d
.
is_empty
(
)
&
&
!
other
.
extra_d
.
is_empty
(
)
{
return
Some
(
Ordering
:
:
Greater
)
;
}
else
if
other
.
extra_d
.
is_empty
(
)
&
&
!
self
.
extra_d
.
is_empty
(
)
{
return
Some
(
Ordering
:
:
Less
)
;
}
let
extra_d_ord
=
self
.
extra_d
.
partial_cmp
(
&
other
.
extra_d
)
;
match
extra_d_ord
{
Some
(
Ordering
:
:
Greater
)
|
Some
(
Ordering
:
:
Less
)
=
>
return
extra_d_ord
_
=
>
(
)
}
;
Some
(
Ordering
:
:
Equal
)
}
}
impl
TryFrom
<
&
'
_
str
>
for
Version
{
type
Error
=
VersionParsingError
;
fn
try_from
(
value
:
&
'
_
str
)
-
>
Result
<
Self
Self
:
:
Error
>
{
let
versions
=
value
.
split
(
'
.
'
)
.
map
(
TryInto
:
:
try_into
)
.
collect
:
:
<
Result
<
Vec
<
_
>
_
>
>
(
)
?
;
Ok
(
Version
(
versions
)
)
}
}
impl
TryFrom
<
String
>
for
Version
{
type
Error
=
VersionParsingError
;
fn
try_from
(
curr_part
:
String
)
-
>
Result
<
Self
Self
:
:
Error
>
{
curr_part
.
as_str
(
)
.
try_into
(
)
}
}
fn
char_at
(
value
:
&
str
idx
:
usize
)
-
>
Result
<
char
VersionParsingError
>
{
value
.
chars
(
)
.
nth
(
idx
)
.
ok_or_else
(
|
|
{
VersionParsingError
:
:
Overflow
(
format
!
(
"
Tried
to
access
character
{
}
in
string
{
}
but
it
has
size
{
}
"
idx
value
value
.
len
(
)
)
)
}
)
}
fn
is_num_c
(
c
:
char
)
-
>
bool
{
c
.
is_numeric
(
)
|
|
c
=
=
'
+
'
|
|
c
=
=
'
-
'
}
fn
parse_version_num
(
val
:
i32
res
:
&
mut
i32
)
-
>
Result
<
(
)
VersionParsingError
>
{
if
*
res
=
=
0
{
*
res
=
val
;
}
else
{
let
res_l
=
*
res
as
i64
;
if
(
res_l
*
10
)
+
val
as
i64
>
i32
:
:
MAX
as
i64
{
return
Err
(
VersionParsingError
:
:
Overflow
(
"
Number
parsing
overflows
an
i32
"
.
into
(
)
)
)
;
}
*
res
*
=
10
;
*
res
+
=
val
;
}
Ok
(
(
)
)
}
impl
TryFrom
<
&
'
_
str
>
for
VersionPart
{
type
Error
=
VersionParsingError
;
fn
try_from
(
value
:
&
'
_
str
)
-
>
Result
<
Self
Self
:
:
Error
>
{
if
value
.
chars
(
)
.
any
(
|
c
|
!
c
.
is_ascii
(
)
)
{
return
Err
(
VersionParsingError
:
:
ParseError
(
format
!
(
"
version
string
{
}
contains
non
-
ascii
characters
"
value
)
)
)
;
}
if
value
.
is_empty
(
)
{
return
Ok
(
Default
:
:
default
(
)
)
;
}
let
mut
res
:
VersionPart
=
Default
:
:
default
(
)
;
if
value
=
=
"
*
"
{
res
.
num_a
=
i32
:
:
MAX
;
return
Ok
(
res
)
;
}
let
mut
curr_idx
=
0
;
while
curr_idx
<
value
.
len
(
)
&
&
char_at
(
value
curr_idx
)
?
.
is_numeric
(
)
{
parse_version_num
(
char_at
(
value
curr_idx
)
?
.
to_digit
(
10
)
.
unwrap
(
)
as
i32
&
mut
res
.
num_a
)
?
;
curr_idx
+
=
1
;
}
if
curr_idx
>
=
value
.
len
(
)
{
return
Ok
(
res
)
;
}
let
first_char
=
char_at
(
value
curr_idx
)
?
;
if
first_char
=
=
'
+
'
{
res
.
num_a
+
=
1
;
res
.
str_b
=
"
pre
"
.
into
(
)
;
return
Ok
(
res
)
;
}
while
curr_idx
<
value
.
len
(
)
&
&
!
is_num_c
(
char_at
(
value
curr_idx
)
?
)
{
res
.
str_b
.
push
(
char_at
(
value
curr_idx
)
?
)
;
curr_idx
+
=
1
;
}
if
curr_idx
>
=
value
.
len
(
)
{
return
Ok
(
res
)
;
}
while
curr_idx
<
value
.
len
(
)
&
&
char_at
(
value
curr_idx
)
?
.
is_numeric
(
)
{
parse_version_num
(
char_at
(
value
curr_idx
)
?
.
to_digit
(
10
)
.
unwrap
(
)
as
i32
&
mut
res
.
num_c
)
?
;
curr_idx
+
=
1
;
}
if
curr_idx
>
=
value
.
len
(
)
{
return
Ok
(
res
)
;
}
res
.
extra_d
=
value
[
curr_idx
.
.
]
.
into
(
)
;
Ok
(
res
)
}
}
