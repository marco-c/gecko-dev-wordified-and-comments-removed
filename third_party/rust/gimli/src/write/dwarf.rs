use
alloc
:
:
vec
:
:
Vec
;
use
crate
:
:
common
:
:
Encoding
;
use
crate
:
:
write
:
:
{
AbbreviationTable
LineProgram
LineStringTable
Result
Sections
StringTable
Unit
UnitTable
Writer
}
;
#
[
derive
(
Debug
Default
)
]
pub
struct
Dwarf
{
pub
units
:
UnitTable
pub
line_programs
:
Vec
<
LineProgram
>
pub
line_strings
:
LineStringTable
pub
strings
:
StringTable
}
impl
Dwarf
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
write
<
W
:
Writer
>
(
&
mut
self
sections
:
&
mut
Sections
<
W
>
)
-
>
Result
<
(
)
>
{
let
line_strings
=
self
.
line_strings
.
write
(
&
mut
sections
.
debug_line_str
)
?
;
let
strings
=
self
.
strings
.
write
(
&
mut
sections
.
debug_str
)
?
;
self
.
units
.
write
(
sections
&
line_strings
&
strings
)
?
;
for
line_program
in
&
self
.
line_programs
{
line_program
.
write
(
&
mut
sections
.
debug_line
line_program
.
encoding
(
)
&
line_strings
&
strings
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
DwarfUnit
{
pub
unit
:
Unit
pub
line_strings
:
LineStringTable
pub
strings
:
StringTable
}
impl
DwarfUnit
{
pub
fn
new
(
encoding
:
Encoding
)
-
>
Self
{
let
unit
=
Unit
:
:
new
(
encoding
LineProgram
:
:
none
(
)
)
;
DwarfUnit
{
unit
line_strings
:
LineStringTable
:
:
default
(
)
strings
:
StringTable
:
:
default
(
)
}
}
pub
fn
write
<
W
:
Writer
>
(
&
mut
self
sections
:
&
mut
Sections
<
W
>
)
-
>
Result
<
(
)
>
{
let
line_strings
=
self
.
line_strings
.
write
(
&
mut
sections
.
debug_line_str
)
?
;
let
strings
=
self
.
strings
.
write
(
&
mut
sections
.
debug_str
)
?
;
let
abbrev_offset
=
sections
.
debug_abbrev
.
offset
(
)
;
let
mut
abbrevs
=
AbbreviationTable
:
:
default
(
)
;
self
.
unit
.
write
(
sections
abbrev_offset
&
mut
abbrevs
&
line_strings
&
strings
)
?
;
assert
!
(
sections
.
debug_info_refs
.
is_empty
(
)
)
;
assert
!
(
sections
.
debug_loc_refs
.
is_empty
(
)
)
;
assert
!
(
sections
.
debug_loclists_refs
.
is_empty
(
)
)
;
abbrevs
.
write
(
&
mut
sections
.
debug_abbrev
)
?
;
Ok
(
(
)
)
}
}
#
[
cfg
(
feature
=
"
read
"
)
]
pub
(
crate
)
mod
convert
{
use
super
:
:
*
;
use
crate
:
:
read
:
:
{
self
Reader
}
;
use
crate
:
:
write
:
:
{
Address
ConvertResult
}
;
impl
Dwarf
{
pub
fn
from
<
R
:
Reader
<
Offset
=
usize
>
>
(
dwarf
:
&
read
:
:
Dwarf
<
R
>
convert_address
:
&
dyn
Fn
(
u64
)
-
>
Option
<
Address
>
)
-
>
ConvertResult
<
Dwarf
>
{
let
mut
line_strings
=
LineStringTable
:
:
default
(
)
;
let
mut
strings
=
StringTable
:
:
default
(
)
;
let
units
=
UnitTable
:
:
from
(
dwarf
&
mut
line_strings
&
mut
strings
convert_address
)
?
;
let
line_programs
=
Vec
:
:
new
(
)
;
Ok
(
Dwarf
{
units
line_programs
line_strings
strings
}
)
}
}
}
