use
crate
:
:
common
:
:
{
DebugAddrBase
DebugAddrIndex
DebugRngListsBase
DebugRngListsIndex
DwarfFileType
Encoding
RangeListsOffset
SectionId
}
;
use
crate
:
:
constants
;
use
crate
:
:
endianity
:
:
Endianity
;
use
crate
:
:
read
:
:
{
lists
:
:
ListsHeader
DebugAddr
EndianSlice
Error
Reader
ReaderOffset
ReaderOffsetId
Result
Section
}
;
#
[
derive
(
Debug
Default
Clone
Copy
)
]
pub
struct
DebugRanges
<
R
>
{
pub
(
crate
)
section
:
R
}
impl
<
'
input
Endian
>
DebugRanges
<
EndianSlice
<
'
input
Endian
>
>
where
Endian
:
Endianity
{
pub
fn
new
(
section
:
&
'
input
[
u8
]
endian
:
Endian
)
-
>
Self
{
Self
:
:
from
(
EndianSlice
:
:
new
(
section
endian
)
)
}
}
impl
<
T
>
DebugRanges
<
T
>
{
pub
(
crate
)
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
)
-
>
DebugRanges
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
borrow
(
&
self
.
section
)
.
into
(
)
}
}
impl
<
R
>
Section
<
R
>
for
DebugRanges
<
R
>
{
fn
id
(
)
-
>
SectionId
{
SectionId
:
:
DebugRanges
}
fn
reader
(
&
self
)
-
>
&
R
{
&
self
.
section
}
}
impl
<
R
>
From
<
R
>
for
DebugRanges
<
R
>
{
fn
from
(
section
:
R
)
-
>
Self
{
DebugRanges
{
section
}
}
}
#
[
derive
(
Debug
Default
Clone
Copy
)
]
pub
struct
DebugRngLists
<
R
>
{
section
:
R
}
impl
<
'
input
Endian
>
DebugRngLists
<
EndianSlice
<
'
input
Endian
>
>
where
Endian
:
Endianity
{
pub
fn
new
(
section
:
&
'
input
[
u8
]
endian
:
Endian
)
-
>
Self
{
Self
:
:
from
(
EndianSlice
:
:
new
(
section
endian
)
)
}
}
impl
<
T
>
DebugRngLists
<
T
>
{
pub
(
crate
)
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
)
-
>
DebugRngLists
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
borrow
(
&
self
.
section
)
.
into
(
)
}
}
impl
<
R
>
Section
<
R
>
for
DebugRngLists
<
R
>
{
fn
id
(
)
-
>
SectionId
{
SectionId
:
:
DebugRngLists
}
fn
reader
(
&
self
)
-
>
&
R
{
&
self
.
section
}
}
impl
<
R
>
From
<
R
>
for
DebugRngLists
<
R
>
{
fn
from
(
section
:
R
)
-
>
Self
{
DebugRngLists
{
section
}
}
}
#
[
allow
(
unused
)
]
pub
(
crate
)
type
RngListsHeader
=
ListsHeader
;
impl
<
Offset
>
DebugRngListsBase
<
Offset
>
where
Offset
:
ReaderOffset
{
pub
fn
default_for_encoding_and_file
(
encoding
:
Encoding
file_type
:
DwarfFileType
)
-
>
DebugRngListsBase
<
Offset
>
{
if
encoding
.
version
>
=
5
&
&
file_type
=
=
DwarfFileType
:
:
Dwo
{
DebugRngListsBase
(
Offset
:
:
from_u8
(
RngListsHeader
:
:
size_for_encoding
(
encoding
)
)
)
}
else
{
DebugRngListsBase
(
Offset
:
:
from_u8
(
0
)
)
}
}
}
#
[
derive
(
Debug
Default
Clone
Copy
)
]
pub
struct
RangeLists
<
R
>
{
debug_ranges
:
DebugRanges
<
R
>
debug_rnglists
:
DebugRngLists
<
R
>
}
impl
<
R
>
RangeLists
<
R
>
{
pub
fn
new
(
debug_ranges
:
DebugRanges
<
R
>
debug_rnglists
:
DebugRngLists
<
R
>
)
-
>
RangeLists
<
R
>
{
RangeLists
{
debug_ranges
debug_rnglists
}
}
pub
fn
debug_ranges
(
&
self
)
-
>
&
DebugRanges
<
R
>
{
&
self
.
debug_ranges
}
pub
fn
set_debug_ranges
(
&
mut
self
debug_ranges
:
DebugRanges
<
R
>
)
{
self
.
debug_ranges
=
debug_ranges
;
}
pub
fn
debug_rnglists
(
&
self
)
-
>
&
DebugRngLists
<
R
>
{
&
self
.
debug_rnglists
}
}
impl
<
T
>
RangeLists
<
T
>
{
pub
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
)
-
>
RangeLists
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
RangeLists
{
debug_ranges
:
borrow
(
&
self
.
debug_ranges
.
section
)
.
into
(
)
debug_rnglists
:
borrow
(
&
self
.
debug_rnglists
.
section
)
.
into
(
)
}
}
}
impl
<
R
:
Reader
>
RangeLists
<
R
>
{
pub
fn
ranges
(
&
self
offset
:
RangeListsOffset
<
R
:
:
Offset
>
unit_encoding
:
Encoding
base_address
:
u64
debug_addr
:
&
DebugAddr
<
R
>
debug_addr_base
:
DebugAddrBase
<
R
:
:
Offset
>
)
-
>
Result
<
RngListIter
<
R
>
>
{
Ok
(
RngListIter
:
:
new
(
self
.
raw_ranges
(
offset
unit_encoding
)
?
base_address
debug_addr
.
clone
(
)
debug_addr_base
)
)
}
pub
fn
raw_ranges
(
&
self
offset
:
RangeListsOffset
<
R
:
:
Offset
>
unit_encoding
:
Encoding
)
-
>
Result
<
RawRngListIter
<
R
>
>
{
let
(
mut
input
format
)
=
if
unit_encoding
.
version
<
=
4
{
(
self
.
debug_ranges
.
section
.
clone
(
)
RangeListsFormat
:
:
Bare
)
}
else
{
(
self
.
debug_rnglists
.
section
.
clone
(
)
RangeListsFormat
:
:
Rle
)
}
;
input
.
skip
(
offset
.
0
)
?
;
Ok
(
RawRngListIter
:
:
new
(
input
unit_encoding
format
)
)
}
pub
fn
get_offset
(
&
self
unit_encoding
:
Encoding
base
:
DebugRngListsBase
<
R
:
:
Offset
>
index
:
DebugRngListsIndex
<
R
:
:
Offset
>
)
-
>
Result
<
RangeListsOffset
<
R
:
:
Offset
>
>
{
let
format
=
unit_encoding
.
format
;
let
input
=
&
mut
self
.
debug_rnglists
.
section
.
clone
(
)
;
input
.
skip
(
base
.
0
)
?
;
input
.
skip
(
R
:
:
Offset
:
:
from_u64
(
index
.
0
.
into_u64
(
)
*
u64
:
:
from
(
format
.
word_size
(
)
)
)
?
)
?
;
input
.
read_offset
(
format
)
.
map
(
|
x
|
RangeListsOffset
(
base
.
0
+
x
)
)
}
pub
fn
lookup_offset_id
(
&
self
id
:
ReaderOffsetId
)
-
>
Option
<
(
SectionId
R
:
:
Offset
)
>
{
self
.
debug_ranges
.
lookup_offset_id
(
id
)
.
or_else
(
|
|
self
.
debug_rnglists
.
lookup_offset_id
(
id
)
)
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
enum
RangeListsFormat
{
Bare
Rle
}
#
[
derive
(
Debug
)
]
pub
struct
RawRngListIter
<
R
:
Reader
>
{
input
:
R
encoding
:
Encoding
format
:
RangeListsFormat
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
RawRngListEntry
<
T
>
{
AddressOrOffsetPair
{
begin
:
u64
end
:
u64
}
BaseAddress
{
addr
:
u64
}
BaseAddressx
{
addr
:
DebugAddrIndex
<
T
>
}
StartxEndx
{
begin
:
DebugAddrIndex
<
T
>
end
:
DebugAddrIndex
<
T
>
}
StartxLength
{
begin
:
DebugAddrIndex
<
T
>
length
:
u64
}
OffsetPair
{
begin
:
u64
end
:
u64
}
StartEnd
{
begin
:
u64
end
:
u64
}
StartLength
{
begin
:
u64
length
:
u64
}
}
impl
<
T
:
ReaderOffset
>
RawRngListEntry
<
T
>
{
fn
parse
<
R
:
Reader
<
Offset
=
T
>
>
(
input
:
&
mut
R
encoding
:
Encoding
format
:
RangeListsFormat
)
-
>
Result
<
Option
<
Self
>
>
{
Ok
(
match
format
{
RangeListsFormat
:
:
Bare
=
>
{
let
range
=
RawRange
:
:
parse
(
input
encoding
.
address_size
)
?
;
if
range
.
is_end
(
)
{
None
}
else
if
range
.
is_base_address
(
encoding
.
address_size
)
{
Some
(
RawRngListEntry
:
:
BaseAddress
{
addr
:
range
.
end
}
)
}
else
{
Some
(
RawRngListEntry
:
:
AddressOrOffsetPair
{
begin
:
range
.
begin
end
:
range
.
end
}
)
}
}
RangeListsFormat
:
:
Rle
=
>
match
constants
:
:
DwRle
(
input
.
read_u8
(
)
?
)
{
constants
:
:
DW_RLE_end_of_list
=
>
None
constants
:
:
DW_RLE_base_addressx
=
>
Some
(
RawRngListEntry
:
:
BaseAddressx
{
addr
:
DebugAddrIndex
(
input
.
read_uleb128
(
)
.
and_then
(
R
:
:
Offset
:
:
from_u64
)
?
)
}
)
constants
:
:
DW_RLE_startx_endx
=
>
Some
(
RawRngListEntry
:
:
StartxEndx
{
begin
:
DebugAddrIndex
(
input
.
read_uleb128
(
)
.
and_then
(
R
:
:
Offset
:
:
from_u64
)
?
)
end
:
DebugAddrIndex
(
input
.
read_uleb128
(
)
.
and_then
(
R
:
:
Offset
:
:
from_u64
)
?
)
}
)
constants
:
:
DW_RLE_startx_length
=
>
Some
(
RawRngListEntry
:
:
StartxLength
{
begin
:
DebugAddrIndex
(
input
.
read_uleb128
(
)
.
and_then
(
R
:
:
Offset
:
:
from_u64
)
?
)
length
:
input
.
read_uleb128
(
)
?
}
)
constants
:
:
DW_RLE_offset_pair
=
>
Some
(
RawRngListEntry
:
:
OffsetPair
{
begin
:
input
.
read_uleb128
(
)
?
end
:
input
.
read_uleb128
(
)
?
}
)
constants
:
:
DW_RLE_base_address
=
>
Some
(
RawRngListEntry
:
:
BaseAddress
{
addr
:
input
.
read_address
(
encoding
.
address_size
)
?
}
)
constants
:
:
DW_RLE_start_end
=
>
Some
(
RawRngListEntry
:
:
StartEnd
{
begin
:
input
.
read_address
(
encoding
.
address_size
)
?
end
:
input
.
read_address
(
encoding
.
address_size
)
?
}
)
constants
:
:
DW_RLE_start_length
=
>
Some
(
RawRngListEntry
:
:
StartLength
{
begin
:
input
.
read_address
(
encoding
.
address_size
)
?
length
:
input
.
read_uleb128
(
)
?
}
)
entry
=
>
{
return
Err
(
Error
:
:
UnknownRangeListsEntry
(
entry
)
)
;
}
}
}
)
}
}
impl
<
R
:
Reader
>
RawRngListIter
<
R
>
{
fn
new
(
input
:
R
encoding
:
Encoding
format
:
RangeListsFormat
)
-
>
RawRngListIter
<
R
>
{
RawRngListIter
{
input
encoding
format
}
}
pub
fn
next
(
&
mut
self
)
-
>
Result
<
Option
<
RawRngListEntry
<
R
:
:
Offset
>
>
>
{
if
self
.
input
.
is_empty
(
)
{
return
Ok
(
None
)
;
}
match
RawRngListEntry
:
:
parse
(
&
mut
self
.
input
self
.
encoding
self
.
format
)
{
Ok
(
range
)
=
>
{
if
range
.
is_none
(
)
{
self
.
input
.
empty
(
)
;
}
Ok
(
range
)
}
Err
(
e
)
=
>
{
self
.
input
.
empty
(
)
;
Err
(
e
)
}
}
}
}
#
[
cfg
(
feature
=
"
fallible
-
iterator
"
)
]
impl
<
R
:
Reader
>
fallible_iterator
:
:
FallibleIterator
for
RawRngListIter
<
R
>
{
type
Item
=
RawRngListEntry
<
R
:
:
Offset
>
;
type
Error
=
Error
;
fn
next
(
&
mut
self
)
-
>
:
:
core
:
:
result
:
:
Result
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
{
RawRngListIter
:
:
next
(
self
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
RngListIter
<
R
:
Reader
>
{
raw
:
RawRngListIter
<
R
>
base_address
:
u64
debug_addr
:
DebugAddr
<
R
>
debug_addr_base
:
DebugAddrBase
<
R
:
:
Offset
>
}
impl
<
R
:
Reader
>
RngListIter
<
R
>
{
fn
new
(
raw
:
RawRngListIter
<
R
>
base_address
:
u64
debug_addr
:
DebugAddr
<
R
>
debug_addr_base
:
DebugAddrBase
<
R
:
:
Offset
>
)
-
>
RngListIter
<
R
>
{
RngListIter
{
raw
base_address
debug_addr
debug_addr_base
}
}
#
[
inline
]
fn
get_address
(
&
self
index
:
DebugAddrIndex
<
R
:
:
Offset
>
)
-
>
Result
<
u64
>
{
self
.
debug_addr
.
get_address
(
self
.
raw
.
encoding
.
address_size
self
.
debug_addr_base
index
)
}
pub
fn
next
(
&
mut
self
)
-
>
Result
<
Option
<
Range
>
>
{
loop
{
let
raw_range
=
match
self
.
raw
.
next
(
)
?
{
Some
(
range
)
=
>
range
None
=
>
return
Ok
(
None
)
}
;
let
range
=
self
.
convert_raw
(
raw_range
)
?
;
if
range
.
is_some
(
)
{
return
Ok
(
range
)
;
}
}
}
#
[
doc
(
hidden
)
]
pub
fn
next_raw
(
&
mut
self
)
-
>
Result
<
Option
<
RawRngListEntry
<
R
:
:
Offset
>
>
>
{
self
.
raw
.
next
(
)
}
#
[
doc
(
hidden
)
]
pub
fn
convert_raw
(
&
mut
self
raw_range
:
RawRngListEntry
<
R
:
:
Offset
>
)
-
>
Result
<
Option
<
Range
>
>
{
let
mask
=
!
0
>
>
(
64
-
self
.
raw
.
encoding
.
address_size
*
8
)
;
let
tombstone
=
if
self
.
raw
.
encoding
.
version
<
=
4
{
mask
-
1
}
else
{
mask
}
;
let
range
=
match
raw_range
{
RawRngListEntry
:
:
BaseAddress
{
addr
}
=
>
{
self
.
base_address
=
addr
;
return
Ok
(
None
)
;
}
RawRngListEntry
:
:
BaseAddressx
{
addr
}
=
>
{
self
.
base_address
=
self
.
get_address
(
addr
)
?
;
return
Ok
(
None
)
;
}
RawRngListEntry
:
:
StartxEndx
{
begin
end
}
=
>
{
let
begin
=
self
.
get_address
(
begin
)
?
;
let
end
=
self
.
get_address
(
end
)
?
;
Range
{
begin
end
}
}
RawRngListEntry
:
:
StartxLength
{
begin
length
}
=
>
{
let
begin
=
self
.
get_address
(
begin
)
?
;
let
end
=
begin
.
wrapping_add
(
length
)
&
mask
;
Range
{
begin
end
}
}
RawRngListEntry
:
:
AddressOrOffsetPair
{
begin
end
}
|
RawRngListEntry
:
:
OffsetPair
{
begin
end
}
=
>
{
if
self
.
base_address
=
=
tombstone
{
return
Ok
(
None
)
;
}
let
mut
range
=
Range
{
begin
end
}
;
range
.
add_base_address
(
self
.
base_address
self
.
raw
.
encoding
.
address_size
)
;
range
}
RawRngListEntry
:
:
StartEnd
{
begin
end
}
=
>
Range
{
begin
end
}
RawRngListEntry
:
:
StartLength
{
begin
length
}
=
>
{
let
end
=
begin
.
wrapping_add
(
length
)
&
mask
;
Range
{
begin
end
}
}
}
;
if
range
.
begin
=
=
tombstone
|
|
range
.
begin
>
range
.
end
{
return
Ok
(
None
)
;
}
Ok
(
Some
(
range
)
)
}
}
#
[
cfg
(
feature
=
"
fallible
-
iterator
"
)
]
impl
<
R
:
Reader
>
fallible_iterator
:
:
FallibleIterator
for
RngListIter
<
R
>
{
type
Item
=
Range
;
type
Error
=
Error
;
fn
next
(
&
mut
self
)
-
>
:
:
core
:
:
result
:
:
Result
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
{
RngListIter
:
:
next
(
self
)
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
pub
(
crate
)
struct
RawRange
{
pub
begin
:
u64
pub
end
:
u64
}
impl
RawRange
{
#
[
inline
]
pub
fn
is_end
(
&
self
)
-
>
bool
{
self
.
begin
=
=
0
&
&
self
.
end
=
=
0
}
#
[
inline
]
pub
fn
is_base_address
(
&
self
address_size
:
u8
)
-
>
bool
{
self
.
begin
=
=
!
0
>
>
(
64
-
address_size
*
8
)
}
#
[
inline
]
pub
fn
parse
<
R
:
Reader
>
(
input
:
&
mut
R
address_size
:
u8
)
-
>
Result
<
RawRange
>
{
let
begin
=
input
.
read_address
(
address_size
)
?
;
let
end
=
input
.
read_address
(
address_size
)
?
;
let
range
=
RawRange
{
begin
end
}
;
Ok
(
range
)
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
pub
struct
Range
{
pub
begin
:
u64
pub
end
:
u64
}
impl
Range
{
#
[
inline
]
pub
(
crate
)
fn
add_base_address
(
&
mut
self
base_address
:
u64
address_size
:
u8
)
{
let
mask
=
!
0
>
>
(
64
-
address_size
*
8
)
;
self
.
begin
=
base_address
.
wrapping_add
(
self
.
begin
)
&
mask
;
self
.
end
=
base_address
.
wrapping_add
(
self
.
end
)
&
mask
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
common
:
:
Format
;
use
crate
:
:
endianity
:
:
LittleEndian
;
use
crate
:
:
test_util
:
:
GimliSectionMethods
;
use
test_assembler
:
:
{
Endian
Label
LabelMaker
Section
}
;
#
[
test
]
fn
test_rnglists_32
(
)
{
let
tombstone
=
!
0u32
;
let
encoding
=
Encoding
{
format
:
Format
:
:
Dwarf32
version
:
5
address_size
:
4
}
;
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
L32
(
0x0300_0000
)
.
L32
(
0x0301_0300
)
.
L32
(
0x0301_0400
)
.
L32
(
0x0301_0500
)
.
L32
(
tombstone
)
.
L32
(
0x0301_0600
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_addr
=
&
DebugAddr
:
:
from
(
EndianSlice
:
:
new
(
&
buf
LittleEndian
)
)
;
let
debug_addr_base
=
DebugAddrBase
(
0
)
;
let
start
=
Label
:
:
new
(
)
;
let
first
=
Label
:
:
new
(
)
;
let
size
=
Label
:
:
new
(
)
;
#
[
rustfmt
:
:
skip
]
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
mark
(
&
start
)
.
L32
(
&
size
)
.
L16
(
encoding
.
version
)
.
L8
(
encoding
.
address_size
)
.
L8
(
0
)
.
L32
(
0
)
.
mark
(
&
first
)
.
L8
(
4
)
.
uleb
(
0x10200
)
.
uleb
(
0x10300
)
.
L8
(
5
)
.
L32
(
0x0200_0000
)
.
L8
(
4
)
.
uleb
(
0x10400
)
.
uleb
(
0x10500
)
.
L8
(
4
)
.
uleb
(
0x10600
)
.
uleb
(
0x10600
)
.
L8
(
4
)
.
uleb
(
0x10800
)
.
uleb
(
0x10900
)
.
L8
(
6
)
.
L32
(
0x201_0a00
)
.
L32
(
0x201_0b00
)
.
L8
(
7
)
.
L32
(
0x201_0c00
)
.
uleb
(
0x100
)
.
L8
(
4
)
.
uleb
(
0
)
.
uleb
(
1
)
.
L8
(
4
)
.
uleb
(
0
)
.
uleb
(
0
)
.
L8
(
5
)
.
L32
(
0
)
.
L8
(
4
)
.
uleb
(
0
)
.
uleb
(
0xffff_ffff
)
.
L8
(
1
)
.
uleb
(
0
)
.
L8
(
4
)
.
uleb
(
0x10100
)
.
uleb
(
0x10200
)
.
L8
(
2
)
.
uleb
(
1
)
.
uleb
(
2
)
.
L8
(
3
)
.
uleb
(
3
)
.
uleb
(
0x100
)
.
L8
(
1
)
.
uleb
(
4
)
.
L8
(
4
)
.
uleb
(
0x11100
)
.
uleb
(
0x11200
)
.
L8
(
5
)
.
L32
(
tombstone
)
.
L8
(
4
)
.
uleb
(
0x11300
)
.
uleb
(
0x11400
)
.
L8
(
2
)
.
uleb
(
4
)
.
uleb
(
5
)
.
L8
(
3
)
.
uleb
(
4
)
.
uleb
(
0x100
)
.
L8
(
6
)
.
L32
(
tombstone
)
.
L32
(
0x201_1500
)
.
L8
(
7
)
.
L32
(
tombstone
)
.
uleb
(
0x100
)
.
L8
(
6
)
.
L32
(
0x201_1600
)
.
L32
(
0x201_1700
)
.
L8
(
0
)
.
L32
(
0xffff_ffff
)
;
size
.
set_const
(
(
&
section
.
here
(
)
-
&
start
-
4
)
as
u64
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_ranges
=
DebugRanges
:
:
new
(
&
[
]
LittleEndian
)
;
let
debug_rnglists
=
DebugRngLists
:
:
new
(
&
buf
LittleEndian
)
;
let
rnglists
=
RangeLists
:
:
new
(
debug_ranges
debug_rnglists
)
;
let
offset
=
RangeListsOffset
(
(
&
first
-
&
start
)
as
usize
)
;
let
mut
ranges
=
rnglists
.
ranges
(
offset
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0101_0200
end
:
0x0101_0300
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0400
end
:
0x0201_0500
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0600
end
:
0x0201_0600
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0800
end
:
0x0201_0900
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0a00
end
:
0x0201_0b00
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0c00
end
:
0x0201_0d00
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0200_0000
end
:
0x0200_0001
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0200_0000
end
:
0x0200_0000
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0000_0000
end
:
0xffff_ffff
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0301_0100
end
:
0x0301_0200
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0301_0300
end
:
0x0301_0400
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0301_0500
end
:
0x0301_0600
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_1600
end
:
0x0201_1700
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
None
)
)
;
let
mut
ranges
=
rnglists
.
ranges
(
RangeListsOffset
(
buf
.
len
(
)
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
None
)
)
;
}
#
[
test
]
fn
test_rnglists_64
(
)
{
let
tombstone
=
!
0u64
;
let
encoding
=
Encoding
{
format
:
Format
:
:
Dwarf64
version
:
5
address_size
:
8
}
;
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
L64
(
0x0300_0000
)
.
L64
(
0x0301_0300
)
.
L64
(
0x0301_0400
)
.
L64
(
0x0301_0500
)
.
L64
(
tombstone
)
.
L64
(
0x0301_0600
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_addr
=
&
DebugAddr
:
:
from
(
EndianSlice
:
:
new
(
&
buf
LittleEndian
)
)
;
let
debug_addr_base
=
DebugAddrBase
(
0
)
;
let
start
=
Label
:
:
new
(
)
;
let
first
=
Label
:
:
new
(
)
;
let
size
=
Label
:
:
new
(
)
;
#
[
rustfmt
:
:
skip
]
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
mark
(
&
start
)
.
L32
(
0xffff_ffff
)
.
L64
(
&
size
)
.
L16
(
encoding
.
version
)
.
L8
(
encoding
.
address_size
)
.
L8
(
0
)
.
L32
(
0
)
.
mark
(
&
first
)
.
L8
(
4
)
.
uleb
(
0x10200
)
.
uleb
(
0x10300
)
.
L8
(
5
)
.
L64
(
0x0200_0000
)
.
L8
(
4
)
.
uleb
(
0x10400
)
.
uleb
(
0x10500
)
.
L8
(
4
)
.
uleb
(
0x10600
)
.
uleb
(
0x10600
)
.
L8
(
4
)
.
uleb
(
0x10800
)
.
uleb
(
0x10900
)
.
L8
(
6
)
.
L64
(
0x201_0a00
)
.
L64
(
0x201_0b00
)
.
L8
(
7
)
.
L64
(
0x201_0c00
)
.
uleb
(
0x100
)
.
L8
(
4
)
.
uleb
(
0
)
.
uleb
(
1
)
.
L8
(
4
)
.
uleb
(
0
)
.
uleb
(
0
)
.
L8
(
5
)
.
L64
(
0
)
.
L8
(
4
)
.
uleb
(
0
)
.
uleb
(
0xffff_ffff
)
.
L8
(
1
)
.
uleb
(
0
)
.
L8
(
4
)
.
uleb
(
0x10100
)
.
uleb
(
0x10200
)
.
L8
(
2
)
.
uleb
(
1
)
.
uleb
(
2
)
.
L8
(
3
)
.
uleb
(
3
)
.
uleb
(
0x100
)
.
L8
(
1
)
.
uleb
(
4
)
.
L8
(
4
)
.
uleb
(
0x11100
)
.
uleb
(
0x11200
)
.
L8
(
5
)
.
L64
(
tombstone
)
.
L8
(
4
)
.
uleb
(
0x11300
)
.
uleb
(
0x11400
)
.
L8
(
2
)
.
uleb
(
4
)
.
uleb
(
5
)
.
L8
(
3
)
.
uleb
(
4
)
.
uleb
(
0x100
)
.
L8
(
6
)
.
L64
(
tombstone
)
.
L64
(
0x201_1500
)
.
L8
(
7
)
.
L64
(
tombstone
)
.
uleb
(
0x100
)
.
L8
(
6
)
.
L64
(
0x201_1600
)
.
L64
(
0x201_1700
)
.
L8
(
0
)
.
L32
(
0xffff_ffff
)
;
size
.
set_const
(
(
&
section
.
here
(
)
-
&
start
-
12
)
as
u64
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_ranges
=
DebugRanges
:
:
new
(
&
[
]
LittleEndian
)
;
let
debug_rnglists
=
DebugRngLists
:
:
new
(
&
buf
LittleEndian
)
;
let
rnglists
=
RangeLists
:
:
new
(
debug_ranges
debug_rnglists
)
;
let
offset
=
RangeListsOffset
(
(
&
first
-
&
start
)
as
usize
)
;
let
mut
ranges
=
rnglists
.
ranges
(
offset
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0101_0200
end
:
0x0101_0300
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0400
end
:
0x0201_0500
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0600
end
:
0x0201_0600
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0800
end
:
0x0201_0900
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0a00
end
:
0x0201_0b00
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0c00
end
:
0x0201_0d00
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0200_0000
end
:
0x0200_0001
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0200_0000
end
:
0x0200_0000
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0000_0000
end
:
0xffff_ffff
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0301_0100
end
:
0x0301_0200
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0301_0300
end
:
0x0301_0400
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0301_0500
end
:
0x0301_0600
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_1600
end
:
0x0201_1700
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
None
)
)
;
let
mut
ranges
=
rnglists
.
ranges
(
RangeListsOffset
(
buf
.
len
(
)
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
None
)
)
;
}
#
[
test
]
fn
test_raw_range
(
)
{
let
range
=
RawRange
{
begin
:
0
end
:
0xffff_ffff
}
;
assert
!
(
!
range
.
is_end
(
)
)
;
assert
!
(
!
range
.
is_base_address
(
4
)
)
;
assert
!
(
!
range
.
is_base_address
(
8
)
)
;
let
range
=
RawRange
{
begin
:
0
end
:
0
}
;
assert
!
(
range
.
is_end
(
)
)
;
assert
!
(
!
range
.
is_base_address
(
4
)
)
;
assert
!
(
!
range
.
is_base_address
(
8
)
)
;
let
range
=
RawRange
{
begin
:
0xffff_ffff
end
:
0
}
;
assert
!
(
!
range
.
is_end
(
)
)
;
assert
!
(
range
.
is_base_address
(
4
)
)
;
assert
!
(
!
range
.
is_base_address
(
8
)
)
;
let
range
=
RawRange
{
begin
:
0xffff_ffff_ffff_ffff
end
:
0
}
;
assert
!
(
!
range
.
is_end
(
)
)
;
assert
!
(
!
range
.
is_base_address
(
4
)
)
;
assert
!
(
range
.
is_base_address
(
8
)
)
;
}
#
[
test
]
fn
test_ranges_32
(
)
{
let
tombstone
=
!
0u32
-
1
;
let
start
=
Label
:
:
new
(
)
;
let
first
=
Label
:
:
new
(
)
;
#
[
rustfmt
:
:
skip
]
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
mark
(
&
start
)
.
L32
(
0x10000
)
.
L32
(
0x10100
)
.
mark
(
&
first
)
.
L32
(
0x10200
)
.
L32
(
0x10300
)
.
L32
(
0xffff_ffff
)
.
L32
(
0x0200_0000
)
.
L32
(
0x10400
)
.
L32
(
0x10500
)
.
L32
(
0x10600
)
.
L32
(
0x10600
)
.
L32
(
0x10800
)
.
L32
(
0x10900
)
.
L32
(
0
)
.
L32
(
1
)
.
L32
(
0xffff_ffff
)
.
L32
(
0x0000_0000
)
.
L32
(
0
)
.
L32
(
0xffff_ffff
)
.
L32
(
tombstone
)
.
L32
(
tombstone
)
.
L32
(
0xffff_ffff
)
.
L32
(
tombstone
)
.
L32
(
0x10a00
)
.
L32
(
0x10b00
)
.
L32
(
0
)
.
L32
(
0
)
.
L32
(
0
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_ranges
=
DebugRanges
:
:
new
(
&
buf
LittleEndian
)
;
let
debug_rnglists
=
DebugRngLists
:
:
new
(
&
[
]
LittleEndian
)
;
let
rnglists
=
RangeLists
:
:
new
(
debug_ranges
debug_rnglists
)
;
let
offset
=
RangeListsOffset
(
(
&
first
-
&
start
)
as
usize
)
;
let
debug_addr
=
&
DebugAddr
:
:
from
(
EndianSlice
:
:
new
(
&
[
]
LittleEndian
)
)
;
let
debug_addr_base
=
DebugAddrBase
(
0
)
;
let
encoding
=
Encoding
{
format
:
Format
:
:
Dwarf32
version
:
4
address_size
:
4
}
;
let
mut
ranges
=
rnglists
.
ranges
(
offset
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0101_0200
end
:
0x0101_0300
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0400
end
:
0x0201_0500
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0600
end
:
0x0201_0600
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0800
end
:
0x0201_0900
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0200_0000
end
:
0x0200_0001
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0000_0000
end
:
0xffff_ffff
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
None
)
)
;
let
mut
ranges
=
rnglists
.
ranges
(
RangeListsOffset
(
buf
.
len
(
)
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
None
)
)
;
}
#
[
test
]
fn
test_ranges_64
(
)
{
let
tombstone
=
!
0u64
-
1
;
let
start
=
Label
:
:
new
(
)
;
let
first
=
Label
:
:
new
(
)
;
#
[
rustfmt
:
:
skip
]
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
mark
(
&
start
)
.
L64
(
0x10000
)
.
L64
(
0x10100
)
.
mark
(
&
first
)
.
L64
(
0x10200
)
.
L64
(
0x10300
)
.
L64
(
0xffff_ffff_ffff_ffff
)
.
L64
(
0x0200_0000
)
.
L64
(
0x10400
)
.
L64
(
0x10500
)
.
L64
(
0x10600
)
.
L64
(
0x10600
)
.
L64
(
0x10800
)
.
L64
(
0x10900
)
.
L64
(
0
)
.
L64
(
1
)
.
L64
(
0xffff_ffff_ffff_ffff
)
.
L64
(
0x0000_0000
)
.
L64
(
0
)
.
L64
(
0xffff_ffff_ffff_ffff
)
.
L64
(
tombstone
)
.
L64
(
tombstone
)
.
L64
(
0xffff_ffff_ffff_ffff
)
.
L64
(
tombstone
)
.
L64
(
0x10a00
)
.
L64
(
0x10b00
)
.
L64
(
0
)
.
L64
(
0
)
.
L64
(
0
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_ranges
=
DebugRanges
:
:
new
(
&
buf
LittleEndian
)
;
let
debug_rnglists
=
DebugRngLists
:
:
new
(
&
[
]
LittleEndian
)
;
let
rnglists
=
RangeLists
:
:
new
(
debug_ranges
debug_rnglists
)
;
let
offset
=
RangeListsOffset
(
(
&
first
-
&
start
)
as
usize
)
;
let
debug_addr
=
&
DebugAddr
:
:
from
(
EndianSlice
:
:
new
(
&
[
]
LittleEndian
)
)
;
let
debug_addr_base
=
DebugAddrBase
(
0
)
;
let
encoding
=
Encoding
{
format
:
Format
:
:
Dwarf64
version
:
4
address_size
:
8
}
;
let
mut
ranges
=
rnglists
.
ranges
(
offset
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0101_0200
end
:
0x0101_0300
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0400
end
:
0x0201_0500
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0600
end
:
0x0201_0600
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0201_0800
end
:
0x0201_0900
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0200_0000
end
:
0x0200_0001
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
Some
(
Range
{
begin
:
0x0
end
:
0xffff_ffff_ffff_ffff
}
)
)
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
None
)
)
;
let
mut
ranges
=
rnglists
.
ranges
(
RangeListsOffset
(
buf
.
len
(
)
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
None
)
)
;
}
#
[
test
]
fn
test_ranges_invalid
(
)
{
#
[
rustfmt
:
:
skip
]
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
L32
(
0x20000
)
.
L32
(
0x10000
)
.
L32
(
0x20000
)
.
L32
(
0xff01_0000
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_ranges
=
DebugRanges
:
:
new
(
&
buf
LittleEndian
)
;
let
debug_rnglists
=
DebugRngLists
:
:
new
(
&
[
]
LittleEndian
)
;
let
rnglists
=
RangeLists
:
:
new
(
debug_ranges
debug_rnglists
)
;
let
debug_addr
=
&
DebugAddr
:
:
from
(
EndianSlice
:
:
new
(
&
[
]
LittleEndian
)
)
;
let
debug_addr_base
=
DebugAddrBase
(
0
)
;
let
encoding
=
Encoding
{
format
:
Format
:
:
Dwarf32
version
:
4
address_size
:
4
}
;
let
mut
ranges
=
rnglists
.
ranges
(
RangeListsOffset
(
0x0
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
None
)
)
;
let
mut
ranges
=
rnglists
.
ranges
(
RangeListsOffset
(
0x8
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
ranges
.
next
(
)
Ok
(
None
)
)
;
match
rnglists
.
ranges
(
RangeListsOffset
(
buf
.
len
(
)
+
1
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
{
Err
(
Error
:
:
UnexpectedEof
(
_
)
)
=
>
{
}
otherwise
=
>
panic
!
(
"
Unexpected
result
:
{
:
?
}
"
otherwise
)
}
}
#
[
test
]
fn
test_get_offset
(
)
{
for
format
in
[
Format
:
:
Dwarf32
Format
:
:
Dwarf64
]
{
let
encoding
=
Encoding
{
format
version
:
5
address_size
:
4
}
;
let
zero
=
Label
:
:
new
(
)
;
let
length
=
Label
:
:
new
(
)
;
let
start
=
Label
:
:
new
(
)
;
let
first
=
Label
:
:
new
(
)
;
let
end
=
Label
:
:
new
(
)
;
let
mut
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
mark
(
&
zero
)
.
initial_length
(
format
&
length
&
start
)
.
D16
(
encoding
.
version
)
.
D8
(
encoding
.
address_size
)
.
D8
(
0
)
.
D32
(
20
)
.
mark
(
&
first
)
;
for
i
in
0
.
.
20
{
section
=
section
.
word
(
format
.
word_size
(
)
1000
+
i
)
;
}
section
=
section
.
mark
(
&
end
)
;
length
.
set_const
(
(
&
end
-
&
start
)
as
u64
)
;
let
section
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_ranges
=
DebugRanges
:
:
from
(
EndianSlice
:
:
new
(
&
[
]
LittleEndian
)
)
;
let
debug_rnglists
=
DebugRngLists
:
:
from
(
EndianSlice
:
:
new
(
&
section
LittleEndian
)
)
;
let
ranges
=
RangeLists
:
:
new
(
debug_ranges
debug_rnglists
)
;
let
base
=
DebugRngListsBase
(
(
&
first
-
&
zero
)
as
usize
)
;
assert_eq
!
(
ranges
.
get_offset
(
encoding
base
DebugRngListsIndex
(
0
)
)
Ok
(
RangeListsOffset
(
base
.
0
+
1000
)
)
)
;
assert_eq
!
(
ranges
.
get_offset
(
encoding
base
DebugRngListsIndex
(
19
)
)
Ok
(
RangeListsOffset
(
base
.
0
+
1019
)
)
)
;
}
}
}
