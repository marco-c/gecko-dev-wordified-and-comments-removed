use
core
:
:
marker
:
:
PhantomData
;
use
crate
:
:
common
:
:
{
DebugInfoOffset
Format
}
;
use
crate
:
:
read
:
:
{
parse_debug_info_offset
Error
Reader
ReaderOffset
Result
UnitOffset
}
;
pub
trait
LookupParser
<
R
:
Reader
>
{
type
Header
;
type
Entry
;
fn
parse_header
(
input
:
&
mut
R
)
-
>
Result
<
(
R
Self
:
:
Header
)
>
;
fn
parse_entry
(
input
:
&
mut
R
header
:
&
Self
:
:
Header
)
-
>
Result
<
Option
<
Self
:
:
Entry
>
>
;
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
DebugLookup
<
R
Parser
>
where
R
:
Reader
Parser
:
LookupParser
<
R
>
{
input_buffer
:
R
phantom
:
PhantomData
<
Parser
>
}
impl
<
R
Parser
>
From
<
R
>
for
DebugLookup
<
R
Parser
>
where
R
:
Reader
Parser
:
LookupParser
<
R
>
{
fn
from
(
input_buffer
:
R
)
-
>
Self
{
DebugLookup
{
input_buffer
phantom
:
PhantomData
}
}
}
impl
<
R
Parser
>
DebugLookup
<
R
Parser
>
where
R
:
Reader
Parser
:
LookupParser
<
R
>
{
pub
fn
items
(
&
self
)
-
>
LookupEntryIter
<
R
Parser
>
{
LookupEntryIter
{
current_set
:
None
remaining_input
:
self
.
input_buffer
.
clone
(
)
}
}
pub
fn
reader
(
&
self
)
-
>
&
R
{
&
self
.
input_buffer
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
LookupEntryIter
<
R
Parser
>
where
R
:
Reader
Parser
:
LookupParser
<
R
>
{
current_set
:
Option
<
(
R
Parser
:
:
Header
)
>
remaining_input
:
R
}
impl
<
R
Parser
>
LookupEntryIter
<
R
Parser
>
where
R
:
Reader
Parser
:
LookupParser
<
R
>
{
pub
fn
next
(
&
mut
self
)
-
>
Result
<
Option
<
Parser
:
:
Entry
>
>
{
loop
{
if
let
Some
(
(
ref
mut
input
ref
header
)
)
=
self
.
current_set
{
if
!
input
.
is_empty
(
)
{
match
Parser
:
:
parse_entry
(
input
header
)
{
Ok
(
Some
(
entry
)
)
=
>
return
Ok
(
Some
(
entry
)
)
Ok
(
None
)
=
>
{
}
Err
(
e
)
=
>
{
input
.
empty
(
)
;
self
.
remaining_input
.
empty
(
)
;
return
Err
(
e
)
;
}
}
}
}
if
self
.
remaining_input
.
is_empty
(
)
{
self
.
current_set
=
None
;
return
Ok
(
None
)
;
}
match
Parser
:
:
parse_header
(
&
mut
self
.
remaining_input
)
{
Ok
(
set
)
=
>
{
self
.
current_set
=
Some
(
set
)
;
}
Err
(
e
)
=
>
{
self
.
current_set
=
None
;
self
.
remaining_input
.
empty
(
)
;
return
Err
(
e
)
;
}
}
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
pub
struct
PubStuffHeader
<
T
=
usize
>
{
format
:
Format
length
:
T
version
:
u16
unit_offset
:
DebugInfoOffset
<
T
>
unit_length
:
T
}
pub
trait
PubStuffEntry
<
R
:
Reader
>
{
fn
new
(
die_offset
:
UnitOffset
<
R
:
:
Offset
>
name
:
R
unit_header_offset
:
DebugInfoOffset
<
R
:
:
Offset
>
)
-
>
Self
;
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
PubStuffParser
<
R
Entry
>
where
R
:
Reader
Entry
:
PubStuffEntry
<
R
>
{
phantom
:
PhantomData
<
(
R
Entry
)
>
}
impl
<
R
Entry
>
LookupParser
<
R
>
for
PubStuffParser
<
R
Entry
>
where
R
:
Reader
Entry
:
PubStuffEntry
<
R
>
{
type
Header
=
PubStuffHeader
<
R
:
:
Offset
>
;
type
Entry
=
Entry
;
fn
parse_header
(
input
:
&
mut
R
)
-
>
Result
<
(
R
Self
:
:
Header
)
>
{
let
(
length
format
)
=
input
.
read_initial_length
(
)
?
;
let
mut
rest
=
input
.
split
(
length
)
?
;
let
version
=
rest
.
read_u16
(
)
?
;
if
version
!
=
2
{
return
Err
(
Error
:
:
UnknownVersion
(
u64
:
:
from
(
version
)
)
)
;
}
let
unit_offset
=
parse_debug_info_offset
(
&
mut
rest
format
)
?
;
let
unit_length
=
rest
.
read_length
(
format
)
?
;
let
header
=
PubStuffHeader
{
format
length
version
unit_offset
unit_length
}
;
Ok
(
(
rest
header
)
)
}
fn
parse_entry
(
input
:
&
mut
R
header
:
&
Self
:
:
Header
)
-
>
Result
<
Option
<
Self
:
:
Entry
>
>
{
let
offset
=
input
.
read_offset
(
header
.
format
)
?
;
if
offset
.
into_u64
(
)
=
=
0
{
input
.
empty
(
)
;
Ok
(
None
)
}
else
{
let
name
=
input
.
read_null_terminated_slice
(
)
?
;
Ok
(
Some
(
Self
:
:
Entry
:
:
new
(
UnitOffset
(
offset
)
name
header
.
unit_offset
)
)
)
}
}
}
