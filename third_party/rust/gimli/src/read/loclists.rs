use
crate
:
:
common
:
:
{
DebugAddrBase
DebugAddrIndex
DebugLocListsBase
DebugLocListsIndex
DwarfFileType
Encoding
LocationListsOffset
SectionId
}
;
use
crate
:
:
constants
;
use
crate
:
:
endianity
:
:
Endianity
;
use
crate
:
:
read
:
:
{
lists
:
:
ListsHeader
DebugAddr
EndianSlice
Error
Expression
Range
RawRange
Reader
ReaderAddress
ReaderOffset
ReaderOffsetId
Result
Section
}
;
#
[
derive
(
Debug
Default
Clone
Copy
)
]
pub
struct
DebugLoc
<
R
>
{
pub
(
crate
)
section
:
R
}
impl
<
'
input
Endian
>
DebugLoc
<
EndianSlice
<
'
input
Endian
>
>
where
Endian
:
Endianity
{
pub
fn
new
(
section
:
&
'
input
[
u8
]
endian
:
Endian
)
-
>
Self
{
Self
:
:
from
(
EndianSlice
:
:
new
(
section
endian
)
)
}
}
impl
<
T
>
DebugLoc
<
T
>
{
pub
(
crate
)
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
)
-
>
DebugLoc
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
borrow
(
&
self
.
section
)
.
into
(
)
}
}
impl
<
R
>
Section
<
R
>
for
DebugLoc
<
R
>
{
fn
id
(
)
-
>
SectionId
{
SectionId
:
:
DebugLoc
}
fn
reader
(
&
self
)
-
>
&
R
{
&
self
.
section
}
}
impl
<
R
>
From
<
R
>
for
DebugLoc
<
R
>
{
fn
from
(
section
:
R
)
-
>
Self
{
DebugLoc
{
section
}
}
}
#
[
derive
(
Debug
Default
Clone
Copy
)
]
pub
struct
DebugLocLists
<
R
>
{
section
:
R
}
impl
<
'
input
Endian
>
DebugLocLists
<
EndianSlice
<
'
input
Endian
>
>
where
Endian
:
Endianity
{
pub
fn
new
(
section
:
&
'
input
[
u8
]
endian
:
Endian
)
-
>
Self
{
Self
:
:
from
(
EndianSlice
:
:
new
(
section
endian
)
)
}
}
impl
<
T
>
DebugLocLists
<
T
>
{
pub
(
crate
)
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
)
-
>
DebugLocLists
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
borrow
(
&
self
.
section
)
.
into
(
)
}
}
impl
<
R
>
Section
<
R
>
for
DebugLocLists
<
R
>
{
fn
id
(
)
-
>
SectionId
{
SectionId
:
:
DebugLocLists
}
fn
reader
(
&
self
)
-
>
&
R
{
&
self
.
section
}
}
impl
<
R
>
From
<
R
>
for
DebugLocLists
<
R
>
{
fn
from
(
section
:
R
)
-
>
Self
{
DebugLocLists
{
section
}
}
}
pub
(
crate
)
type
LocListsHeader
=
ListsHeader
;
impl
<
Offset
>
DebugLocListsBase
<
Offset
>
where
Offset
:
ReaderOffset
{
pub
fn
default_for_encoding_and_file
(
encoding
:
Encoding
file_type
:
DwarfFileType
)
-
>
DebugLocListsBase
<
Offset
>
{
if
encoding
.
version
>
=
5
&
&
file_type
=
=
DwarfFileType
:
:
Dwo
{
DebugLocListsBase
(
Offset
:
:
from_u8
(
LocListsHeader
:
:
size_for_encoding
(
encoding
)
)
)
}
else
{
DebugLocListsBase
(
Offset
:
:
from_u8
(
0
)
)
}
}
}
#
[
derive
(
Debug
Default
Clone
Copy
)
]
pub
struct
LocationLists
<
R
>
{
debug_loc
:
DebugLoc
<
R
>
debug_loclists
:
DebugLocLists
<
R
>
}
impl
<
R
>
LocationLists
<
R
>
{
pub
fn
new
(
debug_loc
:
DebugLoc
<
R
>
debug_loclists
:
DebugLocLists
<
R
>
)
-
>
LocationLists
<
R
>
{
LocationLists
{
debug_loc
debug_loclists
}
}
}
impl
<
T
>
LocationLists
<
T
>
{
pub
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
)
-
>
LocationLists
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
LocationLists
{
debug_loc
:
borrow
(
&
self
.
debug_loc
.
section
)
.
into
(
)
debug_loclists
:
borrow
(
&
self
.
debug_loclists
.
section
)
.
into
(
)
}
}
}
impl
<
R
:
Reader
>
LocationLists
<
R
>
{
pub
fn
locations
(
&
self
offset
:
LocationListsOffset
<
R
:
:
Offset
>
unit_encoding
:
Encoding
base_address
:
u64
debug_addr
:
&
DebugAddr
<
R
>
debug_addr_base
:
DebugAddrBase
<
R
:
:
Offset
>
)
-
>
Result
<
LocListIter
<
R
>
>
{
Ok
(
LocListIter
:
:
new
(
self
.
raw_locations
(
offset
unit_encoding
)
?
base_address
debug_addr
.
clone
(
)
debug_addr_base
)
)
}
pub
fn
locations_dwo
(
&
self
offset
:
LocationListsOffset
<
R
:
:
Offset
>
unit_encoding
:
Encoding
base_address
:
u64
debug_addr
:
&
DebugAddr
<
R
>
debug_addr_base
:
DebugAddrBase
<
R
:
:
Offset
>
)
-
>
Result
<
LocListIter
<
R
>
>
{
Ok
(
LocListIter
:
:
new
(
self
.
raw_locations_dwo
(
offset
unit_encoding
)
?
base_address
debug_addr
.
clone
(
)
debug_addr_base
)
)
}
pub
fn
raw_locations
(
&
self
offset
:
LocationListsOffset
<
R
:
:
Offset
>
unit_encoding
:
Encoding
)
-
>
Result
<
RawLocListIter
<
R
>
>
{
let
(
mut
input
format
)
=
if
unit_encoding
.
version
<
=
4
{
(
self
.
debug_loc
.
section
.
clone
(
)
LocListsFormat
:
:
Bare
)
}
else
{
(
self
.
debug_loclists
.
section
.
clone
(
)
LocListsFormat
:
:
Lle
)
}
;
input
.
skip
(
offset
.
0
)
?
;
Ok
(
RawLocListIter
:
:
new
(
input
unit_encoding
format
)
)
}
pub
fn
raw_locations_dwo
(
&
self
offset
:
LocationListsOffset
<
R
:
:
Offset
>
unit_encoding
:
Encoding
)
-
>
Result
<
RawLocListIter
<
R
>
>
{
let
mut
input
=
if
unit_encoding
.
version
<
=
4
{
self
.
debug_loc
.
section
.
clone
(
)
}
else
{
self
.
debug_loclists
.
section
.
clone
(
)
}
;
input
.
skip
(
offset
.
0
)
?
;
Ok
(
RawLocListIter
:
:
new
(
input
unit_encoding
LocListsFormat
:
:
Lle
)
)
}
pub
fn
get_offset
(
&
self
unit_encoding
:
Encoding
base
:
DebugLocListsBase
<
R
:
:
Offset
>
index
:
DebugLocListsIndex
<
R
:
:
Offset
>
)
-
>
Result
<
LocationListsOffset
<
R
:
:
Offset
>
>
{
let
format
=
unit_encoding
.
format
;
let
input
=
&
mut
self
.
debug_loclists
.
section
.
clone
(
)
;
input
.
skip
(
base
.
0
)
?
;
input
.
skip
(
R
:
:
Offset
:
:
from_u64
(
index
.
0
.
into_u64
(
)
*
u64
:
:
from
(
format
.
word_size
(
)
)
)
?
)
?
;
input
.
read_offset
(
format
)
.
map
(
|
x
|
LocationListsOffset
(
base
.
0
+
x
)
)
}
pub
fn
lookup_offset_id
(
&
self
id
:
ReaderOffsetId
)
-
>
Option
<
(
SectionId
R
:
:
Offset
)
>
{
self
.
debug_loc
.
lookup_offset_id
(
id
)
.
or_else
(
|
|
self
.
debug_loclists
.
lookup_offset_id
(
id
)
)
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
enum
LocListsFormat
{
Bare
Lle
}
#
[
derive
(
Debug
)
]
pub
struct
RawLocListIter
<
R
:
Reader
>
{
input
:
R
encoding
:
Encoding
format
:
LocListsFormat
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
RawLocListEntry
<
R
:
Reader
>
{
AddressOrOffsetPair
{
begin
:
u64
end
:
u64
data
:
Expression
<
R
>
}
BaseAddress
{
addr
:
u64
}
BaseAddressx
{
addr
:
DebugAddrIndex
<
R
:
:
Offset
>
}
StartxEndx
{
begin
:
DebugAddrIndex
<
R
:
:
Offset
>
end
:
DebugAddrIndex
<
R
:
:
Offset
>
data
:
Expression
<
R
>
}
StartxLength
{
begin
:
DebugAddrIndex
<
R
:
:
Offset
>
length
:
u64
data
:
Expression
<
R
>
}
OffsetPair
{
begin
:
u64
end
:
u64
data
:
Expression
<
R
>
}
DefaultLocation
{
data
:
Expression
<
R
>
}
StartEnd
{
begin
:
u64
end
:
u64
data
:
Expression
<
R
>
}
StartLength
{
begin
:
u64
length
:
u64
data
:
Expression
<
R
>
}
}
fn
parse_data
<
R
:
Reader
>
(
input
:
&
mut
R
encoding
:
Encoding
)
-
>
Result
<
Expression
<
R
>
>
{
if
encoding
.
version
>
=
5
{
let
len
=
R
:
:
Offset
:
:
from_u64
(
input
.
read_uleb128
(
)
?
)
?
;
Ok
(
Expression
(
input
.
split
(
len
)
?
)
)
}
else
{
let
len
=
R
:
:
Offset
:
:
from_u16
(
input
.
read_u16
(
)
?
)
;
Ok
(
Expression
(
input
.
split
(
len
)
?
)
)
}
}
impl
<
R
:
Reader
>
RawLocListEntry
<
R
>
{
fn
parse
(
input
:
&
mut
R
encoding
:
Encoding
format
:
LocListsFormat
)
-
>
Result
<
Option
<
Self
>
>
{
Ok
(
match
format
{
LocListsFormat
:
:
Bare
=
>
{
let
range
=
RawRange
:
:
parse
(
input
encoding
.
address_size
)
?
;
if
range
.
is_end
(
)
{
None
}
else
if
range
.
is_base_address
(
encoding
.
address_size
)
{
Some
(
RawLocListEntry
:
:
BaseAddress
{
addr
:
range
.
end
}
)
}
else
{
let
len
=
R
:
:
Offset
:
:
from_u16
(
input
.
read_u16
(
)
?
)
;
let
data
=
Expression
(
input
.
split
(
len
)
?
)
;
Some
(
RawLocListEntry
:
:
AddressOrOffsetPair
{
begin
:
range
.
begin
end
:
range
.
end
data
}
)
}
}
LocListsFormat
:
:
Lle
=
>
match
constants
:
:
DwLle
(
input
.
read_u8
(
)
?
)
{
constants
:
:
DW_LLE_end_of_list
=
>
None
constants
:
:
DW_LLE_base_addressx
=
>
Some
(
RawLocListEntry
:
:
BaseAddressx
{
addr
:
DebugAddrIndex
(
input
.
read_uleb128
(
)
.
and_then
(
R
:
:
Offset
:
:
from_u64
)
?
)
}
)
constants
:
:
DW_LLE_startx_endx
=
>
Some
(
RawLocListEntry
:
:
StartxEndx
{
begin
:
DebugAddrIndex
(
input
.
read_uleb128
(
)
.
and_then
(
R
:
:
Offset
:
:
from_u64
)
?
)
end
:
DebugAddrIndex
(
input
.
read_uleb128
(
)
.
and_then
(
R
:
:
Offset
:
:
from_u64
)
?
)
data
:
parse_data
(
input
encoding
)
?
}
)
constants
:
:
DW_LLE_startx_length
=
>
Some
(
RawLocListEntry
:
:
StartxLength
{
begin
:
DebugAddrIndex
(
input
.
read_uleb128
(
)
.
and_then
(
R
:
:
Offset
:
:
from_u64
)
?
)
length
:
if
encoding
.
version
>
=
5
{
input
.
read_uleb128
(
)
?
}
else
{
input
.
read_u32
(
)
?
as
u64
}
data
:
parse_data
(
input
encoding
)
?
}
)
constants
:
:
DW_LLE_offset_pair
=
>
Some
(
RawLocListEntry
:
:
OffsetPair
{
begin
:
input
.
read_uleb128
(
)
?
end
:
input
.
read_uleb128
(
)
?
data
:
parse_data
(
input
encoding
)
?
}
)
constants
:
:
DW_LLE_default_location
=
>
Some
(
RawLocListEntry
:
:
DefaultLocation
{
data
:
parse_data
(
input
encoding
)
?
}
)
constants
:
:
DW_LLE_base_address
=
>
Some
(
RawLocListEntry
:
:
BaseAddress
{
addr
:
input
.
read_address
(
encoding
.
address_size
)
?
}
)
constants
:
:
DW_LLE_start_end
=
>
Some
(
RawLocListEntry
:
:
StartEnd
{
begin
:
input
.
read_address
(
encoding
.
address_size
)
?
end
:
input
.
read_address
(
encoding
.
address_size
)
?
data
:
parse_data
(
input
encoding
)
?
}
)
constants
:
:
DW_LLE_start_length
=
>
Some
(
RawLocListEntry
:
:
StartLength
{
begin
:
input
.
read_address
(
encoding
.
address_size
)
?
length
:
input
.
read_uleb128
(
)
?
data
:
parse_data
(
input
encoding
)
?
}
)
entry
=
>
{
return
Err
(
Error
:
:
UnknownLocListsEntry
(
entry
)
)
;
}
}
}
)
}
}
impl
<
R
:
Reader
>
RawLocListIter
<
R
>
{
fn
new
(
input
:
R
encoding
:
Encoding
format
:
LocListsFormat
)
-
>
RawLocListIter
<
R
>
{
RawLocListIter
{
input
encoding
format
}
}
pub
fn
next
(
&
mut
self
)
-
>
Result
<
Option
<
RawLocListEntry
<
R
>
>
>
{
if
self
.
input
.
is_empty
(
)
{
return
Ok
(
None
)
;
}
match
RawLocListEntry
:
:
parse
(
&
mut
self
.
input
self
.
encoding
self
.
format
)
{
Ok
(
entry
)
=
>
{
if
entry
.
is_none
(
)
{
self
.
input
.
empty
(
)
;
}
Ok
(
entry
)
}
Err
(
e
)
=
>
{
self
.
input
.
empty
(
)
;
Err
(
e
)
}
}
}
}
#
[
cfg
(
feature
=
"
fallible
-
iterator
"
)
]
impl
<
R
:
Reader
>
fallible_iterator
:
:
FallibleIterator
for
RawLocListIter
<
R
>
{
type
Item
=
RawLocListEntry
<
R
>
;
type
Error
=
Error
;
fn
next
(
&
mut
self
)
-
>
:
:
core
:
:
result
:
:
Result
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
{
RawLocListIter
:
:
next
(
self
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
LocListIter
<
R
:
Reader
>
{
raw
:
RawLocListIter
<
R
>
base_address
:
u64
debug_addr
:
DebugAddr
<
R
>
debug_addr_base
:
DebugAddrBase
<
R
:
:
Offset
>
}
impl
<
R
:
Reader
>
LocListIter
<
R
>
{
fn
new
(
raw
:
RawLocListIter
<
R
>
base_address
:
u64
debug_addr
:
DebugAddr
<
R
>
debug_addr_base
:
DebugAddrBase
<
R
:
:
Offset
>
)
-
>
LocListIter
<
R
>
{
LocListIter
{
raw
base_address
debug_addr
debug_addr_base
}
}
#
[
inline
]
fn
get_address
(
&
self
index
:
DebugAddrIndex
<
R
:
:
Offset
>
)
-
>
Result
<
u64
>
{
self
.
debug_addr
.
get_address
(
self
.
raw
.
encoding
.
address_size
self
.
debug_addr_base
index
)
}
pub
fn
next
(
&
mut
self
)
-
>
Result
<
Option
<
LocationListEntry
<
R
>
>
>
{
loop
{
let
raw_loc
=
match
self
.
raw
.
next
(
)
?
{
Some
(
loc
)
=
>
loc
None
=
>
return
Ok
(
None
)
}
;
let
loc
=
self
.
convert_raw
(
raw_loc
)
?
;
if
loc
.
is_some
(
)
{
return
Ok
(
loc
)
;
}
}
}
#
[
doc
(
hidden
)
]
pub
fn
next_raw
(
&
mut
self
)
-
>
Result
<
Option
<
RawLocListEntry
<
R
>
>
>
{
self
.
raw
.
next
(
)
}
#
[
doc
(
hidden
)
]
pub
fn
convert_raw
(
&
mut
self
raw_loc
:
RawLocListEntry
<
R
>
)
-
>
Result
<
Option
<
LocationListEntry
<
R
>
>
>
{
let
address_size
=
self
.
raw
.
encoding
.
address_size
;
let
mask
=
u64
:
:
ones_sized
(
address_size
)
;
let
tombstone
=
if
self
.
raw
.
encoding
.
version
<
=
4
{
mask
-
1
}
else
{
mask
}
;
let
(
range
data
)
=
match
raw_loc
{
RawLocListEntry
:
:
BaseAddress
{
addr
}
=
>
{
self
.
base_address
=
addr
;
return
Ok
(
None
)
;
}
RawLocListEntry
:
:
BaseAddressx
{
addr
}
=
>
{
self
.
base_address
=
self
.
get_address
(
addr
)
?
;
return
Ok
(
None
)
;
}
RawLocListEntry
:
:
StartxEndx
{
begin
end
data
}
=
>
{
let
begin
=
self
.
get_address
(
begin
)
?
;
let
end
=
self
.
get_address
(
end
)
?
;
(
Range
{
begin
end
}
data
)
}
RawLocListEntry
:
:
StartxLength
{
begin
length
data
}
=
>
{
let
begin
=
self
.
get_address
(
begin
)
?
;
let
end
=
begin
.
wrapping_add_sized
(
length
address_size
)
;
(
Range
{
begin
end
}
data
)
}
RawLocListEntry
:
:
DefaultLocation
{
data
}
=
>
(
Range
{
begin
:
0
end
:
u64
:
:
MAX
}
data
)
RawLocListEntry
:
:
AddressOrOffsetPair
{
begin
end
data
}
|
RawLocListEntry
:
:
OffsetPair
{
begin
end
data
}
=
>
{
if
self
.
base_address
=
=
tombstone
{
return
Ok
(
None
)
;
}
let
mut
range
=
Range
{
begin
end
}
;
range
.
add_base_address
(
self
.
base_address
self
.
raw
.
encoding
.
address_size
)
;
(
range
data
)
}
RawLocListEntry
:
:
StartEnd
{
begin
end
data
}
=
>
(
Range
{
begin
end
}
data
)
RawLocListEntry
:
:
StartLength
{
begin
length
data
}
=
>
{
let
end
=
begin
.
wrapping_add_sized
(
length
address_size
)
;
(
Range
{
begin
end
}
data
)
}
}
;
if
range
.
begin
=
=
tombstone
|
|
range
.
begin
>
range
.
end
{
return
Ok
(
None
)
;
}
Ok
(
Some
(
LocationListEntry
{
range
data
}
)
)
}
}
#
[
cfg
(
feature
=
"
fallible
-
iterator
"
)
]
impl
<
R
:
Reader
>
fallible_iterator
:
:
FallibleIterator
for
LocListIter
<
R
>
{
type
Item
=
LocationListEntry
<
R
>
;
type
Error
=
Error
;
fn
next
(
&
mut
self
)
-
>
:
:
core
:
:
result
:
:
Result
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
{
LocListIter
:
:
next
(
self
)
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
pub
struct
LocationListEntry
<
R
:
Reader
>
{
pub
range
:
Range
pub
data
:
Expression
<
R
>
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
common
:
:
Format
;
use
crate
:
:
endianity
:
:
LittleEndian
;
use
crate
:
:
read
:
:
{
EndianSlice
Range
}
;
use
crate
:
:
test_util
:
:
GimliSectionMethods
;
use
test_assembler
:
:
{
Endian
Label
LabelMaker
Section
}
;
#
[
test
]
fn
test_loclists_32
(
)
{
let
tombstone
=
!
0u32
;
let
encoding
=
Encoding
{
format
:
Format
:
:
Dwarf32
version
:
5
address_size
:
4
}
;
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
L32
(
0x0300_0000
)
.
L32
(
0x0301_0300
)
.
L32
(
0x0301_0400
)
.
L32
(
0x0301_0500
)
.
L32
(
tombstone
)
.
L32
(
0x0301_0600
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_addr
=
&
DebugAddr
:
:
from
(
EndianSlice
:
:
new
(
&
buf
LittleEndian
)
)
;
let
debug_addr_base
=
DebugAddrBase
(
0
)
;
let
start
=
Label
:
:
new
(
)
;
let
first
=
Label
:
:
new
(
)
;
let
size
=
Label
:
:
new
(
)
;
#
[
rustfmt
:
:
skip
]
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
mark
(
&
start
)
.
L32
(
&
size
)
.
L16
(
encoding
.
version
)
.
L8
(
encoding
.
address_size
)
.
L8
(
0
)
.
L32
(
0
)
.
mark
(
&
first
)
.
L8
(
4
)
.
uleb
(
0x10200
)
.
uleb
(
0x10300
)
.
uleb
(
4
)
.
L32
(
2
)
.
L8
(
6
)
.
L32
(
0x0200_0000
)
.
L8
(
4
)
.
uleb
(
0x10400
)
.
uleb
(
0x10500
)
.
uleb
(
4
)
.
L32
(
3
)
.
L8
(
4
)
.
uleb
(
0x10600
)
.
uleb
(
0x10600
)
.
uleb
(
4
)
.
L32
(
4
)
.
L8
(
4
)
.
uleb
(
0x10800
)
.
uleb
(
0x10900
)
.
uleb
(
4
)
.
L32
(
5
)
.
L8
(
7
)
.
L32
(
0x201_0a00
)
.
L32
(
0x201_0b00
)
.
uleb
(
4
)
.
L32
(
6
)
.
L8
(
8
)
.
L32
(
0x201_0c00
)
.
uleb
(
0x100
)
.
uleb
(
4
)
.
L32
(
7
)
.
L8
(
4
)
.
uleb
(
0
)
.
uleb
(
1
)
.
uleb
(
4
)
.
L32
(
8
)
.
L8
(
6
)
.
L32
(
0
)
.
L8
(
4
)
.
uleb
(
0
)
.
uleb
(
0xffff_ffff
)
.
uleb
(
4
)
.
L32
(
9
)
.
L8
(
5
)
.
uleb
(
4
)
.
L32
(
10
)
.
L8
(
1
)
.
uleb
(
0
)
.
L8
(
4
)
.
uleb
(
0x10100
)
.
uleb
(
0x10200
)
.
uleb
(
4
)
.
L32
(
11
)
.
L8
(
2
)
.
uleb
(
1
)
.
uleb
(
2
)
.
uleb
(
4
)
.
L32
(
12
)
.
L8
(
3
)
.
uleb
(
3
)
.
uleb
(
0x100
)
.
uleb
(
4
)
.
L32
(
13
)
.
L8
(
1
)
.
uleb
(
4
)
.
L8
(
4
)
.
uleb
(
0x11100
)
.
uleb
(
0x11200
)
.
uleb
(
4
)
.
L32
(
20
)
.
L8
(
6
)
.
L32
(
tombstone
)
.
L8
(
4
)
.
uleb
(
0x11300
)
.
uleb
(
0x11400
)
.
uleb
(
4
)
.
L32
(
21
)
.
L8
(
2
)
.
uleb
(
4
)
.
uleb
(
5
)
.
uleb
(
4
)
.
L32
(
22
)
.
L8
(
3
)
.
uleb
(
4
)
.
uleb
(
0x100
)
.
uleb
(
4
)
.
L32
(
23
)
.
L8
(
7
)
.
L32
(
tombstone
)
.
L32
(
0x201_1500
)
.
uleb
(
4
)
.
L32
(
24
)
.
L8
(
8
)
.
L32
(
tombstone
)
.
uleb
(
0x100
)
.
uleb
(
4
)
.
L32
(
25
)
.
L8
(
7
)
.
L32
(
0x201_1600
)
.
L32
(
0x201_1700
)
.
uleb
(
4
)
.
L32
(
26
)
.
L8
(
0
)
.
L32
(
0xffff_ffff
)
;
size
.
set_const
(
(
&
section
.
here
(
)
-
&
start
-
4
)
as
u64
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_loc
=
DebugLoc
:
:
new
(
&
[
]
LittleEndian
)
;
let
debug_loclists
=
DebugLocLists
:
:
new
(
&
buf
LittleEndian
)
;
let
loclists
=
LocationLists
:
:
new
(
debug_loc
debug_loclists
)
;
let
offset
=
LocationListsOffset
(
(
&
first
-
&
start
)
as
usize
)
;
let
mut
locations
=
loclists
.
locations
(
offset
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0101_0200
end
:
0x0101_0300
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
2
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0400
end
:
0x0201_0500
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
3
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0600
end
:
0x0201_0600
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
4
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0800
end
:
0x0201_0900
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
5
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0a00
end
:
0x0201_0b00
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
6
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0c00
end
:
0x0201_0d00
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
7
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0200_0000
end
:
0x0200_0001
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
8
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0000_0000
end
:
0xffff_ffff
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
9
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0
end
:
u64
:
:
MAX
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
10
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0301_0100
end
:
0x0301_0200
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
11
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0301_0300
end
:
0x0301_0400
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
12
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0301_0500
end
:
0x0301_0600
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
13
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_1600
end
:
0x0201_1700
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
26
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
None
)
)
;
let
mut
locations
=
loclists
.
locations
(
LocationListsOffset
(
buf
.
len
(
)
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
None
)
)
;
}
#
[
test
]
fn
test_loclists_64
(
)
{
let
tombstone
=
!
0u64
;
let
encoding
=
Encoding
{
format
:
Format
:
:
Dwarf64
version
:
5
address_size
:
8
}
;
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
L64
(
0x0300_0000
)
.
L64
(
0x0301_0300
)
.
L64
(
0x0301_0400
)
.
L64
(
0x0301_0500
)
.
L64
(
tombstone
)
.
L64
(
0x0301_0600
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_addr
=
&
DebugAddr
:
:
from
(
EndianSlice
:
:
new
(
&
buf
LittleEndian
)
)
;
let
debug_addr_base
=
DebugAddrBase
(
0
)
;
let
start
=
Label
:
:
new
(
)
;
let
first
=
Label
:
:
new
(
)
;
let
size
=
Label
:
:
new
(
)
;
#
[
rustfmt
:
:
skip
]
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
mark
(
&
start
)
.
L32
(
0xffff_ffff
)
.
L64
(
&
size
)
.
L16
(
encoding
.
version
)
.
L8
(
encoding
.
address_size
)
.
L8
(
0
)
.
L32
(
0
)
.
mark
(
&
first
)
.
L8
(
4
)
.
uleb
(
0x10200
)
.
uleb
(
0x10300
)
.
uleb
(
4
)
.
L32
(
2
)
.
L8
(
6
)
.
L64
(
0x0200_0000
)
.
L8
(
4
)
.
uleb
(
0x10400
)
.
uleb
(
0x10500
)
.
uleb
(
4
)
.
L32
(
3
)
.
L8
(
4
)
.
uleb
(
0x10600
)
.
uleb
(
0x10600
)
.
uleb
(
4
)
.
L32
(
4
)
.
L8
(
4
)
.
uleb
(
0x10800
)
.
uleb
(
0x10900
)
.
uleb
(
4
)
.
L32
(
5
)
.
L8
(
7
)
.
L64
(
0x201_0a00
)
.
L64
(
0x201_0b00
)
.
uleb
(
4
)
.
L32
(
6
)
.
L8
(
8
)
.
L64
(
0x201_0c00
)
.
uleb
(
0x100
)
.
uleb
(
4
)
.
L32
(
7
)
.
L8
(
4
)
.
uleb
(
0
)
.
uleb
(
1
)
.
uleb
(
4
)
.
L32
(
8
)
.
L8
(
6
)
.
L64
(
0
)
.
L8
(
4
)
.
uleb
(
0
)
.
uleb
(
0xffff_ffff
)
.
uleb
(
4
)
.
L32
(
9
)
.
L8
(
5
)
.
uleb
(
4
)
.
L32
(
10
)
.
L8
(
1
)
.
uleb
(
0
)
.
L8
(
4
)
.
uleb
(
0x10100
)
.
uleb
(
0x10200
)
.
uleb
(
4
)
.
L32
(
11
)
.
L8
(
2
)
.
uleb
(
1
)
.
uleb
(
2
)
.
uleb
(
4
)
.
L32
(
12
)
.
L8
(
3
)
.
uleb
(
3
)
.
uleb
(
0x100
)
.
uleb
(
4
)
.
L32
(
13
)
.
L8
(
1
)
.
uleb
(
4
)
.
L8
(
4
)
.
uleb
(
0x11100
)
.
uleb
(
0x11200
)
.
uleb
(
4
)
.
L32
(
20
)
.
L8
(
6
)
.
L64
(
tombstone
)
.
L8
(
4
)
.
uleb
(
0x11300
)
.
uleb
(
0x11400
)
.
uleb
(
4
)
.
L32
(
21
)
.
L8
(
2
)
.
uleb
(
4
)
.
uleb
(
5
)
.
uleb
(
4
)
.
L32
(
22
)
.
L8
(
3
)
.
uleb
(
4
)
.
uleb
(
0x100
)
.
uleb
(
4
)
.
L32
(
23
)
.
L8
(
7
)
.
L64
(
tombstone
)
.
L64
(
0x201_1500
)
.
uleb
(
4
)
.
L32
(
24
)
.
L8
(
8
)
.
L64
(
tombstone
)
.
uleb
(
0x100
)
.
uleb
(
4
)
.
L32
(
25
)
.
L8
(
7
)
.
L64
(
0x201_1600
)
.
L64
(
0x201_1700
)
.
uleb
(
4
)
.
L32
(
26
)
.
L8
(
0
)
.
L32
(
0xffff_ffff
)
;
size
.
set_const
(
(
&
section
.
here
(
)
-
&
start
-
12
)
as
u64
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_loc
=
DebugLoc
:
:
new
(
&
[
]
LittleEndian
)
;
let
debug_loclists
=
DebugLocLists
:
:
new
(
&
buf
LittleEndian
)
;
let
loclists
=
LocationLists
:
:
new
(
debug_loc
debug_loclists
)
;
let
offset
=
LocationListsOffset
(
(
&
first
-
&
start
)
as
usize
)
;
let
mut
locations
=
loclists
.
locations
(
offset
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0101_0200
end
:
0x0101_0300
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
2
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0400
end
:
0x0201_0500
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
3
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0600
end
:
0x0201_0600
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
4
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0800
end
:
0x0201_0900
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
5
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0a00
end
:
0x0201_0b00
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
6
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0c00
end
:
0x0201_0d00
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
7
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0200_0000
end
:
0x0200_0001
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
8
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0000_0000
end
:
0xffff_ffff
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
9
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0
end
:
u64
:
:
MAX
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
10
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0301_0100
end
:
0x0301_0200
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
11
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0301_0300
end
:
0x0301_0400
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
12
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0301_0500
end
:
0x0301_0600
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
13
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_1600
end
:
0x0201_1700
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
26
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
None
)
)
;
let
mut
locations
=
loclists
.
locations
(
LocationListsOffset
(
buf
.
len
(
)
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
None
)
)
;
}
#
[
test
]
fn
test_location_list_32
(
)
{
let
tombstone
=
!
0u32
-
1
;
let
start
=
Label
:
:
new
(
)
;
let
first
=
Label
:
:
new
(
)
;
#
[
rustfmt
:
:
skip
]
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
mark
(
&
start
)
.
L32
(
0x10000
)
.
L32
(
0x10100
)
.
L16
(
4
)
.
L32
(
1
)
.
mark
(
&
first
)
.
L32
(
0x10200
)
.
L32
(
0x10300
)
.
L16
(
4
)
.
L32
(
2
)
.
L32
(
0xffff_ffff
)
.
L32
(
0x0200_0000
)
.
L32
(
0x10400
)
.
L32
(
0x10500
)
.
L16
(
4
)
.
L32
(
3
)
.
L32
(
0x10600
)
.
L32
(
0x10600
)
.
L16
(
4
)
.
L32
(
4
)
.
L32
(
0x10800
)
.
L32
(
0x10900
)
.
L16
(
4
)
.
L32
(
5
)
.
L32
(
0
)
.
L32
(
1
)
.
L16
(
4
)
.
L32
(
6
)
.
L32
(
0xffff_ffff
)
.
L32
(
0x0000_0000
)
.
L32
(
0
)
.
L32
(
0xffff_ffff
)
.
L16
(
4
)
.
L32
(
7
)
.
L32
(
tombstone
)
.
L32
(
tombstone
)
.
L16
(
4
)
.
L32
(
8
)
.
L32
(
0xffff_ffff
)
.
L32
(
tombstone
)
.
L32
(
0x10a00
)
.
L32
(
0x10b00
)
.
L16
(
4
)
.
L32
(
9
)
.
L32
(
0
)
.
L32
(
0
)
.
L32
(
0
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_loc
=
DebugLoc
:
:
new
(
&
buf
LittleEndian
)
;
let
debug_loclists
=
DebugLocLists
:
:
new
(
&
[
]
LittleEndian
)
;
let
loclists
=
LocationLists
:
:
new
(
debug_loc
debug_loclists
)
;
let
offset
=
LocationListsOffset
(
(
&
first
-
&
start
)
as
usize
)
;
let
debug_addr
=
&
DebugAddr
:
:
from
(
EndianSlice
:
:
new
(
&
[
]
LittleEndian
)
)
;
let
debug_addr_base
=
DebugAddrBase
(
0
)
;
let
encoding
=
Encoding
{
format
:
Format
:
:
Dwarf32
version
:
4
address_size
:
4
}
;
let
mut
locations
=
loclists
.
locations
(
offset
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0101_0200
end
:
0x0101_0300
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
2
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0400
end
:
0x0201_0500
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
3
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0600
end
:
0x0201_0600
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
4
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0800
end
:
0x0201_0900
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
5
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0200_0000
end
:
0x0200_0001
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
6
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0000_0000
end
:
0xffff_ffff
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
7
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
None
)
)
;
let
mut
locations
=
loclists
.
locations
(
LocationListsOffset
(
buf
.
len
(
)
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
None
)
)
;
}
#
[
test
]
fn
test_location_list_64
(
)
{
let
tombstone
=
!
0u64
-
1
;
let
start
=
Label
:
:
new
(
)
;
let
first
=
Label
:
:
new
(
)
;
#
[
rustfmt
:
:
skip
]
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
mark
(
&
start
)
.
L64
(
0x10000
)
.
L64
(
0x10100
)
.
L16
(
4
)
.
L32
(
1
)
.
mark
(
&
first
)
.
L64
(
0x10200
)
.
L64
(
0x10300
)
.
L16
(
4
)
.
L32
(
2
)
.
L64
(
0xffff_ffff_ffff_ffff
)
.
L64
(
0x0200_0000
)
.
L64
(
0x10400
)
.
L64
(
0x10500
)
.
L16
(
4
)
.
L32
(
3
)
.
L64
(
0x10600
)
.
L64
(
0x10600
)
.
L16
(
4
)
.
L32
(
4
)
.
L64
(
0x10800
)
.
L64
(
0x10900
)
.
L16
(
4
)
.
L32
(
5
)
.
L64
(
0
)
.
L64
(
1
)
.
L16
(
4
)
.
L32
(
6
)
.
L64
(
0xffff_ffff_ffff_ffff
)
.
L64
(
0x0000_0000
)
.
L64
(
0
)
.
L64
(
0xffff_ffff_ffff_ffff
)
.
L16
(
4
)
.
L32
(
7
)
.
L64
(
tombstone
)
.
L64
(
tombstone
)
.
L16
(
4
)
.
L32
(
8
)
.
L64
(
0xffff_ffff_ffff_ffff
)
.
L64
(
tombstone
)
.
L64
(
0x10a00
)
.
L64
(
0x10b00
)
.
L16
(
4
)
.
L32
(
9
)
.
L64
(
0
)
.
L64
(
0
)
.
L64
(
0
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_loc
=
DebugLoc
:
:
new
(
&
buf
LittleEndian
)
;
let
debug_loclists
=
DebugLocLists
:
:
new
(
&
[
]
LittleEndian
)
;
let
loclists
=
LocationLists
:
:
new
(
debug_loc
debug_loclists
)
;
let
offset
=
LocationListsOffset
(
(
&
first
-
&
start
)
as
usize
)
;
let
debug_addr
=
&
DebugAddr
:
:
from
(
EndianSlice
:
:
new
(
&
[
]
LittleEndian
)
)
;
let
debug_addr_base
=
DebugAddrBase
(
0
)
;
let
encoding
=
Encoding
{
format
:
Format
:
:
Dwarf64
version
:
4
address_size
:
8
}
;
let
mut
locations
=
loclists
.
locations
(
offset
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0101_0200
end
:
0x0101_0300
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
2
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0400
end
:
0x0201_0500
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
3
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0600
end
:
0x0201_0600
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
4
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0201_0800
end
:
0x0201_0900
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
5
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0200_0000
end
:
0x0200_0001
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
6
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0
end
:
0xffff_ffff_ffff_ffff
}
data
:
Expression
(
EndianSlice
:
:
new
(
&
[
7
0
0
0
]
LittleEndian
)
)
}
)
)
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
None
)
)
;
let
mut
locations
=
loclists
.
locations
(
LocationListsOffset
(
buf
.
len
(
)
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
None
)
)
;
}
#
[
test
]
fn
test_locations_invalid
(
)
{
#
[
rustfmt
:
:
skip
]
let
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
L32
(
0x20000
)
.
L32
(
0x10000
)
.
L16
(
4
)
.
L32
(
1
)
.
L32
(
0x20000
)
.
L32
(
0xff01_0000
)
.
L16
(
4
)
.
L32
(
2
)
;
let
buf
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_loc
=
DebugLoc
:
:
new
(
&
buf
LittleEndian
)
;
let
debug_loclists
=
DebugLocLists
:
:
new
(
&
[
]
LittleEndian
)
;
let
loclists
=
LocationLists
:
:
new
(
debug_loc
debug_loclists
)
;
let
debug_addr
=
&
DebugAddr
:
:
from
(
EndianSlice
:
:
new
(
&
[
]
LittleEndian
)
)
;
let
debug_addr_base
=
DebugAddrBase
(
0
)
;
let
encoding
=
Encoding
{
format
:
Format
:
:
Dwarf32
version
:
4
address_size
:
4
}
;
let
mut
locations
=
loclists
.
locations
(
LocationListsOffset
(
0x0
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
None
)
)
;
let
mut
locations
=
loclists
.
locations
(
LocationListsOffset
(
14
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
None
)
)
;
match
loclists
.
locations
(
LocationListsOffset
(
buf
.
len
(
)
+
1
)
encoding
0x0100_0000
debug_addr
debug_addr_base
)
{
Err
(
Error
:
:
UnexpectedEof
(
_
)
)
=
>
{
}
otherwise
=
>
panic
!
(
"
Unexpected
result
:
{
:
?
}
"
otherwise
)
}
}
#
[
test
]
fn
test_get_offset
(
)
{
for
format
in
[
Format
:
:
Dwarf32
Format
:
:
Dwarf64
]
{
let
encoding
=
Encoding
{
format
version
:
5
address_size
:
4
}
;
let
zero
=
Label
:
:
new
(
)
;
let
length
=
Label
:
:
new
(
)
;
let
start
=
Label
:
:
new
(
)
;
let
first
=
Label
:
:
new
(
)
;
let
end
=
Label
:
:
new
(
)
;
let
mut
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
mark
(
&
zero
)
.
initial_length
(
format
&
length
&
start
)
.
D16
(
encoding
.
version
)
.
D8
(
encoding
.
address_size
)
.
D8
(
0
)
.
D32
(
20
)
.
mark
(
&
first
)
;
for
i
in
0
.
.
20
{
section
=
section
.
word
(
format
.
word_size
(
)
1000
+
i
)
;
}
section
=
section
.
mark
(
&
end
)
;
length
.
set_const
(
(
&
end
-
&
start
)
as
u64
)
;
let
section
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_loc
=
DebugLoc
:
:
from
(
EndianSlice
:
:
new
(
&
[
]
LittleEndian
)
)
;
let
debug_loclists
=
DebugLocLists
:
:
from
(
EndianSlice
:
:
new
(
&
section
LittleEndian
)
)
;
let
locations
=
LocationLists
:
:
new
(
debug_loc
debug_loclists
)
;
let
base
=
DebugLocListsBase
(
(
&
first
-
&
zero
)
as
usize
)
;
assert_eq
!
(
locations
.
get_offset
(
encoding
base
DebugLocListsIndex
(
0
)
)
Ok
(
LocationListsOffset
(
base
.
0
+
1000
)
)
)
;
assert_eq
!
(
locations
.
get_offset
(
encoding
base
DebugLocListsIndex
(
19
)
)
Ok
(
LocationListsOffset
(
base
.
0
+
1019
)
)
)
;
}
}
#
[
test
]
fn
test_loclists_gnu_v4_split_dwarf
(
)
{
#
[
rustfmt
:
:
skip
]
let
buf
=
[
0x03
0x00
0x08
0x00
0x00
0x00
0x03
0x00
0x11
0x00
0x9f
]
;
let
data_buf
=
[
0x11
0x00
0x9f
]
;
let
expected_data
=
EndianSlice
:
:
new
(
&
data_buf
LittleEndian
)
;
let
debug_loc
=
DebugLoc
:
:
new
(
&
buf
LittleEndian
)
;
let
debug_loclists
=
DebugLocLists
:
:
new
(
&
[
]
LittleEndian
)
;
let
loclists
=
LocationLists
:
:
new
(
debug_loc
debug_loclists
)
;
let
debug_addr
=
&
DebugAddr
:
:
from
(
EndianSlice
:
:
new
(
&
[
0x01
0x02
0x03
0x04
]
LittleEndian
)
)
;
let
debug_addr_base
=
DebugAddrBase
(
0
)
;
let
encoding
=
Encoding
{
format
:
Format
:
:
Dwarf32
version
:
4
address_size
:
4
}
;
let
mut
locations
=
loclists
.
locations_dwo
(
LocationListsOffset
(
0x0
)
encoding
0
debug_addr
debug_addr_base
)
.
unwrap
(
)
;
assert_eq
!
(
locations
.
next
(
)
Ok
(
Some
(
LocationListEntry
{
range
:
Range
{
begin
:
0x0403_0201
end
:
0x0403_0209
}
data
:
Expression
(
expected_data
)
}
)
)
)
;
}
}
