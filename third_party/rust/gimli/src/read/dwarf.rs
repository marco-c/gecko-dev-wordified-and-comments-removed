use
alloc
:
:
string
:
:
String
;
use
alloc
:
:
sync
:
:
Arc
;
use
crate
:
:
common
:
:
{
DebugAddrBase
DebugAddrIndex
DebugInfoOffset
DebugLineStrOffset
DebugLocListsBase
DebugLocListsIndex
DebugRngListsBase
DebugRngListsIndex
DebugStrOffset
DebugStrOffsetsBase
DebugStrOffsetsIndex
DebugTypeSignature
DebugTypesOffset
DwarfFileType
DwoId
Encoding
LocationListsOffset
RangeListsOffset
RawRangeListsOffset
SectionId
UnitSectionOffset
}
;
use
crate
:
:
constants
;
use
crate
:
:
read
:
:
{
Abbreviations
AbbreviationsCache
AbbreviationsCacheStrategy
AttributeValue
DebugAbbrev
DebugAddr
DebugAranges
DebugCuIndex
DebugInfo
DebugInfoUnitHeadersIter
DebugLine
DebugLineStr
DebugLoc
DebugLocLists
DebugRanges
DebugRngLists
DebugStr
DebugStrOffsets
DebugTuIndex
DebugTypes
DebugTypesUnitHeadersIter
DebuggingInformationEntry
EntriesCursor
EntriesRaw
EntriesTree
Error
IncompleteLineProgram
IndexSectionId
LocListIter
LocationLists
Range
RangeLists
RawLocListIter
RawRngListIter
Reader
ReaderOffset
ReaderOffsetId
Result
RngListIter
Section
UnitHeader
UnitIndex
UnitIndexSectionIterator
UnitOffset
UnitType
}
;
#
[
derive
(
Debug
)
]
pub
struct
DwarfSections
<
T
>
{
pub
debug_abbrev
:
DebugAbbrev
<
T
>
pub
debug_addr
:
DebugAddr
<
T
>
pub
debug_aranges
:
DebugAranges
<
T
>
pub
debug_info
:
DebugInfo
<
T
>
pub
debug_line
:
DebugLine
<
T
>
pub
debug_line_str
:
DebugLineStr
<
T
>
pub
debug_str
:
DebugStr
<
T
>
pub
debug_str_offsets
:
DebugStrOffsets
<
T
>
pub
debug_types
:
DebugTypes
<
T
>
pub
debug_loc
:
DebugLoc
<
T
>
pub
debug_loclists
:
DebugLocLists
<
T
>
pub
debug_ranges
:
DebugRanges
<
T
>
pub
debug_rnglists
:
DebugRngLists
<
T
>
}
impl
<
T
>
DwarfSections
<
T
>
{
pub
fn
load
<
F
E
>
(
mut
section
:
F
)
-
>
core
:
:
result
:
:
Result
<
Self
E
>
where
F
:
FnMut
(
SectionId
)
-
>
core
:
:
result
:
:
Result
<
T
E
>
{
Ok
(
DwarfSections
{
debug_abbrev
:
Section
:
:
load
(
&
mut
section
)
?
debug_addr
:
Section
:
:
load
(
&
mut
section
)
?
debug_aranges
:
Section
:
:
load
(
&
mut
section
)
?
debug_info
:
Section
:
:
load
(
&
mut
section
)
?
debug_line
:
Section
:
:
load
(
&
mut
section
)
?
debug_line_str
:
Section
:
:
load
(
&
mut
section
)
?
debug_str
:
Section
:
:
load
(
&
mut
section
)
?
debug_str_offsets
:
Section
:
:
load
(
&
mut
section
)
?
debug_types
:
Section
:
:
load
(
&
mut
section
)
?
debug_loc
:
Section
:
:
load
(
&
mut
section
)
?
debug_loclists
:
Section
:
:
load
(
&
mut
section
)
?
debug_ranges
:
Section
:
:
load
(
&
mut
section
)
?
debug_rnglists
:
Section
:
:
load
(
&
mut
section
)
?
}
)
}
pub
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
)
-
>
Dwarf
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
Dwarf
:
:
from_sections
(
DwarfSections
{
debug_abbrev
:
self
.
debug_abbrev
.
borrow
(
&
mut
borrow
)
debug_addr
:
self
.
debug_addr
.
borrow
(
&
mut
borrow
)
debug_aranges
:
self
.
debug_aranges
.
borrow
(
&
mut
borrow
)
debug_info
:
self
.
debug_info
.
borrow
(
&
mut
borrow
)
debug_line
:
self
.
debug_line
.
borrow
(
&
mut
borrow
)
debug_line_str
:
self
.
debug_line_str
.
borrow
(
&
mut
borrow
)
debug_str
:
self
.
debug_str
.
borrow
(
&
mut
borrow
)
debug_str_offsets
:
self
.
debug_str_offsets
.
borrow
(
&
mut
borrow
)
debug_types
:
self
.
debug_types
.
borrow
(
&
mut
borrow
)
debug_loc
:
self
.
debug_loc
.
borrow
(
&
mut
borrow
)
debug_loclists
:
self
.
debug_loclists
.
borrow
(
&
mut
borrow
)
debug_ranges
:
self
.
debug_ranges
.
borrow
(
&
mut
borrow
)
debug_rnglists
:
self
.
debug_rnglists
.
borrow
(
&
mut
borrow
)
}
)
}
pub
fn
borrow_with_sup
<
'
a
F
R
>
(
&
'
a
self
sup
:
&
'
a
Self
mut
borrow
:
F
)
-
>
Dwarf
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
let
mut
dwarf
=
self
.
borrow
(
&
mut
borrow
)
;
dwarf
.
set_sup
(
sup
.
borrow
(
&
mut
borrow
)
)
;
dwarf
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
Dwarf
<
R
>
{
pub
debug_abbrev
:
DebugAbbrev
<
R
>
pub
debug_addr
:
DebugAddr
<
R
>
pub
debug_aranges
:
DebugAranges
<
R
>
pub
debug_info
:
DebugInfo
<
R
>
pub
debug_line
:
DebugLine
<
R
>
pub
debug_line_str
:
DebugLineStr
<
R
>
pub
debug_str
:
DebugStr
<
R
>
pub
debug_str_offsets
:
DebugStrOffsets
<
R
>
pub
debug_types
:
DebugTypes
<
R
>
pub
locations
:
LocationLists
<
R
>
pub
ranges
:
RangeLists
<
R
>
pub
file_type
:
DwarfFileType
pub
sup
:
Option
<
Arc
<
Dwarf
<
R
>
>
>
pub
abbreviations_cache
:
AbbreviationsCache
}
impl
<
T
>
Dwarf
<
T
>
{
pub
fn
load
<
F
E
>
(
section
:
F
)
-
>
core
:
:
result
:
:
Result
<
Self
E
>
where
F
:
FnMut
(
SectionId
)
-
>
core
:
:
result
:
:
Result
<
T
E
>
{
let
sections
=
DwarfSections
:
:
load
(
section
)
?
;
Ok
(
Self
:
:
from_sections
(
sections
)
)
}
pub
fn
load_sup
<
F
E
>
(
&
mut
self
section
:
F
)
-
>
core
:
:
result
:
:
Result
<
(
)
E
>
where
F
:
FnMut
(
SectionId
)
-
>
core
:
:
result
:
:
Result
<
T
E
>
{
self
.
set_sup
(
Self
:
:
load
(
section
)
?
)
;
Ok
(
(
)
)
}
fn
from_sections
(
sections
:
DwarfSections
<
T
>
)
-
>
Self
{
Dwarf
{
debug_abbrev
:
sections
.
debug_abbrev
debug_addr
:
sections
.
debug_addr
debug_aranges
:
sections
.
debug_aranges
debug_info
:
sections
.
debug_info
debug_line
:
sections
.
debug_line
debug_line_str
:
sections
.
debug_line_str
debug_str
:
sections
.
debug_str
debug_str_offsets
:
sections
.
debug_str_offsets
debug_types
:
sections
.
debug_types
locations
:
LocationLists
:
:
new
(
sections
.
debug_loc
sections
.
debug_loclists
)
ranges
:
RangeLists
:
:
new
(
sections
.
debug_ranges
sections
.
debug_rnglists
)
file_type
:
DwarfFileType
:
:
Main
sup
:
None
abbreviations_cache
:
AbbreviationsCache
:
:
new
(
)
}
}
#
[
deprecated
(
note
=
"
use
DwarfSections
:
:
borrow
instead
"
)
]
pub
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
)
-
>
Dwarf
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
Dwarf
{
debug_abbrev
:
self
.
debug_abbrev
.
borrow
(
&
mut
borrow
)
debug_addr
:
self
.
debug_addr
.
borrow
(
&
mut
borrow
)
debug_aranges
:
self
.
debug_aranges
.
borrow
(
&
mut
borrow
)
debug_info
:
self
.
debug_info
.
borrow
(
&
mut
borrow
)
debug_line
:
self
.
debug_line
.
borrow
(
&
mut
borrow
)
debug_line_str
:
self
.
debug_line_str
.
borrow
(
&
mut
borrow
)
debug_str
:
self
.
debug_str
.
borrow
(
&
mut
borrow
)
debug_str_offsets
:
self
.
debug_str_offsets
.
borrow
(
&
mut
borrow
)
debug_types
:
self
.
debug_types
.
borrow
(
&
mut
borrow
)
locations
:
self
.
locations
.
borrow
(
&
mut
borrow
)
ranges
:
self
.
ranges
.
borrow
(
&
mut
borrow
)
file_type
:
self
.
file_type
sup
:
self
.
sup
(
)
.
map
(
|
sup
|
Arc
:
:
new
(
sup
.
borrow
(
borrow
)
)
)
abbreviations_cache
:
AbbreviationsCache
:
:
new
(
)
}
}
pub
fn
set_sup
(
&
mut
self
sup
:
Dwarf
<
T
>
)
{
self
.
sup
=
Some
(
Arc
:
:
new
(
sup
)
)
;
}
pub
fn
sup
(
&
self
)
-
>
Option
<
&
Dwarf
<
T
>
>
{
self
.
sup
.
as_ref
(
)
.
map
(
Arc
:
:
as_ref
)
}
}
impl
<
R
:
Reader
>
Dwarf
<
R
>
{
pub
fn
populate_abbreviations_cache
(
&
mut
self
strategy
:
AbbreviationsCacheStrategy
)
{
self
.
abbreviations_cache
.
populate
(
strategy
&
self
.
debug_abbrev
self
.
debug_info
.
units
(
)
)
;
}
#
[
inline
]
pub
fn
units
(
&
self
)
-
>
DebugInfoUnitHeadersIter
<
R
>
{
self
.
debug_info
.
units
(
)
}
#
[
inline
]
pub
fn
unit
(
&
self
header
:
UnitHeader
<
R
>
)
-
>
Result
<
Unit
<
R
>
>
{
Unit
:
:
new
(
self
header
)
}
#
[
inline
]
pub
fn
type_units
(
&
self
)
-
>
DebugTypesUnitHeadersIter
<
R
>
{
self
.
debug_types
.
units
(
)
}
#
[
inline
]
pub
fn
abbreviations
(
&
self
unit
:
&
UnitHeader
<
R
>
)
-
>
Result
<
Arc
<
Abbreviations
>
>
{
self
.
abbreviations_cache
.
get
(
&
self
.
debug_abbrev
unit
.
debug_abbrev_offset
(
)
)
}
#
[
inline
]
pub
fn
string_offset
(
&
self
unit
:
&
Unit
<
R
>
index
:
DebugStrOffsetsIndex
<
R
:
:
Offset
>
)
-
>
Result
<
DebugStrOffset
<
R
:
:
Offset
>
>
{
self
.
debug_str_offsets
.
get_str_offset
(
unit
.
header
.
format
(
)
unit
.
str_offsets_base
index
)
}
#
[
inline
]
pub
fn
string
(
&
self
offset
:
DebugStrOffset
<
R
:
:
Offset
>
)
-
>
Result
<
R
>
{
self
.
debug_str
.
get_str
(
offset
)
}
#
[
inline
]
pub
fn
line_string
(
&
self
offset
:
DebugLineStrOffset
<
R
:
:
Offset
>
)
-
>
Result
<
R
>
{
self
.
debug_line_str
.
get_str
(
offset
)
}
#
[
inline
]
pub
fn
sup_string
(
&
self
offset
:
DebugStrOffset
<
R
:
:
Offset
>
)
-
>
Result
<
R
>
{
if
let
Some
(
sup
)
=
self
.
sup
(
)
{
sup
.
debug_str
.
get_str
(
offset
)
}
else
{
Err
(
Error
:
:
ExpectedStringAttributeValue
)
}
}
pub
fn
attr_string
(
&
self
unit
:
&
Unit
<
R
>
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
R
>
{
match
attr
{
AttributeValue
:
:
String
(
string
)
=
>
Ok
(
string
)
AttributeValue
:
:
DebugStrRef
(
offset
)
=
>
self
.
string
(
offset
)
AttributeValue
:
:
DebugStrRefSup
(
offset
)
=
>
self
.
sup_string
(
offset
)
AttributeValue
:
:
DebugLineStrRef
(
offset
)
=
>
self
.
line_string
(
offset
)
AttributeValue
:
:
DebugStrOffsetsIndex
(
index
)
=
>
{
let
offset
=
self
.
string_offset
(
unit
index
)
?
;
self
.
string
(
offset
)
}
_
=
>
Err
(
Error
:
:
ExpectedStringAttributeValue
)
}
}
pub
fn
address
(
&
self
unit
:
&
Unit
<
R
>
index
:
DebugAddrIndex
<
R
:
:
Offset
>
)
-
>
Result
<
u64
>
{
self
.
debug_addr
.
get_address
(
unit
.
encoding
(
)
.
address_size
unit
.
addr_base
index
)
}
pub
fn
attr_address
(
&
self
unit
:
&
Unit
<
R
>
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
Option
<
u64
>
>
{
match
attr
{
AttributeValue
:
:
Addr
(
addr
)
=
>
Ok
(
Some
(
addr
)
)
AttributeValue
:
:
DebugAddrIndex
(
index
)
=
>
self
.
address
(
unit
index
)
.
map
(
Some
)
_
=
>
Ok
(
None
)
}
}
pub
fn
ranges_offset_from_raw
(
&
self
unit
:
&
Unit
<
R
>
offset
:
RawRangeListsOffset
<
R
:
:
Offset
>
)
-
>
RangeListsOffset
<
R
:
:
Offset
>
{
if
self
.
file_type
=
=
DwarfFileType
:
:
Dwo
&
&
unit
.
header
.
version
(
)
<
5
{
RangeListsOffset
(
offset
.
0
.
wrapping_add
(
unit
.
rnglists_base
.
0
)
)
}
else
{
RangeListsOffset
(
offset
.
0
)
}
}
pub
fn
ranges_offset
(
&
self
unit
:
&
Unit
<
R
>
index
:
DebugRngListsIndex
<
R
:
:
Offset
>
)
-
>
Result
<
RangeListsOffset
<
R
:
:
Offset
>
>
{
self
.
ranges
.
get_offset
(
unit
.
encoding
(
)
unit
.
rnglists_base
index
)
}
pub
fn
ranges
(
&
self
unit
:
&
Unit
<
R
>
offset
:
RangeListsOffset
<
R
:
:
Offset
>
)
-
>
Result
<
RngListIter
<
R
>
>
{
self
.
ranges
.
ranges
(
offset
unit
.
encoding
(
)
unit
.
low_pc
&
self
.
debug_addr
unit
.
addr_base
)
}
pub
fn
raw_ranges
(
&
self
unit
:
&
Unit
<
R
>
offset
:
RangeListsOffset
<
R
:
:
Offset
>
)
-
>
Result
<
RawRngListIter
<
R
>
>
{
self
.
ranges
.
raw_ranges
(
offset
unit
.
encoding
(
)
)
}
pub
fn
attr_ranges_offset
(
&
self
unit
:
&
Unit
<
R
>
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
Option
<
RangeListsOffset
<
R
:
:
Offset
>
>
>
{
match
attr
{
AttributeValue
:
:
RangeListsRef
(
offset
)
=
>
{
Ok
(
Some
(
self
.
ranges_offset_from_raw
(
unit
offset
)
)
)
}
AttributeValue
:
:
DebugRngListsIndex
(
index
)
=
>
self
.
ranges_offset
(
unit
index
)
.
map
(
Some
)
_
=
>
Ok
(
None
)
}
}
pub
fn
attr_ranges
(
&
self
unit
:
&
Unit
<
R
>
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
Option
<
RngListIter
<
R
>
>
>
{
match
self
.
attr_ranges_offset
(
unit
attr
)
?
{
Some
(
offset
)
=
>
Ok
(
Some
(
self
.
ranges
(
unit
offset
)
?
)
)
None
=
>
Ok
(
None
)
}
}
pub
fn
die_ranges
(
&
self
unit
:
&
Unit
<
R
>
entry
:
&
DebuggingInformationEntry
<
'
_
'
_
R
>
)
-
>
Result
<
RangeIter
<
R
>
>
{
let
mut
low_pc
=
None
;
let
mut
high_pc
=
None
;
let
mut
size
=
None
;
let
mut
attrs
=
entry
.
attrs
(
)
;
while
let
Some
(
attr
)
=
attrs
.
next
(
)
?
{
match
attr
.
name
(
)
{
constants
:
:
DW_AT_low_pc
=
>
{
low_pc
=
Some
(
self
.
attr_address
(
unit
attr
.
value
(
)
)
?
.
ok_or
(
Error
:
:
UnsupportedAttributeForm
)
?
)
;
}
constants
:
:
DW_AT_high_pc
=
>
match
attr
.
value
(
)
{
AttributeValue
:
:
Udata
(
val
)
=
>
size
=
Some
(
val
)
attr
=
>
{
high_pc
=
Some
(
self
.
attr_address
(
unit
attr
)
?
.
ok_or
(
Error
:
:
UnsupportedAttributeForm
)
?
)
;
}
}
constants
:
:
DW_AT_ranges
=
>
{
if
let
Some
(
list
)
=
self
.
attr_ranges
(
unit
attr
.
value
(
)
)
?
{
return
Ok
(
RangeIter
(
RangeIterInner
:
:
List
(
list
)
)
)
;
}
}
_
=
>
{
}
}
}
let
range
=
low_pc
.
and_then
(
|
begin
|
{
let
end
=
size
.
map
(
|
size
|
begin
+
size
)
.
or
(
high_pc
)
;
end
.
map
(
|
end
|
Range
{
begin
end
}
)
}
)
;
Ok
(
RangeIter
(
RangeIterInner
:
:
Single
(
range
)
)
)
}
pub
fn
unit_ranges
(
&
self
unit
:
&
Unit
<
R
>
)
-
>
Result
<
RangeIter
<
R
>
>
{
let
mut
cursor
=
unit
.
header
.
entries
(
&
unit
.
abbreviations
)
;
cursor
.
next_dfs
(
)
?
;
let
root
=
cursor
.
current
(
)
.
ok_or
(
Error
:
:
MissingUnitDie
)
?
;
self
.
die_ranges
(
unit
root
)
}
pub
fn
locations_offset
(
&
self
unit
:
&
Unit
<
R
>
index
:
DebugLocListsIndex
<
R
:
:
Offset
>
)
-
>
Result
<
LocationListsOffset
<
R
:
:
Offset
>
>
{
self
.
locations
.
get_offset
(
unit
.
encoding
(
)
unit
.
loclists_base
index
)
}
pub
fn
locations
(
&
self
unit
:
&
Unit
<
R
>
offset
:
LocationListsOffset
<
R
:
:
Offset
>
)
-
>
Result
<
LocListIter
<
R
>
>
{
match
self
.
file_type
{
DwarfFileType
:
:
Main
=
>
self
.
locations
.
locations
(
offset
unit
.
encoding
(
)
unit
.
low_pc
&
self
.
debug_addr
unit
.
addr_base
)
DwarfFileType
:
:
Dwo
=
>
self
.
locations
.
locations_dwo
(
offset
unit
.
encoding
(
)
unit
.
low_pc
&
self
.
debug_addr
unit
.
addr_base
)
}
}
pub
fn
raw_locations
(
&
self
unit
:
&
Unit
<
R
>
offset
:
LocationListsOffset
<
R
:
:
Offset
>
)
-
>
Result
<
RawLocListIter
<
R
>
>
{
match
self
.
file_type
{
DwarfFileType
:
:
Main
=
>
self
.
locations
.
raw_locations
(
offset
unit
.
encoding
(
)
)
DwarfFileType
:
:
Dwo
=
>
self
.
locations
.
raw_locations_dwo
(
offset
unit
.
encoding
(
)
)
}
}
pub
fn
attr_locations_offset
(
&
self
unit
:
&
Unit
<
R
>
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
Option
<
LocationListsOffset
<
R
:
:
Offset
>
>
>
{
match
attr
{
AttributeValue
:
:
LocationListsRef
(
offset
)
=
>
Ok
(
Some
(
offset
)
)
AttributeValue
:
:
DebugLocListsIndex
(
index
)
=
>
{
self
.
locations_offset
(
unit
index
)
.
map
(
Some
)
}
_
=
>
Ok
(
None
)
}
}
pub
fn
attr_locations
(
&
self
unit
:
&
Unit
<
R
>
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
Option
<
LocListIter
<
R
>
>
>
{
match
self
.
attr_locations_offset
(
unit
attr
)
?
{
Some
(
offset
)
=
>
Ok
(
Some
(
self
.
locations
(
unit
offset
)
?
)
)
None
=
>
Ok
(
None
)
}
}
pub
fn
lookup_offset_id
(
&
self
id
:
ReaderOffsetId
)
-
>
Option
<
(
bool
SectionId
R
:
:
Offset
)
>
{
None
.
or_else
(
|
|
self
.
debug_abbrev
.
lookup_offset_id
(
id
)
)
.
or_else
(
|
|
self
.
debug_addr
.
lookup_offset_id
(
id
)
)
.
or_else
(
|
|
self
.
debug_aranges
.
lookup_offset_id
(
id
)
)
.
or_else
(
|
|
self
.
debug_info
.
lookup_offset_id
(
id
)
)
.
or_else
(
|
|
self
.
debug_line
.
lookup_offset_id
(
id
)
)
.
or_else
(
|
|
self
.
debug_line_str
.
lookup_offset_id
(
id
)
)
.
or_else
(
|
|
self
.
debug_str
.
lookup_offset_id
(
id
)
)
.
or_else
(
|
|
self
.
debug_str_offsets
.
lookup_offset_id
(
id
)
)
.
or_else
(
|
|
self
.
debug_types
.
lookup_offset_id
(
id
)
)
.
or_else
(
|
|
self
.
locations
.
lookup_offset_id
(
id
)
)
.
or_else
(
|
|
self
.
ranges
.
lookup_offset_id
(
id
)
)
.
map
(
|
(
id
offset
)
|
(
false
id
offset
)
)
.
or_else
(
|
|
{
self
.
sup
(
)
.
and_then
(
|
sup
|
sup
.
lookup_offset_id
(
id
)
)
.
map
(
|
(
_
id
offset
)
|
(
true
id
offset
)
)
}
)
}
pub
fn
format_error
(
&
self
err
:
Error
)
-
>
String
{
#
[
allow
(
clippy
:
:
single_match
)
]
match
err
{
Error
:
:
UnexpectedEof
(
id
)
=
>
match
self
.
lookup_offset_id
(
id
)
{
Some
(
(
sup
section
offset
)
)
=
>
{
return
format
!
(
"
{
}
at
{
}
{
}
+
0x
{
:
x
}
"
err
section
.
name
(
)
if
sup
{
"
(
sup
)
"
}
else
{
"
"
}
offset
.
into_u64
(
)
)
;
}
None
=
>
{
}
}
_
=
>
{
}
}
err
.
description
(
)
.
into
(
)
}
}
impl
<
R
:
Clone
>
Dwarf
<
R
>
{
pub
fn
make_dwo
(
&
mut
self
parent
:
&
Dwarf
<
R
>
)
{
self
.
file_type
=
DwarfFileType
:
:
Dwo
;
self
.
debug_addr
=
parent
.
debug_addr
.
clone
(
)
;
self
.
ranges
.
set_debug_ranges
(
parent
.
ranges
.
debug_ranges
(
)
.
clone
(
)
)
;
self
.
sup
=
parent
.
sup
.
clone
(
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
DwarfPackageSections
<
T
>
{
pub
cu_index
:
DebugCuIndex
<
T
>
pub
tu_index
:
DebugTuIndex
<
T
>
pub
debug_abbrev
:
DebugAbbrev
<
T
>
pub
debug_info
:
DebugInfo
<
T
>
pub
debug_line
:
DebugLine
<
T
>
pub
debug_str
:
DebugStr
<
T
>
pub
debug_str_offsets
:
DebugStrOffsets
<
T
>
pub
debug_loc
:
DebugLoc
<
T
>
pub
debug_loclists
:
DebugLocLists
<
T
>
pub
debug_rnglists
:
DebugRngLists
<
T
>
pub
debug_types
:
DebugTypes
<
T
>
}
impl
<
T
>
DwarfPackageSections
<
T
>
{
pub
fn
load
<
F
E
>
(
mut
section
:
F
)
-
>
core
:
:
result
:
:
Result
<
Self
E
>
where
F
:
FnMut
(
SectionId
)
-
>
core
:
:
result
:
:
Result
<
T
E
>
E
:
From
<
Error
>
{
Ok
(
DwarfPackageSections
{
cu_index
:
Section
:
:
load
(
&
mut
section
)
?
tu_index
:
Section
:
:
load
(
&
mut
section
)
?
debug_abbrev
:
Section
:
:
load
(
&
mut
section
)
?
debug_info
:
Section
:
:
load
(
&
mut
section
)
?
debug_line
:
Section
:
:
load
(
&
mut
section
)
?
debug_str
:
Section
:
:
load
(
&
mut
section
)
?
debug_str_offsets
:
Section
:
:
load
(
&
mut
section
)
?
debug_loc
:
Section
:
:
load
(
&
mut
section
)
?
debug_loclists
:
Section
:
:
load
(
&
mut
section
)
?
debug_rnglists
:
Section
:
:
load
(
&
mut
section
)
?
debug_types
:
Section
:
:
load
(
&
mut
section
)
?
}
)
}
pub
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
empty
:
R
)
-
>
Result
<
DwarfPackage
<
R
>
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
R
:
Reader
{
DwarfPackage
:
:
from_sections
(
DwarfPackageSections
{
cu_index
:
self
.
cu_index
.
borrow
(
&
mut
borrow
)
tu_index
:
self
.
tu_index
.
borrow
(
&
mut
borrow
)
debug_abbrev
:
self
.
debug_abbrev
.
borrow
(
&
mut
borrow
)
debug_info
:
self
.
debug_info
.
borrow
(
&
mut
borrow
)
debug_line
:
self
.
debug_line
.
borrow
(
&
mut
borrow
)
debug_str
:
self
.
debug_str
.
borrow
(
&
mut
borrow
)
debug_str_offsets
:
self
.
debug_str_offsets
.
borrow
(
&
mut
borrow
)
debug_loc
:
self
.
debug_loc
.
borrow
(
&
mut
borrow
)
debug_loclists
:
self
.
debug_loclists
.
borrow
(
&
mut
borrow
)
debug_rnglists
:
self
.
debug_rnglists
.
borrow
(
&
mut
borrow
)
debug_types
:
self
.
debug_types
.
borrow
(
&
mut
borrow
)
}
empty
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
DwarfPackage
<
R
:
Reader
>
{
pub
cu_index
:
UnitIndex
<
R
>
pub
tu_index
:
UnitIndex
<
R
>
pub
debug_abbrev
:
DebugAbbrev
<
R
>
pub
debug_info
:
DebugInfo
<
R
>
pub
debug_line
:
DebugLine
<
R
>
pub
debug_str
:
DebugStr
<
R
>
pub
debug_str_offsets
:
DebugStrOffsets
<
R
>
pub
debug_loc
:
DebugLoc
<
R
>
pub
debug_loclists
:
DebugLocLists
<
R
>
pub
debug_rnglists
:
DebugRngLists
<
R
>
pub
debug_types
:
DebugTypes
<
R
>
pub
empty
:
R
}
impl
<
R
:
Reader
>
DwarfPackage
<
R
>
{
pub
fn
load
<
F
E
>
(
section
:
F
empty
:
R
)
-
>
core
:
:
result
:
:
Result
<
Self
E
>
where
F
:
FnMut
(
SectionId
)
-
>
core
:
:
result
:
:
Result
<
R
E
>
E
:
From
<
Error
>
{
let
sections
=
DwarfPackageSections
:
:
load
(
section
)
?
;
Ok
(
Self
:
:
from_sections
(
sections
empty
)
?
)
}
fn
from_sections
(
sections
:
DwarfPackageSections
<
R
>
empty
:
R
)
-
>
Result
<
Self
>
{
Ok
(
DwarfPackage
{
cu_index
:
sections
.
cu_index
.
index
(
)
?
tu_index
:
sections
.
tu_index
.
index
(
)
?
debug_abbrev
:
sections
.
debug_abbrev
debug_info
:
sections
.
debug_info
debug_line
:
sections
.
debug_line
debug_str
:
sections
.
debug_str
debug_str_offsets
:
sections
.
debug_str_offsets
debug_loc
:
sections
.
debug_loc
debug_loclists
:
sections
.
debug_loclists
debug_rnglists
:
sections
.
debug_rnglists
debug_types
:
sections
.
debug_types
empty
}
)
}
pub
fn
find_cu
(
&
self
id
:
DwoId
parent
:
&
Dwarf
<
R
>
)
-
>
Result
<
Option
<
Dwarf
<
R
>
>
>
{
let
row
=
match
self
.
cu_index
.
find
(
id
.
0
)
{
Some
(
row
)
=
>
row
None
=
>
return
Ok
(
None
)
}
;
self
.
cu_sections
(
row
parent
)
.
map
(
Some
)
}
pub
fn
find_tu
(
&
self
signature
:
DebugTypeSignature
parent
:
&
Dwarf
<
R
>
)
-
>
Result
<
Option
<
Dwarf
<
R
>
>
>
{
let
row
=
match
self
.
tu_index
.
find
(
signature
.
0
)
{
Some
(
row
)
=
>
row
None
=
>
return
Ok
(
None
)
}
;
self
.
tu_sections
(
row
parent
)
.
map
(
Some
)
}
pub
fn
cu_sections
(
&
self
index
:
u32
parent
:
&
Dwarf
<
R
>
)
-
>
Result
<
Dwarf
<
R
>
>
{
self
.
sections
(
self
.
cu_index
.
sections
(
index
)
?
parent
)
}
pub
fn
tu_sections
(
&
self
index
:
u32
parent
:
&
Dwarf
<
R
>
)
-
>
Result
<
Dwarf
<
R
>
>
{
self
.
sections
(
self
.
tu_index
.
sections
(
index
)
?
parent
)
}
pub
fn
sections
(
&
self
sections
:
UnitIndexSectionIterator
<
'
_
R
>
parent
:
&
Dwarf
<
R
>
)
-
>
Result
<
Dwarf
<
R
>
>
{
let
mut
abbrev_offset
=
0
;
let
mut
abbrev_size
=
0
;
let
mut
info_offset
=
0
;
let
mut
info_size
=
0
;
let
mut
line_offset
=
0
;
let
mut
line_size
=
0
;
let
mut
loc_offset
=
0
;
let
mut
loc_size
=
0
;
let
mut
loclists_offset
=
0
;
let
mut
loclists_size
=
0
;
let
mut
str_offsets_offset
=
0
;
let
mut
str_offsets_size
=
0
;
let
mut
rnglists_offset
=
0
;
let
mut
rnglists_size
=
0
;
let
mut
types_offset
=
0
;
let
mut
types_size
=
0
;
for
section
in
sections
{
match
section
.
section
{
IndexSectionId
:
:
DebugAbbrev
=
>
{
abbrev_offset
=
section
.
offset
;
abbrev_size
=
section
.
size
;
}
IndexSectionId
:
:
DebugInfo
=
>
{
info_offset
=
section
.
offset
;
info_size
=
section
.
size
;
}
IndexSectionId
:
:
DebugLine
=
>
{
line_offset
=
section
.
offset
;
line_size
=
section
.
size
;
}
IndexSectionId
:
:
DebugLoc
=
>
{
loc_offset
=
section
.
offset
;
loc_size
=
section
.
size
;
}
IndexSectionId
:
:
DebugLocLists
=
>
{
loclists_offset
=
section
.
offset
;
loclists_size
=
section
.
size
;
}
IndexSectionId
:
:
DebugStrOffsets
=
>
{
str_offsets_offset
=
section
.
offset
;
str_offsets_size
=
section
.
size
;
}
IndexSectionId
:
:
DebugRngLists
=
>
{
rnglists_offset
=
section
.
offset
;
rnglists_size
=
section
.
size
;
}
IndexSectionId
:
:
DebugTypes
=
>
{
types_offset
=
section
.
offset
;
types_size
=
section
.
size
;
}
IndexSectionId
:
:
DebugMacro
|
IndexSectionId
:
:
DebugMacinfo
=
>
{
}
}
}
let
debug_abbrev
=
self
.
debug_abbrev
.
dwp_range
(
abbrev_offset
abbrev_size
)
?
;
let
debug_info
=
self
.
debug_info
.
dwp_range
(
info_offset
info_size
)
?
;
let
debug_line
=
self
.
debug_line
.
dwp_range
(
line_offset
line_size
)
?
;
let
debug_loc
=
self
.
debug_loc
.
dwp_range
(
loc_offset
loc_size
)
?
;
let
debug_loclists
=
self
.
debug_loclists
.
dwp_range
(
loclists_offset
loclists_size
)
?
;
let
debug_str_offsets
=
self
.
debug_str_offsets
.
dwp_range
(
str_offsets_offset
str_offsets_size
)
?
;
let
debug_rnglists
=
self
.
debug_rnglists
.
dwp_range
(
rnglists_offset
rnglists_size
)
?
;
let
debug_types
=
self
.
debug_types
.
dwp_range
(
types_offset
types_size
)
?
;
let
debug_str
=
self
.
debug_str
.
clone
(
)
;
let
debug_addr
=
parent
.
debug_addr
.
clone
(
)
;
let
debug_ranges
=
parent
.
ranges
.
debug_ranges
(
)
.
clone
(
)
;
let
debug_aranges
=
self
.
empty
.
clone
(
)
.
into
(
)
;
let
debug_line_str
=
self
.
empty
.
clone
(
)
.
into
(
)
;
Ok
(
Dwarf
{
debug_abbrev
debug_addr
debug_aranges
debug_info
debug_line
debug_line_str
debug_str
debug_str_offsets
debug_types
locations
:
LocationLists
:
:
new
(
debug_loc
debug_loclists
)
ranges
:
RangeLists
:
:
new
(
debug_ranges
debug_rnglists
)
file_type
:
DwarfFileType
:
:
Dwo
sup
:
parent
.
sup
.
clone
(
)
abbreviations_cache
:
AbbreviationsCache
:
:
new
(
)
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Unit
<
R
Offset
=
<
R
as
Reader
>
:
:
Offset
>
where
R
:
Reader
<
Offset
=
Offset
>
Offset
:
ReaderOffset
{
pub
header
:
UnitHeader
<
R
Offset
>
pub
abbreviations
:
Arc
<
Abbreviations
>
pub
name
:
Option
<
R
>
pub
comp_dir
:
Option
<
R
>
pub
low_pc
:
u64
pub
str_offsets_base
:
DebugStrOffsetsBase
<
Offset
>
pub
addr_base
:
DebugAddrBase
<
Offset
>
pub
loclists_base
:
DebugLocListsBase
<
Offset
>
pub
rnglists_base
:
DebugRngListsBase
<
Offset
>
pub
line_program
:
Option
<
IncompleteLineProgram
<
R
Offset
>
>
pub
dwo_id
:
Option
<
DwoId
>
}
impl
<
R
:
Reader
>
Unit
<
R
>
{
#
[
inline
]
pub
fn
new
(
dwarf
:
&
Dwarf
<
R
>
header
:
UnitHeader
<
R
>
)
-
>
Result
<
Self
>
{
let
abbreviations
=
dwarf
.
abbreviations
(
&
header
)
?
;
Self
:
:
new_with_abbreviations
(
dwarf
header
abbreviations
)
}
#
[
inline
]
pub
fn
new_with_abbreviations
(
dwarf
:
&
Dwarf
<
R
>
header
:
UnitHeader
<
R
>
abbreviations
:
Arc
<
Abbreviations
>
)
-
>
Result
<
Self
>
{
let
mut
unit
=
Unit
{
abbreviations
name
:
None
comp_dir
:
None
low_pc
:
0
str_offsets_base
:
DebugStrOffsetsBase
:
:
default_for_encoding_and_file
(
header
.
encoding
(
)
dwarf
.
file_type
)
addr_base
:
DebugAddrBase
(
R
:
:
Offset
:
:
from_u8
(
0
)
)
loclists_base
:
DebugLocListsBase
:
:
default_for_encoding_and_file
(
header
.
encoding
(
)
dwarf
.
file_type
)
rnglists_base
:
DebugRngListsBase
:
:
default_for_encoding_and_file
(
header
.
encoding
(
)
dwarf
.
file_type
)
line_program
:
None
dwo_id
:
match
header
.
type_
(
)
{
UnitType
:
:
Skeleton
(
dwo_id
)
|
UnitType
:
:
SplitCompilation
(
dwo_id
)
=
>
Some
(
dwo_id
)
_
=
>
None
}
header
}
;
let
mut
name
=
None
;
let
mut
comp_dir
=
None
;
let
mut
line_program_offset
=
None
;
let
mut
low_pc_attr
=
None
;
{
let
mut
cursor
=
unit
.
header
.
entries
(
&
unit
.
abbreviations
)
;
cursor
.
next_dfs
(
)
?
;
let
root
=
cursor
.
current
(
)
.
ok_or
(
Error
:
:
MissingUnitDie
)
?
;
let
mut
attrs
=
root
.
attrs
(
)
;
while
let
Some
(
attr
)
=
attrs
.
next
(
)
?
{
match
attr
.
name
(
)
{
constants
:
:
DW_AT_name
=
>
{
name
=
Some
(
attr
.
value
(
)
)
;
}
constants
:
:
DW_AT_comp_dir
=
>
{
comp_dir
=
Some
(
attr
.
value
(
)
)
;
}
constants
:
:
DW_AT_low_pc
=
>
{
low_pc_attr
=
Some
(
attr
.
value
(
)
)
;
}
constants
:
:
DW_AT_stmt_list
=
>
{
if
let
AttributeValue
:
:
DebugLineRef
(
offset
)
=
attr
.
value
(
)
{
line_program_offset
=
Some
(
offset
)
;
}
}
constants
:
:
DW_AT_str_offsets_base
=
>
{
if
let
AttributeValue
:
:
DebugStrOffsetsBase
(
base
)
=
attr
.
value
(
)
{
unit
.
str_offsets_base
=
base
;
}
}
constants
:
:
DW_AT_addr_base
|
constants
:
:
DW_AT_GNU_addr_base
=
>
{
if
let
AttributeValue
:
:
DebugAddrBase
(
base
)
=
attr
.
value
(
)
{
unit
.
addr_base
=
base
;
}
}
constants
:
:
DW_AT_loclists_base
=
>
{
if
let
AttributeValue
:
:
DebugLocListsBase
(
base
)
=
attr
.
value
(
)
{
unit
.
loclists_base
=
base
;
}
}
constants
:
:
DW_AT_rnglists_base
|
constants
:
:
DW_AT_GNU_ranges_base
=
>
{
if
let
AttributeValue
:
:
DebugRngListsBase
(
base
)
=
attr
.
value
(
)
{
unit
.
rnglists_base
=
base
;
}
}
constants
:
:
DW_AT_GNU_dwo_id
=
>
{
if
unit
.
dwo_id
.
is_none
(
)
{
if
let
AttributeValue
:
:
DwoId
(
dwo_id
)
=
attr
.
value
(
)
{
unit
.
dwo_id
=
Some
(
dwo_id
)
;
}
}
}
_
=
>
{
}
}
}
}
unit
.
name
=
match
name
{
Some
(
val
)
=
>
dwarf
.
attr_string
(
&
unit
val
)
.
ok
(
)
None
=
>
None
}
;
unit
.
comp_dir
=
match
comp_dir
{
Some
(
val
)
=
>
dwarf
.
attr_string
(
&
unit
val
)
.
ok
(
)
None
=
>
None
}
;
unit
.
line_program
=
match
line_program_offset
{
Some
(
offset
)
=
>
Some
(
dwarf
.
debug_line
.
program
(
offset
unit
.
header
.
address_size
(
)
unit
.
comp_dir
.
clone
(
)
unit
.
name
.
clone
(
)
)
?
)
None
=
>
None
}
;
if
let
Some
(
low_pc_attr
)
=
low_pc_attr
{
if
let
Some
(
addr
)
=
dwarf
.
attr_address
(
&
unit
low_pc_attr
)
?
{
unit
.
low_pc
=
addr
;
}
}
Ok
(
unit
)
}
pub
fn
unit_ref
<
'
a
>
(
&
'
a
self
dwarf
:
&
'
a
Dwarf
<
R
>
)
-
>
UnitRef
<
'
a
R
>
{
UnitRef
:
:
new
(
dwarf
self
)
}
#
[
inline
]
pub
fn
encoding
(
&
self
)
-
>
Encoding
{
self
.
header
.
encoding
(
)
}
pub
fn
entry
(
&
self
offset
:
UnitOffset
<
R
:
:
Offset
>
)
-
>
Result
<
DebuggingInformationEntry
<
'
_
'
_
R
>
>
{
self
.
header
.
entry
(
&
self
.
abbreviations
offset
)
}
#
[
inline
]
pub
fn
entries
(
&
self
)
-
>
EntriesCursor
<
'
_
'
_
R
>
{
self
.
header
.
entries
(
&
self
.
abbreviations
)
}
#
[
inline
]
pub
fn
entries_at_offset
(
&
self
offset
:
UnitOffset
<
R
:
:
Offset
>
)
-
>
Result
<
EntriesCursor
<
'
_
'
_
R
>
>
{
self
.
header
.
entries_at_offset
(
&
self
.
abbreviations
offset
)
}
#
[
inline
]
pub
fn
entries_tree
(
&
self
offset
:
Option
<
UnitOffset
<
R
:
:
Offset
>
>
)
-
>
Result
<
EntriesTree
<
'
_
'
_
R
>
>
{
self
.
header
.
entries_tree
(
&
self
.
abbreviations
offset
)
}
#
[
inline
]
pub
fn
entries_raw
(
&
self
offset
:
Option
<
UnitOffset
<
R
:
:
Offset
>
>
)
-
>
Result
<
EntriesRaw
<
'
_
'
_
R
>
>
{
self
.
header
.
entries_raw
(
&
self
.
abbreviations
offset
)
}
pub
fn
copy_relocated_attributes
(
&
mut
self
other
:
&
Unit
<
R
>
)
{
self
.
low_pc
=
other
.
low_pc
;
self
.
addr_base
=
other
.
addr_base
;
if
self
.
header
.
version
(
)
<
5
{
self
.
rnglists_base
=
other
.
rnglists_base
;
}
}
pub
fn
dwo_name
(
&
self
)
-
>
Result
<
Option
<
AttributeValue
<
R
>
>
>
{
let
mut
entries
=
self
.
entries
(
)
;
entries
.
next_entry
(
)
?
;
let
entry
=
entries
.
current
(
)
.
ok_or
(
Error
:
:
MissingUnitDie
)
?
;
if
self
.
header
.
version
(
)
<
5
{
entry
.
attr_value
(
constants
:
:
DW_AT_GNU_dwo_name
)
}
else
{
entry
.
attr_value
(
constants
:
:
DW_AT_dwo_name
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
UnitRef
<
'
a
R
:
Reader
>
{
pub
dwarf
:
&
'
a
Dwarf
<
R
>
pub
unit
:
&
'
a
Unit
<
R
>
}
impl
<
'
a
R
:
Reader
>
Clone
for
UnitRef
<
'
a
R
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
'
a
R
:
Reader
>
Copy
for
UnitRef
<
'
a
R
>
{
}
impl
<
'
a
R
:
Reader
>
core
:
:
ops
:
:
Deref
for
UnitRef
<
'
a
R
>
{
type
Target
=
Unit
<
R
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
self
.
unit
}
}
impl
<
'
a
R
:
Reader
>
UnitRef
<
'
a
R
>
{
pub
fn
new
(
dwarf
:
&
'
a
Dwarf
<
R
>
unit
:
&
'
a
Unit
<
R
>
)
-
>
Self
{
UnitRef
{
dwarf
unit
}
}
#
[
inline
]
pub
fn
string_offset
(
&
self
index
:
DebugStrOffsetsIndex
<
R
:
:
Offset
>
)
-
>
Result
<
DebugStrOffset
<
R
:
:
Offset
>
>
{
self
.
dwarf
.
string_offset
(
self
.
unit
index
)
}
#
[
inline
]
pub
fn
string
(
&
self
offset
:
DebugStrOffset
<
R
:
:
Offset
>
)
-
>
Result
<
R
>
{
self
.
dwarf
.
string
(
offset
)
}
#
[
inline
]
pub
fn
line_string
(
&
self
offset
:
DebugLineStrOffset
<
R
:
:
Offset
>
)
-
>
Result
<
R
>
{
self
.
dwarf
.
line_string
(
offset
)
}
#
[
inline
]
pub
fn
sup_string
(
&
self
offset
:
DebugStrOffset
<
R
:
:
Offset
>
)
-
>
Result
<
R
>
{
self
.
dwarf
.
sup_string
(
offset
)
}
pub
fn
attr_string
(
&
self
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
R
>
{
self
.
dwarf
.
attr_string
(
self
.
unit
attr
)
}
pub
fn
address
(
&
self
index
:
DebugAddrIndex
<
R
:
:
Offset
>
)
-
>
Result
<
u64
>
{
self
.
dwarf
.
address
(
self
.
unit
index
)
}
pub
fn
attr_address
(
&
self
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
Option
<
u64
>
>
{
self
.
dwarf
.
attr_address
(
self
.
unit
attr
)
}
pub
fn
ranges_offset_from_raw
(
&
self
offset
:
RawRangeListsOffset
<
R
:
:
Offset
>
)
-
>
RangeListsOffset
<
R
:
:
Offset
>
{
self
.
dwarf
.
ranges_offset_from_raw
(
self
.
unit
offset
)
}
pub
fn
ranges_offset
(
&
self
index
:
DebugRngListsIndex
<
R
:
:
Offset
>
)
-
>
Result
<
RangeListsOffset
<
R
:
:
Offset
>
>
{
self
.
dwarf
.
ranges_offset
(
self
.
unit
index
)
}
pub
fn
ranges
(
&
self
offset
:
RangeListsOffset
<
R
:
:
Offset
>
)
-
>
Result
<
RngListIter
<
R
>
>
{
self
.
dwarf
.
ranges
(
self
.
unit
offset
)
}
pub
fn
raw_ranges
(
&
self
offset
:
RangeListsOffset
<
R
:
:
Offset
>
)
-
>
Result
<
RawRngListIter
<
R
>
>
{
self
.
dwarf
.
raw_ranges
(
self
.
unit
offset
)
}
pub
fn
attr_ranges_offset
(
&
self
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
Option
<
RangeListsOffset
<
R
:
:
Offset
>
>
>
{
self
.
dwarf
.
attr_ranges_offset
(
self
.
unit
attr
)
}
pub
fn
attr_ranges
(
&
self
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
Option
<
RngListIter
<
R
>
>
>
{
self
.
dwarf
.
attr_ranges
(
self
.
unit
attr
)
}
pub
fn
die_ranges
(
&
self
entry
:
&
DebuggingInformationEntry
<
'
_
'
_
R
>
)
-
>
Result
<
RangeIter
<
R
>
>
{
self
.
dwarf
.
die_ranges
(
self
.
unit
entry
)
}
pub
fn
unit_ranges
(
&
self
)
-
>
Result
<
RangeIter
<
R
>
>
{
self
.
dwarf
.
unit_ranges
(
self
.
unit
)
}
pub
fn
locations_offset
(
&
self
index
:
DebugLocListsIndex
<
R
:
:
Offset
>
)
-
>
Result
<
LocationListsOffset
<
R
:
:
Offset
>
>
{
self
.
dwarf
.
locations_offset
(
self
.
unit
index
)
}
pub
fn
locations
(
&
self
offset
:
LocationListsOffset
<
R
:
:
Offset
>
)
-
>
Result
<
LocListIter
<
R
>
>
{
self
.
dwarf
.
locations
(
self
.
unit
offset
)
}
pub
fn
raw_locations
(
&
self
offset
:
LocationListsOffset
<
R
:
:
Offset
>
)
-
>
Result
<
RawLocListIter
<
R
>
>
{
self
.
dwarf
.
raw_locations
(
self
.
unit
offset
)
}
pub
fn
attr_locations_offset
(
&
self
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
Option
<
LocationListsOffset
<
R
:
:
Offset
>
>
>
{
self
.
dwarf
.
attr_locations_offset
(
self
.
unit
attr
)
}
pub
fn
attr_locations
(
&
self
attr
:
AttributeValue
<
R
>
)
-
>
Result
<
Option
<
LocListIter
<
R
>
>
>
{
self
.
dwarf
.
attr_locations
(
self
.
unit
attr
)
}
}
impl
<
T
:
ReaderOffset
>
UnitSectionOffset
<
T
>
{
pub
fn
to_unit_offset
<
R
>
(
&
self
unit
:
&
Unit
<
R
>
)
-
>
Option
<
UnitOffset
<
T
>
>
where
R
:
Reader
<
Offset
=
T
>
{
let
(
offset
unit_offset
)
=
match
(
self
unit
.
header
.
offset
(
)
)
{
(
UnitSectionOffset
:
:
DebugInfoOffset
(
offset
)
UnitSectionOffset
:
:
DebugInfoOffset
(
unit_offset
)
)
=
>
(
offset
.
0
unit_offset
.
0
)
(
UnitSectionOffset
:
:
DebugTypesOffset
(
offset
)
UnitSectionOffset
:
:
DebugTypesOffset
(
unit_offset
)
)
=
>
(
offset
.
0
unit_offset
.
0
)
_
=
>
return
None
}
;
let
offset
=
match
offset
.
checked_sub
(
unit_offset
)
{
Some
(
offset
)
=
>
UnitOffset
(
offset
)
None
=
>
return
None
}
;
if
!
unit
.
header
.
is_valid_offset
(
offset
)
{
return
None
;
}
Some
(
offset
)
}
}
impl
<
T
:
ReaderOffset
>
UnitOffset
<
T
>
{
pub
fn
to_unit_section_offset
<
R
>
(
&
self
unit
:
&
Unit
<
R
>
)
-
>
UnitSectionOffset
<
T
>
where
R
:
Reader
<
Offset
=
T
>
{
match
unit
.
header
.
offset
(
)
{
UnitSectionOffset
:
:
DebugInfoOffset
(
unit_offset
)
=
>
{
DebugInfoOffset
(
unit_offset
.
0
+
self
.
0
)
.
into
(
)
}
UnitSectionOffset
:
:
DebugTypesOffset
(
unit_offset
)
=
>
{
DebugTypesOffset
(
unit_offset
.
0
+
self
.
0
)
.
into
(
)
}
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
RangeIter
<
R
:
Reader
>
(
RangeIterInner
<
R
>
)
;
#
[
derive
(
Debug
)
]
enum
RangeIterInner
<
R
:
Reader
>
{
Single
(
Option
<
Range
>
)
List
(
RngListIter
<
R
>
)
}
impl
<
R
:
Reader
>
Default
for
RangeIter
<
R
>
{
fn
default
(
)
-
>
Self
{
RangeIter
(
RangeIterInner
:
:
Single
(
None
)
)
}
}
impl
<
R
:
Reader
>
RangeIter
<
R
>
{
pub
fn
next
(
&
mut
self
)
-
>
Result
<
Option
<
Range
>
>
{
match
self
.
0
{
RangeIterInner
:
:
Single
(
ref
mut
range
)
=
>
Ok
(
range
.
take
(
)
)
RangeIterInner
:
:
List
(
ref
mut
list
)
=
>
list
.
next
(
)
}
}
}
#
[
cfg
(
feature
=
"
fallible
-
iterator
"
)
]
impl
<
R
:
Reader
>
fallible_iterator
:
:
FallibleIterator
for
RangeIter
<
R
>
{
type
Item
=
Range
;
type
Error
=
Error
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
:
:
core
:
:
result
:
:
Result
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
{
RangeIter
:
:
next
(
self
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
read
:
:
EndianSlice
;
use
crate
:
:
{
Endianity
LittleEndian
}
;
#
[
test
]
fn
test_dwarf_variance
(
)
{
fn
_f
<
'
a
:
'
b
'
b
E
:
Endianity
>
(
x
:
Dwarf
<
EndianSlice
<
'
a
E
>
>
)
-
>
Dwarf
<
EndianSlice
<
'
b
E
>
>
{
x
}
}
#
[
test
]
fn
test_dwarf_unit_variance
(
)
{
fn
_f
<
'
a
:
'
b
'
b
E
:
Endianity
>
(
x
:
Unit
<
EndianSlice
<
'
a
E
>
>
)
-
>
Unit
<
EndianSlice
<
'
b
E
>
>
{
x
}
}
#
[
test
]
fn
test_send
(
)
{
fn
assert_is_send
<
T
:
Send
>
(
)
{
}
assert_is_send
:
:
<
Dwarf
<
EndianSlice
<
'
_
LittleEndian
>
>
>
(
)
;
assert_is_send
:
:
<
Unit
<
EndianSlice
<
'
_
LittleEndian
>
>
>
(
)
;
}
#
[
test
]
fn
test_format_error
(
)
{
let
dwarf_sections
=
DwarfSections
:
:
load
(
|
_
|
-
>
Result
<
_
>
{
Ok
(
vec
!
[
1
2
]
)
}
)
.
unwrap
(
)
;
let
sup_sections
=
DwarfSections
:
:
load
(
|
_
|
-
>
Result
<
_
>
{
Ok
(
vec
!
[
1
2
]
)
}
)
.
unwrap
(
)
;
let
dwarf
=
dwarf_sections
.
borrow_with_sup
(
&
sup_sections
|
section
|
{
EndianSlice
:
:
new
(
section
LittleEndian
)
}
)
;
match
dwarf
.
debug_str
.
get_str
(
DebugStrOffset
(
1
)
)
{
Ok
(
r
)
=
>
panic
!
(
"
Unexpected
str
{
:
?
}
"
r
)
Err
(
e
)
=
>
{
assert_eq
!
(
dwarf
.
format_error
(
e
)
"
Hit
the
end
of
input
before
it
was
expected
at
.
debug_str
+
0x1
"
)
;
}
}
match
dwarf
.
sup
(
)
.
unwrap
(
)
.
debug_str
.
get_str
(
DebugStrOffset
(
1
)
)
{
Ok
(
r
)
=
>
panic
!
(
"
Unexpected
str
{
:
?
}
"
r
)
Err
(
e
)
=
>
{
assert_eq
!
(
dwarf
.
format_error
(
e
)
"
Hit
the
end
of
input
before
it
was
expected
at
.
debug_str
(
sup
)
+
0x1
"
)
;
}
}
assert_eq
!
(
dwarf
.
format_error
(
Error
:
:
Io
)
Error
:
:
Io
.
description
(
)
)
;
}
}
