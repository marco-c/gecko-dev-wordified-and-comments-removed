#
[
cfg
(
feature
=
"
read
"
)
]
use
alloc
:
:
borrow
:
:
Cow
;
use
core
:
:
convert
:
:
TryInto
;
use
core
:
:
fmt
:
:
Debug
;
use
core
:
:
hash
:
:
Hash
;
use
core
:
:
ops
:
:
{
Add
AddAssign
Sub
}
;
use
crate
:
:
common
:
:
Format
;
use
crate
:
:
endianity
:
:
Endianity
;
use
crate
:
:
leb128
;
use
crate
:
:
read
:
:
{
Error
Result
}
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
ReaderOffsetId
(
pub
u64
)
;
pub
trait
ReaderOffset
:
Debug
+
Copy
+
Eq
+
Ord
+
Hash
+
Add
<
Output
=
Self
>
+
AddAssign
+
Sub
<
Output
=
Self
>
{
fn
from_u8
(
offset
:
u8
)
-
>
Self
;
fn
from_u16
(
offset
:
u16
)
-
>
Self
;
fn
from_i16
(
offset
:
i16
)
-
>
Self
;
fn
from_u32
(
offset
:
u32
)
-
>
Self
;
fn
from_u64
(
offset
:
u64
)
-
>
Result
<
Self
>
;
fn
into_u64
(
self
)
-
>
u64
;
fn
wrapping_add
(
self
other
:
Self
)
-
>
Self
;
fn
checked_sub
(
self
other
:
Self
)
-
>
Option
<
Self
>
;
}
impl
ReaderOffset
for
u64
{
#
[
inline
]
fn
from_u8
(
offset
:
u8
)
-
>
Self
{
u64
:
:
from
(
offset
)
}
#
[
inline
]
fn
from_u16
(
offset
:
u16
)
-
>
Self
{
u64
:
:
from
(
offset
)
}
#
[
inline
]
fn
from_i16
(
offset
:
i16
)
-
>
Self
{
offset
as
u64
}
#
[
inline
]
fn
from_u32
(
offset
:
u32
)
-
>
Self
{
u64
:
:
from
(
offset
)
}
#
[
inline
]
fn
from_u64
(
offset
:
u64
)
-
>
Result
<
Self
>
{
Ok
(
offset
)
}
#
[
inline
]
fn
into_u64
(
self
)
-
>
u64
{
self
}
#
[
inline
]
fn
wrapping_add
(
self
other
:
Self
)
-
>
Self
{
self
.
wrapping_add
(
other
)
}
#
[
inline
]
fn
checked_sub
(
self
other
:
Self
)
-
>
Option
<
Self
>
{
self
.
checked_sub
(
other
)
}
}
impl
ReaderOffset
for
u32
{
#
[
inline
]
fn
from_u8
(
offset
:
u8
)
-
>
Self
{
u32
:
:
from
(
offset
)
}
#
[
inline
]
fn
from_u16
(
offset
:
u16
)
-
>
Self
{
u32
:
:
from
(
offset
)
}
#
[
inline
]
fn
from_i16
(
offset
:
i16
)
-
>
Self
{
offset
as
u32
}
#
[
inline
]
fn
from_u32
(
offset
:
u32
)
-
>
Self
{
offset
}
#
[
inline
]
fn
from_u64
(
offset64
:
u64
)
-
>
Result
<
Self
>
{
let
offset
=
offset64
as
u32
;
if
u64
:
:
from
(
offset
)
=
=
offset64
{
Ok
(
offset
)
}
else
{
Err
(
Error
:
:
UnsupportedOffset
)
}
}
#
[
inline
]
fn
into_u64
(
self
)
-
>
u64
{
u64
:
:
from
(
self
)
}
#
[
inline
]
fn
wrapping_add
(
self
other
:
Self
)
-
>
Self
{
self
.
wrapping_add
(
other
)
}
#
[
inline
]
fn
checked_sub
(
self
other
:
Self
)
-
>
Option
<
Self
>
{
self
.
checked_sub
(
other
)
}
}
impl
ReaderOffset
for
usize
{
#
[
inline
]
fn
from_u8
(
offset
:
u8
)
-
>
Self
{
offset
as
usize
}
#
[
inline
]
fn
from_u16
(
offset
:
u16
)
-
>
Self
{
offset
as
usize
}
#
[
inline
]
fn
from_i16
(
offset
:
i16
)
-
>
Self
{
offset
as
usize
}
#
[
inline
]
fn
from_u32
(
offset
:
u32
)
-
>
Self
{
offset
as
usize
}
#
[
inline
]
fn
from_u64
(
offset64
:
u64
)
-
>
Result
<
Self
>
{
let
offset
=
offset64
as
usize
;
if
offset
as
u64
=
=
offset64
{
Ok
(
offset
)
}
else
{
Err
(
Error
:
:
UnsupportedOffset
)
}
}
#
[
inline
]
fn
into_u64
(
self
)
-
>
u64
{
self
as
u64
}
#
[
inline
]
fn
wrapping_add
(
self
other
:
Self
)
-
>
Self
{
self
.
wrapping_add
(
other
)
}
#
[
inline
]
fn
checked_sub
(
self
other
:
Self
)
-
>
Option
<
Self
>
{
self
.
checked_sub
(
other
)
}
}
#
[
cfg
(
not
(
feature
=
"
read
"
)
)
]
pub
(
crate
)
mod
seal_if_no_alloc
{
#
[
derive
(
Debug
)
]
pub
struct
Sealed
;
}
pub
trait
Reader
:
Debug
+
Clone
{
type
Endian
:
Endianity
;
type
Offset
:
ReaderOffset
;
fn
endian
(
&
self
)
-
>
Self
:
:
Endian
;
fn
len
(
&
self
)
-
>
Self
:
:
Offset
;
fn
empty
(
&
mut
self
)
;
fn
truncate
(
&
mut
self
len
:
Self
:
:
Offset
)
-
>
Result
<
(
)
>
;
fn
offset_from
(
&
self
base
:
&
Self
)
-
>
Self
:
:
Offset
;
fn
offset_id
(
&
self
)
-
>
ReaderOffsetId
;
fn
lookup_offset_id
(
&
self
id
:
ReaderOffsetId
)
-
>
Option
<
Self
:
:
Offset
>
;
fn
find
(
&
self
byte
:
u8
)
-
>
Result
<
Self
:
:
Offset
>
;
fn
skip
(
&
mut
self
len
:
Self
:
:
Offset
)
-
>
Result
<
(
)
>
;
fn
split
(
&
mut
self
len
:
Self
:
:
Offset
)
-
>
Result
<
Self
>
;
#
[
cfg
(
not
(
feature
=
"
read
"
)
)
]
fn
cannot_implement
(
)
-
>
seal_if_no_alloc
:
:
Sealed
;
#
[
cfg
(
feature
=
"
read
"
)
]
fn
to_slice
(
&
self
)
-
>
Result
<
Cow
<
'
_
[
u8
]
>
>
;
#
[
cfg
(
feature
=
"
read
"
)
]
fn
to_string
(
&
self
)
-
>
Result
<
Cow
<
'
_
str
>
>
;
#
[
cfg
(
feature
=
"
read
"
)
]
fn
to_string_lossy
(
&
self
)
-
>
Result
<
Cow
<
'
_
str
>
>
;
fn
read_slice
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
>
;
#
[
inline
]
fn
read_u8_array
<
A
>
(
&
mut
self
)
-
>
Result
<
A
>
where
A
:
Sized
+
Default
+
AsMut
<
[
u8
]
>
{
let
mut
val
=
Default
:
:
default
(
)
;
self
.
read_slice
(
<
A
as
AsMut
<
[
u8
]
>
>
:
:
as_mut
(
&
mut
val
)
)
?
;
Ok
(
val
)
}
#
[
inline
]
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
Self
:
:
Offset
:
:
from_u8
(
0
)
}
#
[
inline
]
fn
read_u8
(
&
mut
self
)
-
>
Result
<
u8
>
{
let
a
:
[
u8
;
1
]
=
self
.
read_u8_array
(
)
?
;
Ok
(
a
[
0
]
)
}
#
[
inline
]
fn
read_i8
(
&
mut
self
)
-
>
Result
<
i8
>
{
let
a
:
[
u8
;
1
]
=
self
.
read_u8_array
(
)
?
;
Ok
(
a
[
0
]
as
i8
)
}
#
[
inline
]
fn
read_u16
(
&
mut
self
)
-
>
Result
<
u16
>
{
let
a
:
[
u8
;
2
]
=
self
.
read_u8_array
(
)
?
;
Ok
(
self
.
endian
(
)
.
read_u16
(
&
a
)
)
}
#
[
inline
]
fn
read_i16
(
&
mut
self
)
-
>
Result
<
i16
>
{
let
a
:
[
u8
;
2
]
=
self
.
read_u8_array
(
)
?
;
Ok
(
self
.
endian
(
)
.
read_i16
(
&
a
)
)
}
#
[
inline
]
fn
read_u32
(
&
mut
self
)
-
>
Result
<
u32
>
{
let
a
:
[
u8
;
4
]
=
self
.
read_u8_array
(
)
?
;
Ok
(
self
.
endian
(
)
.
read_u32
(
&
a
)
)
}
#
[
inline
]
fn
read_i32
(
&
mut
self
)
-
>
Result
<
i32
>
{
let
a
:
[
u8
;
4
]
=
self
.
read_u8_array
(
)
?
;
Ok
(
self
.
endian
(
)
.
read_i32
(
&
a
)
)
}
#
[
inline
]
fn
read_u64
(
&
mut
self
)
-
>
Result
<
u64
>
{
let
a
:
[
u8
;
8
]
=
self
.
read_u8_array
(
)
?
;
Ok
(
self
.
endian
(
)
.
read_u64
(
&
a
)
)
}
#
[
inline
]
fn
read_i64
(
&
mut
self
)
-
>
Result
<
i64
>
{
let
a
:
[
u8
;
8
]
=
self
.
read_u8_array
(
)
?
;
Ok
(
self
.
endian
(
)
.
read_i64
(
&
a
)
)
}
#
[
inline
]
fn
read_f32
(
&
mut
self
)
-
>
Result
<
f32
>
{
let
a
:
[
u8
;
4
]
=
self
.
read_u8_array
(
)
?
;
Ok
(
self
.
endian
(
)
.
read_f32
(
&
a
)
)
}
#
[
inline
]
fn
read_f64
(
&
mut
self
)
-
>
Result
<
f64
>
{
let
a
:
[
u8
;
8
]
=
self
.
read_u8_array
(
)
?
;
Ok
(
self
.
endian
(
)
.
read_f64
(
&
a
)
)
}
#
[
inline
]
fn
read_uint
(
&
mut
self
n
:
usize
)
-
>
Result
<
u64
>
{
let
mut
buf
=
[
0
;
8
]
;
self
.
read_slice
(
&
mut
buf
[
.
.
n
]
)
?
;
Ok
(
self
.
endian
(
)
.
read_uint
(
&
buf
[
.
.
n
]
)
)
}
fn
read_null_terminated_slice
(
&
mut
self
)
-
>
Result
<
Self
>
{
let
idx
=
self
.
find
(
0
)
?
;
let
val
=
self
.
split
(
idx
)
?
;
self
.
skip
(
Self
:
:
Offset
:
:
from_u8
(
1
)
)
?
;
Ok
(
val
)
}
fn
skip_leb128
(
&
mut
self
)
-
>
Result
<
(
)
>
{
leb128
:
:
read
:
:
skip
(
self
)
}
fn
read_uleb128
(
&
mut
self
)
-
>
Result
<
u64
>
{
leb128
:
:
read
:
:
unsigned
(
self
)
}
fn
read_uleb128_u32
(
&
mut
self
)
-
>
Result
<
u32
>
{
leb128
:
:
read
:
:
unsigned
(
self
)
?
.
try_into
(
)
.
map_err
(
|
_
|
Error
:
:
BadUnsignedLeb128
)
}
fn
read_uleb128_u16
(
&
mut
self
)
-
>
Result
<
u16
>
{
leb128
:
:
read
:
:
u16
(
self
)
}
fn
read_sleb128
(
&
mut
self
)
-
>
Result
<
i64
>
{
leb128
:
:
read
:
:
signed
(
self
)
}
fn
read_initial_length
(
&
mut
self
)
-
>
Result
<
(
Self
:
:
Offset
Format
)
>
{
const
MAX_DWARF_32_UNIT_LENGTH
:
u32
=
0xffff_fff0
;
const
DWARF_64_INITIAL_UNIT_LENGTH
:
u32
=
0xffff_ffff
;
let
val
=
self
.
read_u32
(
)
?
;
if
val
<
MAX_DWARF_32_UNIT_LENGTH
{
Ok
(
(
Self
:
:
Offset
:
:
from_u32
(
val
)
Format
:
:
Dwarf32
)
)
}
else
if
val
=
=
DWARF_64_INITIAL_UNIT_LENGTH
{
let
val
=
self
.
read_u64
(
)
.
and_then
(
Self
:
:
Offset
:
:
from_u64
)
?
;
Ok
(
(
val
Format
:
:
Dwarf64
)
)
}
else
{
Err
(
Error
:
:
UnknownReservedLength
)
}
}
fn
read_address
(
&
mut
self
address_size
:
u8
)
-
>
Result
<
u64
>
{
match
address_size
{
1
=
>
self
.
read_u8
(
)
.
map
(
u64
:
:
from
)
2
=
>
self
.
read_u16
(
)
.
map
(
u64
:
:
from
)
4
=
>
self
.
read_u32
(
)
.
map
(
u64
:
:
from
)
8
=
>
self
.
read_u64
(
)
otherwise
=
>
Err
(
Error
:
:
UnsupportedAddressSize
(
otherwise
)
)
}
}
fn
read_word
(
&
mut
self
format
:
Format
)
-
>
Result
<
Self
:
:
Offset
>
{
match
format
{
Format
:
:
Dwarf32
=
>
self
.
read_u32
(
)
.
map
(
Self
:
:
Offset
:
:
from_u32
)
Format
:
:
Dwarf64
=
>
self
.
read_u64
(
)
.
and_then
(
Self
:
:
Offset
:
:
from_u64
)
}
}
#
[
inline
]
fn
read_length
(
&
mut
self
format
:
Format
)
-
>
Result
<
Self
:
:
Offset
>
{
self
.
read_word
(
format
)
}
#
[
inline
]
fn
read_offset
(
&
mut
self
format
:
Format
)
-
>
Result
<
Self
:
:
Offset
>
{
self
.
read_word
(
format
)
}
fn
read_sized_offset
(
&
mut
self
size
:
u8
)
-
>
Result
<
Self
:
:
Offset
>
{
match
size
{
1
=
>
self
.
read_u8
(
)
.
map
(
u64
:
:
from
)
2
=
>
self
.
read_u16
(
)
.
map
(
u64
:
:
from
)
4
=
>
self
.
read_u32
(
)
.
map
(
u64
:
:
from
)
8
=
>
self
.
read_u64
(
)
otherwise
=
>
Err
(
Error
:
:
UnsupportedOffsetSize
(
otherwise
)
)
}
.
and_then
(
Self
:
:
Offset
:
:
from_u64
)
}
}
