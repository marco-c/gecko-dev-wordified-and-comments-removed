use
crate
:
:
common
:
:
{
DebugLineStrOffset
DebugStrOffset
DebugStrOffsetsBase
DebugStrOffsetsIndex
DwarfFileType
Encoding
SectionId
}
;
use
crate
:
:
endianity
:
:
Endianity
;
use
crate
:
:
read
:
:
{
EndianSlice
Reader
ReaderOffset
Result
Section
}
;
use
crate
:
:
Format
;
#
[
derive
(
Debug
Default
Clone
Copy
)
]
pub
struct
DebugStr
<
R
>
{
debug_str_section
:
R
}
impl
<
'
input
Endian
>
DebugStr
<
EndianSlice
<
'
input
Endian
>
>
where
Endian
:
Endianity
{
pub
fn
new
(
debug_str_section
:
&
'
input
[
u8
]
endian
:
Endian
)
-
>
Self
{
Self
:
:
from
(
EndianSlice
:
:
new
(
debug_str_section
endian
)
)
}
}
impl
<
R
:
Reader
>
DebugStr
<
R
>
{
pub
fn
get_str
(
&
self
offset
:
DebugStrOffset
<
R
:
:
Offset
>
)
-
>
Result
<
R
>
{
let
input
=
&
mut
self
.
debug_str_section
.
clone
(
)
;
input
.
skip
(
offset
.
0
)
?
;
input
.
read_null_terminated_slice
(
)
}
}
impl
<
T
>
DebugStr
<
T
>
{
pub
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
)
-
>
DebugStr
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
borrow
(
&
self
.
debug_str_section
)
.
into
(
)
}
}
impl
<
R
>
Section
<
R
>
for
DebugStr
<
R
>
{
fn
id
(
)
-
>
SectionId
{
SectionId
:
:
DebugStr
}
fn
reader
(
&
self
)
-
>
&
R
{
&
self
.
debug_str_section
}
}
impl
<
R
>
From
<
R
>
for
DebugStr
<
R
>
{
fn
from
(
debug_str_section
:
R
)
-
>
Self
{
DebugStr
{
debug_str_section
}
}
}
#
[
derive
(
Debug
Default
Clone
Copy
)
]
pub
struct
DebugStrOffsets
<
R
>
{
section
:
R
}
impl
<
R
:
Reader
>
DebugStrOffsets
<
R
>
{
pub
fn
get_str_offset
(
&
self
format
:
Format
base
:
DebugStrOffsetsBase
<
R
:
:
Offset
>
index
:
DebugStrOffsetsIndex
<
R
:
:
Offset
>
)
-
>
Result
<
DebugStrOffset
<
R
:
:
Offset
>
>
{
let
input
=
&
mut
self
.
section
.
clone
(
)
;
input
.
skip
(
base
.
0
)
?
;
input
.
skip
(
R
:
:
Offset
:
:
from_u64
(
index
.
0
.
into_u64
(
)
*
u64
:
:
from
(
format
.
word_size
(
)
)
)
?
)
?
;
input
.
read_offset
(
format
)
.
map
(
DebugStrOffset
)
}
}
impl
<
T
>
DebugStrOffsets
<
T
>
{
pub
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
)
-
>
DebugStrOffsets
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
borrow
(
&
self
.
section
)
.
into
(
)
}
}
impl
<
R
>
Section
<
R
>
for
DebugStrOffsets
<
R
>
{
fn
id
(
)
-
>
SectionId
{
SectionId
:
:
DebugStrOffsets
}
fn
reader
(
&
self
)
-
>
&
R
{
&
self
.
section
}
}
impl
<
R
>
From
<
R
>
for
DebugStrOffsets
<
R
>
{
fn
from
(
section
:
R
)
-
>
Self
{
DebugStrOffsets
{
section
}
}
}
impl
<
Offset
>
DebugStrOffsetsBase
<
Offset
>
where
Offset
:
ReaderOffset
{
pub
fn
default_for_encoding_and_file
(
encoding
:
Encoding
file_type
:
DwarfFileType
)
-
>
DebugStrOffsetsBase
<
Offset
>
{
if
encoding
.
version
>
=
5
&
&
file_type
=
=
DwarfFileType
:
:
Dwo
{
DebugStrOffsetsBase
(
Offset
:
:
from_u8
(
encoding
.
format
.
initial_length_size
(
)
+
2
+
2
)
)
}
else
{
DebugStrOffsetsBase
(
Offset
:
:
from_u8
(
0
)
)
}
}
}
#
[
derive
(
Debug
Default
Clone
Copy
)
]
pub
struct
DebugLineStr
<
R
>
{
section
:
R
}
impl
<
'
input
Endian
>
DebugLineStr
<
EndianSlice
<
'
input
Endian
>
>
where
Endian
:
Endianity
{
pub
fn
new
(
debug_line_str_section
:
&
'
input
[
u8
]
endian
:
Endian
)
-
>
Self
{
Self
:
:
from
(
EndianSlice
:
:
new
(
debug_line_str_section
endian
)
)
}
}
impl
<
R
:
Reader
>
DebugLineStr
<
R
>
{
pub
fn
get_str
(
&
self
offset
:
DebugLineStrOffset
<
R
:
:
Offset
>
)
-
>
Result
<
R
>
{
let
input
=
&
mut
self
.
section
.
clone
(
)
;
input
.
skip
(
offset
.
0
)
?
;
input
.
read_null_terminated_slice
(
)
}
}
impl
<
T
>
DebugLineStr
<
T
>
{
pub
fn
borrow
<
'
a
F
R
>
(
&
'
a
self
mut
borrow
:
F
)
-
>
DebugLineStr
<
R
>
where
F
:
FnMut
(
&
'
a
T
)
-
>
R
{
borrow
(
&
self
.
section
)
.
into
(
)
}
}
impl
<
R
>
Section
<
R
>
for
DebugLineStr
<
R
>
{
fn
id
(
)
-
>
SectionId
{
SectionId
:
:
DebugLineStr
}
fn
reader
(
&
self
)
-
>
&
R
{
&
self
.
section
}
}
impl
<
R
>
From
<
R
>
for
DebugLineStr
<
R
>
{
fn
from
(
section
:
R
)
-
>
Self
{
DebugLineStr
{
section
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
test_util
:
:
GimliSectionMethods
;
use
crate
:
:
LittleEndian
;
use
test_assembler
:
:
{
Endian
Label
LabelMaker
Section
}
;
#
[
test
]
fn
test_get_str_offset
(
)
{
for
format
in
[
Format
:
:
Dwarf32
Format
:
:
Dwarf64
]
{
let
zero
=
Label
:
:
new
(
)
;
let
length
=
Label
:
:
new
(
)
;
let
start
=
Label
:
:
new
(
)
;
let
first
=
Label
:
:
new
(
)
;
let
end
=
Label
:
:
new
(
)
;
let
mut
section
=
Section
:
:
with_endian
(
Endian
:
:
Little
)
.
mark
(
&
zero
)
.
initial_length
(
format
&
length
&
start
)
.
D16
(
5
)
.
D16
(
0
)
.
mark
(
&
first
)
;
for
i
in
0
.
.
20
{
section
=
section
.
word
(
format
.
word_size
(
)
1000
+
i
)
;
}
section
=
section
.
mark
(
&
end
)
;
length
.
set_const
(
(
&
end
-
&
start
)
as
u64
)
;
let
section
=
section
.
get_contents
(
)
.
unwrap
(
)
;
let
debug_str_offsets
=
DebugStrOffsets
:
:
from
(
EndianSlice
:
:
new
(
&
section
LittleEndian
)
)
;
let
base
=
DebugStrOffsetsBase
(
(
&
first
-
&
zero
)
as
usize
)
;
assert_eq
!
(
debug_str_offsets
.
get_str_offset
(
format
base
DebugStrOffsetsIndex
(
0
)
)
Ok
(
DebugStrOffset
(
1000
)
)
)
;
assert_eq
!
(
debug_str_offsets
.
get_str_offset
(
format
base
DebugStrOffsetsIndex
(
19
)
)
Ok
(
DebugStrOffset
(
1019
)
)
)
;
}
}
}
