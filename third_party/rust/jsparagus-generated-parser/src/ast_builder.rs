use
crate
:
:
declaration_kind
:
:
DeclarationKind
;
use
crate
:
:
early_errors
:
:
*
;
use
crate
:
:
error
:
:
{
ParseError
Result
}
;
use
crate
:
:
Token
;
use
ast
:
:
{
arena
source_atom_set
:
:
{
CommonSourceAtomSetIndices
SourceAtomSet
SourceAtomSetIndex
}
source_location_accessor
:
:
SourceLocationAccessor
source_slice_list
:
:
SourceSliceList
types
:
:
*
SourceLocation
}
;
use
bumpalo
:
:
{
vec
Bump
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
rc
:
:
Rc
;
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
enum
BindingKind
{
Unknown
Var
Function
AsyncOrGenerator
Let
Const
Class
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
struct
BindingInfo
{
name
:
SourceAtomSetIndex
offset
:
usize
kind
:
BindingKind
}
pub
struct
AstBuilder
<
'
alloc
>
{
pub
allocator
:
&
'
alloc
Bump
bindings
:
Vec
<
BindingInfo
>
atoms
:
Rc
<
RefCell
<
SourceAtomSet
<
'
alloc
>
>
>
slices
:
Rc
<
RefCell
<
SourceSliceList
<
'
alloc
>
>
>
}
pub
trait
AstBuilderDelegate
<
'
alloc
>
{
fn
ast_builder_refmut
(
&
mut
self
)
-
>
&
mut
AstBuilder
<
'
alloc
>
;
}
impl
<
'
alloc
>
AstBuilder
<
'
alloc
>
{
pub
fn
new
(
allocator
:
&
'
alloc
Bump
atoms
:
Rc
<
RefCell
<
SourceAtomSet
<
'
alloc
>
>
>
slices
:
Rc
<
RefCell
<
SourceSliceList
<
'
alloc
>
>
>
)
-
>
Self
{
Self
{
allocator
bindings
:
Vec
:
:
new
(
)
atoms
slices
}
}
pub
fn
alloc
<
T
>
(
&
self
value
:
T
)
-
>
arena
:
:
Box
<
'
alloc
T
>
{
arena
:
:
alloc
(
self
.
allocator
value
)
}
pub
fn
alloc_str
(
&
self
s
:
&
str
)
-
>
&
'
alloc
str
{
arena
:
:
alloc_str
(
self
.
allocator
s
)
}
fn
new_vec
<
T
>
(
&
self
)
-
>
arena
:
:
Vec
<
'
alloc
T
>
{
arena
:
:
Vec
:
:
new_in
(
self
.
allocator
)
}
fn
new_vec_single
<
T
>
(
&
self
value
:
T
)
-
>
arena
:
:
Vec
<
'
alloc
T
>
{
vec
!
[
in
self
.
allocator
;
value
]
}
fn
collect_vec_from_results
<
T
C
>
(
&
self
results
:
C
)
-
>
Result
<
'
alloc
arena
:
:
Vec
<
'
alloc
T
>
>
where
C
:
IntoIterator
<
Item
=
Result
<
'
alloc
T
>
>
{
let
mut
out
=
self
.
new_vec
(
)
;
for
result
in
results
{
out
.
push
(
result
?
)
;
}
Ok
(
out
)
}
fn
push
<
T
>
(
&
self
list
:
&
mut
arena
:
:
Vec
<
'
alloc
T
>
value
:
T
)
{
list
.
push
(
value
)
;
}
fn
append
<
T
>
(
&
self
list
:
&
mut
arena
:
:
Vec
<
'
alloc
T
>
elements
:
&
mut
arena
:
:
Vec
<
'
alloc
T
>
)
{
list
.
append
(
elements
)
;
}
pub
fn
identifier_reference
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Identifier
>
>
{
self
.
on_identifier_reference
(
&
token
)
?
;
Ok
(
self
.
alloc
(
self
.
identifier
(
token
)
)
)
}
pub
fn
binding_identifier
(
&
mut
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
{
self
.
on_binding_identifier
(
&
token
)
?
;
let
loc
=
token
.
loc
;
Ok
(
self
.
alloc
(
BindingIdentifier
{
name
:
self
.
identifier
(
token
)
loc
}
)
)
}
pub
fn
binding_identifier_yield
(
&
mut
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
{
self
.
on_binding_identifier
(
&
token
)
?
;
let
loc
=
token
.
loc
;
Ok
(
self
.
alloc
(
BindingIdentifier
{
name
:
Identifier
{
value
:
CommonSourceAtomSetIndices
:
:
yield_
(
)
loc
}
loc
}
)
)
}
pub
fn
binding_identifier_await
(
&
mut
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
{
self
.
on_binding_identifier
(
&
token
)
?
;
let
loc
=
token
.
loc
;
Ok
(
self
.
alloc
(
BindingIdentifier
{
name
:
Identifier
{
value
:
CommonSourceAtomSetIndices
:
:
await_
(
)
loc
}
loc
}
)
)
}
pub
fn
label_identifier
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Label
>
>
{
self
.
on_label_identifier
(
&
token
)
?
;
let
loc
=
token
.
loc
;
Ok
(
self
.
alloc
(
Label
{
value
:
token
.
value
.
as_atom
(
)
loc
}
)
)
}
pub
fn
this_expr
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
loc
=
token
.
loc
;
self
.
alloc
(
Expression
:
:
ThisExpression
{
loc
}
)
}
pub
fn
identifier_expr
(
&
self
name
:
arena
:
:
Box
<
'
alloc
Identifier
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
loc
=
name
.
loc
;
self
.
alloc
(
Expression
:
:
IdentifierExpression
(
IdentifierExpression
{
name
:
name
.
unbox
(
)
loc
}
)
)
}
pub
fn
regexp_literal
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
source
=
self
.
slices
.
borrow
(
)
.
get
(
token
.
value
.
as_slice
(
)
)
;
debug_assert
!
(
source
.
chars
(
)
.
nth
(
0
)
.
unwrap
(
)
=
=
'
/
'
)
;
let
end
=
source
.
rfind
(
'
/
'
)
.
unwrap
(
)
;
let
pattern
=
self
.
slices
.
borrow_mut
(
)
.
insert
(
&
source
[
1
.
.
end
]
)
;
let
flags
=
&
source
[
end
+
1
.
.
]
;
let
mut
global
:
bool
=
false
;
let
mut
ignore_case
:
bool
=
false
;
let
mut
multi_line
:
bool
=
false
;
let
mut
dot_all
:
bool
=
false
;
let
mut
unicode
:
bool
=
false
;
let
mut
sticky
:
bool
=
false
;
for
c
in
flags
.
chars
(
)
{
if
c
=
=
'
g
'
{
global
=
true
;
}
if
c
=
=
'
i
'
{
ignore_case
=
true
;
}
if
c
=
=
'
m
'
{
multi_line
=
true
;
}
if
c
=
=
'
s
'
{
dot_all
=
true
;
}
if
c
=
=
'
u
'
{
unicode
=
true
;
}
if
c
=
=
'
y
'
{
sticky
=
true
;
}
}
let
loc
=
token
.
loc
;
self
.
alloc
(
Expression
:
:
LiteralRegExpExpression
{
pattern
global
ignore_case
multi_line
dot_all
sticky
unicode
loc
}
)
}
pub
fn
untagged_template_expr
(
&
self
template_literal
:
arena
:
:
Box
<
'
alloc
TemplateExpression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
self
.
alloc
(
Expression
:
:
TemplateExpression
(
template_literal
.
unbox
(
)
)
)
}
pub
fn
uncover_parenthesized_expression
(
&
self
parenthesized
:
arena
:
:
Box
<
'
alloc
CoverParenthesized
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
match
parenthesized
.
unbox
(
)
{
CoverParenthesized
:
:
Expression
{
expression
.
.
}
=
>
{
Ok
(
expression
)
}
CoverParenthesized
:
:
Parameters
(
_parameters
)
=
>
Err
(
ParseError
:
:
NotImplemented
(
"
parenthesized
expression
with
.
.
.
should
be
a
syntax
error
"
)
)
}
}
pub
fn
cover_parenthesized_expression
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
CoverParenthesized
<
'
alloc
>
>
{
self
.
alloc
(
CoverParenthesized
:
:
Expression
{
expression
loc
:
SourceLocation
:
:
from_parts
(
open_token
.
loc
close_token
.
loc
)
}
)
}
pub
fn
empty_parameter_list
(
&
self
)
-
>
arena
:
:
Vec
<
'
alloc
Parameter
<
'
alloc
>
>
{
self
.
new_vec
(
)
}
fn
assignment_target_maybe_default_to_binding
(
&
self
target
:
AssignmentTargetMaybeDefault
<
'
alloc
>
)
-
>
Result
<
'
alloc
Parameter
<
'
alloc
>
>
{
match
target
{
AssignmentTargetMaybeDefault
:
:
AssignmentTarget
(
target
)
=
>
Ok
(
Parameter
:
:
Binding
(
self
.
assignment_target_to_binding
(
target
)
?
)
)
AssignmentTargetMaybeDefault
:
:
AssignmentTargetWithDefault
(
AssignmentTargetWithDefault
{
binding
init
loc
}
)
=
>
Ok
(
Parameter
:
:
BindingWithDefault
(
BindingWithDefault
{
binding
:
self
.
assignment_target_to_binding
(
binding
)
?
init
loc
}
)
)
}
}
fn
assignment_target_property_to_binding_property
(
&
self
target
:
AssignmentTargetProperty
<
'
alloc
>
)
-
>
Result
<
'
alloc
BindingProperty
<
'
alloc
>
>
{
Ok
(
match
target
{
AssignmentTargetProperty
:
:
AssignmentTargetPropertyIdentifier
(
AssignmentTargetPropertyIdentifier
{
binding
:
AssignmentTargetIdentifier
{
name
loc
}
init
loc
:
loc2
}
)
=
>
BindingProperty
:
:
BindingPropertyIdentifier
(
BindingPropertyIdentifier
{
binding
:
BindingIdentifier
{
name
loc
}
init
loc
:
loc2
}
)
AssignmentTargetProperty
:
:
AssignmentTargetPropertyProperty
(
AssignmentTargetPropertyProperty
{
name
binding
loc
}
)
=
>
BindingProperty
:
:
BindingPropertyProperty
(
BindingPropertyProperty
{
name
binding
:
self
.
assignment_target_maybe_default_to_binding
(
binding
)
?
loc
}
)
}
)
}
fn
assignment_rest_property_to_binding_identifier
(
&
self
target
:
AssignmentTarget
<
'
alloc
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
{
match
target
{
AssignmentTarget
:
:
SimpleAssignmentTarget
(
SimpleAssignmentTarget
:
:
AssignmentTargetIdentifier
(
AssignmentTargetIdentifier
{
name
loc
}
)
)
=
>
Ok
(
self
.
alloc
(
BindingIdentifier
{
name
loc
}
)
)
_
=
>
Err
(
ParseError
:
:
ObjectBindingPatternWithInvalidRest
)
}
}
fn
assignment_target_to_binding
(
&
self
target
:
AssignmentTarget
<
'
alloc
>
)
-
>
Result
<
'
alloc
Binding
<
'
alloc
>
>
{
match
target
{
AssignmentTarget
:
:
SimpleAssignmentTarget
(
SimpleAssignmentTarget
:
:
AssignmentTargetIdentifier
(
AssignmentTargetIdentifier
{
name
loc
}
)
)
=
>
Ok
(
Binding
:
:
BindingIdentifier
(
BindingIdentifier
{
name
loc
}
)
)
AssignmentTarget
:
:
SimpleAssignmentTarget
(
SimpleAssignmentTarget
:
:
MemberAssignmentTarget
(
_
)
)
=
>
Err
(
ParseError
:
:
InvalidParameter
)
AssignmentTarget
:
:
AssignmentTargetPattern
(
AssignmentTargetPattern
:
:
ArrayAssignmentTarget
(
ArrayAssignmentTarget
{
elements
rest
loc
}
)
)
=
>
{
let
elements
:
arena
:
:
Vec
<
'
alloc
Option
<
AssignmentTargetMaybeDefault
<
'
alloc
>
>
>
=
elements
;
let
elements
:
arena
:
:
Vec
<
'
alloc
Option
<
Parameter
<
'
alloc
>
>
>
=
self
.
collect_vec_from_results
(
elements
.
into_iter
(
)
.
map
(
|
maybe_target
|
{
maybe_target
.
map
(
|
target
|
self
.
assignment_target_maybe_default_to_binding
(
target
)
)
.
transpose
(
)
}
)
)
?
;
let
rest
:
Option
<
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
>
>
=
rest
.
map
(
|
rest_target
|
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
>
{
Ok
(
self
.
alloc
(
self
.
assignment_target_to_binding
(
rest_target
.
unbox
(
)
)
?
)
)
}
)
;
let
rest
:
Option
<
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
>
=
rest
.
transpose
(
)
?
;
Ok
(
Binding
:
:
BindingPattern
(
BindingPattern
:
:
ArrayBinding
(
ArrayBinding
{
elements
rest
loc
}
)
)
)
}
AssignmentTarget
:
:
AssignmentTargetPattern
(
AssignmentTargetPattern
:
:
ObjectAssignmentTarget
(
ObjectAssignmentTarget
{
properties
rest
loc
}
)
)
=
>
{
let
properties
=
self
.
collect_vec_from_results
(
properties
.
into_iter
(
)
.
map
(
|
target
|
{
self
.
assignment_target_property_to_binding_property
(
target
)
}
)
)
?
;
let
rest
=
if
let
Some
(
rest_target
)
=
rest
{
Some
(
self
.
assignment_rest_property_to_binding_identifier
(
rest_target
.
unbox
(
)
)
?
)
}
else
{
None
}
;
Ok
(
Binding
:
:
BindingPattern
(
BindingPattern
:
:
ObjectBinding
(
ObjectBinding
{
properties
rest
loc
}
)
)
)
}
}
}
fn
object_property_to_binding_property
(
&
self
op
:
ObjectProperty
<
'
alloc
>
)
-
>
Result
<
'
alloc
BindingProperty
<
'
alloc
>
>
{
match
op
{
ObjectProperty
:
:
NamedObjectProperty
(
NamedObjectProperty
:
:
DataProperty
(
DataProperty
{
property_name
expression
loc
}
)
)
=
>
Ok
(
BindingProperty
:
:
BindingPropertyProperty
(
BindingPropertyProperty
{
name
:
property_name
binding
:
self
.
expression_to_parameter
(
expression
.
unbox
(
)
)
?
loc
}
)
)
ObjectProperty
:
:
NamedObjectProperty
(
NamedObjectProperty
:
:
MethodDefinition
(
_
)
)
=
>
{
Err
(
ParseError
:
:
ObjectPatternWithMethod
)
}
ObjectProperty
:
:
ShorthandProperty
(
ShorthandProperty
{
name
:
IdentifierExpression
{
name
loc
}
.
.
}
)
=
>
{
Ok
(
BindingProperty
:
:
BindingPropertyIdentifier
(
BindingPropertyIdentifier
{
binding
:
BindingIdentifier
{
name
loc
}
init
:
None
loc
}
)
)
}
ObjectProperty
:
:
SpreadProperty
(
_expression
)
=
>
{
Err
(
ParseError
:
:
ObjectPatternWithNonFinalRest
)
}
}
}
fn
spread_expression_to_rest_binding
(
&
self
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
{
Ok
(
match
expression
.
unbox
(
)
{
Expression
:
:
IdentifierExpression
(
IdentifierExpression
{
name
loc
}
)
=
>
{
self
.
alloc
(
BindingIdentifier
{
name
loc
}
)
}
_
=
>
{
return
Err
(
ParseError
:
:
ObjectBindingPatternWithInvalidRest
)
;
}
}
)
}
fn
pop_trailing_spread_property
(
&
self
properties
:
&
mut
arena
:
:
Vec
<
'
alloc
arena
:
:
Box
<
'
alloc
ObjectProperty
<
'
alloc
>
>
>
)
-
>
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
match
properties
.
last
(
)
.
map
(
|
boxed
|
&
*
*
boxed
)
{
Some
(
ObjectProperty
:
:
SpreadProperty
(
_
)
)
=
>
{
}
_
=
>
return
None
}
match
properties
.
pop
(
)
.
unwrap
(
)
.
unbox
(
)
{
ObjectProperty
:
:
SpreadProperty
(
expression
)
=
>
Some
(
expression
)
_
=
>
panic
!
(
"
bug
"
)
}
}
fn
object_expression_to_object_binding
(
&
self
object
:
ObjectExpression
<
'
alloc
>
)
-
>
Result
<
'
alloc
ObjectBinding
<
'
alloc
>
>
{
let
mut
properties
=
object
.
properties
;
let
loc
=
object
.
loc
;
let
rest
=
self
.
pop_trailing_spread_property
(
&
mut
properties
)
;
Ok
(
ObjectBinding
{
properties
:
self
.
collect_vec_from_results
(
properties
.
into_iter
(
)
.
map
(
|
prop
|
self
.
object_property_to_binding_property
(
prop
.
unbox
(
)
)
)
)
?
rest
:
rest
.
map
(
|
expression
|
self
.
spread_expression_to_rest_binding
(
expression
)
)
.
transpose
(
)
?
loc
}
)
}
fn
array_elements_to_parameters
(
&
self
elements
:
arena
:
:
Vec
<
'
alloc
ArrayExpressionElement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Vec
<
'
alloc
Option
<
Parameter
<
'
alloc
>
>
>
>
{
self
.
collect_vec_from_results
(
elements
.
into_iter
(
)
.
map
(
|
element
|
match
element
{
ArrayExpressionElement
:
:
Expression
(
expr
)
=
>
Ok
(
Some
(
self
.
expression_to_parameter
(
expr
.
unbox
(
)
)
?
)
)
ArrayExpressionElement
:
:
SpreadElement
(
_expr
)
=
>
Err
(
ParseError
:
:
ArrayPatternWithNonFinalRest
)
ArrayExpressionElement
:
:
Elision
{
.
.
}
=
>
Ok
(
None
)
}
)
)
}
fn
pop_trailing_spread_element
(
&
self
elements
:
&
mut
arena
:
:
Vec
<
'
alloc
ArrayExpressionElement
<
'
alloc
>
>
)
-
>
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
match
elements
.
last
(
)
{
Some
(
ArrayExpressionElement
:
:
SpreadElement
(
_
)
)
=
>
{
}
_
=
>
return
None
}
match
elements
.
pop
(
)
{
Some
(
ArrayExpressionElement
:
:
SpreadElement
(
expression
)
)
=
>
Some
(
expression
)
_
=
>
panic
!
(
"
bug
"
)
}
}
fn
expression_to_binding_no_default
(
&
self
expression
:
Expression
<
'
alloc
>
)
-
>
Result
<
'
alloc
Binding
<
'
alloc
>
>
{
match
expression
{
Expression
:
:
IdentifierExpression
(
IdentifierExpression
{
name
loc
}
)
=
>
{
Ok
(
Binding
:
:
BindingIdentifier
(
BindingIdentifier
{
name
loc
}
)
)
}
Expression
:
:
ArrayExpression
(
ArrayExpression
{
mut
elements
loc
}
)
=
>
{
let
rest
=
self
.
pop_trailing_spread_element
(
&
mut
elements
)
;
let
elements
=
self
.
array_elements_to_parameters
(
elements
)
?
;
let
rest
=
rest
.
map
(
|
expr
|
match
self
.
expression_to_parameter
(
expr
.
unbox
(
)
)
?
{
Parameter
:
:
Binding
(
b
)
=
>
Ok
(
self
.
alloc
(
b
)
)
Parameter
:
:
BindingWithDefault
(
_
)
=
>
{
Err
(
ParseError
:
:
ArrayBindingPatternWithInvalidRest
)
}
}
)
.
transpose
(
)
?
;
Ok
(
Binding
:
:
BindingPattern
(
BindingPattern
:
:
ArrayBinding
(
ArrayBinding
{
elements
rest
loc
}
)
)
)
}
Expression
:
:
ObjectExpression
(
object
)
=
>
Ok
(
Binding
:
:
BindingPattern
(
BindingPattern
:
:
ObjectBinding
(
self
.
object_expression_to_object_binding
(
object
)
?
)
)
)
_
=
>
Err
(
ParseError
:
:
InvalidParameter
)
}
}
fn
expression_to_parameter
(
&
self
expression
:
Expression
<
'
alloc
>
)
-
>
Result
<
'
alloc
Parameter
<
'
alloc
>
>
{
match
expression
{
Expression
:
:
AssignmentExpression
{
binding
expression
loc
}
=
>
Ok
(
Parameter
:
:
BindingWithDefault
(
BindingWithDefault
{
binding
:
self
.
assignment_target_to_binding
(
binding
)
?
init
:
expression
loc
}
)
)
other
=
>
Ok
(
Parameter
:
:
Binding
(
self
.
expression_to_binding_no_default
(
other
)
?
)
)
}
}
pub
fn
expression_to_parameter_list
(
&
self
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Vec
<
'
alloc
Parameter
<
'
alloc
>
>
>
{
match
expression
.
unbox
(
)
{
Expression
:
:
BinaryExpression
{
operator
:
BinaryOperator
:
:
Comma
{
.
.
}
left
right
.
.
}
=
>
{
let
mut
parameters
=
self
.
expression_to_parameter_list
(
left
)
?
;
self
.
push
(
&
mut
parameters
self
.
expression_to_parameter
(
right
.
unbox
(
)
)
?
)
;
Ok
(
parameters
)
}
other
=
>
Ok
(
self
.
new_vec_single
(
self
.
expression_to_parameter
(
other
)
?
)
)
}
}
fn
arguments_to_parameter_list
(
&
self
arguments
:
Arguments
<
'
alloc
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
>
{
let
loc
=
arguments
.
loc
;
let
mut
items
=
self
.
new_vec
(
)
;
let
mut
rest
:
Option
<
Binding
<
'
alloc
>
>
=
None
;
for
arg
in
arguments
.
args
{
if
rest
.
is_some
(
)
{
return
Err
(
ParseError
:
:
ArrowParametersWithNonFinalRest
)
;
}
match
arg
{
Argument
:
:
Expression
(
expr
)
=
>
{
self
.
push
(
&
mut
items
self
.
expression_to_parameter
(
expr
.
unbox
(
)
)
?
)
;
}
Argument
:
:
SpreadElement
(
spread_expr
)
=
>
{
rest
=
Some
(
self
.
expression_to_binding_no_default
(
spread_expr
.
unbox
(
)
)
?
)
;
}
}
}
Ok
(
self
.
alloc
(
FormalParameters
{
items
rest
loc
}
)
)
}
pub
fn
cover_arrow_parameter_list
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
parameters
:
arena
:
:
Vec
<
'
alloc
Parameter
<
'
alloc
>
>
rest
:
Option
<
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
CoverParenthesized
<
'
alloc
>
>
{
self
.
alloc
(
CoverParenthesized
:
:
Parameters
(
self
.
alloc
(
FormalParameters
{
items
:
parameters
rest
:
rest
.
map
(
|
boxed
|
boxed
.
unbox
(
)
)
loc
:
SourceLocation
:
:
from_parts
(
open_token
.
loc
close_token
.
loc
)
}
)
)
)
}
pub
fn
null_literal
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
loc
=
token
.
loc
;
self
.
alloc
(
Expression
:
:
LiteralNullExpression
{
loc
}
)
}
pub
fn
boolean_literal
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
loc
=
token
.
loc
;
let
s
=
token
.
value
.
as_atom
(
)
;
assert
!
(
s
=
=
CommonSourceAtomSetIndices
:
:
true_
(
)
|
|
s
=
=
CommonSourceAtomSetIndices
:
:
false_
(
)
)
;
self
.
alloc
(
Expression
:
:
LiteralBooleanExpression
{
value
:
s
=
=
CommonSourceAtomSetIndices
:
:
true_
(
)
loc
}
)
}
fn
numeric_literal_value
(
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
f64
{
token
.
unbox
(
)
.
value
.
as_number
(
)
}
pub
fn
numeric_literal
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
let
loc
=
token
.
loc
;
Ok
(
self
.
alloc
(
Expression
:
:
LiteralNumericExpression
(
NumericLiteral
{
value
:
Self
:
:
numeric_literal_value
(
token
)
loc
}
)
)
)
}
pub
fn
bigint_literal
(
&
self
_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
BigInt
"
)
)
}
pub
fn
string_literal
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
let
loc
=
token
.
loc
;
let
value
=
token
.
value
.
as_atom
(
)
;
if
value
=
=
CommonSourceAtomSetIndices
:
:
use_strict
(
)
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
use
strict
directive
"
)
)
;
}
Ok
(
self
.
alloc
(
Expression
:
:
LiteralStringExpression
{
value
loc
}
)
)
}
pub
fn
array_literal_empty
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
elision
:
Option
<
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
self
.
alloc
(
Expression
:
:
ArrayExpression
(
match
elision
{
None
=
>
ArrayExpression
{
elements
:
self
.
new_vec
(
)
loc
:
SourceLocation
:
:
from_parts
(
open_token
.
loc
close_token
.
loc
)
}
Some
(
mut
array
)
=
>
{
array
.
loc
.
set_range
(
open_token
.
loc
close_token
.
loc
)
;
array
.
unbox
(
)
}
}
)
)
}
pub
fn
array_literal
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
array
:
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
array
.
loc
.
set_range
(
open_token
.
loc
close_token
.
loc
)
;
self
.
alloc
(
Expression
:
:
ArrayExpression
(
array
.
unbox
(
)
)
)
}
pub
fn
array_literal_with_trailing_elision
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
array
:
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
elision
:
Option
<
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
if
let
Some
(
mut
more
)
=
elision
{
self
.
append
(
&
mut
array
.
elements
&
mut
more
.
elements
)
;
}
array
.
loc
.
set_range
(
open_token
.
loc
close_token
.
loc
)
;
self
.
alloc
(
Expression
:
:
ArrayExpression
(
array
.
unbox
(
)
)
)
}
pub
fn
element_list_first
(
&
self
elision
:
Option
<
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
>
element
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
{
let
mut
array
=
elision
.
unwrap_or_else
(
|
|
{
self
.
alloc
(
ArrayExpression
{
elements
:
self
.
new_vec
(
)
loc
:
SourceLocation
:
:
default
(
)
}
)
}
)
;
self
.
push
(
&
mut
array
.
elements
ArrayExpressionElement
:
:
Expression
(
element
)
)
;
array
}
pub
fn
element_list_first_spread
(
&
self
elision
:
Option
<
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
>
spread_element
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
{
let
mut
array
=
elision
.
unwrap_or_else
(
|
|
{
self
.
alloc
(
ArrayExpression
{
elements
:
self
.
new_vec
(
)
loc
:
SourceLocation
:
:
default
(
)
}
)
}
)
;
self
.
push
(
&
mut
array
.
elements
ArrayExpressionElement
:
:
SpreadElement
(
spread_element
)
)
;
array
}
pub
fn
element_list_append
(
&
self
mut
array
:
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
elision
:
Option
<
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
>
element
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
{
if
let
Some
(
mut
elision
)
=
elision
{
self
.
append
(
&
mut
array
.
elements
&
mut
elision
.
elements
)
;
}
self
.
push
(
&
mut
array
.
elements
ArrayExpressionElement
:
:
Expression
(
element
)
)
;
array
}
pub
fn
element_list_append_spread
(
&
self
mut
array
:
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
elision
:
Option
<
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
>
spread_element
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
{
if
let
Some
(
mut
elision
)
=
elision
{
self
.
append
(
&
mut
array
.
elements
&
mut
elision
.
elements
)
;
}
self
.
push
(
&
mut
array
.
elements
ArrayExpressionElement
:
:
SpreadElement
(
spread_element
)
)
;
array
}
pub
fn
elision_single
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
{
let
loc
=
token
.
loc
;
self
.
alloc
(
ArrayExpression
{
elements
:
self
.
new_vec_single
(
ArrayExpressionElement
:
:
Elision
{
loc
}
)
loc
:
SourceLocation
:
:
default
(
)
}
)
}
pub
fn
elision_append
(
&
self
mut
array
:
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
{
let
loc
=
token
.
loc
;
self
.
push
(
&
mut
array
.
elements
ArrayExpressionElement
:
:
Elision
{
loc
}
)
;
array
}
pub
fn
spread_element
(
&
self
expr
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
expr
}
pub
fn
object_literal_empty
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
self
.
alloc
(
Expression
:
:
ObjectExpression
(
ObjectExpression
{
properties
:
self
.
new_vec
(
)
loc
:
SourceLocation
:
:
from_parts
(
open_token
.
loc
close_token
.
loc
)
}
)
)
}
pub
fn
object_literal
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
object
:
arena
:
:
Box
<
'
alloc
ObjectExpression
<
'
alloc
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
object
.
loc
.
set_range
(
open_token
.
loc
close_token
.
loc
)
;
self
.
alloc
(
Expression
:
:
ObjectExpression
(
object
.
unbox
(
)
)
)
}
pub
fn
property_definition_list_single
(
&
self
property
:
arena
:
:
Box
<
'
alloc
ObjectProperty
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ObjectExpression
<
'
alloc
>
>
{
self
.
alloc
(
ObjectExpression
{
properties
:
self
.
new_vec_single
(
property
)
loc
:
SourceLocation
:
:
default
(
)
}
)
}
pub
fn
property_definition_list_append
(
&
self
mut
object
:
arena
:
:
Box
<
'
alloc
ObjectExpression
<
'
alloc
>
>
property
:
arena
:
:
Box
<
'
alloc
ObjectProperty
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ObjectExpression
<
'
alloc
>
>
{
self
.
push
(
&
mut
object
.
properties
property
)
;
object
}
pub
fn
shorthand_property
(
&
self
name
:
arena
:
:
Box
<
'
alloc
Identifier
>
)
-
>
arena
:
:
Box
<
'
alloc
ObjectProperty
<
'
alloc
>
>
{
let
loc
=
name
.
loc
;
self
.
alloc
(
ObjectProperty
:
:
ShorthandProperty
(
ShorthandProperty
{
name
:
IdentifierExpression
{
name
:
name
.
unbox
(
)
loc
}
loc
}
)
)
}
pub
fn
property_definition
(
&
self
name
:
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ObjectProperty
<
'
alloc
>
>
{
let
name_loc
=
name
.
get_loc
(
)
;
let
expression_loc
=
expression
.
get_loc
(
)
;
self
.
alloc
(
ObjectProperty
:
:
NamedObjectProperty
(
NamedObjectProperty
:
:
DataProperty
(
DataProperty
{
property_name
:
name
.
unbox
(
)
expression
loc
:
SourceLocation
:
:
from_parts
(
name_loc
expression_loc
)
}
)
)
)
}
pub
fn
property_definition_method
(
&
self
method
:
arena
:
:
Box
<
'
alloc
MethodDefinition
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ObjectProperty
<
'
alloc
>
>
{
self
.
alloc
(
ObjectProperty
:
:
NamedObjectProperty
(
NamedObjectProperty
:
:
MethodDefinition
(
method
.
unbox
(
)
)
)
)
}
pub
fn
property_definition_spread
(
&
self
spread
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ObjectProperty
<
'
alloc
>
>
{
self
.
alloc
(
ObjectProperty
:
:
SpreadProperty
(
spread
)
)
}
pub
fn
property_name_identifier
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
>
{
let
value
=
token
.
value
.
as_atom
(
)
;
if
value
=
=
CommonSourceAtomSetIndices
:
:
__proto__
(
)
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
__proto__
as
property
name
"
)
)
;
}
let
loc
=
token
.
loc
;
Ok
(
self
.
alloc
(
PropertyName
:
:
StaticPropertyName
(
StaticPropertyName
{
value
loc
}
)
)
)
}
pub
fn
property_name_string
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
>
{
let
value
=
token
.
value
.
as_atom
(
)
;
if
value
=
=
CommonSourceAtomSetIndices
:
:
__proto__
(
)
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
__proto__
as
property
name
"
)
)
;
}
let
loc
=
token
.
loc
;
Ok
(
self
.
alloc
(
PropertyName
:
:
StaticPropertyName
(
StaticPropertyName
{
value
loc
}
)
)
)
}
pub
fn
property_name_numeric
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
>
{
let
loc
=
token
.
loc
;
let
value
=
Self
:
:
numeric_literal_value
(
token
)
;
Ok
(
self
.
alloc
(
PropertyName
:
:
StaticNumericPropertyName
(
NumericLiteral
{
value
loc
}
)
)
)
}
pub
fn
property_name_bigint
(
&
self
_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
BigInt
"
)
)
}
pub
fn
computed_property_name
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
{
self
.
alloc
(
PropertyName
:
:
ComputedPropertyName
(
ComputedPropertyName
{
expression
loc
:
SourceLocation
:
:
from_parts
(
open_token
.
loc
close_token
.
loc
)
}
)
)
}
pub
fn
cover_initialized_name
(
&
self
_name
:
arena
:
:
Box
<
'
alloc
Identifier
>
_initializer
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
ObjectProperty
<
'
alloc
>
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
default
initializers
in
object
patterns
"
)
)
}
pub
fn
template_literal
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
TemplateExpression
<
'
alloc
>
>
{
let
loc
=
token
.
loc
;
self
.
alloc
(
TemplateExpression
{
tag
:
None
elements
:
self
.
new_vec_single
(
TemplateExpressionElement
:
:
TemplateElement
(
TemplateElement
{
raw_value
:
token
.
value
.
as_atom
(
)
loc
}
)
)
loc
}
)
}
pub
fn
substitution_template
(
&
self
_head
:
arena
:
:
Box
<
'
alloc
Token
>
_expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
_spans
:
arena
:
:
Box
<
'
alloc
Void
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
TemplateExpression
<
'
alloc
>
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
template
strings
"
)
)
}
pub
fn
template_spans
(
&
self
_middle_list
:
Option
<
arena
:
:
Box
<
'
alloc
Void
>
>
_tail
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
template
strings
"
)
)
}
pub
fn
template_middle_list_single
(
&
self
_middle
:
arena
:
:
Box
<
'
alloc
Token
>
_expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
template
strings
"
)
)
}
pub
fn
template_middle_list_append
(
&
self
_middle_list
:
arena
:
:
Box
<
'
alloc
Void
>
_middle
:
arena
:
:
Box
<
'
alloc
Token
>
_expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
template
strings
"
)
)
}
pub
fn
computed_member_expr
(
&
self
object
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
object_loc
=
object
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
MemberExpression
(
MemberExpression
:
:
ComputedMemberExpression
(
ComputedMemberExpression
{
object
:
ExpressionOrSuper
:
:
Expression
(
object
)
expression
loc
:
SourceLocation
:
:
from_parts
(
object_loc
close_token
.
loc
)
}
)
)
)
}
pub
fn
optional_expr
(
&
self
object
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
tail
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
object_loc
=
object
.
get_loc
(
)
;
let
expression_loc
=
tail
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
OptionalExpression
{
object
:
ExpressionOrSuper
:
:
Expression
(
object
)
tail
loc
:
SourceLocation
:
:
from_parts
(
object_loc
expression_loc
)
}
)
}
pub
fn
optional_computed_member_expr_tail
(
&
self
start_token
:
arena
:
:
Box
<
'
alloc
Token
>
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
self
.
alloc
(
Expression
:
:
OptionalChain
(
OptionalChain
:
:
ComputedMemberExpressionTail
{
expression
loc
:
SourceLocation
:
:
from_parts
(
start_token
.
loc
close_token
.
loc
)
}
)
)
}
pub
fn
optional_static_member_expr_tail
(
&
self
start_token
:
arena
:
:
Box
<
'
alloc
Token
>
identifier_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
identifier_token_loc
=
identifier_token
.
loc
;
self
.
alloc
(
Expression
:
:
OptionalChain
(
OptionalChain
:
:
StaticMemberExpressionTail
{
property
:
self
.
identifier_name
(
identifier_token
)
loc
:
SourceLocation
:
:
from_parts
(
start_token
.
loc
identifier_token_loc
)
}
)
)
}
pub
fn
optional_call_expr_tail
(
&
self
start_token
:
arena
:
:
Box
<
'
alloc
Token
>
arguments
:
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
arguments_loc
=
arguments
.
loc
;
self
.
alloc
(
Expression
:
:
OptionalChain
(
OptionalChain
:
:
CallExpressionTail
{
arguments
:
arguments
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
start_token
.
loc
arguments_loc
)
}
)
)
}
pub
fn
error_optional_chain_with_template
(
&
self
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
Err
(
ParseError
:
:
IllegalCharacter
(
'
'
)
)
}
pub
fn
optional_computed_member_expr
(
&
self
object
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
object_loc
=
object
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
OptionalChain
(
OptionalChain
:
:
ComputedMemberExpression
(
ComputedMemberExpression
{
object
:
ExpressionOrSuper
:
:
Expression
(
object
)
expression
loc
:
SourceLocation
:
:
from_parts
(
object_loc
close_token
.
loc
)
}
)
)
)
}
pub
fn
optional_static_member_expr
(
&
self
object
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
identifier_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
object_loc
=
object
.
get_loc
(
)
;
let
identifier_token_loc
=
identifier_token
.
loc
;
self
.
alloc
(
Expression
:
:
OptionalChain
(
OptionalChain
:
:
StaticMemberExpression
(
StaticMemberExpression
{
object
:
ExpressionOrSuper
:
:
Expression
(
object
)
property
:
self
.
identifier_name
(
identifier_token
)
loc
:
SourceLocation
:
:
from_parts
(
object_loc
identifier_token_loc
)
}
)
)
)
}
pub
fn
optional_call_expr
(
&
self
callee
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
arguments
:
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
callee_loc
=
callee
.
get_loc
(
)
;
let
arguments_loc
=
arguments
.
loc
;
self
.
alloc
(
Expression
:
:
OptionalChain
(
OptionalChain
:
:
CallExpression
(
CallExpression
{
callee
:
ExpressionOrSuper
:
:
Expression
(
callee
)
arguments
:
arguments
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
callee_loc
arguments_loc
)
}
)
)
)
}
fn
identifier
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Identifier
{
Identifier
{
value
:
token
.
value
.
as_atom
(
)
loc
:
token
.
loc
}
}
fn
identifier_name
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
IdentifierName
{
IdentifierName
{
value
:
token
.
value
.
as_atom
(
)
loc
:
token
.
loc
}
}
fn
private_identifier
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
PrivateIdentifier
{
PrivateIdentifier
{
value
:
token
.
value
.
as_atom
(
)
loc
:
token
.
loc
}
}
pub
fn
static_member_expr
(
&
self
object
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
identifier_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
object_loc
=
object
.
get_loc
(
)
;
let
identifier_token_loc
=
identifier_token
.
loc
;
self
.
alloc
(
Expression
:
:
MemberExpression
(
MemberExpression
:
:
StaticMemberExpression
(
StaticMemberExpression
{
object
:
ExpressionOrSuper
:
:
Expression
(
object
)
property
:
self
.
identifier_name
(
identifier_token
)
loc
:
SourceLocation
:
:
from_parts
(
object_loc
identifier_token_loc
)
}
)
)
)
}
pub
fn
tagged_template_expr
(
&
self
tag
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
mut
template_literal
:
arena
:
:
Box
<
'
alloc
TemplateExpression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
template_literal
.
tag
=
Some
(
tag
)
;
self
.
alloc
(
Expression
:
:
TemplateExpression
(
template_literal
.
unbox
(
)
)
)
}
pub
fn
new_expr_with_arguments
(
&
self
new_token
:
arena
:
:
Box
<
'
alloc
Token
>
callee
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
arguments
:
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
arguments_loc
=
arguments
.
loc
;
self
.
alloc
(
Expression
:
:
NewExpression
{
callee
arguments
:
arguments
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
new_token
.
loc
arguments_loc
)
}
)
}
pub
fn
private_field_expr
(
&
self
object
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
private_identifier
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
object_loc
=
object
.
get_loc
(
)
;
let
field_loc
=
private_identifier
.
loc
;
self
.
alloc
(
Expression
:
:
MemberExpression
(
MemberExpression
:
:
PrivateFieldExpression
(
PrivateFieldExpression
{
object
field
:
self
.
private_identifier
(
private_identifier
)
loc
:
SourceLocation
:
:
from_parts
(
object_loc
field_loc
)
}
)
)
)
}
pub
fn
super_property_computed
(
&
self
super_token
:
arena
:
:
Box
<
'
alloc
Token
>
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
super_loc
=
super_token
.
loc
;
self
.
alloc
(
Expression
:
:
MemberExpression
(
MemberExpression
:
:
ComputedMemberExpression
(
ComputedMemberExpression
{
object
:
ExpressionOrSuper
:
:
Super
{
loc
:
super_loc
}
expression
:
expression
loc
:
SourceLocation
:
:
from_parts
(
super_loc
close_token
.
loc
)
}
)
)
)
}
pub
fn
super_property_static
(
&
self
super_token
:
arena
:
:
Box
<
'
alloc
Token
>
identifier_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
super_loc
=
super_token
.
loc
;
let
identifier_loc
=
identifier_token
.
loc
;
self
.
alloc
(
Expression
:
:
MemberExpression
(
MemberExpression
:
:
StaticMemberExpression
(
StaticMemberExpression
{
object
:
ExpressionOrSuper
:
:
Super
{
loc
:
super_loc
}
property
:
self
.
identifier_name
(
identifier_token
)
loc
:
SourceLocation
:
:
from_parts
(
super_loc
identifier_loc
)
}
)
)
)
}
pub
fn
new_target_expr
(
&
self
new_token
:
arena
:
:
Box
<
'
alloc
Token
>
target_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
return
self
.
alloc
(
Expression
:
:
NewTargetExpression
{
loc
:
SourceLocation
:
:
from_parts
(
new_token
.
loc
target_token
.
loc
)
}
)
;
}
pub
fn
new_expr_without_arguments
(
&
self
new_token
:
arena
:
:
Box
<
'
alloc
Token
>
callee
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
callee_loc
=
callee
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
NewExpression
{
callee
arguments
:
Arguments
{
args
:
self
.
new_vec
(
)
loc
:
SourceLocation
:
:
new
(
callee_loc
.
end
callee_loc
.
end
)
}
loc
:
SourceLocation
:
:
from_parts
(
new_token
.
loc
callee_loc
)
}
)
}
pub
fn
call_expr
(
&
self
callee
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
arguments
:
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
callee_loc
=
callee
.
get_loc
(
)
;
let
arguments_loc
=
arguments
.
loc
;
self
.
alloc
(
Expression
:
:
CallExpression
(
CallExpression
{
callee
:
ExpressionOrSuper
:
:
Expression
(
callee
)
arguments
:
arguments
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
callee_loc
arguments_loc
)
}
)
)
}
pub
fn
super_call
(
&
self
super_token
:
arena
:
:
Box
<
'
alloc
Token
>
arguments
:
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
super_loc
=
super_token
.
loc
;
let
arguments_loc
=
arguments
.
loc
;
self
.
alloc
(
Expression
:
:
CallExpression
(
CallExpression
{
callee
:
ExpressionOrSuper
:
:
Super
{
loc
:
super_loc
}
arguments
:
arguments
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
super_loc
arguments_loc
)
}
)
)
}
pub
fn
import_call
(
&
self
import_token
:
arena
:
:
Box
<
'
alloc
Token
>
argument
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
self
.
alloc
(
Expression
:
:
ImportCallExpression
{
argument
loc
:
SourceLocation
:
:
from_parts
(
import_token
.
loc
close_token
.
loc
)
}
)
}
pub
fn
arguments_empty
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
{
self
.
alloc
(
Arguments
{
args
:
self
.
new_vec
(
)
loc
:
SourceLocation
:
:
from_parts
(
open_token
.
loc
close_token
.
loc
)
}
)
}
pub
fn
arguments_single
(
&
self
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
{
self
.
alloc
(
Arguments
{
args
:
self
.
new_vec_single
(
Argument
:
:
Expression
(
expression
)
)
loc
:
SourceLocation
:
:
default
(
)
}
)
}
pub
fn
arguments_spread_single
(
&
self
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
{
self
.
alloc
(
Arguments
{
args
:
self
.
new_vec_single
(
Argument
:
:
SpreadElement
(
expression
)
)
loc
:
SourceLocation
:
:
default
(
)
}
)
}
pub
fn
arguments
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
arguments
:
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
{
arguments
.
loc
.
set_range
(
open_token
.
loc
close_token
.
loc
)
;
arguments
}
pub
fn
arguments_append
(
&
self
mut
arguments
:
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
{
self
.
push
(
&
mut
arguments
.
args
Argument
:
:
Expression
(
expression
)
)
;
arguments
}
pub
fn
arguments_append_spread
(
&
self
mut
arguments
:
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Arguments
<
'
alloc
>
>
{
self
.
push
(
&
mut
arguments
.
args
Argument
:
:
SpreadElement
(
expression
)
)
;
arguments
}
pub
fn
post_increment_expr
(
&
self
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
operator_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
let
operand
=
self
.
expression_to_simple_assignment_target
(
operand
)
?
;
let
operand_loc
=
operand
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Expression
:
:
UpdateExpression
{
is_prefix
:
false
operator
:
UpdateOperator
:
:
Increment
{
loc
:
operator_token
.
loc
}
operand
loc
:
SourceLocation
:
:
from_parts
(
operand_loc
operator_token
.
loc
)
}
)
)
}
pub
fn
post_decrement_expr
(
&
self
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
operator_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
let
operand
=
self
.
expression_to_simple_assignment_target
(
operand
)
?
;
let
operand_loc
=
operand
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Expression
:
:
UpdateExpression
{
is_prefix
:
false
operator
:
UpdateOperator
:
:
Decrement
{
loc
:
operator_token
.
loc
}
operand
loc
:
SourceLocation
:
:
from_parts
(
operand_loc
operator_token
.
loc
)
}
)
)
}
pub
fn
pre_increment_expr
(
&
self
operator_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
let
operand
=
self
.
expression_to_simple_assignment_target
(
operand
)
?
;
let
operand_loc
=
operand
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Expression
:
:
UpdateExpression
{
is_prefix
:
true
operator
:
UpdateOperator
:
:
Increment
{
loc
:
operator_token
.
loc
}
operand
loc
:
SourceLocation
:
:
from_parts
(
operator_token
.
loc
operand_loc
)
}
)
)
}
pub
fn
pre_decrement_expr
(
&
self
operator_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
let
operand
=
self
.
expression_to_simple_assignment_target
(
operand
)
?
;
let
operand_loc
=
operand
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Expression
:
:
UpdateExpression
{
is_prefix
:
true
operator
:
UpdateOperator
:
:
Decrement
{
loc
:
operator_token
.
loc
}
operand
loc
:
SourceLocation
:
:
from_parts
(
operator_token
.
loc
operand_loc
)
}
)
)
}
pub
fn
delete_expr
(
&
self
operator_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
operand_loc
=
operand
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
UnaryExpression
{
operator
:
UnaryOperator
:
:
Delete
{
loc
:
operator_token
.
loc
}
operand
loc
:
SourceLocation
:
:
from_parts
(
operator_token
.
loc
operand_loc
)
}
)
}
pub
fn
void_expr
(
&
self
operator_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
operand_loc
=
operand
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
UnaryExpression
{
operator
:
UnaryOperator
:
:
Void
{
loc
:
operator_token
.
loc
}
operand
loc
:
SourceLocation
:
:
from_parts
(
operator_token
.
loc
operand_loc
)
}
)
}
pub
fn
typeof_expr
(
&
self
operator_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
operand_loc
=
operand
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
UnaryExpression
{
operator
:
UnaryOperator
:
:
Typeof
{
loc
:
operator_token
.
loc
}
operand
loc
:
SourceLocation
:
:
from_parts
(
operator_token
.
loc
operand_loc
)
}
)
}
pub
fn
unary_plus_expr
(
&
self
operator_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
operand_loc
=
operand
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
UnaryExpression
{
operator
:
UnaryOperator
:
:
Plus
{
loc
:
operator_token
.
loc
}
operand
loc
:
SourceLocation
:
:
from_parts
(
operator_token
.
loc
operand_loc
)
}
)
}
pub
fn
unary_minus_expr
(
&
self
operator_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
operand_loc
=
operand
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
UnaryExpression
{
operator
:
UnaryOperator
:
:
Minus
{
loc
:
operator_token
.
loc
}
operand
loc
:
SourceLocation
:
:
from_parts
(
operator_token
.
loc
operand_loc
)
}
)
}
pub
fn
bitwise_not_expr
(
&
self
operator_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
operand_loc
=
operand
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
UnaryExpression
{
operator
:
UnaryOperator
:
:
BitwiseNot
{
loc
:
operator_token
.
loc
}
operand
loc
:
SourceLocation
:
:
from_parts
(
operator_token
.
loc
operand_loc
)
}
)
}
pub
fn
logical_not_expr
(
&
self
operator_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
operand_loc
=
operand
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
UnaryExpression
{
operator
:
UnaryOperator
:
:
LogicalNot
{
loc
:
operator_token
.
loc
}
operand
loc
:
SourceLocation
:
:
from_parts
(
operator_token
.
loc
operand_loc
)
}
)
}
pub
fn
equals_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
Equals
{
loc
:
token
.
loc
}
}
pub
fn
not_equals_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
NotEquals
{
loc
:
token
.
loc
}
}
pub
fn
strict_equals_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
StrictEquals
{
loc
:
token
.
loc
}
}
pub
fn
strict_not_equals_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
StrictNotEquals
{
loc
:
token
.
loc
}
}
pub
fn
less_than_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
LessThan
{
loc
:
token
.
loc
}
}
pub
fn
less_than_or_equal_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
LessThanOrEqual
{
loc
:
token
.
loc
}
}
pub
fn
greater_than_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
GreaterThan
{
loc
:
token
.
loc
}
}
pub
fn
greater_than_or_equal_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
GreaterThanOrEqual
{
loc
:
token
.
loc
}
}
pub
fn
in_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
In
{
loc
:
token
.
loc
}
}
pub
fn
instanceof_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
Instanceof
{
loc
:
token
.
loc
}
}
pub
fn
left_shift_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
LeftShift
{
loc
:
token
.
loc
}
}
pub
fn
right_shift_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
RightShift
{
loc
:
token
.
loc
}
}
pub
fn
right_shift_ext_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
RightShiftExt
{
loc
:
token
.
loc
}
}
pub
fn
add_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
Add
{
loc
:
token
.
loc
}
}
pub
fn
sub_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
Sub
{
loc
:
token
.
loc
}
}
pub
fn
mul_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
Mul
{
loc
:
token
.
loc
}
}
pub
fn
div_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
Div
{
loc
:
token
.
loc
}
}
pub
fn
mod_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
Mod
{
loc
:
token
.
loc
}
}
pub
fn
pow_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
Pow
{
loc
:
token
.
loc
}
}
pub
fn
comma_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
Comma
{
loc
:
token
.
loc
}
}
pub
fn
coalesce_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
Coalesce
{
loc
:
token
.
loc
}
}
pub
fn
logical_or_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
LogicalOr
{
loc
:
token
.
loc
}
}
pub
fn
logical_and_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
LogicalAnd
{
loc
:
token
.
loc
}
}
pub
fn
bitwise_or_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
BitwiseOr
{
loc
:
token
.
loc
}
}
pub
fn
bitwise_xor_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
BitwiseXor
{
loc
:
token
.
loc
}
}
pub
fn
bitwise_and_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
BinaryOperator
{
BinaryOperator
:
:
BitwiseAnd
{
loc
:
token
.
loc
}
}
pub
fn
box_op
(
&
self
op
:
BinaryOperator
)
-
>
arena
:
:
Box
<
'
alloc
BinaryOperator
>
{
self
.
alloc
(
op
)
}
pub
fn
multiplicative_expr
(
&
self
left
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
operator
:
arena
:
:
Box
<
'
alloc
BinaryOperator
>
right
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
self
.
binary_expr
(
operator
.
unbox
(
)
left
right
)
}
pub
fn
binary_expr
(
&
self
operator
:
BinaryOperator
left
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
right
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
left_loc
=
left
.
get_loc
(
)
;
let
right_loc
=
right
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
BinaryExpression
{
operator
left
right
loc
:
SourceLocation
:
:
from_parts
(
left_loc
right_loc
)
}
)
}
pub
fn
conditional_expr
(
&
self
test
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
consequent
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
alternate
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
test_loc
=
test
.
get_loc
(
)
;
let
alternate_loc
=
alternate
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
ConditionalExpression
{
test
consequent
alternate
loc
:
SourceLocation
:
:
from_parts
(
test_loc
alternate_loc
)
}
)
}
fn
array_expression_to_array_assignment_target
(
&
self
mut
elements
:
arena
:
:
Vec
<
'
alloc
ArrayExpressionElement
<
'
alloc
>
>
loc
:
SourceLocation
)
-
>
Result
<
'
alloc
ArrayAssignmentTarget
<
'
alloc
>
>
{
let
spread
=
self
.
pop_trailing_spread_element
(
&
mut
elements
)
;
let
elements
=
self
.
collect_vec_from_results
(
elements
.
into_iter
(
)
.
map
(
|
element
|
match
element
{
ArrayExpressionElement
:
:
SpreadElement
(
_
)
=
>
Err
(
ParseError
:
:
NotImplemented
(
"
rest
destructuring
in
array
pattern
"
)
)
ArrayExpressionElement
:
:
Expression
(
expression
)
=
>
Ok
(
Some
(
self
.
expression_to_assignment_target_maybe_default
(
expression
)
?
)
)
ArrayExpressionElement
:
:
Elision
{
.
.
}
=
>
Ok
(
None
)
}
)
)
?
;
let
rest
:
Option
<
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
AssignmentTarget
<
'
alloc
>
>
>
>
=
spread
.
map
(
|
expr
|
Ok
(
self
.
alloc
(
self
.
expression_to_assignment_target
(
expr
)
?
)
)
)
;
let
rest
=
rest
.
transpose
(
)
?
;
Ok
(
ArrayAssignmentTarget
{
elements
rest
loc
}
)
}
fn
object_property_to_assignment_target_property
(
&
self
property
:
arena
:
:
Box
<
'
alloc
ObjectProperty
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
AssignmentTargetProperty
<
'
alloc
>
>
{
Ok
(
match
property
.
unbox
(
)
{
ObjectProperty
:
:
NamedObjectProperty
(
NamedObjectProperty
:
:
MethodDefinition
(
_
)
)
=
>
{
return
Err
(
ParseError
:
:
ObjectPatternWithMethod
)
}
ObjectProperty
:
:
NamedObjectProperty
(
NamedObjectProperty
:
:
DataProperty
(
DataProperty
{
property_name
expression
loc
}
)
)
=
>
AssignmentTargetProperty
:
:
AssignmentTargetPropertyProperty
(
AssignmentTargetPropertyProperty
{
name
:
property_name
binding
:
self
.
expression_to_assignment_target_maybe_default
(
expression
)
?
loc
}
)
ObjectProperty
:
:
ShorthandProperty
(
ShorthandProperty
{
name
:
IdentifierExpression
{
name
loc
}
.
.
}
)
=
>
{
AssignmentTargetProperty
:
:
AssignmentTargetPropertyIdentifier
(
AssignmentTargetPropertyIdentifier
{
binding
:
AssignmentTargetIdentifier
{
name
loc
}
init
:
None
loc
}
)
}
ObjectProperty
:
:
SpreadProperty
(
_expression
)
=
>
{
return
Err
(
ParseError
:
:
ObjectPatternWithNonFinalRest
)
}
}
)
}
fn
object_expression_to_object_assignment_target
(
&
self
mut
properties
:
arena
:
:
Vec
<
'
alloc
arena
:
:
Box
<
'
alloc
ObjectProperty
<
'
alloc
>
>
>
loc
:
SourceLocation
)
-
>
Result
<
'
alloc
ObjectAssignmentTarget
<
'
alloc
>
>
{
let
spread
=
self
.
pop_trailing_spread_property
(
&
mut
properties
)
;
let
properties
=
self
.
collect_vec_from_results
(
properties
.
into_iter
(
)
.
map
(
|
p
|
self
.
object_property_to_assignment_target_property
(
p
)
)
)
?
;
let
rest
:
Option
<
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
AssignmentTarget
<
'
alloc
>
>
>
>
=
spread
.
map
(
|
expr
|
Ok
(
self
.
alloc
(
self
.
expression_to_assignment_target
(
expr
)
?
)
)
)
;
let
rest
=
rest
.
transpose
(
)
?
;
Ok
(
ObjectAssignmentTarget
{
properties
rest
loc
}
)
}
fn
expression_to_assignment_target_maybe_default
(
&
self
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
AssignmentTargetMaybeDefault
<
'
alloc
>
>
{
Ok
(
match
expression
.
unbox
(
)
{
Expression
:
:
AssignmentExpression
{
binding
expression
loc
}
=
>
AssignmentTargetMaybeDefault
:
:
AssignmentTargetWithDefault
(
AssignmentTargetWithDefault
{
binding
init
:
expression
loc
}
)
other
=
>
AssignmentTargetMaybeDefault
:
:
AssignmentTarget
(
self
.
expression_to_assignment_target
(
self
.
alloc
(
other
)
)
?
)
}
)
}
fn
expression_to_assignment_target
(
&
self
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
AssignmentTarget
<
'
alloc
>
>
{
Ok
(
match
expression
.
unbox
(
)
{
Expression
:
:
ArrayExpression
(
ArrayExpression
{
elements
loc
}
)
=
>
{
AssignmentTarget
:
:
AssignmentTargetPattern
(
AssignmentTargetPattern
:
:
ArrayAssignmentTarget
(
self
.
array_expression_to_array_assignment_target
(
elements
loc
)
?
)
)
}
Expression
:
:
ObjectExpression
(
ObjectExpression
{
properties
loc
}
)
=
>
{
AssignmentTarget
:
:
AssignmentTargetPattern
(
AssignmentTargetPattern
:
:
ObjectAssignmentTarget
(
self
.
object_expression_to_object_assignment_target
(
properties
loc
)
?
)
)
}
other
=
>
AssignmentTarget
:
:
SimpleAssignmentTarget
(
self
.
expression_to_simple_assignment_target
(
self
.
alloc
(
other
)
)
?
)
}
)
}
fn
expression_to_simple_assignment_target
(
&
self
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
SimpleAssignmentTarget
<
'
alloc
>
>
{
Ok
(
match
expression
.
unbox
(
)
{
Expression
:
:
IdentifierExpression
(
IdentifierExpression
{
name
loc
}
)
=
>
{
if
name
.
value
=
=
CommonSourceAtomSetIndices
:
:
arguments
(
)
|
|
name
.
value
=
=
CommonSourceAtomSetIndices
:
:
eval
(
)
{
if
self
.
is_strict
(
)
?
{
return
Err
(
ParseError
:
:
InvalidAssignmentTarget
)
;
}
}
SimpleAssignmentTarget
:
:
AssignmentTargetIdentifier
(
AssignmentTargetIdentifier
{
name
loc
}
)
}
Expression
:
:
MemberExpression
(
MemberExpression
:
:
StaticMemberExpression
(
StaticMemberExpression
{
object
property
loc
}
)
)
=
>
SimpleAssignmentTarget
:
:
MemberAssignmentTarget
(
MemberAssignmentTarget
:
:
StaticMemberAssignmentTarget
(
StaticMemberAssignmentTarget
{
object
property
loc
}
)
)
Expression
:
:
MemberExpression
(
MemberExpression
:
:
ComputedMemberExpression
(
ComputedMemberExpression
{
object
expression
loc
}
)
)
=
>
SimpleAssignmentTarget
:
:
MemberAssignmentTarget
(
MemberAssignmentTarget
:
:
ComputedMemberAssignmentTarget
(
ComputedMemberAssignmentTarget
{
object
expression
loc
}
)
)
Expression
:
:
CallExpression
(
CallExpression
{
.
.
}
)
=
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
Assignment
to
CallExpression
is
allowed
for
non
-
strict
mode
.
"
)
)
;
}
_
=
>
{
return
Err
(
ParseError
:
:
InvalidAssignmentTarget
)
;
}
}
)
}
pub
fn
assignment_expr
(
&
self
left_hand_side
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
value
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
let
target
=
self
.
expression_to_assignment_target
(
left_hand_side
)
?
;
let
target_loc
=
target
.
get_loc
(
)
;
let
value_loc
=
value
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Expression
:
:
AssignmentExpression
{
binding
:
target
expression
:
value
loc
:
SourceLocation
:
:
from_parts
(
target_loc
value_loc
)
}
)
)
}
pub
fn
add_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
Add
{
loc
:
token
.
loc
}
}
pub
fn
sub_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
Sub
{
loc
:
token
.
loc
}
}
pub
fn
mul_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
Mul
{
loc
:
token
.
loc
}
}
pub
fn
div_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
Div
{
loc
:
token
.
loc
}
}
pub
fn
mod_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
Mod
{
loc
:
token
.
loc
}
}
pub
fn
pow_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
Pow
{
loc
:
token
.
loc
}
}
pub
fn
left_shift_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
LeftShift
{
loc
:
token
.
loc
}
}
pub
fn
right_shift_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
RightShift
{
loc
:
token
.
loc
}
}
pub
fn
right_shift_ext_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
RightShiftExt
{
loc
:
token
.
loc
}
}
pub
fn
bitwise_or_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
Or
{
loc
:
token
.
loc
}
}
pub
fn
bitwise_xor_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
Xor
{
loc
:
token
.
loc
}
}
pub
fn
bitwise_and_assign_op
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
CompoundAssignmentOperator
{
CompoundAssignmentOperator
:
:
And
{
loc
:
token
.
loc
}
}
pub
fn
box_assign_op
(
&
self
op
:
CompoundAssignmentOperator
)
-
>
arena
:
:
Box
<
'
alloc
CompoundAssignmentOperator
>
{
self
.
alloc
(
op
)
}
pub
fn
compound_assignment_expr
(
&
self
left_hand_side
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
operator
:
arena
:
:
Box
<
'
alloc
CompoundAssignmentOperator
>
value
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
let
target
=
self
.
expression_to_simple_assignment_target
(
left_hand_side
)
?
;
let
target_loc
=
target
.
get_loc
(
)
;
let
value_loc
=
value
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Expression
:
:
CompoundAssignmentExpression
{
operator
:
operator
.
unbox
(
)
binding
:
target
expression
:
value
loc
:
SourceLocation
:
:
from_parts
(
target_loc
value_loc
)
}
)
)
}
pub
fn
block_statement
(
&
self
block
:
arena
:
:
Box
<
'
alloc
Block
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
let
loc
=
block
.
loc
;
self
.
alloc
(
Statement
:
:
BlockStatement
{
block
:
block
.
unbox
(
)
loc
}
)
}
pub
fn
block
(
&
mut
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
statements
:
Option
<
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Block
<
'
alloc
>
>
>
{
self
.
check_block_bindings
(
open_token
.
loc
.
start
)
?
;
Ok
(
self
.
alloc
(
Block
{
statements
:
match
statements
{
Some
(
statements
)
=
>
statements
.
unbox
(
)
None
=
>
self
.
new_vec
(
)
}
declarations
:
None
loc
:
SourceLocation
:
:
from_parts
(
open_token
.
loc
close_token
.
loc
)
}
)
)
}
pub
fn
catch_block
(
&
mut
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
statements
:
Option
<
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Block
<
'
alloc
>
>
{
self
.
alloc
(
Block
{
statements
:
match
statements
{
Some
(
statements
)
=
>
statements
.
unbox
(
)
None
=
>
self
.
new_vec
(
)
}
declarations
:
None
loc
:
SourceLocation
:
:
from_parts
(
open_token
.
loc
close_token
.
loc
)
}
)
}
pub
fn
statement_list_single
(
&
self
statement
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
alloc
(
self
.
new_vec_single
(
statement
.
unbox
(
)
)
)
}
pub
fn
statement_list_append
(
&
self
mut
list
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
statement
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
push
(
&
mut
list
statement
.
unbox
(
)
)
;
list
}
pub
fn
lexical_declaration
(
&
mut
self
kind
:
arena
:
:
Box
<
'
alloc
VariableDeclarationKind
>
declarators
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
VariableDeclarator
<
'
alloc
>
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
let
binding_kind
=
match
&
*
kind
{
VariableDeclarationKind
:
:
Let
{
.
.
}
=
>
BindingKind
:
:
Let
VariableDeclarationKind
:
:
Const
{
.
.
}
=
>
BindingKind
:
:
Const
_
=
>
panic
!
(
"
unexpected
VariableDeclarationKind
"
)
}
;
self
.
mark_binding_kind
(
kind
.
get_loc
(
)
.
start
None
binding_kind
)
;
if
let
VariableDeclarationKind
:
:
Const
{
.
.
}
=
*
kind
{
for
v
in
declarators
.
iter
(
)
{
if
v
.
init
=
=
None
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
Missing
initializer
in
a
lexical
binding
.
"
)
)
;
}
}
}
let
kind_loc
=
kind
.
get_loc
(
)
;
let
declarator_loc
=
declarators
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
declarator
"
)
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Statement
:
:
VariableDeclarationStatement
(
VariableDeclaration
{
kind
:
kind
.
unbox
(
)
declarators
:
declarators
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
kind_loc
declarator_loc
)
}
)
)
)
}
pub
fn
for_lexical_declaration
(
&
mut
self
kind
:
arena
:
:
Box
<
'
alloc
VariableDeclarationKind
>
declarators
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
VariableDeclarator
<
'
alloc
>
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
VariableDeclarationOrExpression
<
'
alloc
>
>
>
{
let
binding_kind
=
match
&
*
kind
{
VariableDeclarationKind
:
:
Let
{
.
.
}
=
>
BindingKind
:
:
Let
VariableDeclarationKind
:
:
Const
{
.
.
}
=
>
BindingKind
:
:
Const
_
=
>
panic
!
(
"
unexpected
VariableDeclarationKind
"
)
}
;
self
.
mark_binding_kind
(
kind
.
get_loc
(
)
.
start
None
binding_kind
)
;
if
let
VariableDeclarationKind
:
:
Const
{
.
.
}
=
*
kind
{
for
v
in
declarators
.
iter
(
)
{
if
v
.
init
=
=
None
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
Missing
initializer
in
a
lexical
binding
.
"
)
)
;
}
}
}
let
kind_loc
=
kind
.
get_loc
(
)
;
let
declarator_loc
=
declarators
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
declarator
"
)
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
VariableDeclarationOrExpression
:
:
VariableDeclaration
(
VariableDeclaration
{
kind
:
kind
.
unbox
(
)
declarators
:
declarators
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
kind_loc
declarator_loc
)
}
)
)
)
}
pub
fn
let_kind
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
VariableDeclarationKind
>
{
self
.
alloc
(
VariableDeclarationKind
:
:
Let
{
loc
:
token
.
loc
}
)
}
pub
fn
const_kind
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
VariableDeclarationKind
>
{
self
.
alloc
(
VariableDeclarationKind
:
:
Const
{
loc
:
token
.
loc
}
)
}
pub
fn
variable_statement
(
&
mut
self
var_token
:
arena
:
:
Box
<
'
alloc
Token
>
declarators
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
VariableDeclarator
<
'
alloc
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
let
var_loc
=
var_token
.
loc
;
let
declarator_loc
=
declarators
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
declarator
"
)
.
get_loc
(
)
;
self
.
mark_binding_kind
(
var_loc
.
start
None
BindingKind
:
:
Var
)
;
self
.
alloc
(
Statement
:
:
VariableDeclarationStatement
(
VariableDeclaration
{
kind
:
VariableDeclarationKind
:
:
Var
{
loc
:
var_loc
}
declarators
:
declarators
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
var_loc
declarator_loc
)
}
)
)
}
pub
fn
variable_declaration_list_single
(
&
self
decl
:
arena
:
:
Box
<
'
alloc
VariableDeclarator
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
VariableDeclarator
<
'
alloc
>
>
>
{
self
.
alloc
(
self
.
new_vec_single
(
decl
.
unbox
(
)
)
)
}
pub
fn
variable_declaration_list_append
(
&
self
mut
list
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
VariableDeclarator
<
'
alloc
>
>
>
decl
:
arena
:
:
Box
<
'
alloc
VariableDeclarator
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
VariableDeclarator
<
'
alloc
>
>
>
{
self
.
push
(
&
mut
list
decl
.
unbox
(
)
)
;
list
}
pub
fn
variable_declaration
(
&
self
binding
:
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
init
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
VariableDeclarator
<
'
alloc
>
>
{
let
binding_loc
=
binding
.
get_loc
(
)
;
let
loc
=
match
init
{
Some
(
ref
init
)
=
>
SourceLocation
:
:
from_parts
(
binding_loc
init
.
get_loc
(
)
)
None
=
>
binding_loc
}
;
self
.
alloc
(
VariableDeclarator
{
binding
:
binding
.
unbox
(
)
init
loc
}
)
}
pub
fn
object_binding_pattern
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
properties
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
BindingProperty
<
'
alloc
>
>
>
rest
:
Option
<
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
{
self
.
alloc
(
Binding
:
:
BindingPattern
(
BindingPattern
:
:
ObjectBinding
(
ObjectBinding
{
properties
:
properties
.
unbox
(
)
rest
loc
:
SourceLocation
:
:
from_parts
(
open_token
.
loc
close_token
.
loc
)
}
)
)
)
}
pub
fn
binding_element_list_empty
(
&
self
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Option
<
Parameter
<
'
alloc
>
>
>
>
{
self
.
alloc
(
self
.
new_vec
(
)
)
}
pub
fn
array_binding_pattern
(
&
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
elements
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Option
<
Parameter
<
'
alloc
>
>
>
>
elision
:
Option
<
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
>
rest
:
Option
<
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
{
if
let
Some
(
elision
)
=
elision
{
for
_
in
0
.
.
elision
.
elements
.
len
(
)
{
self
.
push
(
&
mut
elements
None
)
;
}
}
self
.
alloc
(
Binding
:
:
BindingPattern
(
BindingPattern
:
:
ArrayBinding
(
ArrayBinding
{
elements
:
elements
.
unbox
(
)
rest
loc
:
SourceLocation
:
:
from_parts
(
open_token
.
loc
close_token
.
loc
)
}
)
)
)
}
pub
fn
binding_property_list_empty
(
&
self
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
BindingProperty
<
'
alloc
>
>
>
{
self
.
alloc
(
self
.
new_vec
(
)
)
}
pub
fn
binding_property_list_single
(
&
self
property
:
arena
:
:
Box
<
'
alloc
BindingProperty
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
BindingProperty
<
'
alloc
>
>
>
{
self
.
alloc
(
self
.
new_vec_single
(
property
.
unbox
(
)
)
)
}
pub
fn
binding_property_list_append
(
&
self
mut
list
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
BindingProperty
<
'
alloc
>
>
>
property
:
arena
:
:
Box
<
'
alloc
BindingProperty
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
BindingProperty
<
'
alloc
>
>
>
{
self
.
push
(
&
mut
list
property
.
unbox
(
)
)
;
list
}
pub
fn
binding_element_list_append
(
&
self
mut
list
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Option
<
Parameter
<
'
alloc
>
>
>
>
mut
element
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Option
<
Parameter
<
'
alloc
>
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Option
<
Parameter
<
'
alloc
>
>
>
>
{
self
.
append
(
&
mut
list
&
mut
element
)
;
list
}
pub
fn
binding_elision_element
(
&
self
elision
:
Option
<
arena
:
:
Box
<
'
alloc
ArrayExpression
<
'
alloc
>
>
>
element
:
arena
:
:
Box
<
'
alloc
Parameter
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Option
<
Parameter
<
'
alloc
>
>
>
>
{
let
elision_count
=
elision
.
map
(
|
v
|
v
.
elements
.
len
(
)
)
.
unwrap_or
(
0
)
;
let
mut
result
=
self
.
alloc
(
self
.
new_vec
(
)
)
;
for
_
in
0
.
.
elision_count
{
self
.
push
(
&
mut
result
None
)
;
}
self
.
push
(
&
mut
result
Some
(
element
.
unbox
(
)
)
)
;
result
}
pub
fn
binding_property_shorthand
(
&
self
binding
:
arena
:
:
Box
<
'
alloc
Parameter
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
BindingProperty
<
'
alloc
>
>
{
let
(
binding
init
)
=
match
binding
.
unbox
(
)
{
Parameter
:
:
Binding
(
binding
)
=
>
(
binding
None
)
Parameter
:
:
BindingWithDefault
(
BindingWithDefault
{
binding
init
.
.
}
)
=
>
{
(
binding
Some
(
init
.
unbox
(
)
)
)
}
}
;
let
binding
=
match
binding
{
Binding
:
:
BindingIdentifier
(
bi
)
=
>
bi
_
=
>
{
panic
!
(
"
invalid
argument
:
binding_property_shorthand
requires
a
Binding
:
:
BindingIdentifier
"
)
;
}
}
;
let
loc
=
binding
.
loc
;
self
.
alloc
(
BindingProperty
:
:
BindingPropertyIdentifier
(
BindingPropertyIdentifier
{
binding
init
:
init
.
map
(
|
x
|
self
.
alloc
(
x
)
)
loc
}
)
)
}
pub
fn
binding_property
(
&
self
name
:
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
binding
:
arena
:
:
Box
<
'
alloc
Parameter
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
BindingProperty
<
'
alloc
>
>
{
let
name_loc
=
name
.
get_loc
(
)
;
let
binding_loc
=
binding
.
get_loc
(
)
;
self
.
alloc
(
BindingProperty
:
:
BindingPropertyProperty
(
BindingPropertyProperty
{
name
:
name
.
unbox
(
)
binding
:
binding
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
name_loc
binding_loc
)
}
)
)
}
pub
fn
binding_element_pattern
(
&
self
binding
:
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
init
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Parameter
<
'
alloc
>
>
{
self
.
alloc
(
match
init
{
None
=
>
Parameter
:
:
Binding
(
binding
.
unbox
(
)
)
Some
(
init
)
=
>
{
let
binding_loc
=
binding
.
get_loc
(
)
;
let
init_loc
=
init
.
get_loc
(
)
;
Parameter
:
:
BindingWithDefault
(
BindingWithDefault
{
binding
:
binding
.
unbox
(
)
init
loc
:
SourceLocation
:
:
from_parts
(
binding_loc
init_loc
)
}
)
}
}
)
}
pub
fn
single_name_binding
(
&
self
name
:
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
init
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Parameter
<
'
alloc
>
>
{
let
binding
=
Binding
:
:
BindingIdentifier
(
name
.
unbox
(
)
)
;
self
.
alloc
(
match
init
{
None
=
>
Parameter
:
:
Binding
(
binding
)
Some
(
init
)
=
>
{
let
binding_loc
=
binding
.
get_loc
(
)
;
let
init_loc
=
init
.
get_loc
(
)
;
Parameter
:
:
BindingWithDefault
(
BindingWithDefault
{
binding
init
loc
:
SourceLocation
:
:
from_parts
(
binding_loc
init_loc
)
}
)
}
}
)
}
pub
fn
binding_rest_element
(
&
self
name
:
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
)
-
>
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
{
self
.
alloc
(
Binding
:
:
BindingIdentifier
(
name
.
unbox
(
)
)
)
}
pub
fn
empty_statement
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
self
.
alloc
(
Statement
:
:
EmptyStatement
{
loc
:
token
.
loc
}
)
}
pub
fn
expression_statement
(
&
self
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
self
.
alloc
(
Statement
:
:
ExpressionStatement
(
expression
)
)
}
pub
fn
if_statement
(
&
self
if_token
:
arena
:
:
Box
<
'
alloc
Token
>
test
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
consequent
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
alternate
:
Option
<
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_single_statement
(
&
consequent
)
?
;
if
let
Some
(
ref
stmt
)
=
alternate
{
self
.
check_single_statement
(
&
stmt
)
?
;
}
let
if_loc
=
if_token
.
loc
;
let
loc
=
match
alternate
{
Some
(
ref
alternate
)
=
>
SourceLocation
:
:
from_parts
(
if_loc
alternate
.
get_loc
(
)
)
None
=
>
SourceLocation
:
:
from_parts
(
if_loc
consequent
.
get_loc
(
)
)
}
;
Ok
(
self
.
alloc
(
Statement
:
:
IfStatement
(
IfStatement
{
test
consequent
alternate
loc
}
)
)
)
}
pub
fn
make_block_stmt_from_function_decl
(
&
mut
self
fun
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
let
fun_loc
=
fun
.
get_loc
(
)
;
if
self
.
is_strict
(
)
?
{
return
Err
(
ParseError
:
:
FunctionDeclInSingleStatement
)
;
}
self
.
check_block_bindings
(
fun_loc
.
start
)
?
;
Ok
(
self
.
alloc
(
Statement
:
:
BlockStatement
{
block
:
Block
{
statements
:
self
.
new_vec_single
(
fun
.
unbox
(
)
)
declarations
:
None
loc
:
fun_loc
}
loc
:
fun_loc
}
)
)
}
fn
is_strict
(
&
self
)
-
>
Result
<
'
alloc
bool
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
strict
-
mode
-
only
early
error
is
not
yet
supported
"
)
)
}
pub
fn
do_while_statement
(
&
self
do_token
:
arena
:
:
Box
<
'
alloc
Token
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
test
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_single_statement
(
&
stmt
)
?
;
Ok
(
self
.
alloc
(
Statement
:
:
DoWhileStatement
{
block
:
stmt
test
loc
:
SourceLocation
:
:
from_parts
(
do_token
.
loc
close_token
.
loc
)
}
)
)
}
pub
fn
while_statement
(
&
self
while_token
:
arena
:
:
Box
<
'
alloc
Token
>
test
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_single_statement
(
&
stmt
)
?
;
let
stmt_loc
=
stmt
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Statement
:
:
WhileStatement
{
test
block
:
stmt
loc
:
SourceLocation
:
:
from_parts
(
while_token
.
loc
stmt_loc
)
}
)
)
}
pub
fn
for_statement
(
&
self
for_token
:
arena
:
:
Box
<
'
alloc
Token
>
init
:
Option
<
VariableDeclarationOrExpression
<
'
alloc
>
>
test
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
update
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_single_statement
(
&
stmt
)
?
;
self
.
for_statement_common
(
for_token
init
test
update
stmt
)
}
pub
fn
for_statement_lexical
(
&
mut
self
for_token
:
arena
:
:
Box
<
'
alloc
Token
>
init
:
VariableDeclarationOrExpression
<
'
alloc
>
test
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
update
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_single_statement
(
&
stmt
)
?
;
self
.
check_lexical_for_bindings
(
&
init
.
get_loc
(
)
)
?
;
self
.
for_statement_common
(
for_token
Some
(
init
)
test
update
stmt
)
}
pub
fn
for_statement_common
(
&
self
for_token
:
arena
:
:
Box
<
'
alloc
Token
>
init
:
Option
<
VariableDeclarationOrExpression
<
'
alloc
>
>
test
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
update
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
let
stmt_loc
=
stmt
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Statement
:
:
ForStatement
{
init
test
update
block
:
stmt
loc
:
SourceLocation
:
:
from_parts
(
for_token
.
loc
stmt_loc
)
}
)
)
}
pub
fn
for_expression
(
&
self
expr
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
)
-
>
Option
<
VariableDeclarationOrExpression
<
'
alloc
>
>
{
expr
.
map
(
|
expr
|
VariableDeclarationOrExpression
:
:
Expression
(
expr
)
)
}
pub
fn
for_var_declaration
(
&
mut
self
var_token
:
arena
:
:
Box
<
'
alloc
Token
>
declarators
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
VariableDeclarator
<
'
alloc
>
>
>
)
-
>
VariableDeclarationOrExpression
<
'
alloc
>
{
let
var_loc
=
var_token
.
loc
;
let
declarator_loc
=
declarators
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
declarator
"
)
.
get_loc
(
)
;
self
.
mark_binding_kind
(
var_loc
.
start
Some
(
declarator_loc
.
end
)
BindingKind
:
:
Var
)
;
VariableDeclarationOrExpression
:
:
VariableDeclaration
(
VariableDeclaration
{
kind
:
VariableDeclarationKind
:
:
Var
{
loc
:
var_loc
}
declarators
:
declarators
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
var_loc
declarator_loc
)
}
)
}
pub
fn
unbox_for_lexical_declaration
(
&
self
declaration
:
arena
:
:
Box
<
'
alloc
VariableDeclarationOrExpression
<
'
alloc
>
>
)
-
>
VariableDeclarationOrExpression
<
'
alloc
>
{
declaration
.
unbox
(
)
}
pub
fn
for_in_statement
(
&
self
for_token
:
arena
:
:
Box
<
'
alloc
Token
>
left
:
VariableDeclarationOrAssignmentTarget
<
'
alloc
>
right
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_single_statement
(
&
stmt
)
?
;
self
.
for_in_statement_common
(
for_token
left
right
stmt
)
}
pub
fn
for_in_statement_lexical
(
&
mut
self
for_token
:
arena
:
:
Box
<
'
alloc
Token
>
left
:
VariableDeclarationOrAssignmentTarget
<
'
alloc
>
right
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_single_statement
(
&
stmt
)
?
;
self
.
check_lexical_for_bindings
(
&
left
.
get_loc
(
)
)
?
;
self
.
for_in_statement_common
(
for_token
left
right
stmt
)
}
pub
fn
for_in_statement_common
(
&
self
for_token
:
arena
:
:
Box
<
'
alloc
Token
>
left
:
VariableDeclarationOrAssignmentTarget
<
'
alloc
>
right
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
let
stmt_loc
=
stmt
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Statement
:
:
ForInStatement
{
left
right
block
:
stmt
loc
:
SourceLocation
:
:
from_parts
(
for_token
.
loc
stmt_loc
)
}
)
)
}
pub
fn
for_in_or_of_var_declaration
(
&
mut
self
var_token
:
arena
:
:
Box
<
'
alloc
Token
>
binding
:
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
init
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
)
-
>
VariableDeclarationOrAssignmentTarget
<
'
alloc
>
{
let
var_loc
=
var_token
.
loc
;
let
binding_loc
=
binding
.
get_loc
(
)
;
let
decl_loc
=
match
init
{
Some
(
ref
init
)
=
>
SourceLocation
:
:
from_parts
(
binding_loc
init
.
get_loc
(
)
)
None
=
>
binding_loc
}
;
self
.
mark_binding_kind
(
binding_loc
.
start
Some
(
binding_loc
.
end
)
BindingKind
:
:
Var
)
;
VariableDeclarationOrAssignmentTarget
:
:
VariableDeclaration
(
VariableDeclaration
{
kind
:
VariableDeclarationKind
:
:
Var
{
loc
:
var_loc
}
declarators
:
self
.
new_vec_single
(
VariableDeclarator
{
binding
:
binding
.
unbox
(
)
init
loc
:
decl_loc
}
)
loc
:
SourceLocation
:
:
from_parts
(
var_loc
decl_loc
)
}
)
}
pub
fn
for_assignment_target
(
&
self
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
VariableDeclarationOrAssignmentTarget
<
'
alloc
>
>
{
Ok
(
VariableDeclarationOrAssignmentTarget
:
:
AssignmentTarget
(
self
.
expression_to_assignment_target
(
expression
)
?
)
)
}
pub
fn
unbox_for_declaration
(
&
self
declaration
:
arena
:
:
Box
<
'
alloc
VariableDeclarationOrAssignmentTarget
<
'
alloc
>
>
)
-
>
VariableDeclarationOrAssignmentTarget
<
'
alloc
>
{
declaration
.
unbox
(
)
}
pub
fn
for_of_statement
(
&
self
for_token
:
arena
:
:
Box
<
'
alloc
Token
>
left
:
VariableDeclarationOrAssignmentTarget
<
'
alloc
>
right
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_single_statement
(
&
stmt
)
?
;
self
.
for_of_statement_common
(
for_token
left
right
stmt
)
}
pub
fn
for_of_statement_lexical
(
&
mut
self
for_token
:
arena
:
:
Box
<
'
alloc
Token
>
left
:
VariableDeclarationOrAssignmentTarget
<
'
alloc
>
right
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_single_statement
(
&
stmt
)
?
;
self
.
check_lexical_for_bindings
(
&
left
.
get_loc
(
)
)
?
;
self
.
for_of_statement_common
(
for_token
left
right
stmt
)
}
pub
fn
for_of_statement_common
(
&
self
for_token
:
arena
:
:
Box
<
'
alloc
Token
>
left
:
VariableDeclarationOrAssignmentTarget
<
'
alloc
>
right
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
let
stmt_loc
=
stmt
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Statement
:
:
ForOfStatement
{
left
right
block
:
stmt
loc
:
SourceLocation
:
:
from_parts
(
for_token
.
loc
stmt_loc
)
}
)
)
}
pub
fn
for_await_of_statement
(
&
self
for_token
:
arena
:
:
Box
<
'
alloc
Token
>
left
:
VariableDeclarationOrAssignmentTarget
right
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_single_statement
(
&
stmt
)
?
;
self
.
for_await_of_statement_common
(
for_token
left
right
stmt
)
}
pub
fn
for_await_of_statement_lexical
(
&
mut
self
for_token
:
arena
:
:
Box
<
'
alloc
Token
>
left
:
VariableDeclarationOrAssignmentTarget
right
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_single_statement
(
&
stmt
)
?
;
self
.
check_lexical_for_bindings
(
&
left
.
get_loc
(
)
)
?
;
self
.
for_await_of_statement_common
(
for_token
left
right
stmt
)
}
pub
fn
for_await_of_statement_common
(
&
self
_for_token
:
arena
:
:
Box
<
'
alloc
Token
>
_left
:
VariableDeclarationOrAssignmentTarget
_right
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
_stmt
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
for
await
statement
(
missing
from
AST
)
"
)
)
}
pub
fn
for_declaration
(
&
mut
self
kind
:
arena
:
:
Box
<
'
alloc
VariableDeclarationKind
>
binding
:
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
VariableDeclarationOrAssignmentTarget
<
'
alloc
>
>
{
let
binding_kind
=
match
&
*
kind
{
VariableDeclarationKind
:
:
Let
{
.
.
}
=
>
BindingKind
:
:
Let
VariableDeclarationKind
:
:
Const
{
.
.
}
=
>
BindingKind
:
:
Const
_
=
>
panic
!
(
"
unexpected
VariableDeclarationKind
"
)
}
;
self
.
mark_binding_kind
(
kind
.
get_loc
(
)
.
start
None
binding_kind
)
;
let
kind_loc
=
kind
.
get_loc
(
)
;
let
binding_loc
=
binding
.
get_loc
(
)
;
self
.
alloc
(
VariableDeclarationOrAssignmentTarget
:
:
VariableDeclaration
(
VariableDeclaration
{
kind
:
kind
.
unbox
(
)
declarators
:
self
.
new_vec_single
(
VariableDeclarator
{
binding
:
binding
.
unbox
(
)
init
:
None
loc
:
binding_loc
}
)
loc
:
SourceLocation
:
:
from_parts
(
kind_loc
binding_loc
)
}
)
)
}
pub
fn
binding_identifier_to_binding
(
&
self
identifier
:
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
)
-
>
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
{
self
.
alloc
(
Binding
:
:
BindingIdentifier
(
identifier
.
unbox
(
)
)
)
}
pub
fn
continue_statement
(
&
self
continue_token
:
arena
:
:
Box
<
'
alloc
Token
>
label
:
Option
<
arena
:
:
Box
<
'
alloc
Label
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
let
continue_loc
=
continue_token
.
loc
;
let
loc
=
match
label
{
Some
(
ref
label
)
=
>
SourceLocation
:
:
from_parts
(
continue_loc
label
.
loc
)
None
=
>
continue_loc
}
;
self
.
alloc
(
Statement
:
:
ContinueStatement
{
label
:
label
.
map
(
|
boxed
|
boxed
.
unbox
(
)
)
loc
}
)
}
pub
fn
break_statement
(
&
self
break_token
:
arena
:
:
Box
<
'
alloc
Token
>
label
:
Option
<
arena
:
:
Box
<
'
alloc
Label
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
let
break_loc
=
break_token
.
loc
;
let
loc
=
match
label
{
Some
(
ref
label
)
=
>
SourceLocation
:
:
from_parts
(
break_loc
label
.
loc
)
None
=
>
break_loc
}
;
self
.
alloc
(
Statement
:
:
BreakStatement
{
label
:
label
.
map
(
|
boxed
|
boxed
.
unbox
(
)
)
loc
}
)
}
pub
fn
return_statement
(
&
self
return_token
:
arena
:
:
Box
<
'
alloc
Token
>
expression
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
let
return_loc
=
return_token
.
loc
;
let
loc
=
match
expression
{
Some
(
ref
expression
)
=
>
SourceLocation
:
:
from_parts
(
return_loc
expression
.
get_loc
(
)
)
None
=
>
return_loc
}
;
self
.
alloc
(
Statement
:
:
ReturnStatement
{
expression
loc
}
)
}
pub
fn
with_statement
(
&
self
with_token
:
arena
:
:
Box
<
'
alloc
Token
>
object
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
body
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
let
body_loc
=
body
.
get_loc
(
)
;
self
.
alloc
(
Statement
:
:
WithStatement
{
object
body
loc
:
SourceLocation
:
:
from_parts
(
with_token
.
loc
body_loc
)
}
)
}
pub
fn
switch_statement
(
&
self
switch_token
:
arena
:
:
Box
<
'
alloc
Token
>
discriminant_expr
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
mut
cases
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
match
&
mut
*
cases
{
Statement
:
:
SwitchStatement
{
discriminant
loc
.
.
}
=
>
{
*
discriminant
=
discriminant_expr
;
(
*
loc
)
.
start
=
switch_token
.
loc
.
start
;
}
Statement
:
:
SwitchStatementWithDefault
{
discriminant
loc
.
.
}
=
>
{
*
discriminant
=
discriminant_expr
;
(
*
loc
)
.
start
=
switch_token
.
loc
.
start
;
}
_
=
>
{
panic
!
(
"
invalid
argument
:
argument
2
must
be
a
SwitchStatement
"
)
;
}
}
cases
}
pub
fn
case_block
(
&
mut
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
cases
:
Option
<
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
SwitchCase
<
'
alloc
>
>
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_case_block_binding
(
open_token
.
loc
.
start
)
?
;
Ok
(
self
.
alloc
(
Statement
:
:
SwitchStatement
{
discriminant
:
self
.
alloc
(
Expression
:
:
LiteralNullExpression
{
loc
:
SourceLocation
:
:
default
(
)
}
)
cases
:
match
cases
{
None
=
>
self
.
new_vec
(
)
Some
(
boxed
)
=
>
boxed
.
unbox
(
)
}
loc
:
close_token
.
loc
}
)
)
}
pub
fn
case_block_with_default
(
&
mut
self
open_token
:
arena
:
:
Box
<
'
alloc
Token
>
pre_default_cases
:
Option
<
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
SwitchCase
<
'
alloc
>
>
>
>
default_case
:
arena
:
:
Box
<
'
alloc
SwitchDefault
<
'
alloc
>
>
post_default_cases
:
Option
<
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
SwitchCase
<
'
alloc
>
>
>
>
close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
check_case_block_binding
(
open_token
.
loc
.
start
)
?
;
Ok
(
self
.
alloc
(
Statement
:
:
SwitchStatementWithDefault
{
discriminant
:
self
.
alloc
(
Expression
:
:
LiteralNullExpression
{
loc
:
SourceLocation
:
:
default
(
)
}
)
pre_default_cases
:
match
pre_default_cases
{
None
=
>
self
.
new_vec
(
)
Some
(
boxed
)
=
>
boxed
.
unbox
(
)
}
default_case
:
default_case
.
unbox
(
)
post_default_cases
:
match
post_default_cases
{
None
=
>
self
.
new_vec
(
)
Some
(
boxed
)
=
>
boxed
.
unbox
(
)
}
loc
:
close_token
.
loc
}
)
)
}
pub
fn
case_clauses_single
(
&
self
case
:
arena
:
:
Box
<
'
alloc
SwitchCase
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
SwitchCase
<
'
alloc
>
>
>
{
self
.
alloc
(
self
.
new_vec_single
(
case
.
unbox
(
)
)
)
}
pub
fn
case_clauses_append
(
&
self
mut
cases
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
SwitchCase
<
'
alloc
>
>
>
case
:
arena
:
:
Box
<
'
alloc
SwitchCase
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
SwitchCase
<
'
alloc
>
>
>
{
self
.
push
(
&
mut
cases
case
.
unbox
(
)
)
;
cases
}
pub
fn
case_clause
(
&
self
case_token
:
arena
:
:
Box
<
'
alloc
Token
>
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
colon_token
:
arena
:
:
Box
<
'
alloc
Token
>
statements
:
Option
<
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
SwitchCase
<
'
alloc
>
>
{
let
case_loc
=
case_token
.
loc
;
if
let
Some
(
statements
)
=
statements
{
let
statement_loc
=
statements
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
statement
"
)
.
get_loc
(
)
;
self
.
alloc
(
SwitchCase
{
test
:
expression
consequent
:
statements
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
case_loc
statement_loc
)
}
)
}
else
{
self
.
alloc
(
SwitchCase
{
test
:
expression
consequent
:
self
.
new_vec
(
)
loc
:
SourceLocation
:
:
from_parts
(
case_loc
colon_token
.
loc
)
}
)
}
}
pub
fn
default_clause
(
&
self
default_token
:
arena
:
:
Box
<
'
alloc
Token
>
colon_token
:
arena
:
:
Box
<
'
alloc
Token
>
statements
:
Option
<
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
SwitchDefault
<
'
alloc
>
>
{
let
default_loc
=
default_token
.
loc
;
if
let
Some
(
statements
)
=
statements
{
let
statement_loc
=
statements
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
statement
"
)
.
get_loc
(
)
;
self
.
alloc
(
SwitchDefault
{
consequent
:
statements
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
default_loc
statement_loc
)
}
)
}
else
{
self
.
alloc
(
SwitchDefault
{
consequent
:
self
.
new_vec
(
)
loc
:
SourceLocation
:
:
from_parts
(
default_loc
colon_token
.
loc
)
}
)
}
}
pub
fn
labelled_statement
(
&
self
label
:
arena
:
:
Box
<
'
alloc
Label
>
body
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
let
label_loc
=
label
.
loc
;
let
body_loc
=
body
.
get_loc
(
)
;
self
.
alloc
(
Statement
:
:
LabeledStatement
{
label
:
label
.
unbox
(
)
body
loc
:
SourceLocation
:
:
from_parts
(
label_loc
body_loc
)
}
)
}
pub
fn
throw_statement
(
&
self
throw_token
:
arena
:
:
Box
<
'
alloc
Token
>
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
let
expression_loc
=
expression
.
get_loc
(
)
;
self
.
alloc
(
Statement
:
:
ThrowStatement
{
expression
loc
:
SourceLocation
:
:
from_parts
(
throw_token
.
loc
expression_loc
)
}
)
}
pub
fn
try_statement
(
&
self
try_token
:
arena
:
:
Box
<
'
alloc
Token
>
body
:
arena
:
:
Box
<
'
alloc
Block
<
'
alloc
>
>
catch_clause
:
Option
<
arena
:
:
Box
<
'
alloc
CatchClause
<
'
alloc
>
>
>
finally_block
:
Option
<
arena
:
:
Box
<
'
alloc
Block
<
'
alloc
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
let
try_loc
=
try_token
.
loc
;
match
(
catch_clause
finally_block
)
{
(
Some
(
catch_clause
)
None
)
=
>
{
let
catch_clause_loc
=
catch_clause
.
loc
;
self
.
alloc
(
Statement
:
:
TryCatchStatement
{
body
:
body
.
unbox
(
)
catch_clause
:
catch_clause
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
try_loc
catch_clause_loc
)
}
)
}
(
catch_clause
Some
(
finally_block
)
)
=
>
{
let
finally_block_loc
=
finally_block
.
loc
;
self
.
alloc
(
Statement
:
:
TryFinallyStatement
{
body
:
body
.
unbox
(
)
catch_clause
:
catch_clause
.
map
(
|
boxed
|
boxed
.
unbox
(
)
)
finalizer
:
finally_block
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
try_loc
finally_block_loc
)
}
)
}
_
=
>
{
panic
!
(
"
invalid
argument
:
try_statement
requires
a
catch
or
finally
block
"
)
;
}
}
}
pub
fn
catch
(
&
mut
self
catch_token
:
arena
:
:
Box
<
'
alloc
Token
>
binding
:
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
body
:
arena
:
:
Box
<
'
alloc
Block
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
CatchClause
<
'
alloc
>
>
>
{
let
catch_loc
=
catch_token
.
loc
;
let
body_loc
=
body
.
loc
;
let
is_simple
=
match
&
*
binding
{
Binding
:
:
BindingIdentifier
(
_
)
=
>
true
_
=
>
false
}
;
self
.
check_catch_bindings
(
is_simple
&
binding
.
get_loc
(
)
)
?
;
Ok
(
self
.
alloc
(
CatchClause
{
binding
:
Some
(
binding
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
catch_loc
body_loc
)
}
)
)
}
pub
fn
catch_no_param
(
&
mut
self
catch_token
:
arena
:
:
Box
<
'
alloc
Token
>
body
:
arena
:
:
Box
<
'
alloc
Block
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
CatchClause
<
'
alloc
>
>
>
{
let
catch_loc
=
catch_token
.
loc
;
let
body_loc
=
body
.
loc
;
self
.
check_catch_no_param_bindings
(
catch_loc
.
start
)
?
;
Ok
(
self
.
alloc
(
CatchClause
{
binding
:
None
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
catch_loc
body_loc
)
}
)
)
}
pub
fn
debugger_statement
(
&
self
token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
self
.
alloc
(
Statement
:
:
DebuggerStatement
{
loc
:
token
.
loc
}
)
}
pub
fn
function_decl
(
&
mut
self
f
:
Function
<
'
alloc
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
self
.
mark_binding_kind
(
f
.
loc
.
start
None
BindingKind
:
:
Function
)
;
self
.
alloc
(
Statement
:
:
FunctionDeclaration
(
f
)
)
}
pub
fn
async_or_generator_decl
(
&
mut
self
f
:
Function
<
'
alloc
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
self
.
mark_binding_kind
(
f
.
loc
.
start
None
BindingKind
:
:
AsyncOrGenerator
)
;
self
.
alloc
(
Statement
:
:
FunctionDeclaration
(
f
)
)
}
pub
fn
function_expr
(
&
mut
self
f
:
Function
<
'
alloc
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
index
=
self
.
find_first_binding
(
f
.
loc
.
start
)
;
self
.
pop_bindings_from
(
index
)
;
self
.
alloc
(
Expression
:
:
FunctionExpression
(
f
)
)
}
pub
fn
function
(
&
mut
self
function_token
:
arena
:
:
Box
<
'
alloc
Token
>
name
:
Option
<
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
param_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
params
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
param_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
body_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
body
:
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
Function
<
'
alloc
>
>
{
let
param_open_loc
=
param_open_token
.
loc
;
let
param_close_loc
=
param_close_token
.
loc
;
let
body_close_loc
=
body_close_token
.
loc
;
let
is_simple
=
Self
:
:
is_params_simple
(
&
params
)
;
self
.
check_function_bindings
(
is_simple
param_open_loc
.
start
param_close_loc
.
end
)
?
;
params
.
loc
.
set_range
(
param_open_loc
param_close_loc
)
;
body
.
loc
.
set_range
(
body_open_token
.
loc
body_close_loc
)
;
Ok
(
Function
{
name
:
name
.
map
(
|
b
|
b
.
unbox
(
)
)
is_async
:
false
is_generator
:
false
params
:
params
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
function_token
.
loc
body_close_loc
)
}
)
}
pub
fn
async_function
(
&
mut
self
async_token
:
arena
:
:
Box
<
'
alloc
Token
>
name
:
Option
<
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
param_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
params
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
param_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
body_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
body
:
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
Function
<
'
alloc
>
>
{
let
param_open_loc
=
param_open_token
.
loc
;
let
param_close_loc
=
param_close_token
.
loc
;
let
body_close_loc
=
body_close_token
.
loc
;
let
is_simple
=
Self
:
:
is_params_simple
(
&
params
)
;
self
.
check_function_bindings
(
is_simple
param_open_loc
.
start
param_close_loc
.
end
)
?
;
params
.
loc
.
set_range
(
param_open_loc
param_close_loc
)
;
body
.
loc
.
set_range
(
body_open_token
.
loc
body_close_loc
)
;
Ok
(
Function
{
name
:
name
.
map
(
|
b
|
b
.
unbox
(
)
)
is_async
:
true
is_generator
:
false
params
:
params
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
async_token
.
loc
body_close_loc
)
}
)
}
pub
fn
generator
(
&
mut
self
function_token
:
arena
:
:
Box
<
'
alloc
Token
>
name
:
Option
<
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
param_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
params
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
param_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
body_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
body
:
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
Function
<
'
alloc
>
>
{
let
param_open_loc
=
param_open_token
.
loc
;
let
param_close_loc
=
param_close_token
.
loc
;
let
body_close_loc
=
body_close_token
.
loc
;
let
is_simple
=
Self
:
:
is_params_simple
(
&
params
)
;
self
.
check_function_bindings
(
is_simple
param_open_loc
.
start
param_close_loc
.
end
)
?
;
params
.
loc
.
set_range
(
param_open_loc
param_close_loc
)
;
body
.
loc
.
set_range
(
body_open_token
.
loc
body_close_loc
)
;
Ok
(
Function
{
name
:
name
.
map
(
|
b
|
b
.
unbox
(
)
)
is_async
:
false
is_generator
:
true
params
:
params
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
function_token
.
loc
body_close_loc
)
}
)
}
pub
fn
async_generator
(
&
mut
self
async_token
:
arena
:
:
Box
<
'
alloc
Token
>
name
:
Option
<
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
param_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
params
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
param_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
body_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
body
:
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
Function
<
'
alloc
>
>
{
let
param_open_loc
=
param_open_token
.
loc
;
let
param_close_loc
=
param_close_token
.
loc
;
let
body_close_loc
=
body_close_token
.
loc
;
let
is_simple
=
Self
:
:
is_params_simple
(
&
params
)
;
self
.
check_function_bindings
(
is_simple
param_open_loc
.
start
param_close_loc
.
end
)
?
;
params
.
loc
.
set_range
(
param_open_loc
param_close_loc
)
;
body
.
loc
.
set_range
(
body_open_token
.
loc
body_close_loc
)
;
Ok
(
Function
{
name
:
name
.
map
(
|
b
|
b
.
unbox
(
)
)
is_async
:
true
is_generator
:
true
params
:
params
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
async_token
.
loc
body_close_loc
)
}
)
}
pub
fn
unique_formal_parameters
(
&
self
parameters
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
{
parameters
}
pub
fn
empty_formal_parameters
(
&
self
)
-
>
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
{
self
.
alloc
(
FormalParameters
{
items
:
self
.
new_vec
(
)
rest
:
None
loc
:
SourceLocation
:
:
default
(
)
}
)
}
pub
fn
with_rest_parameter
(
&
self
mut
params
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
rest
:
arena
:
:
Box
<
'
alloc
Binding
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
{
params
.
rest
=
Some
(
rest
.
unbox
(
)
)
;
params
}
pub
fn
formal_parameter_list_single
(
&
self
parameter
:
arena
:
:
Box
<
'
alloc
Parameter
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
{
self
.
alloc
(
FormalParameters
{
items
:
self
.
new_vec_single
(
parameter
.
unbox
(
)
)
rest
:
None
loc
:
SourceLocation
:
:
default
(
)
}
)
}
pub
fn
formal_parameter_list_append
(
&
self
mut
params
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
next_param
:
arena
:
:
Box
<
'
alloc
Parameter
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
{
self
.
push
(
&
mut
params
.
items
next_param
.
unbox
(
)
)
;
params
}
pub
fn
function_body
(
&
self
statements
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
{
self
.
alloc
(
FunctionBody
{
directives
:
self
.
new_vec
(
)
statements
:
statements
.
unbox
(
)
loc
:
SourceLocation
:
:
default
(
)
}
)
}
pub
fn
function_statement_list
(
&
self
statements
:
Option
<
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
{
match
statements
{
Some
(
statements
)
=
>
statements
None
=
>
self
.
alloc
(
self
.
new_vec
(
)
)
}
}
pub
fn
arrow_function
(
&
mut
self
params
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
body
:
arena
:
:
Box
<
'
alloc
ArrowExpressionBody
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
self
.
check_unique_function_bindings
(
params
.
loc
.
start
params
.
loc
.
end
)
?
;
let
params_loc
=
params
.
loc
;
let
body_loc
=
body
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Expression
:
:
ArrowExpression
{
is_async
:
false
params
:
params
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
params_loc
body_loc
)
}
)
)
}
pub
fn
arrow_parameters_bare
(
&
mut
self
identifier
:
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
)
-
>
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
{
let
loc
=
identifier
.
loc
;
self
.
alloc
(
FormalParameters
{
items
:
self
.
new_vec_single
(
Parameter
:
:
Binding
(
Binding
:
:
BindingIdentifier
(
identifier
.
unbox
(
)
)
)
)
rest
:
None
loc
}
)
}
pub
fn
uncover_arrow_parameters
(
&
self
covered
:
arena
:
:
Box
<
'
alloc
CoverParenthesized
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
>
{
Ok
(
match
covered
.
unbox
(
)
{
CoverParenthesized
:
:
Expression
{
expression
loc
}
=
>
self
.
alloc
(
FormalParameters
{
items
:
self
.
expression_to_parameter_list
(
expression
)
?
rest
:
None
loc
}
)
CoverParenthesized
:
:
Parameters
(
parameters
)
=
>
parameters
}
)
}
pub
fn
concise_body_expression
(
&
self
expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ArrowExpressionBody
<
'
alloc
>
>
{
self
.
alloc
(
ArrowExpressionBody
:
:
Expression
(
expression
)
)
}
pub
fn
concise_body_block
(
&
self
body_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
body
:
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
ArrowExpressionBody
<
'
alloc
>
>
{
body
.
loc
.
set_range
(
body_open_token
.
loc
body_close_token
.
loc
)
;
self
.
alloc
(
ArrowExpressionBody
:
:
FunctionBody
(
body
.
unbox
(
)
)
)
}
pub
fn
method_definition
(
&
mut
self
name
:
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
param_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
params
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
param_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
body_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
body
:
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
MethodDefinition
<
'
alloc
>
>
>
{
let
name_loc
=
name
.
get_loc
(
)
;
let
param_open_loc
=
param_open_token
.
loc
;
let
param_close_loc
=
param_close_token
.
loc
;
let
body_close_loc
=
body_close_token
.
loc
;
self
.
check_unique_function_bindings
(
param_open_loc
.
start
param_close_loc
.
end
)
?
;
params
.
loc
.
set_range
(
param_open_loc
param_close_loc
)
;
body
.
loc
.
set_range
(
body_open_token
.
loc
body_close_loc
)
;
Ok
(
self
.
alloc
(
MethodDefinition
:
:
Method
(
Method
{
name
:
name
.
unbox
(
)
is_async
:
false
is_generator
:
false
params
:
params
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
name_loc
body_close_loc
)
}
)
)
)
}
pub
fn
getter
(
&
self
get_token
:
arena
:
:
Box
<
'
alloc
Token
>
name
:
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
body_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
body
:
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
MethodDefinition
<
'
alloc
>
>
{
let
body_close_loc
=
body_close_token
.
loc
;
body
.
loc
.
set_range
(
body_open_token
.
loc
body_close_loc
)
;
self
.
alloc
(
MethodDefinition
:
:
Getter
(
Getter
{
property_name
:
name
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
get_token
.
loc
body_close_loc
)
}
)
)
}
pub
fn
setter
(
&
mut
self
set_token
:
arena
:
:
Box
<
'
alloc
Token
>
name
:
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
param_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
parameter
:
arena
:
:
Box
<
'
alloc
Parameter
<
'
alloc
>
>
param_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
body_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
body
:
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
MethodDefinition
<
'
alloc
>
>
>
{
let
param_open_loc
=
param_open_token
.
loc
;
let
param_close_loc
=
param_close_token
.
loc
;
let
body_close_loc
=
body_close_token
.
loc
;
self
.
check_unique_function_bindings
(
param_open_loc
.
start
param_close_loc
.
end
)
?
;
parameter
.
set_loc
(
param_open_loc
param_close_loc
)
;
body
.
loc
.
set_range
(
body_open_token
.
loc
body_close_loc
)
;
Ok
(
self
.
alloc
(
MethodDefinition
:
:
Setter
(
Setter
{
property_name
:
name
.
unbox
(
)
param
:
parameter
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
set_token
.
loc
body_close_loc
)
}
)
)
)
}
pub
fn
generator_method
(
&
mut
self
generator_token
:
arena
:
:
Box
<
'
alloc
Token
>
name
:
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
param_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
params
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
param_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
body_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
body
:
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
MethodDefinition
<
'
alloc
>
>
>
{
let
param_open_loc
=
param_open_token
.
loc
;
let
param_close_loc
=
param_close_token
.
loc
;
let
body_close_loc
=
body_close_token
.
loc
;
self
.
check_unique_function_bindings
(
param_open_loc
.
start
param_close_loc
.
end
)
?
;
params
.
loc
.
set_range
(
param_open_loc
param_close_loc
)
;
body
.
loc
.
set_range
(
body_open_token
.
loc
body_close_loc
)
;
Ok
(
self
.
alloc
(
MethodDefinition
:
:
Method
(
Method
{
name
:
name
.
unbox
(
)
is_async
:
false
is_generator
:
true
params
:
params
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
generator_token
.
loc
body_close_loc
)
}
)
)
)
}
pub
fn
yield_expr
(
&
self
yield_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
yield_loc
=
yield_token
.
loc
;
let
loc
=
match
operand
{
Some
(
ref
operand
)
=
>
SourceLocation
:
:
from_parts
(
yield_loc
operand
.
get_loc
(
)
)
None
=
>
yield_loc
}
;
self
.
alloc
(
Expression
:
:
YieldExpression
{
expression
:
operand
loc
}
)
}
pub
fn
yield_star_expr
(
&
self
yield_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
yield_loc
=
yield_token
.
loc
;
let
operand_loc
=
operand
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
YieldGeneratorExpression
{
expression
:
operand
loc
:
SourceLocation
:
:
from_parts
(
yield_loc
operand_loc
)
}
)
}
pub
fn
async_generator_method
(
&
mut
self
async_token
:
arena
:
:
Box
<
'
alloc
Token
>
name
:
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
param_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
params
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
param_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
body_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
body
:
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
MethodDefinition
<
'
alloc
>
>
>
{
let
param_open_loc
=
param_open_token
.
loc
;
let
param_close_loc
=
param_close_token
.
loc
;
let
body_close_loc
=
body_close_token
.
loc
;
self
.
check_unique_function_bindings
(
param_open_loc
.
start
param_close_loc
.
end
)
?
;
params
.
loc
.
set_range
(
param_open_loc
param_close_loc
)
;
body
.
loc
.
set_range
(
body_open_token
.
loc
body_close_loc
)
;
Ok
(
self
.
alloc
(
MethodDefinition
:
:
Method
(
Method
{
name
:
name
.
unbox
(
)
is_async
:
true
is_generator
:
true
params
:
params
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
async_token
.
loc
body_close_loc
)
}
)
)
)
}
pub
fn
class_declaration
(
&
mut
self
class_token
:
arena
:
:
Box
<
'
alloc
Token
>
name
:
Option
<
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
tail
:
arena
:
:
Box
<
'
alloc
ClassExpression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
{
let
class_loc
=
class_token
.
loc
;
self
.
mark_binding_kind
(
class_loc
.
start
None
BindingKind
:
:
Class
)
;
let
tail
=
tail
.
unbox
(
)
;
let
tail_loc
=
tail
.
loc
;
self
.
alloc
(
Statement
:
:
ClassDeclaration
(
ClassDeclaration
{
name
:
match
name
{
None
=
>
{
let
loc
=
SourceLocation
:
:
new
(
class_loc
.
end
class_loc
.
end
)
;
BindingIdentifier
{
name
:
Identifier
{
value
:
CommonSourceAtomSetIndices
:
:
default
(
)
loc
}
loc
}
}
Some
(
bi
)
=
>
bi
.
unbox
(
)
}
super_
:
tail
.
super_
elements
:
tail
.
elements
loc
:
SourceLocation
:
:
from_parts
(
class_loc
tail_loc
)
}
)
)
}
pub
fn
class_expression
(
&
mut
self
class_token
:
arena
:
:
Box
<
'
alloc
Token
>
name
:
Option
<
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
mut
tail
:
arena
:
:
Box
<
'
alloc
ClassExpression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
index
=
self
.
find_first_binding
(
class_token
.
loc
.
start
)
;
self
.
pop_bindings_from
(
index
)
;
tail
.
name
=
name
.
map
(
|
boxed
|
boxed
.
unbox
(
)
)
;
tail
.
loc
.
start
=
class_token
.
loc
.
start
;
self
.
alloc
(
Expression
:
:
ClassExpression
(
tail
.
unbox
(
)
)
)
}
pub
fn
class_tail
(
&
self
heritage
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
body
:
Option
<
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
arena
:
:
Box
<
'
alloc
ClassElement
<
'
alloc
>
>
>
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
ClassExpression
<
'
alloc
>
>
{
self
.
alloc
(
ClassExpression
{
name
:
None
super_
:
heritage
elements
:
match
body
{
None
=
>
self
.
new_vec
(
)
Some
(
boxed
)
=
>
boxed
.
unbox
(
)
}
loc
:
body_close_token
.
loc
}
)
}
pub
fn
class_element_list_append
(
&
self
mut
list
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
arena
:
:
Box
<
'
alloc
ClassElement
<
'
alloc
>
>
>
>
mut
element
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
arena
:
:
Box
<
'
alloc
ClassElement
<
'
alloc
>
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
arena
:
:
Box
<
'
alloc
ClassElement
<
'
alloc
>
>
>
>
{
self
.
append
(
&
mut
list
&
mut
element
)
;
list
}
pub
fn
class_field_definition
(
&
self
name
:
arena
:
:
Box
<
'
alloc
ClassElementName
<
'
alloc
>
>
init
:
Option
<
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ClassElement
<
'
alloc
>
>
{
let
name_loc
=
name
.
get_loc
(
)
;
let
loc
=
match
&
init
{
None
=
>
name_loc
Some
(
expr
)
=
>
SourceLocation
:
:
from_parts
(
name_loc
expr
.
get_loc
(
)
)
}
;
self
.
alloc
(
ClassElement
:
:
FieldDefinition
{
name
:
name
.
unbox
(
)
init
loc
}
)
}
pub
fn
property_name_to_class_element_name
(
&
self
name
:
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
ClassElementName
<
'
alloc
>
>
{
self
.
alloc
(
match
name
.
unbox
(
)
{
PropertyName
:
:
ComputedPropertyName
(
cpn
)
=
>
ClassElementName
:
:
ComputedPropertyName
(
cpn
)
PropertyName
:
:
StaticPropertyName
(
spn
)
=
>
ClassElementName
:
:
StaticPropertyName
(
spn
)
PropertyName
:
:
StaticNumericPropertyName
(
snpn
)
=
>
{
ClassElementName
:
:
StaticNumericPropertyName
(
snpn
)
}
}
)
}
pub
fn
class_element_name_private
(
&
self
private_identifier
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
arena
:
:
Box
<
'
alloc
ClassElementName
<
'
alloc
>
>
{
self
.
alloc
(
ClassElementName
:
:
PrivateFieldName
(
self
.
private_identifier
(
private_identifier
)
)
)
}
pub
fn
class_element
(
&
self
method
:
arena
:
:
Box
<
'
alloc
MethodDefinition
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
arena
:
:
Box
<
'
alloc
ClassElement
<
'
alloc
>
>
>
>
{
let
loc
=
method
.
get_loc
(
)
;
self
.
class_element_to_vec
(
self
.
alloc
(
ClassElement
:
:
MethodDefinition
{
is_static
:
false
method
:
method
.
unbox
(
)
loc
}
)
)
}
pub
fn
class_element_to_vec
(
&
self
element
:
arena
:
:
Box
<
'
alloc
ClassElement
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
arena
:
:
Box
<
'
alloc
ClassElement
<
'
alloc
>
>
>
>
{
self
.
alloc
(
self
.
new_vec_single
(
element
)
)
}
pub
fn
class_element_static
(
&
self
static_token
:
arena
:
:
Box
<
'
alloc
Token
>
method
:
arena
:
:
Box
<
'
alloc
MethodDefinition
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
arena
:
:
Box
<
'
alloc
ClassElement
<
'
alloc
>
>
>
>
{
let
method_loc
=
method
.
get_loc
(
)
;
self
.
alloc
(
self
.
new_vec_single
(
self
.
alloc
(
ClassElement
:
:
MethodDefinition
{
is_static
:
true
method
:
method
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
static_token
.
loc
method_loc
)
}
)
)
)
}
pub
fn
class_element_static_field
(
&
self
_static_token
:
arena
:
:
Box
<
'
alloc
Token
>
_field
:
arena
:
:
Box
<
'
alloc
ClassElement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
class
static
field
"
)
)
}
pub
fn
class_element_empty
(
&
self
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
arena
:
:
Box
<
'
alloc
ClassElement
<
'
alloc
>
>
>
>
{
self
.
alloc
(
self
.
new_vec
(
)
)
}
pub
fn
async_method
(
&
mut
self
async_token
:
arena
:
:
Box
<
'
alloc
Token
>
name
:
arena
:
:
Box
<
'
alloc
PropertyName
<
'
alloc
>
>
param_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
params
:
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
param_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
body_open_token
:
arena
:
:
Box
<
'
alloc
Token
>
mut
body
:
arena
:
:
Box
<
'
alloc
FunctionBody
<
'
alloc
>
>
body_close_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
MethodDefinition
<
'
alloc
>
>
>
{
let
param_open_loc
=
param_open_token
.
loc
;
let
param_close_loc
=
param_close_token
.
loc
;
let
body_close_loc
=
body_close_token
.
loc
;
self
.
check_unique_function_bindings
(
param_open_loc
.
start
param_close_loc
.
end
)
?
;
params
.
loc
.
set_range
(
param_open_loc
param_close_loc
)
;
body
.
loc
.
set_range
(
body_open_token
.
loc
body_close_loc
)
;
Ok
(
self
.
alloc
(
MethodDefinition
:
:
Method
(
Method
{
name
:
name
.
unbox
(
)
is_async
:
true
is_generator
:
false
params
:
params
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
async_token
.
loc
body_close_loc
)
}
)
)
)
}
pub
fn
await_expr
(
&
self
await_token
:
arena
:
:
Box
<
'
alloc
Token
>
operand
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
{
let
operand_loc
=
operand
.
get_loc
(
)
;
self
.
alloc
(
Expression
:
:
AwaitExpression
{
expression
:
operand
loc
:
SourceLocation
:
:
from_parts
(
await_token
.
loc
operand_loc
)
}
)
}
pub
fn
async_arrow_function_bare
(
&
mut
self
async_token
:
arena
:
:
Box
<
'
alloc
Token
>
identifier
:
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
body
:
arena
:
:
Box
<
'
alloc
ArrowExpressionBody
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
let
params
=
self
.
arrow_parameters_bare
(
identifier
)
;
self
.
check_unique_function_bindings
(
params
.
loc
.
start
params
.
loc
.
end
)
?
;
let
body_loc
=
body
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Expression
:
:
ArrowExpression
{
is_async
:
true
params
:
params
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
async_token
.
loc
body_loc
)
}
)
)
}
pub
fn
async_arrow_function
(
&
mut
self
params
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
body
:
arena
:
:
Box
<
'
alloc
ArrowExpressionBody
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
>
{
let
(
params
call_loc
)
=
self
.
async_arrow_parameters
(
params
)
?
;
self
.
check_unique_function_bindings
(
params
.
loc
.
start
params
.
loc
.
end
)
?
;
let
body_loc
=
body
.
get_loc
(
)
;
Ok
(
self
.
alloc
(
Expression
:
:
ArrowExpression
{
is_async
:
true
params
:
params
.
unbox
(
)
body
:
body
.
unbox
(
)
loc
:
SourceLocation
:
:
from_parts
(
call_loc
body_loc
)
}
)
)
}
fn
async_arrow_parameters
(
&
self
call_expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
(
arena
:
:
Box
<
'
alloc
FormalParameters
<
'
alloc
>
>
SourceLocation
)
>
{
match
call_expression
.
unbox
(
)
{
Expression
:
:
CallExpression
(
CallExpression
{
callee
:
ce
arguments
loc
}
)
=
>
{
match
ce
{
ExpressionOrSuper
:
:
Expression
(
callee
)
=
>
match
callee
.
unbox
(
)
{
Expression
:
:
IdentifierExpression
(
IdentifierExpression
{
name
.
.
}
)
=
>
{
if
name
.
value
!
=
CommonSourceAtomSetIndices
:
:
async_
(
)
{
return
Err
(
ParseError
:
:
ArrowHeadInvalid
)
;
}
}
_
=
>
{
return
Err
(
ParseError
:
:
ArrowHeadInvalid
)
;
}
}
ExpressionOrSuper
:
:
Super
{
.
.
}
=
>
{
return
Err
(
ParseError
:
:
ArrowHeadInvalid
)
;
}
}
Ok
(
(
self
.
arguments_to_parameter_list
(
arguments
)
?
loc
)
)
}
_
=
>
{
panic
!
(
"
invalid
argument
"
)
;
}
}
}
pub
fn
script
(
&
mut
self
script
:
Option
<
arena
:
:
Box
<
'
alloc
Script
<
'
alloc
>
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Script
<
'
alloc
>
>
>
{
self
.
check_script_bindings
(
)
?
;
Ok
(
match
script
{
Some
(
script
)
=
>
script
None
=
>
self
.
alloc
(
Script
{
directives
:
self
.
new_vec
(
)
statements
:
self
.
new_vec
(
)
loc
:
SourceLocation
:
:
default
(
)
}
)
}
)
}
pub
fn
script_body
(
&
self
statements
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
)
-
>
arena
:
:
Box
<
'
alloc
Script
<
'
alloc
>
>
{
let
loc
=
if
statements
.
is_empty
(
)
{
SourceLocation
:
:
default
(
)
}
else
{
SourceLocation
:
:
from_parts
(
statements
.
first
(
)
.
unwrap
(
)
.
get_loc
(
)
statements
.
last
(
)
.
unwrap
(
)
.
get_loc
(
)
)
}
;
self
.
alloc
(
Script
{
directives
:
self
.
new_vec
(
)
statements
:
statements
.
unbox
(
)
loc
}
)
}
pub
fn
module
(
&
mut
self
body
:
Option
<
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
>
{
self
.
check_module_bindings
(
)
?
;
Ok
(
body
.
unwrap_or_else
(
|
|
self
.
alloc
(
self
.
new_vec
(
)
)
)
)
}
pub
fn
module_item_list_single
(
&
self
item
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
alloc
(
self
.
new_vec_single
(
item
.
unbox
(
)
)
)
}
pub
fn
module_item_list_append
(
&
self
mut
list
:
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
item
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
arena
:
:
Box
<
'
alloc
arena
:
:
Vec
<
'
alloc
Statement
<
'
alloc
>
>
>
{
self
.
push
(
&
mut
list
item
.
unbox
(
)
)
;
list
}
pub
fn
import_declaration
(
&
self
_import_clause
:
Option
<
arena
:
:
Box
<
'
alloc
Void
>
>
_module_specifier
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
import
"
)
)
}
pub
fn
import_clause
(
&
self
_default_binding
:
Option
<
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
>
_name_space_import
:
Option
<
arena
:
:
Box
<
'
alloc
Void
>
>
_named_imports
:
Option
<
arena
:
:
Box
<
'
alloc
Void
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
import
"
)
)
}
pub
fn
name_space_import
(
&
self
_name
:
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
import
"
)
)
}
pub
fn
imports_list_empty
(
&
self
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
import
"
)
)
}
pub
fn
imports_list_append
(
&
self
_list
:
arena
:
:
Box
<
'
alloc
Void
>
_item
:
arena
:
:
Box
<
'
alloc
Void
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
import
"
)
)
}
pub
fn
import_specifier
(
&
self
_name
:
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
import
"
)
)
}
pub
fn
import_specifier_renaming
(
&
self
_original_name
:
arena
:
:
Box
<
'
alloc
Token
>
_local_name
:
arena
:
:
Box
<
'
alloc
BindingIdentifier
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
import
"
)
)
}
pub
fn
module_specifier
(
&
self
_token
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Token
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
import
"
)
)
}
pub
fn
export_all_from
(
&
self
_module_specifier
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
pub
fn
export_set_from
(
&
self
_export_clause
:
arena
:
:
Box
<
'
alloc
Void
>
_module_specifier
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
pub
fn
export_set
(
&
self
_export_clause
:
arena
:
:
Box
<
'
alloc
Void
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
pub
fn
export_vars
(
&
self
_statement
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
pub
fn
export_declaration
(
&
self
_declaration
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
pub
fn
export_default_hoistable
(
&
self
_declaration
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
pub
fn
export_default_class
(
&
self
_class_declaration
:
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
pub
fn
export_default_value
(
&
self
_expression
:
arena
:
:
Box
<
'
alloc
Expression
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
pub
fn
exports_list_empty
(
&
self
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
pub
fn
exports_list_append
(
&
self
_list
:
arena
:
:
Box
<
'
alloc
Void
>
_export_specifier
:
arena
:
:
Box
<
'
alloc
Void
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
pub
fn
export_specifier
(
&
self
_identifier
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
pub
fn
export_specifier_renaming
(
&
self
_local_name
:
arena
:
:
Box
<
'
alloc
Token
>
_exported_name
:
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
arena
:
:
Box
<
'
alloc
Void
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
export
"
)
)
}
fn
on_binding_identifier
(
&
mut
self
token
:
&
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
(
)
>
{
let
context
=
IdentifierEarlyErrorsContext
:
:
new
(
)
;
context
.
check_binding_identifier
(
token
&
self
.
atoms
.
borrow
(
)
)
?
;
let
name
=
token
.
value
.
as_atom
(
)
;
let
offset
=
token
.
loc
.
start
;
if
let
Some
(
info
)
=
self
.
bindings
.
last
(
)
{
debug_assert
!
(
info
.
offset
<
offset
)
;
}
self
.
bindings
.
push
(
BindingInfo
{
name
offset
kind
:
BindingKind
:
:
Unknown
}
)
;
Ok
(
(
)
)
}
fn
on_identifier_reference
(
&
self
token
:
&
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
(
)
>
{
let
context
=
IdentifierEarlyErrorsContext
:
:
new
(
)
;
context
.
check_identifier_reference
(
token
&
self
.
atoms
.
borrow
(
)
)
}
fn
on_label_identifier
(
&
self
token
:
&
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
Result
<
'
alloc
(
)
>
{
let
context
=
IdentifierEarlyErrorsContext
:
:
new
(
)
;
context
.
check_label_identifier
(
token
&
self
.
atoms
.
borrow
(
)
)
}
fn
mark_binding_kind
(
&
mut
self
from
:
usize
to
:
Option
<
usize
>
kind
:
BindingKind
)
{
for
info
in
self
.
bindings
.
iter_mut
(
)
.
rev
(
)
{
if
info
.
offset
<
from
{
break
;
}
if
to
.
is_none
(
)
|
|
info
.
offset
<
to
.
unwrap
(
)
{
info
.
kind
=
kind
;
}
}
}
fn
find_first_binding
(
&
mut
self
offset
:
usize
)
-
>
usize
{
let
mut
i
=
self
.
bindings
.
len
(
)
;
for
info
in
self
.
bindings
.
iter_mut
(
)
.
rev
(
)
{
if
info
.
offset
<
offset
{
break
;
}
i
-
=
1
;
}
i
}
fn
pop_bindings_from
(
&
mut
self
index
:
usize
)
{
self
.
bindings
.
truncate
(
index
)
}
fn
pop_lexical_bindings_from
(
&
mut
self
index
:
usize
)
{
let
len
=
self
.
bindings
.
len
(
)
;
let
mut
i
=
index
;
while
i
<
len
&
&
self
.
bindings
[
i
]
.
kind
=
=
BindingKind
:
:
Var
{
i
+
=
1
;
}
let
mut
j
=
i
;
while
j
<
len
{
if
self
.
bindings
[
j
]
.
kind
=
=
BindingKind
:
:
Var
{
self
.
bindings
[
i
]
=
self
.
bindings
[
j
]
;
i
+
=
1
;
}
j
+
=
1
;
}
self
.
bindings
.
truncate
(
i
)
}
fn
declare_block
<
T
>
(
&
self
context
:
&
mut
T
index
:
usize
)
-
>
Result
<
'
alloc
(
)
>
where
T
:
LexicalEarlyErrorsContext
+
VarEarlyErrorsContext
{
for
info
in
self
.
bindings
.
iter
(
)
.
skip
(
index
)
{
match
info
.
kind
{
BindingKind
:
:
Var
=
>
{
context
.
declare_var
(
info
.
name
DeclarationKind
:
:
Var
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
BindingKind
:
:
Function
=
>
{
context
.
declare_lex
(
info
.
name
DeclarationKind
:
:
LexicalFunction
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
BindingKind
:
:
AsyncOrGenerator
=
>
{
context
.
declare_lex
(
info
.
name
DeclarationKind
:
:
LexicalAsyncOrGenerator
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
BindingKind
:
:
Let
=
>
{
context
.
declare_lex
(
info
.
name
DeclarationKind
:
:
Let
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
BindingKind
:
:
Const
=
>
{
context
.
declare_lex
(
info
.
name
DeclarationKind
:
:
Const
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
BindingKind
:
:
Class
=
>
{
context
.
declare_lex
(
info
.
name
DeclarationKind
:
:
Class
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
_
=
>
{
panic
!
(
"
Unexpected
binding
found
{
:
?
}
"
info
)
;
}
}
}
Ok
(
(
)
)
}
fn
check_block_bindings
(
&
mut
self
start_of_block_offset
:
usize
)
-
>
Result
<
'
alloc
(
)
>
{
let
mut
context
=
BlockEarlyErrorsContext
:
:
new
(
)
;
let
index
=
self
.
find_first_binding
(
start_of_block_offset
)
;
self
.
declare_block
(
&
mut
context
index
)
?
;
self
.
pop_lexical_bindings_from
(
index
)
;
Ok
(
(
)
)
}
fn
declare_lexical_for_head
(
&
self
context
:
&
mut
LexicalForHeadEarlyErrorsContext
from
:
usize
to
:
usize
)
-
>
Result
<
'
alloc
(
)
>
{
for
info
in
self
.
bindings
.
iter
(
)
.
skip
(
from
)
.
take
(
to
-
from
)
{
match
info
.
kind
{
BindingKind
:
:
Let
=
>
{
context
.
declare_lex
(
info
.
name
DeclarationKind
:
:
Let
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
BindingKind
:
:
Const
=
>
{
context
.
declare_lex
(
info
.
name
DeclarationKind
:
:
Const
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
_
=
>
{
panic
!
(
"
Unexpected
binding
found
{
:
?
}
"
info
)
;
}
}
}
Ok
(
(
)
)
}
fn
declare_lexical_for_body
(
&
self
context
:
&
mut
LexicalForBodyEarlyErrorsContext
index
:
usize
)
-
>
Result
<
'
alloc
(
)
>
{
for
info
in
self
.
bindings
.
iter
(
)
.
skip
(
index
)
{
match
info
.
kind
{
BindingKind
:
:
Var
=
>
{
context
.
declare_var
(
info
.
name
DeclarationKind
:
:
Var
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
_
=
>
{
panic
!
(
"
Unexpected
binding
found
{
:
?
}
"
info
)
;
}
}
}
Ok
(
(
)
)
}
fn
check_lexical_for_bindings
(
&
mut
self
bindings_loc
:
&
SourceLocation
)
-
>
Result
<
'
alloc
(
)
>
{
let
mut
head_context
=
LexicalForHeadEarlyErrorsContext
:
:
new
(
)
;
let
head_index
=
self
.
find_first_binding
(
bindings_loc
.
start
)
;
let
body_index
=
self
.
find_first_binding
(
bindings_loc
.
end
)
;
self
.
declare_lexical_for_head
(
&
mut
head_context
head_index
body_index
)
?
;
let
mut
body_context
=
LexicalForBodyEarlyErrorsContext
:
:
new
(
head_context
)
;
self
.
declare_lexical_for_body
(
&
mut
body_context
body_index
)
?
;
self
.
pop_lexical_bindings_from
(
head_index
)
;
Ok
(
(
)
)
}
fn
check_case_block_binding
(
&
mut
self
start_of_block_offset
:
usize
)
-
>
Result
<
'
alloc
(
)
>
{
let
mut
context
=
CaseBlockEarlyErrorsContext
:
:
new
(
)
;
let
index
=
self
.
find_first_binding
(
start_of_block_offset
)
;
self
.
declare_block
(
&
mut
context
index
)
?
;
self
.
pop_lexical_bindings_from
(
index
)
;
Ok
(
(
)
)
}
fn
declare_param
<
T
>
(
&
self
context
:
&
mut
T
from
:
usize
to
:
usize
)
-
>
Result
<
'
alloc
(
)
>
where
T
:
ParameterEarlyErrorsContext
{
for
info
in
self
.
bindings
.
iter
(
)
.
skip
(
from
)
.
take
(
to
-
from
)
{
context
.
declare
(
info
.
name
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
Ok
(
(
)
)
}
fn
check_catch_bindings
(
&
mut
self
is_simple
:
bool
bindings_loc
:
&
SourceLocation
)
-
>
Result
<
'
alloc
(
)
>
{
let
mut
param_context
=
if
is_simple
{
CatchParameterEarlyErrorsContext
:
:
new_with_binding_identifier
(
)
}
else
{
CatchParameterEarlyErrorsContext
:
:
new_with_binding_pattern
(
)
}
;
let
param_index
=
self
.
find_first_binding
(
bindings_loc
.
start
)
;
let
body_index
=
self
.
find_first_binding
(
bindings_loc
.
end
)
;
self
.
declare_param
(
&
mut
param_context
param_index
body_index
)
?
;
let
mut
block_context
=
CatchBlockEarlyErrorsContext
:
:
new
(
param_context
)
;
self
.
declare_block
(
&
mut
block_context
body_index
)
?
;
self
.
pop_lexical_bindings_from
(
param_index
)
;
Ok
(
(
)
)
}
fn
check_catch_no_param_bindings
(
&
mut
self
catch_offset
:
usize
)
-
>
Result
<
'
alloc
(
)
>
{
let
body_index
=
self
.
find_first_binding
(
catch_offset
)
;
let
param_context
=
CatchParameterEarlyErrorsContext
:
:
new_with_binding_identifier
(
)
;
let
mut
block_context
=
CatchBlockEarlyErrorsContext
:
:
new
(
param_context
)
;
self
.
declare_block
(
&
mut
block_context
body_index
)
?
;
self
.
pop_lexical_bindings_from
(
body_index
)
;
Ok
(
(
)
)
}
fn
declare_script_or_function
<
T
>
(
&
self
context
:
&
mut
T
index
:
usize
)
-
>
Result
<
'
alloc
(
)
>
where
T
:
LexicalEarlyErrorsContext
+
VarEarlyErrorsContext
{
for
info
in
self
.
bindings
.
iter
(
)
.
skip
(
index
)
{
match
info
.
kind
{
BindingKind
:
:
Var
=
>
{
context
.
declare_var
(
info
.
name
DeclarationKind
:
:
Var
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
BindingKind
:
:
Function
|
BindingKind
:
:
AsyncOrGenerator
=
>
{
context
.
declare_var
(
info
.
name
DeclarationKind
:
:
BodyLevelFunction
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
BindingKind
:
:
Let
=
>
{
context
.
declare_lex
(
info
.
name
DeclarationKind
:
:
Let
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
BindingKind
:
:
Const
=
>
{
context
.
declare_lex
(
info
.
name
DeclarationKind
:
:
Const
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
BindingKind
:
:
Class
=
>
{
context
.
declare_lex
(
info
.
name
DeclarationKind
:
:
Class
info
.
offset
&
self
.
atoms
.
borrow
(
)
)
?
;
}
_
=
>
{
panic
!
(
"
Unexpected
binding
found
{
:
?
}
"
info
)
;
}
}
}
Ok
(
(
)
)
}
fn
check_function_bindings
(
&
mut
self
is_simple
:
bool
start_of_param_offset
:
usize
end_of_param_offset
:
usize
)
-
>
Result
<
'
alloc
(
)
>
{
let
mut
param_context
=
if
is_simple
{
FormalParametersEarlyErrorsContext
:
:
new_simple
(
)
}
else
{
FormalParametersEarlyErrorsContext
:
:
new_non_simple
(
)
}
;
let
param_index
=
self
.
find_first_binding
(
start_of_param_offset
)
;
let
body_index
=
self
.
find_first_binding
(
end_of_param_offset
)
;
self
.
declare_param
(
&
mut
param_context
param_index
body_index
)
?
;
let
mut
body_context
=
FunctionBodyEarlyErrorsContext
:
:
new
(
param_context
)
;
self
.
declare_script_or_function
(
&
mut
body_context
body_index
)
?
;
self
.
pop_bindings_from
(
param_index
)
;
Ok
(
(
)
)
}
fn
check_unique_function_bindings
(
&
mut
self
start_of_param_offset
:
usize
end_of_param_offset
:
usize
)
-
>
Result
<
'
alloc
(
)
>
{
let
mut
param_context
=
UniqueFormalParametersEarlyErrorsContext
:
:
new
(
)
;
let
param_index
=
self
.
find_first_binding
(
start_of_param_offset
)
;
let
body_index
=
self
.
find_first_binding
(
end_of_param_offset
)
;
self
.
declare_param
(
&
mut
param_context
param_index
body_index
)
?
;
let
mut
body_context
=
UniqueFunctionBodyEarlyErrorsContext
:
:
new
(
param_context
)
;
self
.
declare_script_or_function
(
&
mut
body_context
body_index
)
?
;
self
.
pop_bindings_from
(
param_index
)
;
Ok
(
(
)
)
}
fn
check_script_bindings
(
&
mut
self
)
-
>
Result
<
'
alloc
(
)
>
{
let
mut
context
=
ScriptEarlyErrorsContext
:
:
new
(
)
;
self
.
declare_script_or_function
(
&
mut
context
0
)
?
;
self
.
pop_bindings_from
(
0
)
;
Ok
(
(
)
)
}
fn
check_module_bindings
(
&
mut
self
)
-
>
Result
<
'
alloc
(
)
>
{
let
mut
context
=
ModuleEarlyErrorsContext
:
:
new
(
)
;
self
.
declare_script_or_function
(
&
mut
context
0
)
?
;
self
.
pop_bindings_from
(
0
)
;
Ok
(
(
)
)
}
fn
is_params_simple
(
params
:
&
FormalParameters
<
'
alloc
>
)
-
>
bool
{
for
param
in
params
.
items
.
iter
(
)
{
match
param
{
Parameter
:
:
Binding
(
Binding
:
:
BindingIdentifier
(
_
)
)
=
>
{
}
_
=
>
{
return
false
;
}
}
}
if
params
.
rest
.
is_some
(
)
{
return
false
;
}
true
}
fn
check_single_statement
(
&
self
stmt
:
&
arena
:
:
Box
<
'
alloc
Statement
<
'
alloc
>
>
)
-
>
Result
<
'
alloc
(
)
>
{
if
self
.
is_labelled_function
(
stmt
)
{
return
Err
(
ParseError
:
:
LabelledFunctionDeclInSingleStatement
)
;
}
Ok
(
(
)
)
}
fn
is_labelled_function
(
&
self
mut
stmt
:
&
Statement
<
'
alloc
>
)
-
>
bool
{
while
let
Statement
:
:
LabeledStatement
{
ref
body
.
.
}
=
stmt
{
let
item
:
&
Statement
<
'
alloc
>
=
body
;
if
let
Statement
:
:
FunctionDeclaration
(
_
)
=
item
{
return
true
;
}
stmt
=
item
;
}
false
}
}
