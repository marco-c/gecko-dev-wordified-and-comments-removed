use
crate
:
:
parser_tables_generated
:
:
TerminalId
;
use
crate
:
:
DeclarationKind
;
use
crate
:
:
ParseError
;
use
crate
:
:
Token
;
use
ast
:
:
arena
;
use
ast
:
:
source_atom_set
:
:
{
CommonSourceAtomSetIndices
SourceAtomSet
SourceAtomSetIndex
}
;
use
std
:
:
collections
:
:
HashMap
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
struct
DeclarationInfo
{
kind
:
DeclarationKind
offset
:
usize
}
impl
DeclarationInfo
{
fn
new
(
kind
:
DeclarationKind
offset
:
usize
)
-
>
Self
{
Self
{
kind
offset
}
}
}
pub
type
EarlyErrorsResult
<
'
alloc
>
=
Result
<
(
)
ParseError
<
'
alloc
>
>
;
pub
trait
LexicalEarlyErrorsContext
{
fn
declare_lex
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
;
}
pub
trait
VarEarlyErrorsContext
{
fn
declare_var
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
;
}
pub
trait
ParameterEarlyErrorsContext
{
fn
declare
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
;
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
IdentifierEarlyErrorsContext
{
}
impl
IdentifierEarlyErrorsContext
{
pub
fn
new
(
)
-
>
Self
{
Self
{
}
}
fn
is_strict
<
'
alloc
>
(
&
self
)
-
>
Result
<
bool
ParseError
<
'
alloc
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
strict
-
mode
-
only
early
error
is
not
yet
supported
"
)
)
}
fn
is_arguments_identifier
<
'
alloc
>
(
token
:
&
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
bool
{
return
(
token
.
terminal_id
=
=
TerminalId
:
:
Name
|
|
token
.
terminal_id
=
=
TerminalId
:
:
NameWithEscape
)
&
&
token
.
value
.
as_atom
(
)
=
=
CommonSourceAtomSetIndices
:
:
arguments
(
)
;
}
fn
is_eval_identifier
<
'
alloc
>
(
token
:
&
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
bool
{
return
(
token
.
terminal_id
=
=
TerminalId
:
:
Name
|
|
token
.
terminal_id
=
=
TerminalId
:
:
NameWithEscape
)
&
&
token
.
value
.
as_atom
(
)
=
=
CommonSourceAtomSetIndices
:
:
eval
(
)
;
}
fn
is_yield_identifier
<
'
alloc
>
(
token
:
&
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
bool
{
return
token
.
terminal_id
=
=
TerminalId
:
:
Yield
|
|
(
token
.
terminal_id
=
=
TerminalId
:
:
NameWithEscape
&
&
token
.
value
.
as_atom
(
)
=
=
CommonSourceAtomSetIndices
:
:
yield_
(
)
)
;
}
fn
is_await_identifier
<
'
alloc
>
(
token
:
&
arena
:
:
Box
<
'
alloc
Token
>
)
-
>
bool
{
return
token
.
terminal_id
=
=
TerminalId
:
:
Await
|
|
(
token
.
terminal_id
=
=
TerminalId
:
:
NameWithEscape
&
&
token
.
value
.
as_atom
(
)
=
=
CommonSourceAtomSetIndices
:
:
await_
(
)
)
;
}
pub
fn
check_binding_identifier
<
'
alloc
>
(
&
self
token
:
&
arena
:
:
Box
<
'
alloc
Token
>
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
Self
:
:
is_arguments_identifier
(
token
)
|
|
Self
:
:
is_eval_identifier
(
token
)
{
if
self
.
is_strict
(
)
?
{
let
name
=
atoms
.
get
(
token
.
value
.
as_atom
(
)
)
;
let
offset
=
token
.
loc
.
start
;
return
Err
(
ParseError
:
:
InvalidIdentifier
(
name
.
clone
(
)
offset
)
)
;
}
return
Ok
(
(
)
)
;
}
if
Self
:
:
is_yield_identifier
(
token
)
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
[
Yield
]
parameter
"
)
)
;
}
if
Self
:
:
is_await_identifier
(
token
)
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
[
Await
]
parameter
"
)
)
;
}
self
.
check_identifier
(
token
atoms
)
}
pub
fn
check_label_identifier
<
'
alloc
>
(
&
self
token
:
&
arena
:
:
Box
<
'
alloc
Token
>
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
Self
:
:
is_yield_identifier
(
token
)
{
return
self
.
check_yield_common
(
token
atoms
)
;
}
if
Self
:
:
is_await_identifier
(
token
)
{
return
self
.
check_await_common
(
token
atoms
)
;
}
self
.
check_identifier
(
token
atoms
)
}
pub
fn
check_identifier_reference
<
'
alloc
>
(
&
self
token
:
&
arena
:
:
Box
<
'
alloc
Token
>
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
Self
:
:
is_yield_identifier
(
token
)
{
return
self
.
check_yield_common
(
token
atoms
)
;
}
if
Self
:
:
is_await_identifier
(
token
)
{
return
self
.
check_await_common
(
token
atoms
)
;
}
self
.
check_identifier
(
token
atoms
)
}
fn
check_yield_common
<
'
alloc
>
(
&
self
_token
:
&
arena
:
:
Box
<
'
alloc
Token
>
_atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
[
Yield
]
parameter
"
)
)
;
}
fn
check_await_common
<
'
alloc
>
(
&
self
_token
:
&
arena
:
:
Box
<
'
alloc
Token
>
_atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
[
Await
]
parameter
"
)
)
;
}
fn
is_contextual_keyword_excluding_yield
(
name
:
SourceAtomSetIndex
)
-
>
bool
{
name
=
=
CommonSourceAtomSetIndices
:
:
implements
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
interface
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
let_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
package
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
private
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
protected
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
public
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
static_
(
)
}
fn
is_keyword
(
name
:
SourceAtomSetIndex
)
-
>
bool
{
name
=
=
CommonSourceAtomSetIndices
:
:
break_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
case
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
catch
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
class
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
const_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
continue_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
debugger
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
default
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
delete
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
do_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
else_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
enum_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
export
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
extends
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
false_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
finally
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
for_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
function
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
if_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
import
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
in_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
instanceof
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
new_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
null
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
return_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
super_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
switch
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
this
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
throw
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
true_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
try_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
typeof_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
var
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
void
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
while_
(
)
|
|
name
=
=
CommonSourceAtomSetIndices
:
:
with
(
)
}
fn
check_identifier
<
'
alloc
>
(
&
self
token
:
&
arena
:
:
Box
<
'
alloc
Token
>
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
match
token
.
terminal_id
{
TerminalId
:
:
NameWithEscape
=
>
{
let
name
=
token
.
value
.
as_atom
(
)
;
if
Self
:
:
is_contextual_keyword_excluding_yield
(
name
)
{
if
self
.
is_strict
(
)
?
{
let
name
=
atoms
.
get
(
token
.
value
.
as_atom
(
)
)
;
let
offset
=
token
.
loc
.
start
;
return
Err
(
ParseError
:
:
InvalidIdentifier
(
name
offset
)
)
;
}
}
else
if
Self
:
:
is_keyword
(
name
)
{
let
name
=
atoms
.
get
(
token
.
value
.
as_atom
(
)
)
;
let
offset
=
token
.
loc
.
start
;
return
Err
(
ParseError
:
:
InvalidIdentifier
(
name
offset
)
)
;
}
}
TerminalId
:
:
Implements
|
TerminalId
:
:
Interface
|
TerminalId
:
:
Let
|
TerminalId
:
:
Package
|
TerminalId
:
:
Private
|
TerminalId
:
:
Protected
|
TerminalId
:
:
Public
|
TerminalId
:
:
Static
=
>
{
if
self
.
is_strict
(
)
?
{
let
name
=
atoms
.
get
(
token
.
value
.
as_atom
(
)
)
;
let
offset
=
token
.
loc
.
start
;
return
Err
(
ParseError
:
:
InvalidIdentifier
(
name
offset
)
)
;
}
}
_
=
>
{
}
}
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
BlockEarlyErrorsContext
{
lex_names_of_stmt_list
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
var_names_of_stmt_list
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
}
impl
BlockEarlyErrorsContext
{
pub
fn
new
(
)
-
>
Self
{
Self
{
lex_names_of_stmt_list
:
HashMap
:
:
new
(
)
var_names_of_stmt_list
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
LexicalFunction
|
DeclarationKind
:
:
LexicalAsyncOrGenerator
|
DeclarationKind
:
:
Class
|
DeclarationKind
:
:
Let
|
DeclarationKind
:
:
Const
=
>
true
_
=
>
false
}
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Var
|
DeclarationKind
:
:
VarForAnnexBLexicalFunction
=
>
true
_
=
>
false
}
}
fn
is_strict
<
'
alloc
>
(
&
self
)
-
>
Result
<
bool
ParseError
<
'
alloc
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
strict
-
mode
-
only
early
error
is
not
yet
supported
"
)
)
}
}
impl
LexicalEarlyErrorsContext
for
BlockEarlyErrorsContext
{
fn
declare_lex
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_stmt_list
.
get
(
&
name
)
{
if
!
(
!
self
.
is_strict
(
)
?
&
&
info
.
kind
=
=
DeclarationKind
:
:
LexicalFunction
&
&
kind
=
=
DeclarationKind
:
:
LexicalFunction
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
}
if
let
Some
(
info
)
=
self
.
var_names_of_stmt_list
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
lex_names_of_stmt_list
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
impl
VarEarlyErrorsContext
for
BlockEarlyErrorsContext
{
fn
declare_var
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_stmt_list
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
var_names_of_stmt_list
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
LexicalForHeadEarlyErrorsContext
{
bound_names_of_decl
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
}
impl
LexicalForHeadEarlyErrorsContext
{
pub
fn
new
(
)
-
>
Self
{
Self
{
bound_names_of_decl
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Let
|
DeclarationKind
:
:
Const
=
>
true
_
=
>
false
}
}
}
impl
LexicalEarlyErrorsContext
for
LexicalForHeadEarlyErrorsContext
{
fn
declare_lex
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
bound_names_of_decl
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
bound_names_of_decl
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
struct
InternalForBodyEarlyErrorsContext
{
var_names_of_stmt
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
}
impl
InternalForBodyEarlyErrorsContext
{
fn
new
(
)
-
>
Self
{
Self
{
var_names_of_stmt
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Var
=
>
true
_
=
>
false
}
}
}
impl
VarEarlyErrorsContext
for
InternalForBodyEarlyErrorsContext
{
fn
declare_var
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
_atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
self
.
var_names_of_stmt
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
LexicalForBodyEarlyErrorsContext
{
head
:
LexicalForHeadEarlyErrorsContext
body
:
InternalForBodyEarlyErrorsContext
}
impl
LexicalForBodyEarlyErrorsContext
{
pub
fn
new
(
head
:
LexicalForHeadEarlyErrorsContext
)
-
>
Self
{
Self
{
head
body
:
InternalForBodyEarlyErrorsContext
:
:
new
(
)
}
}
}
impl
VarEarlyErrorsContext
for
LexicalForBodyEarlyErrorsContext
{
fn
declare_var
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
info
)
=
self
.
head
.
bound_names_of_decl
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
body
.
declare_var
(
name
kind
offset
atoms
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
CaseBlockEarlyErrorsContext
{
lex_names_of_case_block
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
var_names_of_case_block
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
}
impl
CaseBlockEarlyErrorsContext
{
pub
fn
new
(
)
-
>
Self
{
Self
{
lex_names_of_case_block
:
HashMap
:
:
new
(
)
var_names_of_case_block
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
BlockEarlyErrorsContext
:
:
is_supported_lexical
(
kind
)
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
BlockEarlyErrorsContext
:
:
is_supported_var
(
kind
)
}
fn
is_strict
<
'
alloc
>
(
&
self
)
-
>
Result
<
bool
ParseError
<
'
alloc
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
strict
-
mode
-
only
early
error
is
not
yet
supported
"
)
)
}
}
impl
LexicalEarlyErrorsContext
for
CaseBlockEarlyErrorsContext
{
fn
declare_lex
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_case_block
.
get
(
&
name
)
{
if
!
(
!
self
.
is_strict
(
)
?
&
&
info
.
kind
=
=
DeclarationKind
:
:
LexicalFunction
&
&
kind
=
=
DeclarationKind
:
:
LexicalFunction
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
}
if
let
Some
(
info
)
=
self
.
var_names_of_case_block
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
lex_names_of_case_block
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
impl
VarEarlyErrorsContext
for
CaseBlockEarlyErrorsContext
{
fn
declare_var
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_case_block
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
var_names_of_case_block
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
CatchParameterEarlyErrorsContext
{
bound_names_of_catch_param
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
is_simple
:
bool
}
impl
CatchParameterEarlyErrorsContext
{
pub
fn
new_with_binding_identifier
(
)
-
>
Self
{
Self
{
bound_names_of_catch_param
:
HashMap
:
:
new
(
)
is_simple
:
true
}
}
pub
fn
new_with_binding_pattern
(
)
-
>
Self
{
Self
{
bound_names_of_catch_param
:
HashMap
:
:
new
(
)
is_simple
:
false
}
}
}
impl
ParameterEarlyErrorsContext
for
CatchParameterEarlyErrorsContext
{
fn
declare
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
let
kind
=
DeclarationKind
:
:
CatchParameter
;
if
let
Some
(
info
)
=
self
.
bound_names_of_catch_param
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
offset
kind
offset
)
)
;
}
self
.
bound_names_of_catch_param
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
CatchBlockEarlyErrorsContext
{
param
:
CatchParameterEarlyErrorsContext
block
:
BlockEarlyErrorsContext
}
impl
CatchBlockEarlyErrorsContext
{
pub
fn
new
(
param
:
CatchParameterEarlyErrorsContext
)
-
>
Self
{
Self
{
param
block
:
BlockEarlyErrorsContext
:
:
new
(
)
}
}
}
impl
LexicalEarlyErrorsContext
for
CatchBlockEarlyErrorsContext
{
fn
declare_lex
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
info
)
=
self
.
param
.
bound_names_of_catch_param
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
offset
kind
offset
)
)
;
}
self
.
block
.
declare_lex
(
name
kind
offset
atoms
)
}
}
impl
VarEarlyErrorsContext
for
CatchBlockEarlyErrorsContext
{
fn
declare_var
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
info
)
=
self
.
param
.
bound_names_of_catch_param
.
get
(
&
name
)
{
if
!
self
.
param
.
is_simple
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
}
self
.
block
.
declare_var
(
name
kind
offset
atoms
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
FormalParametersEarlyErrorsContext
{
bound_names_of_params
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
is_simple
:
bool
}
impl
FormalParametersEarlyErrorsContext
{
pub
fn
new_simple
(
)
-
>
Self
{
Self
{
bound_names_of_params
:
HashMap
:
:
new
(
)
is_simple
:
true
}
}
pub
fn
new_non_simple
(
)
-
>
Self
{
Self
{
bound_names_of_params
:
HashMap
:
:
new
(
)
is_simple
:
false
}
}
}
impl
ParameterEarlyErrorsContext
for
FormalParametersEarlyErrorsContext
{
fn
declare
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
let
kind
=
DeclarationKind
:
:
FormalParameter
;
if
let
Some
(
info
)
=
self
.
bound_names_of_params
.
get
(
&
name
)
{
if
!
self
.
is_simple
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
}
self
.
bound_names_of_params
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
UniqueFormalParametersEarlyErrorsContext
{
bound_names_of_params
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
}
impl
UniqueFormalParametersEarlyErrorsContext
{
pub
fn
new
(
)
-
>
Self
{
Self
{
bound_names_of_params
:
HashMap
:
:
new
(
)
}
}
}
impl
ParameterEarlyErrorsContext
for
UniqueFormalParametersEarlyErrorsContext
{
fn
declare
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
let
kind
=
DeclarationKind
:
:
FormalParameter
;
if
let
Some
(
info
)
=
self
.
bound_names_of_params
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
bound_names_of_params
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
struct
InternalFunctionBodyEarlyErrorsContext
{
lex_names_of_body
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
var_names_of_body
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
}
impl
InternalFunctionBodyEarlyErrorsContext
{
fn
new
(
)
-
>
Self
{
Self
{
lex_names_of_body
:
HashMap
:
:
new
(
)
var_names_of_body
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Class
|
DeclarationKind
:
:
Let
|
DeclarationKind
:
:
Const
=
>
true
_
=
>
false
}
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
BodyLevelFunction
|
DeclarationKind
:
:
Var
|
DeclarationKind
:
:
VarForAnnexBLexicalFunction
=
>
true
_
=
>
false
}
}
}
impl
LexicalEarlyErrorsContext
for
InternalFunctionBodyEarlyErrorsContext
{
fn
declare_lex
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_body
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
if
let
Some
(
info
)
=
self
.
var_names_of_body
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
lex_names_of_body
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
impl
VarEarlyErrorsContext
for
InternalFunctionBodyEarlyErrorsContext
{
fn
declare_var
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_body
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
var_names_of_body
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
FunctionBodyEarlyErrorsContext
{
param
:
FormalParametersEarlyErrorsContext
body
:
InternalFunctionBodyEarlyErrorsContext
}
impl
FunctionBodyEarlyErrorsContext
{
pub
fn
new
(
param
:
FormalParametersEarlyErrorsContext
)
-
>
Self
{
Self
{
param
body
:
InternalFunctionBodyEarlyErrorsContext
:
:
new
(
)
}
}
}
impl
LexicalEarlyErrorsContext
for
FunctionBodyEarlyErrorsContext
{
fn
declare_lex
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
info
)
=
self
.
param
.
bound_names_of_params
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
body
.
declare_lex
(
name
kind
offset
atoms
)
}
}
impl
VarEarlyErrorsContext
for
FunctionBodyEarlyErrorsContext
{
fn
declare_var
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
self
.
body
.
declare_var
(
name
kind
offset
atoms
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
UniqueFunctionBodyEarlyErrorsContext
{
param
:
UniqueFormalParametersEarlyErrorsContext
body
:
InternalFunctionBodyEarlyErrorsContext
}
impl
UniqueFunctionBodyEarlyErrorsContext
{
pub
fn
new
(
param
:
UniqueFormalParametersEarlyErrorsContext
)
-
>
Self
{
Self
{
param
body
:
InternalFunctionBodyEarlyErrorsContext
:
:
new
(
)
}
}
}
impl
LexicalEarlyErrorsContext
for
UniqueFunctionBodyEarlyErrorsContext
{
fn
declare_lex
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
info
)
=
self
.
param
.
bound_names_of_params
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
body
.
declare_lex
(
name
kind
offset
atoms
)
}
}
impl
VarEarlyErrorsContext
for
UniqueFunctionBodyEarlyErrorsContext
{
fn
declare_var
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
self
.
body
.
declare_var
(
name
kind
offset
atoms
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
ScriptEarlyErrorsContext
{
lex_names_of_body
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
var_names_of_body
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
}
impl
ScriptEarlyErrorsContext
{
pub
fn
new
(
)
-
>
Self
{
Self
{
lex_names_of_body
:
HashMap
:
:
new
(
)
var_names_of_body
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Class
|
DeclarationKind
:
:
Let
|
DeclarationKind
:
:
Const
=
>
true
_
=
>
false
}
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Var
|
DeclarationKind
:
:
BodyLevelFunction
|
DeclarationKind
:
:
VarForAnnexBLexicalFunction
=
>
true
_
=
>
false
}
}
}
impl
LexicalEarlyErrorsContext
for
ScriptEarlyErrorsContext
{
fn
declare_lex
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_body
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
if
let
Some
(
info
)
=
self
.
var_names_of_body
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
lex_names_of_body
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
impl
VarEarlyErrorsContext
for
ScriptEarlyErrorsContext
{
fn
declare_var
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_body
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
var_names_of_body
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
ModuleEarlyErrorsContext
{
lex_names_of_item_list
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
var_names_of_item_list
:
HashMap
<
SourceAtomSetIndex
DeclarationInfo
>
exported_names_of_item_list
:
HashMap
<
SourceAtomSetIndex
usize
>
exported_bindings_of_item_list
:
HashMap
<
SourceAtomSetIndex
usize
>
}
impl
ModuleEarlyErrorsContext
{
pub
fn
new
(
)
-
>
Self
{
Self
{
lex_names_of_item_list
:
HashMap
:
:
new
(
)
var_names_of_item_list
:
HashMap
:
:
new
(
)
exported_names_of_item_list
:
HashMap
:
:
new
(
)
exported_bindings_of_item_list
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Import
|
DeclarationKind
:
:
BodyLevelFunction
|
DeclarationKind
:
:
Class
|
DeclarationKind
:
:
Let
|
DeclarationKind
:
:
Const
=
>
true
_
=
>
false
}
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Var
=
>
true
_
=
>
false
}
}
#
[
allow
(
dead_code
)
]
pub
fn
add_exported_name
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
prev_offset
)
=
self
.
exported_names_of_item_list
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateExport
(
name
prev_offset
.
clone
(
)
offset
)
)
;
}
self
.
exported_names_of_item_list
.
insert
(
name
offset
)
;
Ok
(
(
)
)
}
#
[
allow
(
dead_code
)
]
pub
fn
add_exported_binding
(
&
mut
self
name
:
SourceAtomSetIndex
offset
:
usize
)
{
self
.
exported_bindings_of_item_list
.
insert
(
name
offset
)
;
}
#
[
allow
(
dead_code
)
]
pub
fn
check_exported_name
<
'
alloc
>
(
&
self
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
for
(
name
offset
)
in
&
self
.
exported_bindings_of_item_list
{
if
!
self
.
var_names_of_item_list
.
contains_key
(
name
)
&
&
!
self
.
lex_names_of_item_list
.
contains_key
(
name
)
{
let
name
=
atoms
.
get
(
*
name
)
;
return
Err
(
ParseError
:
:
MissingExport
(
name
offset
.
clone
(
)
)
)
;
}
}
Ok
(
(
)
)
}
}
impl
LexicalEarlyErrorsContext
for
ModuleEarlyErrorsContext
{
fn
declare_lex
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_item_list
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
if
let
Some
(
info
)
=
self
.
var_names_of_item_list
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
lex_names_of_item_list
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
impl
VarEarlyErrorsContext
for
ModuleEarlyErrorsContext
{
fn
declare_var
<
'
alloc
>
(
&
mut
self
name
:
SourceAtomSetIndex
kind
:
DeclarationKind
offset
:
usize
atoms
:
&
SourceAtomSet
<
'
alloc
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_item_list
.
get
(
&
name
)
{
let
name
=
atoms
.
get
(
name
)
;
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
var_names_of_item_list
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
