use
crate
:
:
parser_tables_generated
:
:
TerminalId
;
use
crate
:
:
DeclarationKind
;
use
crate
:
:
ParseError
;
use
crate
:
:
Token
;
use
ast
:
:
arena
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
marker
:
:
PhantomData
;
pub
type
Name
<
'
alloc
>
=
&
'
alloc
str
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
struct
DeclarationInfo
{
kind
:
DeclarationKind
offset
:
usize
}
impl
DeclarationInfo
{
fn
new
(
kind
:
DeclarationKind
offset
:
usize
)
-
>
Self
{
Self
{
kind
offset
}
}
}
pub
type
EarlyErrorsResult
<
'
alloc
>
=
Result
<
(
)
ParseError
<
'
alloc
>
>
;
pub
trait
LexicalEarlyErrorsContext
<
'
alloc
>
{
fn
declare_lex
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
;
}
pub
trait
VarEarlyErrorsContext
<
'
alloc
>
{
fn
declare_var
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
;
}
pub
trait
ParameterEarlyErrorsContext
<
'
alloc
>
{
fn
declare
(
&
mut
self
name
:
Name
<
'
alloc
>
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
;
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
IdentifierEarlyErrorsContext
<
'
alloc
>
{
phantom
:
PhantomData
<
&
'
alloc
(
)
>
}
impl
<
'
alloc
>
IdentifierEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
phantom
:
PhantomData
}
}
fn
is_strict
(
&
self
)
-
>
Result
<
bool
ParseError
<
'
alloc
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
strict
-
mode
-
only
early
error
is
not
yet
supported
"
)
)
}
fn
is_arguments_identifier
(
token
:
&
arena
:
:
Box
<
'
alloc
Token
<
'
alloc
>
>
)
-
>
bool
{
return
(
token
.
terminal_id
=
=
TerminalId
:
:
Name
|
|
token
.
terminal_id
=
=
TerminalId
:
:
NameWithEscape
)
&
&
token
.
value
.
unwrap
(
)
=
=
"
arguments
"
;
}
fn
is_eval_identifier
(
token
:
&
arena
:
:
Box
<
'
alloc
Token
<
'
alloc
>
>
)
-
>
bool
{
return
(
token
.
terminal_id
=
=
TerminalId
:
:
Name
|
|
token
.
terminal_id
=
=
TerminalId
:
:
NameWithEscape
)
&
&
token
.
value
.
unwrap
(
)
=
=
"
eval
"
;
}
fn
is_yield_identifier
(
token
:
&
arena
:
:
Box
<
'
alloc
Token
<
'
alloc
>
>
)
-
>
bool
{
return
token
.
terminal_id
=
=
TerminalId
:
:
Yield
|
|
(
token
.
terminal_id
=
=
TerminalId
:
:
NameWithEscape
&
&
token
.
value
.
unwrap
(
)
=
=
"
yield
"
)
;
}
fn
is_await_identifier
(
token
:
&
arena
:
:
Box
<
'
alloc
Token
<
'
alloc
>
>
)
-
>
bool
{
return
token
.
terminal_id
=
=
TerminalId
:
:
Await
|
|
(
token
.
terminal_id
=
=
TerminalId
:
:
NameWithEscape
&
&
token
.
value
.
unwrap
(
)
=
=
"
await
"
)
;
}
pub
fn
check_binding_identifier
(
&
self
token
:
&
arena
:
:
Box
<
'
alloc
Token
<
'
alloc
>
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
Self
:
:
is_arguments_identifier
(
token
)
|
|
Self
:
:
is_eval_identifier
(
token
)
{
if
self
.
is_strict
(
)
?
{
let
name
=
token
.
value
.
unwrap
(
)
;
let
offset
=
token
.
loc
.
start
;
return
Err
(
ParseError
:
:
InvalidIdentifier
(
name
.
clone
(
)
offset
)
)
;
}
return
Ok
(
(
)
)
;
}
if
Self
:
:
is_yield_identifier
(
token
)
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
[
Yield
]
parameter
"
)
)
;
}
if
Self
:
:
is_await_identifier
(
token
)
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
[
Await
]
parameter
"
)
)
;
}
self
.
check_identifier
(
token
)
}
pub
fn
check_label_identifier
(
&
self
token
:
&
arena
:
:
Box
<
'
alloc
Token
<
'
alloc
>
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
Self
:
:
is_yield_identifier
(
token
)
{
return
self
.
check_yield_common
(
token
)
;
}
if
Self
:
:
is_await_identifier
(
token
)
{
return
self
.
check_await_common
(
token
)
;
}
self
.
check_identifier
(
token
)
}
pub
fn
check_identifier_reference
(
&
self
token
:
&
arena
:
:
Box
<
'
alloc
Token
<
'
alloc
>
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
Self
:
:
is_yield_identifier
(
token
)
{
return
self
.
check_yield_common
(
token
)
;
}
if
Self
:
:
is_await_identifier
(
token
)
{
return
self
.
check_await_common
(
token
)
;
}
self
.
check_identifier
(
token
)
}
fn
check_yield_common
(
&
self
_token
:
&
arena
:
:
Box
<
'
alloc
Token
<
'
alloc
>
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
[
Yield
]
parameter
"
)
)
;
}
fn
check_await_common
(
&
self
_token
:
&
arena
:
:
Box
<
'
alloc
Token
<
'
alloc
>
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
[
Await
]
parameter
"
)
)
;
}
fn
check_identifier
(
&
self
token
:
&
arena
:
:
Box
<
'
alloc
Token
<
'
alloc
>
>
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
match
token
.
terminal_id
{
TerminalId
:
:
NameWithEscape
=
>
{
let
name
=
token
.
value
.
unwrap
(
)
;
match
name
{
"
implements
"
|
"
interface
"
|
"
let
"
|
"
package
"
|
"
private
"
|
"
protected
"
|
"
public
"
|
"
static
"
=
>
{
if
self
.
is_strict
(
)
?
{
let
offset
=
token
.
loc
.
start
;
return
Err
(
ParseError
:
:
InvalidIdentifier
(
name
.
clone
(
)
offset
)
)
;
}
}
"
break
"
|
"
case
"
|
"
catch
"
|
"
class
"
|
"
const
"
|
"
continue
"
|
"
debugger
"
|
"
default
"
|
"
delete
"
|
"
do
"
|
"
else
"
|
"
enum
"
|
"
export
"
|
"
extends
"
|
"
false
"
|
"
finally
"
|
"
for
"
|
"
function
"
|
"
if
"
|
"
import
"
|
"
in
"
|
"
instanceof
"
|
"
new
"
|
"
null
"
|
"
return
"
|
"
super
"
|
"
switch
"
|
"
this
"
|
"
throw
"
|
"
true
"
|
"
try
"
|
"
typeof
"
|
"
var
"
|
"
void
"
|
"
while
"
|
"
with
"
=
>
{
let
offset
=
token
.
loc
.
start
;
return
Err
(
ParseError
:
:
InvalidIdentifier
(
name
.
clone
(
)
offset
)
)
;
}
_
=
>
{
}
}
}
TerminalId
:
:
Implements
|
TerminalId
:
:
Interface
|
TerminalId
:
:
Let
|
TerminalId
:
:
Package
|
TerminalId
:
:
Private
|
TerminalId
:
:
Protected
|
TerminalId
:
:
Public
|
TerminalId
:
:
Static
=
>
{
if
self
.
is_strict
(
)
?
{
let
name
=
token
.
value
.
unwrap
(
)
;
let
offset
=
token
.
loc
.
start
;
return
Err
(
ParseError
:
:
InvalidIdentifier
(
name
.
clone
(
)
offset
)
)
;
}
}
_
=
>
{
}
}
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
BlockEarlyErrorsContext
<
'
alloc
>
{
lex_names_of_stmt_list
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
var_names_of_stmt_list
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
}
impl
<
'
alloc
>
BlockEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
lex_names_of_stmt_list
:
HashMap
:
:
new
(
)
var_names_of_stmt_list
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
LexicalFunction
|
DeclarationKind
:
:
LexicalAsyncOrGenerator
|
DeclarationKind
:
:
Class
|
DeclarationKind
:
:
Let
|
DeclarationKind
:
:
Const
=
>
true
_
=
>
false
}
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Var
|
DeclarationKind
:
:
VarForAnnexBLexicalFunction
=
>
true
_
=
>
false
}
}
fn
is_strict
(
&
self
)
-
>
Result
<
bool
ParseError
<
'
alloc
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
strict
-
mode
-
only
early
error
is
not
yet
supported
"
)
)
}
}
impl
<
'
alloc
>
LexicalEarlyErrorsContext
<
'
alloc
>
for
BlockEarlyErrorsContext
<
'
alloc
>
{
fn
declare_lex
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_stmt_list
.
get
(
&
name
)
{
if
!
(
!
self
.
is_strict
(
)
?
&
&
info
.
kind
=
=
DeclarationKind
:
:
LexicalFunction
&
&
kind
=
=
DeclarationKind
:
:
LexicalFunction
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
}
if
let
Some
(
info
)
=
self
.
var_names_of_stmt_list
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
lex_names_of_stmt_list
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
impl
<
'
alloc
>
VarEarlyErrorsContext
<
'
alloc
>
for
BlockEarlyErrorsContext
<
'
alloc
>
{
fn
declare_var
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_stmt_list
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
var_names_of_stmt_list
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
LexicalForHeadEarlyErrorsContext
<
'
alloc
>
{
bound_names_of_decl
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
}
impl
<
'
alloc
>
LexicalForHeadEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
bound_names_of_decl
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Let
|
DeclarationKind
:
:
Const
=
>
true
_
=
>
false
}
}
}
impl
<
'
alloc
>
LexicalEarlyErrorsContext
<
'
alloc
>
for
LexicalForHeadEarlyErrorsContext
<
'
alloc
>
{
fn
declare_lex
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
bound_names_of_decl
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
bound_names_of_decl
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
struct
InternalForBodyEarlyErrorsContext
<
'
alloc
>
{
var_names_of_stmt
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
}
impl
<
'
alloc
>
InternalForBodyEarlyErrorsContext
<
'
alloc
>
{
fn
new
(
)
-
>
Self
{
Self
{
var_names_of_stmt
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Var
=
>
true
_
=
>
false
}
}
}
impl
<
'
alloc
>
VarEarlyErrorsContext
<
'
alloc
>
for
InternalForBodyEarlyErrorsContext
<
'
alloc
>
{
fn
declare_var
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
self
.
var_names_of_stmt
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
LexicalForBodyEarlyErrorsContext
<
'
alloc
>
{
head
:
LexicalForHeadEarlyErrorsContext
<
'
alloc
>
body
:
InternalForBodyEarlyErrorsContext
<
'
alloc
>
}
impl
<
'
alloc
>
LexicalForBodyEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new
(
head
:
LexicalForHeadEarlyErrorsContext
<
'
alloc
>
)
-
>
Self
{
Self
{
head
body
:
InternalForBodyEarlyErrorsContext
:
:
new
(
)
}
}
}
impl
<
'
alloc
>
VarEarlyErrorsContext
<
'
alloc
>
for
LexicalForBodyEarlyErrorsContext
<
'
alloc
>
{
fn
declare_var
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
info
)
=
self
.
head
.
bound_names_of_decl
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
body
.
declare_var
(
name
kind
offset
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
CaseBlockEarlyErrorsContext
<
'
alloc
>
{
lex_names_of_case_block
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
var_names_of_case_block
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
}
impl
<
'
alloc
>
CaseBlockEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
lex_names_of_case_block
:
HashMap
:
:
new
(
)
var_names_of_case_block
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
BlockEarlyErrorsContext
:
:
is_supported_lexical
(
kind
)
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
BlockEarlyErrorsContext
:
:
is_supported_var
(
kind
)
}
fn
is_strict
(
&
self
)
-
>
Result
<
bool
ParseError
<
'
alloc
>
>
{
Err
(
ParseError
:
:
NotImplemented
(
"
strict
-
mode
-
only
early
error
is
not
yet
supported
"
)
)
}
}
impl
<
'
alloc
>
LexicalEarlyErrorsContext
<
'
alloc
>
for
CaseBlockEarlyErrorsContext
<
'
alloc
>
{
fn
declare_lex
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_case_block
.
get
(
&
name
)
{
if
!
(
!
self
.
is_strict
(
)
?
&
&
info
.
kind
=
=
DeclarationKind
:
:
LexicalFunction
&
&
kind
=
=
DeclarationKind
:
:
LexicalFunction
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
}
if
let
Some
(
info
)
=
self
.
var_names_of_case_block
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
lex_names_of_case_block
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
impl
<
'
alloc
>
VarEarlyErrorsContext
<
'
alloc
>
for
CaseBlockEarlyErrorsContext
<
'
alloc
>
{
fn
declare_var
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_case_block
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
var_names_of_case_block
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
CatchParameterEarlyErrorsContext
<
'
alloc
>
{
bound_names_of_catch_param
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
is_simple
:
bool
}
impl
<
'
alloc
>
CatchParameterEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new_with_binding_identifier
(
)
-
>
Self
{
Self
{
bound_names_of_catch_param
:
HashMap
:
:
new
(
)
is_simple
:
true
}
}
pub
fn
new_with_binding_pattern
(
)
-
>
Self
{
Self
{
bound_names_of_catch_param
:
HashMap
:
:
new
(
)
is_simple
:
false
}
}
}
impl
<
'
alloc
>
ParameterEarlyErrorsContext
<
'
alloc
>
for
CatchParameterEarlyErrorsContext
<
'
alloc
>
{
fn
declare
(
&
mut
self
name
:
Name
<
'
alloc
>
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
let
kind
=
DeclarationKind
:
:
CatchParameter
;
if
let
Some
(
info
)
=
self
.
bound_names_of_catch_param
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
offset
kind
offset
)
)
;
}
self
.
bound_names_of_catch_param
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
CatchBlockEarlyErrorsContext
<
'
alloc
>
{
param
:
CatchParameterEarlyErrorsContext
<
'
alloc
>
block
:
BlockEarlyErrorsContext
<
'
alloc
>
}
impl
<
'
alloc
>
CatchBlockEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new
(
param
:
CatchParameterEarlyErrorsContext
<
'
alloc
>
)
-
>
Self
{
Self
{
param
block
:
BlockEarlyErrorsContext
:
:
new
(
)
}
}
}
impl
<
'
alloc
>
LexicalEarlyErrorsContext
<
'
alloc
>
for
CatchBlockEarlyErrorsContext
<
'
alloc
>
{
fn
declare_lex
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
info
)
=
self
.
param
.
bound_names_of_catch_param
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
offset
kind
offset
)
)
;
}
self
.
block
.
declare_lex
(
name
kind
offset
)
}
}
impl
<
'
alloc
>
VarEarlyErrorsContext
<
'
alloc
>
for
CatchBlockEarlyErrorsContext
<
'
alloc
>
{
fn
declare_var
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
info
)
=
self
.
param
.
bound_names_of_catch_param
.
get
(
&
name
)
{
if
!
self
.
param
.
is_simple
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
}
self
.
block
.
declare_var
(
name
kind
offset
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
FormalParametersEarlyErrorsContext
<
'
alloc
>
{
bound_names_of_params
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
is_simple
:
bool
}
impl
<
'
alloc
>
FormalParametersEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new_simple
(
)
-
>
Self
{
Self
{
bound_names_of_params
:
HashMap
:
:
new
(
)
is_simple
:
true
}
}
pub
fn
new_non_simple
(
)
-
>
Self
{
Self
{
bound_names_of_params
:
HashMap
:
:
new
(
)
is_simple
:
false
}
}
}
impl
<
'
alloc
>
ParameterEarlyErrorsContext
<
'
alloc
>
for
FormalParametersEarlyErrorsContext
<
'
alloc
>
{
fn
declare
(
&
mut
self
name
:
Name
<
'
alloc
>
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
let
kind
=
DeclarationKind
:
:
FormalParameter
;
if
let
Some
(
info
)
=
self
.
bound_names_of_params
.
get
(
&
name
)
{
if
!
self
.
is_simple
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
}
self
.
bound_names_of_params
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
UniqueFormalParametersEarlyErrorsContext
<
'
alloc
>
{
bound_names_of_params
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
}
impl
<
'
alloc
>
UniqueFormalParametersEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
bound_names_of_params
:
HashMap
:
:
new
(
)
}
}
}
impl
<
'
alloc
>
ParameterEarlyErrorsContext
<
'
alloc
>
for
UniqueFormalParametersEarlyErrorsContext
<
'
alloc
>
{
fn
declare
(
&
mut
self
name
:
Name
<
'
alloc
>
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
let
kind
=
DeclarationKind
:
:
FormalParameter
;
if
let
Some
(
info
)
=
self
.
bound_names_of_params
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
bound_names_of_params
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
struct
InternalFunctionBodyEarlyErrorsContext
<
'
alloc
>
{
lex_names_of_body
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
var_names_of_body
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
}
impl
<
'
alloc
>
InternalFunctionBodyEarlyErrorsContext
<
'
alloc
>
{
fn
new
(
)
-
>
Self
{
Self
{
lex_names_of_body
:
HashMap
:
:
new
(
)
var_names_of_body
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Class
|
DeclarationKind
:
:
Let
|
DeclarationKind
:
:
Const
=
>
true
_
=
>
false
}
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
BodyLevelFunction
|
DeclarationKind
:
:
Var
|
DeclarationKind
:
:
VarForAnnexBLexicalFunction
=
>
true
_
=
>
false
}
}
}
impl
<
'
alloc
>
LexicalEarlyErrorsContext
<
'
alloc
>
for
InternalFunctionBodyEarlyErrorsContext
<
'
alloc
>
{
fn
declare_lex
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_body
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
if
let
Some
(
info
)
=
self
.
var_names_of_body
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
lex_names_of_body
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
impl
<
'
alloc
>
VarEarlyErrorsContext
<
'
alloc
>
for
InternalFunctionBodyEarlyErrorsContext
<
'
alloc
>
{
fn
declare_var
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_body
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
var_names_of_body
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
FunctionBodyEarlyErrorsContext
<
'
alloc
>
{
param
:
FormalParametersEarlyErrorsContext
<
'
alloc
>
body
:
InternalFunctionBodyEarlyErrorsContext
<
'
alloc
>
}
impl
<
'
alloc
>
FunctionBodyEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new
(
param
:
FormalParametersEarlyErrorsContext
<
'
alloc
>
)
-
>
Self
{
Self
{
param
body
:
InternalFunctionBodyEarlyErrorsContext
:
:
new
(
)
}
}
}
impl
<
'
alloc
>
LexicalEarlyErrorsContext
<
'
alloc
>
for
FunctionBodyEarlyErrorsContext
<
'
alloc
>
{
fn
declare_lex
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
info
)
=
self
.
param
.
bound_names_of_params
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
body
.
declare_lex
(
name
kind
offset
)
}
}
impl
<
'
alloc
>
VarEarlyErrorsContext
<
'
alloc
>
for
FunctionBodyEarlyErrorsContext
<
'
alloc
>
{
fn
declare_var
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
self
.
body
.
declare_var
(
name
kind
offset
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
UniqueFunctionBodyEarlyErrorsContext
<
'
alloc
>
{
param
:
UniqueFormalParametersEarlyErrorsContext
<
'
alloc
>
body
:
InternalFunctionBodyEarlyErrorsContext
<
'
alloc
>
}
impl
<
'
alloc
>
UniqueFunctionBodyEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new
(
param
:
UniqueFormalParametersEarlyErrorsContext
<
'
alloc
>
)
-
>
Self
{
Self
{
param
body
:
InternalFunctionBodyEarlyErrorsContext
:
:
new
(
)
}
}
}
impl
<
'
alloc
>
LexicalEarlyErrorsContext
<
'
alloc
>
for
UniqueFunctionBodyEarlyErrorsContext
<
'
alloc
>
{
fn
declare_lex
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
info
)
=
self
.
param
.
bound_names_of_params
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
body
.
declare_lex
(
name
kind
offset
)
}
}
impl
<
'
alloc
>
VarEarlyErrorsContext
<
'
alloc
>
for
UniqueFunctionBodyEarlyErrorsContext
<
'
alloc
>
{
fn
declare_var
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
self
.
body
.
declare_var
(
name
kind
offset
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
ScriptEarlyErrorsContext
<
'
alloc
>
{
lex_names_of_body
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
var_names_of_body
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
}
impl
<
'
alloc
>
ScriptEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
lex_names_of_body
:
HashMap
:
:
new
(
)
var_names_of_body
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Class
|
DeclarationKind
:
:
Let
|
DeclarationKind
:
:
Const
=
>
true
_
=
>
false
}
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Var
|
DeclarationKind
:
:
BodyLevelFunction
|
DeclarationKind
:
:
VarForAnnexBLexicalFunction
=
>
true
_
=
>
false
}
}
}
impl
<
'
alloc
>
LexicalEarlyErrorsContext
<
'
alloc
>
for
ScriptEarlyErrorsContext
<
'
alloc
>
{
fn
declare_lex
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_body
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
if
let
Some
(
info
)
=
self
.
var_names_of_body
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
lex_names_of_body
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
impl
<
'
alloc
>
VarEarlyErrorsContext
<
'
alloc
>
for
ScriptEarlyErrorsContext
<
'
alloc
>
{
fn
declare_var
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_body
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
var_names_of_body
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
ModuleEarlyErrorsContext
<
'
alloc
>
{
lex_names_of_item_list
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
var_names_of_item_list
:
HashMap
<
Name
<
'
alloc
>
DeclarationInfo
>
exported_names_of_item_list
:
HashMap
<
Name
<
'
alloc
>
usize
>
exported_bindings_of_item_list
:
HashMap
<
Name
<
'
alloc
>
usize
>
}
impl
<
'
alloc
>
ModuleEarlyErrorsContext
<
'
alloc
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
lex_names_of_item_list
:
HashMap
:
:
new
(
)
var_names_of_item_list
:
HashMap
:
:
new
(
)
exported_names_of_item_list
:
HashMap
:
:
new
(
)
exported_bindings_of_item_list
:
HashMap
:
:
new
(
)
}
}
fn
is_supported_lexical
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Import
|
DeclarationKind
:
:
BodyLevelFunction
|
DeclarationKind
:
:
Class
|
DeclarationKind
:
:
Let
|
DeclarationKind
:
:
Const
=
>
true
_
=
>
false
}
}
fn
is_supported_var
(
kind
:
DeclarationKind
)
-
>
bool
{
match
kind
{
DeclarationKind
:
:
Var
=
>
true
_
=
>
false
}
}
#
[
allow
(
dead_code
)
]
pub
fn
add_exported_name
(
&
mut
self
name
:
Name
<
'
alloc
>
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
if
let
Some
(
prev_offset
)
=
self
.
exported_names_of_item_list
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateExport
(
name
.
clone
(
)
prev_offset
.
clone
(
)
offset
)
)
;
}
self
.
exported_names_of_item_list
.
insert
(
name
offset
)
;
Ok
(
(
)
)
}
#
[
allow
(
dead_code
)
]
pub
fn
add_exported_binding
(
&
mut
self
name
:
Name
<
'
alloc
>
offset
:
usize
)
{
self
.
exported_bindings_of_item_list
.
insert
(
name
offset
)
;
}
#
[
allow
(
dead_code
)
]
pub
fn
check_exported_name
(
&
self
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
for
(
name
offset
)
in
&
self
.
exported_bindings_of_item_list
{
if
!
self
.
var_names_of_item_list
.
contains_key
(
name
)
&
&
!
self
.
lex_names_of_item_list
.
contains_key
(
name
)
{
return
Err
(
ParseError
:
:
MissingExport
(
name
offset
.
clone
(
)
)
)
;
}
}
Ok
(
(
)
)
}
}
impl
<
'
alloc
>
LexicalEarlyErrorsContext
<
'
alloc
>
for
ModuleEarlyErrorsContext
<
'
alloc
>
{
fn
declare_lex
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_lexical
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_item_list
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
if
let
Some
(
info
)
=
self
.
var_names_of_item_list
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
lex_names_of_item_list
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
impl
<
'
alloc
>
VarEarlyErrorsContext
<
'
alloc
>
for
ModuleEarlyErrorsContext
<
'
alloc
>
{
fn
declare_var
(
&
mut
self
name
:
Name
<
'
alloc
>
kind
:
DeclarationKind
offset
:
usize
)
-
>
EarlyErrorsResult
<
'
alloc
>
{
debug_assert
!
(
Self
:
:
is_supported_var
(
kind
)
)
;
if
let
Some
(
info
)
=
self
.
lex_names_of_item_list
.
get
(
&
name
)
{
return
Err
(
ParseError
:
:
DuplicateBinding
(
name
.
clone
(
)
info
.
kind
info
.
offset
kind
offset
)
)
;
}
self
.
var_names_of_item_list
.
insert
(
name
DeclarationInfo
:
:
new
(
kind
offset
)
)
;
Ok
(
(
)
)
}
}
