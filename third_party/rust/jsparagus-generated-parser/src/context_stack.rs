use
ast
:
:
source_atom_set
:
:
SourceAtomSetIndex
;
use
std
:
:
iter
:
:
{
Skip
Take
}
;
use
std
:
:
slice
:
:
Iter
;
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
pub
enum
BindingKind
{
Unknown
Var
Function
AsyncOrGenerator
Let
Const
Class
Label
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
pub
struct
BindingInfo
{
pub
name
:
SourceAtomSetIndex
pub
offset
:
usize
pub
kind
:
BindingKind
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
pub
struct
BindingsIndex
{
pub
index
:
usize
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
pub
enum
ControlKind
{
Continue
Break
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
pub
struct
ControlInfo
{
pub
label
:
Option
<
SourceAtomSetIndex
>
pub
offset
:
usize
pub
kind
:
ControlKind
}
impl
ControlInfo
{
pub
fn
new_continue
(
offset
:
usize
label
:
Option
<
SourceAtomSetIndex
>
)
-
>
Self
{
Self
{
label
kind
:
ControlKind
:
:
Continue
offset
}
}
pub
fn
new_break
(
offset
:
usize
label
:
Option
<
SourceAtomSetIndex
>
)
-
>
Self
{
Self
{
label
kind
:
ControlKind
:
:
Break
offset
}
}
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
pub
struct
BreakOrContinueIndex
{
pub
index
:
usize
}
impl
BreakOrContinueIndex
{
pub
fn
new
(
index
:
usize
)
-
>
Self
{
Self
{
index
}
}
}
pub
struct
ContextMetadata
{
bindings
:
Vec
<
BindingInfo
>
breaks_and_continues
:
Vec
<
ControlInfo
>
}
impl
ContextMetadata
{
pub
fn
new
(
)
-
>
Self
{
Self
{
bindings
:
Vec
:
:
new
(
)
breaks_and_continues
:
Vec
:
:
new
(
)
}
}
pub
fn
push_binding
(
&
mut
self
binding
:
BindingInfo
)
{
self
.
bindings
.
push
(
binding
)
;
}
pub
fn
last_binding
(
&
mut
self
)
-
>
Option
<
&
BindingInfo
>
{
self
.
bindings
.
last
(
)
}
pub
fn
push_break_or_continue
(
&
mut
self
control
:
ControlInfo
)
{
self
.
breaks_and_continues
.
push
(
control
)
;
}
pub
fn
mark_binding_kind
(
&
mut
self
from
:
usize
to
:
Option
<
usize
>
kind
:
BindingKind
)
{
for
info
in
self
.
bindings
.
iter_mut
(
)
.
rev
(
)
{
if
info
.
offset
<
from
{
break
;
}
if
to
.
is_none
(
)
|
|
info
.
offset
<
to
.
unwrap
(
)
{
info
.
kind
=
kind
;
}
}
}
pub
fn
bindings_from
(
&
self
index
:
BindingsIndex
)
-
>
Skip
<
Iter
<
'
_
BindingInfo
>
>
{
self
.
bindings
.
iter
(
)
.
skip
(
index
.
index
)
}
pub
fn
bindings_from_to
(
&
self
from
:
BindingsIndex
to
:
BindingsIndex
)
-
>
Take
<
Skip
<
Iter
<
'
_
BindingInfo
>
>
>
{
self
.
bindings
.
iter
(
)
.
skip
(
from
.
index
)
.
take
(
to
.
index
-
from
.
index
)
}
pub
fn
find_first_binding
(
&
mut
self
offset
:
usize
)
-
>
BindingsIndex
{
let
mut
i
=
self
.
bindings
.
len
(
)
;
for
info
in
self
.
bindings
.
iter_mut
(
)
.
rev
(
)
{
if
info
.
offset
<
offset
{
break
;
}
i
-
=
1
;
}
BindingsIndex
{
index
:
i
}
}
pub
fn
pop_bindings_from
(
&
mut
self
index
:
BindingsIndex
)
{
self
.
bindings
.
truncate
(
index
.
index
)
}
pub
fn
pop_lexical_bindings_from
(
&
mut
self
index
:
BindingsIndex
)
{
let
len
=
self
.
bindings
.
len
(
)
;
let
mut
i
=
index
.
index
;
while
i
<
len
&
&
self
.
bindings
[
i
]
.
kind
=
=
BindingKind
:
:
Var
{
i
+
=
1
;
}
let
mut
j
=
i
;
while
j
<
len
{
if
self
.
bindings
[
j
]
.
kind
=
=
BindingKind
:
:
Var
|
|
self
.
bindings
[
j
]
.
kind
=
=
BindingKind
:
:
Label
{
self
.
bindings
[
i
]
=
self
.
bindings
[
j
]
;
i
+
=
1
;
}
j
+
=
1
;
}
self
.
bindings
.
truncate
(
i
)
}
pub
fn
breaks_and_continues_from
(
&
self
index
:
BreakOrContinueIndex
)
-
>
Skip
<
Iter
<
'
_
ControlInfo
>
>
{
self
.
breaks_and_continues
.
iter
(
)
.
skip
(
index
.
index
)
}
pub
fn
find_first_break_or_continue
(
&
mut
self
offset
:
usize
)
-
>
BreakOrContinueIndex
{
let
mut
i
=
self
.
breaks_and_continues
.
len
(
)
;
for
info
in
self
.
breaks_and_continues
.
iter_mut
(
)
.
rev
(
)
{
if
info
.
offset
<
offset
{
break
;
}
i
-
=
1
;
}
BreakOrContinueIndex
:
:
new
(
i
)
}
pub
fn
pop_labelled_breaks_and_continues_from_index
(
&
mut
self
index
:
BreakOrContinueIndex
name
:
SourceAtomSetIndex
)
{
let
len
=
self
.
breaks_and_continues
.
len
(
)
;
let
mut
i
=
index
.
index
;
let
mut
j
=
i
;
while
j
<
len
{
let
label
=
self
.
breaks_and_continues
[
j
]
.
label
;
if
label
.
is_none
(
)
|
|
label
.
unwrap
(
)
!
=
name
{
self
.
breaks_and_continues
[
i
]
=
self
.
breaks_and_continues
[
j
]
;
i
+
=
1
;
}
j
+
=
1
;
}
self
.
breaks_and_continues
.
truncate
(
i
)
}
pub
fn
pop_unlabelled_breaks_and_continues_from
(
&
mut
self
offset
:
usize
)
{
let
len
=
self
.
breaks_and_continues
.
len
(
)
;
let
index
=
self
.
find_first_break_or_continue
(
offset
)
;
let
mut
i
=
index
.
index
;
while
i
<
len
&
&
self
.
breaks_and_continues
[
i
]
.
label
.
is_some
(
)
{
i
+
=
1
;
}
let
mut
j
=
i
;
while
j
<
len
{
if
self
.
breaks_and_continues
[
j
]
.
label
.
is_some
(
)
{
self
.
breaks_and_continues
[
i
]
=
self
.
breaks_and_continues
[
j
]
;
i
+
=
1
;
}
j
+
=
1
;
}
self
.
breaks_and_continues
.
truncate
(
i
)
}
pub
fn
pop_unlabelled_breaks_from
(
&
mut
self
offset
:
usize
)
{
let
len
=
self
.
breaks_and_continues
.
len
(
)
;
let
index
=
self
.
find_first_break_or_continue
(
offset
)
;
let
mut
i
=
index
.
index
;
while
i
<
len
&
&
self
.
breaks_and_continues
[
i
]
.
label
.
is_some
(
)
{
i
+
=
1
;
}
let
mut
j
=
i
;
while
j
<
len
{
if
self
.
breaks_and_continues
[
j
]
.
label
.
is_some
(
)
|
|
self
.
breaks_and_continues
[
j
]
.
kind
=
=
ControlKind
:
:
Continue
{
self
.
breaks_and_continues
[
i
]
=
self
.
breaks_and_continues
[
j
]
;
i
+
=
1
;
}
j
+
=
1
;
}
self
.
breaks_and_continues
.
truncate
(
i
)
}
pub
fn
find_break_or_continue_at
(
&
self
index
:
BreakOrContinueIndex
)
-
>
Option
<
&
ControlInfo
>
{
self
.
breaks_and_continues
.
get
(
index
.
index
)
}
}
