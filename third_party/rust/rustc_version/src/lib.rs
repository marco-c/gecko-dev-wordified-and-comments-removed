#
!
[
warn
(
missing_docs
)
]
#
[
cfg
(
test
)
]
#
[
macro_use
]
extern
crate
doc_comment
;
#
[
cfg
(
test
)
]
doctest
!
(
"
.
.
/
README
.
md
"
)
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
process
:
:
Command
;
use
std
:
:
{
env
error
fmt
io
num
str
}
;
use
std
:
:
{
ffi
:
:
OsString
str
:
:
FromStr
}
;
pub
use
semver
:
:
Version
;
use
Error
:
:
*
;
#
[
derive
(
Copy
Clone
Eq
PartialEq
Ord
PartialOrd
Hash
Debug
)
]
pub
enum
Channel
{
Dev
Nightly
Beta
Stable
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
pub
struct
LlvmVersion
{
pub
major
:
u64
pub
minor
:
u64
}
impl
fmt
:
:
Display
for
LlvmVersion
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
.
{
}
"
self
.
major
self
.
minor
)
}
}
impl
FromStr
for
LlvmVersion
{
type
Err
=
LlvmVersionParseError
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
let
mut
parts
=
s
.
split
(
'
.
'
)
.
map
(
|
part
|
-
>
Result
<
u64
LlvmVersionParseError
>
{
if
part
=
=
"
0
"
{
Ok
(
0
)
}
else
if
part
.
starts_with
(
'
0
'
)
{
Err
(
LlvmVersionParseError
:
:
ComponentMustNotHaveLeadingZeros
)
}
else
if
part
.
starts_with
(
'
-
'
)
|
|
part
.
starts_with
(
'
+
'
)
{
Err
(
LlvmVersionParseError
:
:
ComponentMustNotHaveSign
)
}
else
{
Ok
(
part
.
parse
(
)
?
)
}
}
)
;
let
major
=
parts
.
next
(
)
.
unwrap
(
)
?
;
let
mut
minor
=
0
;
if
let
Some
(
part
)
=
parts
.
next
(
)
{
minor
=
part
?
;
}
else
if
major
<
4
{
return
Err
(
LlvmVersionParseError
:
:
MinorVersionRequiredBefore4
)
;
}
if
let
Some
(
Err
(
e
)
)
=
parts
.
next
(
)
{
return
Err
(
e
)
;
}
if
parts
.
next
(
)
.
is_some
(
)
{
return
Err
(
LlvmVersionParseError
:
:
TooManyComponents
)
;
}
Ok
(
Self
{
major
minor
}
)
}
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
pub
struct
VersionMeta
{
pub
semver
:
Version
pub
commit_hash
:
Option
<
String
>
pub
commit_date
:
Option
<
String
>
pub
build_date
:
Option
<
String
>
pub
channel
:
Channel
pub
host
:
String
pub
short_version_string
:
String
pub
llvm_version
:
Option
<
LlvmVersion
>
}
impl
VersionMeta
{
pub
fn
for_command
(
mut
cmd
:
Command
)
-
>
Result
<
VersionMeta
>
{
let
out
=
cmd
.
arg
(
"
-
vV
"
)
.
output
(
)
.
map_err
(
Error
:
:
CouldNotExecuteCommand
)
?
;
if
!
out
.
status
.
success
(
)
{
return
Err
(
Error
:
:
CommandError
{
stdout
:
String
:
:
from_utf8_lossy
(
&
out
.
stdout
)
.
into
(
)
stderr
:
String
:
:
from_utf8_lossy
(
&
out
.
stderr
)
.
into
(
)
}
)
;
}
version_meta_for
(
str
:
:
from_utf8
(
&
out
.
stdout
)
?
)
}
}
pub
fn
version
(
)
-
>
Result
<
Version
>
{
Ok
(
version_meta
(
)
?
.
semver
)
}
pub
fn
version_meta
(
)
-
>
Result
<
VersionMeta
>
{
let
cmd
=
env
:
:
var_os
(
"
RUSTC
"
)
.
unwrap_or_else
(
|
|
OsString
:
:
from
(
"
rustc
"
)
)
;
VersionMeta
:
:
for_command
(
Command
:
:
new
(
cmd
)
)
}
pub
fn
version_meta_for
(
verbose_version_string
:
&
str
)
-
>
Result
<
VersionMeta
>
{
let
mut
map
=
HashMap
:
:
new
(
)
;
for
(
i
line
)
in
verbose_version_string
.
lines
(
)
.
enumerate
(
)
{
if
i
=
=
0
{
map
.
insert
(
"
short
"
line
)
;
continue
;
}
let
mut
parts
=
line
.
splitn
(
2
"
:
"
)
;
let
key
=
match
parts
.
next
(
)
{
Some
(
key
)
=
>
key
None
=
>
continue
}
;
if
let
Some
(
value
)
=
parts
.
next
(
)
{
map
.
insert
(
key
value
)
;
}
}
let
short_version_string
=
expect_key
(
"
short
"
&
map
)
?
;
let
host
=
expect_key
(
"
host
"
&
map
)
?
;
let
release
=
expect_key
(
"
release
"
&
map
)
?
;
let
semver
:
Version
=
release
.
parse
(
)
?
;
let
channel
=
match
semver
.
pre
.
split
(
'
.
'
)
.
next
(
)
.
unwrap
(
)
{
"
"
=
>
Channel
:
:
Stable
"
dev
"
=
>
Channel
:
:
Dev
"
beta
"
=
>
Channel
:
:
Beta
"
nightly
"
=
>
Channel
:
:
Nightly
x
=
>
return
Err
(
Error
:
:
UnknownPreReleaseTag
(
x
.
to_owned
(
)
)
)
}
;
let
commit_hash
=
expect_key_or_unknown
(
"
commit
-
hash
"
&
map
)
?
;
let
commit_date
=
expect_key_or_unknown
(
"
commit
-
date
"
&
map
)
?
;
let
build_date
=
map
.
get
(
"
build
-
date
"
)
.
filter
(
|
&
v
|
*
v
!
=
"
unknown
"
)
.
map
(
|
&
v
|
String
:
:
from
(
v
)
)
;
let
llvm_version
=
match
map
.
get
(
"
LLVM
version
"
)
{
Some
(
&
v
)
=
>
Some
(
v
.
parse
(
)
?
)
None
=
>
None
}
;
Ok
(
VersionMeta
{
semver
commit_hash
commit_date
build_date
channel
host
short_version_string
llvm_version
}
)
}
fn
expect_key_or_unknown
(
key
:
&
str
map
:
&
HashMap
<
&
str
&
str
>
)
-
>
Result
<
Option
<
String
>
Error
>
{
match
map
.
get
(
key
)
{
Some
(
&
v
)
if
v
=
=
"
unknown
"
=
>
Ok
(
None
)
Some
(
&
v
)
=
>
Ok
(
Some
(
String
:
:
from
(
v
)
)
)
None
=
>
Err
(
Error
:
:
UnexpectedVersionFormat
)
}
}
fn
expect_key
(
key
:
&
str
map
:
&
HashMap
<
&
str
&
str
>
)
-
>
Result
<
String
Error
>
{
map
.
get
(
key
)
.
map
(
|
&
v
|
String
:
:
from
(
v
)
)
.
ok_or
(
Error
:
:
UnexpectedVersionFormat
)
}
#
[
derive
(
Debug
)
]
pub
enum
LlvmVersionParseError
{
ParseIntError
(
num
:
:
ParseIntError
)
ComponentMustNotHaveLeadingZeros
ComponentMustNotHaveSign
MinorVersionMustBeZeroAfter4
MinorVersionRequiredBefore4
TooManyComponents
}
impl
From
<
num
:
:
ParseIntError
>
for
LlvmVersionParseError
{
fn
from
(
e
:
num
:
:
ParseIntError
)
-
>
Self
{
LlvmVersionParseError
:
:
ParseIntError
(
e
)
}
}
impl
fmt
:
:
Display
for
LlvmVersionParseError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
LlvmVersionParseError
:
:
ParseIntError
(
e
)
=
>
{
write
!
(
f
"
error
parsing
LLVM
version
component
:
{
}
"
e
)
}
LlvmVersionParseError
:
:
ComponentMustNotHaveLeadingZeros
=
>
{
write
!
(
f
"
a
version
component
must
not
have
leading
zeros
"
)
}
LlvmVersionParseError
:
:
ComponentMustNotHaveSign
=
>
{
write
!
(
f
"
a
version
component
must
not
have
a
sign
"
)
}
LlvmVersionParseError
:
:
MinorVersionMustBeZeroAfter4
=
>
write
!
(
f
"
LLVM
'
s
minor
version
component
must
be
0
for
versions
greater
than
4
.
0
"
)
LlvmVersionParseError
:
:
MinorVersionRequiredBefore4
=
>
write
!
(
f
"
LLVM
'
s
minor
version
component
is
required
for
versions
less
than
4
.
0
"
)
LlvmVersionParseError
:
:
TooManyComponents
=
>
write
!
(
f
"
too
many
version
components
"
)
}
}
}
impl
error
:
:
Error
for
LlvmVersionParseError
{
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
error
:
:
Error
+
'
static
)
>
{
match
self
{
LlvmVersionParseError
:
:
ParseIntError
(
e
)
=
>
Some
(
e
)
LlvmVersionParseError
:
:
ComponentMustNotHaveLeadingZeros
|
LlvmVersionParseError
:
:
ComponentMustNotHaveSign
|
LlvmVersionParseError
:
:
MinorVersionMustBeZeroAfter4
|
LlvmVersionParseError
:
:
MinorVersionRequiredBefore4
|
LlvmVersionParseError
:
:
TooManyComponents
=
>
None
}
}
}
#
[
derive
(
Debug
)
]
pub
enum
Error
{
CouldNotExecuteCommand
(
io
:
:
Error
)
CommandError
{
stdout
:
String
stderr
:
String
}
Utf8Error
(
str
:
:
Utf8Error
)
UnexpectedVersionFormat
SemVerError
(
semver
:
:
Error
)
UnknownPreReleaseTag
(
String
)
LlvmVersionError
(
LlvmVersionParseError
)
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
CouldNotExecuteCommand
(
ref
e
)
=
>
write
!
(
f
"
could
not
execute
command
:
{
}
"
e
)
CommandError
{
ref
stdout
ref
stderr
}
=
>
write
!
(
f
"
error
from
command
-
-
stderr
:
\
n
\
n
{
}
\
n
\
nstderr
:
\
n
\
n
{
}
"
stderr
stdout
)
Utf8Error
(
_
)
=
>
write
!
(
f
"
invalid
UTF
-
8
output
from
rustc
-
vV
"
)
UnexpectedVersionFormat
=
>
write
!
(
f
"
unexpected
rustc
-
vV
format
"
)
SemVerError
(
ref
e
)
=
>
write
!
(
f
"
error
parsing
version
:
{
}
"
e
)
UnknownPreReleaseTag
(
ref
i
)
=
>
write
!
(
f
"
unknown
pre
-
release
tag
:
{
}
"
i
)
LlvmVersionError
(
ref
e
)
=
>
write
!
(
f
"
error
parsing
LLVM
'
s
version
:
{
}
"
e
)
}
}
}
impl
error
:
:
Error
for
Error
{
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
error
:
:
Error
+
'
static
)
>
{
match
*
self
{
CouldNotExecuteCommand
(
ref
e
)
=
>
Some
(
e
)
CommandError
{
.
.
}
=
>
None
Utf8Error
(
ref
e
)
=
>
Some
(
e
)
UnexpectedVersionFormat
=
>
None
SemVerError
(
ref
e
)
=
>
Some
(
e
)
UnknownPreReleaseTag
(
_
)
=
>
None
LlvmVersionError
(
ref
e
)
=
>
Some
(
e
)
}
}
}
macro_rules
!
impl_from
{
(
(
err_ty
:
ty
=
>
variant
:
ident
)
*
(
)
*
)
=
>
{
(
impl
From
<
err_ty
>
for
Error
{
fn
from
(
e
:
err_ty
)
-
>
Error
{
Error
:
:
variant
(
e
)
}
}
)
*
}
}
impl_from
!
{
str
:
:
Utf8Error
=
>
Utf8Error
semver
:
:
Error
=
>
SemVerError
LlvmVersionParseError
=
>
LlvmVersionError
}
pub
type
Result
<
T
E
=
Error
>
=
std
:
:
result
:
:
Result
<
T
E
>
;
