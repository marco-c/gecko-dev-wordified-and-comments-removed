use
super
:
:
{
Input
FixedOutput
Reset
}
;
use
generic_array
:
:
{
GenericArray
ArrayLength
}
;
use
generic_array
:
:
typenum
:
:
Unsigned
;
pub
trait
Digest
{
type
OutputSize
:
ArrayLength
<
u8
>
;
fn
new
(
)
-
>
Self
;
fn
input
<
B
:
AsRef
<
[
u8
]
>
>
(
&
mut
self
data
:
B
)
;
fn
chain
<
B
:
AsRef
<
[
u8
]
>
>
(
self
data
:
B
)
-
>
Self
where
Self
:
Sized
;
fn
result
(
self
)
-
>
GenericArray
<
u8
Self
:
:
OutputSize
>
;
fn
result_reset
(
&
mut
self
)
-
>
GenericArray
<
u8
Self
:
:
OutputSize
>
;
fn
reset
(
&
mut
self
)
;
fn
output_size
(
)
-
>
usize
;
fn
digest
(
data
:
&
[
u8
]
)
-
>
GenericArray
<
u8
Self
:
:
OutputSize
>
;
}
impl
<
D
:
Input
+
FixedOutput
+
Reset
+
Clone
+
Default
>
Digest
for
D
{
type
OutputSize
=
<
Self
as
FixedOutput
>
:
:
OutputSize
;
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
fn
input
<
B
:
AsRef
<
[
u8
]
>
>
(
&
mut
self
data
:
B
)
{
Input
:
:
input
(
self
data
)
;
}
fn
chain
<
B
:
AsRef
<
[
u8
]
>
>
(
self
data
:
B
)
-
>
Self
where
Self
:
Sized
{
Input
:
:
chain
(
self
data
)
}
fn
result
(
self
)
-
>
GenericArray
<
u8
Self
:
:
OutputSize
>
{
self
.
fixed_result
(
)
}
fn
result_reset
(
&
mut
self
)
-
>
GenericArray
<
u8
Self
:
:
OutputSize
>
{
let
res
=
self
.
clone
(
)
.
fixed_result
(
)
;
self
.
reset
(
)
;
res
}
fn
reset
(
&
mut
self
)
{
<
Self
as
Reset
>
:
:
reset
(
self
)
}
fn
output_size
(
)
-
>
usize
{
Self
:
:
OutputSize
:
:
to_usize
(
)
}
fn
digest
(
data
:
&
[
u8
]
)
-
>
GenericArray
<
u8
Self
:
:
OutputSize
>
{
let
mut
hasher
=
Self
:
:
default
(
)
;
Input
:
:
input
(
&
mut
hasher
data
)
;
hasher
.
fixed_result
(
)
}
}
