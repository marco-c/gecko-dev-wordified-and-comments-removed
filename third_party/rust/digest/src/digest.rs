use
super
:
:
{
Input
BlockInput
FixedOutput
}
;
use
generic_array
:
:
GenericArray
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
io
;
type
Output
<
N
>
=
GenericArray
<
u8
N
>
;
pub
trait
Digest
:
Input
+
BlockInput
+
FixedOutput
+
Default
{
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
fn
input
(
&
mut
self
input
:
&
[
u8
]
)
{
self
.
process
(
input
)
;
}
fn
result
(
self
)
-
>
Output
<
Self
:
:
OutputSize
>
{
self
.
fixed_result
(
)
}
#
[
inline
]
fn
digest
(
data
:
&
[
u8
]
)
-
>
Output
<
Self
:
:
OutputSize
>
{
let
mut
hasher
=
Self
:
:
default
(
)
;
hasher
.
process
(
data
)
;
hasher
.
fixed_result
(
)
}
#
[
inline
]
fn
digest_str
(
str
:
&
str
)
-
>
Output
<
Self
:
:
OutputSize
>
{
Self
:
:
digest
(
str
.
as_bytes
(
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
inline
]
fn
digest_reader
(
source
:
&
mut
io
:
:
Read
)
-
>
io
:
:
Result
<
Output
<
Self
:
:
OutputSize
>
>
{
let
mut
hasher
=
Self
:
:
default
(
)
;
let
mut
buf
=
[
0u8
;
8
*
1024
]
;
loop
{
let
len
=
match
source
.
read
(
&
mut
buf
)
{
Ok
(
0
)
=
>
return
Ok
(
hasher
.
result
(
)
)
Ok
(
len
)
=
>
len
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
Interrupted
=
>
continue
Err
(
e
)
=
>
Err
(
e
)
?
}
;
hasher
.
process
(
&
buf
[
.
.
len
]
)
;
}
}
}
impl
<
D
:
Input
+
FixedOutput
+
BlockInput
+
Default
>
Digest
for
D
{
}
