use
super
:
:
client_data
:
:
ClientDataHash
;
use
super
:
:
commands
:
:
get_assertion
:
:
{
GetAssertion
GetAssertionOptions
}
;
use
super
:
:
commands
:
:
{
CommandError
PinUvAuthCommand
RequestCtap1
Retryable
StatusCode
}
;
use
crate
:
:
authenticatorservice
:
:
GetAssertionExtensions
;
use
crate
:
:
consts
:
:
{
PARAMETER_SIZE
U2F_AUTHENTICATE
U2F_CHECK_IS_REGISTERED
}
;
use
crate
:
:
crypto
:
:
PinUvAuthToken
;
use
crate
:
:
ctap2
:
:
server
:
:
{
PublicKeyCredentialDescriptor
RelyingPartyWrapper
}
;
use
crate
:
:
errors
:
:
AuthenticatorError
;
use
crate
:
:
transport
:
:
errors
:
:
{
ApduErrorStatus
HIDError
}
;
use
crate
:
:
transport
:
:
FidoDevice
;
use
crate
:
:
u2ftypes
:
:
CTAP1RequestAPDU
;
use
sha2
:
:
{
Digest
Sha256
}
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
CheckKeyHandle
<
'
assertion
>
{
pub
(
crate
)
key_handle
:
&
'
assertion
[
u8
]
pub
(
crate
)
client_data_hash
:
&
'
assertion
[
u8
]
pub
(
crate
)
rp
:
&
'
assertion
RelyingPartyWrapper
}
impl
<
'
assertion
>
RequestCtap1
for
CheckKeyHandle
<
'
assertion
>
{
type
Output
=
(
)
;
type
AdditionalInfo
=
(
)
;
fn
ctap1_format
(
&
self
)
-
>
Result
<
(
Vec
<
u8
>
Self
:
:
AdditionalInfo
)
HIDError
>
{
let
flags
=
U2F_CHECK_IS_REGISTERED
;
let
mut
auth_data
=
Vec
:
:
with_capacity
(
2
*
PARAMETER_SIZE
+
1
+
self
.
key_handle
.
len
(
)
)
;
auth_data
.
extend_from_slice
(
self
.
client_data_hash
)
;
auth_data
.
extend_from_slice
(
self
.
rp
.
hash
(
)
.
as_ref
(
)
)
;
auth_data
.
extend_from_slice
(
&
[
self
.
key_handle
.
len
(
)
as
u8
]
)
;
auth_data
.
extend_from_slice
(
self
.
key_handle
)
;
let
cmd
=
U2F_AUTHENTICATE
;
let
apdu
=
CTAP1RequestAPDU
:
:
serialize
(
cmd
flags
&
auth_data
)
?
;
Ok
(
(
apdu
(
)
)
)
}
fn
handle_response_ctap1
(
&
self
status
:
Result
<
(
)
ApduErrorStatus
>
_input
:
&
[
u8
]
_add_info
:
&
Self
:
:
AdditionalInfo
)
-
>
Result
<
Self
:
:
Output
Retryable
<
HIDError
>
>
{
match
status
{
Ok
(
_
)
|
Err
(
ApduErrorStatus
:
:
ConditionsNotSatisfied
)
=
>
Ok
(
(
)
)
Err
(
e
)
=
>
Err
(
Retryable
:
:
Error
(
HIDError
:
:
ApduStatus
(
e
)
)
)
}
}
}
pub
(
crate
)
fn
do_credential_list_filtering_ctap1
<
Dev
:
FidoDevice
>
(
dev
:
&
mut
Dev
cred_list
:
&
[
PublicKeyCredentialDescriptor
]
rp
:
&
RelyingPartyWrapper
client_data_hash
:
&
ClientDataHash
)
-
>
Option
<
PublicKeyCredentialDescriptor
>
{
let
key_handle
=
cred_list
.
iter
(
)
.
filter
(
|
key_handle
|
key_handle
.
id
.
len
(
)
<
256
)
.
find_map
(
|
key_handle
|
{
let
check_command
=
CheckKeyHandle
{
key_handle
:
key_handle
.
id
.
as_ref
(
)
client_data_hash
:
client_data_hash
.
as_ref
(
)
rp
}
;
let
res
=
dev
.
send_ctap1
(
&
check_command
)
;
match
res
{
Ok
(
_
)
=
>
Some
(
key_handle
.
clone
(
)
)
_
=
>
None
}
}
)
;
key_handle
}
pub
(
crate
)
fn
do_credential_list_filtering_ctap2
<
Dev
:
FidoDevice
>
(
dev
:
&
mut
Dev
cred_list
:
&
[
PublicKeyCredentialDescriptor
]
rp
:
&
RelyingPartyWrapper
pin_uv_auth_token
:
Option
<
PinUvAuthToken
>
)
-
>
Result
<
Vec
<
PublicKeyCredentialDescriptor
>
AuthenticatorError
>
{
let
info
=
dev
.
get_authenticator_info
(
)
.
ok_or
(
HIDError
:
:
DeviceNotInitialized
)
?
;
let
mut
cred_list
=
cred_list
.
to_vec
(
)
;
let
mut
chunk_size
=
match
info
.
max_credential_count_in_list
{
None
|
Some
(
0
)
=
>
1
Some
(
x
)
=
>
x
}
;
match
info
.
max_credential_id_length
{
None
=
>
{
}
Some
(
0
)
=
>
{
chunk_size
=
1
;
}
Some
(
max_key_length
)
=
>
{
cred_list
.
retain
(
|
k
|
k
.
id
.
len
(
)
<
=
max_key_length
)
;
}
}
if
cred_list
.
len
(
)
<
=
chunk_size
{
return
Ok
(
cred_list
)
;
}
let
chunked_list
=
cred_list
.
chunks
(
chunk_size
)
;
let
mut
final_list
=
Vec
:
:
new
(
)
;
for
chunk
in
chunked_list
{
let
mut
silent_assert
=
GetAssertion
:
:
new
(
ClientDataHash
(
Sha256
:
:
digest
(
"
"
)
.
into
(
)
)
rp
.
clone
(
)
chunk
.
to_vec
(
)
GetAssertionOptions
{
user_verification
:
if
pin_uv_auth_token
.
is_some
(
)
{
None
}
else
{
Some
(
false
)
}
user_presence
:
Some
(
false
)
}
GetAssertionExtensions
:
:
default
(
)
None
None
)
;
silent_assert
.
set_pin_uv_auth_param
(
pin_uv_auth_token
.
clone
(
)
)
?
;
let
res
=
dev
.
send_msg
(
&
silent_assert
)
;
match
res
{
Ok
(
response
)
=
>
{
let
credential_ids
=
response
.
0
.
iter
(
)
.
filter_map
(
|
a
|
a
.
credentials
.
clone
(
)
)
.
collect
(
)
;
final_list
=
credential_ids
;
break
;
}
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
NoCredentials
_
)
)
)
=
>
{
}
Err
(
e
)
=
>
{
return
Err
(
e
.
into
(
)
)
;
}
}
}
Ok
(
final_list
)
}
