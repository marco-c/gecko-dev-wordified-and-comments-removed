extern
crate
libc
;
use
std
:
:
io
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
io
:
:
Write
;
use
std
:
:
mem
;
use
consts
:
:
CID_BROADCAST
;
use
consts
:
:
HID_RPT_SIZE
;
use
platform
:
:
fd
:
:
Fd
;
use
platform
:
:
uhid
;
use
u2ftypes
:
:
U2FDevice
;
use
util
:
:
io_err
;
#
[
derive
(
Debug
)
]
pub
struct
Device
{
fd
:
Fd
cid
:
[
u8
;
4
]
}
impl
Device
{
pub
fn
new
(
fd
:
Fd
)
-
>
io
:
:
Result
<
Self
>
{
Ok
(
Self
{
fd
cid
:
CID_BROADCAST
}
)
}
pub
fn
is_u2f
(
&
mut
self
)
-
>
bool
{
if
!
uhid
:
:
is_u2f_device
(
&
self
.
fd
)
{
return
false
;
}
match
uhid
:
:
hid_set_raw
(
&
self
.
fd
true
)
{
Ok
(
_
)
=
>
(
)
Err
(
_
)
=
>
return
false
}
if
let
Err
(
_
)
=
self
.
ping
(
)
{
return
false
;
}
true
}
fn
ping
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
for
i
in
0
.
.
10
{
let
mut
buf
=
vec
!
[
0u8
;
1
+
HID_RPT_SIZE
]
;
buf
[
0
]
=
0
;
buf
[
1
]
=
0xff
;
buf
[
2
]
=
0xff
;
buf
[
3
]
=
0xff
;
buf
[
4
]
=
0xff
;
buf
[
5
]
=
0x81
;
buf
[
6
]
=
0
;
buf
[
7
]
=
1
;
self
.
write
(
&
buf
[
.
.
]
)
?
;
let
mut
pfd
:
libc
:
:
pollfd
=
unsafe
{
mem
:
:
zeroed
(
)
}
;
pfd
.
fd
=
self
.
fd
.
fileno
;
pfd
.
events
=
libc
:
:
POLLIN
;
let
nfds
=
unsafe
{
libc
:
:
poll
(
&
mut
pfd
1
100
)
}
;
if
nfds
=
=
-
1
{
return
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
;
}
if
nfds
=
=
0
{
debug
!
(
"
device
timeout
{
}
"
i
)
;
continue
;
}
self
.
read
(
&
mut
buf
[
.
.
]
)
?
;
return
Ok
(
(
)
)
;
}
Err
(
io_err
(
"
no
response
from
device
"
)
)
}
}
impl
PartialEq
for
Device
{
fn
eq
(
&
self
other
:
&
Device
)
-
>
bool
{
self
.
fd
=
=
other
.
fd
}
}
impl
Read
for
Device
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
let
bufp
=
buf
.
as_mut_ptr
(
)
as
*
mut
libc
:
:
c_void
;
let
nread
=
unsafe
{
libc
:
:
read
(
self
.
fd
.
fileno
bufp
buf
.
len
(
)
)
}
;
if
nread
=
=
-
1
{
return
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
;
}
Ok
(
nread
as
usize
)
}
}
impl
Write
for
Device
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
let
data
=
&
buf
[
1
.
.
]
;
let
data_ptr
=
data
.
as_ptr
(
)
as
*
const
libc
:
:
c_void
;
let
nwrit
=
unsafe
{
libc
:
:
write
(
self
.
fd
.
fileno
data_ptr
data
.
len
(
)
)
}
;
if
nwrit
=
=
-
1
{
return
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
;
}
Ok
(
nwrit
as
usize
+
1
)
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
impl
U2FDevice
for
Device
{
fn
get_cid
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
[
u8
;
4
]
{
&
self
.
cid
}
fn
set_cid
(
&
mut
self
cid
:
[
u8
;
4
]
)
{
self
.
cid
=
cid
;
}
}
