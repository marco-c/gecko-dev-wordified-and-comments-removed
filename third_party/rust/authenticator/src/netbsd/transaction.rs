use
runloop
:
:
RunLoop
;
use
util
:
:
OnceCallback
;
use
platform
:
:
fd
:
:
Fd
;
use
platform
:
:
monitor
:
:
Monitor
;
pub
struct
Transaction
{
thread
:
Option
<
RunLoop
>
}
impl
Transaction
{
pub
fn
new
<
F
T
>
(
timeout
:
u64
callback
:
OnceCallback
<
T
>
new_device_cb
:
F
)
-
>
Result
<
Self
:
:
Error
>
where
F
:
Fn
(
Fd
&
dyn
Fn
(
)
-
>
bool
)
+
Sync
+
Send
+
'
static
T
:
'
static
{
let
thread
=
RunLoop
:
:
new_with_timeout
(
move
|
alive
|
{
let
mut
monitor
=
Monitor
:
:
new
(
new_device_cb
)
;
try_or
!
(
monitor
.
run
(
alive
)
|
_
|
callback
.
call
(
Err
(
:
:
Error
:
:
Unknown
)
)
)
;
callback
.
call
(
Err
(
:
:
Error
:
:
NotAllowed
)
)
;
}
timeout
)
.
map_err
(
|
_
|
:
:
Error
:
:
Unknown
)
?
;
Ok
(
Self
{
thread
:
Some
(
thread
)
}
)
}
pub
fn
cancel
(
&
mut
self
)
{
self
.
thread
.
take
(
)
.
unwrap
(
)
.
cancel
(
)
;
}
}
