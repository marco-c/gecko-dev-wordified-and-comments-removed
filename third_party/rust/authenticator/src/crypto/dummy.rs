use
super
:
:
{
ByteBuf
COSEKey
ECDHSecret
ECDSACurve
}
;
use
serde
:
:
Serialize
;
pub
type
Result
<
T
>
=
std
:
:
result
:
:
Result
<
T
BackendError
>
;
#
[
derive
(
Clone
Debug
PartialEq
Serialize
)
]
pub
enum
BackendError
{
}
pub
(
crate
)
fn
serialize_key
(
_curve
:
ECDSACurve
key
:
&
[
u8
]
)
-
>
Result
<
(
ByteBuf
ByteBuf
)
>
{
let
length
=
key
[
1
.
.
]
.
len
(
)
/
2
;
let
chunks
:
Vec
<
_
>
=
key
[
1
.
.
]
.
chunks_exact
(
length
)
.
collect
(
)
;
Ok
(
(
ByteBuf
:
:
from
(
chunks
[
0
]
.
to_vec
(
)
)
ByteBuf
:
:
from
(
chunks
[
1
]
.
to_vec
(
)
)
)
)
}
pub
(
crate
)
fn
encapsulate
(
_key
:
&
COSEKey
)
-
>
Result
<
ECDHSecret
>
{
unimplemented
!
(
)
}
pub
(
crate
)
fn
encrypt
(
_key
:
&
[
u8
]
_plain_text
:
&
[
u8
]
)
-
>
Result
<
Vec
<
u8
>
>
{
unimplemented
!
(
)
}
pub
(
crate
)
fn
decrypt
(
_key
:
&
[
u8
]
_cypher_text
:
&
[
u8
]
)
-
>
Result
<
Vec
<
u8
>
>
{
unimplemented
!
(
)
}
pub
(
crate
)
fn
authenticate
(
_token
:
&
[
u8
]
_input
:
&
[
u8
]
)
-
>
Result
<
Vec
<
u8
>
>
{
unimplemented
!
(
)
}
