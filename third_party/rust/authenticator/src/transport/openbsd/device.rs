extern
crate
libc
;
use
std
:
:
ffi
:
:
OsString
;
use
std
:
:
io
;
use
std
:
:
io
:
:
{
Read
Result
Write
}
;
use
std
:
:
mem
;
use
crate
:
:
consts
:
:
{
CID_BROADCAST
MAX_HID_RPT_SIZE
}
;
use
crate
:
:
transport
:
:
platform
:
:
monitor
:
:
FidoDev
;
use
crate
:
:
u2ftypes
:
:
{
U2FDevice
U2FDeviceInfo
}
;
use
crate
:
:
util
:
:
{
from_unix_result
io_err
}
;
#
[
derive
(
Debug
)
]
pub
struct
Device
{
path
:
OsString
fd
:
libc
:
:
c_int
cid
:
[
u8
;
4
]
out_len
:
usize
dev_info
:
Option
<
U2FDeviceInfo
>
}
impl
Device
{
pub
fn
new
(
fido
:
FidoDev
)
-
>
Result
<
Self
>
{
debug
!
(
"
device
found
:
{
:
?
}
"
fido
)
;
Ok
(
Self
{
path
:
fido
.
os_path
fd
:
fido
.
fd
cid
:
CID_BROADCAST
out_len
:
64
dev_info
:
None
}
)
}
pub
fn
is_u2f
(
&
mut
self
)
-
>
bool
{
debug
!
(
"
device
{
:
?
}
is
U2F
/
FIDO
"
self
.
path
)
;
match
self
.
ping
(
)
{
Ok
(
_
)
=
>
true
Err
(
err
)
=
>
{
debug
!
(
"
device
{
:
?
}
is
not
responding
:
{
}
"
self
.
path
err
)
;
false
}
}
}
fn
ping
(
&
mut
self
)
-
>
Result
<
(
)
>
{
let
capacity
=
256
;
for
_
in
0
.
.
10
{
let
mut
data
=
vec
!
[
0u8
;
capacity
]
;
self
.
write_all
(
&
[
0
0xff
0xff
0xff
0xff
0x81
0
1
]
)
?
;
let
mut
pfd
:
libc
:
:
pollfd
=
unsafe
{
mem
:
:
zeroed
(
)
}
;
pfd
.
fd
=
self
.
fd
;
pfd
.
events
=
libc
:
:
POLLIN
;
if
from_unix_result
(
unsafe
{
libc
:
:
poll
(
&
mut
pfd
1
100
)
}
)
?
=
=
0
{
debug
!
(
"
device
{
:
?
}
timeout
"
self
.
path
)
;
continue
;
}
self
.
read
(
&
mut
data
[
.
.
]
)
?
;
return
Ok
(
(
)
)
;
}
Err
(
io_err
(
"
no
response
from
device
"
)
)
}
}
impl
Drop
for
Device
{
fn
drop
(
&
mut
self
)
{
let
_
=
unsafe
{
libc
:
:
close
(
self
.
fd
)
}
;
debug
!
(
"
device
{
:
?
}
closed
"
self
.
path
)
;
}
}
impl
PartialEq
for
Device
{
fn
eq
(
&
self
other
:
&
Device
)
-
>
bool
{
self
.
path
=
=
other
.
path
}
}
impl
Read
for
Device
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
Result
<
usize
>
{
let
buf_ptr
=
buf
.
as_mut_ptr
(
)
as
*
mut
libc
:
:
c_void
;
let
rv
=
unsafe
{
libc
:
:
read
(
self
.
fd
buf_ptr
buf
.
len
(
)
)
}
;
from_unix_result
(
rv
as
usize
)
}
}
impl
Write
for
Device
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
Result
<
usize
>
{
let
data
=
&
buf
[
1
.
.
]
;
let
data_ptr
=
data
.
as_ptr
(
)
as
*
const
libc
:
:
c_void
;
let
rv
=
unsafe
{
libc
:
:
write
(
self
.
fd
data_ptr
data
.
len
(
)
)
}
;
Ok
(
from_unix_result
(
rv
as
usize
)
?
+
1
)
}
fn
flush
(
&
mut
self
)
-
>
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
impl
U2FDevice
for
Device
{
fn
get_cid
(
&
self
)
-
>
&
[
u8
;
4
]
{
&
self
.
cid
}
fn
set_cid
(
&
mut
self
cid
:
[
u8
;
4
]
)
{
self
.
cid
=
cid
;
}
fn
in_rpt_size
(
&
self
)
-
>
usize
{
MAX_HID_RPT_SIZE
}
fn
out_rpt_size
(
&
self
)
-
>
usize
{
MAX_HID_RPT_SIZE
}
fn
get_property
(
&
self
_prop_name
:
&
str
)
-
>
io
:
:
Result
<
String
>
{
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
Not
implemented
"
)
)
}
fn
get_device_info
(
&
self
)
-
>
U2FDeviceInfo
{
self
.
dev_info
.
clone
(
)
.
unwrap
(
)
}
fn
set_device_info
(
&
mut
self
dev_info
:
U2FDeviceInfo
)
{
self
.
dev_info
=
Some
(
dev_info
)
;
}
}
