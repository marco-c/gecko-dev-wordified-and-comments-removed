use
crate
:
:
consts
:
:
{
Capability
HIDCmd
}
;
use
crate
:
:
crypto
:
:
{
PinUvAuthProtocol
PinUvAuthToken
SharedSecret
}
;
use
crate
:
:
ctap2
:
:
commands
:
:
client_pin
:
:
{
GetKeyAgreement
GetPinToken
GetPinUvAuthTokenUsingPinWithPermissions
GetPinUvAuthTokenUsingUvWithPermissions
PinUvAuthTokenPermission
}
;
use
crate
:
:
ctap2
:
:
commands
:
:
get_info
:
:
{
AuthenticatorVersion
GetInfo
}
;
use
crate
:
:
ctap2
:
:
commands
:
:
get_version
:
:
GetVersion
;
use
crate
:
:
ctap2
:
:
commands
:
:
make_credentials
:
:
dummy_make_credentials_cmd
;
use
crate
:
:
ctap2
:
:
commands
:
:
selection
:
:
Selection
;
use
crate
:
:
ctap2
:
:
commands
:
:
{
CommandError
Request
RequestCtap1
RequestCtap2
Retryable
StatusCode
}
;
use
crate
:
:
transport
:
:
device_selector
:
:
BlinkResult
;
use
crate
:
:
transport
:
:
errors
:
:
{
ApduErrorStatus
HIDError
}
;
use
crate
:
:
transport
:
:
hid
:
:
HIDDevice
;
use
crate
:
:
util
:
:
io_err
;
use
crate
:
:
Pin
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
thread
;
use
std
:
:
time
:
:
Duration
;
pub
mod
device_selector
;
pub
mod
errors
;
pub
mod
hid
;
#
[
cfg
(
all
(
any
(
target_os
=
"
linux
"
target_os
=
"
freebsd
"
target_os
=
"
netbsd
"
)
not
(
test
)
)
)
]
pub
mod
hidproto
;
#
[
cfg
(
all
(
target_os
=
"
linux
"
not
(
test
)
)
)
]
#
[
path
=
"
linux
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
all
(
target_os
=
"
freebsd
"
not
(
test
)
)
)
]
#
[
path
=
"
freebsd
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
all
(
target_os
=
"
netbsd
"
not
(
test
)
)
)
]
#
[
path
=
"
netbsd
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
all
(
target_os
=
"
openbsd
"
not
(
test
)
)
)
]
#
[
path
=
"
openbsd
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
all
(
target_os
=
"
macos
"
not
(
test
)
)
)
]
#
[
path
=
"
macos
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
all
(
target_os
=
"
windows
"
not
(
test
)
)
)
]
#
[
path
=
"
windows
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
not
(
any
(
target_os
=
"
linux
"
target_os
=
"
freebsd
"
target_os
=
"
openbsd
"
target_os
=
"
netbsd
"
target_os
=
"
macos
"
target_os
=
"
windows
"
test
)
)
)
]
#
[
path
=
"
stub
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
test
)
]
#
[
path
=
"
mock
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
derive
(
Debug
)
]
pub
enum
Nonce
{
CreateRandom
Use
(
[
u8
;
8
]
)
}
pub
trait
FidoDevice
:
HIDDevice
{
fn
send_msg
<
Out
Req
:
Request
<
Out
>
>
(
&
mut
self
msg
:
&
Req
)
-
>
Result
<
Out
HIDError
>
{
self
.
send_msg_cancellable
(
msg
&
|
|
true
)
}
fn
send_cbor
<
Req
:
RequestCtap2
>
(
&
mut
self
msg
:
&
Req
)
-
>
Result
<
Req
:
:
Output
HIDError
>
{
self
.
send_cbor_cancellable
(
msg
&
|
|
true
)
}
fn
send_ctap1
<
Req
:
RequestCtap1
>
(
&
mut
self
msg
:
&
Req
)
-
>
Result
<
Req
:
:
Output
HIDError
>
{
self
.
send_ctap1_cancellable
(
msg
&
|
|
true
)
}
fn
send_msg_cancellable
<
Out
Req
:
Request
<
Out
>
>
(
&
mut
self
msg
:
&
Req
keep_alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
Result
<
Out
HIDError
>
{
if
!
self
.
initialized
(
)
{
return
Err
(
HIDError
:
:
DeviceNotInitialized
)
;
}
if
self
.
get_authenticator_info
(
)
.
is_some
(
)
{
self
.
send_cbor_cancellable
(
msg
keep_alive
)
}
else
{
self
.
send_ctap1_cancellable
(
msg
keep_alive
)
}
}
fn
send_cbor_cancellable
<
Req
:
RequestCtap2
>
(
&
mut
self
msg
:
&
Req
keep_alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
Result
<
Req
:
:
Output
HIDError
>
{
debug
!
(
"
sending
{
:
?
}
to
{
:
?
}
"
msg
self
)
;
let
mut
data
=
msg
.
wire_format
(
)
?
;
let
mut
buf
:
Vec
<
u8
>
=
Vec
:
:
with_capacity
(
data
.
len
(
)
+
1
)
;
buf
.
push
(
Req
:
:
command
(
)
as
u8
)
;
buf
.
append
(
&
mut
data
)
;
let
buf
=
buf
;
let
(
cmd
resp
)
=
self
.
sendrecv
(
HIDCmd
:
:
Cbor
&
buf
keep_alive
)
?
;
debug
!
(
"
got
from
Device
{
:
?
}
status
=
{
:
?
}
:
{
:
?
}
"
self
.
id
(
)
cmd
resp
)
;
if
cmd
=
=
HIDCmd
:
:
Cbor
{
Ok
(
msg
.
handle_response_ctap2
(
self
&
resp
)
?
)
}
else
{
Err
(
HIDError
:
:
UnexpectedCmd
(
cmd
.
into
(
)
)
)
}
}
fn
send_ctap1_cancellable
<
Req
:
RequestCtap1
>
(
&
mut
self
msg
:
&
Req
keep_alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
Result
<
Req
:
:
Output
HIDError
>
{
debug
!
(
"
sending
{
:
?
}
to
{
:
?
}
"
msg
self
)
;
let
(
data
add_info
)
=
msg
.
ctap1_format
(
)
?
;
while
keep_alive
(
)
{
let
(
cmd
mut
data
)
=
self
.
sendrecv
(
HIDCmd
:
:
Msg
&
data
&
|
|
true
)
?
;
debug
!
(
"
got
from
Device
{
:
?
}
status
=
{
:
?
}
:
{
:
?
}
"
self
.
id
(
)
cmd
data
)
;
if
cmd
=
=
HIDCmd
:
:
Msg
{
if
data
.
len
(
)
<
2
{
return
Err
(
io_err
(
"
Unexpected
Response
:
shorter
than
expected
"
)
.
into
(
)
)
;
}
let
split_at
=
data
.
len
(
)
-
2
;
let
status
=
data
.
split_off
(
split_at
)
;
let
status
=
ApduErrorStatus
:
:
from
(
[
status
[
0
]
status
[
1
]
]
)
;
match
msg
.
handle_response_ctap1
(
status
&
data
&
add_info
)
{
Ok
(
out
)
=
>
return
Ok
(
out
)
Err
(
Retryable
:
:
Retry
)
=
>
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
100
)
)
;
}
Err
(
Retryable
:
:
Error
(
e
)
)
=
>
return
Err
(
e
)
}
}
else
{
return
Err
(
HIDError
:
:
UnexpectedCmd
(
cmd
.
into
(
)
)
)
;
}
}
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
KeepaliveCancel
None
)
)
)
}
fn
init
(
&
mut
self
nonce
:
Nonce
)
-
>
Result
<
(
)
HIDError
>
{
<
Self
as
HIDDevice
>
:
:
initialize
(
self
nonce
)
?
;
if
self
.
get_device_info
(
)
.
cap_flags
.
contains
(
Capability
:
:
CBOR
)
{
let
command
=
GetInfo
:
:
default
(
)
;
if
let
Ok
(
info
)
=
self
.
send_cbor
(
&
command
)
{
debug
!
(
"
{
:
?
}
:
{
:
?
}
"
self
.
id
(
)
info
)
;
if
info
.
max_supported_version
(
)
!
=
AuthenticatorVersion
:
:
U2F_V2
{
self
.
set_authenticator_info
(
info
)
;
return
Ok
(
(
)
)
;
}
}
}
let
command
=
GetVersion
:
:
default
(
)
;
self
.
send_ctap1
(
&
command
)
?
;
Ok
(
(
)
)
}
fn
block_and_blink
(
&
mut
self
keep_alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
BlinkResult
{
let
supports_select_cmd
=
self
.
get_authenticator_info
(
)
.
map_or
(
false
|
i
|
{
i
.
versions
.
contains
(
&
AuthenticatorVersion
:
:
FIDO_2_1
)
}
)
;
let
resp
=
if
supports_select_cmd
{
let
msg
=
Selection
{
}
;
self
.
send_cbor_cancellable
(
&
msg
keep_alive
)
}
else
{
let
msg
=
dummy_make_credentials_cmd
(
)
;
info
!
(
"
Trying
to
blink
:
{
:
?
}
"
&
msg
)
;
self
.
send_msg_cancellable
(
&
msg
keep_alive
)
.
map
(
|
_
|
(
)
)
}
;
match
resp
{
Ok
(
_
)
|
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
PinInvalid
_
)
)
)
|
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
PinAuthInvalid
_
)
)
)
|
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
PinNotSet
_
)
)
)
=
>
{
BlinkResult
:
:
DeviceSelected
}
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
KeepaliveCancel
_
)
)
)
|
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
OperationDenied
_
)
)
)
|
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
UserActionTimeout
_
)
)
)
=
>
{
debug
!
(
"
Device
{
:
?
}
got
cancelled
"
&
self
)
;
BlinkResult
:
:
Cancelled
}
e
=
>
{
info
!
(
"
Device
{
:
?
}
received
unexpected
answer
so
we
assume
an
error
occurred
and
we
are
NOT
using
this
device
(
assuming
the
request
was
cancelled
)
:
{
:
?
}
"
&
self
e
)
;
BlinkResult
:
:
Cancelled
}
}
}
fn
establish_shared_secret
(
&
mut
self
)
-
>
Result
<
SharedSecret
HIDError
>
{
let
info
=
match
self
.
get_authenticator_info
(
)
{
Some
(
info
)
=
>
info
None
=
>
return
Err
(
HIDError
:
:
UnsupportedCommand
)
}
;
let
pin_protocol
=
PinUvAuthProtocol
:
:
try_from
(
info
)
?
;
let
pin_command
=
GetKeyAgreement
:
:
new
(
pin_protocol
)
;
let
device_key_agreement
=
self
.
send_cbor
(
&
pin_command
)
?
;
let
shared_secret
=
device_key_agreement
.
shared_secret
(
)
?
;
self
.
set_shared_secret
(
shared_secret
.
clone
(
)
)
;
Ok
(
shared_secret
)
}
fn
get_pin_token
(
&
mut
self
pin
:
&
Option
<
Pin
>
)
-
>
Result
<
PinUvAuthToken
HIDError
>
{
let
pin
=
pin
.
as_ref
(
)
.
ok_or
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
PinRequired
None
)
)
?
;
let
shared_secret
=
self
.
establish_shared_secret
(
)
?
;
let
pin_command
=
GetPinToken
:
:
new
(
&
shared_secret
pin
)
;
let
pin_token
=
self
.
send_cbor
(
&
pin_command
)
?
;
Ok
(
pin_token
)
}
fn
get_pin_uv_auth_token_using_uv_with_permissions
(
&
mut
self
permission
:
PinUvAuthTokenPermission
rp_id
:
Option
<
&
String
>
)
-
>
Result
<
PinUvAuthToken
HIDError
>
{
let
shared_secret
=
self
.
establish_shared_secret
(
)
?
;
let
pin_command
=
GetPinUvAuthTokenUsingUvWithPermissions
:
:
new
(
&
shared_secret
permission
rp_id
.
cloned
(
)
)
;
let
pin_auth_token
=
self
.
send_cbor
(
&
pin_command
)
?
;
Ok
(
pin_auth_token
)
}
fn
get_pin_uv_auth_token_using_pin_with_permissions
(
&
mut
self
pin
:
&
Option
<
Pin
>
permission
:
PinUvAuthTokenPermission
rp_id
:
Option
<
&
String
>
)
-
>
Result
<
PinUvAuthToken
HIDError
>
{
let
pin
=
pin
.
as_ref
(
)
.
ok_or
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
PinRequired
None
)
)
?
;
let
shared_secret
=
self
.
establish_shared_secret
(
)
?
;
let
pin_command
=
GetPinUvAuthTokenUsingPinWithPermissions
:
:
new
(
&
shared_secret
pin
permission
rp_id
.
cloned
(
)
)
;
let
pin_auth_token
=
self
.
send_cbor
(
&
pin_command
)
?
;
Ok
(
pin_auth_token
)
}
}
