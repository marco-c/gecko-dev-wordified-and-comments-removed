use
crate
:
:
crypto
:
:
{
PinUvAuthProtocol
PinUvAuthToken
SharedSecret
}
;
use
crate
:
:
ctap2
:
:
commands
:
:
client_pin
:
:
{
ClientPIN
ClientPinResponse
GetKeyAgreement
GetPinToken
GetPinUvAuthTokenUsingPinWithPermissions
GetPinUvAuthTokenUsingUvWithPermissions
PinUvAuthTokenPermission
}
;
use
crate
:
:
ctap2
:
:
commands
:
:
get_assertion
:
:
{
GetAssertion
GetAssertionResult
}
;
use
crate
:
:
ctap2
:
:
commands
:
:
get_info
:
:
{
AuthenticatorInfo
AuthenticatorVersion
GetInfo
}
;
use
crate
:
:
ctap2
:
:
commands
:
:
get_version
:
:
{
GetVersion
U2FInfo
}
;
use
crate
:
:
ctap2
:
:
commands
:
:
make_credentials
:
:
{
dummy_make_credentials_cmd
MakeCredentials
MakeCredentialsResult
}
;
use
crate
:
:
ctap2
:
:
commands
:
:
reset
:
:
Reset
;
use
crate
:
:
ctap2
:
:
commands
:
:
selection
:
:
Selection
;
use
crate
:
:
ctap2
:
:
commands
:
:
{
CommandError
RequestCtap1
RequestCtap2
StatusCode
}
;
use
crate
:
:
ctap2
:
:
preflight
:
:
CheckKeyHandle
;
use
crate
:
:
transport
:
:
device_selector
:
:
BlinkResult
;
use
crate
:
:
transport
:
:
errors
:
:
HIDError
;
use
crate
:
:
Pin
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
fmt
;
pub
mod
device_selector
;
pub
mod
errors
;
pub
mod
hid
;
#
[
cfg
(
all
(
any
(
target_os
=
"
linux
"
target_os
=
"
freebsd
"
target_os
=
"
netbsd
"
)
not
(
test
)
)
)
]
pub
mod
hidproto
;
#
[
cfg
(
all
(
target_os
=
"
linux
"
not
(
test
)
)
)
]
#
[
path
=
"
linux
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
all
(
target_os
=
"
freebsd
"
not
(
test
)
)
)
]
#
[
path
=
"
freebsd
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
all
(
target_os
=
"
netbsd
"
not
(
test
)
)
)
]
#
[
path
=
"
netbsd
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
all
(
target_os
=
"
openbsd
"
not
(
test
)
)
)
]
#
[
path
=
"
openbsd
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
all
(
target_os
=
"
macos
"
not
(
test
)
)
)
]
#
[
path
=
"
macos
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
all
(
target_os
=
"
windows
"
not
(
test
)
)
)
]
#
[
path
=
"
windows
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
not
(
any
(
target_os
=
"
linux
"
target_os
=
"
freebsd
"
target_os
=
"
openbsd
"
target_os
=
"
netbsd
"
target_os
=
"
macos
"
target_os
=
"
windows
"
test
)
)
)
]
#
[
path
=
"
stub
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
cfg
(
test
)
]
#
[
path
=
"
mock
/
mod
.
rs
"
]
pub
mod
platform
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
FidoProtocol
{
CTAP1
CTAP2
}
pub
trait
FidoDeviceIO
{
fn
send_msg
<
Out
Req
:
RequestCtap1
<
Output
=
Out
>
+
RequestCtap2
<
Output
=
Out
>
>
(
&
mut
self
msg
:
&
Req
)
-
>
Result
<
Out
HIDError
>
{
self
.
send_msg_cancellable
(
msg
&
|
|
true
)
}
fn
send_cbor
<
Req
:
RequestCtap2
>
(
&
mut
self
msg
:
&
Req
)
-
>
Result
<
Req
:
:
Output
HIDError
>
{
self
.
send_cbor_cancellable
(
msg
&
|
|
true
)
}
fn
send_ctap1
<
Req
:
RequestCtap1
>
(
&
mut
self
msg
:
&
Req
)
-
>
Result
<
Req
:
:
Output
HIDError
>
{
self
.
send_ctap1_cancellable
(
msg
&
|
|
true
)
}
fn
send_msg_cancellable
<
Out
Req
:
RequestCtap1
<
Output
=
Out
>
+
RequestCtap2
<
Output
=
Out
>
>
(
&
mut
self
msg
:
&
Req
keep_alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
Result
<
Out
HIDError
>
;
fn
send_cbor_cancellable
<
Req
:
RequestCtap2
>
(
&
mut
self
msg
:
&
Req
keep_alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
Result
<
Req
:
:
Output
HIDError
>
;
fn
send_ctap1_cancellable
<
Req
:
RequestCtap1
>
(
&
mut
self
msg
:
&
Req
keep_alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
Result
<
Req
:
:
Output
HIDError
>
;
}
pub
trait
FidoDevice
:
FidoDeviceIO
where
Self
:
Sized
Self
:
fmt
:
:
Debug
{
fn
pre_init
(
&
mut
self
)
-
>
Result
<
(
)
HIDError
>
;
fn
initialized
(
&
self
)
-
>
bool
;
fn
is_u2f
(
&
mut
self
)
-
>
bool
;
fn
should_try_ctap2
(
&
self
)
-
>
bool
;
fn
get_authenticator_info
(
&
self
)
-
>
Option
<
&
AuthenticatorInfo
>
;
fn
set_authenticator_info
(
&
mut
self
authenticator_info
:
AuthenticatorInfo
)
;
fn
refresh_authenticator_info
(
&
mut
self
)
-
>
Option
<
&
AuthenticatorInfo
>
{
let
command
=
GetInfo
:
:
default
(
)
;
if
let
Ok
(
info
)
=
self
.
send_cbor
(
&
command
)
{
debug
!
(
"
Refreshed
authenticator
info
:
{
:
?
}
"
info
)
;
self
.
set_authenticator_info
(
info
)
;
}
self
.
get_authenticator_info
(
)
}
fn
get_protocol
(
&
self
)
-
>
FidoProtocol
;
fn
downgrade_to_ctap1
(
&
mut
self
)
;
fn
get_shared_secret
(
&
self
)
-
>
Option
<
&
SharedSecret
>
;
fn
set_shared_secret
(
&
mut
self
secret
:
SharedSecret
)
;
fn
init
(
&
mut
self
)
-
>
Result
<
(
)
HIDError
>
{
self
.
pre_init
(
)
?
;
if
self
.
should_try_ctap2
(
)
{
let
command
=
GetInfo
:
:
default
(
)
;
if
let
Ok
(
info
)
=
self
.
send_cbor
(
&
command
)
{
debug
!
(
"
{
:
?
}
"
info
)
;
if
info
.
max_supported_version
(
)
=
=
AuthenticatorVersion
:
:
U2F_V2
{
self
.
downgrade_to_ctap1
(
)
;
}
self
.
set_authenticator_info
(
info
)
;
return
Ok
(
(
)
)
;
}
}
self
.
downgrade_to_ctap1
(
)
;
let
command
=
GetVersion
:
:
default
(
)
;
self
.
send_ctap1
(
&
command
)
?
;
Ok
(
(
)
)
}
fn
block_and_blink
(
&
mut
self
keep_alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
BlinkResult
{
let
supports_select_cmd
=
self
.
get_protocol
(
)
=
=
FidoProtocol
:
:
CTAP2
&
&
self
.
get_authenticator_info
(
)
.
map_or
(
false
|
i
|
{
i
.
versions
.
contains
(
&
AuthenticatorVersion
:
:
FIDO_2_1
)
}
)
;
let
resp
=
if
supports_select_cmd
{
let
msg
=
Selection
{
}
;
self
.
send_cbor_cancellable
(
&
msg
keep_alive
)
}
else
{
let
msg
=
dummy_make_credentials_cmd
(
)
;
info
!
(
"
Trying
to
blink
:
{
:
?
}
"
&
msg
)
;
self
.
send_msg_cancellable
(
&
msg
keep_alive
)
.
map
(
|
_
|
(
)
)
}
;
match
resp
{
Ok
(
_
)
|
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
PinInvalid
_
)
)
)
|
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
PinAuthInvalid
_
)
)
)
|
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
PinNotSet
_
)
)
)
=
>
{
BlinkResult
:
:
DeviceSelected
}
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
KeepaliveCancel
_
)
)
)
|
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
OperationDenied
_
)
)
)
|
Err
(
HIDError
:
:
Command
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
UserActionTimeout
_
)
)
)
=
>
{
debug
!
(
"
Device
{
:
?
}
got
cancelled
"
&
self
)
;
BlinkResult
:
:
Cancelled
}
e
=
>
{
info
!
(
"
Device
{
:
?
}
received
unexpected
answer
so
we
assume
an
error
occurred
and
we
are
NOT
using
this
device
(
assuming
the
request
was
cancelled
)
:
{
:
?
}
"
&
self
e
)
;
BlinkResult
:
:
Cancelled
}
}
}
fn
establish_shared_secret
(
&
mut
self
alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
Result
<
SharedSecret
HIDError
>
{
let
info
=
match
(
self
.
get_protocol
(
)
self
.
get_authenticator_info
(
)
)
{
(
FidoProtocol
:
:
CTAP2
Some
(
info
)
)
=
>
info
_
=
>
return
Err
(
HIDError
:
:
UnsupportedCommand
)
}
;
let
pin_protocol
=
PinUvAuthProtocol
:
:
try_from
(
info
)
?
;
let
pin_command
=
GetKeyAgreement
:
:
new
(
pin_protocol
.
clone
(
)
)
;
let
resp
=
self
.
send_cbor_cancellable
(
&
pin_command
alive
)
?
;
if
let
Some
(
device_key_agreement_key
)
=
resp
.
key_agreement
{
let
shared_secret
=
pin_protocol
.
encapsulate
(
&
device_key_agreement_key
)
.
map_err
(
CommandError
:
:
from
)
?
;
self
.
set_shared_secret
(
shared_secret
.
clone
(
)
)
;
Ok
(
shared_secret
)
}
else
{
Err
(
HIDError
:
:
Command
(
CommandError
:
:
MissingRequiredField
(
"
key_agreement
"
)
)
)
}
}
fn
get_pin_token
(
&
mut
self
pin
:
&
Option
<
Pin
>
alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
Result
<
PinUvAuthToken
HIDError
>
{
let
pin
=
pin
.
as_ref
(
)
.
ok_or
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
PinRequired
None
)
)
?
;
let
shared_secret
=
self
.
establish_shared_secret
(
alive
)
?
;
let
pin_command
=
GetPinToken
:
:
new
(
&
shared_secret
pin
)
;
let
resp
=
self
.
send_cbor_cancellable
(
&
pin_command
alive
)
?
;
if
let
Some
(
encrypted_pin_token
)
=
resp
.
pin_token
{
let
default_permissions
=
PinUvAuthTokenPermission
:
:
default
(
)
;
let
pin_token
=
shared_secret
.
decrypt_pin_token
(
default_permissions
encrypted_pin_token
.
as_ref
(
)
)
.
map_err
(
CommandError
:
:
from
)
?
;
Ok
(
pin_token
)
}
else
{
Err
(
HIDError
:
:
Command
(
CommandError
:
:
MissingRequiredField
(
"
pin_token
"
)
)
)
}
}
fn
get_pin_uv_auth_token_using_uv_with_permissions
(
&
mut
self
permission
:
PinUvAuthTokenPermission
rp_id
:
Option
<
&
String
>
alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
Result
<
PinUvAuthToken
HIDError
>
{
let
shared_secret
=
self
.
establish_shared_secret
(
alive
)
?
;
let
pin_command
=
GetPinUvAuthTokenUsingUvWithPermissions
:
:
new
(
&
shared_secret
permission
rp_id
.
cloned
(
)
)
;
let
resp
=
self
.
send_cbor_cancellable
(
&
pin_command
alive
)
?
;
if
let
Some
(
encrypted_pin_token
)
=
resp
.
pin_token
{
let
pin_token
=
shared_secret
.
decrypt_pin_token
(
permission
encrypted_pin_token
.
as_ref
(
)
)
.
map_err
(
CommandError
:
:
from
)
?
;
Ok
(
pin_token
)
}
else
{
Err
(
HIDError
:
:
Command
(
CommandError
:
:
MissingRequiredField
(
"
pin_token
"
)
)
)
}
}
fn
get_pin_uv_auth_token_using_pin_with_permissions
(
&
mut
self
pin
:
&
Option
<
Pin
>
permission
:
PinUvAuthTokenPermission
rp_id
:
Option
<
&
String
>
alive
:
&
dyn
Fn
(
)
-
>
bool
)
-
>
Result
<
PinUvAuthToken
HIDError
>
{
let
pin
=
pin
.
as_ref
(
)
.
ok_or
(
CommandError
:
:
StatusCode
(
StatusCode
:
:
PinRequired
None
)
)
?
;
let
shared_secret
=
self
.
establish_shared_secret
(
alive
)
?
;
let
pin_command
=
GetPinUvAuthTokenUsingPinWithPermissions
:
:
new
(
&
shared_secret
pin
permission
rp_id
.
cloned
(
)
)
;
let
resp
=
self
.
send_cbor_cancellable
(
&
pin_command
alive
)
?
;
if
let
Some
(
encrypted_pin_token
)
=
resp
.
pin_token
{
let
pin_token
=
shared_secret
.
decrypt_pin_token
(
permission
encrypted_pin_token
.
as_ref
(
)
)
.
map_err
(
CommandError
:
:
from
)
?
;
Ok
(
pin_token
)
}
else
{
Err
(
HIDError
:
:
Command
(
CommandError
:
:
MissingRequiredField
(
"
pin_token
"
)
)
)
}
}
}
pub
trait
VirtualFidoDevice
:
FidoDevice
{
fn
check_key_handle
(
&
self
req
:
&
CheckKeyHandle
)
-
>
Result
<
(
)
HIDError
>
;
fn
client_pin
(
&
self
req
:
&
ClientPIN
)
-
>
Result
<
ClientPinResponse
HIDError
>
;
fn
get_assertion
(
&
self
req
:
&
GetAssertion
)
-
>
Result
<
GetAssertionResult
HIDError
>
;
fn
get_info
(
&
self
)
-
>
Result
<
AuthenticatorInfo
HIDError
>
;
fn
get_version
(
&
self
req
:
&
GetVersion
)
-
>
Result
<
U2FInfo
HIDError
>
;
fn
make_credentials
(
&
self
req
:
&
MakeCredentials
)
-
>
Result
<
MakeCredentialsResult
HIDError
>
;
fn
reset
(
&
self
req
:
&
Reset
)
-
>
Result
<
(
)
HIDError
>
;
fn
selection
(
&
self
req
:
&
Selection
)
-
>
Result
<
(
)
HIDError
>
;
}
