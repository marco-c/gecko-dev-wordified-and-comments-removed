use
crate
:
:
codepointtrie
:
:
error
:
:
Error
;
use
crate
:
:
codepointtrie
:
:
impl_const
:
:
*
;
use
crate
:
:
codepointinvlist
:
:
CodePointInversionList
;
use
core
:
:
char
:
:
CharTryFromError
;
use
core
:
:
convert
:
:
Infallible
;
use
core
:
:
convert
:
:
TryFrom
;
use
core
:
:
fmt
:
:
Display
;
use
core
:
:
iter
:
:
FromIterator
;
use
core
:
:
num
:
:
TryFromIntError
;
use
core
:
:
ops
:
:
RangeInclusive
;
use
yoke
:
:
Yokeable
;
use
zerofrom
:
:
ZeroFrom
;
use
zerovec
:
:
ZeroVec
;
use
zerovec
:
:
ZeroVecError
;
#
[
derive
(
Clone
Copy
PartialEq
Debug
Eq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Deserialize
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
databake
"
derive
(
databake
:
:
Bake
)
databake
(
path
=
icu_collections
:
:
codepointtrie
)
)
]
pub
enum
TrieType
{
Fast
=
0
Small
=
1
}
pub
trait
TrieValue
:
Copy
+
Eq
+
PartialEq
+
zerovec
:
:
ule
:
:
AsULE
+
'
static
{
type
TryFromU32Error
:
Display
;
fn
try_from_u32
(
i
:
u32
)
-
>
Result
<
Self
Self
:
:
TryFromU32Error
>
;
fn
to_u32
(
self
)
-
>
u32
{
debug_assert
!
(
false
"
TrieValue
:
:
to_u32
(
)
not
implemented
for
{
}
"
:
:
core
:
:
any
:
:
type_name
:
:
<
Self
>
(
)
)
;
0
}
}
macro_rules
!
impl_primitive_trie_value
{
(
primitive
:
ty
error
:
ty
)
=
>
{
impl
TrieValue
for
primitive
{
type
TryFromU32Error
=
error
;
fn
try_from_u32
(
i
:
u32
)
-
>
Result
<
Self
Self
:
:
TryFromU32Error
>
{
Self
:
:
try_from
(
i
)
}
fn
to_u32
(
self
)
-
>
u32
{
/
/
bitcast
when
the
same
size
zero
-
extend
/
sign
-
extend
/
/
when
not
the
same
size
self
as
u32
}
}
}
;
}
impl_primitive_trie_value
!
(
u8
TryFromIntError
)
;
impl_primitive_trie_value
!
(
u16
TryFromIntError
)
;
impl_primitive_trie_value
!
(
u32
Infallible
)
;
impl_primitive_trie_value
!
(
i8
TryFromIntError
)
;
impl_primitive_trie_value
!
(
i16
TryFromIntError
)
;
impl_primitive_trie_value
!
(
i32
TryFromIntError
)
;
impl_primitive_trie_value
!
(
char
CharTryFromError
)
;
fn
maybe_filter_value
<
T
:
TrieValue
>
(
value
:
T
trie_null_value
:
T
null_value
:
T
)
-
>
T
{
if
value
=
=
trie_null_value
{
null_value
}
else
{
value
}
}
#
[
derive
(
Debug
Eq
PartialEq
Yokeable
ZeroFrom
)
]
pub
struct
CodePointTrie
<
'
trie
T
:
TrieValue
>
{
pub
(
crate
)
header
:
CodePointTrieHeader
pub
(
crate
)
index
:
ZeroVec
<
'
trie
u16
>
pub
(
crate
)
data
:
ZeroVec
<
'
trie
T
>
#
[
zerofrom
(
clone
)
]
pub
(
crate
)
error_value
:
T
}
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Deserialize
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
databake
"
derive
(
databake
:
:
Bake
)
databake
(
path
=
icu_collections
:
:
codepointtrie
)
)
]
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Yokeable
ZeroFrom
)
]
pub
struct
CodePointTrieHeader
{
pub
high_start
:
u32
pub
shifted12_high_start
:
u16
pub
index3_null_offset
:
u16
pub
data_null_offset
:
u32
pub
null_value
:
u32
pub
trie_type
:
TrieType
}
impl
TryFrom
<
u8
>
for
TrieType
{
type
Error
=
crate
:
:
codepointtrie
:
:
error
:
:
Error
;
fn
try_from
(
trie_type_int
:
u8
)
-
>
Result
<
TrieType
crate
:
:
codepointtrie
:
:
error
:
:
Error
>
{
match
trie_type_int
{
0
=
>
Ok
(
TrieType
:
:
Fast
)
1
=
>
Ok
(
TrieType
:
:
Small
)
_
=
>
Err
(
crate
:
:
codepointtrie
:
:
error
:
:
Error
:
:
FromDeserialized
{
reason
:
"
Cannot
parse
value
for
trie_type
"
}
)
}
}
}
impl
<
'
trie
T
:
TrieValue
>
CodePointTrie
<
'
trie
T
>
{
#
[
doc
(
hidden
)
]
pub
const
fn
from_parts
(
header
:
CodePointTrieHeader
index
:
ZeroVec
<
'
trie
u16
>
data
:
ZeroVec
<
'
trie
T
>
error_value
:
T
)
-
>
Self
{
Self
{
header
index
data
error_value
}
}
pub
fn
try_new
(
header
:
CodePointTrieHeader
index
:
ZeroVec
<
'
trie
u16
>
data
:
ZeroVec
<
'
trie
T
>
)
-
>
Result
<
CodePointTrie
<
'
trie
T
>
Error
>
{
let
error_value
=
data
.
last
(
)
.
ok_or
(
Error
:
:
EmptyDataVector
)
?
;
let
trie
:
CodePointTrie
<
'
trie
T
>
=
CodePointTrie
{
header
index
data
error_value
}
;
Ok
(
trie
)
}
#
[
inline
(
always
)
]
fn
trie_error_val_index
(
&
self
)
-
>
u32
{
self
.
data
.
len
(
)
as
u32
-
ERROR_VALUE_NEG_DATA_OFFSET
}
fn
internal_small_index
(
&
self
code_point
:
u32
)
-
>
u32
{
let
mut
index1_pos
:
u32
=
code_point
>
>
SHIFT_1
;
if
self
.
header
.
trie_type
=
=
TrieType
:
:
Fast
{
debug_assert
!
(
FAST_TYPE_FAST_INDEXING_MAX
<
code_point
&
&
code_point
<
self
.
header
.
high_start
)
;
index1_pos
=
index1_pos
+
BMP_INDEX_LENGTH
-
OMITTED_BMP_INDEX_1_LENGTH
;
}
else
{
assert
!
(
code_point
<
self
.
header
.
high_start
&
&
self
.
header
.
high_start
>
SMALL_LIMIT
)
;
index1_pos
+
=
SMALL_INDEX_LENGTH
;
}
let
index1_val
=
if
let
Some
(
index1_val
)
=
self
.
index
.
get
(
index1_pos
as
usize
)
{
index1_val
}
else
{
return
self
.
trie_error_val_index
(
)
;
}
;
let
index3_block_idx
:
u32
=
(
index1_val
as
u32
)
+
(
(
code_point
>
>
SHIFT_2
)
&
INDEX_2_MASK
)
;
let
mut
index3_block
:
u32
=
if
let
Some
(
index3_block
)
=
self
.
index
.
get
(
index3_block_idx
as
usize
)
{
index3_block
as
u32
}
else
{
return
self
.
trie_error_val_index
(
)
;
}
;
let
mut
index3_pos
:
u32
=
(
code_point
>
>
SHIFT_3
)
&
INDEX_3_MASK
;
let
mut
data_block
:
u32
;
if
index3_block
&
0x8000
=
=
0
{
data_block
=
if
let
Some
(
data_block
)
=
self
.
index
.
get
(
(
index3_block
+
index3_pos
)
as
usize
)
{
data_block
as
u32
}
else
{
return
self
.
trie_error_val_index
(
)
;
}
;
}
else
{
index3_block
=
(
index3_block
&
0x7fff
)
+
(
index3_pos
&
!
7
)
+
(
index3_pos
>
>
3
)
;
index3_pos
&
=
7
;
data_block
=
if
let
Some
(
data_block
)
=
self
.
index
.
get
(
index3_block
as
usize
)
{
data_block
as
u32
}
else
{
return
self
.
trie_error_val_index
(
)
;
}
;
data_block
=
(
data_block
<
<
(
2
+
(
2
*
index3_pos
)
)
)
&
0x30000
;
index3_block
+
=
1
;
data_block
=
if
let
Some
(
index3_val
)
=
self
.
index
.
get
(
(
index3_block
+
index3_pos
)
as
usize
)
{
data_block
|
(
index3_val
as
u32
)
}
else
{
return
self
.
trie_error_val_index
(
)
;
}
;
}
data_block
+
(
code_point
&
SMALL_DATA_MASK
)
}
fn
small_index
(
&
self
code_point
:
u32
)
-
>
u32
{
if
code_point
>
=
self
.
header
.
high_start
{
self
.
data
.
len
(
)
as
u32
-
HIGH_VALUE_NEG_DATA_OFFSET
}
else
{
self
.
internal_small_index
(
code_point
)
}
}
#
[
inline
(
always
)
]
fn
fast_index
(
&
self
code_point
:
u32
)
-
>
u32
{
let
index_array_pos
:
u32
=
code_point
>
>
FAST_TYPE_SHIFT
;
let
index_array_val
:
u16
=
if
let
Some
(
index_array_val
)
=
self
.
index
.
get
(
index_array_pos
as
usize
)
{
index_array_val
}
else
{
return
self
.
trie_error_val_index
(
)
;
}
;
let
fast_index_val
:
u32
=
index_array_val
as
u32
+
(
code_point
&
FAST_TYPE_DATA_MASK
)
;
fast_index_val
}
#
[
inline
(
always
)
]
pub
fn
get32
(
&
self
code_point
:
u32
)
-
>
T
{
self
.
get32_ule
(
code_point
)
.
map
(
|
t
|
T
:
:
from_unaligned
(
*
t
)
)
.
unwrap_or
(
self
.
error_value
)
}
#
[
inline
(
always
)
]
pub
fn
get
(
&
self
c
:
char
)
-
>
T
{
self
.
get32
(
u32
:
:
from
(
c
)
)
}
#
[
inline
(
always
)
]
pub
fn
get32_ule
(
&
self
code_point
:
u32
)
-
>
Option
<
&
T
:
:
ULE
>
{
let
fast_max
=
match
self
.
header
.
trie_type
{
TrieType
:
:
Fast
=
>
FAST_TYPE_FAST_INDEXING_MAX
TrieType
:
:
Small
=
>
SMALL_TYPE_FAST_INDEXING_MAX
}
;
let
data_pos
:
u32
=
if
code_point
<
=
fast_max
{
Self
:
:
fast_index
(
self
code_point
)
}
else
if
code_point
<
=
CODE_POINT_MAX
{
Self
:
:
small_index
(
self
code_point
)
}
else
{
self
.
trie_error_val_index
(
)
}
;
self
.
data
.
as_ule_slice
(
)
.
get
(
data_pos
as
usize
)
}
pub
fn
try_into_converted
<
P
>
(
self
)
-
>
Result
<
CodePointTrie
<
'
trie
P
>
ZeroVecError
>
where
P
:
TrieValue
{
let
converted_data
=
self
.
data
.
try_into_converted
(
)
?
;
let
error_ule
=
self
.
error_value
.
to_unaligned
(
)
;
let
slice
=
&
[
error_ule
]
;
let
error_vec
=
ZeroVec
:
:
<
T
>
:
:
new_borrowed
(
slice
)
;
let
error_converted
=
error_vec
.
try_into_converted
:
:
<
P
>
(
)
?
;
#
[
allow
(
clippy
:
:
expect_used
)
]
Ok
(
CodePointTrie
{
header
:
self
.
header
index
:
self
.
index
data
:
converted_data
error_value
:
error_converted
.
get
(
0
)
.
expect
(
"
vector
known
to
have
one
element
"
)
}
)
}
pub
fn
try_alloc_map_value
<
P
E
>
(
&
self
mut
f
:
impl
FnMut
(
T
)
-
>
Result
<
P
E
>
)
-
>
Result
<
CodePointTrie
<
'
trie
P
>
E
>
where
P
:
TrieValue
{
let
error_converted
=
f
(
self
.
error_value
)
?
;
let
converted_data
=
self
.
data
.
iter
(
)
.
map
(
f
)
.
collect
:
:
<
Result
<
ZeroVec
<
P
>
E
>
>
(
)
?
;
Ok
(
CodePointTrie
{
header
:
self
.
header
index
:
self
.
index
.
clone
(
)
data
:
converted_data
error_value
:
error_converted
}
)
}
pub
fn
get_range
(
&
self
start
:
u32
)
-
>
Option
<
CodePointMapRange
<
T
>
>
{
if
CODE_POINT_MAX
<
start
{
return
None
;
}
if
start
>
=
self
.
header
.
high_start
{
let
di
:
usize
=
self
.
data
.
len
(
)
-
(
HIGH_VALUE_NEG_DATA_OFFSET
as
usize
)
;
let
value
:
T
=
self
.
data
.
get
(
di
)
?
;
return
Some
(
CodePointMapRange
{
range
:
RangeInclusive
:
:
new
(
start
CODE_POINT_MAX
)
value
}
)
;
}
let
null_value
:
T
=
T
:
:
try_from_u32
(
self
.
header
.
null_value
)
.
ok
(
)
?
;
let
mut
prev_i3_block
:
u32
=
u32
:
:
MAX
;
let
mut
prev_block
:
u32
=
u32
:
:
MAX
;
let
mut
c
:
u32
=
start
;
let
mut
trie_value
:
T
=
self
.
error_value
(
)
;
let
mut
value
:
T
=
self
.
error_value
(
)
;
let
mut
have_value
:
bool
=
false
;
loop
{
let
i3_block
:
u32
;
let
mut
i3
:
u32
;
let
i3_block_length
:
u32
;
let
data_block_length
:
u32
;
if
c
<
=
0xffff
&
&
(
self
.
header
.
trie_type
=
=
TrieType
:
:
Fast
|
|
c
<
=
SMALL_TYPE_FAST_INDEXING_MAX
)
{
i3_block
=
0
;
i3
=
c
>
>
FAST_TYPE_SHIFT
;
i3_block_length
=
if
self
.
header
.
trie_type
=
=
TrieType
:
:
Fast
{
BMP_INDEX_LENGTH
}
else
{
SMALL_INDEX_LENGTH
}
;
data_block_length
=
FAST_TYPE_DATA_BLOCK_LENGTH
;
}
else
{
let
mut
i1
:
u32
=
c
>
>
SHIFT_1
;
if
self
.
header
.
trie_type
=
=
TrieType
:
:
Fast
{
debug_assert
!
(
0xffff
<
c
&
&
c
<
self
.
header
.
high_start
)
;
i1
=
i1
+
BMP_INDEX_LENGTH
-
OMITTED_BMP_INDEX_1_LENGTH
;
}
else
{
debug_assert
!
(
c
<
self
.
header
.
high_start
&
&
self
.
header
.
high_start
>
SMALL_LIMIT
)
;
i1
+
=
SMALL_INDEX_LENGTH
;
}
let
i2
:
u16
=
self
.
index
.
get
(
i1
as
usize
)
?
;
let
i3_block_idx
:
u32
=
(
i2
as
u32
)
+
(
(
c
>
>
SHIFT_2
)
&
INDEX_2_MASK
)
;
i3_block
=
if
let
Some
(
i3b
)
=
self
.
index
.
get
(
i3_block_idx
as
usize
)
{
i3b
as
u32
}
else
{
return
None
;
}
;
if
i3_block
=
=
prev_i3_block
&
&
(
c
-
start
)
>
=
CP_PER_INDEX_2_ENTRY
{
debug_assert
!
(
(
c
&
(
CP_PER_INDEX_2_ENTRY
-
1
)
)
=
=
0
)
;
c
+
=
CP_PER_INDEX_2_ENTRY
;
if
c
>
=
self
.
header
.
high_start
{
break
;
}
else
{
continue
;
}
}
prev_i3_block
=
i3_block
;
if
i3_block
=
=
self
.
header
.
index3_null_offset
as
u32
{
if
have_value
{
if
null_value
!
=
value
{
return
Some
(
CodePointMapRange
{
range
:
RangeInclusive
:
:
new
(
start
c
-
1
)
value
}
)
;
}
}
else
{
trie_value
=
T
:
:
try_from_u32
(
self
.
header
.
null_value
)
.
ok
(
)
?
;
value
=
null_value
;
have_value
=
true
;
}
prev_block
=
self
.
header
.
data_null_offset
;
c
=
(
c
+
CP_PER_INDEX_2_ENTRY
)
&
!
(
CP_PER_INDEX_2_ENTRY
-
1
)
;
if
c
>
=
self
.
header
.
high_start
{
break
;
}
else
{
continue
;
}
}
i3
=
(
c
>
>
SHIFT_3
)
&
INDEX_3_MASK
;
i3_block_length
=
INDEX_3_BLOCK_LENGTH
;
data_block_length
=
SMALL_DATA_BLOCK_LENGTH
;
}
loop
{
let
mut
block
:
u32
;
if
(
i3_block
&
0x8000
)
=
=
0
{
block
=
if
let
Some
(
b
)
=
self
.
index
.
get
(
(
i3_block
+
i3
)
as
usize
)
{
b
as
u32
}
else
{
return
None
;
}
;
}
else
{
let
mut
group
:
u32
=
(
i3_block
&
0x7fff
)
+
(
i3
&
!
7
)
+
(
i3
>
>
3
)
;
let
gi
:
u32
=
i3
&
7
;
let
gi_val
:
u32
=
if
let
Some
(
giv
)
=
self
.
index
.
get
(
group
as
usize
)
{
giv
.
into
(
)
}
else
{
return
None
;
}
;
block
=
(
gi_val
<
<
(
2
+
(
2
*
gi
)
)
)
&
0x30000
;
group
+
=
1
;
let
ggi_val
:
u32
=
if
let
Some
(
ggiv
)
=
self
.
index
.
get
(
(
group
+
gi
)
as
usize
)
{
ggiv
as
u32
}
else
{
return
None
;
}
;
block
|
=
ggi_val
;
}
if
block
=
=
prev_block
&
&
(
c
-
start
)
>
=
data_block_length
{
debug_assert
!
(
(
c
&
(
data_block_length
-
1
)
)
=
=
0
)
;
c
+
=
data_block_length
;
}
else
{
let
data_mask
:
u32
=
data_block_length
-
1
;
prev_block
=
block
;
if
block
=
=
self
.
header
.
data_null_offset
{
if
have_value
{
if
null_value
!
=
value
{
return
Some
(
CodePointMapRange
{
range
:
RangeInclusive
:
:
new
(
start
c
-
1
)
value
}
)
;
}
}
else
{
trie_value
=
T
:
:
try_from_u32
(
self
.
header
.
null_value
)
.
ok
(
)
?
;
value
=
null_value
;
have_value
=
true
;
}
c
=
(
c
+
data_block_length
)
&
!
data_mask
;
}
else
{
let
mut
di
:
u32
=
block
+
(
c
&
data_mask
)
;
let
mut
trie_value_2
:
T
=
self
.
data
.
get
(
di
as
usize
)
?
;
if
have_value
{
if
trie_value_2
!
=
trie_value
{
if
maybe_filter_value
(
trie_value_2
T
:
:
try_from_u32
(
self
.
header
.
null_value
)
.
ok
(
)
?
null_value
)
!
=
value
{
return
Some
(
CodePointMapRange
{
range
:
RangeInclusive
:
:
new
(
start
c
-
1
)
value
}
)
;
}
trie_value
=
trie_value_2
;
}
}
else
{
trie_value
=
trie_value_2
;
value
=
maybe_filter_value
(
trie_value_2
T
:
:
try_from_u32
(
self
.
header
.
null_value
)
.
ok
(
)
?
null_value
)
;
have_value
=
true
;
}
c
+
=
1
;
while
(
c
&
data_mask
)
!
=
0
{
di
+
=
1
;
trie_value_2
=
self
.
data
.
get
(
di
as
usize
)
?
;
if
trie_value_2
!
=
trie_value
{
if
maybe_filter_value
(
trie_value_2
T
:
:
try_from_u32
(
self
.
header
.
null_value
)
.
ok
(
)
?
null_value
)
!
=
value
{
return
Some
(
CodePointMapRange
{
range
:
RangeInclusive
:
:
new
(
start
c
-
1
)
value
}
)
;
}
trie_value
=
trie_value_2
;
}
c
+
=
1
;
}
}
}
i3
+
=
1
;
if
i3
>
=
i3_block_length
{
break
;
}
}
if
c
>
=
self
.
header
.
high_start
{
break
;
}
}
debug_assert
!
(
have_value
)
;
let
di
:
u32
=
self
.
data
.
len
(
)
as
u32
-
HIGH_VALUE_NEG_DATA_OFFSET
;
let
high_value
:
T
=
self
.
data
.
get
(
di
as
usize
)
?
;
if
maybe_filter_value
(
high_value
T
:
:
try_from_u32
(
self
.
header
.
null_value
)
.
ok
(
)
?
null_value
)
!
=
value
{
c
-
=
1
;
}
else
{
c
=
CODE_POINT_MAX
;
}
Some
(
CodePointMapRange
{
range
:
RangeInclusive
:
:
new
(
start
c
)
value
}
)
}
pub
fn
iter_ranges
(
&
self
)
-
>
CodePointMapRangeIterator
<
T
>
{
let
init_range
=
Some
(
CodePointMapRange
{
range
:
RangeInclusive
:
:
new
(
u32
:
:
MAX
u32
:
:
MAX
)
value
:
self
.
error_value
(
)
}
)
;
CodePointMapRangeIterator
:
:
<
T
>
{
cpt
:
self
cpm_range
:
init_range
}
}
pub
fn
get_ranges_for_value
(
&
self
value
:
T
)
-
>
impl
Iterator
<
Item
=
RangeInclusive
<
u32
>
>
+
'
_
{
self
.
iter_ranges
(
)
.
filter
(
move
|
cpm_range
|
cpm_range
.
value
=
=
value
)
.
map
(
|
cpm_range
|
cpm_range
.
range
)
}
pub
fn
iter_ranges_mapped
<
'
a
U
:
Eq
+
'
a
>
(
&
'
a
self
mut
map
:
impl
FnMut
(
T
)
-
>
U
+
Copy
+
'
a
)
-
>
impl
Iterator
<
Item
=
CodePointMapRange
<
U
>
>
+
'
a
{
crate
:
:
iterator_utils
:
:
RangeListIteratorCoalescer
:
:
new
(
self
.
iter_ranges
(
)
.
map
(
move
|
range
|
CodePointMapRange
{
range
:
range
.
range
value
:
map
(
range
.
value
)
}
)
)
}
pub
fn
get_set_for_value
(
&
self
value
:
T
)
-
>
CodePointInversionList
<
'
static
>
{
let
value_ranges
=
self
.
get_ranges_for_value
(
value
)
;
CodePointInversionList
:
:
from_iter
(
value_ranges
)
}
#
[
inline
]
pub
fn
error_value
(
&
self
)
-
>
T
{
self
.
error_value
}
}
#
[
cfg
(
feature
=
"
databake
"
)
]
impl
<
'
trie
T
:
TrieValue
+
databake
:
:
Bake
>
databake
:
:
Bake
for
CodePointTrie
<
'
trie
T
>
{
fn
bake
(
&
self
env
:
&
databake
:
:
CrateEnv
)
-
>
databake
:
:
TokenStream
{
let
header
=
self
.
header
.
bake
(
env
)
;
let
index
=
self
.
index
.
bake
(
env
)
;
let
data
=
self
.
data
.
bake
(
env
)
;
let
error_value
=
self
.
error_value
.
bake
(
env
)
;
databake
:
:
quote
!
{
icu_collections
:
:
codepointtrie
:
:
CodePointTrie
:
:
from_parts
(
#
header
#
index
#
data
#
error_value
)
}
}
}
impl
<
'
trie
T
:
TrieValue
+
Into
<
u32
>
>
CodePointTrie
<
'
trie
T
>
{
pub
fn
get32_u32
(
&
self
code_point
:
u32
)
-
>
u32
{
self
.
get32
(
code_point
)
.
into
(
)
}
}
impl
<
'
trie
T
:
TrieValue
>
Clone
for
CodePointTrie
<
'
trie
T
>
where
<
T
as
zerovec
:
:
ule
:
:
AsULE
>
:
:
ULE
:
Clone
{
fn
clone
(
&
self
)
-
>
Self
{
CodePointTrie
{
header
:
self
.
header
index
:
self
.
index
.
clone
(
)
data
:
self
.
data
.
clone
(
)
error_value
:
self
.
error_value
}
}
}
#
[
derive
(
PartialEq
Eq
Debug
Clone
)
]
pub
struct
CodePointMapRange
<
T
>
{
pub
range
:
RangeInclusive
<
u32
>
pub
value
:
T
}
pub
struct
CodePointMapRangeIterator
<
'
a
T
:
TrieValue
>
{
cpt
:
&
'
a
CodePointTrie
<
'
a
T
>
cpm_range
:
Option
<
CodePointMapRange
<
T
>
>
}
impl
<
'
a
T
:
TrieValue
>
Iterator
for
CodePointMapRangeIterator
<
'
a
T
>
{
type
Item
=
CodePointMapRange
<
T
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
cpm_range
=
match
&
self
.
cpm_range
{
Some
(
cpmr
)
=
>
{
if
*
cpmr
.
range
.
start
(
)
=
=
u32
:
:
MAX
{
self
.
cpt
.
get_range
(
0
)
}
else
{
self
.
cpt
.
get_range
(
cpmr
.
range
.
end
(
)
+
1
)
}
}
None
=
>
None
}
;
self
.
cpm_range
.
clone
(
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
codepointtrie
:
:
planes
;
use
alloc
:
:
vec
:
:
Vec
;
#
[
test
]
#
[
cfg
(
feature
=
"
serde
"
)
]
fn
test_serde_with_postcard_roundtrip
(
)
-
>
Result
<
(
)
postcard
:
:
Error
>
{
let
trie
=
crate
:
:
codepointtrie
:
:
planes
:
:
get_planes_trie
(
)
;
let
trie_serialized
:
Vec
<
u8
>
=
postcard
:
:
to_allocvec
(
&
trie
)
.
unwrap
(
)
;
const
EXP_TRIE_SERIALIZED
:
&
[
u8
]
=
&
[
128
128
64
128
2
2
0
0
1
160
18
0
0
64
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
136
2
144
2
144
2
144
2
176
2
176
2
176
2
176
2
208
2
208
2
208
2
208
2
240
2
240
2
240
2
240
2
16
3
16
3
16
3
16
3
48
3
48
3
48
3
48
3
80
3
80
3
80
3
80
3
112
3
112
3
112
3
112
3
144
3
144
3
144
3
144
3
176
3
176
3
176
3
176
3
208
3
208
3
208
3
208
3
240
3
240
3
240
3
240
3
16
4
16
4
16
4
16
4
48
4
48
4
48
4
48
4
80
4
80
4
80
4
80
4
112
4
112
4
112
4
112
4
0
0
16
0
32
0
48
0
64
0
80
0
96
0
112
0
0
0
16
0
32
0
48
0
0
0
16
0
32
0
48
0
0
0
16
0
32
0
48
0
0
0
16
0
32
0
48
0
0
0
16
0
32
0
48
0
0
0
16
0
32
0
48
0
0
0
16
0
32
0
48
0
0
0
16
0
32
0
48
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
128
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
144
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
160
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
176
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
192
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
208
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
224
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
240
0
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
32
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
48
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
64
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
80
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
96
1
128
0
136
0
136
0
136
0
136
0
136
0
136
0
136
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
2
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
168
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
200
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
232
0
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
40
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
72
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
104
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
136
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
168
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
200
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
232
1
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
8
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
40
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
72
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
104
2
244
2
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
8
8
8
8
8
8
8
8
8
8
8
8
8
8
8
8
9
9
9
9
9
9
9
9
9
9
9
9
9
9
9
9
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
12
12
12
12
12
12
12
12
12
12
12
12
12
12
12
12
13
13
13
13
13
13
13
13
13
13
13
13
13
13
13
13
14
14
14
14
14
14
14
14
14
14
14
14
14
14
14
14
15
15
15
15
15
15
15
15
15
15
15
15
15
15
15
15
16
16
16
0
]
;
assert_eq
!
(
trie_serialized
EXP_TRIE_SERIALIZED
)
;
let
trie_deserialized
=
postcard
:
:
from_bytes
:
:
<
CodePointTrie
<
u8
>
>
(
&
trie_serialized
)
?
;
assert_eq
!
(
&
trie
.
index
&
trie_deserialized
.
index
)
;
assert_eq
!
(
&
trie
.
data
&
trie_deserialized
.
data
)
;
assert
!
(
!
trie_deserialized
.
index
.
is_owned
(
)
)
;
assert
!
(
!
trie_deserialized
.
data
.
is_owned
(
)
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
test_get_range
(
)
{
let
planes_trie
=
planes
:
:
get_planes_trie
(
)
;
let
first_range
:
Option
<
CodePointMapRange
<
u8
>
>
=
planes_trie
.
get_range
(
0x0
)
;
assert_eq
!
(
first_range
Some
(
CodePointMapRange
{
range
:
RangeInclusive
:
:
new
(
0x0
0xffff
)
value
:
0
}
)
)
;
let
second_range
:
Option
<
CodePointMapRange
<
u8
>
>
=
planes_trie
.
get_range
(
0x1_0000
)
;
assert_eq
!
(
second_range
Some
(
CodePointMapRange
{
range
:
RangeInclusive
:
:
new
(
0x10000
0x1ffff
)
value
:
1
}
)
)
;
let
penultimate_range
:
Option
<
CodePointMapRange
<
u8
>
>
=
planes_trie
.
get_range
(
0xf_0000
)
;
assert_eq
!
(
penultimate_range
Some
(
CodePointMapRange
{
range
:
RangeInclusive
:
:
new
(
0xf_0000
0xf_ffff
)
value
:
15
}
)
)
;
let
last_range
:
Option
<
CodePointMapRange
<
u8
>
>
=
planes_trie
.
get_range
(
0x10_0000
)
;
assert_eq
!
(
last_range
Some
(
CodePointMapRange
{
range
:
RangeInclusive
:
:
new
(
0x10_0000
0x10_ffff
)
value
:
16
}
)
)
;
}
#
[
test
]
fn
databake
(
)
{
databake
:
:
test_bake
!
(
CodePointTrie
<
'
static
u32
>
const
:
crate
:
:
codepointtrie
:
:
CodePointTrie
:
:
from_parts
(
crate
:
:
codepointtrie
:
:
CodePointTrieHeader
{
high_start
:
1u32
shifted12_high_start
:
2u16
index3_null_offset
:
3u16
data_null_offset
:
4u32
null_value
:
5u32
trie_type
:
crate
:
:
codepointtrie
:
:
TrieType
:
:
Small
}
zerovec
:
:
ZeroVec
:
:
new
(
)
zerovec
:
:
ZeroVec
:
:
new
(
)
0u32
)
icu_collections
[
zerovec
]
)
;
}
}
