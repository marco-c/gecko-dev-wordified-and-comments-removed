use
crate
:
:
codepointinvlist
:
:
{
CodePointInversionList
CodePointInversionListBuilder
CodePointInversionListError
CodePointInversionListULE
}
;
use
alloc
:
:
string
:
:
{
String
ToString
}
;
use
alloc
:
:
vec
:
:
Vec
;
use
displaydoc
:
:
Display
;
use
yoke
:
:
Yokeable
;
use
zerofrom
:
:
ZeroFrom
;
use
zerovec
:
:
{
VarZeroSlice
VarZeroVec
}
;
#
[
zerovec
:
:
make_varule
(
CodePointInversionListAndStringListULE
)
]
#
[
zerovec
:
:
skip_derive
(
Ord
)
]
#
[
zerovec
:
:
derive
(
Debug
)
]
#
[
derive
(
Debug
Eq
PartialEq
Clone
Yokeable
ZeroFrom
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Deserialize
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
zerovec
:
:
derive
(
Serialize
Deserialize
Debug
)
)
]
pub
struct
CodePointInversionListAndStringList
<
'
data
>
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
borrow
)
)
]
#
[
zerovec
:
:
varule
(
CodePointInversionListULE
)
]
cp_inv_list
:
CodePointInversionList
<
'
data
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
borrow
)
)
]
str_list
:
VarZeroVec
<
'
data
str
>
}
#
[
cfg
(
feature
=
"
databake
"
)
]
impl
databake
:
:
Bake
for
CodePointInversionListAndStringList
<
'
_
>
{
fn
bake
(
&
self
env
:
&
databake
:
:
CrateEnv
)
-
>
databake
:
:
TokenStream
{
env
.
insert
(
"
icu_collections
"
)
;
let
cp_inv_list
=
self
.
cp_inv_list
.
bake
(
env
)
;
let
str_list
=
self
.
str_list
.
bake
(
env
)
;
databake
:
:
quote
!
{
icu_collections
:
:
codepointinvliststringlist
:
:
CodePointInversionListAndStringList
:
:
from_parts_unchecked
(
#
cp_inv_list
#
str_list
)
}
}
}
impl
<
'
data
>
CodePointInversionListAndStringList
<
'
data
>
{
pub
fn
try_from
(
cp_inv_list
:
CodePointInversionList
<
'
data
>
str_list
:
VarZeroVec
<
'
data
str
>
)
-
>
Result
<
Self
CodePointInversionListAndStringListError
>
{
{
let
mut
it
=
str_list
.
iter
(
)
;
if
let
Some
(
mut
x
)
=
it
.
next
(
)
{
if
x
.
len
(
)
=
=
1
{
return
Err
(
CodePointInversionListAndStringListError
:
:
InvalidStringLength
(
x
.
to_string
(
)
)
)
;
}
for
y
in
it
{
if
x
.
len
(
)
=
=
1
{
return
Err
(
CodePointInversionListAndStringListError
:
:
InvalidStringLength
(
x
.
to_string
(
)
)
)
;
}
else
if
x
=
=
y
{
return
Err
(
CodePointInversionListAndStringListError
:
:
StringListNotUnique
(
x
.
to_string
(
)
)
)
;
}
else
if
x
>
y
{
return
Err
(
CodePointInversionListAndStringListError
:
:
StringListNotSorted
(
x
.
to_string
(
)
y
.
to_string
(
)
)
)
;
}
x
=
y
;
}
}
}
Ok
(
CodePointInversionListAndStringList
{
cp_inv_list
str_list
}
)
}
#
[
doc
(
hidden
)
]
pub
const
fn
from_parts_unchecked
(
cp_inv_list
:
CodePointInversionList
<
'
data
>
str_list
:
VarZeroVec
<
'
data
str
>
)
-
>
Self
{
CodePointInversionListAndStringList
{
cp_inv_list
str_list
}
}
pub
fn
size
(
&
self
)
-
>
usize
{
self
.
cp_inv_list
.
size
(
)
+
self
.
str_list
.
len
(
)
}
pub
fn
has_strings
(
&
self
)
-
>
bool
{
!
self
.
str_list
.
is_empty
(
)
}
pub
fn
contains
(
&
self
s
:
&
str
)
-
>
bool
{
let
mut
chars
=
s
.
chars
(
)
;
if
let
Some
(
first_char
)
=
chars
.
next
(
)
{
if
chars
.
next
(
)
.
is_none
(
)
{
return
self
.
contains_char
(
first_char
)
;
}
}
self
.
str_list
.
binary_search
(
s
)
.
is_ok
(
)
}
pub
fn
contains32
(
&
self
cp
:
u32
)
-
>
bool
{
self
.
cp_inv_list
.
contains32
(
cp
)
}
pub
fn
contains_char
(
&
self
ch
:
char
)
-
>
bool
{
self
.
contains32
(
ch
as
u32
)
}
pub
fn
code_points
(
&
self
)
-
>
&
CodePointInversionList
<
'
data
>
{
&
self
.
cp_inv_list
}
pub
fn
strings
(
&
self
)
-
>
&
VarZeroSlice
<
str
>
{
&
self
.
str_list
}
}
impl
<
'
a
>
FromIterator
<
&
'
a
str
>
for
CodePointInversionListAndStringList
<
'
_
>
{
fn
from_iter
<
I
>
(
it
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
&
'
a
str
>
{
let
mut
builder
=
CodePointInversionListBuilder
:
:
new
(
)
;
let
mut
strings
=
Vec
:
:
<
&
str
>
:
:
new
(
)
;
for
s
in
it
{
let
mut
chars
=
s
.
chars
(
)
;
if
let
Some
(
first_char
)
=
chars
.
next
(
)
{
if
chars
.
next
(
)
.
is_none
(
)
{
builder
.
add_char
(
first_char
)
;
continue
;
}
}
strings
.
push
(
s
)
;
}
strings
.
sort_unstable
(
)
;
strings
.
dedup
(
)
;
let
cp_inv_list
=
builder
.
build
(
)
;
let
str_list
=
VarZeroVec
:
:
<
str
>
:
:
from
(
&
strings
)
;
CodePointInversionListAndStringList
{
cp_inv_list
str_list
}
}
}
#
[
derive
(
Display
Debug
)
]
pub
enum
CodePointInversionListAndStringListError
{
#
[
displaydoc
(
"
Invalid
code
point
inversion
list
:
{
0
:
?
}
"
)
]
InvalidCodePointInversionList
(
CodePointInversionListError
)
#
[
displaydoc
(
"
Invalid
string
length
for
string
:
{
0
}
"
)
]
InvalidStringLength
(
String
)
#
[
displaydoc
(
"
String
list
has
duplicate
:
{
0
}
"
)
]
StringListNotUnique
(
String
)
#
[
displaydoc
(
"
Strings
in
string
list
not
in
sorted
order
:
(
{
0
}
{
1
}
)
"
)
]
StringListNotSorted
(
String
String
)
}
#
[
doc
(
no_inline
)
]
pub
use
CodePointInversionListAndStringListError
as
Error
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
test_size_has_strings
(
)
{
let
cp_slice
=
&
[
0
1
0x7F
0x80
0xFFFF
0x1_0000
0x10_FFFF
0x11_0000
]
;
let
cp_list
=
CodePointInversionList
:
:
try_clone_from_inversion_list_slice
(
cp_slice
)
.
unwrap
(
)
;
let
str_slice
=
&
[
"
ascii_max
"
"
bmp_max
"
"
unicode_max
"
"
zero
"
]
;
let
str_list
=
VarZeroVec
:
:
<
str
>
:
:
from
(
str_slice
)
;
let
cpilsl
=
CodePointInversionListAndStringList
:
:
try_from
(
cp_list
str_list
)
.
unwrap
(
)
;
assert
!
(
cpilsl
.
has_strings
(
)
)
;
assert_eq
!
(
8
cpilsl
.
size
(
)
)
;
}
#
[
test
]
fn
test_empty_string_allowed
(
)
{
let
cp_slice
=
&
[
0
1
0x7F
0x80
0xFFFF
0x1_0000
0x10_FFFF
0x11_0000
]
;
let
cp_list
=
CodePointInversionList
:
:
try_clone_from_inversion_list_slice
(
cp_slice
)
.
unwrap
(
)
;
let
str_slice
=
&
[
"
"
"
ascii_max
"
"
bmp_max
"
"
unicode_max
"
"
zero
"
]
;
let
str_list
=
VarZeroVec
:
:
<
str
>
:
:
from
(
str_slice
)
;
let
cpilsl
=
CodePointInversionListAndStringList
:
:
try_from
(
cp_list
str_list
)
.
unwrap
(
)
;
assert
!
(
cpilsl
.
has_strings
(
)
)
;
assert_eq
!
(
9
cpilsl
.
size
(
)
)
;
}
#
[
test
]
fn
test_invalid_string
(
)
{
let
cp_slice
=
&
[
0
1
]
;
let
cp_list
=
CodePointInversionList
:
:
try_clone_from_inversion_list_slice
(
cp_slice
)
.
unwrap
(
)
;
let
str_slice
=
&
[
"
a
"
]
;
let
str_list
=
VarZeroVec
:
:
<
str
>
:
:
from
(
str_slice
)
;
let
cpilsl
=
CodePointInversionListAndStringList
:
:
try_from
(
cp_list
str_list
)
;
assert
!
(
matches
!
(
cpilsl
Err
(
CodePointInversionListAndStringListError
:
:
InvalidStringLength
(
_
)
)
)
)
;
}
#
[
test
]
fn
test_invalid_string_list_has_duplicate
(
)
{
let
cp_slice
=
&
[
0
1
]
;
let
cp_list
=
CodePointInversionList
:
:
try_clone_from_inversion_list_slice
(
cp_slice
)
.
unwrap
(
)
;
let
str_slice
=
&
[
"
abc
"
"
abc
"
]
;
let
str_list
=
VarZeroVec
:
:
<
str
>
:
:
from
(
str_slice
)
;
let
cpilsl
=
CodePointInversionListAndStringList
:
:
try_from
(
cp_list
str_list
)
;
assert
!
(
matches
!
(
cpilsl
Err
(
CodePointInversionListAndStringListError
:
:
StringListNotUnique
(
_
)
)
)
)
;
}
#
[
test
]
fn
test_invalid_string_list_not_sorted
(
)
{
let
cp_slice
=
&
[
0
1
]
;
let
cp_list
=
CodePointInversionList
:
:
try_clone_from_inversion_list_slice
(
cp_slice
)
.
unwrap
(
)
;
let
str_slice
=
&
[
"
xyz
"
"
abc
"
]
;
let
str_list
=
VarZeroVec
:
:
<
str
>
:
:
from
(
str_slice
)
;
let
cpilsl
=
CodePointInversionListAndStringList
:
:
try_from
(
cp_list
str_list
)
;
assert
!
(
matches
!
(
cpilsl
Err
(
CodePointInversionListAndStringListError
:
:
StringListNotSorted
(
_
_
)
)
)
)
;
}
#
[
test
]
fn
test_from_iter_invariants
(
)
{
let
in_strs_1
=
[
"
a
"
"
abc
"
"
xyz
"
"
abc
"
]
;
let
in_strs_2
=
[
"
xyz
"
"
abc
"
"
a
"
"
abc
"
]
;
let
cpilsl_1
=
CodePointInversionListAndStringList
:
:
from_iter
(
in_strs_1
)
;
let
cpilsl_2
=
CodePointInversionListAndStringList
:
:
from_iter
(
in_strs_2
)
;
assert_eq
!
(
cpilsl_1
cpilsl_2
)
;
assert
!
(
cpilsl_1
.
has_strings
(
)
)
;
assert
!
(
cpilsl_1
.
contains
(
"
abc
"
)
)
;
assert
!
(
cpilsl_1
.
contains
(
"
xyz
"
)
)
;
assert
!
(
!
cpilsl_1
.
contains
(
"
def
"
)
)
;
assert_eq
!
(
1
cpilsl_1
.
cp_inv_list
.
size
(
)
)
;
assert
!
(
cpilsl_1
.
contains_char
(
'
a
'
)
)
;
assert
!
(
!
cpilsl_1
.
contains_char
(
'
0
'
)
)
;
assert
!
(
!
cpilsl_1
.
contains_char
(
'
q
'
)
)
;
assert_eq
!
(
3
cpilsl_1
.
size
(
)
)
;
}
}
