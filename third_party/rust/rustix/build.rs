use
std
:
:
env
:
:
var
;
use
std
:
:
io
:
:
Write
;
const
ASM_PATH
:
&
str
=
"
src
/
backend
/
linux_raw
/
arch
"
;
fn
main
(
)
{
println
!
(
"
cargo
:
rerun
-
if
-
changed
=
build
.
rs
"
)
;
let
arch
=
var
(
"
CARGO_CFG_TARGET_ARCH
"
)
.
unwrap
(
)
;
let
env
=
var
(
"
CARGO_CFG_TARGET_ENV
"
)
.
unwrap
(
)
;
let
inline_asm_name
=
format
!
(
"
{
}
/
{
}
.
rs
"
ASM_PATH
arch
)
;
let
inline_asm_name_present
=
std
:
:
fs
:
:
metadata
(
inline_asm_name
)
.
is_ok
(
)
;
let
os
=
var
(
"
CARGO_CFG_TARGET_OS
"
)
.
unwrap
(
)
;
let
pointer_width
=
var
(
"
CARGO_CFG_TARGET_POINTER_WIDTH
"
)
.
unwrap
(
)
;
let
endian
=
var
(
"
CARGO_CFG_TARGET_ENDIAN
"
)
.
unwrap
(
)
;
let
is_x32
=
arch
=
=
"
x86_64
"
&
&
pointer_width
=
=
"
32
"
;
let
is_arm64_ilp32
=
arch
=
=
"
aarch64
"
&
&
pointer_width
=
=
"
32
"
;
let
is_powerpc64be
=
arch
=
=
"
powerpc64
"
&
&
endian
=
=
"
big
"
;
let
is_mipseb
=
(
arch
=
=
"
mips
"
|
|
arch
=
=
"
mips32r6
"
)
&
&
endian
=
=
"
big
"
;
let
is_mips64eb
=
arch
.
contains
(
"
mips64
"
)
&
&
endian
=
=
"
big
"
;
let
is_unsupported_abi
=
is_x32
|
|
is_arm64_ilp32
|
|
is_powerpc64be
|
|
is_mipseb
|
|
is_mips64eb
;
let
feature_use_libc
=
var
(
"
CARGO_FEATURE_USE_LIBC
"
)
.
is_ok
(
)
;
let
cfg_use_libc
=
var
(
"
CARGO_CFG_RUSTIX_USE_LIBC
"
)
.
is_ok
(
)
;
let
rustc_dep_of_std
=
var
(
"
CARGO_FEATURE_RUSTC_DEP_OF_STD
"
)
.
is_ok
(
)
;
let
rustix_use_experimental_features
=
var
(
"
CARGO_CFG_RUSTIX_USE_EXPERIMENTAL_FEATURES
"
)
.
is_ok
(
)
;
let
rustix_use_experimental_asm
=
var
(
"
CARGO_CFG_RUSTIX_USE_EXPERIMENTAL_ASM
"
)
.
is_ok
(
)
;
let
miri
=
var
(
"
CARGO_CFG_MIRI
"
)
.
is_ok
(
)
;
if
rustc_dep_of_std
{
use_feature
(
"
rustc_attrs
"
)
;
use_feature
(
"
core_intrinsics
"
)
;
}
else
if
rustix_use_experimental_features
{
use_feature_or_nothing
(
"
rustc_attrs
"
)
;
use_feature_or_nothing
(
"
core_intrinsics
"
)
;
}
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
{
use_feature_or_nothing
(
"
core_c_str
"
)
;
use_feature_or_nothing
(
"
core_ffi_c
"
)
;
use_feature_or_nothing
(
"
alloc_c_string
"
)
;
use_feature_or_nothing
(
"
alloc_ffi
"
)
;
}
if
use_static_assertions
(
)
{
use_feature
(
"
static_assertions
"
)
;
}
if
os
=
=
"
wasi
"
{
use_feature_or_nothing
(
"
wasi_ext
"
)
;
}
let
libc
=
feature_use_libc
|
|
cfg_use_libc
|
|
os
!
=
"
linux
"
|
|
!
inline_asm_name_present
|
|
is_unsupported_abi
|
|
miri
|
|
(
(
arch
=
=
"
powerpc64
"
|
|
arch
=
=
"
mips
"
|
|
arch
=
=
"
mips64
"
|
|
arch
=
=
"
mips64r6
"
)
&
&
!
rustix_use_experimental_asm
)
;
if
libc
{
use_feature
(
"
libc
"
)
;
}
else
{
use_feature
(
"
linux_raw
"
)
;
if
rustix_use_experimental_asm
{
use_feature
(
"
asm_experimental_arch
"
)
;
}
}
if
arch
=
=
"
arm
"
&
&
use_thumb_mode
(
)
{
use_feature
(
"
thumb_mode
"
)
;
}
let
freebsdlike
=
os
=
=
"
freebsd
"
|
|
os
=
=
"
dragonfly
"
;
if
freebsdlike
{
use_feature
(
"
freebsdlike
"
)
;
}
let
netbsdlike
=
os
=
=
"
openbsd
"
|
|
os
=
=
"
netbsd
"
;
if
netbsdlike
{
use_feature
(
"
netbsdlike
"
)
;
}
let
apple
=
os
=
=
"
macos
"
|
|
os
=
=
"
ios
"
|
|
os
=
=
"
tvos
"
|
|
os
=
=
"
watchos
"
;
if
apple
{
use_feature
(
"
apple
"
)
;
}
if
os
=
=
"
linux
"
|
|
os
=
=
"
l4re
"
|
|
os
=
=
"
android
"
|
|
os
=
=
"
emscripten
"
{
use_feature
(
"
linux_like
"
)
;
}
if
os
=
=
"
solaris
"
|
|
os
=
=
"
illumos
"
{
use_feature
(
"
solarish
"
)
;
}
if
apple
|
|
freebsdlike
|
|
netbsdlike
{
use_feature
(
"
bsd
"
)
;
}
if
os
=
=
"
android
"
|
|
os
=
=
"
linux
"
{
use_feature
(
"
linux_kernel
"
)
;
}
if
libc
&
&
(
arch
=
=
"
arm
"
|
|
arch
=
=
"
mips
"
|
|
arch
=
=
"
sparc
"
|
|
arch
=
=
"
x86
"
|
|
(
arch
=
=
"
wasm32
"
&
&
os
=
=
"
emscripten
"
)
)
&
&
(
apple
|
|
os
=
=
"
android
"
|
|
os
=
=
"
emscripten
"
|
|
os
=
=
"
haiku
"
|
|
env
=
=
"
gnu
"
|
|
(
env
=
=
"
musl
"
&
&
arch
=
=
"
x86
"
)
)
{
use_feature
(
"
fix_y2038
"
)
;
}
println
!
(
"
cargo
:
rerun
-
if
-
env
-
changed
=
CARGO_CFG_RUSTIX_USE_EXPERIMENTAL_ASM
"
)
;
println
!
(
"
cargo
:
rerun
-
if
-
env
-
changed
=
CARGO_CFG_RUSTIX_USE_LIBC
"
)
;
println
!
(
"
cargo
:
rerun
-
if
-
env
-
changed
=
CARGO_FEATURE_USE_LIBC
"
)
;
println
!
(
"
cargo
:
rerun
-
if
-
env
-
changed
=
CARGO_FEATURE_RUSTC_DEP_OF_STD
"
)
;
println
!
(
"
cargo
:
rerun
-
if
-
env
-
changed
=
CARGO_CFG_MIRI
"
)
;
}
fn
use_static_assertions
(
)
-
>
bool
{
can_compile
(
"
const
unsafe
fn
foo
(
p
:
*
const
u8
)
-
>
isize
{
p
.
offset_from
(
p
)
}
"
)
}
fn
use_thumb_mode
(
)
-
>
bool
{
!
can_compile
(
"
pub
unsafe
fn
f
(
)
{
core
:
:
arch
:
:
asm
!
(
\
"
udf
#
16
\
"
in
(
\
"
r7
\
"
)
0
)
;
}
"
)
}
fn
use_feature_or_nothing
(
feature
:
&
str
)
{
if
has_feature
(
feature
)
{
use_feature
(
feature
)
;
}
}
fn
use_feature
(
feature
:
&
str
)
{
println
!
(
"
cargo
:
rustc
-
cfg
=
{
}
"
feature
)
;
}
fn
has_feature
(
feature
:
&
str
)
-
>
bool
{
can_compile
(
format
!
(
"
#
!
[
allow
(
stable_features
)
]
\
n
#
!
[
feature
(
{
}
)
]
"
feature
)
)
}
fn
can_compile
<
T
:
AsRef
<
str
>
>
(
test
:
T
)
-
>
bool
{
use
std
:
:
process
:
:
Stdio
;
let
out_dir
=
var
(
"
OUT_DIR
"
)
.
unwrap
(
)
;
let
rustc
=
var
(
"
RUSTC
"
)
.
unwrap
(
)
;
let
target
=
var
(
"
TARGET
"
)
.
unwrap
(
)
;
let
wrapper
=
var
(
"
RUSTC_WRAPPER
"
)
.
ok
(
)
.
and_then
(
|
w
|
if
w
.
is_empty
(
)
{
None
}
else
{
Some
(
w
)
}
)
;
let
mut
cmd
=
if
let
Some
(
wrapper
)
=
wrapper
{
let
mut
cmd
=
std
:
:
process
:
:
Command
:
:
new
(
wrapper
)
;
cmd
.
arg
(
rustc
)
;
cmd
}
else
{
std
:
:
process
:
:
Command
:
:
new
(
rustc
)
}
;
cmd
.
arg
(
"
-
-
crate
-
type
=
rlib
"
)
.
arg
(
"
-
-
emit
=
metadata
"
)
.
arg
(
"
-
-
target
"
)
.
arg
(
target
)
.
arg
(
"
-
-
out
-
dir
"
)
.
arg
(
out_dir
)
;
if
let
Ok
(
rustflags
)
=
var
(
"
CARGO_ENCODED_RUSTFLAGS
"
)
{
if
!
rustflags
.
is_empty
(
)
{
for
arg
in
rustflags
.
split
(
'
\
x1f
'
)
{
cmd
.
arg
(
arg
)
;
}
}
}
let
mut
child
=
cmd
.
arg
(
"
-
"
)
.
stdin
(
Stdio
:
:
piped
(
)
)
.
stderr
(
Stdio
:
:
null
(
)
)
.
spawn
(
)
.
unwrap
(
)
;
writeln
!
(
child
.
stdin
.
take
(
)
.
unwrap
(
)
"
{
}
"
test
.
as_ref
(
)
)
.
unwrap
(
)
;
child
.
wait
(
)
.
unwrap
(
)
.
success
(
)
}
