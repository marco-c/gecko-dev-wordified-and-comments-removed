#
!
[
allow
(
unsafe_code
)
]
use
crate
:
:
backend
:
:
{
self
c
}
;
use
crate
:
:
fd
:
:
{
AsFd
BorrowedFd
OwnedFd
}
;
use
crate
:
:
io
:
:
{
self
IoSlice
IoSliceMut
}
;
use
core
:
:
iter
:
:
FusedIterator
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
:
:
{
size_of
size_of_val
take
}
;
use
core
:
:
{
ptr
slice
}
;
use
super
:
:
{
RecvFlags
SendFlags
SocketAddrAny
SocketAddrV4
SocketAddrV6
}
;
#
[
macro_export
]
macro_rules
!
cmsg_space
{
(
ScmRights
(
len
:
expr
)
)
=
>
{
crate
:
:
net
:
:
__cmsg_space
(
len
*
:
:
core
:
:
mem
:
:
size_of
:
:
<
crate
:
:
fd
:
:
BorrowedFd
<
'
static
>
>
(
)
)
}
;
(
(
(
(
x
:
tt
)
*
)
+
)
)
=
>
{
(
cmsg_space
!
(
(
x
)
*
)
+
)
+
0
}
;
}
#
[
doc
(
hidden
)
]
pub
fn
__cmsg_space
(
len
:
usize
)
-
>
usize
{
unsafe
{
c
:
:
CMSG_SPACE
(
len
.
try_into
(
)
.
expect
(
"
CMSG_SPACE
size
overflow
"
)
)
as
usize
}
}
#
[
non_exhaustive
]
pub
enum
SendAncillaryMessage
<
'
slice
'
fd
>
{
ScmRights
(
&
'
slice
[
BorrowedFd
<
'
fd
>
]
)
}
impl
SendAncillaryMessage
<
'
_
'
_
>
{
pub
fn
size
(
&
self
)
-
>
usize
{
let
total_bytes
=
match
self
{
Self
:
:
ScmRights
(
slice
)
=
>
size_of_val
(
*
slice
)
}
;
unsafe
{
c
:
:
CMSG_SPACE
(
total_bytes
.
try_into
(
)
.
expect
(
"
size
too
large
for
CMSG_SPACE
"
)
)
as
usize
}
}
}
#
[
non_exhaustive
]
pub
enum
RecvAncillaryMessage
<
'
a
>
{
ScmRights
(
AncillaryIter
<
'
a
OwnedFd
>
)
}
pub
struct
SendAncillaryBuffer
<
'
buf
'
slice
'
fd
>
{
buffer
:
&
'
buf
mut
[
u8
]
length
:
usize
_phantom
:
PhantomData
<
&
'
slice
[
BorrowedFd
<
'
fd
>
]
>
}
impl
<
'
buf
>
From
<
&
'
buf
mut
[
u8
]
>
for
SendAncillaryBuffer
<
'
buf
'
_
'
_
>
{
fn
from
(
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
Self
{
Self
:
:
new
(
buffer
)
}
}
impl
Default
for
SendAncillaryBuffer
<
'
_
'
_
'
_
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
&
mut
[
]
)
}
}
impl
<
'
buf
'
slice
'
fd
>
SendAncillaryBuffer
<
'
buf
'
slice
'
fd
>
{
pub
fn
new
(
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
Self
{
Self
{
buffer
length
:
0
_phantom
:
PhantomData
}
}
pub
(
crate
)
fn
as_control_ptr
(
&
mut
self
)
-
>
*
mut
u8
{
#
[
cfg
(
not
(
linux_kernel
)
)
]
if
self
.
length
=
=
0
{
return
core
:
:
ptr
:
:
null_mut
(
)
;
}
self
.
buffer
.
as_mut_ptr
(
)
}
pub
(
crate
)
fn
control_len
(
&
self
)
-
>
usize
{
self
.
length
}
pub
fn
clear
(
&
mut
self
)
{
self
.
length
=
0
;
}
pub
fn
push
(
&
mut
self
msg
:
SendAncillaryMessage
<
'
slice
'
fd
>
)
-
>
bool
{
match
msg
{
SendAncillaryMessage
:
:
ScmRights
(
fds
)
=
>
{
let
fds_bytes
=
unsafe
{
slice
:
:
from_raw_parts
(
fds
.
as_ptr
(
)
.
cast
:
:
<
u8
>
(
)
size_of_val
(
fds
)
)
}
;
self
.
push_ancillary
(
fds_bytes
c
:
:
SOL_SOCKET
as
_
c
:
:
SCM_RIGHTS
as
_
)
}
}
}
fn
push_ancillary
(
&
mut
self
source
:
&
[
u8
]
cmsg_level
:
c
:
:
c_int
cmsg_type
:
c
:
:
c_int
)
-
>
bool
{
macro_rules
!
leap
{
(
e
:
expr
)
=
>
{
{
match
(
e
)
{
Some
(
x
)
=
>
x
None
=
>
return
false
}
}
}
;
}
let
source_len
=
leap
!
(
u32
:
:
try_from
(
source
.
len
(
)
)
.
ok
(
)
)
;
let
additional_space
=
unsafe
{
c
:
:
CMSG_SPACE
(
source_len
)
}
;
let
new_length
=
leap
!
(
self
.
length
.
checked_add
(
additional_space
as
usize
)
)
;
let
buffer
=
leap
!
(
self
.
buffer
.
get_mut
(
.
.
new_length
)
)
;
buffer
[
self
.
length
.
.
new_length
]
.
fill
(
0
)
;
self
.
length
=
new_length
;
let
last_header
=
leap
!
(
messages
:
:
Messages
:
:
new
(
buffer
)
.
last
(
)
)
;
last_header
.
cmsg_len
=
unsafe
{
c
:
:
CMSG_LEN
(
source_len
)
}
as
_
;
last_header
.
cmsg_level
=
cmsg_level
;
last_header
.
cmsg_type
=
cmsg_type
;
unsafe
{
let
payload
=
c
:
:
CMSG_DATA
(
last_header
)
;
ptr
:
:
copy_nonoverlapping
(
source
.
as_ptr
(
)
payload
source_len
as
_
)
;
}
true
}
}
impl
<
'
slice
'
fd
>
Extend
<
SendAncillaryMessage
<
'
slice
'
fd
>
>
for
SendAncillaryBuffer
<
'
_
'
slice
'
fd
>
{
fn
extend
<
T
:
IntoIterator
<
Item
=
SendAncillaryMessage
<
'
slice
'
fd
>
>
>
(
&
mut
self
iter
:
T
)
{
iter
.
into_iter
(
)
.
all
(
|
msg
|
self
.
push
(
msg
)
)
;
}
}
pub
struct
RecvAncillaryBuffer
<
'
buf
>
{
buffer
:
&
'
buf
mut
[
u8
]
read
:
usize
length
:
usize
}
impl
<
'
buf
>
From
<
&
'
buf
mut
[
u8
]
>
for
RecvAncillaryBuffer
<
'
buf
>
{
fn
from
(
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
Self
{
Self
:
:
new
(
buffer
)
}
}
impl
Default
for
RecvAncillaryBuffer
<
'
_
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
&
mut
[
]
)
}
}
impl
<
'
buf
>
RecvAncillaryBuffer
<
'
buf
>
{
pub
fn
new
(
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
Self
{
Self
{
buffer
read
:
0
length
:
0
}
}
pub
(
crate
)
fn
as_control_ptr
(
&
mut
self
)
-
>
*
mut
u8
{
#
[
cfg
(
not
(
linux_kernel
)
)
]
if
self
.
buffer
.
is_empty
(
)
{
return
core
:
:
ptr
:
:
null_mut
(
)
;
}
self
.
buffer
.
as_mut_ptr
(
)
}
pub
(
crate
)
fn
control_len
(
&
self
)
-
>
usize
{
self
.
buffer
.
len
(
)
}
pub
(
crate
)
unsafe
fn
set_control_len
(
&
mut
self
len
:
usize
)
{
self
.
length
=
len
;
self
.
read
=
0
;
}
pub
(
crate
)
fn
clear
(
&
mut
self
)
{
self
.
drain
(
)
.
for_each
(
drop
)
;
}
pub
fn
drain
(
&
mut
self
)
-
>
AncillaryDrain
<
'
_
>
{
AncillaryDrain
{
messages
:
messages
:
:
Messages
:
:
new
(
&
mut
self
.
buffer
[
self
.
read
.
.
]
[
.
.
self
.
length
]
)
read
:
&
mut
self
.
read
length
:
&
mut
self
.
length
}
}
}
impl
Drop
for
RecvAncillaryBuffer
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
self
.
clear
(
)
;
}
}
pub
struct
AncillaryDrain
<
'
buf
>
{
messages
:
messages
:
:
Messages
<
'
buf
>
read
:
&
'
buf
mut
usize
length
:
&
'
buf
mut
usize
}
impl
<
'
buf
>
AncillaryDrain
<
'
buf
>
{
fn
cvt_msg
(
read
:
&
mut
usize
length
:
&
mut
usize
msg
:
&
c
:
:
cmsghdr
)
-
>
Option
<
RecvAncillaryMessage
<
'
buf
>
>
{
unsafe
{
let
msg_len
=
msg
.
cmsg_len
as
usize
;
*
read
+
=
msg_len
;
*
length
-
=
msg_len
;
let
payload
=
c
:
:
CMSG_DATA
(
msg
)
;
let
payload_len
=
msg
.
cmsg_len
as
usize
-
c
:
:
CMSG_LEN
(
0
)
as
usize
;
let
payload
:
&
'
buf
mut
[
u8
]
=
slice
:
:
from_raw_parts_mut
(
payload
payload_len
)
;
let
(
level
msg_type
)
=
(
msg
.
cmsg_level
msg
.
cmsg_type
)
;
match
(
level
as
_
msg_type
as
_
)
{
(
c
:
:
SOL_SOCKET
c
:
:
SCM_RIGHTS
)
=
>
{
let
fds
=
AncillaryIter
:
:
new
(
payload
)
;
Some
(
RecvAncillaryMessage
:
:
ScmRights
(
fds
)
)
}
_
=
>
None
}
}
}
}
impl
<
'
buf
>
Iterator
for
AncillaryDrain
<
'
buf
>
{
type
Item
=
RecvAncillaryMessage
<
'
buf
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
read
=
&
mut
self
.
read
;
let
length
=
&
mut
self
.
length
;
self
.
messages
.
find_map
(
|
ev
|
Self
:
:
cvt_msg
(
read
length
ev
)
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
(
_
max
)
=
self
.
messages
.
size_hint
(
)
;
(
0
max
)
}
fn
fold
<
B
F
>
(
self
init
:
B
f
:
F
)
-
>
B
where
Self
:
Sized
F
:
FnMut
(
B
Self
:
:
Item
)
-
>
B
{
let
read
=
self
.
read
;
let
length
=
self
.
length
;
self
.
messages
.
filter_map
(
|
ev
|
Self
:
:
cvt_msg
(
read
length
ev
)
)
.
fold
(
init
f
)
}
fn
count
(
self
)
-
>
usize
{
let
read
=
self
.
read
;
let
length
=
self
.
length
;
self
.
messages
.
filter_map
(
|
ev
|
Self
:
:
cvt_msg
(
read
length
ev
)
)
.
count
(
)
}
fn
last
(
self
)
-
>
Option
<
Self
:
:
Item
>
where
Self
:
Sized
{
let
read
=
self
.
read
;
let
length
=
self
.
length
;
self
.
messages
.
filter_map
(
|
ev
|
Self
:
:
cvt_msg
(
read
length
ev
)
)
.
last
(
)
}
fn
collect
<
B
:
FromIterator
<
Self
:
:
Item
>
>
(
self
)
-
>
B
where
Self
:
Sized
{
let
read
=
self
.
read
;
let
length
=
self
.
length
;
self
.
messages
.
filter_map
(
|
ev
|
Self
:
:
cvt_msg
(
read
length
ev
)
)
.
collect
(
)
}
}
impl
FusedIterator
for
AncillaryDrain
<
'
_
>
{
}
#
[
inline
]
pub
fn
sendmsg
(
socket
:
impl
AsFd
iov
:
&
[
IoSlice
<
'
_
>
]
control
:
&
mut
SendAncillaryBuffer
<
'
_
'
_
'
_
>
flags
:
SendFlags
)
-
>
io
:
:
Result
<
usize
>
{
backend
:
:
net
:
:
syscalls
:
:
sendmsg
(
socket
.
as_fd
(
)
iov
control
flags
)
}
#
[
inline
]
pub
fn
sendmsg_v4
(
socket
:
impl
AsFd
addr
:
&
SocketAddrV4
iov
:
&
[
IoSlice
<
'
_
>
]
control
:
&
mut
SendAncillaryBuffer
<
'
_
'
_
'
_
>
flags
:
SendFlags
)
-
>
io
:
:
Result
<
usize
>
{
backend
:
:
net
:
:
syscalls
:
:
sendmsg_v4
(
socket
.
as_fd
(
)
addr
iov
control
flags
)
}
#
[
inline
]
pub
fn
sendmsg_v6
(
socket
:
impl
AsFd
addr
:
&
SocketAddrV6
iov
:
&
[
IoSlice
<
'
_
>
]
control
:
&
mut
SendAncillaryBuffer
<
'
_
'
_
'
_
>
flags
:
SendFlags
)
-
>
io
:
:
Result
<
usize
>
{
backend
:
:
net
:
:
syscalls
:
:
sendmsg_v6
(
socket
.
as_fd
(
)
addr
iov
control
flags
)
}
#
[
inline
]
#
[
cfg
(
unix
)
]
pub
fn
sendmsg_unix
(
socket
:
impl
AsFd
addr
:
&
super
:
:
SocketAddrUnix
iov
:
&
[
IoSlice
<
'
_
>
]
control
:
&
mut
SendAncillaryBuffer
<
'
_
'
_
'
_
>
flags
:
SendFlags
)
-
>
io
:
:
Result
<
usize
>
{
backend
:
:
net
:
:
syscalls
:
:
sendmsg_unix
(
socket
.
as_fd
(
)
addr
iov
control
flags
)
}
#
[
inline
]
pub
fn
sendmsg_any
(
socket
:
impl
AsFd
addr
:
Option
<
&
SocketAddrAny
>
iov
:
&
[
IoSlice
<
'
_
>
]
control
:
&
mut
SendAncillaryBuffer
<
'
_
'
_
'
_
>
flags
:
SendFlags
)
-
>
io
:
:
Result
<
usize
>
{
match
addr
{
None
=
>
backend
:
:
net
:
:
syscalls
:
:
sendmsg
(
socket
.
as_fd
(
)
iov
control
flags
)
Some
(
SocketAddrAny
:
:
V4
(
addr
)
)
=
>
{
backend
:
:
net
:
:
syscalls
:
:
sendmsg_v4
(
socket
.
as_fd
(
)
addr
iov
control
flags
)
}
Some
(
SocketAddrAny
:
:
V6
(
addr
)
)
=
>
{
backend
:
:
net
:
:
syscalls
:
:
sendmsg_v6
(
socket
.
as_fd
(
)
addr
iov
control
flags
)
}
#
[
cfg
(
unix
)
]
Some
(
SocketAddrAny
:
:
Unix
(
addr
)
)
=
>
{
backend
:
:
net
:
:
syscalls
:
:
sendmsg_unix
(
socket
.
as_fd
(
)
addr
iov
control
flags
)
}
}
}
#
[
inline
]
pub
fn
recvmsg
(
socket
:
impl
AsFd
iov
:
&
mut
[
IoSliceMut
<
'
_
>
]
control
:
&
mut
RecvAncillaryBuffer
<
'
_
>
flags
:
RecvFlags
)
-
>
io
:
:
Result
<
RecvMsgReturn
>
{
backend
:
:
net
:
:
syscalls
:
:
recvmsg
(
socket
.
as_fd
(
)
iov
control
flags
)
}
pub
struct
RecvMsgReturn
{
pub
bytes
:
usize
pub
flags
:
RecvFlags
pub
address
:
Option
<
SocketAddrAny
>
}
pub
struct
AncillaryIter
<
'
data
T
>
{
data
:
&
'
data
mut
[
u8
]
_marker
:
PhantomData
<
T
>
}
impl
<
'
data
T
>
AncillaryIter
<
'
data
T
>
{
unsafe
fn
new
(
data
:
&
'
data
mut
[
u8
]
)
-
>
Self
{
assert_eq
!
(
data
.
len
(
)
%
size_of
:
:
<
T
>
(
)
0
)
;
Self
{
data
_marker
:
PhantomData
}
}
}
impl
<
'
data
T
>
Drop
for
AncillaryIter
<
'
data
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
for_each
(
drop
)
;
}
}
impl
<
T
>
Iterator
for
AncillaryIter
<
'
_
T
>
{
type
Item
=
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
data
.
len
(
)
<
size_of
:
:
<
T
>
(
)
{
return
None
;
}
let
item
=
unsafe
{
self
.
data
.
as_ptr
(
)
.
cast
:
:
<
T
>
(
)
.
read_unaligned
(
)
}
;
let
data
=
take
(
&
mut
self
.
data
)
;
self
.
data
=
&
mut
data
[
size_of
:
:
<
T
>
(
)
.
.
]
;
Some
(
item
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
len
=
self
.
len
(
)
;
(
len
Some
(
len
)
)
}
fn
count
(
self
)
-
>
usize
{
self
.
len
(
)
}
fn
last
(
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
next_back
(
)
}
}
impl
<
T
>
FusedIterator
for
AncillaryIter
<
'
_
T
>
{
}
impl
<
T
>
ExactSizeIterator
for
AncillaryIter
<
'
_
T
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
data
.
len
(
)
/
size_of
:
:
<
T
>
(
)
}
}
impl
<
T
>
DoubleEndedIterator
for
AncillaryIter
<
'
_
T
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
data
.
len
(
)
<
size_of
:
:
<
T
>
(
)
{
return
None
;
}
let
item
=
unsafe
{
let
ptr
=
self
.
data
.
as_ptr
(
)
.
add
(
self
.
data
.
len
(
)
-
size_of
:
:
<
T
>
(
)
)
;
ptr
.
cast
:
:
<
T
>
(
)
.
read_unaligned
(
)
}
;
let
len
=
self
.
data
.
len
(
)
;
let
data
=
take
(
&
mut
self
.
data
)
;
self
.
data
=
&
mut
data
[
.
.
len
-
size_of
:
:
<
T
>
(
)
]
;
Some
(
item
)
}
}
mod
messages
{
use
crate
:
:
backend
:
:
c
;
use
crate
:
:
backend
:
:
net
:
:
msghdr
;
use
core
:
:
iter
:
:
FusedIterator
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
ptr
:
:
NonNull
;
pub
(
super
)
struct
Messages
<
'
buf
>
{
msghdr
:
c
:
:
msghdr
header
:
Option
<
NonNull
<
c
:
:
cmsghdr
>
>
_buffer
:
PhantomData
<
&
'
buf
mut
[
u8
]
>
}
impl
<
'
buf
>
Messages
<
'
buf
>
{
pub
(
super
)
fn
new
(
buf
:
&
'
buf
mut
[
u8
]
)
-
>
Self
{
let
msghdr
=
{
let
mut
h
=
msghdr
:
:
zero_msghdr
(
)
;
h
.
msg_control
=
buf
.
as_mut_ptr
(
)
.
cast
(
)
;
h
.
msg_controllen
=
buf
.
len
(
)
.
try_into
(
)
.
expect
(
"
buffer
too
large
for
msghdr
"
)
;
h
}
;
let
header
=
NonNull
:
:
new
(
unsafe
{
c
:
:
CMSG_FIRSTHDR
(
&
msghdr
)
}
)
;
Self
{
msghdr
header
_buffer
:
PhantomData
}
}
}
impl
<
'
a
>
Iterator
for
Messages
<
'
a
>
{
type
Item
=
&
'
a
mut
c
:
:
cmsghdr
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
header
=
self
.
header
?
;
self
.
header
=
NonNull
:
:
new
(
unsafe
{
c
:
:
CMSG_NXTHDR
(
&
self
.
msghdr
header
.
as_ptr
(
)
)
}
)
;
if
Some
(
header
)
=
=
self
.
header
{
self
.
header
=
None
;
}
Some
(
unsafe
{
&
mut
*
header
.
as_ptr
(
)
}
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
if
self
.
header
.
is_some
(
)
{
let
max_size
=
unsafe
{
c
:
:
CMSG_LEN
(
0
)
}
as
usize
;
let
remaining_count
=
self
.
msghdr
.
msg_controllen
as
usize
/
max_size
;
(
1
Some
(
remaining_count
)
)
}
else
{
(
0
Some
(
0
)
)
}
}
}
impl
FusedIterator
for
Messages
<
'
_
>
{
}
}
