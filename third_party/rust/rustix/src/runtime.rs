#
!
[
allow
(
unsafe_code
)
]
use
crate
:
:
backend
;
#
[
cfg
(
linux_raw
)
]
use
crate
:
:
ffi
:
:
CStr
;
#
[
cfg
(
linux_raw
)
]
#
[
cfg
(
feature
=
"
fs
"
)
]
use
crate
:
:
fs
:
:
AtFlags
;
#
[
cfg
(
linux_raw
)
]
use
crate
:
:
io
;
#
[
cfg
(
linux_raw
)
]
use
crate
:
:
pid
:
:
Pid
;
#
[
cfg
(
linux_raw
)
]
#
[
cfg
(
feature
=
"
fs
"
)
]
use
backend
:
:
fd
:
:
AsFd
;
#
[
cfg
(
linux_raw
)
]
use
core
:
:
ffi
:
:
c_void
;
#
[
cfg
(
linux_raw
)
]
pub
use
crate
:
:
signal
:
:
Signal
;
#
[
cfg
(
linux_raw
)
]
pub
type
Sigaction
=
linux_raw_sys
:
:
general
:
:
kernel_sigaction
;
#
[
cfg
(
linux_raw
)
]
pub
type
Stack
=
linux_raw_sys
:
:
general
:
:
stack_t
;
#
[
cfg
(
linux_raw
)
]
pub
type
Sigset
=
linux_raw_sys
:
:
general
:
:
kernel_sigset_t
;
#
[
cfg
(
linux_raw
)
]
pub
type
Siginfo
=
linux_raw_sys
:
:
general
:
:
siginfo_t
;
pub
use
crate
:
:
timespec
:
:
{
Nsecs
Secs
Timespec
}
;
#
[
cfg
(
linux_raw
)
]
#
[
repr
(
u32
)
]
pub
enum
How
{
BLOCK
=
linux_raw_sys
:
:
general
:
:
SIG_BLOCK
UNBLOCK
=
linux_raw_sys
:
:
general
:
:
SIG_UNBLOCK
SETMASK
=
linux_raw_sys
:
:
general
:
:
SIG_SETMASK
}
#
[
cfg
(
target_arch
=
"
x86
"
)
]
#
[
inline
]
pub
unsafe
fn
set_thread_area
(
u_info
:
&
mut
UserDesc
)
-
>
io
:
:
Result
<
(
)
>
{
backend
:
:
runtime
:
:
syscalls
:
:
tls
:
:
set_thread_area
(
u_info
)
}
#
[
cfg
(
target_arch
=
"
arm
"
)
]
#
[
inline
]
pub
unsafe
fn
arm_set_tls
(
data
:
*
mut
c_void
)
-
>
io
:
:
Result
<
(
)
>
{
backend
:
:
runtime
:
:
syscalls
:
:
tls
:
:
arm_set_tls
(
data
)
}
#
[
cfg
(
target_arch
=
"
x86_64
"
)
]
#
[
inline
]
pub
unsafe
fn
set_fs
(
data
:
*
mut
c_void
)
{
backend
:
:
runtime
:
:
syscalls
:
:
tls
:
:
set_fs
(
data
)
}
#
[
inline
]
pub
unsafe
fn
set_tid_address
(
data
:
*
mut
c_void
)
-
>
Pid
{
backend
:
:
runtime
:
:
syscalls
:
:
tls
:
:
set_tid_address
(
data
)
}
#
[
cfg
(
linux_raw
)
]
#
[
cfg
(
target_arch
=
"
x86
"
)
]
pub
use
backend
:
:
runtime
:
:
tls
:
:
UserDesc
;
#
[
inline
]
pub
unsafe
fn
exit_thread
(
status
:
i32
)
-
>
!
{
backend
:
:
runtime
:
:
syscalls
:
:
tls
:
:
exit_thread
(
status
)
}
#
[
doc
(
alias
=
"
_exit
"
)
]
#
[
doc
(
alias
=
"
_Exit
"
)
]
#
[
inline
]
pub
fn
exit_group
(
status
:
i32
)
-
>
!
{
backend
:
:
runtime
:
:
syscalls
:
:
exit_group
(
status
)
}
pub
const
EXIT_SUCCESS
:
i32
=
backend
:
:
c
:
:
EXIT_SUCCESS
;
pub
const
EXIT_FAILURE
:
i32
=
backend
:
:
c
:
:
EXIT_FAILURE
;
#
[
inline
]
pub
fn
startup_tls_info
(
)
-
>
StartupTlsInfo
{
backend
:
:
runtime
:
:
tls
:
:
startup_tls_info
(
)
}
#
[
inline
]
pub
fn
exe_phdrs
(
)
-
>
(
*
const
c_void
usize
usize
)
{
backend
:
:
param
:
:
auxv
:
:
exe_phdrs
(
)
}
#
[
inline
]
pub
fn
entry
(
)
-
>
usize
{
backend
:
:
param
:
:
auxv
:
:
entry
(
)
}
#
[
inline
]
pub
fn
random
(
)
-
>
*
const
[
u8
;
16
]
{
backend
:
:
param
:
:
auxv
:
:
random
(
)
}
#
[
cfg
(
linux_raw
)
]
pub
use
backend
:
:
runtime
:
:
tls
:
:
StartupTlsInfo
;
pub
unsafe
fn
fork
(
)
-
>
io
:
:
Result
<
Fork
>
{
backend
:
:
runtime
:
:
syscalls
:
:
fork
(
)
}
pub
enum
Fork
{
Child
(
Pid
)
Parent
(
Pid
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
fs
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
fs
"
)
)
)
]
pub
unsafe
fn
execveat
<
Fd
:
AsFd
>
(
dirfd
:
Fd
path
:
&
CStr
argv
:
*
const
*
const
u8
envp
:
*
const
*
const
u8
flags
:
AtFlags
)
-
>
io
:
:
Errno
{
backend
:
:
runtime
:
:
syscalls
:
:
execveat
(
dirfd
.
as_fd
(
)
path
argv
envp
flags
)
}
#
[
inline
]
pub
unsafe
fn
execve
(
path
:
&
CStr
argv
:
*
const
*
const
u8
envp
:
*
const
*
const
u8
)
-
>
io
:
:
Errno
{
backend
:
:
runtime
:
:
syscalls
:
:
execve
(
path
argv
envp
)
}
#
[
inline
]
pub
unsafe
fn
sigaction
(
signal
:
Signal
new
:
Option
<
Sigaction
>
)
-
>
io
:
:
Result
<
Sigaction
>
{
backend
:
:
runtime
:
:
syscalls
:
:
sigaction
(
signal
new
)
}
#
[
inline
]
pub
unsafe
fn
sigaltstack
(
new
:
Option
<
Stack
>
)
-
>
io
:
:
Result
<
Stack
>
{
backend
:
:
runtime
:
:
syscalls
:
:
sigaltstack
(
new
)
}
#
[
inline
]
pub
unsafe
fn
tkill
(
tid
:
Pid
sig
:
Signal
)
-
>
io
:
:
Result
<
(
)
>
{
backend
:
:
runtime
:
:
syscalls
:
:
tkill
(
tid
sig
)
}
#
[
inline
]
#
[
doc
(
alias
=
"
pthread_sigmask
"
)
]
#
[
doc
(
alias
=
"
rt_sigprocmask
"
)
]
pub
unsafe
fn
sigprocmask
(
how
:
How
set
:
Option
<
&
Sigset
>
)
-
>
io
:
:
Result
<
Sigset
>
{
backend
:
:
runtime
:
:
syscalls
:
:
sigprocmask
(
how
set
)
}
#
[
inline
]
pub
fn
sigpending
(
)
-
>
Sigset
{
backend
:
:
runtime
:
:
syscalls
:
:
sigpending
(
)
}
#
[
inline
]
pub
fn
sigsuspend
(
set
:
&
Sigset
)
-
>
io
:
:
Result
<
(
)
>
{
backend
:
:
runtime
:
:
syscalls
:
:
sigsuspend
(
set
)
}
#
[
inline
]
pub
unsafe
fn
sigwait
(
set
:
&
Sigset
)
-
>
io
:
:
Result
<
Signal
>
{
backend
:
:
runtime
:
:
syscalls
:
:
sigwait
(
set
)
}
#
[
inline
]
pub
unsafe
fn
sigwaitinfo
(
set
:
&
Sigset
)
-
>
io
:
:
Result
<
Siginfo
>
{
backend
:
:
runtime
:
:
syscalls
:
:
sigwaitinfo
(
set
)
}
#
[
inline
]
pub
unsafe
fn
sigtimedwait
(
set
:
&
Sigset
timeout
:
Option
<
Timespec
>
)
-
>
io
:
:
Result
<
Siginfo
>
{
backend
:
:
runtime
:
:
syscalls
:
:
sigtimedwait
(
set
timeout
)
}
#
[
cfg
(
any
(
linux_raw
any
(
all
(
target_os
=
"
android
"
target_pointer_width
=
"
64
"
)
target_os
=
"
linux
"
)
)
)
]
#
[
inline
]
pub
fn
linux_secure
(
)
-
>
bool
{
backend
:
:
param
:
:
auxv
:
:
linux_secure
(
)
}
#
[
cfg
(
linux_raw
)
]
#
[
inline
]
pub
unsafe
fn
brk
(
addr
:
*
mut
c_void
)
-
>
io
:
:
Result
<
*
mut
c_void
>
{
backend
:
:
runtime
:
:
syscalls
:
:
brk
(
addr
)
}
#
[
cfg
(
linux_raw
)
]
pub
const
SIGRTMIN
:
u32
=
linux_raw_sys
:
:
general
:
:
SIGRTMIN
;
#
[
cfg
(
linux_raw
)
]
pub
const
SIGRTMAX
:
u32
=
{
#
[
cfg
(
not
(
any
(
target_arch
=
"
arm
"
target_arch
=
"
s390x
"
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
)
]
{
linux_raw_sys
:
:
general
:
:
SIGRTMAX
}
#
[
cfg
(
any
(
target_arch
=
"
arm
"
target_arch
=
"
s390x
"
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
]
{
linux_raw_sys
:
:
general
:
:
_NSIG
-
1
}
}
;
