use
crate
:
:
process
:
:
Pid
;
use
crate
:
:
{
backend
io
}
;
use
core
:
:
{
fmt
hash
}
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
)
]
pub
struct
CpuSet
{
cpu_set
:
backend
:
:
process
:
:
types
:
:
RawCpuSet
}
impl
CpuSet
{
pub
const
MAX_CPU
:
usize
=
backend
:
:
process
:
:
types
:
:
CPU_SETSIZE
;
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Self
{
cpu_set
:
backend
:
:
process
:
:
types
:
:
raw_cpu_set_new
(
)
}
}
#
[
inline
]
pub
fn
is_set
(
&
self
field
:
usize
)
-
>
bool
{
backend
:
:
process
:
:
cpu_set
:
:
CPU_ISSET
(
field
&
self
.
cpu_set
)
}
#
[
inline
]
pub
fn
set
(
&
mut
self
field
:
usize
)
{
backend
:
:
process
:
:
cpu_set
:
:
CPU_SET
(
field
&
mut
self
.
cpu_set
)
}
#
[
inline
]
pub
fn
unset
(
&
mut
self
field
:
usize
)
{
backend
:
:
process
:
:
cpu_set
:
:
CPU_CLR
(
field
&
mut
self
.
cpu_set
)
}
#
[
cfg
(
linux_kernel
)
]
#
[
inline
]
pub
fn
count
(
&
self
)
-
>
u32
{
backend
:
:
process
:
:
cpu_set
:
:
CPU_COUNT
(
&
self
.
cpu_set
)
}
#
[
inline
]
pub
fn
clear
(
&
mut
self
)
{
backend
:
:
process
:
:
cpu_set
:
:
CPU_ZERO
(
&
mut
self
.
cpu_set
)
}
}
impl
Default
for
CpuSet
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
fmt
:
:
Debug
for
CpuSet
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
CpuSet
{
{
"
)
?
;
let
mut
first
=
true
;
for
i
in
0
.
.
Self
:
:
MAX_CPU
{
if
self
.
is_set
(
i
)
{
if
first
{
write
!
(
f
"
"
)
?
;
first
=
false
;
}
else
{
write
!
(
f
"
"
)
?
;
}
write
!
(
f
"
cpu
{
}
"
i
)
?
;
}
}
write
!
(
f
"
}
}
"
)
}
}
impl
hash
:
:
Hash
for
CpuSet
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
for
i
in
0
.
.
Self
:
:
MAX_CPU
{
self
.
is_set
(
i
)
.
hash
(
state
)
;
}
}
}
impl
Eq
for
CpuSet
{
}
impl
PartialEq
for
CpuSet
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
backend
:
:
process
:
:
cpu_set
:
:
CPU_EQUAL
(
&
self
.
cpu_set
&
other
.
cpu_set
)
}
}
#
[
inline
]
pub
fn
sched_setaffinity
(
pid
:
Option
<
Pid
>
cpuset
:
&
CpuSet
)
-
>
io
:
:
Result
<
(
)
>
{
backend
:
:
process
:
:
syscalls
:
:
sched_setaffinity
(
pid
&
cpuset
.
cpu_set
)
}
#
[
inline
]
pub
fn
sched_getaffinity
(
pid
:
Option
<
Pid
>
)
-
>
io
:
:
Result
<
CpuSet
>
{
let
mut
cpuset
=
CpuSet
:
:
new
(
)
;
backend
:
:
process
:
:
syscalls
:
:
sched_getaffinity
(
pid
&
mut
cpuset
.
cpu_set
)
.
and
(
Ok
(
cpuset
)
)
}
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
dragonfly
"
)
)
]
#
[
inline
]
pub
fn
sched_getcpu
(
)
-
>
usize
{
backend
:
:
process
:
:
syscalls
:
:
sched_getcpu
(
)
}
