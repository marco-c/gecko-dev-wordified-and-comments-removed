use
crate
:
:
process
:
:
Pid
;
use
crate
:
:
{
backend
io
}
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
struct
CpuSet
{
cpu_set
:
backend
:
:
process
:
:
types
:
:
RawCpuSet
}
impl
CpuSet
{
pub
const
MAX_CPU
:
usize
=
backend
:
:
process
:
:
types
:
:
CPU_SETSIZE
;
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Self
{
cpu_set
:
backend
:
:
process
:
:
types
:
:
raw_cpu_set_new
(
)
}
}
#
[
inline
]
pub
fn
is_set
(
&
self
field
:
usize
)
-
>
bool
{
backend
:
:
process
:
:
cpu_set
:
:
CPU_ISSET
(
field
&
self
.
cpu_set
)
}
#
[
inline
]
pub
fn
set
(
&
mut
self
field
:
usize
)
{
backend
:
:
process
:
:
cpu_set
:
:
CPU_SET
(
field
&
mut
self
.
cpu_set
)
}
#
[
inline
]
pub
fn
unset
(
&
mut
self
field
:
usize
)
{
backend
:
:
process
:
:
cpu_set
:
:
CPU_CLR
(
field
&
mut
self
.
cpu_set
)
}
#
[
cfg
(
linux_kernel
)
]
#
[
inline
]
pub
fn
count
(
&
self
)
-
>
u32
{
backend
:
:
process
:
:
cpu_set
:
:
CPU_COUNT
(
&
self
.
cpu_set
)
}
#
[
inline
]
pub
fn
clear
(
&
mut
self
)
{
backend
:
:
process
:
:
cpu_set
:
:
CPU_ZERO
(
&
mut
self
.
cpu_set
)
}
}
impl
Default
for
CpuSet
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
sched_setaffinity
(
pid
:
Option
<
Pid
>
cpuset
:
&
CpuSet
)
-
>
io
:
:
Result
<
(
)
>
{
backend
:
:
process
:
:
syscalls
:
:
sched_setaffinity
(
pid
&
cpuset
.
cpu_set
)
}
#
[
inline
]
pub
fn
sched_getaffinity
(
pid
:
Option
<
Pid
>
)
-
>
io
:
:
Result
<
CpuSet
>
{
let
mut
cpuset
=
CpuSet
:
:
new
(
)
;
backend
:
:
process
:
:
syscalls
:
:
sched_getaffinity
(
pid
&
mut
cpuset
.
cpu_set
)
.
and
(
Ok
(
cpuset
)
)
}
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
dragonfly
"
)
)
]
#
[
inline
]
pub
fn
sched_getcpu
(
)
-
>
usize
{
backend
:
:
process
:
:
syscalls
:
:
sched_getcpu
(
)
}
