use
crate
:
:
process
:
:
Pid
;
use
crate
:
:
{
backend
io
}
;
use
bitflags
:
:
bitflags
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
use
crate
:
:
fd
:
:
BorrowedFd
;
#
[
cfg
(
linux_raw
)
]
use
crate
:
:
backend
:
:
process
:
:
wait
:
:
SiginfoExt
;
bitflags
!
{
/
/
/
Options
for
modifying
the
behavior
of
[
wait
]
/
[
waitpid
]
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
WaitOptions
:
u32
{
/
/
/
Return
immediately
if
no
child
has
exited
.
const
NOHANG
=
bitcast
!
(
backend
:
:
process
:
:
wait
:
:
WNOHANG
)
;
/
/
/
Return
if
a
child
has
stopped
(
but
not
traced
via
[
ptrace
]
)
.
/
/
/
/
/
/
[
ptrace
]
:
https
:
/
/
man7
.
org
/
linux
/
man
-
pages
/
man2
/
ptrace
.
2
.
html
const
UNTRACED
=
bitcast
!
(
backend
:
:
process
:
:
wait
:
:
WUNTRACED
)
;
/
/
/
Return
if
a
stopped
child
has
been
resumed
by
delivery
of
/
/
/
[
Signal
:
:
Cont
]
.
/
/
/
/
/
/
[
Signal
:
:
Cont
]
:
crate
:
:
process
:
:
Signal
:
:
Cont
const
CONTINUED
=
bitcast
!
(
backend
:
:
process
:
:
wait
:
:
WCONTINUED
)
;
/
/
/
<
https
:
/
/
docs
.
rs
/
bitflags
/
*
/
bitflags
/
#
externally
-
defined
-
flags
>
const
_
=
!
0
;
}
}
#
[
cfg
(
not
(
any
(
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
wasi
"
)
)
)
]
bitflags
!
{
/
/
/
Options
for
modifying
the
behavior
of
[
waitid
]
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
WaitidOptions
:
u32
{
/
/
/
Return
immediately
if
no
child
has
exited
.
const
NOHANG
=
bitcast
!
(
backend
:
:
process
:
:
wait
:
:
WNOHANG
)
;
/
/
/
Return
if
a
stopped
child
has
been
resumed
by
delivery
of
/
/
/
[
Signal
:
:
Cont
]
.
/
/
/
/
/
/
[
Signal
:
:
Cont
]
:
crate
:
:
process
:
:
Signal
:
:
Cont
const
CONTINUED
=
bitcast
!
(
backend
:
:
process
:
:
wait
:
:
WCONTINUED
)
;
/
/
/
Wait
for
processed
that
have
exited
.
const
EXITED
=
bitcast
!
(
backend
:
:
process
:
:
wait
:
:
WEXITED
)
;
/
/
/
Keep
processed
in
a
waitable
state
.
const
NOWAIT
=
bitcast
!
(
backend
:
:
process
:
:
wait
:
:
WNOWAIT
)
;
/
/
/
Wait
for
processes
that
have
been
stopped
.
const
STOPPED
=
bitcast
!
(
backend
:
:
process
:
:
wait
:
:
WSTOPPED
)
;
/
/
/
<
https
:
/
/
docs
.
rs
/
bitflags
/
*
/
bitflags
/
#
externally
-
defined
-
flags
>
const
_
=
!
0
;
}
}
#
[
derive
(
Debug
Clone
Copy
)
]
#
[
repr
(
transparent
)
]
pub
struct
WaitStatus
(
u32
)
;
impl
WaitStatus
{
#
[
inline
]
pub
(
crate
)
fn
new
(
status
:
u32
)
-
>
Self
{
Self
(
status
)
}
#
[
inline
]
pub
const
fn
as_raw
(
self
)
-
>
u32
{
self
.
0
}
#
[
inline
]
pub
fn
stopped
(
self
)
-
>
bool
{
backend
:
:
process
:
:
wait
:
:
WIFSTOPPED
(
self
.
0
as
_
)
}
#
[
inline
]
pub
fn
exited
(
self
)
-
>
bool
{
backend
:
:
process
:
:
wait
:
:
WIFEXITED
(
self
.
0
as
_
)
}
#
[
inline
]
pub
fn
signaled
(
self
)
-
>
bool
{
backend
:
:
process
:
:
wait
:
:
WIFSIGNALED
(
self
.
0
as
_
)
}
#
[
inline
]
pub
fn
continued
(
self
)
-
>
bool
{
backend
:
:
process
:
:
wait
:
:
WIFCONTINUED
(
self
.
0
as
_
)
}
#
[
inline
]
pub
fn
stopping_signal
(
self
)
-
>
Option
<
u32
>
{
if
self
.
stopped
(
)
{
Some
(
backend
:
:
process
:
:
wait
:
:
WSTOPSIG
(
self
.
0
as
_
)
as
_
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
exit_status
(
self
)
-
>
Option
<
u32
>
{
if
self
.
exited
(
)
{
Some
(
backend
:
:
process
:
:
wait
:
:
WEXITSTATUS
(
self
.
0
as
_
)
as
_
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
terminating_signal
(
self
)
-
>
Option
<
u32
>
{
if
self
.
signaled
(
)
{
Some
(
backend
:
:
process
:
:
wait
:
:
WTERMSIG
(
self
.
0
as
_
)
as
_
)
}
else
{
None
}
}
}
#
[
derive
(
Clone
Copy
)
]
#
[
repr
(
transparent
)
]
#
[
cfg
(
not
(
any
(
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
wasi
"
)
)
)
]
pub
struct
WaitidStatus
(
pub
(
crate
)
backend
:
:
c
:
:
siginfo_t
)
;
#
[
cfg
(
not
(
any
(
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
wasi
"
)
)
)
]
impl
WaitidStatus
{
#
[
inline
]
pub
fn
stopped
(
&
self
)
-
>
bool
{
self
.
si_code
(
)
=
=
backend
:
:
c
:
:
CLD_STOPPED
}
#
[
inline
]
pub
fn
trapped
(
&
self
)
-
>
bool
{
self
.
si_code
(
)
=
=
backend
:
:
c
:
:
CLD_TRAPPED
}
#
[
inline
]
pub
fn
exited
(
&
self
)
-
>
bool
{
self
.
si_code
(
)
=
=
backend
:
:
c
:
:
CLD_EXITED
}
#
[
inline
]
pub
fn
killed
(
&
self
)
-
>
bool
{
self
.
si_code
(
)
=
=
backend
:
:
c
:
:
CLD_KILLED
}
#
[
inline
]
pub
fn
dumped
(
&
self
)
-
>
bool
{
self
.
si_code
(
)
=
=
backend
:
:
c
:
:
CLD_DUMPED
}
#
[
inline
]
pub
fn
continued
(
&
self
)
-
>
bool
{
self
.
si_code
(
)
=
=
backend
:
:
c
:
:
CLD_CONTINUED
}
#
[
inline
]
#
[
cfg
(
not
(
any
(
target_os
=
"
emscripten
"
target_os
=
"
fuchsia
"
target_os
=
"
netbsd
"
)
)
)
]
pub
fn
stopping_signal
(
&
self
)
-
>
Option
<
u32
>
{
if
self
.
stopped
(
)
{
Some
(
self
.
si_status
(
)
as
_
)
}
else
{
None
}
}
#
[
inline
]
#
[
cfg
(
not
(
any
(
target_os
=
"
emscripten
"
target_os
=
"
fuchsia
"
target_os
=
"
netbsd
"
)
)
)
]
pub
fn
trapping_signal
(
&
self
)
-
>
Option
<
u32
>
{
if
self
.
trapped
(
)
{
Some
(
self
.
si_status
(
)
as
_
)
}
else
{
None
}
}
#
[
inline
]
#
[
cfg
(
not
(
any
(
target_os
=
"
emscripten
"
target_os
=
"
fuchsia
"
target_os
=
"
netbsd
"
)
)
)
]
pub
fn
exit_status
(
&
self
)
-
>
Option
<
u32
>
{
if
self
.
exited
(
)
{
Some
(
self
.
si_status
(
)
as
_
)
}
else
{
None
}
}
#
[
inline
]
#
[
cfg
(
not
(
any
(
target_os
=
"
emscripten
"
target_os
=
"
fuchsia
"
target_os
=
"
netbsd
"
)
)
)
]
pub
fn
terminating_signal
(
&
self
)
-
>
Option
<
u32
>
{
if
self
.
killed
(
)
|
|
self
.
dumped
(
)
{
Some
(
self
.
si_status
(
)
as
_
)
}
else
{
None
}
}
#
[
inline
]
pub
const
fn
as_raw
(
&
self
)
-
>
&
backend
:
:
c
:
:
siginfo_t
{
&
self
.
0
}
#
[
cfg
(
linux_raw
)
]
fn
si_code
(
&
self
)
-
>
u32
{
self
.
0
.
si_code
(
)
as
u32
}
#
[
cfg
(
not
(
linux_raw
)
)
]
fn
si_code
(
&
self
)
-
>
backend
:
:
c
:
:
c_int
{
self
.
0
.
si_code
}
#
[
cfg
(
not
(
any
(
target_os
=
"
emscripten
"
target_os
=
"
fuchsia
"
target_os
=
"
netbsd
"
)
)
)
]
#
[
allow
(
unsafe_code
)
]
fn
si_status
(
&
self
)
-
>
backend
:
:
c
:
:
c_int
{
unsafe
{
self
.
0
.
si_status
(
)
}
}
}
#
[
cfg
(
not
(
any
(
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
wasi
"
)
)
)
]
#
[
derive
(
Debug
Clone
)
]
#
[
non_exhaustive
]
pub
enum
WaitId
<
'
a
>
{
#
[
doc
(
alias
=
"
P_ALL
"
)
]
All
#
[
doc
(
alias
=
"
P_PID
"
)
]
Pid
(
Pid
)
#
[
doc
(
alias
=
"
P_PGID
"
)
]
Pgid
(
Option
<
Pid
>
)
#
[
cfg
(
target_os
=
"
linux
"
)
]
#
[
doc
(
alias
=
"
P_PIDFD
"
)
]
PidFd
(
BorrowedFd
<
'
a
>
)
#
[
doc
(
hidden
)
]
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
__EatLifetime
(
core
:
:
marker
:
:
PhantomData
<
&
'
a
(
)
>
)
}
#
[
cfg
(
not
(
target_os
=
"
wasi
"
)
)
]
#
[
inline
]
pub
fn
waitpid
(
pid
:
Option
<
Pid
>
waitopts
:
WaitOptions
)
-
>
io
:
:
Result
<
Option
<
WaitStatus
>
>
{
Ok
(
backend
:
:
process
:
:
syscalls
:
:
waitpid
(
pid
waitopts
)
?
.
map
(
|
(
_
status
)
|
status
)
)
}
#
[
cfg
(
not
(
target_os
=
"
wasi
"
)
)
]
#
[
inline
]
pub
fn
waitpgid
(
pgid
:
Pid
waitopts
:
WaitOptions
)
-
>
io
:
:
Result
<
Option
<
WaitStatus
>
>
{
Ok
(
backend
:
:
process
:
:
syscalls
:
:
waitpgid
(
pgid
waitopts
)
?
.
map
(
|
(
_
status
)
|
status
)
)
}
#
[
cfg
(
not
(
target_os
=
"
wasi
"
)
)
]
#
[
inline
]
pub
fn
wait
(
waitopts
:
WaitOptions
)
-
>
io
:
:
Result
<
Option
<
(
Pid
WaitStatus
)
>
>
{
backend
:
:
process
:
:
syscalls
:
:
wait
(
waitopts
)
}
#
[
cfg
(
not
(
any
(
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
wasi
"
)
)
)
]
#
[
inline
]
pub
fn
waitid
<
'
a
>
(
id
:
impl
Into
<
WaitId
<
'
a
>
>
options
:
WaitidOptions
)
-
>
io
:
:
Result
<
Option
<
WaitidStatus
>
>
{
backend
:
:
process
:
:
syscalls
:
:
waitid
(
id
.
into
(
)
options
)
}
