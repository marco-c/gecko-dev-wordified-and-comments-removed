#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
use
crate
:
:
backend
:
:
c
;
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
#
[
cfg
(
fix_y2038
)
]
use
crate
:
:
timespec
:
:
LibcTimespec
;
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
#
[
cfg
(
fix_y2038
)
]
use
crate
:
:
timespec
:
:
Timespec
;
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
use
bitflags
:
:
bitflags
;
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
#
[
cfg
(
not
(
fix_y2038
)
)
]
pub
type
Itimerspec
=
c
:
:
itimerspec
;
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
#
[
cfg
(
fix_y2038
)
]
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Clone
)
]
pub
struct
Itimerspec
{
pub
it_interval
:
Timespec
pub
it_value
:
Timespec
}
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
#
[
cfg
(
not
(
fix_y2038
)
)
]
pub
(
crate
)
type
LibcItimerspec
=
Itimerspec
;
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
#
[
cfg
(
fix_y2038
)
]
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Clone
)
]
pub
(
crate
)
struct
LibcItimerspec
{
pub
it_interval
:
LibcTimespec
pub
it_value
:
LibcTimespec
}
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
#
[
cfg
(
fix_y2038
)
]
impl
From
<
LibcItimerspec
>
for
Itimerspec
{
#
[
inline
]
fn
from
(
t
:
LibcItimerspec
)
-
>
Self
{
Self
{
it_interval
:
t
.
it_interval
.
into
(
)
it_value
:
t
.
it_value
.
into
(
)
}
}
}
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
#
[
cfg
(
fix_y2038
)
]
impl
From
<
Itimerspec
>
for
LibcItimerspec
{
#
[
inline
]
fn
from
(
t
:
Itimerspec
)
-
>
Self
{
Self
{
it_interval
:
t
.
it_interval
.
into
(
)
it_value
:
t
.
it_value
.
into
(
)
}
}
}
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
bitflags
!
{
/
/
/
TFD_
*
flags
for
use
with
[
timerfd_create
]
.
/
/
/
/
/
/
[
timerfd_create
]
:
crate
:
:
time
:
:
timerfd_create
#
[
repr
(
transparent
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
TimerfdFlags
:
u32
{
/
/
/
TFD_NONBLOCK
const
NONBLOCK
=
bitcast
!
(
c
:
:
TFD_NONBLOCK
)
;
/
/
/
TFD_CLOEXEC
const
CLOEXEC
=
bitcast
!
(
c
:
:
TFD_CLOEXEC
)
;
/
/
/
<
https
:
/
/
docs
.
rs
/
bitflags
/
latest
/
bitflags
/
#
externally
-
defined
-
flags
>
const
_
=
!
0
;
}
}
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
bitflags
!
{
/
/
/
TFD_TIMER_
*
flags
for
use
with
[
timerfd_settime
]
.
/
/
/
/
/
/
[
timerfd_settime
]
:
crate
:
:
time
:
:
timerfd_settime
#
[
repr
(
transparent
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
TimerfdTimerFlags
:
u32
{
/
/
/
TFD_TIMER_ABSTIME
const
ABSTIME
=
bitcast
!
(
c
:
:
TFD_TIMER_ABSTIME
)
;
/
/
/
TFD_TIMER_CANCEL_ON_SET
#
[
cfg
(
linux_kernel
)
]
const
CANCEL_ON_SET
=
bitcast
!
(
c
:
:
TFD_TIMER_CANCEL_ON_SET
)
;
/
/
/
<
https
:
/
/
docs
.
rs
/
bitflags
/
latest
/
bitflags
/
#
externally
-
defined
-
flags
>
const
_
=
!
0
;
}
}
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Hash
)
]
#
[
repr
(
u32
)
]
#
[
non_exhaustive
]
pub
enum
TimerfdClockId
{
Realtime
=
bitcast
!
(
c
:
:
CLOCK_REALTIME
)
Monotonic
=
bitcast
!
(
c
:
:
CLOCK_MONOTONIC
)
Boottime
=
bitcast
!
(
c
:
:
CLOCK_BOOTTIME
)
RealtimeAlarm
=
bitcast
!
(
c
:
:
CLOCK_REALTIME_ALARM
)
BoottimeAlarm
=
bitcast
!
(
c
:
:
CLOCK_BOOTTIME_ALARM
)
}
#
[
cfg
(
any
(
linux_kernel
target_os
=
"
fuchsia
"
)
)
]
#
[
test
]
fn
test_types
(
)
{
assert_eq_size
!
(
TimerfdFlags
c
:
:
c_int
)
;
assert_eq_size
!
(
TimerfdTimerFlags
c
:
:
c_int
)
;
}
