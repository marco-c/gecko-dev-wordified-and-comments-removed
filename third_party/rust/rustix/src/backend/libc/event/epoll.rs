use
crate
:
:
backend
:
:
c
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
crate
:
:
backend
:
:
conv
:
:
ret_u32
;
use
crate
:
:
backend
:
:
conv
:
:
{
ret
ret_owned_fd
}
;
use
crate
:
:
fd
:
:
{
AsFd
AsRawFd
OwnedFd
}
;
use
crate
:
:
io
;
use
crate
:
:
utils
:
:
as_mut_ptr
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
vec
:
:
Vec
;
use
bitflags
:
:
bitflags
;
use
core
:
:
ffi
:
:
c_void
;
use
core
:
:
hash
:
:
{
Hash
Hasher
}
;
use
core
:
:
ptr
:
:
null_mut
;
use
core
:
:
slice
;
bitflags
!
{
/
/
/
EPOLL_
*
for
use
with
[
new
]
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
CreateFlags
:
u32
{
/
/
/
EPOLL_CLOEXEC
const
CLOEXEC
=
bitcast
!
(
c
:
:
EPOLL_CLOEXEC
)
;
/
/
/
<
https
:
/
/
docs
.
rs
/
bitflags
/
*
/
bitflags
/
#
externally
-
defined
-
flags
>
const
_
=
!
0
;
}
}
bitflags
!
{
/
/
/
EPOLL
*
for
use
with
[
add
]
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Default
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
EventFlags
:
u32
{
/
/
/
EPOLLIN
const
IN
=
bitcast
!
(
c
:
:
EPOLLIN
)
;
/
/
/
EPOLLOUT
const
OUT
=
bitcast
!
(
c
:
:
EPOLLOUT
)
;
/
/
/
EPOLLPRI
const
PRI
=
bitcast
!
(
c
:
:
EPOLLPRI
)
;
/
/
/
EPOLLERR
const
ERR
=
bitcast
!
(
c
:
:
EPOLLERR
)
;
/
/
/
EPOLLHUP
const
HUP
=
bitcast
!
(
c
:
:
EPOLLHUP
)
;
/
/
/
EPOLLRDNORM
const
RDNORM
=
bitcast
!
(
c
:
:
EPOLLRDNORM
)
;
/
/
/
EPOLLRDBAND
const
RDBAND
=
bitcast
!
(
c
:
:
EPOLLRDBAND
)
;
/
/
/
EPOLLWRNORM
const
WRNORM
=
bitcast
!
(
c
:
:
EPOLLWRNORM
)
;
/
/
/
EPOLLWRBAND
const
WRBAND
=
bitcast
!
(
c
:
:
EPOLLWRBAND
)
;
/
/
/
EPOLLMSG
const
MSG
=
bitcast
!
(
c
:
:
EPOLLMSG
)
;
/
/
/
EPOLLRDHUP
const
RDHUP
=
bitcast
!
(
c
:
:
EPOLLRDHUP
)
;
/
/
/
EPOLLET
const
ET
=
bitcast
!
(
c
:
:
EPOLLET
)
;
/
/
/
EPOLLONESHOT
const
ONESHOT
=
bitcast
!
(
c
:
:
EPOLLONESHOT
)
;
/
/
/
EPOLLWAKEUP
const
WAKEUP
=
bitcast
!
(
c
:
:
EPOLLWAKEUP
)
;
/
/
/
EPOLLEXCLUSIVE
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
const
EXCLUSIVE
=
bitcast
!
(
c
:
:
EPOLLEXCLUSIVE
)
;
/
/
/
<
https
:
/
/
docs
.
rs
/
bitflags
/
*
/
bitflags
/
#
externally
-
defined
-
flags
>
const
_
=
!
0
;
}
}
#
[
inline
]
#
[
doc
(
alias
=
"
epoll_create1
"
)
]
pub
fn
create
(
flags
:
CreateFlags
)
-
>
io
:
:
Result
<
OwnedFd
>
{
unsafe
{
ret_owned_fd
(
c
:
:
epoll_create1
(
bitflags_bits
!
(
flags
)
)
)
}
}
#
[
doc
(
alias
=
"
epoll_ctl
"
)
]
pub
fn
add
(
epoll
:
impl
AsFd
source
:
impl
AsFd
data
:
EventData
event_flags
:
EventFlags
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
let
raw_fd
=
source
.
as_fd
(
)
.
as_raw_fd
(
)
;
ret
(
c
:
:
epoll_ctl
(
epoll
.
as_fd
(
)
.
as_raw_fd
(
)
c
:
:
EPOLL_CTL_ADD
raw_fd
as_mut_ptr
(
&
mut
Event
{
flags
:
event_flags
data
#
[
cfg
(
target_os
=
"
redox
"
)
]
_pad
:
0
}
)
.
cast
(
)
)
)
}
}
#
[
doc
(
alias
=
"
epoll_ctl
"
)
]
pub
fn
modify
(
epoll
:
impl
AsFd
source
:
impl
AsFd
data
:
EventData
event_flags
:
EventFlags
)
-
>
io
:
:
Result
<
(
)
>
{
let
raw_fd
=
source
.
as_fd
(
)
.
as_raw_fd
(
)
;
unsafe
{
ret
(
c
:
:
epoll_ctl
(
epoll
.
as_fd
(
)
.
as_raw_fd
(
)
c
:
:
EPOLL_CTL_MOD
raw_fd
as_mut_ptr
(
&
mut
Event
{
flags
:
event_flags
data
#
[
cfg
(
target_os
=
"
redox
"
)
]
_pad
:
0
}
)
.
cast
(
)
)
)
}
}
#
[
doc
(
alias
=
"
epoll_ctl
"
)
]
pub
fn
delete
(
epoll
:
impl
AsFd
source
:
impl
AsFd
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
let
raw_fd
=
source
.
as_fd
(
)
.
as_raw_fd
(
)
;
ret
(
c
:
:
epoll_ctl
(
epoll
.
as_fd
(
)
.
as_raw_fd
(
)
c
:
:
EPOLL_CTL_DEL
raw_fd
null_mut
(
)
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
alloc
"
)
)
)
]
pub
fn
wait
(
epoll
:
impl
AsFd
event_list
:
&
mut
EventVec
timeout
:
c
:
:
c_int
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
event_list
.
events
.
set_len
(
0
)
;
let
nfds
=
ret_u32
(
c
:
:
epoll_wait
(
epoll
.
as_fd
(
)
.
as_raw_fd
(
)
event_list
.
events
.
as_mut_ptr
(
)
.
cast
:
:
<
c
:
:
epoll_event
>
(
)
event_list
.
events
.
capacity
(
)
.
try_into
(
)
.
unwrap_or
(
i32
:
:
MAX
)
timeout
)
)
?
;
event_list
.
events
.
set_len
(
nfds
as
usize
)
;
}
Ok
(
(
)
)
}
pub
struct
Iter
<
'
a
>
{
iter
:
core
:
:
iter
:
:
Copied
<
slice
:
:
Iter
<
'
a
Event
>
>
}
impl
<
'
a
>
Iterator
for
Iter
<
'
a
>
{
type
Item
=
Event
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
next
(
)
}
}
#
[
repr
(
C
)
]
#
[
cfg_attr
(
all
(
linux_kernel
any
(
all
(
target_arch
=
"
x86
"
not
(
target_env
=
"
musl
"
)
not
(
target_os
=
"
android
"
)
)
target_arch
=
"
x86_64
"
)
)
repr
(
packed
)
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
)
]
pub
struct
Event
{
pub
flags
:
EventFlags
pub
data
:
EventData
#
[
cfg
(
target_os
=
"
redox
"
)
]
_pad
:
u64
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
union
EventData
{
as_u64
:
u64
sixty_four_bit_pointer
:
SixtyFourBitPointer
}
impl
EventData
{
#
[
inline
]
pub
const
fn
new_u64
(
value
:
u64
)
-
>
Self
{
Self
{
as_u64
:
value
}
}
#
[
inline
]
pub
const
fn
new_ptr
(
value
:
*
mut
c_void
)
-
>
Self
{
Self
{
sixty_four_bit_pointer
:
SixtyFourBitPointer
{
pointer
:
value
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
_padding
:
0
}
}
}
#
[
inline
]
pub
fn
u64
(
self
)
-
>
u64
{
unsafe
{
self
.
as_u64
}
}
#
[
inline
]
pub
fn
ptr
(
self
)
-
>
*
mut
c_void
{
unsafe
{
self
.
sixty_four_bit_pointer
.
pointer
}
}
}
impl
PartialEq
for
EventData
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
u64
(
)
=
=
other
.
u64
(
)
}
}
impl
Eq
for
EventData
{
}
impl
Hash
for
EventData
{
#
[
inline
]
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
u64
(
)
.
hash
(
state
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
struct
SixtyFourBitPointer
{
#
[
cfg
(
target_endian
=
"
big
"
)
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
_padding
:
u32
pointer
:
*
mut
c_void
#
[
cfg
(
target_endian
=
"
little
"
)
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
_padding
:
u32
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
struct
EventVec
{
events
:
Vec
<
Event
>
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
EventVec
{
#
[
inline
]
pub
unsafe
fn
from_raw_parts
(
ptr
:
*
mut
Event
len
:
usize
capacity
:
usize
)
-
>
Self
{
Self
{
events
:
Vec
:
:
from_raw_parts
(
ptr
len
capacity
)
}
}
#
[
inline
]
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
Self
{
Self
{
events
:
Vec
:
:
with_capacity
(
capacity
)
}
}
#
[
inline
]
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
events
.
capacity
(
)
}
#
[
inline
]
pub
fn
reserve
(
&
mut
self
additional
:
usize
)
{
self
.
events
.
reserve
(
additional
)
;
}
#
[
inline
]
pub
fn
reserve_exact
(
&
mut
self
additional
:
usize
)
{
self
.
events
.
reserve_exact
(
additional
)
;
}
#
[
inline
]
pub
fn
clear
(
&
mut
self
)
{
self
.
events
.
clear
(
)
;
}
#
[
inline
]
pub
fn
shrink_to_fit
(
&
mut
self
)
{
self
.
events
.
shrink_to_fit
(
)
;
}
#
[
inline
]
pub
fn
iter
(
&
self
)
-
>
Iter
<
'
_
>
{
Iter
{
iter
:
self
.
events
.
iter
(
)
.
copied
(
)
}
}
#
[
inline
]
pub
fn
len
(
&
mut
self
)
-
>
usize
{
self
.
events
.
len
(
)
}
#
[
inline
]
pub
fn
is_empty
(
&
mut
self
)
-
>
bool
{
self
.
events
.
is_empty
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
IntoIterator
for
&
'
a
EventVec
{
type
IntoIter
=
Iter
<
'
a
>
;
type
Item
=
Event
;
#
[
inline
]
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
iter
(
)
}
}
#
[
test
]
fn
test_epoll_layouts
(
)
{
check_renamed_type
!
(
Event
epoll_event
)
;
check_renamed_type
!
(
Event
epoll_event
)
;
check_renamed_struct_renamed_field
!
(
Event
epoll_event
flags
events
)
;
check_renamed_struct_renamed_field
!
(
Event
epoll_event
data
u64
)
;
}
