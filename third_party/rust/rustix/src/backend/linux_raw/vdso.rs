#
!
[
allow
(
unsafe_code
)
]
use
super
:
:
c
;
use
crate
:
:
ffi
:
:
CStr
;
use
crate
:
:
utils
:
:
check_raw_pointer
;
use
core
:
:
ffi
:
:
c_void
;
use
core
:
:
mem
:
:
size_of
;
use
core
:
:
ptr
:
:
{
null
null_mut
}
;
use
linux_raw_sys
:
:
elf
:
:
*
;
pub
(
super
)
struct
Vdso
{
load_addr
:
*
const
Elf_Ehdr
load_end
:
*
const
c_void
pv_offset
:
usize
symtab
:
*
const
Elf_Sym
symstrings
:
*
const
u8
bucket
:
*
const
u32
chain
:
*
const
u32
nbucket
:
u32
versym
:
*
const
u16
verdef
:
*
const
Elf_Verdef
}
fn
elf_hash
(
name
:
&
CStr
)
-
>
u32
{
let
mut
h
:
u32
=
0
;
for
b
in
name
.
to_bytes
(
)
{
h
=
(
h
<
<
4
)
.
wrapping_add
(
u32
:
:
from
(
*
b
)
)
;
let
g
=
h
&
0xf000_0000
;
if
g
!
=
0
{
h
^
=
g
>
>
24
;
}
h
&
=
!
g
;
}
h
}
fn
init_from_sysinfo_ehdr
(
)
-
>
Option
<
Vdso
>
{
unsafe
{
let
hdr
=
super
:
:
param
:
:
auxv
:
:
sysinfo_ehdr
(
)
;
if
hdr
.
is_null
(
)
{
return
None
;
}
let
mut
vdso
=
Vdso
{
load_addr
:
hdr
load_end
:
hdr
.
cast
(
)
pv_offset
:
0
symtab
:
null
(
)
symstrings
:
null
(
)
bucket
:
null
(
)
chain
:
null
(
)
nbucket
:
0
versym
:
null
(
)
verdef
:
null
(
)
}
;
let
hdr
=
&
*
hdr
;
let
pt
=
check_raw_pointer
:
:
<
Elf_Phdr
>
(
vdso
.
base_plus
(
hdr
.
e_phoff
)
?
as
*
mut
_
)
?
.
as_ptr
(
)
;
let
mut
dyn_
:
*
const
Elf_Dyn
=
null
(
)
;
let
mut
num_dyn
=
0
;
let
mut
found_vaddr
=
false
;
for
i
in
0
.
.
hdr
.
e_phnum
{
let
phdr
=
&
*
pt
.
add
(
i
as
usize
)
;
if
phdr
.
p_flags
&
PF_W
!
=
0
{
return
None
;
}
if
phdr
.
p_type
=
=
PT_LOAD
&
&
!
found_vaddr
{
if
phdr
.
p_flags
&
(
PF_R
|
PF_X
)
!
=
(
PF_R
|
PF_X
)
{
return
None
;
}
found_vaddr
=
true
;
vdso
.
load_end
=
vdso
.
base_plus
(
phdr
.
p_offset
.
checked_add
(
phdr
.
p_memsz
)
?
)
?
;
vdso
.
pv_offset
=
phdr
.
p_offset
.
wrapping_sub
(
phdr
.
p_vaddr
)
;
}
else
if
phdr
.
p_type
=
=
PT_DYNAMIC
{
if
phdr
.
p_offset
<
size_of
:
:
<
Elf_Ehdr
>
(
)
{
return
None
;
}
dyn_
=
check_raw_pointer
:
:
<
Elf_Dyn
>
(
vdso
.
base_plus
(
phdr
.
p_offset
)
?
as
*
mut
_
)
?
.
as_ptr
(
)
;
num_dyn
=
phdr
.
p_memsz
/
size_of
:
:
<
Elf_Dyn
>
(
)
;
}
else
if
phdr
.
p_type
=
=
PT_INTERP
|
|
phdr
.
p_type
=
=
PT_GNU_RELRO
{
return
None
;
}
}
if
!
found_vaddr
|
|
dyn_
.
is_null
(
)
{
return
None
;
}
let
mut
hash
:
*
const
u32
=
null
(
)
;
vdso
.
symstrings
=
null
(
)
;
vdso
.
symtab
=
null
(
)
;
vdso
.
versym
=
null
(
)
;
vdso
.
verdef
=
null
(
)
;
let
mut
i
=
0
;
loop
{
if
i
=
=
num_dyn
{
return
None
;
}
let
d
=
&
*
dyn_
.
add
(
i
)
;
match
d
.
d_tag
{
DT_STRTAB
=
>
{
vdso
.
symstrings
=
check_raw_pointer
:
:
<
u8
>
(
vdso
.
addr_from_elf
(
d
.
d_un
.
d_ptr
)
?
as
*
mut
_
)
?
.
as_ptr
(
)
;
}
DT_SYMTAB
=
>
{
vdso
.
symtab
=
check_raw_pointer
:
:
<
Elf_Sym
>
(
vdso
.
addr_from_elf
(
d
.
d_un
.
d_ptr
)
?
as
*
mut
_
)
?
.
as_ptr
(
)
;
}
DT_HASH
=
>
{
hash
=
check_raw_pointer
:
:
<
u32
>
(
vdso
.
addr_from_elf
(
d
.
d_un
.
d_ptr
)
?
as
*
mut
_
)
?
.
as_ptr
(
)
;
}
DT_VERSYM
=
>
{
vdso
.
versym
=
check_raw_pointer
:
:
<
u16
>
(
vdso
.
addr_from_elf
(
d
.
d_un
.
d_ptr
)
?
as
*
mut
_
)
?
.
as_ptr
(
)
;
}
DT_VERDEF
=
>
{
vdso
.
verdef
=
check_raw_pointer
:
:
<
Elf_Verdef
>
(
vdso
.
addr_from_elf
(
d
.
d_un
.
d_ptr
)
?
as
*
mut
_
)
?
.
as_ptr
(
)
;
}
DT_SYMENT
=
>
{
if
d
.
d_un
.
d_ptr
!
=
size_of
:
:
<
Elf_Sym
>
(
)
{
return
None
;
}
}
DT_NULL
=
>
break
_
=
>
{
}
}
i
=
i
.
checked_add
(
1
)
?
;
}
if
vdso
.
verdef
.
is_null
(
)
{
vdso
.
versym
=
null
(
)
;
}
vdso
.
nbucket
=
*
hash
.
add
(
0
)
;
vdso
.
bucket
=
hash
.
add
(
2
)
;
vdso
.
chain
=
hash
.
add
(
vdso
.
nbucket
as
usize
+
2
)
;
Some
(
vdso
)
}
}
impl
Vdso
{
#
[
inline
]
pub
(
super
)
fn
new
(
)
-
>
Option
<
Self
>
{
init_from_sysinfo_ehdr
(
)
}
unsafe
fn
match_version
(
&
self
mut
ver
:
u16
name
:
&
CStr
hash
:
u32
)
-
>
bool
{
ver
&
=
0x7fff
;
let
mut
def
=
self
.
verdef
;
loop
{
if
(
*
def
)
.
vd_version
!
=
VER_DEF_CURRENT
{
return
false
;
}
if
(
(
*
def
)
.
vd_flags
&
VER_FLG_BASE
)
=
=
0
&
&
(
(
*
def
)
.
vd_ndx
&
0x7fff
)
=
=
ver
{
break
;
}
if
(
*
def
)
.
vd_next
=
=
0
{
return
false
;
}
def
=
def
.
cast
:
:
<
u8
>
(
)
.
add
(
(
*
def
)
.
vd_next
as
usize
)
.
cast
:
:
<
Elf_Verdef
>
(
)
;
}
let
aux
=
&
*
(
def
.
cast
:
:
<
u8
>
(
)
)
.
add
(
(
*
def
)
.
vd_aux
as
usize
)
.
cast
:
:
<
Elf_Verdaux
>
(
)
;
(
*
def
)
.
vd_hash
=
=
hash
&
&
(
name
=
=
CStr
:
:
from_ptr
(
self
.
symstrings
.
add
(
aux
.
vda_name
as
usize
)
.
cast
(
)
)
)
}
pub
(
super
)
fn
sym
(
&
self
version
:
&
CStr
name
:
&
CStr
)
-
>
*
mut
c
:
:
c_void
{
let
ver_hash
=
elf_hash
(
version
)
;
let
name_hash
=
elf_hash
(
name
)
;
unsafe
{
let
mut
chain
=
*
self
.
bucket
.
add
(
(
name_hash
%
self
.
nbucket
)
as
usize
)
;
while
chain
!
=
STN_UNDEF
{
let
sym
=
&
*
self
.
symtab
.
add
(
chain
as
usize
)
;
if
(
ELF_ST_TYPE
(
sym
.
st_info
)
!
=
STT_FUNC
&
&
ELF_ST_TYPE
(
sym
.
st_info
)
!
=
STT_NOTYPE
)
|
|
(
ELF_ST_BIND
(
sym
.
st_info
)
!
=
STB_GLOBAL
&
&
ELF_ST_BIND
(
sym
.
st_info
)
!
=
STB_WEAK
)
|
|
sym
.
st_shndx
=
=
SHN_UNDEF
|
|
sym
.
st_shndx
=
=
SHN_ABS
|
|
ELF_ST_VISIBILITY
(
sym
.
st_other
)
!
=
STV_DEFAULT
|
|
(
name
!
=
CStr
:
:
from_ptr
(
self
.
symstrings
.
add
(
sym
.
st_name
as
usize
)
.
cast
(
)
)
)
|
|
(
!
self
.
versym
.
is_null
(
)
&
&
!
self
.
match_version
(
*
self
.
versym
.
add
(
chain
as
usize
)
version
ver_hash
)
)
{
chain
=
*
self
.
chain
.
add
(
chain
as
usize
)
;
continue
;
}
let
sum
=
self
.
addr_from_elf
(
sym
.
st_value
)
.
unwrap
(
)
;
assert
!
(
sum
as
usize
>
=
self
.
load_addr
as
usize
&
&
sum
as
usize
<
=
self
.
load_end
as
usize
)
;
return
sum
as
*
mut
c
:
:
c_void
;
}
}
null_mut
(
)
}
unsafe
fn
base_plus
(
&
self
offset
:
usize
)
-
>
Option
<
*
const
c_void
>
{
let
_
=
(
self
.
load_addr
as
usize
)
.
checked_add
(
offset
)
?
;
Some
(
self
.
load_addr
.
cast
:
:
<
u8
>
(
)
.
add
(
offset
)
.
cast
(
)
)
}
unsafe
fn
addr_from_elf
(
&
self
elf_addr
:
usize
)
-
>
Option
<
*
const
c_void
>
{
self
.
base_plus
(
elf_addr
.
wrapping_add
(
self
.
pv_offset
)
)
}
}
