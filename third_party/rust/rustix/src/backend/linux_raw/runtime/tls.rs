#
!
[
allow
(
unsafe_code
)
]
use
crate
:
:
backend
:
:
c
;
use
crate
:
:
backend
:
:
param
:
:
auxv
:
:
exe_phdrs
;
use
core
:
:
arch
:
:
global_asm
;
use
core
:
:
ptr
:
:
{
null
NonNull
}
;
use
linux_raw_sys
:
:
elf
:
:
*
;
#
[
cfg
(
target_arch
=
"
x86
"
)
]
pub
type
UserDesc
=
linux_raw_sys
:
:
general
:
:
user_desc
;
pub
(
crate
)
fn
startup_tls_info
(
)
-
>
StartupTlsInfo
{
let
mut
base
=
null
(
)
;
let
mut
tls_phdr
=
null
(
)
;
let
mut
stack_size
=
0
;
let
(
first_phdr
phent
phnum
)
=
exe_phdrs
(
)
;
let
mut
current_phdr
=
first_phdr
.
cast
:
:
<
Elf_Phdr
>
(
)
;
let
dynamic_addr
:
*
const
c
:
:
c_void
=
unsafe
{
&
_DYNAMIC
}
;
unsafe
{
let
phdrs_end
=
current_phdr
.
cast
:
:
<
u8
>
(
)
.
add
(
phnum
*
phent
)
.
cast
(
)
;
while
current_phdr
!
=
phdrs_end
{
let
phdr
=
&
*
current_phdr
;
current_phdr
=
current_phdr
.
cast
:
:
<
u8
>
(
)
.
add
(
phent
)
.
cast
(
)
;
match
phdr
.
p_type
{
PT_PHDR
=
>
base
=
first_phdr
.
cast
:
:
<
u8
>
(
)
.
wrapping_sub
(
phdr
.
p_vaddr
)
PT_DYNAMIC
=
>
base
=
dynamic_addr
.
cast
:
:
<
u8
>
(
)
.
wrapping_sub
(
phdr
.
p_vaddr
)
PT_TLS
=
>
tls_phdr
=
phdr
PT_GNU_STACK
=
>
stack_size
=
phdr
.
p_memsz
_
=
>
{
}
}
}
if
tls_phdr
.
is_null
(
)
{
StartupTlsInfo
{
addr
:
NonNull
:
:
dangling
(
)
.
as_ptr
(
)
mem_size
:
0
file_size
:
0
align
:
1
stack_size
:
0
}
}
else
{
StartupTlsInfo
{
addr
:
base
.
cast
:
:
<
u8
>
(
)
.
wrapping_add
(
(
*
tls_phdr
)
.
p_vaddr
)
.
cast
(
)
mem_size
:
(
*
tls_phdr
)
.
p_memsz
file_size
:
(
*
tls_phdr
)
.
p_filesz
align
:
(
*
tls_phdr
)
.
p_align
stack_size
}
}
}
}
extern
"
C
"
{
static
_DYNAMIC
:
c
:
:
c_void
;
}
global_asm
!
(
"
.
weak
_DYNAMIC
"
)
;
pub
struct
StartupTlsInfo
{
pub
addr
:
*
const
c
:
:
c_void
pub
mem_size
:
usize
pub
file_size
:
usize
pub
align
:
usize
pub
stack_size
:
usize
}
