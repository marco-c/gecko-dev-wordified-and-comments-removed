use
crate
:
:
ffi
:
:
CStr
;
use
crate
:
:
io
;
#
[
cfg
(
feature
=
"
itoa
"
)
]
use
crate
:
:
path
:
:
DecInt
;
use
crate
:
:
path
:
:
SMALL_PATH_BUFFER_SIZE
;
#
[
cfg
(
all
(
feature
=
"
alloc
"
feature
=
"
itoa
"
)
)
]
use
alloc
:
:
borrow
:
:
ToOwned
;
use
core
:
:
mem
:
:
MaybeUninit
;
use
core
:
:
{
ptr
slice
str
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
ffi
:
:
{
OsStr
OsString
}
;
#
[
cfg
(
all
(
feature
=
"
std
"
target_os
=
"
hermit
"
)
)
]
use
std
:
:
os
:
:
hermit
:
:
ext
:
:
ffi
:
:
{
OsStrExt
OsStringExt
}
;
#
[
cfg
(
all
(
feature
=
"
std
"
unix
)
)
]
use
std
:
:
os
:
:
unix
:
:
ffi
:
:
{
OsStrExt
OsStringExt
}
;
#
[
cfg
(
all
(
feature
=
"
std
"
target_os
=
"
vxworks
"
)
)
]
use
std
:
:
os
:
:
vxworks
:
:
ext
:
:
ffi
:
:
{
OsStrExt
OsStringExt
}
;
#
[
cfg
(
all
(
feature
=
"
std
"
target_os
=
"
wasi
"
)
)
]
use
std
:
:
os
:
:
wasi
:
:
ffi
:
:
{
OsStrExt
OsStringExt
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
path
:
:
{
Component
Components
Iter
Path
PathBuf
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
{
crate
:
:
ffi
:
:
CString
alloc
:
:
borrow
:
:
Cow
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
{
alloc
:
:
string
:
:
String
alloc
:
:
vec
:
:
Vec
}
;
pub
trait
Arg
{
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
;
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
;
}
pub
fn
option_into_with_c_str
<
T
F
A
:
Arg
>
(
arg
:
Option
<
A
>
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
A
:
Sized
F
:
FnOnce
(
Option
<
&
CStr
>
)
-
>
io
:
:
Result
<
T
>
{
if
let
Some
(
arg
)
=
arg
{
arg
.
into_with_c_str
(
|
p
|
f
(
Some
(
p
)
)
)
}
else
{
f
(
None
)
}
}
impl
Arg
for
&
str
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
Ok
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
Cow
:
:
Borrowed
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
*
self
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
.
as_bytes
(
)
f
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Arg
for
&
String
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
Ok
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
Cow
:
:
Borrowed
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
String
:
:
as_str
(
self
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
self
.
as_str
(
)
.
into_c_str
(
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
.
as_bytes
(
)
f
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Arg
for
String
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
Ok
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
Cow
:
:
Borrowed
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_str
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
f
(
&
CString
:
:
new
(
self
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Arg
for
&
OsStr
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
self
.
to_str
(
)
.
ok_or
(
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
OsStr
:
:
to_string_lossy
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
.
as_bytes
(
)
f
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Arg
for
&
OsString
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
OsString
:
:
as_os_str
(
self
)
.
to_str
(
)
.
ok_or
(
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
self
.
as_os_str
(
)
.
to_string_lossy
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
OsString
:
:
as_os_str
(
self
)
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
self
.
as_os_str
(
)
.
into_c_str
(
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
.
as_bytes
(
)
f
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Arg
for
OsString
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
self
.
as_os_str
(
)
.
to_str
(
)
.
ok_or
(
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
self
.
as_os_str
(
)
.
to_string_lossy
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
into_vec
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
f
(
&
CString
:
:
new
(
self
.
into_vec
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Arg
for
&
Path
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
self
.
as_os_str
(
)
.
to_str
(
)
.
ok_or
(
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
Path
:
:
to_string_lossy
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_os_str
(
)
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_os_str
(
)
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
.
as_os_str
(
)
.
as_bytes
(
)
f
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Arg
for
&
PathBuf
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
PathBuf
:
:
as_path
(
self
)
.
as_os_str
(
)
.
to_str
(
)
.
ok_or
(
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
self
.
as_path
(
)
.
to_string_lossy
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
PathBuf
:
:
as_path
(
self
)
.
as_os_str
(
)
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
self
.
as_path
(
)
.
into_c_str
(
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
.
as_os_str
(
)
.
as_bytes
(
)
f
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Arg
for
PathBuf
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
self
.
as_os_str
(
)
.
to_str
(
)
.
ok_or
(
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
self
.
as_os_str
(
)
.
to_string_lossy
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_os_str
(
)
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
into_os_string
(
)
.
into_vec
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
f
(
&
CString
:
:
new
(
self
.
into_os_string
(
)
.
into_vec
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
}
}
impl
Arg
for
&
CStr
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
self
.
to_str
(
)
.
map_err
(
|
_utf8_err
|
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
CStr
:
:
to_string_lossy
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Borrowed
(
self
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Borrowed
(
self
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
f
(
self
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Arg
for
&
CString
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
unimplemented
!
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
unimplemented
!
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Borrowed
(
self
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Borrowed
(
self
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
f
(
self
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Arg
for
CString
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
self
.
to_str
(
)
.
map_err
(
|
_utf8_err
|
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
CStr
:
:
to_string_lossy
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Borrowed
(
self
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
self
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
f
(
&
self
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
Arg
for
Cow
<
'
a
str
>
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
Ok
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
Cow
:
:
Borrowed
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_ref
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
match
self
{
Cow
:
:
Owned
(
s
)
=
>
CString
:
:
new
(
s
)
Cow
:
:
Borrowed
(
s
)
=
>
CString
:
:
new
(
s
)
}
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
.
as_bytes
(
)
f
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
Arg
for
Cow
<
'
a
OsStr
>
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
(
*
*
self
)
.
to_str
(
)
.
ok_or
(
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
(
*
*
self
)
.
to_string_lossy
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
match
self
{
Cow
:
:
Owned
(
os
)
=
>
CString
:
:
new
(
os
.
into_vec
(
)
)
Cow
:
:
Borrowed
(
os
)
=
>
CString
:
:
new
(
os
.
as_bytes
(
)
)
}
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
.
as_bytes
(
)
f
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
Arg
for
Cow
<
'
a
CStr
>
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
self
.
to_str
(
)
.
map_err
(
|
_utf8_err
|
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
let
borrow
:
&
CStr
=
core
:
:
borrow
:
:
Borrow
:
:
borrow
(
self
)
;
borrow
.
to_string_lossy
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Borrowed
(
self
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
self
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
f
(
&
self
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
'
a
>
Arg
for
Component
<
'
a
>
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
self
.
as_os_str
(
)
.
to_str
(
)
.
ok_or
(
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
self
.
as_os_str
(
)
.
to_string_lossy
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_os_str
(
)
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_os_str
(
)
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
.
as_os_str
(
)
.
as_bytes
(
)
f
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
'
a
>
Arg
for
Components
<
'
a
>
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
self
.
as_path
(
)
.
to_str
(
)
.
ok_or
(
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
self
.
as_path
(
)
.
to_string_lossy
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_path
(
)
.
as_os_str
(
)
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_path
(
)
.
as_os_str
(
)
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
.
as_path
(
)
.
as_os_str
(
)
.
as_bytes
(
)
f
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
'
a
>
Arg
for
Iter
<
'
a
>
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
self
.
as_path
(
)
.
to_str
(
)
.
ok_or
(
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
self
.
as_path
(
)
.
to_string_lossy
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_path
(
)
.
as_os_str
(
)
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_path
(
)
.
as_os_str
(
)
.
as_bytes
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
.
as_path
(
)
.
as_os_str
(
)
.
as_bytes
(
)
f
)
}
}
impl
Arg
for
&
[
u8
]
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
str
:
:
from_utf8
(
self
)
.
map_err
(
|
_utf8_err
|
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
String
:
:
from_utf8_lossy
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
*
self
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
f
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Arg
for
&
Vec
<
u8
>
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
str
:
:
from_utf8
(
self
)
.
map_err
(
|
_utf8_err
|
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
String
:
:
from_utf8_lossy
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_slice
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_slice
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
with_c_str
(
self
f
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Arg
for
Vec
<
u8
>
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
str
:
:
from_utf8
(
self
)
.
map_err
(
|
_utf8_err
|
io
:
:
Errno
:
:
INVAL
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
String
:
:
from_utf8_lossy
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
.
as_slice
(
)
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
CString
:
:
new
(
self
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
f
(
&
CString
:
:
new
(
self
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
}
}
#
[
cfg
(
feature
=
"
itoa
"
)
]
impl
Arg
for
DecInt
{
#
[
inline
]
fn
as_str
(
&
self
)
-
>
io
:
:
Result
<
&
str
>
{
Ok
(
self
.
as_str
(
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
Cow
:
:
Borrowed
(
self
.
as_str
(
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
as_cow_c_str
(
&
self
)
-
>
io
:
:
Result
<
Cow
<
'
_
CStr
>
>
{
Ok
(
Cow
:
:
Borrowed
(
self
.
as_c_str
(
)
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
fn
into_c_str
<
'
b
>
(
self
)
-
>
io
:
:
Result
<
Cow
<
'
b
CStr
>
>
where
Self
:
'
b
{
Ok
(
Cow
:
:
Owned
(
self
.
as_c_str
(
)
.
to_owned
(
)
)
)
}
#
[
inline
]
fn
into_with_c_str
<
T
F
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
Self
:
Sized
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
f
(
self
.
as_c_str
(
)
)
}
}
#
[
allow
(
unsafe_code
clippy
:
:
int_plus_one
)
]
#
[
inline
]
fn
with_c_str
<
T
F
>
(
bytes
:
&
[
u8
]
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
if
bytes
.
len
(
)
>
=
SMALL_PATH_BUFFER_SIZE
{
return
with_c_str_slow_path
(
bytes
f
)
;
}
let
mut
buf
=
MaybeUninit
:
:
<
[
u8
;
SMALL_PATH_BUFFER_SIZE
]
>
:
:
uninit
(
)
;
let
buf_ptr
=
buf
.
as_mut_ptr
(
)
.
cast
:
:
<
u8
>
(
)
;
debug_assert
!
(
bytes
.
len
(
)
+
1
<
=
SMALL_PATH_BUFFER_SIZE
)
;
unsafe
{
ptr
:
:
copy_nonoverlapping
(
bytes
.
as_ptr
(
)
buf_ptr
bytes
.
len
(
)
)
;
buf_ptr
.
add
(
bytes
.
len
(
)
)
.
write
(
0
)
;
}
match
CStr
:
:
from_bytes_with_nul
(
unsafe
{
slice
:
:
from_raw_parts
(
buf_ptr
bytes
.
len
(
)
+
1
)
}
)
{
Ok
(
s
)
=
>
f
(
s
)
Err
(
_
)
=
>
Err
(
io
:
:
Errno
:
:
INVAL
)
}
}
#
[
allow
(
unsafe_code
clippy
:
:
int_plus_one
)
]
#
[
cold
]
fn
with_c_str_slow_path
<
T
F
>
(
bytes
:
&
[
u8
]
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
F
:
FnOnce
(
&
CStr
)
-
>
io
:
:
Result
<
T
>
{
#
[
cfg
(
feature
=
"
alloc
"
)
]
{
f
(
&
CString
:
:
new
(
bytes
)
.
map_err
(
|
_cstr_err
|
io
:
:
Errno
:
:
INVAL
)
?
)
}
#
[
cfg
(
not
(
feature
=
"
alloc
"
)
)
]
{
#
[
cfg
(
all
(
libc
not
(
target_os
=
"
wasi
"
)
)
)
]
const
LARGE_PATH_BUFFER_SIZE
:
usize
=
libc
:
:
PATH_MAX
as
usize
;
#
[
cfg
(
linux_raw
)
]
const
LARGE_PATH_BUFFER_SIZE
:
usize
=
linux_raw_sys
:
:
general
:
:
PATH_MAX
as
usize
;
#
[
cfg
(
target_os
=
"
wasi
"
)
]
const
LARGE_PATH_BUFFER_SIZE
:
usize
=
4096
as
usize
;
let
mut
buf
=
MaybeUninit
:
:
<
[
u8
;
LARGE_PATH_BUFFER_SIZE
]
>
:
:
uninit
(
)
;
let
buf_ptr
=
buf
.
as_mut_ptr
(
)
.
cast
:
:
<
u8
>
(
)
;
if
bytes
.
len
(
)
+
1
>
LARGE_PATH_BUFFER_SIZE
{
return
Err
(
io
:
:
Errno
:
:
NAMETOOLONG
)
;
}
unsafe
{
ptr
:
:
copy_nonoverlapping
(
bytes
.
as_ptr
(
)
buf_ptr
bytes
.
len
(
)
)
;
buf_ptr
.
add
(
bytes
.
len
(
)
)
.
write
(
0
)
;
}
match
CStr
:
:
from_bytes_with_nul
(
unsafe
{
slice
:
:
from_raw_parts
(
buf_ptr
bytes
.
len
(
)
+
1
)
}
)
{
Ok
(
s
)
=
>
f
(
s
)
Err
(
_
)
=
>
Err
(
io
:
:
Errno
:
:
INVAL
)
}
}
}
