#
!
[
allow
(
unsafe_code
)
]
use
crate
:
:
backend
:
:
c
;
use
core
:
:
num
:
:
NonZeroI32
;
pub
type
RawPid
=
c
:
:
pid_t
;
#
[
repr
(
transparent
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Debug
Hash
)
]
pub
struct
Pid
(
NonZeroI32
)
;
impl
Pid
{
pub
const
INIT
:
Self
=
Self
(
match
NonZeroI32
:
:
new
(
1
)
{
Some
(
n
)
=
>
n
None
=
>
panic
!
(
"
unreachable
"
)
}
)
;
#
[
inline
]
pub
const
fn
from_raw
(
raw
:
RawPid
)
-
>
Option
<
Self
>
{
if
raw
>
0
{
unsafe
{
Some
(
Self
:
:
from_raw_unchecked
(
raw
)
)
}
}
else
{
None
}
}
#
[
inline
]
pub
const
unsafe
fn
from_raw_unchecked
(
raw
:
RawPid
)
-
>
Self
{
debug_assert
!
(
raw
>
0
)
;
Self
(
NonZeroI32
:
:
new_unchecked
(
raw
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
inline
]
pub
fn
from_child
(
child
:
&
std
:
:
process
:
:
Child
)
-
>
Self
{
let
id
=
child
.
id
(
)
;
unsafe
{
Self
:
:
from_raw_unchecked
(
id
as
i32
)
}
}
#
[
inline
]
pub
const
fn
as_raw_nonzero
(
self
)
-
>
NonZeroI32
{
self
.
0
}
#
[
inline
]
pub
fn
as_raw
(
pid
:
Option
<
Self
>
)
-
>
RawPid
{
pid
.
map_or
(
0
|
pid
|
pid
.
0
.
get
(
)
)
}
#
[
inline
]
pub
const
fn
is_init
(
self
)
-
>
bool
{
self
.
0
.
get
(
)
=
=
Self
:
:
INIT
.
0
.
get
(
)
}
}
#
[
test
]
fn
test_sizes
(
)
{
use
core
:
:
mem
:
:
transmute
;
assert_eq_size
!
(
RawPid
NonZeroI32
)
;
assert_eq_size
!
(
RawPid
Pid
)
;
assert_eq_size
!
(
RawPid
Option
<
Pid
>
)
;
const_assert_eq
!
(
0
as
RawPid
unsafe
{
transmute
:
:
<
Option
<
Pid
>
RawPid
>
(
None
)
}
)
;
const_assert_eq
!
(
4567
as
RawPid
unsafe
{
transmute
:
:
<
Option
<
Pid
>
RawPid
>
(
Some
(
Pid
:
:
from_raw_unchecked
(
4567
)
)
)
}
)
;
}
