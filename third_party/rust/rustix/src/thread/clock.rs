use
crate
:
:
{
backend
io
}
;
use
core
:
:
fmt
;
pub
use
crate
:
:
timespec
:
:
{
Nsecs
Secs
Timespec
}
;
#
[
cfg
(
not
(
any
(
apple
target_os
=
"
dragonfly
"
target_os
=
"
espidf
"
target_os
=
"
freebsd
"
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
vita
"
target_os
=
"
wasi
"
)
)
)
]
pub
use
crate
:
:
clockid
:
:
ClockId
;
#
[
cfg
(
not
(
any
(
apple
target_os
=
"
dragonfly
"
target_os
=
"
emscripten
"
target_os
=
"
espidf
"
target_os
=
"
freebsd
"
target_os
=
"
haiku
"
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
vita
"
target_os
=
"
wasi
"
)
)
)
]
#
[
inline
]
pub
fn
clock_nanosleep_relative
(
id
:
ClockId
request
:
&
Timespec
)
-
>
NanosleepRelativeResult
{
backend
:
:
thread
:
:
syscalls
:
:
clock_nanosleep_relative
(
id
request
)
}
#
[
cfg
(
not
(
any
(
apple
target_os
=
"
dragonfly
"
target_os
=
"
emscripten
"
target_os
=
"
espidf
"
target_os
=
"
freebsd
"
target_os
=
"
haiku
"
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
vita
"
target_os
=
"
wasi
"
)
)
)
]
#
[
inline
]
pub
fn
clock_nanosleep_absolute
(
id
:
ClockId
request
:
&
Timespec
)
-
>
io
:
:
Result
<
(
)
>
{
backend
:
:
thread
:
:
syscalls
:
:
clock_nanosleep_absolute
(
id
request
)
}
#
[
inline
]
pub
fn
nanosleep
(
request
:
&
Timespec
)
-
>
NanosleepRelativeResult
{
backend
:
:
thread
:
:
syscalls
:
:
nanosleep
(
request
)
}
#
[
derive
(
Clone
)
]
#
[
must_use
]
pub
enum
NanosleepRelativeResult
{
Ok
Interrupted
(
Timespec
)
Err
(
io
:
:
Errno
)
}
impl
fmt
:
:
Debug
for
NanosleepRelativeResult
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
Self
:
:
Ok
=
>
f
.
write_str
(
"
Ok
"
)
Self
:
:
Interrupted
(
remaining
)
=
>
write
!
(
f
"
Interrupted
(
Timespec
{
{
tv_sec
:
{
:
?
}
tv_nsec
:
{
:
?
}
}
}
)
"
remaining
.
tv_sec
remaining
.
tv_nsec
)
Self
:
:
Err
(
err
)
=
>
write
!
(
f
"
Err
(
{
:
?
}
)
"
err
)
}
}
}
