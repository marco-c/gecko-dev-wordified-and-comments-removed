use
crate
:
:
fd
:
:
AsFd
;
use
crate
:
:
fs
:
:
AtFlags
;
use
crate
:
:
{
backend
io
path
}
;
use
backend
:
:
fs
:
:
types
:
:
{
Statx
StatxFlags
}
;
#
[
cfg
(
feature
=
"
linux_4_11
"
)
]
use
backend
:
:
fs
:
:
syscalls
:
:
statx
as
_statx
;
#
[
cfg
(
not
(
feature
=
"
linux_4_11
"
)
)
]
use
compat
:
:
statx
as
_statx
;
#
[
inline
]
pub
fn
statx
<
P
:
path
:
:
Arg
Fd
:
AsFd
>
(
dirfd
:
Fd
path
:
P
flags
:
AtFlags
mask
:
StatxFlags
)
-
>
io
:
:
Result
<
Statx
>
{
path
.
into_with_c_str
(
|
path
|
_statx
(
dirfd
.
as_fd
(
)
path
flags
mask
)
)
}
#
[
cfg
(
not
(
feature
=
"
linux_4_11
"
)
)
]
mod
compat
{
use
crate
:
:
fd
:
:
BorrowedFd
;
use
crate
:
:
ffi
:
:
CStr
;
use
crate
:
:
fs
:
:
AtFlags
;
use
crate
:
:
{
backend
io
}
;
use
core
:
:
sync
:
:
atomic
:
:
{
AtomicU8
Ordering
}
;
use
backend
:
:
fs
:
:
types
:
:
{
Statx
StatxFlags
}
;
static
STATX_STATE
:
AtomicU8
=
AtomicU8
:
:
new
(
0
)
;
#
[
inline
]
pub
fn
statx
(
dirfd
:
BorrowedFd
<
'
_
>
path
:
&
CStr
flags
:
AtFlags
mask
:
StatxFlags
)
-
>
io
:
:
Result
<
Statx
>
{
match
STATX_STATE
.
load
(
Ordering
:
:
Relaxed
)
{
0
=
>
statx_init
(
dirfd
path
flags
mask
)
1
=
>
Err
(
io
:
:
Errno
:
:
NOSYS
)
_
=
>
backend
:
:
fs
:
:
syscalls
:
:
statx
(
dirfd
path
flags
mask
)
}
}
fn
statx_init
(
dirfd
:
BorrowedFd
<
'
_
>
path
:
&
CStr
flags
:
AtFlags
mask
:
StatxFlags
)
-
>
io
:
:
Result
<
Statx
>
{
match
backend
:
:
fs
:
:
syscalls
:
:
statx
(
dirfd
path
flags
mask
)
{
Err
(
io
:
:
Errno
:
:
NOSYS
)
=
>
statx_error_nosys
(
)
Err
(
io
:
:
Errno
:
:
PERM
)
=
>
statx_error_perm
(
)
result
=
>
{
STATX_STATE
.
store
(
2
Ordering
:
:
Relaxed
)
;
result
}
}
}
#
[
cold
]
fn
statx_error_nosys
(
)
-
>
io
:
:
Result
<
Statx
>
{
STATX_STATE
.
store
(
1
Ordering
:
:
Relaxed
)
;
Err
(
io
:
:
Errno
:
:
NOSYS
)
}
#
[
cold
]
fn
statx_error_perm
(
)
-
>
io
:
:
Result
<
Statx
>
{
if
backend
:
:
fs
:
:
syscalls
:
:
is_statx_available
(
)
{
STATX_STATE
.
store
(
2
Ordering
:
:
Relaxed
)
;
Err
(
io
:
:
Errno
:
:
PERM
)
}
else
{
statx_error_nosys
(
)
}
}
}
