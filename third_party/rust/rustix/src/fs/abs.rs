use
crate
:
:
fd
:
:
OwnedFd
;
#
[
cfg
(
not
(
any
(
target_os
=
"
espidf
"
target_os
=
"
vita
"
)
)
)
]
use
crate
:
:
fs
:
:
Access
;
#
[
cfg
(
not
(
any
(
solarish
target_os
=
"
espidf
"
target_os
=
"
haiku
"
target_os
=
"
netbsd
"
target_os
=
"
nto
"
target_os
=
"
redox
"
target_os
=
"
vita
"
target_os
=
"
wasi
"
)
)
)
]
use
crate
:
:
fs
:
:
StatFs
;
#
[
cfg
(
not
(
any
(
target_os
=
"
haiku
"
target_os
=
"
redox
"
target_os
=
"
wasi
"
)
)
)
]
use
crate
:
:
fs
:
:
StatVfs
;
use
crate
:
:
fs
:
:
{
Mode
OFlags
Stat
}
;
#
[
cfg
(
not
(
target_os
=
"
wasi
"
)
)
]
use
crate
:
:
ugid
:
:
{
Gid
Uid
}
;
use
crate
:
:
{
backend
io
path
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
{
crate
:
:
ffi
:
:
{
CStr
CString
}
crate
:
:
path
:
:
SMALL_PATH_BUFFER_SIZE
alloc
:
:
vec
:
:
Vec
}
;
#
[
inline
]
pub
fn
open
<
P
:
path
:
:
Arg
>
(
path
:
P
flags
:
OFlags
mode
:
Mode
)
-
>
io
:
:
Result
<
OwnedFd
>
{
path
.
into_with_c_str
(
|
path
|
backend
:
:
fs
:
:
syscalls
:
:
open
(
path
flags
mode
)
)
}
#
[
cfg
(
not
(
target_os
=
"
wasi
"
)
)
]
#
[
inline
]
pub
fn
chmod
<
P
:
path
:
:
Arg
>
(
path
:
P
mode
:
Mode
)
-
>
io
:
:
Result
<
(
)
>
{
path
.
into_with_c_str
(
|
path
|
backend
:
:
fs
:
:
syscalls
:
:
chmod
(
path
mode
)
)
}
#
[
inline
]
pub
fn
stat
<
P
:
path
:
:
Arg
>
(
path
:
P
)
-
>
io
:
:
Result
<
Stat
>
{
path
.
into_with_c_str
(
backend
:
:
fs
:
:
syscalls
:
:
stat
)
}
#
[
inline
]
pub
fn
lstat
<
P
:
path
:
:
Arg
>
(
path
:
P
)
-
>
io
:
:
Result
<
Stat
>
{
path
.
into_with_c_str
(
backend
:
:
fs
:
:
syscalls
:
:
lstat
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
inline
]
pub
fn
readlink
<
P
:
path
:
:
Arg
B
:
Into
<
Vec
<
u8
>
>
>
(
path
:
P
reuse
:
B
)
-
>
io
:
:
Result
<
CString
>
{
path
.
into_with_c_str
(
|
path
|
_readlink
(
path
reuse
.
into
(
)
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
_readlink
(
path
:
&
CStr
mut
buffer
:
Vec
<
u8
>
)
-
>
io
:
:
Result
<
CString
>
{
buffer
.
clear
(
)
;
buffer
.
reserve
(
SMALL_PATH_BUFFER_SIZE
)
;
buffer
.
resize
(
buffer
.
capacity
(
)
0_u8
)
;
loop
{
let
nread
=
backend
:
:
fs
:
:
syscalls
:
:
readlink
(
path
&
mut
buffer
)
?
;
let
nread
=
nread
as
usize
;
assert
!
(
nread
<
=
buffer
.
len
(
)
)
;
if
nread
<
buffer
.
len
(
)
{
buffer
.
resize
(
nread
0_u8
)
;
return
Ok
(
CString
:
:
new
(
buffer
)
.
unwrap
(
)
)
;
}
buffer
.
reserve
(
1
)
;
buffer
.
resize
(
buffer
.
capacity
(
)
0_u8
)
;
}
}
#
[
inline
]
pub
fn
rename
<
P
:
path
:
:
Arg
Q
:
path
:
:
Arg
>
(
old_path
:
P
new_path
:
Q
)
-
>
io
:
:
Result
<
(
)
>
{
old_path
.
into_with_c_str
(
|
old_path
|
{
new_path
.
into_with_c_str
(
|
new_path
|
backend
:
:
fs
:
:
syscalls
:
:
rename
(
old_path
new_path
)
)
}
)
}
#
[
inline
]
pub
fn
unlink
<
P
:
path
:
:
Arg
>
(
path
:
P
)
-
>
io
:
:
Result
<
(
)
>
{
path
.
into_with_c_str
(
backend
:
:
fs
:
:
syscalls
:
:
unlink
)
}
#
[
inline
]
pub
fn
rmdir
<
P
:
path
:
:
Arg
>
(
path
:
P
)
-
>
io
:
:
Result
<
(
)
>
{
path
.
into_with_c_str
(
backend
:
:
fs
:
:
syscalls
:
:
rmdir
)
}
#
[
inline
]
pub
fn
link
<
P
:
path
:
:
Arg
Q
:
path
:
:
Arg
>
(
old_path
:
P
new_path
:
Q
)
-
>
io
:
:
Result
<
(
)
>
{
old_path
.
into_with_c_str
(
|
old_path
|
{
new_path
.
into_with_c_str
(
|
new_path
|
backend
:
:
fs
:
:
syscalls
:
:
link
(
old_path
new_path
)
)
}
)
}
#
[
inline
]
pub
fn
symlink
<
P
:
path
:
:
Arg
Q
:
path
:
:
Arg
>
(
old_path
:
P
new_path
:
Q
)
-
>
io
:
:
Result
<
(
)
>
{
old_path
.
into_with_c_str
(
|
old_path
|
{
new_path
.
into_with_c_str
(
|
new_path
|
backend
:
:
fs
:
:
syscalls
:
:
symlink
(
old_path
new_path
)
)
}
)
}
#
[
inline
]
pub
fn
mkdir
<
P
:
path
:
:
Arg
>
(
path
:
P
mode
:
Mode
)
-
>
io
:
:
Result
<
(
)
>
{
path
.
into_with_c_str
(
|
path
|
backend
:
:
fs
:
:
syscalls
:
:
mkdir
(
path
mode
)
)
}
#
[
cfg
(
not
(
any
(
target_os
=
"
espidf
"
target_os
=
"
vita
"
)
)
)
]
#
[
inline
]
pub
fn
access
<
P
:
path
:
:
Arg
>
(
path
:
P
access
:
Access
)
-
>
io
:
:
Result
<
(
)
>
{
path
.
into_with_c_str
(
|
path
|
backend
:
:
fs
:
:
syscalls
:
:
access
(
path
access
)
)
}
#
[
cfg
(
not
(
any
(
solarish
target_os
=
"
espidf
"
target_os
=
"
haiku
"
target_os
=
"
netbsd
"
target_os
=
"
nto
"
target_os
=
"
redox
"
target_os
=
"
vita
"
target_os
=
"
wasi
"
)
)
)
]
#
[
inline
]
pub
fn
statfs
<
P
:
path
:
:
Arg
>
(
path
:
P
)
-
>
io
:
:
Result
<
StatFs
>
{
path
.
into_with_c_str
(
backend
:
:
fs
:
:
syscalls
:
:
statfs
)
}
#
[
cfg
(
not
(
any
(
target_os
=
"
haiku
"
target_os
=
"
redox
"
target_os
=
"
wasi
"
)
)
)
]
#
[
inline
]
pub
fn
statvfs
<
P
:
path
:
:
Arg
>
(
path
:
P
)
-
>
io
:
:
Result
<
StatVfs
>
{
path
.
into_with_c_str
(
backend
:
:
fs
:
:
syscalls
:
:
statvfs
)
}
#
[
cfg
(
not
(
target_os
=
"
wasi
"
)
)
]
#
[
inline
]
pub
fn
chown
<
P
:
path
:
:
Arg
>
(
path
:
P
owner
:
Option
<
Uid
>
group
:
Option
<
Gid
>
)
-
>
io
:
:
Result
<
(
)
>
{
path
.
into_with_c_str
(
|
path
|
backend
:
:
fs
:
:
syscalls
:
:
chown
(
path
owner
group
)
)
}
