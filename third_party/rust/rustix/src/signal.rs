use
crate
:
:
backend
:
:
c
;
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
)
]
#
[
repr
(
i32
)
]
pub
enum
Signal
{
Hup
=
c
:
:
SIGHUP
Int
=
c
:
:
SIGINT
Quit
=
c
:
:
SIGQUIT
Ill
=
c
:
:
SIGILL
Trap
=
c
:
:
SIGTRAP
#
[
doc
(
alias
=
"
Iot
"
)
]
#
[
doc
(
alias
=
"
Abrt
"
)
]
Abort
=
c
:
:
SIGABRT
Bus
=
c
:
:
SIGBUS
Fpe
=
c
:
:
SIGFPE
Kill
=
c
:
:
SIGKILL
Usr1
=
c
:
:
SIGUSR1
Segv
=
c
:
:
SIGSEGV
Usr2
=
c
:
:
SIGUSR2
Pipe
=
c
:
:
SIGPIPE
#
[
doc
(
alias
=
"
Alrm
"
)
]
Alarm
=
c
:
:
SIGALRM
Term
=
c
:
:
SIGTERM
#
[
cfg
(
not
(
any
(
bsd
solarish
target_os
=
"
aix
"
target_os
=
"
haiku
"
target_os
=
"
nto
"
all
(
linux_kernel
any
(
target_arch
=
"
mips
"
target_arch
=
"
mips32r6
"
target_arch
=
"
mips64
"
target_arch
=
"
mips64r6
"
target_arch
=
"
sparc
"
target_arch
=
"
sparc64
"
)
)
)
)
)
]
Stkflt
=
c
:
:
SIGSTKFLT
#
[
doc
(
alias
=
"
Chld
"
)
]
Child
=
c
:
:
SIGCHLD
Cont
=
c
:
:
SIGCONT
Stop
=
c
:
:
SIGSTOP
Tstp
=
c
:
:
SIGTSTP
Ttin
=
c
:
:
SIGTTIN
Ttou
=
c
:
:
SIGTTOU
Urg
=
c
:
:
SIGURG
Xcpu
=
c
:
:
SIGXCPU
Xfsz
=
c
:
:
SIGXFSZ
#
[
doc
(
alias
=
"
Vtalrm
"
)
]
Vtalarm
=
c
:
:
SIGVTALRM
Prof
=
c
:
:
SIGPROF
Winch
=
c
:
:
SIGWINCH
#
[
doc
(
alias
=
"
Poll
"
)
]
#
[
cfg
(
not
(
target_os
=
"
haiku
"
)
)
]
Io
=
c
:
:
SIGIO
#
[
cfg
(
not
(
any
(
bsd
target_os
=
"
haiku
"
)
)
)
]
#
[
doc
(
alias
=
"
Pwr
"
)
]
Power
=
c
:
:
SIGPWR
#
[
doc
(
alias
=
"
Unused
"
)
]
Sys
=
c
:
:
SIGSYS
#
[
cfg
(
any
(
bsd
solarish
target_os
=
"
aix
"
target_os
=
"
hermit
"
all
(
linux_kernel
any
(
target_arch
=
"
mips
"
target_arch
=
"
mips32r6
"
target_arch
=
"
mips64
"
target_arch
=
"
mips64r6
"
target_arch
=
"
sparc
"
target_arch
=
"
sparc64
"
)
)
)
)
]
Emt
=
c
:
:
SIGEMT
#
[
cfg
(
bsd
)
]
Info
=
c
:
:
SIGINFO
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
#
[
doc
(
alias
=
"
Lwp
"
)
]
Thr
=
c
:
:
SIGTHR
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
Librt
=
c
:
:
SIGLIBRT
}
impl
Signal
{
pub
fn
from_raw
(
sig
:
c
:
:
c_int
)
-
>
Option
<
Self
>
{
match
sig
{
c
:
:
SIGHUP
=
>
Some
(
Self
:
:
Hup
)
c
:
:
SIGINT
=
>
Some
(
Self
:
:
Int
)
c
:
:
SIGQUIT
=
>
Some
(
Self
:
:
Quit
)
c
:
:
SIGILL
=
>
Some
(
Self
:
:
Ill
)
c
:
:
SIGTRAP
=
>
Some
(
Self
:
:
Trap
)
c
:
:
SIGABRT
=
>
Some
(
Self
:
:
Abort
)
c
:
:
SIGBUS
=
>
Some
(
Self
:
:
Bus
)
c
:
:
SIGFPE
=
>
Some
(
Self
:
:
Fpe
)
c
:
:
SIGKILL
=
>
Some
(
Self
:
:
Kill
)
c
:
:
SIGUSR1
=
>
Some
(
Self
:
:
Usr1
)
c
:
:
SIGSEGV
=
>
Some
(
Self
:
:
Segv
)
c
:
:
SIGUSR2
=
>
Some
(
Self
:
:
Usr2
)
c
:
:
SIGPIPE
=
>
Some
(
Self
:
:
Pipe
)
c
:
:
SIGALRM
=
>
Some
(
Self
:
:
Alarm
)
c
:
:
SIGTERM
=
>
Some
(
Self
:
:
Term
)
#
[
cfg
(
not
(
any
(
bsd
solarish
target_os
=
"
aix
"
target_os
=
"
haiku
"
target_os
=
"
nto
"
all
(
linux_kernel
any
(
target_arch
=
"
mips
"
target_arch
=
"
mips32r6
"
target_arch
=
"
mips64
"
target_arch
=
"
mips64r6
"
target_arch
=
"
sparc
"
target_arch
=
"
sparc64
"
)
)
)
)
)
]
c
:
:
SIGSTKFLT
=
>
Some
(
Self
:
:
Stkflt
)
c
:
:
SIGCHLD
=
>
Some
(
Self
:
:
Child
)
c
:
:
SIGCONT
=
>
Some
(
Self
:
:
Cont
)
c
:
:
SIGSTOP
=
>
Some
(
Self
:
:
Stop
)
c
:
:
SIGTSTP
=
>
Some
(
Self
:
:
Tstp
)
c
:
:
SIGTTIN
=
>
Some
(
Self
:
:
Ttin
)
c
:
:
SIGTTOU
=
>
Some
(
Self
:
:
Ttou
)
c
:
:
SIGURG
=
>
Some
(
Self
:
:
Urg
)
c
:
:
SIGXCPU
=
>
Some
(
Self
:
:
Xcpu
)
c
:
:
SIGXFSZ
=
>
Some
(
Self
:
:
Xfsz
)
c
:
:
SIGVTALRM
=
>
Some
(
Self
:
:
Vtalarm
)
c
:
:
SIGPROF
=
>
Some
(
Self
:
:
Prof
)
c
:
:
SIGWINCH
=
>
Some
(
Self
:
:
Winch
)
#
[
cfg
(
not
(
target_os
=
"
haiku
"
)
)
]
c
:
:
SIGIO
=
>
Some
(
Self
:
:
Io
)
#
[
cfg
(
not
(
any
(
bsd
target_os
=
"
haiku
"
)
)
)
]
c
:
:
SIGPWR
=
>
Some
(
Self
:
:
Power
)
c
:
:
SIGSYS
=
>
Some
(
Self
:
:
Sys
)
#
[
cfg
(
any
(
bsd
solarish
target_os
=
"
aix
"
target_os
=
"
hermit
"
all
(
linux_kernel
any
(
target_arch
=
"
mips
"
target_arch
=
"
mips32r6
"
target_arch
=
"
mips64
"
target_arch
=
"
mips64r6
"
target_arch
=
"
sparc
"
target_arch
=
"
sparc64
"
)
)
)
)
]
c
:
:
SIGEMT
=
>
Some
(
Self
:
:
Emt
)
#
[
cfg
(
bsd
)
]
c
:
:
SIGINFO
=
>
Some
(
Self
:
:
Info
)
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
c
:
:
SIGTHR
=
>
Some
(
Self
:
:
Thr
)
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
c
:
:
SIGLIBRT
=
>
Some
(
Self
:
:
Librt
)
_
=
>
None
}
}
}
#
[
test
]
fn
test_sizes
(
)
{
assert_eq_size
!
(
Signal
c
:
:
c_int
)
;
}
