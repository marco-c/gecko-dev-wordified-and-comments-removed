#
!
[
no_std
]
#
!
[
doc
(
test
(
no_crate_inject
attr
(
deny
(
warnings
rust_2018_idioms
single_use_lifetimes
)
allow
(
dead_code
unused_variables
)
)
)
)
]
#
!
[
warn
(
missing_docs
rust_2018_idioms
single_use_lifetimes
unreachable_pub
)
]
#
!
[
warn
(
clippy
:
:
pedantic
clippy
:
:
alloc_instead_of_core
clippy
:
:
exhaustive_enums
clippy
:
:
exhaustive_structs
clippy
:
:
std_instead_of_alloc
clippy
:
:
std_instead_of_core
clippy
:
:
as_ptr_cast_mut
clippy
:
:
default_union_representation
clippy
:
:
trailing_empty_array
clippy
:
:
transmute_undefined_repr
clippy
:
:
undocumented_unsafe_blocks
)
]
#
!
[
allow
(
clippy
:
:
needless_doctest_main
)
]
#
[
doc
(
inline
)
]
pub
use
pin_project_internal
:
:
pin_project
;
#
[
doc
(
inline
)
]
pub
use
pin_project_internal
:
:
pinned_drop
;
pub
unsafe
trait
UnsafeUnpin
{
}
#
[
doc
(
hidden
)
]
pub
mod
__private
{
use
core
:
:
mem
:
:
ManuallyDrop
;
#
[
doc
(
hidden
)
]
pub
use
core
:
:
{
marker
:
:
{
PhantomData
PhantomPinned
Unpin
}
ops
:
:
Drop
pin
:
:
Pin
ptr
}
;
#
[
doc
(
hidden
)
]
pub
use
pin_project_internal
:
:
__PinProjectInternalDerive
;
use
super
:
:
UnsafeUnpin
;
#
[
doc
(
hidden
)
]
pub
trait
PinnedDrop
{
#
[
doc
(
hidden
)
]
unsafe
fn
drop
(
self
:
Pin
<
&
mut
Self
>
)
;
}
#
[
doc
(
hidden
)
]
pub
struct
Wrapper
<
'
a
T
:
?
Sized
>
(
PhantomData
<
&
'
a
(
)
>
T
)
;
unsafe
impl
<
T
:
?
Sized
+
UnsafeUnpin
>
UnsafeUnpin
for
Wrapper
<
'
_
T
>
{
}
#
[
doc
(
hidden
)
]
pub
struct
AlwaysUnpin
<
'
a
T
>
(
PhantomData
<
&
'
a
(
)
>
PhantomData
<
T
>
)
;
impl
<
T
>
Unpin
for
AlwaysUnpin
<
'
_
T
>
{
}
#
[
doc
(
hidden
)
]
pub
struct
UnsafeDropInPlaceGuard
<
T
:
?
Sized
>
(
*
mut
T
)
;
impl
<
T
:
?
Sized
>
UnsafeDropInPlaceGuard
<
T
>
{
#
[
doc
(
hidden
)
]
pub
unsafe
fn
new
(
ptr
:
*
mut
T
)
-
>
Self
{
Self
(
ptr
)
}
}
impl
<
T
:
?
Sized
>
Drop
for
UnsafeDropInPlaceGuard
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
ptr
:
:
drop_in_place
(
self
.
0
)
;
}
}
}
#
[
doc
(
hidden
)
]
pub
struct
UnsafeOverwriteGuard
<
T
>
{
target
:
*
mut
T
value
:
ManuallyDrop
<
T
>
}
impl
<
T
>
UnsafeOverwriteGuard
<
T
>
{
#
[
doc
(
hidden
)
]
pub
unsafe
fn
new
(
target
:
*
mut
T
value
:
T
)
-
>
Self
{
Self
{
target
value
:
ManuallyDrop
:
:
new
(
value
)
}
}
}
impl
<
T
>
Drop
for
UnsafeOverwriteGuard
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
ptr
:
:
write
(
self
.
target
ptr
:
:
read
(
&
*
self
.
value
)
)
;
}
}
}
}
