#
!
[
no_std
]
#
!
[
doc
(
test
(
no_crate_inject
attr
(
deny
(
warnings
rust_2018_idioms
single_use_lifetimes
)
allow
(
dead_code
)
)
)
)
]
#
!
[
warn
(
missing_docs
rust_2018_idioms
single_use_lifetimes
unreachable_pub
)
]
#
!
[
warn
(
clippy
:
:
default_trait_access
clippy
:
:
wildcard_imports
)
]
#
!
[
allow
(
clippy
:
:
mem_replace_with_default
clippy
:
:
manual_non_exhaustive
)
]
#
!
[
allow
(
clippy
:
:
needless_doctest_main
)
]
#
[
doc
(
inline
)
]
pub
use
pin_project_internal
:
:
pin_project
;
#
[
doc
(
inline
)
]
pub
use
pin_project_internal
:
:
pinned_drop
;
#
[
allow
(
deprecated
)
]
#
[
doc
(
inline
)
]
pub
use
pin_project_internal
:
:
project
;
#
[
allow
(
deprecated
)
]
#
[
doc
(
inline
)
]
pub
use
pin_project_internal
:
:
project_ref
;
#
[
allow
(
deprecated
)
]
#
[
doc
(
inline
)
]
pub
use
pin_project_internal
:
:
project_replace
;
pub
unsafe
trait
UnsafeUnpin
{
}
#
[
doc
(
hidden
)
]
pub
mod
__private
{
#
[
doc
(
hidden
)
]
pub
use
core
:
:
{
marker
:
:
{
PhantomData
PhantomPinned
Unpin
}
mem
:
:
ManuallyDrop
ops
:
:
Drop
pin
:
:
Pin
ptr
}
;
#
[
doc
(
hidden
)
]
pub
use
pin_project_internal
:
:
__PinProjectInternalDerive
;
use
super
:
:
UnsafeUnpin
;
#
[
doc
(
hidden
)
]
pub
trait
PinnedDrop
{
#
[
doc
(
hidden
)
]
unsafe
fn
drop
(
self
:
Pin
<
&
mut
Self
>
)
;
}
#
[
doc
(
hidden
)
]
pub
struct
Wrapper
<
'
a
T
:
?
Sized
>
(
PhantomData
<
&
'
a
(
)
>
T
)
;
unsafe
impl
<
T
:
?
Sized
>
UnsafeUnpin
for
Wrapper
<
'
_
T
>
where
T
:
UnsafeUnpin
{
}
#
[
doc
(
hidden
)
]
pub
struct
AlwaysUnpin
<
'
a
T
>
(
PhantomData
<
&
'
a
(
)
>
PhantomData
<
T
>
)
;
impl
<
T
>
Unpin
for
AlwaysUnpin
<
'
_
T
>
{
}
#
[
doc
(
hidden
)
]
pub
struct
UnsafeDropInPlaceGuard
<
T
:
?
Sized
>
(
pub
*
mut
T
)
;
impl
<
T
:
?
Sized
>
Drop
for
UnsafeDropInPlaceGuard
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
ptr
:
:
drop_in_place
(
self
.
0
)
;
}
}
}
#
[
doc
(
hidden
)
]
pub
struct
UnsafeOverwriteGuard
<
T
>
{
pub
value
:
ManuallyDrop
<
T
>
pub
target
:
*
mut
T
}
impl
<
T
>
Drop
for
UnsafeOverwriteGuard
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
ptr
:
:
write
(
self
.
target
ptr
:
:
read
(
&
*
self
.
value
)
)
;
}
}
}
}
