use
codec
:
:
{
RecvError
UserError
}
;
use
frame
:
:
{
self
Reason
}
;
use
super
:
:
{
store
Buffer
Codec
Config
Counts
Frame
Prioritize
Prioritized
Store
Stream
StreamId
StreamIdOverflow
WindowSize
}
;
use
bytes
:
:
Buf
;
use
http
;
use
futures
:
:
{
Async
Poll
}
;
use
futures
:
:
task
:
:
Task
;
use
tokio_io
:
:
AsyncWrite
;
use
std
:
:
io
;
#
[
derive
(
Debug
)
]
pub
(
super
)
struct
Send
{
next_stream_id
:
Result
<
StreamId
StreamIdOverflow
>
init_window_sz
:
WindowSize
prioritize
:
Prioritize
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
enum
PollReset
{
AwaitingHeaders
Streaming
}
impl
Send
{
pub
fn
new
(
config
:
&
Config
)
-
>
Self
{
Send
{
init_window_sz
:
config
.
remote_init_window_sz
next_stream_id
:
Ok
(
config
.
local_next_stream_id
)
prioritize
:
Prioritize
:
:
new
(
config
)
}
}
pub
fn
init_window_sz
(
&
self
)
-
>
WindowSize
{
self
.
init_window_sz
}
pub
fn
open
(
&
mut
self
)
-
>
Result
<
StreamId
UserError
>
{
let
stream_id
=
self
.
ensure_next_stream_id
(
)
?
;
self
.
next_stream_id
=
stream_id
.
next_id
(
)
;
Ok
(
stream_id
)
}
pub
fn
send_headers
<
B
>
(
&
mut
self
frame
:
frame
:
:
Headers
buffer
:
&
mut
Buffer
<
Frame
<
B
>
>
stream
:
&
mut
store
:
:
Ptr
counts
:
&
mut
Counts
task
:
&
mut
Option
<
Task
>
)
-
>
Result
<
(
)
UserError
>
{
trace
!
(
"
send_headers
;
frame
=
{
:
?
}
;
init_window
=
{
:
?
}
"
frame
self
.
init_window_sz
)
;
if
frame
.
fields
(
)
.
contains_key
(
http
:
:
header
:
:
CONNECTION
)
|
|
frame
.
fields
(
)
.
contains_key
(
http
:
:
header
:
:
TRANSFER_ENCODING
)
|
|
frame
.
fields
(
)
.
contains_key
(
http
:
:
header
:
:
UPGRADE
)
|
|
frame
.
fields
(
)
.
contains_key
(
"
keep
-
alive
"
)
|
|
frame
.
fields
(
)
.
contains_key
(
"
proxy
-
connection
"
)
{
debug
!
(
"
illegal
connection
-
specific
headers
found
"
)
;
return
Err
(
UserError
:
:
MalformedHeaders
)
;
}
else
if
let
Some
(
te
)
=
frame
.
fields
(
)
.
get
(
http
:
:
header
:
:
TE
)
{
if
te
!
=
"
trailers
"
{
debug
!
(
"
illegal
connection
-
specific
headers
found
"
)
;
return
Err
(
UserError
:
:
MalformedHeaders
)
;
}
}
let
end_stream
=
frame
.
is_end_stream
(
)
;
stream
.
state
.
send_open
(
end_stream
)
?
;
if
counts
.
peer
(
)
.
is_local_init
(
frame
.
stream_id
(
)
)
{
if
counts
.
can_inc_num_send_streams
(
)
{
counts
.
inc_num_send_streams
(
stream
)
;
}
else
{
self
.
prioritize
.
queue_open
(
stream
)
;
}
}
self
.
prioritize
.
queue_frame
(
frame
.
into
(
)
buffer
stream
task
)
;
Ok
(
(
)
)
}
pub
fn
send_reset
<
B
>
(
&
mut
self
reason
:
Reason
buffer
:
&
mut
Buffer
<
Frame
<
B
>
>
stream
:
&
mut
store
:
:
Ptr
counts
:
&
mut
Counts
task
:
&
mut
Option
<
Task
>
)
{
let
is_reset
=
stream
.
state
.
is_reset
(
)
;
let
is_closed
=
stream
.
state
.
is_closed
(
)
;
let
is_empty
=
stream
.
pending_send
.
is_empty
(
)
;
trace
!
(
"
send_reset
(
.
.
.
reason
=
{
:
?
}
stream
=
{
:
?
}
.
.
.
\
is_reset
=
{
:
?
}
;
is_closed
=
{
:
?
}
;
pending_send
.
is_empty
=
{
:
?
}
;
\
state
=
{
:
?
}
\
"
stream
.
id
reason
is_reset
is_closed
is_empty
stream
.
state
)
;
if
is_reset
{
trace
!
(
"
-
>
not
sending
RST_STREAM
(
{
:
?
}
is
already
reset
)
"
stream
.
id
)
;
return
;
}
stream
.
state
.
set_reset
(
reason
)
;
if
is_closed
&
&
is_empty
{
trace
!
(
"
-
>
not
sending
explicit
RST_STREAM
(
{
:
?
}
was
closed
\
and
send
queue
was
flushed
)
"
stream
.
id
)
;
return
;
}
self
.
recv_err
(
buffer
stream
counts
)
;
let
frame
=
frame
:
:
Reset
:
:
new
(
stream
.
id
reason
)
;
trace
!
(
"
send_reset
-
-
queueing
;
frame
=
{
:
?
}
"
frame
)
;
self
.
prioritize
.
queue_frame
(
frame
.
into
(
)
buffer
stream
task
)
;
}
pub
fn
schedule_implicit_reset
(
&
mut
self
stream
:
&
mut
store
:
:
Ptr
reason
:
Reason
counts
:
&
mut
Counts
task
:
&
mut
Option
<
Task
>
)
{
if
stream
.
state
.
is_closed
(
)
{
return
;
}
stream
.
state
.
set_scheduled_reset
(
reason
)
;
self
.
prioritize
.
reclaim_reserved_capacity
(
stream
counts
)
;
self
.
prioritize
.
schedule_send
(
stream
task
)
;
}
pub
fn
send_data
<
B
>
(
&
mut
self
frame
:
frame
:
:
Data
<
B
>
buffer
:
&
mut
Buffer
<
Frame
<
B
>
>
stream
:
&
mut
store
:
:
Ptr
counts
:
&
mut
Counts
task
:
&
mut
Option
<
Task
>
)
-
>
Result
<
(
)
UserError
>
where
B
:
Buf
{
self
.
prioritize
.
send_data
(
frame
buffer
stream
counts
task
)
}
pub
fn
send_trailers
<
B
>
(
&
mut
self
frame
:
frame
:
:
Headers
buffer
:
&
mut
Buffer
<
Frame
<
B
>
>
stream
:
&
mut
store
:
:
Ptr
counts
:
&
mut
Counts
task
:
&
mut
Option
<
Task
>
)
-
>
Result
<
(
)
UserError
>
{
if
!
stream
.
state
.
is_send_streaming
(
)
{
return
Err
(
UserError
:
:
UnexpectedFrameType
)
;
}
stream
.
state
.
send_close
(
)
;
trace
!
(
"
send_trailers
-
-
queuing
;
frame
=
{
:
?
}
"
frame
)
;
self
.
prioritize
.
queue_frame
(
frame
.
into
(
)
buffer
stream
task
)
;
self
.
prioritize
.
reserve_capacity
(
0
stream
counts
)
;
Ok
(
(
)
)
}
pub
fn
poll_complete
<
T
B
>
(
&
mut
self
buffer
:
&
mut
Buffer
<
Frame
<
B
>
>
store
:
&
mut
Store
counts
:
&
mut
Counts
dst
:
&
mut
Codec
<
T
Prioritized
<
B
>
>
)
-
>
Poll
<
(
)
io
:
:
Error
>
where
T
:
AsyncWrite
B
:
Buf
{
self
.
prioritize
.
poll_complete
(
buffer
store
counts
dst
)
}
pub
fn
reserve_capacity
(
&
mut
self
capacity
:
WindowSize
stream
:
&
mut
store
:
:
Ptr
counts
:
&
mut
Counts
)
{
self
.
prioritize
.
reserve_capacity
(
capacity
stream
counts
)
}
pub
fn
poll_capacity
(
&
mut
self
stream
:
&
mut
store
:
:
Ptr
)
-
>
Poll
<
Option
<
WindowSize
>
UserError
>
{
if
!
stream
.
state
.
is_send_streaming
(
)
{
return
Ok
(
Async
:
:
Ready
(
None
)
)
;
}
if
!
stream
.
send_capacity_inc
{
stream
.
wait_send
(
)
;
return
Ok
(
Async
:
:
NotReady
)
;
}
stream
.
send_capacity_inc
=
false
;
Ok
(
Async
:
:
Ready
(
Some
(
self
.
capacity
(
stream
)
)
)
)
}
pub
fn
capacity
(
&
self
stream
:
&
mut
store
:
:
Ptr
)
-
>
WindowSize
{
let
available
=
stream
.
send_flow
.
available
(
)
.
as_size
(
)
;
let
buffered
=
stream
.
buffered_send_data
;
if
available
<
=
buffered
{
0
}
else
{
available
-
buffered
}
}
pub
fn
poll_reset
(
&
self
stream
:
&
mut
Stream
mode
:
PollReset
)
-
>
Poll
<
Reason
:
:
Error
>
{
match
stream
.
state
.
ensure_reason
(
mode
)
?
{
Some
(
reason
)
=
>
Ok
(
reason
.
into
(
)
)
None
=
>
{
stream
.
wait_send
(
)
;
Ok
(
Async
:
:
NotReady
)
}
}
}
pub
fn
recv_connection_window_update
(
&
mut
self
frame
:
frame
:
:
WindowUpdate
store
:
&
mut
Store
counts
:
&
mut
Counts
)
-
>
Result
<
(
)
Reason
>
{
self
.
prioritize
.
recv_connection_window_update
(
frame
.
size_increment
(
)
store
counts
)
}
pub
fn
recv_stream_window_update
<
B
>
(
&
mut
self
sz
:
WindowSize
buffer
:
&
mut
Buffer
<
Frame
<
B
>
>
stream
:
&
mut
store
:
:
Ptr
counts
:
&
mut
Counts
task
:
&
mut
Option
<
Task
>
)
-
>
Result
<
(
)
Reason
>
{
if
let
Err
(
e
)
=
self
.
prioritize
.
recv_stream_window_update
(
sz
stream
)
{
debug
!
(
"
recv_stream_window_update
!
!
;
err
=
{
:
?
}
"
e
)
;
self
.
send_reset
(
Reason
:
:
FLOW_CONTROL_ERROR
.
into
(
)
buffer
stream
counts
task
)
;
return
Err
(
e
)
;
}
Ok
(
(
)
)
}
pub
fn
recv_reset
<
B
>
(
&
mut
self
buffer
:
&
mut
Buffer
<
Frame
<
B
>
>
stream
:
&
mut
store
:
:
Ptr
)
{
self
.
prioritize
.
clear_queue
(
buffer
stream
)
;
}
pub
fn
recv_err
<
B
>
(
&
mut
self
buffer
:
&
mut
Buffer
<
Frame
<
B
>
>
stream
:
&
mut
store
:
:
Ptr
counts
:
&
mut
Counts
)
{
self
.
prioritize
.
clear_queue
(
buffer
stream
)
;
self
.
prioritize
.
reclaim_all_capacity
(
stream
counts
)
;
}
pub
fn
apply_remote_settings
<
B
>
(
&
mut
self
settings
:
&
frame
:
:
Settings
buffer
:
&
mut
Buffer
<
Frame
<
B
>
>
store
:
&
mut
Store
counts
:
&
mut
Counts
task
:
&
mut
Option
<
Task
>
)
-
>
Result
<
(
)
RecvError
>
{
if
let
Some
(
val
)
=
settings
.
initial_window_size
(
)
{
let
old_val
=
self
.
init_window_sz
;
self
.
init_window_sz
=
val
;
if
val
<
old_val
{
let
dec
=
old_val
-
val
;
trace
!
(
"
decrementing
all
windows
;
dec
=
{
}
"
dec
)
;
let
mut
total_reclaimed
=
0
;
store
.
for_each
(
|
mut
stream
|
{
let
stream
=
&
mut
*
stream
;
stream
.
send_flow
.
dec_window
(
dec
)
;
let
window_size
=
stream
.
send_flow
.
window_size
(
)
;
let
available
=
stream
.
send_flow
.
available
(
)
.
as_size
(
)
;
let
reclaimed
=
if
available
>
window_size
{
let
reclaim
=
available
-
window_size
;
stream
.
send_flow
.
claim_capacity
(
reclaim
)
;
total_reclaimed
+
=
reclaim
;
reclaim
}
else
{
0
}
;
trace
!
(
"
decremented
stream
window
;
id
=
{
:
?
}
;
decr
=
{
}
;
reclaimed
=
{
}
;
flow
=
{
:
?
}
"
stream
.
id
dec
reclaimed
stream
.
send_flow
)
;
Ok
:
:
<
_
RecvError
>
(
(
)
)
}
)
?
;
self
.
prioritize
.
assign_connection_capacity
(
total_reclaimed
store
counts
)
;
}
else
if
val
>
old_val
{
let
inc
=
val
-
old_val
;
store
.
for_each
(
|
mut
stream
|
{
self
.
recv_stream_window_update
(
inc
buffer
&
mut
stream
counts
task
)
.
map_err
(
RecvError
:
:
Connection
)
}
)
?
;
}
}
Ok
(
(
)
)
}
pub
fn
clear_queues
(
&
mut
self
store
:
&
mut
Store
counts
:
&
mut
Counts
)
{
self
.
prioritize
.
clear_pending_capacity
(
store
counts
)
;
self
.
prioritize
.
clear_pending_send
(
store
counts
)
;
self
.
prioritize
.
clear_pending_open
(
store
counts
)
;
}
pub
fn
ensure_not_idle
(
&
self
id
:
StreamId
)
-
>
Result
<
(
)
Reason
>
{
if
let
Ok
(
next
)
=
self
.
next_stream_id
{
if
id
>
=
next
{
return
Err
(
Reason
:
:
PROTOCOL_ERROR
)
;
}
}
Ok
(
(
)
)
}
pub
fn
ensure_next_stream_id
(
&
self
)
-
>
Result
<
StreamId
UserError
>
{
self
.
next_stream_id
.
map_err
(
|
_
|
UserError
:
:
OverflowedStreamId
)
}
}
