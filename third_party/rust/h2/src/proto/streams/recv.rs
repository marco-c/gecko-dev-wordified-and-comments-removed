use
super
:
:
*
;
use
{
frame
proto
}
;
use
codec
:
:
{
RecvError
UserError
}
;
use
frame
:
:
{
Reason
DEFAULT_INITIAL_WINDOW_SIZE
}
;
use
http
:
:
HeaderMap
;
use
std
:
:
io
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
#
[
derive
(
Debug
)
]
pub
(
super
)
struct
Recv
{
init_window_sz
:
WindowSize
flow
:
FlowControl
in_flight_data
:
WindowSize
next_stream_id
:
Result
<
StreamId
StreamIdOverflow
>
last_processed_id
:
StreamId
max_stream_id
:
StreamId
pending_window_updates
:
store
:
:
Queue
<
stream
:
:
NextWindowUpdate
>
pending_accept
:
store
:
:
Queue
<
stream
:
:
NextAccept
>
pending_reset_expired
:
store
:
:
Queue
<
stream
:
:
NextResetExpire
>
reset_duration
:
Duration
buffer
:
Buffer
<
Event
>
refused
:
Option
<
StreamId
>
is_push_enabled
:
bool
}
#
[
derive
(
Debug
)
]
pub
(
super
)
enum
Event
{
Headers
(
peer
:
:
PollMessage
)
Data
(
Bytes
)
Trailers
(
HeaderMap
)
}
#
[
derive
(
Debug
)
]
pub
(
super
)
enum
RecvHeaderBlockError
<
T
>
{
Oversize
(
T
)
State
(
RecvError
)
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
enum
Open
{
PushPromise
Headers
}
#
[
derive
(
Debug
Clone
Copy
)
]
struct
Indices
{
head
:
store
:
:
Key
tail
:
store
:
:
Key
}
impl
Recv
{
pub
fn
new
(
peer
:
peer
:
:
Dyn
config
:
&
Config
)
-
>
Self
{
let
next_stream_id
=
if
peer
.
is_server
(
)
{
1
}
else
{
2
}
;
let
mut
flow
=
FlowControl
:
:
new
(
)
;
flow
.
inc_window
(
DEFAULT_INITIAL_WINDOW_SIZE
)
.
expect
(
"
invalid
initial
remote
window
size
"
)
;
flow
.
assign_capacity
(
DEFAULT_INITIAL_WINDOW_SIZE
)
;
Recv
{
init_window_sz
:
config
.
local_init_window_sz
flow
:
flow
in_flight_data
:
0
as
WindowSize
next_stream_id
:
Ok
(
next_stream_id
.
into
(
)
)
pending_window_updates
:
store
:
:
Queue
:
:
new
(
)
last_processed_id
:
StreamId
:
:
ZERO
max_stream_id
:
StreamId
:
:
MAX
pending_accept
:
store
:
:
Queue
:
:
new
(
)
pending_reset_expired
:
store
:
:
Queue
:
:
new
(
)
reset_duration
:
config
.
local_reset_duration
buffer
:
Buffer
:
:
new
(
)
refused
:
None
is_push_enabled
:
config
.
local_push_enabled
}
}
pub
fn
init_window_sz
(
&
self
)
-
>
WindowSize
{
self
.
init_window_sz
}
pub
fn
last_processed_id
(
&
self
)
-
>
StreamId
{
self
.
last_processed_id
}
pub
fn
open
(
&
mut
self
id
:
StreamId
mode
:
Open
counts
:
&
mut
Counts
)
-
>
Result
<
Option
<
StreamId
>
RecvError
>
{
assert
!
(
self
.
refused
.
is_none
(
)
)
;
counts
.
peer
(
)
.
ensure_can_open
(
id
mode
)
?
;
let
next_id
=
self
.
next_stream_id
(
)
?
;
if
id
<
next_id
{
trace
!
(
"
id
(
{
:
?
}
)
<
next_id
(
{
:
?
}
)
PROTOCOL_ERROR
"
id
next_id
)
;
return
Err
(
RecvError
:
:
Connection
(
Reason
:
:
PROTOCOL_ERROR
)
)
;
}
self
.
next_stream_id
=
id
.
next_id
(
)
;
if
!
counts
.
can_inc_num_recv_streams
(
)
{
self
.
refused
=
Some
(
id
)
;
return
Ok
(
None
)
;
}
Ok
(
Some
(
id
)
)
}
pub
fn
recv_headers
(
&
mut
self
frame
:
frame
:
:
Headers
stream
:
&
mut
store
:
:
Ptr
counts
:
&
mut
Counts
)
-
>
Result
<
(
)
RecvHeaderBlockError
<
Option
<
frame
:
:
Headers
>
>
>
{
trace
!
(
"
opening
stream
;
init_window
=
{
}
"
self
.
init_window_sz
)
;
let
is_initial
=
stream
.
state
.
recv_open
(
frame
.
is_end_stream
(
)
)
?
;
if
is_initial
{
if
frame
.
stream_id
(
)
>
self
.
last_processed_id
{
self
.
last_processed_id
=
frame
.
stream_id
(
)
;
}
counts
.
inc_num_recv_streams
(
stream
)
;
}
if
!
stream
.
content_length
.
is_head
(
)
{
use
super
:
:
stream
:
:
ContentLength
;
use
http
:
:
header
;
if
let
Some
(
content_length
)
=
frame
.
fields
(
)
.
get
(
header
:
:
CONTENT_LENGTH
)
{
let
content_length
=
match
parse_u64
(
content_length
.
as_bytes
(
)
)
{
Ok
(
v
)
=
>
v
Err
(
_
)
=
>
{
return
Err
(
RecvError
:
:
Stream
{
id
:
stream
.
id
reason
:
Reason
:
:
PROTOCOL_ERROR
}
.
into
(
)
)
}
}
;
stream
.
content_length
=
ContentLength
:
:
Remaining
(
content_length
)
;
}
}
if
frame
.
is_over_size
(
)
{
trace
!
(
"
recv_headers
;
frame
for
{
:
?
}
is
over
size
"
stream
.
id
)
;
return
if
counts
.
peer
(
)
.
is_server
(
)
&
&
is_initial
{
let
mut
res
=
frame
:
:
Headers
:
:
new
(
stream
.
id
frame
:
:
Pseudo
:
:
response
(
:
:
http
:
:
StatusCode
:
:
REQUEST_HEADER_FIELDS_TOO_LARGE
)
HeaderMap
:
:
new
(
)
)
;
res
.
set_end_stream
(
)
;
Err
(
RecvHeaderBlockError
:
:
Oversize
(
Some
(
res
)
)
)
}
else
{
Err
(
RecvHeaderBlockError
:
:
Oversize
(
None
)
)
}
;
}
let
message
=
counts
.
peer
(
)
.
convert_poll_message
(
frame
)
?
;
stream
.
pending_recv
.
push_back
(
&
mut
self
.
buffer
Event
:
:
Headers
(
message
)
)
;
stream
.
notify_recv
(
)
;
if
counts
.
peer
(
)
.
is_server
(
)
{
self
.
pending_accept
.
push
(
stream
)
;
}
Ok
(
(
)
)
}
pub
fn
take_request
(
&
mut
self
stream
:
&
mut
store
:
:
Ptr
)
-
>
Request
<
(
)
>
{
use
super
:
:
peer
:
:
PollMessage
:
:
*
;
match
stream
.
pending_recv
.
pop_front
(
&
mut
self
.
buffer
)
{
Some
(
Event
:
:
Headers
(
Server
(
request
)
)
)
=
>
request
_
=
>
panic
!
(
)
}
}
pub
fn
poll_response
(
&
mut
self
stream
:
&
mut
store
:
:
Ptr
)
-
>
Poll
<
Response
<
(
)
>
proto
:
:
Error
>
{
use
super
:
:
peer
:
:
PollMessage
:
:
*
;
match
stream
.
pending_recv
.
pop_front
(
&
mut
self
.
buffer
)
{
Some
(
Event
:
:
Headers
(
Client
(
response
)
)
)
=
>
Ok
(
response
.
into
(
)
)
Some
(
_
)
=
>
panic
!
(
"
poll_response
called
after
response
returned
"
)
None
=
>
{
stream
.
state
.
ensure_recv_open
(
)
?
;
stream
.
recv_task
=
Some
(
task
:
:
current
(
)
)
;
Ok
(
Async
:
:
NotReady
)
}
}
}
pub
fn
recv_trailers
(
&
mut
self
frame
:
frame
:
:
Headers
stream
:
&
mut
store
:
:
Ptr
)
-
>
Result
<
(
)
RecvError
>
{
stream
.
state
.
recv_close
(
)
?
;
if
stream
.
ensure_content_length_zero
(
)
.
is_err
(
)
{
return
Err
(
RecvError
:
:
Stream
{
id
:
stream
.
id
reason
:
Reason
:
:
PROTOCOL_ERROR
}
)
;
}
let
trailers
=
frame
.
into_fields
(
)
;
stream
.
pending_recv
.
push_back
(
&
mut
self
.
buffer
Event
:
:
Trailers
(
trailers
)
)
;
stream
.
notify_recv
(
)
;
Ok
(
(
)
)
}
pub
fn
release_connection_capacity
(
&
mut
self
capacity
:
WindowSize
task
:
&
mut
Option
<
Task
>
)
{
trace
!
(
"
release_connection_capacity
;
size
=
{
}
"
capacity
)
;
self
.
in_flight_data
-
=
capacity
;
self
.
flow
.
assign_capacity
(
capacity
)
;
if
self
.
flow
.
unclaimed_capacity
(
)
.
is_some
(
)
{
if
let
Some
(
task
)
=
task
.
take
(
)
{
task
.
notify
(
)
;
}
}
}
pub
fn
release_capacity
(
&
mut
self
capacity
:
WindowSize
stream
:
&
mut
store
:
:
Ptr
task
:
&
mut
Option
<
Task
>
)
-
>
Result
<
(
)
UserError
>
{
trace
!
(
"
release_capacity
;
size
=
{
}
"
capacity
)
;
if
capacity
>
stream
.
in_flight_recv_data
{
return
Err
(
UserError
:
:
ReleaseCapacityTooBig
)
;
}
self
.
release_connection_capacity
(
capacity
task
)
;
stream
.
in_flight_recv_data
-
=
capacity
;
stream
.
recv_flow
.
assign_capacity
(
capacity
)
;
if
stream
.
recv_flow
.
unclaimed_capacity
(
)
.
is_some
(
)
{
self
.
pending_window_updates
.
push
(
stream
)
;
if
let
Some
(
task
)
=
task
.
take
(
)
{
task
.
notify
(
)
;
}
}
Ok
(
(
)
)
}
pub
fn
set_target_connection_window
(
&
mut
self
target
:
WindowSize
task
:
&
mut
Option
<
Task
>
)
{
trace
!
(
"
set_target_connection_window
;
target
=
{
}
;
available
=
{
}
reserved
=
{
}
"
target
self
.
flow
.
available
(
)
self
.
in_flight_data
)
;
let
current
=
(
self
.
flow
.
available
(
)
+
self
.
in_flight_data
)
.
checked_size
(
)
;
if
target
>
current
{
self
.
flow
.
assign_capacity
(
target
-
current
)
;
}
else
{
self
.
flow
.
claim_capacity
(
current
-
target
)
;
}
if
self
.
flow
.
unclaimed_capacity
(
)
.
is_some
(
)
{
if
let
Some
(
task
)
=
task
.
take
(
)
{
task
.
notify
(
)
;
}
}
}
pub
fn
body_is_empty
(
&
self
stream
:
&
store
:
:
Ptr
)
-
>
bool
{
if
!
stream
.
state
.
is_recv_closed
(
)
{
return
false
;
}
stream
.
pending_recv
.
peek_front
(
&
self
.
buffer
)
.
map
(
|
event
|
!
event
.
is_data
(
)
)
.
unwrap_or
(
true
)
}
pub
fn
is_end_stream
(
&
self
stream
:
&
store
:
:
Ptr
)
-
>
bool
{
if
!
stream
.
state
.
is_recv_closed
(
)
{
return
false
;
}
stream
.
pending_recv
.
is_empty
(
)
}
pub
fn
recv_data
(
&
mut
self
frame
:
frame
:
:
Data
stream
:
&
mut
store
:
:
Ptr
)
-
>
Result
<
(
)
RecvError
>
{
let
sz
=
frame
.
payload
(
)
.
len
(
)
;
assert
!
(
sz
<
=
MAX_WINDOW_SIZE
as
usize
)
;
let
sz
=
sz
as
WindowSize
;
let
is_ignoring_frame
=
stream
.
state
.
is_local_reset
(
)
;
if
!
is_ignoring_frame
&
&
!
stream
.
state
.
is_recv_streaming
(
)
{
return
Err
(
RecvError
:
:
Connection
(
Reason
:
:
PROTOCOL_ERROR
)
)
;
}
trace
!
(
"
recv_data
;
size
=
{
}
;
connection
=
{
}
;
stream
=
{
}
"
sz
self
.
flow
.
window_size
(
)
stream
.
recv_flow
.
window_size
(
)
)
;
self
.
consume_connection_window
(
sz
)
?
;
if
is_ignoring_frame
{
trace
!
(
"
recv_data
frame
ignored
on
locally
reset
{
:
?
}
for
some
time
"
stream
.
id
)
;
self
.
release_connection_capacity
(
sz
&
mut
None
)
;
return
Ok
(
(
)
)
;
}
if
stream
.
recv_flow
.
window_size
(
)
<
sz
{
return
Err
(
RecvError
:
:
Stream
{
id
:
stream
.
id
reason
:
Reason
:
:
FLOW_CONTROL_ERROR
}
)
;
}
stream
.
recv_flow
.
send_data
(
sz
)
;
stream
.
in_flight_recv_data
+
=
sz
;
if
stream
.
dec_content_length
(
frame
.
payload
(
)
.
len
(
)
)
.
is_err
(
)
{
trace
!
(
"
content
-
length
overflow
"
)
;
return
Err
(
RecvError
:
:
Stream
{
id
:
stream
.
id
reason
:
Reason
:
:
PROTOCOL_ERROR
}
)
;
}
if
frame
.
is_end_stream
(
)
{
if
stream
.
ensure_content_length_zero
(
)
.
is_err
(
)
{
trace
!
(
"
content
-
length
underflow
"
)
;
return
Err
(
RecvError
:
:
Stream
{
id
:
stream
.
id
reason
:
Reason
:
:
PROTOCOL_ERROR
}
)
;
}
if
stream
.
state
.
recv_close
(
)
.
is_err
(
)
{
trace
!
(
"
failed
to
transition
to
closed
state
"
)
;
return
Err
(
RecvError
:
:
Connection
(
Reason
:
:
PROTOCOL_ERROR
)
)
;
}
}
let
event
=
Event
:
:
Data
(
frame
.
into_payload
(
)
)
;
stream
.
pending_recv
.
push_back
(
&
mut
self
.
buffer
event
)
;
stream
.
notify_recv
(
)
;
Ok
(
(
)
)
}
pub
fn
consume_connection_window
(
&
mut
self
sz
:
WindowSize
)
-
>
Result
<
(
)
RecvError
>
{
if
self
.
flow
.
window_size
(
)
<
sz
{
return
Err
(
RecvError
:
:
Connection
(
Reason
:
:
FLOW_CONTROL_ERROR
)
)
;
}
self
.
flow
.
send_data
(
sz
)
;
self
.
in_flight_data
+
=
sz
;
Ok
(
(
)
)
}
pub
fn
recv_push_promise
(
&
mut
self
frame
:
frame
:
:
PushPromise
stream
:
&
mut
store
:
:
Ptr
)
-
>
Result
<
(
)
RecvError
>
{
stream
.
state
.
reserve_remote
(
)
?
;
if
frame
.
is_over_size
(
)
{
trace
!
(
"
recv_push_promise
;
frame
for
{
:
?
}
is
over
size
"
frame
.
promised_id
(
)
)
;
return
Err
(
RecvError
:
:
Stream
{
id
:
frame
.
promised_id
(
)
reason
:
Reason
:
:
REFUSED_STREAM
}
)
;
}
Ok
(
(
)
)
}
pub
fn
ensure_not_idle
(
&
self
id
:
StreamId
)
-
>
Result
<
(
)
Reason
>
{
if
let
Ok
(
next
)
=
self
.
next_stream_id
{
if
id
>
=
next
{
trace
!
(
"
stream
ID
implicitly
closed
"
)
;
return
Err
(
Reason
:
:
PROTOCOL_ERROR
)
;
}
}
Ok
(
(
)
)
}
pub
fn
recv_reset
(
&
mut
self
frame
:
frame
:
:
Reset
stream
:
&
mut
Stream
)
{
stream
.
state
.
recv_reset
(
frame
.
reason
(
)
stream
.
is_pending_send
)
;
stream
.
notify_send
(
)
;
stream
.
notify_recv
(
)
;
}
pub
fn
recv_err
(
&
mut
self
err
:
&
proto
:
:
Error
stream
:
&
mut
Stream
)
{
stream
.
state
.
recv_err
(
err
)
;
stream
.
notify_send
(
)
;
stream
.
notify_recv
(
)
;
}
pub
fn
go_away
(
&
mut
self
last_processed_id
:
StreamId
)
{
assert
!
(
self
.
max_stream_id
>
=
last_processed_id
)
;
self
.
max_stream_id
=
last_processed_id
;
}
pub
fn
recv_eof
(
&
mut
self
stream
:
&
mut
Stream
)
{
stream
.
state
.
recv_eof
(
)
;
stream
.
notify_send
(
)
;
stream
.
notify_recv
(
)
;
}
pub
fn
max_stream_id
(
&
self
)
-
>
StreamId
{
self
.
max_stream_id
}
fn
next_stream_id
(
&
self
)
-
>
Result
<
StreamId
RecvError
>
{
if
let
Ok
(
id
)
=
self
.
next_stream_id
{
Ok
(
id
)
}
else
{
Err
(
RecvError
:
:
Connection
(
Reason
:
:
PROTOCOL_ERROR
)
)
}
}
pub
fn
ensure_can_reserve
(
&
self
)
-
>
Result
<
(
)
RecvError
>
{
if
!
self
.
is_push_enabled
{
trace
!
(
"
recv_push_promise
;
error
push
is
disabled
"
)
;
return
Err
(
RecvError
:
:
Connection
(
Reason
:
:
PROTOCOL_ERROR
)
)
;
}
Ok
(
(
)
)
}
pub
fn
enqueue_reset_expiration
(
&
mut
self
stream
:
&
mut
store
:
:
Ptr
counts
:
&
mut
Counts
)
{
if
!
stream
.
state
.
is_local_reset
(
)
|
|
stream
.
is_pending_reset_expiration
(
)
{
return
;
}
trace
!
(
"
enqueue_reset_expiration
;
{
:
?
}
"
stream
.
id
)
;
if
!
counts
.
can_inc_num_reset_streams
(
)
{
if
let
Some
(
evicted
)
=
self
.
pending_reset_expired
.
pop
(
stream
.
store_mut
(
)
)
{
counts
.
transition_after
(
evicted
true
)
;
}
}
if
counts
.
can_inc_num_reset_streams
(
)
{
counts
.
inc_num_reset_streams
(
)
;
self
.
pending_reset_expired
.
push
(
stream
)
;
}
}
pub
fn
send_pending_refusal
<
T
B
>
(
&
mut
self
dst
:
&
mut
Codec
<
T
Prioritized
<
B
>
>
)
-
>
Poll
<
(
)
io
:
:
Error
>
where
T
:
AsyncWrite
B
:
Buf
{
if
let
Some
(
stream_id
)
=
self
.
refused
{
try_ready
!
(
dst
.
poll_ready
(
)
)
;
let
frame
=
frame
:
:
Reset
:
:
new
(
stream_id
Reason
:
:
REFUSED_STREAM
)
;
dst
.
buffer
(
frame
.
into
(
)
)
.
ok
(
)
.
expect
(
"
invalid
RST_STREAM
frame
"
)
;
}
self
.
refused
=
None
;
Ok
(
Async
:
:
Ready
(
(
)
)
)
}
pub
fn
clear_expired_reset_streams
(
&
mut
self
store
:
&
mut
Store
counts
:
&
mut
Counts
)
{
let
now
=
Instant
:
:
now
(
)
;
let
reset_duration
=
self
.
reset_duration
;
while
let
Some
(
stream
)
=
self
.
pending_reset_expired
.
pop_if
(
store
|
stream
|
{
let
reset_at
=
stream
.
reset_at
.
expect
(
"
reset_at
must
be
set
if
in
queue
"
)
;
now
-
reset_at
>
reset_duration
}
)
{
counts
.
transition_after
(
stream
true
)
;
}
}
pub
fn
clear_queues
(
&
mut
self
clear_pending_accept
:
bool
store
:
&
mut
Store
counts
:
&
mut
Counts
)
{
self
.
clear_stream_window_update_queue
(
store
counts
)
;
self
.
clear_all_reset_streams
(
store
counts
)
;
if
clear_pending_accept
{
self
.
clear_all_pending_accept
(
store
counts
)
;
}
}
fn
clear_stream_window_update_queue
(
&
mut
self
store
:
&
mut
Store
counts
:
&
mut
Counts
)
{
while
let
Some
(
stream
)
=
self
.
pending_window_updates
.
pop
(
store
)
{
counts
.
transition
(
stream
|
_
stream
|
{
trace
!
(
"
clear_stream_window_update_queue
;
stream
=
{
:
?
}
"
stream
.
id
)
;
}
)
}
}
fn
clear_all_reset_streams
(
&
mut
self
store
:
&
mut
Store
counts
:
&
mut
Counts
)
{
while
let
Some
(
stream
)
=
self
.
pending_reset_expired
.
pop
(
store
)
{
counts
.
transition_after
(
stream
true
)
;
}
}
fn
clear_all_pending_accept
(
&
mut
self
store
:
&
mut
Store
counts
:
&
mut
Counts
)
{
while
let
Some
(
stream
)
=
self
.
pending_accept
.
pop
(
store
)
{
counts
.
transition_after
(
stream
false
)
;
}
}
pub
fn
poll_complete
<
T
B
>
(
&
mut
self
store
:
&
mut
Store
counts
:
&
mut
Counts
dst
:
&
mut
Codec
<
T
Prioritized
<
B
>
>
)
-
>
Poll
<
(
)
io
:
:
Error
>
where
T
:
AsyncWrite
B
:
Buf
{
try_ready
!
(
self
.
send_connection_window_update
(
dst
)
)
;
try_ready
!
(
self
.
send_stream_window_updates
(
store
counts
dst
)
)
;
Ok
(
(
)
.
into
(
)
)
}
fn
send_connection_window_update
<
T
B
>
(
&
mut
self
dst
:
&
mut
Codec
<
T
Prioritized
<
B
>
>
)
-
>
Poll
<
(
)
io
:
:
Error
>
where
T
:
AsyncWrite
B
:
Buf
{
if
let
Some
(
incr
)
=
self
.
flow
.
unclaimed_capacity
(
)
{
let
frame
=
frame
:
:
WindowUpdate
:
:
new
(
StreamId
:
:
zero
(
)
incr
)
;
try_ready
!
(
dst
.
poll_ready
(
)
)
;
dst
.
buffer
(
frame
.
into
(
)
)
.
ok
(
)
.
expect
(
"
invalid
WINDOW_UPDATE
frame
"
)
;
self
.
flow
.
inc_window
(
incr
)
.
ok
(
)
.
expect
(
"
unexpected
flow
control
state
"
)
;
}
Ok
(
(
)
.
into
(
)
)
}
pub
fn
send_stream_window_updates
<
T
B
>
(
&
mut
self
store
:
&
mut
Store
counts
:
&
mut
Counts
dst
:
&
mut
Codec
<
T
Prioritized
<
B
>
>
)
-
>
Poll
<
(
)
io
:
:
Error
>
where
T
:
AsyncWrite
B
:
Buf
{
loop
{
try_ready
!
(
dst
.
poll_ready
(
)
)
;
let
stream
=
match
self
.
pending_window_updates
.
pop
(
store
)
{
Some
(
stream
)
=
>
stream
None
=
>
return
Ok
(
(
)
.
into
(
)
)
}
;
counts
.
transition
(
stream
|
_
stream
|
{
trace
!
(
"
pending_window_updates
-
-
pop
;
stream
=
{
:
?
}
"
stream
.
id
)
;
debug_assert
!
(
!
stream
.
is_pending_window_update
)
;
if
!
stream
.
state
.
is_recv_streaming
(
)
{
return
;
}
if
let
Some
(
incr
)
=
stream
.
recv_flow
.
unclaimed_capacity
(
)
{
let
frame
=
frame
:
:
WindowUpdate
:
:
new
(
stream
.
id
incr
)
;
dst
.
buffer
(
frame
.
into
(
)
)
.
ok
(
)
.
expect
(
"
invalid
WINDOW_UPDATE
frame
"
)
;
stream
.
recv_flow
.
inc_window
(
incr
)
.
ok
(
)
.
expect
(
"
unexpected
flow
control
state
"
)
;
}
}
)
}
}
pub
fn
next_incoming
(
&
mut
self
store
:
&
mut
Store
)
-
>
Option
<
store
:
:
Key
>
{
self
.
pending_accept
.
pop
(
store
)
.
map
(
|
ptr
|
ptr
.
key
(
)
)
}
pub
fn
poll_data
(
&
mut
self
stream
:
&
mut
Stream
)
-
>
Poll
<
Option
<
Bytes
>
proto
:
:
Error
>
{
match
stream
.
pending_recv
.
pop_front
(
&
mut
self
.
buffer
)
{
Some
(
Event
:
:
Data
(
payload
)
)
=
>
Ok
(
Some
(
payload
)
.
into
(
)
)
Some
(
event
)
=
>
{
stream
.
pending_recv
.
push_front
(
&
mut
self
.
buffer
event
)
;
stream
.
notify_recv
(
)
;
Ok
(
None
.
into
(
)
)
}
None
=
>
self
.
schedule_recv
(
stream
)
}
}
pub
fn
poll_trailers
(
&
mut
self
stream
:
&
mut
Stream
)
-
>
Poll
<
Option
<
HeaderMap
>
proto
:
:
Error
>
{
match
stream
.
pending_recv
.
pop_front
(
&
mut
self
.
buffer
)
{
Some
(
Event
:
:
Trailers
(
trailers
)
)
=
>
Ok
(
Some
(
trailers
)
.
into
(
)
)
Some
(
event
)
=
>
{
stream
.
pending_recv
.
push_front
(
&
mut
self
.
buffer
event
)
;
Ok
(
Async
:
:
NotReady
)
}
None
=
>
self
.
schedule_recv
(
stream
)
}
}
fn
schedule_recv
<
T
>
(
&
mut
self
stream
:
&
mut
Stream
)
-
>
Poll
<
Option
<
T
>
proto
:
:
Error
>
{
if
stream
.
state
.
ensure_recv_open
(
)
?
{
stream
.
recv_task
=
Some
(
task
:
:
current
(
)
)
;
Ok
(
Async
:
:
NotReady
)
}
else
{
Ok
(
None
.
into
(
)
)
}
}
}
impl
Event
{
fn
is_data
(
&
self
)
-
>
bool
{
match
*
self
{
Event
:
:
Data
(
.
.
)
=
>
true
_
=
>
false
}
}
}
impl
Open
{
pub
fn
is_push_promise
(
&
self
)
-
>
bool
{
use
self
:
:
Open
:
:
*
;
match
*
self
{
PushPromise
=
>
true
_
=
>
false
}
}
}
impl
<
T
>
From
<
RecvError
>
for
RecvHeaderBlockError
<
T
>
{
fn
from
(
err
:
RecvError
)
-
>
Self
{
RecvHeaderBlockError
:
:
State
(
err
)
}
}
fn
parse_u64
(
src
:
&
[
u8
]
)
-
>
Result
<
u64
(
)
>
{
if
src
.
len
(
)
>
19
{
return
Err
(
(
)
)
;
}
let
mut
ret
=
0
;
for
&
d
in
src
{
if
d
<
b
'
0
'
|
|
d
>
b
'
9
'
{
return
Err
(
(
)
)
;
}
ret
*
=
10
;
ret
+
=
(
d
-
b
'
0
'
)
as
u64
;
}
Ok
(
ret
)
}
