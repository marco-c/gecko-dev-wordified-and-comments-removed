use
{
client
frame
proto
server
}
;
use
codec
:
:
RecvError
;
use
frame
:
:
{
Reason
StreamId
}
;
use
frame
:
:
DEFAULT_INITIAL_WINDOW_SIZE
;
use
proto
:
:
*
;
use
bytes
:
:
{
Bytes
IntoBuf
}
;
use
futures
:
:
Stream
;
use
tokio_io
:
:
{
AsyncRead
AsyncWrite
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
io
;
use
std
:
:
time
:
:
Duration
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Connection
<
T
P
B
:
IntoBuf
=
Bytes
>
where
P
:
Peer
{
state
:
State
error
:
Option
<
Reason
>
codec
:
Codec
<
T
Prioritized
<
B
:
:
Buf
>
>
go_away
:
GoAway
ping_pong
:
PingPong
settings
:
Settings
streams
:
Streams
<
B
:
:
Buf
P
>
_phantom
:
PhantomData
<
P
>
}
#
[
derive
(
Debug
Clone
)
]
pub
(
crate
)
struct
Config
{
pub
next_stream_id
:
StreamId
pub
initial_max_send_streams
:
usize
pub
reset_stream_duration
:
Duration
pub
reset_stream_max
:
usize
pub
settings
:
frame
:
:
Settings
}
#
[
derive
(
Debug
)
]
enum
State
{
Open
Closing
(
Reason
)
Closed
(
Reason
)
}
impl
<
T
P
B
>
Connection
<
T
P
B
>
where
T
:
AsyncRead
+
AsyncWrite
P
:
Peer
B
:
IntoBuf
{
pub
fn
new
(
codec
:
Codec
<
T
Prioritized
<
B
:
:
Buf
>
>
config
:
Config
)
-
>
Connection
<
T
P
B
>
{
let
streams
=
Streams
:
:
new
(
streams
:
:
Config
{
local_init_window_sz
:
config
.
settings
.
initial_window_size
(
)
.
unwrap_or
(
DEFAULT_INITIAL_WINDOW_SIZE
)
initial_max_send_streams
:
config
.
initial_max_send_streams
local_next_stream_id
:
config
.
next_stream_id
local_push_enabled
:
config
.
settings
.
is_push_enabled
(
)
local_reset_duration
:
config
.
reset_stream_duration
local_reset_max
:
config
.
reset_stream_max
remote_init_window_sz
:
DEFAULT_INITIAL_WINDOW_SIZE
remote_max_initiated
:
config
.
settings
.
max_concurrent_streams
(
)
.
map
(
|
max
|
max
as
usize
)
}
)
;
Connection
{
state
:
State
:
:
Open
error
:
None
codec
:
codec
go_away
:
GoAway
:
:
new
(
)
ping_pong
:
PingPong
:
:
new
(
)
settings
:
Settings
:
:
new
(
)
streams
:
streams
_phantom
:
PhantomData
}
}
pub
fn
set_target_window_size
(
&
mut
self
size
:
WindowSize
)
{
self
.
streams
.
set_target_connection_window_size
(
size
)
;
}
fn
poll_ready
(
&
mut
self
)
-
>
Poll
<
(
)
RecvError
>
{
try_ready
!
(
self
.
ping_pong
.
send_pending_pong
(
&
mut
self
.
codec
)
)
;
try_ready
!
(
self
.
ping_pong
.
send_pending_ping
(
&
mut
self
.
codec
)
)
;
try_ready
!
(
self
.
settings
.
send_pending_ack
(
&
mut
self
.
codec
&
mut
self
.
streams
)
)
;
try_ready
!
(
self
.
streams
.
send_pending_refusal
(
&
mut
self
.
codec
)
)
;
Ok
(
(
)
.
into
(
)
)
}
fn
poll_go_away
(
&
mut
self
)
-
>
Poll
<
Option
<
Reason
>
io
:
:
Error
>
{
self
.
go_away
.
send_pending_go_away
(
&
mut
self
.
codec
)
}
fn
go_away
(
&
mut
self
id
:
StreamId
e
:
Reason
)
{
let
frame
=
frame
:
:
GoAway
:
:
new
(
id
e
)
;
self
.
streams
.
send_go_away
(
id
)
;
self
.
go_away
.
go_away
(
frame
)
;
}
pub
fn
go_away_now
(
&
mut
self
e
:
Reason
)
{
let
last_processed_id
=
self
.
streams
.
last_processed_id
(
)
;
let
frame
=
frame
:
:
GoAway
:
:
new
(
last_processed_id
e
)
;
self
.
go_away
.
go_away_now
(
frame
)
;
}
fn
take_error
(
&
mut
self
ours
:
Reason
)
-
>
Poll
<
(
)
proto
:
:
Error
>
{
let
reason
=
if
let
Some
(
theirs
)
=
self
.
error
.
take
(
)
{
match
(
ours
theirs
)
{
(
Reason
:
:
NO_ERROR
err
)
|
(
err
Reason
:
:
NO_ERROR
)
=
>
err
(
_
theirs
)
=
>
theirs
}
}
else
{
ours
}
;
if
reason
=
=
Reason
:
:
NO_ERROR
{
Ok
(
(
)
.
into
(
)
)
}
else
{
Err
(
proto
:
:
Error
:
:
Proto
(
reason
)
)
}
}
pub
fn
maybe_close_connection_if_no_streams
(
&
mut
self
)
{
if
self
.
streams
.
num_active_streams
(
)
=
=
0
&
&
!
self
.
streams
.
has_streams_or_other_references
(
)
{
self
.
go_away_now
(
Reason
:
:
NO_ERROR
)
;
}
}
pub
fn
poll
(
&
mut
self
)
-
>
Poll
<
(
)
proto
:
:
Error
>
{
use
codec
:
:
RecvError
:
:
*
;
loop
{
match
self
.
state
{
State
:
:
Open
=
>
{
match
self
.
poll2
(
)
{
Ok
(
Async
:
:
Ready
(
(
)
)
)
=
>
return
self
.
take_error
(
Reason
:
:
NO_ERROR
)
Ok
(
Async
:
:
NotReady
)
=
>
{
try_ready
!
(
self
.
streams
.
poll_complete
(
&
mut
self
.
codec
)
)
;
if
self
.
error
.
is_some
(
)
|
|
self
.
go_away
.
should_close_on_idle
(
)
{
if
self
.
streams
.
num_active_streams
(
)
=
=
0
{
self
.
go_away_now
(
Reason
:
:
NO_ERROR
)
;
continue
;
}
}
return
Ok
(
Async
:
:
NotReady
)
;
}
Err
(
Connection
(
e
)
)
=
>
{
debug
!
(
"
Connection
:
:
poll
;
err
=
{
:
?
}
"
e
)
;
if
let
Some
(
reason
)
=
self
.
go_away
.
going_away_reason
(
)
{
if
reason
=
=
e
{
trace
!
(
"
-
>
already
going
away
"
)
;
self
.
state
=
State
:
:
Closing
(
e
)
;
continue
;
}
}
self
.
streams
.
recv_err
(
&
e
.
into
(
)
)
;
self
.
go_away_now
(
e
)
;
}
Err
(
Stream
{
id
reason
}
)
=
>
{
trace
!
(
"
stream
level
error
;
id
=
{
:
?
}
;
reason
=
{
:
?
}
"
id
reason
)
;
self
.
streams
.
send_reset
(
id
reason
)
;
}
Err
(
Io
(
e
)
)
=
>
{
let
e
=
e
.
into
(
)
;
self
.
streams
.
recv_err
(
&
e
)
;
return
Err
(
e
)
;
}
}
}
State
:
:
Closing
(
reason
)
=
>
{
trace
!
(
"
connection
closing
after
flush
reason
=
{
:
?
}
"
reason
)
;
try_ready
!
(
self
.
codec
.
flush
(
)
)
;
self
.
state
=
State
:
:
Closed
(
reason
)
;
}
State
:
:
Closed
(
reason
)
=
>
return
self
.
take_error
(
reason
)
}
}
}
fn
poll2
(
&
mut
self
)
-
>
Poll
<
(
)
RecvError
>
{
use
frame
:
:
Frame
:
:
*
;
self
.
clear_expired_reset_streams
(
)
;
loop
{
if
let
Some
(
reason
)
=
try_ready
!
(
self
.
poll_go_away
(
)
)
{
if
self
.
go_away
.
should_close_now
(
)
{
return
Err
(
RecvError
:
:
Connection
(
reason
)
)
;
}
debug_assert_eq
!
(
reason
Reason
:
:
NO_ERROR
"
graceful
GOAWAY
should
be
NO_ERROR
"
)
;
}
try_ready
!
(
self
.
poll_ready
(
)
)
;
match
try_ready
!
(
self
.
codec
.
poll
(
)
)
{
Some
(
Headers
(
frame
)
)
=
>
{
trace
!
(
"
recv
HEADERS
;
frame
=
{
:
?
}
"
frame
)
;
self
.
streams
.
recv_headers
(
frame
)
?
;
}
Some
(
Data
(
frame
)
)
=
>
{
trace
!
(
"
recv
DATA
;
frame
=
{
:
?
}
"
frame
)
;
self
.
streams
.
recv_data
(
frame
)
?
;
}
Some
(
Reset
(
frame
)
)
=
>
{
trace
!
(
"
recv
RST_STREAM
;
frame
=
{
:
?
}
"
frame
)
;
self
.
streams
.
recv_reset
(
frame
)
?
;
}
Some
(
PushPromise
(
frame
)
)
=
>
{
trace
!
(
"
recv
PUSH_PROMISE
;
frame
=
{
:
?
}
"
frame
)
;
self
.
streams
.
recv_push_promise
(
frame
)
?
;
}
Some
(
Settings
(
frame
)
)
=
>
{
trace
!
(
"
recv
SETTINGS
;
frame
=
{
:
?
}
"
frame
)
;
self
.
settings
.
recv_settings
(
frame
)
;
}
Some
(
GoAway
(
frame
)
)
=
>
{
trace
!
(
"
recv
GOAWAY
;
frame
=
{
:
?
}
"
frame
)
;
self
.
streams
.
recv_go_away
(
&
frame
)
?
;
self
.
error
=
Some
(
frame
.
reason
(
)
)
;
}
Some
(
Ping
(
frame
)
)
=
>
{
trace
!
(
"
recv
PING
;
frame
=
{
:
?
}
"
frame
)
;
let
status
=
self
.
ping_pong
.
recv_ping
(
frame
)
;
if
status
.
is_shutdown
(
)
{
assert
!
(
self
.
go_away
.
is_going_away
(
)
"
received
unexpected
shutdown
ping
"
)
;
let
last_processed_id
=
self
.
streams
.
last_processed_id
(
)
;
self
.
go_away
(
last_processed_id
Reason
:
:
NO_ERROR
)
;
}
}
Some
(
WindowUpdate
(
frame
)
)
=
>
{
trace
!
(
"
recv
WINDOW_UPDATE
;
frame
=
{
:
?
}
"
frame
)
;
self
.
streams
.
recv_window_update
(
frame
)
?
;
}
Some
(
Priority
(
frame
)
)
=
>
{
trace
!
(
"
recv
PRIORITY
;
frame
=
{
:
?
}
"
frame
)
;
}
None
=
>
{
trace
!
(
"
codec
closed
"
)
;
self
.
streams
.
recv_eof
(
false
)
.
ok
(
)
.
expect
(
"
mutex
poisoned
"
)
;
return
Ok
(
Async
:
:
Ready
(
(
)
)
)
;
}
}
}
}
fn
clear_expired_reset_streams
(
&
mut
self
)
{
self
.
streams
.
clear_expired_reset_streams
(
)
;
}
}
impl
<
T
B
>
Connection
<
T
client
:
:
Peer
B
>
where
T
:
AsyncRead
+
AsyncWrite
B
:
IntoBuf
{
pub
(
crate
)
fn
streams
(
&
self
)
-
>
&
Streams
<
B
:
:
Buf
client
:
:
Peer
>
{
&
self
.
streams
}
}
impl
<
T
B
>
Connection
<
T
server
:
:
Peer
B
>
where
T
:
AsyncRead
+
AsyncWrite
B
:
IntoBuf
{
pub
fn
next_incoming
(
&
mut
self
)
-
>
Option
<
StreamRef
<
B
:
:
Buf
>
>
{
self
.
streams
.
next_incoming
(
)
}
pub
fn
go_away_gracefully
(
&
mut
self
)
{
if
self
.
go_away
.
is_going_away
(
)
{
return
;
}
self
.
go_away
(
StreamId
:
:
MAX
Reason
:
:
NO_ERROR
)
;
self
.
ping_pong
.
ping_shutdown
(
)
;
}
}
impl
<
T
P
B
>
Drop
for
Connection
<
T
P
B
>
where
P
:
Peer
B
:
IntoBuf
{
fn
drop
(
&
mut
self
)
{
let
_
=
self
.
streams
.
recv_eof
(
true
)
;
}
}
