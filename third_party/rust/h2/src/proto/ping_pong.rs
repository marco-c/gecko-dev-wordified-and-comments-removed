use
codec
:
:
Codec
;
use
frame
:
:
Ping
;
use
proto
:
:
PingPayload
;
use
bytes
:
:
Buf
;
use
futures
:
:
{
Async
Poll
}
;
use
std
:
:
io
;
use
tokio_io
:
:
AsyncWrite
;
#
[
derive
(
Debug
)
]
pub
struct
PingPong
{
pending_ping
:
Option
<
PendingPing
>
pending_pong
:
Option
<
PingPayload
>
}
#
[
derive
(
Debug
)
]
struct
PendingPing
{
payload
:
PingPayload
sent
:
bool
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
enum
ReceivedPing
{
MustAck
Unknown
Shutdown
}
impl
PingPong
{
pub
fn
new
(
)
-
>
Self
{
PingPong
{
pending_ping
:
None
pending_pong
:
None
}
}
pub
fn
ping_shutdown
(
&
mut
self
)
{
assert
!
(
self
.
pending_ping
.
is_none
(
)
)
;
self
.
pending_ping
=
Some
(
PendingPing
{
payload
:
Ping
:
:
SHUTDOWN
sent
:
false
}
)
;
}
pub
(
crate
)
fn
recv_ping
(
&
mut
self
ping
:
Ping
)
-
>
ReceivedPing
{
assert
!
(
self
.
pending_pong
.
is_none
(
)
)
;
if
ping
.
is_ack
(
)
{
if
let
Some
(
pending
)
=
self
.
pending_ping
.
take
(
)
{
if
&
pending
.
payload
=
=
ping
.
payload
(
)
{
trace
!
(
"
recv
PING
ack
"
)
;
return
ReceivedPing
:
:
Shutdown
;
}
self
.
pending_ping
=
Some
(
pending
)
;
}
warn
!
(
"
recv
PING
ack
that
we
never
sent
:
{
:
?
}
"
ping
)
;
ReceivedPing
:
:
Unknown
}
else
{
self
.
pending_pong
=
Some
(
ping
.
into_payload
(
)
)
;
ReceivedPing
:
:
MustAck
}
}
pub
fn
send_pending_pong
<
T
B
>
(
&
mut
self
dst
:
&
mut
Codec
<
T
B
>
)
-
>
Poll
<
(
)
io
:
:
Error
>
where
T
:
AsyncWrite
B
:
Buf
{
if
let
Some
(
pong
)
=
self
.
pending_pong
.
take
(
)
{
if
!
dst
.
poll_ready
(
)
?
.
is_ready
(
)
{
self
.
pending_pong
=
Some
(
pong
)
;
return
Ok
(
Async
:
:
NotReady
)
;
}
dst
.
buffer
(
Ping
:
:
pong
(
pong
)
.
into
(
)
)
.
expect
(
"
invalid
pong
frame
"
)
;
}
Ok
(
Async
:
:
Ready
(
(
)
)
)
}
pub
fn
send_pending_ping
<
T
B
>
(
&
mut
self
dst
:
&
mut
Codec
<
T
B
>
)
-
>
Poll
<
(
)
io
:
:
Error
>
where
T
:
AsyncWrite
B
:
Buf
{
if
let
Some
(
ref
mut
ping
)
=
self
.
pending_ping
{
if
!
ping
.
sent
{
if
!
dst
.
poll_ready
(
)
?
.
is_ready
(
)
{
return
Ok
(
Async
:
:
NotReady
)
;
}
dst
.
buffer
(
Ping
:
:
new
(
ping
.
payload
)
.
into
(
)
)
.
expect
(
"
invalid
ping
frame
"
)
;
ping
.
sent
=
true
;
}
}
Ok
(
Async
:
:
Ready
(
(
)
)
)
}
}
impl
ReceivedPing
{
pub
fn
is_shutdown
(
&
self
)
-
>
bool
{
match
*
self
{
ReceivedPing
:
:
Shutdown
=
>
true
_
=
>
false
}
}
}
