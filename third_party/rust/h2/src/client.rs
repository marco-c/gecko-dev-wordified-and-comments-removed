use
{
SendStream
RecvStream
ReleaseCapacity
}
;
use
codec
:
:
{
Codec
RecvError
SendError
UserError
}
;
use
frame
:
:
{
Headers
Pseudo
Reason
Settings
StreamId
}
;
use
proto
;
use
bytes
:
:
{
Bytes
IntoBuf
}
;
use
futures
:
:
{
Async
Future
Poll
}
;
use
http
:
:
{
uri
Request
Response
Method
Version
}
;
use
tokio_io
:
:
{
AsyncRead
AsyncWrite
}
;
use
tokio_io
:
:
io
:
:
WriteAll
;
use
std
:
:
fmt
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
time
:
:
Duration
;
use
std
:
:
usize
;
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
pub
struct
Handshake
<
T
B
:
IntoBuf
=
Bytes
>
{
builder
:
Builder
inner
:
WriteAll
<
T
&
'
static
[
u8
]
>
_marker
:
PhantomData
<
B
>
}
pub
struct
SendRequest
<
B
:
IntoBuf
>
{
inner
:
proto
:
:
Streams
<
B
:
:
Buf
Peer
>
pending
:
Option
<
proto
:
:
OpaqueStreamRef
>
}
#
[
derive
(
Debug
)
]
pub
struct
ReadySendRequest
<
B
:
IntoBuf
>
{
inner
:
Option
<
SendRequest
<
B
>
>
}
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
pub
struct
Connection
<
T
B
:
IntoBuf
=
Bytes
>
{
inner
:
proto
:
:
Connection
<
T
Peer
B
>
}
#
[
derive
(
Debug
)
]
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
pub
struct
ResponseFuture
{
inner
:
proto
:
:
OpaqueStreamRef
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Builder
{
reset_stream_duration
:
Duration
initial_max_send_streams
:
usize
initial_target_connection_window_size
:
Option
<
u32
>
reset_stream_max
:
usize
settings
:
Settings
stream_id
:
StreamId
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Peer
;
impl
<
B
>
SendRequest
<
B
>
where
B
:
IntoBuf
B
:
:
Buf
:
'
static
{
pub
fn
poll_ready
(
&
mut
self
)
-
>
Poll
<
(
)
:
:
Error
>
{
try_ready
!
(
self
.
inner
.
poll_pending_open
(
self
.
pending
.
as_ref
(
)
)
)
;
self
.
pending
=
None
;
Ok
(
(
)
.
into
(
)
)
}
pub
fn
ready
(
self
)
-
>
ReadySendRequest
<
B
>
{
ReadySendRequest
{
inner
:
Some
(
self
)
}
}
pub
fn
send_request
(
&
mut
self
request
:
Request
<
(
)
>
end_of_stream
:
bool
)
-
>
Result
<
(
ResponseFuture
SendStream
<
B
>
)
:
:
Error
>
{
self
.
inner
.
send_request
(
request
end_of_stream
self
.
pending
.
as_ref
(
)
)
.
map_err
(
Into
:
:
into
)
.
map
(
|
stream
|
{
if
stream
.
is_pending_open
(
)
{
self
.
pending
=
Some
(
stream
.
clone_to_opaque
(
)
)
;
}
let
response
=
ResponseFuture
{
inner
:
stream
.
clone_to_opaque
(
)
}
;
let
stream
=
SendStream
:
:
new
(
stream
)
;
(
response
stream
)
}
)
}
}
impl
<
B
>
fmt
:
:
Debug
for
SendRequest
<
B
>
where
B
:
IntoBuf
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
SendRequest
"
)
.
finish
(
)
}
}
impl
<
B
>
Clone
for
SendRequest
<
B
>
where
B
:
IntoBuf
{
fn
clone
(
&
self
)
-
>
Self
{
SendRequest
{
inner
:
self
.
inner
.
clone
(
)
pending
:
None
}
}
}
#
[
cfg
(
feature
=
"
unstable
"
)
]
impl
<
B
>
SendRequest
<
B
>
where
B
:
IntoBuf
{
pub
fn
num_active_streams
(
&
self
)
-
>
usize
{
self
.
inner
.
num_active_streams
(
)
}
pub
fn
num_wired_streams
(
&
self
)
-
>
usize
{
self
.
inner
.
num_wired_streams
(
)
}
}
impl
<
B
>
Future
for
ReadySendRequest
<
B
>
where
B
:
IntoBuf
B
:
:
Buf
:
'
static
{
type
Item
=
SendRequest
<
B
>
;
type
Error
=
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
Self
:
:
Error
>
{
match
self
.
inner
{
Some
(
ref
mut
send_request
)
=
>
{
let
_
=
try_ready
!
(
send_request
.
poll_ready
(
)
)
;
}
None
=
>
panic
!
(
"
called
poll
after
future
completed
"
)
}
Ok
(
self
.
inner
.
take
(
)
.
unwrap
(
)
.
into
(
)
)
}
}
impl
Builder
{
pub
fn
new
(
)
-
>
Builder
{
Builder
{
reset_stream_duration
:
Duration
:
:
from_secs
(
proto
:
:
DEFAULT_RESET_STREAM_SECS
)
reset_stream_max
:
proto
:
:
DEFAULT_RESET_STREAM_MAX
initial_target_connection_window_size
:
None
initial_max_send_streams
:
usize
:
:
MAX
settings
:
Default
:
:
default
(
)
stream_id
:
1
.
into
(
)
}
}
pub
fn
initial_window_size
(
&
mut
self
size
:
u32
)
-
>
&
mut
Self
{
self
.
settings
.
set_initial_window_size
(
Some
(
size
)
)
;
self
}
pub
fn
initial_connection_window_size
(
&
mut
self
size
:
u32
)
-
>
&
mut
Self
{
self
.
initial_target_connection_window_size
=
Some
(
size
)
;
self
}
pub
fn
max_frame_size
(
&
mut
self
max
:
u32
)
-
>
&
mut
Self
{
self
.
settings
.
set_max_frame_size
(
Some
(
max
)
)
;
self
}
pub
fn
max_header_list_size
(
&
mut
self
max
:
u32
)
-
>
&
mut
Self
{
self
.
settings
.
set_max_header_list_size
(
Some
(
max
)
)
;
self
}
pub
fn
max_concurrent_streams
(
&
mut
self
max
:
u32
)
-
>
&
mut
Self
{
self
.
settings
.
set_max_concurrent_streams
(
Some
(
max
)
)
;
self
}
pub
fn
initial_max_send_streams
(
&
mut
self
initial
:
usize
)
-
>
&
mut
Self
{
self
.
initial_max_send_streams
=
initial
;
self
}
pub
fn
max_concurrent_reset_streams
(
&
mut
self
max
:
usize
)
-
>
&
mut
Self
{
self
.
reset_stream_max
=
max
;
self
}
pub
fn
reset_stream_duration
(
&
mut
self
dur
:
Duration
)
-
>
&
mut
Self
{
self
.
reset_stream_duration
=
dur
;
self
}
pub
fn
enable_push
(
&
mut
self
enabled
:
bool
)
-
>
&
mut
Self
{
self
.
settings
.
set_enable_push
(
enabled
)
;
self
}
#
[
cfg
(
feature
=
"
unstable
"
)
]
pub
fn
initial_stream_id
(
&
mut
self
stream_id
:
u32
)
-
>
&
mut
Self
{
self
.
stream_id
=
stream_id
.
into
(
)
;
assert
!
(
self
.
stream_id
.
is_client_initiated
(
)
"
stream
id
must
be
odd
"
)
;
self
}
pub
fn
handshake
<
T
B
>
(
&
self
io
:
T
)
-
>
Handshake
<
T
B
>
where
T
:
AsyncRead
+
AsyncWrite
B
:
IntoBuf
B
:
:
Buf
:
'
static
{
Connection
:
:
handshake2
(
io
self
.
clone
(
)
)
}
}
impl
Default
for
Builder
{
fn
default
(
)
-
>
Builder
{
Builder
:
:
new
(
)
}
}
pub
fn
handshake
<
T
>
(
io
:
T
)
-
>
Handshake
<
T
Bytes
>
where
T
:
AsyncRead
+
AsyncWrite
{
Builder
:
:
new
(
)
.
handshake
(
io
)
}
impl
<
T
B
>
Connection
<
T
B
>
where
T
:
AsyncRead
+
AsyncWrite
B
:
IntoBuf
{
fn
handshake2
(
io
:
T
builder
:
Builder
)
-
>
Handshake
<
T
B
>
{
use
tokio_io
:
:
io
;
debug
!
(
"
binding
client
connection
"
)
;
let
msg
:
&
'
static
[
u8
]
=
b
"
PRI
*
HTTP
/
2
.
0
\
r
\
n
\
r
\
nSM
\
r
\
n
\
r
\
n
"
;
let
handshake
=
io
:
:
write_all
(
io
msg
)
;
Handshake
{
builder
inner
:
handshake
_marker
:
PhantomData
}
}
pub
fn
set_target_window_size
(
&
mut
self
size
:
u32
)
{
assert
!
(
size
<
=
proto
:
:
MAX_WINDOW_SIZE
)
;
self
.
inner
.
set_target_window_size
(
size
)
;
}
}
impl
<
T
B
>
Future
for
Connection
<
T
B
>
where
T
:
AsyncRead
+
AsyncWrite
B
:
IntoBuf
{
type
Item
=
(
)
;
type
Error
=
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
(
)
:
:
Error
>
{
self
.
inner
.
maybe_close_connection_if_no_streams
(
)
;
self
.
inner
.
poll
(
)
.
map_err
(
Into
:
:
into
)
}
}
impl
<
T
B
>
fmt
:
:
Debug
for
Connection
<
T
B
>
where
T
:
AsyncRead
+
AsyncWrite
T
:
fmt
:
:
Debug
B
:
fmt
:
:
Debug
+
IntoBuf
B
:
:
Buf
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
self
.
inner
fmt
)
}
}
impl
<
T
B
>
Future
for
Handshake
<
T
B
>
where
T
:
AsyncRead
+
AsyncWrite
B
:
IntoBuf
B
:
:
Buf
:
'
static
{
type
Item
=
(
SendRequest
<
B
>
Connection
<
T
B
>
)
;
type
Error
=
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
Self
:
:
Error
>
{
let
res
=
self
.
inner
.
poll
(
)
.
map_err
(
:
:
Error
:
:
from
)
;
let
(
io
_
)
=
try_ready
!
(
res
)
;
debug
!
(
"
client
connection
bound
"
)
;
let
mut
codec
=
Codec
:
:
new
(
io
)
;
if
let
Some
(
max
)
=
self
.
builder
.
settings
.
max_frame_size
(
)
{
codec
.
set_max_recv_frame_size
(
max
as
usize
)
;
}
if
let
Some
(
max
)
=
self
.
builder
.
settings
.
max_header_list_size
(
)
{
codec
.
set_max_recv_header_list_size
(
max
as
usize
)
;
}
codec
.
buffer
(
self
.
builder
.
settings
.
clone
(
)
.
into
(
)
)
.
expect
(
"
invalid
SETTINGS
frame
"
)
;
let
inner
=
proto
:
:
Connection
:
:
new
(
codec
proto
:
:
Config
{
next_stream_id
:
self
.
builder
.
stream_id
initial_max_send_streams
:
self
.
builder
.
initial_max_send_streams
reset_stream_duration
:
self
.
builder
.
reset_stream_duration
reset_stream_max
:
self
.
builder
.
reset_stream_max
settings
:
self
.
builder
.
settings
.
clone
(
)
}
)
;
let
send_request
=
SendRequest
{
inner
:
inner
.
streams
(
)
.
clone
(
)
pending
:
None
}
;
let
mut
connection
=
Connection
{
inner
}
;
if
let
Some
(
sz
)
=
self
.
builder
.
initial_target_connection_window_size
{
connection
.
set_target_window_size
(
sz
)
;
}
Ok
(
Async
:
:
Ready
(
(
send_request
connection
)
)
)
}
}
impl
<
T
B
>
fmt
:
:
Debug
for
Handshake
<
T
B
>
where
T
:
AsyncRead
+
AsyncWrite
T
:
fmt
:
:
Debug
B
:
fmt
:
:
Debug
+
IntoBuf
B
:
:
Buf
:
fmt
:
:
Debug
+
IntoBuf
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
client
:
:
Handshake
"
)
}
}
impl
Future
for
ResponseFuture
{
type
Item
=
Response
<
RecvStream
>
;
type
Error
=
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
Self
:
:
Error
>
{
let
(
parts
_
)
=
try_ready
!
(
self
.
inner
.
poll_response
(
)
)
.
into_parts
(
)
;
let
body
=
RecvStream
:
:
new
(
ReleaseCapacity
:
:
new
(
self
.
inner
.
clone
(
)
)
)
;
Ok
(
Response
:
:
from_parts
(
parts
body
)
.
into
(
)
)
}
}
impl
ResponseFuture
{
pub
fn
stream_id
(
&
self
)
-
>
:
:
StreamId
{
:
:
StreamId
:
:
from_internal
(
self
.
inner
.
stream_id
(
)
)
}
}
impl
Peer
{
pub
fn
convert_send_message
(
id
:
StreamId
request
:
Request
<
(
)
>
end_of_stream
:
bool
)
-
>
Result
<
Headers
SendError
>
{
use
http
:
:
request
:
:
Parts
;
let
(
Parts
{
method
uri
headers
version
.
.
}
_
)
=
request
.
into_parts
(
)
;
let
is_connect
=
method
=
=
Method
:
:
CONNECT
;
let
mut
pseudo
=
Pseudo
:
:
request
(
method
uri
)
;
if
pseudo
.
scheme
.
is_none
(
)
{
if
pseudo
.
authority
.
is_none
(
)
{
if
version
=
=
Version
:
:
HTTP_2
{
return
Err
(
UserError
:
:
MissingUriSchemeAndAuthority
.
into
(
)
)
;
}
else
{
pseudo
.
set_scheme
(
uri
:
:
Scheme
:
:
HTTP
)
;
}
}
else
if
!
is_connect
{
}
}
let
mut
frame
=
Headers
:
:
new
(
id
pseudo
headers
)
;
if
end_of_stream
{
frame
.
set_end_stream
(
)
}
Ok
(
frame
)
}
}
impl
proto
:
:
Peer
for
Peer
{
type
Poll
=
Response
<
(
)
>
;
fn
dyn
(
)
-
>
proto
:
:
DynPeer
{
proto
:
:
DynPeer
:
:
Client
}
fn
is_server
(
)
-
>
bool
{
false
}
fn
convert_poll_message
(
headers
:
Headers
)
-
>
Result
<
Self
:
:
Poll
RecvError
>
{
let
mut
b
=
Response
:
:
builder
(
)
;
let
stream_id
=
headers
.
stream_id
(
)
;
let
(
pseudo
fields
)
=
headers
.
into_parts
(
)
;
b
.
version
(
Version
:
:
HTTP_2
)
;
if
let
Some
(
status
)
=
pseudo
.
status
{
b
.
status
(
status
)
;
}
let
mut
response
=
match
b
.
body
(
(
)
)
{
Ok
(
response
)
=
>
response
Err
(
_
)
=
>
{
return
Err
(
RecvError
:
:
Stream
{
id
:
stream_id
reason
:
Reason
:
:
PROTOCOL_ERROR
}
)
;
}
}
;
*
response
.
headers_mut
(
)
=
fields
;
Ok
(
response
)
}
}
