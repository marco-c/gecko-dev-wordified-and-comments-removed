use
codec
:
:
UserError
;
use
frame
:
:
Reason
;
use
proto
:
:
{
self
WindowSize
}
;
use
bytes
:
:
{
Bytes
IntoBuf
}
;
use
futures
:
:
{
self
Poll
Async
}
;
use
http
:
:
{
HeaderMap
}
;
use
std
:
:
fmt
;
#
[
derive
(
Debug
)
]
pub
struct
SendStream
<
B
:
IntoBuf
>
{
inner
:
proto
:
:
StreamRef
<
B
:
:
Buf
>
}
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
)
]
pub
struct
StreamId
(
u32
)
;
#
[
must_use
=
"
streams
do
nothing
unless
polled
"
]
pub
struct
RecvStream
{
inner
:
ReleaseCapacity
}
#
[
derive
(
Debug
)
]
pub
struct
ReleaseCapacity
{
inner
:
proto
:
:
OpaqueStreamRef
}
impl
<
B
:
IntoBuf
>
SendStream
<
B
>
{
pub
(
crate
)
fn
new
(
inner
:
proto
:
:
StreamRef
<
B
:
:
Buf
>
)
-
>
Self
{
SendStream
{
inner
}
}
pub
fn
reserve_capacity
(
&
mut
self
capacity
:
usize
)
{
self
.
inner
.
reserve_capacity
(
capacity
as
WindowSize
)
}
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
inner
.
capacity
(
)
as
usize
}
pub
fn
poll_capacity
(
&
mut
self
)
-
>
Poll
<
Option
<
usize
>
:
:
Error
>
{
let
res
=
try_ready
!
(
self
.
inner
.
poll_capacity
(
)
)
;
Ok
(
Async
:
:
Ready
(
res
.
map
(
|
v
|
v
as
usize
)
)
)
}
pub
fn
send_data
(
&
mut
self
data
:
B
end_of_stream
:
bool
)
-
>
Result
<
(
)
:
:
Error
>
{
self
.
inner
.
send_data
(
data
.
into_buf
(
)
end_of_stream
)
.
map_err
(
Into
:
:
into
)
}
pub
fn
send_trailers
(
&
mut
self
trailers
:
HeaderMap
)
-
>
Result
<
(
)
:
:
Error
>
{
self
.
inner
.
send_trailers
(
trailers
)
.
map_err
(
Into
:
:
into
)
}
pub
fn
send_reset
(
&
mut
self
reason
:
Reason
)
{
self
.
inner
.
send_reset
(
reason
)
}
pub
fn
poll_reset
(
&
mut
self
)
-
>
Poll
<
Reason
:
:
Error
>
{
self
.
inner
.
poll_reset
(
proto
:
:
PollReset
:
:
Streaming
)
}
pub
fn
stream_id
(
&
self
)
-
>
StreamId
{
StreamId
:
:
from_internal
(
self
.
inner
.
stream_id
(
)
)
}
}
impl
StreamId
{
pub
(
crate
)
fn
from_internal
(
id
:
:
:
frame
:
:
StreamId
)
-
>
Self
{
StreamId
(
id
.
into
(
)
)
}
}
impl
RecvStream
{
pub
(
crate
)
fn
new
(
inner
:
ReleaseCapacity
)
-
>
Self
{
RecvStream
{
inner
}
}
#
[
deprecated
(
since
=
"
0
.
0
.
0
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
inner
.
inner
.
body_is_empty
(
)
}
pub
fn
is_end_stream
(
&
self
)
-
>
bool
{
self
.
inner
.
inner
.
is_end_stream
(
)
}
pub
fn
release_capacity
(
&
mut
self
)
-
>
&
mut
ReleaseCapacity
{
&
mut
self
.
inner
}
pub
fn
poll_trailers
(
&
mut
self
)
-
>
Poll
<
Option
<
HeaderMap
>
:
:
Error
>
{
self
.
inner
.
inner
.
poll_trailers
(
)
.
map_err
(
Into
:
:
into
)
}
pub
fn
stream_id
(
&
self
)
-
>
StreamId
{
self
.
inner
.
stream_id
(
)
}
}
impl
futures
:
:
Stream
for
RecvStream
{
type
Item
=
Bytes
;
type
Error
=
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
{
self
.
inner
.
inner
.
poll_data
(
)
.
map_err
(
Into
:
:
into
)
}
}
impl
fmt
:
:
Debug
for
RecvStream
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
RecvStream
"
)
.
field
(
"
inner
"
&
self
.
inner
)
.
finish
(
)
}
}
impl
ReleaseCapacity
{
pub
(
crate
)
fn
new
(
inner
:
proto
:
:
OpaqueStreamRef
)
-
>
Self
{
ReleaseCapacity
{
inner
}
}
pub
fn
stream_id
(
&
self
)
-
>
StreamId
{
StreamId
:
:
from_internal
(
self
.
inner
.
stream_id
(
)
)
}
pub
fn
release_capacity
(
&
mut
self
sz
:
usize
)
-
>
Result
<
(
)
:
:
Error
>
{
if
sz
>
proto
:
:
MAX_WINDOW_SIZE
as
usize
{
return
Err
(
UserError
:
:
ReleaseCapacityTooBig
.
into
(
)
)
;
}
self
.
inner
.
release_capacity
(
sz
as
proto
:
:
WindowSize
)
.
map_err
(
Into
:
:
into
)
}
}
impl
Clone
for
ReleaseCapacity
{
fn
clone
(
&
self
)
-
>
Self
{
let
inner
=
self
.
inner
.
clone
(
)
;
ReleaseCapacity
{
inner
}
}
}
