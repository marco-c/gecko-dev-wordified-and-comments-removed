use
crate
:
:
Variable
;
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
mem
;
use
core
:
:
u32
;
use
cranelift_codegen
:
:
cursor
:
:
{
Cursor
FuncCursor
}
;
use
cranelift_codegen
:
:
entity
:
:
{
EntityRef
PrimaryMap
SecondaryMap
}
;
use
cranelift_codegen
:
:
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
use
cranelift_codegen
:
:
ir
:
:
instructions
:
:
BranchInfo
;
use
cranelift_codegen
:
:
ir
:
:
types
:
:
{
F32
F64
}
;
use
cranelift_codegen
:
:
ir
:
:
{
Block
Function
Inst
InstBuilder
InstructionData
Type
Value
}
;
use
cranelift_codegen
:
:
packed_option
:
:
PackedOption
;
use
cranelift_codegen
:
:
packed_option
:
:
ReservedValue
;
use
smallvec
:
:
SmallVec
;
pub
struct
SSABuilder
{
variables
:
SecondaryMap
<
Variable
SecondaryMap
<
SSABlock
PackedOption
<
Value
>
>
>
ssa_blocks
:
PrimaryMap
<
SSABlock
SSABlockData
>
block_headers
:
SecondaryMap
<
Block
PackedOption
<
SSABlock
>
>
calls
:
Vec
<
Call
>
results
:
Vec
<
Value
>
side_effects
:
SideEffects
}
pub
struct
SideEffects
{
pub
split_blocks_created
:
Vec
<
Block
>
pub
instructions_added_to_blocks
:
Vec
<
Block
>
}
impl
SideEffects
{
fn
new
(
)
-
>
Self
{
Self
{
split_blocks_created
:
Vec
:
:
new
(
)
instructions_added_to_blocks
:
Vec
:
:
new
(
)
}
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
split_blocks_created
.
is_empty
(
)
&
&
self
.
instructions_added_to_blocks
.
is_empty
(
)
}
}
enum
SSABlockData
{
BlockHeader
(
BlockHeaderSSABlockData
)
BlockBody
{
ssa_pred
:
SSABlock
}
}
impl
SSABlockData
{
fn
add_predecessor
(
&
mut
self
ssa_pred
:
SSABlock
inst
:
Inst
)
{
match
*
self
{
Self
:
:
BlockBody
{
.
.
}
=
>
panic
!
(
"
you
can
'
t
add
a
predecessor
to
a
body
block
"
)
Self
:
:
BlockHeader
(
ref
mut
data
)
=
>
{
debug_assert
!
(
!
data
.
sealed
"
sealed
blocks
cannot
accept
new
predecessors
"
)
;
data
.
predecessors
.
push
(
PredBlock
:
:
new
(
ssa_pred
inst
)
)
;
}
}
}
fn
remove_predecessor
(
&
mut
self
inst
:
Inst
)
-
>
SSABlock
{
match
*
self
{
Self
:
:
BlockBody
{
.
.
}
=
>
panic
!
(
"
should
not
happen
"
)
Self
:
:
BlockHeader
(
ref
mut
data
)
=
>
{
let
pred
:
usize
=
data
.
predecessors
.
iter
(
)
.
position
(
|
&
PredBlock
{
branch
.
.
}
|
branch
=
=
inst
)
.
expect
(
"
the
predecessor
you
are
trying
to
remove
is
not
declared
"
)
;
data
.
predecessors
.
swap_remove
(
pred
)
.
ssa_block
}
}
}
}
struct
PredBlock
{
ssa_block
:
SSABlock
branch
:
Inst
}
impl
PredBlock
{
fn
new
(
ssa_block
:
SSABlock
branch
:
Inst
)
-
>
Self
{
Self
{
ssa_block
branch
}
}
}
type
PredBlockSmallVec
=
SmallVec
<
[
PredBlock
;
4
]
>
;
struct
BlockHeaderSSABlockData
{
predecessors
:
PredBlockSmallVec
sealed
:
bool
block
:
Block
undef_variables
:
Vec
<
(
Variable
Value
)
>
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
struct
SSABlock
(
u32
)
;
impl
EntityRef
for
SSABlock
{
fn
new
(
index
:
usize
)
-
>
Self
{
debug_assert
!
(
index
<
(
u32
:
:
MAX
as
usize
)
)
;
Self
(
index
as
u32
)
}
fn
index
(
self
)
-
>
usize
{
self
.
0
as
usize
}
}
impl
ReservedValue
for
SSABlock
{
fn
reserved_value
(
)
-
>
Self
{
Self
(
u32
:
:
MAX
)
}
}
impl
SSABuilder
{
pub
fn
new
(
)
-
>
Self
{
Self
{
variables
:
SecondaryMap
:
:
with_default
(
SecondaryMap
:
:
new
(
)
)
ssa_blocks
:
PrimaryMap
:
:
new
(
)
block_headers
:
SecondaryMap
:
:
new
(
)
calls
:
Vec
:
:
new
(
)
results
:
Vec
:
:
new
(
)
side_effects
:
SideEffects
:
:
new
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
variables
.
clear
(
)
;
self
.
ssa_blocks
.
clear
(
)
;
self
.
block_headers
.
clear
(
)
;
debug_assert
!
(
self
.
calls
.
is_empty
(
)
)
;
debug_assert
!
(
self
.
results
.
is_empty
(
)
)
;
debug_assert
!
(
self
.
side_effects
.
is_empty
(
)
)
;
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
variables
.
is_empty
(
)
&
&
self
.
ssa_blocks
.
is_empty
(
)
&
&
self
.
block_headers
.
is_empty
(
)
&
&
self
.
calls
.
is_empty
(
)
&
&
self
.
results
.
is_empty
(
)
&
&
self
.
side_effects
.
is_empty
(
)
}
}
#
[
derive
(
Debug
)
]
enum
ZeroOneOrMore
<
T
>
{
Zero
One
(
T
)
More
}
#
[
derive
(
Debug
)
]
enum
UseVarCases
{
Unsealed
(
Value
)
SealedOnePredecessor
(
SSABlock
)
SealedMultiplePredecessors
(
Value
Block
)
}
enum
Call
{
UseVar
(
SSABlock
)
FinishSealedOnePredecessor
(
SSABlock
)
FinishPredecessorsLookup
(
Value
Block
)
}
fn
emit_zero
(
ty
:
Type
mut
cur
:
FuncCursor
)
-
>
Value
{
if
ty
.
is_int
(
)
{
cur
.
ins
(
)
.
iconst
(
ty
0
)
}
else
if
ty
.
is_bool
(
)
{
cur
.
ins
(
)
.
bconst
(
ty
false
)
}
else
if
ty
=
=
F32
{
cur
.
ins
(
)
.
f32const
(
Ieee32
:
:
with_bits
(
0
)
)
}
else
if
ty
=
=
F64
{
cur
.
ins
(
)
.
f64const
(
Ieee64
:
:
with_bits
(
0
)
)
}
else
if
ty
.
is_ref
(
)
{
cur
.
ins
(
)
.
null
(
ty
)
}
else
if
ty
.
is_vector
(
)
{
let
scalar_ty
=
ty
.
lane_type
(
)
;
if
scalar_ty
.
is_int
(
)
{
cur
.
ins
(
)
.
iconst
(
ty
0
)
}
else
if
scalar_ty
.
is_bool
(
)
{
cur
.
ins
(
)
.
bconst
(
ty
false
)
}
else
if
scalar_ty
=
=
F32
{
let
scalar
=
cur
.
ins
(
)
.
f32const
(
Ieee32
:
:
with_bits
(
0
)
)
;
cur
.
ins
(
)
.
splat
(
ty
scalar
)
}
else
if
scalar_ty
=
=
F64
{
let
scalar
=
cur
.
ins
(
)
.
f64const
(
Ieee64
:
:
with_bits
(
0
)
)
;
cur
.
ins
(
)
.
splat
(
ty
scalar
)
}
else
{
panic
!
(
"
unimplemented
scalar
type
:
{
:
?
}
"
ty
)
}
}
else
{
panic
!
(
"
unimplemented
type
:
{
:
?
}
"
ty
)
}
}
impl
SSABuilder
{
pub
fn
def_var
(
&
mut
self
var
:
Variable
val
:
Value
ssa_block
:
SSABlock
)
{
self
.
variables
[
var
]
[
ssa_block
]
=
PackedOption
:
:
from
(
val
)
;
}
pub
fn
use_var
(
&
mut
self
func
:
&
mut
Function
var
:
Variable
ty
:
Type
ssa_block
:
SSABlock
)
-
>
(
Value
SideEffects
)
{
if
let
Some
(
var_defs
)
=
self
.
variables
.
get
(
var
)
{
if
let
Some
(
val
)
=
var_defs
[
ssa_block
]
.
expand
(
)
{
return
(
val
SideEffects
:
:
new
(
)
)
;
}
}
debug_assert
!
(
self
.
calls
.
is_empty
(
)
)
;
debug_assert
!
(
self
.
results
.
is_empty
(
)
)
;
debug_assert
!
(
self
.
side_effects
.
is_empty
(
)
)
;
self
.
use_var_nonlocal
(
func
var
ty
ssa_block
)
;
let
value
=
self
.
run_state_machine
(
func
var
ty
)
;
let
side_effects
=
mem
:
:
replace
(
&
mut
self
.
side_effects
SideEffects
:
:
new
(
)
)
;
(
value
side_effects
)
}
fn
use_var_nonlocal
(
&
mut
self
func
:
&
mut
Function
var
:
Variable
ty
:
Type
ssa_block
:
SSABlock
)
{
let
case
=
match
self
.
ssa_blocks
[
ssa_block
]
{
SSABlockData
:
:
BlockHeader
(
ref
mut
data
)
=
>
{
if
data
.
sealed
{
if
data
.
predecessors
.
len
(
)
=
=
1
{
UseVarCases
:
:
SealedOnePredecessor
(
data
.
predecessors
[
0
]
.
ssa_block
)
}
else
{
let
val
=
func
.
dfg
.
append_block_param
(
data
.
block
ty
)
;
UseVarCases
:
:
SealedMultiplePredecessors
(
val
data
.
block
)
}
}
else
{
let
val
=
func
.
dfg
.
append_block_param
(
data
.
block
ty
)
;
data
.
undef_variables
.
push
(
(
var
val
)
)
;
UseVarCases
:
:
Unsealed
(
val
)
}
}
SSABlockData
:
:
BlockBody
{
ssa_pred
}
=
>
UseVarCases
:
:
SealedOnePredecessor
(
ssa_pred
)
}
;
match
case
{
UseVarCases
:
:
SealedOnePredecessor
(
pred
)
=
>
{
self
.
calls
.
push
(
Call
:
:
FinishSealedOnePredecessor
(
ssa_block
)
)
;
self
.
calls
.
push
(
Call
:
:
UseVar
(
pred
)
)
;
}
UseVarCases
:
:
Unsealed
(
val
)
=
>
{
self
.
def_var
(
var
val
ssa_block
)
;
self
.
results
.
push
(
val
)
;
}
UseVarCases
:
:
SealedMultiplePredecessors
(
val
block
)
=
>
{
self
.
def_var
(
var
val
ssa_block
)
;
self
.
begin_predecessors_lookup
(
val
block
)
;
}
}
}
fn
finish_sealed_one_predecessor
(
&
mut
self
var
:
Variable
ssa_block
:
SSABlock
)
{
let
val
=
*
self
.
results
.
last
(
)
.
unwrap
(
)
;
self
.
def_var
(
var
val
ssa_block
)
;
}
pub
fn
declare_block_body_block
(
&
mut
self
ssa_pred
:
SSABlock
)
-
>
SSABlock
{
self
.
ssa_blocks
.
push
(
SSABlockData
:
:
BlockBody
{
ssa_pred
}
)
}
pub
fn
declare_block_header_block
(
&
mut
self
block
:
Block
)
-
>
SSABlock
{
let
ssa_block
=
self
.
ssa_blocks
.
push
(
SSABlockData
:
:
BlockHeader
(
BlockHeaderSSABlockData
{
predecessors
:
PredBlockSmallVec
:
:
new
(
)
sealed
:
false
block
undef_variables
:
Vec
:
:
new
(
)
}
)
)
;
self
.
block_headers
[
block
]
=
ssa_block
.
into
(
)
;
ssa_block
}
pub
fn
header_block
(
&
self
block
:
Block
)
-
>
SSABlock
{
self
.
block_headers
.
get
(
block
)
.
expect
(
"
the
block
has
not
been
declared
"
)
.
expand
(
)
.
expect
(
"
the
header
block
has
not
been
defined
"
)
}
pub
fn
declare_block_predecessor
(
&
mut
self
block
:
Block
ssa_pred
:
SSABlock
inst
:
Inst
)
{
debug_assert
!
(
!
self
.
is_sealed
(
block
)
)
;
let
header_block
=
self
.
header_block
(
block
)
;
self
.
ssa_blocks
[
header_block
]
.
add_predecessor
(
ssa_pred
inst
)
}
pub
fn
remove_block_predecessor
(
&
mut
self
block
:
Block
inst
:
Inst
)
-
>
SSABlock
{
debug_assert
!
(
!
self
.
is_sealed
(
block
)
)
;
let
header_block
=
self
.
header_block
(
block
)
;
self
.
ssa_blocks
[
header_block
]
.
remove_predecessor
(
inst
)
}
pub
fn
seal_block_header_block
(
&
mut
self
block
:
Block
func
:
&
mut
Function
)
-
>
SideEffects
{
self
.
seal_one_block_header_block
(
block
func
)
;
mem
:
:
replace
(
&
mut
self
.
side_effects
SideEffects
:
:
new
(
)
)
}
pub
fn
seal_all_block_header_blocks
(
&
mut
self
func
:
&
mut
Function
)
-
>
SideEffects
{
for
block
in
self
.
block_headers
.
keys
(
)
{
self
.
seal_one_block_header_block
(
block
func
)
;
}
mem
:
:
replace
(
&
mut
self
.
side_effects
SideEffects
:
:
new
(
)
)
}
fn
seal_one_block_header_block
(
&
mut
self
block
:
Block
func
:
&
mut
Function
)
{
let
ssa_block
=
self
.
header_block
(
block
)
;
let
undef_vars
=
match
self
.
ssa_blocks
[
ssa_block
]
{
SSABlockData
:
:
BlockBody
{
.
.
}
=
>
panic
!
(
"
this
should
not
happen
"
)
SSABlockData
:
:
BlockHeader
(
ref
mut
data
)
=
>
{
debug_assert
!
(
!
data
.
sealed
"
Attempting
to
seal
{
}
which
is
already
sealed
.
"
block
)
;
debug_assert_eq
!
(
block
data
.
block
)
;
mem
:
:
replace
(
&
mut
data
.
undef_variables
Vec
:
:
new
(
)
)
}
}
;
for
(
var
val
)
in
undef_vars
{
let
ty
=
func
.
dfg
.
value_type
(
val
)
;
self
.
predecessors_lookup
(
func
val
var
ty
block
)
;
}
self
.
mark_block_header_block_sealed
(
ssa_block
)
;
}
fn
mark_block_header_block_sealed
(
&
mut
self
ssa_block
:
SSABlock
)
{
match
self
.
ssa_blocks
[
ssa_block
]
{
SSABlockData
:
:
BlockBody
{
.
.
}
=
>
panic
!
(
"
this
should
not
happen
"
)
SSABlockData
:
:
BlockHeader
(
ref
mut
data
)
=
>
{
debug_assert
!
(
!
data
.
sealed
)
;
debug_assert
!
(
data
.
undef_variables
.
is_empty
(
)
)
;
data
.
sealed
=
true
;
}
}
}
fn
predecessors_lookup
(
&
mut
self
func
:
&
mut
Function
sentinel
:
Value
var
:
Variable
ty
:
Type
block
:
Block
)
-
>
Value
{
debug_assert
!
(
self
.
calls
.
is_empty
(
)
)
;
debug_assert
!
(
self
.
results
.
is_empty
(
)
)
;
self
.
begin_predecessors_lookup
(
sentinel
block
)
;
self
.
run_state_machine
(
func
var
ty
)
}
fn
begin_predecessors_lookup
(
&
mut
self
sentinel
:
Value
dest_block
:
Block
)
{
self
.
calls
.
push
(
Call
:
:
FinishPredecessorsLookup
(
sentinel
dest_block
)
)
;
let
mut
calls
=
mem
:
:
replace
(
&
mut
self
.
calls
Vec
:
:
new
(
)
)
;
calls
.
extend
(
self
.
predecessors
(
dest_block
)
.
iter
(
)
.
rev
(
)
.
map
(
|
&
PredBlock
{
ssa_block
:
pred
.
.
}
|
Call
:
:
UseVar
(
pred
)
)
)
;
self
.
calls
=
calls
;
}
fn
finish_predecessors_lookup
(
&
mut
self
func
:
&
mut
Function
sentinel
:
Value
var
:
Variable
dest_block
:
Block
)
{
let
mut
pred_values
:
ZeroOneOrMore
<
Value
>
=
ZeroOneOrMore
:
:
Zero
;
let
num_predecessors
=
self
.
predecessors
(
dest_block
)
.
len
(
)
;
for
&
pred_val
in
self
.
results
.
iter
(
)
.
rev
(
)
.
take
(
num_predecessors
)
{
match
pred_values
{
ZeroOneOrMore
:
:
Zero
=
>
{
if
pred_val
!
=
sentinel
{
pred_values
=
ZeroOneOrMore
:
:
One
(
pred_val
)
;
}
}
ZeroOneOrMore
:
:
One
(
old_val
)
=
>
{
if
pred_val
!
=
sentinel
&
&
pred_val
!
=
old_val
{
pred_values
=
ZeroOneOrMore
:
:
More
;
break
;
}
}
ZeroOneOrMore
:
:
More
=
>
{
break
;
}
}
}
self
.
results
.
truncate
(
self
.
results
.
len
(
)
-
num_predecessors
)
;
let
result_val
=
match
pred_values
{
ZeroOneOrMore
:
:
Zero
=
>
{
if
!
func
.
layout
.
is_block_inserted
(
dest_block
)
{
func
.
layout
.
append_block
(
dest_block
)
;
}
self
.
side_effects
.
instructions_added_to_blocks
.
push
(
dest_block
)
;
let
zero
=
emit_zero
(
func
.
dfg
.
value_type
(
sentinel
)
FuncCursor
:
:
new
(
func
)
.
at_first_insertion_point
(
dest_block
)
)
;
func
.
dfg
.
remove_block_param
(
sentinel
)
;
func
.
dfg
.
change_to_alias
(
sentinel
zero
)
;
zero
}
ZeroOneOrMore
:
:
One
(
pred_val
)
=
>
{
let
mut
resolved
=
func
.
dfg
.
resolve_aliases
(
pred_val
)
;
if
sentinel
=
=
resolved
{
resolved
=
emit_zero
(
func
.
dfg
.
value_type
(
sentinel
)
FuncCursor
:
:
new
(
func
)
.
at_first_insertion_point
(
dest_block
)
)
;
}
func
.
dfg
.
remove_block_param
(
sentinel
)
;
func
.
dfg
.
change_to_alias
(
sentinel
resolved
)
;
resolved
}
ZeroOneOrMore
:
:
More
=
>
{
let
mut
preds
=
mem
:
:
replace
(
self
.
predecessors_mut
(
dest_block
)
PredBlockSmallVec
:
:
new
(
)
)
;
for
&
mut
PredBlock
{
ssa_block
:
ref
mut
pred_ssa_block
branch
:
ref
mut
last_inst
}
in
&
mut
preds
{
let
ssa_block_map
=
self
.
variables
.
get
(
var
)
.
unwrap
(
)
;
let
pred_val
=
ssa_block_map
.
get
(
*
pred_ssa_block
)
.
unwrap
(
)
.
unwrap
(
)
;
let
jump_arg
=
self
.
append_jump_argument
(
func
*
last_inst
*
pred_ssa_block
dest_block
pred_val
var
)
;
if
let
Some
(
(
middle_block
middle_ssa_block
middle_jump_inst
)
)
=
jump_arg
{
*
pred_ssa_block
=
middle_ssa_block
;
*
last_inst
=
middle_jump_inst
;
self
.
side_effects
.
split_blocks_created
.
push
(
middle_block
)
;
}
}
debug_assert
!
(
self
.
predecessors
(
dest_block
)
.
is_empty
(
)
)
;
*
self
.
predecessors_mut
(
dest_block
)
=
preds
;
sentinel
}
}
;
self
.
results
.
push
(
result_val
)
;
}
fn
append_jump_argument
(
&
mut
self
func
:
&
mut
Function
jump_inst
:
Inst
jump_inst_ssa_block
:
SSABlock
dest_block
:
Block
val
:
Value
var
:
Variable
)
-
>
Option
<
(
Block
SSABlock
Inst
)
>
{
match
func
.
dfg
.
analyze_branch
(
jump_inst
)
{
BranchInfo
:
:
NotABranch
=
>
{
panic
!
(
"
you
have
declared
a
non
-
branch
instruction
as
a
predecessor
to
an
block
"
)
;
}
BranchInfo
:
:
SingleDest
(
_
_
)
=
>
{
func
.
dfg
.
append_inst_arg
(
jump_inst
val
)
;
None
}
BranchInfo
:
:
Table
(
jt
default_block
)
=
>
{
let
middle_block
=
func
.
dfg
.
make_block
(
)
;
func
.
layout
.
append_block
(
middle_block
)
;
let
middle_ssa_block
=
self
.
declare_block_header_block
(
middle_block
)
;
self
.
ssa_blocks
[
middle_ssa_block
]
.
add_predecessor
(
jump_inst_ssa_block
jump_inst
)
;
self
.
mark_block_header_block_sealed
(
middle_ssa_block
)
;
if
let
Some
(
default_block
)
=
default_block
{
if
dest_block
=
=
default_block
{
match
func
.
dfg
[
jump_inst
]
{
InstructionData
:
:
BranchTable
{
destination
:
ref
mut
dest
.
.
}
=
>
{
*
dest
=
middle_block
;
}
_
=
>
panic
!
(
"
should
not
happen
"
)
}
}
}
for
old_dest
in
func
.
jump_tables
[
jt
]
.
as_mut_slice
(
)
{
if
*
old_dest
=
=
dest_block
{
*
old_dest
=
middle_block
;
}
}
let
mut
cur
=
FuncCursor
:
:
new
(
func
)
.
at_bottom
(
middle_block
)
;
let
middle_jump_inst
=
cur
.
ins
(
)
.
jump
(
dest_block
&
[
val
]
)
;
self
.
def_var
(
var
val
middle_ssa_block
)
;
Some
(
(
middle_block
middle_ssa_block
middle_jump_inst
)
)
}
}
}
fn
predecessors
(
&
self
block
:
Block
)
-
>
&
[
PredBlock
]
{
let
ssa_block
=
self
.
header_block
(
block
)
;
match
self
.
ssa_blocks
[
ssa_block
]
{
SSABlockData
:
:
BlockBody
{
.
.
}
=
>
panic
!
(
"
should
not
happen
"
)
SSABlockData
:
:
BlockHeader
(
ref
data
)
=
>
&
data
.
predecessors
}
}
pub
fn
has_any_predecessors
(
&
self
block
:
Block
)
-
>
bool
{
!
self
.
predecessors
(
block
)
.
is_empty
(
)
}
fn
predecessors_mut
(
&
mut
self
block
:
Block
)
-
>
&
mut
PredBlockSmallVec
{
let
ssa_block
=
self
.
header_block
(
block
)
;
match
self
.
ssa_blocks
[
ssa_block
]
{
SSABlockData
:
:
BlockBody
{
.
.
}
=
>
panic
!
(
"
should
not
happen
"
)
SSABlockData
:
:
BlockHeader
(
ref
mut
data
)
=
>
&
mut
data
.
predecessors
}
}
pub
fn
is_sealed
(
&
self
block
:
Block
)
-
>
bool
{
match
self
.
ssa_blocks
[
self
.
header_block
(
block
)
]
{
SSABlockData
:
:
BlockBody
{
.
.
}
=
>
panic
!
(
"
should
not
happen
"
)
SSABlockData
:
:
BlockHeader
(
ref
data
)
=
>
data
.
sealed
}
}
fn
run_state_machine
(
&
mut
self
func
:
&
mut
Function
var
:
Variable
ty
:
Type
)
-
>
Value
{
while
let
Some
(
call
)
=
self
.
calls
.
pop
(
)
{
match
call
{
Call
:
:
UseVar
(
ssa_block
)
=
>
{
if
let
Some
(
var_defs
)
=
self
.
variables
.
get
(
var
)
{
if
let
Some
(
val
)
=
var_defs
[
ssa_block
]
.
expand
(
)
{
self
.
results
.
push
(
val
)
;
continue
;
}
}
self
.
use_var_nonlocal
(
func
var
ty
ssa_block
)
;
}
Call
:
:
FinishSealedOnePredecessor
(
ssa_block
)
=
>
{
self
.
finish_sealed_one_predecessor
(
var
ssa_block
)
;
}
Call
:
:
FinishPredecessorsLookup
(
sentinel
dest_block
)
=
>
{
self
.
finish_predecessors_lookup
(
func
sentinel
var
dest_block
)
;
}
}
}
debug_assert_eq
!
(
self
.
results
.
len
(
)
1
)
;
self
.
results
.
pop
(
)
.
unwrap
(
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
crate
:
:
ssa
:
:
SSABuilder
;
use
crate
:
:
Variable
;
use
cranelift_codegen
:
:
cursor
:
:
{
Cursor
FuncCursor
}
;
use
cranelift_codegen
:
:
entity
:
:
EntityRef
;
use
cranelift_codegen
:
:
ir
:
:
instructions
:
:
BranchInfo
;
use
cranelift_codegen
:
:
ir
:
:
types
:
:
*
;
use
cranelift_codegen
:
:
ir
:
:
{
Function
Inst
InstBuilder
JumpTableData
Opcode
}
;
use
cranelift_codegen
:
:
settings
;
use
cranelift_codegen
:
:
verify_function
;
#
[
test
]
fn
simple_block
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
mut
ssa
=
SSABuilder
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
ssa_block
=
ssa
.
declare_block_header_block
(
block0
)
;
let
x_var
=
Variable
:
:
new
(
0
)
;
let
x_ssa
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
;
cur
.
insert_block
(
block0
)
;
cur
.
ins
(
)
.
iconst
(
I32
1
)
}
;
ssa
.
def_var
(
x_var
x_ssa
ssa_block
)
;
let
y_var
=
Variable
:
:
new
(
1
)
;
let
y_ssa
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
iconst
(
I32
2
)
}
;
ssa
.
def_var
(
y_var
y_ssa
ssa_block
)
;
assert_eq
!
(
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block
)
.
0
x_ssa
)
;
assert_eq
!
(
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block
)
.
0
y_ssa
)
;
let
z_var
=
Variable
:
:
new
(
2
)
;
let
x_use1
=
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block
)
.
0
;
let
y_use1
=
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block
)
.
0
;
let
z1_ssa
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
iadd
(
x_use1
y_use1
)
}
;
ssa
.
def_var
(
z_var
z1_ssa
ssa_block
)
;
assert_eq
!
(
ssa
.
use_var
(
&
mut
func
z_var
I32
ssa_block
)
.
0
z1_ssa
)
;
let
x_use2
=
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block
)
.
0
;
let
z_use1
=
ssa
.
use_var
(
&
mut
func
z_var
I32
ssa_block
)
.
0
;
let
z2_ssa
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
iadd
(
x_use2
z_use1
)
}
;
ssa
.
def_var
(
z_var
z2_ssa
ssa_block
)
;
assert_eq
!
(
ssa
.
use_var
(
&
mut
func
z_var
I32
ssa_block
)
.
0
z2_ssa
)
;
}
#
[
test
]
fn
sequence_of_blocks
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
mut
ssa
=
SSABuilder
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
block1
=
func
.
dfg
.
make_block
(
)
;
let
ssa_block0
=
ssa
.
declare_block_header_block
(
block0
)
;
let
x_var
=
Variable
:
:
new
(
0
)
;
let
x_ssa
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
;
cur
.
insert_block
(
block0
)
;
cur
.
insert_block
(
block1
)
;
cur
.
goto_bottom
(
block0
)
;
cur
.
ins
(
)
.
iconst
(
I32
1
)
}
;
ssa
.
def_var
(
x_var
x_ssa
ssa_block0
)
;
let
y_var
=
Variable
:
:
new
(
1
)
;
let
y_ssa
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
iconst
(
I32
2
)
}
;
ssa
.
def_var
(
y_var
y_ssa
ssa_block0
)
;
assert_eq
!
(
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block0
)
.
0
x_ssa
)
;
assert_eq
!
(
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block0
)
.
0
y_ssa
)
;
let
z_var
=
Variable
:
:
new
(
2
)
;
let
x_use1
=
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block0
)
.
0
;
let
y_use1
=
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block0
)
.
0
;
let
z1_ssa
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
iadd
(
x_use1
y_use1
)
}
;
ssa
.
def_var
(
z_var
z1_ssa
ssa_block0
)
;
assert_eq
!
(
ssa
.
use_var
(
&
mut
func
z_var
I32
ssa_block0
)
.
0
z1_ssa
)
;
let
y_use2
=
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block0
)
.
0
;
let
jump_inst
:
Inst
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
brnz
(
y_use2
block1
&
[
]
)
}
;
let
ssa_block1
=
ssa
.
declare_block_body_block
(
ssa_block0
)
;
let
x_use2
=
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block1
)
.
0
;
assert_eq
!
(
x_use2
x_ssa
)
;
let
z_use1
=
ssa
.
use_var
(
&
mut
func
z_var
I32
ssa_block1
)
.
0
;
assert_eq
!
(
z_use1
z1_ssa
)
;
let
z2_ssa
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
iadd
(
x_use2
z_use1
)
}
;
ssa
.
def_var
(
z_var
z2_ssa
ssa_block1
)
;
assert_eq
!
(
ssa
.
use_var
(
&
mut
func
z_var
I32
ssa_block1
)
.
0
z2_ssa
)
;
ssa
.
seal_block_header_block
(
block0
&
mut
func
)
;
let
ssa_block2
=
ssa
.
declare_block_header_block
(
block1
)
;
ssa
.
declare_block_predecessor
(
block1
ssa_block0
jump_inst
)
;
ssa
.
seal_block_header_block
(
block1
&
mut
func
)
;
let
x_use3
=
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block2
)
.
0
;
assert_eq
!
(
x_ssa
x_use3
)
;
let
y_use3
=
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block2
)
.
0
;
assert_eq
!
(
y_ssa
y_use3
)
;
let
y2_ssa
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
iadd
(
x_use3
y_use3
)
}
;
ssa
.
def_var
(
y_var
y2_ssa
ssa_block2
)
;
match
func
.
dfg
.
analyze_branch
(
jump_inst
)
{
BranchInfo
:
:
SingleDest
(
dest
jump_args
)
=
>
{
assert_eq
!
(
dest
block1
)
;
assert_eq
!
(
jump_args
.
len
(
)
0
)
;
}
_
=
>
assert
!
(
false
)
}
;
}
#
[
test
]
fn
program_with_loop
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
mut
ssa
=
SSABuilder
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
block1
=
func
.
dfg
.
make_block
(
)
;
let
block2
=
func
.
dfg
.
make_block
(
)
;
let
ssa_block0
=
ssa
.
declare_block_header_block
(
block0
)
;
ssa
.
seal_block_header_block
(
block0
&
mut
func
)
;
let
x_var
=
Variable
:
:
new
(
0
)
;
let
x1
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
;
cur
.
insert_block
(
block0
)
;
cur
.
insert_block
(
block1
)
;
cur
.
insert_block
(
block2
)
;
cur
.
goto_bottom
(
block0
)
;
cur
.
ins
(
)
.
iconst
(
I32
1
)
}
;
ssa
.
def_var
(
x_var
x1
ssa_block0
)
;
assert_eq
!
(
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block0
)
.
0
x1
)
;
let
y_var
=
Variable
:
:
new
(
1
)
;
let
y1
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
iconst
(
I32
2
)
}
;
ssa
.
def_var
(
y_var
y1
ssa_block0
)
;
assert_eq
!
(
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block0
)
.
0
y1
)
;
let
z_var
=
Variable
:
:
new
(
2
)
;
let
x2
=
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block0
)
.
0
;
assert_eq
!
(
x2
x1
)
;
let
y2
=
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block0
)
.
0
;
assert_eq
!
(
y2
y1
)
;
let
z1
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
iadd
(
x2
y2
)
}
;
ssa
.
def_var
(
z_var
z1
ssa_block0
)
;
let
jump_block0_block1
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
jump
(
block1
&
[
]
)
}
;
let
ssa_block1
=
ssa
.
declare_block_header_block
(
block1
)
;
ssa
.
declare_block_predecessor
(
block1
ssa_block0
jump_block0_block1
)
;
let
z2
=
ssa
.
use_var
(
&
mut
func
z_var
I32
ssa_block1
)
.
0
;
let
y3
=
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block1
)
.
0
;
let
z3
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block1
)
;
cur
.
ins
(
)
.
iadd
(
z2
y3
)
}
;
ssa
.
def_var
(
z_var
z3
ssa_block1
)
;
let
y4
=
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block1
)
.
0
;
assert_eq
!
(
y4
y3
)
;
let
jump_block1_block2
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block1
)
;
cur
.
ins
(
)
.
brnz
(
y4
block2
&
[
]
)
}
;
let
ssa_block2
=
ssa
.
declare_block_body_block
(
ssa_block1
)
;
let
z4
=
ssa
.
use_var
(
&
mut
func
z_var
I32
ssa_block2
)
.
0
;
assert_eq
!
(
z4
z3
)
;
let
x3
=
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block2
)
.
0
;
let
z5
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block1
)
;
cur
.
ins
(
)
.
isub
(
z4
x3
)
}
;
ssa
.
def_var
(
z_var
z5
ssa_block2
)
;
let
y5
=
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block2
)
.
0
;
assert_eq
!
(
y5
y3
)
;
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block1
)
;
cur
.
ins
(
)
.
return_
(
&
[
y5
]
)
}
;
let
ssa_block3
=
ssa
.
declare_block_header_block
(
block2
)
;
ssa
.
declare_block_predecessor
(
block2
ssa_block1
jump_block1_block2
)
;
ssa
.
seal_block_header_block
(
block2
&
mut
func
)
;
let
y6
=
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block3
)
.
0
;
assert_eq
!
(
y6
y3
)
;
let
x4
=
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block3
)
.
0
;
assert_eq
!
(
x4
x3
)
;
let
y7
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block2
)
;
cur
.
ins
(
)
.
isub
(
y6
x4
)
}
;
ssa
.
def_var
(
y_var
y7
ssa_block3
)
;
let
jump_block2_block1
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block2
)
;
cur
.
ins
(
)
.
jump
(
block1
&
[
]
)
}
;
ssa
.
declare_block_predecessor
(
block1
ssa_block3
jump_block2_block1
)
;
ssa
.
seal_block_header_block
(
block1
&
mut
func
)
;
assert_eq
!
(
func
.
dfg
.
block_params
(
block1
)
[
0
]
z2
)
;
assert_eq
!
(
func
.
dfg
.
block_params
(
block1
)
[
1
]
y3
)
;
assert_eq
!
(
func
.
dfg
.
resolve_aliases
(
x3
)
x1
)
;
}
#
[
test
]
fn
br_table_with_args
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
mut
ssa
=
SSABuilder
:
:
new
(
)
;
let
mut
jump_table
=
JumpTableData
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
block1
=
func
.
dfg
.
make_block
(
)
;
let
block2
=
func
.
dfg
.
make_block
(
)
;
let
ssa_block0
=
ssa
.
declare_block_header_block
(
block0
)
;
ssa
.
seal_block_header_block
(
block0
&
mut
func
)
;
let
x_var
=
Variable
:
:
new
(
0
)
;
let
x1
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
;
cur
.
insert_block
(
block0
)
;
cur
.
insert_block
(
block1
)
;
cur
.
insert_block
(
block2
)
;
cur
.
goto_bottom
(
block0
)
;
cur
.
ins
(
)
.
iconst
(
I32
1
)
}
;
ssa
.
def_var
(
x_var
x1
ssa_block0
)
;
jump_table
.
push_entry
(
block2
)
;
jump_table
.
push_entry
(
block1
)
;
let
jt
=
func
.
create_jump_table
(
jump_table
)
;
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block0
)
.
0
;
let
br_table
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
br_table
(
x1
block2
jt
)
}
;
let
ssa_block1
=
ssa
.
declare_block_header_block
(
block1
)
;
ssa
.
seal_block_header_block
(
block1
&
mut
func
)
;
let
x2
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block1
)
;
cur
.
ins
(
)
.
iconst
(
I32
2
)
}
;
ssa
.
def_var
(
x_var
x2
ssa_block1
)
;
let
jump_inst
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block1
)
;
cur
.
ins
(
)
.
jump
(
block2
&
[
]
)
}
;
let
ssa_block3
=
ssa
.
declare_block_header_block
(
block2
)
;
ssa
.
declare_block_predecessor
(
block2
ssa_block1
jump_inst
)
;
ssa
.
declare_block_predecessor
(
block2
ssa_block0
br_table
)
;
ssa
.
seal_block_header_block
(
block2
&
mut
func
)
;
let
ssa_block4
=
ssa
.
declare_block_body_block
(
ssa_block3
)
;
let
x3
=
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block4
)
.
0
;
let
x4
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block2
)
;
cur
.
ins
(
)
.
iadd_imm
(
x3
1
)
}
;
ssa
.
def_var
(
x_var
x4
ssa_block4
)
;
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block2
)
;
cur
.
ins
(
)
.
return_
(
&
[
]
)
}
;
let
flags
=
settings
:
:
Flags
:
:
new
(
settings
:
:
builder
(
)
)
;
match
verify_function
(
&
func
&
flags
)
{
Ok
(
(
)
)
=
>
{
}
Err
(
_errors
)
=
>
{
#
[
cfg
(
feature
=
"
std
"
)
]
panic
!
(
_errors
)
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
panic
!
(
"
function
failed
to
verify
"
)
;
}
}
}
#
[
test
]
fn
undef_values_reordering
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
mut
ssa
=
SSABuilder
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
block1
=
func
.
dfg
.
make_block
(
)
;
let
ssa_block0
=
ssa
.
declare_block_header_block
(
block0
)
;
let
x_var
=
Variable
:
:
new
(
0
)
;
let
y_var
=
Variable
:
:
new
(
1
)
;
let
z_var
=
Variable
:
:
new
(
2
)
;
ssa
.
seal_block_header_block
(
block0
&
mut
func
)
;
let
x1
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
;
cur
.
insert_block
(
block0
)
;
cur
.
insert_block
(
block1
)
;
cur
.
goto_bottom
(
block0
)
;
cur
.
ins
(
)
.
iconst
(
I32
0
)
}
;
ssa
.
def_var
(
x_var
x1
ssa_block0
)
;
let
y1
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
iconst
(
I32
1
)
}
;
ssa
.
def_var
(
y_var
y1
ssa_block0
)
;
let
z1
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
iconst
(
I32
2
)
}
;
ssa
.
def_var
(
z_var
z1
ssa_block0
)
;
let
jump_inst
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block0
)
;
cur
.
ins
(
)
.
jump
(
block1
&
[
]
)
}
;
let
ssa_block1
=
ssa
.
declare_block_header_block
(
block1
)
;
ssa
.
declare_block_predecessor
(
block1
ssa_block0
jump_inst
)
;
let
z2
=
ssa
.
use_var
(
&
mut
func
z_var
I32
ssa_block1
)
.
0
;
assert_eq
!
(
func
.
dfg
.
block_params
(
block1
)
[
0
]
z2
)
;
let
x2
=
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block1
)
.
0
;
assert_eq
!
(
func
.
dfg
.
block_params
(
block1
)
[
1
]
x2
)
;
let
x3
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block1
)
;
cur
.
ins
(
)
.
iadd
(
x2
z2
)
}
;
ssa
.
def_var
(
x_var
x3
ssa_block1
)
;
let
x4
=
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block1
)
.
0
;
let
y3
=
ssa
.
use_var
(
&
mut
func
y_var
I32
ssa_block1
)
.
0
;
assert_eq
!
(
func
.
dfg
.
block_params
(
block1
)
[
2
]
y3
)
;
let
y4
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block1
)
;
cur
.
ins
(
)
.
isub
(
y3
x4
)
}
;
ssa
.
def_var
(
y_var
y4
ssa_block1
)
;
let
jump_inst
=
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
.
at_bottom
(
block1
)
;
cur
.
ins
(
)
.
jump
(
block1
&
[
]
)
}
;
ssa
.
declare_block_predecessor
(
block1
ssa_block1
jump_inst
)
;
ssa
.
seal_block_header_block
(
block1
&
mut
func
)
;
assert_eq
!
(
func
.
dfg
.
block_params
(
block1
)
[
1
]
y3
)
;
assert_eq
!
(
func
.
dfg
.
block_params
(
block1
)
[
0
]
x2
)
;
}
#
[
test
]
fn
undef
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
mut
ssa
=
SSABuilder
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
ssa_block
=
ssa
.
declare_block_header_block
(
block0
)
;
ssa
.
seal_block_header_block
(
block0
&
mut
func
)
;
let
i32_var
=
Variable
:
:
new
(
0
)
;
let
f32_var
=
Variable
:
:
new
(
1
)
;
let
f64_var
=
Variable
:
:
new
(
2
)
;
let
b1_var
=
Variable
:
:
new
(
3
)
;
let
f32x4_var
=
Variable
:
:
new
(
4
)
;
ssa
.
use_var
(
&
mut
func
i32_var
I32
ssa_block
)
;
ssa
.
use_var
(
&
mut
func
f32_var
F32
ssa_block
)
;
ssa
.
use_var
(
&
mut
func
f64_var
F64
ssa_block
)
;
ssa
.
use_var
(
&
mut
func
b1_var
B1
ssa_block
)
;
ssa
.
use_var
(
&
mut
func
f32x4_var
F32X4
ssa_block
)
;
assert_eq
!
(
func
.
dfg
.
num_block_params
(
block0
)
0
)
;
}
#
[
test
]
fn
undef_in_entry
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
mut
ssa
=
SSABuilder
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
ssa_block
=
ssa
.
declare_block_header_block
(
block0
)
;
ssa
.
seal_block_header_block
(
block0
&
mut
func
)
;
let
x_var
=
Variable
:
:
new
(
0
)
;
assert_eq
!
(
func
.
dfg
.
num_block_params
(
block0
)
0
)
;
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block
)
;
assert_eq
!
(
func
.
dfg
.
num_block_params
(
block0
)
0
)
;
assert_eq
!
(
func
.
dfg
[
func
.
layout
.
first_inst
(
block0
)
.
unwrap
(
)
]
.
opcode
(
)
Opcode
:
:
Iconst
)
;
}
#
[
test
]
fn
undef_in_entry_sealed_after
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
mut
ssa
=
SSABuilder
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
ssa_block
=
ssa
.
declare_block_header_block
(
block0
)
;
let
x_var
=
Variable
:
:
new
(
0
)
;
assert_eq
!
(
func
.
dfg
.
num_block_params
(
block0
)
0
)
;
ssa
.
use_var
(
&
mut
func
x_var
I32
ssa_block
)
;
assert_eq
!
(
func
.
dfg
.
num_block_params
(
block0
)
1
)
;
ssa
.
seal_block_header_block
(
block0
&
mut
func
)
;
assert_eq
!
(
func
.
dfg
.
num_block_params
(
block0
)
0
)
;
assert_eq
!
(
func
.
dfg
[
func
.
layout
.
first_inst
(
block0
)
.
unwrap
(
)
]
.
opcode
(
)
Opcode
:
:
Iconst
)
;
}
#
[
test
]
fn
unreachable_use
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
mut
ssa
=
SSABuilder
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
block1
=
func
.
dfg
.
make_block
(
)
;
let
_ssa_block0
=
ssa
.
declare_block_header_block
(
block0
)
;
ssa
.
seal_block_header_block
(
block0
&
mut
func
)
;
let
ssa_block1
=
ssa
.
declare_block_header_block
(
block1
)
;
let
ssa_block2
=
ssa
.
declare_block_body_block
(
ssa_block1
)
;
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
;
cur
.
insert_block
(
block0
)
;
cur
.
insert_block
(
block1
)
;
cur
.
goto_bottom
(
block0
)
;
cur
.
ins
(
)
.
return_
(
&
[
]
)
;
let
x_var
=
Variable
:
:
new
(
0
)
;
cur
.
goto_bottom
(
block1
)
;
let
val
=
ssa
.
use_var
(
&
mut
cur
.
func
x_var
I32
ssa_block1
)
.
0
;
let
brz
=
cur
.
ins
(
)
.
brz
(
val
block1
&
[
]
)
;
ssa
.
declare_block_predecessor
(
block1
ssa_block1
brz
)
;
let
j
=
cur
.
ins
(
)
.
jump
(
block1
&
[
]
)
;
ssa
.
declare_block_predecessor
(
block1
ssa_block2
j
)
;
}
ssa
.
seal_block_header_block
(
block1
&
mut
func
)
;
let
flags
=
settings
:
:
Flags
:
:
new
(
settings
:
:
builder
(
)
)
;
match
verify_function
(
&
func
&
flags
)
{
Ok
(
(
)
)
=
>
{
}
Err
(
_errors
)
=
>
{
#
[
cfg
(
feature
=
"
std
"
)
]
panic
!
(
_errors
)
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
panic
!
(
"
function
failed
to
verify
"
)
;
}
}
}
#
[
test
]
fn
unreachable_use_with_multiple_preds
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
mut
ssa
=
SSABuilder
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
block1
=
func
.
dfg
.
make_block
(
)
;
let
block2
=
func
.
dfg
.
make_block
(
)
;
let
_ssa_block0
=
ssa
.
declare_block_header_block
(
block0
)
;
ssa
.
seal_block_header_block
(
block0
&
mut
func
)
;
let
ssa_block1
=
ssa
.
declare_block_header_block
(
block1
)
;
let
ssa_block2
=
ssa
.
declare_block_header_block
(
block2
)
;
{
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
;
let
x_var
=
Variable
:
:
new
(
0
)
;
cur
.
insert_block
(
block0
)
;
cur
.
insert_block
(
block1
)
;
cur
.
insert_block
(
block2
)
;
cur
.
goto_bottom
(
block0
)
;
cur
.
ins
(
)
.
return_
(
&
[
]
)
;
cur
.
goto_bottom
(
block1
)
;
let
v
=
ssa
.
use_var
(
&
mut
cur
.
func
x_var
I32
ssa_block1
)
.
0
;
let
brz
=
cur
.
ins
(
)
.
brz
(
v
block2
&
[
]
)
;
let
j0
=
cur
.
ins
(
)
.
jump
(
block1
&
[
]
)
;
cur
.
goto_bottom
(
block2
)
;
let
j1
=
cur
.
ins
(
)
.
jump
(
block1
&
[
]
)
;
ssa
.
declare_block_predecessor
(
block1
ssa_block2
brz
)
;
ssa
.
declare_block_predecessor
(
block1
ssa_block1
j0
)
;
ssa
.
declare_block_predecessor
(
block2
ssa_block1
j1
)
;
}
ssa
.
seal_block_header_block
(
block1
&
mut
func
)
;
ssa
.
seal_block_header_block
(
block2
&
mut
func
)
;
let
flags
=
settings
:
:
Flags
:
:
new
(
settings
:
:
builder
(
)
)
;
match
verify_function
(
&
func
&
flags
)
{
Ok
(
(
)
)
=
>
{
}
Err
(
_errors
)
=
>
{
#
[
cfg
(
feature
=
"
std
"
)
]
panic
!
(
_errors
)
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
panic
!
(
"
function
failed
to
verify
"
)
;
}
}
}
}
