use
crate
:
:
ssa
:
:
{
Block
SSABuilder
SideEffects
}
;
use
crate
:
:
variable
:
:
Variable
;
use
cranelift_codegen
:
:
cursor
:
:
{
Cursor
FuncCursor
}
;
use
cranelift_codegen
:
:
entity
:
:
{
EntitySet
SecondaryMap
}
;
use
cranelift_codegen
:
:
ir
;
use
cranelift_codegen
:
:
ir
:
:
function
:
:
DisplayFunction
;
use
cranelift_codegen
:
:
ir
:
:
{
types
AbiParam
DataFlowGraph
Ebb
ExtFuncData
ExternalName
FuncRef
Function
GlobalValue
GlobalValueData
Heap
HeapData
Inst
InstBuilder
InstBuilderBase
InstructionData
JumpTable
JumpTableData
LibCall
MemFlags
SigRef
Signature
StackSlot
StackSlotData
Type
Value
}
;
use
cranelift_codegen
:
:
isa
:
:
{
TargetFrontendConfig
TargetIsa
}
;
use
cranelift_codegen
:
:
packed_option
:
:
PackedOption
;
use
std
:
:
vec
:
:
Vec
;
pub
struct
FunctionBuilderContext
{
ssa
:
SSABuilder
ebbs
:
SecondaryMap
<
Ebb
EbbData
>
types
:
SecondaryMap
<
Variable
Type
>
}
pub
struct
FunctionBuilder
<
'
a
>
{
pub
func
:
&
'
a
mut
Function
srcloc
:
ir
:
:
SourceLoc
func_ctx
:
&
'
a
mut
FunctionBuilderContext
position
:
Position
}
#
[
derive
(
Clone
Default
)
]
struct
EbbData
{
filled
:
bool
pristine
:
bool
user_param_count
:
usize
}
struct
Position
{
ebb
:
PackedOption
<
Ebb
>
basic_block
:
PackedOption
<
Block
>
}
impl
Position
{
fn
at
(
ebb
:
Ebb
basic_block
:
Block
)
-
>
Self
{
Self
{
ebb
:
PackedOption
:
:
from
(
ebb
)
basic_block
:
PackedOption
:
:
from
(
basic_block
)
}
}
fn
default
(
)
-
>
Self
{
Self
{
ebb
:
PackedOption
:
:
default
(
)
basic_block
:
PackedOption
:
:
default
(
)
}
}
fn
is_default
(
&
self
)
-
>
bool
{
self
.
ebb
.
is_none
(
)
&
&
self
.
basic_block
.
is_none
(
)
}
}
impl
FunctionBuilderContext
{
pub
fn
new
(
)
-
>
Self
{
Self
{
ssa
:
SSABuilder
:
:
new
(
)
ebbs
:
SecondaryMap
:
:
new
(
)
types
:
SecondaryMap
:
:
new
(
)
}
}
fn
clear
(
&
mut
self
)
{
self
.
ssa
.
clear
(
)
;
self
.
ebbs
.
clear
(
)
;
self
.
types
.
clear
(
)
;
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
ssa
.
is_empty
(
)
&
&
self
.
ebbs
.
is_empty
(
)
&
&
self
.
types
.
is_empty
(
)
}
}
pub
struct
FuncInstBuilder
<
'
short
'
long
:
'
short
>
{
builder
:
&
'
short
mut
FunctionBuilder
<
'
long
>
ebb
:
Ebb
}
impl
<
'
short
'
long
>
FuncInstBuilder
<
'
short
'
long
>
{
fn
new
(
builder
:
&
'
short
mut
FunctionBuilder
<
'
long
>
ebb
:
Ebb
)
-
>
Self
{
Self
{
builder
ebb
}
}
}
impl
<
'
short
'
long
>
InstBuilderBase
<
'
short
>
for
FuncInstBuilder
<
'
short
'
long
>
{
fn
data_flow_graph
(
&
self
)
-
>
&
DataFlowGraph
{
&
self
.
builder
.
func
.
dfg
}
fn
data_flow_graph_mut
(
&
mut
self
)
-
>
&
mut
DataFlowGraph
{
&
mut
self
.
builder
.
func
.
dfg
}
fn
build
(
self
data
:
InstructionData
ctrl_typevar
:
Type
)
-
>
(
Inst
&
'
short
mut
DataFlowGraph
)
{
self
.
builder
.
ensure_inserted_ebb
(
)
;
let
inst
=
self
.
builder
.
func
.
dfg
.
make_inst
(
data
.
clone
(
)
)
;
self
.
builder
.
func
.
dfg
.
make_inst_results
(
inst
ctrl_typevar
)
;
self
.
builder
.
func
.
layout
.
append_inst
(
inst
self
.
ebb
)
;
if
!
self
.
builder
.
srcloc
.
is_default
(
)
{
self
.
builder
.
func
.
srclocs
[
inst
]
=
self
.
builder
.
srcloc
;
}
if
data
.
opcode
(
)
.
is_branch
(
)
{
match
data
.
branch_destination
(
)
{
Some
(
dest_ebb
)
=
>
{
self
.
builder
.
declare_successor
(
dest_ebb
inst
)
;
}
None
=
>
{
if
let
InstructionData
:
:
BranchTable
{
table
destination
.
.
}
=
data
{
let
mut
unique
=
EntitySet
:
:
<
Ebb
>
:
:
new
(
)
;
for
dest_ebb
in
self
.
builder
.
func
.
jump_tables
.
get
(
table
)
.
expect
(
"
you
are
referencing
an
undeclared
jump
table
"
)
.
iter
(
)
.
filter
(
|
&
dest_ebb
|
unique
.
insert
(
*
dest_ebb
)
)
{
self
.
builder
.
func_ctx
.
ssa
.
declare_ebb_predecessor
(
*
dest_ebb
self
.
builder
.
position
.
basic_block
.
unwrap
(
)
inst
)
;
}
self
.
builder
.
func_ctx
.
ssa
.
declare_ebb_predecessor
(
destination
self
.
builder
.
position
.
basic_block
.
unwrap
(
)
inst
)
;
}
}
}
}
if
data
.
opcode
(
)
.
is_terminator
(
)
{
self
.
builder
.
fill_current_block
(
)
}
else
if
data
.
opcode
(
)
.
is_branch
(
)
{
self
.
builder
.
move_to_next_basic_block
(
)
}
(
inst
&
mut
self
.
builder
.
func
.
dfg
)
}
}
impl
<
'
a
>
FunctionBuilder
<
'
a
>
{
pub
fn
new
(
func
:
&
'
a
mut
Function
func_ctx
:
&
'
a
mut
FunctionBuilderContext
)
-
>
Self
{
debug_assert
!
(
func_ctx
.
is_empty
(
)
)
;
Self
{
func
srcloc
:
Default
:
:
default
(
)
func_ctx
position
:
Position
:
:
default
(
)
}
}
pub
fn
set_srcloc
(
&
mut
self
srcloc
:
ir
:
:
SourceLoc
)
{
self
.
srcloc
=
srcloc
;
}
pub
fn
create_ebb
(
&
mut
self
)
-
>
Ebb
{
let
ebb
=
self
.
func
.
dfg
.
make_ebb
(
)
;
self
.
func_ctx
.
ssa
.
declare_ebb_header_block
(
ebb
)
;
self
.
func_ctx
.
ebbs
[
ebb
]
=
EbbData
{
filled
:
false
pristine
:
true
user_param_count
:
0
}
;
ebb
}
pub
fn
switch_to_block
(
&
mut
self
ebb
:
Ebb
)
{
debug_assert
!
(
self
.
position
.
is_default
(
)
|
|
self
.
is_unreachable
(
)
|
|
self
.
is_pristine
(
)
|
|
self
.
is_filled
(
)
"
you
have
to
fill
your
block
before
switching
"
)
;
debug_assert
!
(
!
self
.
func_ctx
.
ebbs
[
ebb
]
.
filled
"
you
cannot
switch
to
a
block
which
is
already
filled
"
)
;
let
basic_block
=
self
.
func_ctx
.
ssa
.
header_block
(
ebb
)
;
self
.
position
=
Position
:
:
at
(
ebb
basic_block
)
;
}
pub
fn
seal_block
(
&
mut
self
ebb
:
Ebb
)
{
let
side_effects
=
self
.
func_ctx
.
ssa
.
seal_ebb_header_block
(
ebb
self
.
func
)
;
self
.
handle_ssa_side_effects
(
side_effects
)
;
}
pub
fn
seal_all_blocks
(
&
mut
self
)
{
let
side_effects
=
self
.
func_ctx
.
ssa
.
seal_all_ebb_header_blocks
(
self
.
func
)
;
self
.
handle_ssa_side_effects
(
side_effects
)
;
}
pub
fn
declare_var
(
&
mut
self
var
:
Variable
ty
:
Type
)
{
self
.
func_ctx
.
types
[
var
]
=
ty
;
}
pub
fn
use_var
(
&
mut
self
var
:
Variable
)
-
>
Value
{
let
(
val
side_effects
)
=
{
let
ty
=
*
self
.
func_ctx
.
types
.
get
(
var
)
.
unwrap_or_else
(
|
|
{
panic
!
(
"
variable
{
:
?
}
is
used
but
its
type
has
not
been
declared
"
var
)
}
)
;
self
.
func_ctx
.
ssa
.
use_var
(
self
.
func
var
ty
self
.
position
.
basic_block
.
unwrap
(
)
)
}
;
self
.
handle_ssa_side_effects
(
side_effects
)
;
val
}
pub
fn
def_var
(
&
mut
self
var
:
Variable
val
:
Value
)
{
debug_assert_eq
!
(
*
self
.
func_ctx
.
types
.
get
(
var
)
.
unwrap_or_else
(
|
|
panic
!
(
"
variable
{
:
?
}
is
used
but
its
type
has
not
been
declared
"
var
)
)
self
.
func
.
dfg
.
value_type
(
val
)
"
declared
type
of
variable
{
:
?
}
doesn
'
t
match
type
of
value
{
}
"
var
val
)
;
self
.
func_ctx
.
ssa
.
def_var
(
var
val
self
.
position
.
basic_block
.
unwrap
(
)
)
;
}
pub
fn
create_jump_table
(
&
mut
self
data
:
JumpTableData
)
-
>
JumpTable
{
self
.
func
.
create_jump_table
(
data
)
}
pub
fn
create_stack_slot
(
&
mut
self
data
:
StackSlotData
)
-
>
StackSlot
{
self
.
func
.
create_stack_slot
(
data
)
}
pub
fn
import_signature
(
&
mut
self
signature
:
Signature
)
-
>
SigRef
{
self
.
func
.
import_signature
(
signature
)
}
pub
fn
import_function
(
&
mut
self
data
:
ExtFuncData
)
-
>
FuncRef
{
self
.
func
.
import_function
(
data
)
}
pub
fn
create_global_value
(
&
mut
self
data
:
GlobalValueData
)
-
>
GlobalValue
{
self
.
func
.
create_global_value
(
data
)
}
pub
fn
create_heap
(
&
mut
self
data
:
HeapData
)
-
>
Heap
{
self
.
func
.
create_heap
(
data
)
}
pub
fn
ins
<
'
short
>
(
&
'
short
mut
self
)
-
>
FuncInstBuilder
<
'
short
'
a
>
{
let
ebb
=
self
.
position
.
ebb
.
expect
(
"
Please
call
switch_to_block
before
inserting
instructions
"
)
;
FuncInstBuilder
:
:
new
(
self
ebb
)
}
pub
fn
ensure_inserted_ebb
(
&
mut
self
)
{
let
ebb
=
self
.
position
.
ebb
.
unwrap
(
)
;
if
self
.
func_ctx
.
ebbs
[
ebb
]
.
pristine
{
if
!
self
.
func
.
layout
.
is_ebb_inserted
(
ebb
)
{
self
.
func
.
layout
.
append_ebb
(
ebb
)
;
}
self
.
func_ctx
.
ebbs
[
ebb
]
.
pristine
=
false
;
}
else
{
debug_assert
!
(
!
self
.
func_ctx
.
ebbs
[
ebb
]
.
filled
"
you
cannot
add
an
instruction
to
a
block
already
filled
"
)
;
}
}
pub
fn
cursor
(
&
mut
self
)
-
>
FuncCursor
{
self
.
ensure_inserted_ebb
(
)
;
FuncCursor
:
:
new
(
self
.
func
)
.
with_srcloc
(
self
.
srcloc
)
.
at_bottom
(
self
.
position
.
ebb
.
unwrap
(
)
)
}
pub
fn
append_ebb_params_for_function_params
(
&
mut
self
ebb
:
Ebb
)
{
debug_assert
!
(
!
self
.
func_ctx
.
ssa
.
has_any_predecessors
(
ebb
)
"
ebb
parameters
for
function
parameters
should
only
be
added
to
the
entry
block
"
)
;
let
user_param_count
=
&
mut
self
.
func_ctx
.
ebbs
[
ebb
]
.
user_param_count
;
for
argtyp
in
&
self
.
func
.
signature
.
params
{
*
user_param_count
+
=
1
;
self
.
func
.
dfg
.
append_ebb_param
(
ebb
argtyp
.
value_type
)
;
}
}
pub
fn
append_ebb_params_for_function_returns
(
&
mut
self
ebb
:
Ebb
)
{
let
user_param_count
=
&
mut
self
.
func_ctx
.
ebbs
[
ebb
]
.
user_param_count
;
for
argtyp
in
&
self
.
func
.
signature
.
returns
{
*
user_param_count
+
=
1
;
self
.
func
.
dfg
.
append_ebb_param
(
ebb
argtyp
.
value_type
)
;
}
}
pub
fn
finalize
(
&
mut
self
)
{
debug_assert
!
(
self
.
func_ctx
.
ebbs
.
iter
(
)
.
all
(
|
(
ebb
ebb_data
)
|
ebb_data
.
pristine
|
|
self
.
func_ctx
.
ssa
.
is_sealed
(
ebb
)
)
"
all
blocks
should
be
sealed
before
dropping
a
FunctionBuilder
"
)
;
debug_assert
!
(
self
.
func_ctx
.
ebbs
.
values
(
)
.
all
(
|
ebb_data
|
ebb_data
.
pristine
|
|
ebb_data
.
filled
)
"
all
blocks
should
be
filled
before
dropping
a
FunctionBuilder
"
)
;
self
.
func_ctx
.
clear
(
)
;
self
.
srcloc
=
Default
:
:
default
(
)
;
self
.
position
=
Position
:
:
default
(
)
;
}
}
impl
<
'
a
>
FunctionBuilder
<
'
a
>
{
pub
fn
ebb_params
(
&
self
ebb
:
Ebb
)
-
>
&
[
Value
]
{
self
.
func
.
dfg
.
ebb_params
(
ebb
)
}
pub
fn
signature
(
&
self
sigref
:
SigRef
)
-
>
Option
<
&
Signature
>
{
self
.
func
.
dfg
.
signatures
.
get
(
sigref
)
}
pub
fn
append_ebb_param
(
&
mut
self
ebb
:
Ebb
ty
:
Type
)
-
>
Value
{
debug_assert
!
(
self
.
func_ctx
.
ebbs
[
ebb
]
.
pristine
)
;
debug_assert_eq
!
(
self
.
func_ctx
.
ebbs
[
ebb
]
.
user_param_count
self
.
func
.
dfg
.
num_ebb_params
(
ebb
)
)
;
self
.
func_ctx
.
ebbs
[
ebb
]
.
user_param_count
+
=
1
;
self
.
func
.
dfg
.
append_ebb_param
(
ebb
ty
)
}
pub
fn
inst_results
(
&
self
inst
:
Inst
)
-
>
&
[
Value
]
{
self
.
func
.
dfg
.
inst_results
(
inst
)
}
pub
fn
change_jump_destination
(
&
mut
self
inst
:
Inst
new_dest
:
Ebb
)
{
let
old_dest
=
self
.
func
.
dfg
[
inst
]
.
branch_destination_mut
(
)
.
expect
(
"
you
want
to
change
the
jump
destination
of
a
non
-
jump
instruction
"
)
;
let
pred
=
self
.
func_ctx
.
ssa
.
remove_ebb_predecessor
(
*
old_dest
inst
)
;
*
old_dest
=
new_dest
;
self
.
func_ctx
.
ssa
.
declare_ebb_predecessor
(
new_dest
pred
inst
)
;
}
pub
fn
is_unreachable
(
&
self
)
-
>
bool
{
let
is_entry
=
match
self
.
func
.
layout
.
entry_block
(
)
{
None
=
>
false
Some
(
entry
)
=
>
self
.
position
.
ebb
.
unwrap
(
)
=
=
entry
}
;
!
is_entry
&
&
self
.
func_ctx
.
ssa
.
is_sealed
(
self
.
position
.
ebb
.
unwrap
(
)
)
&
&
!
self
.
func_ctx
.
ssa
.
has_any_predecessors
(
self
.
position
.
ebb
.
unwrap
(
)
)
}
pub
fn
is_pristine
(
&
self
)
-
>
bool
{
self
.
func_ctx
.
ebbs
[
self
.
position
.
ebb
.
unwrap
(
)
]
.
pristine
}
pub
fn
is_filled
(
&
self
)
-
>
bool
{
self
.
func_ctx
.
ebbs
[
self
.
position
.
ebb
.
unwrap
(
)
]
.
filled
}
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
clippy
:
:
needless_lifetimes
)
)
]
pub
fn
display
<
'
b
I
:
Into
<
Option
<
&
'
b
TargetIsa
>
>
>
(
&
'
b
self
isa
:
I
)
-
>
DisplayFunction
{
self
.
func
.
display
(
isa
)
}
}
impl
<
'
a
>
FunctionBuilder
<
'
a
>
{
pub
fn
call_memcpy
(
&
mut
self
config
:
TargetFrontendConfig
dest
:
Value
src
:
Value
size
:
Value
)
{
let
pointer_type
=
config
.
pointer_type
(
)
;
let
signature
=
{
let
mut
s
=
Signature
:
:
new
(
config
.
default_call_conv
)
;
s
.
params
.
push
(
AbiParam
:
:
new
(
pointer_type
)
)
;
s
.
params
.
push
(
AbiParam
:
:
new
(
pointer_type
)
)
;
s
.
params
.
push
(
AbiParam
:
:
new
(
pointer_type
)
)
;
self
.
import_signature
(
s
)
}
;
let
libc_memcpy
=
self
.
import_function
(
ExtFuncData
{
name
:
ExternalName
:
:
LibCall
(
LibCall
:
:
Memcpy
)
signature
colocated
:
false
}
)
;
self
.
ins
(
)
.
call
(
libc_memcpy
&
[
dest
src
size
]
)
;
}
pub
fn
emit_small_memcpy
(
&
mut
self
config
:
TargetFrontendConfig
dest
:
Value
src
:
Value
size
:
u64
dest_align
:
u8
src_align
:
u8
)
{
const
THRESHOLD
:
u64
=
4
;
if
size
=
=
0
{
return
;
}
let
access_size
=
greatest_divisible_power_of_two
(
size
)
;
assert
!
(
access_size
.
is_power_of_two
(
)
"
size
is
not
a
power
of
two
"
)
;
assert
!
(
access_size
>
=
u64
:
:
from
(
:
:
core
:
:
cmp
:
:
min
(
src_align
dest_align
)
)
"
size
is
smaller
than
dest
and
src
'
s
alignment
value
.
"
)
;
let
(
access_size
int_type
)
=
if
access_size
<
=
8
{
(
access_size
Type
:
:
int
(
(
access_size
*
8
)
as
u16
)
.
unwrap
(
)
)
}
else
{
(
8
types
:
:
I64
)
}
;
let
load_and_store_amount
=
size
/
access_size
;
if
load_and_store_amount
>
THRESHOLD
{
let
size_value
=
self
.
ins
(
)
.
iconst
(
config
.
pointer_type
(
)
size
as
i64
)
;
self
.
call_memcpy
(
config
dest
src
size_value
)
;
return
;
}
let
mut
flags
=
MemFlags
:
:
new
(
)
;
flags
.
set_aligned
(
)
;
for
i
in
0
.
.
load_and_store_amount
{
let
offset
=
(
access_size
*
i
)
as
i32
;
let
value
=
self
.
ins
(
)
.
load
(
int_type
flags
src
offset
)
;
self
.
ins
(
)
.
store
(
flags
value
dest
offset
)
;
}
}
pub
fn
call_memset
(
&
mut
self
config
:
TargetFrontendConfig
buffer
:
Value
ch
:
Value
size
:
Value
)
{
let
pointer_type
=
config
.
pointer_type
(
)
;
let
signature
=
{
let
mut
s
=
Signature
:
:
new
(
config
.
default_call_conv
)
;
s
.
params
.
push
(
AbiParam
:
:
new
(
pointer_type
)
)
;
s
.
params
.
push
(
AbiParam
:
:
new
(
types
:
:
I32
)
)
;
s
.
params
.
push
(
AbiParam
:
:
new
(
pointer_type
)
)
;
self
.
import_signature
(
s
)
}
;
let
libc_memset
=
self
.
import_function
(
ExtFuncData
{
name
:
ExternalName
:
:
LibCall
(
LibCall
:
:
Memset
)
signature
colocated
:
false
}
)
;
let
ch
=
self
.
ins
(
)
.
uextend
(
types
:
:
I32
ch
)
;
self
.
ins
(
)
.
call
(
libc_memset
&
[
buffer
ch
size
]
)
;
}
pub
fn
emit_small_memset
(
&
mut
self
config
:
TargetFrontendConfig
buffer
:
Value
ch
:
u32
size
:
u64
buffer_align
:
u8
)
{
const
THRESHOLD
:
u64
=
4
;
if
size
=
=
0
{
return
;
}
let
access_size
=
greatest_divisible_power_of_two
(
size
)
;
assert
!
(
access_size
.
is_power_of_two
(
)
"
size
is
not
a
power
of
two
"
)
;
assert
!
(
access_size
>
=
u64
:
:
from
(
buffer_align
)
"
size
is
smaller
than
dest
and
src
'
s
alignment
value
.
"
)
;
let
(
access_size
int_type
)
=
if
access_size
<
=
8
{
(
access_size
Type
:
:
int
(
(
access_size
*
8
)
as
u16
)
.
unwrap
(
)
)
}
else
{
(
8
types
:
:
I64
)
}
;
let
load_and_store_amount
=
size
/
access_size
;
if
load_and_store_amount
>
THRESHOLD
{
let
ch
=
self
.
ins
(
)
.
iconst
(
types
:
:
I32
i64
:
:
from
(
ch
)
)
;
let
size
=
self
.
ins
(
)
.
iconst
(
config
.
pointer_type
(
)
size
as
i64
)
;
self
.
call_memset
(
config
buffer
ch
size
)
;
}
else
{
let
mut
flags
=
MemFlags
:
:
new
(
)
;
flags
.
set_aligned
(
)
;
let
ch
=
u64
:
:
from
(
ch
)
;
let
raw_value
=
if
int_type
=
=
types
:
:
I64
{
(
ch
<
<
32
)
|
(
ch
<
<
16
)
|
(
ch
<
<
8
)
|
ch
}
else
if
int_type
=
=
types
:
:
I32
{
(
ch
<
<
16
)
|
(
ch
<
<
8
)
|
ch
}
else
if
int_type
=
=
types
:
:
I16
{
(
ch
<
<
8
)
|
ch
}
else
{
assert_eq
!
(
int_type
types
:
:
I8
)
;
ch
}
;
let
value
=
self
.
ins
(
)
.
iconst
(
int_type
raw_value
as
i64
)
;
for
i
in
0
.
.
load_and_store_amount
{
let
offset
=
(
access_size
*
i
)
as
i32
;
self
.
ins
(
)
.
store
(
flags
value
buffer
offset
)
;
}
}
}
pub
fn
call_memmove
(
&
mut
self
config
:
TargetFrontendConfig
dest
:
Value
source
:
Value
size
:
Value
)
{
let
pointer_type
=
config
.
pointer_type
(
)
;
let
signature
=
{
let
mut
s
=
Signature
:
:
new
(
config
.
default_call_conv
)
;
s
.
params
.
push
(
AbiParam
:
:
new
(
pointer_type
)
)
;
s
.
params
.
push
(
AbiParam
:
:
new
(
pointer_type
)
)
;
s
.
params
.
push
(
AbiParam
:
:
new
(
pointer_type
)
)
;
self
.
import_signature
(
s
)
}
;
let
libc_memmove
=
self
.
import_function
(
ExtFuncData
{
name
:
ExternalName
:
:
LibCall
(
LibCall
:
:
Memmove
)
signature
colocated
:
false
}
)
;
self
.
ins
(
)
.
call
(
libc_memmove
&
[
dest
source
size
]
)
;
}
pub
fn
emit_small_memmove
(
&
mut
self
config
:
TargetFrontendConfig
dest
:
Value
src
:
Value
size
:
u64
dest_align
:
u8
src_align
:
u8
)
{
const
THRESHOLD
:
u64
=
4
;
let
access_size
=
greatest_divisible_power_of_two
(
size
)
;
assert
!
(
access_size
.
is_power_of_two
(
)
"
size
is
not
a
power
of
two
"
)
;
assert
!
(
access_size
>
=
u64
:
:
from
(
:
:
core
:
:
cmp
:
:
min
(
src_align
dest_align
)
)
"
size
is
smaller
than
dest
and
src
'
s
alignment
value
.
"
)
;
let
load_and_store_amount
=
size
/
access_size
;
if
load_and_store_amount
>
THRESHOLD
{
let
size_value
=
self
.
ins
(
)
.
iconst
(
config
.
pointer_type
(
)
size
as
i64
)
;
self
.
call_memmove
(
config
dest
src
size_value
)
;
return
;
}
let
mut
flags
=
MemFlags
:
:
new
(
)
;
flags
.
set_aligned
(
)
;
let
registers
:
Vec
<
_
>
=
(
0
.
.
load_and_store_amount
)
.
map
(
|
i
|
{
let
offset
=
(
access_size
*
i
)
as
i32
;
(
self
.
ins
(
)
.
load
(
config
.
pointer_type
(
)
flags
src
offset
)
offset
)
}
)
.
collect
(
)
;
for
(
value
offset
)
in
registers
{
self
.
ins
(
)
.
store
(
flags
value
dest
offset
)
;
}
}
}
fn
greatest_divisible_power_of_two
(
size
:
u64
)
-
>
u64
{
(
size
as
i64
&
-
(
size
as
i64
)
)
as
u64
}
impl
<
'
a
>
FunctionBuilder
<
'
a
>
{
fn
move_to_next_basic_block
(
&
mut
self
)
{
self
.
position
.
basic_block
=
PackedOption
:
:
from
(
self
.
func_ctx
.
ssa
.
declare_ebb_body_block
(
self
.
position
.
basic_block
.
unwrap
(
)
)
)
;
}
fn
fill_current_block
(
&
mut
self
)
{
self
.
func_ctx
.
ebbs
[
self
.
position
.
ebb
.
unwrap
(
)
]
.
filled
=
true
;
}
fn
declare_successor
(
&
mut
self
dest_ebb
:
Ebb
jump_inst
:
Inst
)
{
self
.
func_ctx
.
ssa
.
declare_ebb_predecessor
(
dest_ebb
self
.
position
.
basic_block
.
unwrap
(
)
jump_inst
)
;
}
fn
handle_ssa_side_effects
(
&
mut
self
side_effects
:
SideEffects
)
{
for
split_ebb
in
side_effects
.
split_ebbs_created
{
self
.
func_ctx
.
ebbs
[
split_ebb
]
.
filled
=
true
}
for
modified_ebb
in
side_effects
.
instructions_added_to_ebbs
{
self
.
func_ctx
.
ebbs
[
modified_ebb
]
.
pristine
=
false
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
greatest_divisible_power_of_two
;
use
crate
:
:
frontend
:
:
{
FunctionBuilder
FunctionBuilderContext
}
;
use
crate
:
:
Variable
;
use
cranelift_codegen
:
:
entity
:
:
EntityRef
;
use
cranelift_codegen
:
:
ir
:
:
types
:
:
*
;
use
cranelift_codegen
:
:
ir
:
:
{
AbiParam
ExternalName
Function
InstBuilder
Signature
}
;
use
cranelift_codegen
:
:
isa
:
:
CallConv
;
use
cranelift_codegen
:
:
settings
;
use
cranelift_codegen
:
:
verifier
:
:
verify_function
;
use
std
:
:
string
:
:
ToString
;
fn
sample_function
(
lazy_seal
:
bool
)
{
let
mut
sig
=
Signature
:
:
new
(
CallConv
:
:
SystemV
)
;
sig
.
returns
.
push
(
AbiParam
:
:
new
(
I32
)
)
;
sig
.
params
.
push
(
AbiParam
:
:
new
(
I32
)
)
;
let
mut
fn_ctx
=
FunctionBuilderContext
:
:
new
(
)
;
let
mut
func
=
Function
:
:
with_name_signature
(
ExternalName
:
:
testcase
(
"
sample
"
)
sig
)
;
{
let
mut
builder
=
FunctionBuilder
:
:
new
(
&
mut
func
&
mut
fn_ctx
)
;
let
block0
=
builder
.
create_ebb
(
)
;
let
block1
=
builder
.
create_ebb
(
)
;
let
block2
=
builder
.
create_ebb
(
)
;
let
x
=
Variable
:
:
new
(
0
)
;
let
y
=
Variable
:
:
new
(
1
)
;
let
z
=
Variable
:
:
new
(
2
)
;
builder
.
declare_var
(
x
I32
)
;
builder
.
declare_var
(
y
I32
)
;
builder
.
declare_var
(
z
I32
)
;
builder
.
append_ebb_params_for_function_params
(
block0
)
;
builder
.
switch_to_block
(
block0
)
;
if
!
lazy_seal
{
builder
.
seal_block
(
block0
)
;
}
{
let
tmp
=
builder
.
ebb_params
(
block0
)
[
0
]
;
builder
.
def_var
(
x
tmp
)
;
}
{
let
tmp
=
builder
.
ins
(
)
.
iconst
(
I32
2
)
;
builder
.
def_var
(
y
tmp
)
;
}
{
let
arg1
=
builder
.
use_var
(
x
)
;
let
arg2
=
builder
.
use_var
(
y
)
;
let
tmp
=
builder
.
ins
(
)
.
iadd
(
arg1
arg2
)
;
builder
.
def_var
(
z
tmp
)
;
}
builder
.
ins
(
)
.
jump
(
block1
&
[
]
)
;
builder
.
switch_to_block
(
block1
)
;
{
let
arg1
=
builder
.
use_var
(
y
)
;
let
arg2
=
builder
.
use_var
(
z
)
;
let
tmp
=
builder
.
ins
(
)
.
iadd
(
arg1
arg2
)
;
builder
.
def_var
(
z
tmp
)
;
}
{
let
arg
=
builder
.
use_var
(
y
)
;
builder
.
ins
(
)
.
brnz
(
arg
block2
&
[
]
)
;
}
{
let
arg1
=
builder
.
use_var
(
z
)
;
let
arg2
=
builder
.
use_var
(
x
)
;
let
tmp
=
builder
.
ins
(
)
.
isub
(
arg1
arg2
)
;
builder
.
def_var
(
z
tmp
)
;
}
{
let
arg
=
builder
.
use_var
(
y
)
;
builder
.
ins
(
)
.
return_
(
&
[
arg
]
)
;
}
builder
.
switch_to_block
(
block2
)
;
if
!
lazy_seal
{
builder
.
seal_block
(
block2
)
;
}
{
let
arg1
=
builder
.
use_var
(
y
)
;
let
arg2
=
builder
.
use_var
(
x
)
;
let
tmp
=
builder
.
ins
(
)
.
isub
(
arg1
arg2
)
;
builder
.
def_var
(
y
tmp
)
;
}
builder
.
ins
(
)
.
jump
(
block1
&
[
]
)
;
if
!
lazy_seal
{
builder
.
seal_block
(
block1
)
;
}
if
lazy_seal
{
builder
.
seal_all_blocks
(
)
;
}
builder
.
finalize
(
)
;
}
let
flags
=
settings
:
:
Flags
:
:
new
(
settings
:
:
builder
(
)
)
;
if
let
Err
(
errors
)
=
verify_function
(
&
func
&
flags
)
{
panic
!
(
"
{
}
\
n
{
}
"
func
.
display
(
None
)
errors
)
}
}
#
[
test
]
fn
sample
(
)
{
sample_function
(
false
)
}
#
[
test
]
fn
sample_with_lazy_seal
(
)
{
sample_function
(
true
)
}
#
[
test
]
fn
memcpy
(
)
{
use
core
:
:
str
:
:
FromStr
;
use
cranelift_codegen
:
:
{
isa
settings
}
;
let
shared_builder
=
settings
:
:
builder
(
)
;
let
shared_flags
=
settings
:
:
Flags
:
:
new
(
shared_builder
)
;
let
triple
=
:
:
target_lexicon
:
:
Triple
:
:
from_str
(
"
arm
"
)
.
expect
(
"
Couldn
'
t
create
arm
triple
"
)
;
let
target
=
isa
:
:
lookup
(
triple
)
.
ok
(
)
.
map
(
|
b
|
b
.
finish
(
shared_flags
)
)
.
expect
(
"
This
test
requires
arm
support
.
"
)
;
let
mut
sig
=
Signature
:
:
new
(
target
.
default_call_conv
(
)
)
;
sig
.
returns
.
push
(
AbiParam
:
:
new
(
I32
)
)
;
let
mut
fn_ctx
=
FunctionBuilderContext
:
:
new
(
)
;
let
mut
func
=
Function
:
:
with_name_signature
(
ExternalName
:
:
testcase
(
"
sample
"
)
sig
)
;
{
let
mut
builder
=
FunctionBuilder
:
:
new
(
&
mut
func
&
mut
fn_ctx
)
;
let
block0
=
builder
.
create_ebb
(
)
;
let
x
=
Variable
:
:
new
(
0
)
;
let
y
=
Variable
:
:
new
(
1
)
;
let
z
=
Variable
:
:
new
(
2
)
;
builder
.
declare_var
(
x
target
.
pointer_type
(
)
)
;
builder
.
declare_var
(
y
target
.
pointer_type
(
)
)
;
builder
.
declare_var
(
z
I32
)
;
builder
.
append_ebb_params_for_function_params
(
block0
)
;
builder
.
switch_to_block
(
block0
)
;
let
src
=
builder
.
use_var
(
x
)
;
let
dest
=
builder
.
use_var
(
y
)
;
let
size
=
builder
.
use_var
(
y
)
;
builder
.
call_memcpy
(
target
.
frontend_config
(
)
dest
src
size
)
;
builder
.
ins
(
)
.
return_
(
&
[
size
]
)
;
builder
.
seal_all_blocks
(
)
;
builder
.
finalize
(
)
;
}
assert_eq
!
(
func
.
display
(
None
)
.
to_string
(
)
"
function
%
sample
(
)
-
>
i32
system_v
{
sig0
=
(
i32
i32
i32
)
system_v
fn0
=
%
Memcpy
sig0
ebb0
:
v3
=
iconst
.
i32
0
v1
-
>
v3
v2
=
iconst
.
i32
0
v0
-
>
v2
call
fn0
(
v1
v0
v1
)
return
v1
}
"
)
;
}
#
[
test
]
fn
small_memcpy
(
)
{
use
core
:
:
str
:
:
FromStr
;
use
cranelift_codegen
:
:
{
isa
settings
}
;
let
shared_builder
=
settings
:
:
builder
(
)
;
let
shared_flags
=
settings
:
:
Flags
:
:
new
(
shared_builder
)
;
let
triple
=
:
:
target_lexicon
:
:
Triple
:
:
from_str
(
"
arm
"
)
.
expect
(
"
Couldn
'
t
create
arm
triple
"
)
;
let
target
=
isa
:
:
lookup
(
triple
)
.
ok
(
)
.
map
(
|
b
|
b
.
finish
(
shared_flags
)
)
.
expect
(
"
This
test
requires
arm
support
.
"
)
;
let
mut
sig
=
Signature
:
:
new
(
target
.
default_call_conv
(
)
)
;
sig
.
returns
.
push
(
AbiParam
:
:
new
(
I32
)
)
;
let
mut
fn_ctx
=
FunctionBuilderContext
:
:
new
(
)
;
let
mut
func
=
Function
:
:
with_name_signature
(
ExternalName
:
:
testcase
(
"
sample
"
)
sig
)
;
{
let
mut
builder
=
FunctionBuilder
:
:
new
(
&
mut
func
&
mut
fn_ctx
)
;
let
block0
=
builder
.
create_ebb
(
)
;
let
x
=
Variable
:
:
new
(
0
)
;
let
y
=
Variable
:
:
new
(
16
)
;
builder
.
declare_var
(
x
target
.
pointer_type
(
)
)
;
builder
.
declare_var
(
y
target
.
pointer_type
(
)
)
;
builder
.
append_ebb_params_for_function_params
(
block0
)
;
builder
.
switch_to_block
(
block0
)
;
let
src
=
builder
.
use_var
(
x
)
;
let
dest
=
builder
.
use_var
(
y
)
;
let
size
=
8
;
builder
.
emit_small_memcpy
(
target
.
frontend_config
(
)
dest
src
size
8
8
)
;
builder
.
ins
(
)
.
return_
(
&
[
dest
]
)
;
builder
.
seal_all_blocks
(
)
;
builder
.
finalize
(
)
;
}
assert_eq
!
(
func
.
display
(
None
)
.
to_string
(
)
"
function
%
sample
(
)
-
>
i32
system_v
{
ebb0
:
v4
=
iconst
.
i32
0
v1
-
>
v4
v3
=
iconst
.
i32
0
v0
-
>
v3
v2
=
load
.
i64
aligned
v0
store
aligned
v2
v1
return
v1
}
"
)
;
}
#
[
test
]
fn
test_greatest_divisible_power_of_two
(
)
{
assert_eq
!
(
64
greatest_divisible_power_of_two
(
64
)
)
;
assert_eq
!
(
16
greatest_divisible_power_of_two
(
48
)
)
;
assert_eq
!
(
8
greatest_divisible_power_of_two
(
24
)
)
;
assert_eq
!
(
1
greatest_divisible_power_of_two
(
25
)
)
;
}
}
