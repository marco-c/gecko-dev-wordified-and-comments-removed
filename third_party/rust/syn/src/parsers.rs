use
buffer
:
:
Cursor
;
use
parse_error
;
use
synom
:
:
PResult
;
#
[
macro_export
]
macro_rules
!
named
{
(
name
:
ident
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
fn
name
(
i
:
crate
:
:
buffer
:
:
Cursor
)
-
>
crate
:
:
synom
:
:
PResult
<
o
>
{
submac
!
(
i
(
args
)
*
)
}
}
;
(
pub
name
:
ident
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
pub
fn
name
(
i
:
crate
:
:
buffer
:
:
Cursor
)
-
>
crate
:
:
synom
:
:
PResult
<
o
>
{
submac
!
(
i
(
args
)
*
)
}
}
;
(
name
:
ident
(
(
params
:
tt
)
*
)
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
fn
name
(
i
:
crate
:
:
buffer
:
:
Cursor
(
params
)
*
)
-
>
crate
:
:
synom
:
:
PResult
<
o
>
{
submac
!
(
i
(
args
)
*
)
}
}
;
(
pub
name
:
ident
(
(
params
:
tt
)
*
)
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
pub
fn
name
(
i
:
crate
:
:
buffer
:
:
Cursor
(
params
)
*
)
-
>
crate
:
:
synom
:
:
PResult
<
o
>
{
submac
!
(
i
(
args
)
*
)
}
}
;
}
#
[
cfg
(
synom_verbose_trace
)
]
#
[
macro_export
]
macro_rules
!
call
{
(
i
:
expr
fun
:
expr
(
args
:
expr
)
*
)
=
>
{
{
#
[
allow
(
unused_imports
)
]
use
crate
:
:
synom
:
:
ext
:
:
*
;
let
i
=
i
;
eprintln
!
(
concat
!
(
"
-
>
"
stringify
!
(
fun
)
"
{
:
?
}
"
)
i
)
;
let
r
=
fun
(
i
(
args
)
*
)
;
match
r
{
Ok
(
(
_
i
)
)
=
>
eprintln
!
(
concat
!
(
"
OK
"
stringify
!
(
fun
)
"
{
:
?
}
"
)
i
)
Err
(
_
)
=
>
eprintln
!
(
concat
!
(
"
ERR
"
stringify
!
(
fun
)
"
{
:
?
}
"
)
i
)
}
r
}
}
;
}
#
[
cfg
(
not
(
synom_verbose_trace
)
)
]
#
[
macro_export
]
macro_rules
!
call
{
(
i
:
expr
fun
:
expr
(
args
:
expr
)
*
)
=
>
{
{
#
[
allow
(
unused_imports
)
]
use
crate
:
:
synom
:
:
ext
:
:
*
;
fun
(
i
(
args
)
*
)
}
}
;
}
#
[
macro_export
]
macro_rules
!
map
{
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
crate
:
:
parsers
:
:
invoke
(
g
o
)
i
)
)
}
}
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
{
map
!
(
i
call
!
(
f
)
g
)
}
;
}
#
[
doc
(
hidden
)
]
pub
fn
invoke
<
T
R
F
:
FnOnce
(
T
)
-
>
R
>
(
f
:
F
t
:
T
)
-
>
R
{
f
(
t
)
}
#
[
macro_export
]
macro_rules
!
not
{
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
_
)
=
>
crate
:
:
parse_error
(
)
:
:
std
:
:
result
:
:
Result
:
:
Err
(
_
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
(
)
i
)
)
}
}
;
}
#
[
macro_export
]
macro_rules
!
cond
{
(
i
:
expr
cond
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
if
cond
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
:
:
std
:
:
option
:
:
Option
:
:
Some
(
o
)
i
)
)
:
:
std
:
:
result
:
:
Result
:
:
Err
(
x
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
x
)
}
}
else
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
:
:
std
:
:
option
:
:
Option
:
:
None
i
)
)
}
}
;
(
i
:
expr
cond
:
expr
f
:
expr
)
=
>
{
cond
!
(
i
cond
call
!
(
f
)
)
}
;
}
#
[
macro_export
]
macro_rules
!
cond_reduce
{
(
i
:
expr
cond
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
if
cond
{
submac
!
(
i
(
args
)
*
)
}
else
{
crate
:
:
parse_error
(
)
}
}
;
(
i
:
expr
cond
:
expr
)
=
>
{
cond_reduce
!
(
i
cond
epsilon
!
(
)
)
}
;
(
i
:
expr
cond
:
expr
f
:
expr
)
=
>
{
cond_reduce
!
(
i
cond
call
!
(
f
)
)
}
;
}
#
[
macro_export
]
macro_rules
!
many0
{
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
{
let
ret
;
let
mut
res
=
:
:
std
:
:
vec
:
:
Vec
:
:
new
(
)
;
let
mut
input
=
i
;
loop
{
if
input
.
eof
(
)
{
ret
=
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
res
input
)
)
;
break
;
}
match
submac
!
(
input
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Err
(
_
)
=
>
{
ret
=
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
res
input
)
)
;
break
;
}
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
{
/
/
loop
trip
must
always
consume
(
otherwise
infinite
loops
)
if
i
=
=
input
{
ret
=
crate
:
:
parse_error
(
)
;
break
;
}
res
.
push
(
o
)
;
input
=
i
;
}
}
}
ret
}
}
;
(
i
:
expr
f
:
expr
)
=
>
{
crate
:
:
parsers
:
:
many0
(
i
f
)
}
;
}
#
[
doc
(
hidden
)
]
pub
fn
many0
<
T
>
(
mut
input
:
Cursor
f
:
fn
(
Cursor
)
-
>
PResult
<
T
>
)
-
>
PResult
<
Vec
<
T
>
>
{
let
mut
res
=
Vec
:
:
new
(
)
;
loop
{
if
input
.
eof
(
)
{
return
Ok
(
(
res
input
)
)
;
}
match
f
(
input
)
{
Err
(
_
)
=
>
{
return
Ok
(
(
res
input
)
)
;
}
Ok
(
(
o
i
)
)
=
>
{
if
i
=
=
input
{
return
parse_error
(
)
;
}
res
.
push
(
o
)
;
input
=
i
;
}
}
}
}
#
[
macro_export
]
macro_rules
!
switch
{
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
(
p
:
pat
=
>
subrule
:
ident
!
(
(
args2
:
tt
)
*
)
)
|
*
)
=
>
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
match
o
{
(
p
=
>
subrule
!
(
i
(
args2
)
*
)
)
*
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
value
{
(
i
:
expr
res
:
expr
)
=
>
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
res
i
)
)
}
;
}
#
[
macro_export
]
macro_rules
!
reject
{
(
i
:
expr
)
=
>
{
{
let
_
=
i
;
crate
:
:
parse_error
(
)
}
}
;
}
#
[
macro_export
]
macro_rules
!
tuple
{
(
i
:
expr
(
rest
:
tt
)
*
)
=
>
{
tuple_parser
!
(
i
(
)
(
rest
)
*
)
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
tuple_parser
{
(
i
:
expr
(
(
parsed
:
tt
)
*
)
e
:
ident
(
rest
:
tt
)
*
)
=
>
{
tuple_parser
!
(
i
(
(
parsed
)
*
)
call
!
(
e
)
(
rest
)
*
)
}
;
(
i
:
expr
(
)
submac
:
ident
!
(
(
args
:
tt
)
*
)
(
rest
:
tt
)
*
)
=
>
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
tuple_parser
!
(
i
(
o
)
(
rest
)
*
)
}
}
;
(
i
:
expr
(
(
parsed
:
tt
)
*
)
submac
:
ident
!
(
(
args
:
tt
)
*
)
(
rest
:
tt
)
*
)
=
>
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
tuple_parser
!
(
i
(
(
parsed
)
*
o
)
(
rest
)
*
)
}
}
;
(
i
:
expr
(
(
parsed
:
tt
)
*
)
e
:
ident
)
=
>
{
tuple_parser
!
(
i
(
(
parsed
)
*
)
call
!
(
e
)
)
}
;
(
i
:
expr
(
)
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
submac
!
(
i
(
args
)
*
)
}
;
(
i
:
expr
(
(
parsed
:
expr
)
*
)
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
(
(
parsed
)
*
o
)
i
)
)
}
}
;
(
i
:
expr
(
(
parsed
:
expr
)
*
)
)
=
>
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
(
(
parsed
)
*
)
i
)
)
}
;
}
#
[
macro_export
]
macro_rules
!
alt
{
(
i
:
expr
e
:
ident
|
(
rest
:
tt
)
*
)
=
>
{
alt
!
(
i
call
!
(
e
)
|
(
rest
)
*
)
}
;
(
i
:
expr
subrule
:
ident
!
(
(
args
:
tt
)
*
)
|
(
rest
:
tt
)
*
)
=
>
{
match
subrule
!
(
i
(
args
)
*
)
{
res
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
_
)
=
>
res
_
=
>
alt
!
(
i
(
rest
)
*
)
}
}
;
(
i
:
expr
subrule
:
ident
!
(
(
args
:
tt
)
*
)
=
>
{
gen
:
expr
}
|
(
rest
:
tt
)
+
)
=
>
{
match
subrule
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
crate
:
:
parsers
:
:
invoke
(
gen
o
)
i
)
)
:
:
std
:
:
result
:
:
Result
:
:
Err
(
_
)
=
>
alt
!
(
i
(
rest
)
*
)
}
}
;
(
i
:
expr
e
:
ident
=
>
{
gen
:
expr
}
|
(
rest
:
tt
)
*
)
=
>
{
alt
!
(
i
call
!
(
e
)
=
>
{
gen
}
|
(
rest
)
*
)
}
;
(
i
:
expr
e
:
ident
=
>
{
gen
:
expr
}
)
=
>
{
alt
!
(
i
call
!
(
e
)
=
>
{
gen
}
)
}
;
(
i
:
expr
subrule
:
ident
!
(
(
args
:
tt
)
*
)
=
>
{
gen
:
expr
}
)
=
>
{
match
subrule
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
crate
:
:
parsers
:
:
invoke
(
gen
o
)
i
)
)
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
}
}
;
(
i
:
expr
e
:
ident
)
=
>
{
alt
!
(
i
call
!
(
e
)
)
}
;
(
i
:
expr
subrule
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
subrule
!
(
i
(
args
)
*
)
}
;
}
#
[
macro_export
]
macro_rules
!
do_parse
{
(
i
:
expr
(
(
rest
:
expr
)
*
)
)
=
>
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
(
(
rest
)
*
)
i
)
)
}
;
(
i
:
expr
e
:
ident
>
>
(
rest
:
tt
)
*
)
=
>
{
do_parse
!
(
i
call
!
(
e
)
>
>
(
rest
)
*
)
}
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
>
>
(
rest
:
tt
)
*
)
=
>
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
_
i
)
)
=
>
do_parse
!
(
i
(
rest
)
*
)
}
}
;
(
i
:
expr
field
:
ident
:
e
:
ident
>
>
(
rest
:
tt
)
*
)
=
>
{
do_parse
!
(
i
field
:
call
!
(
e
)
>
>
(
rest
)
*
)
}
;
(
i
:
expr
field
:
ident
:
submac
:
ident
!
(
(
args
:
tt
)
*
)
>
>
(
rest
:
tt
)
*
)
=
>
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
{
let
field
=
o
;
do_parse
!
(
i
(
rest
)
*
)
}
}
}
;
(
i
:
expr
mut
field
:
ident
:
e
:
ident
>
>
(
rest
:
tt
)
*
)
=
>
{
do_parse
!
(
i
mut
field
:
call
!
(
e
)
>
>
(
rest
)
*
)
}
;
(
i
:
expr
mut
field
:
ident
:
submac
:
ident
!
(
(
args
:
tt
)
*
)
>
>
(
rest
:
tt
)
*
)
=
>
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
{
let
mut
field
=
o
;
do_parse
!
(
i
(
rest
)
*
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
input_end
{
(
i
:
expr
)
=
>
{
crate
:
:
parsers
:
:
input_end
(
i
)
}
;
}
#
[
doc
(
hidden
)
]
pub
fn
input_end
(
input
:
Cursor
)
-
>
PResult
<
'
static
(
)
>
{
if
input
.
eof
(
)
{
Ok
(
(
(
)
Cursor
:
:
empty
(
)
)
)
}
else
{
parse_error
(
)
}
}
#
[
macro_export
]
macro_rules
!
option
{
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
Some
(
o
)
i
)
)
:
:
std
:
:
result
:
:
Result
:
:
Err
(
_
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
None
i
)
)
}
}
;
(
i
:
expr
f
:
expr
)
=
>
{
option
!
(
i
call
!
(
f
)
)
;
}
;
}
#
[
macro_export
]
macro_rules
!
epsilon
{
(
i
:
expr
)
=
>
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
(
)
i
)
)
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
tap
{
(
i
:
expr
name
:
ident
:
submac
:
ident
!
(
(
args
:
tt
)
*
)
=
>
e
:
expr
)
=
>
{
match
submac
!
(
i
(
args
)
*
)
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
o
i
)
)
=
>
{
let
name
=
o
;
e
;
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
(
)
i
)
)
}
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
}
}
;
(
i
:
expr
name
:
ident
:
f
:
expr
=
>
e
:
expr
)
=
>
{
tap
!
(
i
name
:
call
!
(
f
)
=
>
e
)
;
}
;
}
#
[
macro_export
]
macro_rules
!
syn
{
(
i
:
expr
t
:
ty
)
=
>
{
<
t
as
crate
:
:
synom
:
:
Synom
>
:
:
parse
(
i
)
}
;
}
#
[
macro_export
]
macro_rules
!
custom_keyword
{
(
i
:
expr
keyword
:
ident
)
=
>
{
match
<
crate
:
:
Ident
as
crate
:
:
synom
:
:
Synom
>
:
:
parse
(
i
)
{
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
=
>
:
:
std
:
:
result
:
:
Result
:
:
Err
(
err
)
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
token
i
)
)
=
>
{
if
token
=
=
stringify
!
(
keyword
)
{
:
:
std
:
:
result
:
:
Result
:
:
Ok
(
(
token
i
)
)
}
else
{
crate
:
:
parse_error
(
)
}
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
parens
{
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
crate
:
:
token
:
:
Paren
:
:
parse
(
i
|
i
|
submac
!
(
i
(
args
)
*
)
)
}
;
(
i
:
expr
f
:
expr
)
=
>
{
parens
!
(
i
call
!
(
f
)
)
;
}
;
}
#
[
macro_export
]
macro_rules
!
brackets
{
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
crate
:
:
token
:
:
Bracket
:
:
parse
(
i
|
i
|
submac
!
(
i
(
args
)
*
)
)
}
;
(
i
:
expr
f
:
expr
)
=
>
{
brackets
!
(
i
call
!
(
f
)
)
;
}
;
}
#
[
macro_export
]
macro_rules
!
braces
{
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
crate
:
:
token
:
:
Brace
:
:
parse
(
i
|
i
|
submac
!
(
i
(
args
)
*
)
)
}
;
(
i
:
expr
f
:
expr
)
=
>
{
braces
!
(
i
call
!
(
f
)
)
;
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
grouped
{
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
crate
:
:
token
:
:
Group
:
:
parse
(
i
|
i
|
submac
!
(
i
(
args
)
*
)
)
}
;
(
i
:
expr
f
:
expr
)
=
>
{
grouped
!
(
i
call
!
(
f
)
)
;
}
;
}
