#
[
cfg
(
feature
=
"
proc
-
macro
"
)
]
use
proc_macro
;
use
proc_macro2
;
pub
use
error
:
:
{
PResult
ParseError
}
;
use
buffer
:
:
{
Cursor
TokenBuffer
}
;
pub
trait
Synom
:
Sized
{
fn
parse
(
input
:
Cursor
)
-
>
PResult
<
Self
>
;
fn
description
(
)
-
>
Option
<
&
'
static
str
>
{
None
}
}
impl
Synom
for
proc_macro2
:
:
TokenStream
{
fn
parse
(
input
:
Cursor
)
-
>
PResult
<
Self
>
{
Ok
(
(
input
.
token_stream
(
)
Cursor
:
:
empty
(
)
)
)
}
fn
description
(
)
-
>
Option
<
&
'
static
str
>
{
Some
(
"
arbitrary
token
stream
"
)
}
}
pub
trait
Parser
:
Sized
{
type
Output
;
fn
parse2
(
self
tokens
:
proc_macro2
:
:
TokenStream
)
-
>
Result
<
Self
:
:
Output
ParseError
>
;
#
[
cfg
(
feature
=
"
proc
-
macro
"
)
]
fn
parse
(
self
tokens
:
proc_macro
:
:
TokenStream
)
-
>
Result
<
Self
:
:
Output
ParseError
>
{
self
.
parse2
(
tokens
.
into
(
)
)
}
fn
parse_str
(
self
s
:
&
str
)
-
>
Result
<
Self
:
:
Output
ParseError
>
{
match
s
.
parse
(
)
{
Ok
(
tts
)
=
>
self
.
parse2
(
tts
)
Err
(
_
)
=
>
Err
(
ParseError
:
:
new
(
"
error
while
lexing
input
string
"
)
)
}
}
}
impl
<
F
T
>
Parser
for
F
where
F
:
FnOnce
(
Cursor
)
-
>
PResult
<
T
>
{
type
Output
=
T
;
fn
parse2
(
self
tokens
:
proc_macro2
:
:
TokenStream
)
-
>
Result
<
T
ParseError
>
{
let
buf
=
TokenBuffer
:
:
new2
(
tokens
)
;
let
(
t
rest
)
=
self
(
buf
.
begin
(
)
)
?
;
if
rest
.
eof
(
)
{
Ok
(
t
)
}
else
if
rest
=
=
buf
.
begin
(
)
{
Err
(
ParseError
:
:
new
(
"
failed
to
parse
anything
"
)
)
}
else
{
Err
(
ParseError
:
:
new
(
"
failed
to
parse
all
tokens
"
)
)
}
}
}
