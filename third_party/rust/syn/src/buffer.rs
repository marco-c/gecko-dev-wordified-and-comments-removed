#
[
cfg
(
all
(
not
(
all
(
target_arch
=
"
wasm32
"
any
(
target_os
=
"
unknown
"
target_os
=
"
wasi
"
)
)
)
feature
=
"
proc
-
macro
"
)
)
]
use
crate
:
:
proc_macro
as
pm
;
use
crate
:
:
Lifetime
;
use
proc_macro2
:
:
{
Delimiter
Group
Ident
Literal
Punct
Spacing
Span
TokenStream
TokenTree
}
;
use
std
:
:
hint
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
;
use
std
:
:
ptr
;
use
std
:
:
slice
;
enum
Entry
{
Group
(
Group
TokenBuffer
)
Ident
(
Ident
)
Punct
(
Punct
)
Literal
(
Literal
)
End
(
*
const
Entry
)
}
pub
struct
TokenBuffer
{
ptr
:
*
const
Entry
len
:
usize
}
impl
Drop
for
TokenBuffer
{
fn
drop
(
&
mut
self
)
{
unsafe
{
let
slice
=
slice
:
:
from_raw_parts_mut
(
self
.
ptr
as
*
mut
Entry
self
.
len
)
;
let
_
=
Box
:
:
from_raw
(
slice
)
;
}
}
}
impl
TokenBuffer
{
fn
inner_new
(
stream
:
TokenStream
up
:
*
const
Entry
)
-
>
TokenBuffer
{
let
iterator
=
stream
.
into_iter
(
)
;
let
mut
entries
=
Vec
:
:
with_capacity
(
iterator
.
size_hint
(
)
.
0
+
1
)
;
let
mut
next_index_after_last_group
=
0
;
for
tt
in
iterator
{
match
tt
{
TokenTree
:
:
Ident
(
ident
)
=
>
{
entries
.
push
(
Entry
:
:
Ident
(
ident
)
)
;
}
TokenTree
:
:
Punct
(
punct
)
=
>
{
entries
.
push
(
Entry
:
:
Punct
(
punct
)
)
;
}
TokenTree
:
:
Literal
(
literal
)
=
>
{
entries
.
push
(
Entry
:
:
Literal
(
literal
)
)
;
}
TokenTree
:
:
Group
(
group
)
=
>
{
let
group_up
=
ptr
:
:
null
:
:
<
u8
>
(
)
.
wrapping_add
(
next_index_after_last_group
)
as
*
const
Entry
;
let
inner
=
Self
:
:
inner_new
(
group
.
stream
(
)
group_up
)
;
entries
.
push
(
Entry
:
:
Group
(
group
inner
)
)
;
next_index_after_last_group
=
entries
.
len
(
)
;
}
}
}
entries
.
push
(
Entry
:
:
End
(
up
)
)
;
let
entries
=
entries
.
into_boxed_slice
(
)
;
let
len
=
entries
.
len
(
)
;
let
entries
=
Box
:
:
into_raw
(
entries
)
as
*
mut
Entry
;
while
let
Some
(
idx
)
=
next_index_after_last_group
.
checked_sub
(
1
)
{
let
group_up
=
unsafe
{
entries
.
add
(
next_index_after_last_group
)
}
;
let
token_buffer
=
match
unsafe
{
&
*
entries
.
add
(
idx
)
}
{
Entry
:
:
Group
(
_group
token_buffer
)
=
>
token_buffer
_
=
>
unsafe
{
hint
:
:
unreachable_unchecked
(
)
}
}
;
let
buffer_ptr
=
token_buffer
.
ptr
as
*
mut
Entry
;
let
last_entry
=
unsafe
{
&
mut
*
buffer_ptr
.
add
(
token_buffer
.
len
-
1
)
}
;
let
end_ptr_slot
=
match
last_entry
{
Entry
:
:
End
(
end_ptr_slot
)
=
>
end_ptr_slot
_
=
>
unsafe
{
hint
:
:
unreachable_unchecked
(
)
}
}
;
next_index_after_last_group
=
mem
:
:
replace
(
end_ptr_slot
group_up
)
as
usize
;
}
TokenBuffer
{
ptr
:
entries
len
}
}
#
[
cfg
(
all
(
not
(
all
(
target_arch
=
"
wasm32
"
any
(
target_os
=
"
unknown
"
target_os
=
"
wasi
"
)
)
)
feature
=
"
proc
-
macro
"
)
)
]
pub
fn
new
(
stream
:
pm
:
:
TokenStream
)
-
>
Self
{
Self
:
:
new2
(
stream
.
into
(
)
)
}
pub
fn
new2
(
stream
:
TokenStream
)
-
>
Self
{
Self
:
:
inner_new
(
stream
ptr
:
:
null
(
)
)
}
pub
fn
begin
(
&
self
)
-
>
Cursor
{
unsafe
{
Cursor
:
:
create
(
self
.
ptr
self
.
ptr
.
add
(
self
.
len
-
1
)
)
}
}
}
pub
struct
Cursor
<
'
a
>
{
ptr
:
*
const
Entry
scope
:
*
const
Entry
marker
:
PhantomData
<
&
'
a
Entry
>
}
impl
<
'
a
>
Cursor
<
'
a
>
{
pub
fn
empty
(
)
-
>
Self
{
struct
UnsafeSyncEntry
(
Entry
)
;
unsafe
impl
Sync
for
UnsafeSyncEntry
{
}
static
EMPTY_ENTRY
:
UnsafeSyncEntry
=
UnsafeSyncEntry
(
Entry
:
:
End
(
0
as
*
const
Entry
)
)
;
Cursor
{
ptr
:
&
EMPTY_ENTRY
.
0
scope
:
&
EMPTY_ENTRY
.
0
marker
:
PhantomData
}
}
unsafe
fn
create
(
mut
ptr
:
*
const
Entry
scope
:
*
const
Entry
)
-
>
Self
{
while
let
Entry
:
:
End
(
exit
)
=
*
ptr
{
if
ptr
=
=
scope
{
break
;
}
ptr
=
exit
;
}
Cursor
{
ptr
scope
marker
:
PhantomData
}
}
fn
entry
(
self
)
-
>
&
'
a
Entry
{
unsafe
{
&
*
self
.
ptr
}
}
unsafe
fn
bump
(
self
)
-
>
Cursor
<
'
a
>
{
Cursor
:
:
create
(
self
.
ptr
.
offset
(
1
)
self
.
scope
)
}
fn
ignore_none
(
&
mut
self
)
{
while
let
Entry
:
:
Group
(
group
buf
)
=
self
.
entry
(
)
{
if
group
.
delimiter
(
)
=
=
Delimiter
:
:
None
{
unsafe
{
*
self
=
Cursor
:
:
create
(
buf
.
ptr
self
.
scope
)
;
}
}
else
{
break
;
}
}
}
pub
fn
eof
(
self
)
-
>
bool
{
self
.
ptr
=
=
self
.
scope
}
pub
fn
group
(
mut
self
delim
:
Delimiter
)
-
>
Option
<
(
Cursor
<
'
a
>
Span
Cursor
<
'
a
>
)
>
{
if
delim
!
=
Delimiter
:
:
None
{
self
.
ignore_none
(
)
;
}
if
let
Entry
:
:
Group
(
group
buf
)
=
self
.
entry
(
)
{
if
group
.
delimiter
(
)
=
=
delim
{
return
Some
(
(
buf
.
begin
(
)
group
.
span
(
)
unsafe
{
self
.
bump
(
)
}
)
)
;
}
}
None
}
pub
fn
ident
(
mut
self
)
-
>
Option
<
(
Ident
Cursor
<
'
a
>
)
>
{
self
.
ignore_none
(
)
;
match
self
.
entry
(
)
{
Entry
:
:
Ident
(
ident
)
=
>
Some
(
(
ident
.
clone
(
)
unsafe
{
self
.
bump
(
)
}
)
)
_
=
>
None
}
}
pub
fn
punct
(
mut
self
)
-
>
Option
<
(
Punct
Cursor
<
'
a
>
)
>
{
self
.
ignore_none
(
)
;
match
self
.
entry
(
)
{
Entry
:
:
Punct
(
punct
)
if
punct
.
as_char
(
)
!
=
'
\
'
'
=
>
{
Some
(
(
punct
.
clone
(
)
unsafe
{
self
.
bump
(
)
}
)
)
}
_
=
>
None
}
}
pub
fn
literal
(
mut
self
)
-
>
Option
<
(
Literal
Cursor
<
'
a
>
)
>
{
self
.
ignore_none
(
)
;
match
self
.
entry
(
)
{
Entry
:
:
Literal
(
literal
)
=
>
Some
(
(
literal
.
clone
(
)
unsafe
{
self
.
bump
(
)
}
)
)
_
=
>
None
}
}
pub
fn
lifetime
(
mut
self
)
-
>
Option
<
(
Lifetime
Cursor
<
'
a
>
)
>
{
self
.
ignore_none
(
)
;
match
self
.
entry
(
)
{
Entry
:
:
Punct
(
punct
)
if
punct
.
as_char
(
)
=
=
'
\
'
'
&
&
punct
.
spacing
(
)
=
=
Spacing
:
:
Joint
=
>
{
let
next
=
unsafe
{
self
.
bump
(
)
}
;
match
next
.
ident
(
)
{
Some
(
(
ident
rest
)
)
=
>
{
let
lifetime
=
Lifetime
{
apostrophe
:
punct
.
span
(
)
ident
}
;
Some
(
(
lifetime
rest
)
)
}
None
=
>
None
}
}
_
=
>
None
}
}
pub
fn
token_stream
(
self
)
-
>
TokenStream
{
let
mut
tts
=
Vec
:
:
new
(
)
;
let
mut
cursor
=
self
;
while
let
Some
(
(
tt
rest
)
)
=
cursor
.
token_tree
(
)
{
tts
.
push
(
tt
)
;
cursor
=
rest
;
}
tts
.
into_iter
(
)
.
collect
(
)
}
pub
fn
token_tree
(
self
)
-
>
Option
<
(
TokenTree
Cursor
<
'
a
>
)
>
{
let
tree
=
match
self
.
entry
(
)
{
Entry
:
:
Group
(
group
_
)
=
>
group
.
clone
(
)
.
into
(
)
Entry
:
:
Literal
(
literal
)
=
>
literal
.
clone
(
)
.
into
(
)
Entry
:
:
Ident
(
ident
)
=
>
ident
.
clone
(
)
.
into
(
)
Entry
:
:
Punct
(
punct
)
=
>
punct
.
clone
(
)
.
into
(
)
Entry
:
:
End
(
.
.
)
=
>
return
None
}
;
Some
(
(
tree
unsafe
{
self
.
bump
(
)
}
)
)
}
pub
fn
span
(
self
)
-
>
Span
{
match
self
.
entry
(
)
{
Entry
:
:
Group
(
group
_
)
=
>
group
.
span
(
)
Entry
:
:
Literal
(
literal
)
=
>
literal
.
span
(
)
Entry
:
:
Ident
(
ident
)
=
>
ident
.
span
(
)
Entry
:
:
Punct
(
punct
)
=
>
punct
.
span
(
)
Entry
:
:
End
(
.
.
)
=
>
Span
:
:
call_site
(
)
}
}
pub
(
crate
)
fn
skip
(
self
)
-
>
Option
<
Cursor
<
'
a
>
>
{
match
self
.
entry
(
)
{
Entry
:
:
End
(
.
.
)
=
>
None
Entry
:
:
Punct
(
punct
)
if
punct
.
as_char
(
)
=
=
'
\
'
'
&
&
punct
.
spacing
(
)
=
=
Spacing
:
:
Joint
=
>
{
let
next
=
unsafe
{
self
.
bump
(
)
}
;
match
next
.
entry
(
)
{
Entry
:
:
Ident
(
_
)
=
>
Some
(
unsafe
{
next
.
bump
(
)
}
)
_
=
>
Some
(
next
)
}
}
_
=
>
Some
(
unsafe
{
self
.
bump
(
)
}
)
}
}
}
impl
<
'
a
>
Copy
for
Cursor
<
'
a
>
{
}
impl
<
'
a
>
Clone
for
Cursor
<
'
a
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
'
a
>
Eq
for
Cursor
<
'
a
>
{
}
impl
<
'
a
>
PartialEq
for
Cursor
<
'
a
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
let
Cursor
{
ptr
scope
marker
}
=
self
;
let
_
=
marker
;
*
ptr
=
=
other
.
ptr
&
&
*
scope
=
=
other
.
scope
}
}
pub
(
crate
)
fn
same_scope
(
a
:
Cursor
b
:
Cursor
)
-
>
bool
{
a
.
scope
=
=
b
.
scope
}
pub
(
crate
)
fn
open_span_of_group
(
cursor
:
Cursor
)
-
>
Span
{
match
cursor
.
entry
(
)
{
Entry
:
:
Group
(
group
_
)
=
>
group
.
span_open
(
)
_
=
>
cursor
.
span
(
)
}
}
pub
(
crate
)
fn
close_span_of_group
(
cursor
:
Cursor
)
-
>
Span
{
match
cursor
.
entry
(
)
{
Entry
:
:
Group
(
group
_
)
=
>
group
.
span_close
(
)
_
=
>
cursor
.
span
(
)
}
}
