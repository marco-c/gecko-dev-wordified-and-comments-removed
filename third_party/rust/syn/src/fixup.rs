use
crate
:
:
classify
;
use
crate
:
:
expr
:
:
Expr
;
use
crate
:
:
precedence
:
:
Precedence
;
pub
(
crate
)
struct
FixupContext
{
stmt
:
bool
leftmost_subexpression_in_stmt
:
bool
match_arm
:
bool
leftmost_subexpression_in_match_arm
:
bool
parenthesize_exterior_struct_lit
:
bool
}
impl
FixupContext
{
pub
const
NONE
:
Self
=
FixupContext
{
stmt
:
false
leftmost_subexpression_in_stmt
:
false
match_arm
:
false
leftmost_subexpression_in_match_arm
:
false
parenthesize_exterior_struct_lit
:
false
}
;
pub
fn
new_stmt
(
)
-
>
Self
{
FixupContext
{
stmt
:
true
.
.
FixupContext
:
:
NONE
}
}
pub
fn
new_match_arm
(
)
-
>
Self
{
FixupContext
{
match_arm
:
true
.
.
FixupContext
:
:
NONE
}
}
pub
fn
new_condition
(
)
-
>
Self
{
FixupContext
{
parenthesize_exterior_struct_lit
:
true
.
.
FixupContext
:
:
NONE
}
}
pub
fn
leftmost_subexpression
(
self
)
-
>
Self
{
FixupContext
{
stmt
:
false
leftmost_subexpression_in_stmt
:
self
.
stmt
|
|
self
.
leftmost_subexpression_in_stmt
match_arm
:
false
leftmost_subexpression_in_match_arm
:
self
.
match_arm
|
|
self
.
leftmost_subexpression_in_match_arm
.
.
self
}
}
pub
fn
leftmost_subexpression_with_dot
(
self
)
-
>
Self
{
FixupContext
{
stmt
:
self
.
stmt
|
|
self
.
leftmost_subexpression_in_stmt
leftmost_subexpression_in_stmt
:
false
match_arm
:
self
.
match_arm
|
|
self
.
leftmost_subexpression_in_match_arm
leftmost_subexpression_in_match_arm
:
false
.
.
self
}
}
pub
fn
subsequent_subexpression
(
self
)
-
>
Self
{
FixupContext
{
stmt
:
false
leftmost_subexpression_in_stmt
:
false
match_arm
:
false
leftmost_subexpression_in_match_arm
:
false
.
.
self
}
}
pub
fn
would_cause_statement_boundary
(
self
expr
:
&
Expr
)
-
>
bool
{
(
self
.
leftmost_subexpression_in_stmt
&
&
!
classify
:
:
requires_semi_to_be_stmt
(
expr
)
)
|
|
(
self
.
leftmost_subexpression_in_match_arm
&
&
!
classify
:
:
requires_comma_to_be_match_arm
(
expr
)
)
}
pub
fn
needs_group_as_let_scrutinee
(
self
expr
:
&
Expr
)
-
>
bool
{
self
.
parenthesize_exterior_struct_lit
&
&
classify
:
:
confusable_with_adjacent_block
(
expr
)
|
|
Precedence
:
:
of_rhs
(
expr
)
<
=
Precedence
:
:
And
}
}
impl
Copy
for
FixupContext
{
}
impl
Clone
for
FixupContext
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
