use
crate
:
:
classify
;
use
crate
:
:
expr
:
:
Expr
;
use
crate
:
:
precedence
:
:
Precedence
;
pub
(
crate
)
struct
FixupContext
{
#
[
cfg
(
feature
=
"
full
"
)
]
stmt
:
bool
#
[
cfg
(
feature
=
"
full
"
)
]
leftmost_subexpression_in_stmt
:
bool
#
[
cfg
(
feature
=
"
full
"
)
]
match_arm
:
bool
#
[
cfg
(
feature
=
"
full
"
)
]
leftmost_subexpression_in_match_arm
:
bool
#
[
cfg
(
feature
=
"
full
"
)
]
parenthesize_exterior_struct_lit
:
bool
#
[
cfg
(
feature
=
"
full
"
)
]
parenthesize_exterior_jump
:
bool
#
[
cfg
(
feature
=
"
full
"
)
]
next_operator_can_begin_expr
:
bool
next_operator_can_begin_generics
:
bool
}
impl
FixupContext
{
pub
const
NONE
:
Self
=
FixupContext
{
#
[
cfg
(
feature
=
"
full
"
)
]
stmt
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
leftmost_subexpression_in_stmt
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
match_arm
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
leftmost_subexpression_in_match_arm
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
parenthesize_exterior_struct_lit
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
parenthesize_exterior_jump
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
next_operator_can_begin_expr
:
false
next_operator_can_begin_generics
:
false
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
fn
new_stmt
(
)
-
>
Self
{
FixupContext
{
stmt
:
true
.
.
FixupContext
:
:
NONE
}
}
#
[
cfg
(
feature
=
"
full
"
)
]
pub
fn
new_match_arm
(
)
-
>
Self
{
FixupContext
{
match_arm
:
true
.
.
FixupContext
:
:
NONE
}
}
#
[
cfg
(
feature
=
"
full
"
)
]
pub
fn
new_condition
(
)
-
>
Self
{
FixupContext
{
parenthesize_exterior_struct_lit
:
true
.
.
FixupContext
:
:
NONE
}
}
pub
fn
leftmost_subexpression
(
self
)
-
>
Self
{
FixupContext
{
#
[
cfg
(
feature
=
"
full
"
)
]
stmt
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
leftmost_subexpression_in_stmt
:
self
.
stmt
|
|
self
.
leftmost_subexpression_in_stmt
#
[
cfg
(
feature
=
"
full
"
)
]
match_arm
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
leftmost_subexpression_in_match_arm
:
self
.
match_arm
|
|
self
.
leftmost_subexpression_in_match_arm
#
[
cfg
(
feature
=
"
full
"
)
]
parenthesize_exterior_jump
:
true
.
.
self
}
}
pub
fn
leftmost_subexpression_with_dot
(
self
)
-
>
Self
{
FixupContext
{
#
[
cfg
(
feature
=
"
full
"
)
]
stmt
:
self
.
stmt
|
|
self
.
leftmost_subexpression_in_stmt
#
[
cfg
(
feature
=
"
full
"
)
]
leftmost_subexpression_in_stmt
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
match_arm
:
self
.
match_arm
|
|
self
.
leftmost_subexpression_in_match_arm
#
[
cfg
(
feature
=
"
full
"
)
]
leftmost_subexpression_in_match_arm
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
parenthesize_exterior_jump
:
true
.
.
self
}
}
pub
fn
leftmost_subexpression_with_begin_operator
(
self
#
[
cfg
(
feature
=
"
full
"
)
]
next_operator_can_begin_expr
:
bool
next_operator_can_begin_generics
:
bool
)
-
>
Self
{
FixupContext
{
#
[
cfg
(
feature
=
"
full
"
)
]
next_operator_can_begin_expr
next_operator_can_begin_generics
.
.
self
.
leftmost_subexpression
(
)
}
}
pub
fn
subsequent_subexpression
(
self
)
-
>
Self
{
FixupContext
{
#
[
cfg
(
feature
=
"
full
"
)
]
stmt
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
leftmost_subexpression_in_stmt
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
match_arm
:
false
#
[
cfg
(
feature
=
"
full
"
)
]
leftmost_subexpression_in_match_arm
:
false
.
.
self
}
}
#
[
cfg
(
feature
=
"
full
"
)
]
pub
fn
would_cause_statement_boundary
(
self
expr
:
&
Expr
)
-
>
bool
{
(
self
.
leftmost_subexpression_in_stmt
&
&
!
classify
:
:
requires_semi_to_be_stmt
(
expr
)
)
|
|
(
(
self
.
stmt
|
|
self
.
leftmost_subexpression_in_stmt
)
&
&
matches
!
(
expr
Expr
:
:
Let
(
_
)
)
)
|
|
(
self
.
leftmost_subexpression_in_match_arm
&
&
!
classify
:
:
requires_comma_to_be_match_arm
(
expr
)
)
}
#
[
cfg
(
feature
=
"
full
"
)
]
pub
fn
needs_group_as_let_scrutinee
(
self
expr
:
&
Expr
)
-
>
bool
{
self
.
parenthesize_exterior_struct_lit
&
&
classify
:
:
confusable_with_adjacent_block
(
expr
)
|
|
self
.
trailing_precedence
(
expr
)
<
Precedence
:
:
Let
}
pub
fn
leading_precedence
(
self
expr
:
&
Expr
)
-
>
Precedence
{
#
[
cfg
(
feature
=
"
full
"
)
]
if
self
.
next_operator_can_begin_expr
{
if
let
Expr
:
:
Break
(
_
)
|
Expr
:
:
Return
(
_
)
|
Expr
:
:
Yield
(
_
)
=
expr
{
return
Precedence
:
:
Jump
;
}
}
self
.
precedence
(
expr
)
}
pub
fn
trailing_precedence
(
self
expr
:
&
Expr
)
-
>
Precedence
{
#
[
cfg
(
feature
=
"
full
"
)
]
if
!
self
.
parenthesize_exterior_jump
{
match
expr
{
Expr
:
:
Break
(
_
)
|
Expr
:
:
Closure
(
_
)
|
Expr
:
:
Let
(
_
)
|
Expr
:
:
Return
(
_
)
|
Expr
:
:
Yield
(
_
)
=
>
{
return
Precedence
:
:
Prefix
;
}
Expr
:
:
Range
(
e
)
if
e
.
start
.
is_none
(
)
=
>
return
Precedence
:
:
Prefix
_
=
>
{
}
}
}
self
.
precedence
(
expr
)
}
fn
precedence
(
self
expr
:
&
Expr
)
-
>
Precedence
{
if
self
.
next_operator_can_begin_generics
{
if
let
Expr
:
:
Cast
(
cast
)
=
expr
{
if
classify
:
:
trailing_unparameterized_path
(
&
cast
.
ty
)
{
return
Precedence
:
:
MIN
;
}
}
}
Precedence
:
:
of
(
expr
)
}
}
impl
Copy
for
FixupContext
{
}
impl
Clone
for
FixupContext
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
