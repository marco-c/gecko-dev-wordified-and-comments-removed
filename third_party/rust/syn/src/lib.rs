#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
syn
/
2
.
0
.
87
"
)
]
#
!
[
cfg_attr
(
docsrs
feature
(
doc_cfg
)
)
]
#
!
[
deny
(
unsafe_op_in_unsafe_fn
)
]
#
!
[
allow
(
non_camel_case_types
)
]
#
!
[
cfg_attr
(
not
(
check_cfg
)
allow
(
unexpected_cfgs
)
)
]
#
!
[
allow
(
clippy
:
:
bool_to_int_with_if
clippy
:
:
cast_lossless
clippy
:
:
cast_possible_truncation
clippy
:
:
cast_possible_wrap
clippy
:
:
cast_ptr_alignment
clippy
:
:
default_trait_access
clippy
:
:
derivable_impls
clippy
:
:
diverging_sub_expression
clippy
:
:
doc_markdown
clippy
:
:
enum_glob_use
clippy
:
:
expl_impl_clone_on_copy
clippy
:
:
explicit_auto_deref
clippy
:
:
if_not_else
clippy
:
:
inherent_to_string
clippy
:
:
into_iter_without_iter
clippy
:
:
items_after_statements
clippy
:
:
large_enum_variant
clippy
:
:
let_underscore_untyped
clippy
:
:
manual_assert
clippy
:
:
manual_let_else
clippy
:
:
manual_map
clippy
:
:
match_like_matches_macro
clippy
:
:
match_on_vec_items
clippy
:
:
match_same_arms
clippy
:
:
match_wildcard_for_single_variants
clippy
:
:
missing_errors_doc
clippy
:
:
missing_panics_doc
clippy
:
:
module_name_repetitions
clippy
:
:
must_use_candidate
clippy
:
:
needless_doctest_main
clippy
:
:
needless_lifetimes
clippy
:
:
needless_pass_by_value
clippy
:
:
needless_update
clippy
:
:
never_loop
clippy
:
:
range_plus_one
clippy
:
:
redundant_else
clippy
:
:
ref_option
clippy
:
:
return_self_not_must_use
clippy
:
:
similar_names
clippy
:
:
single_match_else
clippy
:
:
struct_excessive_bools
clippy
:
:
too_many_arguments
clippy
:
:
too_many_lines
clippy
:
:
trivially_copy_pass_by_ref
clippy
:
:
unconditional_recursion
clippy
:
:
uninhabited_references
clippy
:
:
uninlined_format_args
clippy
:
:
unnecessary_box_returns
clippy
:
:
unnecessary_unwrap
clippy
:
:
used_underscore_binding
clippy
:
:
wildcard_imports
)
]
extern
crate
self
as
syn
;
#
[
cfg
(
feature
=
"
proc
-
macro
"
)
]
extern
crate
proc_macro
;
#
[
macro_use
]
mod
macros
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
macro_use
]
mod
group
;
#
[
macro_use
]
pub
mod
token
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
attr
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
pub
use
crate
:
:
attr
:
:
{
AttrStyle
Attribute
Meta
MetaList
MetaNameValue
}
;
mod
bigint
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
mod
buffer
;
#
[
cfg
(
any
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
all
(
feature
=
"
printing
"
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
mod
classify
;
mod
custom_keyword
;
mod
custom_punctuation
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
data
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
pub
use
crate
:
:
data
:
:
{
Field
Fields
FieldsNamed
FieldsUnnamed
Variant
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
derive
;
#
[
cfg
(
feature
=
"
derive
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
derive
"
)
)
)
]
pub
use
crate
:
:
derive
:
:
{
Data
DataEnum
DataStruct
DataUnion
DeriveInput
}
;
mod
drops
;
mod
error
;
pub
use
crate
:
:
error
:
:
{
Error
Result
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
expr
;
#
[
cfg
(
feature
=
"
full
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
full
"
)
)
)
]
pub
use
crate
:
:
expr
:
:
{
Arm
Label
PointerMutability
RangeLimits
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
pub
use
crate
:
:
expr
:
:
{
Expr
ExprBinary
ExprCall
ExprCast
ExprField
ExprIndex
ExprLit
ExprMacro
ExprMethodCall
ExprParen
ExprPath
ExprReference
ExprStruct
ExprUnary
FieldValue
Index
Member
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
full
"
)
)
)
]
pub
use
crate
:
:
expr
:
:
{
ExprArray
ExprAssign
ExprAsync
ExprAwait
ExprBlock
ExprBreak
ExprClosure
ExprConst
ExprContinue
ExprForLoop
ExprGroup
ExprIf
ExprInfer
ExprLet
ExprLoop
ExprMatch
ExprRange
ExprRawAddr
ExprRepeat
ExprReturn
ExprTry
ExprTryBlock
ExprTuple
ExprUnsafe
ExprWhile
ExprYield
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
mod
ext
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
file
;
#
[
cfg
(
feature
=
"
full
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
full
"
)
)
)
]
pub
use
crate
:
:
file
:
:
File
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
mod
fixup
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
generics
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
pub
use
crate
:
:
generics
:
:
{
BoundLifetimes
ConstParam
GenericParam
Generics
LifetimeParam
PredicateLifetime
PredicateType
TraitBound
TraitBoundModifier
TypeParam
TypeParamBound
WhereClause
WherePredicate
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
full
"
)
)
)
]
pub
use
crate
:
:
generics
:
:
{
CapturedParam
PreciseCapture
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
)
)
]
pub
use
crate
:
:
generics
:
:
{
ImplGenerics
Turbofish
TypeGenerics
}
;
mod
ident
;
#
[
doc
(
inline
)
]
pub
use
crate
:
:
ident
:
:
Ident
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
item
;
#
[
cfg
(
feature
=
"
full
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
full
"
)
)
)
]
pub
use
crate
:
:
item
:
:
{
FnArg
ForeignItem
ForeignItemFn
ForeignItemMacro
ForeignItemStatic
ForeignItemType
ImplItem
ImplItemConst
ImplItemFn
ImplItemMacro
ImplItemType
ImplRestriction
Item
ItemConst
ItemEnum
ItemExternCrate
ItemFn
ItemForeignMod
ItemImpl
ItemMacro
ItemMod
ItemStatic
ItemStruct
ItemTrait
ItemTraitAlias
ItemType
ItemUnion
ItemUse
Receiver
Signature
StaticMutability
TraitItem
TraitItemConst
TraitItemFn
TraitItemMacro
TraitItemType
UseGlob
UseGroup
UseName
UsePath
UseRename
UseTree
Variadic
}
;
mod
lifetime
;
#
[
doc
(
inline
)
]
pub
use
crate
:
:
lifetime
:
:
Lifetime
;
mod
lit
;
#
[
doc
(
hidden
)
]
pub
use
crate
:
:
lit
:
:
StrStyle
;
#
[
doc
(
inline
)
]
pub
use
crate
:
:
lit
:
:
{
Lit
LitBool
LitByte
LitByteStr
LitCStr
LitChar
LitFloat
LitInt
LitStr
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
mod
lookahead
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
mac
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
pub
use
crate
:
:
mac
:
:
{
Macro
MacroDelimiter
}
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
parsing
"
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
)
]
pub
mod
meta
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
op
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
pub
use
crate
:
:
op
:
:
{
BinOp
UnOp
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
mod
parse
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
proc
-
macro
"
)
)
]
mod
parse_macro_input
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
]
mod
parse_quote
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
pat
;
#
[
cfg
(
feature
=
"
full
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
full
"
)
)
)
]
pub
use
crate
:
:
pat
:
:
{
FieldPat
Pat
PatConst
PatIdent
PatLit
PatMacro
PatOr
PatParen
PatPath
PatRange
PatReference
PatRest
PatSlice
PatStruct
PatTuple
PatTupleStruct
PatType
PatWild
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
path
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
pub
use
crate
:
:
path
:
:
{
AngleBracketedGenericArguments
AssocConst
AssocType
Constraint
GenericArgument
ParenthesizedGenericArguments
Path
PathArguments
PathSegment
QSelf
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
any
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
)
]
mod
precedence
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
mod
print
;
pub
mod
punctuated
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
restriction
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
pub
use
crate
:
:
restriction
:
:
{
FieldMutability
VisRestricted
Visibility
}
;
mod
sealed
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
derive
"
not
(
feature
=
"
full
"
)
)
)
]
mod
scan_expr
;
mod
span
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
)
)
]
pub
mod
spanned
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
stmt
;
#
[
cfg
(
feature
=
"
full
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
full
"
)
)
)
]
pub
use
crate
:
:
stmt
:
:
{
Block
Local
LocalInit
Stmt
StmtMacro
}
;
mod
thread
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
extra
-
traits
"
)
)
]
mod
tt
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
ty
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
pub
use
crate
:
:
ty
:
:
{
Abi
BareFnArg
BareVariadic
ReturnType
Type
TypeArray
TypeBareFn
TypeGroup
TypeImplTrait
TypeInfer
TypeMacro
TypeNever
TypeParen
TypePath
TypePtr
TypeReference
TypeSlice
TypeTraitObject
TypeTuple
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
parsing
"
)
)
]
mod
verbatim
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
)
]
mod
whitespace
;
#
[
rustfmt
:
:
skip
]
mod
gen
{
#
[
cfg
(
feature
=
"
fold
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
fold
"
)
)
)
]
#
[
rustfmt
:
:
skip
]
pub
mod
fold
;
#
[
cfg
(
feature
=
"
visit
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
visit
"
)
)
)
]
#
[
rustfmt
:
:
skip
]
pub
mod
visit
;
#
[
cfg
(
feature
=
"
visit
-
mut
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
visit
-
mut
"
)
)
)
]
#
[
rustfmt
:
:
skip
]
pub
mod
visit_mut
;
#
[
cfg
(
feature
=
"
clone
-
impls
"
)
]
#
[
rustfmt
:
:
skip
]
mod
clone
;
#
[
cfg
(
feature
=
"
extra
-
traits
"
)
]
#
[
rustfmt
:
:
skip
]
mod
debug
;
#
[
cfg
(
feature
=
"
extra
-
traits
"
)
]
#
[
rustfmt
:
:
skip
]
mod
eq
;
#
[
cfg
(
feature
=
"
extra
-
traits
"
)
]
#
[
rustfmt
:
:
skip
]
mod
hash
;
}
#
[
cfg
(
feature
=
"
fold
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
fold
"
)
)
)
]
pub
use
crate
:
:
gen
:
:
fold
;
#
[
cfg
(
feature
=
"
visit
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
visit
"
)
)
)
]
pub
use
crate
:
:
gen
:
:
visit
;
#
[
cfg
(
feature
=
"
visit
-
mut
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
visit
-
mut
"
)
)
)
]
pub
use
crate
:
:
gen
:
:
visit_mut
;
#
[
doc
(
hidden
)
]
#
[
path
=
"
export
.
rs
"
]
pub
mod
__private
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
proc
-
macro
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
proc
-
macro
"
)
)
)
)
]
pub
fn
parse
<
T
:
parse
:
:
Parse
>
(
tokens
:
proc_macro
:
:
TokenStream
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse
(
T
:
:
parse
tokens
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
fn
parse2
<
T
:
parse
:
:
Parse
>
(
tokens
:
proc_macro2
:
:
TokenStream
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse2
(
T
:
:
parse
tokens
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
fn
parse_str
<
T
:
parse
:
:
Parse
>
(
s
:
&
str
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse_str
(
T
:
:
parse
s
)
}
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
)
)
)
]
pub
fn
parse_file
(
mut
content
:
&
str
)
-
>
Result
<
File
>
{
const
BOM
:
&
str
=
"
\
u
{
feff
}
"
;
if
content
.
starts_with
(
BOM
)
{
content
=
&
content
[
BOM
.
len
(
)
.
.
]
;
}
let
mut
shebang
=
None
;
if
content
.
starts_with
(
"
#
!
"
)
{
let
rest
=
whitespace
:
:
skip
(
&
content
[
2
.
.
]
)
;
if
!
rest
.
starts_with
(
'
[
'
)
{
if
let
Some
(
idx
)
=
content
.
find
(
'
\
n
'
)
{
shebang
=
Some
(
content
[
.
.
idx
]
.
to_string
(
)
)
;
content
=
&
content
[
idx
.
.
]
;
}
else
{
shebang
=
Some
(
content
.
to_string
(
)
)
;
content
=
"
"
;
}
}
}
let
mut
file
:
File
=
parse_str
(
content
)
?
;
file
.
shebang
=
shebang
;
Ok
(
file
)
}
