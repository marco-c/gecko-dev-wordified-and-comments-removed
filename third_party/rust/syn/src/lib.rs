#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
syn
/
2
.
0
.
39
"
)
]
#
!
[
cfg_attr
(
doc_cfg
feature
(
doc_cfg
)
)
]
#
!
[
allow
(
non_camel_case_types
)
]
#
!
[
allow
(
clippy
:
:
bool_to_int_with_if
clippy
:
:
cast_lossless
clippy
:
:
cast_possible_truncation
clippy
:
:
cast_possible_wrap
clippy
:
:
cast_ptr_alignment
clippy
:
:
default_trait_access
clippy
:
:
derivable_impls
clippy
:
:
doc_markdown
clippy
:
:
expl_impl_clone_on_copy
clippy
:
:
explicit_auto_deref
clippy
:
:
if_not_else
clippy
:
:
inherent_to_string
clippy
:
:
into_iter_without_iter
clippy
:
:
items_after_statements
clippy
:
:
large_enum_variant
clippy
:
:
let_underscore_untyped
clippy
:
:
manual_assert
clippy
:
:
manual_let_else
clippy
:
:
match_like_matches_macro
clippy
:
:
match_on_vec_items
clippy
:
:
match_same_arms
clippy
:
:
match_wildcard_for_single_variants
clippy
:
:
missing_errors_doc
clippy
:
:
missing_panics_doc
clippy
:
:
module_name_repetitions
clippy
:
:
must_use_candidate
clippy
:
:
needless_doctest_main
clippy
:
:
needless_pass_by_value
clippy
:
:
never_loop
clippy
:
:
range_plus_one
clippy
:
:
redundant_else
clippy
:
:
return_self_not_must_use
clippy
:
:
similar_names
clippy
:
:
single_match_else
clippy
:
:
too_many_arguments
clippy
:
:
too_many_lines
clippy
:
:
trivially_copy_pass_by_ref
clippy
:
:
uninlined_format_args
clippy
:
:
unnecessary_box_returns
clippy
:
:
unnecessary_unwrap
clippy
:
:
used_underscore_binding
clippy
:
:
wildcard_imports
)
]
#
[
cfg
(
feature
=
"
proc
-
macro
"
)
]
extern
crate
proc_macro
;
#
[
macro_use
]
mod
macros
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
macro_use
]
mod
group
;
#
[
macro_use
]
pub
mod
token
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
attr
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
attr
:
:
{
AttrStyle
Attribute
Meta
MetaList
MetaNameValue
}
;
mod
bigint
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
mod
buffer
;
mod
custom_keyword
;
mod
custom_punctuation
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
data
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
data
:
:
{
Field
Fields
FieldsNamed
FieldsUnnamed
Variant
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
derive
;
#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
crate
:
:
derive
:
:
{
Data
DataEnum
DataStruct
DataUnion
DeriveInput
}
;
mod
drops
;
mod
error
;
pub
use
crate
:
:
error
:
:
{
Error
Result
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
expr
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
crate
:
:
expr
:
:
{
Arm
FieldValue
Label
RangeLimits
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
expr
:
:
{
Expr
ExprArray
ExprAssign
ExprAsync
ExprAwait
ExprBinary
ExprBlock
ExprBreak
ExprCall
ExprCast
ExprClosure
ExprConst
ExprContinue
ExprField
ExprForLoop
ExprGroup
ExprIf
ExprIndex
ExprInfer
ExprLet
ExprLit
ExprLoop
ExprMacro
ExprMatch
ExprMethodCall
ExprParen
ExprPath
ExprRange
ExprReference
ExprRepeat
ExprReturn
ExprStruct
ExprTry
ExprTryBlock
ExprTuple
ExprUnary
ExprUnsafe
ExprWhile
ExprYield
Index
Member
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
mod
ext
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
file
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
crate
:
:
file
:
:
File
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
generics
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
generics
:
:
{
BoundLifetimes
ConstParam
GenericParam
Generics
LifetimeParam
PredicateLifetime
PredicateType
TraitBound
TraitBoundModifier
TypeParam
TypeParamBound
WhereClause
WherePredicate
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
pub
use
crate
:
:
generics
:
:
{
ImplGenerics
Turbofish
TypeGenerics
}
;
mod
ident
;
#
[
doc
(
inline
)
]
pub
use
crate
:
:
ident
:
:
Ident
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
item
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
crate
:
:
item
:
:
{
FnArg
ForeignItem
ForeignItemFn
ForeignItemMacro
ForeignItemStatic
ForeignItemType
ImplItem
ImplItemConst
ImplItemFn
ImplItemMacro
ImplItemType
ImplRestriction
Item
ItemConst
ItemEnum
ItemExternCrate
ItemFn
ItemForeignMod
ItemImpl
ItemMacro
ItemMod
ItemStatic
ItemStruct
ItemTrait
ItemTraitAlias
ItemType
ItemUnion
ItemUse
Receiver
Signature
StaticMutability
TraitItem
TraitItemConst
TraitItemFn
TraitItemMacro
TraitItemType
UseGlob
UseGroup
UseName
UsePath
UseRename
UseTree
Variadic
}
;
mod
lifetime
;
#
[
doc
(
inline
)
]
pub
use
crate
:
:
lifetime
:
:
Lifetime
;
mod
lit
;
#
[
doc
(
inline
)
]
pub
use
crate
:
:
lit
:
:
{
Lit
LitBool
LitByte
LitByteStr
LitChar
LitFloat
LitInt
LitStr
StrStyle
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
mod
lookahead
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
mac
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
mac
:
:
{
Macro
MacroDelimiter
}
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
all
(
feature
=
"
parsing
"
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
)
]
pub
mod
meta
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
op
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
op
:
:
{
BinOp
UnOp
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
mod
parse
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
proc
-
macro
"
)
)
]
mod
parse_macro_input
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
]
mod
parse_quote
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
pat
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
crate
:
:
expr
:
:
{
ExprConst
as
PatConst
ExprLit
as
PatLit
ExprMacro
as
PatMacro
ExprPath
as
PatPath
ExprRange
as
PatRange
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
crate
:
:
pat
:
:
{
FieldPat
Pat
PatIdent
PatOr
PatParen
PatReference
PatRest
PatSlice
PatStruct
PatTuple
PatTupleStruct
PatType
PatWild
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
path
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
path
:
:
{
AngleBracketedGenericArguments
AssocConst
AssocType
Constraint
GenericArgument
ParenthesizedGenericArguments
Path
PathArguments
PathSegment
QSelf
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
mod
print
;
pub
mod
punctuated
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
restriction
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
restriction
:
:
{
FieldMutability
VisRestricted
Visibility
}
;
mod
sealed
;
mod
span
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
)
)
]
pub
mod
spanned
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
stmt
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
crate
:
:
stmt
:
:
{
Block
Local
LocalInit
Stmt
StmtMacro
}
;
mod
thread
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
extra
-
traits
"
)
)
]
mod
tt
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
ty
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
ty
:
:
{
Abi
BareFnArg
BareVariadic
ReturnType
Type
TypeArray
TypeBareFn
TypeGroup
TypeImplTrait
TypeInfer
TypeMacro
TypeNever
TypeParen
TypePath
TypePtr
TypeReference
TypeSlice
TypeTraitObject
TypeTuple
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
parsing
"
)
)
]
mod
verbatim
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
)
]
mod
whitespace
;
mod
gen
{
#
[
cfg
(
feature
=
"
fold
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
fold
"
)
)
)
]
#
[
rustfmt
:
:
skip
]
pub
mod
fold
;
#
[
cfg
(
feature
=
"
visit
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
visit
"
)
)
)
]
#
[
rustfmt
:
:
skip
]
pub
mod
visit
;
#
[
cfg
(
feature
=
"
visit
-
mut
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
visit
-
mut
"
)
)
)
]
#
[
rustfmt
:
:
skip
]
pub
mod
visit_mut
;
#
[
cfg
(
feature
=
"
clone
-
impls
"
)
]
#
[
rustfmt
:
:
skip
]
mod
clone
;
#
[
cfg
(
feature
=
"
extra
-
traits
"
)
]
#
[
rustfmt
:
:
skip
]
mod
debug
;
#
[
cfg
(
feature
=
"
extra
-
traits
"
)
]
#
[
rustfmt
:
:
skip
]
mod
eq
;
#
[
cfg
(
feature
=
"
extra
-
traits
"
)
]
#
[
rustfmt
:
:
skip
]
mod
hash
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
path
=
"
.
.
/
gen_helper
.
rs
"
]
mod
helper
;
}
#
[
cfg
(
any
(
feature
=
"
fold
"
feature
=
"
visit
"
feature
=
"
visit
-
mut
"
)
)
]
pub
use
crate
:
:
gen
:
:
*
;
#
[
doc
(
hidden
)
]
#
[
path
=
"
export
.
rs
"
]
pub
mod
__private
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
proc
-
macro
"
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
proc
-
macro
"
)
)
)
)
]
pub
fn
parse
<
T
:
parse
:
:
Parse
>
(
tokens
:
proc_macro
:
:
TokenStream
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse
(
T
:
:
parse
tokens
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
fn
parse2
<
T
:
parse
:
:
Parse
>
(
tokens
:
proc_macro2
:
:
TokenStream
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse2
(
T
:
:
parse
tokens
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
fn
parse_str
<
T
:
parse
:
:
Parse
>
(
s
:
&
str
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse_str
(
T
:
:
parse
s
)
}
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
)
)
)
]
pub
fn
parse_file
(
mut
content
:
&
str
)
-
>
Result
<
File
>
{
const
BOM
:
&
str
=
"
\
u
{
feff
}
"
;
if
content
.
starts_with
(
BOM
)
{
content
=
&
content
[
BOM
.
len
(
)
.
.
]
;
}
let
mut
shebang
=
None
;
if
content
.
starts_with
(
"
#
!
"
)
{
let
rest
=
whitespace
:
:
skip
(
&
content
[
2
.
.
]
)
;
if
!
rest
.
starts_with
(
'
[
'
)
{
if
let
Some
(
idx
)
=
content
.
find
(
'
\
n
'
)
{
shebang
=
Some
(
content
[
.
.
idx
]
.
to_string
(
)
)
;
content
=
&
content
[
idx
.
.
]
;
}
else
{
shebang
=
Some
(
content
.
to_string
(
)
)
;
content
=
"
"
;
}
}
}
let
mut
file
:
File
=
parse_str
(
content
)
?
;
file
.
shebang
=
shebang
;
Ok
(
file
)
}
