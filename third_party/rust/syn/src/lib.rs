#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
syn
/
0
.
15
.
30
"
)
]
#
!
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
renamed_and_removed_lints
)
)
]
#
!
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
deny
(
clippy
clippy_pedantic
)
)
]
#
!
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
block_in_if_condition_stmt
cognitive_complexity
const_static_lifetime
deprecated_cfg_attr
doc_markdown
eval_order_dependence
large_enum_variant
needless_pass_by_value
never_loop
redundant_field_names
too_many_arguments
)
)
]
#
!
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
cast_possible_truncation
cast_possible_wrap
empty_enum
if_not_else
items_after_statements
module_name_repetitions
shadow_unrelated
similar_names
single_match_else
unseparated_literal_suffix
use_self
used_underscore_binding
)
)
]
#
[
cfg
(
all
(
not
(
all
(
target_arch
=
"
wasm32
"
target_os
=
"
unknown
"
)
)
feature
=
"
proc
-
macro
"
)
)
]
extern
crate
proc_macro
;
extern
crate
proc_macro2
;
extern
crate
unicode_xid
;
#
[
cfg
(
feature
=
"
printing
"
)
]
extern
crate
quote
;
#
[
macro_use
]
mod
macros
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
doc
(
hidden
)
]
#
[
macro_use
]
pub
mod
group
;
#
[
macro_use
]
pub
mod
token
;
mod
ident
;
pub
use
ident
:
:
Ident
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
attr
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
attr
:
:
{
AttrStyle
Attribute
AttributeArgs
Meta
MetaList
MetaNameValue
NestedMeta
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
data
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
data
:
:
{
Field
Fields
FieldsNamed
FieldsUnnamed
Variant
VisCrate
VisPublic
VisRestricted
Visibility
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
expr
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
expr
:
:
{
Expr
ExprArray
ExprAssign
ExprAssignOp
ExprAsync
ExprBinary
ExprBlock
ExprBox
ExprBreak
ExprCall
ExprCast
ExprClosure
ExprContinue
ExprField
ExprForLoop
ExprGroup
ExprIf
ExprInPlace
ExprIndex
ExprLet
ExprLit
ExprLoop
ExprMacro
ExprMatch
ExprMethodCall
ExprParen
ExprPath
ExprRange
ExprReference
ExprRepeat
ExprReturn
ExprStruct
ExprTry
ExprTryBlock
ExprTuple
ExprType
ExprUnary
ExprUnsafe
ExprVerbatim
ExprWhile
ExprYield
Index
Member
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
expr
:
:
{
Arm
Block
FieldPat
FieldValue
GenericMethodArgument
Label
Local
MethodTurbofish
Pat
PatBox
PatIdent
PatLit
PatMacro
PatPath
PatRange
PatRef
PatSlice
PatStruct
PatTuple
PatTupleStruct
PatVerbatim
PatWild
RangeLimits
Stmt
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
generics
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
generics
:
:
{
BoundLifetimes
ConstParam
GenericParam
Generics
LifetimeDef
PredicateEq
PredicateLifetime
PredicateType
TraitBound
TraitBoundModifier
TypeParam
TypeParamBound
WhereClause
WherePredicate
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
pub
use
generics
:
:
{
ImplGenerics
Turbofish
TypeGenerics
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
item
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
item
:
:
{
ArgCaptured
ArgSelf
ArgSelfRef
FnArg
FnDecl
ForeignItem
ForeignItemFn
ForeignItemMacro
ForeignItemStatic
ForeignItemType
ForeignItemVerbatim
ImplItem
ImplItemConst
ImplItemExistential
ImplItemMacro
ImplItemMethod
ImplItemType
ImplItemVerbatim
Item
ItemConst
ItemEnum
ItemExistential
ItemExternCrate
ItemFn
ItemForeignMod
ItemImpl
ItemMacro
ItemMacro2
ItemMod
ItemStatic
ItemStruct
ItemTrait
ItemTraitAlias
ItemType
ItemUnion
ItemUse
ItemVerbatim
MethodSig
TraitItem
TraitItemConst
TraitItemMacro
TraitItemMethod
TraitItemType
TraitItemVerbatim
UseGlob
UseGroup
UseName
UsePath
UseRename
UseTree
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
file
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
file
:
:
File
;
mod
lifetime
;
pub
use
lifetime
:
:
Lifetime
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
lit
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
lit
:
:
{
FloatSuffix
IntSuffix
Lit
LitBool
LitByte
LitByteStr
LitChar
LitFloat
LitInt
LitStr
LitVerbatim
StrStyle
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
mac
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
mac
:
:
{
Macro
MacroDelimiter
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
derive
;
#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
derive
:
:
{
Data
DataEnum
DataStruct
DataUnion
DeriveInput
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
op
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
op
:
:
{
BinOp
UnOp
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
ty
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
ty
:
:
{
Abi
BareFnArg
BareFnArgName
ReturnType
Type
TypeArray
TypeBareFn
TypeGroup
TypeImplTrait
TypeInfer
TypeMacro
TypeNever
TypeParen
TypePath
TypePtr
TypeReference
TypeSlice
TypeTraitObject
TypeTuple
TypeVerbatim
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
path
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
path
:
:
{
AngleBracketedGenericArguments
Binding
Constraint
GenericArgument
ParenthesizedGenericArguments
Path
PathArguments
PathSegment
QSelf
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
mod
buffer
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
mod
ext
;
pub
mod
punctuated
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
extra
-
traits
"
)
)
]
mod
tt
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
doc
(
hidden
)
]
pub
mod
parse_quote
;
#
[
cfg
(
all
(
not
(
all
(
target_arch
=
"
wasm32
"
target_os
=
"
unknown
"
)
)
feature
=
"
parsing
"
feature
=
"
proc
-
macro
"
)
)
]
#
[
doc
(
hidden
)
]
pub
mod
parse_macro_input
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
]
pub
mod
spanned
;
mod
gen
{
#
[
cfg
(
feature
=
"
visit
"
)
]
pub
mod
visit
;
#
[
cfg
(
feature
=
"
visit
-
mut
"
)
]
pub
mod
visit_mut
;
#
[
cfg
(
feature
=
"
fold
"
)
]
pub
mod
fold
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
path
=
"
.
.
/
gen_helper
.
rs
"
]
mod
helper
;
}
pub
use
gen
:
:
*
;
#
[
doc
(
hidden
)
]
pub
mod
export
;
mod
keyword
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
mod
lookahead
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
mod
parse
;
mod
span
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
mod
print
;
mod
thread
;
#
[
cfg
(
any
(
feature
=
"
parsing
"
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
allow
(
non_camel_case_types
)
]
struct
private
;
mod
error
;
pub
use
error
:
:
{
Error
Result
}
;
#
[
cfg
(
all
(
not
(
all
(
target_arch
=
"
wasm32
"
target_os
=
"
unknown
"
)
)
feature
=
"
parsing
"
feature
=
"
proc
-
macro
"
)
)
]
pub
fn
parse
<
T
:
parse
:
:
Parse
>
(
tokens
:
proc_macro
:
:
TokenStream
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse
(
T
:
:
parse
tokens
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
fn
parse2
<
T
:
parse
:
:
Parse
>
(
tokens
:
proc_macro2
:
:
TokenStream
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse2
(
T
:
:
parse
tokens
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
fn
parse_str
<
T
:
parse
:
:
Parse
>
(
s
:
&
str
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse_str
(
T
:
:
parse
s
)
}
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
)
]
pub
fn
parse_file
(
mut
content
:
&
str
)
-
>
Result
<
File
>
{
const
BOM
:
&
'
static
str
=
"
\
u
{
feff
}
"
;
if
content
.
starts_with
(
BOM
)
{
content
=
&
content
[
BOM
.
len
(
)
.
.
]
;
}
let
mut
shebang
=
None
;
if
content
.
starts_with
(
"
#
!
"
)
&
&
!
content
.
starts_with
(
"
#
!
[
"
)
{
if
let
Some
(
idx
)
=
content
.
find
(
'
\
n
'
)
{
shebang
=
Some
(
content
[
.
.
idx
]
.
to_string
(
)
)
;
content
=
&
content
[
idx
.
.
]
;
}
else
{
shebang
=
Some
(
content
.
to_string
(
)
)
;
content
=
"
"
;
}
}
let
mut
file
:
File
=
parse_str
(
content
)
?
;
file
.
shebang
=
shebang
;
Ok
(
file
)
}
