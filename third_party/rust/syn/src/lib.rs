#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
syn
/
1
.
0
.
99
"
)
]
#
!
[
cfg_attr
(
doc_cfg
feature
(
doc_cfg
)
)
]
#
!
[
allow
(
non_camel_case_types
)
]
#
!
[
allow
(
clippy
:
:
cast_lossless
clippy
:
:
cast_possible_truncation
clippy
:
:
cast_ptr_alignment
clippy
:
:
default_trait_access
clippy
:
:
doc_markdown
clippy
:
:
expl_impl_clone_on_copy
clippy
:
:
explicit_auto_deref
clippy
:
:
if_not_else
clippy
:
:
inherent_to_string
clippy
:
:
large_enum_variant
clippy
:
:
let_underscore_drop
clippy
:
:
manual_assert
clippy
:
:
match_on_vec_items
clippy
:
:
match_same_arms
clippy
:
:
match_wildcard_for_single_variants
clippy
:
:
missing_errors_doc
clippy
:
:
missing_panics_doc
clippy
:
:
module_name_repetitions
clippy
:
:
must_use_candidate
clippy
:
:
needless_doctest_main
clippy
:
:
needless_pass_by_value
clippy
:
:
never_loop
clippy
:
:
redundant_else
clippy
:
:
return_self_not_must_use
clippy
:
:
similar_names
clippy
:
:
single_match_else
clippy
:
:
too_many_arguments
clippy
:
:
too_many_lines
clippy
:
:
trivially_copy_pass_by_ref
clippy
:
:
unnecessary_unwrap
clippy
:
:
used_underscore_binding
clippy
:
:
wildcard_imports
)
]
#
[
cfg
(
all
(
not
(
all
(
target_arch
=
"
wasm32
"
any
(
target_os
=
"
unknown
"
target_os
=
"
wasi
"
)
)
)
feature
=
"
proc
-
macro
"
)
)
]
extern
crate
proc_macro
;
extern
crate
proc_macro2
;
#
[
cfg
(
feature
=
"
printing
"
)
]
extern
crate
quote
;
#
[
macro_use
]
mod
macros
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
macro_use
]
mod
group
;
#
[
macro_use
]
pub
mod
token
;
mod
ident
;
pub
use
crate
:
:
ident
:
:
Ident
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
attr
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
attr
:
:
{
AttrStyle
Attribute
AttributeArgs
Meta
MetaList
MetaNameValue
NestedMeta
}
;
mod
bigint
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
data
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
data
:
:
{
Field
Fields
FieldsNamed
FieldsUnnamed
Variant
VisCrate
VisPublic
VisRestricted
Visibility
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
expr
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
crate
:
:
expr
:
:
{
Arm
FieldValue
GenericMethodArgument
Label
MethodTurbofish
RangeLimits
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
expr
:
:
{
Expr
ExprArray
ExprAssign
ExprAssignOp
ExprAsync
ExprAwait
ExprBinary
ExprBlock
ExprBox
ExprBreak
ExprCall
ExprCast
ExprClosure
ExprContinue
ExprField
ExprForLoop
ExprGroup
ExprIf
ExprIndex
ExprLet
ExprLit
ExprLoop
ExprMacro
ExprMatch
ExprMethodCall
ExprParen
ExprPath
ExprRange
ExprReference
ExprRepeat
ExprReturn
ExprStruct
ExprTry
ExprTryBlock
ExprTuple
ExprType
ExprUnary
ExprUnsafe
ExprWhile
ExprYield
Index
Member
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
generics
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
generics
:
:
{
BoundLifetimes
ConstParam
GenericParam
Generics
LifetimeDef
PredicateEq
PredicateLifetime
PredicateType
TraitBound
TraitBoundModifier
TypeParam
TypeParamBound
WhereClause
WherePredicate
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
pub
use
crate
:
:
generics
:
:
{
ImplGenerics
Turbofish
TypeGenerics
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
item
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
crate
:
:
item
:
:
{
FnArg
ForeignItem
ForeignItemFn
ForeignItemMacro
ForeignItemStatic
ForeignItemType
ImplItem
ImplItemConst
ImplItemMacro
ImplItemMethod
ImplItemType
Item
ItemConst
ItemEnum
ItemExternCrate
ItemFn
ItemForeignMod
ItemImpl
ItemMacro
ItemMacro2
ItemMod
ItemStatic
ItemStruct
ItemTrait
ItemTraitAlias
ItemType
ItemUnion
ItemUse
Receiver
Signature
TraitItem
TraitItemConst
TraitItemMacro
TraitItemMethod
TraitItemType
UseGlob
UseGroup
UseName
UsePath
UseRename
UseTree
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
file
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
crate
:
:
file
:
:
File
;
mod
lifetime
;
pub
use
crate
:
:
lifetime
:
:
Lifetime
;
mod
lit
;
pub
use
crate
:
:
lit
:
:
{
Lit
LitBool
LitByte
LitByteStr
LitChar
LitFloat
LitInt
LitStr
StrStyle
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
mac
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
mac
:
:
{
Macro
MacroDelimiter
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
derive
;
#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
crate
:
:
derive
:
:
{
Data
DataEnum
DataStruct
DataUnion
DeriveInput
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
op
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
op
:
:
{
BinOp
UnOp
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
stmt
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
crate
:
:
stmt
:
:
{
Block
Local
Stmt
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
ty
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
ty
:
:
{
Abi
BareFnArg
ReturnType
Type
TypeArray
TypeBareFn
TypeGroup
TypeImplTrait
TypeInfer
TypeMacro
TypeNever
TypeParen
TypePath
TypePtr
TypeReference
TypeSlice
TypeTraitObject
TypeTuple
Variadic
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
pat
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
crate
:
:
pat
:
:
{
FieldPat
Pat
PatBox
PatIdent
PatLit
PatMacro
PatOr
PatPath
PatRange
PatReference
PatRest
PatSlice
PatStruct
PatTuple
PatTupleStruct
PatType
PatWild
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
path
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
crate
:
:
path
:
:
{
AngleBracketedGenericArguments
Binding
Constraint
GenericArgument
ParenthesizedGenericArguments
Path
PathArguments
PathSegment
QSelf
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
mod
buffer
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
mod
ext
;
pub
mod
punctuated
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
extra
-
traits
"
)
)
]
mod
tt
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
doc
(
hidden
)
]
pub
mod
parse_quote
;
#
[
cfg
(
all
(
not
(
all
(
target_arch
=
"
wasm32
"
any
(
target_os
=
"
unknown
"
target_os
=
"
wasi
"
)
)
)
feature
=
"
parsing
"
feature
=
"
proc
-
macro
"
)
)
]
#
[
doc
(
hidden
)
]
pub
mod
parse_macro_input
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
)
)
]
pub
mod
spanned
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
)
]
mod
whitespace
;
mod
gen
{
#
[
cfg
(
feature
=
"
visit
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
visit
"
)
)
)
]
#
[
rustfmt
:
:
skip
]
pub
mod
visit
;
#
[
cfg
(
feature
=
"
visit
-
mut
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
visit
-
mut
"
)
)
)
]
#
[
rustfmt
:
:
skip
]
pub
mod
visit_mut
;
#
[
cfg
(
feature
=
"
fold
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
fold
"
)
)
)
]
#
[
rustfmt
:
:
skip
]
pub
mod
fold
;
#
[
cfg
(
feature
=
"
clone
-
impls
"
)
]
#
[
rustfmt
:
:
skip
]
mod
clone
;
#
[
cfg
(
feature
=
"
extra
-
traits
"
)
]
#
[
rustfmt
:
:
skip
]
mod
eq
;
#
[
cfg
(
feature
=
"
extra
-
traits
"
)
]
#
[
rustfmt
:
:
skip
]
mod
hash
;
#
[
cfg
(
feature
=
"
extra
-
traits
"
)
]
#
[
rustfmt
:
:
skip
]
mod
debug
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
path
=
"
.
.
/
gen_helper
.
rs
"
]
mod
helper
;
}
pub
use
crate
:
:
gen
:
:
*
;
#
[
doc
(
hidden
)
]
#
[
path
=
"
export
.
rs
"
]
pub
mod
__private
;
mod
custom_keyword
;
mod
custom_punctuation
;
mod
sealed
;
mod
span
;
mod
thread
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
mod
lookahead
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
mod
parse
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
reserved
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
parsing
"
)
)
]
mod
verbatim
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
mod
print
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
mod
rustdoc_workaround
{
pub
use
crate
:
:
parse
:
:
{
self
as
parse_module
}
;
}
mod
error
;
pub
use
crate
:
:
error
:
:
{
Error
Result
}
;
#
[
cfg
(
all
(
not
(
all
(
target_arch
=
"
wasm32
"
any
(
target_os
=
"
unknown
"
target_os
=
"
wasi
"
)
)
)
feature
=
"
parsing
"
feature
=
"
proc
-
macro
"
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
proc
-
macro
"
)
)
)
)
]
pub
fn
parse
<
T
:
parse
:
:
Parse
>
(
tokens
:
proc_macro
:
:
TokenStream
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse
(
T
:
:
parse
tokens
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
fn
parse2
<
T
:
parse
:
:
Parse
>
(
tokens
:
proc_macro2
:
:
TokenStream
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse2
(
T
:
:
parse
tokens
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
fn
parse_str
<
T
:
parse
:
:
Parse
>
(
s
:
&
str
)
-
>
Result
<
T
>
{
parse
:
:
Parser
:
:
parse_str
(
T
:
:
parse
s
)
}
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
)
)
)
]
pub
fn
parse_file
(
mut
content
:
&
str
)
-
>
Result
<
File
>
{
const
BOM
:
&
str
=
"
\
u
{
feff
}
"
;
if
content
.
starts_with
(
BOM
)
{
content
=
&
content
[
BOM
.
len
(
)
.
.
]
;
}
let
mut
shebang
=
None
;
if
content
.
starts_with
(
"
#
!
"
)
{
let
rest
=
whitespace
:
:
skip
(
&
content
[
2
.
.
]
)
;
if
!
rest
.
starts_with
(
'
[
'
)
{
if
let
Some
(
idx
)
=
content
.
find
(
'
\
n
'
)
{
shebang
=
Some
(
content
[
.
.
idx
]
.
to_string
(
)
)
;
content
=
&
content
[
idx
.
.
]
;
}
else
{
shebang
=
Some
(
content
.
to_string
(
)
)
;
content
=
"
"
;
}
}
}
let
mut
file
:
File
=
parse_str
(
content
)
?
;
file
.
shebang
=
shebang
;
Ok
(
file
)
}
