#
[
macro_export
]
macro_rules
!
parse_macro_input
{
(
tokenstream
:
ident
as
ty
:
ty
)
=
>
{
match
crate
:
:
parse_macro_input
:
:
parse
:
:
<
ty
>
(
tokenstream
)
{
crate
:
:
export
:
:
Ok
(
data
)
=
>
data
crate
:
:
export
:
:
Err
(
err
)
=
>
{
return
crate
:
:
export
:
:
TokenStream
:
:
from
(
err
.
to_compile_error
(
)
)
;
}
}
}
;
(
tokenstream
:
ident
)
=
>
{
crate
:
:
parse_macro_input
!
(
tokenstream
as
_
)
}
;
}
use
crate
:
:
parse
:
:
{
Parse
ParseStream
Parser
Result
}
;
use
proc_macro
:
:
TokenStream
;
#
[
doc
(
hidden
)
]
pub
fn
parse
<
T
:
ParseMacroInput
>
(
token_stream
:
TokenStream
)
-
>
Result
<
T
>
{
T
:
:
parse
.
parse
(
token_stream
)
}
#
[
doc
(
hidden
)
]
pub
trait
ParseMacroInput
:
Sized
{
fn
parse
(
input
:
ParseStream
)
-
>
Result
<
Self
>
;
}
impl
<
T
:
Parse
>
ParseMacroInput
for
T
{
fn
parse
(
input
:
ParseStream
)
-
>
Result
<
Self
>
{
<
T
as
Parse
>
:
:
parse
(
input
)
}
}
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
use
crate
:
:
AttributeArgs
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
impl
ParseMacroInput
for
AttributeArgs
{
fn
parse
(
input
:
ParseStream
)
-
>
Result
<
Self
>
{
let
mut
metas
=
Vec
:
:
new
(
)
;
loop
{
if
input
.
is_empty
(
)
{
break
;
}
let
value
=
input
.
parse
(
)
?
;
metas
.
push
(
value
)
;
if
input
.
is_empty
(
)
{
break
;
}
input
.
parse
:
:
<
Token
!
[
]
>
(
)
?
;
}
Ok
(
metas
)
}
}
