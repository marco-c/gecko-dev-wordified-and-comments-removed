use
super
:
:
*
;
use
crate
:
:
token
:
:
{
Brace
Bracket
Paren
}
;
use
proc_macro2
:
:
extra
:
:
DelimSpan
;
#
[
cfg
(
any
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
]
use
proc_macro2
:
:
Delimiter
;
use
proc_macro2
:
:
TokenStream
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
proc_macro2
:
:
TokenTree
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
crate
:
:
parse
:
:
{
Parse
ParseStream
Parser
Result
}
;
ast_struct
!
{
/
/
/
A
macro
invocation
:
println
!
(
"
{
}
"
mac
)
.
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
pub
struct
Macro
{
pub
path
:
Path
pub
bang_token
:
Token
!
[
!
]
pub
delimiter
:
MacroDelimiter
pub
tokens
:
TokenStream
}
}
ast_enum
!
{
/
/
/
A
grouping
token
that
surrounds
a
macro
body
:
m
!
(
.
.
.
)
or
m
!
{
.
.
.
}
or
m
!
[
.
.
.
]
.
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
)
)
]
pub
enum
MacroDelimiter
{
Paren
(
Paren
)
Brace
(
Brace
)
Bracket
(
Bracket
)
}
}
impl
MacroDelimiter
{
pub
fn
span
(
&
self
)
-
>
&
DelimSpan
{
match
self
{
MacroDelimiter
:
:
Paren
(
token
)
=
>
&
token
.
span
MacroDelimiter
:
:
Brace
(
token
)
=
>
&
token
.
span
MacroDelimiter
:
:
Bracket
(
token
)
=
>
&
token
.
span
}
}
}
impl
Macro
{
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
fn
parse_body
<
T
:
Parse
>
(
&
self
)
-
>
Result
<
T
>
{
self
.
parse_body_with
(
T
:
:
parse
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
pub
fn
parse_body_with
<
F
:
Parser
>
(
&
self
parser
:
F
)
-
>
Result
<
F
:
:
Output
>
{
let
scope
=
self
.
delimiter
.
span
(
)
.
close
(
)
;
crate
:
:
parse
:
:
parse_scoped
(
parser
scope
self
.
tokens
.
clone
(
)
)
}
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
(
crate
)
fn
parse_delimiter
(
input
:
ParseStream
)
-
>
Result
<
(
MacroDelimiter
TokenStream
)
>
{
input
.
step
(
|
cursor
|
{
if
let
Some
(
(
TokenTree
:
:
Group
(
g
)
rest
)
)
=
cursor
.
token_tree
(
)
{
let
span
=
g
.
delim_span
(
)
;
let
delimiter
=
match
g
.
delimiter
(
)
{
Delimiter
:
:
Parenthesis
=
>
MacroDelimiter
:
:
Paren
(
Paren
(
span
)
)
Delimiter
:
:
Brace
=
>
MacroDelimiter
:
:
Brace
(
Brace
(
span
)
)
Delimiter
:
:
Bracket
=
>
MacroDelimiter
:
:
Bracket
(
Bracket
(
span
)
)
Delimiter
:
:
None
=
>
{
return
Err
(
cursor
.
error
(
"
expected
delimiter
"
)
)
;
}
}
;
Ok
(
(
(
delimiter
g
.
stream
(
)
)
rest
)
)
}
else
{
Err
(
cursor
.
error
(
"
expected
delimiter
"
)
)
}
}
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
(
crate
)
mod
parsing
{
use
super
:
:
*
;
use
crate
:
:
parse
:
:
{
Parse
ParseStream
Result
}
;
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
parsing
"
)
)
)
]
impl
Parse
for
Macro
{
fn
parse
(
input
:
ParseStream
)
-
>
Result
<
Self
>
{
let
tokens
;
Ok
(
Macro
{
path
:
input
.
call
(
Path
:
:
parse_mod_style
)
?
bang_token
:
input
.
parse
(
)
?
delimiter
:
{
let
(
delimiter
content
)
=
parse_delimiter
(
input
)
?
;
tokens
=
content
;
delimiter
}
tokens
}
)
}
}
}
#
[
cfg
(
feature
=
"
printing
"
)
]
mod
printing
{
use
super
:
:
*
;
use
proc_macro2
:
:
TokenStream
;
use
quote
:
:
ToTokens
;
impl
MacroDelimiter
{
pub
(
crate
)
fn
surround
(
&
self
tokens
:
&
mut
TokenStream
inner
:
TokenStream
)
{
let
(
delim
span
)
=
match
self
{
MacroDelimiter
:
:
Paren
(
paren
)
=
>
(
Delimiter
:
:
Parenthesis
paren
.
span
)
MacroDelimiter
:
:
Brace
(
brace
)
=
>
(
Delimiter
:
:
Brace
brace
.
span
)
MacroDelimiter
:
:
Bracket
(
bracket
)
=
>
(
Delimiter
:
:
Bracket
bracket
.
span
)
}
;
token
:
:
printing
:
:
delim
(
delim
span
.
join
(
)
tokens
inner
)
;
}
}
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
printing
"
)
)
)
]
impl
ToTokens
for
Macro
{
fn
to_tokens
(
&
self
tokens
:
&
mut
TokenStream
)
{
self
.
path
.
to_tokens
(
tokens
)
;
self
.
bang_token
.
to_tokens
(
tokens
)
;
self
.
delimiter
.
surround
(
tokens
self
.
tokens
.
clone
(
)
)
;
}
}
}
