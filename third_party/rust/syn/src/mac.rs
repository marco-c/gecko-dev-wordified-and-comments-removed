use
super
:
:
*
;
use
crate
:
:
token
:
:
{
Brace
Bracket
Paren
}
;
use
proc_macro2
:
:
TokenStream
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
proc_macro2
:
:
{
Delimiter
Group
Span
TokenTree
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
crate
:
:
parse
:
:
{
Parse
ParseStream
Parser
Result
}
;
ast_struct
!
{
/
/
/
A
macro
invocation
:
println
!
(
"
{
}
"
mac
)
.
/
/
/
/
/
/
*
This
type
is
available
only
if
Syn
is
built
with
the
"
derive
"
or
"
full
"
/
/
/
feature
.
*
pub
struct
Macro
{
pub
path
:
Path
pub
bang_token
:
Token
!
[
!
]
pub
delimiter
:
MacroDelimiter
pub
tokens
:
TokenStream
}
}
ast_enum
!
{
/
/
/
A
grouping
token
that
surrounds
a
macro
body
:
m
!
(
.
.
.
)
or
m
!
{
.
.
.
}
or
m
!
[
.
.
.
]
.
/
/
/
/
/
/
*
This
type
is
available
only
if
Syn
is
built
with
the
"
derive
"
or
"
full
"
/
/
/
feature
.
*
pub
enum
MacroDelimiter
{
Paren
(
Paren
)
Brace
(
Brace
)
Bracket
(
Bracket
)
}
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
fn
delimiter_span_close
(
macro_delimiter
:
&
MacroDelimiter
)
-
>
Span
{
let
delimiter
=
match
macro_delimiter
{
MacroDelimiter
:
:
Paren
(
_
)
=
>
Delimiter
:
:
Parenthesis
MacroDelimiter
:
:
Brace
(
_
)
=
>
Delimiter
:
:
Brace
MacroDelimiter
:
:
Bracket
(
_
)
=
>
Delimiter
:
:
Bracket
}
;
let
mut
group
=
Group
:
:
new
(
delimiter
TokenStream
:
:
new
(
)
)
;
group
.
set_span
(
match
macro_delimiter
{
MacroDelimiter
:
:
Paren
(
token
)
=
>
token
.
span
MacroDelimiter
:
:
Brace
(
token
)
=
>
token
.
span
MacroDelimiter
:
:
Bracket
(
token
)
=
>
token
.
span
}
)
;
group
.
span_close
(
)
}
impl
Macro
{
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
fn
parse_body
<
T
:
Parse
>
(
&
self
)
-
>
Result
<
T
>
{
self
.
parse_body_with
(
T
:
:
parse
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
fn
parse_body_with
<
F
:
Parser
>
(
&
self
parser
:
F
)
-
>
Result
<
F
:
:
Output
>
{
let
scope
=
delimiter_span_close
(
&
self
.
delimiter
)
;
crate
:
:
parse
:
:
parse_scoped
(
parser
scope
self
.
tokens
.
clone
(
)
)
}
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
fn
parse_delimiter
(
input
:
ParseStream
)
-
>
Result
<
(
MacroDelimiter
TokenStream
)
>
{
input
.
step
(
|
cursor
|
{
if
let
Some
(
(
TokenTree
:
:
Group
(
g
)
rest
)
)
=
cursor
.
token_tree
(
)
{
let
span
=
g
.
span
(
)
;
let
delimiter
=
match
g
.
delimiter
(
)
{
Delimiter
:
:
Parenthesis
=
>
MacroDelimiter
:
:
Paren
(
Paren
(
span
)
)
Delimiter
:
:
Brace
=
>
MacroDelimiter
:
:
Brace
(
Brace
(
span
)
)
Delimiter
:
:
Bracket
=
>
MacroDelimiter
:
:
Bracket
(
Bracket
(
span
)
)
Delimiter
:
:
None
=
>
{
return
Err
(
cursor
.
error
(
"
expected
delimiter
"
)
)
;
}
}
;
Ok
(
(
(
delimiter
g
.
stream
(
)
)
rest
)
)
}
else
{
Err
(
cursor
.
error
(
"
expected
delimiter
"
)
)
}
}
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
mod
parsing
{
use
super
:
:
*
;
use
crate
:
:
parse
:
:
{
Parse
ParseStream
Result
}
;
impl
Parse
for
Macro
{
fn
parse
(
input
:
ParseStream
)
-
>
Result
<
Self
>
{
let
tokens
;
Ok
(
Macro
{
path
:
input
.
call
(
Path
:
:
parse_mod_style
)
?
bang_token
:
input
.
parse
(
)
?
delimiter
:
{
let
(
delimiter
content
)
=
parse_delimiter
(
input
)
?
;
tokens
=
content
;
delimiter
}
tokens
}
)
}
}
}
#
[
cfg
(
feature
=
"
printing
"
)
]
mod
printing
{
use
super
:
:
*
;
use
proc_macro2
:
:
TokenStream
;
use
quote
:
:
ToTokens
;
impl
ToTokens
for
Macro
{
fn
to_tokens
(
&
self
tokens
:
&
mut
TokenStream
)
{
self
.
path
.
to_tokens
(
tokens
)
;
self
.
bang_token
.
to_tokens
(
tokens
)
;
match
&
self
.
delimiter
{
MacroDelimiter
:
:
Paren
(
paren
)
=
>
{
paren
.
surround
(
tokens
|
tokens
|
self
.
tokens
.
to_tokens
(
tokens
)
)
;
}
MacroDelimiter
:
:
Brace
(
brace
)
=
>
{
brace
.
surround
(
tokens
|
tokens
|
self
.
tokens
.
to_tokens
(
tokens
)
)
;
}
MacroDelimiter
:
:
Bracket
(
bracket
)
=
>
{
bracket
.
surround
(
tokens
|
tokens
|
self
.
tokens
.
to_tokens
(
tokens
)
)
;
}
}
}
}
}
