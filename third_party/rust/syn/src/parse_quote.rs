#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
parse_quote
{
(
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
parse_quote
:
:
parse
(
crate
:
:
export
:
:
From
:
:
from
(
crate
:
:
export
:
:
quote
:
:
quote
!
(
(
tt
)
*
)
)
)
}
;
}
use
crate
:
:
parse
:
:
{
Parse
ParseStream
Parser
Result
}
;
use
proc_macro2
:
:
TokenStream
;
#
[
doc
(
hidden
)
]
pub
fn
parse
<
T
:
ParseQuote
>
(
token_stream
:
TokenStream
)
-
>
T
{
let
parser
=
T
:
:
parse
;
match
parser
.
parse2
(
token_stream
)
{
Ok
(
t
)
=
>
t
Err
(
err
)
=
>
panic
!
(
"
{
}
"
err
)
}
}
#
[
doc
(
hidden
)
]
pub
trait
ParseQuote
:
Sized
{
fn
parse
(
input
:
ParseStream
)
-
>
Result
<
Self
>
;
}
impl
<
T
:
Parse
>
ParseQuote
for
T
{
fn
parse
(
input
:
ParseStream
)
-
>
Result
<
Self
>
{
<
T
as
Parse
>
:
:
parse
(
input
)
}
}
use
crate
:
:
punctuated
:
:
Punctuated
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
use
crate
:
:
{
attr
Attribute
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
impl
ParseQuote
for
Attribute
{
fn
parse
(
input
:
ParseStream
)
-
>
Result
<
Self
>
{
if
input
.
peek
(
Token
!
[
#
]
)
&
&
input
.
peek2
(
Token
!
[
!
]
)
{
attr
:
:
parsing
:
:
single_parse_inner
(
input
)
}
else
{
attr
:
:
parsing
:
:
single_parse_outer
(
input
)
}
}
}
impl
<
T
:
Parse
P
:
Parse
>
ParseQuote
for
Punctuated
<
T
P
>
{
fn
parse
(
input
:
ParseStream
)
-
>
Result
<
Self
>
{
Self
:
:
parse_terminated
(
input
)
}
}
