use
crate
:
:
error
:
:
*
;
use
lazy_static
:
:
lazy_static
;
use
rusqlite
:
:
Connection
;
use
sql_support
:
:
ConnExt
;
pub
(
super
)
const
VERSION
:
i64
=
2
;
pub
const
COMMON_COLS
:
&
str
=
"
guid
secFields
origin
httpRealm
formActionOrigin
usernameField
passwordField
timeCreated
timeLastUsed
timePasswordChanged
timesUsed
"
;
const
COMMON_SQL
:
&
str
=
"
id
INTEGER
PRIMARY
KEY
AUTOINCREMENT
origin
TEXT
NOT
NULL
-
-
Exactly
one
of
httpRealm
or
formActionOrigin
should
be
set
httpRealm
TEXT
formActionOrigin
TEXT
usernameField
TEXT
passwordField
TEXT
timesUsed
INTEGER
NOT
NULL
DEFAULT
0
timeCreated
INTEGER
NOT
NULL
timeLastUsed
INTEGER
timePasswordChanged
INTEGER
NOT
NULL
secFields
TEXT
guid
TEXT
NOT
NULL
UNIQUE
"
;
lazy_static
!
{
static
ref
CREATE_LOCAL_TABLE_SQL
:
String
=
format
!
(
"
CREATE
TABLE
IF
NOT
EXISTS
loginsL
(
{
common_sql
}
-
-
Milliseconds
or
NULL
if
never
modified
locally
.
local_modified
INTEGER
is_deleted
TINYINT
NOT
NULL
DEFAULT
0
sync_status
TINYINT
NOT
NULL
DEFAULT
0
)
"
common_sql
=
COMMON_SQL
)
;
static
ref
CREATE_MIRROR_TABLE_SQL
:
String
=
format
!
(
"
CREATE
TABLE
IF
NOT
EXISTS
loginsM
(
{
common_sql
}
-
-
Milliseconds
(
a
sync15
:
:
ServerTimestamp
multiplied
by
-
-
1000
and
truncated
)
server_modified
INTEGER
NOT
NULL
is_overridden
TINYINT
NOT
NULL
DEFAULT
0
-
-
fields
on
incoming
records
we
don
'
t
know
about
and
roundtrip
.
-
-
a
serde_json
:
:
Value
:
:
Object
as
an
encrypted
string
.
enc_unknown_fields
TEXT
)
"
common_sql
=
COMMON_SQL
)
;
static
ref
SET_VERSION_SQL
:
String
=
format
!
(
"
PRAGMA
user_version
=
{
version
}
"
version
=
VERSION
)
;
}
const
CREATE_META_TABLE_SQL
:
&
str
=
"
CREATE
TABLE
IF
NOT
EXISTS
loginsSyncMeta
(
key
TEXT
PRIMARY
KEY
value
NOT
NULL
)
"
;
const
CREATE_OVERRIDE_ORIGIN_INDEX_SQL
:
&
str
=
"
CREATE
INDEX
IF
NOT
EXISTS
idx_loginsM_is_overridden_origin
ON
loginsM
(
is_overridden
origin
)
"
;
const
CREATE_DELETED_ORIGIN_INDEX_SQL
:
&
str
=
"
CREATE
INDEX
IF
NOT
EXISTS
idx_loginsL_is_deleted_origin
ON
loginsL
(
is_deleted
origin
)
"
;
pub
(
crate
)
static
LAST_SYNC_META_KEY
:
&
str
=
"
last_sync_time
"
;
pub
(
crate
)
static
GLOBAL_STATE_META_KEY
:
&
str
=
"
global_state_v2
"
;
pub
(
crate
)
static
GLOBAL_SYNCID_META_KEY
:
&
str
=
"
global_sync_id
"
;
pub
(
crate
)
static
COLLECTION_SYNCID_META_KEY
:
&
str
=
"
passwords_sync_id
"
;
pub
(
crate
)
static
CHECKPOINT_KEY
:
&
str
=
"
checkpoint
"
;
pub
(
crate
)
fn
init
(
db
:
&
Connection
)
-
>
Result
<
(
)
>
{
let
user_version
=
db
.
conn_ext_query_one
:
:
<
i64
>
(
"
PRAGMA
user_version
"
)
?
;
warn
!
(
"
user_version
:
{
}
"
user_version
)
;
if
user_version
=
=
0
{
return
create
(
db
)
;
}
if
user_version
!
=
VERSION
{
if
user_version
<
VERSION
{
upgrade
(
db
user_version
)
?
;
}
else
{
warn
!
(
"
Loaded
future
schema
version
{
}
(
we
only
understand
version
{
}
)
.
\
Optimistically
"
user_version
VERSION
)
}
}
Ok
(
(
)
)
}
#
[
allow
(
clippy
:
:
unnecessary_wraps
)
]
fn
upgrade
(
db
:
&
Connection
from
:
i64
)
-
>
Result
<
(
)
>
{
debug
!
(
"
Upgrading
schema
from
{
}
to
{
}
"
from
VERSION
)
;
if
from
=
=
VERSION
{
return
Ok
(
(
)
)
;
}
assert_ne
!
(
from
0
"
Upgrading
from
user_version
=
0
should
already
be
handled
(
in
init
)
"
)
;
if
from
=
=
1
{
db
.
execute_batch
(
"
ALTER
TABLE
loginsM
ADD
enc_unknown_fields
TEXT
;
"
)
?
;
}
db
.
execute_batch
(
&
SET_VERSION_SQL
)
?
;
Ok
(
(
)
)
}
pub
(
crate
)
fn
create
(
db
:
&
Connection
)
-
>
Result
<
(
)
>
{
debug
!
(
"
Creating
schema
"
)
;
db
.
execute_all
(
&
[
&
*
CREATE_LOCAL_TABLE_SQL
&
*
CREATE_MIRROR_TABLE_SQL
CREATE_OVERRIDE_ORIGIN_INDEX_SQL
CREATE_DELETED_ORIGIN_INDEX_SQL
CREATE_META_TABLE_SQL
&
*
SET_VERSION_SQL
]
)
?
;
Ok
(
(
)
)
}
#
[
cfg
(
not
(
feature
=
"
keydb
"
)
)
]
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
encryption
:
:
test_utils
:
:
TEST_ENCDEC
;
use
crate
:
:
LoginDb
;
use
nss
:
:
ensure_initialized
;
use
rusqlite
:
:
Connection
;
#
[
test
]
fn
test_create_schema
(
)
{
ensure_initialized
(
)
;
let
db
=
LoginDb
:
:
open_in_memory
(
)
;
let
version
=
db
.
conn_ext_query_one
:
:
<
i64
>
(
"
PRAGMA
user_version
"
)
.
unwrap
(
)
;
assert_eq
!
(
version
VERSION
)
;
}
#
[
test
]
fn
test_upgrade_v1
(
)
{
ensure_initialized
(
)
;
let
connection
=
Connection
:
:
open_in_memory
(
)
.
unwrap
(
)
;
connection
.
execute_batch
(
"
CREATE
TABLE
IF
NOT
EXISTS
loginsM
(
-
-
this
was
common_sql
as
at
v1
id
INTEGER
PRIMARY
KEY
AUTOINCREMENT
origin
TEXT
NOT
NULL
httpRealm
TEXT
formActionOrigin
TEXT
usernameField
TEXT
passwordField
TEXT
timesUsed
INTEGER
NOT
NULL
DEFAULT
0
timeCreated
INTEGER
NOT
NULL
timeLastUsed
INTEGER
timePasswordChanged
INTEGER
NOT
NULL
secFields
TEXT
guid
TEXT
NOT
NULL
UNIQUE
server_modified
INTEGER
NOT
NULL
is_overridden
TINYINT
NOT
NULL
DEFAULT
0
-
-
note
enc_unknown_fields
missing
)
;
"
)
.
unwrap
(
)
;
create
(
&
connection
)
.
unwrap
(
)
;
connection
.
execute_batch
(
"
PRAGMA
user_version
=
1
;
"
)
.
unwrap
(
)
;
let
db
=
LoginDb
:
:
with_connection
(
connection
TEST_ENCDEC
.
clone
(
)
)
.
unwrap
(
)
;
let
version
=
db
.
conn_ext_query_one
:
:
<
i64
>
(
"
PRAGMA
user_version
"
)
.
unwrap
(
)
;
assert_eq
!
(
version
VERSION
)
;
db
.
execute_batch
(
"
SELECT
enc_unknown_fields
FROM
loginsM
"
)
.
unwrap
(
)
;
}
}
