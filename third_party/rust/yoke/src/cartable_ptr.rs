use
crate
:
:
CloneableCart
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
boxed
:
:
Box
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
rc
:
:
Rc
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
sync
:
:
Arc
;
#
[
cfg
(
test
)
]
use
core
:
:
cell
:
:
Cell
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
ptr
:
:
NonNull
;
use
stable_deref_trait
:
:
StableDeref
;
#
[
inline
]
fn
sentinel_for
<
T
>
(
)
-
>
NonNull
<
T
>
{
static
SENTINEL
:
&
u8
=
&
0x1a
;
unsafe
{
NonNull
:
:
new_unchecked
(
SENTINEL
as
*
const
u8
as
*
mut
T
)
}
}
#
[
cfg
(
test
)
]
thread_local
!
{
static
DROP_INVOCATIONS
:
Cell
<
usize
>
=
const
{
Cell
:
:
new
(
0
)
}
;
}
mod
private
{
pub
trait
Sealed
{
}
}
use
private
:
:
Sealed
;
pub
unsafe
trait
CartablePointerLike
:
StableDeref
+
Sealed
{
#
[
doc
(
hidden
)
]
type
Raw
;
#
[
doc
(
hidden
)
]
fn
into_raw
(
self
)
-
>
NonNull
<
Self
:
:
Raw
>
;
#
[
doc
(
hidden
)
]
unsafe
fn
drop_raw
(
pointer
:
NonNull
<
Self
:
:
Raw
>
)
;
}
pub
unsafe
trait
CloneableCartablePointerLike
:
CartablePointerLike
{
#
[
doc
(
hidden
)
]
unsafe
fn
addref_raw
(
pointer
:
NonNull
<
Self
:
:
Raw
>
)
;
}
impl
<
'
a
T
>
Sealed
for
&
'
a
T
{
}
unsafe
impl
<
'
a
T
>
CartablePointerLike
for
&
'
a
T
{
type
Raw
=
T
;
#
[
inline
]
fn
into_raw
(
self
)
-
>
NonNull
<
T
>
{
self
.
into
(
)
}
#
[
inline
]
unsafe
fn
drop_raw
(
_pointer
:
NonNull
<
T
>
)
{
}
}
unsafe
impl
<
'
a
T
>
CloneableCartablePointerLike
for
&
'
a
T
{
#
[
inline
]
unsafe
fn
addref_raw
(
_pointer
:
NonNull
<
T
>
)
{
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
T
>
Sealed
for
Box
<
T
>
{
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
unsafe
impl
<
T
>
CartablePointerLike
for
Box
<
T
>
{
type
Raw
=
T
;
#
[
inline
]
fn
into_raw
(
self
)
-
>
NonNull
<
T
>
{
unsafe
{
NonNull
:
:
new_unchecked
(
Box
:
:
into_raw
(
self
)
)
}
}
#
[
inline
]
unsafe
fn
drop_raw
(
pointer
:
NonNull
<
T
>
)
{
let
_box
=
Box
:
:
from_raw
(
pointer
.
as_ptr
(
)
)
;
#
[
cfg
(
test
)
]
DROP_INVOCATIONS
.
with
(
|
x
|
x
.
set
(
x
.
get
(
)
+
1
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
T
>
Sealed
for
Rc
<
T
>
{
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
unsafe
impl
<
T
>
CartablePointerLike
for
Rc
<
T
>
{
type
Raw
=
T
;
#
[
inline
]
fn
into_raw
(
self
)
-
>
NonNull
<
T
>
{
unsafe
{
NonNull
:
:
new_unchecked
(
Rc
:
:
into_raw
(
self
)
as
*
mut
T
)
}
}
#
[
inline
]
unsafe
fn
drop_raw
(
pointer
:
NonNull
<
T
>
)
{
let
_rc
=
Rc
:
:
from_raw
(
pointer
.
as_ptr
(
)
)
;
#
[
cfg
(
test
)
]
if
Rc
:
:
strong_count
(
&
_rc
)
=
=
1
{
DROP_INVOCATIONS
.
with
(
|
x
|
x
.
set
(
x
.
get
(
)
+
1
)
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
unsafe
impl
<
T
>
CloneableCartablePointerLike
for
Rc
<
T
>
{
#
[
inline
]
unsafe
fn
addref_raw
(
pointer
:
NonNull
<
T
>
)
{
Rc
:
:
increment_strong_count
(
pointer
.
as_ptr
(
)
)
;
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
T
>
Sealed
for
Arc
<
T
>
{
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
unsafe
impl
<
T
>
CartablePointerLike
for
Arc
<
T
>
{
type
Raw
=
T
;
#
[
inline
]
fn
into_raw
(
self
)
-
>
NonNull
<
T
>
{
unsafe
{
NonNull
:
:
new_unchecked
(
Arc
:
:
into_raw
(
self
)
as
*
mut
T
)
}
}
#
[
inline
]
unsafe
fn
drop_raw
(
pointer
:
NonNull
<
T
>
)
{
let
_arc
=
Arc
:
:
from_raw
(
pointer
.
as_ptr
(
)
)
;
#
[
cfg
(
test
)
]
if
Arc
:
:
strong_count
(
&
_arc
)
=
=
1
{
DROP_INVOCATIONS
.
with
(
|
x
|
x
.
set
(
x
.
get
(
)
+
1
)
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
unsafe
impl
<
T
>
CloneableCartablePointerLike
for
Arc
<
T
>
{
#
[
inline
]
unsafe
fn
addref_raw
(
pointer
:
NonNull
<
T
>
)
{
Arc
:
:
increment_strong_count
(
pointer
.
as_ptr
(
)
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
CartableOptionPointer
<
C
>
where
C
:
CartablePointerLike
{
inner
:
NonNull
<
C
:
:
Raw
>
_cartable
:
PhantomData
<
C
>
}
impl
<
C
>
CartableOptionPointer
<
C
>
where
C
:
CartablePointerLike
{
#
[
inline
]
pub
(
crate
)
fn
none
(
)
-
>
Self
{
Self
{
inner
:
sentinel_for
:
:
<
C
:
:
Raw
>
(
)
_cartable
:
PhantomData
}
}
#
[
inline
]
pub
(
crate
)
fn
from_cartable
(
cartable
:
C
)
-
>
Self
{
Self
{
inner
:
cartable
.
into_raw
(
)
_cartable
:
PhantomData
}
}
#
[
inline
]
pub
fn
is_none
(
&
self
)
-
>
bool
{
self
.
inner
=
=
sentinel_for
:
:
<
C
:
:
Raw
>
(
)
}
}
impl
<
C
>
Drop
for
CartableOptionPointer
<
C
>
where
C
:
CartablePointerLike
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
let
ptr
=
self
.
inner
;
if
ptr
!
=
sentinel_for
:
:
<
C
:
:
Raw
>
(
)
{
self
.
inner
=
sentinel_for
:
:
<
C
:
:
Raw
>
(
)
;
unsafe
{
C
:
:
drop_raw
(
ptr
)
}
}
}
}
impl
<
C
>
Clone
for
CartableOptionPointer
<
C
>
where
C
:
CloneableCartablePointerLike
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
let
ptr
=
self
.
inner
;
if
ptr
!
=
sentinel_for
:
:
<
C
:
:
Raw
>
(
)
{
unsafe
{
C
:
:
addref_raw
(
ptr
)
}
}
Self
{
inner
:
self
.
inner
_cartable
:
PhantomData
}
}
}
unsafe
impl
<
C
>
CloneableCart
for
CartableOptionPointer
<
C
>
where
C
:
CloneableCartablePointerLike
+
CloneableCart
{
}
unsafe
impl
<
C
>
Send
for
CartableOptionPointer
<
C
>
where
C
:
Sync
+
CartablePointerLike
{
}
unsafe
impl
<
C
>
Sync
for
CartableOptionPointer
<
C
>
where
C
:
Send
+
CartablePointerLike
{
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
Yoke
;
use
core
:
:
mem
:
:
size_of
;
const
SAMPLE_BYTES
:
&
[
u8
]
=
b
"
abCDEfg
"
;
const
W
:
usize
=
size_of
:
:
<
usize
>
(
)
;
#
[
test
]
fn
test_sizes
(
)
{
assert_eq
!
(
W
*
4
size_of
:
:
<
Yoke
<
[
usize
;
3
]
&
&
[
u8
]
>
>
(
)
)
;
assert_eq
!
(
W
*
4
size_of
:
:
<
Yoke
<
[
usize
;
3
]
Option
<
&
&
[
u8
]
>
>
>
(
)
)
;
assert_eq
!
(
W
*
4
size_of
:
:
<
Yoke
<
[
usize
;
3
]
CartableOptionPointer
<
&
&
[
u8
]
>
>
>
(
)
)
;
assert_eq
!
(
W
*
4
size_of
:
:
<
Option
<
Yoke
<
[
usize
;
3
]
&
&
[
u8
]
>
>
>
(
)
)
;
assert_eq
!
(
W
*
5
size_of
:
:
<
Option
<
Yoke
<
[
usize
;
3
]
Option
<
&
&
[
u8
]
>
>
>
>
(
)
)
;
assert_eq
!
(
W
*
4
size_of
:
:
<
Option
<
Yoke
<
[
usize
;
3
]
CartableOptionPointer
<
&
&
[
u8
]
>
>
>
>
(
)
)
;
}
#
[
test
]
fn
test_new_sentinel
(
)
{
let
start
=
DROP_INVOCATIONS
.
with
(
Cell
:
:
get
)
;
{
let
_
=
CartableOptionPointer
:
:
<
Rc
<
&
[
u8
]
>
>
:
:
none
(
)
;
}
assert_eq
!
(
start
DROP_INVOCATIONS
.
with
(
Cell
:
:
get
)
)
;
{
let
_
=
CartableOptionPointer
:
:
<
Rc
<
&
[
u8
]
>
>
:
:
none
(
)
;
}
assert_eq
!
(
start
DROP_INVOCATIONS
.
with
(
Cell
:
:
get
)
)
;
}
#
[
test
]
fn
test_new_rc
(
)
{
let
start
=
DROP_INVOCATIONS
.
with
(
Cell
:
:
get
)
;
{
let
_
=
CartableOptionPointer
:
:
<
Rc
<
&
[
u8
]
>
>
:
:
from_cartable
(
SAMPLE_BYTES
.
into
(
)
)
;
}
assert_eq
!
(
start
+
1
DROP_INVOCATIONS
.
with
(
Cell
:
:
get
)
)
;
}
#
[
test
]
fn
test_rc_clone
(
)
{
let
start
=
DROP_INVOCATIONS
.
with
(
Cell
:
:
get
)
;
{
let
x
=
CartableOptionPointer
:
:
<
Rc
<
&
[
u8
]
>
>
:
:
from_cartable
(
SAMPLE_BYTES
.
into
(
)
)
;
assert_eq
!
(
start
DROP_INVOCATIONS
.
with
(
Cell
:
:
get
)
)
;
{
let
_
=
x
.
clone
(
)
;
}
assert_eq
!
(
start
DROP_INVOCATIONS
.
with
(
Cell
:
:
get
)
)
;
{
let
_
=
x
.
clone
(
)
;
let
_
=
x
.
clone
(
)
;
let
_
=
x
.
clone
(
)
;
}
assert_eq
!
(
start
DROP_INVOCATIONS
.
with
(
Cell
:
:
get
)
)
;
}
assert_eq
!
(
start
+
1
DROP_INVOCATIONS
.
with
(
Cell
:
:
get
)
)
;
}
}
