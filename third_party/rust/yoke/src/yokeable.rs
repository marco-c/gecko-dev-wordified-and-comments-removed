#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
borrow
:
:
{
Cow
ToOwned
}
;
use
core
:
:
{
marker
:
:
PhantomData
mem
}
;
pub
unsafe
trait
Yokeable
<
'
a
>
:
'
static
{
type
Output
:
'
a
;
fn
transform
(
&
'
a
self
)
-
>
&
'
a
Self
:
:
Output
;
fn
transform_owned
(
self
)
-
>
Self
:
:
Output
;
unsafe
fn
make
(
from
:
Self
:
:
Output
)
-
>
Self
;
fn
transform_mut
<
F
>
(
&
'
a
mut
self
f
:
F
)
where
F
:
'
static
+
for
<
'
b
>
FnOnce
(
&
'
b
mut
Self
:
:
Output
)
;
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
unsafe
impl
<
'
a
T
:
'
static
+
ToOwned
+
?
Sized
>
Yokeable
<
'
a
>
for
Cow
<
'
static
T
>
where
<
T
as
ToOwned
>
:
:
Owned
:
Sized
{
type
Output
=
Cow
<
'
a
T
>
;
#
[
inline
]
fn
transform
(
&
'
a
self
)
-
>
&
'
a
Cow
<
'
a
T
>
{
self
}
#
[
inline
]
fn
transform_owned
(
self
)
-
>
Cow
<
'
a
T
>
{
self
}
#
[
inline
]
unsafe
fn
make
(
from
:
Cow
<
'
a
T
>
)
-
>
Self
{
debug_assert
!
(
mem
:
:
size_of
:
:
<
Cow
<
'
a
T
>
>
(
)
=
=
mem
:
:
size_of
:
:
<
Self
>
(
)
)
;
let
ptr
:
*
const
Self
=
(
&
from
as
*
const
Self
:
:
Output
)
.
cast
(
)
;
let
_
=
core
:
:
mem
:
:
ManuallyDrop
:
:
new
(
from
)
;
unsafe
{
core
:
:
ptr
:
:
read
(
ptr
)
}
}
#
[
inline
]
fn
transform_mut
<
F
>
(
&
'
a
mut
self
f
:
F
)
where
F
:
'
static
+
for
<
'
b
>
FnOnce
(
&
'
b
mut
Self
:
:
Output
)
{
unsafe
{
f
(
mem
:
:
transmute
:
:
<
&
'
a
mut
Self
&
'
a
mut
Self
:
:
Output
>
(
self
)
)
}
}
}
unsafe
impl
<
'
a
T
:
'
static
+
?
Sized
>
Yokeable
<
'
a
>
for
&
'
static
T
{
type
Output
=
&
'
a
T
;
#
[
inline
]
fn
transform
(
&
'
a
self
)
-
>
&
'
a
&
'
a
T
{
self
}
#
[
inline
]
fn
transform_owned
(
self
)
-
>
&
'
a
T
{
self
}
#
[
inline
]
unsafe
fn
make
(
from
:
&
'
a
T
)
-
>
Self
{
unsafe
{
mem
:
:
transmute
(
from
)
}
}
#
[
inline
]
fn
transform_mut
<
F
>
(
&
'
a
mut
self
f
:
F
)
where
F
:
'
static
+
for
<
'
b
>
FnOnce
(
&
'
b
mut
Self
:
:
Output
)
{
unsafe
{
f
(
mem
:
:
transmute
:
:
<
&
'
a
mut
Self
&
'
a
mut
Self
:
:
Output
>
(
self
)
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
unsafe
impl
<
'
a
T
:
'
static
>
Yokeable
<
'
a
>
for
alloc
:
:
vec
:
:
Vec
<
T
>
{
type
Output
=
alloc
:
:
vec
:
:
Vec
<
T
>
;
#
[
inline
]
fn
transform
(
&
'
a
self
)
-
>
&
'
a
alloc
:
:
vec
:
:
Vec
<
T
>
{
self
}
#
[
inline
]
fn
transform_owned
(
self
)
-
>
alloc
:
:
vec
:
:
Vec
<
T
>
{
self
}
#
[
inline
]
unsafe
fn
make
(
from
:
alloc
:
:
vec
:
:
Vec
<
T
>
)
-
>
Self
{
from
}
#
[
inline
]
fn
transform_mut
<
F
>
(
&
'
a
mut
self
f
:
F
)
where
F
:
'
static
+
for
<
'
b
>
FnOnce
(
&
'
b
mut
Self
:
:
Output
)
{
f
(
self
)
}
}
unsafe
impl
<
'
a
T
:
?
Sized
+
'
static
>
Yokeable
<
'
a
>
for
PhantomData
<
T
>
{
type
Output
=
PhantomData
<
T
>
;
fn
transform
(
&
'
a
self
)
-
>
&
'
a
Self
:
:
Output
{
self
}
fn
transform_owned
(
self
)
-
>
Self
:
:
Output
{
self
}
unsafe
fn
make
(
from
:
Self
:
:
Output
)
-
>
Self
{
from
}
fn
transform_mut
<
F
>
(
&
'
a
mut
self
f
:
F
)
where
F
:
'
static
+
for
<
'
b
>
FnOnce
(
&
'
b
mut
Self
:
:
Output
)
{
f
(
self
)
}
}
