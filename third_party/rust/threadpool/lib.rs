use
std
:
:
fmt
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Sender
Receiver
}
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
thread
:
:
{
Builder
panicking
}
;
trait
FnBox
{
fn
call_box
(
self
:
Box
<
Self
>
)
;
}
impl
<
F
:
FnOnce
(
)
>
FnBox
for
F
{
fn
call_box
(
self
:
Box
<
F
>
)
{
(
*
self
)
(
)
}
}
type
Thunk
<
'
a
>
=
Box
<
FnBox
+
Send
+
'
a
>
;
struct
Sentinel
<
'
a
>
{
name
:
Option
<
String
>
jobs
:
&
'
a
Arc
<
Mutex
<
Receiver
<
Thunk
<
'
static
>
>
>
>
thread_counter
:
&
'
a
Arc
<
AtomicUsize
>
thread_count_max
:
&
'
a
Arc
<
AtomicUsize
>
thread_count_panic
:
&
'
a
Arc
<
AtomicUsize
>
active
:
bool
}
impl
<
'
a
>
Sentinel
<
'
a
>
{
fn
new
(
name
:
Option
<
String
>
jobs
:
&
'
a
Arc
<
Mutex
<
Receiver
<
Thunk
<
'
static
>
>
>
>
thread_counter
:
&
'
a
Arc
<
AtomicUsize
>
thread_count_max
:
&
'
a
Arc
<
AtomicUsize
>
thread_count_panic
:
&
'
a
Arc
<
AtomicUsize
>
)
-
>
Sentinel
<
'
a
>
{
Sentinel
{
name
:
name
jobs
:
jobs
thread_counter
:
thread_counter
thread_count_max
:
thread_count_max
thread_count_panic
:
thread_count_panic
active
:
true
}
}
fn
cancel
(
mut
self
)
{
self
.
active
=
false
;
}
}
impl
<
'
a
>
Drop
for
Sentinel
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
if
self
.
active
{
self
.
thread_counter
.
fetch_sub
(
1
Ordering
:
:
SeqCst
)
;
if
panicking
(
)
{
self
.
thread_count_panic
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
}
spawn_in_pool
(
self
.
name
.
clone
(
)
self
.
jobs
.
clone
(
)
self
.
thread_counter
.
clone
(
)
self
.
thread_count_max
.
clone
(
)
self
.
thread_count_panic
.
clone
(
)
)
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
ThreadPool
{
name
:
Option
<
String
>
jobs
:
Sender
<
Thunk
<
'
static
>
>
job_receiver
:
Arc
<
Mutex
<
Receiver
<
Thunk
<
'
static
>
>
>
>
active_count
:
Arc
<
AtomicUsize
>
max_count
:
Arc
<
AtomicUsize
>
panic_count
:
Arc
<
AtomicUsize
>
}
impl
ThreadPool
{
pub
fn
new
(
num_threads
:
usize
)
-
>
ThreadPool
{
ThreadPool
:
:
new_pool
(
None
num_threads
)
}
pub
fn
new_with_name
(
name
:
String
num_threads
:
usize
)
-
>
ThreadPool
{
ThreadPool
:
:
new_pool
(
Some
(
name
)
num_threads
)
}
#
[
inline
]
fn
new_pool
(
name
:
Option
<
String
>
num_threads
:
usize
)
-
>
ThreadPool
{
assert
!
(
num_threads
>
=
1
)
;
let
(
tx
rx
)
=
channel
:
:
<
Thunk
<
'
static
>
>
(
)
;
let
rx
=
Arc
:
:
new
(
Mutex
:
:
new
(
rx
)
)
;
let
active_count
=
Arc
:
:
new
(
AtomicUsize
:
:
new
(
0
)
)
;
let
max_count
=
Arc
:
:
new
(
AtomicUsize
:
:
new
(
num_threads
)
)
;
let
panic_count
=
Arc
:
:
new
(
AtomicUsize
:
:
new
(
0
)
)
;
for
_
in
0
.
.
num_threads
{
spawn_in_pool
(
name
.
clone
(
)
rx
.
clone
(
)
active_count
.
clone
(
)
max_count
.
clone
(
)
panic_count
.
clone
(
)
)
;
}
ThreadPool
{
name
:
name
jobs
:
tx
job_receiver
:
rx
.
clone
(
)
active_count
:
active_count
max_count
:
max_count
panic_count
:
panic_count
}
}
pub
fn
execute
<
F
>
(
&
self
job
:
F
)
where
F
:
FnOnce
(
)
+
Send
+
'
static
{
self
.
jobs
.
send
(
Box
:
:
new
(
move
|
|
job
(
)
)
)
.
unwrap
(
)
;
}
pub
fn
active_count
(
&
self
)
-
>
usize
{
self
.
active_count
.
load
(
Ordering
:
:
Relaxed
)
}
pub
fn
max_count
(
&
self
)
-
>
usize
{
self
.
max_count
.
load
(
Ordering
:
:
Relaxed
)
}
pub
fn
panic_count
(
&
self
)
-
>
usize
{
self
.
panic_count
.
load
(
Ordering
:
:
Relaxed
)
}
#
[
deprecated
(
since
=
"
1
.
3
.
0
"
note
=
"
use
ThreadPool
:
:
set_num_threads
"
)
]
pub
fn
set_threads
(
&
mut
self
num_threads
:
usize
)
{
self
.
set_num_threads
(
num_threads
)
}
pub
fn
set_num_threads
(
&
mut
self
num_threads
:
usize
)
{
assert
!
(
num_threads
>
=
1
)
;
let
prev_num_threads
=
(
*
self
.
max_count
)
.
swap
(
num_threads
Ordering
:
:
Release
)
;
if
let
Some
(
num_spawn
)
=
num_threads
.
checked_sub
(
prev_num_threads
)
{
for
_
in
0
.
.
num_spawn
{
spawn_in_pool
(
self
.
name
.
clone
(
)
self
.
job_receiver
.
clone
(
)
self
.
active_count
.
clone
(
)
self
.
max_count
.
clone
(
)
self
.
panic_count
.
clone
(
)
)
;
}
}
}
}
impl
fmt
:
:
Debug
for
ThreadPool
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
ThreadPool
{
{
name
:
{
:
?
}
active_count
:
{
}
max_count
:
{
}
}
}
"
self
.
name
self
.
active_count
(
)
self
.
max_count
(
)
)
}
}
fn
spawn_in_pool
(
name
:
Option
<
String
>
jobs
:
Arc
<
Mutex
<
Receiver
<
Thunk
<
'
static
>
>
>
>
thread_counter
:
Arc
<
AtomicUsize
>
thread_count_max
:
Arc
<
AtomicUsize
>
thread_count_panic
:
Arc
<
AtomicUsize
>
)
{
let
mut
builder
=
Builder
:
:
new
(
)
;
if
let
Some
(
ref
name
)
=
name
{
builder
=
builder
.
name
(
name
.
clone
(
)
)
;
}
builder
.
spawn
(
move
|
|
{
let
sentinel
=
Sentinel
:
:
new
(
name
&
jobs
&
thread_counter
&
thread_count_max
&
thread_count_panic
)
;
loop
{
let
thread_counter_val
=
thread_counter
.
load
(
Ordering
:
:
Acquire
)
;
let
thread_count_max_val
=
thread_count_max
.
load
(
Ordering
:
:
Relaxed
)
;
if
thread_counter_val
>
=
thread_count_max_val
{
break
;
}
let
message
=
{
let
lock
=
jobs
.
lock
(
)
.
unwrap
(
)
;
lock
.
recv
(
)
}
;
let
job
=
match
message
{
Ok
(
job
)
=
>
job
Err
(
.
.
)
=
>
break
}
;
thread_counter
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
job
.
call_box
(
)
;
thread_counter
.
fetch_sub
(
1
Ordering
:
:
SeqCst
)
;
}
sentinel
.
cancel
(
)
;
}
)
.
unwrap
(
)
;
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
ThreadPool
;
use
std
:
:
sync
:
:
mpsc
:
:
{
sync_channel
channel
}
;
use
std
:
:
sync
:
:
{
Arc
Barrier
}
;
use
std
:
:
thread
:
:
{
self
sleep
}
;
use
std
:
:
time
:
:
Duration
;
const
TEST_TASKS
:
usize
=
4
;
#
[
test
]
fn
test_set_num_threads_increasing
(
)
{
let
new_thread_amount
=
TEST_TASKS
+
8
;
let
mut
pool
=
ThreadPool
:
:
new
(
TEST_TASKS
)
;
for
_
in
0
.
.
TEST_TASKS
{
pool
.
execute
(
move
|
|
{
loop
{
sleep
(
Duration
:
:
from_secs
(
10
)
)
}
}
)
;
}
pool
.
set_num_threads
(
new_thread_amount
)
;
for
_
in
0
.
.
(
new_thread_amount
-
TEST_TASKS
)
{
pool
.
execute
(
move
|
|
{
loop
{
sleep
(
Duration
:
:
from_secs
(
10
)
)
}
}
)
;
}
sleep
(
Duration
:
:
from_secs
(
1
)
)
;
assert_eq
!
(
pool
.
active_count
(
)
new_thread_amount
)
;
}
#
[
test
]
fn
test_set_num_threads_decreasing
(
)
{
let
new_thread_amount
=
2
;
let
mut
pool
=
ThreadPool
:
:
new
(
TEST_TASKS
)
;
for
_
in
0
.
.
TEST_TASKS
{
pool
.
execute
(
move
|
|
{
1
+
1
;
}
)
;
}
pool
.
set_num_threads
(
new_thread_amount
)
;
for
_
in
0
.
.
new_thread_amount
{
pool
.
execute
(
move
|
|
{
loop
{
sleep
(
Duration
:
:
from_secs
(
10
)
)
}
}
)
;
}
sleep
(
Duration
:
:
from_secs
(
1
)
)
;
assert_eq
!
(
pool
.
active_count
(
)
new_thread_amount
)
;
}
#
[
test
]
fn
test_active_count
(
)
{
let
pool
=
ThreadPool
:
:
new
(
TEST_TASKS
)
;
for
_
in
0
.
.
TEST_TASKS
{
pool
.
execute
(
move
|
|
{
loop
{
sleep
(
Duration
:
:
from_secs
(
10
)
)
}
}
)
;
}
sleep
(
Duration
:
:
from_secs
(
1
)
)
;
let
active_count
=
pool
.
active_count
(
)
;
assert_eq
!
(
active_count
TEST_TASKS
)
;
let
initialized_count
=
pool
.
max_count
(
)
;
assert_eq
!
(
initialized_count
TEST_TASKS
)
;
}
#
[
test
]
fn
test_works
(
)
{
let
pool
=
ThreadPool
:
:
new
(
TEST_TASKS
)
;
let
(
tx
rx
)
=
channel
(
)
;
for
_
in
0
.
.
TEST_TASKS
{
let
tx
=
tx
.
clone
(
)
;
pool
.
execute
(
move
|
|
{
tx
.
send
(
1
)
.
unwrap
(
)
;
}
)
;
}
assert_eq
!
(
rx
.
iter
(
)
.
take
(
TEST_TASKS
)
.
fold
(
0
|
a
b
|
a
+
b
)
TEST_TASKS
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_zero_tasks_panic
(
)
{
ThreadPool
:
:
new
(
0
)
;
}
#
[
test
]
fn
test_recovery_from_subtask_panic
(
)
{
let
pool
=
ThreadPool
:
:
new
(
TEST_TASKS
)
;
for
_
in
0
.
.
TEST_TASKS
{
pool
.
execute
(
move
|
|
{
panic
!
(
)
}
)
;
}
sleep
(
Duration
:
:
from_secs
(
1
)
)
;
assert_eq
!
(
pool
.
panic_count
(
)
TEST_TASKS
)
;
let
(
tx
rx
)
=
channel
(
)
;
for
_
in
0
.
.
TEST_TASKS
{
let
tx
=
tx
.
clone
(
)
;
pool
.
execute
(
move
|
|
{
tx
.
send
(
1
)
.
unwrap
(
)
;
}
)
;
}
assert_eq
!
(
rx
.
iter
(
)
.
take
(
TEST_TASKS
)
.
fold
(
0
|
a
b
|
a
+
b
)
TEST_TASKS
)
;
}
#
[
test
]
fn
test_should_not_panic_on_drop_if_subtasks_panic_after_drop
(
)
{
let
pool
=
ThreadPool
:
:
new
(
TEST_TASKS
)
;
let
waiter
=
Arc
:
:
new
(
Barrier
:
:
new
(
TEST_TASKS
+
1
)
)
;
for
_
in
0
.
.
TEST_TASKS
{
let
waiter
=
waiter
.
clone
(
)
;
pool
.
execute
(
move
|
|
{
waiter
.
wait
(
)
;
panic
!
(
"
Ignore
this
panic
it
should
!
"
)
;
}
)
;
}
drop
(
pool
)
;
waiter
.
wait
(
)
;
}
#
[
test
]
fn
test_massive_task_creation
(
)
{
let
test_tasks
=
4_200_000
;
let
pool
=
ThreadPool
:
:
new
(
TEST_TASKS
)
;
let
b0
=
Arc
:
:
new
(
Barrier
:
:
new
(
TEST_TASKS
+
1
)
)
;
let
b1
=
Arc
:
:
new
(
Barrier
:
:
new
(
TEST_TASKS
+
1
)
)
;
let
(
tx
rx
)
=
channel
(
)
;
for
i
in
0
.
.
test_tasks
{
let
tx
=
tx
.
clone
(
)
;
let
(
b0
b1
)
=
(
b0
.
clone
(
)
b1
.
clone
(
)
)
;
pool
.
execute
(
move
|
|
{
if
i
<
TEST_TASKS
{
b0
.
wait
(
)
;
b1
.
wait
(
)
;
}
tx
.
send
(
1
)
.
is_ok
(
)
;
}
)
;
}
b0
.
wait
(
)
;
assert_eq
!
(
pool
.
active_count
(
)
TEST_TASKS
)
;
b1
.
wait
(
)
;
assert_eq
!
(
rx
.
iter
(
)
.
take
(
test_tasks
)
.
fold
(
0
|
a
b
|
a
+
b
)
test_tasks
)
;
let
atomic_active_count
=
pool
.
active_count
(
)
;
assert
!
(
atomic_active_count
<
=
1
"
atomic_active_count
:
{
}
"
atomic_active_count
)
;
}
#
[
test
]
fn
test_shrink
(
)
{
let
test_tasks_begin
=
TEST_TASKS
+
2
;
let
mut
pool
=
ThreadPool
:
:
new
(
test_tasks_begin
)
;
let
b0
=
Arc
:
:
new
(
Barrier
:
:
new
(
test_tasks_begin
+
1
)
)
;
let
b1
=
Arc
:
:
new
(
Barrier
:
:
new
(
test_tasks_begin
+
1
)
)
;
for
_
in
0
.
.
test_tasks_begin
{
let
(
b0
b1
)
=
(
b0
.
clone
(
)
b1
.
clone
(
)
)
;
pool
.
execute
(
move
|
|
{
b0
.
wait
(
)
;
b1
.
wait
(
)
;
}
)
;
}
let
b2
=
Arc
:
:
new
(
Barrier
:
:
new
(
TEST_TASKS
+
1
)
)
;
let
b3
=
Arc
:
:
new
(
Barrier
:
:
new
(
TEST_TASKS
+
1
)
)
;
for
_
in
0
.
.
TEST_TASKS
{
let
(
b2
b3
)
=
(
b2
.
clone
(
)
b3
.
clone
(
)
)
;
pool
.
execute
(
move
|
|
{
b2
.
wait
(
)
;
b3
.
wait
(
)
;
}
)
;
}
b0
.
wait
(
)
;
pool
.
set_num_threads
(
TEST_TASKS
)
;
assert_eq
!
(
pool
.
active_count
(
)
test_tasks_begin
)
;
b1
.
wait
(
)
;
b2
.
wait
(
)
;
assert_eq
!
(
pool
.
active_count
(
)
TEST_TASKS
)
;
b3
.
wait
(
)
;
}
#
[
test
]
fn
test_name
(
)
{
let
name
=
"
test
"
;
let
mut
pool
=
ThreadPool
:
:
new_with_name
(
name
.
to_owned
(
)
2
)
;
let
(
tx
rx
)
=
sync_channel
(
0
)
;
for
_
in
0
.
.
2
{
let
tx
=
tx
.
clone
(
)
;
pool
.
execute
(
move
|
|
{
let
name
=
thread
:
:
current
(
)
.
name
(
)
.
unwrap
(
)
.
to_owned
(
)
;
tx
.
send
(
name
)
.
unwrap
(
)
;
}
)
;
}
pool
.
set_num_threads
(
3
)
;
let
tx_clone
=
tx
.
clone
(
)
;
pool
.
execute
(
move
|
|
{
let
name
=
thread
:
:
current
(
)
.
name
(
)
.
unwrap
(
)
.
to_owned
(
)
;
tx_clone
.
send
(
name
)
.
unwrap
(
)
;
panic
!
(
)
;
}
)
;
pool
.
execute
(
move
|
|
{
let
name
=
thread
:
:
current
(
)
.
name
(
)
.
unwrap
(
)
.
to_owned
(
)
;
tx
.
send
(
name
)
.
unwrap
(
)
;
}
)
;
for
thread_name
in
rx
.
iter
(
)
.
take
(
4
)
{
assert_eq
!
(
name
thread_name
)
;
}
}
#
[
test
]
fn
test_debug
(
)
{
let
pool
=
ThreadPool
:
:
new
(
4
)
;
let
debug
=
format
!
(
"
{
:
?
}
"
pool
)
;
assert_eq
!
(
debug
"
ThreadPool
{
name
:
None
active_count
:
0
max_count
:
4
}
"
)
;
let
pool
=
ThreadPool
:
:
new_with_name
(
"
hello
"
.
into
(
)
4
)
;
let
debug
=
format
!
(
"
{
:
?
}
"
pool
)
;
assert_eq
!
(
debug
"
ThreadPool
{
name
:
Some
(
\
"
hello
\
"
)
active_count
:
0
max_count
:
4
}
"
)
;
let
pool
=
ThreadPool
:
:
new
(
4
)
;
pool
.
execute
(
move
|
|
{
sleep
(
Duration
:
:
from_secs
(
5
)
)
}
)
;
sleep
(
Duration
:
:
from_secs
(
1
)
)
;
let
debug
=
format
!
(
"
{
:
?
}
"
pool
)
;
assert_eq
!
(
debug
"
ThreadPool
{
name
:
None
active_count
:
1
max_count
:
4
}
"
)
;
}
}
