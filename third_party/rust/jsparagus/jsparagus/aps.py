from
__future__
import
annotations
import
typing
from
dataclasses
import
dataclass
from
.
grammar
import
Nt
from
.
lr0
import
ShiftedTerm
Term
from
.
actions
import
Action
if
typing
.
TYPE_CHECKING
:
    
from
.
parse_table
import
StateId
StateAndTransitions
ParseTable
def
shifted_path_to
(
pt
:
ParseTable
n
:
int
right_of
:
Path
)
-
>
typing
.
Iterator
[
Path
]
:
    
"
Compute
all
paths
with
n
shifted
terms
ending
with
right_of
.
"
    
assert
isinstance
(
right_of
list
)
and
len
(
right_of
)
>
=
1
    
if
n
=
=
0
:
        
yield
right_of
    
state
=
right_of
[
0
]
.
src
    
assert
isinstance
(
state
int
)
    
for
edge
in
pt
.
states
[
state
]
.
backedges
:
        
if
not
pt
.
term_is_shifted
(
edge
.
term
)
:
            
print
(
repr
(
edge
)
)
            
print
(
pt
.
states
[
edge
.
src
]
)
        
assert
pt
.
term_is_shifted
(
edge
.
term
)
        
if
pt
.
term_is_stacked
(
edge
.
term
)
:
            
s_n
=
n
-
1
            
if
n
=
=
0
:
                
continue
        
else
:
            
s_n
=
n
        
from_edge
=
Edge
(
edge
.
src
edge
.
term
)
        
for
path
in
shifted_path_to
(
pt
s_n
[
from_edge
]
+
right_of
)
:
            
yield
path
def
reduce_path
(
pt
:
ParseTable
shifted
:
Path
)
-
>
typing
.
Iterator
[
Path
]
:
    
"
"
"
Compute
all
paths
which
might
be
reduced
by
a
given
action
.
This
function
    
assumes
that
the
state
is
reachable
from
the
starting
goals
and
that
    
the
depth
which
is
being
queried
has
valid
answers
.
"
"
"
    
assert
len
(
shifted
)
>
=
1
    
action
=
shifted
[
-
1
]
.
term
    
assert
isinstance
(
action
Action
)
    
assert
action
.
update_stack
(
)
    
stack_diff
=
action
.
update_stack_with
(
)
    
nt
=
stack_diff
.
nt
    
depth
=
stack_diff
.
pop
+
stack_diff
.
replay
    
if
depth
>
0
:
        
stacked
=
[
i
for
i
e
in
enumerate
(
shifted
)
if
pt
.
term_is_stacked
(
e
.
term
)
]
        
if
len
(
stacked
)
<
depth
:
            
shifted_from
=
0
            
depth
-
=
len
(
stacked
)
        
else
:
            
shifted_from
=
stacked
[
-
depth
]
            
depth
=
0
        
shifted_end
=
shifted
[
shifted_from
:
]
    
else
:
        
shifted_end
=
shifted
[
-
1
:
]
    
for
path
in
shifted_path_to
(
pt
depth
shifted_end
)
:
        
assert
pt
.
assume_inconsistent
or
nt
in
pt
.
states
[
path
[
0
]
.
src
]
.
nonterminals
        
yield
path
dataclass
(
frozen
=
True
)
class
Edge
:
    
"
"
"
An
edge
in
a
Parse
table
is
a
tuple
of
a
source
state
and
the
term
followed
    
to
exit
this
state
.
The
destination
is
not
saved
here
as
it
can
easily
be
    
inferred
by
looking
it
up
in
the
parse
table
.
    
Note
the
term
might
be
None
if
no
term
is
specified
yet
.
This
is
useful
    
for
specifying
the
last
state
in
a
Path
.
      
src
:
Index
of
the
state
from
which
this
directed
edge
is
coming
from
.
      
term
:
Edge
transition
value
this
can
be
a
terminal
non
-
terminal
or
an
          
action
to
be
executed
on
an
epsilon
transition
.
    
"
"
"
    
src
:
StateId
    
term
:
typing
.
Optional
[
Term
]
    
def
stable_str
(
self
states
:
typing
.
List
[
StateAndTransitions
]
)
-
>
str
:
        
return
"
{
}
-
-
{
}
-
-
>
"
.
format
(
states
[
self
.
src
]
.
stable_hash
str
(
self
.
term
)
)
    
def
__str__
(
self
)
-
>
str
:
        
return
"
{
}
-
-
{
}
-
-
>
"
.
format
(
self
.
src
str
(
self
.
term
)
)
Path
=
typing
.
List
[
Edge
]
dataclass
(
frozen
=
True
)
class
APS
:
    
__slots__
=
[
'
stack
'
'
shift
'
'
lookahead
'
'
replay
'
'
history
'
'
reducing
'
]
    
stack
:
Path
    
shift
:
Path
    
lookahead
:
typing
.
List
[
ShiftedTerm
]
    
replay
:
typing
.
List
[
ShiftedTerm
]
    
history
:
Path
    
reducing
:
bool
    
staticmethod
    
def
start
(
state
:
StateId
)
-
>
APS
:
        
"
Return
an
Abstract
Parser
State
starting
at
a
given
state
of
a
parse
table
"
        
edge
=
Edge
(
state
None
)
        
return
APS
(
[
edge
]
[
edge
]
[
]
[
]
[
]
False
)
    
def
shift_next
(
self
pt
:
ParseTable
)
-
>
typing
.
Iterator
[
APS
]
:
        
"
"
"
Yield
an
APS
for
each
state
reachable
from
this
APS
in
a
single
step
        
by
handling
a
single
term
(
terminal
nonterminal
or
action
)
.
        
All
yielded
APS
are
representing
context
information
around
the
same
        
starting
state
as
self
either
by
having
additional
lookahead
terms
        
or
a
larger
stack
representing
the
path
taken
to
reach
the
starting
        
state
.
        
For
each
outgoing
edge
it
builds
a
new
APS
which
represents
the
state
        
of
the
Parser
if
we
were
to
have
taken
this
edge
.
Only
valid
APS
are
        
yielded
given
the
context
provided
by
self
.
        
For
example
we
cannot
reduce
to
a
path
which
is
different
than
what
is
        
already
present
in
the
shift
list
or
shift
a
term
different
than
the
        
next
term
to
be
shifted
from
the
replay
list
.
        
"
"
"
        
st
sh
la
rp
hs
=
self
.
stack
self
.
shift
self
.
lookahead
self
.
replay
self
.
history
        
last_edge
=
sh
[
-
1
]
        
state
=
pt
.
states
[
last_edge
.
src
]
        
if
self
.
replay
=
=
[
]
:
            
for
term
to
in
state
.
shifted_edges
(
)
:
                
edge
=
Edge
(
last_edge
.
src
term
)
                
new_sh
=
self
.
shift
[
:
-
1
]
+
[
edge
]
                
edge_to
=
Edge
(
to
None
)
                
yield
APS
(
st
new_sh
+
[
edge_to
]
la
+
[
term
]
rp
hs
+
[
edge
]
False
)
        
else
:
            
term
=
self
.
replay
[
0
]
            
rp
=
self
.
replay
[
1
:
]
            
if
term
in
state
:
                
edge
=
Edge
(
last_edge
.
src
term
)
                
new_sh
=
self
.
shift
[
:
-
1
]
+
[
edge
]
                
to
=
state
[
term
]
                
edge_to
=
Edge
(
to
None
)
                
yield
APS
(
st
new_sh
+
[
edge_to
]
la
rp
hs
+
[
edge
]
False
)
        
rp
=
self
.
replay
        
for
a
to
in
state
.
epsilon
:
            
edge
=
Edge
(
last_edge
.
src
a
)
            
prev_sh
=
self
.
shift
[
:
-
1
]
+
[
edge
]
            
if
a
.
update_stack
(
)
:
                
if
self
.
reducing
:
                    
continue
                
assert
not
a
.
follow_edge
(
)
                
stack_diff
=
a
.
update_stack_with
(
)
                
for
path
in
reduce_path
(
pt
prev_sh
)
:
                    
if
prev_sh
[
-
len
(
path
)
:
]
!
=
path
[
-
len
(
prev_sh
)
:
]
:
                        
continue
                    
new_st
=
path
[
:
max
(
len
(
path
)
-
len
(
prev_sh
)
0
)
]
+
st
                    
assert
pt
.
is_valid_path
(
new_st
)
                    
new_sh
=
prev_sh
[
:
-
len
(
path
)
]
+
[
Edge
(
path
[
0
]
.
src
None
)
]
                    
assert
pt
.
is_valid_path
(
new_sh
)
                    
replay
=
stack_diff
.
replay
                    
nt
=
stack_diff
.
nt
                    
assert
nt
is
not
None
                    
new_rp
:
typing
.
List
[
ShiftedTerm
]
=
[
nt
]
                    
if
replay
>
0
:
                        
stacked_terms
=
[
                            
typing
.
cast
(
ShiftedTerm
edge
.
term
)
                            
for
edge
in
path
if
pt
.
term_is_stacked
(
edge
.
term
)
                        
]
                        
new_rp
=
new_rp
+
stacked_terms
[
-
replay
:
]
                    
new_rp
=
new_rp
+
rp
                    
new_la
=
la
[
:
max
(
len
(
la
)
-
replay
0
)
]
                    
yield
APS
(
new_st
new_sh
new_la
new_rp
hs
+
[
edge
]
True
)
            
else
:
                
edge_to
=
Edge
(
to
None
)
                
yield
APS
(
st
prev_sh
+
[
edge_to
]
la
rp
hs
+
[
edge
]
self
.
reducing
)
    
def
stable_str
(
self
states
:
typing
.
List
[
StateAndTransitions
]
name
:
str
=
"
aps
"
)
-
>
str
:
        
return
"
"
"
{
}
.
stack
=
[
{
}
]
{
}
.
shift
=
[
{
}
]
{
}
.
lookahead
=
[
{
}
]
{
}
.
replay
=
[
{
}
]
{
}
.
history
=
[
{
}
]
{
}
.
reducing
=
{
}
        
"
"
"
.
format
(
            
name
"
"
.
join
(
e
.
stable_str
(
states
)
for
e
in
self
.
stack
)
            
name
"
"
.
join
(
e
.
stable_str
(
states
)
for
e
in
self
.
shift
)
            
name
"
"
.
join
(
repr
(
e
)
for
e
in
self
.
lookahead
)
            
name
"
"
.
join
(
repr
(
e
)
for
e
in
self
.
replay
)
            
name
"
"
.
join
(
e
.
stable_str
(
states
)
for
e
in
self
.
history
)
            
name
self
.
reducing
        
)
    
def
string
(
self
name
:
str
=
"
aps
"
)
-
>
str
:
        
return
"
"
"
{
}
.
stack
=
[
{
}
]
{
}
.
shift
=
[
{
}
]
{
}
.
lookahead
=
[
{
}
]
{
}
.
replay
=
[
{
}
]
{
}
.
history
=
[
{
}
]
{
}
.
reducing
=
{
}
        
"
"
"
.
format
(
            
name
"
"
.
join
(
str
(
e
)
for
e
in
self
.
stack
)
            
name
"
"
.
join
(
str
(
e
)
for
e
in
self
.
shift
)
            
name
"
"
.
join
(
repr
(
e
)
for
e
in
self
.
lookahead
)
            
name
"
"
.
join
(
repr
(
e
)
for
e
in
self
.
replay
)
            
name
"
"
.
join
(
str
(
e
)
for
e
in
self
.
history
)
            
name
self
.
reducing
        
)
    
def
__str__
(
self
)
-
>
str
:
        
return
self
.
string
(
)
def
stable_aps_lanes_str
(
        
aps_lanes
:
typing
.
List
[
APS
]
        
states
:
typing
.
List
[
StateAndTransitions
]
        
header
:
str
=
"
lanes
:
"
        
name
:
str
=
"
\
taps
"
)
-
>
str
:
    
return
"
{
}
\
n
{
}
"
.
format
(
header
"
\
n
"
.
join
(
aps
.
stable_str
(
states
name
)
for
aps
in
aps_lanes
)
)
