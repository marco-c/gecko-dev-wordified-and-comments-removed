#
!
[
deny
(
missing_docs
)
]
#
[
cfg
(
feature
=
"
backtrace
"
)
]
extern
crate
backtrace
;
use
std
:
:
error
;
use
std
:
:
iter
:
:
Iterator
;
#
[
cfg
(
feature
=
"
backtrace
"
)
]
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
backtrace
"
)
]
pub
use
backtrace
:
:
Backtrace
;
#
[
cfg
(
not
(
feature
=
"
backtrace
"
)
)
]
pub
type
Backtrace
=
(
)
;
#
[
macro_use
]
mod
quick_error
;
#
[
macro_use
]
mod
error_chain
;
#
[
macro_use
]
mod
quick_main
;
pub
use
quick_main
:
:
ExitCode
;
#
[
cfg
(
feature
=
"
example_generated
"
)
]
pub
mod
example_generated
;
pub
struct
ErrorChainIter
<
'
a
>
(
pub
Option
<
&
'
a
error
:
:
Error
>
)
;
impl
<
'
a
>
Iterator
for
ErrorChainIter
<
'
a
>
{
type
Item
=
&
'
a
error
:
:
Error
;
fn
next
<
'
b
>
(
&
'
b
mut
self
)
-
>
Option
<
&
'
a
error
:
:
Error
>
{
match
self
.
0
.
take
(
)
{
Some
(
e
)
=
>
{
self
.
0
=
e
.
cause
(
)
;
Some
(
e
)
}
None
=
>
None
}
}
}
#
[
cfg
(
feature
=
"
backtrace
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
make_backtrace
(
)
-
>
Option
<
Arc
<
Backtrace
>
>
{
match
std
:
:
env
:
:
var_os
(
"
RUST_BACKTRACE
"
)
{
Some
(
ref
val
)
if
val
!
=
"
0
"
=
>
Some
(
Arc
:
:
new
(
Backtrace
:
:
new
(
)
)
)
_
=
>
None
}
}
pub
trait
ChainedError
:
error
:
:
Error
+
Send
+
'
static
{
type
ErrorKind
;
fn
from_kind
(
kind
:
Self
:
:
ErrorKind
)
-
>
Self
where
Self
:
Sized
;
fn
with_chain
<
E
K
>
(
error
:
E
kind
:
K
)
-
>
Self
where
Self
:
Sized
E
:
:
:
std
:
:
error
:
:
Error
+
Send
+
'
static
K
:
Into
<
Self
:
:
ErrorKind
>
;
fn
kind
(
&
self
)
-
>
&
Self
:
:
ErrorKind
;
fn
iter
(
&
self
)
-
>
ErrorChainIter
;
fn
backtrace
(
&
self
)
-
>
Option
<
&
Backtrace
>
;
fn
display
<
'
a
>
(
&
'
a
self
)
-
>
Display
<
'
a
Self
>
{
Display
(
self
)
}
#
[
doc
(
hidden
)
]
fn
new
(
kind
:
Self
:
:
ErrorKind
state
:
State
)
-
>
Self
where
Self
:
Sized
;
#
[
cfg
(
feature
=
"
backtrace
"
)
]
#
[
doc
(
hidden
)
]
fn
extract_backtrace
(
e
:
&
(
error
:
:
Error
+
Send
+
'
static
)
)
-
>
Option
<
Arc
<
Backtrace
>
>
where
Self
:
Sized
;
}
#
[
derive
(
Debug
)
]
pub
struct
Display
<
'
a
T
:
'
a
+
?
Sized
>
(
&
'
a
T
)
;
impl
<
'
a
T
>
fmt
:
:
Display
for
Display
<
'
a
T
>
where
T
:
ChainedError
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
try
!
(
writeln
!
(
fmt
"
Error
:
{
}
"
self
.
0
)
)
;
for
e
in
self
.
0
.
iter
(
)
.
skip
(
1
)
{
try
!
(
writeln
!
(
fmt
"
Caused
by
:
{
}
"
e
)
)
;
}
if
let
Some
(
backtrace
)
=
self
.
0
.
backtrace
(
)
{
try
!
(
writeln
!
(
fmt
"
{
:
?
}
"
backtrace
)
)
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
)
]
#
[
doc
(
hidden
)
]
pub
struct
State
{
pub
next_error
:
Option
<
Box
<
error
:
:
Error
+
Send
>
>
#
[
cfg
(
feature
=
"
backtrace
"
)
]
pub
backtrace
:
Option
<
Arc
<
Backtrace
>
>
}
impl
Default
for
State
{
#
[
cfg
(
feature
=
"
backtrace
"
)
]
fn
default
(
)
-
>
State
{
State
{
next_error
:
None
backtrace
:
make_backtrace
(
)
}
}
#
[
cfg
(
not
(
feature
=
"
backtrace
"
)
)
]
fn
default
(
)
-
>
State
{
State
{
next_error
:
None
}
}
}
impl
State
{
#
[
cfg
(
feature
=
"
backtrace
"
)
]
pub
fn
new
<
CE
:
ChainedError
>
(
e
:
Box
<
error
:
:
Error
+
Send
>
)
-
>
State
{
let
backtrace
=
CE
:
:
extract_backtrace
(
&
*
e
)
.
or_else
(
make_backtrace
)
;
State
{
next_error
:
Some
(
e
)
backtrace
:
backtrace
}
}
#
[
cfg
(
not
(
feature
=
"
backtrace
"
)
)
]
pub
fn
new
<
CE
:
ChainedError
>
(
e
:
Box
<
error
:
:
Error
+
Send
>
)
-
>
State
{
State
{
next_error
:
Some
(
e
)
}
}
#
[
cfg
(
feature
=
"
backtrace
"
)
]
pub
fn
backtrace
(
&
self
)
-
>
Option
<
&
Backtrace
>
{
self
.
backtrace
.
as_ref
(
)
.
map
(
|
v
|
&
*
*
v
)
}
#
[
cfg
(
not
(
feature
=
"
backtrace
"
)
)
]
pub
fn
backtrace
(
&
self
)
-
>
Option
<
&
Backtrace
>
{
None
}
}
#
[
macro_export
]
macro_rules
!
bail
{
(
e
:
expr
)
=
>
{
return
Err
(
e
.
into
(
)
)
;
}
;
(
fmt
:
expr
(
arg
:
tt
)
+
)
=
>
{
return
Err
(
format
!
(
fmt
(
arg
)
+
)
.
into
(
)
)
;
}
;
}
#
[
macro_export
]
macro_rules
!
ensure
{
(
cond
:
expr
e
:
expr
)
=
>
{
if
!
(
cond
)
{
bail
!
(
e
)
;
}
}
;
(
cond
:
expr
fmt
:
expr
(
arg
:
tt
)
+
)
=
>
{
if
!
(
cond
)
{
bail
!
(
fmt
(
arg
)
+
)
;
}
}
;
}
#
[
doc
(
hidden
)
]
pub
mod
mock
{
error_chain
!
{
}
}
