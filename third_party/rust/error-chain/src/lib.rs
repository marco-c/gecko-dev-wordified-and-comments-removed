#
!
[
deny
(
missing_docs
)
]
#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
error
-
chain
/
0
.
12
.
4
"
)
]
use
std
:
:
error
;
use
std
:
:
fmt
;
use
std
:
:
iter
:
:
Iterator
;
#
[
macro_use
]
mod
impl_error_chain_kind
;
#
[
macro_use
]
mod
error_chain
;
#
[
macro_use
]
mod
quick_main
;
pub
use
quick_main
:
:
ExitCode
;
mod
backtrace
;
#
[
cfg
(
feature
=
"
example_generated
"
)
]
pub
mod
example_generated
;
pub
use
backtrace
:
:
Backtrace
;
#
[
doc
(
hidden
)
]
pub
use
backtrace
:
:
InternalBacktrace
;
#
[
derive
(
Debug
)
]
#
[
allow
(
unknown_lints
bare_trait_objects
)
]
pub
struct
Iter
<
'
a
>
(
Option
<
&
'
a
error
:
:
Error
>
)
;
impl
<
'
a
>
Iter
<
'
a
>
{
#
[
allow
(
unknown_lints
bare_trait_objects
)
]
pub
fn
new
(
err
:
Option
<
&
'
a
error
:
:
Error
>
)
-
>
Iter
<
'
a
>
{
Iter
(
err
)
}
}
#
[
allow
(
unknown_lints
bare_trait_objects
)
]
impl
<
'
a
>
Iterator
for
Iter
<
'
a
>
{
type
Item
=
&
'
a
error
:
:
Error
;
fn
next
<
'
b
>
(
&
'
b
mut
self
)
-
>
Option
<
&
'
a
error
:
:
Error
>
{
match
self
.
0
.
take
(
)
{
Some
(
e
)
=
>
{
self
.
0
=
match
(
)
{
#
[
cfg
(
not
(
has_error_source
)
)
]
(
)
=
>
e
.
cause
(
)
#
[
cfg
(
has_error_source
)
]
(
)
=
>
e
.
source
(
)
}
;
Some
(
e
)
}
None
=
>
None
}
}
}
pub
trait
ChainedError
:
error
:
:
Error
+
Send
+
'
static
{
type
ErrorKind
;
fn
from_kind
(
kind
:
Self
:
:
ErrorKind
)
-
>
Self
where
Self
:
Sized
;
fn
with_chain
<
E
K
>
(
error
:
E
kind
:
K
)
-
>
Self
where
Self
:
Sized
E
:
:
:
std
:
:
error
:
:
Error
+
Send
+
'
static
K
:
Into
<
Self
:
:
ErrorKind
>
;
fn
kind
(
&
self
)
-
>
&
Self
:
:
ErrorKind
;
fn
iter
(
&
self
)
-
>
Iter
;
fn
backtrace
(
&
self
)
-
>
Option
<
&
Backtrace
>
;
fn
display_chain
<
'
a
>
(
&
'
a
self
)
-
>
DisplayChain
<
'
a
Self
>
{
DisplayChain
(
self
)
}
fn
chain_err
<
F
EK
>
(
self
error
:
F
)
-
>
Self
where
F
:
FnOnce
(
)
-
>
EK
EK
:
Into
<
Self
:
:
ErrorKind
>
;
#
[
doc
(
hidden
)
]
fn
new
(
kind
:
Self
:
:
ErrorKind
state
:
State
)
-
>
Self
where
Self
:
Sized
;
#
[
doc
(
hidden
)
]
#
[
allow
(
unknown_lints
bare_trait_objects
)
]
fn
extract_backtrace
(
e
:
&
(
error
:
:
Error
+
Send
+
'
static
)
)
-
>
Option
<
InternalBacktrace
>
where
Self
:
Sized
;
}
#
[
derive
(
Debug
)
]
pub
struct
DisplayChain
<
'
a
T
:
'
a
+
?
Sized
>
(
&
'
a
T
)
;
impl
<
'
a
T
>
fmt
:
:
Display
for
DisplayChain
<
'
a
T
>
where
T
:
ChainedError
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
fmt
"
Error
:
{
}
"
self
.
0
)
?
;
for
e
in
self
.
0
.
iter
(
)
.
skip
(
1
)
{
writeln
!
(
fmt
"
Caused
by
:
{
}
"
e
)
?
;
}
if
let
Some
(
backtrace
)
=
ChainedError
:
:
backtrace
(
self
.
0
)
{
writeln
!
(
fmt
"
{
:
?
}
"
backtrace
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
)
]
#
[
doc
(
hidden
)
]
#
[
allow
(
unknown_lints
bare_trait_objects
)
]
pub
struct
State
{
pub
next_error
:
Option
<
Box
<
error
:
:
Error
+
Send
>
>
pub
backtrace
:
InternalBacktrace
}
impl
Default
for
State
{
fn
default
(
)
-
>
State
{
State
{
next_error
:
None
backtrace
:
InternalBacktrace
:
:
new
(
)
}
}
}
impl
State
{
#
[
allow
(
unknown_lints
bare_trait_objects
)
]
pub
fn
new
<
CE
:
ChainedError
>
(
e
:
Box
<
error
:
:
Error
+
Send
>
)
-
>
State
{
let
backtrace
=
CE
:
:
extract_backtrace
(
&
*
e
)
.
unwrap_or_else
(
InternalBacktrace
:
:
new
)
;
State
{
next_error
:
Some
(
e
)
backtrace
:
backtrace
}
}
pub
fn
backtrace
(
&
self
)
-
>
Option
<
&
Backtrace
>
{
self
.
backtrace
.
as_backtrace
(
)
}
}
#
[
macro_export
]
macro_rules
!
bail
{
(
e
:
expr
)
=
>
{
return
Err
(
e
.
into
(
)
)
;
}
;
(
fmt
:
expr
(
arg
:
tt
)
+
)
=
>
{
return
Err
(
format
!
(
fmt
(
arg
)
+
)
.
into
(
)
)
;
}
;
}
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
ensure
{
(
cond
:
expr
e
:
expr
)
=
>
{
if
!
(
cond
)
{
bail
!
(
e
)
;
}
}
;
(
cond
:
expr
fmt
:
expr
(
arg
:
tt
)
+
)
=
>
{
if
!
(
cond
)
{
bail
!
(
fmt
(
arg
)
+
)
;
}
}
;
}
#
[
doc
(
hidden
)
]
pub
mod
mock
{
error_chain
!
{
}
}
