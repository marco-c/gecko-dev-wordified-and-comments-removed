use
std
:
:
{
borrow
:
:
Cow
cmp
:
:
Ordering
collections
:
:
{
HashMap
HashSet
}
convert
:
:
{
TryFrom
TryInto
}
fmt
mem
ops
:
:
Deref
ptr
}
;
use
smallbitvec
:
:
SmallBitVec
;
use
crate
:
:
error
:
:
{
Error
ErrorKind
Result
}
;
use
crate
:
:
guid
:
:
Guid
;
type
Index
=
usize
;
#
[
derive
(
Debug
)
]
pub
struct
Tree
{
entry_index_by_guid
:
HashMap
<
Guid
Index
>
entries
:
Vec
<
TreeEntry
>
deleted_guids
:
HashSet
<
Guid
>
problems
:
Problems
}
impl
Tree
{
pub
fn
with_root
(
root
:
Item
)
-
>
Builder
{
let
mut
entry_index_by_guid
=
HashMap
:
:
new
(
)
;
entry_index_by_guid
.
insert
(
root
.
guid
.
clone
(
)
0
)
;
Builder
{
entries
:
vec
!
[
BuilderEntry
{
item
:
root
content
:
None
parent
:
BuilderEntryParent
:
:
Root
children
:
Vec
:
:
new
(
)
}
]
deleted_guids
:
HashSet
:
:
new
(
)
entry_index_by_guid
reparent_orphans_to
:
None
}
}
#
[
inline
]
pub
fn
size
(
&
self
)
-
>
usize
{
self
.
entries
.
len
(
)
}
#
[
inline
]
pub
fn
root
(
&
self
)
-
>
Node
<
'
_
>
{
Node
(
self
&
self
.
entries
[
0
]
)
}
#
[
inline
]
pub
fn
deletions
(
&
self
)
-
>
&
HashSet
<
Guid
>
{
&
self
.
deleted_guids
}
#
[
inline
]
pub
fn
exists
(
&
self
guid
:
&
Guid
)
-
>
bool
{
self
.
entry_index_by_guid
.
contains_key
(
guid
)
}
#
[
inline
]
pub
fn
is_deleted
(
&
self
guid
:
&
Guid
)
-
>
bool
{
self
.
deleted_guids
.
contains
(
guid
)
}
#
[
inline
]
pub
fn
mentions
(
&
self
guid
:
&
Guid
)
-
>
bool
{
self
.
entry_index_by_guid
.
contains_key
(
guid
)
|
|
self
.
deleted_guids
.
contains
(
guid
)
}
pub
fn
guids
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Guid
>
{
self
.
entries
.
iter
(
)
.
map
(
|
entry
|
&
entry
.
item
.
guid
)
.
chain
(
self
.
deleted_guids
.
iter
(
)
)
}
pub
fn
node_for_guid
(
&
self
guid
:
&
Guid
)
-
>
Option
<
Node
<
'
_
>
>
{
self
.
entry_index_by_guid
.
get
(
guid
)
.
map
(
|
&
index
|
Node
(
self
&
self
.
entries
[
index
]
)
)
}
#
[
inline
]
pub
fn
problems
(
&
self
)
-
>
&
Problems
{
&
self
.
problems
}
}
impl
fmt
:
:
Display
for
Tree
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
root
=
self
.
root
(
)
;
f
.
write_str
(
&
root
.
to_ascii_string
(
)
)
?
;
if
!
self
.
deleted_guids
.
is_empty
(
)
{
f
.
write_str
(
"
\
nDeleted
:
[
"
)
?
;
for
(
i
guid
)
in
self
.
deleted_guids
.
iter
(
)
.
enumerate
(
)
{
if
i
!
=
0
{
f
.
write_str
(
"
"
)
?
;
}
f
.
write_str
(
guid
.
as_ref
(
)
)
?
;
}
}
if
!
self
.
problems
.
is_empty
(
)
{
f
.
write_str
(
"
\
nProblems
:
\
n
"
)
?
;
for
(
i
summary
)
in
self
.
problems
.
summarize
(
)
.
enumerate
(
)
{
if
i
!
=
0
{
f
.
write_str
(
"
\
n
"
)
?
;
}
write
!
(
f
"
{
}
"
summary
)
?
;
}
}
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Builder
{
entry_index_by_guid
:
HashMap
<
Guid
Index
>
entries
:
Vec
<
BuilderEntry
>
deleted_guids
:
HashSet
<
Guid
>
reparent_orphans_to
:
Option
<
Guid
>
}
impl
Builder
{
#
[
inline
]
pub
fn
reparent_orphans_to
(
&
mut
self
guid
:
&
Guid
)
-
>
&
mut
Builder
{
self
.
reparent_orphans_to
=
Some
(
guid
.
clone
(
)
)
;
self
}
pub
fn
item
(
&
mut
self
item
:
Item
)
-
>
Result
<
ItemBuilder
<
'
_
>
>
{
assert_eq
!
(
self
.
entries
.
len
(
)
self
.
entry_index_by_guid
.
len
(
)
)
;
if
self
.
entry_index_by_guid
.
contains_key
(
&
item
.
guid
)
{
return
Err
(
ErrorKind
:
:
DuplicateItem
(
item
.
guid
.
clone
(
)
)
.
into
(
)
)
;
}
let
entry_index
=
self
.
entries
.
len
(
)
;
self
.
entry_index_by_guid
.
insert
(
item
.
guid
.
clone
(
)
entry_index
)
;
self
.
entries
.
push
(
BuilderEntry
{
item
content
:
None
parent
:
BuilderEntryParent
:
:
None
children
:
Vec
:
:
new
(
)
}
)
;
Ok
(
ItemBuilder
(
self
entry_index
)
)
}
pub
fn
parent_for
(
&
mut
self
child_guid
:
&
Guid
)
-
>
ParentBuilder
<
'
_
>
{
assert_eq
!
(
self
.
entries
.
len
(
)
self
.
entry_index_by_guid
.
len
(
)
)
;
let
entry_child
=
match
self
.
entry_index_by_guid
.
get
(
child_guid
)
{
Some
(
&
child_index
)
=
>
BuilderEntryChild
:
:
Exists
(
child_index
)
None
=
>
BuilderEntryChild
:
:
Missing
(
child_guid
.
clone
(
)
)
}
;
ParentBuilder
(
self
entry_child
)
}
#
[
inline
]
pub
fn
deletion
(
&
mut
self
guid
:
Guid
)
-
>
&
mut
Builder
{
self
.
deleted_guids
.
insert
(
guid
)
;
self
}
pub
fn
into_tree
(
self
)
-
>
Result
<
Tree
>
{
self
.
try_into
(
)
}
#
[
cfg
(
test
)
]
pub
fn
mutate
(
&
mut
self
child_guid
:
&
Guid
)
-
>
ItemBuilder
<
'
_
>
{
assert_eq
!
(
self
.
entries
.
len
(
)
self
.
entry_index_by_guid
.
len
(
)
)
;
match
self
.
entry_index_by_guid
.
get
(
child_guid
)
{
Some
(
&
child_index
)
=
>
ItemBuilder
(
self
child_index
)
None
=
>
panic
!
(
"
Can
'
t
mutate
nonexistent
item
{
}
"
child_guid
)
}
}
}
impl
TryFrom
<
Builder
>
for
Tree
{
type
Error
=
Error
;
fn
try_from
(
mut
builder
:
Builder
)
-
>
Result
<
Tree
>
{
let
mut
problems
=
Problems
:
:
default
(
)
;
let
mut
zombies
=
SmallBitVec
:
:
from_elem
(
builder
.
entries
.
len
(
)
false
)
;
let
mut
parents
=
Vec
:
:
with_capacity
(
builder
.
entries
.
len
(
)
)
;
let
mut
reparented_child_indices_by_parent
:
HashMap
<
Index
Vec
<
Index
>
>
=
HashMap
:
:
new
(
)
;
for
(
entry_index
entry
)
in
builder
.
entries
.
iter
(
)
.
enumerate
(
)
{
let
r
=
ResolveParent
:
:
new
(
&
builder
entry
&
mut
problems
)
;
let
resolved_parent
=
r
.
resolve
(
)
;
if
let
ResolvedParent
:
:
ByParentGuid
(
parent_index
)
=
resolved_parent
{
let
reparented_child_indices
=
reparented_child_indices_by_parent
.
entry
(
parent_index
)
.
or_default
(
)
;
reparented_child_indices
.
push
(
entry_index
)
;
}
if
builder
.
deleted_guids
.
remove
(
&
entry
.
item
.
guid
)
{
zombies
.
set
(
entry_index
true
)
;
}
parents
.
push
(
resolved_parent
)
;
}
if
let
Some
(
index
)
=
detect_cycles
(
&
parents
)
{
return
Err
(
ErrorKind
:
:
Cycle
(
builder
.
entries
[
index
]
.
item
.
guid
.
clone
(
)
)
.
into
(
)
)
;
}
let
mut
entries
=
Vec
:
:
with_capacity
(
builder
.
entries
.
len
(
)
)
;
for
(
entry_index
entry
)
in
builder
.
entries
.
into_iter
(
)
.
enumerate
(
)
{
let
mut
divergence
=
Divergence
:
:
Consistent
;
let
parent_index
=
match
&
parents
[
entry_index
]
{
ResolvedParent
:
:
Root
=
>
{
assert_eq
!
(
entry_index
0
)
;
None
}
ResolvedParent
:
:
ByStructure
(
index
)
=
>
{
Some
(
*
index
)
}
ResolvedParent
:
:
ByChildren
(
index
)
|
ResolvedParent
:
:
ByParentGuid
(
index
)
=
>
{
divergence
=
Divergence
:
:
Diverged
;
Some
(
*
index
)
}
}
;
if
zombies
[
entry_index
]
{
divergence
=
Divergence
:
:
Diverged
;
}
let
mut
child_indices
=
Vec
:
:
with_capacity
(
entry
.
children
.
len
(
)
)
;
for
child
in
entry
.
children
{
match
child
{
BuilderEntryChild
:
:
Exists
(
child_index
)
=
>
{
if
zombies
[
entry_index
]
{
divergence
=
Divergence
:
:
Diverged
;
}
match
&
parents
[
child_index
]
{
ResolvedParent
:
:
Root
=
>
{
unreachable
!
(
"
A
child
can
'
t
be
a
top
-
level
root
"
)
;
}
ResolvedParent
:
:
ByStructure
(
parent_index
)
=
>
{
assert_eq
!
(
*
parent_index
entry_index
)
;
child_indices
.
push
(
child_index
)
;
}
ResolvedParent
:
:
ByChildren
(
parent_index
)
=
>
{
divergence
=
Divergence
:
:
Diverged
;
if
*
parent_index
=
=
entry_index
{
child_indices
.
push
(
child_index
)
;
}
}
ResolvedParent
:
:
ByParentGuid
(
parent_index
)
=
>
{
assert_eq
!
(
*
parent_index
0
)
;
divergence
=
Divergence
:
:
Diverged
;
}
}
}
BuilderEntryChild
:
:
Missing
(
child_guid
)
=
>
{
divergence
=
Divergence
:
:
Diverged
;
let
problem
=
if
builder
.
deleted_guids
.
remove
(
&
child_guid
)
{
Problem
:
:
DeletedChild
{
child_guid
:
child_guid
.
clone
(
)
}
}
else
{
Problem
:
:
MissingChild
{
child_guid
:
child_guid
.
clone
(
)
}
}
;
problems
.
note
(
&
entry
.
item
.
guid
problem
)
;
}
}
}
if
let
Some
(
reparented_child_indices
)
=
reparented_child_indices_by_parent
.
get
(
&
entry_index
)
{
divergence
=
Divergence
:
:
Diverged
;
child_indices
.
extend_from_slice
(
reparented_child_indices
)
;
}
entries
.
push
(
TreeEntry
{
item
:
entry
.
item
content
:
entry
.
content
parent_index
child_indices
divergence
}
)
;
}
Ok
(
Tree
{
entry_index_by_guid
:
builder
.
entry_index_by_guid
entries
deleted_guids
:
builder
.
deleted_guids
problems
}
)
}
}
pub
struct
ItemBuilder
<
'
b
>
(
&
'
b
mut
Builder
Index
)
;
impl
<
'
b
>
ItemBuilder
<
'
b
>
{
#
[
inline
]
pub
fn
content
<
'
c
>
(
&
'
c
mut
self
content
:
Content
)
-
>
&
'
c
mut
ItemBuilder
<
'
b
>
{
mem
:
:
replace
(
&
mut
self
.
0
.
entries
[
self
.
1
]
.
content
Some
(
content
)
)
;
self
}
#
[
inline
]
pub
fn
by_children
(
self
parent_guid
:
&
Guid
)
-
>
Result
<
&
'
b
mut
Builder
>
{
let
b
=
ParentBuilder
(
self
.
0
BuilderEntryChild
:
:
Exists
(
self
.
1
)
)
;
b
.
by_children
(
parent_guid
)
}
#
[
inline
]
pub
fn
by_parent_guid
(
self
parent_guid
:
Guid
)
-
>
Result
<
&
'
b
mut
Builder
>
{
let
b
=
ParentBuilder
(
self
.
0
BuilderEntryChild
:
:
Exists
(
self
.
1
)
)
;
b
.
by_parent_guid
(
parent_guid
)
}
#
[
inline
]
pub
fn
by_structure
(
self
parent_guid
:
&
Guid
)
-
>
Result
<
&
'
b
mut
Builder
>
{
let
b
=
ParentBuilder
(
self
.
0
BuilderEntryChild
:
:
Exists
(
self
.
1
)
)
;
b
.
by_structure
(
parent_guid
)
}
}
pub
struct
ParentBuilder
<
'
b
>
(
&
'
b
mut
Builder
BuilderEntryChild
)
;
impl
<
'
b
>
ParentBuilder
<
'
b
>
{
pub
fn
by_children
(
self
parent_guid
:
&
Guid
)
-
>
Result
<
&
'
b
mut
Builder
>
{
let
parent_index
=
match
self
.
0
.
entry_index_by_guid
.
get
(
parent_guid
)
{
Some
(
&
parent_index
)
if
self
.
0
.
entries
[
parent_index
]
.
item
.
is_folder
(
)
=
>
parent_index
_
=
>
{
let
child_guid
=
match
&
self
.
1
{
BuilderEntryChild
:
:
Exists
(
index
)
=
>
&
self
.
0
.
entries
[
*
index
]
.
item
.
guid
BuilderEntryChild
:
:
Missing
(
guid
)
=
>
guid
}
;
return
Err
(
ErrorKind
:
:
InvalidParent
(
child_guid
.
clone
(
)
parent_guid
.
clone
(
)
)
.
into
(
)
)
;
}
}
;
if
let
BuilderEntryChild
:
:
Exists
(
child_index
)
=
&
self
.
1
{
self
.
0
.
entries
[
*
child_index
]
.
parents_by
(
&
[
BuilderParentBy
:
:
Children
(
parent_index
)
]
)
?
;
}
self
.
0
.
entries
[
parent_index
]
.
children
.
push
(
self
.
1
)
;
Ok
(
self
.
0
)
}
pub
fn
by_parent_guid
(
self
parent_guid
:
Guid
)
-
>
Result
<
&
'
b
mut
Builder
>
{
match
&
self
.
1
{
BuilderEntryChild
:
:
Exists
(
child_index
)
=
>
{
self
.
0
.
entries
[
*
child_index
]
.
parents_by
(
&
[
BuilderParentBy
:
:
UnknownItem
(
parent_guid
)
]
)
?
;
}
BuilderEntryChild
:
:
Missing
(
child_guid
)
=
>
{
return
Err
(
ErrorKind
:
:
MissingItem
(
child_guid
.
clone
(
)
)
.
into
(
)
)
;
}
}
Ok
(
self
.
0
)
}
pub
fn
by_structure
(
self
parent_guid
:
&
Guid
)
-
>
Result
<
&
'
b
mut
Builder
>
{
let
parent_index
=
match
self
.
0
.
entry_index_by_guid
.
get
(
parent_guid
)
{
Some
(
&
parent_index
)
if
self
.
0
.
entries
[
parent_index
]
.
item
.
is_folder
(
)
=
>
parent_index
_
=
>
{
let
child_guid
=
match
&
self
.
1
{
BuilderEntryChild
:
:
Exists
(
index
)
=
>
&
self
.
0
.
entries
[
*
index
]
.
item
.
guid
BuilderEntryChild
:
:
Missing
(
guid
)
=
>
guid
}
;
return
Err
(
ErrorKind
:
:
InvalidParent
(
child_guid
.
clone
(
)
parent_guid
.
clone
(
)
)
.
into
(
)
)
;
}
}
;
if
let
BuilderEntryChild
:
:
Exists
(
child_index
)
=
&
self
.
1
{
self
.
0
.
entries
[
*
child_index
]
.
parents_by
(
&
[
BuilderParentBy
:
:
Children
(
parent_index
)
BuilderParentBy
:
:
KnownItem
(
parent_index
)
]
)
?
;
}
self
.
0
.
entries
[
parent_index
]
.
children
.
push
(
self
.
1
)
;
Ok
(
self
.
0
)
}
}
#
[
derive
(
Debug
)
]
struct
TreeEntry
{
item
:
Item
content
:
Option
<
Content
>
divergence
:
Divergence
parent_index
:
Option
<
Index
>
child_indices
:
Vec
<
Index
>
}
#
[
derive
(
Debug
)
]
struct
BuilderEntry
{
item
:
Item
content
:
Option
<
Content
>
parent
:
BuilderEntryParent
children
:
Vec
<
BuilderEntryChild
>
}
impl
BuilderEntry
{
fn
parents_by
(
&
mut
self
new_parents
:
&
[
BuilderParentBy
]
)
-
>
Result
<
(
)
>
{
let
old_parent
=
mem
:
:
replace
(
&
mut
self
.
parent
BuilderEntryParent
:
:
None
)
;
let
new_parent
=
match
old_parent
{
BuilderEntryParent
:
:
Root
=
>
{
mem
:
:
replace
(
&
mut
self
.
parent
BuilderEntryParent
:
:
Root
)
;
return
Err
(
ErrorKind
:
:
DuplicateItem
(
self
.
item
.
guid
.
clone
(
)
)
.
into
(
)
)
;
}
BuilderEntryParent
:
:
None
=
>
match
new_parents
{
[
BuilderParentBy
:
:
Children
(
from_children
)
BuilderParentBy
:
:
KnownItem
(
from_item
)
]
|
[
BuilderParentBy
:
:
KnownItem
(
from_item
)
BuilderParentBy
:
:
Children
(
from_children
)
]
if
from_children
=
=
from_item
=
>
{
BuilderEntryParent
:
:
Complete
(
*
from_children
)
}
new_parents
=
>
BuilderEntryParent
:
:
Partial
(
new_parents
.
to_vec
(
)
)
}
BuilderEntryParent
:
:
Complete
(
index
)
=
>
{
let
mut
parents
=
vec
!
[
BuilderParentBy
:
:
Children
(
index
)
BuilderParentBy
:
:
KnownItem
(
index
)
]
;
parents
.
extend_from_slice
(
new_parents
)
;
BuilderEntryParent
:
:
Partial
(
parents
)
}
BuilderEntryParent
:
:
Partial
(
mut
parents
)
=
>
{
parents
.
extend_from_slice
(
new_parents
)
;
BuilderEntryParent
:
:
Partial
(
parents
)
}
}
;
mem
:
:
replace
(
&
mut
self
.
parent
new_parent
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
)
]
enum
BuilderEntryChild
{
Exists
(
Index
)
Missing
(
Guid
)
}
#
[
derive
(
Clone
Debug
)
]
enum
BuilderEntryParent
{
None
Root
Complete
(
Index
)
Partial
(
Vec
<
BuilderParentBy
>
)
}
#
[
derive
(
Clone
Debug
)
]
enum
BuilderParentBy
{
Children
(
Index
)
UnknownItem
(
Guid
)
KnownItem
(
Index
)
}
struct
ResolveParent
<
'
a
>
{
builder
:
&
'
a
Builder
entry
:
&
'
a
BuilderEntry
problems
:
&
'
a
mut
Problems
}
impl
<
'
a
>
ResolveParent
<
'
a
>
{
fn
new
(
builder
:
&
'
a
Builder
entry
:
&
'
a
BuilderEntry
problems
:
&
'
a
mut
Problems
)
-
>
ResolveParent
<
'
a
>
{
ResolveParent
{
builder
entry
problems
}
}
fn
resolve
(
self
)
-
>
ResolvedParent
{
if
self
.
entry
.
item
.
guid
.
is_built_in_root
(
)
{
self
.
user_content_root
(
)
}
else
{
self
.
item
(
)
}
}
fn
parent
(
&
self
)
-
>
Cow
<
'
a
BuilderEntryParent
>
{
let
parents
=
match
&
self
.
entry
.
parent
{
BuilderEntryParent
:
:
Root
=
>
return
Cow
:
:
Owned
(
BuilderEntryParent
:
:
Root
)
BuilderEntryParent
:
:
None
=
>
return
Cow
:
:
Owned
(
BuilderEntryParent
:
:
None
)
BuilderEntryParent
:
:
Complete
(
index
)
=
>
{
return
Cow
:
:
Owned
(
BuilderEntryParent
:
:
Complete
(
*
index
)
)
;
}
BuilderEntryParent
:
:
Partial
(
parents
)
=
>
parents
}
;
let
(
index_by_guid
index_by_children
)
=
match
parents
.
as_slice
(
)
{
[
BuilderParentBy
:
:
UnknownItem
(
guid
)
BuilderParentBy
:
:
Children
(
index_by_children
)
]
|
[
BuilderParentBy
:
:
Children
(
index_by_children
)
BuilderParentBy
:
:
UnknownItem
(
guid
)
]
=
>
{
match
self
.
builder
.
entry_index_by_guid
.
get
(
guid
)
{
Some
(
&
index_by_guid
)
=
>
(
index_by_guid
*
index_by_children
)
None
=
>
return
Cow
:
:
Borrowed
(
&
self
.
entry
.
parent
)
}
}
[
BuilderParentBy
:
:
KnownItem
(
index_by_guid
)
BuilderParentBy
:
:
Children
(
index_by_children
)
]
|
[
BuilderParentBy
:
:
Children
(
index_by_children
)
BuilderParentBy
:
:
KnownItem
(
index_by_guid
)
]
=
>
{
(
*
index_by_guid
*
index_by_children
)
}
_
=
>
return
Cow
:
:
Borrowed
(
&
self
.
entry
.
parent
)
}
;
if
index_by_guid
=
=
index_by_children
{
Cow
:
:
Owned
(
BuilderEntryParent
:
:
Complete
(
index_by_children
)
)
}
else
{
Cow
:
:
Borrowed
(
&
self
.
entry
.
parent
)
}
}
fn
user_content_root
(
self
)
-
>
ResolvedParent
{
match
self
.
parent
(
)
.
as_ref
(
)
{
BuilderEntryParent
:
:
None
=
>
{
self
.
problems
.
note
(
&
self
.
entry
.
item
.
guid
Problem
:
:
Orphan
)
;
ResolvedParent
:
:
ByParentGuid
(
0
)
}
BuilderEntryParent
:
:
Root
=
>
{
unreachable
!
(
"
A
user
content
root
can
'
t
be
a
top
-
level
root
"
)
}
BuilderEntryParent
:
:
Complete
(
index
)
=
>
{
if
*
index
=
=
0
{
ResolvedParent
:
:
ByStructure
(
*
index
)
}
else
{
let
parent_guid
=
self
.
builder
.
entries
[
*
index
]
.
item
.
guid
.
clone
(
)
;
self
.
problems
.
note
(
&
self
.
entry
.
item
.
guid
Problem
:
:
MisparentedRoot
(
vec
!
[
DivergedParent
:
:
ByChildren
(
parent_guid
.
clone
(
)
)
DivergedParentGuid
:
:
Folder
(
parent_guid
)
.
into
(
)
]
)
)
;
ResolvedParent
:
:
ByParentGuid
(
0
)
}
}
BuilderEntryParent
:
:
Partial
(
parents_by
)
=
>
{
self
.
problems
.
note
(
&
self
.
entry
.
item
.
guid
Problem
:
:
MisparentedRoot
(
parents_by
.
iter
(
)
.
map
(
|
parent_by
|
{
PossibleParent
:
:
new
(
self
.
builder
parent_by
)
.
summarize
(
)
}
)
.
collect
(
)
)
)
;
ResolvedParent
:
:
ByParentGuid
(
0
)
}
}
}
fn
item
(
self
)
-
>
ResolvedParent
{
match
self
.
parent
(
)
.
as_ref
(
)
{
BuilderEntryParent
:
:
Root
=
>
ResolvedParent
:
:
Root
BuilderEntryParent
:
:
None
=
>
{
let
parent_index
=
self
.
reparent_orphans_to_default_index
(
)
;
self
.
problems
.
note
(
&
self
.
entry
.
item
.
guid
Problem
:
:
Orphan
)
;
ResolvedParent
:
:
ByParentGuid
(
parent_index
)
}
BuilderEntryParent
:
:
Complete
(
index
)
=
>
{
ResolvedParent
:
:
ByStructure
(
*
index
)
}
BuilderEntryParent
:
:
Partial
(
parents
)
=
>
{
let
possible_parents
=
parents
.
iter
(
)
.
map
(
|
parent_by
|
PossibleParent
:
:
new
(
self
.
builder
parent_by
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
self
.
problems
.
note
(
&
self
.
entry
.
item
.
guid
Problem
:
:
DivergedParents
(
possible_parents
.
iter
(
)
.
map
(
PossibleParent
:
:
summarize
)
.
collect
(
)
)
)
;
possible_parents
.
into_iter
(
)
.
min
(
)
.
and_then
(
|
p
|
match
p
.
parent_by
{
BuilderParentBy
:
:
Children
(
index
)
=
>
{
Some
(
ResolvedParent
:
:
ByChildren
(
*
index
)
)
}
BuilderParentBy
:
:
KnownItem
(
index
)
=
>
{
Some
(
ResolvedParent
:
:
ByParentGuid
(
*
index
)
)
}
BuilderParentBy
:
:
UnknownItem
(
guid
)
=
>
self
.
builder
.
entry_index_by_guid
.
get
(
guid
)
.
filter
(
|
&
&
index
|
self
.
builder
.
entries
[
index
]
.
item
.
is_folder
(
)
)
.
map
(
|
&
index
|
ResolvedParent
:
:
ByParentGuid
(
index
)
)
}
)
.
unwrap_or_else
(
|
|
{
let
parent_index
=
self
.
reparent_orphans_to_default_index
(
)
;
ResolvedParent
:
:
ByParentGuid
(
parent_index
)
}
)
}
}
}
fn
reparent_orphans_to_default_index
(
&
self
)
-
>
Index
{
self
.
builder
.
reparent_orphans_to
.
as_ref
(
)
.
and_then
(
|
guid
|
self
.
builder
.
entry_index_by_guid
.
get
(
guid
)
)
.
cloned
(
)
.
filter
(
|
&
parent_index
|
{
let
parent_entry
=
&
self
.
builder
.
entries
[
parent_index
]
;
parent_entry
.
item
.
is_folder
(
)
}
)
.
unwrap_or
(
0
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
struct
PossibleParent
<
'
a
>
{
builder
:
&
'
a
Builder
parent_by
:
&
'
a
BuilderParentBy
}
impl
<
'
a
>
PossibleParent
<
'
a
>
{
fn
new
(
builder
:
&
'
a
Builder
parent_by
:
&
'
a
BuilderParentBy
)
-
>
PossibleParent
<
'
a
>
{
PossibleParent
{
builder
parent_by
}
}
fn
summarize
(
&
self
)
-
>
DivergedParent
{
let
entry
=
match
self
.
parent_by
{
BuilderParentBy
:
:
Children
(
index
)
=
>
{
return
DivergedParent
:
:
ByChildren
(
self
.
builder
.
entries
[
*
index
]
.
item
.
guid
.
clone
(
)
)
;
}
BuilderParentBy
:
:
KnownItem
(
index
)
=
>
&
self
.
builder
.
entries
[
*
index
]
BuilderParentBy
:
:
UnknownItem
(
guid
)
=
>
{
match
self
.
builder
.
entry_index_by_guid
.
get
(
guid
)
{
Some
(
index
)
=
>
&
self
.
builder
.
entries
[
*
index
]
None
=
>
{
if
self
.
builder
.
deleted_guids
.
contains
(
guid
)
{
return
DivergedParentGuid
:
:
Deleted
(
guid
.
clone
(
)
)
.
into
(
)
;
}
return
DivergedParentGuid
:
:
Missing
(
guid
.
clone
(
)
)
.
into
(
)
;
}
}
}
}
;
if
entry
.
item
.
is_folder
(
)
{
DivergedParentGuid
:
:
Folder
(
entry
.
item
.
guid
.
clone
(
)
)
.
into
(
)
}
else
{
DivergedParentGuid
:
:
NonFolder
(
entry
.
item
.
guid
.
clone
(
)
)
.
into
(
)
}
}
}
impl
<
'
a
>
Ord
for
PossibleParent
<
'
a
>
{
fn
cmp
(
&
self
other
:
&
PossibleParent
<
'
_
>
)
-
>
Ordering
{
let
(
index
other_index
)
=
match
(
&
self
.
parent_by
&
other
.
parent_by
)
{
(
BuilderParentBy
:
:
Children
(
index
)
BuilderParentBy
:
:
Children
(
other_index
)
)
=
>
{
(
*
index
*
other_index
)
}
(
BuilderParentBy
:
:
Children
(
_
)
BuilderParentBy
:
:
KnownItem
(
_
)
)
=
>
{
return
Ordering
:
:
Less
;
}
(
BuilderParentBy
:
:
Children
(
_
)
BuilderParentBy
:
:
UnknownItem
(
_
)
)
=
>
{
return
Ordering
:
:
Less
;
}
(
BuilderParentBy
:
:
KnownItem
(
_
)
BuilderParentBy
:
:
Children
(
_
)
)
=
>
{
return
Ordering
:
:
Greater
;
}
(
BuilderParentBy
:
:
UnknownItem
(
_
)
BuilderParentBy
:
:
Children
(
_
)
)
=
>
{
return
Ordering
:
:
Greater
;
}
_
=
>
return
Ordering
:
:
Equal
}
;
let
entry
=
&
self
.
builder
.
entries
[
index
]
;
let
other_entry
=
&
self
.
builder
.
entries
[
other_index
]
;
match
(
entry
.
item
.
is_folder
(
)
other_entry
.
item
.
is_folder
(
)
)
{
(
true
true
)
=
>
entry
.
item
.
age
.
cmp
(
&
other_entry
.
item
.
age
)
(
false
true
)
=
>
Ordering
:
:
Greater
(
true
false
)
=
>
Ordering
:
:
Less
(
false
false
)
=
>
Ordering
:
:
Equal
}
}
}
impl
<
'
a
>
PartialOrd
for
PossibleParent
<
'
a
>
{
fn
partial_cmp
(
&
self
other
:
&
PossibleParent
<
'
_
>
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
<
'
a
>
PartialEq
for
PossibleParent
<
'
a
>
{
fn
eq
(
&
self
other
:
&
PossibleParent
<
'
_
>
)
-
>
bool
{
self
.
cmp
(
other
)
=
=
Ordering
:
:
Equal
}
}
impl
<
'
a
>
Eq
for
PossibleParent
<
'
a
>
{
}
#
[
derive
(
Debug
)
]
enum
ResolvedParent
{
Root
ByStructure
(
Index
)
ByChildren
(
Index
)
ByParentGuid
(
Index
)
}
impl
ResolvedParent
{
fn
index
(
&
self
)
-
>
Option
<
Index
>
{
match
self
{
ResolvedParent
:
:
Root
=
>
None
ResolvedParent
:
:
ByStructure
(
index
)
|
ResolvedParent
:
:
ByChildren
(
index
)
|
ResolvedParent
:
:
ByParentGuid
(
index
)
=
>
Some
(
*
index
)
}
}
}
fn
detect_cycles
(
parents
:
&
[
ResolvedParent
]
)
-
>
Option
<
Index
>
{
let
mut
seen
=
SmallBitVec
:
:
from_elem
(
parents
.
len
(
)
false
)
;
for
(
entry_index
parent
)
in
parents
.
iter
(
)
.
enumerate
(
)
{
if
seen
[
entry_index
]
{
continue
;
}
let
mut
parent_index
=
parent
.
index
(
)
;
let
mut
grandparent_index
=
parent
.
index
(
)
.
and_then
(
|
index
|
parents
[
index
]
.
index
(
)
)
;
while
let
(
Some
(
i
)
Some
(
j
)
)
=
(
parent_index
grandparent_index
)
{
if
i
=
=
j
{
return
Some
(
i
)
;
}
if
seen
[
i
]
|
|
seen
[
j
]
{
break
;
}
parent_index
=
parent_index
.
and_then
(
|
index
|
parents
[
index
]
.
index
(
)
)
;
grandparent_index
=
grandparent_index
.
and_then
(
|
index
|
parents
[
index
]
.
index
(
)
)
.
and_then
(
|
index
|
parents
[
index
]
.
index
(
)
)
;
}
seen
.
set
(
entry_index
true
)
;
}
None
}
#
[
derive
(
Debug
)
]
enum
Divergence
{
Consistent
Diverged
}
#
[
derive
(
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
enum
Problem
{
Orphan
MisparentedRoot
(
Vec
<
DivergedParent
>
)
DivergedParents
(
Vec
<
DivergedParent
>
)
MissingChild
{
child_guid
:
Guid
}
DeletedChild
{
child_guid
:
Guid
}
}
impl
Problem
{
fn
counts
(
&
self
)
-
>
ProblemCounts
{
let
(
parents
deltas
)
=
match
self
{
Problem
:
:
Orphan
=
>
{
return
ProblemCounts
{
orphans
:
1
.
.
ProblemCounts
:
:
default
(
)
}
}
Problem
:
:
DeletedChild
{
.
.
}
=
>
{
return
ProblemCounts
{
deleted_children
:
1
.
.
ProblemCounts
:
:
default
(
)
}
}
Problem
:
:
MissingChild
{
.
.
}
=
>
{
return
ProblemCounts
{
missing_children
:
1
.
.
ProblemCounts
:
:
default
(
)
}
}
Problem
:
:
MisparentedRoot
(
parents
)
=
>
(
parents
ProblemCounts
{
misparented_roots
:
1
.
.
ProblemCounts
:
:
default
(
)
}
)
Problem
:
:
DivergedParents
(
parents
)
=
>
(
parents
ProblemCounts
:
:
default
(
)
)
}
;
let
deltas
=
match
parents
.
as_slice
(
)
{
[
DivergedParent
:
:
ByChildren
(
_
)
]
|
[
DivergedParent
:
:
ByParentGuid
(
_
)
]
|
[
DivergedParent
:
:
ByChildren
(
_
)
DivergedParent
:
:
ByParentGuid
(
_
)
]
|
[
DivergedParent
:
:
ByParentGuid
(
_
)
DivergedParent
:
:
ByChildren
(
_
)
]
=
>
ProblemCounts
{
parent_child_disagreements
:
1
.
.
deltas
}
_
=
>
ProblemCounts
{
multiple_parents_by_children
:
1
parent_child_disagreements
:
1
.
.
deltas
}
}
;
parents
.
iter
(
)
.
fold
(
deltas
|
deltas
parent
|
match
parent
{
DivergedParent
:
:
ByChildren
(
_
)
=
>
deltas
DivergedParent
:
:
ByParentGuid
(
p
)
=
>
match
p
{
DivergedParentGuid
:
:
Folder
(
_
)
=
>
deltas
DivergedParentGuid
:
:
NonFolder
(
_
)
=
>
{
if
deltas
.
non_folder_parent_guids
>
0
{
deltas
}
else
{
ProblemCounts
{
non_folder_parent_guids
:
1
.
.
deltas
}
}
}
DivergedParentGuid
:
:
Deleted
(
_
)
=
>
{
if
deltas
.
deleted_parent_guids
>
0
{
deltas
}
else
{
ProblemCounts
{
deleted_parent_guids
:
1
.
.
deltas
}
}
}
DivergedParentGuid
:
:
Missing
(
_
)
=
>
{
if
deltas
.
missing_parent_guids
>
0
{
deltas
}
else
{
ProblemCounts
{
missing_parent_guids
:
1
.
.
deltas
}
}
}
}
}
)
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
enum
DivergedParent
{
ByChildren
(
Guid
)
ByParentGuid
(
DivergedParentGuid
)
}
impl
From
<
DivergedParentGuid
>
for
DivergedParent
{
fn
from
(
d
:
DivergedParentGuid
)
-
>
DivergedParent
{
DivergedParent
:
:
ByParentGuid
(
d
)
}
}
impl
fmt
:
:
Display
for
DivergedParent
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
DivergedParent
:
:
ByChildren
(
parent_guid
)
=
>
{
write
!
(
f
"
is
in
children
of
{
}
"
parent_guid
)
}
DivergedParent
:
:
ByParentGuid
(
p
)
=
>
match
p
{
DivergedParentGuid
:
:
Folder
(
parent_guid
)
=
>
write
!
(
f
"
has
parent
{
}
"
parent_guid
)
DivergedParentGuid
:
:
NonFolder
(
parent_guid
)
=
>
{
write
!
(
f
"
has
non
-
folder
parent
{
}
"
parent_guid
)
}
DivergedParentGuid
:
:
Deleted
(
parent_guid
)
=
>
{
write
!
(
f
"
has
deleted
parent
{
}
"
parent_guid
)
}
DivergedParentGuid
:
:
Missing
(
parent_guid
)
=
>
{
write
!
(
f
"
has
nonexistent
parent
{
}
"
parent_guid
)
}
}
}
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
enum
DivergedParentGuid
{
Folder
(
Guid
)
NonFolder
(
Guid
)
Deleted
(
Guid
)
Missing
(
Guid
)
}
#
[
derive
(
Debug
Default
)
]
pub
struct
Problems
(
HashMap
<
Guid
Vec
<
Problem
>
>
)
;
impl
Problems
{
#
[
inline
]
pub
fn
note
(
&
mut
self
guid
:
&
Guid
problem
:
Problem
)
-
>
&
mut
Problems
{
self
.
0
.
entry
(
guid
.
clone
(
)
)
.
or_default
(
)
.
push
(
problem
)
;
self
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
pub
fn
summarize
(
&
self
)
-
>
impl
Iterator
<
Item
=
ProblemSummary
<
'
_
>
>
{
self
.
0
.
iter
(
)
.
flat_map
(
|
(
guid
problems
)
|
{
problems
.
iter
(
)
.
map
(
move
|
problem
|
ProblemSummary
(
guid
problem
)
)
}
)
}
pub
fn
counts
(
&
self
)
-
>
ProblemCounts
{
self
.
0
.
values
(
)
.
flatten
(
)
.
fold
(
ProblemCounts
:
:
default
(
)
|
totals
problem
|
{
totals
.
add
(
problem
.
counts
(
)
)
}
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
ProblemSummary
<
'
a
>
(
&
'
a
Guid
&
'
a
Problem
)
;
impl
<
'
a
>
ProblemSummary
<
'
a
>
{
#
[
inline
]
pub
fn
guid
(
&
self
)
-
>
&
Guid
{
&
self
.
0
}
#
[
inline
]
pub
fn
problem
(
&
self
)
-
>
&
Problem
{
&
self
.
1
}
}
impl
<
'
a
>
fmt
:
:
Display
for
ProblemSummary
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
parents
=
match
self
.
problem
(
)
{
Problem
:
:
Orphan
=
>
return
write
!
(
f
"
{
}
is
an
orphan
"
self
.
guid
(
)
)
Problem
:
:
MisparentedRoot
(
parents
)
=
>
{
write
!
(
f
"
{
}
is
a
user
content
root
"
self
.
guid
(
)
)
?
;
if
parents
.
is_empty
(
)
{
return
Ok
(
(
)
)
;
}
f
.
write_str
(
"
but
"
)
?
;
parents
}
Problem
:
:
DivergedParents
(
parents
)
=
>
{
if
parents
.
is_empty
(
)
{
return
write
!
(
f
"
{
}
has
diverged
parents
"
self
.
guid
(
)
)
;
}
write
!
(
f
"
{
}
"
self
.
guid
(
)
)
?
;
parents
}
Problem
:
:
MissingChild
{
child_guid
}
=
>
{
return
write
!
(
f
"
{
}
has
nonexistent
child
{
}
"
self
.
guid
(
)
child_guid
)
;
}
Problem
:
:
DeletedChild
{
child_guid
}
=
>
{
return
write
!
(
f
"
{
}
has
deleted
child
{
}
"
self
.
guid
(
)
child_guid
)
;
}
}
;
match
parents
.
as_slice
(
)
{
[
a
]
=
>
write
!
(
f
"
{
}
"
a
)
?
[
a
b
]
=
>
write
!
(
f
"
{
}
and
{
}
"
a
b
)
?
_
=
>
{
for
(
i
parent
)
in
parents
.
iter
(
)
.
enumerate
(
)
{
if
i
!
=
0
{
f
.
write_str
(
"
"
)
?
;
}
if
i
=
=
parents
.
len
(
)
-
1
{
f
.
write_str
(
"
and
"
)
?
;
}
write
!
(
f
"
{
}
"
parent
)
?
;
}
}
}
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Copy
Default
Debug
Eq
Hash
PartialEq
)
]
pub
struct
ProblemCounts
{
pub
orphans
:
usize
pub
misparented_roots
:
usize
pub
multiple_parents_by_children
:
usize
pub
deleted_parent_guids
:
usize
pub
missing_parent_guids
:
usize
pub
non_folder_parent_guids
:
usize
pub
parent_child_disagreements
:
usize
pub
deleted_children
:
usize
pub
missing_children
:
usize
}
impl
ProblemCounts
{
pub
fn
add
(
&
self
other
:
ProblemCounts
)
-
>
ProblemCounts
{
ProblemCounts
{
orphans
:
self
.
orphans
+
other
.
orphans
misparented_roots
:
self
.
misparented_roots
+
other
.
misparented_roots
multiple_parents_by_children
:
self
.
multiple_parents_by_children
+
other
.
multiple_parents_by_children
deleted_parent_guids
:
self
.
deleted_parent_guids
+
other
.
deleted_parent_guids
missing_parent_guids
:
self
.
missing_parent_guids
+
other
.
missing_parent_guids
non_folder_parent_guids
:
self
.
non_folder_parent_guids
+
other
.
non_folder_parent_guids
parent_child_disagreements
:
self
.
parent_child_disagreements
+
other
.
parent_child_disagreements
deleted_children
:
self
.
deleted_children
+
other
.
deleted_children
missing_children
:
self
.
missing_children
+
other
.
missing_children
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
Node
<
'
t
>
(
&
'
t
Tree
&
'
t
TreeEntry
)
;
impl
<
'
t
>
Node
<
'
t
>
{
#
[
inline
]
pub
fn
item
(
&
self
)
-
>
&
'
t
Item
{
&
self
.
1
.
item
}
#
[
inline
]
pub
fn
content
(
&
self
)
-
>
Option
<
&
'
t
Content
>
{
self
.
1
.
content
.
as_ref
(
)
}
pub
fn
children
<
'
n
>
(
&
'
n
self
)
-
>
impl
Iterator
<
Item
=
Node
<
'
t
>
>
+
'
n
{
self
.
1
.
child_indices
.
iter
(
)
.
map
(
move
|
&
child_index
|
Node
(
self
.
0
&
self
.
0
.
entries
[
child_index
]
)
)
}
pub
fn
child
(
&
self
index
:
usize
)
-
>
Option
<
Node
<
'
_
>
>
{
self
.
1
.
child_indices
.
get
(
index
)
.
map
(
|
&
child_index
|
Node
(
self
.
0
&
self
.
0
.
entries
[
child_index
]
)
)
}
pub
fn
has_matching_children
<
'
u
>
(
&
self
other
:
Node
<
'
u
>
)
-
>
bool
{
if
self
.
1
.
child_indices
.
len
(
)
!
=
other
.
1
.
child_indices
.
len
(
)
{
return
false
;
}
for
(
index
&
child_index
)
in
self
.
1
.
child_indices
.
iter
(
)
.
enumerate
(
)
{
let
guid
=
&
self
.
0
.
entries
[
child_index
]
.
item
.
guid
;
let
other_guid
=
&
other
.
0
.
entries
[
other
.
1
.
child_indices
[
index
]
]
.
item
.
guid
;
if
guid
!
=
other_guid
{
return
false
;
}
}
true
}
pub
fn
parent
(
&
self
)
-
>
Option
<
Node
<
'
_
>
>
{
self
.
1
.
parent_index
.
as_ref
(
)
.
map
(
|
&
parent_index
|
Node
(
self
.
0
&
self
.
0
.
entries
[
parent_index
]
)
)
}
pub
fn
level
(
&
self
)
-
>
i64
{
if
self
.
is_root
(
)
{
return
0
;
}
self
.
parent
(
)
.
map_or
(
-
1
|
parent
|
parent
.
level
(
)
+
1
)
}
pub
fn
is_syncable
(
&
self
)
-
>
bool
{
if
self
.
is_root
(
)
{
return
false
;
}
if
self
.
is_built_in_root
(
)
{
return
true
;
}
match
self
.
kind
{
Kind
:
:
Livemark
=
>
false
Kind
:
:
Query
if
self
.
diverged
(
)
=
>
false
_
=
>
self
.
parent
(
)
.
map_or
(
false
|
parent
|
parent
.
is_syncable
(
)
)
}
}
#
[
inline
]
pub
fn
diverged
(
&
self
)
-
>
bool
{
match
&
self
.
1
.
divergence
{
Divergence
:
:
Diverged
=
>
true
Divergence
:
:
Consistent
=
>
false
}
}
pub
fn
to_ascii_string
(
&
self
)
-
>
String
{
self
.
to_ascii_fragment
(
"
"
)
}
fn
to_ascii_fragment
(
&
self
prefix
:
&
str
)
-
>
String
{
match
self
.
item
(
)
.
kind
{
Kind
:
:
Folder
=
>
{
let
children_prefix
=
format
!
(
"
{
}
|
"
prefix
)
;
let
children
=
self
.
children
(
)
.
map
(
|
n
|
n
.
to_ascii_fragment
(
&
children_prefix
)
)
.
collect
:
:
<
Vec
<
String
>
>
(
)
;
let
kind
=
if
self
.
diverged
(
)
{
"
"
}
else
{
"
"
}
;
if
children
.
is_empty
(
)
{
format
!
(
"
{
}
{
}
{
}
"
prefix
kind
self
.
item
(
)
)
}
else
{
format
!
(
"
{
}
{
}
{
}
\
n
{
}
"
prefix
kind
self
.
item
(
)
children
.
join
(
"
\
n
"
)
)
}
}
_
=
>
{
let
kind
=
if
self
.
diverged
(
)
{
"
"
}
else
{
"
"
}
;
format
!
(
"
{
}
{
}
{
}
"
prefix
kind
self
.
item
(
)
)
}
}
}
#
[
inline
]
pub
fn
is_root
(
&
self
)
-
>
bool
{
ptr
:
:
eq
(
self
.
1
&
self
.
0
.
entries
[
0
]
)
}
#
[
inline
]
pub
fn
is_built_in_root
(
&
self
)
-
>
bool
{
self
.
item
(
)
.
guid
.
is_built_in_root
(
)
}
}
impl
<
'
t
>
Deref
for
Node
<
'
t
>
{
type
Target
=
Item
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
Item
{
self
.
item
(
)
}
}
impl
<
'
t
>
fmt
:
:
Display
for
Node
<
'
t
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
item
(
)
.
fmt
(
f
)
}
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
pub
struct
Item
{
pub
guid
:
Guid
pub
kind
:
Kind
pub
age
:
i64
pub
needs_merge
:
bool
pub
validity
:
Validity
}
impl
Item
{
#
[
inline
]
pub
fn
new
(
guid
:
Guid
kind
:
Kind
)
-
>
Item
{
Item
{
guid
kind
age
:
0
needs_merge
:
false
validity
:
Validity
:
:
Valid
}
}
#
[
inline
]
pub
fn
is_folder
(
&
self
)
-
>
bool
{
self
.
kind
=
=
Kind
:
:
Folder
}
#
[
inline
]
pub
fn
has_compatible_kind
(
&
self
remote_node
:
&
Item
)
-
>
bool
{
match
(
&
self
.
kind
&
remote_node
.
kind
)
{
(
Kind
:
:
Bookmark
Kind
:
:
Query
)
=
>
true
(
Kind
:
:
Query
Kind
:
:
Bookmark
)
=
>
true
(
local_kind
remote_kind
)
=
>
local_kind
=
=
remote_kind
}
}
}
impl
fmt
:
:
Display
for
Item
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
kind
=
match
self
.
validity
{
Validity
:
:
Valid
=
>
format
!
(
"
{
}
"
self
.
kind
)
Validity
:
:
Reupload
|
Validity
:
:
Replace
=
>
format
!
(
"
{
}
(
{
}
)
"
self
.
kind
self
.
validity
)
}
;
let
info
=
if
self
.
needs_merge
{
format
!
(
"
{
}
;
Age
=
{
}
ms
;
Unmerged
"
kind
self
.
age
)
}
else
{
format
!
(
"
{
}
;
Age
=
{
}
ms
"
kind
self
.
age
)
}
;
write
!
(
f
"
{
}
(
{
}
)
"
self
.
guid
info
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
Kind
{
Bookmark
Query
Folder
Livemark
Separator
}
impl
fmt
:
:
Display
for
Kind
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
Validity
{
Valid
Reupload
Replace
}
impl
fmt
:
:
Display
for
Validity
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
MergedNode
<
'
t
>
{
pub
guid
:
Guid
pub
merge_state
:
MergeState
<
'
t
>
pub
merged_children
:
Vec
<
MergedNode
<
'
t
>
>
}
impl
<
'
t
>
MergedNode
<
'
t
>
{
pub
fn
new
(
guid
:
Guid
merge_state
:
MergeState
<
'
t
>
)
-
>
MergedNode
<
'
t
>
{
MergedNode
{
guid
merge_state
merged_children
:
Vec
:
:
new
(
)
}
}
pub
fn
local_guid_changed
(
&
self
)
-
>
bool
{
self
.
merge_state
.
local_node
(
)
.
map_or
(
false
|
local_node
|
local_node
.
guid
!
=
self
.
guid
)
}
pub
fn
remote_guid_changed
(
&
self
)
-
>
bool
{
self
.
merge_state
.
remote_node
(
)
.
map_or
(
false
|
remote_node
|
remote_node
.
guid
!
=
self
.
guid
)
}
#
[
inline
]
pub
fn
to_ascii_string
(
&
self
)
-
>
String
{
self
.
to_ascii_fragment
(
"
"
)
}
fn
to_ascii_fragment
(
&
self
prefix
:
&
str
)
-
>
String
{
match
self
.
merge_state
.
node
(
)
.
kind
{
Kind
:
:
Folder
=
>
{
let
children_prefix
=
format
!
(
"
{
}
|
"
prefix
)
;
let
children
=
self
.
merged_children
.
iter
(
)
.
map
(
|
n
|
n
.
to_ascii_fragment
(
&
children_prefix
)
)
.
collect
:
:
<
Vec
<
String
>
>
(
)
;
if
children
.
is_empty
(
)
{
format
!
(
"
{
}
{
}
"
prefix
&
self
)
}
else
{
format
!
(
"
{
}
{
}
\
n
{
}
"
prefix
&
self
children
.
join
(
"
\
n
"
)
)
}
}
_
=
>
format
!
(
"
{
}
{
}
"
prefix
&
self
)
}
}
}
impl
<
'
t
>
fmt
:
:
Display
for
MergedNode
<
'
t
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
{
}
"
self
.
guid
self
.
merge_state
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
MergeState
<
'
t
>
{
LocalOnly
(
Node
<
'
t
>
)
LocalOnlyWithNewLocalStructure
(
Node
<
'
t
>
)
RemoteOnly
(
Node
<
'
t
>
)
RemoteOnlyWithNewRemoteStructure
(
Node
<
'
t
>
)
Local
{
local_node
:
Node
<
'
t
>
remote_node
:
Node
<
'
t
>
}
LocalWithNewLocalStructure
{
local_node
:
Node
<
'
t
>
remote_node
:
Node
<
'
t
>
}
Remote
{
local_node
:
Node
<
'
t
>
remote_node
:
Node
<
'
t
>
}
RemoteWithNewRemoteStructure
{
local_node
:
Node
<
'
t
>
remote_node
:
Node
<
'
t
>
}
Unchanged
{
local_node
:
Node
<
'
t
>
remote_node
:
Node
<
'
t
>
}
UnchangedWithNewLocalStructure
{
local_node
:
Node
<
'
t
>
remote_node
:
Node
<
'
t
>
}
}
impl
<
'
t
>
MergeState
<
'
t
>
{
pub
fn
local_node
(
&
self
)
-
>
Option
<
&
Node
<
'
t
>
>
{
match
self
{
MergeState
:
:
LocalOnly
(
local_node
)
|
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
local_node
)
|
MergeState
:
:
Local
{
local_node
.
.
}
|
MergeState
:
:
LocalWithNewLocalStructure
{
local_node
.
.
}
|
MergeState
:
:
Remote
{
local_node
.
.
}
|
MergeState
:
:
RemoteWithNewRemoteStructure
{
local_node
.
.
}
|
MergeState
:
:
Unchanged
{
local_node
.
.
}
|
MergeState
:
:
UnchangedWithNewLocalStructure
{
local_node
.
.
}
=
>
Some
(
local_node
)
MergeState
:
:
RemoteOnly
(
_
)
|
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
_
)
=
>
None
}
}
pub
fn
remote_node
(
&
self
)
-
>
Option
<
&
Node
<
'
t
>
>
{
match
self
{
MergeState
:
:
Local
{
remote_node
.
.
}
|
MergeState
:
:
LocalWithNewLocalStructure
{
remote_node
.
.
}
|
MergeState
:
:
RemoteOnly
(
remote_node
)
|
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
remote_node
)
|
MergeState
:
:
Remote
{
remote_node
.
.
}
|
MergeState
:
:
RemoteWithNewRemoteStructure
{
remote_node
.
.
}
|
MergeState
:
:
Unchanged
{
remote_node
.
.
}
|
MergeState
:
:
UnchangedWithNewLocalStructure
{
remote_node
.
.
}
=
>
Some
(
remote_node
)
MergeState
:
:
LocalOnly
(
_
)
|
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
_
)
=
>
None
}
}
pub
fn
should_apply_item
(
&
self
)
-
>
bool
{
match
self
{
MergeState
:
:
RemoteOnly
(
_
)
|
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
_
)
|
MergeState
:
:
Remote
{
.
.
}
|
MergeState
:
:
RemoteWithNewRemoteStructure
{
.
.
}
=
>
true
MergeState
:
:
LocalOnly
(
_
)
|
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
_
)
|
MergeState
:
:
Local
{
.
.
}
|
MergeState
:
:
LocalWithNewLocalStructure
{
.
.
}
|
MergeState
:
:
Unchanged
{
.
.
}
|
MergeState
:
:
UnchangedWithNewLocalStructure
{
.
.
}
=
>
false
}
}
pub
fn
should_apply_structure
(
&
self
)
-
>
bool
{
match
self
{
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
_
)
|
MergeState
:
:
LocalWithNewLocalStructure
{
.
.
}
|
MergeState
:
:
RemoteOnly
(
_
)
|
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
_
)
|
MergeState
:
:
Remote
{
.
.
}
|
MergeState
:
:
RemoteWithNewRemoteStructure
{
.
.
}
|
MergeState
:
:
UnchangedWithNewLocalStructure
{
.
.
}
=
>
true
MergeState
:
:
LocalOnly
(
_
)
|
MergeState
:
:
Local
{
.
.
}
|
MergeState
:
:
Unchanged
{
.
.
}
=
>
{
false
}
}
}
pub
fn
should_upload
(
&
self
)
-
>
bool
{
match
self
{
MergeState
:
:
LocalOnly
(
_
)
|
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
_
)
|
MergeState
:
:
Local
{
.
.
}
|
MergeState
:
:
LocalWithNewLocalStructure
{
.
.
}
|
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
_
)
|
MergeState
:
:
RemoteWithNewRemoteStructure
{
.
.
}
=
>
true
MergeState
:
:
RemoteOnly
(
_
)
|
MergeState
:
:
Remote
{
.
.
}
|
MergeState
:
:
Unchanged
{
.
.
}
|
MergeState
:
:
UnchangedWithNewLocalStructure
{
.
.
}
=
>
false
}
}
pub
fn
with_new_local_structure
(
self
)
-
>
MergeState
<
'
t
>
{
match
self
{
MergeState
:
:
LocalOnly
(
local_node
)
=
>
{
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
local_node
)
}
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
local_node
)
=
>
{
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
local_node
)
}
MergeState
:
:
Local
{
local_node
remote_node
}
=
>
MergeState
:
:
LocalWithNewLocalStructure
{
local_node
remote_node
}
MergeState
:
:
LocalWithNewLocalStructure
{
local_node
remote_node
}
=
>
MergeState
:
:
LocalWithNewLocalStructure
{
local_node
remote_node
}
MergeState
:
:
RemoteOnly
(
remote_node
)
=
>
MergeState
:
:
RemoteOnly
(
remote_node
)
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
local_node
)
=
>
{
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
local_node
)
}
MergeState
:
:
Remote
{
local_node
remote_node
}
=
>
MergeState
:
:
Remote
{
local_node
remote_node
}
MergeState
:
:
RemoteWithNewRemoteStructure
{
local_node
remote_node
}
=
>
MergeState
:
:
RemoteWithNewRemoteStructure
{
local_node
remote_node
}
MergeState
:
:
Unchanged
{
local_node
remote_node
}
=
>
{
MergeState
:
:
UnchangedWithNewLocalStructure
{
local_node
remote_node
}
}
MergeState
:
:
UnchangedWithNewLocalStructure
{
local_node
remote_node
}
=
>
MergeState
:
:
UnchangedWithNewLocalStructure
{
local_node
remote_node
}
}
}
pub
fn
with_new_remote_structure
(
self
)
-
>
MergeState
<
'
t
>
{
match
self
{
MergeState
:
:
LocalOnly
(
local_node
)
=
>
MergeState
:
:
LocalOnly
(
local_node
)
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
local_node
)
=
>
{
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
local_node
)
}
MergeState
:
:
Local
{
local_node
remote_node
}
=
>
MergeState
:
:
Local
{
local_node
remote_node
}
MergeState
:
:
LocalWithNewLocalStructure
{
local_node
remote_node
}
=
>
MergeState
:
:
LocalWithNewLocalStructure
{
local_node
remote_node
}
MergeState
:
:
RemoteOnly
(
remote_node
)
=
>
{
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
remote_node
)
}
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
remote_node
)
=
>
{
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
remote_node
)
}
MergeState
:
:
Remote
{
local_node
remote_node
}
=
>
MergeState
:
:
RemoteWithNewRemoteStructure
{
local_node
remote_node
}
MergeState
:
:
RemoteWithNewRemoteStructure
{
local_node
remote_node
}
=
>
MergeState
:
:
RemoteWithNewRemoteStructure
{
local_node
remote_node
}
MergeState
:
:
Unchanged
{
local_node
remote_node
}
=
>
{
MergeState
:
:
Local
{
local_node
remote_node
}
}
MergeState
:
:
UnchangedWithNewLocalStructure
{
local_node
remote_node
}
=
>
MergeState
:
:
LocalWithNewLocalStructure
{
local_node
remote_node
}
}
}
fn
node
(
&
self
)
-
>
&
Node
<
'
t
>
{
match
self
{
MergeState
:
:
LocalOnly
(
local_node
)
|
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
local_node
)
|
MergeState
:
:
Local
{
local_node
.
.
}
|
MergeState
:
:
LocalWithNewLocalStructure
{
local_node
.
.
}
|
MergeState
:
:
Unchanged
{
local_node
.
.
}
|
MergeState
:
:
UnchangedWithNewLocalStructure
{
local_node
.
.
}
=
>
local_node
MergeState
:
:
RemoteOnly
(
remote_node
)
|
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
remote_node
)
|
MergeState
:
:
Remote
{
remote_node
.
.
}
|
MergeState
:
:
RemoteWithNewRemoteStructure
{
remote_node
.
.
}
=
>
remote_node
}
}
}
impl
<
'
t
>
fmt
:
:
Display
for
MergeState
<
'
t
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
match
self
{
MergeState
:
:
LocalOnly
(
_
)
|
MergeState
:
:
Local
{
.
.
}
=
>
"
(
Local
Local
)
"
MergeState
:
:
LocalOnlyWithNewLocalStructure
(
_
)
|
MergeState
:
:
LocalWithNewLocalStructure
{
.
.
}
=
>
"
(
Local
New
)
"
MergeState
:
:
RemoteOnly
(
_
)
|
MergeState
:
:
Remote
{
.
.
}
=
>
"
(
Remote
Remote
)
"
MergeState
:
:
RemoteOnlyWithNewRemoteStructure
(
_
)
|
MergeState
:
:
RemoteWithNewRemoteStructure
{
.
.
}
=
>
"
(
Remote
New
)
"
MergeState
:
:
Unchanged
{
.
.
}
=
>
"
(
Unchanged
Unchanged
)
"
MergeState
:
:
UnchangedWithNewLocalStructure
{
.
.
}
=
>
"
(
Unchanged
New
)
"
}
)
}
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
enum
Content
{
Bookmark
{
title
:
String
url_href
:
String
}
Folder
{
title
:
String
}
Separator
}
