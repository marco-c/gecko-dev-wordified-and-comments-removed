use
std
:
:
{
cmp
:
:
Ordering
collections
:
:
{
HashMap
HashSet
}
fmt
mem
ops
:
:
Deref
ptr
}
;
use
smallbitvec
:
:
SmallBitVec
;
use
crate
:
:
error
:
:
{
ErrorKind
Result
}
;
use
crate
:
:
guid
:
:
Guid
;
type
Index
=
usize
;
pub
trait
IntoTree
{
fn
into_tree
(
self
)
-
>
Result
<
Tree
>
;
}
#
[
derive
(
Debug
)
]
pub
struct
Tree
{
entry_index_by_guid
:
HashMap
<
Guid
Index
>
entries
:
Vec
<
TreeEntry
>
deleted_guids
:
HashSet
<
Guid
>
}
impl
Tree
{
pub
fn
with_root
(
root
:
Item
)
-
>
Builder
{
let
mut
entry_index_by_guid
=
HashMap
:
:
new
(
)
;
entry_index_by_guid
.
insert
(
root
.
guid
.
clone
(
)
0
)
;
Builder
{
entries
:
vec
!
[
BuilderEntry
{
item
:
root
parent
:
BuilderEntryParent
:
:
Root
children
:
Vec
:
:
new
(
)
}
]
entry_index_by_guid
reparent_orphans_to
:
None
}
}
#
[
inline
]
pub
fn
root
(
&
self
)
-
>
Node
{
Node
(
self
&
self
.
entries
[
0
]
)
}
#
[
inline
]
pub
fn
deletions
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Guid
>
{
self
.
deleted_guids
.
iter
(
)
}
#
[
inline
]
pub
fn
is_deleted
(
&
self
guid
:
&
Guid
)
-
>
bool
{
self
.
deleted_guids
.
contains
(
guid
)
}
#
[
inline
]
pub
fn
note_deleted
(
&
mut
self
guid
:
Guid
)
{
self
.
deleted_guids
.
insert
(
guid
)
;
}
pub
fn
guids
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Guid
>
{
assert_eq
!
(
self
.
entries
.
len
(
)
self
.
entry_index_by_guid
.
len
(
)
)
;
self
.
entries
.
iter
(
)
.
map
(
|
entry
|
&
entry
.
item
.
guid
)
.
chain
(
self
.
deleted_guids
.
iter
(
)
)
}
pub
fn
node_for_guid
(
&
self
guid
:
&
Guid
)
-
>
Option
<
Node
>
{
assert_eq
!
(
self
.
entries
.
len
(
)
self
.
entry_index_by_guid
.
len
(
)
)
;
self
.
entry_index_by_guid
.
get
(
guid
)
.
map
(
|
&
index
|
Node
(
self
&
self
.
entries
[
index
]
)
)
}
}
impl
IntoTree
for
Tree
{
#
[
inline
]
fn
into_tree
(
self
)
-
>
Result
<
Tree
>
{
Ok
(
self
)
}
}
impl
fmt
:
:
Display
for
Tree
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
root
=
self
.
root
(
)
;
let
deleted_guids
=
self
.
deleted_guids
.
iter
(
)
.
map
(
|
guid
|
guid
.
as_ref
(
)
)
.
collect
:
:
<
Vec
<
&
str
>
>
(
)
;
match
deleted_guids
.
len
(
)
{
0
=
>
write
!
(
f
"
{
}
"
root
.
to_ascii_string
(
)
)
_
=
>
write
!
(
f
"
{
}
\
nDeleted
:
[
{
}
]
"
root
.
to_ascii_string
(
)
deleted_guids
.
join
(
"
"
)
)
}
}
}
#
[
cfg
(
test
)
]
impl
PartialEq
for
Tree
{
fn
eq
(
&
self
other
:
&
Tree
)
-
>
bool
{
self
.
root
(
)
=
=
other
.
root
(
)
&
&
self
.
deletions
(
)
.
eq
(
other
.
deletions
(
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Builder
{
entry_index_by_guid
:
HashMap
<
Guid
Index
>
entries
:
Vec
<
BuilderEntry
>
reparent_orphans_to
:
Option
<
Guid
>
}
impl
Builder
{
#
[
inline
]
pub
fn
reparent_orphans_to
(
&
mut
self
guid
:
&
Guid
)
-
>
&
mut
Builder
{
self
.
reparent_orphans_to
=
Some
(
guid
.
clone
(
)
)
;
self
}
pub
fn
item
(
&
mut
self
item
:
Item
)
-
>
Result
<
ParentBuilder
>
{
assert_eq
!
(
self
.
entries
.
len
(
)
self
.
entry_index_by_guid
.
len
(
)
)
;
if
self
.
entry_index_by_guid
.
contains_key
(
&
item
.
guid
)
{
return
Err
(
ErrorKind
:
:
DuplicateItem
(
item
.
guid
.
clone
(
)
)
.
into
(
)
)
;
}
self
.
entry_index_by_guid
.
insert
(
item
.
guid
.
clone
(
)
self
.
entries
.
len
(
)
)
;
let
entry_child
=
BuilderEntryChild
:
:
Exists
(
self
.
entries
.
len
(
)
)
;
self
.
entries
.
push
(
BuilderEntry
{
item
parent
:
BuilderEntryParent
:
:
None
children
:
Vec
:
:
new
(
)
}
)
;
Ok
(
ParentBuilder
(
self
entry_child
)
)
}
pub
fn
parent_for
(
&
mut
self
child_guid
:
&
Guid
)
-
>
ParentBuilder
{
assert_eq
!
(
self
.
entries
.
len
(
)
self
.
entry_index_by_guid
.
len
(
)
)
;
let
entry_child
=
match
self
.
entry_index_by_guid
.
get
(
child_guid
)
{
Some
(
&
child_index
)
=
>
BuilderEntryChild
:
:
Exists
(
child_index
)
None
=
>
BuilderEntryChild
:
:
Missing
(
child_guid
.
clone
(
)
)
}
;
ParentBuilder
(
self
entry_child
)
}
fn
reparent_orphans_to_default_index
(
&
self
)
-
>
Index
{
self
.
reparent_orphans_to
.
as_ref
(
)
.
and_then
(
|
guid
|
self
.
entry_index_by_guid
.
get
(
guid
)
)
.
cloned
(
)
.
filter
(
|
&
parent_index
|
{
let
parent_entry
=
&
self
.
entries
[
parent_index
]
;
parent_entry
.
item
.
is_folder
(
)
}
)
.
unwrap_or
(
0
)
}
fn
resolve
(
&
self
)
-
>
(
Vec
<
ResolvedParent
>
HashMap
<
Index
Vec
<
Index
>
>
)
{
let
mut
parents
=
Vec
:
:
with_capacity
(
self
.
entries
.
len
(
)
)
;
let
mut
reparented_orphans_by_parent
:
HashMap
<
Index
Vec
<
Index
>
>
=
HashMap
:
:
new
(
)
;
for
(
entry_index
entry
)
in
self
.
entries
.
iter
(
)
.
enumerate
(
)
{
let
mut
resolved_parent
=
match
&
entry
.
parent
{
BuilderEntryParent
:
:
Root
=
>
ResolvedParent
:
:
Root
BuilderEntryParent
:
:
None
=
>
{
let
parent_index
=
self
.
reparent_orphans_to_default_index
(
)
;
ResolvedParent
:
:
ByParentGuid
(
parent_index
)
}
BuilderEntryParent
:
:
Complete
(
index
)
=
>
{
ResolvedParent
:
:
Unchanged
(
*
index
)
}
BuilderEntryParent
:
:
Partial
(
parents
)
=
>
match
parents
.
as_slice
(
)
{
[
BuilderParentBy
:
:
UnknownItem
(
by_item
)
BuilderParentBy
:
:
Children
(
by_children
)
]
|
[
BuilderParentBy
:
:
Children
(
by_children
)
BuilderParentBy
:
:
UnknownItem
(
by_item
)
]
=
>
{
self
.
entry_index_by_guid
.
get
(
by_item
)
.
filter
(
|
by_item
|
by_item
=
=
&
by_children
)
.
map
(
|
&
by_item
|
{
ResolvedParent
:
:
Unchanged
(
by_item
)
}
)
.
unwrap_or_else
(
|
|
ResolvedParent
:
:
ByChildren
(
*
by_children
)
)
}
parents
=
>
{
parents
.
iter
(
)
.
min_by
(
|
parent
other_parent
|
{
let
(
parent_index
other_parent_index
)
=
match
(
parent
other_parent
)
{
(
BuilderParentBy
:
:
Children
(
parent_index
)
BuilderParentBy
:
:
Children
(
other_parent_index
)
)
=
>
(
*
parent_index
*
other_parent_index
)
(
BuilderParentBy
:
:
Children
(
_
)
BuilderParentBy
:
:
KnownItem
(
_
)
)
=
>
{
return
Ordering
:
:
Less
;
}
(
BuilderParentBy
:
:
Children
(
_
)
BuilderParentBy
:
:
UnknownItem
(
_
)
)
=
>
{
return
Ordering
:
:
Less
;
}
(
BuilderParentBy
:
:
KnownItem
(
parent_index
)
BuilderParentBy
:
:
KnownItem
(
other_parent_index
)
)
=
>
(
*
parent_index
*
other_parent_index
)
(
BuilderParentBy
:
:
KnownItem
(
_
)
BuilderParentBy
:
:
Children
(
_
)
)
=
>
{
return
Ordering
:
:
Greater
;
}
(
BuilderParentBy
:
:
KnownItem
(
_
)
BuilderParentBy
:
:
UnknownItem
(
_
)
)
=
>
{
return
Ordering
:
:
Less
;
}
(
BuilderParentBy
:
:
UnknownItem
(
parent_guid
)
BuilderParentBy
:
:
UnknownItem
(
other_parent_guid
)
)
=
>
{
match
(
self
.
entry_index_by_guid
.
get
(
parent_guid
)
self
.
entry_index_by_guid
.
get
(
other_parent_guid
)
)
{
(
Some
(
parent_index
)
Some
(
other_parent_index
)
)
=
>
{
(
*
parent_index
*
other_parent_index
)
}
(
Some
(
_
)
None
)
=
>
return
Ordering
:
:
Less
(
None
Some
(
_
)
)
=
>
return
Ordering
:
:
Greater
(
None
None
)
=
>
return
Ordering
:
:
Equal
}
}
(
BuilderParentBy
:
:
UnknownItem
(
_
)
BuilderParentBy
:
:
Children
(
_
)
)
=
>
{
return
Ordering
:
:
Greater
;
}
(
BuilderParentBy
:
:
UnknownItem
(
_
)
BuilderParentBy
:
:
KnownItem
(
_
)
)
=
>
{
return
Ordering
:
:
Greater
;
}
}
;
let
parent_entry
=
&
self
.
entries
[
parent_index
]
;
let
other_parent_entry
=
&
self
.
entries
[
other_parent_index
]
;
parent_entry
.
item
.
age
.
cmp
(
&
other_parent_entry
.
item
.
age
)
}
)
.
and_then
(
|
parent_from
|
match
parent_from
{
BuilderParentBy
:
:
Children
(
index
)
=
>
{
Some
(
ResolvedParent
:
:
ByChildren
(
*
index
)
)
}
BuilderParentBy
:
:
KnownItem
(
index
)
=
>
{
Some
(
ResolvedParent
:
:
ByParentGuid
(
*
index
)
)
}
BuilderParentBy
:
:
UnknownItem
(
guid
)
=
>
self
.
entry_index_by_guid
.
get
(
guid
)
.
filter
(
|
&
&
index
|
self
.
entries
[
index
]
.
item
.
is_folder
(
)
)
.
map
(
|
&
index
|
ResolvedParent
:
:
ByParentGuid
(
index
)
)
}
)
.
unwrap_or_else
(
|
|
{
let
parent_index
=
self
.
reparent_orphans_to_default_index
(
)
;
ResolvedParent
:
:
ByParentGuid
(
parent_index
)
}
)
}
}
}
;
if
entry
.
item
.
guid
.
is_user_content_root
(
)
{
resolved_parent
=
match
resolved_parent
{
ResolvedParent
:
:
Unchanged
(
parent_index
)
if
parent_index
=
=
0
=
>
{
ResolvedParent
:
:
Unchanged
(
parent_index
)
}
_
=
>
ResolvedParent
:
:
ByParentGuid
(
0
)
}
;
}
if
let
ResolvedParent
:
:
ByParentGuid
(
parent_index
)
=
&
resolved_parent
{
let
reparented_orphans
=
reparented_orphans_by_parent
.
entry
(
*
parent_index
)
.
or_default
(
)
;
reparented_orphans
.
push
(
entry_index
)
;
}
parents
.
push
(
resolved_parent
)
;
}
(
parents
reparented_orphans_by_parent
)
}
}
impl
IntoTree
for
Builder
{
fn
into_tree
(
self
)
-
>
Result
<
Tree
>
{
let
(
parents
mut
reparented_orphans_by_parent
)
=
self
.
resolve
(
)
;
if
let
Some
(
index
)
=
detect_cycles
(
&
parents
)
{
return
Err
(
ErrorKind
:
:
Cycle
(
self
.
entries
[
index
]
.
item
.
guid
.
clone
(
)
)
.
into
(
)
)
;
}
for
reparented_orphans
in
reparented_orphans_by_parent
.
values_mut
(
)
{
reparented_orphans
.
sort_unstable_by
(
|
&
index
&
other_index
|
{
self
.
entries
[
index
]
.
item
.
guid
.
cmp
(
&
self
.
entries
[
other_index
]
.
item
.
guid
)
}
)
;
}
let
entries
=
self
.
entries
.
into_iter
(
)
.
enumerate
(
)
.
map
(
|
(
entry_index
entry
)
|
{
let
mut
divergence
=
Divergence
:
:
Consistent
;
let
parent_index
=
match
&
parents
[
entry_index
]
{
ResolvedParent
:
:
Root
=
>
None
ResolvedParent
:
:
Unchanged
(
index
)
=
>
Some
(
*
index
)
ResolvedParent
:
:
ByChildren
(
index
)
|
ResolvedParent
:
:
ByParentGuid
(
index
)
=
>
{
divergence
=
Divergence
:
:
Diverged
;
Some
(
*
index
)
}
}
;
let
mut
child_indices
=
entry
.
children
.
iter
(
)
.
filter_map
(
|
child_index
|
{
match
child_index
{
BuilderEntryChild
:
:
Exists
(
child_index
)
=
>
{
match
&
parents
[
*
child_index
]
{
ResolvedParent
:
:
Root
|
ResolvedParent
:
:
Unchanged
(
_
)
=
>
{
Some
(
*
child_index
)
}
ResolvedParent
:
:
ByChildren
(
parent_index
)
|
ResolvedParent
:
:
ByParentGuid
(
parent_index
)
=
>
{
divergence
=
Divergence
:
:
Diverged
;
if
*
parent_index
=
=
entry_index
{
Some
(
*
child_index
)
}
else
{
None
}
}
}
}
BuilderEntryChild
:
:
Missing
(
_
)
=
>
{
divergence
=
Divergence
:
:
Diverged
;
None
}
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
if
let
Some
(
mut
reparented_orphans
)
=
reparented_orphans_by_parent
.
get_mut
(
&
entry_index
)
{
divergence
=
Divergence
:
:
Diverged
;
child_indices
.
append
(
&
mut
reparented_orphans
)
;
}
TreeEntry
{
item
:
entry
.
item
parent_index
child_indices
divergence
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
Ok
(
Tree
{
entry_index_by_guid
:
self
.
entry_index_by_guid
entries
deleted_guids
:
HashSet
:
:
new
(
)
}
)
}
}
pub
struct
ParentBuilder
<
'
b
>
(
&
'
b
mut
Builder
BuilderEntryChild
)
;
impl
<
'
b
>
ParentBuilder
<
'
b
>
{
pub
fn
by_children
(
self
parent_guid
:
&
Guid
)
-
>
Result
<
&
'
b
mut
Builder
>
{
let
parent_index
=
match
self
.
0
.
entry_index_by_guid
.
get
(
parent_guid
)
{
Some
(
&
parent_index
)
if
self
.
0
.
entries
[
parent_index
]
.
item
.
is_folder
(
)
=
>
parent_index
_
=
>
{
return
Err
(
ErrorKind
:
:
InvalidParent
(
self
.
child_guid
(
)
.
clone
(
)
parent_guid
.
clone
(
)
)
.
into
(
)
)
;
}
}
;
if
let
BuilderEntryChild
:
:
Exists
(
child_index
)
=
&
self
.
1
{
self
.
0
.
entries
[
*
child_index
]
.
parents_by
(
&
[
BuilderParentBy
:
:
Children
(
parent_index
)
]
)
?
;
}
self
.
0
.
entries
[
parent_index
]
.
children
.
push
(
self
.
1
)
;
Ok
(
self
.
0
)
}
pub
fn
by_parent_guid
(
self
parent_guid
:
Guid
)
-
>
Result
<
&
'
b
mut
Builder
>
{
match
&
self
.
1
{
BuilderEntryChild
:
:
Exists
(
child_index
)
=
>
{
self
.
0
.
entries
[
*
child_index
]
.
parents_by
(
&
[
BuilderParentBy
:
:
UnknownItem
(
parent_guid
)
]
)
?
;
}
BuilderEntryChild
:
:
Missing
(
child_guid
)
=
>
{
return
Err
(
ErrorKind
:
:
MissingItem
(
child_guid
.
clone
(
)
)
.
into
(
)
)
;
}
}
Ok
(
self
.
0
)
}
pub
fn
by_structure
(
self
parent_guid
:
&
Guid
)
-
>
Result
<
&
'
b
mut
Builder
>
{
let
parent_index
=
match
self
.
0
.
entry_index_by_guid
.
get
(
parent_guid
)
{
Some
(
&
parent_index
)
if
self
.
0
.
entries
[
parent_index
]
.
item
.
is_folder
(
)
=
>
parent_index
_
=
>
{
return
Err
(
ErrorKind
:
:
InvalidParent
(
self
.
child_guid
(
)
.
clone
(
)
parent_guid
.
clone
(
)
)
.
into
(
)
)
;
}
}
;
match
&
self
.
1
{
BuilderEntryChild
:
:
Exists
(
child_index
)
=
>
{
self
.
0
.
entries
[
*
child_index
]
.
parents_by
(
&
[
BuilderParentBy
:
:
Children
(
parent_index
)
BuilderParentBy
:
:
KnownItem
(
parent_index
)
]
)
?
;
}
BuilderEntryChild
:
:
Missing
(
child_guid
)
=
>
{
return
Err
(
ErrorKind
:
:
MissingItem
(
child_guid
.
clone
(
)
)
.
into
(
)
)
;
}
}
self
.
0
.
entries
[
parent_index
]
.
children
.
push
(
self
.
1
)
;
Ok
(
self
.
0
)
}
fn
child_guid
(
&
self
)
-
>
&
Guid
{
match
&
self
.
1
{
BuilderEntryChild
:
:
Exists
(
index
)
=
>
&
self
.
0
.
entries
[
*
index
]
.
item
.
guid
BuilderEntryChild
:
:
Missing
(
guid
)
=
>
guid
}
}
}
#
[
derive
(
Debug
)
]
struct
TreeEntry
{
item
:
Item
divergence
:
Divergence
parent_index
:
Option
<
Index
>
child_indices
:
Vec
<
Index
>
}
#
[
derive
(
Debug
)
]
struct
BuilderEntry
{
item
:
Item
parent
:
BuilderEntryParent
children
:
Vec
<
BuilderEntryChild
>
}
impl
BuilderEntry
{
fn
parents_by
(
&
mut
self
new_parents
:
&
[
BuilderParentBy
]
)
-
>
Result
<
(
)
>
{
let
old_parent
=
mem
:
:
replace
(
&
mut
self
.
parent
BuilderEntryParent
:
:
None
)
;
let
new_parent
=
match
old_parent
{
BuilderEntryParent
:
:
Root
=
>
{
mem
:
:
replace
(
&
mut
self
.
parent
BuilderEntryParent
:
:
Root
)
;
return
Err
(
ErrorKind
:
:
DuplicateItem
(
self
.
item
.
guid
.
clone
(
)
)
.
into
(
)
)
;
}
BuilderEntryParent
:
:
None
=
>
match
new_parents
{
[
BuilderParentBy
:
:
Children
(
from_children
)
BuilderParentBy
:
:
KnownItem
(
from_item
)
]
|
[
BuilderParentBy
:
:
KnownItem
(
from_item
)
BuilderParentBy
:
:
Children
(
from_children
)
]
if
from_children
=
=
from_item
=
>
{
BuilderEntryParent
:
:
Complete
(
*
from_children
)
}
new_parents
=
>
BuilderEntryParent
:
:
Partial
(
new_parents
.
to_vec
(
)
)
}
BuilderEntryParent
:
:
Complete
(
index
)
=
>
{
let
mut
parents
=
vec
!
[
BuilderParentBy
:
:
Children
(
index
)
BuilderParentBy
:
:
KnownItem
(
index
)
]
;
parents
.
extend_from_slice
(
new_parents
)
;
BuilderEntryParent
:
:
Partial
(
parents
)
}
BuilderEntryParent
:
:
Partial
(
mut
parents
)
=
>
{
parents
.
extend_from_slice
(
new_parents
)
;
BuilderEntryParent
:
:
Partial
(
parents
)
}
}
;
mem
:
:
replace
(
&
mut
self
.
parent
new_parent
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
)
]
enum
BuilderEntryChild
{
Exists
(
Index
)
Missing
(
Guid
)
}
#
[
derive
(
Debug
)
]
enum
BuilderEntryParent
{
None
Root
Complete
(
Index
)
Partial
(
Vec
<
BuilderParentBy
>
)
}
#
[
derive
(
Clone
Debug
)
]
enum
BuilderParentBy
{
Children
(
Index
)
UnknownItem
(
Guid
)
KnownItem
(
Index
)
}
#
[
derive
(
Debug
)
]
enum
ResolvedParent
{
Root
Unchanged
(
Index
)
ByChildren
(
Index
)
ByParentGuid
(
Index
)
}
impl
ResolvedParent
{
fn
index
(
&
self
)
-
>
Option
<
Index
>
{
match
self
{
ResolvedParent
:
:
Root
=
>
None
ResolvedParent
:
:
Unchanged
(
index
)
|
ResolvedParent
:
:
ByChildren
(
index
)
|
ResolvedParent
:
:
ByParentGuid
(
index
)
=
>
Some
(
*
index
)
}
}
}
fn
detect_cycles
(
parents
:
&
[
ResolvedParent
]
)
-
>
Option
<
Index
>
{
let
mut
seen
=
SmallBitVec
:
:
from_elem
(
parents
.
len
(
)
false
)
;
for
(
entry_index
parent
)
in
parents
.
iter
(
)
.
enumerate
(
)
{
if
seen
[
entry_index
]
{
continue
;
}
let
mut
parent_index
=
parent
.
index
(
)
;
let
mut
grandparent_index
=
parent
.
index
(
)
.
and_then
(
|
index
|
parents
[
index
]
.
index
(
)
)
;
while
let
(
Some
(
i
)
Some
(
j
)
)
=
(
parent_index
grandparent_index
)
{
if
i
=
=
j
{
return
Some
(
i
)
;
}
if
seen
[
i
]
|
|
seen
[
j
]
{
break
;
}
parent_index
=
parent_index
.
and_then
(
|
index
|
parents
[
index
]
.
index
(
)
)
;
grandparent_index
=
grandparent_index
.
and_then
(
|
index
|
parents
[
index
]
.
index
(
)
)
.
and_then
(
|
index
|
parents
[
index
]
.
index
(
)
)
;
}
seen
.
set
(
entry_index
true
)
;
}
None
}
#
[
derive
(
Debug
)
]
enum
Divergence
{
Consistent
Diverged
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
Node
<
'
t
>
(
&
'
t
Tree
&
'
t
TreeEntry
)
;
impl
<
'
t
>
Node
<
'
t
>
{
pub
fn
children
<
'
n
>
(
&
'
n
self
)
-
>
impl
Iterator
<
Item
=
Node
<
'
t
>
>
+
'
n
{
self
.
1
.
child_indices
.
iter
(
)
.
map
(
move
|
&
child_index
|
Node
(
self
.
0
&
self
.
0
.
entries
[
child_index
]
)
)
}
pub
fn
parent
(
&
self
)
-
>
Option
<
Node
>
{
self
.
1
.
parent_index
.
as_ref
(
)
.
map
(
|
&
parent_index
|
Node
(
self
.
0
&
self
.
0
.
entries
[
parent_index
]
)
)
}
pub
fn
level
(
&
self
)
-
>
i64
{
if
self
.
is_root
(
)
{
return
0
;
}
self
.
parent
(
)
.
map
(
|
parent
|
parent
.
level
(
)
+
1
)
.
unwrap_or
(
-
1
)
}
pub
fn
is_syncable
(
&
self
)
-
>
bool
{
if
self
.
is_root
(
)
{
return
false
;
}
if
self
.
is_user_content_root
(
)
{
return
true
;
}
if
self
.
kind
=
=
Kind
:
:
Query
&
&
self
.
diverged
(
)
{
return
false
;
}
self
.
parent
(
)
.
map
(
|
parent
|
parent
.
is_syncable
(
)
)
.
unwrap_or
(
false
)
}
#
[
inline
]
pub
fn
diverged
(
&
self
)
-
>
bool
{
match
&
self
.
1
.
divergence
{
Divergence
:
:
Diverged
=
>
true
Divergence
:
:
Consistent
=
>
false
}
}
pub
fn
to_ascii_string
(
&
self
)
-
>
String
{
self
.
to_ascii_fragment
(
"
"
)
}
fn
to_ascii_fragment
(
&
self
prefix
:
&
str
)
-
>
String
{
match
self
.
1
.
item
.
kind
{
Kind
:
:
Folder
=
>
{
let
children_prefix
=
format
!
(
"
{
}
|
"
prefix
)
;
let
children
=
self
.
children
(
)
.
map
(
|
n
|
n
.
to_ascii_fragment
(
&
children_prefix
)
)
.
collect
:
:
<
Vec
<
String
>
>
(
)
;
let
kind
=
if
self
.
diverged
(
)
{
"
"
}
else
{
"
"
}
;
if
children
.
is_empty
(
)
{
format
!
(
"
{
}
{
}
{
}
"
prefix
kind
self
.
1
.
item
)
}
else
{
format
!
(
"
{
}
{
}
\
n
{
}
"
prefix
self
.
1
.
item
children
.
join
(
"
\
n
"
)
)
}
}
_
=
>
{
let
kind
=
if
self
.
diverged
(
)
{
"
"
}
else
{
"
"
}
;
format
!
(
"
{
}
{
}
{
}
"
prefix
kind
self
.
1
.
item
)
}
}
}
#
[
inline
]
pub
fn
is_root
(
&
self
)
-
>
bool
{
ptr
:
:
eq
(
self
.
1
&
self
.
0
.
entries
[
0
]
)
}
#
[
inline
]
pub
fn
is_user_content_root
(
&
self
)
-
>
bool
{
self
.
1
.
item
.
guid
.
is_user_content_root
(
)
}
}
impl
<
'
t
>
Deref
for
Node
<
'
t
>
{
type
Target
=
Item
;
fn
deref
(
&
self
)
-
>
&
Item
{
&
self
.
1
.
item
}
}
impl
<
'
t
>
fmt
:
:
Display
for
Node
<
'
t
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
1
.
item
.
fmt
(
f
)
}
}
#
[
cfg
(
test
)
]
impl
<
'
t
>
PartialEq
for
Node
<
'
t
>
{
fn
eq
(
&
self
other
:
&
Node
)
-
>
bool
{
match
(
self
.
parent
(
)
other
.
parent
(
)
)
{
(
Some
(
parent
)
Some
(
other_parent
)
)
=
>
{
if
parent
.
1
.
item
!
=
other_parent
.
1
.
item
{
return
false
;
}
}
(
Some
(
_
)
None
)
|
(
None
Some
(
_
)
)
=
>
return
false
(
None
None
)
=
>
{
}
}
if
self
.
1
.
item
!
=
other
.
1
.
item
{
return
false
;
}
self
.
children
(
)
.
eq
(
other
.
children
(
)
)
}
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
pub
struct
Item
{
pub
guid
:
Guid
pub
kind
:
Kind
pub
age
:
i64
pub
needs_merge
:
bool
pub
validity
:
Validity
}
impl
Item
{
#
[
inline
]
pub
fn
new
(
guid
:
Guid
kind
:
Kind
)
-
>
Item
{
Item
{
guid
kind
age
:
0
needs_merge
:
false
validity
:
Validity
:
:
Valid
}
}
#
[
inline
]
pub
fn
is_folder
(
&
self
)
-
>
bool
{
self
.
kind
=
=
Kind
:
:
Folder
}
#
[
inline
]
pub
fn
has_compatible_kind
(
&
self
remote_node
:
&
Item
)
-
>
bool
{
match
(
&
self
.
kind
&
remote_node
.
kind
)
{
(
Kind
:
:
Bookmark
Kind
:
:
Query
)
=
>
true
(
Kind
:
:
Query
Kind
:
:
Bookmark
)
=
>
true
(
local_kind
remote_kind
)
=
>
local_kind
=
=
remote_kind
}
}
}
impl
fmt
:
:
Display
for
Item
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
kind
=
match
self
.
validity
{
Validity
:
:
Valid
=
>
format
!
(
"
{
}
"
self
.
kind
)
Validity
:
:
Reupload
|
Validity
:
:
Replace
=
>
format
!
(
"
{
}
(
{
}
)
"
self
.
kind
self
.
validity
)
}
;
let
info
=
if
self
.
needs_merge
{
format
!
(
"
{
}
;
Age
=
{
}
ms
;
Unmerged
"
kind
self
.
age
)
}
else
{
format
!
(
"
{
}
;
Age
=
{
}
ms
"
kind
self
.
age
)
}
;
write
!
(
f
"
{
}
(
{
}
)
"
self
.
guid
info
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
Kind
{
Bookmark
Query
Folder
Livemark
Separator
}
impl
fmt
:
:
Display
for
Kind
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
Validity
{
Valid
Reupload
Replace
}
impl
fmt
:
:
Display
for
Validity
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
MergedRoot
<
'
t
>
{
node
:
MergedNode
<
'
t
>
size_hint
:
usize
}
impl
<
'
t
>
MergedRoot
<
'
t
>
{
pub
(
crate
)
fn
with_size
(
node
:
MergedNode
<
'
t
>
size_hint
:
usize
)
-
>
MergedRoot
{
MergedRoot
{
node
size_hint
}
}
pub
fn
node
(
&
self
)
-
>
&
MergedNode
{
&
self
.
node
}
pub
fn
descendants
(
&
self
)
-
>
Vec
<
MergedDescendant
>
{
fn
accumulate
<
'
t
>
(
results
:
&
mut
Vec
<
MergedDescendant
<
'
t
>
>
merged_node
:
&
'
t
MergedNode
<
'
t
>
level
:
usize
)
{
results
.
reserve
(
merged_node
.
merged_children
.
len
(
)
)
;
for
(
position
merged_child_node
)
in
merged_node
.
merged_children
.
iter
(
)
.
enumerate
(
)
{
results
.
push
(
MergedDescendant
{
merged_parent_node
:
&
merged_node
level
:
level
+
1
position
merged_node
:
merged_child_node
}
)
;
accumulate
(
results
merged_child_node
level
+
1
)
;
}
}
let
mut
results
=
Vec
:
:
with_capacity
(
self
.
size_hint
)
;
accumulate
(
&
mut
results
&
self
.
node
0
)
;
results
}
pub
fn
to_ascii_string
(
&
self
)
-
>
String
{
self
.
node
.
to_ascii_fragment
(
"
"
)
}
}
#
[
cfg
(
test
)
]
impl
<
'
t
>
IntoTree
for
MergedRoot
<
'
t
>
{
fn
into_tree
(
self
)
-
>
Result
<
Tree
>
{
fn
to_item
(
merged_node
:
&
MergedNode
)
-
>
Item
{
let
node
=
merged_node
.
merge_state
.
node
(
)
;
let
mut
item
=
Item
:
:
new
(
merged_node
.
guid
.
clone
(
)
node
.
kind
)
;
item
.
age
=
node
.
age
;
item
.
needs_merge
=
merged_node
.
merge_state
.
upload_reason
(
)
!
=
UploadReason
:
:
None
;
item
}
let
mut
b
=
Tree
:
:
with_root
(
to_item
(
&
self
.
node
)
)
;
for
MergedDescendant
{
merged_parent_node
merged_node
.
.
}
in
self
.
descendants
(
)
{
b
.
item
(
to_item
(
merged_node
)
)
?
.
by_structure
(
&
merged_parent_node
.
guid
)
?
;
}
b
.
into_tree
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
MergedNode
<
'
t
>
{
pub
guid
:
Guid
pub
merge_state
:
MergeState
<
'
t
>
pub
merged_children
:
Vec
<
MergedNode
<
'
t
>
>
}
impl
<
'
t
>
MergedNode
<
'
t
>
{
pub
(
crate
)
fn
new
(
guid
:
Guid
merge_state
:
MergeState
<
'
t
>
)
-
>
MergedNode
<
'
t
>
{
MergedNode
{
guid
merge_state
merged_children
:
Vec
:
:
new
(
)
}
}
pub
(
crate
)
fn
remote_guid_changed
(
&
self
)
-
>
bool
{
self
.
merge_state
.
remote_node
(
)
.
map
(
|
remote_node
|
remote_node
.
guid
!
=
self
.
guid
)
.
unwrap_or
(
false
)
}
fn
to_ascii_fragment
(
&
self
prefix
:
&
str
)
-
>
String
{
match
self
.
merge_state
.
node
(
)
.
kind
{
Kind
:
:
Folder
=
>
{
let
children_prefix
=
format
!
(
"
{
}
|
"
prefix
)
;
let
children
=
self
.
merged_children
.
iter
(
)
.
map
(
|
n
|
n
.
to_ascii_fragment
(
&
children_prefix
)
)
.
collect
:
:
<
Vec
<
String
>
>
(
)
;
if
children
.
is_empty
(
)
{
format
!
(
"
{
}
{
}
"
prefix
&
self
)
}
else
{
format
!
(
"
{
}
{
}
\
n
{
}
"
prefix
&
self
children
.
join
(
"
\
n
"
)
)
}
}
_
=
>
format
!
(
"
{
}
{
}
"
prefix
&
self
)
}
}
}
impl
<
'
t
>
fmt
:
:
Display
for
MergedNode
<
'
t
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
{
}
"
self
.
guid
self
.
merge_state
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
MergedDescendant
<
'
t
>
{
pub
merged_parent_node
:
&
'
t
MergedNode
<
'
t
>
pub
level
:
usize
pub
position
:
usize
pub
merged_node
:
&
'
t
MergedNode
<
'
t
>
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
MergeState
<
'
t
>
{
LocalOnly
(
Node
<
'
t
>
)
RemoteOnly
(
Node
<
'
t
>
)
Local
{
local_node
:
Node
<
'
t
>
remote_node
:
Node
<
'
t
>
}
Remote
{
local_node
:
Node
<
'
t
>
remote_node
:
Node
<
'
t
>
}
RemoteOnlyWithNewStructure
(
Node
<
'
t
>
)
RemoteWithNewStructure
{
local_node
:
Node
<
'
t
>
remote_node
:
Node
<
'
t
>
}
Unchanged
{
local_node
:
Node
<
'
t
>
remote_node
:
Node
<
'
t
>
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
UploadReason
{
None
LocallyNew
Merged
NewStructure
}
impl
<
'
t
>
MergeState
<
'
t
>
{
pub
fn
local_node
(
&
self
)
-
>
Option
<
&
Node
<
'
t
>
>
{
match
self
{
MergeState
:
:
LocalOnly
(
local_node
)
|
MergeState
:
:
Local
{
local_node
.
.
}
|
MergeState
:
:
Remote
{
local_node
.
.
}
|
MergeState
:
:
RemoteWithNewStructure
{
local_node
.
.
}
|
MergeState
:
:
Unchanged
{
local_node
.
.
}
=
>
Some
(
local_node
)
MergeState
:
:
RemoteOnly
(
_
)
|
MergeState
:
:
RemoteOnlyWithNewStructure
(
_
)
=
>
None
}
}
pub
fn
remote_node
(
&
self
)
-
>
Option
<
&
Node
<
'
t
>
>
{
match
self
{
MergeState
:
:
RemoteOnly
(
remote_node
)
|
MergeState
:
:
Local
{
remote_node
.
.
}
|
MergeState
:
:
Remote
{
remote_node
.
.
}
|
MergeState
:
:
RemoteOnlyWithNewStructure
(
remote_node
)
|
MergeState
:
:
RemoteWithNewStructure
{
remote_node
.
.
}
|
MergeState
:
:
Unchanged
{
remote_node
.
.
}
=
>
Some
(
remote_node
)
MergeState
:
:
LocalOnly
(
_
)
=
>
None
}
}
pub
fn
should_apply
(
&
self
)
-
>
bool
{
match
self
{
MergeState
:
:
RemoteOnly
(
_
)
|
MergeState
:
:
Remote
{
.
.
}
|
MergeState
:
:
RemoteOnlyWithNewStructure
(
_
)
|
MergeState
:
:
RemoteWithNewStructure
{
.
.
}
=
>
true
MergeState
:
:
LocalOnly
(
_
)
|
MergeState
:
:
Local
{
.
.
}
|
MergeState
:
:
Unchanged
{
.
.
}
=
>
{
false
}
}
}
pub
fn
upload_reason
(
&
self
)
-
>
UploadReason
{
match
self
{
MergeState
:
:
LocalOnly
(
_
)
=
>
UploadReason
:
:
LocallyNew
MergeState
:
:
RemoteOnly
(
_
)
=
>
UploadReason
:
:
None
MergeState
:
:
Local
{
.
.
}
=
>
UploadReason
:
:
Merged
MergeState
:
:
Remote
{
.
.
}
=
>
UploadReason
:
:
None
MergeState
:
:
RemoteOnlyWithNewStructure
(
_
)
=
>
{
UploadReason
:
:
NewStructure
}
MergeState
:
:
RemoteWithNewStructure
{
local_node
.
.
}
=
>
{
if
local_node
.
needs_merge
{
UploadReason
:
:
Merged
}
else
{
UploadReason
:
:
NewStructure
}
}
MergeState
:
:
Unchanged
{
.
.
}
=
>
UploadReason
:
:
None
}
}
pub
(
crate
)
fn
with_new_structure
(
&
self
)
-
>
MergeState
<
'
t
>
{
match
*
self
{
MergeState
:
:
LocalOnly
(
local_node
)
=
>
MergeState
:
:
LocalOnly
(
local_node
)
MergeState
:
:
RemoteOnly
(
remote_node
)
|
MergeState
:
:
RemoteOnlyWithNewStructure
(
remote_node
)
=
>
{
MergeState
:
:
RemoteOnlyWithNewStructure
(
remote_node
)
}
MergeState
:
:
Local
{
local_node
remote_node
}
=
>
MergeState
:
:
Local
{
local_node
remote_node
}
MergeState
:
:
Remote
{
local_node
remote_node
}
|
MergeState
:
:
RemoteWithNewStructure
{
local_node
remote_node
}
=
>
MergeState
:
:
RemoteWithNewStructure
{
local_node
remote_node
}
MergeState
:
:
Unchanged
{
local_node
remote_node
}
=
>
{
MergeState
:
:
Local
{
local_node
remote_node
}
}
}
}
fn
node
(
&
self
)
-
>
&
Node
<
'
t
>
{
match
self
{
MergeState
:
:
LocalOnly
(
local_node
)
|
MergeState
:
:
Local
{
local_node
.
.
}
=
>
local_node
MergeState
:
:
RemoteOnly
(
remote_node
)
|
MergeState
:
:
Remote
{
remote_node
.
.
}
|
MergeState
:
:
RemoteOnlyWithNewStructure
(
remote_node
)
|
MergeState
:
:
RemoteWithNewStructure
{
remote_node
.
.
}
=
>
remote_node
MergeState
:
:
Unchanged
{
local_node
.
.
}
=
>
local_node
}
}
}
impl
<
'
t
>
fmt
:
:
Display
for
MergeState
<
'
t
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
match
self
{
MergeState
:
:
LocalOnly
(
_
)
|
MergeState
:
:
Local
{
.
.
}
=
>
"
(
Local
Local
)
"
MergeState
:
:
RemoteOnly
(
_
)
|
MergeState
:
:
Remote
{
.
.
}
=
>
"
(
Remote
Remote
)
"
MergeState
:
:
RemoteOnlyWithNewStructure
(
_
)
|
MergeState
:
:
RemoteWithNewStructure
{
.
.
}
=
>
"
(
Remote
New
)
"
MergeState
:
:
Unchanged
{
.
.
}
=
>
"
(
Unchanged
Unchanged
)
"
}
)
}
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
enum
Content
{
Bookmark
{
title
:
String
url_href
:
String
}
Folder
{
title
:
String
}
Separator
{
position
:
i64
}
}
