use
std
:
:
{
error
fmt
result
str
:
:
Utf8Error
string
:
:
FromUtf16Error
}
;
use
crate
:
:
guid
:
:
Guid
;
use
crate
:
:
Item
;
pub
type
Result
<
T
>
=
result
:
:
Result
<
T
Error
>
;
#
[
derive
(
Debug
)
]
pub
struct
Error
(
ErrorKind
)
;
impl
Error
{
pub
fn
kind
(
&
self
)
-
>
&
ErrorKind
{
&
self
.
0
}
}
impl
error
:
:
Error
for
Error
{
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
error
:
:
Error
+
'
static
)
>
{
match
self
.
kind
(
)
{
ErrorKind
:
:
MalformedString
(
err
)
=
>
Some
(
err
.
as_ref
(
)
)
_
=
>
None
}
}
}
impl
From
<
ErrorKind
>
for
Error
{
fn
from
(
kind
:
ErrorKind
)
-
>
Error
{
Error
(
kind
)
}
}
impl
From
<
FromUtf16Error
>
for
Error
{
fn
from
(
error
:
FromUtf16Error
)
-
>
Error
{
Error
(
ErrorKind
:
:
MalformedString
(
error
.
into
(
)
)
)
}
}
impl
From
<
Utf8Error
>
for
Error
{
fn
from
(
error
:
Utf8Error
)
-
>
Error
{
Error
(
ErrorKind
:
:
MalformedString
(
error
.
into
(
)
)
)
}
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
.
kind
(
)
{
ErrorKind
:
:
MismatchedItemKind
(
local_item
remote_item
)
=
>
write
!
(
f
"
Can
'
t
merge
local
{
}
<
guid
:
{
}
>
and
remote
{
}
<
guid
:
{
}
>
"
local_item
.
kind
local_item
.
guid
remote_item
.
kind
remote_item
.
guid
)
ErrorKind
:
:
DuplicateItem
(
guid
)
=
>
{
write
!
(
f
"
Item
<
guid
:
{
}
>
already
exists
in
tree
"
guid
)
}
ErrorKind
:
:
MissingItem
(
guid
)
=
>
{
write
!
(
f
"
Item
<
guid
:
{
}
>
doesn
'
t
exist
in
tree
"
guid
)
}
ErrorKind
:
:
InvalidParent
(
child
parent
)
=
>
write
!
(
f
"
Can
'
t
insert
{
}
<
guid
:
{
}
>
into
{
}
<
guid
:
{
}
>
"
child
.
kind
child
.
guid
parent
.
kind
parent
.
guid
)
ErrorKind
:
:
InvalidParentForUnknownChild
(
child_guid
parent
)
=
>
write
!
(
f
"
Can
'
t
insert
unknown
child
<
guid
:
{
}
>
into
{
}
<
guid
:
{
}
>
"
child_guid
parent
.
kind
parent
.
guid
)
ErrorKind
:
:
MissingParent
(
child
parent_guid
)
=
>
write
!
(
f
"
Can
'
t
insert
{
}
<
guid
:
{
}
>
into
nonexistent
parent
<
guid
:
{
}
>
"
child
.
kind
child
.
guid
parent_guid
)
ErrorKind
:
:
MissingParentForUnknownChild
(
child_guid
parent_guid
)
=
>
write
!
(
f
"
Can
'
t
insert
unknown
child
<
guid
:
{
}
>
into
nonexistent
parent
<
guid
:
{
}
>
"
child_guid
parent_guid
)
ErrorKind
:
:
Cycle
(
guid
)
=
>
write
!
(
f
"
Item
<
guid
:
{
}
>
can
'
t
contain
itself
"
guid
)
ErrorKind
:
:
MergeConflict
=
>
write
!
(
f
"
Local
tree
changed
during
merge
"
)
ErrorKind
:
:
UnmergedLocalItems
=
>
{
write
!
(
f
"
Merged
tree
doesn
'
t
mention
all
items
from
local
tree
"
)
}
ErrorKind
:
:
UnmergedRemoteItems
=
>
{
write
!
(
f
"
Merged
tree
doesn
'
t
mention
all
items
from
remote
tree
"
)
}
ErrorKind
:
:
InvalidGuid
(
invalid_guid
)
=
>
{
write
!
(
f
"
Merged
tree
contains
invalid
GUID
<
guid
:
{
}
>
"
invalid_guid
)
}
ErrorKind
:
:
InvalidByte
(
b
)
=
>
write
!
(
f
"
Invalid
byte
<
byte
:
{
}
>
in
UTF
-
16
encoding
"
b
)
ErrorKind
:
:
MalformedString
(
err
)
=
>
err
.
fmt
(
f
)
ErrorKind
:
:
Abort
=
>
write
!
(
f
"
Operation
aborted
"
)
}
}
}
#
[
derive
(
Debug
)
]
pub
enum
ErrorKind
{
MismatchedItemKind
(
Item
Item
)
DuplicateItem
(
Guid
)
InvalidParent
(
Item
Item
)
InvalidParentForUnknownChild
(
Guid
Item
)
MissingParent
(
Item
Guid
)
MissingParentForUnknownChild
(
Guid
Guid
)
MissingItem
(
Guid
)
Cycle
(
Guid
)
MergeConflict
UnmergedLocalItems
UnmergedRemoteItems
InvalidGuid
(
Guid
)
InvalidByte
(
u16
)
MalformedString
(
Box
<
dyn
error
:
:
Error
+
Send
+
Sync
+
'
static
>
)
Abort
}
