use
std
:
:
{
collections
:
:
HashMap
time
:
:
Duration
}
;
use
crate
:
:
driver
:
:
{
DefaultDriver
Driver
}
;
use
crate
:
:
error
:
:
{
Error
ErrorKind
}
;
use
crate
:
:
guid
:
:
Guid
;
use
crate
:
:
merge
:
:
{
Deletion
Merger
StructureCounts
}
;
use
crate
:
:
tree
:
:
{
Content
MergedRoot
Tree
}
;
#
[
derive
(
Clone
Debug
Default
Eq
PartialEq
)
]
pub
struct
Stats
{
pub
timings
:
MergeTimings
pub
counts
:
StructureCounts
}
#
[
derive
(
Clone
Debug
Default
Eq
PartialEq
)
]
pub
struct
MergeTimings
{
pub
fetch_local_tree
:
Duration
pub
fetch_new_local_contents
:
Duration
pub
fetch_remote_tree
:
Duration
pub
fetch_new_remote_contents
:
Duration
pub
merge
:
Duration
pub
apply
:
Duration
}
macro_rules
!
time
{
(
timings
:
ident
name
:
ident
op
:
expr
)
=
>
{
{
let
now
=
std
:
:
time
:
:
Instant
:
:
now
(
)
;
let
result
=
op
;
timings
.
name
=
now
.
elapsed
(
)
;
result
}
}
;
}
pub
trait
Store
<
E
:
From
<
Error
>
>
{
fn
fetch_local_tree
(
&
self
)
-
>
Result
<
Tree
E
>
;
fn
fetch_new_local_contents
(
&
self
)
-
>
Result
<
HashMap
<
Guid
Content
>
E
>
;
fn
fetch_remote_tree
(
&
self
)
-
>
Result
<
Tree
E
>
;
fn
fetch_new_remote_contents
(
&
self
)
-
>
Result
<
HashMap
<
Guid
Content
>
E
>
;
fn
apply
<
'
t
>
(
&
mut
self
root
:
MergedRoot
<
'
t
>
deletions
:
impl
Iterator
<
Item
=
Deletion
<
'
t
>
>
)
-
>
Result
<
(
)
E
>
;
fn
merge
(
&
mut
self
)
-
>
Result
<
Stats
E
>
{
self
.
merge_with_driver
(
&
DefaultDriver
)
}
fn
merge_with_driver
<
D
:
Driver
>
(
&
mut
self
driver
:
&
D
)
-
>
Result
<
Stats
E
>
{
let
mut
merge_timings
=
MergeTimings
:
:
default
(
)
;
let
local_tree
=
time
!
(
merge_timings
fetch_local_tree
{
self
.
fetch_local_tree
(
)
}
)
?
;
debug
!
(
driver
"
Built
local
tree
from
mirror
\
n
{
}
"
local_tree
)
;
let
new_local_contents
=
time
!
(
merge_timings
fetch_new_local_contents
{
self
.
fetch_new_local_contents
(
)
}
)
?
;
let
remote_tree
=
time
!
(
merge_timings
fetch_remote_tree
{
self
.
fetch_remote_tree
(
)
}
)
?
;
debug
!
(
driver
"
Built
remote
tree
from
mirror
\
n
{
}
"
remote_tree
)
;
let
new_remote_contents
=
time
!
(
merge_timings
fetch_new_remote_contents
{
self
.
fetch_new_remote_contents
(
)
}
)
?
;
let
mut
merger
=
Merger
:
:
with_driver
(
driver
&
local_tree
&
new_local_contents
&
remote_tree
&
new_remote_contents
)
;
let
merged_root
=
time
!
(
merge_timings
merge
merger
.
merge
(
)
)
?
;
debug
!
(
driver
"
Built
new
merged
tree
\
n
{
}
\
nDelete
Locally
:
[
{
}
]
\
nDelete
Remotely
:
[
{
}
]
"
merged_root
.
to_ascii_string
(
)
merger
.
local_deletions
(
)
.
map
(
|
d
|
d
.
guid
.
as_str
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
join
(
"
"
)
merger
.
remote_deletions
(
)
.
map
(
|
d
|
d
.
guid
.
as_str
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
join
(
"
"
)
)
;
if
!
merger
.
subsumes
(
&
local_tree
)
{
Err
(
E
:
:
from
(
ErrorKind
:
:
UnmergedLocalItems
.
into
(
)
)
)
?
;
}
if
!
merger
.
subsumes
(
&
remote_tree
)
{
Err
(
E
:
:
from
(
ErrorKind
:
:
UnmergedRemoteItems
.
into
(
)
)
)
?
;
}
time
!
(
merge_timings
apply
self
.
apply
(
merged_root
merger
.
deletions
(
)
)
)
?
;
Ok
(
Stats
{
timings
:
merge_timings
counts
:
*
merger
.
counts
(
)
}
)
}
}
