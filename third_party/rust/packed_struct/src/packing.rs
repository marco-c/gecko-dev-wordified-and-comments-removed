use
internal_prelude
:
:
v1
:
:
*
;
pub
trait
PackedStruct
<
B
>
where
Self
:
Sized
{
fn
pack
(
&
self
)
-
>
B
;
fn
unpack
(
src
:
&
B
)
-
>
Result
<
Self
PackingError
>
;
}
pub
trait
PackedStructInfo
{
fn
packed_bits
(
)
-
>
usize
;
}
pub
trait
PackedStructSlice
where
Self
:
Sized
{
fn
pack_to_slice
(
&
self
output
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
PackingError
>
;
fn
unpack_from_slice
(
src
:
&
[
u8
]
)
-
>
Result
<
Self
PackingError
>
;
fn
packed_bytes
(
)
-
>
usize
;
#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
)
)
]
fn
pack_to_vec
(
&
self
)
-
>
Result
<
Vec
<
u8
>
PackingError
>
{
let
mut
buf
=
vec
!
[
0
;
Self
:
:
packed_bytes
(
)
]
;
self
.
pack_to_slice
(
&
mut
buf
)
?
;
Ok
(
buf
)
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Serialize
)
]
pub
enum
PackingError
{
InvalidValue
BitsError
BufferTooSmall
NotImplemented
BufferSizeMismatch
{
expected
:
usize
actual
:
usize
}
}
impl
Display
for
PackingError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
"
self
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
:
:
std
:
:
error
:
:
Error
for
PackingError
{
fn
description
(
&
self
)
-
>
&
str
{
match
*
self
{
PackingError
:
:
InvalidValue
=
>
"
Invalid
value
"
PackingError
:
:
BitsError
=
>
"
Bits
error
"
PackingError
:
:
BufferTooSmall
=
>
"
Buffer
too
small
"
PackingError
:
:
BufferSizeMismatch
{
.
.
}
=
>
"
Buffer
size
mismatched
"
PackingError
:
:
NotImplemented
=
>
"
Not
implemented
"
}
}
}
macro_rules
!
packing_slice
{
(
T
:
path
;
num_bytes
:
expr
)
=
>
(
impl
PackedStructSlice
for
T
{
#
[
inline
]
fn
pack_to_slice
(
&
self
output
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
PackingError
>
{
if
output
.
len
(
)
!
=
num_bytes
{
return
Err
(
PackingError
:
:
BufferTooSmall
)
;
}
let
packed
=
self
.
pack
(
)
;
&
mut
output
[
.
.
]
.
copy_from_slice
(
&
packed
[
.
.
]
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
unpack_from_slice
(
src
:
&
[
u8
]
)
-
>
Result
<
Self
PackingError
>
{
if
src
.
len
(
)
!
=
num_bytes
{
return
Err
(
PackingError
:
:
BufferTooSmall
)
;
}
let
mut
s
=
[
0
;
num_bytes
]
;
&
mut
s
[
.
.
]
.
copy_from_slice
(
src
)
;
Self
:
:
unpack
(
&
s
)
}
#
[
inline
]
fn
packed_bytes
(
)
-
>
usize
{
num_bytes
}
}
)
}
