#
!
[
no_std
]
use
core
:
:
cmp
:
:
{
self
Ordering
}
;
use
core
:
:
mem
;
use
core
:
:
ptr
;
struct
WriteOnDrop
<
T
>
{
value
:
Option
<
T
>
dest
:
*
mut
T
}
impl
<
T
>
Drop
for
WriteOnDrop
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
ptr
:
:
write
(
self
.
dest
self
.
value
.
take
(
)
.
unwrap
(
)
)
;
}
}
}
fn
insert_head
<
T
F
>
(
v
:
&
mut
[
T
]
is_less
:
&
mut
F
)
where
F
:
FnMut
(
&
T
&
T
)
-
>
bool
{
if
v
.
len
(
)
>
=
2
&
&
is_less
(
&
v
[
1
]
&
v
[
0
]
)
{
unsafe
{
let
mut
tmp
=
NoDrop
{
value
:
Some
(
ptr
:
:
read
(
&
v
[
0
]
)
)
}
;
let
mut
hole
=
InsertionHole
{
src
:
tmp
.
value
.
as_mut
(
)
.
unwrap
(
)
dest
:
&
mut
v
[
1
]
}
;
ptr
:
:
copy_nonoverlapping
(
&
v
[
1
]
&
mut
v
[
0
]
1
)
;
for
i
in
2
.
.
v
.
len
(
)
{
if
!
is_less
(
&
v
[
i
]
&
tmp
.
value
.
as_ref
(
)
.
unwrap
(
)
)
{
break
;
}
ptr
:
:
copy_nonoverlapping
(
&
v
[
i
]
&
mut
v
[
i
-
1
]
1
)
;
hole
.
dest
=
&
mut
v
[
i
]
;
}
}
}
struct
NoDrop
<
T
>
{
value
:
Option
<
T
>
}
impl
<
T
>
Drop
for
NoDrop
<
T
>
{
fn
drop
(
&
mut
self
)
{
mem
:
:
forget
(
self
.
value
.
take
(
)
)
;
}
}
struct
InsertionHole
<
T
>
{
src
:
*
mut
T
dest
:
*
mut
T
}
impl
<
T
>
Drop
for
InsertionHole
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
ptr
:
:
copy_nonoverlapping
(
self
.
src
self
.
dest
1
)
;
}
}
}
}
fn
insertion_sort
<
T
F
>
(
v
:
&
mut
[
T
]
is_less
:
&
mut
F
)
where
F
:
FnMut
(
&
T
&
T
)
-
>
bool
{
let
len
=
v
.
len
(
)
;
if
len
>
=
2
{
for
i
in
(
0
.
.
len
-
1
)
.
rev
(
)
{
insert_head
(
&
mut
v
[
i
.
.
]
is_less
)
;
}
}
}
#
[
cold
]
fn
heapsort
<
T
F
>
(
v
:
&
mut
[
T
]
is_less
:
&
mut
F
)
where
F
:
FnMut
(
&
T
&
T
)
-
>
bool
{
let
mut
sift_down
=
|
v
:
&
mut
[
T
]
mut
node
|
{
loop
{
let
left
=
2
*
node
+
1
;
let
right
=
2
*
node
+
2
;
let
greater
=
if
right
<
v
.
len
(
)
&
&
is_less
(
&
v
[
left
]
&
v
[
right
]
)
{
right
}
else
{
left
}
;
if
greater
>
=
v
.
len
(
)
|
|
!
is_less
(
&
v
[
node
]
&
v
[
greater
]
)
{
break
;
}
v
.
swap
(
node
greater
)
;
node
=
greater
;
}
}
;
for
i
in
(
0
.
.
v
.
len
(
)
/
2
)
.
rev
(
)
{
sift_down
(
v
i
)
;
}
for
i
in
(
1
.
.
v
.
len
(
)
)
.
rev
(
)
{
v
.
swap
(
0
i
)
;
sift_down
(
&
mut
v
[
.
.
i
]
0
)
;
}
}
fn
partition_in_blocks
<
T
F
>
(
v
:
&
mut
[
T
]
pivot
:
&
T
is_less
:
&
mut
F
)
-
>
usize
where
F
:
FnMut
(
&
T
&
T
)
-
>
bool
{
const
BLOCK
:
usize
=
64
;
let
mut
l
=
v
.
as_mut_ptr
(
)
;
let
mut
block_l
=
BLOCK
;
let
mut
start_l
=
ptr
:
:
null_mut
(
)
;
let
mut
end_l
=
ptr
:
:
null_mut
(
)
;
let
mut
offsets_l
:
[
u8
;
BLOCK
]
=
unsafe
{
mem
:
:
uninitialized
(
)
}
;
let
mut
r
=
unsafe
{
l
.
offset
(
v
.
len
(
)
as
isize
)
}
;
let
mut
block_r
=
BLOCK
;
let
mut
start_r
=
ptr
:
:
null_mut
(
)
;
let
mut
end_r
=
ptr
:
:
null_mut
(
)
;
let
mut
offsets_r
:
[
u8
;
BLOCK
]
=
unsafe
{
mem
:
:
uninitialized
(
)
}
;
fn
width
<
T
>
(
l
:
*
mut
T
r
:
*
mut
T
)
-
>
usize
{
(
r
as
usize
-
l
as
usize
)
/
mem
:
:
size_of
:
:
<
T
>
(
)
}
loop
{
let
is_done
=
width
(
l
r
)
<
=
2
*
BLOCK
;
if
is_done
{
let
rem
=
width
(
l
r
)
-
(
start_l
<
end_l
|
|
start_r
<
end_r
)
as
usize
*
BLOCK
;
if
start_l
<
end_l
{
block_r
=
rem
;
}
else
if
start_r
<
end_r
{
block_l
=
rem
;
}
else
{
block_l
=
rem
/
2
;
block_r
=
rem
-
block_l
;
}
debug_assert
!
(
width
(
l
r
)
=
=
block_l
+
block_r
)
;
}
if
start_l
=
=
end_l
{
start_l
=
offsets_l
.
as_mut_ptr
(
)
;
end_l
=
offsets_l
.
as_mut_ptr
(
)
;
let
mut
elem
=
l
;
for
i
in
0
.
.
block_l
{
unsafe
{
*
end_l
=
i
as
u8
;
end_l
=
end_l
.
offset
(
!
is_less
(
&
*
elem
pivot
)
as
isize
)
;
elem
=
elem
.
offset
(
1
)
;
}
}
}
if
start_r
=
=
end_r
{
start_r
=
offsets_r
.
as_mut_ptr
(
)
;
end_r
=
offsets_r
.
as_mut_ptr
(
)
;
let
mut
elem
=
r
;
for
i
in
0
.
.
block_r
{
unsafe
{
elem
=
elem
.
offset
(
-
1
)
;
*
end_r
=
i
as
u8
;
end_r
=
end_r
.
offset
(
is_less
(
&
*
elem
pivot
)
as
isize
)
;
}
}
}
let
count
=
cmp
:
:
min
(
width
(
start_l
end_l
)
width
(
start_r
end_r
)
)
;
if
count
>
0
{
macro_rules
!
left
{
(
)
=
>
{
l
.
offset
(
*
start_l
as
isize
)
}
}
macro_rules
!
right
{
(
)
=
>
{
r
.
offset
(
-
(
*
start_r
as
isize
)
-
1
)
}
}
unsafe
{
let
tmp
=
ptr
:
:
read
(
left
!
(
)
)
;
ptr
:
:
copy_nonoverlapping
(
right
!
(
)
left
!
(
)
1
)
;
for
_
in
1
.
.
count
{
start_l
=
start_l
.
offset
(
1
)
;
ptr
:
:
copy_nonoverlapping
(
left
!
(
)
right
!
(
)
1
)
;
start_r
=
start_r
.
offset
(
1
)
;
ptr
:
:
copy_nonoverlapping
(
right
!
(
)
left
!
(
)
1
)
;
}
ptr
:
:
copy_nonoverlapping
(
&
tmp
right
!
(
)
1
)
;
mem
:
:
forget
(
tmp
)
;
start_l
=
start_l
.
offset
(
1
)
;
start_r
=
start_r
.
offset
(
1
)
;
}
}
if
start_l
=
=
end_l
{
l
=
unsafe
{
l
.
offset
(
block_l
as
isize
)
}
;
}
if
start_r
=
=
end_r
{
r
=
unsafe
{
r
.
offset
(
-
(
block_r
as
isize
)
)
}
;
}
if
is_done
{
break
;
}
}
if
start_l
<
end_l
{
while
start_l
<
end_l
{
unsafe
{
end_l
=
end_l
.
offset
(
-
1
)
;
ptr
:
:
swap
(
l
.
offset
(
*
end_l
as
isize
)
r
.
offset
(
-
1
)
)
;
r
=
r
.
offset
(
-
1
)
;
}
}
width
(
v
.
as_mut_ptr
(
)
r
)
}
else
{
while
start_r
<
end_r
{
unsafe
{
end_r
=
end_r
.
offset
(
-
1
)
;
ptr
:
:
swap
(
l
r
.
offset
(
-
(
*
end_r
as
isize
)
-
1
)
)
;
l
=
l
.
offset
(
1
)
;
}
}
width
(
v
.
as_mut_ptr
(
)
l
)
}
}
fn
partition
<
T
F
>
(
v
:
&
mut
[
T
]
pivot
:
usize
is_less
:
&
mut
F
)
-
>
(
usize
bool
)
where
F
:
FnMut
(
&
T
&
T
)
-
>
bool
{
v
.
swap
(
0
pivot
)
;
let
(
mid
was_partitioned
)
=
{
let
(
pivot
v
)
=
v
.
split_at_mut
(
1
)
;
let
write_on_drop
=
WriteOnDrop
{
value
:
unsafe
{
Some
(
ptr
:
:
read
(
&
pivot
[
0
]
)
)
}
dest
:
&
mut
pivot
[
0
]
}
;
let
pivot
=
write_on_drop
.
value
.
as_ref
(
)
.
unwrap
(
)
;
let
mut
l
=
0
;
let
mut
r
=
v
.
len
(
)
;
unsafe
{
while
l
<
r
&
&
is_less
(
v
.
get_unchecked
(
l
)
pivot
)
{
l
+
=
1
;
}
while
l
<
r
&
&
!
is_less
(
v
.
get_unchecked
(
r
-
1
)
pivot
)
{
r
-
=
1
;
}
}
(
l
+
partition_in_blocks
(
&
mut
v
[
l
.
.
r
]
pivot
is_less
)
l
>
=
r
)
}
;
v
.
swap
(
0
mid
)
;
(
mid
was_partitioned
)
}
fn
partition_equal
<
T
F
>
(
v
:
&
mut
[
T
]
pivot
:
usize
is_less
:
&
mut
F
)
-
>
usize
where
F
:
FnMut
(
&
T
&
T
)
-
>
bool
{
v
.
swap
(
0
pivot
)
;
let
(
pivot
v
)
=
v
.
split_at_mut
(
1
)
;
let
write_on_drop
=
WriteOnDrop
{
value
:
unsafe
{
Some
(
ptr
:
:
read
(
&
pivot
[
0
]
)
)
}
dest
:
&
mut
pivot
[
0
]
}
;
let
pivot
=
write_on_drop
.
value
.
as_ref
(
)
.
unwrap
(
)
;
let
mut
l
=
0
;
let
mut
r
=
v
.
len
(
)
;
loop
{
unsafe
{
while
l
<
r
&
&
!
is_less
(
pivot
v
.
get_unchecked
(
l
)
)
{
l
+
=
1
;
}
while
l
<
r
&
&
is_less
(
pivot
v
.
get_unchecked
(
r
-
1
)
)
{
r
-
=
1
;
}
if
l
>
=
r
{
break
;
}
r
-
=
1
;
ptr
:
:
swap
(
v
.
get_unchecked_mut
(
l
)
v
.
get_unchecked_mut
(
r
)
)
;
l
+
=
1
;
}
}
l
+
1
}
#
[
cold
]
fn
break_patterns
<
T
>
(
v
:
&
mut
[
T
]
)
{
let
len
=
v
.
len
(
)
;
if
len
>
=
8
{
let
mut
rnd
=
len
as
u32
;
rnd
^
=
rnd
<
<
13
;
rnd
^
=
rnd
>
>
17
;
rnd
^
=
rnd
<
<
5
;
let
mask
=
(
len
/
4
)
.
next_power_of_two
(
)
-
1
;
let
rnd
=
rnd
as
usize
&
mask
;
debug_assert
!
(
rnd
<
len
/
2
)
;
let
a
=
len
/
4
*
2
;
let
b
=
len
/
4
+
rnd
;
for
i
in
0
.
.
3
{
v
.
swap
(
a
-
1
+
i
b
-
1
+
i
)
;
}
}
}
fn
choose_pivot
<
T
F
>
(
v
:
&
mut
[
T
]
is_less
:
&
mut
F
)
-
>
usize
where
F
:
FnMut
(
&
T
&
T
)
-
>
bool
{
const
SHORTEST_MEDIAN_OF_MEDIANS
:
usize
=
90
;
const
MAX_SWAPS
:
usize
=
4
*
3
;
let
len
=
v
.
len
(
)
;
let
mut
a
=
len
/
4
*
1
;
let
mut
b
=
len
/
4
*
2
;
let
mut
c
=
len
/
4
*
3
;
let
mut
swaps
=
0
;
if
len
>
=
4
{
let
mut
sort2
=
|
a
:
&
mut
usize
b
:
&
mut
usize
|
unsafe
{
if
is_less
(
v
.
get_unchecked
(
*
b
)
v
.
get_unchecked
(
*
a
)
)
{
ptr
:
:
swap
(
a
b
)
;
swaps
+
=
1
;
}
}
;
let
mut
sort3
=
|
a
:
&
mut
usize
b
:
&
mut
usize
c
:
&
mut
usize
|
{
sort2
(
a
b
)
;
sort2
(
b
c
)
;
sort2
(
a
b
)
;
}
;
if
len
>
=
SHORTEST_MEDIAN_OF_MEDIANS
{
let
mut
sort_adjacent
=
|
a
:
&
mut
usize
|
{
let
tmp
=
*
a
;
sort3
(
&
mut
(
tmp
-
1
)
a
&
mut
(
tmp
+
1
)
)
;
}
;
sort_adjacent
(
&
mut
a
)
;
sort_adjacent
(
&
mut
b
)
;
sort_adjacent
(
&
mut
c
)
;
}
sort3
(
&
mut
a
&
mut
b
&
mut
c
)
;
}
if
swaps
<
MAX_SWAPS
{
b
}
else
{
v
.
reverse
(
)
;
len
-
1
-
b
}
}
fn
recurse
<
T
F
>
(
v
:
&
mut
[
T
]
is_less
:
&
mut
F
pred
:
Option
<
&
T
>
mut
limit
:
usize
)
where
F
:
FnMut
(
&
T
&
T
)
-
>
bool
{
let
max_insertion
=
if
mem
:
:
size_of
:
:
<
T
>
(
)
<
=
2
*
mem
:
:
size_of
:
:
<
usize
>
(
)
{
32
}
else
{
16
}
;
let
len
=
v
.
len
(
)
;
if
len
<
=
max_insertion
{
insertion_sort
(
v
is_less
)
;
return
;
}
if
limit
=
=
0
{
heapsort
(
v
is_less
)
;
return
;
}
let
pivot
=
choose_pivot
(
v
is_less
)
;
if
let
Some
(
p
)
=
pred
{
if
!
is_less
(
p
&
v
[
pivot
]
)
{
let
mid
=
partition_equal
(
v
pivot
is_less
)
;
recurse
(
&
mut
v
[
mid
.
.
]
is_less
pred
limit
)
;
return
;
}
}
let
(
mid
was_partitioned
)
=
partition
(
v
pivot
is_less
)
;
let
is_balanced
=
cmp
:
:
min
(
mid
len
-
mid
)
>
=
len
/
8
;
if
is_balanced
&
&
was_partitioned
&
&
v
.
windows
(
2
)
.
all
(
|
w
|
!
is_less
(
&
w
[
1
]
&
w
[
0
]
)
)
{
return
;
}
let
(
left
right
)
=
v
.
split_at_mut
(
mid
)
;
let
(
pivot
right
)
=
right
.
split_at_mut
(
1
)
;
if
!
is_balanced
{
break_patterns
(
left
)
;
break_patterns
(
right
)
;
limit
-
=
1
;
}
recurse
(
left
is_less
pred
limit
)
;
recurse
(
right
is_less
Some
(
&
pivot
[
0
]
)
limit
)
;
}
fn
quicksort
<
T
F
>
(
v
:
&
mut
[
T
]
mut
is_less
:
F
)
where
F
:
FnMut
(
&
T
&
T
)
-
>
bool
{
if
mem
:
:
size_of
:
:
<
T
>
(
)
=
=
0
{
return
;
}
let
limit
=
64
-
(
v
.
len
(
)
as
u64
)
.
leading_zeros
(
)
as
usize
+
1
;
recurse
(
v
&
mut
is_less
None
limit
)
;
}
#
[
inline
]
pub
fn
sort
<
T
>
(
v
:
&
mut
[
T
]
)
where
T
:
Ord
{
quicksort
(
v
|
a
b
|
a
.
lt
(
b
)
)
;
}
#
[
inline
]
pub
fn
sort_by_key
<
T
B
F
>
(
v
:
&
mut
[
T
]
mut
f
:
F
)
where
F
:
FnMut
(
&
T
)
-
>
B
B
:
Ord
{
quicksort
(
v
|
a
b
|
f
(
a
)
.
lt
(
&
f
(
b
)
)
)
}
#
[
inline
]
pub
fn
sort_by
<
T
F
>
(
v
:
&
mut
[
T
]
mut
compare
:
F
)
where
F
:
FnMut
(
&
T
&
T
)
-
>
Ordering
{
quicksort
(
v
|
a
b
|
compare
(
a
b
)
=
=
Ordering
:
:
Less
)
;
}
#
[
cfg
(
test
)
]
mod
tests
{
extern
crate
std
;
extern
crate
rand
;
use
self
:
:
rand
:
:
{
Rng
thread_rng
}
;
use
self
:
:
std
:
:
cmp
:
:
Ordering
:
:
{
Greater
Less
}
;
use
self
:
:
std
:
:
prelude
:
:
v1
:
:
*
;
#
[
test
]
fn
test_sort_zero_sized_type
(
)
{
[
(
)
;
10
]
.
sort
(
)
;
[
(
)
;
100
]
.
sort
(
)
;
}
#
[
test
]
fn
test_pdqsort
(
)
{
let
mut
rng
=
thread_rng
(
)
;
for
n
in
0
.
.
16
{
for
l
in
0
.
.
16
{
let
mut
v
=
rng
.
gen_iter
:
:
<
u64
>
(
)
.
map
(
|
x
|
x
%
(
1
<
<
l
)
)
.
take
(
(
1
<
<
n
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
mut
v1
=
v
.
clone
(
)
;
super
:
:
sort
(
&
mut
v
)
;
assert
!
(
v
.
windows
(
2
)
.
all
(
|
w
|
w
[
0
]
<
=
w
[
1
]
)
)
;
v1
.
sort_by
(
|
a
b
|
a
.
cmp
(
b
)
)
;
assert
!
(
v1
.
windows
(
2
)
.
all
(
|
w
|
w
[
0
]
<
=
w
[
1
]
)
)
;
v1
.
sort_by
(
|
a
b
|
b
.
cmp
(
a
)
)
;
assert
!
(
v1
.
windows
(
2
)
.
all
(
|
w
|
w
[
0
]
>
=
w
[
1
]
)
)
;
}
}
let
mut
v
=
[
0xDEADBEEFu64
]
;
super
:
:
sort
(
&
mut
v
)
;
assert
!
(
v
=
=
[
0xDEADBEEF
]
)
;
}
#
[
test
]
fn
test_heapsort
(
)
{
let
mut
rng
=
thread_rng
(
)
;
for
n
in
0
.
.
16
{
for
l
in
0
.
.
16
{
let
mut
v
=
rng
.
gen_iter
:
:
<
u64
>
(
)
.
map
(
|
x
|
x
%
(
1
<
<
l
)
)
.
take
(
(
1
<
<
n
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
mut
v1
=
v
.
clone
(
)
;
super
:
:
heapsort
(
&
mut
v
&
mut
|
a
b
|
a
.
lt
(
b
)
)
;
assert
!
(
v
.
windows
(
2
)
.
all
(
|
w
|
w
[
0
]
<
=
w
[
1
]
)
)
;
v1
.
sort_by
(
|
a
b
|
a
.
cmp
(
b
)
)
;
assert
!
(
v1
.
windows
(
2
)
.
all
(
|
w
|
w
[
0
]
<
=
w
[
1
]
)
)
;
v1
.
sort_by
(
|
a
b
|
b
.
cmp
(
a
)
)
;
assert
!
(
v1
.
windows
(
2
)
.
all
(
|
w
|
w
[
0
]
>
=
w
[
1
]
)
)
;
}
}
let
mut
v
=
[
0xDEADBEEFu64
]
;
super
:
:
heapsort
(
&
mut
v
&
mut
|
a
b
|
a
.
lt
(
b
)
)
;
assert
!
(
v
=
=
[
0xDEADBEEF
]
)
;
}
#
[
test
]
fn
test_crazy_compare
(
)
{
let
mut
rng
=
thread_rng
(
)
;
let
mut
v
=
rng
.
gen_iter
:
:
<
u64
>
(
)
.
map
(
|
x
|
x
%
1000
)
.
take
(
100_000
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
super
:
:
sort_by
(
&
mut
v
|
_
_
|
*
rng
.
choose
(
&
[
Less
Greater
]
)
.
unwrap
(
)
)
;
}
}
