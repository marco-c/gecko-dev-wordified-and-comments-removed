#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
syn
/
0
.
12
.
12
"
)
]
#
!
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
const_static_lifetime
doc_markdown
large_enum_variant
match_bool
redundant_closure
needless_pass_by_value
)
)
]
extern
crate
proc_macro2
;
extern
crate
proc_macro
;
extern
crate
unicode_xid
;
#
[
cfg
(
feature
=
"
printing
"
)
]
extern
crate
quote
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
macro_use
]
#
[
doc
(
hidden
)
]
pub
mod
parsers
;
#
[
macro_use
]
mod
macros
;
#
[
macro_use
]
pub
mod
token
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
attr
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
attr
:
:
{
AttrStyle
Attribute
Meta
MetaList
MetaNameValue
NestedMeta
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
data
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
data
:
:
{
Field
Fields
FieldsNamed
FieldsUnnamed
Variant
VisCrate
VisPublic
VisRestricted
Visibility
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
expr
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
expr
:
:
{
Expr
ExprAddrOf
ExprArray
ExprAssign
ExprAssignOp
ExprBinary
ExprBlock
ExprBox
ExprBreak
ExprCall
ExprCast
ExprCatch
ExprClosure
ExprContinue
ExprField
ExprForLoop
ExprGroup
ExprIf
ExprIfLet
ExprInPlace
ExprIndex
ExprLit
ExprLoop
ExprMacro
ExprMatch
ExprMethodCall
ExprParen
ExprPath
ExprRange
ExprRepeat
ExprReturn
ExprStruct
ExprTry
ExprTuple
ExprType
ExprUnary
ExprUnsafe
ExprVerbatim
ExprWhile
ExprWhileLet
ExprYield
Index
Member
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
expr
:
:
{
Arm
Block
FieldPat
FieldValue
GenericMethodArgument
Label
Local
MethodTurbofish
Pat
PatBox
PatIdent
PatLit
PatMacro
PatPath
PatRange
PatRef
PatSlice
PatStruct
PatTuple
PatTupleStruct
PatVerbatim
PatWild
RangeLimits
Stmt
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
generics
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
generics
:
:
{
BoundLifetimes
ConstParam
GenericParam
Generics
LifetimeDef
PredicateEq
PredicateLifetime
PredicateType
TraitBound
TraitBoundModifier
TypeParam
TypeParamBound
WhereClause
WherePredicate
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
pub
use
generics
:
:
{
ImplGenerics
Turbofish
TypeGenerics
}
;
mod
ident
;
pub
use
ident
:
:
Ident
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
item
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
item
:
:
{
ArgCaptured
ArgSelf
ArgSelfRef
FnArg
FnDecl
ForeignItem
ForeignItemFn
ForeignItemStatic
ForeignItemType
ForeignItemVerbatim
ImplItem
ImplItemConst
ImplItemMacro
ImplItemMethod
ImplItemType
ImplItemVerbatim
Item
ItemConst
ItemEnum
ItemExternCrate
ItemFn
ItemForeignMod
ItemImpl
ItemMacro
ItemMacro2
ItemMod
ItemStatic
ItemStruct
ItemTrait
ItemType
ItemUnion
ItemUse
ItemVerbatim
MethodSig
TraitItem
TraitItemConst
TraitItemMacro
TraitItemMethod
TraitItemType
TraitItemVerbatim
UseGlob
UseList
UsePath
UseTree
}
;
#
[
cfg
(
feature
=
"
full
"
)
]
mod
file
;
#
[
cfg
(
feature
=
"
full
"
)
]
pub
use
file
:
:
File
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
lifetime
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
lifetime
:
:
Lifetime
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
lit
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
lit
:
:
{
FloatSuffix
IntSuffix
Lit
LitBool
LitByte
LitByteStr
LitChar
LitFloat
LitInt
LitStr
LitVerbatim
StrStyle
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
mac
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
mac
:
:
{
Macro
MacroDelimiter
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
derive
;
#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
derive
:
:
{
Data
DataEnum
DataStruct
DataUnion
DeriveInput
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
op
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
op
:
:
{
BinOp
UnOp
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
ty
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
ty
:
:
{
Abi
BareFnArg
BareFnArgName
ReturnType
Type
TypeArray
TypeBareFn
TypeGroup
TypeImplTrait
TypeInfer
TypeMacro
TypeNever
TypeParen
TypePath
TypePtr
TypeReference
TypeSlice
TypeTraitObject
TypeTuple
TypeVerbatim
}
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
path
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
pub
use
path
:
:
{
AngleBracketedGenericArguments
Binding
GenericArgument
ParenthesizedGenericArguments
Path
PathArguments
PathSegment
QSelf
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
pub
use
path
:
:
PathTokens
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
mod
buffer
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
mod
synom
;
pub
mod
punctuated
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
mod
tt
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
doc
(
hidden
)
]
pub
mod
parse_quote
;
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
printing
"
)
)
]
pub
mod
spanned
;
mod
gen
{
#
[
cfg
(
feature
=
"
visit
"
)
]
pub
mod
visit
;
#
[
cfg
(
feature
=
"
visit
-
mut
"
)
]
pub
mod
visit_mut
;
#
[
cfg
(
feature
=
"
fold
"
)
]
pub
mod
fold
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
#
[
path
=
"
.
.
/
gen_helper
.
rs
"
]
mod
helper
;
}
pub
use
gen
:
:
*
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
synom
:
:
{
Synom
Parser
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
mod
error
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
error
:
:
ParseError
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
#
[
doc
(
hidden
)
]
pub
use
error
:
:
parse_error
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
fn
parse
<
T
>
(
tokens
:
proc_macro
:
:
TokenStream
)
-
>
Result
<
T
ParseError
>
where
T
:
Synom
{
parse2
(
tokens
.
into
(
)
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
fn
parse2
<
T
>
(
tokens
:
proc_macro2
:
:
TokenStream
)
-
>
Result
<
T
ParseError
>
where
T
:
Synom
{
let
parser
=
T
:
:
parse
;
parser
.
parse2
(
tokens
)
.
map_err
(
|
err
|
{
match
T
:
:
description
(
)
{
Some
(
s
)
=
>
ParseError
:
:
new
(
format
!
(
"
failed
to
parse
{
}
:
{
}
"
s
err
)
)
None
=
>
err
}
}
)
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
pub
fn
parse_str
<
T
:
Synom
>
(
s
:
&
str
)
-
>
Result
<
T
ParseError
>
{
match
s
.
parse
(
)
{
Ok
(
tts
)
=
>
parse2
(
tts
)
Err
(
_
)
=
>
Err
(
ParseError
:
:
new
(
"
error
while
lexing
input
string
"
)
)
}
}
#
[
cfg
(
all
(
feature
=
"
parsing
"
feature
=
"
full
"
)
)
]
pub
fn
parse_file
(
mut
content
:
&
str
)
-
>
Result
<
File
ParseError
>
{
const
BOM
:
&
'
static
str
=
"
\
u
{
feff
}
"
;
if
content
.
starts_with
(
BOM
)
{
content
=
&
content
[
BOM
.
len
(
)
.
.
]
;
}
let
mut
shebang
=
None
;
if
content
.
starts_with
(
"
#
!
"
)
&
&
!
content
.
starts_with
(
"
#
!
[
"
)
{
if
let
Some
(
idx
)
=
content
.
find
(
'
\
n
'
)
{
shebang
=
Some
(
content
[
.
.
idx
]
.
to_string
(
)
)
;
content
=
&
content
[
idx
.
.
]
;
}
else
{
shebang
=
Some
(
content
.
to_string
(
)
)
;
content
=
"
"
;
}
}
let
mut
file
:
File
=
parse_str
(
content
)
?
;
file
.
shebang
=
shebang
;
Ok
(
file
)
}
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
struct
TokensOrDefault
<
'
a
T
:
'
a
>
(
&
'
a
Option
<
T
>
)
;
#
[
cfg
(
all
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
feature
=
"
printing
"
)
)
]
impl
<
'
a
T
>
quote
:
:
ToTokens
for
TokensOrDefault
<
'
a
T
>
where
T
:
quote
:
:
ToTokens
+
Default
{
fn
to_tokens
(
&
self
tokens
:
&
mut
quote
:
:
Tokens
)
{
match
*
self
.
0
{
Some
(
ref
t
)
=
>
t
.
to_tokens
(
tokens
)
None
=
>
T
:
:
default
(
)
.
to_tokens
(
tokens
)
}
}
}
