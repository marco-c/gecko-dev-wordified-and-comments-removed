#
[
macro_export
]
macro_rules
!
parse_quote
{
(
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
parse_quote
:
:
parse
(
crate
:
:
parse_quote
:
:
From
:
:
from
(
quote
!
(
(
tt
)
*
)
)
)
}
;
}
use
synom
:
:
{
Synom
Parser
PResult
}
;
use
buffer
:
:
Cursor
;
use
proc_macro2
:
:
TokenStream
;
#
[
doc
(
hidden
)
]
pub
use
std
:
:
convert
:
:
From
;
#
[
doc
(
hidden
)
]
pub
fn
parse
<
T
:
ParseQuote
>
(
token_stream
:
TokenStream
)
-
>
T
{
let
parser
=
T
:
:
parse
;
match
parser
.
parse2
(
token_stream
)
{
Ok
(
t
)
=
>
t
Err
(
err
)
=
>
match
T
:
:
description
(
)
{
Some
(
s
)
=
>
panic
!
(
"
failed
to
parse
{
}
:
{
}
"
s
err
)
None
=
>
panic
!
(
"
{
}
"
err
)
}
}
}
#
[
doc
(
hidden
)
]
pub
trait
ParseQuote
:
Sized
{
fn
parse
(
input
:
Cursor
)
-
>
PResult
<
Self
>
;
fn
description
(
)
-
>
Option
<
&
'
static
str
>
;
}
impl
<
T
>
ParseQuote
for
T
where
T
:
Synom
{
fn
parse
(
input
:
Cursor
)
-
>
PResult
<
Self
>
{
<
T
as
Synom
>
:
:
parse
(
input
)
}
fn
description
(
)
-
>
Option
<
&
'
static
str
>
{
<
T
as
Synom
>
:
:
description
(
)
}
}
use
punctuated
:
:
Punctuated
;
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
use
Attribute
;
impl
<
T
P
>
ParseQuote
for
Punctuated
<
T
P
>
where
T
:
Synom
P
:
Synom
{
named
!
(
parse
-
>
Self
call
!
(
Punctuated
:
:
parse_terminated
)
)
;
fn
description
(
)
-
>
Option
<
&
'
static
str
>
{
Some
(
"
punctuated
sequence
"
)
}
}
#
[
cfg
(
any
(
feature
=
"
full
"
feature
=
"
derive
"
)
)
]
impl
ParseQuote
for
Attribute
{
named
!
(
parse
-
>
Self
alt
!
(
call
!
(
Attribute
:
:
parse_outer
)
|
call
!
(
Attribute
:
:
parse_inner
)
)
)
;
fn
description
(
)
-
>
Option
<
&
'
static
str
>
{
Some
(
"
attribute
"
)
}
}
