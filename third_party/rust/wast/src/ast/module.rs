use
crate
:
:
ast
:
:
{
self
kw
annotation
}
;
use
crate
:
:
parser
:
:
{
Parse
Parser
Result
}
;
pub
use
crate
:
:
resolve
:
:
Names
;
pub
struct
Wat
<
'
a
>
{
#
[
allow
(
missing_docs
)
]
pub
module
:
Module
<
'
a
>
}
impl
<
'
a
>
Parse
<
'
a
>
for
Wat
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
_r
=
parser
.
register_annotation
(
"
custom
"
)
;
let
module
=
if
!
parser
.
peek2
:
:
<
kw
:
:
module
>
(
)
{
let
fields
=
ModuleField
:
:
parse_remaining
(
parser
)
?
;
if
fields
.
is_empty
(
)
{
return
Err
(
parser
.
error
(
"
expected
at
least
one
module
field
"
)
)
;
}
Module
{
span
:
ast
:
:
Span
{
offset
:
0
}
id
:
None
name
:
None
kind
:
ModuleKind
:
:
Text
(
fields
)
}
}
else
{
parser
.
parens
(
|
parser
|
parser
.
parse
(
)
)
?
}
;
module
.
validate
(
parser
)
?
;
Ok
(
Wat
{
module
}
)
}
}
pub
struct
Module
<
'
a
>
{
pub
span
:
ast
:
:
Span
pub
id
:
Option
<
ast
:
:
Id
<
'
a
>
>
pub
name
:
Option
<
ast
:
:
NameAnnotation
<
'
a
>
>
pub
kind
:
ModuleKind
<
'
a
>
}
pub
enum
ModuleKind
<
'
a
>
{
Text
(
Vec
<
ModuleField
<
'
a
>
>
)
Binary
(
Vec
<
&
'
a
[
u8
]
>
)
}
impl
<
'
a
>
Module
<
'
a
>
{
pub
fn
resolve
(
&
mut
self
)
-
>
std
:
:
result
:
:
Result
<
Names
<
'
a
>
crate
:
:
Error
>
{
crate
:
:
resolve
:
:
resolve
(
self
)
}
pub
fn
encode
(
&
mut
self
)
-
>
std
:
:
result
:
:
Result
<
Vec
<
u8
>
crate
:
:
Error
>
{
self
.
resolve
(
)
?
;
Ok
(
crate
:
:
binary
:
:
encode
(
self
)
)
}
fn
validate
(
&
self
parser
:
Parser
<
'
_
>
)
-
>
Result
<
(
)
>
{
let
mut
starts
=
0
;
if
let
ModuleKind
:
:
Text
(
fields
)
=
&
self
.
kind
{
for
item
in
fields
.
iter
(
)
{
if
let
ModuleField
:
:
Start
(
_
)
=
item
{
starts
+
=
1
;
}
}
}
if
starts
>
1
{
return
Err
(
parser
.
error
(
"
multiple
start
sections
found
"
)
)
;
}
Ok
(
(
)
)
}
}
impl
<
'
a
>
Parse
<
'
a
>
for
Module
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
_r
=
parser
.
register_annotation
(
"
custom
"
)
;
let
span
=
parser
.
parse
:
:
<
kw
:
:
module
>
(
)
?
.
0
;
let
id
=
parser
.
parse
(
)
?
;
let
name
=
parser
.
parse
(
)
?
;
let
kind
=
if
parser
.
peek
:
:
<
kw
:
:
binary
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
binary
>
(
)
?
;
let
mut
data
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
{
data
.
push
(
parser
.
parse
(
)
?
)
;
}
ModuleKind
:
:
Binary
(
data
)
}
else
{
ModuleKind
:
:
Text
(
ModuleField
:
:
parse_remaining
(
parser
)
?
)
}
;
Ok
(
Module
{
span
id
name
kind
}
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
enum
ModuleField
<
'
a
>
{
Type
(
ast
:
:
Type
<
'
a
>
)
Import
(
ast
:
:
Import
<
'
a
>
)
Func
(
ast
:
:
Func
<
'
a
>
)
Table
(
ast
:
:
Table
<
'
a
>
)
Memory
(
ast
:
:
Memory
<
'
a
>
)
Global
(
ast
:
:
Global
<
'
a
>
)
Export
(
ast
:
:
Export
<
'
a
>
)
Start
(
ast
:
:
Index
<
'
a
>
)
Elem
(
ast
:
:
Elem
<
'
a
>
)
Data
(
ast
:
:
Data
<
'
a
>
)
Event
(
ast
:
:
Event
<
'
a
>
)
GcOptIn
(
ast
:
:
GcOptIn
)
Custom
(
ast
:
:
Custom
<
'
a
>
)
}
impl
<
'
a
>
ModuleField
<
'
a
>
{
fn
parse_remaining
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Vec
<
ModuleField
>
>
{
let
mut
fields
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
{
fields
.
push
(
parser
.
parens
(
ModuleField
:
:
parse
)
?
)
;
}
Ok
(
fields
)
}
}
impl
<
'
a
>
Parse
<
'
a
>
for
ModuleField
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
if
parser
.
peek
:
:
<
kw
:
:
r
#
type
>
(
)
{
return
Ok
(
ModuleField
:
:
Type
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
import
>
(
)
{
return
Ok
(
ModuleField
:
:
Import
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
func
>
(
)
{
return
Ok
(
ModuleField
:
:
Func
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
table
>
(
)
{
return
Ok
(
ModuleField
:
:
Table
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
memory
>
(
)
{
return
Ok
(
ModuleField
:
:
Memory
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
global
>
(
)
{
return
Ok
(
ModuleField
:
:
Global
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
export
>
(
)
{
return
Ok
(
ModuleField
:
:
Export
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
start
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
start
>
(
)
?
;
return
Ok
(
ModuleField
:
:
Start
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
elem
>
(
)
{
return
Ok
(
ModuleField
:
:
Elem
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
data
>
(
)
{
return
Ok
(
ModuleField
:
:
Data
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
event
>
(
)
{
return
Ok
(
ModuleField
:
:
Event
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
gc_feature_opt_in
>
(
)
{
return
Ok
(
ModuleField
:
:
GcOptIn
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
annotation
:
:
custom
>
(
)
{
return
Ok
(
ModuleField
:
:
Custom
(
parser
.
parse
(
)
?
)
)
;
}
Err
(
parser
.
error
(
"
expected
valid
module
field
"
)
)
}
}
