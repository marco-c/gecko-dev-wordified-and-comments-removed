#
[
macro_export
]
macro_rules
!
custom_keyword
{
(
name
:
ident
)
=
>
{
crate
:
:
custom_keyword
!
(
name
=
stringify
!
(
name
)
)
;
}
;
(
name
:
ident
=
kw
:
expr
)
=
>
{
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
name
(
pub
crate
:
:
Span
)
;
impl
<
'
a
>
crate
:
:
parser
:
:
Parse
<
'
a
>
for
name
{
fn
parse
(
parser
:
crate
:
:
parser
:
:
Parser
<
'
a
>
)
-
>
crate
:
:
parser
:
:
Result
<
Self
>
{
parser
.
step
(
|
c
|
{
if
let
Some
(
(
kw
rest
)
)
=
c
.
keyword
(
)
{
if
kw
=
=
kw
{
return
Ok
(
(
name
(
c
.
cur_span
(
)
)
rest
)
)
;
}
}
Err
(
c
.
error
(
concat
!
(
"
expected
keyword
"
kw
"
"
)
)
)
}
)
}
}
impl
crate
:
:
parser
:
:
Peek
for
name
{
fn
peek
(
cursor
:
crate
:
:
parser
:
:
Cursor
<
'
_
>
)
-
>
bool
{
if
let
Some
(
(
kw
_rest
)
)
=
cursor
.
keyword
(
)
{
kw
=
=
kw
}
else
{
false
}
}
fn
display
(
)
-
>
&
'
static
str
{
concat
!
(
"
"
kw
"
"
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
custom_reserved
{
(
name
:
ident
)
=
>
{
crate
:
:
custom_reserved
!
(
name
=
stringify
!
(
name
)
)
;
}
;
(
name
:
ident
=
rsv
:
expr
)
=
>
{
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
struct
name
(
pub
crate
:
:
Span
)
;
impl
<
'
a
>
crate
:
:
parser
:
:
Parse
<
'
a
>
for
name
{
fn
parse
(
parser
:
crate
:
:
parser
:
:
Parser
<
'
a
>
)
-
>
crate
:
:
parser
:
:
Result
<
Self
>
{
parser
.
step
(
|
c
|
{
if
let
Some
(
(
rsv
rest
)
)
=
c
.
reserved
(
)
{
if
rsv
=
=
rsv
{
return
Ok
(
(
name
(
c
.
cur_span
(
)
)
rest
)
)
;
}
}
Err
(
c
.
error
(
concat
!
(
"
expected
reserved
symbol
"
rsv
"
"
)
)
)
}
)
}
}
impl
crate
:
:
parser
:
:
Peek
for
name
{
fn
peek
(
cursor
:
crate
:
:
parser
:
:
Cursor
<
'
_
>
)
-
>
bool
{
if
let
Some
(
(
rsv
_rest
)
)
=
cursor
.
reserved
(
)
{
rsv
=
=
rsv
}
else
{
false
}
}
fn
display
(
)
-
>
&
'
static
str
{
concat
!
(
"
"
rsv
"
"
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
annotation
{
(
name
:
ident
)
=
>
{
crate
:
:
annotation
!
(
name
=
stringify
!
(
name
)
)
;
}
;
(
name
:
ident
=
annotation
:
expr
)
=
>
{
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
struct
name
(
pub
crate
:
:
Span
)
;
impl
<
'
a
>
crate
:
:
parser
:
:
Parse
<
'
a
>
for
name
{
fn
parse
(
parser
:
crate
:
:
parser
:
:
Parser
<
'
a
>
)
-
>
crate
:
:
parser
:
:
Result
<
Self
>
{
parser
.
step
(
|
c
|
{
if
let
Some
(
(
a
rest
)
)
=
c
.
annotation
(
)
{
if
a
=
=
annotation
{
return
Ok
(
(
name
(
c
.
cur_span
(
)
)
rest
)
)
;
}
}
Err
(
c
.
error
(
concat
!
(
"
expected
annotation
"
annotation
"
"
)
)
)
}
)
}
}
impl
crate
:
:
parser
:
:
Peek
for
name
{
fn
peek
(
cursor
:
crate
:
:
parser
:
:
Cursor
<
'
_
>
)
-
>
bool
{
if
let
Some
(
(
a
_rest
)
)
=
cursor
.
annotation
(
)
{
a
=
=
annotation
}
else
{
false
}
}
fn
display
(
)
-
>
&
'
static
str
{
concat
!
(
"
"
annotation
"
"
)
}
}
}
;
}
macro_rules
!
reexport
{
(
(
mod
name
:
ident
;
)
*
)
=
>
(
(
mod
name
;
pub
use
self
:
:
name
:
:
*
;
)
*
)
;
}
reexport
!
{
mod
token
;
}
#
[
cfg
(
feature
=
"
wasm
-
module
"
)
]
reexport
!
{
mod
alias
;
mod
assert_expr
;
mod
custom
;
mod
event
;
mod
export
;
mod
expr
;
mod
func
;
mod
global
;
mod
import
;
mod
instance
;
mod
memory
;
mod
module
;
mod
nested_module
;
mod
table
;
mod
types
;
mod
wast
;
}
pub
mod
kw
{
custom_keyword
!
(
after
)
;
custom_keyword
!
(
alias
)
;
custom_keyword
!
(
any
)
;
custom_keyword
!
(
anyfunc
)
;
custom_keyword
!
(
anyref
)
;
custom_keyword
!
(
arg
)
;
custom_keyword
!
(
array
)
;
custom_keyword
!
(
assert_exhaustion
)
;
custom_keyword
!
(
assert_invalid
)
;
custom_keyword
!
(
assert_malformed
)
;
custom_keyword
!
(
assert_return
)
;
custom_keyword
!
(
assert_return_arithmetic_nan
)
;
custom_keyword
!
(
assert_return_arithmetic_nan_f32x4
)
;
custom_keyword
!
(
assert_return_arithmetic_nan_f64x2
)
;
custom_keyword
!
(
assert_return_canonical_nan
)
;
custom_keyword
!
(
assert_return_canonical_nan_f32x4
)
;
custom_keyword
!
(
assert_return_canonical_nan_f64x2
)
;
custom_keyword
!
(
assert_return_func
)
;
custom_keyword
!
(
assert_trap
)
;
custom_keyword
!
(
assert_unlinkable
)
;
custom_keyword
!
(
before
)
;
custom_keyword
!
(
binary
)
;
custom_keyword
!
(
block
)
;
custom_keyword
!
(
catch
)
;
custom_keyword
!
(
catch_all
)
;
custom_keyword
!
(
code
)
;
custom_keyword
!
(
data
)
;
custom_keyword
!
(
dataref
)
;
custom_keyword
!
(
declare
)
;
custom_keyword
!
(
delegate
)
;
custom_keyword
!
(
r
#
do
=
"
do
"
)
;
custom_keyword
!
(
elem
)
;
custom_keyword
!
(
end
)
;
custom_keyword
!
(
event
)
;
custom_keyword
!
(
export
)
;
custom_keyword
!
(
r
#
extern
=
"
extern
"
)
;
custom_keyword
!
(
externref
)
;
custom_keyword
!
(
eq
)
;
custom_keyword
!
(
eqref
)
;
custom_keyword
!
(
f32
)
;
custom_keyword
!
(
f32x4
)
;
custom_keyword
!
(
f64
)
;
custom_keyword
!
(
f64x2
)
;
custom_keyword
!
(
field
)
;
custom_keyword
!
(
first
)
;
custom_keyword
!
(
func
)
;
custom_keyword
!
(
funcref
)
;
custom_keyword
!
(
get
)
;
custom_keyword
!
(
global
)
;
custom_keyword
!
(
i16
)
;
custom_keyword
!
(
i16x8
)
;
custom_keyword
!
(
i31
)
;
custom_keyword
!
(
i31ref
)
;
custom_keyword
!
(
i32
)
;
custom_keyword
!
(
i32x4
)
;
custom_keyword
!
(
i64
)
;
custom_keyword
!
(
i64x2
)
;
custom_keyword
!
(
i8
)
;
custom_keyword
!
(
i8x16
)
;
custom_keyword
!
(
import
)
;
custom_keyword
!
(
instance
)
;
custom_keyword
!
(
instantiate
)
;
custom_keyword
!
(
invoke
)
;
custom_keyword
!
(
item
)
;
custom_keyword
!
(
last
)
;
custom_keyword
!
(
local
)
;
custom_keyword
!
(
memory
)
;
custom_keyword
!
(
module
)
;
custom_keyword
!
(
modulecode
)
;
custom_keyword
!
(
nan_arithmetic
=
"
nan
:
arithmetic
"
)
;
custom_keyword
!
(
nan_canonical
=
"
nan
:
canonical
"
)
;
custom_keyword
!
(
null
)
;
custom_keyword
!
(
nullref
)
;
custom_keyword
!
(
offset
)
;
custom_keyword
!
(
outer
)
;
custom_keyword
!
(
param
)
;
custom_keyword
!
(
parent
)
;
custom_keyword
!
(
passive
)
;
custom_keyword
!
(
quote
)
;
custom_keyword
!
(
r
#
else
=
"
else
"
)
;
custom_keyword
!
(
r
#
if
=
"
if
"
)
;
custom_keyword
!
(
r
#
loop
=
"
loop
"
)
;
custom_keyword
!
(
r
#
mut
=
"
mut
"
)
;
custom_keyword
!
(
r
#
type
=
"
type
"
)
;
custom_keyword
!
(
r
#
ref
=
"
ref
"
)
;
custom_keyword
!
(
ref_func
=
"
ref
.
func
"
)
;
custom_keyword
!
(
ref_null
=
"
ref
.
null
"
)
;
custom_keyword
!
(
register
)
;
custom_keyword
!
(
result
)
;
custom_keyword
!
(
rtt
)
;
custom_keyword
!
(
shared
)
;
custom_keyword
!
(
start
)
;
custom_keyword
!
(
r
#
struct
=
"
struct
"
)
;
custom_keyword
!
(
table
)
;
custom_keyword
!
(
then
)
;
custom_keyword
!
(
r
#
try
=
"
try
"
)
;
custom_keyword
!
(
unwind
)
;
custom_keyword
!
(
v128
)
;
}
pub
mod
annotation
{
annotation
!
(
custom
)
;
annotation
!
(
name
)
;
}
