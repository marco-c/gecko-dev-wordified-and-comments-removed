use
crate
:
:
token
:
:
Span
;
use
crate
:
:
Error
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
char
;
use
std
:
:
fmt
;
use
std
:
:
str
;
#
[
derive
(
Clone
)
]
pub
struct
Lexer
<
'
a
>
{
remaining
:
&
'
a
str
input
:
&
'
a
str
allow_confusing_unicode
:
bool
}
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
Token
<
'
a
>
{
LineComment
(
&
'
a
str
)
BlockComment
(
&
'
a
str
)
Whitespace
(
&
'
a
str
)
LParen
(
&
'
a
str
)
RParen
(
&
'
a
str
)
String
(
WasmString
<
'
a
>
)
Id
(
&
'
a
str
)
Keyword
(
&
'
a
str
)
Reserved
(
&
'
a
str
)
Integer
(
Integer
<
'
a
>
)
Float
(
Float
<
'
a
>
)
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
#
[
non_exhaustive
]
pub
enum
LexError
{
DanglingBlockComment
Unexpected
(
char
)
InvalidStringElement
(
char
)
InvalidStringEscape
(
char
)
InvalidHexDigit
(
char
)
InvalidDigit
(
char
)
Expected
{
wanted
:
char
found
:
char
}
UnexpectedEof
NumberTooBig
InvalidUnicodeValue
(
u32
)
LoneUnderscore
ConfusingUnicode
(
char
)
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
enum
SignToken
{
Plus
Minus
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
Integer
<
'
a
>
(
Box
<
IntegerInner
<
'
a
>
>
)
;
#
[
derive
(
Debug
PartialEq
)
]
struct
IntegerInner
<
'
a
>
{
sign
:
Option
<
SignToken
>
src
:
&
'
a
str
val
:
Cow
<
'
a
str
>
hex
:
bool
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
Float
<
'
a
>
(
Box
<
FloatInner
<
'
a
>
>
)
;
#
[
derive
(
Debug
PartialEq
)
]
struct
FloatInner
<
'
a
>
{
src
:
&
'
a
str
val
:
FloatVal
<
'
a
>
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
WasmString
<
'
a
>
(
Box
<
WasmStringInner
<
'
a
>
>
)
;
#
[
derive
(
Debug
PartialEq
)
]
struct
WasmStringInner
<
'
a
>
{
src
:
&
'
a
str
val
:
Cow
<
'
a
[
u8
]
>
}
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
FloatVal
<
'
a
>
{
Nan
{
val
:
Option
<
u64
>
negative
:
bool
}
Inf
{
#
[
allow
(
missing_docs
)
]
negative
:
bool
}
Val
{
hex
:
bool
integral
:
Cow
<
'
a
str
>
decimal
:
Option
<
Cow
<
'
a
str
>
>
exponent
:
Option
<
Cow
<
'
a
str
>
>
}
}
macro_rules
!
idchars
{
(
)
=
>
{
b
'
0
'
.
.
=
b
'
9
'
|
b
'
A
'
.
.
=
b
'
Z
'
|
b
'
a
'
.
.
=
b
'
z
'
|
b
'
!
'
|
b
'
#
'
|
b
'
'
|
b
'
%
'
|
b
'
&
'
|
b
'
\
'
'
|
b
'
*
'
|
b
'
+
'
|
b
'
-
'
|
b
'
.
'
|
b
'
/
'
|
b
'
:
'
|
b
'
<
'
|
b
'
=
'
|
b
'
>
'
|
b
'
?
'
|
b
'
'
|
b
'
\
\
'
|
b
'
^
'
|
b
'
_
'
|
b
'
'
|
b
'
|
'
|
b
'
~
'
}
}
impl
<
'
a
>
Lexer
<
'
a
>
{
pub
fn
new
(
input
:
&
str
)
-
>
Lexer
<
'
_
>
{
Lexer
{
remaining
:
input
input
allow_confusing_unicode
:
false
}
}
pub
fn
input
(
&
self
)
-
>
&
'
a
str
{
self
.
input
}
pub
fn
allow_confusing_unicode
(
&
mut
self
allow
:
bool
)
-
>
&
mut
Self
{
self
.
allow_confusing_unicode
=
allow
;
self
}
pub
fn
parse
(
&
mut
self
)
-
>
Result
<
Option
<
Token
<
'
a
>
>
Error
>
{
let
pos
=
self
.
cur
(
)
;
let
byte
=
match
self
.
remaining
.
as_bytes
(
)
.
get
(
0
)
{
Some
(
b
)
=
>
b
None
=
>
return
Ok
(
None
)
}
;
match
byte
{
b
'
(
'
=
>
match
self
.
remaining
.
as_bytes
(
)
.
get
(
1
)
{
Some
(
b
'
;
'
)
=
>
{
let
mut
level
=
1
;
let
mut
iter
=
self
.
remaining
.
as_bytes
(
)
[
2
.
.
]
.
iter
(
)
;
while
let
Some
(
ch
)
=
iter
.
next
(
)
{
match
ch
{
b
'
(
'
=
>
{
if
let
Some
(
b
'
;
'
)
=
iter
.
as_slice
(
)
.
get
(
0
)
{
level
+
=
1
;
iter
.
next
(
)
;
}
}
b
'
;
'
=
>
{
if
let
Some
(
b
'
)
'
)
=
iter
.
as_slice
(
)
.
get
(
0
)
{
level
-
=
1
;
iter
.
next
(
)
;
if
level
=
=
0
{
let
len
=
self
.
remaining
.
len
(
)
-
iter
.
as_slice
(
)
.
len
(
)
;
let
(
comment
remaining
)
=
self
.
remaining
.
split_at
(
len
)
;
self
.
remaining
=
remaining
;
self
.
check_confusing_comment
(
comment
)
?
;
return
Ok
(
Some
(
Token
:
:
BlockComment
(
comment
)
)
)
;
}
}
}
_
=
>
{
}
}
}
Err
(
self
.
error
(
pos
LexError
:
:
DanglingBlockComment
)
)
}
_
=
>
Ok
(
Some
(
Token
:
:
LParen
(
self
.
split_first_byte
(
)
)
)
)
}
b
'
)
'
=
>
Ok
(
Some
(
Token
:
:
RParen
(
self
.
split_first_byte
(
)
)
)
)
b
'
"
'
=
>
{
let
val
=
self
.
string
(
)
?
;
let
src
=
&
self
.
input
[
pos
.
.
self
.
cur
(
)
]
;
return
Ok
(
Some
(
Token
:
:
String
(
WasmString
(
Box
:
:
new
(
WasmStringInner
{
val
src
}
)
)
)
)
)
;
}
b
'
'
|
b
'
\
n
'
|
b
'
\
r
'
|
b
'
\
t
'
=
>
Ok
(
Some
(
Token
:
:
Whitespace
(
self
.
split_ws
(
)
)
)
)
c
idchars
!
(
)
=
>
{
let
reserved
=
self
.
split_while
(
|
b
|
match
b
{
idchars
!
(
)
=
>
true
_
=
>
false
}
)
;
if
let
Some
(
number
)
=
self
.
number
(
reserved
)
{
Ok
(
Some
(
number
)
)
}
else
if
*
c
=
=
b
'
'
&
&
reserved
.
len
(
)
>
1
{
Ok
(
Some
(
Token
:
:
Id
(
reserved
)
)
)
}
else
if
b
'
a
'
<
=
*
c
&
&
*
c
<
=
b
'
z
'
{
Ok
(
Some
(
Token
:
:
Keyword
(
reserved
)
)
)
}
else
{
Ok
(
Some
(
Token
:
:
Reserved
(
reserved
)
)
)
}
}
b
'
;
'
=
>
match
self
.
remaining
.
as_bytes
(
)
.
get
(
1
)
{
Some
(
b
'
;
'
)
=
>
{
let
comment
=
self
.
split_until
(
b
'
\
n
'
)
;
self
.
check_confusing_comment
(
comment
)
?
;
Ok
(
Some
(
Token
:
:
LineComment
(
comment
)
)
)
}
_
=
>
Ok
(
Some
(
Token
:
:
Reserved
(
self
.
split_first_byte
(
)
)
)
)
}
b
'
'
|
b
'
[
'
|
b
'
]
'
|
b
'
{
'
|
b
'
}
'
=
>
Ok
(
Some
(
Token
:
:
Reserved
(
self
.
split_first_byte
(
)
)
)
)
_
=
>
{
let
ch
=
self
.
remaining
.
chars
(
)
.
next
(
)
.
unwrap
(
)
;
Err
(
self
.
error
(
pos
LexError
:
:
Unexpected
(
ch
)
)
)
}
}
}
fn
split_first_byte
(
&
mut
self
)
-
>
&
'
a
str
{
let
(
token
remaining
)
=
self
.
remaining
.
split_at
(
1
)
;
self
.
remaining
=
remaining
;
token
}
fn
split_until
(
&
mut
self
byte
:
u8
)
-
>
&
'
a
str
{
let
pos
=
memchr
:
:
memchr
(
byte
self
.
remaining
.
as_bytes
(
)
)
.
unwrap_or
(
self
.
remaining
.
len
(
)
)
;
let
(
ret
remaining
)
=
self
.
remaining
.
split_at
(
pos
)
;
self
.
remaining
=
remaining
;
ret
}
fn
split_ws
(
&
mut
self
)
-
>
&
'
a
str
{
#
[
rustfmt
:
:
skip
]
const
WS
:
[
u8
;
256
]
=
[
0
0
0
0
0
0
0
0
0
1
1
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
;
let
pos
=
self
.
remaining
.
as_bytes
(
)
.
iter
(
)
.
position
(
|
b
|
WS
[
*
b
as
usize
]
!
=
1
)
.
unwrap_or
(
self
.
remaining
.
len
(
)
)
;
let
(
ret
remaining
)
=
self
.
remaining
.
split_at
(
pos
)
;
self
.
remaining
=
remaining
;
ret
}
fn
split_while
(
&
mut
self
f
:
impl
Fn
(
u8
)
-
>
bool
)
-
>
&
'
a
str
{
let
pos
=
self
.
remaining
.
as_bytes
(
)
.
iter
(
)
.
position
(
|
b
|
!
f
(
*
b
)
)
.
unwrap_or
(
self
.
remaining
.
len
(
)
)
;
let
(
ret
remaining
)
=
self
.
remaining
.
split_at
(
pos
)
;
self
.
remaining
=
remaining
;
ret
}
fn
number
(
&
self
src
:
&
'
a
str
)
-
>
Option
<
Token
<
'
a
>
>
{
let
(
sign
num
)
=
if
let
Some
(
stripped
)
=
src
.
strip_prefix
(
'
+
'
)
{
(
Some
(
SignToken
:
:
Plus
)
stripped
)
}
else
if
let
Some
(
stripped
)
=
src
.
strip_prefix
(
'
-
'
)
{
(
Some
(
SignToken
:
:
Minus
)
stripped
)
}
else
{
(
None
src
)
}
;
let
negative
=
sign
=
=
Some
(
SignToken
:
:
Minus
)
;
if
num
=
=
"
inf
"
{
return
Some
(
Token
:
:
Float
(
Float
(
Box
:
:
new
(
FloatInner
{
src
val
:
FloatVal
:
:
Inf
{
negative
}
}
)
)
)
)
;
}
else
if
num
=
=
"
nan
"
{
return
Some
(
Token
:
:
Float
(
Float
(
Box
:
:
new
(
FloatInner
{
src
val
:
FloatVal
:
:
Nan
{
val
:
None
negative
}
}
)
)
)
)
;
}
else
if
let
Some
(
stripped
)
=
num
.
strip_prefix
(
"
nan
:
0x
"
)
{
let
mut
it
=
stripped
.
chars
(
)
;
let
to_parse
=
skip_undescores
(
&
mut
it
false
char
:
:
is_ascii_hexdigit
)
?
;
if
it
.
next
(
)
.
is_some
(
)
{
return
None
;
}
let
n
=
u64
:
:
from_str_radix
(
&
to_parse
16
)
.
ok
(
)
?
;
return
Some
(
Token
:
:
Float
(
Float
(
Box
:
:
new
(
FloatInner
{
src
val
:
FloatVal
:
:
Nan
{
val
:
Some
(
n
)
negative
}
}
)
)
)
)
;
}
let
(
mut
it
hex
test_valid
)
=
if
let
Some
(
stripped
)
=
num
.
strip_prefix
(
"
0x
"
)
{
(
stripped
.
chars
(
)
true
char
:
:
is_ascii_hexdigit
as
fn
(
&
char
)
-
>
bool
)
}
else
{
(
num
.
chars
(
)
false
char
:
:
is_ascii_digit
as
fn
(
&
char
)
-
>
bool
)
}
;
let
val
=
skip_undescores
(
&
mut
it
negative
test_valid
)
?
;
match
it
.
clone
(
)
.
next
(
)
{
Some
(
_
)
=
>
{
}
None
=
>
{
return
Some
(
Token
:
:
Integer
(
Integer
(
Box
:
:
new
(
IntegerInner
{
sign
src
val
hex
}
)
)
)
)
}
}
let
decimal
=
if
it
.
clone
(
)
.
next
(
)
=
=
Some
(
'
.
'
)
{
it
.
next
(
)
;
match
it
.
clone
(
)
.
next
(
)
{
Some
(
c
)
if
test_valid
(
&
c
)
=
>
Some
(
skip_undescores
(
&
mut
it
false
test_valid
)
?
)
Some
(
_
)
|
None
=
>
None
}
}
else
{
None
}
;
let
exponent
=
match
(
hex
it
.
next
(
)
)
{
(
true
Some
(
'
p
'
)
)
|
(
true
Some
(
'
P
'
)
)
|
(
false
Some
(
'
e
'
)
)
|
(
false
Some
(
'
E
'
)
)
=
>
{
let
negative
=
match
it
.
clone
(
)
.
next
(
)
{
Some
(
'
-
'
)
=
>
{
it
.
next
(
)
;
true
}
Some
(
'
+
'
)
=
>
{
it
.
next
(
)
;
false
}
_
=
>
false
}
;
Some
(
skip_undescores
(
&
mut
it
negative
char
:
:
is_ascii_digit
)
?
)
}
(
_
None
)
=
>
None
_
=
>
return
None
}
;
if
it
.
next
(
)
.
is_some
(
)
{
return
None
;
}
return
Some
(
Token
:
:
Float
(
Float
(
Box
:
:
new
(
FloatInner
{
src
val
:
FloatVal
:
:
Val
{
hex
integral
:
val
exponent
decimal
}
}
)
)
)
)
;
fn
skip_undescores
<
'
a
>
(
it
:
&
mut
str
:
:
Chars
<
'
a
>
negative
:
bool
good
:
fn
(
&
char
)
-
>
bool
)
-
>
Option
<
Cow
<
'
a
str
>
>
{
enum
State
{
Raw
Collecting
(
String
)
}
let
mut
last_underscore
=
false
;
let
mut
state
=
if
negative
{
State
:
:
Collecting
(
"
-
"
.
to_string
(
)
)
}
else
{
State
:
:
Raw
}
;
let
input
=
it
.
as_str
(
)
;
let
first
=
it
.
next
(
)
?
;
if
!
good
(
&
first
)
{
return
None
;
}
if
let
State
:
:
Collecting
(
s
)
=
&
mut
state
{
s
.
push
(
first
)
;
}
let
mut
last
=
1
;
while
let
Some
(
c
)
=
it
.
clone
(
)
.
next
(
)
{
if
c
=
=
'
_
'
&
&
!
last_underscore
{
if
let
State
:
:
Raw
=
state
{
state
=
State
:
:
Collecting
(
input
[
.
.
last
]
.
to_string
(
)
)
;
}
it
.
next
(
)
;
last_underscore
=
true
;
continue
;
}
if
!
good
(
&
c
)
{
break
;
}
if
let
State
:
:
Collecting
(
s
)
=
&
mut
state
{
s
.
push
(
c
)
;
}
last_underscore
=
false
;
it
.
next
(
)
;
last
+
=
1
;
}
if
last_underscore
{
return
None
;
}
Some
(
match
state
{
State
:
:
Raw
=
>
input
[
.
.
last
]
.
into
(
)
State
:
:
Collecting
(
s
)
=
>
s
.
into
(
)
}
)
}
}
fn
check_confusing_comment
(
&
self
comment
:
&
str
)
-
>
Result
<
(
)
Error
>
{
if
self
.
allow_confusing_unicode
{
return
Ok
(
(
)
)
;
}
let
bytes
=
comment
.
as_bytes
(
)
;
for
pos
in
memchr
:
:
Memchr
:
:
new
(
0xe2
bytes
)
{
if
let
Some
(
c
)
=
comment
[
pos
.
.
]
.
chars
(
)
.
next
(
)
{
if
is_confusing_unicode
(
c
)
{
let
pos
=
self
.
cur
(
)
-
comment
.
len
(
)
+
pos
;
return
Err
(
self
.
error
(
pos
LexError
:
:
ConfusingUnicode
(
c
)
)
)
;
}
}
}
Ok
(
(
)
)
}
fn
string
(
&
mut
self
)
-
>
Result
<
Cow
<
'
a
[
u8
]
>
Error
>
{
let
mut
it
=
self
.
remaining
[
1
.
.
]
.
chars
(
)
;
let
result
=
Lexer
:
:
parse_str
(
&
mut
it
self
.
allow_confusing_unicode
)
;
let
end
=
self
.
input
.
len
(
)
-
it
.
as_str
(
)
.
len
(
)
;
self
.
remaining
=
&
self
.
input
[
end
.
.
]
;
result
.
map_err
(
|
e
|
{
let
err_pos
=
match
&
e
{
LexError
:
:
UnexpectedEof
=
>
self
.
input
.
len
(
)
_
=
>
self
.
input
[
.
.
end
]
.
char_indices
(
)
.
next_back
(
)
.
unwrap
(
)
.
0
}
;
self
.
error
(
err_pos
e
)
}
)
}
fn
parse_str
(
it
:
&
mut
str
:
:
Chars
<
'
a
>
allow_confusing_unicode
:
bool
)
-
>
Result
<
Cow
<
'
a
[
u8
]
>
LexError
>
{
enum
State
{
Start
String
(
Vec
<
u8
>
)
}
let
orig
=
it
.
as_str
(
)
;
let
mut
state
=
State
:
:
Start
;
loop
{
match
it
.
next
(
)
.
ok_or
(
LexError
:
:
UnexpectedEof
)
?
{
'
"
'
=
>
break
'
\
\
'
=
>
{
match
state
{
State
:
:
String
(
_
)
=
>
{
}
State
:
:
Start
=
>
{
let
pos
=
orig
.
len
(
)
-
it
.
as_str
(
)
.
len
(
)
-
1
;
state
=
State
:
:
String
(
orig
[
.
.
pos
]
.
as_bytes
(
)
.
to_vec
(
)
)
;
}
}
let
buf
=
match
&
mut
state
{
State
:
:
String
(
b
)
=
>
b
State
:
:
Start
=
>
unreachable
!
(
)
}
;
match
it
.
next
(
)
.
ok_or
(
LexError
:
:
UnexpectedEof
)
?
{
'
"
'
=
>
buf
.
push
(
b
'
"
'
)
'
\
'
'
=
>
buf
.
push
(
b
'
\
'
'
)
'
t
'
=
>
buf
.
push
(
b
'
\
t
'
)
'
n
'
=
>
buf
.
push
(
b
'
\
n
'
)
'
r
'
=
>
buf
.
push
(
b
'
\
r
'
)
'
\
\
'
=
>
buf
.
push
(
b
'
\
\
'
)
'
u
'
=
>
{
Lexer
:
:
must_eat_char
(
it
'
{
'
)
?
;
let
n
=
Lexer
:
:
hexnum
(
it
)
?
;
let
c
=
char
:
:
from_u32
(
n
)
.
ok_or
(
LexError
:
:
InvalidUnicodeValue
(
n
)
)
?
;
buf
.
extend
(
c
.
encode_utf8
(
&
mut
[
0
;
4
]
)
.
as_bytes
(
)
)
;
Lexer
:
:
must_eat_char
(
it
'
}
'
)
?
;
}
c1
if
c1
.
is_ascii_hexdigit
(
)
=
>
{
let
c2
=
Lexer
:
:
hexdigit
(
it
)
?
;
buf
.
push
(
to_hex
(
c1
)
*
16
+
c2
)
;
}
c
=
>
return
Err
(
LexError
:
:
InvalidStringEscape
(
c
)
)
}
}
c
if
(
c
as
u32
)
<
0x20
|
|
c
as
u32
=
=
0x7f
=
>
{
return
Err
(
LexError
:
:
InvalidStringElement
(
c
)
)
}
c
if
!
allow_confusing_unicode
&
&
is_confusing_unicode
(
c
)
=
>
{
return
Err
(
LexError
:
:
ConfusingUnicode
(
c
)
)
}
c
=
>
match
&
mut
state
{
State
:
:
Start
=
>
{
}
State
:
:
String
(
v
)
=
>
{
v
.
extend
(
c
.
encode_utf8
(
&
mut
[
0
;
4
]
)
.
as_bytes
(
)
)
;
}
}
}
}
match
state
{
State
:
:
Start
=
>
Ok
(
orig
[
.
.
orig
.
len
(
)
-
it
.
as_str
(
)
.
len
(
)
-
1
]
.
as_bytes
(
)
.
into
(
)
)
State
:
:
String
(
s
)
=
>
Ok
(
s
.
into
(
)
)
}
}
fn
hexnum
(
it
:
&
mut
str
:
:
Chars
<
'
_
>
)
-
>
Result
<
u32
LexError
>
{
let
n
=
Lexer
:
:
hexdigit
(
it
)
?
;
let
mut
last_underscore
=
false
;
let
mut
n
=
n
as
u32
;
while
let
Some
(
c
)
=
it
.
clone
(
)
.
next
(
)
{
if
c
=
=
'
_
'
{
it
.
next
(
)
;
last_underscore
=
true
;
continue
;
}
if
!
c
.
is_ascii_hexdigit
(
)
{
break
;
}
last_underscore
=
false
;
it
.
next
(
)
;
n
=
n
.
checked_mul
(
16
)
.
and_then
(
|
n
|
n
.
checked_add
(
to_hex
(
c
)
as
u32
)
)
.
ok_or
(
LexError
:
:
NumberTooBig
)
?
;
}
if
last_underscore
{
return
Err
(
LexError
:
:
LoneUnderscore
)
;
}
Ok
(
n
)
}
fn
hexdigit
(
it
:
&
mut
str
:
:
Chars
<
'
_
>
)
-
>
Result
<
u8
LexError
>
{
let
ch
=
Lexer
:
:
must_char
(
it
)
?
;
if
ch
.
is_ascii_hexdigit
(
)
{
Ok
(
to_hex
(
ch
)
)
}
else
{
Err
(
LexError
:
:
InvalidHexDigit
(
ch
)
)
}
}
fn
must_char
(
it
:
&
mut
str
:
:
Chars
<
'
_
>
)
-
>
Result
<
char
LexError
>
{
it
.
next
(
)
.
ok_or
(
LexError
:
:
UnexpectedEof
)
}
fn
must_eat_char
(
it
:
&
mut
str
:
:
Chars
<
'
_
>
wanted
:
char
)
-
>
Result
<
(
)
LexError
>
{
let
found
=
Lexer
:
:
must_char
(
it
)
?
;
if
wanted
=
=
found
{
Ok
(
(
)
)
}
else
{
Err
(
LexError
:
:
Expected
{
wanted
found
}
)
}
}
fn
cur
(
&
self
)
-
>
usize
{
self
.
input
.
len
(
)
-
self
.
remaining
.
len
(
)
}
fn
error
(
&
self
pos
:
usize
kind
:
LexError
)
-
>
Error
{
Error
:
:
lex
(
Span
{
offset
:
pos
}
self
.
input
kind
)
}
}
impl
<
'
a
>
Iterator
for
Lexer
<
'
a
>
{
type
Item
=
Result
<
Token
<
'
a
>
Error
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
parse
(
)
.
transpose
(
)
}
}
impl
<
'
a
>
Token
<
'
a
>
{
pub
fn
src
(
&
self
)
-
>
&
'
a
str
{
match
self
{
Token
:
:
Whitespace
(
s
)
=
>
s
Token
:
:
BlockComment
(
s
)
=
>
s
Token
:
:
LineComment
(
s
)
=
>
s
Token
:
:
LParen
(
s
)
=
>
s
Token
:
:
RParen
(
s
)
=
>
s
Token
:
:
String
(
s
)
=
>
s
.
src
(
)
Token
:
:
Id
(
s
)
=
>
s
Token
:
:
Keyword
(
s
)
=
>
s
Token
:
:
Reserved
(
s
)
=
>
s
Token
:
:
Integer
(
i
)
=
>
i
.
src
(
)
Token
:
:
Float
(
f
)
=
>
f
.
src
(
)
}
}
}
impl
<
'
a
>
Integer
<
'
a
>
{
pub
fn
sign
(
&
self
)
-
>
Option
<
SignToken
>
{
self
.
0
.
sign
}
pub
fn
src
(
&
self
)
-
>
&
'
a
str
{
self
.
0
.
src
}
pub
fn
val
(
&
self
)
-
>
(
&
str
u32
)
{
(
&
self
.
0
.
val
if
self
.
0
.
hex
{
16
}
else
{
10
}
)
}
}
impl
<
'
a
>
Float
<
'
a
>
{
pub
fn
src
(
&
self
)
-
>
&
'
a
str
{
self
.
0
.
src
}
pub
fn
val
(
&
self
)
-
>
&
FloatVal
<
'
a
>
{
&
self
.
0
.
val
}
}
impl
<
'
a
>
WasmString
<
'
a
>
{
pub
fn
src
(
&
self
)
-
>
&
'
a
str
{
self
.
0
.
src
}
pub
fn
val
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
.
val
}
}
fn
to_hex
(
c
:
char
)
-
>
u8
{
match
c
{
'
a
'
.
.
=
'
f
'
=
>
c
as
u8
-
b
'
a
'
+
10
'
A
'
.
.
=
'
F
'
=
>
c
as
u8
-
b
'
A
'
+
10
_
=
>
c
as
u8
-
b
'
0
'
}
}
impl
fmt
:
:
Display
for
LexError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
use
LexError
:
:
*
;
match
self
{
DanglingBlockComment
=
>
f
.
write_str
(
"
unterminated
block
comment
"
)
?
Unexpected
(
c
)
=
>
write
!
(
f
"
unexpected
character
'
{
}
'
"
escape_char
(
*
c
)
)
?
InvalidStringElement
(
c
)
=
>
{
write
!
(
f
"
invalid
character
in
string
'
{
}
'
"
escape_char
(
*
c
)
)
?
}
InvalidStringEscape
(
c
)
=
>
write
!
(
f
"
invalid
string
escape
'
{
}
'
"
escape_char
(
*
c
)
)
?
InvalidHexDigit
(
c
)
=
>
write
!
(
f
"
invalid
hex
digit
'
{
}
'
"
escape_char
(
*
c
)
)
?
InvalidDigit
(
c
)
=
>
write
!
(
f
"
invalid
decimal
digit
'
{
}
'
"
escape_char
(
*
c
)
)
?
Expected
{
wanted
found
}
=
>
write
!
(
f
"
expected
'
{
}
'
but
found
'
{
}
'
"
escape_char
(
*
wanted
)
escape_char
(
*
found
)
)
?
UnexpectedEof
=
>
write
!
(
f
"
unexpected
end
-
of
-
file
"
)
?
NumberTooBig
=
>
f
.
write_str
(
"
number
is
too
big
to
parse
"
)
?
InvalidUnicodeValue
(
c
)
=
>
write
!
(
f
"
invalid
unicode
scalar
value
0x
{
:
x
}
"
c
)
?
LoneUnderscore
=
>
write
!
(
f
"
bare
underscore
in
numeric
literal
"
)
?
ConfusingUnicode
(
c
)
=
>
write
!
(
f
"
likely
-
confusing
unicode
character
found
{
:
?
}
"
c
)
?
}
Ok
(
(
)
)
}
}
fn
escape_char
(
c
:
char
)
-
>
String
{
match
c
{
'
\
t
'
=
>
String
:
:
from
(
"
\
\
t
"
)
'
\
r
'
=
>
String
:
:
from
(
"
\
\
r
"
)
'
\
n
'
=
>
String
:
:
from
(
"
\
\
n
"
)
'
\
\
'
=
>
String
:
:
from
(
"
\
\
\
\
"
)
'
\
'
'
=
>
String
:
:
from
(
"
\
\
\
'
"
)
'
\
"
'
=
>
String
:
:
from
(
"
\
"
"
)
'
\
x20
'
.
.
=
'
\
x7e
'
=
>
String
:
:
from
(
c
)
_
=
>
c
.
escape_unicode
(
)
.
to_string
(
)
}
}
fn
is_confusing_unicode
(
ch
:
char
)
-
>
bool
{
match
ch
{
'
\
u
{
202a
}
'
|
'
\
u
{
202b
}
'
|
'
\
u
{
202d
}
'
|
'
\
u
{
202e
}
'
|
'
\
u
{
2066
}
'
|
'
\
u
{
2067
}
'
|
'
\
u
{
2068
}
'
|
'
\
u
{
206c
}
'
|
'
\
u
{
2069
}
'
=
>
true
_
=
>
false
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
ws_smoke
(
)
{
fn
get_whitespace
(
input
:
&
str
)
-
>
&
str
{
match
Lexer
:
:
new
(
input
)
.
parse
(
)
.
expect
(
"
no
first
token
"
)
{
Some
(
Token
:
:
Whitespace
(
s
)
)
=
>
s
other
=
>
panic
!
(
"
unexpected
{
:
?
}
"
other
)
}
}
assert_eq
!
(
get_whitespace
(
"
"
)
"
"
)
;
assert_eq
!
(
get_whitespace
(
"
"
)
"
"
)
;
assert_eq
!
(
get_whitespace
(
"
\
n
"
)
"
\
n
"
)
;
assert_eq
!
(
get_whitespace
(
"
x
"
)
"
"
)
;
assert_eq
!
(
get_whitespace
(
"
;
"
)
"
"
)
;
}
#
[
test
]
fn
line_comment_smoke
(
)
{
fn
get_line_comment
(
input
:
&
str
)
-
>
&
str
{
match
Lexer
:
:
new
(
input
)
.
parse
(
)
.
expect
(
"
no
first
token
"
)
{
Some
(
Token
:
:
LineComment
(
s
)
)
=
>
s
other
=
>
panic
!
(
"
unexpected
{
:
?
}
"
other
)
}
}
assert_eq
!
(
get_line_comment
(
"
;
;
"
)
"
;
;
"
)
;
assert_eq
!
(
get_line_comment
(
"
;
;
xyz
"
)
"
;
;
xyz
"
)
;
assert_eq
!
(
get_line_comment
(
"
;
;
xyz
\
nabc
"
)
"
;
;
xyz
"
)
;
assert_eq
!
(
get_line_comment
(
"
;
;
\
nabc
"
)
"
;
;
"
)
;
assert_eq
!
(
get_line_comment
(
"
;
;
\
nabc
"
)
"
;
;
"
)
;
}
#
[
test
]
fn
block_comment_smoke
(
)
{
fn
get_block_comment
(
input
:
&
str
)
-
>
&
str
{
match
Lexer
:
:
new
(
input
)
.
parse
(
)
.
expect
(
"
no
first
token
"
)
{
Some
(
Token
:
:
BlockComment
(
s
)
)
=
>
s
other
=
>
panic
!
(
"
unexpected
{
:
?
}
"
other
)
}
}
assert_eq
!
(
get_block_comment
(
"
(
;
;
)
"
)
"
(
;
;
)
"
)
;
assert_eq
!
(
get_block_comment
(
"
(
;
;
)
"
)
"
(
;
;
)
"
)
;
assert_eq
!
(
get_block_comment
(
"
(
;
(
;
;
)
;
)
"
)
"
(
;
(
;
;
)
;
)
"
)
;
}
fn
get_token
(
input
:
&
str
)
-
>
Token
<
'
_
>
{
Lexer
:
:
new
(
input
)
.
parse
(
)
.
expect
(
"
no
first
token
"
)
.
expect
(
"
no
token
"
)
}
#
[
test
]
fn
lparen
(
)
{
assert_eq
!
(
get_token
(
"
(
(
"
)
Token
:
:
LParen
(
"
(
"
)
)
;
}
#
[
test
]
fn
rparen
(
)
{
assert_eq
!
(
get_token
(
"
)
(
"
)
Token
:
:
RParen
(
"
)
"
)
)
;
}
#
[
test
]
fn
strings
(
)
{
fn
get_string
(
input
:
&
str
)
-
>
Vec
<
u8
>
{
match
get_token
(
input
)
{
Token
:
:
String
(
s
)
=
>
{
assert_eq
!
(
input
s
.
src
(
)
)
;
s
.
val
(
)
.
to_vec
(
)
}
other
=
>
panic
!
(
"
not
string
{
:
?
}
"
other
)
}
}
assert_eq
!
(
&
*
get_string
(
"
\
"
\
"
"
)
b
"
"
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
a
\
"
"
)
b
"
a
"
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
a
b
c
d
\
"
"
)
b
"
a
b
c
d
"
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
\
\
\
"
\
"
"
)
b
"
\
"
"
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
\
\
'
\
"
"
)
b
"
'
"
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
\
\
n
\
"
"
)
b
"
\
n
"
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
\
\
t
\
"
"
)
b
"
\
t
"
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
\
\
r
\
"
"
)
b
"
\
r
"
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
\
\
\
\
\
"
"
)
b
"
\
\
"
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
\
\
01
\
"
"
)
&
[
1
]
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
\
\
u
{
1
}
\
"
"
)
&
[
1
]
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
\
\
u
{
0f3
}
\
"
"
)
'
\
u
{
0f3
}
'
.
encode_utf8
(
&
mut
[
0
;
4
]
)
.
as_bytes
(
)
)
;
assert_eq
!
(
&
*
get_string
(
"
\
"
\
\
u
{
0_f_3
}
\
"
"
)
'
\
u
{
0f3
}
'
.
encode_utf8
(
&
mut
[
0
;
4
]
)
.
as_bytes
(
)
)
;
for
i
in
0
.
.
=
255i32
{
let
s
=
format
!
(
"
\
"
\
\
{
:
02x
}
\
"
"
i
)
;
assert_eq
!
(
&
*
get_string
(
&
s
)
&
[
i
as
u8
]
)
;
}
}
#
[
test
]
fn
id
(
)
{
fn
get_id
(
input
:
&
str
)
-
>
&
str
{
match
get_token
(
input
)
{
Token
:
:
Id
(
s
)
=
>
s
other
=
>
panic
!
(
"
not
id
{
:
?
}
"
other
)
}
}
assert_eq
!
(
get_id
(
"
x
"
)
"
x
"
)
;
assert_eq
!
(
get_id
(
"
xyz
"
)
"
xyz
"
)
;
assert_eq
!
(
get_id
(
"
x_z
"
)
"
x_z
"
)
;
assert_eq
!
(
get_id
(
"
0
^
"
)
"
0
^
"
)
;
assert_eq
!
(
get_id
(
"
0
^
;
;
"
)
"
0
^
"
)
;
assert_eq
!
(
get_id
(
"
0
^
;
;
"
)
"
0
^
"
)
;
}
#
[
test
]
fn
keyword
(
)
{
fn
get_keyword
(
input
:
&
str
)
-
>
&
str
{
match
get_token
(
input
)
{
Token
:
:
Keyword
(
s
)
=
>
s
other
=
>
panic
!
(
"
not
id
{
:
?
}
"
other
)
}
}
assert_eq
!
(
get_keyword
(
"
x
"
)
"
x
"
)
;
assert_eq
!
(
get_keyword
(
"
xyz
"
)
"
xyz
"
)
;
assert_eq
!
(
get_keyword
(
"
x_z
"
)
"
x_z
"
)
;
assert_eq
!
(
get_keyword
(
"
x_z
"
)
"
x_z
"
)
;
assert_eq
!
(
get_keyword
(
"
x_z
"
)
"
x_z
"
)
;
}
#
[
test
]
fn
reserved
(
)
{
fn
get_reserved
(
input
:
&
str
)
-
>
&
str
{
match
get_token
(
input
)
{
Token
:
:
Reserved
(
s
)
=
>
s
other
=
>
panic
!
(
"
not
reserved
{
:
?
}
"
other
)
}
}
assert_eq
!
(
get_reserved
(
"
"
)
"
"
)
;
assert_eq
!
(
get_reserved
(
"
^
_x
"
)
"
^
_x
"
)
;
}
#
[
test
]
fn
integer
(
)
{
fn
get_integer
(
input
:
&
str
)
-
>
String
{
match
get_token
(
input
)
{
Token
:
:
Integer
(
i
)
=
>
{
assert_eq
!
(
input
i
.
src
(
)
)
;
i
.
val
(
)
.
0
.
to_string
(
)
}
other
=
>
panic
!
(
"
not
integer
{
:
?
}
"
other
)
}
}
assert_eq
!
(
get_integer
(
"
1
"
)
"
1
"
)
;
assert_eq
!
(
get_integer
(
"
0
"
)
"
0
"
)
;
assert_eq
!
(
get_integer
(
"
-
1
"
)
"
-
1
"
)
;
assert_eq
!
(
get_integer
(
"
+
1
"
)
"
1
"
)
;
assert_eq
!
(
get_integer
(
"
+
1_000
"
)
"
1000
"
)
;
assert_eq
!
(
get_integer
(
"
+
1_0_0_0
"
)
"
1000
"
)
;
assert_eq
!
(
get_integer
(
"
+
0x10
"
)
"
10
"
)
;
assert_eq
!
(
get_integer
(
"
-
0x10
"
)
"
-
10
"
)
;
assert_eq
!
(
get_integer
(
"
0x10
"
)
"
10
"
)
;
}
#
[
test
]
fn
float
(
)
{
fn
get_float
(
input
:
&
str
)
-
>
FloatVal
<
'
_
>
{
match
get_token
(
input
)
{
Token
:
:
Float
(
i
)
=
>
{
assert_eq
!
(
input
i
.
src
(
)
)
;
i
.
0
.
val
}
other
=
>
panic
!
(
"
not
reserved
{
:
?
}
"
other
)
}
}
assert_eq
!
(
get_float
(
"
nan
"
)
FloatVal
:
:
Nan
{
val
:
None
negative
:
false
}
)
;
assert_eq
!
(
get_float
(
"
-
nan
"
)
FloatVal
:
:
Nan
{
val
:
None
negative
:
true
}
)
;
assert_eq
!
(
get_float
(
"
+
nan
"
)
FloatVal
:
:
Nan
{
val
:
None
negative
:
false
}
)
;
assert_eq
!
(
get_float
(
"
+
nan
:
0x1
"
)
FloatVal
:
:
Nan
{
val
:
Some
(
1
)
negative
:
false
}
)
;
assert_eq
!
(
get_float
(
"
nan
:
0x7f_ffff
"
)
FloatVal
:
:
Nan
{
val
:
Some
(
0x7fffff
)
negative
:
false
}
)
;
assert_eq
!
(
get_float
(
"
inf
"
)
FloatVal
:
:
Inf
{
negative
:
false
}
)
;
assert_eq
!
(
get_float
(
"
-
inf
"
)
FloatVal
:
:
Inf
{
negative
:
true
}
)
;
assert_eq
!
(
get_float
(
"
+
inf
"
)
FloatVal
:
:
Inf
{
negative
:
false
}
)
;
assert_eq
!
(
get_float
(
"
1
.
2
"
)
FloatVal
:
:
Val
{
integral
:
"
1
"
.
into
(
)
decimal
:
Some
(
"
2
"
.
into
(
)
)
exponent
:
None
hex
:
false
}
)
;
assert_eq
!
(
get_float
(
"
1
.
2e3
"
)
FloatVal
:
:
Val
{
integral
:
"
1
"
.
into
(
)
decimal
:
Some
(
"
2
"
.
into
(
)
)
exponent
:
Some
(
"
3
"
.
into
(
)
)
hex
:
false
}
)
;
assert_eq
!
(
get_float
(
"
-
1_2
.
1_1E
+
0_1
"
)
FloatVal
:
:
Val
{
integral
:
"
-
12
"
.
into
(
)
decimal
:
Some
(
"
11
"
.
into
(
)
)
exponent
:
Some
(
"
01
"
.
into
(
)
)
hex
:
false
}
)
;
assert_eq
!
(
get_float
(
"
+
1_2
.
1_1E
-
0_1
"
)
FloatVal
:
:
Val
{
integral
:
"
12
"
.
into
(
)
decimal
:
Some
(
"
11
"
.
into
(
)
)
exponent
:
Some
(
"
-
01
"
.
into
(
)
)
hex
:
false
}
)
;
assert_eq
!
(
get_float
(
"
0x1_2
.
3_4p5_6
"
)
FloatVal
:
:
Val
{
integral
:
"
12
"
.
into
(
)
decimal
:
Some
(
"
34
"
.
into
(
)
)
exponent
:
Some
(
"
56
"
.
into
(
)
)
hex
:
true
}
)
;
assert_eq
!
(
get_float
(
"
+
0x1_2
.
3_4P
-
5_6
"
)
FloatVal
:
:
Val
{
integral
:
"
12
"
.
into
(
)
decimal
:
Some
(
"
34
"
.
into
(
)
)
exponent
:
Some
(
"
-
56
"
.
into
(
)
)
hex
:
true
}
)
;
assert_eq
!
(
get_float
(
"
1
.
"
)
FloatVal
:
:
Val
{
integral
:
"
1
"
.
into
(
)
decimal
:
None
exponent
:
None
hex
:
false
}
)
;
assert_eq
!
(
get_float
(
"
0x1p
-
24
"
)
FloatVal
:
:
Val
{
integral
:
"
1
"
.
into
(
)
decimal
:
None
exponent
:
Some
(
"
-
24
"
.
into
(
)
)
hex
:
true
}
)
;
}
}
