use
crate
:
:
component
:
:
*
;
use
crate
:
:
core
;
use
crate
:
:
kw
;
use
crate
:
:
parser
:
:
{
Parse
Parser
Result
}
;
use
crate
:
:
token
:
:
{
Id
NameAnnotation
Span
}
;
#
[
derive
(
Debug
)
]
pub
struct
Component
<
'
a
>
{
pub
span
:
Span
pub
id
:
Option
<
Id
<
'
a
>
>
pub
name
:
Option
<
NameAnnotation
<
'
a
>
>
pub
kind
:
ComponentKind
<
'
a
>
}
#
[
derive
(
Debug
)
]
pub
enum
ComponentKind
<
'
a
>
{
Text
(
Vec
<
ComponentField
<
'
a
>
>
)
Binary
(
Vec
<
&
'
a
[
u8
]
>
)
}
impl
<
'
a
>
Component
<
'
a
>
{
pub
fn
resolve
(
&
mut
self
)
-
>
std
:
:
result
:
:
Result
<
(
)
crate
:
:
Error
>
{
match
&
mut
self
.
kind
{
ComponentKind
:
:
Text
(
fields
)
=
>
{
crate
:
:
component
:
:
expand
:
:
expand
(
fields
)
;
}
ComponentKind
:
:
Binary
(
_
)
=
>
{
}
}
crate
:
:
component
:
:
resolve
:
:
resolve
(
self
)
}
pub
fn
encode
(
&
mut
self
)
-
>
std
:
:
result
:
:
Result
<
Vec
<
u8
>
crate
:
:
Error
>
{
self
.
resolve
(
)
?
;
Ok
(
crate
:
:
component
:
:
binary
:
:
encode
(
self
)
)
}
pub
(
crate
)
fn
validate
(
&
self
parser
:
Parser
<
'
_
>
)
-
>
Result
<
(
)
>
{
let
mut
starts
=
0
;
if
let
ComponentKind
:
:
Text
(
fields
)
=
&
self
.
kind
{
for
item
in
fields
.
iter
(
)
{
if
let
ComponentField
:
:
Start
(
_
)
=
item
{
starts
+
=
1
;
}
}
}
if
starts
>
1
{
return
Err
(
parser
.
error
(
"
multiple
start
sections
found
"
)
)
;
}
Ok
(
(
)
)
}
}
impl
<
'
a
>
Parse
<
'
a
>
for
Component
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
_r
=
parser
.
register_annotation
(
"
custom
"
)
;
let
span
=
parser
.
parse
:
:
<
kw
:
:
component
>
(
)
?
.
0
;
let
id
=
parser
.
parse
(
)
?
;
let
name
=
parser
.
parse
(
)
?
;
let
kind
=
if
parser
.
peek
:
:
<
kw
:
:
binary
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
binary
>
(
)
?
;
let
mut
data
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
{
data
.
push
(
parser
.
parse
(
)
?
)
;
}
ComponentKind
:
:
Binary
(
data
)
}
else
{
ComponentKind
:
:
Text
(
ComponentField
:
:
parse_remaining
(
parser
)
?
)
}
;
Ok
(
Component
{
span
id
name
kind
}
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
enum
ComponentField
<
'
a
>
{
Type
(
TypeField
<
'
a
>
)
Import
(
ComponentImport
<
'
a
>
)
Func
(
ComponentFunc
<
'
a
>
)
Export
(
ComponentExport
<
'
a
>
)
Start
(
Start
<
'
a
>
)
Instance
(
Instance
<
'
a
>
)
Module
(
Module
<
'
a
>
)
Component
(
NestedComponent
<
'
a
>
)
Alias
(
Alias
<
'
a
>
)
}
impl
<
'
a
>
ComponentField
<
'
a
>
{
fn
parse_remaining
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Vec
<
ComponentField
>
>
{
let
mut
fields
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
{
fields
.
push
(
parser
.
parens
(
ComponentField
:
:
parse
)
?
)
;
}
Ok
(
fields
)
}
}
impl
<
'
a
>
Parse
<
'
a
>
for
ComponentField
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
if
parser
.
peek
:
:
<
kw
:
:
r
#
type
>
(
)
{
return
Ok
(
ComponentField
:
:
Type
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
import
>
(
)
{
return
Ok
(
ComponentField
:
:
Import
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
func
>
(
)
{
return
Ok
(
ComponentField
:
:
Func
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
export
>
(
)
{
return
Ok
(
ComponentField
:
:
Export
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
start
>
(
)
{
return
Ok
(
ComponentField
:
:
Start
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
instance
>
(
)
{
return
Ok
(
ComponentField
:
:
Instance
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
module
>
(
)
{
return
Ok
(
ComponentField
:
:
Module
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
component
>
(
)
{
return
Ok
(
ComponentField
:
:
Component
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
alias
>
(
)
{
return
Ok
(
ComponentField
:
:
Alias
(
parser
.
parse
(
)
?
)
)
;
}
Err
(
parser
.
error
(
"
expected
valid
component
field
"
)
)
}
}
impl
<
'
a
>
From
<
TypeField
<
'
a
>
>
for
ComponentField
<
'
a
>
{
fn
from
(
field
:
TypeField
<
'
a
>
)
-
>
ComponentField
<
'
a
>
{
ComponentField
:
:
Type
(
field
)
}
}
impl
<
'
a
>
From
<
Alias
<
'
a
>
>
for
ComponentField
<
'
a
>
{
fn
from
(
field
:
Alias
<
'
a
>
)
-
>
ComponentField
<
'
a
>
{
ComponentField
:
:
Alias
(
field
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Start
<
'
a
>
{
pub
func
:
ItemRef
<
'
a
kw
:
:
func
>
pub
args
:
Vec
<
ItemRef
<
'
a
kw
:
:
value
>
>
pub
result
:
Option
<
Id
<
'
a
>
>
}
impl
<
'
a
>
Parse
<
'
a
>
for
Start
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
parser
.
parse
:
:
<
kw
:
:
start
>
(
)
?
;
let
func
=
parser
.
parse
:
:
<
IndexOrRef
<
_
>
>
(
)
?
.
0
;
let
mut
args
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
&
&
!
parser
.
peek2
:
:
<
kw
:
:
result
>
(
)
{
args
.
push
(
parser
.
parse
(
)
?
)
;
}
let
result
=
if
!
parser
.
is_empty
(
)
{
parser
.
parens
(
|
parser
|
{
parser
.
parse
:
:
<
kw
:
:
result
>
(
)
?
;
if
!
parser
.
is_empty
(
)
{
parser
.
parens
(
|
parser
|
{
parser
.
parse
:
:
<
kw
:
:
value
>
(
)
?
;
let
id
=
parser
.
parse
(
)
?
;
Ok
(
Some
(
id
)
)
}
)
}
else
{
Ok
(
None
)
}
}
)
?
}
else
{
None
}
;
Ok
(
Start
{
func
args
result
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
NestedComponent
<
'
a
>
{
pub
span
:
Span
pub
id
:
Option
<
Id
<
'
a
>
>
pub
name
:
Option
<
NameAnnotation
<
'
a
>
>
pub
exports
:
core
:
:
InlineExport
<
'
a
>
pub
kind
:
NestedComponentKind
<
'
a
>
}
#
[
derive
(
Debug
)
]
pub
enum
NestedComponentKind
<
'
a
>
{
Import
{
import
:
InlineImport
<
'
a
>
ty
:
ComponentTypeUse
<
'
a
ComponentType
<
'
a
>
>
}
Inline
(
Vec
<
ComponentField
<
'
a
>
>
)
}
impl
<
'
a
>
Parse
<
'
a
>
for
NestedComponent
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
span
=
parser
.
parse
:
:
<
kw
:
:
component
>
(
)
?
.
0
;
let
id
=
parser
.
parse
(
)
?
;
let
name
=
parser
.
parse
(
)
?
;
let
exports
=
parser
.
parse
(
)
?
;
let
kind
=
if
let
Some
(
import
)
=
parser
.
parse
(
)
?
{
NestedComponentKind
:
:
Import
{
import
ty
:
parser
.
parse
(
)
?
}
}
else
{
let
mut
fields
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
{
fields
.
push
(
parser
.
parens
(
|
p
|
p
.
parse
(
)
)
?
)
;
}
NestedComponentKind
:
:
Inline
(
fields
)
}
;
Ok
(
NestedComponent
{
span
id
name
exports
kind
}
)
}
}
