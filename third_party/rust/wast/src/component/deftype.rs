use
crate
:
:
component
:
:
*
;
use
crate
:
:
core
;
use
crate
:
:
kw
;
use
crate
:
:
parser
:
:
{
Cursor
Parse
Parser
Peek
Result
}
;
#
[
derive
(
Debug
Clone
Copy
Hash
Eq
PartialEq
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
DefTypeKind
{
Func
Module
Component
Instance
Value
}
impl
<
'
a
>
Parse
<
'
a
>
for
DefTypeKind
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
mut
l
=
parser
.
lookahead1
(
)
;
if
l
.
peek
:
:
<
kw
:
:
func
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
func
>
(
)
?
;
Ok
(
DefTypeKind
:
:
Func
)
}
else
if
l
.
peek
:
:
<
kw
:
:
module
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
module
>
(
)
?
;
Ok
(
DefTypeKind
:
:
Module
)
}
else
if
l
.
peek
:
:
<
kw
:
:
component
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
component
>
(
)
?
;
Ok
(
DefTypeKind
:
:
Component
)
}
else
if
l
.
peek
:
:
<
kw
:
:
instance
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
instance
>
(
)
?
;
Ok
(
DefTypeKind
:
:
Instance
)
}
else
if
l
.
peek
:
:
<
kw
:
:
value
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
value
>
(
)
?
;
Ok
(
DefTypeKind
:
:
Value
)
}
else
{
Err
(
l
.
error
(
)
)
}
}
}
impl
Peek
for
DefTypeKind
{
fn
peek
(
cursor
:
Cursor
<
'
_
>
)
-
>
bool
{
kw
:
:
func
:
:
peek
(
cursor
)
|
|
kw
:
:
module
:
:
peek
(
cursor
)
|
|
kw
:
:
component
:
:
peek
(
cursor
)
|
|
kw
:
:
instance
:
:
peek
(
cursor
)
|
|
kw
:
:
value
:
:
peek
(
cursor
)
}
fn
display
(
)
-
>
&
'
static
str
{
"
deftype
kind
"
}
}
#
[
derive
(
Debug
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
DefType
<
'
a
>
{
Func
(
ComponentFunctionType
<
'
a
>
)
Module
(
ModuleType
<
'
a
>
)
Component
(
ComponentType
<
'
a
>
)
Instance
(
InstanceType
<
'
a
>
)
Value
(
ValueType
<
'
a
>
)
}
impl
<
'
a
>
Parse
<
'
a
>
for
DefType
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
if
parser
.
peek
:
:
<
kw
:
:
func
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
func
>
(
)
?
;
Ok
(
DefType
:
:
Func
(
parser
.
parse
(
)
?
)
)
}
else
if
parser
.
peek
:
:
<
kw
:
:
module
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
module
>
(
)
?
;
Ok
(
DefType
:
:
Module
(
parser
.
parse
(
)
?
)
)
}
else
if
parser
.
peek
:
:
<
kw
:
:
component
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
component
>
(
)
?
;
Ok
(
DefType
:
:
Component
(
parser
.
parse
(
)
?
)
)
}
else
if
parser
.
peek
:
:
<
kw
:
:
instance
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
instance
>
(
)
?
;
Ok
(
DefType
:
:
Instance
(
parser
.
parse
(
)
?
)
)
}
else
if
parser
.
peek
:
:
<
kw
:
:
value
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
value
>
(
)
?
;
Ok
(
DefType
:
:
Value
(
parser
.
parse
(
)
?
)
)
}
else
{
Err
(
parser
.
error
(
"
expected
a
deftype
"
)
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
ComponentFunctionType
<
'
a
>
{
pub
params
:
Box
<
[
ComponentFunctionParam
<
'
a
>
]
>
pub
result
:
InterTypeRef
<
'
a
>
}
impl
<
'
a
>
Parse
<
'
a
>
for
ComponentFunctionType
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
mut
params
=
Vec
:
:
new
(
)
;
while
parser
.
peek2
:
:
<
kw
:
:
param
>
(
)
{
parser
.
parens
(
|
p
|
{
p
.
parse
:
:
<
kw
:
:
param
>
(
)
?
;
params
.
push
(
ComponentFunctionParam
{
name
:
p
.
parse
(
)
?
type_
:
p
.
parse
(
)
?
}
)
;
Ok
(
(
)
)
}
)
?
;
}
let
result
=
if
parser
.
peek2
:
:
<
kw
:
:
result
>
(
)
{
parser
.
parens
(
|
parser
|
{
parser
.
parse
:
:
<
kw
:
:
result
>
(
)
?
;
parser
.
parse
(
)
}
)
?
}
else
{
InterTypeRef
:
:
Primitive
(
Primitive
:
:
Unit
)
}
;
Ok
(
Self
{
params
:
params
.
into
(
)
result
}
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ComponentFunctionParam
<
'
a
>
{
pub
name
:
Option
<
&
'
a
str
>
pub
type_
:
InterTypeRef
<
'
a
>
}
#
[
derive
(
Debug
)
]
pub
struct
ModuleType
<
'
a
>
{
pub
defs
:
Vec
<
ModuleTypeDef
<
'
a
>
>
}
impl
<
'
a
>
Parse
<
'
a
>
for
ModuleType
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
if
parser
.
parens_depth
(
)
>
100
{
return
Err
(
parser
.
error
(
"
module
type
nesting
too
deep
"
)
)
;
}
let
mut
defs
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
{
defs
.
push
(
parser
.
parens
(
|
p
|
p
.
parse
(
)
)
?
)
;
}
Ok
(
ModuleType
{
defs
}
)
}
}
#
[
derive
(
Debug
)
]
pub
enum
ModuleTypeDef
<
'
a
>
{
Type
(
core
:
:
Type
<
'
a
>
)
Import
(
core
:
:
Import
<
'
a
>
)
Export
(
&
'
a
str
core
:
:
ItemSig
<
'
a
>
)
}
impl
<
'
a
>
Parse
<
'
a
>
for
ModuleTypeDef
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
mut
l
=
parser
.
lookahead1
(
)
;
if
l
.
peek
:
:
<
kw
:
:
r
#
type
>
(
)
{
Ok
(
ModuleTypeDef
:
:
Type
(
parser
.
parse
(
)
?
)
)
}
else
if
l
.
peek
:
:
<
kw
:
:
import
>
(
)
{
Ok
(
ModuleTypeDef
:
:
Import
(
parser
.
parse
(
)
?
)
)
}
else
if
l
.
peek
:
:
<
kw
:
:
export
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
export
>
(
)
?
;
let
name
=
parser
.
parse
(
)
?
;
let
et
=
parser
.
parens
(
|
parser
|
parser
.
parse
(
)
)
?
;
Ok
(
ModuleTypeDef
:
:
Export
(
name
et
)
)
}
else
{
Err
(
parser
.
error
(
"
Expected
a
moduletype
-
def
"
)
)
}
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
ComponentType
<
'
a
>
{
pub
fields
:
Vec
<
ComponentTypeField
<
'
a
>
>
}
impl
<
'
a
>
Parse
<
'
a
>
for
ComponentType
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
if
parser
.
parens_depth
(
)
>
100
{
return
Err
(
parser
.
error
(
"
component
type
nesting
too
deep
"
)
)
;
}
let
mut
fields
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
{
parser
.
parens
(
|
parser
|
{
if
parser
.
peek
:
:
<
kw
:
:
import
>
(
)
{
fields
.
push
(
ComponentTypeField
:
:
Import
(
parser
.
parse
(
)
?
)
)
;
}
else
if
parser
.
peek
:
:
<
kw
:
:
export
>
(
)
{
fields
.
push
(
ComponentTypeField
:
:
Export
(
parser
.
parse
(
)
?
)
)
;
}
else
if
parser
.
peek
:
:
<
kw
:
:
r
#
type
>
(
)
{
fields
.
push
(
ComponentTypeField
:
:
Type
(
parser
.
parse
(
)
?
)
)
;
}
else
if
parser
.
peek
:
:
<
kw
:
:
alias
>
(
)
{
fields
.
push
(
ComponentTypeField
:
:
Alias
(
parser
.
parse
(
)
?
)
)
;
}
Ok
(
(
)
)
}
)
?
;
}
Ok
(
ComponentType
{
fields
}
)
}
}
#
[
derive
(
Debug
)
]
pub
enum
ComponentTypeField
<
'
a
>
{
Type
(
TypeField
<
'
a
>
)
Alias
(
Alias
<
'
a
>
)
Import
(
ComponentImport
<
'
a
>
)
Export
(
ComponentExportType
<
'
a
>
)
}
impl
<
'
a
>
From
<
TypeField
<
'
a
>
>
for
ComponentTypeField
<
'
a
>
{
fn
from
(
field
:
TypeField
<
'
a
>
)
-
>
ComponentTypeField
<
'
a
>
{
ComponentTypeField
:
:
Type
(
field
)
}
}
impl
<
'
a
>
From
<
Alias
<
'
a
>
>
for
ComponentTypeField
<
'
a
>
{
fn
from
(
field
:
Alias
<
'
a
>
)
-
>
ComponentTypeField
<
'
a
>
{
ComponentTypeField
:
:
Alias
(
field
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
InstanceType
<
'
a
>
{
pub
fields
:
Vec
<
InstanceTypeField
<
'
a
>
>
}
impl
<
'
a
>
Parse
<
'
a
>
for
InstanceType
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
if
parser
.
parens_depth
(
)
>
100
{
return
Err
(
parser
.
error
(
"
instance
type
nesting
too
deep
"
)
)
;
}
let
mut
fields
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
{
parser
.
parens
(
|
parser
|
{
let
mut
l
=
parser
.
lookahead1
(
)
;
if
l
.
peek
:
:
<
kw
:
:
export
>
(
)
{
fields
.
push
(
InstanceTypeField
:
:
Export
(
parser
.
parse
(
)
?
)
)
;
}
else
if
l
.
peek
:
:
<
kw
:
:
r
#
type
>
(
)
{
fields
.
push
(
InstanceTypeField
:
:
Type
(
parser
.
parse
(
)
?
)
)
;
}
else
if
l
.
peek
:
:
<
kw
:
:
alias
>
(
)
{
fields
.
push
(
InstanceTypeField
:
:
Alias
(
parser
.
parse
(
)
?
)
)
;
}
else
{
return
Err
(
l
.
error
(
)
)
;
}
Ok
(
(
)
)
}
)
?
;
}
Ok
(
InstanceType
{
fields
}
)
}
}
#
[
derive
(
Debug
)
]
pub
enum
InstanceTypeField
<
'
a
>
{
Type
(
TypeField
<
'
a
>
)
Alias
(
Alias
<
'
a
>
)
Export
(
ComponentExportType
<
'
a
>
)
}
impl
<
'
a
>
From
<
TypeField
<
'
a
>
>
for
InstanceTypeField
<
'
a
>
{
fn
from
(
field
:
TypeField
<
'
a
>
)
-
>
InstanceTypeField
<
'
a
>
{
InstanceTypeField
:
:
Type
(
field
)
}
}
impl
<
'
a
>
From
<
Alias
<
'
a
>
>
for
InstanceTypeField
<
'
a
>
{
fn
from
(
field
:
Alias
<
'
a
>
)
-
>
InstanceTypeField
<
'
a
>
{
InstanceTypeField
:
:
Alias
(
field
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ValueType
<
'
a
>
{
pub
value_type
:
InterTypeRef
<
'
a
>
}
impl
<
'
a
>
Parse
<
'
a
>
for
ValueType
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
Ok
(
ValueType
{
value_type
:
parser
.
parse
(
)
?
}
)
}
}
