use
super
:
:
{
ComponentExternName
ItemRef
ItemSigNoName
}
;
use
crate
:
:
kw
;
use
crate
:
:
parser
:
:
{
Cursor
Parse
Parser
Peek
Result
}
;
use
crate
:
:
token
:
:
{
Id
Index
NameAnnotation
Span
}
;
#
[
derive
(
Debug
)
]
pub
struct
ComponentExport
<
'
a
>
{
pub
span
:
Span
pub
id
:
Option
<
Id
<
'
a
>
>
pub
debug_name
:
Option
<
NameAnnotation
<
'
a
>
>
pub
name
:
ComponentExternName
<
'
a
>
pub
kind
:
ComponentExportKind
<
'
a
>
pub
ty
:
Option
<
ItemSigNoName
<
'
a
>
>
}
impl
<
'
a
>
Parse
<
'
a
>
for
ComponentExport
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
span
=
parser
.
parse
:
:
<
kw
:
:
export
>
(
)
?
.
0
;
let
id
=
parser
.
parse
(
)
?
;
let
debug_name
=
parser
.
parse
(
)
?
;
let
name
=
parser
.
parse
(
)
?
;
let
kind
=
parser
.
parse
(
)
?
;
let
ty
=
if
!
parser
.
is_empty
(
)
{
Some
(
parser
.
parens
(
|
p
|
p
.
parse
(
)
)
?
)
}
else
{
None
}
;
Ok
(
ComponentExport
{
span
id
debug_name
name
kind
ty
}
)
}
}
impl
<
'
a
>
Parse
<
'
a
>
for
Vec
<
ComponentExport
<
'
a
>
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
mut
exports
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
{
exports
.
push
(
parser
.
parens
(
|
parser
|
parser
.
parse
(
)
)
?
)
;
}
Ok
(
exports
)
}
}
#
[
derive
(
Debug
)
]
pub
enum
ComponentExportKind
<
'
a
>
{
CoreModule
(
ItemRef
<
'
a
kw
:
:
module
>
)
Func
(
ItemRef
<
'
a
kw
:
:
func
>
)
Value
(
ItemRef
<
'
a
kw
:
:
value
>
)
Type
(
ItemRef
<
'
a
kw
:
:
r
#
type
>
)
Component
(
ItemRef
<
'
a
kw
:
:
component
>
)
Instance
(
ItemRef
<
'
a
kw
:
:
instance
>
)
}
impl
<
'
a
>
ComponentExportKind
<
'
a
>
{
pub
(
crate
)
fn
module
(
span
:
Span
id
:
Id
<
'
a
>
)
-
>
Self
{
Self
:
:
CoreModule
(
ItemRef
{
kind
:
kw
:
:
module
(
span
)
idx
:
Index
:
:
Id
(
id
)
export_names
:
Default
:
:
default
(
)
}
)
}
pub
(
crate
)
fn
component
(
span
:
Span
id
:
Id
<
'
a
>
)
-
>
Self
{
Self
:
:
Component
(
ItemRef
{
kind
:
kw
:
:
component
(
span
)
idx
:
Index
:
:
Id
(
id
)
export_names
:
Default
:
:
default
(
)
}
)
}
pub
(
crate
)
fn
instance
(
span
:
Span
id
:
Id
<
'
a
>
)
-
>
Self
{
Self
:
:
Instance
(
ItemRef
{
kind
:
kw
:
:
instance
(
span
)
idx
:
Index
:
:
Id
(
id
)
export_names
:
Default
:
:
default
(
)
}
)
}
pub
(
crate
)
fn
func
(
span
:
Span
id
:
Id
<
'
a
>
)
-
>
Self
{
Self
:
:
Func
(
ItemRef
{
kind
:
kw
:
:
func
(
span
)
idx
:
Index
:
:
Id
(
id
)
export_names
:
Default
:
:
default
(
)
}
)
}
pub
(
crate
)
fn
ty
(
span
:
Span
id
:
Id
<
'
a
>
)
-
>
Self
{
Self
:
:
Type
(
ItemRef
{
kind
:
kw
:
:
r
#
type
(
span
)
idx
:
Index
:
:
Id
(
id
)
export_names
:
Default
:
:
default
(
)
}
)
}
}
impl
<
'
a
>
Parse
<
'
a
>
for
ComponentExportKind
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
parser
.
parens
(
|
parser
|
{
let
mut
l
=
parser
.
lookahead1
(
)
;
if
l
.
peek
:
:
<
kw
:
:
core
>
(
)
?
{
parser
.
parse
:
:
<
kw
:
:
core
>
(
)
?
;
Ok
(
Self
:
:
CoreModule
(
parser
.
parse
(
)
?
)
)
}
else
if
l
.
peek
:
:
<
kw
:
:
func
>
(
)
?
{
Ok
(
Self
:
:
Func
(
parser
.
parse
(
)
?
)
)
}
else
if
l
.
peek
:
:
<
kw
:
:
value
>
(
)
?
{
Ok
(
Self
:
:
Value
(
parser
.
parse
(
)
?
)
)
}
else
if
l
.
peek
:
:
<
kw
:
:
r
#
type
>
(
)
?
{
Ok
(
Self
:
:
Type
(
parser
.
parse
(
)
?
)
)
}
else
if
l
.
peek
:
:
<
kw
:
:
component
>
(
)
?
{
Ok
(
Self
:
:
Component
(
parser
.
parse
(
)
?
)
)
}
else
if
l
.
peek
:
:
<
kw
:
:
instance
>
(
)
?
{
Ok
(
Self
:
:
Instance
(
parser
.
parse
(
)
?
)
)
}
else
{
Err
(
l
.
error
(
)
)
}
}
)
}
}
impl
Peek
for
ComponentExportKind
<
'
_
>
{
fn
peek
(
cursor
:
Cursor
)
-
>
Result
<
bool
>
{
let
cursor
=
match
cursor
.
lparen
(
)
?
{
Some
(
c
)
=
>
c
None
=
>
return
Ok
(
false
)
}
;
let
cursor
=
match
cursor
.
keyword
(
)
?
{
Some
(
(
"
core
"
c
)
)
=
>
match
c
.
keyword
(
)
?
{
Some
(
(
"
module
"
c
)
)
=
>
c
_
=
>
return
Ok
(
false
)
}
Some
(
(
"
func
"
c
)
)
|
Some
(
(
"
value
"
c
)
)
|
Some
(
(
"
type
"
c
)
)
|
Some
(
(
"
component
"
c
)
)
|
Some
(
(
"
instance
"
c
)
)
=
>
c
_
=
>
return
Ok
(
false
)
}
;
Index
:
:
peek
(
cursor
)
}
fn
display
(
)
-
>
&
'
static
str
{
"
component
export
"
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
InlineExport
<
'
a
>
{
pub
names
:
Vec
<
ComponentExternName
<
'
a
>
>
}
impl
<
'
a
>
Parse
<
'
a
>
for
InlineExport
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
mut
names
=
Vec
:
:
new
(
)
;
while
parser
.
peek
:
:
<
Self
>
(
)
?
{
names
.
push
(
parser
.
parens
(
|
p
|
{
p
.
parse
:
:
<
kw
:
:
export
>
(
)
?
;
p
.
parse
(
)
}
)
?
)
;
}
Ok
(
InlineExport
{
names
}
)
}
}
impl
Peek
for
InlineExport
<
'
_
>
{
fn
peek
(
cursor
:
Cursor
<
'
_
>
)
-
>
Result
<
bool
>
{
let
cursor
=
match
cursor
.
lparen
(
)
?
{
Some
(
cursor
)
=
>
cursor
None
=
>
return
Ok
(
false
)
}
;
let
cursor
=
match
cursor
.
keyword
(
)
?
{
Some
(
(
"
export
"
cursor
)
)
=
>
cursor
_
=
>
return
Ok
(
false
)
}
;
if
let
Some
(
(
_
cursor
)
)
=
cursor
.
string
(
)
?
{
return
Ok
(
cursor
.
rparen
(
)
?
.
is_some
(
)
)
;
}
let
cursor
=
match
cursor
.
lparen
(
)
?
{
Some
(
cursor
)
=
>
cursor
None
=
>
return
Ok
(
false
)
}
;
let
cursor
=
match
cursor
.
keyword
(
)
?
{
Some
(
(
"
interface
"
cursor
)
)
=
>
cursor
_
=
>
return
Ok
(
false
)
}
;
let
cursor
=
match
cursor
.
string
(
)
?
{
Some
(
(
_
cursor
)
)
=
>
cursor
_
=
>
return
Ok
(
false
)
}
;
let
cursor
=
match
cursor
.
rparen
(
)
?
{
Some
(
cursor
)
=
>
cursor
_
=
>
return
Ok
(
false
)
}
;
Ok
(
cursor
.
rparen
(
)
?
.
is_some
(
)
)
}
fn
display
(
)
-
>
&
'
static
str
{
"
inline
export
"
}
}
