use
crate
:
:
component
:
:
*
;
use
crate
:
:
kw
;
use
crate
:
:
parser
:
:
{
Parse
Parser
Result
}
;
use
crate
:
:
token
:
:
{
Id
NameAnnotation
Span
}
;
#
[
derive
(
Debug
)
]
pub
enum
ComponentTypeDef
<
'
a
>
{
DefType
(
DefType
<
'
a
>
)
InterType
(
InterType
<
'
a
>
)
}
#
[
derive
(
Debug
)
]
pub
struct
ComponentExportType
<
'
a
>
{
pub
span
:
Span
pub
name
:
&
'
a
str
pub
item
:
ItemSig
<
'
a
>
}
impl
<
'
a
>
Parse
<
'
a
>
for
ComponentExportType
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
span
=
parser
.
parse
:
:
<
kw
:
:
export
>
(
)
?
.
0
;
let
name
=
parser
.
parse
(
)
?
;
let
item
=
parser
.
parens
(
|
p
|
p
.
parse
(
)
)
?
;
Ok
(
ComponentExportType
{
span
name
item
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
TypeField
<
'
a
>
{
pub
span
:
Span
pub
id
:
Option
<
Id
<
'
a
>
>
pub
name
:
Option
<
NameAnnotation
<
'
a
>
>
pub
def
:
ComponentTypeDef
<
'
a
>
}
impl
<
'
a
>
Parse
<
'
a
>
for
TypeField
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
span
=
parser
.
parse
:
:
<
kw
:
:
r
#
type
>
(
)
?
.
0
;
let
id
=
parser
.
parse
(
)
?
;
let
name
=
parser
.
parse
(
)
?
;
let
def
=
if
parser
.
peek2
:
:
<
DefTypeKind
>
(
)
{
ComponentTypeDef
:
:
DefType
(
parser
.
parens
(
|
p
|
p
.
parse
(
)
)
?
)
}
else
{
ComponentTypeDef
:
:
InterType
(
parser
.
parse
(
)
?
)
}
;
Ok
(
TypeField
{
span
id
name
def
}
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
ComponentTypeUse
<
'
a
T
>
{
Ref
(
ItemRef
<
'
a
kw
:
:
r
#
type
>
)
Inline
(
T
)
}
impl
<
'
a
T
:
Parse
<
'
a
>
>
Parse
<
'
a
>
for
ComponentTypeUse
<
'
a
T
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
if
parser
.
peek
:
:
<
ItemRef
<
'
a
kw
:
:
r
#
type
>
>
(
)
{
Ok
(
ComponentTypeUse
:
:
Ref
(
parser
.
parse
(
)
?
)
)
}
else
{
Ok
(
ComponentTypeUse
:
:
Inline
(
parser
.
parse
(
)
?
)
)
}
}
}
