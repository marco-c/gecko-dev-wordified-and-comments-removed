use
crate
:
:
ast
:
:
*
;
use
crate
:
:
resolve
:
:
gensym
;
use
crate
:
:
resolve
:
:
Ns
;
use
crate
:
:
Error
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
pub
fn
run
(
fields
:
&
mut
Vec
<
ModuleField
>
)
-
>
Result
<
(
)
Error
>
{
Expander
:
:
default
(
)
.
process
(
fields
None
)
}
#
[
derive
(
Default
)
]
struct
Expander
<
'
a
>
{
to_append
:
Vec
<
ModuleField
<
'
a
>
>
all_missing
:
HashSet
<
(
Id
<
'
a
>
Ns
)
>
defined_names
:
HashSet
<
(
Id
<
'
a
>
Ns
)
>
missing_names
:
HashMap
<
&
'
a
str
HashMap
<
(
&
'
a
str
Ns
)
Id
<
'
a
>
>
>
module_exports
:
HashMap
<
Id
<
'
a
>
ExportInfo
<
'
a
>
>
instance_exports
:
HashMap
<
Id
<
'
a
>
InstanceExports
<
'
a
>
>
instance_type_exports
:
HashMap
<
Id
<
'
a
>
Vec
<
ExportType
<
'
a
>
>
>
}
enum
InstanceExports
<
'
a
>
{
Inline
(
ExportInfo
<
'
a
>
)
Module
(
Id
<
'
a
>
)
}
impl
<
'
a
>
Expander
<
'
a
>
{
fn
process
(
&
mut
self
fields
:
&
mut
Vec
<
ModuleField
<
'
a
>
>
parent
:
Option
<
&
Expander
<
'
a
>
>
)
-
>
Result
<
(
)
Error
>
{
for
field
in
fields
.
iter_mut
(
)
{
self
.
record_missing_name
(
field
)
;
self
.
discover_module_names
(
field
)
;
}
if
let
Some
(
parent
)
=
parent
{
let
mut
names_to_add
=
self
.
all_missing
.
iter
(
)
.
filter
(
|
key
|
!
self
.
defined_names
.
contains
(
key
)
)
.
filter
(
|
key
|
parent
.
defined_names
.
contains
(
key
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
names_to_add
.
sort_by_key
(
|
e
|
e
.
0
.
name
(
)
)
;
for
key
in
names_to_add
{
fields
.
insert
(
0
ModuleField
:
:
Alias
(
Alias
{
id
:
Some
(
key
.
0
)
instance
:
None
name
:
None
span
:
key
.
0
.
span
(
)
kind
:
key
.
1
.
to_export_kind
(
Index
:
:
Id
(
key
.
0
)
)
}
)
)
;
self
.
defined_names
.
insert
(
*
key
)
;
match
key
.
1
{
Ns
:
:
Module
=
>
{
if
let
Some
(
info
)
=
parent
.
module_exports
.
get
(
&
key
.
0
)
{
self
.
module_exports
.
insert
(
key
.
0
info
.
clone
(
)
)
;
}
}
Ns
:
:
Type
=
>
{
if
let
Some
(
list
)
=
parent
.
instance_type_exports
.
get
(
&
key
.
0
)
{
self
.
instance_type_exports
.
insert
(
key
.
0
list
.
clone
(
)
)
;
}
}
Ns
:
:
Instance
=
>
{
let
info
=
match
parent
.
instance_exports
.
get
(
&
key
.
0
)
{
Some
(
InstanceExports
:
:
Inline
(
info
)
)
=
>
info
Some
(
InstanceExports
:
:
Module
(
module_id
)
)
=
>
{
&
parent
.
module_exports
[
module_id
]
}
None
=
>
continue
}
;
self
.
instance_exports
.
insert
(
key
.
0
InstanceExports
:
:
Inline
(
info
.
clone
(
)
)
)
;
}
_
=
>
{
}
}
}
}
self
.
iter_and_expand
(
fields
|
me
field
|
{
me
.
inject_aliases
(
field
)
;
Ok
(
true
)
}
)
?
;
assert
!
(
self
.
to_append
.
is_empty
(
)
)
;
self
.
iter_and_expand
(
fields
|
me
field
|
me
.
expand_export_all
(
field
)
)
?
;
assert
!
(
self
.
to_append
.
is_empty
(
)
)
;
for
field
in
fields
.
iter_mut
(
)
{
if
let
ModuleField
:
:
NestedModule
(
m
)
=
field
{
if
let
NestedModuleKind
:
:
Inline
{
fields
.
.
}
=
&
mut
m
.
kind
{
Expander
:
:
default
(
)
.
process
(
fields
Some
(
self
)
)
?
;
}
}
}
Ok
(
(
)
)
}
fn
discover_module_names
(
&
mut
self
field
:
&
ModuleField
<
'
a
>
)
{
let
(
id
info
)
=
match
field
{
ModuleField
:
:
Import
(
Import
{
item
:
ItemSig
{
id
:
Some
(
id
)
kind
:
ItemKind
:
:
Module
(
TypeUse
{
inline
:
Some
(
ty
)
.
.
}
)
.
.
}
.
.
}
)
=
>
(
id
ExportInfo
:
:
from_exports
(
&
ty
.
exports
)
)
ModuleField
:
:
NestedModule
(
NestedModule
{
id
:
Some
(
id
)
kind
:
NestedModuleKind
:
:
Inline
{
fields
.
.
}
.
.
}
)
=
>
{
let
mut
info
=
ExportInfo
:
:
default
(
)
;
for
field
in
fields
{
let
export
=
match
field
{
ModuleField
:
:
Export
(
e
)
=
>
e
_
=
>
continue
}
;
let
(
idx
ns
)
=
Ns
:
:
from_export
(
&
export
.
kind
)
;
if
let
Index
:
:
Id
(
id
)
=
idx
{
info
.
wat_name_to_export_idx
.
insert
(
(
id
.
name
(
)
ns
)
info
.
export_names
.
len
(
)
as
u32
)
;
}
info
.
export_names
.
push
(
(
export
.
name
ns
)
)
;
}
(
id
info
)
}
_
=
>
return
}
;
self
.
module_exports
.
insert
(
*
id
info
)
;
}
fn
iter_and_expand
(
&
mut
self
fields
:
&
mut
Vec
<
ModuleField
<
'
a
>
>
f
:
impl
Fn
(
&
mut
Self
&
mut
ModuleField
<
'
a
>
)
-
>
Result
<
bool
Error
>
)
-
>
Result
<
(
)
Error
>
{
assert
!
(
self
.
to_append
.
is_empty
(
)
)
;
let
mut
cur
=
0
;
while
cur
<
fields
.
len
(
)
{
let
keep
=
f
(
self
&
mut
fields
[
cur
]
)
?
;
if
keep
{
cur
+
=
1
;
}
else
{
fields
.
remove
(
cur
)
;
}
for
new
in
self
.
to_append
.
drain
(
.
.
)
{
fields
.
insert
(
cur
new
)
;
cur
+
=
1
;
}
}
Ok
(
(
)
)
}
fn
record_missing_name
(
&
mut
self
field
:
&
ModuleField
<
'
a
>
)
{
match
field
{
ModuleField
:
:
Type
(
t
)
=
>
{
self
.
record_defined
(
&
t
.
id
Ns
:
:
Type
)
;
match
&
t
.
def
{
TypeDef
:
:
Module
(
m
)
=
>
m
.
record_missing
(
self
)
TypeDef
:
:
Instance
(
i
)
=
>
{
i
.
record_missing
(
self
)
;
if
let
Some
(
name
)
=
t
.
id
{
self
.
instance_type_exports
.
insert
(
name
i
.
exports
.
clone
(
)
)
;
}
}
TypeDef
:
:
Func
(
f
)
=
>
f
.
record_missing
(
self
)
TypeDef
:
:
Array
(
_
)
|
TypeDef
:
:
Struct
(
_
)
=
>
{
}
}
}
ModuleField
:
:
Import
(
i
)
=
>
{
self
.
record_defined
(
&
i
.
item
.
id
Ns
:
:
from_item
(
&
i
.
item
)
)
;
self
.
record_item_sig
(
&
i
.
item
)
;
}
ModuleField
:
:
Func
(
f
)
=
>
{
self
.
record_defined
(
&
f
.
id
Ns
:
:
Func
)
;
self
.
record_type_use
(
&
f
.
ty
)
;
if
let
FuncKind
:
:
Inline
{
expression
.
.
}
=
&
f
.
kind
{
self
.
record_expr
(
expression
)
;
}
}
ModuleField
:
:
Memory
(
m
)
=
>
{
self
.
record_defined
(
&
m
.
id
Ns
:
:
Memory
)
;
}
ModuleField
:
:
Table
(
t
)
=
>
{
self
.
record_defined
(
&
t
.
id
Ns
:
:
Table
)
;
}
ModuleField
:
:
Global
(
g
)
=
>
{
self
.
record_defined
(
&
g
.
id
Ns
:
:
Global
)
;
if
let
GlobalKind
:
:
Inline
(
e
)
=
&
g
.
kind
{
self
.
record_expr
(
e
)
;
}
}
ModuleField
:
:
Event
(
e
)
=
>
{
self
.
record_defined
(
&
e
.
id
Ns
:
:
Event
)
;
match
&
e
.
ty
{
EventType
:
:
Exception
(
ty
)
=
>
self
.
record_type_use
(
ty
)
}
}
ModuleField
:
:
Instance
(
i
)
=
>
{
self
.
record_defined
(
&
i
.
id
Ns
:
:
Instance
)
;
if
let
InstanceKind
:
:
Inline
{
items
module
.
.
}
=
&
i
.
kind
{
self
.
record_missing
(
module
Ns
:
:
Module
)
;
for
item
in
items
{
let
(
idx
ns
)
=
Ns
:
:
from_export
(
item
)
;
self
.
record_missing
(
&
idx
ns
)
;
}
}
}
ModuleField
:
:
Start
(
id
)
=
>
self
.
record_missing
(
id
Ns
:
:
Func
)
ModuleField
:
:
Export
(
e
)
=
>
{
let
(
idx
ns
)
=
Ns
:
:
from_export
(
&
e
.
kind
)
;
self
.
record_missing
(
&
idx
ns
)
;
}
ModuleField
:
:
Elem
(
e
)
=
>
{
match
&
e
.
kind
{
ElemKind
:
:
Active
{
table
offset
}
=
>
{
self
.
record_missing
(
table
Ns
:
:
Table
)
;
self
.
record_expr
(
offset
)
;
}
ElemKind
:
:
Passive
{
.
.
}
|
ElemKind
:
:
Declared
{
.
.
}
=
>
{
}
}
match
&
e
.
payload
{
ElemPayload
:
:
Indices
(
elems
)
=
>
{
for
idx
in
elems
{
self
.
record_missing
(
idx
Ns
:
:
Func
)
;
}
}
ElemPayload
:
:
Exprs
{
exprs
.
.
}
=
>
{
for
funcref
in
exprs
{
if
let
Some
(
idx
)
=
funcref
{
self
.
record_missing
(
idx
Ns
:
:
Func
)
;
}
}
}
}
}
ModuleField
:
:
Data
(
d
)
=
>
{
if
let
DataKind
:
:
Active
{
memory
offset
}
=
&
d
.
kind
{
self
.
record_missing
(
memory
Ns
:
:
Memory
)
;
self
.
record_expr
(
offset
)
;
}
}
ModuleField
:
:
Alias
(
a
)
=
>
{
let
(
_idx
ns
)
=
Ns
:
:
from_export
(
&
a
.
kind
)
;
self
.
record_defined
(
&
a
.
id
ns
)
;
if
let
Some
(
instance
)
=
&
a
.
instance
{
self
.
record_missing
(
instance
Ns
:
:
Instance
)
;
}
}
ModuleField
:
:
NestedModule
(
m
)
=
>
{
self
.
record_defined
(
&
m
.
id
Ns
:
:
Module
)
;
}
ModuleField
:
:
ExportAll
(
_span
instance
)
=
>
{
self
.
record_missing
(
&
Index
:
:
Id
(
*
instance
)
Ns
:
:
Instance
)
;
}
ModuleField
:
:
Custom
(
_
)
=
>
{
}
}
}
fn
record_type_use
(
&
mut
self
item
:
&
TypeUse
<
'
a
impl
TypeReference
<
'
a
>
>
)
{
if
let
Some
(
idx
)
=
&
item
.
index
{
self
.
record_missing
(
idx
Ns
:
:
Type
)
;
}
if
let
Some
(
inline
)
=
&
item
.
inline
{
inline
.
record_missing
(
self
)
;
}
}
fn
record_item_sig
(
&
mut
self
sig
:
&
ItemSig
<
'
a
>
)
{
match
&
sig
.
kind
{
ItemKind
:
:
Func
(
f
)
|
ItemKind
:
:
Event
(
EventType
:
:
Exception
(
f
)
)
=
>
self
.
record_type_use
(
f
)
ItemKind
:
:
Module
(
m
)
=
>
self
.
record_type_use
(
m
)
ItemKind
:
:
Instance
(
i
)
=
>
self
.
record_type_use
(
i
)
ItemKind
:
:
Table
(
_
)
|
ItemKind
:
:
Memory
(
_
)
|
ItemKind
:
:
Global
(
_
)
=
>
{
}
}
}
fn
record_expr
(
&
mut
self
expr
:
&
Expression
<
'
a
>
)
{
use
Instruction
:
:
*
;
for
instr
in
expr
.
instrs
.
iter
(
)
{
match
instr
{
Block
(
t
)
|
Loop
(
t
)
|
If
(
t
)
|
Try
(
t
)
=
>
{
self
.
record_type_use
(
&
t
.
ty
)
;
}
FuncBind
(
b
)
=
>
{
self
.
record_type_use
(
&
b
.
ty
)
;
}
Call
(
f
)
|
ReturnCall
(
f
)
|
RefFunc
(
f
)
=
>
self
.
record_missing
(
f
Ns
:
:
Func
)
CallIndirect
(
f
)
|
ReturnCallIndirect
(
f
)
=
>
{
self
.
record_missing
(
&
f
.
table
Ns
:
:
Table
)
;
self
.
record_type_use
(
&
f
.
ty
)
;
}
GlobalGet
(
g
)
|
GlobalSet
(
g
)
=
>
self
.
record_missing
(
g
Ns
:
:
Global
)
TableFill
(
g
)
|
TableSize
(
g
)
|
TableGrow
(
g
)
|
TableGet
(
g
)
|
TableSet
(
g
)
=
>
{
self
.
record_missing
(
&
g
.
dst
Ns
:
:
Table
)
}
TableInit
(
t
)
=
>
self
.
record_missing
(
&
t
.
table
Ns
:
:
Table
)
TableCopy
(
t
)
=
>
{
self
.
record_missing
(
&
t
.
src
Ns
:
:
Table
)
;
self
.
record_missing
(
&
t
.
dst
Ns
:
:
Table
)
;
}
MemorySize
(
i
)
|
MemoryGrow
(
i
)
|
MemoryFill
(
i
)
=
>
{
self
.
record_missing
(
&
i
.
mem
Ns
:
:
Memory
)
;
}
MemoryInit
(
i
)
=
>
{
self
.
record_missing
(
&
i
.
mem
Ns
:
:
Memory
)
;
}
MemoryCopy
(
i
)
=
>
{
self
.
record_missing
(
&
i
.
src
Ns
:
:
Memory
)
;
self
.
record_missing
(
&
i
.
dst
Ns
:
:
Memory
)
;
}
I32Load
(
m
)
|
I64Load
(
m
)
|
F32Load
(
m
)
|
F64Load
(
m
)
|
I32Load8s
(
m
)
|
I32Load8u
(
m
)
|
I32Load16s
(
m
)
|
I32Load16u
(
m
)
|
I64Load8s
(
m
)
|
I64Load8u
(
m
)
|
I64Load16s
(
m
)
|
I64Load16u
(
m
)
|
I64Load32s
(
m
)
|
I64Load32u
(
m
)
|
I32Store
(
m
)
|
I64Store
(
m
)
|
F32Store
(
m
)
|
F64Store
(
m
)
|
I32Store8
(
m
)
|
I32Store16
(
m
)
|
I64Store8
(
m
)
|
I64Store16
(
m
)
|
I64Store32
(
m
)
|
I32AtomicLoad
(
m
)
|
I64AtomicLoad
(
m
)
|
I32AtomicLoad8u
(
m
)
|
I32AtomicLoad16u
(
m
)
|
I64AtomicLoad8u
(
m
)
|
I64AtomicLoad16u
(
m
)
|
I64AtomicLoad32u
(
m
)
|
I32AtomicStore
(
m
)
|
I64AtomicStore
(
m
)
|
I32AtomicStore8
(
m
)
|
I32AtomicStore16
(
m
)
|
I64AtomicStore8
(
m
)
|
I64AtomicStore16
(
m
)
|
I64AtomicStore32
(
m
)
|
I32AtomicRmwAdd
(
m
)
|
I64AtomicRmwAdd
(
m
)
|
I32AtomicRmw8AddU
(
m
)
|
I32AtomicRmw16AddU
(
m
)
|
I64AtomicRmw8AddU
(
m
)
|
I64AtomicRmw16AddU
(
m
)
|
I64AtomicRmw32AddU
(
m
)
|
I32AtomicRmwSub
(
m
)
|
I64AtomicRmwSub
(
m
)
|
I32AtomicRmw8SubU
(
m
)
|
I32AtomicRmw16SubU
(
m
)
|
I64AtomicRmw8SubU
(
m
)
|
I64AtomicRmw16SubU
(
m
)
|
I64AtomicRmw32SubU
(
m
)
|
I32AtomicRmwAnd
(
m
)
|
I64AtomicRmwAnd
(
m
)
|
I32AtomicRmw8AndU
(
m
)
|
I32AtomicRmw16AndU
(
m
)
|
I64AtomicRmw8AndU
(
m
)
|
I64AtomicRmw16AndU
(
m
)
|
I64AtomicRmw32AndU
(
m
)
|
I32AtomicRmwOr
(
m
)
|
I64AtomicRmwOr
(
m
)
|
I32AtomicRmw8OrU
(
m
)
|
I32AtomicRmw16OrU
(
m
)
|
I64AtomicRmw8OrU
(
m
)
|
I64AtomicRmw16OrU
(
m
)
|
I64AtomicRmw32OrU
(
m
)
|
I32AtomicRmwXor
(
m
)
|
I64AtomicRmwXor
(
m
)
|
I32AtomicRmw8XorU
(
m
)
|
I32AtomicRmw16XorU
(
m
)
|
I64AtomicRmw8XorU
(
m
)
|
I64AtomicRmw16XorU
(
m
)
|
I64AtomicRmw32XorU
(
m
)
|
I32AtomicRmwXchg
(
m
)
|
I64AtomicRmwXchg
(
m
)
|
I32AtomicRmw8XchgU
(
m
)
|
I32AtomicRmw16XchgU
(
m
)
|
I64AtomicRmw8XchgU
(
m
)
|
I64AtomicRmw16XchgU
(
m
)
|
I64AtomicRmw32XchgU
(
m
)
|
I32AtomicRmwCmpxchg
(
m
)
|
I64AtomicRmwCmpxchg
(
m
)
|
I32AtomicRmw8CmpxchgU
(
m
)
|
I32AtomicRmw16CmpxchgU
(
m
)
|
I64AtomicRmw8CmpxchgU
(
m
)
|
I64AtomicRmw16CmpxchgU
(
m
)
|
I64AtomicRmw32CmpxchgU
(
m
)
|
V128Load
(
m
)
|
V128Load8x8S
(
m
)
|
V128Load8x8U
(
m
)
|
V128Load16x4S
(
m
)
|
V128Load16x4U
(
m
)
|
V128Load32x2S
(
m
)
|
V128Load32x2U
(
m
)
|
V128Load8Splat
(
m
)
|
V128Load16Splat
(
m
)
|
V128Load32Splat
(
m
)
|
V128Load64Splat
(
m
)
|
V128Load32Zero
(
m
)
|
V128Load64Zero
(
m
)
|
V128Store
(
m
)
|
MemoryAtomicNotify
(
m
)
|
MemoryAtomicWait32
(
m
)
|
MemoryAtomicWait64
(
m
)
=
>
self
.
record_missing
(
&
m
.
memory
Ns
:
:
Memory
)
_
=
>
{
}
}
}
}
fn
record_defined
(
&
mut
self
name
:
&
Option
<
Id
<
'
a
>
>
kind
:
Ns
)
{
if
let
Some
(
id
)
=
name
{
self
.
defined_names
.
insert
(
(
*
id
kind
)
)
;
}
}
fn
record_missing
(
&
mut
self
name
:
&
Index
<
'
a
>
kind
:
Ns
)
{
let
id
=
match
name
{
Index
:
:
Num
(
.
.
)
=
>
return
Index
:
:
Id
(
id
)
=
>
id
}
;
self
.
all_missing
.
insert
(
(
*
id
kind
)
)
;
let
(
instance
field
)
=
match
self
.
split_name
(
id
)
{
Some
(
p
)
=
>
p
None
=
>
return
}
;
self
.
missing_names
.
entry
(
instance
)
.
or_insert
(
HashMap
:
:
new
(
)
)
.
insert
(
(
field
kind
)
*
id
)
;
}
fn
split_name
(
&
self
id
:
&
Id
<
'
a
>
)
-
>
Option
<
(
&
'
a
str
&
'
a
str
)
>
{
let
name
=
id
.
name
(
)
;
let
i
=
name
.
find
(
'
.
'
)
?
;
let
(
instance
field
)
=
(
&
name
[
.
.
i
]
&
name
[
i
+
1
.
.
]
)
;
if
field
.
starts_with
(
"
"
)
{
Some
(
(
instance
&
field
[
1
.
.
]
)
)
}
else
{
None
}
}
fn
inject_aliases
(
&
mut
self
field
:
&
ModuleField
<
'
a
>
)
{
let
defined_names
=
&
self
.
defined_names
;
let
(
id
span
export_info
)
=
match
field
{
ModuleField
:
:
Import
(
Import
{
item
:
ItemSig
{
id
:
Some
(
id
)
span
kind
:
ItemKind
:
:
Instance
(
TypeUse
{
inline
:
Some
(
ty
)
.
.
}
)
.
.
}
.
.
}
)
=
>
{
let
map
=
self
.
instance_exports
.
entry
(
*
id
)
.
or_insert_with
(
|
|
{
InstanceExports
:
:
Inline
(
ExportInfo
:
:
from_exports
(
&
ty
.
exports
)
)
}
)
;
(
id
span
match
map
{
InstanceExports
:
:
Inline
(
i
)
=
>
&
*
i
InstanceExports
:
:
Module
(
_
)
=
>
return
}
)
}
ModuleField
:
:
Instance
(
Instance
{
span
id
:
Some
(
id
)
kind
:
InstanceKind
:
:
Inline
{
module
:
Index
:
:
Id
(
module_id
)
.
.
}
.
.
}
)
=
>
match
self
.
module_exports
.
get
(
module_id
)
{
Some
(
map
)
=
>
{
self
.
instance_exports
.
insert
(
*
id
InstanceExports
:
:
Module
(
*
module_id
)
)
;
(
id
span
map
)
}
None
=
>
return
}
_
=
>
return
}
;
let
missing
=
match
self
.
missing_names
.
get
(
id
.
name
(
)
)
{
Some
(
missing
)
=
>
missing
None
=
>
return
}
;
let
mut
to_add
=
missing
.
iter
(
)
.
filter
(
|
(
(
_
ns
)
full_name
)
|
!
defined_names
.
contains
(
&
(
*
*
full_name
*
ns
)
)
)
.
filter_map
(
|
(
key
full_name
)
|
{
export_info
.
wat_name_to_export_idx
.
get
(
key
)
.
map
(
move
|
idx
|
(
&
key
.
1
idx
full_name
)
)
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
to_add
.
sort_by_key
(
|
e
|
e
.
1
)
;
for
(
ns
index
full_name
)
in
to_add
{
let
export_index
=
Index
:
:
Num
(
*
index
*
span
)
;
self
.
defined_names
.
insert
(
(
*
full_name
*
ns
)
)
;
self
.
to_append
.
push
(
ModuleField
:
:
Alias
(
Alias
{
id
:
Some
(
*
full_name
)
instance
:
Some
(
Index
:
:
Id
(
*
id
)
)
name
:
None
span
:
*
span
kind
:
ns
.
to_export_kind
(
export_index
)
}
)
)
;
}
}
fn
expand_export_all
(
&
mut
self
field
:
&
mut
ModuleField
<
'
a
>
)
-
>
Result
<
bool
Error
>
{
match
field
{
ModuleField
:
:
Type
(
t
)
=
>
{
match
&
mut
t
.
def
{
TypeDef
:
:
Module
(
m
)
=
>
m
.
expand_export_all
(
self
)
?
TypeDef
:
:
Instance
(
i
)
=
>
i
.
expand_export_all
(
self
)
?
TypeDef
:
:
Func
(
f
)
=
>
f
.
expand_export_all
(
self
)
?
TypeDef
:
:
Array
(
_
)
|
TypeDef
:
:
Struct
(
_
)
=
>
{
}
}
Ok
(
true
)
}
ModuleField
:
:
Import
(
t
)
=
>
{
self
.
expand_export_all_item_sig
(
&
mut
t
.
item
)
?
;
Ok
(
true
)
}
ModuleField
:
:
ExportAll
(
span
instance
)
=
>
{
let
info
=
match
self
.
instance_exports
.
get
(
instance
)
{
Some
(
InstanceExports
:
:
Inline
(
i
)
)
=
>
i
Some
(
InstanceExports
:
:
Module
(
i
)
)
=
>
&
self
.
module_exports
[
i
]
None
=
>
{
return
Err
(
Error
:
:
new
(
instance
.
span
(
)
format
!
(
"
failed
to
find
instance
to
inline
exports
"
)
)
)
}
}
;
for
(
i
(
name
ns
)
)
in
info
.
export_names
.
iter
(
)
.
enumerate
(
)
{
let
index
=
Index
:
:
Num
(
i
as
u32
*
span
)
;
let
alias_id
=
gensym
:
:
gen
(
*
span
)
;
self
.
to_append
.
push
(
ModuleField
:
:
Alias
(
Alias
{
id
:
Some
(
alias_id
)
instance
:
Some
(
Index
:
:
Id
(
*
instance
)
)
name
:
None
span
:
*
span
kind
:
ns
.
to_export_kind
(
index
)
}
)
)
;
self
.
to_append
.
push
(
ModuleField
:
:
Export
(
Export
{
span
:
*
span
name
kind
:
ns
.
to_export_kind
(
Index
:
:
Id
(
alias_id
)
)
}
)
)
;
}
Ok
(
false
)
}
_
=
>
Ok
(
true
)
}
}
fn
expand_export_all_item_sig
(
&
mut
self
item
:
&
mut
ItemSig
<
'
a
>
)
-
>
Result
<
(
)
Error
>
{
match
&
mut
item
.
kind
{
ItemKind
:
:
Module
(
t
)
=
>
self
.
expand_export_all_type_use
(
t
)
ItemKind
:
:
Instance
(
t
)
=
>
self
.
expand_export_all_type_use
(
t
)
ItemKind
:
:
Func
(
t
)
|
ItemKind
:
:
Event
(
EventType
:
:
Exception
(
t
)
)
=
>
{
self
.
expand_export_all_type_use
(
t
)
}
ItemKind
:
:
Memory
(
_
)
|
ItemKind
:
:
Table
(
_
)
|
ItemKind
:
:
Global
(
_
)
=
>
Ok
(
(
)
)
}
}
fn
expand_export_all_type_use
(
&
mut
self
item
:
&
mut
TypeUse
<
'
a
impl
TypeReference
<
'
a
>
>
)
-
>
Result
<
(
)
Error
>
{
if
let
Some
(
t
)
=
&
mut
item
.
inline
{
t
.
expand_export_all
(
self
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Default
Clone
)
]
struct
ExportInfo
<
'
a
>
{
wat_name_to_export_idx
:
HashMap
<
(
&
'
a
str
Ns
)
u32
>
export_names
:
Vec
<
(
&
'
a
str
Ns
)
>
}
impl
<
'
a
>
ExportInfo
<
'
a
>
{
fn
from_exports
(
exports
:
&
[
ExportType
<
'
a
>
]
)
-
>
ExportInfo
<
'
a
>
{
let
mut
wat_name_to_export_idx
=
HashMap
:
:
new
(
)
;
let
mut
export_names
=
Vec
:
:
new
(
)
;
for
(
i
export
)
in
exports
.
iter
(
)
.
enumerate
(
)
{
let
ns
=
Ns
:
:
from_item
(
&
export
.
item
)
;
if
let
Some
(
id
)
=
export
.
item
.
id
{
wat_name_to_export_idx
.
insert
(
(
id
.
name
(
)
ns
)
i
as
u32
)
;
}
export_names
.
push
(
(
export
.
name
ns
)
)
;
}
ExportInfo
{
wat_name_to_export_idx
export_names
}
}
}
trait
TypeReference
<
'
a
>
{
fn
record_missing
(
&
self
cx
:
&
mut
Expander
<
'
a
>
)
;
fn
expand_export_all
(
&
mut
self
cx
:
&
mut
Expander
<
'
a
>
)
-
>
Result
<
(
)
Error
>
;
}
impl
<
'
a
>
TypeReference
<
'
a
>
for
FunctionType
<
'
a
>
{
fn
record_missing
(
&
self
_cx
:
&
mut
Expander
<
'
a
>
)
{
}
fn
expand_export_all
(
&
mut
self
_cx
:
&
mut
Expander
<
'
a
>
)
-
>
Result
<
(
)
Error
>
{
Ok
(
(
)
)
}
}
impl
<
'
a
>
TypeReference
<
'
a
>
for
ModuleType
<
'
a
>
{
fn
record_missing
(
&
self
cx
:
&
mut
Expander
<
'
a
>
)
{
for
i
in
self
.
imports
.
iter
(
)
{
cx
.
record_item_sig
(
&
i
.
item
)
;
}
for
e
in
self
.
exports
.
iter
(
)
{
cx
.
record_item_sig
(
&
e
.
item
)
;
}
for
(
_
name
)
in
self
.
instance_exports
.
iter
(
)
{
cx
.
record_missing
(
&
Index
:
:
Id
(
*
name
)
Ns
:
:
Type
)
;
}
}
fn
expand_export_all
(
&
mut
self
cx
:
&
mut
Expander
<
'
a
>
)
-
>
Result
<
(
)
Error
>
{
for
(
_span
instance_ty_name
)
in
self
.
instance_exports
.
drain
(
.
.
)
{
match
cx
.
instance_type_exports
.
get
(
&
instance_ty_name
)
{
Some
(
exports
)
=
>
self
.
exports
.
extend
(
exports
.
iter
(
)
.
cloned
(
)
)
None
=
>
{
return
Err
(
Error
:
:
new
(
instance_ty_name
.
span
(
)
format
!
(
"
failed
to
find
instance
type
to
inline
exports
from
"
)
)
)
}
}
}
for
i
in
self
.
imports
.
iter_mut
(
)
{
cx
.
expand_export_all_item_sig
(
&
mut
i
.
item
)
?
;
}
for
e
in
self
.
exports
.
iter_mut
(
)
{
cx
.
expand_export_all_item_sig
(
&
mut
e
.
item
)
?
;
}
Ok
(
(
)
)
}
}
impl
<
'
a
>
TypeReference
<
'
a
>
for
InstanceType
<
'
a
>
{
fn
record_missing
(
&
self
cx
:
&
mut
Expander
<
'
a
>
)
{
for
e
in
self
.
exports
.
iter
(
)
{
cx
.
record_item_sig
(
&
e
.
item
)
;
}
}
fn
expand_export_all
(
&
mut
self
cx
:
&
mut
Expander
<
'
a
>
)
-
>
Result
<
(
)
Error
>
{
for
e
in
self
.
exports
.
iter_mut
(
)
{
cx
.
expand_export_all_item_sig
(
&
mut
e
.
item
)
?
;
}
Ok
(
(
)
)
}
}
