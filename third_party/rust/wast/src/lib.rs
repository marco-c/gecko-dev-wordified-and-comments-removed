#
!
[
deny
(
missing_docs
rustdoc
:
:
broken_intra_doc_links
)
]
#
[
macro_export
]
macro_rules
!
custom_keyword
{
(
name
:
ident
)
=
>
{
crate
:
:
custom_keyword
!
(
name
=
stringify
!
(
name
)
)
;
}
;
(
name
:
ident
=
kw
:
expr
)
=
>
{
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
name
(
pub
crate
:
:
token
:
:
Span
)
;
impl
<
'
a
>
crate
:
:
parser
:
:
Parse
<
'
a
>
for
name
{
fn
parse
(
parser
:
crate
:
:
parser
:
:
Parser
<
'
a
>
)
-
>
crate
:
:
parser
:
:
Result
<
Self
>
{
parser
.
step
(
|
c
|
{
if
let
Some
(
(
kw
rest
)
)
=
c
.
keyword
(
)
{
if
kw
=
=
kw
{
return
Ok
(
(
name
(
c
.
cur_span
(
)
)
rest
)
)
;
}
}
Err
(
c
.
error
(
concat
!
(
"
expected
keyword
"
kw
"
"
)
)
)
}
)
}
}
impl
crate
:
:
parser
:
:
Peek
for
name
{
fn
peek
(
cursor
:
crate
:
:
parser
:
:
Cursor
<
'
_
>
)
-
>
bool
{
if
let
Some
(
(
kw
_rest
)
)
=
cursor
.
keyword
(
)
{
kw
=
=
kw
}
else
{
false
}
}
fn
display
(
)
-
>
&
'
static
str
{
concat
!
(
"
"
kw
"
"
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
custom_reserved
{
(
name
:
ident
)
=
>
{
crate
:
:
custom_reserved
!
(
name
=
stringify
!
(
name
)
)
;
}
;
(
name
:
ident
=
rsv
:
expr
)
=
>
{
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
struct
name
(
pub
crate
:
:
token
:
:
Span
)
;
impl
<
'
a
>
crate
:
:
parser
:
:
Parse
<
'
a
>
for
name
{
fn
parse
(
parser
:
crate
:
:
parser
:
:
Parser
<
'
a
>
)
-
>
crate
:
:
parser
:
:
Result
<
Self
>
{
parser
.
step
(
|
c
|
{
if
let
Some
(
(
rsv
rest
)
)
=
c
.
reserved
(
)
{
if
rsv
=
=
rsv
{
return
Ok
(
(
name
(
c
.
cur_span
(
)
)
rest
)
)
;
}
}
Err
(
c
.
error
(
concat
!
(
"
expected
reserved
symbol
"
rsv
"
"
)
)
)
}
)
}
}
impl
crate
:
:
parser
:
:
Peek
for
name
{
fn
peek
(
cursor
:
crate
:
:
parser
:
:
Cursor
<
'
_
>
)
-
>
bool
{
if
let
Some
(
(
rsv
_rest
)
)
=
cursor
.
reserved
(
)
{
rsv
=
=
rsv
}
else
{
false
}
}
fn
display
(
)
-
>
&
'
static
str
{
concat
!
(
"
"
rsv
"
"
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
annotation
{
(
name
:
ident
)
=
>
{
crate
:
:
annotation
!
(
name
=
stringify
!
(
name
)
)
;
}
;
(
name
:
ident
=
annotation
:
expr
)
=
>
{
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
struct
name
(
pub
crate
:
:
token
:
:
Span
)
;
impl
<
'
a
>
crate
:
:
parser
:
:
Parse
<
'
a
>
for
name
{
fn
parse
(
parser
:
crate
:
:
parser
:
:
Parser
<
'
a
>
)
-
>
crate
:
:
parser
:
:
Result
<
Self
>
{
parser
.
step
(
|
c
|
{
if
let
Some
(
(
a
rest
)
)
=
c
.
annotation
(
)
{
if
a
=
=
annotation
{
return
Ok
(
(
name
(
c
.
cur_span
(
)
)
rest
)
)
;
}
}
Err
(
c
.
error
(
concat
!
(
"
expected
annotation
"
annotation
"
"
)
)
)
}
)
}
}
impl
crate
:
:
parser
:
:
Peek
for
name
{
fn
peek
(
cursor
:
crate
:
:
parser
:
:
Cursor
<
'
_
>
)
-
>
bool
{
if
let
Some
(
(
a
_rest
)
)
=
cursor
.
annotation
(
)
{
a
=
=
annotation
}
else
{
false
}
}
fn
display
(
)
-
>
&
'
static
str
{
concat
!
(
"
"
annotation
"
"
)
}
}
}
;
}
pub
mod
lexer
;
pub
mod
parser
;
pub
mod
token
;
mod
encode
;
mod
error
;
mod
gensym
;
mod
names
;
pub
use
self
:
:
error
:
:
*
;
macro_rules
!
id
{
(
(
t
:
tt
)
*
)
=
>
(
(
t
)
*
)
}
#
[
cfg
(
feature
=
"
wasm
-
module
"
)
]
id
!
{
mod
wast
;
mod
wat
;
pub
use
self
:
:
wast
:
:
*
;
pub
use
self
:
:
wat
:
:
*
;
/
/
Support
for
core
wasm
parsing
pub
mod
core
;
/
/
Support
for
component
model
parsing
pub
mod
component
;
}
pub
mod
kw
{
custom_keyword
!
(
after
)
;
custom_keyword
!
(
alias
)
;
custom_keyword
!
(
any
)
;
custom_keyword
!
(
anyfunc
)
;
custom_keyword
!
(
anyref
)
;
custom_keyword
!
(
arg
)
;
custom_keyword
!
(
array
)
;
custom_keyword
!
(
arrayref
)
;
custom_keyword
!
(
assert_exception
)
;
custom_keyword
!
(
assert_exhaustion
)
;
custom_keyword
!
(
assert_invalid
)
;
custom_keyword
!
(
assert_malformed
)
;
custom_keyword
!
(
assert_return
)
;
custom_keyword
!
(
assert_trap
)
;
custom_keyword
!
(
assert_unlinkable
)
;
custom_keyword
!
(
before
)
;
custom_keyword
!
(
binary
)
;
custom_keyword
!
(
block
)
;
custom_keyword
!
(
catch
)
;
custom_keyword
!
(
catch_all
)
;
custom_keyword
!
(
code
)
;
custom_keyword
!
(
component
)
;
custom_keyword
!
(
data
)
;
custom_keyword
!
(
dataref
)
;
custom_keyword
!
(
declare
)
;
custom_keyword
!
(
delegate
)
;
custom_keyword
!
(
r
#
do
=
"
do
"
)
;
custom_keyword
!
(
elem
)
;
custom_keyword
!
(
end
)
;
custom_keyword
!
(
tag
)
;
custom_keyword
!
(
export
)
;
custom_keyword
!
(
r
#
extern
=
"
extern
"
)
;
custom_keyword
!
(
externref
)
;
custom_keyword
!
(
eq
)
;
custom_keyword
!
(
eqref
)
;
custom_keyword
!
(
f32
)
;
custom_keyword
!
(
f32x4
)
;
custom_keyword
!
(
f64
)
;
custom_keyword
!
(
f64x2
)
;
custom_keyword
!
(
field
)
;
custom_keyword
!
(
first
)
;
custom_keyword
!
(
func
)
;
custom_keyword
!
(
funcref
)
;
custom_keyword
!
(
get
)
;
custom_keyword
!
(
global
)
;
custom_keyword
!
(
i16
)
;
custom_keyword
!
(
i16x8
)
;
custom_keyword
!
(
i31
)
;
custom_keyword
!
(
i31ref
)
;
custom_keyword
!
(
i32
)
;
custom_keyword
!
(
i32x4
)
;
custom_keyword
!
(
i64
)
;
custom_keyword
!
(
i64x2
)
;
custom_keyword
!
(
i8
)
;
custom_keyword
!
(
i8x16
)
;
custom_keyword
!
(
import
)
;
custom_keyword
!
(
instance
)
;
custom_keyword
!
(
instantiate
)
;
custom_keyword
!
(
invoke
)
;
custom_keyword
!
(
item
)
;
custom_keyword
!
(
last
)
;
custom_keyword
!
(
local
)
;
custom_keyword
!
(
memory
)
;
custom_keyword
!
(
module
)
;
custom_keyword
!
(
modulecode
)
;
custom_keyword
!
(
nan_arithmetic
=
"
nan
:
arithmetic
"
)
;
custom_keyword
!
(
nan_canonical
=
"
nan
:
canonical
"
)
;
custom_keyword
!
(
null
)
;
custom_keyword
!
(
nullref
)
;
custom_keyword
!
(
offset
)
;
custom_keyword
!
(
outer
)
;
custom_keyword
!
(
param
)
;
custom_keyword
!
(
parent
)
;
custom_keyword
!
(
passive
)
;
custom_keyword
!
(
quote
)
;
custom_keyword
!
(
r
#
else
=
"
else
"
)
;
custom_keyword
!
(
r
#
if
=
"
if
"
)
;
custom_keyword
!
(
r
#
loop
=
"
loop
"
)
;
custom_keyword
!
(
r
#
mut
=
"
mut
"
)
;
custom_keyword
!
(
r
#
type
=
"
type
"
)
;
custom_keyword
!
(
r
#
ref
=
"
ref
"
)
;
custom_keyword
!
(
ref_func
=
"
ref
.
func
"
)
;
custom_keyword
!
(
ref_null
=
"
ref
.
null
"
)
;
custom_keyword
!
(
register
)
;
custom_keyword
!
(
rec
)
;
custom_keyword
!
(
result
)
;
custom_keyword
!
(
shared
)
;
custom_keyword
!
(
start
)
;
custom_keyword
!
(
r
#
struct
=
"
struct
"
)
;
custom_keyword
!
(
sub
)
;
custom_keyword
!
(
table
)
;
custom_keyword
!
(
then
)
;
custom_keyword
!
(
r
#
try
=
"
try
"
)
;
custom_keyword
!
(
v128
)
;
custom_keyword
!
(
value
)
;
custom_keyword
!
(
s8
)
;
custom_keyword
!
(
s16
)
;
custom_keyword
!
(
s32
)
;
custom_keyword
!
(
s64
)
;
custom_keyword
!
(
u8
)
;
custom_keyword
!
(
u16
)
;
custom_keyword
!
(
u32
)
;
custom_keyword
!
(
u64
)
;
custom_keyword
!
(
char
)
;
custom_keyword
!
(
case
)
;
custom_keyword
!
(
refines
)
;
custom_keyword
!
(
record
)
;
custom_keyword
!
(
string
)
;
custom_keyword
!
(
bool_
=
"
bool
"
)
;
custom_keyword
!
(
float32
)
;
custom_keyword
!
(
float64
)
;
custom_keyword
!
(
variant
)
;
custom_keyword
!
(
unit
)
;
custom_keyword
!
(
flags
)
;
custom_keyword
!
(
option
)
;
custom_keyword
!
(
tuple
)
;
custom_keyword
!
(
list
)
;
custom_keyword
!
(
union
)
;
custom_keyword
!
(
expected
)
;
custom_keyword
!
(
canon
)
;
custom_keyword
!
(
lift
)
;
custom_keyword
!
(
lower
)
;
custom_keyword
!
(
enum_
=
"
enum
"
)
;
custom_keyword
!
(
string_utf8
=
"
string
-
encoding
=
utf8
"
)
;
custom_keyword
!
(
string_utf16
=
"
string
-
encoding
=
utf16
"
)
;
custom_keyword
!
(
string_latin1_utf16
=
"
string
-
encoding
=
latin1
+
utf16
"
)
;
custom_keyword
!
(
realloc
)
;
custom_keyword
!
(
post_return
=
"
post
-
return
"
)
;
custom_keyword
!
(
with
)
;
custom_keyword
!
(
core
)
;
custom_keyword
!
(
true_
=
"
true
"
)
;
custom_keyword
!
(
false_
=
"
false
"
)
;
}
pub
mod
annotation
{
annotation
!
(
custom
)
;
annotation
!
(
name
)
;
}
