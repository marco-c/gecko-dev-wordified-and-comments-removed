#
!
[
deny
(
missing_docs
rustdoc
:
:
broken_intra_doc_links
)
]
#
!
[
cfg_attr
(
docsrs
feature
(
doc_auto_cfg
)
)
]
#
[
macro_export
]
macro_rules
!
custom_keyword
{
(
name
:
ident
)
=
>
{
crate
:
:
custom_keyword
!
(
name
=
stringify
!
(
name
)
)
;
}
;
(
name
:
ident
=
kw
:
expr
)
=
>
{
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
name
(
#
[
allow
(
dead_code
)
]
pub
crate
:
:
token
:
:
Span
)
;
impl
<
'
a
>
crate
:
:
parser
:
:
Parse
<
'
a
>
for
name
{
fn
parse
(
parser
:
crate
:
:
parser
:
:
Parser
<
'
a
>
)
-
>
crate
:
:
parser
:
:
Result
<
Self
>
{
parser
.
step
(
|
c
|
{
if
let
Some
(
(
kw
rest
)
)
=
c
.
keyword
(
)
?
{
if
kw
=
=
kw
{
return
Ok
(
(
name
(
c
.
cur_span
(
)
)
rest
)
)
;
}
}
Err
(
c
.
error
(
concat
!
(
"
expected
keyword
"
kw
"
"
)
)
)
}
)
}
}
impl
crate
:
:
parser
:
:
Peek
for
name
{
fn
peek
(
cursor
:
crate
:
:
parser
:
:
Cursor
<
'
_
>
)
-
>
crate
:
:
parser
:
:
Result
<
bool
>
{
Ok
(
if
let
Some
(
(
kw
_rest
)
)
=
cursor
.
keyword
(
)
?
{
kw
=
=
kw
}
else
{
false
}
)
}
fn
display
(
)
-
>
&
'
static
str
{
concat
!
(
"
"
kw
"
"
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
custom_reserved
{
(
name
:
ident
)
=
>
{
crate
:
:
custom_reserved
!
(
name
=
stringify
!
(
name
)
)
;
}
;
(
name
:
ident
=
rsv
:
expr
)
=
>
{
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
struct
name
(
pub
crate
:
:
token
:
:
Span
)
;
impl
<
'
a
>
crate
:
:
parser
:
:
Parse
<
'
a
>
for
name
{
fn
parse
(
parser
:
crate
:
:
parser
:
:
Parser
<
'
a
>
)
-
>
crate
:
:
parser
:
:
Result
<
Self
>
{
parser
.
step
(
|
c
|
{
if
let
Some
(
(
rsv
rest
)
)
=
c
.
reserved
(
)
?
{
if
rsv
=
=
rsv
{
return
Ok
(
(
name
(
c
.
cur_span
(
)
)
rest
)
)
;
}
}
Err
(
c
.
error
(
concat
!
(
"
expected
reserved
symbol
"
rsv
"
"
)
)
)
}
)
}
}
impl
crate
:
:
parser
:
:
Peek
for
name
{
fn
peek
(
cursor
:
crate
:
:
parser
:
:
Cursor
<
'
_
>
)
-
>
Result
<
bool
>
{
if
let
Some
(
(
rsv
_rest
)
)
=
cursor
.
reserved
(
)
?
{
Ok
(
rsv
=
=
rsv
)
}
else
{
Ok
(
false
)
}
}
fn
display
(
)
-
>
&
'
static
str
{
concat
!
(
"
"
rsv
"
"
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
annotation
{
(
name
:
ident
)
=
>
{
crate
:
:
annotation
!
(
name
=
stringify
!
(
name
)
)
;
}
;
(
name
:
ident
=
annotation
:
expr
)
=
>
{
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
struct
name
(
pub
crate
:
:
token
:
:
Span
)
;
impl
<
'
a
>
crate
:
:
parser
:
:
Parse
<
'
a
>
for
name
{
fn
parse
(
parser
:
crate
:
:
parser
:
:
Parser
<
'
a
>
)
-
>
crate
:
:
parser
:
:
Result
<
Self
>
{
parser
.
step
(
|
c
|
{
if
let
Some
(
(
a
rest
)
)
=
c
.
annotation
(
)
?
{
if
a
=
=
annotation
{
return
Ok
(
(
name
(
c
.
cur_span
(
)
)
rest
)
)
;
}
}
Err
(
c
.
error
(
concat
!
(
"
expected
annotation
"
annotation
"
"
)
)
)
}
)
}
}
impl
crate
:
:
parser
:
:
Peek
for
name
{
fn
peek
(
cursor
:
crate
:
:
parser
:
:
Cursor
<
'
_
>
)
-
>
crate
:
:
parser
:
:
Result
<
bool
>
{
Ok
(
if
let
Some
(
(
a
_rest
)
)
=
cursor
.
annotation
(
)
?
{
a
=
=
annotation
}
else
{
false
}
)
}
fn
display
(
)
-
>
&
'
static
str
{
concat
!
(
"
"
annotation
"
"
)
}
}
}
;
}
pub
mod
lexer
;
pub
mod
parser
;
pub
mod
token
;
#
[
cfg
(
feature
=
"
wasm
-
module
"
)
]
mod
encode
;
mod
error
;
#
[
cfg
(
feature
=
"
wasm
-
module
"
)
]
mod
gensym
;
#
[
cfg
(
feature
=
"
wasm
-
module
"
)
]
mod
names
;
pub
use
self
:
:
error
:
:
*
;
#
[
cfg
(
feature
=
"
wasm
-
module
"
)
]
macro_rules
!
id
{
(
(
t
:
tt
)
*
)
=
>
(
(
t
)
*
)
}
#
[
cfg
(
feature
=
"
wasm
-
module
"
)
]
id
!
{
mod
wast
;
mod
wat
;
pub
use
self
:
:
wast
:
:
*
;
pub
use
self
:
:
wat
:
:
*
;
/
/
Support
for
core
wasm
parsing
pub
mod
core
;
/
/
Support
for
component
model
parsing
#
[
cfg
(
feature
=
"
component
-
model
"
)
]
pub
mod
component
;
#
[
cfg
(
not
(
feature
=
"
component
-
model
"
)
)
]
#
[
path
=
"
component_disabled
.
rs
"
]
pub
mod
component
;
}
pub
mod
kw
{
custom_keyword
!
(
after
)
;
custom_keyword
!
(
alias
)
;
custom_keyword
!
(
any
)
;
custom_keyword
!
(
anyref
)
;
custom_keyword
!
(
arg
)
;
custom_keyword
!
(
array
)
;
custom_keyword
!
(
arrayref
)
;
custom_keyword
!
(
assert_exception
)
;
custom_keyword
!
(
assert_exhaustion
)
;
custom_keyword
!
(
assert_invalid
)
;
custom_keyword
!
(
assert_malformed
)
;
custom_keyword
!
(
assert_return
)
;
custom_keyword
!
(
assert_trap
)
;
custom_keyword
!
(
assert_unlinkable
)
;
custom_keyword
!
(
assert_suspension
)
;
custom_keyword
!
(
before
)
;
custom_keyword
!
(
binary
)
;
custom_keyword
!
(
block
)
;
custom_keyword
!
(
borrow
)
;
custom_keyword
!
(
catch
)
;
custom_keyword
!
(
catch_ref
)
;
custom_keyword
!
(
catch_all
)
;
custom_keyword
!
(
catch_all_ref
)
;
custom_keyword
!
(
code
)
;
custom_keyword
!
(
cont
)
;
custom_keyword
!
(
contref
)
;
custom_keyword
!
(
component
)
;
custom_keyword
!
(
data
)
;
custom_keyword
!
(
declare
)
;
custom_keyword
!
(
delegate
)
;
custom_keyword
!
(
r
#
do
=
"
do
"
)
;
custom_keyword
!
(
dtor
)
;
custom_keyword
!
(
elem
)
;
custom_keyword
!
(
end
)
;
custom_keyword
!
(
tag
)
;
custom_keyword
!
(
exn
)
;
custom_keyword
!
(
exnref
)
;
custom_keyword
!
(
export
)
;
custom_keyword
!
(
r
#
extern
=
"
extern
"
)
;
custom_keyword
!
(
externref
)
;
custom_keyword
!
(
eq
)
;
custom_keyword
!
(
eqref
)
;
custom_keyword
!
(
f32
)
;
custom_keyword
!
(
f32x4
)
;
custom_keyword
!
(
f64
)
;
custom_keyword
!
(
f64x2
)
;
custom_keyword
!
(
field
)
;
custom_keyword
!
(
first
)
;
custom_keyword
!
(
func
)
;
custom_keyword
!
(
funcref
)
;
custom_keyword
!
(
get
)
;
custom_keyword
!
(
global
)
;
custom_keyword
!
(
i16
)
;
custom_keyword
!
(
i16x8
)
;
custom_keyword
!
(
i31
)
;
custom_keyword
!
(
i31ref
)
;
custom_keyword
!
(
i32
)
;
custom_keyword
!
(
i32x4
)
;
custom_keyword
!
(
i64
)
;
custom_keyword
!
(
i64x2
)
;
custom_keyword
!
(
i8
)
;
custom_keyword
!
(
i8x16
)
;
custom_keyword
!
(
import
)
;
custom_keyword
!
(
instance
)
;
custom_keyword
!
(
instantiate
)
;
custom_keyword
!
(
interface
)
;
custom_keyword
!
(
invoke
)
;
custom_keyword
!
(
item
)
;
custom_keyword
!
(
last
)
;
custom_keyword
!
(
local
)
;
custom_keyword
!
(
memory
)
;
custom_keyword
!
(
module
)
;
custom_keyword
!
(
modulecode
)
;
custom_keyword
!
(
nan_arithmetic
=
"
nan
:
arithmetic
"
)
;
custom_keyword
!
(
nan_canonical
=
"
nan
:
canonical
"
)
;
custom_keyword
!
(
nocont
)
;
custom_keyword
!
(
nofunc
)
;
custom_keyword
!
(
noextern
)
;
custom_keyword
!
(
noexn
)
;
custom_keyword
!
(
none
)
;
custom_keyword
!
(
null
)
;
custom_keyword
!
(
nullcontref
)
;
custom_keyword
!
(
nullfuncref
)
;
custom_keyword
!
(
nullexternref
)
;
custom_keyword
!
(
nullexnref
)
;
custom_keyword
!
(
nullref
)
;
custom_keyword
!
(
offset
)
;
custom_keyword
!
(
on
)
;
custom_keyword
!
(
outer
)
;
custom_keyword
!
(
own
)
;
custom_keyword
!
(
pagesize
)
;
custom_keyword
!
(
param
)
;
custom_keyword
!
(
parent
)
;
custom_keyword
!
(
passive
)
;
custom_keyword
!
(
quote
)
;
custom_keyword
!
(
r
#
else
=
"
else
"
)
;
custom_keyword
!
(
r
#
if
=
"
if
"
)
;
custom_keyword
!
(
r
#
loop
=
"
loop
"
)
;
custom_keyword
!
(
r
#
mut
=
"
mut
"
)
;
custom_keyword
!
(
r
#
type
=
"
type
"
)
;
custom_keyword
!
(
r
#
ref
=
"
ref
"
)
;
custom_keyword
!
(
ref_func
=
"
ref
.
func
"
)
;
custom_keyword
!
(
ref_null
=
"
ref
.
null
"
)
;
custom_keyword
!
(
register
)
;
custom_keyword
!
(
rec
)
;
custom_keyword
!
(
acq_rel
)
;
custom_keyword
!
(
rep
)
;
custom_keyword
!
(
resource
)
;
custom_keyword
!
(
resource_new
=
"
resource
.
new
"
)
;
custom_keyword
!
(
resource_drop
=
"
resource
.
drop
"
)
;
custom_keyword
!
(
resource_rep
=
"
resource
.
rep
"
)
;
custom_keyword
!
(
result
)
;
custom_keyword
!
(
seq_cst
)
;
custom_keyword
!
(
shared
)
;
custom_keyword
!
(
start
)
;
custom_keyword
!
(
sub
)
;
custom_keyword
!
(
switch
)
;
custom_keyword
!
(
r
#
final
=
"
final
"
)
;
custom_keyword
!
(
table
)
;
custom_keyword
!
(
then
)
;
custom_keyword
!
(
r
#
try
=
"
try
"
)
;
custom_keyword
!
(
v128
)
;
custom_keyword
!
(
value
)
;
custom_keyword
!
(
s8
)
;
custom_keyword
!
(
s16
)
;
custom_keyword
!
(
s32
)
;
custom_keyword
!
(
s64
)
;
custom_keyword
!
(
u8
)
;
custom_keyword
!
(
u16
)
;
custom_keyword
!
(
u32
)
;
custom_keyword
!
(
u64
)
;
custom_keyword
!
(
char
)
;
custom_keyword
!
(
case
)
;
custom_keyword
!
(
refines
)
;
custom_keyword
!
(
record
)
;
custom_keyword
!
(
string
)
;
custom_keyword
!
(
bool_
=
"
bool
"
)
;
custom_keyword
!
(
float32
)
;
custom_keyword
!
(
float64
)
;
custom_keyword
!
(
variant
)
;
custom_keyword
!
(
flags
)
;
custom_keyword
!
(
option
)
;
custom_keyword
!
(
tuple
)
;
custom_keyword
!
(
list
)
;
custom_keyword
!
(
error
)
;
custom_keyword
!
(
canon
)
;
custom_keyword
!
(
lift
)
;
custom_keyword
!
(
lower
)
;
custom_keyword
!
(
enum_
=
"
enum
"
)
;
custom_keyword
!
(
string_utf8
=
"
string
-
encoding
=
utf8
"
)
;
custom_keyword
!
(
string_utf16
=
"
string
-
encoding
=
utf16
"
)
;
custom_keyword
!
(
string_latin1_utf16
=
"
string
-
encoding
=
latin1
+
utf16
"
)
;
custom_keyword
!
(
r
#
struct
=
"
struct
"
)
;
custom_keyword
!
(
structref
)
;
custom_keyword
!
(
realloc
)
;
custom_keyword
!
(
post_return
=
"
post
-
return
"
)
;
custom_keyword
!
(
with
)
;
custom_keyword
!
(
core
)
;
custom_keyword
!
(
true_
=
"
true
"
)
;
custom_keyword
!
(
false_
=
"
false
"
)
;
custom_keyword
!
(
language
)
;
custom_keyword
!
(
sdk
)
;
custom_keyword
!
(
processed_by
=
"
processed
-
by
"
)
;
custom_keyword
!
(
mem_info
=
"
mem
-
info
"
)
;
custom_keyword
!
(
needed
)
;
custom_keyword
!
(
export_info
=
"
export
-
info
"
)
;
custom_keyword
!
(
import_info
=
"
import
-
info
"
)
;
custom_keyword
!
(
thread
)
;
custom_keyword
!
(
thread_spawn
=
"
thread
.
spawn
"
)
;
custom_keyword
!
(
thread_hw_concurrency
=
"
thread
.
hw_concurrency
"
)
;
custom_keyword
!
(
task_backpressure
=
"
task
.
backpressure
"
)
;
custom_keyword
!
(
task_return
=
"
task
.
return
"
)
;
custom_keyword
!
(
task_wait
=
"
task
.
wait
"
)
;
custom_keyword
!
(
task_poll
=
"
task
.
poll
"
)
;
custom_keyword
!
(
task_yield
=
"
task
.
yield
"
)
;
custom_keyword
!
(
subtask_drop
=
"
subtask
.
drop
"
)
;
custom_keyword
!
(
stream_new
=
"
stream
.
new
"
)
;
custom_keyword
!
(
stream_read
=
"
stream
.
read
"
)
;
custom_keyword
!
(
stream_write
=
"
stream
.
write
"
)
;
custom_keyword
!
(
stream_cancel_read
=
"
stream
.
cancel
-
read
"
)
;
custom_keyword
!
(
stream_cancel_write
=
"
stream
.
cancel
-
write
"
)
;
custom_keyword
!
(
stream_close_readable
=
"
stream
.
close
-
readable
"
)
;
custom_keyword
!
(
stream_close_writable
=
"
stream
.
close
-
writable
"
)
;
custom_keyword
!
(
future_new
=
"
future
.
new
"
)
;
custom_keyword
!
(
future_read
=
"
future
.
read
"
)
;
custom_keyword
!
(
future_write
=
"
future
.
write
"
)
;
custom_keyword
!
(
future_cancel_read
=
"
future
.
cancel
-
read
"
)
;
custom_keyword
!
(
future_cancel_write
=
"
future
.
cancel
-
write
"
)
;
custom_keyword
!
(
future_close_readable
=
"
future
.
close
-
readable
"
)
;
custom_keyword
!
(
future_close_writable
=
"
future
.
close
-
writable
"
)
;
custom_keyword
!
(
error_context_new
=
"
error
-
context
.
new
"
)
;
custom_keyword
!
(
error_context_debug_message
=
"
error
-
context
.
debug
-
message
"
)
;
custom_keyword
!
(
error_context_drop
=
"
error
-
context
.
drop
"
)
;
custom_keyword
!
(
wait
)
;
custom_keyword
!
(
definition
)
;
custom_keyword
!
(
r
#
async
=
"
async
"
)
;
custom_keyword
!
(
callback
)
;
custom_keyword
!
(
stream
)
;
custom_keyword
!
(
future
)
;
}
pub
mod
annotation
{
annotation
!
(
custom
)
;
annotation
!
(
name
)
;
annotation
!
(
producers
)
;
annotation
!
(
dylink_0
=
"
dylink
.
0
"
)
;
annotation
!
(
metadata_code_branch_hint
=
"
metadata
.
code
.
branch_hint
"
)
;
}
