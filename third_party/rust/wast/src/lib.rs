#
!
[
deny
(
missing_docs
intra_doc_link_resolution_failure
)
]
use
std
:
:
fmt
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
#
[
cfg
(
feature
=
"
wasm
-
module
"
)
]
mod
binary
;
#
[
cfg
(
feature
=
"
wasm
-
module
"
)
]
mod
resolve
;
mod
ast
;
pub
use
self
:
:
ast
:
:
*
;
pub
mod
lexer
;
pub
mod
parser
;
#
[
derive
(
Debug
)
]
pub
struct
Error
{
inner
:
Box
<
ErrorInner
>
}
#
[
derive
(
Debug
)
]
struct
ErrorInner
{
text
:
Option
<
Text
>
file
:
Option
<
PathBuf
>
span
:
Span
kind
:
ErrorKind
}
#
[
derive
(
Debug
)
]
struct
Text
{
line
:
usize
col
:
usize
snippet
:
String
}
#
[
derive
(
Debug
)
]
enum
ErrorKind
{
Lex
(
lexer
:
:
LexError
)
Custom
(
String
)
}
impl
Error
{
fn
lex
(
span
:
Span
content
:
&
str
kind
:
lexer
:
:
LexError
)
-
>
Error
{
let
mut
ret
=
Error
{
inner
:
Box
:
:
new
(
ErrorInner
{
text
:
None
file
:
None
span
kind
:
ErrorKind
:
:
Lex
(
kind
)
}
)
}
;
ret
.
set_text
(
content
)
;
return
ret
;
}
fn
parse
(
span
:
Span
content
:
&
str
message
:
String
)
-
>
Error
{
let
mut
ret
=
Error
{
inner
:
Box
:
:
new
(
ErrorInner
{
text
:
None
file
:
None
span
kind
:
ErrorKind
:
:
Custom
(
message
)
}
)
}
;
ret
.
set_text
(
content
)
;
return
ret
;
}
pub
fn
new
(
span
:
Span
message
:
String
)
-
>
Error
{
Error
{
inner
:
Box
:
:
new
(
ErrorInner
{
text
:
None
file
:
None
span
kind
:
ErrorKind
:
:
Custom
(
message
)
}
)
}
}
pub
fn
set_text
(
&
mut
self
contents
:
&
str
)
{
if
self
.
inner
.
text
.
is_some
(
)
{
return
;
}
self
.
inner
.
text
=
Some
(
Text
:
:
new
(
contents
self
.
inner
.
span
)
)
;
}
pub
fn
set_path
(
&
mut
self
path
:
&
Path
)
{
if
self
.
inner
.
file
.
is_some
(
)
{
return
;
}
self
.
inner
.
file
=
Some
(
path
.
to_path_buf
(
)
)
;
}
pub
fn
lex_error
(
&
self
)
-
>
Option
<
&
lexer
:
:
LexError
>
{
match
&
self
.
inner
.
kind
{
ErrorKind
:
:
Lex
(
e
)
=
>
Some
(
e
)
_
=
>
None
}
}
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
err
=
match
&
self
.
inner
.
kind
{
ErrorKind
:
:
Lex
(
e
)
=
>
e
as
&
dyn
fmt
:
:
Display
ErrorKind
:
:
Custom
(
e
)
=
>
e
as
&
dyn
fmt
:
:
Display
}
;
let
text
=
match
&
self
.
inner
.
text
{
Some
(
text
)
=
>
text
None
=
>
{
return
write
!
(
f
"
{
}
at
byte
offset
{
}
"
err
self
.
inner
.
span
.
offset
)
;
}
}
;
let
file
=
self
.
inner
.
file
.
as_ref
(
)
.
and_then
(
|
p
|
p
.
to_str
(
)
)
.
unwrap_or
(
"
<
anon
>
"
)
;
write
!
(
f
"
\
{
err
}
-
-
>
{
file
}
:
{
line
}
:
{
col
}
|
{
line
:
4
}
|
{
text
}
|
{
marker
:
>
0
}
"
text
.
col
+
1
file
=
file
line
=
text
.
line
+
1
col
=
text
.
col
+
1
err
=
err
text
=
text
.
snippet
marker
=
"
^
"
)
}
}
impl
std
:
:
error
:
:
Error
for
Error
{
}
impl
Text
{
fn
new
(
content
:
&
str
span
:
Span
)
-
>
Text
{
let
(
line
col
)
=
span
.
linecol_in
(
content
)
;
let
snippet
=
content
.
lines
(
)
.
nth
(
line
)
.
unwrap_or
(
"
"
)
.
to_string
(
)
;
Text
{
line
col
snippet
}
}
}
