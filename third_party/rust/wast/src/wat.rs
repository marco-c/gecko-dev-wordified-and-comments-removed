use
crate
:
:
component
:
:
Component
;
use
crate
:
:
core
:
:
{
Module
ModuleField
ModuleKind
}
;
use
crate
:
:
kw
;
use
crate
:
:
parser
:
:
{
Parse
Parser
Result
}
;
use
crate
:
:
token
:
:
Span
;
#
[
derive
(
Debug
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
Wat
<
'
a
>
{
Module
(
Module
<
'
a
>
)
Component
(
Component
<
'
a
>
)
}
impl
Wat
<
'
_
>
{
fn
validate
(
&
self
parser
:
Parser
<
'
_
>
)
-
>
Result
<
(
)
>
{
match
self
{
Wat
:
:
Module
(
m
)
=
>
m
.
validate
(
parser
)
Wat
:
:
Component
(
c
)
=
>
c
.
validate
(
parser
)
}
}
pub
fn
encode
(
&
mut
self
)
-
>
std
:
:
result
:
:
Result
<
Vec
<
u8
>
crate
:
:
Error
>
{
crate
:
:
core
:
:
EncodeOptions
:
:
default
(
)
.
encode_wat
(
self
)
}
pub
fn
span
(
&
self
)
-
>
Span
{
match
self
{
Wat
:
:
Module
(
m
)
=
>
m
.
span
Wat
:
:
Component
(
c
)
=
>
c
.
span
}
}
}
impl
<
'
a
>
Parse
<
'
a
>
for
Wat
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
if
!
parser
.
has_meaningful_tokens
(
)
{
return
Err
(
parser
.
error
(
"
expected
at
least
one
module
field
"
)
)
;
}
let
_r
=
parser
.
register_annotation
(
"
custom
"
)
;
let
_r
=
parser
.
register_annotation
(
"
producers
"
)
;
let
_r
=
parser
.
register_annotation
(
"
name
"
)
;
let
_r
=
parser
.
register_annotation
(
"
metadata
.
code
.
branch_hint
"
)
;
let
wat
=
if
parser
.
peek2
:
:
<
kw
:
:
module
>
(
)
?
{
Wat
:
:
Module
(
parser
.
parens
(
|
parser
|
parser
.
parse
(
)
)
?
)
}
else
if
parser
.
peek2
:
:
<
kw
:
:
component
>
(
)
?
{
Wat
:
:
Component
(
parser
.
parens
(
|
parser
|
parser
.
parse
(
)
)
?
)
}
else
{
let
fields
=
ModuleField
:
:
parse_remaining
(
parser
)
?
;
Wat
:
:
Module
(
Module
{
span
:
Span
{
offset
:
0
}
id
:
None
name
:
None
kind
:
ModuleKind
:
:
Text
(
fields
)
}
)
}
;
wat
.
validate
(
parser
)
?
;
Ok
(
wat
)
}
}
