use
crate
:
:
core
:
:
*
;
use
crate
:
:
parser
:
:
{
Parse
Parser
Result
}
;
use
crate
:
:
token
:
:
{
Id
Index
NameAnnotation
Span
}
;
use
crate
:
:
{
annotation
kw
}
;
pub
use
crate
:
:
core
:
:
resolve
:
:
Names
;
#
[
derive
(
Debug
)
]
pub
struct
Module
<
'
a
>
{
pub
span
:
Span
pub
id
:
Option
<
Id
<
'
a
>
>
pub
name
:
Option
<
NameAnnotation
<
'
a
>
>
pub
kind
:
ModuleKind
<
'
a
>
}
#
[
derive
(
Debug
)
]
pub
enum
ModuleKind
<
'
a
>
{
Text
(
Vec
<
ModuleField
<
'
a
>
>
)
Binary
(
Vec
<
&
'
a
[
u8
]
>
)
}
impl
<
'
a
>
Module
<
'
a
>
{
pub
fn
resolve
(
&
mut
self
)
-
>
std
:
:
result
:
:
Result
<
Names
<
'
a
>
crate
:
:
Error
>
{
let
names
=
match
&
mut
self
.
kind
{
ModuleKind
:
:
Text
(
fields
)
=
>
crate
:
:
core
:
:
resolve
:
:
resolve
(
fields
)
?
ModuleKind
:
:
Binary
(
_blobs
)
=
>
Default
:
:
default
(
)
}
;
Ok
(
names
)
}
pub
fn
encode
(
&
mut
self
)
-
>
std
:
:
result
:
:
Result
<
Vec
<
u8
>
crate
:
:
Error
>
{
self
.
resolve
(
)
?
;
Ok
(
match
&
self
.
kind
{
ModuleKind
:
:
Text
(
fields
)
=
>
crate
:
:
core
:
:
binary
:
:
encode
(
&
self
.
id
&
self
.
name
fields
)
ModuleKind
:
:
Binary
(
blobs
)
=
>
blobs
.
iter
(
)
.
flat_map
(
|
b
|
b
.
iter
(
)
.
cloned
(
)
)
.
collect
(
)
}
)
}
pub
(
crate
)
fn
validate
(
&
self
parser
:
Parser
<
'
_
>
)
-
>
Result
<
(
)
>
{
let
mut
starts
=
0
;
if
let
ModuleKind
:
:
Text
(
fields
)
=
&
self
.
kind
{
for
item
in
fields
.
iter
(
)
{
if
let
ModuleField
:
:
Start
(
_
)
=
item
{
starts
+
=
1
;
}
}
}
if
starts
>
1
{
return
Err
(
parser
.
error
(
"
multiple
start
sections
found
"
)
)
;
}
Ok
(
(
)
)
}
}
impl
<
'
a
>
Parse
<
'
a
>
for
Module
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
let
_r
=
parser
.
register_annotation
(
"
custom
"
)
;
let
span
=
parser
.
parse
:
:
<
kw
:
:
module
>
(
)
?
.
0
;
let
id
=
parser
.
parse
(
)
?
;
let
name
=
parser
.
parse
(
)
?
;
let
kind
=
if
parser
.
peek
:
:
<
kw
:
:
binary
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
binary
>
(
)
?
;
let
mut
data
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
{
data
.
push
(
parser
.
parse
(
)
?
)
;
}
ModuleKind
:
:
Binary
(
data
)
}
else
{
ModuleKind
:
:
Text
(
ModuleField
:
:
parse_remaining
(
parser
)
?
)
}
;
Ok
(
Module
{
span
id
name
kind
}
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Debug
)
]
pub
enum
ModuleField
<
'
a
>
{
Type
(
Type
<
'
a
>
)
Rec
(
Rec
<
'
a
>
)
Import
(
Import
<
'
a
>
)
Func
(
Func
<
'
a
>
)
Table
(
Table
<
'
a
>
)
Memory
(
Memory
<
'
a
>
)
Global
(
Global
<
'
a
>
)
Export
(
Export
<
'
a
>
)
Start
(
Index
<
'
a
>
)
Elem
(
Elem
<
'
a
>
)
Data
(
Data
<
'
a
>
)
Tag
(
Tag
<
'
a
>
)
Custom
(
Custom
<
'
a
>
)
}
impl
<
'
a
>
ModuleField
<
'
a
>
{
pub
(
crate
)
fn
parse_remaining
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Vec
<
ModuleField
>
>
{
let
mut
fields
=
Vec
:
:
new
(
)
;
while
!
parser
.
is_empty
(
)
{
fields
.
push
(
parser
.
parens
(
ModuleField
:
:
parse
)
?
)
;
}
Ok
(
fields
)
}
}
impl
<
'
a
>
Parse
<
'
a
>
for
ModuleField
<
'
a
>
{
fn
parse
(
parser
:
Parser
<
'
a
>
)
-
>
Result
<
Self
>
{
if
parser
.
peek
:
:
<
Type
<
'
a
>
>
(
)
{
return
Ok
(
ModuleField
:
:
Type
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
rec
>
(
)
{
return
Ok
(
ModuleField
:
:
Rec
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
import
>
(
)
{
return
Ok
(
ModuleField
:
:
Import
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
func
>
(
)
{
return
Ok
(
ModuleField
:
:
Func
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
table
>
(
)
{
return
Ok
(
ModuleField
:
:
Table
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
memory
>
(
)
{
return
Ok
(
ModuleField
:
:
Memory
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
global
>
(
)
{
return
Ok
(
ModuleField
:
:
Global
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
export
>
(
)
{
return
Ok
(
ModuleField
:
:
Export
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
start
>
(
)
{
parser
.
parse
:
:
<
kw
:
:
start
>
(
)
?
;
return
Ok
(
ModuleField
:
:
Start
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
elem
>
(
)
{
return
Ok
(
ModuleField
:
:
Elem
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
data
>
(
)
{
return
Ok
(
ModuleField
:
:
Data
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
kw
:
:
tag
>
(
)
{
return
Ok
(
ModuleField
:
:
Tag
(
parser
.
parse
(
)
?
)
)
;
}
if
parser
.
peek
:
:
<
annotation
:
:
custom
>
(
)
{
return
Ok
(
ModuleField
:
:
Custom
(
parser
.
parse
(
)
?
)
)
;
}
Err
(
parser
.
error
(
"
expected
valid
module
field
"
)
)
}
}
