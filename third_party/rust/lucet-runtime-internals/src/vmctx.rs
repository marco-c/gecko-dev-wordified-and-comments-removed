pub
use
crate
:
:
c_api
:
:
lucet_vmctx
;
use
crate
:
:
alloc
:
:
instance_heap_offset
;
use
crate
:
:
context
:
:
Context
;
use
crate
:
:
error
:
:
Error
;
use
crate
:
:
instance
:
:
{
EmptyYieldVal
Instance
InstanceInternal
State
TerminationDetails
YieldedVal
CURRENT_INSTANCE
HOST_CTX
}
;
use
lucet_module
:
:
{
FunctionHandle
GlobalValue
}
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
borrow
:
:
{
Borrow
BorrowMut
}
;
use
std
:
:
cell
:
:
{
Ref
RefCell
RefMut
}
;
use
std
:
:
marker
:
:
PhantomData
;
#
[
derive
(
Debug
)
]
pub
struct
Vmctx
{
vmctx
:
*
mut
lucet_vmctx
heap_view
:
RefCell
<
Box
<
[
u8
]
>
>
globals_view
:
RefCell
<
Box
<
[
GlobalValue
]
>
>
}
impl
Drop
for
Vmctx
{
fn
drop
(
&
mut
self
)
{
let
heap_view
=
self
.
heap_view
.
replace
(
Box
:
:
new
(
[
]
)
)
;
let
globals_view
=
self
.
globals_view
.
replace
(
Box
:
:
new
(
[
]
)
)
;
Box
:
:
leak
(
heap_view
)
;
Box
:
:
leak
(
globals_view
)
;
}
}
pub
trait
VmctxInternal
{
fn
instance
(
&
self
)
-
>
&
Instance
;
unsafe
fn
instance_mut
(
&
self
)
-
>
&
mut
Instance
;
fn
try_take_resumed_val
<
R
:
Any
+
'
static
>
(
&
self
)
-
>
Option
<
R
>
;
fn
yield_val_try_val
<
A
:
Any
+
'
static
R
:
Any
+
'
static
>
(
&
self
val
:
A
)
-
>
Option
<
R
>
;
}
impl
VmctxInternal
for
Vmctx
{
fn
instance
(
&
self
)
-
>
&
Instance
{
unsafe
{
instance_from_vmctx
(
self
.
vmctx
)
}
}
unsafe
fn
instance_mut
(
&
self
)
-
>
&
mut
Instance
{
instance_from_vmctx
(
self
.
vmctx
)
}
fn
try_take_resumed_val
<
R
:
Any
+
'
static
>
(
&
self
)
-
>
Option
<
R
>
{
let
inst
=
unsafe
{
self
.
instance_mut
(
)
}
;
if
let
Some
(
val
)
=
inst
.
resumed_val
.
take
(
)
{
match
val
.
downcast
(
)
{
Ok
(
val
)
=
>
Some
(
*
val
)
Err
(
val
)
=
>
{
inst
.
resumed_val
=
Some
(
val
)
;
None
}
}
}
else
{
None
}
}
fn
yield_val_try_val
<
A
:
Any
+
'
static
R
:
Any
+
'
static
>
(
&
self
val
:
A
)
-
>
Option
<
R
>
{
self
.
yield_impl
:
:
<
A
R
>
(
val
)
;
self
.
try_take_resumed_val
(
)
}
}
impl
Vmctx
{
pub
unsafe
fn
from_raw
(
vmctx
:
*
mut
lucet_vmctx
)
-
>
Vmctx
{
let
inst
=
instance_from_vmctx
(
vmctx
)
;
assert
!
(
inst
.
valid_magic
(
)
)
;
let
res
=
Vmctx
{
vmctx
heap_view
:
RefCell
:
:
new
(
Box
:
:
<
[
u8
]
>
:
:
from_raw
(
inst
.
heap_mut
(
)
)
)
globals_view
:
RefCell
:
:
new
(
Box
:
:
<
[
GlobalValue
]
>
:
:
from_raw
(
inst
.
globals_mut
(
)
)
)
}
;
res
}
pub
fn
as_raw
(
&
self
)
-
>
*
mut
lucet_vmctx
{
self
.
vmctx
}
pub
fn
heap
(
&
self
)
-
>
Ref
<
'
_
[
u8
]
>
{
unsafe
{
self
.
reconstitute_heap_view_if_needed
(
)
;
}
let
r
=
self
.
heap_view
.
try_borrow
(
)
.
unwrap_or_else
(
|
_
|
panic
!
(
TerminationDetails
:
:
BorrowError
(
"
heap
"
)
)
)
;
Ref
:
:
map
(
r
|
b
|
b
.
borrow
(
)
)
}
pub
fn
heap_mut
(
&
self
)
-
>
RefMut
<
'
_
[
u8
]
>
{
unsafe
{
self
.
reconstitute_heap_view_if_needed
(
)
;
}
let
r
=
self
.
heap_view
.
try_borrow_mut
(
)
.
unwrap_or_else
(
|
_
|
panic
!
(
TerminationDetails
:
:
BorrowError
(
"
heap_mut
"
)
)
)
;
RefMut
:
:
map
(
r
|
b
|
b
.
borrow_mut
(
)
)
}
unsafe
fn
reconstitute_heap_view_if_needed
(
&
self
)
{
let
inst
=
self
.
instance_mut
(
)
;
if
inst
.
heap_mut
(
)
.
len
(
)
!
=
self
.
heap_view
.
borrow
(
)
.
len
(
)
{
let
old_heap_view
=
self
.
heap_view
.
replace
(
Box
:
:
<
[
u8
]
>
:
:
from_raw
(
inst
.
heap_mut
(
)
)
)
;
Box
:
:
leak
(
old_heap_view
)
;
}
}
pub
fn
check_heap
<
T
>
(
&
self
ptr
:
*
const
T
len
:
usize
)
-
>
bool
{
self
.
instance
(
)
.
check_heap
(
ptr
len
)
}
pub
fn
contains_embed_ctx
<
T
:
Any
>
(
&
self
)
-
>
bool
{
self
.
instance
(
)
.
contains_embed_ctx
:
:
<
T
>
(
)
}
pub
fn
get_embed_ctx
<
T
:
Any
>
(
&
self
)
-
>
Ref
<
'
_
T
>
{
match
self
.
instance
(
)
.
embed_ctx
.
try_get
:
:
<
T
>
(
)
{
Some
(
Ok
(
t
)
)
=
>
t
Some
(
Err
(
_
)
)
=
>
panic
!
(
TerminationDetails
:
:
BorrowError
(
"
get_embed_ctx
"
)
)
None
=
>
panic
!
(
TerminationDetails
:
:
CtxNotFound
)
}
}
pub
fn
get_embed_ctx_mut
<
T
:
Any
>
(
&
self
)
-
>
RefMut
<
'
_
T
>
{
match
unsafe
{
self
.
instance_mut
(
)
.
embed_ctx
.
try_get_mut
:
:
<
T
>
(
)
}
{
Some
(
Ok
(
t
)
)
=
>
t
Some
(
Err
(
_
)
)
=
>
panic
!
(
TerminationDetails
:
:
BorrowError
(
"
get_embed_ctx_mut
"
)
)
None
=
>
panic
!
(
TerminationDetails
:
:
CtxNotFound
)
}
}
pub
unsafe
fn
terminate_no_unwind
(
&
mut
self
details
:
TerminationDetails
)
-
>
!
{
self
.
instance_mut
(
)
.
terminate
(
details
)
}
pub
fn
grow_memory
(
&
mut
self
additional_pages
:
u32
)
-
>
Result
<
u32
Error
>
{
unsafe
{
self
.
instance_mut
(
)
.
grow_memory
(
additional_pages
)
}
}
pub
fn
globals
(
&
self
)
-
>
Ref
<
'
_
[
GlobalValue
]
>
{
let
r
=
self
.
globals_view
.
try_borrow
(
)
.
unwrap_or_else
(
|
_
|
panic
!
(
TerminationDetails
:
:
BorrowError
(
"
globals
"
)
)
)
;
Ref
:
:
map
(
r
|
b
|
b
.
borrow
(
)
)
}
pub
fn
globals_mut
(
&
self
)
-
>
RefMut
<
'
_
[
GlobalValue
]
>
{
let
r
=
self
.
globals_view
.
try_borrow_mut
(
)
.
unwrap_or_else
(
|
_
|
panic
!
(
TerminationDetails
:
:
BorrowError
(
"
globals_mut
"
)
)
)
;
RefMut
:
:
map
(
r
|
b
|
b
.
borrow_mut
(
)
)
}
pub
fn
get_func_from_idx
(
&
self
table_idx
:
u32
func_idx
:
u32
)
-
>
Result
<
FunctionHandle
Error
>
{
self
.
instance
(
)
.
module
(
)
.
get_func_from_idx
(
table_idx
func_idx
)
}
pub
fn
yield_
(
&
self
)
{
self
.
yield_val_expecting_val
:
:
<
EmptyYieldVal
EmptyYieldVal
>
(
EmptyYieldVal
)
;
}
pub
fn
yield_expecting_val
<
R
:
Any
+
'
static
>
(
&
self
)
-
>
R
{
self
.
yield_val_expecting_val
:
:
<
EmptyYieldVal
R
>
(
EmptyYieldVal
)
}
pub
fn
yield_val
<
A
:
Any
+
'
static
>
(
&
self
val
:
A
)
{
self
.
yield_val_expecting_val
:
:
<
A
EmptyYieldVal
>
(
val
)
;
}
pub
fn
yield_val_expecting_val
<
A
:
Any
+
'
static
R
:
Any
+
'
static
>
(
&
self
val
:
A
)
-
>
R
{
self
.
yield_impl
:
:
<
A
R
>
(
val
)
;
self
.
take_resumed_val
(
)
}
fn
yield_impl
<
A
:
Any
+
'
static
R
:
Any
+
'
static
>
(
&
self
val
:
A
)
{
let
inst
=
unsafe
{
self
.
instance_mut
(
)
}
;
let
expecting
:
Box
<
PhantomData
<
R
>
>
=
Box
:
:
new
(
PhantomData
)
;
inst
.
state
=
State
:
:
Yielding
{
val
:
YieldedVal
:
:
new
(
val
)
expecting
:
expecting
as
Box
<
dyn
Any
>
}
;
HOST_CTX
.
with
(
|
host_ctx
|
unsafe
{
Context
:
:
swap
(
&
mut
inst
.
ctx
&
mut
*
host_ctx
.
get
(
)
)
}
)
;
}
fn
take_resumed_val
<
R
:
Any
+
'
static
>
(
&
self
)
-
>
R
{
self
.
try_take_resumed_val
(
)
.
unwrap_or_else
(
|
|
panic
!
(
TerminationDetails
:
:
YieldTypeMismatch
)
)
}
}
pub
unsafe
fn
instance_from_vmctx
<
'
a
>
(
vmctx
:
*
mut
lucet_vmctx
)
-
>
&
'
a
mut
Instance
{
assert
!
(
!
vmctx
.
is_null
(
)
"
vmctx
is
not
null
"
)
;
let
inst_ptr
=
(
vmctx
as
usize
-
instance_heap_offset
(
)
)
as
*
mut
Instance
;
CURRENT_INSTANCE
.
with
(
|
current_instance
|
{
if
let
Some
(
current_inst_ptr
)
=
current_instance
.
borrow
(
)
.
map
(
|
nn
|
nn
.
as_ptr
(
)
)
{
assert_eq
!
(
inst_ptr
current_inst_ptr
"
vmctx
corresponds
to
current
instance
"
)
;
}
else
{
panic
!
(
"
current
instance
is
not
set
;
thread
local
storage
failure
can
indicate
\
dynamic
linking
issues
"
)
;
}
}
)
;
let
inst
=
inst_ptr
.
as_mut
(
)
.
unwrap
(
)
;
assert
!
(
inst
.
valid_magic
(
)
)
;
inst
}
impl
Instance
{
unsafe
fn
terminate
(
&
mut
self
details
:
TerminationDetails
)
-
>
!
{
self
.
state
=
State
:
:
Terminating
{
details
}
;
#
[
allow
(
unused_unsafe
)
]
HOST_CTX
.
with
(
|
host_ctx
|
unsafe
{
Context
:
:
set
(
&
*
host_ctx
.
get
(
)
)
}
)
}
}
