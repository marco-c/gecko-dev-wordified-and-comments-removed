const
URI_LENGTH_MAX
:
usize
=
65536
;
const
TAB_ENTRIES_LIMIT
:
usize
=
5
;
const
REMOTE_COMMAND_TTL_MS
:
u64
=
2
*
24
*
60
*
60
*
1000
;
use
crate
:
:
error
:
:
*
;
use
crate
:
:
schema
;
use
crate
:
:
sync
:
:
record
:
:
TabsRecord
;
use
crate
:
:
DeviceType
;
use
crate
:
:
{
PendingCommand
RemoteCommand
Timestamp
}
;
use
rusqlite
:
:
{
types
:
:
{
FromSql
FromSqlError
FromSqlResult
ToSql
ToSqlOutput
ValueRef
}
Connection
OpenFlags
}
;
use
serde_derive
:
:
{
Deserialize
Serialize
}
;
use
sql_support
:
:
open_database
:
:
{
self
open_database_with_flags
}
;
use
sql_support
:
:
ConnExt
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
sync15
:
:
{
RemoteClient
ServerTimestamp
}
;
pub
type
TabsDeviceType
=
crate
:
:
DeviceType
;
pub
type
RemoteTabRecord
=
RemoteTab
;
pub
(
crate
)
const
TABS_CLIENT_TTL
:
u32
=
15_552_000
;
const
FAR_FUTURE
:
i64
=
4_102_405_200_000
;
const
MAX_PAYLOAD_SIZE
:
usize
=
512
*
1024
;
const
MAX_TITLE_CHAR_LENGTH
:
usize
=
512
;
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
Serialize
Deserialize
)
]
pub
struct
RemoteTab
{
pub
title
:
String
pub
url_history
:
Vec
<
String
>
pub
icon
:
Option
<
String
>
pub
last_used
:
i64
pub
inactive
:
bool
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ClientRemoteTabs
{
pub
client_id
:
String
pub
client_name
:
String
pub
device_type
:
DeviceType
pub
last_modified
:
i64
pub
remote_tabs
:
Vec
<
RemoteTab
>
}
pub
(
crate
)
enum
DbConnection
{
Created
Open
(
Connection
)
Closed
}
pub
struct
TabsStorage
{
local_tabs
:
RefCell
<
Option
<
Vec
<
RemoteTab
>
>
>
db_path
:
PathBuf
db_connection
:
DbConnection
}
impl
TabsStorage
{
pub
fn
new
(
db_path
:
impl
AsRef
<
Path
>
)
-
>
Self
{
Self
{
local_tabs
:
RefCell
:
:
default
(
)
db_path
:
db_path
.
as_ref
(
)
.
to_path_buf
(
)
db_connection
:
DbConnection
:
:
Created
}
}
pub
fn
close
(
&
mut
self
)
{
if
let
DbConnection
:
:
Open
(
conn
)
=
std
:
:
mem
:
:
replace
(
&
mut
self
.
db_connection
DbConnection
:
:
Closed
)
{
if
let
Err
(
err
)
=
conn
.
close
(
)
{
log
:
:
error
!
(
"
Failed
to
close
the
connection
:
{
:
?
}
"
err
)
;
}
}
}
pub
fn
new_with_mem_path
(
db_path
:
&
str
)
-
>
Self
{
let
name
=
PathBuf
:
:
from
(
format
!
(
"
file
:
{
}
?
mode
=
memory
&
cache
=
shared
"
db_path
)
)
;
Self
:
:
new
(
name
)
}
pub
fn
open_if_exists
(
&
mut
self
)
-
>
Result
<
Option
<
&
Connection
>
>
{
match
self
.
db_connection
{
DbConnection
:
:
Open
(
ref
conn
)
=
>
return
Ok
(
Some
(
conn
)
)
DbConnection
:
:
Closed
=
>
return
Ok
(
None
)
DbConnection
:
:
Created
=
>
{
}
}
let
flags
=
OpenFlags
:
:
SQLITE_OPEN_NO_MUTEX
|
OpenFlags
:
:
SQLITE_OPEN_URI
|
OpenFlags
:
:
SQLITE_OPEN_READ_WRITE
;
match
open_database_with_flags
(
self
.
db_path
.
clone
(
)
flags
&
crate
:
:
schema
:
:
TabsMigrationLogic
)
{
Ok
(
conn
)
=
>
{
self
.
db_connection
=
DbConnection
:
:
Open
(
conn
)
;
match
self
.
db_connection
{
DbConnection
:
:
Open
(
ref
conn
)
=
>
Ok
(
Some
(
conn
)
)
_
=
>
unreachable
!
(
"
impossible
value
"
)
}
}
Err
(
open_database
:
:
Error
:
:
SqlError
(
rusqlite
:
:
Error
:
:
SqliteFailure
(
code
_
)
)
)
if
code
.
code
=
=
rusqlite
:
:
ErrorCode
:
:
CannotOpen
=
>
{
Ok
(
None
)
}
Err
(
e
)
=
>
Err
(
e
.
into
(
)
)
}
}
pub
fn
open_or_create
(
&
mut
self
)
-
>
Result
<
&
Connection
>
{
match
self
.
db_connection
{
DbConnection
:
:
Open
(
ref
conn
)
=
>
return
Ok
(
conn
)
DbConnection
:
:
Closed
=
>
return
Err
(
Error
:
:
UnexpectedConnectionState
)
DbConnection
:
:
Created
=
>
{
}
}
let
flags
=
OpenFlags
:
:
SQLITE_OPEN_NO_MUTEX
|
OpenFlags
:
:
SQLITE_OPEN_URI
|
OpenFlags
:
:
SQLITE_OPEN_READ_WRITE
|
OpenFlags
:
:
SQLITE_OPEN_CREATE
;
let
conn
=
open_database_with_flags
(
self
.
db_path
.
clone
(
)
flags
&
crate
:
:
schema
:
:
TabsMigrationLogic
)
?
;
self
.
db_connection
=
DbConnection
:
:
Open
(
conn
)
;
match
self
.
db_connection
{
DbConnection
:
:
Open
(
ref
conn
)
=
>
Ok
(
conn
)
_
=
>
unreachable
!
(
"
We
just
set
to
Open
this
should
be
impossible
.
"
)
}
}
pub
fn
update_local_state
(
&
mut
self
local_state
:
Vec
<
RemoteTab
>
)
{
self
.
local_tabs
.
borrow_mut
(
)
.
replace
(
local_state
)
;
}
pub
fn
prepare_local_tabs_for_upload
(
&
self
)
-
>
Option
<
Vec
<
RemoteTab
>
>
{
if
let
Some
(
local_tabs
)
=
self
.
local_tabs
.
borrow
(
)
.
as_ref
(
)
{
let
mut
sanitized_tabs
:
Vec
<
RemoteTab
>
=
local_tabs
.
iter
(
)
.
cloned
(
)
.
filter_map
(
|
mut
tab
|
{
if
tab
.
url_history
.
is_empty
(
)
|
|
!
is_url_syncable
(
&
tab
.
url_history
[
0
]
)
{
return
None
;
}
let
mut
sanitized_history
=
Vec
:
:
with_capacity
(
TAB_ENTRIES_LIMIT
)
;
for
url
in
tab
.
url_history
{
if
sanitized_history
.
len
(
)
=
=
TAB_ENTRIES_LIMIT
{
break
;
}
if
is_url_syncable
(
&
url
)
{
sanitized_history
.
push
(
url
)
;
}
}
tab
.
url_history
=
sanitized_history
;
tab
.
title
=
slice_up_to
(
tab
.
title
MAX_TITLE_CHAR_LENGTH
)
;
Some
(
tab
)
}
)
.
collect
(
)
;
sanitized_tabs
.
sort_by
(
|
a
b
|
b
.
last_used
.
cmp
(
&
a
.
last_used
)
)
;
trim_tabs_length
(
&
mut
sanitized_tabs
MAX_PAYLOAD_SIZE
)
;
return
Some
(
sanitized_tabs
)
;
}
None
}
pub
fn
get_remote_tabs
(
&
mut
self
)
-
>
Option
<
Vec
<
ClientRemoteTabs
>
>
{
let
conn
=
match
self
.
open_if_exists
(
)
{
Err
(
e
)
=
>
{
error_support
:
:
report_error
!
(
"
tabs
-
read
-
remote
"
"
Failed
to
read
remote
tabs
:
{
}
"
e
)
;
return
None
;
}
Ok
(
None
)
=
>
return
None
Ok
(
Some
(
conn
)
)
=
>
conn
}
;
let
records
:
Vec
<
(
TabsRecord
ServerTimestamp
)
>
=
match
conn
.
query_rows_and_then_cached
(
"
SELECT
record
last_modified
FROM
tabs
"
[
]
|
row
|
-
>
Result
<
_
>
{
Ok
(
(
serde_json
:
:
from_str
(
&
row
.
get
:
:
<
_
String
>
(
0
)
?
)
?
ServerTimestamp
(
row
.
get
:
:
<
_
i64
>
(
1
)
?
)
)
)
}
)
{
Ok
(
records
)
=
>
records
Err
(
e
)
=
>
{
error_support
:
:
report_error
!
(
"
tabs
-
read
-
remote
"
"
Failed
to
read
database
:
{
}
"
e
)
;
return
None
;
}
}
;
let
mut
crts
:
Vec
<
ClientRemoteTabs
>
=
Vec
:
:
new
(
)
;
let
remote_clients
:
HashMap
<
String
RemoteClient
>
=
match
self
.
get_meta
:
:
<
String
>
(
schema
:
:
REMOTE_CLIENTS_KEY
)
{
Err
(
e
)
=
>
{
error_support
:
:
report_error
!
(
"
tabs
-
read
-
remote
"
"
Failed
to
get
remote
clients
:
{
}
"
e
)
;
return
None
;
}
Ok
(
None
)
=
>
HashMap
:
:
default
(
)
Ok
(
Some
(
json
)
)
=
>
serde_json
:
:
from_str
(
&
json
)
.
unwrap
(
)
}
;
for
(
record
last_modified
)
in
records
{
let
id
=
record
.
id
.
clone
(
)
;
let
crt
=
if
let
Some
(
remote_client
)
=
remote_clients
.
get
(
&
id
)
{
ClientRemoteTabs
:
:
from_record_with_remote_client
(
remote_client
.
fxa_device_id
.
as_ref
(
)
.
unwrap_or
(
&
id
)
.
to_owned
(
)
last_modified
remote_client
record
)
}
else
{
log
:
:
info
!
(
"
Storing
tabs
from
a
client
that
doesn
'
t
appear
in
the
devices
list
:
{
}
"
id
)
;
ClientRemoteTabs
:
:
from_record
(
id
last_modified
record
)
}
;
crts
.
push
(
crt
)
;
}
let
filtered_crts
=
self
.
filter_pending_remote_tabs
(
crts
)
;
Some
(
filtered_crts
)
}
fn
filter_pending_remote_tabs
(
&
mut
self
crts
:
Vec
<
ClientRemoteTabs
>
)
-
>
Vec
<
ClientRemoteTabs
>
{
let
conn
=
match
self
.
open_if_exists
(
)
{
Err
(
e
)
=
>
{
error_support
:
:
report_error
!
(
"
tabs
-
read
-
remote
"
"
Failed
to
read
remote
tabs
:
{
}
"
e
)
;
return
crts
;
}
Ok
(
None
)
=
>
return
crts
Ok
(
Some
(
conn
)
)
=
>
conn
}
;
let
pending_tabs_result
:
Result
<
Vec
<
(
String
String
)
>
>
=
conn
.
query_rows_and_then_cached
(
"
SELECT
device_id
url
FROM
remote_tab_commands
WHERE
command
=
:
command_close_tab
"
rusqlite
:
:
named_params
!
{
"
:
command_close_tab
"
:
CommandKind
:
:
CloseTab
}
|
row
|
{
Ok
(
(
row
.
get
:
:
<
_
String
>
(
0
)
?
row
.
get
:
:
<
_
String
>
(
1
)
?
)
)
}
)
;
let
pending_closures
=
match
pending_tabs_result
{
Ok
(
pending_closures
)
=
>
pending_closures
.
into_iter
(
)
.
fold
(
HashMap
:
:
new
(
)
|
mut
acc
:
HashMap
<
String
Vec
<
String
>
>
(
device_id
url
)
|
{
acc
.
entry
(
device_id
)
.
or_default
(
)
.
push
(
url
)
;
acc
}
)
Err
(
e
)
=
>
{
error_support
:
:
report_error
!
(
"
tabs
-
read
-
remote
"
"
Failed
to
read
database
:
{
}
"
e
)
;
return
crts
;
}
}
;
let
filtered_crts
:
Vec
<
ClientRemoteTabs
>
=
crts
.
into_iter
(
)
.
map
(
|
mut
crt
|
{
crt
.
remote_tabs
.
retain
(
|
tab
|
{
!
pending_closures
.
get
(
&
crt
.
client_id
)
.
map_or
(
false
|
urls
|
urls
.
contains
(
&
tab
.
url_history
[
0
]
)
)
}
)
;
crt
}
)
.
collect
(
)
;
filtered_crts
}
pub
fn
remove_stale_clients
(
&
mut
self
)
-
>
Result
<
(
)
>
{
let
last_sync
=
self
.
get_meta
:
:
<
i64
>
(
schema
:
:
LAST_SYNC_META_KEY
)
?
;
if
let
Some
(
conn
)
=
self
.
open_if_exists
(
)
?
{
if
let
Some
(
last_sync
)
=
last_sync
{
let
client_ttl_ms
=
(
TABS_CLIENT_TTL
as
i64
)
*
1000
;
if
last_sync
-
client_ttl_ms
>
=
0
&
&
last_sync
!
=
(
FAR_FUTURE
*
1000
)
{
let
tx
=
conn
.
unchecked_transaction
(
)
?
;
let
num_removed
=
tx
.
execute_cached
(
"
DELETE
FROM
tabs
WHERE
last_modified
<
=
:
last_sync
-
:
ttl
"
rusqlite
:
:
named_params
!
{
"
:
last_sync
"
:
last_sync
"
:
ttl
"
:
client_ttl_ms
}
)
?
;
log
:
:
info
!
(
"
removed
{
}
stale
clients
(
threshold
was
{
}
)
"
num_removed
last_sync
-
client_ttl_ms
)
;
tx
.
commit
(
)
?
;
}
}
}
Ok
(
(
)
)
}
pub
(
crate
)
fn
replace_remote_tabs
(
&
mut
self
new_remote_tabs
:
&
Vec
<
(
TabsRecord
ServerTimestamp
)
>
)
-
>
Result
<
(
)
>
{
let
connection
=
self
.
open_or_create
(
)
?
;
let
tx
=
connection
.
unchecked_transaction
(
)
?
;
for
remote_tab
in
new_remote_tabs
{
let
record
=
&
remote_tab
.
0
;
let
last_modified
=
remote_tab
.
1
;
log
:
:
info
!
(
"
inserting
tab
for
device
{
}
last
modified
at
{
}
"
record
.
id
last_modified
.
as_millis
(
)
)
;
tx
.
execute_cached
(
"
INSERT
OR
REPLACE
INTO
tabs
(
guid
record
last_modified
)
VALUES
(
:
guid
:
record
:
last_modified
)
;
"
rusqlite
:
:
named_params
!
{
"
:
guid
"
:
&
record
.
id
"
:
record
"
:
serde_json
:
:
to_string
(
&
record
)
.
expect
(
"
tabs
don
'
t
fail
to
serialize
"
)
"
:
last_modified
"
:
last_modified
.
as_millis
(
)
}
)
?
;
}
tx
.
commit
(
)
?
;
Ok
(
(
)
)
}
pub
(
crate
)
fn
wipe_remote_tabs
(
&
mut
self
)
-
>
Result
<
(
)
>
{
if
let
Some
(
db
)
=
self
.
open_if_exists
(
)
?
{
db
.
execute_batch
(
"
DELETE
FROM
tabs
"
)
?
;
}
Ok
(
(
)
)
}
pub
(
crate
)
fn
wipe_local_tabs
(
&
self
)
{
self
.
local_tabs
.
replace
(
None
)
;
}
pub
(
crate
)
fn
put_meta
(
&
mut
self
key
:
&
str
value
:
&
dyn
ToSql
)
-
>
Result
<
(
)
>
{
let
db
=
self
.
open_or_create
(
)
?
;
db
.
execute_cached
(
"
REPLACE
INTO
moz_meta
(
key
value
)
VALUES
(
:
key
:
value
)
"
&
[
(
"
:
key
"
&
key
as
&
dyn
ToSql
)
(
"
:
value
"
value
)
]
)
?
;
Ok
(
(
)
)
}
pub
(
crate
)
fn
get_meta
<
T
:
FromSql
>
(
&
mut
self
key
:
&
str
)
-
>
Result
<
Option
<
T
>
>
{
match
self
.
open_if_exists
(
)
{
Ok
(
Some
(
db
)
)
=
>
{
let
res
=
db
.
try_query_one
(
"
SELECT
value
FROM
moz_meta
WHERE
key
=
:
key
"
&
[
(
"
:
key
"
&
key
)
]
true
)
?
;
Ok
(
res
)
}
Err
(
e
)
=
>
Err
(
e
)
Ok
(
None
)
=
>
Ok
(
None
)
}
}
pub
(
crate
)
fn
delete_meta
(
&
mut
self
key
:
&
str
)
-
>
Result
<
(
)
>
{
if
let
Some
(
db
)
=
self
.
open_if_exists
(
)
?
{
db
.
execute_cached
(
"
DELETE
FROM
moz_meta
WHERE
key
=
:
key
"
&
[
(
"
:
key
"
&
key
)
]
)
?
;
}
Ok
(
(
)
)
}
}
impl
TabsStorage
{
pub
fn
add_remote_tab_command
(
&
mut
self
device_id
:
&
str
command
:
&
RemoteCommand
)
-
>
Result
<
bool
>
{
self
.
add_remote_tab_command_at
(
device_id
command
Timestamp
:
:
now
(
)
)
}
pub
fn
add_remote_tab_command_at
(
&
mut
self
device_id
:
&
str
command
:
&
RemoteCommand
time_requested
:
Timestamp
)
-
>
Result
<
bool
>
{
let
connection
=
self
.
open_or_create
(
)
?
;
let
RemoteCommand
:
:
CloseTab
{
url
}
=
command
;
log
:
:
info
!
(
"
Adding
remote
command
for
{
device_id
}
at
{
time_requested
}
"
)
;
log
:
:
trace
!
(
"
command
is
{
command
:
?
}
"
)
;
let
tx
=
connection
.
unchecked_transaction
(
)
?
;
let
changes
=
tx
.
execute_cached
(
"
INSERT
OR
IGNORE
INTO
remote_tab_commands
(
device_id
command
url
time_requested
time_sent
)
VALUES
(
:
device_id
:
command
:
url
:
time_requested
null
)
"
rusqlite
:
:
named_params
!
{
"
:
device_id
"
:
&
device_id
"
:
url
"
:
url
"
:
time_requested
"
:
time_requested
"
:
command
"
:
command
.
as_ref
(
)
}
)
?
;
tx
.
commit
(
)
?
;
Ok
(
changes
!
=
0
)
}
pub
fn
remove_remote_tab_command
(
&
mut
self
device_id
:
&
str
command
:
&
RemoteCommand
)
-
>
Result
<
bool
>
{
let
connection
=
self
.
open_or_create
(
)
?
;
let
RemoteCommand
:
:
CloseTab
{
url
}
=
command
;
log
:
:
info
!
(
"
removing
remote
tab
close
details
:
client
=
{
device_id
}
"
)
;
let
tx
=
connection
.
unchecked_transaction
(
)
?
;
let
changes
=
tx
.
execute_cached
(
"
DELETE
FROM
remote_tab_commands
WHERE
device_id
=
:
device_id
AND
command
=
:
command
AND
url
=
:
url
;
"
rusqlite
:
:
named_params
!
{
"
:
device_id
"
:
&
device_id
"
:
url
"
:
url
"
:
command
"
:
command
.
as_ref
(
)
}
)
?
;
tx
.
commit
(
)
?
;
Ok
(
changes
!
=
0
)
}
pub
fn
get_unsent_commands
(
&
mut
self
)
-
>
Result
<
Vec
<
PendingCommand
>
>
{
self
.
do_get_pending_commands
(
"
WHERE
time_sent
IS
NULL
"
)
}
fn
do_get_pending_commands
(
&
mut
self
where_clause
:
&
str
)
-
>
Result
<
Vec
<
PendingCommand
>
>
{
let
Some
(
conn
)
=
self
.
open_if_exists
(
)
?
else
{
return
Ok
(
Vec
:
:
new
(
)
)
;
}
;
let
result
=
conn
.
query_rows_and_then_cached
(
&
format
!
(
"
SELECT
device_id
command
url
time_requested
time_sent
FROM
remote_tab_commands
{
where_clause
}
ORDER
BY
time_requested
LIMIT
1000
-
-
sue
me
!
"
)
[
]
|
row
|
-
>
Result
<
_
>
{
let
command
=
match
row
.
get
:
:
<
_
CommandKind
>
(
1
)
{
Ok
(
c
)
=
>
c
Err
(
e
)
=
>
{
log
:
:
error
!
(
"
do_get_pending_commands
:
ignoring
error
fetching
command
:
{
e
:
?
}
"
)
;
return
Ok
(
None
)
;
}
}
;
Ok
(
Some
(
match
command
{
CommandKind
:
:
CloseTab
=
>
PendingCommand
{
device_id
:
row
.
get
:
:
<
_
String
>
(
0
)
?
command
:
RemoteCommand
:
:
CloseTab
{
url
:
row
.
get
:
:
<
_
String
>
(
2
)
?
}
time_requested
:
row
.
get
:
:
<
_
Timestamp
>
(
3
)
?
time_sent
:
row
.
get
:
:
<
_
Option
<
Timestamp
>
>
(
4
)
?
}
}
)
)
}
)
;
Ok
(
match
result
{
Ok
(
records
)
=
>
records
.
into_iter
(
)
.
flatten
(
)
.
collect
(
)
Err
(
e
)
=
>
{
error_support
:
:
report_error
!
(
"
tabs
-
get_unsent
"
"
Failed
to
read
database
:
{
}
"
e
)
;
Vec
:
:
new
(
)
}
}
)
}
pub
fn
set_pending_command_sent
(
&
mut
self
command
:
&
PendingCommand
)
-
>
Result
<
bool
>
{
let
connection
=
self
.
open_or_create
(
)
?
;
let
RemoteCommand
:
:
CloseTab
{
url
}
=
&
command
.
command
;
log
:
:
info
!
(
"
setting
remote
tab
sent
:
client
=
{
}
"
command
.
device_id
)
;
log
:
:
trace
!
(
"
command
:
{
command
:
?
}
"
)
;
let
tx
=
connection
.
unchecked_transaction
(
)
?
;
let
ts
=
Timestamp
:
:
now
(
)
;
let
changes
=
tx
.
execute_cached
(
"
UPDATE
remote_tab_commands
SET
time_sent
=
:
ts
WHERE
device_id
=
:
device_id
AND
command
=
:
command
AND
url
=
:
url
;
"
rusqlite
:
:
named_params
!
{
"
:
command
"
:
command
.
command
.
as_ref
(
)
"
:
device_id
"
:
&
command
.
device_id
"
:
url
"
:
url
"
:
ts
"
:
&
ts
}
)
?
;
tx
.
commit
(
)
?
;
Ok
(
changes
!
=
0
)
}
pub
fn
remove_old_pending_closures
(
&
mut
self
new_remote_tabs
:
&
[
(
TabsRecord
ServerTimestamp
)
]
)
-
>
Result
<
(
)
>
{
let
remote_clients
:
HashMap
<
String
RemoteClient
>
=
{
match
self
.
get_meta
:
:
<
String
>
(
schema
:
:
REMOTE_CLIENTS_KEY
)
?
{
None
=
>
HashMap
:
:
default
(
)
Some
(
json
)
=
>
serde_json
:
:
from_str
(
&
json
)
.
unwrap
(
)
}
}
;
let
conn
=
self
.
open_or_create
(
)
?
;
let
tx
=
conn
.
unchecked_transaction
(
)
?
;
conn
.
execute
(
"
CREATE
TEMP
TABLE
if
not
exists
new_remote_tabs
(
device_id
TEXT
url
TEXT
)
"
[
]
)
?
;
conn
.
execute
(
"
DELETE
FROM
new_remote_tabs
"
[
]
)
?
;
for
(
record
_
)
in
new_remote_tabs
.
iter
(
)
{
let
fxa_id
=
remote_clients
.
get
(
&
record
.
id
)
.
and_then
(
|
r
|
r
.
fxa_device_id
.
as_ref
(
)
)
.
unwrap_or
(
&
record
.
id
)
;
for
tab
in
&
record
.
tabs
{
if
let
Some
(
url
)
=
tab
.
url_history
.
first
(
)
{
conn
.
execute
(
"
INSERT
INTO
new_remote_tabs
(
device_id
url
)
VALUES
(
?
?
)
"
rusqlite
:
:
params
!
[
fxa_id
url
]
)
?
;
}
}
}
let
delete_sql
=
"
DELETE
FROM
remote_tab_commands
WHERE
(
device_id
IN
(
SELECT
device_id
from
new_remote_tabs
)
)
AND
(
url
NOT
IN
(
SELECT
url
from
new_remote_tabs
WHERE
new_remote_tabs
.
device_id
=
device_id
AND
:
command_close_tab
=
remote_tab_commands
.
command
)
)
"
;
conn
.
execute
(
delete_sql
rusqlite
:
:
named_params
!
{
"
:
command_close_tab
"
:
CommandKind
:
:
CloseTab
}
)
?
;
log
:
:
info
!
(
"
deleted
{
}
pending
tab
closures
because
they
were
not
in
the
new
tabs
"
conn
.
changes
(
)
)
;
let
sql
=
format
!
(
"
DELETE
FROM
remote_tab_commands
WHERE
device_id
IN
(
SELECT
guid
FROM
tabs
)
AND
(
SELECT
last_modified
FROM
tabs
WHERE
guid
=
device_id
)
-
time_requested
>
=
{
REMOTE_COMMAND_TTL_MS
}
"
)
;
tx
.
execute_cached
(
&
sql
[
]
)
?
;
log
:
:
info
!
(
"
deleted
{
}
records
because
they
timed
out
"
conn
.
changes
(
)
)
;
tx
.
commit
(
)
?
;
conn
.
execute
(
"
DROP
TABLE
new_remote_tabs
"
[
]
)
?
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
repr
(
u8
)
]
enum
CommandKind
{
CloseTab
=
0
}
impl
AsRef
<
CommandKind
>
for
RemoteCommand
{
fn
as_ref
(
&
self
)
-
>
&
CommandKind
{
match
self
{
RemoteCommand
:
:
CloseTab
{
.
.
}
=
>
&
CommandKind
:
:
CloseTab
}
}
}
impl
FromSql
for
CommandKind
{
fn
column_result
(
value
:
ValueRef
<
'
_
>
)
-
>
FromSqlResult
<
Self
>
{
Ok
(
match
value
.
as_i64
(
)
?
{
0
=
>
CommandKind
:
:
CloseTab
_
=
>
return
Err
(
FromSqlError
:
:
InvalidType
)
}
)
}
}
impl
ToSql
for
CommandKind
{
fn
to_sql
(
&
self
)
-
>
rusqlite
:
:
Result
<
ToSqlOutput
<
'
_
>
>
{
Ok
(
ToSqlOutput
:
:
from
(
*
self
as
u8
)
)
}
}
fn
trim_tabs_length
(
tabs
:
&
mut
Vec
<
RemoteTab
>
payload_size_max_bytes
:
usize
)
{
if
let
Some
(
count
)
=
payload_support
:
:
try_fit_items
(
tabs
payload_size_max_bytes
)
.
as_some
(
)
{
tabs
.
truncate
(
count
.
get
(
)
)
;
}
}
pub
fn
slice_up_to
(
s
:
String
max_len
:
usize
)
-
>
String
{
if
max_len
>
=
s
.
len
(
)
{
return
s
;
}
let
ellipsis
=
'
\
u
{
2026
}
'
;
let
mut
idx
=
max_len
-
ellipsis
.
len_utf8
(
)
;
while
!
s
.
is_char_boundary
(
idx
)
{
idx
-
=
1
;
}
let
mut
new_str
=
s
[
.
.
idx
]
.
to_string
(
)
;
new_str
.
push
(
ellipsis
)
;
new_str
}
fn
is_url_syncable
(
url
:
&
str
)
-
>
bool
{
url
.
len
(
)
<
=
URI_LENGTH_MAX
&
&
!
(
url
.
starts_with
(
"
about
:
"
)
|
|
url
.
starts_with
(
"
resource
:
"
)
|
|
url
.
starts_with
(
"
chrome
:
"
)
|
|
url
.
starts_with
(
"
wyciwyg
:
"
)
|
|
url
.
starts_with
(
"
blob
:
"
)
|
|
url
.
starts_with
(
"
file
:
"
)
|
|
url
.
starts_with
(
"
moz
-
extension
:
"
)
|
|
url
.
starts_with
(
"
data
:
"
)
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
payload_support
:
:
compute_serialized_size
;
use
std
:
:
time
:
:
Duration
;
use
super
:
:
*
;
use
crate
:
:
{
sync
:
:
record
:
:
TabsRecordTab
PendingCommand
}
;
impl
RemoteCommand
{
fn
close_tab
(
url
:
&
str
)
-
>
Self
{
RemoteCommand
:
:
CloseTab
{
url
:
url
.
to_string
(
)
}
}
}
#
[
test
]
fn
test_is_url_syncable
(
)
{
assert
!
(
is_url_syncable
(
"
https
:
/
/
bobo
.
com
"
)
)
;
assert
!
(
is_url_syncable
(
"
ftp
:
/
/
bobo
.
com
"
)
)
;
assert
!
(
!
is_url_syncable
(
"
about
:
blank
"
)
)
;
assert
!
(
is_url_syncable
(
"
aboutbobo
.
com
"
)
)
;
assert
!
(
!
is_url_syncable
(
"
file
:
/
/
/
Users
/
eoger
/
bobo
"
)
)
;
}
#
[
test
]
fn
test_open_if_exists_no_file
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
dir
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
db_name
=
dir
.
path
(
)
.
join
(
"
test_open_for_read_no_file
.
db
"
)
;
let
mut
storage
=
TabsStorage
:
:
new
(
db_name
.
clone
(
)
)
;
assert
!
(
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
is_none
(
)
)
;
storage
.
open_or_create
(
)
.
unwrap
(
)
;
let
mut
storage
=
TabsStorage
:
:
new
(
db_name
)
;
assert
!
(
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
is_some
(
)
)
;
}
#
[
test
]
fn
test_tabs_meta
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
dir
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
db_name
=
dir
.
path
(
)
.
join
(
"
test_tabs_meta
.
db
"
)
;
let
mut
db
=
TabsStorage
:
:
new
(
db_name
)
;
let
test_key
=
"
TEST
KEY
A
"
;
let
test_value
=
"
TEST
VALUE
A
"
;
let
test_key2
=
"
TEST
KEY
B
"
;
let
test_value2
=
"
TEST
VALUE
B
"
;
db
.
put_meta
(
test_key
&
test_value
)
.
unwrap
(
)
;
db
.
put_meta
(
test_key2
&
test_value2
)
.
unwrap
(
)
;
let
retrieved_value
:
String
=
db
.
get_meta
(
test_key
)
.
unwrap
(
)
.
expect
(
"
test
value
"
)
;
let
retrieved_value2
:
String
=
db
.
get_meta
(
test_key2
)
.
unwrap
(
)
.
expect
(
"
test
value
2
"
)
;
assert_eq
!
(
retrieved_value
test_value
)
;
assert_eq
!
(
retrieved_value2
test_value2
)
;
let
test_value3
=
"
TEST
VALUE
C
"
;
db
.
put_meta
(
test_key
&
test_value3
)
.
unwrap
(
)
;
let
retrieved_value3
:
String
=
db
.
get_meta
(
test_key
)
.
unwrap
(
)
.
expect
(
"
test
value
3
"
)
;
assert_eq
!
(
retrieved_value3
test_value3
)
;
db
.
delete_meta
(
test_key
)
.
unwrap
(
)
;
let
retrieved_value4
:
Option
<
String
>
=
db
.
get_meta
(
test_key
)
.
unwrap
(
)
;
assert
!
(
retrieved_value4
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_prepare_local_tabs_for_upload
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_prepare_local_tabs_for_upload
"
)
;
assert_eq
!
(
storage
.
prepare_local_tabs_for_upload
(
)
None
)
;
storage
.
update_local_state
(
vec
!
[
RemoteTab
{
url_history
:
vec
!
[
"
about
:
blank
"
.
to_owned
(
)
"
https
:
/
/
foo
.
bar
"
.
to_owned
(
)
]
.
.
Default
:
:
default
(
)
}
RemoteTab
{
url_history
:
vec
!
[
"
https
:
/
/
foo
.
bar
"
.
to_owned
(
)
"
about
:
blank
"
.
to_owned
(
)
"
about
:
blank
"
.
to_owned
(
)
"
about
:
blank
"
.
to_owned
(
)
"
about
:
blank
"
.
to_owned
(
)
"
about
:
blank
"
.
to_owned
(
)
"
about
:
blank
"
.
to_owned
(
)
"
about
:
blank
"
.
to_owned
(
)
]
.
.
Default
:
:
default
(
)
}
RemoteTab
{
url_history
:
vec
!
[
"
https
:
/
/
foo
.
bar
"
.
to_owned
(
)
"
about
:
blank
"
.
to_owned
(
)
"
https
:
/
/
foo2
.
bar
"
.
to_owned
(
)
"
https
:
/
/
foo3
.
bar
"
.
to_owned
(
)
"
https
:
/
/
foo4
.
bar
"
.
to_owned
(
)
"
https
:
/
/
foo5
.
bar
"
.
to_owned
(
)
"
https
:
/
/
foo6
.
bar
"
.
to_owned
(
)
]
.
.
Default
:
:
default
(
)
}
RemoteTab
{
.
.
Default
:
:
default
(
)
}
]
)
;
assert_eq
!
(
storage
.
prepare_local_tabs_for_upload
(
)
Some
(
vec
!
[
RemoteTab
{
url_history
:
vec
!
[
"
https
:
/
/
foo
.
bar
"
.
to_owned
(
)
]
.
.
Default
:
:
default
(
)
}
RemoteTab
{
url_history
:
vec
!
[
"
https
:
/
/
foo
.
bar
"
.
to_owned
(
)
"
https
:
/
/
foo2
.
bar
"
.
to_owned
(
)
"
https
:
/
/
foo3
.
bar
"
.
to_owned
(
)
"
https
:
/
/
foo4
.
bar
"
.
to_owned
(
)
"
https
:
/
/
foo5
.
bar
"
.
to_owned
(
)
]
.
.
Default
:
:
default
(
)
}
]
)
)
;
}
#
[
test
]
fn
test_trimming_tab_title
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_prepare_local_tabs_for_upload
"
)
;
assert_eq
!
(
storage
.
prepare_local_tabs_for_upload
(
)
None
)
;
storage
.
update_local_state
(
vec
!
[
RemoteTab
{
title
:
"
a
"
.
repeat
(
MAX_TITLE_CHAR_LENGTH
+
10
)
/
/
Fill
a
string
more
than
max
url_history
:
vec
!
[
"
https
:
/
/
foo
.
bar
"
.
to_owned
(
)
]
.
.
Default
:
:
default
(
)
}
]
)
;
let
ellipsis_char
=
'
\
u
{
2026
}
'
;
let
mut
truncated_title
=
"
a
"
.
repeat
(
MAX_TITLE_CHAR_LENGTH
-
ellipsis_char
.
len_utf8
(
)
)
;
truncated_title
.
push
(
ellipsis_char
)
;
assert_eq
!
(
storage
.
prepare_local_tabs_for_upload
(
)
Some
(
vec
!
[
/
/
title
trimmed
to
50
characters
RemoteTab
{
title
:
truncated_title
/
/
title
was
trimmed
to
only
max
char
length
url_history
:
vec
!
[
"
https
:
/
/
foo
.
bar
"
.
to_owned
(
)
]
.
.
Default
:
:
default
(
)
}
]
)
)
;
}
#
[
test
]
fn
test_utf8_safe_title_trim
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_prepare_local_tabs_for_upload
"
)
;
assert_eq
!
(
storage
.
prepare_local_tabs_for_upload
(
)
None
)
;
storage
.
update_local_state
(
vec
!
[
RemoteTab
{
title
:
"
"
.
repeat
(
MAX_TITLE_CHAR_LENGTH
+
10
)
/
/
Fill
a
string
more
than
max
url_history
:
vec
!
[
"
https
:
/
/
foo
.
bar
"
.
to_owned
(
)
]
.
.
Default
:
:
default
(
)
}
RemoteTab
{
title
:
"
"
.
repeat
(
MAX_TITLE_CHAR_LENGTH
+
5
)
/
/
Fill
a
string
more
than
max
url_history
:
vec
!
[
"
https
:
/
/
foo_jp
.
bar
"
.
to_owned
(
)
]
.
.
Default
:
:
default
(
)
}
]
)
;
let
ellipsis_char
=
'
\
u
{
2026
}
'
;
let
mut
truncated_title
=
"
"
.
repeat
(
127
)
;
let
mut
truncated_jp_title
=
"
"
.
repeat
(
169
)
;
truncated_title
.
push
(
ellipsis_char
)
;
truncated_jp_title
.
push
(
ellipsis_char
)
;
let
remote_tabs
=
storage
.
prepare_local_tabs_for_upload
(
)
.
unwrap
(
)
;
assert_eq
!
(
remote_tabs
vec
!
[
RemoteTab
{
title
:
truncated_title
/
/
title
was
trimmed
to
only
max
char
length
url_history
:
vec
!
[
"
https
:
/
/
foo
.
bar
"
.
to_owned
(
)
]
.
.
Default
:
:
default
(
)
}
RemoteTab
{
title
:
truncated_jp_title
/
/
title
was
trimmed
to
only
max
char
length
url_history
:
vec
!
[
"
https
:
/
/
foo_jp
.
bar
"
.
to_owned
(
)
]
.
.
Default
:
:
default
(
)
}
]
)
;
assert
!
(
remote_tabs
[
0
]
.
title
.
chars
(
)
.
count
(
)
<
=
MAX_TITLE_CHAR_LENGTH
)
;
assert
!
(
remote_tabs
[
1
]
.
title
.
chars
(
)
.
count
(
)
<
=
MAX_TITLE_CHAR_LENGTH
)
;
}
#
[
test
]
fn
test_trim_tabs_length
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_prepare_local_tabs_for_upload
"
)
;
assert_eq
!
(
storage
.
prepare_local_tabs_for_upload
(
)
None
)
;
let
mut
too_many_tabs
:
Vec
<
RemoteTab
>
=
Vec
:
:
new
(
)
;
for
n
in
1
.
.
5000
{
too_many_tabs
.
push
(
RemoteTab
{
title
:
"
aaaa
aaaa
aaaa
aaaa
aaaa
aaaa
aaaa
aaaa
aaaa
aaaa
"
.
to_owned
(
)
url_history
:
vec
!
[
format
!
(
"
https
:
/
/
foo
{
}
.
bar
"
n
)
]
.
.
Default
:
:
default
(
)
}
)
;
}
let
tabs_mem_size
=
compute_serialized_size
(
&
too_many_tabs
)
.
unwrap
(
)
;
assert
!
(
tabs_mem_size
>
MAX_PAYLOAD_SIZE
)
;
storage
.
update_local_state
(
too_many_tabs
.
clone
(
)
)
;
let
tabs_to_upload
=
&
storage
.
prepare_local_tabs_for_upload
(
)
.
unwrap
(
)
;
assert
!
(
compute_serialized_size
(
tabs_to_upload
)
.
unwrap
(
)
<
=
MAX_PAYLOAD_SIZE
)
;
}
struct
TabsSQLRecord
{
guid
:
String
record
:
TabsRecord
last_modified
:
i64
}
#
[
test
]
fn
test_remove_stale_clients
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
dir
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
db_name
=
dir
.
path
(
)
.
join
(
"
test_remove_stale_clients
.
db
"
)
;
let
mut
storage
=
TabsStorage
:
:
new
(
db_name
)
;
storage
.
open_or_create
(
)
.
unwrap
(
)
;
assert
!
(
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
is_some
(
)
)
;
let
records
=
vec
!
[
TabsSQLRecord
{
guid
:
"
device
-
1
"
.
to_string
(
)
record
:
TabsRecord
{
id
:
"
device
-
1
"
.
to_string
(
)
client_name
:
"
Device
#
1
"
.
to_string
(
)
tabs
:
vec
!
[
TabsRecordTab
{
title
:
"
the
title
"
.
to_string
(
)
url_history
:
vec
!
[
"
https
:
/
/
mozilla
.
org
/
"
.
to_string
(
)
]
icon
:
Some
(
"
https
:
/
/
mozilla
.
org
/
icon
"
.
to_string
(
)
)
last_used
:
1643764207000
.
.
Default
:
:
default
(
)
}
]
}
last_modified
:
1643764207000
}
TabsSQLRecord
{
guid
:
"
device
-
outdated
"
.
to_string
(
)
record
:
TabsRecord
{
id
:
"
device
-
outdated
"
.
to_string
(
)
client_name
:
"
Device
outdated
"
.
to_string
(
)
tabs
:
vec
!
[
TabsRecordTab
{
title
:
"
the
title
"
.
to_string
(
)
url_history
:
vec
!
[
"
https
:
/
/
mozilla
.
org
/
"
.
to_string
(
)
]
icon
:
Some
(
"
https
:
/
/
mozilla
.
org
/
icon
"
.
to_string
(
)
)
last_used
:
1643764207000
.
.
Default
:
:
default
(
)
}
]
}
last_modified
:
1443764207000
/
/
old
}
]
;
let
db
=
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
unwrap
(
)
;
for
record
in
records
{
db
.
execute
(
"
INSERT
INTO
tabs
(
guid
record
last_modified
)
VALUES
(
:
guid
:
record
:
last_modified
)
;
"
rusqlite
:
:
named_params
!
{
"
:
guid
"
:
&
record
.
guid
"
:
record
"
:
serde_json
:
:
to_string
(
&
record
.
record
)
.
unwrap
(
)
"
:
last_modified
"
:
&
record
.
last_modified
}
)
.
unwrap
(
)
;
}
let
last_synced
=
1643764207000_i64
;
storage
.
put_meta
(
schema
:
:
LAST_SYNC_META_KEY
&
last_synced
)
.
unwrap
(
)
;
storage
.
remove_stale_clients
(
)
.
unwrap
(
)
;
let
remote_tabs
=
storage
.
get_remote_tabs
(
)
.
unwrap
(
)
;
assert_eq
!
(
remote_tabs
.
len
(
)
1
)
;
assert_eq
!
(
remote_tabs
[
0
]
.
client_id
"
device
-
1
"
)
;
}
fn
pending_url_command
(
device_id
:
&
str
url
:
&
str
ts
:
Timestamp
)
-
>
PendingCommand
{
PendingCommand
{
device_id
:
device_id
.
to_string
(
)
command
:
RemoteCommand
:
:
CloseTab
{
url
:
url
.
to_string
(
)
}
time_requested
:
ts
time_sent
:
None
}
}
#
[
test
]
fn
test_add_pending_dupe_simple
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_add_pending_dupe_simple
"
)
;
let
command
=
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example1
.
com
"
)
;
assert
!
(
storage
.
add_remote_tab_command
(
"
device
-
1
"
&
command
)
.
expect
(
"
should
work
"
)
)
;
assert
!
(
!
storage
.
add_remote_tab_command
(
"
device
-
1
"
&
command
)
.
expect
(
"
should
work
"
)
)
;
assert
!
(
storage
.
remove_remote_tab_command
(
"
device
-
1
"
&
command
)
.
expect
(
"
should
work
"
)
)
;
assert
!
(
storage
.
add_remote_tab_command
(
"
device
-
1
"
&
command
)
.
expect
(
"
should
work
"
)
)
;
}
#
[
test
]
fn
test_add_pending_remote_close
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_add_pending_remote_close
"
)
;
storage
.
open_or_create
(
)
.
unwrap
(
)
;
assert
!
(
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
is_some
(
)
)
;
let
now
=
Timestamp
:
:
now
(
)
;
let
earliest
=
now
.
checked_sub
(
Duration
:
:
from_millis
(
1
)
)
.
unwrap
(
)
;
let
later
=
now
.
checked_add
(
Duration
:
:
from_millis
(
1
)
)
.
unwrap
(
)
;
let
latest
=
now
.
checked_add
(
Duration
:
:
from_millis
(
2
)
)
.
unwrap
(
)
;
storage
.
add_remote_tab_command_at
(
"
device
-
1
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example1
.
com
"
)
latest
)
.
expect
(
"
should
work
"
)
;
storage
.
add_remote_tab_command_at
(
"
device
-
1
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example2
.
com
"
)
earliest
)
.
expect
(
"
should
work
"
)
;
storage
.
add_remote_tab_command_at
(
"
device
-
2
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example2
.
com
"
)
now
)
.
expect
(
"
should
work
"
)
;
storage
.
add_remote_tab_command_at
(
"
device
-
2
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example3
.
com
"
)
later
)
.
expect
(
"
should
work
"
)
;
let
got
=
storage
.
get_unsent_commands
(
)
.
unwrap
(
)
;
assert_eq
!
(
got
.
len
(
)
4
)
;
assert_eq
!
(
got
vec
!
[
pending_url_command
(
"
device
-
1
"
"
https
:
/
/
example2
.
com
"
earliest
)
pending_url_command
(
"
device
-
2
"
"
https
:
/
/
example2
.
com
"
now
)
pending_url_command
(
"
device
-
2
"
"
https
:
/
/
example3
.
com
"
later
)
pending_url_command
(
"
device
-
1
"
"
https
:
/
/
example1
.
com
"
latest
)
]
)
;
}
#
[
test
]
fn
test_remote_tabs_filters_pending_closures
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_remote_tabs_filters_pending_closures
"
)
;
let
records
=
vec
!
[
TabsSQLRecord
{
guid
:
"
device
-
1
"
.
to_string
(
)
record
:
TabsRecord
{
id
:
"
device
-
1
"
.
to_string
(
)
client_name
:
"
Device
#
1
"
.
to_string
(
)
tabs
:
vec
!
[
TabsRecordTab
{
title
:
"
the
title
"
.
to_string
(
)
url_history
:
vec
!
[
"
https
:
/
/
mozilla
.
org
/
"
.
to_string
(
)
]
icon
:
Some
(
"
https
:
/
/
mozilla
.
org
/
icon
"
.
to_string
(
)
)
last_used
:
1711929600015
/
/
4
/
1
/
2024
.
.
Default
:
:
default
(
)
}
]
}
last_modified
:
1711929600015
/
/
4
/
1
/
2024
}
TabsSQLRecord
{
guid
:
"
device
-
2
"
.
to_string
(
)
record
:
TabsRecord
{
id
:
"
device
-
2
"
.
to_string
(
)
client_name
:
"
Another
device
"
.
to_string
(
)
tabs
:
vec
!
[
TabsRecordTab
{
title
:
"
the
title
"
.
to_string
(
)
url_history
:
vec
!
[
"
https
:
/
/
mozilla
.
org
/
"
.
to_string
(
)
]
icon
:
Some
(
"
https
:
/
/
mozilla
.
org
/
icon
"
.
to_string
(
)
)
last_used
:
1711929600015
/
/
4
/
1
/
2024
.
.
Default
:
:
default
(
)
}
TabsRecordTab
{
title
:
"
the
title
"
.
to_string
(
)
url_history
:
vec
!
[
"
https
:
/
/
example
.
com
/
"
.
to_string
(
)
"
https
:
/
/
example1
.
com
/
"
.
to_string
(
)
]
icon
:
None
last_used
:
1711929600015
/
/
4
/
1
/
2024
.
.
Default
:
:
default
(
)
}
TabsRecordTab
{
title
:
"
the
title
"
.
to_string
(
)
url_history
:
vec
!
[
"
https
:
/
/
example1
.
com
/
"
.
to_string
(
)
]
icon
:
None
last_used
:
1711929600015
/
/
4
/
1
/
2024
.
.
Default
:
:
default
(
)
}
]
}
last_modified
:
1711929600015
/
/
4
/
1
/
2024
}
]
;
let
db
=
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
unwrap
(
)
;
for
record
in
records
{
db
.
execute
(
"
INSERT
INTO
tabs
(
guid
record
last_modified
)
VALUES
(
:
guid
:
record
:
last_modified
)
;
"
rusqlite
:
:
named_params
!
{
"
:
guid
"
:
&
record
.
guid
"
:
record
"
:
serde_json
:
:
to_string
(
&
record
.
record
)
.
unwrap
(
)
"
:
last_modified
"
:
&
record
.
last_modified
}
)
.
unwrap
(
)
;
}
storage
.
add_remote_tab_command
(
"
device
-
1
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
mozilla
.
org
/
"
)
)
.
unwrap
(
)
;
storage
.
add_remote_tab_command
(
"
device
-
2
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example
.
com
/
"
)
)
.
unwrap
(
)
;
storage
.
add_remote_tab_command
(
"
device
-
2
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example1
.
com
/
"
)
)
.
unwrap
(
)
;
let
remote_tabs
=
storage
.
get_remote_tabs
(
)
.
unwrap
(
)
;
assert_eq
!
(
remote_tabs
.
len
(
)
2
)
;
assert_eq
!
(
remote_tabs
[
0
]
.
client_id
"
device
-
1
"
)
;
assert_eq
!
(
remote_tabs
[
0
]
.
remote_tabs
.
len
(
)
0
)
;
assert_eq
!
(
remote_tabs
[
1
]
.
client_id
"
device
-
2
"
)
;
assert_eq
!
(
remote_tabs
[
1
]
.
remote_tabs
.
len
(
)
1
)
;
assert_eq
!
(
remote_tabs
[
1
]
.
remote_tabs
[
0
]
RemoteTab
{
title
:
"
the
title
"
.
to_string
(
)
url_history
:
vec
!
[
"
https
:
/
/
mozilla
.
org
/
"
.
to_string
(
)
]
icon
:
Some
(
"
https
:
/
/
mozilla
.
org
/
icon
"
.
to_string
(
)
)
last_used
:
1711929600015000
/
/
server
time
is
ns
so
1000
bigger
than
local
.
.
.
Default
:
:
default
(
)
}
)
;
}
#
[
test
]
fn
test_remove_old_pending_closures_timed_removal
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_remove_old_pending_closures_timed_removal
"
)
;
let
now
=
Timestamp
:
:
now
(
)
;
let
older
=
now
.
checked_sub
(
Duration
:
:
from_millis
(
REMOTE_COMMAND_TTL_MS
)
)
.
unwrap
(
)
;
{
let
db
=
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
unwrap
(
)
;
db
.
execute
(
"
INSERT
INTO
tabs
(
guid
record
last_modified
)
VALUES
(
'
device
-
synced
'
'
'
:
now
)
;
"
rusqlite
:
:
named_params
!
{
"
:
now
"
:
now
}
)
.
unwrap
(
)
;
db
.
execute
(
"
INSERT
INTO
tabs
(
guid
record
last_modified
)
VALUES
(
'
device
-
not
-
synced
'
'
'
:
old
)
;
"
rusqlite
:
:
named_params
!
{
"
:
old
"
:
older
}
)
.
unwrap
(
)
;
}
storage
.
add_remote_tab_command_at
(
"
device
-
synced
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example
.
com
"
)
older
)
.
unwrap
(
)
;
storage
.
add_remote_tab_command_at
(
"
device
-
not
-
synced
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example2
.
com
"
)
now
)
.
unwrap
(
)
;
{
let
db
=
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
unwrap
(
)
;
let
before_count
:
i64
=
db
.
query_one
(
"
SELECT
COUNT
(
*
)
FROM
remote_tab_commands
"
)
.
unwrap
(
)
;
assert_eq
!
(
before_count
2
)
;
}
let
new_records
=
vec
!
[
(
TabsRecord
{
id
:
"
device
-
not
-
synced
"
.
to_string
(
)
client_name
:
"
"
.
to_string
(
)
tabs
:
vec
!
[
TabsRecordTab
{
url_history
:
vec
!
[
"
https
:
/
/
example2
.
com
"
.
to_string
(
)
]
.
.
Default
:
:
default
(
)
}
]
}
ServerTimestamp
:
:
from_millis
(
now
.
as_millis_i64
(
)
)
)
]
;
storage
.
remove_old_pending_closures
(
&
new_records
)
.
unwrap
(
)
;
let
reopen_db
=
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
unwrap
(
)
;
let
after_count
:
i64
=
reopen_db
.
query_one
(
"
SELECT
COUNT
(
*
)
FROM
remote_tab_commands
"
)
.
unwrap
(
)
;
assert_eq
!
(
after_count
1
)
;
let
remaining_device_id
:
String
=
reopen_db
.
query_one
(
"
SELECT
device_id
FROM
remote_tab_commands
"
)
.
unwrap
(
)
;
assert_eq
!
(
remaining_device_id
"
device
-
not
-
synced
"
)
;
}
#
[
test
]
fn
test_remove_old_pending_closures_no_tab_removal
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_remove_old_pending_closures_no_tab_removal
"
)
;
let
db
=
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
unwrap
(
)
;
let
now_ms
:
u64
=
Timestamp
:
:
now
(
)
.
as_millis
(
)
;
db
.
execute
(
"
INSERT
INTO
tabs
(
guid
record
last_modified
)
VALUES
(
'
device
-
recent
'
'
'
:
now
)
;
"
rusqlite
:
:
named_params
!
{
"
:
now
"
:
now_ms
}
)
.
unwrap
(
)
;
db
.
execute
(
"
INSERT
INTO
remote_tab_commands
(
device_id
command
url
time_requested
)
VALUES
(
:
device_id
:
command
:
url
:
time_requested
)
"
rusqlite
:
:
named_params
!
{
"
:
command
"
:
CommandKind
:
:
CloseTab
"
:
device_id
"
:
"
device
-
recent
"
"
:
url
"
:
"
https
:
/
/
example
.
com
"
"
:
time_requested
"
:
now_ms
}
)
.
unwrap
(
)
;
db
.
execute
(
"
INSERT
INTO
remote_tab_commands
(
device_id
command
url
time_requested
)
VALUES
(
:
device_id
:
command
:
url
:
time_requested
)
"
rusqlite
:
:
named_params
!
{
"
:
command
"
:
CommandKind
:
:
CloseTab
"
:
device_id
"
:
"
device
-
recent
"
"
:
url
"
:
"
https
:
/
/
old
-
url
.
com
"
"
:
time_requested
"
:
now_ms
}
)
.
unwrap
(
)
;
let
before_count
:
i64
=
db
.
query_row
(
"
SELECT
COUNT
(
*
)
FROM
remote_tab_commands
"
[
]
|
row
|
{
row
.
get
(
0
)
}
)
.
unwrap
(
)
;
assert_eq
!
(
before_count
2
)
;
let
new_records
=
vec
!
[
(
TabsRecord
{
id
:
"
device
-
recent
"
.
to_string
(
)
client_name
:
"
"
.
to_string
(
)
tabs
:
vec
!
[
TabsRecordTab
{
url_history
:
vec
!
[
"
https
:
/
/
example99
.
com
"
.
to_string
(
)
]
.
.
Default
:
:
default
(
)
}
TabsRecordTab
{
url_history
:
vec
!
[
"
https
:
/
/
example
.
com
"
.
to_string
(
)
]
.
.
Default
:
:
default
(
)
}
]
}
ServerTimestamp
:
:
default
(
)
)
]
;
storage
.
remove_old_pending_closures
(
&
new_records
)
.
unwrap
(
)
;
let
reopen_db
=
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
unwrap
(
)
;
let
after_count
:
i64
=
reopen_db
.
query_row
(
"
SELECT
COUNT
(
*
)
FROM
remote_tab_commands
"
[
]
|
row
|
{
row
.
get
(
0
)
}
)
.
unwrap
(
)
;
assert_eq
!
(
after_count
1
)
;
let
remaining_url
:
String
=
reopen_db
.
query_row
(
"
SELECT
url
FROM
remote_tab_commands
"
[
]
|
row
|
row
.
get
(
0
)
)
.
unwrap
(
)
;
assert_eq
!
(
remaining_url
"
https
:
/
/
example
.
com
"
)
;
}
#
[
test
]
fn
test_remove_pending_command
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_remove_pending_command
"
)
;
storage
.
open_or_create
(
)
.
unwrap
(
)
;
assert
!
(
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
is_some
(
)
)
;
storage
.
add_remote_tab_command
(
"
device
-
1
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example1
.
com
"
)
)
.
expect
(
"
should
work
"
)
;
assert_eq
!
(
storage
.
get_unsent_commands
(
)
.
unwrap
(
)
.
len
(
)
1
)
;
assert
!
(
!
storage
.
remove_remote_tab_command
(
"
no
-
devce
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example1
.
com
"
)
)
.
unwrap
(
)
)
;
assert_eq
!
(
storage
.
get_unsent_commands
(
)
.
unwrap
(
)
.
len
(
)
1
)
;
assert
!
(
!
storage
.
remove_remote_tab_command
(
"
device
-
1
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example9
.
com
"
)
)
.
unwrap
(
)
)
;
assert_eq
!
(
storage
.
get_unsent_commands
(
)
.
unwrap
(
)
.
len
(
)
1
)
;
assert
!
(
storage
.
remove_remote_tab_command
(
"
device
-
1
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example1
.
com
"
)
)
.
unwrap
(
)
)
;
assert_eq
!
(
storage
.
get_unsent_commands
(
)
.
unwrap
(
)
.
len
(
)
0
)
;
}
#
[
test
]
fn
test_sent_command
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_sent_command
"
)
;
let
command
=
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example1
.
com
"
)
;
storage
.
add_remote_tab_command
(
"
device
-
1
"
&
command
)
.
expect
(
"
should
work
"
)
;
assert_eq
!
(
storage
.
get_unsent_commands
(
)
.
unwrap
(
)
.
len
(
)
1
)
;
let
pending_command
=
PendingCommand
{
device_id
:
"
device
-
1
"
.
to_string
(
)
command
:
command
.
clone
(
)
time_requested
:
Timestamp
:
:
now
(
)
time_sent
:
None
}
;
assert
!
(
storage
.
set_pending_command_sent
(
&
pending_command
)
.
unwrap
(
)
)
;
assert_eq
!
(
storage
.
get_unsent_commands
(
)
.
unwrap
(
)
.
len
(
)
0
)
;
assert
!
(
!
storage
.
add_remote_tab_command
(
"
device
-
1
"
&
command
)
.
unwrap
(
)
)
;
assert
!
(
storage
.
remove_remote_tab_command
(
"
device
-
1
"
&
command
)
.
unwrap
(
)
)
;
assert
!
(
storage
.
add_remote_tab_command
(
"
device
-
1
"
&
command
)
.
unwrap
(
)
)
;
assert_eq
!
(
storage
.
get_unsent_commands
(
)
.
unwrap
(
)
.
len
(
)
1
)
;
}
#
[
test
]
fn
test_remove_pending_closures_only_affects_target_device
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
mut
storage
=
TabsStorage
:
:
new_with_mem_path
(
"
test_remove_pending_closures_target_device
"
)
;
let
now
=
Timestamp
:
:
now
(
)
;
let
db
=
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
unwrap
(
)
;
db
.
execute
(
"
INSERT
INTO
tabs
(
guid
record
last_modified
)
VALUES
(
'
device
-
1
'
'
'
:
now
)
;
"
rusqlite
:
:
named_params
!
{
"
:
now
"
:
now
}
)
.
unwrap
(
)
;
db
.
execute
(
"
INSERT
INTO
tabs
(
guid
record
last_modified
)
VALUES
(
'
device
-
2
'
'
'
:
now
)
;
"
rusqlite
:
:
named_params
!
{
"
:
now
"
:
now
}
)
.
unwrap
(
)
;
storage
.
add_remote_tab_command
(
"
device
-
1
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example1
.
com
"
)
)
.
unwrap
(
)
;
storage
.
add_remote_tab_command
(
"
device
-
1
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example2
.
com
"
)
)
.
unwrap
(
)
;
storage
.
add_remote_tab_command
(
"
device
-
2
"
&
RemoteCommand
:
:
close_tab
(
"
https
:
/
/
example3
.
com
"
)
)
.
unwrap
(
)
;
let
new_records
=
vec
!
[
(
TabsRecord
{
id
:
"
device
-
1
"
.
to_string
(
)
client_name
:
"
"
.
to_string
(
)
tabs
:
vec
!
[
TabsRecordTab
{
url_history
:
vec
!
[
"
https
:
/
/
example1
.
com
"
.
to_string
(
)
]
.
.
Default
:
:
default
(
)
}
]
}
ServerTimestamp
:
:
default
(
)
)
]
;
storage
.
remove_old_pending_closures
(
&
new_records
)
.
unwrap
(
)
;
let
reopen_db
=
storage
.
open_if_exists
(
)
.
unwrap
(
)
.
unwrap
(
)
;
let
remaining_commands
:
Vec
<
(
String
String
)
>
=
reopen_db
.
prepare
(
"
SELECT
device_id
url
FROM
remote_tab_commands
"
)
.
unwrap
(
)
.
query_map
(
[
]
|
row
|
{
Ok
(
(
row
.
get
:
:
<
_
String
>
(
0
)
?
row
.
get
:
:
<
_
String
>
(
1
)
?
)
)
}
)
.
unwrap
(
)
.
collect
:
:
<
rusqlite
:
:
Result
<
Vec
<
_
>
_
>
>
(
)
.
unwrap
(
)
;
assert_eq
!
(
remaining_commands
.
len
(
)
2
)
;
assert
!
(
remaining_commands
.
contains
(
&
(
"
device
-
1
"
.
to_string
(
)
"
https
:
/
/
example1
.
com
"
.
to_string
(
)
)
)
)
;
assert
!
(
remaining_commands
.
contains
(
&
(
"
device
-
2
"
.
to_string
(
)
"
https
:
/
/
example3
.
com
"
.
to_string
(
)
)
)
)
;
}
#
[
test
]
fn
test_close_connection
(
)
{
let
dir
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
db_path
=
dir
.
path
(
)
.
join
(
"
test_close_connection
.
db
"
)
;
let
mut
storage
=
TabsStorage
:
:
new
(
db_path
)
;
storage
.
open_or_create
(
)
.
unwrap
(
)
;
assert
!
(
matches
!
(
storage
.
db_connection
DbConnection
:
:
Open
(
_
)
)
)
;
storage
.
close
(
)
;
assert
!
(
matches
!
(
storage
.
db_connection
DbConnection
:
:
Closed
)
)
;
let
result
=
storage
.
open_or_create
(
)
;
assert
!
(
result
.
is_err
(
)
)
;
assert
!
(
matches
!
(
result
.
unwrap_err
(
)
Error
:
:
UnexpectedConnectionState
)
)
;
}
}
