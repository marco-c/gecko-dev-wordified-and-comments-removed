use
crate
:
:
parser
:
:
{
default_port
Context
Input
Parser
SchemeType
}
;
use
crate
:
:
{
Host
ParseError
Position
Url
}
;
use
alloc
:
:
string
:
:
String
;
use
alloc
:
:
string
:
:
ToString
;
#
[
derive
(
Copy
Clone
)
]
#
[
cfg
(
feature
=
"
expose_internals
"
)
]
pub
struct
InternalComponents
{
pub
scheme_end
:
u32
pub
username_end
:
u32
pub
host_start
:
u32
pub
host_end
:
u32
pub
port
:
Option
<
u16
>
pub
path_start
:
u32
pub
query_start
:
Option
<
u32
>
pub
fragment_start
:
Option
<
u32
>
}
#
[
cfg
(
feature
=
"
expose_internals
"
)
]
pub
fn
internal_components
(
url
:
&
Url
)
-
>
InternalComponents
{
InternalComponents
{
scheme_end
:
url
.
scheme_end
username_end
:
url
.
username_end
host_start
:
url
.
host_start
host_end
:
url
.
host_end
port
:
url
.
port
path_start
:
url
.
path_start
query_start
:
url
.
query_start
fragment_start
:
url
.
fragment_start
}
}
pub
fn
domain_to_ascii
(
domain
:
&
str
)
-
>
String
{
match
Host
:
:
parse
(
domain
)
{
Ok
(
Host
:
:
Domain
(
domain
)
)
=
>
domain
_
=
>
String
:
:
new
(
)
}
}
pub
fn
domain_to_unicode
(
domain
:
&
str
)
-
>
String
{
match
Host
:
:
parse
(
domain
)
{
Ok
(
Host
:
:
Domain
(
ref
domain
)
)
=
>
{
let
(
unicode
_errors
)
=
idna
:
:
domain_to_unicode
(
domain
)
;
unicode
}
_
=
>
String
:
:
new
(
)
}
}
pub
fn
href
(
url
:
&
Url
)
-
>
&
str
{
url
.
as_str
(
)
}
pub
fn
set_href
(
url
:
&
mut
Url
value
:
&
str
)
-
>
Result
<
(
)
ParseError
>
{
*
url
=
Url
:
:
parse
(
value
)
?
;
Ok
(
(
)
)
}
pub
fn
origin
(
url
:
&
Url
)
-
>
String
{
url
.
origin
(
)
.
ascii_serialization
(
)
}
#
[
inline
]
pub
fn
protocol
(
url
:
&
Url
)
-
>
&
str
{
&
url
.
as_str
(
)
[
.
.
url
.
scheme
(
)
.
len
(
)
+
"
:
"
.
len
(
)
]
}
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
set_protocol
(
url
:
&
mut
Url
mut
new_protocol
:
&
str
)
-
>
Result
<
(
)
(
)
>
{
if
let
Some
(
position
)
=
new_protocol
.
find
(
'
:
'
)
{
new_protocol
=
&
new_protocol
[
.
.
position
]
;
}
url
.
set_scheme
(
new_protocol
)
}
#
[
inline
]
pub
fn
username
(
url
:
&
Url
)
-
>
&
str
{
url
.
username
(
)
}
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
set_username
(
url
:
&
mut
Url
new_username
:
&
str
)
-
>
Result
<
(
)
(
)
>
{
url
.
set_username
(
new_username
)
}
#
[
inline
]
pub
fn
password
(
url
:
&
Url
)
-
>
&
str
{
url
.
password
(
)
.
unwrap_or
(
"
"
)
}
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
set_password
(
url
:
&
mut
Url
new_password
:
&
str
)
-
>
Result
<
(
)
(
)
>
{
url
.
set_password
(
if
new_password
.
is_empty
(
)
{
None
}
else
{
Some
(
new_password
)
}
)
}
#
[
inline
]
pub
fn
host
(
url
:
&
Url
)
-
>
&
str
{
&
url
[
Position
:
:
BeforeHost
.
.
Position
:
:
AfterPort
]
}
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
set_host
(
url
:
&
mut
Url
new_host
:
&
str
)
-
>
Result
<
(
)
(
)
>
{
if
url
.
cannot_be_a_base
(
)
{
return
Err
(
(
)
)
;
}
let
input
=
Input
:
:
new_no_trim
(
new_host
)
;
let
host
;
let
opt_port
;
{
let
scheme
=
url
.
scheme
(
)
;
let
scheme_type
=
SchemeType
:
:
from
(
scheme
)
;
if
scheme_type
=
=
SchemeType
:
:
File
&
&
new_host
.
is_empty
(
)
{
url
.
set_host_internal
(
Host
:
:
Domain
(
"
"
.
into
(
)
)
None
)
;
return
Ok
(
(
)
)
;
}
if
let
Ok
(
(
h
remaining
)
)
=
Parser
:
:
parse_host
(
input
scheme_type
)
{
host
=
h
;
opt_port
=
if
let
Some
(
remaining
)
=
remaining
.
split_prefix
(
'
:
'
)
{
if
remaining
.
is_empty
(
)
{
None
}
else
{
Parser
:
:
parse_port
(
remaining
|
|
default_port
(
scheme
)
Context
:
:
Setter
)
.
ok
(
)
.
map
(
|
(
port
_remaining
)
|
port
)
}
}
else
{
None
}
;
}
else
{
return
Err
(
(
)
)
;
}
}
if
host
=
=
Host
:
:
Domain
(
"
"
.
to_string
(
)
)
&
&
(
!
username
(
url
)
.
is_empty
(
)
|
|
matches
!
(
opt_port
Some
(
Some
(
_
)
)
)
|
|
url
.
port
(
)
.
is_some
(
)
)
{
return
Err
(
(
)
)
;
}
url
.
set_host_internal
(
host
opt_port
)
;
Ok
(
(
)
)
}
#
[
inline
]
pub
fn
hostname
(
url
:
&
Url
)
-
>
&
str
{
url
.
host_str
(
)
.
unwrap_or
(
"
"
)
}
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
set_hostname
(
url
:
&
mut
Url
new_hostname
:
&
str
)
-
>
Result
<
(
)
(
)
>
{
if
url
.
cannot_be_a_base
(
)
{
return
Err
(
(
)
)
;
}
let
input
=
Input
:
:
new_no_trim
(
new_hostname
)
;
let
scheme_type
=
SchemeType
:
:
from
(
url
.
scheme
(
)
)
;
if
scheme_type
=
=
SchemeType
:
:
File
&
&
new_hostname
.
is_empty
(
)
{
url
.
set_host_internal
(
Host
:
:
Domain
(
"
"
.
into
(
)
)
None
)
;
return
Ok
(
(
)
)
;
}
if
let
Ok
(
(
host
remaining
)
)
=
Parser
:
:
parse_host
(
input
scheme_type
)
{
if
remaining
.
starts_with
(
'
:
'
)
{
return
Err
(
(
)
)
;
}
;
if
let
Host
:
:
Domain
(
h
)
=
&
host
{
if
h
.
is_empty
(
)
{
if
SchemeType
:
:
from
(
url
.
scheme
(
)
)
=
=
SchemeType
:
:
SpecialNotFile
|
|
!
port
(
url
)
.
is_empty
(
)
|
|
!
url
.
username
(
)
.
is_empty
(
)
|
|
!
url
.
password
(
)
.
unwrap_or
(
"
"
)
.
is_empty
(
)
{
return
Err
(
(
)
)
;
}
}
}
url
.
set_host_internal
(
host
None
)
;
Ok
(
(
)
)
}
else
{
Err
(
(
)
)
}
}
#
[
inline
]
pub
fn
port
(
url
:
&
Url
)
-
>
&
str
{
&
url
[
Position
:
:
BeforePort
.
.
Position
:
:
AfterPort
]
}
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
set_port
(
url
:
&
mut
Url
new_port
:
&
str
)
-
>
Result
<
(
)
(
)
>
{
let
result
;
{
let
scheme
=
url
.
scheme
(
)
;
if
!
url
.
has_host
(
)
|
|
url
.
host
(
)
=
=
Some
(
Host
:
:
Domain
(
"
"
)
)
|
|
scheme
=
=
"
file
"
{
return
Err
(
(
)
)
;
}
result
=
Parser
:
:
parse_port
(
Input
:
:
new_no_trim
(
new_port
)
|
|
default_port
(
scheme
)
Context
:
:
Setter
)
}
if
let
Ok
(
(
new_port
_remaining
)
)
=
result
{
url
.
set_port_internal
(
new_port
)
;
Ok
(
(
)
)
}
else
{
Err
(
(
)
)
}
}
#
[
inline
]
pub
fn
pathname
(
url
:
&
Url
)
-
>
&
str
{
url
.
path
(
)
}
pub
fn
set_pathname
(
url
:
&
mut
Url
new_pathname
:
&
str
)
{
if
url
.
cannot_be_a_base
(
)
{
return
;
}
if
new_pathname
.
starts_with
(
'
/
'
)
|
|
(
SchemeType
:
:
from
(
url
.
scheme
(
)
)
.
is_special
(
)
&
&
new_pathname
.
starts_with
(
'
\
\
'
)
)
{
url
.
set_path
(
new_pathname
)
}
else
if
SchemeType
:
:
from
(
url
.
scheme
(
)
)
.
is_special
(
)
|
|
!
new_pathname
.
is_empty
(
)
|
|
!
url
.
has_host
(
)
{
let
mut
path_to_set
=
String
:
:
from
(
"
/
"
)
;
path_to_set
.
push_str
(
new_pathname
)
;
url
.
set_path
(
&
path_to_set
)
}
else
{
url
.
set_path
(
new_pathname
)
}
}
pub
fn
search
(
url
:
&
Url
)
-
>
&
str
{
trim
(
&
url
[
Position
:
:
AfterPath
.
.
Position
:
:
AfterQuery
]
)
}
pub
fn
set_search
(
url
:
&
mut
Url
new_search
:
&
str
)
{
url
.
set_query
(
match
new_search
{
"
"
=
>
None
_
if
new_search
.
starts_with
(
'
?
'
)
=
>
Some
(
&
new_search
[
1
.
.
]
)
_
=
>
Some
(
new_search
)
}
)
}
pub
fn
hash
(
url
:
&
Url
)
-
>
&
str
{
trim
(
&
url
[
Position
:
:
AfterQuery
.
.
]
)
}
pub
fn
set_hash
(
url
:
&
mut
Url
new_hash
:
&
str
)
{
url
.
set_fragment
(
match
new_hash
{
"
"
=
>
None
_
if
new_hash
.
starts_with
(
'
#
'
)
=
>
Some
(
&
new_hash
[
1
.
.
]
)
_
=
>
Some
(
new_hash
)
}
)
}
fn
trim
(
s
:
&
str
)
-
>
&
str
{
if
s
.
len
(
)
=
=
1
{
"
"
}
else
{
s
}
}
