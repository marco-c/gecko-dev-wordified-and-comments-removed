#
!
[
no_std
]
#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
url
/
2
.
5
.
7
"
)
]
#
!
[
cfg_attr
(
feature
=
"
debugger_visualizer
"
debugger_visualizer
(
natvis_file
=
"
.
.
/
.
.
/
debug_metadata
/
url
.
natvis
"
)
)
]
pub
use
form_urlencoded
;
#
[
cfg
(
feature
=
"
std
"
)
]
extern
crate
std
;
#
[
macro_use
]
extern
crate
alloc
;
#
[
cfg
(
feature
=
"
serde
"
)
]
extern
crate
serde
;
use
crate
:
:
host
:
:
HostInternal
;
use
crate
:
:
net
:
:
IpAddr
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg
(
any
(
unix
windows
target_os
=
"
redox
"
target_os
=
"
wasi
"
target_os
=
"
hermit
"
)
)
]
use
crate
:
:
net
:
:
{
SocketAddr
ToSocketAddrs
}
;
use
crate
:
:
parser
:
:
{
to_u32
Context
Parser
SchemeType
USERINFO
}
;
use
alloc
:
:
borrow
:
:
Cow
;
use
alloc
:
:
borrow
:
:
ToOwned
;
use
alloc
:
:
str
;
use
alloc
:
:
string
:
:
{
String
ToString
}
;
use
core
:
:
borrow
:
:
Borrow
;
use
core
:
:
convert
:
:
TryFrom
;
use
core
:
:
fmt
:
:
Write
;
use
core
:
:
ops
:
:
{
Range
RangeFrom
RangeTo
}
;
use
core
:
:
{
cmp
fmt
hash
mem
}
;
use
percent_encoding
:
:
utf8_percent_encode
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg
(
any
(
unix
windows
target_os
=
"
redox
"
target_os
=
"
wasi
"
target_os
=
"
hermit
"
)
)
]
use
std
:
:
io
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
pub
(
crate
)
mod
net
{
pub
use
std
:
:
net
:
:
*
;
}
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
pub
(
crate
)
mod
net
{
pub
use
core
:
:
net
:
:
*
;
}
pub
use
crate
:
:
host
:
:
Host
;
pub
use
crate
:
:
origin
:
:
{
OpaqueOrigin
Origin
}
;
pub
use
crate
:
:
parser
:
:
{
ParseError
SyntaxViolation
}
;
pub
use
crate
:
:
path_segments
:
:
PathSegmentsMut
;
pub
use
crate
:
:
slicing
:
:
Position
;
pub
use
form_urlencoded
:
:
EncodingOverride
;
mod
host
;
mod
origin
;
mod
parser
;
mod
path_segments
;
mod
slicing
;
#
[
doc
(
hidden
)
]
pub
mod
quirks
;
#
[
derive
(
Clone
)
]
pub
struct
Url
{
serialization
:
String
scheme_end
:
u32
username_end
:
u32
host_start
:
u32
host_end
:
u32
host
:
HostInternal
port
:
Option
<
u16
>
path_start
:
u32
query_start
:
Option
<
u32
>
fragment_start
:
Option
<
u32
>
}
#
[
derive
(
Copy
Clone
)
]
#
[
must_use
]
pub
struct
ParseOptions
<
'
a
>
{
base_url
:
Option
<
&
'
a
Url
>
encoding_override
:
EncodingOverride
<
'
a
>
violation_fn
:
Option
<
&
'
a
dyn
Fn
(
SyntaxViolation
)
>
}
impl
<
'
a
>
ParseOptions
<
'
a
>
{
pub
fn
base_url
(
mut
self
new
:
Option
<
&
'
a
Url
>
)
-
>
Self
{
self
.
base_url
=
new
;
self
}
pub
fn
encoding_override
(
mut
self
new
:
EncodingOverride
<
'
a
>
)
-
>
Self
{
self
.
encoding_override
=
new
;
self
}
pub
fn
syntax_violation_callback
(
mut
self
new
:
Option
<
&
'
a
dyn
Fn
(
SyntaxViolation
)
>
)
-
>
Self
{
self
.
violation_fn
=
new
;
self
}
pub
fn
parse
(
self
input
:
&
str
)
-
>
Result
<
Url
crate
:
:
ParseError
>
{
Parser
{
serialization
:
String
:
:
with_capacity
(
input
.
len
(
)
)
base_url
:
self
.
base_url
query_encoding_override
:
self
.
encoding_override
violation_fn
:
self
.
violation_fn
context
:
Context
:
:
UrlParser
}
.
parse_url
(
input
)
}
}
impl
Url
{
#
[
inline
]
pub
fn
parse
(
input
:
&
str
)
-
>
Result
<
Self
crate
:
:
ParseError
>
{
Self
:
:
options
(
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
parse_with_params
<
I
K
V
>
(
input
:
&
str
iter
:
I
)
-
>
Result
<
Self
crate
:
:
ParseError
>
where
I
:
IntoIterator
I
:
:
Item
:
Borrow
<
(
K
V
)
>
K
:
AsRef
<
str
>
V
:
AsRef
<
str
>
{
let
mut
url
=
Self
:
:
options
(
)
.
parse
(
input
)
;
if
let
Ok
(
ref
mut
url
)
=
url
{
url
.
query_pairs_mut
(
)
.
extend_pairs
(
iter
)
;
}
url
}
fn
strip_trailing_spaces_from_opaque_path
(
&
mut
self
)
{
if
!
self
.
cannot_be_a_base
(
)
{
return
;
}
if
self
.
fragment_start
.
is_some
(
)
{
return
;
}
if
self
.
query_start
.
is_some
(
)
{
return
;
}
let
trailing_space_count
=
self
.
serialization
.
chars
(
)
.
rev
(
)
.
take_while
(
|
c
|
*
c
=
=
'
'
)
.
count
(
)
;
let
start
=
self
.
serialization
.
len
(
)
-
trailing_space_count
;
self
.
serialization
.
truncate
(
start
)
;
}
#
[
inline
]
pub
fn
join
(
&
self
input
:
&
str
)
-
>
Result
<
Self
crate
:
:
ParseError
>
{
Self
:
:
options
(
)
.
base_url
(
Some
(
self
)
)
.
parse
(
input
)
}
pub
fn
make_relative
(
&
self
url
:
&
Self
)
-
>
Option
<
String
>
{
if
self
.
cannot_be_a_base
(
)
{
return
None
;
}
if
self
.
scheme
(
)
!
=
url
.
scheme
(
)
|
|
self
.
host
(
)
!
=
url
.
host
(
)
|
|
self
.
port
(
)
!
=
url
.
port
(
)
{
return
None
;
}
let
mut
relative
=
String
:
:
new
(
)
;
fn
extract_path_filename
(
s
:
&
str
)
-
>
(
&
str
&
str
)
{
let
last_slash_idx
=
s
.
rfind
(
'
/
'
)
.
unwrap_or
(
0
)
;
let
(
path
filename
)
=
s
.
split_at
(
last_slash_idx
)
;
if
filename
.
is_empty
(
)
{
(
path
"
"
)
}
else
{
(
path
&
filename
[
1
.
.
]
)
}
}
let
(
base_path
base_filename
)
=
extract_path_filename
(
self
.
path
(
)
)
;
let
(
url_path
url_filename
)
=
extract_path_filename
(
url
.
path
(
)
)
;
let
mut
base_path
=
base_path
.
split
(
'
/
'
)
.
peekable
(
)
;
let
mut
url_path
=
url_path
.
split
(
'
/
'
)
.
peekable
(
)
;
while
base_path
.
peek
(
)
.
is_some
(
)
&
&
base_path
.
peek
(
)
=
=
url_path
.
peek
(
)
{
base_path
.
next
(
)
;
url_path
.
next
(
)
;
}
for
base_path_segment
in
base_path
{
if
base_path_segment
.
is_empty
(
)
{
break
;
}
if
!
relative
.
is_empty
(
)
{
relative
.
push
(
'
/
'
)
;
}
relative
.
push_str
(
"
.
.
"
)
;
}
for
url_path_segment
in
url_path
{
if
!
relative
.
is_empty
(
)
{
relative
.
push
(
'
/
'
)
;
}
relative
.
push_str
(
url_path_segment
)
;
}
if
!
relative
.
is_empty
(
)
|
|
base_filename
!
=
url_filename
{
if
url_filename
.
is_empty
(
)
{
relative
.
push
(
'
/
'
)
;
}
else
{
if
!
relative
.
is_empty
(
)
{
relative
.
push
(
'
/
'
)
;
}
relative
.
push_str
(
url_filename
)
;
}
}
if
let
Some
(
query
)
=
url
.
query
(
)
{
relative
.
push
(
'
?
'
)
;
relative
.
push_str
(
query
)
;
}
if
let
Some
(
fragment
)
=
url
.
fragment
(
)
{
relative
.
push
(
'
#
'
)
;
relative
.
push_str
(
fragment
)
;
}
Some
(
relative
)
}
pub
fn
options
<
'
a
>
(
)
-
>
ParseOptions
<
'
a
>
{
ParseOptions
{
base_url
:
None
encoding_override
:
None
violation_fn
:
None
}
}
#
[
inline
]
pub
fn
as_str
(
&
self
)
-
>
&
str
{
&
self
.
serialization
}
#
[
inline
]
#
[
deprecated
(
since
=
"
2
.
3
.
0
"
note
=
"
use
Into
<
String
>
"
)
]
pub
fn
into_string
(
self
)
-
>
String
{
self
.
into
(
)
}
#
[
doc
(
hidden
)
]
pub
fn
check_invariants
(
&
self
)
-
>
Result
<
(
)
String
>
{
macro_rules
!
assert
{
(
x
:
expr
)
=
>
{
if
!
x
{
return
Err
(
format
!
(
"
!
(
{
}
)
for
URL
{
:
?
}
"
stringify
!
(
x
)
self
.
serialization
)
)
;
}
}
;
}
macro_rules
!
assert_eq
{
(
a
:
expr
b
:
expr
)
=
>
{
{
let
a
=
a
;
let
b
=
b
;
if
a
!
=
b
{
return
Err
(
format
!
(
"
{
:
?
}
!
=
{
:
?
}
(
{
}
!
=
{
}
)
for
URL
{
:
?
}
"
a
b
stringify
!
(
a
)
stringify
!
(
b
)
self
.
serialization
)
)
}
}
}
}
assert
!
(
self
.
scheme_end
>
=
1
)
;
assert
!
(
self
.
byte_at
(
0
)
.
is_ascii_alphabetic
(
)
)
;
assert
!
(
self
.
slice
(
1
.
.
self
.
scheme_end
)
.
chars
(
)
.
all
(
|
c
|
matches
!
(
c
'
a
'
.
.
=
'
z
'
|
'
A
'
.
.
=
'
Z
'
|
'
0
'
.
.
=
'
9
'
|
'
+
'
|
'
-
'
|
'
.
'
)
)
)
;
assert_eq
!
(
self
.
byte_at
(
self
.
scheme_end
)
b
'
:
'
)
;
if
self
.
slice
(
self
.
scheme_end
+
1
.
.
)
.
starts_with
(
"
/
/
"
)
{
if
self
.
username_end
!
=
self
.
serialization
.
len
(
)
as
u32
{
match
self
.
byte_at
(
self
.
username_end
)
{
b
'
:
'
=
>
{
assert
!
(
self
.
host_start
>
=
self
.
username_end
+
2
)
;
assert_eq
!
(
self
.
byte_at
(
self
.
host_start
-
1
)
b
'
'
)
;
}
b
'
'
=
>
assert
!
(
self
.
host_start
=
=
self
.
username_end
+
1
)
_
=
>
assert_eq
!
(
self
.
username_end
self
.
scheme_end
+
3
)
}
}
assert
!
(
self
.
host_start
>
=
self
.
username_end
)
;
assert
!
(
self
.
host_end
>
=
self
.
host_start
)
;
let
host_str
=
self
.
slice
(
self
.
host_start
.
.
self
.
host_end
)
;
match
self
.
host
{
HostInternal
:
:
None
=
>
assert_eq
!
(
host_str
"
"
)
HostInternal
:
:
Ipv4
(
address
)
=
>
assert_eq
!
(
host_str
address
.
to_string
(
)
)
HostInternal
:
:
Ipv6
(
address
)
=
>
{
let
h
:
Host
<
String
>
=
Host
:
:
Ipv6
(
address
)
;
assert_eq
!
(
host_str
h
.
to_string
(
)
)
}
HostInternal
:
:
Domain
=
>
{
if
SchemeType
:
:
from
(
self
.
scheme
(
)
)
.
is_special
(
)
{
assert
!
(
!
host_str
.
is_empty
(
)
)
}
}
}
if
self
.
path_start
=
=
self
.
host_end
{
assert_eq
!
(
self
.
port
None
)
;
}
else
{
assert_eq
!
(
self
.
byte_at
(
self
.
host_end
)
b
'
:
'
)
;
let
port_str
=
self
.
slice
(
self
.
host_end
+
1
.
.
self
.
path_start
)
;
assert_eq
!
(
self
.
port
Some
(
port_str
.
parse
:
:
<
u16
>
(
)
.
expect
(
"
Couldn
'
t
parse
port
?
"
)
)
)
;
}
assert
!
(
self
.
path_start
as
usize
=
=
self
.
serialization
.
len
(
)
|
|
matches
!
(
self
.
byte_at
(
self
.
path_start
)
b
'
/
'
|
b
'
#
'
|
b
'
?
'
)
)
;
}
else
{
assert_eq
!
(
self
.
username_end
self
.
scheme_end
+
1
)
;
assert_eq
!
(
self
.
host_start
self
.
scheme_end
+
1
)
;
assert_eq
!
(
self
.
host_end
self
.
scheme_end
+
1
)
;
assert_eq
!
(
self
.
host
HostInternal
:
:
None
)
;
assert_eq
!
(
self
.
port
None
)
;
if
self
.
path
(
)
.
starts_with
(
"
/
/
"
)
{
assert_eq
!
(
self
.
byte_at
(
self
.
scheme_end
+
1
)
b
'
/
'
)
;
assert_eq
!
(
self
.
byte_at
(
self
.
scheme_end
+
2
)
b
'
.
'
)
;
assert_eq
!
(
self
.
path_start
self
.
scheme_end
+
3
)
;
}
else
{
assert_eq
!
(
self
.
path_start
self
.
scheme_end
+
1
)
;
}
}
if
let
Some
(
start
)
=
self
.
query_start
{
assert
!
(
start
>
=
self
.
path_start
)
;
assert_eq
!
(
self
.
byte_at
(
start
)
b
'
?
'
)
;
}
if
let
Some
(
start
)
=
self
.
fragment_start
{
assert
!
(
start
>
=
self
.
path_start
)
;
assert_eq
!
(
self
.
byte_at
(
start
)
b
'
#
'
)
;
}
if
let
(
Some
(
query_start
)
Some
(
fragment_start
)
)
=
(
self
.
query_start
self
.
fragment_start
)
{
assert
!
(
fragment_start
>
query_start
)
;
}
let
other
=
Self
:
:
parse
(
self
.
as_str
(
)
)
.
expect
(
"
Failed
to
parse
myself
?
"
)
;
assert_eq
!
(
&
self
.
serialization
&
other
.
serialization
)
;
assert_eq
!
(
self
.
scheme_end
other
.
scheme_end
)
;
assert_eq
!
(
self
.
username_end
other
.
username_end
)
;
assert_eq
!
(
self
.
host_start
other
.
host_start
)
;
assert_eq
!
(
self
.
host_end
other
.
host_end
)
;
assert
!
(
self
.
host
=
=
other
.
host
|
|
/
/
XXX
No
host
round
-
trips
to
empty
host
.
/
/
See
https
:
/
/
github
.
com
/
whatwg
/
url
/
issues
/
79
(
self
.
host_str
(
)
other
.
host_str
(
)
)
=
=
(
None
Some
(
"
"
)
)
)
;
assert_eq
!
(
self
.
port
other
.
port
)
;
assert_eq
!
(
self
.
path_start
other
.
path_start
)
;
assert_eq
!
(
self
.
query_start
other
.
query_start
)
;
assert_eq
!
(
self
.
fragment_start
other
.
fragment_start
)
;
Ok
(
(
)
)
}
#
[
inline
]
pub
fn
origin
(
&
self
)
-
>
Origin
{
origin
:
:
url_origin
(
self
)
}
#
[
inline
]
pub
fn
scheme
(
&
self
)
-
>
&
str
{
self
.
slice
(
.
.
self
.
scheme_end
)
}
pub
fn
is_special
(
&
self
)
-
>
bool
{
let
scheme_type
=
SchemeType
:
:
from
(
self
.
scheme
(
)
)
;
scheme_type
.
is_special
(
)
}
#
[
inline
]
pub
fn
has_authority
(
&
self
)
-
>
bool
{
debug_assert
!
(
self
.
byte_at
(
self
.
scheme_end
)
=
=
b
'
:
'
)
;
self
.
slice
(
self
.
scheme_end
.
.
)
.
starts_with
(
"
:
/
/
"
)
}
pub
fn
authority
(
&
self
)
-
>
&
str
{
let
scheme_separator_len
=
"
:
/
/
"
.
len
(
)
as
u32
;
if
self
.
has_authority
(
)
&
&
self
.
path_start
>
self
.
scheme_end
+
scheme_separator_len
{
self
.
slice
(
self
.
scheme_end
+
scheme_separator_len
.
.
self
.
path_start
)
}
else
{
"
"
}
}
#
[
inline
]
pub
fn
cannot_be_a_base
(
&
self
)
-
>
bool
{
!
self
.
slice
(
self
.
scheme_end
+
1
.
.
)
.
starts_with
(
'
/
'
)
}
pub
fn
username
(
&
self
)
-
>
&
str
{
let
scheme_separator_len
=
"
:
/
/
"
.
len
(
)
as
u32
;
if
self
.
has_authority
(
)
&
&
self
.
username_end
>
self
.
scheme_end
+
scheme_separator_len
{
self
.
slice
(
self
.
scheme_end
+
scheme_separator_len
.
.
self
.
username_end
)
}
else
{
"
"
}
}
pub
fn
password
(
&
self
)
-
>
Option
<
&
str
>
{
if
self
.
has_authority
(
)
&
&
self
.
username_end
!
=
self
.
serialization
.
len
(
)
as
u32
&
&
self
.
byte_at
(
self
.
username_end
)
=
=
b
'
:
'
{
debug_assert
!
(
self
.
byte_at
(
self
.
host_start
-
1
)
=
=
b
'
'
)
;
Some
(
self
.
slice
(
self
.
username_end
+
1
.
.
self
.
host_start
-
1
)
)
}
else
{
None
}
}
pub
fn
has_host
(
&
self
)
-
>
bool
{
!
matches
!
(
self
.
host
HostInternal
:
:
None
)
}
pub
fn
host_str
(
&
self
)
-
>
Option
<
&
str
>
{
if
self
.
has_host
(
)
{
Some
(
self
.
slice
(
self
.
host_start
.
.
self
.
host_end
)
)
}
else
{
None
}
}
pub
fn
host
(
&
self
)
-
>
Option
<
Host
<
&
str
>
>
{
match
self
.
host
{
HostInternal
:
:
None
=
>
None
HostInternal
:
:
Domain
=
>
Some
(
Host
:
:
Domain
(
self
.
slice
(
self
.
host_start
.
.
self
.
host_end
)
)
)
HostInternal
:
:
Ipv4
(
address
)
=
>
Some
(
Host
:
:
Ipv4
(
address
)
)
HostInternal
:
:
Ipv6
(
address
)
=
>
Some
(
Host
:
:
Ipv6
(
address
)
)
}
}
pub
fn
domain
(
&
self
)
-
>
Option
<
&
str
>
{
match
self
.
host
{
HostInternal
:
:
Domain
=
>
Some
(
self
.
slice
(
self
.
host_start
.
.
self
.
host_end
)
)
_
=
>
None
}
}
#
[
inline
]
pub
fn
port
(
&
self
)
-
>
Option
<
u16
>
{
self
.
port
}
#
[
inline
]
pub
fn
port_or_known_default
(
&
self
)
-
>
Option
<
u16
>
{
self
.
port
.
or_else
(
|
|
parser
:
:
default_port
(
self
.
scheme
(
)
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg
(
any
(
unix
windows
target_os
=
"
redox
"
target_os
=
"
wasi
"
target_os
=
"
hermit
"
)
)
]
pub
fn
socket_addrs
(
&
self
default_port_number
:
impl
Fn
(
)
-
>
Option
<
u16
>
)
-
>
io
:
:
Result
<
alloc
:
:
vec
:
:
Vec
<
SocketAddr
>
>
{
fn
io_result
<
T
>
(
opt
:
Option
<
T
>
message
:
&
str
)
-
>
io
:
:
Result
<
T
>
{
opt
.
ok_or_else
(
|
|
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidData
message
)
)
}
let
host
=
io_result
(
self
.
host
(
)
"
No
host
name
in
the
URL
"
)
?
;
let
port
=
io_result
(
self
.
port_or_known_default
(
)
.
or_else
(
default_port_number
)
"
No
port
number
in
the
URL
"
)
?
;
Ok
(
match
host
{
Host
:
:
Domain
(
domain
)
=
>
(
domain
port
)
.
to_socket_addrs
(
)
?
.
collect
(
)
Host
:
:
Ipv4
(
ip
)
=
>
vec
!
[
(
ip
port
)
.
into
(
)
]
Host
:
:
Ipv6
(
ip
)
=
>
vec
!
[
(
ip
port
)
.
into
(
)
]
}
)
}
pub
fn
path
(
&
self
)
-
>
&
str
{
match
(
self
.
query_start
self
.
fragment_start
)
{
(
None
None
)
=
>
self
.
slice
(
self
.
path_start
.
.
)
(
Some
(
next_component_start
)
_
)
|
(
None
Some
(
next_component_start
)
)
=
>
{
self
.
slice
(
self
.
path_start
.
.
next_component_start
)
}
}
}
pub
fn
path_segments
(
&
self
)
-
>
Option
<
str
:
:
Split
<
'
_
char
>
>
{
let
path
=
self
.
path
(
)
;
path
.
strip_prefix
(
'
/
'
)
.
map
(
|
remainder
|
remainder
.
split
(
'
/
'
)
)
}
pub
fn
query
(
&
self
)
-
>
Option
<
&
str
>
{
match
(
self
.
query_start
self
.
fragment_start
)
{
(
None
_
)
=
>
None
(
Some
(
query_start
)
None
)
=
>
{
debug_assert
!
(
self
.
byte_at
(
query_start
)
=
=
b
'
?
'
)
;
Some
(
self
.
slice
(
query_start
+
1
.
.
)
)
}
(
Some
(
query_start
)
Some
(
fragment_start
)
)
=
>
{
debug_assert
!
(
self
.
byte_at
(
query_start
)
=
=
b
'
?
'
)
;
Some
(
self
.
slice
(
query_start
+
1
.
.
fragment_start
)
)
}
}
}
#
[
inline
]
pub
fn
query_pairs
(
&
self
)
-
>
form_urlencoded
:
:
Parse
<
'
_
>
{
form_urlencoded
:
:
parse
(
self
.
query
(
)
.
unwrap_or
(
"
"
)
.
as_bytes
(
)
)
}
pub
fn
fragment
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
fragment_start
.
map
(
|
start
|
{
debug_assert
!
(
self
.
byte_at
(
start
)
=
=
b
'
#
'
)
;
self
.
slice
(
start
+
1
.
.
)
}
)
}
fn
mutate
<
F
:
FnOnce
(
&
mut
Parser
<
'
_
>
)
-
>
R
R
>
(
&
mut
self
f
:
F
)
-
>
R
{
let
mut
parser
=
Parser
:
:
for_setter
(
mem
:
:
take
(
&
mut
self
.
serialization
)
)
;
let
result
=
f
(
&
mut
parser
)
;
self
.
serialization
=
parser
.
serialization
;
result
}
pub
fn
set_fragment
(
&
mut
self
fragment
:
Option
<
&
str
>
)
{
if
let
Some
(
start
)
=
self
.
fragment_start
{
debug_assert
!
(
self
.
byte_at
(
start
)
=
=
b
'
#
'
)
;
self
.
serialization
.
truncate
(
start
as
usize
)
;
}
if
let
Some
(
input
)
=
fragment
{
self
.
fragment_start
=
Some
(
to_u32
(
self
.
serialization
.
len
(
)
)
.
unwrap
(
)
)
;
self
.
serialization
.
push
(
'
#
'
)
;
self
.
mutate
(
|
parser
|
parser
.
parse_fragment
(
parser
:
:
Input
:
:
new_no_trim
(
input
)
)
)
}
else
{
self
.
fragment_start
=
None
;
self
.
strip_trailing_spaces_from_opaque_path
(
)
;
}
}
fn
take_fragment
(
&
mut
self
)
-
>
Option
<
String
>
{
self
.
fragment_start
.
take
(
)
.
map
(
|
start
|
{
debug_assert
!
(
self
.
byte_at
(
start
)
=
=
b
'
#
'
)
;
let
fragment
=
self
.
slice
(
start
+
1
.
.
)
.
to_owned
(
)
;
self
.
serialization
.
truncate
(
start
as
usize
)
;
fragment
}
)
}
fn
restore_already_parsed_fragment
(
&
mut
self
fragment
:
Option
<
String
>
)
{
if
let
Some
(
ref
fragment
)
=
fragment
{
assert
!
(
self
.
fragment_start
.
is_none
(
)
)
;
self
.
fragment_start
=
Some
(
to_u32
(
self
.
serialization
.
len
(
)
)
.
unwrap
(
)
)
;
self
.
serialization
.
push
(
'
#
'
)
;
self
.
serialization
.
push_str
(
fragment
)
;
}
}
pub
fn
set_query
(
&
mut
self
query
:
Option
<
&
str
>
)
{
let
fragment
=
self
.
take_fragment
(
)
;
if
let
Some
(
start
)
=
self
.
query_start
.
take
(
)
{
debug_assert
!
(
self
.
byte_at
(
start
)
=
=
b
'
?
'
)
;
self
.
serialization
.
truncate
(
start
as
usize
)
;
}
if
let
Some
(
input
)
=
query
{
self
.
query_start
=
Some
(
to_u32
(
self
.
serialization
.
len
(
)
)
.
unwrap
(
)
)
;
self
.
serialization
.
push
(
'
?
'
)
;
let
scheme_type
=
SchemeType
:
:
from
(
self
.
scheme
(
)
)
;
let
scheme_end
=
self
.
scheme_end
;
self
.
mutate
(
|
parser
|
{
let
vfn
=
parser
.
violation_fn
;
parser
.
parse_query
(
scheme_type
scheme_end
parser
:
:
Input
:
:
new_trim_tab_and_newlines
(
input
vfn
)
)
}
)
;
}
else
{
self
.
query_start
=
None
;
if
fragment
.
is_none
(
)
{
self
.
strip_trailing_spaces_from_opaque_path
(
)
;
}
}
self
.
restore_already_parsed_fragment
(
fragment
)
;
}
pub
fn
query_pairs_mut
(
&
mut
self
)
-
>
form_urlencoded
:
:
Serializer
<
'
_
UrlQuery
<
'
_
>
>
{
let
fragment
=
self
.
take_fragment
(
)
;
let
query_start
;
if
let
Some
(
start
)
=
self
.
query_start
{
debug_assert
!
(
self
.
byte_at
(
start
)
=
=
b
'
?
'
)
;
query_start
=
start
as
usize
;
}
else
{
query_start
=
self
.
serialization
.
len
(
)
;
self
.
query_start
=
Some
(
to_u32
(
query_start
)
.
unwrap
(
)
)
;
self
.
serialization
.
push
(
'
?
'
)
;
}
let
query
=
UrlQuery
{
url
:
Some
(
self
)
fragment
}
;
form_urlencoded
:
:
Serializer
:
:
for_suffix
(
query
query_start
+
"
?
"
.
len
(
)
)
}
fn
take_after_path
(
&
mut
self
)
-
>
String
{
match
(
self
.
query_start
self
.
fragment_start
)
{
(
Some
(
i
)
_
)
|
(
None
Some
(
i
)
)
=
>
{
let
after_path
=
self
.
slice
(
i
.
.
)
.
to_owned
(
)
;
self
.
serialization
.
truncate
(
i
as
usize
)
;
after_path
}
(
None
None
)
=
>
String
:
:
new
(
)
}
}
pub
fn
set_path
(
&
mut
self
mut
path
:
&
str
)
{
let
after_path
=
self
.
take_after_path
(
)
;
let
old_after_path_pos
=
to_u32
(
self
.
serialization
.
len
(
)
)
.
unwrap
(
)
;
let
cannot_be_a_base
=
self
.
cannot_be_a_base
(
)
;
let
scheme_type
=
SchemeType
:
:
from
(
self
.
scheme
(
)
)
;
self
.
serialization
.
truncate
(
self
.
path_start
as
usize
)
;
self
.
mutate
(
|
parser
|
{
if
cannot_be_a_base
{
if
path
.
starts_with
(
'
/
'
)
{
parser
.
serialization
.
push_str
(
"
%
2F
"
)
;
path
=
&
path
[
1
.
.
]
;
}
parser
.
parse_cannot_be_a_base_path
(
parser
:
:
Input
:
:
new_no_trim
(
path
)
)
;
}
else
{
let
mut
has_host
=
true
;
parser
.
parse_path_start
(
scheme_type
&
mut
has_host
parser
:
:
Input
:
:
new_no_trim
(
path
)
)
;
}
}
)
;
self
.
restore_after_path
(
old_after_path_pos
&
after_path
)
;
}
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
path_segments_mut
(
&
mut
self
)
-
>
Result
<
PathSegmentsMut
<
'
_
>
(
)
>
{
if
self
.
cannot_be_a_base
(
)
{
Err
(
(
)
)
}
else
{
Ok
(
path_segments
:
:
new
(
self
)
)
}
}
fn
restore_after_path
(
&
mut
self
old_after_path_position
:
u32
after_path
:
&
str
)
{
let
new_after_path_position
=
to_u32
(
self
.
serialization
.
len
(
)
)
.
unwrap
(
)
;
let
adjust
=
|
index
:
&
mut
u32
|
{
*
index
-
=
old_after_path_position
;
*
index
+
=
new_after_path_position
;
}
;
if
let
Some
(
ref
mut
index
)
=
self
.
query_start
{
adjust
(
index
)
}
if
let
Some
(
ref
mut
index
)
=
self
.
fragment_start
{
adjust
(
index
)
}
self
.
serialization
.
push_str
(
after_path
)
}
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
set_port
(
&
mut
self
mut
port
:
Option
<
u16
>
)
-
>
Result
<
(
)
(
)
>
{
if
!
self
.
has_host
(
)
|
|
self
.
host
(
)
=
=
Some
(
Host
:
:
Domain
(
"
"
)
)
|
|
self
.
scheme
(
)
=
=
"
file
"
{
return
Err
(
(
)
)
;
}
if
port
.
is_some
(
)
&
&
port
=
=
parser
:
:
default_port
(
self
.
scheme
(
)
)
{
port
=
None
}
self
.
set_port_internal
(
port
)
;
Ok
(
(
)
)
}
fn
set_port_internal
(
&
mut
self
port
:
Option
<
u16
>
)
{
match
(
self
.
port
port
)
{
(
None
None
)
=
>
{
}
(
Some
(
_
)
None
)
=
>
{
self
.
serialization
.
drain
(
self
.
host_end
as
usize
.
.
self
.
path_start
as
usize
)
;
let
offset
=
self
.
path_start
-
self
.
host_end
;
self
.
path_start
=
self
.
host_end
;
if
let
Some
(
ref
mut
index
)
=
self
.
query_start
{
*
index
-
=
offset
}
if
let
Some
(
ref
mut
index
)
=
self
.
fragment_start
{
*
index
-
=
offset
}
}
(
Some
(
old
)
Some
(
new
)
)
if
old
=
=
new
=
>
{
}
(
_
Some
(
new
)
)
=
>
{
let
path_and_after
=
self
.
slice
(
self
.
path_start
.
.
)
.
to_owned
(
)
;
self
.
serialization
.
truncate
(
self
.
host_end
as
usize
)
;
write
!
(
&
mut
self
.
serialization
"
:
{
new
}
"
)
.
unwrap
(
)
;
let
old_path_start
=
self
.
path_start
;
let
new_path_start
=
to_u32
(
self
.
serialization
.
len
(
)
)
.
unwrap
(
)
;
self
.
path_start
=
new_path_start
;
let
adjust
=
|
index
:
&
mut
u32
|
{
*
index
-
=
old_path_start
;
*
index
+
=
new_path_start
;
}
;
if
let
Some
(
ref
mut
index
)
=
self
.
query_start
{
adjust
(
index
)
}
if
let
Some
(
ref
mut
index
)
=
self
.
fragment_start
{
adjust
(
index
)
}
self
.
serialization
.
push_str
(
&
path_and_after
)
;
}
}
self
.
port
=
port
;
}
pub
fn
set_host
(
&
mut
self
host
:
Option
<
&
str
>
)
-
>
Result
<
(
)
ParseError
>
{
if
self
.
cannot_be_a_base
(
)
{
return
Err
(
ParseError
:
:
SetHostOnCannotBeABaseUrl
)
;
}
let
scheme_type
=
SchemeType
:
:
from
(
self
.
scheme
(
)
)
;
if
let
Some
(
host
)
=
host
{
if
host
.
is_empty
(
)
&
&
scheme_type
.
is_special
(
)
&
&
!
scheme_type
.
is_file
(
)
{
return
Err
(
ParseError
:
:
EmptyHost
)
;
}
let
mut
host_substr
=
host
;
if
!
host
.
starts_with
(
'
[
'
)
|
|
!
host
.
ends_with
(
'
]
'
)
{
match
host
.
find
(
'
:
'
)
{
Some
(
0
)
=
>
{
return
Err
(
ParseError
:
:
InvalidDomainCharacter
)
;
}
Some
(
colon_index
)
=
>
{
host_substr
=
&
host
[
.
.
colon_index
]
;
}
None
=
>
{
}
}
}
if
SchemeType
:
:
from
(
self
.
scheme
(
)
)
.
is_special
(
)
{
self
.
set_host_internal
(
Host
:
:
parse_cow
(
host_substr
.
into
(
)
)
?
None
)
;
}
else
{
self
.
set_host_internal
(
Host
:
:
parse_opaque_cow
(
host_substr
.
into
(
)
)
?
None
)
;
}
}
else
if
self
.
has_host
(
)
{
if
scheme_type
.
is_special
(
)
&
&
!
scheme_type
.
is_file
(
)
{
return
Err
(
ParseError
:
:
EmptyHost
)
;
}
else
if
self
.
serialization
.
len
(
)
=
=
self
.
path_start
as
usize
{
self
.
serialization
.
push
(
'
/
'
)
;
}
debug_assert
!
(
self
.
byte_at
(
self
.
scheme_end
)
=
=
b
'
:
'
)
;
debug_assert
!
(
self
.
byte_at
(
self
.
path_start
)
=
=
b
'
/
'
)
;
let
new_path_start
=
if
scheme_type
.
is_file
(
)
{
self
.
scheme_end
+
3
}
else
{
self
.
scheme_end
+
1
}
;
self
.
serialization
.
drain
(
new_path_start
as
usize
.
.
self
.
path_start
as
usize
)
;
let
offset
=
self
.
path_start
-
new_path_start
;
self
.
path_start
=
new_path_start
;
self
.
username_end
=
new_path_start
;
self
.
host_start
=
new_path_start
;
self
.
host_end
=
new_path_start
;
self
.
port
=
None
;
if
let
Some
(
ref
mut
index
)
=
self
.
query_start
{
*
index
-
=
offset
}
if
let
Some
(
ref
mut
index
)
=
self
.
fragment_start
{
*
index
-
=
offset
}
}
Ok
(
(
)
)
}
fn
set_host_internal
(
&
mut
self
host
:
Host
<
Cow
<
'
_
str
>
>
opt_new_port
:
Option
<
Option
<
u16
>
>
)
{
let
old_suffix_pos
=
if
opt_new_port
.
is_some
(
)
{
self
.
path_start
}
else
{
self
.
host_end
}
;
let
suffix
=
self
.
slice
(
old_suffix_pos
.
.
)
.
to_owned
(
)
;
self
.
serialization
.
truncate
(
self
.
host_start
as
usize
)
;
if
!
self
.
has_authority
(
)
{
debug_assert
!
(
self
.
slice
(
self
.
scheme_end
.
.
self
.
host_start
)
=
=
"
:
"
)
;
debug_assert
!
(
self
.
username_end
=
=
self
.
host_start
)
;
self
.
serialization
.
push
(
'
/
'
)
;
self
.
serialization
.
push
(
'
/
'
)
;
self
.
username_end
+
=
2
;
self
.
host_start
+
=
2
;
}
write
!
(
&
mut
self
.
serialization
"
{
host
}
"
)
.
unwrap
(
)
;
self
.
host_end
=
to_u32
(
self
.
serialization
.
len
(
)
)
.
unwrap
(
)
;
self
.
host
=
host
.
into
(
)
;
if
let
Some
(
new_port
)
=
opt_new_port
{
self
.
port
=
new_port
;
if
let
Some
(
port
)
=
new_port
{
write
!
(
&
mut
self
.
serialization
"
:
{
port
}
"
)
.
unwrap
(
)
;
}
}
let
new_suffix_pos
=
to_u32
(
self
.
serialization
.
len
(
)
)
.
unwrap
(
)
;
self
.
serialization
.
push_str
(
&
suffix
)
;
let
adjust
=
|
index
:
&
mut
u32
|
{
*
index
-
=
old_suffix_pos
;
*
index
+
=
new_suffix_pos
;
}
;
adjust
(
&
mut
self
.
path_start
)
;
if
let
Some
(
ref
mut
index
)
=
self
.
query_start
{
adjust
(
index
)
}
if
let
Some
(
ref
mut
index
)
=
self
.
fragment_start
{
adjust
(
index
)
}
}
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
set_ip_host
(
&
mut
self
address
:
IpAddr
)
-
>
Result
<
(
)
(
)
>
{
if
self
.
cannot_be_a_base
(
)
{
return
Err
(
(
)
)
;
}
let
address
=
match
address
{
IpAddr
:
:
V4
(
address
)
=
>
Host
:
:
Ipv4
(
address
)
IpAddr
:
:
V6
(
address
)
=
>
Host
:
:
Ipv6
(
address
)
}
;
self
.
set_host_internal
(
address
None
)
;
Ok
(
(
)
)
}
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
set_password
(
&
mut
self
password
:
Option
<
&
str
>
)
-
>
Result
<
(
)
(
)
>
{
if
!
self
.
has_host
(
)
|
|
self
.
host
(
)
=
=
Some
(
Host
:
:
Domain
(
"
"
)
)
|
|
self
.
scheme
(
)
=
=
"
file
"
{
return
Err
(
(
)
)
;
}
let
password
=
password
.
unwrap_or_default
(
)
;
if
!
password
.
is_empty
(
)
{
let
host_and_after
=
self
.
slice
(
self
.
host_start
.
.
)
.
to_owned
(
)
;
self
.
serialization
.
truncate
(
self
.
username_end
as
usize
)
;
self
.
serialization
.
push
(
'
:
'
)
;
self
.
serialization
.
extend
(
utf8_percent_encode
(
password
USERINFO
)
)
;
self
.
serialization
.
push
(
'
'
)
;
let
old_host_start
=
self
.
host_start
;
let
new_host_start
=
to_u32
(
self
.
serialization
.
len
(
)
)
.
unwrap
(
)
;
let
adjust
=
|
index
:
&
mut
u32
|
{
*
index
-
=
old_host_start
;
*
index
+
=
new_host_start
;
}
;
self
.
host_start
=
new_host_start
;
adjust
(
&
mut
self
.
host_end
)
;
adjust
(
&
mut
self
.
path_start
)
;
if
let
Some
(
ref
mut
index
)
=
self
.
query_start
{
adjust
(
index
)
}
if
let
Some
(
ref
mut
index
)
=
self
.
fragment_start
{
adjust
(
index
)
}
self
.
serialization
.
push_str
(
&
host_and_after
)
;
}
else
if
self
.
byte_at
(
self
.
username_end
)
=
=
b
'
:
'
{
let
has_username_or_password
=
self
.
byte_at
(
self
.
host_start
-
1
)
=
=
b
'
'
;
debug_assert
!
(
has_username_or_password
)
;
let
username_start
=
self
.
scheme_end
+
3
;
let
empty_username
=
username_start
=
=
self
.
username_end
;
let
start
=
self
.
username_end
;
let
end
=
if
empty_username
{
self
.
host_start
}
else
{
self
.
host_start
-
1
}
;
self
.
serialization
.
drain
(
start
as
usize
.
.
end
as
usize
)
;
let
offset
=
end
-
start
;
self
.
host_start
-
=
offset
;
self
.
host_end
-
=
offset
;
self
.
path_start
-
=
offset
;
if
let
Some
(
ref
mut
index
)
=
self
.
query_start
{
*
index
-
=
offset
}
if
let
Some
(
ref
mut
index
)
=
self
.
fragment_start
{
*
index
-
=
offset
}
}
Ok
(
(
)
)
}
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
set_username
(
&
mut
self
username
:
&
str
)
-
>
Result
<
(
)
(
)
>
{
if
!
self
.
has_host
(
)
|
|
self
.
host
(
)
=
=
Some
(
Host
:
:
Domain
(
"
"
)
)
|
|
self
.
scheme
(
)
=
=
"
file
"
{
return
Err
(
(
)
)
;
}
let
username_start
=
self
.
scheme_end
+
3
;
debug_assert
!
(
self
.
slice
(
self
.
scheme_end
.
.
username_start
)
=
=
"
:
/
/
"
)
;
if
self
.
slice
(
username_start
.
.
self
.
username_end
)
=
=
username
{
return
Ok
(
(
)
)
;
}
let
after_username
=
self
.
slice
(
self
.
username_end
.
.
)
.
to_owned
(
)
;
self
.
serialization
.
truncate
(
username_start
as
usize
)
;
self
.
serialization
.
extend
(
utf8_percent_encode
(
username
USERINFO
)
)
;
let
mut
removed_bytes
=
self
.
username_end
;
self
.
username_end
=
to_u32
(
self
.
serialization
.
len
(
)
)
.
unwrap
(
)
;
let
mut
added_bytes
=
self
.
username_end
;
let
new_username_is_empty
=
self
.
username_end
=
=
username_start
;
match
(
new_username_is_empty
after_username
.
chars
(
)
.
next
(
)
)
{
(
true
Some
(
'
'
)
)
=
>
{
removed_bytes
+
=
1
;
self
.
serialization
.
push_str
(
&
after_username
[
1
.
.
]
)
;
}
(
false
Some
(
'
'
)
)
|
(
_
Some
(
'
:
'
)
)
|
(
true
_
)
=
>
{
self
.
serialization
.
push_str
(
&
after_username
)
;
}
(
false
_
)
=
>
{
added_bytes
+
=
1
;
self
.
serialization
.
push
(
'
'
)
;
self
.
serialization
.
push_str
(
&
after_username
)
;
}
}
let
adjust
=
|
index
:
&
mut
u32
|
{
*
index
-
=
removed_bytes
;
*
index
+
=
added_bytes
;
}
;
adjust
(
&
mut
self
.
host_start
)
;
adjust
(
&
mut
self
.
host_end
)
;
adjust
(
&
mut
self
.
path_start
)
;
if
let
Some
(
ref
mut
index
)
=
self
.
query_start
{
adjust
(
index
)
}
if
let
Some
(
ref
mut
index
)
=
self
.
fragment_start
{
adjust
(
index
)
}
Ok
(
(
)
)
}
#
[
allow
(
clippy
:
:
result_unit_err
clippy
:
:
suspicious_operation_groupings
)
]
pub
fn
set_scheme
(
&
mut
self
scheme
:
&
str
)
-
>
Result
<
(
)
(
)
>
{
let
mut
parser
=
Parser
:
:
for_setter
(
String
:
:
new
(
)
)
;
let
remaining
=
parser
.
parse_scheme
(
parser
:
:
Input
:
:
new_no_trim
(
scheme
)
)
?
;
let
new_scheme_type
=
SchemeType
:
:
from
(
&
parser
.
serialization
)
;
let
old_scheme_type
=
SchemeType
:
:
from
(
self
.
scheme
(
)
)
;
if
(
new_scheme_type
.
is_special
(
)
&
&
!
old_scheme_type
.
is_special
(
)
)
|
|
(
!
new_scheme_type
.
is_special
(
)
&
&
old_scheme_type
.
is_special
(
)
)
|
|
(
new_scheme_type
.
is_file
(
)
&
&
self
.
has_authority
(
)
)
{
return
Err
(
(
)
)
;
}
if
!
remaining
.
is_empty
(
)
|
|
(
!
self
.
has_host
(
)
&
&
new_scheme_type
.
is_special
(
)
)
{
return
Err
(
(
)
)
;
}
let
old_scheme_end
=
self
.
scheme_end
;
let
new_scheme_end
=
to_u32
(
parser
.
serialization
.
len
(
)
)
.
unwrap
(
)
;
let
adjust
=
|
index
:
&
mut
u32
|
{
*
index
-
=
old_scheme_end
;
*
index
+
=
new_scheme_end
;
}
;
self
.
scheme_end
=
new_scheme_end
;
adjust
(
&
mut
self
.
username_end
)
;
adjust
(
&
mut
self
.
host_start
)
;
adjust
(
&
mut
self
.
host_end
)
;
adjust
(
&
mut
self
.
path_start
)
;
if
let
Some
(
ref
mut
index
)
=
self
.
query_start
{
adjust
(
index
)
}
if
let
Some
(
ref
mut
index
)
=
self
.
fragment_start
{
adjust
(
index
)
}
parser
.
serialization
.
push_str
(
self
.
slice
(
old_scheme_end
.
.
)
)
;
self
.
serialization
=
parser
.
serialization
;
let
previous_port
=
self
.
port
(
)
;
let
_
=
self
.
set_port
(
previous_port
)
;
Ok
(
(
)
)
}
#
[
cfg
(
all
(
feature
=
"
std
"
any
(
unix
windows
target_os
=
"
redox
"
target_os
=
"
wasi
"
target_os
=
"
hermit
"
)
)
)
]
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
from_file_path
<
P
:
AsRef
<
std
:
:
path
:
:
Path
>
>
(
path
:
P
)
-
>
Result
<
Self
(
)
>
{
let
mut
serialization
=
"
file
:
/
/
"
.
to_owned
(
)
;
let
host_start
=
serialization
.
len
(
)
as
u32
;
let
(
host_end
host
)
=
path_to_file_url_segments
(
path
.
as_ref
(
)
&
mut
serialization
)
?
;
Ok
(
Self
{
serialization
scheme_end
:
"
file
"
.
len
(
)
as
u32
username_end
:
host_start
host_start
host_end
host
port
:
None
path_start
:
host_end
query_start
:
None
fragment_start
:
None
}
)
}
#
[
cfg
(
all
(
feature
=
"
std
"
any
(
unix
windows
target_os
=
"
redox
"
target_os
=
"
wasi
"
target_os
=
"
hermit
"
)
)
)
]
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
from_directory_path
<
P
:
AsRef
<
std
:
:
path
:
:
Path
>
>
(
path
:
P
)
-
>
Result
<
Self
(
)
>
{
let
mut
url
=
Self
:
:
from_file_path
(
path
)
?
;
if
!
url
.
serialization
.
ends_with
(
'
/
'
)
{
url
.
serialization
.
push
(
'
/
'
)
}
Ok
(
url
)
}
#
[
cfg
(
feature
=
"
serde
"
)
]
#
[
deny
(
unused
)
]
pub
fn
serialize_internal
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
serde
:
:
Serializer
{
use
serde
:
:
Serialize
;
let
Url
{
ref
serialization
ref
scheme_end
ref
username_end
ref
host_start
ref
host_end
ref
host
ref
port
ref
path_start
ref
query_start
ref
fragment_start
}
=
*
self
;
(
serialization
scheme_end
username_end
host_start
host_end
host
port
path_start
query_start
fragment_start
)
.
serialize
(
serializer
)
}
#
[
cfg
(
feature
=
"
serde
"
)
]
#
[
deny
(
unused
)
]
pub
fn
deserialize_internal
<
'
de
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
serde
:
:
Deserializer
<
'
de
>
{
use
serde
:
:
de
:
:
{
Deserialize
Error
}
;
let
(
serialization
scheme_end
username_end
host_start
host_end
host
port
path_start
query_start
fragment_start
)
=
Deserialize
:
:
deserialize
(
deserializer
)
?
;
let
url
=
Url
{
serialization
scheme_end
username_end
host_start
host_end
host
port
path_start
query_start
fragment_start
}
;
if
cfg
!
(
debug_assertions
)
{
url
.
check_invariants
(
)
.
map_err
(
Error
:
:
custom
)
?
}
Ok
(
url
)
}
#
[
inline
]
#
[
cfg
(
all
(
feature
=
"
std
"
any
(
unix
windows
target_os
=
"
redox
"
target_os
=
"
wasi
"
target_os
=
"
hermit
"
)
)
)
]
#
[
allow
(
clippy
:
:
result_unit_err
)
]
pub
fn
to_file_path
(
&
self
)
-
>
Result
<
PathBuf
(
)
>
{
if
let
Some
(
segments
)
=
self
.
path_segments
(
)
{
let
host
=
match
self
.
host
(
)
{
None
|
Some
(
Host
:
:
Domain
(
"
localhost
"
)
)
=
>
None
Some
(
_
)
if
cfg
!
(
windows
)
&
&
self
.
scheme
(
)
=
=
"
file
"
=
>
{
Some
(
&
self
.
serialization
[
self
.
host_start
as
usize
.
.
self
.
host_end
as
usize
]
)
}
_
=
>
return
Err
(
(
)
)
}
;
let
str_len
=
self
.
as_str
(
)
.
len
(
)
;
let
estimated_capacity
=
if
cfg
!
(
target_os
=
"
redox
"
)
{
let
scheme_len
=
self
.
scheme
(
)
.
len
(
)
;
let
file_scheme_len
=
"
file
"
.
len
(
)
;
if
scheme_len
<
file_scheme_len
{
let
scheme_diff
=
file_scheme_len
-
scheme_len
;
(
str_len
+
scheme_diff
)
.
saturating_sub
(
2
)
}
else
{
let
scheme_diff
=
scheme_len
-
file_scheme_len
;
str_len
.
saturating_sub
(
scheme_diff
+
2
)
}
}
else
if
cfg
!
(
windows
)
{
str_len
.
saturating_sub
(
self
.
scheme
(
)
.
len
(
)
+
1
)
}
else
{
str_len
.
saturating_sub
(
self
.
scheme
(
)
.
len
(
)
+
3
)
}
;
return
file_url_segments_to_pathbuf
(
estimated_capacity
host
segments
)
;
}
Err
(
(
)
)
}
#
[
inline
]
fn
slice
<
R
>
(
&
self
range
:
R
)
-
>
&
str
where
R
:
RangeArg
{
range
.
slice_of
(
&
self
.
serialization
)
}
#
[
inline
]
fn
byte_at
(
&
self
i
:
u32
)
-
>
u8
{
self
.
serialization
.
as_bytes
(
)
[
i
as
usize
]
}
}
impl
str
:
:
FromStr
for
Url
{
type
Err
=
ParseError
;
#
[
inline
]
fn
from_str
(
input
:
&
str
)
-
>
Result
<
Self
crate
:
:
ParseError
>
{
Self
:
:
parse
(
input
)
}
}
impl
<
'
a
>
TryFrom
<
&
'
a
str
>
for
Url
{
type
Error
=
ParseError
;
fn
try_from
(
s
:
&
'
a
str
)
-
>
Result
<
Self
Self
:
:
Error
>
{
Self
:
:
parse
(
s
)
}
}
impl
fmt
:
:
Display
for
Url
{
#
[
inline
]
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
serialization
formatter
)
}
}
impl
From
<
Url
>
for
String
{
fn
from
(
value
:
Url
)
-
>
Self
{
value
.
serialization
}
}
impl
fmt
:
:
Debug
for
Url
{
#
[
inline
]
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
debug_struct
(
"
Url
"
)
.
field
(
"
scheme
"
&
self
.
scheme
(
)
)
.
field
(
"
cannot_be_a_base
"
&
self
.
cannot_be_a_base
(
)
)
.
field
(
"
username
"
&
self
.
username
(
)
)
.
field
(
"
password
"
&
self
.
password
(
)
)
.
field
(
"
host
"
&
self
.
host
(
)
)
.
field
(
"
port
"
&
self
.
port
(
)
)
.
field
(
"
path
"
&
self
.
path
(
)
)
.
field
(
"
query
"
&
self
.
query
(
)
)
.
field
(
"
fragment
"
&
self
.
fragment
(
)
)
.
finish
(
)
}
}
impl
Eq
for
Url
{
}
impl
PartialEq
for
Url
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
serialization
=
=
other
.
serialization
}
}
impl
Ord
for
Url
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
cmp
:
:
Ordering
{
self
.
serialization
.
cmp
(
&
other
.
serialization
)
}
}
impl
PartialOrd
for
Url
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
cmp
:
:
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
hash
:
:
Hash
for
Url
{
#
[
inline
]
fn
hash
<
H
>
(
&
self
state
:
&
mut
H
)
where
H
:
hash
:
:
Hasher
{
hash
:
:
Hash
:
:
hash
(
&
self
.
serialization
state
)
}
}
impl
AsRef
<
str
>
for
Url
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
str
{
&
self
.
serialization
}
}
trait
RangeArg
{
fn
slice_of
<
'
a
>
(
&
self
s
:
&
'
a
str
)
-
>
&
'
a
str
;
}
impl
RangeArg
for
Range
<
u32
>
{
#
[
inline
]
fn
slice_of
<
'
a
>
(
&
self
s
:
&
'
a
str
)
-
>
&
'
a
str
{
&
s
[
self
.
start
as
usize
.
.
self
.
end
as
usize
]
}
}
impl
RangeArg
for
RangeFrom
<
u32
>
{
#
[
inline
]
fn
slice_of
<
'
a
>
(
&
self
s
:
&
'
a
str
)
-
>
&
'
a
str
{
&
s
[
self
.
start
as
usize
.
.
]
}
}
impl
RangeArg
for
RangeTo
<
u32
>
{
#
[
inline
]
fn
slice_of
<
'
a
>
(
&
self
s
:
&
'
a
str
)
-
>
&
'
a
str
{
&
s
[
.
.
self
.
end
as
usize
]
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
serde
:
:
Serialize
for
Url
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
serde
:
:
Serializer
{
serializer
.
serialize_str
(
self
.
as_str
(
)
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
>
serde
:
:
Deserialize
<
'
de
>
for
Url
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Url
D
:
:
Error
>
where
D
:
serde
:
:
Deserializer
<
'
de
>
{
use
serde
:
:
de
:
:
{
Error
Visitor
}
;
struct
UrlVisitor
;
impl
Visitor
<
'
_
>
for
UrlVisitor
{
type
Value
=
Url
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
string
representing
an
URL
"
)
}
fn
visit_str
<
E
>
(
self
s
:
&
str
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
Error
{
Url
:
:
parse
(
s
)
.
map_err
(
|
err
|
Error
:
:
custom
(
format
!
(
"
{
err
}
:
{
s
:
?
}
"
)
)
)
}
}
deserializer
.
deserialize_str
(
UrlVisitor
)
}
}
#
[
cfg
(
all
(
feature
=
"
std
"
any
(
unix
target_os
=
"
redox
"
target_os
=
"
wasi
"
target_os
=
"
hermit
"
)
)
)
]
fn
path_to_file_url_segments
(
path
:
&
Path
serialization
:
&
mut
String
)
-
>
Result
<
(
u32
HostInternal
)
(
)
>
{
use
parser
:
:
SPECIAL_PATH_SEGMENT
;
use
percent_encoding
:
:
percent_encode
;
#
[
cfg
(
target_os
=
"
hermit
"
)
]
use
std
:
:
os
:
:
hermit
:
:
ffi
:
:
OsStrExt
;
#
[
cfg
(
any
(
unix
target_os
=
"
redox
"
)
)
]
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
OsStrExt
;
if
!
path
.
is_absolute
(
)
{
return
Err
(
(
)
)
;
}
let
host_end
=
to_u32
(
serialization
.
len
(
)
)
.
unwrap
(
)
;
let
mut
empty
=
true
;
for
component
in
path
.
components
(
)
.
skip
(
1
)
{
empty
=
false
;
serialization
.
push
(
'
/
'
)
;
#
[
cfg
(
not
(
target_os
=
"
wasi
"
)
)
]
serialization
.
extend
(
percent_encode
(
component
.
as_os_str
(
)
.
as_bytes
(
)
SPECIAL_PATH_SEGMENT
)
)
;
#
[
cfg
(
target_os
=
"
wasi
"
)
]
serialization
.
extend
(
percent_encode
(
component
.
as_os_str
(
)
.
to_string_lossy
(
)
.
as_bytes
(
)
SPECIAL_PATH_SEGMENT
)
)
;
}
if
empty
{
serialization
.
push
(
'
/
'
)
;
}
Ok
(
(
host_end
HostInternal
:
:
None
)
)
}
#
[
cfg
(
all
(
feature
=
"
std
"
windows
)
)
]
fn
path_to_file_url_segments
(
path
:
&
Path
serialization
:
&
mut
String
)
-
>
Result
<
(
u32
HostInternal
)
(
)
>
{
path_to_file_url_segments_windows
(
path
serialization
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
not
(
windows
)
allow
(
dead_code
)
)
]
fn
path_to_file_url_segments_windows
(
path
:
&
Path
serialization
:
&
mut
String
)
-
>
Result
<
(
u32
HostInternal
)
(
)
>
{
use
crate
:
:
parser
:
:
PATH_SEGMENT
;
use
percent_encoding
:
:
percent_encode
;
use
std
:
:
path
:
:
{
Component
Prefix
}
;
if
!
path
.
is_absolute
(
)
{
return
Err
(
(
)
)
;
}
let
mut
components
=
path
.
components
(
)
;
let
host_start
=
serialization
.
len
(
)
+
1
;
let
host_end
;
let
host_internal
;
match
components
.
next
(
)
{
Some
(
Component
:
:
Prefix
(
ref
p
)
)
=
>
match
p
.
kind
(
)
{
Prefix
:
:
Disk
(
letter
)
|
Prefix
:
:
VerbatimDisk
(
letter
)
=
>
{
host_end
=
to_u32
(
serialization
.
len
(
)
)
.
unwrap
(
)
;
host_internal
=
HostInternal
:
:
None
;
serialization
.
push
(
'
/
'
)
;
serialization
.
push
(
letter
as
char
)
;
serialization
.
push
(
'
:
'
)
;
}
Prefix
:
:
UNC
(
server
share
)
|
Prefix
:
:
VerbatimUNC
(
server
share
)
=
>
{
let
host
=
Host
:
:
parse_cow
(
server
.
to_str
(
)
.
ok_or
(
(
)
)
?
.
into
(
)
)
.
map_err
(
|
_
|
(
)
)
?
;
write
!
(
serialization
"
{
host
}
"
)
.
unwrap
(
)
;
host_end
=
to_u32
(
serialization
.
len
(
)
)
.
unwrap
(
)
;
host_internal
=
host
.
into
(
)
;
serialization
.
push
(
'
/
'
)
;
let
share
=
share
.
to_str
(
)
.
ok_or
(
(
)
)
?
;
serialization
.
extend
(
percent_encode
(
share
.
as_bytes
(
)
PATH_SEGMENT
)
)
;
}
_
=
>
return
Err
(
(
)
)
}
_
=
>
return
Err
(
(
)
)
}
let
mut
path_only_has_prefix
=
true
;
for
component
in
components
{
if
component
=
=
Component
:
:
RootDir
{
continue
;
}
path_only_has_prefix
=
false
;
let
component
=
component
.
as_os_str
(
)
.
to_str
(
)
.
ok_or
(
(
)
)
?
;
serialization
.
push
(
'
/
'
)
;
serialization
.
extend
(
percent_encode
(
component
.
as_bytes
(
)
PATH_SEGMENT
)
)
;
}
if
serialization
.
len
(
)
>
host_start
&
&
parser
:
:
is_windows_drive_letter
(
&
serialization
[
host_start
.
.
]
)
&
&
path_only_has_prefix
{
serialization
.
push
(
'
/
'
)
;
}
Ok
(
(
host_end
host_internal
)
)
}
#
[
cfg
(
all
(
feature
=
"
std
"
any
(
unix
target_os
=
"
redox
"
target_os
=
"
wasi
"
target_os
=
"
hermit
"
)
)
)
]
fn
file_url_segments_to_pathbuf
(
estimated_capacity
:
usize
host
:
Option
<
&
str
>
segments
:
str
:
:
Split
<
'
_
char
>
)
-
>
Result
<
PathBuf
(
)
>
{
use
alloc
:
:
vec
:
:
Vec
;
use
percent_encoding
:
:
percent_decode
;
#
[
cfg
(
not
(
target_os
=
"
wasi
"
)
)
]
use
std
:
:
ffi
:
:
OsStr
;
#
[
cfg
(
target_os
=
"
hermit
"
)
]
use
std
:
:
os
:
:
hermit
:
:
ffi
:
:
OsStrExt
;
#
[
cfg
(
any
(
unix
target_os
=
"
redox
"
)
)
]
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
OsStrExt
;
if
host
.
is_some
(
)
{
return
Err
(
(
)
)
;
}
let
mut
bytes
=
Vec
:
:
new
(
)
;
bytes
.
try_reserve
(
estimated_capacity
)
.
map_err
(
|
_
|
(
)
)
?
;
if
cfg
!
(
target_os
=
"
redox
"
)
{
bytes
.
extend
(
b
"
file
:
"
)
;
}
for
segment
in
segments
{
bytes
.
push
(
b
'
/
'
)
;
bytes
.
extend
(
percent_decode
(
segment
.
as_bytes
(
)
)
)
;
}
if
bytes
.
len
(
)
>
2
&
&
bytes
[
bytes
.
len
(
)
-
2
]
.
is_ascii_alphabetic
(
)
&
&
matches
!
(
bytes
[
bytes
.
len
(
)
-
1
]
b
'
:
'
|
b
'
|
'
)
{
bytes
.
push
(
b
'
/
'
)
;
}
#
[
cfg
(
not
(
target_os
=
"
wasi
"
)
)
]
let
path
=
PathBuf
:
:
from
(
OsStr
:
:
from_bytes
(
&
bytes
)
)
;
#
[
cfg
(
target_os
=
"
wasi
"
)
]
let
path
=
String
:
:
from_utf8
(
bytes
)
.
map
(
|
path
|
PathBuf
:
:
from
(
path
)
)
.
map_err
(
|
_
|
(
)
)
?
;
debug_assert
!
(
path
.
is_absolute
(
)
"
to_file_path
(
)
failed
to
produce
an
absolute
Path
"
)
;
Ok
(
path
)
}
#
[
cfg
(
all
(
feature
=
"
std
"
windows
)
)
]
fn
file_url_segments_to_pathbuf
(
estimated_capacity
:
usize
host
:
Option
<
&
str
>
segments
:
str
:
:
Split
<
char
>
)
-
>
Result
<
PathBuf
(
)
>
{
file_url_segments_to_pathbuf_windows
(
estimated_capacity
host
segments
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
not
(
windows
)
allow
(
dead_code
)
)
]
fn
file_url_segments_to_pathbuf_windows
(
estimated_capacity
:
usize
host
:
Option
<
&
str
>
mut
segments
:
str
:
:
Split
<
'
_
char
>
)
-
>
Result
<
PathBuf
(
)
>
{
use
percent_encoding
:
:
percent_decode_str
;
let
mut
string
=
String
:
:
new
(
)
;
string
.
try_reserve
(
estimated_capacity
)
.
map_err
(
|
_
|
(
)
)
?
;
if
let
Some
(
host
)
=
host
{
string
.
push_str
(
r
"
\
\
"
)
;
string
.
push_str
(
host
)
;
}
else
{
let
first
=
segments
.
next
(
)
.
ok_or
(
(
)
)
?
;
match
first
.
len
(
)
{
2
=
>
{
if
!
first
.
starts_with
(
parser
:
:
ascii_alpha
)
|
|
first
.
as_bytes
(
)
[
1
]
!
=
b
'
:
'
{
return
Err
(
(
)
)
;
}
string
.
push_str
(
first
)
;
}
4
=
>
{
if
!
first
.
starts_with
(
parser
:
:
ascii_alpha
)
{
return
Err
(
(
)
)
;
}
let
bytes
=
first
.
as_bytes
(
)
;
if
bytes
[
1
]
!
=
b
'
%
'
|
|
bytes
[
2
]
!
=
b
'
3
'
|
|
(
bytes
[
3
]
!
=
b
'
a
'
&
&
bytes
[
3
]
!
=
b
'
A
'
)
{
return
Err
(
(
)
)
;
}
string
.
push_str
(
&
first
[
0
.
.
1
]
)
;
string
.
push
(
'
:
'
)
;
}
_
=
>
return
Err
(
(
)
)
}
}
;
for
segment
in
segments
{
string
.
push
(
'
\
\
'
)
;
match
percent_decode_str
(
segment
)
.
decode_utf8
(
)
{
Ok
(
s
)
=
>
string
.
push_str
(
&
s
)
Err
(
.
.
)
=
>
return
Err
(
(
)
)
}
}
if
cfg
!
(
test
)
{
debug_assert
!
(
string
.
len
(
)
<
=
estimated_capacity
"
len
:
{
}
capacity
:
{
}
"
string
.
len
(
)
estimated_capacity
)
;
}
let
path
=
PathBuf
:
:
from
(
string
)
;
debug_assert
!
(
path
.
is_absolute
(
)
"
to_file_path
(
)
failed
to
produce
an
absolute
Path
"
)
;
Ok
(
path
)
}
#
[
derive
(
Debug
)
]
pub
struct
UrlQuery
<
'
a
>
{
url
:
Option
<
&
'
a
mut
Url
>
fragment
:
Option
<
String
>
}
impl
<
'
a
>
form_urlencoded
:
:
Target
for
UrlQuery
<
'
a
>
{
fn
as_mut_string
(
&
mut
self
)
-
>
&
mut
String
{
&
mut
self
.
url
.
as_mut
(
)
.
unwrap
(
)
.
serialization
}
fn
finish
(
mut
self
)
-
>
&
'
a
mut
Url
{
let
url
=
self
.
url
.
take
(
)
.
unwrap
(
)
;
url
.
restore_already_parsed_fragment
(
self
.
fragment
.
take
(
)
)
;
url
}
type
Finished
=
&
'
a
mut
Url
;
}
impl
Drop
for
UrlQuery
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
url
)
=
self
.
url
.
take
(
)
{
url
.
restore_already_parsed_fragment
(
self
.
fragment
.
take
(
)
)
}
}
}
