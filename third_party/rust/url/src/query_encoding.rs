use
std
:
:
borrow
:
:
Cow
;
pub
type
EncodingOverride
<
'
a
>
=
Option
<
&
'
a
dyn
Fn
(
&
str
)
-
>
Cow
<
[
u8
]
>
>
;
pub
(
crate
)
fn
encode
<
'
a
>
(
encoding_override
:
EncodingOverride
input
:
&
'
a
str
)
-
>
Cow
<
'
a
[
u8
]
>
{
if
let
Some
(
o
)
=
encoding_override
{
return
o
(
input
)
;
}
input
.
as_bytes
(
)
.
into
(
)
}
pub
(
crate
)
fn
decode_utf8_lossy
(
input
:
Cow
<
[
u8
]
>
)
-
>
Cow
<
str
>
{
match
input
{
Cow
:
:
Borrowed
(
bytes
)
=
>
String
:
:
from_utf8_lossy
(
bytes
)
Cow
:
:
Owned
(
bytes
)
=
>
{
let
raw_utf8
:
*
const
[
u8
]
;
match
String
:
:
from_utf8_lossy
(
&
bytes
)
{
Cow
:
:
Borrowed
(
utf8
)
=
>
raw_utf8
=
utf8
.
as_bytes
(
)
Cow
:
:
Owned
(
s
)
=
>
return
s
.
into
(
)
}
debug_assert
!
(
raw_utf8
=
=
&
*
bytes
as
*
const
[
u8
]
)
;
unsafe
{
String
:
:
from_utf8_unchecked
(
bytes
)
}
.
into
(
)
}
}
}
