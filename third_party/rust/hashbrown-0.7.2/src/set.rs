use
crate
:
:
CollectionAllocErr
;
use
core
:
:
borrow
:
:
Borrow
;
use
core
:
:
fmt
;
use
core
:
:
hash
:
:
{
BuildHasher
Hash
}
;
use
core
:
:
iter
:
:
{
Chain
FromIterator
FusedIterator
}
;
use
core
:
:
ops
:
:
{
BitAnd
BitOr
BitXor
Sub
}
;
use
super
:
:
map
:
:
{
self
DefaultHashBuilder
HashMap
Keys
}
;
pub
struct
HashSet
<
T
S
=
DefaultHashBuilder
>
{
pub
(
crate
)
map
:
HashMap
<
T
(
)
S
>
}
impl
<
T
:
Clone
S
:
Clone
>
Clone
for
HashSet
<
T
S
>
{
fn
clone
(
&
self
)
-
>
Self
{
HashSet
{
map
:
self
.
map
.
clone
(
)
}
}
fn
clone_from
(
&
mut
self
source
:
&
Self
)
{
self
.
map
.
clone_from
(
&
source
.
map
)
;
}
}
#
[
cfg
(
feature
=
"
ahash
"
)
]
impl
<
T
:
Hash
+
Eq
>
HashSet
<
T
DefaultHashBuilder
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
new
(
)
-
>
Self
{
Self
{
map
:
HashMap
:
:
new
(
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
Self
{
Self
{
map
:
HashMap
:
:
with_capacity
(
capacity
)
}
}
}
impl
<
T
S
>
HashSet
<
T
S
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
map
.
capacity
(
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
iter
(
&
self
)
-
>
Iter
<
'
_
T
>
{
Iter
{
iter
:
self
.
map
.
keys
(
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
map
.
len
(
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
map
.
is_empty
(
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
drain
(
&
mut
self
)
-
>
Drain
<
'
_
T
>
{
Drain
{
iter
:
self
.
map
.
drain
(
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
clear
(
&
mut
self
)
{
self
.
map
.
clear
(
)
}
}
impl
<
T
S
>
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
with_hasher
(
hasher
:
S
)
-
>
Self
{
Self
{
map
:
HashMap
:
:
with_hasher
(
hasher
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
with_capacity_and_hasher
(
capacity
:
usize
hasher
:
S
)
-
>
Self
{
Self
{
map
:
HashMap
:
:
with_capacity_and_hasher
(
capacity
hasher
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
hasher
(
&
self
)
-
>
&
S
{
self
.
map
.
hasher
(
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
reserve
(
&
mut
self
additional
:
usize
)
{
self
.
map
.
reserve
(
additional
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
try_reserve
(
&
mut
self
additional
:
usize
)
-
>
Result
<
(
)
CollectionAllocErr
>
{
self
.
map
.
try_reserve
(
additional
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
shrink_to_fit
(
&
mut
self
)
{
self
.
map
.
shrink_to_fit
(
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
shrink_to
(
&
mut
self
min_capacity
:
usize
)
{
self
.
map
.
shrink_to
(
min_capacity
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
difference
<
'
a
>
(
&
'
a
self
other
:
&
'
a
Self
)
-
>
Difference
<
'
a
T
S
>
{
Difference
{
iter
:
self
.
iter
(
)
other
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
symmetric_difference
<
'
a
>
(
&
'
a
self
other
:
&
'
a
Self
)
-
>
SymmetricDifference
<
'
a
T
S
>
{
SymmetricDifference
{
iter
:
self
.
difference
(
other
)
.
chain
(
other
.
difference
(
self
)
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
intersection
<
'
a
>
(
&
'
a
self
other
:
&
'
a
Self
)
-
>
Intersection
<
'
a
T
S
>
{
let
(
smaller
larger
)
=
if
self
.
len
(
)
<
=
other
.
len
(
)
{
(
self
other
)
}
else
{
(
other
self
)
}
;
Intersection
{
iter
:
smaller
.
iter
(
)
other
:
larger
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
union
<
'
a
>
(
&
'
a
self
other
:
&
'
a
Self
)
-
>
Union
<
'
a
T
S
>
{
let
(
smaller
larger
)
=
if
self
.
len
(
)
<
=
other
.
len
(
)
{
(
self
other
)
}
else
{
(
other
self
)
}
;
Union
{
iter
:
larger
.
iter
(
)
.
chain
(
smaller
.
difference
(
larger
)
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
contains
<
Q
:
?
Sized
>
(
&
self
value
:
&
Q
)
-
>
bool
where
T
:
Borrow
<
Q
>
Q
:
Hash
+
Eq
{
self
.
map
.
contains_key
(
value
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
get
<
Q
:
?
Sized
>
(
&
self
value
:
&
Q
)
-
>
Option
<
&
T
>
where
T
:
Borrow
<
Q
>
Q
:
Hash
+
Eq
{
self
.
map
.
get_key_value
(
value
)
.
map
(
|
(
k
_
)
|
k
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
get_or_insert
(
&
mut
self
value
:
T
)
-
>
&
T
{
self
.
map
.
raw_entry_mut
(
)
.
from_key
(
&
value
)
.
or_insert
(
value
(
)
)
.
0
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
get_or_insert_with
<
Q
:
?
Sized
F
>
(
&
mut
self
value
:
&
Q
f
:
F
)
-
>
&
T
where
T
:
Borrow
<
Q
>
Q
:
Hash
+
Eq
F
:
FnOnce
(
&
Q
)
-
>
T
{
self
.
map
.
raw_entry_mut
(
)
.
from_key
(
value
)
.
or_insert_with
(
|
|
(
f
(
value
)
(
)
)
)
.
0
}
pub
fn
is_disjoint
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
iter
(
)
.
all
(
|
v
|
!
other
.
contains
(
v
)
)
}
pub
fn
is_subset
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
len
(
)
<
=
other
.
len
(
)
&
&
self
.
iter
(
)
.
all
(
|
v
|
other
.
contains
(
v
)
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
is_superset
(
&
self
other
:
&
Self
)
-
>
bool
{
other
.
is_subset
(
self
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
insert
(
&
mut
self
value
:
T
)
-
>
bool
{
self
.
map
.
insert
(
value
(
)
)
.
is_none
(
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
replace
(
&
mut
self
value
:
T
)
-
>
Option
<
T
>
{
match
self
.
map
.
entry
(
value
)
{
map
:
:
Entry
:
:
Occupied
(
occupied
)
=
>
Some
(
occupied
.
replace_key
(
)
)
map
:
:
Entry
:
:
Vacant
(
vacant
)
=
>
{
vacant
.
insert
(
(
)
)
;
None
}
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
remove
<
Q
:
?
Sized
>
(
&
mut
self
value
:
&
Q
)
-
>
bool
where
T
:
Borrow
<
Q
>
Q
:
Hash
+
Eq
{
self
.
map
.
remove
(
value
)
.
is_some
(
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
take
<
Q
:
?
Sized
>
(
&
mut
self
value
:
&
Q
)
-
>
Option
<
T
>
where
T
:
Borrow
<
Q
>
Q
:
Hash
+
Eq
{
self
.
map
.
remove_entry
(
value
)
.
map
(
|
(
k
_
)
|
k
)
}
pub
fn
retain
<
F
>
(
&
mut
self
mut
f
:
F
)
where
F
:
FnMut
(
&
T
)
-
>
bool
{
self
.
map
.
retain
(
|
k
_
|
f
(
k
)
)
;
}
}
impl
<
T
S
>
PartialEq
for
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
if
self
.
len
(
)
!
=
other
.
len
(
)
{
return
false
;
}
self
.
iter
(
)
.
all
(
|
key
|
other
.
contains
(
key
)
)
}
}
impl
<
T
S
>
Eq
for
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
}
impl
<
T
S
>
fmt
:
:
Debug
for
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
+
fmt
:
:
Debug
S
:
BuildHasher
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_set
(
)
.
entries
(
self
.
iter
(
)
)
.
finish
(
)
}
}
impl
<
T
S
>
FromIterator
<
T
>
for
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
+
Default
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
from_iter
<
I
:
IntoIterator
<
Item
=
T
>
>
(
iter
:
I
)
-
>
Self
{
let
mut
set
=
Self
:
:
with_hasher
(
Default
:
:
default
(
)
)
;
set
.
extend
(
iter
)
;
set
}
}
impl
<
T
S
>
Extend
<
T
>
for
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
extend
<
I
:
IntoIterator
<
Item
=
T
>
>
(
&
mut
self
iter
:
I
)
{
self
.
map
.
extend
(
iter
.
into_iter
(
)
.
map
(
|
k
|
(
k
(
)
)
)
)
;
}
}
impl
<
'
a
T
S
>
Extend
<
&
'
a
T
>
for
HashSet
<
T
S
>
where
T
:
'
a
+
Eq
+
Hash
+
Copy
S
:
BuildHasher
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
extend
<
I
:
IntoIterator
<
Item
=
&
'
a
T
>
>
(
&
mut
self
iter
:
I
)
{
self
.
extend
(
iter
.
into_iter
(
)
.
cloned
(
)
)
;
}
}
impl
<
T
S
>
Default
for
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
+
Default
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
default
(
)
-
>
Self
{
Self
{
map
:
HashMap
:
:
default
(
)
}
}
}
impl
<
T
S
>
BitOr
<
&
HashSet
<
T
S
>
>
for
&
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
+
Clone
S
:
BuildHasher
+
Default
{
type
Output
=
HashSet
<
T
S
>
;
fn
bitor
(
self
rhs
:
&
HashSet
<
T
S
>
)
-
>
HashSet
<
T
S
>
{
self
.
union
(
rhs
)
.
cloned
(
)
.
collect
(
)
}
}
impl
<
T
S
>
BitAnd
<
&
HashSet
<
T
S
>
>
for
&
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
+
Clone
S
:
BuildHasher
+
Default
{
type
Output
=
HashSet
<
T
S
>
;
fn
bitand
(
self
rhs
:
&
HashSet
<
T
S
>
)
-
>
HashSet
<
T
S
>
{
self
.
intersection
(
rhs
)
.
cloned
(
)
.
collect
(
)
}
}
impl
<
T
S
>
BitXor
<
&
HashSet
<
T
S
>
>
for
&
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
+
Clone
S
:
BuildHasher
+
Default
{
type
Output
=
HashSet
<
T
S
>
;
fn
bitxor
(
self
rhs
:
&
HashSet
<
T
S
>
)
-
>
HashSet
<
T
S
>
{
self
.
symmetric_difference
(
rhs
)
.
cloned
(
)
.
collect
(
)
}
}
impl
<
T
S
>
Sub
<
&
HashSet
<
T
S
>
>
for
&
HashSet
<
T
S
>
where
T
:
Eq
+
Hash
+
Clone
S
:
BuildHasher
+
Default
{
type
Output
=
HashSet
<
T
S
>
;
fn
sub
(
self
rhs
:
&
HashSet
<
T
S
>
)
-
>
HashSet
<
T
S
>
{
self
.
difference
(
rhs
)
.
cloned
(
)
.
collect
(
)
}
}
pub
struct
Iter
<
'
a
K
>
{
iter
:
Keys
<
'
a
K
(
)
>
}
pub
struct
IntoIter
<
K
>
{
iter
:
map
:
:
IntoIter
<
K
(
)
>
}
pub
struct
Drain
<
'
a
K
>
{
iter
:
map
:
:
Drain
<
'
a
K
(
)
>
}
pub
struct
Intersection
<
'
a
T
S
>
{
iter
:
Iter
<
'
a
T
>
other
:
&
'
a
HashSet
<
T
S
>
}
pub
struct
Difference
<
'
a
T
S
>
{
iter
:
Iter
<
'
a
T
>
other
:
&
'
a
HashSet
<
T
S
>
}
pub
struct
SymmetricDifference
<
'
a
T
S
>
{
iter
:
Chain
<
Difference
<
'
a
T
S
>
Difference
<
'
a
T
S
>
>
}
pub
struct
Union
<
'
a
T
S
>
{
iter
:
Chain
<
Iter
<
'
a
T
>
Difference
<
'
a
T
S
>
>
}
impl
<
'
a
T
S
>
IntoIterator
for
&
'
a
HashSet
<
T
S
>
{
type
Item
=
&
'
a
T
;
type
IntoIter
=
Iter
<
'
a
T
>
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
into_iter
(
self
)
-
>
Iter
<
'
a
T
>
{
self
.
iter
(
)
}
}
impl
<
T
S
>
IntoIterator
for
HashSet
<
T
S
>
{
type
Item
=
T
;
type
IntoIter
=
IntoIter
<
T
>
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
into_iter
(
self
)
-
>
IntoIter
<
T
>
{
IntoIter
{
iter
:
self
.
map
.
into_iter
(
)
}
}
}
impl
<
K
>
Clone
for
Iter
<
'
_
K
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
clone
(
&
self
)
-
>
Self
{
Iter
{
iter
:
self
.
iter
.
clone
(
)
}
}
}
impl
<
'
a
K
>
Iterator
for
Iter
<
'
a
K
>
{
type
Item
=
&
'
a
K
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
K
>
{
self
.
iter
.
next
(
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
'
a
K
>
ExactSizeIterator
for
Iter
<
'
a
K
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
>
FusedIterator
for
Iter
<
'
_
K
>
{
}
impl
<
K
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Iter
<
'
_
K
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
impl
<
K
>
Iterator
for
IntoIter
<
K
>
{
type
Item
=
K
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
K
>
{
self
.
iter
.
next
(
)
.
map
(
|
(
k
_
)
|
k
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
K
>
ExactSizeIterator
for
IntoIter
<
K
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
>
FusedIterator
for
IntoIter
<
K
>
{
}
impl
<
K
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
IntoIter
<
K
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
entries_iter
=
self
.
iter
.
iter
(
)
.
map
(
|
(
k
_
)
|
k
)
;
f
.
debug_list
(
)
.
entries
(
entries_iter
)
.
finish
(
)
}
}
impl
<
K
>
Iterator
for
Drain
<
'
_
K
>
{
type
Item
=
K
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
K
>
{
self
.
iter
.
next
(
)
.
map
(
|
(
k
_
)
|
k
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
K
>
ExactSizeIterator
for
Drain
<
'
_
K
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
>
FusedIterator
for
Drain
<
'
_
K
>
{
}
impl
<
K
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Drain
<
'
_
K
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
entries_iter
=
self
.
iter
.
iter
(
)
.
map
(
|
(
k
_
)
|
k
)
;
f
.
debug_list
(
)
.
entries
(
entries_iter
)
.
finish
(
)
}
}
impl
<
T
S
>
Clone
for
Intersection
<
'
_
T
S
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
clone
(
&
self
)
-
>
Self
{
Intersection
{
iter
:
self
.
iter
.
clone
(
)
.
.
*
self
}
}
}
impl
<
'
a
T
S
>
Iterator
for
Intersection
<
'
a
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
type
Item
=
&
'
a
T
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
loop
{
let
elt
=
self
.
iter
.
next
(
)
?
;
if
self
.
other
.
contains
(
elt
)
{
return
Some
(
elt
)
;
}
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
(
_
upper
)
=
self
.
iter
.
size_hint
(
)
;
(
0
upper
)
}
}
impl
<
T
S
>
fmt
:
:
Debug
for
Intersection
<
'
_
T
S
>
where
T
:
fmt
:
:
Debug
+
Eq
+
Hash
S
:
BuildHasher
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
impl
<
T
S
>
FusedIterator
for
Intersection
<
'
_
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
}
impl
<
T
S
>
Clone
for
Difference
<
'
_
T
S
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
clone
(
&
self
)
-
>
Self
{
Difference
{
iter
:
self
.
iter
.
clone
(
)
.
.
*
self
}
}
}
impl
<
'
a
T
S
>
Iterator
for
Difference
<
'
a
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
type
Item
=
&
'
a
T
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
loop
{
let
elt
=
self
.
iter
.
next
(
)
?
;
if
!
self
.
other
.
contains
(
elt
)
{
return
Some
(
elt
)
;
}
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
(
_
upper
)
=
self
.
iter
.
size_hint
(
)
;
(
0
upper
)
}
}
impl
<
T
S
>
FusedIterator
for
Difference
<
'
_
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
}
impl
<
T
S
>
fmt
:
:
Debug
for
Difference
<
'
_
T
S
>
where
T
:
fmt
:
:
Debug
+
Eq
+
Hash
S
:
BuildHasher
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
impl
<
T
S
>
Clone
for
SymmetricDifference
<
'
_
T
S
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
clone
(
&
self
)
-
>
Self
{
SymmetricDifference
{
iter
:
self
.
iter
.
clone
(
)
}
}
}
impl
<
'
a
T
S
>
Iterator
for
SymmetricDifference
<
'
a
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
type
Item
=
&
'
a
T
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
self
.
iter
.
next
(
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
T
S
>
FusedIterator
for
SymmetricDifference
<
'
_
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
}
impl
<
T
S
>
fmt
:
:
Debug
for
SymmetricDifference
<
'
_
T
S
>
where
T
:
fmt
:
:
Debug
+
Eq
+
Hash
S
:
BuildHasher
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
impl
<
T
S
>
Clone
for
Union
<
'
_
T
S
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
clone
(
&
self
)
-
>
Self
{
Union
{
iter
:
self
.
iter
.
clone
(
)
}
}
}
impl
<
T
S
>
FusedIterator
for
Union
<
'
_
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
}
impl
<
T
S
>
fmt
:
:
Debug
for
Union
<
'
_
T
S
>
where
T
:
fmt
:
:
Debug
+
Eq
+
Hash
S
:
BuildHasher
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
impl
<
'
a
T
S
>
Iterator
for
Union
<
'
a
T
S
>
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
type
Item
=
&
'
a
T
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
self
.
iter
.
next
(
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
#
[
allow
(
dead_code
)
]
fn
assert_covariance
(
)
{
fn
set
<
'
new
>
(
v
:
HashSet
<
&
'
static
str
>
)
-
>
HashSet
<
&
'
new
str
>
{
v
}
fn
iter
<
'
a
'
new
>
(
v
:
Iter
<
'
a
&
'
static
str
>
)
-
>
Iter
<
'
a
&
'
new
str
>
{
v
}
fn
into_iter
<
'
new
>
(
v
:
IntoIter
<
&
'
static
str
>
)
-
>
IntoIter
<
&
'
new
str
>
{
v
}
fn
difference
<
'
a
'
new
>
(
v
:
Difference
<
'
a
&
'
static
str
DefaultHashBuilder
>
)
-
>
Difference
<
'
a
&
'
new
str
DefaultHashBuilder
>
{
v
}
fn
symmetric_difference
<
'
a
'
new
>
(
v
:
SymmetricDifference
<
'
a
&
'
static
str
DefaultHashBuilder
>
)
-
>
SymmetricDifference
<
'
a
&
'
new
str
DefaultHashBuilder
>
{
v
}
fn
intersection
<
'
a
'
new
>
(
v
:
Intersection
<
'
a
&
'
static
str
DefaultHashBuilder
>
)
-
>
Intersection
<
'
a
&
'
new
str
DefaultHashBuilder
>
{
v
}
fn
union
<
'
a
'
new
>
(
v
:
Union
<
'
a
&
'
static
str
DefaultHashBuilder
>
)
-
>
Union
<
'
a
&
'
new
str
DefaultHashBuilder
>
{
v
}
fn
drain
<
'
new
>
(
d
:
Drain
<
'
static
&
'
static
str
>
)
-
>
Drain
<
'
new
&
'
new
str
>
{
d
}
}
#
[
cfg
(
test
)
]
mod
test_set
{
use
super
:
:
super
:
:
map
:
:
DefaultHashBuilder
;
use
super
:
:
HashSet
;
use
std
:
:
vec
:
:
Vec
;
#
[
test
]
fn
test_zero_capacities
(
)
{
type
HS
=
HashSet
<
i32
>
;
let
s
=
HS
:
:
new
(
)
;
assert_eq
!
(
s
.
capacity
(
)
0
)
;
let
s
=
HS
:
:
default
(
)
;
assert_eq
!
(
s
.
capacity
(
)
0
)
;
let
s
=
HS
:
:
with_hasher
(
DefaultHashBuilder
:
:
default
(
)
)
;
assert_eq
!
(
s
.
capacity
(
)
0
)
;
let
s
=
HS
:
:
with_capacity
(
0
)
;
assert_eq
!
(
s
.
capacity
(
)
0
)
;
let
s
=
HS
:
:
with_capacity_and_hasher
(
0
DefaultHashBuilder
:
:
default
(
)
)
;
assert_eq
!
(
s
.
capacity
(
)
0
)
;
let
mut
s
=
HS
:
:
new
(
)
;
s
.
insert
(
1
)
;
s
.
insert
(
2
)
;
s
.
remove
(
&
1
)
;
s
.
remove
(
&
2
)
;
s
.
shrink_to_fit
(
)
;
assert_eq
!
(
s
.
capacity
(
)
0
)
;
let
mut
s
=
HS
:
:
new
(
)
;
s
.
reserve
(
0
)
;
assert_eq
!
(
s
.
capacity
(
)
0
)
;
}
#
[
test
]
fn
test_disjoint
(
)
{
let
mut
xs
=
HashSet
:
:
new
(
)
;
let
mut
ys
=
HashSet
:
:
new
(
)
;
assert
!
(
xs
.
is_disjoint
(
&
ys
)
)
;
assert
!
(
ys
.
is_disjoint
(
&
xs
)
)
;
assert
!
(
xs
.
insert
(
5
)
)
;
assert
!
(
ys
.
insert
(
11
)
)
;
assert
!
(
xs
.
is_disjoint
(
&
ys
)
)
;
assert
!
(
ys
.
is_disjoint
(
&
xs
)
)
;
assert
!
(
xs
.
insert
(
7
)
)
;
assert
!
(
xs
.
insert
(
19
)
)
;
assert
!
(
xs
.
insert
(
4
)
)
;
assert
!
(
ys
.
insert
(
2
)
)
;
assert
!
(
ys
.
insert
(
-
11
)
)
;
assert
!
(
xs
.
is_disjoint
(
&
ys
)
)
;
assert
!
(
ys
.
is_disjoint
(
&
xs
)
)
;
assert
!
(
ys
.
insert
(
7
)
)
;
assert
!
(
!
xs
.
is_disjoint
(
&
ys
)
)
;
assert
!
(
!
ys
.
is_disjoint
(
&
xs
)
)
;
}
#
[
test
]
fn
test_subset_and_superset
(
)
{
let
mut
a
=
HashSet
:
:
new
(
)
;
assert
!
(
a
.
insert
(
0
)
)
;
assert
!
(
a
.
insert
(
5
)
)
;
assert
!
(
a
.
insert
(
11
)
)
;
assert
!
(
a
.
insert
(
7
)
)
;
let
mut
b
=
HashSet
:
:
new
(
)
;
assert
!
(
b
.
insert
(
0
)
)
;
assert
!
(
b
.
insert
(
7
)
)
;
assert
!
(
b
.
insert
(
19
)
)
;
assert
!
(
b
.
insert
(
250
)
)
;
assert
!
(
b
.
insert
(
11
)
)
;
assert
!
(
b
.
insert
(
200
)
)
;
assert
!
(
!
a
.
is_subset
(
&
b
)
)
;
assert
!
(
!
a
.
is_superset
(
&
b
)
)
;
assert
!
(
!
b
.
is_subset
(
&
a
)
)
;
assert
!
(
!
b
.
is_superset
(
&
a
)
)
;
assert
!
(
b
.
insert
(
5
)
)
;
assert
!
(
a
.
is_subset
(
&
b
)
)
;
assert
!
(
!
a
.
is_superset
(
&
b
)
)
;
assert
!
(
!
b
.
is_subset
(
&
a
)
)
;
assert
!
(
b
.
is_superset
(
&
a
)
)
;
}
#
[
test
]
fn
test_iterate
(
)
{
let
mut
a
=
HashSet
:
:
new
(
)
;
for
i
in
0
.
.
32
{
assert
!
(
a
.
insert
(
i
)
)
;
}
let
mut
observed
:
u32
=
0
;
for
k
in
&
a
{
observed
|
=
1
<
<
*
k
;
}
assert_eq
!
(
observed
0xFFFF_FFFF
)
;
}
#
[
test
]
fn
test_intersection
(
)
{
let
mut
a
=
HashSet
:
:
new
(
)
;
let
mut
b
=
HashSet
:
:
new
(
)
;
assert
!
(
a
.
insert
(
11
)
)
;
assert
!
(
a
.
insert
(
1
)
)
;
assert
!
(
a
.
insert
(
3
)
)
;
assert
!
(
a
.
insert
(
77
)
)
;
assert
!
(
a
.
insert
(
103
)
)
;
assert
!
(
a
.
insert
(
5
)
)
;
assert
!
(
a
.
insert
(
-
5
)
)
;
assert
!
(
b
.
insert
(
2
)
)
;
assert
!
(
b
.
insert
(
11
)
)
;
assert
!
(
b
.
insert
(
77
)
)
;
assert
!
(
b
.
insert
(
-
9
)
)
;
assert
!
(
b
.
insert
(
-
42
)
)
;
assert
!
(
b
.
insert
(
5
)
)
;
assert
!
(
b
.
insert
(
3
)
)
;
let
mut
i
=
0
;
let
expected
=
[
3
5
11
77
]
;
for
x
in
a
.
intersection
(
&
b
)
{
assert
!
(
expected
.
contains
(
x
)
)
;
i
+
=
1
}
assert_eq
!
(
i
expected
.
len
(
)
)
;
}
#
[
test
]
fn
test_difference
(
)
{
let
mut
a
=
HashSet
:
:
new
(
)
;
let
mut
b
=
HashSet
:
:
new
(
)
;
assert
!
(
a
.
insert
(
1
)
)
;
assert
!
(
a
.
insert
(
3
)
)
;
assert
!
(
a
.
insert
(
5
)
)
;
assert
!
(
a
.
insert
(
9
)
)
;
assert
!
(
a
.
insert
(
11
)
)
;
assert
!
(
b
.
insert
(
3
)
)
;
assert
!
(
b
.
insert
(
9
)
)
;
let
mut
i
=
0
;
let
expected
=
[
1
5
11
]
;
for
x
in
a
.
difference
(
&
b
)
{
assert
!
(
expected
.
contains
(
x
)
)
;
i
+
=
1
}
assert_eq
!
(
i
expected
.
len
(
)
)
;
}
#
[
test
]
fn
test_symmetric_difference
(
)
{
let
mut
a
=
HashSet
:
:
new
(
)
;
let
mut
b
=
HashSet
:
:
new
(
)
;
assert
!
(
a
.
insert
(
1
)
)
;
assert
!
(
a
.
insert
(
3
)
)
;
assert
!
(
a
.
insert
(
5
)
)
;
assert
!
(
a
.
insert
(
9
)
)
;
assert
!
(
a
.
insert
(
11
)
)
;
assert
!
(
b
.
insert
(
-
2
)
)
;
assert
!
(
b
.
insert
(
3
)
)
;
assert
!
(
b
.
insert
(
9
)
)
;
assert
!
(
b
.
insert
(
14
)
)
;
assert
!
(
b
.
insert
(
22
)
)
;
let
mut
i
=
0
;
let
expected
=
[
-
2
1
5
11
14
22
]
;
for
x
in
a
.
symmetric_difference
(
&
b
)
{
assert
!
(
expected
.
contains
(
x
)
)
;
i
+
=
1
}
assert_eq
!
(
i
expected
.
len
(
)
)
;
}
#
[
test
]
fn
test_union
(
)
{
let
mut
a
=
HashSet
:
:
new
(
)
;
let
mut
b
=
HashSet
:
:
new
(
)
;
assert
!
(
a
.
insert
(
1
)
)
;
assert
!
(
a
.
insert
(
3
)
)
;
assert
!
(
a
.
insert
(
5
)
)
;
assert
!
(
a
.
insert
(
9
)
)
;
assert
!
(
a
.
insert
(
11
)
)
;
assert
!
(
a
.
insert
(
16
)
)
;
assert
!
(
a
.
insert
(
19
)
)
;
assert
!
(
a
.
insert
(
24
)
)
;
assert
!
(
b
.
insert
(
-
2
)
)
;
assert
!
(
b
.
insert
(
1
)
)
;
assert
!
(
b
.
insert
(
5
)
)
;
assert
!
(
b
.
insert
(
9
)
)
;
assert
!
(
b
.
insert
(
13
)
)
;
assert
!
(
b
.
insert
(
19
)
)
;
let
mut
i
=
0
;
let
expected
=
[
-
2
1
3
5
9
11
13
16
19
24
]
;
for
x
in
a
.
union
(
&
b
)
{
assert
!
(
expected
.
contains
(
x
)
)
;
i
+
=
1
}
assert_eq
!
(
i
expected
.
len
(
)
)
;
}
#
[
test
]
fn
test_from_iter
(
)
{
let
xs
=
[
1
2
3
4
5
6
7
8
9
]
;
let
set
:
HashSet
<
_
>
=
xs
.
iter
(
)
.
cloned
(
)
.
collect
(
)
;
for
x
in
&
xs
{
assert
!
(
set
.
contains
(
x
)
)
;
}
}
#
[
test
]
fn
test_move_iter
(
)
{
let
hs
=
{
let
mut
hs
=
HashSet
:
:
new
(
)
;
hs
.
insert
(
'
a
'
)
;
hs
.
insert
(
'
b
'
)
;
hs
}
;
let
v
=
hs
.
into_iter
(
)
.
collect
:
:
<
Vec
<
char
>
>
(
)
;
assert
!
(
v
=
=
[
'
a
'
'
b
'
]
|
|
v
=
=
[
'
b
'
'
a
'
]
)
;
}
#
[
test
]
fn
test_eq
(
)
{
let
mut
s1
=
HashSet
:
:
new
(
)
;
s1
.
insert
(
1
)
;
s1
.
insert
(
2
)
;
s1
.
insert
(
3
)
;
let
mut
s2
=
HashSet
:
:
new
(
)
;
s2
.
insert
(
1
)
;
s2
.
insert
(
2
)
;
assert
!
(
s1
!
=
s2
)
;
s2
.
insert
(
3
)
;
assert_eq
!
(
s1
s2
)
;
}
#
[
test
]
fn
test_show
(
)
{
let
mut
set
=
HashSet
:
:
new
(
)
;
let
empty
=
HashSet
:
:
<
i32
>
:
:
new
(
)
;
set
.
insert
(
1
)
;
set
.
insert
(
2
)
;
let
set_str
=
format
!
(
"
{
:
?
}
"
set
)
;
assert
!
(
set_str
=
=
"
{
1
2
}
"
|
|
set_str
=
=
"
{
2
1
}
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
empty
)
"
{
}
"
)
;
}
#
[
test
]
fn
test_trivial_drain
(
)
{
let
mut
s
=
HashSet
:
:
<
i32
>
:
:
new
(
)
;
for
_
in
s
.
drain
(
)
{
}
assert
!
(
s
.
is_empty
(
)
)
;
drop
(
s
)
;
let
mut
s
=
HashSet
:
:
<
i32
>
:
:
new
(
)
;
drop
(
s
.
drain
(
)
)
;
assert
!
(
s
.
is_empty
(
)
)
;
}
#
[
test
]
fn
test_drain
(
)
{
let
mut
s
:
HashSet
<
_
>
=
(
1
.
.
100
)
.
collect
(
)
;
for
_
in
0
.
.
20
{
assert_eq
!
(
s
.
len
(
)
99
)
;
{
let
mut
last_i
=
0
;
let
mut
d
=
s
.
drain
(
)
;
for
(
i
x
)
in
d
.
by_ref
(
)
.
take
(
50
)
.
enumerate
(
)
{
last_i
=
i
;
assert
!
(
x
!
=
0
)
;
}
assert_eq
!
(
last_i
49
)
;
}
for
_
in
&
s
{
panic
!
(
"
s
should
be
empty
!
"
)
;
}
s
.
extend
(
1
.
.
100
)
;
}
}
#
[
test
]
fn
test_replace
(
)
{
use
core
:
:
hash
;
#
[
derive
(
Debug
)
]
struct
Foo
(
&
'
static
str
i32
)
;
impl
PartialEq
for
Foo
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
0
=
=
other
.
0
}
}
impl
Eq
for
Foo
{
}
impl
hash
:
:
Hash
for
Foo
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
h
:
&
mut
H
)
{
self
.
0
.
hash
(
h
)
;
}
}
let
mut
s
=
HashSet
:
:
new
(
)
;
assert_eq
!
(
s
.
replace
(
Foo
(
"
a
"
1
)
)
None
)
;
assert_eq
!
(
s
.
len
(
)
1
)
;
assert_eq
!
(
s
.
replace
(
Foo
(
"
a
"
2
)
)
Some
(
Foo
(
"
a
"
1
)
)
)
;
assert_eq
!
(
s
.
len
(
)
1
)
;
let
mut
it
=
s
.
iter
(
)
;
assert_eq
!
(
it
.
next
(
)
Some
(
&
Foo
(
"
a
"
2
)
)
)
;
assert_eq
!
(
it
.
next
(
)
None
)
;
}
#
[
test
]
fn
test_extend_ref
(
)
{
let
mut
a
=
HashSet
:
:
new
(
)
;
a
.
insert
(
1
)
;
a
.
extend
(
&
[
2
3
4
]
)
;
assert_eq
!
(
a
.
len
(
)
4
)
;
assert
!
(
a
.
contains
(
&
1
)
)
;
assert
!
(
a
.
contains
(
&
2
)
)
;
assert
!
(
a
.
contains
(
&
3
)
)
;
assert
!
(
a
.
contains
(
&
4
)
)
;
let
mut
b
=
HashSet
:
:
new
(
)
;
b
.
insert
(
5
)
;
b
.
insert
(
6
)
;
a
.
extend
(
&
b
)
;
assert_eq
!
(
a
.
len
(
)
6
)
;
assert
!
(
a
.
contains
(
&
1
)
)
;
assert
!
(
a
.
contains
(
&
2
)
)
;
assert
!
(
a
.
contains
(
&
3
)
)
;
assert
!
(
a
.
contains
(
&
4
)
)
;
assert
!
(
a
.
contains
(
&
5
)
)
;
assert
!
(
a
.
contains
(
&
6
)
)
;
}
#
[
test
]
fn
test_retain
(
)
{
let
xs
=
[
1
2
3
4
5
6
]
;
let
mut
set
:
HashSet
<
i32
>
=
xs
.
iter
(
)
.
cloned
(
)
.
collect
(
)
;
set
.
retain
(
|
&
k
|
k
%
2
=
=
0
)
;
assert_eq
!
(
set
.
len
(
)
3
)
;
assert
!
(
set
.
contains
(
&
2
)
)
;
assert
!
(
set
.
contains
(
&
4
)
)
;
assert
!
(
set
.
contains
(
&
6
)
)
;
}
}
