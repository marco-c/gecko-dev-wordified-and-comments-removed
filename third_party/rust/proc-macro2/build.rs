use
std
:
:
env
;
use
std
:
:
process
:
:
{
self
Command
}
;
use
std
:
:
str
;
use
std
:
:
u32
;
fn
main
(
)
{
println
!
(
"
cargo
:
rerun
-
if
-
changed
=
build
.
rs
"
)
;
let
version
=
rustc_version
(
)
.
unwrap_or
(
RustcVersion
{
minor
:
u32
:
:
MAX
nightly
:
false
}
)
;
if
version
.
minor
<
31
{
eprintln
!
(
"
Minimum
supported
rustc
version
is
1
.
31
"
)
;
process
:
:
exit
(
1
)
;
}
let
docs_rs
=
env
:
:
var_os
(
"
DOCS_RS
"
)
.
is_some
(
)
;
let
semver_exempt
=
cfg
!
(
procmacro2_semver_exempt
)
|
|
docs_rs
;
if
semver_exempt
{
println
!
(
"
cargo
:
rustc
-
cfg
=
procmacro2_semver_exempt
"
)
;
}
if
semver_exempt
|
|
cfg
!
(
feature
=
"
span
-
locations
"
)
{
println
!
(
"
cargo
:
rustc
-
cfg
=
span_locations
"
)
;
}
if
version
.
minor
<
32
{
println
!
(
"
cargo
:
rustc
-
cfg
=
no_libprocmacro_unwind_safe
"
)
;
}
if
version
.
minor
<
34
{
println
!
(
"
cargo
:
rustc
-
cfg
=
no_try_from
"
)
;
}
if
version
.
minor
<
39
{
println
!
(
"
cargo
:
rustc
-
cfg
=
no_bind_by_move_pattern_guard
"
)
;
}
if
version
.
minor
<
44
{
println
!
(
"
cargo
:
rustc
-
cfg
=
no_lexerror_display
"
)
;
}
if
version
.
minor
<
45
{
println
!
(
"
cargo
:
rustc
-
cfg
=
no_hygiene
"
)
;
}
if
version
.
minor
<
47
{
println
!
(
"
cargo
:
rustc
-
cfg
=
no_ident_new_raw
"
)
;
}
if
version
.
minor
<
54
{
println
!
(
"
cargo
:
rustc
-
cfg
=
no_literal_from_str
"
)
;
}
if
version
.
minor
<
55
{
println
!
(
"
cargo
:
rustc
-
cfg
=
no_group_open_close
"
)
;
}
if
version
.
minor
<
57
{
println
!
(
"
cargo
:
rustc
-
cfg
=
no_is_available
"
)
;
}
if
version
.
minor
<
66
{
println
!
(
"
cargo
:
rustc
-
cfg
=
no_source_text
"
)
;
}
if
!
cfg
!
(
feature
=
"
proc
-
macro
"
)
{
return
;
}
if
version
.
nightly
|
|
!
semver_exempt
{
println
!
(
"
cargo
:
rustc
-
cfg
=
wrap_proc_macro
"
)
;
}
if
version
.
nightly
&
&
feature_allowed
(
"
proc_macro_span
"
)
&
&
feature_allowed
(
"
proc_macro_span_shrink
"
)
{
println
!
(
"
cargo
:
rustc
-
cfg
=
proc_macro_span
"
)
;
}
if
semver_exempt
&
&
version
.
nightly
{
println
!
(
"
cargo
:
rustc
-
cfg
=
super_unstable
"
)
;
}
}
struct
RustcVersion
{
minor
:
u32
nightly
:
bool
}
fn
rustc_version
(
)
-
>
Option
<
RustcVersion
>
{
let
rustc
=
env
:
:
var_os
(
"
RUSTC
"
)
?
;
let
output
=
Command
:
:
new
(
rustc
)
.
arg
(
"
-
-
version
"
)
.
output
(
)
.
ok
(
)
?
;
let
version
=
str
:
:
from_utf8
(
&
output
.
stdout
)
.
ok
(
)
?
;
let
nightly
=
version
.
contains
(
"
nightly
"
)
|
|
version
.
contains
(
"
dev
"
)
;
let
mut
pieces
=
version
.
split
(
'
.
'
)
;
if
pieces
.
next
(
)
!
=
Some
(
"
rustc
1
"
)
{
return
None
;
}
let
minor
=
pieces
.
next
(
)
?
.
parse
(
)
.
ok
(
)
?
;
Some
(
RustcVersion
{
minor
nightly
}
)
}
fn
feature_allowed
(
feature
:
&
str
)
-
>
bool
{
let
flags_var
;
let
flags_var_string
;
let
flags
=
if
let
Some
(
encoded_rustflags
)
=
env
:
:
var_os
(
"
CARGO_ENCODED_RUSTFLAGS
"
)
{
flags_var
=
encoded_rustflags
;
flags_var_string
=
flags_var
.
to_string_lossy
(
)
;
flags_var_string
.
split
(
'
\
x1f
'
)
}
else
{
return
true
;
}
;
for
mut
flag
in
flags
{
if
flag
.
starts_with
(
"
-
Z
"
)
{
flag
=
&
flag
[
"
-
Z
"
.
len
(
)
.
.
]
;
}
if
flag
.
starts_with
(
"
allow
-
features
=
"
)
{
flag
=
&
flag
[
"
allow
-
features
=
"
.
len
(
)
.
.
]
;
return
flag
.
split
(
'
'
)
.
any
(
|
allowed
|
allowed
=
=
feature
)
;
}
}
true
}
