use
std
:
:
env
;
use
std
:
:
process
:
:
Command
;
use
std
:
:
str
;
fn
main
(
)
{
println
!
(
"
cargo
:
rerun
-
if
-
changed
=
build
.
rs
"
)
;
let
target
=
env
:
:
var
(
"
TARGET
"
)
.
unwrap
(
)
;
let
version
=
match
rustc_version
(
)
{
Some
(
version
)
=
>
version
None
=
>
return
}
;
if
version
.
minor
>
=
26
{
println
!
(
"
cargo
:
rustc
-
cfg
=
u128
"
)
;
}
let
semver_exempt
=
cfg
!
(
procmacro2_semver_exempt
)
;
if
semver_exempt
{
println
!
(
"
cargo
:
rustc
-
cfg
=
procmacro2_semver_exempt
"
)
;
}
if
semver_exempt
|
|
cfg
!
(
feature
=
"
span
-
locations
"
)
{
println
!
(
"
cargo
:
rustc
-
cfg
=
span_locations
"
)
;
}
if
!
enable_use_proc_macro
(
&
target
)
{
return
;
}
println
!
(
"
cargo
:
rustc
-
cfg
=
use_proc_macro
"
)
;
if
version
.
nightly
|
|
version
.
minor
>
=
29
&
&
!
semver_exempt
{
println
!
(
"
cargo
:
rustc
-
cfg
=
wrap_proc_macro
"
)
;
}
if
version
.
minor
=
=
29
{
println
!
(
"
cargo
:
rustc
-
cfg
=
slow_extend
"
)
;
}
if
version
.
nightly
{
println
!
(
"
cargo
:
rustc
-
cfg
=
nightly
"
)
;
}
if
semver_exempt
&
&
version
.
nightly
{
println
!
(
"
cargo
:
rustc
-
cfg
=
super_unstable
"
)
;
}
}
fn
enable_use_proc_macro
(
target
:
&
str
)
-
>
bool
{
if
target
.
contains
(
"
wasm32
"
)
{
return
false
;
}
cfg
!
(
feature
=
"
proc
-
macro
"
)
}
struct
RustcVersion
{
minor
:
u32
nightly
:
bool
}
fn
rustc_version
(
)
-
>
Option
<
RustcVersion
>
{
macro_rules
!
otry
{
(
e
:
expr
)
=
>
{
match
e
{
Some
(
e
)
=
>
e
None
=
>
return
None
}
}
;
}
let
rustc
=
otry
!
(
env
:
:
var_os
(
"
RUSTC
"
)
)
;
let
output
=
otry
!
(
Command
:
:
new
(
rustc
)
.
arg
(
"
-
-
version
"
)
.
output
(
)
.
ok
(
)
)
;
let
version
=
otry
!
(
str
:
:
from_utf8
(
&
output
.
stdout
)
.
ok
(
)
)
;
let
nightly
=
version
.
contains
(
"
nightly
"
)
;
let
mut
pieces
=
version
.
split
(
'
.
'
)
;
if
pieces
.
next
(
)
!
=
Some
(
"
rustc
1
"
)
{
return
None
;
}
let
minor
=
otry
!
(
pieces
.
next
(
)
)
;
let
minor
=
otry
!
(
minor
.
parse
(
)
.
ok
(
)
)
;
Some
(
RustcVersion
{
minor
:
minor
nightly
:
nightly
}
)
}
