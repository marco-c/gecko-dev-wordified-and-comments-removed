#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
proc
-
macro2
/
1
.
0
.
59
"
)
]
#
!
[
cfg_attr
(
any
(
proc_macro_span
super_unstable
)
feature
(
proc_macro_span
proc_macro_span_shrink
)
)
]
#
!
[
cfg_attr
(
super_unstable
feature
(
proc_macro_def_site
)
)
]
#
!
[
cfg_attr
(
doc_cfg
feature
(
doc_cfg
)
)
]
#
!
[
allow
(
clippy
:
:
cast_lossless
clippy
:
:
cast_possible_truncation
clippy
:
:
doc_markdown
clippy
:
:
items_after_statements
clippy
:
:
let_underscore_untyped
clippy
:
:
manual_assert
clippy
:
:
must_use_candidate
clippy
:
:
needless_doctest_main
clippy
:
:
new_without_default
clippy
:
:
return_self_not_must_use
clippy
:
:
shadow_unrelated
clippy
:
:
trivially_copy_pass_by_ref
clippy
:
:
unnecessary_wraps
clippy
:
:
unused_self
clippy
:
:
used_underscore_binding
clippy
:
:
vec_init_then_push
)
]
#
[
cfg
(
all
(
procmacro2_semver_exempt
wrap_proc_macro
not
(
super_unstable
)
)
)
]
compile_error
!
{
"
\
Something
is
not
right
.
If
you
'
ve
tried
to
turn
on
\
procmacro2_semver_exempt
you
need
to
ensure
that
it
\
is
turned
on
for
the
compilation
of
the
proc
-
macro2
\
build
script
as
well
.
"
}
#
[
cfg
(
feature
=
"
proc
-
macro
"
)
]
extern
crate
proc_macro
;
mod
marker
;
mod
parse
;
mod
rcvec
;
#
[
cfg
(
wrap_proc_macro
)
]
mod
detection
;
#
[
doc
(
hidden
)
]
pub
mod
fallback
;
pub
mod
extra
;
#
[
cfg
(
not
(
wrap_proc_macro
)
)
]
use
crate
:
:
fallback
as
imp
;
#
[
path
=
"
wrapper
.
rs
"
]
#
[
cfg
(
wrap_proc_macro
)
]
mod
imp
;
#
[
cfg
(
span_locations
)
]
mod
convert
;
#
[
cfg
(
span_locations
)
]
mod
location
;
use
crate
:
:
extra
:
:
DelimSpan
;
use
crate
:
:
marker
:
:
Marker
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
fmt
:
:
{
self
Debug
Display
}
;
use
core
:
:
hash
:
:
{
Hash
Hasher
}
;
use
core
:
:
iter
:
:
FromIterator
;
use
core
:
:
ops
:
:
RangeBounds
;
use
core
:
:
str
:
:
FromStr
;
use
std
:
:
error
:
:
Error
;
#
[
cfg
(
procmacro2_semver_exempt
)
]
use
std
:
:
path
:
:
PathBuf
;
#
[
cfg
(
span_locations
)
]
pub
use
crate
:
:
location
:
:
LineColumn
;
#
[
derive
(
Clone
)
]
pub
struct
TokenStream
{
inner
:
imp
:
:
TokenStream
_marker
:
Marker
}
pub
struct
LexError
{
inner
:
imp
:
:
LexError
_marker
:
Marker
}
impl
TokenStream
{
fn
_new
(
inner
:
imp
:
:
TokenStream
)
-
>
Self
{
TokenStream
{
inner
_marker
:
Marker
}
}
fn
_new_fallback
(
inner
:
fallback
:
:
TokenStream
)
-
>
Self
{
TokenStream
{
inner
:
inner
.
into
(
)
_marker
:
Marker
}
}
pub
fn
new
(
)
-
>
Self
{
TokenStream
:
:
_new
(
imp
:
:
TokenStream
:
:
new
(
)
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
inner
.
is_empty
(
)
}
}
impl
Default
for
TokenStream
{
fn
default
(
)
-
>
Self
{
TokenStream
:
:
new
(
)
}
}
impl
FromStr
for
TokenStream
{
type
Err
=
LexError
;
fn
from_str
(
src
:
&
str
)
-
>
Result
<
TokenStream
LexError
>
{
let
e
=
src
.
parse
(
)
.
map_err
(
|
e
|
LexError
{
inner
:
e
_marker
:
Marker
}
)
?
;
Ok
(
TokenStream
:
:
_new
(
e
)
)
}
}
#
[
cfg
(
feature
=
"
proc
-
macro
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
proc
-
macro
"
)
)
)
]
impl
From
<
proc_macro
:
:
TokenStream
>
for
TokenStream
{
fn
from
(
inner
:
proc_macro
:
:
TokenStream
)
-
>
Self
{
TokenStream
:
:
_new
(
inner
.
into
(
)
)
}
}
#
[
cfg
(
feature
=
"
proc
-
macro
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
proc
-
macro
"
)
)
)
]
impl
From
<
TokenStream
>
for
proc_macro
:
:
TokenStream
{
fn
from
(
inner
:
TokenStream
)
-
>
Self
{
inner
.
inner
.
into
(
)
}
}
impl
From
<
TokenTree
>
for
TokenStream
{
fn
from
(
token
:
TokenTree
)
-
>
Self
{
TokenStream
:
:
_new
(
imp
:
:
TokenStream
:
:
from
(
token
)
)
}
}
impl
Extend
<
TokenTree
>
for
TokenStream
{
fn
extend
<
I
:
IntoIterator
<
Item
=
TokenTree
>
>
(
&
mut
self
streams
:
I
)
{
self
.
inner
.
extend
(
streams
)
;
}
}
impl
Extend
<
TokenStream
>
for
TokenStream
{
fn
extend
<
I
:
IntoIterator
<
Item
=
TokenStream
>
>
(
&
mut
self
streams
:
I
)
{
self
.
inner
.
extend
(
streams
.
into_iter
(
)
.
map
(
|
stream
|
stream
.
inner
)
)
;
}
}
impl
FromIterator
<
TokenTree
>
for
TokenStream
{
fn
from_iter
<
I
:
IntoIterator
<
Item
=
TokenTree
>
>
(
streams
:
I
)
-
>
Self
{
TokenStream
:
:
_new
(
streams
.
into_iter
(
)
.
collect
(
)
)
}
}
impl
FromIterator
<
TokenStream
>
for
TokenStream
{
fn
from_iter
<
I
:
IntoIterator
<
Item
=
TokenStream
>
>
(
streams
:
I
)
-
>
Self
{
TokenStream
:
:
_new
(
streams
.
into_iter
(
)
.
map
(
|
i
|
i
.
inner
)
.
collect
(
)
)
}
}
impl
Display
for
TokenStream
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
self
.
inner
f
)
}
}
impl
Debug
for
TokenStream
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
.
inner
f
)
}
}
impl
LexError
{
pub
fn
span
(
&
self
)
-
>
Span
{
Span
:
:
_new
(
self
.
inner
.
span
(
)
)
}
}
impl
Debug
for
LexError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
.
inner
f
)
}
}
impl
Display
for
LexError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
self
.
inner
f
)
}
}
impl
Error
for
LexError
{
}
#
[
cfg
(
all
(
procmacro2_semver_exempt
any
(
not
(
wrap_proc_macro
)
super_unstable
)
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
procmacro2_semver_exempt
)
)
)
]
#
[
derive
(
Clone
PartialEq
Eq
)
]
pub
struct
SourceFile
{
inner
:
imp
:
:
SourceFile
_marker
:
Marker
}
#
[
cfg
(
all
(
procmacro2_semver_exempt
any
(
not
(
wrap_proc_macro
)
super_unstable
)
)
)
]
impl
SourceFile
{
fn
_new
(
inner
:
imp
:
:
SourceFile
)
-
>
Self
{
SourceFile
{
inner
_marker
:
Marker
}
}
pub
fn
path
(
&
self
)
-
>
PathBuf
{
self
.
inner
.
path
(
)
}
pub
fn
is_real
(
&
self
)
-
>
bool
{
self
.
inner
.
is_real
(
)
}
}
#
[
cfg
(
all
(
procmacro2_semver_exempt
any
(
not
(
wrap_proc_macro
)
super_unstable
)
)
)
]
impl
Debug
for
SourceFile
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
.
inner
f
)
}
}
#
[
derive
(
Copy
Clone
)
]
pub
struct
Span
{
inner
:
imp
:
:
Span
_marker
:
Marker
}
impl
Span
{
fn
_new
(
inner
:
imp
:
:
Span
)
-
>
Self
{
Span
{
inner
_marker
:
Marker
}
}
fn
_new_fallback
(
inner
:
fallback
:
:
Span
)
-
>
Self
{
Span
{
inner
:
inner
.
into
(
)
_marker
:
Marker
}
}
pub
fn
call_site
(
)
-
>
Self
{
Span
:
:
_new
(
imp
:
:
Span
:
:
call_site
(
)
)
}
#
[
cfg
(
not
(
no_hygiene
)
)
]
pub
fn
mixed_site
(
)
-
>
Self
{
Span
:
:
_new
(
imp
:
:
Span
:
:
mixed_site
(
)
)
}
#
[
cfg
(
procmacro2_semver_exempt
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
procmacro2_semver_exempt
)
)
)
]
pub
fn
def_site
(
)
-
>
Self
{
Span
:
:
_new
(
imp
:
:
Span
:
:
def_site
(
)
)
}
pub
fn
resolved_at
(
&
self
other
:
Span
)
-
>
Span
{
Span
:
:
_new
(
self
.
inner
.
resolved_at
(
other
.
inner
)
)
}
pub
fn
located_at
(
&
self
other
:
Span
)
-
>
Span
{
Span
:
:
_new
(
self
.
inner
.
located_at
(
other
.
inner
)
)
}
#
[
cfg
(
wrap_proc_macro
)
]
pub
fn
unwrap
(
self
)
-
>
proc_macro
:
:
Span
{
self
.
inner
.
unwrap
(
)
}
#
[
cfg
(
wrap_proc_macro
)
]
#
[
doc
(
hidden
)
]
pub
fn
unstable
(
self
)
-
>
proc_macro
:
:
Span
{
self
.
unwrap
(
)
}
#
[
cfg
(
all
(
procmacro2_semver_exempt
any
(
not
(
wrap_proc_macro
)
super_unstable
)
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
procmacro2_semver_exempt
)
)
)
]
pub
fn
source_file
(
&
self
)
-
>
SourceFile
{
SourceFile
:
:
_new
(
self
.
inner
.
source_file
(
)
)
}
#
[
cfg
(
span_locations
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
span
-
locations
"
)
)
)
]
pub
fn
start
(
&
self
)
-
>
LineColumn
{
self
.
inner
.
start
(
)
}
#
[
cfg
(
span_locations
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
span
-
locations
"
)
)
)
]
pub
fn
end
(
&
self
)
-
>
LineColumn
{
self
.
inner
.
end
(
)
}
#
[
cfg
(
all
(
procmacro2_semver_exempt
any
(
not
(
wrap_proc_macro
)
super_unstable
)
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
procmacro2_semver_exempt
)
)
)
]
pub
fn
before
(
&
self
)
-
>
Span
{
Span
:
:
_new
(
self
.
inner
.
before
(
)
)
}
#
[
cfg
(
all
(
procmacro2_semver_exempt
any
(
not
(
wrap_proc_macro
)
super_unstable
)
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
procmacro2_semver_exempt
)
)
)
]
pub
fn
after
(
&
self
)
-
>
Span
{
Span
:
:
_new
(
self
.
inner
.
after
(
)
)
}
pub
fn
join
(
&
self
other
:
Span
)
-
>
Option
<
Span
>
{
self
.
inner
.
join
(
other
.
inner
)
.
map
(
Span
:
:
_new
)
}
#
[
cfg
(
procmacro2_semver_exempt
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
procmacro2_semver_exempt
)
)
)
]
pub
fn
eq
(
&
self
other
:
&
Span
)
-
>
bool
{
self
.
inner
.
eq
(
&
other
.
inner
)
}
pub
fn
source_text
(
&
self
)
-
>
Option
<
String
>
{
self
.
inner
.
source_text
(
)
}
}
impl
Debug
for
Span
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
.
inner
f
)
}
}
#
[
derive
(
Clone
)
]
pub
enum
TokenTree
{
Group
(
Group
)
Ident
(
Ident
)
Punct
(
Punct
)
Literal
(
Literal
)
}
impl
TokenTree
{
pub
fn
span
(
&
self
)
-
>
Span
{
match
self
{
TokenTree
:
:
Group
(
t
)
=
>
t
.
span
(
)
TokenTree
:
:
Ident
(
t
)
=
>
t
.
span
(
)
TokenTree
:
:
Punct
(
t
)
=
>
t
.
span
(
)
TokenTree
:
:
Literal
(
t
)
=
>
t
.
span
(
)
}
}
pub
fn
set_span
(
&
mut
self
span
:
Span
)
{
match
self
{
TokenTree
:
:
Group
(
t
)
=
>
t
.
set_span
(
span
)
TokenTree
:
:
Ident
(
t
)
=
>
t
.
set_span
(
span
)
TokenTree
:
:
Punct
(
t
)
=
>
t
.
set_span
(
span
)
TokenTree
:
:
Literal
(
t
)
=
>
t
.
set_span
(
span
)
}
}
}
impl
From
<
Group
>
for
TokenTree
{
fn
from
(
g
:
Group
)
-
>
Self
{
TokenTree
:
:
Group
(
g
)
}
}
impl
From
<
Ident
>
for
TokenTree
{
fn
from
(
g
:
Ident
)
-
>
Self
{
TokenTree
:
:
Ident
(
g
)
}
}
impl
From
<
Punct
>
for
TokenTree
{
fn
from
(
g
:
Punct
)
-
>
Self
{
TokenTree
:
:
Punct
(
g
)
}
}
impl
From
<
Literal
>
for
TokenTree
{
fn
from
(
g
:
Literal
)
-
>
Self
{
TokenTree
:
:
Literal
(
g
)
}
}
impl
Display
for
TokenTree
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
TokenTree
:
:
Group
(
t
)
=
>
Display
:
:
fmt
(
t
f
)
TokenTree
:
:
Ident
(
t
)
=
>
Display
:
:
fmt
(
t
f
)
TokenTree
:
:
Punct
(
t
)
=
>
Display
:
:
fmt
(
t
f
)
TokenTree
:
:
Literal
(
t
)
=
>
Display
:
:
fmt
(
t
f
)
}
}
}
impl
Debug
for
TokenTree
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
TokenTree
:
:
Group
(
t
)
=
>
Debug
:
:
fmt
(
t
f
)
TokenTree
:
:
Ident
(
t
)
=
>
{
let
mut
debug
=
f
.
debug_struct
(
"
Ident
"
)
;
debug
.
field
(
"
sym
"
&
format_args
!
(
"
{
}
"
t
)
)
;
imp
:
:
debug_span_field_if_nontrivial
(
&
mut
debug
t
.
span
(
)
.
inner
)
;
debug
.
finish
(
)
}
TokenTree
:
:
Punct
(
t
)
=
>
Debug
:
:
fmt
(
t
f
)
TokenTree
:
:
Literal
(
t
)
=
>
Debug
:
:
fmt
(
t
f
)
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
Group
{
inner
:
imp
:
:
Group
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
)
]
pub
enum
Delimiter
{
Parenthesis
Brace
Bracket
None
}
impl
Group
{
fn
_new
(
inner
:
imp
:
:
Group
)
-
>
Self
{
Group
{
inner
}
}
fn
_new_fallback
(
inner
:
fallback
:
:
Group
)
-
>
Self
{
Group
{
inner
:
inner
.
into
(
)
}
}
pub
fn
new
(
delimiter
:
Delimiter
stream
:
TokenStream
)
-
>
Self
{
Group
{
inner
:
imp
:
:
Group
:
:
new
(
delimiter
stream
.
inner
)
}
}
pub
fn
delimiter
(
&
self
)
-
>
Delimiter
{
self
.
inner
.
delimiter
(
)
}
pub
fn
stream
(
&
self
)
-
>
TokenStream
{
TokenStream
:
:
_new
(
self
.
inner
.
stream
(
)
)
}
pub
fn
span
(
&
self
)
-
>
Span
{
Span
:
:
_new
(
self
.
inner
.
span
(
)
)
}
pub
fn
span_open
(
&
self
)
-
>
Span
{
Span
:
:
_new
(
self
.
inner
.
span_open
(
)
)
}
pub
fn
span_close
(
&
self
)
-
>
Span
{
Span
:
:
_new
(
self
.
inner
.
span_close
(
)
)
}
pub
fn
delim_span
(
&
self
)
-
>
DelimSpan
{
DelimSpan
:
:
new
(
&
self
.
inner
)
}
pub
fn
set_span
(
&
mut
self
span
:
Span
)
{
self
.
inner
.
set_span
(
span
.
inner
)
;
}
}
impl
Display
for
Group
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
self
.
inner
formatter
)
}
}
impl
Debug
for
Group
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
.
inner
formatter
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
Punct
{
ch
:
char
spacing
:
Spacing
span
:
Span
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
)
]
pub
enum
Spacing
{
Alone
Joint
}
impl
Punct
{
pub
fn
new
(
ch
:
char
spacing
:
Spacing
)
-
>
Self
{
Punct
{
ch
spacing
span
:
Span
:
:
call_site
(
)
}
}
pub
fn
as_char
(
&
self
)
-
>
char
{
self
.
ch
}
pub
fn
spacing
(
&
self
)
-
>
Spacing
{
self
.
spacing
}
pub
fn
span
(
&
self
)
-
>
Span
{
self
.
span
}
pub
fn
set_span
(
&
mut
self
span
:
Span
)
{
self
.
span
=
span
;
}
}
impl
Display
for
Punct
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
self
.
ch
f
)
}
}
impl
Debug
for
Punct
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
mut
debug
=
fmt
.
debug_struct
(
"
Punct
"
)
;
debug
.
field
(
"
char
"
&
self
.
ch
)
;
debug
.
field
(
"
spacing
"
&
self
.
spacing
)
;
imp
:
:
debug_span_field_if_nontrivial
(
&
mut
debug
self
.
span
.
inner
)
;
debug
.
finish
(
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
Ident
{
inner
:
imp
:
:
Ident
_marker
:
Marker
}
impl
Ident
{
fn
_new
(
inner
:
imp
:
:
Ident
)
-
>
Self
{
Ident
{
inner
_marker
:
Marker
}
}
pub
fn
new
(
string
:
&
str
span
:
Span
)
-
>
Self
{
Ident
:
:
_new
(
imp
:
:
Ident
:
:
new
(
string
span
.
inner
)
)
}
pub
fn
new_raw
(
string
:
&
str
span
:
Span
)
-
>
Self
{
Ident
:
:
_new_raw
(
string
span
)
}
fn
_new_raw
(
string
:
&
str
span
:
Span
)
-
>
Self
{
Ident
:
:
_new
(
imp
:
:
Ident
:
:
new_raw
(
string
span
.
inner
)
)
}
pub
fn
span
(
&
self
)
-
>
Span
{
Span
:
:
_new
(
self
.
inner
.
span
(
)
)
}
pub
fn
set_span
(
&
mut
self
span
:
Span
)
{
self
.
inner
.
set_span
(
span
.
inner
)
;
}
}
impl
PartialEq
for
Ident
{
fn
eq
(
&
self
other
:
&
Ident
)
-
>
bool
{
self
.
inner
=
=
other
.
inner
}
}
impl
<
T
>
PartialEq
<
T
>
for
Ident
where
T
:
?
Sized
+
AsRef
<
str
>
{
fn
eq
(
&
self
other
:
&
T
)
-
>
bool
{
self
.
inner
=
=
other
}
}
impl
Eq
for
Ident
{
}
impl
PartialOrd
for
Ident
{
fn
partial_cmp
(
&
self
other
:
&
Ident
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
Ord
for
Ident
{
fn
cmp
(
&
self
other
:
&
Ident
)
-
>
Ordering
{
self
.
to_string
(
)
.
cmp
(
&
other
.
to_string
(
)
)
}
}
impl
Hash
for
Ident
{
fn
hash
<
H
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
self
.
to_string
(
)
.
hash
(
hasher
)
;
}
}
impl
Display
for
Ident
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
self
.
inner
f
)
}
}
impl
Debug
for
Ident
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
.
inner
f
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
Literal
{
inner
:
imp
:
:
Literal
_marker
:
Marker
}
macro_rules
!
suffixed_int_literals
{
(
(
name
:
ident
=
>
kind
:
ident
)
*
)
=
>
(
(
/
/
/
Creates
a
new
suffixed
integer
literal
with
the
specified
value
.
/
/
/
/
/
/
This
function
will
create
an
integer
like
1u32
where
the
integer
/
/
/
value
specified
is
the
first
part
of
the
token
and
the
integral
is
/
/
/
also
suffixed
at
the
end
.
Literals
created
from
negative
numbers
may
/
/
/
not
survive
roundtrips
through
TokenStream
or
strings
and
may
be
/
/
/
broken
into
two
tokens
(
-
and
positive
literal
)
.
/
/
/
/
/
/
Literals
created
through
this
method
have
the
Span
:
:
call_site
(
)
pub
fn
name
(
n
:
kind
)
-
>
Literal
{
Literal
:
:
_new
(
imp
:
:
Literal
:
:
name
(
n
)
)
}
)
*
)
}
macro_rules
!
unsuffixed_int_literals
{
(
(
name
:
ident
=
>
kind
:
ident
)
*
)
=
>
(
(
/
/
/
Creates
a
new
unsuffixed
integer
literal
with
the
specified
value
.
/
/
/
/
/
/
This
function
will
create
an
integer
like
1
where
the
integer
/
/
/
value
specified
is
the
first
part
of
the
token
.
No
suffix
is
/
/
/
specified
on
this
token
meaning
that
invocations
like
/
/
/
Literal
:
:
i8_unsuffixed
(
1
)
are
equivalent
to
/
/
/
Literal
:
:
u32_unsuffixed
(
1
)
.
Literals
created
from
negative
numbers
/
/
/
may
not
survive
roundtrips
through
TokenStream
or
strings
and
may
/
/
/
be
broken
into
two
tokens
(
-
and
positive
literal
)
.
/
/
/
/
/
/
Literals
created
through
this
method
have
the
Span
:
:
call_site
(
)
pub
fn
name
(
n
:
kind
)
-
>
Literal
{
Literal
:
:
_new
(
imp
:
:
Literal
:
:
name
(
n
)
)
}
)
*
)
}
impl
Literal
{
fn
_new
(
inner
:
imp
:
:
Literal
)
-
>
Self
{
Literal
{
inner
_marker
:
Marker
}
}
fn
_new_fallback
(
inner
:
fallback
:
:
Literal
)
-
>
Self
{
Literal
{
inner
:
inner
.
into
(
)
_marker
:
Marker
}
}
suffixed_int_literals
!
{
u8_suffixed
=
>
u8
u16_suffixed
=
>
u16
u32_suffixed
=
>
u32
u64_suffixed
=
>
u64
u128_suffixed
=
>
u128
usize_suffixed
=
>
usize
i8_suffixed
=
>
i8
i16_suffixed
=
>
i16
i32_suffixed
=
>
i32
i64_suffixed
=
>
i64
i128_suffixed
=
>
i128
isize_suffixed
=
>
isize
}
unsuffixed_int_literals
!
{
u8_unsuffixed
=
>
u8
u16_unsuffixed
=
>
u16
u32_unsuffixed
=
>
u32
u64_unsuffixed
=
>
u64
u128_unsuffixed
=
>
u128
usize_unsuffixed
=
>
usize
i8_unsuffixed
=
>
i8
i16_unsuffixed
=
>
i16
i32_unsuffixed
=
>
i32
i64_unsuffixed
=
>
i64
i128_unsuffixed
=
>
i128
isize_unsuffixed
=
>
isize
}
pub
fn
f64_unsuffixed
(
f
:
f64
)
-
>
Literal
{
assert
!
(
f
.
is_finite
(
)
)
;
Literal
:
:
_new
(
imp
:
:
Literal
:
:
f64_unsuffixed
(
f
)
)
}
pub
fn
f64_suffixed
(
f
:
f64
)
-
>
Literal
{
assert
!
(
f
.
is_finite
(
)
)
;
Literal
:
:
_new
(
imp
:
:
Literal
:
:
f64_suffixed
(
f
)
)
}
pub
fn
f32_unsuffixed
(
f
:
f32
)
-
>
Literal
{
assert
!
(
f
.
is_finite
(
)
)
;
Literal
:
:
_new
(
imp
:
:
Literal
:
:
f32_unsuffixed
(
f
)
)
}
pub
fn
f32_suffixed
(
f
:
f32
)
-
>
Literal
{
assert
!
(
f
.
is_finite
(
)
)
;
Literal
:
:
_new
(
imp
:
:
Literal
:
:
f32_suffixed
(
f
)
)
}
pub
fn
string
(
string
:
&
str
)
-
>
Literal
{
Literal
:
:
_new
(
imp
:
:
Literal
:
:
string
(
string
)
)
}
pub
fn
character
(
ch
:
char
)
-
>
Literal
{
Literal
:
:
_new
(
imp
:
:
Literal
:
:
character
(
ch
)
)
}
pub
fn
byte_string
(
s
:
&
[
u8
]
)
-
>
Literal
{
Literal
:
:
_new
(
imp
:
:
Literal
:
:
byte_string
(
s
)
)
}
pub
fn
span
(
&
self
)
-
>
Span
{
Span
:
:
_new
(
self
.
inner
.
span
(
)
)
}
pub
fn
set_span
(
&
mut
self
span
:
Span
)
{
self
.
inner
.
set_span
(
span
.
inner
)
;
}
pub
fn
subspan
<
R
:
RangeBounds
<
usize
>
>
(
&
self
range
:
R
)
-
>
Option
<
Span
>
{
self
.
inner
.
subspan
(
range
)
.
map
(
Span
:
:
_new
)
}
#
[
doc
(
hidden
)
]
pub
unsafe
fn
from_str_unchecked
(
repr
:
&
str
)
-
>
Self
{
Literal
:
:
_new
(
imp
:
:
Literal
:
:
from_str_unchecked
(
repr
)
)
}
}
impl
FromStr
for
Literal
{
type
Err
=
LexError
;
fn
from_str
(
repr
:
&
str
)
-
>
Result
<
Self
LexError
>
{
repr
.
parse
(
)
.
map
(
Literal
:
:
_new
)
.
map_err
(
|
inner
|
LexError
{
inner
_marker
:
Marker
}
)
}
}
impl
Debug
for
Literal
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
.
inner
f
)
}
}
impl
Display
for
Literal
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
self
.
inner
f
)
}
}
pub
mod
token_stream
{
use
crate
:
:
marker
:
:
Marker
;
use
crate
:
:
{
imp
TokenTree
}
;
use
core
:
:
fmt
:
:
{
self
Debug
}
;
pub
use
crate
:
:
TokenStream
;
#
[
derive
(
Clone
)
]
pub
struct
IntoIter
{
inner
:
imp
:
:
TokenTreeIter
_marker
:
Marker
}
impl
Iterator
for
IntoIter
{
type
Item
=
TokenTree
;
fn
next
(
&
mut
self
)
-
>
Option
<
TokenTree
>
{
self
.
inner
.
next
(
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
impl
Debug
for
IntoIter
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
TokenStream
"
)
?
;
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
impl
IntoIterator
for
TokenStream
{
type
Item
=
TokenTree
;
type
IntoIter
=
IntoIter
;
fn
into_iter
(
self
)
-
>
IntoIter
{
IntoIter
{
inner
:
self
.
inner
.
into_iter
(
)
_marker
:
Marker
}
}
}
}
