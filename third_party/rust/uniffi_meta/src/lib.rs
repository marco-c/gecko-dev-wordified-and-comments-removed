use
std
:
:
{
collections
:
:
hash_map
:
:
DefaultHasher
hash
:
:
{
Hash
Hasher
}
}
;
use
serde
:
:
{
Deserialize
Serialize
}
;
#
[
derive
(
Clone
Debug
Hash
Deserialize
Serialize
)
]
pub
struct
FnMetadata
{
pub
module_path
:
Vec
<
String
>
pub
name
:
String
pub
inputs
:
Vec
<
FnParamMetadata
>
pub
return_type
:
Option
<
Type
>
}
impl
FnMetadata
{
pub
fn
ffi_symbol_name
(
&
self
)
-
>
String
{
fn_ffi_symbol_name
(
&
self
.
module_path
&
self
.
name
checksum
(
self
)
)
}
}
#
[
derive
(
Clone
Debug
Hash
Deserialize
Serialize
)
]
pub
struct
FnParamMetadata
{
pub
name
:
String
#
[
serde
(
rename
=
"
type
"
)
]
pub
ty
:
Type
}
#
[
derive
(
Clone
Debug
Hash
Deserialize
Serialize
)
]
pub
enum
Type
{
U8
U16
U32
U64
I8
I16
I32
I64
F32
F64
Bool
String
Option
{
inner_type
:
Box
<
Type
>
}
Vec
{
inner_type
:
Box
<
Type
>
}
HashMap
{
key_type
:
Box
<
Type
>
value_type
:
Box
<
Type
>
}
}
pub
fn
checksum
<
T
:
Hash
>
(
val
:
&
T
)
-
>
u16
{
let
mut
hasher
=
DefaultHasher
:
:
new
(
)
;
val
.
hash
(
&
mut
hasher
)
;
(
hasher
.
finish
(
)
&
0x000000000000FFFF
)
as
u16
}
pub
fn
fn_ffi_symbol_name
(
mod_path
:
&
[
String
]
name
:
&
str
checksum
:
u16
)
-
>
String
{
let
mod_path
=
mod_path
.
join
(
"
__
"
)
;
format
!
(
"
_uniffi_
{
mod_path
}
_
{
name
}
_
{
checksum
:
x
}
"
)
}
#
[
derive
(
Clone
Debug
Hash
Deserialize
Serialize
)
]
pub
enum
Metadata
{
Func
(
FnMetadata
)
}
impl
From
<
FnMetadata
>
for
Metadata
{
fn
from
(
value
:
FnMetadata
)
-
>
Metadata
{
Metadata
:
:
Func
(
value
)
}
}
