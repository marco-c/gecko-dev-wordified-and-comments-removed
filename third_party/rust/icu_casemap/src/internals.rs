use
crate
:
:
greek_to_me
:
:
{
self
GreekCombiningCharacterSequenceDiacritics
GreekDiacritics
GreekPrecomposedLetterData
GreekVowel
}
;
use
crate
:
:
provider
:
:
data
:
:
{
DotType
MappingKind
}
;
use
crate
:
:
provider
:
:
exception_helpers
:
:
ExceptionSlot
;
use
crate
:
:
provider
:
:
{
CaseMap
CaseMapUnfold
}
;
use
crate
:
:
set
:
:
ClosureSink
;
use
crate
:
:
titlecase
:
:
TrailingCase
;
use
core
:
:
fmt
;
use
icu_locale_core
:
:
LanguageIdentifier
;
use
writeable
:
:
Writeable
;
const
ACUTE
:
char
=
'
\
u
{
301
}
'
;
#
[
derive
(
Copy
Clone
Default
)
]
pub
(
crate
)
struct
FoldOptions
{
exclude_special_i
:
bool
}
impl
FoldOptions
{
pub
fn
with_turkic_mappings
(
)
-
>
Self
{
Self
{
exclude_special_i
:
true
}
}
}
pub
(
crate
)
struct
StringAndWriteable
<
'
a
W
>
{
pub
string
:
&
'
a
str
pub
writeable
:
W
}
impl
<
Wr
:
Writeable
>
Writeable
for
StringAndWriteable
<
'
_
Wr
>
{
fn
write_to
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
sink
:
&
mut
W
)
-
>
fmt
:
:
Result
{
sink
.
write_str
(
self
.
string
)
?
;
self
.
writeable
.
write_to
(
sink
)
}
fn
writeable_length_hint
(
&
self
)
-
>
writeable
:
:
LengthHint
{
writeable
:
:
LengthHint
:
:
exact
(
self
.
string
.
len
(
)
)
+
self
.
writeable
.
writeable_length_hint
(
)
}
}
pub
(
crate
)
struct
FullCaseWriteable
<
'
a
'
data
const
IS_TITLE_CONTEXT
:
bool
>
{
data
:
&
'
data
CaseMap
<
'
data
>
src
:
&
'
a
str
locale
:
CaseMapLocale
mapping
:
MappingKind
titlecase_tail_casing
:
TrailingCase
}
impl
<
'
a
const
IS_TITLE_CONTEXT
:
bool
>
Writeable
for
FullCaseWriteable
<
'
a
'
_
IS_TITLE_CONTEXT
>
{
#
[
allow
(
clippy
:
:
indexing_slicing
)
]
fn
write_to
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
sink
:
&
mut
W
)
-
>
fmt
:
:
Result
{
let
src
=
self
.
src
;
let
mut
mapping
=
self
.
mapping
;
let
mut
iter
=
src
.
char_indices
(
)
;
for
(
i
c
)
in
&
mut
iter
{
let
context
=
ContextIterator
:
:
new
(
&
src
[
.
.
i
]
&
src
[
i
.
.
]
)
;
self
.
data
.
full_helper
:
:
<
IS_TITLE_CONTEXT
W
>
(
c
context
self
.
locale
mapping
sink
)
?
;
if
IS_TITLE_CONTEXT
{
if
self
.
titlecase_tail_casing
=
=
TrailingCase
:
:
Lower
{
mapping
=
MappingKind
:
:
Lower
;
}
else
{
break
;
}
}
}
if
IS_TITLE_CONTEXT
&
&
self
.
titlecase_tail_casing
=
=
TrailingCase
:
:
Unchanged
{
sink
.
write_str
(
iter
.
as_str
(
)
)
?
;
}
Ok
(
(
)
)
}
fn
writeable_length_hint
(
&
self
)
-
>
writeable
:
:
LengthHint
{
writeable
:
:
LengthHint
:
:
at_least
(
self
.
src
.
len
(
)
)
}
fn
write_to_string
(
&
self
)
-
>
alloc
:
:
borrow
:
:
Cow
<
'
a
str
>
{
writeable
:
:
to_string_or_borrow
(
self
self
.
src
.
as_bytes
(
)
)
}
}
impl
<
'
data
>
CaseMap
<
'
data
>
{
fn
simple_helper
(
&
self
c
:
char
kind
:
MappingKind
)
-
>
char
{
let
data
=
self
.
lookup_data
(
c
)
;
if
!
data
.
has_exception
(
)
{
if
data
.
is_relevant_to
(
kind
)
{
let
folded
=
c
as
i32
+
data
.
delta
(
)
as
i32
;
char
:
:
from_u32
(
folded
as
u32
)
.
unwrap_or
(
c
)
}
else
{
c
}
}
else
{
let
idx
=
data
.
exception_index
(
)
;
let
exception
=
self
.
exceptions
.
get
(
idx
)
;
if
data
.
is_relevant_to
(
kind
)
{
if
let
Some
(
simple
)
=
exception
.
get_simple_case_slot_for
(
c
)
{
return
simple
;
}
}
exception
.
slot_char_for_kind
(
kind
)
.
unwrap_or
(
c
)
}
}
#
[
inline
]
pub
(
crate
)
fn
simple_lower
(
&
self
c
:
char
)
-
>
char
{
self
.
simple_helper
(
c
MappingKind
:
:
Lower
)
}
#
[
inline
]
pub
(
crate
)
fn
simple_upper
(
&
self
c
:
char
)
-
>
char
{
self
.
simple_helper
(
c
MappingKind
:
:
Upper
)
}
#
[
inline
]
pub
(
crate
)
fn
simple_title
(
&
self
c
:
char
)
-
>
char
{
self
.
simple_helper
(
c
MappingKind
:
:
Title
)
}
#
[
inline
]
pub
(
crate
)
fn
simple_fold
(
&
self
c
:
char
options
:
FoldOptions
)
-
>
char
{
let
data
=
self
.
lookup_data
(
c
)
;
if
!
data
.
has_exception
(
)
{
if
data
.
is_upper_or_title
(
)
{
let
folded
=
c
as
i32
+
data
.
delta
(
)
as
i32
;
char
:
:
from_u32
(
folded
as
u32
)
.
unwrap_or
(
c
)
}
else
{
c
}
}
else
{
let
idx
=
data
.
exception_index
(
)
;
let
exception
=
self
.
exceptions
.
get
(
idx
)
;
if
exception
.
bits
.
has_conditional_fold
(
)
{
self
.
simple_fold_special_case
(
c
options
)
}
else
if
exception
.
bits
.
no_simple_case_folding
(
)
{
c
}
else
if
data
.
is_upper_or_title
(
)
&
&
exception
.
has_slot
(
ExceptionSlot
:
:
Delta
)
{
exception
.
get_simple_case_slot_for
(
c
)
.
unwrap_or
(
'
\
0
'
)
}
else
if
let
Some
(
slot_char
)
=
exception
.
slot_char_for_kind
(
MappingKind
:
:
Fold
)
{
slot_char
}
else
{
c
}
}
}
fn
dot_type
(
&
self
c
:
char
)
-
>
DotType
{
let
data
=
self
.
lookup_data
(
c
)
;
if
!
data
.
has_exception
(
)
{
data
.
dot_type
(
)
}
else
{
let
idx
=
data
.
exception_index
(
)
;
self
.
exceptions
.
get
(
idx
)
.
bits
.
dot_type
(
)
}
}
#
[
allow
(
dead_code
)
]
fn
is_case_sensitive
(
&
self
c
:
char
)
-
>
bool
{
let
data
=
self
.
lookup_data
(
c
)
;
if
!
data
.
has_exception
(
)
{
data
.
is_sensitive
(
)
}
else
{
let
idx
=
data
.
exception_index
(
)
;
self
.
exceptions
.
get
(
idx
)
.
bits
.
is_sensitive
(
)
}
}
pub
(
crate
)
fn
is_cased
(
&
self
c
:
char
)
-
>
bool
{
self
.
lookup_data
(
c
)
.
case_type
(
)
.
is_some
(
)
}
#
[
inline
(
always
)
]
fn
full_helper
<
const
IS_TITLE_CONTEXT
:
bool
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
c
:
char
context
:
ContextIterator
locale
:
CaseMapLocale
kind
:
MappingKind
sink
:
&
mut
W
)
-
>
fmt
:
:
Result
{
debug_assert
!
(
kind
!
=
MappingKind
:
:
Title
|
|
IS_TITLE_CONTEXT
)
;
debug_assert
!
(
!
IS_TITLE_CONTEXT
|
|
kind
=
=
MappingKind
:
:
Title
|
|
kind
=
=
MappingKind
:
:
Lower
)
;
if
IS_TITLE_CONTEXT
&
&
locale
=
=
CaseMapLocale
:
:
Dutch
&
&
kind
=
=
MappingKind
:
:
Lower
{
if
(
c
=
=
'
j
'
|
|
c
=
=
'
J
'
)
&
&
context
.
is_dutch_ij_pair_at_beginning
(
self
)
{
return
sink
.
write_char
(
'
J
'
)
;
}
}
if
!
IS_TITLE_CONTEXT
&
&
locale
=
=
CaseMapLocale
:
:
Greek
&
&
kind
=
=
MappingKind
:
:
Upper
{
if
greek_to_me
:
:
is_greek_diacritic_except_ypogegrammeni
(
c
)
&
&
context
.
preceded_by_greek_letter
(
)
{
return
Ok
(
(
)
)
;
}
let
data
=
greek_to_me
:
:
get_data
(
c
)
;
match
data
{
Some
(
GreekPrecomposedLetterData
:
:
Vowel
(
vowel
mut
precomposed_diacritics
)
)
=
>
{
let
mut
diacritics
=
context
.
add_greek_diacritics
(
precomposed_diacritics
)
;
if
!
diacritics
.
dialytika
&
&
(
vowel
=
=
GreekVowel
:
:
|
|
vowel
=
=
GreekVowel
:
:
)
{
if
let
Some
(
preceding_vowel
)
=
context
.
preceding_greek_vowel_diacritics
(
)
{
if
!
preceding_vowel
.
combining
.
dialytika
&
&
!
preceding_vowel
.
precomposed
.
dialytika
{
if
preceding_vowel
.
combining
.
accented
{
diacritics
.
dialytika
=
true
;
}
else
{
precomposed_diacritics
.
dialytika
=
preceding_vowel
.
precomposed
.
accented
;
}
}
}
}
match
vowel
{
GreekVowel
:
:
=
>
{
if
diacritics
.
accented
&
&
!
context
.
followed_by_cased_letter
(
self
)
&
&
!
context
.
preceded_by_cased_letter
(
self
)
&
&
!
diacritics
.
ypogegrammeni
{
if
precomposed_diacritics
.
accented
{
sink
.
write_char
(
'
'
)
?
;
}
else
{
sink
.
write_char
(
'
'
)
?
;
sink
.
write_char
(
greek_to_me
:
:
TONOS
)
?
;
}
}
else
{
sink
.
write_char
(
'
'
)
?
;
}
}
GreekVowel
:
:
=
>
sink
.
write_char
(
if
precomposed_diacritics
.
dialytika
{
diacritics
.
dialytika
=
false
;
'
'
}
else
{
vowel
.
into
(
)
}
)
?
GreekVowel
:
:
=
>
sink
.
write_char
(
if
precomposed_diacritics
.
dialytika
{
diacritics
.
dialytika
=
false
;
'
'
}
else
{
vowel
.
into
(
)
}
)
?
_
=
>
sink
.
write_char
(
vowel
.
into
(
)
)
?
}
;
if
diacritics
.
dialytika
{
sink
.
write_char
(
greek_to_me
:
:
DIALYTIKA
)
?
;
}
if
precomposed_diacritics
.
ypogegrammeni
{
sink
.
write_char
(
'
'
)
?
;
}
return
Ok
(
(
)
)
;
}
Some
(
GreekPrecomposedLetterData
:
:
Consonant
(
true
)
)
=
>
{
sink
.
write_char
(
greek_to_me
:
:
CAPITAL_RHO
)
?
;
return
Ok
(
(
)
)
;
}
_
=
>
(
)
}
}
let
data
=
self
.
lookup_data
(
c
)
;
if
!
data
.
has_exception
(
)
{
if
data
.
is_relevant_to
(
kind
)
{
let
mapped
=
c
as
i32
+
data
.
delta
(
)
as
i32
;
let
mapped
=
char
:
:
from_u32
(
mapped
as
u32
)
.
unwrap_or
(
c
)
;
sink
.
write_char
(
mapped
)
}
else
{
sink
.
write_char
(
c
)
}
}
else
{
let
idx
=
data
.
exception_index
(
)
;
let
exception
=
self
.
exceptions
.
get
(
idx
)
;
if
exception
.
bits
.
has_conditional_special
(
)
{
if
let
Some
(
special
)
=
match
kind
{
MappingKind
:
:
Lower
=
>
{
self
.
full_lower_special_case
:
:
<
IS_TITLE_CONTEXT
>
(
c
context
locale
)
}
MappingKind
:
:
Fold
=
>
self
.
full_fold_special_case
(
c
context
locale
)
MappingKind
:
:
Upper
|
MappingKind
:
:
Title
=
>
self
.
full_upper_or_title_special_case
:
:
<
IS_TITLE_CONTEXT
>
(
c
context
locale
)
}
{
return
special
.
write_to
(
sink
)
;
}
}
if
let
Some
(
mapped_string
)
=
exception
.
get_fullmappings_slot_for_kind
(
kind
)
{
if
!
mapped_string
.
is_empty
(
)
{
return
sink
.
write_str
(
mapped_string
)
;
}
}
if
kind
=
=
MappingKind
:
:
Fold
&
&
exception
.
bits
.
no_simple_case_folding
(
)
{
return
sink
.
write_char
(
c
)
;
}
if
data
.
is_relevant_to
(
kind
)
{
if
let
Some
(
simple
)
=
exception
.
get_simple_case_slot_for
(
c
)
{
return
sink
.
write_char
(
simple
)
;
}
}
if
let
Some
(
slot_char
)
=
exception
.
slot_char_for_kind
(
kind
)
{
sink
.
write_char
(
slot_char
)
}
else
{
sink
.
write_char
(
c
)
}
}
}
const
I_DOT
:
&
'
static
str
=
"
\
u
{
69
}
\
u
{
307
}
"
;
const
J_DOT
:
&
'
static
str
=
"
\
u
{
6a
}
\
u
{
307
}
"
;
const
I_OGONEK_DOT
:
&
'
static
str
=
"
\
u
{
12f
}
\
u
{
307
}
"
;
const
I_DOT_GRAVE
:
&
'
static
str
=
"
\
u
{
69
}
\
u
{
307
}
\
u
{
300
}
"
;
const
I_DOT_ACUTE
:
&
'
static
str
=
"
\
u
{
69
}
\
u
{
307
}
\
u
{
301
}
"
;
const
I_DOT_TILDE
:
&
'
static
str
=
"
\
u
{
69
}
\
u
{
307
}
\
u
{
303
}
"
;
fn
simple_fold_special_case
(
&
self
c
:
char
options
:
FoldOptions
)
-
>
char
{
debug_assert
!
(
c
=
=
'
\
u
{
49
}
'
|
|
c
=
=
'
\
u
{
130
}
'
)
;
let
is_turkic
=
options
.
exclude_special_i
;
match
(
c
is_turkic
)
{
(
'
\
u
{
49
}
'
true
)
=
>
'
\
u
{
131
}
'
(
'
\
u
{
130
}
'
true
)
=
>
'
\
u
{
69
}
'
(
'
\
u
{
49
}
'
false
)
=
>
'
\
u
{
69
}
'
(
c
_
)
=
>
c
}
}
fn
full_lower_special_case
<
const
IS_TITLE_CONTEXT
:
bool
>
(
&
self
c
:
char
context
:
ContextIterator
locale
:
CaseMapLocale
)
-
>
Option
<
FullMappingResult
>
{
if
locale
=
=
CaseMapLocale
:
:
Lithuanian
{
if
c
=
=
'
I
'
&
&
context
.
followed_by_more_above
(
self
)
{
return
Some
(
FullMappingResult
:
:
String
(
Self
:
:
I_DOT
)
)
;
}
else
if
c
=
=
'
J
'
&
&
context
.
followed_by_more_above
(
self
)
{
return
Some
(
FullMappingResult
:
:
String
(
Self
:
:
J_DOT
)
)
;
}
else
if
c
=
=
'
\
u
{
12e
}
'
&
&
context
.
followed_by_more_above
(
self
)
{
return
Some
(
FullMappingResult
:
:
String
(
Self
:
:
I_OGONEK_DOT
)
)
;
}
if
c
=
=
'
\
u
{
cc
}
'
{
return
Some
(
FullMappingResult
:
:
String
(
Self
:
:
I_DOT_GRAVE
)
)
;
}
else
if
c
=
=
'
\
u
{
cd
}
'
{
return
Some
(
FullMappingResult
:
:
String
(
Self
:
:
I_DOT_ACUTE
)
)
;
}
else
if
c
=
=
'
\
u
{
128
}
'
{
return
Some
(
FullMappingResult
:
:
String
(
Self
:
:
I_DOT_TILDE
)
)
;
}
}
if
locale
=
=
CaseMapLocale
:
:
Turkish
{
if
c
=
=
'
\
u
{
130
}
'
{
return
Some
(
FullMappingResult
:
:
CodePoint
(
'
i
'
)
)
;
}
else
if
c
=
=
'
\
u
{
307
}
'
&
&
context
.
preceded_by_capital_i
:
:
<
IS_TITLE_CONTEXT
>
(
self
)
{
return
Some
(
FullMappingResult
:
:
Remove
)
;
}
else
if
c
=
=
'
I
'
&
&
!
context
.
followed_by_dot_above
(
self
)
{
return
Some
(
FullMappingResult
:
:
CodePoint
(
'
\
u
{
131
}
'
)
)
;
}
}
if
c
=
=
'
\
u
{
130
}
'
{
return
Some
(
FullMappingResult
:
:
String
(
Self
:
:
I_DOT
)
)
;
}
if
c
=
=
'
\
u
{
3a3
}
'
&
&
context
.
preceded_by_cased_letter
(
self
)
&
&
!
context
.
followed_by_cased_letter
(
self
)
{
return
Some
(
FullMappingResult
:
:
CodePoint
(
'
\
u
{
3c2
}
'
)
)
;
}
None
}
fn
full_upper_or_title_special_case
<
const
IS_TITLE_CONTEXT
:
bool
>
(
&
self
c
:
char
context
:
ContextIterator
locale
:
CaseMapLocale
)
-
>
Option
<
FullMappingResult
>
{
if
locale
=
=
CaseMapLocale
:
:
Turkish
&
&
c
=
=
'
i
'
{
return
Some
(
FullMappingResult
:
:
CodePoint
(
'
\
u
{
130
}
'
)
)
;
}
if
locale
=
=
CaseMapLocale
:
:
Lithuanian
&
&
c
=
=
'
\
u
{
307
}
'
&
&
context
.
preceded_by_soft_dotted
(
self
)
{
return
Some
(
FullMappingResult
:
:
Remove
)
;
}
if
c
=
=
'
\
u
{
587
}
'
{
return
match
(
locale
IS_TITLE_CONTEXT
)
{
(
CaseMapLocale
:
:
Armenian
false
)
=
>
Some
(
FullMappingResult
:
:
String
(
"
"
)
)
(
CaseMapLocale
:
:
Armenian
true
)
=
>
Some
(
FullMappingResult
:
:
String
(
"
"
)
)
(
_
false
)
=
>
Some
(
FullMappingResult
:
:
String
(
"
"
)
)
(
_
true
)
=
>
Some
(
FullMappingResult
:
:
String
(
"
"
)
)
}
;
}
None
}
fn
full_fold_special_case
(
&
self
c
:
char
_context
:
ContextIterator
locale
:
CaseMapLocale
)
-
>
Option
<
FullMappingResult
>
{
let
is_turkic
=
locale
=
=
CaseMapLocale
:
:
Turkish
;
match
(
c
is_turkic
)
{
(
'
\
u
{
49
}
'
true
)
=
>
Some
(
FullMappingResult
:
:
CodePoint
(
'
\
u
{
131
}
'
)
)
(
'
\
u
{
130
}
'
true
)
=
>
Some
(
FullMappingResult
:
:
CodePoint
(
'
\
u
{
69
}
'
)
)
(
'
\
u
{
49
}
'
false
)
=
>
Some
(
FullMappingResult
:
:
CodePoint
(
'
\
u
{
69
}
'
)
)
(
'
\
u
{
130
}
'
false
)
=
>
Some
(
FullMappingResult
:
:
String
(
Self
:
:
I_DOT
)
)
(
_
_
)
=
>
None
}
}
pub
(
crate
)
fn
full_helper_writeable
<
'
a
:
'
data
const
IS_TITLE_CONTEXT
:
bool
>
(
&
'
data
self
src
:
&
'
a
str
locale
:
CaseMapLocale
mapping
:
MappingKind
titlecase_tail_casing
:
TrailingCase
)
-
>
FullCaseWriteable
<
'
a
'
data
IS_TITLE_CONTEXT
>
{
debug_assert
!
(
IS_TITLE_CONTEXT
=
=
(
mapping
=
=
MappingKind
:
:
Title
)
)
;
FullCaseWriteable
:
:
<
IS_TITLE_CONTEXT
>
{
data
:
self
src
locale
mapping
titlecase_tail_casing
}
}
pub
(
crate
)
fn
add_case_closure_to
<
S
:
ClosureSink
>
(
&
self
c
:
char
set
:
&
mut
S
)
{
match
c
{
'
\
u
{
49
}
'
=
>
{
set
.
add_char
(
'
\
u
{
69
}
'
)
;
return
;
}
'
\
u
{
69
}
'
=
>
{
set
.
add_char
(
'
\
u
{
49
}
'
)
;
return
;
}
'
\
u
{
130
}
'
=
>
{
set
.
add_string
(
Self
:
:
I_DOT
)
;
return
;
}
'
\
u
{
131
}
'
=
>
{
return
;
}
_
=
>
{
}
}
let
data
=
self
.
lookup_data
(
c
)
;
if
!
data
.
has_exception
(
)
{
if
data
.
case_type
(
)
.
is_some
(
)
{
let
delta
=
data
.
delta
(
)
as
i32
;
if
delta
!
=
0
{
let
codepoint
=
c
as
i32
+
delta
;
let
mapped
=
char
:
:
from_u32
(
codepoint
as
u32
)
.
unwrap_or
(
c
)
;
set
.
add_char
(
mapped
)
;
}
}
return
;
}
let
idx
=
data
.
exception_index
(
)
;
let
exception
=
self
.
exceptions
.
get
(
idx
)
;
for
slot
in
[
ExceptionSlot
:
:
Lower
ExceptionSlot
:
:
Fold
ExceptionSlot
:
:
Upper
ExceptionSlot
:
:
Title
]
{
if
let
Some
(
simple
)
=
exception
.
get_char_slot
(
slot
)
{
set
.
add_char
(
simple
)
;
}
}
if
let
Some
(
simple
)
=
exception
.
get_simple_case_slot_for
(
c
)
{
set
.
add_char
(
simple
)
;
}
exception
.
add_full_and_closure_mappings
(
set
)
;
}
pub
(
crate
)
fn
add_string_case_closure_to
<
S
:
ClosureSink
>
(
&
self
s
:
&
str
set
:
&
mut
S
unfold_data
:
&
CaseMapUnfold
)
-
>
bool
{
if
s
.
chars
(
)
.
count
(
)
<
=
1
{
return
false
;
}
match
unfold_data
.
get
(
s
)
{
Some
(
closure_string
)
=
>
{
for
c
in
closure_string
.
chars
(
)
{
set
.
add_char
(
c
)
;
self
.
add_case_closure_to
(
c
set
)
;
}
true
}
None
=
>
false
}
}
}
#
[
derive
(
Copy
Clone
Eq
PartialEq
Debug
)
]
pub
enum
CaseMapLocale
{
Root
Turkish
Lithuanian
Greek
Dutch
Armenian
}
impl
CaseMapLocale
{
pub
const
fn
from_langid
(
langid
:
&
LanguageIdentifier
)
-
>
Self
{
use
icu_locale_core
:
:
subtags
:
:
{
language
Language
}
;
const
TR
:
Language
=
language
!
(
"
tr
"
)
;
const
AZ
:
Language
=
language
!
(
"
az
"
)
;
const
LT
:
Language
=
language
!
(
"
lt
"
)
;
const
EL
:
Language
=
language
!
(
"
el
"
)
;
const
NL
:
Language
=
language
!
(
"
nl
"
)
;
const
HY
:
Language
=
language
!
(
"
hy
"
)
;
match
langid
.
language
{
TR
|
AZ
=
>
Self
:
:
Turkish
LT
=
>
Self
:
:
Lithuanian
EL
=
>
Self
:
:
Greek
NL
=
>
Self
:
:
Dutch
HY
=
>
Self
:
:
Armenian
_
=
>
Self
:
:
Root
}
}
}
pub
enum
FullMappingResult
<
'
a
>
{
Remove
CodePoint
(
char
)
String
(
&
'
a
str
)
}
impl
FullMappingResult
<
'
_
>
{
#
[
allow
(
dead_code
)
]
fn
add_to_set
<
S
:
ClosureSink
>
(
&
self
set
:
&
mut
S
)
{
match
*
self
{
FullMappingResult
:
:
CodePoint
(
c
)
=
>
set
.
add_char
(
c
)
FullMappingResult
:
:
String
(
s
)
=
>
set
.
add_string
(
s
)
FullMappingResult
:
:
Remove
=
>
{
}
}
}
}
impl
Writeable
for
FullMappingResult
<
'
_
>
{
fn
write_to
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
sink
:
&
mut
W
)
-
>
fmt
:
:
Result
{
match
*
self
{
FullMappingResult
:
:
CodePoint
(
c
)
=
>
sink
.
write_char
(
c
)
FullMappingResult
:
:
String
(
s
)
=
>
sink
.
write_str
(
s
)
FullMappingResult
:
:
Remove
=
>
Ok
(
(
)
)
}
}
}
pub
(
crate
)
struct
ContextIterator
<
'
a
>
{
before
:
&
'
a
str
after
:
&
'
a
str
}
impl
<
'
a
>
ContextIterator
<
'
a
>
{
pub
fn
new
(
before
:
&
'
a
str
char_and_after
:
&
'
a
str
)
-
>
Self
{
let
mut
char_and_after
=
char_and_after
.
chars
(
)
;
char_and_after
.
next
(
)
;
let
after
=
char_and_after
.
as_str
(
)
;
Self
{
before
after
}
}
fn
add_greek_diacritics
(
&
self
mut
diacritics
:
GreekDiacritics
)
-
>
GreekDiacritics
{
diacritics
.
consume_greek_diacritics
(
self
.
after
)
;
diacritics
}
fn
preceded_by_greek_letter
(
&
self
)
-
>
bool
{
greek_to_me
:
:
preceded_by_greek_letter
(
self
.
before
)
}
fn
preceding_greek_vowel_diacritics
(
&
self
)
-
>
Option
<
GreekCombiningCharacterSequenceDiacritics
>
{
greek_to_me
:
:
preceding_greek_vowel_diacritics
(
self
.
before
)
}
fn
preceded_by_soft_dotted
(
&
self
mapping
:
&
CaseMap
)
-
>
bool
{
for
c
in
self
.
before
.
chars
(
)
.
rev
(
)
{
match
mapping
.
dot_type
(
c
)
{
DotType
:
:
SoftDotted
=
>
return
true
DotType
:
:
OtherAccent
=
>
continue
_
=
>
return
false
}
}
false
}
fn
preceded_by_capital_i
<
const
I_MUST_NOT_START_STRING
:
bool
>
(
&
self
mapping
:
&
CaseMap
)
-
>
bool
{
let
mut
iter
=
self
.
before
.
chars
(
)
.
rev
(
)
;
while
let
Some
(
c
)
=
iter
.
next
(
)
{
if
c
=
=
'
I
'
{
if
I_MUST_NOT_START_STRING
{
return
iter
.
next
(
)
.
is_some
(
)
;
}
else
{
return
true
;
}
}
if
mapping
.
dot_type
(
c
)
!
=
DotType
:
:
OtherAccent
{
break
;
}
}
false
}
fn
preceded_by_cased_letter
(
&
self
mapping
:
&
CaseMap
)
-
>
bool
{
for
c
in
self
.
before
.
chars
(
)
.
rev
(
)
{
let
data
=
mapping
.
lookup_data
(
c
)
;
if
!
data
.
is_ignorable
(
)
{
return
data
.
case_type
(
)
.
is_some
(
)
;
}
}
false
}
fn
followed_by_cased_letter
(
&
self
mapping
:
&
CaseMap
)
-
>
bool
{
for
c
in
self
.
after
.
chars
(
)
{
let
data
=
mapping
.
lookup_data
(
c
)
;
if
!
data
.
is_ignorable
(
)
{
return
data
.
case_type
(
)
.
is_some
(
)
;
}
}
false
}
fn
followed_by_more_above
(
&
self
mapping
:
&
CaseMap
)
-
>
bool
{
for
c
in
self
.
after
.
chars
(
)
{
match
mapping
.
dot_type
(
c
)
{
DotType
:
:
Above
=
>
return
true
DotType
:
:
OtherAccent
=
>
continue
_
=
>
return
false
}
}
false
}
fn
followed_by_dot_above
(
&
self
mapping
:
&
CaseMap
)
-
>
bool
{
for
c
in
self
.
after
.
chars
(
)
{
if
c
=
=
'
\
u
{
307
}
'
{
return
true
;
}
if
mapping
.
dot_type
(
c
)
!
=
DotType
:
:
OtherAccent
{
return
false
;
}
}
false
}
fn
is_dutch_ij_pair_at_beginning
(
&
self
mapping
:
&
CaseMap
)
-
>
bool
{
let
mut
before
=
self
.
before
.
chars
(
)
.
rev
(
)
;
let
mut
i_has_acute
=
false
;
loop
{
match
before
.
next
(
)
{
Some
(
'
i
'
)
|
Some
(
'
I
'
)
=
>
break
Some
(
'
'
)
|
Some
(
'
'
)
=
>
{
i_has_acute
=
true
;
break
;
}
Some
(
ACUTE
)
=
>
i_has_acute
=
true
_
=
>
return
false
}
}
if
before
.
next
(
)
.
is_some
(
)
{
return
false
;
}
let
mut
j_has_acute
=
false
;
for
c
in
self
.
after
.
chars
(
)
{
if
c
=
=
ACUTE
{
j_has_acute
=
true
;
continue
;
}
match
mapping
.
dot_type
(
c
)
{
DotType
:
:
NoDot
|
DotType
:
:
SoftDotted
=
>
break
_
=
>
return
false
}
}
!
(
j_has_acute
^
i_has_acute
)
}
}
