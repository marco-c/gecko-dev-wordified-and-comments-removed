use
crate
:
:
internals
:
:
{
CaseMapLocale
FoldOptions
FullCaseWriteable
StringAndWriteable
}
;
use
crate
:
:
provider
:
:
data
:
:
MappingKind
;
use
crate
:
:
provider
:
:
CaseMap
;
use
crate
:
:
provider
:
:
CaseMapV1
;
use
crate
:
:
set
:
:
ClosureSink
;
use
crate
:
:
titlecase
:
:
{
LeadingAdjustment
TitlecaseOptions
TrailingCase
}
;
use
alloc
:
:
borrow
:
:
Cow
;
use
icu_locale_core
:
:
LanguageIdentifier
;
use
icu_provider
:
:
prelude
:
:
*
;
use
writeable
:
:
Writeable
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
CaseMapper
{
pub
(
crate
)
data
:
DataPayload
<
CaseMapV1
>
}
impl
AsRef
<
CaseMapper
>
for
CaseMapper
{
fn
as_ref
(
&
self
)
-
>
&
CaseMapper
{
self
}
}
#
[
derive
(
Clone
Debug
Copy
)
]
pub
struct
CaseMapperBorrowed
<
'
a
>
{
pub
(
crate
)
data
:
&
'
a
CaseMap
<
'
a
>
}
impl
CaseMapperBorrowed
<
'
static
>
{
pub
const
fn
static_to_owned
(
self
)
-
>
CaseMapper
{
CaseMapper
{
data
:
DataPayload
:
:
from_static_ref
(
self
.
data
)
}
}
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
pub
const
fn
new
(
)
-
>
Self
{
Self
{
data
:
crate
:
:
provider
:
:
Baked
:
:
SINGLETON_CASE_MAP_V1
}
}
}
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
impl
Default
for
CaseMapperBorrowed
<
'
static
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
'
a
>
CaseMapperBorrowed
<
'
a
>
{
pub
fn
lowercase
(
self
src
:
&
'
a
str
langid
:
&
LanguageIdentifier
)
-
>
impl
Writeable
+
'
a
{
self
.
data
.
full_helper_writeable
:
:
<
false
>
(
src
CaseMapLocale
:
:
from_langid
(
langid
)
MappingKind
:
:
Lower
TrailingCase
:
:
default
(
)
)
}
pub
fn
uppercase
(
self
src
:
&
'
a
str
langid
:
&
LanguageIdentifier
)
-
>
impl
Writeable
+
'
a
{
self
.
data
.
full_helper_writeable
:
:
<
false
>
(
src
CaseMapLocale
:
:
from_langid
(
langid
)
MappingKind
:
:
Upper
TrailingCase
:
:
default
(
)
)
}
pub
fn
titlecase_segment_with_only_case_data
(
self
src
:
&
'
a
str
langid
:
&
LanguageIdentifier
options
:
TitlecaseOptions
)
-
>
impl
Writeable
+
'
a
{
self
.
titlecase_segment_with_adjustment
(
src
langid
options
|
data
ch
|
data
.
is_cased
(
ch
)
)
}
pub
(
crate
)
fn
titlecase_segment_with_adjustment
(
self
src
:
&
'
a
str
langid
:
&
LanguageIdentifier
options
:
TitlecaseOptions
char_is_lead
:
impl
Fn
(
&
CaseMap
char
)
-
>
bool
)
-
>
StringAndWriteable
<
'
a
FullCaseWriteable
<
'
a
'
a
true
>
>
{
let
(
head
rest
)
=
match
options
.
leading_adjustment
.
unwrap_or_default
(
)
{
LeadingAdjustment
:
:
Auto
|
LeadingAdjustment
:
:
ToCased
=
>
{
let
first_cased
=
src
.
char_indices
(
)
.
find
(
|
(
_i
ch
)
|
char_is_lead
(
self
.
data
*
ch
)
)
;
if
let
Some
(
(
first_cased
_ch
)
)
=
first_cased
{
(
src
.
get
(
.
.
first_cased
)
.
unwrap_or
(
"
"
)
src
.
get
(
first_cased
.
.
)
.
unwrap_or
(
"
"
)
)
}
else
{
(
src
"
"
)
}
}
LeadingAdjustment
:
:
None
=
>
(
"
"
src
)
}
;
let
writeable
=
self
.
data
.
full_helper_writeable
:
:
<
true
>
(
rest
CaseMapLocale
:
:
from_langid
(
langid
)
MappingKind
:
:
Title
options
.
trailing_case
.
unwrap_or_default
(
)
)
;
StringAndWriteable
{
string
:
head
writeable
}
}
pub
fn
fold
(
self
src
:
&
'
a
str
)
-
>
impl
Writeable
+
'
a
{
self
.
data
.
full_helper_writeable
:
:
<
false
>
(
src
CaseMapLocale
:
:
Root
MappingKind
:
:
Fold
TrailingCase
:
:
default
(
)
)
}
pub
fn
fold_turkic
(
self
src
:
&
'
a
str
)
-
>
impl
Writeable
+
'
a
{
self
.
data
.
full_helper_writeable
:
:
<
false
>
(
src
CaseMapLocale
:
:
Turkish
MappingKind
:
:
Fold
TrailingCase
:
:
default
(
)
)
}
pub
fn
lowercase_to_string
<
'
s
>
(
self
src
:
&
'
s
str
langid
:
&
LanguageIdentifier
)
-
>
Cow
<
'
s
str
>
{
writeable
:
:
to_string_or_borrow
(
&
self
.
lowercase
(
src
langid
)
src
.
as_bytes
(
)
)
}
pub
fn
uppercase_to_string
<
'
s
>
(
self
src
:
&
'
s
str
langid
:
&
LanguageIdentifier
)
-
>
Cow
<
'
s
str
>
{
writeable
:
:
to_string_or_borrow
(
&
self
.
uppercase
(
src
langid
)
src
.
as_bytes
(
)
)
}
pub
fn
titlecase_segment_with_only_case_data_to_string
<
'
s
>
(
self
src
:
&
'
s
str
langid
:
&
LanguageIdentifier
options
:
TitlecaseOptions
)
-
>
Cow
<
'
s
str
>
{
writeable
:
:
to_string_or_borrow
(
&
self
.
titlecase_segment_with_only_case_data
(
src
langid
options
)
src
.
as_bytes
(
)
)
}
pub
fn
fold_string
(
self
src
:
&
str
)
-
>
Cow
<
str
>
{
writeable
:
:
to_string_or_borrow
(
&
self
.
fold
(
src
)
src
.
as_bytes
(
)
)
}
pub
fn
fold_turkic_string
(
self
src
:
&
str
)
-
>
Cow
<
str
>
{
writeable
:
:
to_string_or_borrow
(
&
self
.
fold_turkic
(
src
)
src
.
as_bytes
(
)
)
}
pub
fn
add_case_closure_to
<
S
:
ClosureSink
>
(
self
c
:
char
set
:
&
mut
S
)
{
self
.
data
.
add_case_closure_to
(
c
set
)
;
}
pub
fn
simple_lowercase
(
self
c
:
char
)
-
>
char
{
self
.
data
.
simple_lower
(
c
)
}
pub
fn
simple_uppercase
(
self
c
:
char
)
-
>
char
{
self
.
data
.
simple_upper
(
c
)
}
pub
fn
simple_titlecase
(
self
c
:
char
)
-
>
char
{
self
.
data
.
simple_title
(
c
)
}
pub
fn
simple_fold
(
self
c
:
char
)
-
>
char
{
self
.
data
.
simple_fold
(
c
FoldOptions
:
:
default
(
)
)
}
pub
fn
simple_fold_turkic
(
self
c
:
char
)
-
>
char
{
self
.
data
.
simple_fold
(
c
FoldOptions
:
:
with_turkic_mappings
(
)
)
}
}
impl
CaseMapper
{
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
#
[
allow
(
clippy
:
:
new_ret_no_self
)
]
pub
const
fn
new
(
)
-
>
CaseMapperBorrowed
<
'
static
>
{
CaseMapperBorrowed
:
:
new
(
)
}
pub
fn
as_borrowed
(
&
self
)
-
>
CaseMapperBorrowed
<
'
_
>
{
CaseMapperBorrowed
{
data
:
self
.
data
.
get
(
)
}
}
icu_provider
:
:
gen_buffer_data_constructors
!
(
(
)
-
>
error
:
DataError
functions
:
[
new
:
skip
try_new_with_buffer_provider
try_new_unstable
Self
]
)
;
#
[
doc
=
icu_provider
:
:
gen_buffer_unstable_docs
!
(
UNSTABLE
Self
:
:
new
)
]
pub
fn
try_new_unstable
<
P
>
(
provider
:
&
P
)
-
>
Result
<
CaseMapper
DataError
>
where
P
:
DataProvider
<
CaseMapV1
>
+
?
Sized
{
let
data
=
provider
.
load
(
Default
:
:
default
(
)
)
?
.
payload
;
Ok
(
Self
{
data
}
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
icu_locale_core
:
:
langid
;
#
[
test
]
fn
test_special_cases
(
)
{
let
cm
=
CaseMapper
:
:
new
(
)
;
let
root
=
langid
!
(
"
und
"
)
;
let
default_options
=
Default
:
:
default
(
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
"
&
root
)
"
FF
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
"
&
root
)
"
ST
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
"
&
root
)
"
N
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
"
&
root
)
"
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
"
&
root
)
"
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
\
u
{
0313
}
\
u
{
0345
}
"
&
root
)
"
\
u
{
0313
}
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
\
u
{
0313
}
\
u
{
0345
}
"
&
root
default_options
)
"
\
u
{
0313
}
\
u
{
0345
}
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
"
&
root
default_options
)
"
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
"
&
root
)
"
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
"
&
root
)
"
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
"
&
root
default_options
)
"
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
"
&
root
)
"
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
"
&
root
)
"
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
"
&
root
default_options
)
"
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
"
&
root
)
"
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
"
&
root
)
"
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
"
&
root
default_options
)
"
\
u
{
345
}
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
"
&
root
)
"
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
"
&
root
)
"
"
)
;
let
tr
=
langid
!
(
"
tr
"
)
;
let
az
=
langid
!
(
"
az
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
"
&
tr
)
"
i
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
"
&
az
)
"
i
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
"
&
tr
default_options
)
"
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
"
&
az
default_options
)
"
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
"
&
tr
)
"
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
"
&
az
)
"
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
I
\
u
{
0307
}
"
&
tr
)
"
i
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
I
\
u
{
0307
}
"
&
az
)
"
i
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
I
\
u
{
0307
}
"
&
tr
default_options
)
"
I
\
u
{
0307
}
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
I
\
u
{
0307
}
"
&
az
default_options
)
"
I
\
u
{
0307
}
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
I
\
u
{
0307
}
"
&
tr
)
"
I
\
u
{
0307
}
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
I
\
u
{
0307
}
"
&
az
)
"
I
\
u
{
0307
}
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
I
"
&
tr
)
"
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
I
"
&
az
)
"
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
I
"
&
tr
default_options
)
"
I
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
I
"
&
az
default_options
)
"
I
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
I
"
&
tr
)
"
I
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
I
"
&
az
)
"
I
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
i
"
&
tr
)
"
i
"
)
;
assert_eq
!
(
cm
.
lowercase_to_string
(
"
i
"
&
az
)
"
i
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
i
"
&
tr
default_options
)
"
"
)
;
assert_eq
!
(
cm
.
titlecase_segment_with_only_case_data_to_string
(
"
i
"
&
az
default_options
)
"
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
i
"
&
tr
)
"
"
)
;
assert_eq
!
(
cm
.
uppercase_to_string
(
"
i
"
&
az
)
"
"
)
;
}
#
[
test
]
fn
test_cherokee_case_folding
(
)
{
let
case_mapping
=
CaseMapper
:
:
new
(
)
;
assert_eq
!
(
case_mapping
.
simple_fold
(
'
'
)
'
'
)
;
assert_eq
!
(
case_mapping
.
simple_fold
(
'
'
)
'
'
)
;
assert_eq
!
(
case_mapping
.
simple_fold_turkic
(
'
'
)
'
'
)
;
assert_eq
!
(
case_mapping
.
simple_fold_turkic
(
'
'
)
'
'
)
;
assert_eq
!
(
case_mapping
.
fold_string
(
"
"
)
"
"
)
;
assert_eq
!
(
case_mapping
.
fold_string
(
"
"
)
"
"
)
;
assert_eq
!
(
case_mapping
.
fold_turkic_string
(
"
"
)
"
"
)
;
assert_eq
!
(
case_mapping
.
fold_turkic_string
(
"
"
)
"
"
)
;
}
}
