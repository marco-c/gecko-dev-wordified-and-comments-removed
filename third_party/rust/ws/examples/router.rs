extern
crate
ws
;
extern
crate
env_logger
;
struct
Router
{
sender
:
ws
:
:
Sender
inner
:
Box
<
ws
:
:
Handler
>
}
impl
ws
:
:
Handler
for
Router
{
fn
on_request
(
&
mut
self
req
:
&
ws
:
:
Request
)
-
>
ws
:
:
Result
<
(
ws
:
:
Response
)
>
{
let
out
=
self
.
sender
.
clone
(
)
;
match
req
.
resource
(
)
{
"
/
echo
"
=
>
self
.
inner
=
Box
:
:
new
(
Echo
{
ws
:
out
}
)
"
/
data
/
one
"
=
>
self
.
inner
=
Box
:
:
new
(
Data
{
ws
:
out
data
:
vec
!
[
"
one
"
"
two
"
"
three
"
"
four
"
"
five
"
]
}
)
"
/
data
/
two
"
=
>
self
.
inner
=
Box
:
:
new
(
Data
{
ws
:
out
data
:
vec
!
[
"
"
"
"
"
"
"
"
"
"
]
}
)
"
/
closure
"
=
>
self
.
inner
=
Box
:
:
new
(
move
|
msg
:
ws
:
:
Message
|
{
println
!
(
"
Got
a
message
on
a
closure
handler
:
{
}
"
msg
)
;
out
.
close_with_reason
(
ws
:
:
CloseCode
:
:
Error
"
Not
Implemented
.
"
)
}
)
_
=
>
(
)
}
self
.
inner
.
on_request
(
req
)
}
fn
on_shutdown
(
&
mut
self
)
{
self
.
inner
.
on_shutdown
(
)
}
fn
on_open
(
&
mut
self
shake
:
ws
:
:
Handshake
)
-
>
ws
:
:
Result
<
(
)
>
{
self
.
inner
.
on_open
(
shake
)
}
fn
on_message
(
&
mut
self
msg
:
ws
:
:
Message
)
-
>
ws
:
:
Result
<
(
)
>
{
self
.
inner
.
on_message
(
msg
)
}
fn
on_close
(
&
mut
self
code
:
ws
:
:
CloseCode
reason
:
&
str
)
{
self
.
inner
.
on_close
(
code
reason
)
}
fn
on_error
(
&
mut
self
err
:
ws
:
:
Error
)
{
self
.
inner
.
on_error
(
err
)
;
}
}
struct
NotFound
;
impl
ws
:
:
Handler
for
NotFound
{
fn
on_request
(
&
mut
self
req
:
&
ws
:
:
Request
)
-
>
ws
:
:
Result
<
(
ws
:
:
Response
)
>
{
let
mut
res
=
try
!
(
ws
:
:
Response
:
:
from_request
(
req
)
)
;
res
.
set_status
(
404
)
;
res
.
set_reason
(
"
Not
Found
"
)
;
Ok
(
res
)
}
}
struct
Echo
{
ws
:
ws
:
:
Sender
}
impl
ws
:
:
Handler
for
Echo
{
fn
on_message
(
&
mut
self
msg
:
ws
:
:
Message
)
-
>
ws
:
:
Result
<
(
)
>
{
println
!
(
"
Echo
handler
received
a
message
:
{
}
"
msg
)
;
self
.
ws
.
send
(
msg
)
}
}
struct
Data
{
ws
:
ws
:
:
Sender
data
:
Vec
<
&
'
static
str
>
}
impl
ws
:
:
Handler
for
Data
{
fn
on_open
(
&
mut
self
_
:
ws
:
:
Handshake
)
-
>
ws
:
:
Result
<
(
)
>
{
for
msg
in
self
.
data
.
iter
(
)
{
try
!
(
self
.
ws
.
send
(
*
msg
)
)
}
Ok
(
(
)
)
}
fn
on_message
(
&
mut
self
msg
:
ws
:
:
Message
)
-
>
ws
:
:
Result
<
(
)
>
{
println
!
(
"
Data
handler
received
a
message
:
{
}
"
msg
)
;
println
!
(
"
Data
handler
going
down
.
"
)
;
self
.
ws
.
close
(
ws
:
:
CloseCode
:
:
Normal
)
}
}
fn
main
(
)
{
env_logger
:
:
init
(
)
.
unwrap
(
)
;
if
let
Err
(
error
)
=
ws
:
:
listen
(
"
127
.
0
.
0
.
1
:
3012
"
|
out
|
{
Router
{
sender
:
out
inner
:
Box
:
:
new
(
NotFound
)
}
}
)
{
println
!
(
"
Failed
to
create
WebSocket
due
to
{
:
?
}
"
error
)
;
}
}
