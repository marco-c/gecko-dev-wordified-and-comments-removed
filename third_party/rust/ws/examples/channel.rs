extern
crate
env_logger
;
extern
crate
ws
;
use
std
:
:
sync
:
:
mpsc
:
:
Sender
as
ThreadOut
;
use
std
:
:
sync
:
:
mpsc
:
:
channel
;
use
std
:
:
thread
;
use
std
:
:
thread
:
:
sleep
;
use
std
:
:
time
:
:
Duration
;
use
ws
:
:
{
connect
listen
CloseCode
Handler
Handshake
Message
Result
Sender
}
;
fn
main
(
)
{
env_logger
:
:
init
(
)
;
let
data
=
vec
!
[
1
2
3
4
5
]
;
let
(
final_in
final_out
)
=
channel
(
)
;
let
(
log_in
log_out
)
=
channel
(
)
;
struct
Server
{
ws
:
Sender
log
:
ThreadOut
<
String
>
}
impl
Handler
for
Server
{
fn
on_message
(
&
mut
self
msg
:
Message
)
-
>
Result
<
(
)
>
{
println
!
(
"
Server
got
message
'
{
}
'
.
"
msg
)
;
self
.
log
.
send
(
msg
.
to_string
(
)
)
.
unwrap
(
)
;
self
.
ws
.
send
(
msg
)
}
fn
on_close
(
&
mut
self
_
:
CloseCode
_
:
&
str
)
{
self
.
ws
.
shutdown
(
)
.
unwrap
(
)
}
}
let
server
=
thread
:
:
Builder
:
:
new
(
)
.
name
(
"
server
"
.
to_owned
(
)
)
.
spawn
(
move
|
|
{
listen
(
"
127
.
0
.
0
.
1
:
3012
"
|
out
|
{
Server
{
ws
:
out
log
:
log_in
.
clone
(
)
}
}
)
.
unwrap
(
)
}
)
.
unwrap
(
)
;
sleep
(
Duration
:
:
from_millis
(
10
)
)
;
struct
Client
{
out
:
Sender
ind
:
usize
data
:
Vec
<
u32
>
}
impl
Client
{
fn
increment
(
&
mut
self
)
-
>
Result
<
(
)
>
{
if
let
Some
(
num
)
=
self
.
data
.
get
(
self
.
ind
)
{
self
.
ind
+
=
1
;
self
.
out
.
send
(
num
.
to_string
(
)
)
}
else
{
self
.
out
.
close
(
CloseCode
:
:
Normal
)
}
}
}
impl
Handler
for
Client
{
fn
on_open
(
&
mut
self
_
:
Handshake
)
-
>
Result
<
(
)
>
{
self
.
increment
(
)
}
fn
on_message
(
&
mut
self
msg
:
Message
)
-
>
Result
<
(
)
>
{
println
!
(
"
Client
got
message
'
{
}
'
.
"
msg
)
;
self
.
increment
(
)
}
}
let
client_data
=
data
.
clone
(
)
;
let
client
=
thread
:
:
Builder
:
:
new
(
)
.
name
(
"
client
"
.
to_owned
(
)
)
.
spawn
(
move
|
|
{
connect
(
"
ws
:
/
/
127
.
0
.
0
.
1
:
3012
"
|
out
|
{
Client
{
out
ind
:
0
data
:
client_data
.
clone
(
)
}
}
)
.
unwrap
(
)
}
)
.
unwrap
(
)
;
let
logger
=
thread
:
:
Builder
:
:
new
(
)
.
name
(
"
logger
"
.
to_owned
(
)
)
.
spawn
(
move
|
|
{
let
mut
log
:
Vec
<
u32
>
=
Vec
:
:
new
(
)
;
while
let
Ok
(
string
)
=
log_out
.
recv
(
)
{
println
!
(
"
Logger
is
storing
{
}
"
string
)
;
log
.
push
(
string
.
parse
(
)
.
unwrap
(
)
)
;
}
println
!
(
"
Logger
sending
final
log
result
.
"
)
;
final_in
.
send
(
log
)
.
unwrap
(
)
;
}
)
.
unwrap
(
)
;
let
_
=
server
.
join
(
)
;
let
_
=
client
.
join
(
)
;
let
_
=
logger
.
join
(
)
;
let
final_data
=
final_out
.
recv
(
)
.
unwrap
(
)
;
println
!
(
"
In
:
{
:
?
}
"
data
)
;
println
!
(
"
Out
:
{
:
?
}
"
final_data
)
;
assert_eq
!
(
final_data
data
)
;
println
!
(
"
All
done
.
"
)
}
