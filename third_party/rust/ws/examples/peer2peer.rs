extern
crate
clap
;
extern
crate
env_logger
;
extern
crate
url
;
extern
crate
ws
;
#
[
macro_use
]
extern
crate
log
;
use
std
:
:
io
;
use
std
:
:
io
:
:
prelude
:
:
*
;
use
std
:
:
thread
;
use
clap
:
:
{
App
Arg
}
;
fn
main
(
)
{
env_logger
:
:
init
(
)
;
let
matches
=
App
:
:
new
(
"
Simple
Peer
2
Peer
"
)
.
version
(
"
1
.
0
"
)
.
author
(
"
Jason
Housley
<
housleyjk
gmail
.
com
>
"
)
.
about
(
"
Connect
to
other
peers
and
listen
for
incoming
connections
.
"
)
.
arg
(
Arg
:
:
with_name
(
"
server
"
)
.
short
(
"
s
"
)
.
long
(
"
server
"
)
.
value_name
(
"
SERVER
"
)
.
help
(
"
Set
the
address
to
listen
for
new
connections
.
"
)
)
.
arg
(
Arg
:
:
with_name
(
"
PEER
"
)
.
help
(
"
A
WebSocket
URL
to
attempt
to
connect
to
at
start
.
"
)
.
multiple
(
true
)
)
.
get_matches
(
)
;
let
my_addr
=
matches
.
value_of
(
"
server
"
)
.
unwrap_or
(
"
localhost
:
3012
"
)
;
let
mut
me
=
ws
:
:
WebSocket
:
:
new
(
|
_
|
{
move
|
msg
|
{
info
!
(
"
Peer
{
}
got
message
:
{
}
"
my_addr
msg
)
;
Ok
(
(
)
)
}
}
)
.
unwrap
(
)
;
let
broacaster
=
me
.
broadcaster
(
)
;
let
input
=
thread
:
:
spawn
(
move
|
|
{
let
stdin
=
io
:
:
stdin
(
)
;
for
line
in
stdin
.
lock
(
)
.
lines
(
)
{
broacaster
.
send
(
line
.
unwrap
(
)
)
.
unwrap
(
)
;
}
}
)
;
if
let
Some
(
peers
)
=
matches
.
values_of
(
"
PEER
"
)
{
for
peer
in
peers
{
me
.
connect
(
url
:
:
Url
:
:
parse
(
peer
)
.
unwrap
(
)
)
.
unwrap
(
)
;
}
}
me
.
listen
(
my_addr
)
.
unwrap
(
)
;
input
.
join
(
)
.
unwrap
(
)
;
}
