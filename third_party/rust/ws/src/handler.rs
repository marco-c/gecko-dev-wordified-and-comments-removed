use
log
:
:
Level
:
:
Error
as
ErrorLevel
;
#
[
cfg
(
feature
=
"
nativetls
"
)
]
use
native_tls
:
:
{
TlsConnector
TlsStream
as
SslStream
}
;
#
[
cfg
(
feature
=
"
ssl
"
)
]
use
openssl
:
:
ssl
:
:
{
SslConnector
SslMethod
SslStream
}
;
use
url
;
use
frame
:
:
Frame
;
use
handshake
:
:
{
Handshake
Request
Response
}
;
use
message
:
:
Message
;
use
protocol
:
:
CloseCode
;
use
result
:
:
{
Error
Kind
Result
}
;
use
util
:
:
{
Timeout
Token
}
;
#
[
cfg
(
any
(
feature
=
"
ssl
"
feature
=
"
nativetls
"
)
)
]
use
util
:
:
TcpStream
;
pub
trait
Handler
{
#
[
inline
]
fn
on_shutdown
(
&
mut
self
)
{
debug
!
(
"
Handler
received
WebSocket
shutdown
request
.
"
)
;
}
fn
on_open
(
&
mut
self
shake
:
Handshake
)
-
>
Result
<
(
)
>
{
if
let
Some
(
addr
)
=
shake
.
remote_addr
(
)
?
{
debug
!
(
"
Connection
with
{
}
now
open
"
addr
)
;
}
Ok
(
(
)
)
}
fn
on_message
(
&
mut
self
msg
:
Message
)
-
>
Result
<
(
)
>
{
debug
!
(
"
Received
message
{
:
?
}
"
msg
)
;
Ok
(
(
)
)
}
fn
on_close
(
&
mut
self
code
:
CloseCode
reason
:
&
str
)
{
debug
!
(
"
Connection
closing
due
to
(
{
:
?
}
)
{
}
"
code
reason
)
;
}
fn
on_error
(
&
mut
self
err
:
Error
)
{
if
let
Kind
:
:
Io
(
ref
err
)
=
err
.
kind
{
if
let
Some
(
104
)
=
err
.
raw_os_error
(
)
{
return
;
}
}
error
!
(
"
{
:
?
}
"
err
)
;
if
!
log_enabled
!
(
ErrorLevel
)
{
println
!
(
"
Encountered
an
error
:
{
}
\
nEnable
a
logger
to
see
more
information
.
"
err
)
;
}
}
#
[
inline
]
fn
on_request
(
&
mut
self
req
:
&
Request
)
-
>
Result
<
Response
>
{
debug
!
(
"
Handler
received
request
:
\
n
{
}
"
req
)
;
Response
:
:
from_request
(
req
)
}
#
[
inline
]
fn
on_response
(
&
mut
self
res
:
&
Response
)
-
>
Result
<
(
)
>
{
debug
!
(
"
Handler
received
response
:
\
n
{
}
"
res
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
on_timeout
(
&
mut
self
event
:
Token
)
-
>
Result
<
(
)
>
{
debug
!
(
"
Handler
received
timeout
token
:
{
:
?
}
"
event
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
on_new_timeout
(
&
mut
self
_
:
Token
_
:
Timeout
)
-
>
Result
<
(
)
>
{
Ok
(
(
)
)
}
#
[
inline
]
fn
on_frame
(
&
mut
self
frame
:
Frame
)
-
>
Result
<
Option
<
Frame
>
>
{
debug
!
(
"
Handler
received
:
{
}
"
frame
)
;
if
frame
.
has_rsv1
(
)
|
|
frame
.
has_rsv2
(
)
|
|
frame
.
has_rsv3
(
)
{
Err
(
Error
:
:
new
(
Kind
:
:
Protocol
"
Encountered
frame
with
reserved
bits
set
.
"
)
)
}
else
{
Ok
(
Some
(
frame
)
)
}
}
#
[
inline
]
fn
on_send_frame
(
&
mut
self
frame
:
Frame
)
-
>
Result
<
Option
<
Frame
>
>
{
trace
!
(
"
Handler
will
send
:
{
}
"
frame
)
;
if
frame
.
has_rsv1
(
)
|
|
frame
.
has_rsv2
(
)
|
|
frame
.
has_rsv3
(
)
{
Err
(
Error
:
:
new
(
Kind
:
:
Protocol
"
Encountered
frame
with
reserved
bits
set
.
"
)
)
}
else
{
Ok
(
Some
(
frame
)
)
}
}
#
[
inline
]
fn
build_request
(
&
mut
self
url
:
&
url
:
:
Url
)
-
>
Result
<
Request
>
{
trace
!
(
"
Handler
is
building
request
to
{
}
.
"
url
)
;
Request
:
:
from_url
(
url
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
ssl
"
)
]
fn
upgrade_ssl_client
(
&
mut
self
stream
:
TcpStream
url
:
&
url
:
:
Url
)
-
>
Result
<
SslStream
<
TcpStream
>
>
{
let
domain
=
url
.
domain
(
)
.
ok_or
(
Error
:
:
new
(
Kind
:
:
Protocol
format
!
(
"
Unable
to
parse
domain
from
{
}
.
Needed
for
SSL
.
"
url
)
)
)
?
;
let
connector
=
SslConnector
:
:
builder
(
SslMethod
:
:
tls
(
)
)
.
map_err
(
|
e
|
{
Error
:
:
new
(
Kind
:
:
Internal
format
!
(
"
Failed
to
upgrade
client
to
SSL
:
{
}
"
e
)
)
}
)
?
.
build
(
)
;
connector
.
connect
(
domain
stream
)
.
map_err
(
Error
:
:
from
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
nativetls
"
)
]
fn
upgrade_ssl_client
(
&
mut
self
stream
:
TcpStream
url
:
&
url
:
:
Url
)
-
>
Result
<
SslStream
<
TcpStream
>
>
{
let
domain
=
url
.
domain
(
)
.
ok_or
(
Error
:
:
new
(
Kind
:
:
Protocol
format
!
(
"
Unable
to
parse
domain
from
{
}
.
Needed
for
SSL
.
"
url
)
)
)
?
;
let
connector
=
TlsConnector
:
:
new
(
)
.
map_err
(
|
e
|
{
Error
:
:
new
(
Kind
:
:
Internal
format
!
(
"
Failed
to
upgrade
client
to
SSL
:
{
}
"
e
)
)
}
)
?
;
connector
.
connect
(
domain
stream
)
.
map_err
(
Error
:
:
from
)
}
#
[
inline
]
#
[
cfg
(
any
(
feature
=
"
ssl
"
feature
=
"
nativetls
"
)
)
]
fn
upgrade_ssl_server
(
&
mut
self
_
:
TcpStream
)
-
>
Result
<
SslStream
<
TcpStream
>
>
{
unimplemented
!
(
)
}
}
impl
<
F
>
Handler
for
F
where
F
:
Fn
(
Message
)
-
>
Result
<
(
)
>
{
fn
on_message
(
&
mut
self
msg
:
Message
)
-
>
Result
<
(
)
>
{
self
(
msg
)
}
}
mod
test
{
#
!
[
allow
(
unused_imports
unused_variables
dead_code
)
]
use
super
:
:
*
;
use
frame
;
use
handshake
:
:
{
Handshake
Request
Response
}
;
use
message
;
use
mio
;
use
protocol
:
:
CloseCode
;
use
result
:
:
Result
;
use
url
;
#
[
derive
(
Debug
Eq
PartialEq
)
]
struct
M
;
impl
Handler
for
M
{
fn
on_message
(
&
mut
self
_
:
message
:
:
Message
)
-
>
Result
<
(
)
>
{
println
!
(
"
test
"
)
;
Ok
(
(
)
)
}
fn
on_frame
(
&
mut
self
f
:
frame
:
:
Frame
)
-
>
Result
<
Option
<
frame
:
:
Frame
>
>
{
Ok
(
None
)
}
}
#
[
test
]
fn
handler
(
)
{
struct
H
;
impl
Handler
for
H
{
fn
on_open
(
&
mut
self
shake
:
Handshake
)
-
>
Result
<
(
)
>
{
assert
!
(
shake
.
request
.
key
(
)
.
is_ok
(
)
)
;
assert
!
(
shake
.
response
.
key
(
)
.
is_ok
(
)
)
;
Ok
(
(
)
)
}
fn
on_message
(
&
mut
self
msg
:
message
:
:
Message
)
-
>
Result
<
(
)
>
{
Ok
(
assert_eq
!
(
msg
message
:
:
Message
:
:
Text
(
String
:
:
from
(
"
testme
"
)
)
)
)
}
fn
on_close
(
&
mut
self
code
:
CloseCode
_
:
&
str
)
{
assert_eq
!
(
code
CloseCode
:
:
Normal
)
}
}
let
mut
h
=
H
;
let
url
=
url
:
:
Url
:
:
parse
(
"
wss
:
/
/
127
.
0
.
0
.
1
:
3012
"
)
.
unwrap
(
)
;
let
req
=
Request
:
:
from_url
(
&
url
)
.
unwrap
(
)
;
let
res
=
Response
:
:
from_request
(
&
req
)
.
unwrap
(
)
;
h
.
on_open
(
Handshake
{
request
:
req
response
:
res
peer_addr
:
None
local_addr
:
None
}
)
.
unwrap
(
)
;
h
.
on_message
(
message
:
:
Message
:
:
Text
(
"
testme
"
.
to_owned
(
)
)
)
.
unwrap
(
)
;
h
.
on_close
(
CloseCode
:
:
Normal
"
"
)
;
}
#
[
test
]
fn
closure_handler
(
)
{
let
mut
close
=
|
msg
|
{
assert_eq
!
(
msg
message
:
:
Message
:
:
Binary
(
vec
!
[
1
2
3
]
)
)
;
Ok
(
(
)
)
}
;
close
.
on_message
(
message
:
:
Message
:
:
Binary
(
vec
!
[
1
2
3
]
)
)
.
unwrap
(
)
;
}
}
