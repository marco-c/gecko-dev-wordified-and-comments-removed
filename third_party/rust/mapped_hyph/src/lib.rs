#
[
macro_use
]
extern
crate
arrayref
;
extern
crate
memmap
;
use
std
:
:
slice
;
use
std
:
:
str
;
use
std
:
:
cmp
:
:
max
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
mem
:
:
size_of
;
use
memmap
:
:
Mmap
;
pub
mod
builder
;
pub
mod
ffi
;
const
MAGIC_NUMBER
:
[
u8
;
4
]
=
[
b
'
H
'
b
'
y
'
b
'
f
'
b
'
0
'
]
;
const
INVALID_STRING_OFFSET
:
u16
=
0xffff
;
const
INVALID_STATE_OFFSET
:
u32
=
0xffffff
;
const
FILE_HEADER_SIZE
:
usize
=
8
;
const
LEVEL_HEADER_SIZE
:
usize
=
16
;
const
STATE_HEADER_SIZE_BASIC
:
usize
=
8
;
const
STATE_HEADER_SIZE_EXTENDED
:
usize
=
12
;
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Copy
Clone
)
]
struct
Transition
(
u8
u8
u8
u8
)
;
impl
Transition
{
fn
new_state_offset
(
&
self
)
-
>
usize
{
self
.
0
as
usize
+
(
(
self
.
1
as
usize
)
<
<
8
)
+
(
(
self
.
2
as
usize
)
<
<
16
)
}
fn
match_byte
(
&
self
)
-
>
u8
{
self
.
3
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
repr
(
C
)
]
struct
State
{
fallback_state_
:
[
u8
;
4
]
match_string_offset_
:
[
u8
;
2
]
num_transitions_
:
u8
is_extended_
:
u8
}
impl
State
{
fn
fallback_state
(
&
self
)
-
>
usize
{
u32
:
:
from_le_bytes
(
self
.
fallback_state_
)
as
usize
}
fn
match_string_offset
(
&
self
)
-
>
usize
{
u16
:
:
from_le_bytes
(
self
.
match_string_offset_
)
as
usize
}
fn
num_transitions
(
&
self
)
-
>
u8
{
self
.
num_transitions_
}
fn
is_extended
(
&
self
)
-
>
bool
{
self
.
is_extended_
!
=
0
}
#
[
allow
(
dead_code
)
]
fn
repl_string_offset
(
&
self
)
-
>
usize
{
debug_assert
!
(
self
.
is_extended
(
)
)
;
u16
:
:
from_le
(
unsafe
{
*
(
(
self
as
*
const
State
as
*
const
u8
)
.
offset
(
8
)
as
*
const
u16
)
}
)
as
usize
}
#
[
allow
(
dead_code
)
]
fn
repl_index
(
&
self
)
-
>
i8
{
debug_assert
!
(
self
.
is_extended
(
)
)
;
unsafe
{
*
(
(
self
as
*
const
State
as
*
const
i8
)
.
offset
(
10
)
)
}
}
#
[
allow
(
dead_code
)
]
fn
repl_cut
(
&
self
)
-
>
i8
{
debug_assert
!
(
self
.
is_extended
(
)
)
;
unsafe
{
*
(
(
self
as
*
const
State
as
*
const
i8
)
.
offset
(
11
)
)
}
}
fn
transitions
(
&
self
)
-
>
&
[
Transition
]
{
let
count
=
self
.
num_transitions
(
)
as
usize
;
if
count
=
=
0
{
return
&
[
]
;
}
let
transition_offset
=
if
self
.
is_extended
(
)
{
STATE_HEADER_SIZE_EXTENDED
}
else
{
STATE_HEADER_SIZE_BASIC
}
as
isize
;
let
trans_ptr
=
unsafe
{
(
self
as
*
const
State
as
*
const
u8
)
.
offset
(
transition_offset
)
as
*
const
Transition
}
;
unsafe
{
slice
:
:
from_raw_parts
(
trans_ptr
count
)
}
}
fn
transition_for
(
&
self
b
:
u8
)
-
>
Option
<
Transition
>
{
self
.
transitions
(
)
.
iter
(
)
.
copied
(
)
.
find
(
|
t
|
t
.
match_byte
(
)
=
=
b
)
}
#
[
allow
(
dead_code
)
]
fn
deep_show
(
&
self
prefix
:
&
str
dic
:
&
Level
)
{
if
self
.
match_string_offset
(
)
!
=
INVALID_STRING_OFFSET
as
usize
{
let
match_string
=
dic
.
string_at_offset
(
self
.
match_string_offset
(
)
)
;
println
!
(
"
{
}
match
:
{
}
"
prefix
str
:
:
from_utf8
(
match_string
)
.
unwrap
(
)
)
;
}
for
t
in
self
.
transitions
(
)
{
println
!
(
"
{
}
{
}
-
>
"
prefix
t
.
match_byte
(
)
as
char
)
;
let
next_prefix
=
format
!
(
"
{
}
"
prefix
)
;
dic
.
get_state
(
t
.
new_state_offset
(
)
)
.
unwrap
(
)
.
deep_show
(
&
next_prefix
&
dic
)
;
}
}
}
fn
lig_length
(
trail_byte
:
u8
)
-
>
usize
{
const
LENGTHS
:
[
u8
;
7
]
=
[
2u8
2u8
2u8
3u8
3u8
2u8
2u8
]
;
if
trail_byte
>
0x86
{
return
1
;
}
LENGTHS
[
trail_byte
as
usize
-
0x80
]
as
usize
}
fn
is_utf8_trail_byte
(
byte
:
u8
)
-
>
bool
{
(
byte
&
0xC0
)
=
=
0x80
}
fn
is_ascii_digit
(
byte
:
u8
)
-
>
bool
{
byte
<
=
b
'
9
'
&
&
byte
>
=
b
'
0
'
}
fn
is_odd
(
byte
:
u8
)
-
>
bool
{
(
byte
&
0x01
)
=
=
0x01
}
#
[
derive
(
Debug
Copy
Clone
)
]
struct
Level
<
'
a
>
{
data
:
&
'
a
[
u8
]
state_data_base_
:
usize
string_data_base_
:
usize
}
impl
Level
<
'
_
>
{
fn
new
(
data
:
&
[
u8
]
)
-
>
Level
{
Level
{
data
:
data
state_data_base_
:
u32
:
:
from_le_bytes
(
*
array_ref
!
(
data
0
4
)
)
as
usize
string_data_base_
:
u32
:
:
from_le_bytes
(
*
array_ref
!
(
data
4
4
)
)
as
usize
}
}
fn
state_data_base
(
&
self
)
-
>
usize
{
self
.
state_data_base_
}
fn
string_data_base
(
&
self
)
-
>
usize
{
self
.
string_data_base_
}
fn
nohyphen_string_offset
(
&
self
)
-
>
usize
{
u16
:
:
from_le_bytes
(
*
array_ref
!
(
self
.
data
8
2
)
)
as
usize
}
#
[
allow
(
dead_code
)
]
fn
nohyphen_count
(
&
self
)
-
>
u16
{
u16
:
:
from_le_bytes
(
*
array_ref
!
(
self
.
data
10
2
)
)
}
fn
lh_min
(
&
self
)
-
>
usize
{
max
(
1
self
.
data
[
12
]
as
usize
)
}
fn
rh_min
(
&
self
)
-
>
usize
{
max
(
1
self
.
data
[
13
]
as
usize
)
}
fn
clh_min
(
&
self
)
-
>
usize
{
max
(
1
self
.
data
[
14
]
as
usize
)
}
fn
crh_min
(
&
self
)
-
>
usize
{
max
(
1
self
.
data
[
15
]
as
usize
)
}
fn
word_boundary_mins
(
&
self
)
-
>
(
usize
usize
usize
usize
)
{
(
self
.
lh_min
(
)
self
.
rh_min
(
)
self
.
clh_min
(
)
self
.
crh_min
(
)
)
}
fn
string_at_offset
(
&
self
offset
:
usize
)
-
>
&
'
_
[
u8
]
{
if
offset
=
=
INVALID_STRING_OFFSET
as
usize
{
return
&
[
]
;
}
let
string_base
=
self
.
string_data_base
(
)
as
usize
+
offset
;
debug_assert
!
(
string_base
+
1
<
=
self
.
data
.
len
(
)
)
;
if
string_base
+
1
>
self
.
data
.
len
(
)
{
return
&
[
]
;
}
let
len
=
self
.
data
[
string_base
]
as
usize
;
debug_assert
!
(
string_base
+
1
+
len
<
=
self
.
data
.
len
(
)
)
;
if
string_base
+
1
+
len
>
self
.
data
.
len
(
)
{
return
&
[
]
;
}
self
.
data
.
get
(
string_base
+
1
.
.
string_base
+
1
+
len
)
.
unwrap
(
)
}
fn
nohyphen
(
&
self
)
-
>
Vec
<
&
[
u8
]
>
{
let
string_offset
=
self
.
nohyphen_string_offset
(
)
;
let
nohyph_str
=
self
.
string_at_offset
(
string_offset
as
usize
)
;
if
nohyph_str
.
len
(
)
=
=
0
{
return
vec
!
[
]
;
}
nohyph_str
.
split
(
|
&
b
|
b
=
=
0
)
.
collect
(
)
}
fn
get_state
(
&
self
offset
:
usize
)
-
>
Option
<
&
State
>
{
if
offset
=
=
INVALID_STATE_OFFSET
as
usize
{
return
None
;
}
debug_assert_eq
!
(
offset
&
3
0
)
;
let
state_base
=
self
.
state_data_base
(
)
+
offset
;
debug_assert
!
(
state_base
+
STATE_HEADER_SIZE_BASIC
<
=
self
.
string_data_base
(
)
)
;
if
state_base
+
STATE_HEADER_SIZE_BASIC
>
self
.
string_data_base
(
)
{
return
None
;
}
let
state_ptr
=
&
self
.
data
[
state_base
]
as
*
const
u8
as
*
const
State
;
let
state
=
unsafe
{
state_ptr
.
as_ref
(
)
.
unwrap
(
)
}
;
let
length
=
if
state
.
is_extended
(
)
{
STATE_HEADER_SIZE_EXTENDED
}
else
{
STATE_HEADER_SIZE_BASIC
}
+
size_of
:
:
<
Transition
>
(
)
*
state
.
num_transitions
(
)
as
usize
;
debug_assert
!
(
state_base
+
length
<
=
self
.
string_data_base
(
)
)
;
if
state_base
+
length
>
self
.
string_data_base
(
)
{
return
None
;
}
unsafe
{
state_ptr
.
as_ref
(
)
}
}
fn
find_hyphen_values
(
&
self
word
:
&
str
values
:
&
mut
[
u8
]
lh_min
:
usize
rh_min
:
usize
)
-
>
isize
{
if
word
.
len
(
)
<
lh_min
+
rh_min
{
return
0
;
}
let
start_state
=
self
.
get_state
(
0
)
;
let
mut
st
=
start_state
;
let
mut
hyph_count
=
0
;
for
i
in
0
.
.
word
.
len
(
)
+
2
{
let
b
=
if
i
=
=
0
|
|
i
=
=
word
.
len
(
)
+
1
{
b
'
.
'
}
else
{
word
.
as_bytes
(
)
[
i
-
1
]
}
;
loop
{
if
st
.
is_none
(
)
{
st
=
start_state
;
break
;
}
let
state
=
st
.
unwrap
(
)
;
if
let
Some
(
tr
)
=
state
.
transition_for
(
b
)
{
st
=
self
.
get_state
(
tr
.
new_state_offset
(
)
)
;
if
let
Some
(
state
)
=
st
{
let
match_offset
=
state
.
match_string_offset
(
)
;
if
match_offset
!
=
INVALID_STRING_OFFSET
as
usize
{
if
state
.
is_extended
(
)
{
debug_assert
!
(
false
"
extended
hyphenation
not
supported
by
this
function
"
)
;
}
else
{
let
match_str
=
self
.
string_at_offset
(
match_offset
)
;
let
offset
=
i
+
1
-
match_str
.
len
(
)
;
assert
!
(
offset
+
match_str
.
len
(
)
<
=
word
.
len
(
)
+
2
)
;
for
j
in
0
.
.
match_str
.
len
(
)
{
let
index
=
offset
+
j
;
if
index
>
=
lh_min
&
&
index
<
=
word
.
len
(
)
-
rh_min
{
let
old_value
=
values
[
index
-
1
]
;
let
value
=
match_str
[
j
]
-
b
'
0
'
;
if
value
>
old_value
{
if
is_odd
(
old_value
)
!
=
is_odd
(
value
)
{
hyph_count
+
=
if
is_odd
(
value
)
{
1
}
else
{
-
1
}
;
}
values
[
index
-
1
]
=
value
;
}
}
}
}
}
}
break
;
}
st
=
self
.
get_state
(
state
.
fallback_state
(
)
)
;
}
}
let
mut
index
=
0
;
let
mut
count
=
0
;
let
word_bytes
=
word
.
as_bytes
(
)
;
let
mut
clear_hyphen_at
=
|
i
|
{
if
is_odd
(
values
[
i
]
)
{
hyph_count
-
=
1
;
}
values
[
i
]
=
0
;
}
;
while
count
<
lh_min
-
1
&
&
index
<
word_bytes
.
len
(
)
{
let
byte
=
word_bytes
[
index
]
;
clear_hyphen_at
(
index
)
;
if
byte
<
0x80
{
index
+
=
1
;
if
is_ascii_digit
(
byte
)
{
continue
;
}
}
else
if
byte
=
=
0xEF
&
&
word_bytes
[
index
+
1
]
=
=
0xAC
{
count
+
=
lig_length
(
word_bytes
[
index
+
2
]
)
;
clear_hyphen_at
(
index
+
1
)
;
clear_hyphen_at
(
index
+
2
)
;
index
+
=
3
;
continue
;
}
else
{
index
+
=
1
;
while
index
<
word_bytes
.
len
(
)
&
&
is_utf8_trail_byte
(
word_bytes
[
index
]
)
{
clear_hyphen_at
(
index
)
;
index
+
=
1
;
}
}
count
+
=
1
;
}
count
=
0
;
index
=
word
.
len
(
)
;
while
count
<
rh_min
&
&
index
>
0
{
index
-
=
1
;
let
byte
=
word_bytes
[
index
]
;
if
index
<
word
.
len
(
)
-
1
{
clear_hyphen_at
(
index
)
;
}
if
byte
<
0x80
{
if
!
is_ascii_digit
(
byte
)
{
count
+
=
1
;
}
continue
;
}
if
is_utf8_trail_byte
(
byte
)
{
continue
;
}
if
byte
=
=
0xEF
&
&
word_bytes
[
index
+
1
]
=
=
0xAC
{
count
+
=
lig_length
(
word_bytes
[
index
+
2
]
)
;
continue
;
}
count
+
=
1
;
}
hyph_count
}
}
pub
struct
Hyphenator
<
'
a
>
(
&
'
a
[
u8
]
)
;
impl
Hyphenator
<
'
_
>
{
pub
fn
new
(
buffer
:
&
[
u8
]
)
-
>
Hyphenator
{
Hyphenator
(
buffer
)
}
fn
magic_number
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
[
0
.
.
4
]
}
fn
num_levels
(
&
self
)
-
>
usize
{
u32
:
:
from_le_bytes
(
*
array_ref
!
(
self
.
0
4
4
)
)
as
usize
}
fn
level
(
&
self
i
:
usize
)
-
>
Level
{
let
offset
=
u32
:
:
from_le_bytes
(
*
array_ref
!
(
self
.
0
FILE_HEADER_SIZE
+
4
*
i
4
)
)
as
usize
;
let
limit
=
if
i
=
=
self
.
num_levels
(
)
-
1
{
self
.
0
.
len
(
)
}
else
{
u32
:
:
from_le_bytes
(
*
array_ref
!
(
self
.
0
FILE_HEADER_SIZE
+
4
*
i
+
4
4
)
)
as
usize
}
;
debug_assert
!
(
offset
+
LEVEL_HEADER_SIZE
<
=
limit
&
&
limit
<
=
self
.
0
.
len
(
)
)
;
debug_assert_eq
!
(
offset
&
3
0
)
;
debug_assert_eq
!
(
limit
&
3
0
)
;
Level
:
:
new
(
&
self
.
0
[
offset
.
.
limit
]
)
}
pub
fn
find_hyphen_values
(
&
self
word
:
&
str
values
:
&
mut
[
u8
]
)
-
>
isize
{
assert
!
(
values
.
len
(
)
>
=
word
.
len
(
)
)
;
values
.
iter_mut
(
)
.
for_each
(
|
x
|
*
x
=
0
)
;
let
top_level
=
self
.
level
(
0
)
;
let
(
lh_min
rh_min
clh_min
crh_min
)
=
top_level
.
word_boundary_mins
(
)
;
if
word
.
len
(
)
<
lh_min
+
rh_min
{
return
0
;
}
let
mut
hyph_count
=
top_level
.
find_hyphen_values
(
word
values
lh_min
rh_min
)
;
let
compound
=
hyph_count
>
0
;
for
l
in
1
.
.
self
.
num_levels
(
)
{
let
level
=
self
.
level
(
l
)
;
if
hyph_count
>
0
{
let
mut
begin
=
0
;
let
mut
lh
=
lh_min
;
for
i
in
lh_min
-
1
.
.
word
.
len
(
)
-
rh_min
{
if
is_odd
(
values
[
i
]
)
{
if
i
>
begin
{
values
[
begin
.
.
i
]
.
iter_mut
(
)
.
for_each
(
|
x
|
{
*
x
=
0
;
}
)
;
hyph_count
+
=
level
.
find_hyphen_values
(
&
word
[
begin
.
.
i
+
1
]
&
mut
values
[
begin
.
.
i
+
1
]
lh
crh_min
)
;
}
begin
=
i
+
1
;
lh
=
clh_min
;
}
}
if
begin
=
=
0
{
hyph_count
+
=
level
.
find_hyphen_values
(
word
values
lh_min
rh_min
)
;
}
else
if
begin
<
word
.
len
(
)
{
hyph_count
+
=
level
.
find_hyphen_values
(
&
word
[
begin
.
.
word
.
len
(
)
]
&
mut
values
[
begin
.
.
word
.
len
(
)
]
clh_min
rh_min
)
;
}
}
else
{
hyph_count
+
=
level
.
find_hyphen_values
(
word
values
lh_min
rh_min
)
;
}
}
if
compound
&
&
hyph_count
>
0
{
let
nohyph
=
top_level
.
nohyphen
(
)
;
if
nohyph
.
len
(
)
>
0
{
for
i
in
lh_min
.
.
word
.
len
(
)
-
rh_min
+
1
{
if
is_odd
(
values
[
i
-
1
]
)
{
for
nh
in
&
nohyph
{
if
i
+
nh
.
len
(
)
<
=
word
.
len
(
)
&
&
*
nh
=
=
&
word
.
as_bytes
(
)
[
i
.
.
i
+
nh
.
len
(
)
]
{
values
[
i
-
1
]
=
0
;
hyph_count
-
=
1
;
break
;
}
if
nh
.
len
(
)
<
=
i
&
&
*
nh
=
=
&
word
.
as_bytes
(
)
[
i
-
nh
.
len
(
)
.
.
i
]
{
values
[
i
-
1
]
=
0
;
hyph_count
-
=
1
;
break
;
}
}
}
}
}
}
hyph_count
}
pub
fn
hyphenate_word
(
&
self
word
:
&
str
hyphchar
:
char
)
-
>
String
{
let
mut
values
=
vec
!
[
0u8
;
word
.
len
(
)
]
;
let
hyph_count
=
self
.
find_hyphen_values
(
word
&
mut
values
)
;
if
hyph_count
<
=
0
{
return
word
.
to_string
(
)
;
}
let
result_len
=
word
.
len
(
)
+
hyph_count
as
usize
*
hyphchar
.
len_utf8
(
)
;
let
mut
result
=
String
:
:
with_capacity
(
result_len
)
;
let
mut
n
=
0
;
for
ch
in
word
.
char_indices
(
)
{
if
ch
.
0
>
0
&
&
is_odd
(
values
[
ch
.
0
-
1
]
)
{
result
.
push
(
hyphchar
)
;
n
+
=
1
;
}
result
.
push
(
ch
.
1
)
;
}
debug_assert_eq
!
(
n
hyph_count
)
;
debug_assert_eq
!
(
result_len
result
.
len
(
)
)
;
result
}
pub
fn
is_valid_hyphenator
(
&
self
)
-
>
bool
{
if
self
.
0
.
len
(
)
<
FILE_HEADER_SIZE
{
return
false
;
}
if
self
.
magic_number
(
)
!
=
MAGIC_NUMBER
{
return
false
;
}
let
num_levels
=
self
.
num_levels
(
)
;
if
self
.
0
.
len
(
)
<
FILE_HEADER_SIZE
+
LEVEL_HEADER_SIZE
*
num_levels
{
return
false
;
}
for
l
in
0
.
.
num_levels
{
let
level
=
self
.
level
(
l
)
;
if
level
.
state_data_base
(
)
<
LEVEL_HEADER_SIZE
|
|
level
.
state_data_base
(
)
>
level
.
string_data_base
(
)
|
|
level
.
string_data_base
(
)
>
level
.
data
.
len
(
)
{
return
false
;
}
}
true
}
}
pub
unsafe
fn
load_file
(
dic_path
:
&
str
)
-
>
Option
<
Mmap
>
{
let
file
=
File
:
:
open
(
dic_path
)
.
ok
(
)
?
;
let
dic
=
Mmap
:
:
map
(
&
file
)
.
ok
(
)
?
;
let
hyph
=
Hyphenator
(
&
*
dic
)
;
if
hyph
.
is_valid_hyphenator
(
)
{
return
Some
(
dic
)
;
}
None
}
