use
std
:
:
slice
;
use
std
:
:
str
;
use
std
:
:
ffi
:
:
CStr
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
use
std
:
:
str
:
:
Utf8Error
;
use
memmap2
:
:
Mmap
;
use
super
:
:
Hyphenator
;
pub
struct
HyphDic
;
pub
struct
CompiledData
;
unsafe
fn
params_from_c
<
'
a
>
(
word
:
*
const
c_char
word_len
:
u32
hyphens
:
*
mut
u8
hyphens_len
:
u32
)
-
>
(
Result
<
&
'
a
str
Utf8Error
>
&
'
a
mut
[
u8
]
)
{
(
str
:
:
from_utf8
(
slice
:
:
from_raw_parts
(
word
as
*
const
u8
word_len
as
usize
)
)
slice
:
:
from_raw_parts_mut
(
hyphens
hyphens_len
as
usize
)
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mapped_hyph_load_dictionary
(
path
:
*
const
c_char
)
-
>
*
const
HyphDic
{
let
path_str
=
match
CStr
:
:
from_ptr
(
path
)
.
to_str
(
)
{
Ok
(
str
)
=
>
str
Err
(
_
)
=
>
return
std
:
:
ptr
:
:
null
(
)
}
;
let
hyph
=
Box
:
:
new
(
match
super
:
:
load_file
(
path_str
)
{
Some
(
dic
)
=
>
dic
_
=
>
return
std
:
:
ptr
:
:
null
(
)
}
)
;
Box
:
:
into_raw
(
hyph
)
as
*
const
HyphDic
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mapped_hyph_free_dictionary
(
dic
:
*
mut
HyphDic
)
{
Box
:
:
from_raw
(
dic
)
;
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mapped_hyph_find_hyphen_values_dic
(
dic
:
*
const
HyphDic
word
:
*
const
c_char
word_len
:
u32
hyphens
:
*
mut
u8
hyphens_len
:
u32
)
-
>
i32
{
if
word_len
>
hyphens_len
{
return
-
1
;
}
let
(
word_str
hyphen_buf
)
=
params_from_c
(
word
word_len
hyphens
hyphens_len
)
;
if
word_str
.
is_err
(
)
{
return
-
1
;
}
Hyphenator
:
:
new
(
&
*
(
dic
as
*
const
Mmap
)
)
.
find_hyphen_values
(
word_str
.
unwrap
(
)
hyphen_buf
)
as
i32
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mapped_hyph_find_hyphen_values_raw
(
dic_buf
:
*
const
u8
dic_len
:
u32
word
:
*
const
c_char
word_len
:
u32
hyphens
:
*
mut
u8
hyphens_len
:
u32
)
-
>
i32
{
if
word_len
>
hyphens_len
{
return
-
1
;
}
let
(
word_str
hyphen_buf
)
=
params_from_c
(
word
word_len
hyphens
hyphens_len
)
;
if
word_str
.
is_err
(
)
{
return
-
1
;
}
Hyphenator
:
:
new
(
slice
:
:
from_raw_parts
(
dic_buf
dic_len
as
usize
)
)
.
find_hyphen_values
(
word_str
.
unwrap
(
)
hyphen_buf
)
as
i32
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mapped_hyph_is_valid_hyphenator
(
dic_buf
:
*
const
u8
dic_len
:
u32
)
-
>
bool
{
if
dic_buf
.
is_null
(
)
{
return
false
;
}
let
dic
=
Hyphenator
:
:
new
(
slice
:
:
from_raw_parts
(
dic_buf
dic_len
as
usize
)
)
;
dic
.
is_valid_hyphenator
(
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mapped_hyph_free_compiled_data
(
data
:
*
mut
CompiledData
)
{
Box
:
:
from_raw
(
data
)
;
}
fn
compile_and_wrap
<
T
:
Read
>
(
input
:
T
compress
:
bool
)
-
>
*
const
CompiledData
{
let
mut
compiled
:
Vec
<
u8
>
=
vec
!
[
]
;
if
super
:
:
builder
:
:
compile
(
input
&
mut
compiled
compress
)
.
is_err
(
)
{
return
std
:
:
ptr
:
:
null
(
)
;
}
compiled
.
shrink_to_fit
(
)
;
Box
:
:
into_raw
(
Box
:
:
new
(
compiled
)
)
as
*
const
CompiledData
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mapped_hyph_compile_buffer
(
pattern_buf
:
*
const
u8
pattern_len
:
u32
compress
:
bool
)
-
>
*
const
CompiledData
{
compile_and_wrap
(
slice
:
:
from_raw_parts
(
pattern_buf
pattern_len
as
usize
)
compress
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mapped_hyph_compile_file
(
path
:
*
const
c_char
compress
:
bool
)
-
>
*
const
CompiledData
{
let
path_str
=
match
CStr
:
:
from_ptr
(
path
)
.
to_str
(
)
{
Ok
(
str
)
=
>
str
Err
(
_
)
=
>
return
std
:
:
ptr
:
:
null
(
)
}
;
let
in_file
=
match
File
:
:
open
(
path_str
)
{
Ok
(
file
)
=
>
file
Err
(
_
)
=
>
return
std
:
:
ptr
:
:
null
(
)
}
;
compile_and_wrap
(
&
in_file
compress
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mapped_hyph_compiled_data_size
(
data
:
*
const
CompiledData
)
-
>
u32
{
(
&
*
(
data
as
*
const
Vec
<
u8
>
)
)
.
len
(
)
as
u32
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mapped_hyph_compiled_data_ptr
(
data
:
*
const
CompiledData
)
-
>
*
const
u8
{
(
&
*
(
data
as
*
const
Vec
<
u8
>
)
)
.
as_ptr
(
)
}
