use
crate
:
:
provider
:
:
*
;
use
crate
:
:
{
LocaleExpander
LocaleTransformError
}
;
use
icu_locid
:
:
subtags
:
:
Script
;
use
icu_locid
:
:
LanguageIdentifier
;
use
icu_provider
:
:
prelude
:
:
*
;
#
[
derive
(
Debug
PartialEq
Eq
Clone
Copy
)
]
#
[
non_exhaustive
]
pub
enum
Direction
{
LeftToRight
RightToLeft
}
#
[
derive
(
Debug
)
]
pub
struct
LocaleDirectionality
{
script_direction
:
DataPayload
<
ScriptDirectionV1Marker
>
expander
:
LocaleExpander
}
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
impl
Default
for
LocaleDirectionality
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
LocaleDirectionality
{
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
pub
const
fn
new
(
)
-
>
Self
{
Self
:
:
new_with_expander
(
LocaleExpander
:
:
new
(
)
)
}
#
[
doc
=
icu_provider
:
:
gen_any_buffer_unstable_docs
!
(
ANY
Self
:
:
new
)
]
pub
fn
try_new_with_any_provider
(
provider
:
&
(
impl
AnyProvider
+
?
Sized
)
)
-
>
Result
<
LocaleDirectionality
LocaleTransformError
>
{
let
expander
=
LocaleExpander
:
:
try_new_with_any_provider
(
provider
)
?
;
Self
:
:
try_new_with_expander_unstable
(
&
provider
.
as_downcasting
(
)
expander
)
}
#
[
doc
=
icu_provider
:
:
gen_any_buffer_unstable_docs
!
(
BUFFER
Self
:
:
new
)
]
#
[
cfg
(
feature
=
"
serde
"
)
]
pub
fn
try_new_with_buffer_provider
(
provider
:
&
(
impl
BufferProvider
+
?
Sized
)
)
-
>
Result
<
LocaleDirectionality
LocaleTransformError
>
{
let
expander
=
LocaleExpander
:
:
try_new_with_buffer_provider
(
provider
)
?
;
Self
:
:
try_new_with_expander_unstable
(
&
provider
.
as_deserializing
(
)
expander
)
}
#
[
doc
=
icu_provider
:
:
gen_any_buffer_unstable_docs
!
(
UNSTABLE
Self
:
:
new
)
]
pub
fn
try_new_unstable
<
P
>
(
provider
:
&
P
)
-
>
Result
<
LocaleDirectionality
LocaleTransformError
>
where
P
:
DataProvider
<
ScriptDirectionV1Marker
>
+
DataProvider
<
LikelySubtagsForLanguageV1Marker
>
+
DataProvider
<
LikelySubtagsForScriptRegionV1Marker
>
+
?
Sized
{
let
expander
=
LocaleExpander
:
:
try_new_unstable
(
provider
)
?
;
Self
:
:
try_new_with_expander_unstable
(
provider
expander
)
}
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
pub
const
fn
new_with_expander
(
expander
:
LocaleExpander
)
-
>
Self
{
LocaleDirectionality
{
script_direction
:
DataPayload
:
:
from_static_ref
(
crate
:
:
provider
:
:
Baked
:
:
SINGLETON_LOCID_TRANSFORM_SCRIPT_DIR_V1
)
expander
}
}
#
[
doc
=
icu_provider
:
:
gen_any_buffer_unstable_docs
!
(
UNSTABLE
Self
:
:
new_with_expander
)
]
pub
fn
try_new_with_expander_unstable
<
P
>
(
provider
:
&
P
expander
:
LocaleExpander
)
-
>
Result
<
LocaleDirectionality
LocaleTransformError
>
where
P
:
DataProvider
<
ScriptDirectionV1Marker
>
+
?
Sized
{
let
script_direction
=
provider
.
load
(
Default
:
:
default
(
)
)
?
.
take_payload
(
)
?
;
Ok
(
LocaleDirectionality
{
script_direction
expander
}
)
}
pub
fn
get
(
&
self
locale
:
impl
AsRef
<
LanguageIdentifier
>
)
-
>
Option
<
Direction
>
{
let
script
=
self
.
expander
.
get_likely_script
(
locale
.
as_ref
(
)
)
?
;
if
self
.
script_in_ltr
(
script
)
{
Some
(
Direction
:
:
LeftToRight
)
}
else
if
self
.
script_in_rtl
(
script
)
{
Some
(
Direction
:
:
RightToLeft
)
}
else
{
None
}
}
pub
fn
is_right_to_left
(
&
self
locale
:
impl
AsRef
<
LanguageIdentifier
>
)
-
>
bool
{
self
.
expander
.
get_likely_script
(
locale
.
as_ref
(
)
)
.
map
(
|
s
|
self
.
script_in_rtl
(
s
)
)
.
unwrap_or
(
false
)
}
pub
fn
is_left_to_right
(
&
self
locale
:
impl
AsRef
<
LanguageIdentifier
>
)
-
>
bool
{
self
.
expander
.
get_likely_script
(
locale
.
as_ref
(
)
)
.
map
(
|
s
|
self
.
script_in_ltr
(
s
)
)
.
unwrap_or
(
false
)
}
fn
script_in_rtl
(
&
self
script
:
Script
)
-
>
bool
{
self
.
script_direction
.
get
(
)
.
rtl
.
binary_search
(
&
script
.
into_tinystr
(
)
.
to_unvalidated
(
)
)
.
is_ok
(
)
}
fn
script_in_ltr
(
&
self
script
:
Script
)
-
>
bool
{
self
.
script_direction
.
get
(
)
.
ltr
.
binary_search
(
&
script
.
into_tinystr
(
)
.
to_unvalidated
(
)
)
.
is_ok
(
)
}
}
