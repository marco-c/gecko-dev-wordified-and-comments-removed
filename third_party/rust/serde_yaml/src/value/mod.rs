use
std
:
:
f64
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
str
:
:
FromStr
;
use
serde
:
:
de
:
:
{
Deserialize
DeserializeOwned
}
;
use
serde
:
:
Serialize
;
use
yaml_rust
:
:
Yaml
;
use
error
:
:
Error
;
use
mapping
:
:
Mapping
;
use
ser
:
:
Serializer
;
pub
use
self
:
:
index
:
:
Index
;
pub
use
number
:
:
Number
;
#
[
derive
(
Clone
PartialOrd
Debug
)
]
pub
enum
Value
{
Null
Bool
(
bool
)
Number
(
Number
)
String
(
String
)
Sequence
(
Sequence
)
Mapping
(
Mapping
)
}
impl
Default
for
Value
{
fn
default
(
)
-
>
Value
{
Value
:
:
Null
}
}
pub
type
Sequence
=
Vec
<
Value
>
;
pub
fn
to_value
<
T
>
(
value
:
T
)
-
>
Result
<
Value
Error
>
where
T
:
Serialize
{
value
.
serialize
(
Serializer
)
.
map
(
yaml_to_value
)
}
pub
fn
from_value
<
T
>
(
value
:
Value
)
-
>
Result
<
T
Error
>
where
T
:
DeserializeOwned
{
Deserialize
:
:
deserialize
(
value
)
}
impl
Value
{
pub
fn
get
<
I
:
Index
>
(
&
self
index
:
I
)
-
>
Option
<
&
Value
>
{
index
.
index_into
(
self
)
}
pub
fn
get_mut
<
I
:
Index
>
(
&
mut
self
index
:
I
)
-
>
Option
<
&
mut
Value
>
{
index
.
index_into_mut
(
self
)
}
pub
fn
is_null
(
&
self
)
-
>
bool
{
if
let
Value
:
:
Null
=
*
self
{
true
}
else
{
false
}
}
pub
fn
as_null
(
&
self
)
-
>
Option
<
(
)
>
{
match
*
self
{
Value
:
:
Null
=
>
Some
(
(
)
)
_
=
>
None
}
}
pub
fn
is_bool
(
&
self
)
-
>
bool
{
self
.
as_bool
(
)
.
is_some
(
)
}
pub
fn
as_bool
(
&
self
)
-
>
Option
<
bool
>
{
match
*
self
{
Value
:
:
Bool
(
b
)
=
>
Some
(
b
)
_
=
>
None
}
}
pub
fn
is_number
(
&
self
)
-
>
bool
{
match
*
self
{
Value
:
:
Number
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
is_i64
(
&
self
)
-
>
bool
{
self
.
as_i64
(
)
.
is_some
(
)
}
pub
fn
as_i64
(
&
self
)
-
>
Option
<
i64
>
{
match
*
self
{
Value
:
:
Number
(
ref
n
)
=
>
n
.
as_i64
(
)
_
=
>
None
}
}
pub
fn
is_u64
(
&
self
)
-
>
bool
{
self
.
as_u64
(
)
.
is_some
(
)
}
pub
fn
as_u64
(
&
self
)
-
>
Option
<
u64
>
{
match
*
self
{
Value
:
:
Number
(
ref
n
)
=
>
n
.
as_u64
(
)
_
=
>
None
}
}
pub
fn
is_f64
(
&
self
)
-
>
bool
{
match
*
self
{
Value
:
:
Number
(
ref
n
)
=
>
n
.
is_f64
(
)
_
=
>
false
}
}
pub
fn
as_f64
(
&
self
)
-
>
Option
<
f64
>
{
match
*
self
{
Value
:
:
Number
(
ref
i
)
=
>
i
.
as_f64
(
)
_
=
>
None
}
}
pub
fn
is_string
(
&
self
)
-
>
bool
{
self
.
as_str
(
)
.
is_some
(
)
}
pub
fn
as_str
(
&
self
)
-
>
Option
<
&
str
>
{
match
*
self
{
Value
:
:
String
(
ref
s
)
=
>
Some
(
s
)
_
=
>
None
}
}
pub
fn
is_sequence
(
&
self
)
-
>
bool
{
self
.
as_sequence
(
)
.
is_some
(
)
}
pub
fn
as_sequence
(
&
self
)
-
>
Option
<
&
Sequence
>
{
match
*
self
{
Value
:
:
Sequence
(
ref
seq
)
=
>
Some
(
seq
)
_
=
>
None
}
}
pub
fn
as_sequence_mut
(
&
mut
self
)
-
>
Option
<
&
mut
Sequence
>
{
match
*
self
{
Value
:
:
Sequence
(
ref
mut
seq
)
=
>
Some
(
seq
)
_
=
>
None
}
}
pub
fn
is_mapping
(
&
self
)
-
>
bool
{
self
.
as_mapping
(
)
.
is_some
(
)
}
pub
fn
as_mapping
(
&
self
)
-
>
Option
<
&
Mapping
>
{
match
*
self
{
Value
:
:
Mapping
(
ref
map
)
=
>
Some
(
map
)
_
=
>
None
}
}
pub
fn
as_mapping_mut
(
&
mut
self
)
-
>
Option
<
&
mut
Mapping
>
{
match
*
self
{
Value
:
:
Mapping
(
ref
mut
map
)
=
>
Some
(
map
)
_
=
>
None
}
}
}
fn
yaml_to_value
(
yaml
:
Yaml
)
-
>
Value
{
match
yaml
{
Yaml
:
:
Real
(
f
)
=
>
{
if
f
=
=
"
.
inf
"
{
Value
:
:
Number
(
f64
:
:
INFINITY
.
into
(
)
)
}
else
if
f
=
=
"
-
.
inf
"
{
Value
:
:
Number
(
f64
:
:
NEG_INFINITY
.
into
(
)
)
}
else
if
f
=
=
"
.
nan
"
{
Value
:
:
Number
(
f64
:
:
NAN
.
into
(
)
)
}
else
if
let
Ok
(
n
)
=
u64
:
:
from_str
(
&
f
)
{
Value
:
:
Number
(
n
.
into
(
)
)
}
else
if
let
Ok
(
n
)
=
i64
:
:
from_str
(
&
f
)
{
Value
:
:
Number
(
n
.
into
(
)
)
}
else
if
let
Ok
(
n
)
=
f64
:
:
from_str
(
&
f
)
{
Value
:
:
Number
(
n
.
into
(
)
)
}
else
{
Value
:
:
String
(
f
)
}
}
Yaml
:
:
Integer
(
i
)
=
>
Value
:
:
Number
(
i
.
into
(
)
)
Yaml
:
:
String
(
s
)
=
>
Value
:
:
String
(
s
)
Yaml
:
:
Boolean
(
b
)
=
>
Value
:
:
Bool
(
b
)
Yaml
:
:
Array
(
sequence
)
=
>
Value
:
:
Sequence
(
sequence
.
into_iter
(
)
.
map
(
yaml_to_value
)
.
collect
(
)
)
Yaml
:
:
Hash
(
hash
)
=
>
Value
:
:
Mapping
(
hash
.
into_iter
(
)
.
map
(
|
(
k
v
)
|
(
yaml_to_value
(
k
)
yaml_to_value
(
v
)
)
)
.
collect
(
)
)
Yaml
:
:
Alias
(
_
)
=
>
panic
!
(
"
alias
unsupported
"
)
Yaml
:
:
Null
=
>
Value
:
:
Null
Yaml
:
:
BadValue
=
>
panic
!
(
"
bad
value
"
)
}
}
impl
Eq
for
Value
{
}
impl
Hash
for
Value
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
match
*
self
{
Value
:
:
Null
=
>
0
.
hash
(
state
)
Value
:
:
Bool
(
b
)
=
>
(
1
b
)
.
hash
(
state
)
Value
:
:
Number
(
ref
i
)
=
>
(
2
i
)
.
hash
(
state
)
Value
:
:
String
(
ref
s
)
=
>
(
3
s
)
.
hash
(
state
)
Value
:
:
Sequence
(
ref
seq
)
=
>
(
4
seq
)
.
hash
(
state
)
Value
:
:
Mapping
(
ref
map
)
=
>
(
5
map
)
.
hash
(
state
)
}
}
}
mod
from
;
mod
index
;
mod
partial_eq
;
mod
de
;
mod
ser
;
