#
!
[
warn
(
rust_2018_idioms
)
]
#
!
[
cfg
(
feature
=
"
full
"
)
]
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
use
futures
:
:
{
Stream
StreamExt
}
;
use
tokio
:
:
time
:
:
{
self
Duration
Instant
Interval
MissedTickBehavior
}
;
use
tokio_test
:
:
{
assert_pending
assert_ready_eq
task
}
;
macro_rules
!
check_interval_poll
{
(
i
:
ident
start
:
ident
(
delta
:
expr
)
*
(
)
?
)
=
>
{
(
assert_ready_eq
!
(
poll_next
(
&
mut
i
)
start
+
ms
(
delta
)
)
;
)
*
assert_pending
!
(
poll_next
(
&
mut
i
)
)
;
}
;
(
i
:
ident
start
:
ident
)
=
>
{
check_interval_poll
!
(
i
start
)
;
}
;
}
#
[
tokio
:
:
test
]
#
[
should_panic
]
async
fn
interval_zero_duration
(
)
{
let
_
=
time
:
:
interval_at
(
Instant
:
:
now
(
)
ms
(
0
)
)
;
}
#
[
tokio
:
:
test
(
start_paused
=
true
)
]
async
fn
burst
(
)
{
let
start
=
Instant
:
:
now
(
)
;
time
:
:
advance
(
ms
(
1
)
)
.
await
;
let
mut
i
=
task
:
:
spawn
(
time
:
:
interval_at
(
start
ms
(
300
)
)
)
;
check_interval_poll
!
(
i
start
0
)
;
time
:
:
advance
(
ms
(
100
)
)
.
await
;
check_interval_poll
!
(
i
start
)
;
time
:
:
advance
(
ms
(
200
)
)
.
await
;
check_interval_poll
!
(
i
start
300
)
;
time
:
:
advance
(
ms
(
650
)
)
.
await
;
check_interval_poll
!
(
i
start
600
900
)
;
time
:
:
advance
(
ms
(
200
)
)
.
await
;
check_interval_poll
!
(
i
start
)
;
time
:
:
advance
(
ms
(
100
)
)
.
await
;
check_interval_poll
!
(
i
start
1200
)
;
time
:
:
advance
(
ms
(
250
)
)
.
await
;
check_interval_poll
!
(
i
start
1500
)
;
time
:
:
advance
(
ms
(
300
)
)
.
await
;
check_interval_poll
!
(
i
start
1800
)
;
}
#
[
tokio
:
:
test
(
start_paused
=
true
)
]
async
fn
delay
(
)
{
let
start
=
Instant
:
:
now
(
)
;
time
:
:
advance
(
ms
(
1
)
)
.
await
;
let
mut
i
=
task
:
:
spawn
(
time
:
:
interval_at
(
start
ms
(
300
)
)
)
;
i
.
set_missed_tick_behavior
(
MissedTickBehavior
:
:
Delay
)
;
check_interval_poll
!
(
i
start
0
)
;
time
:
:
advance
(
ms
(
100
)
)
.
await
;
check_interval_poll
!
(
i
start
)
;
time
:
:
advance
(
ms
(
200
)
)
.
await
;
check_interval_poll
!
(
i
start
300
)
;
time
:
:
advance
(
ms
(
650
)
)
.
await
;
check_interval_poll
!
(
i
start
600
)
;
time
:
:
advance
(
ms
(
100
)
)
.
await
;
check_interval_poll
!
(
i
start
)
;
time
:
:
advance
(
ms
(
201
)
)
.
await
;
check_interval_poll
!
(
i
start
1251
)
;
time
:
:
advance
(
ms
(
300
)
)
.
await
;
check_interval_poll
!
(
i
start
1551
)
;
time
:
:
advance
(
ms
(
300
)
)
.
await
;
check_interval_poll
!
(
i
start
1851
)
;
}
#
[
tokio
:
:
test
(
start_paused
=
true
)
]
async
fn
skip
(
)
{
let
start
=
Instant
:
:
now
(
)
;
time
:
:
advance
(
ms
(
1
)
)
.
await
;
let
mut
i
=
task
:
:
spawn
(
time
:
:
interval_at
(
start
ms
(
300
)
)
)
;
i
.
set_missed_tick_behavior
(
MissedTickBehavior
:
:
Skip
)
;
check_interval_poll
!
(
i
start
0
)
;
time
:
:
advance
(
ms
(
100
)
)
.
await
;
check_interval_poll
!
(
i
start
)
;
time
:
:
advance
(
ms
(
200
)
)
.
await
;
check_interval_poll
!
(
i
start
300
)
;
time
:
:
advance
(
ms
(
650
)
)
.
await
;
check_interval_poll
!
(
i
start
600
)
;
time
:
:
advance
(
ms
(
250
)
)
.
await
;
check_interval_poll
!
(
i
start
1200
)
;
time
:
:
advance
(
ms
(
300
)
)
.
await
;
check_interval_poll
!
(
i
start
1500
)
;
time
:
:
advance
(
ms
(
300
)
)
.
await
;
check_interval_poll
!
(
i
start
1800
)
;
}
#
[
tokio
:
:
test
(
start_paused
=
true
)
]
async
fn
reset
(
)
{
let
start
=
Instant
:
:
now
(
)
;
time
:
:
advance
(
ms
(
1
)
)
.
await
;
let
mut
i
=
task
:
:
spawn
(
time
:
:
interval_at
(
start
ms
(
300
)
)
)
;
check_interval_poll
!
(
i
start
0
)
;
time
:
:
advance
(
ms
(
100
)
)
.
await
;
check_interval_poll
!
(
i
start
)
;
time
:
:
advance
(
ms
(
200
)
)
.
await
;
check_interval_poll
!
(
i
start
300
)
;
time
:
:
advance
(
ms
(
100
)
)
.
await
;
check_interval_poll
!
(
i
start
)
;
i
.
reset
(
)
;
time
:
:
advance
(
ms
(
250
)
)
.
await
;
check_interval_poll
!
(
i
start
)
;
time
:
:
advance
(
ms
(
50
)
)
.
await
;
check_interval_poll
!
(
i
start
701
)
;
time
:
:
advance
(
ms
(
300
)
)
.
await
;
check_interval_poll
!
(
i
start
1001
)
;
}
fn
poll_next
(
interval
:
&
mut
task
:
:
Spawn
<
time
:
:
Interval
>
)
-
>
Poll
<
Instant
>
{
interval
.
enter
(
|
cx
mut
interval
|
interval
.
poll_tick
(
cx
)
)
}
fn
ms
(
n
:
u64
)
-
>
Duration
{
Duration
:
:
from_millis
(
n
)
}
struct
IntervalStreamer
{
counter
:
u32
timer
:
Interval
wake_on_pending
:
bool
}
impl
Stream
for
IntervalStreamer
{
type
Item
=
u32
;
fn
poll_next
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
>
{
let
this
=
Pin
:
:
into_inner
(
self
)
;
if
this
.
counter
>
12
{
return
Poll
:
:
Ready
(
None
)
;
}
match
this
.
timer
.
poll_tick
(
cx
)
{
Poll
:
:
Pending
=
>
Poll
:
:
Pending
Poll
:
:
Ready
(
_
)
=
>
{
this
.
counter
+
=
1
;
if
this
.
counter
%
4
=
=
0
{
Poll
:
:
Ready
(
Some
(
this
.
counter
)
)
}
else
{
if
this
.
wake_on_pending
{
cx
.
waker
(
)
.
wake_by_ref
(
)
;
}
Poll
:
:
Pending
}
}
}
}
}
#
[
tokio
:
:
test
(
start_paused
=
true
)
]
async
fn
stream_with_interval_poll_tick_self_waking
(
)
{
let
stream
=
IntervalStreamer
{
counter
:
0
timer
:
tokio
:
:
time
:
:
interval
(
tokio
:
:
time
:
:
Duration
:
:
from_millis
(
10
)
)
wake_on_pending
:
true
}
;
let
(
res_tx
mut
res_rx
)
=
tokio
:
:
sync
:
:
mpsc
:
:
channel
(
12
)
;
tokio
:
:
spawn
(
tokio
:
:
time
:
:
timeout
(
tokio
:
:
time
:
:
Duration
:
:
from_millis
(
150
)
async
move
{
tokio
:
:
pin
!
(
stream
)
;
while
let
Some
(
item
)
=
stream
.
next
(
)
.
await
{
res_tx
.
send
(
item
)
.
await
.
ok
(
)
;
}
}
)
)
;
let
mut
items
=
Vec
:
:
with_capacity
(
3
)
;
while
let
Some
(
result
)
=
res_rx
.
recv
(
)
.
await
{
items
.
push
(
result
)
;
}
assert_eq
!
(
items
vec
!
[
4
8
12
]
)
;
}
#
[
tokio
:
:
test
(
start_paused
=
true
)
]
async
fn
stream_with_interval_poll_tick_no_waking
(
)
{
let
stream
=
IntervalStreamer
{
counter
:
0
timer
:
tokio
:
:
time
:
:
interval
(
tokio
:
:
time
:
:
Duration
:
:
from_millis
(
10
)
)
wake_on_pending
:
false
}
;
let
(
res_tx
mut
res_rx
)
=
tokio
:
:
sync
:
:
mpsc
:
:
channel
(
12
)
;
tokio
:
:
spawn
(
tokio
:
:
time
:
:
timeout
(
tokio
:
:
time
:
:
Duration
:
:
from_millis
(
150
)
async
move
{
tokio
:
:
pin
!
(
stream
)
;
while
let
Some
(
item
)
=
stream
.
next
(
)
.
await
{
res_tx
.
send
(
item
)
.
await
.
ok
(
)
;
}
}
)
)
;
let
mut
items
=
Vec
:
:
with_capacity
(
0
)
;
while
let
Some
(
result
)
=
res_rx
.
recv
(
)
.
await
{
items
.
push
(
result
)
;
}
assert_eq
!
(
items
vec
!
[
]
)
;
}
