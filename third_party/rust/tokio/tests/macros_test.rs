#
!
[
cfg
(
all
(
feature
=
"
full
"
not
(
target_os
=
"
wasi
"
)
)
)
]
use
tokio
:
:
test
;
#
[
test
]
async
fn
test_macro_can_be_used_via_use
(
)
{
tokio
:
:
spawn
(
async
{
}
)
.
await
.
unwrap
(
)
;
}
#
[
tokio
:
:
test
]
async
fn
test_macro_is_resilient_to_shadowing
(
)
{
tokio
:
:
spawn
(
async
{
}
)
.
await
.
unwrap
(
)
;
}
#
[
rustfmt
:
:
skip
]
#
[
tokio
:
:
main
]
pub
async
fn
unused_braces_main
(
)
{
println
!
(
"
hello
"
)
}
#
[
rustfmt
:
:
skip
]
#
[
tokio
:
:
test
]
async
fn
unused_braces_test
(
)
{
assert_eq
!
(
1
+
1
2
)
}
#
[
std
:
:
prelude
:
:
v1
:
:
test
]
fn
trait_method
(
)
{
trait
A
{
fn
f
(
self
)
;
fn
g
(
self
)
;
}
impl
A
for
(
)
{
#
[
tokio
:
:
main
]
async
fn
f
(
self
)
{
self
.
g
(
)
}
fn
g
(
self
)
{
}
}
(
)
.
f
(
)
}
#
[
tokio
:
:
main
]
pub
async
fn
issue_4175_main_1
(
)
-
>
!
{
panic
!
(
)
;
}
#
[
tokio
:
:
main
]
pub
async
fn
issue_4175_main_2
(
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
panic
!
(
)
;
}
#
[
allow
(
unreachable_code
)
]
#
[
tokio
:
:
test
]
pub
async
fn
issue_4175_test
(
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
return
Ok
(
(
)
)
;
panic
!
(
)
;
}
#
[
allow
(
clippy
:
:
let_unit_value
)
]
pub
mod
clippy_semicolon_if_nothing_returned
{
#
!
[
deny
(
clippy
:
:
semicolon_if_nothing_returned
)
]
#
[
tokio
:
:
main
]
pub
async
fn
local
(
)
{
let
_x
=
(
)
;
}
#
[
tokio
:
:
main
]
pub
async
fn
item
(
)
{
fn
_f
(
)
{
}
}
#
[
tokio
:
:
main
]
pub
async
fn
semi
(
)
{
panic
!
(
)
;
}
#
[
tokio
:
:
main
]
pub
async
fn
empty
(
)
{
}
}
pub
mod
issue_5243
{
macro_rules
!
mac
{
(
async
fn
name
:
ident
(
)
b
:
block
)
=
>
{
#
[
:
:
tokio
:
:
test
]
async
fn
name
(
)
{
b
}
}
;
}
mac
!
(
async
fn
foo
(
)
{
}
)
;
}
#
[
cfg
(
tokio_unstable
)
]
pub
mod
macro_rt_arg_unhandled_panic
{
use
tokio_test
:
:
assert_err
;
#
[
tokio
:
:
test
(
flavor
=
"
current_thread
"
unhandled_panic
=
"
shutdown_runtime
"
)
]
#
[
should_panic
]
async
fn
unhandled_panic_shutdown_runtime
(
)
{
let
_
=
tokio
:
:
spawn
(
async
{
panic
!
(
"
This
panic
should
shutdown
the
runtime
.
"
)
;
}
)
.
await
;
}
#
[
tokio
:
:
test
(
flavor
=
"
current_thread
"
unhandled_panic
=
"
ignore
"
)
]
async
fn
unhandled_panic_ignore
(
)
{
let
rt
=
tokio
:
:
spawn
(
async
{
panic
!
(
"
This
panic
should
be
forwarded
to
rt
as
an
error
.
"
)
;
}
)
.
await
;
assert_err
!
(
rt
)
;
}
}
