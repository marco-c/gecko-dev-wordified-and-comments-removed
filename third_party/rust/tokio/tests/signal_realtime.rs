#
!
[
warn
(
rust_2018_idioms
)
]
#
!
[
cfg
(
feature
=
"
full
"
)
]
#
!
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
illumos
"
)
)
]
#
!
[
cfg
(
not
(
miri
)
)
]
mod
support
{
pub
mod
signal
;
}
use
libc
:
:
c_int
;
use
support
:
:
signal
:
:
send_signal
;
use
futures
:
:
stream
:
:
{
FuturesUnordered
StreamExt
}
;
use
std
:
:
collections
:
:
HashMap
;
use
tokio
:
:
signal
:
:
unix
:
:
{
signal
SignalKind
}
;
use
tokio
:
:
time
:
:
{
sleep
Duration
}
;
use
tokio_test
:
:
assert_ok
;
#
[
tokio
:
:
test
]
async
fn
signal_realtime
(
)
{
let
signals
=
(
libc
:
:
SIGRTMIN
(
)
.
.
=
sigrt_max
(
)
)
.
map
(
|
signum
|
{
let
sig
=
assert_ok
!
(
signal
(
SignalKind
:
:
from_raw
(
signum
)
)
"
failed
to
create
signal
for
{
}
"
sigrtnum_to_string
(
signum
)
)
;
(
signum
sig
)
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
eprintln
!
(
"
registered
{
}
signals
in
the
range
{
}
.
.
=
{
}
"
signals
.
len
(
)
libc
:
:
SIGRTMIN
(
)
libc
:
:
SIGRTMAX
(
)
)
;
for
signum
in
libc
:
:
SIGRTMIN
(
)
.
.
=
sigrt_max
(
)
{
send_signal
(
signum
)
;
}
let
futures
=
signals
.
into_iter
(
)
.
map
(
|
(
signum
mut
sig
)
|
async
move
{
let
res
=
sig
.
recv
(
)
.
await
;
(
signum
res
)
}
)
.
collect
:
:
<
FuturesUnordered
<
_
>
>
(
)
;
let
sleep
=
std
:
:
pin
:
:
pin
!
(
sleep
(
Duration
:
:
from_secs
(
5
)
)
)
;
let
done
=
futures
.
take_until
(
sleep
)
.
collect
:
:
<
HashMap
<
_
_
>
>
(
)
.
await
;
let
mut
none
=
Vec
:
:
new
(
)
;
let
mut
missing
=
Vec
:
:
new
(
)
;
for
signum
in
libc
:
:
SIGRTMIN
(
)
.
.
=
sigrt_max
(
)
{
match
done
.
get
(
&
signum
)
{
Some
(
Some
(
(
)
)
)
=
>
{
}
Some
(
None
)
=
>
none
.
push
(
signum
)
None
=
>
missing
.
push
(
signum
)
}
}
if
none
.
is_empty
(
)
&
&
missing
.
is_empty
(
)
{
return
;
}
let
mut
msg
=
String
:
:
new
(
)
;
if
!
none
.
is_empty
(
)
{
msg
.
push_str
(
"
no
signals
received
for
:
\
n
"
)
;
for
signum
in
none
{
msg
.
push_str
(
&
format
!
(
"
-
{
}
\
n
"
sigrtnum_to_string
(
signum
)
)
)
;
}
}
if
!
missing
.
is_empty
(
)
{
msg
.
push_str
(
"
missing
signals
for
:
\
n
"
)
;
for
signum
in
missing
{
msg
.
push_str
(
&
format
!
(
"
-
{
}
\
n
"
sigrtnum_to_string
(
signum
)
)
)
;
}
}
panic
!
(
"
{
}
"
msg
)
;
}
fn
sigrt_max
(
)
-
>
c_int
{
libc
:
:
SIGRTMAX
(
)
.
min
(
libc
:
:
SIGRTMIN
(
)
+
27
)
}
fn
sigrtnum_to_string
(
signum
:
i32
)
-
>
String
{
format
!
(
"
SIGRTMIN
+
{
}
(
signal
{
}
)
"
signum
-
libc
:
:
SIGRTMIN
(
)
signum
)
}
