mod
atomic_stack
;
use
self
:
:
atomic_stack
:
:
AtomicStack
;
mod
entry
;
pub
(
super
)
use
self
:
:
entry
:
:
Entry
;
mod
handle
;
pub
(
crate
)
use
self
:
:
handle
:
:
Handle
;
mod
registration
;
pub
(
crate
)
use
self
:
:
registration
:
:
Registration
;
mod
stack
;
use
self
:
:
stack
:
:
Stack
;
use
crate
:
:
loom
:
:
sync
:
:
atomic
:
:
{
AtomicU64
AtomicUsize
}
;
use
crate
:
:
park
:
:
{
Park
Unpark
}
;
use
crate
:
:
time
:
:
{
wheel
Error
}
;
use
crate
:
:
time
:
:
{
Clock
Duration
Instant
}
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
Acquire
Relaxed
Release
SeqCst
}
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
usize
;
use
std
:
:
{
cmp
fmt
}
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Driver
<
T
:
Park
>
{
inner
:
Arc
<
Inner
>
wheel
:
wheel
:
:
Wheel
<
Stack
>
park
:
T
clock
:
Clock
is_shutdown
:
bool
}
pub
(
crate
)
struct
Inner
{
start
:
Instant
elapsed
:
AtomicU64
num
:
AtomicUsize
process
:
AtomicStack
unpark
:
Box
<
dyn
Unpark
>
}
const
MAX_TIMEOUTS
:
usize
=
usize
:
:
MAX
>
>
1
;
impl
<
T
>
Driver
<
T
>
where
T
:
Park
{
pub
(
crate
)
fn
new
(
park
:
T
clock
:
Clock
)
-
>
Driver
<
T
>
{
let
unpark
=
Box
:
:
new
(
park
.
unpark
(
)
)
;
Driver
{
inner
:
Arc
:
:
new
(
Inner
:
:
new
(
clock
.
now
(
)
unpark
)
)
wheel
:
wheel
:
:
Wheel
:
:
new
(
)
park
clock
is_shutdown
:
false
}
}
pub
(
crate
)
fn
handle
(
&
self
)
-
>
Handle
{
Handle
:
:
new
(
Arc
:
:
downgrade
(
&
self
.
inner
)
)
}
fn
expiration_instant
(
&
self
when
:
u64
)
-
>
Instant
{
self
.
inner
.
start
+
Duration
:
:
from_millis
(
when
)
}
fn
process
(
&
mut
self
)
{
let
now
=
crate
:
:
time
:
:
ms
(
self
.
clock
.
now
(
)
-
self
.
inner
.
start
crate
:
:
time
:
:
Round
:
:
Down
)
;
let
mut
poll
=
wheel
:
:
Poll
:
:
new
(
now
)
;
while
let
Some
(
entry
)
=
self
.
wheel
.
poll
(
&
mut
poll
&
mut
(
)
)
{
let
when
=
entry
.
when_internal
(
)
.
expect
(
"
invalid
internal
entry
state
"
)
;
entry
.
fire
(
when
)
;
entry
.
set_when_internal
(
None
)
;
}
self
.
inner
.
elapsed
.
store
(
self
.
wheel
.
elapsed
(
)
SeqCst
)
;
}
fn
process_queue
(
&
mut
self
)
{
for
entry
in
self
.
inner
.
process
.
take
(
)
{
match
(
entry
.
when_internal
(
)
entry
.
load_state
(
)
)
{
(
None
None
)
=
>
{
}
(
Some
(
_
)
None
)
=
>
{
self
.
clear_entry
(
&
entry
)
;
}
(
None
Some
(
when
)
)
=
>
{
self
.
add_entry
(
entry
when
)
;
}
(
Some
(
_
)
Some
(
next
)
)
=
>
{
self
.
clear_entry
(
&
entry
)
;
self
.
add_entry
(
entry
next
)
;
}
}
}
}
fn
clear_entry
(
&
mut
self
entry
:
&
Arc
<
Entry
>
)
{
self
.
wheel
.
remove
(
entry
&
mut
(
)
)
;
entry
.
set_when_internal
(
None
)
;
}
fn
add_entry
(
&
mut
self
entry
:
Arc
<
Entry
>
when
:
u64
)
{
use
crate
:
:
time
:
:
wheel
:
:
InsertError
;
entry
.
set_when_internal
(
Some
(
when
)
)
;
match
self
.
wheel
.
insert
(
when
entry
&
mut
(
)
)
{
Ok
(
_
)
=
>
{
}
Err
(
(
entry
InsertError
:
:
Elapsed
)
)
=
>
{
entry
.
set_when_internal
(
None
)
;
entry
.
fire
(
when
)
;
}
Err
(
(
entry
InsertError
:
:
Invalid
)
)
=
>
{
entry
.
set_when_internal
(
None
)
;
entry
.
error
(
Error
:
:
invalid
(
)
)
;
}
}
}
}
impl
<
T
>
Park
for
Driver
<
T
>
where
T
:
Park
{
type
Unpark
=
T
:
:
Unpark
;
type
Error
=
T
:
:
Error
;
fn
unpark
(
&
self
)
-
>
Self
:
:
Unpark
{
self
.
park
.
unpark
(
)
}
fn
park
(
&
mut
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
process_queue
(
)
;
match
self
.
wheel
.
poll_at
(
)
{
Some
(
when
)
=
>
{
let
now
=
self
.
clock
.
now
(
)
;
let
deadline
=
self
.
expiration_instant
(
when
)
;
if
deadline
>
now
{
let
dur
=
deadline
-
now
;
if
self
.
clock
.
is_paused
(
)
{
self
.
park
.
park_timeout
(
Duration
:
:
from_secs
(
0
)
)
?
;
self
.
clock
.
advance
(
dur
)
;
}
else
{
self
.
park
.
park_timeout
(
dur
)
?
;
}
}
else
{
self
.
park
.
park_timeout
(
Duration
:
:
from_secs
(
0
)
)
?
;
}
}
None
=
>
{
self
.
park
.
park
(
)
?
;
}
}
self
.
process
(
)
;
Ok
(
(
)
)
}
fn
park_timeout
(
&
mut
self
duration
:
Duration
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
process_queue
(
)
;
match
self
.
wheel
.
poll_at
(
)
{
Some
(
when
)
=
>
{
let
now
=
self
.
clock
.
now
(
)
;
let
deadline
=
self
.
expiration_instant
(
when
)
;
if
deadline
>
now
{
let
duration
=
cmp
:
:
min
(
deadline
-
now
duration
)
;
if
self
.
clock
.
is_paused
(
)
{
self
.
park
.
park_timeout
(
Duration
:
:
from_secs
(
0
)
)
?
;
self
.
clock
.
advance
(
duration
)
;
}
else
{
self
.
park
.
park_timeout
(
duration
)
?
;
}
}
else
{
self
.
park
.
park_timeout
(
Duration
:
:
from_secs
(
0
)
)
?
;
}
}
None
=
>
{
self
.
park
.
park_timeout
(
duration
)
?
;
}
}
self
.
process
(
)
;
Ok
(
(
)
)
}
fn
shutdown
(
&
mut
self
)
{
if
self
.
is_shutdown
{
return
;
}
use
std
:
:
u64
;
self
.
inner
.
process
.
shutdown
(
)
;
let
mut
poll
=
wheel
:
:
Poll
:
:
new
(
u64
:
:
MAX
)
;
while
let
Some
(
entry
)
=
self
.
wheel
.
poll
(
&
mut
poll
&
mut
(
)
)
{
entry
.
error
(
Error
:
:
shutdown
(
)
)
;
}
self
.
park
.
shutdown
(
)
;
self
.
is_shutdown
=
true
;
}
}
impl
<
T
>
Drop
for
Driver
<
T
>
where
T
:
Park
{
fn
drop
(
&
mut
self
)
{
self
.
shutdown
(
)
;
}
}
impl
Inner
{
fn
new
(
start
:
Instant
unpark
:
Box
<
dyn
Unpark
>
)
-
>
Inner
{
Inner
{
num
:
AtomicUsize
:
:
new
(
0
)
elapsed
:
AtomicU64
:
:
new
(
0
)
process
:
AtomicStack
:
:
new
(
)
start
unpark
}
}
fn
elapsed
(
&
self
)
-
>
u64
{
self
.
elapsed
.
load
(
SeqCst
)
}
#
[
cfg
(
all
(
test
loom
)
)
]
fn
num
(
&
self
ordering
:
std
:
:
sync
:
:
atomic
:
:
Ordering
)
-
>
usize
{
self
.
num
.
load
(
ordering
)
}
fn
increment
(
&
self
)
-
>
Result
<
(
)
Error
>
{
let
mut
curr
=
self
.
num
.
load
(
Relaxed
)
;
loop
{
if
curr
=
=
MAX_TIMEOUTS
{
return
Err
(
Error
:
:
at_capacity
(
)
)
;
}
match
self
.
num
.
compare_exchange_weak
(
curr
curr
+
1
Release
Relaxed
)
{
Ok
(
_
)
=
>
return
Ok
(
(
)
)
Err
(
next
)
=
>
curr
=
next
}
}
}
fn
decrement
(
&
self
)
{
let
prev
=
self
.
num
.
fetch_sub
(
1
Acquire
)
;
debug_assert
!
(
prev
<
=
MAX_TIMEOUTS
)
;
}
fn
queue
(
&
self
entry
:
&
Arc
<
Entry
>
)
-
>
Result
<
(
)
Error
>
{
if
self
.
process
.
push
(
entry
)
?
{
self
.
unpark
.
unpark
(
)
;
}
Ok
(
(
)
)
}
fn
normalize_deadline
(
&
self
deadline
:
Instant
)
-
>
u64
{
if
deadline
<
self
.
start
{
return
0
;
}
crate
:
:
time
:
:
ms
(
deadline
-
self
.
start
crate
:
:
time
:
:
Round
:
:
Up
)
}
}
impl
fmt
:
:
Debug
for
Inner
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Inner
"
)
.
finish
(
)
}
}
#
[
cfg
(
all
(
test
loom
)
)
]
mod
tests
;
