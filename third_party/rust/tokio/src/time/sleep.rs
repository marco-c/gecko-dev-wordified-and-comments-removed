use
crate
:
:
runtime
:
:
time
:
:
TimerEntry
;
use
crate
:
:
time
:
:
{
error
:
:
Error
Duration
Instant
}
;
use
crate
:
:
util
:
:
trace
;
use
pin_project_lite
:
:
pin_project
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
panic
:
:
Location
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
task
:
:
{
self
Poll
}
;
#
[
cfg_attr
(
docsrs
doc
(
alias
=
"
delay_until
"
)
)
]
#
[
track_caller
]
pub
fn
sleep_until
(
deadline
:
Instant
)
-
>
Sleep
{
return
Sleep
:
:
new_timeout
(
deadline
trace
:
:
caller_location
(
)
)
;
}
#
[
cfg_attr
(
docsrs
doc
(
alias
=
"
delay_for
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
alias
=
"
wait
"
)
)
]
#
[
track_caller
]
pub
fn
sleep
(
duration
:
Duration
)
-
>
Sleep
{
let
location
=
trace
:
:
caller_location
(
)
;
match
Instant
:
:
now
(
)
.
checked_add
(
duration
)
{
Some
(
deadline
)
=
>
Sleep
:
:
new_timeout
(
deadline
location
)
None
=
>
Sleep
:
:
new_timeout
(
Instant
:
:
far_future
(
)
location
)
}
}
pin_project
!
{
/
/
/
Future
returned
by
[
sleep
]
(
sleep
)
and
[
sleep_until
]
(
sleep_until
)
.
/
/
/
/
/
/
This
type
does
not
implement
the
Unpin
trait
which
means
that
if
you
/
/
/
use
it
with
[
select
!
]
or
by
calling
poll
you
have
to
pin
it
first
.
/
/
/
If
you
use
it
with
.
await
this
does
not
apply
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
Wait
100ms
and
print
"
100
ms
have
elapsed
"
.
/
/
/
/
/
/
#
[
cfg_attr
(
docsrs
doc
(
alias
=
"
Delay
"
)
)
]
#
[
derive
(
Debug
)
]
#
[
must_use
=
"
futures
do
nothing
unless
you
.
await
or
poll
them
"
]
pub
struct
Sleep
{
inner
:
Inner
#
[
pin
]
entry
:
TimerEntry
}
}
cfg_trace
!
{
#
[
derive
(
Debug
)
]
struct
Inner
{
ctx
:
trace
:
:
AsyncOpTracingCtx
}
}
cfg_not_trace
!
{
#
[
derive
(
Debug
)
]
struct
Inner
{
}
}
impl
Sleep
{
#
[
cfg_attr
(
not
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
allow
(
unused_variables
)
)
]
#
[
track_caller
]
pub
(
crate
)
fn
new_timeout
(
deadline
:
Instant
location
:
Option
<
&
'
static
Location
<
'
static
>
>
)
-
>
Sleep
{
use
crate
:
:
runtime
:
:
scheduler
;
let
handle
=
scheduler
:
:
Handle
:
:
current
(
)
;
let
entry
=
TimerEntry
:
:
new
(
&
handle
deadline
)
;
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
inner
=
{
let
clock
=
handle
.
driver
(
)
.
clock
(
)
;
let
handle
=
&
handle
.
driver
(
)
.
time
(
)
;
let
time_source
=
handle
.
time_source
(
)
;
let
deadline_tick
=
time_source
.
deadline_to_tick
(
deadline
)
;
let
duration
=
deadline_tick
.
saturating_sub
(
time_source
.
now
(
clock
)
)
;
let
location
=
location
.
expect
(
"
should
have
location
if
tracing
"
)
;
let
resource_span
=
tracing
:
:
trace_span
!
(
"
runtime
.
resource
"
concrete_type
=
"
Sleep
"
kind
=
"
timer
"
loc
.
file
=
location
.
file
(
)
loc
.
line
=
location
.
line
(
)
loc
.
col
=
location
.
column
(
)
)
;
let
async_op_span
=
resource_span
.
in_scope
(
|
|
{
tracing
:
:
trace
!
(
target
:
"
runtime
:
:
resource
:
:
state_update
"
duration
=
duration
duration
.
unit
=
"
ms
"
duration
.
op
=
"
override
"
)
;
tracing
:
:
trace_span
!
(
"
runtime
.
resource
.
async_op
"
source
=
"
Sleep
:
:
new_timeout
"
)
}
)
;
let
async_op_poll_span
=
async_op_span
.
in_scope
(
|
|
tracing
:
:
trace_span
!
(
"
runtime
.
resource
.
async_op
.
poll
"
)
)
;
let
ctx
=
trace
:
:
AsyncOpTracingCtx
{
async_op_span
async_op_poll_span
resource_span
}
;
Inner
{
ctx
}
}
;
#
[
cfg
(
not
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
)
]
let
inner
=
Inner
{
}
;
Sleep
{
inner
entry
}
}
pub
(
crate
)
fn
far_future
(
location
:
Option
<
&
'
static
Location
<
'
static
>
>
)
-
>
Sleep
{
Self
:
:
new_timeout
(
Instant
:
:
far_future
(
)
location
)
}
pub
fn
deadline
(
&
self
)
-
>
Instant
{
self
.
entry
.
deadline
(
)
}
pub
fn
is_elapsed
(
&
self
)
-
>
bool
{
self
.
entry
.
is_elapsed
(
)
}
pub
fn
reset
(
self
:
Pin
<
&
mut
Self
>
deadline
:
Instant
)
{
self
.
reset_inner
(
deadline
)
}
pub
(
crate
)
fn
reset_without_reregister
(
self
:
Pin
<
&
mut
Self
>
deadline
:
Instant
)
{
let
mut
me
=
self
.
project
(
)
;
me
.
entry
.
as_mut
(
)
.
reset
(
deadline
false
)
;
}
fn
reset_inner
(
self
:
Pin
<
&
mut
Self
>
deadline
:
Instant
)
{
let
mut
me
=
self
.
project
(
)
;
me
.
entry
.
as_mut
(
)
.
reset
(
deadline
true
)
;
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
{
let
_resource_enter
=
me
.
inner
.
ctx
.
resource_span
.
enter
(
)
;
me
.
inner
.
ctx
.
async_op_span
=
tracing
:
:
trace_span
!
(
"
runtime
.
resource
.
async_op
"
source
=
"
Sleep
:
:
reset
"
)
;
let
_async_op_enter
=
me
.
inner
.
ctx
.
async_op_span
.
enter
(
)
;
me
.
inner
.
ctx
.
async_op_poll_span
=
tracing
:
:
trace_span
!
(
"
runtime
.
resource
.
async_op
.
poll
"
)
;
let
duration
=
{
let
clock
=
me
.
entry
.
clock
(
)
;
let
time_source
=
me
.
entry
.
driver
(
)
.
time_source
(
)
;
let
now
=
time_source
.
now
(
clock
)
;
let
deadline_tick
=
time_source
.
deadline_to_tick
(
deadline
)
;
deadline_tick
.
saturating_sub
(
now
)
}
;
tracing
:
:
trace
!
(
target
:
"
runtime
:
:
resource
:
:
state_update
"
duration
=
duration
duration
.
unit
=
"
ms
"
duration
.
op
=
"
override
"
)
;
}
}
fn
poll_elapsed
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Error
>
>
{
let
me
=
self
.
project
(
)
;
ready
!
(
crate
:
:
trace
:
:
trace_leaf
(
cx
)
)
;
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
coop
=
ready
!
(
trace_poll_op
!
(
"
poll_elapsed
"
crate
:
:
runtime
:
:
coop
:
:
poll_proceed
(
cx
)
)
)
;
#
[
cfg
(
any
(
not
(
tokio_unstable
)
not
(
feature
=
"
tracing
"
)
)
)
]
let
coop
=
ready
!
(
crate
:
:
runtime
:
:
coop
:
:
poll_proceed
(
cx
)
)
;
let
result
=
me
.
entry
.
poll_elapsed
(
cx
)
.
map
(
move
|
r
|
{
coop
.
made_progress
(
)
;
r
}
)
;
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
return
trace_poll_op
!
(
"
poll_elapsed
"
result
)
;
#
[
cfg
(
any
(
not
(
tokio_unstable
)
not
(
feature
=
"
tracing
"
)
)
)
]
return
result
;
}
}
impl
Future
for
Sleep
{
type
Output
=
(
)
;
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
_res_span
=
self
.
inner
.
ctx
.
resource_span
.
clone
(
)
.
entered
(
)
;
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
_ao_span
=
self
.
inner
.
ctx
.
async_op_span
.
clone
(
)
.
entered
(
)
;
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
_ao_poll_span
=
self
.
inner
.
ctx
.
async_op_poll_span
.
clone
(
)
.
entered
(
)
;
match
ready
!
(
self
.
as_mut
(
)
.
poll_elapsed
(
cx
)
)
{
Ok
(
(
)
)
=
>
Poll
:
:
Ready
(
(
)
)
Err
(
e
)
=
>
panic
!
(
"
timer
error
:
{
}
"
e
)
}
}
}
