#
!
[
cfg
(
unix
)
]
#
!
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
unix
feature
=
"
signal
"
)
)
)
)
]
use
crate
:
:
runtime
:
:
scheduler
;
use
crate
:
:
runtime
:
:
signal
:
:
Handle
;
use
crate
:
:
signal
:
:
registry
:
:
{
globals
EventId
EventInfo
Globals
Init
Storage
}
;
use
crate
:
:
signal
:
:
RxFuture
;
use
crate
:
:
sync
:
:
watch
;
use
mio
:
:
net
:
:
UnixStream
;
use
std
:
:
io
:
:
{
self
Error
ErrorKind
Write
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
std
:
:
sync
:
:
Once
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
pub
(
crate
)
type
OsStorage
=
Vec
<
SignalInfo
>
;
impl
Init
for
OsStorage
{
fn
init
(
)
-
>
Self
{
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
let
possible
=
0
.
.
=
33
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
let
possible
=
0
.
.
=
libc
:
:
SIGRTMAX
(
)
;
possible
.
map
(
|
_
|
SignalInfo
:
:
default
(
)
)
.
collect
(
)
}
}
impl
Storage
for
OsStorage
{
fn
event_info
(
&
self
id
:
EventId
)
-
>
Option
<
&
EventInfo
>
{
self
.
get
(
id
)
.
map
(
|
si
|
&
si
.
event_info
)
}
fn
for_each
<
'
a
F
>
(
&
'
a
self
f
:
F
)
where
F
:
FnMut
(
&
'
a
EventInfo
)
{
self
.
iter
(
)
.
map
(
|
si
|
&
si
.
event_info
)
.
for_each
(
f
)
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
OsExtraData
{
sender
:
UnixStream
pub
(
crate
)
receiver
:
UnixStream
}
impl
Init
for
OsExtraData
{
fn
init
(
)
-
>
Self
{
let
(
receiver
sender
)
=
UnixStream
:
:
pair
(
)
.
expect
(
"
failed
to
create
UnixStream
"
)
;
Self
{
sender
receiver
}
}
}
#
[
derive
(
Debug
Clone
Copy
Hash
PartialEq
Eq
)
]
pub
struct
SignalKind
(
libc
:
:
c_int
)
;
impl
SignalKind
{
pub
const
fn
from_raw
(
signum
:
std
:
:
os
:
:
raw
:
:
c_int
)
-
>
Self
{
Self
(
signum
as
libc
:
:
c_int
)
}
pub
const
fn
as_raw_value
(
&
self
)
-
>
std
:
:
os
:
:
raw
:
:
c_int
{
self
.
0
}
pub
const
fn
alarm
(
)
-
>
Self
{
Self
(
libc
:
:
SIGALRM
)
}
pub
const
fn
child
(
)
-
>
Self
{
Self
(
libc
:
:
SIGCHLD
)
}
pub
const
fn
hangup
(
)
-
>
Self
{
Self
(
libc
:
:
SIGHUP
)
}
#
[
cfg
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
macos
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
]
pub
const
fn
info
(
)
-
>
Self
{
Self
(
libc
:
:
SIGINFO
)
}
pub
const
fn
interrupt
(
)
-
>
Self
{
Self
(
libc
:
:
SIGINT
)
}
pub
const
fn
io
(
)
-
>
Self
{
Self
(
libc
:
:
SIGIO
)
}
pub
const
fn
pipe
(
)
-
>
Self
{
Self
(
libc
:
:
SIGPIPE
)
}
pub
const
fn
quit
(
)
-
>
Self
{
Self
(
libc
:
:
SIGQUIT
)
}
pub
const
fn
terminate
(
)
-
>
Self
{
Self
(
libc
:
:
SIGTERM
)
}
pub
const
fn
user_defined1
(
)
-
>
Self
{
Self
(
libc
:
:
SIGUSR1
)
}
pub
const
fn
user_defined2
(
)
-
>
Self
{
Self
(
libc
:
:
SIGUSR2
)
}
pub
const
fn
window_change
(
)
-
>
Self
{
Self
(
libc
:
:
SIGWINCH
)
}
}
impl
From
<
std
:
:
os
:
:
raw
:
:
c_int
>
for
SignalKind
{
fn
from
(
signum
:
std
:
:
os
:
:
raw
:
:
c_int
)
-
>
Self
{
Self
:
:
from_raw
(
signum
as
libc
:
:
c_int
)
}
}
impl
From
<
SignalKind
>
for
std
:
:
os
:
:
raw
:
:
c_int
{
fn
from
(
kind
:
SignalKind
)
-
>
Self
{
kind
.
as_raw_value
(
)
}
}
pub
(
crate
)
struct
SignalInfo
{
event_info
:
EventInfo
init
:
Once
initialized
:
AtomicBool
}
impl
Default
for
SignalInfo
{
fn
default
(
)
-
>
SignalInfo
{
SignalInfo
{
event_info
:
Default
:
:
default
(
)
init
:
Once
:
:
new
(
)
initialized
:
AtomicBool
:
:
new
(
false
)
}
}
}
fn
action
(
globals
:
&
'
static
Globals
signal
:
libc
:
:
c_int
)
{
globals
.
record_event
(
signal
as
EventId
)
;
let
mut
sender
=
&
globals
.
sender
;
drop
(
sender
.
write
(
&
[
1
]
)
)
;
}
fn
signal_enable
(
signal
:
SignalKind
handle
:
&
Handle
)
-
>
io
:
:
Result
<
(
)
>
{
let
signal
=
signal
.
0
;
if
signal
<
0
|
|
signal_hook_registry
:
:
FORBIDDEN
.
contains
(
&
signal
)
{
return
Err
(
Error
:
:
new
(
ErrorKind
:
:
Other
format
!
(
"
Refusing
to
register
signal
{
}
"
signal
)
)
)
;
}
handle
.
check_inner
(
)
?
;
let
globals
=
globals
(
)
;
let
siginfo
=
match
globals
.
storage
(
)
.
get
(
signal
as
EventId
)
{
Some
(
slot
)
=
>
slot
None
=
>
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
signal
too
large
"
)
)
}
;
let
mut
registered
=
Ok
(
(
)
)
;
siginfo
.
init
.
call_once
(
|
|
{
registered
=
unsafe
{
signal_hook_registry
:
:
register
(
signal
move
|
|
action
(
globals
signal
)
)
.
map
(
|
_
|
(
)
)
}
;
if
registered
.
is_ok
(
)
{
siginfo
.
initialized
.
store
(
true
Ordering
:
:
Relaxed
)
;
}
}
)
;
registered
?
;
if
siginfo
.
initialized
.
load
(
Ordering
:
:
Relaxed
)
{
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
new
(
ErrorKind
:
:
Other
"
Failed
to
register
signal
handler
"
)
)
}
}
#
[
must_use
=
"
streams
do
nothing
unless
polled
"
]
#
[
derive
(
Debug
)
]
pub
struct
Signal
{
inner
:
RxFuture
}
#
[
track_caller
]
pub
fn
signal
(
kind
:
SignalKind
)
-
>
io
:
:
Result
<
Signal
>
{
let
handle
=
scheduler
:
:
Handle
:
:
current
(
)
;
let
rx
=
signal_with_handle
(
kind
handle
.
driver
(
)
.
signal
(
)
)
?
;
Ok
(
Signal
{
inner
:
RxFuture
:
:
new
(
rx
)
}
)
}
pub
(
crate
)
fn
signal_with_handle
(
kind
:
SignalKind
handle
:
&
Handle
)
-
>
io
:
:
Result
<
watch
:
:
Receiver
<
(
)
>
>
{
signal_enable
(
kind
handle
)
?
;
Ok
(
globals
(
)
.
register_listener
(
kind
.
0
as
EventId
)
)
}
impl
Signal
{
pub
async
fn
recv
(
&
mut
self
)
-
>
Option
<
(
)
>
{
self
.
inner
.
recv
(
)
.
await
}
pub
fn
poll_recv
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
(
)
>
>
{
self
.
inner
.
poll_recv
(
cx
)
}
}
pub
(
crate
)
trait
InternalStream
{
fn
poll_recv
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
(
)
>
>
;
}
impl
InternalStream
for
Signal
{
fn
poll_recv
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
(
)
>
>
{
self
.
poll_recv
(
cx
)
}
}
pub
(
crate
)
fn
ctrl_c
(
)
-
>
io
:
:
Result
<
Signal
>
{
signal
(
SignalKind
:
:
interrupt
(
)
)
}
#
[
cfg
(
all
(
test
not
(
loom
)
)
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
signal_enable_error_on_invalid_input
(
)
{
signal_enable
(
SignalKind
:
:
from_raw
(
-
1
)
&
Handle
:
:
default
(
)
)
.
unwrap_err
(
)
;
}
#
[
test
]
fn
signal_enable_error_on_forbidden_input
(
)
{
signal_enable
(
SignalKind
:
:
from_raw
(
signal_hook_registry
:
:
FORBIDDEN
[
0
]
)
&
Handle
:
:
default
(
)
)
.
unwrap_err
(
)
;
}
#
[
test
]
fn
from_c_int
(
)
{
assert_eq
!
(
SignalKind
:
:
from
(
2
)
SignalKind
:
:
interrupt
(
)
)
;
}
#
[
test
]
fn
into_c_int
(
)
{
let
value
:
std
:
:
os
:
:
raw
:
:
c_int
=
SignalKind
:
:
interrupt
(
)
.
into
(
)
;
assert_eq
!
(
value
libc
:
:
SIGINT
as
_
)
;
}
}
