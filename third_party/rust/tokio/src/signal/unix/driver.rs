#
!
[
cfg_attr
(
not
(
feature
=
"
rt
"
)
allow
(
dead_code
)
)
]
use
crate
:
:
io
:
:
driver
:
:
{
Driver
as
IoDriver
Interest
}
;
use
crate
:
:
io
:
:
PollEvented
;
use
crate
:
:
park
:
:
Park
;
use
crate
:
:
signal
:
:
registry
:
:
globals
;
use
mio
:
:
net
:
:
UnixStream
;
use
std
:
:
io
:
:
{
self
Read
}
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
{
Arc
Weak
}
;
use
std
:
:
task
:
:
{
Context
Poll
RawWaker
RawWakerVTable
Waker
}
;
use
std
:
:
time
:
:
Duration
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Driver
{
park
:
IoDriver
receiver
:
PollEvented
<
UnixStream
>
inner
:
Arc
<
Inner
>
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
(
crate
)
struct
Handle
{
inner
:
Weak
<
Inner
>
}
#
[
derive
(
Debug
)
]
pub
(
super
)
struct
Inner
(
(
)
)
;
impl
Driver
{
pub
(
crate
)
fn
new
(
park
:
IoDriver
)
-
>
io
:
:
Result
<
Self
>
{
use
std
:
:
mem
:
:
ManuallyDrop
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsRawFd
FromRawFd
}
;
let
receiver_fd
=
globals
(
)
.
receiver
.
as_raw_fd
(
)
;
let
original
=
ManuallyDrop
:
:
new
(
unsafe
{
std
:
:
os
:
:
unix
:
:
net
:
:
UnixStream
:
:
from_raw_fd
(
receiver_fd
)
}
)
;
let
receiver
=
UnixStream
:
:
from_std
(
original
.
try_clone
(
)
?
)
;
let
receiver
=
PollEvented
:
:
new_with_interest_and_handle
(
receiver
Interest
:
:
READABLE
|
Interest
:
:
WRITABLE
park
.
handle
(
)
)
?
;
Ok
(
Self
{
park
receiver
inner
:
Arc
:
:
new
(
Inner
(
(
)
)
)
}
)
}
pub
(
crate
)
fn
handle
(
&
self
)
-
>
Handle
{
Handle
{
inner
:
Arc
:
:
downgrade
(
&
self
.
inner
)
}
}
fn
process
(
&
self
)
{
let
waker
=
unsafe
{
Waker
:
:
from_raw
(
RawWaker
:
:
new
(
ptr
:
:
null
(
)
&
NOOP_WAKER_VTABLE
)
)
}
;
let
mut
cx
=
Context
:
:
from_waker
(
&
waker
)
;
let
ev
=
match
self
.
receiver
.
registration
(
)
.
poll_read_ready
(
&
mut
cx
)
{
Poll
:
:
Ready
(
Ok
(
ev
)
)
=
>
ev
Poll
:
:
Ready
(
Err
(
e
)
)
=
>
panic
!
(
"
reactor
gone
:
{
}
"
e
)
Poll
:
:
Pending
=
>
return
}
;
let
mut
buf
=
[
0
;
128
]
;
loop
{
match
(
&
*
self
.
receiver
)
.
read
(
&
mut
buf
)
{
Ok
(
0
)
=
>
panic
!
(
"
EOF
on
self
-
pipe
"
)
Ok
(
_
)
=
>
continue
Err
(
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
break
Err
(
e
)
=
>
panic
!
(
"
Bad
read
on
self
-
pipe
:
{
}
"
e
)
}
}
self
.
receiver
.
registration
(
)
.
clear_readiness
(
ev
)
;
globals
(
)
.
broadcast
(
)
;
}
}
const
NOOP_WAKER_VTABLE
:
RawWakerVTable
=
RawWakerVTable
:
:
new
(
noop_clone
noop
noop
noop
)
;
unsafe
fn
noop_clone
(
_data
:
*
const
(
)
)
-
>
RawWaker
{
RawWaker
:
:
new
(
ptr
:
:
null
(
)
&
NOOP_WAKER_VTABLE
)
}
unsafe
fn
noop
(
_data
:
*
const
(
)
)
{
}
impl
Park
for
Driver
{
type
Unpark
=
<
IoDriver
as
Park
>
:
:
Unpark
;
type
Error
=
io
:
:
Error
;
fn
unpark
(
&
self
)
-
>
Self
:
:
Unpark
{
self
.
park
.
unpark
(
)
}
fn
park
(
&
mut
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
park
.
park
(
)
?
;
self
.
process
(
)
;
Ok
(
(
)
)
}
fn
park_timeout
(
&
mut
self
duration
:
Duration
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
park
.
park_timeout
(
duration
)
?
;
self
.
process
(
)
;
Ok
(
(
)
)
}
fn
shutdown
(
&
mut
self
)
{
self
.
park
.
shutdown
(
)
}
}
impl
Handle
{
pub
(
super
)
fn
check_inner
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
if
self
.
inner
.
strong_count
(
)
>
0
{
Ok
(
(
)
)
}
else
{
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
signal
driver
gone
"
)
)
}
}
}
cfg_rt
!
{
impl
Handle
{
/
/
/
Returns
a
handle
to
the
current
driver
/
/
/
/
/
/
#
Panics
/
/
/
/
/
/
This
function
panics
if
there
is
no
current
signal
driver
set
.
pub
(
super
)
fn
current
(
)
-
>
Self
{
crate
:
:
runtime
:
:
context
:
:
signal_handle
(
)
.
expect
(
"
there
is
no
signal
driver
running
must
be
called
from
the
context
of
Tokio
runtime
"
)
}
}
}
cfg_not_rt
!
{
impl
Handle
{
/
/
/
Returns
a
handle
to
the
current
driver
/
/
/
/
/
/
#
Panics
/
/
/
/
/
/
This
function
panics
if
there
is
no
current
signal
driver
set
.
pub
(
super
)
fn
current
(
)
-
>
Self
{
panic
!
(
"
there
is
no
signal
driver
running
must
be
called
from
the
context
of
Tokio
runtime
or
with
\
rt
enabled
.
"
)
}
}
}
