#
!
[
allow
(
deprecated
)
]
pub
use
tokio_current_thread
:
:
{
BlockError
CurrentThread
Entered
Handle
RunError
RunTimeoutError
TaskExecutor
Turn
TurnError
block_on_all
spawn
}
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
marker
:
:
PhantomData
;
use
futures
:
:
future
:
:
{
self
}
;
#
[
deprecated
(
since
=
"
0
.
1
.
2
"
note
=
"
use
block_on_all
instead
"
)
]
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
pub
struct
Context
<
'
a
>
{
cancel
:
Cell
<
bool
>
_p
:
PhantomData
<
&
'
a
(
)
>
}
impl
<
'
a
>
Context
<
'
a
>
{
pub
fn
cancel_all_spawned
(
&
self
)
{
self
.
cancel
.
set
(
true
)
;
}
}
#
[
deprecated
(
since
=
"
0
.
1
.
2
"
note
=
"
use
block_on_all
instead
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
run
<
F
R
>
(
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Context
)
-
>
R
{
let
mut
context
=
Context
{
cancel
:
Cell
:
:
new
(
false
)
_p
:
PhantomData
}
;
let
mut
current_thread
=
CurrentThread
:
:
new
(
)
;
let
ret
=
current_thread
.
block_on
(
future
:
:
lazy
(
|
|
Ok
:
:
<
_
(
)
>
(
f
(
&
mut
context
)
)
)
)
.
unwrap
(
)
;
if
context
.
cancel
.
get
(
)
{
return
ret
;
}
current_thread
.
run
(
)
.
unwrap
(
)
;
ret
}
#
[
deprecated
(
since
=
"
0
.
1
.
2
"
note
=
"
use
TaskExecutor
:
:
current
instead
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
task_executor
(
)
-
>
TaskExecutor
{
TaskExecutor
:
:
current
(
)
}
