#
!
[
allow
(
deprecated
)
]
mod
scheduler
;
use
self
:
:
scheduler
:
:
Scheduler
;
use
tokio_executor
:
:
{
self
Enter
SpawnError
}
;
use
tokio_executor
:
:
park
:
:
{
Park
Unpark
ParkThread
}
;
use
futures
:
:
{
executor
Async
Future
}
;
use
futures
:
:
future
:
:
{
self
Executor
ExecuteError
ExecuteErrorKind
}
;
use
std
:
:
fmt
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
std
:
:
sync
:
:
mpsc
;
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
use
futures2
;
pub
struct
CurrentThread
<
P
:
Park
=
ParkThread
>
{
scheduler
:
Scheduler
<
P
:
:
Unpark
>
num_futures
:
usize
park
:
P
spawn_handle
:
Handle
spawn_receiver
:
mpsc
:
:
Receiver
<
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
>
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
TaskExecutor
{
_p
:
:
:
std
:
:
marker
:
:
PhantomData
<
Rc
<
(
)
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
Turn
{
polled
:
bool
}
impl
Turn
{
pub
fn
has_polled
(
&
self
)
-
>
bool
{
self
.
polled
}
}
pub
struct
Entered
<
'
a
P
:
Park
+
'
a
>
{
executor
:
&
'
a
mut
CurrentThread
<
P
>
enter
:
&
'
a
mut
Enter
}
#
[
deprecated
(
since
=
"
0
.
1
.
2
"
note
=
"
use
block_on_all
instead
"
)
]
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
pub
struct
Context
<
'
a
>
{
cancel
:
Cell
<
bool
>
_p
:
PhantomData
<
&
'
a
(
)
>
}
#
[
derive
(
Debug
)
]
pub
struct
RunError
{
_p
:
(
)
}
#
[
derive
(
Debug
)
]
pub
struct
RunTimeoutError
{
timeout
:
bool
}
#
[
derive
(
Debug
)
]
pub
struct
TurnError
{
_p
:
(
)
}
#
[
derive
(
Debug
)
]
pub
struct
BlockError
<
T
>
{
inner
:
Option
<
T
>
}
struct
Borrow
<
'
a
U
:
'
a
>
{
scheduler
:
&
'
a
mut
Scheduler
<
U
>
num_futures
:
&
'
a
mut
usize
}
trait
SpawnLocal
{
fn
spawn_local
(
&
mut
self
future
:
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
>
)
;
}
struct
CurrentRunner
{
spawn
:
Cell
<
Option
<
*
mut
SpawnLocal
>
>
}
thread_local
!
(
static
CURRENT
:
CurrentRunner
=
CurrentRunner
{
spawn
:
Cell
:
:
new
(
None
)
}
)
;
#
[
deprecated
(
since
=
"
0
.
1
.
2
"
note
=
"
use
block_on_all
instead
"
)
]
#
[
doc
(
hidden
)
]
#
[
allow
(
deprecated
)
]
pub
fn
run
<
F
R
>
(
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Context
)
-
>
R
{
let
mut
context
=
Context
{
cancel
:
Cell
:
:
new
(
false
)
_p
:
PhantomData
}
;
let
mut
current_thread
=
CurrentThread
:
:
new
(
)
;
let
ret
=
current_thread
.
block_on
(
future
:
:
lazy
(
|
|
Ok
:
:
<
_
(
)
>
(
f
(
&
mut
context
)
)
)
)
.
unwrap
(
)
;
if
context
.
cancel
.
get
(
)
{
return
ret
;
}
current_thread
.
run
(
)
.
unwrap
(
)
;
ret
}
pub
fn
block_on_all
<
F
>
(
future
:
F
)
-
>
Result
<
F
:
:
Item
F
:
:
Error
>
where
F
:
Future
{
let
mut
current_thread
=
CurrentThread
:
:
new
(
)
;
let
ret
=
current_thread
.
block_on
(
future
)
;
current_thread
.
run
(
)
.
unwrap
(
)
;
ret
.
map_err
(
|
e
|
e
.
into_inner
(
)
.
expect
(
"
unexpected
execution
error
"
)
)
}
pub
fn
spawn
<
F
>
(
future
:
F
)
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
TaskExecutor
:
:
current
(
)
.
spawn_local
(
Box
:
:
new
(
future
)
)
.
unwrap
(
)
;
}
impl
CurrentThread
<
ParkThread
>
{
pub
fn
new
(
)
-
>
Self
{
CurrentThread
:
:
new_with_park
(
ParkThread
:
:
new
(
)
)
}
}
impl
<
P
:
Park
>
CurrentThread
<
P
>
{
pub
fn
new_with_park
(
park
:
P
)
-
>
Self
{
let
unpark
=
park
.
unpark
(
)
;
let
(
spawn_sender
spawn_receiver
)
=
mpsc
:
:
channel
(
)
;
let
scheduler
=
Scheduler
:
:
new
(
unpark
)
;
let
notify
=
scheduler
.
notify
(
)
;
CurrentThread
{
scheduler
:
scheduler
num_futures
:
0
park
spawn_handle
:
Handle
{
sender
:
spawn_sender
notify
:
notify
}
spawn_receiver
:
spawn_receiver
}
}
pub
fn
is_idle
(
&
self
)
-
>
bool
{
self
.
num_futures
=
=
0
}
pub
fn
spawn
<
F
>
(
&
mut
self
future
:
F
)
-
>
&
mut
Self
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
self
.
borrow
(
)
.
spawn_local
(
Box
:
:
new
(
future
)
)
;
self
}
pub
fn
block_on
<
F
>
(
&
mut
self
future
:
F
)
-
>
Result
<
F
:
:
Item
BlockError
<
F
:
:
Error
>
>
where
F
:
Future
{
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
unwrap
(
)
;
self
.
enter
(
&
mut
enter
)
.
block_on
(
future
)
}
pub
fn
run
(
&
mut
self
)
-
>
Result
<
(
)
RunError
>
{
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
unwrap
(
)
;
self
.
enter
(
&
mut
enter
)
.
run
(
)
}
pub
fn
run_timeout
(
&
mut
self
duration
:
Duration
)
-
>
Result
<
(
)
RunTimeoutError
>
{
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
unwrap
(
)
;
self
.
enter
(
&
mut
enter
)
.
run_timeout
(
duration
)
}
pub
fn
turn
(
&
mut
self
duration
:
Option
<
Duration
>
)
-
>
Result
<
Turn
TurnError
>
{
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
unwrap
(
)
;
self
.
enter
(
&
mut
enter
)
.
turn
(
duration
)
}
pub
fn
enter
<
'
a
>
(
&
'
a
mut
self
enter
:
&
'
a
mut
Enter
)
-
>
Entered
<
'
a
P
>
{
Entered
{
executor
:
self
enter
}
}
pub
fn
get_park
(
&
self
)
-
>
&
P
{
&
self
.
park
}
pub
fn
get_park_mut
(
&
mut
self
)
-
>
&
mut
P
{
&
mut
self
.
park
}
fn
borrow
(
&
mut
self
)
-
>
Borrow
<
P
:
:
Unpark
>
{
Borrow
{
scheduler
:
&
mut
self
.
scheduler
num_futures
:
&
mut
self
.
num_futures
}
}
pub
fn
handle
(
&
self
)
-
>
Handle
{
self
.
spawn_handle
.
clone
(
)
}
}
impl
tokio_executor
:
:
Executor
for
CurrentThread
{
fn
spawn
(
&
mut
self
future
:
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
>
)
-
>
Result
<
(
)
SpawnError
>
{
self
.
borrow
(
)
.
spawn_local
(
future
)
;
Ok
(
(
)
)
}
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
fn
spawn2
(
&
mut
self
_future
:
Box
<
futures2
:
:
Future
<
Item
=
(
)
Error
=
futures2
:
:
Never
>
+
Send
>
)
-
>
Result
<
(
)
futures2
:
:
executor
:
:
SpawnError
>
{
panic
!
(
"
Futures
0
.
2
integration
is
not
available
for
current_thread
"
)
;
}
}
impl
<
P
:
Park
>
fmt
:
:
Debug
for
CurrentThread
<
P
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
CurrentThread
"
)
.
field
(
"
scheduler
"
&
self
.
scheduler
)
.
field
(
"
num_futures
"
&
self
.
num_futures
)
.
finish
(
)
}
}
impl
<
'
a
P
:
Park
>
Entered
<
'
a
P
>
{
pub
fn
spawn
<
F
>
(
&
mut
self
future
:
F
)
-
>
&
mut
Self
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
self
.
executor
.
borrow
(
)
.
spawn_local
(
Box
:
:
new
(
future
)
)
;
self
}
pub
fn
block_on
<
F
>
(
&
mut
self
future
:
F
)
-
>
Result
<
F
:
:
Item
BlockError
<
F
:
:
Error
>
>
where
F
:
Future
{
let
mut
future
=
executor
:
:
spawn
(
future
)
;
let
notify
=
self
.
executor
.
scheduler
.
notify
(
)
;
loop
{
let
res
=
self
.
executor
.
borrow
(
)
.
enter
(
self
.
enter
|
|
{
future
.
poll_future_notify
(
&
notify
0
)
}
)
;
match
res
{
Ok
(
Async
:
:
Ready
(
e
)
)
=
>
return
Ok
(
e
)
Err
(
e
)
=
>
return
Err
(
BlockError
{
inner
:
Some
(
e
)
}
)
Ok
(
Async
:
:
NotReady
)
=
>
{
}
}
self
.
tick
(
)
;
if
let
Err
(
_
)
=
self
.
executor
.
park
.
park
(
)
{
return
Err
(
BlockError
{
inner
:
None
}
)
;
}
}
}
pub
fn
run
(
&
mut
self
)
-
>
Result
<
(
)
RunError
>
{
self
.
run_timeout2
(
None
)
.
map_err
(
|
_
|
RunError
{
_p
:
(
)
}
)
}
pub
fn
run_timeout
(
&
mut
self
duration
:
Duration
)
-
>
Result
<
(
)
RunTimeoutError
>
{
self
.
run_timeout2
(
Some
(
duration
)
)
}
pub
fn
turn
(
&
mut
self
duration
:
Option
<
Duration
>
)
-
>
Result
<
Turn
TurnError
>
{
let
res
=
if
self
.
executor
.
scheduler
.
has_pending_futures
(
)
{
self
.
executor
.
park
.
park_timeout
(
Duration
:
:
from_millis
(
0
)
)
}
else
{
match
duration
{
Some
(
duration
)
=
>
self
.
executor
.
park
.
park_timeout
(
duration
)
None
=
>
self
.
executor
.
park
.
park
(
)
}
}
;
if
res
.
is_err
(
)
{
return
Err
(
TurnError
{
_p
:
(
)
}
)
;
}
let
polled
=
self
.
tick
(
)
;
Ok
(
Turn
{
polled
}
)
}
pub
fn
get_park
(
&
self
)
-
>
&
P
{
&
self
.
executor
.
park
}
pub
fn
get_park_mut
(
&
mut
self
)
-
>
&
mut
P
{
&
mut
self
.
executor
.
park
}
fn
run_timeout2
(
&
mut
self
dur
:
Option
<
Duration
>
)
-
>
Result
<
(
)
RunTimeoutError
>
{
if
self
.
executor
.
is_idle
(
)
{
return
Ok
(
(
)
)
;
}
let
mut
time
=
dur
.
map
(
|
dur
|
(
Instant
:
:
now
(
)
+
dur
dur
)
)
;
loop
{
self
.
tick
(
)
;
if
self
.
executor
.
is_idle
(
)
{
return
Ok
(
(
)
)
;
}
match
time
{
Some
(
(
until
rem
)
)
=
>
{
if
let
Err
(
_
)
=
self
.
executor
.
park
.
park_timeout
(
rem
)
{
return
Err
(
RunTimeoutError
:
:
new
(
false
)
)
;
}
let
now
=
Instant
:
:
now
(
)
;
if
now
>
=
until
{
return
Err
(
RunTimeoutError
:
:
new
(
true
)
)
;
}
time
=
Some
(
(
until
until
-
now
)
)
;
}
None
=
>
{
if
let
Err
(
_
)
=
self
.
executor
.
park
.
park
(
)
{
return
Err
(
RunTimeoutError
:
:
new
(
false
)
)
;
}
}
}
}
}
fn
tick
(
&
mut
self
)
-
>
bool
{
let
(
mut
borrow
spawn_receiver
)
=
(
Borrow
{
scheduler
:
&
mut
self
.
executor
.
scheduler
num_futures
:
&
mut
self
.
executor
.
num_futures
}
&
mut
self
.
executor
.
spawn_receiver
)
;
while
let
Ok
(
future
)
=
spawn_receiver
.
try_recv
(
)
{
borrow
.
spawn_local
(
future
)
;
}
borrow
.
scheduler
.
tick
(
&
mut
*
self
.
enter
borrow
.
num_futures
)
}
}
impl
<
'
a
P
:
Park
>
fmt
:
:
Debug
for
Entered
<
'
a
P
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Entered
"
)
.
field
(
"
executor
"
&
self
.
executor
)
.
field
(
"
enter
"
&
self
.
enter
)
.
finish
(
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
Handle
{
sender
:
mpsc
:
:
Sender
<
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
>
>
notify
:
executor
:
:
NotifyHandle
}
impl
fmt
:
:
Debug
for
Handle
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Handle
"
)
.
finish
(
)
}
}
impl
Handle
{
pub
fn
spawn
<
F
>
(
&
self
future
:
F
)
-
>
Result
<
(
)
SpawnError
>
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
self
.
sender
.
send
(
Box
:
:
new
(
future
)
)
.
expect
(
"
CurrentThread
does
not
exist
anymore
"
)
;
self
.
notify
.
notify
(
0
)
;
Ok
(
(
)
)
}
}
#
[
deprecated
(
since
=
"
0
.
1
.
2
"
note
=
"
use
TaskExecutor
:
:
current
instead
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
task_executor
(
)
-
>
TaskExecutor
{
TaskExecutor
{
_p
:
:
:
std
:
:
marker
:
:
PhantomData
}
}
impl
TaskExecutor
{
pub
fn
current
(
)
-
>
TaskExecutor
{
TaskExecutor
{
_p
:
:
:
std
:
:
marker
:
:
PhantomData
}
}
pub
fn
spawn_local
(
&
mut
self
future
:
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
>
)
-
>
Result
<
(
)
SpawnError
>
{
CURRENT
.
with
(
|
current
|
{
match
current
.
spawn
.
get
(
)
{
Some
(
spawn
)
=
>
{
unsafe
{
(
*
spawn
)
.
spawn_local
(
future
)
}
;
Ok
(
(
)
)
}
None
=
>
{
Err
(
SpawnError
:
:
shutdown
(
)
)
}
}
}
)
}
}
impl
tokio_executor
:
:
Executor
for
TaskExecutor
{
fn
spawn
(
&
mut
self
future
:
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
>
)
-
>
Result
<
(
)
SpawnError
>
{
self
.
spawn_local
(
future
)
}
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
fn
spawn2
(
&
mut
self
_future
:
Box
<
futures2
:
:
Future
<
Item
=
(
)
Error
=
futures2
:
:
Never
>
+
Send
>
)
-
>
Result
<
(
)
futures2
:
:
executor
:
:
SpawnError
>
{
panic
!
(
"
Futures
0
.
2
integration
is
not
available
for
current_thread
"
)
;
}
fn
status
(
&
self
)
-
>
Result
<
(
)
SpawnError
>
{
CURRENT
.
with
(
|
current
|
{
if
current
.
spawn
.
get
(
)
.
is_some
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
SpawnError
:
:
shutdown
(
)
)
}
}
)
}
}
impl
<
F
>
Executor
<
F
>
for
TaskExecutor
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
fn
execute
(
&
self
future
:
F
)
-
>
Result
<
(
)
ExecuteError
<
F
>
>
{
CURRENT
.
with
(
|
current
|
{
match
current
.
spawn
.
get
(
)
{
Some
(
spawn
)
=
>
{
unsafe
{
(
*
spawn
)
.
spawn_local
(
Box
:
:
new
(
future
)
)
}
;
Ok
(
(
)
)
}
None
=
>
{
Err
(
ExecuteError
:
:
new
(
ExecuteErrorKind
:
:
Shutdown
future
)
)
}
}
}
)
}
}
impl
<
'
a
>
Context
<
'
a
>
{
pub
fn
cancel_all_spawned
(
&
self
)
{
self
.
cancel
.
set
(
true
)
;
}
}
impl
<
'
a
U
:
Unpark
>
Borrow
<
'
a
U
>
{
fn
enter
<
F
R
>
(
&
mut
self
_
:
&
mut
Enter
f
:
F
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
{
CURRENT
.
with
(
|
current
|
{
current
.
set_spawn
(
self
|
|
{
f
(
)
}
)
}
)
}
}
impl
<
'
a
U
:
Unpark
>
SpawnLocal
for
Borrow
<
'
a
U
>
{
fn
spawn_local
(
&
mut
self
future
:
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
>
)
{
*
self
.
num_futures
+
=
1
;
self
.
scheduler
.
schedule
(
future
)
;
}
}
impl
CurrentRunner
{
fn
set_spawn
<
F
R
>
(
&
self
spawn
:
&
mut
SpawnLocal
f
:
F
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
{
struct
Reset
<
'
a
>
(
&
'
a
CurrentRunner
)
;
impl
<
'
a
>
Drop
for
Reset
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
self
.
0
.
spawn
.
set
(
None
)
;
}
}
let
_reset
=
Reset
(
self
)
;
let
spawn
=
unsafe
{
hide_lt
(
spawn
as
*
mut
SpawnLocal
)
}
;
self
.
spawn
.
set
(
Some
(
spawn
)
)
;
f
(
)
}
}
unsafe
fn
hide_lt
<
'
a
>
(
p
:
*
mut
(
SpawnLocal
+
'
a
)
)
-
>
*
mut
(
SpawnLocal
+
'
static
)
{
use
std
:
:
mem
;
mem
:
:
transmute
(
p
)
}
impl
RunTimeoutError
{
fn
new
(
timeout
:
bool
)
-
>
Self
{
RunTimeoutError
{
timeout
}
}
pub
fn
is_timeout
(
&
self
)
-
>
bool
{
self
.
timeout
}
}
impl
From
<
tokio_executor
:
:
EnterError
>
for
RunTimeoutError
{
fn
from
(
_
:
tokio_executor
:
:
EnterError
)
-
>
Self
{
RunTimeoutError
:
:
new
(
false
)
}
}
impl
<
T
>
BlockError
<
T
>
{
pub
fn
into_inner
(
self
)
-
>
Option
<
T
>
{
self
.
inner
}
}
impl
<
T
>
From
<
tokio_executor
:
:
EnterError
>
for
BlockError
<
T
>
{
fn
from
(
_
:
tokio_executor
:
:
EnterError
)
-
>
Self
{
BlockError
{
inner
:
None
}
}
}
