use
crate
:
:
future
:
:
Future
;
use
crate
:
:
loom
:
:
cell
:
:
UnsafeCell
;
use
crate
:
:
loom
:
:
sync
:
:
Mutex
;
use
crate
:
:
runtime
:
:
task
:
:
{
JoinHandle
LocalNotified
Notified
Schedule
Task
}
;
use
crate
:
:
util
:
:
linked_list
:
:
{
CountedLinkedList
Link
LinkedList
}
;
use
std
:
:
marker
:
:
PhantomData
;
cfg_has_atomic_u64
!
{
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicU64
Ordering
}
;
static
NEXT_OWNED_TASKS_ID
:
AtomicU64
=
AtomicU64
:
:
new
(
1
)
;
fn
get_next_id
(
)
-
>
u64
{
loop
{
let
id
=
NEXT_OWNED_TASKS_ID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
if
id
!
=
0
{
return
id
;
}
}
}
}
cfg_not_has_atomic_u64
!
{
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicU32
Ordering
}
;
static
NEXT_OWNED_TASKS_ID
:
AtomicU32
=
AtomicU32
:
:
new
(
1
)
;
fn
get_next_id
(
)
-
>
u64
{
loop
{
let
id
=
NEXT_OWNED_TASKS_ID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
if
id
!
=
0
{
return
u64
:
:
from
(
id
)
;
}
}
}
}
pub
(
crate
)
struct
OwnedTasks
<
S
:
'
static
>
{
inner
:
Mutex
<
CountedOwnedTasksInner
<
S
>
>
id
:
u64
}
struct
CountedOwnedTasksInner
<
S
:
'
static
>
{
list
:
CountedLinkedList
<
Task
<
S
>
<
Task
<
S
>
as
Link
>
:
:
Target
>
closed
:
bool
}
pub
(
crate
)
struct
LocalOwnedTasks
<
S
:
'
static
>
{
inner
:
UnsafeCell
<
OwnedTasksInner
<
S
>
>
id
:
u64
_not_send_or_sync
:
PhantomData
<
*
const
(
)
>
}
struct
OwnedTasksInner
<
S
:
'
static
>
{
list
:
LinkedList
<
Task
<
S
>
<
Task
<
S
>
as
Link
>
:
:
Target
>
closed
:
bool
}
impl
<
S
:
'
static
>
OwnedTasks
<
S
>
{
pub
(
crate
)
fn
new
(
)
-
>
Self
{
Self
{
inner
:
Mutex
:
:
new
(
CountedOwnedTasksInner
{
list
:
CountedLinkedList
:
:
new
(
)
closed
:
false
}
)
id
:
get_next_id
(
)
}
}
pub
(
crate
)
fn
bind
<
T
>
(
&
self
task
:
T
scheduler
:
S
id
:
super
:
:
Id
)
-
>
(
JoinHandle
<
T
:
:
Output
>
Option
<
Notified
<
S
>
>
)
where
S
:
Schedule
T
:
Future
+
Send
+
'
static
T
:
:
Output
:
Send
+
'
static
{
let
(
task
notified
join
)
=
super
:
:
new_task
(
task
scheduler
id
)
;
unsafe
{
task
.
header
(
)
.
set_owner_id
(
self
.
id
)
;
}
let
mut
lock
=
self
.
inner
.
lock
(
)
;
if
lock
.
closed
{
drop
(
lock
)
;
drop
(
notified
)
;
task
.
shutdown
(
)
;
(
join
None
)
}
else
{
lock
.
list
.
push_front
(
task
)
;
(
join
Some
(
notified
)
)
}
}
#
[
inline
]
pub
(
crate
)
fn
assert_owner
(
&
self
task
:
Notified
<
S
>
)
-
>
LocalNotified
<
S
>
{
assert_eq
!
(
task
.
header
(
)
.
get_owner_id
(
)
self
.
id
)
;
LocalNotified
{
task
:
task
.
0
_not_send
:
PhantomData
}
}
pub
(
crate
)
fn
close_and_shutdown_all
(
&
self
)
where
S
:
Schedule
{
let
first_task
=
{
let
mut
lock
=
self
.
inner
.
lock
(
)
;
lock
.
closed
=
true
;
lock
.
list
.
pop_back
(
)
}
;
match
first_task
{
Some
(
task
)
=
>
task
.
shutdown
(
)
None
=
>
return
}
loop
{
let
task
=
match
self
.
inner
.
lock
(
)
.
list
.
pop_back
(
)
{
Some
(
task
)
=
>
task
None
=
>
return
}
;
task
.
shutdown
(
)
;
}
}
pub
(
crate
)
fn
active_tasks_count
(
&
self
)
-
>
usize
{
self
.
inner
.
lock
(
)
.
list
.
count
(
)
}
pub
(
crate
)
fn
remove
(
&
self
task
:
&
Task
<
S
>
)
-
>
Option
<
Task
<
S
>
>
{
let
task_id
=
task
.
header
(
)
.
get_owner_id
(
)
;
if
task_id
=
=
0
{
return
None
;
}
assert_eq
!
(
task_id
self
.
id
)
;
unsafe
{
self
.
inner
.
lock
(
)
.
list
.
remove
(
task
.
header_ptr
(
)
)
}
}
pub
(
crate
)
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
inner
.
lock
(
)
.
list
.
is_empty
(
)
}
}
cfg_taskdump
!
{
impl
<
S
:
'
static
>
OwnedTasks
<
S
>
{
/
/
/
Locks
the
tasks
and
calls
f
on
an
iterator
over
them
.
pub
(
crate
)
fn
for_each
<
F
>
(
&
self
f
:
F
)
where
F
:
FnMut
(
&
Task
<
S
>
)
{
self
.
inner
.
lock
(
)
.
list
.
for_each
(
f
)
}
}
}
impl
<
S
:
'
static
>
LocalOwnedTasks
<
S
>
{
pub
(
crate
)
fn
new
(
)
-
>
Self
{
Self
{
inner
:
UnsafeCell
:
:
new
(
OwnedTasksInner
{
list
:
LinkedList
:
:
new
(
)
closed
:
false
}
)
id
:
get_next_id
(
)
_not_send_or_sync
:
PhantomData
}
}
pub
(
crate
)
fn
bind
<
T
>
(
&
self
task
:
T
scheduler
:
S
id
:
super
:
:
Id
)
-
>
(
JoinHandle
<
T
:
:
Output
>
Option
<
Notified
<
S
>
>
)
where
S
:
Schedule
T
:
Future
+
'
static
T
:
:
Output
:
'
static
{
let
(
task
notified
join
)
=
super
:
:
new_task
(
task
scheduler
id
)
;
unsafe
{
task
.
header
(
)
.
set_owner_id
(
self
.
id
)
;
}
if
self
.
is_closed
(
)
{
drop
(
notified
)
;
task
.
shutdown
(
)
;
(
join
None
)
}
else
{
self
.
with_inner
(
|
inner
|
{
inner
.
list
.
push_front
(
task
)
;
}
)
;
(
join
Some
(
notified
)
)
}
}
pub
(
crate
)
fn
close_and_shutdown_all
(
&
self
)
where
S
:
Schedule
{
self
.
with_inner
(
|
inner
|
inner
.
closed
=
true
)
;
while
let
Some
(
task
)
=
self
.
with_inner
(
|
inner
|
inner
.
list
.
pop_back
(
)
)
{
task
.
shutdown
(
)
;
}
}
pub
(
crate
)
fn
remove
(
&
self
task
:
&
Task
<
S
>
)
-
>
Option
<
Task
<
S
>
>
{
let
task_id
=
task
.
header
(
)
.
get_owner_id
(
)
;
if
task_id
=
=
0
{
return
None
;
}
assert_eq
!
(
task_id
self
.
id
)
;
self
.
with_inner
(
|
inner
|
unsafe
{
inner
.
list
.
remove
(
task
.
header_ptr
(
)
)
}
)
}
#
[
inline
]
pub
(
crate
)
fn
assert_owner
(
&
self
task
:
Notified
<
S
>
)
-
>
LocalNotified
<
S
>
{
assert_eq
!
(
task
.
header
(
)
.
get_owner_id
(
)
self
.
id
)
;
LocalNotified
{
task
:
task
.
0
_not_send
:
PhantomData
}
}
#
[
inline
]
fn
with_inner
<
F
T
>
(
&
self
f
:
F
)
-
>
T
where
F
:
FnOnce
(
&
mut
OwnedTasksInner
<
S
>
)
-
>
T
{
self
.
inner
.
with_mut
(
|
ptr
|
unsafe
{
f
(
&
mut
*
ptr
)
}
)
}
pub
(
crate
)
fn
is_closed
(
&
self
)
-
>
bool
{
self
.
with_inner
(
|
inner
|
inner
.
closed
)
}
pub
(
crate
)
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
with_inner
(
|
inner
|
inner
.
list
.
is_empty
(
)
)
}
}
#
[
cfg
(
all
(
test
)
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
test_id_not_broken
(
)
{
let
mut
last_id
=
get_next_id
(
)
;
assert_ne
!
(
last_id
0
)
;
for
_
in
0
.
.
1000
{
let
next_id
=
get_next_id
(
)
;
assert_ne
!
(
next_id
0
)
;
assert
!
(
last_id
<
next_id
)
;
last_id
=
next_id
;
}
}
}
