use
crate
:
:
runtime
:
:
context
;
use
std
:
:
fmt
;
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
rt
"
tokio_unstable
)
)
)
)
]
#
[
cfg_attr
(
not
(
tokio_unstable
)
allow
(
unreachable_pub
)
)
]
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
PartialEq
)
]
pub
struct
Id
(
pub
(
crate
)
u64
)
;
#
[
cfg_attr
(
not
(
tokio_unstable
)
allow
(
unreachable_pub
)
)
]
#
[
track_caller
]
pub
fn
id
(
)
-
>
Id
{
context
:
:
current_task_id
(
)
.
expect
(
"
Can
'
t
get
a
task
id
when
not
inside
a
task
"
)
}
#
[
cfg_attr
(
not
(
tokio_unstable
)
allow
(
unreachable_pub
)
)
]
#
[
track_caller
]
pub
fn
try_id
(
)
-
>
Option
<
Id
>
{
context
:
:
current_task_id
(
)
}
impl
fmt
:
:
Display
for
Id
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
0
.
fmt
(
f
)
}
}
impl
Id
{
pub
(
crate
)
fn
next
(
)
-
>
Self
{
use
crate
:
:
loom
:
:
sync
:
:
atomic
:
:
Ordering
:
:
Relaxed
;
use
crate
:
:
loom
:
:
sync
:
:
atomic
:
:
StaticAtomicU64
;
#
[
cfg
(
all
(
test
loom
)
)
]
{
crate
:
:
loom
:
:
lazy_static
!
{
static
ref
NEXT_ID
:
StaticAtomicU64
=
StaticAtomicU64
:
:
new
(
1
)
;
}
Self
(
NEXT_ID
.
fetch_add
(
1
Relaxed
)
)
}
#
[
cfg
(
not
(
all
(
test
loom
)
)
)
]
{
static
NEXT_ID
:
StaticAtomicU64
=
StaticAtomicU64
:
:
new
(
1
)
;
Self
(
NEXT_ID
.
fetch_add
(
1
Relaxed
)
)
}
}
pub
(
crate
)
fn
as_u64
(
&
self
)
-
>
u64
{
self
.
0
}
}
