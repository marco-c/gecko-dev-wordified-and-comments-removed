#
[
cfg
(
test
)
]
#
[
macro_use
]
mod
tests
;
pub
(
crate
)
mod
context
;
cfg_rt_core
!
{
mod
basic_scheduler
;
use
basic_scheduler
:
:
BasicScheduler
;
pub
(
crate
)
mod
task
;
}
mod
blocking
;
use
blocking
:
:
BlockingPool
;
cfg_blocking_impl
!
{
#
[
allow
(
unused_imports
)
]
pub
(
crate
)
use
blocking
:
:
{
spawn_blocking
try_spawn_blocking
}
;
}
mod
builder
;
pub
use
self
:
:
builder
:
:
Builder
;
pub
(
crate
)
mod
enter
;
use
self
:
:
enter
:
:
enter
;
mod
handle
;
pub
use
self
:
:
handle
:
:
{
Handle
TryCurrentError
}
;
mod
io
;
cfg_rt_threaded
!
{
mod
park
;
use
park
:
:
Parker
;
}
mod
shell
;
use
self
:
:
shell
:
:
Shell
;
mod
spawner
;
use
self
:
:
spawner
:
:
Spawner
;
mod
time
;
cfg_rt_threaded
!
{
mod
queue
;
pub
(
crate
)
mod
thread_pool
;
use
self
:
:
thread_pool
:
:
ThreadPool
;
}
cfg_rt_core
!
{
use
crate
:
:
task
:
:
JoinHandle
;
}
use
std
:
:
future
:
:
Future
;
use
std
:
:
time
:
:
Duration
;
#
[
derive
(
Debug
)
]
pub
struct
Runtime
{
kind
:
Kind
handle
:
Handle
blocking_pool
:
BlockingPool
}
#
[
derive
(
Debug
)
]
enum
Kind
{
Shell
(
Shell
)
#
[
cfg
(
feature
=
"
rt
-
core
"
)
]
Basic
(
BasicScheduler
<
time
:
:
Driver
>
)
#
[
cfg
(
feature
=
"
rt
-
threaded
"
)
]
ThreadPool
(
ThreadPool
)
}
type
Callback
=
std
:
:
sync
:
:
Arc
<
dyn
Fn
(
)
+
Send
+
Sync
>
;
impl
Runtime
{
pub
fn
new
(
)
-
>
io
:
:
Result
<
Runtime
>
{
#
[
cfg
(
feature
=
"
rt
-
threaded
"
)
]
let
ret
=
Builder
:
:
new
(
)
.
threaded_scheduler
(
)
.
enable_all
(
)
.
build
(
)
;
#
[
cfg
(
all
(
not
(
feature
=
"
rt
-
threaded
"
)
feature
=
"
rt
-
core
"
)
)
]
let
ret
=
Builder
:
:
new
(
)
.
basic_scheduler
(
)
.
enable_all
(
)
.
build
(
)
;
#
[
cfg
(
not
(
feature
=
"
rt
-
core
"
)
)
]
let
ret
=
Builder
:
:
new
(
)
.
enable_all
(
)
.
build
(
)
;
ret
}
#
[
cfg
(
feature
=
"
rt
-
core
"
)
]
pub
fn
spawn
<
F
>
(
&
self
future
:
F
)
-
>
JoinHandle
<
F
:
:
Output
>
where
F
:
Future
+
Send
+
'
static
F
:
:
Output
:
Send
+
'
static
{
match
&
self
.
kind
{
Kind
:
:
Shell
(
_
)
=
>
panic
!
(
"
task
execution
disabled
"
)
#
[
cfg
(
feature
=
"
rt
-
threaded
"
)
]
Kind
:
:
ThreadPool
(
exec
)
=
>
exec
.
spawn
(
future
)
Kind
:
:
Basic
(
exec
)
=
>
exec
.
spawn
(
future
)
}
}
pub
fn
block_on
<
F
:
Future
>
(
&
mut
self
future
:
F
)
-
>
F
:
:
Output
{
let
kind
=
&
mut
self
.
kind
;
self
.
handle
.
enter
(
|
|
match
kind
{
Kind
:
:
Shell
(
exec
)
=
>
exec
.
block_on
(
future
)
#
[
cfg
(
feature
=
"
rt
-
core
"
)
]
Kind
:
:
Basic
(
exec
)
=
>
exec
.
block_on
(
future
)
#
[
cfg
(
feature
=
"
rt
-
threaded
"
)
]
Kind
:
:
ThreadPool
(
exec
)
=
>
exec
.
block_on
(
future
)
}
)
}
pub
fn
enter
<
F
R
>
(
&
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
{
self
.
handle
.
enter
(
f
)
}
pub
fn
handle
(
&
self
)
-
>
&
Handle
{
&
self
.
handle
}
pub
fn
shutdown_timeout
(
mut
self
duration
:
Duration
)
{
self
.
handle
.
spawner
.
shutdown
(
)
;
self
.
blocking_pool
.
shutdown
(
Some
(
duration
)
)
;
}
pub
fn
shutdown_background
(
self
)
{
self
.
shutdown_timeout
(
Duration
:
:
from_nanos
(
0
)
)
}
}
