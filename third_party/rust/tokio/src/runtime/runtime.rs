use
crate
:
:
runtime
:
:
blocking
:
:
BlockingPool
;
use
crate
:
:
runtime
:
:
scheduler
:
:
CurrentThread
;
use
crate
:
:
runtime
:
:
{
context
EnterGuard
Handle
}
;
use
crate
:
:
task
:
:
JoinHandle
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
time
:
:
Duration
;
cfg_rt_multi_thread
!
{
use
crate
:
:
runtime
:
:
Builder
;
use
crate
:
:
runtime
:
:
scheduler
:
:
MultiThread
;
}
#
[
derive
(
Debug
)
]
pub
struct
Runtime
{
scheduler
:
Scheduler
handle
:
Handle
blocking_pool
:
BlockingPool
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
enum
RuntimeFlavor
{
CurrentThread
MultiThread
}
#
[
derive
(
Debug
)
]
pub
(
super
)
enum
Scheduler
{
CurrentThread
(
CurrentThread
)
#
[
cfg
(
all
(
feature
=
"
rt
-
multi
-
thread
"
not
(
tokio_wasi
)
)
)
]
MultiThread
(
MultiThread
)
}
impl
Runtime
{
pub
(
super
)
fn
from_parts
(
scheduler
:
Scheduler
handle
:
Handle
blocking_pool
:
BlockingPool
)
-
>
Runtime
{
Runtime
{
scheduler
handle
blocking_pool
}
}
cfg_not_wasi
!
{
/
/
/
Creates
a
new
runtime
instance
with
default
configuration
values
.
/
/
/
/
/
/
This
results
in
the
multi
threaded
scheduler
I
/
O
driver
and
time
driver
being
/
/
/
initialized
.
/
/
/
/
/
/
Most
applications
will
not
need
to
call
this
function
directly
.
Instead
/
/
/
they
will
use
the
[
#
[
tokio
:
:
main
]
attribute
]
[
main
]
.
When
a
more
complex
/
/
/
configuration
is
necessary
the
[
runtime
builder
]
may
be
used
.
/
/
/
/
/
/
See
[
module
level
]
[
mod
]
documentation
for
more
details
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
Creating
a
new
Runtime
with
default
configuration
values
.
/
/
/
/
/
/
#
[
cfg
(
feature
=
"
rt
-
multi
-
thread
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
rt
-
multi
-
thread
"
)
)
)
]
pub
fn
new
(
)
-
>
std
:
:
io
:
:
Result
<
Runtime
>
{
Builder
:
:
new_multi_thread
(
)
.
enable_all
(
)
.
build
(
)
}
}
pub
fn
handle
(
&
self
)
-
>
&
Handle
{
&
self
.
handle
}
#
[
track_caller
]
pub
fn
spawn
<
F
>
(
&
self
future
:
F
)
-
>
JoinHandle
<
F
:
:
Output
>
where
F
:
Future
+
Send
+
'
static
F
:
:
Output
:
Send
+
'
static
{
self
.
handle
.
spawn
(
future
)
}
#
[
track_caller
]
pub
fn
spawn_blocking
<
F
R
>
(
&
self
func
:
F
)
-
>
JoinHandle
<
R
>
where
F
:
FnOnce
(
)
-
>
R
+
Send
+
'
static
R
:
Send
+
'
static
{
self
.
handle
.
spawn_blocking
(
func
)
}
#
[
track_caller
]
pub
fn
block_on
<
F
:
Future
>
(
&
self
future
:
F
)
-
>
F
:
:
Output
{
#
[
cfg
(
all
(
tokio_unstable
tokio_taskdump
feature
=
"
rt
"
target_os
=
"
linux
"
any
(
target_arch
=
"
aarch64
"
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
)
]
let
future
=
super
:
:
task
:
:
trace
:
:
Trace
:
:
root
(
future
)
;
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
future
=
crate
:
:
util
:
:
trace
:
:
task
(
future
"
block_on
"
None
crate
:
:
runtime
:
:
task
:
:
Id
:
:
next
(
)
.
as_u64
(
)
)
;
let
_enter
=
self
.
enter
(
)
;
match
&
self
.
scheduler
{
Scheduler
:
:
CurrentThread
(
exec
)
=
>
exec
.
block_on
(
&
self
.
handle
.
inner
future
)
#
[
cfg
(
all
(
feature
=
"
rt
-
multi
-
thread
"
not
(
tokio_wasi
)
)
)
]
Scheduler
:
:
MultiThread
(
exec
)
=
>
exec
.
block_on
(
&
self
.
handle
.
inner
future
)
}
}
pub
fn
enter
(
&
self
)
-
>
EnterGuard
<
'
_
>
{
self
.
handle
.
enter
(
)
}
pub
fn
shutdown_timeout
(
mut
self
duration
:
Duration
)
{
self
.
handle
.
inner
.
shutdown
(
)
;
self
.
blocking_pool
.
shutdown
(
Some
(
duration
)
)
;
}
pub
fn
shutdown_background
(
self
)
{
self
.
shutdown_timeout
(
Duration
:
:
from_nanos
(
0
)
)
}
}
#
[
allow
(
clippy
:
:
single_match
)
]
impl
Drop
for
Runtime
{
fn
drop
(
&
mut
self
)
{
match
&
mut
self
.
scheduler
{
Scheduler
:
:
CurrentThread
(
current_thread
)
=
>
{
let
_guard
=
context
:
:
try_set_current
(
&
self
.
handle
.
inner
)
;
current_thread
.
shutdown
(
&
self
.
handle
.
inner
)
;
}
#
[
cfg
(
all
(
feature
=
"
rt
-
multi
-
thread
"
not
(
tokio_wasi
)
)
)
]
Scheduler
:
:
MultiThread
(
multi_thread
)
=
>
{
multi_thread
.
shutdown
(
&
self
.
handle
.
inner
)
;
}
}
}
}
cfg_metrics
!
{
impl
Runtime
{
/
/
/
TODO
pub
fn
metrics
(
&
self
)
-
>
crate
:
:
runtime
:
:
RuntimeMetrics
{
self
.
handle
.
metrics
(
)
}
}
}
