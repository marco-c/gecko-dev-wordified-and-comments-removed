use
tokio_threadpool
:
:
Sender
;
use
futures
:
:
future
:
:
{
self
Future
}
;
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
use
futures2
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
TaskExecutor
{
pub
(
super
)
inner
:
Sender
}
impl
TaskExecutor
{
pub
fn
spawn
<
F
>
(
&
self
future
:
F
)
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
self
.
inner
.
spawn
(
future
)
.
unwrap
(
)
;
}
}
impl
<
T
>
future
:
:
Executor
<
T
>
for
TaskExecutor
where
T
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
fn
execute
(
&
self
future
:
T
)
-
>
Result
<
(
)
future
:
:
ExecuteError
<
T
>
>
{
self
.
inner
.
execute
(
future
)
}
}
impl
:
:
executor
:
:
Executor
for
TaskExecutor
{
fn
spawn
(
&
mut
self
future
:
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
>
)
-
>
Result
<
(
)
:
:
executor
:
:
SpawnError
>
{
self
.
inner
.
spawn
(
future
)
}
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
fn
spawn2
(
&
mut
self
future
:
Box
<
futures2
:
:
Future
<
Item
=
(
)
Error
=
futures2
:
:
Never
>
+
Send
>
)
-
>
Result
<
(
)
futures2
:
:
executor
:
:
SpawnError
>
{
self
.
inner
.
spawn2
(
future
)
}
}
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
type
Task2
=
Box
<
futures2
:
:
Future
<
Item
=
(
)
Error
=
futures2
:
:
Never
>
+
Send
>
;
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
impl
futures2
:
:
executor
:
:
Executor
for
TaskExecutor
{
fn
spawn
(
&
mut
self
f
:
Task2
)
-
>
Result
<
(
)
futures2
:
:
executor
:
:
SpawnError
>
{
futures2
:
:
executor
:
:
Executor
:
:
spawn
(
&
mut
self
.
inner
f
)
}
fn
status
(
&
self
)
-
>
Result
<
(
)
futures2
:
:
executor
:
:
SpawnError
>
{
futures2
:
:
executor
:
:
Executor
:
:
status
(
&
self
.
inner
)
}
}
