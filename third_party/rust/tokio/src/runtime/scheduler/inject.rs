use
crate
:
:
loom
:
:
sync
:
:
Mutex
;
use
crate
:
:
runtime
:
:
task
;
mod
pop
;
pub
(
crate
)
use
pop
:
:
Pop
;
mod
shared
;
pub
(
crate
)
use
shared
:
:
Shared
;
mod
synced
;
pub
(
crate
)
use
synced
:
:
Synced
;
cfg_rt_multi_thread
!
{
mod
rt_multi_thread
;
}
cfg_metrics
!
{
mod
metrics
;
}
pub
(
crate
)
struct
Inject
<
T
:
'
static
>
{
shared
:
Shared
<
T
>
synced
:
Mutex
<
Synced
>
}
impl
<
T
:
'
static
>
Inject
<
T
>
{
pub
(
crate
)
fn
new
(
)
-
>
Inject
<
T
>
{
let
(
shared
synced
)
=
Shared
:
:
new
(
)
;
Inject
{
shared
synced
:
Mutex
:
:
new
(
synced
)
}
}
#
[
cfg
(
tokio_taskdump
)
]
pub
(
crate
)
fn
is_closed
(
&
self
)
-
>
bool
{
let
synced
=
self
.
synced
.
lock
(
)
;
self
.
shared
.
is_closed
(
&
synced
)
}
pub
(
crate
)
fn
close
(
&
self
)
-
>
bool
{
let
mut
synced
=
self
.
synced
.
lock
(
)
;
self
.
shared
.
close
(
&
mut
synced
)
}
pub
(
crate
)
fn
push
(
&
self
task
:
task
:
:
Notified
<
T
>
)
{
let
mut
synced
=
self
.
synced
.
lock
(
)
;
unsafe
{
self
.
shared
.
push
(
&
mut
synced
task
)
}
}
pub
(
crate
)
fn
pop
(
&
self
)
-
>
Option
<
task
:
:
Notified
<
T
>
>
{
if
self
.
shared
.
is_empty
(
)
{
return
None
;
}
let
mut
synced
=
self
.
synced
.
lock
(
)
;
unsafe
{
self
.
shared
.
pop
(
&
mut
synced
)
}
}
}
