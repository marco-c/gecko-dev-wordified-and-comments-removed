use
crate
:
:
loom
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
crate
:
:
runtime
:
:
scheduler
:
:
multi_thread
:
:
Shared
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
self
SeqCst
}
;
pub
(
super
)
struct
Idle
{
state
:
AtomicUsize
num_workers
:
usize
}
pub
(
super
)
struct
Synced
{
sleepers
:
Vec
<
usize
>
}
const
UNPARK_SHIFT
:
usize
=
16
;
const
UNPARK_MASK
:
usize
=
!
SEARCH_MASK
;
const
SEARCH_MASK
:
usize
=
(
1
<
<
UNPARK_SHIFT
)
-
1
;
#
[
derive
(
Copy
Clone
)
]
struct
State
(
usize
)
;
impl
Idle
{
pub
(
super
)
fn
new
(
num_workers
:
usize
)
-
>
(
Idle
Synced
)
{
let
init
=
State
:
:
new
(
num_workers
)
;
let
idle
=
Idle
{
state
:
AtomicUsize
:
:
new
(
init
.
into
(
)
)
num_workers
}
;
let
synced
=
Synced
{
sleepers
:
Vec
:
:
with_capacity
(
num_workers
)
}
;
(
idle
synced
)
}
pub
(
super
)
fn
worker_to_notify
(
&
self
shared
:
&
Shared
)
-
>
Option
<
usize
>
{
if
!
self
.
notify_should_wakeup
(
)
{
return
None
;
}
let
mut
lock
=
shared
.
synced
.
lock
(
)
;
if
!
self
.
notify_should_wakeup
(
)
{
return
None
;
}
State
:
:
unpark_one
(
&
self
.
state
1
)
;
let
ret
=
lock
.
idle
.
sleepers
.
pop
(
)
;
debug_assert
!
(
ret
.
is_some
(
)
)
;
ret
}
pub
(
super
)
fn
transition_worker_to_parked
(
&
self
shared
:
&
Shared
worker
:
usize
is_searching
:
bool
)
-
>
bool
{
let
mut
lock
=
shared
.
synced
.
lock
(
)
;
let
ret
=
State
:
:
dec_num_unparked
(
&
self
.
state
is_searching
)
;
lock
.
idle
.
sleepers
.
push
(
worker
)
;
ret
}
pub
(
super
)
fn
transition_worker_to_searching
(
&
self
)
-
>
bool
{
let
state
=
State
:
:
load
(
&
self
.
state
SeqCst
)
;
if
2
*
state
.
num_searching
(
)
>
=
self
.
num_workers
{
return
false
;
}
State
:
:
inc_num_searching
(
&
self
.
state
SeqCst
)
;
true
}
pub
(
super
)
fn
transition_worker_from_searching
(
&
self
)
-
>
bool
{
State
:
:
dec_num_searching
(
&
self
.
state
)
}
pub
(
super
)
fn
unpark_worker_by_id
(
&
self
shared
:
&
Shared
worker_id
:
usize
)
-
>
bool
{
let
mut
lock
=
shared
.
synced
.
lock
(
)
;
let
sleepers
=
&
mut
lock
.
idle
.
sleepers
;
for
index
in
0
.
.
sleepers
.
len
(
)
{
if
sleepers
[
index
]
=
=
worker_id
{
sleepers
.
swap_remove
(
index
)
;
State
:
:
unpark_one
(
&
self
.
state
0
)
;
return
true
;
}
}
false
}
pub
(
super
)
fn
is_parked
(
&
self
shared
:
&
Shared
worker_id
:
usize
)
-
>
bool
{
let
lock
=
shared
.
synced
.
lock
(
)
;
lock
.
idle
.
sleepers
.
contains
(
&
worker_id
)
}
fn
notify_should_wakeup
(
&
self
)
-
>
bool
{
let
state
=
State
(
self
.
state
.
fetch_add
(
0
SeqCst
)
)
;
state
.
num_searching
(
)
=
=
0
&
&
state
.
num_unparked
(
)
<
self
.
num_workers
}
}
impl
State
{
fn
new
(
num_workers
:
usize
)
-
>
State
{
let
ret
=
State
(
num_workers
<
<
UNPARK_SHIFT
)
;
debug_assert_eq
!
(
num_workers
ret
.
num_unparked
(
)
)
;
debug_assert_eq
!
(
0
ret
.
num_searching
(
)
)
;
ret
}
fn
load
(
cell
:
&
AtomicUsize
ordering
:
Ordering
)
-
>
State
{
State
(
cell
.
load
(
ordering
)
)
}
fn
unpark_one
(
cell
:
&
AtomicUsize
num_searching
:
usize
)
{
cell
.
fetch_add
(
num_searching
|
(
1
<
<
UNPARK_SHIFT
)
SeqCst
)
;
}
fn
inc_num_searching
(
cell
:
&
AtomicUsize
ordering
:
Ordering
)
{
cell
.
fetch_add
(
1
ordering
)
;
}
fn
dec_num_searching
(
cell
:
&
AtomicUsize
)
-
>
bool
{
let
state
=
State
(
cell
.
fetch_sub
(
1
SeqCst
)
)
;
state
.
num_searching
(
)
=
=
1
}
fn
dec_num_unparked
(
cell
:
&
AtomicUsize
is_searching
:
bool
)
-
>
bool
{
let
mut
dec
=
1
<
<
UNPARK_SHIFT
;
if
is_searching
{
dec
+
=
1
;
}
let
prev
=
State
(
cell
.
fetch_sub
(
dec
SeqCst
)
)
;
is_searching
&
&
prev
.
num_searching
(
)
=
=
1
}
fn
num_searching
(
self
)
-
>
usize
{
self
.
0
&
SEARCH_MASK
}
fn
num_unparked
(
self
)
-
>
usize
{
(
self
.
0
&
UNPARK_MASK
)
>
>
UNPARK_SHIFT
}
}
impl
From
<
usize
>
for
State
{
fn
from
(
src
:
usize
)
-
>
State
{
State
(
src
)
}
}
impl
From
<
State
>
for
usize
{
fn
from
(
src
:
State
)
-
>
usize
{
src
.
0
}
}
impl
fmt
:
:
Debug
for
State
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
worker
:
:
State
"
)
.
field
(
"
num_unparked
"
&
self
.
num_unparked
(
)
)
.
field
(
"
num_searching
"
&
self
.
num_searching
(
)
)
.
finish
(
)
}
}
#
[
test
]
fn
test_state
(
)
{
assert_eq
!
(
0
UNPARK_MASK
&
SEARCH_MASK
)
;
assert_eq
!
(
0
!
(
UNPARK_MASK
|
SEARCH_MASK
)
)
;
let
state
=
State
:
:
new
(
10
)
;
assert_eq
!
(
10
state
.
num_unparked
(
)
)
;
assert_eq
!
(
0
state
.
num_searching
(
)
)
;
}
