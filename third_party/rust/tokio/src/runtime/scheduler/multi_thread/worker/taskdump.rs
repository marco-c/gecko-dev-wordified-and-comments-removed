use
super
:
:
{
Core
Handle
Shared
}
;
use
crate
:
:
loom
:
:
sync
:
:
Arc
;
use
crate
:
:
runtime
:
:
scheduler
:
:
multi_thread
:
:
Stats
;
use
crate
:
:
runtime
:
:
task
:
:
trace
:
:
trace_multi_thread
;
use
crate
:
:
runtime
:
:
{
dump
WorkerMetrics
}
;
use
std
:
:
time
:
:
Duration
;
impl
Handle
{
pub
(
super
)
fn
trace_core
(
&
self
mut
core
:
Box
<
Core
>
)
-
>
Box
<
Core
>
{
core
.
is_traced
=
false
;
if
core
.
is_shutdown
{
return
core
;
}
let
timeout
=
Duration
:
:
from_millis
(
250
)
;
let
barrier
=
if
let
Some
(
barrier
)
=
self
.
shared
.
trace_status
.
trace_start
.
wait_timeout
(
timeout
)
{
barrier
}
else
{
return
core
;
}
;
if
!
barrier
.
is_leader
(
)
{
self
.
shared
.
trace_status
.
trace_end
.
wait
(
)
;
return
core
;
}
let
owned
=
&
self
.
shared
.
owned
;
let
mut
local
=
self
.
shared
.
steal_all
(
)
;
let
synced
=
&
self
.
shared
.
synced
;
let
injection
=
&
self
.
shared
.
inject
;
let
traces
=
unsafe
{
trace_multi_thread
(
owned
&
mut
local
synced
injection
)
}
.
into_iter
(
)
.
map
(
|
(
id
trace
)
|
dump
:
:
Task
:
:
new
(
id
trace
)
)
.
collect
(
)
;
let
result
=
dump
:
:
Dump
:
:
new
(
traces
)
;
self
.
shared
.
trace_status
.
stash_result
(
result
)
;
self
.
shared
.
trace_status
.
trace_end
.
wait
(
)
;
core
}
}
impl
Shared
{
pub
(
super
)
fn
steal_all
(
&
self
)
-
>
super
:
:
queue
:
:
Local
<
Arc
<
Handle
>
>
{
let
(
_steal
mut
local
)
=
super
:
:
queue
:
:
local
(
)
;
let
worker_metrics
=
WorkerMetrics
:
:
new
(
)
;
let
mut
stats
=
Stats
:
:
new
(
&
worker_metrics
)
;
for
remote
in
self
.
remotes
.
iter
(
)
{
let
steal
=
&
remote
.
steal
;
while
!
steal
.
is_empty
(
)
{
if
let
Some
(
task
)
=
steal
.
steal_into
(
&
mut
local
&
mut
stats
)
{
local
.
push_back
(
[
task
]
.
into_iter
(
)
)
;
}
}
}
local
}
}
