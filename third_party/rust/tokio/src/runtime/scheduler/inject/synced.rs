use
crate
:
:
runtime
:
:
task
;
pub
(
crate
)
struct
Synced
{
pub
(
super
)
is_closed
:
bool
pub
(
super
)
head
:
Option
<
task
:
:
RawTask
>
pub
(
super
)
tail
:
Option
<
task
:
:
RawTask
>
}
unsafe
impl
Send
for
Synced
{
}
unsafe
impl
Sync
for
Synced
{
}
impl
Synced
{
pub
(
super
)
fn
pop
<
T
:
'
static
>
(
&
mut
self
)
-
>
Option
<
task
:
:
Notified
<
T
>
>
{
let
task
=
self
.
head
?
;
self
.
head
=
unsafe
{
task
.
get_queue_next
(
)
}
;
if
self
.
head
.
is_none
(
)
{
self
.
tail
=
None
;
}
unsafe
{
task
.
set_queue_next
(
None
)
}
;
Some
(
unsafe
{
task
:
:
Notified
:
:
from_raw
(
task
)
}
)
}
}
