use
super
:
:
{
Shared
Synced
}
;
use
crate
:
:
runtime
:
:
scheduler
:
:
Lock
;
use
crate
:
:
runtime
:
:
task
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
Release
;
impl
<
'
a
>
Lock
<
Synced
>
for
&
'
a
mut
Synced
{
type
Handle
=
&
'
a
mut
Synced
;
fn
lock
(
self
)
-
>
Self
:
:
Handle
{
self
}
}
impl
AsMut
<
Synced
>
for
Synced
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
Synced
{
self
}
}
impl
<
T
:
'
static
>
Shared
<
T
>
{
#
[
inline
]
pub
(
crate
)
unsafe
fn
push_batch
<
L
I
>
(
&
self
shared
:
L
mut
iter
:
I
)
where
L
:
Lock
<
Synced
>
I
:
Iterator
<
Item
=
task
:
:
Notified
<
T
>
>
{
let
first
=
match
iter
.
next
(
)
{
Some
(
first
)
=
>
first
.
into_raw
(
)
None
=
>
return
}
;
let
mut
prev
=
first
;
let
mut
counter
=
1
;
iter
.
for_each
(
|
next
|
{
let
next
=
next
.
into_raw
(
)
;
unsafe
{
prev
.
set_queue_next
(
Some
(
next
)
)
}
;
prev
=
next
;
counter
+
=
1
;
}
)
;
self
.
push_batch_inner
(
shared
first
prev
counter
)
;
}
#
[
inline
]
unsafe
fn
push_batch_inner
<
L
>
(
&
self
shared
:
L
batch_head
:
task
:
:
RawTask
batch_tail
:
task
:
:
RawTask
num
:
usize
)
where
L
:
Lock
<
Synced
>
{
debug_assert
!
(
unsafe
{
batch_tail
.
get_queue_next
(
)
.
is_none
(
)
}
)
;
let
mut
synced
=
shared
.
lock
(
)
;
let
synced
=
synced
.
as_mut
(
)
;
if
let
Some
(
tail
)
=
synced
.
tail
{
unsafe
{
tail
.
set_queue_next
(
Some
(
batch_head
)
)
;
}
}
else
{
synced
.
head
=
Some
(
batch_head
)
;
}
synced
.
tail
=
Some
(
batch_tail
)
;
let
len
=
self
.
len
.
unsync_load
(
)
;
self
.
len
.
store
(
len
+
num
Release
)
;
}
}
