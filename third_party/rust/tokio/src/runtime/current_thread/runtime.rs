use
executor
:
:
current_thread
:
:
{
self
CurrentThread
}
;
use
executor
:
:
current_thread
:
:
Handle
as
ExecutorHandle
;
use
runtime
:
:
current_thread
:
:
Builder
;
use
tokio_reactor
:
:
{
self
Reactor
}
;
use
tokio_timer
:
:
clock
:
:
{
self
Clock
}
;
use
tokio_timer
:
:
timer
:
:
{
self
Timer
}
;
use
tokio_executor
;
use
futures
:
:
Future
;
use
std
:
:
io
;
#
[
derive
(
Debug
)
]
pub
struct
Runtime
{
reactor_handle
:
tokio_reactor
:
:
Handle
timer_handle
:
timer
:
:
Handle
clock
:
Clock
executor
:
CurrentThread
<
Timer
<
Reactor
>
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Handle
(
ExecutorHandle
)
;
impl
Handle
{
pub
fn
spawn
<
F
>
(
&
self
future
:
F
)
-
>
Result
<
(
)
tokio_executor
:
:
SpawnError
>
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
self
.
0
.
spawn
(
future
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
RunError
{
inner
:
current_thread
:
:
RunError
}
impl
Runtime
{
pub
fn
new
(
)
-
>
io
:
:
Result
<
Runtime
>
{
Builder
:
:
new
(
)
.
build
(
)
}
pub
(
super
)
fn
new2
(
reactor_handle
:
tokio_reactor
:
:
Handle
timer_handle
:
timer
:
:
Handle
clock
:
Clock
executor
:
CurrentThread
<
Timer
<
Reactor
>
>
)
-
>
Runtime
{
Runtime
{
reactor_handle
timer_handle
clock
executor
}
}
pub
fn
handle
(
&
self
)
-
>
Handle
{
Handle
(
self
.
executor
.
handle
(
)
.
clone
(
)
)
}
pub
fn
spawn
<
F
>
(
&
mut
self
future
:
F
)
-
>
&
mut
Self
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
self
.
executor
.
spawn
(
future
)
;
self
}
pub
fn
block_on
<
F
>
(
&
mut
self
f
:
F
)
-
>
Result
<
F
:
:
Item
F
:
:
Error
>
where
F
:
Future
{
self
.
enter
(
|
executor
|
{
let
ret
=
executor
.
block_on
(
f
)
;
ret
.
map_err
(
|
e
|
e
.
into_inner
(
)
.
expect
(
"
unexpected
execution
error
"
)
)
}
)
}
pub
fn
run
(
&
mut
self
)
-
>
Result
<
(
)
RunError
>
{
self
.
enter
(
|
executor
|
executor
.
run
(
)
)
.
map_err
(
|
e
|
RunError
{
inner
:
e
}
)
}
fn
enter
<
F
R
>
(
&
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
current_thread
:
:
Entered
<
Timer
<
Reactor
>
>
)
-
>
R
{
let
Runtime
{
ref
reactor_handle
ref
timer_handle
ref
clock
ref
mut
executor
.
.
}
=
*
self
;
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
expect
(
"
Multiple
executors
at
once
"
)
;
tokio_reactor
:
:
with_default
(
&
reactor_handle
&
mut
enter
|
enter
|
{
clock
:
:
with_default
(
clock
enter
|
enter
|
{
timer
:
:
with_default
(
&
timer_handle
enter
|
enter
|
{
let
mut
default_executor
=
current_thread
:
:
TaskExecutor
:
:
current
(
)
;
tokio_executor
:
:
with_default
(
&
mut
default_executor
enter
|
enter
|
{
let
mut
executor
=
executor
.
enter
(
enter
)
;
f
(
&
mut
executor
)
}
)
}
)
}
)
}
)
}
}
