use
crate
:
:
runtime
:
:
Handle
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
Relaxed
;
use
std
:
:
time
:
:
Duration
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
RuntimeMetrics
{
handle
:
Handle
}
impl
RuntimeMetrics
{
pub
(
crate
)
fn
new
(
handle
:
Handle
)
-
>
RuntimeMetrics
{
RuntimeMetrics
{
handle
}
}
pub
fn
num_workers
(
&
self
)
-
>
usize
{
self
.
handle
.
spawner
.
num_workers
(
)
}
pub
fn
remote_schedule_count
(
&
self
)
-
>
u64
{
self
.
handle
.
spawner
.
scheduler_metrics
(
)
.
remote_schedule_count
.
load
(
Relaxed
)
}
pub
fn
worker_park_count
(
&
self
worker
:
usize
)
-
>
u64
{
self
.
handle
.
spawner
.
worker_metrics
(
worker
)
.
park_count
.
load
(
Relaxed
)
}
pub
fn
worker_noop_count
(
&
self
worker
:
usize
)
-
>
u64
{
self
.
handle
.
spawner
.
worker_metrics
(
worker
)
.
noop_count
.
load
(
Relaxed
)
}
pub
fn
worker_steal_count
(
&
self
worker
:
usize
)
-
>
u64
{
self
.
handle
.
spawner
.
worker_metrics
(
worker
)
.
steal_count
.
load
(
Relaxed
)
}
pub
fn
worker_poll_count
(
&
self
worker
:
usize
)
-
>
u64
{
self
.
handle
.
spawner
.
worker_metrics
(
worker
)
.
poll_count
.
load
(
Relaxed
)
}
pub
fn
worker_total_busy_duration
(
&
self
worker
:
usize
)
-
>
Duration
{
let
nanos
=
self
.
handle
.
spawner
.
worker_metrics
(
worker
)
.
busy_duration_total
.
load
(
Relaxed
)
;
Duration
:
:
from_nanos
(
nanos
)
}
pub
fn
worker_local_schedule_count
(
&
self
worker
:
usize
)
-
>
u64
{
self
.
handle
.
spawner
.
worker_metrics
(
worker
)
.
local_schedule_count
.
load
(
Relaxed
)
}
pub
fn
worker_overflow_count
(
&
self
worker
:
usize
)
-
>
u64
{
self
.
handle
.
spawner
.
worker_metrics
(
worker
)
.
overflow_count
.
load
(
Relaxed
)
}
pub
fn
injection_queue_depth
(
&
self
)
-
>
usize
{
self
.
handle
.
spawner
.
injection_queue_depth
(
)
}
pub
fn
worker_local_queue_depth
(
&
self
worker
:
usize
)
-
>
usize
{
self
.
handle
.
spawner
.
worker_local_queue_depth
(
worker
)
}
}
