use
crate
:
:
runtime
:
:
WorkerMetrics
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
Relaxed
;
use
std
:
:
time
:
:
Instant
;
pub
(
crate
)
struct
MetricsBatch
{
park_count
:
u64
noop_count
:
u64
steal_count
:
u64
poll_count
:
u64
poll_count_on_last_park
:
u64
local_schedule_count
:
u64
overflow_count
:
u64
busy_duration_total
:
u64
last_resume_time
:
Instant
}
impl
MetricsBatch
{
pub
(
crate
)
fn
new
(
)
-
>
MetricsBatch
{
MetricsBatch
{
park_count
:
0
noop_count
:
0
steal_count
:
0
poll_count
:
0
poll_count_on_last_park
:
0
local_schedule_count
:
0
overflow_count
:
0
busy_duration_total
:
0
last_resume_time
:
Instant
:
:
now
(
)
}
}
pub
(
crate
)
fn
submit
(
&
mut
self
worker
:
&
WorkerMetrics
)
{
worker
.
park_count
.
store
(
self
.
park_count
Relaxed
)
;
worker
.
noop_count
.
store
(
self
.
noop_count
Relaxed
)
;
worker
.
steal_count
.
store
(
self
.
steal_count
Relaxed
)
;
worker
.
poll_count
.
store
(
self
.
poll_count
Relaxed
)
;
worker
.
busy_duration_total
.
store
(
self
.
busy_duration_total
Relaxed
)
;
worker
.
local_schedule_count
.
store
(
self
.
local_schedule_count
Relaxed
)
;
worker
.
overflow_count
.
store
(
self
.
overflow_count
Relaxed
)
;
}
pub
(
crate
)
fn
about_to_park
(
&
mut
self
)
{
self
.
park_count
+
=
1
;
if
self
.
poll_count_on_last_park
=
=
self
.
poll_count
{
self
.
noop_count
+
=
1
;
}
else
{
self
.
poll_count_on_last_park
=
self
.
poll_count
;
}
let
busy_duration
=
self
.
last_resume_time
.
elapsed
(
)
;
let
busy_duration
=
u64
:
:
try_from
(
busy_duration
.
as_nanos
(
)
)
.
unwrap_or
(
u64
:
:
MAX
)
;
self
.
busy_duration_total
+
=
busy_duration
;
}
pub
(
crate
)
fn
returned_from_park
(
&
mut
self
)
{
self
.
last_resume_time
=
Instant
:
:
now
(
)
;
}
pub
(
crate
)
fn
inc_local_schedule_count
(
&
mut
self
)
{
self
.
local_schedule_count
+
=
1
;
}
pub
(
crate
)
fn
incr_poll_count
(
&
mut
self
)
{
self
.
poll_count
+
=
1
;
}
}
cfg_rt_multi_thread
!
{
impl
MetricsBatch
{
pub
(
crate
)
fn
incr_steal_count
(
&
mut
self
by
:
u16
)
{
self
.
steal_count
+
=
by
as
u64
;
}
pub
(
crate
)
fn
incr_overflow_count
(
&
mut
self
)
{
self
.
overflow_count
+
=
1
;
}
}
}
