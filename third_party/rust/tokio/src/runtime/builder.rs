use
crate
:
:
runtime
:
:
handle
:
:
Handle
;
use
crate
:
:
runtime
:
:
shell
:
:
Shell
;
use
crate
:
:
runtime
:
:
{
blocking
io
time
Callback
Runtime
Spawner
}
;
use
std
:
:
fmt
;
#
[
cfg
(
not
(
loom
)
)
]
use
std
:
:
sync
:
:
Arc
;
pub
struct
Builder
{
kind
:
Kind
enable_io
:
bool
enable_time
:
bool
core_threads
:
Option
<
usize
>
max_threads
:
usize
pub
(
super
)
thread_name
:
String
pub
(
super
)
thread_stack_size
:
Option
<
usize
>
pub
(
super
)
after_start
:
Option
<
Callback
>
pub
(
super
)
before_stop
:
Option
<
Callback
>
}
#
[
derive
(
Debug
Clone
Copy
)
]
enum
Kind
{
Shell
#
[
cfg
(
feature
=
"
rt
-
core
"
)
]
Basic
#
[
cfg
(
feature
=
"
rt
-
threaded
"
)
]
ThreadPool
}
impl
Builder
{
pub
fn
new
(
)
-
>
Builder
{
Builder
{
kind
:
Kind
:
:
Shell
enable_io
:
false
enable_time
:
false
core_threads
:
None
max_threads
:
512
thread_name
:
"
tokio
-
runtime
-
worker
"
.
into
(
)
thread_stack_size
:
None
after_start
:
None
before_stop
:
None
}
}
pub
fn
enable_all
(
&
mut
self
)
-
>
&
mut
Self
{
#
[
cfg
(
feature
=
"
io
-
driver
"
)
]
self
.
enable_io
(
)
;
#
[
cfg
(
feature
=
"
time
"
)
]
self
.
enable_time
(
)
;
self
}
#
[
deprecated
(
note
=
"
In
future
will
be
replaced
by
core_threads
method
"
)
]
pub
fn
num_threads
(
&
mut
self
val
:
usize
)
-
>
&
mut
Self
{
self
.
core_threads
=
Some
(
val
)
;
self
}
pub
fn
core_threads
(
&
mut
self
val
:
usize
)
-
>
&
mut
Self
{
assert_ne
!
(
val
0
"
Core
threads
cannot
be
zero
"
)
;
self
.
core_threads
=
Some
(
val
)
;
self
}
pub
fn
max_threads
(
&
mut
self
val
:
usize
)
-
>
&
mut
Self
{
assert_ne
!
(
val
0
"
Thread
limit
cannot
be
zero
"
)
;
self
.
max_threads
=
val
;
self
}
pub
fn
thread_name
(
&
mut
self
val
:
impl
Into
<
String
>
)
-
>
&
mut
Self
{
self
.
thread_name
=
val
.
into
(
)
;
self
}
pub
fn
thread_stack_size
(
&
mut
self
val
:
usize
)
-
>
&
mut
Self
{
self
.
thread_stack_size
=
Some
(
val
)
;
self
}
#
[
cfg
(
not
(
loom
)
)
]
pub
fn
on_thread_start
<
F
>
(
&
mut
self
f
:
F
)
-
>
&
mut
Self
where
F
:
Fn
(
)
+
Send
+
Sync
+
'
static
{
self
.
after_start
=
Some
(
Arc
:
:
new
(
f
)
)
;
self
}
#
[
cfg
(
not
(
loom
)
)
]
pub
fn
on_thread_stop
<
F
>
(
&
mut
self
f
:
F
)
-
>
&
mut
Self
where
F
:
Fn
(
)
+
Send
+
Sync
+
'
static
{
self
.
before_stop
=
Some
(
Arc
:
:
new
(
f
)
)
;
self
}
pub
fn
build
(
&
mut
self
)
-
>
io
:
:
Result
<
Runtime
>
{
match
self
.
kind
{
Kind
:
:
Shell
=
>
self
.
build_shell_runtime
(
)
#
[
cfg
(
feature
=
"
rt
-
core
"
)
]
Kind
:
:
Basic
=
>
self
.
build_basic_runtime
(
)
#
[
cfg
(
feature
=
"
rt
-
threaded
"
)
]
Kind
:
:
ThreadPool
=
>
self
.
build_threaded_runtime
(
)
}
}
fn
build_shell_runtime
(
&
mut
self
)
-
>
io
:
:
Result
<
Runtime
>
{
use
crate
:
:
runtime
:
:
Kind
;
let
clock
=
time
:
:
create_clock
(
)
;
let
(
io_driver
io_handle
)
=
io
:
:
create_driver
(
self
.
enable_io
)
?
;
let
(
driver
time_handle
)
=
time
:
:
create_driver
(
self
.
enable_time
io_driver
clock
.
clone
(
)
)
;
let
spawner
=
Spawner
:
:
Shell
;
let
blocking_pool
=
blocking
:
:
create_blocking_pool
(
self
self
.
max_threads
)
;
let
blocking_spawner
=
blocking_pool
.
spawner
(
)
.
clone
(
)
;
Ok
(
Runtime
{
kind
:
Kind
:
:
Shell
(
Shell
:
:
new
(
driver
)
)
handle
:
Handle
{
spawner
io_handle
time_handle
clock
blocking_spawner
}
blocking_pool
}
)
}
}
cfg_io_driver
!
{
impl
Builder
{
/
/
/
Enables
the
I
/
O
driver
.
/
/
/
/
/
/
Doing
this
enables
using
net
process
signal
and
some
I
/
O
types
on
/
/
/
the
runtime
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
;
/
/
/
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new
(
)
/
/
/
.
enable_io
(
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
pub
fn
enable_io
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
enable_io
=
true
;
self
}
}
}
cfg_time
!
{
impl
Builder
{
/
/
/
Enables
the
time
driver
.
/
/
/
/
/
/
Doing
this
enables
using
tokio
:
:
time
on
the
runtime
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
;
/
/
/
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new
(
)
/
/
/
.
enable_time
(
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
pub
fn
enable_time
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
enable_time
=
true
;
self
}
}
}
cfg_rt_core
!
{
impl
Builder
{
/
/
/
Sets
runtime
to
use
a
simpler
scheduler
that
runs
all
tasks
on
the
current
-
thread
.
/
/
/
/
/
/
The
executor
and
all
necessary
drivers
will
all
be
run
on
the
current
/
/
/
thread
during
[
block_on
]
calls
.
/
/
/
/
/
/
See
also
[
the
module
level
documentation
]
[
1
]
which
has
a
section
on
scheduler
/
/
/
types
.
/
/
/
/
/
/
[
1
]
:
index
.
html
#
runtime
-
configurations
/
/
/
[
block_on
]
:
Runtime
:
:
block_on
pub
fn
basic_scheduler
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
kind
=
Kind
:
:
Basic
;
self
}
fn
build_basic_runtime
(
&
mut
self
)
-
>
io
:
:
Result
<
Runtime
>
{
use
crate
:
:
runtime
:
:
{
BasicScheduler
Kind
}
;
let
clock
=
time
:
:
create_clock
(
)
;
/
/
Create
I
/
O
driver
let
(
io_driver
io_handle
)
=
io
:
:
create_driver
(
self
.
enable_io
)
?
;
let
(
driver
time_handle
)
=
time
:
:
create_driver
(
self
.
enable_time
io_driver
clock
.
clone
(
)
)
;
/
/
And
now
put
a
single
-
threaded
scheduler
on
top
of
the
timer
.
When
/
/
there
are
no
futures
ready
to
do
something
it
'
ll
let
the
timer
or
/
/
the
reactor
to
generate
some
new
stimuli
for
the
futures
to
continue
/
/
in
their
life
.
let
scheduler
=
BasicScheduler
:
:
new
(
driver
)
;
let
spawner
=
Spawner
:
:
Basic
(
scheduler
.
spawner
(
)
.
clone
(
)
)
;
/
/
Blocking
pool
let
blocking_pool
=
blocking
:
:
create_blocking_pool
(
self
self
.
max_threads
)
;
let
blocking_spawner
=
blocking_pool
.
spawner
(
)
.
clone
(
)
;
Ok
(
Runtime
{
kind
:
Kind
:
:
Basic
(
scheduler
)
handle
:
Handle
{
spawner
io_handle
time_handle
clock
blocking_spawner
}
blocking_pool
}
)
}
}
}
cfg_rt_threaded
!
{
impl
Builder
{
/
/
/
Sets
runtime
to
use
a
multi
-
threaded
scheduler
for
executing
tasks
.
/
/
/
/
/
/
See
also
[
the
module
level
documentation
]
[
1
]
which
has
a
section
on
scheduler
/
/
/
types
.
/
/
/
/
/
/
[
1
]
:
index
.
html
#
runtime
-
configurations
pub
fn
threaded_scheduler
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
kind
=
Kind
:
:
ThreadPool
;
self
}
fn
build_threaded_runtime
(
&
mut
self
)
-
>
io
:
:
Result
<
Runtime
>
{
use
crate
:
:
loom
:
:
sys
:
:
num_cpus
;
use
crate
:
:
runtime
:
:
{
Kind
ThreadPool
}
;
use
crate
:
:
runtime
:
:
park
:
:
Parker
;
use
std
:
:
cmp
;
let
core_threads
=
self
.
core_threads
.
unwrap_or_else
(
|
|
cmp
:
:
min
(
self
.
max_threads
num_cpus
(
)
)
)
;
assert
!
(
core_threads
<
=
self
.
max_threads
"
Core
threads
number
cannot
be
above
max
limit
"
)
;
let
clock
=
time
:
:
create_clock
(
)
;
let
(
io_driver
io_handle
)
=
io
:
:
create_driver
(
self
.
enable_io
)
?
;
let
(
driver
time_handle
)
=
time
:
:
create_driver
(
self
.
enable_time
io_driver
clock
.
clone
(
)
)
;
let
(
scheduler
launch
)
=
ThreadPool
:
:
new
(
core_threads
Parker
:
:
new
(
driver
)
)
;
let
spawner
=
Spawner
:
:
ThreadPool
(
scheduler
.
spawner
(
)
.
clone
(
)
)
;
/
/
Create
the
blocking
pool
let
blocking_pool
=
blocking
:
:
create_blocking_pool
(
self
self
.
max_threads
)
;
let
blocking_spawner
=
blocking_pool
.
spawner
(
)
.
clone
(
)
;
/
/
Create
the
runtime
handle
let
handle
=
Handle
{
spawner
io_handle
time_handle
clock
blocking_spawner
}
;
/
/
Spawn
the
thread
pool
workers
handle
.
enter
(
|
|
launch
.
launch
(
)
)
;
Ok
(
Runtime
{
kind
:
Kind
:
:
ThreadPool
(
scheduler
)
handle
blocking_pool
}
)
}
}
}
impl
Default
for
Builder
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
fmt
:
:
Debug
for
Builder
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Builder
"
)
.
field
(
"
kind
"
&
self
.
kind
)
.
field
(
"
core_threads
"
&
self
.
core_threads
)
.
field
(
"
max_threads
"
&
self
.
max_threads
)
.
field
(
"
thread_name
"
&
self
.
thread_name
)
.
field
(
"
thread_stack_size
"
&
self
.
thread_stack_size
)
.
field
(
"
after_start
"
&
self
.
after_start
.
as_ref
(
)
.
map
(
|
_
|
"
.
.
.
"
)
)
.
field
(
"
before_stop
"
&
self
.
after_start
.
as_ref
(
)
.
map
(
|
_
|
"
.
.
.
"
)
)
.
finish
(
)
}
}
