use
crate
:
:
runtime
:
:
handle
:
:
Handle
;
use
crate
:
:
runtime
:
:
{
blocking
driver
Callback
HistogramBuilder
Runtime
}
;
use
crate
:
:
util
:
:
rand
:
:
{
RngSeed
RngSeedGenerator
}
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
time
:
:
Duration
;
pub
struct
Builder
{
kind
:
Kind
enable_io
:
bool
nevents
:
usize
enable_time
:
bool
start_paused
:
bool
worker_threads
:
Option
<
usize
>
max_blocking_threads
:
usize
pub
(
super
)
thread_name
:
ThreadNameFn
pub
(
super
)
thread_stack_size
:
Option
<
usize
>
pub
(
super
)
after_start
:
Option
<
Callback
>
pub
(
super
)
before_stop
:
Option
<
Callback
>
pub
(
super
)
before_park
:
Option
<
Callback
>
pub
(
super
)
after_unpark
:
Option
<
Callback
>
pub
(
super
)
keep_alive
:
Option
<
Duration
>
pub
(
super
)
global_queue_interval
:
Option
<
u32
>
pub
(
super
)
event_interval
:
u32
pub
(
super
)
local_queue_capacity
:
usize
pub
(
super
)
disable_lifo_slot
:
bool
pub
(
super
)
seed_generator
:
RngSeedGenerator
pub
(
super
)
metrics_poll_count_histogram_enable
:
bool
pub
(
super
)
metrics_poll_count_histogram
:
HistogramBuilder
#
[
cfg
(
tokio_unstable
)
]
pub
(
super
)
unhandled_panic
:
UnhandledPanic
}
cfg_unstable
!
{
/
/
/
How
the
runtime
should
respond
to
unhandled
panics
.
/
/
/
/
/
/
Instances
of
UnhandledPanic
are
passed
to
Builder
:
:
unhandled_panic
#
[
derive
(
Debug
Clone
)
]
#
[
non_exhaustive
]
pub
enum
UnhandledPanic
{
/
/
/
The
runtime
should
ignore
panics
on
spawned
tasks
.
/
/
/
/
/
/
The
panic
is
forwarded
to
the
task
'
s
[
JoinHandle
]
and
all
spawned
/
/
/
tasks
continue
running
normally
.
/
/
/
/
/
/
This
is
the
default
behavior
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
:
:
{
self
UnhandledPanic
}
;
/
/
/
/
/
/
#
pub
fn
main
(
)
{
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_current_thread
(
)
/
/
/
.
unhandled_panic
(
UnhandledPanic
:
:
Ignore
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
/
/
/
let
task1
=
rt
.
spawn
(
async
{
panic
!
(
"
boom
"
)
;
}
)
;
/
/
/
let
task2
=
rt
.
spawn
(
async
{
/
/
/
/
/
This
task
completes
normally
/
/
/
"
done
"
/
/
/
}
)
;
/
/
/
/
/
/
rt
.
block_on
(
async
{
/
/
/
/
/
The
panic
on
the
first
task
is
forwarded
to
the
JoinHandle
/
/
/
assert
!
(
task1
.
await
.
is_err
(
)
)
;
/
/
/
/
/
/
/
/
The
second
task
completes
normally
/
/
/
assert
!
(
task2
.
await
.
is_ok
(
)
)
;
/
/
/
}
)
/
/
/
#
}
/
/
/
/
/
/
/
/
/
[
JoinHandle
]
:
struct
crate
:
:
task
:
:
JoinHandle
Ignore
/
/
/
The
runtime
should
immediately
shutdown
if
a
spawned
task
panics
.
/
/
/
/
/
/
The
runtime
will
immediately
shutdown
even
if
the
panicked
task
'
s
/
/
/
[
JoinHandle
]
is
still
available
.
All
further
spawned
tasks
will
be
/
/
/
immediately
dropped
and
call
to
[
Runtime
:
:
block_on
]
will
panic
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
should_panic
/
/
/
use
tokio
:
:
runtime
:
:
{
self
UnhandledPanic
}
;
/
/
/
/
/
/
#
pub
fn
main
(
)
{
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_current_thread
(
)
/
/
/
.
unhandled_panic
(
UnhandledPanic
:
:
ShutdownRuntime
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
/
/
/
rt
.
spawn
(
async
{
panic
!
(
"
boom
"
)
;
}
)
;
/
/
/
rt
.
spawn
(
async
{
/
/
/
/
/
This
task
never
completes
.
/
/
/
}
)
;
/
/
/
/
/
/
rt
.
block_on
(
async
{
/
/
/
/
/
Do
some
work
/
/
/
#
loop
{
tokio
:
:
task
:
:
yield_now
(
)
.
await
;
}
/
/
/
}
)
/
/
/
#
}
/
/
/
/
/
/
/
/
/
[
JoinHandle
]
:
struct
crate
:
:
task
:
:
JoinHandle
ShutdownRuntime
}
}
pub
(
crate
)
type
ThreadNameFn
=
std
:
:
sync
:
:
Arc
<
dyn
Fn
(
)
-
>
String
+
Send
+
Sync
+
'
static
>
;
#
[
derive
(
Clone
Copy
)
]
pub
(
crate
)
enum
Kind
{
CurrentThread
#
[
cfg
(
feature
=
"
rt
-
multi
-
thread
"
)
]
MultiThread
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
rt
-
multi
-
thread
"
)
)
]
MultiThreadAlt
}
impl
Builder
{
pub
fn
new_current_thread
(
)
-
>
Builder
{
#
[
cfg
(
loom
)
]
const
EVENT_INTERVAL
:
u32
=
4
;
#
[
cfg
(
not
(
loom
)
)
]
const
EVENT_INTERVAL
:
u32
=
61
;
Builder
:
:
new
(
Kind
:
:
CurrentThread
EVENT_INTERVAL
)
}
#
[
cfg
(
feature
=
"
rt
-
multi
-
thread
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
rt
-
multi
-
thread
"
)
)
)
]
pub
fn
new_multi_thread
(
)
-
>
Builder
{
Builder
:
:
new
(
Kind
:
:
MultiThread
61
)
}
cfg_unstable
!
{
/
/
/
Returns
a
new
builder
with
the
alternate
multi
thread
scheduler
/
/
/
selected
.
/
/
/
/
/
/
The
alternate
multi
threaded
scheduler
is
an
in
-
progress
/
/
/
candidate
to
replace
the
existing
multi
threaded
scheduler
.
It
/
/
/
currently
does
not
scale
as
well
to
16
+
processors
.
/
/
/
/
/
/
This
runtime
flavor
is
currently
*
*
not
considered
production
/
/
/
ready
*
*
.
/
/
/
/
/
/
Configuration
methods
can
be
chained
on
the
return
value
.
#
[
cfg
(
feature
=
"
rt
-
multi
-
thread
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
rt
-
multi
-
thread
"
)
)
)
]
pub
fn
new_multi_thread_alt
(
)
-
>
Builder
{
/
/
The
number
61
is
fairly
arbitrary
.
I
believe
this
value
was
copied
from
golang
.
Builder
:
:
new
(
Kind
:
:
MultiThreadAlt
61
)
}
}
pub
(
crate
)
fn
new
(
kind
:
Kind
event_interval
:
u32
)
-
>
Builder
{
Builder
{
kind
enable_io
:
false
nevents
:
1024
enable_time
:
false
start_paused
:
false
worker_threads
:
None
max_blocking_threads
:
512
thread_name
:
std
:
:
sync
:
:
Arc
:
:
new
(
|
|
"
tokio
-
runtime
-
worker
"
.
into
(
)
)
thread_stack_size
:
None
after_start
:
None
before_stop
:
None
before_park
:
None
after_unpark
:
None
keep_alive
:
None
global_queue_interval
:
None
event_interval
#
[
cfg
(
not
(
loom
)
)
]
local_queue_capacity
:
256
#
[
cfg
(
loom
)
]
local_queue_capacity
:
4
seed_generator
:
RngSeedGenerator
:
:
new
(
RngSeed
:
:
new
(
)
)
#
[
cfg
(
tokio_unstable
)
]
unhandled_panic
:
UnhandledPanic
:
:
Ignore
metrics_poll_count_histogram_enable
:
false
metrics_poll_count_histogram
:
HistogramBuilder
:
:
default
(
)
disable_lifo_slot
:
false
}
}
pub
fn
enable_all
(
&
mut
self
)
-
>
&
mut
Self
{
#
[
cfg
(
any
(
feature
=
"
net
"
all
(
unix
feature
=
"
process
"
)
all
(
unix
feature
=
"
signal
"
)
)
)
]
self
.
enable_io
(
)
;
#
[
cfg
(
feature
=
"
time
"
)
]
self
.
enable_time
(
)
;
self
}
#
[
track_caller
]
pub
fn
worker_threads
(
&
mut
self
val
:
usize
)
-
>
&
mut
Self
{
assert
!
(
val
>
0
"
Worker
threads
cannot
be
set
to
0
"
)
;
self
.
worker_threads
=
Some
(
val
)
;
self
}
#
[
track_caller
]
#
[
cfg_attr
(
docsrs
doc
(
alias
=
"
max_threads
"
)
)
]
pub
fn
max_blocking_threads
(
&
mut
self
val
:
usize
)
-
>
&
mut
Self
{
assert
!
(
val
>
0
"
Max
blocking
threads
cannot
be
set
to
0
"
)
;
self
.
max_blocking_threads
=
val
;
self
}
pub
fn
thread_name
(
&
mut
self
val
:
impl
Into
<
String
>
)
-
>
&
mut
Self
{
let
val
=
val
.
into
(
)
;
self
.
thread_name
=
std
:
:
sync
:
:
Arc
:
:
new
(
move
|
|
val
.
clone
(
)
)
;
self
}
pub
fn
thread_name_fn
<
F
>
(
&
mut
self
f
:
F
)
-
>
&
mut
Self
where
F
:
Fn
(
)
-
>
String
+
Send
+
Sync
+
'
static
{
self
.
thread_name
=
std
:
:
sync
:
:
Arc
:
:
new
(
f
)
;
self
}
pub
fn
thread_stack_size
(
&
mut
self
val
:
usize
)
-
>
&
mut
Self
{
self
.
thread_stack_size
=
Some
(
val
)
;
self
}
#
[
cfg
(
not
(
loom
)
)
]
pub
fn
on_thread_start
<
F
>
(
&
mut
self
f
:
F
)
-
>
&
mut
Self
where
F
:
Fn
(
)
+
Send
+
Sync
+
'
static
{
self
.
after_start
=
Some
(
std
:
:
sync
:
:
Arc
:
:
new
(
f
)
)
;
self
}
#
[
cfg
(
not
(
loom
)
)
]
pub
fn
on_thread_stop
<
F
>
(
&
mut
self
f
:
F
)
-
>
&
mut
Self
where
F
:
Fn
(
)
+
Send
+
Sync
+
'
static
{
self
.
before_stop
=
Some
(
std
:
:
sync
:
:
Arc
:
:
new
(
f
)
)
;
self
}
#
[
cfg
(
not
(
loom
)
)
]
pub
fn
on_thread_park
<
F
>
(
&
mut
self
f
:
F
)
-
>
&
mut
Self
where
F
:
Fn
(
)
+
Send
+
Sync
+
'
static
{
self
.
before_park
=
Some
(
std
:
:
sync
:
:
Arc
:
:
new
(
f
)
)
;
self
}
#
[
cfg
(
not
(
loom
)
)
]
pub
fn
on_thread_unpark
<
F
>
(
&
mut
self
f
:
F
)
-
>
&
mut
Self
where
F
:
Fn
(
)
+
Send
+
Sync
+
'
static
{
self
.
after_unpark
=
Some
(
std
:
:
sync
:
:
Arc
:
:
new
(
f
)
)
;
self
}
pub
fn
build
(
&
mut
self
)
-
>
io
:
:
Result
<
Runtime
>
{
match
&
self
.
kind
{
Kind
:
:
CurrentThread
=
>
self
.
build_current_thread_runtime
(
)
#
[
cfg
(
feature
=
"
rt
-
multi
-
thread
"
)
]
Kind
:
:
MultiThread
=
>
self
.
build_threaded_runtime
(
)
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
rt
-
multi
-
thread
"
)
)
]
Kind
:
:
MultiThreadAlt
=
>
self
.
build_alt_threaded_runtime
(
)
}
}
fn
get_cfg
(
&
self
workers
:
usize
)
-
>
driver
:
:
Cfg
{
driver
:
:
Cfg
{
enable_pause_time
:
match
self
.
kind
{
Kind
:
:
CurrentThread
=
>
true
#
[
cfg
(
feature
=
"
rt
-
multi
-
thread
"
)
]
Kind
:
:
MultiThread
=
>
false
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
rt
-
multi
-
thread
"
)
)
]
Kind
:
:
MultiThreadAlt
=
>
false
}
enable_io
:
self
.
enable_io
enable_time
:
self
.
enable_time
start_paused
:
self
.
start_paused
nevents
:
self
.
nevents
workers
}
}
pub
fn
thread_keep_alive
(
&
mut
self
duration
:
Duration
)
-
>
&
mut
Self
{
self
.
keep_alive
=
Some
(
duration
)
;
self
}
#
[
track_caller
]
pub
fn
global_queue_interval
(
&
mut
self
val
:
u32
)
-
>
&
mut
Self
{
assert
!
(
val
>
0
"
global_queue_interval
must
be
greater
than
0
"
)
;
self
.
global_queue_interval
=
Some
(
val
)
;
self
}
pub
fn
event_interval
(
&
mut
self
val
:
u32
)
-
>
&
mut
Self
{
self
.
event_interval
=
val
;
self
}
cfg_unstable
!
{
/
/
/
Configure
how
the
runtime
responds
to
an
unhandled
panic
on
a
/
/
/
spawned
task
.
/
/
/
/
/
/
By
default
an
unhandled
panic
(
i
.
e
.
a
panic
not
caught
by
/
/
/
[
std
:
:
panic
:
:
catch_unwind
]
)
has
no
impact
on
the
runtime
'
s
/
/
/
execution
.
The
panic
'
s
error
value
is
forwarded
to
the
task
'
s
/
/
/
[
JoinHandle
]
and
all
other
spawned
tasks
continue
running
.
/
/
/
/
/
/
The
unhandled_panic
option
enables
configuring
this
behavior
.
/
/
/
/
/
/
*
UnhandledPanic
:
:
Ignore
is
the
default
behavior
.
Panics
on
/
/
/
spawned
tasks
have
no
impact
on
the
runtime
'
s
execution
.
/
/
/
*
UnhandledPanic
:
:
ShutdownRuntime
will
force
the
runtime
to
/
/
/
shutdown
immediately
when
a
spawned
task
panics
even
if
that
/
/
/
task
'
s
JoinHandle
has
not
been
dropped
.
All
other
spawned
tasks
/
/
/
will
immediately
terminate
and
further
calls
to
/
/
/
[
Runtime
:
:
block_on
]
will
panic
.
/
/
/
/
/
/
#
Panics
/
/
/
This
method
panics
if
called
with
[
UnhandledPanic
:
:
ShutdownRuntime
]
/
/
/
on
a
runtime
other
than
the
current
thread
runtime
.
/
/
/
/
/
/
#
Unstable
/
/
/
/
/
/
This
option
is
currently
unstable
and
its
implementation
is
/
/
/
incomplete
.
The
API
may
change
or
be
removed
in
the
future
.
See
/
/
/
issue
[
tokio
-
rs
/
tokio
#
4516
]
for
more
details
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
The
following
demonstrates
a
runtime
configured
to
shutdown
on
/
/
/
panic
.
The
first
spawned
task
panics
and
results
in
the
runtime
/
/
/
shutting
down
.
The
second
spawned
task
never
has
a
chance
to
/
/
/
execute
.
The
call
to
block_on
will
panic
due
to
the
runtime
being
/
/
/
forcibly
shutdown
.
/
/
/
/
/
/
should_panic
/
/
/
use
tokio
:
:
runtime
:
:
{
self
UnhandledPanic
}
;
/
/
/
/
/
/
#
pub
fn
main
(
)
{
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_current_thread
(
)
/
/
/
.
unhandled_panic
(
UnhandledPanic
:
:
ShutdownRuntime
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
/
/
/
rt
.
spawn
(
async
{
panic
!
(
"
boom
"
)
;
}
)
;
/
/
/
rt
.
spawn
(
async
{
/
/
/
/
/
This
task
never
completes
.
/
/
/
}
)
;
/
/
/
/
/
/
rt
.
block_on
(
async
{
/
/
/
/
/
Do
some
work
/
/
/
#
loop
{
tokio
:
:
task
:
:
yield_now
(
)
.
await
;
}
/
/
/
}
)
/
/
/
#
}
/
/
/
/
/
/
/
/
/
[
JoinHandle
]
:
struct
crate
:
:
task
:
:
JoinHandle
/
/
/
[
tokio
-
rs
/
tokio
#
4516
]
:
https
:
/
/
github
.
com
/
tokio
-
rs
/
tokio
/
issues
/
4516
pub
fn
unhandled_panic
(
&
mut
self
behavior
:
UnhandledPanic
)
-
>
&
mut
Self
{
if
!
matches
!
(
self
.
kind
Kind
:
:
CurrentThread
)
&
&
matches
!
(
behavior
UnhandledPanic
:
:
ShutdownRuntime
)
{
panic
!
(
"
UnhandledPanic
:
:
ShutdownRuntime
is
only
supported
in
current
thread
runtime
"
)
;
}
self
.
unhandled_panic
=
behavior
;
self
}
/
/
/
Disables
the
LIFO
task
scheduler
heuristic
.
/
/
/
/
/
/
The
multi
-
threaded
scheduler
includes
a
heuristic
for
optimizing
/
/
/
message
-
passing
patterns
.
This
heuristic
results
in
the
*
*
last
*
*
/
/
/
scheduled
task
being
polled
first
.
/
/
/
/
/
/
To
implement
this
heuristic
each
worker
thread
has
a
slot
which
/
/
/
holds
the
task
that
should
be
polled
next
.
However
this
slot
cannot
/
/
/
be
stolen
by
other
worker
threads
which
can
result
in
lower
total
/
/
/
throughput
when
tasks
tend
to
have
longer
poll
times
.
/
/
/
/
/
/
This
configuration
option
will
disable
this
heuristic
resulting
in
/
/
/
all
scheduled
tasks
being
pushed
into
the
worker
-
local
queue
which
/
/
/
is
stealable
.
/
/
/
/
/
/
Consider
trying
this
option
when
the
task
"
scheduled
"
time
is
high
/
/
/
but
the
runtime
is
underutilized
.
Use
[
tokio
-
rs
/
tokio
-
metrics
]
to
/
/
/
collect
this
data
.
/
/
/
/
/
/
#
Unstable
/
/
/
/
/
/
This
configuration
option
is
considered
a
workaround
for
the
LIFO
/
/
/
slot
not
being
stealable
.
When
the
slot
becomes
stealable
we
will
/
/
/
revisit
whether
or
not
this
option
is
necessary
.
See
/
/
/
issue
[
tokio
-
rs
/
tokio
#
4941
]
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
;
/
/
/
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_multi_thread
(
)
/
/
/
.
disable_lifo_slot
(
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
/
/
/
/
/
/
[
tokio
-
rs
/
tokio
-
metrics
]
:
https
:
/
/
github
.
com
/
tokio
-
rs
/
tokio
-
metrics
/
/
/
[
tokio
-
rs
/
tokio
#
4941
]
:
https
:
/
/
github
.
com
/
tokio
-
rs
/
tokio
/
issues
/
4941
pub
fn
disable_lifo_slot
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
disable_lifo_slot
=
true
;
self
}
/
/
/
Specifies
the
random
number
generation
seed
to
use
within
all
/
/
/
threads
associated
with
the
runtime
being
built
.
/
/
/
/
/
/
This
option
is
intended
to
make
certain
parts
of
the
runtime
/
/
/
deterministic
(
e
.
g
.
the
[
tokio
:
:
select
!
]
macro
)
.
In
the
case
of
/
/
/
[
tokio
:
:
select
!
]
it
will
ensure
that
the
order
that
branches
are
/
/
/
polled
is
deterministic
.
/
/
/
/
/
/
In
addition
to
the
code
specifying
rng_seed
and
interacting
with
/
/
/
the
runtime
the
internals
of
Tokio
and
the
Rust
compiler
may
affect
/
/
/
the
sequences
of
random
numbers
.
In
order
to
ensure
repeatable
/
/
/
results
the
version
of
Tokio
the
versions
of
all
other
/
/
/
dependencies
that
interact
with
Tokio
and
the
Rust
compiler
version
/
/
/
should
also
all
remain
constant
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
#
use
tokio
:
:
runtime
:
:
{
self
RngSeed
}
;
/
/
/
#
pub
fn
main
(
)
{
/
/
/
let
seed
=
RngSeed
:
:
from_bytes
(
b
"
place
your
seed
here
"
)
;
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_current_thread
(
)
/
/
/
.
rng_seed
(
seed
)
/
/
/
.
build
(
)
;
/
/
/
#
}
/
/
/
/
/
/
/
/
/
[
tokio
:
:
select
!
]
:
crate
:
:
select
pub
fn
rng_seed
(
&
mut
self
seed
:
RngSeed
)
-
>
&
mut
Self
{
self
.
seed_generator
=
RngSeedGenerator
:
:
new
(
seed
)
;
self
}
}
cfg_unstable_metrics
!
{
/
/
/
Enables
tracking
the
distribution
of
task
poll
times
.
/
/
/
/
/
/
Task
poll
times
are
not
instrumented
by
default
as
doing
so
requires
/
/
/
calling
[
Instant
:
:
now
(
)
]
twice
per
task
poll
which
could
add
/
/
/
measurable
overhead
.
Use
the
[
Handle
:
:
metrics
(
)
]
to
access
the
/
/
/
metrics
data
.
/
/
/
/
/
/
The
histogram
uses
fixed
bucket
sizes
.
In
other
words
the
histogram
/
/
/
buckets
are
not
dynamic
based
on
input
values
.
Use
the
/
/
/
metrics_poll_count_histogram_
builder
methods
to
configure
the
/
/
/
histogram
details
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
;
/
/
/
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_multi_thread
(
)
/
/
/
.
enable_metrics_poll_count_histogram
(
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
#
/
/
Test
default
values
here
/
/
/
#
fn
us
(
n
:
u64
)
-
>
std
:
:
time
:
:
Duration
{
std
:
:
time
:
:
Duration
:
:
from_micros
(
n
)
}
/
/
/
#
let
m
=
rt
.
handle
(
)
.
metrics
(
)
;
/
/
/
#
assert_eq
!
(
m
.
poll_count_histogram_num_buckets
(
)
10
)
;
/
/
/
#
assert_eq
!
(
m
.
poll_count_histogram_bucket_range
(
0
)
us
(
0
)
.
.
us
(
100
)
)
;
/
/
/
#
assert_eq
!
(
m
.
poll_count_histogram_bucket_range
(
1
)
us
(
100
)
.
.
us
(
200
)
)
;
/
/
/
/
/
/
/
/
/
[
Handle
:
:
metrics
(
)
]
:
crate
:
:
runtime
:
:
Handle
:
:
metrics
/
/
/
[
Instant
:
:
now
(
)
]
:
std
:
:
time
:
:
Instant
:
:
now
pub
fn
enable_metrics_poll_count_histogram
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
metrics_poll_count_histogram_enable
=
true
;
self
}
/
/
/
Sets
the
histogram
scale
for
tracking
the
distribution
of
task
poll
/
/
/
times
.
/
/
/
/
/
/
Tracking
the
distribution
of
task
poll
times
can
be
done
using
a
/
/
/
linear
or
log
scale
.
When
using
linear
scale
each
histogram
bucket
/
/
/
will
represent
the
same
range
of
poll
times
.
When
using
log
scale
/
/
/
each
histogram
bucket
will
cover
a
range
twice
as
big
as
the
/
/
/
previous
bucket
.
/
/
/
/
/
/
*
*
Default
:
*
*
linear
scale
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
:
:
{
self
HistogramScale
}
;
/
/
/
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_multi_thread
(
)
/
/
/
.
enable_metrics_poll_count_histogram
(
)
/
/
/
.
metrics_poll_count_histogram_scale
(
HistogramScale
:
:
Log
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
pub
fn
metrics_poll_count_histogram_scale
(
&
mut
self
histogram_scale
:
crate
:
:
runtime
:
:
HistogramScale
)
-
>
&
mut
Self
{
self
.
metrics_poll_count_histogram
.
scale
=
histogram_scale
;
self
}
/
/
/
Sets
the
histogram
resolution
for
tracking
the
distribution
of
task
/
/
/
poll
times
.
/
/
/
/
/
/
The
resolution
is
the
histogram
'
s
first
bucket
'
s
range
.
When
using
a
/
/
/
linear
histogram
scale
each
bucket
will
cover
the
same
range
.
When
/
/
/
using
a
log
scale
each
bucket
will
cover
a
range
twice
as
big
as
/
/
/
the
previous
bucket
.
In
the
log
case
the
resolution
represents
the
/
/
/
smallest
bucket
range
.
/
/
/
/
/
/
Note
that
when
using
log
scale
the
resolution
is
rounded
up
to
the
/
/
/
nearest
power
of
2
in
nanoseconds
.
/
/
/
/
/
/
*
*
Default
:
*
*
100
microseconds
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
;
/
/
/
use
std
:
:
time
:
:
Duration
;
/
/
/
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_multi_thread
(
)
/
/
/
.
enable_metrics_poll_count_histogram
(
)
/
/
/
.
metrics_poll_count_histogram_resolution
(
Duration
:
:
from_micros
(
100
)
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
pub
fn
metrics_poll_count_histogram_resolution
(
&
mut
self
resolution
:
Duration
)
-
>
&
mut
Self
{
assert
!
(
resolution
>
Duration
:
:
from_secs
(
0
)
)
;
/
/
Sanity
check
the
argument
and
also
make
the
cast
below
safe
.
assert
!
(
resolution
<
=
Duration
:
:
from_secs
(
1
)
)
;
let
resolution
=
resolution
.
as_nanos
(
)
as
u64
;
self
.
metrics_poll_count_histogram
.
resolution
=
resolution
;
self
}
/
/
/
Sets
the
number
of
buckets
for
the
histogram
tracking
the
/
/
/
distribution
of
task
poll
times
.
/
/
/
/
/
/
The
last
bucket
tracks
all
greater
values
that
fall
out
of
other
/
/
/
ranges
.
So
configuring
the
histogram
using
a
linear
scale
/
/
/
resolution
of
50ms
and
10
buckets
the
10th
bucket
will
track
task
/
/
/
polls
that
take
more
than
450ms
to
complete
.
/
/
/
/
/
/
*
*
Default
:
*
*
10
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
;
/
/
/
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_multi_thread
(
)
/
/
/
.
enable_metrics_poll_count_histogram
(
)
/
/
/
.
metrics_poll_count_histogram_buckets
(
15
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
pub
fn
metrics_poll_count_histogram_buckets
(
&
mut
self
buckets
:
usize
)
-
>
&
mut
Self
{
self
.
metrics_poll_count_histogram
.
num_buckets
=
buckets
;
self
}
}
cfg_loom
!
{
pub
(
crate
)
fn
local_queue_capacity
(
&
mut
self
value
:
usize
)
-
>
&
mut
Self
{
assert
!
(
value
.
is_power_of_two
(
)
)
;
self
.
local_queue_capacity
=
value
;
self
}
}
fn
build_current_thread_runtime
(
&
mut
self
)
-
>
io
:
:
Result
<
Runtime
>
{
use
crate
:
:
runtime
:
:
scheduler
:
:
{
self
CurrentThread
}
;
use
crate
:
:
runtime
:
:
{
runtime
:
:
Scheduler
Config
}
;
let
(
driver
driver_handle
)
=
driver
:
:
Driver
:
:
new
(
self
.
get_cfg
(
1
)
)
?
;
let
blocking_pool
=
blocking
:
:
create_blocking_pool
(
self
self
.
max_blocking_threads
)
;
let
blocking_spawner
=
blocking_pool
.
spawner
(
)
.
clone
(
)
;
let
seed_generator_1
=
self
.
seed_generator
.
next_generator
(
)
;
let
seed_generator_2
=
self
.
seed_generator
.
next_generator
(
)
;
let
(
scheduler
handle
)
=
CurrentThread
:
:
new
(
driver
driver_handle
blocking_spawner
seed_generator_2
Config
{
before_park
:
self
.
before_park
.
clone
(
)
after_unpark
:
self
.
after_unpark
.
clone
(
)
global_queue_interval
:
self
.
global_queue_interval
event_interval
:
self
.
event_interval
local_queue_capacity
:
self
.
local_queue_capacity
#
[
cfg
(
tokio_unstable
)
]
unhandled_panic
:
self
.
unhandled_panic
.
clone
(
)
disable_lifo_slot
:
self
.
disable_lifo_slot
seed_generator
:
seed_generator_1
metrics_poll_count_histogram
:
self
.
metrics_poll_count_histogram_builder
(
)
}
)
;
let
handle
=
Handle
{
inner
:
scheduler
:
:
Handle
:
:
CurrentThread
(
handle
)
}
;
Ok
(
Runtime
:
:
from_parts
(
Scheduler
:
:
CurrentThread
(
scheduler
)
handle
blocking_pool
)
)
}
fn
metrics_poll_count_histogram_builder
(
&
self
)
-
>
Option
<
HistogramBuilder
>
{
if
self
.
metrics_poll_count_histogram_enable
{
Some
(
self
.
metrics_poll_count_histogram
.
clone
(
)
)
}
else
{
None
}
}
}
cfg_io_driver
!
{
impl
Builder
{
/
/
/
Enables
the
I
/
O
driver
.
/
/
/
/
/
/
Doing
this
enables
using
net
process
signal
and
some
I
/
O
types
on
/
/
/
the
runtime
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
;
/
/
/
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_multi_thread
(
)
/
/
/
.
enable_io
(
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
pub
fn
enable_io
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
enable_io
=
true
;
self
}
/
/
/
Enables
the
I
/
O
driver
and
configures
the
max
number
of
events
to
be
/
/
/
processed
per
tick
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
;
/
/
/
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_current_thread
(
)
/
/
/
.
enable_io
(
)
/
/
/
.
max_io_events_per_tick
(
1024
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
pub
fn
max_io_events_per_tick
(
&
mut
self
capacity
:
usize
)
-
>
&
mut
Self
{
self
.
nevents
=
capacity
;
self
}
}
}
cfg_time
!
{
impl
Builder
{
/
/
/
Enables
the
time
driver
.
/
/
/
/
/
/
Doing
this
enables
using
tokio
:
:
time
on
the
runtime
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
;
/
/
/
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_multi_thread
(
)
/
/
/
.
enable_time
(
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
pub
fn
enable_time
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
enable_time
=
true
;
self
}
}
}
cfg_test_util
!
{
impl
Builder
{
/
/
/
Controls
if
the
runtime
'
s
clock
starts
paused
or
advancing
.
/
/
/
/
/
/
Pausing
time
requires
the
current
-
thread
runtime
;
construction
of
/
/
/
the
runtime
will
panic
otherwise
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
use
tokio
:
:
runtime
;
/
/
/
/
/
/
let
rt
=
runtime
:
:
Builder
:
:
new_current_thread
(
)
/
/
/
.
enable_time
(
)
/
/
/
.
start_paused
(
true
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
pub
fn
start_paused
(
&
mut
self
start_paused
:
bool
)
-
>
&
mut
Self
{
self
.
start_paused
=
start_paused
;
self
}
}
}
cfg_rt_multi_thread
!
{
impl
Builder
{
fn
build_threaded_runtime
(
&
mut
self
)
-
>
io
:
:
Result
<
Runtime
>
{
use
crate
:
:
loom
:
:
sys
:
:
num_cpus
;
use
crate
:
:
runtime
:
:
{
Config
runtime
:
:
Scheduler
}
;
use
crate
:
:
runtime
:
:
scheduler
:
:
{
self
MultiThread
}
;
let
core_threads
=
self
.
worker_threads
.
unwrap_or_else
(
num_cpus
)
;
let
(
driver
driver_handle
)
=
driver
:
:
Driver
:
:
new
(
self
.
get_cfg
(
core_threads
)
)
?
;
/
/
Create
the
blocking
pool
let
blocking_pool
=
blocking
:
:
create_blocking_pool
(
self
self
.
max_blocking_threads
+
core_threads
)
;
let
blocking_spawner
=
blocking_pool
.
spawner
(
)
.
clone
(
)
;
/
/
Generate
a
rng
seed
for
this
runtime
.
let
seed_generator_1
=
self
.
seed_generator
.
next_generator
(
)
;
let
seed_generator_2
=
self
.
seed_generator
.
next_generator
(
)
;
let
(
scheduler
handle
launch
)
=
MultiThread
:
:
new
(
core_threads
driver
driver_handle
blocking_spawner
seed_generator_2
Config
{
before_park
:
self
.
before_park
.
clone
(
)
after_unpark
:
self
.
after_unpark
.
clone
(
)
global_queue_interval
:
self
.
global_queue_interval
event_interval
:
self
.
event_interval
local_queue_capacity
:
self
.
local_queue_capacity
#
[
cfg
(
tokio_unstable
)
]
unhandled_panic
:
self
.
unhandled_panic
.
clone
(
)
disable_lifo_slot
:
self
.
disable_lifo_slot
seed_generator
:
seed_generator_1
metrics_poll_count_histogram
:
self
.
metrics_poll_count_histogram_builder
(
)
}
)
;
let
handle
=
Handle
{
inner
:
scheduler
:
:
Handle
:
:
MultiThread
(
handle
)
}
;
/
/
Spawn
the
thread
pool
workers
let
_enter
=
handle
.
enter
(
)
;
launch
.
launch
(
)
;
Ok
(
Runtime
:
:
from_parts
(
Scheduler
:
:
MultiThread
(
scheduler
)
handle
blocking_pool
)
)
}
cfg_unstable
!
{
fn
build_alt_threaded_runtime
(
&
mut
self
)
-
>
io
:
:
Result
<
Runtime
>
{
use
crate
:
:
loom
:
:
sys
:
:
num_cpus
;
use
crate
:
:
runtime
:
:
{
Config
runtime
:
:
Scheduler
}
;
use
crate
:
:
runtime
:
:
scheduler
:
:
MultiThreadAlt
;
let
core_threads
=
self
.
worker_threads
.
unwrap_or_else
(
num_cpus
)
;
let
(
driver
driver_handle
)
=
driver
:
:
Driver
:
:
new
(
self
.
get_cfg
(
core_threads
)
)
?
;
/
/
Create
the
blocking
pool
let
blocking_pool
=
blocking
:
:
create_blocking_pool
(
self
self
.
max_blocking_threads
+
core_threads
)
;
let
blocking_spawner
=
blocking_pool
.
spawner
(
)
.
clone
(
)
;
/
/
Generate
a
rng
seed
for
this
runtime
.
let
seed_generator_1
=
self
.
seed_generator
.
next_generator
(
)
;
let
seed_generator_2
=
self
.
seed_generator
.
next_generator
(
)
;
let
(
scheduler
handle
)
=
MultiThreadAlt
:
:
new
(
core_threads
driver
driver_handle
blocking_spawner
seed_generator_2
Config
{
before_park
:
self
.
before_park
.
clone
(
)
after_unpark
:
self
.
after_unpark
.
clone
(
)
global_queue_interval
:
self
.
global_queue_interval
event_interval
:
self
.
event_interval
local_queue_capacity
:
self
.
local_queue_capacity
#
[
cfg
(
tokio_unstable
)
]
unhandled_panic
:
self
.
unhandled_panic
.
clone
(
)
disable_lifo_slot
:
self
.
disable_lifo_slot
seed_generator
:
seed_generator_1
metrics_poll_count_histogram
:
self
.
metrics_poll_count_histogram_builder
(
)
}
)
;
Ok
(
Runtime
:
:
from_parts
(
Scheduler
:
:
MultiThreadAlt
(
scheduler
)
handle
blocking_pool
)
)
}
}
}
}
impl
fmt
:
:
Debug
for
Builder
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Builder
"
)
.
field
(
"
worker_threads
"
&
self
.
worker_threads
)
.
field
(
"
max_blocking_threads
"
&
self
.
max_blocking_threads
)
.
field
(
"
thread_name
"
&
"
<
dyn
Fn
(
)
-
>
String
+
Send
+
Sync
+
'
static
>
"
)
.
field
(
"
thread_stack_size
"
&
self
.
thread_stack_size
)
.
field
(
"
after_start
"
&
self
.
after_start
.
as_ref
(
)
.
map
(
|
_
|
"
.
.
.
"
)
)
.
field
(
"
before_stop
"
&
self
.
before_stop
.
as_ref
(
)
.
map
(
|
_
|
"
.
.
.
"
)
)
.
field
(
"
before_park
"
&
self
.
before_park
.
as_ref
(
)
.
map
(
|
_
|
"
.
.
.
"
)
)
.
field
(
"
after_unpark
"
&
self
.
after_unpark
.
as_ref
(
)
.
map
(
|
_
|
"
.
.
.
"
)
)
.
finish
(
)
}
}
