use
crate
:
:
runtime
:
:
blocking
:
:
{
BlockingTask
NoopSchedule
}
;
use
crate
:
:
runtime
:
:
task
:
:
{
self
JoinHandle
}
;
use
crate
:
:
runtime
:
:
{
blocking
context
driver
Spawner
}
;
use
crate
:
:
util
:
:
error
:
:
{
CONTEXT_MISSING_ERROR
THREAD_LOCAL_DESTROYED_ERROR
}
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
{
error
fmt
}
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
Handle
{
pub
(
super
)
spawner
:
Spawner
#
[
cfg_attr
(
not
(
any
(
feature
=
"
net
"
feature
=
"
process
"
all
(
unix
feature
=
"
signal
"
)
)
)
allow
(
dead_code
)
)
]
pub
(
super
)
io_handle
:
driver
:
:
IoHandle
#
[
cfg_attr
(
any
(
loom
not
(
all
(
unix
feature
=
"
signal
"
)
)
not
(
all
(
unix
feature
=
"
process
"
)
)
)
allow
(
dead_code
)
)
]
pub
(
super
)
signal_handle
:
driver
:
:
SignalHandle
#
[
cfg_attr
(
not
(
feature
=
"
time
"
)
allow
(
dead_code
)
)
]
pub
(
super
)
time_handle
:
driver
:
:
TimeHandle
#
[
cfg_attr
(
not
(
all
(
feature
=
"
time
"
feature
=
"
test
-
util
"
)
)
allow
(
dead_code
)
)
]
pub
(
super
)
clock
:
driver
:
:
Clock
pub
(
super
)
blocking_spawner
:
blocking
:
:
Spawner
}
#
[
derive
(
Debug
)
]
#
[
must_use
=
"
Creating
and
dropping
a
guard
does
nothing
"
]
pub
struct
EnterGuard
<
'
a
>
{
_guard
:
context
:
:
EnterGuard
_handle_lifetime
:
PhantomData
<
&
'
a
Handle
>
}
impl
Handle
{
pub
fn
enter
(
&
self
)
-
>
EnterGuard
<
'
_
>
{
EnterGuard
{
_guard
:
context
:
:
enter
(
self
.
clone
(
)
)
_handle_lifetime
:
PhantomData
}
}
pub
fn
current
(
)
-
>
Self
{
context
:
:
current
(
)
}
pub
fn
try_current
(
)
-
>
Result
<
Self
TryCurrentError
>
{
context
:
:
try_current
(
)
}
#
[
track_caller
]
pub
fn
spawn
<
F
>
(
&
self
future
:
F
)
-
>
JoinHandle
<
F
:
:
Output
>
where
F
:
Future
+
Send
+
'
static
F
:
:
Output
:
Send
+
'
static
{
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
future
=
crate
:
:
util
:
:
trace
:
:
task
(
future
"
task
"
None
)
;
self
.
spawner
.
spawn
(
future
)
}
#
[
track_caller
]
pub
fn
spawn_blocking
<
F
R
>
(
&
self
func
:
F
)
-
>
JoinHandle
<
R
>
where
F
:
FnOnce
(
)
-
>
R
+
Send
+
'
static
R
:
Send
+
'
static
{
let
(
join_handle
_was_spawned
)
=
if
cfg
!
(
debug_assertions
)
&
&
std
:
:
mem
:
:
size_of
:
:
<
F
>
(
)
>
2048
{
self
.
spawn_blocking_inner
(
Box
:
:
new
(
func
)
blocking
:
:
Mandatory
:
:
NonMandatory
None
)
}
else
{
self
.
spawn_blocking_inner
(
func
blocking
:
:
Mandatory
:
:
NonMandatory
None
)
}
;
join_handle
}
cfg_fs
!
{
#
[
track_caller
]
#
[
cfg_attr
(
any
(
all
(
loom
not
(
test
)
)
/
/
the
function
is
covered
by
loom
tests
test
)
allow
(
dead_code
)
)
]
pub
(
crate
)
fn
spawn_mandatory_blocking
<
F
R
>
(
&
self
func
:
F
)
-
>
Option
<
JoinHandle
<
R
>
>
where
F
:
FnOnce
(
)
-
>
R
+
Send
+
'
static
R
:
Send
+
'
static
{
let
(
join_handle
was_spawned
)
=
if
cfg
!
(
debug_assertions
)
&
&
std
:
:
mem
:
:
size_of
:
:
<
F
>
(
)
>
2048
{
self
.
spawn_blocking_inner
(
Box
:
:
new
(
func
)
blocking
:
:
Mandatory
:
:
Mandatory
None
)
}
else
{
self
.
spawn_blocking_inner
(
func
blocking
:
:
Mandatory
:
:
Mandatory
None
)
}
;
if
was_spawned
{
Some
(
join_handle
)
}
else
{
None
}
}
}
#
[
track_caller
]
pub
(
crate
)
fn
spawn_blocking_inner
<
F
R
>
(
&
self
func
:
F
is_mandatory
:
blocking
:
:
Mandatory
name
:
Option
<
&
str
>
)
-
>
(
JoinHandle
<
R
>
bool
)
where
F
:
FnOnce
(
)
-
>
R
+
Send
+
'
static
R
:
Send
+
'
static
{
let
fut
=
BlockingTask
:
:
new
(
func
)
;
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
fut
=
{
use
tracing
:
:
Instrument
;
let
location
=
std
:
:
panic
:
:
Location
:
:
caller
(
)
;
let
span
=
tracing
:
:
trace_span
!
(
target
:
"
tokio
:
:
task
:
:
blocking
"
"
runtime
.
spawn
"
kind
=
%
"
blocking
"
task
.
name
=
%
name
.
unwrap_or_default
(
)
"
fn
"
=
%
std
:
:
any
:
:
type_name
:
:
<
F
>
(
)
spawn
.
location
=
%
format_args
!
(
"
{
}
:
{
}
:
{
}
"
location
.
file
(
)
location
.
line
(
)
location
.
column
(
)
)
)
;
fut
.
instrument
(
span
)
}
;
#
[
cfg
(
not
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
)
]
let
_
=
name
;
let
(
task
handle
)
=
task
:
:
unowned
(
fut
NoopSchedule
)
;
let
spawned
=
self
.
blocking_spawner
.
spawn
(
blocking
:
:
Task
:
:
new
(
task
is_mandatory
)
self
)
;
(
handle
spawned
.
is_ok
(
)
)
}
#
[
track_caller
]
pub
fn
block_on
<
F
:
Future
>
(
&
self
future
:
F
)
-
>
F
:
:
Output
{
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
future
=
crate
:
:
util
:
:
trace
:
:
task
(
future
"
block_on
"
None
)
;
let
_rt_enter
=
self
.
enter
(
)
;
let
mut
blocking_enter
=
crate
:
:
runtime
:
:
enter
(
true
)
;
blocking_enter
.
block_on
(
future
)
.
expect
(
"
failed
to
park
thread
"
)
}
pub
(
crate
)
fn
shutdown
(
mut
self
)
{
self
.
spawner
.
shutdown
(
)
;
}
}
cfg_metrics
!
{
use
crate
:
:
runtime
:
:
RuntimeMetrics
;
impl
Handle
{
/
/
/
Returns
a
view
that
lets
you
get
information
about
how
the
runtime
/
/
/
is
performing
.
pub
fn
metrics
(
&
self
)
-
>
RuntimeMetrics
{
RuntimeMetrics
:
:
new
(
self
.
clone
(
)
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
TryCurrentError
{
kind
:
TryCurrentErrorKind
}
impl
TryCurrentError
{
pub
(
crate
)
fn
new_no_context
(
)
-
>
Self
{
Self
{
kind
:
TryCurrentErrorKind
:
:
NoContext
}
}
pub
(
crate
)
fn
new_thread_local_destroyed
(
)
-
>
Self
{
Self
{
kind
:
TryCurrentErrorKind
:
:
ThreadLocalDestroyed
}
}
pub
fn
is_missing_context
(
&
self
)
-
>
bool
{
matches
!
(
self
.
kind
TryCurrentErrorKind
:
:
NoContext
)
}
pub
fn
is_thread_local_destroyed
(
&
self
)
-
>
bool
{
matches
!
(
self
.
kind
TryCurrentErrorKind
:
:
ThreadLocalDestroyed
)
}
}
enum
TryCurrentErrorKind
{
NoContext
ThreadLocalDestroyed
}
impl
fmt
:
:
Debug
for
TryCurrentErrorKind
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
use
TryCurrentErrorKind
:
:
*
;
match
self
{
NoContext
=
>
f
.
write_str
(
"
NoContext
"
)
ThreadLocalDestroyed
=
>
f
.
write_str
(
"
ThreadLocalDestroyed
"
)
}
}
}
impl
fmt
:
:
Display
for
TryCurrentError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
use
TryCurrentErrorKind
:
:
*
;
match
self
.
kind
{
NoContext
=
>
f
.
write_str
(
CONTEXT_MISSING_ERROR
)
ThreadLocalDestroyed
=
>
f
.
write_str
(
THREAD_LOCAL_DESTROYED_ERROR
)
}
}
}
impl
error
:
:
Error
for
TryCurrentError
{
}
