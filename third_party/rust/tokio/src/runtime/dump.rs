use
crate
:
:
task
:
:
Id
;
use
std
:
:
{
fmt
future
:
:
Future
path
:
:
Path
}
;
pub
use
crate
:
:
runtime
:
:
task
:
:
trace
:
:
Root
;
#
[
derive
(
Debug
)
]
pub
struct
Dump
{
tasks
:
Tasks
}
#
[
derive
(
Debug
)
]
pub
struct
Tasks
{
tasks
:
Vec
<
Task
>
}
#
[
derive
(
Debug
)
]
pub
struct
Task
{
id
:
Id
trace
:
Trace
}
#
[
derive
(
Copy
Clone
Debug
)
]
struct
Address
(
*
mut
std
:
:
ffi
:
:
c_void
)
;
unsafe
impl
Send
for
Address
{
}
unsafe
impl
Sync
for
Address
{
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
BacktraceSymbol
{
name
:
Option
<
Box
<
[
u8
]
>
>
name_demangled
:
Option
<
Box
<
str
>
>
addr
:
Option
<
Address
>
filename
:
Option
<
std
:
:
path
:
:
PathBuf
>
lineno
:
Option
<
u32
>
colno
:
Option
<
u32
>
}
impl
BacktraceSymbol
{
pub
(
crate
)
fn
from_backtrace_symbol
(
sym
:
&
backtrace
:
:
BacktraceSymbol
)
-
>
Self
{
let
name
=
sym
.
name
(
)
;
Self
{
name
:
name
.
as_ref
(
)
.
map
(
|
name
|
name
.
as_bytes
(
)
.
into
(
)
)
name_demangled
:
name
.
map
(
|
name
|
format
!
(
"
{
}
"
name
)
.
into
(
)
)
addr
:
sym
.
addr
(
)
.
map
(
Address
)
filename
:
sym
.
filename
(
)
.
map
(
From
:
:
from
)
lineno
:
sym
.
lineno
(
)
colno
:
sym
.
colno
(
)
}
}
pub
fn
name_raw
(
&
self
)
-
>
Option
<
&
[
u8
]
>
{
self
.
name
.
as_deref
(
)
}
pub
fn
name_demangled
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
name_demangled
.
as_deref
(
)
}
pub
fn
addr
(
&
self
)
-
>
Option
<
*
mut
std
:
:
ffi
:
:
c_void
>
{
self
.
addr
.
map
(
|
addr
|
addr
.
0
)
}
pub
fn
filename
(
&
self
)
-
>
Option
<
&
Path
>
{
self
.
filename
.
as_deref
(
)
}
pub
fn
lineno
(
&
self
)
-
>
Option
<
u32
>
{
self
.
lineno
}
pub
fn
colno
(
&
self
)
-
>
Option
<
u32
>
{
self
.
colno
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
BacktraceFrame
{
ip
:
Address
symbol_address
:
Address
symbols
:
Box
<
[
BacktraceSymbol
]
>
}
impl
BacktraceFrame
{
pub
(
crate
)
fn
from_resolved_backtrace_frame
(
frame
:
&
backtrace
:
:
BacktraceFrame
)
-
>
Self
{
Self
{
ip
:
Address
(
frame
.
ip
(
)
)
symbol_address
:
Address
(
frame
.
symbol_address
(
)
)
symbols
:
frame
.
symbols
(
)
.
iter
(
)
.
map
(
BacktraceSymbol
:
:
from_backtrace_symbol
)
.
collect
(
)
}
}
pub
fn
ip
(
&
self
)
-
>
*
mut
std
:
:
ffi
:
:
c_void
{
self
.
ip
.
0
}
pub
fn
symbol_address
(
&
self
)
-
>
*
mut
std
:
:
ffi
:
:
c_void
{
self
.
symbol_address
.
0
}
pub
fn
symbols
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
BacktraceSymbol
>
{
self
.
symbols
.
iter
(
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Backtrace
{
frames
:
Box
<
[
BacktraceFrame
]
>
}
impl
Backtrace
{
pub
fn
frames
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
BacktraceFrame
>
{
self
.
frames
.
iter
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Trace
{
inner
:
super
:
:
task
:
:
trace
:
:
Trace
}
impl
Trace
{
pub
fn
resolve_backtraces
(
&
self
)
-
>
Vec
<
Backtrace
>
{
self
.
inner
.
backtraces
(
)
.
iter
(
)
.
map
(
|
backtrace
|
{
let
mut
backtrace
=
backtrace
:
:
Backtrace
:
:
from
(
backtrace
.
clone
(
)
)
;
backtrace
.
resolve
(
)
;
Backtrace
{
frames
:
backtrace
.
frames
(
)
.
iter
(
)
.
map
(
BacktraceFrame
:
:
from_resolved_backtrace_frame
)
.
collect
(
)
}
}
)
.
collect
(
)
}
pub
fn
capture
<
F
R
>
(
f
:
F
)
-
>
(
R
Trace
)
where
F
:
FnOnce
(
)
-
>
R
{
let
(
res
trace
)
=
super
:
:
task
:
:
trace
:
:
Trace
:
:
capture
(
f
)
;
(
res
Trace
{
inner
:
trace
}
)
}
pub
fn
root
<
F
>
(
f
:
F
)
-
>
Root
<
F
>
where
F
:
Future
{
crate
:
:
runtime
:
:
task
:
:
trace
:
:
Trace
:
:
root
(
f
)
}
}
impl
Dump
{
pub
(
crate
)
fn
new
(
tasks
:
Vec
<
Task
>
)
-
>
Self
{
Self
{
tasks
:
Tasks
{
tasks
}
}
}
pub
fn
tasks
(
&
self
)
-
>
&
Tasks
{
&
self
.
tasks
}
}
impl
Tasks
{
pub
fn
iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Task
>
{
self
.
tasks
.
iter
(
)
}
}
impl
Task
{
pub
(
crate
)
fn
new
(
id
:
Id
trace
:
super
:
:
task
:
:
trace
:
:
Trace
)
-
>
Self
{
Self
{
id
trace
:
Trace
{
inner
:
trace
}
}
}
#
[
cfg
(
tokio_unstable
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
tokio_unstable
)
)
)
]
pub
fn
id
(
&
self
)
-
>
Id
{
self
.
id
}
pub
fn
trace
(
&
self
)
-
>
&
Trace
{
&
self
.
trace
}
}
impl
fmt
:
:
Display
for
Trace
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
inner
.
fmt
(
f
)
}
}
