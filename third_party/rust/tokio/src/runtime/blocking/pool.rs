use
crate
:
:
loom
:
:
sync
:
:
{
Arc
Condvar
Mutex
}
;
use
crate
:
:
loom
:
:
thread
;
use
crate
:
:
runtime
:
:
blocking
:
:
schedule
:
:
NoopSchedule
;
use
crate
:
:
runtime
:
:
blocking
:
:
shutdown
;
use
crate
:
:
runtime
:
:
builder
:
:
ThreadNameFn
;
use
crate
:
:
runtime
:
:
context
;
use
crate
:
:
runtime
:
:
task
:
:
{
self
JoinHandle
}
;
use
crate
:
:
runtime
:
:
{
Builder
Callback
Handle
}
;
use
std
:
:
collections
:
:
{
HashMap
VecDeque
}
;
use
std
:
:
fmt
;
use
std
:
:
time
:
:
Duration
;
pub
(
crate
)
struct
BlockingPool
{
spawner
:
Spawner
shutdown_rx
:
shutdown
:
:
Receiver
}
#
[
derive
(
Clone
)
]
pub
(
crate
)
struct
Spawner
{
inner
:
Arc
<
Inner
>
}
struct
Inner
{
shared
:
Mutex
<
Shared
>
condvar
:
Condvar
thread_name
:
ThreadNameFn
stack_size
:
Option
<
usize
>
after_start
:
Option
<
Callback
>
before_stop
:
Option
<
Callback
>
thread_cap
:
usize
keep_alive
:
Duration
}
struct
Shared
{
queue
:
VecDeque
<
Task
>
num_th
:
usize
num_idle
:
u32
num_notify
:
u32
shutdown
:
bool
shutdown_tx
:
Option
<
shutdown
:
:
Sender
>
last_exiting_thread
:
Option
<
thread
:
:
JoinHandle
<
(
)
>
>
worker_threads
:
HashMap
<
usize
thread
:
:
JoinHandle
<
(
)
>
>
worker_thread_index
:
usize
}
pub
(
crate
)
struct
Task
{
task
:
task
:
:
UnownedTask
<
NoopSchedule
>
mandatory
:
Mandatory
}
#
[
derive
(
PartialEq
Eq
)
]
pub
(
crate
)
enum
Mandatory
{
#
[
cfg_attr
(
not
(
fs
)
allow
(
dead_code
)
)
]
Mandatory
NonMandatory
}
impl
Task
{
pub
(
crate
)
fn
new
(
task
:
task
:
:
UnownedTask
<
NoopSchedule
>
mandatory
:
Mandatory
)
-
>
Task
{
Task
{
task
mandatory
}
}
fn
run
(
self
)
{
self
.
task
.
run
(
)
;
}
fn
shutdown_or_run_if_mandatory
(
self
)
{
match
self
.
mandatory
{
Mandatory
:
:
NonMandatory
=
>
self
.
task
.
shutdown
(
)
Mandatory
:
:
Mandatory
=
>
self
.
task
.
run
(
)
}
}
}
const
KEEP_ALIVE
:
Duration
=
Duration
:
:
from_secs
(
10
)
;
pub
(
crate
)
fn
spawn_blocking
<
F
R
>
(
func
:
F
)
-
>
JoinHandle
<
R
>
where
F
:
FnOnce
(
)
-
>
R
+
Send
+
'
static
R
:
Send
+
'
static
{
let
rt
=
context
:
:
current
(
)
;
rt
.
spawn_blocking
(
func
)
}
cfg_fs
!
{
#
[
cfg_attr
(
any
(
all
(
loom
not
(
test
)
)
/
/
the
function
is
covered
by
loom
tests
test
)
allow
(
dead_code
)
)
]
/
/
/
Runs
the
provided
function
on
an
executor
dedicated
to
blocking
/
/
/
operations
.
Tasks
will
be
scheduled
as
mandatory
meaning
they
are
/
/
/
guaranteed
to
run
unless
a
shutdown
is
already
taking
place
.
In
case
a
/
/
/
shutdown
is
already
taking
place
None
will
be
returned
.
pub
(
crate
)
fn
spawn_mandatory_blocking
<
F
R
>
(
func
:
F
)
-
>
Option
<
JoinHandle
<
R
>
>
where
F
:
FnOnce
(
)
-
>
R
+
Send
+
'
static
R
:
Send
+
'
static
{
let
rt
=
context
:
:
current
(
)
;
rt
.
spawn_mandatory_blocking
(
func
)
}
}
impl
BlockingPool
{
pub
(
crate
)
fn
new
(
builder
:
&
Builder
thread_cap
:
usize
)
-
>
BlockingPool
{
let
(
shutdown_tx
shutdown_rx
)
=
shutdown
:
:
channel
(
)
;
let
keep_alive
=
builder
.
keep_alive
.
unwrap_or
(
KEEP_ALIVE
)
;
BlockingPool
{
spawner
:
Spawner
{
inner
:
Arc
:
:
new
(
Inner
{
shared
:
Mutex
:
:
new
(
Shared
{
queue
:
VecDeque
:
:
new
(
)
num_th
:
0
num_idle
:
0
num_notify
:
0
shutdown
:
false
shutdown_tx
:
Some
(
shutdown_tx
)
last_exiting_thread
:
None
worker_threads
:
HashMap
:
:
new
(
)
worker_thread_index
:
0
}
)
condvar
:
Condvar
:
:
new
(
)
thread_name
:
builder
.
thread_name
.
clone
(
)
stack_size
:
builder
.
thread_stack_size
after_start
:
builder
.
after_start
.
clone
(
)
before_stop
:
builder
.
before_stop
.
clone
(
)
thread_cap
keep_alive
}
)
}
shutdown_rx
}
}
pub
(
crate
)
fn
spawner
(
&
self
)
-
>
&
Spawner
{
&
self
.
spawner
}
pub
(
crate
)
fn
shutdown
(
&
mut
self
timeout
:
Option
<
Duration
>
)
{
let
mut
shared
=
self
.
spawner
.
inner
.
shared
.
lock
(
)
;
if
shared
.
shutdown
{
return
;
}
shared
.
shutdown
=
true
;
shared
.
shutdown_tx
=
None
;
self
.
spawner
.
inner
.
condvar
.
notify_all
(
)
;
let
last_exited_thread
=
std
:
:
mem
:
:
take
(
&
mut
shared
.
last_exiting_thread
)
;
let
workers
=
std
:
:
mem
:
:
take
(
&
mut
shared
.
worker_threads
)
;
drop
(
shared
)
;
if
self
.
shutdown_rx
.
wait
(
timeout
)
{
let
_
=
last_exited_thread
.
map
(
|
th
|
th
.
join
(
)
)
;
let
mut
workers
:
Vec
<
(
usize
thread
:
:
JoinHandle
<
(
)
>
)
>
=
workers
.
into_iter
(
)
.
collect
(
)
;
workers
.
sort_by_key
(
|
(
id
_
)
|
*
id
)
;
for
(
_id
handle
)
in
workers
.
into_iter
(
)
{
let
_
=
handle
.
join
(
)
;
}
}
}
}
impl
Drop
for
BlockingPool
{
fn
drop
(
&
mut
self
)
{
self
.
shutdown
(
None
)
;
}
}
impl
fmt
:
:
Debug
for
BlockingPool
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
BlockingPool
"
)
.
finish
(
)
}
}
impl
Spawner
{
pub
(
crate
)
fn
spawn
(
&
self
task
:
Task
rt
:
&
Handle
)
-
>
Result
<
(
)
(
)
>
{
let
mut
shared
=
self
.
inner
.
shared
.
lock
(
)
;
if
shared
.
shutdown
{
task
.
task
.
shutdown
(
)
;
return
Err
(
(
)
)
;
}
shared
.
queue
.
push_back
(
task
)
;
if
shared
.
num_idle
=
=
0
{
if
shared
.
num_th
=
=
self
.
inner
.
thread_cap
{
}
else
{
shared
.
num_th
+
=
1
;
assert
!
(
shared
.
shutdown_tx
.
is_some
(
)
)
;
let
shutdown_tx
=
shared
.
shutdown_tx
.
clone
(
)
;
if
let
Some
(
shutdown_tx
)
=
shutdown_tx
{
let
id
=
shared
.
worker_thread_index
;
shared
.
worker_thread_index
+
=
1
;
let
handle
=
self
.
spawn_thread
(
shutdown_tx
rt
id
)
;
shared
.
worker_threads
.
insert
(
id
handle
)
;
}
}
}
else
{
shared
.
num_idle
-
=
1
;
shared
.
num_notify
+
=
1
;
self
.
inner
.
condvar
.
notify_one
(
)
;
}
Ok
(
(
)
)
}
fn
spawn_thread
(
&
self
shutdown_tx
:
shutdown
:
:
Sender
rt
:
&
Handle
id
:
usize
)
-
>
thread
:
:
JoinHandle
<
(
)
>
{
let
mut
builder
=
thread
:
:
Builder
:
:
new
(
)
.
name
(
(
self
.
inner
.
thread_name
)
(
)
)
;
if
let
Some
(
stack_size
)
=
self
.
inner
.
stack_size
{
builder
=
builder
.
stack_size
(
stack_size
)
;
}
let
rt
=
rt
.
clone
(
)
;
builder
.
spawn
(
move
|
|
{
let
_enter
=
crate
:
:
runtime
:
:
context
:
:
enter
(
rt
.
clone
(
)
)
;
rt
.
blocking_spawner
.
inner
.
run
(
id
)
;
drop
(
shutdown_tx
)
;
}
)
.
expect
(
"
OS
can
'
t
spawn
a
new
worker
thread
"
)
}
}
impl
Inner
{
fn
run
(
&
self
worker_thread_id
:
usize
)
{
if
let
Some
(
f
)
=
&
self
.
after_start
{
f
(
)
}
let
mut
shared
=
self
.
shared
.
lock
(
)
;
let
mut
join_on_thread
=
None
;
'
main
:
loop
{
while
let
Some
(
task
)
=
shared
.
queue
.
pop_front
(
)
{
drop
(
shared
)
;
task
.
run
(
)
;
shared
=
self
.
shared
.
lock
(
)
;
}
shared
.
num_idle
+
=
1
;
while
!
shared
.
shutdown
{
let
lock_result
=
self
.
condvar
.
wait_timeout
(
shared
self
.
keep_alive
)
.
unwrap
(
)
;
shared
=
lock_result
.
0
;
let
timeout_result
=
lock_result
.
1
;
if
shared
.
num_notify
!
=
0
{
shared
.
num_notify
-
=
1
;
break
;
}
if
!
shared
.
shutdown
&
&
timeout_result
.
timed_out
(
)
{
let
my_handle
=
shared
.
worker_threads
.
remove
(
&
worker_thread_id
)
;
join_on_thread
=
std
:
:
mem
:
:
replace
(
&
mut
shared
.
last_exiting_thread
my_handle
)
;
break
'
main
;
}
}
if
shared
.
shutdown
{
while
let
Some
(
task
)
=
shared
.
queue
.
pop_front
(
)
{
drop
(
shared
)
;
task
.
shutdown_or_run_if_mandatory
(
)
;
shared
=
self
.
shared
.
lock
(
)
;
}
shared
.
num_idle
+
=
1
;
break
;
}
}
shared
.
num_th
-
=
1
;
shared
.
num_idle
=
shared
.
num_idle
.
checked_sub
(
1
)
.
expect
(
"
num_idle
underflowed
on
thread
exit
"
)
;
if
shared
.
shutdown
&
&
shared
.
num_th
=
=
0
{
self
.
condvar
.
notify_one
(
)
;
}
drop
(
shared
)
;
if
let
Some
(
f
)
=
&
self
.
before_stop
{
f
(
)
}
if
let
Some
(
handle
)
=
join_on_thread
{
let
_
=
handle
.
join
(
)
;
}
}
}
impl
fmt
:
:
Debug
for
Spawner
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
blocking
:
:
Spawner
"
)
.
finish
(
)
}
}
