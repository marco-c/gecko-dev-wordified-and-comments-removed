use
crate
:
:
loom
:
:
sync
:
:
Arc
;
use
crate
:
:
sync
:
:
oneshot
;
use
std
:
:
time
:
:
Duration
;
#
[
derive
(
Debug
Clone
)
]
pub
(
super
)
struct
Sender
{
tx
:
Arc
<
oneshot
:
:
Sender
<
(
)
>
>
}
#
[
derive
(
Debug
)
]
pub
(
super
)
struct
Receiver
{
rx
:
oneshot
:
:
Receiver
<
(
)
>
}
pub
(
super
)
fn
channel
(
)
-
>
(
Sender
Receiver
)
{
let
(
tx
rx
)
=
oneshot
:
:
channel
(
)
;
let
tx
=
Sender
{
tx
:
Arc
:
:
new
(
tx
)
}
;
let
rx
=
Receiver
{
rx
}
;
(
tx
rx
)
}
impl
Receiver
{
pub
(
crate
)
fn
wait
(
&
mut
self
timeout
:
Option
<
Duration
>
)
-
>
bool
{
use
crate
:
:
runtime
:
:
enter
:
:
try_enter
;
if
timeout
=
=
Some
(
Duration
:
:
from_nanos
(
0
)
)
{
return
true
;
}
let
mut
e
=
match
try_enter
(
false
)
{
Some
(
enter
)
=
>
enter
_
=
>
{
if
std
:
:
thread
:
:
panicking
(
)
{
return
false
;
}
else
{
panic
!
(
"
Cannot
drop
a
runtime
in
a
context
where
blocking
is
not
allowed
.
\
This
happens
when
a
runtime
is
dropped
from
within
an
asynchronous
context
.
"
)
;
}
}
}
;
if
let
Some
(
timeout
)
=
timeout
{
e
.
block_on_timeout
(
&
mut
self
.
rx
timeout
)
.
is_ok
(
)
}
else
{
let
_
=
e
.
block_on
(
&
mut
self
.
rx
)
;
true
}
}
}
