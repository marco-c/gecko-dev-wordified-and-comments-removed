#
!
[
cfg_attr
(
any
(
loom
not
(
feature
=
"
sync
"
)
)
allow
(
dead_code
unreachable_pub
)
)
]
use
crate
:
:
loom
:
:
cell
:
:
UnsafeCell
;
use
crate
:
:
loom
:
:
hint
;
use
crate
:
:
loom
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
std
:
:
fmt
;
use
std
:
:
panic
:
:
{
resume_unwind
AssertUnwindSafe
RefUnwindSafe
UnwindSafe
}
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
AcqRel
Acquire
Release
}
;
use
std
:
:
task
:
:
Waker
;
pub
(
crate
)
struct
AtomicWaker
{
state
:
AtomicUsize
waker
:
UnsafeCell
<
Option
<
Waker
>
>
}
impl
RefUnwindSafe
for
AtomicWaker
{
}
impl
UnwindSafe
for
AtomicWaker
{
}
const
WAITING
:
usize
=
0
;
const
REGISTERING
:
usize
=
0b01
;
const
WAKING
:
usize
=
0b10
;
impl
AtomicWaker
{
pub
(
crate
)
fn
new
(
)
-
>
AtomicWaker
{
AtomicWaker
{
state
:
AtomicUsize
:
:
new
(
WAITING
)
waker
:
UnsafeCell
:
:
new
(
None
)
}
}
pub
(
crate
)
fn
register_by_ref
(
&
self
waker
:
&
Waker
)
{
self
.
do_register
(
waker
)
;
}
fn
do_register
<
W
>
(
&
self
waker
:
W
)
where
W
:
WakerRef
{
fn
catch_unwind
<
F
:
FnOnce
(
)
-
>
R
R
>
(
f
:
F
)
-
>
std
:
:
thread
:
:
Result
<
R
>
{
std
:
:
panic
:
:
catch_unwind
(
AssertUnwindSafe
(
f
)
)
}
match
self
.
state
.
compare_exchange
(
WAITING
REGISTERING
Acquire
Acquire
)
.
unwrap_or_else
(
|
x
|
x
)
{
WAITING
=
>
{
unsafe
{
let
new_waker_or_panic
=
catch_unwind
(
move
|
|
waker
.
into_waker
(
)
)
;
let
mut
maybe_panic
=
None
;
let
mut
old_waker
=
None
;
match
new_waker_or_panic
{
Ok
(
new_waker
)
=
>
{
old_waker
=
self
.
waker
.
with_mut
(
|
t
|
(
*
t
)
.
take
(
)
)
;
self
.
waker
.
with_mut
(
|
t
|
*
t
=
Some
(
new_waker
)
)
;
}
Err
(
panic
)
=
>
maybe_panic
=
Some
(
panic
)
}
let
res
=
self
.
state
.
compare_exchange
(
REGISTERING
WAITING
AcqRel
Acquire
)
;
match
res
{
Ok
(
_
)
=
>
{
let
_
=
catch_unwind
(
move
|
|
{
drop
(
old_waker
)
;
}
)
;
}
Err
(
actual
)
=
>
{
debug_assert_eq
!
(
actual
REGISTERING
|
WAKING
)
;
let
mut
waker
=
self
.
waker
.
with_mut
(
|
t
|
(
*
t
)
.
take
(
)
)
;
self
.
state
.
swap
(
WAITING
AcqRel
)
;
if
maybe_panic
.
is_some
(
)
{
old_waker
=
waker
.
take
(
)
;
}
if
let
Some
(
old_waker
)
=
old_waker
{
let
_
=
catch_unwind
(
move
|
|
{
old_waker
.
wake
(
)
;
}
)
;
}
if
let
Some
(
waker
)
=
waker
{
debug_assert
!
(
maybe_panic
.
is_none
(
)
)
;
waker
.
wake
(
)
;
}
}
}
if
let
Some
(
panic
)
=
maybe_panic
{
resume_unwind
(
panic
)
;
}
}
}
WAKING
=
>
{
waker
.
wake
(
)
;
hint
:
:
spin_loop
(
)
;
}
state
=
>
{
debug_assert
!
(
state
=
=
REGISTERING
|
|
state
=
=
REGISTERING
|
WAKING
)
;
}
}
}
pub
(
crate
)
fn
wake
(
&
self
)
{
if
let
Some
(
waker
)
=
self
.
take_waker
(
)
{
waker
.
wake
(
)
;
}
}
pub
(
crate
)
fn
take_waker
(
&
self
)
-
>
Option
<
Waker
>
{
match
self
.
state
.
fetch_or
(
WAKING
AcqRel
)
{
WAITING
=
>
{
let
waker
=
unsafe
{
self
.
waker
.
with_mut
(
|
t
|
(
*
t
)
.
take
(
)
)
}
;
self
.
state
.
fetch_and
(
!
WAKING
Release
)
;
waker
}
state
=
>
{
debug_assert
!
(
state
=
=
REGISTERING
|
|
state
=
=
REGISTERING
|
WAKING
|
|
state
=
=
WAKING
)
;
None
}
}
}
}
impl
Default
for
AtomicWaker
{
fn
default
(
)
-
>
Self
{
AtomicWaker
:
:
new
(
)
}
}
impl
fmt
:
:
Debug
for
AtomicWaker
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
AtomicWaker
"
)
}
}
unsafe
impl
Send
for
AtomicWaker
{
}
unsafe
impl
Sync
for
AtomicWaker
{
}
trait
WakerRef
{
fn
wake
(
self
)
;
fn
into_waker
(
self
)
-
>
Waker
;
}
impl
WakerRef
for
Waker
{
fn
wake
(
self
)
{
self
.
wake
(
)
}
fn
into_waker
(
self
)
-
>
Waker
{
self
}
}
impl
WakerRef
for
&
Waker
{
fn
wake
(
self
)
{
self
.
wake_by_ref
(
)
}
fn
into_waker
(
self
)
-
>
Waker
{
self
.
clone
(
)
}
}
