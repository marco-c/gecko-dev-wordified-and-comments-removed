use
super
:
:
batch_semaphore
as
ll
;
use
super
:
:
{
AcquireError
TryAcquireError
}
;
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
use
crate
:
:
util
:
:
trace
;
use
std
:
:
sync
:
:
Arc
;
#
[
derive
(
Debug
)
]
pub
struct
Semaphore
{
ll_sem
:
ll
:
:
Semaphore
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
resource_span
:
tracing
:
:
Span
}
#
[
must_use
]
#
[
clippy
:
:
has_significant_drop
]
#
[
derive
(
Debug
)
]
pub
struct
SemaphorePermit
<
'
a
>
{
sem
:
&
'
a
Semaphore
permits
:
u32
}
#
[
must_use
]
#
[
clippy
:
:
has_significant_drop
]
#
[
derive
(
Debug
)
]
pub
struct
OwnedSemaphorePermit
{
sem
:
Arc
<
Semaphore
>
permits
:
u32
}
#
[
test
]
#
[
cfg
(
not
(
loom
)
)
]
fn
bounds
(
)
{
fn
check_unpin
<
T
:
Unpin
>
(
)
{
}
fn
check_send_sync_val
<
T
:
Send
+
Sync
>
(
_t
:
T
)
{
}
fn
check_send_sync
<
T
:
Send
+
Sync
>
(
)
{
}
check_unpin
:
:
<
Semaphore
>
(
)
;
check_unpin
:
:
<
SemaphorePermit
<
'
_
>
>
(
)
;
check_send_sync
:
:
<
Semaphore
>
(
)
;
let
semaphore
=
Semaphore
:
:
new
(
0
)
;
check_send_sync_val
(
semaphore
.
acquire
(
)
)
;
}
impl
Semaphore
{
pub
const
MAX_PERMITS
:
usize
=
super
:
:
batch_semaphore
:
:
Semaphore
:
:
MAX_PERMITS
;
#
[
track_caller
]
pub
fn
new
(
permits
:
usize
)
-
>
Self
{
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
resource_span
=
{
let
location
=
std
:
:
panic
:
:
Location
:
:
caller
(
)
;
tracing
:
:
trace_span
!
(
parent
:
None
"
runtime
.
resource
"
concrete_type
=
"
Semaphore
"
kind
=
"
Sync
"
loc
.
file
=
location
.
file
(
)
loc
.
line
=
location
.
line
(
)
loc
.
col
=
location
.
column
(
)
inherits_child_attrs
=
true
)
}
;
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
ll_sem
=
resource_span
.
in_scope
(
|
|
ll
:
:
Semaphore
:
:
new
(
permits
)
)
;
#
[
cfg
(
any
(
not
(
tokio_unstable
)
not
(
feature
=
"
tracing
"
)
)
)
]
let
ll_sem
=
ll
:
:
Semaphore
:
:
new
(
permits
)
;
Self
{
ll_sem
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
resource_span
}
}
#
[
cfg
(
not
(
all
(
loom
test
)
)
)
]
pub
const
fn
const_new
(
permits
:
usize
)
-
>
Self
{
Self
{
ll_sem
:
ll
:
:
Semaphore
:
:
const_new
(
permits
)
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
resource_span
:
tracing
:
:
Span
:
:
none
(
)
}
}
pub
(
crate
)
fn
new_closed
(
)
-
>
Self
{
Self
{
ll_sem
:
ll
:
:
Semaphore
:
:
new_closed
(
)
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
resource_span
:
tracing
:
:
Span
:
:
none
(
)
}
}
#
[
cfg
(
not
(
all
(
loom
test
)
)
)
]
pub
(
crate
)
const
fn
const_new_closed
(
)
-
>
Self
{
Self
{
ll_sem
:
ll
:
:
Semaphore
:
:
const_new_closed
(
)
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
resource_span
:
tracing
:
:
Span
:
:
none
(
)
}
}
pub
fn
available_permits
(
&
self
)
-
>
usize
{
self
.
ll_sem
.
available_permits
(
)
}
pub
fn
add_permits
(
&
self
n
:
usize
)
{
self
.
ll_sem
.
release
(
n
)
;
}
pub
fn
forget_permits
(
&
self
n
:
usize
)
-
>
usize
{
self
.
ll_sem
.
forget_permits
(
n
)
}
pub
async
fn
acquire
(
&
self
)
-
>
Result
<
SemaphorePermit
<
'
_
>
AcquireError
>
{
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
inner
=
trace
:
:
async_op
(
|
|
self
.
ll_sem
.
acquire
(
1
)
self
.
resource_span
.
clone
(
)
"
Semaphore
:
:
acquire
"
"
poll
"
true
)
;
#
[
cfg
(
not
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
)
]
let
inner
=
self
.
ll_sem
.
acquire
(
1
)
;
inner
.
await
?
;
Ok
(
SemaphorePermit
{
sem
:
self
permits
:
1
}
)
}
pub
async
fn
acquire_many
(
&
self
n
:
u32
)
-
>
Result
<
SemaphorePermit
<
'
_
>
AcquireError
>
{
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
trace
:
:
async_op
(
|
|
self
.
ll_sem
.
acquire
(
n
as
usize
)
self
.
resource_span
.
clone
(
)
"
Semaphore
:
:
acquire_many
"
"
poll
"
true
)
.
await
?
;
#
[
cfg
(
not
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
)
]
self
.
ll_sem
.
acquire
(
n
as
usize
)
.
await
?
;
Ok
(
SemaphorePermit
{
sem
:
self
permits
:
n
}
)
}
pub
fn
try_acquire
(
&
self
)
-
>
Result
<
SemaphorePermit
<
'
_
>
TryAcquireError
>
{
match
self
.
ll_sem
.
try_acquire
(
1
)
{
Ok
(
(
)
)
=
>
Ok
(
SemaphorePermit
{
sem
:
self
permits
:
1
}
)
Err
(
e
)
=
>
Err
(
e
)
}
}
pub
fn
try_acquire_many
(
&
self
n
:
u32
)
-
>
Result
<
SemaphorePermit
<
'
_
>
TryAcquireError
>
{
match
self
.
ll_sem
.
try_acquire
(
n
as
usize
)
{
Ok
(
(
)
)
=
>
Ok
(
SemaphorePermit
{
sem
:
self
permits
:
n
}
)
Err
(
e
)
=
>
Err
(
e
)
}
}
pub
async
fn
acquire_owned
(
self
:
Arc
<
Self
>
)
-
>
Result
<
OwnedSemaphorePermit
AcquireError
>
{
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
inner
=
trace
:
:
async_op
(
|
|
self
.
ll_sem
.
acquire
(
1
)
self
.
resource_span
.
clone
(
)
"
Semaphore
:
:
acquire_owned
"
"
poll
"
true
)
;
#
[
cfg
(
not
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
)
]
let
inner
=
self
.
ll_sem
.
acquire
(
1
)
;
inner
.
await
?
;
Ok
(
OwnedSemaphorePermit
{
sem
:
self
permits
:
1
}
)
}
pub
async
fn
acquire_many_owned
(
self
:
Arc
<
Self
>
n
:
u32
)
-
>
Result
<
OwnedSemaphorePermit
AcquireError
>
{
#
[
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
]
let
inner
=
trace
:
:
async_op
(
|
|
self
.
ll_sem
.
acquire
(
n
as
usize
)
self
.
resource_span
.
clone
(
)
"
Semaphore
:
:
acquire_many_owned
"
"
poll
"
true
)
;
#
[
cfg
(
not
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
)
]
let
inner
=
self
.
ll_sem
.
acquire
(
n
as
usize
)
;
inner
.
await
?
;
Ok
(
OwnedSemaphorePermit
{
sem
:
self
permits
:
n
}
)
}
pub
fn
try_acquire_owned
(
self
:
Arc
<
Self
>
)
-
>
Result
<
OwnedSemaphorePermit
TryAcquireError
>
{
match
self
.
ll_sem
.
try_acquire
(
1
)
{
Ok
(
(
)
)
=
>
Ok
(
OwnedSemaphorePermit
{
sem
:
self
permits
:
1
}
)
Err
(
e
)
=
>
Err
(
e
)
}
}
pub
fn
try_acquire_many_owned
(
self
:
Arc
<
Self
>
n
:
u32
)
-
>
Result
<
OwnedSemaphorePermit
TryAcquireError
>
{
match
self
.
ll_sem
.
try_acquire
(
n
as
usize
)
{
Ok
(
(
)
)
=
>
Ok
(
OwnedSemaphorePermit
{
sem
:
self
permits
:
n
}
)
Err
(
e
)
=
>
Err
(
e
)
}
}
pub
fn
close
(
&
self
)
{
self
.
ll_sem
.
close
(
)
;
}
pub
fn
is_closed
(
&
self
)
-
>
bool
{
self
.
ll_sem
.
is_closed
(
)
}
}
impl
<
'
a
>
SemaphorePermit
<
'
a
>
{
pub
fn
forget
(
mut
self
)
{
self
.
permits
=
0
;
}
#
[
track_caller
]
pub
fn
merge
(
&
mut
self
mut
other
:
Self
)
{
assert
!
(
std
:
:
ptr
:
:
eq
(
self
.
sem
other
.
sem
)
"
merging
permits
from
different
semaphore
instances
"
)
;
self
.
permits
+
=
other
.
permits
;
other
.
permits
=
0
;
}
pub
fn
split
(
&
mut
self
n
:
usize
)
-
>
Option
<
Self
>
{
let
n
=
u32
:
:
try_from
(
n
)
.
ok
(
)
?
;
if
n
>
self
.
permits
{
return
None
;
}
self
.
permits
-
=
n
;
Some
(
Self
{
sem
:
self
.
sem
permits
:
n
}
)
}
pub
fn
num_permits
(
&
self
)
-
>
usize
{
self
.
permits
as
usize
}
}
impl
OwnedSemaphorePermit
{
pub
fn
forget
(
mut
self
)
{
self
.
permits
=
0
;
}
#
[
track_caller
]
pub
fn
merge
(
&
mut
self
mut
other
:
Self
)
{
assert
!
(
Arc
:
:
ptr_eq
(
&
self
.
sem
&
other
.
sem
)
"
merging
permits
from
different
semaphore
instances
"
)
;
self
.
permits
+
=
other
.
permits
;
other
.
permits
=
0
;
}
pub
fn
split
(
&
mut
self
n
:
usize
)
-
>
Option
<
Self
>
{
let
n
=
u32
:
:
try_from
(
n
)
.
ok
(
)
?
;
if
n
>
self
.
permits
{
return
None
;
}
self
.
permits
-
=
n
;
Some
(
Self
{
sem
:
self
.
sem
.
clone
(
)
permits
:
n
}
)
}
pub
fn
semaphore
(
&
self
)
-
>
&
Arc
<
Semaphore
>
{
&
self
.
sem
}
pub
fn
num_permits
(
&
self
)
-
>
usize
{
self
.
permits
as
usize
}
}
impl
Drop
for
SemaphorePermit
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
self
.
sem
.
add_permits
(
self
.
permits
as
usize
)
;
}
}
impl
Drop
for
OwnedSemaphorePermit
{
fn
drop
(
&
mut
self
)
{
self
.
sem
.
add_permits
(
self
.
permits
as
usize
)
;
}
}
