use
crate
:
:
loom
:
:
cell
:
:
UnsafeCell
;
use
crate
:
:
loom
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
crate
:
:
loom
:
:
sync
:
:
{
Arc
Mutex
RwLock
RwLockReadGuard
}
;
use
crate
:
:
util
:
:
linked_list
:
:
{
self
LinkedList
}
;
use
std
:
:
fmt
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
marker
:
:
PhantomPinned
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
ptr
:
:
NonNull
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
SeqCst
;
use
std
:
:
task
:
:
{
Context
Poll
Waker
}
;
use
std
:
:
usize
;
pub
struct
Sender
<
T
>
{
shared
:
Arc
<
Shared
<
T
>
>
}
pub
struct
Receiver
<
T
>
{
shared
:
Arc
<
Shared
<
T
>
>
next
:
u64
}
pub
mod
error
{
use
std
:
:
fmt
;
#
[
derive
(
Debug
)
]
pub
struct
SendError
<
T
>
(
pub
T
)
;
impl
<
T
>
fmt
:
:
Display
for
SendError
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
channel
closed
"
)
}
}
impl
<
T
:
fmt
:
:
Debug
>
std
:
:
error
:
:
Error
for
SendError
<
T
>
{
}
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
RecvError
{
Closed
Lagged
(
u64
)
}
impl
fmt
:
:
Display
for
RecvError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
RecvError
:
:
Closed
=
>
write
!
(
f
"
channel
closed
"
)
RecvError
:
:
Lagged
(
amt
)
=
>
write
!
(
f
"
channel
lagged
by
{
}
"
amt
)
}
}
}
impl
std
:
:
error
:
:
Error
for
RecvError
{
}
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
TryRecvError
{
Empty
Closed
Lagged
(
u64
)
}
impl
fmt
:
:
Display
for
TryRecvError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
TryRecvError
:
:
Empty
=
>
write
!
(
f
"
channel
empty
"
)
TryRecvError
:
:
Closed
=
>
write
!
(
f
"
channel
closed
"
)
TryRecvError
:
:
Lagged
(
amt
)
=
>
write
!
(
f
"
channel
lagged
by
{
}
"
amt
)
}
}
}
impl
std
:
:
error
:
:
Error
for
TryRecvError
{
}
}
use
self
:
:
error
:
:
*
;
struct
Shared
<
T
>
{
buffer
:
Box
<
[
RwLock
<
Slot
<
T
>
>
]
>
mask
:
usize
tail
:
Mutex
<
Tail
>
num_tx
:
AtomicUsize
}
struct
Tail
{
pos
:
u64
rx_cnt
:
usize
closed
:
bool
waiters
:
LinkedList
<
Waiter
<
Waiter
as
linked_list
:
:
Link
>
:
:
Target
>
}
struct
Slot
<
T
>
{
rem
:
AtomicUsize
pos
:
u64
closed
:
bool
val
:
UnsafeCell
<
Option
<
T
>
>
}
struct
Waiter
{
queued
:
bool
waker
:
Option
<
Waker
>
pointers
:
linked_list
:
:
Pointers
<
Waiter
>
_p
:
PhantomPinned
}
struct
RecvGuard
<
'
a
T
>
{
slot
:
RwLockReadGuard
<
'
a
Slot
<
T
>
>
}
struct
Recv
<
'
a
T
>
{
receiver
:
&
'
a
mut
Receiver
<
T
>
waiter
:
UnsafeCell
<
Waiter
>
}
unsafe
impl
<
'
a
T
:
Send
>
Send
for
Recv
<
'
a
T
>
{
}
unsafe
impl
<
'
a
T
:
Send
>
Sync
for
Recv
<
'
a
T
>
{
}
const
MAX_RECEIVERS
:
usize
=
usize
:
:
MAX
>
>
2
;
pub
fn
channel
<
T
:
Clone
>
(
mut
capacity
:
usize
)
-
>
(
Sender
<
T
>
Receiver
<
T
>
)
{
assert
!
(
capacity
>
0
"
capacity
is
empty
"
)
;
assert
!
(
capacity
<
=
usize
:
:
MAX
>
>
1
"
requested
capacity
too
large
"
)
;
capacity
=
capacity
.
next_power_of_two
(
)
;
let
mut
buffer
=
Vec
:
:
with_capacity
(
capacity
)
;
for
i
in
0
.
.
capacity
{
buffer
.
push
(
RwLock
:
:
new
(
Slot
{
rem
:
AtomicUsize
:
:
new
(
0
)
pos
:
(
i
as
u64
)
.
wrapping_sub
(
capacity
as
u64
)
closed
:
false
val
:
UnsafeCell
:
:
new
(
None
)
}
)
)
;
}
let
shared
=
Arc
:
:
new
(
Shared
{
buffer
:
buffer
.
into_boxed_slice
(
)
mask
:
capacity
-
1
tail
:
Mutex
:
:
new
(
Tail
{
pos
:
0
rx_cnt
:
1
closed
:
false
waiters
:
LinkedList
:
:
new
(
)
}
)
num_tx
:
AtomicUsize
:
:
new
(
1
)
}
)
;
let
rx
=
Receiver
{
shared
:
shared
.
clone
(
)
next
:
0
}
;
let
tx
=
Sender
{
shared
}
;
(
tx
rx
)
}
unsafe
impl
<
T
:
Send
>
Send
for
Sender
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Sync
for
Sender
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Send
for
Receiver
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Sync
for
Receiver
<
T
>
{
}
impl
<
T
>
Sender
<
T
>
{
pub
fn
send
(
&
self
value
:
T
)
-
>
Result
<
usize
SendError
<
T
>
>
{
self
.
send2
(
Some
(
value
)
)
.
map_err
(
|
SendError
(
maybe_v
)
|
SendError
(
maybe_v
.
unwrap
(
)
)
)
}
pub
fn
subscribe
(
&
self
)
-
>
Receiver
<
T
>
{
let
shared
=
self
.
shared
.
clone
(
)
;
new_receiver
(
shared
)
}
pub
fn
receiver_count
(
&
self
)
-
>
usize
{
let
tail
=
self
.
shared
.
tail
.
lock
(
)
;
tail
.
rx_cnt
}
fn
send2
(
&
self
value
:
Option
<
T
>
)
-
>
Result
<
usize
SendError
<
Option
<
T
>
>
>
{
let
mut
tail
=
self
.
shared
.
tail
.
lock
(
)
;
if
tail
.
rx_cnt
=
=
0
{
return
Err
(
SendError
(
value
)
)
;
}
let
pos
=
tail
.
pos
;
let
rem
=
tail
.
rx_cnt
;
let
idx
=
(
pos
&
self
.
shared
.
mask
as
u64
)
as
usize
;
tail
.
pos
=
tail
.
pos
.
wrapping_add
(
1
)
;
let
mut
slot
=
self
.
shared
.
buffer
[
idx
]
.
write
(
)
.
unwrap
(
)
;
slot
.
pos
=
pos
;
slot
.
rem
.
with_mut
(
|
v
|
*
v
=
rem
)
;
if
value
.
is_none
(
)
{
tail
.
closed
=
true
;
slot
.
closed
=
true
;
}
else
{
slot
.
val
.
with_mut
(
|
ptr
|
unsafe
{
*
ptr
=
value
}
)
;
}
drop
(
slot
)
;
tail
.
notify_rx
(
)
;
drop
(
tail
)
;
Ok
(
rem
)
}
}
fn
new_receiver
<
T
>
(
shared
:
Arc
<
Shared
<
T
>
>
)
-
>
Receiver
<
T
>
{
let
mut
tail
=
shared
.
tail
.
lock
(
)
;
if
tail
.
rx_cnt
=
=
MAX_RECEIVERS
{
panic
!
(
"
max
receivers
"
)
;
}
tail
.
rx_cnt
=
tail
.
rx_cnt
.
checked_add
(
1
)
.
expect
(
"
overflow
"
)
;
let
next
=
tail
.
pos
;
drop
(
tail
)
;
Receiver
{
shared
next
}
}
impl
Tail
{
fn
notify_rx
(
&
mut
self
)
{
while
let
Some
(
mut
waiter
)
=
self
.
waiters
.
pop_back
(
)
{
let
waiter
=
unsafe
{
waiter
.
as_mut
(
)
}
;
assert
!
(
waiter
.
queued
)
;
waiter
.
queued
=
false
;
let
waker
=
waiter
.
waker
.
take
(
)
.
unwrap
(
)
;
waker
.
wake
(
)
;
}
}
}
impl
<
T
>
Clone
for
Sender
<
T
>
{
fn
clone
(
&
self
)
-
>
Sender
<
T
>
{
let
shared
=
self
.
shared
.
clone
(
)
;
shared
.
num_tx
.
fetch_add
(
1
SeqCst
)
;
Sender
{
shared
}
}
}
impl
<
T
>
Drop
for
Sender
<
T
>
{
fn
drop
(
&
mut
self
)
{
if
1
=
=
self
.
shared
.
num_tx
.
fetch_sub
(
1
SeqCst
)
{
let
_
=
self
.
send2
(
None
)
;
}
}
}
impl
<
T
>
Receiver
<
T
>
{
fn
recv_ref
(
&
mut
self
waiter
:
Option
<
(
&
UnsafeCell
<
Waiter
>
&
Waker
)
>
)
-
>
Result
<
RecvGuard
<
'
_
T
>
TryRecvError
>
{
let
idx
=
(
self
.
next
&
self
.
shared
.
mask
as
u64
)
as
usize
;
let
mut
slot
=
self
.
shared
.
buffer
[
idx
]
.
read
(
)
.
unwrap
(
)
;
if
slot
.
pos
!
=
self
.
next
{
let
next_pos
=
slot
.
pos
.
wrapping_add
(
self
.
shared
.
buffer
.
len
(
)
as
u64
)
;
if
waiter
.
is_none
(
)
&
&
next_pos
=
=
self
.
next
{
return
Err
(
TryRecvError
:
:
Empty
)
;
}
drop
(
slot
)
;
let
mut
tail
=
self
.
shared
.
tail
.
lock
(
)
;
slot
=
self
.
shared
.
buffer
[
idx
]
.
read
(
)
.
unwrap
(
)
;
if
slot
.
pos
!
=
self
.
next
{
let
next_pos
=
slot
.
pos
.
wrapping_add
(
self
.
shared
.
buffer
.
len
(
)
as
u64
)
;
if
next_pos
=
=
self
.
next
{
if
let
Some
(
(
waiter
waker
)
)
=
waiter
{
unsafe
{
waiter
.
with_mut
(
|
ptr
|
{
match
(
*
ptr
)
.
waker
{
Some
(
ref
w
)
if
w
.
will_wake
(
waker
)
=
>
{
}
_
=
>
{
(
*
ptr
)
.
waker
=
Some
(
waker
.
clone
(
)
)
;
}
}
if
!
(
*
ptr
)
.
queued
{
(
*
ptr
)
.
queued
=
true
;
tail
.
waiters
.
push_front
(
NonNull
:
:
new_unchecked
(
&
mut
*
ptr
)
)
;
}
}
)
;
}
}
return
Err
(
TryRecvError
:
:
Empty
)
;
}
let
mut
adjust
=
0
;
if
tail
.
closed
{
adjust
=
1
}
let
next
=
tail
.
pos
.
wrapping_sub
(
self
.
shared
.
buffer
.
len
(
)
as
u64
+
adjust
)
;
let
missed
=
next
.
wrapping_sub
(
self
.
next
)
;
drop
(
tail
)
;
if
missed
=
=
0
{
self
.
next
=
self
.
next
.
wrapping_add
(
1
)
;
return
Ok
(
RecvGuard
{
slot
}
)
;
}
self
.
next
=
next
;
return
Err
(
TryRecvError
:
:
Lagged
(
missed
)
)
;
}
}
self
.
next
=
self
.
next
.
wrapping_add
(
1
)
;
if
slot
.
closed
{
return
Err
(
TryRecvError
:
:
Closed
)
;
}
Ok
(
RecvGuard
{
slot
}
)
}
}
impl
<
T
:
Clone
>
Receiver
<
T
>
{
pub
async
fn
recv
(
&
mut
self
)
-
>
Result
<
T
RecvError
>
{
let
fut
=
Recv
:
:
new
(
self
)
;
fut
.
await
}
pub
fn
try_recv
(
&
mut
self
)
-
>
Result
<
T
TryRecvError
>
{
let
guard
=
self
.
recv_ref
(
None
)
?
;
guard
.
clone_value
(
)
.
ok_or
(
TryRecvError
:
:
Closed
)
}
}
impl
<
T
>
Drop
for
Receiver
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
mut
tail
=
self
.
shared
.
tail
.
lock
(
)
;
tail
.
rx_cnt
-
=
1
;
let
until
=
tail
.
pos
;
drop
(
tail
)
;
while
self
.
next
<
until
{
match
self
.
recv_ref
(
None
)
{
Ok
(
_
)
=
>
{
}
Err
(
TryRecvError
:
:
Closed
)
=
>
break
Err
(
TryRecvError
:
:
Lagged
(
.
.
)
)
=
>
{
}
Err
(
TryRecvError
:
:
Empty
)
=
>
panic
!
(
"
unexpected
empty
broadcast
channel
"
)
}
}
}
}
impl
<
'
a
T
>
Recv
<
'
a
T
>
{
fn
new
(
receiver
:
&
'
a
mut
Receiver
<
T
>
)
-
>
Recv
<
'
a
T
>
{
Recv
{
receiver
waiter
:
UnsafeCell
:
:
new
(
Waiter
{
queued
:
false
waker
:
None
pointers
:
linked_list
:
:
Pointers
:
:
new
(
)
_p
:
PhantomPinned
}
)
}
}
fn
project
(
self
:
Pin
<
&
mut
Self
>
)
-
>
(
&
mut
Receiver
<
T
>
&
UnsafeCell
<
Waiter
>
)
{
unsafe
{
is_unpin
:
:
<
&
mut
Receiver
<
T
>
>
(
)
;
let
me
=
self
.
get_unchecked_mut
(
)
;
(
me
.
receiver
&
me
.
waiter
)
}
}
}
impl
<
'
a
T
>
Future
for
Recv
<
'
a
T
>
where
T
:
Clone
{
type
Output
=
Result
<
T
RecvError
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
T
RecvError
>
>
{
let
(
receiver
waiter
)
=
self
.
project
(
)
;
let
guard
=
match
receiver
.
recv_ref
(
Some
(
(
waiter
cx
.
waker
(
)
)
)
)
{
Ok
(
value
)
=
>
value
Err
(
TryRecvError
:
:
Empty
)
=
>
return
Poll
:
:
Pending
Err
(
TryRecvError
:
:
Lagged
(
n
)
)
=
>
return
Poll
:
:
Ready
(
Err
(
RecvError
:
:
Lagged
(
n
)
)
)
Err
(
TryRecvError
:
:
Closed
)
=
>
return
Poll
:
:
Ready
(
Err
(
RecvError
:
:
Closed
)
)
}
;
Poll
:
:
Ready
(
guard
.
clone_value
(
)
.
ok_or
(
RecvError
:
:
Closed
)
)
}
}
impl
<
'
a
T
>
Drop
for
Recv
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
let
mut
tail
=
self
.
receiver
.
shared
.
tail
.
lock
(
)
;
let
queued
=
self
.
waiter
.
with
(
|
ptr
|
unsafe
{
(
*
ptr
)
.
queued
}
)
;
if
queued
{
unsafe
{
self
.
waiter
.
with_mut
(
|
ptr
|
{
tail
.
waiters
.
remove
(
(
&
mut
*
ptr
)
.
into
(
)
)
;
}
)
;
}
}
}
}
unsafe
impl
linked_list
:
:
Link
for
Waiter
{
type
Handle
=
NonNull
<
Waiter
>
;
type
Target
=
Waiter
;
fn
as_raw
(
handle
:
&
NonNull
<
Waiter
>
)
-
>
NonNull
<
Waiter
>
{
*
handle
}
unsafe
fn
from_raw
(
ptr
:
NonNull
<
Waiter
>
)
-
>
NonNull
<
Waiter
>
{
ptr
}
unsafe
fn
pointers
(
mut
target
:
NonNull
<
Waiter
>
)
-
>
NonNull
<
linked_list
:
:
Pointers
<
Waiter
>
>
{
NonNull
:
:
from
(
&
mut
target
.
as_mut
(
)
.
pointers
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
Sender
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
broadcast
:
:
Sender
"
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
Receiver
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
broadcast
:
:
Receiver
"
)
}
}
impl
<
'
a
T
>
RecvGuard
<
'
a
T
>
{
fn
clone_value
(
&
self
)
-
>
Option
<
T
>
where
T
:
Clone
{
self
.
slot
.
val
.
with
(
|
ptr
|
unsafe
{
(
*
ptr
)
.
clone
(
)
}
)
}
}
impl
<
'
a
T
>
Drop
for
RecvGuard
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
if
1
=
=
self
.
slot
.
rem
.
fetch_sub
(
1
SeqCst
)
{
self
.
slot
.
val
.
with_mut
(
|
ptr
|
unsafe
{
*
ptr
=
None
}
)
;
}
}
}
fn
is_unpin
<
T
:
Unpin
>
(
)
{
}
