use
crate
:
:
io
:
:
{
Interest
PollEvented
ReadBuf
Ready
}
;
use
crate
:
:
net
:
:
{
to_socket_addrs
ToSocketAddrs
}
;
use
crate
:
:
util
:
:
check_socket_for_blocking
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
net
:
:
{
self
Ipv4Addr
Ipv6Addr
SocketAddr
}
;
use
std
:
:
task
:
:
{
ready
Context
Poll
}
;
cfg_io_util
!
{
use
bytes
:
:
BufMut
;
}
cfg_net
!
{
/
/
/
A
UDP
socket
.
/
/
/
/
/
/
UDP
is
"
connectionless
"
unlike
TCP
.
Meaning
regardless
of
what
address
you
'
ve
bound
to
a
UdpSocket
/
/
/
is
free
to
communicate
with
many
different
remotes
.
In
tokio
there
are
basically
two
main
ways
to
use
UdpSocket
:
/
/
/
/
/
/
*
one
to
many
:
[
bind
]
(
UdpSocket
:
:
bind
)
and
use
[
send_to
]
(
UdpSocket
:
:
send_to
)
/
/
/
and
[
recv_from
]
(
UdpSocket
:
:
recv_from
)
to
communicate
with
many
different
addresses
/
/
/
*
one
to
one
:
[
connect
]
(
UdpSocket
:
:
connect
)
and
associate
with
a
single
address
using
[
send
]
(
UdpSocket
:
:
send
)
/
/
/
and
[
recv
]
(
UdpSocket
:
:
recv
)
to
communicate
only
with
that
remote
address
/
/
/
/
/
/
This
type
does
not
provide
a
split
method
because
this
functionality
/
/
/
can
be
achieved
by
instead
wrapping
the
socket
in
an
[
Arc
]
.
Note
that
/
/
/
you
do
not
need
a
Mutex
to
share
the
UdpSocket
an
Arc
<
UdpSocket
>
/
/
/
is
enough
.
This
is
because
all
of
the
methods
take
&
self
instead
of
/
/
/
&
mut
self
.
Once
you
have
wrapped
it
in
an
Arc
you
can
call
/
/
/
.
clone
(
)
on
the
Arc
<
UdpSocket
>
to
get
multiple
shared
handles
to
the
/
/
/
same
socket
.
An
example
of
such
usage
can
be
found
further
down
.
/
/
/
/
/
/
[
Arc
]
:
std
:
:
sync
:
:
Arc
/
/
/
/
/
/
#
Streams
/
/
/
/
/
/
If
you
need
to
listen
over
UDP
and
produce
a
[
Stream
]
you
can
look
/
/
/
at
[
UdpFramed
]
.
/
/
/
/
/
/
[
UdpFramed
]
:
https
:
/
/
docs
.
rs
/
tokio
-
util
/
latest
/
tokio_util
/
udp
/
struct
.
UdpFramed
.
html
/
/
/
[
Stream
]
:
https
:
/
/
docs
.
rs
/
futures
/
0
.
3
/
futures
/
stream
/
trait
.
Stream
.
html
/
/
/
/
/
/
#
Example
:
one
to
many
(
bind
)
/
/
/
/
/
/
Using
bind
we
can
create
a
simple
echo
server
that
sends
and
recv
'
s
with
many
different
clients
:
/
/
/
no_run
/
/
/
use
tokio
:
:
net
:
:
UdpSocket
;
/
/
/
use
std
:
:
io
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
-
>
io
:
:
Result
<
(
)
>
{
/
/
/
let
sock
=
UdpSocket
:
:
bind
(
"
0
.
0
.
0
.
0
:
8080
"
)
.
await
?
;
/
/
/
let
mut
buf
=
[
0
;
1024
]
;
/
/
/
loop
{
/
/
/
let
(
len
addr
)
=
sock
.
recv_from
(
&
mut
buf
)
.
await
?
;
/
/
/
println
!
(
"
{
:
?
}
bytes
received
from
{
:
?
}
"
len
addr
)
;
/
/
/
/
/
/
let
len
=
sock
.
send_to
(
&
buf
[
.
.
len
]
addr
)
.
await
?
;
/
/
/
println
!
(
"
{
:
?
}
bytes
sent
"
len
)
;
/
/
/
}
/
/
/
}
/
/
/
/
/
/
/
/
/
#
Example
:
one
to
one
(
connect
)
/
/
/
/
/
/
Or
using
connect
we
can
echo
with
a
single
remote
address
using
send
and
recv
:
/
/
/
no_run
/
/
/
use
tokio
:
:
net
:
:
UdpSocket
;
/
/
/
use
std
:
:
io
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
-
>
io
:
:
Result
<
(
)
>
{
/
/
/
let
sock
=
UdpSocket
:
:
bind
(
"
0
.
0
.
0
.
0
:
8080
"
)
.
await
?
;
/
/
/
/
/
/
let
remote_addr
=
"
127
.
0
.
0
.
1
:
59611
"
;
/
/
/
sock
.
connect
(
remote_addr
)
.
await
?
;
/
/
/
let
mut
buf
=
[
0
;
1024
]
;
/
/
/
loop
{
/
/
/
let
len
=
sock
.
recv
(
&
mut
buf
)
.
await
?
;
/
/
/
println
!
(
"
{
:
?
}
bytes
received
from
{
:
?
}
"
len
remote_addr
)
;
/
/
/
/
/
/
let
len
=
sock
.
send
(
&
buf
[
.
.
len
]
)
.
await
?
;
/
/
/
println
!
(
"
{
:
?
}
bytes
sent
"
len
)
;
/
/
/
}
/
/
/
}
/
/
/
/
/
/
/
/
/
#
Example
:
Splitting
with
Arc
/
/
/
/
/
/
Because
send_to
and
recv_from
take
&
self
.
It
'
s
perfectly
alright
/
/
/
to
use
an
Arc
<
UdpSocket
>
and
share
the
references
to
multiple
tasks
.
/
/
/
Here
is
a
similar
"
echo
"
example
that
supports
concurrent
/
/
/
sending
/
receiving
:
/
/
/
/
/
/
no_run
/
/
/
use
tokio
:
:
{
net
:
:
UdpSocket
sync
:
:
mpsc
}
;
/
/
/
use
std
:
:
{
io
net
:
:
SocketAddr
sync
:
:
Arc
}
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
-
>
io
:
:
Result
<
(
)
>
{
/
/
/
let
sock
=
UdpSocket
:
:
bind
(
"
0
.
0
.
0
.
0
:
8080
"
.
parse
:
:
<
SocketAddr
>
(
)
.
unwrap
(
)
)
.
await
?
;
/
/
/
let
r
=
Arc
:
:
new
(
sock
)
;
/
/
/
let
s
=
r
.
clone
(
)
;
/
/
/
let
(
tx
mut
rx
)
=
mpsc
:
:
channel
:
:
<
(
Vec
<
u8
>
SocketAddr
)
>
(
1_000
)
;
/
/
/
/
/
/
tokio
:
:
spawn
(
async
move
{
/
/
/
while
let
Some
(
(
bytes
addr
)
)
=
rx
.
recv
(
)
.
await
{
/
/
/
let
len
=
s
.
send_to
(
&
bytes
&
addr
)
.
await
.
unwrap
(
)
;
/
/
/
println
!
(
"
{
:
?
}
bytes
sent
"
len
)
;
/
/
/
}
/
/
/
}
)
;
/
/
/
/
/
/
let
mut
buf
=
[
0
;
1024
]
;
/
/
/
loop
{
/
/
/
let
(
len
addr
)
=
r
.
recv_from
(
&
mut
buf
)
.
await
?
;
/
/
/
println
!
(
"
{
:
?
}
bytes
received
from
{
:
?
}
"
len
addr
)
;
/
/
/
tx
.
send
(
(
buf
[
.
.
len
]
.
to_vec
(
)
addr
)
)
.
await
.
unwrap
(
)
;
/
/
/
}
/
/
/
}
/
/
/
/
/
/
pub
struct
UdpSocket
{
io
:
PollEvented
<
mio
:
:
net
:
:
UdpSocket
>
}
}
impl
UdpSocket
{
pub
async
fn
bind
<
A
:
ToSocketAddrs
>
(
addr
:
A
)
-
>
io
:
:
Result
<
UdpSocket
>
{
let
addrs
=
to_socket_addrs
(
addr
)
.
await
?
;
let
mut
last_err
=
None
;
for
addr
in
addrs
{
match
UdpSocket
:
:
bind_addr
(
addr
)
{
Ok
(
socket
)
=
>
return
Ok
(
socket
)
Err
(
e
)
=
>
last_err
=
Some
(
e
)
}
}
Err
(
last_err
.
unwrap_or_else
(
|
|
{
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidInput
"
could
not
resolve
to
any
address
"
)
}
)
)
}
fn
bind_addr
(
addr
:
SocketAddr
)
-
>
io
:
:
Result
<
UdpSocket
>
{
let
sys
=
mio
:
:
net
:
:
UdpSocket
:
:
bind
(
addr
)
?
;
UdpSocket
:
:
new
(
sys
)
}
#
[
track_caller
]
fn
new
(
socket
:
mio
:
:
net
:
:
UdpSocket
)
-
>
io
:
:
Result
<
UdpSocket
>
{
let
io
=
PollEvented
:
:
new
(
socket
)
?
;
Ok
(
UdpSocket
{
io
}
)
}
#
[
track_caller
]
pub
fn
from_std
(
socket
:
net
:
:
UdpSocket
)
-
>
io
:
:
Result
<
UdpSocket
>
{
check_socket_for_blocking
(
&
socket
)
?
;
let
io
=
mio
:
:
net
:
:
UdpSocket
:
:
from_std
(
socket
)
;
UdpSocket
:
:
new
(
io
)
}
pub
fn
into_std
(
self
)
-
>
io
:
:
Result
<
std
:
:
net
:
:
UdpSocket
>
{
#
[
cfg
(
unix
)
]
{
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
FromRawFd
IntoRawFd
}
;
self
.
io
.
into_inner
(
)
.
map
(
IntoRawFd
:
:
into_raw_fd
)
.
map
(
|
raw_fd
|
unsafe
{
std
:
:
net
:
:
UdpSocket
:
:
from_raw_fd
(
raw_fd
)
}
)
}
#
[
cfg
(
windows
)
]
{
use
std
:
:
os
:
:
windows
:
:
io
:
:
{
FromRawSocket
IntoRawSocket
}
;
self
.
io
.
into_inner
(
)
.
map
(
|
io
|
io
.
into_raw_socket
(
)
)
.
map
(
|
raw_socket
|
unsafe
{
std
:
:
net
:
:
UdpSocket
:
:
from_raw_socket
(
raw_socket
)
}
)
}
}
fn
as_socket
(
&
self
)
-
>
socket2
:
:
SockRef
<
'
_
>
{
socket2
:
:
SockRef
:
:
from
(
self
)
}
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
local_addr
(
)
}
pub
fn
peer_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
peer_addr
(
)
}
pub
async
fn
connect
<
A
:
ToSocketAddrs
>
(
&
self
addr
:
A
)
-
>
io
:
:
Result
<
(
)
>
{
let
addrs
=
to_socket_addrs
(
addr
)
.
await
?
;
let
mut
last_err
=
None
;
for
addr
in
addrs
{
match
self
.
io
.
connect
(
addr
)
{
Ok
(
(
)
)
=
>
return
Ok
(
(
)
)
Err
(
e
)
=
>
last_err
=
Some
(
e
)
}
}
Err
(
last_err
.
unwrap_or_else
(
|
|
{
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidInput
"
could
not
resolve
to
any
address
"
)
}
)
)
}
pub
async
fn
ready
(
&
self
interest
:
Interest
)
-
>
io
:
:
Result
<
Ready
>
{
let
event
=
self
.
io
.
registration
(
)
.
readiness
(
interest
)
.
await
?
;
Ok
(
event
.
ready
)
}
pub
async
fn
writable
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
ready
(
Interest
:
:
WRITABLE
)
.
await
?
;
Ok
(
(
)
)
}
pub
fn
poll_send_ready
(
&
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
self
.
io
.
registration
(
)
.
poll_write_ready
(
cx
)
.
map_ok
(
|
_
|
(
)
)
}
pub
async
fn
send
(
&
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
registration
(
)
.
async_io
(
Interest
:
:
WRITABLE
|
|
self
.
io
.
send
(
buf
)
)
.
await
}
pub
fn
poll_send
(
&
self
cx
:
&
mut
Context
<
'
_
>
buf
:
&
[
u8
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
self
.
io
.
registration
(
)
.
poll_write_io
(
cx
|
|
self
.
io
.
send
(
buf
)
)
}
pub
fn
try_send
(
&
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
registration
(
)
.
try_io
(
Interest
:
:
WRITABLE
|
|
self
.
io
.
send
(
buf
)
)
}
pub
async
fn
readable
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
ready
(
Interest
:
:
READABLE
)
.
await
?
;
Ok
(
(
)
)
}
pub
fn
poll_recv_ready
(
&
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
self
.
io
.
registration
(
)
.
poll_read_ready
(
cx
)
.
map_ok
(
|
_
|
(
)
)
}
pub
async
fn
recv
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
registration
(
)
.
async_io
(
Interest
:
:
READABLE
|
|
self
.
io
.
recv
(
buf
)
)
.
await
}
pub
fn
poll_recv
(
&
self
cx
:
&
mut
Context
<
'
_
>
buf
:
&
mut
ReadBuf
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
#
[
allow
(
clippy
:
:
blocks_in_conditions
)
]
let
n
=
ready
!
(
self
.
io
.
registration
(
)
.
poll_read_io
(
cx
|
|
{
/
/
Safety
:
will
not
read
the
maybe
uninitialized
bytes
.
let
b
=
unsafe
{
&
mut
*
(
buf
.
unfilled_mut
(
)
as
*
mut
[
std
:
:
mem
:
:
MaybeUninit
<
u8
>
]
as
*
mut
[
u8
]
)
}
;
self
.
io
.
recv
(
b
)
}
)
)
?
;
unsafe
{
buf
.
assume_init
(
n
)
;
}
buf
.
advance
(
n
)
;
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
pub
fn
try_recv
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
registration
(
)
.
try_io
(
Interest
:
:
READABLE
|
|
self
.
io
.
recv
(
buf
)
)
}
cfg_io_util
!
{
/
/
/
Tries
to
receive
data
from
the
stream
into
the
provided
buffer
advancing
the
/
/
/
buffer
'
s
internal
cursor
returning
how
many
bytes
were
read
.
/
/
/
/
/
/
This
method
must
be
called
with
valid
byte
array
buf
of
sufficient
size
/
/
/
to
hold
the
message
bytes
.
If
a
message
is
too
long
to
fit
in
the
/
/
/
supplied
buffer
excess
bytes
may
be
discarded
.
/
/
/
/
/
/
This
method
can
be
used
even
if
buf
is
uninitialized
.
/
/
/
/
/
/
When
there
is
no
pending
data
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
)
is
/
/
/
returned
.
This
function
is
usually
paired
with
readable
(
)
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
no_run
/
/
/
use
tokio
:
:
net
:
:
UdpSocket
;
/
/
/
use
std
:
:
io
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
-
>
io
:
:
Result
<
(
)
>
{
/
/
/
/
/
Connect
to
a
peer
/
/
/
let
socket
=
UdpSocket
:
:
bind
(
"
127
.
0
.
0
.
1
:
8080
"
)
.
await
?
;
/
/
/
socket
.
connect
(
"
127
.
0
.
0
.
1
:
8081
"
)
.
await
?
;
/
/
/
/
/
/
loop
{
/
/
/
/
/
Wait
for
the
socket
to
be
readable
/
/
/
socket
.
readable
(
)
.
await
?
;
/
/
/
/
/
/
let
mut
buf
=
Vec
:
:
with_capacity
(
1024
)
;
/
/
/
/
/
/
/
/
Try
to
recv
data
this
may
still
fail
with
WouldBlock
/
/
/
/
/
if
the
readiness
event
is
a
false
positive
.
/
/
/
match
socket
.
try_recv_buf
(
&
mut
buf
)
{
/
/
/
Ok
(
n
)
=
>
{
/
/
/
println
!
(
"
GOT
{
:
?
}
"
&
buf
[
.
.
n
]
)
;
/
/
/
break
;
/
/
/
}
/
/
/
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
/
/
/
continue
;
/
/
/
}
/
/
/
Err
(
e
)
=
>
{
/
/
/
return
Err
(
e
)
;
/
/
/
}
/
/
/
}
/
/
/
}
/
/
/
/
/
/
Ok
(
(
)
)
/
/
/
}
/
/
/
pub
fn
try_recv_buf
<
B
:
BufMut
>
(
&
self
buf
:
&
mut
B
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
registration
(
)
.
try_io
(
Interest
:
:
READABLE
|
|
{
let
dst
=
buf
.
chunk_mut
(
)
;
let
dst
=
unsafe
{
&
mut
*
(
dst
as
*
mut
_
as
*
mut
[
std
:
:
mem
:
:
MaybeUninit
<
u8
>
]
as
*
mut
[
u8
]
)
}
;
let
n
=
(
*
self
.
io
)
.
recv
(
dst
)
?
;
/
/
Safety
:
We
trust
UdpSocket
:
:
recv
to
have
filled
up
n
bytes
in
the
/
/
buffer
.
unsafe
{
buf
.
advance_mut
(
n
)
;
}
Ok
(
n
)
}
)
}
/
/
/
Receives
a
single
datagram
message
on
the
socket
from
the
remote
address
/
/
/
to
which
it
is
connected
advancing
the
buffer
'
s
internal
cursor
/
/
/
returning
how
many
bytes
were
read
.
/
/
/
/
/
/
This
method
must
be
called
with
valid
byte
array
buf
of
sufficient
size
/
/
/
to
hold
the
message
bytes
.
If
a
message
is
too
long
to
fit
in
the
/
/
/
supplied
buffer
excess
bytes
may
be
discarded
.
/
/
/
/
/
/
This
method
can
be
used
even
if
buf
is
uninitialized
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
no_run
/
/
/
use
tokio
:
:
net
:
:
UdpSocket
;
/
/
/
use
std
:
:
io
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
-
>
io
:
:
Result
<
(
)
>
{
/
/
/
/
/
Connect
to
a
peer
/
/
/
let
socket
=
UdpSocket
:
:
bind
(
"
127
.
0
.
0
.
1
:
8080
"
)
.
await
?
;
/
/
/
socket
.
connect
(
"
127
.
0
.
0
.
1
:
8081
"
)
.
await
?
;
/
/
/
/
/
/
let
mut
buf
=
Vec
:
:
with_capacity
(
512
)
;
/
/
/
let
len
=
socket
.
recv_buf
(
&
mut
buf
)
.
await
?
;
/
/
/
/
/
/
println
!
(
"
received
{
}
bytes
{
:
?
}
"
len
&
buf
[
.
.
len
]
)
;
/
/
/
/
/
/
Ok
(
(
)
)
/
/
/
}
/
/
/
pub
async
fn
recv_buf
<
B
:
BufMut
>
(
&
self
buf
:
&
mut
B
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
registration
(
)
.
async_io
(
Interest
:
:
READABLE
|
|
{
let
dst
=
buf
.
chunk_mut
(
)
;
let
dst
=
unsafe
{
&
mut
*
(
dst
as
*
mut
_
as
*
mut
[
std
:
:
mem
:
:
MaybeUninit
<
u8
>
]
as
*
mut
[
u8
]
)
}
;
let
n
=
(
*
self
.
io
)
.
recv
(
dst
)
?
;
/
/
Safety
:
We
trust
UdpSocket
:
:
recv
to
have
filled
up
n
bytes
in
the
/
/
buffer
.
unsafe
{
buf
.
advance_mut
(
n
)
;
}
Ok
(
n
)
}
)
.
await
}
/
/
/
Tries
to
receive
a
single
datagram
message
on
the
socket
.
On
success
/
/
/
returns
the
number
of
bytes
read
and
the
origin
.
/
/
/
/
/
/
This
method
must
be
called
with
valid
byte
array
buf
of
sufficient
size
/
/
/
to
hold
the
message
bytes
.
If
a
message
is
too
long
to
fit
in
the
/
/
/
supplied
buffer
excess
bytes
may
be
discarded
.
/
/
/
/
/
/
This
method
can
be
used
even
if
buf
is
uninitialized
.
/
/
/
/
/
/
When
there
is
no
pending
data
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
)
is
/
/
/
returned
.
This
function
is
usually
paired
with
readable
(
)
.
/
/
/
/
/
/
#
Notes
/
/
/
Note
that
the
socket
address
*
*
cannot
*
*
be
implicitly
trusted
because
it
is
relatively
/
/
/
trivial
to
send
a
UDP
datagram
with
a
spoofed
origin
in
a
[
packet
injection
attack
]
.
/
/
/
Because
UDP
is
stateless
and
does
not
validate
the
origin
of
a
packet
/
/
/
the
attacker
does
not
need
to
be
able
to
intercept
traffic
in
order
to
interfere
.
/
/
/
It
is
important
to
be
aware
of
this
when
designing
your
application
-
level
protocol
.
/
/
/
/
/
/
[
packet
injection
attack
]
:
https
:
/
/
en
.
wikipedia
.
org
/
wiki
/
Packet_injection
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
no_run
/
/
/
use
tokio
:
:
net
:
:
UdpSocket
;
/
/
/
use
std
:
:
io
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
-
>
io
:
:
Result
<
(
)
>
{
/
/
/
/
/
Connect
to
a
peer
/
/
/
let
socket
=
UdpSocket
:
:
bind
(
"
127
.
0
.
0
.
1
:
8080
"
)
.
await
?
;
/
/
/
/
/
/
loop
{
/
/
/
/
/
Wait
for
the
socket
to
be
readable
/
/
/
socket
.
readable
(
)
.
await
?
;
/
/
/
/
/
/
let
mut
buf
=
Vec
:
:
with_capacity
(
1024
)
;
/
/
/
/
/
/
/
/
Try
to
recv
data
this
may
still
fail
with
WouldBlock
/
/
/
/
/
if
the
readiness
event
is
a
false
positive
.
/
/
/
match
socket
.
try_recv_buf_from
(
&
mut
buf
)
{
/
/
/
Ok
(
(
n
_addr
)
)
=
>
{
/
/
/
println
!
(
"
GOT
{
:
?
}
"
&
buf
[
.
.
n
]
)
;
/
/
/
break
;
/
/
/
}
/
/
/
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
/
/
/
continue
;
/
/
/
}
/
/
/
Err
(
e
)
=
>
{
/
/
/
return
Err
(
e
)
;
/
/
/
}
/
/
/
}
/
/
/
}
/
/
/
/
/
/
Ok
(
(
)
)
/
/
/
}
/
/
/
pub
fn
try_recv_buf_from
<
B
:
BufMut
>
(
&
self
buf
:
&
mut
B
)
-
>
io
:
:
Result
<
(
usize
SocketAddr
)
>
{
self
.
io
.
registration
(
)
.
try_io
(
Interest
:
:
READABLE
|
|
{
let
dst
=
buf
.
chunk_mut
(
)
;
let
dst
=
unsafe
{
&
mut
*
(
dst
as
*
mut
_
as
*
mut
[
std
:
:
mem
:
:
MaybeUninit
<
u8
>
]
as
*
mut
[
u8
]
)
}
;
let
(
n
addr
)
=
(
*
self
.
io
)
.
recv_from
(
dst
)
?
;
/
/
Safety
:
We
trust
UdpSocket
:
:
recv_from
to
have
filled
up
n
bytes
in
the
/
/
buffer
.
unsafe
{
buf
.
advance_mut
(
n
)
;
}
Ok
(
(
n
addr
)
)
}
)
}
/
/
/
Receives
a
single
datagram
message
on
the
socket
advancing
the
/
/
/
buffer
'
s
internal
cursor
returning
how
many
bytes
were
read
and
the
origin
.
/
/
/
/
/
/
This
method
must
be
called
with
valid
byte
array
buf
of
sufficient
size
/
/
/
to
hold
the
message
bytes
.
If
a
message
is
too
long
to
fit
in
the
/
/
/
supplied
buffer
excess
bytes
may
be
discarded
.
/
/
/
/
/
/
This
method
can
be
used
even
if
buf
is
uninitialized
.
/
/
/
/
/
/
#
Notes
/
/
/
Note
that
the
socket
address
*
*
cannot
*
*
be
implicitly
trusted
because
it
is
relatively
/
/
/
trivial
to
send
a
UDP
datagram
with
a
spoofed
origin
in
a
[
packet
injection
attack
]
.
/
/
/
Because
UDP
is
stateless
and
does
not
validate
the
origin
of
a
packet
/
/
/
the
attacker
does
not
need
to
be
able
to
intercept
traffic
in
order
to
interfere
.
/
/
/
It
is
important
to
be
aware
of
this
when
designing
your
application
-
level
protocol
.
/
/
/
/
/
/
[
packet
injection
attack
]
:
https
:
/
/
en
.
wikipedia
.
org
/
wiki
/
Packet_injection
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
no_run
/
/
/
use
tokio
:
:
net
:
:
UdpSocket
;
/
/
/
use
std
:
:
io
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
-
>
io
:
:
Result
<
(
)
>
{
/
/
/
/
/
Connect
to
a
peer
/
/
/
let
socket
=
UdpSocket
:
:
bind
(
"
127
.
0
.
0
.
1
:
8080
"
)
.
await
?
;
/
/
/
socket
.
connect
(
"
127
.
0
.
0
.
1
:
8081
"
)
.
await
?
;
/
/
/
/
/
/
let
mut
buf
=
Vec
:
:
with_capacity
(
512
)
;
/
/
/
let
(
len
addr
)
=
socket
.
recv_buf_from
(
&
mut
buf
)
.
await
?
;
/
/
/
/
/
/
println
!
(
"
received
{
:
?
}
bytes
from
{
:
?
}
"
len
addr
)
;
/
/
/
/
/
/
Ok
(
(
)
)
/
/
/
}
/
/
/
pub
async
fn
recv_buf_from
<
B
:
BufMut
>
(
&
self
buf
:
&
mut
B
)
-
>
io
:
:
Result
<
(
usize
SocketAddr
)
>
{
self
.
io
.
registration
(
)
.
async_io
(
Interest
:
:
READABLE
|
|
{
let
dst
=
buf
.
chunk_mut
(
)
;
let
dst
=
unsafe
{
&
mut
*
(
dst
as
*
mut
_
as
*
mut
[
std
:
:
mem
:
:
MaybeUninit
<
u8
>
]
as
*
mut
[
u8
]
)
}
;
let
(
n
addr
)
=
(
*
self
.
io
)
.
recv_from
(
dst
)
?
;
/
/
Safety
:
We
trust
UdpSocket
:
:
recv_from
to
have
filled
up
n
bytes
in
the
/
/
buffer
.
unsafe
{
buf
.
advance_mut
(
n
)
;
}
Ok
(
(
n
addr
)
)
}
)
.
await
}
}
pub
async
fn
send_to
<
A
:
ToSocketAddrs
>
(
&
self
buf
:
&
[
u8
]
addr
:
A
)
-
>
io
:
:
Result
<
usize
>
{
let
mut
addrs
=
to_socket_addrs
(
addr
)
.
await
?
;
match
addrs
.
next
(
)
{
Some
(
target
)
=
>
self
.
send_to_addr
(
buf
target
)
.
await
None
=
>
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidInput
"
no
addresses
to
send
data
to
"
)
)
}
}
pub
fn
poll_send_to
(
&
self
cx
:
&
mut
Context
<
'
_
>
buf
:
&
[
u8
]
target
:
SocketAddr
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
self
.
io
.
registration
(
)
.
poll_write_io
(
cx
|
|
self
.
io
.
send_to
(
buf
target
)
)
}
pub
fn
try_send_to
(
&
self
buf
:
&
[
u8
]
target
:
SocketAddr
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
registration
(
)
.
try_io
(
Interest
:
:
WRITABLE
|
|
self
.
io
.
send_to
(
buf
target
)
)
}
async
fn
send_to_addr
(
&
self
buf
:
&
[
u8
]
target
:
SocketAddr
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
registration
(
)
.
async_io
(
Interest
:
:
WRITABLE
|
|
self
.
io
.
send_to
(
buf
target
)
)
.
await
}
pub
async
fn
recv_from
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
(
usize
SocketAddr
)
>
{
self
.
io
.
registration
(
)
.
async_io
(
Interest
:
:
READABLE
|
|
self
.
io
.
recv_from
(
buf
)
)
.
await
}
pub
fn
poll_recv_from
(
&
self
cx
:
&
mut
Context
<
'
_
>
buf
:
&
mut
ReadBuf
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
SocketAddr
>
>
{
#
[
allow
(
clippy
:
:
blocks_in_conditions
)
]
let
(
n
addr
)
=
ready
!
(
self
.
io
.
registration
(
)
.
poll_read_io
(
cx
|
|
{
/
/
Safety
:
will
not
read
the
maybe
uninitialized
bytes
.
let
b
=
unsafe
{
&
mut
*
(
buf
.
unfilled_mut
(
)
as
*
mut
[
std
:
:
mem
:
:
MaybeUninit
<
u8
>
]
as
*
mut
[
u8
]
)
}
;
self
.
io
.
recv_from
(
b
)
}
)
)
?
;
unsafe
{
buf
.
assume_init
(
n
)
;
}
buf
.
advance
(
n
)
;
Poll
:
:
Ready
(
Ok
(
addr
)
)
}
pub
fn
try_recv_from
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
(
usize
SocketAddr
)
>
{
self
.
io
.
registration
(
)
.
try_io
(
Interest
:
:
READABLE
|
|
self
.
io
.
recv_from
(
buf
)
)
}
pub
fn
try_io
<
R
>
(
&
self
interest
:
Interest
f
:
impl
FnOnce
(
)
-
>
io
:
:
Result
<
R
>
)
-
>
io
:
:
Result
<
R
>
{
self
.
io
.
registration
(
)
.
try_io
(
interest
|
|
self
.
io
.
try_io
(
f
)
)
}
pub
async
fn
async_io
<
R
>
(
&
self
interest
:
Interest
mut
f
:
impl
FnMut
(
)
-
>
io
:
:
Result
<
R
>
)
-
>
io
:
:
Result
<
R
>
{
self
.
io
.
registration
(
)
.
async_io
(
interest
|
|
self
.
io
.
try_io
(
&
mut
f
)
)
.
await
}
pub
async
fn
peek
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
registration
(
)
.
async_io
(
Interest
:
:
READABLE
|
|
self
.
io
.
peek
(
buf
)
)
.
await
}
pub
fn
poll_peek
(
&
self
cx
:
&
mut
Context
<
'
_
>
buf
:
&
mut
ReadBuf
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
#
[
allow
(
clippy
:
:
blocks_in_conditions
)
]
let
n
=
ready
!
(
self
.
io
.
registration
(
)
.
poll_read_io
(
cx
|
|
{
/
/
Safety
:
will
not
read
the
maybe
uninitialized
bytes
.
let
b
=
unsafe
{
&
mut
*
(
buf
.
unfilled_mut
(
)
as
*
mut
[
std
:
:
mem
:
:
MaybeUninit
<
u8
>
]
as
*
mut
[
u8
]
)
}
;
self
.
io
.
peek
(
b
)
}
)
)
?
;
unsafe
{
buf
.
assume_init
(
n
)
;
}
buf
.
advance
(
n
)
;
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
pub
fn
try_peek
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
registration
(
)
.
try_io
(
Interest
:
:
READABLE
|
|
self
.
io
.
peek
(
buf
)
)
}
pub
async
fn
peek_from
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
(
usize
SocketAddr
)
>
{
self
.
io
.
registration
(
)
.
async_io
(
Interest
:
:
READABLE
|
|
self
.
io
.
peek_from
(
buf
)
)
.
await
}
pub
fn
poll_peek_from
(
&
self
cx
:
&
mut
Context
<
'
_
>
buf
:
&
mut
ReadBuf
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
SocketAddr
>
>
{
#
[
allow
(
clippy
:
:
blocks_in_conditions
)
]
let
(
n
addr
)
=
ready
!
(
self
.
io
.
registration
(
)
.
poll_read_io
(
cx
|
|
{
/
/
Safety
:
will
not
read
the
maybe
uninitialized
bytes
.
let
b
=
unsafe
{
&
mut
*
(
buf
.
unfilled_mut
(
)
as
*
mut
[
std
:
:
mem
:
:
MaybeUninit
<
u8
>
]
as
*
mut
[
u8
]
)
}
;
self
.
io
.
peek_from
(
b
)
}
)
)
?
;
unsafe
{
buf
.
assume_init
(
n
)
;
}
buf
.
advance
(
n
)
;
Poll
:
:
Ready
(
Ok
(
addr
)
)
}
pub
fn
try_peek_from
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
(
usize
SocketAddr
)
>
{
self
.
io
.
registration
(
)
.
try_io
(
Interest
:
:
READABLE
|
|
self
.
io
.
peek_from
(
buf
)
)
}
pub
async
fn
peek_sender
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
registration
(
)
.
async_io
(
Interest
:
:
READABLE
|
|
self
.
peek_sender_inner
(
)
)
.
await
}
pub
fn
poll_peek_sender
(
&
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
SocketAddr
>
>
{
self
.
io
.
registration
(
)
.
poll_read_io
(
cx
|
|
self
.
peek_sender_inner
(
)
)
}
pub
fn
try_peek_sender
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
registration
(
)
.
try_io
(
Interest
:
:
READABLE
|
|
self
.
peek_sender_inner
(
)
)
}
#
[
inline
]
fn
peek_sender_inner
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
try_io
(
|
|
{
self
.
as_socket
(
)
.
peek_sender
(
)
?
.
as_socket
(
)
.
ok_or_else
(
|
|
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
sender
not
available
"
)
)
}
)
}
pub
fn
broadcast
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
io
.
broadcast
(
)
}
pub
fn
set_broadcast
(
&
self
on
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
set_broadcast
(
on
)
}
pub
fn
multicast_loop_v4
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
io
.
multicast_loop_v4
(
)
}
pub
fn
set_multicast_loop_v4
(
&
self
on
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
set_multicast_loop_v4
(
on
)
}
pub
fn
multicast_ttl_v4
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
io
.
multicast_ttl_v4
(
)
}
pub
fn
set_multicast_ttl_v4
(
&
self
ttl
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
set_multicast_ttl_v4
(
ttl
)
}
pub
fn
multicast_loop_v6
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
io
.
multicast_loop_v6
(
)
}
pub
fn
set_multicast_loop_v6
(
&
self
on
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
set_multicast_loop_v6
(
on
)
}
pub
fn
ttl
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
io
.
ttl
(
)
}
pub
fn
set_ttl
(
&
self
ttl
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
set_ttl
(
ttl
)
}
#
[
cfg
(
not
(
any
(
target_os
=
"
fuchsia
"
target_os
=
"
redox
"
target_os
=
"
solaris
"
target_os
=
"
illumos
"
target_os
=
"
haiku
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
not
(
any
(
target_os
=
"
fuchsia
"
target_os
=
"
redox
"
target_os
=
"
solaris
"
target_os
=
"
illumos
"
target_os
=
"
haiku
"
)
)
)
)
)
]
pub
fn
tos
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
as_socket
(
)
.
tos
(
)
}
#
[
cfg
(
not
(
any
(
target_os
=
"
fuchsia
"
target_os
=
"
redox
"
target_os
=
"
solaris
"
target_os
=
"
illumos
"
target_os
=
"
haiku
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
not
(
any
(
target_os
=
"
fuchsia
"
target_os
=
"
redox
"
target_os
=
"
solaris
"
target_os
=
"
illumos
"
target_os
=
"
haiku
"
)
)
)
)
)
]
pub
fn
set_tos
(
&
self
tos
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
as_socket
(
)
.
set_tos
(
tos
)
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
]
pub
fn
device
(
&
self
)
-
>
io
:
:
Result
<
Option
<
Vec
<
u8
>
>
>
{
self
.
as_socket
(
)
.
device
(
)
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
bind_device
(
&
self
interface
:
Option
<
&
[
u8
]
>
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
as_socket
(
)
.
bind_device
(
interface
)
}
pub
fn
join_multicast_v4
(
&
self
multiaddr
:
Ipv4Addr
interface
:
Ipv4Addr
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
join_multicast_v4
(
&
multiaddr
&
interface
)
}
pub
fn
join_multicast_v6
(
&
self
multiaddr
:
&
Ipv6Addr
interface
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
join_multicast_v6
(
multiaddr
interface
)
}
pub
fn
leave_multicast_v4
(
&
self
multiaddr
:
Ipv4Addr
interface
:
Ipv4Addr
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
leave_multicast_v4
(
&
multiaddr
&
interface
)
}
pub
fn
leave_multicast_v6
(
&
self
multiaddr
:
&
Ipv6Addr
interface
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
leave_multicast_v6
(
multiaddr
interface
)
}
pub
fn
take_error
(
&
self
)
-
>
io
:
:
Result
<
Option
<
io
:
:
Error
>
>
{
self
.
io
.
take_error
(
)
}
}
impl
TryFrom
<
std
:
:
net
:
:
UdpSocket
>
for
UdpSocket
{
type
Error
=
io
:
:
Error
;
fn
try_from
(
stream
:
std
:
:
net
:
:
UdpSocket
)
-
>
Result
<
Self
Self
:
:
Error
>
{
Self
:
:
from_std
(
stream
)
}
}
impl
fmt
:
:
Debug
for
UdpSocket
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
io
.
fmt
(
f
)
}
}
#
[
cfg
(
unix
)
]
mod
sys
{
use
super
:
:
UdpSocket
;
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
*
;
impl
AsRawFd
for
UdpSocket
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
io
.
as_raw_fd
(
)
}
}
impl
AsFd
for
UdpSocket
{
fn
as_fd
(
&
self
)
-
>
BorrowedFd
<
'
_
>
{
unsafe
{
BorrowedFd
:
:
borrow_raw
(
self
.
as_raw_fd
(
)
)
}
}
}
}
cfg_windows
!
{
use
crate
:
:
os
:
:
windows
:
:
io
:
:
{
AsRawSocket
RawSocket
}
;
use
crate
:
:
os
:
:
windows
:
:
io
:
:
{
AsSocket
BorrowedSocket
}
;
impl
AsRawSocket
for
UdpSocket
{
fn
as_raw_socket
(
&
self
)
-
>
RawSocket
{
self
.
io
.
as_raw_socket
(
)
}
}
impl
AsSocket
for
UdpSocket
{
fn
as_socket
(
&
self
)
-
>
BorrowedSocket
<
'
_
>
{
unsafe
{
BorrowedSocket
:
:
borrow_raw
(
self
.
as_raw_socket
(
)
)
}
}
}
}
