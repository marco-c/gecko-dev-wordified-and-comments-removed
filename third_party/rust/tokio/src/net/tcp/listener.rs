use
crate
:
:
io
:
:
{
Interest
PollEvented
}
;
use
crate
:
:
net
:
:
tcp
:
:
TcpStream
;
use
crate
:
:
util
:
:
check_socket_for_blocking
;
cfg_not_wasi
!
{
use
crate
:
:
net
:
:
{
to_socket_addrs
ToSocketAddrs
}
;
}
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
net
:
:
{
self
SocketAddr
}
;
use
std
:
:
task
:
:
{
ready
Context
Poll
}
;
cfg_net
!
{
/
/
/
A
TCP
socket
server
listening
for
connections
.
/
/
/
/
/
/
You
can
accept
a
new
connection
by
using
the
[
accept
]
(
TcpListener
:
:
accept
)
/
/
/
method
.
/
/
/
/
/
/
A
TcpListener
can
be
turned
into
a
Stream
with
[
TcpListenerStream
]
.
/
/
/
/
/
/
[
TcpListenerStream
]
:
https
:
/
/
docs
.
rs
/
tokio
-
stream
/
0
.
1
/
tokio_stream
/
wrappers
/
struct
.
TcpListenerStream
.
html
/
/
/
/
/
/
#
Errors
/
/
/
/
/
/
Note
that
accepting
a
connection
can
lead
to
various
errors
and
not
all
/
/
/
of
them
are
necessarily
fatal
for
example
having
too
many
open
file
/
/
/
descriptors
or
the
other
side
closing
the
connection
while
it
waits
in
/
/
/
an
accept
queue
.
These
would
terminate
the
stream
if
not
handled
in
any
/
/
/
way
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
Using
accept
:
/
/
/
no_run
/
/
/
use
tokio
:
:
net
:
:
TcpListener
;
/
/
/
/
/
/
use
std
:
:
io
;
/
/
/
/
/
/
async
fn
process_socket
<
T
>
(
socket
:
T
)
{
/
/
/
#
drop
(
socket
)
;
/
/
/
/
/
do
work
with
socket
here
/
/
/
}
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
-
>
io
:
:
Result
<
(
)
>
{
/
/
/
let
listener
=
TcpListener
:
:
bind
(
"
127
.
0
.
0
.
1
:
8080
"
)
.
await
?
;
/
/
/
/
/
/
loop
{
/
/
/
let
(
socket
_
)
=
listener
.
accept
(
)
.
await
?
;
/
/
/
process_socket
(
socket
)
.
await
;
/
/
/
}
/
/
/
}
/
/
/
pub
struct
TcpListener
{
io
:
PollEvented
<
mio
:
:
net
:
:
TcpListener
>
}
}
impl
TcpListener
{
cfg_not_wasi
!
{
/
/
/
Creates
a
new
TcpListener
which
will
be
bound
to
the
specified
address
.
/
/
/
/
/
/
The
returned
listener
is
ready
for
accepting
connections
.
/
/
/
/
/
/
Binding
with
a
port
number
of
0
will
request
that
the
OS
assigns
a
port
/
/
/
to
this
listener
.
The
port
allocated
can
be
queried
via
the
local_addr
/
/
/
method
.
/
/
/
/
/
/
The
address
type
can
be
any
implementor
of
the
[
ToSocketAddrs
]
trait
.
/
/
/
If
addr
yields
multiple
addresses
bind
will
be
attempted
with
each
of
/
/
/
the
addresses
until
one
succeeds
and
returns
the
listener
.
If
none
of
/
/
/
the
addresses
succeed
in
creating
a
listener
the
error
returned
from
/
/
/
the
last
attempt
(
the
last
address
)
is
returned
.
/
/
/
/
/
/
This
function
sets
the
SO_REUSEADDR
option
on
the
socket
.
/
/
/
/
/
/
To
configure
the
socket
before
binding
you
can
use
the
[
TcpSocket
]
/
/
/
type
.
/
/
/
/
/
/
[
ToSocketAddrs
]
:
trait
crate
:
:
net
:
:
ToSocketAddrs
/
/
/
[
TcpSocket
]
:
struct
crate
:
:
net
:
:
TcpSocket
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
no_run
/
/
/
use
tokio
:
:
net
:
:
TcpListener
;
/
/
/
use
std
:
:
io
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
-
>
io
:
:
Result
<
(
)
>
{
/
/
/
#
if
cfg
!
(
miri
)
{
return
Ok
(
(
)
)
;
}
/
/
No
socket
in
miri
.
/
/
/
let
listener
=
TcpListener
:
:
bind
(
"
127
.
0
.
0
.
1
:
2345
"
)
.
await
?
;
/
/
/
/
/
/
/
/
use
the
listener
/
/
/
/
/
/
#
let
_
=
listener
;
/
/
/
Ok
(
(
)
)
/
/
/
}
/
/
/
pub
async
fn
bind
<
A
:
ToSocketAddrs
>
(
addr
:
A
)
-
>
io
:
:
Result
<
TcpListener
>
{
let
addrs
=
to_socket_addrs
(
addr
)
.
await
?
;
let
mut
last_err
=
None
;
for
addr
in
addrs
{
match
TcpListener
:
:
bind_addr
(
addr
)
{
Ok
(
listener
)
=
>
return
Ok
(
listener
)
Err
(
e
)
=
>
last_err
=
Some
(
e
)
}
}
Err
(
last_err
.
unwrap_or_else
(
|
|
{
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidInput
"
could
not
resolve
to
any
address
"
)
}
)
)
}
fn
bind_addr
(
addr
:
SocketAddr
)
-
>
io
:
:
Result
<
TcpListener
>
{
let
listener
=
mio
:
:
net
:
:
TcpListener
:
:
bind
(
addr
)
?
;
TcpListener
:
:
new
(
listener
)
}
}
pub
async
fn
accept
(
&
self
)
-
>
io
:
:
Result
<
(
TcpStream
SocketAddr
)
>
{
let
(
mio
addr
)
=
self
.
io
.
registration
(
)
.
async_io
(
Interest
:
:
READABLE
|
|
self
.
io
.
accept
(
)
)
.
await
?
;
let
stream
=
TcpStream
:
:
new
(
mio
)
?
;
Ok
(
(
stream
addr
)
)
}
pub
fn
poll_accept
(
&
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
TcpStream
SocketAddr
)
>
>
{
loop
{
let
ev
=
ready
!
(
self
.
io
.
registration
(
)
.
poll_read_ready
(
cx
)
)
?
;
match
self
.
io
.
accept
(
)
{
Ok
(
(
io
addr
)
)
=
>
{
let
io
=
TcpStream
:
:
new
(
io
)
?
;
return
Poll
:
:
Ready
(
Ok
(
(
io
addr
)
)
)
;
}
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
io
.
registration
(
)
.
clear_readiness
(
ev
)
;
}
Err
(
e
)
=
>
return
Poll
:
:
Ready
(
Err
(
e
)
)
}
}
}
#
[
track_caller
]
pub
fn
from_std
(
listener
:
net
:
:
TcpListener
)
-
>
io
:
:
Result
<
TcpListener
>
{
check_socket_for_blocking
(
&
listener
)
?
;
let
io
=
mio
:
:
net
:
:
TcpListener
:
:
from_std
(
listener
)
;
let
io
=
PollEvented
:
:
new
(
io
)
?
;
Ok
(
TcpListener
{
io
}
)
}
pub
fn
into_std
(
self
)
-
>
io
:
:
Result
<
std
:
:
net
:
:
TcpListener
>
{
#
[
cfg
(
unix
)
]
{
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
FromRawFd
IntoRawFd
}
;
self
.
io
.
into_inner
(
)
.
map
(
IntoRawFd
:
:
into_raw_fd
)
.
map
(
|
raw_fd
|
unsafe
{
std
:
:
net
:
:
TcpListener
:
:
from_raw_fd
(
raw_fd
)
}
)
}
#
[
cfg
(
windows
)
]
{
use
std
:
:
os
:
:
windows
:
:
io
:
:
{
FromRawSocket
IntoRawSocket
}
;
self
.
io
.
into_inner
(
)
.
map
(
|
io
|
io
.
into_raw_socket
(
)
)
.
map
(
|
raw_socket
|
unsafe
{
std
:
:
net
:
:
TcpListener
:
:
from_raw_socket
(
raw_socket
)
}
)
}
#
[
cfg
(
target_os
=
"
wasi
"
)
]
{
use
std
:
:
os
:
:
wasi
:
:
io
:
:
{
FromRawFd
IntoRawFd
}
;
self
.
io
.
into_inner
(
)
.
map
(
|
io
|
io
.
into_raw_fd
(
)
)
.
map
(
|
raw_fd
|
unsafe
{
std
:
:
net
:
:
TcpListener
:
:
from_raw_fd
(
raw_fd
)
}
)
}
}
cfg_not_wasi
!
{
pub
(
crate
)
fn
new
(
listener
:
mio
:
:
net
:
:
TcpListener
)
-
>
io
:
:
Result
<
TcpListener
>
{
let
io
=
PollEvented
:
:
new
(
listener
)
?
;
Ok
(
TcpListener
{
io
}
)
}
}
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
local_addr
(
)
}
pub
fn
ttl
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
io
.
ttl
(
)
}
pub
fn
set_ttl
(
&
self
ttl
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
set_ttl
(
ttl
)
}
}
impl
TryFrom
<
net
:
:
TcpListener
>
for
TcpListener
{
type
Error
=
io
:
:
Error
;
fn
try_from
(
stream
:
net
:
:
TcpListener
)
-
>
Result
<
Self
Self
:
:
Error
>
{
Self
:
:
from_std
(
stream
)
}
}
impl
fmt
:
:
Debug
for
TcpListener
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
io
.
fmt
(
f
)
}
}
#
[
cfg
(
unix
)
]
mod
sys
{
use
super
:
:
TcpListener
;
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
*
;
impl
AsRawFd
for
TcpListener
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
io
.
as_raw_fd
(
)
}
}
impl
AsFd
for
TcpListener
{
fn
as_fd
(
&
self
)
-
>
BorrowedFd
<
'
_
>
{
unsafe
{
BorrowedFd
:
:
borrow_raw
(
self
.
as_raw_fd
(
)
)
}
}
}
}
cfg_unstable
!
{
#
[
cfg
(
target_os
=
"
wasi
"
)
]
mod
sys
{
use
super
:
:
TcpListener
;
use
std
:
:
os
:
:
wasi
:
:
prelude
:
:
*
;
impl
AsRawFd
for
TcpListener
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
io
.
as_raw_fd
(
)
}
}
impl
AsFd
for
TcpListener
{
fn
as_fd
(
&
self
)
-
>
BorrowedFd
<
'
_
>
{
unsafe
{
BorrowedFd
:
:
borrow_raw
(
self
.
as_raw_fd
(
)
)
}
}
}
}
}
cfg_windows
!
{
use
crate
:
:
os
:
:
windows
:
:
io
:
:
{
AsRawSocket
RawSocket
AsSocket
BorrowedSocket
}
;
impl
AsRawSocket
for
TcpListener
{
fn
as_raw_socket
(
&
self
)
-
>
RawSocket
{
self
.
io
.
as_raw_socket
(
)
}
}
impl
AsSocket
for
TcpListener
{
fn
as_socket
(
&
self
)
-
>
BorrowedSocket
<
'
_
>
{
unsafe
{
BorrowedSocket
:
:
borrow_raw
(
self
.
as_raw_socket
(
)
)
}
}
}
}
