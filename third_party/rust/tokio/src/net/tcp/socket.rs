use
crate
:
:
net
:
:
{
TcpListener
TcpStream
}
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
net
:
:
SocketAddr
;
#
[
cfg
(
unix
)
]
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsRawFd
FromRawFd
IntoRawFd
RawFd
}
;
#
[
cfg
(
windows
)
]
use
std
:
:
os
:
:
windows
:
:
io
:
:
{
AsRawSocket
FromRawSocket
IntoRawSocket
RawSocket
}
;
use
std
:
:
time
:
:
Duration
;
cfg_net
!
{
/
/
/
A
TCP
socket
that
has
not
yet
been
converted
to
a
TcpStream
or
/
/
/
TcpListener
.
#
[
cfg_attr
(
docsrs
doc
(
alias
=
"
connect_std
"
)
)
]
pub
struct
TcpSocket
{
inner
:
socket2
:
:
Socket
}
}
impl
TcpSocket
{
pub
fn
new_v4
(
)
-
>
io
:
:
Result
<
TcpSocket
>
{
TcpSocket
:
:
new
(
socket2
:
:
Domain
:
:
IPV4
)
}
pub
fn
new_v6
(
)
-
>
io
:
:
Result
<
TcpSocket
>
{
TcpSocket
:
:
new
(
socket2
:
:
Domain
:
:
IPV6
)
}
fn
new
(
domain
:
socket2
:
:
Domain
)
-
>
io
:
:
Result
<
TcpSocket
>
{
let
ty
=
socket2
:
:
Type
:
:
STREAM
;
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
]
let
ty
=
ty
.
nonblocking
(
)
;
let
inner
=
socket2
:
:
Socket
:
:
new
(
domain
ty
Some
(
socket2
:
:
Protocol
:
:
TCP
)
)
?
;
#
[
cfg
(
not
(
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
)
]
inner
.
set_nonblocking
(
true
)
?
;
Ok
(
TcpSocket
{
inner
}
)
}
pub
fn
set_reuseaddr
(
&
self
reuseaddr
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
inner
.
set_reuse_address
(
reuseaddr
)
}
pub
fn
reuseaddr
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
inner
.
reuse_address
(
)
}
#
[
cfg
(
all
(
unix
not
(
target_os
=
"
solaris
"
)
not
(
target_os
=
"
illumos
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
unix
not
(
target_os
=
"
solaris
"
)
not
(
target_os
=
"
illumos
"
)
)
)
)
)
]
pub
fn
set_reuseport
(
&
self
reuseport
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
inner
.
set_reuse_port
(
reuseport
)
}
#
[
cfg
(
all
(
unix
not
(
target_os
=
"
solaris
"
)
not
(
target_os
=
"
illumos
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
unix
not
(
target_os
=
"
solaris
"
)
not
(
target_os
=
"
illumos
"
)
)
)
)
)
]
pub
fn
reuseport
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
inner
.
reuse_port
(
)
}
pub
fn
set_send_buffer_size
(
&
self
size
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
inner
.
set_send_buffer_size
(
size
as
usize
)
}
pub
fn
send_buffer_size
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
inner
.
send_buffer_size
(
)
.
map
(
|
n
|
n
as
u32
)
}
pub
fn
set_recv_buffer_size
(
&
self
size
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
inner
.
set_recv_buffer_size
(
size
as
usize
)
}
pub
fn
recv_buffer_size
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
inner
.
recv_buffer_size
(
)
.
map
(
|
n
|
n
as
u32
)
}
pub
fn
set_linger
(
&
self
dur
:
Option
<
Duration
>
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
inner
.
set_linger
(
dur
)
}
pub
fn
linger
(
&
self
)
-
>
io
:
:
Result
<
Option
<
Duration
>
>
{
self
.
inner
.
linger
(
)
}
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
inner
.
local_addr
(
)
.
and_then
(
convert_address
)
}
pub
fn
bind
(
&
self
addr
:
SocketAddr
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
inner
.
bind
(
&
addr
.
into
(
)
)
}
pub
async
fn
connect
(
self
addr
:
SocketAddr
)
-
>
io
:
:
Result
<
TcpStream
>
{
if
let
Err
(
err
)
=
self
.
inner
.
connect
(
&
addr
.
into
(
)
)
{
#
[
cfg
(
unix
)
]
if
err
.
raw_os_error
(
)
!
=
Some
(
libc
:
:
EINPROGRESS
)
{
return
Err
(
err
)
;
}
#
[
cfg
(
windows
)
]
if
err
.
kind
(
)
!
=
io
:
:
ErrorKind
:
:
WouldBlock
{
return
Err
(
err
)
;
}
}
#
[
cfg
(
unix
)
]
let
mio
=
{
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
FromRawFd
IntoRawFd
}
;
let
raw_fd
=
self
.
inner
.
into_raw_fd
(
)
;
unsafe
{
mio
:
:
net
:
:
TcpStream
:
:
from_raw_fd
(
raw_fd
)
}
}
;
#
[
cfg
(
windows
)
]
let
mio
=
{
use
std
:
:
os
:
:
windows
:
:
io
:
:
{
FromRawSocket
IntoRawSocket
}
;
let
raw_socket
=
self
.
inner
.
into_raw_socket
(
)
;
unsafe
{
mio
:
:
net
:
:
TcpStream
:
:
from_raw_socket
(
raw_socket
)
}
}
;
TcpStream
:
:
connect_mio
(
mio
)
.
await
}
pub
fn
listen
(
self
backlog
:
u32
)
-
>
io
:
:
Result
<
TcpListener
>
{
self
.
inner
.
listen
(
backlog
as
i32
)
?
;
#
[
cfg
(
unix
)
]
let
mio
=
{
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
FromRawFd
IntoRawFd
}
;
let
raw_fd
=
self
.
inner
.
into_raw_fd
(
)
;
unsafe
{
mio
:
:
net
:
:
TcpListener
:
:
from_raw_fd
(
raw_fd
)
}
}
;
#
[
cfg
(
windows
)
]
let
mio
=
{
use
std
:
:
os
:
:
windows
:
:
io
:
:
{
FromRawSocket
IntoRawSocket
}
;
let
raw_socket
=
self
.
inner
.
into_raw_socket
(
)
;
unsafe
{
mio
:
:
net
:
:
TcpListener
:
:
from_raw_socket
(
raw_socket
)
}
}
;
TcpListener
:
:
new
(
mio
)
}
pub
fn
from_std_stream
(
std_stream
:
std
:
:
net
:
:
TcpStream
)
-
>
TcpSocket
{
#
[
cfg
(
unix
)
]
{
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
FromRawFd
IntoRawFd
}
;
let
raw_fd
=
std_stream
.
into_raw_fd
(
)
;
unsafe
{
TcpSocket
:
:
from_raw_fd
(
raw_fd
)
}
}
#
[
cfg
(
windows
)
]
{
use
std
:
:
os
:
:
windows
:
:
io
:
:
{
FromRawSocket
IntoRawSocket
}
;
let
raw_socket
=
std_stream
.
into_raw_socket
(
)
;
unsafe
{
TcpSocket
:
:
from_raw_socket
(
raw_socket
)
}
}
}
}
fn
convert_address
(
address
:
socket2
:
:
SockAddr
)
-
>
io
:
:
Result
<
SocketAddr
>
{
match
address
.
as_socket
(
)
{
Some
(
address
)
=
>
Ok
(
address
)
None
=
>
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidInput
"
invalid
address
family
(
not
IPv4
or
IPv6
)
"
)
)
}
}
impl
fmt
:
:
Debug
for
TcpSocket
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
inner
.
fmt
(
fmt
)
}
}
#
[
cfg
(
unix
)
]
impl
AsRawFd
for
TcpSocket
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
inner
.
as_raw_fd
(
)
}
}
#
[
cfg
(
unix
)
]
impl
FromRawFd
for
TcpSocket
{
unsafe
fn
from_raw_fd
(
fd
:
RawFd
)
-
>
TcpSocket
{
let
inner
=
socket2
:
:
Socket
:
:
from_raw_fd
(
fd
)
;
TcpSocket
{
inner
}
}
}
#
[
cfg
(
unix
)
]
impl
IntoRawFd
for
TcpSocket
{
fn
into_raw_fd
(
self
)
-
>
RawFd
{
self
.
inner
.
into_raw_fd
(
)
}
}
#
[
cfg
(
windows
)
]
impl
IntoRawSocket
for
TcpSocket
{
fn
into_raw_socket
(
self
)
-
>
RawSocket
{
self
.
inner
.
into_raw_socket
(
)
}
}
#
[
cfg
(
windows
)
]
impl
AsRawSocket
for
TcpSocket
{
fn
as_raw_socket
(
&
self
)
-
>
RawSocket
{
self
.
inner
.
as_raw_socket
(
)
}
}
#
[
cfg
(
windows
)
]
impl
FromRawSocket
for
TcpSocket
{
unsafe
fn
from_raw_socket
(
socket
:
RawSocket
)
-
>
TcpSocket
{
let
inner
=
socket2
:
:
Socket
:
:
from_raw_socket
(
socket
)
;
TcpSocket
{
inner
}
}
}
