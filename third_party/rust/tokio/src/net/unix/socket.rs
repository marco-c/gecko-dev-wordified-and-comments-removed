use
std
:
:
io
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsFd
AsRawFd
BorrowedFd
FromRawFd
IntoRawFd
RawFd
}
;
use
crate
:
:
net
:
:
{
UnixDatagram
UnixListener
UnixStream
}
;
cfg_net_unix
!
{
/
/
/
A
Unix
socket
that
has
not
yet
been
converted
to
a
[
UnixStream
]
[
UnixDatagram
]
or
/
/
/
[
UnixListener
]
.
/
/
/
/
/
/
UnixSocket
wraps
an
operating
system
socket
and
enables
the
caller
to
/
/
/
configure
the
socket
before
establishing
a
connection
or
accepting
/
/
/
inbound
connections
.
The
caller
is
able
to
set
socket
option
and
explicitly
/
/
/
bind
the
socket
with
a
socket
address
.
/
/
/
/
/
/
The
underlying
socket
is
closed
when
the
UnixSocket
value
is
dropped
.
/
/
/
/
/
/
UnixSocket
should
only
be
used
directly
if
the
default
configuration
used
/
/
/
by
[
UnixStream
:
:
connect
]
[
UnixDatagram
:
:
bind
]
and
[
UnixListener
:
:
bind
]
/
/
/
does
not
meet
the
required
use
case
.
/
/
/
/
/
/
Calling
UnixStream
:
:
connect
(
path
)
effectively
performs
the
same
function
as
:
/
/
/
/
/
/
no_run
/
/
/
use
tokio
:
:
net
:
:
UnixSocket
;
/
/
/
use
std
:
:
error
:
:
Error
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
-
>
Result
<
(
)
Box
<
dyn
Error
>
>
{
/
/
/
let
dir
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
/
/
/
let
path
=
dir
.
path
(
)
.
join
(
"
bind_path
"
)
;
/
/
/
let
socket
=
UnixSocket
:
:
new_stream
(
)
?
;
/
/
/
/
/
/
let
stream
=
socket
.
connect
(
path
)
.
await
?
;
/
/
/
/
/
/
Ok
(
(
)
)
/
/
/
}
/
/
/
#
[
derive
(
Debug
)
]
pub
struct
UnixSocket
{
inner
:
socket2
:
:
Socket
}
}
impl
UnixSocket
{
fn
ty
(
&
self
)
-
>
socket2
:
:
Type
{
self
.
inner
.
r
#
type
(
)
.
unwrap
(
)
}
pub
fn
new_datagram
(
)
-
>
io
:
:
Result
<
UnixSocket
>
{
UnixSocket
:
:
new
(
socket2
:
:
Type
:
:
DGRAM
)
}
pub
fn
new_stream
(
)
-
>
io
:
:
Result
<
UnixSocket
>
{
UnixSocket
:
:
new
(
socket2
:
:
Type
:
:
STREAM
)
}
fn
new
(
ty
:
socket2
:
:
Type
)
-
>
io
:
:
Result
<
UnixSocket
>
{
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
]
let
ty
=
ty
.
nonblocking
(
)
;
let
inner
=
socket2
:
:
Socket
:
:
new
(
socket2
:
:
Domain
:
:
UNIX
ty
None
)
?
;
#
[
cfg
(
not
(
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
)
]
inner
.
set_nonblocking
(
true
)
?
;
Ok
(
UnixSocket
{
inner
}
)
}
pub
fn
bind
(
&
self
path
:
impl
AsRef
<
Path
>
)
-
>
io
:
:
Result
<
(
)
>
{
let
addr
=
socket2
:
:
SockAddr
:
:
unix
(
path
)
?
;
self
.
inner
.
bind
(
&
addr
)
}
pub
fn
listen
(
self
backlog
:
u32
)
-
>
io
:
:
Result
<
UnixListener
>
{
if
self
.
ty
(
)
=
=
socket2
:
:
Type
:
:
DGRAM
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
listen
cannot
be
called
on
a
datagram
socket
"
)
)
;
}
self
.
inner
.
listen
(
backlog
as
i32
)
?
;
let
mio
=
{
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
FromRawFd
IntoRawFd
}
;
let
raw_fd
=
self
.
inner
.
into_raw_fd
(
)
;
unsafe
{
mio
:
:
net
:
:
UnixListener
:
:
from_raw_fd
(
raw_fd
)
}
}
;
UnixListener
:
:
new
(
mio
)
}
pub
async
fn
connect
(
self
path
:
impl
AsRef
<
Path
>
)
-
>
io
:
:
Result
<
UnixStream
>
{
if
self
.
ty
(
)
=
=
socket2
:
:
Type
:
:
DGRAM
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
connect
cannot
be
called
on
a
datagram
socket
"
)
)
;
}
let
addr
=
socket2
:
:
SockAddr
:
:
unix
(
path
)
?
;
if
let
Err
(
err
)
=
self
.
inner
.
connect
(
&
addr
)
{
if
err
.
raw_os_error
(
)
!
=
Some
(
libc
:
:
EINPROGRESS
)
{
return
Err
(
err
)
;
}
}
let
mio
=
{
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
FromRawFd
IntoRawFd
}
;
let
raw_fd
=
self
.
inner
.
into_raw_fd
(
)
;
unsafe
{
mio
:
:
net
:
:
UnixStream
:
:
from_raw_fd
(
raw_fd
)
}
}
;
UnixStream
:
:
connect_mio
(
mio
)
.
await
}
pub
fn
datagram
(
self
)
-
>
io
:
:
Result
<
UnixDatagram
>
{
if
self
.
ty
(
)
=
=
socket2
:
:
Type
:
:
STREAM
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
datagram
cannot
be
called
on
a
stream
socket
"
)
)
;
}
let
mio
=
{
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
FromRawFd
IntoRawFd
}
;
let
raw_fd
=
self
.
inner
.
into_raw_fd
(
)
;
unsafe
{
mio
:
:
net
:
:
UnixDatagram
:
:
from_raw_fd
(
raw_fd
)
}
}
;
UnixDatagram
:
:
from_mio
(
mio
)
}
}
impl
AsRawFd
for
UnixSocket
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
inner
.
as_raw_fd
(
)
}
}
impl
AsFd
for
UnixSocket
{
fn
as_fd
(
&
self
)
-
>
BorrowedFd
<
'
_
>
{
unsafe
{
BorrowedFd
:
:
borrow_raw
(
self
.
as_raw_fd
(
)
)
}
}
}
impl
FromRawFd
for
UnixSocket
{
unsafe
fn
from_raw_fd
(
fd
:
RawFd
)
-
>
UnixSocket
{
let
inner
=
socket2
:
:
Socket
:
:
from_raw_fd
(
fd
)
;
UnixSocket
{
inner
}
}
}
impl
IntoRawFd
for
UnixSocket
{
fn
into_raw_fd
(
self
)
-
>
RawFd
{
self
.
inner
.
into_raw_fd
(
)
}
}
