use
crate
:
:
fs
:
:
{
asyncify
File
}
;
use
std
:
:
io
;
use
std
:
:
path
:
:
Path
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
OpenOptions
(
std
:
:
fs
:
:
OpenOptions
)
;
impl
OpenOptions
{
pub
fn
new
(
)
-
>
OpenOptions
{
OpenOptions
(
std
:
:
fs
:
:
OpenOptions
:
:
new
(
)
)
}
pub
fn
read
(
&
mut
self
read
:
bool
)
-
>
&
mut
OpenOptions
{
self
.
0
.
read
(
read
)
;
self
}
pub
fn
write
(
&
mut
self
write
:
bool
)
-
>
&
mut
OpenOptions
{
self
.
0
.
write
(
write
)
;
self
}
pub
fn
append
(
&
mut
self
append
:
bool
)
-
>
&
mut
OpenOptions
{
self
.
0
.
append
(
append
)
;
self
}
pub
fn
truncate
(
&
mut
self
truncate
:
bool
)
-
>
&
mut
OpenOptions
{
self
.
0
.
truncate
(
truncate
)
;
self
}
pub
fn
create
(
&
mut
self
create
:
bool
)
-
>
&
mut
OpenOptions
{
self
.
0
.
create
(
create
)
;
self
}
pub
fn
create_new
(
&
mut
self
create_new
:
bool
)
-
>
&
mut
OpenOptions
{
self
.
0
.
create_new
(
create_new
)
;
self
}
pub
async
fn
open
(
&
self
path
:
impl
AsRef
<
Path
>
)
-
>
io
:
:
Result
<
File
>
{
let
path
=
path
.
as_ref
(
)
.
to_owned
(
)
;
let
opts
=
self
.
0
.
clone
(
)
;
let
std
=
asyncify
(
move
|
|
opts
.
open
(
path
)
)
.
await
?
;
Ok
(
File
:
:
from_std
(
std
)
)
}
#
[
cfg
(
unix
)
]
pub
(
super
)
fn
as_inner_mut
(
&
mut
self
)
-
>
&
mut
std
:
:
fs
:
:
OpenOptions
{
&
mut
self
.
0
}
}
impl
From
<
std
:
:
fs
:
:
OpenOptions
>
for
OpenOptions
{
fn
from
(
options
:
std
:
:
fs
:
:
OpenOptions
)
-
>
OpenOptions
{
OpenOptions
(
options
)
}
}
impl
Default
for
OpenOptions
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
