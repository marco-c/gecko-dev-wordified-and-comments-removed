use
self
:
:
State
:
:
*
;
use
crate
:
:
fs
:
:
asyncify
;
use
crate
:
:
io
:
:
blocking
:
:
Buf
;
use
crate
:
:
io
:
:
{
AsyncRead
AsyncSeek
AsyncWrite
ReadBuf
}
;
use
crate
:
:
sync
:
:
Mutex
;
use
std
:
:
fmt
;
use
std
:
:
fs
:
:
{
Metadata
Permissions
}
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
io
:
:
{
self
Seek
SeekFrom
}
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
task
:
:
Context
;
use
std
:
:
task
:
:
Poll
;
use
std
:
:
task
:
:
Poll
:
:
*
;
#
[
cfg
(
test
)
]
use
super
:
:
mocks
:
:
JoinHandle
;
#
[
cfg
(
test
)
]
use
super
:
:
mocks
:
:
MockFile
as
StdFile
;
#
[
cfg
(
test
)
]
use
super
:
:
mocks
:
:
{
spawn_blocking
spawn_mandatory_blocking
}
;
#
[
cfg
(
not
(
test
)
)
]
use
crate
:
:
blocking
:
:
JoinHandle
;
#
[
cfg
(
not
(
test
)
)
]
use
crate
:
:
blocking
:
:
{
spawn_blocking
spawn_mandatory_blocking
}
;
#
[
cfg
(
not
(
test
)
)
]
use
std
:
:
fs
:
:
File
as
StdFile
;
pub
struct
File
{
std
:
Arc
<
StdFile
>
inner
:
Mutex
<
Inner
>
}
struct
Inner
{
state
:
State
last_write_err
:
Option
<
io
:
:
ErrorKind
>
pos
:
u64
}
#
[
derive
(
Debug
)
]
enum
State
{
Idle
(
Option
<
Buf
>
)
Busy
(
JoinHandle
<
(
Operation
Buf
)
>
)
}
#
[
derive
(
Debug
)
]
enum
Operation
{
Read
(
io
:
:
Result
<
usize
>
)
Write
(
io
:
:
Result
<
(
)
>
)
Seek
(
io
:
:
Result
<
u64
>
)
}
impl
File
{
pub
async
fn
open
(
path
:
impl
AsRef
<
Path
>
)
-
>
io
:
:
Result
<
File
>
{
let
path
=
path
.
as_ref
(
)
.
to_owned
(
)
;
let
std
=
asyncify
(
|
|
StdFile
:
:
open
(
path
)
)
.
await
?
;
Ok
(
File
:
:
from_std
(
std
)
)
}
pub
async
fn
create
(
path
:
impl
AsRef
<
Path
>
)
-
>
io
:
:
Result
<
File
>
{
let
path
=
path
.
as_ref
(
)
.
to_owned
(
)
;
let
std_file
=
asyncify
(
move
|
|
StdFile
:
:
create
(
path
)
)
.
await
?
;
Ok
(
File
:
:
from_std
(
std_file
)
)
}
pub
fn
from_std
(
std
:
StdFile
)
-
>
File
{
File
{
std
:
Arc
:
:
new
(
std
)
inner
:
Mutex
:
:
new
(
Inner
{
state
:
State
:
:
Idle
(
Some
(
Buf
:
:
with_capacity
(
0
)
)
)
last_write_err
:
None
pos
:
0
}
)
}
}
pub
async
fn
sync_all
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
inner
=
self
.
inner
.
lock
(
)
.
await
;
inner
.
complete_inflight
(
)
.
await
;
let
std
=
self
.
std
.
clone
(
)
;
asyncify
(
move
|
|
std
.
sync_all
(
)
)
.
await
}
pub
async
fn
sync_data
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
inner
=
self
.
inner
.
lock
(
)
.
await
;
inner
.
complete_inflight
(
)
.
await
;
let
std
=
self
.
std
.
clone
(
)
;
asyncify
(
move
|
|
std
.
sync_data
(
)
)
.
await
}
pub
async
fn
set_len
(
&
self
size
:
u64
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
inner
=
self
.
inner
.
lock
(
)
.
await
;
inner
.
complete_inflight
(
)
.
await
;
let
mut
buf
=
match
inner
.
state
{
Idle
(
ref
mut
buf_cell
)
=
>
buf_cell
.
take
(
)
.
unwrap
(
)
_
=
>
unreachable
!
(
)
}
;
let
seek
=
if
!
buf
.
is_empty
(
)
{
Some
(
SeekFrom
:
:
Current
(
buf
.
discard_read
(
)
)
)
}
else
{
None
}
;
let
std
=
self
.
std
.
clone
(
)
;
inner
.
state
=
Busy
(
spawn_blocking
(
move
|
|
{
let
res
=
if
let
Some
(
seek
)
=
seek
{
(
&
*
std
)
.
seek
(
seek
)
.
and_then
(
|
_
|
std
.
set_len
(
size
)
)
}
else
{
std
.
set_len
(
size
)
}
.
map
(
|
_
|
0
)
;
(
Operation
:
:
Seek
(
res
)
buf
)
}
)
)
;
let
(
op
buf
)
=
match
inner
.
state
{
Idle
(
_
)
=
>
unreachable
!
(
)
Busy
(
ref
mut
rx
)
=
>
rx
.
await
?
}
;
inner
.
state
=
Idle
(
Some
(
buf
)
)
;
match
op
{
Operation
:
:
Seek
(
res
)
=
>
res
.
map
(
|
pos
|
{
inner
.
pos
=
pos
;
}
)
_
=
>
unreachable
!
(
)
}
}
pub
async
fn
metadata
(
&
self
)
-
>
io
:
:
Result
<
Metadata
>
{
let
std
=
self
.
std
.
clone
(
)
;
asyncify
(
move
|
|
std
.
metadata
(
)
)
.
await
}
pub
async
fn
try_clone
(
&
self
)
-
>
io
:
:
Result
<
File
>
{
let
std
=
self
.
std
.
clone
(
)
;
let
std_file
=
asyncify
(
move
|
|
std
.
try_clone
(
)
)
.
await
?
;
Ok
(
File
:
:
from_std
(
std_file
)
)
}
pub
async
fn
into_std
(
mut
self
)
-
>
StdFile
{
self
.
inner
.
get_mut
(
)
.
complete_inflight
(
)
.
await
;
Arc
:
:
try_unwrap
(
self
.
std
)
.
expect
(
"
Arc
:
:
try_unwrap
failed
"
)
}
pub
fn
try_into_std
(
mut
self
)
-
>
Result
<
StdFile
Self
>
{
match
Arc
:
:
try_unwrap
(
self
.
std
)
{
Ok
(
file
)
=
>
Ok
(
file
)
Err
(
std_file_arc
)
=
>
{
self
.
std
=
std_file_arc
;
Err
(
self
)
}
}
}
pub
async
fn
set_permissions
(
&
self
perm
:
Permissions
)
-
>
io
:
:
Result
<
(
)
>
{
let
std
=
self
.
std
.
clone
(
)
;
asyncify
(
move
|
|
std
.
set_permissions
(
perm
)
)
.
await
}
}
impl
AsyncRead
for
File
{
fn
poll_read
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
dst
:
&
mut
ReadBuf
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
let
me
=
self
.
get_mut
(
)
;
let
inner
=
me
.
inner
.
get_mut
(
)
;
loop
{
match
inner
.
state
{
Idle
(
ref
mut
buf_cell
)
=
>
{
let
mut
buf
=
buf_cell
.
take
(
)
.
unwrap
(
)
;
if
!
buf
.
is_empty
(
)
{
buf
.
copy_to
(
dst
)
;
*
buf_cell
=
Some
(
buf
)
;
return
Ready
(
Ok
(
(
)
)
)
;
}
buf
.
ensure_capacity_for
(
dst
)
;
let
std
=
me
.
std
.
clone
(
)
;
inner
.
state
=
Busy
(
spawn_blocking
(
move
|
|
{
let
res
=
buf
.
read_from
(
&
mut
&
*
std
)
;
(
Operation
:
:
Read
(
res
)
buf
)
}
)
)
;
}
Busy
(
ref
mut
rx
)
=
>
{
let
(
op
mut
buf
)
=
ready
!
(
Pin
:
:
new
(
rx
)
.
poll
(
cx
)
)
?
;
match
op
{
Operation
:
:
Read
(
Ok
(
_
)
)
=
>
{
buf
.
copy_to
(
dst
)
;
inner
.
state
=
Idle
(
Some
(
buf
)
)
;
return
Ready
(
Ok
(
(
)
)
)
;
}
Operation
:
:
Read
(
Err
(
e
)
)
=
>
{
assert
!
(
buf
.
is_empty
(
)
)
;
inner
.
state
=
Idle
(
Some
(
buf
)
)
;
return
Ready
(
Err
(
e
)
)
;
}
Operation
:
:
Write
(
Ok
(
_
)
)
=
>
{
assert
!
(
buf
.
is_empty
(
)
)
;
inner
.
state
=
Idle
(
Some
(
buf
)
)
;
continue
;
}
Operation
:
:
Write
(
Err
(
e
)
)
=
>
{
assert
!
(
inner
.
last_write_err
.
is_none
(
)
)
;
inner
.
last_write_err
=
Some
(
e
.
kind
(
)
)
;
inner
.
state
=
Idle
(
Some
(
buf
)
)
;
}
Operation
:
:
Seek
(
result
)
=
>
{
assert
!
(
buf
.
is_empty
(
)
)
;
inner
.
state
=
Idle
(
Some
(
buf
)
)
;
if
let
Ok
(
pos
)
=
result
{
inner
.
pos
=
pos
;
}
continue
;
}
}
}
}
}
}
}
impl
AsyncSeek
for
File
{
fn
start_seek
(
self
:
Pin
<
&
mut
Self
>
mut
pos
:
SeekFrom
)
-
>
io
:
:
Result
<
(
)
>
{
let
me
=
self
.
get_mut
(
)
;
let
inner
=
me
.
inner
.
get_mut
(
)
;
loop
{
match
inner
.
state
{
Busy
(
_
)
=
>
panic
!
(
"
must
wait
for
poll_complete
before
calling
start_seek
"
)
Idle
(
ref
mut
buf_cell
)
=
>
{
let
mut
buf
=
buf_cell
.
take
(
)
.
unwrap
(
)
;
if
!
buf
.
is_empty
(
)
{
let
n
=
buf
.
discard_read
(
)
;
if
let
SeekFrom
:
:
Current
(
ref
mut
offset
)
=
pos
{
*
offset
+
=
n
;
}
}
let
std
=
me
.
std
.
clone
(
)
;
inner
.
state
=
Busy
(
spawn_blocking
(
move
|
|
{
let
res
=
(
&
*
std
)
.
seek
(
pos
)
;
(
Operation
:
:
Seek
(
res
)
buf
)
}
)
)
;
return
Ok
(
(
)
)
;
}
}
}
}
fn
poll_complete
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
u64
>
>
{
let
inner
=
self
.
inner
.
get_mut
(
)
;
loop
{
match
inner
.
state
{
Idle
(
_
)
=
>
return
Poll
:
:
Ready
(
Ok
(
inner
.
pos
)
)
Busy
(
ref
mut
rx
)
=
>
{
let
(
op
buf
)
=
ready
!
(
Pin
:
:
new
(
rx
)
.
poll
(
cx
)
)
?
;
inner
.
state
=
Idle
(
Some
(
buf
)
)
;
match
op
{
Operation
:
:
Read
(
_
)
=
>
{
}
Operation
:
:
Write
(
Err
(
e
)
)
=
>
{
assert
!
(
inner
.
last_write_err
.
is_none
(
)
)
;
inner
.
last_write_err
=
Some
(
e
.
kind
(
)
)
;
}
Operation
:
:
Write
(
_
)
=
>
{
}
Operation
:
:
Seek
(
res
)
=
>
{
if
let
Ok
(
pos
)
=
res
{
inner
.
pos
=
pos
;
}
return
Ready
(
res
)
;
}
}
}
}
}
}
}
impl
AsyncWrite
for
File
{
fn
poll_write
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
src
:
&
[
u8
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
let
me
=
self
.
get_mut
(
)
;
let
inner
=
me
.
inner
.
get_mut
(
)
;
if
let
Some
(
e
)
=
inner
.
last_write_err
.
take
(
)
{
return
Ready
(
Err
(
e
.
into
(
)
)
)
;
}
loop
{
match
inner
.
state
{
Idle
(
ref
mut
buf_cell
)
=
>
{
let
mut
buf
=
buf_cell
.
take
(
)
.
unwrap
(
)
;
let
seek
=
if
!
buf
.
is_empty
(
)
{
Some
(
SeekFrom
:
:
Current
(
buf
.
discard_read
(
)
)
)
}
else
{
None
}
;
let
n
=
buf
.
copy_from
(
src
)
;
let
std
=
me
.
std
.
clone
(
)
;
let
blocking_task_join_handle
=
spawn_mandatory_blocking
(
move
|
|
{
let
res
=
if
let
Some
(
seek
)
=
seek
{
(
&
*
std
)
.
seek
(
seek
)
.
and_then
(
|
_
|
buf
.
write_to
(
&
mut
&
*
std
)
)
}
else
{
buf
.
write_to
(
&
mut
&
*
std
)
}
;
(
Operation
:
:
Write
(
res
)
buf
)
}
)
.
ok_or_else
(
|
|
{
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
background
task
failed
"
)
}
)
?
;
inner
.
state
=
Busy
(
blocking_task_join_handle
)
;
return
Ready
(
Ok
(
n
)
)
;
}
Busy
(
ref
mut
rx
)
=
>
{
let
(
op
buf
)
=
ready
!
(
Pin
:
:
new
(
rx
)
.
poll
(
cx
)
)
?
;
inner
.
state
=
Idle
(
Some
(
buf
)
)
;
match
op
{
Operation
:
:
Read
(
_
)
=
>
{
continue
;
}
Operation
:
:
Write
(
res
)
=
>
{
res
?
;
continue
;
}
Operation
:
:
Seek
(
_
)
=
>
{
continue
;
}
}
}
}
}
}
fn
poll_flush
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
io
:
:
Error
>
>
{
let
inner
=
self
.
inner
.
get_mut
(
)
;
inner
.
poll_flush
(
cx
)
}
fn
poll_shutdown
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
io
:
:
Error
>
>
{
self
.
poll_flush
(
cx
)
}
}
impl
From
<
StdFile
>
for
File
{
fn
from
(
std
:
StdFile
)
-
>
Self
{
Self
:
:
from_std
(
std
)
}
}
impl
fmt
:
:
Debug
for
File
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
tokio
:
:
fs
:
:
File
"
)
.
field
(
"
std
"
&
self
.
std
)
.
finish
(
)
}
}
#
[
cfg
(
unix
)
]
impl
std
:
:
os
:
:
unix
:
:
io
:
:
AsRawFd
for
File
{
fn
as_raw_fd
(
&
self
)
-
>
std
:
:
os
:
:
unix
:
:
io
:
:
RawFd
{
self
.
std
.
as_raw_fd
(
)
}
}
#
[
cfg
(
unix
)
]
impl
std
:
:
os
:
:
unix
:
:
io
:
:
FromRawFd
for
File
{
unsafe
fn
from_raw_fd
(
fd
:
std
:
:
os
:
:
unix
:
:
io
:
:
RawFd
)
-
>
Self
{
StdFile
:
:
from_raw_fd
(
fd
)
.
into
(
)
}
}
#
[
cfg
(
windows
)
]
impl
std
:
:
os
:
:
windows
:
:
io
:
:
AsRawHandle
for
File
{
fn
as_raw_handle
(
&
self
)
-
>
std
:
:
os
:
:
windows
:
:
io
:
:
RawHandle
{
self
.
std
.
as_raw_handle
(
)
}
}
#
[
cfg
(
windows
)
]
impl
std
:
:
os
:
:
windows
:
:
io
:
:
FromRawHandle
for
File
{
unsafe
fn
from_raw_handle
(
handle
:
std
:
:
os
:
:
windows
:
:
io
:
:
RawHandle
)
-
>
Self
{
StdFile
:
:
from_raw_handle
(
handle
)
.
into
(
)
}
}
impl
Inner
{
async
fn
complete_inflight
(
&
mut
self
)
{
use
crate
:
:
future
:
:
poll_fn
;
if
let
Err
(
e
)
=
poll_fn
(
|
cx
|
Pin
:
:
new
(
&
mut
*
self
)
.
poll_flush
(
cx
)
)
.
await
{
self
.
last_write_err
=
Some
(
e
.
kind
(
)
)
;
}
}
fn
poll_flush
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
io
:
:
Error
>
>
{
if
let
Some
(
e
)
=
self
.
last_write_err
.
take
(
)
{
return
Ready
(
Err
(
e
.
into
(
)
)
)
;
}
let
(
op
buf
)
=
match
self
.
state
{
Idle
(
_
)
=
>
return
Ready
(
Ok
(
(
)
)
)
Busy
(
ref
mut
rx
)
=
>
ready
!
(
Pin
:
:
new
(
rx
)
.
poll
(
cx
)
)
?
}
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
match
op
{
Operation
:
:
Read
(
_
)
=
>
Ready
(
Ok
(
(
)
)
)
Operation
:
:
Write
(
res
)
=
>
Ready
(
res
)
Operation
:
:
Seek
(
_
)
=
>
Ready
(
Ok
(
(
)
)
)
}
}
}
#
[
cfg
(
test
)
]
mod
tests
;
