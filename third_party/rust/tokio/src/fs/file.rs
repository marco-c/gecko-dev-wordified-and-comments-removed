use
self
:
:
State
:
:
*
;
use
crate
:
:
fs
:
:
{
asyncify
sys
}
;
use
crate
:
:
io
:
:
blocking
:
:
Buf
;
use
crate
:
:
io
:
:
{
AsyncRead
AsyncSeek
AsyncWrite
}
;
use
std
:
:
fmt
;
use
std
:
:
fs
:
:
{
Metadata
Permissions
}
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
io
:
:
{
self
Seek
SeekFrom
}
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
task
:
:
Context
;
use
std
:
:
task
:
:
Poll
;
use
std
:
:
task
:
:
Poll
:
:
*
;
pub
struct
File
{
std
:
Arc
<
sys
:
:
File
>
state
:
State
last_write_err
:
Option
<
io
:
:
ErrorKind
>
}
#
[
derive
(
Debug
)
]
enum
State
{
Idle
(
Option
<
Buf
>
)
Busy
(
sys
:
:
Blocking
<
(
Operation
Buf
)
>
)
}
#
[
derive
(
Debug
)
]
enum
Operation
{
Read
(
io
:
:
Result
<
usize
>
)
Write
(
io
:
:
Result
<
(
)
>
)
Seek
(
io
:
:
Result
<
u64
>
)
}
impl
File
{
pub
async
fn
open
(
path
:
impl
AsRef
<
Path
>
)
-
>
io
:
:
Result
<
File
>
{
let
path
=
path
.
as_ref
(
)
.
to_owned
(
)
;
let
std
=
asyncify
(
|
|
sys
:
:
File
:
:
open
(
path
)
)
.
await
?
;
Ok
(
File
:
:
from_std
(
std
)
)
}
pub
async
fn
create
(
path
:
impl
AsRef
<
Path
>
)
-
>
io
:
:
Result
<
File
>
{
let
path
=
path
.
as_ref
(
)
.
to_owned
(
)
;
let
std_file
=
asyncify
(
move
|
|
sys
:
:
File
:
:
create
(
path
)
)
.
await
?
;
Ok
(
File
:
:
from_std
(
std_file
)
)
}
pub
fn
from_std
(
std
:
sys
:
:
File
)
-
>
File
{
File
{
std
:
Arc
:
:
new
(
std
)
state
:
State
:
:
Idle
(
Some
(
Buf
:
:
with_capacity
(
0
)
)
)
last_write_err
:
None
}
}
pub
async
fn
seek
(
&
mut
self
mut
pos
:
SeekFrom
)
-
>
io
:
:
Result
<
u64
>
{
self
.
complete_inflight
(
)
.
await
;
let
mut
buf
=
match
self
.
state
{
Idle
(
ref
mut
buf_cell
)
=
>
buf_cell
.
take
(
)
.
unwrap
(
)
_
=
>
unreachable
!
(
)
}
;
if
!
buf
.
is_empty
(
)
{
let
n
=
buf
.
discard_read
(
)
;
if
let
SeekFrom
:
:
Current
(
ref
mut
offset
)
=
pos
{
*
offset
+
=
n
;
}
}
let
std
=
self
.
std
.
clone
(
)
;
self
.
state
=
Busy
(
sys
:
:
run
(
move
|
|
{
let
res
=
(
&
*
std
)
.
seek
(
pos
)
;
(
Operation
:
:
Seek
(
res
)
buf
)
}
)
)
;
let
(
op
buf
)
=
match
self
.
state
{
Idle
(
_
)
=
>
unreachable
!
(
)
Busy
(
ref
mut
rx
)
=
>
rx
.
await
.
unwrap
(
)
}
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
match
op
{
Operation
:
:
Seek
(
res
)
=
>
res
_
=
>
unreachable
!
(
)
}
}
pub
async
fn
sync_all
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
complete_inflight
(
)
.
await
;
let
std
=
self
.
std
.
clone
(
)
;
asyncify
(
move
|
|
std
.
sync_all
(
)
)
.
await
}
pub
async
fn
sync_data
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
complete_inflight
(
)
.
await
;
let
std
=
self
.
std
.
clone
(
)
;
asyncify
(
move
|
|
std
.
sync_data
(
)
)
.
await
}
pub
async
fn
set_len
(
&
mut
self
size
:
u64
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
complete_inflight
(
)
.
await
;
let
mut
buf
=
match
self
.
state
{
Idle
(
ref
mut
buf_cell
)
=
>
buf_cell
.
take
(
)
.
unwrap
(
)
_
=
>
unreachable
!
(
)
}
;
let
seek
=
if
!
buf
.
is_empty
(
)
{
Some
(
SeekFrom
:
:
Current
(
buf
.
discard_read
(
)
)
)
}
else
{
None
}
;
let
std
=
self
.
std
.
clone
(
)
;
self
.
state
=
Busy
(
sys
:
:
run
(
move
|
|
{
let
res
=
if
let
Some
(
seek
)
=
seek
{
(
&
*
std
)
.
seek
(
seek
)
.
and_then
(
|
_
|
std
.
set_len
(
size
)
)
}
else
{
std
.
set_len
(
size
)
}
.
map
(
|
_
|
0
)
;
(
Operation
:
:
Seek
(
res
)
buf
)
}
)
)
;
let
(
op
buf
)
=
match
self
.
state
{
Idle
(
_
)
=
>
unreachable
!
(
)
Busy
(
ref
mut
rx
)
=
>
rx
.
await
?
}
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
match
op
{
Operation
:
:
Seek
(
res
)
=
>
res
.
map
(
|
_
|
(
)
)
_
=
>
unreachable
!
(
)
}
}
pub
async
fn
metadata
(
&
self
)
-
>
io
:
:
Result
<
Metadata
>
{
let
std
=
self
.
std
.
clone
(
)
;
asyncify
(
move
|
|
std
.
metadata
(
)
)
.
await
}
pub
async
fn
try_clone
(
&
self
)
-
>
io
:
:
Result
<
File
>
{
let
std
=
self
.
std
.
clone
(
)
;
let
std_file
=
asyncify
(
move
|
|
std
.
try_clone
(
)
)
.
await
?
;
Ok
(
File
:
:
from_std
(
std_file
)
)
}
pub
async
fn
into_std
(
mut
self
)
-
>
sys
:
:
File
{
self
.
complete_inflight
(
)
.
await
;
Arc
:
:
try_unwrap
(
self
.
std
)
.
expect
(
"
Arc
:
:
try_unwrap
failed
"
)
}
pub
fn
try_into_std
(
mut
self
)
-
>
Result
<
sys
:
:
File
Self
>
{
match
Arc
:
:
try_unwrap
(
self
.
std
)
{
Ok
(
file
)
=
>
Ok
(
file
)
Err
(
std_file_arc
)
=
>
{
self
.
std
=
std_file_arc
;
Err
(
self
)
}
}
}
pub
async
fn
set_permissions
(
&
self
perm
:
Permissions
)
-
>
io
:
:
Result
<
(
)
>
{
let
std
=
self
.
std
.
clone
(
)
;
asyncify
(
move
|
|
std
.
set_permissions
(
perm
)
)
.
await
}
async
fn
complete_inflight
(
&
mut
self
)
{
use
crate
:
:
future
:
:
poll_fn
;
if
let
Err
(
e
)
=
poll_fn
(
|
cx
|
Pin
:
:
new
(
&
mut
*
self
)
.
poll_flush
(
cx
)
)
.
await
{
self
.
last_write_err
=
Some
(
e
.
kind
(
)
)
;
}
}
}
impl
AsyncRead
for
File
{
unsafe
fn
prepare_uninitialized_buffer
(
&
self
_buf
:
&
mut
[
std
:
:
mem
:
:
MaybeUninit
<
u8
>
]
)
-
>
bool
{
false
}
fn
poll_read
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
dst
:
&
mut
[
u8
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
loop
{
match
self
.
state
{
Idle
(
ref
mut
buf_cell
)
=
>
{
let
mut
buf
=
buf_cell
.
take
(
)
.
unwrap
(
)
;
if
!
buf
.
is_empty
(
)
{
let
n
=
buf
.
copy_to
(
dst
)
;
*
buf_cell
=
Some
(
buf
)
;
return
Ready
(
Ok
(
n
)
)
;
}
buf
.
ensure_capacity_for
(
dst
)
;
let
std
=
self
.
std
.
clone
(
)
;
self
.
state
=
Busy
(
sys
:
:
run
(
move
|
|
{
let
res
=
buf
.
read_from
(
&
mut
&
*
std
)
;
(
Operation
:
:
Read
(
res
)
buf
)
}
)
)
;
}
Busy
(
ref
mut
rx
)
=
>
{
let
(
op
mut
buf
)
=
ready
!
(
Pin
:
:
new
(
rx
)
.
poll
(
cx
)
)
?
;
match
op
{
Operation
:
:
Read
(
Ok
(
_
)
)
=
>
{
let
n
=
buf
.
copy_to
(
dst
)
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
return
Ready
(
Ok
(
n
)
)
;
}
Operation
:
:
Read
(
Err
(
e
)
)
=
>
{
assert
!
(
buf
.
is_empty
(
)
)
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
return
Ready
(
Err
(
e
)
)
;
}
Operation
:
:
Write
(
Ok
(
_
)
)
=
>
{
assert
!
(
buf
.
is_empty
(
)
)
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
continue
;
}
Operation
:
:
Write
(
Err
(
e
)
)
=
>
{
assert
!
(
self
.
last_write_err
.
is_none
(
)
)
;
self
.
last_write_err
=
Some
(
e
.
kind
(
)
)
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
}
Operation
:
:
Seek
(
_
)
=
>
{
assert
!
(
buf
.
is_empty
(
)
)
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
continue
;
}
}
}
}
}
}
}
impl
AsyncSeek
for
File
{
fn
start_seek
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
mut
pos
:
SeekFrom
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
loop
{
match
self
.
state
{
Idle
(
ref
mut
buf_cell
)
=
>
{
let
mut
buf
=
buf_cell
.
take
(
)
.
unwrap
(
)
;
if
!
buf
.
is_empty
(
)
{
let
n
=
buf
.
discard_read
(
)
;
if
let
SeekFrom
:
:
Current
(
ref
mut
offset
)
=
pos
{
*
offset
+
=
n
;
}
}
let
std
=
self
.
std
.
clone
(
)
;
self
.
state
=
Busy
(
sys
:
:
run
(
move
|
|
{
let
res
=
(
&
*
std
)
.
seek
(
pos
)
;
(
Operation
:
:
Seek
(
res
)
buf
)
}
)
)
;
return
Ready
(
Ok
(
(
)
)
)
;
}
Busy
(
ref
mut
rx
)
=
>
{
let
(
op
buf
)
=
ready
!
(
Pin
:
:
new
(
rx
)
.
poll
(
cx
)
)
?
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
match
op
{
Operation
:
:
Read
(
_
)
=
>
{
}
Operation
:
:
Write
(
Err
(
e
)
)
=
>
{
assert
!
(
self
.
last_write_err
.
is_none
(
)
)
;
self
.
last_write_err
=
Some
(
e
.
kind
(
)
)
;
}
Operation
:
:
Write
(
_
)
=
>
{
}
Operation
:
:
Seek
(
_
)
=
>
{
}
}
}
}
}
}
fn
poll_complete
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
u64
>
>
{
loop
{
match
self
.
state
{
Idle
(
_
)
=
>
panic
!
(
"
must
call
start_seek
before
calling
poll_complete
"
)
Busy
(
ref
mut
rx
)
=
>
{
let
(
op
buf
)
=
ready
!
(
Pin
:
:
new
(
rx
)
.
poll
(
cx
)
)
?
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
match
op
{
Operation
:
:
Read
(
_
)
=
>
{
}
Operation
:
:
Write
(
Err
(
e
)
)
=
>
{
assert
!
(
self
.
last_write_err
.
is_none
(
)
)
;
self
.
last_write_err
=
Some
(
e
.
kind
(
)
)
;
}
Operation
:
:
Write
(
_
)
=
>
{
}
Operation
:
:
Seek
(
res
)
=
>
return
Ready
(
res
)
}
}
}
}
}
}
impl
AsyncWrite
for
File
{
fn
poll_write
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
src
:
&
[
u8
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
if
let
Some
(
e
)
=
self
.
last_write_err
.
take
(
)
{
return
Ready
(
Err
(
e
.
into
(
)
)
)
;
}
loop
{
match
self
.
state
{
Idle
(
ref
mut
buf_cell
)
=
>
{
let
mut
buf
=
buf_cell
.
take
(
)
.
unwrap
(
)
;
let
seek
=
if
!
buf
.
is_empty
(
)
{
Some
(
SeekFrom
:
:
Current
(
buf
.
discard_read
(
)
)
)
}
else
{
None
}
;
let
n
=
buf
.
copy_from
(
src
)
;
let
std
=
self
.
std
.
clone
(
)
;
self
.
state
=
Busy
(
sys
:
:
run
(
move
|
|
{
let
res
=
if
let
Some
(
seek
)
=
seek
{
(
&
*
std
)
.
seek
(
seek
)
.
and_then
(
|
_
|
buf
.
write_to
(
&
mut
&
*
std
)
)
}
else
{
buf
.
write_to
(
&
mut
&
*
std
)
}
;
(
Operation
:
:
Write
(
res
)
buf
)
}
)
)
;
return
Ready
(
Ok
(
n
)
)
;
}
Busy
(
ref
mut
rx
)
=
>
{
let
(
op
buf
)
=
ready
!
(
Pin
:
:
new
(
rx
)
.
poll
(
cx
)
)
?
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
match
op
{
Operation
:
:
Read
(
_
)
=
>
{
continue
;
}
Operation
:
:
Write
(
res
)
=
>
{
res
?
;
continue
;
}
Operation
:
:
Seek
(
_
)
=
>
{
continue
;
}
}
}
}
}
}
fn
poll_flush
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
io
:
:
Error
>
>
{
if
let
Some
(
e
)
=
self
.
last_write_err
.
take
(
)
{
return
Ready
(
Err
(
e
.
into
(
)
)
)
;
}
let
(
op
buf
)
=
match
self
.
state
{
Idle
(
_
)
=
>
return
Ready
(
Ok
(
(
)
)
)
Busy
(
ref
mut
rx
)
=
>
ready
!
(
Pin
:
:
new
(
rx
)
.
poll
(
cx
)
)
?
}
;
self
.
state
=
Idle
(
Some
(
buf
)
)
;
match
op
{
Operation
:
:
Read
(
_
)
=
>
Ready
(
Ok
(
(
)
)
)
Operation
:
:
Write
(
res
)
=
>
Ready
(
res
)
Operation
:
:
Seek
(
_
)
=
>
Ready
(
Ok
(
(
)
)
)
}
}
fn
poll_shutdown
(
self
:
Pin
<
&
mut
Self
>
_cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
io
:
:
Error
>
>
{
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
}
impl
From
<
sys
:
:
File
>
for
File
{
fn
from
(
std
:
sys
:
:
File
)
-
>
Self
{
Self
:
:
from_std
(
std
)
}
}
impl
fmt
:
:
Debug
for
File
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
tokio
:
:
fs
:
:
File
"
)
.
field
(
"
std
"
&
self
.
std
)
.
finish
(
)
}
}
#
[
cfg
(
unix
)
]
impl
std
:
:
os
:
:
unix
:
:
io
:
:
AsRawFd
for
File
{
fn
as_raw_fd
(
&
self
)
-
>
std
:
:
os
:
:
unix
:
:
io
:
:
RawFd
{
self
.
std
.
as_raw_fd
(
)
}
}
#
[
cfg
(
windows
)
]
impl
std
:
:
os
:
:
windows
:
:
io
:
:
AsRawHandle
for
File
{
fn
as_raw_handle
(
&
self
)
-
>
std
:
:
os
:
:
windows
:
:
io
:
:
RawHandle
{
self
.
std
.
as_raw_handle
(
)
}
}
