use
std
:
:
cell
:
:
Cell
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
const
BUDGET
:
usize
=
128
;
const
UNCONSTRAINED
:
usize
=
usize
:
:
max_value
(
)
;
thread_local
!
{
static
HITS
:
Cell
<
usize
>
=
Cell
:
:
new
(
UNCONSTRAINED
)
;
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
budget
<
F
R
>
(
f
:
F
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
{
HITS
.
with
(
move
|
hits
|
{
if
hits
.
get
(
)
!
=
UNCONSTRAINED
{
return
f
(
)
;
}
struct
Guard
<
'
a
>
(
&
'
a
Cell
<
usize
>
)
;
impl
<
'
a
>
Drop
for
Guard
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
self
.
0
.
set
(
UNCONSTRAINED
)
;
}
}
hits
.
set
(
BUDGET
)
;
let
_guard
=
Guard
(
hits
)
;
f
(
)
}
)
}
cfg_rt_threaded
!
{
#
[
inline
(
always
)
]
pub
(
crate
)
fn
has_budget_remaining
(
)
-
>
bool
{
HITS
.
with
(
|
hits
|
hits
.
get
(
)
>
0
)
}
}
cfg_blocking_impl
!
{
/
/
/
Forcibly
remove
the
budgeting
constraints
early
.
pub
(
crate
)
fn
stop
(
)
{
HITS
.
with
(
|
hits
|
{
hits
.
set
(
UNCONSTRAINED
)
;
}
)
;
}
}
#
[
allow
(
unreachable_pub
dead_code
)
]
pub
fn
limit
<
R
>
(
bound
:
usize
f
:
impl
FnOnce
(
)
-
>
R
)
-
>
R
{
HITS
.
with
(
|
hits
|
{
let
budget
=
hits
.
get
(
)
;
let
bound
=
std
:
:
cmp
:
:
min
(
budget
bound
)
;
let
floor
=
budget
.
saturating_sub
(
bound
)
;
struct
RestoreBudget
<
'
a
>
(
&
'
a
Cell
<
usize
>
usize
)
;
impl
<
'
a
>
Drop
for
RestoreBudget
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
let
left
=
self
.
0
.
get
(
)
;
self
.
0
.
set
(
self
.
1
+
left
)
;
}
}
hits
.
set
(
bound
)
;
let
_restore
=
RestoreBudget
(
&
hits
floor
)
;
f
(
)
}
)
}
#
[
allow
(
unreachable_pub
dead_code
)
]
#
[
inline
]
pub
fn
poll_proceed
(
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
(
)
>
{
HITS
.
with
(
|
hits
|
{
let
n
=
hits
.
get
(
)
;
if
n
=
=
UNCONSTRAINED
{
Poll
:
:
Ready
(
(
)
)
}
else
if
n
=
=
0
{
cx
.
waker
(
)
.
wake_by_ref
(
)
;
Poll
:
:
Pending
}
else
{
hits
.
set
(
n
.
saturating_sub
(
1
)
)
;
Poll
:
:
Ready
(
(
)
)
}
}
)
}
#
[
allow
(
unreachable_pub
dead_code
)
]
#
[
inline
]
pub
async
fn
proceed
(
)
{
use
crate
:
:
future
:
:
poll_fn
;
poll_fn
(
|
cx
|
poll_proceed
(
cx
)
)
.
await
;
}
pin_project_lite
:
:
pin_project
!
{
/
/
/
A
future
that
cooperatively
yields
to
the
task
scheduler
when
polling
/
/
/
if
the
task
'
s
budget
is
exhausted
.
/
/
/
/
/
/
Internally
this
is
simply
a
future
combinator
which
calls
/
/
/
[
poll_proceed
]
in
its
poll
implementation
before
polling
the
wrapped
/
/
/
future
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
rust
ignore
/
/
/
#
#
[
tokio
:
:
main
]
/
/
/
#
async
fn
main
(
)
{
/
/
/
use
tokio
:
:
coop
:
:
CoopFutureExt
;
/
/
/
/
/
/
async
{
/
*
.
.
.
*
/
}
/
/
/
.
cooperate
(
)
/
/
/
.
await
;
/
/
/
#
}
/
/
/
/
/
/
/
/
/
[
poll_proceed
]
:
fn
poll_proceed
#
[
derive
(
Debug
)
]
#
[
allow
(
unreachable_pub
dead_code
)
]
pub
struct
CoopFuture
<
F
>
{
#
[
pin
]
future
:
F
}
}
impl
<
F
:
Future
>
Future
for
CoopFuture
<
F
>
{
type
Output
=
F
:
:
Output
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
ready
!
(
poll_proceed
(
cx
)
)
;
self
.
project
(
)
.
future
.
poll
(
cx
)
}
}
impl
<
F
:
Future
>
CoopFuture
<
F
>
{
#
[
allow
(
unreachable_pub
dead_code
)
]
pub
fn
new
(
future
:
F
)
-
>
Self
{
Self
{
future
}
}
}
cfg_sync
!
{
/
/
/
Extension
trait
providing
Future
:
:
cooperate
extension
method
.
/
/
/
/
/
/
Note
:
if
/
when
the
co
-
op
API
becomes
public
this
method
should
probably
be
/
/
/
provided
by
FutureExt
instead
.
pub
(
crate
)
trait
CoopFutureExt
:
Future
{
/
/
/
Wrap
self
to
cooperatively
yield
to
the
scheduler
when
polling
if
the
/
/
/
task
'
s
budget
is
exhausted
.
fn
cooperate
(
self
)
-
>
CoopFuture
<
Self
>
where
Self
:
Sized
{
CoopFuture
:
:
new
(
self
)
}
}
impl
<
F
>
CoopFutureExt
for
F
where
F
:
Future
{
}
}
#
[
cfg
(
all
(
test
not
(
loom
)
)
)
]
mod
test
{
use
super
:
:
*
;
fn
get
(
)
-
>
usize
{
HITS
.
with
(
|
hits
|
hits
.
get
(
)
)
}
#
[
test
]
fn
bugeting
(
)
{
use
tokio_test
:
:
*
;
assert_eq
!
(
get
(
)
UNCONSTRAINED
)
;
assert_ready
!
(
task
:
:
spawn
(
(
)
)
.
enter
(
|
cx
_
|
poll_proceed
(
cx
)
)
)
;
assert_eq
!
(
get
(
)
UNCONSTRAINED
)
;
budget
(
|
|
{
assert_eq
!
(
get
(
)
BUDGET
)
;
assert_ready
!
(
task
:
:
spawn
(
(
)
)
.
enter
(
|
cx
_
|
poll_proceed
(
cx
)
)
)
;
assert_eq
!
(
get
(
)
BUDGET
-
1
)
;
assert_ready
!
(
task
:
:
spawn
(
(
)
)
.
enter
(
|
cx
_
|
poll_proceed
(
cx
)
)
)
;
assert_eq
!
(
get
(
)
BUDGET
-
2
)
;
}
)
;
assert_eq
!
(
get
(
)
UNCONSTRAINED
)
;
budget
(
|
|
{
limit
(
3
|
|
{
assert_eq
!
(
get
(
)
3
)
;
assert_ready
!
(
task
:
:
spawn
(
(
)
)
.
enter
(
|
cx
_
|
poll_proceed
(
cx
)
)
)
;
assert_eq
!
(
get
(
)
2
)
;
limit
(
4
|
|
{
assert_eq
!
(
get
(
)
2
)
;
assert_ready
!
(
task
:
:
spawn
(
(
)
)
.
enter
(
|
cx
_
|
poll_proceed
(
cx
)
)
)
;
assert_eq
!
(
get
(
)
1
)
;
}
)
;
assert_eq
!
(
get
(
)
1
)
;
assert_ready
!
(
task
:
:
spawn
(
(
)
)
.
enter
(
|
cx
_
|
poll_proceed
(
cx
)
)
)
;
assert_eq
!
(
get
(
)
0
)
;
assert_pending
!
(
task
:
:
spawn
(
(
)
)
.
enter
(
|
cx
_
|
poll_proceed
(
cx
)
)
)
;
assert_eq
!
(
get
(
)
0
)
;
assert_pending
!
(
task
:
:
spawn
(
(
)
)
.
enter
(
|
cx
_
|
poll_proceed
(
cx
)
)
)
;
assert_eq
!
(
get
(
)
0
)
;
}
)
;
assert_eq
!
(
get
(
)
BUDGET
-
3
)
;
assert_ready
!
(
task
:
:
spawn
(
(
)
)
.
enter
(
|
cx
_
|
poll_proceed
(
cx
)
)
)
;
assert_eq
!
(
get
(
)
BUDGET
-
4
)
;
assert_ready
!
(
task
:
:
spawn
(
proceed
(
)
)
.
poll
(
)
)
;
assert_eq
!
(
get
(
)
BUDGET
-
5
)
;
}
)
;
}
}
