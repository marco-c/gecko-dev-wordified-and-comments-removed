use
std
:
:
cell
:
:
Cell
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
FastRand
{
one
:
Cell
<
u32
>
two
:
Cell
<
u32
>
}
impl
FastRand
{
pub
(
crate
)
fn
new
(
seed
:
u64
)
-
>
FastRand
{
let
one
=
(
seed
>
>
32
)
as
u32
;
let
mut
two
=
seed
as
u32
;
if
two
=
=
0
{
two
=
1
;
}
FastRand
{
one
:
Cell
:
:
new
(
one
)
two
:
Cell
:
:
new
(
two
)
}
}
pub
(
crate
)
fn
fastrand_n
(
&
self
n
:
u32
)
-
>
u32
{
let
mul
=
(
self
.
fastrand
(
)
as
u64
)
.
wrapping_mul
(
n
as
u64
)
;
(
mul
>
>
32
)
as
u32
}
fn
fastrand
(
&
self
)
-
>
u32
{
let
mut
s1
=
self
.
one
.
get
(
)
;
let
s0
=
self
.
two
.
get
(
)
;
s1
^
=
s1
<
<
17
;
s1
=
s1
^
s0
^
s1
>
>
7
^
s0
>
>
16
;
self
.
one
.
set
(
s0
)
;
self
.
two
.
set
(
s1
)
;
s0
.
wrapping_add
(
s1
)
}
}
#
[
cfg
(
any
(
feature
=
"
macros
"
)
)
]
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
not
(
feature
=
"
macros
"
)
allow
(
unreachable_pub
)
)
]
pub
fn
thread_rng_n
(
n
:
u32
)
-
>
u32
{
thread_local
!
{
static
THREAD_RNG
:
FastRand
=
FastRand
:
:
new
(
crate
:
:
loom
:
:
rand
:
:
seed
(
)
)
;
}
THREAD_RNG
.
with
(
|
rng
|
rng
.
fastrand_n
(
n
)
)
}
