use
std
:
:
ptr
:
:
NonNull
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
crate
:
:
loom
:
:
sync
:
:
{
Mutex
MutexGuard
}
;
use
crate
:
:
util
:
:
metric_atomics
:
:
{
MetricAtomicU64
MetricAtomicUsize
}
;
use
super
:
:
linked_list
:
:
{
Link
LinkedList
}
;
pub
(
crate
)
struct
ShardedList
<
L
T
>
{
lists
:
Box
<
[
Mutex
<
LinkedList
<
L
T
>
>
]
>
added
:
MetricAtomicU64
count
:
MetricAtomicUsize
shard_mask
:
usize
}
pub
(
crate
)
unsafe
trait
ShardedListItem
:
Link
{
unsafe
fn
get_shard_id
(
target
:
NonNull
<
Self
:
:
Target
>
)
-
>
usize
;
}
impl
<
L
T
>
ShardedList
<
L
T
>
{
pub
(
crate
)
fn
new
(
sharded_size
:
usize
)
-
>
Self
{
assert
!
(
sharded_size
.
is_power_of_two
(
)
)
;
let
shard_mask
=
sharded_size
-
1
;
let
mut
lists
=
Vec
:
:
with_capacity
(
sharded_size
)
;
for
_
in
0
.
.
sharded_size
{
lists
.
push
(
Mutex
:
:
new
(
LinkedList
:
:
<
L
T
>
:
:
new
(
)
)
)
}
Self
{
lists
:
lists
.
into_boxed_slice
(
)
added
:
MetricAtomicU64
:
:
new
(
0
)
count
:
MetricAtomicUsize
:
:
new
(
0
)
shard_mask
}
}
}
pub
(
crate
)
struct
ShardGuard
<
'
a
L
T
>
{
lock
:
MutexGuard
<
'
a
LinkedList
<
L
T
>
>
added
:
&
'
a
MetricAtomicU64
count
:
&
'
a
MetricAtomicUsize
id
:
usize
}
impl
<
L
:
ShardedListItem
>
ShardedList
<
L
L
:
:
Target
>
{
pub
(
crate
)
fn
pop_back
(
&
self
shard_id
:
usize
)
-
>
Option
<
L
:
:
Handle
>
{
let
mut
lock
=
self
.
shard_inner
(
shard_id
)
;
let
node
=
lock
.
pop_back
(
)
;
if
node
.
is_some
(
)
{
self
.
count
.
decrement
(
)
;
}
node
}
pub
(
crate
)
unsafe
fn
remove
(
&
self
node
:
NonNull
<
L
:
:
Target
>
)
-
>
Option
<
L
:
:
Handle
>
{
let
id
=
L
:
:
get_shard_id
(
node
)
;
let
mut
lock
=
self
.
shard_inner
(
id
)
;
let
node
=
unsafe
{
lock
.
remove
(
node
)
}
;
if
node
.
is_some
(
)
{
self
.
count
.
decrement
(
)
;
}
node
}
pub
(
crate
)
fn
lock_shard
(
&
self
val
:
&
L
:
:
Handle
)
-
>
ShardGuard
<
'
_
L
L
:
:
Target
>
{
let
id
=
unsafe
{
L
:
:
get_shard_id
(
L
:
:
as_raw
(
val
)
)
}
;
ShardGuard
{
lock
:
self
.
shard_inner
(
id
)
added
:
&
self
.
added
count
:
&
self
.
count
id
}
}
pub
(
crate
)
fn
len
(
&
self
)
-
>
usize
{
self
.
count
.
load
(
Ordering
:
:
Relaxed
)
}
cfg_64bit_metrics
!
{
/
/
/
Gets
the
total
number
of
elements
added
to
this
list
.
pub
(
crate
)
fn
added
(
&
self
)
-
>
u64
{
self
.
added
.
load
(
Ordering
:
:
Relaxed
)
}
}
pub
(
crate
)
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
pub
(
crate
)
fn
shard_size
(
&
self
)
-
>
usize
{
self
.
shard_mask
+
1
}
#
[
inline
]
fn
shard_inner
(
&
self
id
:
usize
)
-
>
MutexGuard
<
'
_
LinkedList
<
L
<
L
as
Link
>
:
:
Target
>
>
{
unsafe
{
self
.
lists
.
get_unchecked
(
id
&
self
.
shard_mask
)
.
lock
(
)
}
}
}
impl
<
'
a
L
:
ShardedListItem
>
ShardGuard
<
'
a
L
L
:
:
Target
>
{
pub
(
crate
)
fn
push
(
mut
self
val
:
L
:
:
Handle
)
{
let
id
=
unsafe
{
L
:
:
get_shard_id
(
L
:
:
as_raw
(
&
val
)
)
}
;
assert_eq
!
(
id
self
.
id
)
;
self
.
lock
.
push_front
(
val
)
;
self
.
added
.
add
(
1
Ordering
:
:
Relaxed
)
;
self
.
count
.
increment
(
)
;
}
}
cfg_taskdump
!
{
impl
<
L
:
ShardedListItem
>
ShardedList
<
L
L
:
:
Target
>
{
pub
(
crate
)
fn
for_each
<
F
>
(
&
self
mut
f
:
F
)
where
F
:
FnMut
(
&
L
:
:
Handle
)
{
let
mut
guards
=
Vec
:
:
with_capacity
(
self
.
lists
.
len
(
)
)
;
for
list
in
self
.
lists
.
iter
(
)
{
guards
.
push
(
list
.
lock
(
)
)
;
}
for
g
in
&
mut
guards
{
g
.
for_each
(
&
mut
f
)
;
}
}
}
}
