#
[
path
=
"
unix
/
mod
.
rs
"
]
#
[
cfg
(
unix
)
]
mod
imp
;
#
[
cfg
(
unix
)
]
pub
(
crate
)
mod
unix
{
pub
(
crate
)
use
super
:
:
imp
:
:
*
;
}
#
[
path
=
"
windows
.
rs
"
]
#
[
cfg
(
windows
)
]
mod
imp
;
mod
kill
;
use
crate
:
:
io
:
:
{
AsyncRead
AsyncWrite
ReadBuf
}
;
use
crate
:
:
process
:
:
kill
:
:
Kill
;
use
std
:
:
convert
:
:
TryInto
;
use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
io
;
#
[
cfg
(
unix
)
]
use
std
:
:
os
:
:
unix
:
:
process
:
:
CommandExt
;
#
[
cfg
(
windows
)
]
use
std
:
:
os
:
:
windows
:
:
io
:
:
{
AsRawHandle
RawHandle
}
;
#
[
cfg
(
windows
)
]
use
std
:
:
os
:
:
windows
:
:
process
:
:
CommandExt
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
process
:
:
{
Command
as
StdCommand
ExitStatus
Output
Stdio
}
;
use
std
:
:
task
:
:
Context
;
use
std
:
:
task
:
:
Poll
;
#
[
derive
(
Debug
)
]
pub
struct
Command
{
std
:
StdCommand
kill_on_drop
:
bool
}
pub
(
crate
)
struct
SpawnedChild
{
child
:
imp
:
:
Child
stdin
:
Option
<
imp
:
:
ChildStdio
>
stdout
:
Option
<
imp
:
:
ChildStdio
>
stderr
:
Option
<
imp
:
:
ChildStdio
>
}
impl
Command
{
pub
fn
new
<
S
:
AsRef
<
OsStr
>
>
(
program
:
S
)
-
>
Command
{
Self
:
:
from
(
StdCommand
:
:
new
(
program
)
)
}
pub
fn
as_std
(
&
self
)
-
>
&
StdCommand
{
&
self
.
std
}
pub
fn
arg
<
S
:
AsRef
<
OsStr
>
>
(
&
mut
self
arg
:
S
)
-
>
&
mut
Command
{
self
.
std
.
arg
(
arg
)
;
self
}
pub
fn
args
<
I
S
>
(
&
mut
self
args
:
I
)
-
>
&
mut
Command
where
I
:
IntoIterator
<
Item
=
S
>
S
:
AsRef
<
OsStr
>
{
self
.
std
.
args
(
args
)
;
self
}
pub
fn
env
<
K
V
>
(
&
mut
self
key
:
K
val
:
V
)
-
>
&
mut
Command
where
K
:
AsRef
<
OsStr
>
V
:
AsRef
<
OsStr
>
{
self
.
std
.
env
(
key
val
)
;
self
}
pub
fn
envs
<
I
K
V
>
(
&
mut
self
vars
:
I
)
-
>
&
mut
Command
where
I
:
IntoIterator
<
Item
=
(
K
V
)
>
K
:
AsRef
<
OsStr
>
V
:
AsRef
<
OsStr
>
{
self
.
std
.
envs
(
vars
)
;
self
}
pub
fn
env_remove
<
K
:
AsRef
<
OsStr
>
>
(
&
mut
self
key
:
K
)
-
>
&
mut
Command
{
self
.
std
.
env_remove
(
key
)
;
self
}
pub
fn
env_clear
(
&
mut
self
)
-
>
&
mut
Command
{
self
.
std
.
env_clear
(
)
;
self
}
pub
fn
current_dir
<
P
:
AsRef
<
Path
>
>
(
&
mut
self
dir
:
P
)
-
>
&
mut
Command
{
self
.
std
.
current_dir
(
dir
)
;
self
}
pub
fn
stdin
<
T
:
Into
<
Stdio
>
>
(
&
mut
self
cfg
:
T
)
-
>
&
mut
Command
{
self
.
std
.
stdin
(
cfg
)
;
self
}
pub
fn
stdout
<
T
:
Into
<
Stdio
>
>
(
&
mut
self
cfg
:
T
)
-
>
&
mut
Command
{
self
.
std
.
stdout
(
cfg
)
;
self
}
pub
fn
stderr
<
T
:
Into
<
Stdio
>
>
(
&
mut
self
cfg
:
T
)
-
>
&
mut
Command
{
self
.
std
.
stderr
(
cfg
)
;
self
}
pub
fn
kill_on_drop
(
&
mut
self
kill_on_drop
:
bool
)
-
>
&
mut
Command
{
self
.
kill_on_drop
=
kill_on_drop
;
self
}
#
[
cfg
(
windows
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
windows
)
)
)
]
pub
fn
creation_flags
(
&
mut
self
flags
:
u32
)
-
>
&
mut
Command
{
self
.
std
.
creation_flags
(
flags
)
;
self
}
#
[
cfg
(
unix
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
unix
)
)
)
]
pub
fn
uid
(
&
mut
self
id
:
u32
)
-
>
&
mut
Command
{
self
.
std
.
uid
(
id
)
;
self
}
#
[
cfg
(
unix
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
unix
)
)
)
]
pub
fn
gid
(
&
mut
self
id
:
u32
)
-
>
&
mut
Command
{
self
.
std
.
gid
(
id
)
;
self
}
#
[
cfg
(
unix
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
unix
)
)
)
]
pub
fn
arg0
<
S
>
(
&
mut
self
arg
:
S
)
-
>
&
mut
Command
where
S
:
AsRef
<
OsStr
>
{
self
.
std
.
arg0
(
arg
)
;
self
}
#
[
cfg
(
unix
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
unix
)
)
)
]
pub
unsafe
fn
pre_exec
<
F
>
(
&
mut
self
f
:
F
)
-
>
&
mut
Command
where
F
:
FnMut
(
)
-
>
io
:
:
Result
<
(
)
>
+
Send
+
Sync
+
'
static
{
self
.
std
.
pre_exec
(
f
)
;
self
}
pub
fn
spawn
(
&
mut
self
)
-
>
io
:
:
Result
<
Child
>
{
imp
:
:
spawn_child
(
&
mut
self
.
std
)
.
map
(
|
spawned_child
|
Child
{
child
:
FusedChild
:
:
Child
(
ChildDropGuard
{
inner
:
spawned_child
.
child
kill_on_drop
:
self
.
kill_on_drop
}
)
stdin
:
spawned_child
.
stdin
.
map
(
|
inner
|
ChildStdin
{
inner
}
)
stdout
:
spawned_child
.
stdout
.
map
(
|
inner
|
ChildStdout
{
inner
}
)
stderr
:
spawned_child
.
stderr
.
map
(
|
inner
|
ChildStderr
{
inner
}
)
}
)
}
pub
fn
status
(
&
mut
self
)
-
>
impl
Future
<
Output
=
io
:
:
Result
<
ExitStatus
>
>
{
let
child
=
self
.
spawn
(
)
;
async
{
let
mut
child
=
child
?
;
child
.
stdin
.
take
(
)
;
child
.
stdout
.
take
(
)
;
child
.
stderr
.
take
(
)
;
child
.
wait
(
)
.
await
}
}
pub
fn
output
(
&
mut
self
)
-
>
impl
Future
<
Output
=
io
:
:
Result
<
Output
>
>
{
self
.
std
.
stdout
(
Stdio
:
:
piped
(
)
)
;
self
.
std
.
stderr
(
Stdio
:
:
piped
(
)
)
;
let
child
=
self
.
spawn
(
)
;
async
{
child
?
.
wait_with_output
(
)
.
await
}
}
}
impl
From
<
StdCommand
>
for
Command
{
fn
from
(
std
:
StdCommand
)
-
>
Command
{
Command
{
std
kill_on_drop
:
false
}
}
}
#
[
derive
(
Debug
)
]
struct
ChildDropGuard
<
T
:
Kill
>
{
inner
:
T
kill_on_drop
:
bool
}
impl
<
T
:
Kill
>
Kill
for
ChildDropGuard
<
T
>
{
fn
kill
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
let
ret
=
self
.
inner
.
kill
(
)
;
if
ret
.
is_ok
(
)
{
self
.
kill_on_drop
=
false
;
}
ret
}
}
impl
<
T
:
Kill
>
Drop
for
ChildDropGuard
<
T
>
{
fn
drop
(
&
mut
self
)
{
if
self
.
kill_on_drop
{
drop
(
self
.
kill
(
)
)
;
}
}
}
impl
<
T
E
F
>
Future
for
ChildDropGuard
<
F
>
where
F
:
Future
<
Output
=
Result
<
T
E
>
>
+
Kill
+
Unpin
{
type
Output
=
Result
<
T
E
>
;
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
coop
=
ready
!
(
crate
:
:
coop
:
:
poll_proceed
(
cx
)
)
;
let
ret
=
Pin
:
:
new
(
&
mut
self
.
inner
)
.
poll
(
cx
)
;
if
let
Poll
:
:
Ready
(
Ok
(
_
)
)
=
ret
{
self
.
kill_on_drop
=
false
;
}
if
ret
.
is_ready
(
)
{
coop
.
made_progress
(
)
;
}
ret
}
}
#
[
derive
(
Debug
)
]
enum
FusedChild
{
Child
(
ChildDropGuard
<
imp
:
:
Child
>
)
Done
(
ExitStatus
)
}
#
[
derive
(
Debug
)
]
pub
struct
Child
{
child
:
FusedChild
pub
stdin
:
Option
<
ChildStdin
>
pub
stdout
:
Option
<
ChildStdout
>
pub
stderr
:
Option
<
ChildStderr
>
}
impl
Child
{
pub
fn
id
(
&
self
)
-
>
Option
<
u32
>
{
match
&
self
.
child
{
FusedChild
:
:
Child
(
child
)
=
>
Some
(
child
.
inner
.
id
(
)
)
FusedChild
:
:
Done
(
_
)
=
>
None
}
}
#
[
cfg
(
windows
)
]
pub
fn
raw_handle
(
&
self
)
-
>
Option
<
RawHandle
>
{
match
&
self
.
child
{
FusedChild
:
:
Child
(
c
)
=
>
Some
(
c
.
inner
.
as_raw_handle
(
)
)
FusedChild
:
:
Done
(
_
)
=
>
None
}
}
pub
fn
start_kill
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
match
&
mut
self
.
child
{
FusedChild
:
:
Child
(
child
)
=
>
child
.
kill
(
)
FusedChild
:
:
Done
(
_
)
=
>
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidInput
"
invalid
argument
:
can
'
t
kill
an
exited
process
"
)
)
}
}
pub
async
fn
kill
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
start_kill
(
)
?
;
self
.
wait
(
)
.
await
?
;
Ok
(
(
)
)
}
pub
async
fn
wait
(
&
mut
self
)
-
>
io
:
:
Result
<
ExitStatus
>
{
drop
(
self
.
stdin
.
take
(
)
)
;
match
&
mut
self
.
child
{
FusedChild
:
:
Done
(
exit
)
=
>
Ok
(
*
exit
)
FusedChild
:
:
Child
(
child
)
=
>
{
let
ret
=
child
.
await
;
if
let
Ok
(
exit
)
=
ret
{
self
.
child
=
FusedChild
:
:
Done
(
exit
)
;
}
ret
}
}
}
pub
fn
try_wait
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
ExitStatus
>
>
{
match
&
mut
self
.
child
{
FusedChild
:
:
Done
(
exit
)
=
>
Ok
(
Some
(
*
exit
)
)
FusedChild
:
:
Child
(
guard
)
=
>
{
let
ret
=
guard
.
inner
.
try_wait
(
)
;
if
let
Ok
(
Some
(
exit
)
)
=
ret
{
guard
.
kill_on_drop
=
false
;
self
.
child
=
FusedChild
:
:
Done
(
exit
)
;
}
ret
}
}
}
pub
async
fn
wait_with_output
(
mut
self
)
-
>
io
:
:
Result
<
Output
>
{
use
crate
:
:
future
:
:
try_join3
;
async
fn
read_to_end
<
A
:
AsyncRead
+
Unpin
>
(
io
:
&
mut
Option
<
A
>
)
-
>
io
:
:
Result
<
Vec
<
u8
>
>
{
let
mut
vec
=
Vec
:
:
new
(
)
;
if
let
Some
(
io
)
=
io
.
as_mut
(
)
{
crate
:
:
io
:
:
util
:
:
read_to_end
(
io
&
mut
vec
)
.
await
?
;
}
Ok
(
vec
)
}
let
mut
stdout_pipe
=
self
.
stdout
.
take
(
)
;
let
mut
stderr_pipe
=
self
.
stderr
.
take
(
)
;
let
stdout_fut
=
read_to_end
(
&
mut
stdout_pipe
)
;
let
stderr_fut
=
read_to_end
(
&
mut
stderr_pipe
)
;
let
(
status
stdout
stderr
)
=
try_join3
(
self
.
wait
(
)
stdout_fut
stderr_fut
)
.
await
?
;
drop
(
stdout_pipe
)
;
drop
(
stderr_pipe
)
;
Ok
(
Output
{
status
stdout
stderr
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ChildStdin
{
inner
:
imp
:
:
ChildStdio
}
#
[
derive
(
Debug
)
]
pub
struct
ChildStdout
{
inner
:
imp
:
:
ChildStdio
}
#
[
derive
(
Debug
)
]
pub
struct
ChildStderr
{
inner
:
imp
:
:
ChildStdio
}
impl
ChildStdin
{
pub
fn
from_std
(
inner
:
std
:
:
process
:
:
ChildStdin
)
-
>
io
:
:
Result
<
Self
>
{
Ok
(
Self
{
inner
:
imp
:
:
stdio
(
inner
)
?
}
)
}
}
impl
ChildStdout
{
pub
fn
from_std
(
inner
:
std
:
:
process
:
:
ChildStdout
)
-
>
io
:
:
Result
<
Self
>
{
Ok
(
Self
{
inner
:
imp
:
:
stdio
(
inner
)
?
}
)
}
}
impl
ChildStderr
{
pub
fn
from_std
(
inner
:
std
:
:
process
:
:
ChildStderr
)
-
>
io
:
:
Result
<
Self
>
{
Ok
(
Self
{
inner
:
imp
:
:
stdio
(
inner
)
?
}
)
}
}
impl
AsyncWrite
for
ChildStdin
{
fn
poll_write
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
buf
:
&
[
u8
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
self
.
inner
.
poll_write
(
cx
buf
)
}
fn
poll_flush
(
self
:
Pin
<
&
mut
Self
>
_cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
fn
poll_shutdown
(
self
:
Pin
<
&
mut
Self
>
_cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
}
impl
AsyncRead
for
ChildStdout
{
fn
poll_read
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
buf
:
&
mut
ReadBuf
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
unsafe
{
self
.
inner
.
poll_read
(
cx
buf
)
}
}
}
impl
AsyncRead
for
ChildStderr
{
fn
poll_read
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
buf
:
&
mut
ReadBuf
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
unsafe
{
self
.
inner
.
poll_read
(
cx
buf
)
}
}
}
impl
TryInto
<
Stdio
>
for
ChildStdin
{
type
Error
=
io
:
:
Error
;
fn
try_into
(
self
)
-
>
Result
<
Stdio
Self
:
:
Error
>
{
imp
:
:
convert_to_stdio
(
self
.
inner
)
}
}
impl
TryInto
<
Stdio
>
for
ChildStdout
{
type
Error
=
io
:
:
Error
;
fn
try_into
(
self
)
-
>
Result
<
Stdio
Self
:
:
Error
>
{
imp
:
:
convert_to_stdio
(
self
.
inner
)
}
}
impl
TryInto
<
Stdio
>
for
ChildStderr
{
type
Error
=
io
:
:
Error
;
fn
try_into
(
self
)
-
>
Result
<
Stdio
Self
:
:
Error
>
{
imp
:
:
convert_to_stdio
(
self
.
inner
)
}
}
#
[
cfg
(
unix
)
]
mod
sys
{
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsRawFd
RawFd
}
;
use
super
:
:
{
ChildStderr
ChildStdin
ChildStdout
}
;
impl
AsRawFd
for
ChildStdin
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
inner
.
as_raw_fd
(
)
}
}
impl
AsRawFd
for
ChildStdout
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
inner
.
as_raw_fd
(
)
}
}
impl
AsRawFd
for
ChildStderr
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
inner
.
as_raw_fd
(
)
}
}
}
#
[
cfg
(
windows
)
]
mod
sys
{
use
std
:
:
os
:
:
windows
:
:
io
:
:
{
AsRawHandle
RawHandle
}
;
use
super
:
:
{
ChildStderr
ChildStdin
ChildStdout
}
;
impl
AsRawHandle
for
ChildStdin
{
fn
as_raw_handle
(
&
self
)
-
>
RawHandle
{
self
.
inner
.
as_raw_handle
(
)
}
}
impl
AsRawHandle
for
ChildStdout
{
fn
as_raw_handle
(
&
self
)
-
>
RawHandle
{
self
.
inner
.
as_raw_handle
(
)
}
}
impl
AsRawHandle
for
ChildStderr
{
fn
as_raw_handle
(
&
self
)
-
>
RawHandle
{
self
.
inner
.
as_raw_handle
(
)
}
}
}
#
[
cfg
(
all
(
test
not
(
loom
)
)
)
]
mod
test
{
use
super
:
:
kill
:
:
Kill
;
use
super
:
:
ChildDropGuard
;
use
futures
:
:
future
:
:
FutureExt
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
io
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
struct
Mock
{
num_kills
:
usize
num_polls
:
usize
poll_result
:
Poll
<
Result
<
(
)
(
)
>
>
}
impl
Mock
{
fn
new
(
)
-
>
Self
{
Self
:
:
with_result
(
Poll
:
:
Pending
)
}
fn
with_result
(
result
:
Poll
<
Result
<
(
)
(
)
>
>
)
-
>
Self
{
Self
{
num_kills
:
0
num_polls
:
0
poll_result
:
result
}
}
}
impl
Kill
for
Mock
{
fn
kill
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
num_kills
+
=
1
;
Ok
(
(
)
)
}
}
impl
Future
for
Mock
{
type
Output
=
Result
<
(
)
(
)
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
_cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
inner
=
Pin
:
:
get_mut
(
self
)
;
inner
.
num_polls
+
=
1
;
inner
.
poll_result
}
}
#
[
test
]
fn
kills_on_drop_if_specified
(
)
{
let
mut
mock
=
Mock
:
:
new
(
)
;
{
let
guard
=
ChildDropGuard
{
inner
:
&
mut
mock
kill_on_drop
:
true
}
;
drop
(
guard
)
;
}
assert_eq
!
(
1
mock
.
num_kills
)
;
assert_eq
!
(
0
mock
.
num_polls
)
;
}
#
[
test
]
fn
no_kill_on_drop_by_default
(
)
{
let
mut
mock
=
Mock
:
:
new
(
)
;
{
let
guard
=
ChildDropGuard
{
inner
:
&
mut
mock
kill_on_drop
:
false
}
;
drop
(
guard
)
;
}
assert_eq
!
(
0
mock
.
num_kills
)
;
assert_eq
!
(
0
mock
.
num_polls
)
;
}
#
[
test
]
fn
no_kill_if_already_killed
(
)
{
let
mut
mock
=
Mock
:
:
new
(
)
;
{
let
mut
guard
=
ChildDropGuard
{
inner
:
&
mut
mock
kill_on_drop
:
true
}
;
let
_
=
guard
.
kill
(
)
;
drop
(
guard
)
;
}
assert_eq
!
(
1
mock
.
num_kills
)
;
assert_eq
!
(
0
mock
.
num_polls
)
;
}
#
[
test
]
fn
no_kill_if_reaped
(
)
{
let
mut
mock_pending
=
Mock
:
:
with_result
(
Poll
:
:
Pending
)
;
let
mut
mock_reaped
=
Mock
:
:
with_result
(
Poll
:
:
Ready
(
Ok
(
(
)
)
)
)
;
let
mut
mock_err
=
Mock
:
:
with_result
(
Poll
:
:
Ready
(
Err
(
(
)
)
)
)
;
let
waker
=
futures
:
:
task
:
:
noop_waker
(
)
;
let
mut
context
=
Context
:
:
from_waker
(
&
waker
)
;
{
let
mut
guard
=
ChildDropGuard
{
inner
:
&
mut
mock_pending
kill_on_drop
:
true
}
;
let
_
=
guard
.
poll_unpin
(
&
mut
context
)
;
let
mut
guard
=
ChildDropGuard
{
inner
:
&
mut
mock_reaped
kill_on_drop
:
true
}
;
let
_
=
guard
.
poll_unpin
(
&
mut
context
)
;
let
mut
guard
=
ChildDropGuard
{
inner
:
&
mut
mock_err
kill_on_drop
:
true
}
;
let
_
=
guard
.
poll_unpin
(
&
mut
context
)
;
}
assert_eq
!
(
1
mock_pending
.
num_kills
)
;
assert_eq
!
(
1
mock_pending
.
num_polls
)
;
assert_eq
!
(
0
mock_reaped
.
num_kills
)
;
assert_eq
!
(
1
mock_reaped
.
num_polls
)
;
assert_eq
!
(
1
mock_err
.
num_kills
)
;
assert_eq
!
(
1
mock_err
.
num_polls
)
;
}
}
