use
crate
:
:
loom
:
:
sync
:
:
{
Condvar
Mutex
}
;
use
std
:
:
fmt
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
pub
(
crate
)
struct
Barrier
{
lock
:
Mutex
<
BarrierState
>
cvar
:
Condvar
num_threads
:
usize
}
struct
BarrierState
{
count
:
usize
generation_id
:
usize
}
pub
(
crate
)
struct
BarrierWaitResult
(
bool
)
;
impl
fmt
:
:
Debug
for
Barrier
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Barrier
"
)
.
finish_non_exhaustive
(
)
}
}
impl
Barrier
{
#
[
must_use
]
pub
(
crate
)
fn
new
(
n
:
usize
)
-
>
Barrier
{
Barrier
{
lock
:
Mutex
:
:
new
(
BarrierState
{
count
:
0
generation_id
:
0
}
)
cvar
:
Condvar
:
:
new
(
)
num_threads
:
n
}
}
pub
(
crate
)
fn
wait
(
&
self
)
-
>
BarrierWaitResult
{
let
mut
lock
=
self
.
lock
.
lock
(
)
;
let
local_gen
=
lock
.
generation_id
;
lock
.
count
+
=
1
;
if
lock
.
count
<
self
.
num_threads
{
while
local_gen
=
=
lock
.
generation_id
{
lock
=
self
.
cvar
.
wait
(
lock
)
.
unwrap
(
)
;
}
BarrierWaitResult
(
false
)
}
else
{
lock
.
count
=
0
;
lock
.
generation_id
=
lock
.
generation_id
.
wrapping_add
(
1
)
;
self
.
cvar
.
notify_all
(
)
;
BarrierWaitResult
(
true
)
}
}
pub
(
crate
)
fn
wait_timeout
(
&
self
timeout
:
Duration
)
-
>
Option
<
BarrierWaitResult
>
{
let
deadline
=
Instant
:
:
now
(
)
+
timeout
;
let
mut
lock
=
loop
{
if
let
Some
(
guard
)
=
self
.
lock
.
try_lock
(
)
{
break
guard
;
}
else
if
Instant
:
:
now
(
)
>
deadline
{
return
None
;
}
else
{
std
:
:
thread
:
:
yield_now
(
)
;
}
}
;
let
timeout
=
deadline
.
saturating_duration_since
(
Instant
:
:
now
(
)
)
;
let
local_gen
=
lock
.
generation_id
;
lock
.
count
+
=
1
;
if
lock
.
count
<
self
.
num_threads
{
while
local_gen
=
=
lock
.
generation_id
{
let
(
guard
timeout_result
)
=
self
.
cvar
.
wait_timeout
(
lock
timeout
)
.
unwrap
(
)
;
lock
=
guard
;
if
timeout_result
.
timed_out
(
)
{
return
None
;
}
}
Some
(
BarrierWaitResult
(
false
)
)
}
else
{
lock
.
count
=
0
;
lock
.
generation_id
=
lock
.
generation_id
.
wrapping_add
(
1
)
;
self
.
cvar
.
notify_all
(
)
;
Some
(
BarrierWaitResult
(
true
)
)
}
}
}
impl
fmt
:
:
Debug
for
BarrierWaitResult
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
BarrierWaitResult
"
)
.
field
(
"
is_leader
"
&
self
.
is_leader
(
)
)
.
finish
(
)
}
}
impl
BarrierWaitResult
{
#
[
must_use
]
pub
(
crate
)
fn
is_leader
(
&
self
)
-
>
bool
{
self
.
0
}
}
