use
crate
:
:
task
:
:
JoinHandle
;
cfg_rt_multi_thread
!
{
/
/
/
Runs
the
provided
blocking
function
on
the
current
thread
without
/
/
/
blocking
the
executor
.
/
/
/
/
/
/
In
general
issuing
a
blocking
call
or
performing
a
lot
of
compute
in
a
/
/
/
future
without
yielding
is
problematic
as
it
may
prevent
the
executor
/
/
/
from
driving
other
tasks
forward
.
Calling
this
function
informs
the
/
/
/
executor
that
the
currently
executing
task
is
about
to
block
the
thread
/
/
/
so
the
executor
is
able
to
hand
off
any
other
tasks
it
has
to
a
new
/
/
/
worker
thread
before
that
happens
.
See
the
[
CPU
-
bound
tasks
and
blocking
/
/
/
code
]
[
blocking
]
section
for
more
information
.
/
/
/
/
/
/
Be
aware
that
although
this
function
avoids
starving
other
independently
/
/
/
spawned
tasks
any
other
code
running
concurrently
in
the
same
task
will
/
/
/
be
suspended
during
the
call
to
block_in_place
.
This
can
happen
e
.
g
.
/
/
/
when
using
the
[
join
!
]
macro
.
To
avoid
this
issue
use
/
/
/
[
spawn_blocking
]
instead
of
block_in_place
.
#
[
track_caller
]
pub
fn
block_in_place
<
F
R
>
(
f
:
F
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
{
crate
:
:
runtime
:
:
scheduler
:
:
block_in_place
(
f
)
}
}
cfg_rt
!
{
/
/
/
Runs
the
provided
closure
on
a
thread
where
blocking
is
acceptable
.
/
/
/
/
/
/
In
general
issuing
a
blocking
call
or
performing
a
lot
of
compute
in
a
/
/
/
future
without
yielding
is
problematic
as
it
may
prevent
the
executor
from
/
/
/
driving
other
futures
forward
.
This
function
runs
the
provided
closure
on
a
/
/
/
thread
dedicated
to
blocking
operations
.
See
the
[
CPU
-
bound
tasks
and
/
/
/
blocking
code
]
[
blocking
]
section
for
more
information
.
/
/
/
/
/
/
Tokio
will
spawn
more
blocking
threads
when
they
are
requested
through
this
/
/
/
function
until
the
upper
limit
configured
on
the
[
Builder
]
is
reached
.
/
/
/
After
reaching
the
upper
limit
the
tasks
are
put
in
a
queue
.
/
/
/
The
thread
limit
is
very
large
by
default
because
spawn_blocking
is
often
/
/
/
used
for
various
kinds
of
IO
operations
that
cannot
be
performed
/
/
/
asynchronously
.
When
you
run
CPU
-
bound
code
using
spawn_blocking
you
/
/
/
should
keep
this
large
upper
limit
in
mind
.
When
running
many
CPU
-
bound
/
/
/
computations
a
semaphore
or
some
other
synchronization
primitive
should
be
/
/
/
used
to
limit
the
number
of
computation
executed
in
parallel
.
Specialized
/
/
/
CPU
-
bound
executors
such
as
[
rayon
]
may
also
be
a
good
fit
.
/
/
/
/
/
/
This
function
is
intended
for
non
-
async
operations
that
eventually
finish
on
/
/
/
their
own
.
If
you
want
to
spawn
an
ordinary
thread
you
should
use
/
/
/
[
thread
:
:
spawn
]
instead
.
/
/
/
/
/
/
Be
aware
that
tasks
spawned
using
spawn_blocking
cannot
be
aborted
/
/
/
because
they
are
not
async
.
If
you
call
[
abort
]
on
a
spawn_blocking
#
[
track_caller
]
pub
fn
spawn_blocking
<
F
R
>
(
f
:
F
)
-
>
JoinHandle
<
R
>
where
F
:
FnOnce
(
)
-
>
R
+
Send
+
'
static
R
:
Send
+
'
static
{
crate
:
:
runtime
:
:
spawn_blocking
(
f
)
}
}
