use
crate
:
:
loom
:
:
cell
:
:
UnsafeCell
;
use
crate
:
:
loom
:
:
sync
:
:
{
Arc
Mutex
}
;
use
crate
:
:
runtime
:
:
task
:
:
{
self
JoinHandle
LocalOwnedTasks
Task
}
;
use
crate
:
:
runtime
:
:
{
context
ThreadId
}
;
use
crate
:
:
sync
:
:
AtomicWaker
;
use
crate
:
:
util
:
:
RcCell
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
fmt
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
task
:
:
Poll
;
use
pin_project_lite
:
:
pin_project
;
cfg_rt
!
{
/
/
/
A
set
of
tasks
which
are
executed
on
the
same
thread
.
/
/
/
/
/
/
In
some
cases
it
is
necessary
to
run
one
or
more
futures
that
do
not
/
/
/
implement
[
Send
]
and
thus
are
unsafe
to
send
between
threads
.
In
these
/
/
/
cases
a
[
local
task
set
]
may
be
used
to
schedule
one
or
more
!
Send
/
/
/
futures
to
run
together
on
the
same
thread
.
/
/
/
/
/
/
For
example
the
following
code
will
not
compile
:
/
/
/
/
/
/
rust
compile_fail
/
/
/
use
std
:
:
rc
:
:
Rc
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
{
/
/
/
/
/
Rc
does
not
implement
Send
and
thus
may
not
be
sent
between
/
/
/
/
/
threads
safely
.
/
/
/
let
nonsend_data
=
Rc
:
:
new
(
"
my
nonsend
data
.
.
.
"
)
;
/
/
/
/
/
/
let
nonsend_data
=
nonsend_data
.
clone
(
)
;
/
/
/
/
/
Because
the
async
block
here
moves
nonsend_data
the
future
is
!
Send
.
/
/
/
/
/
Since
tokio
:
:
spawn
requires
the
spawned
future
to
implement
Send
this
/
/
/
/
/
will
not
compile
.
/
/
/
tokio
:
:
spawn
(
async
move
{
/
/
/
println
!
(
"
{
}
"
nonsend_data
)
;
/
/
/
/
/
.
.
.
/
/
/
}
)
.
await
.
unwrap
(
)
;
/
/
/
}
/
/
/
/
/
/
/
/
/
#
Use
with
run_until
/
/
/
/
/
/
To
spawn
!
Send
futures
we
can
use
a
local
task
set
to
schedule
them
/
/
/
on
the
thread
calling
[
Runtime
:
:
block_on
]
.
When
running
inside
of
the
/
/
/
local
task
set
we
can
use
[
task
:
:
spawn_local
]
which
can
spawn
/
/
/
!
Send
futures
.
For
example
:
/
/
/
/
/
/
rust
/
/
/
use
std
:
:
rc
:
:
Rc
;
/
/
/
use
tokio
:
:
task
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
{
/
/
/
let
nonsend_data
=
Rc
:
:
new
(
"
my
nonsend
data
.
.
.
"
)
;
/
/
/
/
/
/
/
/
Construct
a
local
task
set
that
can
run
!
Send
futures
.
/
/
/
let
local
=
task
:
:
LocalSet
:
:
new
(
)
;
/
/
/
/
/
/
/
/
Run
the
local
task
set
.
/
/
/
local
.
run_until
(
async
move
{
/
/
/
let
nonsend_data
=
nonsend_data
.
clone
(
)
;
/
/
/
/
/
spawn_local
ensures
that
the
future
is
spawned
on
the
local
/
/
/
/
/
task
set
.
/
/
/
task
:
:
spawn_local
(
async
move
{
/
/
/
println
!
(
"
{
}
"
nonsend_data
)
;
/
/
/
/
/
.
.
.
/
/
/
}
)
.
await
.
unwrap
(
)
;
/
/
/
}
)
.
await
;
/
/
/
}
/
/
/
/
/
/
*
*
Note
:
*
*
The
run_until
method
can
only
be
used
in
#
[
tokio
:
:
main
]
/
/
/
#
[
tokio
:
:
test
]
or
directly
inside
a
call
to
[
Runtime
:
:
block_on
]
.
It
/
/
/
cannot
be
used
inside
a
task
spawned
with
tokio
:
:
spawn
.
/
/
/
/
/
/
#
#
Awaiting
a
LocalSet
/
/
/
/
/
/
Additionally
a
LocalSet
itself
implements
Future
completing
when
/
/
/
*
all
*
tasks
spawned
on
the
LocalSet
complete
.
This
can
be
used
to
run
/
/
/
several
futures
on
a
LocalSet
and
drive
the
whole
set
until
they
/
/
/
complete
.
For
example
/
/
/
/
/
/
rust
/
/
/
use
tokio
:
:
{
task
time
}
;
/
/
/
use
std
:
:
rc
:
:
Rc
;
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
{
/
/
/
let
nonsend_data
=
Rc
:
:
new
(
"
world
"
)
;
/
/
/
let
local
=
task
:
:
LocalSet
:
:
new
(
)
;
/
/
/
/
/
/
let
nonsend_data2
=
nonsend_data
.
clone
(
)
;
/
/
/
local
.
spawn_local
(
async
move
{
/
/
/
/
/
.
.
.
/
/
/
println
!
(
"
hello
{
}
"
nonsend_data2
)
/
/
/
}
)
;
/
/
/
/
/
/
local
.
spawn_local
(
async
move
{
/
/
/
time
:
:
sleep
(
time
:
:
Duration
:
:
from_millis
(
100
)
)
.
await
;
/
/
/
println
!
(
"
goodbye
{
}
"
nonsend_data
)
/
/
/
}
)
;
/
/
/
/
/
/
/
/
.
.
.
/
/
/
/
/
/
local
.
await
;
/
/
/
}
/
/
/
/
/
/
*
*
Note
:
*
*
Awaiting
a
LocalSet
can
only
be
done
inside
/
/
/
#
[
tokio
:
:
main
]
#
[
tokio
:
:
test
]
or
directly
inside
a
call
to
/
/
/
[
Runtime
:
:
block_on
]
.
It
cannot
be
used
inside
a
task
spawned
with
/
/
/
tokio
:
:
spawn
.
/
/
/
/
/
/
#
#
Use
inside
tokio
:
:
spawn
/
/
/
/
/
/
The
two
methods
mentioned
above
cannot
be
used
inside
tokio
:
:
spawn
so
/
/
/
to
spawn
!
Send
futures
from
inside
tokio
:
:
spawn
we
need
to
do
/
/
/
something
else
.
The
solution
is
to
create
the
LocalSet
somewhere
else
/
/
/
and
communicate
with
it
using
an
[
mpsc
]
channel
.
/
/
/
/
/
/
The
following
example
puts
the
LocalSet
inside
a
new
thread
.
/
/
/
/
/
/
use
tokio
:
:
runtime
:
:
Builder
;
/
/
/
use
tokio
:
:
sync
:
:
{
mpsc
oneshot
}
;
/
/
/
use
tokio
:
:
task
:
:
LocalSet
;
/
/
/
/
/
/
/
/
This
struct
describes
the
task
you
want
to
spawn
.
Here
we
include
/
/
/
/
/
some
simple
examples
.
The
oneshot
channel
allows
sending
a
response
/
/
/
/
/
to
the
spawner
.
/
/
/
#
[
derive
(
Debug
)
]
/
/
/
enum
Task
{
/
/
/
PrintNumber
(
u32
)
/
/
/
AddOne
(
u32
oneshot
:
:
Sender
<
u32
>
)
/
/
/
}
/
/
/
/
/
/
#
[
derive
(
Clone
)
]
/
/
/
struct
LocalSpawner
{
/
/
/
send
:
mpsc
:
:
UnboundedSender
<
Task
>
/
/
/
}
/
/
/
/
/
/
impl
LocalSpawner
{
/
/
/
pub
fn
new
(
)
-
>
Self
{
/
/
/
let
(
send
mut
recv
)
=
mpsc
:
:
unbounded_channel
(
)
;
/
/
/
/
/
/
let
rt
=
Builder
:
:
new_current_thread
(
)
/
/
/
.
enable_all
(
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
/
/
/
std
:
:
thread
:
:
spawn
(
move
|
|
{
/
/
/
let
local
=
LocalSet
:
:
new
(
)
;
/
/
/
/
/
/
local
.
spawn_local
(
async
move
{
/
/
/
while
let
Some
(
new_task
)
=
recv
.
recv
(
)
.
await
{
/
/
/
tokio
:
:
task
:
:
spawn_local
(
run_task
(
new_task
)
)
;
/
/
/
}
/
/
/
/
/
If
the
while
loop
returns
then
all
the
LocalSpawner
/
/
/
/
/
objects
have
been
dropped
.
/
/
/
}
)
;
/
/
/
/
/
/
/
/
This
will
return
once
all
senders
are
dropped
and
all
/
/
/
/
/
spawned
tasks
have
returned
.
/
/
/
rt
.
block_on
(
local
)
;
/
/
/
}
)
;
/
/
/
/
/
/
Self
{
/
/
/
send
/
/
/
}
/
/
/
}
/
/
/
/
/
/
pub
fn
spawn
(
&
self
task
:
Task
)
{
/
/
/
self
.
send
.
send
(
task
)
.
expect
(
"
Thread
with
LocalSet
has
shut
down
.
"
)
;
/
/
/
}
/
/
/
}
/
/
/
/
/
/
/
/
This
task
may
do
!
Send
stuff
.
We
use
printing
a
number
as
an
example
/
/
/
/
/
but
it
could
be
anything
.
/
/
/
/
/
/
/
/
/
/
The
Task
struct
is
an
enum
to
support
spawning
many
different
kinds
/
/
/
/
/
of
operations
.
/
/
/
async
fn
run_task
(
task
:
Task
)
{
/
/
/
match
task
{
/
/
/
Task
:
:
PrintNumber
(
n
)
=
>
{
/
/
/
println
!
(
"
{
}
"
n
)
;
/
/
/
}
/
/
/
Task
:
:
AddOne
(
n
response
)
=
>
{
/
/
/
/
/
We
ignore
failures
to
send
the
response
.
/
/
/
let
_
=
response
.
send
(
n
+
1
)
;
/
/
/
}
/
/
/
}
/
/
/
}
/
/
/
/
/
/
#
[
tokio
:
:
main
]
/
/
/
async
fn
main
(
)
{
/
/
/
let
spawner
=
LocalSpawner
:
:
new
(
)
;
/
/
/
/
/
/
let
(
send
response
)
=
oneshot
:
:
channel
(
)
;
/
/
/
spawner
.
spawn
(
Task
:
:
AddOne
(
10
send
)
)
;
/
/
/
let
eleven
=
response
.
await
.
unwrap
(
)
;
/
/
/
assert_eq
!
(
eleven
11
)
;
/
/
/
}
/
/
/
/
/
/
/
/
/
[
Send
]
:
trait
std
:
:
marker
:
:
Send
/
/
/
[
local
task
set
]
:
struct
LocalSet
/
/
/
[
Runtime
:
:
block_on
]
:
method
crate
:
:
runtime
:
:
Runtime
:
:
block_on
/
/
/
[
task
:
:
spawn_local
]
:
fn
spawn_local
/
/
/
[
mpsc
]
:
mod
crate
:
:
sync
:
:
mpsc
pub
struct
LocalSet
{
/
/
/
Current
scheduler
tick
.
tick
:
Cell
<
u8
>
/
/
/
State
available
from
thread
-
local
.
context
:
Rc
<
Context
>
/
/
/
This
type
should
not
be
Send
.
_not_send
:
PhantomData
<
*
const
(
)
>
}
}
struct
Context
{
shared
:
Arc
<
Shared
>
unhandled_panic
:
Cell
<
bool
>
}
struct
Shared
{
local_state
:
LocalState
queue
:
Mutex
<
Option
<
VecDeque
<
task
:
:
Notified
<
Arc
<
Shared
>
>
>
>
>
waker
:
AtomicWaker
#
[
cfg
(
tokio_unstable
)
]
pub
(
crate
)
unhandled_panic
:
crate
:
:
runtime
:
:
UnhandledPanic
}
struct
LocalState
{
owner
:
ThreadId
local_queue
:
UnsafeCell
<
VecDeque
<
task
:
:
Notified
<
Arc
<
Shared
>
>
>
>
owned
:
LocalOwnedTasks
<
Arc
<
Shared
>
>
}
pin_project
!
{
#
[
derive
(
Debug
)
]
struct
RunUntil
<
'
a
F
>
{
local_set
:
&
'
a
LocalSet
#
[
pin
]
future
:
F
}
}
tokio_thread_local
!
(
static
CURRENT
:
LocalData
=
const
{
LocalData
{
ctx
:
RcCell
:
:
new
(
)
}
}
)
;
struct
LocalData
{
ctx
:
RcCell
<
Context
>
}
cfg_rt
!
{
/
/
/
Spawns
a
!
Send
future
on
the
current
[
LocalSet
]
.
/
/
/
/
/
/
The
spawned
future
will
run
on
the
same
thread
that
called
spawn_local
.
#
[
track_caller
]
pub
fn
spawn_local
<
F
>
(
future
:
F
)
-
>
JoinHandle
<
F
:
:
Output
>
where
F
:
Future
+
'
static
F
:
:
Output
:
'
static
{
spawn_local_inner
(
future
None
)
}
#
[
track_caller
]
pub
(
super
)
fn
spawn_local_inner
<
F
>
(
future
:
F
name
:
Option
<
&
str
>
)
-
>
JoinHandle
<
F
:
:
Output
>
where
F
:
Future
+
'
static
F
:
:
Output
:
'
static
{
match
CURRENT
.
with
(
|
LocalData
{
ctx
.
.
}
|
ctx
.
get
(
)
)
{
None
=
>
panic
!
(
"
spawn_local
called
from
outside
of
a
task
:
:
LocalSet
"
)
Some
(
cx
)
=
>
cx
.
spawn
(
future
name
)
}
}
}
const
INITIAL_CAPACITY
:
usize
=
64
;
const
MAX_TASKS_PER_TICK
:
usize
=
61
;
const
REMOTE_FIRST_INTERVAL
:
u8
=
31
;
pub
struct
LocalEnterGuard
(
Option
<
Rc
<
Context
>
>
)
;
impl
Drop
for
LocalEnterGuard
{
fn
drop
(
&
mut
self
)
{
CURRENT
.
with
(
|
LocalData
{
ctx
.
.
}
|
{
ctx
.
set
(
self
.
0
.
take
(
)
)
;
}
)
}
}
impl
fmt
:
:
Debug
for
LocalEnterGuard
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
LocalEnterGuard
"
)
.
finish
(
)
}
}
impl
LocalSet
{
pub
fn
new
(
)
-
>
LocalSet
{
let
owner
=
context
:
:
thread_id
(
)
.
expect
(
"
cannot
create
LocalSet
during
thread
shutdown
"
)
;
LocalSet
{
tick
:
Cell
:
:
new
(
0
)
context
:
Rc
:
:
new
(
Context
{
shared
:
Arc
:
:
new
(
Shared
{
local_state
:
LocalState
{
owner
owned
:
LocalOwnedTasks
:
:
new
(
)
local_queue
:
UnsafeCell
:
:
new
(
VecDeque
:
:
with_capacity
(
INITIAL_CAPACITY
)
)
}
queue
:
Mutex
:
:
new
(
Some
(
VecDeque
:
:
with_capacity
(
INITIAL_CAPACITY
)
)
)
waker
:
AtomicWaker
:
:
new
(
)
#
[
cfg
(
tokio_unstable
)
]
unhandled_panic
:
crate
:
:
runtime
:
:
UnhandledPanic
:
:
Ignore
}
)
unhandled_panic
:
Cell
:
:
new
(
false
)
}
)
_not_send
:
PhantomData
}
}
pub
fn
enter
(
&
self
)
-
>
LocalEnterGuard
{
CURRENT
.
with
(
|
LocalData
{
ctx
.
.
}
|
{
let
old
=
ctx
.
replace
(
Some
(
self
.
context
.
clone
(
)
)
)
;
LocalEnterGuard
(
old
)
}
)
}
#
[
track_caller
]
pub
fn
spawn_local
<
F
>
(
&
self
future
:
F
)
-
>
JoinHandle
<
F
:
:
Output
>
where
F
:
Future
+
'
static
F
:
:
Output
:
'
static
{
self
.
spawn_named
(
future
None
)
}
#
[
track_caller
]
#
[
cfg
(
feature
=
"
rt
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
rt
"
)
)
)
]
pub
fn
block_on
<
F
>
(
&
self
rt
:
&
crate
:
:
runtime
:
:
Runtime
future
:
F
)
-
>
F
:
:
Output
where
F
:
Future
{
rt
.
block_on
(
self
.
run_until
(
future
)
)
}
pub
async
fn
run_until
<
F
>
(
&
self
future
:
F
)
-
>
F
:
:
Output
where
F
:
Future
{
let
run_until
=
RunUntil
{
future
local_set
:
self
}
;
run_until
.
await
}
pub
(
in
crate
:
:
task
)
fn
spawn_named
<
F
>
(
&
self
future
:
F
name
:
Option
<
&
str
>
)
-
>
JoinHandle
<
F
:
:
Output
>
where
F
:
Future
+
'
static
F
:
:
Output
:
'
static
{
let
handle
=
self
.
context
.
spawn
(
future
name
)
;
self
.
context
.
shared
.
waker
.
wake
(
)
;
handle
}
fn
tick
(
&
self
)
-
>
bool
{
for
_
in
0
.
.
MAX_TASKS_PER_TICK
{
if
self
.
context
.
unhandled_panic
.
get
(
)
{
panic
!
(
"
a
spawned
task
panicked
and
the
LocalSet
is
configured
to
shutdown
on
unhandled
panic
"
)
;
}
match
self
.
next_task
(
)
{
Some
(
task
)
=
>
crate
:
:
runtime
:
:
coop
:
:
budget
(
|
|
task
.
run
(
)
)
None
=
>
return
false
}
}
true
}
fn
next_task
(
&
self
)
-
>
Option
<
task
:
:
LocalNotified
<
Arc
<
Shared
>
>
>
{
let
tick
=
self
.
tick
.
get
(
)
;
self
.
tick
.
set
(
tick
.
wrapping_add
(
1
)
)
;
let
task
=
if
tick
%
REMOTE_FIRST_INTERVAL
=
=
0
{
self
.
context
.
shared
.
queue
.
lock
(
)
.
as_mut
(
)
.
and_then
(
|
queue
|
queue
.
pop_front
(
)
)
.
or_else
(
|
|
self
.
pop_local
(
)
)
}
else
{
self
.
pop_local
(
)
.
or_else
(
|
|
{
self
.
context
.
shared
.
queue
.
lock
(
)
.
as_mut
(
)
.
and_then
(
|
queue
|
queue
.
pop_front
(
)
)
}
)
}
;
task
.
map
(
|
task
|
unsafe
{
self
.
context
.
shared
.
local_state
.
assert_owner
(
task
)
}
)
}
fn
pop_local
(
&
self
)
-
>
Option
<
task
:
:
Notified
<
Arc
<
Shared
>
>
>
{
unsafe
{
self
.
context
.
shared
.
local_state
.
task_pop_front
(
)
}
}
fn
with
<
T
>
(
&
self
f
:
impl
FnOnce
(
)
-
>
T
)
-
>
T
{
CURRENT
.
with
(
|
LocalData
{
ctx
.
.
}
|
{
struct
Reset
<
'
a
>
{
ctx_ref
:
&
'
a
RcCell
<
Context
>
val
:
Option
<
Rc
<
Context
>
>
}
impl
<
'
a
>
Drop
for
Reset
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
self
.
ctx_ref
.
set
(
self
.
val
.
take
(
)
)
;
}
}
let
old
=
ctx
.
replace
(
Some
(
self
.
context
.
clone
(
)
)
)
;
let
_reset
=
Reset
{
ctx_ref
:
ctx
val
:
old
}
;
f
(
)
}
)
}
fn
with_if_possible
<
T
>
(
&
self
f
:
impl
FnOnce
(
)
-
>
T
)
-
>
T
{
let
mut
f
=
Some
(
f
)
;
let
res
=
CURRENT
.
try_with
(
|
LocalData
{
ctx
.
.
}
|
{
struct
Reset
<
'
a
>
{
ctx_ref
:
&
'
a
RcCell
<
Context
>
val
:
Option
<
Rc
<
Context
>
>
}
impl
<
'
a
>
Drop
for
Reset
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
self
.
ctx_ref
.
replace
(
self
.
val
.
take
(
)
)
;
}
}
let
old
=
ctx
.
replace
(
Some
(
self
.
context
.
clone
(
)
)
)
;
let
_reset
=
Reset
{
ctx_ref
:
ctx
val
:
old
}
;
(
f
.
take
(
)
.
unwrap
(
)
)
(
)
}
)
;
match
res
{
Ok
(
res
)
=
>
res
Err
(
_access_error
)
=
>
(
f
.
take
(
)
.
unwrap
(
)
)
(
)
}
}
}
cfg_unstable
!
{
impl
LocalSet
{
/
/
/
Configure
how
the
LocalSet
responds
to
an
unhandled
panic
on
a
/
/
/
spawned
task
.
/
/
/
/
/
/
By
default
an
unhandled
panic
(
i
.
e
.
a
panic
not
caught
by
/
/
/
[
std
:
:
panic
:
:
catch_unwind
]
)
has
no
impact
on
the
LocalSet
'
s
/
/
/
execution
.
The
panic
is
error
value
is
forwarded
to
the
task
'
s
/
/
/
[
JoinHandle
]
and
all
other
spawned
tasks
continue
running
.
/
/
/
/
/
/
The
unhandled_panic
option
enables
configuring
this
behavior
.
/
/
/
/
/
/
*
UnhandledPanic
:
:
Ignore
is
the
default
behavior
.
Panics
on
/
/
/
spawned
tasks
have
no
impact
on
the
LocalSet
'
s
execution
.
/
/
/
*
UnhandledPanic
:
:
ShutdownRuntime
will
force
the
LocalSet
to
/
/
/
shutdown
immediately
when
a
spawned
task
panics
even
if
that
/
/
/
task
'
s
JoinHandle
has
not
been
dropped
.
All
other
spawned
tasks
/
/
/
will
immediately
terminate
and
further
calls
to
/
/
/
[
LocalSet
:
:
block_on
]
and
[
LocalSet
:
:
run_until
]
will
panic
.
/
/
/
/
/
/
#
Panics
/
/
/
/
/
/
This
method
panics
if
called
after
the
LocalSet
has
started
/
/
/
running
.
/
/
/
/
/
/
#
Unstable
/
/
/
/
/
/
This
option
is
currently
unstable
and
its
implementation
is
/
/
/
incomplete
.
The
API
may
change
or
be
removed
in
the
future
.
See
/
/
/
tokio
-
rs
/
tokio
#
4516
for
more
details
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
The
following
demonstrates
a
LocalSet
configured
to
shutdown
on
/
/
/
panic
.
The
first
spawned
task
panics
and
results
in
the
LocalSet
/
/
/
shutting
down
.
The
second
spawned
task
never
has
a
chance
to
/
/
/
execute
.
The
call
to
run_until
will
panic
due
to
the
runtime
being
/
/
/
forcibly
shutdown
.
/
/
/
/
/
/
should_panic
/
/
/
use
tokio
:
:
runtime
:
:
UnhandledPanic
;
/
/
/
/
/
/
#
#
[
tokio
:
:
main
]
/
/
/
#
async
fn
main
(
)
{
/
/
/
tokio
:
:
task
:
:
LocalSet
:
:
new
(
)
/
/
/
.
unhandled_panic
(
UnhandledPanic
:
:
ShutdownRuntime
)
/
/
/
.
run_until
(
async
{
/
/
/
tokio
:
:
task
:
:
spawn_local
(
async
{
panic
!
(
"
boom
"
)
;
}
)
;
/
/
/
tokio
:
:
task
:
:
spawn_local
(
async
{
/
/
/
/
/
This
task
never
completes
/
/
/
}
)
;
/
/
/
/
/
/
/
/
Do
some
work
but
run_until
will
panic
before
it
completes
/
/
/
#
loop
{
tokio
:
:
task
:
:
yield_now
(
)
.
await
;
}
/
/
/
}
)
/
/
/
.
await
;
/
/
/
#
}
/
/
/
/
/
/
/
/
/
[
JoinHandle
]
:
struct
crate
:
:
task
:
:
JoinHandle
pub
fn
unhandled_panic
(
&
mut
self
behavior
:
crate
:
:
runtime
:
:
UnhandledPanic
)
-
>
&
mut
Self
{
/
/
TODO
:
This
should
be
set
as
a
builder
Rc
:
:
get_mut
(
&
mut
self
.
context
)
.
and_then
(
|
ctx
|
Arc
:
:
get_mut
(
&
mut
ctx
.
shared
)
)
.
expect
(
"
Unhandled
Panic
behavior
modified
after
starting
LocalSet
"
)
.
unhandled_panic
=
behavior
;
self
}
}
}
impl
fmt
:
:
Debug
for
LocalSet
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
LocalSet
"
)
.
finish
(
)
}
}
impl
Future
for
LocalSet
{
type
Output
=
(
)
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
std
:
:
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
self
.
context
.
shared
.
waker
.
register_by_ref
(
cx
.
waker
(
)
)
;
if
self
.
with
(
|
|
self
.
tick
(
)
)
{
cx
.
waker
(
)
.
wake_by_ref
(
)
;
Poll
:
:
Pending
}
else
if
unsafe
{
self
.
context
.
shared
.
local_state
.
owned_is_empty
(
)
}
{
Poll
:
:
Ready
(
(
)
)
}
else
{
Poll
:
:
Pending
}
}
}
impl
Default
for
LocalSet
{
fn
default
(
)
-
>
LocalSet
{
LocalSet
:
:
new
(
)
}
}
impl
Drop
for
LocalSet
{
fn
drop
(
&
mut
self
)
{
self
.
with_if_possible
(
|
|
{
unsafe
{
self
.
context
.
shared
.
local_state
.
close_and_shutdown_all
(
)
;
}
let
local_queue
=
unsafe
{
self
.
context
.
shared
.
local_state
.
take_local_queue
(
)
}
;
for
task
in
local_queue
{
drop
(
task
)
;
}
let
queue
=
self
.
context
.
shared
.
queue
.
lock
(
)
.
take
(
)
.
unwrap
(
)
;
for
task
in
queue
{
drop
(
task
)
;
}
assert
!
(
unsafe
{
self
.
context
.
shared
.
local_state
.
owned_is_empty
(
)
}
)
;
}
)
;
}
}
impl
Context
{
#
[
track_caller
]
fn
spawn
<
F
>
(
&
self
future
:
F
name
:
Option
<
&
str
>
)
-
>
JoinHandle
<
F
:
:
Output
>
where
F
:
Future
+
'
static
F
:
:
Output
:
'
static
{
let
id
=
crate
:
:
runtime
:
:
task
:
:
Id
:
:
next
(
)
;
let
future
=
crate
:
:
util
:
:
trace
:
:
task
(
future
"
local
"
name
id
.
as_u64
(
)
)
;
let
(
handle
notified
)
=
{
self
.
shared
.
local_state
.
assert_called_from_owner_thread
(
)
;
self
.
shared
.
local_state
.
owned
.
bind
(
future
self
.
shared
.
clone
(
)
id
)
}
;
if
let
Some
(
notified
)
=
notified
{
self
.
shared
.
schedule
(
notified
)
;
}
handle
}
}
impl
<
T
:
Future
>
Future
for
RunUntil
<
'
_
T
>
{
type
Output
=
T
:
:
Output
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
std
:
:
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
me
=
self
.
project
(
)
;
me
.
local_set
.
with
(
|
|
{
me
.
local_set
.
context
.
shared
.
waker
.
register_by_ref
(
cx
.
waker
(
)
)
;
let
_no_blocking
=
crate
:
:
runtime
:
:
context
:
:
disallow_block_in_place
(
)
;
let
f
=
me
.
future
;
if
let
Poll
:
:
Ready
(
output
)
=
f
.
poll
(
cx
)
{
return
Poll
:
:
Ready
(
output
)
;
}
if
me
.
local_set
.
tick
(
)
{
cx
.
waker
(
)
.
wake_by_ref
(
)
;
}
Poll
:
:
Pending
}
)
}
}
impl
Shared
{
fn
schedule
(
&
self
task
:
task
:
:
Notified
<
Arc
<
Self
>
>
)
{
CURRENT
.
with
(
|
localdata
|
{
match
localdata
.
ctx
.
get
(
)
{
Some
(
cx
)
if
cx
.
shared
.
ptr_eq
(
self
)
=
>
unsafe
{
cx
.
shared
.
local_state
.
task_push_back
(
task
)
;
}
_
if
context
:
:
thread_id
(
)
.
ok
(
)
=
=
Some
(
self
.
local_state
.
owner
)
=
>
{
unsafe
{
self
.
local_state
.
task_push_back
(
task
)
;
}
self
.
waker
.
wake
(
)
;
}
_
=
>
{
let
mut
lock
=
self
.
queue
.
lock
(
)
;
if
let
Some
(
queue
)
=
lock
.
as_mut
(
)
{
queue
.
push_back
(
task
)
;
drop
(
lock
)
;
self
.
waker
.
wake
(
)
;
}
}
}
}
)
;
}
fn
ptr_eq
(
&
self
other
:
&
Shared
)
-
>
bool
{
std
:
:
ptr
:
:
eq
(
self
other
)
}
}
unsafe
impl
Sync
for
Shared
{
}
impl
task
:
:
Schedule
for
Arc
<
Shared
>
{
fn
release
(
&
self
task
:
&
Task
<
Self
>
)
-
>
Option
<
Task
<
Self
>
>
{
unsafe
{
self
.
local_state
.
task_remove
(
task
)
}
}
fn
schedule
(
&
self
task
:
task
:
:
Notified
<
Self
>
)
{
Shared
:
:
schedule
(
self
task
)
;
}
cfg_unstable
!
{
fn
unhandled_panic
(
&
self
)
{
use
crate
:
:
runtime
:
:
UnhandledPanic
;
match
self
.
unhandled_panic
{
UnhandledPanic
:
:
Ignore
=
>
{
/
/
Do
nothing
}
UnhandledPanic
:
:
ShutdownRuntime
=
>
{
/
/
This
hook
is
only
called
from
within
the
runtime
so
/
/
CURRENT
should
match
with
&
self
i
.
e
.
there
is
no
/
/
opportunity
for
a
nested
scheduler
to
be
called
.
CURRENT
.
with
(
|
LocalData
{
ctx
.
.
}
|
match
ctx
.
get
(
)
{
Some
(
cx
)
if
Arc
:
:
ptr_eq
(
self
&
cx
.
shared
)
=
>
{
cx
.
unhandled_panic
.
set
(
true
)
;
/
/
Safety
:
this
is
always
called
from
the
thread
that
owns
LocalSet
unsafe
{
cx
.
shared
.
local_state
.
close_and_shutdown_all
(
)
;
}
}
_
=
>
unreachable
!
(
"
runtime
core
not
set
in
CURRENT
thread
-
local
"
)
}
)
}
}
}
}
}
impl
LocalState
{
unsafe
fn
task_pop_front
(
&
self
)
-
>
Option
<
task
:
:
Notified
<
Arc
<
Shared
>
>
>
{
self
.
assert_called_from_owner_thread
(
)
;
self
.
local_queue
.
with_mut
(
|
ptr
|
(
*
ptr
)
.
pop_front
(
)
)
}
unsafe
fn
task_push_back
(
&
self
task
:
task
:
:
Notified
<
Arc
<
Shared
>
>
)
{
self
.
assert_called_from_owner_thread
(
)
;
self
.
local_queue
.
with_mut
(
|
ptr
|
(
*
ptr
)
.
push_back
(
task
)
)
}
unsafe
fn
take_local_queue
(
&
self
)
-
>
VecDeque
<
task
:
:
Notified
<
Arc
<
Shared
>
>
>
{
self
.
assert_called_from_owner_thread
(
)
;
self
.
local_queue
.
with_mut
(
|
ptr
|
std
:
:
mem
:
:
take
(
&
mut
(
*
ptr
)
)
)
}
unsafe
fn
task_remove
(
&
self
task
:
&
Task
<
Arc
<
Shared
>
>
)
-
>
Option
<
Task
<
Arc
<
Shared
>
>
>
{
self
.
assert_called_from_owner_thread
(
)
;
self
.
owned
.
remove
(
task
)
}
unsafe
fn
owned_is_empty
(
&
self
)
-
>
bool
{
self
.
assert_called_from_owner_thread
(
)
;
self
.
owned
.
is_empty
(
)
}
unsafe
fn
assert_owner
(
&
self
task
:
task
:
:
Notified
<
Arc
<
Shared
>
>
)
-
>
task
:
:
LocalNotified
<
Arc
<
Shared
>
>
{
self
.
assert_called_from_owner_thread
(
)
;
self
.
owned
.
assert_owner
(
task
)
}
unsafe
fn
close_and_shutdown_all
(
&
self
)
{
self
.
assert_called_from_owner_thread
(
)
;
self
.
owned
.
close_and_shutdown_all
(
)
}
#
[
track_caller
]
fn
assert_called_from_owner_thread
(
&
self
)
{
#
[
cfg
(
not
(
any
(
target_os
=
"
openbsd
"
target_os
=
"
freebsd
"
)
)
)
]
debug_assert
!
(
/
/
if
we
couldn
'
t
get
the
thread
ID
because
we
'
re
dropping
the
local
/
/
data
skip
the
assertion
-
-
-
the
Drop
impl
is
not
going
to
be
/
/
called
from
another
thread
because
LocalSet
is
!
Send
context
:
:
thread_id
(
)
.
map
(
|
id
|
id
=
=
self
.
owner
)
.
unwrap_or
(
true
)
"
LocalSet
'
s
local
run
queue
must
not
be
accessed
by
another
thread
!
"
)
;
}
}
unsafe
impl
Send
for
LocalState
{
}
#
[
cfg
(
all
(
test
not
(
loom
)
)
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
local_current_thread_scheduler
(
)
{
let
f
=
async
{
LocalSet
:
:
new
(
)
.
run_until
(
async
{
spawn_local
(
async
{
}
)
.
await
.
unwrap
(
)
;
}
)
.
await
;
}
;
crate
:
:
runtime
:
:
Builder
:
:
new_current_thread
(
)
.
build
(
)
.
expect
(
"
rt
"
)
.
block_on
(
f
)
}
#
[
test
]
fn
wakes_to_local_queue
(
)
{
use
super
:
:
*
;
use
crate
:
:
sync
:
:
Notify
;
let
rt
=
crate
:
:
runtime
:
:
Builder
:
:
new_current_thread
(
)
.
build
(
)
.
expect
(
"
rt
"
)
;
rt
.
block_on
(
async
{
let
local
=
LocalSet
:
:
new
(
)
;
let
notify
=
Arc
:
:
new
(
Notify
:
:
new
(
)
)
;
let
task
=
local
.
spawn_local
(
{
let
notify
=
notify
.
clone
(
)
;
async
move
{
notify
.
notified
(
)
.
await
;
}
}
)
;
let
mut
run_until
=
Box
:
:
pin
(
local
.
run_until
(
async
move
{
task
.
await
.
unwrap
(
)
;
}
)
)
;
crate
:
:
future
:
:
poll_fn
(
|
cx
|
{
let
_
=
run_until
.
as_mut
(
)
.
poll
(
cx
)
;
Poll
:
:
Ready
(
(
)
)
}
)
.
await
;
notify
.
notify_one
(
)
;
let
task
=
unsafe
{
local
.
context
.
shared
.
local_state
.
task_pop_front
(
)
}
;
assert
!
(
task
.
is_some
(
)
"
task
should
have
been
notified
to
the
LocalSet
'
s
local
queue
"
)
;
}
)
}
}
