use
crate
:
:
runtime
:
:
BOX_FUTURE_THRESHOLD
;
use
crate
:
:
task
:
:
JoinHandle
;
use
crate
:
:
util
:
:
trace
:
:
SpawnMeta
;
use
std
:
:
future
:
:
Future
;
cfg_rt
!
{
/
/
/
Spawns
a
new
asynchronous
task
returning
a
/
/
/
[
JoinHandle
]
(
JoinHandle
)
for
it
.
/
/
/
/
/
/
The
provided
future
will
start
running
in
the
background
immediately
/
/
/
when
spawn
is
called
even
if
you
don
'
t
await
the
returned
/
/
/
JoinHandle
.
#
[
track_caller
]
pub
fn
spawn
<
F
>
(
future
:
F
)
-
>
JoinHandle
<
F
:
:
Output
>
where
F
:
Future
+
Send
+
'
static
F
:
:
Output
:
Send
+
'
static
{
let
fut_size
=
std
:
:
mem
:
:
size_of
:
:
<
F
>
(
)
;
if
fut_size
>
BOX_FUTURE_THRESHOLD
{
spawn_inner
(
Box
:
:
pin
(
future
)
SpawnMeta
:
:
new_unnamed
(
fut_size
)
)
}
else
{
spawn_inner
(
future
SpawnMeta
:
:
new_unnamed
(
fut_size
)
)
}
}
#
[
track_caller
]
pub
(
super
)
fn
spawn_inner
<
T
>
(
future
:
T
meta
:
SpawnMeta
<
'
_
>
)
-
>
JoinHandle
<
T
:
:
Output
>
where
T
:
Future
+
Send
+
'
static
T
:
:
Output
:
Send
+
'
static
{
use
crate
:
:
runtime
:
:
{
context
task
}
;
#
[
cfg
(
all
(
tokio_unstable
tokio_taskdump
feature
=
"
rt
"
target_os
=
"
linux
"
any
(
target_arch
=
"
aarch64
"
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
)
]
let
future
=
task
:
:
trace
:
:
Trace
:
:
root
(
future
)
;
let
id
=
task
:
:
Id
:
:
next
(
)
;
let
task
=
crate
:
:
util
:
:
trace
:
:
task
(
future
"
task
"
meta
id
.
as_u64
(
)
)
;
match
context
:
:
with_current
(
|
handle
|
handle
.
spawn
(
task
id
)
)
{
Ok
(
join_handle
)
=
>
join_handle
Err
(
e
)
=
>
panic
!
(
"
{
}
"
e
)
}
}
}
