#
!
[
allow
(
unreachable_pub
)
]
use
crate
:
:
{
runtime
:
:
{
Handle
BOX_FUTURE_THRESHOLD
}
task
:
:
{
JoinHandle
LocalSet
}
util
:
:
trace
:
:
SpawnMeta
}
;
use
std
:
:
{
future
:
:
Future
io
mem
}
;
#
[
derive
(
Default
Debug
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
tokio_unstable
feature
=
"
tracing
"
)
)
)
)
]
pub
struct
Builder
<
'
a
>
{
name
:
Option
<
&
'
a
str
>
}
impl
<
'
a
>
Builder
<
'
a
>
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
name
(
&
self
name
:
&
'
a
str
)
-
>
Self
{
Self
{
name
:
Some
(
name
)
}
}
#
[
track_caller
]
pub
fn
spawn
<
Fut
>
(
self
future
:
Fut
)
-
>
io
:
:
Result
<
JoinHandle
<
Fut
:
:
Output
>
>
where
Fut
:
Future
+
Send
+
'
static
Fut
:
:
Output
:
Send
+
'
static
{
let
fut_size
=
mem
:
:
size_of
:
:
<
Fut
>
(
)
;
Ok
(
if
fut_size
>
BOX_FUTURE_THRESHOLD
{
super
:
:
spawn
:
:
spawn_inner
(
Box
:
:
pin
(
future
)
SpawnMeta
:
:
new
(
self
.
name
fut_size
)
)
}
else
{
super
:
:
spawn
:
:
spawn_inner
(
future
SpawnMeta
:
:
new
(
self
.
name
fut_size
)
)
}
)
}
#
[
track_caller
]
pub
fn
spawn_on
<
Fut
>
(
self
future
:
Fut
handle
:
&
Handle
)
-
>
io
:
:
Result
<
JoinHandle
<
Fut
:
:
Output
>
>
where
Fut
:
Future
+
Send
+
'
static
Fut
:
:
Output
:
Send
+
'
static
{
let
fut_size
=
mem
:
:
size_of
:
:
<
Fut
>
(
)
;
Ok
(
if
fut_size
>
BOX_FUTURE_THRESHOLD
{
handle
.
spawn_named
(
Box
:
:
pin
(
future
)
SpawnMeta
:
:
new
(
self
.
name
fut_size
)
)
}
else
{
handle
.
spawn_named
(
future
SpawnMeta
:
:
new
(
self
.
name
fut_size
)
)
}
)
}
#
[
track_caller
]
pub
fn
spawn_local
<
Fut
>
(
self
future
:
Fut
)
-
>
io
:
:
Result
<
JoinHandle
<
Fut
:
:
Output
>
>
where
Fut
:
Future
+
'
static
Fut
:
:
Output
:
'
static
{
let
fut_size
=
mem
:
:
size_of
:
:
<
Fut
>
(
)
;
Ok
(
if
fut_size
>
BOX_FUTURE_THRESHOLD
{
super
:
:
local
:
:
spawn_local_inner
(
Box
:
:
pin
(
future
)
SpawnMeta
:
:
new
(
self
.
name
fut_size
)
)
}
else
{
super
:
:
local
:
:
spawn_local_inner
(
future
SpawnMeta
:
:
new
(
self
.
name
fut_size
)
)
}
)
}
#
[
track_caller
]
pub
fn
spawn_local_on
<
Fut
>
(
self
future
:
Fut
local_set
:
&
LocalSet
)
-
>
io
:
:
Result
<
JoinHandle
<
Fut
:
:
Output
>
>
where
Fut
:
Future
+
'
static
Fut
:
:
Output
:
'
static
{
let
fut_size
=
mem
:
:
size_of
:
:
<
Fut
>
(
)
;
Ok
(
if
fut_size
>
BOX_FUTURE_THRESHOLD
{
local_set
.
spawn_named
(
Box
:
:
pin
(
future
)
SpawnMeta
:
:
new
(
self
.
name
fut_size
)
)
}
else
{
local_set
.
spawn_named
(
future
SpawnMeta
:
:
new
(
self
.
name
fut_size
)
)
}
)
}
#
[
track_caller
]
pub
fn
spawn_blocking
<
Function
Output
>
(
self
function
:
Function
)
-
>
io
:
:
Result
<
JoinHandle
<
Output
>
>
where
Function
:
FnOnce
(
)
-
>
Output
+
Send
+
'
static
Output
:
Send
+
'
static
{
let
handle
=
Handle
:
:
current
(
)
;
self
.
spawn_blocking_on
(
function
&
handle
)
}
#
[
track_caller
]
pub
fn
spawn_blocking_on
<
Function
Output
>
(
self
function
:
Function
handle
:
&
Handle
)
-
>
io
:
:
Result
<
JoinHandle
<
Output
>
>
where
Function
:
FnOnce
(
)
-
>
Output
+
Send
+
'
static
Output
:
Send
+
'
static
{
use
crate
:
:
runtime
:
:
Mandatory
;
let
fn_size
=
mem
:
:
size_of
:
:
<
Function
>
(
)
;
let
(
join_handle
spawn_result
)
=
if
fn_size
>
BOX_FUTURE_THRESHOLD
{
handle
.
inner
.
blocking_spawner
(
)
.
spawn_blocking_inner
(
Box
:
:
new
(
function
)
Mandatory
:
:
NonMandatory
SpawnMeta
:
:
new
(
self
.
name
fn_size
)
handle
)
}
else
{
handle
.
inner
.
blocking_spawner
(
)
.
spawn_blocking_inner
(
function
Mandatory
:
:
NonMandatory
SpawnMeta
:
:
new
(
self
.
name
fn_size
)
handle
)
}
;
spawn_result
?
;
Ok
(
join_handle
)
}
}
