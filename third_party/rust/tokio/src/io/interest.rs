#
!
[
cfg_attr
(
not
(
feature
=
"
net
"
)
allow
(
dead_code
unreachable_pub
)
)
]
use
crate
:
:
io
:
:
ready
:
:
Ready
;
use
std
:
:
fmt
;
use
std
:
:
ops
;
const
READABLE
:
usize
=
0b0001
;
const
WRITABLE
:
usize
=
0b0010
;
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
const
AIO
:
usize
=
0b0100
;
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
const
LIO
:
usize
=
0b1000
;
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
const
PRIORITY
:
usize
=
0b0001_0000
;
const
ERROR
:
usize
=
0b0010_0000
;
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
net
"
)
)
)
]
#
[
derive
(
Clone
Copy
Eq
PartialEq
)
]
pub
struct
Interest
(
usize
)
;
impl
Interest
{
cfg_aio
!
{
/
/
/
Interest
for
POSIX
AIO
.
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
pub
const
AIO
:
Interest
=
Interest
(
AIO
)
;
/
/
/
Interest
for
POSIX
AIO
.
#
[
cfg
(
not
(
target_os
=
"
freebsd
"
)
)
]
pub
const
AIO
:
Interest
=
Interest
(
READABLE
)
;
/
/
/
Interest
for
POSIX
AIO
lio_listio
events
.
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
pub
const
LIO
:
Interest
=
Interest
(
LIO
)
;
/
/
/
Interest
for
POSIX
AIO
lio_listio
events
.
#
[
cfg
(
not
(
target_os
=
"
freebsd
"
)
)
]
pub
const
LIO
:
Interest
=
Interest
(
READABLE
)
;
}
pub
const
READABLE
:
Interest
=
Interest
(
READABLE
)
;
pub
const
WRITABLE
:
Interest
=
Interest
(
WRITABLE
)
;
pub
const
ERROR
:
Interest
=
Interest
(
ERROR
)
;
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
)
)
]
pub
const
PRIORITY
:
Interest
=
Interest
(
PRIORITY
)
;
pub
const
fn
is_readable
(
self
)
-
>
bool
{
self
.
0
&
READABLE
!
=
0
}
pub
const
fn
is_writable
(
self
)
-
>
bool
{
self
.
0
&
WRITABLE
!
=
0
}
pub
const
fn
is_error
(
self
)
-
>
bool
{
self
.
0
&
ERROR
!
=
0
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
const
fn
is_aio
(
self
)
-
>
bool
{
self
.
0
&
AIO
!
=
0
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
const
fn
is_lio
(
self
)
-
>
bool
{
self
.
0
&
LIO
!
=
0
}
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
)
)
]
pub
const
fn
is_priority
(
self
)
-
>
bool
{
self
.
0
&
PRIORITY
!
=
0
}
#
[
must_use
=
"
this
returns
the
result
of
the
operation
without
modifying
the
original
"
]
pub
const
fn
add
(
self
other
:
Interest
)
-
>
Interest
{
Self
(
self
.
0
|
other
.
0
)
}
#
[
must_use
=
"
this
returns
the
result
of
the
operation
without
modifying
the
original
"
]
pub
fn
remove
(
self
other
:
Interest
)
-
>
Option
<
Interest
>
{
let
value
=
self
.
0
&
!
other
.
0
;
if
value
!
=
0
{
Some
(
Self
(
value
)
)
}
else
{
None
}
}
pub
(
crate
)
fn
to_mio
(
self
)
-
>
mio
:
:
Interest
{
fn
mio_add
(
wrapped
:
&
mut
Option
<
mio
:
:
Interest
>
add
:
mio
:
:
Interest
)
{
match
wrapped
{
Some
(
inner
)
=
>
*
inner
|
=
add
None
=
>
*
wrapped
=
Some
(
add
)
}
}
let
mut
mio
=
None
;
if
self
.
is_readable
(
)
{
mio_add
(
&
mut
mio
mio
:
:
Interest
:
:
READABLE
)
;
}
if
self
.
is_writable
(
)
{
mio_add
(
&
mut
mio
mio
:
:
Interest
:
:
WRITABLE
)
;
}
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
if
self
.
is_priority
(
)
{
mio_add
(
&
mut
mio
mio
:
:
Interest
:
:
PRIORITY
)
;
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
if
self
.
is_aio
(
)
{
mio_add
(
&
mut
mio
mio
:
:
Interest
:
:
AIO
)
;
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
if
self
.
is_lio
(
)
{
mio_add
(
&
mut
mio
mio
:
:
Interest
:
:
LIO
)
;
}
if
self
.
is_error
(
)
{
mio_add
(
&
mut
mio
mio
:
:
Interest
:
:
READABLE
)
;
}
mio
.
unwrap_or
(
mio
:
:
Interest
:
:
READABLE
)
}
pub
(
crate
)
fn
mask
(
self
)
-
>
Ready
{
match
self
{
Interest
:
:
READABLE
=
>
Ready
:
:
READABLE
|
Ready
:
:
READ_CLOSED
Interest
:
:
WRITABLE
=
>
Ready
:
:
WRITABLE
|
Ready
:
:
WRITE_CLOSED
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
Interest
:
:
PRIORITY
=
>
Ready
:
:
PRIORITY
|
Ready
:
:
READ_CLOSED
Interest
:
:
ERROR
=
>
Ready
:
:
ERROR
_
=
>
Ready
:
:
EMPTY
}
}
}
impl
ops
:
:
BitOr
for
Interest
{
type
Output
=
Self
;
#
[
inline
]
fn
bitor
(
self
other
:
Self
)
-
>
Self
{
self
.
add
(
other
)
}
}
impl
ops
:
:
BitOrAssign
for
Interest
{
#
[
inline
]
fn
bitor_assign
(
&
mut
self
other
:
Self
)
{
*
self
=
*
self
|
other
;
}
}
impl
fmt
:
:
Debug
for
Interest
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
mut
separator
=
false
;
if
self
.
is_readable
(
)
{
if
separator
{
write
!
(
fmt
"
|
"
)
?
;
}
write
!
(
fmt
"
READABLE
"
)
?
;
separator
=
true
;
}
if
self
.
is_writable
(
)
{
if
separator
{
write
!
(
fmt
"
|
"
)
?
;
}
write
!
(
fmt
"
WRITABLE
"
)
?
;
separator
=
true
;
}
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
if
self
.
is_priority
(
)
{
if
separator
{
write
!
(
fmt
"
|
"
)
?
;
}
write
!
(
fmt
"
PRIORITY
"
)
?
;
separator
=
true
;
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
if
self
.
is_aio
(
)
{
if
separator
{
write
!
(
fmt
"
|
"
)
?
;
}
write
!
(
fmt
"
AIO
"
)
?
;
separator
=
true
;
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
if
self
.
is_lio
(
)
{
if
separator
{
write
!
(
fmt
"
|
"
)
?
;
}
write
!
(
fmt
"
LIO
"
)
?
;
separator
=
true
;
}
if
self
.
is_error
(
)
{
if
separator
{
write
!
(
fmt
"
|
"
)
?
;
}
write
!
(
fmt
"
ERROR
"
)
?
;
separator
=
true
;
}
let
_
=
separator
;
Ok
(
(
)
)
}
}
