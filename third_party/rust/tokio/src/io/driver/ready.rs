#
!
[
cfg_attr
(
not
(
feature
=
"
net
"
)
allow
(
unreachable_pub
)
)
]
use
std
:
:
fmt
;
use
std
:
:
ops
;
const
READABLE
:
usize
=
0b0_01
;
const
WRITABLE
:
usize
=
0b0_10
;
const
READ_CLOSED
:
usize
=
0b0_0100
;
const
WRITE_CLOSED
:
usize
=
0b0_1000
;
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
net
"
)
)
)
]
#
[
derive
(
Clone
Copy
PartialEq
PartialOrd
)
]
pub
struct
Ready
(
usize
)
;
impl
Ready
{
pub
const
EMPTY
:
Ready
=
Ready
(
0
)
;
pub
const
READABLE
:
Ready
=
Ready
(
READABLE
)
;
pub
const
WRITABLE
:
Ready
=
Ready
(
WRITABLE
)
;
pub
const
READ_CLOSED
:
Ready
=
Ready
(
READ_CLOSED
)
;
pub
const
WRITE_CLOSED
:
Ready
=
Ready
(
WRITE_CLOSED
)
;
pub
const
ALL
:
Ready
=
Ready
(
READABLE
|
WRITABLE
|
READ_CLOSED
|
WRITE_CLOSED
)
;
pub
(
crate
)
fn
from_mio
(
event
:
&
mio
:
:
event
:
:
Event
)
-
>
Ready
{
let
mut
ready
=
Ready
:
:
EMPTY
;
#
[
cfg
(
all
(
target_os
=
"
freebsd
"
feature
=
"
net
"
)
)
]
{
if
event
.
is_aio
(
)
{
ready
|
=
Ready
:
:
READABLE
;
}
if
event
.
is_lio
(
)
{
ready
|
=
Ready
:
:
READABLE
;
}
}
if
event
.
is_readable
(
)
{
ready
|
=
Ready
:
:
READABLE
;
}
if
event
.
is_writable
(
)
{
ready
|
=
Ready
:
:
WRITABLE
;
}
if
event
.
is_read_closed
(
)
{
ready
|
=
Ready
:
:
READ_CLOSED
;
}
if
event
.
is_write_closed
(
)
{
ready
|
=
Ready
:
:
WRITE_CLOSED
;
}
ready
}
pub
fn
is_empty
(
self
)
-
>
bool
{
self
=
=
Ready
:
:
EMPTY
}
pub
fn
is_readable
(
self
)
-
>
bool
{
self
.
contains
(
Ready
:
:
READABLE
)
|
|
self
.
is_read_closed
(
)
}
pub
fn
is_writable
(
self
)
-
>
bool
{
self
.
contains
(
Ready
:
:
WRITABLE
)
|
|
self
.
is_write_closed
(
)
}
pub
fn
is_read_closed
(
self
)
-
>
bool
{
self
.
contains
(
Ready
:
:
READ_CLOSED
)
}
pub
fn
is_write_closed
(
self
)
-
>
bool
{
self
.
contains
(
Ready
:
:
WRITE_CLOSED
)
}
pub
(
crate
)
fn
contains
<
T
:
Into
<
Self
>
>
(
self
other
:
T
)
-
>
bool
{
let
other
=
other
.
into
(
)
;
(
self
&
other
)
=
=
other
}
pub
(
crate
)
fn
from_usize
(
val
:
usize
)
-
>
Ready
{
Ready
(
val
&
Ready
:
:
ALL
.
as_usize
(
)
)
}
pub
(
crate
)
fn
as_usize
(
self
)
-
>
usize
{
self
.
0
}
}
cfg_io_readiness
!
{
use
crate
:
:
io
:
:
Interest
;
impl
Ready
{
pub
(
crate
)
fn
from_interest
(
interest
:
Interest
)
-
>
Ready
{
let
mut
ready
=
Ready
:
:
EMPTY
;
if
interest
.
is_readable
(
)
{
ready
|
=
Ready
:
:
READABLE
;
ready
|
=
Ready
:
:
READ_CLOSED
;
}
if
interest
.
is_writable
(
)
{
ready
|
=
Ready
:
:
WRITABLE
;
ready
|
=
Ready
:
:
WRITE_CLOSED
;
}
ready
}
pub
(
crate
)
fn
intersection
(
self
interest
:
Interest
)
-
>
Ready
{
Ready
(
self
.
0
&
Ready
:
:
from_interest
(
interest
)
.
0
)
}
pub
(
crate
)
fn
satisfies
(
self
interest
:
Interest
)
-
>
bool
{
self
.
0
&
Ready
:
:
from_interest
(
interest
)
.
0
!
=
0
}
}
}
impl
ops
:
:
BitOr
<
Ready
>
for
Ready
{
type
Output
=
Ready
;
#
[
inline
]
fn
bitor
(
self
other
:
Ready
)
-
>
Ready
{
Ready
(
self
.
0
|
other
.
0
)
}
}
impl
ops
:
:
BitOrAssign
<
Ready
>
for
Ready
{
#
[
inline
]
fn
bitor_assign
(
&
mut
self
other
:
Ready
)
{
self
.
0
|
=
other
.
0
;
}
}
impl
ops
:
:
BitAnd
<
Ready
>
for
Ready
{
type
Output
=
Ready
;
#
[
inline
]
fn
bitand
(
self
other
:
Ready
)
-
>
Ready
{
Ready
(
self
.
0
&
other
.
0
)
}
}
impl
ops
:
:
Sub
<
Ready
>
for
Ready
{
type
Output
=
Ready
;
#
[
inline
]
fn
sub
(
self
other
:
Ready
)
-
>
Ready
{
Ready
(
self
.
0
&
!
other
.
0
)
}
}
impl
fmt
:
:
Debug
for
Ready
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Ready
"
)
.
field
(
"
is_readable
"
&
self
.
is_readable
(
)
)
.
field
(
"
is_writable
"
&
self
.
is_writable
(
)
)
.
field
(
"
is_read_closed
"
&
self
.
is_read_closed
(
)
)
.
field
(
"
is_write_closed
"
&
self
.
is_write_closed
(
)
)
.
finish
(
)
}
}
