use
crate
:
:
io
:
:
{
Interest
Ready
}
;
use
crate
:
:
runtime
:
:
io
:
:
{
ReadyEvent
Registration
}
;
use
crate
:
:
runtime
:
:
scheduler
;
use
mio
:
:
unix
:
:
SourceFd
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsRawFd
RawFd
}
;
use
std
:
:
{
task
:
:
Context
task
:
:
Poll
}
;
pub
struct
AsyncFd
<
T
:
AsRawFd
>
{
registration
:
Registration
inner
:
Option
<
T
>
}
#
[
must_use
=
"
You
must
explicitly
choose
whether
to
clear
the
readiness
state
by
calling
a
method
on
ReadyGuard
"
]
pub
struct
AsyncFdReadyGuard
<
'
a
T
:
AsRawFd
>
{
async_fd
:
&
'
a
AsyncFd
<
T
>
event
:
Option
<
ReadyEvent
>
}
#
[
must_use
=
"
You
must
explicitly
choose
whether
to
clear
the
readiness
state
by
calling
a
method
on
ReadyGuard
"
]
pub
struct
AsyncFdReadyMutGuard
<
'
a
T
:
AsRawFd
>
{
async_fd
:
&
'
a
mut
AsyncFd
<
T
>
event
:
Option
<
ReadyEvent
>
}
impl
<
T
:
AsRawFd
>
AsyncFd
<
T
>
{
#
[
inline
]
#
[
track_caller
]
pub
fn
new
(
inner
:
T
)
-
>
io
:
:
Result
<
Self
>
where
T
:
AsRawFd
{
Self
:
:
with_interest
(
inner
Interest
:
:
READABLE
|
Interest
:
:
WRITABLE
)
}
#
[
inline
]
#
[
track_caller
]
pub
fn
with_interest
(
inner
:
T
interest
:
Interest
)
-
>
io
:
:
Result
<
Self
>
where
T
:
AsRawFd
{
Self
:
:
new_with_handle_and_interest
(
inner
scheduler
:
:
Handle
:
:
current
(
)
interest
)
}
#
[
track_caller
]
pub
(
crate
)
fn
new_with_handle_and_interest
(
inner
:
T
handle
:
scheduler
:
:
Handle
interest
:
Interest
)
-
>
io
:
:
Result
<
Self
>
{
Self
:
:
try_new_with_handle_and_interest
(
inner
handle
interest
)
.
map_err
(
Into
:
:
into
)
}
#
[
inline
]
#
[
track_caller
]
pub
fn
try_new
(
inner
:
T
)
-
>
Result
<
Self
AsyncFdTryNewError
<
T
>
>
where
T
:
AsRawFd
{
Self
:
:
try_with_interest
(
inner
Interest
:
:
READABLE
|
Interest
:
:
WRITABLE
)
}
#
[
inline
]
#
[
track_caller
]
pub
fn
try_with_interest
(
inner
:
T
interest
:
Interest
)
-
>
Result
<
Self
AsyncFdTryNewError
<
T
>
>
where
T
:
AsRawFd
{
Self
:
:
try_new_with_handle_and_interest
(
inner
scheduler
:
:
Handle
:
:
current
(
)
interest
)
}
#
[
track_caller
]
pub
(
crate
)
fn
try_new_with_handle_and_interest
(
inner
:
T
handle
:
scheduler
:
:
Handle
interest
:
Interest
)
-
>
Result
<
Self
AsyncFdTryNewError
<
T
>
>
{
let
fd
=
inner
.
as_raw_fd
(
)
;
match
Registration
:
:
new_with_interest_and_handle
(
&
mut
SourceFd
(
&
fd
)
interest
handle
)
{
Ok
(
registration
)
=
>
Ok
(
AsyncFd
{
registration
inner
:
Some
(
inner
)
}
)
Err
(
cause
)
=
>
Err
(
AsyncFdTryNewError
{
inner
cause
}
)
}
}
#
[
inline
]
pub
fn
get_ref
(
&
self
)
-
>
&
T
{
self
.
inner
.
as_ref
(
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
T
{
self
.
inner
.
as_mut
(
)
.
unwrap
(
)
}
fn
take_inner
(
&
mut
self
)
-
>
Option
<
T
>
{
let
inner
=
self
.
inner
.
take
(
)
?
;
let
fd
=
inner
.
as_raw_fd
(
)
;
let
_
=
self
.
registration
.
deregister
(
&
mut
SourceFd
(
&
fd
)
)
;
Some
(
inner
)
}
pub
fn
into_inner
(
mut
self
)
-
>
T
{
self
.
take_inner
(
)
.
unwrap
(
)
}
pub
fn
poll_read_ready
<
'
a
>
(
&
'
a
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
AsyncFdReadyGuard
<
'
a
T
>
>
>
{
let
event
=
ready
!
(
self
.
registration
.
poll_read_ready
(
cx
)
)
?
;
Poll
:
:
Ready
(
Ok
(
AsyncFdReadyGuard
{
async_fd
:
self
event
:
Some
(
event
)
}
)
)
}
pub
fn
poll_read_ready_mut
<
'
a
>
(
&
'
a
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
AsyncFdReadyMutGuard
<
'
a
T
>
>
>
{
let
event
=
ready
!
(
self
.
registration
.
poll_read_ready
(
cx
)
)
?
;
Poll
:
:
Ready
(
Ok
(
AsyncFdReadyMutGuard
{
async_fd
:
self
event
:
Some
(
event
)
}
)
)
}
pub
fn
poll_write_ready
<
'
a
>
(
&
'
a
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
AsyncFdReadyGuard
<
'
a
T
>
>
>
{
let
event
=
ready
!
(
self
.
registration
.
poll_write_ready
(
cx
)
)
?
;
Poll
:
:
Ready
(
Ok
(
AsyncFdReadyGuard
{
async_fd
:
self
event
:
Some
(
event
)
}
)
)
}
pub
fn
poll_write_ready_mut
<
'
a
>
(
&
'
a
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
AsyncFdReadyMutGuard
<
'
a
T
>
>
>
{
let
event
=
ready
!
(
self
.
registration
.
poll_write_ready
(
cx
)
)
?
;
Poll
:
:
Ready
(
Ok
(
AsyncFdReadyMutGuard
{
async_fd
:
self
event
:
Some
(
event
)
}
)
)
}
pub
async
fn
ready
(
&
self
interest
:
Interest
)
-
>
io
:
:
Result
<
AsyncFdReadyGuard
<
'
_
T
>
>
{
let
event
=
self
.
registration
.
readiness
(
interest
)
.
await
?
;
Ok
(
AsyncFdReadyGuard
{
async_fd
:
self
event
:
Some
(
event
)
}
)
}
pub
async
fn
ready_mut
(
&
mut
self
interest
:
Interest
)
-
>
io
:
:
Result
<
AsyncFdReadyMutGuard
<
'
_
T
>
>
{
let
event
=
self
.
registration
.
readiness
(
interest
)
.
await
?
;
Ok
(
AsyncFdReadyMutGuard
{
async_fd
:
self
event
:
Some
(
event
)
}
)
}
#
[
allow
(
clippy
:
:
needless_lifetimes
)
]
pub
async
fn
readable
<
'
a
>
(
&
'
a
self
)
-
>
io
:
:
Result
<
AsyncFdReadyGuard
<
'
a
T
>
>
{
self
.
ready
(
Interest
:
:
READABLE
)
.
await
}
#
[
allow
(
clippy
:
:
needless_lifetimes
)
]
pub
async
fn
readable_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
io
:
:
Result
<
AsyncFdReadyMutGuard
<
'
a
T
>
>
{
self
.
ready_mut
(
Interest
:
:
READABLE
)
.
await
}
#
[
allow
(
clippy
:
:
needless_lifetimes
)
]
pub
async
fn
writable
<
'
a
>
(
&
'
a
self
)
-
>
io
:
:
Result
<
AsyncFdReadyGuard
<
'
a
T
>
>
{
self
.
ready
(
Interest
:
:
WRITABLE
)
.
await
}
#
[
allow
(
clippy
:
:
needless_lifetimes
)
]
pub
async
fn
writable_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
io
:
:
Result
<
AsyncFdReadyMutGuard
<
'
a
T
>
>
{
self
.
ready_mut
(
Interest
:
:
WRITABLE
)
.
await
}
pub
async
fn
async_io
<
R
>
(
&
self
interest
:
Interest
mut
f
:
impl
FnMut
(
&
T
)
-
>
io
:
:
Result
<
R
>
)
-
>
io
:
:
Result
<
R
>
{
self
.
registration
.
async_io
(
interest
|
|
f
(
self
.
get_ref
(
)
)
)
.
await
}
pub
async
fn
async_io_mut
<
R
>
(
&
mut
self
interest
:
Interest
mut
f
:
impl
FnMut
(
&
mut
T
)
-
>
io
:
:
Result
<
R
>
)
-
>
io
:
:
Result
<
R
>
{
self
.
registration
.
async_io
(
interest
|
|
f
(
self
.
inner
.
as_mut
(
)
.
unwrap
(
)
)
)
.
await
}
}
impl
<
T
:
AsRawFd
>
AsRawFd
for
AsyncFd
<
T
>
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
inner
.
as_ref
(
)
.
unwrap
(
)
.
as_raw_fd
(
)
}
}
impl
<
T
:
AsRawFd
>
std
:
:
os
:
:
unix
:
:
io
:
:
AsFd
for
AsyncFd
<
T
>
{
fn
as_fd
(
&
self
)
-
>
std
:
:
os
:
:
unix
:
:
io
:
:
BorrowedFd
<
'
_
>
{
unsafe
{
std
:
:
os
:
:
unix
:
:
io
:
:
BorrowedFd
:
:
borrow_raw
(
self
.
as_raw_fd
(
)
)
}
}
}
impl
<
T
:
std
:
:
fmt
:
:
Debug
+
AsRawFd
>
std
:
:
fmt
:
:
Debug
for
AsyncFd
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
AsyncFd
"
)
.
field
(
"
inner
"
&
self
.
inner
)
.
finish
(
)
}
}
impl
<
T
:
AsRawFd
>
Drop
for
AsyncFd
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
_
=
self
.
take_inner
(
)
;
}
}
impl
<
'
a
Inner
:
AsRawFd
>
AsyncFdReadyGuard
<
'
a
Inner
>
{
pub
fn
clear_ready
(
&
mut
self
)
{
if
let
Some
(
event
)
=
self
.
event
.
take
(
)
{
self
.
async_fd
.
registration
.
clear_readiness
(
event
)
;
}
}
pub
fn
clear_ready_matching
(
&
mut
self
ready
:
Ready
)
{
if
let
Some
(
mut
event
)
=
self
.
event
.
take
(
)
{
self
.
async_fd
.
registration
.
clear_readiness
(
event
.
with_ready
(
ready
)
)
;
event
.
ready
=
event
.
ready
-
ready
;
if
!
event
.
ready
.
is_empty
(
)
{
self
.
event
=
Some
(
event
)
;
}
}
}
pub
fn
retain_ready
(
&
mut
self
)
{
}
pub
fn
ready
(
&
self
)
-
>
Ready
{
match
&
self
.
event
{
Some
(
event
)
=
>
event
.
ready
None
=
>
Ready
:
:
EMPTY
}
}
#
[
cfg_attr
(
docsrs
doc
(
alias
=
"
with_io
"
)
)
]
pub
fn
try_io
<
R
>
(
&
mut
self
f
:
impl
FnOnce
(
&
'
a
AsyncFd
<
Inner
>
)
-
>
io
:
:
Result
<
R
>
)
-
>
Result
<
io
:
:
Result
<
R
>
TryIoError
>
{
let
result
=
f
(
self
.
async_fd
)
;
match
result
{
Err
(
err
)
if
err
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
clear_ready
(
)
;
Err
(
TryIoError
(
(
)
)
)
}
result
=
>
Ok
(
result
)
}
}
pub
fn
get_ref
(
&
self
)
-
>
&
'
a
AsyncFd
<
Inner
>
{
self
.
async_fd
}
pub
fn
get_inner
(
&
self
)
-
>
&
'
a
Inner
{
self
.
get_ref
(
)
.
get_ref
(
)
}
}
impl
<
'
a
Inner
:
AsRawFd
>
AsyncFdReadyMutGuard
<
'
a
Inner
>
{
pub
fn
clear_ready
(
&
mut
self
)
{
if
let
Some
(
event
)
=
self
.
event
.
take
(
)
{
self
.
async_fd
.
registration
.
clear_readiness
(
event
)
;
}
}
pub
fn
clear_ready_matching
(
&
mut
self
ready
:
Ready
)
{
if
let
Some
(
mut
event
)
=
self
.
event
.
take
(
)
{
self
.
async_fd
.
registration
.
clear_readiness
(
event
.
with_ready
(
ready
)
)
;
event
.
ready
=
event
.
ready
-
ready
;
if
!
event
.
ready
.
is_empty
(
)
{
self
.
event
=
Some
(
event
)
;
}
}
}
pub
fn
retain_ready
(
&
mut
self
)
{
}
pub
fn
ready
(
&
self
)
-
>
Ready
{
match
&
self
.
event
{
Some
(
event
)
=
>
event
.
ready
None
=
>
Ready
:
:
EMPTY
}
}
pub
fn
try_io
<
R
>
(
&
mut
self
f
:
impl
FnOnce
(
&
mut
AsyncFd
<
Inner
>
)
-
>
io
:
:
Result
<
R
>
)
-
>
Result
<
io
:
:
Result
<
R
>
TryIoError
>
{
let
result
=
f
(
self
.
async_fd
)
;
match
result
{
Err
(
err
)
if
err
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
clear_ready
(
)
;
Err
(
TryIoError
(
(
)
)
)
}
result
=
>
Ok
(
result
)
}
}
pub
fn
get_ref
(
&
self
)
-
>
&
AsyncFd
<
Inner
>
{
self
.
async_fd
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
AsyncFd
<
Inner
>
{
self
.
async_fd
}
pub
fn
get_inner
(
&
self
)
-
>
&
Inner
{
self
.
get_ref
(
)
.
get_ref
(
)
}
pub
fn
get_inner_mut
(
&
mut
self
)
-
>
&
mut
Inner
{
self
.
get_mut
(
)
.
get_mut
(
)
}
}
impl
<
'
a
T
:
std
:
:
fmt
:
:
Debug
+
AsRawFd
>
std
:
:
fmt
:
:
Debug
for
AsyncFdReadyGuard
<
'
a
T
>
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
ReadyGuard
"
)
.
field
(
"
async_fd
"
&
self
.
async_fd
)
.
finish
(
)
}
}
impl
<
'
a
T
:
std
:
:
fmt
:
:
Debug
+
AsRawFd
>
std
:
:
fmt
:
:
Debug
for
AsyncFdReadyMutGuard
<
'
a
T
>
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
MutReadyGuard
"
)
.
field
(
"
async_fd
"
&
self
.
async_fd
)
.
finish
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
TryIoError
(
(
)
)
;
pub
struct
AsyncFdTryNewError
<
T
>
{
inner
:
T
cause
:
io
:
:
Error
}
impl
<
T
>
AsyncFdTryNewError
<
T
>
{
pub
fn
into_parts
(
self
)
-
>
(
T
io
:
:
Error
)
{
(
self
.
inner
self
.
cause
)
}
}
impl
<
T
>
fmt
:
:
Display
for
AsyncFdTryNewError
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
cause
f
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
AsyncFdTryNewError
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
self
.
cause
f
)
}
}
impl
<
T
>
Error
for
AsyncFdTryNewError
<
T
>
{
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
Error
+
'
static
)
>
{
Some
(
&
self
.
cause
)
}
}
impl
<
T
>
From
<
AsyncFdTryNewError
<
T
>
>
for
io
:
:
Error
{
fn
from
(
value
:
AsyncFdTryNewError
<
T
>
)
-
>
Self
{
value
.
cause
}
}
