use
crate
:
:
io
:
:
driver
:
:
{
Handle
Interest
ReadyEvent
Registration
}
;
use
mio
:
:
event
:
:
Source
;
use
mio
:
:
Registry
;
use
mio
:
:
Token
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
AsRawFd
;
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
RawFd
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
pub
trait
AioSource
{
fn
register
(
&
mut
self
kq
:
RawFd
token
:
usize
)
;
fn
deregister
(
&
mut
self
)
;
}
struct
MioSource
<
T
>
(
T
)
;
impl
<
T
:
AioSource
>
Source
for
MioSource
<
T
>
{
fn
register
(
&
mut
self
registry
:
&
Registry
token
:
Token
interests
:
mio
:
:
Interest
)
-
>
io
:
:
Result
<
(
)
>
{
assert
!
(
interests
.
is_aio
(
)
|
|
interests
.
is_lio
(
)
)
;
self
.
0
.
register
(
registry
.
as_raw_fd
(
)
usize
:
:
from
(
token
)
)
;
Ok
(
(
)
)
}
fn
deregister
(
&
mut
self
_registry
:
&
Registry
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
0
.
deregister
(
)
;
Ok
(
(
)
)
}
fn
reregister
(
&
mut
self
registry
:
&
Registry
token
:
Token
interests
:
mio
:
:
Interest
)
-
>
io
:
:
Result
<
(
)
>
{
assert
!
(
interests
.
is_aio
(
)
|
|
interests
.
is_lio
(
)
)
;
self
.
0
.
register
(
registry
.
as_raw_fd
(
)
usize
:
:
from
(
token
)
)
;
Ok
(
(
)
)
}
}
pub
struct
Aio
<
E
>
{
io
:
MioSource
<
E
>
registration
:
Registration
}
impl
<
E
:
AioSource
>
Aio
<
E
>
{
pub
fn
new_for_aio
(
io
:
E
)
-
>
io
:
:
Result
<
Self
>
{
Self
:
:
new_with_interest
(
io
Interest
:
:
AIO
)
}
pub
fn
new_for_lio
(
io
:
E
)
-
>
io
:
:
Result
<
Self
>
{
Self
:
:
new_with_interest
(
io
Interest
:
:
LIO
)
}
fn
new_with_interest
(
io
:
E
interest
:
Interest
)
-
>
io
:
:
Result
<
Self
>
{
let
mut
io
=
MioSource
(
io
)
;
let
handle
=
Handle
:
:
current
(
)
;
let
registration
=
Registration
:
:
new_with_interest_and_handle
(
&
mut
io
interest
handle
)
?
;
Ok
(
Self
{
io
registration
}
)
}
pub
fn
clear_ready
(
&
self
ev
:
AioEvent
)
{
self
.
registration
.
clear_readiness
(
ev
.
0
)
}
pub
fn
into_inner
(
self
)
-
>
E
{
self
.
io
.
0
}
pub
fn
poll_ready
<
'
a
>
(
&
'
a
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
AioEvent
>
>
{
let
ev
=
ready
!
(
self
.
registration
.
poll_read_ready
(
cx
)
)
?
;
Poll
:
:
Ready
(
Ok
(
AioEvent
(
ev
)
)
)
}
}
impl
<
E
:
AioSource
>
Deref
for
Aio
<
E
>
{
type
Target
=
E
;
fn
deref
(
&
self
)
-
>
&
E
{
&
self
.
io
.
0
}
}
impl
<
E
:
AioSource
>
DerefMut
for
Aio
<
E
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
E
{
&
mut
self
.
io
.
0
}
}
impl
<
E
:
AioSource
+
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Aio
<
E
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Aio
"
)
.
field
(
"
io
"
&
self
.
io
.
0
)
.
finish
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
AioEvent
(
ReadyEvent
)
;
