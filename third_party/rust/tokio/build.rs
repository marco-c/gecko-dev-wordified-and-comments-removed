use
autocfg
:
:
AutoCfg
;
const
CONST_THREAD_LOCAL_PROBE
:
&
str
=
r
#
"
{
thread_local
!
{
static
MY_PROBE
:
usize
=
const
{
10
}
;
}
MY_PROBE
.
with
(
|
val
|
*
val
)
}
"
#
;
const
CONST_MUTEX_NEW_PROBE
:
&
str
=
r
#
"
{
static
MY_MUTEX
:
:
:
std
:
:
sync
:
:
Mutex
<
i32
>
=
:
:
std
:
:
sync
:
:
Mutex
:
:
new
(
1
)
;
*
MY_MUTEX
.
lock
(
)
.
unwrap
(
)
}
"
#
;
const
AS_FD_PROBE
:
&
str
=
r
#
"
{
#
[
allow
(
unused_imports
)
]
#
[
cfg
(
unix
)
]
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
AsFd
as
_
;
#
[
allow
(
unused_imports
)
]
#
[
cfg
(
windows
)
]
use
std
:
:
os
:
:
windows
:
:
prelude
:
:
AsSocket
as
_
;
#
[
allow
(
unused_imports
)
]
#
[
cfg
(
target_os
=
"
wasi
"
)
]
use
std
:
:
os
:
:
wasi
:
:
prelude
:
:
AsFd
as
_
;
}
"
#
;
const
TARGET_HAS_ATOMIC_PROBE
:
&
str
=
r
#
"
{
#
[
cfg
(
target_has_atomic
=
"
ptr
"
)
]
let
_
=
(
)
;
}
"
#
;
const
TARGET_ATOMIC_U64_PROBE
:
&
str
=
r
#
"
{
#
[
allow
(
unused_imports
)
]
use
std
:
:
sync
:
:
atomic
:
:
AtomicU64
as
_
;
}
"
#
;
fn
main
(
)
{
let
mut
enable_const_thread_local
=
false
;
let
mut
enable_target_has_atomic
=
false
;
let
mut
enable_const_mutex_new
=
false
;
let
mut
enable_as_fd
=
false
;
let
mut
target_needs_atomic_u64_fallback
=
false
;
match
AutoCfg
:
:
new
(
)
{
Ok
(
ac
)
=
>
{
if
ac
.
probe_rustc_version
(
1
60
)
{
enable_const_thread_local
=
true
;
}
else
if
ac
.
probe_rustc_version
(
1
59
)
{
if
ac
.
probe_expression
(
CONST_THREAD_LOCAL_PROBE
)
{
enable_const_thread_local
=
true
;
}
}
if
ac
.
probe_rustc_version
(
1
61
)
{
enable_target_has_atomic
=
true
;
}
else
if
ac
.
probe_rustc_version
(
1
60
)
{
if
ac
.
probe_expression
(
TARGET_HAS_ATOMIC_PROBE
)
{
enable_target_has_atomic
=
true
;
}
}
if
!
enable_target_has_atomic
&
&
!
ac
.
probe_expression
(
TARGET_ATOMIC_U64_PROBE
)
{
target_needs_atomic_u64_fallback
=
true
;
}
if
ac
.
probe_rustc_version
(
1
64
)
{
enable_const_mutex_new
=
true
;
}
else
if
ac
.
probe_rustc_version
(
1
63
)
{
if
ac
.
probe_expression
(
CONST_MUTEX_NEW_PROBE
)
{
enable_const_mutex_new
=
true
;
}
}
if
ac
.
probe_rustc_version
(
1
64
)
{
enable_as_fd
=
true
;
}
else
if
ac
.
probe_rustc_version
(
1
63
)
{
if
ac
.
probe_expression
(
AS_FD_PROBE
)
{
enable_as_fd
=
true
;
}
}
}
Err
(
e
)
=
>
{
println
!
(
"
cargo
:
warning
=
tokio
:
failed
to
detect
compiler
features
:
{
}
"
e
)
;
}
}
if
!
enable_const_thread_local
{
autocfg
:
:
emit
(
"
tokio_no_const_thread_local
"
)
}
if
!
enable_target_has_atomic
{
autocfg
:
:
emit
(
"
tokio_no_target_has_atomic
"
)
}
if
!
enable_const_mutex_new
{
autocfg
:
:
emit
(
"
tokio_no_const_mutex_new
"
)
}
if
!
enable_as_fd
{
autocfg
:
:
emit
(
"
tokio_no_as_fd
"
)
;
}
if
target_needs_atomic_u64_fallback
{
autocfg
:
:
emit
(
"
tokio_no_atomic_u64
"
)
}
let
target
=
:
:
std
:
:
env
:
:
var
(
"
TARGET
"
)
.
unwrap_or_default
(
)
;
if
target
.
starts_with
(
"
wasm
"
)
{
autocfg
:
:
emit
(
"
tokio_wasm
"
)
;
if
target
.
contains
(
"
wasi
"
)
{
autocfg
:
:
emit
(
"
tokio_wasi
"
)
;
}
else
{
autocfg
:
:
emit
(
"
tokio_wasm_not_wasi
"
)
;
}
}
}
