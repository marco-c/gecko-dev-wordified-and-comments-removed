use
crate
:
:
free_name_tracker
:
:
FreeNameTracker
;
use
ast
:
:
associated_data
:
:
{
AssociatedData
Key
as
AssociatedDataKey
}
;
use
ast
:
:
source_atom_set
:
:
{
CommonSourceAtomSetIndices
SourceAtomSetIndex
}
;
use
ast
:
:
source_location_accessor
:
:
SourceLocationAccessor
;
use
ast
:
:
type_id
:
:
NodeTypeIdAccessor
;
use
indexmap
:
:
set
:
:
IndexSet
;
use
std
:
:
collections
:
:
HashSet
;
use
stencil
:
:
scope
:
:
{
BindingName
FunctionScopeData
GlobalScopeData
LexicalScopeData
ScopeData
ScopeDataList
ScopeDataMap
ScopeIndex
VarScopeData
}
;
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
VarScopedDeclarationsItemKind
{
#
[
allow
(
dead_code
)
]
VariableDeclaration
#
[
allow
(
dead_code
)
]
ForBinding
#
[
allow
(
dead_code
)
]
FunctionDeclaration
#
[
allow
(
dead_code
)
]
GeneratorDeclaration
#
[
allow
(
dead_code
)
]
AsyncFunctionDeclaration
#
[
allow
(
dead_code
)
]
AsyncGeneratorDeclaration
#
[
allow
(
dead_code
)
]
BindingIdentifier
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
LexicallyScopedDeclarations
{
#
[
allow
(
dead_code
)
]
FunctionDeclaration
#
[
allow
(
dead_code
)
]
GeneratorDeclaration
#
[
allow
(
dead_code
)
]
AsyncFunctionDeclaration
#
[
allow
(
dead_code
)
]
AsyncGeneratorDeclaration
#
[
allow
(
dead_code
)
]
ClassDeclaration
#
[
allow
(
dead_code
)
]
LexicalDeclarationWithLet
#
[
allow
(
dead_code
)
]
LexicalDeclarationWithConst
#
[
allow
(
dead_code
)
]
ExportDeclarationWithAssignmentExpression
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
ScopeKind
{
Var
Let
Const
FunctionName
FormalParameter
#
[
allow
(
dead_code
)
]
CatchParameter
#
[
allow
(
dead_code
)
]
Export
#
[
allow
(
dead_code
)
]
ScriptBodyStatementList
#
[
allow
(
dead_code
)
]
FunctionStatementList
#
[
allow
(
dead_code
)
]
BlockStatementList
}
#
[
derive
(
Debug
)
]
struct
GlobalScopeBuilder
{
functions_to_initialize
:
Vec
<
AssociatedDataKey
>
declared_function_names
:
IndexSet
<
SourceAtomSetIndex
>
declared_var_names
:
IndexSet
<
SourceAtomSetIndex
>
let_names
:
Vec
<
SourceAtomSetIndex
>
const_names
:
Vec
<
SourceAtomSetIndex
>
scope_index
:
ScopeIndex
name_tracker
:
FreeNameTracker
}
impl
GlobalScopeBuilder
{
fn
new
(
scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
functions_to_initialize
:
Vec
:
:
new
(
)
declared_function_names
:
IndexSet
:
:
new
(
)
declared_var_names
:
IndexSet
:
:
new
(
)
let_names
:
Vec
:
:
new
(
)
const_names
:
Vec
:
:
new
(
)
scope_index
name_tracker
:
FreeNameTracker
:
:
new
(
)
}
}
fn
declare_var
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
declared_var_names
.
insert
(
name
)
;
}
fn
declare_let
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
let_names
.
push
(
name
)
;
}
fn
declare_const
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
const_names
.
push
(
name
)
;
}
fn
declare_function
<
T
>
(
&
mut
self
name
:
SourceAtomSetIndex
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
declared_function_names
.
insert
(
name
)
;
self
.
functions_to_initialize
.
push
(
AssociatedDataKey
:
:
new
(
fun
)
)
;
}
fn
remove_function_names_from_var_names
(
&
mut
self
)
{
for
n
in
&
self
.
declared_function_names
{
self
.
declared_var_names
.
remove
(
n
)
;
}
}
fn
into_scope_data
(
self
)
-
>
ScopeData
{
let
mut
data
=
GlobalScopeData
:
:
new
(
self
.
declared_var_names
.
len
(
)
+
self
.
declared_function_names
.
len
(
)
self
.
let_names
.
len
(
)
self
.
const_names
.
len
(
)
self
.
functions_to_initialize
)
;
for
n
in
&
self
.
declared_var_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
self
.
declared_function_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new_top_level_function
(
*
n
is_closed_over
)
)
;
}
for
n
in
&
self
.
let_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
self
.
const_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
ScopeData
:
:
Global
(
data
)
}
}
#
[
derive
(
Debug
)
]
struct
BlockScopeBuilder
{
let_names
:
Vec
<
SourceAtomSetIndex
>
fun_names
:
Vec
<
SourceAtomSetIndex
>
const_names
:
Vec
<
SourceAtomSetIndex
>
functions
:
Vec
<
AssociatedDataKey
>
scope_index
:
ScopeIndex
name_tracker
:
FreeNameTracker
}
impl
BlockScopeBuilder
{
fn
new
(
scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
let_names
:
Vec
:
:
new
(
)
fun_names
:
Vec
:
:
new
(
)
const_names
:
Vec
:
:
new
(
)
functions
:
Vec
:
:
new
(
)
scope_index
name_tracker
:
FreeNameTracker
:
:
new
(
)
}
}
fn
declare_let
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
let_names
.
push
(
name
)
;
}
fn
declare_const
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
const_names
.
push
(
name
)
;
}
fn
declare_function
<
T
>
(
&
mut
self
name
:
SourceAtomSetIndex
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
fun_names
.
push
(
name
)
;
self
.
functions
.
push
(
AssociatedDataKey
:
:
new
(
fun
)
)
;
}
fn
into_scope_data
(
self
enclosing
:
ScopeIndex
)
-
>
ScopeData
{
let
mut
data
=
LexicalScopeData
:
:
new_block
(
self
.
let_names
.
len
(
)
+
self
.
fun_names
.
len
(
)
self
.
const_names
.
len
(
)
enclosing
self
.
functions
)
;
for
n
in
&
self
.
let_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
self
.
fun_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
self
.
const_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
ScopeData
:
:
Lexical
(
data
)
}
}
#
[
derive
(
Debug
)
]
struct
FunctionExpressionScopeBuilder
{
function_expression_name
:
Option
<
SourceAtomSetIndex
>
scope_index
:
ScopeIndex
name_tracker
:
FreeNameTracker
}
impl
FunctionExpressionScopeBuilder
{
fn
new
(
scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
function_expression_name
:
None
scope_index
name_tracker
:
FreeNameTracker
:
:
new
(
)
}
}
fn
set_function_name
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
function_expression_name
=
Some
(
name
)
;
}
fn
into_scope_data
(
self
enclosing
:
ScopeIndex
)
-
>
ScopeData
{
match
&
self
.
function_expression_name
{
Some
(
name
)
=
>
{
let
mut
data
=
LexicalScopeData
:
:
new_named_lambda
(
enclosing
)
;
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
name
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
name
is_closed_over
)
)
;
ScopeData
:
:
Lexical
(
data
)
}
None
=
>
ScopeData
:
:
Alias
(
enclosing
)
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
ThisMode
{
Lexical
#
[
allow
(
dead_code
)
]
Strict
Global
}
struct
FunctionScopeDataSet
{
function
:
ScopeData
extra_body_var
:
ScopeData
lexical
:
ScopeData
}
#
[
derive
(
Debug
)
]
enum
FunctionParametersState
{
Init
Parameter
DestructuringParameter
RestParameter
DestructuringRestParameter
}
#
[
derive
(
Debug
)
]
struct
FunctionParametersScopeBuilder
{
state
:
FunctionParametersState
positional_parameter_names
:
Vec
<
Option
<
SourceAtomSetIndex
>
>
non_positional_parameter_names
:
Vec
<
SourceAtomSetIndex
>
this_mode
:
ThisMode
strict
:
bool
parameter_names
:
HashSet
<
SourceAtomSetIndex
>
parameter_has_arguments
:
bool
has_duplicates
:
bool
simple_parameter_list
:
bool
has_parameter_expressions
:
bool
scope_index
:
ScopeIndex
name_tracker
:
FreeNameTracker
}
impl
FunctionParametersScopeBuilder
{
fn
new
(
scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
state
:
FunctionParametersState
:
:
Init
positional_parameter_names
:
Vec
:
:
new
(
)
non_positional_parameter_names
:
Vec
:
:
new
(
)
this_mode
:
ThisMode
:
:
Global
strict
:
false
parameter_names
:
HashSet
:
:
new
(
)
parameter_has_arguments
:
false
has_duplicates
:
false
simple_parameter_list
:
true
has_parameter_expressions
:
false
scope_index
name_tracker
:
FreeNameTracker
:
:
new
(
)
}
}
fn
before_parameter
(
&
mut
self
)
{
match
self
.
state
{
FunctionParametersState
:
:
Init
=
>
{
self
.
state
=
FunctionParametersState
:
:
Parameter
;
}
FunctionParametersState
:
:
Parameter
=
>
{
self
.
state
=
FunctionParametersState
:
:
Parameter
;
}
FunctionParametersState
:
:
DestructuringParameter
=
>
{
self
.
state
=
FunctionParametersState
:
:
Parameter
;
}
FunctionParametersState
:
:
RestParameter
|
FunctionParametersState
:
:
DestructuringRestParameter
=
>
panic
!
(
"
Invalid
transition
"
)
}
}
fn
before_binding_pattern
(
&
mut
self
)
{
self
.
simple_parameter_list
=
false
;
match
self
.
state
{
FunctionParametersState
:
:
Parameter
=
>
{
self
.
positional_parameter_names
.
push
(
None
)
;
self
.
state
=
FunctionParametersState
:
:
DestructuringParameter
;
}
FunctionParametersState
:
:
DestructuringParameter
=
>
{
}
FunctionParametersState
:
:
RestParameter
=
>
{
self
.
positional_parameter_names
.
push
(
None
)
;
self
.
state
=
FunctionParametersState
:
:
DestructuringRestParameter
;
}
FunctionParametersState
:
:
DestructuringRestParameter
=
>
{
}
FunctionParametersState
:
:
Init
=
>
panic
!
(
"
Invalid
transition
"
)
}
}
fn
before_rest_parameter
(
&
mut
self
)
{
self
.
simple_parameter_list
=
false
;
match
self
.
state
{
FunctionParametersState
:
:
Init
|
FunctionParametersState
:
:
Parameter
|
FunctionParametersState
:
:
DestructuringParameter
=
>
{
self
.
state
=
FunctionParametersState
:
:
RestParameter
;
}
FunctionParametersState
:
:
RestParameter
|
FunctionParametersState
:
:
DestructuringRestParameter
=
>
panic
!
(
"
Invalid
transition
"
)
}
}
fn
after_initializer
(
&
mut
self
)
{
self
.
simple_parameter_list
=
false
;
self
.
has_parameter_expressions
=
true
;
}
fn
before_computed_property_name
(
&
mut
self
)
{
self
.
has_parameter_expressions
=
true
;
}
fn
declare_param
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
match
self
.
state
{
FunctionParametersState
:
:
Init
=
>
panic
!
(
"
Invalid
state
"
)
FunctionParametersState
:
:
Parameter
=
>
{
self
.
positional_parameter_names
.
push
(
Some
(
name
.
clone
(
)
)
)
;
}
FunctionParametersState
:
:
DestructuringParameter
=
>
{
self
.
non_positional_parameter_names
.
push
(
name
.
clone
(
)
)
;
}
FunctionParametersState
:
:
RestParameter
=
>
{
self
.
positional_parameter_names
.
push
(
Some
(
name
.
clone
(
)
)
)
;
}
FunctionParametersState
:
:
DestructuringRestParameter
=
>
{
self
.
non_positional_parameter_names
.
push
(
name
.
clone
(
)
)
;
}
}
if
self
.
parameter_names
.
contains
(
&
name
)
{
self
.
has_duplicates
=
true
;
}
self
.
parameter_names
.
insert
(
name
.
clone
(
)
)
;
if
name
=
=
CommonSourceAtomSetIndices
:
:
arguments
(
)
{
self
.
parameter_has_arguments
=
true
;
}
}
fn
into_scope_data_set
(
self
enclosing
:
ScopeIndex
body_scope_builder
:
FunctionBodyScopeBuilder
)
-
>
FunctionScopeDataSet
{
let
mut
arguments_object_needed
=
true
;
if
self
.
this_mode
=
=
ThisMode
:
:
Lexical
{
arguments_object_needed
=
false
;
}
else
if
self
.
parameter_has_arguments
{
arguments_object_needed
=
false
;
}
else
if
!
self
.
parameter_has_arguments
{
if
body_scope_builder
.
function_or_lexical_has_arguments
{
arguments_object_needed
=
false
;
}
}
if
self
.
strict
|
|
!
self
.
has_parameter_expressions
{
}
else
{
}
let
has_extra_body_var_scope
=
self
.
has_parameter_expressions
;
let
function_var_names_count
=
if
has_extra_body_var_scope
{
0
}
else
{
body_scope_builder
.
var_names
.
len
(
)
}
;
let
mut
function_scope_data
=
FunctionScopeData
:
:
new
(
self
.
has_parameter_expressions
self
.
positional_parameter_names
.
len
(
)
self
.
non_positional_parameter_names
.
len
(
)
function_var_names_count
enclosing
)
;
for
maybe_name
in
&
self
.
positional_parameter_names
{
match
maybe_name
{
Some
(
n
)
=
>
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
|
|
(
!
has_extra_body_var_scope
&
&
body_scope_builder
.
name_tracker
.
is_closed_over_def
(
n
)
)
;
function_scope_data
.
bindings
.
push
(
Some
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
)
}
None
=
>
function_scope_data
.
bindings
.
push
(
None
)
}
}
for
n
in
&
self
.
non_positional_parameter_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
|
|
(
!
has_extra_body_var_scope
&
&
body_scope_builder
.
name_tracker
.
is_closed_over_def
(
n
)
)
;
function_scope_data
.
bindings
.
push
(
Some
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
)
}
let
extra_body_var_scope_data
=
if
!
self
.
has_parameter_expressions
{
debug_assert
!
(
!
has_extra_body_var_scope
)
;
for
n
in
&
body_scope_builder
.
var_names
{
if
self
.
parameter_names
.
contains
(
n
)
|
|
(
arguments_object_needed
&
&
*
n
=
=
CommonSourceAtomSetIndices
:
:
arguments
(
)
)
{
continue
;
}
let
is_closed_over
=
body_scope_builder
.
name_tracker
.
is_closed_over_def
(
n
)
;
function_scope_data
.
bindings
.
push
(
Some
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
)
;
}
ScopeData
:
:
Alias
(
self
.
scope_index
)
}
else
{
debug_assert
!
(
has_extra_body_var_scope
)
;
let
mut
data
=
VarScopeData
:
:
new
(
body_scope_builder
.
var_names
.
len
(
)
self
.
scope_index
)
;
for
n
in
&
body_scope_builder
.
var_names
{
let
is_closed_over
=
body_scope_builder
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
;
}
ScopeData
:
:
Var
(
data
)
}
;
let
lexical_scope_data
=
if
body_scope_builder
.
let_names
.
len
(
)
>
0
|
|
body_scope_builder
.
const_names
.
len
(
)
>
0
{
let
mut
data
=
LexicalScopeData
:
:
new_function_lexical
(
body_scope_builder
.
let_names
.
len
(
)
body_scope_builder
.
const_names
.
len
(
)
body_scope_builder
.
var_scope_index
)
;
for
n
in
&
body_scope_builder
.
let_names
{
let
is_closed_over
=
body_scope_builder
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
body_scope_builder
.
const_names
{
let
is_closed_over
=
body_scope_builder
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
ScopeData
:
:
Lexical
(
data
)
}
else
{
ScopeData
:
:
Alias
(
body_scope_builder
.
var_scope_index
)
}
;
FunctionScopeDataSet
{
function
:
ScopeData
:
:
Function
(
function_scope_data
)
extra_body_var
:
extra_body_var_scope_data
lexical
:
lexical_scope_data
}
}
}
#
[
derive
(
Debug
)
]
struct
FunctionBodyScopeBuilder
{
var_names
:
IndexSet
<
SourceAtomSetIndex
>
let_names
:
Vec
<
SourceAtomSetIndex
>
const_names
:
Vec
<
SourceAtomSetIndex
>
functions_to_initialize
:
Vec
<
AssociatedDataKey
>
function_or_lexical_has_arguments
:
bool
var_scope_index
:
ScopeIndex
lexical_scope_index
:
ScopeIndex
name_tracker
:
FreeNameTracker
}
impl
FunctionBodyScopeBuilder
{
fn
new
(
var_scope_index
:
ScopeIndex
lexical_scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
var_names
:
IndexSet
:
:
new
(
)
let_names
:
Vec
:
:
new
(
)
const_names
:
Vec
:
:
new
(
)
functions_to_initialize
:
Vec
:
:
new
(
)
function_or_lexical_has_arguments
:
false
var_scope_index
lexical_scope_index
name_tracker
:
FreeNameTracker
:
:
new
(
)
}
}
fn
declare_var
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
var_names
.
insert
(
name
)
;
}
fn
check_lexical_or_function_name
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
if
name
=
=
CommonSourceAtomSetIndices
:
:
arguments
(
)
{
self
.
function_or_lexical_has_arguments
=
true
;
}
}
fn
declare_let
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
let_names
.
push
(
name
.
clone
(
)
)
;
self
.
check_lexical_or_function_name
(
name
)
;
}
fn
declare_const
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
let_names
.
push
(
name
.
clone
(
)
)
;
self
.
check_lexical_or_function_name
(
name
)
;
}
fn
declare_function
<
T
>
(
&
mut
self
name
:
SourceAtomSetIndex
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
check_lexical_or_function_name
(
name
)
;
self
.
functions_to_initialize
.
push
(
AssociatedDataKey
:
:
new
(
fun
)
)
;
}
}
#
[
derive
(
Debug
)
]
enum
ScopeBuilder
{
Global
(
GlobalScopeBuilder
)
Block
(
BlockScopeBuilder
)
FunctionExpression
(
FunctionExpressionScopeBuilder
)
FunctionParameters
(
FunctionParametersScopeBuilder
)
FunctionBody
(
FunctionBodyScopeBuilder
)
}
impl
ScopeBuilder
{
fn
get_scope_index
(
&
self
)
-
>
ScopeIndex
{
match
self
{
ScopeBuilder
:
:
Global
(
builder
)
=
>
builder
.
scope_index
ScopeBuilder
:
:
Block
(
builder
)
=
>
builder
.
scope_index
ScopeBuilder
:
:
FunctionExpression
(
builder
)
=
>
builder
.
scope_index
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
builder
.
scope_index
ScopeBuilder
:
:
FunctionBody
(
builder
)
=
>
builder
.
lexical_scope_index
}
}
fn
declare_var
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
name_tracker_mut
(
)
.
note_def
(
name
)
;
match
self
{
ScopeBuilder
:
:
Global
(
ref
mut
builder
)
=
>
builder
.
declare_var
(
name
)
ScopeBuilder
:
:
FunctionBody
(
ref
mut
builder
)
=
>
builder
.
declare_var
(
name
)
_
=
>
panic
!
(
"
unexpected
var
scope
builder
"
)
}
}
fn
declare_let
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
name_tracker_mut
(
)
.
note_def
(
name
)
;
match
self
{
ScopeBuilder
:
:
Global
(
ref
mut
builder
)
=
>
builder
.
declare_let
(
name
)
ScopeBuilder
:
:
Block
(
ref
mut
builder
)
=
>
builder
.
declare_let
(
name
)
ScopeBuilder
:
:
FunctionBody
(
ref
mut
builder
)
=
>
builder
.
declare_let
(
name
)
_
=
>
panic
!
(
"
unexpected
lexical
scope
builder
"
)
}
}
fn
declare_const
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
name_tracker_mut
(
)
.
note_def
(
name
)
;
match
self
{
ScopeBuilder
:
:
Global
(
ref
mut
builder
)
=
>
builder
.
declare_const
(
name
)
ScopeBuilder
:
:
Block
(
ref
mut
builder
)
=
>
builder
.
declare_const
(
name
)
ScopeBuilder
:
:
FunctionBody
(
ref
mut
builder
)
=
>
builder
.
declare_const
(
name
)
_
=
>
panic
!
(
"
unexpected
lexical
scope
builder
"
)
}
}
fn
set_function_name
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
name_tracker_mut
(
)
.
note_def
(
name
)
;
match
self
{
ScopeBuilder
:
:
FunctionExpression
(
ref
mut
builder
)
=
>
builder
.
set_function_name
(
name
)
_
=
>
{
}
}
}
fn
declare_param
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
name_tracker_mut
(
)
.
note_def
(
name
)
;
match
self
{
ScopeBuilder
:
:
FunctionParameters
(
ref
mut
builder
)
=
>
builder
.
declare_param
(
name
)
_
=
>
panic
!
(
"
unexpected
function
scope
builder
"
)
}
}
fn
name_tracker
(
&
self
)
-
>
&
FreeNameTracker
{
match
self
{
ScopeBuilder
:
:
Global
(
builder
)
=
>
&
builder
.
name_tracker
ScopeBuilder
:
:
Block
(
builder
)
=
>
&
builder
.
name_tracker
ScopeBuilder
:
:
FunctionExpression
(
builder
)
=
>
&
builder
.
name_tracker
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
&
builder
.
name_tracker
ScopeBuilder
:
:
FunctionBody
(
builder
)
=
>
&
builder
.
name_tracker
}
}
fn
name_tracker_mut
(
&
mut
self
)
-
>
&
mut
FreeNameTracker
{
match
self
{
ScopeBuilder
:
:
Global
(
builder
)
=
>
&
mut
builder
.
name_tracker
ScopeBuilder
:
:
Block
(
builder
)
=
>
&
mut
builder
.
name_tracker
ScopeBuilder
:
:
FunctionExpression
(
builder
)
=
>
&
mut
builder
.
name_tracker
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
&
mut
builder
.
name_tracker
ScopeBuilder
:
:
FunctionBody
(
builder
)
=
>
&
mut
builder
.
name_tracker
}
}
}
#
[
derive
(
Debug
)
]
struct
ScopeKindStack
{
stack
:
Vec
<
ScopeKind
>
}
impl
ScopeKindStack
{
fn
new
(
)
-
>
Self
{
Self
{
stack
:
Vec
:
:
new
(
)
}
}
fn
innermost
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
ScopeKind
{
self
.
stack
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
}
fn
push
(
&
mut
self
kind
:
ScopeKind
)
{
self
.
stack
.
push
(
kind
)
}
fn
pop
(
&
mut
self
kind
:
ScopeKind
)
{
match
self
.
stack
.
pop
(
)
{
Some
(
k
)
if
k
=
=
kind
=
>
{
}
_
=
>
panic
!
(
"
unmatching
scope
kind
"
)
}
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
stack
.
len
(
)
=
=
0
}
}
#
[
derive
(
Debug
)
]
struct
ScopeBuilderStack
{
stack
:
Vec
<
ScopeBuilder
>
}
impl
ScopeBuilderStack
{
fn
new
(
)
-
>
Self
{
Self
{
stack
:
Vec
:
:
new
(
)
}
}
fn
innermost_var
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
ScopeBuilder
{
for
builder
in
self
.
stack
.
iter_mut
(
)
.
rev
(
)
{
match
builder
{
ScopeBuilder
:
:
Global
(
_
)
=
>
return
builder
ScopeBuilder
:
:
FunctionBody
(
_
)
=
>
return
builder
_
=
>
{
}
}
}
panic
!
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
;
}
fn
innermost_lexical
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
ScopeBuilder
{
self
.
innermost
(
)
}
fn
innermost
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
ScopeBuilder
{
self
.
stack
.
last_mut
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
}
fn
current_scope_index
(
&
self
)
-
>
ScopeIndex
{
self
.
stack
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
.
get_scope_index
(
)
}
fn
push_global
(
&
mut
self
builder
:
GlobalScopeBuilder
)
{
self
.
stack
.
push
(
ScopeBuilder
:
:
Global
(
builder
)
)
}
fn
pop_global
(
&
mut
self
)
-
>
GlobalScopeBuilder
{
match
self
.
pop
(
)
{
ScopeBuilder
:
:
Global
(
builder
)
=
>
builder
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
}
fn
push_block
(
&
mut
self
builder
:
BlockScopeBuilder
)
{
self
.
stack
.
push
(
ScopeBuilder
:
:
Block
(
builder
)
)
}
fn
pop_block
(
&
mut
self
)
-
>
BlockScopeBuilder
{
match
self
.
pop
(
)
{
ScopeBuilder
:
:
Block
(
builder
)
=
>
builder
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
}
fn
push_function_expression
(
&
mut
self
builder
:
FunctionExpressionScopeBuilder
)
{
self
.
stack
.
push
(
ScopeBuilder
:
:
FunctionExpression
(
builder
)
)
}
fn
pop_function_expression
(
&
mut
self
)
-
>
FunctionExpressionScopeBuilder
{
match
self
.
pop
(
)
{
ScopeBuilder
:
:
FunctionExpression
(
builder
)
=
>
builder
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
}
fn
push_function_parameters
(
&
mut
self
builder
:
FunctionParametersScopeBuilder
)
{
self
.
stack
.
push
(
ScopeBuilder
:
:
FunctionParameters
(
builder
)
)
}
fn
pop_function_parameters
(
&
mut
self
)
-
>
FunctionParametersScopeBuilder
{
match
self
.
pop
(
)
{
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
builder
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
}
fn
get_function_parameters
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
FunctionParametersScopeBuilder
{
match
self
.
innermost
(
)
{
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
builder
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
}
fn
push_function_body
(
&
mut
self
builder
:
FunctionBodyScopeBuilder
)
{
self
.
stack
.
push
(
ScopeBuilder
:
:
FunctionBody
(
builder
)
)
}
fn
pop_function_body
(
&
mut
self
)
-
>
FunctionBodyScopeBuilder
{
match
self
.
pop
(
)
{
ScopeBuilder
:
:
FunctionBody
(
builder
)
=
>
builder
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
}
fn
pop
(
&
mut
self
)
-
>
ScopeBuilder
{
let
inner
=
self
.
stack
.
pop
(
)
.
expect
(
"
unmatching
scope
builder
"
)
;
match
self
.
stack
.
last_mut
(
)
{
Some
(
outer
)
=
>
{
let
inner_tracker
=
inner
.
name_tracker
(
)
;
let
outer_tracker
=
outer
.
name_tracker_mut
(
)
;
match
inner
{
ScopeBuilder
:
:
Global
(
_
)
=
>
{
panic
!
(
"
Global
shouldn
'
t
be
enclosed
by
other
scope
"
)
;
}
ScopeBuilder
:
:
Block
(
_
)
=
>
{
outer_tracker
.
propagate_from_inner_non_script
(
inner_tracker
)
;
}
ScopeBuilder
:
:
FunctionExpression
(
_
)
=
>
{
outer_tracker
.
propagate_from_inner_non_script
(
inner_tracker
)
;
}
ScopeBuilder
:
:
FunctionParameters
(
_
)
=
>
{
outer_tracker
.
propagate_from_inner_script
(
inner_tracker
)
;
}
ScopeBuilder
:
:
FunctionBody
(
_
)
=
>
{
outer_tracker
.
propagate_from_inner_non_script
(
inner_tracker
)
;
}
}
}
None
=
>
{
}
}
inner
}
}
#
[
derive
(
Debug
)
]
pub
struct
ScopeDataMapBuilder
{
scope_kind_stack
:
ScopeKindStack
builder_stack
:
ScopeBuilderStack
scopes
:
ScopeDataList
global
:
Option
<
ScopeIndex
>
non_global
:
AssociatedData
<
ScopeIndex
>
}
impl
ScopeDataMapBuilder
{
pub
fn
new
(
)
-
>
Self
{
Self
{
scope_kind_stack
:
ScopeKindStack
:
:
new
(
)
builder_stack
:
ScopeBuilderStack
:
:
new
(
)
scopes
:
ScopeDataList
:
:
new
(
)
global
:
None
non_global
:
AssociatedData
:
:
new
(
)
}
}
pub
fn
before_script
(
&
mut
self
)
{
let
index
=
self
.
scopes
.
allocate
(
)
;
let
builder
=
GlobalScopeBuilder
:
:
new
(
index
)
;
self
.
global
=
Some
(
index
)
;
self
.
builder_stack
.
push_global
(
builder
)
;
}
pub
fn
after_script
(
&
mut
self
)
{
let
mut
builder
=
self
.
builder_stack
.
pop_global
(
)
;
builder
.
remove_function_names_from_var_names
(
)
;
self
.
scopes
.
populate
(
builder
.
scope_index
builder
.
into_scope_data
(
)
)
;
}
pub
fn
before_block_statement
<
T
>
(
&
mut
self
block
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
let
index
=
self
.
scopes
.
allocate
(
)
;
let
builder
=
BlockScopeBuilder
:
:
new
(
index
)
;
self
.
non_global
.
insert
(
block
index
)
;
self
.
builder_stack
.
push_block
(
builder
)
;
}
pub
fn
after_block_statement
(
&
mut
self
)
{
let
builder
=
self
.
builder_stack
.
pop_block
(
)
;
let
enclosing
=
self
.
builder_stack
.
current_scope_index
(
)
;
self
.
scopes
.
populate
(
builder
.
scope_index
builder
.
into_scope_data
(
enclosing
)
)
;
}
pub
fn
before_var_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Var
)
;
}
pub
fn
after_var_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Var
)
;
}
pub
fn
before_let_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Let
)
;
}
pub
fn
after_let_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Let
)
;
}
pub
fn
before_const_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Const
)
;
}
pub
fn
after_const_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Const
)
;
}
pub
fn
on_binding_identifier
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
if
self
.
scope_kind_stack
.
is_empty
(
)
{
return
;
}
match
self
.
scope_kind_stack
.
innermost
(
)
{
ScopeKind
:
:
Var
=
>
self
.
builder_stack
.
innermost_var
(
)
.
declare_var
(
name
)
ScopeKind
:
:
Let
=
>
self
.
builder_stack
.
innermost_lexical
(
)
.
declare_let
(
name
)
ScopeKind
:
:
Const
=
>
self
.
builder_stack
.
innermost_lexical
(
)
.
declare_const
(
name
)
ScopeKind
:
:
FunctionName
=
>
self
.
builder_stack
.
innermost
(
)
.
set_function_name
(
name
)
ScopeKind
:
:
FormalParameter
=
>
self
.
builder_stack
.
innermost
(
)
.
declare_param
(
name
)
_
=
>
panic
!
(
"
Not
implemeneted
"
)
}
}
pub
fn
on_non_binding_identifier
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
builder_stack
.
innermost
(
)
.
name_tracker_mut
(
)
.
note_use
(
name
)
;
}
pub
fn
before_function_declaration
<
T
>
(
&
mut
self
name
:
SourceAtomSetIndex
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
match
self
.
builder_stack
.
innermost_lexical
(
)
{
ScopeBuilder
:
:
Global
(
ref
mut
builder
)
=
>
builder
.
declare_function
(
name
fun
)
ScopeBuilder
:
:
Block
(
ref
mut
builder
)
=
>
builder
.
declare_function
(
name
fun
)
ScopeBuilder
:
:
FunctionBody
(
ref
mut
builder
)
=
>
builder
.
declare_function
(
name
fun
)
_
=
>
panic
!
(
"
unexpected
lexical
for
FunctionDeclaration
"
)
}
}
pub
fn
before_function_expression
<
T
>
(
&
mut
self
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
let
index
=
self
.
scopes
.
allocate
(
)
;
let
builder
=
FunctionExpressionScopeBuilder
:
:
new
(
index
)
;
self
.
non_global
.
insert
(
fun
index
)
;
self
.
builder_stack
.
push_function_expression
(
builder
)
;
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
FunctionName
)
;
}
pub
fn
after_function_expression
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
FunctionName
)
;
let
builder
=
self
.
builder_stack
.
pop_function_expression
(
)
;
let
enclosing
=
self
.
builder_stack
.
current_scope_index
(
)
;
self
.
scopes
.
populate
(
builder
.
scope_index
builder
.
into_scope_data
(
enclosing
)
)
;
}
pub
fn
before_function_parameters
<
T
>
(
&
mut
self
params
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
let
index
=
self
.
scopes
.
allocate
(
)
;
let
builder
=
FunctionParametersScopeBuilder
:
:
new
(
index
)
;
self
.
non_global
.
insert
(
params
index
)
;
self
.
builder_stack
.
push_function_parameters
(
builder
)
;
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
FormalParameter
)
;
}
pub
fn
after_function_parameters
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
FormalParameter
)
;
}
pub
fn
before_parameter
(
&
mut
self
)
{
let
builder
=
self
.
builder_stack
.
get_function_parameters
(
)
;
builder
.
before_parameter
(
)
;
}
pub
fn
before_binding_pattern
(
&
mut
self
)
{
match
self
.
builder_stack
.
innermost
(
)
{
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
{
builder
.
before_binding_pattern
(
)
;
}
_
=
>
{
}
}
}
pub
fn
after_initializer
(
&
mut
self
)
{
match
self
.
builder_stack
.
innermost
(
)
{
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
{
builder
.
after_initializer
(
)
;
}
_
=
>
{
}
}
}
pub
fn
before_computed_property_name
(
&
mut
self
)
{
match
self
.
builder_stack
.
innermost
(
)
{
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
{
builder
.
before_computed_property_name
(
)
;
}
_
=
>
{
}
}
}
pub
fn
before_rest_parameter
(
&
mut
self
)
{
let
builder
=
self
.
builder_stack
.
get_function_parameters
(
)
;
builder
.
before_rest_parameter
(
)
;
}
pub
fn
before_function_body
<
T
>
(
&
mut
self
body
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
let
var_index
=
self
.
scopes
.
allocate
(
)
;
let
lexical_index
=
self
.
scopes
.
allocate
(
)
;
debug_assert
!
(
lexical_index
=
=
var_index
.
next
(
)
)
;
let
builder
=
FunctionBodyScopeBuilder
:
:
new
(
var_index
lexical_index
)
;
self
.
non_global
.
insert
(
body
var_index
)
;
self
.
builder_stack
.
push_function_body
(
builder
)
;
}
pub
fn
after_function_body
(
&
mut
self
)
{
let
body_scope_builder
=
self
.
builder_stack
.
pop_function_body
(
)
;
let
parameter_scope_builder
=
self
.
builder_stack
.
pop_function_parameters
(
)
;
let
enclosing
=
self
.
builder_stack
.
current_scope_index
(
)
;
let
function_scope_index
=
parameter_scope_builder
.
scope_index
;
let
var_scope_index
=
body_scope_builder
.
var_scope_index
;
let
lexical_scope_index
=
body_scope_builder
.
lexical_scope_index
;
let
scope_data_set
=
parameter_scope_builder
.
into_scope_data_set
(
enclosing
body_scope_builder
)
;
self
.
scopes
.
populate
(
function_scope_index
scope_data_set
.
function
)
;
self
.
scopes
.
populate
(
var_scope_index
scope_data_set
.
extra_body_var
)
;
self
.
scopes
.
populate
(
lexical_scope_index
scope_data_set
.
lexical
)
;
}
}
impl
From
<
ScopeDataMapBuilder
>
for
ScopeDataMap
{
fn
from
(
builder
:
ScopeDataMapBuilder
)
-
>
ScopeDataMap
{
ScopeDataMap
:
:
new
(
builder
.
scopes
builder
.
global
.
expect
(
"
There
should
be
global
scope
data
"
)
builder
.
non_global
)
}
}
