use
crate
:
:
data
:
:
FunctionDeclarationPropertyMap
;
use
crate
:
:
free_name_tracker
:
:
FreeNameTracker
;
use
ast
:
:
associated_data
:
:
AssociatedData
;
use
ast
:
:
source_atom_set
:
:
{
CommonSourceAtomSetIndices
SourceAtomSetIndex
}
;
use
ast
:
:
source_location_accessor
:
:
SourceLocationAccessor
;
use
ast
:
:
type_id
:
:
NodeTypeIdAccessor
;
use
indexmap
:
:
set
:
:
IndexSet
;
use
std
:
:
collections
:
:
hash_map
:
:
Keys
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
stencil
:
:
function
:
:
{
FunctionFlags
FunctionSyntaxKind
}
;
use
stencil
:
:
scope
:
:
{
BindingName
FunctionScopeData
GlobalScopeData
LexicalScopeData
ScopeData
ScopeDataList
ScopeDataMap
ScopeIndex
VarScopeData
}
;
use
stencil
:
:
script
:
:
{
ScriptStencil
ScriptStencilIndex
ScriptStencilList
SourceExtent
}
;
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
VarScopedDeclarationsItemKind
{
#
[
allow
(
dead_code
)
]
VariableDeclaration
#
[
allow
(
dead_code
)
]
ForBinding
#
[
allow
(
dead_code
)
]
FunctionDeclaration
#
[
allow
(
dead_code
)
]
GeneratorDeclaration
#
[
allow
(
dead_code
)
]
AsyncFunctionDeclaration
#
[
allow
(
dead_code
)
]
AsyncGeneratorDeclaration
#
[
allow
(
dead_code
)
]
BindingIdentifier
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
LexicallyScopedDeclarations
{
#
[
allow
(
dead_code
)
]
FunctionDeclaration
#
[
allow
(
dead_code
)
]
GeneratorDeclaration
#
[
allow
(
dead_code
)
]
AsyncFunctionDeclaration
#
[
allow
(
dead_code
)
]
AsyncGeneratorDeclaration
#
[
allow
(
dead_code
)
]
ClassDeclaration
#
[
allow
(
dead_code
)
]
LexicalDeclarationWithLet
#
[
allow
(
dead_code
)
]
LexicalDeclarationWithConst
#
[
allow
(
dead_code
)
]
ExportDeclarationWithAssignmentExpression
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
ScopeKind
{
Var
Let
Const
FunctionName
FunctionParametersAndBody
FormalParameter
#
[
allow
(
dead_code
)
]
CatchParameter
#
[
allow
(
dead_code
)
]
Export
#
[
allow
(
dead_code
)
]
ScriptBodyStatementList
#
[
allow
(
dead_code
)
]
FunctionStatementList
#
[
allow
(
dead_code
)
]
BlockStatementList
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
)
]
pub
struct
BindingIndex
{
index
:
usize
}
impl
BindingIndex
{
fn
new
(
index
:
usize
)
-
>
Self
{
Self
{
index
}
}
pub
fn
next
(
&
self
)
-
>
Self
{
Self
{
index
:
self
.
index
+
1
}
}
}
impl
From
<
BindingIndex
>
for
usize
{
fn
from
(
index
:
BindingIndex
)
-
>
usize
{
index
.
index
}
}
#
[
derive
(
Debug
)
]
struct
PossiblyAnnexBFunction
{
name
:
SourceAtomSetIndex
owner_scope_index
:
ScopeIndex
binding_index
:
BindingIndex
script_index
:
ScriptStencilIndex
}
#
[
derive
(
Debug
)
]
struct
PossiblyAnnexBFunctionList
{
functions
:
HashMap
<
SourceAtomSetIndex
Vec
<
PossiblyAnnexBFunction
>
>
}
impl
PossiblyAnnexBFunctionList
{
fn
new
(
)
-
>
Self
{
Self
{
functions
:
HashMap
:
:
new
(
)
}
}
fn
push
(
&
mut
self
name
:
SourceAtomSetIndex
owner_scope_index
:
ScopeIndex
binding_index
:
BindingIndex
script_index
:
ScriptStencilIndex
)
{
if
let
Some
(
functions
)
=
self
.
functions
.
get_mut
(
&
name
)
{
functions
.
push
(
PossiblyAnnexBFunction
{
name
owner_scope_index
binding_index
script_index
}
)
;
return
;
}
let
mut
functions
=
Vec
:
:
with_capacity
(
1
)
;
functions
.
push
(
PossiblyAnnexBFunction
{
name
owner_scope_index
binding_index
script_index
}
)
;
self
.
functions
.
insert
(
name
functions
)
;
}
fn
remove_if_exists
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
functions
.
remove
(
&
name
)
;
}
fn
mark_annex_b
(
&
self
function_declaration_properties
:
&
mut
FunctionDeclarationPropertyMap
)
{
for
functions
in
&
mut
self
.
functions
.
values
(
)
{
for
fun
in
functions
{
function_declaration_properties
.
mark_annex_b
(
fun
.
script_index
)
;
}
}
}
fn
names
(
&
self
)
-
>
Keys
<
SourceAtomSetIndex
Vec
<
PossiblyAnnexBFunction
>
>
{
self
.
functions
.
keys
(
)
}
fn
clear
(
&
mut
self
)
{
self
.
functions
.
clear
(
)
;
}
}
#
[
derive
(
Debug
)
]
struct
BaseScopeBuilder
{
name_tracker
:
FreeNameTracker
bindings_accessed_dynamically
:
bool
}
impl
BaseScopeBuilder
{
fn
new
(
)
-
>
Self
{
Self
{
name_tracker
:
FreeNameTracker
:
:
new
(
)
bindings_accessed_dynamically
:
false
}
}
}
#
[
derive
(
Debug
)
]
struct
GlobalScopeBuilder
{
base
:
BaseScopeBuilder
functions_to_initialize
:
Vec
<
ScriptStencilIndex
>
declared_function_names
:
IndexSet
<
SourceAtomSetIndex
>
declared_var_names
:
IndexSet
<
SourceAtomSetIndex
>
let_names
:
Vec
<
SourceAtomSetIndex
>
const_names
:
Vec
<
SourceAtomSetIndex
>
scope_index
:
ScopeIndex
}
impl
GlobalScopeBuilder
{
fn
new
(
scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
base
:
BaseScopeBuilder
:
:
new
(
)
functions_to_initialize
:
Vec
:
:
new
(
)
declared_function_names
:
IndexSet
:
:
new
(
)
declared_var_names
:
IndexSet
:
:
new
(
)
let_names
:
Vec
:
:
new
(
)
const_names
:
Vec
:
:
new
(
)
scope_index
}
}
fn
declare_var
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
declared_var_names
.
insert
(
name
)
;
}
fn
declare_let
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
let_names
.
push
(
name
)
;
}
fn
declare_const
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
const_names
.
push
(
name
)
;
}
fn
declare_function
(
&
mut
self
name
:
SourceAtomSetIndex
fun_index
:
ScriptStencilIndex
)
{
self
.
declared_function_names
.
insert
(
name
)
;
self
.
functions_to_initialize
.
push
(
fun_index
)
;
}
fn
remove_function_names_from_var_names
(
&
mut
self
)
{
for
n
in
&
self
.
declared_function_names
{
self
.
declared_var_names
.
remove
(
n
)
;
}
}
fn
perform_annex_b
(
&
mut
self
function_declaration_properties
:
&
mut
FunctionDeclarationPropertyMap
possibly_annex_b_functions
:
&
mut
PossiblyAnnexBFunctionList
)
{
let
strict
=
false
;
if
strict
{
return
;
}
for
n
in
&
self
.
let_names
{
possibly_annex_b_functions
.
remove_if_exists
(
*
n
)
;
}
for
n
in
&
self
.
const_names
{
possibly_annex_b_functions
.
remove_if_exists
(
*
n
)
;
}
for
n
in
possibly_annex_b_functions
.
names
(
)
{
self
.
declared_var_names
.
insert
(
*
n
)
;
}
possibly_annex_b_functions
.
mark_annex_b
(
function_declaration_properties
)
;
}
fn
into_scope_data
(
mut
self
function_declaration_properties
:
&
mut
FunctionDeclarationPropertyMap
possibly_annex_b_functions
:
&
mut
PossiblyAnnexBFunctionList
)
-
>
ScopeData
{
self
.
perform_annex_b
(
function_declaration_properties
possibly_annex_b_functions
)
;
self
.
remove_function_names_from_var_names
(
)
;
let
mut
data
=
GlobalScopeData
:
:
new
(
self
.
declared_var_names
.
len
(
)
+
self
.
declared_function_names
.
len
(
)
self
.
let_names
.
len
(
)
self
.
const_names
.
len
(
)
self
.
functions_to_initialize
)
;
for
n
in
&
self
.
declared_var_names
{
let
is_closed_over
=
self
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
base
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
self
.
declared_function_names
{
let
is_closed_over
=
self
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
base
.
bindings
.
push
(
BindingName
:
:
new_top_level_function
(
*
n
is_closed_over
)
)
;
}
for
n
in
&
self
.
let_names
{
let
is_closed_over
=
self
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
base
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
self
.
const_names
{
let
is_closed_over
=
self
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
base
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
ScopeData
:
:
Global
(
data
)
}
}
#
[
derive
(
Debug
)
]
struct
FunctionNameAndStencilIndex
{
name
:
SourceAtomSetIndex
stencil
:
ScriptStencilIndex
}
#
[
derive
(
Debug
)
]
struct
BlockScopeBuilder
{
base
:
BaseScopeBuilder
let_names
:
Vec
<
SourceAtomSetIndex
>
const_names
:
Vec
<
SourceAtomSetIndex
>
functions
:
Vec
<
FunctionNameAndStencilIndex
>
scope_index
:
ScopeIndex
}
impl
BlockScopeBuilder
{
fn
new
(
scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
base
:
BaseScopeBuilder
:
:
new
(
)
let_names
:
Vec
:
:
new
(
)
const_names
:
Vec
:
:
new
(
)
functions
:
Vec
:
:
new
(
)
scope_index
}
}
fn
declare_let
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
let_names
.
push
(
name
)
;
}
fn
declare_const
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
const_names
.
push
(
name
)
;
}
fn
declare_function
(
&
mut
self
name
:
SourceAtomSetIndex
fun_index
:
ScriptStencilIndex
)
{
self
.
functions
.
push
(
FunctionNameAndStencilIndex
{
name
stencil
:
fun_index
}
)
;
}
fn
into_scope_data
(
self
enclosing
:
ScopeIndex
possibly_annex_b_functions
:
&
mut
PossiblyAnnexBFunctionList
)
-
>
ScopeData
{
let
mut
data
=
LexicalScopeData
:
:
new_block
(
self
.
let_names
.
len
(
)
+
self
.
functions
.
len
(
)
self
.
const_names
.
len
(
)
enclosing
self
.
functions
.
iter
(
)
.
map
(
|
n
|
n
.
stencil
)
.
collect
(
)
)
;
for
n
in
&
self
.
let_names
{
let
is_closed_over
=
self
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
base
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
;
}
for
n
in
&
self
.
functions
{
let
is_closed_over
=
self
.
base
.
name_tracker
.
is_closed_over_def
(
&
n
.
name
)
;
let
binding_index
=
BindingIndex
:
:
new
(
data
.
base
.
bindings
.
len
(
)
)
;
data
.
base
.
bindings
.
push
(
BindingName
:
:
new
(
n
.
name
is_closed_over
)
)
;
possibly_annex_b_functions
.
push
(
n
.
name
self
.
scope_index
binding_index
n
.
stencil
)
;
}
for
n
in
&
self
.
const_names
{
let
is_closed_over
=
self
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
base
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
;
}
ScopeData
:
:
Lexical
(
data
)
}
}
#
[
derive
(
Debug
)
]
struct
FunctionExpressionScopeBuilder
{
base
:
BaseScopeBuilder
function_expression_name
:
Option
<
SourceAtomSetIndex
>
scope_index
:
ScopeIndex
}
impl
FunctionExpressionScopeBuilder
{
fn
new
(
scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
base
:
BaseScopeBuilder
:
:
new
(
)
function_expression_name
:
None
scope_index
}
}
fn
set_function_name
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
function_expression_name
=
Some
(
name
)
;
}
fn
into_scope_data
(
self
enclosing
:
ScopeIndex
)
-
>
ScopeData
{
match
&
self
.
function_expression_name
{
Some
(
name
)
=
>
{
let
mut
data
=
LexicalScopeData
:
:
new_named_lambda
(
enclosing
)
;
let
is_closed_over
=
self
.
base
.
name_tracker
.
is_closed_over_def
(
name
)
;
data
.
base
.
bindings
.
push
(
BindingName
:
:
new
(
*
name
is_closed_over
)
)
;
ScopeData
:
:
Lexical
(
data
)
}
None
=
>
ScopeData
:
:
Alias
(
enclosing
)
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
ThisMode
{
Lexical
#
[
allow
(
dead_code
)
]
Strict
Global
}
struct
FunctionScopeDataSet
{
function
:
ScopeData
extra_body_var
:
ScopeData
lexical
:
ScopeData
}
#
[
derive
(
Debug
)
]
enum
FunctionParametersState
{
Init
Parameter
DestructuringParameter
RestParameter
DestructuringRestParameter
}
#
[
derive
(
Debug
)
]
struct
FunctionParametersScopeBuilder
{
base
:
BaseScopeBuilder
state
:
FunctionParametersState
positional_parameter_names
:
Vec
<
Option
<
SourceAtomSetIndex
>
>
non_positional_parameter_names
:
Vec
<
SourceAtomSetIndex
>
this_mode
:
ThisMode
strict
:
bool
parameter_names
:
HashSet
<
SourceAtomSetIndex
>
parameter_has_arguments
:
bool
has_duplicates
:
bool
simple_parameter_list
:
bool
has_parameter_expressions
:
bool
scope_index
:
ScopeIndex
script_index
:
ScriptStencilIndex
has_direct_eval
:
bool
is_arrow
:
bool
}
impl
FunctionParametersScopeBuilder
{
fn
new
(
scope_index
:
ScopeIndex
is_arrow
:
bool
script_index
:
ScriptStencilIndex
)
-
>
Self
{
let
mut
base
=
BaseScopeBuilder
:
:
new
(
)
;
if
!
is_arrow
{
base
.
name_tracker
.
note_def
(
CommonSourceAtomSetIndices
:
:
this
(
)
)
;
base
.
name_tracker
.
note_def
(
CommonSourceAtomSetIndices
:
:
arguments
(
)
)
;
}
Self
{
base
state
:
FunctionParametersState
:
:
Init
positional_parameter_names
:
Vec
:
:
new
(
)
non_positional_parameter_names
:
Vec
:
:
new
(
)
this_mode
:
ThisMode
:
:
Global
strict
:
false
parameter_names
:
HashSet
:
:
new
(
)
parameter_has_arguments
:
false
has_duplicates
:
false
simple_parameter_list
:
true
has_parameter_expressions
:
false
scope_index
script_index
has_direct_eval
:
false
is_arrow
}
}
fn
before_parameter
(
&
mut
self
)
{
match
self
.
state
{
FunctionParametersState
:
:
Init
=
>
{
self
.
state
=
FunctionParametersState
:
:
Parameter
;
}
FunctionParametersState
:
:
Parameter
=
>
{
self
.
state
=
FunctionParametersState
:
:
Parameter
;
}
FunctionParametersState
:
:
DestructuringParameter
=
>
{
self
.
state
=
FunctionParametersState
:
:
Parameter
;
}
FunctionParametersState
:
:
RestParameter
|
FunctionParametersState
:
:
DestructuringRestParameter
=
>
panic
!
(
"
Invalid
transition
"
)
}
}
fn
before_binding_pattern
(
&
mut
self
)
{
self
.
simple_parameter_list
=
false
;
match
self
.
state
{
FunctionParametersState
:
:
Parameter
=
>
{
self
.
positional_parameter_names
.
push
(
None
)
;
self
.
state
=
FunctionParametersState
:
:
DestructuringParameter
;
}
FunctionParametersState
:
:
DestructuringParameter
=
>
{
}
FunctionParametersState
:
:
RestParameter
=
>
{
self
.
positional_parameter_names
.
push
(
None
)
;
self
.
state
=
FunctionParametersState
:
:
DestructuringRestParameter
;
}
FunctionParametersState
:
:
DestructuringRestParameter
=
>
{
}
FunctionParametersState
:
:
Init
=
>
panic
!
(
"
Invalid
transition
"
)
}
}
fn
before_rest_parameter
(
&
mut
self
)
{
self
.
simple_parameter_list
=
false
;
match
self
.
state
{
FunctionParametersState
:
:
Init
|
FunctionParametersState
:
:
Parameter
|
FunctionParametersState
:
:
DestructuringParameter
=
>
{
self
.
state
=
FunctionParametersState
:
:
RestParameter
;
}
FunctionParametersState
:
:
RestParameter
|
FunctionParametersState
:
:
DestructuringRestParameter
=
>
panic
!
(
"
Invalid
transition
"
)
}
}
fn
after_initializer
(
&
mut
self
)
{
self
.
simple_parameter_list
=
false
;
self
.
has_parameter_expressions
=
true
;
}
fn
before_computed_property_name
(
&
mut
self
)
{
self
.
has_parameter_expressions
=
true
;
}
fn
declare_param
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
match
self
.
state
{
FunctionParametersState
:
:
Init
=
>
panic
!
(
"
Invalid
state
"
)
FunctionParametersState
:
:
Parameter
=
>
{
self
.
positional_parameter_names
.
push
(
Some
(
name
.
clone
(
)
)
)
;
}
FunctionParametersState
:
:
DestructuringParameter
=
>
{
self
.
non_positional_parameter_names
.
push
(
name
.
clone
(
)
)
;
}
FunctionParametersState
:
:
RestParameter
=
>
{
self
.
positional_parameter_names
.
push
(
Some
(
name
.
clone
(
)
)
)
;
}
FunctionParametersState
:
:
DestructuringRestParameter
=
>
{
self
.
non_positional_parameter_names
.
push
(
name
.
clone
(
)
)
;
}
}
if
self
.
parameter_names
.
contains
(
&
name
)
{
self
.
has_duplicates
=
true
;
}
self
.
parameter_names
.
insert
(
name
.
clone
(
)
)
;
if
name
=
=
CommonSourceAtomSetIndices
:
:
arguments
(
)
{
self
.
parameter_has_arguments
=
true
;
}
}
fn
perform_annex_b
(
&
mut
self
function_declaration_properties
:
&
mut
FunctionDeclarationPropertyMap
possibly_annex_b_functions
:
&
mut
PossiblyAnnexBFunctionList
body_scope_builder
:
&
mut
FunctionBodyScopeBuilder
)
{
let
strict
=
false
;
if
strict
{
return
;
}
for
n
in
&
body_scope_builder
.
let_names
{
possibly_annex_b_functions
.
remove_if_exists
(
*
n
)
;
}
for
n
in
&
body_scope_builder
.
const_names
{
possibly_annex_b_functions
.
remove_if_exists
(
*
n
)
;
}
for
n
in
&
self
.
parameter_names
{
possibly_annex_b_functions
.
remove_if_exists
(
*
n
)
;
}
possibly_annex_b_functions
.
remove_if_exists
(
CommonSourceAtomSetIndices
:
:
arguments
(
)
)
;
for
n
in
possibly_annex_b_functions
.
names
(
)
{
body_scope_builder
.
var_names
.
insert
(
*
n
)
;
}
possibly_annex_b_functions
.
mark_annex_b
(
function_declaration_properties
)
;
}
fn
into_scope_data_set
(
mut
self
function_declaration_properties
:
&
mut
FunctionDeclarationPropertyMap
possibly_annex_b_functions
:
&
mut
PossiblyAnnexBFunctionList
enclosing
:
ScopeIndex
mut
body_scope_builder
:
FunctionBodyScopeBuilder
)
-
>
FunctionScopeDataSet
{
let
mut
arguments_object_needed
=
true
;
if
self
.
this_mode
=
=
ThisMode
:
:
Lexical
{
arguments_object_needed
=
false
;
}
else
if
self
.
parameter_has_arguments
{
arguments_object_needed
=
false
;
}
else
if
!
self
.
parameter_has_arguments
{
if
body_scope_builder
.
function_or_lexical_has_arguments
{
arguments_object_needed
=
false
;
}
}
if
self
.
strict
|
|
!
self
.
has_parameter_expressions
{
}
else
{
}
self
.
perform_annex_b
(
function_declaration_properties
possibly_annex_b_functions
&
mut
body_scope_builder
)
;
let
has_extra_body_var_scope
=
self
.
has_parameter_expressions
;
let
function_max_var_names_count
=
if
has_extra_body_var_scope
{
0
}
else
{
body_scope_builder
.
var_names
.
len
(
)
}
;
let
mut
function_scope_data
=
FunctionScopeData
:
:
new
(
self
.
has_parameter_expressions
self
.
positional_parameter_names
.
len
(
)
self
.
non_positional_parameter_names
.
len
(
)
function_max_var_names_count
enclosing
self
.
script_index
self
.
is_arrow
)
;
for
maybe_name
in
&
self
.
positional_parameter_names
{
match
maybe_name
{
Some
(
n
)
=
>
{
let
is_closed_over
=
self
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
|
|
(
!
has_extra_body_var_scope
&
&
body_scope_builder
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
)
;
function_scope_data
.
base
.
bindings
.
push
(
Some
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
)
}
None
=
>
function_scope_data
.
base
.
bindings
.
push
(
None
)
}
}
for
n
in
&
self
.
non_positional_parameter_names
{
let
is_closed_over
=
self
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
|
|
(
!
has_extra_body_var_scope
&
&
body_scope_builder
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
)
;
function_scope_data
.
base
.
bindings
.
push
(
Some
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
)
}
let
extra_body_var_scope_data
=
if
!
self
.
has_parameter_expressions
{
debug_assert
!
(
!
has_extra_body_var_scope
)
;
for
n
in
&
body_scope_builder
.
var_names
{
if
self
.
parameter_names
.
contains
(
n
)
|
|
(
arguments_object_needed
&
&
*
n
=
=
CommonSourceAtomSetIndices
:
:
arguments
(
)
)
{
continue
;
}
let
is_closed_over
=
body_scope_builder
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
;
function_scope_data
.
base
.
bindings
.
push
(
Some
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
)
;
}
ScopeData
:
:
Alias
(
self
.
scope_index
)
}
else
{
debug_assert
!
(
has_extra_body_var_scope
)
;
let
function_has_extensible_scope
=
!
self
.
strict
&
&
self
.
has_direct_eval
;
let
mut
data
=
VarScopeData
:
:
new
(
body_scope_builder
.
var_names
.
len
(
)
function_has_extensible_scope
self
.
scope_index
)
;
for
n
in
&
body_scope_builder
.
var_names
{
let
is_closed_over
=
body_scope_builder
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
base
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
;
}
ScopeData
:
:
Var
(
data
)
}
;
let
lexical_scope_data
=
if
body_scope_builder
.
let_names
.
len
(
)
>
0
|
|
body_scope_builder
.
const_names
.
len
(
)
>
0
{
let
mut
data
=
LexicalScopeData
:
:
new_function_lexical
(
body_scope_builder
.
let_names
.
len
(
)
body_scope_builder
.
const_names
.
len
(
)
body_scope_builder
.
var_scope_index
)
;
for
n
in
&
body_scope_builder
.
let_names
{
let
is_closed_over
=
body_scope_builder
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
base
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
body_scope_builder
.
const_names
{
let
is_closed_over
=
body_scope_builder
.
base
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
base
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
ScopeData
:
:
Lexical
(
data
)
}
else
{
ScopeData
:
:
Alias
(
body_scope_builder
.
var_scope_index
)
}
;
FunctionScopeDataSet
{
function
:
ScopeData
:
:
Function
(
function_scope_data
)
extra_body_var
:
extra_body_var_scope_data
lexical
:
lexical_scope_data
}
}
}
#
[
derive
(
Debug
)
]
struct
FunctionBodyScopeBuilder
{
base
:
BaseScopeBuilder
var_names
:
IndexSet
<
SourceAtomSetIndex
>
let_names
:
Vec
<
SourceAtomSetIndex
>
const_names
:
Vec
<
SourceAtomSetIndex
>
functions_to_initialize
:
Vec
<
ScriptStencilIndex
>
function_or_lexical_has_arguments
:
bool
var_scope_index
:
ScopeIndex
lexical_scope_index
:
ScopeIndex
}
impl
FunctionBodyScopeBuilder
{
fn
new
(
var_scope_index
:
ScopeIndex
lexical_scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
base
:
BaseScopeBuilder
:
:
new
(
)
var_names
:
IndexSet
:
:
new
(
)
let_names
:
Vec
:
:
new
(
)
const_names
:
Vec
:
:
new
(
)
functions_to_initialize
:
Vec
:
:
new
(
)
function_or_lexical_has_arguments
:
false
var_scope_index
lexical_scope_index
}
}
fn
declare_var
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
var_names
.
insert
(
name
)
;
}
fn
check_lexical_or_function_name
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
if
name
=
=
CommonSourceAtomSetIndices
:
:
arguments
(
)
{
self
.
function_or_lexical_has_arguments
=
true
;
}
}
fn
declare_let
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
let_names
.
push
(
name
.
clone
(
)
)
;
self
.
check_lexical_or_function_name
(
name
)
;
}
fn
declare_const
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
let_names
.
push
(
name
.
clone
(
)
)
;
self
.
check_lexical_or_function_name
(
name
)
;
}
fn
declare_function
(
&
mut
self
name
:
SourceAtomSetIndex
fun_index
:
ScriptStencilIndex
)
{
self
.
var_names
.
insert
(
name
)
;
self
.
check_lexical_or_function_name
(
name
)
;
self
.
functions_to_initialize
.
push
(
fun_index
)
;
}
}
#
[
derive
(
Debug
)
]
enum
ScopeBuilder
{
Global
(
GlobalScopeBuilder
)
Block
(
BlockScopeBuilder
)
FunctionExpression
(
FunctionExpressionScopeBuilder
)
FunctionParameters
(
FunctionParametersScopeBuilder
)
FunctionBody
(
FunctionBodyScopeBuilder
)
}
impl
ScopeBuilder
{
fn
get_scope_index
(
&
self
)
-
>
ScopeIndex
{
match
self
{
ScopeBuilder
:
:
Global
(
builder
)
=
>
builder
.
scope_index
ScopeBuilder
:
:
Block
(
builder
)
=
>
builder
.
scope_index
ScopeBuilder
:
:
FunctionExpression
(
builder
)
=
>
builder
.
scope_index
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
builder
.
scope_index
ScopeBuilder
:
:
FunctionBody
(
builder
)
=
>
builder
.
lexical_scope_index
}
}
fn
declare_var
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
base_mut
(
)
.
name_tracker
.
note_def
(
name
)
;
match
self
{
ScopeBuilder
:
:
Global
(
ref
mut
builder
)
=
>
builder
.
declare_var
(
name
)
ScopeBuilder
:
:
FunctionBody
(
ref
mut
builder
)
=
>
builder
.
declare_var
(
name
)
_
=
>
panic
!
(
"
unexpected
var
scope
builder
"
)
}
}
fn
declare_let
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
base_mut
(
)
.
name_tracker
.
note_def
(
name
)
;
match
self
{
ScopeBuilder
:
:
Global
(
ref
mut
builder
)
=
>
builder
.
declare_let
(
name
)
ScopeBuilder
:
:
Block
(
ref
mut
builder
)
=
>
builder
.
declare_let
(
name
)
ScopeBuilder
:
:
FunctionBody
(
ref
mut
builder
)
=
>
builder
.
declare_let
(
name
)
_
=
>
panic
!
(
"
unexpected
lexical
scope
builder
"
)
}
}
fn
declare_const
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
base_mut
(
)
.
name_tracker
.
note_def
(
name
)
;
match
self
{
ScopeBuilder
:
:
Global
(
ref
mut
builder
)
=
>
builder
.
declare_const
(
name
)
ScopeBuilder
:
:
Block
(
ref
mut
builder
)
=
>
builder
.
declare_const
(
name
)
ScopeBuilder
:
:
FunctionBody
(
ref
mut
builder
)
=
>
builder
.
declare_const
(
name
)
_
=
>
panic
!
(
"
unexpected
lexical
scope
builder
"
)
}
}
fn
set_function_name
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
base_mut
(
)
.
name_tracker
.
note_def
(
name
)
;
match
self
{
ScopeBuilder
:
:
FunctionExpression
(
ref
mut
builder
)
=
>
builder
.
set_function_name
(
name
)
_
=
>
{
}
}
}
fn
declare_param
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
base_mut
(
)
.
name_tracker
.
note_def
(
name
)
;
match
self
{
ScopeBuilder
:
:
FunctionParameters
(
ref
mut
builder
)
=
>
builder
.
declare_param
(
name
)
_
=
>
panic
!
(
"
unexpected
function
scope
builder
"
)
}
}
fn
base
(
&
self
)
-
>
&
BaseScopeBuilder
{
match
self
{
ScopeBuilder
:
:
Global
(
builder
)
=
>
&
builder
.
base
ScopeBuilder
:
:
Block
(
builder
)
=
>
&
builder
.
base
ScopeBuilder
:
:
FunctionExpression
(
builder
)
=
>
&
builder
.
base
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
&
builder
.
base
ScopeBuilder
:
:
FunctionBody
(
builder
)
=
>
&
builder
.
base
}
}
fn
base_mut
(
&
mut
self
)
-
>
&
mut
BaseScopeBuilder
{
match
self
{
ScopeBuilder
:
:
Global
(
builder
)
=
>
&
mut
builder
.
base
ScopeBuilder
:
:
Block
(
builder
)
=
>
&
mut
builder
.
base
ScopeBuilder
:
:
FunctionExpression
(
builder
)
=
>
&
mut
builder
.
base
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
&
mut
builder
.
base
ScopeBuilder
:
:
FunctionBody
(
builder
)
=
>
&
mut
builder
.
base
}
}
}
#
[
derive
(
Debug
)
]
struct
ScopeKindStack
{
stack
:
Vec
<
ScopeKind
>
}
impl
ScopeKindStack
{
fn
new
(
)
-
>
Self
{
Self
{
stack
:
Vec
:
:
new
(
)
}
}
fn
innermost
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
ScopeKind
{
self
.
stack
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
}
fn
push
(
&
mut
self
kind
:
ScopeKind
)
{
self
.
stack
.
push
(
kind
)
}
fn
pop
(
&
mut
self
kind
:
ScopeKind
)
{
match
self
.
stack
.
pop
(
)
{
Some
(
k
)
if
k
=
=
kind
=
>
{
}
_
=
>
panic
!
(
"
unmatching
scope
kind
"
)
}
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
stack
.
len
(
)
=
=
0
}
}
#
[
derive
(
Debug
)
]
struct
ScopeBuilderStack
{
stack
:
Vec
<
ScopeBuilder
>
closed_over_bindings_for_lazy
:
Vec
<
Vec
<
Option
<
SourceAtomSetIndex
>
>
>
}
impl
ScopeBuilderStack
{
fn
new
(
)
-
>
Self
{
Self
{
stack
:
Vec
:
:
new
(
)
closed_over_bindings_for_lazy
:
Vec
:
:
new
(
)
}
}
fn
innermost_var
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
ScopeBuilder
{
for
builder
in
self
.
stack
.
iter_mut
(
)
.
rev
(
)
{
match
builder
{
ScopeBuilder
:
:
Global
(
_
)
=
>
return
builder
ScopeBuilder
:
:
FunctionBody
(
_
)
=
>
return
builder
_
=
>
{
}
}
}
panic
!
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
;
}
fn
maybe_innermost_function_parameters
<
'
a
>
(
&
'
a
mut
self
)
-
>
Option
<
&
'
a
mut
FunctionParametersScopeBuilder
>
{
for
builder
in
self
.
stack
.
iter_mut
(
)
.
rev
(
)
{
match
builder
{
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
return
Some
(
builder
)
_
=
>
{
}
}
}
None
}
fn
innermost_lexical
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
ScopeBuilder
{
self
.
innermost
(
)
}
fn
innermost
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
ScopeBuilder
{
self
.
stack
.
last_mut
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
}
fn
current_scope_index
(
&
self
)
-
>
ScopeIndex
{
self
.
stack
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
.
get_scope_index
(
)
}
fn
current_scope_index_or_empty_global
(
&
self
)
-
>
ScopeIndex
{
self
.
current_scope_index
(
)
}
fn
push_global
(
&
mut
self
builder
:
GlobalScopeBuilder
)
{
self
.
stack
.
push
(
ScopeBuilder
:
:
Global
(
builder
)
)
}
fn
pop_global
(
&
mut
self
)
-
>
GlobalScopeBuilder
{
match
self
.
pop
(
)
{
ScopeBuilder
:
:
Global
(
builder
)
=
>
builder
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
}
fn
push_block
(
&
mut
self
builder
:
BlockScopeBuilder
)
{
self
.
stack
.
push
(
ScopeBuilder
:
:
Block
(
builder
)
)
}
fn
pop_block
(
&
mut
self
)
-
>
BlockScopeBuilder
{
match
self
.
pop
(
)
{
ScopeBuilder
:
:
Block
(
builder
)
=
>
{
self
.
update_closed_over_bindings_for_lazy
(
&
builder
.
base
)
;
builder
}
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
}
fn
push_function_expression
(
&
mut
self
builder
:
FunctionExpressionScopeBuilder
)
{
self
.
stack
.
push
(
ScopeBuilder
:
:
FunctionExpression
(
builder
)
)
}
fn
pop_function_expression
(
&
mut
self
)
-
>
FunctionExpressionScopeBuilder
{
match
self
.
pop
(
)
{
ScopeBuilder
:
:
FunctionExpression
(
builder
)
=
>
{
self
.
update_closed_over_bindings_for_lazy
(
&
builder
.
base
)
;
builder
}
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
}
fn
push_function_parameters
(
&
mut
self
builder
:
FunctionParametersScopeBuilder
)
{
self
.
stack
.
push
(
ScopeBuilder
:
:
FunctionParameters
(
builder
)
)
}
fn
pop_function_parameters_and_body
(
&
mut
self
)
-
>
(
FunctionParametersScopeBuilder
FunctionBodyScopeBuilder
)
{
let
body_scope_builder
=
match
self
.
pop
(
)
{
ScopeBuilder
:
:
FunctionBody
(
builder
)
=
>
builder
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
;
let
parameter_scope_builder
=
match
self
.
pop
(
)
{
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
builder
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
;
let
has_extra_body_var_scope
=
parameter_scope_builder
.
has_parameter_expressions
;
if
has_extra_body_var_scope
{
self
.
update_closed_over_bindings_for_lazy
(
&
body_scope_builder
.
base
)
;
self
.
update_closed_over_bindings_for_lazy
(
&
parameter_scope_builder
.
base
)
;
}
else
{
self
.
update_closed_over_bindings_for_lazy_with_parameters_and_body
(
&
parameter_scope_builder
.
base
&
body_scope_builder
.
base
)
;
}
(
parameter_scope_builder
body_scope_builder
)
}
fn
get_function_parameters
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
FunctionParametersScopeBuilder
{
match
self
.
innermost
(
)
{
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
builder
_
=
>
panic
!
(
"
unmatching
scope
builder
"
)
}
}
fn
push_function_body
(
&
mut
self
builder
:
FunctionBodyScopeBuilder
)
{
self
.
stack
.
push
(
ScopeBuilder
:
:
FunctionBody
(
builder
)
)
}
fn
update_closed_over_bindings_for_lazy
(
&
mut
self
builder
:
&
BaseScopeBuilder
)
{
match
self
.
closed_over_bindings_for_lazy
.
last_mut
(
)
{
Some
(
bindings
)
=
>
{
for
name
in
builder
.
name_tracker
.
defined_and_closed_over_vars
(
)
{
bindings
.
push
(
Some
(
*
name
)
)
;
}
bindings
.
push
(
None
)
;
}
None
=
>
{
}
}
}
fn
update_closed_over_bindings_for_lazy_with_parameters_and_body
(
&
mut
self
builder1
:
&
BaseScopeBuilder
builder2
:
&
BaseScopeBuilder
)
{
match
self
.
closed_over_bindings_for_lazy
.
last_mut
(
)
{
Some
(
bindings
)
=
>
{
for
name
in
builder1
.
name_tracker
.
defined_and_closed_over_vars
(
)
{
bindings
.
push
(
Some
(
*
name
)
)
;
}
for
name
in
builder2
.
name_tracker
.
defined_and_closed_over_vars
(
)
{
bindings
.
push
(
Some
(
*
name
)
)
;
}
bindings
.
push
(
None
)
;
}
None
=
>
{
}
}
}
fn
pop
(
&
mut
self
)
-
>
ScopeBuilder
{
let
inner
=
self
.
stack
.
pop
(
)
.
expect
(
"
unmatching
scope
builder
"
)
;
match
self
.
stack
.
last_mut
(
)
{
Some
(
outer
)
=
>
{
let
inner_base
=
inner
.
base
(
)
;
let
outer_base
=
outer
.
base_mut
(
)
;
outer_base
.
bindings_accessed_dynamically
|
=
inner_base
.
bindings_accessed_dynamically
;
match
inner
{
ScopeBuilder
:
:
Global
(
_
)
=
>
{
panic
!
(
"
Global
shouldn
'
t
be
enclosed
by
other
scope
"
)
;
}
ScopeBuilder
:
:
Block
(
_
)
=
>
{
outer_base
.
name_tracker
.
propagate_from_inner_non_script
(
&
inner_base
.
name_tracker
)
;
}
ScopeBuilder
:
:
FunctionExpression
(
_
)
=
>
{
outer_base
.
name_tracker
.
propagate_from_inner_non_script
(
&
inner_base
.
name_tracker
)
;
}
ScopeBuilder
:
:
FunctionParameters
(
_
)
=
>
{
outer_base
.
name_tracker
.
propagate_from_inner_script
(
&
inner_base
.
name_tracker
)
;
}
ScopeBuilder
:
:
FunctionBody
(
_
)
=
>
{
outer_base
.
name_tracker
.
propagate_from_inner_non_script
(
&
inner_base
.
name_tracker
)
;
}
}
}
None
=
>
{
}
}
inner
}
}
#
[
derive
(
Debug
)
]
pub
struct
FunctionScriptStencilBuilder
{
function_stencil_indices
:
AssociatedData
<
ScriptStencilIndex
>
functions
:
ScriptStencilList
function_stack
:
Vec
<
ScriptStencilIndex
>
}
impl
FunctionScriptStencilBuilder
{
fn
new
(
)
-
>
Self
{
Self
{
function_stencil_indices
:
AssociatedData
:
:
new
(
)
functions
:
ScriptStencilList
:
:
new
(
)
function_stack
:
Vec
:
:
new
(
)
}
}
fn
enter
<
T
>
(
&
mut
self
fun
:
&
T
syntax_kind
:
FunctionSyntaxKind
enclosing_scope_index
:
ScopeIndex
)
-
>
ScriptStencilIndex
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
let
loc
=
fun
.
get_loc
(
)
;
let
source_start
=
loc
.
start
as
u32
;
let
lineno
=
1
;
let
column
=
0
;
let
function_stencil
=
ScriptStencil
:
:
lazy_function
(
SourceExtent
{
source_start
source_end
:
0
to_string_start
:
source_start
to_string_end
:
0
lineno
column
}
None
syntax_kind
.
is_generator
(
)
syntax_kind
.
is_async
(
)
FunctionFlags
:
:
interpreted
(
syntax_kind
)
enclosing_scope_index
)
;
let
index
=
self
.
functions
.
push
(
function_stencil
)
;
self
.
function_stencil_indices
.
insert
(
fun
index
)
;
match
self
.
maybe_current_mut
(
)
{
Some
(
enclosing
)
=
>
{
enclosing
.
push_inner_function
(
index
)
;
}
None
=
>
{
}
}
self
.
function_stack
.
push
(
index
)
;
index
}
fn
leave
<
T
>
(
&
mut
self
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
let
loc
=
fun
.
get_loc
(
)
;
let
source_end
=
loc
.
end
;
self
.
current_mut
(
)
.
set_source_end
(
source_end
)
;
self
.
current_mut
(
)
.
set_to_string_end
(
source_end
)
;
self
.
function_stack
.
pop
(
)
;
}
fn
current_index
(
&
self
)
-
>
ScriptStencilIndex
{
*
self
.
function_stack
.
last
(
)
.
expect
(
"
should
be
inside
function
"
)
}
fn
maybe_current
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
&
'
a
ScriptStencil
>
{
let
maybe_index
=
self
.
function_stack
.
last
(
)
;
maybe_index
.
map
(
move
|
index
|
self
.
functions
.
get
(
*
index
)
)
}
fn
current
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
ScriptStencil
{
self
.
maybe_current
(
)
.
expect
(
"
should
be
inside
function
"
)
}
fn
maybe_current_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
Option
<
&
'
a
mut
ScriptStencil
>
{
let
maybe_index
=
self
.
function_stack
.
last
(
)
.
cloned
(
)
;
maybe_index
.
map
(
move
|
index
|
self
.
functions
.
get_mut
(
index
)
)
}
fn
current_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
ScriptStencil
{
self
.
maybe_current_mut
(
)
.
expect
(
"
should
be
inside
function
"
)
}
fn
set_function_name
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
current_mut
(
)
.
set_fun_name
(
name
)
;
}
fn
on_function_parameters
<
T
>
(
&
mut
self
params
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
let
loc
=
params
.
get_loc
(
)
;
let
params_start
=
loc
.
start
;
self
.
current_mut
(
)
.
set_source_starts
(
params_start
)
;
}
fn
on_non_rest_parameter
(
&
mut
self
)
{
let
fun
=
self
.
current_mut
(
)
;
fun
.
add_fun_nargs
(
)
;
}
fn
on_rest_parameter
(
&
mut
self
)
{
let
fun
=
self
.
current_mut
(
)
;
fun
.
add_fun_nargs
(
)
;
fun
.
set_has_rest
(
)
;
}
fn
add_closed_over_bindings
(
&
mut
self
mut
closed_over_bindings_for_lazy
:
Vec
<
Option
<
SourceAtomSetIndex
>
>
)
{
loop
{
match
closed_over_bindings_for_lazy
.
last
(
)
{
Some
(
Some
(
_
)
)
=
>
{
break
;
}
Some
(
None
)
=
>
{
closed_over_bindings_for_lazy
.
pop
(
)
;
}
None
=
>
{
break
;
}
}
}
let
current
=
self
.
current_mut
(
)
;
for
name
in
closed_over_bindings_for_lazy
{
match
name
{
Some
(
name
)
=
>
current
.
push_closed_over_bindings
(
name
)
None
=
>
current
.
push_closed_over_bindings_delimiter
(
)
}
}
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
ScopeBuildError
{
NotImplemented
(
&
'
static
str
)
}
#
[
derive
(
Debug
)
]
pub
struct
ScopeDataMapBuilder
{
scope_kind_stack
:
ScopeKindStack
builder_stack
:
ScopeBuilderStack
scopes
:
ScopeDataList
global
:
Option
<
ScopeIndex
>
non_global
:
AssociatedData
<
ScopeIndex
>
function_stencil_builder
:
FunctionScriptStencilBuilder
function_declaration_properties
:
FunctionDeclarationPropertyMap
possibly_annex_b_functions
:
PossiblyAnnexBFunctionList
error
:
Option
<
ScopeBuildError
>
}
impl
ScopeDataMapBuilder
{
pub
fn
new
(
)
-
>
Self
{
Self
{
scope_kind_stack
:
ScopeKindStack
:
:
new
(
)
builder_stack
:
ScopeBuilderStack
:
:
new
(
)
scopes
:
ScopeDataList
:
:
new
(
)
global
:
None
non_global
:
AssociatedData
:
:
new
(
)
function_stencil_builder
:
FunctionScriptStencilBuilder
:
:
new
(
)
function_declaration_properties
:
FunctionDeclarationPropertyMap
:
:
new
(
)
possibly_annex_b_functions
:
PossiblyAnnexBFunctionList
:
:
new
(
)
error
:
None
}
}
fn
set_error
(
&
mut
self
e
:
ScopeBuildError
)
{
if
self
.
error
.
is_none
(
)
{
self
.
error
=
Some
(
e
)
;
}
}
pub
fn
before_script
(
&
mut
self
)
{
let
index
=
self
.
scopes
.
allocate
(
)
;
let
builder
=
GlobalScopeBuilder
:
:
new
(
index
)
;
self
.
global
=
Some
(
index
)
;
self
.
builder_stack
.
push_global
(
builder
)
;
}
pub
fn
after_script
(
&
mut
self
)
{
let
builder
=
self
.
builder_stack
.
pop_global
(
)
;
let
scope_index
=
builder
.
scope_index
;
let
scope
=
builder
.
into_scope_data
(
&
mut
self
.
function_declaration_properties
&
mut
self
.
possibly_annex_b_functions
)
;
self
.
scopes
.
populate
(
scope_index
scope
)
;
}
pub
fn
before_block_statement
<
T
>
(
&
mut
self
block
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
let
index
=
self
.
scopes
.
allocate
(
)
;
let
builder
=
BlockScopeBuilder
:
:
new
(
index
)
;
self
.
non_global
.
insert
(
block
index
)
;
self
.
builder_stack
.
push_block
(
builder
)
;
}
pub
fn
after_block_statement
(
&
mut
self
)
{
let
builder
=
self
.
builder_stack
.
pop_block
(
)
;
let
enclosing
=
self
.
builder_stack
.
current_scope_index
(
)
;
self
.
scopes
.
populate
(
builder
.
scope_index
builder
.
into_scope_data
(
enclosing
&
mut
self
.
possibly_annex_b_functions
)
)
;
}
pub
fn
before_var_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Var
)
;
}
pub
fn
after_var_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Var
)
;
}
pub
fn
before_let_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Let
)
;
}
pub
fn
after_let_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Let
)
;
}
pub
fn
before_const_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Const
)
;
}
pub
fn
after_const_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Const
)
;
}
pub
fn
on_binding_identifier
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
if
self
.
scope_kind_stack
.
is_empty
(
)
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
Unsupported
binding
identifier
"
)
)
;
return
;
}
match
self
.
scope_kind_stack
.
innermost
(
)
{
ScopeKind
:
:
Var
=
>
self
.
builder_stack
.
innermost_var
(
)
.
declare_var
(
name
)
ScopeKind
:
:
Let
=
>
self
.
builder_stack
.
innermost_lexical
(
)
.
declare_let
(
name
)
ScopeKind
:
:
Const
=
>
self
.
builder_stack
.
innermost_lexical
(
)
.
declare_const
(
name
)
ScopeKind
:
:
FunctionName
=
>
{
self
.
builder_stack
.
innermost
(
)
.
set_function_name
(
name
)
;
self
.
function_stencil_builder
.
set_function_name
(
name
)
;
}
ScopeKind
:
:
FunctionParametersAndBody
=
>
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
Unsupported
binding
identifier
"
)
)
;
return
;
}
ScopeKind
:
:
FormalParameter
=
>
self
.
builder_stack
.
innermost
(
)
.
declare_param
(
name
)
_
=
>
panic
!
(
"
Not
implemeneted
"
)
}
}
pub
fn
on_non_binding_identifier
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
builder_stack
.
innermost
(
)
.
base_mut
(
)
.
name_tracker
.
note_use
(
name
)
;
}
pub
fn
before_function_declaration
<
T
>
(
&
mut
self
name
:
SourceAtomSetIndex
fun
:
&
T
is_generator
:
bool
is_async
:
bool
)
-
>
ScriptStencilIndex
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
if
is_generator
|
|
is_async
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
Generator
or
async
function
"
)
)
;
}
let
fun_index
=
self
.
function_stencil_builder
.
enter
(
fun
FunctionSyntaxKind
:
:
function_declaration
(
is_generator
is_async
)
self
.
builder_stack
.
current_scope_index_or_empty_global
(
)
)
;
match
self
.
builder_stack
.
innermost_lexical
(
)
{
ScopeBuilder
:
:
Global
(
ref
mut
builder
)
=
>
builder
.
declare_function
(
name
fun_index
)
ScopeBuilder
:
:
Block
(
ref
mut
builder
)
=
>
builder
.
declare_function
(
name
fun_index
)
ScopeBuilder
:
:
FunctionBody
(
ref
mut
builder
)
=
>
{
builder
.
declare_function
(
name
fun_index
)
}
_
=
>
panic
!
(
"
unexpected
lexical
for
FunctionDeclaration
"
)
}
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
FunctionName
)
;
fun_index
}
pub
fn
after_function_declaration
<
T
>
(
&
mut
self
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
function_stencil_builder
.
leave
(
fun
)
;
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
FunctionName
)
;
}
pub
fn
before_function_expression
<
T
>
(
&
mut
self
fun
:
&
T
is_generator
:
bool
is_async
:
bool
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
Function
expression
(
name
analysis
)
"
)
)
;
let
index
=
self
.
scopes
.
allocate
(
)
;
let
builder
=
FunctionExpressionScopeBuilder
:
:
new
(
index
)
;
self
.
non_global
.
insert
(
fun
index
)
;
self
.
builder_stack
.
push_function_expression
(
builder
)
;
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
FunctionName
)
;
self
.
function_stencil_builder
.
enter
(
fun
FunctionSyntaxKind
:
:
function_expression
(
is_generator
is_async
)
self
.
builder_stack
.
current_scope_index_or_empty_global
(
)
)
;
}
pub
fn
after_function_expression
<
T
>
(
&
mut
self
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
function_stencil_builder
.
leave
(
fun
)
;
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
FunctionName
)
;
let
builder
=
self
.
builder_stack
.
pop_function_expression
(
)
;
let
enclosing
=
self
.
builder_stack
.
current_scope_index
(
)
;
self
.
scopes
.
populate
(
builder
.
scope_index
builder
.
into_scope_data
(
enclosing
)
)
;
}
pub
fn
before_method
<
T
>
(
&
mut
self
fun
:
&
T
is_generator
:
bool
is_async
:
bool
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
Method
(
name
calculation
)
"
)
)
;
self
.
function_stencil_builder
.
enter
(
fun
FunctionSyntaxKind
:
:
method
(
is_generator
is_async
)
self
.
builder_stack
.
current_scope_index_or_empty_global
(
)
)
;
}
pub
fn
after_method
<
T
>
(
&
mut
self
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
function_stencil_builder
.
leave
(
fun
)
;
}
pub
fn
before_getter
<
T
>
(
&
mut
self
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
Getter
(
name
calculation
)
"
)
)
;
self
.
function_stencil_builder
.
enter
(
fun
FunctionSyntaxKind
:
:
getter
(
)
self
.
builder_stack
.
current_scope_index_or_empty_global
(
)
)
;
}
pub
fn
on_getter_parameter
<
T
>
(
&
mut
self
param
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
before_function_parameters
(
param
)
;
self
.
after_function_parameters
(
)
;
}
pub
fn
after_getter
<
T
>
(
&
mut
self
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
function_stencil_builder
.
leave
(
fun
)
;
}
pub
fn
before_setter
<
T
>
(
&
mut
self
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
Setter
(
name
calculation
)
"
)
)
;
self
.
function_stencil_builder
.
enter
(
fun
FunctionSyntaxKind
:
:
setter
(
)
self
.
builder_stack
.
current_scope_index_or_empty_global
(
)
)
;
}
pub
fn
before_setter_parameter
<
T
>
(
&
mut
self
param
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
before_function_parameters
(
param
)
;
self
.
before_parameter
(
)
;
}
pub
fn
after_setter_parameter
(
&
mut
self
)
{
self
.
after_function_parameters
(
)
;
}
pub
fn
after_setter
<
T
>
(
&
mut
self
fun
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
function_stencil_builder
.
leave
(
fun
)
;
}
pub
fn
before_arrow_function
<
T
>
(
&
mut
self
is_async
:
bool
params
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
Arrow
function
(
special
name
handling
)
"
)
)
;
self
.
function_stencil_builder
.
enter
(
params
FunctionSyntaxKind
:
:
arrow
(
is_async
)
self
.
builder_stack
.
current_scope_index_or_empty_global
(
)
)
;
}
pub
fn
after_arrow_function
<
T
>
(
&
mut
self
body
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
function_stencil_builder
.
leave
(
body
)
;
}
pub
fn
before_function_parameters
<
T
>
(
&
mut
self
params
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
FunctionParametersAndBody
)
;
self
.
builder_stack
.
closed_over_bindings_for_lazy
.
push
(
Vec
:
:
new
(
)
)
;
self
.
function_stencil_builder
.
on_function_parameters
(
params
)
;
let
index
=
self
.
scopes
.
allocate
(
)
;
let
is_arrow
=
self
.
function_stencil_builder
.
current
(
)
.
is_arrow_function
(
)
;
let
builder
=
FunctionParametersScopeBuilder
:
:
new
(
index
is_arrow
self
.
function_stencil_builder
.
current_index
(
)
)
;
self
.
non_global
.
insert
(
params
index
)
;
self
.
builder_stack
.
push_function_parameters
(
builder
)
;
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
FormalParameter
)
;
}
pub
fn
after_function_parameters
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
FormalParameter
)
;
}
pub
fn
before_parameter
(
&
mut
self
)
{
let
builder
=
self
.
builder_stack
.
get_function_parameters
(
)
;
builder
.
before_parameter
(
)
;
self
.
function_stencil_builder
.
on_non_rest_parameter
(
)
;
}
pub
fn
before_binding_pattern
(
&
mut
self
)
{
match
self
.
builder_stack
.
innermost
(
)
{
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
{
builder
.
before_binding_pattern
(
)
;
}
_
=
>
{
}
}
}
pub
fn
after_initializer
(
&
mut
self
)
{
match
self
.
builder_stack
.
innermost
(
)
{
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
{
builder
.
after_initializer
(
)
;
}
_
=
>
{
}
}
}
pub
fn
before_computed_property_name
(
&
mut
self
)
{
match
self
.
builder_stack
.
innermost
(
)
{
ScopeBuilder
:
:
FunctionParameters
(
builder
)
=
>
{
builder
.
before_computed_property_name
(
)
;
}
_
=
>
{
}
}
}
pub
fn
before_rest_parameter
(
&
mut
self
)
{
self
.
function_stencil_builder
.
on_rest_parameter
(
)
;
let
builder
=
self
.
builder_stack
.
get_function_parameters
(
)
;
builder
.
before_rest_parameter
(
)
;
}
pub
fn
before_function_body
<
T
>
(
&
mut
self
body
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
let
var_index
=
self
.
scopes
.
allocate
(
)
;
let
lexical_index
=
self
.
scopes
.
allocate
(
)
;
debug_assert
!
(
lexical_index
=
=
var_index
.
next
(
)
)
;
let
builder
=
FunctionBodyScopeBuilder
:
:
new
(
var_index
lexical_index
)
;
self
.
non_global
.
insert
(
body
var_index
)
;
self
.
builder_stack
.
push_function_body
(
builder
)
;
}
pub
fn
after_function_body
(
&
mut
self
)
{
let
(
parameter_scope_builder
body_scope_builder
)
=
self
.
builder_stack
.
pop_function_parameters_and_body
(
)
;
let
enclosing
=
self
.
builder_stack
.
current_scope_index
(
)
;
let
has_extra_body_var_scope
=
parameter_scope_builder
.
has_parameter_expressions
;
self
.
function_stencil_builder
.
add_closed_over_bindings
(
self
.
builder_stack
.
closed_over_bindings_for_lazy
.
pop
(
)
.
expect
(
"
Vector
should
be
pushed
by
before_function_parameters
"
)
)
;
let
function_scope_index
=
parameter_scope_builder
.
scope_index
;
let
var_scope_index
=
body_scope_builder
.
var_scope_index
;
let
lexical_scope_index
=
body_scope_builder
.
lexical_scope_index
;
let
bindings_accessed_dynamically
=
parameter_scope_builder
.
base
.
bindings_accessed_dynamically
;
let
has_used_this
=
parameter_scope_builder
.
base
.
name_tracker
.
is_used_or_closed_over
(
CommonSourceAtomSetIndices
:
:
this
(
)
)
|
|
bindings_accessed_dynamically
;
let
has_used_arguments
=
parameter_scope_builder
.
base
.
name_tracker
.
is_used_or_closed_over
(
CommonSourceAtomSetIndices
:
:
arguments
(
)
)
|
|
bindings_accessed_dynamically
;
let
parameter_has_arguments
=
parameter_scope_builder
.
parameter_has_arguments
;
let
var_names_has_arguments
=
body_scope_builder
.
var_names
.
contains
(
&
CommonSourceAtomSetIndices
:
:
arguments
(
)
)
;
let
body_has_defined_arguments
=
var_names_has_arguments
|
|
body_scope_builder
.
function_or_lexical_has_arguments
;
let
strict
=
parameter_scope_builder
.
strict
;
let
simple_parameter_list
=
parameter_scope_builder
.
simple_parameter_list
;
let
has_mapped_arguments
=
!
strict
&
&
simple_parameter_list
;
let
scope_data_set
=
parameter_scope_builder
.
into_scope_data_set
(
&
mut
self
.
function_declaration_properties
&
mut
self
.
possibly_annex_b_functions
enclosing
body_scope_builder
)
;
self
.
possibly_annex_b_functions
.
clear
(
)
;
match
&
scope_data_set
.
extra_body_var
{
ScopeData
:
:
Var
(
_
)
=
>
{
debug_assert
!
(
has_extra_body_var_scope
)
;
}
_
=
>
{
debug_assert
!
(
!
has_extra_body_var_scope
)
;
}
}
;
let
fun_stencil
=
self
.
function_stencil_builder
.
current_mut
(
)
;
if
let
ScopeData
:
:
Function
(
fun
)
=
&
scope_data_set
.
function
{
if
fun
.
base
.
needs_environment_object
(
)
{
fun_stencil
.
set_needs_function_environment_objects
(
)
;
}
}
else
{
panic
!
(
"
Unexpected
scope
data
for
function
"
)
;
}
if
has_extra_body_var_scope
{
let
extra_body_var_scope
=
match
&
scope_data_set
.
extra_body_var
{
ScopeData
:
:
Var
(
scope
)
=
>
scope
_
=
>
panic
!
(
"
"
)
}
;
if
extra_body_var_scope
.
base
.
bindings
.
len
(
)
>
0
{
fun_stencil
.
set_function_has_extra_body_var_scope
(
)
;
}
}
if
has_mapped_arguments
{
fun_stencil
.
set_has_mapped_args_obj
(
)
;
}
if
!
fun_stencil
.
is_arrow_function
(
)
{
if
has_used_this
{
fun_stencil
.
set_function_has_this_binding
(
)
;
}
let
mut
uses_arguments
=
false
;
let
mut
try_declare_arguments
=
has_used_arguments
;
if
var_names_has_arguments
{
if
has_extra_body_var_scope
{
try_declare_arguments
=
true
;
}
else
if
!
parameter_has_arguments
{
uses_arguments
=
true
;
}
}
if
try_declare_arguments
{
let
declare_arguments
=
!
parameter_has_arguments
&
&
(
has_extra_body_var_scope
|
|
!
body_has_defined_arguments
)
;
if
declare_arguments
{
fun_stencil
.
set_should_declare_arguments
(
)
;
uses_arguments
=
true
;
}
}
if
uses_arguments
{
fun_stencil
.
set_arguments_has_var_binding
(
)
;
if
bindings_accessed_dynamically
{
fun_stencil
.
set_always_needs_args_obj
(
)
;
}
if
has_used_this
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
IsLikelyConstructorWrapper
condition
"
)
)
;
}
}
}
self
.
scopes
.
populate
(
function_scope_index
scope_data_set
.
function
)
;
self
.
scopes
.
populate
(
var_scope_index
scope_data_set
.
extra_body_var
)
;
self
.
scopes
.
populate
(
lexical_scope_index
scope_data_set
.
lexical
)
;
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
FunctionParametersAndBody
)
;
}
pub
fn
before_catch_clause
(
&
mut
self
)
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
try
-
catch
"
)
)
;
}
pub
fn
on_direct_eval
(
&
mut
self
)
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
direct
eval
(
script
flags
)
"
)
)
;
if
let
Some
(
parameter_scope_builder
)
=
self
.
builder_stack
.
maybe_innermost_function_parameters
(
)
{
parameter_scope_builder
.
has_direct_eval
=
true
;
}
self
.
builder_stack
.
innermost
(
)
.
base_mut
(
)
.
bindings_accessed_dynamically
=
true
;
}
pub
fn
on_class
(
&
mut
self
)
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
class
"
)
)
;
}
pub
fn
on_with
(
&
mut
self
)
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
with
statement
"
)
)
;
}
pub
fn
on_delete
(
&
mut
self
)
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
delete
operator
"
)
)
;
}
pub
fn
on_lexical_for
(
&
mut
self
)
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
lexical
for
"
)
)
;
}
pub
fn
on_switch
(
&
mut
self
)
{
self
.
set_error
(
ScopeBuildError
:
:
NotImplemented
(
"
switch
"
)
)
;
}
}
pub
struct
ScopeDataMapAndScriptStencilList
{
pub
scope_data_map
:
ScopeDataMap
pub
function_stencil_indices
:
AssociatedData
<
ScriptStencilIndex
>
pub
function_declaration_properties
:
FunctionDeclarationPropertyMap
pub
functions
:
ScriptStencilList
pub
error
:
Option
<
ScopeBuildError
>
}
impl
From
<
ScopeDataMapBuilder
>
for
ScopeDataMapAndScriptStencilList
{
fn
from
(
builder
:
ScopeDataMapBuilder
)
-
>
ScopeDataMapAndScriptStencilList
{
ScopeDataMapAndScriptStencilList
{
scope_data_map
:
ScopeDataMap
:
:
new
(
builder
.
scopes
builder
.
global
.
expect
(
"
There
should
be
global
scope
data
"
)
builder
.
non_global
)
function_stencil_indices
:
builder
.
function_stencil_builder
.
function_stencil_indices
function_declaration_properties
:
builder
.
function_declaration_properties
functions
:
builder
.
function_stencil_builder
.
functions
error
:
builder
.
error
}
}
}
