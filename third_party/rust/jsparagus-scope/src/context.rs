use
crate
:
:
data
:
:
{
BindingName
GlobalScopeData
LexicalScopeData
ScopeData
ScopeDataList
ScopeDataMap
ScopeIndex
}
;
use
crate
:
:
free_name_tracker
:
:
FreeNameTracker
;
use
ast
:
:
associated_data
:
:
AssociatedData
;
use
ast
:
:
source_atom_set
:
:
SourceAtomSetIndex
;
use
ast
:
:
source_location_accessor
:
:
SourceLocationAccessor
;
use
ast
:
:
type_id
:
:
NodeTypeIdAccessor
;
use
indexmap
:
:
set
:
:
IndexSet
;
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
VarScopedDeclarationsItemKind
{
#
[
allow
(
dead_code
)
]
VariableDeclaration
#
[
allow
(
dead_code
)
]
ForBinding
#
[
allow
(
dead_code
)
]
FunctionDeclaration
#
[
allow
(
dead_code
)
]
GeneratorDeclaration
#
[
allow
(
dead_code
)
]
AsyncFunctionDeclaration
#
[
allow
(
dead_code
)
]
AsyncGeneratorDeclaration
#
[
allow
(
dead_code
)
]
BindingIdentifier
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
LexicallyScopedDeclarations
{
#
[
allow
(
dead_code
)
]
FunctionDeclaration
#
[
allow
(
dead_code
)
]
GeneratorDeclaration
#
[
allow
(
dead_code
)
]
AsyncFunctionDeclaration
#
[
allow
(
dead_code
)
]
AsyncGeneratorDeclaration
#
[
allow
(
dead_code
)
]
ClassDeclaration
#
[
allow
(
dead_code
)
]
LexicalDeclarationWithLet
#
[
allow
(
dead_code
)
]
LexicalDeclarationWithConst
#
[
allow
(
dead_code
)
]
ExportDeclarationWithAssignmentExpression
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
ScopeKind
{
Var
Let
Const
#
[
allow
(
dead_code
)
]
FormalParameter
#
[
allow
(
dead_code
)
]
CatchParameter
#
[
allow
(
dead_code
)
]
Export
#
[
allow
(
dead_code
)
]
ScriptBodyStatementList
#
[
allow
(
dead_code
)
]
FunctionStatementList
#
[
allow
(
dead_code
)
]
BlockStatementList
}
#
[
derive
(
Debug
)
]
struct
GlobalContext
{
declared_function_names
:
IndexSet
<
SourceAtomSetIndex
>
declared_var_names
:
IndexSet
<
SourceAtomSetIndex
>
let_names
:
Vec
<
SourceAtomSetIndex
>
const_names
:
Vec
<
SourceAtomSetIndex
>
scope_index
:
ScopeIndex
name_tracker
:
FreeNameTracker
}
impl
GlobalContext
{
fn
new
(
scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
declared_function_names
:
IndexSet
:
:
new
(
)
declared_var_names
:
IndexSet
:
:
new
(
)
let_names
:
Vec
:
:
new
(
)
const_names
:
Vec
:
:
new
(
)
scope_index
name_tracker
:
FreeNameTracker
:
:
new
(
)
}
}
fn
declare_var
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
declared_var_names
.
insert
(
name
)
;
}
fn
declare_let
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
let_names
.
push
(
name
)
;
}
fn
declare_const
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
const_names
.
push
(
name
)
;
}
fn
declare_function
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
declared_function_names
.
insert
(
name
)
;
}
fn
remove_function_names_from_var_names
(
&
mut
self
)
{
for
n
in
&
self
.
declared_function_names
{
self
.
declared_var_names
.
remove
(
n
)
;
}
}
fn
into_scope_data
(
self
)
-
>
ScopeData
{
let
mut
data
=
GlobalScopeData
:
:
new
(
self
.
declared_var_names
.
len
(
)
+
self
.
declared_function_names
.
len
(
)
self
.
let_names
.
len
(
)
self
.
const_names
.
len
(
)
)
;
for
n
in
&
self
.
declared_var_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
self
.
declared_function_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new_top_level_function
(
*
n
is_closed_over
)
)
;
}
for
n
in
&
self
.
let_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
self
.
const_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
ScopeData
:
:
Global
(
data
)
}
}
#
[
derive
(
Debug
)
]
struct
BlockContext
{
let_names
:
Vec
<
SourceAtomSetIndex
>
fun_names
:
Vec
<
SourceAtomSetIndex
>
const_names
:
Vec
<
SourceAtomSetIndex
>
scope_index
:
ScopeIndex
name_tracker
:
FreeNameTracker
}
impl
BlockContext
{
fn
new
(
scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
let_names
:
Vec
:
:
new
(
)
fun_names
:
Vec
:
:
new
(
)
const_names
:
Vec
:
:
new
(
)
scope_index
name_tracker
:
FreeNameTracker
:
:
new
(
)
}
}
fn
declare_let
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
let_names
.
push
(
name
)
;
}
fn
declare_const
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
const_names
.
push
(
name
)
;
}
fn
declare_function
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
fun_names
.
push
(
name
)
;
}
fn
into_scope_data
(
self
enclosing
:
ScopeIndex
)
-
>
ScopeData
{
let
mut
data
=
LexicalScopeData
:
:
new
(
self
.
let_names
.
len
(
)
+
self
.
fun_names
.
len
(
)
self
.
const_names
.
len
(
)
enclosing
)
;
for
n
in
&
self
.
let_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
self
.
fun_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
for
n
in
&
self
.
const_names
{
let
is_closed_over
=
self
.
name_tracker
.
is_closed_over_def
(
n
)
;
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
is_closed_over
)
)
}
ScopeData
:
:
Lexical
(
data
)
}
}
#
[
derive
(
Debug
)
]
enum
Context
{
Global
(
GlobalContext
)
Block
(
BlockContext
)
}
impl
Context
{
fn
get_scope_index
(
&
self
)
-
>
ScopeIndex
{
match
self
{
Context
:
:
Global
(
context
)
=
>
context
.
scope_index
Context
:
:
Block
(
context
)
=
>
context
.
scope_index
}
}
fn
declare_var
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
name_tracker_mut
(
)
.
note_def
(
name
)
;
match
self
{
Context
:
:
Global
(
ref
mut
context
)
=
>
context
.
declare_var
(
name
)
_
=
>
panic
!
(
"
unexpected
var
context
"
)
}
}
fn
declare_let
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
name_tracker_mut
(
)
.
note_def
(
name
)
;
match
self
{
Context
:
:
Global
(
ref
mut
context
)
=
>
context
.
declare_let
(
name
)
Context
:
:
Block
(
ref
mut
context
)
=
>
context
.
declare_let
(
name
)
}
}
fn
declare_const
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
name_tracker_mut
(
)
.
note_def
(
name
)
;
match
self
{
Context
:
:
Global
(
ref
mut
context
)
=
>
context
.
declare_const
(
name
)
Context
:
:
Block
(
ref
mut
context
)
=
>
context
.
declare_const
(
name
)
}
}
pub
fn
name_tracker
(
&
self
)
-
>
&
FreeNameTracker
{
match
self
{
Context
:
:
Global
(
context
)
=
>
&
context
.
name_tracker
Context
:
:
Block
(
context
)
=
>
&
context
.
name_tracker
}
}
pub
fn
name_tracker_mut
(
&
mut
self
)
-
>
&
mut
FreeNameTracker
{
match
self
{
Context
:
:
Global
(
context
)
=
>
&
mut
context
.
name_tracker
Context
:
:
Block
(
context
)
=
>
&
mut
context
.
name_tracker
}
}
}
#
[
derive
(
Debug
)
]
struct
ScopeKindStack
{
stack
:
Vec
<
ScopeKind
>
}
impl
ScopeKindStack
{
fn
new
(
)
-
>
Self
{
Self
{
stack
:
Vec
:
:
new
(
)
}
}
fn
innermost
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
ScopeKind
{
self
.
stack
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
}
fn
push
(
&
mut
self
kind
:
ScopeKind
)
{
self
.
stack
.
push
(
kind
)
}
fn
pop
(
&
mut
self
kind
:
ScopeKind
)
{
match
self
.
stack
.
pop
(
)
{
Some
(
k
)
if
k
=
=
kind
=
>
{
}
_
=
>
panic
!
(
"
unmatching
scope
kind
"
)
}
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
stack
.
len
(
)
=
=
0
}
}
#
[
derive
(
Debug
)
]
struct
ContextStack
{
stack
:
Vec
<
Context
>
}
impl
ContextStack
{
fn
new
(
)
-
>
Self
{
Self
{
stack
:
Vec
:
:
new
(
)
}
}
fn
innermost_var
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Context
{
for
context
in
self
.
stack
.
iter_mut
(
)
.
rev
(
)
{
match
context
{
Context
:
:
Global
(
_
)
=
>
return
context
_
=
>
{
}
}
}
panic
!
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
;
}
fn
innermost_lexical
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Context
{
self
.
stack
.
last_mut
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
}
fn
current_scope_index
(
&
self
)
-
>
ScopeIndex
{
self
.
stack
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
.
get_scope_index
(
)
}
fn
push_global
(
&
mut
self
context
:
GlobalContext
)
{
self
.
stack
.
push
(
Context
:
:
Global
(
context
)
)
}
fn
pop_global
(
&
mut
self
)
-
>
GlobalContext
{
match
self
.
pop
(
)
{
Context
:
:
Global
(
context
)
=
>
context
_
=
>
panic
!
(
"
unmatching
context
"
)
}
}
fn
push_block
(
&
mut
self
context
:
BlockContext
)
{
self
.
stack
.
push
(
Context
:
:
Block
(
context
)
)
}
fn
pop_block
(
&
mut
self
)
-
>
BlockContext
{
match
self
.
pop
(
)
{
Context
:
:
Block
(
context
)
=
>
context
_
=
>
panic
!
(
"
unmatching
context
"
)
}
}
fn
pop
(
&
mut
self
)
-
>
Context
{
let
inner
=
self
.
stack
.
pop
(
)
.
expect
(
"
unmatching
context
"
)
;
match
self
.
stack
.
last_mut
(
)
{
Some
(
outer
)
=
>
{
let
inner_tracker
=
inner
.
name_tracker
(
)
;
let
outer_tracker
=
outer
.
name_tracker_mut
(
)
;
match
inner
{
Context
:
:
Global
(
_
)
=
>
{
panic
!
(
"
Global
shouldn
'
t
be
enclosed
by
other
scope
"
)
;
}
Context
:
:
Block
(
_
)
=
>
{
outer_tracker
.
propagate_from_inner_non_script
(
inner_tracker
)
}
}
}
None
=
>
{
}
}
inner
}
}
#
[
derive
(
Debug
)
]
pub
struct
ScopeContext
{
scope_kind_stack
:
ScopeKindStack
context_stack
:
ContextStack
scopes
:
ScopeDataList
global
:
Option
<
ScopeIndex
>
non_global
:
AssociatedData
<
ScopeIndex
>
}
impl
ScopeContext
{
pub
fn
new
(
)
-
>
Self
{
Self
{
scope_kind_stack
:
ScopeKindStack
:
:
new
(
)
context_stack
:
ContextStack
:
:
new
(
)
scopes
:
ScopeDataList
:
:
new
(
)
global
:
None
non_global
:
AssociatedData
:
:
new
(
)
}
}
pub
fn
before_script
(
&
mut
self
)
{
let
index
=
self
.
scopes
.
allocate
(
)
;
let
context
=
GlobalContext
:
:
new
(
index
)
;
self
.
global
=
Some
(
index
)
;
self
.
context_stack
.
push_global
(
context
)
;
}
pub
fn
after_script
(
&
mut
self
)
{
let
mut
context
=
self
.
context_stack
.
pop_global
(
)
;
context
.
remove_function_names_from_var_names
(
)
;
self
.
scopes
.
populate
(
context
.
scope_index
context
.
into_scope_data
(
)
)
;
}
pub
fn
before_block_statement
<
T
>
(
&
mut
self
block
:
&
T
)
where
T
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
let
index
=
self
.
scopes
.
allocate
(
)
;
let
context
=
BlockContext
:
:
new
(
index
)
;
self
.
non_global
.
insert
(
block
index
)
;
self
.
context_stack
.
push_block
(
context
)
;
}
pub
fn
after_block_statement
(
&
mut
self
)
{
let
context
=
self
.
context_stack
.
pop_block
(
)
;
let
enclosing
=
self
.
context_stack
.
current_scope_index
(
)
;
self
.
scopes
.
populate
(
context
.
scope_index
context
.
into_scope_data
(
enclosing
)
)
;
}
pub
fn
before_var_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Var
)
;
}
pub
fn
after_var_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Var
)
;
}
pub
fn
before_let_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Let
)
;
}
pub
fn
after_let_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Let
)
;
}
pub
fn
before_const_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Const
)
;
}
pub
fn
after_const_declaration
(
&
mut
self
)
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Const
)
;
}
pub
fn
on_binding_identifier
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
if
self
.
scope_kind_stack
.
is_empty
(
)
{
return
;
}
match
self
.
scope_kind_stack
.
innermost
(
)
{
ScopeKind
:
:
Var
=
>
self
.
context_stack
.
innermost_var
(
)
.
declare_var
(
name
)
ScopeKind
:
:
Let
=
>
self
.
context_stack
.
innermost_lexical
(
)
.
declare_let
(
name
)
ScopeKind
:
:
Const
=
>
self
.
context_stack
.
innermost_lexical
(
)
.
declare_const
(
name
)
_
=
>
panic
!
(
"
Not
implemeneted
"
)
}
}
pub
fn
on_non_binding_identifier
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
self
.
context_stack
.
innermost_lexical
(
)
.
name_tracker_mut
(
)
.
note_use
(
name
)
;
}
pub
fn
before_function_declaration
(
&
mut
self
name
:
SourceAtomSetIndex
)
{
match
self
.
context_stack
.
innermost_lexical
(
)
{
Context
:
:
Global
(
ref
mut
context
)
=
>
context
.
declare_function
(
name
)
Context
:
:
Block
(
ref
mut
context
)
=
>
context
.
declare_function
(
name
)
}
}
}
impl
From
<
ScopeContext
>
for
ScopeDataMap
{
fn
from
(
context
:
ScopeContext
)
-
>
ScopeDataMap
{
ScopeDataMap
:
:
new
(
context
.
scopes
context
.
global
.
expect
(
"
There
should
be
global
scope
data
"
)
context
.
non_global
)
}
}
