use
ast
:
:
source_atom_set
:
:
SourceAtomSetIndex
;
use
std
:
:
collections
:
:
hash_map
:
:
RandomState
;
use
std
:
:
collections
:
:
hash_set
:
:
Difference
;
use
std
:
:
collections
:
:
HashSet
;
#
[
derive
(
Debug
)
]
pub
struct
FreeNameTracker
{
closed_over_names
:
HashSet
<
SourceAtomSetIndex
>
used_names
:
HashSet
<
SourceAtomSetIndex
>
def_names
:
HashSet
<
SourceAtomSetIndex
>
}
impl
FreeNameTracker
{
pub
fn
new
(
)
-
>
Self
{
Self
{
closed_over_names
:
HashSet
:
:
new
(
)
used_names
:
HashSet
:
:
new
(
)
def_names
:
HashSet
:
:
new
(
)
}
}
fn
note_closed_over
(
&
mut
self
atom
:
SourceAtomSetIndex
)
{
self
.
closed_over_names
.
insert
(
atom
)
;
}
pub
fn
note_use
(
&
mut
self
atom
:
SourceAtomSetIndex
)
{
self
.
used_names
.
insert
(
atom
)
;
}
pub
fn
note_def
(
&
mut
self
atom
:
SourceAtomSetIndex
)
{
self
.
def_names
.
insert
(
atom
)
;
}
fn
closed_over_freevars
(
&
self
)
-
>
Difference
<
'
_
SourceAtomSetIndex
RandomState
>
{
self
.
closed_over_names
.
difference
(
&
self
.
def_names
)
}
fn
used_freevars
(
&
self
)
-
>
Difference
<
'
_
SourceAtomSetIndex
RandomState
>
{
self
.
used_names
.
difference
(
&
self
.
def_names
)
}
pub
fn
is_closed_over_def
(
&
self
atom
:
&
SourceAtomSetIndex
)
-
>
bool
{
return
self
.
def_names
.
contains
(
atom
)
&
&
self
.
closed_over_names
.
contains
(
atom
)
;
}
pub
fn
propagate_from_inner_non_script
(
&
mut
self
inner
:
&
FreeNameTracker
)
{
for
atom
in
inner
.
closed_over_freevars
(
)
{
self
.
note_closed_over
(
*
atom
)
;
}
for
atom
in
inner
.
used_freevars
(
)
{
self
.
note_use
(
*
atom
)
;
}
}
#
[
allow
(
dead_code
)
]
pub
fn
propagate_from_inner_script
(
&
mut
self
inner
:
&
FreeNameTracker
)
{
for
atom
in
inner
.
closed_over_freevars
(
)
{
self
.
note_closed_over
(
*
atom
)
;
}
for
atom
in
inner
.
used_freevars
(
)
{
self
.
note_closed_over
(
*
atom
)
;
}
}
}
