use
core
:
:
num
:
:
Wrapping
as
w
;
use
{
Rng
SeedableRng
Rand
}
;
#
[
allow
(
missing_copy_implementations
)
]
#
[
derive
(
Clone
Debug
)
]
pub
struct
XorShiftRng
{
x
:
w
<
u32
>
y
:
w
<
u32
>
z
:
w
<
u32
>
w
:
w
<
u32
>
}
impl
XorShiftRng
{
pub
fn
new_unseeded
(
)
-
>
XorShiftRng
{
XorShiftRng
{
x
:
w
(
0x193a6754
)
y
:
w
(
0xa8a7d469
)
z
:
w
(
0x97830e05
)
w
:
w
(
0x113ba7bb
)
}
}
}
impl
Rng
for
XorShiftRng
{
#
[
inline
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
let
x
=
self
.
x
;
let
t
=
x
^
(
x
<
<
11
)
;
self
.
x
=
self
.
y
;
self
.
y
=
self
.
z
;
self
.
z
=
self
.
w
;
let
w_
=
self
.
w
;
self
.
w
=
w_
^
(
w_
>
>
19
)
^
(
t
^
(
t
>
>
8
)
)
;
self
.
w
.
0
}
}
impl
SeedableRng
<
[
u32
;
4
]
>
for
XorShiftRng
{
fn
reseed
(
&
mut
self
seed
:
[
u32
;
4
]
)
{
assert
!
(
!
seed
.
iter
(
)
.
all
(
|
&
x
|
x
=
=
0
)
"
XorShiftRng
.
reseed
called
with
an
all
zero
seed
.
"
)
;
self
.
x
=
w
(
seed
[
0
]
)
;
self
.
y
=
w
(
seed
[
1
]
)
;
self
.
z
=
w
(
seed
[
2
]
)
;
self
.
w
=
w
(
seed
[
3
]
)
;
}
fn
from_seed
(
seed
:
[
u32
;
4
]
)
-
>
XorShiftRng
{
assert
!
(
!
seed
.
iter
(
)
.
all
(
|
&
x
|
x
=
=
0
)
"
XorShiftRng
:
:
from_seed
called
with
an
all
zero
seed
.
"
)
;
XorShiftRng
{
x
:
w
(
seed
[
0
]
)
y
:
w
(
seed
[
1
]
)
z
:
w
(
seed
[
2
]
)
w
:
w
(
seed
[
3
]
)
}
}
}
impl
Rand
for
XorShiftRng
{
fn
rand
<
R
:
Rng
>
(
rng
:
&
mut
R
)
-
>
XorShiftRng
{
let
mut
tuple
:
(
u32
u32
u32
u32
)
=
rng
.
gen
(
)
;
while
tuple
=
=
(
0
0
0
0
)
{
tuple
=
rng
.
gen
(
)
;
}
let
(
x
y
z
w_
)
=
tuple
;
XorShiftRng
{
x
:
w
(
x
)
y
:
w
(
y
)
z
:
w
(
z
)
w
:
w
(
w_
)
}
}
}
