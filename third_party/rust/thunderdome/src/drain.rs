use
std
:
:
iter
:
:
{
ExactSizeIterator
FusedIterator
}
;
use
crate
:
:
arena
:
:
{
Arena
Index
}
;
pub
struct
Drain
<
'
a
T
>
{
pub
(
crate
)
arena
:
&
'
a
mut
Arena
<
T
>
pub
(
crate
)
slot
:
u32
}
impl
<
'
a
T
>
Iterator
for
Drain
<
'
a
T
>
{
type
Item
=
(
Index
T
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
loop
{
if
self
.
arena
.
is_empty
(
)
{
return
None
;
}
let
slot
=
self
.
slot
;
self
.
slot
=
self
.
slot
.
checked_add
(
1
)
.
unwrap_or_else
(
|
|
panic
!
(
"
Overflowed
u32
trying
to
drain
Arena
"
)
)
;
if
let
Some
(
(
index
value
)
)
=
self
.
arena
.
remove_entry_by_slot
(
slot
)
{
return
Some
(
(
index
value
)
)
;
}
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
(
self
.
arena
.
len
(
)
Some
(
self
.
arena
.
len
(
)
)
)
}
}
impl
<
'
a
T
>
FusedIterator
for
Drain
<
'
a
T
>
{
}
impl
<
'
a
T
>
ExactSizeIterator
for
Drain
<
'
a
T
>
{
}
impl
<
'
a
T
>
Drop
for
Drain
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
for_each
(
drop
)
;
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
crate
:
:
Arena
;
use
std
:
:
collections
:
:
HashSet
;
#
[
test
]
fn
drain
(
)
{
let
mut
arena
=
Arena
:
:
with_capacity
(
2
)
;
let
one
=
arena
.
insert
(
1
)
;
let
two
=
arena
.
insert
(
2
)
;
let
mut
drained_pairs
=
HashSet
:
:
new
(
)
;
{
let
mut
drain
=
arena
.
drain
(
)
;
assert_eq
!
(
drain
.
size_hint
(
)
(
2
Some
(
2
)
)
)
;
drained_pairs
.
insert
(
drain
.
next
(
)
.
unwrap
(
)
)
;
assert_eq
!
(
drain
.
size_hint
(
)
(
1
Some
(
1
)
)
)
;
assert_eq
!
(
drain
.
size_hint
(
)
(
1
Some
(
1
)
)
)
;
}
assert_eq
!
(
arena
.
len
(
)
0
)
;
assert_eq
!
(
arena
.
capacity
(
)
2
)
;
assert_eq
!
(
drained_pairs
.
len
(
)
1
)
;
let
one_prime
=
arena
.
insert
(
1
)
;
let
two_prime
=
arena
.
insert
(
2
)
;
assert_eq
!
(
arena
.
len
(
)
2
)
;
assert_eq
!
(
arena
.
capacity
(
)
2
)
;
assert_eq
!
(
arena
.
get
(
one_prime
)
Some
(
&
1
)
)
;
assert_eq
!
(
arena
.
get
(
two_prime
)
Some
(
&
2
)
)
;
assert_eq
!
(
arena
.
get
(
one
)
None
)
;
assert_eq
!
(
arena
.
get
(
two
)
None
)
;
}
}
