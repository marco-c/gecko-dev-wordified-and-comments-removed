use
std
:
:
convert
:
:
TryInto
;
use
std
:
:
mem
:
:
replace
;
use
std
:
:
ops
;
use
crate
:
:
drain
:
:
Drain
;
use
crate
:
:
free_pointer
:
:
FreePointer
;
use
crate
:
:
generation
:
:
Generation
;
use
crate
:
:
into_iter
:
:
IntoIter
;
use
crate
:
:
iter
:
:
Iter
;
use
crate
:
:
iter_mut
:
:
IterMut
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
Arena
<
T
>
{
storage
:
Vec
<
Entry
<
T
>
>
len
:
u32
first_free
:
Option
<
FreePointer
>
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
struct
Index
{
pub
(
crate
)
slot
:
u32
pub
(
crate
)
generation
:
Generation
}
impl
Index
{
#
[
allow
(
clippy
:
:
integer_arithmetic
)
]
pub
fn
to_bits
(
self
)
-
>
u64
{
(
(
self
.
generation
.
to_u32
(
)
as
u64
)
<
<
32
)
|
(
self
.
slot
as
u64
)
}
#
[
allow
(
clippy
:
:
integer_arithmetic
)
]
pub
fn
from_bits
(
bits
:
u64
)
-
>
Self
{
let
generation
=
Generation
:
:
from_u32
(
(
bits
>
>
32
)
as
u32
)
;
let
slot
=
bits
as
u32
;
Self
{
generation
slot
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
(
crate
)
enum
Entry
<
T
>
{
Occupied
(
OccupiedEntry
<
T
>
)
Empty
(
EmptyEntry
)
}
impl
<
T
>
Entry
<
T
>
{
fn
into_value
(
self
)
-
>
Option
<
T
>
{
match
self
{
Entry
:
:
Occupied
(
occupied
)
=
>
Some
(
occupied
.
value
)
Entry
:
:
Empty
(
_
)
=
>
None
}
}
fn
get_empty
(
&
self
)
-
>
Option
<
EmptyEntry
>
{
match
self
{
Entry
:
:
Empty
(
empty
)
=
>
Some
(
*
empty
)
Entry
:
:
Occupied
(
_
)
=
>
None
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
(
crate
)
struct
OccupiedEntry
<
T
>
{
pub
(
crate
)
generation
:
Generation
pub
(
crate
)
value
:
T
}
#
[
derive
(
Debug
Clone
Copy
)
]
pub
(
crate
)
struct
EmptyEntry
{
pub
(
crate
)
generation
:
Generation
pub
(
crate
)
next_free
:
Option
<
FreePointer
>
}
impl
<
T
>
Arena
<
T
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
storage
:
Vec
:
:
new
(
)
len
:
0
first_free
:
None
}
}
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
Self
{
Self
{
storage
:
Vec
:
:
with_capacity
(
capacity
)
len
:
0
first_free
:
None
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
len
as
usize
}
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
storage
.
capacity
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
=
=
0
}
pub
fn
insert
(
&
mut
self
value
:
T
)
-
>
Index
{
self
.
len
=
self
.
len
.
checked_add
(
1
)
.
unwrap_or_else
(
|
|
panic
!
(
"
Cannot
insert
more
than
u32
:
:
MAX
elements
into
Arena
"
)
)
;
if
let
Some
(
free_pointer
)
=
self
.
first_free
{
let
slot
=
free_pointer
.
slot
(
)
;
let
entry
=
self
.
storage
.
get_mut
(
slot
as
usize
)
.
unwrap_or_else
(
|
|
{
unreachable
!
(
"
first_free
pointed
past
the
end
of
the
arena
'
s
storage
"
)
}
)
;
let
empty
=
entry
.
get_empty
(
)
.
unwrap_or_else
(
|
|
unreachable
!
(
"
first_free
pointed
to
an
occupied
entry
"
)
)
;
self
.
first_free
=
empty
.
next_free
;
let
generation
=
empty
.
generation
.
next
(
)
;
*
entry
=
Entry
:
:
Occupied
(
OccupiedEntry
{
generation
value
}
)
;
Index
{
slot
generation
}
}
else
{
let
generation
=
Generation
:
:
first
(
)
;
let
slot
:
u32
=
self
.
storage
.
len
(
)
.
try_into
(
)
.
unwrap_or_else
(
|
_
|
{
unreachable
!
(
"
Arena
storage
exceeded
what
can
be
represented
by
a
u32
"
)
}
)
;
self
.
storage
.
push
(
Entry
:
:
Occupied
(
OccupiedEntry
{
generation
value
}
)
)
;
Index
{
slot
generation
}
}
}
pub
fn
get
(
&
self
index
:
Index
)
-
>
Option
<
&
T
>
{
match
self
.
storage
.
get
(
index
.
slot
as
usize
)
{
Some
(
Entry
:
:
Occupied
(
occupied
)
)
if
occupied
.
generation
=
=
index
.
generation
=
>
{
Some
(
&
occupied
.
value
)
}
_
=
>
None
}
}
pub
fn
get_mut
(
&
mut
self
index
:
Index
)
-
>
Option
<
&
mut
T
>
{
match
self
.
storage
.
get_mut
(
index
.
slot
as
usize
)
{
Some
(
Entry
:
:
Occupied
(
occupied
)
)
if
occupied
.
generation
=
=
index
.
generation
=
>
{
Some
(
&
mut
occupied
.
value
)
}
_
=
>
None
}
}
pub
fn
remove
(
&
mut
self
index
:
Index
)
-
>
Option
<
T
>
{
let
entry
=
self
.
storage
.
get_mut
(
index
.
slot
as
usize
)
?
;
match
entry
{
Entry
:
:
Occupied
(
occupied
)
if
occupied
.
generation
=
=
index
.
generation
=
>
{
let
new_entry
=
Entry
:
:
Empty
(
EmptyEntry
{
generation
:
occupied
.
generation
next_free
:
self
.
first_free
}
)
;
let
old_entry
=
replace
(
entry
new_entry
)
;
let
value
=
old_entry
.
into_value
(
)
.
unwrap_or_else
(
|
|
unreachable
!
(
)
)
;
self
.
first_free
=
Some
(
FreePointer
:
:
from_slot
(
index
.
slot
)
)
;
self
.
len
=
self
.
len
.
checked_sub
(
1
)
.
unwrap_or_else
(
|
|
unreachable
!
(
)
)
;
Some
(
value
)
}
_
=
>
None
}
}
pub
fn
invalidate
(
&
mut
self
index
:
Index
)
-
>
Option
<
Index
>
{
let
entry
=
self
.
storage
.
get_mut
(
index
.
slot
as
usize
)
?
;
match
entry
{
Entry
:
:
Occupied
(
occupied
)
if
occupied
.
generation
=
=
index
.
generation
=
>
{
occupied
.
generation
=
occupied
.
generation
.
next
(
)
;
Some
(
Index
{
generation
:
occupied
.
generation
.
.
index
}
)
}
_
=
>
None
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
drain
(
)
.
for_each
(
drop
)
;
}
pub
fn
iter
(
&
self
)
-
>
Iter
<
'
_
T
>
{
Iter
{
inner
:
self
.
storage
.
iter
(
)
.
enumerate
(
)
len
:
self
.
len
}
}
pub
fn
iter_mut
(
&
mut
self
)
-
>
IterMut
<
'
_
T
>
{
IterMut
{
inner
:
self
.
storage
.
iter_mut
(
)
.
enumerate
(
)
len
:
self
.
len
}
}
pub
fn
drain
(
&
mut
self
)
-
>
Drain
<
'
_
T
>
{
Drain
{
arena
:
self
slot
:
0
}
}
}
impl
<
T
>
Arena
<
T
>
{
pub
(
crate
)
fn
remove_entry_by_slot
(
&
mut
self
slot
:
u32
)
-
>
Option
<
(
Index
T
)
>
{
let
entry
=
self
.
storage
.
get_mut
(
slot
as
usize
)
?
;
match
entry
{
Entry
:
:
Occupied
(
occupied
)
=
>
{
let
index
=
Index
{
generation
:
occupied
.
generation
slot
}
;
let
next_entry
=
Entry
:
:
Empty
(
EmptyEntry
{
generation
:
occupied
.
generation
next_free
:
self
.
first_free
}
)
;
let
old_entry
=
replace
(
entry
next_entry
)
;
let
value
=
old_entry
.
into_value
(
)
.
unwrap_or_else
(
|
|
unreachable
!
(
)
)
;
self
.
first_free
=
Some
(
FreePointer
:
:
from_slot
(
slot
)
)
;
self
.
len
=
self
.
len
.
checked_sub
(
1
)
.
unwrap_or_else
(
|
|
unreachable
!
(
)
)
;
Some
(
(
index
value
)
)
}
_
=
>
None
}
}
}
impl
<
T
>
Default
for
Arena
<
T
>
{
fn
default
(
)
-
>
Self
{
Arena
:
:
new
(
)
}
}
impl
<
T
>
IntoIterator
for
Arena
<
T
>
{
type
Item
=
(
Index
T
)
;
type
IntoIter
=
IntoIter
<
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
IntoIter
{
arena
:
self
slot
:
0
}
}
}
impl
<
T
>
ops
:
:
Index
<
Index
>
for
Arena
<
T
>
{
type
Output
=
T
;
fn
index
(
&
self
index
:
Index
)
-
>
&
Self
:
:
Output
{
self
.
get
(
index
)
.
unwrap_or_else
(
|
|
panic
!
(
"
No
entry
at
index
{
:
?
}
"
index
)
)
}
}
impl
<
T
>
ops
:
:
IndexMut
<
Index
>
for
Arena
<
T
>
{
fn
index_mut
(
&
mut
self
index
:
Index
)
-
>
&
mut
Self
:
:
Output
{
self
.
get_mut
(
index
)
.
unwrap_or_else
(
|
|
panic
!
(
"
No
entry
at
index
{
:
?
}
"
index
)
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
{
Arena
Index
}
;
use
std
:
:
mem
:
:
size_of
;
#
[
test
]
fn
size_of_index
(
)
{
assert_eq
!
(
size_of
:
:
<
Index
>
(
)
8
)
;
assert_eq
!
(
size_of
:
:
<
Option
<
Index
>
>
(
)
8
)
;
}
#
[
test
]
fn
new
(
)
{
let
arena
:
Arena
<
u32
>
=
Arena
:
:
new
(
)
;
assert_eq
!
(
arena
.
len
(
)
0
)
;
assert_eq
!
(
arena
.
capacity
(
)
0
)
;
}
#
[
test
]
fn
with_capacity
(
)
{
let
arena
:
Arena
<
u32
>
=
Arena
:
:
with_capacity
(
8
)
;
assert_eq
!
(
arena
.
len
(
)
0
)
;
assert_eq
!
(
arena
.
capacity
(
)
8
)
;
}
#
[
test
]
fn
insert_and_get
(
)
{
let
mut
arena
=
Arena
:
:
new
(
)
;
let
one
=
arena
.
insert
(
1
)
;
assert_eq
!
(
arena
.
len
(
)
1
)
;
assert_eq
!
(
arena
.
get
(
one
)
Some
(
&
1
)
)
;
let
two
=
arena
.
insert
(
2
)
;
assert_eq
!
(
arena
.
len
(
)
2
)
;
assert_eq
!
(
arena
.
get
(
one
)
Some
(
&
1
)
)
;
assert_eq
!
(
arena
.
get
(
two
)
Some
(
&
2
)
)
;
}
#
[
test
]
fn
insert_remove_get
(
)
{
let
mut
arena
=
Arena
:
:
new
(
)
;
let
one
=
arena
.
insert
(
1
)
;
let
two
=
arena
.
insert
(
2
)
;
assert_eq
!
(
arena
.
len
(
)
2
)
;
assert_eq
!
(
arena
.
remove
(
two
)
Some
(
2
)
)
;
let
three
=
arena
.
insert
(
3
)
;
assert_eq
!
(
arena
.
len
(
)
2
)
;
assert_eq
!
(
arena
.
get
(
one
)
Some
(
&
1
)
)
;
assert_eq
!
(
arena
.
get
(
three
)
Some
(
&
3
)
)
;
assert_eq
!
(
arena
.
get
(
two
)
None
)
;
}
#
[
test
]
fn
get_mut
(
)
{
let
mut
arena
=
Arena
:
:
new
(
)
;
let
foo
=
arena
.
insert
(
5
)
;
let
handle
=
arena
.
get_mut
(
foo
)
.
unwrap
(
)
;
*
handle
=
6
;
assert_eq
!
(
arena
.
get
(
foo
)
Some
(
&
6
)
)
;
}
#
[
test
]
fn
insert_remove_insert_capacity
(
)
{
let
mut
arena
=
Arena
:
:
with_capacity
(
2
)
;
assert_eq
!
(
arena
.
capacity
(
)
2
)
;
let
a
=
arena
.
insert
(
"
a
"
)
;
let
b
=
arena
.
insert
(
"
b
"
)
;
assert_eq
!
(
arena
.
len
(
)
2
)
;
assert_eq
!
(
arena
.
capacity
(
)
2
)
;
arena
.
remove
(
a
)
;
arena
.
remove
(
b
)
;
assert_eq
!
(
arena
.
len
(
)
0
)
;
assert_eq
!
(
arena
.
capacity
(
)
2
)
;
let
_a2
=
arena
.
insert
(
"
a2
"
)
;
let
_b2
=
arena
.
insert
(
"
b2
"
)
;
assert_eq
!
(
arena
.
len
(
)
2
)
;
assert_eq
!
(
arena
.
capacity
(
)
2
)
;
}
#
[
test
]
fn
invalidate
(
)
{
let
mut
arena
=
Arena
:
:
new
(
)
;
let
a
=
arena
.
insert
(
"
a
"
)
;
assert_eq
!
(
arena
.
get
(
a
)
Some
(
&
"
a
"
)
)
;
let
new_a
=
arena
.
invalidate
(
a
)
.
unwrap
(
)
;
assert_eq
!
(
arena
.
get
(
a
)
None
)
;
assert_eq
!
(
arena
.
get
(
new_a
)
Some
(
&
"
a
"
)
)
;
}
#
[
test
]
fn
index_bits_roundtrip
(
)
{
let
index
=
Index
:
:
from_bits
(
0x1BADCAFE_DEADBEEF
)
;
assert_eq
!
(
index
.
to_bits
(
)
0x1BADCAFE_DEADBEEF
)
;
}
#
[
test
]
#
[
should_panic
]
fn
index_bits_panic_on_zero_generation
(
)
{
Index
:
:
from_bits
(
0x00000000_DEADBEEF
)
;
}
}
