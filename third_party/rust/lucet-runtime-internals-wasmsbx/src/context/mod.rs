#
!
[
allow
(
improper_ctypes
)
]
#
[
cfg
(
test
)
]
mod
tests
;
use
crate
:
:
val
:
:
{
val_to_reg
val_to_stack
RegVal
UntypedRetVal
Val
}
;
use
failure
:
:
Fail
;
use
nix
;
use
nix
:
:
sys
:
:
signal
;
use
std
:
:
arch
:
:
x86_64
:
:
{
__m128
_mm_setzero_ps
}
;
use
std
:
:
mem
;
use
std
:
:
ptr
:
:
NonNull
;
use
xfailure
:
:
xbail
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
)
]
struct
GpRegs
{
rbx
:
u64
rsp
:
u64
rbp
:
u64
rdi
:
u64
r12
:
u64
r13
:
u64
r14
:
u64
r15
:
u64
}
impl
GpRegs
{
fn
new
(
)
-
>
Self
{
GpRegs
{
rbx
:
0
rsp
:
0
rbp
:
0
rdi
:
0
r12
:
0
r13
:
0
r14
:
0
r15
:
0
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
)
]
struct
FpRegs
{
xmm0
:
__m128
xmm1
:
__m128
xmm2
:
__m128
xmm3
:
__m128
xmm4
:
__m128
xmm5
:
__m128
xmm6
:
__m128
xmm7
:
__m128
}
impl
FpRegs
{
fn
new
(
)
-
>
Self
{
let
zero
=
unsafe
{
_mm_setzero_ps
(
)
}
;
FpRegs
{
xmm0
:
zero
xmm1
:
zero
xmm2
:
zero
xmm3
:
zero
xmm4
:
zero
xmm5
:
zero
xmm6
:
zero
xmm7
:
zero
}
}
}
#
[
repr
(
C
align
(
64
)
)
]
#
[
derive
(
Clone
)
]
pub
struct
Context
{
gpr
:
GpRegs
fpr
:
FpRegs
retvals_gp
:
[
u64
;
2
]
retval_fp
:
__m128
sigset
:
signal
:
:
SigSet
}
impl
Context
{
pub
fn
new
(
)
-
>
Self
{
Context
{
gpr
:
GpRegs
:
:
new
(
)
fpr
:
FpRegs
:
:
new
(
)
retvals_gp
:
[
0
;
2
]
retval_fp
:
unsafe
{
_mm_setzero_ps
(
)
}
sigset
:
signal
:
:
SigSet
:
:
empty
(
)
}
}
}
#
[
repr
(
C
)
]
pub
struct
ContextHandle
{
internal
:
NonNull
<
Context
>
}
impl
Drop
for
ContextHandle
{
fn
drop
(
&
mut
self
)
{
unsafe
{
Box
:
:
from_raw
(
self
.
internal
.
as_ptr
(
)
)
;
}
}
}
impl
std
:
:
ops
:
:
Deref
for
ContextHandle
{
type
Target
=
Context
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
unsafe
{
self
.
internal
.
as_ref
(
)
}
}
}
impl
std
:
:
ops
:
:
DerefMut
for
ContextHandle
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
unsafe
{
self
.
internal
.
as_mut
(
)
}
}
}
impl
ContextHandle
{
pub
fn
new
(
)
-
>
Self
{
let
internal
=
NonNull
:
:
new
(
Box
:
:
into_raw
(
Box
:
:
new
(
Context
:
:
new
(
)
)
)
)
.
expect
(
"
Box
:
:
into_raw
should
never
return
NULL
"
)
;
ContextHandle
{
internal
}
}
pub
fn
create_and_init
(
stack
:
&
mut
[
u64
]
parent
:
&
mut
ContextHandle
fptr
:
usize
args
:
&
[
Val
]
)
-
>
Result
<
ContextHandle
Error
>
{
let
mut
child
=
ContextHandle
:
:
new
(
)
;
Context
:
:
init
(
stack
parent
&
mut
child
fptr
args
)
?
;
Ok
(
child
)
}
}
impl
Context
{
pub
fn
init
(
stack
:
&
mut
[
u64
]
parent
:
&
mut
Context
child
:
&
mut
Context
fptr
:
usize
args
:
&
[
Val
]
)
-
>
Result
<
(
)
Error
>
{
if
!
stack_is_aligned
(
stack
)
{
xbail
!
(
Error
:
:
UnalignedStack
)
;
}
let
mut
gp_args_ix
=
0
;
let
mut
fp_args_ix
=
0
;
let
mut
spilled_args
=
vec
!
[
]
;
for
arg
in
args
{
match
val_to_reg
(
arg
)
{
RegVal
:
:
GpReg
(
v
)
=
>
{
if
gp_args_ix
>
=
6
{
spilled_args
.
push
(
arg
)
;
}
else
{
child
.
bootstrap_gp_ix_arg
(
gp_args_ix
v
)
;
gp_args_ix
+
=
1
;
}
}
RegVal
:
:
FpReg
(
v
)
=
>
{
if
fp_args_ix
>
=
8
{
spilled_args
.
push
(
arg
)
;
}
else
{
child
.
bootstrap_fp_ix_arg
(
fp_args_ix
v
)
;
fp_args_ix
+
=
1
;
}
}
}
}
let
sp
=
stack
.
len
(
)
;
let
stack_start
=
3
+
spilled_args
.
len
(
)
+
spilled_args
.
len
(
)
%
2
+
4
;
let
mut
stack_args_ix
=
3
;
for
arg
in
spilled_args
{
let
v
=
val_to_stack
(
arg
)
;
stack
[
sp
+
stack_args_ix
-
stack_start
]
=
v
;
stack_args_ix
+
=
1
;
}
stack
[
sp
+
0
-
stack_start
]
=
lucet_context_bootstrap
as
u64
;
stack
[
sp
+
1
-
stack_start
]
=
fptr
as
u64
;
stack
[
sp
+
2
-
stack_start
]
=
lucet_context_backstop
as
u64
;
stack
[
sp
-
4
]
=
child
as
*
mut
Context
as
u64
;
stack
[
sp
-
3
]
=
parent
as
*
mut
Context
as
u64
;
stack
[
sp
-
2
]
=
0
;
stack
[
sp
-
1
]
=
0
;
child
.
gpr
.
rsp
=
&
mut
stack
[
sp
-
stack_start
]
as
*
mut
u64
as
u64
;
child
.
gpr
.
rbp
=
&
mut
stack
[
sp
-
2
]
as
*
mut
u64
as
u64
;
signal
:
:
sigprocmask
(
signal
:
:
SigmaskHow
:
:
SIG_SETMASK
None
Some
(
&
mut
child
.
sigset
)
)
.
expect
(
"
sigprocmask
could
not
be
retrieved
"
)
;
Ok
(
(
)
)
}
#
[
inline
]
pub
unsafe
fn
swap
(
from
:
&
mut
Context
to
:
&
Context
)
{
lucet_context_swap
(
from
as
*
mut
Context
to
as
*
const
Context
)
;
}
#
[
inline
]
pub
unsafe
fn
set
(
to
:
&
Context
)
-
>
!
{
lucet_context_set
(
to
as
*
const
Context
)
;
}
#
[
inline
]
pub
unsafe
fn
get_current_stack_pointer
(
)
-
>
u64
{
return
lucet_get_current_stack_pointer
(
)
;
}
#
[
inline
]
pub
unsafe
fn
set_from_signal
(
to
:
&
Context
)
-
>
Result
<
(
)
nix
:
:
Error
>
{
signal
:
:
sigprocmask
(
signal
:
:
SigmaskHow
:
:
SIG_SETMASK
Some
(
&
to
.
sigset
)
None
)
?
;
Context
:
:
set
(
to
)
}
pub
fn
clear_retvals
(
&
mut
self
)
{
self
.
retvals_gp
=
[
0
;
2
]
;
let
zero
=
unsafe
{
_mm_setzero_ps
(
)
}
;
self
.
retval_fp
=
zero
;
}
pub
fn
get_retval_gp
(
&
self
idx
:
usize
)
-
>
u64
{
self
.
retvals_gp
[
idx
]
}
pub
fn
get_retval_fp
(
&
self
)
-
>
__m128
{
self
.
retval_fp
}
pub
fn
get_untyped_retval
(
&
self
)
-
>
UntypedRetVal
{
let
gp
=
self
.
get_retval_gp
(
0
)
;
let
fp
=
self
.
get_retval_fp
(
)
;
UntypedRetVal
:
:
new
(
gp
fp
)
}
fn
bootstrap_gp_ix_arg
(
&
mut
self
ix
:
usize
arg
:
u64
)
{
match
ix
{
0
=
>
self
.
gpr
.
rdi
=
arg
1
=
>
self
.
gpr
.
r12
=
arg
2
=
>
self
.
gpr
.
r13
=
arg
3
=
>
self
.
gpr
.
r14
=
arg
4
=
>
self
.
gpr
.
r15
=
arg
5
=
>
self
.
gpr
.
rbx
=
arg
_
=
>
panic
!
(
"
unexpected
gp
register
index
{
}
"
ix
)
}
}
fn
bootstrap_fp_ix_arg
(
&
mut
self
ix
:
usize
arg
:
__m128
)
{
match
ix
{
0
=
>
self
.
fpr
.
xmm0
=
arg
1
=
>
self
.
fpr
.
xmm1
=
arg
2
=
>
self
.
fpr
.
xmm2
=
arg
3
=
>
self
.
fpr
.
xmm3
=
arg
4
=
>
self
.
fpr
.
xmm4
=
arg
5
=
>
self
.
fpr
.
xmm5
=
arg
6
=
>
self
.
fpr
.
xmm6
=
arg
7
=
>
self
.
fpr
.
xmm7
=
arg
_
=
>
panic
!
(
"
unexpected
fp
register
index
{
}
"
ix
)
}
}
}
#
[
derive
(
Debug
Fail
)
]
pub
enum
Error
{
#
[
fail
(
display
=
"
context
initialized
with
unaligned
stack
"
)
]
UnalignedStack
}
fn
stack_is_aligned
(
stack
:
&
[
u64
]
)
-
>
bool
{
let
size
=
stack
.
len
(
)
;
let
last_elt_addr
=
&
stack
[
size
-
1
]
as
*
const
u64
as
usize
;
let
bottom_addr
=
last_elt_addr
+
mem
:
:
size_of
:
:
<
u64
>
(
)
;
bottom_addr
%
16
=
=
0
}
extern
"
C
"
{
fn
lucet_context_bootstrap
(
)
;
fn
lucet_context_backstop
(
)
;
fn
lucet_context_swap
(
from
:
*
mut
Context
to
:
*
const
Context
)
;
fn
lucet_context_set
(
to
:
*
const
Context
)
-
>
!
;
fn
lucet_get_current_stack_pointer
(
)
-
>
u64
;
}
