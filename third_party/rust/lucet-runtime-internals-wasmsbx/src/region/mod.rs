pub
mod
mmap
;
use
crate
:
:
alloc
:
:
{
Alloc
Limits
Slot
}
;
use
crate
:
:
embed_ctx
:
:
CtxMap
;
use
crate
:
:
error
:
:
Error
;
use
crate
:
:
instance
:
:
InstanceHandle
;
use
crate
:
:
module
:
:
Module
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
sync
:
:
Arc
;
pub
trait
Region
:
RegionInternal
{
fn
new_instance
(
&
self
module
:
Arc
<
dyn
Module
>
)
-
>
Result
<
InstanceHandle
Error
>
{
self
.
new_instance_builder
(
module
)
.
build
(
)
}
fn
new_instance_builder
<
'
a
>
(
&
'
a
self
module
:
Arc
<
dyn
Module
>
)
-
>
InstanceBuilder
<
'
a
>
{
InstanceBuilder
:
:
new
(
self
.
as_dyn_internal
(
)
module
)
}
}
pub
trait
RegionInternal
:
Send
+
Sync
{
fn
new_instance_with
(
&
self
module
:
Arc
<
dyn
Module
>
embed_ctx
:
CtxMap
)
-
>
Result
<
InstanceHandle
Error
>
;
fn
drop_alloc
(
&
self
alloc
:
&
mut
Alloc
)
;
fn
expand_heap
(
&
self
slot
:
&
Slot
start
:
u32
len
:
u32
)
-
>
Result
<
(
)
Error
>
;
fn
reset_heap
(
&
self
alloc
:
&
mut
Alloc
module
:
&
dyn
Module
)
-
>
Result
<
(
)
Error
>
;
fn
as_dyn_internal
(
&
self
)
-
>
&
dyn
RegionInternal
;
}
pub
trait
RegionCreate
:
Region
{
const
TYPE_NAME
:
&
'
static
str
;
fn
create
(
instance_capacity
:
usize
limits
:
&
Limits
)
-
>
Result
<
Arc
<
Self
>
Error
>
;
}
pub
struct
InstanceBuilder
<
'
a
>
{
region
:
&
'
a
dyn
RegionInternal
module
:
Arc
<
dyn
Module
>
embed_ctx
:
CtxMap
}
impl
<
'
a
>
InstanceBuilder
<
'
a
>
{
fn
new
(
region
:
&
'
a
dyn
RegionInternal
module
:
Arc
<
dyn
Module
>
)
-
>
Self
{
InstanceBuilder
{
region
module
embed_ctx
:
CtxMap
:
:
new
(
)
}
}
pub
fn
with_embed_ctx
<
T
:
Any
>
(
mut
self
ctx
:
T
)
-
>
Self
{
self
.
embed_ctx
.
insert
(
ctx
)
;
self
}
pub
fn
build
(
self
)
-
>
Result
<
InstanceHandle
Error
>
{
self
.
region
.
new_instance_with
(
self
.
module
self
.
embed_ctx
)
}
}
