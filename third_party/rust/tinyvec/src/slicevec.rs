#
!
[
allow
(
unused_variables
)
]
#
!
[
allow
(
missing_docs
)
]
use
super
:
:
*
;
pub
struct
SliceVec
<
'
s
T
>
{
data
:
&
'
s
mut
[
T
]
len
:
usize
}
impl
<
'
s
T
>
Default
for
SliceVec
<
'
s
T
>
{
#
[
inline
(
always
)
]
#
[
must_use
]
fn
default
(
)
-
>
Self
{
Self
{
data
:
&
mut
[
]
len
:
0
}
}
}
impl
<
'
s
T
>
Deref
for
SliceVec
<
'
s
T
>
{
type
Target
=
[
T
]
;
#
[
inline
(
always
)
]
#
[
must_use
]
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
data
[
.
.
self
.
len
]
}
}
impl
<
'
s
T
>
DerefMut
for
SliceVec
<
'
s
T
>
{
#
[
inline
(
always
)
]
#
[
must_use
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
data
[
.
.
self
.
len
]
}
}
impl
<
'
s
T
I
>
Index
<
I
>
for
SliceVec
<
'
s
T
>
where
I
:
SliceIndex
<
[
T
]
>
{
type
Output
=
<
I
as
SliceIndex
<
[
T
]
>
>
:
:
Output
;
#
[
inline
(
always
)
]
#
[
must_use
]
fn
index
(
&
self
index
:
I
)
-
>
&
Self
:
:
Output
{
&
self
.
deref
(
)
[
index
]
}
}
impl
<
'
s
T
I
>
IndexMut
<
I
>
for
SliceVec
<
'
s
T
>
where
I
:
SliceIndex
<
[
T
]
>
{
#
[
inline
(
always
)
]
#
[
must_use
]
fn
index_mut
(
&
mut
self
index
:
I
)
-
>
&
mut
Self
:
:
Output
{
&
mut
self
.
deref_mut
(
)
[
index
]
}
}
impl
<
'
s
T
>
SliceVec
<
'
s
T
>
{
#
[
inline
]
pub
fn
append
(
&
mut
self
other
:
&
mut
Self
)
where
T
:
Default
{
for
item
in
other
.
drain
(
.
.
)
{
self
.
push
(
item
)
}
}
#
[
inline
(
always
)
]
#
[
must_use
]
pub
fn
as_mut_ptr
(
&
mut
self
)
-
>
*
mut
T
{
self
.
data
.
as_mut_ptr
(
)
}
#
[
inline
(
always
)
]
#
[
must_use
]
pub
fn
as_mut_slice
(
&
mut
self
)
-
>
&
mut
[
T
]
{
self
.
deref_mut
(
)
}
#
[
inline
(
always
)
]
#
[
must_use
]
pub
fn
as_ptr
(
&
self
)
-
>
*
const
T
{
self
.
data
.
as_ptr
(
)
}
#
[
inline
(
always
)
]
#
[
must_use
]
pub
fn
as_slice
(
&
self
)
-
>
&
[
T
]
{
self
.
deref
(
)
}
#
[
inline
(
always
)
]
#
[
must_use
]
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
data
.
len
(
)
}
#
[
inline
(
always
)
]
pub
fn
clear
(
&
mut
self
)
where
T
:
Default
{
self
.
truncate
(
0
)
}
#
[
inline
]
pub
fn
drain
<
'
p
R
:
RangeBounds
<
usize
>
>
(
&
'
p
mut
self
range
:
R
)
-
>
SliceVecDrain
<
'
p
'
s
T
>
where
T
:
Default
{
use
core
:
:
ops
:
:
Bound
;
let
start
=
match
range
.
start_bound
(
)
{
Bound
:
:
Included
(
x
)
=
>
*
x
Bound
:
:
Excluded
(
x
)
=
>
x
.
saturating_add
(
1
)
Bound
:
:
Unbounded
=
>
0
}
;
let
end
=
match
range
.
end_bound
(
)
{
Bound
:
:
Included
(
x
)
=
>
x
.
saturating_add
(
1
)
Bound
:
:
Excluded
(
x
)
=
>
*
x
Bound
:
:
Unbounded
=
>
self
.
len
}
;
assert
!
(
start
<
=
end
"
SliceVec
:
:
drain
>
Illegal
range
{
}
to
{
}
"
start
end
)
;
assert
!
(
end
<
=
self
.
len
"
SliceVec
:
:
drain
>
Range
ends
at
{
}
but
length
is
only
{
}
!
"
end
self
.
len
)
;
SliceVecDrain
{
parent
:
self
target_start
:
start
target_index
:
start
target_end
:
end
}
}
#
[
inline
]
pub
fn
extend_from_slice
(
&
mut
self
sli
:
&
[
T
]
)
where
T
:
Clone
{
if
sli
.
is_empty
(
)
{
return
;
}
let
new_len
=
self
.
len
+
sli
.
len
(
)
;
if
new_len
>
self
.
capacity
(
)
{
panic
!
(
"
SliceVec
:
:
extend_from_slice
>
total
length
{
}
exceeds
capacity
{
}
"
new_len
self
.
capacity
(
)
)
}
let
target
=
&
mut
self
.
data
[
self
.
len
.
.
new_len
]
;
target
.
clone_from_slice
(
sli
)
;
self
.
set_len
(
new_len
)
;
}
#
[
inline
]
pub
fn
fill
<
I
:
IntoIterator
<
Item
=
T
>
>
(
&
mut
self
iter
:
I
)
-
>
I
:
:
IntoIter
{
let
mut
iter
=
iter
.
into_iter
(
)
;
for
element
in
iter
.
by_ref
(
)
.
take
(
self
.
capacity
(
)
-
self
.
len
(
)
)
{
self
.
push
(
element
)
;
}
iter
}
#
[
inline
]
#
[
must_use
]
#
[
allow
(
clippy
:
:
match_wild_err_arm
)
]
pub
fn
from_slice_len
(
data
:
&
'
s
mut
[
T
]
len
:
usize
)
-
>
Self
{
assert
!
(
len
<
=
data
.
len
(
)
)
;
Self
{
data
len
}
}
#
[
inline
]
pub
fn
insert
(
&
mut
self
index
:
usize
item
:
T
)
{
if
index
>
self
.
len
{
panic
!
(
"
SliceVec
:
:
insert
>
index
{
}
is
out
of
bounds
{
}
"
index
self
.
len
)
;
}
self
.
push
(
item
)
;
self
.
as_mut_slice
(
)
[
index
.
.
]
.
rotate_right
(
1
)
;
}
#
[
inline
(
always
)
]
#
[
must_use
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
=
=
0
}
#
[
inline
(
always
)
]
#
[
must_use
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
len
}
#
[
inline
]
pub
fn
pop
(
&
mut
self
)
-
>
Option
<
T
>
where
T
:
Default
{
if
self
.
len
>
0
{
self
.
len
-
=
1
;
let
out
=
core
:
:
mem
:
:
take
(
&
mut
self
.
data
[
self
.
len
]
)
;
Some
(
out
)
}
else
{
None
}
}
#
[
inline
(
always
)
]
pub
fn
push
(
&
mut
self
val
:
T
)
{
if
self
.
len
<
self
.
capacity
(
)
{
self
.
data
[
self
.
len
]
=
val
;
self
.
len
+
=
1
;
}
else
{
panic
!
(
"
SliceVec
:
:
push
>
capacity
overflow
"
)
}
}
#
[
inline
]
pub
fn
remove
(
&
mut
self
index
:
usize
)
-
>
T
where
T
:
Default
{
let
targets
:
&
mut
[
T
]
=
&
mut
self
.
deref_mut
(
)
[
index
.
.
]
;
let
item
=
core
:
:
mem
:
:
take
(
&
mut
targets
[
0
]
)
;
targets
.
rotate_left
(
1
)
;
self
.
len
-
=
1
;
item
}
#
[
inline
]
pub
fn
resize
(
&
mut
self
new_len
:
usize
new_val
:
T
)
where
T
:
Clone
{
self
.
resize_with
(
new_len
|
|
new_val
.
clone
(
)
)
}
#
[
inline
]
pub
fn
resize_with
<
F
:
FnMut
(
)
-
>
T
>
(
&
mut
self
new_len
:
usize
mut
f
:
F
)
{
match
new_len
.
checked_sub
(
self
.
len
)
{
None
=
>
{
if
needs_drop
:
:
<
T
>
(
)
{
while
self
.
len
(
)
>
new_len
{
self
.
len
-
=
1
;
self
.
data
[
self
.
len
]
=
f
(
)
;
}
}
else
{
self
.
len
=
new_len
;
}
}
Some
(
new_elements
)
=
>
{
for
_
in
0
.
.
new_elements
{
self
.
push
(
f
(
)
)
;
}
}
}
}
#
[
inline
]
pub
fn
retain
<
F
:
FnMut
(
&
T
)
-
>
bool
>
(
&
mut
self
mut
acceptable
:
F
)
where
T
:
Default
{
struct
JoinOnDrop
<
'
vec
Item
>
{
items
:
&
'
vec
mut
[
Item
]
done_end
:
usize
tail_start
:
usize
}
impl
<
Item
>
Drop
for
JoinOnDrop
<
'
_
Item
>
{
fn
drop
(
&
mut
self
)
{
self
.
items
[
self
.
done_end
.
.
]
.
rotate_left
(
self
.
tail_start
)
;
}
}
let
mut
rest
=
JoinOnDrop
{
items
:
self
.
data
done_end
:
0
tail_start
:
0
}
;
for
idx
in
0
.
.
self
.
len
{
if
!
acceptable
(
&
rest
.
items
[
idx
]
)
{
let
_
=
core
:
:
mem
:
:
take
(
&
mut
rest
.
items
[
idx
]
)
;
self
.
len
-
=
1
;
rest
.
tail_start
+
=
1
;
}
else
{
rest
.
items
.
swap
(
rest
.
done_end
idx
)
;
rest
.
done_end
+
=
1
;
}
}
}
#
[
inline
(
always
)
]
pub
fn
set_len
(
&
mut
self
new_len
:
usize
)
{
if
new_len
>
self
.
capacity
(
)
{
panic
!
(
"
SliceVec
:
:
set_len
>
new
length
{
}
exceeds
capacity
{
}
"
new_len
self
.
capacity
(
)
)
}
else
{
self
.
len
=
new_len
;
}
}
#
[
inline
]
pub
fn
split_off
<
'
a
>
(
&
'
a
mut
self
at
:
usize
)
-
>
SliceVec
<
'
s
T
>
{
let
mut
new
=
Self
:
:
default
(
)
;
let
backing
:
&
'
s
mut
[
T
]
=
core
:
:
mem
:
:
take
(
&
mut
self
.
data
)
;
let
(
me
other
)
=
backing
.
split_at_mut
(
at
)
;
new
.
len
=
self
.
len
-
at
;
new
.
data
=
other
;
self
.
len
=
me
.
len
(
)
;
self
.
data
=
me
;
new
}
#
[
inline
]
pub
fn
swap_remove
(
&
mut
self
index
:
usize
)
-
>
T
where
T
:
Default
{
assert
!
(
index
<
self
.
len
"
SliceVec
:
:
swap_remove
>
index
{
}
is
out
of
bounds
{
}
"
index
self
.
len
)
;
if
index
=
=
self
.
len
-
1
{
self
.
pop
(
)
.
unwrap
(
)
}
else
{
let
i
=
self
.
pop
(
)
.
unwrap
(
)
;
replace
(
&
mut
self
[
index
]
i
)
}
}
#
[
inline
]
pub
fn
truncate
(
&
mut
self
new_len
:
usize
)
where
T
:
Default
{
if
needs_drop
:
:
<
T
>
(
)
{
while
self
.
len
>
new_len
{
self
.
pop
(
)
;
}
}
else
{
self
.
len
=
self
.
len
.
min
(
new_len
)
;
}
}
#
[
inline
]
pub
fn
try_from_slice_len
(
data
:
&
'
s
mut
[
T
]
len
:
usize
)
-
>
Option
<
Self
>
{
if
len
<
=
data
.
len
(
)
{
Some
(
Self
{
data
len
}
)
}
else
{
None
}
}
}
#
[
cfg
(
feature
=
"
grab_spare_slice
"
)
]
impl
<
'
s
T
>
SliceVec
<
'
s
T
>
{
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
grab_spare_slice
(
&
self
)
-
>
&
[
T
]
{
&
self
.
data
[
self
.
len
.
.
]
}
#
[
inline
(
always
)
]
pub
fn
grab_spare_slice_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
{
&
mut
self
.
data
[
self
.
len
.
.
]
}
}
impl
<
'
s
T
>
From
<
&
'
s
mut
[
T
]
>
for
SliceVec
<
'
s
T
>
{
#
[
inline
]
fn
from
(
data
:
&
'
s
mut
[
T
]
)
-
>
Self
{
let
len
=
data
.
len
(
)
;
Self
{
data
len
}
}
}
impl
<
'
s
T
A
>
From
<
&
'
s
mut
A
>
for
SliceVec
<
'
s
T
>
where
A
:
AsMut
<
[
T
]
>
{
#
[
inline
]
fn
from
(
a
:
&
'
s
mut
A
)
-
>
Self
{
let
data
=
a
.
as_mut
(
)
;
let
len
=
data
.
len
(
)
;
Self
{
data
len
}
}
}
pub
struct
SliceVecDrain
<
'
p
'
s
T
:
Default
>
{
parent
:
&
'
p
mut
SliceVec
<
'
s
T
>
target_start
:
usize
target_index
:
usize
target_end
:
usize
}
impl
<
'
p
'
s
T
:
Default
>
Iterator
for
SliceVecDrain
<
'
p
'
s
T
>
{
type
Item
=
T
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
target_index
!
=
self
.
target_end
{
let
out
=
core
:
:
mem
:
:
take
(
&
mut
self
.
parent
[
self
.
target_index
]
)
;
self
.
target_index
+
=
1
;
Some
(
out
)
}
else
{
None
}
}
}
impl
<
'
p
'
s
T
:
Default
>
FusedIterator
for
SliceVecDrain
<
'
p
'
s
T
>
{
}
impl
<
'
p
'
s
T
:
Default
>
Drop
for
SliceVecDrain
<
'
p
'
s
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
self
.
for_each
(
drop
)
;
let
count
=
self
.
target_end
-
self
.
target_start
;
let
targets
:
&
mut
[
T
]
=
&
mut
self
.
parent
.
deref_mut
(
)
[
self
.
target_start
.
.
]
;
targets
.
rotate_left
(
count
)
;
self
.
parent
.
len
-
=
count
;
}
}
impl
<
'
s
T
>
AsMut
<
[
T
]
>
for
SliceVec
<
'
s
T
>
{
#
[
inline
(
always
)
]
#
[
must_use
]
fn
as_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
{
&
mut
*
self
}
}
impl
<
'
s
T
>
AsRef
<
[
T
]
>
for
SliceVec
<
'
s
T
>
{
#
[
inline
(
always
)
]
#
[
must_use
]
fn
as_ref
(
&
self
)
-
>
&
[
T
]
{
&
*
self
}
}
impl
<
'
s
T
>
Borrow
<
[
T
]
>
for
SliceVec
<
'
s
T
>
{
#
[
inline
(
always
)
]
#
[
must_use
]
fn
borrow
(
&
self
)
-
>
&
[
T
]
{
&
*
self
}
}
impl
<
'
s
T
>
BorrowMut
<
[
T
]
>
for
SliceVec
<
'
s
T
>
{
#
[
inline
(
always
)
]
#
[
must_use
]
fn
borrow_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
{
&
mut
*
self
}
}
impl
<
'
s
T
>
Extend
<
T
>
for
SliceVec
<
'
s
T
>
{
#
[
inline
]
fn
extend
<
I
:
IntoIterator
<
Item
=
T
>
>
(
&
mut
self
iter
:
I
)
{
for
t
in
iter
{
self
.
push
(
t
)
}
}
}
impl
<
'
s
T
>
IntoIterator
for
SliceVec
<
'
s
T
>
{
type
Item
=
&
'
s
mut
T
;
type
IntoIter
=
core
:
:
slice
:
:
IterMut
<
'
s
T
>
;
#
[
inline
(
always
)
]
#
[
must_use
]
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
data
.
iter_mut
(
)
}
}
impl
<
'
s
T
>
PartialEq
for
SliceVec
<
'
s
T
>
where
T
:
PartialEq
{
#
[
inline
]
#
[
must_use
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
as_slice
(
)
.
eq
(
other
.
as_slice
(
)
)
}
}
impl
<
'
s
T
>
Eq
for
SliceVec
<
'
s
T
>
where
T
:
Eq
{
}
impl
<
'
s
T
>
PartialOrd
for
SliceVec
<
'
s
T
>
where
T
:
PartialOrd
{
#
[
inline
]
#
[
must_use
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
core
:
:
cmp
:
:
Ordering
>
{
self
.
as_slice
(
)
.
partial_cmp
(
other
.
as_slice
(
)
)
}
}
impl
<
'
s
T
>
Ord
for
SliceVec
<
'
s
T
>
where
T
:
Ord
{
#
[
inline
]
#
[
must_use
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
core
:
:
cmp
:
:
Ordering
{
self
.
as_slice
(
)
.
cmp
(
other
.
as_slice
(
)
)
}
}
impl
<
'
s
T
>
PartialEq
<
&
[
T
]
>
for
SliceVec
<
'
s
T
>
where
T
:
PartialEq
{
#
[
inline
]
#
[
must_use
]
fn
eq
(
&
self
other
:
&
&
[
T
]
)
-
>
bool
{
self
.
as_slice
(
)
.
eq
(
*
other
)
}
}
impl
<
'
s
T
>
Hash
for
SliceVec
<
'
s
T
>
where
T
:
Hash
{
#
[
inline
]
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
as_slice
(
)
.
hash
(
state
)
}
}
#
[
cfg
(
feature
=
"
experimental_write_impl
"
)
]
impl
<
'
s
>
core
:
:
fmt
:
:
Write
for
SliceVec
<
'
s
u8
>
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
core
:
:
fmt
:
:
Result
{
let
my_len
=
self
.
len
(
)
;
let
str_len
=
s
.
as_bytes
(
)
.
len
(
)
;
if
my_len
+
str_len
<
=
self
.
capacity
(
)
{
let
remainder
=
&
mut
self
.
data
[
my_len
.
.
]
;
let
target
=
&
mut
remainder
[
.
.
str_len
]
;
target
.
copy_from_slice
(
s
.
as_bytes
(
)
)
;
Ok
(
(
)
)
}
else
{
Err
(
core
:
:
fmt
:
:
Error
)
}
}
}
impl
<
'
s
T
>
Binary
for
SliceVec
<
'
s
T
>
where
T
:
Binary
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
[
"
)
?
;
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
for
(
i
elem
)
in
self
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
write
!
(
f
"
{
}
"
if
f
.
alternate
(
)
{
"
\
n
"
}
else
{
"
"
}
)
?
;
}
Binary
:
:
fmt
(
elem
f
)
?
;
}
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
write
!
(
f
"
]
"
)
}
}
impl
<
'
s
T
>
Debug
for
SliceVec
<
'
s
T
>
where
T
:
Debug
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
[
"
)
?
;
if
f
.
alternate
(
)
&
&
!
self
.
is_empty
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
for
(
i
elem
)
in
self
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
write
!
(
f
"
{
}
"
if
f
.
alternate
(
)
{
"
\
n
"
}
else
{
"
"
}
)
?
;
}
Debug
:
:
fmt
(
elem
f
)
?
;
}
if
f
.
alternate
(
)
&
&
!
self
.
is_empty
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
write
!
(
f
"
]
"
)
}
}
impl
<
'
s
T
>
Display
for
SliceVec
<
'
s
T
>
where
T
:
Display
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
[
"
)
?
;
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
for
(
i
elem
)
in
self
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
write
!
(
f
"
{
}
"
if
f
.
alternate
(
)
{
"
\
n
"
}
else
{
"
"
}
)
?
;
}
Display
:
:
fmt
(
elem
f
)
?
;
}
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
write
!
(
f
"
]
"
)
}
}
impl
<
'
s
T
>
LowerExp
for
SliceVec
<
'
s
T
>
where
T
:
LowerExp
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
[
"
)
?
;
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
for
(
i
elem
)
in
self
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
write
!
(
f
"
{
}
"
if
f
.
alternate
(
)
{
"
\
n
"
}
else
{
"
"
}
)
?
;
}
LowerExp
:
:
fmt
(
elem
f
)
?
;
}
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
write
!
(
f
"
]
"
)
}
}
impl
<
'
s
T
>
LowerHex
for
SliceVec
<
'
s
T
>
where
T
:
LowerHex
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
[
"
)
?
;
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
for
(
i
elem
)
in
self
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
write
!
(
f
"
{
}
"
if
f
.
alternate
(
)
{
"
\
n
"
}
else
{
"
"
}
)
?
;
}
LowerHex
:
:
fmt
(
elem
f
)
?
;
}
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
write
!
(
f
"
]
"
)
}
}
impl
<
'
s
T
>
Octal
for
SliceVec
<
'
s
T
>
where
T
:
Octal
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
[
"
)
?
;
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
for
(
i
elem
)
in
self
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
write
!
(
f
"
{
}
"
if
f
.
alternate
(
)
{
"
\
n
"
}
else
{
"
"
}
)
?
;
}
Octal
:
:
fmt
(
elem
f
)
?
;
}
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
write
!
(
f
"
]
"
)
}
}
impl
<
'
s
T
>
Pointer
for
SliceVec
<
'
s
T
>
where
T
:
Pointer
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
[
"
)
?
;
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
for
(
i
elem
)
in
self
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
write
!
(
f
"
{
}
"
if
f
.
alternate
(
)
{
"
\
n
"
}
else
{
"
"
}
)
?
;
}
Pointer
:
:
fmt
(
elem
f
)
?
;
}
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
write
!
(
f
"
]
"
)
}
}
impl
<
'
s
T
>
UpperExp
for
SliceVec
<
'
s
T
>
where
T
:
UpperExp
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
[
"
)
?
;
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
for
(
i
elem
)
in
self
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
write
!
(
f
"
{
}
"
if
f
.
alternate
(
)
{
"
\
n
"
}
else
{
"
"
}
)
?
;
}
UpperExp
:
:
fmt
(
elem
f
)
?
;
}
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
write
!
(
f
"
]
"
)
}
}
impl
<
'
s
T
>
UpperHex
for
SliceVec
<
'
s
T
>
where
T
:
UpperHex
{
#
[
allow
(
clippy
:
:
missing_inline_in_public_items
)
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
[
"
)
?
;
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
for
(
i
elem
)
in
self
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
write
!
(
f
"
{
}
"
if
f
.
alternate
(
)
{
"
\
n
"
}
else
{
"
"
}
)
?
;
}
UpperHex
:
:
fmt
(
elem
f
)
?
;
}
if
f
.
alternate
(
)
{
write
!
(
f
"
\
n
"
)
?
;
}
write
!
(
f
"
]
"
)
}
}
