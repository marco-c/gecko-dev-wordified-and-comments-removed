#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
phf_codegen
/
0
.
7
"
)
]
extern
crate
phf_shared
;
extern
crate
phf_generator
;
use
phf_shared
:
:
PhfHash
;
use
std
:
:
collections
:
:
HashSet
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
io
;
use
std
:
:
io
:
:
prelude
:
:
*
;
pub
struct
Map
<
K
>
{
keys
:
Vec
<
K
>
values
:
Vec
<
String
>
path
:
String
}
impl
<
K
:
Hash
+
PhfHash
+
Eq
+
fmt
:
:
Debug
>
Map
<
K
>
{
pub
fn
new
(
)
-
>
Map
<
K
>
{
fn
noop_fix_for_27438
(
)
{
}
noop_fix_for_27438
(
)
;
Map
{
keys
:
vec
!
[
]
values
:
vec
!
[
]
path
:
String
:
:
from
(
"
:
:
phf
"
)
}
}
pub
fn
phf_path
(
&
mut
self
path
:
&
str
)
-
>
&
mut
Map
<
K
>
{
self
.
path
=
path
.
to_owned
(
)
;
self
}
pub
fn
entry
(
&
mut
self
key
:
K
value
:
&
str
)
-
>
&
mut
Map
<
K
>
{
self
.
keys
.
push
(
key
)
;
self
.
values
.
push
(
value
.
to_owned
(
)
)
;
self
}
pub
fn
build
<
W
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
set
=
HashSet
:
:
new
(
)
;
for
key
in
&
self
.
keys
{
if
!
set
.
insert
(
key
)
{
panic
!
(
"
duplicate
key
{
:
?
}
"
key
)
;
}
}
let
state
=
phf_generator
:
:
generate_hash
(
&
self
.
keys
)
;
try
!
(
write
!
(
w
"
{
}
:
:
Map
{
{
key
:
{
}
disps
:
{
}
:
:
Slice
:
:
Static
(
&
[
"
self
.
path
state
.
key
self
.
path
)
)
;
for
&
(
d1
d2
)
in
&
state
.
disps
{
try
!
(
write
!
(
w
"
(
{
}
{
}
)
"
d1
d2
)
)
;
}
try
!
(
write
!
(
w
"
]
)
entries
:
{
}
:
:
Slice
:
:
Static
(
&
[
"
self
.
path
)
)
;
for
&
idx
in
&
state
.
map
{
try
!
(
write
!
(
w
"
(
{
:
?
}
{
}
)
"
&
self
.
keys
[
idx
]
&
self
.
values
[
idx
]
)
)
;
}
write
!
(
w
"
]
)
}
}
"
)
}
}
pub
struct
Set
<
T
>
{
map
:
Map
<
T
>
}
impl
<
T
:
Hash
+
PhfHash
+
Eq
+
fmt
:
:
Debug
>
Set
<
T
>
{
pub
fn
new
(
)
-
>
Set
<
T
>
{
Set
{
map
:
Map
:
:
new
(
)
}
}
pub
fn
phf_path
(
&
mut
self
path
:
&
str
)
-
>
&
mut
Set
<
T
>
{
self
.
map
.
phf_path
(
path
)
;
self
}
pub
fn
entry
(
&
mut
self
entry
:
T
)
-
>
&
mut
Set
<
T
>
{
self
.
map
.
entry
(
entry
"
(
)
"
)
;
self
}
pub
fn
build
<
W
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
try
!
(
write
!
(
w
"
{
}
:
:
Set
{
{
map
:
"
self
.
map
.
path
)
)
;
try
!
(
self
.
map
.
build
(
w
)
)
;
write
!
(
w
"
}
}
"
)
}
}
pub
struct
OrderedMap
<
K
>
{
keys
:
Vec
<
K
>
values
:
Vec
<
String
>
path
:
String
}
impl
<
K
:
Hash
+
PhfHash
+
Eq
+
fmt
:
:
Debug
>
OrderedMap
<
K
>
{
pub
fn
new
(
)
-
>
OrderedMap
<
K
>
{
OrderedMap
{
keys
:
vec
!
[
]
values
:
vec
!
[
]
path
:
String
:
:
from
(
"
:
:
phf
"
)
}
}
pub
fn
phf_path
(
&
mut
self
path
:
&
str
)
-
>
&
mut
OrderedMap
<
K
>
{
self
.
path
=
path
.
to_owned
(
)
;
self
}
pub
fn
entry
(
&
mut
self
key
:
K
value
:
&
str
)
-
>
&
mut
OrderedMap
<
K
>
{
self
.
keys
.
push
(
key
)
;
self
.
values
.
push
(
value
.
to_owned
(
)
)
;
self
}
pub
fn
build
<
W
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
set
=
HashSet
:
:
new
(
)
;
for
key
in
&
self
.
keys
{
if
!
set
.
insert
(
key
)
{
panic
!
(
"
duplicate
key
{
:
?
}
"
key
)
;
}
}
let
state
=
phf_generator
:
:
generate_hash
(
&
self
.
keys
)
;
try
!
(
write
!
(
w
"
{
}
:
:
OrderedMap
{
{
key
:
{
}
disps
:
{
}
:
:
Slice
:
:
Static
(
&
[
"
self
.
path
state
.
key
self
.
path
)
)
;
for
&
(
d1
d2
)
in
&
state
.
disps
{
try
!
(
write
!
(
w
"
(
{
}
{
}
)
"
d1
d2
)
)
;
}
try
!
(
write
!
(
w
"
]
)
idxs
:
{
}
:
:
Slice
:
:
Static
(
&
[
"
self
.
path
)
)
;
for
&
idx
in
&
state
.
map
{
try
!
(
write
!
(
w
"
{
}
"
idx
)
)
;
}
try
!
(
write
!
(
w
"
]
)
entries
:
{
}
:
:
Slice
:
:
Static
(
&
[
"
self
.
path
)
)
;
for
(
key
value
)
in
self
.
keys
.
iter
(
)
.
zip
(
self
.
values
.
iter
(
)
)
{
try
!
(
write
!
(
w
"
(
{
:
?
}
{
}
)
"
key
value
)
)
;
}
write
!
(
w
"
]
)
}
}
"
)
}
}
pub
struct
OrderedSet
<
T
>
{
map
:
OrderedMap
<
T
>
}
impl
<
T
:
Hash
+
PhfHash
+
Eq
+
fmt
:
:
Debug
>
OrderedSet
<
T
>
{
pub
fn
new
(
)
-
>
OrderedSet
<
T
>
{
OrderedSet
{
map
:
OrderedMap
:
:
new
(
)
}
}
pub
fn
phf_path
(
&
mut
self
path
:
&
str
)
-
>
&
mut
OrderedSet
<
T
>
{
self
.
map
.
phf_path
(
path
)
;
self
}
pub
fn
entry
(
&
mut
self
entry
:
T
)
-
>
&
mut
OrderedSet
<
T
>
{
self
.
map
.
entry
(
entry
"
(
)
"
)
;
self
}
pub
fn
build
<
W
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
try
!
(
write
!
(
w
"
{
}
:
:
OrderedSet
{
{
map
:
"
self
.
map
.
path
)
)
;
try
!
(
self
.
map
.
build
(
w
)
)
;
write
!
(
w
"
}
}
"
)
}
}
