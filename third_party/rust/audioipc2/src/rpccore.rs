use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
io
:
:
{
self
Result
}
;
use
std
:
:
mem
:
:
ManuallyDrop
;
use
std
:
:
sync
:
:
{
Arc
Mutex
Weak
}
;
use
crossbeam_channel
:
:
{
self
Receiver
Sender
}
;
use
mio
:
:
Token
;
use
slab
:
:
Slab
;
use
crate
:
:
ipccore
:
:
EventLoopHandle
;
pub
(
crate
)
trait
Handler
{
type
In
;
type
Out
;
fn
consume
(
&
mut
self
request
:
Self
:
:
In
)
-
>
Result
<
(
)
>
;
fn
produce
(
&
mut
self
)
-
>
Result
<
Option
<
Self
:
:
Out
>
>
;
}
pub
trait
Client
{
type
ServerMessage
;
type
ClientMessage
;
}
pub
trait
Server
{
type
ServerMessage
;
type
ClientMessage
;
fn
process
(
&
mut
self
req
:
Self
:
:
ServerMessage
)
-
>
Self
:
:
ClientMessage
;
}
type
ProxyKey
=
usize
;
type
ProxyRequest
<
Request
>
=
(
ProxyKey
Request
)
;
#
[
derive
(
Debug
)
]
pub
struct
Proxy
<
Request
Response
>
{
handle
:
Option
<
(
EventLoopHandle
Token
)
>
key
:
ProxyKey
response_rx
:
Receiver
<
Response
>
handler_tx
:
ManuallyDrop
<
Sender
<
ProxyRequest
<
Request
>
>
>
proxy_mgr
:
Weak
<
ProxyManager
<
Response
>
>
}
impl
<
Request
Response
>
Proxy
<
Request
Response
>
{
fn
new
(
handler_tx
:
Sender
<
ProxyRequest
<
Request
>
>
proxy_mgr
:
Weak
<
ProxyManager
<
Response
>
>
)
-
>
Self
{
let
(
tx
rx
)
=
crossbeam_channel
:
:
bounded
(
1
)
;
Self
{
handle
:
None
key
:
proxy_mgr
.
upgrade
(
)
.
unwrap
(
)
.
register_proxy
(
tx
)
response_rx
:
rx
handler_tx
:
ManuallyDrop
:
:
new
(
handler_tx
)
proxy_mgr
}
}
pub
fn
call
(
&
self
request
:
Request
)
-
>
Result
<
Response
>
{
match
self
.
handler_tx
.
send
(
(
self
.
key
request
)
)
{
Ok
(
_
)
=
>
self
.
wake_connection
(
)
Err
(
_
)
=
>
{
return
Err
(
std
:
:
io
:
:
Error
:
:
new
(
std
:
:
io
:
:
ErrorKind
:
:
Other
"
proxy
send
error
"
)
)
}
}
match
self
.
response_rx
.
recv
(
)
{
Ok
(
resp
)
=
>
Ok
(
resp
)
Err
(
_
)
=
>
Err
(
std
:
:
io
:
:
Error
:
:
new
(
std
:
:
io
:
:
ErrorKind
:
:
Other
"
proxy
recv
error
"
)
)
}
}
pub
(
crate
)
fn
connect_event_loop
(
&
mut
self
handle
:
EventLoopHandle
token
:
Token
)
{
self
.
handle
=
Some
(
(
handle
token
)
)
;
}
fn
wake_connection
(
&
self
)
{
let
(
handle
token
)
=
self
.
handle
.
as_ref
(
)
.
expect
(
"
proxy
not
connected
to
event
loop
"
)
;
handle
.
wake_connection
(
*
token
)
;
}
}
impl
<
Request
Response
>
Clone
for
Proxy
<
Request
Response
>
{
fn
clone
(
&
self
)
-
>
Self
{
let
(
tx
rx
)
=
crossbeam_channel
:
:
bounded
(
1
)
;
Self
{
handle
:
self
.
handle
.
clone
(
)
key
:
self
.
proxy_mgr
.
upgrade
(
)
.
unwrap
(
)
.
register_proxy
(
tx
)
response_rx
:
rx
handler_tx
:
self
.
handler_tx
.
clone
(
)
proxy_mgr
:
self
.
proxy_mgr
.
clone
(
)
}
}
}
impl
<
Request
Response
>
Drop
for
Proxy
<
Request
Response
>
{
fn
drop
(
&
mut
self
)
{
trace
!
(
"
Proxy
drop
waking
EventLoop
"
)
;
if
let
Some
(
mgr
)
=
self
.
proxy_mgr
.
upgrade
(
)
{
mgr
.
unregister_proxy
(
self
.
key
)
}
unsafe
{
ManuallyDrop
:
:
drop
(
&
mut
self
.
handler_tx
)
;
}
if
self
.
handle
.
is_some
(
)
{
self
.
wake_connection
(
)
}
}
}
const
RPC_CLIENT_INITIAL_PROXIES
:
usize
=
32
;
#
[
derive
(
Debug
)
]
struct
ProxyManager
<
Response
>
{
proxies
:
Mutex
<
Slab
<
Sender
<
Response
>
>
>
}
impl
<
Response
>
ProxyManager
<
Response
>
{
fn
new
(
)
-
>
Self
{
Self
{
proxies
:
Mutex
:
:
new
(
Slab
:
:
with_capacity
(
RPC_CLIENT_INITIAL_PROXIES
)
)
}
}
fn
register_proxy
(
&
self
tx
:
Sender
<
Response
>
)
-
>
ProxyKey
{
let
mut
proxies
=
self
.
proxies
.
lock
(
)
.
unwrap
(
)
;
let
entry
=
proxies
.
vacant_entry
(
)
;
let
key
=
entry
.
key
(
)
;
entry
.
insert
(
tx
)
;
key
}
fn
unregister_proxy
(
&
self
key
:
ProxyKey
)
{
let
_
=
self
.
proxies
.
lock
(
)
.
unwrap
(
)
.
remove
(
key
)
;
}
fn
deliver
(
&
self
key
:
ProxyKey
resp
:
Response
)
{
let
_
=
self
.
proxies
.
lock
(
)
.
unwrap
(
)
[
key
]
.
send
(
resp
)
;
}
}
pub
(
crate
)
struct
ClientHandler
<
C
:
Client
>
{
messages
:
Receiver
<
ProxyRequest
<
C
:
:
ServerMessage
>
>
proxies
:
Arc
<
ProxyManager
<
C
:
:
ClientMessage
>
>
in_flight
:
VecDeque
<
ProxyKey
>
}
impl
<
C
:
Client
>
ClientHandler
<
C
>
{
fn
new
(
rx
:
Receiver
<
ProxyRequest
<
C
:
:
ServerMessage
>
>
)
-
>
ClientHandler
<
C
>
{
ClientHandler
:
:
<
C
>
{
messages
:
rx
proxies
:
Arc
:
:
new
(
ProxyManager
:
:
new
(
)
)
in_flight
:
VecDeque
:
:
with_capacity
(
RPC_CLIENT_INITIAL_PROXIES
)
}
}
fn
proxy_manager
(
&
self
)
-
>
Weak
<
ProxyManager
<
<
C
as
Client
>
:
:
ClientMessage
>
>
{
Arc
:
:
downgrade
(
&
self
.
proxies
)
}
}
impl
<
C
:
Client
>
Handler
for
ClientHandler
<
C
>
{
type
In
=
C
:
:
ClientMessage
;
type
Out
=
C
:
:
ServerMessage
;
fn
consume
(
&
mut
self
response
:
Self
:
:
In
)
-
>
Result
<
(
)
>
{
trace
!
(
"
ClientHandler
:
:
consume
"
)
;
if
let
Some
(
proxy
)
=
self
.
in_flight
.
pop_front
(
)
{
self
.
proxies
.
deliver
(
proxy
response
)
;
}
else
{
return
Err
(
std
:
:
io
:
:
Error
:
:
new
(
std
:
:
io
:
:
ErrorKind
:
:
Other
"
request
/
response
mismatch
"
)
)
;
}
Ok
(
(
)
)
}
fn
produce
(
&
mut
self
)
-
>
Result
<
Option
<
Self
:
:
Out
>
>
{
trace
!
(
"
ClientHandler
:
:
produce
"
)
;
match
self
.
messages
.
try_recv
(
)
{
Ok
(
(
proxy
request
)
)
=
>
{
trace
!
(
"
-
-
>
received
request
"
)
;
self
.
in_flight
.
push_back
(
proxy
)
;
Ok
(
Some
(
request
)
)
}
Err
(
crossbeam_channel
:
:
TryRecvError
:
:
Empty
)
=
>
{
trace
!
(
"
-
-
>
no
request
"
)
;
Ok
(
None
)
}
Err
(
e
)
=
>
{
trace
!
(
"
-
-
>
client
disconnected
"
)
;
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
ConnectionAborted
e
)
)
}
}
}
}
pub
(
crate
)
fn
make_client
<
C
:
Client
>
(
)
-
>
(
ClientHandler
<
C
>
Proxy
<
C
:
:
ServerMessage
C
:
:
ClientMessage
>
)
{
let
(
tx
rx
)
=
crossbeam_channel
:
:
bounded
(
RPC_CLIENT_INITIAL_PROXIES
)
;
let
handler
=
ClientHandler
:
:
new
(
rx
)
;
let
proxy_mgr
=
handler
.
proxy_manager
(
)
;
(
handler
Proxy
:
:
new
(
tx
proxy_mgr
)
)
}
pub
(
crate
)
struct
ServerHandler
<
S
:
Server
>
{
server
:
S
in_flight
:
VecDeque
<
S
:
:
ClientMessage
>
}
impl
<
S
:
Server
>
Handler
for
ServerHandler
<
S
>
{
type
In
=
S
:
:
ServerMessage
;
type
Out
=
S
:
:
ClientMessage
;
fn
consume
(
&
mut
self
message
:
Self
:
:
In
)
-
>
Result
<
(
)
>
{
trace
!
(
"
ServerHandler
:
:
consume
"
)
;
let
response
=
self
.
server
.
process
(
message
)
;
self
.
in_flight
.
push_back
(
response
)
;
Ok
(
(
)
)
}
fn
produce
(
&
mut
self
)
-
>
Result
<
Option
<
Self
:
:
Out
>
>
{
trace
!
(
"
ServerHandler
:
:
produce
"
)
;
match
self
.
in_flight
.
pop_front
(
)
{
Some
(
res
)
=
>
{
trace
!
(
"
-
-
>
received
response
"
)
;
Ok
(
Some
(
res
)
)
}
None
=
>
{
trace
!
(
"
-
-
>
no
response
ready
"
)
;
Ok
(
None
)
}
}
}
}
const
RPC_SERVER_INITIAL_CLIENTS
:
usize
=
32
;
pub
(
crate
)
fn
make_server
<
S
:
Server
>
(
server
:
S
)
-
>
ServerHandler
<
S
>
{
ServerHandler
:
:
<
S
>
{
server
in_flight
:
VecDeque
:
:
with_capacity
(
RPC_SERVER_INITIAL_CLIENTS
)
}
}
