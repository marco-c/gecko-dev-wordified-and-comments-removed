#
!
[
cfg_attr
(
all
(
not
(
test
)
not
(
doc
)
)
no_std
)
]
#
!
[
cfg_attr
(
not
(
test
)
deny
(
clippy
:
:
indexing_slicing
clippy
:
:
unwrap_used
clippy
:
:
expect_used
clippy
:
:
panic
clippy
:
:
exhaustive_structs
clippy
:
:
exhaustive_enums
missing_debug_implementations
)
)
]
extern
crate
alloc
;
mod
cmp
;
#
[
cfg
(
feature
=
"
either
"
)
]
mod
either
;
mod
impls
;
mod
ops
;
mod
parts_write_adapter
;
mod
testing
;
mod
try_writeable
;
use
alloc
:
:
borrow
:
:
Cow
;
use
alloc
:
:
string
:
:
String
;
use
core
:
:
fmt
;
pub
use
try_writeable
:
:
TryWriteable
;
pub
mod
adapters
{
use
super
:
:
*
;
pub
use
parts_write_adapter
:
:
CoreWriteAsPartsWrite
;
pub
use
try_writeable
:
:
TryWriteableInfallibleAsWriteable
;
pub
use
try_writeable
:
:
WriteableAsTryWriteableInfallible
;
}
#
[
doc
(
hidden
)
]
pub
mod
_internal
{
pub
use
super
:
:
testing
:
:
try_writeable_to_parts_for_test
;
pub
use
super
:
:
testing
:
:
writeable_to_parts_for_test
;
}
#
[
derive
(
Debug
PartialEq
Eq
Copy
Clone
)
]
#
[
non_exhaustive
]
pub
struct
LengthHint
(
pub
usize
pub
Option
<
usize
>
)
;
impl
LengthHint
{
pub
fn
undefined
(
)
-
>
Self
{
Self
(
0
None
)
}
pub
fn
exact
(
n
:
usize
)
-
>
Self
{
Self
(
n
Some
(
n
)
)
}
pub
fn
at_least
(
n
:
usize
)
-
>
Self
{
Self
(
n
None
)
}
pub
fn
at_most
(
n
:
usize
)
-
>
Self
{
Self
(
0
Some
(
n
)
)
}
pub
fn
between
(
n
:
usize
m
:
usize
)
-
>
Self
{
Self
(
Ord
:
:
min
(
n
m
)
Some
(
Ord
:
:
max
(
n
m
)
)
)
}
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
1
.
unwrap_or
(
self
.
0
)
}
pub
fn
is_zero
(
&
self
)
-
>
bool
{
self
.
1
=
=
Some
(
0
)
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
Part
{
pub
category
:
&
'
static
str
pub
value
:
&
'
static
str
}
impl
Part
{
pub
const
ERROR
:
Part
=
Part
{
category
:
"
writeable
"
value
:
"
error
"
}
;
}
pub
trait
PartsWrite
:
fmt
:
:
Write
{
type
SubPartsWrite
:
PartsWrite
+
?
Sized
;
fn
with_part
(
&
mut
self
part
:
Part
f
:
impl
FnMut
(
&
mut
Self
:
:
SubPartsWrite
)
-
>
fmt
:
:
Result
)
-
>
fmt
:
:
Result
;
}
pub
trait
Writeable
{
fn
write_to
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
sink
:
&
mut
W
)
-
>
fmt
:
:
Result
{
self
.
write_to_parts
(
&
mut
parts_write_adapter
:
:
CoreWriteAsPartsWrite
(
sink
)
)
}
fn
write_to_parts
<
S
:
PartsWrite
+
?
Sized
>
(
&
self
sink
:
&
mut
S
)
-
>
fmt
:
:
Result
{
self
.
write_to
(
sink
)
}
fn
writeable_length_hint
(
&
self
)
-
>
LengthHint
{
LengthHint
:
:
undefined
(
)
}
fn
write_to_string
(
&
self
)
-
>
Cow
<
str
>
{
let
hint
=
self
.
writeable_length_hint
(
)
;
if
hint
.
is_zero
(
)
{
return
Cow
:
:
Borrowed
(
"
"
)
;
}
let
mut
output
=
String
:
:
with_capacity
(
hint
.
capacity
(
)
)
;
let
_
=
self
.
write_to
(
&
mut
output
)
;
Cow
:
:
Owned
(
output
)
}
fn
writeable_cmp_bytes
(
&
self
other
:
&
[
u8
]
)
-
>
core
:
:
cmp
:
:
Ordering
{
let
mut
wc
=
cmp
:
:
WriteComparator
:
:
new
(
other
)
;
let
_
=
self
.
write_to
(
&
mut
wc
)
;
wc
.
finish
(
)
.
reverse
(
)
}
}
#
[
macro_export
]
macro_rules
!
impl_display_with_writeable
{
(
type
:
ty
)
=
>
{
/
/
/
This
trait
is
implemented
for
compatibility
with
[
fmt
!
]
(
alloc
:
:
fmt
)
.
/
/
/
To
create
a
string
[
Writeable
:
:
write_to_string
]
is
usually
more
efficient
.
impl
core
:
:
fmt
:
:
Display
for
type
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
crate
:
:
Writeable
:
:
write_to
(
&
self
f
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
assert_writeable_eq
{
(
actual_writeable
:
expr
expected_str
:
expr
(
)
?
)
=
>
{
crate
:
:
assert_writeable_eq
!
(
actual_writeable
expected_str
"
"
)
}
;
(
actual_writeable
:
expr
expected_str
:
expr
(
arg
:
tt
)
+
)
=
>
{
{
crate
:
:
assert_writeable_eq
!
(
internal
actual_writeable
expected_str
(
arg
)
*
)
;
}
}
;
(
internal
actual_writeable
:
expr
expected_str
:
expr
(
arg
:
tt
)
+
)
=
>
{
{
let
actual_writeable
=
&
actual_writeable
;
let
(
actual_str
actual_parts
)
=
crate
:
:
_internal
:
:
writeable_to_parts_for_test
(
actual_writeable
)
;
let
actual_len
=
actual_str
.
len
(
)
;
assert_eq
!
(
actual_str
expected_str
(
arg
)
*
)
;
assert_eq
!
(
actual_str
crate
:
:
Writeable
:
:
write_to_string
(
actual_writeable
)
(
arg
)
+
)
;
let
length_hint
=
crate
:
:
Writeable
:
:
writeable_length_hint
(
actual_writeable
)
;
let
lower
=
length_hint
.
0
;
assert
!
(
lower
<
=
actual_len
"
hint
lower
bound
{
lower
}
larger
than
actual
length
{
actual_len
}
:
{
}
"
format
!
(
(
arg
)
*
)
)
;
if
let
Some
(
upper
)
=
length_hint
.
1
{
assert
!
(
actual_len
<
=
upper
"
hint
upper
bound
{
upper
}
smaller
than
actual
length
{
actual_len
}
:
{
}
"
format
!
(
(
arg
)
*
)
)
;
}
assert_eq
!
(
actual_writeable
.
to_string
(
)
expected_str
)
;
let
ordering
=
crate
:
:
Writeable
:
:
writeable_cmp_bytes
(
actual_writeable
expected_str
.
as_bytes
(
)
)
;
assert_eq
!
(
ordering
core
:
:
cmp
:
:
Ordering
:
:
Equal
(
arg
)
*
)
;
let
ordering
=
crate
:
:
Writeable
:
:
writeable_cmp_bytes
(
actual_writeable
"
\
u
{
10FFFF
}
"
.
as_bytes
(
)
)
;
assert_eq
!
(
ordering
core
:
:
cmp
:
:
Ordering
:
:
Less
(
arg
)
*
)
;
if
expected_str
!
=
"
"
{
let
ordering
=
crate
:
:
Writeable
:
:
writeable_cmp_bytes
(
actual_writeable
"
"
.
as_bytes
(
)
)
;
assert_eq
!
(
ordering
core
:
:
cmp
:
:
Ordering
:
:
Greater
(
arg
)
*
)
;
}
actual_parts
/
/
return
for
assert_writeable_parts_eq
}
}
;
}
#
[
macro_export
]
macro_rules
!
assert_writeable_parts_eq
{
(
actual_writeable
:
expr
expected_str
:
expr
expected_parts
:
expr
(
)
?
)
=
>
{
crate
:
:
assert_writeable_parts_eq
!
(
actual_writeable
expected_str
expected_parts
"
"
)
}
;
(
actual_writeable
:
expr
expected_str
:
expr
expected_parts
:
expr
(
arg
:
tt
)
+
)
=
>
{
{
let
actual_parts
=
crate
:
:
assert_writeable_eq
!
(
internal
actual_writeable
expected_str
(
arg
)
*
)
;
assert_eq
!
(
actual_parts
expected_parts
(
arg
)
+
)
;
}
}
;
}
