use
crate
:
:
Writeable
;
use
alloc
:
:
borrow
:
:
Cow
;
use
alloc
:
:
string
:
:
String
;
use
core
:
:
fmt
;
struct
PartiallyValidatedUtf8
<
'
a
>
{
slice
:
&
'
a
[
u8
]
offset
:
usize
}
impl
<
'
a
>
PartiallyValidatedUtf8
<
'
a
>
{
fn
new
(
slice
:
&
'
a
[
u8
]
)
-
>
Self
{
Self
{
slice
offset
:
0
}
}
fn
try_push
(
&
mut
self
valid_str
:
&
str
)
-
>
bool
{
let
new_offset
=
self
.
offset
+
valid_str
.
len
(
)
;
if
self
.
slice
.
get
(
self
.
offset
.
.
new_offset
)
=
=
Some
(
valid_str
.
as_bytes
(
)
)
{
self
.
offset
=
new_offset
;
true
}
else
{
false
}
}
fn
validated_as_str
(
&
self
)
-
>
&
'
a
str
{
debug_assert
!
(
self
.
offset
<
=
self
.
slice
.
len
(
)
)
;
let
valid_slice
=
unsafe
{
self
.
slice
.
get_unchecked
(
.
.
self
.
offset
)
}
;
debug_assert
!
(
core
:
:
str
:
:
from_utf8
(
valid_slice
)
.
is_ok
(
)
)
;
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
valid_slice
)
}
}
}
enum
SliceOrString
<
'
a
>
{
Slice
(
PartiallyValidatedUtf8
<
'
a
>
)
String
(
String
)
}
impl
fmt
:
:
Write
for
SliceOrString
<
'
_
>
{
#
[
inline
]
fn
write_str
(
&
mut
self
other
:
&
str
)
-
>
fmt
:
:
Result
{
match
self
{
SliceOrString
:
:
Slice
(
slice
)
=
>
{
if
!
slice
.
try_push
(
other
)
{
let
valid_str
=
slice
.
validated_as_str
(
)
;
let
mut
owned
=
String
:
:
with_capacity
(
valid_str
.
len
(
)
+
other
.
len
(
)
)
;
owned
.
push_str
(
valid_str
)
;
owned
.
push_str
(
other
)
;
*
self
=
SliceOrString
:
:
String
(
owned
)
;
}
Ok
(
(
)
)
}
SliceOrString
:
:
String
(
owned
)
=
>
owned
.
write_str
(
other
)
}
}
}
impl
<
'
a
>
SliceOrString
<
'
a
>
{
#
[
inline
]
fn
new
(
slice
:
&
'
a
[
u8
]
)
-
>
Self
{
Self
:
:
Slice
(
PartiallyValidatedUtf8
:
:
new
(
slice
)
)
}
#
[
inline
]
fn
finish
(
self
)
-
>
Cow
<
'
a
str
>
{
match
self
{
SliceOrString
:
:
Slice
(
slice
)
=
>
Cow
:
:
Borrowed
(
slice
.
validated_as_str
(
)
)
SliceOrString
:
:
String
(
owned
)
=
>
Cow
:
:
Owned
(
owned
)
}
}
}
pub
fn
to_string_or_borrow
<
'
a
>
(
writeable
:
&
impl
Writeable
reference_bytes
:
&
'
a
[
u8
]
)
-
>
Cow
<
'
a
str
>
{
let
mut
sink
=
SliceOrString
:
:
new
(
reference_bytes
)
;
let
_
=
writeable
.
write_to
(
&
mut
sink
)
;
sink
.
finish
(
)
}
