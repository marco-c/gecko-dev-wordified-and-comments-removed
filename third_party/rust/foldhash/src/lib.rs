#
!
[
cfg_attr
(
all
(
not
(
test
)
not
(
feature
=
"
std
"
)
)
no_std
)
]
#
!
[
warn
(
missing_docs
)
]
pub
mod
fast
;
pub
mod
quality
;
mod
seed
;
pub
use
seed
:
:
SharedSeed
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
convenience
;
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
convenience
:
:
*
;
const
ARBITRARY0
:
u64
=
0x243f6a8885a308d3
;
const
ARBITRARY1
:
u64
=
0x13198a2e03707344
;
const
ARBITRARY2
:
u64
=
0xa4093822299f31d0
;
const
ARBITRARY3
:
u64
=
0x082efa98ec4e6c89
;
const
ARBITRARY4
:
u64
=
0x452821e638d01377
;
const
ARBITRARY5
:
u64
=
0xbe5466cf34e90c6c
;
const
ARBITRARY6
:
u64
=
0xc0ac29b7c97c50dd
;
const
ARBITRARY7
:
u64
=
0x3f84d5b5b5470917
;
const
ARBITRARY8
:
u64
=
0x9216d5d98979fb1b
;
const
ARBITRARY9
:
u64
=
0xd1310ba698dfb5ac
;
#
[
inline
(
always
)
]
const
fn
folded_multiply
(
x
:
u64
y
:
u64
)
-
>
u64
{
#
[
cfg
(
any
(
all
(
target_pointer_width
=
"
64
"
not
(
any
(
target_arch
=
"
sparc64
"
target_arch
=
"
wasm64
"
)
)
)
target_arch
=
"
aarch64
"
target_arch
=
"
x86_64
"
all
(
target_family
=
"
wasm
"
target_feature
=
"
wide
-
arithmetic
"
)
)
)
]
{
let
full
=
(
x
as
u128
)
.
wrapping_mul
(
y
as
u128
)
;
let
lo
=
full
as
u64
;
let
hi
=
(
full
>
>
64
)
as
u64
;
lo
^
hi
}
#
[
cfg
(
not
(
any
(
all
(
target_pointer_width
=
"
64
"
not
(
any
(
target_arch
=
"
sparc64
"
target_arch
=
"
wasm64
"
)
)
)
target_arch
=
"
aarch64
"
target_arch
=
"
x86_64
"
all
(
target_family
=
"
wasm
"
target_feature
=
"
wide
-
arithmetic
"
)
)
)
)
]
{
let
lx
=
x
as
u32
;
let
ly
=
y
as
u32
;
let
hx
=
(
x
>
>
32
)
as
u32
;
let
hy
=
(
y
>
>
32
)
as
u32
;
let
ll
=
(
lx
as
u64
)
.
wrapping_mul
(
ly
as
u64
)
;
let
lh
=
(
lx
as
u64
)
.
wrapping_mul
(
hy
as
u64
)
;
let
hl
=
(
hx
as
u64
)
.
wrapping_mul
(
ly
as
u64
)
;
let
hh
=
(
hx
as
u64
)
.
wrapping_mul
(
hy
as
u64
)
;
(
hh
^
ll
)
^
(
hl
^
lh
)
.
rotate_right
(
32
)
}
}
#
[
inline
(
always
)
]
const
fn
rotate_right
(
x
:
u64
r
:
u32
)
-
>
u64
{
#
[
cfg
(
any
(
target_pointer_width
=
"
64
"
target_arch
=
"
aarch64
"
target_arch
=
"
x86_64
"
target_family
=
"
wasm
"
)
)
]
{
x
.
rotate_right
(
r
)
}
#
[
cfg
(
not
(
any
(
target_pointer_width
=
"
64
"
target_arch
=
"
aarch64
"
target_arch
=
"
x86_64
"
target_family
=
"
wasm
"
)
)
)
]
{
let
lo
=
(
x
as
u32
)
.
rotate_right
(
r
)
;
let
hi
=
(
(
x
>
>
32
)
as
u32
)
.
rotate_right
(
r
)
;
(
(
hi
as
u64
)
<
<
32
)
|
lo
as
u64
}
}
fn
hash_bytes_medium
(
bytes
:
&
[
u8
]
mut
s0
:
u64
mut
s1
:
u64
fold_seed
:
u64
)
-
>
u64
{
let
left_to_right
=
bytes
.
chunks_exact
(
16
)
;
let
mut
right_to_left
=
bytes
.
rchunks_exact
(
16
)
;
for
lo
in
left_to_right
{
let
hi
=
right_to_left
.
next
(
)
.
unwrap
(
)
;
let
unconsumed_start
=
lo
.
as_ptr
(
)
;
let
unconsumed_end
=
hi
.
as_ptr_range
(
)
.
end
;
if
unconsumed_start
>
=
unconsumed_end
{
break
;
}
let
a
=
u64
:
:
from_ne_bytes
(
lo
[
0
.
.
8
]
.
try_into
(
)
.
unwrap
(
)
)
;
let
b
=
u64
:
:
from_ne_bytes
(
lo
[
8
.
.
16
]
.
try_into
(
)
.
unwrap
(
)
)
;
let
c
=
u64
:
:
from_ne_bytes
(
hi
[
0
.
.
8
]
.
try_into
(
)
.
unwrap
(
)
)
;
let
d
=
u64
:
:
from_ne_bytes
(
hi
[
8
.
.
16
]
.
try_into
(
)
.
unwrap
(
)
)
;
s0
=
folded_multiply
(
a
^
s0
c
^
fold_seed
)
;
s1
=
folded_multiply
(
b
^
s1
d
^
fold_seed
)
;
}
s0
^
s1
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
hash_bytes_long
(
bytes
:
&
[
u8
]
mut
s0
:
u64
mut
s1
:
u64
mut
s2
:
u64
mut
s3
:
u64
fold_seed
:
u64
)
-
>
u64
{
let
chunks
=
bytes
.
chunks_exact
(
64
)
;
let
remainder
=
chunks
.
remainder
(
)
.
len
(
)
;
for
chunk
in
chunks
{
let
a
=
u64
:
:
from_ne_bytes
(
chunk
[
0
.
.
8
]
.
try_into
(
)
.
unwrap
(
)
)
;
let
b
=
u64
:
:
from_ne_bytes
(
chunk
[
8
.
.
16
]
.
try_into
(
)
.
unwrap
(
)
)
;
let
c
=
u64
:
:
from_ne_bytes
(
chunk
[
16
.
.
24
]
.
try_into
(
)
.
unwrap
(
)
)
;
let
d
=
u64
:
:
from_ne_bytes
(
chunk
[
24
.
.
32
]
.
try_into
(
)
.
unwrap
(
)
)
;
let
e
=
u64
:
:
from_ne_bytes
(
chunk
[
32
.
.
40
]
.
try_into
(
)
.
unwrap
(
)
)
;
let
f
=
u64
:
:
from_ne_bytes
(
chunk
[
40
.
.
48
]
.
try_into
(
)
.
unwrap
(
)
)
;
let
g
=
u64
:
:
from_ne_bytes
(
chunk
[
48
.
.
56
]
.
try_into
(
)
.
unwrap
(
)
)
;
let
h
=
u64
:
:
from_ne_bytes
(
chunk
[
56
.
.
64
]
.
try_into
(
)
.
unwrap
(
)
)
;
s0
=
folded_multiply
(
a
^
s0
e
^
fold_seed
)
;
s1
=
folded_multiply
(
b
^
s1
f
^
fold_seed
)
;
s2
=
folded_multiply
(
c
^
s2
g
^
fold_seed
)
;
s3
=
folded_multiply
(
d
^
s3
h
^
fold_seed
)
;
}
s0
^
=
s2
;
s1
^
=
s3
;
if
remainder
>
0
{
hash_bytes_medium
(
&
bytes
[
bytes
.
len
(
)
-
remainder
.
max
(
16
)
.
.
]
s0
s1
fold_seed
)
}
else
{
s0
^
s1
}
}
