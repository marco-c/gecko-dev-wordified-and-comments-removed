#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
feature
(
alloc
)
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
feature
(
collections
)
)
]
#
!
[
warn
(
missing_docs
)
]
#
!
[
no_std
]
#
[
macro_use
]
#
[
cfg
(
feature
=
"
std
"
)
]
extern
crate
std
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
extern
crate
alloc
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
extern
crate
collections
;
use
core
:
:
str
:
:
FromStr
;
use
core
:
:
fmt
;
use
core
:
:
result
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
sync
:
:
Arc
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
alloc
:
:
arc
:
:
Arc
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
boxed
:
:
Box
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
alloc
:
:
boxed
:
:
Box
;
#
[
doc
(
hidden
)
]
pub
type
Never
=
(
)
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
macro_export
]
macro_rules
!
o
(
(
;
k
:
expr
=
>
v
:
expr
)
=
>
{
o
!
(
(
k
v
)
;
)
}
;
(
;
k
:
expr
=
>
v
:
expr
(
args
:
tt
)
*
)
=
>
{
o
!
(
(
k
v
)
;
(
args
)
*
)
}
;
(
args_ready
:
expr
;
k
:
expr
=
>
v
:
expr
)
=
>
{
o
!
(
(
k
v
args_ready
)
;
)
}
;
(
args_ready
:
expr
;
k
:
expr
=
>
v
:
expr
(
args
:
tt
)
*
)
=
>
{
o
!
(
(
k
v
args_ready
)
;
(
args
)
*
)
}
;
(
args_ready
:
expr
;
)
=
>
{
args_ready
}
;
(
args_ready
:
expr
;
)
=
>
{
args_ready
}
;
(
)
=
>
{
None
}
;
(
(
args
:
tt
)
+
)
=
>
{
Some
(
:
:
std
:
:
boxed
:
:
Box
:
:
new
(
o
!
(
;
(
args
)
+
)
)
)
}
;
)
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
#
[
macro_export
]
macro_rules
!
o
(
(
;
k
:
expr
=
>
v
:
expr
)
=
>
{
o
!
(
(
k
v
)
;
)
}
;
(
;
k
:
expr
=
>
v
:
expr
(
args
:
tt
)
*
)
=
>
{
o
!
(
(
k
v
)
;
(
args
)
*
)
}
;
(
args_ready
:
expr
;
k
:
expr
=
>
v
:
expr
)
=
>
{
o
!
(
(
k
v
args_ready
)
;
)
}
;
(
args_ready
:
expr
;
k
:
expr
=
>
v
:
expr
(
args
:
tt
)
*
)
=
>
{
o
!
(
(
k
v
args_ready
)
;
(
args
)
*
)
}
;
(
args_ready
:
expr
;
)
=
>
{
args_ready
}
;
(
args_ready
:
expr
;
)
=
>
{
args_ready
}
;
(
)
=
>
{
None
}
;
(
(
args
:
tt
)
+
)
=
>
{
Some
(
:
:
std
:
:
boxed
:
:
Box
:
:
new
(
o
!
(
;
(
args
)
+
)
)
)
}
;
)
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
macro_export
]
macro_rules
!
slog_o
(
(
;
k
:
expr
=
>
v
:
expr
)
=
>
{
o
!
(
(
k
v
)
;
)
}
;
(
;
k
:
expr
=
>
v
:
expr
(
args
:
tt
)
*
)
=
>
{
o
!
(
(
k
v
)
;
(
args
)
*
)
}
;
(
args_ready
:
expr
;
k
:
expr
=
>
v
:
expr
)
=
>
{
o
!
(
(
k
v
args_ready
)
;
)
}
;
(
args_ready
:
expr
;
k
:
expr
=
>
v
:
expr
(
args
:
tt
)
*
)
=
>
{
o
!
(
(
k
v
args_ready
)
;
(
args
)
*
)
}
;
(
args_ready
:
expr
;
)
=
>
{
args_ready
}
;
(
args_ready
:
expr
;
)
=
>
{
args_ready
}
;
(
)
=
>
{
None
}
;
(
(
args
:
tt
)
+
)
=
>
{
Some
(
:
:
std
:
:
boxed
:
:
Box
:
:
new
(
o
!
(
;
(
args
)
+
)
)
)
}
;
)
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
#
[
macro_export
]
macro_rules
!
slog_o
(
(
;
k
:
expr
=
>
v
:
expr
)
=
>
{
o
!
(
(
k
v
)
;
)
}
;
(
;
k
:
expr
=
>
v
:
expr
(
args
:
tt
)
*
)
=
>
{
o
!
(
(
k
v
)
;
(
args
)
*
)
}
;
(
args_ready
:
expr
;
k
:
expr
=
>
v
:
expr
)
=
>
{
o
!
(
(
k
v
args_ready
)
;
)
}
;
(
args_ready
:
expr
;
k
:
expr
=
>
v
:
expr
(
args
:
tt
)
*
)
=
>
{
o
!
(
(
k
v
args_ready
)
;
(
args
)
*
)
}
;
(
args_ready
:
expr
;
)
=
>
{
args_ready
}
;
(
args_ready
:
expr
;
)
=
>
{
args_ready
}
;
(
)
=
>
{
None
}
;
(
(
args
:
tt
)
+
)
=
>
{
Some
(
:
:
std
:
:
boxed
:
:
Box
:
:
new
(
o
!
(
;
(
args
)
+
)
)
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
log
(
(
lvl
:
expr
l
:
expr
(
k
:
expr
=
>
v
:
expr
)
+
;
(
args
:
tt
)
+
)
=
>
{
if
lvl
.
as_usize
(
)
<
=
crate
:
:
__slog_static_max_level
(
)
.
as_usize
(
)
{
/
/
prevent
generating
big
Record
over
and
over
static
RS
:
crate
:
:
RecordStatic
<
'
static
>
=
crate
:
:
RecordStatic
{
level
:
lvl
file
:
file
!
(
)
line
:
line
!
(
)
column
:
column
!
(
)
function
:
"
"
module
:
module_path
!
(
)
target
:
module_path
!
(
)
}
;
l
.
log
(
&
crate
:
:
Record
:
:
new
(
&
RS
format_args
!
(
(
args
)
+
)
&
[
(
(
k
&
v
)
)
+
]
)
)
}
}
;
(
lvl
:
expr
l
:
expr
msg
:
expr
)
=
>
{
if
lvl
.
as_usize
(
)
<
=
crate
:
:
__slog_static_max_level
(
)
.
as_usize
(
)
{
/
/
prevent
generating
big
Record
over
and
over
static
RS
:
crate
:
:
RecordStatic
<
'
static
>
=
crate
:
:
RecordStatic
{
level
:
lvl
file
:
file
!
(
)
line
:
line
!
(
)
column
:
column
!
(
)
function
:
"
"
module
:
module_path
!
(
)
target
:
module_path
!
(
)
}
;
l
.
log
(
&
crate
:
:
Record
:
:
new
(
&
RS
format_args
!
(
"
{
}
"
msg
)
&
[
]
)
)
}
}
;
(
lvl
:
expr
l
:
expr
msg
:
expr
;
(
k
:
expr
=
>
v
:
expr
)
+
)
=
>
{
if
lvl
.
as_usize
(
)
<
=
crate
:
:
__slog_static_max_level
(
)
.
as_usize
(
)
{
/
/
prevent
generating
big
Record
over
and
over
static
RS
:
crate
:
:
RecordStatic
<
'
static
>
=
crate
:
:
RecordStatic
{
level
:
lvl
file
:
file
!
(
)
line
:
line
!
(
)
column
:
column
!
(
)
function
:
"
"
module
:
module_path
!
(
)
target
:
module_path
!
(
)
}
;
l
.
log
(
&
crate
:
:
Record
:
:
new
(
&
RS
format_args
!
(
"
{
}
"
msg
)
&
[
(
(
k
&
v
)
)
+
]
)
)
}
}
;
(
lvl
:
expr
l
:
expr
msg
:
expr
;
(
k
:
expr
=
>
v
:
expr
)
+
)
=
>
{
log
!
(
lvl
l
msg
;
(
k
=
>
v
)
+
)
}
;
(
lvl
:
expr
l
:
expr
(
args
:
tt
)
+
)
=
>
{
if
lvl
.
as_usize
(
)
<
=
crate
:
:
__slog_static_max_level
(
)
.
as_usize
(
)
{
/
/
prevent
generating
big
Record
over
and
over
static
RS
:
crate
:
:
RecordStatic
<
'
static
>
=
crate
:
:
RecordStatic
{
level
:
lvl
file
:
file
!
(
)
line
:
line
!
(
)
column
:
column
!
(
)
function
:
"
"
module
:
module_path
!
(
)
target
:
module_path
!
(
)
}
;
l
.
log
(
&
crate
:
:
Record
:
:
new
(
&
RS
format_args
!
(
(
args
)
+
)
&
[
]
)
)
}
}
;
)
;
#
[
macro_export
]
macro_rules
!
slog_log
(
(
lvl
:
expr
l
:
expr
(
k
:
expr
=
>
v
:
expr
)
+
;
(
args
:
tt
)
+
)
=
>
{
if
lvl
.
as_usize
(
)
<
=
crate
:
:
__slog_static_max_level
(
)
.
as_usize
(
)
{
/
/
prevent
generating
big
Record
over
and
over
static
RS
:
crate
:
:
RecordStatic
<
'
static
>
=
crate
:
:
RecordStatic
{
level
:
lvl
file
:
file
!
(
)
line
:
line
!
(
)
column
:
column
!
(
)
function
:
"
"
module
:
module_path
!
(
)
target
:
module_path
!
(
)
}
;
l
.
log
(
&
crate
:
:
Record
:
:
new
(
&
RS
format_args
!
(
(
args
)
+
)
&
[
(
(
k
&
v
)
)
+
]
)
)
}
}
;
(
lvl
:
expr
l
:
expr
msg
:
expr
)
=
>
{
if
lvl
.
as_usize
(
)
<
=
crate
:
:
__slog_static_max_level
(
)
.
as_usize
(
)
{
/
/
prevent
generating
big
Record
over
and
over
static
RS
:
crate
:
:
RecordStatic
<
'
static
>
=
crate
:
:
RecordStatic
{
level
:
lvl
file
:
file
!
(
)
line
:
line
!
(
)
column
:
column
!
(
)
function
:
"
"
module
:
module_path
!
(
)
target
:
module_path
!
(
)
}
;
l
.
log
(
&
crate
:
:
Record
:
:
new
(
&
RS
format_args
!
(
"
{
}
"
msg
)
&
[
]
)
)
}
}
;
(
lvl
:
expr
l
:
expr
msg
:
expr
;
(
k
:
expr
=
>
v
:
expr
)
+
)
=
>
{
if
lvl
.
as_usize
(
)
<
=
crate
:
:
__slog_static_max_level
(
)
.
as_usize
(
)
{
/
/
prevent
generating
big
Record
over
and
over
static
RS
:
crate
:
:
RecordStatic
<
'
static
>
=
crate
:
:
RecordStatic
{
level
:
lvl
file
:
file
!
(
)
line
:
line
!
(
)
column
:
column
!
(
)
function
:
"
"
module
:
module_path
!
(
)
target
:
module_path
!
(
)
}
;
l
.
log
(
&
crate
:
:
Record
:
:
new
(
&
RS
format_args
!
(
"
{
}
"
msg
)
&
[
(
(
k
&
v
)
)
+
]
)
)
}
}
;
(
lvl
:
expr
l
:
expr
msg
:
expr
;
(
k
:
expr
=
>
v
:
expr
)
+
)
=
>
{
log
!
(
lvl
l
msg
;
(
k
=
>
v
)
+
)
}
;
(
lvl
:
expr
l
:
expr
(
args
:
tt
)
+
)
=
>
{
if
lvl
.
as_usize
(
)
<
=
crate
:
:
__slog_static_max_level
(
)
.
as_usize
(
)
{
/
/
prevent
generating
big
Record
over
and
over
static
RS
:
crate
:
:
RecordStatic
<
'
static
>
=
crate
:
:
RecordStatic
{
level
:
lvl
file
:
file
!
(
)
line
:
line
!
(
)
column
:
column
!
(
)
function
:
"
"
module
:
module_path
!
(
)
target
:
module_path
!
(
)
}
;
l
.
log
(
&
crate
:
:
Record
:
:
new
(
&
RS
format_args
!
(
(
args
)
+
)
&
[
]
)
)
}
}
;
)
;
#
[
macro_export
]
macro_rules
!
crit
(
(
(
args
:
tt
)
+
)
=
>
{
log
!
(
crate
:
:
Level
:
:
Critical
(
args
)
+
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
slog_crit
(
(
(
args
:
tt
)
+
)
=
>
{
slog_log
!
(
crate
:
:
Level
:
:
Critical
(
args
)
+
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
error
(
(
(
args
:
tt
)
+
)
=
>
{
log
!
(
crate
:
:
Level
:
:
Error
(
args
)
+
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
slog_error
(
(
(
args
:
tt
)
+
)
=
>
{
slog_log
!
(
crate
:
:
Level
:
:
Error
(
args
)
+
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
warn
(
(
(
args
:
tt
)
+
)
=
>
{
log
!
(
crate
:
:
Level
:
:
Warning
(
args
)
+
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
slog_warn
(
(
(
args
:
tt
)
+
)
=
>
{
slog_log
!
(
crate
:
:
Level
:
:
Warning
(
args
)
+
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
info
(
(
(
args
:
tt
)
+
)
=
>
{
log
!
(
crate
:
:
Level
:
:
Info
(
args
)
+
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
slog_info
(
(
(
args
:
tt
)
+
)
=
>
{
slog_log
!
(
crate
:
:
Level
:
:
Info
(
args
)
+
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
debug
(
(
(
args
:
tt
)
+
)
=
>
{
log
!
(
crate
:
:
Level
:
:
Debug
(
args
)
+
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
slog_debug
(
(
(
args
:
tt
)
+
)
=
>
{
slog_log
!
(
crate
:
:
Level
:
:
Debug
(
args
)
+
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
trace
(
(
(
args
:
tt
)
+
)
=
>
{
log
!
(
crate
:
:
Level
:
:
Trace
(
args
)
+
)
}
;
)
;
#
[
macro_export
]
macro_rules
!
slog_trace
(
(
(
args
:
tt
)
+
)
=
>
{
slog_log
!
(
crate
:
:
Level
:
:
Trace
(
args
)
+
)
}
;
)
;
pub
mod
ser
;
pub
use
ser
:
:
{
PushLazy
ValueSerializer
Serializer
Serialize
}
;
include
!
(
"
_level
.
rs
"
)
;
include
!
(
"
_logger
.
rs
"
)
;
include
!
(
"
_drain
.
rs
"
)
;
pub
type
BorrowedKeyValue
<
'
a
>
=
(
&
'
static
str
&
'
a
ser
:
:
Serialize
)
;
pub
type
OwnedKeyValue
<
'
a
>
=
(
&
'
static
str
&
'
a
ser
:
:
SyncSerialize
)
;
struct
OwnedKeyValueListInner
{
parent
:
Option
<
OwnedKeyValueList
>
values
:
Option
<
Box
<
ser
:
:
SyncMultiSerialize
>
>
}
#
[
derive
(
Clone
)
]
pub
struct
OwnedKeyValueList
{
inner
:
Arc
<
OwnedKeyValueListInner
>
}
impl
OwnedKeyValueList
{
pub
fn
new
(
values
:
Box
<
ser
:
:
SyncMultiSerialize
>
parent
:
OwnedKeyValueList
)
-
>
Self
{
OwnedKeyValueList
{
inner
:
Arc
:
:
new
(
OwnedKeyValueListInner
{
parent
:
Some
(
parent
)
values
:
Some
(
values
)
}
)
}
}
pub
fn
root
(
values
:
Option
<
Box
<
ser
:
:
SyncMultiSerialize
>
>
)
-
>
Self
{
OwnedKeyValueList
{
inner
:
Arc
:
:
new
(
OwnedKeyValueListInner
{
parent
:
None
values
:
values
}
)
}
}
pub
fn
parent
(
&
self
)
-
>
&
Option
<
OwnedKeyValueList
>
{
&
self
.
inner
.
parent
}
pub
fn
values
(
&
self
)
-
>
Option
<
&
ser
:
:
SyncMultiSerialize
>
{
self
.
inner
.
values
.
as_ref
(
)
.
map
(
|
b
|
&
*
*
b
)
}
pub
fn
iter
(
&
self
)
-
>
OwnedKeyValueListIterator
{
OwnedKeyValueListIterator
:
:
new
(
self
)
}
#
[
deprecated
]
pub
fn
id
(
&
self
)
-
>
usize
{
&
*
self
.
inner
as
*
const
_
as
usize
}
}
pub
struct
OwnedKeyValueListIterator
<
'
a
>
{
next_node
:
Option
<
&
'
a
OwnedKeyValueList
>
cur
:
Option
<
&
'
a
ser
:
:
SyncMultiSerialize
>
}
impl
<
'
a
>
OwnedKeyValueListIterator
<
'
a
>
{
fn
new
(
node
:
&
'
a
OwnedKeyValueList
)
-
>
Self
{
OwnedKeyValueListIterator
{
next_node
:
Some
(
node
)
cur
:
None
}
}
}
impl
<
'
a
>
Iterator
for
OwnedKeyValueListIterator
<
'
a
>
{
type
Item
=
OwnedKeyValue
<
'
a
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
loop
{
let
cur
=
self
.
cur
;
match
cur
{
Some
(
x
)
=
>
{
let
tail
=
x
.
tail
(
)
;
self
.
cur
=
tail
;
return
Some
(
x
.
head
(
)
)
}
None
=
>
{
self
.
next_node
=
match
self
.
next_node
{
Some
(
ref
node
)
=
>
{
self
.
cur
=
node
.
inner
.
values
.
as_ref
(
)
.
map
(
|
v
|
&
*
*
v
)
;
node
.
inner
.
parent
.
as_ref
(
)
}
None
=
>
return
None
}
;
}
}
}
}
}
#
[
allow
(
unknown_lints
)
]
#
[
allow
(
inline_always
)
]
#
[
inline
(
always
)
]
#
[
doc
(
hidden
)
]
pub
fn
__slog_static_max_level
(
)
-
>
FilterLevel
{
if
!
cfg
!
(
debug_assertions
)
{
if
cfg
!
(
feature
=
"
release_max_level_off
"
)
{
return
FilterLevel
:
:
Off
;
}
else
if
cfg
!
(
feature
=
"
release_max_level_error
"
)
{
return
FilterLevel
:
:
Error
;
}
else
if
cfg
!
(
feature
=
"
release_max_level_warn
"
)
{
return
FilterLevel
:
:
Warning
;
}
else
if
cfg
!
(
feature
=
"
release_max_level_info
"
)
{
return
FilterLevel
:
:
Info
;
}
else
if
cfg
!
(
feature
=
"
release_max_level_debug
"
)
{
return
FilterLevel
:
:
Debug
;
}
else
if
cfg
!
(
feature
=
"
release_max_level_trace
"
)
{
return
FilterLevel
:
:
Trace
;
}
}
if
cfg
!
(
feature
=
"
max_level_off
"
)
{
FilterLevel
:
:
Off
}
else
if
cfg
!
(
feature
=
"
max_level_error
"
)
{
FilterLevel
:
:
Error
}
else
if
cfg
!
(
feature
=
"
max_level_warn
"
)
{
FilterLevel
:
:
Warning
}
else
if
cfg
!
(
feature
=
"
max_level_info
"
)
{
FilterLevel
:
:
Info
}
else
if
cfg
!
(
feature
=
"
max_level_debug
"
)
{
FilterLevel
:
:
Debug
}
else
if
cfg
!
(
feature
=
"
max_level_trace
"
)
{
FilterLevel
:
:
Trace
}
else
{
if
!
cfg
!
(
debug_assertions
)
{
FilterLevel
:
:
Info
}
else
{
FilterLevel
:
:
Debug
}
}
}
#
[
cfg
(
test
)
]
mod
tests
;
