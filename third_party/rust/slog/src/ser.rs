#
[
cfg
(
feature
=
"
std
"
)
]
use
std
;
use
core
;
use
core
:
:
{
result
fmt
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
sync
:
:
Arc
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
alloc
:
:
arc
:
:
Arc
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
rc
:
:
Rc
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
alloc
:
:
rc
:
:
Rc
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
boxed
:
:
Box
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
alloc
:
:
boxed
:
:
Box
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
string
:
:
String
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
collections
:
:
string
:
:
String
;
use
super
:
:
Record
;
#
[
derive
(
Debug
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
enum
Error
{
Io
(
std
:
:
io
:
:
Error
)
Other
}
#
[
derive
(
Debug
)
]
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
pub
enum
Error
{
Other
}
pub
type
Result
=
result
:
:
Result
<
(
)
Error
>
;
#
[
cfg
(
feature
=
"
std
"
)
]
impl
From
<
std
:
:
io
:
:
Error
>
for
Error
{
fn
from
(
err
:
std
:
:
io
:
:
Error
)
-
>
Error
{
Error
:
:
Io
(
err
)
}
}
impl
From
<
core
:
:
fmt
:
:
Error
>
for
Error
{
fn
from
(
_
:
core
:
:
fmt
:
:
Error
)
-
>
Error
{
Error
:
:
Other
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
From
<
Error
>
for
std
:
:
io
:
:
Error
{
fn
from
(
e
:
Error
)
-
>
std
:
:
io
:
:
Error
{
match
e
{
Error
:
:
Io
(
e
)
=
>
e
Error
:
:
Other
=
>
std
:
:
io
:
:
Error
:
:
new
(
std
:
:
io
:
:
ErrorKind
:
:
Other
"
other
error
"
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
std
:
:
error
:
:
Error
for
Error
{
fn
description
(
&
self
)
-
>
&
str
{
match
*
self
{
Error
:
:
Io
(
ref
e
)
=
>
e
.
description
(
)
Error
:
:
Other
=
>
"
serialization
error
"
}
}
fn
cause
(
&
self
)
-
>
Option
<
&
std
:
:
error
:
:
Error
>
{
match
*
self
{
Error
:
:
Io
(
ref
e
)
=
>
Some
(
e
)
Error
:
:
Other
=
>
None
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
core
:
:
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
fmt
:
&
mut
core
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
match
*
self
{
Error
:
:
Io
(
ref
e
)
=
>
e
.
fmt
(
fmt
)
Error
:
:
Other
=
>
fmt
.
write_str
(
"
Other
serialization
error
"
)
}
}
}
pub
trait
Serialize
{
fn
serialize
(
&
self
record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
;
}
pub
trait
SyncSerialize
:
Send
+
Sync
+
'
static
+
Serialize
{
}
pub
trait
SyncMultiSerialize
:
Send
+
Sync
+
'
static
{
fn
head
(
&
self
)
-
>
(
&
'
static
str
&
SyncSerialize
)
;
fn
tail
(
&
self
)
-
>
Option
<
&
SyncMultiSerialize
>
;
}
pub
trait
Serializer
{
fn
emit_bool
(
&
mut
self
key
:
&
'
static
str
val
:
bool
)
-
>
Result
;
fn
emit_unit
(
&
mut
self
key
:
&
'
static
str
)
-
>
Result
;
fn
emit_none
(
&
mut
self
key
:
&
'
static
str
)
-
>
Result
;
fn
emit_char
(
&
mut
self
key
:
&
'
static
str
val
:
char
)
-
>
Result
;
fn
emit_u8
(
&
mut
self
key
:
&
'
static
str
val
:
u8
)
-
>
Result
;
fn
emit_i8
(
&
mut
self
key
:
&
'
static
str
val
:
i8
)
-
>
Result
;
fn
emit_u16
(
&
mut
self
key
:
&
'
static
str
val
:
u16
)
-
>
Result
;
fn
emit_i16
(
&
mut
self
key
:
&
'
static
str
val
:
i16
)
-
>
Result
;
fn
emit_u32
(
&
mut
self
key
:
&
'
static
str
val
:
u32
)
-
>
Result
;
fn
emit_i32
(
&
mut
self
key
:
&
'
static
str
val
:
i32
)
-
>
Result
;
fn
emit_f32
(
&
mut
self
key
:
&
'
static
str
val
:
f32
)
-
>
Result
;
fn
emit_u64
(
&
mut
self
key
:
&
'
static
str
val
:
u64
)
-
>
Result
;
fn
emit_i64
(
&
mut
self
key
:
&
'
static
str
val
:
i64
)
-
>
Result
;
fn
emit_f64
(
&
mut
self
key
:
&
'
static
str
val
:
f64
)
-
>
Result
;
fn
emit_usize
(
&
mut
self
key
:
&
'
static
str
val
:
usize
)
-
>
Result
;
fn
emit_isize
(
&
mut
self
key
:
&
'
static
str
val
:
isize
)
-
>
Result
;
fn
emit_str
(
&
mut
self
key
:
&
'
static
str
val
:
&
str
)
-
>
Result
;
fn
emit_arguments
(
&
mut
self
key
:
&
'
static
str
val
:
&
fmt
:
:
Arguments
)
-
>
Result
;
}
macro_rules
!
impl_serialize_for
{
(
t
:
ty
f
:
ident
)
=
>
{
impl
Serialize
for
t
{
fn
serialize
(
&
self
_record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
serializer
.
f
(
key
*
self
)
}
}
impl
SyncSerialize
for
t
where
t
:
Send
+
Sync
+
'
static
{
}
}
;
}
impl_serialize_for
!
(
usize
emit_usize
)
;
impl_serialize_for
!
(
isize
emit_isize
)
;
impl_serialize_for
!
(
bool
emit_bool
)
;
impl_serialize_for
!
(
char
emit_char
)
;
impl_serialize_for
!
(
u8
emit_u8
)
;
impl_serialize_for
!
(
i8
emit_i8
)
;
impl_serialize_for
!
(
u16
emit_u16
)
;
impl_serialize_for
!
(
i16
emit_i16
)
;
impl_serialize_for
!
(
u32
emit_u32
)
;
impl_serialize_for
!
(
i32
emit_i32
)
;
impl_serialize_for
!
(
f32
emit_f32
)
;
impl_serialize_for
!
(
u64
emit_u64
)
;
impl_serialize_for
!
(
i64
emit_i64
)
;
impl_serialize_for
!
(
f64
emit_f64
)
;
impl
Serialize
for
(
)
{
fn
serialize
(
&
self
_record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
serializer
.
emit_unit
(
key
)
}
}
impl
SyncSerialize
for
(
)
{
}
impl
Serialize
for
str
{
fn
serialize
(
&
self
_record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
serializer
.
emit_str
(
key
self
)
}
}
impl
<
'
a
>
Serialize
for
&
'
a
str
{
fn
serialize
(
&
self
_record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
serializer
.
emit_str
(
key
self
)
}
}
impl
<
'
a
>
Serialize
for
fmt
:
:
Arguments
<
'
a
>
{
fn
serialize
(
&
self
_record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
serializer
.
emit_arguments
(
key
self
)
}
}
impl
SyncSerialize
for
fmt
:
:
Arguments
<
'
static
>
{
}
impl
SyncSerialize
for
&
'
static
str
{
}
impl
Serialize
for
String
{
fn
serialize
(
&
self
_record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
serializer
.
emit_str
(
key
self
.
as_str
(
)
)
}
}
impl
SyncSerialize
for
String
{
}
impl
<
T
:
Serialize
>
Serialize
for
Option
<
T
>
{
fn
serialize
(
&
self
record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
match
*
self
{
Some
(
ref
s
)
=
>
s
.
serialize
(
record
key
serializer
)
None
=
>
serializer
.
emit_none
(
key
)
}
}
}
impl
<
T
:
Serialize
+
Send
+
Sync
+
'
static
>
SyncSerialize
for
Option
<
T
>
{
}
impl
Serialize
for
Box
<
Serialize
+
Send
+
'
static
>
{
fn
serialize
(
&
self
record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
(
*
*
self
)
.
serialize
(
record
key
serializer
)
}
}
impl
<
T
>
Serialize
for
Arc
<
T
>
where
T
:
Serialize
{
fn
serialize
(
&
self
record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
(
*
*
self
)
.
serialize
(
record
key
serializer
)
}
}
impl
<
T
>
SyncSerialize
for
Arc
<
T
>
where
T
:
SyncSerialize
{
}
impl
<
T
>
Serialize
for
Rc
<
T
>
where
T
:
Serialize
{
fn
serialize
(
&
self
record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
(
*
*
self
)
.
serialize
(
record
key
serializer
)
}
}
impl
<
T
>
Serialize
for
core
:
:
num
:
:
Wrapping
<
T
>
where
T
:
Serialize
{
fn
serialize
(
&
self
record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
self
.
0
.
serialize
(
record
key
serializer
)
}
}
impl
<
T
>
SyncSerialize
for
core
:
:
num
:
:
Wrapping
<
T
>
where
T
:
SyncSerialize
{
}
impl
<
S
:
'
static
+
Serialize
F
>
Serialize
for
F
where
F
:
'
static
+
for
<
'
c
'
d
>
Fn
(
&
'
c
Record
<
'
d
>
)
-
>
S
{
fn
serialize
(
&
self
record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
(
*
self
)
(
record
)
.
serialize
(
record
key
serializer
)
}
}
impl
<
S
:
'
static
+
Serialize
F
>
SyncSerialize
for
F
where
F
:
'
static
+
Sync
+
Send
+
for
<
'
c
'
d
>
Fn
(
&
'
c
Record
<
'
d
>
)
-
>
S
{
}
pub
struct
PushLazy
<
F
>
(
pub
F
)
;
pub
struct
ValueSerializer
<
'
a
>
{
record
:
&
'
a
Record
<
'
a
>
key
:
&
'
static
str
serializer
:
&
'
a
mut
Serializer
done
:
bool
}
impl
<
'
a
>
ValueSerializer
<
'
a
>
{
pub
fn
serialize
<
'
b
S
:
'
b
+
Serialize
>
(
mut
self
s
:
S
)
-
>
result
:
:
Result
<
(
)
Error
>
{
self
.
done
=
true
;
s
.
serialize
(
self
.
record
self
.
key
self
.
serializer
)
}
}
impl
<
'
a
>
Drop
for
ValueSerializer
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
if
!
self
.
done
{
let
_
=
self
.
serializer
.
emit_unit
(
self
.
key
)
;
}
}
}
impl
<
F
>
Serialize
for
PushLazy
<
F
>
where
F
:
'
static
+
for
<
'
c
'
d
>
Fn
(
&
'
c
Record
<
'
d
>
ValueSerializer
<
'
c
>
)
-
>
result
:
:
Result
<
(
)
Error
>
{
fn
serialize
(
&
self
record
:
&
Record
key
:
&
'
static
str
serializer
:
&
mut
Serializer
)
-
>
result
:
:
Result
<
(
)
Error
>
{
let
ser
=
ValueSerializer
{
record
:
record
key
:
key
serializer
:
serializer
done
:
false
}
;
(
self
.
0
)
(
record
ser
)
}
}
impl
<
F
>
SyncSerialize
for
PushLazy
<
F
>
where
F
:
'
static
+
Sync
+
Send
+
for
<
'
c
'
d
>
Fn
(
&
'
c
Record
<
'
d
>
ValueSerializer
<
'
c
>
)
-
>
result
:
:
Result
<
(
)
Error
>
{
}
impl
<
A
:
SyncSerialize
>
SyncMultiSerialize
for
(
&
'
static
str
A
)
{
fn
tail
(
&
self
)
-
>
Option
<
&
SyncMultiSerialize
>
{
None
}
fn
head
(
&
self
)
-
>
(
&
'
static
str
&
SyncSerialize
)
{
let
(
ref
key
ref
val
)
=
*
self
;
(
key
val
)
}
}
impl
<
A
:
SyncSerialize
R
:
SyncMultiSerialize
>
SyncMultiSerialize
for
(
&
'
static
str
A
R
)
{
fn
tail
(
&
self
)
-
>
Option
<
&
SyncMultiSerialize
>
{
let
(
_
_
ref
tail
)
=
*
self
;
Some
(
tail
)
}
fn
head
(
&
self
)
-
>
(
&
'
static
str
&
SyncSerialize
)
{
let
(
ref
key
ref
val
_
)
=
*
self
;
(
key
val
)
}
}
