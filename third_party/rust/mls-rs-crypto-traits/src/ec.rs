use
mls_rs_core
:
:
crypto
:
:
CipherSuite
;
use
crate
:
:
SamplingMethod
;
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
#
[
repr
(
u8
)
]
#
[
non_exhaustive
]
pub
enum
Curve
{
P256
P384
P521
X25519
Ed25519
X448
Ed448
}
impl
Curve
{
#
[
inline
(
always
)
]
pub
fn
secret_key_size
(
&
self
)
-
>
usize
{
match
self
{
Curve
:
:
P256
=
>
32
Curve
:
:
P384
=
>
48
Curve
:
:
P521
=
>
66
Curve
:
:
X25519
=
>
32
Curve
:
:
Ed25519
=
>
64
Curve
:
:
X448
=
>
56
Curve
:
:
Ed448
=
>
114
}
}
#
[
inline
(
always
)
]
pub
fn
public_key_size
(
&
self
)
-
>
usize
{
match
self
{
Curve
:
:
P256
|
Curve
:
:
P384
|
Curve
:
:
P521
=
>
2
*
self
.
secret_key_size
(
)
+
1
Curve
:
:
X25519
|
Curve
:
:
Ed25519
|
Curve
:
:
X448
|
Curve
:
:
Ed448
=
>
self
.
secret_key_size
(
)
}
}
pub
fn
from_ciphersuite
(
cipher_suite
:
CipherSuite
for_sig
:
bool
)
-
>
Option
<
Self
>
{
match
cipher_suite
{
CipherSuite
:
:
P256_AES128
=
>
Some
(
Curve
:
:
P256
)
CipherSuite
:
:
P384_AES256
=
>
Some
(
Curve
:
:
P384
)
CipherSuite
:
:
P521_AES256
=
>
Some
(
Curve
:
:
P521
)
CipherSuite
:
:
CURVE25519_AES128
|
CipherSuite
:
:
CURVE25519_CHACHA
if
for_sig
=
>
{
Some
(
Curve
:
:
Ed25519
)
}
CipherSuite
:
:
CURVE25519_AES128
|
CipherSuite
:
:
CURVE25519_CHACHA
=
>
Some
(
Curve
:
:
X25519
)
CipherSuite
:
:
CURVE448_AES256
|
CipherSuite
:
:
CURVE448_CHACHA
if
for_sig
=
>
{
Some
(
Curve
:
:
Ed448
)
}
CipherSuite
:
:
CURVE448_AES256
|
CipherSuite
:
:
CURVE448_CHACHA
=
>
Some
(
Curve
:
:
X448
)
_
=
>
None
}
}
#
[
inline
(
always
)
]
pub
fn
hpke_sampling_method
(
&
self
)
-
>
SamplingMethod
{
match
self
{
Curve
:
:
P256
|
Curve
:
:
P384
=
>
SamplingMethod
:
:
HpkeWithBitmask
(
0xFF
)
Curve
:
:
P521
=
>
SamplingMethod
:
:
HpkeWithBitmask
(
0x01
)
_
=
>
SamplingMethod
:
:
HpkeWithoutBitmask
}
}
}
