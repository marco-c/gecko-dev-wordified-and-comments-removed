use
super
:
:
{
EnumPath
Everywhere
MaybeStatic
NonOptional
OpaquePath
Optional
OutputOnly
PrimitiveType
StructPath
TyPosition
TypeContext
TypeLifetime
}
;
use
crate
:
:
ast
;
pub
use
ast
:
:
Mutability
;
pub
type
OutType
=
Type
<
OutputOnly
>
;
#
[
derive
(
Debug
)
]
#
[
non_exhaustive
]
pub
enum
Type
<
P
:
TyPosition
=
Everywhere
>
{
Primitive
(
PrimitiveType
)
Opaque
(
OpaquePath
<
Optional
P
:
:
OpaqueOwnership
>
)
Struct
(
P
:
:
StructPath
)
Enum
(
EnumPath
)
Slice
(
Slice
)
}
#
[
derive
(
Debug
Clone
)
]
#
[
non_exhaustive
]
pub
enum
SelfType
{
Opaque
(
OpaquePath
<
NonOptional
Borrow
>
)
Struct
(
StructPath
)
Enum
(
EnumPath
)
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
non_exhaustive
]
pub
enum
Slice
{
Str
(
MaybeStatic
<
TypeLifetime
>
)
Primitive
(
Borrow
PrimitiveType
)
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
non_exhaustive
]
pub
struct
Borrow
{
pub
lifetime
:
MaybeStatic
<
TypeLifetime
>
pub
mutability
:
Mutability
}
impl
Type
{
pub
(
super
)
fn
field_leaf_lifetime_counts
(
&
self
tcx
:
&
TypeContext
)
-
>
(
usize
usize
)
{
match
self
{
Type
:
:
Struct
(
ty
)
=
>
ty
.
resolve
(
tcx
)
.
fields
.
iter
(
)
.
fold
(
(
1
0
)
|
acc
field
|
{
let
inner
=
field
.
ty
.
field_leaf_lifetime_counts
(
tcx
)
;
(
acc
.
0
+
inner
.
0
acc
.
1
+
inner
.
1
)
}
)
Type
:
:
Opaque
(
_
)
|
Type
:
:
Slice
(
_
)
=
>
(
1
1
)
Type
:
:
Primitive
(
_
)
|
Type
:
:
Enum
(
_
)
=
>
(
0
0
)
}
}
}
impl
SelfType
{
pub
fn
is_immutably_borrowed
(
&
self
)
-
>
bool
{
match
self
{
SelfType
:
:
Opaque
(
opaque_path
)
=
>
opaque_path
.
owner
.
mutability
=
=
Mutability
:
:
Immutable
_
=
>
false
}
}
}
impl
Slice
{
pub
fn
lifetime
(
&
self
)
-
>
&
MaybeStatic
<
TypeLifetime
>
{
match
self
{
Slice
:
:
Str
(
lifetime
)
=
>
lifetime
Slice
:
:
Primitive
(
reference
_
)
=
>
&
reference
.
lifetime
}
}
}
impl
Borrow
{
pub
(
super
)
fn
new
(
lifetime
:
MaybeStatic
<
TypeLifetime
>
mutability
:
Mutability
)
-
>
Self
{
Self
{
lifetime
mutability
}
}
}
impl
From
<
SelfType
>
for
Type
{
fn
from
(
s
:
SelfType
)
-
>
Type
{
match
s
{
SelfType
:
:
Opaque
(
o
)
=
>
Type
:
:
Opaque
(
o
.
wrap_optional
(
)
)
SelfType
:
:
Struct
(
s
)
=
>
Type
:
:
Struct
(
s
)
SelfType
:
:
Enum
(
e
)
=
>
Type
:
:
Enum
(
e
)
}
}
}
