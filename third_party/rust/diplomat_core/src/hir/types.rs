use
super
:
:
lifetimes
:
:
{
Lifetime
MaybeStatic
}
;
use
super
:
:
{
EnumPath
Everywhere
NonOptional
OpaqueOwner
OpaquePath
Optional
OutputOnly
PrimitiveType
StructPath
StructPathLike
TyPosition
TypeContext
TypeId
}
;
use
crate
:
:
ast
;
pub
use
ast
:
:
Mutability
;
pub
use
ast
:
:
StringEncoding
;
use
either
:
:
Either
;
pub
type
OutType
=
Type
<
OutputOnly
>
;
#
[
derive
(
Debug
Clone
)
]
#
[
non_exhaustive
]
pub
enum
Type
<
P
:
TyPosition
=
Everywhere
>
{
Primitive
(
PrimitiveType
)
Opaque
(
OpaquePath
<
Optional
P
:
:
OpaqueOwnership
>
)
Struct
(
P
:
:
StructPath
)
Enum
(
EnumPath
)
Slice
(
Slice
)
}
#
[
derive
(
Debug
Clone
)
]
#
[
non_exhaustive
]
pub
enum
SelfType
{
Opaque
(
OpaquePath
<
NonOptional
Borrow
>
)
Struct
(
StructPath
)
Enum
(
EnumPath
)
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
non_exhaustive
]
pub
enum
Slice
{
Str
(
Option
<
MaybeStatic
<
Lifetime
>
>
StringEncoding
)
Primitive
(
Option
<
Borrow
>
PrimitiveType
)
Strs
(
StringEncoding
)
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
non_exhaustive
]
pub
struct
Borrow
{
pub
lifetime
:
MaybeStatic
<
Lifetime
>
pub
mutability
:
Mutability
}
impl
Type
{
pub
(
super
)
fn
field_leaf_lifetime_counts
(
&
self
tcx
:
&
TypeContext
)
-
>
(
usize
usize
)
{
match
self
{
Type
:
:
Struct
(
ty
)
=
>
ty
.
resolve
(
tcx
)
.
fields
.
iter
(
)
.
fold
(
(
1
0
)
|
acc
field
|
{
let
inner
=
field
.
ty
.
field_leaf_lifetime_counts
(
tcx
)
;
(
acc
.
0
+
inner
.
0
acc
.
1
+
inner
.
1
)
}
)
Type
:
:
Opaque
(
_
)
|
Type
:
:
Slice
(
_
)
=
>
(
1
1
)
Type
:
:
Primitive
(
_
)
|
Type
:
:
Enum
(
_
)
=
>
(
0
0
)
}
}
}
impl
<
P
:
TyPosition
>
Type
<
P
>
{
pub
fn
lifetimes
(
&
self
)
-
>
impl
Iterator
<
Item
=
MaybeStatic
<
Lifetime
>
>
+
'
_
{
match
self
{
Type
:
:
Opaque
(
opaque
)
=
>
Either
:
:
Right
(
opaque
.
lifetimes
.
as_slice
(
)
.
iter
(
)
.
copied
(
)
.
chain
(
opaque
.
owner
.
lifetime
(
)
)
)
Type
:
:
Struct
(
struct_
)
=
>
Either
:
:
Left
(
struct_
.
lifetimes
(
)
.
as_slice
(
)
.
iter
(
)
.
copied
(
)
)
Type
:
:
Slice
(
slice
)
=
>
Either
:
:
Left
(
slice
.
lifetime
(
)
.
map
(
|
lt
|
std
:
:
slice
:
:
from_ref
(
lt
)
.
iter
(
)
.
copied
(
)
)
.
unwrap_or
(
[
]
.
iter
(
)
.
copied
(
)
)
)
_
=
>
Either
:
:
Left
(
[
]
.
iter
(
)
.
copied
(
)
)
}
}
pub
fn
id
(
&
self
)
-
>
Option
<
TypeId
>
{
Some
(
match
self
{
Self
:
:
Opaque
(
p
)
=
>
TypeId
:
:
Opaque
(
p
.
tcx_id
)
Self
:
:
Enum
(
p
)
=
>
TypeId
:
:
Enum
(
p
.
tcx_id
)
Self
:
:
Struct
(
p
)
=
>
p
.
id
(
)
_
=
>
return
None
}
)
}
}
impl
SelfType
{
pub
fn
is_immutably_borrowed
(
&
self
)
-
>
bool
{
match
self
{
SelfType
:
:
Opaque
(
opaque_path
)
=
>
opaque_path
.
owner
.
mutability
=
=
Mutability
:
:
Immutable
_
=
>
false
}
}
}
impl
Slice
{
pub
fn
lifetime
(
&
self
)
-
>
Option
<
&
MaybeStatic
<
Lifetime
>
>
{
match
self
{
Slice
:
:
Str
(
lifetime
.
.
)
=
>
lifetime
.
as_ref
(
)
Slice
:
:
Primitive
(
Some
(
reference
)
.
.
)
=
>
Some
(
&
reference
.
lifetime
)
Slice
:
:
Primitive
(
.
.
)
=
>
None
Slice
:
:
Strs
(
.
.
)
=
>
Some
(
{
const
X
:
MaybeStatic
<
Lifetime
>
=
MaybeStatic
:
:
NonStatic
(
Lifetime
:
:
new
(
usize
:
:
MAX
)
)
;
&
X
}
)
}
}
}
impl
Borrow
{
pub
(
super
)
fn
new
(
lifetime
:
MaybeStatic
<
Lifetime
>
mutability
:
Mutability
)
-
>
Self
{
Self
{
lifetime
mutability
}
}
}
impl
From
<
SelfType
>
for
Type
{
fn
from
(
s
:
SelfType
)
-
>
Type
{
match
s
{
SelfType
:
:
Opaque
(
o
)
=
>
Type
:
:
Opaque
(
o
.
wrap_optional
(
)
)
SelfType
:
:
Struct
(
s
)
=
>
Type
:
:
Struct
(
s
)
SelfType
:
:
Enum
(
e
)
=
>
Type
:
:
Enum
(
e
)
}
}
}
