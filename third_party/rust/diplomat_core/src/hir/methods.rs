use
std
:
:
collections
:
:
BTreeSet
;
use
std
:
:
ops
:
:
Deref
;
use
super
:
:
{
Attrs
Docs
Ident
IdentBuf
OutType
SelfType
Type
TypeContext
}
;
use
super
:
:
lifetimes
:
:
{
Lifetime
LifetimeEnv
Lifetimes
MaybeStatic
}
;
use
borrowing_field
:
:
BorrowingFieldVisitor
;
use
borrowing_param
:
:
BorrowingParamVisitor
;
pub
mod
borrowing_field
;
pub
mod
borrowing_param
;
#
[
derive
(
Debug
)
]
#
[
non_exhaustive
]
pub
struct
Method
{
pub
docs
:
Docs
pub
name
:
IdentBuf
pub
lifetime_env
:
LifetimeEnv
pub
param_self
:
Option
<
ParamSelf
>
pub
params
:
Vec
<
Param
>
pub
output
:
ReturnType
pub
attrs
:
Attrs
}
#
[
derive
(
Debug
Clone
)
]
#
[
non_exhaustive
]
pub
enum
SuccessType
{
Writeable
OutType
(
OutType
)
Unit
}
#
[
derive
(
Debug
)
]
#
[
allow
(
clippy
:
:
exhaustive_enums
)
]
pub
enum
ReturnType
{
Infallible
(
SuccessType
)
Fallible
(
SuccessType
Option
<
OutType
>
)
Nullable
(
SuccessType
)
}
#
[
derive
(
Debug
)
]
#
[
non_exhaustive
]
pub
struct
ParamSelf
{
pub
ty
:
SelfType
}
#
[
derive
(
Debug
)
]
#
[
non_exhaustive
]
pub
struct
Param
{
pub
name
:
IdentBuf
pub
ty
:
Type
}
impl
SuccessType
{
pub
fn
is_writeable
(
&
self
)
-
>
bool
{
matches
!
(
self
SuccessType
:
:
Writeable
)
}
pub
fn
is_unit
(
&
self
)
-
>
bool
{
matches
!
(
self
SuccessType
:
:
Unit
)
}
pub
fn
as_type
(
&
self
)
-
>
Option
<
&
OutType
>
{
match
self
{
SuccessType
:
:
OutType
(
ty
)
=
>
Some
(
ty
)
_
=
>
None
}
}
}
impl
Deref
for
ReturnType
{
type
Target
=
SuccessType
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
match
self
{
ReturnType
:
:
Infallible
(
ret
)
|
ReturnType
:
:
Fallible
(
ret
_
)
|
Self
:
:
Nullable
(
ret
)
=
>
ret
}
}
}
impl
ReturnType
{
pub
fn
is_ffi_unit
(
&
self
)
-
>
bool
{
matches
!
(
self
ReturnType
:
:
Infallible
(
SuccessType
:
:
Unit
|
SuccessType
:
:
Writeable
)
)
}
pub
fn
success_type
(
&
self
)
-
>
&
SuccessType
{
match
&
self
{
Self
:
:
Infallible
(
s
)
=
>
s
Self
:
:
Fallible
(
s
_
)
=
>
s
Self
:
:
Nullable
(
s
)
=
>
s
}
}
pub
fn
used_method_lifetimes
(
&
self
)
-
>
BTreeSet
<
Lifetime
>
{
let
mut
set
=
BTreeSet
:
:
new
(
)
;
let
mut
add_to_set
=
|
ty
:
&
OutType
|
{
for
lt
in
ty
.
lifetimes
(
)
{
if
let
MaybeStatic
:
:
NonStatic
(
lt
)
=
lt
{
set
.
insert
(
lt
)
;
}
}
}
;
match
self
{
ReturnType
:
:
Infallible
(
SuccessType
:
:
OutType
(
ref
ty
)
)
|
ReturnType
:
:
Nullable
(
SuccessType
:
:
OutType
(
ref
ty
)
)
=
>
add_to_set
(
ty
)
ReturnType
:
:
Fallible
(
ref
ok
ref
err
)
=
>
{
if
let
SuccessType
:
:
OutType
(
ref
ty
)
=
ok
{
add_to_set
(
ty
)
}
if
let
Some
(
ref
ty
)
=
err
{
add_to_set
(
ty
)
}
}
_
=
>
(
)
}
set
}
pub
fn
with_contained_types
(
&
self
mut
f
:
impl
FnMut
(
&
OutType
)
)
{
match
self
{
Self
:
:
Infallible
(
SuccessType
:
:
OutType
(
o
)
)
|
Self
:
:
Nullable
(
SuccessType
:
:
OutType
(
o
)
)
|
Self
:
:
Fallible
(
SuccessType
:
:
OutType
(
o
)
None
)
=
>
f
(
o
)
Self
:
:
Fallible
(
SuccessType
:
:
OutType
(
o
)
Some
(
o2
)
)
=
>
{
f
(
o
)
;
f
(
o2
)
}
Self
:
:
Fallible
(
_
Some
(
o
)
)
=
>
f
(
o
)
_
=
>
(
)
}
}
}
impl
ParamSelf
{
pub
(
super
)
fn
new
(
ty
:
SelfType
)
-
>
Self
{
Self
{
ty
}
}
fn
field_leaf_lifetime_counts
(
&
self
tcx
:
&
TypeContext
)
-
>
(
usize
usize
)
{
match
self
.
ty
{
SelfType
:
:
Opaque
(
_
)
=
>
(
1
1
)
SelfType
:
:
Struct
(
ref
ty
)
=
>
ty
.
resolve
(
tcx
)
.
fields
.
iter
(
)
.
fold
(
(
1
0
)
|
acc
field
|
{
let
inner
=
field
.
ty
.
field_leaf_lifetime_counts
(
tcx
)
;
(
acc
.
0
+
inner
.
0
acc
.
1
+
inner
.
1
)
}
)
SelfType
:
:
Enum
(
_
)
=
>
(
0
0
)
}
}
}
impl
Param
{
pub
(
super
)
fn
new
(
name
:
IdentBuf
ty
:
Type
)
-
>
Self
{
Self
{
name
ty
}
}
}
impl
Method
{
pub
fn
method_lifetimes
(
&
self
)
-
>
Lifetimes
{
self
.
lifetime_env
.
lifetimes
(
)
}
pub
fn
borrowing_param_visitor
<
'
tcx
>
(
&
'
tcx
self
tcx
:
&
'
tcx
TypeContext
)
-
>
BorrowingParamVisitor
<
'
tcx
>
{
BorrowingParamVisitor
:
:
new
(
self
tcx
)
}
pub
fn
borrowing_field_visitor
<
'
m
>
(
&
'
m
self
tcx
:
&
'
m
TypeContext
self_name
:
&
'
m
Ident
)
-
>
BorrowingFieldVisitor
<
'
m
>
{
BorrowingFieldVisitor
:
:
new
(
self
tcx
self_name
)
}
}
