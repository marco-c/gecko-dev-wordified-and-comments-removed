#
!
[
allow
(
dead_code
)
]
use
super
:
:
IdentBuf
;
use
crate
:
:
ast
;
use
smallvec
:
:
{
smallvec
SmallVec
}
;
const
INLINE_NUM_LIFETIMES
:
usize
=
4
;
#
[
derive
(
Debug
)
]
pub
struct
LifetimeEnv
{
nodes
:
SmallVec
<
[
Lifetime
;
INLINE_NUM_LIFETIMES
]
>
num_lifetimes
:
usize
}
#
[
derive
(
Debug
)
]
pub
(
super
)
struct
Lifetime
{
ident
:
IdentBuf
longer
:
SmallVec
<
[
MethodLifetime
;
2
]
>
shorter
:
SmallVec
<
[
MethodLifetime
;
2
]
>
}
impl
Lifetime
{
pub
(
super
)
fn
new
(
ident
:
IdentBuf
longer
:
SmallVec
<
[
MethodLifetime
;
2
]
>
shorter
:
SmallVec
<
[
MethodLifetime
;
2
]
>
)
-
>
Self
{
Self
{
ident
longer
shorter
}
}
}
pub
struct
SubtypeLifetimeVisitor
<
'
lt
F
>
{
lifetime_env
:
&
'
lt
LifetimeEnv
visited
:
SmallVec
<
[
bool
;
INLINE_NUM_LIFETIMES
]
>
visit_fn
:
F
}
impl
<
'
lt
F
>
SubtypeLifetimeVisitor
<
'
lt
F
>
where
F
:
FnMut
(
MethodLifetime
)
{
fn
new
(
lifetime_env
:
&
'
lt
LifetimeEnv
visit_fn
:
F
)
-
>
Self
{
Self
{
lifetime_env
visited
:
smallvec
!
[
false
;
lifetime_env
.
nodes
.
len
(
)
]
visit_fn
}
}
pub
fn
visit_subtypes
(
&
mut
self
method_lifetime
:
MethodLifetime
)
{
if
let
Some
(
visited
false
)
=
self
.
visited
.
get_mut
(
method_lifetime
.
0
)
{
*
visited
=
true
;
(
self
.
visit_fn
)
(
method_lifetime
)
;
for
longer
in
self
.
lifetime_env
.
nodes
[
method_lifetime
.
0
]
.
longer
.
iter
(
)
{
self
.
visit_subtypes
(
*
longer
)
}
}
else
{
debug_assert
!
(
method_lifetime
.
0
>
self
.
lifetime_env
.
num_lifetimes
"
method
lifetime
has
an
internal
index
that
'
s
not
in
range
of
the
lifetime
env
"
)
;
}
}
}
#
[
derive
(
Copy
Clone
Debug
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
enum
MaybeStatic
<
T
>
{
Static
NonStatic
(
T
)
}
impl
<
T
>
MaybeStatic
<
T
>
{
pub
(
super
)
fn
map_nonstatic
<
F
R
>
(
self
f
:
F
)
-
>
MaybeStatic
<
R
>
where
F
:
FnOnce
(
T
)
-
>
R
{
match
self
{
MaybeStatic
:
:
Static
=
>
MaybeStatic
:
:
Static
MaybeStatic
:
:
NonStatic
(
lifetime
)
=
>
MaybeStatic
:
:
NonStatic
(
f
(
lifetime
)
)
}
}
pub
(
super
)
fn
flat_map_nonstatic
<
R
F
>
(
self
f
:
F
)
-
>
MaybeStatic
<
R
>
where
F
:
FnOnce
(
T
)
-
>
MaybeStatic
<
R
>
{
match
self
{
MaybeStatic
:
:
Static
=
>
MaybeStatic
:
:
Static
MaybeStatic
:
:
NonStatic
(
lifetime
)
=
>
f
(
lifetime
)
}
}
}
#
[
derive
(
Copy
Clone
Debug
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
TypeLifetime
(
usize
)
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
TypeLifetimes
{
indices
:
SmallVec
<
[
MaybeStatic
<
TypeLifetime
>
;
2
]
>
}
#
[
derive
(
Copy
Clone
Debug
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
MethodLifetime
(
usize
)
;
pub
struct
MethodLifetimes
{
indices
:
SmallVec
<
[
MaybeStatic
<
MethodLifetime
>
;
2
]
>
}
impl
LifetimeEnv
{
pub
(
super
)
fn
new
(
nodes
:
SmallVec
<
[
Lifetime
;
INLINE_NUM_LIFETIMES
]
>
num_lifetimes
:
usize
)
-
>
Self
{
Self
{
nodes
num_lifetimes
}
}
pub
fn
method_lifetimes
(
&
self
)
-
>
MethodLifetimes
{
let
indices
=
(
0
.
.
self
.
num_lifetimes
)
.
map
(
|
index
|
MaybeStatic
:
:
NonStatic
(
MethodLifetime
(
index
)
)
)
.
collect
(
)
;
MethodLifetimes
{
indices
}
}
pub
fn
subtype_lifetimes_visitor
<
F
>
(
&
self
visit_fn
:
F
)
-
>
SubtypeLifetimeVisitor
<
'
_
F
>
where
F
:
FnMut
(
MethodLifetime
)
{
SubtypeLifetimeVisitor
:
:
new
(
self
visit_fn
)
}
}
impl
TypeLifetime
{
pub
(
super
)
fn
from_ast
(
named
:
&
ast
:
:
NamedLifetime
lifetime_env
:
&
ast
:
:
LifetimeEnv
)
-
>
Self
{
let
index
=
lifetime_env
.
id
(
named
)
.
unwrap_or_else
(
|
|
panic
!
(
"
lifetime
{
named
}
not
found
in
lifetime
env
"
)
)
;
Self
(
index
)
}
pub
(
super
)
fn
new
(
index
:
usize
)
-
>
Self
{
Self
(
index
)
}
pub
fn
as_method_lifetime
(
self
method_lifetimes
:
&
MethodLifetimes
)
-
>
MaybeStatic
<
MethodLifetime
>
{
method_lifetimes
.
indices
[
self
.
0
]
}
}
impl
TypeLifetimes
{
pub
(
super
)
fn
from_fn
<
F
>
(
lifetimes
:
&
[
ast
:
:
Lifetime
]
lower_fn
:
F
)
-
>
Self
where
F
:
FnMut
(
&
ast
:
:
Lifetime
)
-
>
MaybeStatic
<
TypeLifetime
>
{
Self
{
indices
:
lifetimes
.
iter
(
)
.
map
(
lower_fn
)
.
collect
(
)
}
}
pub
fn
as_method_lifetimes
(
&
self
method_lifetimes
:
&
MethodLifetimes
)
-
>
MethodLifetimes
{
let
indices
=
self
.
indices
.
iter
(
)
.
map
(
|
maybe_static_lt
|
{
maybe_static_lt
.
flat_map_nonstatic
(
|
lt
|
lt
.
as_method_lifetime
(
method_lifetimes
)
)
}
)
.
collect
(
)
;
MethodLifetimes
{
indices
}
}
}
impl
MethodLifetime
{
pub
(
super
)
fn
new
(
index
:
usize
)
-
>
Self
{
Self
(
index
)
}
}
impl
MethodLifetimes
{
pub
(
super
)
fn
lifetimes
(
&
self
)
-
>
impl
Iterator
<
Item
=
MaybeStatic
<
MethodLifetime
>
>
+
'
_
{
self
.
indices
.
iter
(
)
.
copied
(
)
}
}
