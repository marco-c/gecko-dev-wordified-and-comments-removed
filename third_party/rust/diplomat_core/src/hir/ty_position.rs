use
super
:
:
lifetimes
:
:
{
Lifetime
Lifetimes
MaybeStatic
}
;
use
super
:
:
{
Borrow
Callback
CallbackInstantiationFunctionality
LinkedLifetimes
MaybeOwn
Mutability
NoCallback
NoTraitPath
OutStructId
ReturnableStructPath
StructDef
StructId
StructPath
TraitId
TraitPath
TypeContext
TypeDef
TypeId
}
;
use
core
:
:
fmt
:
:
Debug
;
pub
trait
TyPosition
:
Debug
+
Copy
where
for
<
'
tcx
>
TypeDef
<
'
tcx
>
:
From
<
&
'
tcx
StructDef
<
Self
>
>
{
const
IN_OUT_STATUS
:
InputOrOutput
;
type
CallbackInstantiation
:
Debug
+
CallbackInstantiationFunctionality
;
type
OpaqueOwnership
:
Debug
+
OpaqueOwner
;
type
StructId
:
Debug
;
type
StructPath
:
Debug
+
StructPathLike
;
type
TraitPath
:
Debug
+
TraitIdGetter
;
fn
wrap_struct_def
<
'
tcx
>
(
def
:
&
'
tcx
StructDef
<
Self
>
)
-
>
TypeDef
<
'
tcx
>
;
fn
build_callback
(
cb
:
Callback
)
-
>
Self
:
:
CallbackInstantiation
;
fn
build_trait_path
(
trait_path
:
TraitPath
)
-
>
Self
:
:
TraitPath
;
}
#
[
non_exhaustive
]
pub
enum
InputOrOutput
{
Input
Output
InputOutput
}
pub
trait
TraitIdGetter
{
fn
id
(
&
self
)
-
>
TraitId
;
}
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
non_exhaustive
]
pub
struct
Everywhere
;
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
non_exhaustive
]
pub
struct
OutputOnly
;
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
non_exhaustive
]
pub
struct
InputOnly
;
impl
TyPosition
for
Everywhere
{
const
IN_OUT_STATUS
:
InputOrOutput
=
InputOrOutput
:
:
InputOutput
;
type
OpaqueOwnership
=
Borrow
;
type
StructId
=
StructId
;
type
StructPath
=
StructPath
;
type
CallbackInstantiation
=
NoCallback
;
type
TraitPath
=
NoTraitPath
;
fn
wrap_struct_def
<
'
tcx
>
(
def
:
&
'
tcx
StructDef
<
Self
>
)
-
>
TypeDef
<
'
tcx
>
{
TypeDef
:
:
Struct
(
def
)
}
fn
build_callback
(
_cb
:
Callback
)
-
>
Self
:
:
CallbackInstantiation
{
panic
!
(
"
Callbacks
must
be
input
-
only
"
)
;
}
fn
build_trait_path
(
_trait_path
:
TraitPath
)
-
>
Self
:
:
TraitPath
{
panic
!
(
"
Traits
must
be
input
-
only
"
)
;
}
}
impl
TyPosition
for
OutputOnly
{
const
IN_OUT_STATUS
:
InputOrOutput
=
InputOrOutput
:
:
Output
;
type
OpaqueOwnership
=
MaybeOwn
;
type
StructId
=
OutStructId
;
type
StructPath
=
ReturnableStructPath
;
type
CallbackInstantiation
=
NoCallback
;
type
TraitPath
=
NoTraitPath
;
fn
wrap_struct_def
<
'
tcx
>
(
def
:
&
'
tcx
StructDef
<
Self
>
)
-
>
TypeDef
<
'
tcx
>
{
TypeDef
:
:
OutStruct
(
def
)
}
fn
build_callback
(
_cb
:
Callback
)
-
>
Self
:
:
CallbackInstantiation
{
panic
!
(
"
Callbacks
must
be
input
-
only
"
)
;
}
fn
build_trait_path
(
_trait_path
:
TraitPath
)
-
>
Self
:
:
TraitPath
{
panic
!
(
"
Traits
must
be
input
-
only
"
)
;
}
}
impl
TyPosition
for
InputOnly
{
const
IN_OUT_STATUS
:
InputOrOutput
=
InputOrOutput
:
:
Input
;
type
OpaqueOwnership
=
Borrow
;
type
StructId
=
StructId
;
type
StructPath
=
StructPath
;
type
CallbackInstantiation
=
Callback
;
type
TraitPath
=
TraitPath
;
fn
wrap_struct_def
<
'
tcx
>
(
_def
:
&
'
tcx
StructDef
<
Self
>
)
-
>
TypeDef
<
'
tcx
>
{
panic
!
(
"
Input
-
only
structs
are
not
currently
supported
"
)
;
}
fn
build_callback
(
cb
:
Callback
)
-
>
Self
:
:
CallbackInstantiation
{
cb
}
fn
build_trait_path
(
trait_path
:
TraitPath
)
-
>
Self
:
:
TraitPath
{
trait_path
}
}
pub
trait
StructPathLike
{
fn
lifetimes
(
&
self
)
-
>
&
Lifetimes
;
fn
id
(
&
self
)
-
>
TypeId
;
fn
link_lifetimes
<
'
def
'
tcx
>
(
&
'
def
self
tcx
:
&
'
tcx
TypeContext
)
-
>
LinkedLifetimes
<
'
def
'
tcx
>
;
}
impl
StructPathLike
for
StructPath
{
fn
lifetimes
(
&
self
)
-
>
&
Lifetimes
{
&
self
.
lifetimes
}
fn
id
(
&
self
)
-
>
TypeId
{
self
.
tcx_id
.
into
(
)
}
fn
link_lifetimes
<
'
def
'
tcx
>
(
&
'
def
self
tcx
:
&
'
tcx
TypeContext
)
-
>
LinkedLifetimes
<
'
def
'
tcx
>
{
let
struc
=
self
.
resolve
(
tcx
)
;
let
env
=
&
struc
.
lifetimes
;
LinkedLifetimes
:
:
new
(
env
None
&
self
.
lifetimes
)
}
}
impl
StructPathLike
for
ReturnableStructPath
{
fn
lifetimes
(
&
self
)
-
>
&
Lifetimes
{
self
.
lifetimes
(
)
}
fn
id
(
&
self
)
-
>
TypeId
{
match
self
{
ReturnableStructPath
:
:
Struct
(
p
)
=
>
p
.
tcx_id
.
into
(
)
ReturnableStructPath
:
:
OutStruct
(
p
)
=
>
p
.
tcx_id
.
into
(
)
}
}
fn
link_lifetimes
<
'
def
'
tcx
>
(
&
'
def
self
tcx
:
&
'
tcx
TypeContext
)
-
>
LinkedLifetimes
<
'
def
'
tcx
>
{
match
self
{
Self
:
:
Struct
(
p
)
=
>
p
.
link_lifetimes
(
tcx
)
Self
:
:
OutStruct
(
p
)
=
>
p
.
link_lifetimes
(
tcx
)
}
}
}
impl
TraitIdGetter
for
TraitPath
{
fn
id
(
&
self
)
-
>
TraitId
{
self
.
tcx_id
}
}
impl
TraitIdGetter
for
NoTraitPath
{
fn
id
(
&
self
)
-
>
TraitId
{
panic
!
(
"
Trait
path
not
allowed
here
no
trait
ID
valid
"
)
;
}
}
pub
trait
OpaqueOwner
{
fn
mutability
(
&
self
)
-
>
Option
<
Mutability
>
;
fn
is_owned
(
&
self
)
-
>
bool
;
fn
lifetime
(
&
self
)
-
>
Option
<
MaybeStatic
<
Lifetime
>
>
;
}
impl
OpaqueOwner
for
MaybeOwn
{
fn
mutability
(
&
self
)
-
>
Option
<
Mutability
>
{
match
self
{
MaybeOwn
:
:
Own
=
>
None
MaybeOwn
:
:
Borrow
(
b
)
=
>
b
.
mutability
(
)
}
}
fn
is_owned
(
&
self
)
-
>
bool
{
match
self
{
MaybeOwn
:
:
Own
=
>
true
MaybeOwn
:
:
Borrow
(
_
)
=
>
false
}
}
fn
lifetime
(
&
self
)
-
>
Option
<
MaybeStatic
<
Lifetime
>
>
{
match
self
{
MaybeOwn
:
:
Own
=
>
None
MaybeOwn
:
:
Borrow
(
b
)
=
>
b
.
lifetime
(
)
}
}
}
impl
OpaqueOwner
for
Borrow
{
fn
mutability
(
&
self
)
-
>
Option
<
Mutability
>
{
Some
(
self
.
mutability
)
}
fn
is_owned
(
&
self
)
-
>
bool
{
false
}
fn
lifetime
(
&
self
)
-
>
Option
<
MaybeStatic
<
Lifetime
>
>
{
Some
(
self
.
lifetime
)
}
}
