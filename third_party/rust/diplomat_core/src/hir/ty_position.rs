use
super
:
:
lifetimes
:
:
{
Lifetime
Lifetimes
MaybeStatic
}
;
use
super
:
:
{
Borrow
LinkedLifetimes
MaybeOwn
Mutability
OutStructId
ReturnableStructPath
StructId
StructPath
TypeContext
TypeId
}
;
use
core
:
:
fmt
:
:
Debug
;
pub
trait
TyPosition
:
Debug
+
Copy
{
const
IS_OUT_ONLY
:
bool
;
type
OpaqueOwnership
:
Debug
+
OpaqueOwner
;
type
StructId
:
Debug
;
type
StructPath
:
Debug
+
StructPathLike
;
}
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
non_exhaustive
]
pub
struct
Everywhere
;
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
non_exhaustive
]
pub
struct
OutputOnly
;
impl
TyPosition
for
Everywhere
{
const
IS_OUT_ONLY
:
bool
=
false
;
type
OpaqueOwnership
=
Borrow
;
type
StructId
=
StructId
;
type
StructPath
=
StructPath
;
}
impl
TyPosition
for
OutputOnly
{
const
IS_OUT_ONLY
:
bool
=
true
;
type
OpaqueOwnership
=
MaybeOwn
;
type
StructId
=
OutStructId
;
type
StructPath
=
ReturnableStructPath
;
}
pub
trait
StructPathLike
{
fn
lifetimes
(
&
self
)
-
>
&
Lifetimes
;
fn
id
(
&
self
)
-
>
TypeId
;
fn
link_lifetimes
<
'
def
'
tcx
>
(
&
'
def
self
tcx
:
&
'
tcx
TypeContext
)
-
>
LinkedLifetimes
<
'
def
'
tcx
>
;
}
impl
StructPathLike
for
StructPath
{
fn
lifetimes
(
&
self
)
-
>
&
Lifetimes
{
&
self
.
lifetimes
}
fn
id
(
&
self
)
-
>
TypeId
{
self
.
tcx_id
.
into
(
)
}
fn
link_lifetimes
<
'
def
'
tcx
>
(
&
'
def
self
tcx
:
&
'
tcx
TypeContext
)
-
>
LinkedLifetimes
<
'
def
'
tcx
>
{
let
struc
=
self
.
resolve
(
tcx
)
;
let
env
=
&
struc
.
lifetimes
;
LinkedLifetimes
:
:
new
(
env
None
&
self
.
lifetimes
)
}
}
impl
StructPathLike
for
ReturnableStructPath
{
fn
lifetimes
(
&
self
)
-
>
&
Lifetimes
{
self
.
lifetimes
(
)
}
fn
id
(
&
self
)
-
>
TypeId
{
match
self
{
ReturnableStructPath
:
:
Struct
(
p
)
=
>
p
.
tcx_id
.
into
(
)
ReturnableStructPath
:
:
OutStruct
(
p
)
=
>
p
.
tcx_id
.
into
(
)
}
}
fn
link_lifetimes
<
'
def
'
tcx
>
(
&
'
def
self
tcx
:
&
'
tcx
TypeContext
)
-
>
LinkedLifetimes
<
'
def
'
tcx
>
{
match
self
{
Self
:
:
Struct
(
p
)
=
>
p
.
link_lifetimes
(
tcx
)
Self
:
:
OutStruct
(
p
)
=
>
p
.
link_lifetimes
(
tcx
)
}
}
}
pub
trait
OpaqueOwner
{
fn
mutability
(
&
self
)
-
>
Option
<
Mutability
>
;
fn
is_owned
(
&
self
)
-
>
bool
;
fn
lifetime
(
&
self
)
-
>
Option
<
MaybeStatic
<
Lifetime
>
>
;
}
impl
OpaqueOwner
for
MaybeOwn
{
fn
mutability
(
&
self
)
-
>
Option
<
Mutability
>
{
match
self
{
MaybeOwn
:
:
Own
=
>
None
MaybeOwn
:
:
Borrow
(
b
)
=
>
b
.
mutability
(
)
}
}
fn
is_owned
(
&
self
)
-
>
bool
{
match
self
{
MaybeOwn
:
:
Own
=
>
true
MaybeOwn
:
:
Borrow
(
_
)
=
>
false
}
}
fn
lifetime
(
&
self
)
-
>
Option
<
MaybeStatic
<
Lifetime
>
>
{
match
self
{
MaybeOwn
:
:
Own
=
>
None
MaybeOwn
:
:
Borrow
(
b
)
=
>
b
.
lifetime
(
)
}
}
}
impl
OpaqueOwner
for
Borrow
{
fn
mutability
(
&
self
)
-
>
Option
<
Mutability
>
{
Some
(
self
.
mutability
)
}
fn
is_owned
(
&
self
)
-
>
bool
{
false
}
fn
lifetime
(
&
self
)
-
>
Option
<
MaybeStatic
<
Lifetime
>
>
{
Some
(
self
.
lifetime
)
}
}
