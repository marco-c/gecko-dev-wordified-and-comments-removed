#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__unless_target_features
{
(
(
tf
:
tt
)
+
=
>
body
:
expr
)
=
>
{
{
#
[
cfg
(
not
(
all
(
(
target_feature
=
tf
)
*
)
)
)
]
body
#
[
cfg
(
all
(
(
target_feature
=
tf
)
*
)
)
]
true
}
}
;
}
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__detect_target_features
{
(
(
tf
:
tt
)
+
)
=
>
{
{
let
hwcaps
=
crate
:
:
aarch64
:
:
getauxval_hwcap
(
)
;
(
crate
:
:
check
!
(
hwcaps
tf
)
&
)
+
true
}
}
;
}
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
pub
fn
getauxval_hwcap
(
)
-
>
u64
{
unsafe
{
libc
:
:
getauxval
(
libc
:
:
AT_HWCAP
)
}
}
#
[
cfg
(
target_vendor
=
"
apple
"
)
]
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__detect_target_features
{
(
(
tf
:
tt
)
+
)
=
>
{
{
(
crate
:
:
check
!
(
tf
)
&
)
+
true
}
}
;
}
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
macro_rules
!
__expand_check_macro
{
(
(
(
name
:
tt
hwcap
:
ident
)
)
*
(
)
?
)
=
>
{
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
check
{
(
(
hwcaps
:
expr
name
)
=
>
{
(
(
hwcaps
&
crate
:
:
aarch64
:
:
hwcaps
:
:
hwcap
)
!
=
0
)
}
;
)
*
}
}
;
}
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
__expand_check_macro
!
{
(
"
aes
"
AES
)
/
/
Enable
AES
support
.
(
"
sha2
"
SHA2
)
/
/
Enable
SHA1
and
SHA256
support
.
(
"
sha3
"
SHA3
)
/
/
Enable
SHA512
and
SHA3
support
.
}
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
pub
mod
hwcaps
{
use
libc
:
:
c_ulong
;
pub
const
AES
:
c_ulong
=
libc
:
:
HWCAP_AES
|
libc
:
:
HWCAP_PMULL
;
pub
const
SHA2
:
c_ulong
=
libc
:
:
HWCAP_SHA2
;
pub
const
SHA3
:
c_ulong
=
libc
:
:
HWCAP_SHA3
|
libc
:
:
HWCAP_SHA512
;
}
#
[
cfg
(
target_vendor
=
"
apple
"
)
]
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
check
{
(
"
aes
"
)
=
>
{
true
}
;
(
"
sha2
"
)
=
>
{
true
}
;
(
"
sha3
"
)
=
>
{
unsafe
{
/
/
sha3
target
feature
implies
SHA
-
512
as
well
crate
:
:
aarch64
:
:
sysctlbyname
(
b
"
hw
.
optional
.
armv8_2_sha512
\
0
"
)
&
&
crate
:
:
aarch64
:
:
sysctlbyname
(
b
"
hw
.
optional
.
armv8_2_sha3
\
0
"
)
}
}
;
}
#
[
cfg
(
target_vendor
=
"
apple
"
)
]
pub
unsafe
fn
sysctlbyname
(
name
:
&
[
u8
]
)
-
>
bool
{
assert_eq
!
(
name
.
last
(
)
.
cloned
(
)
Some
(
0
)
"
name
is
not
NUL
terminated
:
{
:
?
}
"
name
)
;
let
mut
value
:
u32
=
0
;
let
mut
size
=
core
:
:
mem
:
:
size_of
:
:
<
u32
>
(
)
;
let
rc
=
libc
:
:
sysctlbyname
(
name
.
as_ptr
(
)
as
*
const
i8
&
mut
value
as
*
mut
_
as
*
mut
libc
:
:
c_void
&
mut
size
core
:
:
ptr
:
:
null_mut
(
)
0
)
;
assert_eq
!
(
size
4
"
unexpected
sysctlbyname
(
3
)
result
size
"
)
;
assert_eq
!
(
rc
0
"
sysctlbyname
returned
error
code
:
{
}
"
rc
)
;
value
!
=
0
}
#
[
cfg
(
not
(
any
(
target_vendor
=
"
apple
"
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
)
]
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__detect_target_features
{
(
(
tf
:
tt
)
+
)
=
>
{
false
}
;
}
