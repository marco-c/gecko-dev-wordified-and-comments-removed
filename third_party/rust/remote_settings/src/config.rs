use
url
:
:
Url
;
use
crate
:
:
{
ApiResult
Error
RemoteSettingsContext
Result
}
;
#
[
derive
(
Debug
Default
Clone
uniffi
:
:
Record
)
]
pub
struct
RemoteSettingsConfig2
{
#
[
uniffi
(
default
=
None
)
]
pub
server
:
Option
<
RemoteSettingsServer
>
#
[
uniffi
(
default
=
None
)
]
pub
bucket_name
:
Option
<
String
>
#
[
uniffi
(
default
=
None
)
]
pub
app_context
:
Option
<
RemoteSettingsContext
>
}
#
[
derive
(
Debug
Clone
uniffi
:
:
Record
)
]
pub
struct
RemoteSettingsConfig
{
pub
collection_name
:
String
#
[
uniffi
(
default
=
None
)
]
pub
bucket_name
:
Option
<
String
>
#
[
uniffi
(
default
=
None
)
]
pub
server_url
:
Option
<
String
>
#
[
uniffi
(
default
=
None
)
]
pub
server
:
Option
<
RemoteSettingsServer
>
}
#
[
derive
(
Debug
Clone
uniffi
:
:
Enum
)
]
pub
enum
RemoteSettingsServer
{
Prod
Stage
Dev
Custom
{
url
:
String
}
}
impl
RemoteSettingsServer
{
#
[
error_support
:
:
handle_error
(
Error
)
]
pub
fn
url
(
&
self
)
-
>
ApiResult
<
Url
>
{
self
.
get_url
(
)
}
pub
fn
get_base_url
(
&
self
)
-
>
Result
<
BaseUrl
>
{
let
base_url
=
BaseUrl
:
:
parse
(
self
.
raw_url
(
)
)
?
;
if
base_url
.
url
(
)
.
scheme
(
)
!
=
"
file
"
{
Ok
(
base_url
.
join
(
"
v1
"
)
)
}
else
{
Ok
(
base_url
)
}
}
pub
fn
get_base_url_with_prod_fallback
(
&
self
)
-
>
BaseUrl
{
match
self
.
get_base_url
(
)
{
Ok
(
url
)
=
>
url
Err
(
_
)
=
>
{
log
:
:
warn
!
(
"
Invalid
Custom
URL
:
{
}
"
self
.
raw_url
(
)
)
;
BaseUrl
:
:
parse
(
Self
:
:
Prod
.
raw_url
(
)
)
.
unwrap
(
)
}
}
}
fn
raw_url
(
&
self
)
-
>
&
str
{
match
self
{
Self
:
:
Prod
=
>
"
https
:
/
/
firefox
.
settings
.
services
.
mozilla
.
com
/
v1
"
Self
:
:
Stage
=
>
"
https
:
/
/
firefox
.
settings
.
services
.
allizom
.
org
/
v1
"
Self
:
:
Dev
=
>
"
https
:
/
/
remote
-
settings
-
dev
.
allizom
.
org
/
v1
"
Self
:
:
Custom
{
url
}
=
>
url
}
}
pub
fn
get_url
(
&
self
)
-
>
Result
<
Url
>
{
Ok
(
match
self
{
Self
:
:
Prod
=
>
Url
:
:
parse
(
"
https
:
/
/
firefox
.
settings
.
services
.
mozilla
.
com
/
v1
"
)
?
Self
:
:
Stage
=
>
Url
:
:
parse
(
"
https
:
/
/
firefox
.
settings
.
services
.
allizom
.
org
/
v1
"
)
?
Self
:
:
Dev
=
>
Url
:
:
parse
(
"
https
:
/
/
remote
-
settings
-
dev
.
allizom
.
org
/
v1
"
)
?
Self
:
:
Custom
{
url
}
=
>
{
let
mut
url
=
Url
:
:
parse
(
url
)
?
;
if
url
.
scheme
(
)
!
=
"
file
"
{
url
=
url
.
join
(
"
v1
"
)
?
}
url
}
}
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
BaseUrl
{
url
:
Url
}
impl
BaseUrl
{
pub
fn
parse
(
url
:
&
str
)
-
>
Result
<
Self
>
{
let
url
=
Url
:
:
parse
(
url
)
?
;
if
url
.
cannot_be_a_base
(
)
{
Err
(
Error
:
:
UrlParsingError
(
url
:
:
ParseError
:
:
RelativeUrlWithCannotBeABaseBase
)
)
}
else
{
Ok
(
Self
{
url
}
)
}
}
pub
fn
url
(
&
self
)
-
>
&
Url
{
&
self
.
url
}
pub
fn
into_inner
(
self
)
-
>
Url
{
self
.
url
}
pub
fn
join
(
&
self
input
:
&
str
)
-
>
BaseUrl
{
Self
{
url
:
self
.
url
.
join
(
input
)
.
unwrap
(
)
}
}
pub
fn
path_segments_mut
(
&
mut
self
)
-
>
url
:
:
PathSegmentsMut
<
'
_
>
{
self
.
url
.
path_segments_mut
(
)
.
unwrap
(
)
}
}
