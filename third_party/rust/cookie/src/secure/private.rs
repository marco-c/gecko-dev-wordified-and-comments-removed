use
secure
:
:
ring
:
:
aead
:
:
{
seal_in_place
open_in_place
Algorithm
AES_256_GCM
}
;
use
secure
:
:
ring
:
:
aead
:
:
{
OpeningKey
SealingKey
}
;
use
secure
:
:
ring
:
:
rand
:
:
{
SecureRandom
SystemRandom
}
;
use
secure
:
:
{
base64
Key
}
;
use
{
Cookie
CookieJar
}
;
static
ALGO
:
&
'
static
Algorithm
=
&
AES_256_GCM
;
const
NONCE_LEN
:
usize
=
12
;
pub
const
KEY_LEN
:
usize
=
32
;
pub
struct
PrivateJar
<
'
a
>
{
parent
:
&
'
a
mut
CookieJar
key
:
[
u8
;
KEY_LEN
]
}
impl
<
'
a
>
PrivateJar
<
'
a
>
{
#
[
doc
(
hidden
)
]
pub
fn
new
(
parent
:
&
'
a
mut
CookieJar
key
:
&
Key
)
-
>
PrivateJar
<
'
a
>
{
let
mut
key_array
=
[
0u8
;
KEY_LEN
]
;
key_array
.
copy_from_slice
(
key
.
encryption
(
)
)
;
PrivateJar
{
parent
:
parent
key
:
key_array
}
}
fn
unseal
(
&
self
name
:
&
str
value
:
&
str
)
-
>
Result
<
String
&
'
static
str
>
{
let
mut
data
=
base64
:
:
decode
(
value
)
.
map_err
(
|
_
|
"
bad
base64
value
"
)
?
;
if
data
.
len
(
)
<
=
NONCE_LEN
{
return
Err
(
"
length
of
decoded
data
is
<
=
NONCE_LEN
"
)
;
}
let
ad
=
name
.
as_bytes
(
)
;
let
key
=
OpeningKey
:
:
new
(
ALGO
&
self
.
key
)
.
expect
(
"
opening
key
"
)
;
let
(
nonce
sealed
)
=
data
.
split_at_mut
(
NONCE_LEN
)
;
let
unsealed
=
open_in_place
(
&
key
nonce
ad
0
sealed
)
.
map_err
(
|
_
|
"
invalid
key
/
nonce
/
value
:
bad
seal
"
)
?
;
:
:
std
:
:
str
:
:
from_utf8
(
unsealed
)
.
map
(
|
s
|
s
.
to_string
(
)
)
.
map_err
(
|
_
|
"
bad
unsealed
utf8
"
)
}
pub
fn
get
(
&
self
name
:
&
str
)
-
>
Option
<
Cookie
<
'
static
>
>
{
if
let
Some
(
cookie_ref
)
=
self
.
parent
.
get
(
name
)
{
let
mut
cookie
=
cookie_ref
.
clone
(
)
;
if
let
Ok
(
value
)
=
self
.
unseal
(
name
cookie
.
value
(
)
)
{
cookie
.
set_value
(
value
)
;
return
Some
(
cookie
)
;
}
}
None
}
pub
fn
add
(
&
mut
self
mut
cookie
:
Cookie
<
'
static
>
)
{
self
.
encrypt_cookie
(
&
mut
cookie
)
;
self
.
parent
.
add
(
cookie
)
;
}
pub
fn
add_original
(
&
mut
self
mut
cookie
:
Cookie
<
'
static
>
)
{
self
.
encrypt_cookie
(
&
mut
cookie
)
;
self
.
parent
.
add_original
(
cookie
)
;
}
fn
encrypt_cookie
(
&
self
cookie
:
&
mut
Cookie
)
{
let
mut
data
;
let
output_len
=
{
let
key
=
SealingKey
:
:
new
(
ALGO
&
self
.
key
)
.
expect
(
"
sealing
key
creation
"
)
;
let
overhead
=
ALGO
.
tag_len
(
)
;
let
cookie_val
=
cookie
.
value
(
)
.
as_bytes
(
)
;
data
=
vec
!
[
0
;
NONCE_LEN
+
cookie_val
.
len
(
)
+
overhead
]
;
let
(
nonce
in_out
)
=
data
.
split_at_mut
(
NONCE_LEN
)
;
SystemRandom
:
:
new
(
)
.
fill
(
nonce
)
.
expect
(
"
couldn
'
t
random
fill
nonce
"
)
;
in_out
[
.
.
cookie_val
.
len
(
)
]
.
copy_from_slice
(
cookie_val
)
;
let
ad
=
cookie
.
name
(
)
.
as_bytes
(
)
;
seal_in_place
(
&
key
nonce
ad
in_out
overhead
)
.
expect
(
"
in
-
place
seal
"
)
}
;
let
sealed_value
=
base64
:
:
encode
(
&
data
[
.
.
(
NONCE_LEN
+
output_len
)
]
)
;
cookie
.
set_value
(
sealed_value
)
;
}
pub
fn
remove
(
&
mut
self
cookie
:
Cookie
<
'
static
>
)
{
self
.
parent
.
remove
(
cookie
)
;
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
{
CookieJar
Cookie
Key
}
;
#
[
test
]
fn
simple
(
)
{
let
key
=
Key
:
:
generate
(
)
;
let
mut
jar
=
CookieJar
:
:
new
(
)
;
assert_simple_behaviour
!
(
jar
jar
.
private
(
&
key
)
)
;
}
#
[
test
]
fn
private
(
)
{
let
key
=
Key
:
:
generate
(
)
;
let
mut
jar
=
CookieJar
:
:
new
(
)
;
assert_secure_behaviour
!
(
jar
jar
.
private
(
&
key
)
)
;
}
}
