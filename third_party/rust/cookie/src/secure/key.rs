use
secure
:
:
ring
:
:
hkdf
:
:
expand
;
use
secure
:
:
ring
:
:
digest
:
:
{
SHA256
Algorithm
}
;
use
secure
:
:
ring
:
:
hmac
:
:
SigningKey
;
use
secure
:
:
ring
:
:
rand
:
:
{
SecureRandom
SystemRandom
}
;
use
secure
:
:
private
:
:
KEY_LEN
as
PRIVATE_KEY_LEN
;
use
secure
:
:
signed
:
:
KEY_LEN
as
SIGNED_KEY_LEN
;
static
HKDF_DIGEST
:
&
'
static
Algorithm
=
&
SHA256
;
const
KEYS_INFO
:
&
'
static
str
=
"
COOKIE
;
SIGNED
:
HMAC
-
SHA256
;
PRIVATE
:
AEAD
-
AES
-
256
-
GCM
"
;
#
[
derive
(
Clone
)
]
pub
struct
Key
{
signing_key
:
[
u8
;
SIGNED_KEY_LEN
]
encryption_key
:
[
u8
;
PRIVATE_KEY_LEN
]
}
impl
Key
{
pub
fn
from_master
(
key
:
&
[
u8
]
)
-
>
Key
{
if
key
.
len
(
)
<
32
{
panic
!
(
"
bad
master
key
length
:
expected
at
least
32
bytes
found
{
}
"
key
.
len
(
)
)
;
}
let
prk
=
SigningKey
:
:
new
(
HKDF_DIGEST
key
)
;
let
mut
both_keys
=
[
0
;
SIGNED_KEY_LEN
+
PRIVATE_KEY_LEN
]
;
expand
(
&
prk
KEYS_INFO
.
as_bytes
(
)
&
mut
both_keys
)
;
let
mut
signing_key
=
[
0
;
SIGNED_KEY_LEN
]
;
let
mut
encryption_key
=
[
0
;
PRIVATE_KEY_LEN
]
;
signing_key
.
copy_from_slice
(
&
both_keys
[
.
.
SIGNED_KEY_LEN
]
)
;
encryption_key
.
copy_from_slice
(
&
both_keys
[
SIGNED_KEY_LEN
.
.
]
)
;
Key
{
signing_key
:
signing_key
encryption_key
:
encryption_key
}
}
pub
fn
generate
(
)
-
>
Key
{
Self
:
:
try_generate
(
)
.
expect
(
"
failed
to
generate
Key
from
randomness
"
)
}
pub
fn
try_generate
(
)
-
>
Option
<
Key
>
{
let
mut
sign_key
=
[
0
;
SIGNED_KEY_LEN
]
;
let
mut
enc_key
=
[
0
;
PRIVATE_KEY_LEN
]
;
let
rng
=
SystemRandom
:
:
new
(
)
;
if
rng
.
fill
(
&
mut
sign_key
)
.
is_err
(
)
|
|
rng
.
fill
(
&
mut
enc_key
)
.
is_err
(
)
{
return
None
}
Some
(
Key
{
signing_key
:
sign_key
encryption_key
:
enc_key
}
)
}
pub
fn
signing
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
signing_key
[
.
.
]
}
pub
fn
encryption
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
encryption_key
[
.
.
]
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
Key
;
#
[
test
]
fn
deterministic_from_master
(
)
{
let
master_key
:
Vec
<
u8
>
=
(
0
.
.
32
)
.
collect
(
)
;
let
key_a
=
Key
:
:
from_master
(
&
master_key
)
;
let
key_b
=
Key
:
:
from_master
(
&
master_key
)
;
assert_eq
!
(
key_a
.
signing
(
)
key_b
.
signing
(
)
)
;
assert_eq
!
(
key_a
.
encryption
(
)
key_b
.
encryption
(
)
)
;
assert_ne
!
(
key_a
.
encryption
(
)
key_a
.
signing
(
)
)
;
let
master_key_2
:
Vec
<
u8
>
=
(
32
.
.
64
)
.
collect
(
)
;
let
key_2
=
Key
:
:
from_master
(
&
master_key_2
)
;
assert_ne
!
(
key_2
.
signing
(
)
key_a
.
signing
(
)
)
;
assert_ne
!
(
key_2
.
encryption
(
)
key_a
.
encryption
(
)
)
;
}
#
[
test
]
fn
non_deterministic_generate
(
)
{
let
key_a
=
Key
:
:
generate
(
)
;
let
key_b
=
Key
:
:
generate
(
)
;
assert_ne
!
(
key_a
.
signing
(
)
key_b
.
signing
(
)
)
;
assert_ne
!
(
key_a
.
encryption
(
)
key_b
.
encryption
(
)
)
;
}
}
