const
SIGNING_KEY_LEN
:
usize
=
32
;
const
ENCRYPTION_KEY_LEN
:
usize
=
32
;
const
COMBINED_KEY_LENGTH
:
usize
=
SIGNING_KEY_LEN
+
ENCRYPTION_KEY_LEN
;
#
[
cfg
(
feature
=
"
signed
"
)
]
const_assert
!
(
crate
:
:
secure
:
:
signed
:
:
KEY_LEN
=
=
SIGNING_KEY_LEN
)
;
#
[
cfg
(
feature
=
"
private
"
)
]
const_assert
!
(
crate
:
:
secure
:
:
private
:
:
KEY_LEN
=
=
ENCRYPTION_KEY_LEN
)
;
#
[
cfg_attr
(
all
(
nightly
doc
)
doc
(
cfg
(
any
(
feature
=
"
private
"
feature
=
"
signed
"
)
)
)
)
]
#
[
derive
(
Clone
)
]
pub
struct
Key
(
[
u8
;
COMBINED_KEY_LENGTH
]
)
;
impl
PartialEq
for
Key
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
use
subtle
:
:
ConstantTimeEq
;
self
.
0
.
ct_eq
(
&
other
.
0
)
.
into
(
)
}
}
impl
Key
{
const
fn
zero
(
)
-
>
Self
{
Key
(
[
0
;
COMBINED_KEY_LENGTH
]
)
}
pub
fn
from
(
key
:
&
[
u8
]
)
-
>
Key
{
if
key
.
len
(
)
<
64
{
panic
!
(
"
bad
key
length
:
expected
>
=
64
bytes
found
{
}
"
key
.
len
(
)
)
;
}
let
mut
output
=
Key
:
:
zero
(
)
;
output
.
0
.
copy_from_slice
(
&
key
[
.
.
COMBINED_KEY_LENGTH
]
)
;
output
}
#
[
cfg
(
feature
=
"
key
-
expansion
"
)
]
#
[
cfg_attr
(
all
(
nightly
doc
)
doc
(
cfg
(
feature
=
"
key
-
expansion
"
)
)
)
]
pub
fn
derive_from
(
master_key
:
&
[
u8
]
)
-
>
Self
{
if
master_key
.
len
(
)
<
32
{
panic
!
(
"
bad
master
key
length
:
expected
>
=
32
bytes
found
{
}
"
master_key
.
len
(
)
)
;
}
const
KEYS_INFO
:
&
[
u8
]
=
b
"
COOKIE
;
SIGNED
:
HMAC
-
SHA256
;
PRIVATE
:
AEAD
-
AES
-
256
-
GCM
"
;
let
mut
both_keys
=
[
0
;
COMBINED_KEY_LENGTH
]
;
let
hk
=
hkdf
:
:
Hkdf
:
:
<
sha2
:
:
Sha256
>
:
:
from_prk
(
master_key
)
.
expect
(
"
key
length
prechecked
"
)
;
hk
.
expand
(
KEYS_INFO
&
mut
both_keys
)
.
expect
(
"
expand
into
keys
"
)
;
Key
:
:
from
(
&
both_keys
)
}
pub
fn
generate
(
)
-
>
Key
{
Self
:
:
try_generate
(
)
.
expect
(
"
failed
to
generate
Key
from
randomness
"
)
}
pub
fn
try_generate
(
)
-
>
Option
<
Key
>
{
use
crate
:
:
secure
:
:
rand
:
:
RngCore
;
let
mut
rng
=
crate
:
:
secure
:
:
rand
:
:
thread_rng
(
)
;
let
mut
key
=
Key
:
:
zero
(
)
;
rng
.
try_fill_bytes
(
&
mut
key
.
0
)
.
ok
(
)
?
;
Some
(
key
)
}
pub
fn
signing
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
[
.
.
SIGNING_KEY_LEN
]
}
pub
fn
encryption
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
[
SIGNING_KEY_LEN
.
.
]
}
pub
fn
master
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
Key
;
#
[
test
]
fn
from_works
(
)
{
let
key
=
Key
:
:
from
(
&
(
0
.
.
64
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
;
let
signing
:
Vec
<
u8
>
=
(
0
.
.
32
)
.
collect
(
)
;
assert_eq
!
(
key
.
signing
(
)
&
*
signing
)
;
let
encryption
:
Vec
<
u8
>
=
(
32
.
.
64
)
.
collect
(
)
;
assert_eq
!
(
key
.
encryption
(
)
&
*
encryption
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
key
-
expansion
"
)
]
fn
deterministic_derive
(
)
{
let
master_key
:
Vec
<
u8
>
=
(
0
.
.
32
)
.
collect
(
)
;
let
key_a
=
Key
:
:
derive_from
(
&
master_key
)
;
let
key_b
=
Key
:
:
derive_from
(
&
master_key
)
;
assert_eq
!
(
key_a
.
signing
(
)
key_b
.
signing
(
)
)
;
assert_eq
!
(
key_a
.
encryption
(
)
key_b
.
encryption
(
)
)
;
assert_ne
!
(
key_a
.
encryption
(
)
key_a
.
signing
(
)
)
;
let
master_key_2
:
Vec
<
u8
>
=
(
32
.
.
64
)
.
collect
(
)
;
let
key_2
=
Key
:
:
derive_from
(
&
master_key_2
)
;
assert_ne
!
(
key_2
.
signing
(
)
key_a
.
signing
(
)
)
;
assert_ne
!
(
key_2
.
encryption
(
)
key_a
.
encryption
(
)
)
;
}
#
[
test
]
fn
non_deterministic_generate
(
)
{
let
key_a
=
Key
:
:
generate
(
)
;
let
key_b
=
Key
:
:
generate
(
)
;
assert_ne
!
(
key_a
.
signing
(
)
key_b
.
signing
(
)
)
;
assert_ne
!
(
key_a
.
encryption
(
)
key_b
.
encryption
(
)
)
;
}
}
