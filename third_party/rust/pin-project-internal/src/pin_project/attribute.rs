use
proc_macro2
:
:
{
Span
TokenStream
}
;
use
quote
:
:
quote
;
use
syn
:
:
{
parse
:
:
{
Parse
ParseStream
}
*
}
;
use
crate
:
:
utils
:
:
{
SliceExt
CURRENT_PRIVATE_MODULE
}
;
use
super
:
:
PIN
;
pub
(
super
)
fn
parse_attribute
(
args
:
&
TokenStream
input
:
TokenStream
)
-
>
Result
<
TokenStream
>
{
let
Input
{
mut
attrs
body
}
=
syn
:
:
parse2
(
input
)
?
;
let
private
=
Ident
:
:
new
(
CURRENT_PRIVATE_MODULE
Span
:
:
call_site
(
)
)
;
attrs
.
push
(
syn
:
:
parse_quote
!
{
#
[
derive
(
:
:
pin_project
:
:
#
private
:
:
__PinProjectInternalDerive
)
]
}
)
;
attrs
.
push
(
syn
:
:
parse_quote
!
{
#
[
pin
(
#
private
(
#
args
)
)
]
}
)
;
Ok
(
quote
!
{
#
(
#
attrs
)
*
#
body
}
)
}
#
[
allow
(
dead_code
)
]
struct
Input
{
attrs
:
Vec
<
Attribute
>
body
:
TokenStream
}
impl
Parse
for
Input
{
fn
parse
(
input
:
ParseStream
<
'
_
>
)
-
>
Result
<
Self
>
{
let
attrs
=
input
.
call
(
Attribute
:
:
parse_outer
)
?
;
let
ahead
=
input
.
fork
(
)
;
let
_vis
:
Visibility
=
ahead
.
parse
(
)
?
;
if
!
ahead
.
peek
(
Token
!
[
struct
]
)
&
&
!
ahead
.
peek
(
Token
!
[
enum
]
)
{
Err
(
error
!
(
input
.
parse
:
:
<
TokenStream
>
(
)
?
"
#
[
pin_project
]
attribute
may
only
be
used
on
structs
or
enums
"
)
)
}
else
if
let
Some
(
attr
)
=
attrs
.
find
(
PIN
)
{
Err
(
error
!
(
attr
"
#
[
pin
]
attribute
may
only
be
used
on
fields
of
structs
or
variants
"
)
)
}
else
if
let
Some
(
attr
)
=
attrs
.
find
(
"
pin_project
"
)
{
Err
(
error
!
(
attr
"
only
one
#
[
pin_project
]
attribute
is
allowed
"
)
)
}
else
{
Ok
(
Self
{
attrs
body
:
input
.
parse
(
)
?
}
)
}
}
}
