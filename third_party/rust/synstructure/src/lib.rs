extern
crate
syn
;
#
[
macro_use
]
extern
crate
quote
;
use
std
:
:
borrow
:
:
Cow
;
use
syn
:
:
{
Body
Field
Ident
MacroInput
VariantData
Variant
}
;
use
quote
:
:
{
Tokens
ToTokens
}
;
#
[
derive
(
Debug
Copy
Clone
)
]
pub
enum
BindStyle
{
Move
MoveMut
Ref
RefMut
}
impl
ToTokens
for
BindStyle
{
fn
to_tokens
(
&
self
tokens
:
&
mut
Tokens
)
{
match
*
self
{
BindStyle
:
:
Move
=
>
{
}
BindStyle
:
:
MoveMut
=
>
tokens
.
append
(
"
mut
"
)
BindStyle
:
:
Ref
=
>
tokens
.
append
(
"
ref
"
)
BindStyle
:
:
RefMut
=
>
{
tokens
.
append
(
"
ref
"
)
;
tokens
.
append
(
"
mut
"
)
;
}
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
BindOpts
{
bind_style
:
BindStyle
prefix
:
Cow
<
'
static
str
>
}
impl
BindOpts
{
pub
fn
new
(
bind_style
:
BindStyle
)
-
>
BindOpts
{
BindOpts
{
bind_style
:
bind_style
prefix
:
"
__binding
"
.
into
(
)
}
}
pub
fn
with_prefix
(
bind_style
:
BindStyle
prefix
:
String
)
-
>
BindOpts
{
BindOpts
{
bind_style
:
bind_style
prefix
:
prefix
.
into
(
)
}
}
}
impl
From
<
BindStyle
>
for
BindOpts
{
fn
from
(
style
:
BindStyle
)
-
>
Self
{
BindOpts
:
:
new
(
style
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
BindingInfo
<
'
a
>
{
pub
ident
:
Ident
pub
field
:
&
'
a
Field
}
impl
<
'
a
>
ToTokens
for
BindingInfo
<
'
a
>
{
fn
to_tokens
(
&
self
tokens
:
&
mut
Tokens
)
{
self
.
ident
.
to_tokens
(
tokens
)
;
}
}
pub
fn
match_pattern
<
'
a
N
:
ToTokens
>
(
name
:
&
N
vd
:
&
'
a
VariantData
options
:
&
BindOpts
)
-
>
(
Tokens
Vec
<
BindingInfo
<
'
a
>
>
)
{
let
mut
t
=
Tokens
:
:
new
(
)
;
let
mut
matches
=
Vec
:
:
new
(
)
;
let
binding
=
options
.
bind_style
;
name
.
to_tokens
(
&
mut
t
)
;
match
*
vd
{
VariantData
:
:
Unit
=
>
{
}
VariantData
:
:
Tuple
(
ref
fields
)
=
>
{
t
.
append
(
"
(
"
)
;
for
(
i
field
)
in
fields
.
iter
(
)
.
enumerate
(
)
{
let
ident
:
Ident
=
format
!
(
"
{
}
_
{
}
"
options
.
prefix
i
)
.
into
(
)
;
quote
!
(
#
binding
#
ident
)
.
to_tokens
(
&
mut
t
)
;
matches
.
push
(
BindingInfo
{
ident
:
ident
field
:
field
}
)
;
}
t
.
append
(
"
)
"
)
;
}
VariantData
:
:
Struct
(
ref
fields
)
=
>
{
t
.
append
(
"
{
"
)
;
for
(
i
field
)
in
fields
.
iter
(
)
.
enumerate
(
)
{
let
ident
:
Ident
=
format
!
(
"
{
}
_
{
}
"
options
.
prefix
i
)
.
into
(
)
;
{
let
field_name
=
field
.
ident
.
as_ref
(
)
.
unwrap
(
)
;
quote
!
(
#
field_name
:
#
binding
#
ident
)
.
to_tokens
(
&
mut
t
)
;
}
matches
.
push
(
BindingInfo
{
ident
:
ident
field
:
field
}
)
;
}
t
.
append
(
"
}
"
)
;
}
}
(
t
matches
)
}
pub
fn
each_variant
<
F
T
:
ToTokens
>
(
input
:
&
MacroInput
options
:
&
BindOpts
mut
func
:
F
)
-
>
Tokens
where
F
:
FnMut
(
Vec
<
BindingInfo
>
&
Variant
)
-
>
T
{
let
ident
=
&
input
.
ident
;
let
struct_variant
;
let
variants
=
match
input
.
body
{
Body
:
:
Enum
(
ref
variants
)
=
>
{
variants
.
iter
(
)
.
map
(
|
variant
|
{
let
variant_ident
=
&
variant
.
ident
;
let
(
pat
bindings
)
=
match_pattern
(
&
quote
!
(
#
ident
:
:
#
variant_ident
)
&
variant
.
data
options
)
;
(
pat
bindings
variant
)
}
)
.
collect
(
)
}
Body
:
:
Struct
(
ref
vd
)
=
>
{
struct_variant
=
Variant
{
ident
:
ident
.
clone
(
)
attrs
:
input
.
attrs
.
clone
(
)
data
:
vd
.
clone
(
)
discriminant
:
None
}
;
let
(
pat
bindings
)
=
match_pattern
(
&
ident
&
vd
options
)
;
vec
!
[
(
pat
bindings
&
struct_variant
)
]
}
}
;
let
mut
t
=
Tokens
:
:
new
(
)
;
for
(
pat
bindings
variant
)
in
variants
{
let
body
=
func
(
bindings
variant
)
;
quote
!
(
#
pat
=
>
{
#
body
}
)
.
to_tokens
(
&
mut
t
)
;
}
t
}
pub
fn
match_substructs
<
F
T
:
ToTokens
>
(
input
:
&
MacroInput
options
:
&
BindOpts
mut
func
:
F
)
-
>
Tokens
where
F
:
FnMut
(
Vec
<
BindingInfo
>
)
-
>
T
{
each_variant
(
input
options
|
bindings
_
|
func
(
bindings
)
)
}
pub
fn
each_field
<
F
T
:
ToTokens
>
(
input
:
&
MacroInput
options
:
&
BindOpts
mut
func
:
F
)
-
>
Tokens
where
F
:
FnMut
(
BindingInfo
)
-
>
T
{
each_variant
(
input
options
|
bindings
_
|
{
let
mut
t
=
Tokens
:
:
new
(
)
;
for
binding
in
bindings
{
t
.
append
(
"
{
"
)
;
func
(
binding
)
.
to_tokens
(
&
mut
t
)
;
t
.
append
(
"
}
"
)
;
}
quote
!
(
(
)
)
.
to_tokens
(
&
mut
t
)
;
t
}
)
}
