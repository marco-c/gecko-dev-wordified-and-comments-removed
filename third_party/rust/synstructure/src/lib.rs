extern
crate
proc_macro
;
extern
crate
proc_macro2
;
#
[
macro_use
]
extern
crate
quote
;
#
[
macro_use
]
extern
crate
syn
;
extern
crate
unicode_xid
;
use
std
:
:
collections
:
:
HashSet
;
use
syn
:
:
{
Generics
Ident
Attribute
Field
Fields
Expr
DeriveInput
TraitBound
WhereClause
GenericParam
Data
WherePredicate
TypeParamBound
Type
TypeMacro
FieldsUnnamed
FieldsNamed
PredicateType
TypePath
token
punctuated
}
;
use
syn
:
:
visit
:
:
{
self
Visit
}
;
#
[
doc
(
hidden
)
]
pub
use
quote
:
:
*
;
use
proc_macro2
:
:
{
TokenStream
TokenTree
}
;
use
unicode_xid
:
:
UnicodeXID
;
use
proc_macro2
:
:
Span
;
#
[
doc
(
hidden
)
]
pub
mod
macros
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
AddBounds
{
Both
Fields
Generics
None
#
[
doc
(
hidden
)
]
__Nonexhaustive
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
BindStyle
{
Move
MoveMut
Ref
RefMut
}
impl
ToTokens
for
BindStyle
{
fn
to_tokens
(
&
self
tokens
:
&
mut
TokenStream
)
{
match
*
self
{
BindStyle
:
:
Move
=
>
{
}
BindStyle
:
:
MoveMut
=
>
quote_spanned
!
(
Span
:
:
call_site
(
)
=
>
mut
)
.
to_tokens
(
tokens
)
BindStyle
:
:
Ref
=
>
quote_spanned
!
(
Span
:
:
call_site
(
)
=
>
ref
)
.
to_tokens
(
tokens
)
BindStyle
:
:
RefMut
=
>
quote_spanned
!
(
Span
:
:
call_site
(
)
=
>
ref
mut
)
.
to_tokens
(
tokens
)
}
}
}
fn
generics_fuse
(
res
:
&
mut
Vec
<
bool
>
new
:
&
[
bool
]
)
{
for
(
i
&
flag
)
in
new
.
iter
(
)
.
enumerate
(
)
{
if
i
=
=
res
.
len
(
)
{
res
.
push
(
false
)
;
}
if
flag
{
res
[
i
]
=
true
;
}
}
}
fn
fetch_generics
<
'
a
>
(
set
:
&
[
bool
]
generics
:
&
'
a
Generics
)
-
>
Vec
<
&
'
a
Ident
>
{
let
mut
tys
=
vec
!
[
]
;
for
(
&
seen
param
)
in
set
.
iter
(
)
.
zip
(
generics
.
params
.
iter
(
)
)
{
if
seen
{
match
*
param
{
GenericParam
:
:
Type
(
ref
tparam
)
=
>
tys
.
push
(
&
tparam
.
ident
)
_
=
>
{
}
}
}
}
tys
}
fn
sanitize_ident
(
s
:
&
str
)
-
>
Ident
{
let
mut
res
=
String
:
:
with_capacity
(
s
.
len
(
)
)
;
for
mut
c
in
s
.
chars
(
)
{
if
!
UnicodeXID
:
:
is_xid_continue
(
c
)
{
c
=
'
_
'
}
if
res
.
ends_with
(
'
_
'
)
&
&
c
=
=
'
_
'
{
continue
}
res
.
push
(
c
)
;
}
Ident
:
:
new
(
&
res
Span
:
:
call_site
(
)
)
}
fn
merge_generics
(
into
:
&
mut
Generics
from
:
&
Generics
)
{
'
outer
:
for
p
in
&
from
.
params
{
for
op
in
&
into
.
params
{
match
(
op
p
)
{
(
&
GenericParam
:
:
Type
(
ref
otp
)
&
GenericParam
:
:
Type
(
ref
tp
)
)
=
>
{
if
otp
.
ident
=
=
tp
.
ident
{
panic
!
(
"
Attempted
to
merge
conflicting
generic
params
:
{
}
and
{
}
"
quote
!
{
#
op
}
quote
!
{
#
p
}
)
;
}
}
(
&
GenericParam
:
:
Lifetime
(
ref
olp
)
&
GenericParam
:
:
Lifetime
(
ref
lp
)
)
=
>
{
if
olp
.
lifetime
=
=
lp
.
lifetime
{
panic
!
(
"
Attempted
to
merge
conflicting
generic
params
:
{
}
and
{
}
"
quote
!
{
#
op
}
quote
!
{
#
p
}
)
;
}
}
_
=
>
(
)
}
}
into
.
params
.
push
(
p
.
clone
(
)
)
;
}
if
let
Some
(
ref
from_clause
)
=
from
.
where_clause
{
into
.
make_where_clause
(
)
.
predicates
.
extend
(
from_clause
.
predicates
.
iter
(
)
.
cloned
(
)
)
;
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Hash
)
]
pub
struct
BindingInfo
<
'
a
>
{
pub
binding
:
Ident
pub
style
:
BindStyle
field
:
&
'
a
Field
generics
:
&
'
a
Generics
seen_generics
:
Vec
<
bool
>
}
impl
<
'
a
>
ToTokens
for
BindingInfo
<
'
a
>
{
fn
to_tokens
(
&
self
tokens
:
&
mut
TokenStream
)
{
self
.
binding
.
to_tokens
(
tokens
)
;
}
}
impl
<
'
a
>
BindingInfo
<
'
a
>
{
pub
fn
ast
(
&
self
)
-
>
&
'
a
Field
{
self
.
field
}
pub
fn
pat
(
&
self
)
-
>
TokenStream
{
let
BindingInfo
{
ref
binding
ref
style
.
.
}
=
*
self
;
quote
!
(
#
style
#
binding
)
}
pub
fn
referenced_ty_params
(
&
self
)
-
>
Vec
<
&
'
a
Ident
>
{
fetch_generics
(
&
self
.
seen_generics
self
.
generics
)
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
VariantAst
<
'
a
>
{
pub
attrs
:
&
'
a
[
Attribute
]
pub
ident
:
&
'
a
Ident
pub
fields
:
&
'
a
Fields
pub
discriminant
:
&
'
a
Option
<
(
token
:
:
Eq
Expr
)
>
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Hash
)
]
pub
struct
VariantInfo
<
'
a
>
{
pub
prefix
:
Option
<
&
'
a
Ident
>
bindings
:
Vec
<
BindingInfo
<
'
a
>
>
omitted_fields
:
bool
ast
:
VariantAst
<
'
a
>
generics
:
&
'
a
Generics
}
fn
get_ty_params
<
'
a
>
(
field
:
&
Field
generics
:
&
Generics
)
-
>
Vec
<
bool
>
{
struct
BoundTypeLocator
<
'
a
>
{
result
:
Vec
<
bool
>
generics
:
&
'
a
Generics
}
impl
<
'
a
>
Visit
<
'
a
>
for
BoundTypeLocator
<
'
a
>
{
fn
visit_ident
(
&
mut
self
id
:
&
Ident
)
{
for
(
idx
i
)
in
self
.
generics
.
params
.
iter
(
)
.
enumerate
(
)
{
if
let
GenericParam
:
:
Type
(
ref
tparam
)
=
*
i
{
if
tparam
.
ident
=
=
*
id
{
self
.
result
[
idx
]
=
true
;
}
}
}
}
fn
visit_type_macro
(
&
mut
self
x
:
&
'
a
TypeMacro
)
{
for
r
in
&
mut
self
.
result
{
*
r
=
true
;
}
visit
:
:
visit_type_macro
(
self
x
)
}
}
let
mut
btl
=
BoundTypeLocator
{
result
:
vec
!
[
false
;
generics
.
params
.
len
(
)
]
generics
:
generics
}
;
btl
.
visit_type
(
&
field
.
ty
)
;
btl
.
result
}
impl
<
'
a
>
VariantInfo
<
'
a
>
{
fn
new
(
ast
:
VariantAst
<
'
a
>
prefix
:
Option
<
&
'
a
Ident
>
generics
:
&
'
a
Generics
)
-
>
Self
{
let
bindings
=
match
*
ast
.
fields
{
Fields
:
:
Unit
=
>
vec
!
[
]
Fields
:
:
Unnamed
(
FieldsUnnamed
{
unnamed
:
ref
fields
.
.
}
)
|
Fields
:
:
Named
(
FieldsNamed
{
named
:
ref
fields
.
.
}
)
=
>
{
fields
.
into_iter
(
)
.
enumerate
(
)
.
map
(
|
(
i
field
)
|
{
BindingInfo
{
binding
:
Ident
:
:
new
(
&
format
!
(
"
__binding_
{
}
"
i
)
Span
:
:
call_site
(
)
)
style
:
BindStyle
:
:
Ref
field
:
field
generics
:
generics
seen_generics
:
get_ty_params
(
field
generics
)
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
}
}
;
VariantInfo
{
prefix
:
prefix
bindings
:
bindings
omitted_fields
:
false
ast
:
ast
generics
:
generics
}
}
pub
fn
bindings
(
&
self
)
-
>
&
[
BindingInfo
<
'
a
>
]
{
&
self
.
bindings
}
pub
fn
bindings_mut
(
&
mut
self
)
-
>
&
mut
[
BindingInfo
<
'
a
>
]
{
&
mut
self
.
bindings
}
pub
fn
ast
(
&
self
)
-
>
VariantAst
<
'
a
>
{
self
.
ast
}
pub
fn
omitted_bindings
(
&
self
)
-
>
bool
{
self
.
omitted_fields
}
pub
fn
pat
(
&
self
)
-
>
TokenStream
{
let
mut
t
=
TokenStream
:
:
new
(
)
;
if
let
Some
(
prefix
)
=
self
.
prefix
{
prefix
.
to_tokens
(
&
mut
t
)
;
quote
!
(
:
:
)
.
to_tokens
(
&
mut
t
)
;
}
self
.
ast
.
ident
.
to_tokens
(
&
mut
t
)
;
match
*
self
.
ast
.
fields
{
Fields
:
:
Unit
=
>
{
assert
!
(
self
.
bindings
.
len
(
)
=
=
0
)
;
}
Fields
:
:
Unnamed
(
.
.
)
=
>
{
token
:
:
Paren
(
Span
:
:
call_site
(
)
)
.
surround
(
&
mut
t
|
t
|
{
for
binding
in
&
self
.
bindings
{
binding
.
pat
(
)
.
to_tokens
(
t
)
;
quote
!
(
)
.
to_tokens
(
t
)
;
}
if
self
.
omitted_fields
{
quote
!
(
.
.
)
.
to_tokens
(
t
)
;
}
}
)
}
Fields
:
:
Named
(
.
.
)
=
>
{
token
:
:
Brace
(
Span
:
:
call_site
(
)
)
.
surround
(
&
mut
t
|
t
|
{
for
binding
in
&
self
.
bindings
{
binding
.
field
.
ident
.
to_tokens
(
t
)
;
quote
!
(
:
)
.
to_tokens
(
t
)
;
binding
.
pat
(
)
.
to_tokens
(
t
)
;
quote
!
(
)
.
to_tokens
(
t
)
;
}
if
self
.
omitted_fields
{
quote
!
(
.
.
)
.
to_tokens
(
t
)
;
}
}
)
}
}
t
}
pub
fn
construct
<
F
T
>
(
&
self
mut
func
:
F
)
-
>
TokenStream
where
F
:
FnMut
(
&
Field
usize
)
-
>
T
T
:
ToTokens
{
let
mut
t
=
TokenStream
:
:
new
(
)
;
if
let
Some
(
prefix
)
=
self
.
prefix
{
quote
!
(
#
prefix
:
:
)
.
to_tokens
(
&
mut
t
)
;
}
self
.
ast
.
ident
.
to_tokens
(
&
mut
t
)
;
match
*
self
.
ast
.
fields
{
Fields
:
:
Unit
=
>
(
)
Fields
:
:
Unnamed
(
FieldsUnnamed
{
ref
unnamed
.
.
}
)
=
>
{
token
:
:
Paren
:
:
default
(
)
.
surround
(
&
mut
t
|
t
|
{
for
(
i
field
)
in
unnamed
.
into_iter
(
)
.
enumerate
(
)
{
func
(
field
i
)
.
to_tokens
(
t
)
;
quote
!
(
)
.
to_tokens
(
t
)
;
}
}
)
}
Fields
:
:
Named
(
FieldsNamed
{
ref
named
.
.
}
)
=
>
{
token
:
:
Brace
:
:
default
(
)
.
surround
(
&
mut
t
|
t
|
{
for
(
i
field
)
in
named
.
into_iter
(
)
.
enumerate
(
)
{
field
.
ident
.
to_tokens
(
t
)
;
quote
!
(
:
)
.
to_tokens
(
t
)
;
func
(
field
i
)
.
to_tokens
(
t
)
;
quote
!
(
)
.
to_tokens
(
t
)
;
}
}
)
}
}
t
}
pub
fn
each
<
F
R
>
(
&
self
mut
f
:
F
)
-
>
TokenStream
where
F
:
FnMut
(
&
BindingInfo
)
-
>
R
R
:
ToTokens
{
let
pat
=
self
.
pat
(
)
;
let
mut
body
=
TokenStream
:
:
new
(
)
;
for
binding
in
&
self
.
bindings
{
token
:
:
Brace
:
:
default
(
)
.
surround
(
&
mut
body
|
body
|
{
f
(
binding
)
.
to_tokens
(
body
)
;
}
)
;
}
quote
!
(
#
pat
=
>
{
#
body
}
)
}
pub
fn
fold
<
F
I
R
>
(
&
self
init
:
I
mut
f
:
F
)
-
>
TokenStream
where
F
:
FnMut
(
TokenStream
&
BindingInfo
)
-
>
R
I
:
ToTokens
R
:
ToTokens
{
let
pat
=
self
.
pat
(
)
;
let
body
=
self
.
bindings
.
iter
(
)
.
fold
(
quote
!
(
#
init
)
|
i
bi
|
{
let
r
=
f
(
i
bi
)
;
quote
!
(
#
r
)
}
)
;
quote
!
(
#
pat
=
>
{
#
body
}
)
}
pub
fn
filter
<
F
>
(
&
mut
self
f
:
F
)
-
>
&
mut
Self
where
F
:
FnMut
(
&
BindingInfo
)
-
>
bool
{
let
before_len
=
self
.
bindings
.
len
(
)
;
self
.
bindings
.
retain
(
f
)
;
if
self
.
bindings
.
len
(
)
!
=
before_len
{
self
.
omitted_fields
=
true
;
}
self
}
pub
fn
remove_binding
(
&
mut
self
idx
:
usize
)
-
>
&
mut
Self
{
self
.
bindings
.
remove
(
idx
)
;
self
.
omitted_fields
=
true
;
self
}
pub
fn
bind_with
<
F
>
(
&
mut
self
mut
f
:
F
)
-
>
&
mut
Self
where
F
:
FnMut
(
&
BindingInfo
)
-
>
BindStyle
{
for
binding
in
&
mut
self
.
bindings
{
binding
.
style
=
f
(
&
binding
)
;
}
self
}
pub
fn
binding_name
<
F
>
(
&
mut
self
mut
f
:
F
)
-
>
&
mut
Self
where
F
:
FnMut
(
&
Field
usize
)
-
>
Ident
{
for
(
it
binding
)
in
self
.
bindings
.
iter_mut
(
)
.
enumerate
(
)
{
binding
.
binding
=
f
(
binding
.
field
it
)
;
}
self
}
pub
fn
referenced_ty_params
(
&
self
)
-
>
Vec
<
&
'
a
Ident
>
{
let
mut
flags
=
Vec
:
:
new
(
)
;
for
binding
in
&
self
.
bindings
{
generics_fuse
(
&
mut
flags
&
binding
.
seen_generics
)
;
}
fetch_generics
(
&
flags
self
.
generics
)
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Hash
)
]
pub
struct
Structure
<
'
a
>
{
variants
:
Vec
<
VariantInfo
<
'
a
>
>
omitted_variants
:
bool
ast
:
&
'
a
DeriveInput
extra_impl
:
Vec
<
GenericParam
>
add_bounds
:
AddBounds
}
impl
<
'
a
>
Structure
<
'
a
>
{
pub
fn
new
(
ast
:
&
'
a
DeriveInput
)
-
>
Self
{
let
variants
=
match
ast
.
data
{
Data
:
:
Enum
(
ref
data
)
=
>
{
(
&
data
.
variants
)
.
into_iter
(
)
.
map
(
|
v
|
{
VariantInfo
:
:
new
(
VariantAst
{
attrs
:
&
v
.
attrs
ident
:
&
v
.
ident
fields
:
&
v
.
fields
discriminant
:
&
v
.
discriminant
}
Some
(
&
ast
.
ident
)
&
ast
.
generics
)
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
}
Data
:
:
Struct
(
ref
data
)
=
>
{
struct
UnsafeMakeSync
(
Option
<
(
token
:
:
Eq
Expr
)
>
)
;
unsafe
impl
Sync
for
UnsafeMakeSync
{
}
static
NONE_DISCRIMINANT
:
UnsafeMakeSync
=
UnsafeMakeSync
(
None
)
;
vec
!
[
VariantInfo
:
:
new
(
VariantAst
{
attrs
:
&
ast
.
attrs
ident
:
&
ast
.
ident
fields
:
&
data
.
fields
discriminant
:
&
NONE_DISCRIMINANT
.
0
}
None
&
ast
.
generics
)
]
}
Data
:
:
Union
(
_
)
=
>
{
panic
!
(
"
synstructure
does
not
handle
untagged
unions
\
(
https
:
/
/
github
.
com
/
mystor
/
synstructure
/
issues
/
6
)
"
)
;
}
}
;
Structure
{
variants
:
variants
omitted_variants
:
false
ast
:
ast
extra_impl
:
vec
!
[
]
add_bounds
:
AddBounds
:
:
Both
}
}
pub
fn
variants
(
&
self
)
-
>
&
[
VariantInfo
<
'
a
>
]
{
&
self
.
variants
}
pub
fn
variants_mut
(
&
mut
self
)
-
>
&
mut
[
VariantInfo
<
'
a
>
]
{
&
mut
self
.
variants
}
pub
fn
ast
(
&
self
)
-
>
&
'
a
DeriveInput
{
self
.
ast
}
pub
fn
omitted_variants
(
&
self
)
-
>
bool
{
self
.
omitted_variants
}
pub
fn
each
<
F
R
>
(
&
self
mut
f
:
F
)
-
>
TokenStream
where
F
:
FnMut
(
&
BindingInfo
)
-
>
R
R
:
ToTokens
{
let
mut
t
=
TokenStream
:
:
new
(
)
;
for
variant
in
&
self
.
variants
{
variant
.
each
(
&
mut
f
)
.
to_tokens
(
&
mut
t
)
;
}
if
self
.
omitted_variants
{
quote
!
(
_
=
>
{
}
)
.
to_tokens
(
&
mut
t
)
;
}
t
}
pub
fn
fold
<
F
I
R
>
(
&
self
init
:
I
mut
f
:
F
)
-
>
TokenStream
where
F
:
FnMut
(
TokenStream
&
BindingInfo
)
-
>
R
I
:
ToTokens
R
:
ToTokens
{
let
mut
t
=
TokenStream
:
:
new
(
)
;
for
variant
in
&
self
.
variants
{
variant
.
fold
(
&
init
&
mut
f
)
.
to_tokens
(
&
mut
t
)
;
}
if
self
.
omitted_variants
{
quote
!
(
_
=
>
{
#
init
}
)
.
to_tokens
(
&
mut
t
)
;
}
t
}
pub
fn
each_variant
<
F
R
>
(
&
self
mut
f
:
F
)
-
>
TokenStream
where
F
:
FnMut
(
&
VariantInfo
)
-
>
R
R
:
ToTokens
{
let
mut
t
=
TokenStream
:
:
new
(
)
;
for
variant
in
&
self
.
variants
{
let
pat
=
variant
.
pat
(
)
;
let
body
=
f
(
variant
)
;
quote
!
(
#
pat
=
>
{
#
body
}
)
.
to_tokens
(
&
mut
t
)
;
}
if
self
.
omitted_variants
{
quote
!
(
_
=
>
{
}
)
.
to_tokens
(
&
mut
t
)
;
}
t
}
pub
fn
filter
<
F
>
(
&
mut
self
mut
f
:
F
)
-
>
&
mut
Self
where
F
:
FnMut
(
&
BindingInfo
)
-
>
bool
{
for
variant
in
&
mut
self
.
variants
{
variant
.
filter
(
&
mut
f
)
;
}
self
}
pub
fn
add_bounds
(
&
mut
self
mode
:
AddBounds
)
-
>
&
mut
Self
{
self
.
add_bounds
=
mode
;
self
}
pub
fn
filter_variants
<
F
>
(
&
mut
self
f
:
F
)
-
>
&
mut
Self
where
F
:
FnMut
(
&
VariantInfo
)
-
>
bool
{
let
before_len
=
self
.
variants
.
len
(
)
;
self
.
variants
.
retain
(
f
)
;
if
self
.
variants
.
len
(
)
!
=
before_len
{
self
.
omitted_variants
=
true
;
}
self
}
pub
fn
remove_variant
(
&
mut
self
idx
:
usize
)
-
>
&
mut
Self
{
self
.
variants
.
remove
(
idx
)
;
self
.
omitted_variants
=
true
;
self
}
pub
fn
bind_with
<
F
>
(
&
mut
self
mut
f
:
F
)
-
>
&
mut
Self
where
F
:
FnMut
(
&
BindingInfo
)
-
>
BindStyle
{
for
variant
in
&
mut
self
.
variants
{
variant
.
bind_with
(
&
mut
f
)
;
}
self
}
pub
fn
binding_name
<
F
>
(
&
mut
self
mut
f
:
F
)
-
>
&
mut
Self
where
F
:
FnMut
(
&
Field
usize
)
-
>
Ident
{
for
variant
in
&
mut
self
.
variants
{
variant
.
binding_name
(
&
mut
f
)
;
}
self
}
pub
fn
referenced_ty_params
(
&
self
)
-
>
Vec
<
&
'
a
Ident
>
{
let
mut
flags
=
Vec
:
:
new
(
)
;
for
variant
in
&
self
.
variants
{
for
binding
in
&
variant
.
bindings
{
generics_fuse
(
&
mut
flags
&
binding
.
seen_generics
)
;
}
}
fetch_generics
(
&
flags
&
self
.
ast
.
generics
)
}
pub
fn
add_impl_generic
(
&
mut
self
param
:
GenericParam
)
-
>
&
mut
Self
{
self
.
extra_impl
.
push
(
param
)
;
self
}
pub
fn
add_trait_bounds
(
&
self
bound
:
&
TraitBound
where_clause
:
&
mut
Option
<
WhereClause
>
mode
:
AddBounds
)
{
let
mut
seen
=
HashSet
:
:
new
(
)
;
let
mut
pred
=
|
ty
:
Type
|
if
!
seen
.
contains
(
&
ty
)
{
seen
.
insert
(
ty
.
clone
(
)
)
;
if
where_clause
.
is_none
(
)
{
*
where_clause
=
Some
(
WhereClause
{
where_token
:
Default
:
:
default
(
)
predicates
:
punctuated
:
:
Punctuated
:
:
new
(
)
}
)
;
}
let
clause
=
where_clause
.
as_mut
(
)
.
unwrap
(
)
;
clause
.
predicates
.
push
(
WherePredicate
:
:
Type
(
PredicateType
{
lifetimes
:
None
bounded_ty
:
ty
colon_token
:
Default
:
:
default
(
)
bounds
:
Some
(
punctuated
:
:
Pair
:
:
End
(
TypeParamBound
:
:
Trait
(
bound
.
clone
(
)
)
)
)
.
into_iter
(
)
.
collect
(
)
}
)
)
;
}
;
for
variant
in
&
self
.
variants
{
for
binding
in
&
variant
.
bindings
{
match
mode
{
AddBounds
:
:
Both
|
AddBounds
:
:
Fields
=
>
{
for
&
seen
in
&
binding
.
seen_generics
{
if
seen
{
pred
(
binding
.
ast
(
)
.
ty
.
clone
(
)
)
;
break
;
}
}
}
_
=
>
{
}
}
match
mode
{
AddBounds
:
:
Both
|
AddBounds
:
:
Generics
=
>
{
for
param
in
binding
.
referenced_ty_params
(
)
{
pred
(
Type
:
:
Path
(
TypePath
{
qself
:
None
path
:
(
*
param
)
.
clone
(
)
.
into
(
)
}
)
)
;
}
}
_
=
>
{
}
}
}
}
}
pub
fn
bound_impl
<
P
:
ToTokens
B
:
ToTokens
>
(
&
self
path
:
P
body
:
B
)
-
>
TokenStream
{
self
.
impl_internal
(
path
.
into_token_stream
(
)
body
.
into_token_stream
(
)
quote
!
(
)
None
)
}
pub
fn
unsafe_bound_impl
<
P
:
ToTokens
B
:
ToTokens
>
(
&
self
path
:
P
body
:
B
)
-
>
TokenStream
{
self
.
impl_internal
(
path
.
into_token_stream
(
)
body
.
into_token_stream
(
)
quote
!
(
unsafe
)
None
)
}
pub
fn
unbound_impl
<
P
:
ToTokens
B
:
ToTokens
>
(
&
self
path
:
P
body
:
B
)
-
>
TokenStream
{
self
.
impl_internal
(
path
.
into_token_stream
(
)
body
.
into_token_stream
(
)
quote
!
(
)
Some
(
AddBounds
:
:
None
)
)
}
#
[
deprecated
]
pub
fn
unsafe_unbound_impl
<
P
:
ToTokens
B
:
ToTokens
>
(
&
self
path
:
P
body
:
B
)
-
>
TokenStream
{
self
.
impl_internal
(
path
.
into_token_stream
(
)
body
.
into_token_stream
(
)
quote
!
(
unsafe
)
Some
(
AddBounds
:
:
None
)
)
}
fn
impl_internal
(
&
self
path
:
TokenStream
body
:
TokenStream
safety
:
TokenStream
mode
:
Option
<
AddBounds
>
)
-
>
TokenStream
{
let
mode
=
mode
.
unwrap_or
(
self
.
add_bounds
)
;
let
name
=
&
self
.
ast
.
ident
;
let
mut
gen_clone
=
self
.
ast
.
generics
.
clone
(
)
;
gen_clone
.
params
.
extend
(
self
.
extra_impl
.
clone
(
)
.
into_iter
(
)
)
;
let
(
impl_generics
_
_
)
=
gen_clone
.
split_for_impl
(
)
;
let
(
_
ty_generics
where_clause
)
=
self
.
ast
.
generics
.
split_for_impl
(
)
;
let
bound
=
syn
:
:
parse2
:
:
<
TraitBound
>
(
path
.
into
(
)
)
.
expect
(
"
path
argument
must
be
a
valid
rust
trait
bound
"
)
;
let
mut
where_clause
=
where_clause
.
cloned
(
)
;
self
.
add_trait_bounds
(
&
bound
&
mut
where_clause
mode
)
;
let
dummy_const
:
Ident
=
sanitize_ident
(
&
format
!
(
"
_DERIVE_
{
}
_FOR_
{
}
"
(
&
bound
)
.
into_token_stream
(
)
name
.
into_token_stream
(
)
)
)
;
let
mut
extern_crate
=
quote
!
(
)
;
if
bound
.
path
.
leading_colon
.
is_none
(
)
{
if
let
Some
(
ref
seg
)
=
bound
.
path
.
segments
.
first
(
)
{
let
seg
=
seg
.
value
(
)
;
extern_crate
=
quote
!
{
extern
crate
#
seg
;
}
;
}
}
quote
!
{
#
[
allow
(
non_upper_case_globals
)
]
const
#
dummy_const
:
(
)
=
{
#
extern_crate
#
safety
impl
#
impl_generics
#
bound
for
#
name
#
ty_generics
#
where_clause
{
#
body
}
}
;
}
}
pub
fn
gen_impl
(
&
self
cfg
:
TokenStream
)
-
>
TokenStream
{
use
syn
:
:
parse
:
:
{
Parser
ParseStream
Result
}
;
let
do_parse
=
|
input
:
ParseStream
|
-
>
Result
<
TokenStream
>
{
let
parse_prefix
=
|
input
:
ParseStream
|
-
>
Result
<
_
>
{
if
input
.
parse
:
:
<
Ident
>
(
)
?
!
=
"
gen
"
{
return
Err
(
input
.
error
(
"
"
)
)
;
}
let
safety
=
input
.
parse
:
:
<
Option
<
Token
!
[
unsafe
]
>
>
(
)
?
;
let
_
=
input
.
parse
:
:
<
Token
!
[
impl
]
>
(
)
?
;
Ok
(
safety
)
}
;
let
mut
before
=
vec
!
[
]
;
loop
{
if
let
Ok
(
_
)
=
parse_prefix
(
&
input
.
fork
(
)
)
{
break
;
}
before
.
push
(
input
.
parse
:
:
<
TokenTree
>
(
)
?
)
;
}
let
safety
=
parse_prefix
(
input
)
?
;
let
mut
generics
=
input
.
parse
:
:
<
Generics
>
(
)
?
;
let
bound
=
input
.
parse
:
:
<
TraitBound
>
(
)
?
;
let
_
=
input
.
parse
:
:
<
Token
!
[
for
]
>
(
)
?
;
let
_
=
input
.
parse
:
:
<
Token
!
[
]
>
(
)
?
;
let
_
=
input
.
parse
:
:
<
Token
!
[
Self
]
>
(
)
?
;
generics
.
where_clause
=
input
.
parse
(
)
?
;
let
body
;
braced
!
(
body
in
input
)
;
let
body
=
body
.
parse
:
:
<
TokenStream
>
(
)
?
;
let
after
=
input
.
parse
:
:
<
TokenStream
>
(
)
?
;
let
name
=
&
self
.
ast
.
ident
;
merge_generics
(
&
mut
generics
&
self
.
ast
.
generics
)
;
self
.
add_trait_bounds
(
&
bound
&
mut
generics
.
where_clause
self
.
add_bounds
)
;
let
(
impl_generics
_
where_clause
)
=
generics
.
split_for_impl
(
)
;
let
(
_
ty_generics
_
)
=
self
.
ast
.
generics
.
split_for_impl
(
)
;
let
dummy_const
:
Ident
=
sanitize_ident
(
&
format
!
(
"
_DERIVE_
{
}
_FOR_
{
}
"
(
&
bound
)
.
into_token_stream
(
)
name
.
into_token_stream
(
)
)
)
;
Ok
(
quote
!
{
#
[
allow
(
non_upper_case_globals
)
]
const
#
dummy_const
:
(
)
=
{
#
(
#
before
)
*
#
safety
impl
#
impl_generics
#
bound
for
#
name
#
ty_generics
#
where_clause
{
#
body
}
#
after
}
;
}
)
}
;
Parser
:
:
parse2
(
do_parse
cfg
)
.
expect
(
"
Failed
to
parse
gen_impl
"
)
}
}
pub
fn
unpretty_print
<
T
:
std
:
:
fmt
:
:
Display
>
(
ts
:
T
)
-
>
String
{
let
mut
res
=
String
:
:
new
(
)
;
let
raw_s
=
ts
.
to_string
(
)
;
let
mut
s
=
&
raw_s
[
.
.
]
;
let
mut
indent
=
0
;
while
let
Some
(
i
)
=
s
.
find
(
&
[
'
(
'
'
{
'
'
[
'
'
)
'
'
}
'
'
]
'
'
;
'
]
[
.
.
]
)
{
match
&
s
[
i
.
.
i
+
1
]
{
"
(
"
|
"
{
"
|
"
[
"
=
>
indent
+
=
1
"
)
"
|
"
}
"
|
"
]
"
=
>
indent
-
=
1
_
=
>
{
}
}
res
.
push_str
(
&
s
[
.
.
i
+
1
]
)
;
res
.
push
(
'
\
n
'
)
;
for
_
in
0
.
.
indent
{
res
.
push_str
(
"
"
)
;
}
s
=
s
[
i
+
1
.
.
]
.
trim_left_matches
(
'
'
)
;
}
res
.
push_str
(
s
)
;
res
}
