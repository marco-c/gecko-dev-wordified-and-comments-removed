pub
use
proc_macro
:
:
TokenStream
;
pub
use
proc_macro2
:
:
TokenStream
as
TokenStream2
;
pub
use
syn
:
:
{
parse
parse_str
DeriveInput
}
;
#
[
macro_export
]
macro_rules
!
decl_derive
{
(
[
derives
:
ident
(
derive_t
:
tt
)
*
]
=
>
inner
:
path
)
=
>
{
#
[
proc_macro_derive
(
derives
(
derive_t
)
*
)
]
#
[
allow
(
non_snake_case
)
]
pub
fn
derives
(
i
:
crate
:
:
macros
:
:
TokenStream
)
-
>
crate
:
:
macros
:
:
TokenStream
{
match
crate
:
:
macros
:
:
parse
:
:
<
crate
:
:
macros
:
:
DeriveInput
>
(
i
)
{
Ok
(
p
)
=
>
{
match
crate
:
:
Structure
:
:
try_new
(
&
p
)
{
Ok
(
s
)
=
>
crate
:
:
MacroResult
:
:
into_stream
(
inner
(
s
)
)
Err
(
e
)
=
>
e
.
to_compile_error
(
)
.
into
(
)
}
}
Err
(
e
)
=
>
e
.
to_compile_error
(
)
.
into
(
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
decl_attribute
{
(
[
attribute
:
ident
]
=
>
inner
:
path
)
=
>
{
#
[
proc_macro_attribute
]
pub
fn
attribute
(
attr
:
crate
:
:
macros
:
:
TokenStream
i
:
crate
:
:
macros
:
:
TokenStream
)
-
>
crate
:
:
macros
:
:
TokenStream
{
match
crate
:
:
macros
:
:
parse
:
:
<
crate
:
:
macros
:
:
DeriveInput
>
(
i
)
{
Ok
(
p
)
=
>
match
crate
:
:
Structure
:
:
try_new
(
&
p
)
{
Ok
(
s
)
=
>
crate
:
:
MacroResult
:
:
into_stream
(
inner
(
attr
.
into
(
)
s
)
)
Err
(
e
)
=
>
e
.
to_compile_error
(
)
.
into
(
)
}
Err
(
e
)
=
>
e
.
to_compile_error
(
)
.
into
(
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
test_derive
{
(
name
:
path
{
(
i
:
tt
)
*
}
expands
to
{
(
o
:
tt
)
*
}
)
=
>
{
{
#
[
allow
(
dead_code
)
]
fn
ensure_compiles
(
)
{
(
i
)
*
(
o
)
*
}
crate
:
:
test_derive
!
(
name
{
(
i
)
*
}
expands
to
{
(
o
)
*
}
no_build
)
;
}
}
;
(
name
:
path
{
(
i
:
tt
)
*
}
expands
to
{
(
o
:
tt
)
*
}
no_build
)
=
>
{
{
let
i
=
stringify
!
(
(
i
)
*
)
;
let
parsed
=
crate
:
:
macros
:
:
parse_str
:
:
<
crate
:
:
macros
:
:
DeriveInput
>
(
i
)
.
expect
(
concat
!
(
"
Failed
to
parse
input
to
#
[
derive
(
"
stringify
!
(
name
)
"
)
]
"
)
)
;
let
raw_res
=
name
(
crate
:
:
Structure
:
:
new
(
&
parsed
)
)
;
let
res
=
crate
:
:
MacroResult
:
:
into_result
(
raw_res
)
.
expect
(
concat
!
(
"
Procedural
macro
failed
for
#
[
derive
(
"
stringify
!
(
name
)
"
)
]
"
)
)
;
let
expected
=
stringify
!
(
(
o
)
*
)
.
parse
:
:
<
crate
:
:
macros
:
:
TokenStream2
>
(
)
.
expect
(
"
output
should
be
a
valid
TokenStream
"
)
;
let
mut
expected_toks
=
crate
:
:
macros
:
:
TokenStream2
:
:
from
(
expected
)
;
if
res
.
to_string
(
)
!
=
expected_toks
.
to_string
(
)
{
panic
!
(
"
\
test_derive
failed
:
expected
:
{
}
got
:
{
}
\
n
"
crate
:
:
unpretty_print
(
&
expected_toks
)
crate
:
:
unpretty_print
(
&
res
)
)
;
}
}
}
;
}
