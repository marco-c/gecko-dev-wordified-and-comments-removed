#
[
macro_use
]
extern
crate
bitflags
;
mod
channel
;
mod
coefficient
;
pub
use
channel
:
:
Channel
;
use
coefficient
:
:
{
Coefficient
MixingCoefficient
}
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
ops
:
:
{
AddAssign
Mul
}
;
#
[
derive
(
Debug
)
]
pub
struct
Mixer
<
T
>
where
T
:
Copy
+
Debug
+
MixingCoefficient
T
:
:
Coef
:
AddAssign
+
Copy
+
Debug
+
Default
+
Mul
<
T
:
:
Coef
Output
=
T
:
:
Coef
>
{
coefficient
:
Coefficient
<
T
>
}
impl
<
T
>
Mixer
<
T
>
where
T
:
Copy
+
Debug
+
MixingCoefficient
T
:
:
Coef
:
AddAssign
+
Copy
+
Debug
+
Default
+
Mul
<
T
:
:
Coef
Output
=
T
:
:
Coef
>
{
pub
fn
new
(
input_channels
:
&
[
Channel
]
output_channels
:
&
[
Channel
]
)
-
>
Self
{
Self
{
coefficient
:
Coefficient
:
:
create
(
input_channels
output_channels
)
}
}
pub
fn
mix
(
&
self
input_buffer
:
&
[
T
]
output_buffer
:
&
mut
[
T
]
)
{
assert_eq
!
(
input_buffer
.
len
(
)
self
.
input_channels
(
)
.
len
(
)
"
input
slice
must
have
the
same
size
as
the
input
channel
'
s
one
.
"
)
;
assert_eq
!
(
output_buffer
.
len
(
)
self
.
output_channels
(
)
.
len
(
)
"
output
slice
must
have
the
same
size
as
the
output
channel
'
s
one
.
"
)
;
for
(
i
output
)
in
output_buffer
.
iter_mut
(
)
.
enumerate
(
)
{
let
mut
value
=
T
:
:
Coef
:
:
default
(
)
;
for
(
j
input
)
in
input_buffer
.
iter
(
)
.
enumerate
(
)
{
value
+
=
self
.
coefficient
.
get
(
j
i
)
*
T
:
:
to_coefficient_value
(
*
input
)
;
}
*
output
=
T
:
:
from_coefficient_value
(
value
self
.
coefficient
.
would_overflow_from_coefficient_value
(
)
)
;
}
}
pub
fn
input_channels
(
&
self
)
-
>
&
[
Channel
]
{
&
self
.
coefficient
.
input_channels
(
)
}
pub
fn
output_channels
(
&
self
)
-
>
&
[
Channel
]
{
&
self
.
coefficient
.
output_channels
(
)
}
}
