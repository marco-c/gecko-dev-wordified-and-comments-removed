#
[
cfg
(
feature
=
"
compat
"
)
]
use
crate
:
:
compat
:
:
Compat
;
use
core
:
:
pin
:
:
Pin
;
use
futures_core
:
:
{
future
:
:
{
Future
TryFuture
}
stream
:
:
TryStream
task
:
:
{
Context
Poll
}
}
;
mod
and_then
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
and_then
:
:
AndThen
;
mod
err_into
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
err_into
:
:
ErrInto
;
mod
inspect_ok
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
inspect_ok
:
:
InspectOk
;
mod
inspect_err
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
inspect_err
:
:
InspectErr
;
mod
into_stream
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
into_stream
:
:
IntoStream
;
mod
map_ok
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
map_ok
:
:
MapOk
;
mod
map_err
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
map_err
:
:
MapErr
;
mod
or_else
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
or_else
:
:
OrElse
;
mod
try_next
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_next
:
:
TryNext
;
mod
try_for_each
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_for_each
:
:
TryForEach
;
mod
try_filter
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_filter
:
:
TryFilter
;
mod
try_filter_map
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_filter_map
:
:
TryFilterMap
;
mod
try_flatten
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_flatten
:
:
TryFlatten
;
mod
try_collect
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_collect
:
:
TryCollect
;
mod
try_concat
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_concat
:
:
TryConcat
;
mod
try_fold
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_fold
:
:
TryFold
;
mod
try_unfold
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_unfold
:
:
{
try_unfold
TryUnfold
}
;
mod
try_skip_while
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_skip_while
:
:
TrySkipWhile
;
cfg_target_has_atomic
!
{
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
try_buffer_unordered
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
57411
pub
use
self
:
:
try_buffer_unordered
:
:
TryBufferUnordered
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
try_for_each_concurrent
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
57411
pub
use
self
:
:
try_for_each_concurrent
:
:
TryForEachConcurrent
;
}
#
[
cfg
(
feature
=
"
io
"
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
mod
into_async_read
;
#
[
cfg
(
feature
=
"
io
"
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
into_async_read
:
:
IntoAsyncRead
;
impl
<
S
:
?
Sized
+
TryStream
>
TryStreamExt
for
S
{
}
pub
trait
TryStreamExt
:
TryStream
{
fn
err_into
<
E
>
(
self
)
-
>
ErrInto
<
Self
E
>
where
Self
:
Sized
Self
:
:
Error
:
Into
<
E
>
{
ErrInto
:
:
new
(
self
)
}
fn
map_ok
<
T
F
>
(
self
f
:
F
)
-
>
MapOk
<
Self
F
>
where
Self
:
Sized
F
:
FnMut
(
Self
:
:
Ok
)
-
>
T
{
MapOk
:
:
new
(
self
f
)
}
fn
map_err
<
E
F
>
(
self
f
:
F
)
-
>
MapErr
<
Self
F
>
where
Self
:
Sized
F
:
FnMut
(
Self
:
:
Error
)
-
>
E
{
MapErr
:
:
new
(
self
f
)
}
fn
and_then
<
Fut
F
>
(
self
f
:
F
)
-
>
AndThen
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Ok
)
-
>
Fut
Fut
:
TryFuture
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
AndThen
:
:
new
(
self
f
)
}
fn
or_else
<
Fut
F
>
(
self
f
:
F
)
-
>
OrElse
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Error
)
-
>
Fut
Fut
:
TryFuture
<
Ok
=
Self
:
:
Ok
>
Self
:
Sized
{
OrElse
:
:
new
(
self
f
)
}
fn
inspect_ok
<
F
>
(
self
f
:
F
)
-
>
InspectOk
<
Self
F
>
where
F
:
FnMut
(
&
Self
:
:
Ok
)
Self
:
Sized
{
InspectOk
:
:
new
(
self
f
)
}
fn
inspect_err
<
F
>
(
self
f
:
F
)
-
>
InspectErr
<
Self
F
>
where
F
:
FnMut
(
&
Self
:
:
Error
)
Self
:
Sized
{
InspectErr
:
:
new
(
self
f
)
}
fn
into_stream
(
self
)
-
>
IntoStream
<
Self
>
where
Self
:
Sized
{
IntoStream
:
:
new
(
self
)
}
fn
try_next
(
&
mut
self
)
-
>
TryNext
<
'
_
Self
>
where
Self
:
Unpin
{
TryNext
:
:
new
(
self
)
}
fn
try_for_each
<
Fut
F
>
(
self
f
:
F
)
-
>
TryForEach
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Ok
)
-
>
Fut
Fut
:
TryFuture
<
Ok
=
(
)
Error
=
Self
:
:
Error
>
Self
:
Sized
{
TryForEach
:
:
new
(
self
f
)
}
fn
try_skip_while
<
Fut
F
>
(
self
f
:
F
)
-
>
TrySkipWhile
<
Self
Fut
F
>
where
F
:
FnMut
(
&
Self
:
:
Ok
)
-
>
Fut
Fut
:
TryFuture
<
Ok
=
bool
Error
=
Self
:
:
Error
>
Self
:
Sized
{
TrySkipWhile
:
:
new
(
self
f
)
}
#
[
cfg_attr
(
feature
=
"
cfg
-
target
-
has
-
atomic
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
try_for_each_concurrent
<
Fut
F
>
(
self
limit
:
impl
Into
<
Option
<
usize
>
>
f
:
F
)
-
>
TryForEachConcurrent
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Ok
)
-
>
Fut
Fut
:
Future
<
Output
=
Result
<
(
)
Self
:
:
Error
>
>
Self
:
Sized
{
TryForEachConcurrent
:
:
new
(
self
limit
.
into
(
)
f
)
}
fn
try_collect
<
C
:
Default
+
Extend
<
Self
:
:
Ok
>
>
(
self
)
-
>
TryCollect
<
Self
C
>
where
Self
:
Sized
{
TryCollect
:
:
new
(
self
)
}
fn
try_filter
<
Fut
F
>
(
self
f
:
F
)
-
>
TryFilter
<
Self
Fut
F
>
where
Fut
:
Future
<
Output
=
bool
>
F
:
FnMut
(
&
Self
:
:
Ok
)
-
>
Fut
Self
:
Sized
{
TryFilter
:
:
new
(
self
f
)
}
fn
try_filter_map
<
Fut
F
T
>
(
self
f
:
F
)
-
>
TryFilterMap
<
Self
Fut
F
>
where
Fut
:
TryFuture
<
Ok
=
Option
<
T
>
Error
=
Self
:
:
Error
>
F
:
FnMut
(
Self
:
:
Ok
)
-
>
Fut
Self
:
Sized
{
TryFilterMap
:
:
new
(
self
f
)
}
fn
try_flatten
(
self
)
-
>
TryFlatten
<
Self
>
where
Self
:
:
Ok
:
TryStream
<
Self
:
:
Ok
as
TryStream
>
:
:
Error
:
From
<
Self
:
:
Error
>
Self
:
Sized
{
TryFlatten
:
:
new
(
self
)
}
fn
try_fold
<
T
Fut
F
>
(
self
init
:
T
f
:
F
)
-
>
TryFold
<
Self
Fut
T
F
>
where
F
:
FnMut
(
T
Self
:
:
Ok
)
-
>
Fut
Fut
:
TryFuture
<
Ok
=
T
Error
=
Self
:
:
Error
>
Self
:
Sized
{
TryFold
:
:
new
(
self
f
init
)
}
fn
try_concat
(
self
)
-
>
TryConcat
<
Self
>
where
Self
:
Sized
Self
:
:
Ok
:
Extend
<
<
<
Self
as
TryStream
>
:
:
Ok
as
IntoIterator
>
:
:
Item
>
+
IntoIterator
+
Default
{
TryConcat
:
:
new
(
self
)
}
#
[
cfg_attr
(
feature
=
"
cfg
-
target
-
has
-
atomic
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
try_buffer_unordered
(
self
n
:
usize
)
-
>
TryBufferUnordered
<
Self
>
where
Self
:
:
Ok
:
TryFuture
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
TryBufferUnordered
:
:
new
(
self
n
)
}
fn
try_poll_next_unpin
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Result
<
Self
:
:
Ok
Self
:
:
Error
>
>
>
where
Self
:
Unpin
{
Pin
:
:
new
(
self
)
.
try_poll_next
(
cx
)
}
#
[
cfg
(
feature
=
"
compat
"
)
]
fn
compat
(
self
)
-
>
Compat
<
Self
>
where
Self
:
Sized
+
Unpin
{
Compat
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
io
"
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
into_async_read
(
self
)
-
>
IntoAsyncRead
<
Self
>
where
Self
:
Sized
+
TryStreamExt
<
Error
=
std
:
:
io
:
:
Error
>
+
Unpin
Self
:
:
Ok
:
AsRef
<
[
u8
]
>
{
IntoAsyncRead
:
:
new
(
self
)
}
}
