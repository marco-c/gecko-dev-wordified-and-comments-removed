#
[
cfg
(
feature
=
"
compat
"
)
]
use
crate
:
:
compat
:
:
Compat
;
use
crate
:
:
fns
:
:
{
inspect_err_fn
inspect_ok_fn
into_fn
map_err_fn
map_ok_fn
InspectErrFn
InspectOkFn
IntoFn
MapErrFn
MapOkFn
}
;
use
crate
:
:
future
:
:
assert_future
;
use
crate
:
:
stream
:
:
assert_stream
;
use
crate
:
:
stream
:
:
{
Inspect
Map
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
pin
:
:
Pin
;
use
futures_core
:
:
{
future
:
:
{
Future
TryFuture
}
stream
:
:
TryStream
task
:
:
{
Context
Poll
}
}
;
mod
and_then
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
and_then
:
:
AndThen
;
delegate_all
!
(
/
/
/
Stream
for
the
[
err_into
]
(
super
:
:
TryStreamExt
:
:
err_into
)
method
.
ErrInto
<
St
E
>
(
MapErr
<
St
IntoFn
<
E
>
>
)
:
Debug
+
Sink
+
Stream
+
FusedStream
+
AccessInner
[
St
(
.
)
]
+
New
[
|
x
:
St
|
MapErr
:
:
new
(
x
into_fn
(
)
)
]
)
;
delegate_all
!
(
/
/
/
Stream
for
the
[
inspect_ok
]
(
super
:
:
TryStreamExt
:
:
inspect_ok
)
method
.
InspectOk
<
St
F
>
(
Inspect
<
IntoStream
<
St
>
InspectOkFn
<
F
>
>
)
:
Debug
+
Sink
+
Stream
+
FusedStream
+
AccessInner
[
St
(
.
.
)
]
+
New
[
|
x
:
St
f
:
F
|
Inspect
:
:
new
(
IntoStream
:
:
new
(
x
)
inspect_ok_fn
(
f
)
)
]
)
;
delegate_all
!
(
/
/
/
Stream
for
the
[
inspect_err
]
(
super
:
:
TryStreamExt
:
:
inspect_err
)
method
.
InspectErr
<
St
F
>
(
Inspect
<
IntoStream
<
St
>
InspectErrFn
<
F
>
>
)
:
Debug
+
Sink
+
Stream
+
FusedStream
+
AccessInner
[
St
(
.
.
)
]
+
New
[
|
x
:
St
f
:
F
|
Inspect
:
:
new
(
IntoStream
:
:
new
(
x
)
inspect_err_fn
(
f
)
)
]
)
;
mod
into_stream
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
into_stream
:
:
IntoStream
;
delegate_all
!
(
/
/
/
Stream
for
the
[
map_ok
]
(
super
:
:
TryStreamExt
:
:
map_ok
)
method
.
MapOk
<
St
F
>
(
Map
<
IntoStream
<
St
>
MapOkFn
<
F
>
>
)
:
Debug
+
Sink
+
Stream
+
FusedStream
+
AccessInner
[
St
(
.
.
)
]
+
New
[
|
x
:
St
f
:
F
|
Map
:
:
new
(
IntoStream
:
:
new
(
x
)
map_ok_fn
(
f
)
)
]
)
;
delegate_all
!
(
/
/
/
Stream
for
the
[
map_err
]
(
super
:
:
TryStreamExt
:
:
map_err
)
method
.
MapErr
<
St
F
>
(
Map
<
IntoStream
<
St
>
MapErrFn
<
F
>
>
)
:
Debug
+
Sink
+
Stream
+
FusedStream
+
AccessInner
[
St
(
.
.
)
]
+
New
[
|
x
:
St
f
:
F
|
Map
:
:
new
(
IntoStream
:
:
new
(
x
)
map_err_fn
(
f
)
)
]
)
;
mod
or_else
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
or_else
:
:
OrElse
;
mod
try_next
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_next
:
:
TryNext
;
mod
try_for_each
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_for_each
:
:
TryForEach
;
mod
try_filter
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_filter
:
:
TryFilter
;
mod
try_filter_map
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_filter_map
:
:
TryFilterMap
;
mod
try_flatten
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_flatten
:
:
TryFlatten
;
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
try_flatten_unordered
;
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_flatten_unordered
:
:
TryFlattenUnordered
;
mod
try_collect
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_collect
:
:
TryCollect
;
mod
try_concat
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_concat
:
:
TryConcat
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
try_chunks
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_chunks
:
:
{
TryChunks
TryChunksError
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
try_ready_chunks
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_ready_chunks
:
:
{
TryReadyChunks
TryReadyChunksError
}
;
mod
try_fold
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_fold
:
:
TryFold
;
mod
try_unfold
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_unfold
:
:
{
try_unfold
TryUnfold
}
;
mod
try_skip_while
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_skip_while
:
:
TrySkipWhile
;
mod
try_take_while
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_take_while
:
:
TryTakeWhile
;
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
try_buffer_unordered
;
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_buffer_unordered
:
:
TryBufferUnordered
;
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
try_buffered
;
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_buffered
:
:
TryBuffered
;
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
try_for_each_concurrent
;
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_for_each_concurrent
:
:
TryForEachConcurrent
;
#
[
cfg
(
feature
=
"
io
"
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
mod
into_async_read
;
#
[
cfg
(
feature
=
"
io
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
io
"
)
)
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
into_async_read
:
:
IntoAsyncRead
;
mod
try_all
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_all
:
:
TryAll
;
mod
try_any
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
try_any
:
:
TryAny
;
impl
<
S
:
?
Sized
+
TryStream
>
TryStreamExt
for
S
{
}
pub
trait
TryStreamExt
:
TryStream
{
fn
err_into
<
E
>
(
self
)
-
>
ErrInto
<
Self
E
>
where
Self
:
Sized
Self
:
:
Error
:
Into
<
E
>
{
assert_stream
:
:
<
Result
<
Self
:
:
Ok
E
>
_
>
(
ErrInto
:
:
new
(
self
)
)
}
fn
map_ok
<
T
F
>
(
self
f
:
F
)
-
>
MapOk
<
Self
F
>
where
Self
:
Sized
F
:
FnMut
(
Self
:
:
Ok
)
-
>
T
{
assert_stream
:
:
<
Result
<
T
Self
:
:
Error
>
_
>
(
MapOk
:
:
new
(
self
f
)
)
}
fn
map_err
<
E
F
>
(
self
f
:
F
)
-
>
MapErr
<
Self
F
>
where
Self
:
Sized
F
:
FnMut
(
Self
:
:
Error
)
-
>
E
{
assert_stream
:
:
<
Result
<
Self
:
:
Ok
E
>
_
>
(
MapErr
:
:
new
(
self
f
)
)
}
fn
and_then
<
Fut
F
>
(
self
f
:
F
)
-
>
AndThen
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Ok
)
-
>
Fut
Fut
:
TryFuture
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
assert_stream
:
:
<
Result
<
Fut
:
:
Ok
Fut
:
:
Error
>
_
>
(
AndThen
:
:
new
(
self
f
)
)
}
fn
or_else
<
Fut
F
>
(
self
f
:
F
)
-
>
OrElse
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Error
)
-
>
Fut
Fut
:
TryFuture
<
Ok
=
Self
:
:
Ok
>
Self
:
Sized
{
assert_stream
:
:
<
Result
<
Self
:
:
Ok
Fut
:
:
Error
>
_
>
(
OrElse
:
:
new
(
self
f
)
)
}
fn
inspect_ok
<
F
>
(
self
f
:
F
)
-
>
InspectOk
<
Self
F
>
where
F
:
FnMut
(
&
Self
:
:
Ok
)
Self
:
Sized
{
assert_stream
:
:
<
Result
<
Self
:
:
Ok
Self
:
:
Error
>
_
>
(
InspectOk
:
:
new
(
self
f
)
)
}
fn
inspect_err
<
F
>
(
self
f
:
F
)
-
>
InspectErr
<
Self
F
>
where
F
:
FnMut
(
&
Self
:
:
Error
)
Self
:
Sized
{
assert_stream
:
:
<
Result
<
Self
:
:
Ok
Self
:
:
Error
>
_
>
(
InspectErr
:
:
new
(
self
f
)
)
}
fn
into_stream
(
self
)
-
>
IntoStream
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
Result
<
Self
:
:
Ok
Self
:
:
Error
>
_
>
(
IntoStream
:
:
new
(
self
)
)
}
fn
try_next
(
&
mut
self
)
-
>
TryNext
<
'
_
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
Option
<
Self
:
:
Ok
>
Self
:
:
Error
>
_
>
(
TryNext
:
:
new
(
self
)
)
}
fn
try_for_each
<
Fut
F
>
(
self
f
:
F
)
-
>
TryForEach
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Ok
)
-
>
Fut
Fut
:
TryFuture
<
Ok
=
(
)
Error
=
Self
:
:
Error
>
Self
:
Sized
{
assert_future
:
:
<
Result
<
(
)
Self
:
:
Error
>
_
>
(
TryForEach
:
:
new
(
self
f
)
)
}
fn
try_skip_while
<
Fut
F
>
(
self
f
:
F
)
-
>
TrySkipWhile
<
Self
Fut
F
>
where
F
:
FnMut
(
&
Self
:
:
Ok
)
-
>
Fut
Fut
:
TryFuture
<
Ok
=
bool
Error
=
Self
:
:
Error
>
Self
:
Sized
{
assert_stream
:
:
<
Result
<
Self
:
:
Ok
Self
:
:
Error
>
_
>
(
TrySkipWhile
:
:
new
(
self
f
)
)
}
fn
try_take_while
<
Fut
F
>
(
self
f
:
F
)
-
>
TryTakeWhile
<
Self
Fut
F
>
where
F
:
FnMut
(
&
Self
:
:
Ok
)
-
>
Fut
Fut
:
TryFuture
<
Ok
=
bool
Error
=
Self
:
:
Error
>
Self
:
Sized
{
assert_stream
:
:
<
Result
<
Self
:
:
Ok
Self
:
:
Error
>
_
>
(
TryTakeWhile
:
:
new
(
self
f
)
)
}
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
try_for_each_concurrent
<
Fut
F
>
(
self
limit
:
impl
Into
<
Option
<
usize
>
>
f
:
F
)
-
>
TryForEachConcurrent
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Ok
)
-
>
Fut
Fut
:
Future
<
Output
=
Result
<
(
)
Self
:
:
Error
>
>
Self
:
Sized
{
assert_future
:
:
<
Result
<
(
)
Self
:
:
Error
>
_
>
(
TryForEachConcurrent
:
:
new
(
self
limit
.
into
(
)
f
)
)
}
fn
try_collect
<
C
:
Default
+
Extend
<
Self
:
:
Ok
>
>
(
self
)
-
>
TryCollect
<
Self
C
>
where
Self
:
Sized
{
assert_future
:
:
<
Result
<
C
Self
:
:
Error
>
_
>
(
TryCollect
:
:
new
(
self
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
try_chunks
(
self
capacity
:
usize
)
-
>
TryChunks
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
Result
<
Vec
<
Self
:
:
Ok
>
TryChunksError
<
Self
:
:
Ok
Self
:
:
Error
>
>
_
>
(
TryChunks
:
:
new
(
self
capacity
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
try_ready_chunks
(
self
capacity
:
usize
)
-
>
TryReadyChunks
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
Result
<
Vec
<
Self
:
:
Ok
>
TryReadyChunksError
<
Self
:
:
Ok
Self
:
:
Error
>
>
_
>
(
TryReadyChunks
:
:
new
(
self
capacity
)
)
}
fn
try_filter
<
Fut
F
>
(
self
f
:
F
)
-
>
TryFilter
<
Self
Fut
F
>
where
Fut
:
Future
<
Output
=
bool
>
F
:
FnMut
(
&
Self
:
:
Ok
)
-
>
Fut
Self
:
Sized
{
assert_stream
:
:
<
Result
<
Self
:
:
Ok
Self
:
:
Error
>
_
>
(
TryFilter
:
:
new
(
self
f
)
)
}
fn
try_filter_map
<
Fut
F
T
>
(
self
f
:
F
)
-
>
TryFilterMap
<
Self
Fut
F
>
where
Fut
:
TryFuture
<
Ok
=
Option
<
T
>
Error
=
Self
:
:
Error
>
F
:
FnMut
(
Self
:
:
Ok
)
-
>
Fut
Self
:
Sized
{
assert_stream
:
:
<
Result
<
T
Self
:
:
Error
>
_
>
(
TryFilterMap
:
:
new
(
self
f
)
)
}
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
try_flatten_unordered
(
self
limit
:
impl
Into
<
Option
<
usize
>
>
)
-
>
TryFlattenUnordered
<
Self
>
where
Self
:
:
Ok
:
TryStream
+
Unpin
<
Self
:
:
Ok
as
TryStream
>
:
:
Error
:
From
<
Self
:
:
Error
>
Self
:
Sized
{
assert_stream
:
:
<
Result
<
<
Self
:
:
Ok
as
TryStream
>
:
:
Ok
<
Self
:
:
Ok
as
TryStream
>
:
:
Error
>
_
>
(
TryFlattenUnordered
:
:
new
(
self
limit
)
)
}
fn
try_flatten
(
self
)
-
>
TryFlatten
<
Self
>
where
Self
:
:
Ok
:
TryStream
<
Self
:
:
Ok
as
TryStream
>
:
:
Error
:
From
<
Self
:
:
Error
>
Self
:
Sized
{
assert_stream
:
:
<
Result
<
<
Self
:
:
Ok
as
TryStream
>
:
:
Ok
<
Self
:
:
Ok
as
TryStream
>
:
:
Error
>
_
>
(
TryFlatten
:
:
new
(
self
)
)
}
fn
try_fold
<
T
Fut
F
>
(
self
init
:
T
f
:
F
)
-
>
TryFold
<
Self
Fut
T
F
>
where
F
:
FnMut
(
T
Self
:
:
Ok
)
-
>
Fut
Fut
:
TryFuture
<
Ok
=
T
Error
=
Self
:
:
Error
>
Self
:
Sized
{
assert_future
:
:
<
Result
<
T
Self
:
:
Error
>
_
>
(
TryFold
:
:
new
(
self
f
init
)
)
}
fn
try_concat
(
self
)
-
>
TryConcat
<
Self
>
where
Self
:
Sized
Self
:
:
Ok
:
Extend
<
<
<
Self
as
TryStream
>
:
:
Ok
as
IntoIterator
>
:
:
Item
>
+
IntoIterator
+
Default
{
assert_future
:
:
<
Result
<
Self
:
:
Ok
Self
:
:
Error
>
_
>
(
TryConcat
:
:
new
(
self
)
)
}
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
try_buffer_unordered
(
self
n
:
usize
)
-
>
TryBufferUnordered
<
Self
>
where
Self
:
:
Ok
:
TryFuture
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
assert_stream
:
:
<
Result
<
<
Self
:
:
Ok
as
TryFuture
>
:
:
Ok
Self
:
:
Error
>
_
>
(
TryBufferUnordered
:
:
new
(
self
n
)
)
}
#
[
cfg_attr
(
target_os
=
"
none
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
try_buffered
(
self
n
:
usize
)
-
>
TryBuffered
<
Self
>
where
Self
:
:
Ok
:
TryFuture
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
assert_stream
:
:
<
Result
<
<
Self
:
:
Ok
as
TryFuture
>
:
:
Ok
Self
:
:
Error
>
_
>
(
TryBuffered
:
:
new
(
self
n
)
)
}
fn
try_poll_next_unpin
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Result
<
Self
:
:
Ok
Self
:
:
Error
>
>
>
where
Self
:
Unpin
{
Pin
:
:
new
(
self
)
.
try_poll_next
(
cx
)
}
#
[
cfg
(
feature
=
"
compat
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
compat
"
)
)
)
]
fn
compat
(
self
)
-
>
Compat
<
Self
>
where
Self
:
Sized
+
Unpin
{
Compat
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
io
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
io
"
)
)
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
into_async_read
(
self
)
-
>
IntoAsyncRead
<
Self
>
where
Self
:
Sized
+
TryStreamExt
<
Error
=
std
:
:
io
:
:
Error
>
Self
:
:
Ok
:
AsRef
<
[
u8
]
>
{
crate
:
:
io
:
:
assert_read
(
IntoAsyncRead
:
:
new
(
self
)
)
}
fn
try_all
<
Fut
F
>
(
self
f
:
F
)
-
>
TryAll
<
Self
Fut
F
>
where
Self
:
Sized
F
:
FnMut
(
Self
:
:
Ok
)
-
>
Fut
Fut
:
Future
<
Output
=
bool
>
{
assert_future
:
:
<
Result
<
bool
Self
:
:
Error
>
_
>
(
TryAll
:
:
new
(
self
f
)
)
}
fn
try_any
<
Fut
F
>
(
self
f
:
F
)
-
>
TryAny
<
Self
Fut
F
>
where
Self
:
Sized
F
:
FnMut
(
Self
:
:
Ok
)
-
>
Fut
Fut
:
Future
<
Output
=
bool
>
{
assert_future
:
:
<
Result
<
bool
Self
:
:
Error
>
_
>
(
TryAny
:
:
new
(
self
f
)
)
}
}
