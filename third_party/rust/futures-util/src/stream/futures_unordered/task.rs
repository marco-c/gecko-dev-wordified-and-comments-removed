use
alloc
:
:
sync
:
:
{
Arc
Weak
}
;
use
core
:
:
cell
:
:
UnsafeCell
;
use
core
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
self
Relaxed
SeqCst
}
;
use
core
:
:
sync
:
:
atomic
:
:
{
AtomicBool
AtomicPtr
}
;
use
super
:
:
abort
:
:
abort
;
use
super
:
:
ReadyToRunQueue
;
use
crate
:
:
task
:
:
ArcWake
;
pub
(
super
)
struct
Task
<
Fut
>
{
pub
(
super
)
future
:
UnsafeCell
<
Option
<
Fut
>
>
pub
(
super
)
next_all
:
AtomicPtr
<
Task
<
Fut
>
>
pub
(
super
)
prev_all
:
UnsafeCell
<
*
const
Task
<
Fut
>
>
pub
(
super
)
len_all
:
UnsafeCell
<
usize
>
pub
(
super
)
next_ready_to_run
:
AtomicPtr
<
Task
<
Fut
>
>
pub
(
super
)
ready_to_run_queue
:
Weak
<
ReadyToRunQueue
<
Fut
>
>
pub
(
super
)
queued
:
AtomicBool
pub
(
super
)
woken
:
AtomicBool
}
unsafe
impl
<
Fut
>
Send
for
Task
<
Fut
>
{
}
unsafe
impl
<
Fut
>
Sync
for
Task
<
Fut
>
{
}
impl
<
Fut
>
ArcWake
for
Task
<
Fut
>
{
fn
wake_by_ref
(
arc_self
:
&
Arc
<
Self
>
)
{
let
inner
=
match
arc_self
.
ready_to_run_queue
.
upgrade
(
)
{
Some
(
inner
)
=
>
inner
None
=
>
return
}
;
arc_self
.
woken
.
store
(
true
Relaxed
)
;
let
prev
=
arc_self
.
queued
.
swap
(
true
SeqCst
)
;
if
!
prev
{
inner
.
enqueue
(
Arc
:
:
as_ptr
(
arc_self
)
)
;
inner
.
waker
.
wake
(
)
;
}
}
}
impl
<
Fut
>
Task
<
Fut
>
{
pub
(
super
)
unsafe
fn
waker_ref
(
this
:
&
Arc
<
Self
>
)
-
>
waker_ref
:
:
WakerRef
<
'
_
>
{
unsafe
{
waker_ref
:
:
waker_ref
(
this
)
}
}
#
[
inline
]
pub
(
super
)
fn
spin_next_all
(
&
self
pending_next_all
:
*
mut
Self
ordering
:
Ordering
)
-
>
*
const
Self
{
loop
{
let
next
=
self
.
next_all
.
load
(
ordering
)
;
if
next
!
=
pending_next_all
{
return
next
;
}
}
}
}
impl
<
Fut
>
Drop
for
Task
<
Fut
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
(
*
self
.
future
.
get
(
)
)
.
is_some
(
)
{
abort
(
"
future
still
here
when
dropping
"
)
;
}
}
}
}
mod
waker_ref
{
use
alloc
:
:
sync
:
:
Arc
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
;
use
core
:
:
mem
:
:
ManuallyDrop
;
use
core
:
:
ops
:
:
Deref
;
use
core
:
:
task
:
:
{
RawWaker
RawWakerVTable
Waker
}
;
use
futures_task
:
:
ArcWake
;
pub
(
crate
)
struct
WakerRef
<
'
a
>
{
waker
:
ManuallyDrop
<
Waker
>
_marker
:
PhantomData
<
&
'
a
(
)
>
}
impl
WakerRef
<
'
_
>
{
#
[
inline
]
fn
new_unowned
(
waker
:
ManuallyDrop
<
Waker
>
)
-
>
Self
{
Self
{
waker
_marker
:
PhantomData
}
}
}
impl
Deref
for
WakerRef
<
'
_
>
{
type
Target
=
Waker
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
Waker
{
&
self
.
waker
}
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
waker_ref
<
W
>
(
wake
:
&
Arc
<
W
>
)
-
>
WakerRef
<
'
_
>
where
W
:
ArcWake
{
let
ptr
=
Arc
:
:
as_ptr
(
wake
)
.
cast
:
:
<
(
)
>
(
)
;
let
waker
=
ManuallyDrop
:
:
new
(
unsafe
{
Waker
:
:
from_raw
(
RawWaker
:
:
new
(
ptr
waker_vtable
:
:
<
W
>
(
)
)
)
}
)
;
WakerRef
:
:
new_unowned
(
waker
)
}
fn
waker_vtable
<
W
:
ArcWake
>
(
)
-
>
&
'
static
RawWakerVTable
{
&
RawWakerVTable
:
:
new
(
clone_arc_raw
:
:
<
W
>
wake_arc_raw
:
:
<
W
>
wake_by_ref_arc_raw
:
:
<
W
>
drop_arc_raw
:
:
<
W
>
)
}
unsafe
fn
increase_refcount
<
T
:
ArcWake
>
(
data
:
*
const
(
)
)
{
let
arc
=
mem
:
:
ManuallyDrop
:
:
new
(
unsafe
{
Arc
:
:
<
T
>
:
:
from_raw
(
data
.
cast
:
:
<
T
>
(
)
)
}
)
;
let
_arc_clone
:
mem
:
:
ManuallyDrop
<
_
>
=
arc
.
clone
(
)
;
}
unsafe
fn
clone_arc_raw
<
T
:
ArcWake
>
(
data
:
*
const
(
)
)
-
>
RawWaker
{
unsafe
{
increase_refcount
:
:
<
T
>
(
data
)
}
RawWaker
:
:
new
(
data
waker_vtable
:
:
<
T
>
(
)
)
}
unsafe
fn
wake_arc_raw
<
T
:
ArcWake
>
(
data
:
*
const
(
)
)
{
let
arc
:
Arc
<
T
>
=
unsafe
{
Arc
:
:
from_raw
(
data
.
cast
:
:
<
T
>
(
)
)
}
;
ArcWake
:
:
wake
(
arc
)
;
}
unsafe
fn
wake_by_ref_arc_raw
<
T
:
ArcWake
>
(
data
:
*
const
(
)
)
{
let
arc
=
mem
:
:
ManuallyDrop
:
:
new
(
unsafe
{
Arc
:
:
<
T
>
:
:
from_raw
(
data
.
cast
:
:
<
T
>
(
)
)
}
)
;
ArcWake
:
:
wake_by_ref
(
&
arc
)
;
}
unsafe
fn
drop_arc_raw
<
T
:
ArcWake
>
(
data
:
*
const
(
)
)
{
drop
(
unsafe
{
Arc
:
:
<
T
>
:
:
from_raw
(
data
.
cast
:
:
<
T
>
(
)
)
}
)
}
}
