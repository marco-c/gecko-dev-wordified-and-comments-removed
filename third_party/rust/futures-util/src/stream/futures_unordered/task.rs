use
core
:
:
cell
:
:
UnsafeCell
;
use
core
:
:
sync
:
:
atomic
:
:
{
AtomicPtr
AtomicBool
}
;
use
core
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
self
SeqCst
}
;
use
alloc
:
:
sync
:
:
{
Arc
Weak
}
;
use
crate
:
:
task
:
:
{
ArcWake
WakerRef
waker_ref
}
;
use
super
:
:
ReadyToRunQueue
;
use
super
:
:
abort
:
:
abort
;
pub
(
super
)
struct
Task
<
Fut
>
{
pub
(
super
)
future
:
UnsafeCell
<
Option
<
Fut
>
>
pub
(
super
)
next_all
:
AtomicPtr
<
Task
<
Fut
>
>
pub
(
super
)
prev_all
:
UnsafeCell
<
*
const
Task
<
Fut
>
>
pub
(
super
)
len_all
:
UnsafeCell
<
usize
>
pub
(
super
)
next_ready_to_run
:
AtomicPtr
<
Task
<
Fut
>
>
pub
(
super
)
ready_to_run_queue
:
Weak
<
ReadyToRunQueue
<
Fut
>
>
pub
(
super
)
queued
:
AtomicBool
}
unsafe
impl
<
Fut
>
Send
for
Task
<
Fut
>
{
}
unsafe
impl
<
Fut
>
Sync
for
Task
<
Fut
>
{
}
impl
<
Fut
>
ArcWake
for
Task
<
Fut
>
{
fn
wake_by_ref
(
arc_self
:
&
Arc
<
Self
>
)
{
let
inner
=
match
arc_self
.
ready_to_run_queue
.
upgrade
(
)
{
Some
(
inner
)
=
>
inner
None
=
>
return
}
;
let
prev
=
arc_self
.
queued
.
swap
(
true
SeqCst
)
;
if
!
prev
{
inner
.
enqueue
(
&
*
*
arc_self
)
;
inner
.
waker
.
wake
(
)
;
}
}
}
impl
<
Fut
>
Task
<
Fut
>
{
pub
(
super
)
fn
waker_ref
<
'
a
>
(
this
:
&
'
a
Arc
<
Task
<
Fut
>
>
)
-
>
WakerRef
<
'
a
>
{
waker_ref
(
this
)
}
#
[
inline
]
pub
(
super
)
fn
spin_next_all
(
&
self
pending_next_all
:
*
mut
Self
ordering
:
Ordering
)
-
>
*
const
Self
{
loop
{
let
next
=
self
.
next_all
.
load
(
ordering
)
;
if
next
!
=
pending_next_all
{
return
next
;
}
}
}
}
impl
<
Fut
>
Drop
for
Task
<
Fut
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
(
*
self
.
future
.
get
(
)
)
.
is_some
(
)
{
abort
(
"
future
still
here
when
dropping
"
)
;
}
}
}
}
