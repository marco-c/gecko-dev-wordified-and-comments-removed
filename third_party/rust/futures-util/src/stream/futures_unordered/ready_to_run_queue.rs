use
crate
:
:
task
:
:
AtomicWaker
;
use
alloc
:
:
sync
:
:
Arc
;
use
core
:
:
cell
:
:
UnsafeCell
;
use
core
:
:
ptr
;
use
core
:
:
sync
:
:
atomic
:
:
AtomicPtr
;
use
core
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
AcqRel
Acquire
Relaxed
Release
}
;
use
super
:
:
abort
:
:
abort
;
use
super
:
:
task
:
:
Task
;
pub
(
super
)
enum
Dequeue
<
Fut
>
{
Data
(
*
const
Task
<
Fut
>
)
Empty
Inconsistent
}
pub
(
super
)
struct
ReadyToRunQueue
<
Fut
>
{
pub
(
super
)
waker
:
AtomicWaker
pub
(
super
)
head
:
AtomicPtr
<
Task
<
Fut
>
>
pub
(
super
)
tail
:
UnsafeCell
<
*
const
Task
<
Fut
>
>
pub
(
super
)
stub
:
Arc
<
Task
<
Fut
>
>
}
impl
<
Fut
>
ReadyToRunQueue
<
Fut
>
{
pub
(
super
)
fn
enqueue
(
&
self
task
:
*
const
Task
<
Fut
>
)
{
unsafe
{
debug_assert
!
(
(
*
task
)
.
queued
.
load
(
Relaxed
)
)
;
(
*
task
)
.
next_ready_to_run
.
store
(
ptr
:
:
null_mut
(
)
Relaxed
)
;
let
task
=
task
as
*
mut
_
;
let
prev
=
self
.
head
.
swap
(
task
AcqRel
)
;
(
*
prev
)
.
next_ready_to_run
.
store
(
task
Release
)
;
}
}
pub
(
super
)
unsafe
fn
dequeue
(
&
self
)
-
>
Dequeue
<
Fut
>
{
unsafe
{
let
mut
tail
=
*
self
.
tail
.
get
(
)
;
let
mut
next
=
(
*
tail
)
.
next_ready_to_run
.
load
(
Acquire
)
;
if
tail
=
=
self
.
stub
(
)
{
if
next
.
is_null
(
)
{
return
Dequeue
:
:
Empty
;
}
*
self
.
tail
.
get
(
)
=
next
;
tail
=
next
;
next
=
(
*
next
)
.
next_ready_to_run
.
load
(
Acquire
)
;
}
if
!
next
.
is_null
(
)
{
*
self
.
tail
.
get
(
)
=
next
;
debug_assert
!
(
tail
!
=
self
.
stub
(
)
)
;
return
Dequeue
:
:
Data
(
tail
)
;
}
if
self
.
head
.
load
(
Acquire
)
as
*
const
_
!
=
tail
{
return
Dequeue
:
:
Inconsistent
;
}
self
.
enqueue
(
self
.
stub
(
)
)
;
next
=
(
*
tail
)
.
next_ready_to_run
.
load
(
Acquire
)
;
if
!
next
.
is_null
(
)
{
*
self
.
tail
.
get
(
)
=
next
;
return
Dequeue
:
:
Data
(
tail
)
;
}
Dequeue
:
:
Inconsistent
}
}
pub
(
super
)
fn
stub
(
&
self
)
-
>
*
const
Task
<
Fut
>
{
Arc
:
:
as_ptr
(
&
self
.
stub
)
}
}
impl
<
Fut
>
Drop
for
ReadyToRunQueue
<
Fut
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
loop
{
match
self
.
dequeue
(
)
{
Dequeue
:
:
Empty
=
>
break
Dequeue
:
:
Inconsistent
=
>
abort
(
"
inconsistent
in
drop
"
)
Dequeue
:
:
Data
(
ptr
)
=
>
drop
(
Arc
:
:
from_raw
(
ptr
)
)
}
}
}
}
}
