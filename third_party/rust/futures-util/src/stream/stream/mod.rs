use
crate
:
:
future
:
:
{
assert_future
Either
}
;
use
crate
:
:
stream
:
:
assert_stream
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
boxed
:
:
Box
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
pin
:
:
Pin
;
#
[
cfg
(
feature
=
"
sink
"
)
]
use
futures_core
:
:
stream
:
:
TryStream
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
futures_core
:
:
stream
:
:
{
BoxStream
LocalBoxStream
}
;
use
futures_core
:
:
{
future
:
:
Future
stream
:
:
{
FusedStream
Stream
}
task
:
:
{
Context
Poll
}
}
;
#
[
cfg
(
feature
=
"
sink
"
)
]
use
futures_sink
:
:
Sink
;
use
crate
:
:
fns
:
:
{
inspect_fn
InspectFn
}
;
mod
chain
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
chain
:
:
Chain
;
mod
collect
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
collect
:
:
Collect
;
mod
unzip
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
unzip
:
:
Unzip
;
mod
concat
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
concat
:
:
Concat
;
mod
cycle
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
cycle
:
:
Cycle
;
mod
enumerate
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
enumerate
:
:
Enumerate
;
mod
filter
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
filter
:
:
Filter
;
mod
filter_map
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
filter_map
:
:
FilterMap
;
mod
flatten
;
delegate_all
!
(
/
/
/
Stream
for
the
[
flatten
]
(
StreamExt
:
:
flatten
)
method
.
Flatten
<
St
>
(
flatten
:
:
Flatten
<
St
St
:
:
Item
>
)
:
Debug
+
Sink
+
Stream
+
FusedStream
+
AccessInner
[
St
(
.
)
]
+
New
[
|
x
:
St
|
flatten
:
:
Flatten
:
:
new
(
x
)
]
where
St
:
Stream
)
;
mod
fold
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
fold
:
:
Fold
;
#
[
cfg
(
feature
=
"
sink
"
)
]
mod
forward
;
#
[
cfg
(
feature
=
"
sink
"
)
]
delegate_all
!
(
/
/
/
Future
for
the
[
forward
]
(
super
:
:
StreamExt
:
:
forward
)
method
.
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
sink
"
)
)
)
]
Forward
<
St
Si
>
(
forward
:
:
Forward
<
St
Si
St
:
:
Ok
>
)
:
Debug
+
Future
+
FusedFuture
+
New
[
|
x
:
St
y
:
Si
|
forward
:
:
Forward
:
:
new
(
x
y
)
]
where
St
:
TryStream
)
;
mod
for_each
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
for_each
:
:
ForEach
;
mod
fuse
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
fuse
:
:
Fuse
;
mod
into_future
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
into_future
:
:
StreamFuture
;
delegate_all
!
(
/
/
/
Stream
for
the
[
inspect
]
(
StreamExt
:
:
inspect
)
method
.
Inspect
<
St
F
>
(
map
:
:
Map
<
St
InspectFn
<
F
>
>
)
:
Debug
+
Sink
+
Stream
+
FusedStream
+
AccessInner
[
St
(
.
)
]
+
New
[
|
x
:
St
f
:
F
|
map
:
:
Map
:
:
new
(
x
inspect_fn
(
f
)
)
]
)
;
mod
map
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
map
:
:
Map
;
delegate_all
!
(
/
/
/
Stream
for
the
[
flat_map
]
(
StreamExt
:
:
flat_map
)
method
.
FlatMap
<
St
U
F
>
(
flatten
:
:
Flatten
<
Map
<
St
F
>
U
>
)
:
Debug
+
Sink
+
Stream
+
FusedStream
+
AccessInner
[
St
(
.
.
)
]
+
New
[
|
x
:
St
f
:
F
|
flatten
:
:
Flatten
:
:
new
(
Map
:
:
new
(
x
f
)
)
]
)
;
mod
next
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
next
:
:
Next
;
mod
select_next_some
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
select_next_some
:
:
SelectNextSome
;
mod
peek
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
peek
:
:
{
NextIf
NextIfEq
Peek
Peekable
}
;
mod
skip
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
skip
:
:
Skip
;
mod
skip_while
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
skip_while
:
:
SkipWhile
;
mod
take
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
take
:
:
Take
;
mod
take_while
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
take_while
:
:
TakeWhile
;
mod
take_until
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
take_until
:
:
TakeUntil
;
mod
then
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
then
:
:
Then
;
mod
zip
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
zip
:
:
Zip
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
chunks
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
chunks
:
:
Chunks
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
ready_chunks
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
ready_chunks
:
:
ReadyChunks
;
mod
scan
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
scan
:
:
Scan
;
cfg_target_has_atomic
!
{
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
buffer_unordered
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
57411
pub
use
self
:
:
buffer_unordered
:
:
BufferUnordered
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
buffered
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
57411
pub
use
self
:
:
buffered
:
:
Buffered
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
for_each_concurrent
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
57411
pub
use
self
:
:
for_each_concurrent
:
:
ForEachConcurrent
;
#
[
cfg
(
feature
=
"
sink
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
sink
"
)
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
split
;
#
[
cfg
(
feature
=
"
sink
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
sink
"
)
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
57411
pub
use
self
:
:
split
:
:
{
SplitStream
SplitSink
ReuniteError
}
;
}
#
[
cfg
(
feature
=
"
std
"
)
]
mod
catch_unwind
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
catch_unwind
:
:
CatchUnwind
;
impl
<
T
:
?
Sized
>
StreamExt
for
T
where
T
:
Stream
{
}
pub
trait
StreamExt
:
Stream
{
fn
next
(
&
mut
self
)
-
>
Next
<
'
_
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Option
<
Self
:
:
Item
>
_
>
(
Next
:
:
new
(
self
)
)
}
fn
into_future
(
self
)
-
>
StreamFuture
<
Self
>
where
Self
:
Sized
+
Unpin
{
assert_future
:
:
<
(
Option
<
Self
:
:
Item
>
Self
)
_
>
(
StreamFuture
:
:
new
(
self
)
)
}
fn
map
<
T
F
>
(
self
f
:
F
)
-
>
Map
<
Self
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
T
Self
:
Sized
{
assert_stream
:
:
<
T
_
>
(
Map
:
:
new
(
self
f
)
)
}
fn
enumerate
(
self
)
-
>
Enumerate
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
(
usize
Self
:
:
Item
)
_
>
(
Enumerate
:
:
new
(
self
)
)
}
fn
filter
<
Fut
F
>
(
self
f
:
F
)
-
>
Filter
<
Self
Fut
F
>
where
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
bool
>
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Filter
:
:
new
(
self
f
)
)
}
fn
filter_map
<
Fut
T
F
>
(
self
f
:
F
)
-
>
FilterMap
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
Option
<
T
>
>
Self
:
Sized
{
assert_stream
:
:
<
T
_
>
(
FilterMap
:
:
new
(
self
f
)
)
}
fn
then
<
Fut
F
>
(
self
f
:
F
)
-
>
Then
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
Self
:
Sized
{
assert_stream
:
:
<
Fut
:
:
Output
_
>
(
Then
:
:
new
(
self
f
)
)
}
fn
collect
<
C
:
Default
+
Extend
<
Self
:
:
Item
>
>
(
self
)
-
>
Collect
<
Self
C
>
where
Self
:
Sized
{
assert_future
:
:
<
C
_
>
(
Collect
:
:
new
(
self
)
)
}
fn
unzip
<
A
B
FromA
FromB
>
(
self
)
-
>
Unzip
<
Self
FromA
FromB
>
where
FromA
:
Default
+
Extend
<
A
>
FromB
:
Default
+
Extend
<
B
>
Self
:
Sized
+
Stream
<
Item
=
(
A
B
)
>
{
assert_future
:
:
<
(
FromA
FromB
)
_
>
(
Unzip
:
:
new
(
self
)
)
}
fn
concat
(
self
)
-
>
Concat
<
Self
>
where
Self
:
Sized
Self
:
:
Item
:
Extend
<
<
<
Self
as
Stream
>
:
:
Item
as
IntoIterator
>
:
:
Item
>
+
IntoIterator
+
Default
{
assert_future
:
:
<
Self
:
:
Item
_
>
(
Concat
:
:
new
(
self
)
)
}
fn
cycle
(
self
)
-
>
Cycle
<
Self
>
where
Self
:
Sized
+
Clone
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Cycle
:
:
new
(
self
)
)
}
fn
fold
<
T
Fut
F
>
(
self
init
:
T
f
:
F
)
-
>
Fold
<
Self
Fut
T
F
>
where
F
:
FnMut
(
T
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
T
>
Self
:
Sized
{
assert_future
:
:
<
T
_
>
(
Fold
:
:
new
(
self
f
init
)
)
}
fn
flatten
(
self
)
-
>
Flatten
<
Self
>
where
Self
:
:
Item
:
Stream
Self
:
Sized
{
assert_stream
:
:
<
<
Self
:
:
Item
as
Stream
>
:
:
Item
_
>
(
Flatten
:
:
new
(
self
)
)
}
fn
flat_map
<
U
F
>
(
self
f
:
F
)
-
>
FlatMap
<
Self
U
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
U
U
:
Stream
Self
:
Sized
{
assert_stream
:
:
<
U
:
:
Item
_
>
(
FlatMap
:
:
new
(
self
f
)
)
}
fn
scan
<
S
B
Fut
F
>
(
self
initial_state
:
S
f
:
F
)
-
>
Scan
<
Self
S
Fut
F
>
where
F
:
FnMut
(
&
mut
S
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
Option
<
B
>
>
Self
:
Sized
{
assert_stream
:
:
<
B
_
>
(
Scan
:
:
new
(
self
initial_state
f
)
)
}
fn
skip_while
<
Fut
F
>
(
self
f
:
F
)
-
>
SkipWhile
<
Self
Fut
F
>
where
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
bool
>
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
SkipWhile
:
:
new
(
self
f
)
)
}
fn
take_while
<
Fut
F
>
(
self
f
:
F
)
-
>
TakeWhile
<
Self
Fut
F
>
where
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
bool
>
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
TakeWhile
:
:
new
(
self
f
)
)
}
fn
take_until
<
Fut
>
(
self
fut
:
Fut
)
-
>
TakeUntil
<
Self
Fut
>
where
Fut
:
Future
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
TakeUntil
:
:
new
(
self
fut
)
)
}
fn
for_each
<
Fut
F
>
(
self
f
:
F
)
-
>
ForEach
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
(
)
>
Self
:
Sized
{
assert_future
:
:
<
(
)
_
>
(
ForEach
:
:
new
(
self
f
)
)
}
#
[
cfg
(
not
(
futures_no_atomic_cas
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
for_each_concurrent
<
Fut
F
>
(
self
limit
:
impl
Into
<
Option
<
usize
>
>
f
:
F
)
-
>
ForEachConcurrent
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
(
)
>
Self
:
Sized
{
assert_future
:
:
<
(
)
_
>
(
ForEachConcurrent
:
:
new
(
self
limit
.
into
(
)
f
)
)
}
fn
take
(
self
n
:
usize
)
-
>
Take
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Take
:
:
new
(
self
n
)
)
}
fn
skip
(
self
n
:
usize
)
-
>
Skip
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Skip
:
:
new
(
self
n
)
)
}
fn
fuse
(
self
)
-
>
Fuse
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Fuse
:
:
new
(
self
)
)
}
fn
by_ref
(
&
mut
self
)
-
>
&
mut
Self
{
self
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
catch_unwind
(
self
)
-
>
CatchUnwind
<
Self
>
where
Self
:
Sized
+
std
:
:
panic
:
:
UnwindSafe
{
assert_stream
(
CatchUnwind
:
:
new
(
self
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
boxed
<
'
a
>
(
self
)
-
>
BoxStream
<
'
a
Self
:
:
Item
>
where
Self
:
Sized
+
Send
+
'
a
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Box
:
:
pin
(
self
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
boxed_local
<
'
a
>
(
self
)
-
>
LocalBoxStream
<
'
a
Self
:
:
Item
>
where
Self
:
Sized
+
'
a
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Box
:
:
pin
(
self
)
)
}
#
[
cfg
(
not
(
futures_no_atomic_cas
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
buffered
(
self
n
:
usize
)
-
>
Buffered
<
Self
>
where
Self
:
:
Item
:
Future
Self
:
Sized
{
assert_stream
:
:
<
<
Self
:
:
Item
as
Future
>
:
:
Output
_
>
(
Buffered
:
:
new
(
self
n
)
)
}
#
[
cfg
(
not
(
futures_no_atomic_cas
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
buffer_unordered
(
self
n
:
usize
)
-
>
BufferUnordered
<
Self
>
where
Self
:
:
Item
:
Future
Self
:
Sized
{
assert_stream
:
:
<
<
Self
:
:
Item
as
Future
>
:
:
Output
_
>
(
BufferUnordered
:
:
new
(
self
n
)
)
}
fn
zip
<
St
>
(
self
other
:
St
)
-
>
Zip
<
Self
St
>
where
St
:
Stream
Self
:
Sized
{
assert_stream
:
:
<
(
Self
:
:
Item
St
:
:
Item
)
_
>
(
Zip
:
:
new
(
self
other
)
)
}
fn
chain
<
St
>
(
self
other
:
St
)
-
>
Chain
<
Self
St
>
where
St
:
Stream
<
Item
=
Self
:
:
Item
>
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Chain
:
:
new
(
self
other
)
)
}
fn
peekable
(
self
)
-
>
Peekable
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Peekable
:
:
new
(
self
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
chunks
(
self
capacity
:
usize
)
-
>
Chunks
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
Vec
<
Self
:
:
Item
>
_
>
(
Chunks
:
:
new
(
self
capacity
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
ready_chunks
(
self
capacity
:
usize
)
-
>
ReadyChunks
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
Vec
<
Self
:
:
Item
>
_
>
(
ReadyChunks
:
:
new
(
self
capacity
)
)
}
#
[
cfg
(
feature
=
"
sink
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
sink
"
)
)
)
]
fn
forward
<
S
>
(
self
sink
:
S
)
-
>
Forward
<
Self
S
>
where
S
:
Sink
<
Self
:
:
Ok
Error
=
Self
:
:
Error
>
Self
:
TryStream
+
Sized
{
Forward
:
:
new
(
self
sink
)
}
#
[
cfg
(
feature
=
"
sink
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
sink
"
)
)
)
]
#
[
cfg
(
not
(
futures_no_atomic_cas
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
split
<
Item
>
(
self
)
-
>
(
SplitSink
<
Self
Item
>
SplitStream
<
Self
>
)
where
Self
:
Sink
<
Item
>
+
Sized
{
let
(
sink
stream
)
=
split
:
:
split
(
self
)
;
(
crate
:
:
sink
:
:
assert_sink
:
:
<
Item
Self
:
:
Error
_
>
(
sink
)
assert_stream
:
:
<
Self
:
:
Item
_
>
(
stream
)
)
}
fn
inspect
<
F
>
(
self
f
:
F
)
-
>
Inspect
<
Self
F
>
where
F
:
FnMut
(
&
Self
:
:
Item
)
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Inspect
:
:
new
(
self
f
)
)
}
fn
left_stream
<
B
>
(
self
)
-
>
Either
<
Self
B
>
where
B
:
Stream
<
Item
=
Self
:
:
Item
>
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Either
:
:
Left
(
self
)
)
}
fn
right_stream
<
B
>
(
self
)
-
>
Either
<
B
Self
>
where
B
:
Stream
<
Item
=
Self
:
:
Item
>
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Item
_
>
(
Either
:
:
Right
(
self
)
)
}
fn
poll_next_unpin
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
>
where
Self
:
Unpin
{
Pin
:
:
new
(
self
)
.
poll_next
(
cx
)
}
fn
select_next_some
(
&
mut
self
)
-
>
SelectNextSome
<
'
_
Self
>
where
Self
:
Unpin
+
FusedStream
{
assert_future
:
:
<
Self
:
:
Item
_
>
(
SelectNextSome
:
:
new
(
self
)
)
}
}
