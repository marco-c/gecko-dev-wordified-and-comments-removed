use
crate
:
:
future
:
:
Either
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
pin
:
:
Pin
;
#
[
cfg
(
feature
=
"
sink
"
)
]
use
futures_core
:
:
stream
:
:
TryStream
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
futures_core
:
:
stream
:
:
{
BoxStream
LocalBoxStream
}
;
use
futures_core
:
:
{
future
:
:
Future
stream
:
:
{
FusedStream
Stream
}
task
:
:
{
Context
Poll
}
}
;
#
[
cfg
(
feature
=
"
sink
"
)
]
use
futures_sink
:
:
Sink
;
mod
chain
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
chain
:
:
Chain
;
mod
collect
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
collect
:
:
Collect
;
mod
concat
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
concat
:
:
Concat
;
mod
enumerate
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
enumerate
:
:
Enumerate
;
mod
filter
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
filter
:
:
Filter
;
mod
filter_map
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
filter_map
:
:
FilterMap
;
mod
flatten
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
flatten
:
:
Flatten
;
mod
fold
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
fold
:
:
Fold
;
#
[
cfg
(
feature
=
"
sink
"
)
]
mod
forward
;
#
[
cfg
(
feature
=
"
sink
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
forward
:
:
Forward
;
mod
for_each
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
for_each
:
:
ForEach
;
mod
fuse
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
fuse
:
:
Fuse
;
mod
into_future
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
into_future
:
:
StreamFuture
;
mod
inspect
;
pub
(
crate
)
use
self
:
:
inspect
:
:
inspect
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
inspect
:
:
Inspect
;
mod
map
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
map
:
:
Map
;
mod
next
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
next
:
:
Next
;
mod
select_next_some
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
select_next_some
:
:
SelectNextSome
;
mod
peek
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
peek
:
:
{
Peek
Peekable
}
;
mod
skip
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
skip
:
:
Skip
;
mod
skip_while
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
skip_while
:
:
SkipWhile
;
mod
take
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
take
:
:
Take
;
mod
take_while
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
take_while
:
:
TakeWhile
;
mod
then
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
then
:
:
Then
;
mod
zip
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
zip
:
:
Zip
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
chunks
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
chunks
:
:
Chunks
;
mod
scan
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
scan
:
:
Scan
;
cfg_target_has_atomic
!
{
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
buffer_unordered
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
57411
pub
use
self
:
:
buffer_unordered
:
:
BufferUnordered
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
buffered
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
57411
pub
use
self
:
:
buffered
:
:
Buffered
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
for_each_concurrent
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
57411
pub
use
self
:
:
for_each_concurrent
:
:
ForEachConcurrent
;
#
[
cfg
(
feature
=
"
sink
"
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
split
;
#
[
cfg
(
feature
=
"
sink
"
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
unreachable_pub
)
]
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
57411
pub
use
self
:
:
split
:
:
{
SplitStream
SplitSink
ReuniteError
}
;
}
#
[
cfg
(
feature
=
"
std
"
)
]
mod
catch_unwind
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
catch_unwind
:
:
CatchUnwind
;
impl
<
T
:
?
Sized
>
StreamExt
for
T
where
T
:
Stream
{
}
pub
trait
StreamExt
:
Stream
{
fn
next
(
&
mut
self
)
-
>
Next
<
'
_
Self
>
where
Self
:
Unpin
{
Next
:
:
new
(
self
)
}
fn
into_future
(
self
)
-
>
StreamFuture
<
Self
>
where
Self
:
Sized
+
Unpin
{
StreamFuture
:
:
new
(
self
)
}
fn
map
<
T
F
>
(
self
f
:
F
)
-
>
Map
<
Self
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
T
Self
:
Sized
{
Map
:
:
new
(
self
f
)
}
fn
enumerate
(
self
)
-
>
Enumerate
<
Self
>
where
Self
:
Sized
{
Enumerate
:
:
new
(
self
)
}
fn
filter
<
Fut
F
>
(
self
f
:
F
)
-
>
Filter
<
Self
Fut
F
>
where
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
bool
>
Self
:
Sized
{
Filter
:
:
new
(
self
f
)
}
fn
filter_map
<
Fut
T
F
>
(
self
f
:
F
)
-
>
FilterMap
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
Option
<
T
>
>
Self
:
Sized
{
FilterMap
:
:
new
(
self
f
)
}
fn
then
<
Fut
F
>
(
self
f
:
F
)
-
>
Then
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
Self
:
Sized
{
Then
:
:
new
(
self
f
)
}
fn
collect
<
C
:
Default
+
Extend
<
Self
:
:
Item
>
>
(
self
)
-
>
Collect
<
Self
C
>
where
Self
:
Sized
{
Collect
:
:
new
(
self
)
}
fn
concat
(
self
)
-
>
Concat
<
Self
>
where
Self
:
Sized
Self
:
:
Item
:
Extend
<
<
<
Self
as
Stream
>
:
:
Item
as
IntoIterator
>
:
:
Item
>
+
IntoIterator
+
Default
{
Concat
:
:
new
(
self
)
}
fn
fold
<
T
Fut
F
>
(
self
init
:
T
f
:
F
)
-
>
Fold
<
Self
Fut
T
F
>
where
F
:
FnMut
(
T
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
T
>
Self
:
Sized
{
Fold
:
:
new
(
self
f
init
)
}
fn
flatten
(
self
)
-
>
Flatten
<
Self
>
where
Self
:
:
Item
:
Stream
Self
:
Sized
{
Flatten
:
:
new
(
self
)
}
fn
scan
<
S
B
Fut
F
>
(
self
initial_state
:
S
f
:
F
)
-
>
Scan
<
Self
S
Fut
F
>
where
F
:
FnMut
(
&
mut
S
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
Option
<
B
>
>
Self
:
Sized
{
Scan
:
:
new
(
self
initial_state
f
)
}
fn
skip_while
<
Fut
F
>
(
self
f
:
F
)
-
>
SkipWhile
<
Self
Fut
F
>
where
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
bool
>
Self
:
Sized
{
SkipWhile
:
:
new
(
self
f
)
}
fn
take_while
<
Fut
F
>
(
self
f
:
F
)
-
>
TakeWhile
<
Self
Fut
F
>
where
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
bool
>
Self
:
Sized
{
TakeWhile
:
:
new
(
self
f
)
}
fn
for_each
<
Fut
F
>
(
self
f
:
F
)
-
>
ForEach
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
(
)
>
Self
:
Sized
{
ForEach
:
:
new
(
self
f
)
}
#
[
cfg_attr
(
feature
=
"
cfg
-
target
-
has
-
atomic
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
for_each_concurrent
<
Fut
F
>
(
self
limit
:
impl
Into
<
Option
<
usize
>
>
f
:
F
)
-
>
ForEachConcurrent
<
Self
Fut
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
Fut
Fut
:
Future
<
Output
=
(
)
>
Self
:
Sized
{
ForEachConcurrent
:
:
new
(
self
limit
.
into
(
)
f
)
}
fn
take
(
self
n
:
usize
)
-
>
Take
<
Self
>
where
Self
:
Sized
{
Take
:
:
new
(
self
n
)
}
fn
skip
(
self
n
:
usize
)
-
>
Skip
<
Self
>
where
Self
:
Sized
{
Skip
:
:
new
(
self
n
)
}
fn
fuse
(
self
)
-
>
Fuse
<
Self
>
where
Self
:
Sized
{
Fuse
:
:
new
(
self
)
}
fn
by_ref
(
&
mut
self
)
-
>
&
mut
Self
{
self
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
catch_unwind
(
self
)
-
>
CatchUnwind
<
Self
>
where
Self
:
Sized
+
std
:
:
panic
:
:
UnwindSafe
{
CatchUnwind
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
boxed
<
'
a
>
(
self
)
-
>
BoxStream
<
'
a
Self
:
:
Item
>
where
Self
:
Sized
+
Send
+
'
a
{
Box
:
:
pin
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
boxed_local
<
'
a
>
(
self
)
-
>
LocalBoxStream
<
'
a
Self
:
:
Item
>
where
Self
:
Sized
+
'
a
{
Box
:
:
pin
(
self
)
}
#
[
cfg_attr
(
feature
=
"
cfg
-
target
-
has
-
atomic
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
buffered
(
self
n
:
usize
)
-
>
Buffered
<
Self
>
where
Self
:
:
Item
:
Future
Self
:
Sized
{
Buffered
:
:
new
(
self
n
)
}
#
[
cfg_attr
(
feature
=
"
cfg
-
target
-
has
-
atomic
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
buffer_unordered
(
self
n
:
usize
)
-
>
BufferUnordered
<
Self
>
where
Self
:
:
Item
:
Future
Self
:
Sized
{
BufferUnordered
:
:
new
(
self
n
)
}
fn
zip
<
St
>
(
self
other
:
St
)
-
>
Zip
<
Self
St
>
where
St
:
Stream
Self
:
Sized
{
Zip
:
:
new
(
self
other
)
}
fn
chain
<
St
>
(
self
other
:
St
)
-
>
Chain
<
Self
St
>
where
St
:
Stream
<
Item
=
Self
:
:
Item
>
Self
:
Sized
{
Chain
:
:
new
(
self
other
)
}
fn
peekable
(
self
)
-
>
Peekable
<
Self
>
where
Self
:
Sized
{
Peekable
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
chunks
(
self
capacity
:
usize
)
-
>
Chunks
<
Self
>
where
Self
:
Sized
{
Chunks
:
:
new
(
self
capacity
)
}
#
[
cfg
(
feature
=
"
sink
"
)
]
fn
forward
<
S
>
(
self
sink
:
S
)
-
>
Forward
<
Self
S
>
where
S
:
Sink
<
<
Self
as
TryStream
>
:
:
Ok
>
Self
:
TryStream
<
Error
=
S
:
:
Error
>
+
Sized
{
Forward
:
:
new
(
self
sink
)
}
#
[
cfg
(
feature
=
"
sink
"
)
]
#
[
cfg_attr
(
feature
=
"
cfg
-
target
-
has
-
atomic
"
cfg
(
target_has_atomic
=
"
ptr
"
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
split
<
Item
>
(
self
)
-
>
(
SplitSink
<
Self
Item
>
SplitStream
<
Self
>
)
where
Self
:
Sink
<
Item
>
+
Sized
{
split
:
:
split
(
self
)
}
fn
inspect
<
F
>
(
self
f
:
F
)
-
>
Inspect
<
Self
F
>
where
F
:
FnMut
(
&
Self
:
:
Item
)
Self
:
Sized
{
Inspect
:
:
new
(
self
f
)
}
fn
left_stream
<
B
>
(
self
)
-
>
Either
<
Self
B
>
where
B
:
Stream
<
Item
=
Self
:
:
Item
>
Self
:
Sized
{
Either
:
:
Left
(
self
)
}
fn
right_stream
<
B
>
(
self
)
-
>
Either
<
B
Self
>
where
B
:
Stream
<
Item
=
Self
:
:
Item
>
Self
:
Sized
{
Either
:
:
Right
(
self
)
}
fn
poll_next_unpin
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
>
where
Self
:
Unpin
{
Pin
:
:
new
(
self
)
.
poll_next
(
cx
)
}
fn
select_next_some
(
&
mut
self
)
-
>
SelectNextSome
<
'
_
Self
>
where
Self
:
Unpin
+
FusedStream
{
SelectNextSome
:
:
new
(
self
)
}
}
