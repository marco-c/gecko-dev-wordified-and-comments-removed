use
alloc
:
:
sync
:
:
Arc
;
use
core
:
:
{
cell
:
:
UnsafeCell
convert
:
:
identity
fmt
marker
:
:
PhantomData
num
:
:
NonZeroUsize
pin
:
:
Pin
sync
:
:
atomic
:
:
{
AtomicU8
Ordering
}
}
;
use
pin_project_lite
:
:
pin_project
;
use
futures_core
:
:
{
future
:
:
Future
ready
stream
:
:
{
FusedStream
Stream
}
task
:
:
{
Context
Poll
Waker
}
}
;
#
[
cfg
(
feature
=
"
sink
"
)
]
use
futures_sink
:
:
Sink
;
use
futures_task
:
:
{
waker
ArcWake
}
;
use
crate
:
:
stream
:
:
FuturesUnordered
;
pub
type
FlattenUnordered
<
St
>
=
FlattenUnorderedWithFlowController
<
St
(
)
>
;
const
NONE
:
u8
=
0
;
const
NEED_TO_POLL_INNER_STREAMS
:
u8
=
1
;
const
NEED_TO_POLL_STREAM
:
u8
=
0b10
;
const
NEED_TO_POLL_ALL
:
u8
=
NEED_TO_POLL_INNER_STREAMS
|
NEED_TO_POLL_STREAM
;
const
POLLING
:
u8
=
0b100
;
const
WAKING
:
u8
=
0b1000
;
const
WOKEN
:
u8
=
0b10000
;
#
[
derive
(
Clone
Debug
)
]
struct
SharedPollState
{
state
:
Arc
<
AtomicU8
>
}
impl
SharedPollState
{
fn
new
(
value
:
u8
)
-
>
Self
{
Self
{
state
:
Arc
:
:
new
(
AtomicU8
:
:
new
(
value
)
)
}
}
fn
start_polling
(
&
self
)
-
>
Option
<
(
u8
PollStateBomb
<
'
_
impl
FnOnce
(
&
Self
)
-
>
u8
>
)
>
{
let
value
=
self
.
state
.
fetch_update
(
Ordering
:
:
SeqCst
Ordering
:
:
SeqCst
|
value
|
{
if
value
&
WAKING
=
=
NONE
{
Some
(
POLLING
)
}
else
{
None
}
}
)
.
ok
(
)
?
;
let
bomb
=
PollStateBomb
:
:
new
(
self
Self
:
:
reset
)
;
Some
(
(
value
bomb
)
)
}
fn
start_waking
(
&
self
to_poll
:
u8
)
-
>
Option
<
(
u8
PollStateBomb
<
'
_
impl
FnOnce
(
&
Self
)
-
>
u8
>
)
>
{
let
value
=
self
.
state
.
fetch_update
(
Ordering
:
:
SeqCst
Ordering
:
:
SeqCst
|
value
|
{
let
mut
next_value
=
value
|
to_poll
;
if
value
&
(
WOKEN
|
POLLING
)
=
=
NONE
{
next_value
|
=
WAKING
;
}
if
next_value
!
=
value
{
Some
(
next_value
)
}
else
{
None
}
}
)
.
ok
(
)
?
;
if
value
&
(
WOKEN
|
POLLING
|
WAKING
)
=
=
NONE
{
let
bomb
=
PollStateBomb
:
:
new
(
self
Self
:
:
stop_waking
)
;
Some
(
(
value
bomb
)
)
}
else
{
None
}
}
fn
stop_polling
(
&
self
to_poll
:
u8
will_be_woken
:
bool
)
-
>
u8
{
self
.
state
.
fetch_update
(
Ordering
:
:
SeqCst
Ordering
:
:
SeqCst
|
mut
value
|
{
let
mut
next_value
=
to_poll
;
value
&
=
NEED_TO_POLL_ALL
;
if
value
!
=
NONE
|
|
will_be_woken
{
next_value
|
=
WOKEN
;
}
next_value
|
=
value
;
Some
(
next_value
&
!
POLLING
&
!
WAKING
)
}
)
.
unwrap
(
)
}
fn
stop_waking
(
&
self
)
-
>
u8
{
let
value
=
self
.
state
.
fetch_update
(
Ordering
:
:
SeqCst
Ordering
:
:
SeqCst
|
value
|
{
let
next_value
=
value
&
!
WAKING
|
WOKEN
;
if
next_value
!
=
value
{
Some
(
next_value
)
}
else
{
None
}
}
)
.
unwrap_or_else
(
identity
)
;
debug_assert
!
(
value
&
(
WOKEN
|
POLLING
|
WAKING
)
=
=
WAKING
)
;
value
}
fn
reset
(
&
self
)
-
>
u8
{
self
.
state
.
swap
(
NEED_TO_POLL_ALL
Ordering
:
:
SeqCst
)
}
}
struct
PollStateBomb
<
'
a
F
:
FnOnce
(
&
SharedPollState
)
-
>
u8
>
{
state
:
&
'
a
SharedPollState
drop
:
Option
<
F
>
}
impl
<
'
a
F
:
FnOnce
(
&
SharedPollState
)
-
>
u8
>
PollStateBomb
<
'
a
F
>
{
fn
new
(
state
:
&
'
a
SharedPollState
drop
:
F
)
-
>
Self
{
Self
{
state
drop
:
Some
(
drop
)
}
}
fn
deactivate
(
mut
self
)
{
self
.
drop
.
take
(
)
;
}
}
impl
<
F
:
FnOnce
(
&
SharedPollState
)
-
>
u8
>
Drop
for
PollStateBomb
<
'
_
F
>
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
drop
)
=
self
.
drop
.
take
(
)
{
(
drop
)
(
self
.
state
)
;
}
}
}
struct
WrappedWaker
{
inner_waker
:
UnsafeCell
<
Option
<
Waker
>
>
poll_state
:
SharedPollState
need_to_poll
:
u8
}
unsafe
impl
Send
for
WrappedWaker
{
}
unsafe
impl
Sync
for
WrappedWaker
{
}
impl
WrappedWaker
{
unsafe
fn
replace_waker
(
self_arc
:
&
mut
Arc
<
Self
>
cx
:
&
Context
<
'
_
>
)
{
unsafe
{
*
self_arc
.
inner_waker
.
get
(
)
=
cx
.
waker
(
)
.
clone
(
)
.
into
(
)
}
}
fn
start_waking
(
&
self
)
-
>
Option
<
(
u8
PollStateBomb
<
'
_
impl
FnOnce
(
&
SharedPollState
)
-
>
u8
>
)
>
{
self
.
poll_state
.
start_waking
(
self
.
need_to_poll
)
}
}
impl
ArcWake
for
WrappedWaker
{
fn
wake_by_ref
(
self_arc
:
&
Arc
<
Self
>
)
{
if
let
Some
(
(
_
state_bomb
)
)
=
self_arc
.
start_waking
(
)
{
let
waker_opt
=
unsafe
{
self_arc
.
inner_waker
.
get
(
)
.
as_ref
(
)
.
unwrap
(
)
}
;
if
let
Some
(
inner_waker
)
=
waker_opt
.
clone
(
)
{
drop
(
state_bomb
)
;
inner_waker
.
wake
(
)
;
}
}
}
}
pin_project
!
{
/
/
/
Future
which
polls
optional
inner
stream
.
/
/
/
/
/
/
If
it
'
s
Some
it
will
attempt
to
call
poll_next
on
it
/
/
/
returning
Some
(
(
item
next_item_fut
)
)
in
case
of
Poll
:
:
Ready
(
Some
(
.
.
.
)
)
#
[
must_use
=
"
futures
do
nothing
unless
you
.
await
or
poll
them
"
]
struct
PollStreamFut
<
St
>
{
#
[
pin
]
stream
:
Option
<
St
>
}
}
impl
<
St
>
PollStreamFut
<
St
>
{
fn
new
(
stream
:
impl
Into
<
Option
<
St
>
>
)
-
>
Self
{
Self
{
stream
:
stream
.
into
(
)
}
}
}
impl
<
St
:
Stream
+
Unpin
>
Future
for
PollStreamFut
<
St
>
{
type
Output
=
Option
<
(
St
:
:
Item
Self
)
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
mut
stream
=
self
.
project
(
)
.
stream
;
let
item
=
if
let
Some
(
stream
)
=
stream
.
as_mut
(
)
.
as_pin_mut
(
)
{
ready
!
(
stream
.
poll_next
(
cx
)
)
}
else
{
None
}
;
let
next_item_fut
=
Self
:
:
new
(
stream
.
get_mut
(
)
.
take
(
)
)
;
let
out
=
item
.
map
(
|
item
|
(
item
next_item_fut
)
)
;
Poll
:
:
Ready
(
out
)
}
}
pin_project
!
{
/
/
/
Stream
for
the
[
flatten_unordered
]
(
super
:
:
StreamExt
:
:
flatten_unordered
)
/
/
/
method
with
ability
to
specify
flow
controller
.
#
[
project
=
FlattenUnorderedWithFlowControllerProj
]
#
[
must_use
=
"
streams
do
nothing
unless
polled
"
]
pub
struct
FlattenUnorderedWithFlowController
<
St
Fc
>
where
St
:
Stream
{
#
[
pin
]
inner_streams
:
FuturesUnordered
<
PollStreamFut
<
St
:
:
Item
>
>
#
[
pin
]
stream
:
St
poll_state
:
SharedPollState
limit
:
Option
<
NonZeroUsize
>
is_stream_done
:
bool
inner_streams_waker
:
Arc
<
WrappedWaker
>
stream_waker
:
Arc
<
WrappedWaker
>
flow_controller
:
PhantomData
<
Fc
>
}
}
impl
<
St
Fc
>
fmt
:
:
Debug
for
FlattenUnorderedWithFlowController
<
St
Fc
>
where
St
:
Stream
+
fmt
:
:
Debug
St
:
:
Item
:
Stream
+
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
FlattenUnorderedWithFlowController
"
)
.
field
(
"
poll_state
"
&
self
.
poll_state
)
.
field
(
"
inner_streams
"
&
self
.
inner_streams
)
.
field
(
"
limit
"
&
self
.
limit
)
.
field
(
"
stream
"
&
self
.
stream
)
.
field
(
"
is_stream_done
"
&
self
.
is_stream_done
)
.
field
(
"
flow_controller
"
&
self
.
flow_controller
)
.
finish
(
)
}
}
impl
<
St
Fc
>
FlattenUnorderedWithFlowController
<
St
Fc
>
where
St
:
Stream
Fc
:
FlowController
<
St
:
:
Item
<
St
:
:
Item
as
Stream
>
:
:
Item
>
St
:
:
Item
:
Stream
+
Unpin
{
pub
(
crate
)
fn
new
(
stream
:
St
limit
:
Option
<
usize
>
)
-
>
Self
{
let
poll_state
=
SharedPollState
:
:
new
(
NEED_TO_POLL_STREAM
)
;
Self
{
inner_streams
:
FuturesUnordered
:
:
new
(
)
stream
is_stream_done
:
false
limit
:
limit
.
and_then
(
NonZeroUsize
:
:
new
)
inner_streams_waker
:
Arc
:
:
new
(
WrappedWaker
{
inner_waker
:
UnsafeCell
:
:
new
(
None
)
poll_state
:
poll_state
.
clone
(
)
need_to_poll
:
NEED_TO_POLL_INNER_STREAMS
}
)
stream_waker
:
Arc
:
:
new
(
WrappedWaker
{
inner_waker
:
UnsafeCell
:
:
new
(
None
)
poll_state
:
poll_state
.
clone
(
)
need_to_poll
:
NEED_TO_POLL_STREAM
}
)
poll_state
flow_controller
:
PhantomData
}
}
delegate_access_inner
!
(
stream
St
(
)
)
;
}
pub
trait
FlowController
<
I
O
>
{
fn
next_step
(
item
:
I
)
-
>
FlowStep
<
I
O
>
;
}
impl
<
I
O
>
FlowController
<
I
O
>
for
(
)
{
fn
next_step
(
item
:
I
)
-
>
FlowStep
<
I
O
>
{
FlowStep
:
:
Continue
(
item
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
FlowStep
<
C
R
>
{
Continue
(
C
)
Return
(
R
)
}
impl
<
St
Fc
>
FlattenUnorderedWithFlowControllerProj
<
'
_
St
Fc
>
where
St
:
Stream
{
fn
is_exceeded_limit
(
&
self
)
-
>
bool
{
self
.
limit
.
map_or
(
false
|
limit
|
self
.
inner_streams
.
len
(
)
>
=
limit
.
get
(
)
)
}
}
impl
<
St
Fc
>
FusedStream
for
FlattenUnorderedWithFlowController
<
St
Fc
>
where
St
:
FusedStream
Fc
:
FlowController
<
St
:
:
Item
<
St
:
:
Item
as
Stream
>
:
:
Item
>
St
:
:
Item
:
Stream
+
Unpin
{
fn
is_terminated
(
&
self
)
-
>
bool
{
self
.
stream
.
is_terminated
(
)
&
&
self
.
inner_streams
.
is_empty
(
)
}
}
impl
<
St
Fc
>
Stream
for
FlattenUnorderedWithFlowController
<
St
Fc
>
where
St
:
Stream
Fc
:
FlowController
<
St
:
:
Item
<
St
:
:
Item
as
Stream
>
:
:
Item
>
St
:
:
Item
:
Stream
+
Unpin
{
type
Item
=
<
St
:
:
Item
as
Stream
>
:
:
Item
;
fn
poll_next
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
>
{
let
mut
next_item
=
None
;
let
mut
need_to_poll_next
=
NONE
;
let
mut
this
=
self
.
as_mut
(
)
.
project
(
)
;
let
(
mut
poll_state_value
state_bomb
)
=
loop
{
if
let
Some
(
value
)
=
this
.
poll_state
.
start_polling
(
)
{
break
value
;
}
}
;
unsafe
{
WrappedWaker
:
:
replace_waker
(
this
.
stream_waker
cx
)
;
WrappedWaker
:
:
replace_waker
(
this
.
inner_streams_waker
cx
)
}
;
if
poll_state_value
&
NEED_TO_POLL_STREAM
!
=
NONE
{
let
mut
stream_waker
=
None
;
loop
{
if
this
.
is_exceeded_limit
(
)
|
|
*
this
.
is_stream_done
{
if
!
*
this
.
is_stream_done
{
need_to_poll_next
|
=
NEED_TO_POLL_STREAM
;
}
break
;
}
else
{
let
mut
cx
=
Context
:
:
from_waker
(
stream_waker
.
get_or_insert_with
(
|
|
waker
(
this
.
stream_waker
.
clone
(
)
)
)
)
;
match
this
.
stream
.
as_mut
(
)
.
poll_next
(
&
mut
cx
)
{
Poll
:
:
Ready
(
Some
(
item
)
)
=
>
{
let
next_item_fut
=
match
Fc
:
:
next_step
(
item
)
{
FlowStep
:
:
Return
(
item
)
=
>
{
need_to_poll_next
|
=
NEED_TO_POLL_STREAM
|
(
poll_state_value
&
NEED_TO_POLL_INNER_STREAMS
)
;
poll_state_value
&
=
!
NEED_TO_POLL_INNER_STREAMS
;
next_item
=
Some
(
item
)
;
break
;
}
FlowStep
:
:
Continue
(
inner_stream
)
=
>
{
PollStreamFut
:
:
new
(
inner_stream
)
}
}
;
this
.
inner_streams
.
as_mut
(
)
.
push
(
next_item_fut
)
;
poll_state_value
|
=
NEED_TO_POLL_INNER_STREAMS
;
}
Poll
:
:
Ready
(
None
)
=
>
{
*
this
.
is_stream_done
=
true
;
}
Poll
:
:
Pending
=
>
{
break
;
}
}
}
}
}
if
poll_state_value
&
NEED_TO_POLL_INNER_STREAMS
!
=
NONE
{
let
inner_streams_waker
=
waker
(
this
.
inner_streams_waker
.
clone
(
)
)
;
let
mut
cx
=
Context
:
:
from_waker
(
&
inner_streams_waker
)
;
match
this
.
inner_streams
.
as_mut
(
)
.
poll_next
(
&
mut
cx
)
{
Poll
:
:
Ready
(
Some
(
Some
(
(
item
next_item_fut
)
)
)
)
=
>
{
this
.
inner_streams
.
as_mut
(
)
.
push
(
next_item_fut
)
;
next_item
=
Some
(
item
)
;
need_to_poll_next
|
=
NEED_TO_POLL_INNER_STREAMS
;
}
Poll
:
:
Ready
(
Some
(
None
)
)
=
>
{
need_to_poll_next
|
=
NEED_TO_POLL_INNER_STREAMS
;
}
_
=
>
{
}
}
}
state_bomb
.
deactivate
(
)
;
let
mut
force_wake
=
need_to_poll_next
&
NEED_TO_POLL_STREAM
!
=
NONE
&
&
!
this
.
is_exceeded_limit
(
)
|
|
need_to_poll_next
&
NEED_TO_POLL_INNER_STREAMS
!
=
NONE
;
poll_state_value
=
this
.
poll_state
.
stop_polling
(
need_to_poll_next
force_wake
)
;
force_wake
|
=
poll_state_value
&
NEED_TO_POLL_ALL
!
=
NONE
;
let
is_done
=
*
this
.
is_stream_done
&
&
this
.
inner_streams
.
is_empty
(
)
;
if
next_item
.
is_some
(
)
|
|
is_done
{
Poll
:
:
Ready
(
next_item
)
}
else
{
if
force_wake
{
cx
.
waker
(
)
.
wake_by_ref
(
)
;
}
Poll
:
:
Pending
}
}
}
#
[
cfg
(
feature
=
"
sink
"
)
]
impl
<
St
Item
Fc
>
Sink
<
Item
>
for
FlattenUnorderedWithFlowController
<
St
Fc
>
where
St
:
Stream
+
Sink
<
Item
>
{
type
Error
=
St
:
:
Error
;
delegate_sink
!
(
stream
Item
)
;
}
