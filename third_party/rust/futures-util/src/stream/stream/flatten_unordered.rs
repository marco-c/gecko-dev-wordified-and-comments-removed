use
alloc
:
:
sync
:
:
Arc
;
use
core
:
:
{
cell
:
:
UnsafeCell
convert
:
:
identity
fmt
num
:
:
NonZeroUsize
pin
:
:
Pin
sync
:
:
atomic
:
:
{
AtomicU8
Ordering
}
}
;
use
pin_project_lite
:
:
pin_project
;
use
futures_core
:
:
{
future
:
:
Future
ready
stream
:
:
{
FusedStream
Stream
}
task
:
:
{
Context
Poll
Waker
}
}
;
#
[
cfg
(
feature
=
"
sink
"
)
]
use
futures_sink
:
:
Sink
;
use
futures_task
:
:
{
waker
ArcWake
}
;
use
crate
:
:
stream
:
:
FuturesUnordered
;
const
NONE
:
u8
=
0
;
const
NEED_TO_POLL_INNER_STREAMS
:
u8
=
1
;
const
NEED_TO_POLL_STREAM
:
u8
=
0b10
;
const
NEED_TO_POLL_ALL
:
u8
=
NEED_TO_POLL_INNER_STREAMS
|
NEED_TO_POLL_STREAM
;
const
POLLING
:
u8
=
0b100
;
const
WAKING_INNER_STREAMS
:
u8
=
0b1000
;
const
WAKING_STREAM
:
u8
=
0b10000
;
const
WAKING_ALL
:
u8
=
WAKING_STREAM
|
WAKING_INNER_STREAMS
;
const
WOKEN
:
u8
=
0b100000
;
#
[
derive
(
Clone
Debug
)
]
struct
SharedPollState
{
state
:
Arc
<
AtomicU8
>
}
impl
SharedPollState
{
fn
new
(
value
:
u8
)
-
>
SharedPollState
{
SharedPollState
{
state
:
Arc
:
:
new
(
AtomicU8
:
:
new
(
value
)
)
}
}
fn
start_polling
(
&
self
)
-
>
Option
<
(
u8
PollStateBomb
<
'
_
impl
FnOnce
(
&
SharedPollState
)
-
>
u8
>
)
>
{
let
value
=
self
.
state
.
fetch_update
(
Ordering
:
:
SeqCst
Ordering
:
:
SeqCst
|
value
|
{
if
value
&
WAKING_ALL
=
=
NONE
{
Some
(
POLLING
)
}
else
{
None
}
}
)
.
ok
(
)
?
;
let
bomb
=
PollStateBomb
:
:
new
(
self
SharedPollState
:
:
reset
)
;
Some
(
(
value
bomb
)
)
}
fn
start_waking
(
&
self
to_poll
:
u8
waking
:
u8
)
-
>
Option
<
(
u8
PollStateBomb
<
'
_
impl
FnOnce
(
&
SharedPollState
)
-
>
u8
>
)
>
{
let
value
=
self
.
state
.
fetch_update
(
Ordering
:
:
SeqCst
Ordering
:
:
SeqCst
|
value
|
{
if
value
&
waking
!
=
NONE
{
return
None
;
}
let
mut
next_value
=
value
|
to_poll
;
if
value
&
(
WOKEN
|
POLLING
)
=
=
NONE
{
next_value
|
=
waking
;
}
if
next_value
!
=
value
{
Some
(
next_value
)
}
else
{
None
}
}
)
.
ok
(
)
?
;
if
value
&
(
WOKEN
|
POLLING
)
=
=
NONE
{
let
bomb
=
PollStateBomb
:
:
new
(
self
move
|
state
|
state
.
stop_waking
(
waking
)
)
;
Some
(
(
value
bomb
)
)
}
else
{
None
}
}
fn
stop_polling
(
&
self
to_poll
:
u8
will_be_woken
:
bool
)
-
>
u8
{
self
.
state
.
fetch_update
(
Ordering
:
:
SeqCst
Ordering
:
:
SeqCst
|
mut
value
|
{
let
mut
next_value
=
to_poll
;
value
&
=
NEED_TO_POLL_ALL
;
if
value
!
=
NONE
|
|
will_be_woken
{
next_value
|
=
WOKEN
;
}
next_value
|
=
value
;
Some
(
next_value
&
!
POLLING
&
!
WAKING_ALL
)
}
)
.
unwrap
(
)
}
fn
stop_waking
(
&
self
waking
:
u8
)
-
>
u8
{
self
.
state
.
fetch_update
(
Ordering
:
:
SeqCst
Ordering
:
:
SeqCst
|
value
|
{
let
mut
next_value
=
value
&
!
waking
;
if
value
&
WAKING_ALL
=
=
waking
{
next_value
|
=
WOKEN
;
}
if
next_value
!
=
value
{
Some
(
next_value
)
}
else
{
None
}
}
)
.
unwrap_or_else
(
identity
)
}
fn
reset
(
&
self
)
-
>
u8
{
self
.
state
.
swap
(
NEED_TO_POLL_ALL
Ordering
:
:
AcqRel
)
}
}
struct
PollStateBomb
<
'
a
F
:
FnOnce
(
&
SharedPollState
)
-
>
u8
>
{
state
:
&
'
a
SharedPollState
drop
:
Option
<
F
>
}
impl
<
'
a
F
:
FnOnce
(
&
SharedPollState
)
-
>
u8
>
PollStateBomb
<
'
a
F
>
{
fn
new
(
state
:
&
'
a
SharedPollState
drop
:
F
)
-
>
Self
{
Self
{
state
drop
:
Some
(
drop
)
}
}
fn
deactivate
(
mut
self
)
{
self
.
drop
.
take
(
)
;
}
fn
fire
(
mut
self
)
-
>
Option
<
u8
>
{
self
.
drop
.
take
(
)
.
map
(
|
drop
|
(
drop
)
(
self
.
state
)
)
}
}
impl
<
F
:
FnOnce
(
&
SharedPollState
)
-
>
u8
>
Drop
for
PollStateBomb
<
'
_
F
>
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
drop
)
=
self
.
drop
.
take
(
)
{
(
drop
)
(
self
.
state
)
;
}
}
}
struct
InnerWaker
{
inner_waker
:
UnsafeCell
<
Option
<
Waker
>
>
poll_state
:
SharedPollState
need_to_poll
:
u8
}
unsafe
impl
Send
for
InnerWaker
{
}
unsafe
impl
Sync
for
InnerWaker
{
}
impl
InnerWaker
{
unsafe
fn
replace_waker
(
self_arc
:
&
mut
Arc
<
Self
>
cx
:
&
Context
<
'
_
>
)
-
>
Waker
{
*
self_arc
.
inner_waker
.
get
(
)
=
cx
.
waker
(
)
.
clone
(
)
.
into
(
)
;
waker
(
self_arc
.
clone
(
)
)
}
fn
start_waking
(
&
self
)
-
>
Option
<
(
u8
PollStateBomb
<
'
_
impl
FnOnce
(
&
SharedPollState
)
-
>
u8
>
)
>
{
self
.
poll_state
.
start_waking
(
self
.
need_to_poll
self
.
waking_state
(
)
)
}
fn
waking_state
(
&
self
)
-
>
u8
{
self
.
need_to_poll
<
<
3
}
}
impl
ArcWake
for
InnerWaker
{
fn
wake_by_ref
(
self_arc
:
&
Arc
<
Self
>
)
{
if
let
Some
(
(
_
state_bomb
)
)
=
self_arc
.
start_waking
(
)
{
let
waker_opt
=
unsafe
{
self_arc
.
inner_waker
.
get
(
)
.
as_ref
(
)
.
unwrap
(
)
}
;
if
let
Some
(
inner_waker
)
=
waker_opt
.
clone
(
)
{
let
poll_state_value
=
state_bomb
.
fire
(
)
.
unwrap
(
)
;
if
poll_state_value
&
(
WOKEN
|
WAKING_ALL
)
=
=
self_arc
.
waking_state
(
)
{
inner_waker
.
wake
(
)
;
}
}
}
}
}
pin_project
!
{
/
/
/
Future
which
contains
optional
stream
.
/
/
/
/
/
/
If
it
'
s
Some
it
will
attempt
to
call
poll_next
on
it
/
/
/
returning
Some
(
(
item
next_item_fut
)
)
in
case
of
Poll
:
:
Ready
(
Some
(
.
.
.
)
)
#
[
must_use
=
"
futures
do
nothing
unless
you
.
await
or
poll
them
"
]
struct
PollStreamFut
<
St
>
{
#
[
pin
]
stream
:
Option
<
St
>
}
}
impl
<
St
>
PollStreamFut
<
St
>
{
fn
new
(
stream
:
impl
Into
<
Option
<
St
>
>
)
-
>
Self
{
Self
{
stream
:
stream
.
into
(
)
}
}
}
impl
<
St
:
Stream
+
Unpin
>
Future
for
PollStreamFut
<
St
>
{
type
Output
=
Option
<
(
St
:
:
Item
PollStreamFut
<
St
>
)
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
mut
stream
=
self
.
project
(
)
.
stream
;
let
item
=
if
let
Some
(
stream
)
=
stream
.
as_mut
(
)
.
as_pin_mut
(
)
{
ready
!
(
stream
.
poll_next
(
cx
)
)
}
else
{
None
}
;
let
next_item_fut
=
PollStreamFut
:
:
new
(
stream
.
get_mut
(
)
.
take
(
)
)
;
let
out
=
item
.
map
(
|
item
|
(
item
next_item_fut
)
)
;
Poll
:
:
Ready
(
out
)
}
}
pin_project
!
{
/
/
/
Stream
for
the
[
flatten_unordered
]
(
super
:
:
StreamExt
:
:
flatten_unordered
)
/
/
/
method
.
#
[
project
=
FlattenUnorderedProj
]
#
[
must_use
=
"
streams
do
nothing
unless
polled
"
]
pub
struct
FlattenUnordered
<
St
>
where
St
:
Stream
{
#
[
pin
]
inner_streams
:
FuturesUnordered
<
PollStreamFut
<
St
:
:
Item
>
>
#
[
pin
]
stream
:
St
poll_state
:
SharedPollState
limit
:
Option
<
NonZeroUsize
>
is_stream_done
:
bool
inner_streams_waker
:
Arc
<
InnerWaker
>
stream_waker
:
Arc
<
InnerWaker
>
}
}
impl
<
St
>
fmt
:
:
Debug
for
FlattenUnordered
<
St
>
where
St
:
Stream
+
fmt
:
:
Debug
St
:
:
Item
:
Stream
+
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
FlattenUnordered
"
)
.
field
(
"
poll_state
"
&
self
.
poll_state
)
.
field
(
"
inner_streams
"
&
self
.
inner_streams
)
.
field
(
"
limit
"
&
self
.
limit
)
.
field
(
"
stream
"
&
self
.
stream
)
.
field
(
"
is_stream_done
"
&
self
.
is_stream_done
)
.
finish
(
)
}
}
impl
<
St
>
FlattenUnordered
<
St
>
where
St
:
Stream
St
:
:
Item
:
Stream
+
Unpin
{
pub
(
super
)
fn
new
(
stream
:
St
limit
:
Option
<
usize
>
)
-
>
FlattenUnordered
<
St
>
{
let
poll_state
=
SharedPollState
:
:
new
(
NEED_TO_POLL_STREAM
)
;
FlattenUnordered
{
inner_streams
:
FuturesUnordered
:
:
new
(
)
stream
is_stream_done
:
false
limit
:
limit
.
and_then
(
NonZeroUsize
:
:
new
)
inner_streams_waker
:
Arc
:
:
new
(
InnerWaker
{
inner_waker
:
UnsafeCell
:
:
new
(
None
)
poll_state
:
poll_state
.
clone
(
)
need_to_poll
:
NEED_TO_POLL_INNER_STREAMS
}
)
stream_waker
:
Arc
:
:
new
(
InnerWaker
{
inner_waker
:
UnsafeCell
:
:
new
(
None
)
poll_state
:
poll_state
.
clone
(
)
need_to_poll
:
NEED_TO_POLL_STREAM
}
)
poll_state
}
}
delegate_access_inner
!
(
stream
St
(
)
)
;
}
impl
<
St
>
FlattenUnorderedProj
<
'
_
St
>
where
St
:
Stream
{
fn
is_exceeded_limit
(
&
self
)
-
>
bool
{
self
.
limit
.
map_or
(
false
|
limit
|
self
.
inner_streams
.
len
(
)
>
=
limit
.
get
(
)
)
}
}
impl
<
St
>
FusedStream
for
FlattenUnordered
<
St
>
where
St
:
FusedStream
St
:
:
Item
:
FusedStream
+
Unpin
{
fn
is_terminated
(
&
self
)
-
>
bool
{
self
.
stream
.
is_terminated
(
)
&
&
self
.
inner_streams
.
is_empty
(
)
}
}
impl
<
St
>
Stream
for
FlattenUnordered
<
St
>
where
St
:
Stream
St
:
:
Item
:
Stream
+
Unpin
{
type
Item
=
<
St
:
:
Item
as
Stream
>
:
:
Item
;
fn
poll_next
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
>
{
let
mut
next_item
=
None
;
let
mut
need_to_poll_next
=
NONE
;
let
mut
this
=
self
.
as_mut
(
)
.
project
(
)
;
let
(
mut
poll_state_value
state_bomb
)
=
match
this
.
poll_state
.
start_polling
(
)
{
Some
(
value
)
=
>
value
_
=
>
{
return
Poll
:
:
Pending
;
}
}
;
if
poll_state_value
&
NEED_TO_POLL_STREAM
!
=
NONE
{
let
stream_waker
=
unsafe
{
InnerWaker
:
:
replace_waker
(
this
.
stream_waker
cx
)
}
;
loop
{
if
this
.
is_exceeded_limit
(
)
|
|
*
this
.
is_stream_done
{
if
!
*
this
.
is_stream_done
{
need_to_poll_next
|
=
NEED_TO_POLL_STREAM
;
}
break
;
}
else
{
match
this
.
stream
.
as_mut
(
)
.
poll_next
(
&
mut
Context
:
:
from_waker
(
&
stream_waker
)
)
{
Poll
:
:
Ready
(
Some
(
inner_stream
)
)
=
>
{
this
.
inner_streams
.
as_mut
(
)
.
push
(
PollStreamFut
:
:
new
(
inner_stream
)
)
;
poll_state_value
|
=
NEED_TO_POLL_INNER_STREAMS
;
}
Poll
:
:
Ready
(
None
)
=
>
{
*
this
.
is_stream_done
=
true
;
}
Poll
:
:
Pending
=
>
{
break
;
}
}
}
}
}
if
poll_state_value
&
NEED_TO_POLL_INNER_STREAMS
!
=
NONE
{
let
inner_streams_waker
=
unsafe
{
InnerWaker
:
:
replace_waker
(
this
.
inner_streams_waker
cx
)
}
;
match
this
.
inner_streams
.
as_mut
(
)
.
poll_next
(
&
mut
Context
:
:
from_waker
(
&
inner_streams_waker
)
)
{
Poll
:
:
Ready
(
Some
(
Some
(
(
item
next_item_fut
)
)
)
)
=
>
{
this
.
inner_streams
.
as_mut
(
)
.
push
(
next_item_fut
)
;
next_item
=
Some
(
item
)
;
need_to_poll_next
|
=
NEED_TO_POLL_INNER_STREAMS
;
}
Poll
:
:
Ready
(
Some
(
None
)
)
=
>
{
need_to_poll_next
|
=
NEED_TO_POLL_INNER_STREAMS
;
}
_
=
>
{
}
}
}
state_bomb
.
deactivate
(
)
;
let
mut
force_wake
=
need_to_poll_next
&
NEED_TO_POLL_STREAM
!
=
NONE
&
&
!
this
.
is_exceeded_limit
(
)
|
|
need_to_poll_next
&
NEED_TO_POLL_INNER_STREAMS
!
=
NONE
;
poll_state_value
=
this
.
poll_state
.
stop_polling
(
need_to_poll_next
force_wake
)
;
force_wake
|
=
poll_state_value
&
NEED_TO_POLL_ALL
!
=
NONE
;
let
is_done
=
*
this
.
is_stream_done
&
&
this
.
inner_streams
.
is_empty
(
)
;
if
next_item
.
is_some
(
)
|
|
is_done
{
Poll
:
:
Ready
(
next_item
)
}
else
{
if
force_wake
{
cx
.
waker
(
)
.
wake_by_ref
(
)
;
}
Poll
:
:
Pending
}
}
}
#
[
cfg
(
feature
=
"
sink
"
)
]
impl
<
St
Item
>
Sink
<
Item
>
for
FlattenUnordered
<
St
>
where
St
:
Stream
+
Sink
<
Item
>
{
type
Error
=
St
:
:
Error
;
delegate_sink
!
(
stream
Item
)
;
}
