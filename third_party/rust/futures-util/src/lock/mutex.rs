use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
sync
:
:
{
Arc
Mutex
as
StdMutex
}
;
use
std
:
:
{
fmt
mem
}
;
use
slab
:
:
Slab
;
use
futures_core
:
:
future
:
:
{
FusedFuture
Future
}
;
use
futures_core
:
:
task
:
:
{
Context
Poll
Waker
}
;
pub
struct
Mutex
<
T
:
?
Sized
>
{
state
:
AtomicUsize
waiters
:
StdMutex
<
Slab
<
Waiter
>
>
value
:
UnsafeCell
<
T
>
}
impl
<
T
:
?
Sized
>
fmt
:
:
Debug
for
Mutex
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
state
=
self
.
state
.
load
(
Ordering
:
:
SeqCst
)
;
f
.
debug_struct
(
"
Mutex
"
)
.
field
(
"
is_locked
"
&
(
(
state
&
IS_LOCKED
)
!
=
0
)
)
.
field
(
"
has_waiters
"
&
(
(
state
&
HAS_WAITERS
)
!
=
0
)
)
.
finish
(
)
}
}
impl
<
T
>
From
<
T
>
for
Mutex
<
T
>
{
fn
from
(
t
:
T
)
-
>
Self
{
Self
:
:
new
(
t
)
}
}
impl
<
T
:
Default
>
Default
for
Mutex
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
Default
:
:
default
(
)
)
}
}
enum
Waiter
{
Waiting
(
Waker
)
Woken
}
impl
Waiter
{
fn
register
(
&
mut
self
waker
:
&
Waker
)
{
match
self
{
Self
:
:
Waiting
(
w
)
if
waker
.
will_wake
(
w
)
=
>
{
}
_
=
>
*
self
=
Self
:
:
Waiting
(
waker
.
clone
(
)
)
}
}
fn
wake
(
&
mut
self
)
{
match
mem
:
:
replace
(
self
Self
:
:
Woken
)
{
Self
:
:
Waiting
(
waker
)
=
>
waker
.
wake
(
)
Self
:
:
Woken
=
>
{
}
}
}
}
const
IS_LOCKED
:
usize
=
1
<
<
0
;
const
HAS_WAITERS
:
usize
=
1
<
<
1
;
impl
<
T
>
Mutex
<
T
>
{
pub
fn
new
(
t
:
T
)
-
>
Self
{
Self
{
state
:
AtomicUsize
:
:
new
(
0
)
waiters
:
StdMutex
:
:
new
(
Slab
:
:
new
(
)
)
value
:
UnsafeCell
:
:
new
(
t
)
}
}
pub
fn
into_inner
(
self
)
-
>
T
{
self
.
value
.
into_inner
(
)
}
}
impl
<
T
:
?
Sized
>
Mutex
<
T
>
{
pub
fn
try_lock
(
&
self
)
-
>
Option
<
MutexGuard
<
'
_
T
>
>
{
let
old_state
=
self
.
state
.
fetch_or
(
IS_LOCKED
Ordering
:
:
Acquire
)
;
if
(
old_state
&
IS_LOCKED
)
=
=
0
{
Some
(
MutexGuard
{
mutex
:
self
}
)
}
else
{
None
}
}
pub
fn
try_lock_owned
(
self
:
&
Arc
<
Self
>
)
-
>
Option
<
OwnedMutexGuard
<
T
>
>
{
let
old_state
=
self
.
state
.
fetch_or
(
IS_LOCKED
Ordering
:
:
Acquire
)
;
if
(
old_state
&
IS_LOCKED
)
=
=
0
{
Some
(
OwnedMutexGuard
{
mutex
:
self
.
clone
(
)
}
)
}
else
{
None
}
}
pub
fn
lock
(
&
self
)
-
>
MutexLockFuture
<
'
_
T
>
{
MutexLockFuture
{
mutex
:
Some
(
self
)
wait_key
:
WAIT_KEY_NONE
}
}
pub
fn
lock_owned
(
self
:
Arc
<
Self
>
)
-
>
OwnedMutexLockFuture
<
T
>
{
OwnedMutexLockFuture
{
mutex
:
Some
(
self
)
wait_key
:
WAIT_KEY_NONE
}
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
T
{
unsafe
{
&
mut
*
self
.
value
.
get
(
)
}
}
fn
remove_waker
(
&
self
wait_key
:
usize
wake_another
:
bool
)
{
if
wait_key
!
=
WAIT_KEY_NONE
{
let
mut
waiters
=
self
.
waiters
.
lock
(
)
.
unwrap
(
)
;
match
waiters
.
remove
(
wait_key
)
{
Waiter
:
:
Waiting
(
_
)
=
>
{
}
Waiter
:
:
Woken
=
>
{
if
wake_another
{
if
let
Some
(
(
_i
waiter
)
)
=
waiters
.
iter_mut
(
)
.
next
(
)
{
waiter
.
wake
(
)
;
}
}
}
}
if
waiters
.
is_empty
(
)
{
self
.
state
.
fetch_and
(
!
HAS_WAITERS
Ordering
:
:
Relaxed
)
;
}
}
}
fn
unlock
(
&
self
)
{
let
old_state
=
self
.
state
.
fetch_and
(
!
IS_LOCKED
Ordering
:
:
AcqRel
)
;
if
(
old_state
&
HAS_WAITERS
)
!
=
0
{
let
mut
waiters
=
self
.
waiters
.
lock
(
)
.
unwrap
(
)
;
if
let
Some
(
(
_i
waiter
)
)
=
waiters
.
iter_mut
(
)
.
next
(
)
{
waiter
.
wake
(
)
;
}
}
}
}
const
WAIT_KEY_NONE
:
usize
=
usize
:
:
MAX
;
pub
struct
OwnedMutexLockFuture
<
T
:
?
Sized
>
{
mutex
:
Option
<
Arc
<
Mutex
<
T
>
>
>
wait_key
:
usize
}
impl
<
T
:
?
Sized
>
fmt
:
:
Debug
for
OwnedMutexLockFuture
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
OwnedMutexLockFuture
"
)
.
field
(
"
was_acquired
"
&
self
.
mutex
.
is_none
(
)
)
.
field
(
"
mutex
"
&
self
.
mutex
)
.
field
(
"
wait_key
"
&
(
if
self
.
wait_key
=
=
WAIT_KEY_NONE
{
None
}
else
{
Some
(
self
.
wait_key
)
}
)
)
.
finish
(
)
}
}
impl
<
T
:
?
Sized
>
FusedFuture
for
OwnedMutexLockFuture
<
T
>
{
fn
is_terminated
(
&
self
)
-
>
bool
{
self
.
mutex
.
is_none
(
)
}
}
impl
<
T
:
?
Sized
>
Future
for
OwnedMutexLockFuture
<
T
>
{
type
Output
=
OwnedMutexGuard
<
T
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
this
=
self
.
get_mut
(
)
;
let
mutex
=
this
.
mutex
.
as_ref
(
)
.
expect
(
"
polled
OwnedMutexLockFuture
after
completion
"
)
;
if
let
Some
(
lock
)
=
mutex
.
try_lock_owned
(
)
{
mutex
.
remove_waker
(
this
.
wait_key
false
)
;
this
.
mutex
=
None
;
return
Poll
:
:
Ready
(
lock
)
;
}
{
let
mut
waiters
=
mutex
.
waiters
.
lock
(
)
.
unwrap
(
)
;
if
this
.
wait_key
=
=
WAIT_KEY_NONE
{
this
.
wait_key
=
waiters
.
insert
(
Waiter
:
:
Waiting
(
cx
.
waker
(
)
.
clone
(
)
)
)
;
if
waiters
.
len
(
)
=
=
1
{
mutex
.
state
.
fetch_or
(
HAS_WAITERS
Ordering
:
:
Relaxed
)
;
}
}
else
{
waiters
[
this
.
wait_key
]
.
register
(
cx
.
waker
(
)
)
;
}
}
if
let
Some
(
lock
)
=
mutex
.
try_lock_owned
(
)
{
mutex
.
remove_waker
(
this
.
wait_key
false
)
;
this
.
mutex
=
None
;
return
Poll
:
:
Ready
(
lock
)
;
}
Poll
:
:
Pending
}
}
impl
<
T
:
?
Sized
>
Drop
for
OwnedMutexLockFuture
<
T
>
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
mutex
)
=
self
.
mutex
.
as_ref
(
)
{
mutex
.
remove_waker
(
self
.
wait_key
true
)
;
}
}
}
pub
struct
OwnedMutexGuard
<
T
:
?
Sized
>
{
mutex
:
Arc
<
Mutex
<
T
>
>
}
impl
<
T
:
?
Sized
+
fmt
:
:
Debug
>
fmt
:
:
Debug
for
OwnedMutexGuard
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
OwnedMutexGuard
"
)
.
field
(
"
value
"
&
&
*
*
self
)
.
field
(
"
mutex
"
&
self
.
mutex
)
.
finish
(
)
}
}
impl
<
T
:
?
Sized
>
Drop
for
OwnedMutexGuard
<
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
mutex
.
unlock
(
)
}
}
impl
<
T
:
?
Sized
>
Deref
for
OwnedMutexGuard
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
&
*
self
.
mutex
.
value
.
get
(
)
}
}
}
impl
<
T
:
?
Sized
>
DerefMut
for
OwnedMutexGuard
<
T
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
T
{
unsafe
{
&
mut
*
self
.
mutex
.
value
.
get
(
)
}
}
}
pub
struct
MutexLockFuture
<
'
a
T
:
?
Sized
>
{
mutex
:
Option
<
&
'
a
Mutex
<
T
>
>
wait_key
:
usize
}
impl
<
T
:
?
Sized
>
fmt
:
:
Debug
for
MutexLockFuture
<
'
_
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
MutexLockFuture
"
)
.
field
(
"
was_acquired
"
&
self
.
mutex
.
is_none
(
)
)
.
field
(
"
mutex
"
&
self
.
mutex
)
.
field
(
"
wait_key
"
&
(
if
self
.
wait_key
=
=
WAIT_KEY_NONE
{
None
}
else
{
Some
(
self
.
wait_key
)
}
)
)
.
finish
(
)
}
}
impl
<
T
:
?
Sized
>
FusedFuture
for
MutexLockFuture
<
'
_
T
>
{
fn
is_terminated
(
&
self
)
-
>
bool
{
self
.
mutex
.
is_none
(
)
}
}
impl
<
'
a
T
:
?
Sized
>
Future
for
MutexLockFuture
<
'
a
T
>
{
type
Output
=
MutexGuard
<
'
a
T
>
;
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
mutex
=
self
.
mutex
.
expect
(
"
polled
MutexLockFuture
after
completion
"
)
;
if
let
Some
(
lock
)
=
mutex
.
try_lock
(
)
{
mutex
.
remove_waker
(
self
.
wait_key
false
)
;
self
.
mutex
=
None
;
return
Poll
:
:
Ready
(
lock
)
;
}
{
let
mut
waiters
=
mutex
.
waiters
.
lock
(
)
.
unwrap
(
)
;
if
self
.
wait_key
=
=
WAIT_KEY_NONE
{
self
.
wait_key
=
waiters
.
insert
(
Waiter
:
:
Waiting
(
cx
.
waker
(
)
.
clone
(
)
)
)
;
if
waiters
.
len
(
)
=
=
1
{
mutex
.
state
.
fetch_or
(
HAS_WAITERS
Ordering
:
:
Relaxed
)
;
}
}
else
{
waiters
[
self
.
wait_key
]
.
register
(
cx
.
waker
(
)
)
;
}
}
if
let
Some
(
lock
)
=
mutex
.
try_lock
(
)
{
mutex
.
remove_waker
(
self
.
wait_key
false
)
;
self
.
mutex
=
None
;
return
Poll
:
:
Ready
(
lock
)
;
}
Poll
:
:
Pending
}
}
impl
<
T
:
?
Sized
>
Drop
for
MutexLockFuture
<
'
_
T
>
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
mutex
)
=
self
.
mutex
{
mutex
.
remove_waker
(
self
.
wait_key
true
)
;
}
}
}
pub
struct
MutexGuard
<
'
a
T
:
?
Sized
>
{
mutex
:
&
'
a
Mutex
<
T
>
}
impl
<
'
a
T
:
?
Sized
>
MutexGuard
<
'
a
T
>
{
#
[
inline
]
pub
fn
map
<
U
:
?
Sized
F
>
(
this
:
Self
f
:
F
)
-
>
MappedMutexGuard
<
'
a
T
U
>
where
F
:
FnOnce
(
&
mut
T
)
-
>
&
mut
U
{
let
mutex
=
this
.
mutex
;
let
value
=
f
(
unsafe
{
&
mut
*
this
.
mutex
.
value
.
get
(
)
}
)
;
mem
:
:
forget
(
this
)
;
MappedMutexGuard
{
mutex
value
_marker
:
PhantomData
}
}
}
impl
<
T
:
?
Sized
+
fmt
:
:
Debug
>
fmt
:
:
Debug
for
MutexGuard
<
'
_
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
MutexGuard
"
)
.
field
(
"
value
"
&
&
*
*
self
)
.
field
(
"
mutex
"
&
self
.
mutex
)
.
finish
(
)
}
}
impl
<
T
:
?
Sized
>
Drop
for
MutexGuard
<
'
_
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
mutex
.
unlock
(
)
}
}
impl
<
T
:
?
Sized
>
Deref
for
MutexGuard
<
'
_
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
&
*
self
.
mutex
.
value
.
get
(
)
}
}
}
impl
<
T
:
?
Sized
>
DerefMut
for
MutexGuard
<
'
_
T
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
T
{
unsafe
{
&
mut
*
self
.
mutex
.
value
.
get
(
)
}
}
}
pub
struct
MappedMutexGuard
<
'
a
T
:
?
Sized
U
:
?
Sized
>
{
mutex
:
&
'
a
Mutex
<
T
>
value
:
*
mut
U
_marker
:
PhantomData
<
&
'
a
mut
U
>
}
impl
<
'
a
T
:
?
Sized
U
:
?
Sized
>
MappedMutexGuard
<
'
a
T
U
>
{
#
[
inline
]
pub
fn
map
<
V
:
?
Sized
F
>
(
this
:
Self
f
:
F
)
-
>
MappedMutexGuard
<
'
a
T
V
>
where
F
:
FnOnce
(
&
mut
U
)
-
>
&
mut
V
{
let
mutex
=
this
.
mutex
;
let
value
=
f
(
unsafe
{
&
mut
*
this
.
value
}
)
;
mem
:
:
forget
(
this
)
;
MappedMutexGuard
{
mutex
value
_marker
:
PhantomData
}
}
}
impl
<
T
:
?
Sized
U
:
?
Sized
+
fmt
:
:
Debug
>
fmt
:
:
Debug
for
MappedMutexGuard
<
'
_
T
U
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
MappedMutexGuard
"
)
.
field
(
"
value
"
&
&
*
*
self
)
.
field
(
"
mutex
"
&
self
.
mutex
)
.
finish
(
)
}
}
impl
<
T
:
?
Sized
U
:
?
Sized
>
Drop
for
MappedMutexGuard
<
'
_
T
U
>
{
fn
drop
(
&
mut
self
)
{
self
.
mutex
.
unlock
(
)
}
}
impl
<
T
:
?
Sized
U
:
?
Sized
>
Deref
for
MappedMutexGuard
<
'
_
T
U
>
{
type
Target
=
U
;
fn
deref
(
&
self
)
-
>
&
U
{
unsafe
{
&
*
self
.
value
}
}
}
impl
<
T
:
?
Sized
U
:
?
Sized
>
DerefMut
for
MappedMutexGuard
<
'
_
T
U
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
U
{
unsafe
{
&
mut
*
self
.
value
}
}
}
unsafe
impl
<
T
:
?
Sized
+
Send
>
Send
for
Mutex
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Send
>
Sync
for
Mutex
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Send
>
Send
for
MutexLockFuture
<
'
_
T
>
{
}
unsafe
impl
<
T
:
?
Sized
>
Sync
for
MutexLockFuture
<
'
_
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Send
>
Send
for
OwnedMutexLockFuture
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
>
Sync
for
OwnedMutexLockFuture
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Send
>
Send
for
MutexGuard
<
'
_
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Sync
>
Sync
for
MutexGuard
<
'
_
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Send
>
Send
for
OwnedMutexGuard
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Sync
>
Sync
for
OwnedMutexGuard
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Send
U
:
?
Sized
+
Send
>
Send
for
MappedMutexGuard
<
'
_
T
U
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Sync
U
:
?
Sized
+
Sync
>
Sync
for
MappedMutexGuard
<
'
_
T
U
>
{
}
#
[
test
]
fn
test_mutex_guard_debug_not_recurse
(
)
{
let
mutex
=
Mutex
:
:
new
(
42
)
;
let
guard
=
mutex
.
try_lock
(
)
.
unwrap
(
)
;
let
_
=
format
!
(
"
{
:
?
}
"
guard
)
;
let
guard
=
MutexGuard
:
:
map
(
guard
|
n
|
n
)
;
let
_
=
format
!
(
"
{
:
?
}
"
guard
)
;
}
