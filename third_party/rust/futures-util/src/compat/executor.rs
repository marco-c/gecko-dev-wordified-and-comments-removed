use
super
:
:
{
Compat
Future01CompatExt
}
;
use
crate
:
:
{
future
:
:
{
FutureExt
TryFutureExt
UnitError
}
task
:
:
SpawnExt
}
;
use
futures_01
:
:
future
:
:
{
ExecuteError
as
ExecuteError01
Executor
as
Executor01
}
;
use
futures_01
:
:
Future
as
Future01
;
use
futures_task
:
:
{
FutureObj
Spawn
as
Spawn03
SpawnError
as
SpawnError03
}
;
pub
type
Executor01Future
=
Compat
<
UnitError
<
FutureObj
<
'
static
(
)
>
>
>
;
pub
trait
Executor01CompatExt
:
Executor01
<
Executor01Future
>
+
Clone
+
Send
+
'
static
{
fn
compat
(
self
)
-
>
Executor01As03
<
Self
>
where
Self
:
Sized
;
}
impl
<
Ex
>
Executor01CompatExt
for
Ex
where
Ex
:
Executor01
<
Executor01Future
>
+
Clone
+
Send
+
'
static
{
fn
compat
(
self
)
-
>
Executor01As03
<
Self
>
{
Executor01As03
{
executor01
:
self
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Executor01As03
<
Ex
>
{
executor01
:
Ex
}
impl
<
Ex
>
Spawn03
for
Executor01As03
<
Ex
>
where
Ex
:
Executor01
<
Executor01Future
>
+
Clone
+
Send
+
'
static
{
fn
spawn_obj
(
&
self
future
:
FutureObj
<
'
static
(
)
>
)
-
>
Result
<
(
)
SpawnError03
>
{
let
future
=
future
.
unit_error
(
)
.
compat
(
)
;
self
.
executor01
.
execute
(
future
)
.
map_err
(
|
_
|
SpawnError03
:
:
shutdown
(
)
)
}
}
#
[
allow
(
single_use_lifetimes
)
]
impl
<
Sp
Fut
>
Executor01
<
Fut
>
for
Compat
<
Sp
>
where
for
<
'
a
>
&
'
a
Sp
:
Spawn03
Fut
:
Future01
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
fn
execute
(
&
self
future
:
Fut
)
-
>
Result
<
(
)
ExecuteError01
<
Fut
>
>
{
(
&
self
.
inner
)
.
spawn
(
future
.
compat
(
)
.
map
(
|
_
|
(
)
)
)
.
expect
(
"
unable
to
spawn
future
from
Compat
executor
"
)
;
Ok
(
(
)
)
}
}
