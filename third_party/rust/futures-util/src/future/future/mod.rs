use
super
:
:
{
assert_future
Either
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
pin
:
:
Pin
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
futures_core
:
:
future
:
:
{
BoxFuture
LocalBoxFuture
}
;
use
futures_core
:
:
{
future
:
:
Future
stream
:
:
Stream
task
:
:
{
Context
Poll
}
}
;
mod
flatten
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
flatten
:
:
Flatten
;
mod
flatten_stream
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
flatten_stream
:
:
FlattenStream
;
mod
fuse
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
fuse
:
:
Fuse
;
mod
into_stream
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
into_stream
:
:
IntoStream
;
mod
map
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
map
:
:
Map
;
mod
then
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
then
:
:
Then
;
mod
inspect
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
inspect
:
:
Inspect
;
mod
unit_error
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
unit_error
:
:
UnitError
;
mod
never_error
;
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
never_error
:
:
NeverError
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
catch_unwind
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
catch_unwind
:
:
CatchUnwind
;
#
[
cfg
(
feature
=
"
channel
"
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
mod
remote_handle
;
#
[
cfg
(
feature
=
"
channel
"
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
remote_handle
:
:
{
Remote
RemoteHandle
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
shared
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
shared
:
:
Shared
;
mod
chain
;
pub
(
crate
)
use
self
:
:
chain
:
:
Chain
;
impl
<
T
:
?
Sized
>
FutureExt
for
T
where
T
:
Future
{
}
pub
trait
FutureExt
:
Future
{
fn
map
<
U
F
>
(
self
f
:
F
)
-
>
Map
<
Self
F
>
where
F
:
FnOnce
(
Self
:
:
Output
)
-
>
U
Self
:
Sized
{
assert_future
:
:
<
U
_
>
(
Map
:
:
new
(
self
f
)
)
}
fn
then
<
Fut
F
>
(
self
f
:
F
)
-
>
Then
<
Self
Fut
F
>
where
F
:
FnOnce
(
Self
:
:
Output
)
-
>
Fut
Fut
:
Future
Self
:
Sized
{
assert_future
:
:
<
Fut
:
:
Output
_
>
(
Then
:
:
new
(
self
f
)
)
}
fn
left_future
<
B
>
(
self
)
-
>
Either
<
Self
B
>
where
B
:
Future
<
Output
=
Self
:
:
Output
>
Self
:
Sized
{
Either
:
:
Left
(
self
)
}
fn
right_future
<
A
>
(
self
)
-
>
Either
<
A
Self
>
where
A
:
Future
<
Output
=
Self
:
:
Output
>
Self
:
Sized
{
Either
:
:
Right
(
self
)
}
fn
into_stream
(
self
)
-
>
IntoStream
<
Self
>
where
Self
:
Sized
{
IntoStream
:
:
new
(
self
)
}
fn
flatten
(
self
)
-
>
Flatten
<
Self
>
where
Self
:
:
Output
:
Future
Self
:
Sized
{
let
f
=
Flatten
:
:
new
(
self
)
;
assert_future
:
:
<
<
<
Self
as
Future
>
:
:
Output
as
Future
>
:
:
Output
_
>
(
f
)
}
fn
flatten_stream
(
self
)
-
>
FlattenStream
<
Self
>
where
Self
:
:
Output
:
Stream
Self
:
Sized
{
FlattenStream
:
:
new
(
self
)
}
fn
fuse
(
self
)
-
>
Fuse
<
Self
>
where
Self
:
Sized
{
let
f
=
Fuse
:
:
new
(
self
)
;
assert_future
:
:
<
Self
:
:
Output
_
>
(
f
)
}
fn
inspect
<
F
>
(
self
f
:
F
)
-
>
Inspect
<
Self
F
>
where
F
:
FnOnce
(
&
Self
:
:
Output
)
Self
:
Sized
{
assert_future
:
:
<
Self
:
:
Output
_
>
(
Inspect
:
:
new
(
self
f
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
catch_unwind
(
self
)
-
>
CatchUnwind
<
Self
>
where
Self
:
Sized
+
:
:
std
:
:
panic
:
:
UnwindSafe
{
CatchUnwind
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
shared
(
self
)
-
>
Shared
<
Self
>
where
Self
:
Sized
Self
:
:
Output
:
Clone
{
Shared
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
channel
"
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
remote_handle
(
self
)
-
>
(
Remote
<
Self
>
RemoteHandle
<
Self
:
:
Output
>
)
where
Self
:
Sized
{
remote_handle
:
:
remote_handle
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
boxed
<
'
a
>
(
self
)
-
>
BoxFuture
<
'
a
Self
:
:
Output
>
where
Self
:
Sized
+
Send
+
'
a
{
Box
:
:
pin
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
boxed_local
<
'
a
>
(
self
)
-
>
LocalBoxFuture
<
'
a
Self
:
:
Output
>
where
Self
:
Sized
+
'
a
{
Box
:
:
pin
(
self
)
}
fn
unit_error
(
self
)
-
>
UnitError
<
Self
>
where
Self
:
Sized
{
UnitError
:
:
new
(
self
)
}
fn
never_error
(
self
)
-
>
NeverError
<
Self
>
where
Self
:
Sized
{
NeverError
:
:
new
(
self
)
}
fn
poll_unpin
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
where
Self
:
Unpin
{
Pin
:
:
new
(
self
)
.
poll
(
cx
)
}
fn
now_or_never
(
mut
self
)
-
>
Option
<
Self
:
:
Output
>
where
Self
:
Sized
{
let
noop_waker
=
crate
:
:
task
:
:
noop_waker
(
)
;
let
mut
cx
=
Context
:
:
from_waker
(
&
noop_waker
)
;
let
pinned
=
unsafe
{
Pin
:
:
new_unchecked
(
&
mut
self
)
}
;
match
pinned
.
poll
(
&
mut
cx
)
{
Poll
:
:
Ready
(
x
)
=
>
Some
(
x
)
_
=
>
None
}
}
}
