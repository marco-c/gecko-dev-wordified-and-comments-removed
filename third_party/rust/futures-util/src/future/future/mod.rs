#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
pin
:
:
Pin
;
use
crate
:
:
fns
:
:
{
inspect_fn
into_fn
ok_fn
InspectFn
IntoFn
OkFn
}
;
use
crate
:
:
future
:
:
{
assert_future
Either
}
;
use
crate
:
:
never
:
:
Never
;
use
crate
:
:
stream
:
:
assert_stream
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
futures_core
:
:
future
:
:
{
BoxFuture
LocalBoxFuture
}
;
use
futures_core
:
:
{
future
:
:
Future
stream
:
:
Stream
task
:
:
{
Context
Poll
}
}
;
use
pin_utils
:
:
pin_mut
;
mod
flatten
;
mod
fuse
;
mod
map
;
delegate_all
!
(
/
/
/
Future
for
the
[
flatten
]
(
super
:
:
FutureExt
:
:
flatten
)
method
.
Flatten
<
F
>
(
flatten
:
:
Flatten
<
F
<
F
as
Future
>
:
:
Output
>
)
:
Debug
+
Future
+
FusedFuture
+
New
[
|
x
:
F
|
flatten
:
:
Flatten
:
:
new
(
x
)
]
where
F
:
Future
)
;
delegate_all
!
(
/
/
/
Stream
for
the
[
flatten_stream
]
(
FutureExt
:
:
flatten_stream
)
method
.
FlattenStream
<
F
>
(
flatten
:
:
Flatten
<
F
<
F
as
Future
>
:
:
Output
>
)
:
Debug
+
Sink
+
Stream
+
FusedStream
+
New
[
|
x
:
F
|
flatten
:
:
Flatten
:
:
new
(
x
)
]
where
F
:
Future
)
;
#
[
allow
(
unreachable_pub
)
]
pub
use
fuse
:
:
Fuse
;
delegate_all
!
(
/
/
/
Future
for
the
[
map
]
(
super
:
:
FutureExt
:
:
map
)
method
.
Map
<
Fut
F
>
(
map
:
:
Map
<
Fut
F
>
)
:
Debug
+
Future
+
FusedFuture
+
New
[
|
x
:
Fut
f
:
F
|
map
:
:
Map
:
:
new
(
x
f
)
]
)
;
delegate_all
!
(
/
/
/
Stream
for
the
[
into_stream
]
(
FutureExt
:
:
into_stream
)
method
.
IntoStream
<
F
>
(
crate
:
:
stream
:
:
Once
<
F
>
)
:
Debug
+
Stream
+
FusedStream
+
New
[
|
x
:
F
|
crate
:
:
stream
:
:
Once
:
:
new
(
x
)
]
)
;
delegate_all
!
(
/
/
/
Future
for
the
[
map_into
]
(
FutureExt
:
:
map_into
)
combinator
.
MapInto
<
Fut
T
>
(
Map
<
Fut
IntoFn
<
T
>
>
)
:
Debug
+
Future
+
FusedFuture
+
New
[
|
x
:
Fut
|
Map
:
:
new
(
x
into_fn
(
)
)
]
)
;
delegate_all
!
(
/
/
/
Future
for
the
[
then
]
(
FutureExt
:
:
then
)
method
.
Then
<
Fut1
Fut2
F
>
(
flatten
:
:
Flatten
<
Map
<
Fut1
F
>
Fut2
>
)
:
Debug
+
Future
+
FusedFuture
+
New
[
|
x
:
Fut1
y
:
F
|
flatten
:
:
Flatten
:
:
new
(
Map
:
:
new
(
x
y
)
)
]
)
;
delegate_all
!
(
/
/
/
Future
for
the
[
inspect
]
(
FutureExt
:
:
inspect
)
method
.
Inspect
<
Fut
F
>
(
map
:
:
Map
<
Fut
InspectFn
<
F
>
>
)
:
Debug
+
Future
+
FusedFuture
+
New
[
|
x
:
Fut
f
:
F
|
map
:
:
Map
:
:
new
(
x
inspect_fn
(
f
)
)
]
)
;
delegate_all
!
(
/
/
/
Future
for
the
[
never_error
]
(
super
:
:
FutureExt
:
:
never_error
)
combinator
.
NeverError
<
Fut
>
(
Map
<
Fut
OkFn
<
Never
>
>
)
:
Debug
+
Future
+
FusedFuture
+
New
[
|
x
:
Fut
|
Map
:
:
new
(
x
ok_fn
(
)
)
]
)
;
delegate_all
!
(
/
/
/
Future
for
the
[
unit_error
]
(
super
:
:
FutureExt
:
:
unit_error
)
combinator
.
UnitError
<
Fut
>
(
Map
<
Fut
OkFn
<
(
)
>
>
)
:
Debug
+
Future
+
FusedFuture
+
New
[
|
x
:
Fut
|
Map
:
:
new
(
x
ok_fn
(
)
)
]
)
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
catch_unwind
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
catch_unwind
:
:
CatchUnwind
;
#
[
cfg
(
feature
=
"
channel
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
channel
"
)
)
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
mod
remote_handle
;
#
[
cfg
(
feature
=
"
channel
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
channel
"
)
)
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
remote_handle
:
:
{
Remote
RemoteHandle
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
shared
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
unreachable_pub
)
]
pub
use
self
:
:
shared
:
:
{
Shared
WeakShared
}
;
impl
<
T
:
?
Sized
>
FutureExt
for
T
where
T
:
Future
{
}
pub
trait
FutureExt
:
Future
{
fn
map
<
U
F
>
(
self
f
:
F
)
-
>
Map
<
Self
F
>
where
F
:
FnOnce
(
Self
:
:
Output
)
-
>
U
Self
:
Sized
{
assert_future
:
:
<
U
_
>
(
Map
:
:
new
(
self
f
)
)
}
fn
map_into
<
U
>
(
self
)
-
>
MapInto
<
Self
U
>
where
Self
:
:
Output
:
Into
<
U
>
Self
:
Sized
{
assert_future
:
:
<
U
_
>
(
MapInto
:
:
new
(
self
)
)
}
fn
then
<
Fut
F
>
(
self
f
:
F
)
-
>
Then
<
Self
Fut
F
>
where
F
:
FnOnce
(
Self
:
:
Output
)
-
>
Fut
Fut
:
Future
Self
:
Sized
{
assert_future
:
:
<
Fut
:
:
Output
_
>
(
Then
:
:
new
(
self
f
)
)
}
fn
left_future
<
B
>
(
self
)
-
>
Either
<
Self
B
>
where
B
:
Future
<
Output
=
Self
:
:
Output
>
Self
:
Sized
{
assert_future
:
:
<
Self
:
:
Output
_
>
(
Either
:
:
Left
(
self
)
)
}
fn
right_future
<
A
>
(
self
)
-
>
Either
<
A
Self
>
where
A
:
Future
<
Output
=
Self
:
:
Output
>
Self
:
Sized
{
assert_future
:
:
<
Self
:
:
Output
_
>
(
Either
:
:
Right
(
self
)
)
}
fn
into_stream
(
self
)
-
>
IntoStream
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
Self
:
:
Output
_
>
(
IntoStream
:
:
new
(
self
)
)
}
fn
flatten
(
self
)
-
>
Flatten
<
Self
>
where
Self
:
:
Output
:
Future
Self
:
Sized
{
let
f
=
Flatten
:
:
new
(
self
)
;
assert_future
:
:
<
<
<
Self
as
Future
>
:
:
Output
as
Future
>
:
:
Output
_
>
(
f
)
}
fn
flatten_stream
(
self
)
-
>
FlattenStream
<
Self
>
where
Self
:
:
Output
:
Stream
Self
:
Sized
{
assert_stream
:
:
<
<
Self
:
:
Output
as
Stream
>
:
:
Item
_
>
(
FlattenStream
:
:
new
(
self
)
)
}
fn
fuse
(
self
)
-
>
Fuse
<
Self
>
where
Self
:
Sized
{
let
f
=
Fuse
:
:
new
(
self
)
;
assert_future
:
:
<
Self
:
:
Output
_
>
(
f
)
}
fn
inspect
<
F
>
(
self
f
:
F
)
-
>
Inspect
<
Self
F
>
where
F
:
FnOnce
(
&
Self
:
:
Output
)
Self
:
Sized
{
assert_future
:
:
<
Self
:
:
Output
_
>
(
Inspect
:
:
new
(
self
f
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
catch_unwind
(
self
)
-
>
CatchUnwind
<
Self
>
where
Self
:
Sized
+
:
:
std
:
:
panic
:
:
UnwindSafe
{
assert_future
:
:
<
Result
<
Self
:
:
Output
Box
<
dyn
std
:
:
any
:
:
Any
+
Send
>
>
_
>
(
CatchUnwind
:
:
new
(
self
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
shared
(
self
)
-
>
Shared
<
Self
>
where
Self
:
Sized
Self
:
:
Output
:
Clone
{
assert_future
:
:
<
Self
:
:
Output
_
>
(
Shared
:
:
new
(
self
)
)
}
#
[
cfg
(
feature
=
"
channel
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
channel
"
)
)
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
remote_handle
(
self
)
-
>
(
Remote
<
Self
>
RemoteHandle
<
Self
:
:
Output
>
)
where
Self
:
Sized
{
let
(
wrapped
handle
)
=
remote_handle
:
:
remote_handle
(
self
)
;
(
assert_future
:
:
<
(
)
_
>
(
wrapped
)
handle
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
boxed
<
'
a
>
(
self
)
-
>
BoxFuture
<
'
a
Self
:
:
Output
>
where
Self
:
Sized
+
Send
+
'
a
{
assert_future
:
:
<
Self
:
:
Output
_
>
(
Box
:
:
pin
(
self
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
boxed_local
<
'
a
>
(
self
)
-
>
LocalBoxFuture
<
'
a
Self
:
:
Output
>
where
Self
:
Sized
+
'
a
{
assert_future
:
:
<
Self
:
:
Output
_
>
(
Box
:
:
pin
(
self
)
)
}
fn
unit_error
(
self
)
-
>
UnitError
<
Self
>
where
Self
:
Sized
{
assert_future
:
:
<
Result
<
Self
:
:
Output
(
)
>
_
>
(
UnitError
:
:
new
(
self
)
)
}
fn
never_error
(
self
)
-
>
NeverError
<
Self
>
where
Self
:
Sized
{
assert_future
:
:
<
Result
<
Self
:
:
Output
Never
>
_
>
(
NeverError
:
:
new
(
self
)
)
}
fn
poll_unpin
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
where
Self
:
Unpin
{
Pin
:
:
new
(
self
)
.
poll
(
cx
)
}
fn
now_or_never
(
self
)
-
>
Option
<
Self
:
:
Output
>
where
Self
:
Sized
{
let
noop_waker
=
crate
:
:
task
:
:
noop_waker
(
)
;
let
mut
cx
=
Context
:
:
from_waker
(
&
noop_waker
)
;
let
this
=
self
;
pin_mut
!
(
this
)
;
match
this
.
poll
(
&
mut
cx
)
{
Poll
:
:
Ready
(
x
)
=
>
Some
(
x
)
_
=
>
None
}
}
}
