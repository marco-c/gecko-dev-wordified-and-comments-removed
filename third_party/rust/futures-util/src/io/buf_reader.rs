use
futures_core
:
:
task
:
:
{
Context
Poll
}
;
#
[
cfg
(
feature
=
"
read
-
initializer
"
)
]
use
futures_io
:
:
Initializer
;
use
futures_io
:
:
{
AsyncBufRead
AsyncRead
AsyncSeek
AsyncWrite
IoSlice
IoSliceMut
SeekFrom
}
;
use
pin_utils
:
:
{
unsafe_pinned
unsafe_unpinned
}
;
use
std
:
:
io
:
:
{
self
Read
}
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
{
cmp
fmt
}
;
use
super
:
:
DEFAULT_BUF_SIZE
;
pub
struct
BufReader
<
R
>
{
inner
:
R
buf
:
Box
<
[
u8
]
>
pos
:
usize
cap
:
usize
}
impl
<
R
>
BufReader
<
R
>
{
unsafe_pinned
!
(
inner
:
R
)
;
unsafe_unpinned
!
(
pos
:
usize
)
;
unsafe_unpinned
!
(
cap
:
usize
)
;
}
impl
<
R
:
AsyncRead
>
BufReader
<
R
>
{
pub
fn
new
(
inner
:
R
)
-
>
Self
{
Self
:
:
with_capacity
(
DEFAULT_BUF_SIZE
inner
)
}
pub
fn
with_capacity
(
capacity
:
usize
inner
:
R
)
-
>
Self
{
unsafe
{
let
mut
buffer
=
Vec
:
:
with_capacity
(
capacity
)
;
buffer
.
set_len
(
capacity
)
;
super
:
:
initialize
(
&
inner
&
mut
buffer
)
;
Self
{
inner
buf
:
buffer
.
into_boxed_slice
(
)
pos
:
0
cap
:
0
}
}
}
pub
fn
get_ref
(
&
self
)
-
>
&
R
{
&
self
.
inner
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
R
{
&
mut
self
.
inner
}
pub
fn
get_pin_mut
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Pin
<
&
mut
R
>
{
self
.
inner
(
)
}
pub
fn
into_inner
(
self
)
-
>
R
{
self
.
inner
}
pub
fn
buffer
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
buf
[
self
.
pos
.
.
self
.
cap
]
}
#
[
inline
]
fn
discard_buffer
(
mut
self
:
Pin
<
&
mut
Self
>
)
{
*
self
.
as_mut
(
)
.
pos
(
)
=
0
;
*
self
.
cap
(
)
=
0
;
}
}
impl
<
R
:
AsyncRead
>
AsyncRead
for
BufReader
<
R
>
{
fn
poll_read
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
buf
:
&
mut
[
u8
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
if
self
.
pos
=
=
self
.
cap
&
&
buf
.
len
(
)
>
=
self
.
buf
.
len
(
)
{
let
res
=
ready
!
(
self
.
as_mut
(
)
.
inner
(
)
.
poll_read
(
cx
buf
)
)
;
self
.
discard_buffer
(
)
;
return
Poll
:
:
Ready
(
res
)
;
}
let
mut
rem
=
ready
!
(
self
.
as_mut
(
)
.
poll_fill_buf
(
cx
)
)
?
;
let
nread
=
rem
.
read
(
buf
)
?
;
self
.
consume
(
nread
)
;
Poll
:
:
Ready
(
Ok
(
nread
)
)
}
fn
poll_read_vectored
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
bufs
:
&
mut
[
IoSliceMut
<
'
_
>
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
let
total_len
=
bufs
.
iter
(
)
.
map
(
|
b
|
b
.
len
(
)
)
.
sum
:
:
<
usize
>
(
)
;
if
self
.
pos
=
=
self
.
cap
&
&
total_len
>
=
self
.
buf
.
len
(
)
{
let
res
=
ready
!
(
self
.
as_mut
(
)
.
inner
(
)
.
poll_read_vectored
(
cx
bufs
)
)
;
self
.
discard_buffer
(
)
;
return
Poll
:
:
Ready
(
res
)
;
}
let
mut
rem
=
ready
!
(
self
.
as_mut
(
)
.
poll_fill_buf
(
cx
)
)
?
;
let
nread
=
rem
.
read_vectored
(
bufs
)
?
;
self
.
consume
(
nread
)
;
Poll
:
:
Ready
(
Ok
(
nread
)
)
}
#
[
cfg
(
feature
=
"
read
-
initializer
"
)
]
unsafe
fn
initializer
(
&
self
)
-
>
Initializer
{
self
.
inner
.
initializer
(
)
}
}
impl
<
R
:
AsyncRead
>
AsyncBufRead
for
BufReader
<
R
>
{
fn
poll_fill_buf
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
&
[
u8
]
>
>
{
let
Self
{
inner
buf
cap
pos
}
=
unsafe
{
self
.
get_unchecked_mut
(
)
}
;
let
mut
inner
=
unsafe
{
Pin
:
:
new_unchecked
(
inner
)
}
;
if
*
pos
>
=
*
cap
{
debug_assert
!
(
*
pos
=
=
*
cap
)
;
*
cap
=
ready
!
(
inner
.
as_mut
(
)
.
poll_read
(
cx
buf
)
)
?
;
*
pos
=
0
;
}
Poll
:
:
Ready
(
Ok
(
&
buf
[
*
pos
.
.
*
cap
]
)
)
}
fn
consume
(
mut
self
:
Pin
<
&
mut
Self
>
amt
:
usize
)
{
*
self
.
as_mut
(
)
.
pos
(
)
=
cmp
:
:
min
(
self
.
pos
+
amt
self
.
cap
)
;
}
}
impl
<
R
:
AsyncWrite
>
AsyncWrite
for
BufReader
<
R
>
{
fn
poll_write
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
buf
:
&
[
u8
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
self
.
inner
(
)
.
poll_write
(
cx
buf
)
}
fn
poll_write_vectored
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
bufs
:
&
[
IoSlice
<
'
_
>
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
self
.
inner
(
)
.
poll_write_vectored
(
cx
bufs
)
}
fn
poll_flush
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
self
.
inner
(
)
.
poll_flush
(
cx
)
}
fn
poll_close
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
self
.
inner
(
)
.
poll_close
(
cx
)
}
}
impl
<
R
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
BufReader
<
R
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
BufReader
"
)
.
field
(
"
reader
"
&
self
.
inner
)
.
field
(
"
buffer
"
&
format_args
!
(
"
{
}
/
{
}
"
self
.
cap
-
self
.
pos
self
.
buf
.
len
(
)
)
)
.
finish
(
)
}
}
impl
<
R
:
AsyncRead
+
AsyncSeek
>
AsyncSeek
for
BufReader
<
R
>
{
fn
poll_seek
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
pos
:
SeekFrom
)
-
>
Poll
<
io
:
:
Result
<
u64
>
>
{
let
result
:
u64
;
if
let
SeekFrom
:
:
Current
(
n
)
=
pos
{
let
remainder
=
(
self
.
cap
-
self
.
pos
)
as
i64
;
if
let
Some
(
offset
)
=
n
.
checked_sub
(
remainder
)
{
result
=
ready
!
(
self
.
as_mut
(
)
.
inner
(
)
.
poll_seek
(
cx
SeekFrom
:
:
Current
(
offset
)
)
)
?
;
}
else
{
ready
!
(
self
.
as_mut
(
)
.
inner
(
)
.
poll_seek
(
cx
SeekFrom
:
:
Current
(
-
remainder
)
)
)
?
;
self
.
as_mut
(
)
.
discard_buffer
(
)
;
result
=
ready
!
(
self
.
as_mut
(
)
.
inner
(
)
.
poll_seek
(
cx
SeekFrom
:
:
Current
(
n
)
)
)
?
;
}
}
else
{
result
=
ready
!
(
self
.
as_mut
(
)
.
inner
(
)
.
poll_seek
(
cx
pos
)
)
?
;
}
self
.
discard_buffer
(
)
;
Poll
:
:
Ready
(
Ok
(
result
)
)
}
}
