#
[
cfg
(
feature
=
"
io
-
compat
"
)
]
use
crate
:
:
compat
:
:
Compat
;
use
std
:
:
ptr
;
pub
use
futures_io
:
:
{
AsyncRead
AsyncWrite
AsyncSeek
AsyncBufRead
Error
ErrorKind
IoSlice
IoSliceMut
Result
SeekFrom
}
;
#
[
cfg
(
feature
=
"
read
-
initializer
"
)
]
pub
use
futures_io
:
:
Initializer
;
const
DEFAULT_BUF_SIZE
:
usize
=
8
*
1024
;
#
[
inline
]
unsafe
fn
initialize
<
R
:
AsyncRead
>
(
_reader
:
&
R
buf
:
&
mut
[
u8
]
)
{
#
[
cfg
(
feature
=
"
read
-
initializer
"
)
]
{
if
!
_reader
.
initializer
(
)
.
should_initialize
(
)
{
return
;
}
}
ptr
:
:
write_bytes
(
buf
.
as_mut_ptr
(
)
0
buf
.
len
(
)
)
}
mod
allow_std
;
pub
use
self
:
:
allow_std
:
:
AllowStdIo
;
mod
buf_reader
;
pub
use
self
:
:
buf_reader
:
:
BufReader
;
mod
buf_writer
;
pub
use
self
:
:
buf_writer
:
:
BufWriter
;
mod
chain
;
pub
use
self
:
:
chain
:
:
Chain
;
mod
close
;
pub
use
self
:
:
close
:
:
Close
;
mod
copy
;
pub
use
self
:
:
copy
:
:
{
copy
Copy
}
;
mod
copy_buf
;
pub
use
self
:
:
copy_buf
:
:
{
copy_buf
CopyBuf
}
;
mod
cursor
;
pub
use
self
:
:
cursor
:
:
Cursor
;
mod
empty
;
pub
use
self
:
:
empty
:
:
{
empty
Empty
}
;
mod
flush
;
pub
use
self
:
:
flush
:
:
Flush
;
#
[
cfg
(
feature
=
"
sink
"
)
]
mod
into_sink
;
#
[
cfg
(
feature
=
"
sink
"
)
]
pub
use
self
:
:
into_sink
:
:
IntoSink
;
mod
lines
;
pub
use
self
:
:
lines
:
:
Lines
;
mod
read
;
pub
use
self
:
:
read
:
:
Read
;
mod
read_vectored
;
pub
use
self
:
:
read_vectored
:
:
ReadVectored
;
mod
read_exact
;
pub
use
self
:
:
read_exact
:
:
ReadExact
;
mod
read_line
;
pub
use
self
:
:
read_line
:
:
ReadLine
;
mod
read_to_end
;
pub
use
self
:
:
read_to_end
:
:
ReadToEnd
;
mod
read_to_string
;
pub
use
self
:
:
read_to_string
:
:
ReadToString
;
mod
read_until
;
pub
use
self
:
:
read_until
:
:
ReadUntil
;
mod
repeat
;
pub
use
self
:
:
repeat
:
:
{
repeat
Repeat
}
;
mod
seek
;
pub
use
self
:
:
seek
:
:
Seek
;
mod
sink
;
pub
use
self
:
:
sink
:
:
{
sink
Sink
}
;
mod
split
;
pub
use
self
:
:
split
:
:
{
ReadHalf
WriteHalf
}
;
mod
take
;
pub
use
self
:
:
take
:
:
Take
;
mod
window
;
pub
use
self
:
:
window
:
:
Window
;
mod
write
;
pub
use
self
:
:
write
:
:
Write
;
mod
write_vectored
;
pub
use
self
:
:
write_vectored
:
:
WriteVectored
;
mod
write_all
;
pub
use
self
:
:
write_all
:
:
WriteAll
;
pub
trait
AsyncReadExt
:
AsyncRead
{
fn
chain
<
R
>
(
self
next
:
R
)
-
>
Chain
<
Self
R
>
where
Self
:
Sized
R
:
AsyncRead
{
Chain
:
:
new
(
self
next
)
}
fn
read
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
mut
[
u8
]
)
-
>
Read
<
'
a
Self
>
where
Self
:
Unpin
{
Read
:
:
new
(
self
buf
)
}
fn
read_vectored
<
'
a
>
(
&
'
a
mut
self
bufs
:
&
'
a
mut
[
IoSliceMut
<
'
a
>
]
)
-
>
ReadVectored
<
'
a
Self
>
where
Self
:
Unpin
{
ReadVectored
:
:
new
(
self
bufs
)
}
fn
read_exact
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
mut
[
u8
]
)
-
>
ReadExact
<
'
a
Self
>
where
Self
:
Unpin
{
ReadExact
:
:
new
(
self
buf
)
}
fn
read_to_end
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
mut
Vec
<
u8
>
)
-
>
ReadToEnd
<
'
a
Self
>
where
Self
:
Unpin
{
ReadToEnd
:
:
new
(
self
buf
)
}
fn
read_to_string
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
mut
String
)
-
>
ReadToString
<
'
a
Self
>
where
Self
:
Unpin
{
ReadToString
:
:
new
(
self
buf
)
}
fn
split
(
self
)
-
>
(
ReadHalf
<
Self
>
WriteHalf
<
Self
>
)
where
Self
:
AsyncWrite
+
Sized
{
split
:
:
split
(
self
)
}
fn
take
(
self
limit
:
u64
)
-
>
Take
<
Self
>
where
Self
:
Sized
{
Take
:
:
new
(
self
limit
)
}
#
[
cfg
(
feature
=
"
io
-
compat
"
)
]
fn
compat
(
self
)
-
>
Compat
<
Self
>
where
Self
:
Sized
+
Unpin
{
Compat
:
:
new
(
self
)
}
}
impl
<
R
:
AsyncRead
+
?
Sized
>
AsyncReadExt
for
R
{
}
pub
trait
AsyncWriteExt
:
AsyncWrite
{
fn
flush
(
&
mut
self
)
-
>
Flush
<
'
_
Self
>
where
Self
:
Unpin
{
Flush
:
:
new
(
self
)
}
fn
close
(
&
mut
self
)
-
>
Close
<
'
_
Self
>
where
Self
:
Unpin
{
Close
:
:
new
(
self
)
}
fn
write
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
[
u8
]
)
-
>
Write
<
'
a
Self
>
where
Self
:
Unpin
{
Write
:
:
new
(
self
buf
)
}
fn
write_vectored
<
'
a
>
(
&
'
a
mut
self
bufs
:
&
'
a
[
IoSlice
<
'
a
>
]
)
-
>
WriteVectored
<
'
a
Self
>
where
Self
:
Unpin
{
WriteVectored
:
:
new
(
self
bufs
)
}
fn
write_all
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
[
u8
]
)
-
>
WriteAll
<
'
a
Self
>
where
Self
:
Unpin
{
WriteAll
:
:
new
(
self
buf
)
}
#
[
cfg
(
feature
=
"
io
-
compat
"
)
]
fn
compat_write
(
self
)
-
>
Compat
<
Self
>
where
Self
:
Sized
+
Unpin
{
Compat
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
sink
"
)
]
fn
into_sink
<
Item
:
AsRef
<
[
u8
]
>
>
(
self
)
-
>
IntoSink
<
Self
Item
>
where
Self
:
Sized
{
IntoSink
:
:
new
(
self
)
}
}
impl
<
W
:
AsyncWrite
+
?
Sized
>
AsyncWriteExt
for
W
{
}
pub
trait
AsyncSeekExt
:
AsyncSeek
{
fn
seek
(
&
mut
self
pos
:
SeekFrom
)
-
>
Seek
<
'
_
Self
>
where
Self
:
Unpin
{
Seek
:
:
new
(
self
pos
)
}
}
impl
<
S
:
AsyncSeek
+
?
Sized
>
AsyncSeekExt
for
S
{
}
pub
trait
AsyncBufReadExt
:
AsyncBufRead
{
fn
read_until
<
'
a
>
(
&
'
a
mut
self
byte
:
u8
buf
:
&
'
a
mut
Vec
<
u8
>
)
-
>
ReadUntil
<
'
a
Self
>
where
Self
:
Unpin
{
ReadUntil
:
:
new
(
self
byte
buf
)
}
fn
read_line
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
mut
String
)
-
>
ReadLine
<
'
a
Self
>
where
Self
:
Unpin
{
ReadLine
:
:
new
(
self
buf
)
}
fn
lines
(
self
)
-
>
Lines
<
Self
>
where
Self
:
Sized
{
Lines
:
:
new
(
self
)
}
}
impl
<
R
:
AsyncBufRead
+
?
Sized
>
AsyncBufReadExt
for
R
{
}
