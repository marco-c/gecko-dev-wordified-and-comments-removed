#
[
cfg
(
feature
=
"
io
-
compat
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
io
-
compat
"
)
)
)
]
use
crate
:
:
compat
:
:
Compat
;
use
crate
:
:
future
:
:
assert_future
;
use
crate
:
:
stream
:
:
assert_stream
;
use
std
:
:
{
pin
:
:
Pin
ptr
}
;
#
[
doc
(
no_inline
)
]
#
[
cfg
(
feature
=
"
read
-
initializer
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
read
-
initializer
"
)
)
)
]
pub
use
std
:
:
io
:
:
Initializer
;
#
[
doc
(
no_inline
)
]
pub
use
std
:
:
io
:
:
{
Error
ErrorKind
IoSlice
IoSliceMut
Result
SeekFrom
}
;
pub
use
futures_io
:
:
{
AsyncBufRead
AsyncRead
AsyncSeek
AsyncWrite
}
;
const
DEFAULT_BUF_SIZE
:
usize
=
8
*
1024
;
#
[
inline
]
unsafe
fn
initialize
<
R
:
AsyncRead
>
(
_reader
:
&
R
buf
:
&
mut
[
u8
]
)
{
#
[
cfg
(
feature
=
"
read
-
initializer
"
)
]
{
if
!
_reader
.
initializer
(
)
.
should_initialize
(
)
{
return
;
}
}
ptr
:
:
write_bytes
(
buf
.
as_mut_ptr
(
)
0
buf
.
len
(
)
)
}
mod
allow_std
;
pub
use
self
:
:
allow_std
:
:
AllowStdIo
;
mod
buf_reader
;
pub
use
self
:
:
buf_reader
:
:
BufReader
;
mod
buf_writer
;
pub
use
self
:
:
buf_writer
:
:
BufWriter
;
mod
chain
;
pub
use
self
:
:
chain
:
:
Chain
;
mod
close
;
pub
use
self
:
:
close
:
:
Close
;
mod
copy
;
pub
use
self
:
:
copy
:
:
{
copy
Copy
}
;
mod
copy_buf
;
pub
use
self
:
:
copy_buf
:
:
{
copy_buf
CopyBuf
}
;
mod
cursor
;
pub
use
self
:
:
cursor
:
:
Cursor
;
mod
empty
;
pub
use
self
:
:
empty
:
:
{
empty
Empty
}
;
mod
fill_buf
;
pub
use
self
:
:
fill_buf
:
:
FillBuf
;
mod
flush
;
pub
use
self
:
:
flush
:
:
Flush
;
#
[
cfg
(
feature
=
"
sink
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
sink
"
)
)
)
]
mod
into_sink
;
#
[
cfg
(
feature
=
"
sink
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
sink
"
)
)
)
]
pub
use
self
:
:
into_sink
:
:
IntoSink
;
mod
lines
;
pub
use
self
:
:
lines
:
:
Lines
;
mod
read
;
pub
use
self
:
:
read
:
:
Read
;
mod
read_vectored
;
pub
use
self
:
:
read_vectored
:
:
ReadVectored
;
mod
read_exact
;
pub
use
self
:
:
read_exact
:
:
ReadExact
;
mod
read_line
;
pub
use
self
:
:
read_line
:
:
ReadLine
;
mod
read_to_end
;
pub
use
self
:
:
read_to_end
:
:
ReadToEnd
;
mod
read_to_string
;
pub
use
self
:
:
read_to_string
:
:
ReadToString
;
mod
read_until
;
pub
use
self
:
:
read_until
:
:
ReadUntil
;
mod
repeat
;
pub
use
self
:
:
repeat
:
:
{
repeat
Repeat
}
;
mod
seek
;
pub
use
self
:
:
seek
:
:
Seek
;
mod
sink
;
pub
use
self
:
:
sink
:
:
{
sink
Sink
}
;
mod
split
;
pub
use
self
:
:
split
:
:
{
ReadHalf
ReuniteError
WriteHalf
}
;
mod
take
;
pub
use
self
:
:
take
:
:
Take
;
mod
window
;
pub
use
self
:
:
window
:
:
Window
;
mod
write
;
pub
use
self
:
:
write
:
:
Write
;
mod
write_vectored
;
pub
use
self
:
:
write_vectored
:
:
WriteVectored
;
mod
write_all
;
pub
use
self
:
:
write_all
:
:
WriteAll
;
#
[
cfg
(
feature
=
"
write
-
all
-
vectored
"
)
]
mod
write_all_vectored
;
#
[
cfg
(
feature
=
"
write
-
all
-
vectored
"
)
]
pub
use
self
:
:
write_all_vectored
:
:
WriteAllVectored
;
pub
trait
AsyncReadExt
:
AsyncRead
{
fn
chain
<
R
>
(
self
next
:
R
)
-
>
Chain
<
Self
R
>
where
Self
:
Sized
R
:
AsyncRead
{
assert_read
(
Chain
:
:
new
(
self
next
)
)
}
fn
read
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
mut
[
u8
]
)
-
>
Read
<
'
a
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
usize
>
_
>
(
Read
:
:
new
(
self
buf
)
)
}
fn
read_vectored
<
'
a
>
(
&
'
a
mut
self
bufs
:
&
'
a
mut
[
IoSliceMut
<
'
a
>
]
)
-
>
ReadVectored
<
'
a
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
usize
>
_
>
(
ReadVectored
:
:
new
(
self
bufs
)
)
}
fn
read_exact
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
mut
[
u8
]
)
-
>
ReadExact
<
'
a
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
(
)
>
_
>
(
ReadExact
:
:
new
(
self
buf
)
)
}
fn
read_to_end
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
mut
Vec
<
u8
>
)
-
>
ReadToEnd
<
'
a
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
usize
>
_
>
(
ReadToEnd
:
:
new
(
self
buf
)
)
}
fn
read_to_string
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
mut
String
)
-
>
ReadToString
<
'
a
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
usize
>
_
>
(
ReadToString
:
:
new
(
self
buf
)
)
}
fn
split
(
self
)
-
>
(
ReadHalf
<
Self
>
WriteHalf
<
Self
>
)
where
Self
:
AsyncWrite
+
Sized
{
let
(
r
w
)
=
split
:
:
split
(
self
)
;
(
assert_read
(
r
)
assert_write
(
w
)
)
}
fn
take
(
self
limit
:
u64
)
-
>
Take
<
Self
>
where
Self
:
Sized
{
assert_read
(
Take
:
:
new
(
self
limit
)
)
}
#
[
cfg
(
feature
=
"
io
-
compat
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
io
-
compat
"
)
)
)
]
fn
compat
(
self
)
-
>
Compat
<
Self
>
where
Self
:
Sized
+
Unpin
{
Compat
:
:
new
(
self
)
}
}
impl
<
R
:
AsyncRead
+
?
Sized
>
AsyncReadExt
for
R
{
}
pub
trait
AsyncWriteExt
:
AsyncWrite
{
fn
flush
(
&
mut
self
)
-
>
Flush
<
'
_
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
(
)
>
_
>
(
Flush
:
:
new
(
self
)
)
}
fn
close
(
&
mut
self
)
-
>
Close
<
'
_
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
(
)
>
_
>
(
Close
:
:
new
(
self
)
)
}
fn
write
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
[
u8
]
)
-
>
Write
<
'
a
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
usize
>
_
>
(
Write
:
:
new
(
self
buf
)
)
}
fn
write_vectored
<
'
a
>
(
&
'
a
mut
self
bufs
:
&
'
a
[
IoSlice
<
'
a
>
]
)
-
>
WriteVectored
<
'
a
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
usize
>
_
>
(
WriteVectored
:
:
new
(
self
bufs
)
)
}
fn
write_all
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
[
u8
]
)
-
>
WriteAll
<
'
a
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
(
)
>
_
>
(
WriteAll
:
:
new
(
self
buf
)
)
}
#
[
cfg
(
feature
=
"
write
-
all
-
vectored
"
)
]
fn
write_all_vectored
<
'
a
>
(
&
'
a
mut
self
bufs
:
&
'
a
mut
[
IoSlice
<
'
a
>
]
)
-
>
WriteAllVectored
<
'
a
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
(
)
>
_
>
(
WriteAllVectored
:
:
new
(
self
bufs
)
)
}
#
[
cfg
(
feature
=
"
io
-
compat
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
io
-
compat
"
)
)
)
]
fn
compat_write
(
self
)
-
>
Compat
<
Self
>
where
Self
:
Sized
+
Unpin
{
Compat
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
sink
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
sink
"
)
)
)
]
fn
into_sink
<
Item
:
AsRef
<
[
u8
]
>
>
(
self
)
-
>
IntoSink
<
Self
Item
>
where
Self
:
Sized
{
crate
:
:
sink
:
:
assert_sink
:
:
<
Item
Error
_
>
(
IntoSink
:
:
new
(
self
)
)
}
}
impl
<
W
:
AsyncWrite
+
?
Sized
>
AsyncWriteExt
for
W
{
}
pub
trait
AsyncSeekExt
:
AsyncSeek
{
fn
seek
(
&
mut
self
pos
:
SeekFrom
)
-
>
Seek
<
'
_
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
u64
>
_
>
(
Seek
:
:
new
(
self
pos
)
)
}
fn
stream_position
(
&
mut
self
)
-
>
Seek
<
'
_
Self
>
where
Self
:
Unpin
{
self
.
seek
(
SeekFrom
:
:
Current
(
0
)
)
}
}
impl
<
S
:
AsyncSeek
+
?
Sized
>
AsyncSeekExt
for
S
{
}
pub
trait
AsyncBufReadExt
:
AsyncBufRead
{
fn
fill_buf
(
&
mut
self
)
-
>
FillBuf
<
'
_
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
&
[
u8
]
>
_
>
(
FillBuf
:
:
new
(
self
)
)
}
fn
consume_unpin
(
&
mut
self
amt
:
usize
)
where
Self
:
Unpin
{
Pin
:
:
new
(
self
)
.
consume
(
amt
)
}
fn
read_until
<
'
a
>
(
&
'
a
mut
self
byte
:
u8
buf
:
&
'
a
mut
Vec
<
u8
>
)
-
>
ReadUntil
<
'
a
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
usize
>
_
>
(
ReadUntil
:
:
new
(
self
byte
buf
)
)
}
fn
read_line
<
'
a
>
(
&
'
a
mut
self
buf
:
&
'
a
mut
String
)
-
>
ReadLine
<
'
a
Self
>
where
Self
:
Unpin
{
assert_future
:
:
<
Result
<
usize
>
_
>
(
ReadLine
:
:
new
(
self
buf
)
)
}
fn
lines
(
self
)
-
>
Lines
<
Self
>
where
Self
:
Sized
{
assert_stream
:
:
<
Result
<
String
>
_
>
(
Lines
:
:
new
(
self
)
)
}
}
impl
<
R
:
AsyncBufRead
+
?
Sized
>
AsyncBufReadExt
for
R
{
}
pub
(
crate
)
fn
assert_read
<
R
>
(
reader
:
R
)
-
>
R
where
R
:
AsyncRead
{
reader
}
pub
(
crate
)
fn
assert_write
<
W
>
(
writer
:
W
)
-
>
W
where
W
:
AsyncWrite
{
writer
}
