use
futures_core
:
:
ready
;
use
futures_core
:
:
task
:
:
{
Context
Poll
}
;
use
futures_io
:
:
{
AsyncBufRead
AsyncRead
}
;
use
pin_project_lite
:
:
pin_project
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
{
cmp
io
}
;
pin_project
!
{
/
/
/
Reader
for
the
[
take
]
(
super
:
:
AsyncReadExt
:
:
take
)
method
.
#
[
derive
(
Debug
)
]
#
[
must_use
=
"
readers
do
nothing
unless
you
.
await
or
poll
them
"
]
pub
struct
Take
<
R
>
{
#
[
pin
]
inner
:
R
limit
:
u64
}
}
impl
<
R
:
AsyncRead
>
Take
<
R
>
{
pub
(
super
)
fn
new
(
inner
:
R
limit
:
u64
)
-
>
Self
{
Self
{
inner
limit
}
}
pub
fn
limit
(
&
self
)
-
>
u64
{
self
.
limit
}
pub
fn
set_limit
(
&
mut
self
limit
:
u64
)
{
self
.
limit
=
limit
}
delegate_access_inner
!
(
inner
R
(
)
)
;
}
impl
<
R
:
AsyncRead
>
AsyncRead
for
Take
<
R
>
{
fn
poll_read
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
buf
:
&
mut
[
u8
]
)
-
>
Poll
<
Result
<
usize
io
:
:
Error
>
>
{
let
this
=
self
.
project
(
)
;
if
*
this
.
limit
=
=
0
{
return
Poll
:
:
Ready
(
Ok
(
0
)
)
;
}
let
max
=
cmp
:
:
min
(
buf
.
len
(
)
as
u64
*
this
.
limit
)
as
usize
;
let
n
=
ready
!
(
this
.
inner
.
poll_read
(
cx
&
mut
buf
[
.
.
max
]
)
)
?
;
*
this
.
limit
-
=
n
as
u64
;
Poll
:
:
Ready
(
Ok
(
n
)
)
}
}
impl
<
R
:
AsyncBufRead
>
AsyncBufRead
for
Take
<
R
>
{
fn
poll_fill_buf
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
&
[
u8
]
>
>
{
let
this
=
self
.
project
(
)
;
if
*
this
.
limit
=
=
0
{
return
Poll
:
:
Ready
(
Ok
(
&
[
]
)
)
;
}
let
buf
=
ready
!
(
this
.
inner
.
poll_fill_buf
(
cx
)
?
)
;
let
cap
=
cmp
:
:
min
(
buf
.
len
(
)
as
u64
*
this
.
limit
)
as
usize
;
Poll
:
:
Ready
(
Ok
(
&
buf
[
.
.
cap
]
)
)
}
fn
consume
(
self
:
Pin
<
&
mut
Self
>
amt
:
usize
)
{
let
this
=
self
.
project
(
)
;
let
amt
=
cmp
:
:
min
(
amt
as
u64
*
this
.
limit
)
as
usize
;
*
this
.
limit
-
=
amt
as
u64
;
this
.
inner
.
consume
(
amt
)
;
}
}
