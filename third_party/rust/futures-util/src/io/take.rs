use
futures_core
:
:
task
:
:
{
Context
Poll
}
;
#
[
cfg
(
feature
=
"
read
-
initializer
"
)
]
use
futures_io
:
:
Initializer
;
use
futures_io
:
:
{
AsyncRead
AsyncBufRead
}
;
use
pin_utils
:
:
{
unsafe_pinned
unsafe_unpinned
}
;
use
std
:
:
{
cmp
io
}
;
use
std
:
:
pin
:
:
Pin
;
#
[
derive
(
Debug
)
]
#
[
must_use
=
"
readers
do
nothing
unless
you
.
await
or
poll
them
"
]
pub
struct
Take
<
R
>
{
inner
:
R
limit_
:
u64
}
impl
<
R
:
Unpin
>
Unpin
for
Take
<
R
>
{
}
impl
<
R
:
AsyncRead
>
Take
<
R
>
{
unsafe_pinned
!
(
inner
:
R
)
;
unsafe_unpinned
!
(
limit_
:
u64
)
;
pub
(
super
)
fn
new
(
inner
:
R
limit
:
u64
)
-
>
Self
{
Self
{
inner
limit_
:
limit
}
}
pub
fn
limit
(
&
self
)
-
>
u64
{
self
.
limit_
}
pub
fn
set_limit
(
&
mut
self
limit
:
u64
)
{
self
.
limit_
=
limit
}
pub
fn
get_ref
(
&
self
)
-
>
&
R
{
&
self
.
inner
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
R
{
&
mut
self
.
inner
}
pub
fn
get_pin_mut
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Pin
<
&
mut
R
>
{
self
.
inner
(
)
}
pub
fn
into_inner
(
self
)
-
>
R
{
self
.
inner
}
}
impl
<
R
:
AsyncRead
>
AsyncRead
for
Take
<
R
>
{
fn
poll_read
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
buf
:
&
mut
[
u8
]
)
-
>
Poll
<
Result
<
usize
io
:
:
Error
>
>
{
if
self
.
limit_
=
=
0
{
return
Poll
:
:
Ready
(
Ok
(
0
)
)
;
}
let
max
=
std
:
:
cmp
:
:
min
(
buf
.
len
(
)
as
u64
self
.
limit_
)
as
usize
;
let
n
=
ready
!
(
self
.
as_mut
(
)
.
inner
(
)
.
poll_read
(
cx
&
mut
buf
[
.
.
max
]
)
)
?
;
*
self
.
as_mut
(
)
.
limit_
(
)
-
=
n
as
u64
;
Poll
:
:
Ready
(
Ok
(
n
)
)
}
#
[
cfg
(
feature
=
"
read
-
initializer
"
)
]
unsafe
fn
initializer
(
&
self
)
-
>
Initializer
{
self
.
inner
.
initializer
(
)
}
}
impl
<
R
:
AsyncBufRead
>
AsyncBufRead
for
Take
<
R
>
{
fn
poll_fill_buf
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
&
[
u8
]
>
>
{
let
Self
{
inner
limit_
}
=
unsafe
{
self
.
get_unchecked_mut
(
)
}
;
let
inner
=
unsafe
{
Pin
:
:
new_unchecked
(
inner
)
}
;
if
*
limit_
=
=
0
{
return
Poll
:
:
Ready
(
Ok
(
&
[
]
)
)
;
}
let
buf
=
ready
!
(
inner
.
poll_fill_buf
(
cx
)
?
)
;
let
cap
=
cmp
:
:
min
(
buf
.
len
(
)
as
u64
*
limit_
)
as
usize
;
Poll
:
:
Ready
(
Ok
(
&
buf
[
.
.
cap
]
)
)
}
fn
consume
(
mut
self
:
Pin
<
&
mut
Self
>
amt
:
usize
)
{
let
amt
=
cmp
:
:
min
(
amt
as
u64
self
.
limit_
)
as
usize
;
*
self
.
as_mut
(
)
.
limit_
(
)
-
=
amt
as
u64
;
self
.
inner
(
)
.
consume
(
amt
)
;
}
}
