use
futures_core
:
:
future
:
:
Future
;
use
futures_core
:
:
ready
;
use
futures_core
:
:
task
:
:
{
Context
Poll
}
;
use
futures_io
:
:
{
AsyncBufRead
AsyncWrite
}
;
use
std
:
:
io
;
use
std
:
:
pin
:
:
Pin
;
use
pin_project_lite
:
:
pin_project
;
pub
fn
copy_buf
<
R
W
>
(
reader
:
R
writer
:
&
mut
W
)
-
>
CopyBuf
<
'
_
R
W
>
where
R
:
AsyncBufRead
W
:
AsyncWrite
+
Unpin
+
?
Sized
{
CopyBuf
{
reader
writer
amt
:
0
}
}
pin_project
!
{
/
/
/
Future
for
the
[
copy_buf
(
)
]
function
.
#
[
derive
(
Debug
)
]
#
[
must_use
=
"
futures
do
nothing
unless
you
.
await
or
poll
them
"
]
pub
struct
CopyBuf
<
'
a
R
W
:
?
Sized
>
{
#
[
pin
]
reader
:
R
writer
:
&
'
a
mut
W
amt
:
u64
}
}
impl
<
R
W
>
Future
for
CopyBuf
<
'
_
R
W
>
where
R
:
AsyncBufRead
W
:
AsyncWrite
+
Unpin
+
?
Sized
{
type
Output
=
io
:
:
Result
<
u64
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
mut
this
=
self
.
project
(
)
;
loop
{
let
buffer
=
ready
!
(
this
.
reader
.
as_mut
(
)
.
poll_fill_buf
(
cx
)
)
?
;
if
buffer
.
is_empty
(
)
{
ready
!
(
Pin
:
:
new
(
&
mut
this
.
writer
)
.
poll_flush
(
cx
)
)
?
;
return
Poll
:
:
Ready
(
Ok
(
*
this
.
amt
)
)
;
}
let
i
=
ready
!
(
Pin
:
:
new
(
&
mut
this
.
writer
)
.
poll_write
(
cx
buffer
)
)
?
;
if
i
=
=
0
{
return
Poll
:
:
Ready
(
Err
(
io
:
:
ErrorKind
:
:
WriteZero
.
into
(
)
)
)
}
*
this
.
amt
+
=
i
as
u64
;
this
.
reader
.
as_mut
(
)
.
consume
(
i
)
;
}
}
}
