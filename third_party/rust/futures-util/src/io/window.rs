use
std
:
:
ops
:
:
{
Bound
Range
RangeBounds
}
;
#
[
derive
(
Debug
)
]
pub
struct
Window
<
T
>
{
inner
:
T
range
:
Range
<
usize
>
}
impl
<
T
:
AsRef
<
[
u8
]
>
>
Window
<
T
>
{
pub
fn
new
(
t
:
T
)
-
>
Self
{
Self
{
range
:
0
.
.
t
.
as_ref
(
)
.
len
(
)
inner
:
t
}
}
pub
fn
get_ref
(
&
self
)
-
>
&
T
{
&
self
.
inner
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
inner
}
pub
fn
into_inner
(
self
)
-
>
T
{
self
.
inner
}
pub
fn
start
(
&
self
)
-
>
usize
{
self
.
range
.
start
}
pub
fn
end
(
&
self
)
-
>
usize
{
self
.
range
.
end
}
pub
fn
set
<
R
:
RangeBounds
<
usize
>
>
(
&
mut
self
range
:
R
)
{
let
start
=
match
range
.
start_bound
(
)
{
Bound
:
:
Included
(
n
)
=
>
*
n
Bound
:
:
Excluded
(
n
)
=
>
*
n
+
1
Bound
:
:
Unbounded
=
>
0
}
;
let
end
=
match
range
.
end_bound
(
)
{
Bound
:
:
Included
(
n
)
=
>
*
n
+
1
Bound
:
:
Excluded
(
n
)
=
>
*
n
Bound
:
:
Unbounded
=
>
self
.
inner
.
as_ref
(
)
.
len
(
)
}
;
assert
!
(
end
<
=
self
.
inner
.
as_ref
(
)
.
len
(
)
)
;
assert
!
(
start
<
=
end
)
;
self
.
range
.
start
=
start
;
self
.
range
.
end
=
end
;
}
}
impl
<
T
:
AsRef
<
[
u8
]
>
>
AsRef
<
[
u8
]
>
for
Window
<
T
>
{
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
inner
.
as_ref
(
)
[
self
.
range
.
start
.
.
self
.
range
.
end
]
}
}
impl
<
T
:
AsMut
<
[
u8
]
>
>
AsMut
<
[
u8
]
>
for
Window
<
T
>
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
&
mut
self
.
inner
.
as_mut
(
)
[
self
.
range
.
start
.
.
self
.
range
.
end
]
}
}
