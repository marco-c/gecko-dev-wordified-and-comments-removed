extern
crate
winapi
;
extern
crate
kernel32
;
use
util
:
:
{
ensure_compatible_types
cstr_cow_from_bytes
}
;
use
std
:
:
ffi
:
:
{
OsStr
OsString
}
;
use
std
:
:
{
fmt
io
marker
mem
ptr
}
;
use
std
:
:
os
:
:
windows
:
:
ffi
:
:
{
OsStrExt
OsStringExt
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
ATOMIC_BOOL_INIT
Ordering
}
;
pub
struct
Library
(
winapi
:
:
HMODULE
)
;
unsafe
impl
Send
for
Library
{
}
unsafe
impl
Sync
for
Library
{
}
impl
Library
{
#
[
inline
]
pub
fn
new
<
P
:
AsRef
<
OsStr
>
>
(
filename
:
P
)
-
>
:
:
Result
<
Library
>
{
let
wide_filename
:
Vec
<
u16
>
=
filename
.
as_ref
(
)
.
encode_wide
(
)
.
chain
(
Some
(
0
)
)
.
collect
(
)
;
let
_guard
=
ErrorModeGuard
:
:
new
(
)
;
let
ret
=
with_get_last_error
(
|
|
{
let
handle
=
unsafe
{
kernel32
:
:
LoadLibraryW
(
wide_filename
.
as_ptr
(
)
)
}
;
if
handle
.
is_null
(
)
{
None
}
else
{
Some
(
Library
(
handle
)
)
}
}
)
.
map_err
(
|
e
|
e
.
unwrap_or_else
(
|
|
panic
!
(
"
LoadLibraryW
failed
but
GetLastError
did
not
report
the
error
"
)
)
)
;
drop
(
wide_filename
)
;
ret
}
pub
unsafe
fn
get
<
T
>
(
&
self
symbol
:
&
[
u8
]
)
-
>
:
:
Result
<
Symbol
<
T
>
>
{
ensure_compatible_types
:
:
<
T
winapi
:
:
FARPROC
>
(
)
;
let
symbol
=
try
!
(
cstr_cow_from_bytes
(
symbol
)
)
;
with_get_last_error
(
|
|
{
let
symbol
=
kernel32
:
:
GetProcAddress
(
self
.
0
symbol
.
as_ptr
(
)
)
;
if
symbol
.
is_null
(
)
{
None
}
else
{
Some
(
Symbol
{
pointer
:
symbol
pd
:
marker
:
:
PhantomData
}
)
}
}
)
.
map_err
(
|
e
|
e
.
unwrap_or_else
(
|
|
panic
!
(
"
GetProcAddress
failed
but
GetLastError
did
not
report
the
error
"
)
)
)
}
pub
unsafe
fn
get_ordinal
<
T
>
(
&
self
ordinal
:
winapi
:
:
WORD
)
-
>
:
:
Result
<
Symbol
<
T
>
>
{
ensure_compatible_types
:
:
<
T
winapi
:
:
FARPROC
>
(
)
;
with_get_last_error
(
|
|
{
let
ordinal
=
ordinal
as
usize
as
*
mut
_
;
let
symbol
=
kernel32
:
:
GetProcAddress
(
self
.
0
ordinal
)
;
if
symbol
.
is_null
(
)
{
None
}
else
{
Some
(
Symbol
{
pointer
:
symbol
pd
:
marker
:
:
PhantomData
}
)
}
}
)
.
map_err
(
|
e
|
e
.
unwrap_or_else
(
|
|
panic
!
(
"
GetProcAddress
failed
but
GetLastError
did
not
report
the
error
"
)
)
)
}
}
impl
Drop
for
Library
{
fn
drop
(
&
mut
self
)
{
with_get_last_error
(
|
|
{
if
unsafe
{
kernel32
:
:
FreeLibrary
(
self
.
0
)
=
=
0
}
{
None
}
else
{
Some
(
(
)
)
}
}
)
.
unwrap
(
)
}
}
impl
fmt
:
:
Debug
for
Library
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
unsafe
{
let
mut
buf
:
[
winapi
:
:
WCHAR
;
1024
]
=
mem
:
:
uninitialized
(
)
;
let
len
=
kernel32
:
:
GetModuleFileNameW
(
self
.
0
(
&
mut
buf
[
.
.
]
)
.
as_mut_ptr
(
)
1024
)
as
usize
;
if
len
=
=
0
{
f
.
write_str
(
&
format
!
(
"
Library
{
:
p
}
"
self
.
0
)
)
}
else
{
let
string
:
OsString
=
OsString
:
:
from_wide
(
&
buf
[
.
.
len
]
)
;
f
.
write_str
(
&
format
!
(
"
Library
{
:
p
}
from
{
:
?
}
"
self
.
0
string
)
)
}
}
}
}
pub
struct
Symbol
<
T
>
{
pointer
:
winapi
:
:
FARPROC
pd
:
marker
:
:
PhantomData
<
T
>
}
unsafe
impl
<
T
:
Send
>
Send
for
Symbol
<
T
>
{
}
unsafe
impl
<
T
:
Sync
>
Sync
for
Symbol
<
T
>
{
}
impl
<
T
>
Clone
for
Symbol
<
T
>
{
fn
clone
(
&
self
)
-
>
Symbol
<
T
>
{
Symbol
{
.
.
*
self
}
}
}
impl
<
T
>
:
:
std
:
:
ops
:
:
Deref
for
Symbol
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
mem
:
:
transmute
(
&
self
.
pointer
)
}
}
}
impl
<
T
>
fmt
:
:
Debug
for
Symbol
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
&
format
!
(
"
Symbol
{
:
p
}
"
self
.
pointer
)
)
}
}
static
USE_ERRORMODE
:
AtomicBool
=
ATOMIC_BOOL_INIT
;
struct
ErrorModeGuard
(
winapi
:
:
DWORD
)
;
impl
ErrorModeGuard
{
fn
new
(
)
-
>
ErrorModeGuard
{
let
mut
ret
=
ErrorModeGuard
(
0
)
;
if
!
USE_ERRORMODE
.
load
(
Ordering
:
:
Acquire
)
{
if
unsafe
{
kernel32
:
:
SetThreadErrorMode
(
1
&
mut
ret
.
0
)
=
=
0
&
&
kernel32
:
:
GetLastError
(
)
=
=
winapi
:
:
ERROR_CALL_NOT_IMPLEMENTED
}
{
USE_ERRORMODE
.
store
(
true
Ordering
:
:
Release
)
;
}
else
{
return
ret
;
}
}
ret
.
0
=
unsafe
{
kernel32
:
:
SetErrorMode
(
1
)
}
;
ret
}
}
impl
Drop
for
ErrorModeGuard
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
!
USE_ERRORMODE
.
load
(
Ordering
:
:
Relaxed
)
{
kernel32
:
:
SetThreadErrorMode
(
self
.
0
ptr
:
:
null_mut
(
)
)
;
}
else
{
kernel32
:
:
SetErrorMode
(
self
.
0
)
;
}
}
}
}
fn
with_get_last_error
<
T
F
>
(
closure
:
F
)
-
>
Result
<
T
Option
<
io
:
:
Error
>
>
where
F
:
FnOnce
(
)
-
>
Option
<
T
>
{
closure
(
)
.
ok_or_else
(
|
|
{
let
error
=
unsafe
{
kernel32
:
:
GetLastError
(
)
}
;
if
error
=
=
0
{
None
}
else
{
Some
(
io
:
:
Error
:
:
from_raw_os_error
(
error
as
i32
)
)
}
}
)
}
#
[
test
]
fn
works_getlasterror
(
)
{
let
lib
=
Library
:
:
new
(
"
kernel32
.
dll
"
)
.
unwrap
(
)
;
let
gle
:
Symbol
<
unsafe
extern
"
system
"
fn
(
)
-
>
winapi
:
:
DWORD
>
=
unsafe
{
lib
.
get
(
b
"
GetLastError
"
)
.
unwrap
(
)
}
;
unsafe
{
kernel32
:
:
SetLastError
(
42
)
;
assert_eq
!
(
kernel32
:
:
GetLastError
(
)
gle
(
)
)
}
}
#
[
test
]
fn
works_getlasterror0
(
)
{
let
lib
=
Library
:
:
new
(
"
kernel32
.
dll
"
)
.
unwrap
(
)
;
let
gle
:
Symbol
<
unsafe
extern
"
system
"
fn
(
)
-
>
winapi
:
:
DWORD
>
=
unsafe
{
lib
.
get
(
b
"
GetLastError
\
0
"
)
.
unwrap
(
)
}
;
unsafe
{
kernel32
:
:
SetLastError
(
42
)
;
assert_eq
!
(
kernel32
:
:
GetLastError
(
)
gle
(
)
)
}
}
