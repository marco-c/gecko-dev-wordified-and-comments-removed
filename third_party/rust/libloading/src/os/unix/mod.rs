#
[
cfg
(
all
(
libloading_docs
not
(
unix
)
)
)
]
mod
unix_imports
{
}
#
[
cfg
(
any
(
not
(
libloading_docs
)
unix
)
)
]
mod
unix_imports
{
pub
(
super
)
use
std
:
:
os
:
:
unix
:
:
ffi
:
:
OsStrExt
;
}
pub
use
self
:
:
consts
:
:
*
;
use
self
:
:
unix_imports
:
:
*
;
use
std
:
:
ffi
:
:
{
CStr
OsStr
}
;
use
std
:
:
os
:
:
raw
;
use
std
:
:
{
fmt
marker
mem
ptr
}
;
use
util
:
:
{
cstr_cow_from_bytes
ensure_compatible_types
}
;
mod
consts
;
pub
fn
with_dlerror
<
T
F
Error
>
(
closure
:
F
error
:
fn
(
&
CStr
)
-
>
Error
)
-
>
Result
<
T
Option
<
Error
>
>
where
F
:
FnOnce
(
)
-
>
Option
<
T
>
{
closure
(
)
.
ok_or_else
(
|
|
unsafe
{
let
dlerror_str
=
dlerror
(
)
;
if
dlerror_str
.
is_null
(
)
{
None
}
else
{
Some
(
error
(
CStr
:
:
from_ptr
(
dlerror_str
)
)
)
}
}
)
}
pub
struct
Library
{
handle
:
*
mut
raw
:
:
c_void
}
unsafe
impl
Send
for
Library
{
}
unsafe
impl
Sync
for
Library
{
}
impl
Library
{
#
[
inline
]
pub
unsafe
fn
new
<
P
:
AsRef
<
OsStr
>
>
(
filename
:
P
)
-
>
Result
<
Library
crate
:
:
Error
>
{
Library
:
:
open
(
Some
(
filename
)
RTLD_LAZY
|
RTLD_LOCAL
)
}
#
[
inline
]
pub
fn
this
(
)
-
>
Library
{
unsafe
{
Library
:
:
open
(
None
:
:
<
&
OsStr
>
RTLD_LAZY
|
RTLD_LOCAL
)
.
expect
(
"
this
should
never
fail
"
)
}
}
pub
unsafe
fn
open
<
P
>
(
filename
:
Option
<
P
>
flags
:
raw
:
:
c_int
)
-
>
Result
<
Library
crate
:
:
Error
>
where
P
:
AsRef
<
OsStr
>
{
let
filename
=
match
filename
{
None
=
>
None
Some
(
ref
f
)
=
>
Some
(
cstr_cow_from_bytes
(
f
.
as_ref
(
)
.
as_bytes
(
)
)
?
)
}
;
with_dlerror
(
move
|
|
{
let
result
=
dlopen
(
match
filename
{
None
=
>
ptr
:
:
null
(
)
Some
(
ref
f
)
=
>
f
.
as_ptr
(
)
}
flags
)
;
drop
(
filename
)
;
if
result
.
is_null
(
)
{
None
}
else
{
Some
(
Library
{
handle
:
result
}
)
}
}
|
desc
|
crate
:
:
Error
:
:
DlOpen
{
desc
:
desc
.
into
(
)
}
)
.
map_err
(
|
e
|
e
.
unwrap_or
(
crate
:
:
Error
:
:
DlOpenUnknown
)
)
}
unsafe
fn
get_impl
<
T
F
>
(
&
self
symbol
:
&
[
u8
]
on_null
:
F
)
-
>
Result
<
Symbol
<
T
>
crate
:
:
Error
>
where
F
:
FnOnce
(
)
-
>
Result
<
Symbol
<
T
>
crate
:
:
Error
>
{
ensure_compatible_types
:
:
<
T
*
mut
raw
:
:
c_void
>
(
)
?
;
let
symbol
=
cstr_cow_from_bytes
(
symbol
)
?
;
let
result
=
with_dlerror
(
|
|
{
dlerror
(
)
;
let
symbol
=
dlsym
(
self
.
handle
symbol
.
as_ptr
(
)
)
;
if
symbol
.
is_null
(
)
{
None
}
else
{
Some
(
Symbol
{
pointer
:
symbol
pd
:
marker
:
:
PhantomData
}
)
}
}
|
desc
|
crate
:
:
Error
:
:
DlSym
{
desc
:
desc
.
into
(
)
}
)
;
match
result
{
Err
(
None
)
=
>
on_null
(
)
Err
(
Some
(
e
)
)
=
>
Err
(
e
)
Ok
(
x
)
=
>
Ok
(
x
)
}
}
#
[
inline
(
always
)
]
pub
unsafe
fn
get
<
T
>
(
&
self
symbol
:
&
[
u8
]
)
-
>
Result
<
Symbol
<
T
>
crate
:
:
Error
>
{
extern
crate
cfg_if
;
cfg_if
:
:
cfg_if
!
{
/
/
These
targets
are
known
to
have
MT
-
safe
dlerror
.
if
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
target_os
=
"
openbsd
"
target_os
=
"
macos
"
target_os
=
"
ios
"
target_os
=
"
solaris
"
target_os
=
"
illumos
"
target_os
=
"
redox
"
target_os
=
"
fuchsia
"
)
)
]
{
self
.
get_singlethreaded
(
symbol
)
}
else
{
self
.
get_impl
(
symbol
|
|
Err
(
crate
:
:
Error
:
:
DlSymUnknown
)
)
}
}
}
#
[
inline
(
always
)
]
pub
unsafe
fn
get_singlethreaded
<
T
>
(
&
self
symbol
:
&
[
u8
]
)
-
>
Result
<
Symbol
<
T
>
crate
:
:
Error
>
{
self
.
get_impl
(
symbol
|
|
{
Ok
(
Symbol
{
pointer
:
ptr
:
:
null_mut
(
)
pd
:
marker
:
:
PhantomData
}
)
}
)
}
pub
fn
into_raw
(
self
)
-
>
*
mut
raw
:
:
c_void
{
let
handle
=
self
.
handle
;
mem
:
:
forget
(
self
)
;
handle
}
pub
unsafe
fn
from_raw
(
handle
:
*
mut
raw
:
:
c_void
)
-
>
Library
{
Library
{
handle
}
}
pub
fn
close
(
self
)
-
>
Result
<
(
)
crate
:
:
Error
>
{
let
result
=
with_dlerror
(
|
|
{
if
unsafe
{
dlclose
(
self
.
handle
)
}
=
=
0
{
Some
(
(
)
)
}
else
{
None
}
}
|
desc
|
crate
:
:
Error
:
:
DlClose
{
desc
:
desc
.
into
(
)
}
)
.
map_err
(
|
e
|
e
.
unwrap_or
(
crate
:
:
Error
:
:
DlCloseUnknown
)
)
;
std
:
:
mem
:
:
forget
(
self
)
;
result
}
}
impl
Drop
for
Library
{
fn
drop
(
&
mut
self
)
{
unsafe
{
dlclose
(
self
.
handle
)
;
}
}
}
impl
fmt
:
:
Debug
for
Library
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
&
format
!
(
"
Library
{
:
p
}
"
self
.
handle
)
)
}
}
pub
struct
Symbol
<
T
>
{
pointer
:
*
mut
raw
:
:
c_void
pd
:
marker
:
:
PhantomData
<
T
>
}
impl
<
T
>
Symbol
<
T
>
{
pub
fn
into_raw
(
self
)
-
>
*
mut
raw
:
:
c_void
{
self
.
pointer
}
pub
fn
as_raw_ptr
(
self
)
-
>
*
mut
raw
:
:
c_void
{
self
.
pointer
}
}
impl
<
T
>
Symbol
<
Option
<
T
>
>
{
pub
fn
lift_option
(
self
)
-
>
Option
<
Symbol
<
T
>
>
{
if
self
.
pointer
.
is_null
(
)
{
None
}
else
{
Some
(
Symbol
{
pointer
:
self
.
pointer
pd
:
marker
:
:
PhantomData
}
)
}
}
}
unsafe
impl
<
T
:
Send
>
Send
for
Symbol
<
T
>
{
}
unsafe
impl
<
T
:
Sync
>
Sync
for
Symbol
<
T
>
{
}
impl
<
T
>
Clone
for
Symbol
<
T
>
{
fn
clone
(
&
self
)
-
>
Symbol
<
T
>
{
Symbol
{
.
.
*
self
}
}
}
impl
<
T
>
:
:
std
:
:
ops
:
:
Deref
for
Symbol
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
&
*
(
&
self
.
pointer
as
*
const
*
mut
_
as
*
const
T
)
}
}
}
impl
<
T
>
fmt
:
:
Debug
for
Symbol
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
unsafe
{
let
mut
info
=
mem
:
:
MaybeUninit
:
:
<
DlInfo
>
:
:
uninit
(
)
;
if
dladdr
(
self
.
pointer
info
.
as_mut_ptr
(
)
)
!
=
0
{
let
info
=
info
.
assume_init
(
)
;
if
info
.
dli_sname
.
is_null
(
)
{
f
.
write_str
(
&
format
!
(
"
Symbol
{
:
p
}
from
{
:
?
}
"
self
.
pointer
CStr
:
:
from_ptr
(
info
.
dli_fname
)
)
)
}
else
{
f
.
write_str
(
&
format
!
(
"
Symbol
{
:
?
}
{
:
p
}
from
{
:
?
}
"
CStr
:
:
from_ptr
(
info
.
dli_sname
)
self
.
pointer
CStr
:
:
from_ptr
(
info
.
dli_fname
)
)
)
}
}
else
{
f
.
write_str
(
&
format
!
(
"
Symbol
{
:
p
}
"
self
.
pointer
)
)
}
}
}
}
#
[
cfg_attr
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
link
(
name
=
"
dl
"
)
)
]
#
[
cfg_attr
(
any
(
target_os
=
"
freebsd
"
target_os
=
"
dragonfly
"
)
link
(
name
=
"
c
"
)
)
]
extern
"
C
"
{
fn
dlopen
(
filename
:
*
const
raw
:
:
c_char
flags
:
raw
:
:
c_int
)
-
>
*
mut
raw
:
:
c_void
;
fn
dlclose
(
handle
:
*
mut
raw
:
:
c_void
)
-
>
raw
:
:
c_int
;
fn
dlsym
(
handle
:
*
mut
raw
:
:
c_void
symbol
:
*
const
raw
:
:
c_char
)
-
>
*
mut
raw
:
:
c_void
;
fn
dlerror
(
)
-
>
*
mut
raw
:
:
c_char
;
fn
dladdr
(
addr
:
*
mut
raw
:
:
c_void
info
:
*
mut
DlInfo
)
-
>
raw
:
:
c_int
;
}
#
[
repr
(
C
)
]
struct
DlInfo
{
dli_fname
:
*
const
raw
:
:
c_char
dli_fbase
:
*
mut
raw
:
:
c_void
dli_sname
:
*
const
raw
:
:
c_char
dli_saddr
:
*
mut
raw
:
:
c_void
}
