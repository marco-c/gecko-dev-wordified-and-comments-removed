#
[
cfg
(
not
(
feature
=
"
portable
-
atomic
"
)
)
]
use
core
:
:
sync
:
:
atomic
;
#
[
cfg
(
feature
=
"
portable
-
atomic
"
)
]
use
portable_atomic
as
atomic
;
use
atomic
:
:
{
AtomicPtr
AtomicUsize
Ordering
}
;
use
core
:
:
cell
:
:
UnsafeCell
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
num
:
:
NonZeroUsize
;
use
core
:
:
ptr
;
#
[
derive
(
Default
Debug
)
]
pub
struct
OnceNonZeroUsize
{
inner
:
AtomicUsize
}
impl
OnceNonZeroUsize
{
#
[
inline
]
pub
const
fn
new
(
)
-
>
Self
{
Self
{
inner
:
AtomicUsize
:
:
new
(
0
)
}
}
#
[
inline
]
pub
fn
get
(
&
self
)
-
>
Option
<
NonZeroUsize
>
{
let
val
=
self
.
inner
.
load
(
Ordering
:
:
Acquire
)
;
NonZeroUsize
:
:
new
(
val
)
}
pub
unsafe
fn
get_unchecked
(
&
self
)
-
>
NonZeroUsize
{
#
[
inline
(
always
)
]
fn
as_const_ptr
(
r
:
&
AtomicUsize
)
-
>
*
const
usize
{
use
core
:
:
mem
:
:
align_of
;
let
p
:
*
const
AtomicUsize
=
r
;
const
_ALIGNMENT_COMPATIBLE
:
(
)
=
assert
!
(
align_of
:
:
<
AtomicUsize
>
(
)
%
align_of
:
:
<
usize
>
(
)
=
=
0
)
;
p
.
cast
:
:
<
usize
>
(
)
}
let
p
=
as_const_ptr
(
&
self
.
inner
)
;
let
val
=
unsafe
{
p
.
read
(
)
}
;
unsafe
{
NonZeroUsize
:
:
new_unchecked
(
val
)
}
}
#
[
inline
]
pub
fn
set
(
&
self
value
:
NonZeroUsize
)
-
>
Result
<
(
)
(
)
>
{
match
self
.
compare_exchange
(
value
)
{
Ok
(
_
)
=
>
Ok
(
(
)
)
Err
(
_
)
=
>
Err
(
(
)
)
}
}
pub
fn
get_or_init
<
F
>
(
&
self
f
:
F
)
-
>
NonZeroUsize
where
F
:
FnOnce
(
)
-
>
NonZeroUsize
{
enum
Void
{
}
match
self
.
get_or_try_init
(
|
|
Ok
:
:
<
NonZeroUsize
Void
>
(
f
(
)
)
)
{
Ok
(
val
)
=
>
val
Err
(
void
)
=
>
match
void
{
}
}
}
pub
fn
get_or_try_init
<
F
E
>
(
&
self
f
:
F
)
-
>
Result
<
NonZeroUsize
E
>
where
F
:
FnOnce
(
)
-
>
Result
<
NonZeroUsize
E
>
{
match
self
.
get
(
)
{
Some
(
it
)
=
>
Ok
(
it
)
None
=
>
self
.
init
(
f
)
}
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
init
<
E
>
(
&
self
f
:
impl
FnOnce
(
)
-
>
Result
<
NonZeroUsize
E
>
)
-
>
Result
<
NonZeroUsize
E
>
{
let
nz
=
f
(
)
?
;
let
mut
val
=
nz
.
get
(
)
;
if
let
Err
(
old
)
=
self
.
compare_exchange
(
nz
)
{
val
=
old
;
}
Ok
(
unsafe
{
NonZeroUsize
:
:
new_unchecked
(
val
)
}
)
}
#
[
inline
(
always
)
]
fn
compare_exchange
(
&
self
val
:
NonZeroUsize
)
-
>
Result
<
usize
usize
>
{
self
.
inner
.
compare_exchange
(
0
val
.
get
(
)
Ordering
:
:
Release
Ordering
:
:
Acquire
)
}
}
#
[
derive
(
Default
Debug
)
]
pub
struct
OnceBool
{
inner
:
OnceNonZeroUsize
}
impl
OnceBool
{
#
[
inline
]
pub
const
fn
new
(
)
-
>
Self
{
Self
{
inner
:
OnceNonZeroUsize
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
get
(
&
self
)
-
>
Option
<
bool
>
{
self
.
inner
.
get
(
)
.
map
(
Self
:
:
from_usize
)
}
#
[
inline
]
pub
fn
set
(
&
self
value
:
bool
)
-
>
Result
<
(
)
(
)
>
{
self
.
inner
.
set
(
Self
:
:
to_usize
(
value
)
)
}
pub
fn
get_or_init
<
F
>
(
&
self
f
:
F
)
-
>
bool
where
F
:
FnOnce
(
)
-
>
bool
{
Self
:
:
from_usize
(
self
.
inner
.
get_or_init
(
|
|
Self
:
:
to_usize
(
f
(
)
)
)
)
}
pub
fn
get_or_try_init
<
F
E
>
(
&
self
f
:
F
)
-
>
Result
<
bool
E
>
where
F
:
FnOnce
(
)
-
>
Result
<
bool
E
>
{
self
.
inner
.
get_or_try_init
(
|
|
f
(
)
.
map
(
Self
:
:
to_usize
)
)
.
map
(
Self
:
:
from_usize
)
}
#
[
inline
]
fn
from_usize
(
value
:
NonZeroUsize
)
-
>
bool
{
value
.
get
(
)
=
=
1
}
#
[
inline
]
fn
to_usize
(
value
:
bool
)
-
>
NonZeroUsize
{
unsafe
{
NonZeroUsize
:
:
new_unchecked
(
if
value
{
1
}
else
{
2
}
)
}
}
}
pub
struct
OnceRef
<
'
a
T
>
{
inner
:
AtomicPtr
<
T
>
ghost
:
PhantomData
<
UnsafeCell
<
&
'
a
T
>
>
}
unsafe
impl
<
'
a
T
:
Sync
>
Sync
for
OnceRef
<
'
a
T
>
{
}
impl
<
'
a
T
>
core
:
:
fmt
:
:
Debug
for
OnceRef
<
'
a
T
>
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
OnceRef
(
{
:
?
}
)
"
self
.
inner
)
}
}
impl
<
'
a
T
>
Default
for
OnceRef
<
'
a
T
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
'
a
T
>
OnceRef
<
'
a
T
>
{
pub
const
fn
new
(
)
-
>
Self
{
Self
{
inner
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
ghost
:
PhantomData
}
}
pub
fn
get
(
&
self
)
-
>
Option
<
&
'
a
T
>
{
let
ptr
=
self
.
inner
.
load
(
Ordering
:
:
Acquire
)
;
unsafe
{
ptr
.
as_ref
(
)
}
}
pub
fn
set
(
&
self
value
:
&
'
a
T
)
-
>
Result
<
(
)
(
)
>
{
match
self
.
compare_exchange
(
value
)
{
Ok
(
_
)
=
>
Ok
(
(
)
)
Err
(
_
)
=
>
Err
(
(
)
)
}
}
pub
fn
get_or_init
<
F
>
(
&
self
f
:
F
)
-
>
&
'
a
T
where
F
:
FnOnce
(
)
-
>
&
'
a
T
{
enum
Void
{
}
match
self
.
get_or_try_init
(
|
|
Ok
:
:
<
&
'
a
T
Void
>
(
f
(
)
)
)
{
Ok
(
val
)
=
>
val
Err
(
void
)
=
>
match
void
{
}
}
}
pub
fn
get_or_try_init
<
F
E
>
(
&
self
f
:
F
)
-
>
Result
<
&
'
a
T
E
>
where
F
:
FnOnce
(
)
-
>
Result
<
&
'
a
T
E
>
{
match
self
.
get
(
)
{
Some
(
val
)
=
>
Ok
(
val
)
None
=
>
self
.
init
(
f
)
}
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
init
<
E
>
(
&
self
f
:
impl
FnOnce
(
)
-
>
Result
<
&
'
a
T
E
>
)
-
>
Result
<
&
'
a
T
E
>
{
let
mut
value
:
&
'
a
T
=
f
(
)
?
;
if
let
Err
(
old
)
=
self
.
compare_exchange
(
value
)
{
value
=
unsafe
{
&
*
old
}
;
}
Ok
(
value
)
}
#
[
inline
(
always
)
]
fn
compare_exchange
(
&
self
value
:
&
'
a
T
)
-
>
Result
<
(
)
*
const
T
>
{
self
.
inner
.
compare_exchange
(
ptr
:
:
null_mut
(
)
<
*
const
T
>
:
:
cast_mut
(
value
)
Ordering
:
:
Release
Ordering
:
:
Acquire
)
.
map
(
|
_
:
*
mut
T
|
(
)
)
.
map_err
(
<
*
mut
T
>
:
:
cast_const
)
}
fn
_dummy
(
)
{
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
use
self
:
:
once_box
:
:
OnceBox
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
once_box
{
use
super
:
:
atomic
:
:
{
AtomicPtr
Ordering
}
;
use
core
:
:
{
marker
:
:
PhantomData
ptr
}
;
use
alloc
:
:
boxed
:
:
Box
;
pub
struct
OnceBox
<
T
>
{
inner
:
AtomicPtr
<
T
>
ghost
:
PhantomData
<
Option
<
Box
<
T
>
>
>
}
impl
<
T
>
core
:
:
fmt
:
:
Debug
for
OnceBox
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
OnceBox
(
{
:
?
}
)
"
self
.
inner
.
load
(
Ordering
:
:
Relaxed
)
)
}
}
impl
<
T
>
Default
for
OnceBox
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
T
>
Drop
for
OnceBox
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
ptr
=
*
self
.
inner
.
get_mut
(
)
;
if
!
ptr
.
is_null
(
)
{
drop
(
unsafe
{
Box
:
:
from_raw
(
ptr
)
}
)
}
}
}
impl
<
T
>
OnceBox
<
T
>
{
pub
const
fn
new
(
)
-
>
Self
{
Self
{
inner
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
ghost
:
PhantomData
}
}
pub
fn
with_value
(
value
:
Box
<
T
>
)
-
>
Self
{
Self
{
inner
:
AtomicPtr
:
:
new
(
Box
:
:
into_raw
(
value
)
)
ghost
:
PhantomData
}
}
pub
fn
get
(
&
self
)
-
>
Option
<
&
T
>
{
let
ptr
=
self
.
inner
.
load
(
Ordering
:
:
Acquire
)
;
if
ptr
.
is_null
(
)
{
return
None
;
}
Some
(
unsafe
{
&
*
ptr
}
)
}
pub
fn
set
(
&
self
value
:
Box
<
T
>
)
-
>
Result
<
(
)
Box
<
T
>
>
{
let
ptr
=
Box
:
:
into_raw
(
value
)
;
let
exchange
=
self
.
inner
.
compare_exchange
(
ptr
:
:
null_mut
(
)
ptr
Ordering
:
:
Release
Ordering
:
:
Acquire
)
;
if
exchange
.
is_err
(
)
{
let
value
=
unsafe
{
Box
:
:
from_raw
(
ptr
)
}
;
return
Err
(
value
)
;
}
Ok
(
(
)
)
}
pub
fn
get_or_init
<
F
>
(
&
self
f
:
F
)
-
>
&
T
where
F
:
FnOnce
(
)
-
>
Box
<
T
>
{
enum
Void
{
}
match
self
.
get_or_try_init
(
|
|
Ok
:
:
<
Box
<
T
>
Void
>
(
f
(
)
)
)
{
Ok
(
val
)
=
>
val
Err
(
void
)
=
>
match
void
{
}
}
}
pub
fn
get_or_try_init
<
F
E
>
(
&
self
f
:
F
)
-
>
Result
<
&
T
E
>
where
F
:
FnOnce
(
)
-
>
Result
<
Box
<
T
>
E
>
{
match
self
.
get
(
)
{
Some
(
val
)
=
>
Ok
(
val
)
None
=
>
self
.
init
(
f
)
}
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
init
<
E
>
(
&
self
f
:
impl
FnOnce
(
)
-
>
Result
<
Box
<
T
>
E
>
)
-
>
Result
<
&
T
E
>
{
let
val
=
f
(
)
?
;
let
mut
ptr
=
Box
:
:
into_raw
(
val
)
;
let
exchange
=
self
.
inner
.
compare_exchange
(
ptr
:
:
null_mut
(
)
ptr
Ordering
:
:
Release
Ordering
:
:
Acquire
)
;
if
let
Err
(
old
)
=
exchange
{
drop
(
unsafe
{
Box
:
:
from_raw
(
ptr
)
}
)
;
ptr
=
old
;
}
Ok
(
unsafe
{
&
*
ptr
}
)
}
}
unsafe
impl
<
T
:
Sync
+
Send
>
Sync
for
OnceBox
<
T
>
{
}
impl
<
T
:
Clone
>
Clone
for
OnceBox
<
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
match
self
.
get
(
)
{
Some
(
value
)
=
>
OnceBox
:
:
with_value
(
Box
:
:
new
(
value
.
clone
(
)
)
)
None
=
>
OnceBox
:
:
new
(
)
}
}
}
fn
_dummy
(
)
{
}
}
