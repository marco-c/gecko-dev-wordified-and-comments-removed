use
core
:
:
cmp
;
use
core
:
:
hash
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
;
use
core
:
:
ptr
;
use
core
:
:
slice
;
#
[
derive
(
Debug
Clone
Copy
Default
)
]
pub
struct
SipHasher13
{
hasher
:
Hasher
<
Sip13Rounds
>
}
#
[
derive
(
Debug
Clone
Copy
Default
)
]
pub
struct
SipHasher24
{
hasher
:
Hasher
<
Sip24Rounds
>
}
#
[
derive
(
Debug
Clone
Copy
Default
)
]
pub
struct
SipHasher
(
SipHasher24
)
;
#
[
derive
(
Debug
Clone
Copy
)
]
struct
Hasher
<
S
:
Sip
>
{
k0
:
u64
k1
:
u64
length
:
usize
state
:
State
tail
:
u64
ntail
:
usize
_marker
:
PhantomData
<
S
>
}
#
[
derive
(
Debug
Clone
Copy
)
]
struct
State
{
v0
:
u64
v2
:
u64
v1
:
u64
v3
:
u64
}
macro_rules
!
compress
{
(
state
:
expr
)
=
>
(
{
compress
!
(
state
.
v0
state
.
v1
state
.
v2
state
.
v3
)
}
)
;
(
v0
:
expr
v1
:
expr
v2
:
expr
v3
:
expr
)
=
>
(
{
v0
=
v0
.
wrapping_add
(
v1
)
;
v1
=
v1
.
rotate_left
(
13
)
;
v1
^
=
v0
;
v0
=
v0
.
rotate_left
(
32
)
;
v2
=
v2
.
wrapping_add
(
v3
)
;
v3
=
v3
.
rotate_left
(
16
)
;
v3
^
=
v2
;
v0
=
v0
.
wrapping_add
(
v3
)
;
v3
=
v3
.
rotate_left
(
21
)
;
v3
^
=
v0
;
v2
=
v2
.
wrapping_add
(
v1
)
;
v1
=
v1
.
rotate_left
(
17
)
;
v1
^
=
v2
;
v2
=
v2
.
rotate_left
(
32
)
;
}
)
;
}
macro_rules
!
load_int_le
{
(
buf
:
expr
i
:
expr
int_ty
:
ident
)
=
>
(
{
debug_assert
!
(
i
+
mem
:
:
size_of
:
:
<
int_ty
>
(
)
<
=
buf
.
len
(
)
)
;
let
mut
data
=
0
as
int_ty
;
ptr
:
:
copy_nonoverlapping
(
buf
.
get_unchecked
(
i
)
&
mut
data
as
*
mut
_
as
*
mut
u8
mem
:
:
size_of
:
:
<
int_ty
>
(
)
)
;
data
.
to_le
(
)
}
)
;
}
#
[
inline
]
unsafe
fn
u8to64_le
(
buf
:
&
[
u8
]
start
:
usize
len
:
usize
)
-
>
u64
{
debug_assert
!
(
len
<
8
)
;
let
mut
i
=
0
;
let
mut
out
=
0
;
if
i
+
3
<
len
{
out
=
load_int_le
!
(
buf
start
+
i
u32
)
as
u64
;
i
+
=
4
;
}
if
i
+
1
<
len
{
out
|
=
(
load_int_le
!
(
buf
start
+
i
u16
)
as
u64
)
<
<
(
i
*
8
)
;
i
+
=
2
}
if
i
<
len
{
out
|
=
(
*
buf
.
get_unchecked
(
start
+
i
)
as
u64
)
<
<
(
i
*
8
)
;
i
+
=
1
;
}
debug_assert_eq
!
(
i
len
)
;
out
}
impl
SipHasher
{
#
[
inline
]
pub
fn
new
(
)
-
>
SipHasher
{
SipHasher
:
:
new_with_keys
(
0
0
)
}
#
[
inline
]
pub
fn
new_with_keys
(
key0
:
u64
key1
:
u64
)
-
>
SipHasher
{
SipHasher
(
SipHasher24
:
:
new_with_keys
(
key0
key1
)
)
}
}
impl
SipHasher13
{
#
[
inline
]
pub
fn
new
(
)
-
>
SipHasher13
{
SipHasher13
:
:
new_with_keys
(
0
0
)
}
#
[
inline
]
pub
fn
new_with_keys
(
key0
:
u64
key1
:
u64
)
-
>
SipHasher13
{
SipHasher13
{
hasher
:
Hasher
:
:
new_with_keys
(
key0
key1
)
}
}
}
impl
SipHasher24
{
#
[
inline
]
pub
fn
new
(
)
-
>
SipHasher24
{
SipHasher24
:
:
new_with_keys
(
0
0
)
}
#
[
inline
]
pub
fn
new_with_keys
(
key0
:
u64
key1
:
u64
)
-
>
SipHasher24
{
SipHasher24
{
hasher
:
Hasher
:
:
new_with_keys
(
key0
key1
)
}
}
}
impl
<
S
:
Sip
>
Hasher
<
S
>
{
#
[
inline
]
fn
new_with_keys
(
key0
:
u64
key1
:
u64
)
-
>
Hasher
<
S
>
{
let
mut
state
=
Hasher
{
k0
:
key0
k1
:
key1
length
:
0
state
:
State
{
v0
:
0
v1
:
0
v2
:
0
v3
:
0
}
tail
:
0
ntail
:
0
_marker
:
PhantomData
}
;
state
.
reset
(
)
;
state
}
#
[
inline
]
fn
reset
(
&
mut
self
)
{
self
.
length
=
0
;
self
.
state
.
v0
=
self
.
k0
^
0x736f6d6570736575
;
self
.
state
.
v1
=
self
.
k1
^
0x646f72616e646f6d
;
self
.
state
.
v2
=
self
.
k0
^
0x6c7967656e657261
;
self
.
state
.
v3
=
self
.
k1
^
0x7465646279746573
;
self
.
ntail
=
0
;
}
#
[
inline
(
always
)
]
fn
short_write
(
&
mut
self
msg
:
&
[
u8
]
)
{
debug_assert
!
(
msg
.
len
(
)
<
=
8
)
;
let
length
=
msg
.
len
(
)
;
self
.
length
+
=
length
;
let
needed
=
8
-
self
.
ntail
;
let
fill
=
cmp
:
:
min
(
length
needed
)
;
if
fill
=
=
8
{
self
.
tail
=
unsafe
{
load_int_le
!
(
msg
0
u64
)
}
;
}
else
{
self
.
tail
|
=
unsafe
{
u8to64_le
(
msg
0
fill
)
}
<
<
(
8
*
self
.
ntail
)
;
if
length
<
needed
{
self
.
ntail
+
=
length
;
return
;
}
}
self
.
state
.
v3
^
=
self
.
tail
;
S
:
:
c_rounds
(
&
mut
self
.
state
)
;
self
.
state
.
v0
^
=
self
.
tail
;
self
.
ntail
=
length
-
needed
;
self
.
tail
=
unsafe
{
u8to64_le
(
msg
needed
self
.
ntail
)
}
;
}
}
impl
hash
:
:
Hasher
for
SipHasher
{
#
[
inline
]
fn
write
(
&
mut
self
msg
:
&
[
u8
]
)
{
self
.
0
.
write
(
msg
)
}
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
self
.
0
.
finish
(
)
}
}
impl
hash
:
:
Hasher
for
SipHasher13
{
#
[
inline
]
fn
write
(
&
mut
self
msg
:
&
[
u8
]
)
{
self
.
hasher
.
write
(
msg
)
}
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
self
.
hasher
.
finish
(
)
}
}
impl
hash
:
:
Hasher
for
SipHasher24
{
#
[
inline
]
fn
write
(
&
mut
self
msg
:
&
[
u8
]
)
{
self
.
hasher
.
write
(
msg
)
}
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
self
.
hasher
.
finish
(
)
}
}
impl
<
S
:
Sip
>
hash
:
:
Hasher
for
Hasher
<
S
>
{
#
[
inline
]
fn
write_usize
(
&
mut
self
i
:
usize
)
{
let
bytes
=
unsafe
{
slice
:
:
from_raw_parts
(
&
i
as
*
const
usize
as
*
const
u8
mem
:
:
size_of
:
:
<
usize
>
(
)
)
}
;
self
.
short_write
(
bytes
)
;
}
#
[
inline
]
fn
write_u8
(
&
mut
self
i
:
u8
)
{
self
.
short_write
(
&
[
i
]
)
;
}
#
[
inline
]
fn
write
(
&
mut
self
msg
:
&
[
u8
]
)
{
let
length
=
msg
.
len
(
)
;
self
.
length
+
=
length
;
let
mut
needed
=
0
;
if
self
.
ntail
!
=
0
{
needed
=
8
-
self
.
ntail
;
self
.
tail
|
=
unsafe
{
u8to64_le
(
msg
0
cmp
:
:
min
(
length
needed
)
)
}
<
<
8
*
self
.
ntail
;
if
length
<
needed
{
self
.
ntail
+
=
length
;
return
;
}
else
{
self
.
state
.
v3
^
=
self
.
tail
;
S
:
:
c_rounds
(
&
mut
self
.
state
)
;
self
.
state
.
v0
^
=
self
.
tail
;
self
.
ntail
=
0
;
}
}
let
len
=
length
-
needed
;
let
left
=
len
&
0x7
;
let
mut
i
=
needed
;
while
i
<
len
-
left
{
let
mi
=
unsafe
{
load_int_le
!
(
msg
i
u64
)
}
;
self
.
state
.
v3
^
=
mi
;
S
:
:
c_rounds
(
&
mut
self
.
state
)
;
self
.
state
.
v0
^
=
mi
;
i
+
=
8
;
}
self
.
tail
=
unsafe
{
u8to64_le
(
msg
i
left
)
}
;
self
.
ntail
=
left
;
}
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
let
mut
state
=
self
.
state
;
let
b
:
u64
=
(
(
self
.
length
as
u64
&
0xff
)
<
<
56
)
|
self
.
tail
;
state
.
v3
^
=
b
;
S
:
:
c_rounds
(
&
mut
state
)
;
state
.
v0
^
=
b
;
state
.
v2
^
=
0xff
;
S
:
:
d_rounds
(
&
mut
state
)
;
state
.
v0
^
state
.
v1
^
state
.
v2
^
state
.
v3
}
}
impl
<
S
:
Sip
>
Default
for
Hasher
<
S
>
{
#
[
inline
]
fn
default
(
)
-
>
Hasher
<
S
>
{
Hasher
:
:
new_with_keys
(
0
0
)
}
}
#
[
doc
(
hidden
)
]
trait
Sip
{
fn
c_rounds
(
&
mut
State
)
;
fn
d_rounds
(
&
mut
State
)
;
}
#
[
derive
(
Debug
Clone
Copy
Default
)
]
struct
Sip13Rounds
;
impl
Sip
for
Sip13Rounds
{
#
[
inline
]
fn
c_rounds
(
state
:
&
mut
State
)
{
compress
!
(
state
)
;
}
#
[
inline
]
fn
d_rounds
(
state
:
&
mut
State
)
{
compress
!
(
state
)
;
compress
!
(
state
)
;
compress
!
(
state
)
;
}
}
#
[
derive
(
Debug
Clone
Copy
Default
)
]
struct
Sip24Rounds
;
impl
Sip
for
Sip24Rounds
{
#
[
inline
]
fn
c_rounds
(
state
:
&
mut
State
)
{
compress
!
(
state
)
;
compress
!
(
state
)
;
}
#
[
inline
]
fn
d_rounds
(
state
:
&
mut
State
)
{
compress
!
(
state
)
;
compress
!
(
state
)
;
compress
!
(
state
)
;
compress
!
(
state
)
;
}
}
