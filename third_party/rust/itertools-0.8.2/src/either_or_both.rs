use
EitherOrBoth
:
:
*
;
use
either
:
:
Either
;
#
[
derive
(
Clone
PartialEq
Eq
Debug
)
]
pub
enum
EitherOrBoth
<
A
B
>
{
Both
(
A
B
)
Left
(
A
)
Right
(
B
)
}
impl
<
A
B
>
EitherOrBoth
<
A
B
>
{
pub
fn
has_left
(
&
self
)
-
>
bool
{
self
.
as_ref
(
)
.
left
(
)
.
is_some
(
)
}
pub
fn
has_right
(
&
self
)
-
>
bool
{
self
.
as_ref
(
)
.
right
(
)
.
is_some
(
)
}
pub
fn
is_left
(
&
self
)
-
>
bool
{
match
*
self
{
Left
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
is_right
(
&
self
)
-
>
bool
{
match
*
self
{
Right
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
is_both
(
&
self
)
-
>
bool
{
self
.
as_ref
(
)
.
both
(
)
.
is_some
(
)
}
pub
fn
left
(
self
)
-
>
Option
<
A
>
{
match
self
{
Left
(
left
)
|
Both
(
left
_
)
=
>
Some
(
left
)
_
=
>
None
}
}
pub
fn
right
(
self
)
-
>
Option
<
B
>
{
match
self
{
Right
(
right
)
|
Both
(
_
right
)
=
>
Some
(
right
)
_
=
>
None
}
}
pub
fn
both
(
self
)
-
>
Option
<
(
A
B
)
>
{
match
self
{
Both
(
a
b
)
=
>
Some
(
(
a
b
)
)
_
=
>
None
}
}
pub
fn
as_ref
(
&
self
)
-
>
EitherOrBoth
<
&
A
&
B
>
{
match
*
self
{
Left
(
ref
left
)
=
>
Left
(
left
)
Right
(
ref
right
)
=
>
Right
(
right
)
Both
(
ref
left
ref
right
)
=
>
Both
(
left
right
)
}
}
pub
fn
as_mut
(
&
mut
self
)
-
>
EitherOrBoth
<
&
mut
A
&
mut
B
>
{
match
*
self
{
Left
(
ref
mut
left
)
=
>
Left
(
left
)
Right
(
ref
mut
right
)
=
>
Right
(
right
)
Both
(
ref
mut
left
ref
mut
right
)
=
>
Both
(
left
right
)
}
}
pub
fn
flip
(
self
)
-
>
EitherOrBoth
<
B
A
>
{
match
self
{
Left
(
a
)
=
>
Right
(
a
)
Right
(
b
)
=
>
Left
(
b
)
Both
(
a
b
)
=
>
Both
(
b
a
)
}
}
pub
fn
map_left
<
F
M
>
(
self
f
:
F
)
-
>
EitherOrBoth
<
M
B
>
where
F
:
FnOnce
(
A
)
-
>
M
{
match
self
{
Both
(
a
b
)
=
>
Both
(
f
(
a
)
b
)
Left
(
a
)
=
>
Left
(
f
(
a
)
)
Right
(
b
)
=
>
Right
(
b
)
}
}
pub
fn
map_right
<
F
M
>
(
self
f
:
F
)
-
>
EitherOrBoth
<
A
M
>
where
F
:
FnOnce
(
B
)
-
>
M
{
match
self
{
Left
(
a
)
=
>
Left
(
a
)
Right
(
b
)
=
>
Right
(
f
(
b
)
)
Both
(
a
b
)
=
>
Both
(
a
f
(
b
)
)
}
}
pub
fn
map_any
<
F
L
G
R
>
(
self
f
:
F
g
:
G
)
-
>
EitherOrBoth
<
L
R
>
where
F
:
FnOnce
(
A
)
-
>
L
G
:
FnOnce
(
B
)
-
>
R
{
match
self
{
Left
(
a
)
=
>
Left
(
f
(
a
)
)
Right
(
b
)
=
>
Right
(
g
(
b
)
)
Both
(
a
b
)
=
>
Both
(
f
(
a
)
g
(
b
)
)
}
}
pub
fn
left_and_then
<
F
L
>
(
self
f
:
F
)
-
>
EitherOrBoth
<
L
B
>
where
F
:
FnOnce
(
A
)
-
>
EitherOrBoth
<
L
B
>
{
match
self
{
Left
(
a
)
|
Both
(
a
_
)
=
>
f
(
a
)
Right
(
b
)
=
>
Right
(
b
)
}
}
pub
fn
right_and_then
<
F
R
>
(
self
f
:
F
)
-
>
EitherOrBoth
<
A
R
>
where
F
:
FnOnce
(
B
)
-
>
EitherOrBoth
<
A
R
>
{
match
self
{
Left
(
a
)
=
>
Left
(
a
)
Right
(
b
)
|
Both
(
_
b
)
=
>
f
(
b
)
}
}
}
impl
<
T
>
EitherOrBoth
<
T
T
>
{
pub
fn
reduce
<
F
>
(
self
f
:
F
)
-
>
T
where
F
:
FnOnce
(
T
T
)
-
>
T
{
match
self
{
Left
(
a
)
=
>
a
Right
(
b
)
=
>
b
Both
(
a
b
)
=
>
f
(
a
b
)
}
}
}
impl
<
A
B
>
Into
<
Option
<
Either
<
A
B
>
>
>
for
EitherOrBoth
<
A
B
>
{
fn
into
(
self
)
-
>
Option
<
Either
<
A
B
>
>
{
match
self
{
EitherOrBoth
:
:
Left
(
l
)
=
>
Some
(
Either
:
:
Left
(
l
)
)
EitherOrBoth
:
:
Right
(
r
)
=
>
Some
(
Either
:
:
Right
(
r
)
)
_
=
>
None
}
}
}
