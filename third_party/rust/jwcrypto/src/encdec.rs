use
crate
:
:
{
JwCryptoError
Jwk
}
;
use
serde
:
:
{
de
:
:
DeserializeOwned
Serialize
}
;
pub
struct
EncryptorDecryptor
{
jwk
:
Jwk
}
impl
EncryptorDecryptor
{
pub
fn
create_key
(
)
-
>
Result
<
String
JwCryptoError
>
{
let
key
=
crate
:
:
Jwk
:
:
new_direct_key
(
None
)
?
;
Ok
(
serde_json
:
:
to_string
(
&
key
)
?
)
}
pub
fn
new
(
key
:
&
str
)
-
>
Result
<
Self
JwCryptoError
>
{
match
serde_json
:
:
from_str
(
key
)
{
Ok
(
jwk
)
=
>
Ok
(
Self
{
jwk
}
)
Err
(
_
)
=
>
Err
(
JwCryptoError
:
:
InvalidKey
)
}
}
pub
fn
new_with_random_key
(
)
-
>
Result
<
Self
JwCryptoError
>
{
Self
:
:
new
(
&
Self
:
:
create_key
(
)
?
)
}
pub
fn
encrypt
(
&
self
cleartext
:
&
str
)
-
>
Result
<
String
JwCryptoError
>
{
crate
:
:
encrypt_to_jwe
(
cleartext
.
as_bytes
(
)
crate
:
:
EncryptionParameters
:
:
Direct
{
enc
:
crate
:
:
EncryptionAlgorithm
:
:
A256GCM
jwk
:
&
self
.
jwk
}
)
}
pub
fn
encrypt_struct
<
T
:
Serialize
>
(
&
self
fields
:
&
T
)
-
>
Result
<
String
JwCryptoError
>
{
let
str
=
serde_json
:
:
to_string
(
fields
)
?
;
self
.
encrypt
(
&
str
)
}
pub
fn
decrypt
(
&
self
ciphertext
:
&
str
)
-
>
Result
<
String
JwCryptoError
>
{
if
ciphertext
.
is_empty
(
)
{
return
Err
(
JwCryptoError
:
:
EmptyCyphertext
)
;
}
crate
:
:
decrypt_jwe
(
ciphertext
crate
:
:
DecryptionParameters
:
:
Direct
{
jwk
:
self
.
jwk
.
clone
(
)
}
)
}
pub
fn
decrypt_struct
<
T
:
DeserializeOwned
>
(
&
self
ciphertext
:
&
str
)
-
>
Result
<
T
JwCryptoError
>
{
let
json
=
self
.
decrypt
(
ciphertext
)
?
;
Ok
(
serde_json
:
:
from_str
(
&
json
)
?
)
}
pub
fn
create_canary
(
&
self
text
:
&
str
)
-
>
Result
<
String
JwCryptoError
>
{
self
.
encrypt
(
text
)
}
pub
fn
check_canary
(
&
self
canary
:
&
str
text
:
&
str
)
-
>
Result
<
bool
JwCryptoError
>
{
Ok
(
self
.
decrypt
(
canary
)
?
=
=
text
)
}
}
