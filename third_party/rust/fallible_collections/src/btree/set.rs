use
crate
:
:
TryReserveError
;
use
core
:
:
borrow
:
:
Borrow
;
use
core
:
:
cmp
:
:
max
;
use
core
:
:
cmp
:
:
Ordering
:
:
{
self
Equal
Greater
Less
}
;
use
core
:
:
fmt
:
:
{
self
Debug
}
;
use
core
:
:
iter
:
:
{
FromIterator
FusedIterator
Peekable
}
;
use
core
:
:
ops
:
:
{
BitAnd
BitOr
BitXor
RangeBounds
Sub
}
;
use
super
:
:
map
:
:
{
self
BTreeMap
Keys
}
;
use
super
:
:
Recover
;
#
[
derive
(
Clone
Hash
PartialEq
Eq
Ord
PartialOrd
)
]
pub
struct
BTreeSet
<
T
>
{
map
:
BTreeMap
<
T
(
)
>
}
pub
struct
Iter
<
'
a
T
:
'
a
>
{
iter
:
Keys
<
'
a
T
(
)
>
}
impl
<
T
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Iter
<
'
_
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
Iter
"
)
.
field
(
&
self
.
iter
.
clone
(
)
)
.
finish
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
IntoIter
<
T
>
{
iter
:
map
:
:
IntoIter
<
T
(
)
>
}
#
[
derive
(
Debug
)
]
pub
struct
Range
<
'
a
T
:
'
a
>
{
iter
:
map
:
:
Range
<
'
a
T
(
)
>
}
pub
struct
Difference
<
'
a
T
:
'
a
>
{
inner
:
DifferenceInner
<
'
a
T
>
}
enum
DifferenceInner
<
'
a
T
:
'
a
>
{
Stitch
{
self_iter
:
Iter
<
'
a
T
>
other_iter
:
Peekable
<
Iter
<
'
a
T
>
>
}
Search
{
self_iter
:
Iter
<
'
a
T
>
other_set
:
&
'
a
BTreeSet
<
T
>
}
}
impl
<
T
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Difference
<
'
_
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
&
self
.
inner
{
DifferenceInner
:
:
Stitch
{
self_iter
other_iter
}
=
>
f
.
debug_tuple
(
"
Difference
"
)
.
field
(
&
self_iter
)
.
field
(
&
other_iter
)
.
finish
(
)
DifferenceInner
:
:
Search
{
self_iter
other_set
:
_
}
=
>
f
.
debug_tuple
(
"
Difference
"
)
.
field
(
&
self_iter
)
.
finish
(
)
}
}
}
pub
struct
SymmetricDifference
<
'
a
T
:
'
a
>
{
a
:
Peekable
<
Iter
<
'
a
T
>
>
b
:
Peekable
<
Iter
<
'
a
T
>
>
}
impl
<
T
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
SymmetricDifference
<
'
_
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
SymmetricDifference
"
)
.
field
(
&
self
.
a
)
.
field
(
&
self
.
b
)
.
finish
(
)
}
}
pub
struct
Intersection
<
'
a
T
:
'
a
>
{
inner
:
IntersectionInner
<
'
a
T
>
}
enum
IntersectionInner
<
'
a
T
:
'
a
>
{
Stitch
{
small_iter
:
Iter
<
'
a
T
>
other_iter
:
Iter
<
'
a
T
>
}
Search
{
small_iter
:
Iter
<
'
a
T
>
large_set
:
&
'
a
BTreeSet
<
T
>
}
}
impl
<
T
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Intersection
<
'
_
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
&
self
.
inner
{
IntersectionInner
:
:
Stitch
{
small_iter
other_iter
}
=
>
f
.
debug_tuple
(
"
Intersection
"
)
.
field
(
&
small_iter
)
.
field
(
&
other_iter
)
.
finish
(
)
IntersectionInner
:
:
Search
{
small_iter
large_set
:
_
}
=
>
f
.
debug_tuple
(
"
Intersection
"
)
.
field
(
&
small_iter
)
.
finish
(
)
}
}
}
pub
struct
Union
<
'
a
T
:
'
a
>
{
a
:
Peekable
<
Iter
<
'
a
T
>
>
b
:
Peekable
<
Iter
<
'
a
T
>
>
}
impl
<
T
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Union
<
'
_
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
Union
"
)
.
field
(
&
self
.
a
)
.
field
(
&
self
.
b
)
.
finish
(
)
}
}
const
ITER_PERFORMANCE_TIPPING_SIZE_DIFF
:
usize
=
16
;
impl
<
T
:
Ord
>
BTreeSet
<
T
>
{
pub
fn
new
(
)
-
>
BTreeSet
<
T
>
{
BTreeSet
{
map
:
BTreeMap
:
:
new
(
)
}
}
pub
fn
range
<
K
:
?
Sized
R
>
(
&
self
range
:
R
)
-
>
Range
<
'
_
T
>
where
K
:
Ord
T
:
Borrow
<
K
>
R
:
RangeBounds
<
K
>
{
Range
{
iter
:
self
.
map
.
range
(
range
)
}
}
pub
fn
difference
<
'
a
>
(
&
'
a
self
other
:
&
'
a
BTreeSet
<
T
>
)
-
>
Difference
<
'
a
T
>
{
if
self
.
len
(
)
>
other
.
len
(
)
/
ITER_PERFORMANCE_TIPPING_SIZE_DIFF
{
Difference
{
inner
:
DifferenceInner
:
:
Stitch
{
self_iter
:
self
.
iter
(
)
other_iter
:
other
.
iter
(
)
.
peekable
(
)
}
}
}
else
{
Difference
{
inner
:
DifferenceInner
:
:
Search
{
self_iter
:
self
.
iter
(
)
other_set
:
other
}
}
}
}
pub
fn
symmetric_difference
<
'
a
>
(
&
'
a
self
other
:
&
'
a
BTreeSet
<
T
>
)
-
>
SymmetricDifference
<
'
a
T
>
{
SymmetricDifference
{
a
:
self
.
iter
(
)
.
peekable
(
)
b
:
other
.
iter
(
)
.
peekable
(
)
}
}
pub
fn
intersection
<
'
a
>
(
&
'
a
self
other
:
&
'
a
BTreeSet
<
T
>
)
-
>
Intersection
<
'
a
T
>
{
let
(
small
other
)
=
if
self
.
len
(
)
<
=
other
.
len
(
)
{
(
self
other
)
}
else
{
(
other
self
)
}
;
if
small
.
len
(
)
>
other
.
len
(
)
/
ITER_PERFORMANCE_TIPPING_SIZE_DIFF
{
Intersection
{
inner
:
IntersectionInner
:
:
Stitch
{
small_iter
:
small
.
iter
(
)
other_iter
:
other
.
iter
(
)
}
}
}
else
{
Intersection
{
inner
:
IntersectionInner
:
:
Search
{
small_iter
:
small
.
iter
(
)
large_set
:
other
}
}
}
}
pub
fn
union
<
'
a
>
(
&
'
a
self
other
:
&
'
a
BTreeSet
<
T
>
)
-
>
Union
<
'
a
T
>
{
Union
{
a
:
self
.
iter
(
)
.
peekable
(
)
b
:
other
.
iter
(
)
.
peekable
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
map
.
clear
(
)
}
pub
fn
contains
<
Q
:
?
Sized
>
(
&
self
value
:
&
Q
)
-
>
bool
where
T
:
Borrow
<
Q
>
Q
:
Ord
{
self
.
map
.
contains_key
(
value
)
}
pub
fn
get
<
Q
:
?
Sized
>
(
&
self
value
:
&
Q
)
-
>
Option
<
&
T
>
where
T
:
Borrow
<
Q
>
Q
:
Ord
{
Recover
:
:
get
(
&
self
.
map
value
)
}
pub
fn
is_disjoint
(
&
self
other
:
&
BTreeSet
<
T
>
)
-
>
bool
{
self
.
intersection
(
other
)
.
next
(
)
.
is_none
(
)
}
pub
fn
is_subset
(
&
self
other
:
&
BTreeSet
<
T
>
)
-
>
bool
{
if
self
.
len
(
)
>
other
.
len
(
)
{
false
}
else
if
self
.
len
(
)
>
other
.
len
(
)
/
ITER_PERFORMANCE_TIPPING_SIZE_DIFF
{
let
mut
x
=
self
.
iter
(
)
;
let
mut
y
=
other
.
iter
(
)
;
let
mut
a
=
x
.
next
(
)
;
let
mut
b
=
y
.
next
(
)
;
while
a
.
is_some
(
)
{
if
b
.
is_none
(
)
{
return
false
;
}
let
a1
=
a
.
unwrap
(
)
;
let
b1
=
b
.
unwrap
(
)
;
match
b1
.
cmp
(
a1
)
{
Less
=
>
(
)
Greater
=
>
return
false
Equal
=
>
a
=
x
.
next
(
)
}
b
=
y
.
next
(
)
;
}
true
}
else
{
for
next
in
self
{
if
!
other
.
contains
(
next
)
{
return
false
;
}
}
true
}
}
pub
fn
is_superset
(
&
self
other
:
&
BTreeSet
<
T
>
)
-
>
bool
{
other
.
is_subset
(
self
)
}
pub
fn
try_insert
(
&
mut
self
value
:
T
)
-
>
Result
<
bool
TryReserveError
>
{
Ok
(
self
.
map
.
try_insert
(
value
(
)
)
?
.
is_none
(
)
)
}
pub
fn
replace
(
&
mut
self
value
:
T
)
-
>
Result
<
Option
<
T
>
TryReserveError
>
{
Ok
(
Recover
:
:
replace
(
&
mut
self
.
map
value
)
?
)
}
pub
fn
remove
<
Q
:
?
Sized
>
(
&
mut
self
value
:
&
Q
)
-
>
bool
where
T
:
Borrow
<
Q
>
Q
:
Ord
{
self
.
map
.
remove
(
value
)
.
is_some
(
)
}
pub
fn
take
<
Q
:
?
Sized
>
(
&
mut
self
value
:
&
Q
)
-
>
Option
<
T
>
where
T
:
Borrow
<
Q
>
Q
:
Ord
{
Recover
:
:
take
(
&
mut
self
.
map
value
)
}
pub
fn
append
(
&
mut
self
other
:
&
mut
Self
)
{
self
.
map
.
append
(
&
mut
other
.
map
)
;
}
pub
fn
try_split_off
<
Q
:
?
Sized
+
Ord
>
(
&
mut
self
key
:
&
Q
)
-
>
Result
<
Self
TryReserveError
>
where
T
:
Borrow
<
Q
>
{
Ok
(
BTreeSet
{
map
:
self
.
map
.
split_off
(
key
)
?
}
)
}
}
impl
<
T
>
BTreeSet
<
T
>
{
pub
fn
iter
(
&
self
)
-
>
Iter
<
'
_
T
>
{
Iter
{
iter
:
self
.
map
.
keys
(
)
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
map
.
len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
}
impl
<
T
:
Ord
>
FromIterator
<
T
>
for
BTreeSet
<
T
>
{
fn
from_iter
<
I
:
IntoIterator
<
Item
=
T
>
>
(
iter
:
I
)
-
>
BTreeSet
<
T
>
{
let
mut
set
=
BTreeSet
:
:
new
(
)
;
set
.
extend
(
iter
)
;
set
}
}
impl
<
T
>
IntoIterator
for
BTreeSet
<
T
>
{
type
Item
=
T
;
type
IntoIter
=
IntoIter
<
T
>
;
fn
into_iter
(
self
)
-
>
IntoIter
<
T
>
{
IntoIter
{
iter
:
self
.
map
.
into_iter
(
)
}
}
}
impl
<
'
a
T
>
IntoIterator
for
&
'
a
BTreeSet
<
T
>
{
type
Item
=
&
'
a
T
;
type
IntoIter
=
Iter
<
'
a
T
>
;
fn
into_iter
(
self
)
-
>
Iter
<
'
a
T
>
{
self
.
iter
(
)
}
}
impl
<
T
:
Ord
>
Extend
<
T
>
for
BTreeSet
<
T
>
{
#
[
inline
]
fn
extend
<
Iter
:
IntoIterator
<
Item
=
T
>
>
(
&
mut
self
iter
:
Iter
)
{
iter
.
into_iter
(
)
.
for_each
(
move
|
elem
|
{
self
.
try_insert
(
elem
)
.
expect
(
"
Out
of
Mem
"
)
;
}
)
;
}
}
impl
<
'
a
T
:
'
a
+
Ord
+
Copy
>
Extend
<
&
'
a
T
>
for
BTreeSet
<
T
>
{
fn
extend
<
I
:
IntoIterator
<
Item
=
&
'
a
T
>
>
(
&
mut
self
iter
:
I
)
{
self
.
extend
(
iter
.
into_iter
(
)
.
cloned
(
)
)
;
}
}
impl
<
T
:
Ord
>
Default
for
BTreeSet
<
T
>
{
fn
default
(
)
-
>
BTreeSet
<
T
>
{
BTreeSet
:
:
new
(
)
}
}
impl
<
T
:
Ord
+
Clone
>
Sub
<
&
BTreeSet
<
T
>
>
for
&
BTreeSet
<
T
>
{
type
Output
=
BTreeSet
<
T
>
;
fn
sub
(
self
rhs
:
&
BTreeSet
<
T
>
)
-
>
BTreeSet
<
T
>
{
self
.
difference
(
rhs
)
.
cloned
(
)
.
collect
(
)
}
}
impl
<
T
:
Ord
+
Clone
>
BitXor
<
&
BTreeSet
<
T
>
>
for
&
BTreeSet
<
T
>
{
type
Output
=
BTreeSet
<
T
>
;
fn
bitxor
(
self
rhs
:
&
BTreeSet
<
T
>
)
-
>
BTreeSet
<
T
>
{
self
.
symmetric_difference
(
rhs
)
.
cloned
(
)
.
collect
(
)
}
}
impl
<
T
:
Ord
+
Clone
>
BitAnd
<
&
BTreeSet
<
T
>
>
for
&
BTreeSet
<
T
>
{
type
Output
=
BTreeSet
<
T
>
;
fn
bitand
(
self
rhs
:
&
BTreeSet
<
T
>
)
-
>
BTreeSet
<
T
>
{
self
.
intersection
(
rhs
)
.
cloned
(
)
.
collect
(
)
}
}
impl
<
T
:
Ord
+
Clone
>
BitOr
<
&
BTreeSet
<
T
>
>
for
&
BTreeSet
<
T
>
{
type
Output
=
BTreeSet
<
T
>
;
fn
bitor
(
self
rhs
:
&
BTreeSet
<
T
>
)
-
>
BTreeSet
<
T
>
{
self
.
union
(
rhs
)
.
cloned
(
)
.
collect
(
)
}
}
impl
<
T
:
Debug
>
Debug
for
BTreeSet
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_set
(
)
.
entries
(
self
.
iter
(
)
)
.
finish
(
)
}
}
impl
<
T
>
Clone
for
Iter
<
'
_
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
Iter
{
iter
:
self
.
iter
.
clone
(
)
}
}
}
impl
<
'
a
T
>
Iterator
for
Iter
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
self
.
iter
.
next
(
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
'
a
T
>
DoubleEndedIterator
for
Iter
<
'
a
T
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
self
.
iter
.
next_back
(
)
}
}
impl
<
T
>
ExactSizeIterator
for
Iter
<
'
_
T
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
T
>
FusedIterator
for
Iter
<
'
_
T
>
{
}
impl
<
T
>
Iterator
for
IntoIter
<
T
>
{
type
Item
=
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
T
>
{
self
.
iter
.
next
(
)
.
map
(
|
(
k
_
)
|
k
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
T
>
DoubleEndedIterator
for
IntoIter
<
T
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
T
>
{
self
.
iter
.
next_back
(
)
.
map
(
|
(
k
_
)
|
k
)
}
}
impl
<
T
>
ExactSizeIterator
for
IntoIter
<
T
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
T
>
FusedIterator
for
IntoIter
<
T
>
{
}
impl
<
T
>
Clone
for
Range
<
'
_
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
Range
{
iter
:
self
.
iter
.
clone
(
)
}
}
}
impl
<
'
a
T
>
Iterator
for
Range
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
self
.
iter
.
next
(
)
.
map
(
|
(
k
_
)
|
k
)
}
}
impl
<
'
a
T
>
DoubleEndedIterator
for
Range
<
'
a
T
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
self
.
iter
.
next_back
(
)
.
map
(
|
(
k
_
)
|
k
)
}
}
impl
<
T
>
FusedIterator
for
Range
<
'
_
T
>
{
}
fn
cmp_opt
<
T
:
Ord
>
(
x
:
Option
<
&
T
>
y
:
Option
<
&
T
>
short
:
Ordering
long
:
Ordering
)
-
>
Ordering
{
match
(
x
y
)
{
(
None
_
)
=
>
short
(
_
None
)
=
>
long
(
Some
(
x1
)
Some
(
y1
)
)
=
>
x1
.
cmp
(
y1
)
}
}
impl
<
T
>
Clone
for
Difference
<
'
_
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
Difference
{
inner
:
match
&
self
.
inner
{
DifferenceInner
:
:
Stitch
{
self_iter
other_iter
}
=
>
DifferenceInner
:
:
Stitch
{
self_iter
:
self_iter
.
clone
(
)
other_iter
:
other_iter
.
clone
(
)
}
DifferenceInner
:
:
Search
{
self_iter
other_set
}
=
>
DifferenceInner
:
:
Search
{
self_iter
:
self_iter
.
clone
(
)
other_set
}
}
}
}
}
impl
<
'
a
T
:
Ord
>
Iterator
for
Difference
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
match
&
mut
self
.
inner
{
DifferenceInner
:
:
Stitch
{
self_iter
other_iter
}
=
>
{
let
mut
self_next
=
self_iter
.
next
(
)
?
;
loop
{
match
other_iter
.
peek
(
)
.
map_or
(
Less
|
other_next
|
Ord
:
:
cmp
(
self_next
other_next
)
)
{
Less
=
>
return
Some
(
self_next
)
Equal
=
>
{
self_next
=
self_iter
.
next
(
)
?
;
other_iter
.
next
(
)
;
}
Greater
=
>
{
other_iter
.
next
(
)
;
}
}
}
}
DifferenceInner
:
:
Search
{
self_iter
other_set
}
=
>
loop
{
let
self_next
=
self_iter
.
next
(
)
?
;
if
!
other_set
.
contains
(
&
self_next
)
{
return
Some
(
self_next
)
;
}
}
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
(
self_len
other_len
)
=
match
&
self
.
inner
{
DifferenceInner
:
:
Stitch
{
self_iter
other_iter
}
=
>
(
self_iter
.
len
(
)
other_iter
.
len
(
)
)
DifferenceInner
:
:
Search
{
self_iter
other_set
}
=
>
(
self_iter
.
len
(
)
other_set
.
len
(
)
)
}
;
(
self_len
.
saturating_sub
(
other_len
)
Some
(
self_len
)
)
}
}
impl
<
T
:
Ord
>
FusedIterator
for
Difference
<
'
_
T
>
{
}
impl
<
T
>
Clone
for
SymmetricDifference
<
'
_
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
SymmetricDifference
{
a
:
self
.
a
.
clone
(
)
b
:
self
.
b
.
clone
(
)
}
}
}
impl
<
'
a
T
:
Ord
>
Iterator
for
SymmetricDifference
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
loop
{
match
cmp_opt
(
self
.
a
.
peek
(
)
self
.
b
.
peek
(
)
Greater
Less
)
{
Less
=
>
return
self
.
a
.
next
(
)
Equal
=
>
{
self
.
a
.
next
(
)
;
self
.
b
.
next
(
)
;
}
Greater
=
>
return
self
.
b
.
next
(
)
}
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
(
0
Some
(
self
.
a
.
len
(
)
+
self
.
b
.
len
(
)
)
)
}
}
impl
<
T
:
Ord
>
FusedIterator
for
SymmetricDifference
<
'
_
T
>
{
}
impl
<
T
>
Clone
for
Intersection
<
'
_
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
Intersection
{
inner
:
match
&
self
.
inner
{
IntersectionInner
:
:
Stitch
{
small_iter
other_iter
}
=
>
IntersectionInner
:
:
Stitch
{
small_iter
:
small_iter
.
clone
(
)
other_iter
:
other_iter
.
clone
(
)
}
IntersectionInner
:
:
Search
{
small_iter
large_set
}
=
>
IntersectionInner
:
:
Search
{
small_iter
:
small_iter
.
clone
(
)
large_set
}
}
}
}
}
impl
<
'
a
T
:
Ord
>
Iterator
for
Intersection
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
match
&
mut
self
.
inner
{
IntersectionInner
:
:
Stitch
{
small_iter
other_iter
}
=
>
{
let
mut
small_next
=
small_iter
.
next
(
)
?
;
let
mut
other_next
=
other_iter
.
next
(
)
?
;
loop
{
match
Ord
:
:
cmp
(
small_next
other_next
)
{
Less
=
>
small_next
=
small_iter
.
next
(
)
?
Greater
=
>
other_next
=
other_iter
.
next
(
)
?
Equal
=
>
return
Some
(
small_next
)
}
}
}
IntersectionInner
:
:
Search
{
small_iter
large_set
}
=
>
loop
{
let
small_next
=
small_iter
.
next
(
)
?
;
if
large_set
.
contains
(
&
small_next
)
{
return
Some
(
small_next
)
;
}
}
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
min_len
=
match
&
self
.
inner
{
IntersectionInner
:
:
Stitch
{
small_iter
.
.
}
=
>
small_iter
.
len
(
)
IntersectionInner
:
:
Search
{
small_iter
.
.
}
=
>
small_iter
.
len
(
)
}
;
(
0
Some
(
min_len
)
)
}
}
impl
<
T
:
Ord
>
FusedIterator
for
Intersection
<
'
_
T
>
{
}
impl
<
T
>
Clone
for
Union
<
'
_
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
Union
{
a
:
self
.
a
.
clone
(
)
b
:
self
.
b
.
clone
(
)
}
}
}
impl
<
'
a
T
:
Ord
>
Iterator
for
Union
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
T
>
{
match
cmp_opt
(
self
.
a
.
peek
(
)
self
.
b
.
peek
(
)
Greater
Less
)
{
Less
=
>
self
.
a
.
next
(
)
Equal
=
>
{
self
.
b
.
next
(
)
;
self
.
a
.
next
(
)
}
Greater
=
>
self
.
b
.
next
(
)
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
a_len
=
self
.
a
.
len
(
)
;
let
b_len
=
self
.
b
.
len
(
)
;
(
max
(
a_len
b_len
)
Some
(
a_len
+
b_len
)
)
}
}
impl
<
T
:
Ord
>
FusedIterator
for
Union
<
'
_
T
>
{
}
