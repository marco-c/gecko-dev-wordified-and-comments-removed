use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
:
:
{
self
MaybeUninit
}
;
use
core
:
:
ptr
:
:
{
self
NonNull
Unique
}
;
use
core
:
:
slice
;
use
crate
:
:
boxed
:
:
FallibleBox
;
use
crate
:
:
TryReserveError
;
use
alloc
:
:
alloc
:
:
{
Allocator
Global
Layout
}
;
use
alloc
:
:
boxed
:
:
Box
;
const
B
:
usize
=
6
;
pub
const
MIN_LEN
:
usize
=
B
-
1
;
pub
const
CAPACITY
:
usize
=
2
*
B
-
1
;
#
[
repr
(
C
)
]
struct
NodeHeader
<
K
V
K2
=
(
)
>
{
parent
:
*
const
InternalNode
<
K
V
>
parent_idx
:
MaybeUninit
<
u16
>
len
:
u16
keys_start
:
[
K2
;
0
]
}
#
[
repr
(
C
)
]
struct
LeafNode
<
K
V
>
{
parent
:
*
const
InternalNode
<
K
V
>
parent_idx
:
MaybeUninit
<
u16
>
len
:
u16
keys
:
[
MaybeUninit
<
K
>
;
CAPACITY
]
vals
:
[
MaybeUninit
<
V
>
;
CAPACITY
]
}
impl
<
K
V
>
LeafNode
<
K
V
>
{
unsafe
fn
new
(
)
-
>
Self
{
LeafNode
{
keys
:
MaybeUninit
:
:
uninit_array
:
:
<
CAPACITY
>
(
)
vals
:
MaybeUninit
:
:
uninit_array
:
:
<
CAPACITY
>
(
)
parent
:
ptr
:
:
null
(
)
parent_idx
:
MaybeUninit
:
:
uninit
(
)
len
:
0
}
}
}
impl
<
K
V
>
NodeHeader
<
K
V
>
{
fn
is_shared_root
(
&
self
)
-
>
bool
{
ptr
:
:
eq
(
self
&
EMPTY_ROOT_NODE
as
*
const
_
as
*
const
_
)
}
}
unsafe
impl
Sync
for
NodeHeader
<
(
)
(
)
>
{
}
static
EMPTY_ROOT_NODE
:
NodeHeader
<
(
)
(
)
>
=
NodeHeader
{
parent
:
ptr
:
:
null
(
)
parent_idx
:
MaybeUninit
:
:
uninit
(
)
len
:
0
keys_start
:
[
]
}
;
#
[
repr
(
C
)
]
struct
InternalNode
<
K
V
>
{
data
:
LeafNode
<
K
V
>
edges
:
[
MaybeUninit
<
BoxedNode
<
K
V
>
>
;
2
*
B
]
}
impl
<
K
V
>
InternalNode
<
K
V
>
{
unsafe
fn
new
(
)
-
>
Self
{
InternalNode
{
data
:
LeafNode
:
:
new
(
)
edges
:
MaybeUninit
:
:
uninit_array
:
:
<
{
2
*
B
}
>
(
)
}
}
}
struct
BoxedNode
<
K
V
>
{
ptr
:
Unique
<
LeafNode
<
K
V
>
>
}
impl
<
K
V
>
BoxedNode
<
K
V
>
{
fn
from_leaf
(
node
:
Box
<
LeafNode
<
K
V
>
>
)
-
>
Self
{
let
(
ptr
_g
)
=
Box
:
:
into_unique
(
node
)
;
BoxedNode
{
ptr
:
ptr
}
}
fn
from_internal
(
node
:
Box
<
InternalNode
<
K
V
>
>
)
-
>
Self
{
unsafe
{
BoxedNode
{
ptr
:
Unique
:
:
new_unchecked
(
Box
:
:
into_raw
(
node
)
as
*
mut
LeafNode
<
K
V
>
)
}
}
}
unsafe
fn
from_ptr
(
ptr
:
NonNull
<
LeafNode
<
K
V
>
>
)
-
>
Self
{
BoxedNode
{
ptr
:
Unique
:
:
new_unchecked
(
ptr
.
as_ptr
(
)
)
}
}
fn
as_ptr
(
&
self
)
-
>
NonNull
<
LeafNode
<
K
V
>
>
{
NonNull
:
:
from
(
self
.
ptr
)
}
}
pub
struct
Root
<
K
V
>
{
node
:
BoxedNode
<
K
V
>
height
:
usize
}
unsafe
impl
<
K
:
Sync
V
:
Sync
>
Sync
for
Root
<
K
V
>
{
}
unsafe
impl
<
K
:
Send
V
:
Send
>
Send
for
Root
<
K
V
>
{
}
impl
<
K
V
>
Root
<
K
V
>
{
pub
fn
is_shared_root
(
&
self
)
-
>
bool
{
self
.
as_ref
(
)
.
is_shared_root
(
)
}
pub
fn
shared_empty_root
(
)
-
>
Self
{
Root
{
node
:
unsafe
{
BoxedNode
:
:
from_ptr
(
NonNull
:
:
new_unchecked
(
&
EMPTY_ROOT_NODE
as
*
const
_
as
*
const
LeafNode
<
K
V
>
as
*
mut
_
)
)
}
height
:
0
}
}
pub
fn
new_leaf
(
)
-
>
Result
<
Self
TryReserveError
>
{
Ok
(
Root
{
node
:
BoxedNode
:
:
from_leaf
(
<
Box
<
_
>
as
FallibleBox
<
_
>
>
:
:
try_new
(
unsafe
{
LeafNode
:
:
new
(
)
}
)
?
)
height
:
0
}
)
}
pub
fn
as_ref
(
&
self
)
-
>
NodeRef
<
marker
:
:
Immut
<
'
_
>
K
V
marker
:
:
LeafOrInternal
>
{
NodeRef
{
height
:
self
.
height
node
:
self
.
node
.
as_ptr
(
)
root
:
self
as
*
const
_
as
*
mut
_
_marker
:
PhantomData
}
}
pub
fn
as_mut
(
&
mut
self
)
-
>
NodeRef
<
marker
:
:
Mut
<
'
_
>
K
V
marker
:
:
LeafOrInternal
>
{
NodeRef
{
height
:
self
.
height
node
:
self
.
node
.
as_ptr
(
)
root
:
self
as
*
mut
_
_marker
:
PhantomData
}
}
pub
fn
into_ref
(
self
)
-
>
NodeRef
<
marker
:
:
Owned
K
V
marker
:
:
LeafOrInternal
>
{
NodeRef
{
height
:
self
.
height
node
:
self
.
node
.
as_ptr
(
)
root
:
ptr
:
:
null_mut
(
)
_marker
:
PhantomData
}
}
pub
fn
push_level
(
&
mut
self
)
-
>
Result
<
NodeRef
<
marker
:
:
Mut
<
'
_
>
K
V
marker
:
:
Internal
>
TryReserveError
>
{
debug_assert
!
(
!
self
.
is_shared_root
(
)
)
;
let
mut
new_node
=
<
Box
<
_
>
as
FallibleBox
<
_
>
>
:
:
try_new
(
unsafe
{
InternalNode
:
:
new
(
)
}
)
?
;
new_node
.
edges
[
0
]
.
write
(
unsafe
{
BoxedNode
:
:
from_ptr
(
self
.
node
.
as_ptr
(
)
)
}
)
;
self
.
node
=
BoxedNode
:
:
from_internal
(
new_node
)
;
self
.
height
+
=
1
;
let
mut
ret
=
NodeRef
{
height
:
self
.
height
node
:
self
.
node
.
as_ptr
(
)
root
:
self
as
*
mut
_
_marker
:
PhantomData
}
;
unsafe
{
ret
.
reborrow_mut
(
)
.
first_edge
(
)
.
correct_parent_link
(
)
;
}
Ok
(
ret
)
}
pub
fn
pop_level
(
&
mut
self
)
{
debug_assert
!
(
self
.
height
>
0
)
;
let
top
=
self
.
node
.
ptr
;
self
.
node
=
unsafe
{
BoxedNode
:
:
from_ptr
(
self
.
as_mut
(
)
.
cast_unchecked
:
:
<
marker
:
:
Internal
>
(
)
.
first_edge
(
)
.
descend
(
)
.
node
)
}
;
self
.
height
-
=
1
;
unsafe
{
(
*
self
.
as_mut
(
)
.
as_leaf_mut
(
)
)
.
parent
=
ptr
:
:
null
(
)
;
}
unsafe
{
Global
.
deallocate
(
NonNull
:
:
from
(
top
)
.
cast
(
)
Layout
:
:
new
:
:
<
InternalNode
<
K
V
>
>
(
)
)
;
}
}
}
pub
struct
NodeRef
<
BorrowType
K
V
Type
>
{
height
:
usize
node
:
NonNull
<
LeafNode
<
K
V
>
>
root
:
*
const
Root
<
K
V
>
_marker
:
PhantomData
<
(
BorrowType
Type
)
>
}
impl
<
'
a
K
:
'
a
V
:
'
a
Type
>
Copy
for
NodeRef
<
marker
:
:
Immut
<
'
a
>
K
V
Type
>
{
}
impl
<
'
a
K
:
'
a
V
:
'
a
Type
>
Clone
for
NodeRef
<
marker
:
:
Immut
<
'
a
>
K
V
Type
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
unsafe
impl
<
BorrowType
K
:
Sync
V
:
Sync
Type
>
Sync
for
NodeRef
<
BorrowType
K
V
Type
>
{
}
unsafe
impl
<
'
a
K
:
Sync
+
'
a
V
:
Sync
+
'
a
Type
>
Send
for
NodeRef
<
marker
:
:
Immut
<
'
a
>
K
V
Type
>
{
}
unsafe
impl
<
'
a
K
:
Send
+
'
a
V
:
Send
+
'
a
Type
>
Send
for
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
Type
>
{
}
unsafe
impl
<
K
:
Send
V
:
Send
Type
>
Send
for
NodeRef
<
marker
:
:
Owned
K
V
Type
>
{
}
impl
<
BorrowType
K
V
>
NodeRef
<
BorrowType
K
V
marker
:
:
Internal
>
{
fn
as_internal
(
&
self
)
-
>
&
InternalNode
<
K
V
>
{
unsafe
{
&
*
(
self
.
node
.
as_ptr
(
)
as
*
mut
InternalNode
<
K
V
>
)
}
}
}
impl
<
'
a
K
V
>
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
Internal
>
{
fn
as_internal_mut
(
&
mut
self
)
-
>
&
mut
InternalNode
<
K
V
>
{
unsafe
{
&
mut
*
(
self
.
node
.
as_ptr
(
)
as
*
mut
InternalNode
<
K
V
>
)
}
}
}
impl
<
BorrowType
K
V
Type
>
NodeRef
<
BorrowType
K
V
Type
>
{
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
as_header
(
)
.
len
as
usize
}
pub
fn
height
(
&
self
)
-
>
usize
{
self
.
height
}
pub
fn
forget_type
(
self
)
-
>
NodeRef
<
BorrowType
K
V
marker
:
:
LeafOrInternal
>
{
NodeRef
{
height
:
self
.
height
node
:
self
.
node
root
:
self
.
root
_marker
:
PhantomData
}
}
fn
reborrow
<
'
a
>
(
&
'
a
self
)
-
>
NodeRef
<
marker
:
:
Immut
<
'
a
>
K
V
Type
>
{
NodeRef
{
height
:
self
.
height
node
:
self
.
node
root
:
self
.
root
_marker
:
PhantomData
}
}
unsafe
fn
as_leaf
(
&
self
)
-
>
&
LeafNode
<
K
V
>
{
self
.
node
.
as_ref
(
)
}
fn
as_header
(
&
self
)
-
>
&
NodeHeader
<
K
V
>
{
unsafe
{
&
*
(
self
.
node
.
as_ptr
(
)
as
*
const
NodeHeader
<
K
V
>
)
}
}
pub
fn
is_shared_root
(
&
self
)
-
>
bool
{
self
.
as_header
(
)
.
is_shared_root
(
)
}
pub
fn
keys
(
&
self
)
-
>
&
[
K
]
{
self
.
reborrow
(
)
.
into_key_slice
(
)
}
fn
vals
(
&
self
)
-
>
&
[
V
]
{
self
.
reborrow
(
)
.
into_val_slice
(
)
}
pub
fn
ascend
(
self
)
-
>
Result
<
Handle
<
NodeRef
<
BorrowType
K
V
marker
:
:
Internal
>
marker
:
:
Edge
>
Self
>
{
let
parent_as_leaf
=
self
.
as_header
(
)
.
parent
as
*
const
LeafNode
<
K
V
>
;
if
let
Some
(
non_zero
)
=
NonNull
:
:
new
(
parent_as_leaf
as
*
mut
_
)
{
Ok
(
Handle
{
node
:
NodeRef
{
height
:
self
.
height
+
1
node
:
non_zero
root
:
self
.
root
_marker
:
PhantomData
}
idx
:
unsafe
{
usize
:
:
from
(
*
self
.
as_header
(
)
.
parent_idx
.
as_ptr
(
)
)
}
_marker
:
PhantomData
}
)
}
else
{
Err
(
self
)
}
}
pub
fn
first_edge
(
self
)
-
>
Handle
<
Self
marker
:
:
Edge
>
{
Handle
:
:
new_edge
(
self
0
)
}
pub
fn
last_edge
(
self
)
-
>
Handle
<
Self
marker
:
:
Edge
>
{
let
len
=
self
.
len
(
)
;
Handle
:
:
new_edge
(
self
len
)
}
pub
fn
first_kv
(
self
)
-
>
Handle
<
Self
marker
:
:
KV
>
{
debug_assert
!
(
self
.
len
(
)
>
0
)
;
Handle
:
:
new_kv
(
self
0
)
}
pub
fn
last_kv
(
self
)
-
>
Handle
<
Self
marker
:
:
KV
>
{
let
len
=
self
.
len
(
)
;
debug_assert
!
(
len
>
0
)
;
Handle
:
:
new_kv
(
self
len
-
1
)
}
}
impl
<
K
V
>
NodeRef
<
marker
:
:
Owned
K
V
marker
:
:
Leaf
>
{
pub
unsafe
fn
deallocate_and_ascend
(
self
)
-
>
Option
<
Handle
<
NodeRef
<
marker
:
:
Owned
K
V
marker
:
:
Internal
>
marker
:
:
Edge
>
>
{
debug_assert
!
(
!
self
.
is_shared_root
(
)
)
;
let
node
=
self
.
node
;
let
ret
=
self
.
ascend
(
)
.
ok
(
)
;
Global
.
deallocate
(
node
.
cast
(
)
Layout
:
:
new
:
:
<
LeafNode
<
K
V
>
>
(
)
)
;
ret
}
}
impl
<
K
V
>
NodeRef
<
marker
:
:
Owned
K
V
marker
:
:
Internal
>
{
pub
unsafe
fn
deallocate_and_ascend
(
self
)
-
>
Option
<
Handle
<
NodeRef
<
marker
:
:
Owned
K
V
marker
:
:
Internal
>
marker
:
:
Edge
>
>
{
let
node
=
self
.
node
;
let
ret
=
self
.
ascend
(
)
.
ok
(
)
;
Global
.
deallocate
(
node
.
cast
(
)
Layout
:
:
new
:
:
<
InternalNode
<
K
V
>
>
(
)
)
;
ret
}
}
impl
<
'
a
K
V
Type
>
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
Type
>
{
unsafe
fn
cast_unchecked
<
NewType
>
(
&
mut
self
)
-
>
NodeRef
<
marker
:
:
Mut
<
'
_
>
K
V
NewType
>
{
NodeRef
{
height
:
self
.
height
node
:
self
.
node
root
:
self
.
root
_marker
:
PhantomData
}
}
unsafe
fn
reborrow_mut
(
&
mut
self
)
-
>
NodeRef
<
marker
:
:
Mut
<
'
_
>
K
V
Type
>
{
NodeRef
{
height
:
self
.
height
node
:
self
.
node
root
:
self
.
root
_marker
:
PhantomData
}
}
fn
as_leaf_mut
(
&
mut
self
)
-
>
*
mut
LeafNode
<
K
V
>
{
self
.
node
.
as_ptr
(
)
}
fn
keys_mut
(
&
mut
self
)
-
>
&
mut
[
K
]
{
unsafe
{
self
.
reborrow_mut
(
)
.
into_key_slice_mut
(
)
}
}
fn
vals_mut
(
&
mut
self
)
-
>
&
mut
[
V
]
{
unsafe
{
self
.
reborrow_mut
(
)
.
into_val_slice_mut
(
)
}
}
}
impl
<
'
a
K
:
'
a
V
:
'
a
Type
>
NodeRef
<
marker
:
:
Immut
<
'
a
>
K
V
Type
>
{
fn
into_key_slice
(
self
)
-
>
&
'
a
[
K
]
{
if
mem
:
:
align_of
:
:
<
K
>
(
)
>
mem
:
:
align_of
:
:
<
LeafNode
<
(
)
(
)
>
>
(
)
&
&
self
.
is_shared_root
(
)
{
&
[
]
}
else
{
assert
!
(
mem
:
:
size_of
:
:
<
NodeHeader
<
K
V
>
>
(
)
=
=
mem
:
:
size_of
:
:
<
NodeHeader
<
K
V
K
>
>
(
)
)
;
let
header
=
self
.
as_header
(
)
as
*
const
_
as
*
const
NodeHeader
<
K
V
K
>
;
let
keys
=
unsafe
{
&
(
*
header
)
.
keys_start
as
*
const
_
as
*
const
K
}
;
unsafe
{
slice
:
:
from_raw_parts
(
keys
self
.
len
(
)
)
}
}
}
fn
into_val_slice
(
self
)
-
>
&
'
a
[
V
]
{
debug_assert
!
(
!
self
.
is_shared_root
(
)
)
;
unsafe
{
slice
:
:
from_raw_parts
(
MaybeUninit
:
:
slice_as_ptr
(
&
self
.
as_leaf
(
)
.
vals
)
self
.
len
(
)
)
}
}
fn
into_slices
(
self
)
-
>
(
&
'
a
[
K
]
&
'
a
[
V
]
)
{
let
k
=
unsafe
{
ptr
:
:
read
(
&
self
)
}
;
(
k
.
into_key_slice
(
)
self
.
into_val_slice
(
)
)
}
}
impl
<
'
a
K
:
'
a
V
:
'
a
Type
>
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
Type
>
{
pub
fn
into_root_mut
(
self
)
-
>
&
'
a
mut
Root
<
K
V
>
{
unsafe
{
&
mut
*
(
self
.
root
as
*
mut
Root
<
K
V
>
)
}
}
fn
into_key_slice_mut
(
mut
self
)
-
>
&
'
a
mut
[
K
]
{
if
mem
:
:
align_of
:
:
<
K
>
(
)
>
mem
:
:
align_of
:
:
<
LeafNode
<
(
)
(
)
>
>
(
)
&
&
self
.
is_shared_root
(
)
{
&
mut
[
]
}
else
{
unsafe
{
slice
:
:
from_raw_parts_mut
(
MaybeUninit
:
:
slice_as_mut_ptr
(
&
mut
(
*
self
.
as_leaf_mut
(
)
)
.
keys
)
self
.
len
(
)
)
}
}
}
fn
into_val_slice_mut
(
mut
self
)
-
>
&
'
a
mut
[
V
]
{
debug_assert
!
(
!
self
.
is_shared_root
(
)
)
;
unsafe
{
slice
:
:
from_raw_parts_mut
(
MaybeUninit
:
:
slice_as_mut_ptr
(
&
mut
(
*
self
.
as_leaf_mut
(
)
)
.
vals
)
self
.
len
(
)
)
}
}
fn
into_slices_mut
(
mut
self
)
-
>
(
&
'
a
mut
[
K
]
&
'
a
mut
[
V
]
)
{
debug_assert
!
(
!
self
.
is_shared_root
(
)
)
;
unsafe
{
let
len
=
self
.
len
(
)
;
let
leaf
=
self
.
as_leaf_mut
(
)
;
let
keys
=
slice
:
:
from_raw_parts_mut
(
MaybeUninit
:
:
slice_as_mut_ptr
(
&
mut
(
*
leaf
)
.
keys
)
len
)
;
let
vals
=
slice
:
:
from_raw_parts_mut
(
MaybeUninit
:
:
slice_as_mut_ptr
(
&
mut
(
*
leaf
)
.
vals
)
len
)
;
(
keys
vals
)
}
}
}
impl
<
'
a
K
V
>
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
Leaf
>
{
pub
fn
push
(
&
mut
self
key
:
K
val
:
V
)
{
debug_assert
!
(
self
.
len
(
)
<
CAPACITY
)
;
debug_assert
!
(
!
self
.
is_shared_root
(
)
)
;
let
idx
=
self
.
len
(
)
;
unsafe
{
ptr
:
:
write
(
self
.
keys_mut
(
)
.
get_unchecked_mut
(
idx
)
key
)
;
ptr
:
:
write
(
self
.
vals_mut
(
)
.
get_unchecked_mut
(
idx
)
val
)
;
(
*
self
.
as_leaf_mut
(
)
)
.
len
+
=
1
;
}
}
pub
fn
push_front
(
&
mut
self
key
:
K
val
:
V
)
{
debug_assert
!
(
self
.
len
(
)
<
CAPACITY
)
;
debug_assert
!
(
!
self
.
is_shared_root
(
)
)
;
unsafe
{
slice_insert
(
self
.
keys_mut
(
)
0
key
)
;
slice_insert
(
self
.
vals_mut
(
)
0
val
)
;
(
*
self
.
as_leaf_mut
(
)
)
.
len
+
=
1
;
}
}
}
impl
<
'
a
K
V
>
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
Internal
>
{
pub
fn
push
(
&
mut
self
key
:
K
val
:
V
edge
:
Root
<
K
V
>
)
{
debug_assert
!
(
edge
.
height
=
=
self
.
height
-
1
)
;
debug_assert
!
(
self
.
len
(
)
<
CAPACITY
)
;
let
idx
=
self
.
len
(
)
;
unsafe
{
ptr
:
:
write
(
self
.
keys_mut
(
)
.
get_unchecked_mut
(
idx
)
key
)
;
ptr
:
:
write
(
self
.
vals_mut
(
)
.
get_unchecked_mut
(
idx
)
val
)
;
self
.
as_internal_mut
(
)
.
edges
.
get_unchecked_mut
(
idx
+
1
)
.
write
(
edge
.
node
)
;
(
*
self
.
as_leaf_mut
(
)
)
.
len
+
=
1
;
Handle
:
:
new_edge
(
self
.
reborrow_mut
(
)
idx
+
1
)
.
correct_parent_link
(
)
;
}
}
fn
correct_childrens_parent_links
(
&
mut
self
first
:
usize
after_last
:
usize
)
{
for
i
in
first
.
.
after_last
{
Handle
:
:
new_edge
(
unsafe
{
self
.
reborrow_mut
(
)
}
i
)
.
correct_parent_link
(
)
;
}
}
fn
correct_all_childrens_parent_links
(
&
mut
self
)
{
let
len
=
self
.
len
(
)
;
self
.
correct_childrens_parent_links
(
0
len
+
1
)
;
}
pub
fn
push_front
(
&
mut
self
key
:
K
val
:
V
edge
:
Root
<
K
V
>
)
{
debug_assert
!
(
edge
.
height
=
=
self
.
height
-
1
)
;
debug_assert
!
(
self
.
len
(
)
<
CAPACITY
)
;
unsafe
{
slice_insert
(
self
.
keys_mut
(
)
0
key
)
;
slice_insert
(
self
.
vals_mut
(
)
0
val
)
;
slice_insert
(
slice
:
:
from_raw_parts_mut
(
MaybeUninit
:
:
slice_as_mut_ptr
(
&
mut
self
.
as_internal_mut
(
)
.
edges
)
self
.
len
(
)
+
1
)
0
edge
.
node
)
;
(
*
self
.
as_leaf_mut
(
)
)
.
len
+
=
1
;
self
.
correct_all_childrens_parent_links
(
)
;
}
}
}
impl
<
'
a
K
V
>
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
LeafOrInternal
>
{
pub
fn
pop
(
&
mut
self
)
-
>
(
K
V
Option
<
Root
<
K
V
>
>
)
{
debug_assert
!
(
self
.
len
(
)
>
0
)
;
let
idx
=
self
.
len
(
)
-
1
;
unsafe
{
let
key
=
ptr
:
:
read
(
self
.
keys
(
)
.
get_unchecked
(
idx
)
)
;
let
val
=
ptr
:
:
read
(
self
.
vals
(
)
.
get_unchecked
(
idx
)
)
;
let
edge
=
match
self
.
reborrow_mut
(
)
.
force
(
)
{
ForceResult
:
:
Leaf
(
_
)
=
>
None
ForceResult
:
:
Internal
(
internal
)
=
>
{
let
edge
=
ptr
:
:
read
(
internal
.
as_internal
(
)
.
edges
.
get_unchecked
(
idx
+
1
)
.
as_ptr
(
)
)
;
let
mut
new_root
=
Root
{
node
:
edge
height
:
internal
.
height
-
1
}
;
(
*
new_root
.
as_mut
(
)
.
as_leaf_mut
(
)
)
.
parent
=
ptr
:
:
null
(
)
;
Some
(
new_root
)
}
}
;
(
*
self
.
as_leaf_mut
(
)
)
.
len
-
=
1
;
(
key
val
edge
)
}
}
pub
fn
pop_front
(
&
mut
self
)
-
>
(
K
V
Option
<
Root
<
K
V
>
>
)
{
debug_assert
!
(
self
.
len
(
)
>
0
)
;
let
old_len
=
self
.
len
(
)
;
unsafe
{
let
key
=
slice_remove
(
self
.
keys_mut
(
)
0
)
;
let
val
=
slice_remove
(
self
.
vals_mut
(
)
0
)
;
let
edge
=
match
self
.
reborrow_mut
(
)
.
force
(
)
{
ForceResult
:
:
Leaf
(
_
)
=
>
None
ForceResult
:
:
Internal
(
mut
internal
)
=
>
{
let
edge
=
slice_remove
(
slice
:
:
from_raw_parts_mut
(
MaybeUninit
:
:
slice_as_mut_ptr
(
&
mut
internal
.
as_internal_mut
(
)
.
edges
)
old_len
+
1
)
0
)
;
let
mut
new_root
=
Root
{
node
:
edge
height
:
internal
.
height
-
1
}
;
(
*
new_root
.
as_mut
(
)
.
as_leaf_mut
(
)
)
.
parent
=
ptr
:
:
null
(
)
;
for
i
in
0
.
.
old_len
{
Handle
:
:
new_edge
(
internal
.
reborrow_mut
(
)
i
)
.
correct_parent_link
(
)
;
}
Some
(
new_root
)
}
}
;
(
*
self
.
as_leaf_mut
(
)
)
.
len
-
=
1
;
(
key
val
edge
)
}
}
fn
into_kv_pointers_mut
(
mut
self
)
-
>
(
*
mut
K
*
mut
V
)
{
(
self
.
keys_mut
(
)
.
as_mut_ptr
(
)
self
.
vals_mut
(
)
.
as_mut_ptr
(
)
)
}
}
impl
<
BorrowType
K
V
>
NodeRef
<
BorrowType
K
V
marker
:
:
LeafOrInternal
>
{
pub
fn
force
(
self
)
-
>
ForceResult
<
NodeRef
<
BorrowType
K
V
marker
:
:
Leaf
>
NodeRef
<
BorrowType
K
V
marker
:
:
Internal
>
>
{
if
self
.
height
=
=
0
{
ForceResult
:
:
Leaf
(
NodeRef
{
height
:
self
.
height
node
:
self
.
node
root
:
self
.
root
_marker
:
PhantomData
}
)
}
else
{
ForceResult
:
:
Internal
(
NodeRef
{
height
:
self
.
height
node
:
self
.
node
root
:
self
.
root
_marker
:
PhantomData
}
)
}
}
}
pub
struct
Handle
<
Node
Type
>
{
node
:
Node
idx
:
usize
_marker
:
PhantomData
<
Type
>
}
impl
<
Node
:
Copy
Type
>
Copy
for
Handle
<
Node
Type
>
{
}
impl
<
Node
:
Copy
Type
>
Clone
for
Handle
<
Node
Type
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
Node
Type
>
Handle
<
Node
Type
>
{
pub
fn
into_node
(
self
)
-
>
Node
{
self
.
node
}
}
impl
<
BorrowType
K
V
NodeType
>
Handle
<
NodeRef
<
BorrowType
K
V
NodeType
>
marker
:
:
KV
>
{
pub
fn
new_kv
(
node
:
NodeRef
<
BorrowType
K
V
NodeType
>
idx
:
usize
)
-
>
Self
{
debug_assert
!
(
idx
<
node
.
len
(
)
)
;
Handle
{
node
idx
_marker
:
PhantomData
}
}
pub
fn
left_edge
(
self
)
-
>
Handle
<
NodeRef
<
BorrowType
K
V
NodeType
>
marker
:
:
Edge
>
{
Handle
:
:
new_edge
(
self
.
node
self
.
idx
)
}
pub
fn
right_edge
(
self
)
-
>
Handle
<
NodeRef
<
BorrowType
K
V
NodeType
>
marker
:
:
Edge
>
{
Handle
:
:
new_edge
(
self
.
node
self
.
idx
+
1
)
}
}
impl
<
BorrowType
K
V
NodeType
HandleType
>
PartialEq
for
Handle
<
NodeRef
<
BorrowType
K
V
NodeType
>
HandleType
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
node
.
node
=
=
other
.
node
.
node
&
&
self
.
idx
=
=
other
.
idx
}
}
impl
<
BorrowType
K
V
NodeType
HandleType
>
Handle
<
NodeRef
<
BorrowType
K
V
NodeType
>
HandleType
>
{
pub
fn
reborrow
(
&
self
)
-
>
Handle
<
NodeRef
<
marker
:
:
Immut
<
'
_
>
K
V
NodeType
>
HandleType
>
{
Handle
{
node
:
self
.
node
.
reborrow
(
)
idx
:
self
.
idx
_marker
:
PhantomData
}
}
}
impl
<
'
a
K
V
NodeType
HandleType
>
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
NodeType
>
HandleType
>
{
pub
unsafe
fn
reborrow_mut
(
&
mut
self
)
-
>
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
_
>
K
V
NodeType
>
HandleType
>
{
Handle
{
node
:
self
.
node
.
reborrow_mut
(
)
idx
:
self
.
idx
_marker
:
PhantomData
}
}
}
impl
<
BorrowType
K
V
NodeType
>
Handle
<
NodeRef
<
BorrowType
K
V
NodeType
>
marker
:
:
Edge
>
{
pub
fn
new_edge
(
node
:
NodeRef
<
BorrowType
K
V
NodeType
>
idx
:
usize
)
-
>
Self
{
debug_assert
!
(
idx
<
=
node
.
len
(
)
)
;
Handle
{
node
idx
_marker
:
PhantomData
}
}
pub
fn
left_kv
(
self
)
-
>
Result
<
Handle
<
NodeRef
<
BorrowType
K
V
NodeType
>
marker
:
:
KV
>
Self
>
{
if
self
.
idx
>
0
{
Ok
(
Handle
:
:
new_kv
(
self
.
node
self
.
idx
-
1
)
)
}
else
{
Err
(
self
)
}
}
pub
fn
right_kv
(
self
)
-
>
Result
<
Handle
<
NodeRef
<
BorrowType
K
V
NodeType
>
marker
:
:
KV
>
Self
>
{
if
self
.
idx
<
self
.
node
.
len
(
)
{
Ok
(
Handle
:
:
new_kv
(
self
.
node
self
.
idx
)
)
}
else
{
Err
(
self
)
}
}
}
impl
<
'
a
K
V
>
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
Leaf
>
marker
:
:
Edge
>
{
fn
insert_fit
(
&
mut
self
key
:
K
val
:
V
)
-
>
*
mut
V
{
debug_assert
!
(
self
.
node
.
len
(
)
<
CAPACITY
)
;
debug_assert
!
(
!
self
.
node
.
is_shared_root
(
)
)
;
unsafe
{
slice_insert
(
self
.
node
.
keys_mut
(
)
self
.
idx
key
)
;
slice_insert
(
self
.
node
.
vals_mut
(
)
self
.
idx
val
)
;
(
*
self
.
node
.
as_leaf_mut
(
)
)
.
len
+
=
1
;
self
.
node
.
vals_mut
(
)
.
get_unchecked_mut
(
self
.
idx
)
}
}
pub
fn
insert
(
mut
self
key
:
K
val
:
V
)
-
>
Result
<
(
InsertResult
<
'
a
K
V
marker
:
:
Leaf
>
*
mut
V
)
TryReserveError
>
{
if
self
.
node
.
len
(
)
<
CAPACITY
{
let
ptr
=
self
.
insert_fit
(
key
val
)
;
Ok
(
(
InsertResult
:
:
Fit
(
Handle
:
:
new_kv
(
self
.
node
self
.
idx
)
)
ptr
)
)
}
else
{
let
middle
=
Handle
:
:
new_kv
(
self
.
node
B
)
;
let
(
mut
left
k
v
mut
right
)
=
middle
.
split
(
)
?
;
let
ptr
=
if
self
.
idx
<
=
B
{
unsafe
{
Handle
:
:
new_edge
(
left
.
reborrow_mut
(
)
self
.
idx
)
.
insert_fit
(
key
val
)
}
}
else
{
unsafe
{
Handle
:
:
new_edge
(
right
.
as_mut
(
)
.
cast_unchecked
:
:
<
marker
:
:
Leaf
>
(
)
self
.
idx
-
(
B
+
1
)
)
.
insert_fit
(
key
val
)
}
}
;
Ok
(
(
InsertResult
:
:
Split
(
left
k
v
right
)
ptr
)
)
}
}
}
impl
<
'
a
K
V
>
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
Internal
>
marker
:
:
Edge
>
{
fn
correct_parent_link
(
mut
self
)
{
let
idx
=
self
.
idx
as
u16
;
let
ptr
=
self
.
node
.
as_internal_mut
(
)
as
*
mut
_
;
let
mut
child
=
self
.
descend
(
)
;
unsafe
{
(
*
child
.
as_leaf_mut
(
)
)
.
parent
=
ptr
;
(
*
child
.
as_leaf_mut
(
)
)
.
parent_idx
.
write
(
idx
)
;
}
}
unsafe
fn
cast_unchecked
<
NewType
>
(
&
mut
self
)
-
>
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
_
>
K
V
NewType
>
marker
:
:
Edge
>
{
Handle
:
:
new_edge
(
self
.
node
.
cast_unchecked
(
)
self
.
idx
)
}
fn
insert_fit
(
&
mut
self
key
:
K
val
:
V
edge
:
Root
<
K
V
>
)
{
debug_assert
!
(
self
.
node
.
len
(
)
<
CAPACITY
)
;
debug_assert
!
(
edge
.
height
=
=
self
.
node
.
height
-
1
)
;
unsafe
{
self
.
cast_unchecked
:
:
<
marker
:
:
Leaf
>
(
)
.
insert_fit
(
key
val
)
;
slice_insert
(
slice
:
:
from_raw_parts_mut
(
MaybeUninit
:
:
slice_as_mut_ptr
(
&
mut
self
.
node
.
as_internal_mut
(
)
.
edges
)
self
.
node
.
len
(
)
)
self
.
idx
+
1
edge
.
node
)
;
for
i
in
(
self
.
idx
+
1
)
.
.
(
self
.
node
.
len
(
)
+
1
)
{
Handle
:
:
new_edge
(
self
.
node
.
reborrow_mut
(
)
i
)
.
correct_parent_link
(
)
;
}
}
}
pub
fn
insert
(
mut
self
key
:
K
val
:
V
edge
:
Root
<
K
V
>
)
-
>
Result
<
InsertResult
<
'
a
K
V
marker
:
:
Internal
>
TryReserveError
>
{
debug_assert
!
(
edge
.
height
=
=
self
.
node
.
height
-
1
)
;
if
self
.
node
.
len
(
)
<
CAPACITY
{
self
.
insert_fit
(
key
val
edge
)
;
Ok
(
InsertResult
:
:
Fit
(
Handle
:
:
new_kv
(
self
.
node
self
.
idx
)
)
)
}
else
{
let
middle
=
Handle
:
:
new_kv
(
self
.
node
B
)
;
let
(
mut
left
k
v
mut
right
)
=
middle
.
split
(
)
?
;
if
self
.
idx
<
=
B
{
unsafe
{
Handle
:
:
new_edge
(
left
.
reborrow_mut
(
)
self
.
idx
)
.
insert_fit
(
key
val
edge
)
;
}
}
else
{
unsafe
{
Handle
:
:
new_edge
(
right
.
as_mut
(
)
.
cast_unchecked
:
:
<
marker
:
:
Internal
>
(
)
self
.
idx
-
(
B
+
1
)
)
.
insert_fit
(
key
val
edge
)
;
}
}
Ok
(
InsertResult
:
:
Split
(
left
k
v
right
)
)
}
}
}
impl
<
BorrowType
K
V
>
Handle
<
NodeRef
<
BorrowType
K
V
marker
:
:
Internal
>
marker
:
:
Edge
>
{
pub
fn
descend
(
self
)
-
>
NodeRef
<
BorrowType
K
V
marker
:
:
LeafOrInternal
>
{
NodeRef
{
height
:
self
.
node
.
height
-
1
node
:
unsafe
{
(
&
*
self
.
node
.
as_internal
(
)
.
edges
.
get_unchecked
(
self
.
idx
)
.
as_ptr
(
)
)
.
as_ptr
(
)
}
root
:
self
.
node
.
root
_marker
:
PhantomData
}
}
}
impl
<
'
a
K
:
'
a
V
:
'
a
NodeType
>
Handle
<
NodeRef
<
marker
:
:
Immut
<
'
a
>
K
V
NodeType
>
marker
:
:
KV
>
{
pub
fn
into_kv
(
self
)
-
>
(
&
'
a
K
&
'
a
V
)
{
let
(
keys
vals
)
=
self
.
node
.
into_slices
(
)
;
unsafe
{
(
keys
.
get_unchecked
(
self
.
idx
)
vals
.
get_unchecked
(
self
.
idx
)
)
}
}
}
impl
<
'
a
K
:
'
a
V
:
'
a
NodeType
>
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
NodeType
>
marker
:
:
KV
>
{
pub
fn
into_kv_mut
(
self
)
-
>
(
&
'
a
mut
K
&
'
a
mut
V
)
{
let
(
keys
vals
)
=
self
.
node
.
into_slices_mut
(
)
;
unsafe
{
(
keys
.
get_unchecked_mut
(
self
.
idx
)
vals
.
get_unchecked_mut
(
self
.
idx
)
)
}
}
}
impl
<
'
a
K
V
NodeType
>
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
NodeType
>
marker
:
:
KV
>
{
pub
fn
kv_mut
(
&
mut
self
)
-
>
(
&
mut
K
&
mut
V
)
{
unsafe
{
let
(
keys
vals
)
=
self
.
node
.
reborrow_mut
(
)
.
into_slices_mut
(
)
;
(
keys
.
get_unchecked_mut
(
self
.
idx
)
vals
.
get_unchecked_mut
(
self
.
idx
)
)
}
}
}
impl
<
'
a
K
V
>
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
Leaf
>
marker
:
:
KV
>
{
pub
fn
split
(
mut
self
)
-
>
Result
<
(
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
Leaf
>
K
V
Root
<
K
V
>
)
TryReserveError
>
{
debug_assert
!
(
!
self
.
node
.
is_shared_root
(
)
)
;
unsafe
{
let
mut
new_node
=
<
Box
<
_
>
as
FallibleBox
<
_
>
>
:
:
try_new
(
LeafNode
:
:
new
(
)
)
?
;
let
k
=
ptr
:
:
read
(
self
.
node
.
keys
(
)
.
get_unchecked
(
self
.
idx
)
)
;
let
v
=
ptr
:
:
read
(
self
.
node
.
vals
(
)
.
get_unchecked
(
self
.
idx
)
)
;
let
new_len
=
self
.
node
.
len
(
)
-
self
.
idx
-
1
;
ptr
:
:
copy_nonoverlapping
(
self
.
node
.
keys
(
)
.
as_ptr
(
)
.
add
(
self
.
idx
+
1
)
new_node
.
keys
.
as_mut_ptr
(
)
as
*
mut
K
new_len
)
;
ptr
:
:
copy_nonoverlapping
(
self
.
node
.
vals
(
)
.
as_ptr
(
)
.
add
(
self
.
idx
+
1
)
new_node
.
vals
.
as_mut_ptr
(
)
as
*
mut
V
new_len
)
;
(
*
self
.
node
.
as_leaf_mut
(
)
)
.
len
=
self
.
idx
as
u16
;
new_node
.
len
=
new_len
as
u16
;
Ok
(
(
self
.
node
k
v
Root
{
node
:
BoxedNode
:
:
from_leaf
(
new_node
)
height
:
0
}
)
)
}
}
pub
fn
remove
(
mut
self
)
-
>
(
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
Leaf
>
marker
:
:
Edge
>
K
V
)
{
debug_assert
!
(
!
self
.
node
.
is_shared_root
(
)
)
;
unsafe
{
let
k
=
slice_remove
(
self
.
node
.
keys_mut
(
)
self
.
idx
)
;
let
v
=
slice_remove
(
self
.
node
.
vals_mut
(
)
self
.
idx
)
;
(
*
self
.
node
.
as_leaf_mut
(
)
)
.
len
-
=
1
;
(
self
.
left_edge
(
)
k
v
)
}
}
}
impl
<
'
a
K
V
>
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
Internal
>
marker
:
:
KV
>
{
pub
fn
split
(
mut
self
)
-
>
Result
<
(
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
Internal
>
K
V
Root
<
K
V
>
)
TryReserveError
>
{
unsafe
{
let
mut
new_node
=
<
Box
<
_
>
as
FallibleBox
<
_
>
>
:
:
try_new
(
InternalNode
:
:
new
(
)
)
?
;
let
k
=
ptr
:
:
read
(
self
.
node
.
keys
(
)
.
get_unchecked
(
self
.
idx
)
)
;
let
v
=
ptr
:
:
read
(
self
.
node
.
vals
(
)
.
get_unchecked
(
self
.
idx
)
)
;
let
height
=
self
.
node
.
height
;
let
new_len
=
self
.
node
.
len
(
)
-
self
.
idx
-
1
;
ptr
:
:
copy_nonoverlapping
(
self
.
node
.
keys
(
)
.
as_ptr
(
)
.
add
(
self
.
idx
+
1
)
new_node
.
data
.
keys
.
as_mut_ptr
(
)
as
*
mut
K
new_len
)
;
ptr
:
:
copy_nonoverlapping
(
self
.
node
.
vals
(
)
.
as_ptr
(
)
.
add
(
self
.
idx
+
1
)
new_node
.
data
.
vals
.
as_mut_ptr
(
)
as
*
mut
V
new_len
)
;
ptr
:
:
copy_nonoverlapping
(
self
.
node
.
as_internal
(
)
.
edges
.
as_ptr
(
)
.
add
(
self
.
idx
+
1
)
new_node
.
edges
.
as_mut_ptr
(
)
new_len
+
1
)
;
(
*
self
.
node
.
as_leaf_mut
(
)
)
.
len
=
self
.
idx
as
u16
;
new_node
.
data
.
len
=
new_len
as
u16
;
let
mut
new_root
=
Root
{
node
:
BoxedNode
:
:
from_internal
(
new_node
)
height
}
;
for
i
in
0
.
.
(
new_len
+
1
)
{
Handle
:
:
new_edge
(
new_root
.
as_mut
(
)
.
cast_unchecked
(
)
i
)
.
correct_parent_link
(
)
;
}
Ok
(
(
self
.
node
k
v
new_root
)
)
}
}
pub
fn
can_merge
(
&
self
)
-
>
bool
{
(
self
.
reborrow
(
)
.
left_edge
(
)
.
descend
(
)
.
len
(
)
+
self
.
reborrow
(
)
.
right_edge
(
)
.
descend
(
)
.
len
(
)
+
1
)
<
=
CAPACITY
}
pub
fn
merge
(
mut
self
)
-
>
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
Internal
>
marker
:
:
Edge
>
{
let
self1
=
unsafe
{
ptr
:
:
read
(
&
self
)
}
;
let
self2
=
unsafe
{
ptr
:
:
read
(
&
self
)
}
;
let
mut
left_node
=
self1
.
left_edge
(
)
.
descend
(
)
;
let
left_len
=
left_node
.
len
(
)
;
let
mut
right_node
=
self2
.
right_edge
(
)
.
descend
(
)
;
let
right_len
=
right_node
.
len
(
)
;
debug_assert
!
(
left_len
+
right_len
+
1
<
=
CAPACITY
)
;
unsafe
{
ptr
:
:
write
(
left_node
.
keys_mut
(
)
.
get_unchecked_mut
(
left_len
)
slice_remove
(
self
.
node
.
keys_mut
(
)
self
.
idx
)
)
;
ptr
:
:
copy_nonoverlapping
(
right_node
.
keys
(
)
.
as_ptr
(
)
left_node
.
keys_mut
(
)
.
as_mut_ptr
(
)
.
add
(
left_len
+
1
)
right_len
)
;
ptr
:
:
write
(
left_node
.
vals_mut
(
)
.
get_unchecked_mut
(
left_len
)
slice_remove
(
self
.
node
.
vals_mut
(
)
self
.
idx
)
)
;
ptr
:
:
copy_nonoverlapping
(
right_node
.
vals
(
)
.
as_ptr
(
)
left_node
.
vals_mut
(
)
.
as_mut_ptr
(
)
.
add
(
left_len
+
1
)
right_len
)
;
slice_remove
(
&
mut
self
.
node
.
as_internal_mut
(
)
.
edges
self
.
idx
+
1
)
;
for
i
in
self
.
idx
+
1
.
.
self
.
node
.
len
(
)
{
Handle
:
:
new_edge
(
self
.
node
.
reborrow_mut
(
)
i
)
.
correct_parent_link
(
)
;
}
(
*
self
.
node
.
as_leaf_mut
(
)
)
.
len
-
=
1
;
(
*
left_node
.
as_leaf_mut
(
)
)
.
len
+
=
right_len
as
u16
+
1
;
if
self
.
node
.
height
>
1
{
ptr
:
:
copy_nonoverlapping
(
right_node
.
cast_unchecked
(
)
.
as_internal
(
)
.
edges
.
as_ptr
(
)
left_node
.
cast_unchecked
(
)
.
as_internal_mut
(
)
.
edges
.
as_mut_ptr
(
)
.
add
(
left_len
+
1
)
right_len
+
1
)
;
for
i
in
left_len
+
1
.
.
left_len
+
right_len
+
2
{
Handle
:
:
new_edge
(
left_node
.
cast_unchecked
(
)
.
reborrow_mut
(
)
i
)
.
correct_parent_link
(
)
;
}
Global
.
deallocate
(
right_node
.
node
.
cast
(
)
Layout
:
:
new
:
:
<
InternalNode
<
K
V
>
>
(
)
)
;
}
else
{
Global
.
deallocate
(
right_node
.
node
.
cast
(
)
Layout
:
:
new
:
:
<
LeafNode
<
K
V
>
>
(
)
)
;
}
Handle
:
:
new_edge
(
self
.
node
self
.
idx
)
}
}
pub
fn
steal_left
(
&
mut
self
)
{
unsafe
{
let
(
k
v
edge
)
=
self
.
reborrow_mut
(
)
.
left_edge
(
)
.
descend
(
)
.
pop
(
)
;
let
k
=
mem
:
:
replace
(
self
.
reborrow_mut
(
)
.
into_kv_mut
(
)
.
0
k
)
;
let
v
=
mem
:
:
replace
(
self
.
reborrow_mut
(
)
.
into_kv_mut
(
)
.
1
v
)
;
match
self
.
reborrow_mut
(
)
.
right_edge
(
)
.
descend
(
)
.
force
(
)
{
ForceResult
:
:
Leaf
(
mut
leaf
)
=
>
leaf
.
push_front
(
k
v
)
ForceResult
:
:
Internal
(
mut
internal
)
=
>
internal
.
push_front
(
k
v
edge
.
unwrap
(
)
)
}
}
}
pub
fn
steal_right
(
&
mut
self
)
{
unsafe
{
let
(
k
v
edge
)
=
self
.
reborrow_mut
(
)
.
right_edge
(
)
.
descend
(
)
.
pop_front
(
)
;
let
k
=
mem
:
:
replace
(
self
.
reborrow_mut
(
)
.
into_kv_mut
(
)
.
0
k
)
;
let
v
=
mem
:
:
replace
(
self
.
reborrow_mut
(
)
.
into_kv_mut
(
)
.
1
v
)
;
match
self
.
reborrow_mut
(
)
.
left_edge
(
)
.
descend
(
)
.
force
(
)
{
ForceResult
:
:
Leaf
(
mut
leaf
)
=
>
leaf
.
push
(
k
v
)
ForceResult
:
:
Internal
(
mut
internal
)
=
>
internal
.
push
(
k
v
edge
.
unwrap
(
)
)
}
}
}
pub
fn
bulk_steal_left
(
&
mut
self
count
:
usize
)
{
unsafe
{
let
mut
left_node
=
ptr
:
:
read
(
self
)
.
left_edge
(
)
.
descend
(
)
;
let
left_len
=
left_node
.
len
(
)
;
let
mut
right_node
=
ptr
:
:
read
(
self
)
.
right_edge
(
)
.
descend
(
)
;
let
right_len
=
right_node
.
len
(
)
;
debug_assert
!
(
right_len
+
count
<
=
CAPACITY
)
;
debug_assert
!
(
left_len
>
=
count
)
;
let
new_left_len
=
left_len
-
count
;
{
let
left_kv
=
left_node
.
reborrow_mut
(
)
.
into_kv_pointers_mut
(
)
;
let
right_kv
=
right_node
.
reborrow_mut
(
)
.
into_kv_pointers_mut
(
)
;
let
parent_kv
=
{
let
kv
=
self
.
reborrow_mut
(
)
.
into_kv_mut
(
)
;
(
kv
.
0
as
*
mut
K
kv
.
1
as
*
mut
V
)
}
;
ptr
:
:
copy
(
right_kv
.
0
right_kv
.
0
.
add
(
count
)
right_len
)
;
ptr
:
:
copy
(
right_kv
.
1
right_kv
.
1
.
add
(
count
)
right_len
)
;
move_kv
(
left_kv
new_left_len
+
1
right_kv
0
count
-
1
)
;
move_kv
(
parent_kv
0
right_kv
count
-
1
1
)
;
move_kv
(
left_kv
new_left_len
parent_kv
0
1
)
;
}
(
*
left_node
.
reborrow_mut
(
)
.
as_leaf_mut
(
)
)
.
len
-
=
count
as
u16
;
(
*
right_node
.
reborrow_mut
(
)
.
as_leaf_mut
(
)
)
.
len
+
=
count
as
u16
;
match
(
left_node
.
force
(
)
right_node
.
force
(
)
)
{
(
ForceResult
:
:
Internal
(
left
)
ForceResult
:
:
Internal
(
mut
right
)
)
=
>
{
let
right_edges
=
right
.
reborrow_mut
(
)
.
as_internal_mut
(
)
.
edges
.
as_mut_ptr
(
)
;
ptr
:
:
copy
(
right_edges
right_edges
.
add
(
count
)
right_len
+
1
)
;
right
.
correct_childrens_parent_links
(
count
count
+
right_len
+
1
)
;
move_edges
(
left
new_left_len
+
1
right
0
count
)
;
}
(
ForceResult
:
:
Leaf
(
_
)
ForceResult
:
:
Leaf
(
_
)
)
=
>
{
}
_
=
>
{
unreachable
!
(
)
;
}
}
}
}
pub
fn
bulk_steal_right
(
&
mut
self
count
:
usize
)
{
unsafe
{
let
mut
left_node
=
ptr
:
:
read
(
self
)
.
left_edge
(
)
.
descend
(
)
;
let
left_len
=
left_node
.
len
(
)
;
let
mut
right_node
=
ptr
:
:
read
(
self
)
.
right_edge
(
)
.
descend
(
)
;
let
right_len
=
right_node
.
len
(
)
;
debug_assert
!
(
left_len
+
count
<
=
CAPACITY
)
;
debug_assert
!
(
right_len
>
=
count
)
;
let
new_right_len
=
right_len
-
count
;
{
let
left_kv
=
left_node
.
reborrow_mut
(
)
.
into_kv_pointers_mut
(
)
;
let
right_kv
=
right_node
.
reborrow_mut
(
)
.
into_kv_pointers_mut
(
)
;
let
parent_kv
=
{
let
kv
=
self
.
reborrow_mut
(
)
.
into_kv_mut
(
)
;
(
kv
.
0
as
*
mut
K
kv
.
1
as
*
mut
V
)
}
;
move_kv
(
parent_kv
0
left_kv
left_len
1
)
;
move_kv
(
right_kv
0
left_kv
left_len
+
1
count
-
1
)
;
move_kv
(
right_kv
count
-
1
parent_kv
0
1
)
;
ptr
:
:
copy
(
right_kv
.
0
.
add
(
count
)
right_kv
.
0
new_right_len
)
;
ptr
:
:
copy
(
right_kv
.
1
.
add
(
count
)
right_kv
.
1
new_right_len
)
;
}
(
*
left_node
.
reborrow_mut
(
)
.
as_leaf_mut
(
)
)
.
len
+
=
count
as
u16
;
(
*
right_node
.
reborrow_mut
(
)
.
as_leaf_mut
(
)
)
.
len
-
=
count
as
u16
;
match
(
left_node
.
force
(
)
right_node
.
force
(
)
)
{
(
ForceResult
:
:
Internal
(
left
)
ForceResult
:
:
Internal
(
mut
right
)
)
=
>
{
move_edges
(
right
.
reborrow_mut
(
)
0
left
left_len
+
1
count
)
;
let
right_edges
=
right
.
reborrow_mut
(
)
.
as_internal_mut
(
)
.
edges
.
as_mut_ptr
(
)
;
ptr
:
:
copy
(
right_edges
.
add
(
count
)
right_edges
new_right_len
+
1
)
;
right
.
correct_childrens_parent_links
(
0
new_right_len
+
1
)
;
}
(
ForceResult
:
:
Leaf
(
_
)
ForceResult
:
:
Leaf
(
_
)
)
=
>
{
}
_
=
>
{
unreachable
!
(
)
;
}
}
}
}
}
unsafe
fn
move_kv
<
K
V
>
(
source
:
(
*
mut
K
*
mut
V
)
source_offset
:
usize
dest
:
(
*
mut
K
*
mut
V
)
dest_offset
:
usize
count
:
usize
)
{
ptr
:
:
copy_nonoverlapping
(
source
.
0
.
add
(
source_offset
)
dest
.
0
.
add
(
dest_offset
)
count
)
;
ptr
:
:
copy_nonoverlapping
(
source
.
1
.
add
(
source_offset
)
dest
.
1
.
add
(
dest_offset
)
count
)
;
}
unsafe
fn
move_edges
<
K
V
>
(
mut
source
:
NodeRef
<
marker
:
:
Mut
<
'
_
>
K
V
marker
:
:
Internal
>
source_offset
:
usize
mut
dest
:
NodeRef
<
marker
:
:
Mut
<
'
_
>
K
V
marker
:
:
Internal
>
dest_offset
:
usize
count
:
usize
)
{
let
source_ptr
=
source
.
as_internal_mut
(
)
.
edges
.
as_mut_ptr
(
)
;
let
dest_ptr
=
dest
.
as_internal_mut
(
)
.
edges
.
as_mut_ptr
(
)
;
ptr
:
:
copy_nonoverlapping
(
source_ptr
.
add
(
source_offset
)
dest_ptr
.
add
(
dest_offset
)
count
)
;
dest
.
correct_childrens_parent_links
(
dest_offset
dest_offset
+
count
)
;
}
impl
<
BorrowType
K
V
HandleType
>
Handle
<
NodeRef
<
BorrowType
K
V
marker
:
:
LeafOrInternal
>
HandleType
>
{
pub
fn
force
(
self
)
-
>
ForceResult
<
Handle
<
NodeRef
<
BorrowType
K
V
marker
:
:
Leaf
>
HandleType
>
Handle
<
NodeRef
<
BorrowType
K
V
marker
:
:
Internal
>
HandleType
>
>
{
match
self
.
node
.
force
(
)
{
ForceResult
:
:
Leaf
(
node
)
=
>
ForceResult
:
:
Leaf
(
Handle
{
node
idx
:
self
.
idx
_marker
:
PhantomData
}
)
ForceResult
:
:
Internal
(
node
)
=
>
ForceResult
:
:
Internal
(
Handle
{
node
idx
:
self
.
idx
_marker
:
PhantomData
}
)
}
}
}
impl
<
'
a
K
V
>
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
LeafOrInternal
>
marker
:
:
Edge
>
{
pub
fn
move_suffix
(
&
mut
self
right
:
&
mut
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
marker
:
:
LeafOrInternal
>
)
{
unsafe
{
let
left_new_len
=
self
.
idx
;
let
mut
left_node
=
self
.
reborrow_mut
(
)
.
into_node
(
)
;
let
right_new_len
=
left_node
.
len
(
)
-
left_new_len
;
let
mut
right_node
=
right
.
reborrow_mut
(
)
;
debug_assert
!
(
right_node
.
len
(
)
=
=
0
)
;
debug_assert
!
(
left_node
.
height
=
=
right_node
.
height
)
;
let
left_kv
=
left_node
.
reborrow_mut
(
)
.
into_kv_pointers_mut
(
)
;
let
right_kv
=
right_node
.
reborrow_mut
(
)
.
into_kv_pointers_mut
(
)
;
move_kv
(
left_kv
left_new_len
right_kv
0
right_new_len
)
;
(
*
left_node
.
reborrow_mut
(
)
.
as_leaf_mut
(
)
)
.
len
=
left_new_len
as
u16
;
(
*
right_node
.
reborrow_mut
(
)
.
as_leaf_mut
(
)
)
.
len
=
right_new_len
as
u16
;
match
(
left_node
.
force
(
)
right_node
.
force
(
)
)
{
(
ForceResult
:
:
Internal
(
left
)
ForceResult
:
:
Internal
(
right
)
)
=
>
{
move_edges
(
left
left_new_len
+
1
right
1
right_new_len
)
;
}
(
ForceResult
:
:
Leaf
(
_
)
ForceResult
:
:
Leaf
(
_
)
)
=
>
{
}
_
=
>
{
unreachable
!
(
)
;
}
}
}
}
}
pub
enum
ForceResult
<
Leaf
Internal
>
{
Leaf
(
Leaf
)
Internal
(
Internal
)
}
pub
enum
InsertResult
<
'
a
K
V
Type
>
{
Fit
(
Handle
<
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
Type
>
marker
:
:
KV
>
)
Split
(
NodeRef
<
marker
:
:
Mut
<
'
a
>
K
V
Type
>
K
V
Root
<
K
V
>
)
}
pub
mod
marker
{
use
core
:
:
marker
:
:
PhantomData
;
pub
enum
Leaf
{
}
pub
enum
Internal
{
}
pub
enum
LeafOrInternal
{
}
pub
enum
Owned
{
}
pub
struct
Immut
<
'
a
>
(
PhantomData
<
&
'
a
(
)
>
)
;
pub
struct
Mut
<
'
a
>
(
PhantomData
<
&
'
a
mut
(
)
>
)
;
pub
enum
KV
{
}
pub
enum
Edge
{
}
}
unsafe
fn
slice_insert
<
T
>
(
slice
:
&
mut
[
T
]
idx
:
usize
val
:
T
)
{
ptr
:
:
copy
(
slice
.
as_ptr
(
)
.
add
(
idx
)
slice
.
as_mut_ptr
(
)
.
add
(
idx
+
1
)
slice
.
len
(
)
-
idx
)
;
ptr
:
:
write
(
slice
.
get_unchecked_mut
(
idx
)
val
)
;
}
unsafe
fn
slice_remove
<
T
>
(
slice
:
&
mut
[
T
]
idx
:
usize
)
-
>
T
{
let
ret
=
ptr
:
:
read
(
slice
.
get_unchecked
(
idx
)
)
;
ptr
:
:
copy
(
slice
.
as_ptr
(
)
.
add
(
idx
+
1
)
slice
.
as_mut_ptr
(
)
.
add
(
idx
)
slice
.
len
(
)
-
idx
-
1
)
;
ret
}
