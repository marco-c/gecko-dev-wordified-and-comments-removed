use
super
:
:
TryClone
;
use
crate
:
:
TryReserveError
;
use
alloc
:
:
alloc
:
:
Layout
;
use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
borrow
:
:
Borrow
;
use
core
:
:
ptr
:
:
NonNull
;
pub
trait
FallibleBox
<
T
>
{
fn
try_new
(
t
:
T
)
-
>
Result
<
Self
TryReserveError
>
where
Self
:
Sized
;
}
pub
struct
TryBox
<
T
>
{
inner
:
Box
<
T
>
}
impl
<
T
>
TryBox
<
T
>
{
pub
fn
try_new
(
t
:
T
)
-
>
Result
<
Self
TryReserveError
>
{
Ok
(
Self
{
inner
:
Box
:
:
try_new
(
t
)
?
}
)
}
pub
fn
into_raw
(
b
:
TryBox
<
T
>
)
-
>
*
mut
T
{
Box
:
:
into_raw
(
b
.
inner
)
}
pub
unsafe
fn
from_raw
(
raw
:
*
mut
T
)
-
>
Self
{
Self
{
inner
:
Box
:
:
from_raw
(
raw
)
}
}
}
impl
<
T
:
TryClone
>
TryClone
for
TryBox
<
T
>
{
fn
try_clone
(
&
self
)
-
>
Result
<
Self
TryReserveError
>
{
let
clone
:
T
=
(
*
self
.
inner
)
.
try_clone
(
)
?
;
Self
:
:
try_new
(
clone
)
}
}
fn
alloc
(
layout
:
Layout
)
-
>
Result
<
NonNull
<
u8
>
TryReserveError
>
{
#
[
cfg
(
feature
=
"
unstable
"
)
]
{
use
core
:
:
alloc
:
:
AllocRef
as
_
;
let
mut
g
=
alloc
:
:
alloc
:
:
Global
;
g
.
alloc
(
layout
alloc
:
:
alloc
:
:
AllocInit
:
:
Uninitialized
)
.
map_err
(
|
_e
|
TryReserveError
:
:
AllocError
{
layout
non_exhaustive
:
(
)
}
)
.
map
(
|
memory_block
|
memory_block
.
ptr
)
}
#
[
cfg
(
not
(
feature
=
"
unstable
"
)
)
]
{
match
layout
.
size
(
)
{
0
=
>
{
Ok
(
NonNull
:
:
dangling
(
)
)
}
1
.
.
=
core
:
:
usize
:
:
MAX
=
>
{
let
ptr
=
unsafe
{
alloc
:
:
alloc
:
:
alloc
(
layout
)
}
;
core
:
:
ptr
:
:
NonNull
:
:
new
(
ptr
)
.
ok_or
(
TryReserveError
:
:
AllocErr
{
layout
}
)
}
_
=
>
unreachable
!
(
"
size
must
be
non
-
negative
"
)
}
}
}
impl
<
T
>
FallibleBox
<
T
>
for
Box
<
T
>
{
fn
try_new
(
t
:
T
)
-
>
Result
<
Self
TryReserveError
>
{
let
layout
=
Layout
:
:
for_value
(
&
t
)
;
let
ptr
=
alloc
(
layout
)
?
.
as_ptr
(
)
as
*
mut
T
;
unsafe
{
core
:
:
ptr
:
:
write
(
ptr
t
)
;
Ok
(
Box
:
:
from_raw
(
ptr
)
)
}
}
}
impl
<
T
:
TryClone
>
TryClone
for
Box
<
T
>
{
fn
try_clone
(
&
self
)
-
>
Result
<
Self
TryReserveError
>
{
Self
:
:
try_new
(
Borrow
:
:
<
T
>
:
:
borrow
(
self
)
.
try_clone
(
)
?
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
boxed
(
)
{
let
mut
v
=
Box
:
:
try_new
(
5
)
.
unwrap
(
)
;
assert_eq
!
(
*
v
5
)
;
*
v
=
3
;
assert_eq
!
(
*
v
3
)
;
}
#
[
test
]
fn
trybox_zst
(
)
{
let
b
=
Box
:
:
try_new
(
(
)
)
.
expect
(
"
ok
"
)
;
assert_eq
!
(
b
Box
:
:
new
(
(
)
)
)
;
}
}
