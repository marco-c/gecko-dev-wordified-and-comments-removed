use
crate
:
:
{
abort_now
check_correctness
sealed
:
:
Sealed
SpanRange
}
;
use
proc_macro2
:
:
Span
;
use
proc_macro2
:
:
TokenStream
;
use
quote
:
:
{
quote_spanned
ToTokens
}
;
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
Level
{
Error
Warning
#
[
doc
(
hidden
)
]
NonExhaustive
}
#
[
derive
(
Debug
)
]
pub
struct
Diagnostic
{
pub
(
crate
)
level
:
Level
pub
(
crate
)
span_range
:
SpanRange
pub
(
crate
)
msg
:
String
pub
(
crate
)
suggestions
:
Vec
<
(
SuggestionKind
String
Option
<
SpanRange
>
)
>
pub
(
crate
)
children
:
Vec
<
(
SpanRange
String
)
>
}
pub
trait
DiagnosticExt
:
Sealed
{
fn
spanned_range
(
span_range
:
SpanRange
level
:
Level
message
:
String
)
-
>
Self
;
fn
span_range_error
(
self
span_range
:
SpanRange
msg
:
String
)
-
>
Self
;
fn
span_range_help
(
self
span_range
:
SpanRange
msg
:
String
)
-
>
Self
;
fn
span_range_note
(
self
span_range
:
SpanRange
msg
:
String
)
-
>
Self
;
}
impl
DiagnosticExt
for
Diagnostic
{
fn
spanned_range
(
span_range
:
SpanRange
level
:
Level
message
:
String
)
-
>
Self
{
Diagnostic
{
level
span_range
msg
:
message
suggestions
:
vec
!
[
]
children
:
vec
!
[
]
}
}
fn
span_range_error
(
mut
self
span_range
:
SpanRange
msg
:
String
)
-
>
Self
{
self
.
children
.
push
(
(
span_range
msg
)
)
;
self
}
fn
span_range_help
(
mut
self
span_range
:
SpanRange
msg
:
String
)
-
>
Self
{
self
.
suggestions
.
push
(
(
SuggestionKind
:
:
Help
msg
Some
(
span_range
)
)
)
;
self
}
fn
span_range_note
(
mut
self
span_range
:
SpanRange
msg
:
String
)
-
>
Self
{
self
.
suggestions
.
push
(
(
SuggestionKind
:
:
Note
msg
Some
(
span_range
)
)
)
;
self
}
}
impl
Diagnostic
{
pub
fn
new
(
level
:
Level
message
:
String
)
-
>
Self
{
Diagnostic
:
:
spanned
(
Span
:
:
call_site
(
)
level
message
)
}
pub
fn
spanned
(
span
:
Span
level
:
Level
message
:
String
)
-
>
Self
{
Diagnostic
:
:
spanned_range
(
SpanRange
{
first
:
span
last
:
span
}
level
message
)
}
pub
fn
span_error
(
self
span
:
Span
msg
:
String
)
-
>
Self
{
self
.
span_range_error
(
SpanRange
{
first
:
span
last
:
span
}
msg
)
}
pub
fn
span_help
(
self
span
:
Span
msg
:
String
)
-
>
Self
{
self
.
span_range_help
(
SpanRange
{
first
:
span
last
:
span
}
msg
)
}
pub
fn
help
(
mut
self
msg
:
String
)
-
>
Self
{
self
.
suggestions
.
push
(
(
SuggestionKind
:
:
Help
msg
None
)
)
;
self
}
pub
fn
span_note
(
self
span
:
Span
msg
:
String
)
-
>
Self
{
self
.
span_range_note
(
SpanRange
{
first
:
span
last
:
span
}
msg
)
}
pub
fn
note
(
mut
self
msg
:
String
)
-
>
Self
{
self
.
suggestions
.
push
(
(
SuggestionKind
:
:
Note
msg
None
)
)
;
self
}
pub
fn
message
(
&
self
)
-
>
&
str
{
&
self
.
msg
}
pub
fn
abort
(
self
)
-
>
!
{
self
.
emit
(
)
;
abort_now
(
)
}
pub
fn
emit
(
self
)
{
check_correctness
(
)
;
crate
:
:
imp
:
:
emit_diagnostic
(
self
)
;
}
}
#
[
doc
(
hidden
)
]
impl
Diagnostic
{
pub
fn
span_suggestion
(
self
span
:
Span
suggestion
:
&
str
msg
:
String
)
-
>
Self
{
match
suggestion
{
"
help
"
|
"
hint
"
=
>
self
.
span_help
(
span
msg
)
_
=
>
self
.
span_note
(
span
msg
)
}
}
pub
fn
suggestion
(
self
suggestion
:
&
str
msg
:
String
)
-
>
Self
{
match
suggestion
{
"
help
"
|
"
hint
"
=
>
self
.
help
(
msg
)
_
=
>
self
.
note
(
msg
)
}
}
}
impl
ToTokens
for
Diagnostic
{
fn
to_tokens
(
&
self
ts
:
&
mut
TokenStream
)
{
use
std
:
:
borrow
:
:
Cow
;
fn
ensure_lf
(
buf
:
&
mut
String
s
:
&
str
)
{
if
s
.
ends_with
(
'
\
n
'
)
{
buf
.
push_str
(
s
)
;
}
else
{
buf
.
push_str
(
s
)
;
buf
.
push
(
'
\
n
'
)
;
}
}
fn
diag_to_tokens
(
span_range
:
SpanRange
level
:
&
Level
msg
:
&
str
suggestions
:
&
[
(
SuggestionKind
String
Option
<
SpanRange
>
)
]
)
-
>
TokenStream
{
if
*
level
=
=
Level
:
:
Warning
{
return
TokenStream
:
:
new
(
)
;
}
let
message
=
if
suggestions
.
is_empty
(
)
{
Cow
:
:
Borrowed
(
msg
)
}
else
{
let
mut
message
=
String
:
:
new
(
)
;
ensure_lf
(
&
mut
message
msg
)
;
message
.
push
(
'
\
n
'
)
;
for
(
kind
note
_span
)
in
suggestions
{
message
.
push_str
(
"
=
"
)
;
message
.
push_str
(
kind
.
name
(
)
)
;
message
.
push_str
(
"
:
"
)
;
ensure_lf
(
&
mut
message
note
)
;
}
message
.
push
(
'
\
n
'
)
;
Cow
:
:
Owned
(
message
)
}
;
let
mut
msg
=
proc_macro2
:
:
Literal
:
:
string
(
&
message
)
;
msg
.
set_span
(
span_range
.
last
)
;
let
group
=
quote_spanned
!
(
span_range
.
last
=
>
{
#
msg
}
)
;
quote_spanned
!
(
span_range
.
first
=
>
compile_error
!
#
group
)
}
ts
.
extend
(
diag_to_tokens
(
self
.
span_range
&
self
.
level
&
self
.
msg
&
self
.
suggestions
)
)
;
ts
.
extend
(
self
.
children
.
iter
(
)
.
map
(
|
(
span_range
msg
)
|
diag_to_tokens
(
*
span_range
&
Level
:
:
Error
&
msg
&
[
]
)
)
)
;
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
enum
SuggestionKind
{
Help
Note
}
impl
SuggestionKind
{
fn
name
(
&
self
)
-
>
&
'
static
str
{
match
self
{
SuggestionKind
:
:
Note
=
>
"
note
"
SuggestionKind
:
:
Help
=
>
"
help
"
}
}
}
#
[
cfg
(
feature
=
"
syn
-
error
"
)
]
impl
From
<
syn
:
:
Error
>
for
Diagnostic
{
fn
from
(
err
:
syn
:
:
Error
)
-
>
Self
{
use
proc_macro2
:
:
{
Delimiter
TokenTree
}
;
fn
gut_error
(
ts
:
&
mut
impl
Iterator
<
Item
=
TokenTree
>
)
-
>
Option
<
(
SpanRange
String
)
>
{
let
first
=
match
ts
.
next
(
)
{
None
=
>
return
None
Some
(
tt
)
=
>
tt
.
span
(
)
}
;
ts
.
next
(
)
.
unwrap
(
)
;
let
lit
=
match
ts
.
next
(
)
.
unwrap
(
)
{
TokenTree
:
:
Group
(
group
)
=
>
{
if
group
.
delimiter
(
)
=
=
Delimiter
:
:
Parenthesis
|
|
group
.
delimiter
(
)
=
=
Delimiter
:
:
Bracket
{
ts
.
next
(
)
.
unwrap
(
)
;
}
match
group
.
stream
(
)
.
into_iter
(
)
.
next
(
)
.
unwrap
(
)
{
TokenTree
:
:
Literal
(
lit
)
=
>
lit
_
=
>
unreachable
!
(
)
}
}
_
=
>
unreachable
!
(
)
}
;
let
last
=
lit
.
span
(
)
;
let
mut
msg
=
lit
.
to_string
(
)
;
msg
.
pop
(
)
;
msg
.
remove
(
0
)
;
Some
(
(
SpanRange
{
first
last
}
msg
)
)
}
let
mut
ts
=
err
.
to_compile_error
(
)
.
into_iter
(
)
;
let
(
span_range
msg
)
=
gut_error
(
&
mut
ts
)
.
unwrap
(
)
;
let
mut
res
=
Diagnostic
:
:
spanned_range
(
span_range
Level
:
:
Error
msg
)
;
while
let
Some
(
(
span_range
msg
)
)
=
gut_error
(
&
mut
ts
)
{
res
=
res
.
span_range_error
(
span_range
msg
)
;
}
res
}
}
