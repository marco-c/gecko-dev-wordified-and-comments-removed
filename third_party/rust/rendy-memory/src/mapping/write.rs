use
std
:
:
ptr
:
:
copy_nonoverlapping
;
pub
trait
Write
<
T
:
Copy
>
{
unsafe
fn
slice
(
&
mut
self
)
-
>
&
mut
[
T
]
;
fn
write
(
&
mut
self
data
:
&
[
T
]
)
{
unsafe
{
let
slice
=
self
.
slice
(
)
;
assert
!
(
data
.
len
(
)
<
=
slice
.
len
(
)
)
;
copy_nonoverlapping
(
data
.
as_ptr
(
)
slice
.
as_mut_ptr
(
)
data
.
len
(
)
)
;
}
}
}
#
[
derive
(
Debug
)
]
pub
(
super
)
struct
WriteFlush
<
'
a
T
F
:
FnOnce
(
)
+
'
a
>
{
pub
(
super
)
slice
:
&
'
a
mut
[
T
]
pub
(
super
)
flush
:
Option
<
F
>
}
impl
<
'
a
T
F
>
Drop
for
WriteFlush
<
'
a
T
F
>
where
T
:
'
a
F
:
FnOnce
(
)
+
'
a
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
f
)
=
self
.
flush
.
take
(
)
{
f
(
)
;
}
}
}
impl
<
'
a
T
F
>
Write
<
T
>
for
WriteFlush
<
'
a
T
F
>
where
T
:
Copy
+
'
a
F
:
FnOnce
(
)
+
'
a
{
unsafe
fn
slice
(
&
mut
self
)
-
>
&
mut
[
T
]
{
self
.
slice
}
}
#
[
warn
(
dead_code
)
]
#
[
derive
(
Debug
)
]
pub
(
super
)
struct
WriteCoherent
<
'
a
T
>
{
pub
(
super
)
slice
:
&
'
a
mut
[
T
]
}
impl
<
'
a
T
>
Write
<
T
>
for
WriteCoherent
<
'
a
T
>
where
T
:
Copy
+
'
a
{
unsafe
fn
slice
(
&
mut
self
)
-
>
&
mut
[
T
]
{
self
.
slice
}
}
