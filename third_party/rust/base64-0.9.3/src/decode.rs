use
byteorder
:
:
{
BigEndian
ByteOrder
}
;
use
{
tables
CharacterSet
Config
STANDARD
}
;
use
std
:
:
{
error
fmt
str
}
;
const
INPUT_CHUNK_LEN
:
usize
=
8
;
const
DECODED_CHUNK_LEN
:
usize
=
6
;
const
DECODED_CHUNK_SUFFIX
:
usize
=
2
;
const
CHUNKS_PER_FAST_LOOP_BLOCK
:
usize
=
4
;
const
INPUT_BLOCK_LEN
:
usize
=
CHUNKS_PER_FAST_LOOP_BLOCK
*
INPUT_CHUNK_LEN
;
const
DECODED_BLOCK_LEN
:
usize
=
CHUNKS_PER_FAST_LOOP_BLOCK
*
DECODED_CHUNK_LEN
+
DECODED_CHUNK_SUFFIX
;
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
enum
DecodeError
{
InvalidByte
(
usize
u8
)
InvalidLength
}
impl
fmt
:
:
Display
for
DecodeError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
DecodeError
:
:
InvalidByte
(
index
byte
)
=
>
{
write
!
(
f
"
Invalid
byte
{
}
offset
{
}
.
"
byte
index
)
}
DecodeError
:
:
InvalidLength
=
>
write
!
(
f
"
Encoded
text
cannot
have
a
6
-
bit
remainder
.
"
)
}
}
}
impl
error
:
:
Error
for
DecodeError
{
fn
description
(
&
self
)
-
>
&
str
{
match
*
self
{
DecodeError
:
:
InvalidByte
(
_
_
)
=
>
"
invalid
byte
"
DecodeError
:
:
InvalidLength
=
>
"
invalid
length
"
}
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
None
}
}
pub
fn
decode
<
T
:
?
Sized
+
AsRef
<
[
u8
]
>
>
(
input
:
&
T
)
-
>
Result
<
Vec
<
u8
>
DecodeError
>
{
decode_config
(
input
STANDARD
)
}
pub
fn
decode_config
<
T
:
?
Sized
+
AsRef
<
[
u8
]
>
>
(
input
:
&
T
config
:
Config
)
-
>
Result
<
Vec
<
u8
>
DecodeError
>
{
let
mut
buffer
=
Vec
:
:
<
u8
>
:
:
with_capacity
(
input
.
as_ref
(
)
.
len
(
)
*
4
/
3
)
;
decode_config_buf
(
input
config
&
mut
buffer
)
.
map
(
|
_
|
buffer
)
}
pub
fn
decode_config_buf
<
T
:
?
Sized
+
AsRef
<
[
u8
]
>
>
(
input
:
&
T
config
:
Config
buffer
:
&
mut
Vec
<
u8
>
)
-
>
Result
<
(
)
DecodeError
>
{
let
input_copy
;
let
input_bytes
=
if
config
.
strip_whitespace
{
input_copy
=
copy_without_whitespace
(
input
.
as_ref
(
)
)
;
input_copy
.
as_ref
(
)
}
else
{
input
.
as_ref
(
)
}
;
let
starting_output_len
=
buffer
.
len
(
)
;
let
num_chunks
=
num_chunks
(
input_bytes
)
;
let
decoded_len_estimate
=
num_chunks
.
checked_mul
(
DECODED_CHUNK_LEN
)
.
and_then
(
|
p
|
p
.
checked_add
(
starting_output_len
)
)
.
expect
(
"
Overflow
when
calculating
output
buffer
length
"
)
;
buffer
.
resize
(
decoded_len_estimate
0
)
;
let
bytes_written
;
{
let
buffer_slice
=
&
mut
buffer
.
as_mut_slice
(
)
[
starting_output_len
.
.
]
;
bytes_written
=
decode_helper
(
input_bytes
num_chunks
&
config
.
char_set
buffer_slice
)
?
;
}
buffer
.
truncate
(
starting_output_len
+
bytes_written
)
;
Ok
(
(
)
)
}
pub
fn
decode_config_slice
<
T
:
?
Sized
+
AsRef
<
[
u8
]
>
>
(
input
:
&
T
config
:
Config
output
:
&
mut
[
u8
]
)
-
>
Result
<
usize
DecodeError
>
{
let
input_copy
;
let
input_bytes
=
if
config
.
strip_whitespace
{
input_copy
=
copy_without_whitespace
(
input
.
as_ref
(
)
)
;
input_copy
.
as_ref
(
)
}
else
{
input
.
as_ref
(
)
}
;
decode_helper
(
input_bytes
num_chunks
(
input_bytes
)
&
config
.
char_set
output
)
}
fn
num_chunks
(
input
:
&
[
u8
]
)
-
>
usize
{
input
.
len
(
)
.
checked_add
(
INPUT_CHUNK_LEN
-
1
)
.
expect
(
"
Overflow
when
calculating
number
of
chunks
in
input
"
)
/
INPUT_CHUNK_LEN
}
fn
copy_without_whitespace
(
input
:
&
[
u8
]
)
-
>
Vec
<
u8
>
{
let
mut
input_copy
=
Vec
:
:
<
u8
>
:
:
with_capacity
(
input
.
len
(
)
)
;
input_copy
.
extend
(
input
.
iter
(
)
.
filter
(
|
b
|
!
b
"
\
n
\
t
\
r
\
x0b
\
x0c
"
.
contains
(
b
)
)
)
;
input_copy
}
#
[
inline
]
fn
decode_helper
(
input
:
&
[
u8
]
num_chunks
:
usize
char_set
:
&
CharacterSet
output
:
&
mut
[
u8
]
)
-
>
Result
<
usize
DecodeError
>
{
let
decode_table
=
char_set
.
decode_table
(
)
;
let
remainder_len
=
input
.
len
(
)
%
INPUT_CHUNK_LEN
;
let
trailing_bytes_to_skip
=
match
remainder_len
{
0
=
>
INPUT_CHUNK_LEN
1
|
5
=
>
return
Err
(
DecodeError
:
:
InvalidLength
)
2
=
>
INPUT_CHUNK_LEN
+
2
3
=
>
INPUT_CHUNK_LEN
+
3
4
=
>
INPUT_CHUNK_LEN
+
4
_
=
>
remainder_len
}
;
let
mut
remaining_chunks
=
num_chunks
;
let
mut
input_index
=
0
;
let
mut
output_index
=
0
;
{
let
length_of_fast_decode_chunks
=
input
.
len
(
)
.
saturating_sub
(
trailing_bytes_to_skip
)
;
if
let
Some
(
max_start_index
)
=
length_of_fast_decode_chunks
.
checked_sub
(
INPUT_BLOCK_LEN
)
{
while
input_index
<
=
max_start_index
{
let
input_slice
=
&
input
[
input_index
.
.
(
input_index
+
INPUT_BLOCK_LEN
)
]
;
let
output_slice
=
&
mut
output
[
output_index
.
.
(
output_index
+
DECODED_BLOCK_LEN
)
]
;
decode_chunk
(
&
input_slice
[
0
.
.
]
input_index
decode_table
&
mut
output_slice
[
0
.
.
]
)
?
;
decode_chunk
(
&
input_slice
[
8
.
.
]
input_index
+
8
decode_table
&
mut
output_slice
[
6
.
.
]
)
?
;
decode_chunk
(
&
input_slice
[
16
.
.
]
input_index
+
16
decode_table
&
mut
output_slice
[
12
.
.
]
)
?
;
decode_chunk
(
&
input_slice
[
24
.
.
]
input_index
+
24
decode_table
&
mut
output_slice
[
18
.
.
]
)
?
;
input_index
+
=
INPUT_BLOCK_LEN
;
output_index
+
=
DECODED_BLOCK_LEN
-
DECODED_CHUNK_SUFFIX
;
remaining_chunks
-
=
CHUNKS_PER_FAST_LOOP_BLOCK
;
}
}
if
let
Some
(
max_start_index
)
=
length_of_fast_decode_chunks
.
checked_sub
(
INPUT_CHUNK_LEN
)
{
while
input_index
<
max_start_index
{
decode_chunk
(
&
input
[
input_index
.
.
(
input_index
+
INPUT_CHUNK_LEN
)
]
input_index
decode_table
&
mut
output
[
output_index
.
.
(
output_index
+
DECODED_CHUNK_LEN
+
DECODED_CHUNK_SUFFIX
)
]
)
?
;
output_index
+
=
DECODED_CHUNK_LEN
;
input_index
+
=
INPUT_CHUNK_LEN
;
remaining_chunks
-
=
1
;
}
}
}
for
_
in
1
.
.
remaining_chunks
{
decode_chunk_precise
(
&
input
[
input_index
.
.
]
input_index
decode_table
&
mut
output
[
output_index
.
.
(
output_index
+
DECODED_CHUNK_LEN
)
]
)
?
;
input_index
+
=
INPUT_CHUNK_LEN
;
output_index
+
=
DECODED_CHUNK_LEN
;
}
let
mut
leftover_bits
:
u64
=
0
;
let
mut
morsels_in_leftover
=
0
;
let
mut
padding_bytes
=
0
;
let
mut
first_padding_index
:
usize
=
0
;
let
start_of_leftovers
=
input_index
;
for
(
i
b
)
in
input
[
start_of_leftovers
.
.
]
.
iter
(
)
.
enumerate
(
)
{
if
*
b
=
=
0x3D
{
if
i
%
4
<
2
{
let
bad_padding_index
=
start_of_leftovers
+
if
padding_bytes
>
0
{
first_padding_index
}
else
{
i
}
;
return
Err
(
DecodeError
:
:
InvalidByte
(
bad_padding_index
*
b
)
)
;
}
if
padding_bytes
=
=
0
{
first_padding_index
=
i
;
}
padding_bytes
+
=
1
;
continue
;
}
if
padding_bytes
>
0
{
return
Err
(
DecodeError
:
:
InvalidByte
(
start_of_leftovers
+
first_padding_index
0x3D
)
)
;
}
let
shift
=
64
-
(
morsels_in_leftover
+
1
)
*
6
;
let
morsel
=
decode_table
[
*
b
as
usize
]
;
if
morsel
=
=
tables
:
:
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
start_of_leftovers
+
i
*
b
)
)
;
}
leftover_bits
|
=
(
morsel
as
u64
)
<
<
shift
;
morsels_in_leftover
+
=
1
;
}
let
leftover_bits_ready_to_append
=
match
morsels_in_leftover
{
0
=
>
0
2
=
>
8
3
=
>
16
4
=
>
24
6
=
>
32
7
=
>
40
8
=
>
48
_
=
>
unreachable
!
(
"
Impossible
:
must
only
have
0
to
8
input
bytes
in
last
chunk
with
no
invalid
lengths
"
)
}
;
let
mut
leftover_bits_appended_to_buf
=
0
;
while
leftover_bits_appended_to_buf
<
leftover_bits_ready_to_append
{
let
selected_bits
=
(
leftover_bits
>
>
(
56
-
leftover_bits_appended_to_buf
)
)
as
u8
;
output
[
output_index
]
=
selected_bits
;
output_index
+
=
1
;
leftover_bits_appended_to_buf
+
=
8
;
}
Ok
(
output_index
)
}
#
[
inline
(
always
)
]
fn
decode_chunk
(
input
:
&
[
u8
]
index_at_start_of_input
:
usize
decode_table
:
&
[
u8
;
256
]
output
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
DecodeError
>
{
let
mut
accum
:
u64
;
let
morsel
=
decode_table
[
input
[
0
]
as
usize
]
;
if
morsel
=
=
tables
:
:
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
input
[
0
]
)
)
;
}
accum
=
(
morsel
as
u64
)
<
<
58
;
let
morsel
=
decode_table
[
input
[
1
]
as
usize
]
;
if
morsel
=
=
tables
:
:
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
1
input
[
1
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
52
;
let
morsel
=
decode_table
[
input
[
2
]
as
usize
]
;
if
morsel
=
=
tables
:
:
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
2
input
[
2
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
46
;
let
morsel
=
decode_table
[
input
[
3
]
as
usize
]
;
if
morsel
=
=
tables
:
:
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
3
input
[
3
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
40
;
let
morsel
=
decode_table
[
input
[
4
]
as
usize
]
;
if
morsel
=
=
tables
:
:
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
4
input
[
4
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
34
;
let
morsel
=
decode_table
[
input
[
5
]
as
usize
]
;
if
morsel
=
=
tables
:
:
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
5
input
[
5
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
28
;
let
morsel
=
decode_table
[
input
[
6
]
as
usize
]
;
if
morsel
=
=
tables
:
:
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
6
input
[
6
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
22
;
let
morsel
=
decode_table
[
input
[
7
]
as
usize
]
;
if
morsel
=
=
tables
:
:
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
7
input
[
7
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
16
;
BigEndian
:
:
write_u64
(
output
accum
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
decode_chunk_precise
(
input
:
&
[
u8
]
index_at_start_of_input
:
usize
decode_table
:
&
[
u8
;
256
]
output
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
DecodeError
>
{
let
mut
tmp_buf
=
[
0_u8
;
8
]
;
decode_chunk
(
input
index_at_start_of_input
decode_table
&
mut
tmp_buf
[
.
.
]
)
?
;
output
[
0
.
.
6
]
.
copy_from_slice
(
&
tmp_buf
[
0
.
.
6
]
)
;
Ok
(
(
)
)
}
#
[
cfg
(
test
)
]
mod
tests
{
extern
crate
rand
;
use
super
:
:
*
;
use
encode
:
:
encode_config_buf
;
use
tests
:
:
{
assert_encode_sanity
random_config
}
;
use
self
:
:
rand
:
:
distributions
:
:
{
IndependentSample
Range
}
;
use
self
:
:
rand
:
:
Rng
;
#
[
test
]
fn
decode_chunk_precise_writes_only_6_bytes
(
)
{
let
input
=
b
"
Zm9vYmFy
"
;
let
mut
output
=
[
0_u8
1
2
3
4
5
6
7
]
;
decode_chunk_precise
(
&
input
[
.
.
]
0
tables
:
:
STANDARD_DECODE
&
mut
output
)
.
unwrap
(
)
;
assert_eq
!
(
&
vec
!
[
b
'
f
'
b
'
o
'
b
'
o
'
b
'
b
'
b
'
a
'
b
'
r
'
6
7
]
&
output
)
;
}
#
[
test
]
fn
decode_chunk_writes_8_bytes
(
)
{
let
input
=
b
"
Zm9vYmFy
"
;
let
mut
output
=
[
0_u8
1
2
3
4
5
6
7
]
;
decode_chunk
(
&
input
[
.
.
]
0
tables
:
:
STANDARD_DECODE
&
mut
output
)
.
unwrap
(
)
;
assert_eq
!
(
&
vec
!
[
b
'
f
'
b
'
o
'
b
'
o
'
b
'
b
'
b
'
a
'
b
'
r
'
0
0
]
&
output
)
;
}
#
[
test
]
fn
decode_into_nonempty_vec_doesnt_clobber_existing_prefix
(
)
{
let
mut
orig_data
=
Vec
:
:
new
(
)
;
let
mut
encoded_data
=
String
:
:
new
(
)
;
let
mut
decoded_with_prefix
=
Vec
:
:
new
(
)
;
let
mut
decoded_without_prefix
=
Vec
:
:
new
(
)
;
let
mut
prefix
=
Vec
:
:
new
(
)
;
let
prefix_len_range
=
Range
:
:
new
(
0
1000
)
;
let
input_len_range
=
Range
:
:
new
(
0
1000
)
;
let
line_len_range
=
Range
:
:
new
(
1
1000
)
;
let
mut
rng
=
rand
:
:
weak_rng
(
)
;
for
_
in
0
.
.
10_000
{
orig_data
.
clear
(
)
;
encoded_data
.
clear
(
)
;
decoded_with_prefix
.
clear
(
)
;
decoded_without_prefix
.
clear
(
)
;
prefix
.
clear
(
)
;
let
input_len
=
input_len_range
.
ind_sample
(
&
mut
rng
)
;
for
_
in
0
.
.
input_len
{
orig_data
.
push
(
rng
.
gen
(
)
)
;
}
let
config
=
random_config
(
&
mut
rng
&
line_len_range
)
;
encode_config_buf
(
&
orig_data
config
&
mut
encoded_data
)
;
assert_encode_sanity
(
&
encoded_data
&
config
input_len
)
;
let
prefix_len
=
prefix_len_range
.
ind_sample
(
&
mut
rng
)
;
for
_
in
0
.
.
prefix_len
{
prefix
.
push
(
rng
.
gen
(
)
)
;
}
decoded_with_prefix
.
resize
(
prefix_len
0
)
;
decoded_with_prefix
.
copy_from_slice
(
&
prefix
)
;
decode_config_buf
(
&
encoded_data
config
&
mut
decoded_with_prefix
)
.
unwrap
(
)
;
decode_config_buf
(
&
encoded_data
config
&
mut
decoded_without_prefix
)
.
unwrap
(
)
;
assert_eq
!
(
prefix_len
+
decoded_without_prefix
.
len
(
)
decoded_with_prefix
.
len
(
)
)
;
assert_eq
!
(
orig_data
decoded_without_prefix
)
;
prefix
.
append
(
&
mut
decoded_without_prefix
)
;
assert_eq
!
(
prefix
decoded_with_prefix
)
;
}
}
#
[
test
]
fn
decode_into_slice_doesnt_clobber_existing_prefix_or_suffix
(
)
{
let
mut
orig_data
=
Vec
:
:
new
(
)
;
let
mut
encoded_data
=
String
:
:
new
(
)
;
let
mut
decode_buf
=
Vec
:
:
new
(
)
;
let
mut
decode_buf_copy
:
Vec
<
u8
>
=
Vec
:
:
new
(
)
;
let
input_len_range
=
Range
:
:
new
(
0
1000
)
;
let
line_len_range
=
Range
:
:
new
(
1
1000
)
;
let
mut
rng
=
rand
:
:
weak_rng
(
)
;
for
_
in
0
.
.
10_000
{
orig_data
.
clear
(
)
;
encoded_data
.
clear
(
)
;
decode_buf
.
clear
(
)
;
decode_buf_copy
.
clear
(
)
;
let
input_len
=
input_len_range
.
ind_sample
(
&
mut
rng
)
;
for
_
in
0
.
.
input_len
{
orig_data
.
push
(
rng
.
gen
(
)
)
;
}
let
config
=
random_config
(
&
mut
rng
&
line_len_range
)
;
encode_config_buf
(
&
orig_data
config
&
mut
encoded_data
)
;
assert_encode_sanity
(
&
encoded_data
&
config
input_len
)
;
for
_
in
0
.
.
5000
{
decode_buf
.
push
(
rng
.
gen
(
)
)
;
}
decode_buf_copy
.
extend
(
decode_buf
.
iter
(
)
)
;
let
offset
=
1000
;
let
decode_bytes_written
=
decode_config_slice
(
&
encoded_data
config
&
mut
decode_buf
[
offset
.
.
]
)
.
unwrap
(
)
;
assert_eq
!
(
orig_data
.
len
(
)
decode_bytes_written
)
;
assert_eq
!
(
orig_data
&
decode_buf
[
offset
.
.
(
offset
+
decode_bytes_written
)
]
)
;
assert_eq
!
(
&
decode_buf_copy
[
0
.
.
offset
]
&
decode_buf
[
0
.
.
offset
]
)
;
assert_eq
!
(
&
decode_buf_copy
[
offset
+
decode_bytes_written
.
.
]
&
decode_buf
[
offset
+
decode_bytes_written
.
.
]
)
;
}
}
#
[
test
]
fn
decode_into_slice_fits_in_precisely_sized_slice
(
)
{
let
mut
orig_data
=
Vec
:
:
new
(
)
;
let
mut
encoded_data
=
String
:
:
new
(
)
;
let
mut
decode_buf
=
Vec
:
:
new
(
)
;
let
input_len_range
=
Range
:
:
new
(
0
1000
)
;
let
line_len_range
=
Range
:
:
new
(
1
1000
)
;
let
mut
rng
=
rand
:
:
weak_rng
(
)
;
for
_
in
0
.
.
10_000
{
orig_data
.
clear
(
)
;
encoded_data
.
clear
(
)
;
decode_buf
.
clear
(
)
;
let
input_len
=
input_len_range
.
ind_sample
(
&
mut
rng
)
;
for
_
in
0
.
.
input_len
{
orig_data
.
push
(
rng
.
gen
(
)
)
;
}
let
config
=
random_config
(
&
mut
rng
&
line_len_range
)
;
encode_config_buf
(
&
orig_data
config
&
mut
encoded_data
)
;
assert_encode_sanity
(
&
encoded_data
&
config
input_len
)
;
decode_buf
.
resize
(
input_len
0
)
;
let
decode_bytes_written
=
decode_config_slice
(
&
encoded_data
config
&
mut
decode_buf
[
.
.
]
)
.
unwrap
(
)
;
assert_eq
!
(
orig_data
.
len
(
)
decode_bytes_written
)
;
assert_eq
!
(
orig_data
decode_buf
)
;
}
}
}
