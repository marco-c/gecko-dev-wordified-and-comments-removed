use
std
:
:
cmp
;
use
std
:
:
ptr
;
use
aho_corasick
:
:
{
Automaton
AcAutomaton
FullAcAutomaton
}
;
use
simd
:
:
u8x16
;
use
simd
:
:
x86
:
:
sse2
:
:
Sse2Bool8ix16
;
use
simd
:
:
x86
:
:
ssse3
:
:
Ssse3U8x16
;
use
syntax
;
const
BLOCK_SIZE
:
usize
=
16
;
pub
fn
is_teddy_128_available
(
)
-
>
bool
{
true
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Match
{
pub
pat
:
usize
pub
start
:
usize
pub
end
:
usize
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Teddy
{
pats
:
Vec
<
Vec
<
u8
>
>
ac
:
FullAcAutomaton
<
Vec
<
u8
>
>
buckets
:
Vec
<
Vec
<
usize
>
>
masks
:
Masks
}
#
[
derive
(
Debug
Clone
)
]
struct
Masks
(
Vec
<
Mask
>
)
;
#
[
derive
(
Debug
Clone
Copy
)
]
struct
Mask
{
lo
:
u8x16
hi
:
u8x16
}
impl
Teddy
{
pub
fn
new
(
pats
:
&
syntax
:
:
Literals
)
-
>
Option
<
Teddy
>
{
let
pats
:
Vec
<
_
>
=
pats
.
literals
(
)
.
iter
(
)
.
map
(
|
p
|
p
.
to_vec
(
)
)
.
collect
(
)
;
let
min_len
=
pats
.
iter
(
)
.
map
(
|
p
|
p
.
len
(
)
)
.
min
(
)
.
unwrap_or
(
0
)
;
if
min_len
<
1
{
return
None
;
}
let
nmasks
=
cmp
:
:
min
(
3
min_len
)
;
let
mut
masks
=
Masks
:
:
new
(
nmasks
)
;
let
mut
buckets
=
vec
!
[
vec
!
[
]
;
8
]
;
for
(
pati
pat
)
in
pats
.
iter
(
)
.
enumerate
(
)
{
let
bucket
=
pati
%
8
;
buckets
[
bucket
]
.
push
(
pati
)
;
masks
.
add
(
bucket
as
u8
pat
)
;
}
Some
(
Teddy
{
pats
:
pats
.
to_vec
(
)
ac
:
AcAutomaton
:
:
new
(
pats
.
to_vec
(
)
)
.
into_full
(
)
buckets
:
buckets
masks
:
masks
}
)
}
pub
fn
patterns
(
&
self
)
-
>
&
[
Vec
<
u8
>
]
{
&
self
.
pats
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
pats
.
len
(
)
}
pub
fn
approximate_size
(
&
self
)
-
>
usize
{
self
.
pats
.
iter
(
)
.
fold
(
0
|
a
b
|
a
+
b
.
len
(
)
)
}
pub
fn
find
(
&
self
haystack
:
&
[
u8
]
)
-
>
Option
<
Match
>
{
if
haystack
.
is_empty
(
)
|
|
haystack
.
len
(
)
<
(
BLOCK_SIZE
+
2
)
{
return
self
.
slow
(
haystack
0
)
;
}
match
self
.
masks
.
len
(
)
{
0
=
>
None
1
=
>
self
.
find1
(
haystack
)
2
=
>
self
.
find2
(
haystack
)
3
=
>
self
.
find3
(
haystack
)
_
=
>
unreachable
!
(
)
}
}
#
[
inline
(
always
)
]
fn
find1
(
&
self
haystack
:
&
[
u8
]
)
-
>
Option
<
Match
>
{
let
mut
pos
=
0
;
let
zero
=
u8x16
:
:
splat
(
0
)
;
let
len
=
haystack
.
len
(
)
;
debug_assert
!
(
len
>
=
BLOCK_SIZE
)
;
while
pos
<
=
len
-
BLOCK_SIZE
{
let
h
=
unsafe
{
u8x16
:
:
load_unchecked
(
haystack
pos
)
}
;
let
res0
=
self
.
masks
.
members1
(
h
)
;
let
bitfield
=
res0
.
ne
(
zero
)
.
move_mask
(
)
;
if
bitfield
!
=
0
{
if
let
Some
(
m
)
=
self
.
verify
(
haystack
pos
res0
bitfield
)
{
return
Some
(
m
)
;
}
}
pos
+
=
BLOCK_SIZE
;
}
self
.
slow
(
haystack
pos
)
}
#
[
inline
(
always
)
]
fn
find2
(
&
self
haystack
:
&
[
u8
]
)
-
>
Option
<
Match
>
{
let
res0shuffle
=
u8x16
:
:
new
(
0
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
)
;
let
zero
=
u8x16
:
:
splat
(
0
)
;
let
len
=
haystack
.
len
(
)
;
let
mut
prev0
=
u8x16
:
:
splat
(
0xFF
)
;
let
mut
pos
=
1
;
debug_assert
!
(
len
>
=
BLOCK_SIZE
)
;
while
pos
<
=
len
-
BLOCK_SIZE
{
let
h
=
unsafe
{
u8x16
:
:
load_unchecked
(
haystack
pos
)
}
;
let
(
res0
res1
)
=
self
.
masks
.
members2
(
h
)
;
let
prev0byte0
=
prev0
.
extract
(
15
)
;
let
res0shiftr8
=
res0
.
shuffle_bytes
(
res0shuffle
)
;
let
res0prev0
=
res0shiftr8
.
replace
(
0
prev0byte0
)
;
let
res
=
res0prev0
&
res1
;
prev0
=
res0
;
let
bitfield
=
res
.
ne
(
zero
)
.
move_mask
(
)
;
if
bitfield
!
=
0
{
let
pos
=
pos
.
checked_sub
(
1
)
.
unwrap
(
)
;
if
let
Some
(
m
)
=
self
.
verify
(
haystack
pos
res
bitfield
)
{
return
Some
(
m
)
;
}
}
pos
+
=
BLOCK_SIZE
;
}
self
.
slow
(
haystack
pos
.
checked_sub
(
1
)
.
unwrap
(
)
)
}
#
[
inline
(
always
)
]
fn
find3
(
&
self
haystack
:
&
[
u8
]
)
-
>
Option
<
Match
>
{
let
zero
=
u8x16
:
:
splat
(
0
)
;
let
len
=
haystack
.
len
(
)
;
let
res0shuffle
=
u8x16
:
:
new
(
0
0
0
1
2
3
4
5
6
7
8
9
10
11
12
13
)
;
let
res1shuffle
=
u8x16
:
:
new
(
0
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
)
;
let
mut
prev0
=
u8x16
:
:
splat
(
0xFF
)
;
let
mut
prev1
=
u8x16
:
:
splat
(
0xFF
)
;
let
mut
pos
=
2
;
while
pos
<
=
len
-
BLOCK_SIZE
{
let
h
=
unsafe
{
u8x16
:
:
load_unchecked
(
haystack
pos
)
}
;
let
(
res0
res1
res2
)
=
self
.
masks
.
members3
(
h
)
;
let
prev0byte0
=
prev0
.
extract
(
14
)
;
let
prev0byte1
=
prev0
.
extract
(
15
)
;
let
res0shiftr16
=
res0
.
shuffle_bytes
(
res0shuffle
)
;
let
res0prev0
=
res0shiftr16
.
replace
(
0
prev0byte0
)
.
replace
(
1
prev0byte1
)
;
let
prev1byte0
=
prev1
.
extract
(
15
)
;
let
res1shiftr8
=
res1
.
shuffle_bytes
(
res1shuffle
)
;
let
res1prev1
=
res1shiftr8
.
replace
(
0
prev1byte0
)
;
let
res
=
res0prev0
&
res1prev1
&
res2
;
prev0
=
res0
;
prev1
=
res1
;
let
bitfield
=
res
.
ne
(
zero
)
.
move_mask
(
)
;
if
bitfield
!
=
0
{
let
pos
=
pos
.
checked_sub
(
2
)
.
unwrap
(
)
;
if
let
Some
(
m
)
=
self
.
verify
(
haystack
pos
res
bitfield
)
{
return
Some
(
m
)
;
}
}
pos
+
=
BLOCK_SIZE
;
}
self
.
slow
(
haystack
pos
.
checked_sub
(
2
)
.
unwrap
(
)
)
}
#
[
inline
(
always
)
]
fn
verify
(
&
self
haystack
:
&
[
u8
]
pos
:
usize
res
:
u8x16
mut
bitfield
:
u32
)
-
>
Option
<
Match
>
{
while
bitfield
!
=
0
{
let
byte_pos
=
bitfield
.
trailing_zeros
(
)
;
bitfield
&
=
!
(
1
<
<
byte_pos
)
;
let
start
=
pos
+
byte_pos
as
usize
;
let
mut
patterns
=
res
.
extract
(
byte_pos
)
;
while
patterns
!
=
0
{
let
bucket
=
patterns
.
trailing_zeros
(
)
as
usize
;
patterns
&
=
!
(
1
<
<
bucket
)
;
if
let
Some
(
m
)
=
self
.
verify_bucket
(
haystack
bucket
start
)
{
return
Some
(
m
)
;
}
}
}
None
}
#
[
inline
(
always
)
]
fn
verify_bucket
(
&
self
haystack
:
&
[
u8
]
bucket
:
usize
start
:
usize
)
-
>
Option
<
Match
>
{
for
&
pati
in
&
self
.
buckets
[
bucket
]
{
let
pat
=
&
*
self
.
pats
[
pati
]
;
if
start
+
pat
.
len
(
)
>
haystack
.
len
(
)
{
continue
;
}
if
pat
=
=
&
haystack
[
start
.
.
start
+
pat
.
len
(
)
]
{
return
Some
(
Match
{
pat
:
pati
start
:
start
end
:
start
+
pat
.
len
(
)
}
)
;
}
}
None
}
fn
slow
(
&
self
haystack
:
&
[
u8
]
pos
:
usize
)
-
>
Option
<
Match
>
{
self
.
ac
.
find
(
&
haystack
[
pos
.
.
]
)
.
next
(
)
.
map
(
|
m
|
{
Match
{
pat
:
m
.
pati
start
:
pos
+
m
.
start
end
:
pos
+
m
.
end
}
}
)
}
}
impl
Masks
{
fn
new
(
n
:
usize
)
-
>
Masks
{
Masks
(
vec
!
[
Mask
:
:
new
(
)
;
n
]
)
}
fn
len
(
&
self
)
-
>
usize
{
self
.
0
.
len
(
)
}
fn
add
(
&
mut
self
bucket
:
u8
pat
:
&
[
u8
]
)
{
for
(
i
mask
)
in
self
.
0
.
iter_mut
(
)
.
enumerate
(
)
{
mask
.
add
(
bucket
pat
[
i
]
)
;
}
}
#
[
inline
(
always
)
]
fn
members1
(
&
self
haystack_block
:
u8x16
)
-
>
u8x16
{
let
masklo
=
u8x16
:
:
splat
(
0xF
)
;
let
hlo
=
haystack_block
&
masklo
;
let
hhi
=
(
haystack_block
>
>
4
)
&
masklo
;
self
.
0
[
0
]
.
lo
.
shuffle_bytes
(
hlo
)
&
self
.
0
[
0
]
.
hi
.
shuffle_bytes
(
hhi
)
}
#
[
inline
(
always
)
]
fn
members2
(
&
self
haystack_block
:
u8x16
)
-
>
(
u8x16
u8x16
)
{
let
masklo
=
u8x16
:
:
splat
(
0xF
)
;
let
hlo
=
haystack_block
&
masklo
;
let
hhi
=
(
haystack_block
>
>
4
)
&
masklo
;
let
res0
=
self
.
0
[
0
]
.
lo
.
shuffle_bytes
(
hlo
)
&
self
.
0
[
0
]
.
hi
.
shuffle_bytes
(
hhi
)
;
let
res1
=
self
.
0
[
1
]
.
lo
.
shuffle_bytes
(
hlo
)
&
self
.
0
[
1
]
.
hi
.
shuffle_bytes
(
hhi
)
;
(
res0
res1
)
}
#
[
inline
(
always
)
]
fn
members3
(
&
self
haystack_block
:
u8x16
)
-
>
(
u8x16
u8x16
u8x16
)
{
let
masklo
=
u8x16
:
:
splat
(
0xF
)
;
let
hlo
=
haystack_block
&
masklo
;
let
hhi
=
(
haystack_block
>
>
4
)
&
masklo
;
let
res0
=
self
.
0
[
0
]
.
lo
.
shuffle_bytes
(
hlo
)
&
self
.
0
[
0
]
.
hi
.
shuffle_bytes
(
hhi
)
;
let
res1
=
self
.
0
[
1
]
.
lo
.
shuffle_bytes
(
hlo
)
&
self
.
0
[
1
]
.
hi
.
shuffle_bytes
(
hhi
)
;
let
res2
=
self
.
0
[
2
]
.
lo
.
shuffle_bytes
(
hlo
)
&
self
.
0
[
2
]
.
hi
.
shuffle_bytes
(
hhi
)
;
(
res0
res1
res2
)
}
}
impl
Mask
{
fn
new
(
)
-
>
Mask
{
Mask
{
lo
:
u8x16
:
:
splat
(
0
)
hi
:
u8x16
:
:
splat
(
0
)
}
}
fn
add
(
&
mut
self
bucket
:
u8
byte
:
u8
)
{
let
byte_lo
=
(
byte
&
0xF
)
as
u32
;
let
byte_hi
=
(
byte
>
>
4
)
as
u32
;
let
lo
=
self
.
lo
.
extract
(
byte_lo
)
;
self
.
lo
=
self
.
lo
.
replace
(
byte_lo
(
(
1
<
<
bucket
)
as
u8
)
|
lo
)
;
let
hi
=
self
.
hi
.
extract
(
byte_hi
)
;
self
.
hi
=
self
.
hi
.
replace
(
byte_hi
(
(
1
<
<
bucket
)
as
u8
)
|
hi
)
;
}
}
trait
UnsafeLoad
{
type
Elem
;
unsafe
fn
load_unchecked
(
slice
:
&
[
Self
:
:
Elem
]
offset
:
usize
)
-
>
Self
;
}
impl
UnsafeLoad
for
u8x16
{
type
Elem
=
u8
;
unsafe
fn
load_unchecked
(
slice
:
&
[
u8
]
offset
:
usize
)
-
>
u8x16
{
let
mut
x
=
u8x16
:
:
splat
(
0
)
;
ptr
:
:
copy_nonoverlapping
(
slice
.
get_unchecked
(
offset
)
&
mut
x
as
*
mut
u8x16
as
*
mut
u8
16
)
;
x
}
}
