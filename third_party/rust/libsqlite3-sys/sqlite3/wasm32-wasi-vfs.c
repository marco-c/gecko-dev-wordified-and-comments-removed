#
if
!
defined
(
SQLITE_TEST
)
|
|
SQLITE_OS_UNIX
#
include
"
sqlite3
.
h
"
#
include
<
assert
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
file
.
h
>
#
include
<
sys
/
param
.
h
>
#
include
<
unistd
.
h
>
#
include
<
time
.
h
>
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
ifndef
SQLITE_DEMOVFS_BUFFERSZ
#
define
SQLITE_DEMOVFS_BUFFERSZ
8192
#
endif
#
define
MAXPATHNAME
512
typedef
struct
DemoFile
DemoFile
;
struct
DemoFile
{
sqlite3_file
base
;
int
fd
;
char
*
aBuffer
;
int
nBuffer
;
sqlite3_int64
iBufferOfst
;
}
;
static
int
demoDirectWrite
(
DemoFile
*
p
const
void
*
zBuf
int
iAmt
sqlite_int64
iOfst
)
{
off_t
ofst
;
size_t
nWrite
;
ofst
=
lseek
(
p
-
>
fd
iOfst
SEEK_SET
)
;
if
(
ofst
!
=
iOfst
)
{
return
SQLITE_IOERR_WRITE
;
}
nWrite
=
write
(
p
-
>
fd
zBuf
iAmt
)
;
if
(
nWrite
!
=
iAmt
)
{
return
SQLITE_IOERR_WRITE
;
}
return
SQLITE_OK
;
}
static
int
demoFlushBuffer
(
DemoFile
*
p
)
{
int
rc
=
SQLITE_OK
;
if
(
p
-
>
nBuffer
)
{
rc
=
demoDirectWrite
(
p
p
-
>
aBuffer
p
-
>
nBuffer
p
-
>
iBufferOfst
)
;
p
-
>
nBuffer
=
0
;
}
return
rc
;
}
static
int
demoClose
(
sqlite3_file
*
pFile
)
{
int
rc
;
DemoFile
*
p
=
(
DemoFile
*
)
pFile
;
rc
=
demoFlushBuffer
(
p
)
;
sqlite3_free
(
p
-
>
aBuffer
)
;
close
(
p
-
>
fd
)
;
return
rc
;
}
static
int
demoRead
(
sqlite3_file
*
pFile
void
*
zBuf
int
iAmt
sqlite_int64
iOfst
)
{
DemoFile
*
p
=
(
DemoFile
*
)
pFile
;
off_t
ofst
;
int
nRead
;
int
rc
;
rc
=
demoFlushBuffer
(
p
)
;
if
(
rc
!
=
SQLITE_OK
)
{
return
rc
;
}
ofst
=
lseek
(
p
-
>
fd
iOfst
SEEK_SET
)
;
if
(
ofst
!
=
iOfst
)
{
return
SQLITE_IOERR_READ
;
}
nRead
=
read
(
p
-
>
fd
zBuf
iAmt
)
;
if
(
nRead
=
=
iAmt
)
{
return
SQLITE_OK
;
}
else
if
(
nRead
>
=
0
)
{
return
SQLITE_IOERR_SHORT_READ
;
}
return
SQLITE_IOERR_READ
;
}
static
int
demoWrite
(
sqlite3_file
*
pFile
const
void
*
zBuf
int
iAmt
sqlite_int64
iOfst
)
{
DemoFile
*
p
=
(
DemoFile
*
)
pFile
;
if
(
p
-
>
aBuffer
)
{
char
*
z
=
(
char
*
)
zBuf
;
int
n
=
iAmt
;
sqlite3_int64
i
=
iOfst
;
while
(
n
>
0
)
{
int
nCopy
;
if
(
p
-
>
nBuffer
=
=
SQLITE_DEMOVFS_BUFFERSZ
|
|
p
-
>
iBufferOfst
+
p
-
>
nBuffer
!
=
i
)
{
int
rc
=
demoFlushBuffer
(
p
)
;
if
(
rc
!
=
SQLITE_OK
)
{
return
rc
;
}
}
assert
(
p
-
>
nBuffer
=
=
0
|
|
p
-
>
iBufferOfst
+
p
-
>
nBuffer
=
=
i
)
;
p
-
>
iBufferOfst
=
i
-
p
-
>
nBuffer
;
nCopy
=
SQLITE_DEMOVFS_BUFFERSZ
-
p
-
>
nBuffer
;
if
(
nCopy
>
n
)
{
nCopy
=
n
;
}
memcpy
(
&
p
-
>
aBuffer
[
p
-
>
nBuffer
]
z
nCopy
)
;
p
-
>
nBuffer
+
=
nCopy
;
n
-
=
nCopy
;
i
+
=
nCopy
;
z
+
=
nCopy
;
}
}
else
{
return
demoDirectWrite
(
p
zBuf
iAmt
iOfst
)
;
}
return
SQLITE_OK
;
}
static
int
demoTruncate
(
sqlite3_file
*
pFile
sqlite_int64
size
)
{
#
if
0
if
(
ftruncate
(
(
(
DemoFile
*
)
pFile
)
-
>
fd
size
)
)
return
SQLITE_IOERR_TRUNCATE
;
#
endif
return
SQLITE_OK
;
}
static
int
demoSync
(
sqlite3_file
*
pFile
int
flags
)
{
DemoFile
*
p
=
(
DemoFile
*
)
pFile
;
int
rc
;
rc
=
demoFlushBuffer
(
p
)
;
if
(
rc
!
=
SQLITE_OK
)
{
return
rc
;
}
rc
=
fsync
(
p
-
>
fd
)
;
return
(
rc
=
=
0
?
SQLITE_OK
:
SQLITE_IOERR_FSYNC
)
;
}
static
int
demoFileSize
(
sqlite3_file
*
pFile
sqlite_int64
*
pSize
)
{
DemoFile
*
p
=
(
DemoFile
*
)
pFile
;
int
rc
;
struct
stat
sStat
;
rc
=
demoFlushBuffer
(
p
)
;
if
(
rc
!
=
SQLITE_OK
)
{
return
rc
;
}
rc
=
fstat
(
p
-
>
fd
&
sStat
)
;
if
(
rc
!
=
0
)
return
SQLITE_IOERR_FSTAT
;
*
pSize
=
sStat
.
st_size
;
return
SQLITE_OK
;
}
static
int
demoLock
(
sqlite3_file
*
pFile
int
eLock
)
{
return
SQLITE_OK
;
}
static
int
demoUnlock
(
sqlite3_file
*
pFile
int
eLock
)
{
return
SQLITE_OK
;
}
static
int
demoCheckReservedLock
(
sqlite3_file
*
pFile
int
*
pResOut
)
{
*
pResOut
=
0
;
return
SQLITE_OK
;
}
static
int
demoFileControl
(
sqlite3_file
*
pFile
int
op
void
*
pArg
)
{
return
SQLITE_OK
;
}
static
int
demoSectorSize
(
sqlite3_file
*
pFile
)
{
return
0
;
}
static
int
demoDeviceCharacteristics
(
sqlite3_file
*
pFile
)
{
return
0
;
}
static
int
demoOpen
(
sqlite3_vfs
*
pVfs
const
char
*
zName
sqlite3_file
*
pFile
int
flags
int
*
pOutFlags
)
{
static
const
sqlite3_io_methods
demoio
=
{
1
demoClose
demoRead
demoWrite
demoTruncate
demoSync
demoFileSize
demoLock
demoUnlock
demoCheckReservedLock
demoFileControl
demoSectorSize
demoDeviceCharacteristics
}
;
DemoFile
*
p
=
(
DemoFile
*
)
pFile
;
int
oflags
=
0
;
char
*
aBuf
=
0
;
if
(
zName
=
=
0
)
{
return
SQLITE_IOERR
;
}
if
(
flags
&
SQLITE_OPEN_MAIN_JOURNAL
)
{
aBuf
=
(
char
*
)
sqlite3_malloc
(
SQLITE_DEMOVFS_BUFFERSZ
)
;
if
(
!
aBuf
)
{
return
SQLITE_NOMEM
;
}
}
if
(
flags
&
SQLITE_OPEN_EXCLUSIVE
)
oflags
|
=
O_EXCL
;
if
(
flags
&
SQLITE_OPEN_CREATE
)
oflags
|
=
O_CREAT
;
if
(
flags
&
SQLITE_OPEN_READONLY
)
oflags
|
=
O_RDONLY
;
if
(
flags
&
SQLITE_OPEN_READWRITE
)
oflags
|
=
O_RDWR
;
memset
(
p
0
sizeof
(
DemoFile
)
)
;
p
-
>
fd
=
open
(
zName
oflags
0600
)
;
if
(
p
-
>
fd
<
0
)
{
sqlite3_free
(
aBuf
)
;
return
SQLITE_CANTOPEN
;
}
p
-
>
aBuffer
=
aBuf
;
if
(
pOutFlags
)
{
*
pOutFlags
=
flags
;
}
p
-
>
base
.
pMethods
=
&
demoio
;
return
SQLITE_OK
;
}
static
int
demoDelete
(
sqlite3_vfs
*
pVfs
const
char
*
zPath
int
dirSync
)
{
int
rc
;
rc
=
unlink
(
zPath
)
;
if
(
rc
!
=
0
&
&
errno
=
=
ENOENT
)
return
SQLITE_OK
;
if
(
rc
=
=
0
&
&
dirSync
)
{
int
dfd
;
int
i
;
char
zDir
[
MAXPATHNAME
+
1
]
;
sqlite3_snprintf
(
MAXPATHNAME
zDir
"
%
s
"
zPath
)
;
zDir
[
MAXPATHNAME
]
=
'
\
0
'
;
for
(
i
=
strlen
(
zDir
)
;
i
>
1
&
&
zDir
[
i
]
!
=
'
/
'
;
i
+
+
)
;
zDir
[
i
]
=
'
\
0
'
;
dfd
=
open
(
zDir
O_RDONLY
0
)
;
if
(
dfd
<
0
)
{
rc
=
-
1
;
}
else
{
rc
=
fsync
(
dfd
)
;
close
(
dfd
)
;
}
}
return
(
rc
=
=
0
?
SQLITE_OK
:
SQLITE_IOERR_DELETE
)
;
}
#
ifndef
F_OK
#
define
F_OK
0
#
endif
#
ifndef
R_OK
#
define
R_OK
4
#
endif
#
ifndef
W_OK
#
define
W_OK
2
#
endif
static
int
demoAccess
(
sqlite3_vfs
*
pVfs
const
char
*
zPath
int
flags
int
*
pResOut
)
{
int
rc
;
int
eAccess
=
F_OK
;
assert
(
flags
=
=
SQLITE_ACCESS_EXISTS
|
|
flags
=
=
SQLITE_ACCESS_READ
|
|
flags
=
=
SQLITE_ACCESS_READWRITE
)
;
if
(
flags
=
=
SQLITE_ACCESS_READWRITE
)
eAccess
=
R_OK
|
W_OK
;
if
(
flags
=
=
SQLITE_ACCESS_READ
)
eAccess
=
R_OK
;
rc
=
access
(
zPath
eAccess
)
;
*
pResOut
=
(
rc
=
=
0
)
;
return
SQLITE_OK
;
}
static
int
demoFullPathname
(
sqlite3_vfs
*
pVfs
const
char
*
zPath
int
nPathOut
char
*
zPathOut
)
{
sqlite3_snprintf
(
nPathOut
zPathOut
"
%
s
"
zPath
)
;
zPathOut
[
nPathOut
-
1
]
=
'
\
0
'
;
return
SQLITE_OK
;
}
static
void
*
demoDlOpen
(
sqlite3_vfs
*
pVfs
const
char
*
zPath
)
{
return
0
;
}
static
void
demoDlError
(
sqlite3_vfs
*
pVfs
int
nByte
char
*
zErrMsg
)
{
sqlite3_snprintf
(
nByte
zErrMsg
"
Loadable
extensions
are
not
supported
"
)
;
zErrMsg
[
nByte
-
1
]
=
'
\
0
'
;
}
static
void
(
*
demoDlSym
(
sqlite3_vfs
*
pVfs
void
*
pH
const
char
*
z
)
)
(
void
)
{
return
0
;
}
static
void
demoDlClose
(
sqlite3_vfs
*
pVfs
void
*
pHandle
)
{
return
;
}
static
int
demoRandomness
(
sqlite3_vfs
*
pVfs
int
nByte
char
*
zByte
)
{
return
SQLITE_OK
;
}
static
int
demoSleep
(
sqlite3_vfs
*
pVfs
int
nMicro
)
{
sleep
(
nMicro
/
1000000
)
;
usleep
(
nMicro
%
1000000
)
;
return
nMicro
;
}
static
int
demoCurrentTime
(
sqlite3_vfs
*
pVfs
double
*
pTime
)
{
time_t
t
=
time
(
0
)
;
*
pTime
=
t
/
86400
.
0
+
2440587
.
5
;
return
SQLITE_OK
;
}
sqlite3_vfs
*
sqlite3_demovfs
(
void
)
{
static
sqlite3_vfs
demovfs
=
{
1
sizeof
(
DemoFile
)
MAXPATHNAME
0
"
demo
"
0
demoOpen
demoDelete
demoAccess
demoFullPathname
demoDlOpen
demoDlError
demoDlSym
demoDlClose
demoRandomness
demoSleep
demoCurrentTime
}
;
return
&
demovfs
;
}
#
endif
#
ifdef
SQLITE_TEST
#
if
defined
(
INCLUDE_SQLITE_TCL_H
)
#
include
"
sqlite_tcl
.
h
"
#
else
#
include
"
tcl
.
h
"
#
ifndef
SQLITE_TCLAPI
#
define
SQLITE_TCLAPI
#
endif
#
endif
#
if
SQLITE_OS_UNIX
static
int
SQLITE_TCLAPI
register_demovfs
(
ClientData
clientData
Tcl_Interp
*
interp
int
objc
Tcl_Obj
*
CONST
objv
[
]
)
{
sqlite3_vfs_register
(
sqlite3_demovfs
(
)
1
)
;
return
TCL_OK
;
}
static
int
SQLITE_TCLAPI
unregister_demovfs
(
ClientData
clientData
Tcl_Interp
*
interp
int
objc
Tcl_Obj
*
CONST
objv
[
]
)
{
sqlite3_vfs_unregister
(
sqlite3_demovfs
(
)
)
;
return
TCL_OK
;
}
int
Sqlitetest_demovfs_Init
(
Tcl_Interp
*
interp
)
{
Tcl_CreateObjCommand
(
interp
"
register_demovfs
"
register_demovfs
0
0
)
;
Tcl_CreateObjCommand
(
interp
"
unregister_demovfs
"
unregister_demovfs
0
0
)
;
return
TCL_OK
;
}
#
else
int
Sqlitetest_demovfs_Init
(
Tcl_Interp
*
interp
)
{
return
TCL_OK
;
}
#
endif
#
endif
int
sqlite3_os_init
(
)
{
sqlite3_vfs_register
(
sqlite3_demovfs
(
)
0
)
;
return
0
;
}
int
sqlite3_os_end
(
)
{
return
0
;
}
