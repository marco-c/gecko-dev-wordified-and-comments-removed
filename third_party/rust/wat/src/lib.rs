#
!
[
deny
(
missing_docs
)
]
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
fmt
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
str
;
use
wast
:
:
parser
:
:
{
self
ParseBuffer
}
;
pub
fn
parse_file
(
file
:
impl
AsRef
<
Path
>
)
-
>
Result
<
Vec
<
u8
>
>
{
_parse_file
(
file
.
as_ref
(
)
)
}
fn
_parse_file
(
file
:
&
Path
)
-
>
Result
<
Vec
<
u8
>
>
{
let
contents
=
std
:
:
fs
:
:
read
(
file
)
.
map_err
(
|
err
|
Error
{
kind
:
Box
:
:
new
(
ErrorKind
:
:
Io
{
err
msg
:
format
!
(
"
failed
to
read
{
}
to
a
string
"
file
.
display
(
)
)
}
)
}
)
?
;
match
parse_bytes
(
&
contents
)
{
Ok
(
bytes
)
=
>
Ok
(
bytes
.
into_owned
(
)
)
Err
(
mut
e
)
=
>
{
if
let
ErrorKind
:
:
Wast
(
e
)
=
&
mut
*
e
.
kind
{
e
.
set_path
(
file
)
;
}
Err
(
e
)
}
}
}
pub
fn
parse_bytes
(
bytes
:
&
[
u8
]
)
-
>
Result
<
Cow
<
'
_
[
u8
]
>
>
{
if
bytes
.
starts_with
(
b
"
\
0asm
"
)
{
return
Ok
(
bytes
.
into
(
)
)
;
}
match
str
:
:
from_utf8
(
bytes
)
{
Ok
(
s
)
=
>
_parse_str
(
s
)
.
map
(
|
s
|
s
.
into
(
)
)
Err
(
_
)
=
>
Err
(
Error
{
kind
:
Box
:
:
new
(
ErrorKind
:
:
Custom
(
format
!
(
"
input
bytes
aren
'
t
valid
utf
-
8
"
)
)
)
}
)
}
}
pub
fn
parse_str
(
wat
:
impl
AsRef
<
str
>
)
-
>
Result
<
Vec
<
u8
>
>
{
_parse_str
(
wat
.
as_ref
(
)
)
}
fn
_parse_str
(
wat
:
&
str
)
-
>
Result
<
Vec
<
u8
>
>
{
let
buf
=
ParseBuffer
:
:
new
(
&
wat
)
.
map_err
(
|
e
|
Error
:
:
cvt
(
e
wat
)
)
?
;
let
mut
ast
=
parser
:
:
parse
:
:
<
wast
:
:
Wat
>
(
&
buf
)
.
map_err
(
|
e
|
Error
:
:
cvt
(
e
wat
)
)
?
;
Ok
(
ast
.
module
.
encode
(
)
.
map_err
(
|
e
|
Error
:
:
cvt
(
e
wat
)
)
?
)
}
pub
type
Result
<
T
>
=
std
:
:
result
:
:
Result
<
T
Error
>
;
#
[
derive
(
Debug
)
]
pub
struct
Error
{
kind
:
Box
<
ErrorKind
>
}
#
[
derive
(
Debug
)
]
enum
ErrorKind
{
Wast
(
wast
:
:
Error
)
Io
{
err
:
std
:
:
io
:
:
Error
msg
:
String
}
Custom
(
String
)
}
impl
Error
{
fn
cvt
<
E
:
Into
<
wast
:
:
Error
>
>
(
e
:
E
contents
:
&
str
)
-
>
Error
{
let
mut
err
=
e
.
into
(
)
;
err
.
set_text
(
contents
)
;
Error
{
kind
:
Box
:
:
new
(
ErrorKind
:
:
Wast
(
err
)
)
}
}
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
&
*
self
.
kind
{
ErrorKind
:
:
Wast
(
err
)
=
>
err
.
fmt
(
f
)
ErrorKind
:
:
Custom
(
err
)
=
>
err
.
fmt
(
f
)
ErrorKind
:
:
Io
{
msg
.
.
}
=
>
msg
.
fmt
(
f
)
}
}
}
impl
std
:
:
error
:
:
Error
for
Error
{
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
std
:
:
error
:
:
Error
+
'
static
)
>
{
match
&
*
self
.
kind
{
ErrorKind
:
:
Wast
(
_
)
=
>
None
ErrorKind
:
:
Custom
(
_
)
=
>
None
ErrorKind
:
:
Io
{
err
.
.
}
=
>
Some
(
err
)
}
}
}
