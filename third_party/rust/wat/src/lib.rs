#
!
[
deny
(
missing_docs
)
]
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
fmt
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
std
:
:
str
;
use
wast
:
:
parser
:
:
{
self
ParseBuffer
}
;
pub
fn
parse_file
(
file
:
impl
AsRef
<
Path
>
)
-
>
Result
<
Vec
<
u8
>
>
{
_parse_file
(
file
.
as_ref
(
)
)
}
fn
_parse_file
(
file
:
&
Path
)
-
>
Result
<
Vec
<
u8
>
>
{
let
contents
=
std
:
:
fs
:
:
read
(
file
)
.
map_err
(
|
err
|
Error
{
kind
:
Box
:
:
new
(
ErrorKind
:
:
Io
{
err
file
:
Some
(
file
.
to_owned
(
)
)
}
)
}
)
?
;
match
parse_bytes
(
&
contents
)
{
Ok
(
bytes
)
=
>
Ok
(
bytes
.
into_owned
(
)
)
Err
(
mut
e
)
=
>
{
e
.
set_path
(
file
)
;
Err
(
e
)
}
}
}
pub
fn
parse_bytes
(
bytes
:
&
[
u8
]
)
-
>
Result
<
Cow
<
'
_
[
u8
]
>
>
{
if
bytes
.
starts_with
(
b
"
\
0asm
"
)
{
return
Ok
(
bytes
.
into
(
)
)
;
}
match
str
:
:
from_utf8
(
bytes
)
{
Ok
(
s
)
=
>
_parse_str
(
s
)
.
map
(
|
s
|
s
.
into
(
)
)
Err
(
_
)
=
>
Err
(
Error
{
kind
:
Box
:
:
new
(
ErrorKind
:
:
Custom
{
msg
:
"
input
bytes
aren
'
t
valid
utf
-
8
"
.
to_string
(
)
file
:
None
}
)
}
)
}
}
pub
fn
parse_str
(
wat
:
impl
AsRef
<
str
>
)
-
>
Result
<
Vec
<
u8
>
>
{
_parse_str
(
wat
.
as_ref
(
)
)
}
fn
_parse_str
(
wat
:
&
str
)
-
>
Result
<
Vec
<
u8
>
>
{
let
buf
=
ParseBuffer
:
:
new
(
&
wat
)
.
map_err
(
|
e
|
Error
:
:
cvt
(
e
wat
)
)
?
;
let
mut
ast
=
parser
:
:
parse
:
:
<
wast
:
:
Wat
>
(
&
buf
)
.
map_err
(
|
e
|
Error
:
:
cvt
(
e
wat
)
)
?
;
Ok
(
ast
.
module
.
encode
(
)
.
map_err
(
|
e
|
Error
:
:
cvt
(
e
wat
)
)
?
)
}
pub
type
Result
<
T
>
=
std
:
:
result
:
:
Result
<
T
Error
>
;
#
[
derive
(
Debug
)
]
pub
struct
Error
{
kind
:
Box
<
ErrorKind
>
}
#
[
derive
(
Debug
)
]
enum
ErrorKind
{
Wast
(
wast
:
:
Error
)
Io
{
err
:
std
:
:
io
:
:
Error
file
:
Option
<
PathBuf
>
}
Custom
{
msg
:
String
file
:
Option
<
PathBuf
>
}
}
impl
Error
{
fn
cvt
<
E
:
Into
<
wast
:
:
Error
>
>
(
e
:
E
contents
:
&
str
)
-
>
Error
{
let
mut
err
=
e
.
into
(
)
;
err
.
set_text
(
contents
)
;
Error
{
kind
:
Box
:
:
new
(
ErrorKind
:
:
Wast
(
err
)
)
}
}
pub
fn
set_path
<
P
:
AsRef
<
Path
>
>
(
&
mut
self
file
:
P
)
{
let
file
=
file
.
as_ref
(
)
;
match
&
mut
*
self
.
kind
{
ErrorKind
:
:
Wast
(
e
)
=
>
e
.
set_path
(
file
)
ErrorKind
:
:
Custom
{
file
:
f
.
.
}
=
>
*
f
=
Some
(
file
.
to_owned
(
)
)
ErrorKind
:
:
Io
{
file
:
f
.
.
}
=
>
*
f
=
Some
(
file
.
to_owned
(
)
)
}
}
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
&
*
self
.
kind
{
ErrorKind
:
:
Wast
(
err
)
=
>
err
.
fmt
(
f
)
ErrorKind
:
:
Custom
{
msg
file
.
.
}
=
>
match
file
{
Some
(
file
)
=
>
{
write
!
(
f
"
failed
to
parse
{
}
:
{
}
"
file
.
display
(
)
msg
)
}
None
=
>
msg
.
fmt
(
f
)
}
ErrorKind
:
:
Io
{
err
file
.
.
}
=
>
match
file
{
Some
(
file
)
=
>
{
write
!
(
f
"
failed
to
read
from
{
}
:
{
}
"
file
.
display
(
)
err
)
}
None
=
>
err
.
fmt
(
f
)
}
}
}
}
impl
std
:
:
error
:
:
Error
for
Error
{
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
std
:
:
error
:
:
Error
+
'
static
)
>
{
match
&
*
self
.
kind
{
ErrorKind
:
:
Wast
(
_
)
=
>
None
ErrorKind
:
:
Custom
{
.
.
}
=
>
None
ErrorKind
:
:
Io
{
err
.
.
}
=
>
Some
(
err
)
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_set_path
(
)
{
let
mut
e
=
parse_bytes
(
&
[
0xFF
]
)
.
unwrap_err
(
)
;
e
.
set_path
(
"
foo
"
)
;
assert_eq
!
(
e
.
to_string
(
)
"
failed
to
parse
foo
:
input
bytes
aren
'
t
valid
utf
-
8
"
)
;
let
e
=
parse_file
(
"
_does_not_exist_
"
)
.
unwrap_err
(
)
;
assert
!
(
e
.
to_string
(
)
.
starts_with
(
"
failed
to
read
from
_does_not_exist_
:
"
)
)
;
let
mut
e
=
parse_bytes
(
"
(
)
"
.
as_bytes
(
)
)
.
unwrap_err
(
)
;
e
.
set_path
(
"
foo
"
)
;
assert_eq
!
(
e
.
to_string
(
)
"
expected
valid
module
field
\
n
-
-
>
foo
:
1
:
2
\
n
|
\
n
1
|
(
)
\
n
|
^
"
)
;
}
}
