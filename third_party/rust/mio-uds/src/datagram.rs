use
std
:
:
io
;
use
std
:
:
net
:
:
Shutdown
;
use
std
:
:
os
:
:
unix
:
:
net
;
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
*
;
use
std
:
:
path
:
:
Path
;
use
libc
;
use
mio
:
:
event
:
:
Evented
;
use
mio
:
:
unix
:
:
EventedFd
;
use
mio
:
:
{
Poll
Token
Ready
PollOpt
}
;
use
cvt
;
use
socket
:
:
{
sockaddr_un
Socket
}
;
#
[
derive
(
Debug
)
]
pub
struct
UnixDatagram
{
inner
:
net
:
:
UnixDatagram
}
impl
UnixDatagram
{
pub
fn
bind
<
P
:
AsRef
<
Path
>
>
(
path
:
P
)
-
>
io
:
:
Result
<
UnixDatagram
>
{
UnixDatagram
:
:
_bind
(
path
.
as_ref
(
)
)
}
fn
_bind
(
path
:
&
Path
)
-
>
io
:
:
Result
<
UnixDatagram
>
{
unsafe
{
let
(
addr
len
)
=
try
!
(
sockaddr_un
(
path
)
)
;
let
fd
=
try
!
(
Socket
:
:
new
(
libc
:
:
SOCK_DGRAM
)
)
;
let
addr
=
&
addr
as
*
const
_
as
*
const
_
;
try
!
(
cvt
(
libc
:
:
bind
(
fd
.
fd
(
)
addr
len
)
)
)
;
Ok
(
UnixDatagram
:
:
from_raw_fd
(
fd
.
into_fd
(
)
)
)
}
}
pub
fn
from_datagram
(
stream
:
net
:
:
UnixDatagram
)
-
>
io
:
:
Result
<
UnixDatagram
>
{
try
!
(
stream
.
set_nonblocking
(
true
)
)
;
Ok
(
UnixDatagram
{
inner
:
stream
}
)
}
pub
fn
pair
(
)
-
>
io
:
:
Result
<
(
UnixDatagram
UnixDatagram
)
>
{
unsafe
{
let
(
a
b
)
=
try
!
(
Socket
:
:
pair
(
libc
:
:
SOCK_DGRAM
)
)
;
Ok
(
(
UnixDatagram
:
:
from_raw_fd
(
a
.
into_fd
(
)
)
UnixDatagram
:
:
from_raw_fd
(
b
.
into_fd
(
)
)
)
)
}
}
pub
fn
unbound
(
)
-
>
io
:
:
Result
<
UnixDatagram
>
{
let
stream
=
try
!
(
net
:
:
UnixDatagram
:
:
unbound
(
)
)
;
try
!
(
stream
.
set_nonblocking
(
true
)
)
;
Ok
(
UnixDatagram
{
inner
:
stream
}
)
}
pub
fn
connect
<
P
:
AsRef
<
Path
>
>
(
&
self
path
:
P
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
inner
.
connect
(
path
)
}
pub
fn
try_clone
(
&
self
)
-
>
io
:
:
Result
<
UnixDatagram
>
{
self
.
inner
.
try_clone
(
)
.
map
(
|
i
|
{
UnixDatagram
{
inner
:
i
}
}
)
}
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
net
:
:
SocketAddr
>
{
self
.
inner
.
local_addr
(
)
}
pub
fn
peer_addr
(
&
self
)
-
>
io
:
:
Result
<
net
:
:
SocketAddr
>
{
self
.
inner
.
peer_addr
(
)
}
pub
fn
recv_from
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
(
usize
net
:
:
SocketAddr
)
>
{
self
.
inner
.
recv_from
(
buf
)
}
pub
fn
recv
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
inner
.
recv
(
buf
)
}
pub
fn
send_to
<
P
:
AsRef
<
Path
>
>
(
&
self
buf
:
&
[
u8
]
path
:
P
)
-
>
io
:
:
Result
<
usize
>
{
self
.
inner
.
send_to
(
buf
path
)
}
pub
fn
send
(
&
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
inner
.
send
(
buf
)
}
pub
fn
take_error
(
&
self
)
-
>
io
:
:
Result
<
Option
<
io
:
:
Error
>
>
{
self
.
inner
.
take_error
(
)
}
pub
fn
shutdown
(
&
self
how
:
Shutdown
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
inner
.
shutdown
(
how
)
}
}
impl
Evented
for
UnixDatagram
{
fn
register
(
&
self
poll
:
&
Poll
token
:
Token
events
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
EventedFd
(
&
self
.
as_raw_fd
(
)
)
.
register
(
poll
token
events
opts
)
}
fn
reregister
(
&
self
poll
:
&
Poll
token
:
Token
events
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
EventedFd
(
&
self
.
as_raw_fd
(
)
)
.
reregister
(
poll
token
events
opts
)
}
fn
deregister
(
&
self
poll
:
&
Poll
)
-
>
io
:
:
Result
<
(
)
>
{
EventedFd
(
&
self
.
as_raw_fd
(
)
)
.
deregister
(
poll
)
}
}
impl
AsRawFd
for
UnixDatagram
{
fn
as_raw_fd
(
&
self
)
-
>
i32
{
self
.
inner
.
as_raw_fd
(
)
}
}
impl
IntoRawFd
for
UnixDatagram
{
fn
into_raw_fd
(
self
)
-
>
i32
{
self
.
inner
.
into_raw_fd
(
)
}
}
impl
FromRawFd
for
UnixDatagram
{
unsafe
fn
from_raw_fd
(
fd
:
i32
)
-
>
UnixDatagram
{
UnixDatagram
{
inner
:
net
:
:
UnixDatagram
:
:
from_raw_fd
(
fd
)
}
}
}
