use
std
:
:
ops
:
:
{
RangeFull
Range
RangeTo
RangeFrom
}
;
use
std
:
:
collections
:
:
Bound
:
:
{
self
Excluded
Included
Unbounded
}
;
pub
trait
RangeArgument
<
T
:
?
Sized
>
{
fn
start
(
&
self
)
-
>
Bound
<
&
T
>
;
fn
end
(
&
self
)
-
>
Bound
<
&
T
>
;
}
impl
<
T
:
?
Sized
>
RangeArgument
<
T
>
for
RangeFull
{
fn
start
(
&
self
)
-
>
Bound
<
&
T
>
{
Unbounded
}
fn
end
(
&
self
)
-
>
Bound
<
&
T
>
{
Unbounded
}
}
impl
<
T
>
RangeArgument
<
T
>
for
RangeFrom
<
T
>
{
fn
start
(
&
self
)
-
>
Bound
<
&
T
>
{
Included
(
&
self
.
start
)
}
fn
end
(
&
self
)
-
>
Bound
<
&
T
>
{
Unbounded
}
}
impl
<
T
>
RangeArgument
<
T
>
for
RangeTo
<
T
>
{
fn
start
(
&
self
)
-
>
Bound
<
&
T
>
{
Unbounded
}
fn
end
(
&
self
)
-
>
Bound
<
&
T
>
{
Excluded
(
&
self
.
end
)
}
}
impl
<
T
>
RangeArgument
<
T
>
for
Range
<
T
>
{
fn
start
(
&
self
)
-
>
Bound
<
&
T
>
{
Included
(
&
self
.
start
)
}
fn
end
(
&
self
)
-
>
Bound
<
&
T
>
{
Excluded
(
&
self
.
end
)
}
}
impl
<
T
>
RangeArgument
<
T
>
for
(
Bound
<
T
>
Bound
<
T
>
)
{
fn
start
(
&
self
)
-
>
Bound
<
&
T
>
{
match
*
self
{
(
Included
(
ref
start
)
_
)
=
>
Included
(
start
)
(
Excluded
(
ref
start
)
_
)
=
>
Excluded
(
start
)
(
Unbounded
_
)
=
>
Unbounded
}
}
fn
end
(
&
self
)
-
>
Bound
<
&
T
>
{
match
*
self
{
(
_
Included
(
ref
end
)
)
=
>
Included
(
end
)
(
_
Excluded
(
ref
end
)
)
=
>
Excluded
(
end
)
(
_
Unbounded
)
=
>
Unbounded
}
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
RangeArgument
<
T
>
for
(
Bound
<
&
'
a
T
>
Bound
<
&
'
a
T
>
)
{
fn
start
(
&
self
)
-
>
Bound
<
&
T
>
{
self
.
0
}
fn
end
(
&
self
)
-
>
Bound
<
&
T
>
{
self
.
1
}
}
