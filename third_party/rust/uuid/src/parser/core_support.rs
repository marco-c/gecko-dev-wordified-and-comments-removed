use
core
:
:
fmt
;
use
parser
;
impl
<
'
a
>
fmt
:
:
Display
for
parser
:
:
Expected
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
parser
:
:
Expected
:
:
Any
(
ref
crits
)
=
>
write
!
(
f
"
one
of
{
:
?
}
"
crits
)
parser
:
:
Expected
:
:
Exact
(
crit
)
=
>
write
!
(
f
"
{
}
"
crit
)
parser
:
:
Expected
:
:
Range
{
min
max
}
=
>
{
write
!
(
f
"
{
}
.
.
{
}
inclusive
"
min
max
)
}
}
}
}
impl
fmt
:
:
Display
for
parser
:
:
ParseError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
:
"
self
.
_description
(
)
)
?
;
match
*
self
{
parser
:
:
ParseError
:
:
InvalidCharacter
{
expected
found
index
}
=
>
write
!
(
f
"
expected
{
:
?
}
found
{
}
at
{
}
"
expected
.
chars
(
)
found
index
)
parser
:
:
ParseError
:
:
InvalidGroupCount
{
ref
expected
found
}
=
>
write
!
(
f
"
expected
{
}
found
{
}
"
expected
found
)
parser
:
:
ParseError
:
:
InvalidGroupLength
{
ref
expected
found
group
}
=
>
write
!
(
f
"
expected
{
}
found
{
}
in
group
{
}
"
expected
found
group
)
parser
:
:
ParseError
:
:
InvalidLength
{
ref
expected
found
}
=
>
write
!
(
f
"
expected
{
}
found
{
}
"
expected
found
)
}
}
}
