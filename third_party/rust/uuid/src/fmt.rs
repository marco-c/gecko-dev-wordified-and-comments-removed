use
crate
:
:
{
std
:
:
{
borrow
:
:
Borrow
fmt
ptr
str
}
Uuid
Variant
}
;
impl
std
:
:
fmt
:
:
Debug
for
Uuid
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
LowerHex
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Display
for
Uuid
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
LowerHex
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Display
for
Variant
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
Variant
:
:
NCS
=
>
write
!
(
f
"
NCS
"
)
Variant
:
:
RFC4122
=
>
write
!
(
f
"
RFC4122
"
)
Variant
:
:
Microsoft
=
>
write
!
(
f
"
Microsoft
"
)
Variant
:
:
Future
=
>
write
!
(
f
"
Future
"
)
}
}
}
impl
fmt
:
:
LowerHex
for
Uuid
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
if
f
.
alternate
(
)
{
fmt
:
:
LowerHex
:
:
fmt
(
self
.
as_simple
(
)
f
)
}
else
{
fmt
:
:
LowerHex
:
:
fmt
(
self
.
as_hyphenated
(
)
f
)
}
}
}
impl
fmt
:
:
UpperHex
for
Uuid
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
if
f
.
alternate
(
)
{
fmt
:
:
UpperHex
:
:
fmt
(
self
.
as_simple
(
)
f
)
}
else
{
fmt
:
:
UpperHex
:
:
fmt
(
self
.
as_hyphenated
(
)
f
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
Default
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
#
[
repr
(
transparent
)
]
pub
struct
Hyphenated
(
Uuid
)
;
#
[
derive
(
Clone
Copy
Debug
Default
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
#
[
repr
(
transparent
)
]
pub
struct
Simple
(
Uuid
)
;
#
[
derive
(
Clone
Copy
Debug
Default
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
#
[
repr
(
transparent
)
]
pub
struct
Urn
(
Uuid
)
;
#
[
derive
(
Clone
Copy
Debug
Default
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
#
[
repr
(
transparent
)
]
pub
struct
Braced
(
Uuid
)
;
impl
Uuid
{
#
[
inline
]
pub
const
fn
hyphenated
(
self
)
-
>
Hyphenated
{
Hyphenated
(
self
)
}
#
[
inline
]
pub
fn
as_hyphenated
(
&
self
)
-
>
&
Hyphenated
{
unsafe
{
&
*
(
self
as
*
const
Uuid
as
*
const
Hyphenated
)
}
}
#
[
inline
]
pub
const
fn
simple
(
self
)
-
>
Simple
{
Simple
(
self
)
}
#
[
inline
]
pub
fn
as_simple
(
&
self
)
-
>
&
Simple
{
unsafe
{
&
*
(
self
as
*
const
Uuid
as
*
const
Simple
)
}
}
#
[
inline
]
pub
const
fn
urn
(
self
)
-
>
Urn
{
Urn
(
self
)
}
#
[
inline
]
pub
fn
as_urn
(
&
self
)
-
>
&
Urn
{
unsafe
{
&
*
(
self
as
*
const
Uuid
as
*
const
Urn
)
}
}
#
[
inline
]
pub
const
fn
braced
(
self
)
-
>
Braced
{
Braced
(
self
)
}
#
[
inline
]
pub
fn
as_braced
(
&
self
)
-
>
&
Braced
{
unsafe
{
&
*
(
self
as
*
const
Uuid
as
*
const
Braced
)
}
}
}
const
UPPER
:
[
u8
;
16
]
=
[
b
'
0
'
b
'
1
'
b
'
2
'
b
'
3
'
b
'
4
'
b
'
5
'
b
'
6
'
b
'
7
'
b
'
8
'
b
'
9
'
b
'
A
'
b
'
B
'
b
'
C
'
b
'
D
'
b
'
E
'
b
'
F
'
]
;
const
LOWER
:
[
u8
;
16
]
=
[
b
'
0
'
b
'
1
'
b
'
2
'
b
'
3
'
b
'
4
'
b
'
5
'
b
'
6
'
b
'
7
'
b
'
8
'
b
'
9
'
b
'
a
'
b
'
b
'
b
'
c
'
b
'
d
'
b
'
e
'
b
'
f
'
]
;
#
[
inline
]
const
fn
format_simple
(
src
:
&
[
u8
;
16
]
upper
:
bool
)
-
>
[
u8
;
32
]
{
let
lut
=
if
upper
{
&
UPPER
}
else
{
&
LOWER
}
;
let
mut
dst
=
[
0
;
32
]
;
let
mut
i
=
0
;
while
i
<
16
{
let
x
=
src
[
i
]
;
dst
[
i
*
2
]
=
lut
[
(
x
>
>
4
)
as
usize
]
;
dst
[
i
*
2
+
1
]
=
lut
[
(
x
&
0x0f
)
as
usize
]
;
i
+
=
1
;
}
dst
}
#
[
inline
]
const
fn
format_hyphenated
(
src
:
&
[
u8
;
16
]
upper
:
bool
)
-
>
[
u8
;
36
]
{
let
lut
=
if
upper
{
&
UPPER
}
else
{
&
LOWER
}
;
let
groups
=
[
(
0
8
)
(
9
13
)
(
14
18
)
(
19
23
)
(
24
36
)
]
;
let
mut
dst
=
[
0
;
36
]
;
let
mut
group_idx
=
0
;
let
mut
i
=
0
;
while
group_idx
<
5
{
let
(
start
end
)
=
groups
[
group_idx
]
;
let
mut
j
=
start
;
while
j
<
end
{
let
x
=
src
[
i
]
;
i
+
=
1
;
dst
[
j
]
=
lut
[
(
x
>
>
4
)
as
usize
]
;
dst
[
j
+
1
]
=
lut
[
(
x
&
0x0f
)
as
usize
]
;
j
+
=
2
;
}
if
group_idx
<
4
{
dst
[
end
]
=
b
'
-
'
;
}
group_idx
+
=
1
;
}
dst
}
#
[
inline
]
fn
encode_simple
<
'
b
>
(
src
:
&
[
u8
;
16
]
buffer
:
&
'
b
mut
[
u8
]
upper
:
bool
)
-
>
&
'
b
mut
str
{
let
buf
=
&
mut
buffer
[
.
.
Simple
:
:
LENGTH
]
;
let
dst
=
buf
.
as_mut_ptr
(
)
;
unsafe
{
ptr
:
:
write
(
dst
.
cast
(
)
format_simple
(
src
upper
)
)
;
str
:
:
from_utf8_unchecked_mut
(
buf
)
}
}
#
[
inline
]
fn
encode_hyphenated
<
'
b
>
(
src
:
&
[
u8
;
16
]
buffer
:
&
'
b
mut
[
u8
]
upper
:
bool
)
-
>
&
'
b
mut
str
{
let
buf
=
&
mut
buffer
[
.
.
Hyphenated
:
:
LENGTH
]
;
let
dst
=
buf
.
as_mut_ptr
(
)
;
unsafe
{
ptr
:
:
write
(
dst
.
cast
(
)
format_hyphenated
(
src
upper
)
)
;
str
:
:
from_utf8_unchecked_mut
(
buf
)
}
}
#
[
inline
]
fn
encode_braced
<
'
b
>
(
src
:
&
[
u8
;
16
]
buffer
:
&
'
b
mut
[
u8
]
upper
:
bool
)
-
>
&
'
b
mut
str
{
let
buf
=
&
mut
buffer
[
.
.
Braced
:
:
LENGTH
]
;
buf
[
0
]
=
b
'
{
'
;
buf
[
Braced
:
:
LENGTH
-
1
]
=
b
'
}
'
;
unsafe
{
let
dst
=
buf
.
as_mut_ptr
(
)
.
add
(
1
)
;
ptr
:
:
write
(
dst
.
cast
(
)
format_hyphenated
(
src
upper
)
)
;
str
:
:
from_utf8_unchecked_mut
(
buf
)
}
}
#
[
inline
]
fn
encode_urn
<
'
b
>
(
src
:
&
[
u8
;
16
]
buffer
:
&
'
b
mut
[
u8
]
upper
:
bool
)
-
>
&
'
b
mut
str
{
let
buf
=
&
mut
buffer
[
.
.
Urn
:
:
LENGTH
]
;
buf
[
.
.
9
]
.
copy_from_slice
(
b
"
urn
:
uuid
:
"
)
;
unsafe
{
let
dst
=
buf
.
as_mut_ptr
(
)
.
add
(
9
)
;
ptr
:
:
write
(
dst
.
cast
(
)
format_hyphenated
(
src
upper
)
)
;
str
:
:
from_utf8_unchecked_mut
(
buf
)
}
}
impl
Hyphenated
{
pub
const
LENGTH
:
usize
=
36
;
pub
const
fn
from_uuid
(
uuid
:
Uuid
)
-
>
Self
{
Hyphenated
(
uuid
)
}
#
[
inline
]
pub
fn
encode_lower
<
'
buf
>
(
&
self
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
&
'
buf
mut
str
{
encode_hyphenated
(
self
.
0
.
as_bytes
(
)
buffer
false
)
}
#
[
inline
]
pub
fn
encode_upper
<
'
buf
>
(
&
self
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
&
'
buf
mut
str
{
encode_hyphenated
(
self
.
0
.
as_bytes
(
)
buffer
true
)
}
pub
const
fn
as_uuid
(
&
self
)
-
>
&
Uuid
{
&
self
.
0
}
pub
const
fn
into_uuid
(
self
)
-
>
Uuid
{
self
.
0
}
}
impl
Braced
{
pub
const
LENGTH
:
usize
=
38
;
pub
const
fn
from_uuid
(
uuid
:
Uuid
)
-
>
Self
{
Braced
(
uuid
)
}
#
[
inline
]
pub
fn
encode_lower
<
'
buf
>
(
&
self
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
&
'
buf
mut
str
{
encode_braced
(
self
.
0
.
as_bytes
(
)
buffer
false
)
}
#
[
inline
]
pub
fn
encode_upper
<
'
buf
>
(
&
self
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
&
'
buf
mut
str
{
encode_braced
(
self
.
0
.
as_bytes
(
)
buffer
true
)
}
pub
const
fn
as_uuid
(
&
self
)
-
>
&
Uuid
{
&
self
.
0
}
pub
const
fn
into_uuid
(
self
)
-
>
Uuid
{
self
.
0
}
}
impl
Simple
{
pub
const
LENGTH
:
usize
=
32
;
pub
const
fn
from_uuid
(
uuid
:
Uuid
)
-
>
Self
{
Simple
(
uuid
)
}
#
[
inline
]
pub
fn
encode_lower
<
'
buf
>
(
&
self
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
&
'
buf
mut
str
{
encode_simple
(
self
.
0
.
as_bytes
(
)
buffer
false
)
}
#
[
inline
]
pub
fn
encode_upper
<
'
buf
>
(
&
self
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
&
'
buf
mut
str
{
encode_simple
(
self
.
0
.
as_bytes
(
)
buffer
true
)
}
pub
const
fn
as_uuid
(
&
self
)
-
>
&
Uuid
{
&
self
.
0
}
pub
const
fn
into_uuid
(
self
)
-
>
Uuid
{
self
.
0
}
}
impl
Urn
{
pub
const
LENGTH
:
usize
=
45
;
pub
const
fn
from_uuid
(
uuid
:
Uuid
)
-
>
Self
{
Urn
(
uuid
)
}
#
[
inline
]
pub
fn
encode_lower
<
'
buf
>
(
&
self
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
&
'
buf
mut
str
{
encode_urn
(
self
.
0
.
as_bytes
(
)
buffer
false
)
}
#
[
inline
]
pub
fn
encode_upper
<
'
buf
>
(
&
self
buffer
:
&
'
buf
mut
[
u8
]
)
-
>
&
'
buf
mut
str
{
encode_urn
(
self
.
0
.
as_bytes
(
)
buffer
true
)
}
pub
const
fn
as_uuid
(
&
self
)
-
>
&
Uuid
{
&
self
.
0
}
pub
const
fn
into_uuid
(
self
)
-
>
Uuid
{
self
.
0
}
}
macro_rules
!
impl_fmt_traits
{
(
(
T
:
ident
<
(
a
:
lifetime
)
*
>
)
+
)
=
>
{
(
impl
<
(
a
)
*
>
fmt
:
:
Display
for
T
<
(
a
)
*
>
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
LowerHex
:
:
fmt
(
self
f
)
}
}
impl
<
(
a
)
*
>
fmt
:
:
LowerHex
for
T
<
(
a
)
*
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
self
.
encode_lower
(
&
mut
[
0
;
Self
:
:
LENGTH
]
)
)
}
}
impl
<
(
a
)
*
>
fmt
:
:
UpperHex
for
T
<
(
a
)
*
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
self
.
encode_upper
(
&
mut
[
0
;
Self
:
:
LENGTH
]
)
)
}
}
impl_fmt_from
!
(
T
<
(
a
)
*
>
)
;
)
+
}
}
macro_rules
!
impl_fmt_from
{
(
T
:
ident
<
>
)
=
>
{
impl
From
<
Uuid
>
for
T
{
#
[
inline
]
fn
from
(
f
:
Uuid
)
-
>
Self
{
T
(
f
)
}
}
impl
From
<
T
>
for
Uuid
{
#
[
inline
]
fn
from
(
f
:
T
)
-
>
Self
{
f
.
into_uuid
(
)
}
}
impl
AsRef
<
Uuid
>
for
T
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
Uuid
{
&
self
.
0
}
}
impl
Borrow
<
Uuid
>
for
T
{
#
[
inline
]
fn
borrow
(
&
self
)
-
>
&
Uuid
{
&
self
.
0
}
}
}
;
(
T
:
ident
<
a
:
lifetime
>
)
=
>
{
impl
<
a
>
From
<
&
a
Uuid
>
for
T
<
a
>
{
#
[
inline
]
fn
from
(
f
:
&
a
Uuid
)
-
>
Self
{
T
:
:
from_uuid_ref
(
f
)
}
}
impl
<
a
>
From
<
T
<
a
>
>
for
&
a
Uuid
{
#
[
inline
]
fn
from
(
f
:
T
<
a
>
)
-
>
&
a
Uuid
{
f
.
0
}
}
impl
<
a
>
AsRef
<
Uuid
>
for
T
<
a
>
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
Uuid
{
self
.
0
}
}
impl
<
a
>
Borrow
<
Uuid
>
for
T
<
a
>
{
#
[
inline
]
fn
borrow
(
&
self
)
-
>
&
Uuid
{
self
.
0
}
}
}
;
}
impl_fmt_traits
!
{
Hyphenated
<
>
Simple
<
>
Urn
<
>
Braced
<
>
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
hyphenated_trailing
(
)
{
let
mut
buf
=
[
b
'
x
'
;
100
]
;
let
len
=
Uuid
:
:
nil
(
)
.
hyphenated
(
)
.
encode_lower
(
&
mut
buf
)
.
len
(
)
;
assert_eq
!
(
len
super
:
:
Hyphenated
:
:
LENGTH
)
;
assert
!
(
buf
[
len
.
.
]
.
iter
(
)
.
all
(
|
x
|
*
x
=
=
b
'
x
'
)
)
;
}
#
[
test
]
fn
hyphenated_ref_trailing
(
)
{
let
mut
buf
=
[
b
'
x
'
;
100
]
;
let
len
=
Uuid
:
:
nil
(
)
.
as_hyphenated
(
)
.
encode_lower
(
&
mut
buf
)
.
len
(
)
;
assert_eq
!
(
len
super
:
:
Hyphenated
:
:
LENGTH
)
;
assert
!
(
buf
[
len
.
.
]
.
iter
(
)
.
all
(
|
x
|
*
x
=
=
b
'
x
'
)
)
;
}
#
[
test
]
fn
simple_trailing
(
)
{
let
mut
buf
=
[
b
'
x
'
;
100
]
;
let
len
=
Uuid
:
:
nil
(
)
.
simple
(
)
.
encode_lower
(
&
mut
buf
)
.
len
(
)
;
assert_eq
!
(
len
super
:
:
Simple
:
:
LENGTH
)
;
assert
!
(
buf
[
len
.
.
]
.
iter
(
)
.
all
(
|
x
|
*
x
=
=
b
'
x
'
)
)
;
}
#
[
test
]
fn
simple_ref_trailing
(
)
{
let
mut
buf
=
[
b
'
x
'
;
100
]
;
let
len
=
Uuid
:
:
nil
(
)
.
as_simple
(
)
.
encode_lower
(
&
mut
buf
)
.
len
(
)
;
assert_eq
!
(
len
super
:
:
Simple
:
:
LENGTH
)
;
assert
!
(
buf
[
len
.
.
]
.
iter
(
)
.
all
(
|
x
|
*
x
=
=
b
'
x
'
)
)
;
}
#
[
test
]
fn
urn_trailing
(
)
{
let
mut
buf
=
[
b
'
x
'
;
100
]
;
let
len
=
Uuid
:
:
nil
(
)
.
urn
(
)
.
encode_lower
(
&
mut
buf
)
.
len
(
)
;
assert_eq
!
(
len
super
:
:
Urn
:
:
LENGTH
)
;
assert
!
(
buf
[
len
.
.
]
.
iter
(
)
.
all
(
|
x
|
*
x
=
=
b
'
x
'
)
)
;
}
#
[
test
]
fn
urn_ref_trailing
(
)
{
let
mut
buf
=
[
b
'
x
'
;
100
]
;
let
len
=
Uuid
:
:
nil
(
)
.
as_urn
(
)
.
encode_lower
(
&
mut
buf
)
.
len
(
)
;
assert_eq
!
(
len
super
:
:
Urn
:
:
LENGTH
)
;
assert
!
(
buf
[
len
.
.
]
.
iter
(
)
.
all
(
|
x
|
*
x
=
=
b
'
x
'
)
)
;
}
#
[
test
]
fn
braced_trailing
(
)
{
let
mut
buf
=
[
b
'
x
'
;
100
]
;
let
len
=
Uuid
:
:
nil
(
)
.
braced
(
)
.
encode_lower
(
&
mut
buf
)
.
len
(
)
;
assert_eq
!
(
len
super
:
:
Braced
:
:
LENGTH
)
;
assert
!
(
buf
[
len
.
.
]
.
iter
(
)
.
all
(
|
x
|
*
x
=
=
b
'
x
'
)
)
;
}
#
[
test
]
fn
braced_ref_trailing
(
)
{
let
mut
buf
=
[
b
'
x
'
;
100
]
;
let
len
=
Uuid
:
:
nil
(
)
.
as_braced
(
)
.
encode_lower
(
&
mut
buf
)
.
len
(
)
;
assert_eq
!
(
len
super
:
:
Braced
:
:
LENGTH
)
;
assert
!
(
buf
[
len
.
.
]
.
iter
(
)
.
all
(
|
x
|
*
x
=
=
b
'
x
'
)
)
;
}
#
[
test
]
#
[
should_panic
]
fn
hyphenated_too_small
(
)
{
Uuid
:
:
nil
(
)
.
hyphenated
(
)
.
encode_lower
(
&
mut
[
0
;
35
]
)
;
}
#
[
test
]
#
[
should_panic
]
fn
simple_too_small
(
)
{
Uuid
:
:
nil
(
)
.
simple
(
)
.
encode_lower
(
&
mut
[
0
;
31
]
)
;
}
#
[
test
]
#
[
should_panic
]
fn
urn_too_small
(
)
{
Uuid
:
:
nil
(
)
.
urn
(
)
.
encode_lower
(
&
mut
[
0
;
44
]
)
;
}
#
[
test
]
#
[
should_panic
]
fn
braced_too_small
(
)
{
Uuid
:
:
nil
(
)
.
braced
(
)
.
encode_lower
(
&
mut
[
0
;
37
]
)
;
}
#
[
test
]
fn
hyphenated_to_inner
(
)
{
let
hyphenated
=
Uuid
:
:
nil
(
)
.
hyphenated
(
)
;
assert_eq
!
(
Uuid
:
:
from
(
hyphenated
)
Uuid
:
:
nil
(
)
)
;
}
#
[
test
]
fn
simple_to_inner
(
)
{
let
simple
=
Uuid
:
:
nil
(
)
.
simple
(
)
;
assert_eq
!
(
Uuid
:
:
from
(
simple
)
Uuid
:
:
nil
(
)
)
;
}
#
[
test
]
fn
urn_to_inner
(
)
{
let
urn
=
Uuid
:
:
nil
(
)
.
urn
(
)
;
assert_eq
!
(
Uuid
:
:
from
(
urn
)
Uuid
:
:
nil
(
)
)
;
}
#
[
test
]
fn
braced_to_inner
(
)
{
let
braced
=
Uuid
:
:
nil
(
)
.
braced
(
)
;
assert_eq
!
(
Uuid
:
:
from
(
braced
)
Uuid
:
:
nil
(
)
)
;
}
}
