mod
error
;
pub
(
crate
)
use
self
:
:
error
:
:
Error
;
use
crate
:
:
prelude
:
:
*
;
impl
Uuid
{
pub
const
fn
nil
(
)
-
>
Self
{
Uuid
:
:
from_bytes
(
[
0
;
16
]
)
}
pub
fn
from_fields
(
d1
:
u32
d2
:
u16
d3
:
u16
d4
:
&
[
u8
]
)
-
>
Result
<
Uuid
crate
:
:
Error
>
{
const
D4_LEN
:
usize
=
8
;
let
len
=
d4
.
len
(
)
;
if
len
!
=
D4_LEN
{
Err
(
Error
:
:
new
(
D4_LEN
len
)
)
?
;
}
Ok
(
Uuid
:
:
from_bytes
(
[
(
d1
>
>
24
)
as
u8
(
d1
>
>
16
)
as
u8
(
d1
>
>
8
)
as
u8
d1
as
u8
(
d2
>
>
8
)
as
u8
d2
as
u8
(
d3
>
>
8
)
as
u8
d3
as
u8
d4
[
0
]
d4
[
1
]
d4
[
2
]
d4
[
3
]
d4
[
4
]
d4
[
5
]
d4
[
6
]
d4
[
7
]
]
)
)
}
pub
fn
from_fields_le
(
d1
:
u32
d2
:
u16
d3
:
u16
d4
:
&
[
u8
]
)
-
>
Result
<
Uuid
crate
:
:
Error
>
{
const
D4_LEN
:
usize
=
8
;
let
len
=
d4
.
len
(
)
;
if
len
!
=
D4_LEN
{
Err
(
Error
:
:
new
(
D4_LEN
len
)
)
?
;
}
Ok
(
Uuid
:
:
from_bytes
(
[
d1
as
u8
(
d1
>
>
8
)
as
u8
(
d1
>
>
16
)
as
u8
(
d1
>
>
24
)
as
u8
(
d2
)
as
u8
(
d2
>
>
8
)
as
u8
d3
as
u8
(
d3
>
>
8
)
as
u8
d4
[
0
]
d4
[
1
]
d4
[
2
]
d4
[
3
]
d4
[
4
]
d4
[
5
]
d4
[
6
]
d4
[
7
]
]
)
)
}
pub
const
fn
from_u128
(
v
:
u128
)
-
>
Self
{
Uuid
:
:
from_bytes
(
[
(
v
>
>
120
)
as
u8
(
v
>
>
112
)
as
u8
(
v
>
>
104
)
as
u8
(
v
>
>
96
)
as
u8
(
v
>
>
88
)
as
u8
(
v
>
>
80
)
as
u8
(
v
>
>
72
)
as
u8
(
v
>
>
64
)
as
u8
(
v
>
>
56
)
as
u8
(
v
>
>
48
)
as
u8
(
v
>
>
40
)
as
u8
(
v
>
>
32
)
as
u8
(
v
>
>
24
)
as
u8
(
v
>
>
16
)
as
u8
(
v
>
>
8
)
as
u8
v
as
u8
]
)
}
pub
const
fn
from_u128_le
(
v
:
u128
)
-
>
Self
{
Uuid
:
:
from_bytes
(
[
v
as
u8
(
v
>
>
8
)
as
u8
(
v
>
>
16
)
as
u8
(
v
>
>
24
)
as
u8
(
v
>
>
32
)
as
u8
(
v
>
>
40
)
as
u8
(
v
>
>
48
)
as
u8
(
v
>
>
56
)
as
u8
(
v
>
>
64
)
as
u8
(
v
>
>
72
)
as
u8
(
v
>
>
80
)
as
u8
(
v
>
>
88
)
as
u8
(
v
>
>
96
)
as
u8
(
v
>
>
104
)
as
u8
(
v
>
>
112
)
as
u8
(
v
>
>
120
)
as
u8
]
)
}
pub
fn
from_slice
(
b
:
&
[
u8
]
)
-
>
Result
<
Uuid
crate
:
:
Error
>
{
const
BYTES_LEN
:
usize
=
16
;
let
len
=
b
.
len
(
)
;
if
len
!
=
BYTES_LEN
{
Err
(
Error
:
:
new
(
BYTES_LEN
len
)
)
?
;
}
let
mut
bytes
:
Bytes
=
[
0
;
16
]
;
bytes
.
copy_from_slice
(
b
)
;
Ok
(
Uuid
:
:
from_bytes
(
bytes
)
)
}
pub
const
fn
from_bytes
(
bytes
:
Bytes
)
-
>
Uuid
{
Uuid
(
bytes
)
}
}
#
[
allow
(
dead_code
)
]
#
[
deprecated
]
pub
type
Builder
=
crate
:
:
Builder
;
impl
crate
:
:
Builder
{
pub
const
fn
from_bytes
(
b
:
Bytes
)
-
>
Self
{
Builder
(
b
)
}
pub
fn
from_slice
(
b
:
&
[
u8
]
)
-
>
Result
<
Self
crate
:
:
Error
>
{
const
BYTES_LEN
:
usize
=
16
;
let
len
=
b
.
len
(
)
;
if
len
!
=
BYTES_LEN
{
Err
(
Error
:
:
new
(
BYTES_LEN
len
)
)
?
;
}
let
mut
bytes
:
crate
:
:
Bytes
=
[
0
;
16
]
;
bytes
.
copy_from_slice
(
b
)
;
Ok
(
Self
:
:
from_bytes
(
bytes
)
)
}
pub
fn
from_fields
(
d1
:
u32
d2
:
u16
d3
:
u16
d4
:
&
[
u8
]
)
-
>
Result
<
Self
crate
:
:
Error
>
{
Uuid
:
:
from_fields
(
d1
d2
d3
d4
)
.
map
(
|
uuid
|
{
let
bytes
=
*
uuid
.
as_bytes
(
)
;
crate
:
:
Builder
:
:
from_bytes
(
bytes
)
}
)
}
pub
fn
from_u128
(
v
:
u128
)
-
>
Self
{
crate
:
:
Builder
:
:
from_bytes
(
*
Uuid
:
:
from_u128
(
v
)
.
as_bytes
(
)
)
}
pub
const
fn
nil
(
)
-
>
Self
{
Builder
(
[
0
;
16
]
)
}
pub
fn
set_variant
(
&
mut
self
v
:
crate
:
:
Variant
)
-
>
&
mut
Self
{
let
byte
=
self
.
0
[
8
]
;
self
.
0
[
8
]
=
match
v
{
crate
:
:
Variant
:
:
NCS
=
>
byte
&
0x7f
crate
:
:
Variant
:
:
RFC4122
=
>
(
byte
&
0x3f
)
|
0x80
crate
:
:
Variant
:
:
Microsoft
=
>
(
byte
&
0x1f
)
|
0xc0
crate
:
:
Variant
:
:
Future
=
>
(
byte
&
0x1f
)
|
0xe0
}
;
self
}
pub
fn
set_version
(
&
mut
self
v
:
crate
:
:
Version
)
-
>
&
mut
Self
{
self
.
0
[
6
]
=
(
self
.
0
[
6
]
&
0x0f
)
|
(
(
v
as
u8
)
<
<
4
)
;
self
}
pub
fn
build
(
&
mut
self
)
-
>
Uuid
{
Uuid
:
:
from_bytes
(
self
.
0
)
}
}
