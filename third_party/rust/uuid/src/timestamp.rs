use
crate
:
:
Uuid
;
pub
const
UUID_TICKS_BETWEEN_EPOCHS
:
u64
=
0x01B2_1DD2_1381_4000
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
pub
struct
Timestamp
{
pub
(
crate
)
seconds
:
u64
pub
(
crate
)
nanos
:
u32
#
[
cfg
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
]
pub
(
crate
)
counter
:
u16
}
impl
Timestamp
{
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
now
(
context
:
impl
ClockSequence
<
Output
=
u16
>
)
-
>
Self
{
#
[
cfg
(
not
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
)
]
{
let
_
=
context
;
}
let
(
seconds
nanos
)
=
now
(
)
;
Timestamp
{
seconds
nanos
#
[
cfg
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
]
counter
:
context
.
generate_sequence
(
seconds
nanos
)
}
}
pub
const
fn
from_rfc4122
(
ticks
:
u64
counter
:
u16
)
-
>
Self
{
#
[
cfg
(
not
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
)
]
{
let
_
=
counter
;
}
let
(
seconds
nanos
)
=
Self
:
:
rfc4122_to_unix
(
ticks
)
;
Timestamp
{
seconds
nanos
#
[
cfg
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
]
counter
}
}
pub
fn
from_unix
(
context
:
impl
ClockSequence
<
Output
=
u16
>
seconds
:
u64
nanos
:
u32
)
-
>
Self
{
#
[
cfg
(
not
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
)
]
{
let
_
=
context
;
Timestamp
{
seconds
nanos
}
}
#
[
cfg
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
]
{
let
counter
=
context
.
generate_sequence
(
seconds
nanos
)
;
Timestamp
{
seconds
nanos
counter
}
}
}
#
[
cfg
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
]
pub
const
fn
to_rfc4122
(
&
self
)
-
>
(
u64
u16
)
{
(
Self
:
:
unix_to_rfc4122_ticks
(
self
.
seconds
self
.
nanos
)
self
.
counter
)
}
pub
const
fn
to_unix
(
&
self
)
-
>
(
u64
u32
)
{
(
self
.
seconds
self
.
nanos
)
}
#
[
cfg
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
]
const
fn
unix_to_rfc4122_ticks
(
seconds
:
u64
nanos
:
u32
)
-
>
u64
{
let
ticks
=
UUID_TICKS_BETWEEN_EPOCHS
+
seconds
*
10_000_000
+
nanos
as
u64
/
100
;
ticks
}
const
fn
rfc4122_to_unix
(
ticks
:
u64
)
-
>
(
u64
u32
)
{
(
(
ticks
-
UUID_TICKS_BETWEEN_EPOCHS
)
/
10_000_000
(
(
ticks
-
UUID_TICKS_BETWEEN_EPOCHS
)
%
10_000_000
)
as
u32
*
100
)
}
#
[
deprecated
(
note
=
"
use
to_unix
instead
"
)
]
pub
const
fn
to_unix_nanos
(
&
self
)
-
>
u32
{
self
.
nanos
}
}
pub
(
crate
)
const
fn
encode_rfc4122_timestamp
(
ticks
:
u64
counter
:
u16
node_id
:
&
[
u8
;
6
]
)
-
>
Uuid
{
let
time_low
=
(
ticks
&
0xFFFF_FFFF
)
as
u32
;
let
time_mid
=
(
(
ticks
>
>
32
)
&
0xFFFF
)
as
u16
;
let
time_high_and_version
=
(
(
(
ticks
>
>
48
)
&
0x0FFF
)
as
u16
)
|
(
1
<
<
12
)
;
let
mut
d4
=
[
0
;
8
]
;
d4
[
0
]
=
(
(
(
counter
&
0x3F00
)
>
>
8
)
as
u8
)
|
0x80
;
d4
[
1
]
=
(
counter
&
0xFF
)
as
u8
;
d4
[
2
]
=
node_id
[
0
]
;
d4
[
3
]
=
node_id
[
1
]
;
d4
[
4
]
=
node_id
[
2
]
;
d4
[
5
]
=
node_id
[
3
]
;
d4
[
6
]
=
node_id
[
4
]
;
d4
[
7
]
=
node_id
[
5
]
;
Uuid
:
:
from_fields
(
time_low
time_mid
time_high_and_version
&
d4
)
}
pub
(
crate
)
const
fn
decode_rfc4122_timestamp
(
uuid
:
&
Uuid
)
-
>
(
u64
u16
)
{
let
bytes
=
uuid
.
as_bytes
(
)
;
let
ticks
:
u64
=
(
(
bytes
[
6
]
&
0x0F
)
as
u64
)
<
<
56
|
(
bytes
[
7
]
as
u64
)
<
<
48
|
(
bytes
[
4
]
as
u64
)
<
<
40
|
(
bytes
[
5
]
as
u64
)
<
<
32
|
(
bytes
[
0
]
as
u64
)
<
<
24
|
(
bytes
[
1
]
as
u64
)
<
<
16
|
(
bytes
[
2
]
as
u64
)
<
<
8
|
(
bytes
[
3
]
as
u64
)
;
let
counter
:
u16
=
(
(
bytes
[
8
]
&
0x3F
)
as
u16
)
<
<
8
|
(
bytes
[
9
]
as
u16
)
;
(
ticks
counter
)
}
#
[
cfg
(
uuid_unstable
)
]
pub
(
crate
)
const
fn
encode_sorted_rfc4122_timestamp
(
ticks
:
u64
counter
:
u16
node_id
:
&
[
u8
;
6
]
)
-
>
Uuid
{
let
time_high
=
(
(
ticks
>
>
28
)
&
0xFFFF_FFFF
)
as
u32
;
let
time_mid
=
(
(
ticks
>
>
12
)
&
0xFFFF
)
as
u16
;
let
time_low_and_version
=
(
(
ticks
&
0x0FFF
)
as
u16
)
|
(
0x6
<
<
12
)
;
let
mut
d4
=
[
0
;
8
]
;
d4
[
0
]
=
(
(
(
counter
&
0x3F00
)
>
>
8
)
as
u8
)
|
0x80
;
d4
[
1
]
=
(
counter
&
0xFF
)
as
u8
;
d4
[
2
]
=
node_id
[
0
]
;
d4
[
3
]
=
node_id
[
1
]
;
d4
[
4
]
=
node_id
[
2
]
;
d4
[
5
]
=
node_id
[
3
]
;
d4
[
6
]
=
node_id
[
4
]
;
d4
[
7
]
=
node_id
[
5
]
;
Uuid
:
:
from_fields
(
time_high
time_mid
time_low_and_version
&
d4
)
}
#
[
cfg
(
uuid_unstable
)
]
pub
(
crate
)
const
fn
decode_sorted_rfc4122_timestamp
(
uuid
:
&
Uuid
)
-
>
(
u64
u16
)
{
let
bytes
=
uuid
.
as_bytes
(
)
;
let
ticks
:
u64
=
(
(
bytes
[
0
]
)
as
u64
)
<
<
52
|
(
bytes
[
1
]
as
u64
)
<
<
44
|
(
bytes
[
2
]
as
u64
)
<
<
36
|
(
bytes
[
3
]
as
u64
)
<
<
28
|
(
bytes
[
4
]
as
u64
)
<
<
20
|
(
bytes
[
5
]
as
u64
)
<
<
12
|
(
(
bytes
[
6
]
&
0xF
)
as
u64
)
<
<
8
|
(
bytes
[
7
]
as
u64
)
;
let
counter
:
u16
=
(
(
bytes
[
8
]
&
0x3F
)
as
u16
)
<
<
8
|
(
bytes
[
9
]
as
u16
)
;
(
ticks
counter
)
}
#
[
cfg
(
uuid_unstable
)
]
pub
(
crate
)
const
fn
encode_unix_timestamp_millis
(
millis
:
u64
random_bytes
:
&
[
u8
;
10
]
)
-
>
Uuid
{
let
millis_high
=
(
(
millis
>
>
16
)
&
0xFFFF_FFFF
)
as
u32
;
let
millis_low
=
(
millis
&
0xFFFF
)
as
u16
;
let
random_and_version
=
(
random_bytes
[
0
]
as
u16
|
(
(
random_bytes
[
1
]
as
u16
)
<
<
8
)
&
0x0FFF
)
|
(
0x7
<
<
12
)
;
let
mut
d4
=
[
0
;
8
]
;
d4
[
0
]
=
(
random_bytes
[
2
]
&
0x3F
)
|
0x80
;
d4
[
1
]
=
random_bytes
[
3
]
;
d4
[
2
]
=
random_bytes
[
4
]
;
d4
[
3
]
=
random_bytes
[
5
]
;
d4
[
4
]
=
random_bytes
[
6
]
;
d4
[
5
]
=
random_bytes
[
7
]
;
d4
[
6
]
=
random_bytes
[
8
]
;
d4
[
7
]
=
random_bytes
[
9
]
;
Uuid
:
:
from_fields
(
millis_high
millis_low
random_and_version
&
d4
)
}
#
[
cfg
(
uuid_unstable
)
]
pub
(
crate
)
const
fn
decode_unix_timestamp_millis
(
uuid
:
&
Uuid
)
-
>
u64
{
let
bytes
=
uuid
.
as_bytes
(
)
;
let
millis
:
u64
=
(
bytes
[
0
]
as
u64
)
<
<
40
|
(
bytes
[
1
]
as
u64
)
<
<
32
|
(
bytes
[
2
]
as
u64
)
<
<
24
|
(
bytes
[
3
]
as
u64
)
<
<
16
|
(
bytes
[
4
]
as
u64
)
<
<
8
|
(
bytes
[
5
]
as
u64
)
;
millis
}
#
[
cfg
(
all
(
feature
=
"
std
"
feature
=
"
js
"
target_arch
=
"
wasm32
"
)
)
]
fn
now
(
)
-
>
(
u64
u32
)
{
use
wasm_bindgen
:
:
prelude
:
:
*
;
#
[
wasm_bindgen
]
extern
"
C
"
{
#
[
wasm_bindgen
(
js_namespace
=
Date
)
]
fn
now
(
)
-
>
f64
;
}
let
now
=
now
(
)
;
let
secs
=
(
now
/
1_000
.
0
)
as
u64
;
let
nanos
=
(
(
now
%
1_000
.
0
)
*
1_000_000
.
0
)
as
u32
;
dbg
!
(
(
secs
nanos
)
)
}
#
[
cfg
(
all
(
feature
=
"
std
"
any
(
not
(
feature
=
"
js
"
)
not
(
target_arch
=
"
wasm32
"
)
)
)
)
]
fn
now
(
)
-
>
(
u64
u32
)
{
let
dur
=
std
:
:
time
:
:
SystemTime
:
:
UNIX_EPOCH
.
elapsed
(
)
.
expect
(
"
Getting
elapsed
time
since
UNIX_EPOCH
.
If
this
fails
we
'
ve
somehow
violated
causality
"
)
;
(
dur
.
as_secs
(
)
dur
.
subsec_nanos
(
)
)
}
pub
trait
ClockSequence
{
type
Output
;
fn
generate_sequence
(
&
self
seconds
:
u64
subsec_nanos
:
u32
)
-
>
Self
:
:
Output
;
}
impl
<
'
a
T
:
ClockSequence
+
?
Sized
>
ClockSequence
for
&
'
a
T
{
type
Output
=
T
:
:
Output
;
fn
generate_sequence
(
&
self
seconds
:
u64
subsec_nanos
:
u32
)
-
>
Self
:
:
Output
{
(
*
*
self
)
.
generate_sequence
(
seconds
subsec_nanos
)
}
}
pub
mod
context
{
use
super
:
:
ClockSequence
;
#
[
cfg
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
]
use
atomic
:
:
{
Atomic
Ordering
}
;
#
[
derive
(
Debug
Clone
Copy
Default
)
]
pub
struct
NoContext
;
impl
ClockSequence
for
NoContext
{
type
Output
=
u16
;
fn
generate_sequence
(
&
self
_seconds
:
u64
_nanos
:
u32
)
-
>
Self
:
:
Output
{
0
}
}
#
[
cfg
(
all
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
feature
=
"
std
"
feature
=
"
rng
"
)
)
]
static
CONTEXT
:
Context
=
Context
{
count
:
Atomic
:
:
new
(
0
)
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
feature
=
"
std
"
feature
=
"
rng
"
)
)
]
static
CONTEXT_INITIALIZED
:
Atomic
<
bool
>
=
Atomic
:
:
new
(
false
)
;
#
[
cfg
(
all
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
feature
=
"
std
"
feature
=
"
rng
"
)
)
]
pub
(
crate
)
fn
shared_context
(
)
-
>
&
'
static
Context
{
if
CONTEXT_INITIALIZED
.
compare_exchange
(
false
true
Ordering
:
:
Relaxed
Ordering
:
:
Relaxed
)
.
is_ok
(
)
{
CONTEXT
.
count
.
store
(
crate
:
:
rng
:
:
u16
(
)
Ordering
:
:
Release
)
;
}
&
CONTEXT
}
#
[
derive
(
Debug
)
]
#
[
cfg
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
]
pub
struct
Context
{
count
:
Atomic
<
u16
>
}
#
[
cfg
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
]
impl
Context
{
pub
const
fn
new
(
count
:
u16
)
-
>
Self
{
Self
{
count
:
Atomic
:
:
<
u16
>
:
:
new
(
count
)
}
}
#
[
cfg
(
feature
=
"
rng
"
)
]
pub
fn
new_random
(
)
-
>
Self
{
Self
{
count
:
Atomic
:
:
<
u16
>
:
:
new
(
crate
:
:
rng
:
:
u16
(
)
)
}
}
}
#
[
cfg
(
any
(
feature
=
"
v1
"
feature
=
"
v6
"
)
)
]
impl
ClockSequence
for
Context
{
type
Output
=
u16
;
fn
generate_sequence
(
&
self
_seconds
:
u64
_nanos
:
u32
)
-
>
Self
:
:
Output
{
self
.
count
.
fetch_add
(
1
Ordering
:
:
AcqRel
)
%
(
u16
:
:
MAX
>
>
2
)
}
}
}
