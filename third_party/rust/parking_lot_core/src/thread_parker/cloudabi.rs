use
cloudabi
as
abi
;
use
core
:
:
{
cell
:
:
Cell
mem
sync
:
:
atomic
:
:
{
AtomicU32
Ordering
}
}
;
use
std
:
:
{
convert
:
:
TryFrom
thread
time
:
:
Instant
}
;
extern
"
C
"
{
#
[
thread_local
]
static
__pthread_thread_id
:
abi
:
:
tid
;
}
struct
Lock
{
lock
:
AtomicU32
}
impl
Lock
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Lock
{
lock
:
AtomicU32
:
:
new
(
abi
:
:
LOCK_UNLOCKED
.
0
)
}
}
#
[
inline
]
fn
try_lock
(
&
self
)
-
>
Option
<
LockGuard
<
'
_
>
>
{
if
let
Err
(
old
)
=
self
.
lock
.
compare_exchange
(
abi
:
:
LOCK_UNLOCKED
.
0
unsafe
{
__pthread_thread_id
.
0
}
|
abi
:
:
LOCK_WRLOCKED
.
0
Ordering
:
:
Acquire
Ordering
:
:
Relaxed
)
{
debug_assert_ne
!
(
old
&
!
abi
:
:
LOCK_KERNEL_MANAGED
.
0
unsafe
{
__pthread_thread_id
.
0
}
|
abi
:
:
LOCK_WRLOCKED
.
0
"
Attempted
to
recursive
write
-
lock
a
lock
"
)
;
None
}
else
{
Some
(
LockGuard
{
inner
:
&
self
}
)
}
}
#
[
inline
]
pub
fn
lock
(
&
self
)
-
>
LockGuard
<
'
_
>
{
self
.
try_lock
(
)
.
unwrap_or_else
(
|
|
{
unsafe
{
let
subscription
=
abi
:
:
subscription
{
type_
:
abi
:
:
eventtype
:
:
LOCK_WRLOCK
union
:
abi
:
:
subscription_union
{
lock
:
abi
:
:
subscription_lock
{
lock
:
self
.
ptr
(
)
lock_scope
:
abi
:
:
scope
:
:
PRIVATE
}
}
.
.
mem
:
:
zeroed
(
)
}
;
let
mut
event
:
abi
:
:
event
=
mem
:
:
uninitialized
(
)
;
let
mut
nevents
:
usize
=
mem
:
:
uninitialized
(
)
;
let
ret
=
abi
:
:
poll
(
&
subscription
&
mut
event
1
&
mut
nevents
)
;
debug_assert_eq
!
(
ret
abi
:
:
errno
:
:
SUCCESS
)
;
debug_assert_eq
!
(
event
.
error
abi
:
:
errno
:
:
SUCCESS
)
;
}
LockGuard
{
inner
:
&
self
}
}
)
}
#
[
inline
]
fn
ptr
(
&
self
)
-
>
*
mut
abi
:
:
lock
{
&
self
.
lock
as
*
const
AtomicU32
as
*
mut
abi
:
:
lock
}
}
struct
LockGuard
<
'
a
>
{
inner
:
&
'
a
Lock
}
impl
LockGuard
<
'
_
>
{
#
[
inline
]
fn
ptr
(
&
self
)
-
>
*
mut
abi
:
:
lock
{
&
self
.
inner
.
lock
as
*
const
AtomicU32
as
*
mut
abi
:
:
lock
}
}
impl
Drop
for
LockGuard
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
debug_assert_eq
!
(
self
.
inner
.
lock
.
load
(
Ordering
:
:
Relaxed
)
&
!
abi
:
:
LOCK_KERNEL_MANAGED
.
0
unsafe
{
__pthread_thread_id
.
0
}
|
abi
:
:
LOCK_WRLOCKED
.
0
"
This
lock
is
not
write
-
locked
by
this
thread
"
)
;
if
!
self
.
inner
.
lock
.
compare_exchange
(
unsafe
{
__pthread_thread_id
.
0
}
|
abi
:
:
LOCK_WRLOCKED
.
0
abi
:
:
LOCK_UNLOCKED
.
0
Ordering
:
:
Release
Ordering
:
:
Relaxed
)
.
is_ok
(
)
{
let
ret
=
unsafe
{
abi
:
:
lock_unlock
(
self
.
ptr
(
)
abi
:
:
scope
:
:
PRIVATE
)
}
;
debug_assert_eq
!
(
ret
abi
:
:
errno
:
:
SUCCESS
)
;
}
}
}
struct
Condvar
{
condvar
:
AtomicU32
}
impl
Condvar
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Condvar
{
condvar
:
AtomicU32
:
:
new
(
abi
:
:
CONDVAR_HAS_NO_WAITERS
.
0
)
}
}
#
[
inline
]
pub
fn
wait
(
&
self
lock
:
&
LockGuard
<
'
_
>
)
{
unsafe
{
let
subscription
=
abi
:
:
subscription
{
type_
:
abi
:
:
eventtype
:
:
CONDVAR
union
:
abi
:
:
subscription_union
{
condvar
:
abi
:
:
subscription_condvar
{
condvar
:
self
.
ptr
(
)
condvar_scope
:
abi
:
:
scope
:
:
PRIVATE
lock
:
lock
.
ptr
(
)
lock_scope
:
abi
:
:
scope
:
:
PRIVATE
}
}
.
.
mem
:
:
zeroed
(
)
}
;
let
mut
event
:
abi
:
:
event
=
mem
:
:
uninitialized
(
)
;
let
mut
nevents
:
usize
=
mem
:
:
uninitialized
(
)
;
let
ret
=
abi
:
:
poll
(
&
subscription
&
mut
event
1
&
mut
nevents
)
;
debug_assert_eq
!
(
ret
abi
:
:
errno
:
:
SUCCESS
)
;
debug_assert_eq
!
(
event
.
error
abi
:
:
errno
:
:
SUCCESS
)
;
}
}
#
[
inline
]
pub
fn
wait_timeout
(
&
self
lock
:
&
LockGuard
<
'
_
>
timeout
:
abi
:
:
timestamp
)
-
>
bool
{
unsafe
{
let
subscriptions
=
[
abi
:
:
subscription
{
type_
:
abi
:
:
eventtype
:
:
CONDVAR
union
:
abi
:
:
subscription_union
{
condvar
:
abi
:
:
subscription_condvar
{
condvar
:
self
.
ptr
(
)
condvar_scope
:
abi
:
:
scope
:
:
PRIVATE
lock
:
lock
.
ptr
(
)
lock_scope
:
abi
:
:
scope
:
:
PRIVATE
}
}
.
.
mem
:
:
zeroed
(
)
}
abi
:
:
subscription
{
type_
:
abi
:
:
eventtype
:
:
CLOCK
union
:
abi
:
:
subscription_union
{
clock
:
abi
:
:
subscription_clock
{
clock_id
:
abi
:
:
clockid
:
:
MONOTONIC
timeout
.
.
mem
:
:
zeroed
(
)
}
}
.
.
mem
:
:
zeroed
(
)
}
]
;
let
mut
events
:
[
abi
:
:
event
;
2
]
=
mem
:
:
uninitialized
(
)
;
let
mut
nevents
:
usize
=
mem
:
:
uninitialized
(
)
;
let
ret
=
abi
:
:
poll
(
subscriptions
.
as_ptr
(
)
events
.
as_mut_ptr
(
)
2
&
mut
nevents
)
;
debug_assert_eq
!
(
ret
abi
:
:
errno
:
:
SUCCESS
)
;
for
i
in
0
.
.
nevents
{
debug_assert_eq
!
(
events
[
i
]
.
error
abi
:
:
errno
:
:
SUCCESS
)
;
if
events
[
i
]
.
type_
=
=
abi
:
:
eventtype
:
:
CONDVAR
{
return
true
;
}
}
}
false
}
#
[
inline
]
pub
fn
notify
(
&
self
)
{
let
ret
=
unsafe
{
abi
:
:
condvar_signal
(
self
.
ptr
(
)
abi
:
:
scope
:
:
PRIVATE
1
)
}
;
debug_assert_eq
!
(
ret
abi
:
:
errno
:
:
SUCCESS
)
;
}
#
[
inline
]
fn
ptr
(
&
self
)
-
>
*
mut
abi
:
:
condvar
{
&
self
.
condvar
as
*
const
AtomicU32
as
*
mut
abi
:
:
condvar
}
}
pub
struct
ThreadParker
{
should_park
:
Cell
<
bool
>
lock
:
Lock
condvar
:
Condvar
}
impl
ThreadParker
{
pub
const
IS_CHEAP_TO_CONSTRUCT
:
bool
=
true
;
#
[
inline
]
pub
fn
new
(
)
-
>
ThreadParker
{
ThreadParker
{
should_park
:
Cell
:
:
new
(
false
)
lock
:
Lock
:
:
new
(
)
condvar
:
Condvar
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
prepare_park
(
&
self
)
{
self
.
should_park
.
set
(
true
)
;
}
#
[
inline
]
pub
fn
timed_out
(
&
self
)
-
>
bool
{
let
_guard
=
self
.
lock
.
lock
(
)
;
self
.
should_park
.
get
(
)
}
#
[
inline
]
pub
fn
park
(
&
self
)
{
let
guard
=
self
.
lock
.
lock
(
)
;
while
self
.
should_park
.
get
(
)
{
self
.
condvar
.
wait
(
&
guard
)
;
}
}
#
[
inline
]
pub
fn
park_until
(
&
self
timeout
:
Instant
)
-
>
bool
{
let
guard
=
self
.
lock
.
lock
(
)
;
while
self
.
should_park
.
get
(
)
{
if
let
Some
(
duration_left
)
=
timeout
.
checked_duration_since
(
Instant
:
:
now
(
)
)
{
if
let
Ok
(
nanos_left
)
=
abi
:
:
timestamp
:
:
try_from
(
duration_left
.
as_nanos
(
)
)
{
self
.
condvar
.
wait_timeout
(
&
guard
nanos_left
)
;
}
else
{
self
.
condvar
.
wait
(
&
guard
)
;
}
}
else
{
return
false
;
}
}
true
}
#
[
inline
]
pub
fn
unpark_lock
(
&
self
)
-
>
UnparkHandle
<
'
_
>
{
let
_lock_guard
=
self
.
lock
.
lock
(
)
;
UnparkHandle
{
thread_parker
:
self
_lock_guard
}
}
}
pub
struct
UnparkHandle
<
'
a
>
{
thread_parker
:
*
const
ThreadParker
_lock_guard
:
LockGuard
<
'
a
>
}
impl
UnparkHandle
<
'
_
>
{
#
[
inline
]
pub
fn
unpark
(
self
)
{
unsafe
{
(
*
self
.
thread_parker
)
.
should_park
.
set
(
false
)
;
(
*
self
.
thread_parker
)
.
condvar
.
notify
(
)
;
}
}
}
#
[
inline
]
pub
fn
thread_yield
(
)
{
thread
:
:
yield_now
(
)
;
}
