#
[
cfg
(
feature
=
"
nightly
"
)
]
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
ATOMIC_USIZE_INIT
Ordering
}
;
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
use
stable
:
:
{
AtomicUsize
ATOMIC_USIZE_INIT
Ordering
}
;
use
std
:
:
time
:
:
Instant
;
mod
keyed_event
;
mod
waitaddress
;
enum
Backend
{
KeyedEvent
(
keyed_event
:
:
KeyedEvent
)
WaitAddress
(
waitaddress
:
:
WaitAddress
)
}
impl
Backend
{
unsafe
fn
get
(
)
-
>
&
'
static
Backend
{
static
BACKEND
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
let
backend
=
BACKEND
.
load
(
Ordering
:
:
Acquire
)
;
if
backend
!
=
0
{
return
&
*
(
backend
as
*
const
Backend
)
;
}
;
let
backend
;
if
let
Some
(
waitaddress
)
=
waitaddress
:
:
WaitAddress
:
:
create
(
)
{
backend
=
Backend
:
:
WaitAddress
(
waitaddress
)
;
}
else
if
let
Some
(
keyed_event
)
=
keyed_event
:
:
KeyedEvent
:
:
create
(
)
{
backend
=
Backend
:
:
KeyedEvent
(
keyed_event
)
;
}
else
{
panic
!
(
"
parking_lot
requires
either
NT
Keyed
Events
(
WinXP
+
)
or
\
WaitOnAddress
/
WakeByAddress
(
Win8
+
)
"
)
;
}
let
backend
=
Box
:
:
into_raw
(
Box
:
:
new
(
backend
)
)
;
match
BACKEND
.
compare_exchange
(
0
backend
as
usize
Ordering
:
:
Release
Ordering
:
:
Relaxed
)
{
Ok
(
_
)
=
>
&
*
(
backend
as
*
const
Backend
)
Err
(
x
)
=
>
{
Box
:
:
from_raw
(
backend
)
;
&
*
(
x
as
*
const
Backend
)
}
}
}
}
pub
struct
ThreadParker
{
key
:
AtomicUsize
backend
:
&
'
static
Backend
}
impl
ThreadParker
{
pub
fn
new
(
)
-
>
ThreadParker
{
ThreadParker
{
key
:
AtomicUsize
:
:
new
(
0
)
backend
:
unsafe
{
Backend
:
:
get
(
)
}
}
}
pub
unsafe
fn
prepare_park
(
&
self
)
{
match
*
self
.
backend
{
Backend
:
:
KeyedEvent
(
ref
x
)
=
>
x
.
prepare_park
(
&
self
.
key
)
Backend
:
:
WaitAddress
(
ref
x
)
=
>
x
.
prepare_park
(
&
self
.
key
)
}
}
pub
unsafe
fn
timed_out
(
&
self
)
-
>
bool
{
match
*
self
.
backend
{
Backend
:
:
KeyedEvent
(
ref
x
)
=
>
x
.
timed_out
(
&
self
.
key
)
Backend
:
:
WaitAddress
(
ref
x
)
=
>
x
.
timed_out
(
&
self
.
key
)
}
}
pub
unsafe
fn
park
(
&
self
)
{
match
*
self
.
backend
{
Backend
:
:
KeyedEvent
(
ref
x
)
=
>
x
.
park
(
&
self
.
key
)
Backend
:
:
WaitAddress
(
ref
x
)
=
>
x
.
park
(
&
self
.
key
)
}
}
pub
unsafe
fn
park_until
(
&
self
timeout
:
Instant
)
-
>
bool
{
match
*
self
.
backend
{
Backend
:
:
KeyedEvent
(
ref
x
)
=
>
x
.
park_until
(
&
self
.
key
timeout
)
Backend
:
:
WaitAddress
(
ref
x
)
=
>
x
.
park_until
(
&
self
.
key
timeout
)
}
}
pub
unsafe
fn
unpark_lock
(
&
self
)
-
>
UnparkHandle
{
match
*
self
.
backend
{
Backend
:
:
KeyedEvent
(
ref
x
)
=
>
UnparkHandle
:
:
KeyedEvent
(
x
.
unpark_lock
(
&
self
.
key
)
)
Backend
:
:
WaitAddress
(
ref
x
)
=
>
UnparkHandle
:
:
WaitAddress
(
x
.
unpark_lock
(
&
self
.
key
)
)
}
}
}
pub
enum
UnparkHandle
{
KeyedEvent
(
keyed_event
:
:
UnparkHandle
)
WaitAddress
(
waitaddress
:
:
UnparkHandle
)
}
impl
UnparkHandle
{
pub
unsafe
fn
unpark
(
self
)
{
match
self
{
UnparkHandle
:
:
KeyedEvent
(
x
)
=
>
x
.
unpark
(
)
UnparkHandle
:
:
WaitAddress
(
x
)
=
>
x
.
unpark
(
)
}
}
}
