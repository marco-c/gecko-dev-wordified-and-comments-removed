use
std
:
:
sync
:
:
{
Mutex
MutexGuard
Condvar
}
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
time
:
:
Instant
;
pub
struct
ThreadParker
{
should_park
:
Cell
<
bool
>
mutex
:
Mutex
<
(
)
>
condvar
:
Condvar
}
impl
ThreadParker
{
pub
fn
new
(
)
-
>
ThreadParker
{
ThreadParker
{
should_park
:
Cell
:
:
new
(
false
)
mutex
:
Mutex
:
:
new
(
(
)
)
condvar
:
Condvar
:
:
new
(
)
}
}
pub
unsafe
fn
prepare_park
(
&
self
)
{
self
.
should_park
.
set
(
true
)
;
}
pub
unsafe
fn
timed_out
(
&
self
)
-
>
bool
{
self
.
should_park
.
get
(
)
}
pub
unsafe
fn
park
(
&
self
)
{
let
mut
lock
=
self
.
mutex
.
lock
(
)
.
unwrap
(
)
;
while
self
.
should_park
.
get
(
)
{
lock
=
self
.
condvar
.
wait
(
lock
)
.
unwrap
(
)
;
}
}
pub
unsafe
fn
park_until
(
&
self
timeout
:
Instant
)
-
>
bool
{
let
mut
lock
=
self
.
mutex
.
lock
(
)
.
unwrap
(
)
;
while
self
.
should_park
.
get
(
)
{
let
now
=
Instant
:
:
now
(
)
;
if
timeout
<
=
now
{
return
false
;
}
let
(
new_lock
_
)
=
self
.
condvar
.
wait_timeout
(
lock
timeout
-
now
)
.
unwrap
(
)
;
lock
=
new_lock
;
}
true
}
pub
unsafe
fn
unpark_lock
(
&
self
)
-
>
UnparkHandle
{
UnparkHandle
{
thread_parker
:
self
_guard
:
self
.
mutex
.
lock
(
)
.
unwrap
(
)
}
}
}
pub
struct
UnparkHandle
<
'
a
>
{
thread_parker
:
*
const
ThreadParker
_guard
:
MutexGuard
<
'
a
(
)
>
}
impl
<
'
a
>
UnparkHandle
<
'
a
>
{
pub
unsafe
fn
unpark
(
self
)
{
(
*
self
.
thread_parker
)
.
should_park
.
set
(
false
)
;
(
*
self
.
thread_parker
)
.
condvar
.
notify_one
(
)
;
}
}
