extern
crate
futures
;
extern
crate
tokio_executor
;
extern
crate
tokio_reactor
;
extern
crate
tokio_tcp
;
use
tokio_reactor
:
:
Reactor
;
use
tokio_tcp
:
:
TcpListener
;
use
futures
:
:
{
Future
Stream
}
;
use
futures
:
:
executor
:
:
{
spawn
Notify
Spawn
}
;
use
std
:
:
mem
;
use
std
:
:
net
:
:
TcpStream
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
#
[
test
]
fn
test_drop_on_notify
(
)
{
struct
MyNotify
;
type
Task
=
Mutex
<
Spawn
<
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
>
>
>
;
impl
Notify
for
MyNotify
{
fn
notify
(
&
self
_
:
usize
)
{
}
fn
clone_id
(
&
self
id
:
usize
)
-
>
usize
{
let
ptr
=
id
as
*
const
Task
;
let
task
=
unsafe
{
Arc
:
:
from_raw
(
ptr
)
}
;
mem
:
:
forget
(
task
.
clone
(
)
)
;
mem
:
:
forget
(
task
)
;
id
}
fn
drop_id
(
&
self
id
:
usize
)
{
let
ptr
=
id
as
*
const
Task
;
let
_
=
unsafe
{
Arc
:
:
from_raw
(
ptr
)
}
;
}
}
let
addr
=
"
127
.
0
.
0
.
1
:
0
"
.
parse
(
)
.
unwrap
(
)
;
let
mut
reactor
=
Reactor
:
:
new
(
)
.
unwrap
(
)
;
let
listener
=
TcpListener
:
:
bind
(
&
addr
)
.
unwrap
(
)
;
let
addr
=
listener
.
local_addr
(
)
.
unwrap
(
)
;
let
task
=
Box
:
:
new
(
{
listener
.
incoming
(
)
.
for_each
(
|
_
|
Ok
(
(
)
)
)
.
map_err
(
|
_
|
panic
!
(
)
)
}
)
as
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
>
;
let
task
=
Arc
:
:
new
(
Mutex
:
:
new
(
spawn
(
task
)
)
)
;
let
notify
=
Arc
:
:
new
(
MyNotify
)
;
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
unwrap
(
)
;
tokio_reactor
:
:
with_default
(
&
reactor
.
handle
(
)
&
mut
enter
|
_
|
{
let
id
=
&
*
task
as
*
const
Task
as
usize
;
task
.
lock
(
)
.
unwrap
(
)
.
poll_future_notify
(
&
notify
id
)
.
unwrap
(
)
;
}
)
;
drop
(
task
)
;
let
_s
=
TcpStream
:
:
connect
(
&
addr
)
.
unwrap
(
)
;
reactor
.
turn
(
None
)
.
unwrap
(
)
;
}
