mod
builder
;
mod
shutdown
;
mod
task_executor
;
pub
use
self
:
:
builder
:
:
Builder
;
pub
use
self
:
:
shutdown
:
:
Shutdown
;
pub
use
self
:
:
task_executor
:
:
TaskExecutor
;
use
reactor
:
:
{
Handle
Reactor
}
;
use
std
:
:
io
;
use
std
:
:
sync
:
:
Mutex
;
use
tokio_executor
:
:
enter
;
use
tokio_threadpool
as
threadpool
;
use
futures
;
use
futures
:
:
future
:
:
Future
;
#
[
derive
(
Debug
)
]
pub
struct
Runtime
{
inner
:
Option
<
Inner
>
}
#
[
derive
(
Debug
)
]
struct
Inner
{
reactor_handle
:
Handle
reactor
:
Mutex
<
Option
<
Reactor
>
>
pool
:
threadpool
:
:
ThreadPool
}
pub
fn
run
<
F
>
(
future
:
F
)
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
let
mut
entered
=
enter
(
)
.
expect
(
"
nested
tokio
:
:
run
"
)
;
let
mut
runtime
=
Runtime
:
:
new
(
)
.
expect
(
"
failed
to
start
new
Runtime
"
)
;
runtime
.
spawn
(
future
)
;
entered
.
block_on
(
runtime
.
shutdown_on_idle
(
)
)
.
expect
(
"
shutdown
cannot
error
"
)
}
impl
Runtime
{
pub
fn
new
(
)
-
>
io
:
:
Result
<
Self
>
{
Builder
:
:
new
(
)
.
build
(
)
}
#
[
deprecated
(
since
=
"
0
.
1
.
5
"
note
=
"
use
reactor
instead
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
handle
(
&
self
)
-
>
&
Handle
{
#
[
allow
(
deprecated
)
]
self
.
reactor
(
)
}
#
[
deprecated
(
since
=
"
0
.
1
.
11
"
note
=
"
there
is
now
a
reactor
per
worker
thread
"
)
]
pub
fn
reactor
(
&
self
)
-
>
&
Handle
{
let
mut
reactor
=
self
.
inner
(
)
.
reactor
.
lock
(
)
.
unwrap
(
)
;
if
let
Some
(
reactor
)
=
reactor
.
take
(
)
{
if
let
Ok
(
background
)
=
reactor
.
background
(
)
{
background
.
forget
(
)
;
}
}
&
self
.
inner
(
)
.
reactor_handle
}
pub
fn
executor
(
&
self
)
-
>
TaskExecutor
{
let
inner
=
self
.
inner
(
)
.
pool
.
sender
(
)
.
clone
(
)
;
TaskExecutor
{
inner
}
}
pub
fn
spawn
<
F
>
(
&
mut
self
future
:
F
)
-
>
&
mut
Self
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
self
.
inner_mut
(
)
.
pool
.
sender
(
)
.
spawn
(
future
)
.
unwrap
(
)
;
self
}
pub
fn
block_on
<
F
R
E
>
(
&
mut
self
future
:
F
)
-
>
Result
<
R
E
>
where
F
:
Send
+
'
static
+
Future
<
Item
=
R
Error
=
E
>
R
:
Send
+
'
static
E
:
Send
+
'
static
{
let
mut
entered
=
enter
(
)
.
expect
(
"
nested
block_on
"
)
;
let
(
tx
rx
)
=
futures
:
:
sync
:
:
oneshot
:
:
channel
(
)
;
self
.
spawn
(
future
.
then
(
move
|
r
|
tx
.
send
(
r
)
.
map_err
(
|
_
|
unreachable
!
(
)
)
)
)
;
entered
.
block_on
(
rx
)
.
unwrap
(
)
}
pub
fn
block_on_all
<
F
R
E
>
(
mut
self
future
:
F
)
-
>
Result
<
R
E
>
where
F
:
Send
+
'
static
+
Future
<
Item
=
R
Error
=
E
>
R
:
Send
+
'
static
E
:
Send
+
'
static
{
let
mut
entered
=
enter
(
)
.
expect
(
"
nested
block_on_all
"
)
;
let
(
tx
rx
)
=
futures
:
:
sync
:
:
oneshot
:
:
channel
(
)
;
self
.
spawn
(
future
.
then
(
move
|
r
|
tx
.
send
(
r
)
.
map_err
(
|
_
|
unreachable
!
(
)
)
)
)
;
let
block
=
rx
.
map_err
(
|
_
|
unreachable
!
(
)
)
.
and_then
(
move
|
r
|
{
self
.
shutdown_on_idle
(
)
.
map
(
move
|
(
)
|
r
)
}
)
;
entered
.
block_on
(
block
)
.
unwrap
(
)
}
pub
fn
shutdown_on_idle
(
mut
self
)
-
>
Shutdown
{
let
inner
=
self
.
inner
.
take
(
)
.
unwrap
(
)
;
let
inner
=
inner
.
pool
.
shutdown_on_idle
(
)
;
Shutdown
{
inner
}
}
pub
fn
shutdown_now
(
mut
self
)
-
>
Shutdown
{
let
inner
=
self
.
inner
.
take
(
)
.
unwrap
(
)
;
Shutdown
:
:
shutdown_now
(
inner
)
}
fn
inner
(
&
self
)
-
>
&
Inner
{
self
.
inner
.
as_ref
(
)
.
unwrap
(
)
}
fn
inner_mut
(
&
mut
self
)
-
>
&
mut
Inner
{
self
.
inner
.
as_mut
(
)
.
unwrap
(
)
}
}
impl
Drop
for
Runtime
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
inner
)
=
self
.
inner
.
take
(
)
{
let
shutdown
=
Shutdown
:
:
shutdown_now
(
inner
)
;
let
_
=
shutdown
.
wait
(
)
;
}
}
}
