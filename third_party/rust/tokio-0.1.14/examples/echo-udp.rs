#
!
[
deny
(
warnings
)
]
#
[
macro_use
]
extern
crate
futures
;
extern
crate
tokio
;
use
std
:
:
{
env
io
}
;
use
std
:
:
net
:
:
SocketAddr
;
use
tokio
:
:
prelude
:
:
*
;
use
tokio
:
:
net
:
:
UdpSocket
;
struct
Server
{
socket
:
UdpSocket
buf
:
Vec
<
u8
>
to_send
:
Option
<
(
usize
SocketAddr
)
>
}
impl
Future
for
Server
{
type
Item
=
(
)
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
loop
{
if
let
Some
(
(
size
peer
)
)
=
self
.
to_send
{
let
amt
=
try_ready
!
(
self
.
socket
.
poll_send_to
(
&
self
.
buf
[
.
.
size
]
&
peer
)
)
;
println
!
(
"
Echoed
{
}
/
{
}
bytes
to
{
}
"
amt
size
peer
)
;
self
.
to_send
=
None
;
}
self
.
to_send
=
Some
(
try_ready
!
(
self
.
socket
.
poll_recv_from
(
&
mut
self
.
buf
)
)
)
;
}
}
}
fn
main
(
)
-
>
Result
<
(
)
Box
<
std
:
:
error
:
:
Error
>
>
{
let
addr
=
env
:
:
args
(
)
.
nth
(
1
)
.
unwrap_or
(
"
127
.
0
.
0
.
1
:
8080
"
.
to_string
(
)
)
;
let
addr
=
addr
.
parse
:
:
<
SocketAddr
>
(
)
?
;
let
socket
=
UdpSocket
:
:
bind
(
&
addr
)
?
;
println
!
(
"
Listening
on
:
{
}
"
socket
.
local_addr
(
)
?
)
;
let
server
=
Server
{
socket
:
socket
buf
:
vec
!
[
0
;
1024
]
to_send
:
None
}
;
tokio
:
:
run
(
server
.
map_err
(
|
e
|
println
!
(
"
server
error
=
{
:
?
}
"
e
)
)
)
;
Ok
(
(
)
)
}
