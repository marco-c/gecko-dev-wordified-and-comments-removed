#
!
[
deny
(
warnings
)
]
extern
crate
tokio
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
io
:
:
BufReader
;
use
std
:
:
env
;
use
std
:
:
net
:
:
SocketAddr
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
tokio
:
:
io
:
:
{
lines
write_all
}
;
use
tokio
:
:
net
:
:
TcpListener
;
use
tokio
:
:
prelude
:
:
*
;
struct
Database
{
map
:
Mutex
<
HashMap
<
String
String
>
>
}
enum
Request
{
Get
{
key
:
String
}
Set
{
key
:
String
value
:
String
}
}
enum
Response
{
Value
{
key
:
String
value
:
String
}
Set
{
key
:
String
value
:
String
previous
:
Option
<
String
>
}
Error
{
msg
:
String
}
}
fn
main
(
)
-
>
Result
<
(
)
Box
<
std
:
:
error
:
:
Error
>
>
{
let
addr
=
env
:
:
args
(
)
.
nth
(
1
)
.
unwrap_or
(
"
127
.
0
.
0
.
1
:
8080
"
.
to_string
(
)
)
;
let
addr
=
addr
.
parse
:
:
<
SocketAddr
>
(
)
?
;
let
listener
=
TcpListener
:
:
bind
(
&
addr
)
.
map_err
(
|
_
|
"
failed
to
bind
"
)
?
;
println
!
(
"
Listening
on
:
{
}
"
addr
)
;
let
mut
initial_db
=
HashMap
:
:
new
(
)
;
initial_db
.
insert
(
"
foo
"
.
to_string
(
)
"
bar
"
.
to_string
(
)
)
;
let
db
=
Arc
:
:
new
(
Database
{
map
:
Mutex
:
:
new
(
initial_db
)
}
)
;
let
done
=
listener
.
incoming
(
)
.
map_err
(
|
e
|
println
!
(
"
error
accepting
socket
;
error
=
{
:
?
}
"
e
)
)
.
for_each
(
move
|
socket
|
{
let
(
reader
writer
)
=
socket
.
split
(
)
;
let
lines
=
lines
(
BufReader
:
:
new
(
reader
)
)
;
let
db
=
db
.
clone
(
)
;
let
responses
=
lines
.
map
(
move
|
line
|
{
let
request
=
match
Request
:
:
parse
(
&
line
)
{
Ok
(
req
)
=
>
req
Err
(
e
)
=
>
return
Response
:
:
Error
{
msg
:
e
}
}
;
let
mut
db
=
db
.
map
.
lock
(
)
.
unwrap
(
)
;
match
request
{
Request
:
:
Get
{
key
}
=
>
{
match
db
.
get
(
&
key
)
{
Some
(
value
)
=
>
Response
:
:
Value
{
key
value
:
value
.
clone
(
)
}
None
=
>
Response
:
:
Error
{
msg
:
format
!
(
"
no
key
{
}
"
key
)
}
}
}
Request
:
:
Set
{
key
value
}
=
>
{
let
previous
=
db
.
insert
(
key
.
clone
(
)
value
.
clone
(
)
)
;
Response
:
:
Set
{
key
value
previous
}
}
}
}
)
;
let
writes
=
responses
.
fold
(
writer
|
writer
response
|
{
let
mut
response
=
response
.
serialize
(
)
;
response
.
push
(
'
\
n
'
)
;
write_all
(
writer
response
.
into_bytes
(
)
)
.
map
(
|
(
w
_
)
|
w
)
}
)
;
let
msg
=
writes
.
then
(
move
|
_
|
Ok
(
(
)
)
)
;
tokio
:
:
spawn
(
msg
)
}
)
;
tokio
:
:
run
(
done
)
;
Ok
(
(
)
)
}
impl
Request
{
fn
parse
(
input
:
&
str
)
-
>
Result
<
Request
String
>
{
let
mut
parts
=
input
.
splitn
(
3
"
"
)
;
match
parts
.
next
(
)
{
Some
(
"
GET
"
)
=
>
{
let
key
=
match
parts
.
next
(
)
{
Some
(
key
)
=
>
key
None
=
>
return
Err
(
format
!
(
"
GET
must
be
followed
by
a
key
"
)
)
}
;
if
parts
.
next
(
)
.
is_some
(
)
{
return
Err
(
format
!
(
"
GET
'
s
key
must
not
be
followed
by
anything
"
)
)
}
Ok
(
Request
:
:
Get
{
key
:
key
.
to_string
(
)
}
)
}
Some
(
"
SET
"
)
=
>
{
let
key
=
match
parts
.
next
(
)
{
Some
(
key
)
=
>
key
None
=
>
return
Err
(
format
!
(
"
SET
must
be
followed
by
a
key
"
)
)
}
;
let
value
=
match
parts
.
next
(
)
{
Some
(
value
)
=
>
value
None
=
>
return
Err
(
format
!
(
"
SET
needs
a
value
"
)
)
}
;
Ok
(
Request
:
:
Set
{
key
:
key
.
to_string
(
)
value
:
value
.
to_string
(
)
}
)
}
Some
(
cmd
)
=
>
Err
(
format
!
(
"
unknown
command
:
{
}
"
cmd
)
)
None
=
>
Err
(
format
!
(
"
empty
input
"
)
)
}
}
}
impl
Response
{
fn
serialize
(
&
self
)
-
>
String
{
match
*
self
{
Response
:
:
Value
{
ref
key
ref
value
}
=
>
{
format
!
(
"
{
}
=
{
}
"
key
value
)
}
Response
:
:
Set
{
ref
key
ref
value
ref
previous
}
=
>
{
format
!
(
"
set
{
}
=
{
}
previous
:
{
:
?
}
"
key
value
previous
)
}
Response
:
:
Error
{
ref
msg
}
=
>
{
format
!
(
"
error
:
{
}
"
msg
)
}
}
}
}
