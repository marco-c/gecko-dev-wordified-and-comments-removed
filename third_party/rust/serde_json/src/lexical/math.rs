use
super
:
:
large_powers
;
use
super
:
:
num
:
:
*
;
use
super
:
:
small_powers
:
:
*
;
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
{
cmp
iter
mem
}
;
#
[
cfg
(
limb_width_32
)
]
pub
type
Limb
=
u32
;
#
[
cfg
(
limb_width_32
)
]
pub
const
POW5_LIMB
:
&
[
Limb
]
=
&
POW5_32
;
#
[
cfg
(
limb_width_32
)
]
pub
const
POW10_LIMB
:
&
[
Limb
]
=
&
POW10_32
;
#
[
cfg
(
limb_width_32
)
]
type
Wide
=
u64
;
#
[
cfg
(
limb_width_64
)
]
pub
type
Limb
=
u64
;
#
[
cfg
(
limb_width_64
)
]
pub
const
POW5_LIMB
:
&
[
Limb
]
=
&
POW5_64
;
#
[
cfg
(
limb_width_64
)
]
pub
const
POW10_LIMB
:
&
[
Limb
]
=
&
POW10_64
;
#
[
cfg
(
limb_width_64
)
]
type
Wide
=
u128
;
#
[
inline
]
pub
(
crate
)
fn
as_limb
<
T
:
Integer
>
(
t
:
T
)
-
>
Limb
{
Limb
:
:
as_cast
(
t
)
}
#
[
inline
]
fn
as_wide
<
T
:
Integer
>
(
t
:
T
)
-
>
Wide
{
Wide
:
:
as_cast
(
t
)
}
#
[
inline
]
#
[
cfg
(
limb_width_32
)
]
fn
split_u64
(
x
:
u64
)
-
>
[
Limb
;
2
]
{
[
as_limb
(
x
)
as_limb
(
x
>
>
32
)
]
}
#
[
inline
]
#
[
cfg
(
limb_width_64
)
]
fn
split_u64
(
x
:
u64
)
-
>
[
Limb
;
1
]
{
[
as_limb
(
x
)
]
}
#
[
inline
]
pub
fn
nonzero
<
T
:
Integer
>
(
x
:
&
[
T
]
rindex
:
usize
)
-
>
bool
{
let
len
=
x
.
len
(
)
;
let
slc
=
&
x
[
.
.
len
-
rindex
]
;
slc
.
iter
(
)
.
rev
(
)
.
any
(
|
&
x
|
x
!
=
T
:
:
ZERO
)
}
#
[
inline
]
fn
u64_to_hi64_1
(
r0
:
u64
)
-
>
(
u64
bool
)
{
debug_assert
!
(
r0
!
=
0
)
;
let
ls
=
r0
.
leading_zeros
(
)
;
(
r0
<
<
ls
false
)
}
#
[
inline
]
fn
u64_to_hi64_2
(
r0
:
u64
r1
:
u64
)
-
>
(
u64
bool
)
{
debug_assert
!
(
r0
!
=
0
)
;
let
ls
=
r0
.
leading_zeros
(
)
;
let
rs
=
64
-
ls
;
let
v
=
match
ls
{
0
=
>
r0
_
=
>
(
r0
<
<
ls
)
|
(
r1
>
>
rs
)
}
;
let
n
=
r1
<
<
ls
!
=
0
;
(
v
n
)
}
trait
Hi64
<
T
>
:
AsRef
<
[
T
]
>
{
fn
hi64_1
(
&
self
)
-
>
(
u64
bool
)
;
fn
hi64_2
(
&
self
)
-
>
(
u64
bool
)
;
fn
hi64_3
(
&
self
)
-
>
(
u64
bool
)
;
#
[
inline
]
fn
hi64
(
&
self
)
-
>
(
u64
bool
)
{
match
self
.
as_ref
(
)
.
len
(
)
{
0
=
>
(
0
false
)
1
=
>
self
.
hi64_1
(
)
2
=
>
self
.
hi64_2
(
)
_
=
>
self
.
hi64_3
(
)
}
}
}
impl
Hi64
<
u32
>
for
[
u32
]
{
#
[
inline
]
fn
hi64_1
(
&
self
)
-
>
(
u64
bool
)
{
debug_assert
!
(
self
.
len
(
)
=
=
1
)
;
let
r0
=
self
[
0
]
as
u64
;
u64_to_hi64_1
(
r0
)
}
#
[
inline
]
fn
hi64_2
(
&
self
)
-
>
(
u64
bool
)
{
debug_assert
!
(
self
.
len
(
)
=
=
2
)
;
let
r0
=
(
self
[
1
]
as
u64
)
<
<
32
;
let
r1
=
self
[
0
]
as
u64
;
u64_to_hi64_1
(
r0
|
r1
)
}
#
[
inline
]
fn
hi64_3
(
&
self
)
-
>
(
u64
bool
)
{
debug_assert
!
(
self
.
len
(
)
>
=
3
)
;
let
r0
=
self
[
self
.
len
(
)
-
1
]
as
u64
;
let
r1
=
(
self
[
self
.
len
(
)
-
2
]
as
u64
)
<
<
32
;
let
r2
=
self
[
self
.
len
(
)
-
3
]
as
u64
;
let
(
v
n
)
=
u64_to_hi64_2
(
r0
r1
|
r2
)
;
(
v
n
|
|
nonzero
(
self
3
)
)
}
}
impl
Hi64
<
u64
>
for
[
u64
]
{
#
[
inline
]
fn
hi64_1
(
&
self
)
-
>
(
u64
bool
)
{
debug_assert
!
(
self
.
len
(
)
=
=
1
)
;
let
r0
=
self
[
0
]
;
u64_to_hi64_1
(
r0
)
}
#
[
inline
]
fn
hi64_2
(
&
self
)
-
>
(
u64
bool
)
{
debug_assert
!
(
self
.
len
(
)
>
=
2
)
;
let
r0
=
self
[
self
.
len
(
)
-
1
]
;
let
r1
=
self
[
self
.
len
(
)
-
2
]
;
let
(
v
n
)
=
u64_to_hi64_2
(
r0
r1
)
;
(
v
n
|
|
nonzero
(
self
2
)
)
}
#
[
inline
]
fn
hi64_3
(
&
self
)
-
>
(
u64
bool
)
{
self
.
hi64_2
(
)
}
}
mod
scalar
{
use
super
:
:
*
;
#
[
inline
]
pub
fn
add
(
x
:
Limb
y
:
Limb
)
-
>
(
Limb
bool
)
{
x
.
overflowing_add
(
y
)
}
#
[
inline
]
pub
fn
iadd
(
x
:
&
mut
Limb
y
:
Limb
)
-
>
bool
{
let
t
=
add
(
*
x
y
)
;
*
x
=
t
.
0
;
t
.
1
}
#
[
inline
]
pub
fn
sub
(
x
:
Limb
y
:
Limb
)
-
>
(
Limb
bool
)
{
x
.
overflowing_sub
(
y
)
}
#
[
inline
]
pub
fn
isub
(
x
:
&
mut
Limb
y
:
Limb
)
-
>
bool
{
let
t
=
sub
(
*
x
y
)
;
*
x
=
t
.
0
;
t
.
1
}
#
[
inline
]
pub
fn
mul
(
x
:
Limb
y
:
Limb
carry
:
Limb
)
-
>
(
Limb
Limb
)
{
let
z
:
Wide
=
as_wide
(
x
)
*
as_wide
(
y
)
+
as_wide
(
carry
)
;
let
bits
=
mem
:
:
size_of
:
:
<
Limb
>
(
)
*
8
;
(
as_limb
(
z
)
as_limb
(
z
>
>
bits
)
)
}
#
[
inline
]
pub
fn
imul
(
x
:
&
mut
Limb
y
:
Limb
carry
:
Limb
)
-
>
Limb
{
let
t
=
mul
(
*
x
y
carry
)
;
*
x
=
t
.
0
;
t
.
1
}
}
mod
small
{
use
super
:
:
*
;
#
[
inline
]
pub
fn
iadd_impl
(
x
:
&
mut
Vec
<
Limb
>
y
:
Limb
xstart
:
usize
)
{
if
x
.
len
(
)
<
=
xstart
{
x
.
push
(
y
)
;
}
else
{
let
mut
carry
=
scalar
:
:
iadd
(
&
mut
x
[
xstart
]
y
)
;
let
mut
size
=
xstart
+
1
;
while
carry
&
&
size
<
x
.
len
(
)
{
carry
=
scalar
:
:
iadd
(
&
mut
x
[
size
]
1
)
;
size
+
=
1
;
}
if
carry
{
x
.
push
(
1
)
;
}
}
}
#
[
inline
]
pub
fn
iadd
(
x
:
&
mut
Vec
<
Limb
>
y
:
Limb
)
{
iadd_impl
(
x
y
0
)
;
}
#
[
inline
]
pub
fn
isub_impl
(
x
:
&
mut
Vec
<
Limb
>
y
:
Limb
xstart
:
usize
)
{
debug_assert
!
(
x
.
len
(
)
>
xstart
&
&
(
x
[
xstart
]
>
=
y
|
|
x
.
len
(
)
>
xstart
+
1
)
)
;
let
mut
carry
=
scalar
:
:
isub
(
&
mut
x
[
xstart
]
y
)
;
let
mut
size
=
xstart
+
1
;
while
carry
&
&
size
<
x
.
len
(
)
{
carry
=
scalar
:
:
isub
(
&
mut
x
[
size
]
1
)
;
size
+
=
1
;
}
normalize
(
x
)
;
}
#
[
inline
]
pub
fn
imul
(
x
:
&
mut
Vec
<
Limb
>
y
:
Limb
)
{
let
mut
carry
:
Limb
=
0
;
for
xi
in
&
mut
*
x
{
carry
=
scalar
:
:
imul
(
xi
y
carry
)
;
}
if
carry
!
=
0
{
x
.
push
(
carry
)
;
}
}
#
[
inline
]
pub
fn
mul
(
x
:
&
[
Limb
]
y
:
Limb
)
-
>
Vec
<
Limb
>
{
let
mut
z
=
Vec
:
:
<
Limb
>
:
:
default
(
)
;
z
.
extend_from_slice
(
x
)
;
imul
(
&
mut
z
y
)
;
z
}
pub
fn
imul_pow5
(
x
:
&
mut
Vec
<
Limb
>
n
:
u32
)
{
use
super
:
:
large
:
:
KARATSUBA_CUTOFF
;
let
small_powers
=
POW5_LIMB
;
let
large_powers
=
large_powers
:
:
POW5
;
if
n
=
=
0
{
return
;
}
let
bit_length
=
32
-
n
.
leading_zeros
(
)
as
usize
;
debug_assert
!
(
bit_length
!
=
0
&
&
bit_length
<
=
large_powers
.
len
(
)
)
;
if
x
.
len
(
)
+
large_powers
[
bit_length
-
1
]
.
len
(
)
<
2
*
KARATSUBA_CUTOFF
{
let
step
=
small_powers
.
len
(
)
-
1
;
let
power
=
small_powers
[
step
]
;
let
mut
n
=
n
as
usize
;
while
n
>
=
step
{
imul
(
x
power
)
;
n
-
=
step
;
}
imul
(
x
small_powers
[
n
]
)
;
}
else
{
let
mut
idx
:
usize
=
0
;
let
mut
bit
:
usize
=
1
;
let
mut
n
=
n
as
usize
;
while
n
!
=
0
{
if
n
&
bit
!
=
0
{
debug_assert
!
(
idx
<
large_powers
.
len
(
)
)
;
large
:
:
imul
(
x
large_powers
[
idx
]
)
;
n
^
=
bit
;
}
idx
+
=
1
;
bit
<
<
=
1
;
}
}
}
#
[
inline
]
pub
fn
leading_zeros
(
x
:
&
[
Limb
]
)
-
>
usize
{
x
.
last
(
)
.
map_or
(
0
|
x
|
x
.
leading_zeros
(
)
as
usize
)
}
#
[
inline
]
pub
fn
bit_length
(
x
:
&
[
Limb
]
)
-
>
usize
{
let
bits
=
mem
:
:
size_of
:
:
<
Limb
>
(
)
*
8
;
let
nlz
=
leading_zeros
(
x
)
;
bits
.
checked_mul
(
x
.
len
(
)
)
.
map_or_else
(
usize
:
:
max_value
|
v
|
v
-
nlz
)
}
#
[
inline
]
pub
fn
ishl_bits
(
x
:
&
mut
Vec
<
Limb
>
n
:
usize
)
{
let
bits
=
mem
:
:
size_of
:
:
<
Limb
>
(
)
*
8
;
debug_assert
!
(
n
<
bits
)
;
if
n
=
=
0
{
return
;
}
let
rshift
=
bits
-
n
;
let
lshift
=
n
;
let
mut
prev
:
Limb
=
0
;
for
xi
in
&
mut
*
x
{
let
tmp
=
*
xi
;
*
xi
<
<
=
lshift
;
*
xi
|
=
prev
>
>
rshift
;
prev
=
tmp
;
}
let
carry
=
prev
>
>
rshift
;
if
carry
!
=
0
{
x
.
push
(
carry
)
;
}
}
#
[
inline
]
pub
fn
ishl_limbs
(
x
:
&
mut
Vec
<
Limb
>
n
:
usize
)
{
debug_assert
!
(
n
!
=
0
)
;
if
!
x
.
is_empty
(
)
{
x
.
reserve
(
n
)
;
x
.
splice
(
.
.
0
iter
:
:
repeat
(
0
)
.
take
(
n
)
)
;
}
}
#
[
inline
]
pub
fn
ishl
(
x
:
&
mut
Vec
<
Limb
>
n
:
usize
)
{
let
bits
=
mem
:
:
size_of
:
:
<
Limb
>
(
)
*
8
;
let
rem
=
n
%
bits
;
let
div
=
n
/
bits
;
ishl_bits
(
x
rem
)
;
if
div
!
=
0
{
ishl_limbs
(
x
div
)
;
}
}
#
[
inline
]
pub
fn
normalize
(
x
:
&
mut
Vec
<
Limb
>
)
{
while
x
.
last
(
)
=
=
Some
(
&
0
)
{
x
.
pop
(
)
;
}
}
}
mod
large
{
use
super
:
:
*
;
#
[
inline
]
pub
fn
compare
(
x
:
&
[
Limb
]
y
:
&
[
Limb
]
)
-
>
cmp
:
:
Ordering
{
if
x
.
len
(
)
>
y
.
len
(
)
{
cmp
:
:
Ordering
:
:
Greater
}
else
if
x
.
len
(
)
<
y
.
len
(
)
{
cmp
:
:
Ordering
:
:
Less
}
else
{
let
iter
=
x
.
iter
(
)
.
rev
(
)
.
zip
(
y
.
iter
(
)
.
rev
(
)
)
;
for
(
&
xi
&
yi
)
in
iter
{
if
xi
>
yi
{
return
cmp
:
:
Ordering
:
:
Greater
;
}
else
if
xi
<
yi
{
return
cmp
:
:
Ordering
:
:
Less
;
}
}
cmp
:
:
Ordering
:
:
Equal
}
}
#
[
inline
]
pub
fn
less
(
x
:
&
[
Limb
]
y
:
&
[
Limb
]
)
-
>
bool
{
compare
(
x
y
)
=
=
cmp
:
:
Ordering
:
:
Less
}
#
[
inline
]
pub
fn
greater_equal
(
x
:
&
[
Limb
]
y
:
&
[
Limb
]
)
-
>
bool
{
!
less
(
x
y
)
}
pub
fn
iadd_impl
(
x
:
&
mut
Vec
<
Limb
>
y
:
&
[
Limb
]
xstart
:
usize
)
{
if
y
.
len
(
)
>
x
.
len
(
)
-
xstart
{
x
.
resize
(
y
.
len
(
)
+
xstart
0
)
;
}
let
mut
carry
=
false
;
for
(
xi
yi
)
in
x
[
xstart
.
.
]
.
iter_mut
(
)
.
zip
(
y
.
iter
(
)
)
{
let
mut
tmp
=
scalar
:
:
iadd
(
xi
*
yi
)
;
if
carry
{
tmp
|
=
scalar
:
:
iadd
(
xi
1
)
;
}
carry
=
tmp
;
}
if
carry
{
small
:
:
iadd_impl
(
x
1
y
.
len
(
)
+
xstart
)
;
}
}
#
[
inline
]
pub
fn
iadd
(
x
:
&
mut
Vec
<
Limb
>
y
:
&
[
Limb
]
)
{
iadd_impl
(
x
y
0
)
;
}
#
[
inline
]
pub
fn
add
(
x
:
&
[
Limb
]
y
:
&
[
Limb
]
)
-
>
Vec
<
Limb
>
{
let
mut
z
=
Vec
:
:
<
Limb
>
:
:
default
(
)
;
z
.
extend_from_slice
(
x
)
;
iadd
(
&
mut
z
y
)
;
z
}
pub
fn
isub
(
x
:
&
mut
Vec
<
Limb
>
y
:
&
[
Limb
]
)
{
debug_assert
!
(
greater_equal
(
x
y
)
)
;
let
mut
carry
=
false
;
for
(
xi
yi
)
in
x
.
iter_mut
(
)
.
zip
(
y
.
iter
(
)
)
{
let
mut
tmp
=
scalar
:
:
isub
(
xi
*
yi
)
;
if
carry
{
tmp
|
=
scalar
:
:
isub
(
xi
1
)
;
}
carry
=
tmp
;
}
if
carry
{
small
:
:
isub_impl
(
x
1
y
.
len
(
)
)
;
}
else
{
small
:
:
normalize
(
x
)
;
}
}
pub
const
KARATSUBA_CUTOFF
:
usize
=
32
;
fn
long_mul
(
x
:
&
[
Limb
]
y
:
&
[
Limb
]
)
-
>
Vec
<
Limb
>
{
let
mut
z
:
Vec
<
Limb
>
=
small
:
:
mul
(
x
y
[
0
]
)
;
z
.
resize
(
x
.
len
(
)
+
y
.
len
(
)
0
)
;
for
(
i
&
yi
)
in
y
[
1
.
.
]
.
iter
(
)
.
enumerate
(
)
{
let
zi
:
Vec
<
Limb
>
=
small
:
:
mul
(
x
yi
)
;
iadd_impl
(
&
mut
z
&
zi
i
+
1
)
;
}
small
:
:
normalize
(
&
mut
z
)
;
z
}
#
[
inline
]
pub
fn
karatsuba_split
(
z
:
&
[
Limb
]
m
:
usize
)
-
>
(
&
[
Limb
]
&
[
Limb
]
)
{
(
&
z
[
.
.
m
]
&
z
[
m
.
.
]
)
}
fn
karatsuba_mul
(
x
:
&
[
Limb
]
y
:
&
[
Limb
]
)
-
>
Vec
<
Limb
>
{
if
y
.
len
(
)
<
=
KARATSUBA_CUTOFF
{
long_mul
(
x
y
)
}
else
if
x
.
len
(
)
<
y
.
len
(
)
/
2
{
karatsuba_uneven_mul
(
x
y
)
}
else
{
let
m
=
y
.
len
(
)
/
2
;
let
(
xl
xh
)
=
karatsuba_split
(
x
m
)
;
let
(
yl
yh
)
=
karatsuba_split
(
y
m
)
;
let
sumx
=
add
(
xl
xh
)
;
let
sumy
=
add
(
yl
yh
)
;
let
z0
=
karatsuba_mul
(
xl
yl
)
;
let
mut
z1
=
karatsuba_mul
(
&
sumx
&
sumy
)
;
let
z2
=
karatsuba_mul
(
xh
yh
)
;
isub
(
&
mut
z1
&
z2
)
;
isub
(
&
mut
z1
&
z0
)
;
let
len
=
z0
.
len
(
)
.
max
(
m
+
z1
.
len
(
)
)
.
max
(
2
*
m
+
z2
.
len
(
)
)
;
let
mut
result
=
z0
;
result
.
reserve_exact
(
len
-
result
.
len
(
)
)
;
iadd_impl
(
&
mut
result
&
z1
m
)
;
iadd_impl
(
&
mut
result
&
z2
2
*
m
)
;
result
}
}
fn
karatsuba_uneven_mul
(
x
:
&
[
Limb
]
mut
y
:
&
[
Limb
]
)
-
>
Vec
<
Limb
>
{
let
mut
result
=
Vec
:
:
<
Limb
>
:
:
default
(
)
;
result
.
resize
(
x
.
len
(
)
+
y
.
len
(
)
0
)
;
let
mut
start
=
0
;
while
!
y
.
is_empty
(
)
{
let
m
=
x
.
len
(
)
.
min
(
y
.
len
(
)
)
;
let
(
yl
yh
)
=
karatsuba_split
(
y
m
)
;
let
prod
=
karatsuba_mul
(
x
yl
)
;
iadd_impl
(
&
mut
result
&
prod
start
)
;
y
=
yh
;
start
+
=
m
;
}
small
:
:
normalize
(
&
mut
result
)
;
result
}
#
[
inline
]
fn
karatsuba_mul_fwd
(
x
:
&
[
Limb
]
y
:
&
[
Limb
]
)
-
>
Vec
<
Limb
>
{
if
x
.
len
(
)
<
y
.
len
(
)
{
karatsuba_mul
(
x
y
)
}
else
{
karatsuba_mul
(
y
x
)
}
}
#
[
inline
]
pub
fn
imul
(
x
:
&
mut
Vec
<
Limb
>
y
:
&
[
Limb
]
)
{
if
y
.
len
(
)
=
=
1
{
small
:
:
imul
(
x
y
[
0
]
)
;
}
else
{
*
x
=
karatsuba_mul_fwd
(
x
y
)
;
}
}
}
pub
(
crate
)
trait
Math
:
Clone
+
Sized
+
Default
{
fn
data
(
&
self
)
-
>
&
Vec
<
Limb
>
;
fn
data_mut
(
&
mut
self
)
-
>
&
mut
Vec
<
Limb
>
;
#
[
inline
]
fn
compare
(
&
self
y
:
&
Self
)
-
>
cmp
:
:
Ordering
{
large
:
:
compare
(
self
.
data
(
)
y
.
data
(
)
)
}
#
[
inline
]
fn
hi64
(
&
self
)
-
>
(
u64
bool
)
{
self
.
data
(
)
.
as_slice
(
)
.
hi64
(
)
}
#
[
inline
]
fn
bit_length
(
&
self
)
-
>
usize
{
small
:
:
bit_length
(
self
.
data
(
)
)
}
#
[
inline
]
fn
from_u64
(
x
:
u64
)
-
>
Self
{
let
mut
v
=
Self
:
:
default
(
)
;
let
slc
=
split_u64
(
x
)
;
v
.
data_mut
(
)
.
extend_from_slice
(
&
slc
)
;
v
.
normalize
(
)
;
v
}
#
[
inline
]
fn
normalize
(
&
mut
self
)
{
small
:
:
normalize
(
self
.
data_mut
(
)
)
;
}
#
[
inline
]
fn
iadd_small
(
&
mut
self
y
:
Limb
)
{
small
:
:
iadd
(
self
.
data_mut
(
)
y
)
;
}
#
[
inline
]
fn
imul_small
(
&
mut
self
y
:
Limb
)
{
small
:
:
imul
(
self
.
data_mut
(
)
y
)
;
}
#
[
inline
]
fn
imul_pow2
(
&
mut
self
n
:
u32
)
{
self
.
ishl
(
n
as
usize
)
;
}
#
[
inline
]
fn
imul_pow5
(
&
mut
self
n
:
u32
)
{
small
:
:
imul_pow5
(
self
.
data_mut
(
)
n
)
;
}
#
[
inline
]
fn
imul_pow10
(
&
mut
self
n
:
u32
)
{
self
.
imul_pow5
(
n
)
;
self
.
imul_pow2
(
n
)
;
}
#
[
inline
]
fn
ishl
(
&
mut
self
n
:
usize
)
{
small
:
:
ishl
(
self
.
data_mut
(
)
n
)
;
}
}
