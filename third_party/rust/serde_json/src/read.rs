use
std
:
:
{
char
cmp
io
str
}
;
use
serde
:
:
iter
:
:
LineColIterator
;
use
super
:
:
error
:
:
{
Error
ErrorCode
Result
}
;
pub
trait
Read
{
fn
next
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
u8
>
>
;
fn
peek
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
u8
>
>
;
fn
discard
(
&
mut
self
)
;
fn
position
(
&
self
)
-
>
Position
;
fn
peek_position
(
&
self
)
-
>
Position
;
fn
parse_str
<
'
s
>
(
&
'
s
mut
self
scratch
:
&
'
s
mut
Vec
<
u8
>
)
-
>
Result
<
&
'
s
str
>
;
}
pub
struct
Position
{
pub
line
:
usize
pub
column
:
usize
}
pub
struct
IteratorRead
<
Iter
>
where
Iter
:
Iterator
<
Item
=
io
:
:
Result
<
u8
>
>
{
iter
:
LineColIterator
<
Iter
>
ch
:
Option
<
u8
>
}
pub
struct
SliceRead
<
'
a
>
{
slice
:
&
'
a
[
u8
]
index
:
usize
}
pub
struct
StrRead
<
'
a
>
{
delegate
:
SliceRead
<
'
a
>
}
impl
<
Iter
>
IteratorRead
<
Iter
>
where
Iter
:
Iterator
<
Item
=
io
:
:
Result
<
u8
>
>
{
pub
fn
new
(
iter
:
Iter
)
-
>
Self
{
IteratorRead
{
iter
:
LineColIterator
:
:
new
(
iter
)
ch
:
None
}
}
}
impl
<
Iter
>
Read
for
IteratorRead
<
Iter
>
where
Iter
:
Iterator
<
Item
=
io
:
:
Result
<
u8
>
>
{
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
u8
>
>
{
match
self
.
ch
.
take
(
)
{
Some
(
ch
)
=
>
Ok
(
Some
(
ch
)
)
None
=
>
{
match
self
.
iter
.
next
(
)
{
Some
(
Err
(
err
)
)
=
>
Err
(
err
)
Some
(
Ok
(
ch
)
)
=
>
Ok
(
Some
(
ch
)
)
None
=
>
Ok
(
None
)
}
}
}
}
#
[
inline
]
fn
peek
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
u8
>
>
{
match
self
.
ch
{
Some
(
ch
)
=
>
Ok
(
Some
(
ch
)
)
None
=
>
{
match
self
.
iter
.
next
(
)
{
Some
(
Err
(
err
)
)
=
>
Err
(
err
)
Some
(
Ok
(
ch
)
)
=
>
{
self
.
ch
=
Some
(
ch
)
;
Ok
(
self
.
ch
)
}
None
=
>
Ok
(
None
)
}
}
}
}
#
[
inline
]
fn
discard
(
&
mut
self
)
{
self
.
ch
=
None
;
}
fn
position
(
&
self
)
-
>
Position
{
Position
{
line
:
self
.
iter
.
line
(
)
column
:
self
.
iter
.
col
(
)
}
}
fn
peek_position
(
&
self
)
-
>
Position
{
self
.
position
(
)
}
fn
parse_str
<
'
s
>
(
&
'
s
mut
self
scratch
:
&
'
s
mut
Vec
<
u8
>
)
-
>
Result
<
&
'
s
str
>
{
loop
{
let
ch
=
match
try
!
(
self
.
next
(
)
)
{
Some
(
ch
)
=
>
ch
None
=
>
{
return
error
(
self
ErrorCode
:
:
EOFWhileParsingString
)
;
}
}
;
if
!
ESCAPE
[
ch
as
usize
]
{
scratch
.
push
(
ch
)
;
continue
;
}
match
ch
{
b
'
"
'
=
>
{
return
as_str
(
self
scratch
)
;
}
b
'
\
\
'
=
>
{
try
!
(
parse_escape
(
self
scratch
)
)
;
}
_
=
>
{
return
error
(
self
ErrorCode
:
:
InvalidUnicodeCodePoint
)
;
}
}
}
}
}
impl
<
'
a
>
SliceRead
<
'
a
>
{
pub
fn
new
(
slice
:
&
'
a
[
u8
]
)
-
>
Self
{
SliceRead
{
slice
:
slice
index
:
0
}
}
fn
position_of_index
(
&
self
i
:
usize
)
-
>
Position
{
let
mut
pos
=
Position
{
line
:
1
column
:
0
}
;
for
ch
in
&
self
.
slice
[
.
.
i
]
{
match
*
ch
{
b
'
\
n
'
=
>
{
pos
.
line
+
=
1
;
pos
.
column
=
0
;
}
_
=
>
{
pos
.
column
+
=
1
;
}
}
}
pos
}
fn
parse_str_bytes
<
'
s
T
F
>
(
&
'
s
mut
self
scratch
:
&
'
s
mut
Vec
<
u8
>
result
:
F
)
-
>
Result
<
T
>
where
T
:
'
s
F
:
FnOnce
(
&
'
s
Self
&
'
s
[
u8
]
)
-
>
Result
<
T
>
{
let
mut
start
=
self
.
index
;
loop
{
while
self
.
index
<
self
.
slice
.
len
(
)
&
&
!
ESCAPE
[
self
.
slice
[
self
.
index
]
as
usize
]
{
self
.
index
+
=
1
;
}
if
self
.
index
=
=
self
.
slice
.
len
(
)
{
return
error
(
self
ErrorCode
:
:
EOFWhileParsingString
)
;
}
match
self
.
slice
[
self
.
index
]
{
b
'
"
'
=
>
{
let
string
=
if
scratch
.
is_empty
(
)
{
&
self
.
slice
[
start
.
.
self
.
index
]
}
else
{
scratch
.
extend_from_slice
(
&
self
.
slice
[
start
.
.
self
.
index
]
)
;
scratch
as
&
[
u8
]
}
;
self
.
index
+
=
1
;
return
result
(
self
string
)
;
}
b
'
\
\
'
=
>
{
scratch
.
extend_from_slice
(
&
self
.
slice
[
start
.
.
self
.
index
]
)
;
self
.
index
+
=
1
;
try
!
(
parse_escape
(
self
scratch
)
)
;
start
=
self
.
index
;
}
_
=
>
{
return
error
(
self
ErrorCode
:
:
InvalidUnicodeCodePoint
)
;
}
}
}
}
}
impl
<
'
a
>
Read
for
SliceRead
<
'
a
>
{
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
u8
>
>
{
Ok
(
if
self
.
index
<
self
.
slice
.
len
(
)
{
let
ch
=
self
.
slice
[
self
.
index
]
;
self
.
index
+
=
1
;
Some
(
ch
)
}
else
{
None
}
)
}
#
[
inline
]
fn
peek
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
u8
>
>
{
Ok
(
if
self
.
index
<
self
.
slice
.
len
(
)
{
Some
(
self
.
slice
[
self
.
index
]
)
}
else
{
None
}
)
}
#
[
inline
]
fn
discard
(
&
mut
self
)
{
self
.
index
+
=
1
;
}
fn
position
(
&
self
)
-
>
Position
{
self
.
position_of_index
(
self
.
index
)
}
fn
peek_position
(
&
self
)
-
>
Position
{
self
.
position_of_index
(
cmp
:
:
min
(
self
.
slice
.
len
(
)
self
.
index
+
1
)
)
}
fn
parse_str
<
'
s
>
(
&
'
s
mut
self
scratch
:
&
'
s
mut
Vec
<
u8
>
)
-
>
Result
<
&
'
s
str
>
{
self
.
parse_str_bytes
(
scratch
as_str
)
}
}
impl
<
'
a
>
StrRead
<
'
a
>
{
pub
fn
new
(
s
:
&
'
a
str
)
-
>
Self
{
StrRead
{
delegate
:
SliceRead
:
:
new
(
s
.
as_bytes
(
)
)
}
}
}
impl
<
'
a
>
Read
for
StrRead
<
'
a
>
{
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
u8
>
>
{
self
.
delegate
.
next
(
)
}
#
[
inline
]
fn
peek
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
u8
>
>
{
self
.
delegate
.
peek
(
)
}
#
[
inline
]
fn
discard
(
&
mut
self
)
{
self
.
delegate
.
discard
(
)
;
}
fn
position
(
&
self
)
-
>
Position
{
self
.
delegate
.
position
(
)
}
fn
peek_position
(
&
self
)
-
>
Position
{
self
.
delegate
.
peek_position
(
)
}
fn
parse_str
<
'
s
>
(
&
'
s
mut
self
scratch
:
&
'
s
mut
Vec
<
u8
>
)
-
>
Result
<
&
'
s
str
>
{
self
.
delegate
.
parse_str_bytes
(
scratch
|
_
bytes
|
{
Ok
(
unsafe
{
str
:
:
from_utf8_unchecked
(
bytes
)
}
)
}
)
}
}
const
CT
:
bool
=
true
;
const
QU
:
bool
=
true
;
const
BS
:
bool
=
true
;
const
O
:
bool
=
false
;
#
[
cfg_attr
(
rustfmt
rustfmt_skip
)
]
static
ESCAPE
:
[
bool
;
256
]
=
[
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
CT
O
O
QU
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
BS
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
]
;
fn
error
<
R
:
Read
T
>
(
read
:
&
R
reason
:
ErrorCode
)
-
>
Result
<
T
>
{
let
pos
=
read
.
position
(
)
;
Err
(
Error
:
:
syntax
(
reason
pos
.
line
pos
.
column
)
)
}
fn
as_str
<
'
s
R
:
Read
>
(
read
:
&
R
slice
:
&
'
s
[
u8
]
)
-
>
Result
<
&
'
s
str
>
{
str
:
:
from_utf8
(
slice
)
.
or_else
(
|
_
|
error
(
read
ErrorCode
:
:
InvalidUnicodeCodePoint
)
)
}
fn
parse_escape
<
R
:
Read
>
(
read
:
&
mut
R
scratch
:
&
mut
Vec
<
u8
>
)
-
>
Result
<
(
)
>
{
let
ch
=
match
try
!
(
read
.
next
(
)
)
{
Some
(
ch
)
=
>
ch
None
=
>
{
return
error
(
read
ErrorCode
:
:
EOFWhileParsingString
)
;
}
}
;
match
ch
{
b
'
"
'
=
>
scratch
.
push
(
b
'
"
'
)
b
'
\
\
'
=
>
scratch
.
push
(
b
'
\
\
'
)
b
'
/
'
=
>
scratch
.
push
(
b
'
/
'
)
b
'
b
'
=
>
scratch
.
push
(
b
'
\
x08
'
)
b
'
f
'
=
>
scratch
.
push
(
b
'
\
x0c
'
)
b
'
n
'
=
>
scratch
.
push
(
b
'
\
n
'
)
b
'
r
'
=
>
scratch
.
push
(
b
'
\
r
'
)
b
'
t
'
=
>
scratch
.
push
(
b
'
\
t
'
)
b
'
u
'
=
>
{
let
c
=
match
try
!
(
decode_hex_escape
(
read
)
)
{
0xDC00
.
.
.
0xDFFF
=
>
{
return
error
(
read
ErrorCode
:
:
LoneLeadingSurrogateInHexEscape
)
;
}
n1
0xD800
.
.
.
0xDBFF
=
>
{
match
(
try
!
(
read
.
next
(
)
)
try
!
(
read
.
next
(
)
)
)
{
(
Some
(
b
'
\
\
'
)
Some
(
b
'
u
'
)
)
=
>
(
)
_
=
>
{
return
error
(
read
ErrorCode
:
:
UnexpectedEndOfHexEscape
)
;
}
}
let
n2
=
try
!
(
decode_hex_escape
(
read
)
)
;
if
n2
<
0xDC00
|
|
n2
>
0xDFFF
{
return
error
(
read
ErrorCode
:
:
LoneLeadingSurrogateInHexEscape
)
;
}
let
n
=
(
(
(
n1
-
0xD800
)
as
u32
)
<
<
10
|
(
n2
-
0xDC00
)
as
u32
)
+
0x1_0000
;
match
char
:
:
from_u32
(
n
as
u32
)
{
Some
(
c
)
=
>
c
None
=
>
{
return
error
(
read
ErrorCode
:
:
InvalidUnicodeCodePoint
)
;
}
}
}
n
=
>
{
match
char
:
:
from_u32
(
n
as
u32
)
{
Some
(
c
)
=
>
c
None
=
>
{
return
error
(
read
ErrorCode
:
:
InvalidUnicodeCodePoint
)
;
}
}
}
}
;
let
mut
buf
=
String
:
:
new
(
)
;
buf
.
push
(
c
)
;
scratch
.
extend
(
buf
.
bytes
(
)
)
;
}
_
=
>
{
return
error
(
read
ErrorCode
:
:
InvalidEscape
)
;
}
}
Ok
(
(
)
)
}
fn
decode_hex_escape
<
R
:
Read
>
(
read
:
&
mut
R
)
-
>
Result
<
u16
>
{
let
mut
i
=
0
;
let
mut
n
=
0
;
while
i
<
4
&
&
try
!
(
read
.
peek
(
)
)
.
is_some
(
)
{
n
=
match
try
!
(
read
.
next
(
)
)
.
unwrap_or
(
b
'
\
x00
'
)
{
c
b
'
0
'
.
.
.
b
'
9
'
=
>
n
*
16_u16
+
(
(
c
as
u16
)
-
(
b
'
0
'
as
u16
)
)
b
'
a
'
|
b
'
A
'
=
>
n
*
16_u16
+
10_u16
b
'
b
'
|
b
'
B
'
=
>
n
*
16_u16
+
11_u16
b
'
c
'
|
b
'
C
'
=
>
n
*
16_u16
+
12_u16
b
'
d
'
|
b
'
D
'
=
>
n
*
16_u16
+
13_u16
b
'
e
'
|
b
'
E
'
=
>
n
*
16_u16
+
14_u16
b
'
f
'
|
b
'
F
'
=
>
n
*
16_u16
+
15_u16
_
=
>
{
return
error
(
read
ErrorCode
:
:
InvalidEscape
)
;
}
}
;
i
+
=
1
;
}
if
i
!
=
4
{
return
error
(
read
ErrorCode
:
:
InvalidEscape
)
;
}
Ok
(
n
)
}
