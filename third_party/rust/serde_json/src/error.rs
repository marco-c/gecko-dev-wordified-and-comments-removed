use
crate
:
:
io
;
use
alloc
:
:
boxed
:
:
Box
;
use
alloc
:
:
string
:
:
{
String
ToString
}
;
use
core
:
:
fmt
:
:
{
self
Debug
Display
}
;
use
core
:
:
result
;
use
core
:
:
str
:
:
FromStr
;
use
serde
:
:
{
de
ser
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
error
;
pub
struct
Error
{
err
:
Box
<
ErrorImpl
>
}
pub
type
Result
<
T
>
=
result
:
:
Result
<
T
Error
>
;
impl
Error
{
pub
fn
line
(
&
self
)
-
>
usize
{
self
.
err
.
line
}
pub
fn
column
(
&
self
)
-
>
usize
{
self
.
err
.
column
}
pub
fn
classify
(
&
self
)
-
>
Category
{
match
self
.
err
.
code
{
ErrorCode
:
:
Message
(
_
)
=
>
Category
:
:
Data
ErrorCode
:
:
Io
(
_
)
=
>
Category
:
:
Io
ErrorCode
:
:
EofWhileParsingList
|
ErrorCode
:
:
EofWhileParsingObject
|
ErrorCode
:
:
EofWhileParsingString
|
ErrorCode
:
:
EofWhileParsingValue
=
>
Category
:
:
Eof
ErrorCode
:
:
ExpectedColon
|
ErrorCode
:
:
ExpectedListCommaOrEnd
|
ErrorCode
:
:
ExpectedObjectCommaOrEnd
|
ErrorCode
:
:
ExpectedSomeIdent
|
ErrorCode
:
:
ExpectedSomeValue
|
ErrorCode
:
:
InvalidEscape
|
ErrorCode
:
:
InvalidNumber
|
ErrorCode
:
:
NumberOutOfRange
|
ErrorCode
:
:
InvalidUnicodeCodePoint
|
ErrorCode
:
:
ControlCharacterWhileParsingString
|
ErrorCode
:
:
KeyMustBeAString
|
ErrorCode
:
:
LoneLeadingSurrogateInHexEscape
|
ErrorCode
:
:
TrailingComma
|
ErrorCode
:
:
TrailingCharacters
|
ErrorCode
:
:
UnexpectedEndOfHexEscape
|
ErrorCode
:
:
RecursionLimitExceeded
=
>
Category
:
:
Syntax
}
}
pub
fn
is_io
(
&
self
)
-
>
bool
{
self
.
classify
(
)
=
=
Category
:
:
Io
}
pub
fn
is_syntax
(
&
self
)
-
>
bool
{
self
.
classify
(
)
=
=
Category
:
:
Syntax
}
pub
fn
is_data
(
&
self
)
-
>
bool
{
self
.
classify
(
)
=
=
Category
:
:
Data
}
pub
fn
is_eof
(
&
self
)
-
>
bool
{
self
.
classify
(
)
=
=
Category
:
:
Eof
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
enum
Category
{
Io
Syntax
Data
Eof
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
clippy
:
:
fallible_impl_from
)
]
impl
From
<
Error
>
for
io
:
:
Error
{
fn
from
(
j
:
Error
)
-
>
Self
{
if
let
ErrorCode
:
:
Io
(
err
)
=
j
.
err
.
code
{
err
}
else
{
match
j
.
classify
(
)
{
Category
:
:
Io
=
>
unreachable
!
(
)
Category
:
:
Syntax
|
Category
:
:
Data
=
>
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidData
j
)
Category
:
:
Eof
=
>
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
UnexpectedEof
j
)
}
}
}
}
struct
ErrorImpl
{
code
:
ErrorCode
line
:
usize
column
:
usize
}
pub
(
crate
)
enum
ErrorCode
{
Message
(
Box
<
str
>
)
Io
(
io
:
:
Error
)
EofWhileParsingList
EofWhileParsingObject
EofWhileParsingString
EofWhileParsingValue
ExpectedColon
ExpectedListCommaOrEnd
ExpectedObjectCommaOrEnd
ExpectedSomeIdent
ExpectedSomeValue
InvalidEscape
InvalidNumber
NumberOutOfRange
InvalidUnicodeCodePoint
ControlCharacterWhileParsingString
KeyMustBeAString
LoneLeadingSurrogateInHexEscape
TrailingComma
TrailingCharacters
UnexpectedEndOfHexEscape
RecursionLimitExceeded
}
impl
Error
{
#
[
cold
]
pub
(
crate
)
fn
syntax
(
code
:
ErrorCode
line
:
usize
column
:
usize
)
-
>
Self
{
Error
{
err
:
Box
:
:
new
(
ErrorImpl
{
code
line
column
}
)
}
}
#
[
doc
(
hidden
)
]
#
[
cold
]
pub
fn
io
(
error
:
io
:
:
Error
)
-
>
Self
{
Error
{
err
:
Box
:
:
new
(
ErrorImpl
{
code
:
ErrorCode
:
:
Io
(
error
)
line
:
0
column
:
0
}
)
}
}
#
[
cold
]
pub
(
crate
)
fn
fix_position
<
F
>
(
self
f
:
F
)
-
>
Self
where
F
:
FnOnce
(
ErrorCode
)
-
>
Error
{
if
self
.
err
.
line
=
=
0
{
f
(
self
.
err
.
code
)
}
else
{
self
}
}
}
impl
Display
for
ErrorCode
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
ErrorCode
:
:
Message
(
ref
msg
)
=
>
f
.
write_str
(
msg
)
ErrorCode
:
:
Io
(
ref
err
)
=
>
Display
:
:
fmt
(
err
f
)
ErrorCode
:
:
EofWhileParsingList
=
>
f
.
write_str
(
"
EOF
while
parsing
a
list
"
)
ErrorCode
:
:
EofWhileParsingObject
=
>
f
.
write_str
(
"
EOF
while
parsing
an
object
"
)
ErrorCode
:
:
EofWhileParsingString
=
>
f
.
write_str
(
"
EOF
while
parsing
a
string
"
)
ErrorCode
:
:
EofWhileParsingValue
=
>
f
.
write_str
(
"
EOF
while
parsing
a
value
"
)
ErrorCode
:
:
ExpectedColon
=
>
f
.
write_str
(
"
expected
:
"
)
ErrorCode
:
:
ExpectedListCommaOrEnd
=
>
f
.
write_str
(
"
expected
or
]
"
)
ErrorCode
:
:
ExpectedObjectCommaOrEnd
=
>
f
.
write_str
(
"
expected
or
}
"
)
ErrorCode
:
:
ExpectedSomeIdent
=
>
f
.
write_str
(
"
expected
ident
"
)
ErrorCode
:
:
ExpectedSomeValue
=
>
f
.
write_str
(
"
expected
value
"
)
ErrorCode
:
:
InvalidEscape
=
>
f
.
write_str
(
"
invalid
escape
"
)
ErrorCode
:
:
InvalidNumber
=
>
f
.
write_str
(
"
invalid
number
"
)
ErrorCode
:
:
NumberOutOfRange
=
>
f
.
write_str
(
"
number
out
of
range
"
)
ErrorCode
:
:
InvalidUnicodeCodePoint
=
>
f
.
write_str
(
"
invalid
unicode
code
point
"
)
ErrorCode
:
:
ControlCharacterWhileParsingString
=
>
{
f
.
write_str
(
"
control
character
(
\
\
u0000
-
\
\
u001F
)
found
while
parsing
a
string
"
)
}
ErrorCode
:
:
KeyMustBeAString
=
>
f
.
write_str
(
"
key
must
be
a
string
"
)
ErrorCode
:
:
LoneLeadingSurrogateInHexEscape
=
>
{
f
.
write_str
(
"
lone
leading
surrogate
in
hex
escape
"
)
}
ErrorCode
:
:
TrailingComma
=
>
f
.
write_str
(
"
trailing
comma
"
)
ErrorCode
:
:
TrailingCharacters
=
>
f
.
write_str
(
"
trailing
characters
"
)
ErrorCode
:
:
UnexpectedEndOfHexEscape
=
>
f
.
write_str
(
"
unexpected
end
of
hex
escape
"
)
ErrorCode
:
:
RecursionLimitExceeded
=
>
f
.
write_str
(
"
recursion
limit
exceeded
"
)
}
}
}
impl
serde
:
:
de
:
:
StdError
for
Error
{
#
[
cfg
(
feature
=
"
std
"
)
]
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
error
:
:
Error
+
'
static
)
>
{
match
self
.
err
.
code
{
ErrorCode
:
:
Io
(
ref
err
)
=
>
Some
(
err
)
_
=
>
None
}
}
}
impl
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
*
self
.
err
f
)
}
}
impl
Display
for
ErrorImpl
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
self
.
line
=
=
0
{
Display
:
:
fmt
(
&
self
.
code
f
)
}
else
{
write
!
(
f
"
{
}
at
line
{
}
column
{
}
"
self
.
code
self
.
line
self
.
column
)
}
}
}
impl
Debug
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Error
(
{
:
?
}
line
:
{
}
column
:
{
}
)
"
self
.
err
.
code
.
to_string
(
)
self
.
err
.
line
self
.
err
.
column
)
}
}
impl
de
:
:
Error
for
Error
{
#
[
cold
]
fn
custom
<
T
:
Display
>
(
msg
:
T
)
-
>
Error
{
make_error
(
msg
.
to_string
(
)
)
}
#
[
cold
]
fn
invalid_type
(
unexp
:
de
:
:
Unexpected
exp
:
&
dyn
de
:
:
Expected
)
-
>
Self
{
if
let
de
:
:
Unexpected
:
:
Unit
=
unexp
{
Error
:
:
custom
(
format_args
!
(
"
invalid
type
:
null
expected
{
}
"
exp
)
)
}
else
{
Error
:
:
custom
(
format_args
!
(
"
invalid
type
:
{
}
expected
{
}
"
unexp
exp
)
)
}
}
}
impl
ser
:
:
Error
for
Error
{
#
[
cold
]
fn
custom
<
T
:
Display
>
(
msg
:
T
)
-
>
Error
{
make_error
(
msg
.
to_string
(
)
)
}
}
fn
make_error
(
mut
msg
:
String
)
-
>
Error
{
let
(
line
column
)
=
parse_line_col
(
&
mut
msg
)
.
unwrap_or
(
(
0
0
)
)
;
Error
{
err
:
Box
:
:
new
(
ErrorImpl
{
code
:
ErrorCode
:
:
Message
(
msg
.
into_boxed_str
(
)
)
line
column
}
)
}
}
fn
parse_line_col
(
msg
:
&
mut
String
)
-
>
Option
<
(
usize
usize
)
>
{
let
start_of_suffix
=
match
msg
.
rfind
(
"
at
line
"
)
{
Some
(
index
)
=
>
index
None
=
>
return
None
}
;
let
start_of_line
=
start_of_suffix
+
"
at
line
"
.
len
(
)
;
let
mut
end_of_line
=
start_of_line
;
while
starts_with_digit
(
&
msg
[
end_of_line
.
.
]
)
{
end_of_line
+
=
1
;
}
if
!
msg
[
end_of_line
.
.
]
.
starts_with
(
"
column
"
)
{
return
None
;
}
let
start_of_column
=
end_of_line
+
"
column
"
.
len
(
)
;
let
mut
end_of_column
=
start_of_column
;
while
starts_with_digit
(
&
msg
[
end_of_column
.
.
]
)
{
end_of_column
+
=
1
;
}
if
end_of_column
<
msg
.
len
(
)
{
return
None
;
}
let
line
=
match
usize
:
:
from_str
(
&
msg
[
start_of_line
.
.
end_of_line
]
)
{
Ok
(
line
)
=
>
line
Err
(
_
)
=
>
return
None
}
;
let
column
=
match
usize
:
:
from_str
(
&
msg
[
start_of_column
.
.
end_of_column
]
)
{
Ok
(
column
)
=
>
column
Err
(
_
)
=
>
return
None
}
;
msg
.
truncate
(
start_of_suffix
)
;
Some
(
(
line
column
)
)
}
fn
starts_with_digit
(
slice
:
&
str
)
-
>
bool
{
match
slice
.
as_bytes
(
)
.
get
(
0
)
{
None
=
>
false
Some
(
&
byte
)
=
>
byte
>
=
b
'
0
'
&
&
byte
<
=
b
'
9
'
}
}
