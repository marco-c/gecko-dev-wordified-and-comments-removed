use
std
:
:
error
;
use
std
:
:
fmt
:
:
{
self
Debug
Display
}
;
use
std
:
:
io
;
use
std
:
:
result
;
use
serde
:
:
de
;
use
serde
:
:
ser
;
pub
struct
Error
{
err
:
Box
<
ErrorImpl
>
}
pub
type
Result
<
T
>
=
result
:
:
Result
<
T
Error
>
;
impl
Error
{
pub
fn
line
(
&
self
)
-
>
usize
{
self
.
err
.
line
}
pub
fn
column
(
&
self
)
-
>
usize
{
self
.
err
.
column
}
pub
fn
classify
(
&
self
)
-
>
Category
{
match
self
.
err
.
code
{
ErrorCode
:
:
Message
(
_
)
=
>
Category
:
:
Data
ErrorCode
:
:
Io
(
_
)
=
>
Category
:
:
Io
ErrorCode
:
:
EofWhileParsingList
|
ErrorCode
:
:
EofWhileParsingObject
|
ErrorCode
:
:
EofWhileParsingString
|
ErrorCode
:
:
EofWhileParsingValue
=
>
Category
:
:
Eof
ErrorCode
:
:
ExpectedColon
|
ErrorCode
:
:
ExpectedListCommaOrEnd
|
ErrorCode
:
:
ExpectedObjectCommaOrEnd
|
ErrorCode
:
:
ExpectedObjectOrArray
|
ErrorCode
:
:
ExpectedSomeIdent
|
ErrorCode
:
:
ExpectedSomeValue
|
ErrorCode
:
:
ExpectedSomeString
|
ErrorCode
:
:
InvalidEscape
|
ErrorCode
:
:
InvalidNumber
|
ErrorCode
:
:
NumberOutOfRange
|
ErrorCode
:
:
InvalidUnicodeCodePoint
|
ErrorCode
:
:
ControlCharacterWhileParsingString
|
ErrorCode
:
:
KeyMustBeAString
|
ErrorCode
:
:
LoneLeadingSurrogateInHexEscape
|
ErrorCode
:
:
TrailingComma
|
ErrorCode
:
:
TrailingCharacters
|
ErrorCode
:
:
UnexpectedEndOfHexEscape
|
ErrorCode
:
:
RecursionLimitExceeded
=
>
Category
:
:
Syntax
}
}
pub
fn
is_io
(
&
self
)
-
>
bool
{
self
.
classify
(
)
=
=
Category
:
:
Io
}
pub
fn
is_syntax
(
&
self
)
-
>
bool
{
self
.
classify
(
)
=
=
Category
:
:
Syntax
}
pub
fn
is_data
(
&
self
)
-
>
bool
{
self
.
classify
(
)
=
=
Category
:
:
Data
}
pub
fn
is_eof
(
&
self
)
-
>
bool
{
self
.
classify
(
)
=
=
Category
:
:
Eof
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
enum
Category
{
Io
Syntax
Data
Eof
}
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
fallible_impl_from
)
)
]
impl
From
<
Error
>
for
io
:
:
Error
{
fn
from
(
j
:
Error
)
-
>
Self
{
if
let
ErrorCode
:
:
Io
(
err
)
=
j
.
err
.
code
{
err
}
else
{
match
j
.
classify
(
)
{
Category
:
:
Io
=
>
unreachable
!
(
)
Category
:
:
Syntax
|
Category
:
:
Data
=
>
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidData
j
)
Category
:
:
Eof
=
>
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
UnexpectedEof
j
)
}
}
}
}
struct
ErrorImpl
{
code
:
ErrorCode
line
:
usize
column
:
usize
}
#
[
doc
(
hidden
)
]
pub
enum
ErrorCode
{
Message
(
Box
<
str
>
)
Io
(
io
:
:
Error
)
EofWhileParsingList
EofWhileParsingObject
EofWhileParsingString
EofWhileParsingValue
ExpectedColon
ExpectedListCommaOrEnd
ExpectedObjectCommaOrEnd
ExpectedObjectOrArray
ExpectedSomeIdent
ExpectedSomeValue
ExpectedSomeString
InvalidEscape
InvalidNumber
NumberOutOfRange
InvalidUnicodeCodePoint
ControlCharacterWhileParsingString
KeyMustBeAString
LoneLeadingSurrogateInHexEscape
TrailingComma
TrailingCharacters
UnexpectedEndOfHexEscape
RecursionLimitExceeded
}
impl
Error
{
#
[
doc
(
hidden
)
]
#
[
cold
]
pub
fn
syntax
(
code
:
ErrorCode
line
:
usize
column
:
usize
)
-
>
Self
{
Error
{
err
:
Box
:
:
new
(
ErrorImpl
{
code
:
code
line
:
line
column
:
column
}
)
}
}
#
[
doc
(
hidden
)
]
#
[
cold
]
pub
fn
io
(
error
:
io
:
:
Error
)
-
>
Self
{
Error
{
err
:
Box
:
:
new
(
ErrorImpl
{
code
:
ErrorCode
:
:
Io
(
error
)
line
:
0
column
:
0
}
)
}
}
#
[
doc
(
hidden
)
]
#
[
cold
]
pub
fn
fix_position
<
F
>
(
self
f
:
F
)
-
>
Self
where
F
:
FnOnce
(
ErrorCode
)
-
>
Error
{
if
self
.
err
.
line
=
=
0
{
f
(
self
.
err
.
code
)
}
else
{
self
}
}
}
impl
Display
for
ErrorCode
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
ErrorCode
:
:
Message
(
ref
msg
)
=
>
f
.
write_str
(
msg
)
ErrorCode
:
:
Io
(
ref
err
)
=
>
Display
:
:
fmt
(
err
f
)
ErrorCode
:
:
EofWhileParsingList
=
>
f
.
write_str
(
"
EOF
while
parsing
a
list
"
)
ErrorCode
:
:
EofWhileParsingObject
=
>
f
.
write_str
(
"
EOF
while
parsing
an
object
"
)
ErrorCode
:
:
EofWhileParsingString
=
>
f
.
write_str
(
"
EOF
while
parsing
a
string
"
)
ErrorCode
:
:
EofWhileParsingValue
=
>
f
.
write_str
(
"
EOF
while
parsing
a
value
"
)
ErrorCode
:
:
ExpectedColon
=
>
f
.
write_str
(
"
expected
:
"
)
ErrorCode
:
:
ExpectedListCommaOrEnd
=
>
f
.
write_str
(
"
expected
or
]
"
)
ErrorCode
:
:
ExpectedObjectCommaOrEnd
=
>
f
.
write_str
(
"
expected
or
}
"
)
ErrorCode
:
:
ExpectedObjectOrArray
=
>
f
.
write_str
(
"
expected
{
or
[
"
)
ErrorCode
:
:
ExpectedSomeIdent
=
>
f
.
write_str
(
"
expected
ident
"
)
ErrorCode
:
:
ExpectedSomeValue
=
>
f
.
write_str
(
"
expected
value
"
)
ErrorCode
:
:
ExpectedSomeString
=
>
f
.
write_str
(
"
expected
string
"
)
ErrorCode
:
:
InvalidEscape
=
>
f
.
write_str
(
"
invalid
escape
"
)
ErrorCode
:
:
InvalidNumber
=
>
f
.
write_str
(
"
invalid
number
"
)
ErrorCode
:
:
NumberOutOfRange
=
>
f
.
write_str
(
"
number
out
of
range
"
)
ErrorCode
:
:
InvalidUnicodeCodePoint
=
>
f
.
write_str
(
"
invalid
unicode
code
point
"
)
ErrorCode
:
:
ControlCharacterWhileParsingString
=
>
{
f
.
write_str
(
"
control
character
(
\
\
u0000
-
\
\
u001F
)
found
while
parsing
a
string
"
)
}
ErrorCode
:
:
KeyMustBeAString
=
>
f
.
write_str
(
"
key
must
be
a
string
"
)
ErrorCode
:
:
LoneLeadingSurrogateInHexEscape
=
>
{
f
.
write_str
(
"
lone
leading
surrogate
in
hex
escape
"
)
}
ErrorCode
:
:
TrailingComma
=
>
f
.
write_str
(
"
trailing
comma
"
)
ErrorCode
:
:
TrailingCharacters
=
>
f
.
write_str
(
"
trailing
characters
"
)
ErrorCode
:
:
UnexpectedEndOfHexEscape
=
>
f
.
write_str
(
"
unexpected
end
of
hex
escape
"
)
ErrorCode
:
:
RecursionLimitExceeded
=
>
f
.
write_str
(
"
recursion
limit
exceeded
"
)
}
}
}
impl
error
:
:
Error
for
Error
{
fn
description
(
&
self
)
-
>
&
str
{
match
self
.
err
.
code
{
ErrorCode
:
:
Io
(
ref
err
)
=
>
error
:
:
Error
:
:
description
(
err
)
_
=
>
{
"
JSON
error
"
}
}
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
match
self
.
err
.
code
{
ErrorCode
:
:
Io
(
ref
err
)
=
>
Some
(
err
)
_
=
>
None
}
}
}
impl
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
*
self
.
err
f
)
}
}
impl
Display
for
ErrorImpl
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
self
.
line
=
=
0
{
Display
:
:
fmt
(
&
self
.
code
f
)
}
else
{
write
!
(
f
"
{
}
at
line
{
}
column
{
}
"
self
.
code
self
.
line
self
.
column
)
}
}
}
impl
Debug
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Error
(
{
:
?
}
line
:
{
}
column
:
{
}
)
"
self
.
err
.
code
.
to_string
(
)
self
.
err
.
line
self
.
err
.
column
)
}
}
impl
de
:
:
Error
for
Error
{
#
[
cold
]
fn
custom
<
T
:
Display
>
(
msg
:
T
)
-
>
Error
{
Error
{
err
:
Box
:
:
new
(
ErrorImpl
{
code
:
ErrorCode
:
:
Message
(
msg
.
to_string
(
)
.
into_boxed_str
(
)
)
line
:
0
column
:
0
}
)
}
}
#
[
cold
]
fn
invalid_type
(
unexp
:
de
:
:
Unexpected
exp
:
&
de
:
:
Expected
)
-
>
Self
{
if
let
de
:
:
Unexpected
:
:
Unit
=
unexp
{
Error
:
:
custom
(
format_args
!
(
"
invalid
type
:
null
expected
{
}
"
exp
)
)
}
else
{
Error
:
:
custom
(
format_args
!
(
"
invalid
type
:
{
}
expected
{
}
"
unexp
exp
)
)
}
}
}
impl
ser
:
:
Error
for
Error
{
#
[
cold
]
fn
custom
<
T
:
Display
>
(
msg
:
T
)
-
>
Error
{
Error
{
err
:
Box
:
:
new
(
ErrorImpl
{
code
:
ErrorCode
:
:
Message
(
msg
.
to_string
(
)
.
into_boxed_str
(
)
)
line
:
0
column
:
0
}
)
}
}
}
