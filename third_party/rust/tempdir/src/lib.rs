#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
-
v2
.
png
"
html_favicon_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
doc
.
rust
-
lang
.
org
/
tempdir
/
"
)
]
#
!
[
cfg_attr
(
test
deny
(
warnings
)
)
]
extern
crate
rand
;
use
std
:
:
env
;
use
std
:
:
io
:
:
{
self
Error
ErrorKind
}
;
use
std
:
:
fmt
;
use
std
:
:
fs
;
use
std
:
:
path
:
:
{
self
PathBuf
Path
}
;
use
rand
:
:
{
thread_rng
Rng
}
;
pub
struct
TempDir
{
path
:
Option
<
PathBuf
>
}
const
NUM_RETRIES
:
u32
=
1
<
<
31
;
const
NUM_RAND_CHARS
:
usize
=
12
;
impl
TempDir
{
pub
fn
new
(
prefix
:
&
str
)
-
>
io
:
:
Result
<
TempDir
>
{
TempDir
:
:
new_in
(
&
env
:
:
temp_dir
(
)
prefix
)
}
pub
fn
new_in
<
P
:
AsRef
<
Path
>
>
(
tmpdir
:
P
prefix
:
&
str
)
-
>
io
:
:
Result
<
TempDir
>
{
let
storage
;
let
mut
tmpdir
=
tmpdir
.
as_ref
(
)
;
if
!
tmpdir
.
is_absolute
(
)
{
let
cur_dir
=
try
!
(
env
:
:
current_dir
(
)
)
;
storage
=
cur_dir
.
join
(
tmpdir
)
;
tmpdir
=
&
storage
;
}
let
mut
rng
=
thread_rng
(
)
;
for
_
in
0
.
.
NUM_RETRIES
{
let
suffix
:
String
=
rng
.
gen_ascii_chars
(
)
.
take
(
NUM_RAND_CHARS
)
.
collect
(
)
;
let
leaf
=
if
prefix
.
len
(
)
>
0
{
format
!
(
"
{
}
.
{
}
"
prefix
suffix
)
}
else
{
suffix
}
;
let
path
=
tmpdir
.
join
(
&
leaf
)
;
match
fs
:
:
create_dir
(
&
path
)
{
Ok
(
_
)
=
>
return
Ok
(
TempDir
{
path
:
Some
(
path
)
}
)
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
ErrorKind
:
:
AlreadyExists
=
>
{
}
Err
(
e
)
=
>
return
Err
(
e
)
}
}
Err
(
Error
:
:
new
(
ErrorKind
:
:
AlreadyExists
"
too
many
temporary
directories
already
exist
"
)
)
}
pub
fn
path
(
&
self
)
-
>
&
path
:
:
Path
{
self
.
path
.
as_ref
(
)
.
unwrap
(
)
}
pub
fn
into_path
(
mut
self
)
-
>
PathBuf
{
self
.
path
.
take
(
)
.
unwrap
(
)
}
pub
fn
close
(
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
cleanup_dir
(
)
}
fn
cleanup_dir
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
match
self
.
path
{
Some
(
ref
p
)
=
>
fs
:
:
remove_dir_all
(
p
)
None
=
>
Ok
(
(
)
)
}
}
}
impl
AsRef
<
Path
>
for
TempDir
{
fn
as_ref
(
&
self
)
-
>
&
Path
{
self
.
path
(
)
}
}
impl
fmt
:
:
Debug
for
TempDir
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
TempDir
"
)
.
field
(
"
path
"
&
self
.
path
(
)
)
.
finish
(
)
}
}
impl
Drop
for
TempDir
{
fn
drop
(
&
mut
self
)
{
let
_
=
self
.
cleanup_dir
(
)
;
}
}
