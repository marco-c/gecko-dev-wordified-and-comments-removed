#
!
[
crate_name
=
"
cssparser
"
]
#
!
[
crate_type
=
"
rlib
"
]
#
!
[
cfg_attr
(
feature
=
"
bench
"
feature
(
test
)
)
]
#
!
[
deny
(
missing_docs
)
]
#
!
[
recursion_limit
=
"
200
"
]
#
[
macro_use
]
extern
crate
matches
;
#
[
cfg
(
test
)
]
extern
crate
encoding_rs
;
#
[
cfg
(
test
)
]
extern
crate
tempdir
;
#
[
cfg
(
test
)
]
extern
crate
rustc_serialize
;
#
[
cfg
(
feature
=
"
serde
"
)
]
extern
crate
serde
;
#
[
cfg
(
feature
=
"
heapsize
"
)
]
#
[
macro_use
]
extern
crate
heapsize
;
pub
use
tokenizer
:
:
{
Token
NumericValue
PercentageValue
SourceLocation
}
;
pub
use
rules_and_declarations
:
:
{
parse_important
}
;
pub
use
rules_and_declarations
:
:
{
DeclarationParser
DeclarationListParser
parse_one_declaration
}
;
pub
use
rules_and_declarations
:
:
{
RuleListParser
parse_one_rule
}
;
pub
use
rules_and_declarations
:
:
{
AtRuleType
QualifiedRuleParser
AtRuleParser
}
;
pub
use
from_bytes
:
:
{
stylesheet_encoding
EncodingSupport
}
;
pub
use
color
:
:
{
RGBA
Color
parse_color_keyword
}
;
pub
use
nth
:
:
parse_nth
;
pub
use
serializer
:
:
{
ToCss
CssStringWriter
serialize_identifier
serialize_string
TokenSerializationType
}
;
pub
use
parser
:
:
{
Parser
Delimiter
Delimiters
SourcePosition
}
;
pub
use
unicode_range
:
:
UnicodeRange
;
#
[
macro_export
]
macro_rules
!
match_ignore_ascii_case
{
(
inner
value
:
expr
(
string
:
expr
=
>
result
:
expr
_
=
>
fallback
:
expr
)
-
>
(
(
parsed
:
tt
)
*
)
)
=
>
{
match_ignore_ascii_case
!
(
inner
value
(
)
-
>
(
(
parsed
)
*
(
string
=
>
result
)
)
fallback
)
}
;
(
inner
value
:
expr
(
string
:
expr
=
>
result
:
expr
(
rest
:
tt
)
*
)
-
>
(
(
parsed
:
tt
)
*
)
)
=
>
{
match_ignore_ascii_case
!
(
inner
value
(
(
rest
)
*
)
-
>
(
(
parsed
)
*
(
string
=
>
result
)
)
)
}
;
(
inner
value
:
expr
(
)
-
>
(
(
(
string
:
expr
=
>
result
:
expr
)
)
*
)
fallback
:
expr
)
=
>
{
{
use
std
:
:
ascii
:
:
AsciiExt
;
match
&
value
[
.
.
]
{
(
s
if
s
.
eq_ignore_ascii_case
(
string
)
=
>
result
)
+
_
=
>
fallback
}
}
}
;
(
value
:
expr
(
rest
:
tt
)
*
)
=
>
{
match_ignore_ascii_case
!
(
inner
value
(
(
rest
)
*
)
-
>
(
)
)
}
;
}
mod
rules_and_declarations
;
#
[
cfg
(
feature
=
"
dummy_match_byte
"
)
]
macro_rules
!
match_byte
{
(
value
:
expr
(
rest
:
tt
)
*
)
=
>
{
match
value
{
(
rest
)
+
}
}
;
}
#
[
cfg
(
feature
=
"
dummy_match_byte
"
)
]
mod
tokenizer
;
#
[
cfg
(
not
(
feature
=
"
dummy_match_byte
"
)
)
]
mod
tokenizer
{
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
tokenizer
.
rs
"
)
)
;
}
mod
parser
;
mod
from_bytes
;
mod
color
;
mod
nth
;
mod
serializer
;
mod
unicode_range
;
#
[
cfg
(
test
)
]
mod
tests
;
