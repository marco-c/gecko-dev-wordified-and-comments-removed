#
!
[
crate_name
=
"
cssparser
"
]
#
!
[
crate_type
=
"
rlib
"
]
#
!
[
cfg_attr
(
feature
=
"
bench
"
feature
(
test
)
)
]
#
!
[
deny
(
missing_docs
)
]
#
!
[
recursion_limit
=
"
200
"
]
#
[
macro_use
]
extern
crate
cssparser_macros
;
#
[
macro_use
]
extern
crate
matches
;
extern
crate
phf
;
#
[
cfg
(
test
)
]
extern
crate
encoding_rs
;
#
[
cfg
(
test
)
]
extern
crate
tempdir
;
#
[
cfg
(
test
)
]
extern
crate
rustc_serialize
;
#
[
cfg
(
feature
=
"
serde
"
)
]
extern
crate
serde
;
#
[
cfg
(
feature
=
"
heapsize
"
)
]
#
[
macro_use
]
extern
crate
heapsize
;
pub
use
tokenizer
:
:
{
Token
NumericValue
PercentageValue
SourceLocation
}
;
pub
use
rules_and_declarations
:
:
{
parse_important
}
;
pub
use
rules_and_declarations
:
:
{
DeclarationParser
DeclarationListParser
parse_one_declaration
}
;
pub
use
rules_and_declarations
:
:
{
RuleListParser
parse_one_rule
}
;
pub
use
rules_and_declarations
:
:
{
AtRuleType
QualifiedRuleParser
AtRuleParser
}
;
pub
use
from_bytes
:
:
{
stylesheet_encoding
EncodingSupport
}
;
pub
use
color
:
:
{
RGBA
Color
parse_color_keyword
}
;
pub
use
nth
:
:
parse_nth
;
pub
use
serializer
:
:
{
ToCss
CssStringWriter
serialize_identifier
serialize_string
TokenSerializationType
}
;
pub
use
parser
:
:
{
Parser
Delimiter
Delimiters
SourcePosition
}
;
pub
use
unicode_range
:
:
UnicodeRange
;
#
[
macro_export
]
macro_rules
!
match_ignore_ascii_case
{
(
inner
value
:
expr
(
string
:
expr
=
>
result
:
expr
_
=
>
fallback
:
expr
)
-
>
(
(
parsed
:
tt
)
*
)
)
=
>
{
match_ignore_ascii_case
!
(
inner
value
(
)
-
>
(
(
parsed
)
*
(
string
=
>
result
)
)
fallback
)
}
;
(
inner
value
:
expr
(
string
:
expr
=
>
result
:
expr
(
rest
:
tt
)
*
)
-
>
(
(
parsed
:
tt
)
*
)
)
=
>
{
match_ignore_ascii_case
!
(
inner
value
(
(
rest
)
*
)
-
>
(
(
parsed
)
*
(
string
=
>
result
)
)
)
}
;
(
inner
value
:
expr
(
)
-
>
(
(
(
string
:
expr
=
>
result
:
expr
)
)
*
)
fallback
:
expr
)
=
>
{
{
#
[
derive
(
cssparser__assert_ascii_lowercase
)
]
#
[
cssparser__assert_ascii_lowercase__data
(
(
string
=
string
)
+
)
]
#
[
allow
(
dead_code
)
]
struct
Dummy
;
_cssparser_internal__to_lowercase
!
(
value
=
>
lowercase
(
string
)
+
)
;
match
lowercase
{
(
Some
(
string
)
=
>
result
)
+
_
=
>
fallback
}
}
}
;
(
value
:
expr
(
rest
:
tt
)
*
)
=
>
{
match_ignore_ascii_case
!
(
inner
value
(
(
rest
)
*
)
-
>
(
)
)
}
;
}
#
[
macro_export
]
macro_rules
!
ascii_case_insensitive_phf_map
{
(
Name
:
ident
:
Map
<
ValueType
:
ty
>
=
{
(
key
:
expr
=
>
value
:
expr
)
*
}
)
=
>
{
#
[
derive
(
cssparser__phf_map
)
]
#
[
cssparser__phf_map__kv_pairs
(
(
key
=
key
value
=
value
)
+
)
]
struct
Name
(
ValueType
)
;
impl
Name
{
#
[
inline
]
fn
get
(
input
:
&
str
)
-
>
Option
<
&
'
static
ValueType
>
{
_cssparser_internal__to_lowercase
!
(
input
=
>
lowercase
(
key
)
+
)
;
lowercase
.
and_then
(
|
string
|
Name
:
:
map
(
)
.
get
(
string
)
)
}
}
}
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
_cssparser_internal__to_lowercase
{
(
input
:
expr
=
>
output
:
ident
(
string
:
expr
)
+
)
=
>
{
#
[
derive
(
cssparser__max_len
)
]
#
[
cssparser__max_len__data
(
(
string
=
string
)
+
)
]
#
[
allow
(
dead_code
)
]
struct
Dummy2
;
/
/
mem
:
:
uninitialized
(
)
is
ok
because
buffer
is
only
used
in
_internal__to_lowercase
/
/
which
initializes
with
copy_from_slice
the
part
of
the
buffer
it
uses
/
/
before
it
uses
it
.
#
[
allow
(
unsafe_code
)
]
/
/
MAX_LENGTH
is
generated
by
cssparser__max_len
let
mut
buffer
:
[
u8
;
MAX_LENGTH
]
=
unsafe
{
:
:
std
:
:
mem
:
:
uninitialized
(
)
}
;
let
input
:
&
str
=
input
;
let
output
=
crate
:
:
_internal__to_lowercase
(
&
mut
buffer
input
)
;
}
}
#
[
doc
(
hidden
)
]
#
[
allow
(
non_snake_case
)
]
pub
fn
_internal__to_lowercase
<
'
a
>
(
buffer
:
&
'
a
mut
[
u8
]
input
:
&
'
a
str
)
-
>
Option
<
&
'
a
str
>
{
if
let
Some
(
buffer
)
=
buffer
.
get_mut
(
.
.
input
.
len
(
)
)
{
if
let
Some
(
first_uppercase
)
=
input
.
bytes
(
)
.
position
(
|
byte
|
matches
!
(
byte
b
'
A
'
.
.
.
b
'
Z
'
)
)
{
buffer
.
copy_from_slice
(
input
.
as_bytes
(
)
)
;
std
:
:
ascii
:
:
AsciiExt
:
:
make_ascii_lowercase
(
&
mut
buffer
[
first_uppercase
.
.
]
)
;
unsafe
{
Some
(
:
:
std
:
:
str
:
:
from_utf8_unchecked
(
buffer
)
)
}
}
else
{
Some
(
input
)
}
}
else
{
None
}
}
mod
rules_and_declarations
;
#
[
cfg
(
feature
=
"
dummy_match_byte
"
)
]
macro_rules
!
match_byte
{
(
value
:
expr
(
rest
:
tt
)
*
)
=
>
{
match
value
{
(
rest
)
+
}
}
;
}
#
[
cfg
(
feature
=
"
dummy_match_byte
"
)
]
mod
tokenizer
;
#
[
cfg
(
not
(
feature
=
"
dummy_match_byte
"
)
)
]
mod
tokenizer
{
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
tokenizer
.
rs
"
)
)
;
}
mod
parser
;
mod
from_bytes
;
mod
color
;
mod
nth
;
mod
serializer
;
mod
unicode_range
;
#
[
cfg
(
test
)
]
mod
tests
;
