use
std
:
:
mem
:
:
MaybeUninit
;
#
[
macro_export
]
macro_rules
!
match_ignore_ascii_case
{
(
input
:
expr
(
(
#
[
meta
:
meta
]
)
*
(
pattern
:
pat
)
|
+
(
if
guard
:
expr
)
?
=
>
then
:
expr
)
+
(
)
?
)
=
>
{
{
/
/
This
dummy
module
works
around
the
feature
gate
/
/
error
[
E0658
]
:
procedural
macros
cannot
be
expanded
to
statements
/
/
by
forcing
the
macro
to
be
in
an
item
context
/
/
rather
than
expression
/
statement
context
/
/
even
though
the
macro
only
expands
to
items
.
mod
cssparser_internal
{
crate
:
:
_cssparser_internal_max_len
!
{
(
(
pattern
)
+
)
+
}
}
crate
:
:
_cssparser_internal_to_lowercase
!
(
input
cssparser_internal
:
:
MAX_LENGTH
=
>
lowercase
)
;
/
/
"
A
"
is
a
short
string
that
we
know
is
different
for
every
string
pattern
/
/
since
we
ve
verified
that
none
of
them
include
ASCII
upper
case
letters
.
match
lowercase
.
unwrap_or
(
"
A
"
)
{
(
(
#
[
meta
]
)
*
(
pattern
)
|
+
(
if
guard
)
?
=
>
then
)
+
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
ascii_case_insensitive_phf_map
{
(
name
:
ident
-
>
ValueType
:
ty
=
{
(
key
:
tt
=
>
value
:
expr
)
+
}
)
=
>
{
ascii_case_insensitive_phf_map
!
(
name
-
>
ValueType
=
{
(
key
=
>
value
)
+
}
)
}
;
(
name
:
ident
-
>
ValueType
:
ty
=
{
(
key
:
tt
=
>
value
:
expr
)
+
}
)
=
>
{
pub
fn
name
(
input
:
&
str
)
-
>
Option
<
&
'
static
ValueType
>
{
/
/
This
dummy
module
works
around
a
feature
gate
/
/
see
comment
on
the
similar
module
in
match_ignore_ascii_case
!
above
.
mod
_cssparser_internal
{
crate
:
:
_cssparser_internal_max_len
!
{
(
key
)
+
}
}
use
crate
:
:
_cssparser_internal_phf
as
phf
;
static
MAP
:
phf
:
:
Map
<
&
'
static
str
ValueType
>
=
phf
:
:
phf_map
!
{
(
key
=
>
value
)
*
}
;
crate
:
:
_cssparser_internal_to_lowercase
!
(
input
_cssparser_internal
:
:
MAX_LENGTH
=
>
lowercase
)
;
lowercase
.
and_then
(
|
s
|
MAP
.
get
(
s
)
)
}
}
}
#
[
inline
(
always
)
]
pub
fn
_cssparser_internal_create_uninit_array
<
const
N
:
usize
>
(
)
-
>
[
MaybeUninit
<
u8
>
;
N
]
{
unsafe
{
MaybeUninit
:
:
<
[
MaybeUninit
<
u8
>
;
N
]
>
:
:
uninit
(
)
.
assume_init
(
)
}
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
_cssparser_internal_to_lowercase
{
(
input
:
expr
BUFFER_SIZE
:
expr
=
>
output
:
ident
)
=
>
{
let
mut
buffer
=
crate
:
:
_cssparser_internal_create_uninit_array
:
:
<
{
BUFFER_SIZE
}
>
(
)
;
let
input
:
&
str
=
input
;
let
output
=
crate
:
:
_cssparser_internal_to_lowercase
(
&
mut
buffer
input
)
;
}
;
}
#
[
doc
(
hidden
)
]
#
[
allow
(
non_snake_case
)
]
#
[
inline
]
pub
fn
_cssparser_internal_to_lowercase
<
'
a
>
(
buffer
:
&
'
a
mut
[
MaybeUninit
<
u8
>
]
input
:
&
'
a
str
)
-
>
Option
<
&
'
a
str
>
{
let
buffer
=
buffer
.
get_mut
(
.
.
input
.
len
(
)
)
?
;
#
[
cold
]
fn
make_ascii_lowercase
<
'
a
>
(
buffer
:
&
'
a
mut
[
MaybeUninit
<
u8
>
]
input
:
&
'
a
str
first_uppercase
:
usize
)
-
>
&
'
a
str
{
let
input_bytes
=
unsafe
{
&
*
(
input
.
as_bytes
(
)
as
*
const
[
u8
]
as
*
const
[
MaybeUninit
<
u8
>
]
)
}
;
buffer
.
copy_from_slice
(
&
*
input_bytes
)
;
let
buffer
=
unsafe
{
&
mut
*
(
buffer
as
*
mut
[
MaybeUninit
<
u8
>
]
as
*
mut
[
u8
]
)
}
;
buffer
[
first_uppercase
.
.
]
.
make_ascii_lowercase
(
)
;
unsafe
{
:
:
std
:
:
str
:
:
from_utf8_unchecked
(
buffer
)
}
}
Some
(
match
input
.
bytes
(
)
.
position
(
|
byte
|
matches
!
(
byte
b
'
A
'
.
.
=
b
'
Z
'
)
)
{
Some
(
first_uppercase
)
=
>
make_ascii_lowercase
(
buffer
input
first_uppercase
)
None
=
>
input
}
)
}
#
[
cfg
(
feature
=
"
dummy_match_byte
"
)
]
macro_rules
!
match_byte
{
(
value
:
expr
(
rest
:
tt
)
*
)
=
>
{
match
value
{
(
rest
)
+
}
}
;
}
