define_invoke_proc_macro
!
(
cssparser_internal__invoke_proc_macro
)
;
#
[
macro_export
]
macro_rules
!
match_ignore_ascii_case
{
(
input
:
expr
(
match_body
:
tt
)
*
)
=
>
{
{
cssparser_internal__invoke_proc_macro
!
{
cssparser_internal__assert_ascii_lowercase__max_len
!
(
(
match_body
)
*
)
}
{
/
/
MAX_LENGTH
is
generated
by
cssparser_internal__assert_ascii_lowercase__max_len
cssparser_internal__to_lowercase
!
(
input
MAX_LENGTH
=
>
lowercase
)
;
/
/
"
A
"
is
a
short
string
that
we
know
is
different
for
every
string
pattern
/
/
since
we
ve
verified
that
none
of
them
include
ASCII
upper
case
letters
.
match
lowercase
.
unwrap_or
(
"
A
"
)
{
(
match_body
)
*
}
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
ascii_case_insensitive_phf_map
{
(
name
:
ident
-
>
ValueType
:
ty
=
{
(
key
:
expr
=
>
value
:
expr
)
*
}
)
=
>
{
ascii_case_insensitive_phf_map
!
(
name
-
>
ValueType
=
{
(
key
=
>
value
)
*
}
)
}
;
(
name
:
ident
-
>
ValueType
:
ty
=
{
(
key
:
expr
=
>
value
:
expr
)
*
}
)
=
>
{
pub
fn
name
(
input
:
&
str
)
-
>
Option
<
&
'
static
ValueType
>
{
cssparser_internal__invoke_proc_macro
!
{
cssparser_internal__phf_map
!
(
(
ValueType
)
(
key
(
value
)
)
+
)
}
{
cssparser_internal__invoke_proc_macro
!
{
cssparser_internal__max_len
!
(
(
key
)
+
)
}
/
/
MAX_LENGTH
is
generated
by
cssparser_internal__max_len
cssparser_internal__to_lowercase
!
(
input
MAX_LENGTH
=
>
lowercase
)
;
lowercase
.
and_then
(
|
s
|
MAP
.
get
(
s
)
)
}
}
}
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
cssparser_internal__to_lowercase
{
(
input
:
expr
BUFFER_SIZE
:
expr
=
>
output
:
ident
)
=
>
{
/
/
mem
:
:
uninitialized
(
)
is
ok
because
buffer
is
only
used
in
_internal__to_lowercase
/
/
which
initializes
with
copy_from_slice
the
part
of
the
buffer
it
uses
/
/
before
it
uses
it
.
#
[
allow
(
unsafe_code
)
]
let
mut
buffer
:
[
u8
;
BUFFER_SIZE
]
=
unsafe
{
:
:
std
:
:
mem
:
:
uninitialized
(
)
}
;
let
input
:
&
str
=
input
;
let
output
=
crate
:
:
_internal__to_lowercase
(
&
mut
buffer
input
)
;
}
;
}
#
[
doc
(
hidden
)
]
#
[
allow
(
non_snake_case
)
]
pub
fn
_internal__to_lowercase
<
'
a
>
(
buffer
:
&
'
a
mut
[
u8
]
input
:
&
'
a
str
)
-
>
Option
<
&
'
a
str
>
{
if
let
Some
(
buffer
)
=
buffer
.
get_mut
(
.
.
input
.
len
(
)
)
{
if
let
Some
(
first_uppercase
)
=
input
.
bytes
(
)
.
position
(
|
byte
|
matches
!
(
byte
b
'
A
'
.
.
.
b
'
Z
'
)
)
{
buffer
.
copy_from_slice
(
input
.
as_bytes
(
)
)
;
buffer
[
first_uppercase
.
.
]
.
make_ascii_lowercase
(
)
;
unsafe
{
Some
(
:
:
std
:
:
str
:
:
from_utf8_unchecked
(
buffer
)
)
}
}
else
{
Some
(
input
)
}
}
else
{
None
}
}
#
[
cfg
(
feature
=
"
dummy_match_byte
"
)
]
macro_rules
!
match_byte
{
(
value
:
expr
(
rest
:
tt
)
*
)
=
>
{
match
value
{
(
rest
)
+
}
}
;
}
