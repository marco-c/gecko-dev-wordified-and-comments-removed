use
{
Parser
ToCss
BasicParseError
}
;
use
std
:
:
char
;
use
std
:
:
cmp
;
use
std
:
:
fmt
;
use
tokenizer
:
:
Token
;
#
[
derive
(
PartialEq
Eq
Clone
Hash
)
]
pub
struct
UnicodeRange
{
pub
start
:
u32
pub
end
:
u32
}
impl
UnicodeRange
{
pub
fn
parse
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
Self
BasicParseError
<
'
i
>
>
{
input
.
expect_ident_matching
(
"
u
"
)
?
;
let
after_u
=
input
.
position
(
)
;
parse_tokens
(
input
)
?
;
let
concatenated_tokens
=
input
.
slice_from
(
after_u
)
;
let
range
=
match
parse_concatenated
(
concatenated_tokens
.
as_bytes
(
)
)
{
Ok
(
range
)
=
>
range
Err
(
(
)
)
=
>
return
Err
(
BasicParseError
:
:
UnexpectedToken
(
Token
:
:
Ident
(
concatenated_tokens
.
into
(
)
)
)
)
}
;
if
range
.
end
>
char
:
:
MAX
as
u32
|
|
range
.
start
>
range
.
end
{
Err
(
BasicParseError
:
:
UnexpectedToken
(
Token
:
:
Ident
(
concatenated_tokens
.
into
(
)
)
)
)
}
else
{
Ok
(
range
)
}
}
}
fn
parse_tokens
<
'
i
'
t
>
(
input
:
&
mut
Parser
<
'
i
'
t
>
)
-
>
Result
<
(
)
BasicParseError
<
'
i
>
>
{
match
input
.
next_including_whitespace
(
)
?
{
Token
:
:
Delim
(
'
+
'
)
=
>
{
match
input
.
next_including_whitespace
(
)
?
{
Token
:
:
Ident
(
_
)
=
>
{
}
Token
:
:
Delim
(
'
?
'
)
=
>
{
}
t
=
>
return
Err
(
BasicParseError
:
:
UnexpectedToken
(
t
)
)
}
parse_question_marks
(
input
)
}
Token
:
:
Dimension
(
.
.
)
=
>
{
parse_question_marks
(
input
)
}
Token
:
:
Number
(
_
)
=
>
{
let
after_number
=
input
.
position
(
)
;
match
input
.
next_including_whitespace
(
)
{
Ok
(
Token
:
:
Delim
(
'
?
'
)
)
=
>
parse_question_marks
(
input
)
Ok
(
Token
:
:
Dimension
(
.
.
)
)
=
>
{
}
Ok
(
Token
:
:
Number
(
_
)
)
=
>
{
}
_
=
>
input
.
reset
(
after_number
)
}
}
t
=
>
return
Err
(
BasicParseError
:
:
UnexpectedToken
(
t
)
)
}
Ok
(
(
)
)
}
fn
parse_question_marks
(
input
:
&
mut
Parser
)
{
loop
{
let
position
=
input
.
position
(
)
;
match
input
.
next_including_whitespace
(
)
{
Ok
(
Token
:
:
Delim
(
'
?
'
)
)
=
>
{
}
_
=
>
{
input
.
reset
(
position
)
;
return
}
}
}
}
fn
parse_concatenated
(
text
:
&
[
u8
]
)
-
>
Result
<
UnicodeRange
(
)
>
{
let
mut
text
=
match
text
.
split_first
(
)
{
Some
(
(
&
b
'
+
'
text
)
)
=
>
text
_
=
>
return
Err
(
(
)
)
}
;
let
(
first_hex_value
hex_digit_count
)
=
consume_hex
(
&
mut
text
)
;
let
question_marks
=
consume_question_marks
(
&
mut
text
)
;
let
consumed
=
hex_digit_count
+
question_marks
;
if
consumed
=
=
0
|
|
consumed
>
6
{
return
Err
(
(
)
)
}
if
question_marks
>
0
{
if
text
.
is_empty
(
)
{
return
Ok
(
UnicodeRange
{
start
:
first_hex_value
<
<
(
question_marks
*
4
)
end
:
(
(
first_hex_value
+
1
)
<
<
(
question_marks
*
4
)
)
-
1
}
)
}
}
else
if
text
.
is_empty
(
)
{
return
Ok
(
UnicodeRange
{
start
:
first_hex_value
end
:
first_hex_value
}
)
}
else
{
if
let
Some
(
(
&
b
'
-
'
mut
text
)
)
=
text
.
split_first
(
)
{
let
(
second_hex_value
hex_digit_count
)
=
consume_hex
(
&
mut
text
)
;
if
hex_digit_count
>
0
&
&
hex_digit_count
<
=
6
&
&
text
.
is_empty
(
)
{
return
Ok
(
UnicodeRange
{
start
:
first_hex_value
end
:
second_hex_value
}
)
}
}
}
Err
(
(
)
)
}
fn
consume_hex
(
text
:
&
mut
&
[
u8
]
)
-
>
(
u32
usize
)
{
let
mut
value
=
0
;
let
mut
digits
=
0
;
while
let
Some
(
(
&
byte
rest
)
)
=
text
.
split_first
(
)
{
if
let
Some
(
digit_value
)
=
(
byte
as
char
)
.
to_digit
(
16
)
{
value
=
value
*
0x10
+
digit_value
;
digits
+
=
1
;
*
text
=
rest
}
else
{
break
}
}
(
value
digits
)
}
fn
consume_question_marks
(
text
:
&
mut
&
[
u8
]
)
-
>
usize
{
let
mut
question_marks
=
0
;
while
let
Some
(
(
&
b
'
?
'
rest
)
)
=
text
.
split_first
(
)
{
question_marks
+
=
1
;
*
text
=
rest
}
question_marks
}
impl
fmt
:
:
Debug
for
UnicodeRange
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
to_css
(
formatter
)
}
}
impl
ToCss
for
UnicodeRange
{
fn
to_css
<
W
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
where
W
:
fmt
:
:
Write
{
dest
.
write_str
(
"
U
+
"
)
?
;
let
bits
=
cmp
:
:
min
(
self
.
start
.
trailing_zeros
(
)
(
!
self
.
end
)
.
trailing_zeros
(
)
)
;
let
question_marks
=
bits
/
4
;
let
bits
=
question_marks
*
4
;
let
truncated_start
=
self
.
start
>
>
bits
;
let
truncated_end
=
self
.
end
>
>
bits
;
if
truncated_start
=
=
truncated_end
{
if
truncated_start
!
=
0
{
write
!
(
dest
"
{
:
X
}
"
truncated_start
)
?
;
}
for
_
in
0
.
.
question_marks
{
dest
.
write_str
(
"
?
"
)
?
;
}
}
else
{
write
!
(
dest
"
{
:
X
}
"
self
.
start
)
?
;
if
self
.
end
!
=
self
.
start
{
write
!
(
dest
"
-
{
:
X
}
"
self
.
end
)
?
;
}
}
Ok
(
(
)
)
}
}
