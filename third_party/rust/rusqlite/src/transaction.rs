use
crate
:
:
{
Connection
Result
}
;
use
std
:
:
ops
:
:
Deref
;
#
[
derive
(
Copy
Clone
)
]
#
[
non_exhaustive
]
pub
enum
TransactionBehavior
{
Deferred
Immediate
Exclusive
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
enum
DropBehavior
{
Rollback
Commit
Ignore
Panic
}
#
[
derive
(
Debug
)
]
pub
struct
Transaction
<
'
conn
>
{
conn
:
&
'
conn
Connection
drop_behavior
:
DropBehavior
}
pub
struct
Savepoint
<
'
conn
>
{
conn
:
&
'
conn
Connection
name
:
String
depth
:
u32
drop_behavior
:
DropBehavior
committed
:
bool
}
impl
Transaction
<
'
_
>
{
pub
fn
new
(
conn
:
&
mut
Connection
behavior
:
TransactionBehavior
)
-
>
Result
<
Transaction
<
'
_
>
>
{
Self
:
:
new_unchecked
(
conn
behavior
)
}
pub
fn
new_unchecked
(
conn
:
&
Connection
behavior
:
TransactionBehavior
)
-
>
Result
<
Transaction
<
'
_
>
>
{
let
query
=
match
behavior
{
TransactionBehavior
:
:
Deferred
=
>
"
BEGIN
DEFERRED
"
TransactionBehavior
:
:
Immediate
=
>
"
BEGIN
IMMEDIATE
"
TransactionBehavior
:
:
Exclusive
=
>
"
BEGIN
EXCLUSIVE
"
}
;
conn
.
execute_batch
(
query
)
.
map
(
move
|
_
|
Transaction
{
conn
drop_behavior
:
DropBehavior
:
:
Rollback
}
)
}
pub
fn
savepoint
(
&
mut
self
)
-
>
Result
<
Savepoint
<
'
_
>
>
{
Savepoint
:
:
with_depth
(
self
.
conn
1
)
}
pub
fn
savepoint_with_name
<
T
:
Into
<
String
>
>
(
&
mut
self
name
:
T
)
-
>
Result
<
Savepoint
<
'
_
>
>
{
Savepoint
:
:
with_depth_and_name
(
self
.
conn
1
name
)
}
pub
fn
drop_behavior
(
&
self
)
-
>
DropBehavior
{
self
.
drop_behavior
}
pub
fn
set_drop_behavior
(
&
mut
self
drop_behavior
:
DropBehavior
)
{
self
.
drop_behavior
=
drop_behavior
}
pub
fn
commit
(
mut
self
)
-
>
Result
<
(
)
>
{
self
.
commit_
(
)
}
fn
commit_
(
&
mut
self
)
-
>
Result
<
(
)
>
{
self
.
conn
.
execute_batch
(
"
COMMIT
"
)
?
;
Ok
(
(
)
)
}
pub
fn
rollback
(
mut
self
)
-
>
Result
<
(
)
>
{
self
.
rollback_
(
)
}
fn
rollback_
(
&
mut
self
)
-
>
Result
<
(
)
>
{
self
.
conn
.
execute_batch
(
"
ROLLBACK
"
)
?
;
Ok
(
(
)
)
}
pub
fn
finish
(
mut
self
)
-
>
Result
<
(
)
>
{
self
.
finish_
(
)
}
fn
finish_
(
&
mut
self
)
-
>
Result
<
(
)
>
{
if
self
.
conn
.
is_autocommit
(
)
{
return
Ok
(
(
)
)
;
}
match
self
.
drop_behavior
(
)
{
DropBehavior
:
:
Commit
=
>
self
.
commit_
(
)
.
or_else
(
|
_
|
self
.
rollback_
(
)
)
DropBehavior
:
:
Rollback
=
>
self
.
rollback_
(
)
DropBehavior
:
:
Ignore
=
>
Ok
(
(
)
)
DropBehavior
:
:
Panic
=
>
panic
!
(
"
Transaction
dropped
unexpectedly
.
"
)
}
}
}
impl
Deref
for
Transaction
<
'
_
>
{
type
Target
=
Connection
;
fn
deref
(
&
self
)
-
>
&
Connection
{
self
.
conn
}
}
#
[
allow
(
unused_must_use
)
]
impl
Drop
for
Transaction
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
self
.
finish_
(
)
;
}
}
impl
Savepoint
<
'
_
>
{
fn
with_depth_and_name
<
T
:
Into
<
String
>
>
(
conn
:
&
Connection
depth
:
u32
name
:
T
)
-
>
Result
<
Savepoint
<
'
_
>
>
{
let
name
=
name
.
into
(
)
;
conn
.
execute_batch
(
&
format
!
(
"
SAVEPOINT
{
}
"
name
)
)
.
map
(
|
_
|
Savepoint
{
conn
name
depth
drop_behavior
:
DropBehavior
:
:
Rollback
committed
:
false
}
)
}
fn
with_depth
(
conn
:
&
Connection
depth
:
u32
)
-
>
Result
<
Savepoint
<
'
_
>
>
{
let
name
=
format
!
(
"
_rusqlite_sp_
{
}
"
depth
)
;
Savepoint
:
:
with_depth_and_name
(
conn
depth
name
)
}
pub
fn
new
(
conn
:
&
mut
Connection
)
-
>
Result
<
Savepoint
<
'
_
>
>
{
Savepoint
:
:
with_depth
(
conn
0
)
}
pub
fn
with_name
<
T
:
Into
<
String
>
>
(
conn
:
&
mut
Connection
name
:
T
)
-
>
Result
<
Savepoint
<
'
_
>
>
{
Savepoint
:
:
with_depth_and_name
(
conn
0
name
)
}
pub
fn
savepoint
(
&
mut
self
)
-
>
Result
<
Savepoint
<
'
_
>
>
{
Savepoint
:
:
with_depth
(
self
.
conn
self
.
depth
+
1
)
}
pub
fn
savepoint_with_name
<
T
:
Into
<
String
>
>
(
&
mut
self
name
:
T
)
-
>
Result
<
Savepoint
<
'
_
>
>
{
Savepoint
:
:
with_depth_and_name
(
self
.
conn
self
.
depth
+
1
name
)
}
pub
fn
drop_behavior
(
&
self
)
-
>
DropBehavior
{
self
.
drop_behavior
}
pub
fn
set_drop_behavior
(
&
mut
self
drop_behavior
:
DropBehavior
)
{
self
.
drop_behavior
=
drop_behavior
}
pub
fn
commit
(
mut
self
)
-
>
Result
<
(
)
>
{
self
.
commit_
(
)
}
fn
commit_
(
&
mut
self
)
-
>
Result
<
(
)
>
{
self
.
conn
.
execute_batch
(
&
format
!
(
"
RELEASE
{
}
"
self
.
name
)
)
?
;
self
.
committed
=
true
;
Ok
(
(
)
)
}
pub
fn
rollback
(
&
mut
self
)
-
>
Result
<
(
)
>
{
self
.
conn
.
execute_batch
(
&
format
!
(
"
ROLLBACK
TO
{
}
"
self
.
name
)
)
}
pub
fn
finish
(
mut
self
)
-
>
Result
<
(
)
>
{
self
.
finish_
(
)
}
fn
finish_
(
&
mut
self
)
-
>
Result
<
(
)
>
{
if
self
.
committed
{
return
Ok
(
(
)
)
;
}
match
self
.
drop_behavior
(
)
{
DropBehavior
:
:
Commit
=
>
self
.
commit_
(
)
.
or_else
(
|
_
|
self
.
rollback
(
)
)
DropBehavior
:
:
Rollback
=
>
self
.
rollback
(
)
DropBehavior
:
:
Ignore
=
>
Ok
(
(
)
)
DropBehavior
:
:
Panic
=
>
panic
!
(
"
Savepoint
dropped
unexpectedly
.
"
)
}
}
}
impl
Deref
for
Savepoint
<
'
_
>
{
type
Target
=
Connection
;
fn
deref
(
&
self
)
-
>
&
Connection
{
self
.
conn
}
}
#
[
allow
(
unused_must_use
)
]
impl
Drop
for
Savepoint
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
self
.
finish_
(
)
;
}
}
impl
Connection
{
pub
fn
transaction
(
&
mut
self
)
-
>
Result
<
Transaction
<
'
_
>
>
{
Transaction
:
:
new
(
self
TransactionBehavior
:
:
Deferred
)
}
pub
fn
transaction_with_behavior
(
&
mut
self
behavior
:
TransactionBehavior
)
-
>
Result
<
Transaction
<
'
_
>
>
{
Transaction
:
:
new
(
self
behavior
)
}
pub
fn
unchecked_transaction
(
&
self
)
-
>
Result
<
Transaction
<
'
_
>
>
{
Transaction
:
:
new_unchecked
(
self
TransactionBehavior
:
:
Deferred
)
}
pub
fn
savepoint
(
&
mut
self
)
-
>
Result
<
Savepoint
<
'
_
>
>
{
Savepoint
:
:
new
(
self
)
}
pub
fn
savepoint_with_name
<
T
:
Into
<
String
>
>
(
&
mut
self
name
:
T
)
-
>
Result
<
Savepoint
<
'
_
>
>
{
Savepoint
:
:
with_name
(
self
name
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
DropBehavior
;
use
crate
:
:
{
Connection
Error
NO_PARAMS
}
;
fn
checked_memory_handle
(
)
-
>
Connection
{
let
db
=
Connection
:
:
open_in_memory
(
)
.
unwrap
(
)
;
db
.
execute_batch
(
"
CREATE
TABLE
foo
(
x
INTEGER
)
"
)
.
unwrap
(
)
;
db
}
#
[
test
]
fn
test_drop
(
)
{
let
mut
db
=
checked_memory_handle
(
)
;
{
let
tx
=
db
.
transaction
(
)
.
unwrap
(
)
;
tx
.
execute_batch
(
"
INSERT
INTO
foo
VALUES
(
1
)
"
)
.
unwrap
(
)
;
}
{
let
mut
tx
=
db
.
transaction
(
)
.
unwrap
(
)
;
tx
.
execute_batch
(
"
INSERT
INTO
foo
VALUES
(
2
)
"
)
.
unwrap
(
)
;
tx
.
set_drop_behavior
(
DropBehavior
:
:
Commit
)
}
{
let
tx
=
db
.
transaction
(
)
.
unwrap
(
)
;
assert_eq
!
(
2i32
tx
.
query_row
:
:
<
i32
_
_
>
(
"
SELECT
SUM
(
x
)
FROM
foo
"
NO_PARAMS
|
r
|
r
.
get
(
0
)
)
.
unwrap
(
)
)
;
}
}
fn
assert_nested_tx_error
(
e
:
crate
:
:
Error
)
{
if
let
Error
:
:
SqliteFailure
(
e
Some
(
m
)
)
=
&
e
{
assert_eq
!
(
e
.
extended_code
crate
:
:
ffi
:
:
SQLITE_ERROR
)
;
assert_eq
!
(
e
.
code
crate
:
:
ErrorCode
:
:
Unknown
)
;
assert
!
(
m
.
contains
(
"
transaction
"
)
)
;
}
else
{
panic
!
(
"
Unexpected
error
type
:
{
:
?
}
"
e
)
;
}
}
#
[
test
]
fn
test_unchecked_nesting
(
)
{
let
db
=
checked_memory_handle
(
)
;
{
let
tx
=
db
.
unchecked_transaction
(
)
.
unwrap
(
)
;
let
e
=
tx
.
unchecked_transaction
(
)
.
unwrap_err
(
)
;
assert_nested_tx_error
(
e
)
;
}
{
let
tx
=
db
.
unchecked_transaction
(
)
.
unwrap
(
)
;
tx
.
execute_batch
(
"
INSERT
INTO
foo
VALUES
(
1
)
"
)
.
unwrap
(
)
;
let
e
=
tx
.
unchecked_transaction
(
)
.
unwrap_err
(
)
;
assert_nested_tx_error
(
e
)
;
tx
.
execute_batch
(
"
INSERT
INTO
foo
VALUES
(
1
)
"
)
.
unwrap
(
)
;
tx
.
commit
(
)
.
unwrap
(
)
;
}
assert_eq
!
(
2i32
db
.
query_row
:
:
<
i32
_
_
>
(
"
SELECT
SUM
(
x
)
FROM
foo
"
NO_PARAMS
|
r
|
r
.
get
(
0
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
test_explicit_rollback_commit
(
)
{
let
mut
db
=
checked_memory_handle
(
)
;
{
let
mut
tx
=
db
.
transaction
(
)
.
unwrap
(
)
;
{
let
mut
sp
=
tx
.
savepoint
(
)
.
unwrap
(
)
;
sp
.
execute_batch
(
"
INSERT
INTO
foo
VALUES
(
1
)
"
)
.
unwrap
(
)
;
sp
.
rollback
(
)
.
unwrap
(
)
;
sp
.
execute_batch
(
"
INSERT
INTO
foo
VALUES
(
2
)
"
)
.
unwrap
(
)
;
sp
.
commit
(
)
.
unwrap
(
)
;
}
tx
.
commit
(
)
.
unwrap
(
)
;
}
{
let
tx
=
db
.
transaction
(
)
.
unwrap
(
)
;
tx
.
execute_batch
(
"
INSERT
INTO
foo
VALUES
(
4
)
"
)
.
unwrap
(
)
;
tx
.
commit
(
)
.
unwrap
(
)
;
}
{
let
tx
=
db
.
transaction
(
)
.
unwrap
(
)
;
assert_eq
!
(
6i32
tx
.
query_row
:
:
<
i32
_
_
>
(
"
SELECT
SUM
(
x
)
FROM
foo
"
NO_PARAMS
|
r
|
r
.
get
(
0
)
)
.
unwrap
(
)
)
;
}
}
#
[
test
]
fn
test_savepoint
(
)
{
let
mut
db
=
checked_memory_handle
(
)
;
{
let
mut
tx
=
db
.
transaction
(
)
.
unwrap
(
)
;
tx
.
execute_batch
(
"
INSERT
INTO
foo
VALUES
(
1
)
"
)
.
unwrap
(
)
;
assert_current_sum
(
1
&
tx
)
;
tx
.
set_drop_behavior
(
DropBehavior
:
:
Commit
)
;
{
let
mut
sp1
=
tx
.
savepoint
(
)
.
unwrap
(
)
;
sp1
.
execute_batch
(
"
INSERT
INTO
foo
VALUES
(
2
)
"
)
.
unwrap
(
)
;
assert_current_sum
(
3
&
sp1
)
;
{
let
mut
sp2
=
sp1
.
savepoint
(
)
.
unwrap
(
)
;
sp2
.
execute_batch
(
"
INSERT
INTO
foo
VALUES
(
4
)
"
)
.
unwrap
(
)
;
assert_current_sum
(
7
&
sp2
)
;
{
let
sp3
=
sp2
.
savepoint
(
)
.
unwrap
(
)
;
sp3
.
execute_batch
(
"
INSERT
INTO
foo
VALUES
(
8
)
"
)
.
unwrap
(
)
;
assert_current_sum
(
15
&
sp3
)
;
sp3
.
commit
(
)
.
unwrap
(
)
;
}
assert_current_sum
(
15
&
sp2
)
;
}
assert_current_sum
(
3
&
sp1
)
;
}
assert_current_sum
(
1
&
tx
)
;
}
assert_current_sum
(
1
&
db
)
;
}
#
[
test
]
fn
test_ignore_drop_behavior
(
)
{
let
mut
db
=
checked_memory_handle
(
)
;
let
mut
tx
=
db
.
transaction
(
)
.
unwrap
(
)
;
{
let
mut
sp1
=
tx
.
savepoint
(
)
.
unwrap
(
)
;
insert
(
1
&
sp1
)
;
sp1
.
rollback
(
)
.
unwrap
(
)
;
insert
(
2
&
sp1
)
;
{
let
mut
sp2
=
sp1
.
savepoint
(
)
.
unwrap
(
)
;
sp2
.
set_drop_behavior
(
DropBehavior
:
:
Ignore
)
;
insert
(
4
&
sp2
)
;
}
assert_current_sum
(
6
&
sp1
)
;
sp1
.
commit
(
)
.
unwrap
(
)
;
}
assert_current_sum
(
6
&
tx
)
;
}
#
[
test
]
fn
test_savepoint_names
(
)
{
let
mut
db
=
checked_memory_handle
(
)
;
{
let
mut
sp1
=
db
.
savepoint_with_name
(
"
my_sp
"
)
.
unwrap
(
)
;
insert
(
1
&
sp1
)
;
assert_current_sum
(
1
&
sp1
)
;
{
let
mut
sp2
=
sp1
.
savepoint_with_name
(
"
my_sp
"
)
.
unwrap
(
)
;
sp2
.
set_drop_behavior
(
DropBehavior
:
:
Commit
)
;
insert
(
2
&
sp2
)
;
assert_current_sum
(
3
&
sp2
)
;
sp2
.
rollback
(
)
.
unwrap
(
)
;
assert_current_sum
(
1
&
sp2
)
;
insert
(
4
&
sp2
)
;
}
assert_current_sum
(
5
&
sp1
)
;
sp1
.
rollback
(
)
.
unwrap
(
)
;
{
let
mut
sp2
=
sp1
.
savepoint_with_name
(
"
my_sp
"
)
.
unwrap
(
)
;
sp2
.
set_drop_behavior
(
DropBehavior
:
:
Ignore
)
;
insert
(
8
&
sp2
)
;
}
assert_current_sum
(
8
&
sp1
)
;
sp1
.
commit
(
)
.
unwrap
(
)
;
}
assert_current_sum
(
8
&
db
)
;
}
#
[
test
]
fn
test_rc
(
)
{
use
std
:
:
rc
:
:
Rc
;
let
mut
conn
=
Connection
:
:
open_in_memory
(
)
.
unwrap
(
)
;
let
rc_txn
=
Rc
:
:
new
(
conn
.
transaction
(
)
.
unwrap
(
)
)
;
Rc
:
:
try_unwrap
(
rc_txn
)
.
unwrap
(
)
;
}
fn
insert
(
x
:
i32
conn
:
&
Connection
)
{
conn
.
execute
(
"
INSERT
INTO
foo
VALUES
(
?
)
"
&
[
x
]
)
.
unwrap
(
)
;
}
fn
assert_current_sum
(
x
:
i32
conn
:
&
Connection
)
{
let
i
=
conn
.
query_row
:
:
<
i32
_
_
>
(
"
SELECT
SUM
(
x
)
FROM
foo
"
NO_PARAMS
|
r
|
r
.
get
(
0
)
)
.
unwrap
(
)
;
assert_eq
!
(
x
i
)
;
}
}
