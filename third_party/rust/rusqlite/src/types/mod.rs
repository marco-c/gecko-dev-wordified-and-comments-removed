pub
use
self
:
:
from_sql
:
:
{
FromSql
FromSqlError
FromSqlResult
}
;
pub
use
self
:
:
to_sql
:
:
{
ToSql
ToSqlOutput
}
;
pub
use
self
:
:
value
:
:
Value
;
pub
use
self
:
:
value_ref
:
:
ValueRef
;
use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
chrono
"
)
]
mod
chrono
;
mod
from_sql
;
#
[
cfg
(
feature
=
"
serde_json
"
)
]
mod
serde_json
;
mod
time
;
mod
to_sql
;
#
[
cfg
(
feature
=
"
url
"
)
]
mod
url
;
mod
value
;
mod
value_ref
;
#
[
derive
(
Copy
Clone
)
]
pub
struct
Null
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
Type
{
Null
Integer
Real
Text
Blob
}
impl
fmt
:
:
Display
for
Type
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
Type
:
:
Null
=
>
write
!
(
f
"
Null
"
)
Type
:
:
Integer
=
>
write
!
(
f
"
Integer
"
)
Type
:
:
Real
=
>
write
!
(
f
"
Real
"
)
Type
:
:
Text
=
>
write
!
(
f
"
Text
"
)
Type
:
:
Blob
=
>
write
!
(
f
"
Blob
"
)
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
Value
;
use
crate
:
:
{
Connection
Error
NO_PARAMS
}
;
use
std
:
:
f64
:
:
EPSILON
;
use
std
:
:
os
:
:
raw
:
:
{
c_double
c_int
}
;
fn
checked_memory_handle
(
)
-
>
Connection
{
let
db
=
Connection
:
:
open_in_memory
(
)
.
unwrap
(
)
;
db
.
execute_batch
(
"
CREATE
TABLE
foo
(
b
BLOB
t
TEXT
i
INTEGER
f
FLOAT
n
)
"
)
.
unwrap
(
)
;
db
}
#
[
test
]
fn
test_blob
(
)
{
let
db
=
checked_memory_handle
(
)
;
let
v1234
=
vec
!
[
1u8
2
3
4
]
;
db
.
execute
(
"
INSERT
INTO
foo
(
b
)
VALUES
(
?
)
"
&
[
&
v1234
]
)
.
unwrap
(
)
;
let
v
:
Vec
<
u8
>
=
db
.
query_row
(
"
SELECT
b
FROM
foo
"
NO_PARAMS
|
r
|
r
.
get
(
0
)
)
.
unwrap
(
)
;
assert_eq
!
(
v
v1234
)
;
}
#
[
test
]
fn
test_empty_blob
(
)
{
let
db
=
checked_memory_handle
(
)
;
let
empty
=
vec
!
[
]
;
db
.
execute
(
"
INSERT
INTO
foo
(
b
)
VALUES
(
?
)
"
&
[
&
empty
]
)
.
unwrap
(
)
;
let
v
:
Vec
<
u8
>
=
db
.
query_row
(
"
SELECT
b
FROM
foo
"
NO_PARAMS
|
r
|
r
.
get
(
0
)
)
.
unwrap
(
)
;
assert_eq
!
(
v
empty
)
;
}
#
[
test
]
fn
test_str
(
)
{
let
db
=
checked_memory_handle
(
)
;
let
s
=
"
hello
world
!
"
;
db
.
execute
(
"
INSERT
INTO
foo
(
t
)
VALUES
(
?
)
"
&
[
&
s
]
)
.
unwrap
(
)
;
let
from
:
String
=
db
.
query_row
(
"
SELECT
t
FROM
foo
"
NO_PARAMS
|
r
|
r
.
get
(
0
)
)
.
unwrap
(
)
;
assert_eq
!
(
from
s
)
;
}
#
[
test
]
fn
test_string
(
)
{
let
db
=
checked_memory_handle
(
)
;
let
s
=
"
hello
world
!
"
;
db
.
execute
(
"
INSERT
INTO
foo
(
t
)
VALUES
(
?
)
"
&
[
s
.
to_owned
(
)
]
)
.
unwrap
(
)
;
let
from
:
String
=
db
.
query_row
(
"
SELECT
t
FROM
foo
"
NO_PARAMS
|
r
|
r
.
get
(
0
)
)
.
unwrap
(
)
;
assert_eq
!
(
from
s
)
;
}
#
[
test
]
fn
test_value
(
)
{
let
db
=
checked_memory_handle
(
)
;
db
.
execute
(
"
INSERT
INTO
foo
(
i
)
VALUES
(
?
)
"
&
[
Value
:
:
Integer
(
10
)
]
)
.
unwrap
(
)
;
assert_eq
!
(
10i64
db
.
query_row
:
:
<
i64
_
_
>
(
"
SELECT
i
FROM
foo
"
NO_PARAMS
|
r
|
r
.
get
(
0
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
test_option
(
)
{
let
db
=
checked_memory_handle
(
)
;
let
s
=
Some
(
"
hello
world
!
"
)
;
let
b
=
Some
(
vec
!
[
1u8
2
3
4
]
)
;
db
.
execute
(
"
INSERT
INTO
foo
(
t
)
VALUES
(
?
)
"
&
[
&
s
]
)
.
unwrap
(
)
;
db
.
execute
(
"
INSERT
INTO
foo
(
b
)
VALUES
(
?
)
"
&
[
&
b
]
)
.
unwrap
(
)
;
let
mut
stmt
=
db
.
prepare
(
"
SELECT
t
b
FROM
foo
ORDER
BY
ROWID
ASC
"
)
.
unwrap
(
)
;
let
mut
rows
=
stmt
.
query
(
NO_PARAMS
)
.
unwrap
(
)
;
{
let
row1
=
rows
.
next
(
)
.
unwrap
(
)
.
unwrap
(
)
;
let
s1
:
Option
<
String
>
=
row1
.
get_unwrap
(
0
)
;
let
b1
:
Option
<
Vec
<
u8
>
>
=
row1
.
get_unwrap
(
1
)
;
assert_eq
!
(
s
.
unwrap
(
)
s1
.
unwrap
(
)
)
;
assert
!
(
b1
.
is_none
(
)
)
;
}
{
let
row2
=
rows
.
next
(
)
.
unwrap
(
)
.
unwrap
(
)
;
let
s2
:
Option
<
String
>
=
row2
.
get_unwrap
(
0
)
;
let
b2
:
Option
<
Vec
<
u8
>
>
=
row2
.
get_unwrap
(
1
)
;
assert
!
(
s2
.
is_none
(
)
)
;
assert_eq
!
(
b
b2
)
;
}
}
#
[
test
]
#
[
allow
(
clippy
:
:
cognitive_complexity
)
]
fn
test_mismatched_types
(
)
{
fn
is_invalid_column_type
(
err
:
Error
)
-
>
bool
{
match
err
{
Error
:
:
InvalidColumnType
(
.
.
)
=
>
true
_
=
>
false
}
}
let
db
=
checked_memory_handle
(
)
;
db
.
execute
(
"
INSERT
INTO
foo
(
b
t
i
f
)
VALUES
(
X
'
0102
'
'
text
'
1
1
.
5
)
"
NO_PARAMS
)
.
unwrap
(
)
;
let
mut
stmt
=
db
.
prepare
(
"
SELECT
b
t
i
f
n
FROM
foo
"
)
.
unwrap
(
)
;
let
mut
rows
=
stmt
.
query
(
NO_PARAMS
)
.
unwrap
(
)
;
let
row
=
rows
.
next
(
)
.
unwrap
(
)
.
unwrap
(
)
;
assert_eq
!
(
vec
!
[
1
2
]
row
.
get
:
:
<
_
Vec
<
u8
>
>
(
0
)
.
unwrap
(
)
)
;
assert_eq
!
(
"
text
"
row
.
get
:
:
<
_
String
>
(
1
)
.
unwrap
(
)
)
;
assert_eq
!
(
1
row
.
get
:
:
<
_
c_int
>
(
2
)
.
unwrap
(
)
)
;
assert
!
(
(
1
.
5
-
row
.
get
:
:
<
_
c_double
>
(
3
)
.
unwrap
(
)
)
.
abs
(
)
<
EPSILON
)
;
assert
!
(
row
.
get
:
:
<
_
Option
<
c_int
>
>
(
4
)
.
unwrap
(
)
.
is_none
(
)
)
;
assert
!
(
row
.
get
:
:
<
_
Option
<
c_double
>
>
(
4
)
.
unwrap
(
)
.
is_none
(
)
)
;
assert
!
(
row
.
get
:
:
<
_
Option
<
String
>
>
(
4
)
.
unwrap
(
)
.
is_none
(
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
c_int
>
(
0
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
c_int
>
(
0
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
i64
>
(
0
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
c_double
>
(
0
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
String
>
(
0
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
time
:
:
Timespec
>
(
0
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
Option
<
c_int
>
>
(
0
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
c_int
>
(
1
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
i64
>
(
1
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
c_double
>
(
1
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
Vec
<
u8
>
>
(
1
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
Option
<
c_int
>
>
(
1
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
String
>
(
2
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
Vec
<
u8
>
>
(
2
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
Option
<
String
>
>
(
2
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
c_int
>
(
3
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
i64
>
(
3
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
String
>
(
3
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
Vec
<
u8
>
>
(
3
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
Option
<
c_int
>
>
(
3
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
c_int
>
(
4
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
i64
>
(
4
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
c_double
>
(
4
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
String
>
(
4
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
Vec
<
u8
>
>
(
4
)
.
err
(
)
.
unwrap
(
)
)
)
;
assert
!
(
is_invalid_column_type
(
row
.
get
:
:
<
_
time
:
:
Timespec
>
(
4
)
.
err
(
)
.
unwrap
(
)
)
)
;
}
#
[
test
]
fn
test_dynamic_type
(
)
{
use
super
:
:
Value
;
let
db
=
checked_memory_handle
(
)
;
db
.
execute
(
"
INSERT
INTO
foo
(
b
t
i
f
)
VALUES
(
X
'
0102
'
'
text
'
1
1
.
5
)
"
NO_PARAMS
)
.
unwrap
(
)
;
let
mut
stmt
=
db
.
prepare
(
"
SELECT
b
t
i
f
n
FROM
foo
"
)
.
unwrap
(
)
;
let
mut
rows
=
stmt
.
query
(
NO_PARAMS
)
.
unwrap
(
)
;
let
row
=
rows
.
next
(
)
.
unwrap
(
)
.
unwrap
(
)
;
assert_eq
!
(
Value
:
:
Blob
(
vec
!
[
1
2
]
)
row
.
get
:
:
<
_
Value
>
(
0
)
.
unwrap
(
)
)
;
assert_eq
!
(
Value
:
:
Text
(
String
:
:
from
(
"
text
"
)
)
row
.
get
:
:
<
_
Value
>
(
1
)
.
unwrap
(
)
)
;
assert_eq
!
(
Value
:
:
Integer
(
1
)
row
.
get
:
:
<
_
Value
>
(
2
)
.
unwrap
(
)
)
;
match
row
.
get
:
:
<
_
Value
>
(
3
)
.
unwrap
(
)
{
Value
:
:
Real
(
val
)
=
>
assert
!
(
(
1
.
5
-
val
)
.
abs
(
)
<
EPSILON
)
x
=
>
panic
!
(
"
Invalid
Value
{
:
?
}
"
x
)
}
assert_eq
!
(
Value
:
:
Null
row
.
get
:
:
<
_
Value
>
(
4
)
.
unwrap
(
)
)
;
}
}
