use
super
:
:
{
Null
Type
}
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
Value
{
Null
Integer
(
i64
)
Real
(
f64
)
Text
(
String
)
Blob
(
Vec
<
u8
>
)
}
impl
From
<
Null
>
for
Value
{
#
[
inline
]
fn
from
(
_
:
Null
)
-
>
Self
{
Self
:
:
Null
}
}
impl
From
<
bool
>
for
Value
{
#
[
inline
]
fn
from
(
i
:
bool
)
-
>
Self
{
Self
:
:
Integer
(
i
as
i64
)
}
}
impl
From
<
isize
>
for
Value
{
#
[
inline
]
fn
from
(
i
:
isize
)
-
>
Self
{
Self
:
:
Integer
(
i
as
i64
)
}
}
#
[
cfg
(
feature
=
"
i128_blob
"
)
]
impl
From
<
i128
>
for
Value
{
#
[
inline
]
fn
from
(
i
:
i128
)
-
>
Self
{
Self
:
:
Blob
(
i128
:
:
to_be_bytes
(
i
^
(
1_i128
<
<
127
)
)
.
to_vec
(
)
)
}
}
#
[
cfg
(
feature
=
"
uuid
"
)
]
impl
From
<
uuid
:
:
Uuid
>
for
Value
{
#
[
inline
]
fn
from
(
id
:
uuid
:
:
Uuid
)
-
>
Self
{
Self
:
:
Blob
(
id
.
as_bytes
(
)
.
to_vec
(
)
)
}
}
macro_rules
!
from_i64
(
(
t
:
ty
)
=
>
(
impl
From
<
t
>
for
Value
{
#
[
inline
]
fn
from
(
i
:
t
)
-
>
Value
{
Value
:
:
Integer
(
i64
:
:
from
(
i
)
)
}
}
)
)
;
from_i64
!
(
i8
)
;
from_i64
!
(
i16
)
;
from_i64
!
(
i32
)
;
from_i64
!
(
u8
)
;
from_i64
!
(
u16
)
;
from_i64
!
(
u32
)
;
impl
From
<
i64
>
for
Value
{
#
[
inline
]
fn
from
(
i
:
i64
)
-
>
Self
{
Self
:
:
Integer
(
i
)
}
}
impl
From
<
f32
>
for
Value
{
#
[
inline
]
fn
from
(
f
:
f32
)
-
>
Self
{
Self
:
:
Real
(
f
.
into
(
)
)
}
}
impl
From
<
f64
>
for
Value
{
#
[
inline
]
fn
from
(
f
:
f64
)
-
>
Self
{
Self
:
:
Real
(
f
)
}
}
impl
From
<
String
>
for
Value
{
#
[
inline
]
fn
from
(
s
:
String
)
-
>
Self
{
Self
:
:
Text
(
s
)
}
}
impl
From
<
Vec
<
u8
>
>
for
Value
{
#
[
inline
]
fn
from
(
v
:
Vec
<
u8
>
)
-
>
Self
{
Self
:
:
Blob
(
v
)
}
}
impl
<
T
>
From
<
Option
<
T
>
>
for
Value
where
T
:
Into
<
Self
>
{
#
[
inline
]
fn
from
(
v
:
Option
<
T
>
)
-
>
Self
{
match
v
{
Some
(
x
)
=
>
x
.
into
(
)
None
=
>
Self
:
:
Null
}
}
}
impl
Value
{
#
[
inline
]
#
[
must_use
]
pub
fn
data_type
(
&
self
)
-
>
Type
{
match
*
self
{
Self
:
:
Null
=
>
Type
:
:
Null
Self
:
:
Integer
(
_
)
=
>
Type
:
:
Integer
Self
:
:
Real
(
_
)
=
>
Type
:
:
Real
Self
:
:
Text
(
_
)
=
>
Type
:
:
Text
Self
:
:
Blob
(
_
)
=
>
Type
:
:
Blob
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
Value
;
use
crate
:
:
types
:
:
Type
;
#
[
test
]
fn
from
(
)
{
assert_eq
!
(
Value
:
:
from
(
2f32
)
Value
:
:
Real
(
2f64
)
)
;
assert_eq
!
(
Value
:
:
from
(
3
.
)
Value
:
:
Real
(
3
.
)
)
;
assert_eq
!
(
Value
:
:
from
(
vec
!
[
0u8
]
)
Value
:
:
Blob
(
vec
!
[
0u8
]
)
)
;
}
#
[
test
]
fn
data_type
(
)
{
assert_eq
!
(
Value
:
:
Null
.
data_type
(
)
Type
:
:
Null
)
;
assert_eq
!
(
Value
:
:
Integer
(
0
)
.
data_type
(
)
Type
:
:
Integer
)
;
assert_eq
!
(
Value
:
:
Real
(
0
.
)
.
data_type
(
)
Type
:
:
Real
)
;
assert_eq
!
(
Value
:
:
Text
(
String
:
:
new
(
)
)
.
data_type
(
)
Type
:
:
Text
)
;
assert_eq
!
(
Value
:
:
Blob
(
vec
!
[
]
)
.
data_type
(
)
Type
:
:
Blob
)
;
}
#
[
test
]
fn
from_option
(
)
{
assert_eq
!
(
Value
:
:
from
(
None
as
Option
<
i64
>
)
Value
:
:
Null
)
;
assert_eq
!
(
Value
:
:
from
(
Some
(
0
)
)
Value
:
:
Integer
(
0
)
)
;
}
}
