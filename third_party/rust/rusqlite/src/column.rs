use
std
:
:
str
;
use
crate
:
:
{
Error
Result
Statement
}
;
#
[
cfg
(
feature
=
"
column_decltype
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
column_decltype
"
)
)
)
]
#
[
derive
(
Debug
)
]
pub
struct
Column
<
'
stmt
>
{
name
:
&
'
stmt
str
decl_type
:
Option
<
&
'
stmt
str
>
}
#
[
cfg
(
feature
=
"
column_decltype
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
column_decltype
"
)
)
)
]
impl
Column
<
'
_
>
{
#
[
inline
]
#
[
must_use
]
pub
fn
name
(
&
self
)
-
>
&
str
{
self
.
name
}
#
[
inline
]
#
[
must_use
]
pub
fn
decl_type
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
decl_type
}
}
impl
Statement
<
'
_
>
{
pub
fn
column_names
(
&
self
)
-
>
Vec
<
&
str
>
{
let
n
=
self
.
column_count
(
)
;
let
mut
cols
=
Vec
:
:
with_capacity
(
n
)
;
for
i
in
0
.
.
n
{
let
s
=
self
.
column_name_unwrap
(
i
)
;
cols
.
push
(
s
)
;
}
cols
}
#
[
inline
]
pub
fn
column_count
(
&
self
)
-
>
usize
{
self
.
stmt
.
column_count
(
)
}
#
[
inline
]
pub
(
super
)
fn
column_name_unwrap
(
&
self
col
:
usize
)
-
>
&
str
{
self
.
column_name
(
col
)
.
expect
(
"
Column
out
of
bounds
"
)
}
#
[
inline
]
pub
fn
column_name
(
&
self
col
:
usize
)
-
>
Result
<
&
str
>
{
self
.
stmt
.
column_name
(
col
)
.
ok_or
(
Error
:
:
InvalidColumnIndex
(
col
)
)
.
map
(
|
slice
|
{
str
:
:
from_utf8
(
slice
.
to_bytes
(
)
)
.
expect
(
"
Invalid
UTF
-
8
sequence
in
column
name
"
)
}
)
}
#
[
inline
]
pub
fn
column_index
(
&
self
name
:
&
str
)
-
>
Result
<
usize
>
{
let
bytes
=
name
.
as_bytes
(
)
;
let
n
=
self
.
column_count
(
)
;
for
i
in
0
.
.
n
{
if
bytes
.
eq_ignore_ascii_case
(
self
.
stmt
.
column_name
(
i
)
.
unwrap
(
)
.
to_bytes
(
)
)
{
return
Ok
(
i
)
;
}
}
Err
(
Error
:
:
InvalidColumnName
(
String
:
:
from
(
name
)
)
)
}
#
[
cfg
(
feature
=
"
column_decltype
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
column_decltype
"
)
)
)
]
pub
fn
columns
(
&
self
)
-
>
Vec
<
Column
>
{
let
n
=
self
.
column_count
(
)
;
let
mut
cols
=
Vec
:
:
with_capacity
(
n
)
;
for
i
in
0
.
.
n
{
let
name
=
self
.
column_name_unwrap
(
i
)
;
let
slice
=
self
.
stmt
.
column_decltype
(
i
)
;
let
decl_type
=
slice
.
map
(
|
s
|
{
str
:
:
from_utf8
(
s
.
to_bytes
(
)
)
.
expect
(
"
Invalid
UTF
-
8
sequence
in
column
declaration
"
)
}
)
;
cols
.
push
(
Column
{
name
decl_type
}
)
;
}
cols
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
crate
:
:
{
Connection
Result
}
;
#
[
test
]
#
[
cfg
(
feature
=
"
column_decltype
"
)
]
fn
test_columns
(
)
-
>
Result
<
(
)
>
{
use
super
:
:
Column
;
let
db
=
Connection
:
:
open_in_memory
(
)
?
;
let
query
=
db
.
prepare
(
"
SELECT
*
FROM
sqlite_master
"
)
?
;
let
columns
=
query
.
columns
(
)
;
let
column_names
:
Vec
<
&
str
>
=
columns
.
iter
(
)
.
map
(
Column
:
:
name
)
.
collect
(
)
;
assert_eq
!
(
column_names
.
as_slice
(
)
&
[
"
type
"
"
name
"
"
tbl_name
"
"
rootpage
"
"
sql
"
]
)
;
let
column_types
:
Vec
<
Option
<
String
>
>
=
columns
.
iter
(
)
.
map
(
|
col
|
col
.
decl_type
(
)
.
map
(
str
:
:
to_lowercase
)
)
.
collect
(
)
;
assert_eq
!
(
&
column_types
[
.
.
3
]
&
[
Some
(
"
text
"
.
to_owned
(
)
)
Some
(
"
text
"
.
to_owned
(
)
)
Some
(
"
text
"
.
to_owned
(
)
)
]
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
test_column_name_in_error
(
)
-
>
Result
<
(
)
>
{
use
crate
:
:
{
types
:
:
Type
Error
}
;
let
db
=
Connection
:
:
open_in_memory
(
)
?
;
db
.
execute_batch
(
"
BEGIN
;
CREATE
TABLE
foo
(
x
INTEGER
y
TEXT
)
;
INSERT
INTO
foo
VALUES
(
4
NULL
)
;
END
;
"
)
?
;
let
mut
stmt
=
db
.
prepare
(
"
SELECT
x
as
renamed
y
FROM
foo
"
)
?
;
let
mut
rows
=
stmt
.
query
(
[
]
)
?
;
let
row
=
rows
.
next
(
)
?
.
unwrap
(
)
;
match
row
.
get
:
:
<
_
String
>
(
0
)
.
unwrap_err
(
)
{
Error
:
:
InvalidColumnType
(
idx
name
ty
)
=
>
{
assert_eq
!
(
idx
0
)
;
assert_eq
!
(
name
"
renamed
"
)
;
assert_eq
!
(
ty
Type
:
:
Integer
)
;
}
e
=
>
{
panic
!
(
"
Unexpected
error
type
:
{
e
:
?
}
"
)
;
}
}
match
row
.
get
:
:
<
_
String
>
(
"
y
"
)
.
unwrap_err
(
)
{
Error
:
:
InvalidColumnType
(
idx
name
ty
)
=
>
{
assert_eq
!
(
idx
1
)
;
assert_eq
!
(
name
"
y
"
)
;
assert_eq
!
(
ty
Type
:
:
Null
)
;
}
e
=
>
{
panic
!
(
"
Unexpected
error
type
:
{
e
:
?
}
"
)
;
}
}
Ok
(
(
)
)
}
#
[
test
]
#
[
cfg
(
feature
=
"
modern_sqlite
"
)
]
fn
test_column_name_reference
(
)
-
>
Result
<
(
)
>
{
let
db
=
Connection
:
:
open_in_memory
(
)
?
;
db
.
execute_batch
(
"
CREATE
TABLE
y
(
x
)
;
"
)
?
;
let
stmt
=
db
.
prepare
(
"
SELECT
x
FROM
y
;
"
)
?
;
let
column_name
=
stmt
.
column_name
(
0
)
?
;
assert_eq
!
(
"
x
"
column_name
)
;
db
.
execute_batch
(
"
ALTER
TABLE
y
RENAME
COLUMN
x
TO
z
;
"
)
?
;
let
same_column_name
=
stmt
.
column_name
(
0
)
?
;
assert_eq
!
(
same_column_name
column_name
)
;
Ok
(
(
)
)
}
}
