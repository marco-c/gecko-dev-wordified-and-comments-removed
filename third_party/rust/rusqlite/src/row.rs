use
fallible_iterator
:
:
FallibleIterator
;
use
fallible_streaming_iterator
:
:
FallibleStreamingIterator
;
use
std
:
:
convert
;
use
super
:
:
{
Error
Result
Statement
}
;
use
crate
:
:
types
:
:
{
FromSql
FromSqlError
ValueRef
}
;
pub
struct
Rows
<
'
stmt
>
{
pub
(
crate
)
stmt
:
Option
<
&
'
stmt
Statement
<
'
stmt
>
>
row
:
Option
<
Row
<
'
stmt
>
>
}
impl
<
'
stmt
>
Rows
<
'
stmt
>
{
fn
reset
(
&
mut
self
)
{
if
let
Some
(
stmt
)
=
self
.
stmt
.
take
(
)
{
stmt
.
reset
(
)
;
}
}
#
[
allow
(
clippy
:
:
should_implement_trait
)
]
pub
fn
next
(
&
mut
self
)
-
>
Result
<
Option
<
&
Row
<
'
stmt
>
>
>
{
self
.
advance
(
)
?
;
Ok
(
(
*
self
)
.
get
(
)
)
}
pub
fn
map
<
F
B
>
(
self
f
:
F
)
-
>
Map
<
'
stmt
F
>
where
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
B
>
{
Map
{
rows
:
self
f
}
}
pub
fn
mapped
<
F
B
>
(
self
f
:
F
)
-
>
MappedRows
<
'
stmt
F
>
where
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
B
>
{
MappedRows
{
rows
:
self
map
:
f
}
}
pub
fn
and_then
<
F
T
E
>
(
self
f
:
F
)
-
>
AndThenRows
<
'
stmt
F
>
where
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
T
E
>
{
AndThenRows
{
rows
:
self
map
:
f
}
}
}
impl
<
'
stmt
>
Rows
<
'
stmt
>
{
pub
(
crate
)
fn
new
(
stmt
:
&
'
stmt
Statement
<
'
stmt
>
)
-
>
Rows
<
'
stmt
>
{
Rows
{
stmt
:
Some
(
stmt
)
row
:
None
}
}
pub
(
crate
)
fn
get_expected_row
(
&
mut
self
)
-
>
Result
<
&
Row
<
'
stmt
>
>
{
match
self
.
next
(
)
?
{
Some
(
row
)
=
>
Ok
(
row
)
None
=
>
Err
(
Error
:
:
QueryReturnedNoRows
)
}
}
}
impl
Drop
for
Rows
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
self
.
reset
(
)
;
}
}
pub
struct
Map
<
'
stmt
F
>
{
rows
:
Rows
<
'
stmt
>
f
:
F
}
impl
<
F
B
>
FallibleIterator
for
Map
<
'
_
F
>
where
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
B
>
{
type
Error
=
Error
;
type
Item
=
B
;
fn
next
(
&
mut
self
)
-
>
Result
<
Option
<
B
>
>
{
match
self
.
rows
.
next
(
)
?
{
Some
(
v
)
=
>
Ok
(
Some
(
(
self
.
f
)
(
v
)
?
)
)
None
=
>
Ok
(
None
)
}
}
}
pub
struct
MappedRows
<
'
stmt
F
>
{
rows
:
Rows
<
'
stmt
>
map
:
F
}
impl
<
'
stmt
T
F
>
MappedRows
<
'
stmt
F
>
where
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
T
>
{
pub
(
crate
)
fn
new
(
rows
:
Rows
<
'
stmt
>
f
:
F
)
-
>
MappedRows
<
'
stmt
F
>
{
MappedRows
{
rows
map
:
f
}
}
}
impl
<
T
F
>
Iterator
for
MappedRows
<
'
_
F
>
where
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
T
>
{
type
Item
=
Result
<
T
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Result
<
T
>
>
{
let
map
=
&
mut
self
.
map
;
self
.
rows
.
next
(
)
.
transpose
(
)
.
map
(
|
row_result
|
row_result
.
and_then
(
|
row
|
(
map
)
(
&
row
)
)
)
}
}
pub
struct
AndThenRows
<
'
stmt
F
>
{
rows
:
Rows
<
'
stmt
>
map
:
F
}
impl
<
'
stmt
T
E
F
>
AndThenRows
<
'
stmt
F
>
where
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
T
E
>
{
pub
(
crate
)
fn
new
(
rows
:
Rows
<
'
stmt
>
f
:
F
)
-
>
AndThenRows
<
'
stmt
F
>
{
AndThenRows
{
rows
map
:
f
}
}
}
impl
<
T
E
F
>
Iterator
for
AndThenRows
<
'
_
F
>
where
E
:
convert
:
:
From
<
Error
>
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
T
E
>
{
type
Item
=
Result
<
T
E
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
map
=
&
mut
self
.
map
;
self
.
rows
.
next
(
)
.
transpose
(
)
.
map
(
|
row_result
|
row_result
.
map_err
(
E
:
:
from
)
.
and_then
(
|
row
|
(
map
)
(
&
row
)
)
)
}
}
impl
<
'
stmt
>
FallibleStreamingIterator
for
Rows
<
'
stmt
>
{
type
Error
=
Error
;
type
Item
=
Row
<
'
stmt
>
;
fn
advance
(
&
mut
self
)
-
>
Result
<
(
)
>
{
match
self
.
stmt
{
Some
(
ref
stmt
)
=
>
match
stmt
.
step
(
)
{
Ok
(
true
)
=
>
{
self
.
row
=
Some
(
Row
{
stmt
}
)
;
Ok
(
(
)
)
}
Ok
(
false
)
=
>
{
self
.
reset
(
)
;
self
.
row
=
None
;
Ok
(
(
)
)
}
Err
(
e
)
=
>
{
self
.
reset
(
)
;
self
.
row
=
None
;
Err
(
e
)
}
}
None
=
>
{
self
.
row
=
None
;
Ok
(
(
)
)
}
}
}
fn
get
(
&
self
)
-
>
Option
<
&
Row
<
'
stmt
>
>
{
self
.
row
.
as_ref
(
)
}
}
pub
struct
Row
<
'
stmt
>
{
pub
(
crate
)
stmt
:
&
'
stmt
Statement
<
'
stmt
>
}
impl
<
'
stmt
>
Row
<
'
stmt
>
{
pub
fn
get_unwrap
<
I
:
RowIndex
T
:
FromSql
>
(
&
self
idx
:
I
)
-
>
T
{
self
.
get
(
idx
)
.
unwrap
(
)
}
pub
fn
get
<
I
:
RowIndex
T
:
FromSql
>
(
&
self
idx
:
I
)
-
>
Result
<
T
>
{
let
idx
=
idx
.
idx
(
self
.
stmt
)
?
;
let
value
=
self
.
stmt
.
value_ref
(
idx
)
;
FromSql
:
:
column_result
(
value
)
.
map_err
(
|
err
|
match
err
{
FromSqlError
:
:
InvalidType
=
>
Error
:
:
InvalidColumnType
(
idx
self
.
stmt
.
column_name_unwrap
(
idx
)
.
into
(
)
value
.
data_type
(
)
)
FromSqlError
:
:
OutOfRange
(
i
)
=
>
Error
:
:
IntegralValueOutOfRange
(
idx
i
)
FromSqlError
:
:
Other
(
err
)
=
>
{
Error
:
:
FromSqlConversionFailure
(
idx
as
usize
value
.
data_type
(
)
err
)
}
#
[
cfg
(
feature
=
"
i128_blob
"
)
]
FromSqlError
:
:
InvalidI128Size
(
_
)
=
>
Error
:
:
InvalidColumnType
(
idx
self
.
stmt
.
column_name_unwrap
(
idx
)
.
into
(
)
value
.
data_type
(
)
)
#
[
cfg
(
feature
=
"
uuid
"
)
]
FromSqlError
:
:
InvalidUuidSize
(
_
)
=
>
Error
:
:
InvalidColumnType
(
idx
self
.
stmt
.
column_name_unwrap
(
idx
)
.
into
(
)
value
.
data_type
(
)
)
}
)
}
pub
fn
get_raw_checked
<
I
:
RowIndex
>
(
&
self
idx
:
I
)
-
>
Result
<
ValueRef
<
'
_
>
>
{
let
idx
=
idx
.
idx
(
self
.
stmt
)
?
;
let
val_ref
=
self
.
stmt
.
value_ref
(
idx
)
;
Ok
(
val_ref
)
}
pub
fn
get_raw
<
I
:
RowIndex
>
(
&
self
idx
:
I
)
-
>
ValueRef
<
'
_
>
{
self
.
get_raw_checked
(
idx
)
.
unwrap
(
)
}
}
pub
trait
RowIndex
{
fn
idx
(
&
self
stmt
:
&
Statement
<
'
_
>
)
-
>
Result
<
usize
>
;
}
impl
RowIndex
for
usize
{
#
[
inline
]
fn
idx
(
&
self
stmt
:
&
Statement
<
'
_
>
)
-
>
Result
<
usize
>
{
if
*
self
>
=
stmt
.
column_count
(
)
{
Err
(
Error
:
:
InvalidColumnIndex
(
*
self
)
)
}
else
{
Ok
(
*
self
)
}
}
}
impl
RowIndex
for
&
'
_
str
{
#
[
inline
]
fn
idx
(
&
self
stmt
:
&
Statement
<
'
_
>
)
-
>
Result
<
usize
>
{
stmt
.
column_index
(
*
self
)
}
}
