use
super
:
:
Blob
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
mem
:
:
MaybeUninit
;
use
std
:
:
slice
:
:
from_raw_parts_mut
;
use
crate
:
:
ffi
;
use
crate
:
:
{
Error
Result
}
;
impl
<
'
conn
>
Blob
<
'
conn
>
{
#
[
inline
]
pub
fn
write_at
(
&
mut
self
buf
:
&
[
u8
]
write_start
:
usize
)
-
>
Result
<
(
)
>
{
let
len
=
self
.
len
(
)
;
if
buf
.
len
(
)
.
saturating_add
(
write_start
)
>
len
{
return
Err
(
Error
:
:
BlobSizeError
)
;
}
debug_assert
!
(
i32
:
:
try_from
(
write_start
)
.
is_ok
(
)
&
&
i32
:
:
try_from
(
buf
.
len
(
)
)
.
is_ok
(
)
)
;
unsafe
{
check
!
(
ffi
:
:
sqlite3_blob_write
(
self
.
blob
buf
.
as_ptr
(
)
as
*
const
_
buf
.
len
(
)
as
i32
write_start
as
i32
)
)
;
}
Ok
(
(
)
)
}
#
[
inline
]
pub
fn
write_all_at
(
&
mut
self
buf
:
&
[
u8
]
write_start
:
usize
)
-
>
Result
<
(
)
>
{
self
.
write_at
(
buf
write_start
)
}
#
[
inline
]
pub
fn
read_at
(
&
self
buf
:
&
mut
[
u8
]
read_start
:
usize
)
-
>
Result
<
usize
>
{
let
as_uninit
:
&
mut
[
MaybeUninit
<
u8
>
]
=
unsafe
{
from_raw_parts_mut
(
buf
.
as_mut_ptr
(
)
as
*
mut
_
buf
.
len
(
)
)
}
;
self
.
raw_read_at
(
as_uninit
read_start
)
.
map
(
|
s
|
s
.
len
(
)
)
}
#
[
inline
]
pub
fn
raw_read_at
<
'
a
>
(
&
self
buf
:
&
'
a
mut
[
MaybeUninit
<
u8
>
]
read_start
:
usize
)
-
>
Result
<
&
'
a
mut
[
u8
]
>
{
let
len
=
self
.
len
(
)
;
let
read_len
=
match
len
.
checked_sub
(
read_start
)
{
None
|
Some
(
0
)
=
>
0
Some
(
v
)
=
>
v
.
min
(
buf
.
len
(
)
)
}
;
if
read_len
=
=
0
{
let
empty
=
unsafe
{
from_raw_parts_mut
(
buf
.
as_mut_ptr
(
)
as
*
mut
u8
0
)
}
;
return
Ok
(
empty
)
;
}
debug_assert
!
(
i32
:
:
try_from
(
read_start
)
.
is_ok
(
)
)
;
debug_assert
!
(
read_start
+
read_len
<
=
len
)
;
debug_assert
!
(
buf
.
len
(
)
>
=
read_len
)
;
debug_assert
!
(
i32
:
:
try_from
(
buf
.
len
(
)
)
.
is_ok
(
)
)
;
debug_assert
!
(
i32
:
:
try_from
(
read_len
)
.
is_ok
(
)
)
;
unsafe
{
check
!
(
ffi
:
:
sqlite3_blob_read
(
self
.
blob
buf
.
as_mut_ptr
(
)
as
*
mut
_
read_len
as
i32
read_start
as
i32
)
)
;
Ok
(
from_raw_parts_mut
(
buf
.
as_mut_ptr
(
)
as
*
mut
u8
read_len
)
)
}
}
#
[
inline
]
pub
fn
read_at_exact
(
&
self
buf
:
&
mut
[
u8
]
read_start
:
usize
)
-
>
Result
<
(
)
>
{
let
n
=
self
.
read_at
(
buf
read_start
)
?
;
if
n
!
=
buf
.
len
(
)
{
Err
(
Error
:
:
BlobSizeError
)
}
else
{
Ok
(
(
)
)
}
}
#
[
inline
]
pub
fn
raw_read_at_exact
<
'
a
>
(
&
self
buf
:
&
'
a
mut
[
MaybeUninit
<
u8
>
]
read_start
:
usize
)
-
>
Result
<
&
'
a
mut
[
u8
]
>
{
let
buflen
=
buf
.
len
(
)
;
let
initted
=
self
.
raw_read_at
(
buf
read_start
)
?
;
if
initted
.
len
(
)
!
=
buflen
{
Err
(
Error
:
:
BlobSizeError
)
}
else
{
Ok
(
initted
)
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
crate
:
:
{
Connection
DatabaseName
NO_PARAMS
}
;
use
std
:
:
io
:
:
Seek
as
_
;
#
[
test
]
fn
test_pos_io
(
)
{
let
db
=
Connection
:
:
open_in_memory
(
)
.
unwrap
(
)
;
db
.
execute_batch
(
"
CREATE
TABLE
test_table
(
content
BLOB
)
;
"
)
.
unwrap
(
)
;
db
.
execute
(
"
INSERT
INTO
test_table
(
content
)
VALUES
(
ZEROBLOB
(
10
)
)
"
NO_PARAMS
)
.
unwrap
(
)
;
let
rowid
=
db
.
last_insert_rowid
(
)
;
let
mut
blob
=
db
.
blob_open
(
DatabaseName
:
:
Main
"
test_table
"
"
content
"
rowid
false
)
.
unwrap
(
)
;
blob
.
seek
(
std
:
:
io
:
:
SeekFrom
:
:
Start
(
1
)
)
.
unwrap
(
)
;
let
one2ten
:
[
u8
;
10
]
=
[
1u8
2
3
4
5
6
7
8
9
10
]
;
blob
.
write_at
(
&
one2ten
0
)
.
unwrap
(
)
;
let
mut
s
=
[
0u8
;
10
]
;
blob
.
read_at_exact
(
&
mut
s
0
)
.
unwrap
(
)
;
assert_eq
!
(
&
s
&
one2ten
"
write
should
go
through
"
)
;
assert
!
(
blob
.
read_at_exact
(
&
mut
s
1
)
.
is_err
(
)
)
;
blob
.
read_at_exact
(
&
mut
s
0
)
.
unwrap
(
)
;
assert_eq
!
(
&
s
&
one2ten
"
should
be
unchanged
"
)
;
let
mut
fives
=
[
0u8
;
5
]
;
blob
.
read_at_exact
(
&
mut
fives
0
)
.
unwrap
(
)
;
assert_eq
!
(
&
fives
&
[
1u8
2
3
4
5
]
)
;
blob
.
read_at_exact
(
&
mut
fives
5
)
.
unwrap
(
)
;
assert_eq
!
(
&
fives
&
[
6u8
7
8
9
10
]
)
;
assert
!
(
blob
.
read_at_exact
(
&
mut
fives
7
)
.
is_err
(
)
)
;
assert
!
(
blob
.
read_at_exact
(
&
mut
fives
12
)
.
is_err
(
)
)
;
assert
!
(
blob
.
read_at_exact
(
&
mut
fives
10
)
.
is_err
(
)
)
;
assert
!
(
blob
.
read_at_exact
(
&
mut
fives
i32
:
:
MAX
as
usize
)
.
is_err
(
)
)
;
assert
!
(
blob
.
read_at_exact
(
&
mut
fives
i32
:
:
MAX
as
usize
+
1
)
.
is_err
(
)
)
;
blob
.
read_at_exact
(
&
mut
[
]
10
)
.
unwrap
(
)
;
blob
.
read_at_exact
(
&
mut
[
]
0
)
.
unwrap
(
)
;
blob
.
read_at_exact
(
&
mut
[
]
5
)
.
unwrap
(
)
;
blob
.
write_all_at
(
&
[
16
17
18
19
20
]
5
)
.
unwrap
(
)
;
blob
.
read_at_exact
(
&
mut
s
0
)
.
unwrap
(
)
;
assert_eq
!
(
&
s
&
[
1u8
2
3
4
5
16
17
18
19
20
]
)
;
assert
!
(
blob
.
write_at
(
&
[
100
99
98
97
96
]
6
)
.
is_err
(
)
)
;
assert
!
(
blob
.
write_at
(
&
[
100
99
98
97
96
]
i32
:
:
MAX
as
usize
)
.
is_err
(
)
)
;
assert
!
(
blob
.
write_at
(
&
[
100
99
98
97
96
]
i32
:
:
MAX
as
usize
+
1
)
.
is_err
(
)
)
;
blob
.
read_at_exact
(
&
mut
s
0
)
.
unwrap
(
)
;
assert_eq
!
(
&
s
&
[
1u8
2
3
4
5
16
17
18
19
20
]
)
;
let
mut
s2
:
[
std
:
:
mem
:
:
MaybeUninit
<
u8
>
;
10
]
=
[
std
:
:
mem
:
:
MaybeUninit
:
:
uninit
(
)
;
10
]
;
{
let
read
=
blob
.
raw_read_at_exact
(
&
mut
s2
0
)
.
unwrap
(
)
;
assert_eq
!
(
read
&
s
)
;
assert
!
(
std
:
:
ptr
:
:
eq
(
read
.
as_ptr
(
)
s2
.
as_ptr
(
)
.
cast
(
)
)
)
;
}
let
mut
empty
=
[
]
;
assert
!
(
std
:
:
ptr
:
:
eq
(
blob
.
raw_read_at_exact
(
&
mut
empty
0
)
.
unwrap
(
)
.
as_ptr
(
)
empty
.
as_ptr
(
)
.
cast
(
)
)
)
;
assert
!
(
blob
.
raw_read_at_exact
(
&
mut
s2
5
)
.
is_err
(
)
)
;
let
end_pos
=
blob
.
seek
(
std
:
:
io
:
:
SeekFrom
:
:
Current
(
0
)
)
.
unwrap
(
)
;
assert_eq
!
(
end_pos
1
)
;
}
}
