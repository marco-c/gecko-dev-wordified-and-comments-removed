#
ifndef
SPIRV_CROSS_BARRIER_HPP
#
define
SPIRV_CROSS_BARRIER_HPP
#
include
<
atomic
>
#
include
<
thread
>
namespace
spirv_cross
{
class
Barrier
{
public
:
Barrier
(
)
{
count
.
store
(
0
)
;
iteration
.
store
(
0
)
;
}
void
set_release_divisor
(
unsigned
divisor
)
{
this
-
>
divisor
=
divisor
;
}
static
inline
void
memoryBarrier
(
)
{
std
:
:
atomic_thread_fence
(
std
:
:
memory_order_seq_cst
)
;
}
void
reset_counter
(
)
{
count
.
store
(
0
)
;
iteration
.
store
(
0
)
;
}
void
wait
(
)
{
unsigned
target_iteration
=
iteration
.
load
(
std
:
:
memory_order_relaxed
)
+
1
;
unsigned
target_count
=
divisor
*
target_iteration
;
unsigned
c
=
count
.
fetch_add
(
1u
std
:
:
memory_order_relaxed
)
;
if
(
c
+
1
=
=
target_count
)
{
iteration
.
store
(
target_iteration
std
:
:
memory_order_relaxed
)
;
}
else
{
while
(
iteration
.
load
(
std
:
:
memory_order_relaxed
)
!
=
target_iteration
)
std
:
:
this_thread
:
:
yield
(
)
;
}
}
private
:
unsigned
divisor
=
1
;
std
:
:
atomic
<
unsigned
>
count
;
std
:
:
atomic
<
unsigned
>
iteration
;
}
;
}
#
endif
