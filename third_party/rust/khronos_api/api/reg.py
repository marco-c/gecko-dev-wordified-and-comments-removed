import
io
os
re
string
sys
from
lxml
import
etree
def
write
(
*
args
*
*
kwargs
)
:
    
file
=
kwargs
.
pop
(
'
file
'
sys
.
stdout
)
    
end
=
kwargs
.
pop
(
'
end
'
'
\
n
'
)
    
file
.
write
(
'
'
.
join
(
[
str
(
arg
)
for
arg
in
args
]
)
)
    
file
.
write
(
end
)
def
noneStr
(
str
)
:
    
if
(
str
)
:
        
return
str
    
else
:
        
return
"
"
def
matchAPIProfile
(
api
profile
elem
)
:
    
"
"
"
Match
a
requested
API
&
profile
name
to
a
api
&
profile
attributes
of
an
Element
"
"
"
    
match
=
True
    
if
(
'
api
'
in
elem
.
attrib
)
:
        
if
(
api
=
=
None
)
:
            
raise
UserWarning
(
"
No
API
requested
but
'
api
'
attribute
is
present
with
value
'
"
+
                              
elem
.
get
(
'
api
'
)
+
"
'
"
)
        
elif
(
api
!
=
elem
.
get
(
'
api
'
)
)
:
            
return
False
    
if
(
'
profile
'
in
elem
.
attrib
)
:
        
if
(
profile
=
=
None
)
:
            
raise
UserWarning
(
"
No
profile
requested
but
'
profile
'
attribute
is
present
with
value
'
"
+
                
elem
.
get
(
'
profile
'
)
+
"
'
"
)
        
elif
(
profile
!
=
elem
.
get
(
'
profile
'
)
)
:
            
return
False
    
return
True
class
BaseInfo
:
    
"
"
"
Represents
the
state
of
a
registry
feature
used
during
API
generation
"
"
"
    
def
__init__
(
self
elem
)
:
        
self
.
required
=
False
        
self
.
declared
=
False
        
self
.
elem
=
elem
    
def
resetState
(
self
)
:
        
self
.
required
=
False
        
self
.
declared
=
False
class
TypeInfo
(
BaseInfo
)
:
    
"
"
"
Represents
the
state
of
a
registry
type
"
"
"
    
def
__init__
(
self
elem
)
:
        
BaseInfo
.
__init__
(
self
elem
)
class
GroupInfo
(
BaseInfo
)
:
    
"
"
"
Represents
the
state
of
a
registry
enumerant
group
"
"
"
    
def
__init__
(
self
elem
)
:
        
BaseInfo
.
__init__
(
self
elem
)
        
self
.
enums
=
{
}
class
EnumInfo
(
BaseInfo
)
:
    
"
"
"
Represents
the
state
of
a
registry
enum
"
"
"
    
def
__init__
(
self
elem
)
:
        
BaseInfo
.
__init__
(
self
elem
)
        
self
.
type
=
elem
.
get
(
'
type
'
)
        
if
(
self
.
type
=
=
None
)
:
            
self
.
type
=
'
'
class
CmdInfo
(
BaseInfo
)
:
    
"
"
"
Represents
the
state
of
a
registry
command
"
"
"
    
def
__init__
(
self
elem
)
:
        
BaseInfo
.
__init__
(
self
elem
)
        
self
.
glxtype
=
None
        
self
.
glxopcode
=
None
        
self
.
glxequiv
=
None
        
self
.
vecequiv
=
None
class
FeatureInfo
(
BaseInfo
)
:
    
"
"
"
Represents
the
state
of
an
API
feature
(
version
/
extension
)
"
"
"
    
def
__init__
(
self
elem
)
:
        
BaseInfo
.
__init__
(
self
elem
)
        
self
.
name
=
elem
.
get
(
'
name
'
)
        
if
(
elem
.
tag
=
=
'
feature
'
)
:
            
self
.
category
=
'
VERSION
'
            
self
.
number
=
elem
.
get
(
'
number
'
)
        
else
:
            
self
.
category
=
self
.
name
.
split
(
'
_
'
2
)
[
1
]
            
self
.
number
=
"
0
"
        
self
.
emit
=
False
def
regSortCategoryKey
(
feature
)
:
    
if
(
feature
.
elem
.
tag
=
=
'
feature
'
)
:
        
return
0
    
elif
(
feature
.
category
=
=
'
ARB
'
or
          
feature
.
category
=
=
'
KHR
'
or
          
feature
.
category
=
=
'
OES
'
)
:
        
return
1
    
else
:
        
return
2
def
regSortNameKey
(
feature
)
:
    
return
feature
.
name
def
regSortNumberKey
(
feature
)
:
    
return
feature
.
number
def
regSortFeatures
(
featureList
)
:
    
featureList
.
sort
(
key
=
regSortNumberKey
)
    
featureList
.
sort
(
key
=
regSortNameKey
)
    
featureList
.
sort
(
key
=
regSortCategoryKey
)
class
GeneratorOptions
:
    
"
"
"
Represents
options
during
header
production
from
an
API
registry
"
"
"
    
def
__init__
(
self
                 
filename
=
None
                 
apiname
=
None
                 
profile
=
None
                 
versions
=
'
.
*
'
                 
emitversions
=
'
.
*
'
                 
defaultExtensions
=
None
                 
addExtensions
=
None
                 
removeExtensions
=
None
                 
sortProcedure
=
regSortFeatures
)
:
        
self
.
filename
=
filename
        
self
.
apiname
=
apiname
        
self
.
profile
=
profile
        
self
.
versions
=
self
.
emptyRegex
(
versions
)
        
self
.
emitversions
=
self
.
emptyRegex
(
emitversions
)
        
self
.
defaultExtensions
=
defaultExtensions
        
self
.
addExtensions
=
self
.
emptyRegex
(
addExtensions
)
        
self
.
removeExtensions
=
self
.
emptyRegex
(
removeExtensions
)
        
self
.
sortProcedure
=
sortProcedure
    
def
emptyRegex
(
self
pat
)
:
        
if
(
pat
=
=
None
or
pat
=
=
'
'
)
:
            
return
'
_nomatch_
^
'
        
else
:
            
return
pat
class
CGeneratorOptions
(
GeneratorOptions
)
:
    
"
"
"
Represents
options
during
C
header
production
from
an
API
registry
"
"
"
    
def
__init__
(
self
                 
filename
=
None
                 
apiname
=
None
                 
profile
=
None
                 
versions
=
'
.
*
'
                 
emitversions
=
'
.
*
'
                 
defaultExtensions
=
None
                 
addExtensions
=
None
                 
removeExtensions
=
None
                 
sortProcedure
=
regSortFeatures
                 
prefixText
=
"
"
                 
genFuncPointers
=
True
                 
protectFile
=
True
                 
protectFeature
=
True
                 
protectProto
=
True
                 
protectProtoStr
=
True
                 
apicall
=
'
'
                 
apientry
=
'
'
                 
apientryp
=
'
'
)
:
        
GeneratorOptions
.
__init__
(
self
filename
apiname
profile
                                  
versions
emitversions
defaultExtensions
                                  
addExtensions
removeExtensions
sortProcedure
)
        
self
.
prefixText
=
prefixText
        
self
.
genFuncPointers
=
genFuncPointers
        
self
.
protectFile
=
protectFile
        
self
.
protectFeature
=
protectFeature
        
self
.
protectProto
=
protectProto
        
self
.
protectProtoStr
=
protectProtoStr
        
self
.
apicall
=
apicall
        
self
.
apientry
=
apientry
        
self
.
apientryp
=
apientryp
class
OutputGenerator
:
    
"
"
"
Generate
specified
API
interfaces
in
a
specific
style
such
as
a
C
header
"
"
"
    
def
__init__
(
self
                 
errFile
=
sys
.
stderr
                 
warnFile
=
sys
.
stderr
                 
diagFile
=
sys
.
stdout
)
:
        
self
.
outFile
=
None
        
self
.
errFile
=
errFile
        
self
.
warnFile
=
warnFile
        
self
.
diagFile
=
diagFile
        
self
.
featureName
=
None
        
self
.
genOpts
=
None
    
def
logMsg
(
self
level
*
args
)
:
        
"
"
"
Log
a
message
at
the
given
level
.
Can
be
ignored
or
log
to
a
file
"
"
"
        
if
(
level
=
=
'
error
'
)
:
            
strfile
=
io
.
StringIO
(
)
            
write
(
'
ERROR
:
'
*
args
file
=
strfile
)
            
if
(
self
.
errFile
!
=
None
)
:
                
write
(
strfile
.
getvalue
(
)
file
=
self
.
errFile
)
            
raise
UserWarning
(
strfile
.
getvalue
(
)
)
        
elif
(
level
=
=
'
warn
'
)
:
            
if
(
self
.
warnFile
!
=
None
)
:
                
write
(
'
WARNING
:
'
*
args
file
=
self
.
warnFile
)
        
elif
(
level
=
=
'
diag
'
)
:
            
if
(
self
.
diagFile
!
=
None
)
:
                
write
(
'
DIAG
:
'
*
args
file
=
self
.
diagFile
)
        
else
:
            
raise
UserWarning
(
                
'
*
*
*
FATAL
ERROR
in
Generator
.
logMsg
:
unknown
level
:
'
+
level
)
    
def
beginFile
(
self
genOpts
)
:
        
self
.
genOpts
=
genOpts
        
if
(
self
.
genOpts
.
filename
!
=
None
)
:
            
self
.
outFile
=
open
(
self
.
genOpts
.
filename
'
w
'
)
        
else
:
            
self
.
outFile
=
sys
.
stdout
    
def
endFile
(
self
)
:
        
self
.
errFile
and
self
.
errFile
.
flush
(
)
        
self
.
warnFile
and
self
.
warnFile
.
flush
(
)
        
self
.
diagFile
and
self
.
diagFile
.
flush
(
)
        
self
.
outFile
.
flush
(
)
        
if
(
self
.
outFile
!
=
sys
.
stdout
and
self
.
outFile
!
=
sys
.
stderr
)
:
            
self
.
outFile
.
close
(
)
        
self
.
genOpts
=
None
    
def
beginFeature
(
self
interface
emit
)
:
        
self
.
emit
=
emit
        
self
.
featureName
=
interface
.
get
(
'
name
'
)
        
self
.
featureExtraProtect
=
interface
.
get
(
'
protect
'
)
    
def
endFeature
(
self
)
:
        
self
.
featureName
=
None
        
self
.
featureExtraProtect
=
None
    
def
genType
(
self
typeinfo
name
)
:
        
if
(
self
.
featureName
=
=
None
)
:
            
raise
UserWarning
(
'
Attempt
to
generate
type
'
name
                    
'
when
not
in
feature
'
)
    
def
genEnum
(
self
enuminfo
name
)
:
        
if
(
self
.
featureName
=
=
None
)
:
            
raise
UserWarning
(
'
Attempt
to
generate
enum
'
name
                    
'
when
not
in
feature
'
)
    
def
genCmd
(
self
cmd
name
)
:
        
if
(
self
.
featureName
=
=
None
)
:
            
raise
UserWarning
(
'
Attempt
to
generate
command
'
name
                    
'
when
not
in
feature
'
)
class
COutputGenerator
(
OutputGenerator
)
:
    
"
"
"
Generate
specified
API
interfaces
in
a
specific
style
such
as
a
C
header
"
"
"
    
def
__init__
(
self
                 
errFile
=
sys
.
stderr
                 
warnFile
=
sys
.
stderr
                 
diagFile
=
sys
.
stdout
)
:
        
OutputGenerator
.
__init__
(
self
errFile
warnFile
diagFile
)
        
self
.
typeBody
=
'
'
        
self
.
enumBody
=
'
'
        
self
.
cmdBody
=
'
'
    
def
makeCDecls
(
self
cmd
)
:
        
"
"
"
Generate
C
function
pointer
typedef
for
<
command
>
Element
"
"
"
        
proto
=
cmd
.
find
(
'
proto
'
)
        
params
=
cmd
.
findall
(
'
param
'
)
        
pdecl
=
self
.
genOpts
.
apicall
        
tdecl
=
'
typedef
'
        
pdecl
+
=
noneStr
(
proto
.
text
)
        
tdecl
+
=
noneStr
(
proto
.
text
)
        
for
elem
in
proto
:
            
text
=
noneStr
(
elem
.
text
)
            
tail
=
noneStr
(
elem
.
tail
)
            
if
(
elem
.
tag
=
=
'
name
'
)
:
                
pdecl
+
=
self
.
genOpts
.
apientry
+
text
+
tail
                
tdecl
+
=
'
(
'
+
self
.
genOpts
.
apientryp
+
'
PFN
'
+
text
.
upper
(
)
+
'
PROC
'
+
tail
+
'
)
'
            
else
:
                
pdecl
+
=
text
+
tail
                
tdecl
+
=
text
+
tail
        
n
=
len
(
params
)
        
paramdecl
=
'
(
'
        
if
n
>
0
:
            
for
i
in
range
(
0
n
)
:
                
paramdecl
+
=
'
'
.
join
(
[
t
for
t
in
params
[
i
]
.
itertext
(
)
]
)
                
if
(
i
<
n
-
1
)
:
                    
paramdecl
+
=
'
'
        
else
:
            
paramdecl
+
=
'
void
'
        
paramdecl
+
=
"
)
;
\
n
"
;
        
return
[
pdecl
+
paramdecl
tdecl
+
paramdecl
]
    
def
newline
(
self
)
:
        
write
(
'
'
file
=
self
.
outFile
)
    
def
beginFile
(
self
genOpts
)
:
        
OutputGenerator
.
beginFile
(
self
genOpts
)
        
if
(
genOpts
.
protectFile
and
self
.
genOpts
.
filename
)
:
            
headerSym
=
'
__
'
+
re
.
sub
(
'
\
.
h
'
'
_h_
'
os
.
path
.
basename
(
self
.
genOpts
.
filename
)
)
            
write
(
'
#
ifndef
'
headerSym
file
=
self
.
outFile
)
            
write
(
'
#
define
'
headerSym
'
1
'
file
=
self
.
outFile
)
            
self
.
newline
(
)
        
write
(
'
#
ifdef
__cplusplus
'
file
=
self
.
outFile
)
        
write
(
'
extern
"
C
"
{
'
file
=
self
.
outFile
)
        
write
(
'
#
endif
'
file
=
self
.
outFile
)
        
self
.
newline
(
)
        
if
(
genOpts
.
prefixText
)
:
            
for
s
in
genOpts
.
prefixText
:
                
write
(
s
file
=
self
.
outFile
)
        
write
(
'
/
*
Generated
C
header
for
:
'
file
=
self
.
outFile
)
        
write
(
'
*
API
:
'
genOpts
.
apiname
file
=
self
.
outFile
)
        
if
(
genOpts
.
profile
)
:
            
write
(
'
*
Profile
:
'
genOpts
.
profile
file
=
self
.
outFile
)
        
write
(
'
*
Versions
considered
:
'
genOpts
.
versions
file
=
self
.
outFile
)
        
write
(
'
*
Versions
emitted
:
'
genOpts
.
emitversions
file
=
self
.
outFile
)
        
write
(
'
*
Default
extensions
included
:
'
genOpts
.
defaultExtensions
file
=
self
.
outFile
)
        
write
(
'
*
Additional
extensions
included
:
'
genOpts
.
addExtensions
file
=
self
.
outFile
)
        
write
(
'
*
Extensions
removed
:
'
genOpts
.
removeExtensions
file
=
self
.
outFile
)
        
write
(
'
*
/
'
file
=
self
.
outFile
)
    
def
endFile
(
self
)
:
        
self
.
newline
(
)
        
write
(
'
#
ifdef
__cplusplus
'
file
=
self
.
outFile
)
        
write
(
'
}
'
file
=
self
.
outFile
)
        
write
(
'
#
endif
'
file
=
self
.
outFile
)
        
if
(
self
.
genOpts
.
protectFile
and
self
.
genOpts
.
filename
)
:
            
self
.
newline
(
)
            
write
(
'
#
endif
'
file
=
self
.
outFile
)
        
OutputGenerator
.
endFile
(
self
)
    
def
beginFeature
(
self
interface
emit
)
:
        
OutputGenerator
.
beginFeature
(
self
interface
emit
)
        
self
.
typeBody
=
'
'
        
self
.
enumBody
=
'
'
        
self
.
cmdPointerBody
=
'
'
        
self
.
cmdBody
=
'
'
    
def
endFeature
(
self
)
:
        
if
(
self
.
emit
)
:
            
self
.
newline
(
)
            
if
(
self
.
genOpts
.
protectFeature
)
:
                
write
(
'
#
ifndef
'
self
.
featureName
file
=
self
.
outFile
)
            
write
(
'
#
define
'
self
.
featureName
'
1
'
file
=
self
.
outFile
)
            
if
(
self
.
typeBody
!
=
'
'
)
:
                
write
(
self
.
typeBody
end
=
'
'
file
=
self
.
outFile
)
            
if
(
self
.
featureExtraProtect
!
=
None
)
:
                
write
(
'
#
ifdef
'
self
.
featureExtraProtect
file
=
self
.
outFile
)
            
if
(
self
.
enumBody
!
=
'
'
)
:
                
write
(
self
.
enumBody
end
=
'
'
file
=
self
.
outFile
)
            
if
(
self
.
genOpts
.
genFuncPointers
and
self
.
cmdPointerBody
!
=
'
'
)
:
                
write
(
self
.
cmdPointerBody
end
=
'
'
file
=
self
.
outFile
)
            
if
(
self
.
cmdBody
!
=
'
'
)
:
                
if
(
self
.
genOpts
.
protectProto
)
:
                    
write
(
'
#
ifdef
'
self
.
genOpts
.
protectProtoStr
file
=
self
.
outFile
)
                
write
(
self
.
cmdBody
end
=
'
'
file
=
self
.
outFile
)
                
if
(
self
.
genOpts
.
protectProto
)
:
                    
write
(
'
#
endif
'
file
=
self
.
outFile
)
            
if
(
self
.
featureExtraProtect
!
=
None
)
:
                
write
(
'
#
endif
/
*
'
self
.
featureExtraProtect
'
*
/
'
file
=
self
.
outFile
)
            
if
(
self
.
genOpts
.
protectFeature
)
:
                
write
(
'
#
endif
/
*
'
self
.
featureName
'
*
/
'
file
=
self
.
outFile
)
        
OutputGenerator
.
endFeature
(
self
)
    
def
genType
(
self
typeinfo
name
)
:
        
OutputGenerator
.
genType
(
self
typeinfo
name
)
        
typeElem
=
typeinfo
.
elem
        
s
=
noneStr
(
typeElem
.
text
)
        
for
elem
in
typeElem
:
            
if
(
elem
.
tag
=
=
'
apientry
'
)
:
                
s
+
=
self
.
genOpts
.
apientry
+
noneStr
(
elem
.
tail
)
            
else
:
                
s
+
=
noneStr
(
elem
.
text
)
+
noneStr
(
elem
.
tail
)
        
if
(
len
(
s
)
>
0
)
:
            
self
.
typeBody
+
=
s
+
"
\
n
"
    
def
genEnum
(
self
enuminfo
name
)
:
        
OutputGenerator
.
genEnum
(
self
enuminfo
name
)
        
self
.
enumBody
+
=
'
#
define
'
+
name
.
ljust
(
33
)
+
'
'
+
enuminfo
.
elem
.
get
(
'
value
'
)
        
t
=
enuminfo
.
elem
.
get
(
'
type
'
)
        
if
(
t
!
=
'
'
and
t
!
=
'
i
'
)
:
            
self
.
enumBody
+
=
enuminfo
.
type
        
self
.
enumBody
+
=
"
\
n
"
    
def
genCmd
(
self
cmdinfo
name
)
:
        
OutputGenerator
.
genCmd
(
self
cmdinfo
name
)
        
decls
=
self
.
makeCDecls
(
cmdinfo
.
elem
)
        
self
.
cmdBody
+
=
decls
[
0
]
        
if
(
self
.
genOpts
.
genFuncPointers
)
:
            
self
.
cmdPointerBody
+
=
decls
[
1
]
class
Registry
:
    
"
"
"
Represents
an
API
registry
loaded
from
XML
"
"
"
    
def
__init__
(
self
)
:
        
self
.
tree
=
None
        
self
.
typedict
=
{
}
        
self
.
groupdict
=
{
}
        
self
.
enumdict
=
{
}
        
self
.
cmddict
=
{
}
        
self
.
apidict
=
{
}
        
self
.
extensions
=
[
]
        
self
.
extdict
=
{
}
        
self
.
gen
=
OutputGenerator
(
)
        
self
.
genOpts
=
None
        
self
.
emitFeatures
=
False
    
def
loadElementTree
(
self
tree
)
:
        
"
"
"
Load
ElementTree
into
a
Registry
object
and
parse
it
"
"
"
        
self
.
tree
=
tree
        
self
.
parseTree
(
)
    
def
loadFile
(
self
file
)
:
        
"
"
"
Load
an
API
registry
XML
file
into
a
Registry
object
and
parse
it
"
"
"
        
self
.
tree
=
etree
.
parse
(
file
)
        
self
.
parseTree
(
)
    
def
setGenerator
(
self
gen
)
:
        
"
"
"
Specify
output
generator
object
.
None
restores
the
default
generator
"
"
"
        
self
.
gen
=
gen
    
def
addElementInfo
(
self
elem
info
infoName
dictionary
)
:
        
if
(
'
api
'
in
elem
.
attrib
)
:
            
key
=
(
elem
.
get
(
'
name
'
)
elem
.
get
(
'
api
'
)
)
        
else
:
            
key
=
elem
.
get
(
'
name
'
)
        
if
key
in
dictionary
:
            
self
.
gen
.
logMsg
(
'
warn
'
'
*
*
*
Attempt
to
redefine
'
                            
infoName
'
with
key
:
'
key
)
        
else
:
            
dictionary
[
key
]
=
info
    
def
lookupElementInfo
(
self
fname
dictionary
)
:
        
key
=
(
fname
self
.
genOpts
.
apiname
)
        
if
(
key
in
dictionary
)
:
            
return
dictionary
[
key
]
        
elif
(
fname
in
dictionary
)
:
            
return
dictionary
[
fname
]
        
else
:
            
return
None
    
def
parseTree
(
self
)
:
        
"
"
"
Parse
the
registry
Element
once
created
"
"
"
        
self
.
reg
=
self
.
tree
.
getroot
(
)
        
self
.
typedict
=
{
}
        
for
type
in
self
.
reg
.
findall
(
'
types
/
type
'
)
:
            
if
(
type
.
get
(
'
name
'
)
=
=
None
)
:
                
type
.
attrib
[
'
name
'
]
=
type
.
find
(
'
name
'
)
.
text
            
self
.
addElementInfo
(
type
TypeInfo
(
type
)
'
type
'
self
.
typedict
)
        
self
.
groupdict
=
{
}
        
for
group
in
self
.
reg
.
findall
(
'
groups
/
group
'
)
:
            
self
.
addElementInfo
(
group
GroupInfo
(
group
)
'
group
'
self
.
groupdict
)
        
self
.
enumdict
=
{
}
        
for
enum
in
self
.
reg
.
findall
(
'
enums
/
enum
'
)
:
            
self
.
addElementInfo
(
enum
EnumInfo
(
enum
)
'
enum
'
self
.
enumdict
)
        
self
.
cmddict
=
{
}
        
for
cmd
in
self
.
reg
.
findall
(
'
commands
/
command
'
)
:
            
if
(
cmd
.
get
(
'
name
'
)
=
=
None
)
:
                
cmd
.
attrib
[
'
name
'
]
=
cmd
.
find
(
'
proto
/
name
'
)
.
text
            
ci
=
CmdInfo
(
cmd
)
            
self
.
addElementInfo
(
cmd
ci
'
command
'
self
.
cmddict
)
        
self
.
apidict
=
{
}
        
for
feature
in
self
.
reg
.
findall
(
'
feature
'
)
:
            
ai
=
FeatureInfo
(
feature
)
            
self
.
addElementInfo
(
feature
ai
'
feature
'
self
.
apidict
)
        
self
.
extensions
=
self
.
reg
.
findall
(
'
extensions
/
extension
'
)
        
self
.
extdict
=
{
}
        
for
feature
in
self
.
extensions
:
            
ei
=
FeatureInfo
(
feature
)
            
self
.
addElementInfo
(
feature
ei
'
extension
'
self
.
extdict
)
    
def
dumpReg
(
self
maxlen
=
40
filehandle
=
sys
.
stdout
)
:
        
"
"
"
Dump
all
the
dictionaries
constructed
from
the
Registry
object
"
"
"
        
write
(
'
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
'
file
=
filehandle
)
        
write
(
'
*
*
Dumping
Registry
contents
*
*
'
file
=
filehandle
)
        
write
(
'
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
'
file
=
filehandle
)
        
write
(
'
/
/
Types
'
file
=
filehandle
)
        
for
name
in
self
.
typedict
:
            
tobj
=
self
.
typedict
[
name
]
            
write
(
'
Type
'
name
'
-
>
'
etree
.
tostring
(
tobj
.
elem
)
[
0
:
maxlen
]
file
=
filehandle
)
        
write
(
'
/
/
Groups
'
file
=
filehandle
)
        
for
name
in
self
.
groupdict
:
            
gobj
=
self
.
groupdict
[
name
]
            
write
(
'
Group
'
name
'
-
>
'
etree
.
tostring
(
gobj
.
elem
)
[
0
:
maxlen
]
file
=
filehandle
)
        
write
(
'
/
/
Enums
'
file
=
filehandle
)
        
for
name
in
self
.
enumdict
:
            
eobj
=
self
.
enumdict
[
name
]
            
write
(
'
Enum
'
name
'
-
>
'
etree
.
tostring
(
eobj
.
elem
)
[
0
:
maxlen
]
file
=
filehandle
)
        
write
(
'
/
/
Commands
'
file
=
filehandle
)
        
for
name
in
self
.
cmddict
:
            
cobj
=
self
.
cmddict
[
name
]
            
write
(
'
Command
'
name
'
-
>
'
etree
.
tostring
(
cobj
.
elem
)
[
0
:
maxlen
]
file
=
filehandle
)
        
write
(
'
/
/
APIs
'
file
=
filehandle
)
        
for
key
in
self
.
apidict
:
            
write
(
'
API
Version
'
key
'
-
>
'
                
etree
.
tostring
(
self
.
apidict
[
key
]
.
elem
)
[
0
:
maxlen
]
file
=
filehandle
)
        
write
(
'
/
/
Extensions
'
file
=
filehandle
)
        
for
key
in
self
.
extdict
:
            
write
(
'
Extension
'
key
'
-
>
'
                
etree
.
tostring
(
self
.
extdict
[
key
]
.
elem
)
[
0
:
maxlen
]
file
=
filehandle
)
    
def
markTypeRequired
(
self
typename
required
)
:
        
"
"
"
Require
(
along
with
its
dependencies
)
or
remove
(
but
not
its
dependencies
)
a
type
"
"
"
        
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
tagging
type
:
'
typename
'
-
>
required
=
'
required
)
        
type
=
self
.
lookupElementInfo
(
typename
self
.
typedict
)
        
if
(
type
!
=
None
)
:
            
if
(
required
and
(
'
requires
'
in
type
.
elem
.
attrib
)
)
:
                
depType
=
type
.
elem
.
get
(
'
requires
'
)
                
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
Generating
dependent
type
'
                    
depType
'
for
type
'
typename
)
                
self
.
markTypeRequired
(
depType
required
)
            
type
.
required
=
required
        
else
:
            
self
.
gen
.
logMsg
(
'
warn
'
'
*
*
*
type
:
'
typename
'
IS
NOT
DEFINED
'
)
    
def
markRequired
(
self
features
required
)
:
        
"
"
"
Require
or
remove
features
specified
in
the
Element
"
"
"
        
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
markRequired
(
features
=
<
too
long
to
print
>
required
=
'
required
'
)
'
)
        
for
typeElem
in
features
.
findall
(
'
type
'
)
:
            
self
.
markTypeRequired
(
typeElem
.
get
(
'
name
'
)
required
)
        
for
enumElem
in
features
.
findall
(
'
enum
'
)
:
            
name
=
enumElem
.
get
(
'
name
'
)
            
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
tagging
enum
:
'
name
'
-
>
required
=
'
required
)
            
enum
=
self
.
lookupElementInfo
(
name
self
.
enumdict
)
            
if
(
enum
!
=
None
)
:
                
enum
.
required
=
required
            
else
:
                
self
.
gen
.
logMsg
(
'
warn
'
'
*
*
*
enum
:
'
name
'
IS
NOT
DEFINED
'
)
        
for
cmdElem
in
features
.
findall
(
'
command
'
)
:
            
name
=
cmdElem
.
get
(
'
name
'
)
            
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
tagging
command
:
'
name
'
-
>
required
=
'
required
)
            
cmd
=
self
.
lookupElementInfo
(
name
self
.
cmddict
)
            
if
(
cmd
!
=
None
)
:
                
cmd
.
required
=
required
                
if
(
required
)
:
                    
for
ptype
in
cmd
.
elem
.
findall
(
'
.
/
/
ptype
'
)
:
                        
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
markRequired
:
command
implicitly
requires
dependent
type
'
ptype
.
text
)
                        
self
.
markTypeRequired
(
ptype
.
text
required
)
            
else
:
                
self
.
gen
.
logMsg
(
'
warn
'
'
*
*
*
command
:
'
name
'
IS
NOT
DEFINED
'
)
    
def
requireAndRemoveFeatures
(
self
interface
api
profile
)
:
        
"
"
"
Process
<
recquire
>
and
<
remove
>
tags
for
a
<
version
>
or
<
extension
>
"
"
"
        
for
feature
in
interface
.
findall
(
'
require
'
)
:
            
if
(
matchAPIProfile
(
api
profile
feature
)
)
:
                
self
.
markRequired
(
feature
True
)
        
for
feature
in
interface
.
findall
(
'
remove
'
)
:
            
if
(
matchAPIProfile
(
api
profile
feature
)
)
:
                
self
.
markRequired
(
feature
False
)
    
def
generateFeature
(
self
fname
ftype
dictionary
genProc
)
:
        
f
=
self
.
lookupElementInfo
(
fname
dictionary
)
        
if
(
f
=
=
None
)
:
            
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
No
entry
found
for
feature
'
fname
                            
'
returning
!
'
)
            
return
        
if
(
not
f
.
required
)
:
            
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
Skipping
'
ftype
fname
'
(
not
required
)
'
)
            
return
        
if
(
f
.
declared
)
:
            
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
Skipping
'
ftype
fname
'
(
already
declared
)
'
)
            
return
        
if
(
ftype
=
=
'
type
'
)
:
            
if
(
'
requires
'
in
f
.
elem
.
attrib
)
:
                
depname
=
f
.
elem
.
get
(
'
requires
'
)
                
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
Generating
required
dependent
type
'
                                
depname
)
                
self
.
generateFeature
(
depname
'
type
'
self
.
typedict
                                     
self
.
gen
.
genType
)
        
elif
(
ftype
=
=
'
command
'
)
:
            
for
ptype
in
f
.
elem
.
findall
(
'
.
/
/
ptype
'
)
:
                
depname
=
ptype
.
text
                
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
Generating
required
parameter
type
'
                                
depname
)
                
self
.
generateFeature
(
depname
'
type
'
self
.
typedict
                                     
self
.
gen
.
genType
)
        
if
self
.
emitFeatures
:
            
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
Emitting
'
ftype
'
decl
for
'
fname
)
            
genProc
(
f
fname
)
        
else
:
            
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
Skipping
'
ftype
fname
                            
'
(
not
emitting
this
feature
)
'
)
        
f
.
declared
=
True
    
def
generateRequiredInterface
(
self
interface
)
:
        
"
"
"
Generate
required
C
interface
for
specified
API
version
/
extension
"
"
"
        
for
features
in
interface
.
findall
(
'
require
'
)
:
            
for
t
in
features
.
findall
(
'
type
'
)
:
                
self
.
generateFeature
(
t
.
get
(
'
name
'
)
'
type
'
self
.
typedict
                                     
self
.
gen
.
genType
)
            
for
e
in
features
.
findall
(
'
enum
'
)
:
                
self
.
generateFeature
(
e
.
get
(
'
name
'
)
'
enum
'
self
.
enumdict
                                     
self
.
gen
.
genEnum
)
            
for
c
in
features
.
findall
(
'
command
'
)
:
                
self
.
generateFeature
(
c
.
get
(
'
name
'
)
'
command
'
self
.
cmddict
                                     
self
.
gen
.
genCmd
)
    
def
apiGen
(
self
genOpts
)
:
        
"
"
"
Generate
interfaces
for
the
specified
API
type
and
range
of
versions
"
"
"
        
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
'
)
        
self
.
gen
.
logMsg
(
'
diag
'
'
Registry
.
apiGen
file
:
'
genOpts
.
filename
                        
'
api
:
'
genOpts
.
apiname
                        
'
profile
:
'
genOpts
.
profile
)
        
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
'
)
        
self
.
genOpts
=
genOpts
        
self
.
apiReset
(
)
        
regVersions
=
re
.
compile
(
self
.
genOpts
.
versions
)
        
regEmitVersions
=
re
.
compile
(
self
.
genOpts
.
emitversions
)
        
regAddExtensions
=
re
.
compile
(
self
.
genOpts
.
addExtensions
)
        
regRemoveExtensions
=
re
.
compile
(
self
.
genOpts
.
removeExtensions
)
        
features
=
[
]
        
apiMatch
=
False
        
for
key
in
self
.
apidict
:
            
fi
=
self
.
apidict
[
key
]
            
api
=
fi
.
elem
.
get
(
'
api
'
)
            
if
(
api
=
=
self
.
genOpts
.
apiname
)
:
                
apiMatch
=
True
                
if
(
regVersions
.
match
(
fi
.
number
)
)
:
                    
fi
.
emit
=
(
regEmitVersions
.
match
(
fi
.
number
)
!
=
None
)
                    
features
.
append
(
fi
)
                    
if
(
not
fi
.
emit
)
:
                        
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
NOT
tagging
feature
api
=
'
api
                            
'
name
=
'
fi
.
name
'
number
=
'
fi
.
number
                            
'
for
emission
(
does
not
match
emitversions
pattern
)
'
)
                
else
:
                    
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
NOT
including
feature
api
=
'
api
                        
'
name
=
'
fi
.
name
'
number
=
'
fi
.
number
                        
'
(
does
not
match
requested
versions
)
'
)
            
else
:
                
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
NOT
including
feature
api
=
'
api
                    
'
name
=
'
fi
.
name
                    
'
(
does
not
match
requested
API
)
'
)
        
if
(
not
apiMatch
)
:
            
self
.
gen
.
logMsg
(
'
warn
'
'
*
*
*
No
matching
API
versions
found
!
'
)
        
for
key
in
self
.
extdict
:
            
ei
=
self
.
extdict
[
key
]
            
extName
=
ei
.
name
            
include
=
False
            
pat
=
'
^
(
'
+
ei
.
elem
.
get
(
'
supported
'
)
+
'
)
'
            
if
(
self
.
genOpts
.
defaultExtensions
and
                     
re
.
match
(
pat
self
.
genOpts
.
defaultExtensions
)
)
:
                
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
Including
extension
'
                    
extName
"
(
defaultExtensions
matches
the
'
supported
'
attribute
)
"
)
                
include
=
True
            
if
(
regAddExtensions
.
match
(
extName
)
!
=
None
)
:
                
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
Including
extension
'
                    
extName
'
(
matches
explicitly
requested
extensions
to
add
)
'
)
                
include
=
True
            
if
(
regRemoveExtensions
.
match
(
extName
)
!
=
None
)
:
                
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
Removing
extension
'
                    
extName
'
(
matches
explicitly
requested
extensions
to
remove
)
'
)
                
include
=
False
            
if
(
include
)
:
                
ei
.
emit
=
True
                
features
.
append
(
ei
)
            
else
:
                
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
NOT
including
extension
'
                    
extName
'
(
does
not
match
api
attribute
or
explicitly
requested
extensions
)
'
)
        
if
(
self
.
genOpts
.
sortProcedure
)
:
            
self
.
genOpts
.
sortProcedure
(
features
)
        
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
PASS
1
:
TAG
FEATURES
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
'
)
        
for
f
in
features
:
            
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
PASS
1
:
Tagging
required
and
removed
features
for
'
                
f
.
name
)
            
self
.
requireAndRemoveFeatures
(
f
.
elem
self
.
genOpts
.
apiname
self
.
genOpts
.
profile
)
        
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
PASS
2
:
GENERATE
INTERFACES
FOR
FEATURES
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
'
)
        
self
.
gen
.
beginFile
(
self
.
genOpts
)
        
for
f
in
features
:
            
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
PASS
2
:
Generating
interface
for
'
                
f
.
name
)
            
emit
=
self
.
emitFeatures
=
f
.
emit
            
if
(
not
emit
)
:
                
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
PASS
2
:
NOT
declaring
feature
'
                    
f
.
elem
.
get
(
'
name
'
)
'
because
it
is
not
tagged
for
emission
'
)
            
self
.
gen
.
beginFeature
(
f
.
elem
emit
)
            
self
.
generateRequiredInterface
(
f
.
elem
)
            
self
.
gen
.
endFeature
(
)
        
self
.
gen
.
endFile
(
)
    
def
apiReset
(
self
)
:
        
"
"
"
Reset
type
/
enum
/
command
dictionaries
before
generating
another
API
"
"
"
        
for
type
in
self
.
typedict
:
            
self
.
typedict
[
type
]
.
resetState
(
)
        
for
enum
in
self
.
enumdict
:
            
self
.
enumdict
[
enum
]
.
resetState
(
)
        
for
cmd
in
self
.
cmddict
:
            
self
.
cmddict
[
cmd
]
.
resetState
(
)
        
for
cmd
in
self
.
apidict
:
            
self
.
apidict
[
cmd
]
.
resetState
(
)
    
def
validateGroups
(
self
)
:
        
"
"
"
Validate
group
=
attributes
on
<
param
>
and
<
proto
>
tags
"
"
"
        
badGroup
=
{
}
        
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
VALIDATING
GROUP
ATTRIBUTES
*
*
*
'
)
        
for
cmd
in
self
.
reg
.
findall
(
'
commands
/
command
'
)
:
            
proto
=
cmd
.
find
(
'
proto
'
)
            
funcname
=
cmd
.
find
(
'
proto
/
name
'
)
.
text
            
if
(
'
group
'
in
proto
.
attrib
.
keys
(
)
)
:
                
group
=
proto
.
get
(
'
group
'
)
                
if
(
group
not
in
self
.
groupdict
.
keys
(
)
)
:
                    
if
(
group
not
in
badGroup
.
keys
(
)
)
:
                        
badGroup
[
group
]
=
1
                    
else
:
                        
badGroup
[
group
]
=
badGroup
[
group
]
+
1
            
for
param
in
cmd
.
findall
(
'
param
'
)
:
                
pname
=
param
.
find
(
'
name
'
)
                
if
(
pname
!
=
None
)
:
                    
pname
=
pname
.
text
                
else
:
                    
pname
=
type
.
get
(
'
name
'
)
                
if
(
'
group
'
in
param
.
attrib
.
keys
(
)
)
:
                    
group
=
param
.
get
(
'
group
'
)
                    
if
(
group
not
in
self
.
groupdict
.
keys
(
)
)
:
                        
if
(
group
not
in
badGroup
.
keys
(
)
)
:
                            
badGroup
[
group
]
=
1
                        
else
:
                            
badGroup
[
group
]
=
badGroup
[
group
]
+
1
        
if
(
len
(
badGroup
.
keys
(
)
)
>
0
)
:
            
self
.
gen
.
logMsg
(
'
diag
'
'
*
*
*
SUMMARY
OF
UNRECOGNIZED
GROUPS
*
*
*
'
)
            
for
key
in
sorted
(
badGroup
.
keys
(
)
)
:
                
self
.
gen
.
logMsg
(
'
diag
'
'
'
key
'
occurred
'
badGroup
[
key
]
'
times
'
)
