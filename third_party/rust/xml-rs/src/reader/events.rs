use
std
:
:
fmt
;
use
std
:
:
borrow
:
:
Cow
;
use
name
:
:
OwnedName
;
use
attribute
:
:
OwnedAttribute
;
use
common
:
:
XmlVersion
;
use
namespace
:
:
Namespace
;
#
[
derive
(
PartialEq
Clone
)
]
pub
enum
XmlEvent
{
StartDocument
{
version
:
XmlVersion
encoding
:
String
standalone
:
Option
<
bool
>
}
EndDocument
ProcessingInstruction
{
name
:
String
data
:
Option
<
String
>
}
StartElement
{
name
:
OwnedName
attributes
:
Vec
<
OwnedAttribute
>
namespace
:
Namespace
}
EndElement
{
name
:
OwnedName
}
CData
(
String
)
Comment
(
String
)
Characters
(
String
)
Whitespace
(
String
)
}
impl
fmt
:
:
Debug
for
XmlEvent
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
XmlEvent
:
:
StartDocument
{
ref
version
ref
encoding
ref
standalone
}
=
>
write
!
(
f
"
StartDocument
(
{
}
{
}
{
:
?
}
)
"
version
*
encoding
*
standalone
)
XmlEvent
:
:
EndDocument
=
>
write
!
(
f
"
EndDocument
"
)
XmlEvent
:
:
ProcessingInstruction
{
ref
name
ref
data
}
=
>
write
!
(
f
"
ProcessingInstruction
(
{
}
{
}
)
"
*
name
match
*
data
{
Some
(
ref
data
)
=
>
format
!
(
"
{
}
"
data
)
None
=
>
String
:
:
new
(
)
}
)
XmlEvent
:
:
StartElement
{
ref
name
ref
attributes
namespace
:
Namespace
(
ref
namespace
)
}
=
>
write
!
(
f
"
StartElement
(
{
}
{
:
?
}
{
}
)
"
name
namespace
if
attributes
.
is_empty
(
)
{
String
:
:
new
(
)
}
else
{
let
attributes
:
Vec
<
String
>
=
attributes
.
iter
(
)
.
map
(
|
a
|
format
!
(
"
{
}
-
>
{
}
"
a
.
name
a
.
value
)
)
.
collect
(
)
;
format
!
(
"
[
{
}
]
"
attributes
.
join
(
"
"
)
)
}
)
XmlEvent
:
:
EndElement
{
ref
name
}
=
>
write
!
(
f
"
EndElement
(
{
}
)
"
name
)
XmlEvent
:
:
Comment
(
ref
data
)
=
>
write
!
(
f
"
Comment
(
{
}
)
"
data
)
XmlEvent
:
:
CData
(
ref
data
)
=
>
write
!
(
f
"
CData
(
{
}
)
"
data
)
XmlEvent
:
:
Characters
(
ref
data
)
=
>
write
!
(
f
"
Characters
(
{
}
)
"
data
)
XmlEvent
:
:
Whitespace
(
ref
data
)
=
>
write
!
(
f
"
Whitespace
(
{
}
)
"
data
)
}
}
}
impl
XmlEvent
{
pub
fn
as_writer_event
<
'
a
>
(
&
'
a
self
)
-
>
Option
<
:
:
writer
:
:
events
:
:
XmlEvent
<
'
a
>
>
{
match
*
self
{
XmlEvent
:
:
StartDocument
{
version
ref
encoding
standalone
}
=
>
Some
(
:
:
writer
:
:
events
:
:
XmlEvent
:
:
StartDocument
{
version
:
version
encoding
:
Some
(
encoding
)
standalone
:
standalone
}
)
XmlEvent
:
:
ProcessingInstruction
{
ref
name
ref
data
}
=
>
Some
(
:
:
writer
:
:
events
:
:
XmlEvent
:
:
ProcessingInstruction
{
name
:
name
data
:
data
.
as_ref
(
)
.
map
(
|
s
|
&
s
[
.
.
]
)
}
)
XmlEvent
:
:
StartElement
{
ref
name
ref
attributes
ref
namespace
}
=
>
Some
(
:
:
writer
:
:
events
:
:
XmlEvent
:
:
StartElement
{
name
:
name
.
borrow
(
)
attributes
:
attributes
.
iter
(
)
.
map
(
|
a
|
a
.
borrow
(
)
)
.
collect
(
)
namespace
:
Cow
:
:
Borrowed
(
namespace
)
}
)
XmlEvent
:
:
EndElement
{
ref
name
}
=
>
Some
(
:
:
writer
:
:
events
:
:
XmlEvent
:
:
EndElement
{
name
:
Some
(
name
.
borrow
(
)
)
}
)
XmlEvent
:
:
Comment
(
ref
data
)
=
>
Some
(
:
:
writer
:
:
events
:
:
XmlEvent
:
:
Comment
(
data
)
)
XmlEvent
:
:
CData
(
ref
data
)
=
>
Some
(
:
:
writer
:
:
events
:
:
XmlEvent
:
:
CData
(
data
)
)
XmlEvent
:
:
Characters
(
ref
data
)
=
>
Some
(
:
:
writer
:
:
events
:
:
XmlEvent
:
:
Characters
(
data
)
)
XmlEvent
:
:
Whitespace
(
ref
data
)
=
>
Some
(
:
:
writer
:
:
events
:
:
XmlEvent
:
:
Characters
(
data
)
)
_
=
>
None
}
}
}
