use
common
:
:
{
is_name_start_char
is_name_char
}
;
use
reader
:
:
events
:
:
XmlEvent
;
use
reader
:
:
lexer
:
:
Token
;
use
super
:
:
{
Result
PullParser
State
ProcessingInstructionSubstate
DeclarationSubstate
}
;
impl
PullParser
{
pub
fn
inside_processing_instruction
(
&
mut
self
t
:
Token
s
:
ProcessingInstructionSubstate
)
-
>
Option
<
Result
>
{
match
s
{
ProcessingInstructionSubstate
:
:
PIInsideName
=
>
match
t
{
Token
:
:
Character
(
c
)
if
!
self
.
buf_has_data
(
)
&
&
is_name_start_char
(
c
)
|
|
self
.
buf_has_data
(
)
&
&
is_name_char
(
c
)
=
>
self
.
append_char_continue
(
c
)
Token
:
:
ProcessingInstructionEnd
=
>
{
let
name
=
self
.
take_buf
(
)
;
match
&
name
[
.
.
]
{
"
"
=
>
Some
(
self_error
!
(
self
;
"
Encountered
processing
instruction
without
name
"
)
)
"
xml
"
|
"
xmL
"
|
"
xMl
"
|
"
xML
"
|
"
Xml
"
|
"
XmL
"
|
"
XMl
"
|
"
XML
"
=
>
Some
(
self_error
!
(
self
;
"
Invalid
processing
instruction
:
<
?
{
}
"
name
)
)
_
=
>
{
self
.
into_state_emit
(
State
:
:
OutsideTag
Ok
(
XmlEvent
:
:
ProcessingInstruction
{
name
:
name
data
:
None
}
)
)
}
}
}
Token
:
:
Whitespace
(
_
)
=
>
{
let
name
=
self
.
take_buf
(
)
;
match
&
name
[
.
.
]
{
"
xml
"
if
!
self
.
encountered_element
&
&
!
self
.
parsed_declaration
=
>
self
.
into_state_continue
(
State
:
:
InsideDeclaration
(
DeclarationSubstate
:
:
BeforeVersion
)
)
"
xml
"
|
"
xmL
"
|
"
xMl
"
|
"
xML
"
|
"
Xml
"
|
"
XmL
"
|
"
XMl
"
|
"
XML
"
if
self
.
encountered_element
|
|
self
.
parsed_declaration
=
>
Some
(
self_error
!
(
self
;
"
Invalid
processing
instruction
:
<
?
{
}
"
name
)
)
_
=
>
{
self
.
lexer
.
disable_errors
(
)
;
self
.
data
.
name
=
name
;
self
.
into_state_continue
(
State
:
:
InsideProcessingInstruction
(
ProcessingInstructionSubstate
:
:
PIInsideData
)
)
}
}
}
_
=
>
Some
(
self_error
!
(
self
;
"
Unexpected
token
:
<
?
{
}
{
}
"
self
.
buf
t
)
)
}
ProcessingInstructionSubstate
:
:
PIInsideData
=
>
match
t
{
Token
:
:
ProcessingInstructionEnd
=
>
{
self
.
lexer
.
enable_errors
(
)
;
let
name
=
self
.
data
.
take_name
(
)
;
let
data
=
self
.
take_buf
(
)
;
self
.
into_state_emit
(
State
:
:
OutsideTag
Ok
(
XmlEvent
:
:
ProcessingInstruction
{
name
:
name
data
:
Some
(
data
)
}
)
)
}
_
=
>
{
t
.
push_to_string
(
&
mut
self
.
buf
)
;
None
}
}
}
}
}
