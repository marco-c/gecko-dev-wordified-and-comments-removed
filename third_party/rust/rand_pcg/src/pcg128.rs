const
MULTIPLIER
:
u128
=
0x2360_ED05_1FC6_5DA4_4385_DF64_9FCC_F645
;
use
core
:
:
fmt
;
use
core
:
:
mem
:
:
transmute
;
use
rand_core
:
:
{
RngCore
SeedableRng
Error
le
}
;
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Mcg128Xsl64
{
state
:
u128
}
pub
type
Pcg64Mcg
=
Mcg128Xsl64
;
impl
Mcg128Xsl64
{
pub
fn
new
(
state
:
u128
)
-
>
Self
{
Mcg128Xsl64
{
state
:
state
|
1
}
}
}
impl
fmt
:
:
Debug
for
Mcg128Xsl64
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Mcg128Xsl64
{
{
}
}
"
)
}
}
impl
SeedableRng
for
Mcg128Xsl64
{
type
Seed
=
[
u8
;
16
]
;
fn
from_seed
(
seed
:
Self
:
:
Seed
)
-
>
Self
{
let
mut
seed_u64
=
[
0u64
;
2
]
;
le
:
:
read_u64_into
(
&
seed
&
mut
seed_u64
)
;
let
state
=
(
seed_u64
[
0
]
as
u128
)
|
(
seed_u64
[
1
]
as
u128
)
<
<
64
;
Mcg128Xsl64
:
:
new
(
state
)
}
}
impl
RngCore
for
Mcg128Xsl64
{
#
[
inline
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
next_u64
(
)
as
u32
}
#
[
inline
]
fn
next_u64
(
&
mut
self
)
-
>
u64
{
let
state
=
self
.
state
.
wrapping_mul
(
MULTIPLIER
)
;
self
.
state
=
state
;
const
XSHIFT
:
u32
=
64
;
const
ROTATE
:
u32
=
122
;
let
rot
=
(
state
>
>
ROTATE
)
as
u32
;
let
xsl
=
(
(
state
>
>
XSHIFT
)
as
u64
)
^
(
state
as
u64
)
;
xsl
.
rotate_right
(
rot
)
}
#
[
inline
]
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
let
mut
left
=
dest
;
while
left
.
len
(
)
>
=
8
{
let
(
l
r
)
=
{
left
}
.
split_at_mut
(
8
)
;
left
=
r
;
let
chunk
:
[
u8
;
8
]
=
unsafe
{
transmute
(
self
.
next_u64
(
)
.
to_le
(
)
)
}
;
l
.
copy_from_slice
(
&
chunk
)
;
}
let
n
=
left
.
len
(
)
;
if
n
>
0
{
let
chunk
:
[
u8
;
8
]
=
unsafe
{
transmute
(
self
.
next_u64
(
)
.
to_le
(
)
)
}
;
left
.
copy_from_slice
(
&
chunk
[
.
.
n
]
)
;
}
}
#
[
inline
]
fn
try_fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
Ok
(
self
.
fill_bytes
(
dest
)
)
}
}
