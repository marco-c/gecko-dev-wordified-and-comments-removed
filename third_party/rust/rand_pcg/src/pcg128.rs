const
MULTIPLIER
:
u128
=
0x2360_ED05_1FC6_5DA4_4385_DF64_9FCC_F645
;
use
core
:
:
fmt
;
use
rand_core
:
:
{
RngCore
SeedableRng
Error
le
}
;
#
[
cfg
(
feature
=
"
serde1
"
)
]
use
serde
:
:
{
Serialize
Deserialize
}
;
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Lcg128Xsl64
{
state
:
u128
increment
:
u128
}
pub
type
Pcg64
=
Lcg128Xsl64
;
impl
Lcg128Xsl64
{
pub
fn
new
(
state
:
u128
stream
:
u128
)
-
>
Self
{
let
increment
=
(
stream
<
<
1
)
|
1
;
Lcg128Xsl64
:
:
from_state_incr
(
state
increment
)
}
#
[
inline
]
fn
from_state_incr
(
state
:
u128
increment
:
u128
)
-
>
Self
{
let
mut
pcg
=
Lcg128Xsl64
{
state
increment
}
;
pcg
.
state
=
pcg
.
state
.
wrapping_add
(
pcg
.
increment
)
;
pcg
.
step
(
)
;
pcg
}
#
[
inline
]
fn
step
(
&
mut
self
)
{
self
.
state
=
self
.
state
.
wrapping_mul
(
MULTIPLIER
)
.
wrapping_add
(
self
.
increment
)
;
}
}
impl
fmt
:
:
Debug
for
Lcg128Xsl64
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Lcg128Xsl64
{
{
}
}
"
)
}
}
impl
SeedableRng
for
Lcg128Xsl64
{
type
Seed
=
[
u8
;
32
]
;
fn
from_seed
(
seed
:
Self
:
:
Seed
)
-
>
Self
{
let
mut
seed_u64
=
[
0u64
;
4
]
;
le
:
:
read_u64_into
(
&
seed
&
mut
seed_u64
)
;
let
state
=
u128
:
:
from
(
seed_u64
[
0
]
)
|
(
u128
:
:
from
(
seed_u64
[
1
]
)
<
<
64
)
;
let
incr
=
u128
:
:
from
(
seed_u64
[
2
]
)
|
(
u128
:
:
from
(
seed_u64
[
3
]
)
<
<
64
)
;
Lcg128Xsl64
:
:
from_state_incr
(
state
incr
|
1
)
}
}
impl
RngCore
for
Lcg128Xsl64
{
#
[
inline
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
next_u64
(
)
as
u32
}
#
[
inline
]
fn
next_u64
(
&
mut
self
)
-
>
u64
{
self
.
step
(
)
;
output_xsl_rr
(
self
.
state
)
}
#
[
inline
]
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
fill_bytes_impl
(
self
dest
)
}
#
[
inline
]
fn
try_fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
self
.
fill_bytes
(
dest
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Mcg128Xsl64
{
state
:
u128
}
pub
type
Pcg64Mcg
=
Mcg128Xsl64
;
impl
Mcg128Xsl64
{
pub
fn
new
(
state
:
u128
)
-
>
Self
{
Mcg128Xsl64
{
state
:
state
|
1
}
}
}
impl
fmt
:
:
Debug
for
Mcg128Xsl64
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Mcg128Xsl64
{
{
}
}
"
)
}
}
impl
SeedableRng
for
Mcg128Xsl64
{
type
Seed
=
[
u8
;
16
]
;
fn
from_seed
(
seed
:
Self
:
:
Seed
)
-
>
Self
{
let
mut
seed_u64
=
[
0u64
;
2
]
;
le
:
:
read_u64_into
(
&
seed
&
mut
seed_u64
)
;
let
state
=
u128
:
:
from
(
seed_u64
[
0
]
)
|
u128
:
:
from
(
seed_u64
[
1
]
)
<
<
64
;
Mcg128Xsl64
:
:
new
(
state
)
}
}
impl
RngCore
for
Mcg128Xsl64
{
#
[
inline
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
next_u64
(
)
as
u32
}
#
[
inline
]
fn
next_u64
(
&
mut
self
)
-
>
u64
{
self
.
state
=
self
.
state
.
wrapping_mul
(
MULTIPLIER
)
;
output_xsl_rr
(
self
.
state
)
}
#
[
inline
]
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
fill_bytes_impl
(
self
dest
)
}
#
[
inline
]
fn
try_fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
self
.
fill_bytes
(
dest
)
;
Ok
(
(
)
)
}
}
#
[
inline
(
always
)
]
fn
output_xsl_rr
(
state
:
u128
)
-
>
u64
{
const
XSHIFT
:
u32
=
64
;
const
ROTATE
:
u32
=
122
;
let
rot
=
(
state
>
>
ROTATE
)
as
u32
;
let
xsl
=
(
(
state
>
>
XSHIFT
)
as
u64
)
^
(
state
as
u64
)
;
xsl
.
rotate_right
(
rot
)
}
#
[
inline
(
always
)
]
fn
fill_bytes_impl
<
R
:
RngCore
+
?
Sized
>
(
rng
:
&
mut
R
dest
:
&
mut
[
u8
]
)
{
let
mut
left
=
dest
;
while
left
.
len
(
)
>
=
8
{
let
(
l
r
)
=
{
left
}
.
split_at_mut
(
8
)
;
left
=
r
;
let
chunk
:
[
u8
;
8
]
=
rng
.
next_u64
(
)
.
to_le_bytes
(
)
;
l
.
copy_from_slice
(
&
chunk
)
;
}
let
n
=
left
.
len
(
)
;
if
n
>
0
{
let
chunk
:
[
u8
;
8
]
=
rng
.
next_u64
(
)
.
to_le_bytes
(
)
;
left
.
copy_from_slice
(
&
chunk
[
.
.
n
]
)
;
}
}
