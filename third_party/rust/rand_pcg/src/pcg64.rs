use
core
:
:
fmt
;
use
core
:
:
mem
:
:
transmute
;
use
rand_core
:
:
{
RngCore
SeedableRng
Error
le
impls
}
;
const
MULTIPLIER
:
u64
=
6364136223846793005
;
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Lcg64Xsh32
{
state
:
u64
increment
:
u64
}
pub
type
Pcg32
=
Lcg64Xsh32
;
impl
Lcg64Xsh32
{
pub
fn
new
(
state
:
u64
stream
:
u64
)
-
>
Self
{
let
increment
=
(
stream
<
<
1
)
|
1
;
Lcg64Xsh32
:
:
from_state_incr
(
state
increment
)
}
#
[
inline
]
fn
from_state_incr
(
state
:
u64
increment
:
u64
)
-
>
Self
{
let
mut
pcg
=
Lcg64Xsh32
{
state
increment
}
;
pcg
.
state
=
pcg
.
state
.
wrapping_add
(
pcg
.
increment
)
;
pcg
.
step
(
)
;
pcg
}
#
[
inline
]
fn
step
(
&
mut
self
)
{
self
.
state
=
self
.
state
.
wrapping_mul
(
MULTIPLIER
)
.
wrapping_add
(
self
.
increment
)
;
}
}
impl
fmt
:
:
Debug
for
Lcg64Xsh32
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Lcg64Xsh32
{
{
}
}
"
)
}
}
impl
SeedableRng
for
Lcg64Xsh32
{
type
Seed
=
[
u8
;
16
]
;
fn
from_seed
(
seed
:
Self
:
:
Seed
)
-
>
Self
{
let
mut
seed_u64
=
[
0u64
;
2
]
;
le
:
:
read_u64_into
(
&
seed
&
mut
seed_u64
)
;
Lcg64Xsh32
:
:
from_state_incr
(
seed_u64
[
0
]
seed_u64
[
1
]
|
1
)
}
}
impl
RngCore
for
Lcg64Xsh32
{
#
[
inline
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
let
state
=
self
.
state
;
self
.
step
(
)
;
const
ROTATE
:
u32
=
59
;
const
XSHIFT
:
u32
=
18
;
const
SPARE
:
u32
=
27
;
let
rot
=
(
state
>
>
ROTATE
)
as
u32
;
let
xsh
=
(
(
(
state
>
>
XSHIFT
)
^
state
)
>
>
SPARE
)
as
u32
;
xsh
.
rotate_right
(
rot
)
}
#
[
inline
]
fn
next_u64
(
&
mut
self
)
-
>
u64
{
impls
:
:
next_u64_via_u32
(
self
)
}
#
[
inline
]
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
let
mut
left
=
dest
;
while
left
.
len
(
)
>
=
4
{
let
(
l
r
)
=
{
left
}
.
split_at_mut
(
4
)
;
left
=
r
;
let
chunk
:
[
u8
;
4
]
=
unsafe
{
transmute
(
self
.
next_u32
(
)
.
to_le
(
)
)
}
;
l
.
copy_from_slice
(
&
chunk
)
;
}
let
n
=
left
.
len
(
)
;
if
n
>
0
{
let
chunk
:
[
u8
;
4
]
=
unsafe
{
transmute
(
self
.
next_u32
(
)
.
to_le
(
)
)
}
;
left
.
copy_from_slice
(
&
chunk
[
.
.
n
]
)
;
}
}
#
[
inline
]
fn
try_fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
Ok
(
self
.
fill_bytes
(
dest
)
)
}
}
