use
std
:
:
convert
:
:
Infallible
;
use
std
:
:
fmt
:
:
{
self
Formatter
Write
}
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
{
borrow
str
}
;
#
[
inline
]
pub
fn
safe
<
T
E
>
(
text
:
T
escaper
:
E
)
-
>
Result
<
Safe
<
T
>
Infallible
>
{
let
_
=
escaper
;
Ok
(
Safe
(
text
)
)
}
#
[
inline
]
pub
fn
escape
<
T
E
>
(
text
:
T
escaper
:
E
)
-
>
Result
<
Safe
<
EscapeDisplay
<
T
E
>
>
Infallible
>
{
Ok
(
Safe
(
EscapeDisplay
(
text
escaper
)
)
)
}
pub
struct
EscapeDisplay
<
T
E
>
(
T
E
)
;
impl
<
T
:
fmt
:
:
Display
E
:
Escaper
>
fmt
:
:
Display
for
EscapeDisplay
<
T
E
>
{
#
[
inline
]
fn
fmt
(
&
self
fmt
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
EscapeWriter
(
fmt
self
.
1
)
"
{
}
"
&
self
.
0
)
}
}
impl
<
T
:
FastWritable
E
:
Escaper
>
FastWritable
for
EscapeDisplay
<
T
E
>
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
self
.
0
.
write_into
(
&
mut
EscapeWriter
(
dest
self
.
1
)
)
}
}
struct
EscapeWriter
<
W
E
>
(
W
E
)
;
impl
<
W
:
Write
E
:
Escaper
>
Write
for
EscapeWriter
<
W
E
>
{
#
[
inline
]
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
fmt
:
:
Result
{
self
.
1
.
write_escaped_str
(
&
mut
self
.
0
s
)
}
#
[
inline
]
fn
write_char
(
&
mut
self
c
:
char
)
-
>
fmt
:
:
Result
{
self
.
1
.
write_escaped_char
(
&
mut
self
.
0
c
)
}
}
#
[
inline
]
pub
fn
e
<
T
E
>
(
text
:
T
escaper
:
E
)
-
>
Result
<
Safe
<
EscapeDisplay
<
T
E
>
>
Infallible
>
{
escape
(
text
escaper
)
}
#
[
derive
(
Debug
Clone
Copy
Default
)
]
pub
struct
Html
;
impl
Escaper
for
Html
{
#
[
inline
]
fn
write_escaped_str
<
W
:
Write
>
(
&
self
fmt
:
W
string
:
&
str
)
-
>
fmt
:
:
Result
{
crate
:
:
html
:
:
write_escaped_str
(
fmt
string
)
}
#
[
inline
]
fn
write_escaped_char
<
W
:
Write
>
(
&
self
fmt
:
W
c
:
char
)
-
>
fmt
:
:
Result
{
crate
:
:
html
:
:
write_escaped_char
(
fmt
c
)
}
}
#
[
derive
(
Debug
Clone
Copy
Default
)
]
pub
struct
Text
;
impl
Escaper
for
Text
{
#
[
inline
]
fn
write_escaped_str
<
W
:
Write
>
(
&
self
mut
fmt
:
W
string
:
&
str
)
-
>
fmt
:
:
Result
{
fmt
.
write_str
(
string
)
}
#
[
inline
]
fn
write_escaped_char
<
W
:
Write
>
(
&
self
mut
fmt
:
W
c
:
char
)
-
>
fmt
:
:
Result
{
fmt
.
write_char
(
c
)
}
}
pub
trait
Escaper
:
Copy
{
fn
write_escaped_str
<
W
:
Write
>
(
&
self
fmt
:
W
string
:
&
str
)
-
>
fmt
:
:
Result
;
#
[
inline
]
fn
write_escaped_char
<
W
:
Write
>
(
&
self
fmt
:
W
c
:
char
)
-
>
fmt
:
:
Result
{
self
.
write_escaped_str
(
fmt
c
.
encode_utf8
(
&
mut
[
0
;
4
]
)
)
}
}
pub
trait
AutoEscape
{
type
Escaped
:
fmt
:
:
Display
;
type
Error
:
Into
<
crate
:
:
Error
>
;
fn
rinja_auto_escape
(
&
self
)
-
>
Result
<
Self
:
:
Escaped
Self
:
:
Error
>
;
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
AutoEscaper
<
'
a
T
:
?
Sized
E
>
{
text
:
&
'
a
T
escaper
:
E
}
impl
<
'
a
T
:
?
Sized
E
>
AutoEscaper
<
'
a
T
E
>
{
#
[
inline
]
pub
fn
new
(
text
:
&
'
a
T
escaper
:
E
)
-
>
Self
{
Self
{
text
escaper
}
}
}
impl
<
'
a
T
:
fmt
:
:
Display
+
?
Sized
E
:
Escaper
>
AutoEscape
for
&
&
AutoEscaper
<
'
a
T
E
>
{
type
Escaped
=
EscapeDisplay
<
&
'
a
T
E
>
;
type
Error
=
Infallible
;
#
[
inline
]
fn
rinja_auto_escape
(
&
self
)
-
>
Result
<
Self
:
:
Escaped
Self
:
:
Error
>
{
Ok
(
EscapeDisplay
(
self
.
text
self
.
escaper
)
)
}
}
pub
trait
HtmlSafe
:
fmt
:
:
Display
{
}
impl
<
'
a
T
:
HtmlSafe
+
?
Sized
>
AutoEscape
for
&
AutoEscaper
<
'
a
T
Html
>
{
type
Escaped
=
&
'
a
T
;
type
Error
=
Infallible
;
#
[
inline
]
fn
rinja_auto_escape
(
&
self
)
-
>
Result
<
Self
:
:
Escaped
Self
:
:
Error
>
{
Ok
(
self
.
text
)
}
}
pub
enum
MaybeSafe
<
T
>
{
Safe
(
T
)
NeedsEscaping
(
T
)
}
const
_
:
(
)
=
{
impl
<
T
:
fmt
:
:
Display
>
fmt
:
:
Display
for
MaybeSafe
<
T
>
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
inner
=
match
self
{
MaybeSafe
:
:
Safe
(
inner
)
=
>
inner
MaybeSafe
:
:
NeedsEscaping
(
inner
)
=
>
inner
}
;
write
!
(
f
"
{
inner
}
"
)
}
}
impl
<
T
:
FastWritable
>
FastWritable
for
MaybeSafe
<
T
>
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
let
inner
=
match
self
{
MaybeSafe
:
:
Safe
(
inner
)
=
>
inner
MaybeSafe
:
:
NeedsEscaping
(
inner
)
=
>
inner
}
;
inner
.
write_into
(
dest
)
}
}
macro_rules
!
add_ref
{
(
(
[
(
tt
:
tt
)
*
]
)
*
)
=
>
{
(
impl
<
'
a
T
:
fmt
:
:
Display
E
:
Escaper
>
AutoEscape
for
&
AutoEscaper
<
'
a
(
tt
)
*
MaybeSafe
<
T
>
E
>
{
type
Escaped
=
Wrapped
<
'
a
T
E
>
;
type
Error
=
Infallible
;
#
[
inline
]
fn
rinja_auto_escape
(
&
self
)
-
>
Result
<
Self
:
:
Escaped
Self
:
:
Error
>
{
match
self
.
text
{
MaybeSafe
:
:
Safe
(
t
)
=
>
Ok
(
Wrapped
:
:
Safe
(
t
)
)
MaybeSafe
:
:
NeedsEscaping
(
t
)
=
>
Ok
(
Wrapped
:
:
NeedsEscaping
(
t
self
.
escaper
)
)
}
}
}
)
*
}
;
}
add_ref
!
(
[
]
[
&
]
[
&
&
]
[
&
&
&
]
)
;
pub
enum
Wrapped
<
'
a
T
:
?
Sized
E
>
{
Safe
(
&
'
a
T
)
NeedsEscaping
(
&
'
a
T
E
)
}
impl
<
T
:
FastWritable
+
?
Sized
E
:
Escaper
>
FastWritable
for
Wrapped
<
'
_
T
E
>
{
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
match
*
self
{
Wrapped
:
:
Safe
(
t
)
=
>
t
.
write_into
(
dest
)
Wrapped
:
:
NeedsEscaping
(
t
e
)
=
>
EscapeDisplay
(
t
e
)
.
write_into
(
dest
)
}
}
}
impl
<
T
:
fmt
:
:
Display
+
?
Sized
E
:
Escaper
>
fmt
:
:
Display
for
Wrapped
<
'
_
T
E
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
Wrapped
:
:
Safe
(
t
)
=
>
write
!
(
f
"
{
t
}
"
)
Wrapped
:
:
NeedsEscaping
(
t
e
)
=
>
EscapeDisplay
(
t
e
)
.
fmt
(
f
)
}
}
}
}
;
pub
struct
Safe
<
T
>
(
pub
T
)
;
const
_
:
(
)
=
{
impl
<
T
:
fmt
:
:
Display
>
fmt
:
:
Display
for
Safe
<
T
>
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
0
)
}
}
impl
<
T
:
FastWritable
>
FastWritable
for
Safe
<
T
>
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
self
.
0
.
write_into
(
dest
)
}
}
macro_rules
!
add_ref
{
(
(
[
(
tt
:
tt
)
*
]
)
*
)
=
>
{
(
impl
<
'
a
T
:
fmt
:
:
Display
E
>
AutoEscape
for
&
AutoEscaper
<
'
a
(
tt
)
*
Safe
<
T
>
E
>
{
type
Escaped
=
&
'
a
T
;
type
Error
=
Infallible
;
#
[
inline
]
fn
rinja_auto_escape
(
&
self
)
-
>
Result
<
Self
:
:
Escaped
Self
:
:
Error
>
{
Ok
(
&
self
.
text
.
0
)
}
}
)
*
}
;
}
add_ref
!
(
[
]
[
&
]
[
&
&
]
[
&
&
&
]
)
;
}
;
pub
struct
Unsafe
<
T
>
(
pub
T
)
;
impl
<
T
:
fmt
:
:
Display
>
fmt
:
:
Display
for
Unsafe
<
T
>
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
0
)
}
}
pub
struct
HtmlSafeOutput
<
T
>
(
pub
T
)
;
impl
<
T
:
fmt
:
:
Display
>
fmt
:
:
Display
for
HtmlSafeOutput
<
T
>
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
0
)
}
}
macro_rules
!
mark_html_safe
{
(
(
ty
:
ty
)
*
(
)
?
)
=
>
{
(
impl
HtmlSafe
for
ty
{
}
)
*
}
;
}
mark_html_safe
!
{
bool
f32
f64
i8
i16
i32
i64
i128
isize
u8
u16
u32
u64
u128
usize
std
:
:
num
:
:
NonZeroI8
std
:
:
num
:
:
NonZeroI16
std
:
:
num
:
:
NonZeroI32
std
:
:
num
:
:
NonZeroI64
std
:
:
num
:
:
NonZeroI128
std
:
:
num
:
:
NonZeroIsize
std
:
:
num
:
:
NonZeroU8
std
:
:
num
:
:
NonZeroU16
std
:
:
num
:
:
NonZeroU32
std
:
:
num
:
:
NonZeroU64
std
:
:
num
:
:
NonZeroU128
std
:
:
num
:
:
NonZeroUsize
}
impl
<
T
:
HtmlSafe
+
?
Sized
>
HtmlSafe
for
&
T
{
}
impl
<
T
:
HtmlSafe
+
?
Sized
>
HtmlSafe
for
Box
<
T
>
{
}
impl
<
T
:
HtmlSafe
+
?
Sized
>
HtmlSafe
for
std
:
:
cell
:
:
Ref
<
'
_
T
>
{
}
impl
<
T
:
HtmlSafe
+
?
Sized
>
HtmlSafe
for
std
:
:
cell
:
:
RefMut
<
'
_
T
>
{
}
impl
<
T
:
HtmlSafe
+
?
Sized
>
HtmlSafe
for
std
:
:
rc
:
:
Rc
<
T
>
{
}
impl
<
T
:
HtmlSafe
+
?
Sized
>
HtmlSafe
for
std
:
:
pin
:
:
Pin
<
&
T
>
{
}
impl
<
T
:
HtmlSafe
+
?
Sized
>
HtmlSafe
for
std
:
:
sync
:
:
Arc
<
T
>
{
}
impl
<
T
:
HtmlSafe
+
?
Sized
>
HtmlSafe
for
std
:
:
sync
:
:
MutexGuard
<
'
_
T
>
{
}
impl
<
T
:
HtmlSafe
+
?
Sized
>
HtmlSafe
for
std
:
:
sync
:
:
RwLockReadGuard
<
'
_
T
>
{
}
impl
<
T
:
HtmlSafe
+
?
Sized
>
HtmlSafe
for
std
:
:
sync
:
:
RwLockWriteGuard
<
'
_
T
>
{
}
impl
<
T
:
HtmlSafe
>
HtmlSafe
for
std
:
:
num
:
:
Wrapping
<
T
>
{
}
impl
<
T
:
fmt
:
:
Display
>
HtmlSafe
for
HtmlSafeOutput
<
T
>
{
}
impl
<
T
>
HtmlSafe
for
borrow
:
:
Cow
<
'
_
T
>
where
T
:
HtmlSafe
+
borrow
:
:
ToOwned
+
?
Sized
T
:
:
Owned
:
HtmlSafe
{
}
pub
struct
Writable
<
'
a
S
:
?
Sized
>
(
pub
&
'
a
S
)
;
pub
trait
WriteWritable
{
fn
rinja_write
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
;
}
pub
trait
FastWritable
{
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
;
}
const
_
:
(
)
=
{
crate
:
:
impl_for_ref
!
{
impl
FastWritable
for
T
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
<
T
>
:
:
write_into
(
self
dest
)
}
}
}
impl
<
T
>
FastWritable
for
Pin
<
T
>
where
T
:
Deref
<
T
as
Deref
>
:
:
Target
:
FastWritable
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
self
.
as_ref
(
)
.
get_ref
(
)
.
write_into
(
dest
)
}
}
impl
<
T
:
FastWritable
+
ToOwned
>
FastWritable
for
borrow
:
:
Cow
<
'
_
T
>
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
T
:
:
write_into
(
self
.
as_ref
(
)
dest
)
}
}
macro_rules
!
impl_for_int
{
(
(
ty
:
ty
)
*
)
=
>
{
(
impl
FastWritable
for
ty
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
dest
.
write_str
(
itoa
:
:
Buffer
:
:
new
(
)
.
format
(
*
self
)
)
}
}
)
*
}
;
}
impl_for_int
!
(
u8
u16
u32
u64
u128
usize
i8
i16
i32
i64
i128
isize
)
;
macro_rules
!
impl_for_nz_int
{
(
(
id
:
ident
)
*
)
=
>
{
(
impl
FastWritable
for
core
:
:
num
:
:
id
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
dest
.
write_str
(
itoa
:
:
Buffer
:
:
new
(
)
.
format
(
self
.
get
(
)
)
)
}
}
)
*
}
;
}
impl_for_nz_int
!
(
NonZeroU8
NonZeroU16
NonZeroU32
NonZeroU64
NonZeroU128
NonZeroUsize
NonZeroI8
NonZeroI16
NonZeroI32
NonZeroI64
NonZeroI128
NonZeroIsize
)
;
impl
FastWritable
for
str
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
dest
.
write_str
(
self
)
}
}
impl
FastWritable
for
String
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
dest
.
write_str
(
self
)
}
}
impl
FastWritable
for
bool
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
dest
.
write_str
(
match
self
{
true
=
>
"
true
"
false
=
>
"
false
"
}
)
}
}
impl
FastWritable
for
char
{
#
[
inline
]
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
dest
.
write_char
(
*
self
)
}
}
impl
FastWritable
for
fmt
:
:
Arguments
<
'
_
>
{
fn
write_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
match
self
.
as_str
(
)
{
Some
(
s
)
=
>
dest
.
write_str
(
s
)
None
=
>
dest
.
write_fmt
(
*
self
)
}
}
}
impl
<
'
a
S
:
FastWritable
+
?
Sized
>
WriteWritable
for
&
Writable
<
'
a
S
>
{
#
[
inline
]
fn
rinja_write
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
self
.
0
.
write_into
(
dest
)
}
}
impl
<
'
a
S
:
fmt
:
:
Display
+
?
Sized
>
WriteWritable
for
&
&
Writable
<
'
a
S
>
{
#
[
inline
]
fn
rinja_write
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
dest
:
&
mut
W
)
-
>
fmt
:
:
Result
{
write
!
(
dest
"
{
}
"
self
.
0
)
}
}
}
;
#
[
test
]
fn
test_escape
(
)
{
assert_eq
!
(
escape
(
"
"
Html
)
.
unwrap
(
)
.
to_string
(
)
"
"
)
;
assert_eq
!
(
escape
(
"
<
&
>
"
Html
)
.
unwrap
(
)
.
to_string
(
)
"
&
#
60
;
&
#
38
;
&
#
62
;
"
)
;
assert_eq
!
(
escape
(
"
bla
&
"
Html
)
.
unwrap
(
)
.
to_string
(
)
"
bla
&
#
38
;
"
)
;
assert_eq
!
(
escape
(
"
<
foo
"
Html
)
.
unwrap
(
)
.
to_string
(
)
"
&
#
60
;
foo
"
)
;
assert_eq
!
(
escape
(
"
bla
&
h
"
Html
)
.
unwrap
(
)
.
to_string
(
)
"
bla
&
#
38
;
h
"
)
;
assert_eq
!
(
escape
(
"
"
Text
)
.
unwrap
(
)
.
to_string
(
)
"
"
)
;
assert_eq
!
(
escape
(
"
<
&
>
"
Text
)
.
unwrap
(
)
.
to_string
(
)
"
<
&
>
"
)
;
assert_eq
!
(
escape
(
"
bla
&
"
Text
)
.
unwrap
(
)
.
to_string
(
)
"
bla
&
"
)
;
assert_eq
!
(
escape
(
"
<
foo
"
Text
)
.
unwrap
(
)
.
to_string
(
)
"
<
foo
"
)
;
assert_eq
!
(
escape
(
"
bla
&
h
"
Text
)
.
unwrap
(
)
.
to_string
(
)
"
bla
&
h
"
)
;
}
#
[
test
]
fn
test_html_safe_marker
(
)
{
struct
Script1
;
struct
Script2
;
impl
fmt
:
:
Display
for
Script1
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
<
script
>
"
)
}
}
impl
fmt
:
:
Display
for
Script2
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
<
script
>
"
)
}
}
impl
HtmlSafe
for
Script2
{
}
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
Script1
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
&
#
60
;
script
&
#
62
;
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
Script2
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
<
script
>
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
Script1
Text
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
<
script
>
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
Script2
Text
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
<
script
>
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
Safe
(
Script1
)
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
<
script
>
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
Safe
(
Script2
)
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
<
script
>
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
Unsafe
(
Script1
)
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
&
#
60
;
script
&
#
62
;
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
Unsafe
(
Script2
)
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
&
#
60
;
script
&
#
62
;
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
MaybeSafe
:
:
Safe
(
Script1
)
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
<
script
>
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
MaybeSafe
:
:
Safe
(
Script2
)
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
<
script
>
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
MaybeSafe
:
:
NeedsEscaping
(
Script1
)
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
&
#
60
;
script
&
#
62
;
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
MaybeSafe
:
:
NeedsEscaping
(
Script2
)
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
&
#
60
;
script
&
#
62
;
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
Safe
(
std
:
:
pin
:
:
Pin
:
:
new
(
&
Script1
)
)
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
<
script
>
"
)
;
assert_eq
!
(
(
&
&
AutoEscaper
:
:
new
(
&
Safe
(
std
:
:
pin
:
:
Pin
:
:
new
(
&
Script2
)
)
Html
)
)
.
rinja_auto_escape
(
)
.
unwrap
(
)
.
to_string
(
)
"
<
script
>
"
)
;
}
