#
!
[
cfg_attr
(
docsrs
feature
(
doc_cfg
doc_auto_cfg
)
)
]
#
!
[
deny
(
elided_lifetimes_in_paths
)
]
#
!
[
deny
(
unreachable_pub
)
]
#
!
[
deny
(
missing_docs
)
]
mod
error
;
pub
mod
filters
;
#
[
doc
(
hidden
)
]
pub
mod
helpers
;
mod
html
;
use
std
:
:
{
fmt
io
}
;
pub
use
rinja_derive
:
:
Template
;
#
[
doc
(
hidden
)
]
pub
use
crate
as
shared
;
pub
use
crate
:
:
error
:
:
{
Error
Result
}
;
pub
trait
Template
:
fmt
:
:
Display
{
fn
render
(
&
self
)
-
>
Result
<
String
>
{
let
mut
buf
=
String
:
:
new
(
)
;
let
_
=
buf
.
try_reserve
(
Self
:
:
SIZE_HINT
)
;
self
.
render_into
(
&
mut
buf
)
?
;
Ok
(
buf
)
}
fn
render_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
)
-
>
Result
<
(
)
>
;
fn
write_into
<
W
:
io
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
struct
Wrapped
<
W
:
io
:
:
Write
>
{
writer
:
W
err
:
Option
<
io
:
:
Error
>
}
impl
<
W
:
io
:
:
Write
>
fmt
:
:
Write
for
Wrapped
<
W
>
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
fmt
:
:
Result
{
if
let
Err
(
err
)
=
self
.
writer
.
write_all
(
s
.
as_bytes
(
)
)
{
self
.
err
=
Some
(
err
)
;
Err
(
fmt
:
:
Error
)
}
else
{
Ok
(
(
)
)
}
}
}
let
mut
wrapped
=
Wrapped
{
writer
err
:
None
}
;
if
self
.
render_into
(
&
mut
wrapped
)
.
is_ok
(
)
{
Ok
(
(
)
)
}
else
{
let
err
=
wrapped
.
err
.
take
(
)
;
Err
(
err
.
unwrap_or_else
(
|
|
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
fmt
:
:
Error
)
)
)
}
}
const
EXTENSION
:
Option
<
&
'
static
str
>
;
const
SIZE_HINT
:
usize
;
const
MIME_TYPE
:
&
'
static
str
;
}
impl
<
T
:
Template
+
?
Sized
>
Template
for
&
T
{
#
[
inline
]
fn
render_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
)
-
>
Result
<
(
)
>
{
T
:
:
render_into
(
self
writer
)
}
#
[
inline
]
fn
render
(
&
self
)
-
>
Result
<
String
>
{
T
:
:
render
(
self
)
}
#
[
inline
]
fn
write_into
<
W
:
io
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
T
:
:
write_into
(
self
writer
)
}
const
EXTENSION
:
Option
<
&
'
static
str
>
=
T
:
:
EXTENSION
;
const
SIZE_HINT
:
usize
=
T
:
:
SIZE_HINT
;
const
MIME_TYPE
:
&
'
static
str
=
T
:
:
MIME_TYPE
;
}
pub
trait
DynTemplate
{
fn
dyn_render
(
&
self
)
-
>
Result
<
String
>
;
fn
dyn_render_into
(
&
self
writer
:
&
mut
dyn
fmt
:
:
Write
)
-
>
Result
<
(
)
>
;
fn
dyn_write_into
(
&
self
writer
:
&
mut
dyn
io
:
:
Write
)
-
>
io
:
:
Result
<
(
)
>
;
fn
extension
(
&
self
)
-
>
Option
<
&
'
static
str
>
;
fn
size_hint
(
&
self
)
-
>
usize
;
fn
mime_type
(
&
self
)
-
>
&
'
static
str
;
}
impl
<
T
:
Template
>
DynTemplate
for
T
{
fn
dyn_render
(
&
self
)
-
>
Result
<
String
>
{
<
Self
as
Template
>
:
:
render
(
self
)
}
fn
dyn_render_into
(
&
self
writer
:
&
mut
dyn
fmt
:
:
Write
)
-
>
Result
<
(
)
>
{
<
Self
as
Template
>
:
:
render_into
(
self
writer
)
}
#
[
inline
]
fn
dyn_write_into
(
&
self
writer
:
&
mut
dyn
io
:
:
Write
)
-
>
io
:
:
Result
<
(
)
>
{
<
Self
as
Template
>
:
:
write_into
(
self
writer
)
}
fn
extension
(
&
self
)
-
>
Option
<
&
'
static
str
>
{
Self
:
:
EXTENSION
}
fn
size_hint
(
&
self
)
-
>
usize
{
Self
:
:
SIZE_HINT
}
fn
mime_type
(
&
self
)
-
>
&
'
static
str
{
Self
:
:
MIME_TYPE
}
}
impl
fmt
:
:
Display
for
dyn
DynTemplate
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
dyn_render_into
(
f
)
.
map_err
(
|
_
|
fmt
:
:
Error
{
}
)
}
}
macro_rules
!
impl_for_ref
{
(
impl
Trait
:
ident
for
T
:
ident
body
:
tt
)
=
>
{
crate
:
:
impl_for_ref
!
{
impl
<
T
>
Trait
for
[
&
T
&
mut
T
Box
<
T
>
std
:
:
cell
:
:
Ref
<
'
_
T
>
std
:
:
cell
:
:
RefMut
<
'
_
T
>
std
:
:
rc
:
:
Rc
<
T
>
std
:
:
sync
:
:
Arc
<
T
>
std
:
:
sync
:
:
MutexGuard
<
'
_
T
>
std
:
:
sync
:
:
RwLockReadGuard
<
'
_
T
>
std
:
:
sync
:
:
RwLockWriteGuard
<
'
_
T
>
]
body
}
}
;
(
impl
<
T
:
ident
>
Trait
:
ident
for
[
(
ty
:
ty
)
*
]
body
:
tt
)
=
>
{
(
impl
<
T
:
Trait
+
?
Sized
>
Trait
for
ty
body
)
*
}
}
pub
(
crate
)
use
impl_for_ref
;
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
fmt
;
use
super
:
:
*
;
use
crate
:
:
{
DynTemplate
Template
}
;
#
[
test
]
fn
dyn_template
(
)
{
struct
Test
;
impl
Template
for
Test
{
fn
render_into
<
W
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
writer
:
&
mut
W
)
-
>
Result
<
(
)
>
{
Ok
(
writer
.
write_str
(
"
test
"
)
?
)
}
const
EXTENSION
:
Option
<
&
'
static
str
>
=
Some
(
"
txt
"
)
;
const
SIZE_HINT
:
usize
=
4
;
const
MIME_TYPE
:
&
'
static
str
=
"
text
/
plain
;
charset
=
utf
-
8
"
;
}
impl
fmt
:
:
Display
for
Test
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
render_into
(
f
)
.
map_err
(
|
_
|
fmt
:
:
Error
{
}
)
}
}
fn
render
(
t
:
&
dyn
DynTemplate
)
-
>
String
{
t
.
dyn_render
(
)
.
unwrap
(
)
}
let
test
=
&
Test
as
&
dyn
DynTemplate
;
assert_eq
!
(
render
(
test
)
"
test
"
)
;
assert_eq
!
(
test
.
to_string
(
)
"
test
"
)
;
assert_eq
!
(
format
!
(
"
{
test
}
"
)
"
test
"
)
;
let
mut
vec
=
Vec
:
:
new
(
)
;
test
.
dyn_write_into
(
&
mut
vec
)
.
unwrap
(
)
;
assert_eq
!
(
vec
vec
!
[
b
'
t
'
b
'
e
'
b
'
s
'
b
'
t
'
]
)
;
}
}
