use
fluent_bundle
:
:
FluentArgs
;
use
std
:
:
borrow
:
:
Cow
;
#
[
derive
(
Debug
)
]
pub
struct
L10nKey
<
'
l
>
{
pub
id
:
Cow
<
'
l
str
>
pub
args
:
Option
<
FluentArgs
<
'
l
>
>
}
impl
<
'
l
>
From
<
&
'
l
str
>
for
L10nKey
<
'
l
>
{
fn
from
(
id
:
&
'
l
str
)
-
>
Self
{
Self
{
id
:
id
.
into
(
)
args
:
None
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
L10nAttribute
<
'
l
>
{
pub
name
:
Cow
<
'
l
str
>
pub
value
:
Cow
<
'
l
str
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
L10nMessage
<
'
l
>
{
pub
value
:
Option
<
Cow
<
'
l
str
>
>
pub
attributes
:
Vec
<
L10nAttribute
<
'
l
>
>
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
ResourceType
{
Required
Optional
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ResourceId
{
pub
value
:
String
pub
resource_type
:
ResourceType
}
impl
ResourceId
{
pub
fn
new
<
S
:
Into
<
String
>
>
(
value
:
S
resource_type
:
ResourceType
)
-
>
Self
{
Self
{
value
:
value
.
into
(
)
resource_type
}
}
pub
fn
is_required
(
&
self
)
-
>
bool
{
matches
!
(
self
.
resource_type
ResourceType
:
:
Required
)
}
pub
fn
is_optional
(
&
self
)
-
>
bool
{
matches
!
(
self
.
resource_type
ResourceType
:
:
Optional
)
}
}
impl
<
S
:
Into
<
String
>
>
From
<
S
>
for
ResourceId
{
fn
from
(
id
:
S
)
-
>
Self
{
Self
{
value
:
id
.
into
(
)
resource_type
:
ResourceType
:
:
Required
}
}
}
impl
std
:
:
fmt
:
:
Display
for
ResourceId
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
value
)
}
}
impl
PartialEq
<
str
>
for
ResourceId
{
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
self
.
value
.
as_str
(
)
.
eq
(
other
)
}
}
impl
Eq
for
ResourceId
{
}
impl
PartialEq
for
ResourceId
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
value
.
eq
(
&
other
.
value
)
}
}
pub
trait
ToResourceId
{
fn
to_resource_id
(
self
resource_type
:
ResourceType
)
-
>
ResourceId
;
}
impl
<
S
:
Into
<
String
>
>
ToResourceId
for
S
{
fn
to_resource_id
(
self
resource_type
:
ResourceType
)
-
>
ResourceId
{
ResourceId
:
:
new
(
self
.
into
(
)
resource_type
)
}
}
