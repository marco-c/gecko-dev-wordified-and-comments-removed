#
!
[
allow
(
warnings
)
]
#
!
[
forbid
(
unsafe_code
)
]
#
!
[
no_std
]
extern
crate
alloc
;
pub
mod
deflate
;
pub
mod
inflate
;
mod
shared
;
pub
use
crate
:
:
shared
:
:
update_adler32
as
mz_adler32_oxide
;
pub
use
crate
:
:
shared
:
:
{
MZ_ADLER32_INIT
MZ_DEFAULT_WINDOW_BITS
}
;
#
[
repr
(
i32
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
MZFlush
{
None
=
0
Partial
=
1
Sync
=
2
Full
=
3
Finish
=
4
Block
=
5
}
impl
MZFlush
{
pub
fn
new
(
flush
:
i32
)
-
>
Result
<
Self
MZError
>
{
match
flush
{
0
=
>
Ok
(
MZFlush
:
:
None
)
1
|
2
=
>
Ok
(
MZFlush
:
:
Sync
)
3
=
>
Ok
(
MZFlush
:
:
Full
)
4
=
>
Ok
(
MZFlush
:
:
Finish
)
_
=
>
Err
(
MZError
:
:
Param
)
}
}
}
#
[
repr
(
i32
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
MZStatus
{
Ok
=
0
StreamEnd
=
1
NeedDict
=
2
}
#
[
repr
(
i32
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
MZError
{
ErrNo
=
-
1
Stream
=
-
2
Data
=
-
3
Mem
=
-
4
Buf
=
-
5
Version
=
-
6
Param
=
-
10_000
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
#
[
non_exhaustive
]
pub
enum
DataFormat
{
Zlib
ZLibIgnoreChecksum
Raw
}
impl
DataFormat
{
pub
(
crate
)
fn
from_window_bits
(
window_bits
:
i32
)
-
>
DataFormat
{
if
window_bits
>
0
{
DataFormat
:
:
Zlib
}
else
{
DataFormat
:
:
Raw
}
}
pub
(
crate
)
fn
to_window_bits
(
self
)
-
>
i32
{
match
self
{
DataFormat
:
:
Zlib
|
DataFormat
:
:
ZLibIgnoreChecksum
=
>
shared
:
:
MZ_DEFAULT_WINDOW_BITS
DataFormat
:
:
Raw
=
>
-
shared
:
:
MZ_DEFAULT_WINDOW_BITS
}
}
}
pub
type
MZResult
=
Result
<
MZStatus
MZError
>
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
StreamResult
{
pub
bytes_consumed
:
usize
pub
bytes_written
:
usize
pub
status
:
MZResult
}
impl
StreamResult
{
#
[
inline
]
pub
(
crate
)
const
fn
error
(
error
:
MZError
)
-
>
StreamResult
{
StreamResult
{
bytes_consumed
:
0
bytes_written
:
0
status
:
Err
(
error
)
}
}
}
impl
core
:
:
convert
:
:
From
<
StreamResult
>
for
MZResult
{
fn
from
(
res
:
StreamResult
)
-
>
Self
{
res
.
status
}
}
impl
core
:
:
convert
:
:
From
<
&
StreamResult
>
for
MZResult
{
fn
from
(
res
:
&
StreamResult
)
-
>
Self
{
res
.
status
}
}
