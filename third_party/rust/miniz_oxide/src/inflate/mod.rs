#
[
cfg
(
feature
=
"
with
-
alloc
"
)
]
use
crate
:
:
alloc
:
:
{
boxed
:
:
Box
vec
vec
:
:
Vec
}
;
use
:
:
core
:
:
usize
;
#
[
cfg
(
all
(
feature
=
"
std
"
feature
=
"
with
-
alloc
"
)
)
]
use
std
:
:
error
:
:
Error
;
pub
mod
core
;
mod
output_buffer
;
pub
mod
stream
;
use
self
:
:
core
:
:
*
;
const
TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS
:
i32
=
-
4
;
const
TINFL_STATUS_BAD_PARAM
:
i32
=
-
3
;
const
TINFL_STATUS_ADLER32_MISMATCH
:
i32
=
-
2
;
const
TINFL_STATUS_FAILED
:
i32
=
-
1
;
const
TINFL_STATUS_DONE
:
i32
=
0
;
const
TINFL_STATUS_NEEDS_MORE_INPUT
:
i32
=
1
;
const
TINFL_STATUS_HAS_MORE_OUTPUT
:
i32
=
2
;
#
[
repr
(
i8
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
TINFLStatus
{
FailedCannotMakeProgress
=
TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS
as
i8
BadParam
=
TINFL_STATUS_BAD_PARAM
as
i8
Adler32Mismatch
=
TINFL_STATUS_ADLER32_MISMATCH
as
i8
Failed
=
TINFL_STATUS_FAILED
as
i8
Done
=
TINFL_STATUS_DONE
as
i8
NeedsMoreInput
=
TINFL_STATUS_NEEDS_MORE_INPUT
as
i8
HasMoreOutput
=
TINFL_STATUS_HAS_MORE_OUTPUT
as
i8
}
impl
TINFLStatus
{
pub
fn
from_i32
(
value
:
i32
)
-
>
Option
<
TINFLStatus
>
{
use
self
:
:
TINFLStatus
:
:
*
;
match
value
{
TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS
=
>
Some
(
FailedCannotMakeProgress
)
TINFL_STATUS_BAD_PARAM
=
>
Some
(
BadParam
)
TINFL_STATUS_ADLER32_MISMATCH
=
>
Some
(
Adler32Mismatch
)
TINFL_STATUS_FAILED
=
>
Some
(
Failed
)
TINFL_STATUS_DONE
=
>
Some
(
Done
)
TINFL_STATUS_NEEDS_MORE_INPUT
=
>
Some
(
NeedsMoreInput
)
TINFL_STATUS_HAS_MORE_OUTPUT
=
>
Some
(
HasMoreOutput
)
_
=
>
None
}
}
}
#
[
cfg
(
feature
=
"
with
-
alloc
"
)
]
#
[
derive
(
Debug
)
]
pub
struct
DecompressError
{
pub
status
:
TINFLStatus
pub
output
:
Vec
<
u8
>
}
#
[
cfg
(
feature
=
"
with
-
alloc
"
)
]
impl
alloc
:
:
fmt
:
:
Display
for
DecompressError
{
fn
fmt
(
&
self
f
:
&
mut
:
:
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
:
:
core
:
:
fmt
:
:
Result
{
f
.
write_str
(
match
self
.
status
{
TINFLStatus
:
:
FailedCannotMakeProgress
=
>
"
Truncated
input
stream
"
TINFLStatus
:
:
BadParam
=
>
"
Invalid
output
buffer
size
"
TINFLStatus
:
:
Adler32Mismatch
=
>
"
Adler32
checksum
mismatch
"
TINFLStatus
:
:
Failed
=
>
"
Invalid
input
data
"
TINFLStatus
:
:
Done
=
>
unreachable
!
(
)
TINFLStatus
:
:
NeedsMoreInput
=
>
"
Truncated
input
stream
"
TINFLStatus
:
:
HasMoreOutput
=
>
"
Output
size
exceeded
the
specified
limit
"
}
)
}
}
#
[
cfg
(
all
(
feature
=
"
std
"
feature
=
"
with
-
alloc
"
)
)
]
impl
Error
for
DecompressError
{
}
#
[
cfg
(
feature
=
"
with
-
alloc
"
)
]
fn
decompress_error
(
status
:
TINFLStatus
output
:
Vec
<
u8
>
)
-
>
Result
<
Vec
<
u8
>
DecompressError
>
{
Err
(
DecompressError
{
status
output
}
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
with
-
alloc
"
)
]
pub
fn
decompress_to_vec
(
input
:
&
[
u8
]
)
-
>
Result
<
Vec
<
u8
>
DecompressError
>
{
decompress_to_vec_inner
(
input
0
usize
:
:
max_value
(
)
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
with
-
alloc
"
)
]
pub
fn
decompress_to_vec_zlib
(
input
:
&
[
u8
]
)
-
>
Result
<
Vec
<
u8
>
DecompressError
>
{
decompress_to_vec_inner
(
input
inflate_flags
:
:
TINFL_FLAG_PARSE_ZLIB_HEADER
usize
:
:
max_value
(
)
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
with
-
alloc
"
)
]
pub
fn
decompress_to_vec_with_limit
(
input
:
&
[
u8
]
max_size
:
usize
)
-
>
Result
<
Vec
<
u8
>
DecompressError
>
{
decompress_to_vec_inner
(
input
0
max_size
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
with
-
alloc
"
)
]
pub
fn
decompress_to_vec_zlib_with_limit
(
input
:
&
[
u8
]
max_size
:
usize
)
-
>
Result
<
Vec
<
u8
>
DecompressError
>
{
decompress_to_vec_inner
(
input
inflate_flags
:
:
TINFL_FLAG_PARSE_ZLIB_HEADER
max_size
)
}
#
[
cfg
(
feature
=
"
with
-
alloc
"
)
]
fn
decompress_to_vec_inner
(
input
:
&
[
u8
]
flags
:
u32
max_output_size
:
usize
)
-
>
Result
<
Vec
<
u8
>
DecompressError
>
{
let
flags
=
flags
|
inflate_flags
:
:
TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF
;
let
mut
ret
:
Vec
<
u8
>
=
vec
!
[
0
;
input
.
len
(
)
.
saturating_mul
(
2
)
.
min
(
max_output_size
)
]
;
let
mut
decomp
=
Box
:
:
<
DecompressorOxide
>
:
:
default
(
)
;
let
mut
in_pos
=
0
;
let
mut
out_pos
=
0
;
loop
{
let
(
status
in_consumed
out_consumed
)
=
decompress
(
&
mut
decomp
&
input
[
in_pos
.
.
]
&
mut
ret
out_pos
flags
)
;
in_pos
+
=
in_consumed
;
out_pos
+
=
out_consumed
;
match
status
{
TINFLStatus
:
:
Done
=
>
{
ret
.
truncate
(
out_pos
)
;
return
Ok
(
ret
)
;
}
TINFLStatus
:
:
HasMoreOutput
=
>
{
if
ret
.
len
(
)
>
=
max_output_size
{
return
decompress_error
(
TINFLStatus
:
:
HasMoreOutput
ret
)
;
}
let
new_len
=
ret
.
len
(
)
.
saturating_mul
(
2
)
.
min
(
max_output_size
)
;
ret
.
resize
(
new_len
0
)
;
}
_
=
>
return
decompress_error
(
status
ret
)
}
}
}
pub
fn
decompress_slice_iter_to_slice
<
'
out
'
inp
>
(
out
:
&
'
out
mut
[
u8
]
it
:
impl
Iterator
<
Item
=
&
'
inp
[
u8
]
>
zlib_header
:
bool
ignore_adler32
:
bool
)
-
>
Result
<
usize
TINFLStatus
>
{
use
self
:
:
core
:
:
inflate_flags
:
:
*
;
let
mut
it
=
it
.
peekable
(
)
;
let
r
=
&
mut
DecompressorOxide
:
:
new
(
)
;
let
mut
out_pos
=
0
;
while
let
Some
(
in_buf
)
=
it
.
next
(
)
{
let
has_more
=
it
.
peek
(
)
.
is_some
(
)
;
let
flags
=
{
let
mut
f
=
TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF
;
if
zlib_header
{
f
|
=
TINFL_FLAG_PARSE_ZLIB_HEADER
;
}
if
ignore_adler32
{
f
|
=
TINFL_FLAG_IGNORE_ADLER32
;
}
if
has_more
{
f
|
=
TINFL_FLAG_HAS_MORE_INPUT
;
}
f
}
;
let
(
status
_input_read
bytes_written
)
=
decompress
(
r
in_buf
out
out_pos
flags
)
;
out_pos
+
=
bytes_written
;
match
status
{
TINFLStatus
:
:
NeedsMoreInput
=
>
continue
TINFLStatus
:
:
Done
=
>
return
Ok
(
out_pos
)
e
=
>
return
Err
(
e
)
}
}
Err
(
TINFLStatus
:
:
FailedCannotMakeProgress
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
{
decompress_slice_iter_to_slice
decompress_to_vec_zlib
decompress_to_vec_zlib_with_limit
DecompressError
TINFLStatus
}
;
const
ENCODED
:
[
u8
;
20
]
=
[
120
156
243
72
205
201
201
215
81
168
202
201
76
82
4
0
27
101
4
19
]
;
#
[
test
]
fn
decompress_vec
(
)
{
let
res
=
decompress_to_vec_zlib
(
&
ENCODED
[
.
.
]
)
.
unwrap
(
)
;
assert_eq
!
(
res
.
as_slice
(
)
&
b
"
Hello
zlib
!
"
[
.
.
]
)
;
}
#
[
test
]
fn
decompress_vec_with_high_limit
(
)
{
let
res
=
decompress_to_vec_zlib_with_limit
(
&
ENCODED
[
.
.
]
100_000
)
.
unwrap
(
)
;
assert_eq
!
(
res
.
as_slice
(
)
&
b
"
Hello
zlib
!
"
[
.
.
]
)
;
}
#
[
test
]
fn
fail_to_decompress_with_limit
(
)
{
let
res
=
decompress_to_vec_zlib_with_limit
(
&
ENCODED
[
.
.
]
8
)
;
match
res
{
Err
(
DecompressError
{
status
:
TINFLStatus
:
:
HasMoreOutput
.
.
}
)
=
>
(
)
_
=
>
panic
!
(
"
Decompression
output
size
limit
was
not
enforced
"
)
}
}
#
[
test
]
fn
test_decompress_slice_iter_to_slice
(
)
{
let
mut
out
=
[
0_u8
;
12_usize
]
;
let
r
=
decompress_slice_iter_to_slice
(
&
mut
out
Some
(
&
ENCODED
[
.
.
]
)
.
into_iter
(
)
true
false
)
;
assert_eq
!
(
r
Ok
(
12
)
)
;
assert_eq
!
(
&
out
[
.
.
12
]
&
b
"
Hello
zlib
!
"
[
.
.
]
)
;
for
chunk_size
in
1
.
.
13
{
let
mut
out
=
[
0_u8
;
12_usize
+
1
]
;
let
r
=
decompress_slice_iter_to_slice
(
&
mut
out
ENCODED
.
chunks
(
chunk_size
)
true
false
)
;
assert_eq
!
(
r
Ok
(
12
)
)
;
assert_eq
!
(
&
out
[
.
.
12
]
&
b
"
Hello
zlib
!
"
[
.
.
]
)
;
}
let
mut
out
=
[
0_u8
;
3_usize
]
;
let
r
=
decompress_slice_iter_to_slice
(
&
mut
out
ENCODED
.
chunks
(
7
)
true
false
)
;
assert
!
(
r
.
is_err
(
)
)
;
}
}
