use
std
:
:
{
mem
usize
}
;
use
std
:
:
io
:
:
Cursor
;
pub
mod
core
;
mod
output_buffer
;
use
self
:
:
core
:
:
*
;
const
TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS
:
i32
=
-
4
;
const
TINFL_STATUS_BAD_PARAM
:
i32
=
-
3
;
const
TINFL_STATUS_ADLER32_MISMATCH
:
i32
=
-
2
;
const
TINFL_STATUS_FAILED
:
i32
=
-
1
;
const
TINFL_STATUS_DONE
:
i32
=
0
;
const
TINFL_STATUS_NEEDS_MORE_INPUT
:
i32
=
1
;
const
TINFL_STATUS_HAS_MORE_OUTPUT
:
i32
=
2
;
#
[
repr
(
i8
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
TINFLStatus
{
FailedCannotMakeProgress
=
TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS
as
i8
BadParam
=
TINFL_STATUS_BAD_PARAM
as
i8
Adler32Mismatch
=
TINFL_STATUS_ADLER32_MISMATCH
as
i8
Failed
=
TINFL_STATUS_FAILED
as
i8
Done
=
TINFL_STATUS_DONE
as
i8
NeedsMoreInput
=
TINFL_STATUS_NEEDS_MORE_INPUT
as
i8
HasMoreOutput
=
TINFL_STATUS_HAS_MORE_OUTPUT
as
i8
}
impl
TINFLStatus
{
pub
fn
from_i32
(
value
:
i32
)
-
>
Option
<
TINFLStatus
>
{
use
self
:
:
TINFLStatus
:
:
*
;
match
value
{
TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS
=
>
Some
(
FailedCannotMakeProgress
)
TINFL_STATUS_BAD_PARAM
=
>
Some
(
BadParam
)
TINFL_STATUS_ADLER32_MISMATCH
=
>
Some
(
Adler32Mismatch
)
TINFL_STATUS_FAILED
=
>
Some
(
Failed
)
TINFL_STATUS_DONE
=
>
Some
(
Done
)
TINFL_STATUS_NEEDS_MORE_INPUT
=
>
Some
(
NeedsMoreInput
)
TINFL_STATUS_HAS_MORE_OUTPUT
=
>
Some
(
HasMoreOutput
)
_
=
>
None
}
}
}
#
[
inline
]
pub
fn
decompress_to_vec
(
input
:
&
[
u8
]
)
-
>
Result
<
Vec
<
u8
>
TINFLStatus
>
{
decompress_to_vec_inner
(
input
0
)
}
#
[
inline
]
pub
fn
decompress_to_vec_zlib
(
input
:
&
[
u8
]
)
-
>
Result
<
Vec
<
u8
>
TINFLStatus
>
{
decompress_to_vec_inner
(
input
inflate_flags
:
:
TINFL_FLAG_PARSE_ZLIB_HEADER
)
}
fn
decompress_to_vec_inner
(
input
:
&
[
u8
]
flags
:
u32
)
-
>
Result
<
Vec
<
u8
>
TINFLStatus
>
{
let
flags
=
flags
|
inflate_flags
:
:
TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF
;
let
mut
ret
=
Vec
:
:
with_capacity
(
input
.
len
(
)
*
2
)
;
unsafe
{
let
cap
=
ret
.
capacity
(
)
;
ret
.
set_len
(
cap
)
;
}
;
let
mut
decomp
=
unsafe
{
DecompressorOxide
:
:
with_init_state_only
(
)
}
;
let
mut
in_pos
=
0
;
let
mut
out_pos
=
0
;
loop
{
let
(
status
in_consumed
out_consumed
)
=
{
let
mut
c
=
Cursor
:
:
new
(
ret
.
as_mut_slice
(
)
)
;
c
.
set_position
(
out_pos
as
u64
)
;
decompress
(
&
mut
decomp
&
input
[
in_pos
.
.
]
&
mut
c
flags
)
}
;
in_pos
+
=
in_consumed
;
out_pos
+
=
out_consumed
;
match
status
{
TINFLStatus
:
:
Done
=
>
{
ret
.
truncate
(
out_pos
)
;
return
Ok
(
ret
)
;
}
TINFLStatus
:
:
HasMoreOutput
=
>
{
ret
.
reserve
(
out_pos
)
;
unsafe
{
let
cap
=
ret
.
capacity
(
)
;
ret
.
set_len
(
cap
)
;
}
}
_
=
>
return
Err
(
status
)
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
decompress_to_vec_zlib
;
#
[
test
]
fn
decompress_vec
(
)
{
let
encoded
=
[
120
156
243
72
205
201
201
215
81
168
202
201
76
82
4
0
27
101
4
19
]
;
let
res
=
decompress_to_vec_zlib
(
&
encoded
[
.
.
]
)
.
unwrap
(
)
;
assert_eq
!
(
res
.
as_slice
(
)
&
b
"
Hello
zlib
!
"
[
.
.
]
)
;
}
}
