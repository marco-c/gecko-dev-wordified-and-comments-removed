#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
adler
/
0
.
2
.
3
"
)
]
#
!
[
doc
(
test
(
attr
(
deny
(
unused_imports
unused_must_use
)
)
)
)
]
#
!
[
cfg_attr
(
docsrs
feature
(
doc_cfg
)
)
]
#
!
[
warn
(
missing_debug_implementations
)
]
#
!
[
forbid
(
unsafe_code
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
extern
crate
core
as
std
;
mod
algo
;
use
std
:
:
hash
:
:
Hasher
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
io
:
:
{
self
BufRead
}
;
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
Adler32
{
a
:
u16
b
:
u16
}
impl
Adler32
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
#
[
inline
]
pub
fn
from_checksum
(
sum
:
u32
)
-
>
Self
{
Adler32
{
a
:
sum
as
u16
b
:
(
sum
>
>
16
)
as
u16
}
}
#
[
inline
]
pub
fn
checksum
(
&
self
)
-
>
u32
{
(
u32
:
:
from
(
self
.
b
)
<
<
16
)
|
u32
:
:
from
(
self
.
a
)
}
pub
fn
write_slice
(
&
mut
self
bytes
:
&
[
u8
]
)
{
self
.
compute
(
bytes
)
;
}
}
impl
Default
for
Adler32
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Adler32
{
a
:
1
b
:
0
}
}
}
impl
Hasher
for
Adler32
{
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
u64
:
:
from
(
self
.
checksum
(
)
)
}
fn
write
(
&
mut
self
bytes
:
&
[
u8
]
)
{
self
.
write_slice
(
bytes
)
;
}
}
pub
fn
adler32_slice
(
data
:
&
[
u8
]
)
-
>
u32
{
let
mut
h
=
Adler32
:
:
new
(
)
;
h
.
write_slice
(
data
)
;
h
.
checksum
(
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
pub
fn
adler32_reader
<
R
:
BufRead
>
(
reader
:
&
mut
R
)
-
>
io
:
:
Result
<
u32
>
{
let
mut
h
=
Adler32
:
:
new
(
)
;
loop
{
let
len
=
{
let
buf
=
reader
.
fill_buf
(
)
?
;
if
buf
.
is_empty
(
)
{
return
Ok
(
h
.
checksum
(
)
)
;
}
h
.
write_slice
(
buf
)
;
buf
.
len
(
)
}
;
reader
.
consume
(
len
)
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
std
:
:
io
:
:
BufReader
;
#
[
test
]
fn
zeroes
(
)
{
assert_eq
!
(
adler32_slice
(
&
[
]
)
1
)
;
assert_eq
!
(
adler32_slice
(
&
[
0
]
)
1
|
1
<
<
16
)
;
assert_eq
!
(
adler32_slice
(
&
[
0
0
]
)
1
|
2
<
<
16
)
;
assert_eq
!
(
adler32_slice
(
&
[
0
;
100
]
)
0x00640001
)
;
assert_eq
!
(
adler32_slice
(
&
[
0
;
1024
]
)
0x04000001
)
;
assert_eq
!
(
adler32_slice
(
&
[
0
;
1024
*
1024
]
)
0x00f00001
)
;
}
#
[
test
]
fn
ones
(
)
{
assert_eq
!
(
adler32_slice
(
&
[
0xff
;
1024
]
)
0x79a6fc2e
)
;
assert_eq
!
(
adler32_slice
(
&
[
0xff
;
1024
*
1024
]
)
0x8e88ef11
)
;
}
#
[
test
]
fn
mixed
(
)
{
assert_eq
!
(
adler32_slice
(
&
[
1
]
)
2
|
2
<
<
16
)
;
assert_eq
!
(
adler32_slice
(
&
[
40
]
)
41
|
41
<
<
16
)
;
assert_eq
!
(
adler32_slice
(
&
[
0xA5
;
1024
*
1024
]
)
0xd5009ab1
)
;
}
#
[
test
]
fn
wiki
(
)
{
assert_eq
!
(
adler32_slice
(
b
"
Wikipedia
"
)
0x11E60398
)
;
}
#
[
test
]
fn
resume
(
)
{
let
mut
adler
=
Adler32
:
:
new
(
)
;
adler
.
write_slice
(
&
[
0xff
;
1024
]
)
;
let
partial
=
adler
.
checksum
(
)
;
assert_eq
!
(
partial
0x79a6fc2e
)
;
adler
.
write_slice
(
&
[
0xff
;
1024
*
1024
-
1024
]
)
;
assert_eq
!
(
adler
.
checksum
(
)
0x8e88ef11
)
;
let
mut
adler
=
Adler32
:
:
from_checksum
(
partial
)
;
adler
.
write_slice
(
&
[
0xff
;
1024
*
1024
-
1024
]
)
;
assert_eq
!
(
adler
.
checksum
(
)
0x8e88ef11
)
;
}
#
[
test
]
fn
bufread
(
)
{
fn
test
(
data
:
&
[
u8
]
checksum
:
u32
)
{
let
mut
buf
=
BufReader
:
:
new
(
data
)
;
let
real_sum
=
adler32_reader
(
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
checksum
real_sum
)
;
}
test
(
&
[
]
1
)
;
test
(
&
[
0
;
1024
]
0x04000001
)
;
test
(
&
[
0
;
1024
*
1024
]
0x00f00001
)
;
test
(
&
[
0xA5
;
1024
*
1024
]
0xd5009ab1
)
;
}
}
