use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
env
;
use
std
:
:
error
;
use
std
:
:
fs
:
:
{
self
File
}
;
use
std
:
:
fmt
;
use
std
:
:
io
:
:
{
BufRead
BufReader
}
;
use
std
:
:
path
:
:
{
PathBuf
Path
}
;
pub
struct
Config
{
cargo_metadata
:
bool
emit_includes
:
bool
required_libs
:
Vec
<
LibNames
>
copy_dlls
:
bool
}
#
[
derive
(
Debug
)
]
pub
struct
Library
{
pub
link_paths
:
Vec
<
PathBuf
>
pub
dll_paths
:
Vec
<
PathBuf
>
pub
include_paths
:
Vec
<
PathBuf
>
pub
cargo_metadata
:
Vec
<
String
>
pub
is_static
:
bool
pub
found_dlls
:
Vec
<
PathBuf
>
pub
found_libs
:
Vec
<
PathBuf
>
}
enum
MSVCTarget
{
X86
X64
}
impl
fmt
:
:
Display
for
MSVCTarget
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
MSVCTarget
:
:
X86
=
>
write
!
(
f
"
x86
-
windows
"
)
MSVCTarget
:
:
X64
=
>
write
!
(
f
"
x64
-
windows
"
)
}
}
}
#
[
derive
(
Debug
)
]
pub
enum
Error
{
DisabledByEnv
(
String
)
RequiredEnvMissing
(
String
)
NotMSVC
VcpkgNotFound
(
String
)
LibNotFound
(
String
)
#
[
doc
(
hidden
)
]
__Nonexhaustive
}
impl
error
:
:
Error
for
Error
{
fn
description
(
&
self
)
-
>
&
str
{
match
*
self
{
Error
:
:
DisabledByEnv
(
_
)
=
>
"
vcpkg
-
rs
requested
to
be
aborted
"
Error
:
:
RequiredEnvMissing
(
_
)
=
>
"
a
required
env
setting
is
missing
"
Error
:
:
NotMSVC
=
>
"
vcpkg
-
rs
only
can
only
find
libraries
for
MSVC
ABI
64
bit
builds
"
Error
:
:
VcpkgNotFound
(
_
)
=
>
"
could
not
find
Vcpkg
tree
"
Error
:
:
LibNotFound
(
_
)
=
>
"
could
not
find
library
in
Vcpkg
tree
"
Error
:
:
__Nonexhaustive
=
>
panic
!
(
)
}
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
match
*
self
{
_
=
>
None
}
}
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
match
*
self
{
Error
:
:
DisabledByEnv
(
ref
name
)
=
>
write
!
(
f
"
Aborted
because
{
}
is
set
"
name
)
Error
:
:
RequiredEnvMissing
(
ref
name
)
=
>
write
!
(
f
"
Aborted
because
{
}
is
not
set
"
name
)
Error
:
:
NotMSVC
=
>
{
write
!
(
f
"
the
vcpkg
-
rs
Vcpkg
build
helper
can
only
find
libraries
built
for
the
MSVC
ABI
.
"
)
}
Error
:
:
VcpkgNotFound
(
ref
detail
)
=
>
write
!
(
f
"
Could
not
find
Vcpkg
tree
:
{
}
"
detail
)
Error
:
:
LibNotFound
(
ref
detail
)
=
>
{
write
!
(
f
"
Could
not
find
library
in
Vcpkg
tree
{
}
"
detail
)
}
Error
:
:
__Nonexhaustive
=
>
panic
!
(
)
}
}
}
pub
fn
probe_package
(
name
:
&
str
)
-
>
Result
<
Library
Error
>
{
Config
:
:
new
(
)
.
probe
(
name
)
}
fn
find_vcpkg_root
(
)
-
>
Result
<
PathBuf
Error
>
{
if
let
Some
(
path
)
=
env
:
:
var_os
(
"
VCPKG_ROOT
"
)
{
return
Ok
(
PathBuf
:
:
from
(
path
)
)
;
}
let
local_app_data
=
try
!
(
env
:
:
var
(
"
LOCALAPPDATA
"
)
.
map_err
(
|
_
|
{
Error
:
:
VcpkgNotFound
(
"
Failed
to
read
LOCALAPPDATA
environment
variable
"
.
to_string
(
)
)
}
)
)
;
let
vcpkg_user_targets_path
=
Path
:
:
new
(
local_app_data
.
as_str
(
)
)
.
join
(
"
vcpkg
"
)
.
join
(
"
vcpkg
.
user
.
targets
"
)
;
let
file
=
try
!
(
File
:
:
open
(
vcpkg_user_targets_path
.
clone
(
)
)
.
map_err
(
|
_
|
{
Error
:
:
VcpkgNotFound
(
"
No
vcpkg
.
user
.
targets
found
.
Set
the
VCPKG_ROOT
environment
\
variable
or
run
'
vcpkg
integrate
install
'
"
.
to_string
(
)
)
}
)
)
;
let
file
=
BufReader
:
:
new
(
&
file
)
;
for
line
in
file
.
lines
(
)
{
let
line
=
try
!
(
line
.
map_err
(
|
_
|
{
Error
:
:
VcpkgNotFound
(
format
!
(
"
Parsing
of
{
}
failed
.
"
vcpkg_user_targets_path
.
to_string_lossy
(
)
.
to_owned
(
)
)
)
}
)
)
;
let
mut
split
=
line
.
split
(
"
Project
=
\
"
"
)
;
split
.
next
(
)
;
if
let
Some
(
found
)
=
split
.
next
(
)
{
if
let
Some
(
found
)
=
found
.
split_terminator
(
"
\
"
"
)
.
next
(
)
{
let
mut
vcpkg_root
=
PathBuf
:
:
from
(
found
)
;
if
!
(
vcpkg_root
.
pop
(
)
&
&
vcpkg_root
.
pop
(
)
&
&
vcpkg_root
.
pop
(
)
&
&
vcpkg_root
.
pop
(
)
)
{
return
Err
(
Error
:
:
VcpkgNotFound
(
format
!
(
"
Could
not
find
vcpkg
root
above
{
}
"
found
)
)
)
;
}
return
Ok
(
vcpkg_root
)
;
}
}
}
Err
(
Error
:
:
VcpkgNotFound
(
format
!
(
"
Project
location
not
found
parsing
{
}
.
"
vcpkg_user_targets_path
.
to_string_lossy
(
)
.
to_owned
(
)
)
)
)
}
fn
validate_vcpkg_root
(
path
:
&
PathBuf
)
-
>
Result
<
(
)
Error
>
{
let
mut
vcpkg_root_path
=
path
.
clone
(
)
;
vcpkg_root_path
.
push
(
"
.
vcpkg
-
root
"
)
;
if
vcpkg_root_path
.
exists
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
VcpkgNotFound
(
format
!
(
"
Could
not
find
Vcpkg
root
at
{
}
"
vcpkg_root_path
.
to_string_lossy
(
)
)
)
)
}
}
struct
LibNames
{
lib_stem
:
String
dll_stem
:
String
}
fn
find_vcpkg_target
(
msvc_target
:
&
MSVCTarget
)
-
>
Result
<
VcpkgTarget
Error
>
{
let
vcpkg_root
=
try
!
(
find_vcpkg_root
(
)
)
;
try
!
(
validate_vcpkg_root
(
&
vcpkg_root
)
)
;
let
static_lib
=
env
:
:
var
(
"
CARGO_CFG_TARGET_FEATURE
"
)
.
unwrap_or
(
String
:
:
new
(
)
)
.
contains
(
"
crt
-
static
"
)
;
let
mut
base
=
vcpkg_root
;
base
.
push
(
"
installed
"
)
;
let
static_appendage
=
if
static_lib
{
"
-
static
"
}
else
{
"
"
}
;
let
vcpkg_triple
=
format
!
(
"
{
}
{
}
"
msvc_target
.
to_string
(
)
static_appendage
)
;
base
.
push
(
vcpkg_triple
)
;
let
lib_path
=
base
.
join
(
"
lib
"
)
;
let
bin_path
=
base
.
join
(
"
bin
"
)
;
let
include_path
=
base
.
join
(
"
include
"
)
;
Ok
(
VcpkgTarget
{
lib_path
:
lib_path
bin_path
:
bin_path
include_path
:
include_path
is_static
:
static_lib
}
)
}
struct
VcpkgTarget
{
lib_path
:
PathBuf
bin_path
:
PathBuf
include_path
:
PathBuf
is_static
:
bool
}
impl
Config
{
pub
fn
new
(
)
-
>
Config
{
Config
{
cargo_metadata
:
true
emit_includes
:
false
required_libs
:
Vec
:
:
new
(
)
copy_dlls
:
true
}
}
pub
fn
lib_name
(
&
mut
self
lib_stem
:
&
str
)
-
>
&
mut
Config
{
self
.
required_libs
.
push
(
LibNames
{
lib_stem
:
lib_stem
.
to_owned
(
)
dll_stem
:
lib_stem
.
to_owned
(
)
}
)
;
self
}
pub
fn
lib_names
(
&
mut
self
lib_stem
:
&
str
dll_stem
:
&
str
)
-
>
&
mut
Config
{
self
.
required_libs
.
push
(
LibNames
{
lib_stem
:
lib_stem
.
to_owned
(
)
dll_stem
:
dll_stem
.
to_owned
(
)
}
)
;
self
}
pub
fn
cargo_metadata
(
&
mut
self
cargo_metadata
:
bool
)
-
>
&
mut
Config
{
self
.
cargo_metadata
=
cargo_metadata
;
self
}
pub
fn
emit_includes
(
&
mut
self
emit_includes
:
bool
)
-
>
&
mut
Config
{
self
.
emit_includes
=
emit_includes
;
self
}
pub
fn
copy_dlls
(
&
mut
self
copy_dlls
:
bool
)
-
>
&
mut
Config
{
self
.
copy_dlls
=
copy_dlls
;
self
}
pub
fn
probe
(
&
mut
self
port_name
:
&
str
)
-
>
Result
<
Library
Error
>
{
let
msvc_target
=
try
!
(
msvc_target
(
)
)
;
if
env
:
:
var_os
(
"
VCPKGRS_DISABLE
"
)
.
is_some
(
)
{
return
Err
(
Error
:
:
DisabledByEnv
(
"
VCPKGRS_DISABLE
"
.
to_owned
(
)
)
)
;
}
if
env
:
:
var_os
(
"
NO_VCPKG
"
)
.
is_some
(
)
{
return
Err
(
Error
:
:
DisabledByEnv
(
"
NO_VCPKG
"
.
to_owned
(
)
)
)
;
}
let
abort_var_name
=
format
!
(
"
VCPKGRS_NO_
{
}
"
envify
(
port_name
)
)
;
if
env
:
:
var_os
(
&
abort_var_name
)
.
is_some
(
)
{
return
Err
(
Error
:
:
DisabledByEnv
(
abort_var_name
)
)
;
}
let
abort_var_name
=
format
!
(
"
{
}
_NO_VCPKG
"
envify
(
port_name
)
)
;
if
env
:
:
var_os
(
&
abort_var_name
)
.
is_some
(
)
{
return
Err
(
Error
:
:
DisabledByEnv
(
abort_var_name
)
)
;
}
if
self
.
required_libs
.
is_empty
(
)
{
self
.
required_libs
.
push
(
LibNames
{
lib_stem
:
port_name
.
to_owned
(
)
dll_stem
:
port_name
.
to_owned
(
)
}
)
;
}
let
vcpkg_target
=
try
!
(
find_vcpkg_target
(
&
msvc_target
)
)
;
if
!
vcpkg_target
.
is_static
&
&
!
env
:
:
var_os
(
"
VCPKGRS_DYNAMIC
"
)
.
is_some
(
)
{
return
Err
(
Error
:
:
RequiredEnvMissing
(
"
VCPKGRS_DYNAMIC
"
.
to_owned
(
)
)
)
;
}
let
mut
lib
=
Library
:
:
new
(
vcpkg_target
.
is_static
)
;
if
self
.
emit_includes
{
lib
.
cargo_metadata
.
push
(
format
!
(
"
cargo
:
include
=
{
}
"
vcpkg_target
.
include_path
.
display
(
)
)
)
;
}
lib
.
include_paths
.
push
(
vcpkg_target
.
include_path
)
;
lib
.
cargo_metadata
.
push
(
format
!
(
"
cargo
:
rustc
-
link
-
search
=
native
=
{
}
"
vcpkg_target
.
lib_path
.
to_str
(
)
.
expect
(
"
failed
to
convert
string
type
"
)
)
)
;
lib
.
link_paths
.
push
(
vcpkg_target
.
lib_path
.
clone
(
)
)
;
if
!
vcpkg_target
.
is_static
{
lib
.
cargo_metadata
.
push
(
format
!
(
"
cargo
:
rustc
-
link
-
search
=
native
=
{
}
"
vcpkg_target
.
bin_path
.
to_str
(
)
.
expect
(
"
failed
to
convert
string
type
"
)
)
)
;
lib
.
dll_paths
.
push
(
vcpkg_target
.
bin_path
.
clone
(
)
)
;
}
drop
(
port_name
)
;
for
required_lib
in
&
self
.
required_libs
{
if
vcpkg_target
.
is_static
{
lib
.
cargo_metadata
.
push
(
format
!
(
"
cargo
:
rustc
-
link
-
lib
=
static
=
{
}
"
required_lib
.
lib_stem
)
)
;
}
else
{
lib
.
cargo_metadata
.
push
(
format
!
(
"
cargo
:
rustc
-
link
-
lib
=
{
}
"
required_lib
.
lib_stem
)
)
;
}
let
mut
lib_location
=
vcpkg_target
.
lib_path
.
clone
(
)
;
lib_location
.
push
(
required_lib
.
lib_stem
.
clone
(
)
)
;
lib_location
.
set_extension
(
"
lib
"
)
;
if
!
lib_location
.
exists
(
)
{
return
Err
(
Error
:
:
LibNotFound
(
lib_location
.
display
(
)
.
to_string
(
)
)
)
;
}
lib
.
found_libs
.
push
(
lib_location
)
;
if
!
vcpkg_target
.
is_static
{
let
mut
lib_location
=
vcpkg_target
.
bin_path
.
clone
(
)
;
lib_location
.
push
(
required_lib
.
dll_stem
.
clone
(
)
)
;
lib_location
.
set_extension
(
"
dll
"
)
;
if
!
lib_location
.
exists
(
)
{
return
Err
(
Error
:
:
LibNotFound
(
lib_location
.
display
(
)
.
to_string
(
)
)
)
;
}
lib
.
found_dlls
.
push
(
lib_location
)
;
}
}
if
self
.
copy_dlls
{
if
let
Some
(
target_dir
)
=
env
:
:
var_os
(
"
OUT_DIR
"
)
{
if
!
lib
.
found_dlls
.
is_empty
(
)
{
for
file
in
&
lib
.
found_dlls
{
let
mut
dest_path
=
Path
:
:
new
(
target_dir
.
as_os_str
(
)
)
.
to_path_buf
(
)
;
dest_path
.
push
(
Path
:
:
new
(
file
.
file_name
(
)
.
unwrap
(
)
)
)
;
try
!
(
fs
:
:
copy
(
file
&
dest_path
)
.
map_err
(
|
_
|
{
Error
:
:
LibNotFound
(
format
!
(
"
Can
'
t
copy
file
{
}
to
{
}
"
file
.
to_string_lossy
(
)
dest_path
.
to_string_lossy
(
)
)
)
}
)
)
;
println
!
(
"
vcpkg
build
helper
copied
{
}
to
{
}
"
file
.
to_string_lossy
(
)
dest_path
.
to_string_lossy
(
)
)
;
}
lib
.
cargo_metadata
.
push
(
format
!
(
"
cargo
:
rustc
-
link
-
search
=
native
=
{
}
"
env
:
:
var
(
"
OUT_DIR
"
)
.
unwrap
(
)
)
)
;
lib
.
cargo_metadata
.
push
(
format
!
(
"
cargo
:
rustc
-
link
-
search
=
{
}
"
env
:
:
var
(
"
OUT_DIR
"
)
.
unwrap
(
)
)
)
;
}
}
else
{
return
Err
(
Error
:
:
LibNotFound
(
"
Unable
to
get
OUT_DIR
"
.
to_owned
(
)
)
)
;
}
}
if
self
.
cargo_metadata
{
for
line
in
&
lib
.
cargo_metadata
{
println
!
(
"
{
}
"
line
)
;
}
}
Ok
(
lib
)
}
}
impl
Library
{
pub
fn
new
(
is_static
:
bool
)
-
>
Library
{
Library
{
link_paths
:
Vec
:
:
new
(
)
dll_paths
:
Vec
:
:
new
(
)
include_paths
:
Vec
:
:
new
(
)
cargo_metadata
:
Vec
:
:
new
(
)
is_static
:
is_static
found_dlls
:
Vec
:
:
new
(
)
found_libs
:
Vec
:
:
new
(
)
}
}
}
fn
envify
(
name
:
&
str
)
-
>
String
{
name
.
chars
(
)
.
map
(
|
c
|
c
.
to_ascii_uppercase
(
)
)
.
map
(
|
c
|
if
c
=
=
'
-
'
{
'
_
'
}
else
{
c
}
)
.
collect
(
)
}
fn
msvc_target
(
)
-
>
Result
<
MSVCTarget
Error
>
{
let
target
=
env
:
:
var
(
"
TARGET
"
)
.
unwrap_or
(
String
:
:
new
(
)
)
;
if
!
target
.
contains
(
"
-
pc
-
windows
-
msvc
"
)
{
Err
(
Error
:
:
NotMSVC
)
}
else
if
target
.
starts_with
(
"
x86_64
-
"
)
{
Ok
(
MSVCTarget
:
:
X64
)
}
else
{
Ok
(
MSVCTarget
:
:
X86
)
}
}
