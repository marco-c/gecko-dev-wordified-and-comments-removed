use
serde
:
:
{
Deserialize
Deserializer
Serialize
Serializer
}
;
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
deserialize_variant
{
(
de
:
expr
enum
:
tt
variant
:
ident
{
(
(
#
[
meta
:
meta
]
)
*
field
:
ident
:
typ
:
ty
)
*
(
)
?
}
)
=
>
(
{
let
var
=
{
/
/
Create
anonymous
type
#
[
derive
(
serde
:
:
Deserialize
)
]
struct
variant
{
(
(
#
[
meta
]
)
*
field
:
typ
)
*
}
<
variant
>
:
:
deserialize
(
de
)
?
}
;
/
/
Due
to
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
issues
/
86935
we
cannot
use
/
/
<
enum
>
:
:
variant
use
enum
:
:
*
;
variant
{
(
field
:
var
.
field
)
*
}
}
)
;
(
de
:
expr
enum
:
tt
variant
:
ident
(
typ
:
ty
)
)
=
>
(
{
let
var
=
<
typ
>
:
:
deserialize
(
de
)
?
;
<
enum
>
:
:
variant
(
var
)
}
)
;
(
de
:
expr
enum
:
tt
variant
:
ident
)
=
>
(
{
serde
:
:
de
:
:
IgnoredAny
:
:
deserialize
(
de
)
?
;
<
enum
>
:
:
variant
}
)
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
deserialize_match
{
(
tag
:
ident
de
:
ident
enum
:
ty
(
_
=
>
(
default_variant
:
tt
)
+
)
(
)
?
)
=
>
(
Ok
(
crate
:
:
deserialize_variant
!
(
de
enum
(
default_variant
)
+
)
)
)
;
(
tag
:
ident
de
:
ident
enum
:
ty
(
(
variant_tag
:
literal
=
>
(
variant
:
tt
)
+
)
)
*
(
_
=
>
(
default_variant
:
tt
)
+
)
(
)
?
)
=
>
(
match
tag
.
as_ref
(
)
{
(
variant_tag
=
>
Ok
(
crate
:
:
deserialize_variant
!
(
de
enum
(
variant
)
+
)
)
)
*
_
=
>
Ok
(
crate
:
:
deserialize_variant
!
(
de
enum
(
default_variant
)
+
)
)
}
)
;
(
tag
:
ident
de
:
ident
enum
:
ty
(
(
variant_tag
:
literal
=
>
(
variant
:
tt
)
+
)
)
*
(
)
?
)
=
>
(
match
tag
.
as_ref
(
)
{
(
variant_tag
=
>
Ok
(
crate
:
:
deserialize_variant
!
(
de
enum
(
variant
)
+
)
)
)
*
_
=
>
Err
(
A
:
:
Error
:
:
unknown_field
(
&
tag
&
[
(
variant_tag
)
+
]
)
)
}
)
;
}
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
impl_deserialize_for_internally_tagged_enum
{
(
enum
:
ty
tag
:
literal
(
cases
:
tt
)
*
)
=
>
{
impl
<
'
de
>
serde
:
:
de
:
:
Deserialize
<
'
de
>
for
enum
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
serde
:
:
de
:
:
Deserializer
<
'
de
>
{
use
serde
:
:
de
:
:
{
Error
MapAccess
Visitor
}
;
/
/
The
Visitor
struct
is
normally
used
for
state
but
none
is
needed
struct
TheVisitor
;
/
/
The
main
logic
of
the
deserializing
happens
in
the
Visitor
trait
impl
<
'
de
>
Visitor
<
'
de
>
for
TheVisitor
{
/
/
The
type
that
is
being
deserialized
type
Value
=
enum
;
/
/
Try
to
give
a
better
error
message
when
this
is
used
wrong
fn
expecting
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
write_str
(
"
expecting
map
with
tag
in
"
)
?
;
f
.
write_str
(
tag
)
}
/
/
The
xml
data
is
provided
as
an
opaque
map
/
/
that
map
is
parsed
into
the
type
fn
visit_map
<
A
>
(
self
mut
map
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
MapAccess
<
'
de
>
{
/
/
Here
the
assumption
is
made
that
only
one
attribute
/
/
exists
and
it
'
s
the
discriminator
(
enum
"
tag
"
)
.
let
entry
:
Option
<
(
String
String
)
>
=
map
.
next_entry
(
)
?
;
/
/
If
there
are
more
attributes
those
would
need
/
/
to
be
parsed
as
well
.
let
tag
=
match
entry
{
/
/
Return
an
error
if
the
no
attributes
are
found
/
/
and
indicate
that
the
tag
attribute
is
missing
.
None
=
>
Err
(
A
:
:
Error
:
:
missing_field
(
tag
)
)
/
/
Check
if
the
attribute
is
the
tag
Some
(
(
attribute
value
)
)
=
>
{
if
attribute
=
=
tag
{
/
/
return
the
value
of
the
tag
Ok
(
value
)
}
else
{
/
/
The
attribute
is
not
tag
return
an
error
/
/
indicating
that
there
is
an
unexpected
attribute
Err
(
A
:
:
Error
:
:
unknown_field
(
&
attribute
&
[
tag
]
)
)
}
}
}
?
;
let
de
=
serde
:
:
de
:
:
value
:
:
MapAccessDeserializer
:
:
new
(
map
)
;
crate
:
:
deserialize_match
!
(
tag
de
enum
(
cases
)
*
)
}
}
/
/
Tell
the
deserializer
to
deserialize
the
data
as
a
map
/
/
using
the
TheVisitor
as
the
decoder
deserializer
.
deserialize_map
(
TheVisitor
)
}
}
}
}
pub
mod
text_content
{
use
super
:
:
*
;
pub
fn
serialize
<
S
T
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
T
:
Serialize
{
#
[
derive
(
Serialize
)
]
struct
Field
<
'
a
T
>
{
#
[
serde
(
rename
=
"
text
"
)
]
value
:
&
'
a
T
}
Field
{
value
}
.
serialize
(
serializer
)
}
pub
fn
deserialize
<
'
de
D
T
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
T
:
Deserialize
<
'
de
>
{
#
[
derive
(
Deserialize
)
]
struct
Field
<
T
>
{
#
[
serde
(
rename
=
"
text
"
)
]
value
:
T
}
Ok
(
Field
:
:
deserialize
(
deserializer
)
?
.
value
)
}
}
