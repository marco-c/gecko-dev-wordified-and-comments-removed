use
crate
:
:
encoding
:
:
Decoder
;
use
crate
:
:
errors
:
:
Result
as
XmlResult
;
use
crate
:
:
escape
:
:
{
escape
resolve_predefined_entity
unescape_with
}
;
use
crate
:
:
name
:
:
{
LocalName
Namespace
QName
}
;
use
crate
:
:
reader
:
:
NsReader
;
use
crate
:
:
utils
:
:
{
is_whitespace
Bytes
}
;
use
std
:
:
fmt
:
:
{
self
Debug
Display
Formatter
}
;
use
std
:
:
iter
:
:
FusedIterator
;
use
std
:
:
{
borrow
:
:
Cow
ops
:
:
Range
}
;
#
[
derive
(
Clone
Eq
PartialEq
)
]
pub
struct
Attribute
<
'
a
>
{
pub
key
:
QName
<
'
a
>
pub
value
:
Cow
<
'
a
[
u8
]
>
}
impl
<
'
a
>
Attribute
<
'
a
>
{
#
[
cfg
(
any
(
doc
not
(
feature
=
"
encoding
"
)
)
)
]
pub
fn
unescape_value
(
&
self
)
-
>
XmlResult
<
Cow
<
'
a
str
>
>
{
self
.
unescape_value_with
(
resolve_predefined_entity
)
}
#
[
cfg
(
any
(
doc
not
(
feature
=
"
encoding
"
)
)
)
]
#
[
inline
]
pub
fn
unescape_value_with
<
'
entity
>
(
&
self
resolve_entity
:
impl
FnMut
(
&
str
)
-
>
Option
<
&
'
entity
str
>
)
-
>
XmlResult
<
Cow
<
'
a
str
>
>
{
self
.
decode_and_unescape_value_with
(
Decoder
:
:
utf8
(
)
resolve_entity
)
}
pub
fn
decode_and_unescape_value
(
&
self
decoder
:
Decoder
)
-
>
XmlResult
<
Cow
<
'
a
str
>
>
{
self
.
decode_and_unescape_value_with
(
decoder
resolve_predefined_entity
)
}
pub
fn
decode_and_unescape_value_with
<
'
entity
>
(
&
self
decoder
:
Decoder
resolve_entity
:
impl
FnMut
(
&
str
)
-
>
Option
<
&
'
entity
str
>
)
-
>
XmlResult
<
Cow
<
'
a
str
>
>
{
let
decoded
=
decoder
.
decode_cow
(
&
self
.
value
)
?
;
match
unescape_with
(
&
decoded
resolve_entity
)
?
{
Cow
:
:
Borrowed
(
_
)
=
>
Ok
(
decoded
)
Cow
:
:
Owned
(
s
)
=
>
Ok
(
s
.
into
(
)
)
}
}
#
[
inline
]
pub
fn
as_bool
(
&
self
)
-
>
Option
<
bool
>
{
match
self
.
value
.
as_ref
(
)
{
b
"
1
"
|
b
"
true
"
=
>
Some
(
true
)
b
"
0
"
|
b
"
false
"
=
>
Some
(
false
)
_
=
>
None
}
}
}
impl
<
'
a
>
Debug
for
Attribute
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Attribute
"
)
.
field
(
"
key
"
&
Bytes
(
self
.
key
.
as_ref
(
)
)
)
.
field
(
"
value
"
&
Bytes
(
&
self
.
value
)
)
.
finish
(
)
}
}
impl
<
'
a
>
From
<
(
&
'
a
[
u8
]
&
'
a
[
u8
]
)
>
for
Attribute
<
'
a
>
{
fn
from
(
val
:
(
&
'
a
[
u8
]
&
'
a
[
u8
]
)
)
-
>
Attribute
<
'
a
>
{
Attribute
{
key
:
QName
(
val
.
0
)
value
:
Cow
:
:
from
(
val
.
1
)
}
}
}
impl
<
'
a
>
From
<
(
&
'
a
str
&
'
a
str
)
>
for
Attribute
<
'
a
>
{
fn
from
(
val
:
(
&
'
a
str
&
'
a
str
)
)
-
>
Attribute
<
'
a
>
{
Attribute
{
key
:
QName
(
val
.
0
.
as_bytes
(
)
)
value
:
match
escape
(
val
.
1
)
{
Cow
:
:
Borrowed
(
s
)
=
>
Cow
:
:
Borrowed
(
s
.
as_bytes
(
)
)
Cow
:
:
Owned
(
s
)
=
>
Cow
:
:
Owned
(
s
.
into_bytes
(
)
)
}
}
}
}
impl
<
'
a
>
From
<
(
&
'
a
str
Cow
<
'
a
str
>
)
>
for
Attribute
<
'
a
>
{
fn
from
(
val
:
(
&
'
a
str
Cow
<
'
a
str
>
)
)
-
>
Attribute
<
'
a
>
{
Attribute
{
key
:
QName
(
val
.
0
.
as_bytes
(
)
)
value
:
match
escape
(
val
.
1
)
{
Cow
:
:
Borrowed
(
s
)
=
>
Cow
:
:
Borrowed
(
s
.
as_bytes
(
)
)
Cow
:
:
Owned
(
s
)
=
>
Cow
:
:
Owned
(
s
.
into_bytes
(
)
)
}
}
}
}
impl
<
'
a
>
From
<
Attr
<
&
'
a
[
u8
]
>
>
for
Attribute
<
'
a
>
{
#
[
inline
]
fn
from
(
attr
:
Attr
<
&
'
a
[
u8
]
>
)
-
>
Self
{
Self
{
key
:
attr
.
key
(
)
value
:
Cow
:
:
Borrowed
(
attr
.
value
(
)
)
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
Attributes
<
'
a
>
{
bytes
:
&
'
a
[
u8
]
state
:
IterState
}
impl
<
'
a
>
Attributes
<
'
a
>
{
#
[
inline
]
pub
(
crate
)
const
fn
wrap
(
buf
:
&
'
a
[
u8
]
pos
:
usize
html
:
bool
)
-
>
Self
{
Self
{
bytes
:
buf
state
:
IterState
:
:
new
(
pos
html
)
}
}
pub
const
fn
new
(
buf
:
&
'
a
str
pos
:
usize
)
-
>
Self
{
Self
:
:
wrap
(
buf
.
as_bytes
(
)
pos
false
)
}
pub
const
fn
html
(
buf
:
&
'
a
str
pos
:
usize
)
-
>
Self
{
Self
:
:
wrap
(
buf
.
as_bytes
(
)
pos
true
)
}
pub
fn
with_checks
(
&
mut
self
val
:
bool
)
-
>
&
mut
Attributes
<
'
a
>
{
self
.
state
.
check_duplicates
=
val
;
self
}
pub
fn
has_nil
<
R
>
(
&
mut
self
reader
:
&
NsReader
<
R
>
)
-
>
bool
{
use
crate
:
:
name
:
:
ResolveResult
:
:
*
;
self
.
any
(
|
attr
|
{
if
let
Ok
(
attr
)
=
attr
{
match
reader
.
resolve_attribute
(
attr
.
key
)
{
(
Bound
(
Namespace
(
b
"
http
:
/
/
www
.
w3
.
org
/
2001
/
XMLSchema
-
instance
"
)
)
LocalName
(
b
"
nil
"
)
)
=
>
attr
.
as_bool
(
)
.
unwrap_or_default
(
)
_
=
>
false
}
}
else
{
false
}
}
)
}
}
impl
<
'
a
>
Debug
for
Attributes
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Attributes
"
)
.
field
(
"
bytes
"
&
Bytes
(
&
self
.
bytes
)
)
.
field
(
"
state
"
&
self
.
state
)
.
finish
(
)
}
}
impl
<
'
a
>
Iterator
for
Attributes
<
'
a
>
{
type
Item
=
Result
<
Attribute
<
'
a
>
AttrError
>
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
match
self
.
state
.
next
(
self
.
bytes
)
{
None
=
>
None
Some
(
Ok
(
a
)
)
=
>
Some
(
Ok
(
a
.
map
(
|
range
|
&
self
.
bytes
[
range
]
)
.
into
(
)
)
)
Some
(
Err
(
e
)
)
=
>
Some
(
Err
(
e
)
)
}
}
}
impl
<
'
a
>
FusedIterator
for
Attributes
<
'
a
>
{
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
enum
AttrError
{
ExpectedEq
(
usize
)
ExpectedValue
(
usize
)
UnquotedValue
(
usize
)
ExpectedQuote
(
usize
u8
)
Duplicated
(
usize
usize
)
}
impl
Display
for
AttrError
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
Self
:
:
ExpectedEq
(
pos
)
=
>
write
!
(
f
r
#
"
position
{
}
:
attribute
key
must
be
directly
followed
by
=
or
space
"
#
pos
)
Self
:
:
ExpectedValue
(
pos
)
=
>
write
!
(
f
r
#
"
position
{
}
:
=
must
be
followed
by
an
attribute
value
"
#
pos
)
Self
:
:
UnquotedValue
(
pos
)
=
>
write
!
(
f
r
#
"
position
{
}
:
attribute
value
must
be
enclosed
in
"
or
'
"
#
pos
)
Self
:
:
ExpectedQuote
(
pos
quote
)
=
>
write
!
(
f
r
#
"
position
{
}
:
missing
closing
quote
{
}
in
attribute
value
"
#
pos
*
quote
as
char
)
Self
:
:
Duplicated
(
pos1
pos2
)
=
>
write
!
(
f
r
#
"
position
{
}
:
duplicated
attribute
previous
declaration
at
position
{
}
"
#
pos1
pos2
)
}
}
}
impl
std
:
:
error
:
:
Error
for
AttrError
{
}
#
[
derive
(
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
enum
Attr
<
T
>
{
DoubleQ
(
T
T
)
SingleQ
(
T
T
)
Unquoted
(
T
T
)
Empty
(
T
)
}
impl
<
T
>
Attr
<
T
>
{
#
[
inline
]
pub
fn
map
<
U
F
>
(
self
mut
f
:
F
)
-
>
Attr
<
U
>
where
F
:
FnMut
(
T
)
-
>
U
{
match
self
{
Attr
:
:
DoubleQ
(
key
value
)
=
>
Attr
:
:
DoubleQ
(
f
(
key
)
f
(
value
)
)
Attr
:
:
SingleQ
(
key
value
)
=
>
Attr
:
:
SingleQ
(
f
(
key
)
f
(
value
)
)
Attr
:
:
Empty
(
key
)
=
>
Attr
:
:
Empty
(
f
(
key
)
)
Attr
:
:
Unquoted
(
key
value
)
=
>
Attr
:
:
Unquoted
(
f
(
key
)
f
(
value
)
)
}
}
}
impl
<
'
a
>
Attr
<
&
'
a
[
u8
]
>
{
#
[
inline
]
pub
const
fn
key
(
&
self
)
-
>
QName
<
'
a
>
{
QName
(
match
self
{
Attr
:
:
DoubleQ
(
key
_
)
=
>
key
Attr
:
:
SingleQ
(
key
_
)
=
>
key
Attr
:
:
Empty
(
key
)
=
>
key
Attr
:
:
Unquoted
(
key
_
)
=
>
key
}
)
}
#
[
inline
]
pub
const
fn
value
(
&
self
)
-
>
&
'
a
[
u8
]
{
match
self
{
Attr
:
:
DoubleQ
(
_
value
)
=
>
value
Attr
:
:
SingleQ
(
_
value
)
=
>
value
Attr
:
:
Empty
(
_
)
=
>
&
[
]
Attr
:
:
Unquoted
(
_
value
)
=
>
value
}
}
}
impl
<
T
:
AsRef
<
[
u8
]
>
>
Debug
for
Attr
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
Attr
:
:
DoubleQ
(
key
value
)
=
>
f
.
debug_tuple
(
"
Attr
:
:
DoubleQ
"
)
.
field
(
&
Bytes
(
key
.
as_ref
(
)
)
)
.
field
(
&
Bytes
(
value
.
as_ref
(
)
)
)
.
finish
(
)
Attr
:
:
SingleQ
(
key
value
)
=
>
f
.
debug_tuple
(
"
Attr
:
:
SingleQ
"
)
.
field
(
&
Bytes
(
key
.
as_ref
(
)
)
)
.
field
(
&
Bytes
(
value
.
as_ref
(
)
)
)
.
finish
(
)
Attr
:
:
Empty
(
key
)
=
>
f
.
debug_tuple
(
"
Attr
:
:
Empty
"
)
.
field
(
&
Bytes
(
key
.
as_ref
(
)
)
)
.
finish
(
)
Attr
:
:
Unquoted
(
key
value
)
=
>
f
.
debug_tuple
(
"
Attr
:
:
Unquoted
"
)
.
field
(
&
Bytes
(
key
.
as_ref
(
)
)
)
.
field
(
&
Bytes
(
value
.
as_ref
(
)
)
)
.
finish
(
)
}
}
}
impl
<
T
>
From
<
Attr
<
T
>
>
for
(
T
Option
<
T
>
)
{
#
[
inline
]
fn
from
(
attr
:
Attr
<
T
>
)
-
>
Self
{
match
attr
{
Attr
:
:
DoubleQ
(
key
value
)
=
>
(
key
Some
(
value
)
)
Attr
:
:
SingleQ
(
key
value
)
=
>
(
key
Some
(
value
)
)
Attr
:
:
Empty
(
key
)
=
>
(
key
None
)
Attr
:
:
Unquoted
(
key
value
)
=
>
(
key
Some
(
value
)
)
}
}
}
type
AttrResult
=
Result
<
Attr
<
Range
<
usize
>
>
AttrError
>
;
#
[
derive
(
Clone
Copy
Debug
)
]
enum
State
{
Done
Next
(
usize
)
SkipValue
(
usize
)
SkipEqValue
(
usize
)
}
#
[
derive
(
Clone
Debug
)
]
pub
(
crate
)
struct
IterState
{
state
:
State
html
:
bool
check_duplicates
:
bool
keys
:
Vec
<
Range
<
usize
>
>
}
impl
IterState
{
pub
const
fn
new
(
offset
:
usize
html
:
bool
)
-
>
Self
{
Self
{
state
:
State
:
:
Next
(
offset
)
html
check_duplicates
:
true
keys
:
Vec
:
:
new
(
)
}
}
fn
recover
(
&
self
slice
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
match
self
.
state
{
State
:
:
Done
=
>
None
State
:
:
Next
(
offset
)
=
>
Some
(
offset
)
State
:
:
SkipValue
(
offset
)
=
>
self
.
skip_value
(
slice
offset
)
State
:
:
SkipEqValue
(
offset
)
=
>
self
.
skip_eq_value
(
slice
offset
)
}
}
#
[
inline
]
#
[
allow
(
clippy
:
:
manual_map
)
]
fn
skip_value
(
&
self
slice
:
&
[
u8
]
offset
:
usize
)
-
>
Option
<
usize
>
{
let
mut
iter
=
(
offset
.
.
)
.
zip
(
slice
[
offset
.
.
]
.
iter
(
)
)
;
match
iter
.
find
(
|
(
_
&
b
)
|
is_whitespace
(
b
)
)
{
Some
(
(
e
_
)
)
=
>
Some
(
e
)
None
=
>
None
}
}
#
[
inline
]
fn
skip_eq_value
(
&
self
slice
:
&
[
u8
]
offset
:
usize
)
-
>
Option
<
usize
>
{
let
mut
iter
=
(
offset
.
.
)
.
zip
(
slice
[
offset
.
.
]
.
iter
(
)
)
;
let
quote
=
match
iter
.
find
(
|
(
_
&
b
)
|
!
is_whitespace
(
b
)
)
{
Some
(
(
_
b
'
"
'
)
)
=
>
b
'
"
'
Some
(
(
_
b
'
\
'
'
)
)
=
>
b
'
\
'
'
Some
(
(
offset
_
)
)
=
>
return
self
.
skip_value
(
slice
offset
)
None
=
>
return
None
}
;
match
iter
.
find
(
|
(
_
&
b
)
|
b
=
=
quote
)
{
Some
(
(
e
b
'
"
'
)
)
=
>
Some
(
e
)
Some
(
(
e
_
)
)
=
>
Some
(
e
)
None
=
>
None
}
}
#
[
inline
]
fn
check_for_duplicates
(
&
mut
self
slice
:
&
[
u8
]
key
:
Range
<
usize
>
)
-
>
Result
<
Range
<
usize
>
AttrError
>
{
if
self
.
check_duplicates
{
if
let
Some
(
prev
)
=
self
.
keys
.
iter
(
)
.
find
(
|
r
|
slice
[
(
*
r
)
.
clone
(
)
]
=
=
slice
[
key
.
clone
(
)
]
)
{
return
Err
(
AttrError
:
:
Duplicated
(
key
.
start
prev
.
start
)
)
;
}
self
.
keys
.
push
(
key
.
clone
(
)
)
;
}
Ok
(
key
)
}
#
[
inline
]
fn
key_only
(
&
mut
self
slice
:
&
[
u8
]
key
:
Range
<
usize
>
offset
:
usize
)
-
>
Option
<
AttrResult
>
{
Some
(
if
self
.
html
{
self
.
check_for_duplicates
(
slice
key
)
.
map
(
Attr
:
:
Empty
)
}
else
{
Err
(
AttrError
:
:
ExpectedEq
(
offset
)
)
}
)
}
#
[
inline
]
fn
double_q
(
&
mut
self
key
:
Range
<
usize
>
value
:
Range
<
usize
>
)
-
>
Option
<
AttrResult
>
{
self
.
state
=
State
:
:
Next
(
value
.
end
+
1
)
;
Some
(
Ok
(
Attr
:
:
DoubleQ
(
key
value
)
)
)
}
#
[
inline
]
fn
single_q
(
&
mut
self
key
:
Range
<
usize
>
value
:
Range
<
usize
>
)
-
>
Option
<
AttrResult
>
{
self
.
state
=
State
:
:
Next
(
value
.
end
+
1
)
;
Some
(
Ok
(
Attr
:
:
SingleQ
(
key
value
)
)
)
}
pub
fn
next
(
&
mut
self
slice
:
&
[
u8
]
)
-
>
Option
<
AttrResult
>
{
let
mut
iter
=
match
self
.
recover
(
slice
)
{
Some
(
offset
)
=
>
(
offset
.
.
)
.
zip
(
slice
[
offset
.
.
]
.
iter
(
)
)
None
=
>
return
None
}
;
let
start_key
=
match
iter
.
find
(
|
(
_
&
b
)
|
!
is_whitespace
(
b
)
)
{
Some
(
(
s
_
)
)
=
>
s
None
=
>
{
self
.
state
=
State
:
:
Done
;
return
None
;
}
}
;
let
(
key
offset
)
=
match
iter
.
find
(
|
(
_
&
b
)
|
b
=
=
b
'
=
'
|
|
is_whitespace
(
b
)
)
{
Some
(
(
e
b
'
=
'
)
)
=
>
(
start_key
.
.
e
e
)
Some
(
(
e
_
)
)
=
>
match
iter
.
find
(
|
(
_
&
b
)
|
!
is_whitespace
(
b
)
)
{
Some
(
(
offset
b
'
=
'
)
)
=
>
(
start_key
.
.
e
offset
)
Some
(
(
offset
_
)
)
=
>
{
self
.
state
=
State
:
:
Next
(
offset
)
;
return
self
.
key_only
(
slice
start_key
.
.
e
offset
)
;
}
None
=
>
{
self
.
state
=
State
:
:
Done
;
return
self
.
key_only
(
slice
start_key
.
.
e
slice
.
len
(
)
)
;
}
}
None
=
>
{
self
.
state
=
State
:
:
Done
;
let
e
=
slice
.
len
(
)
;
return
self
.
key_only
(
slice
start_key
.
.
e
e
)
;
}
}
;
let
key
=
match
self
.
check_for_duplicates
(
slice
key
)
{
Err
(
e
)
=
>
{
self
.
state
=
State
:
:
SkipEqValue
(
offset
)
;
return
Some
(
Err
(
e
)
)
;
}
Ok
(
key
)
=
>
key
}
;
let
(
start_value
quote
)
=
match
iter
.
find
(
|
(
_
&
b
)
|
!
is_whitespace
(
b
)
)
{
Some
(
(
s
b
'
"
'
)
)
=
>
(
s
+
1
b
'
"
'
)
Some
(
(
s
b
'
\
'
'
)
)
=
>
(
s
+
1
b
'
\
'
'
)
Some
(
(
s
_
)
)
if
self
.
html
=
>
{
let
end
=
match
iter
.
find
(
|
(
_
&
b
)
|
is_whitespace
(
b
)
)
{
Some
(
(
e
_
)
)
=
>
e
None
=
>
slice
.
len
(
)
}
;
self
.
state
=
State
:
:
Next
(
end
)
;
return
Some
(
Ok
(
Attr
:
:
Unquoted
(
key
s
.
.
end
)
)
)
;
}
Some
(
(
s
_
)
)
=
>
{
self
.
state
=
State
:
:
SkipValue
(
s
)
;
return
Some
(
Err
(
AttrError
:
:
UnquotedValue
(
s
)
)
)
;
}
None
=
>
{
self
.
state
=
State
:
:
Done
;
return
Some
(
Err
(
AttrError
:
:
ExpectedValue
(
slice
.
len
(
)
)
)
)
;
}
}
;
match
iter
.
find
(
|
(
_
&
b
)
|
b
=
=
quote
)
{
Some
(
(
e
b
'
"
'
)
)
=
>
self
.
double_q
(
key
start_value
.
.
e
)
Some
(
(
e
_
)
)
=
>
self
.
single_q
(
key
start_value
.
.
e
)
None
=
>
{
self
.
state
=
State
:
:
Done
;
Some
(
Err
(
AttrError
:
:
ExpectedQuote
(
slice
.
len
(
)
quote
)
)
)
}
}
}
}
#
[
cfg
(
test
)
]
mod
xml
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
mod
single
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
fn
single_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
double_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
"
value
"
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
unquoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
value
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
UnquotedValue
(
8
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_only
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedEq
(
7
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_start_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
'
key
'
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
'
key
'
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_contains_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
&
jey
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
&
jey
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
missed_value
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedValue
(
8
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
mod
first
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
fn
single_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
'
value
'
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
double_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
"
value
"
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
unquoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
value
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
UnquotedValue
(
8
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_only
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedEq
(
8
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_start_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
'
key
'
=
'
value
'
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
'
key
'
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_contains_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
&
jey
=
'
value
'
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
&
jey
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
missed_value
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
UnquotedValue
(
9
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
UnquotedValue
(
9
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedEq
(
29
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
UnquotedValue
(
9
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedEq
(
29
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
UnquotedValue
(
9
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedEq
(
19
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedEq
(
30
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
mod
sparsed
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
fn
single_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
double_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
"
value
"
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
unquoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
value
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
UnquotedValue
(
10
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_only
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedEq
(
8
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_start_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
'
key
'
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
'
key
'
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_contains_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
&
jey
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
&
jey
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
missed_value
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedValue
(
10
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
mod
duplicated
{
use
super
:
:
*
;
mod
with_check
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
fn
single_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
'
value
'
key
=
'
dup
'
another
=
'
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
Duplicated
(
16
4
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
double_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
'
value
'
key
=
"
dup
"
another
=
'
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
Duplicated
(
16
4
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
unquoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
'
value
'
key
=
dup
another
=
'
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
Duplicated
(
16
4
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_only
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
'
value
'
key
another
=
'
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedEq
(
20
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
mod
without_check
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
fn
single_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
'
value
'
key
=
'
dup
'
another
=
'
'
"
#
3
)
;
iter
.
with_checks
(
false
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
dup
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
double_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
'
value
'
key
=
"
dup
"
another
=
'
'
"
#
3
)
;
iter
.
with_checks
(
false
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
dup
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
unquoted
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
'
value
'
key
=
dup
another
=
'
'
"
#
3
)
;
iter
.
with_checks
(
false
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
UnquotedValue
(
20
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_only
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
key
=
'
value
'
key
another
=
'
'
"
#
3
)
;
iter
.
with_checks
(
false
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedEq
(
20
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
}
#
[
test
]
fn
mixed_quote
(
)
{
let
mut
iter
=
Attributes
:
:
new
(
r
#
"
tag
a
=
'
a
'
b
=
"
b
"
c
=
'
cc
"
cc
'
d
=
"
dd
'
dd
"
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
a
"
)
value
:
Cow
:
:
Borrowed
(
b
"
a
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
b
"
)
value
:
Cow
:
:
Borrowed
(
b
"
b
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
c
"
)
value
:
Cow
:
:
Borrowed
(
br
#
"
cc
"
cc
"
#
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
d
"
)
value
:
Cow
:
:
Borrowed
(
b
"
dd
'
dd
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
#
[
cfg
(
test
)
]
mod
html
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
mod
single
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
fn
single_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
double_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
"
value
"
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
unquoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
value
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_only
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
&
[
]
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_start_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
'
key
'
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
'
key
'
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_contains_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
&
jey
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
&
jey
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
missed_value
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedValue
(
8
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
mod
first
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
fn
single_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
'
value
'
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
double_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
"
value
"
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
unquoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
value
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_only
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
&
[
]
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_start_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
'
key
'
=
'
value
'
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
'
key
'
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_contains_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
&
jey
=
'
value
'
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
&
jey
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
regular
"
)
value
:
Cow
:
:
Borrowed
(
b
"
attribute
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
missed_value
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
regular
=
'
attribute
'
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
regular
=
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
'
attribute
'
"
)
value
:
Cow
:
:
Borrowed
(
&
[
]
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
regular
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
=
'
attribute
'
"
)
value
:
Cow
:
:
Borrowed
(
&
[
]
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
regular
=
'
attribute
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
regular
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
=
"
)
value
:
Cow
:
:
Borrowed
(
&
[
]
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
'
attribute
'
"
)
value
:
Cow
:
:
Borrowed
(
&
[
]
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
mod
sparsed
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
fn
single_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
double_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
"
value
"
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
unquoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
value
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_only
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
&
[
]
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_start_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
'
key
'
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
'
key
'
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_contains_invalid
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
&
jey
=
'
value
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
&
jey
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
missed_value
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
ExpectedValue
(
10
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
mod
duplicated
{
use
super
:
:
*
;
mod
with_check
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
fn
single_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
'
value
'
key
=
'
dup
'
another
=
'
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
Duplicated
(
16
4
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
double_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
'
value
'
key
=
"
dup
"
another
=
'
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
Duplicated
(
16
4
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
unquoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
'
value
'
key
=
dup
another
=
'
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
Duplicated
(
16
4
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_only
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
'
value
'
key
another
=
'
'
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Err
(
AttrError
:
:
Duplicated
(
16
4
)
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
mod
without_check
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
fn
single_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
'
value
'
key
=
'
dup
'
another
=
'
'
"
#
3
)
;
iter
.
with_checks
(
false
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
dup
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
double_quoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
'
value
'
key
=
"
dup
"
another
=
'
'
"
#
3
)
;
iter
.
with_checks
(
false
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
dup
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
unquoted
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
'
value
'
key
=
dup
another
=
'
'
"
#
3
)
;
iter
.
with_checks
(
false
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
dup
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
key_only
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
key
=
'
value
'
key
another
=
'
'
"
#
3
)
;
iter
.
with_checks
(
false
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
b
"
value
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
key
"
)
value
:
Cow
:
:
Borrowed
(
&
[
]
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
another
"
)
value
:
Cow
:
:
Borrowed
(
b
"
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
}
#
[
test
]
fn
mixed_quote
(
)
{
let
mut
iter
=
Attributes
:
:
html
(
r
#
"
tag
a
=
'
a
'
b
=
"
b
"
c
=
'
cc
"
cc
'
d
=
"
dd
'
dd
"
"
#
3
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
a
"
)
value
:
Cow
:
:
Borrowed
(
b
"
a
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
b
"
)
value
:
Cow
:
:
Borrowed
(
b
"
b
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
c
"
)
value
:
Cow
:
:
Borrowed
(
br
#
"
cc
"
cc
"
#
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
Some
(
Ok
(
Attribute
{
key
:
QName
(
b
"
d
"
)
value
:
Cow
:
:
Borrowed
(
b
"
dd
'
dd
"
)
}
)
)
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
assert_eq
!
(
iter
.
next
(
)
None
)
;
}
}
