use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
crate
:
:
encoding
:
:
UTF8_BOM
;
use
crate
:
:
events
:
:
{
attributes
:
:
Attribute
BytesCData
BytesPI
BytesStart
BytesText
Event
}
;
#
[
cfg
(
feature
=
"
async
-
tokio
"
)
]
mod
async_tokio
;
#
[
cfg
(
feature
=
"
serialize
"
)
]
use
{
crate
:
:
se
:
:
SeError
serde
:
:
Serialize
}
;
#
[
derive
(
Clone
)
]
pub
struct
Writer
<
W
>
{
writer
:
W
indent
:
Option
<
Indentation
>
}
impl
<
W
>
Writer
<
W
>
{
pub
const
fn
new
(
inner
:
W
)
-
>
Writer
<
W
>
{
Writer
{
writer
:
inner
indent
:
None
}
}
pub
fn
new_with_indent
(
inner
:
W
indent_char
:
u8
indent_size
:
usize
)
-
>
Writer
<
W
>
{
Writer
{
writer
:
inner
indent
:
Some
(
Indentation
:
:
new
(
indent_char
indent_size
)
)
}
}
pub
fn
into_inner
(
self
)
-
>
W
{
self
.
writer
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
W
{
&
mut
self
.
writer
}
pub
const
fn
get_ref
(
&
self
)
-
>
&
W
{
&
self
.
writer
}
#
[
must_use
]
pub
fn
create_element
<
'
a
N
>
(
&
'
a
mut
self
name
:
N
)
-
>
ElementWriter
<
'
a
W
>
where
N
:
Into
<
Cow
<
'
a
str
>
>
{
ElementWriter
{
writer
:
self
start_tag
:
BytesStart
:
:
new
(
name
)
state
:
AttributeIndent
:
:
NoneAttributesWritten
spaces
:
Vec
:
:
new
(
)
}
}
}
impl
<
W
:
Write
>
Writer
<
W
>
{
pub
fn
write_bom
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
write
(
UTF8_BOM
)
}
pub
fn
write_event
<
'
a
E
:
Into
<
Event
<
'
a
>
>
>
(
&
mut
self
event
:
E
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
next_should_line_break
=
true
;
let
result
=
match
event
.
into
(
)
{
Event
:
:
Start
(
e
)
=
>
{
let
result
=
self
.
write_wrapped
(
b
"
<
"
&
e
b
"
>
"
)
;
if
let
Some
(
i
)
=
self
.
indent
.
as_mut
(
)
{
i
.
grow
(
)
;
}
result
}
Event
:
:
End
(
e
)
=
>
{
if
let
Some
(
i
)
=
self
.
indent
.
as_mut
(
)
{
i
.
shrink
(
)
;
}
self
.
write_wrapped
(
b
"
<
/
"
&
e
b
"
>
"
)
}
Event
:
:
Empty
(
e
)
=
>
self
.
write_wrapped
(
b
"
<
"
&
e
b
"
/
>
"
)
Event
:
:
Text
(
e
)
=
>
{
next_should_line_break
=
false
;
self
.
write
(
&
e
)
}
Event
:
:
Comment
(
e
)
=
>
self
.
write_wrapped
(
b
"
<
!
-
-
"
&
e
b
"
-
-
>
"
)
Event
:
:
CData
(
e
)
=
>
{
next_should_line_break
=
false
;
self
.
write
(
b
"
<
!
[
CDATA
[
"
)
?
;
self
.
write
(
&
e
)
?
;
self
.
write
(
b
"
]
]
>
"
)
}
Event
:
:
Decl
(
e
)
=
>
self
.
write_wrapped
(
b
"
<
?
"
&
e
b
"
?
>
"
)
Event
:
:
PI
(
e
)
=
>
self
.
write_wrapped
(
b
"
<
?
"
&
e
b
"
?
>
"
)
Event
:
:
DocType
(
e
)
=
>
self
.
write_wrapped
(
b
"
<
!
DOCTYPE
"
&
e
b
"
>
"
)
Event
:
:
Eof
=
>
Ok
(
(
)
)
}
;
if
let
Some
(
i
)
=
self
.
indent
.
as_mut
(
)
{
i
.
should_line_break
=
next_should_line_break
;
}
result
}
#
[
inline
]
pub
(
crate
)
fn
write
(
&
mut
self
value
:
&
[
u8
]
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
writer
.
write_all
(
value
)
.
map_err
(
Into
:
:
into
)
}
#
[
inline
]
fn
write_wrapped
(
&
mut
self
before
:
&
[
u8
]
value
:
&
[
u8
]
after
:
&
[
u8
]
)
-
>
io
:
:
Result
<
(
)
>
{
if
let
Some
(
ref
i
)
=
self
.
indent
{
if
i
.
should_line_break
{
self
.
writer
.
write_all
(
b
"
\
n
"
)
?
;
self
.
writer
.
write_all
(
i
.
current
(
)
)
?
;
}
}
self
.
write
(
before
)
?
;
self
.
write
(
value
)
?
;
self
.
write
(
after
)
?
;
Ok
(
(
)
)
}
pub
fn
write_indent
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
if
let
Some
(
ref
i
)
=
self
.
indent
{
self
.
writer
.
write_all
(
b
"
\
n
"
)
?
;
self
.
writer
.
write_all
(
i
.
current
(
)
)
?
;
}
Ok
(
(
)
)
}
#
[
cfg
(
feature
=
"
serialize
"
)
]
pub
fn
write_serializable
<
T
:
Serialize
>
(
&
mut
self
tag_name
:
&
str
content
:
&
T
)
-
>
Result
<
(
)
SeError
>
{
use
crate
:
:
se
:
:
{
Indent
Serializer
}
;
self
.
write_indent
(
)
?
;
let
mut
fmt
=
ToFmtWrite
(
&
mut
self
.
writer
)
;
let
mut
serializer
=
Serializer
:
:
with_root
(
&
mut
fmt
Some
(
tag_name
)
)
?
;
if
let
Some
(
indent
)
=
&
mut
self
.
indent
{
serializer
.
set_indent
(
Indent
:
:
Borrow
(
indent
)
)
;
}
content
.
serialize
(
serializer
)
?
;
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
)
]
enum
AttributeIndent
{
NoneAttributesWritten
WriteSpaces
(
usize
)
Spaces
(
usize
)
WriteConfigured
(
usize
)
Configured
(
usize
)
}
pub
struct
ElementWriter
<
'
a
W
>
{
writer
:
&
'
a
mut
Writer
<
W
>
start_tag
:
BytesStart
<
'
a
>
state
:
AttributeIndent
spaces
:
Vec
<
u8
>
}
impl
<
'
a
W
>
ElementWriter
<
'
a
W
>
{
pub
fn
with_attribute
<
'
b
I
>
(
mut
self
attr
:
I
)
-
>
Self
where
I
:
Into
<
Attribute
<
'
b
>
>
{
self
.
write_attr
(
attr
.
into
(
)
)
;
self
}
pub
fn
with_attributes
<
'
b
I
>
(
mut
self
attributes
:
I
)
-
>
Self
where
I
:
IntoIterator
I
:
:
Item
:
Into
<
Attribute
<
'
b
>
>
{
let
mut
iter
=
attributes
.
into_iter
(
)
;
if
let
Some
(
attr
)
=
iter
.
next
(
)
{
self
.
write_attr
(
attr
.
into
(
)
)
;
self
.
start_tag
.
extend_attributes
(
iter
)
;
}
self
}
pub
fn
new_line
(
mut
self
)
-
>
Self
{
if
let
Some
(
i
)
=
self
.
writer
.
indent
.
as_mut
(
)
{
match
self
.
state
{
AttributeIndent
:
:
NoneAttributesWritten
=
>
{
self
.
state
=
AttributeIndent
:
:
WriteConfigured
(
i
.
indent_size
)
}
AttributeIndent
:
:
WriteSpaces
(
_
)
=
>
{
}
AttributeIndent
:
:
Spaces
(
indent
)
=
>
{
self
.
state
=
AttributeIndent
:
:
WriteSpaces
(
indent
)
}
AttributeIndent
:
:
WriteConfigured
(
_
)
=
>
{
}
AttributeIndent
:
:
Configured
(
indent
)
=
>
{
self
.
state
=
AttributeIndent
:
:
WriteConfigured
(
indent
)
}
}
self
.
start_tag
.
push_newline
(
)
;
}
;
self
}
fn
write_attr
<
'
b
>
(
&
mut
self
attr
:
Attribute
<
'
b
>
)
{
if
let
Some
(
i
)
=
self
.
writer
.
indent
.
as_mut
(
)
{
self
.
state
=
match
self
.
state
{
AttributeIndent
:
:
NoneAttributesWritten
=
>
{
self
.
start_tag
.
push_attribute
(
attr
)
;
AttributeIndent
:
:
Spaces
(
self
.
start_tag
.
name
(
)
.
as_ref
(
)
.
len
(
)
+
2
)
}
AttributeIndent
:
:
WriteSpaces
(
indent
)
=
>
{
if
self
.
spaces
.
len
(
)
<
indent
{
self
.
spaces
.
resize
(
indent
b
'
'
)
;
}
self
.
start_tag
.
push_indent
(
&
self
.
spaces
[
.
.
indent
]
)
;
self
.
start_tag
.
push_attr
(
attr
.
into
(
)
)
;
AttributeIndent
:
:
Spaces
(
indent
)
}
AttributeIndent
:
:
Spaces
(
indent
)
=
>
{
self
.
start_tag
.
push_attribute
(
attr
)
;
AttributeIndent
:
:
Spaces
(
indent
)
}
AttributeIndent
:
:
WriteConfigured
(
indent
)
=
>
{
self
.
start_tag
.
push_indent
(
i
.
additional
(
indent
)
)
;
self
.
start_tag
.
push_attr
(
attr
.
into
(
)
)
;
AttributeIndent
:
:
Configured
(
indent
)
}
AttributeIndent
:
:
Configured
(
indent
)
=
>
{
self
.
start_tag
.
push_attribute
(
attr
)
;
AttributeIndent
:
:
Configured
(
indent
)
}
}
;
}
else
{
self
.
start_tag
.
push_attribute
(
attr
)
;
}
}
}
impl
<
'
a
W
:
Write
>
ElementWriter
<
'
a
W
>
{
pub
fn
write_text_content
(
self
text
:
BytesText
)
-
>
io
:
:
Result
<
&
'
a
mut
Writer
<
W
>
>
{
self
.
writer
.
write_event
(
Event
:
:
Start
(
self
.
start_tag
.
borrow
(
)
)
)
?
;
self
.
writer
.
write_event
(
Event
:
:
Text
(
text
)
)
?
;
self
.
writer
.
write_event
(
Event
:
:
End
(
self
.
start_tag
.
to_end
(
)
)
)
?
;
Ok
(
self
.
writer
)
}
pub
fn
write_cdata_content
(
self
text
:
BytesCData
)
-
>
io
:
:
Result
<
&
'
a
mut
Writer
<
W
>
>
{
self
.
writer
.
write_event
(
Event
:
:
Start
(
self
.
start_tag
.
borrow
(
)
)
)
?
;
self
.
writer
.
write_event
(
Event
:
:
CData
(
text
)
)
?
;
self
.
writer
.
write_event
(
Event
:
:
End
(
self
.
start_tag
.
to_end
(
)
)
)
?
;
Ok
(
self
.
writer
)
}
pub
fn
write_pi_content
(
self
pi
:
BytesPI
)
-
>
io
:
:
Result
<
&
'
a
mut
Writer
<
W
>
>
{
self
.
writer
.
write_event
(
Event
:
:
Start
(
self
.
start_tag
.
borrow
(
)
)
)
?
;
self
.
writer
.
write_event
(
Event
:
:
PI
(
pi
)
)
?
;
self
.
writer
.
write_event
(
Event
:
:
End
(
self
.
start_tag
.
to_end
(
)
)
)
?
;
Ok
(
self
.
writer
)
}
pub
fn
write_empty
(
self
)
-
>
io
:
:
Result
<
&
'
a
mut
Writer
<
W
>
>
{
self
.
writer
.
write_event
(
Event
:
:
Empty
(
self
.
start_tag
)
)
?
;
Ok
(
self
.
writer
)
}
pub
fn
write_inner_content
<
F
>
(
self
closure
:
F
)
-
>
io
:
:
Result
<
&
'
a
mut
Writer
<
W
>
>
where
F
:
FnOnce
(
&
mut
Writer
<
W
>
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
writer
.
write_event
(
Event
:
:
Start
(
self
.
start_tag
.
borrow
(
)
)
)
?
;
closure
(
self
.
writer
)
?
;
self
.
writer
.
write_event
(
Event
:
:
End
(
self
.
start_tag
.
to_end
(
)
)
)
?
;
Ok
(
self
.
writer
)
}
}
#
[
cfg
(
feature
=
"
serialize
"
)
]
pub
(
crate
)
struct
ToFmtWrite
<
T
>
(
pub
T
)
;
#
[
cfg
(
feature
=
"
serialize
"
)
]
impl
<
T
>
std
:
:
fmt
:
:
Write
for
ToFmtWrite
<
T
>
where
T
:
std
:
:
io
:
:
Write
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
std
:
:
fmt
:
:
Result
{
self
.
0
.
write_all
(
s
.
as_bytes
(
)
)
.
map_err
(
|
_
|
std
:
:
fmt
:
:
Error
)
}
}
#
[
derive
(
Clone
)
]
pub
(
crate
)
struct
Indentation
{
should_line_break
:
bool
indent_char
:
u8
indent_size
:
usize
indents
:
Vec
<
u8
>
current_indent_len
:
usize
}
impl
Indentation
{
pub
fn
new
(
indent_char
:
u8
indent_size
:
usize
)
-
>
Self
{
Self
{
should_line_break
:
false
indent_char
indent_size
indents
:
vec
!
[
indent_char
;
128
]
current_indent_len
:
0
}
}
pub
fn
grow
(
&
mut
self
)
{
self
.
current_indent_len
+
=
self
.
indent_size
;
self
.
ensure
(
self
.
current_indent_len
)
;
}
pub
fn
shrink
(
&
mut
self
)
{
self
.
current_indent_len
=
self
.
current_indent_len
.
saturating_sub
(
self
.
indent_size
)
;
}
pub
fn
current
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
indents
[
.
.
self
.
current_indent_len
]
}
pub
fn
additional
(
&
mut
self
additional_indent
:
usize
)
-
>
&
[
u8
]
{
let
new_len
=
self
.
current_indent_len
+
additional_indent
;
self
.
ensure
(
new_len
)
;
&
self
.
indents
[
.
.
new_len
]
}
fn
ensure
(
&
mut
self
new_len
:
usize
)
{
if
self
.
indents
.
len
(
)
<
new_len
{
self
.
indents
.
resize
(
new_len
self
.
indent_char
)
;
}
}
}
