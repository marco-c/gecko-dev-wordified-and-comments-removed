#
[
cfg
(
feature
=
"
encoding
"
)
]
use
encoding_rs
:
:
UTF_8
;
use
crate
:
:
encoding
:
:
Decoder
;
use
crate
:
:
errors
:
:
{
Error
IllFormedError
Result
SyntaxError
}
;
use
crate
:
:
events
:
:
{
BytesCData
BytesDecl
BytesEnd
BytesPI
BytesStart
BytesText
Event
}
;
#
[
cfg
(
feature
=
"
encoding
"
)
]
use
crate
:
:
reader
:
:
EncodingRef
;
use
crate
:
:
reader
:
:
{
BangType
Config
ParseState
}
;
use
crate
:
:
utils
:
:
{
is_whitespace
name_len
}
;
#
[
derive
(
Clone
Debug
)
]
pub
(
super
)
struct
ReaderState
{
pub
offset
:
u64
pub
last_error_offset
:
u64
pub
state
:
ParseState
pub
config
:
Config
opened_buffer
:
Vec
<
u8
>
opened_starts
:
Vec
<
usize
>
#
[
cfg
(
feature
=
"
encoding
"
)
]
pub
encoding
:
EncodingRef
}
impl
ReaderState
{
pub
fn
emit_text
<
'
b
>
(
&
mut
self
bytes
:
&
'
b
[
u8
]
)
-
>
BytesText
<
'
b
>
{
let
mut
content
=
bytes
;
if
self
.
config
.
trim_text_end
{
let
len
=
bytes
.
iter
(
)
.
rposition
(
|
&
b
|
!
is_whitespace
(
b
)
)
.
map_or
(
0
|
p
|
p
+
1
)
;
content
=
&
bytes
[
.
.
len
]
;
}
BytesText
:
:
wrap
(
content
self
.
decoder
(
)
)
}
pub
fn
emit_bang
<
'
b
>
(
&
mut
self
bang_type
:
BangType
buf
:
&
'
b
[
u8
]
)
-
>
Result
<
Event
<
'
b
>
>
{
debug_assert_eq
!
(
buf
.
first
(
)
Some
(
&
b
'
!
'
)
"
CDATA
comment
or
DOCTYPE
should
start
from
'
!
'
"
)
;
let
uncased_starts_with
=
|
string
:
&
[
u8
]
prefix
:
&
[
u8
]
|
{
string
.
len
(
)
>
=
prefix
.
len
(
)
&
&
string
[
.
.
prefix
.
len
(
)
]
.
eq_ignore_ascii_case
(
prefix
)
}
;
let
len
=
buf
.
len
(
)
;
match
bang_type
{
BangType
:
:
Comment
if
buf
.
starts_with
(
b
"
!
-
-
"
)
=
>
{
debug_assert
!
(
buf
.
ends_with
(
b
"
-
-
"
)
)
;
if
self
.
config
.
check_comments
{
let
mut
haystack
=
&
buf
[
3
.
.
len
-
2
]
;
let
mut
off
=
0
;
while
let
Some
(
p
)
=
memchr
:
:
memchr
(
b
'
-
'
haystack
)
{
off
+
=
p
+
1
;
if
buf
[
3
+
off
]
=
=
b
'
-
'
{
self
.
last_error_offset
=
self
.
offset
-
len
as
u64
+
2
+
p
as
u64
;
return
Err
(
Error
:
:
IllFormed
(
IllFormedError
:
:
DoubleHyphenInComment
)
)
;
}
haystack
=
&
haystack
[
p
+
1
.
.
]
;
}
}
Ok
(
Event
:
:
Comment
(
BytesText
:
:
wrap
(
&
buf
[
3
.
.
len
-
2
]
self
.
decoder
(
)
)
)
)
}
BangType
:
:
CData
if
buf
.
starts_with
(
b
"
!
[
CDATA
[
"
)
=
>
{
debug_assert
!
(
buf
.
ends_with
(
b
"
]
]
"
)
)
;
Ok
(
Event
:
:
CData
(
BytesCData
:
:
wrap
(
&
buf
[
8
.
.
len
-
2
]
self
.
decoder
(
)
)
)
)
}
BangType
:
:
DocType
(
0
)
if
uncased_starts_with
(
buf
b
"
!
DOCTYPE
"
)
=
>
{
match
buf
[
8
.
.
]
.
iter
(
)
.
position
(
|
&
b
|
!
is_whitespace
(
b
)
)
{
Some
(
start
)
=
>
Ok
(
Event
:
:
DocType
(
BytesText
:
:
wrap
(
&
buf
[
8
+
start
.
.
]
self
.
decoder
(
)
)
)
)
None
=
>
{
self
.
last_error_offset
=
self
.
offset
-
1
;
return
Err
(
Error
:
:
IllFormed
(
IllFormedError
:
:
MissingDoctypeName
)
)
;
}
}
}
_
=
>
{
self
.
last_error_offset
=
self
.
offset
-
len
as
u64
-
2
;
Err
(
bang_type
.
to_err
(
)
.
into
(
)
)
}
}
}
pub
fn
emit_end
<
'
b
>
(
&
mut
self
buf
:
&
'
b
[
u8
]
)
-
>
Result
<
Event
<
'
b
>
>
{
debug_assert_eq
!
(
buf
.
first
(
)
Some
(
&
b
'
/
'
)
"
closing
tag
should
start
from
'
/
'
"
)
;
let
content
=
&
buf
[
1
.
.
]
;
let
name
=
if
self
.
config
.
trim_markup_names_in_closing_tags
{
if
let
Some
(
pos_end_name
)
=
content
.
iter
(
)
.
rposition
(
|
&
b
|
!
is_whitespace
(
b
)
)
{
&
content
[
.
.
pos_end_name
+
1
]
}
else
{
content
}
}
else
{
content
}
;
let
decoder
=
self
.
decoder
(
)
;
match
self
.
opened_starts
.
pop
(
)
{
Some
(
start
)
=
>
{
if
self
.
config
.
check_end_names
{
let
expected
=
&
self
.
opened_buffer
[
start
.
.
]
;
if
name
!
=
expected
{
let
expected
=
decoder
.
decode
(
expected
)
.
unwrap_or_default
(
)
.
into_owned
(
)
;
self
.
opened_buffer
.
truncate
(
start
)
;
self
.
last_error_offset
=
self
.
offset
-
buf
.
len
(
)
as
u64
-
2
;
return
Err
(
Error
:
:
IllFormed
(
IllFormedError
:
:
MismatchedEndTag
{
expected
found
:
decoder
.
decode
(
name
)
.
unwrap_or_default
(
)
.
into_owned
(
)
}
)
)
;
}
}
self
.
opened_buffer
.
truncate
(
start
)
;
}
None
=
>
{
if
!
self
.
config
.
allow_unmatched_ends
{
self
.
last_error_offset
=
self
.
offset
-
buf
.
len
(
)
as
u64
-
2
;
return
Err
(
Error
:
:
IllFormed
(
IllFormedError
:
:
UnmatchedEndTag
(
decoder
.
decode
(
name
)
.
unwrap_or_default
(
)
.
into_owned
(
)
)
)
)
;
}
}
}
Ok
(
Event
:
:
End
(
BytesEnd
:
:
wrap
(
name
.
into
(
)
)
)
)
}
pub
fn
emit_question_mark
<
'
b
>
(
&
mut
self
buf
:
&
'
b
[
u8
]
)
-
>
Result
<
Event
<
'
b
>
>
{
debug_assert
!
(
buf
.
len
(
)
>
0
)
;
debug_assert_eq
!
(
buf
[
0
]
b
'
?
'
)
;
let
len
=
buf
.
len
(
)
;
if
len
>
1
&
&
buf
[
len
-
1
]
=
=
b
'
?
'
{
let
content
=
&
buf
[
1
.
.
len
-
1
]
;
let
len
=
content
.
len
(
)
;
if
content
.
starts_with
(
b
"
xml
"
)
&
&
(
len
=
=
3
|
|
is_whitespace
(
content
[
3
]
)
)
{
let
event
=
BytesDecl
:
:
from_start
(
BytesStart
:
:
wrap
(
content
3
)
)
;
#
[
cfg
(
feature
=
"
encoding
"
)
]
if
self
.
encoding
.
can_be_refined
(
)
{
if
let
Some
(
encoding
)
=
event
.
encoder
(
)
{
self
.
encoding
=
EncodingRef
:
:
XmlDetected
(
encoding
)
;
}
}
Ok
(
Event
:
:
Decl
(
event
)
)
}
else
{
Ok
(
Event
:
:
PI
(
BytesPI
:
:
wrap
(
content
name_len
(
content
)
)
)
)
}
}
else
{
self
.
last_error_offset
=
self
.
offset
-
len
as
u64
-
2
;
Err
(
Error
:
:
Syntax
(
SyntaxError
:
:
UnclosedPIOrXmlDecl
)
)
}
}
pub
fn
emit_start
<
'
b
>
(
&
mut
self
content
:
&
'
b
[
u8
]
)
-
>
Event
<
'
b
>
{
if
let
Some
(
content
)
=
content
.
strip_suffix
(
b
"
/
"
)
{
let
event
=
BytesStart
:
:
wrap
(
content
name_len
(
content
)
)
;
if
self
.
config
.
expand_empty_elements
{
self
.
state
=
ParseState
:
:
InsideEmpty
;
self
.
opened_starts
.
push
(
self
.
opened_buffer
.
len
(
)
)
;
self
.
opened_buffer
.
extend
(
event
.
name
(
)
.
as_ref
(
)
)
;
Event
:
:
Start
(
event
)
}
else
{
Event
:
:
Empty
(
event
)
}
}
else
{
let
event
=
BytesStart
:
:
wrap
(
content
name_len
(
content
)
)
;
self
.
opened_starts
.
push
(
self
.
opened_buffer
.
len
(
)
)
;
self
.
opened_buffer
.
extend
(
event
.
name
(
)
.
as_ref
(
)
)
;
Event
:
:
Start
(
event
)
}
}
#
[
inline
]
pub
fn
close_expanded_empty
(
&
mut
self
)
-
>
BytesEnd
<
'
static
>
{
self
.
state
=
ParseState
:
:
InsideText
;
let
name
=
self
.
opened_buffer
.
split_off
(
self
.
opened_starts
.
pop
(
)
.
unwrap
(
)
)
;
BytesEnd
:
:
wrap
(
name
.
into
(
)
)
}
pub
const
fn
decoder
(
&
self
)
-
>
Decoder
{
Decoder
{
#
[
cfg
(
feature
=
"
encoding
"
)
]
encoding
:
self
.
encoding
.
encoding
(
)
}
}
}
impl
Default
for
ReaderState
{
fn
default
(
)
-
>
Self
{
Self
{
offset
:
0
last_error_offset
:
0
state
:
ParseState
:
:
Init
config
:
Config
:
:
default
(
)
opened_buffer
:
Vec
:
:
new
(
)
opened_starts
:
Vec
:
:
new
(
)
#
[
cfg
(
feature
=
"
encoding
"
)
]
encoding
:
EncodingRef
:
:
Implicit
(
UTF_8
)
}
}
}
