use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
BufRead
BufReader
}
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
path
:
:
Path
;
use
crate
:
:
errors
:
:
Result
;
use
crate
:
:
events
:
:
Event
;
use
crate
:
:
name
:
:
{
LocalName
NamespaceResolver
PrefixIter
QName
ResolveResult
}
;
use
crate
:
:
reader
:
:
{
Config
Reader
Span
XmlSource
}
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
NsReader
<
R
>
{
pub
(
super
)
reader
:
Reader
<
R
>
ns_resolver
:
NamespaceResolver
pending_pop
:
bool
}
impl
<
R
>
NsReader
<
R
>
{
#
[
inline
]
pub
fn
from_reader
(
reader
:
R
)
-
>
Self
{
Self
:
:
new
(
Reader
:
:
from_reader
(
reader
)
)
}
#
[
inline
]
pub
const
fn
config
(
&
self
)
-
>
&
Config
{
self
.
reader
.
config
(
)
}
#
[
inline
]
pub
fn
config_mut
(
&
mut
self
)
-
>
&
mut
Config
{
self
.
reader
.
config_mut
(
)
}
#
[
inline
]
pub
const
fn
prefixes
(
&
self
)
-
>
PrefixIter
{
self
.
ns_resolver
.
iter
(
)
}
}
impl
<
R
>
NsReader
<
R
>
{
#
[
inline
]
fn
new
(
reader
:
Reader
<
R
>
)
-
>
Self
{
Self
{
reader
ns_resolver
:
NamespaceResolver
:
:
default
(
)
pending_pop
:
false
}
}
fn
read_event_impl
<
'
i
B
>
(
&
mut
self
buf
:
B
)
-
>
Result
<
Event
<
'
i
>
>
where
R
:
XmlSource
<
'
i
B
>
{
self
.
pop
(
)
;
let
event
=
self
.
reader
.
read_event_impl
(
buf
)
;
self
.
process_event
(
event
)
}
pub
(
super
)
fn
pop
(
&
mut
self
)
{
if
self
.
pending_pop
{
self
.
ns_resolver
.
pop
(
)
;
self
.
pending_pop
=
false
;
}
}
pub
(
super
)
fn
process_event
<
'
i
>
(
&
mut
self
event
:
Result
<
Event
<
'
i
>
>
)
-
>
Result
<
Event
<
'
i
>
>
{
match
event
{
Ok
(
Event
:
:
Start
(
e
)
)
=
>
{
self
.
ns_resolver
.
push
(
&
e
)
?
;
Ok
(
Event
:
:
Start
(
e
)
)
}
Ok
(
Event
:
:
Empty
(
e
)
)
=
>
{
self
.
ns_resolver
.
push
(
&
e
)
?
;
self
.
pending_pop
=
true
;
Ok
(
Event
:
:
Empty
(
e
)
)
}
Ok
(
Event
:
:
End
(
e
)
)
=
>
{
self
.
pending_pop
=
true
;
Ok
(
Event
:
:
End
(
e
)
)
}
e
=
>
e
}
}
pub
(
super
)
fn
resolve_event
<
'
i
>
(
&
mut
self
event
:
Result
<
Event
<
'
i
>
>
)
-
>
Result
<
(
ResolveResult
Event
<
'
i
>
)
>
{
match
event
{
Ok
(
Event
:
:
Start
(
e
)
)
=
>
Ok
(
(
self
.
ns_resolver
.
find
(
e
.
name
(
)
)
Event
:
:
Start
(
e
)
)
)
Ok
(
Event
:
:
Empty
(
e
)
)
=
>
Ok
(
(
self
.
ns_resolver
.
find
(
e
.
name
(
)
)
Event
:
:
Empty
(
e
)
)
)
Ok
(
Event
:
:
End
(
e
)
)
=
>
Ok
(
(
self
.
ns_resolver
.
find
(
e
.
name
(
)
)
Event
:
:
End
(
e
)
)
)
Ok
(
e
)
=
>
Ok
(
(
ResolveResult
:
:
Unbound
e
)
)
Err
(
e
)
=
>
Err
(
e
)
}
}
}
impl
<
R
>
NsReader
<
R
>
{
#
[
inline
]
pub
fn
into_inner
(
self
)
-
>
R
{
self
.
reader
.
into_inner
(
)
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
R
{
self
.
reader
.
get_mut
(
)
}
#
[
inline
]
pub
fn
resolve
<
'
n
>
(
&
self
name
:
QName
<
'
n
>
attribute
:
bool
)
-
>
(
ResolveResult
LocalName
<
'
n
>
)
{
self
.
ns_resolver
.
resolve
(
name
!
attribute
)
}
#
[
inline
]
pub
fn
resolve_element
<
'
n
>
(
&
self
name
:
QName
<
'
n
>
)
-
>
(
ResolveResult
LocalName
<
'
n
>
)
{
self
.
ns_resolver
.
resolve
(
name
true
)
}
#
[
inline
]
pub
fn
resolve_attribute
<
'
n
>
(
&
self
name
:
QName
<
'
n
>
)
-
>
(
ResolveResult
LocalName
<
'
n
>
)
{
self
.
ns_resolver
.
resolve
(
name
false
)
}
}
impl
<
R
:
BufRead
>
NsReader
<
R
>
{
#
[
inline
]
pub
fn
read_event_into
<
'
b
>
(
&
mut
self
buf
:
&
'
b
mut
Vec
<
u8
>
)
-
>
Result
<
Event
<
'
b
>
>
{
self
.
read_event_impl
(
buf
)
}
#
[
inline
]
pub
fn
read_resolved_event_into
<
'
b
>
(
&
mut
self
buf
:
&
'
b
mut
Vec
<
u8
>
)
-
>
Result
<
(
ResolveResult
Event
<
'
b
>
)
>
{
let
event
=
self
.
read_event_impl
(
buf
)
;
self
.
resolve_event
(
event
)
}
#
[
inline
]
pub
fn
read_to_end_into
(
&
mut
self
end
:
QName
buf
:
&
mut
Vec
<
u8
>
)
-
>
Result
<
Span
>
{
self
.
reader
.
read_to_end_into
(
end
buf
)
}
}
impl
NsReader
<
BufReader
<
File
>
>
{
pub
fn
from_file
<
P
:
AsRef
<
Path
>
>
(
path
:
P
)
-
>
Result
<
Self
>
{
Ok
(
Self
:
:
new
(
Reader
:
:
from_file
(
path
)
?
)
)
}
}
impl
<
'
i
>
NsReader
<
&
'
i
[
u8
]
>
{
#
[
inline
]
#
[
allow
(
clippy
:
:
should_implement_trait
)
]
pub
fn
from_str
(
s
:
&
'
i
str
)
-
>
Self
{
Self
:
:
new
(
Reader
:
:
from_str
(
s
)
)
}
#
[
inline
]
pub
fn
read_event
(
&
mut
self
)
-
>
Result
<
Event
<
'
i
>
>
{
self
.
read_event_impl
(
(
)
)
}
#
[
inline
]
pub
fn
read_resolved_event
(
&
mut
self
)
-
>
Result
<
(
ResolveResult
Event
<
'
i
>
)
>
{
let
event
=
self
.
read_event_impl
(
(
)
)
;
self
.
resolve_event
(
event
)
}
#
[
inline
]
pub
fn
read_to_end
(
&
mut
self
end
:
QName
)
-
>
Result
<
Span
>
{
self
.
reader
.
read_to_end
(
end
)
}
#
[
inline
]
pub
fn
read_text
(
&
mut
self
end
:
QName
)
-
>
Result
<
Cow
<
'
i
str
>
>
{
self
.
reader
.
read_text
(
end
)
}
}
impl
<
R
>
Deref
for
NsReader
<
R
>
{
type
Target
=
Reader
<
R
>
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
reader
}
}
