use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
self
BufRead
BufReader
}
;
use
std
:
:
path
:
:
Path
;
use
crate
:
:
errors
:
:
{
Error
Result
}
;
use
crate
:
:
events
:
:
Event
;
use
crate
:
:
name
:
:
QName
;
use
crate
:
:
parser
:
:
Parser
;
use
crate
:
:
reader
:
:
{
BangType
ReadTextResult
Reader
Span
XmlSource
}
;
use
crate
:
:
utils
:
:
is_whitespace
;
macro_rules
!
impl_buffered_source
{
(
(
lf
:
lifetime
reader
:
tt
async
:
ident
await
:
ident
)
?
)
=
>
{
#
[
cfg
(
not
(
feature
=
"
encoding
"
)
)
]
#
[
inline
]
(
async
)
?
fn
remove_utf8_bom
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
use
crate
:
:
encoding
:
:
UTF8_BOM
;
loop
{
break
match
self
(
.
reader
)
?
.
fill_buf
(
)
(
.
await
)
?
{
Ok
(
n
)
=
>
{
if
n
.
starts_with
(
UTF8_BOM
)
{
self
(
.
reader
)
?
.
consume
(
UTF8_BOM
.
len
(
)
)
;
}
Ok
(
(
)
)
}
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
Interrupted
=
>
continue
Err
(
e
)
=
>
Err
(
e
)
}
;
}
}
#
[
cfg
(
feature
=
"
encoding
"
)
]
#
[
inline
]
(
async
)
?
fn
detect_encoding
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
&
'
static
encoding_rs
:
:
Encoding
>
>
{
loop
{
break
match
self
(
.
reader
)
?
.
fill_buf
(
)
(
.
await
)
?
{
Ok
(
n
)
=
>
if
let
Some
(
(
enc
bom_len
)
)
=
crate
:
:
encoding
:
:
detect_encoding
(
n
)
{
self
(
.
reader
)
?
.
consume
(
bom_len
)
;
Ok
(
Some
(
enc
)
)
}
else
{
Ok
(
None
)
}
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
Interrupted
=
>
continue
Err
(
e
)
=
>
Err
(
e
)
}
;
}
}
#
[
inline
]
(
async
)
?
fn
read_text
(
<
lf
>
)
?
(
&
mut
self
buf
:
&
'
b
mut
Vec
<
u8
>
position
:
&
mut
u64
)
-
>
ReadTextResult
<
'
b
&
'
b
mut
Vec
<
u8
>
>
{
let
mut
read
=
0
;
let
start
=
buf
.
len
(
)
;
loop
{
let
available
=
match
self
(
.
reader
)
?
.
fill_buf
(
)
(
.
await
)
?
{
Ok
(
n
)
if
n
.
is_empty
(
)
=
>
break
Ok
(
n
)
=
>
n
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
Interrupted
=
>
continue
Err
(
e
)
=
>
{
*
position
+
=
read
;
return
ReadTextResult
:
:
Err
(
e
)
;
}
}
;
match
memchr
:
:
memchr
(
b
'
<
'
available
)
{
/
/
Special
handling
is
needed
only
on
the
first
iteration
.
/
/
On
next
iterations
we
already
read
something
and
should
emit
Text
event
Some
(
0
)
if
read
=
=
0
=
>
{
self
(
.
reader
)
?
.
consume
(
1
)
;
*
position
+
=
1
;
return
ReadTextResult
:
:
Markup
(
buf
)
;
}
Some
(
i
)
=
>
{
buf
.
extend_from_slice
(
&
available
[
.
.
i
]
)
;
let
used
=
i
+
1
;
self
(
.
reader
)
?
.
consume
(
used
)
;
read
+
=
used
as
u64
;
*
position
+
=
read
;
return
ReadTextResult
:
:
UpToMarkup
(
&
buf
[
start
.
.
]
)
;
}
None
=
>
{
buf
.
extend_from_slice
(
available
)
;
let
used
=
available
.
len
(
)
;
self
(
.
reader
)
?
.
consume
(
used
)
;
read
+
=
used
as
u64
;
}
}
}
*
position
+
=
read
;
ReadTextResult
:
:
UpToEof
(
&
buf
[
start
.
.
]
)
}
#
[
inline
]
(
async
)
?
fn
read_with
<
(
lf
)
?
P
:
Parser
>
(
&
mut
self
mut
parser
:
P
buf
:
&
'
b
mut
Vec
<
u8
>
position
:
&
mut
u64
)
-
>
Result
<
&
'
b
[
u8
]
>
{
let
mut
read
=
0
;
let
start
=
buf
.
len
(
)
;
loop
{
let
available
=
match
self
(
.
reader
)
?
.
fill_buf
(
)
(
.
await
)
?
{
Ok
(
n
)
if
n
.
is_empty
(
)
=
>
break
Ok
(
n
)
=
>
n
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
Interrupted
=
>
continue
Err
(
e
)
=
>
{
*
position
+
=
read
;
return
Err
(
Error
:
:
Io
(
e
.
into
(
)
)
)
;
}
}
;
if
let
Some
(
i
)
=
parser
.
feed
(
available
)
{
buf
.
extend_from_slice
(
&
available
[
.
.
i
]
)
;
/
/
+
1
for
>
which
we
do
not
include
self
(
.
reader
)
?
.
consume
(
i
+
1
)
;
read
+
=
i
as
u64
+
1
;
*
position
+
=
read
;
return
Ok
(
&
buf
[
start
.
.
]
)
;
}
/
/
The
>
symbol
not
yet
found
continue
reading
buf
.
extend_from_slice
(
available
)
;
let
used
=
available
.
len
(
)
;
self
(
.
reader
)
?
.
consume
(
used
)
;
read
+
=
used
as
u64
;
}
*
position
+
=
read
;
Err
(
Error
:
:
Syntax
(
P
:
:
eof_error
(
)
)
)
}
#
[
inline
]
(
async
)
?
fn
read_bang_element
(
<
lf
>
)
?
(
&
mut
self
buf
:
&
'
b
mut
Vec
<
u8
>
position
:
&
mut
u64
)
-
>
Result
<
(
BangType
&
'
b
[
u8
]
)
>
{
/
/
Peeked
one
bang
(
'
!
'
)
before
being
called
so
it
'
s
guaranteed
to
/
/
start
with
it
.
let
start
=
buf
.
len
(
)
;
let
mut
read
=
1
;
buf
.
push
(
b
'
!
'
)
;
self
(
.
reader
)
?
.
consume
(
1
)
;
let
mut
bang_type
=
BangType
:
:
new
(
self
.
peek_one
(
)
(
.
await
)
?
?
)
?
;
loop
{
match
self
(
.
reader
)
?
.
fill_buf
(
)
(
.
await
)
?
{
/
/
Note
:
Do
not
update
position
so
the
error
points
to
/
/
somewhere
sane
rather
than
at
the
EOF
Ok
(
n
)
if
n
.
is_empty
(
)
=
>
break
Ok
(
available
)
=
>
{
/
/
We
only
parse
from
start
because
we
don
'
t
want
to
consider
/
/
whatever
is
in
the
buffer
before
the
bang
element
if
let
Some
(
(
consumed
used
)
)
=
bang_type
.
parse
(
&
buf
[
start
.
.
]
available
)
{
buf
.
extend_from_slice
(
consumed
)
;
self
(
.
reader
)
?
.
consume
(
used
)
;
read
+
=
used
as
u64
;
*
position
+
=
read
;
return
Ok
(
(
bang_type
&
buf
[
start
.
.
]
)
)
;
}
else
{
buf
.
extend_from_slice
(
available
)
;
let
used
=
available
.
len
(
)
;
self
(
.
reader
)
?
.
consume
(
used
)
;
read
+
=
used
as
u64
;
}
}
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
Interrupted
=
>
continue
Err
(
e
)
=
>
{
*
position
+
=
read
;
return
Err
(
Error
:
:
Io
(
e
.
into
(
)
)
)
;
}
}
}
*
position
+
=
read
;
Err
(
bang_type
.
to_err
(
)
.
into
(
)
)
}
#
[
inline
]
(
async
)
?
fn
skip_whitespace
(
&
mut
self
position
:
&
mut
u64
)
-
>
io
:
:
Result
<
(
)
>
{
loop
{
break
match
self
(
.
reader
)
?
.
fill_buf
(
)
(
.
await
)
?
{
Ok
(
n
)
=
>
{
let
count
=
n
.
iter
(
)
.
position
(
|
b
|
!
is_whitespace
(
*
b
)
)
.
unwrap_or
(
n
.
len
(
)
)
;
if
count
>
0
{
self
(
.
reader
)
?
.
consume
(
count
)
;
*
position
+
=
count
as
u64
;
continue
;
}
else
{
Ok
(
(
)
)
}
}
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
Interrupted
=
>
continue
Err
(
e
)
=
>
Err
(
e
)
}
;
}
}
#
[
inline
]
(
async
)
?
fn
peek_one
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
u8
>
>
{
loop
{
break
match
self
(
.
reader
)
?
.
fill_buf
(
)
(
.
await
)
?
{
Ok
(
n
)
=
>
Ok
(
n
.
first
(
)
.
cloned
(
)
)
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
Interrupted
=
>
continue
Err
(
e
)
=
>
Err
(
e
)
}
;
}
}
}
;
}
#
[
cfg
(
feature
=
"
async
-
tokio
"
)
]
pub
(
super
)
use
impl_buffered_source
;
impl
<
'
b
R
:
BufRead
>
XmlSource
<
'
b
&
'
b
mut
Vec
<
u8
>
>
for
R
{
impl_buffered_source
!
(
)
;
}
impl
<
R
:
BufRead
>
Reader
<
R
>
{
#
[
inline
]
pub
fn
read_event_into
<
'
b
>
(
&
mut
self
buf
:
&
'
b
mut
Vec
<
u8
>
)
-
>
Result
<
Event
<
'
b
>
>
{
self
.
read_event_impl
(
buf
)
}
pub
fn
read_to_end_into
(
&
mut
self
end
:
QName
buf
:
&
mut
Vec
<
u8
>
)
-
>
Result
<
Span
>
{
Ok
(
read_to_end
!
(
self
end
buf
read_event_impl
{
buf
.
clear
(
)
;
}
)
)
}
}
impl
Reader
<
BufReader
<
File
>
>
{
pub
fn
from_file
<
P
:
AsRef
<
Path
>
>
(
path
:
P
)
-
>
Result
<
Self
>
{
let
file
=
File
:
:
open
(
path
)
?
;
let
reader
=
BufReader
:
:
new
(
file
)
;
Ok
(
Self
:
:
from_reader
(
reader
)
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
crate
:
:
reader
:
:
test
:
:
check
;
use
crate
:
:
reader
:
:
XmlSource
;
fn
identity
<
T
>
(
input
:
T
)
-
>
T
{
input
}
check
!
(
#
[
test
]
read_event_impl
read_until_close
identity
&
mut
Vec
:
:
new
(
)
)
;
}
