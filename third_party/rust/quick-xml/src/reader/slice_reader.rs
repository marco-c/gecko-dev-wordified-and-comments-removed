use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
io
;
#
[
cfg
(
feature
=
"
encoding
"
)
]
use
crate
:
:
reader
:
:
EncodingRef
;
#
[
cfg
(
feature
=
"
encoding
"
)
]
use
encoding_rs
:
:
{
Encoding
UTF_8
}
;
use
crate
:
:
errors
:
:
{
Error
Result
}
;
use
crate
:
:
events
:
:
Event
;
use
crate
:
:
name
:
:
QName
;
use
crate
:
:
parser
:
:
Parser
;
use
crate
:
:
reader
:
:
{
BangType
ReadTextResult
Reader
Span
XmlSource
}
;
use
crate
:
:
utils
:
:
is_whitespace
;
impl
<
'
a
>
Reader
<
&
'
a
[
u8
]
>
{
#
[
allow
(
clippy
:
:
should_implement_trait
)
]
pub
fn
from_str
(
s
:
&
'
a
str
)
-
>
Self
{
#
[
cfg
(
feature
=
"
encoding
"
)
]
{
let
mut
reader
=
Self
:
:
from_reader
(
s
.
as_bytes
(
)
)
;
reader
.
state
.
encoding
=
EncodingRef
:
:
Explicit
(
UTF_8
)
;
reader
}
#
[
cfg
(
not
(
feature
=
"
encoding
"
)
)
]
Self
:
:
from_reader
(
s
.
as_bytes
(
)
)
}
#
[
inline
]
pub
fn
read_event
(
&
mut
self
)
-
>
Result
<
Event
<
'
a
>
>
{
self
.
read_event_impl
(
(
)
)
}
pub
fn
read_to_end
(
&
mut
self
end
:
QName
)
-
>
Result
<
Span
>
{
Ok
(
read_to_end
!
(
self
end
(
)
read_event_impl
{
}
)
)
}
pub
fn
read_text
(
&
mut
self
end
:
QName
)
-
>
Result
<
Cow
<
'
a
str
>
>
{
let
buffer
=
self
.
reader
;
let
span
=
self
.
read_to_end
(
end
)
?
;
let
len
=
span
.
end
-
span
.
start
;
Ok
(
self
.
decoder
(
)
.
decode
(
&
buffer
[
0
.
.
len
as
usize
]
)
?
)
}
}
impl
<
'
a
>
XmlSource
<
'
a
(
)
>
for
&
'
a
[
u8
]
{
#
[
cfg
(
not
(
feature
=
"
encoding
"
)
)
]
#
[
inline
]
fn
remove_utf8_bom
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
if
self
.
starts_with
(
crate
:
:
encoding
:
:
UTF8_BOM
)
{
*
self
=
&
self
[
crate
:
:
encoding
:
:
UTF8_BOM
.
len
(
)
.
.
]
;
}
Ok
(
(
)
)
}
#
[
cfg
(
feature
=
"
encoding
"
)
]
#
[
inline
]
fn
detect_encoding
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
&
'
static
Encoding
>
>
{
if
let
Some
(
(
enc
bom_len
)
)
=
crate
:
:
encoding
:
:
detect_encoding
(
self
)
{
*
self
=
&
self
[
bom_len
.
.
]
;
return
Ok
(
Some
(
enc
)
)
;
}
Ok
(
None
)
}
#
[
inline
]
fn
read_text
(
&
mut
self
_buf
:
(
)
position
:
&
mut
u64
)
-
>
ReadTextResult
<
'
a
(
)
>
{
match
memchr
:
:
memchr
(
b
'
<
'
self
)
{
Some
(
0
)
=
>
{
*
position
+
=
1
;
*
self
=
&
self
[
1
.
.
]
;
ReadTextResult
:
:
Markup
(
(
)
)
}
Some
(
i
)
=
>
{
*
position
+
=
i
as
u64
+
1
;
let
bytes
=
&
self
[
.
.
i
]
;
*
self
=
&
self
[
i
+
1
.
.
]
;
ReadTextResult
:
:
UpToMarkup
(
bytes
)
}
None
=
>
{
*
position
+
=
self
.
len
(
)
as
u64
;
let
bytes
=
&
self
[
.
.
]
;
*
self
=
&
[
]
;
ReadTextResult
:
:
UpToEof
(
bytes
)
}
}
}
#
[
inline
]
fn
read_with
<
P
>
(
&
mut
self
mut
parser
:
P
_buf
:
(
)
position
:
&
mut
u64
)
-
>
Result
<
&
'
a
[
u8
]
>
where
P
:
Parser
{
if
let
Some
(
i
)
=
parser
.
feed
(
self
)
{
*
position
+
=
i
as
u64
+
1
;
let
bytes
=
&
self
[
.
.
i
]
;
*
self
=
&
self
[
i
+
1
.
.
]
;
return
Ok
(
bytes
)
;
}
*
position
+
=
self
.
len
(
)
as
u64
;
Err
(
Error
:
:
Syntax
(
P
:
:
eof_error
(
)
)
)
}
#
[
inline
]
fn
read_bang_element
(
&
mut
self
_buf
:
(
)
position
:
&
mut
u64
)
-
>
Result
<
(
BangType
&
'
a
[
u8
]
)
>
{
debug_assert_eq
!
(
self
[
0
]
b
'
!
'
)
;
let
mut
bang_type
=
BangType
:
:
new
(
self
[
1
.
.
]
.
first
(
)
.
copied
(
)
)
?
;
if
let
Some
(
(
bytes
i
)
)
=
bang_type
.
parse
(
&
[
]
self
)
{
*
position
+
=
i
as
u64
;
*
self
=
&
self
[
i
.
.
]
;
return
Ok
(
(
bang_type
bytes
)
)
;
}
*
position
+
=
self
.
len
(
)
as
u64
;
Err
(
bang_type
.
to_err
(
)
.
into
(
)
)
}
#
[
inline
]
fn
skip_whitespace
(
&
mut
self
position
:
&
mut
u64
)
-
>
io
:
:
Result
<
(
)
>
{
let
whitespaces
=
self
.
iter
(
)
.
position
(
|
b
|
!
is_whitespace
(
*
b
)
)
.
unwrap_or
(
self
.
len
(
)
)
;
*
position
+
=
whitespaces
as
u64
;
*
self
=
&
self
[
whitespaces
.
.
]
;
Ok
(
(
)
)
}
#
[
inline
]
fn
peek_one
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
u8
>
>
{
Ok
(
self
.
first
(
)
.
copied
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
crate
:
:
reader
:
:
test
:
:
check
;
use
crate
:
:
reader
:
:
XmlSource
;
fn
identity
<
T
>
(
input
:
T
)
-
>
T
{
input
}
check
!
(
#
[
test
]
read_event_impl
read_until_close
identity
(
)
)
;
}
