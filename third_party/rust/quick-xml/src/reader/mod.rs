#
[
cfg
(
feature
=
"
encoding
"
)
]
use
encoding_rs
:
:
Encoding
;
use
std
:
:
io
;
use
std
:
:
ops
:
:
Range
;
use
crate
:
:
encoding
:
:
Decoder
;
use
crate
:
:
errors
:
:
{
Error
SyntaxError
}
;
use
crate
:
:
events
:
:
Event
;
use
crate
:
:
parser
:
:
{
ElementParser
Parser
PiParser
}
;
use
crate
:
:
reader
:
:
state
:
:
ReaderState
;
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
arbitrary
:
:
Arbitrary
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
-
types
"
derive
(
serde
:
:
Deserialize
serde
:
:
Serialize
)
)
]
#
[
non_exhaustive
]
pub
struct
Config
{
pub
allow_unmatched_ends
:
bool
pub
check_comments
:
bool
pub
check_end_names
:
bool
pub
expand_empty_elements
:
bool
pub
trim_markup_names_in_closing_tags
:
bool
pub
trim_text_start
:
bool
pub
trim_text_end
:
bool
}
impl
Config
{
#
[
inline
]
pub
fn
trim_text
(
&
mut
self
trim
:
bool
)
{
self
.
trim_text_start
=
trim
;
self
.
trim_text_end
=
trim
;
}
#
[
inline
]
pub
fn
enable_all_checks
(
&
mut
self
enable
:
bool
)
{
self
.
check_comments
=
enable
;
self
.
check_end_names
=
enable
;
}
}
impl
Default
for
Config
{
fn
default
(
)
-
>
Self
{
Self
{
allow_unmatched_ends
:
false
check_comments
:
false
check_end_names
:
true
expand_empty_elements
:
false
trim_markup_names_in_closing_tags
:
true
trim_text_start
:
false
trim_text_end
:
false
}
}
}
macro_rules
!
read_event_impl
{
(
self
:
ident
buf
:
ident
reader
:
expr
read_until_close
:
ident
(
await
:
ident
)
?
)
=
>
{
{
let
event
=
loop
{
break
match
self
.
state
.
state
{
ParseState
:
:
Init
=
>
{
/
/
Go
to
InsideMarkup
state
/
/
If
encoding
set
explicitly
we
not
need
to
detect
it
.
For
example
/
/
explicit
UTF
-
8
set
automatically
if
Reader
was
created
using
from_str
.
/
/
But
we
still
need
to
remove
BOM
for
consistency
with
no
encoding
/
/
feature
enabled
path
#
[
cfg
(
feature
=
"
encoding
"
)
]
if
let
Some
(
encoding
)
=
reader
.
detect_encoding
(
)
(
.
await
)
?
?
{
if
self
.
state
.
encoding
.
can_be_refined
(
)
{
self
.
state
.
encoding
=
crate
:
:
reader
:
:
EncodingRef
:
:
BomDetected
(
encoding
)
;
}
}
/
/
Removes
UTF
-
8
BOM
if
it
is
present
#
[
cfg
(
not
(
feature
=
"
encoding
"
)
)
]
reader
.
remove_utf8_bom
(
)
(
.
await
)
?
?
;
self
.
state
.
state
=
ParseState
:
:
InsideText
;
continue
;
}
ParseState
:
:
InsideText
=
>
{
/
/
Go
to
InsideMarkup
or
Done
state
if
self
.
state
.
config
.
trim_text_start
{
reader
.
skip_whitespace
(
&
mut
self
.
state
.
offset
)
(
.
await
)
?
?
;
}
match
reader
.
read_text
(
buf
&
mut
self
.
state
.
offset
)
(
.
await
)
?
{
ReadTextResult
:
:
Markup
(
buf
)
=
>
{
self
.
state
.
state
=
ParseState
:
:
InsideMarkup
;
/
/
Pass
buf
to
the
next
next
iteration
of
parsing
loop
buf
=
buf
;
continue
;
}
ReadTextResult
:
:
UpToMarkup
(
bytes
)
=
>
{
self
.
state
.
state
=
ParseState
:
:
InsideMarkup
;
/
/
FIXME
:
Can
produce
an
empty
event
if
:
/
/
-
event
contains
only
spaces
/
/
-
trim_text_start
=
false
/
/
-
trim_text_end
=
true
Ok
(
Event
:
:
Text
(
self
.
state
.
emit_text
(
bytes
)
)
)
}
ReadTextResult
:
:
UpToEof
(
bytes
)
=
>
{
self
.
state
.
state
=
ParseState
:
:
Done
;
/
/
Trim
bytes
from
end
if
required
let
event
=
self
.
state
.
emit_text
(
bytes
)
;
if
event
.
is_empty
(
)
{
Ok
(
Event
:
:
Eof
)
}
else
{
Ok
(
Event
:
:
Text
(
event
)
)
}
}
ReadTextResult
:
:
Err
(
e
)
=
>
Err
(
Error
:
:
Io
(
e
.
into
(
)
)
)
}
}
/
/
Go
to
InsideText
state
in
next
two
arms
ParseState
:
:
InsideMarkup
=
>
self
.
read_until_close
(
buf
)
(
.
await
)
?
ParseState
:
:
InsideEmpty
=
>
Ok
(
Event
:
:
End
(
self
.
state
.
close_expanded_empty
(
)
)
)
ParseState
:
:
Done
=
>
Ok
(
Event
:
:
Eof
)
}
;
}
;
match
event
{
/
/
#
513
:
In
case
of
ill
-
formed
errors
we
already
consume
the
wrong
data
/
/
and
change
the
state
.
We
can
continue
parsing
if
we
wish
Err
(
Error
:
:
IllFormed
(
_
)
)
=
>
{
}
Err
(
_
)
|
Ok
(
Event
:
:
Eof
)
=
>
self
.
state
.
state
=
ParseState
:
:
Done
_
=
>
{
}
}
event
}
}
;
}
macro_rules
!
read_until_close
{
(
self
:
ident
buf
:
ident
reader
:
expr
(
await
:
ident
)
?
)
=
>
{
{
self
.
state
.
state
=
ParseState
:
:
InsideText
;
let
start
=
self
.
state
.
offset
;
match
reader
.
peek_one
(
)
(
.
await
)
?
{
/
/
<
!
-
comment
CDATA
or
DOCTYPE
declaration
Ok
(
Some
(
b
'
!
'
)
)
=
>
match
reader
.
read_bang_element
(
buf
&
mut
self
.
state
.
offset
)
(
.
await
)
?
{
Ok
(
(
bang_type
bytes
)
)
=
>
self
.
state
.
emit_bang
(
bang_type
bytes
)
Err
(
e
)
=
>
{
/
/
We
want
to
report
error
at
<
but
offset
was
increased
/
/
so
return
it
back
(
-
1
for
<
)
self
.
state
.
last_error_offset
=
start
-
1
;
Err
(
e
)
}
}
/
/
<
/
-
closing
tag
/
/
#
776
:
We
parse
using
ElementParser
which
allows
us
to
have
attributes
/
/
in
close
tags
.
While
such
tags
are
not
allowed
by
the
specification
/
/
we
anyway
allow
to
parse
them
because
:
/
/
-
we
do
not
check
constraints
during
parsing
.
This
is
performed
by
the
/
/
optional
validate
step
which
user
should
call
manually
/
/
-
if
we
just
look
for
>
we
will
parse
<
/
tag
attr
=
"
>
"
>
as
end
tag
/
/
<
/
tag
attr
=
"
>
and
text
"
>
which
probably
no
one
existing
parser
/
/
does
.
This
is
malformed
XML
however
it
is
tolerated
by
some
parsers
/
/
(
e
.
g
.
the
one
used
by
Adobe
Flash
)
and
such
documents
do
exist
in
the
wild
.
Ok
(
Some
(
b
'
/
'
)
)
=
>
match
reader
.
read_with
(
ElementParser
:
:
Outside
buf
&
mut
self
.
state
.
offset
)
(
.
await
)
?
{
Ok
(
bytes
)
=
>
self
.
state
.
emit_end
(
bytes
)
Err
(
e
)
=
>
{
/
/
We
want
to
report
error
at
<
but
offset
was
increased
/
/
so
return
it
back
(
-
1
for
<
)
self
.
state
.
last_error_offset
=
start
-
1
;
Err
(
e
)
}
}
/
/
<
?
-
processing
instruction
Ok
(
Some
(
b
'
?
'
)
)
=
>
match
reader
.
read_with
(
PiParser
(
false
)
buf
&
mut
self
.
state
.
offset
)
(
.
await
)
?
{
Ok
(
bytes
)
=
>
self
.
state
.
emit_question_mark
(
bytes
)
Err
(
e
)
=
>
{
/
/
We
want
to
report
error
at
<
but
offset
was
increased
/
/
so
return
it
back
(
-
1
for
<
)
self
.
state
.
last_error_offset
=
start
-
1
;
Err
(
e
)
}
}
/
/
<
.
.
.
-
opening
or
self
-
closed
tag
Ok
(
Some
(
_
)
)
=
>
match
reader
.
read_with
(
ElementParser
:
:
Outside
buf
&
mut
self
.
state
.
offset
)
(
.
await
)
?
{
Ok
(
bytes
)
=
>
Ok
(
self
.
state
.
emit_start
(
bytes
)
)
Err
(
e
)
=
>
{
/
/
We
want
to
report
error
at
<
but
offset
was
increased
/
/
so
return
it
back
(
-
1
for
<
)
self
.
state
.
last_error_offset
=
start
-
1
;
Err
(
e
)
}
}
/
/
<
-
syntax
error
tag
not
closed
Ok
(
None
)
=
>
{
/
/
We
want
to
report
error
at
<
but
offset
was
increased
/
/
so
return
it
back
(
-
1
for
<
)
self
.
state
.
last_error_offset
=
start
-
1
;
Err
(
Error
:
:
Syntax
(
SyntaxError
:
:
UnclosedTag
)
)
}
Err
(
e
)
=
>
Err
(
Error
:
:
Io
(
e
.
into
(
)
)
)
}
}
}
;
}
macro_rules
!
read_to_end
{
(
self
:
expr
end
:
expr
buf
:
expr
read_event
:
ident
clear
:
block
(
await
:
ident
)
?
)
=
>
{
{
/
/
Because
we
take
position
after
the
event
before
the
End
event
/
/
it
is
important
that
this
position
indicates
beginning
of
the
End
event
.
/
/
If
between
last
event
and
the
End
event
would
be
only
spaces
then
we
/
/
take
position
before
the
spaces
but
spaces
would
be
skipped
without
/
/
generating
event
if
trim_text_start
is
set
to
true
.
To
prevent
that
/
/
we
temporary
disable
start
text
trimming
.
/
/
/
/
We
also
cannot
take
position
after
getting
End
event
because
if
/
/
trim_markup_names_in_closing_tags
is
set
to
true
(
which
is
the
default
)
/
/
we
do
not
known
the
real
size
of
the
End
event
that
it
is
occupies
in
/
/
the
source
and
cannot
correct
the
position
after
the
End
event
.
/
/
So
we
in
any
case
should
tweak
parser
configuration
.
let
config
=
self
.
config_mut
(
)
;
let
trim
=
config
.
trim_text_start
;
config
.
trim_text_start
=
false
;
let
start
=
self
.
buffer_position
(
)
;
let
mut
depth
=
0
;
loop
{
clear
let
end
=
self
.
buffer_position
(
)
;
match
self
.
read_event
(
buf
)
(
.
await
)
?
{
Err
(
e
)
=
>
{
self
.
config_mut
(
)
.
trim_text_start
=
trim
;
return
Err
(
e
)
;
}
Ok
(
Event
:
:
Start
(
e
)
)
if
e
.
name
(
)
=
=
end
=
>
depth
+
=
1
Ok
(
Event
:
:
End
(
e
)
)
if
e
.
name
(
)
=
=
end
=
>
{
if
depth
=
=
0
{
self
.
config_mut
(
)
.
trim_text_start
=
trim
;
break
start
.
.
end
;
}
depth
-
=
1
;
}
Ok
(
Event
:
:
Eof
)
=
>
{
self
.
config_mut
(
)
.
trim_text_start
=
trim
;
return
Err
(
Error
:
:
missed_end
(
end
self
.
decoder
(
)
)
)
;
}
_
=
>
(
)
}
}
}
}
;
}
#
[
cfg
(
feature
=
"
async
-
tokio
"
)
]
mod
async_tokio
;
mod
buffered_reader
;
mod
ns_reader
;
mod
slice_reader
;
mod
state
;
pub
use
ns_reader
:
:
NsReader
;
pub
type
Span
=
Range
<
u64
>
;
#
[
derive
(
Clone
Debug
)
]
enum
ParseState
{
Init
InsideMarkup
InsideText
InsideEmpty
Done
}
#
[
cfg
(
feature
=
"
encoding
"
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
enum
EncodingRef
{
Implicit
(
&
'
static
Encoding
)
Explicit
(
&
'
static
Encoding
)
BomDetected
(
&
'
static
Encoding
)
XmlDetected
(
&
'
static
Encoding
)
}
#
[
cfg
(
feature
=
"
encoding
"
)
]
impl
EncodingRef
{
#
[
inline
]
const
fn
encoding
(
&
self
)
-
>
&
'
static
Encoding
{
match
self
{
Self
:
:
Implicit
(
e
)
=
>
e
Self
:
:
Explicit
(
e
)
=
>
e
Self
:
:
BomDetected
(
e
)
=
>
e
Self
:
:
XmlDetected
(
e
)
=
>
e
}
}
#
[
inline
]
const
fn
can_be_refined
(
&
self
)
-
>
bool
{
match
self
{
Self
:
:
Implicit
(
_
)
|
Self
:
:
BomDetected
(
_
)
=
>
true
Self
:
:
Explicit
(
_
)
|
Self
:
:
XmlDetected
(
_
)
=
>
false
}
}
}
#
[
derive
(
Debug
)
]
#
[
must_use
=
"
streams
do
nothing
unless
read
or
polled
"
]
pub
struct
BinaryStream
<
'
r
R
>
{
inner
:
&
'
r
mut
R
offset
:
&
'
r
mut
u64
}
impl
<
'
r
R
>
BinaryStream
<
'
r
R
>
{
#
[
inline
]
pub
const
fn
offset
(
&
self
)
-
>
u64
{
*
self
.
offset
}
#
[
inline
]
pub
const
fn
get_ref
(
&
self
)
-
>
&
R
{
self
.
inner
}
#
[
inline
]
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
R
{
self
.
inner
}
}
impl
<
'
r
R
>
io
:
:
Read
for
BinaryStream
<
'
r
R
>
where
R
:
io
:
:
Read
{
#
[
inline
]
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
let
amt
=
self
.
inner
.
read
(
buf
)
?
;
*
self
.
offset
+
=
amt
as
u64
;
Ok
(
amt
)
}
}
impl
<
'
r
R
>
io
:
:
BufRead
for
BinaryStream
<
'
r
R
>
where
R
:
io
:
:
BufRead
{
#
[
inline
]
fn
fill_buf
(
&
mut
self
)
-
>
io
:
:
Result
<
&
[
u8
]
>
{
self
.
inner
.
fill_buf
(
)
}
#
[
inline
]
fn
consume
(
&
mut
self
amt
:
usize
)
{
self
.
inner
.
consume
(
amt
)
;
*
self
.
offset
+
=
amt
as
u64
;
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Reader
<
R
>
{
reader
:
R
state
:
ReaderState
}
impl
<
R
>
Reader
<
R
>
{
pub
fn
from_reader
(
reader
:
R
)
-
>
Self
{
Self
{
reader
state
:
ReaderState
:
:
default
(
)
}
}
pub
const
fn
config
(
&
self
)
-
>
&
Config
{
&
self
.
state
.
config
}
pub
fn
config_mut
(
&
mut
self
)
-
>
&
mut
Config
{
&
mut
self
.
state
.
config
}
}
impl
<
R
>
Reader
<
R
>
{
pub
fn
into_inner
(
self
)
-
>
R
{
self
.
reader
}
pub
const
fn
get_ref
(
&
self
)
-
>
&
R
{
&
self
.
reader
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
R
{
&
mut
self
.
reader
}
pub
const
fn
buffer_position
(
&
self
)
-
>
u64
{
if
let
ParseState
:
:
InsideMarkup
=
self
.
state
.
state
{
self
.
state
.
offset
-
1
}
else
{
self
.
state
.
offset
}
}
pub
const
fn
error_position
(
&
self
)
-
>
u64
{
self
.
state
.
last_error_offset
}
#
[
inline
]
pub
const
fn
decoder
(
&
self
)
-
>
Decoder
{
self
.
state
.
decoder
(
)
}
#
[
inline
]
pub
fn
stream
(
&
mut
self
)
-
>
BinaryStream
<
R
>
{
BinaryStream
{
inner
:
&
mut
self
.
reader
offset
:
&
mut
self
.
state
.
offset
}
}
}
impl
<
R
>
Reader
<
R
>
{
fn
read_event_impl
<
'
i
B
>
(
&
mut
self
mut
buf
:
B
)
-
>
Result
<
Event
<
'
i
>
Error
>
where
R
:
XmlSource
<
'
i
B
>
{
read_event_impl
!
(
self
buf
self
.
reader
read_until_close
)
}
fn
read_until_close
<
'
i
B
>
(
&
mut
self
buf
:
B
)
-
>
Result
<
Event
<
'
i
>
Error
>
where
R
:
XmlSource
<
'
i
B
>
{
read_until_close
!
(
self
buf
self
.
reader
)
}
}
enum
ReadTextResult
<
'
r
B
>
{
Markup
(
B
)
UpToMarkup
(
&
'
r
[
u8
]
)
UpToEof
(
&
'
r
[
u8
]
)
Err
(
io
:
:
Error
)
}
trait
XmlSource
<
'
r
B
>
{
#
[
cfg
(
not
(
feature
=
"
encoding
"
)
)
]
fn
remove_utf8_bom
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
;
#
[
cfg
(
feature
=
"
encoding
"
)
]
fn
detect_encoding
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
&
'
static
Encoding
>
>
;
fn
read_text
(
&
mut
self
buf
:
B
position
:
&
mut
u64
)
-
>
ReadTextResult
<
'
r
B
>
;
fn
read_with
<
P
>
(
&
mut
self
parser
:
P
buf
:
B
position
:
&
mut
u64
)
-
>
Result
<
&
'
r
[
u8
]
Error
>
where
P
:
Parser
;
fn
read_bang_element
(
&
mut
self
buf
:
B
position
:
&
mut
u64
)
-
>
Result
<
(
BangType
&
'
r
[
u8
]
)
Error
>
;
fn
skip_whitespace
(
&
mut
self
position
:
&
mut
u64
)
-
>
io
:
:
Result
<
(
)
>
;
fn
peek_one
(
&
mut
self
)
-
>
io
:
:
Result
<
Option
<
u8
>
>
;
}
#
[
derive
(
Debug
PartialEq
)
]
enum
BangType
{
CData
Comment
DocType
(
i32
)
}
impl
BangType
{
#
[
inline
(
always
)
]
const
fn
new
(
byte
:
Option
<
u8
>
)
-
>
Result
<
Self
SyntaxError
>
{
Ok
(
match
byte
{
Some
(
b
'
[
'
)
=
>
Self
:
:
CData
Some
(
b
'
-
'
)
=
>
Self
:
:
Comment
Some
(
b
'
D
'
)
|
Some
(
b
'
d
'
)
=
>
Self
:
:
DocType
(
0
)
_
=
>
return
Err
(
SyntaxError
:
:
InvalidBangMarkup
)
}
)
}
#
[
inline
(
always
)
]
fn
parse
<
'
b
>
(
&
mut
self
buf
:
&
[
u8
]
chunk
:
&
'
b
[
u8
]
)
-
>
Option
<
(
&
'
b
[
u8
]
usize
)
>
{
match
self
{
Self
:
:
Comment
=
>
{
for
i
in
memchr
:
:
memchr_iter
(
b
'
>
'
chunk
)
{
if
buf
.
len
(
)
+
i
>
4
{
if
chunk
[
.
.
i
]
.
ends_with
(
b
"
-
-
"
)
{
return
Some
(
(
&
chunk
[
.
.
i
]
i
+
1
)
)
;
}
if
i
=
=
1
&
&
buf
.
ends_with
(
b
"
-
"
)
&
&
chunk
[
0
]
=
=
b
'
-
'
{
return
Some
(
(
&
chunk
[
.
.
i
]
i
+
1
)
)
;
}
if
i
=
=
0
&
&
buf
.
ends_with
(
b
"
-
-
"
)
{
return
Some
(
(
&
[
]
i
+
1
)
)
;
}
}
}
}
Self
:
:
CData
=
>
{
for
i
in
memchr
:
:
memchr_iter
(
b
'
>
'
chunk
)
{
if
chunk
[
.
.
i
]
.
ends_with
(
b
"
]
]
"
)
{
return
Some
(
(
&
chunk
[
.
.
i
]
i
+
1
)
)
;
}
if
i
=
=
1
&
&
buf
.
ends_with
(
b
"
]
"
)
&
&
chunk
[
0
]
=
=
b
'
]
'
{
return
Some
(
(
&
chunk
[
.
.
i
]
i
+
1
)
)
;
}
if
i
=
=
0
&
&
buf
.
ends_with
(
b
"
]
]
"
)
{
return
Some
(
(
&
[
]
i
+
1
)
)
;
}
}
}
Self
:
:
DocType
(
ref
mut
balance
)
=
>
{
for
i
in
memchr
:
:
memchr2_iter
(
b
'
<
'
b
'
>
'
chunk
)
{
if
chunk
[
i
]
=
=
b
'
<
'
{
*
balance
+
=
1
;
}
else
{
if
*
balance
=
=
0
{
return
Some
(
(
&
chunk
[
.
.
i
]
i
+
1
)
)
;
}
*
balance
-
=
1
;
}
}
}
}
None
}
#
[
inline
]
const
fn
to_err
(
&
self
)
-
>
SyntaxError
{
match
self
{
Self
:
:
CData
=
>
SyntaxError
:
:
UnclosedCData
Self
:
:
Comment
=
>
SyntaxError
:
:
UnclosedComment
Self
:
:
DocType
(
_
)
=
>
SyntaxError
:
:
UnclosedDoctype
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
macro_rules
!
check
{
(
#
[
test
:
meta
]
read_event
:
ident
read_until_close
:
ident
source
:
path
buf
:
expr
(
async
:
ident
await
:
ident
)
?
)
=
>
{
mod
read_bang_element
{
use
super
:
:
*
;
use
crate
:
:
errors
:
:
{
Error
SyntaxError
}
;
use
crate
:
:
reader
:
:
BangType
;
use
crate
:
:
utils
:
:
Bytes
;
/
/
/
Checks
that
reading
CDATA
content
works
correctly
mod
cdata
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
/
/
/
Checks
that
if
input
begins
like
CDATA
element
but
CDATA
start
sequence
/
/
/
is
not
finished
parsing
ends
with
an
error
#
[
test
]
#
[
ignore
=
"
start
CDATA
sequence
fully
checked
outside
of
read_bang_element
"
]
(
async
)
?
fn
not_properly_start
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
[
]
]
>
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedCData
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
1
)
;
}
/
/
/
Checks
that
if
CDATA
startup
sequence
was
matched
but
an
end
sequence
/
/
/
is
not
found
parsing
ends
with
an
error
#
[
test
]
(
async
)
?
fn
not_closed
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
[
CDATA
[
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
22
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedCData
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
22
)
;
}
/
/
/
Checks
that
CDATA
element
without
content
inside
parsed
successfully
#
[
test
]
(
async
)
?
fn
empty
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
[
CDATA
[
]
]
>
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
12
let
(
ty
bytes
)
=
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
;
assert_eq
!
(
(
ty
Bytes
(
bytes
)
)
(
BangType
:
:
CData
Bytes
(
b
"
!
[
CDATA
[
]
]
"
)
)
)
;
assert_eq
!
(
position
12
)
;
}
/
/
/
Checks
that
CDATA
element
with
content
parsed
successfully
.
/
/
/
Additionally
checks
that
sequences
inside
CDATA
that
may
look
like
/
/
/
a
CDATA
end
sequence
do
not
interrupt
CDATA
parsing
#
[
test
]
(
async
)
?
fn
with_content
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
[
CDATA
[
cdata
]
]
]
>
content
]
]
>
other
content
]
]
>
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
29
let
(
ty
bytes
)
=
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
;
assert_eq
!
(
(
ty
Bytes
(
bytes
)
)
(
BangType
:
:
CData
Bytes
(
b
"
!
[
CDATA
[
cdata
]
]
]
>
content
]
]
"
)
)
)
;
assert_eq
!
(
position
29
)
;
}
}
/
/
/
Checks
that
reading
XML
comments
works
correctly
.
According
to
the
[
specification
]
/
/
/
comment
data
can
contain
any
sequence
except
-
-
:
/
/
/
/
/
/
peg
/
/
/
comment
=
'
<
-
-
'
(
!
'
-
-
'
char
)
*
'
-
-
>
'
;
/
/
/
char
=
[
#
x1
-
#
x2C
]
/
/
/
/
[
#
x2E
-
#
xD7FF
]
/
/
/
/
[
#
xE000
-
#
xFFFD
]
/
/
/
/
[
#
x10000
-
#
x10FFFF
]
/
/
/
/
/
/
/
/
/
The
presence
of
this
limitation
however
is
simply
a
poorly
designed
specification
/
/
/
(
maybe
for
purpose
of
building
of
LL
(
1
)
XML
parser
)
and
quick
-
xml
does
not
check
for
/
/
/
presence
of
these
sequences
by
default
.
This
tests
allow
such
content
.
/
/
/
/
/
/
[
specification
]
:
https
:
/
/
www
.
w3
.
org
/
TR
/
xml11
/
#
dt
-
comment
mod
comment
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
#
[
ignore
=
"
start
comment
sequence
fully
checked
outside
of
read_bang_element
"
]
(
async
)
?
fn
not_properly_start
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
-
-
-
>
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedComment
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
1
)
;
}
#
[
test
]
(
async
)
?
fn
not_properly_end
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
-
>
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
17
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedComment
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
17
)
;
}
#
[
test
]
(
async
)
?
fn
not_closed1
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
-
-
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
17
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedComment
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
17
)
;
}
#
[
test
]
(
async
)
?
fn
not_closed2
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
-
-
>
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
18
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedComment
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
18
)
;
}
#
[
test
]
(
async
)
?
fn
not_closed3
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
-
-
-
>
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
19
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedComment
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
19
)
;
}
#
[
test
]
(
async
)
?
fn
empty
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
-
-
-
-
>
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
7
let
(
ty
bytes
)
=
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
;
assert_eq
!
(
(
ty
Bytes
(
bytes
)
)
(
BangType
:
:
Comment
Bytes
(
b
"
!
-
-
-
-
"
)
)
)
;
assert_eq
!
(
position
7
)
;
}
#
[
test
]
(
async
)
?
fn
with_content
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
-
-
-
>
comment
<
-
-
-
>
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
18
let
(
ty
bytes
)
=
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
;
assert_eq
!
(
(
ty
Bytes
(
bytes
)
)
(
BangType
:
:
Comment
Bytes
(
b
"
!
-
-
-
>
comment
<
-
-
-
"
)
)
)
;
assert_eq
!
(
position
18
)
;
}
}
/
/
/
Checks
that
reading
DOCTYPE
definition
works
correctly
mod
doctype
{
use
super
:
:
*
;
mod
uppercase
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
(
async
)
?
fn
not_properly_start
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
D
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
17
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedDoctype
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
17
)
;
}
#
[
test
]
(
async
)
?
fn
without_space
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
DOCTYPEother
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
22
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedDoctype
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
22
)
;
}
#
[
test
]
(
async
)
?
fn
empty
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
DOCTYPE
>
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
10
let
(
ty
bytes
)
=
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
;
assert_eq
!
(
(
ty
Bytes
(
bytes
)
)
(
BangType
:
:
DocType
(
0
)
Bytes
(
b
"
!
DOCTYPE
"
)
)
)
;
assert_eq
!
(
position
10
)
;
}
#
[
test
]
(
async
)
?
fn
not_closed
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
DOCTYPE
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
23
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedDoctype
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
23
)
;
}
}
mod
lowercase
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
(
async
)
?
fn
not_properly_start
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
d
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
17
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedDoctype
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
17
)
;
}
#
[
test
]
(
async
)
?
fn
without_space
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
doctypeother
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
22
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedDoctype
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
22
)
;
}
#
[
test
]
(
async
)
?
fn
empty
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
doctype
>
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
10
let
(
ty
bytes
)
=
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
;
assert_eq
!
(
(
ty
Bytes
(
bytes
)
)
(
BangType
:
:
DocType
(
0
)
Bytes
(
b
"
!
doctype
"
)
)
)
;
assert_eq
!
(
position
10
)
;
}
#
[
test
]
(
async
)
?
fn
not_closed
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
!
doctype
other
content
"
.
as_ref
(
)
;
/
/
^
=
1
^
=
23
match
source
(
&
mut
input
)
.
read_bang_element
(
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedDoctype
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
23
)
;
}
}
}
}
mod
read_element
{
use
super
:
:
*
;
use
crate
:
:
errors
:
:
{
Error
SyntaxError
}
;
use
crate
:
:
parser
:
:
ElementParser
;
use
crate
:
:
utils
:
:
Bytes
;
use
pretty_assertions
:
:
assert_eq
;
/
/
/
Checks
that
nothing
was
read
from
empty
buffer
#
[
test
]
(
async
)
?
fn
empty
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
"
.
as_ref
(
)
;
/
/
^
=
1
match
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
{
Err
(
Error
:
:
Syntax
(
cause
)
)
=
>
assert_eq
!
(
cause
SyntaxError
:
:
UnclosedTag
)
x
=
>
panic
!
(
"
Expected
Err
(
Syntax
(
_
)
)
but
got
{
:
?
}
"
x
)
}
assert_eq
!
(
position
1
)
;
}
mod
open
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
(
async
)
?
fn
empty_tag
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
>
"
.
as_ref
(
)
;
/
/
^
=
2
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
"
)
)
;
assert_eq
!
(
position
2
)
;
}
#
[
test
]
(
async
)
?
fn
normal
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
tag
>
"
.
as_ref
(
)
;
/
/
^
=
5
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
tag
"
)
)
;
assert_eq
!
(
position
5
)
;
}
#
[
test
]
(
async
)
?
fn
empty_ns_empty_tag
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
:
>
"
.
as_ref
(
)
;
/
/
^
=
3
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
:
"
)
)
;
assert_eq
!
(
position
3
)
;
}
#
[
test
]
(
async
)
?
fn
empty_ns
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
:
tag
>
"
.
as_ref
(
)
;
/
/
^
=
6
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
:
tag
"
)
)
;
assert_eq
!
(
position
6
)
;
}
#
[
test
]
(
async
)
?
fn
with_attributes
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
br
#
"
tag
attr
-
1
=
"
>
"
attr2
=
'
>
'
3attr
>
"
#
.
as_ref
(
)
;
/
/
^
=
39
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
br
#
"
tag
attr
-
1
=
"
>
"
attr2
=
'
>
'
3attr
"
#
)
)
;
assert_eq
!
(
position
39
)
;
}
}
mod
self_closed
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
(
async
)
?
fn
empty_tag
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
/
>
"
.
as_ref
(
)
;
/
/
^
=
3
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
/
"
)
)
;
assert_eq
!
(
position
3
)
;
}
#
[
test
]
(
async
)
?
fn
normal
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
tag
/
>
"
.
as_ref
(
)
;
/
/
^
=
6
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
tag
/
"
)
)
;
assert_eq
!
(
position
6
)
;
}
#
[
test
]
(
async
)
?
fn
empty_ns_empty_tag
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
:
/
>
"
.
as_ref
(
)
;
/
/
^
=
4
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
:
/
"
)
)
;
assert_eq
!
(
position
4
)
;
}
#
[
test
]
(
async
)
?
fn
empty_ns
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
:
tag
/
>
"
.
as_ref
(
)
;
/
/
^
=
7
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
:
tag
/
"
)
)
;
assert_eq
!
(
position
7
)
;
}
#
[
test
]
(
async
)
?
fn
with_attributes
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
br
#
"
tag
attr
-
1
=
"
/
>
"
attr2
=
'
/
>
'
3attr
/
>
"
#
.
as_ref
(
)
;
/
/
^
=
42
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
br
#
"
tag
attr
-
1
=
"
/
>
"
attr2
=
'
/
>
'
3attr
/
"
#
)
)
;
assert_eq
!
(
position
42
)
;
}
}
mod
close
{
use
super
:
:
*
;
use
pretty_assertions
:
:
assert_eq
;
#
[
test
]
(
async
)
?
fn
empty_tag
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
/
>
"
.
as_ref
(
)
;
/
/
^
=
4
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
/
"
)
)
;
assert_eq
!
(
position
4
)
;
}
#
[
test
]
(
async
)
?
fn
normal
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
/
tag
>
"
.
as_ref
(
)
;
/
/
^
=
6
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
/
tag
"
)
)
;
assert_eq
!
(
position
6
)
;
}
#
[
test
]
(
async
)
?
fn
empty_ns_empty_tag
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
/
:
>
"
.
as_ref
(
)
;
/
/
^
=
4
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
/
:
"
)
)
;
assert_eq
!
(
position
4
)
;
}
#
[
test
]
(
async
)
?
fn
empty_ns
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
b
"
/
:
tag
>
"
.
as_ref
(
)
;
/
/
^
=
7
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
b
"
/
:
tag
"
)
)
;
assert_eq
!
(
position
7
)
;
}
#
[
test
]
(
async
)
?
fn
with_attributes
(
)
{
let
buf
=
buf
;
let
mut
position
=
1
;
let
mut
input
=
br
#
"
/
tag
attr
-
1
=
"
>
"
attr2
=
'
>
'
3attr
>
"
#
.
as_ref
(
)
;
/
/
^
=
40
assert_eq
!
(
Bytes
(
source
(
&
mut
input
)
.
read_with
(
ElementParser
:
:
default
(
)
buf
&
mut
position
)
(
.
await
)
?
.
unwrap
(
)
)
Bytes
(
br
#
"
/
tag
attr
-
1
=
"
>
"
attr2
=
'
>
'
3attr
"
#
)
)
;
assert_eq
!
(
position
40
)
;
}
}
}
/
/
/
Ensures
that
no
empty
Text
events
are
generated
mod
read_event
{
use
crate
:
:
events
:
:
{
BytesCData
BytesDecl
BytesEnd
BytesPI
BytesStart
BytesText
Event
}
;
use
crate
:
:
reader
:
:
Reader
;
use
pretty_assertions
:
:
assert_eq
;
/
/
/
When
encoding
feature
is
enabled
encoding
should
be
detected
/
/
/
from
BOM
(
UTF
-
8
)
and
BOM
should
be
stripped
.
/
/
/
/
/
/
When
encoding
feature
is
disabled
UTF
-
8
is
assumed
and
BOM
/
/
/
character
should
be
stripped
for
consistency
#
[
test
]
(
async
)
?
fn
bom_from_reader
(
)
{
let
mut
reader
=
Reader
:
:
from_reader
(
"
\
u
{
feff
}
\
u
{
feff
}
"
.
as_bytes
(
)
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
Text
(
BytesText
:
:
from_escaped
(
"
\
u
{
feff
}
"
)
)
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
Eof
)
;
}
/
/
/
When
parsing
from
&
str
encoding
is
fixed
(
UTF
-
8
)
so
/
/
/
-
when
encoding
feature
is
disabled
the
behavior
the
/
/
/
same
as
in
bom_from_reader
text
/
/
/
-
when
encoding
feature
is
enabled
the
behavior
should
/
/
/
stay
consistent
so
the
first
BOM
character
is
stripped
#
[
test
]
(
async
)
?
fn
bom_from_str
(
)
{
let
mut
reader
=
Reader
:
:
from_str
(
"
\
u
{
feff
}
\
u
{
feff
}
"
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
Text
(
BytesText
:
:
from_escaped
(
"
\
u
{
feff
}
"
)
)
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
Eof
)
;
}
#
[
test
]
(
async
)
?
fn
declaration
(
)
{
let
mut
reader
=
Reader
:
:
from_str
(
"
<
?
xml
?
>
"
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
Decl
(
BytesDecl
:
:
from_start
(
BytesStart
:
:
from_content
(
"
xml
"
3
)
)
)
)
;
}
#
[
test
]
(
async
)
?
fn
doctype
(
)
{
let
mut
reader
=
Reader
:
:
from_str
(
"
<
!
DOCTYPE
x
>
"
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
DocType
(
BytesText
:
:
from_escaped
(
"
x
"
)
)
)
;
}
#
[
test
]
(
async
)
?
fn
processing_instruction
(
)
{
let
mut
reader
=
Reader
:
:
from_str
(
"
<
?
xml
-
stylesheet
'
?
>
\
"
?
>
"
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
PI
(
BytesPI
:
:
new
(
"
xml
-
stylesheet
'
?
>
\
"
"
)
)
)
;
}
/
/
/
Lone
closing
tags
are
not
allowed
so
testing
it
together
with
start
tag
#
[
test
]
(
async
)
?
fn
start_and_end
(
)
{
let
mut
reader
=
Reader
:
:
from_str
(
"
<
tag
>
<
/
tag
>
"
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
Start
(
BytesStart
:
:
new
(
"
tag
"
)
)
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
End
(
BytesEnd
:
:
new
(
"
tag
"
)
)
)
;
}
#
[
test
]
(
async
)
?
fn
empty
(
)
{
let
mut
reader
=
Reader
:
:
from_str
(
"
<
tag
/
>
"
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
Empty
(
BytesStart
:
:
new
(
"
tag
"
)
)
)
;
}
#
[
test
]
(
async
)
?
fn
text
(
)
{
let
mut
reader
=
Reader
:
:
from_str
(
"
text
"
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
Text
(
BytesText
:
:
from_escaped
(
"
text
"
)
)
)
;
}
#
[
test
]
(
async
)
?
fn
cdata
(
)
{
let
mut
reader
=
Reader
:
:
from_str
(
"
<
!
[
CDATA
[
]
]
>
"
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
CData
(
BytesCData
:
:
new
(
"
"
)
)
)
;
}
#
[
test
]
(
async
)
?
fn
comment
(
)
{
let
mut
reader
=
Reader
:
:
from_str
(
"
<
!
-
-
-
-
>
"
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
Comment
(
BytesText
:
:
from_escaped
(
"
"
)
)
)
;
}
#
[
test
]
(
async
)
?
fn
eof
(
)
{
let
mut
reader
=
Reader
:
:
from_str
(
"
"
)
;
assert_eq
!
(
reader
.
read_event
(
buf
)
(
.
await
)
?
.
unwrap
(
)
Event
:
:
Eof
)
;
}
}
}
;
}
pub
(
super
)
use
check
;
}
