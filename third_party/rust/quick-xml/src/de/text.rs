use
crate
:
:
{
de
:
:
simple_type
:
:
SimpleTypeDeserializer
de
:
:
{
Text
TEXT_KEY
}
errors
:
:
serialize
:
:
DeError
utils
:
:
CowRef
}
;
use
serde
:
:
de
:
:
value
:
:
BorrowedStrDeserializer
;
use
serde
:
:
de
:
:
{
DeserializeSeed
Deserializer
EnumAccess
VariantAccess
Visitor
}
;
use
serde
:
:
serde_if_integer128
;
use
std
:
:
borrow
:
:
Cow
;
pub
struct
TextDeserializer
<
'
de
>
(
pub
Text
<
'
de
>
)
;
impl
<
'
de
>
TextDeserializer
<
'
de
>
{
#
[
inline
]
fn
read_string
(
self
)
-
>
Result
<
Cow
<
'
de
str
>
DeError
>
{
Ok
(
self
.
0
.
text
)
}
}
impl
<
'
de
>
Deserializer
<
'
de
>
for
TextDeserializer
<
'
de
>
{
type
Error
=
DeError
;
deserialize_primitives
!
(
)
;
fn
deserialize_unit
<
V
>
(
self
visitor
:
V
)
-
>
Result
<
V
:
:
Value
Self
:
:
Error
>
where
V
:
Visitor
<
'
de
>
{
visitor
.
visit_unit
(
)
}
fn
deserialize_option
<
V
>
(
self
visitor
:
V
)
-
>
Result
<
V
:
:
Value
Self
:
:
Error
>
where
V
:
Visitor
<
'
de
>
{
if
self
.
0
.
is_empty
(
)
{
visitor
.
visit_none
(
)
}
else
{
visitor
.
visit_some
(
self
)
}
}
fn
deserialize_newtype_struct
<
V
>
(
self
_name
:
&
'
static
str
visitor
:
V
)
-
>
Result
<
V
:
:
Value
Self
:
:
Error
>
where
V
:
Visitor
<
'
de
>
{
visitor
.
visit_newtype_struct
(
self
)
}
fn
deserialize_seq
<
V
>
(
self
visitor
:
V
)
-
>
Result
<
V
:
:
Value
Self
:
:
Error
>
where
V
:
Visitor
<
'
de
>
{
SimpleTypeDeserializer
:
:
from_text_content
(
self
.
0
)
.
deserialize_seq
(
visitor
)
}
#
[
inline
]
fn
deserialize_struct
<
V
>
(
self
_name
:
&
'
static
str
_fields
:
&
'
static
[
&
'
static
str
]
visitor
:
V
)
-
>
Result
<
V
:
:
Value
Self
:
:
Error
>
where
V
:
Visitor
<
'
de
>
{
self
.
deserialize_str
(
visitor
)
}
fn
deserialize_enum
<
V
>
(
self
_name
:
&
'
static
str
_variants
:
&
'
static
[
&
'
static
str
]
visitor
:
V
)
-
>
Result
<
V
:
:
Value
Self
:
:
Error
>
where
V
:
Visitor
<
'
de
>
{
visitor
.
visit_enum
(
self
)
}
#
[
inline
]
fn
deserialize_any
<
V
>
(
self
visitor
:
V
)
-
>
Result
<
V
:
:
Value
Self
:
:
Error
>
where
V
:
Visitor
<
'
de
>
{
self
.
deserialize_str
(
visitor
)
}
}
impl
<
'
de
>
EnumAccess
<
'
de
>
for
TextDeserializer
<
'
de
>
{
type
Error
=
DeError
;
type
Variant
=
Self
;
fn
variant_seed
<
V
>
(
self
seed
:
V
)
-
>
Result
<
(
V
:
:
Value
Self
:
:
Variant
)
Self
:
:
Error
>
where
V
:
DeserializeSeed
<
'
de
>
{
let
name
=
seed
.
deserialize
(
BorrowedStrDeserializer
:
:
<
DeError
>
:
:
new
(
TEXT_KEY
)
)
?
;
Ok
(
(
name
self
)
)
}
}
impl
<
'
de
>
VariantAccess
<
'
de
>
for
TextDeserializer
<
'
de
>
{
type
Error
=
DeError
;
#
[
inline
]
fn
unit_variant
(
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
Ok
(
(
)
)
}
fn
newtype_variant_seed
<
T
>
(
self
seed
:
T
)
-
>
Result
<
T
:
:
Value
Self
:
:
Error
>
where
T
:
DeserializeSeed
<
'
de
>
{
seed
.
deserialize
(
self
)
}
#
[
inline
]
fn
tuple_variant
<
V
>
(
self
len
:
usize
visitor
:
V
)
-
>
Result
<
V
:
:
Value
Self
:
:
Error
>
where
V
:
Visitor
<
'
de
>
{
self
.
deserialize_tuple
(
len
visitor
)
}
#
[
inline
]
fn
struct_variant
<
V
>
(
self
fields
:
&
'
static
[
&
'
static
str
]
visitor
:
V
)
-
>
Result
<
V
:
:
Value
Self
:
:
Error
>
where
V
:
Visitor
<
'
de
>
{
self
.
deserialize_struct
(
"
"
fields
visitor
)
}
}
