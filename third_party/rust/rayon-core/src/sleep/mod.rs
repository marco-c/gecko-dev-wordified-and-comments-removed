use
log
:
:
Event
:
:
*
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
sync
:
:
{
Condvar
Mutex
}
;
use
std
:
:
thread
;
use
std
:
:
usize
;
pub
(
super
)
struct
Sleep
{
state
:
AtomicUsize
data
:
Mutex
<
(
)
>
tickle
:
Condvar
}
const
AWAKE
:
usize
=
0
;
const
SLEEPING
:
usize
=
1
;
const
ROUNDS_UNTIL_SLEEPY
:
usize
=
32
;
const
ROUNDS_UNTIL_ASLEEP
:
usize
=
64
;
impl
Sleep
{
pub
(
super
)
fn
new
(
)
-
>
Sleep
{
Sleep
{
state
:
AtomicUsize
:
:
new
(
AWAKE
)
data
:
Mutex
:
:
new
(
(
)
)
tickle
:
Condvar
:
:
new
(
)
}
}
fn
anyone_sleeping
(
&
self
state
:
usize
)
-
>
bool
{
state
&
SLEEPING
!
=
0
}
fn
any_worker_is_sleepy
(
&
self
state
:
usize
)
-
>
bool
{
(
state
>
>
1
)
!
=
0
}
fn
worker_is_sleepy
(
&
self
state
:
usize
worker_index
:
usize
)
-
>
bool
{
(
state
>
>
1
)
=
=
(
worker_index
+
1
)
}
fn
with_sleepy_worker
(
&
self
state
:
usize
worker_index
:
usize
)
-
>
usize
{
debug_assert
!
(
state
=
=
AWAKE
|
|
state
=
=
SLEEPING
)
;
(
(
worker_index
+
1
)
<
<
1
)
+
state
}
#
[
inline
]
pub
(
super
)
fn
work_found
(
&
self
worker_index
:
usize
yields
:
usize
)
-
>
usize
{
log
!
(
FoundWork
{
worker
:
worker_index
yields
:
yields
}
)
;
if
yields
>
ROUNDS_UNTIL_SLEEPY
{
self
.
tickle
(
worker_index
)
;
}
0
}
#
[
inline
]
pub
(
super
)
fn
no_work_found
(
&
self
worker_index
:
usize
yields
:
usize
)
-
>
usize
{
log
!
(
DidNotFindWork
{
worker
:
worker_index
yields
:
yields
}
)
;
if
yields
<
ROUNDS_UNTIL_SLEEPY
{
thread
:
:
yield_now
(
)
;
yields
+
1
}
else
if
yields
=
=
ROUNDS_UNTIL_SLEEPY
{
thread
:
:
yield_now
(
)
;
if
self
.
get_sleepy
(
worker_index
)
{
yields
+
1
}
else
{
yields
}
}
else
if
yields
<
ROUNDS_UNTIL_ASLEEP
{
thread
:
:
yield_now
(
)
;
if
self
.
still_sleepy
(
worker_index
)
{
yields
+
1
}
else
{
log
!
(
GotInterrupted
{
worker
:
worker_index
}
)
;
0
}
}
else
{
debug_assert_eq
!
(
yields
ROUNDS_UNTIL_ASLEEP
)
;
self
.
sleep
(
worker_index
)
;
0
}
}
pub
(
super
)
fn
tickle
(
&
self
worker_index
:
usize
)
{
let
old_state
=
self
.
state
.
load
(
Ordering
:
:
SeqCst
)
;
if
old_state
!
=
AWAKE
{
self
.
tickle_cold
(
worker_index
)
;
}
}
#
[
cold
]
fn
tickle_cold
(
&
self
worker_index
:
usize
)
{
let
old_state
=
self
.
state
.
swap
(
AWAKE
Ordering
:
:
Release
)
;
log
!
(
Tickle
{
worker
:
worker_index
old_state
:
old_state
}
)
;
if
self
.
anyone_sleeping
(
old_state
)
{
let
_data
=
self
.
data
.
lock
(
)
.
unwrap
(
)
;
self
.
tickle
.
notify_all
(
)
;
}
}
fn
get_sleepy
(
&
self
worker_index
:
usize
)
-
>
bool
{
loop
{
let
state
=
self
.
state
.
load
(
Ordering
:
:
Acquire
)
;
log
!
(
GetSleepy
{
worker
:
worker_index
state
:
state
}
)
;
if
self
.
any_worker_is_sleepy
(
state
)
{
debug_assert
!
(
!
self
.
worker_is_sleepy
(
state
worker_index
)
"
worker
{
}
called
is_sleepy
(
)
\
but
they
are
already
sleepy
(
state
=
{
}
)
"
worker_index
state
)
;
return
false
;
}
else
{
let
new_state
=
self
.
with_sleepy_worker
(
state
worker_index
)
;
if
self
.
state
.
compare_exchange
(
state
new_state
Ordering
:
:
SeqCst
Ordering
:
:
Relaxed
)
.
is_ok
(
)
{
log
!
(
GotSleepy
{
worker
:
worker_index
old_state
:
state
new_state
:
new_state
}
)
;
return
true
;
}
}
}
}
fn
still_sleepy
(
&
self
worker_index
:
usize
)
-
>
bool
{
let
state
=
self
.
state
.
load
(
Ordering
:
:
SeqCst
)
;
self
.
worker_is_sleepy
(
state
worker_index
)
}
fn
sleep
(
&
self
worker_index
:
usize
)
{
loop
{
let
state
=
self
.
state
.
load
(
Ordering
:
:
Acquire
)
;
if
self
.
worker_is_sleepy
(
state
worker_index
)
{
let
data
=
self
.
data
.
lock
(
)
.
unwrap
(
)
;
if
self
.
state
.
compare_exchange
(
state
SLEEPING
Ordering
:
:
SeqCst
Ordering
:
:
Relaxed
)
.
is_ok
(
)
{
log
!
(
FellAsleep
{
worker
:
worker_index
}
)
;
let
_
=
self
.
tickle
.
wait
(
data
)
.
unwrap
(
)
;
log
!
(
GotAwoken
{
worker
:
worker_index
}
)
;
return
;
}
}
else
{
log
!
(
GotInterrupted
{
worker
:
worker_index
}
)
;
return
;
}
}
}
}
