use
crossbeam_queue
:
:
SegQueue
;
use
latch
:
:
Latch
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
mem
;
use
unwind
;
pub
(
super
)
enum
JobResult
<
T
>
{
None
Ok
(
T
)
Panic
(
Box
<
Any
+
Send
>
)
}
pub
(
super
)
trait
Job
{
unsafe
fn
execute
(
this
:
*
const
Self
)
;
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
pub
(
super
)
struct
JobRef
{
pointer
:
*
const
(
)
execute_fn
:
unsafe
fn
(
*
const
(
)
)
}
unsafe
impl
Send
for
JobRef
{
}
unsafe
impl
Sync
for
JobRef
{
}
impl
JobRef
{
pub
(
super
)
unsafe
fn
new
<
T
>
(
data
:
*
const
T
)
-
>
JobRef
where
T
:
Job
{
let
fn_ptr
:
unsafe
fn
(
*
const
T
)
=
<
T
as
Job
>
:
:
execute
;
JobRef
{
pointer
:
data
as
*
const
(
)
execute_fn
:
mem
:
:
transmute
(
fn_ptr
)
}
}
#
[
inline
]
pub
(
super
)
unsafe
fn
execute
(
&
self
)
{
(
self
.
execute_fn
)
(
self
.
pointer
)
}
}
pub
(
super
)
struct
StackJob
<
L
F
R
>
where
L
:
Latch
+
Sync
F
:
FnOnce
(
bool
)
-
>
R
+
Send
R
:
Send
{
pub
(
super
)
latch
:
L
func
:
UnsafeCell
<
Option
<
F
>
>
result
:
UnsafeCell
<
JobResult
<
R
>
>
}
impl
<
L
F
R
>
StackJob
<
L
F
R
>
where
L
:
Latch
+
Sync
F
:
FnOnce
(
bool
)
-
>
R
+
Send
R
:
Send
{
pub
(
super
)
fn
new
(
func
:
F
latch
:
L
)
-
>
StackJob
<
L
F
R
>
{
StackJob
{
latch
func
:
UnsafeCell
:
:
new
(
Some
(
func
)
)
result
:
UnsafeCell
:
:
new
(
JobResult
:
:
None
)
}
}
pub
(
super
)
unsafe
fn
as_job_ref
(
&
self
)
-
>
JobRef
{
JobRef
:
:
new
(
self
)
}
pub
(
super
)
unsafe
fn
run_inline
(
self
stolen
:
bool
)
-
>
R
{
self
.
func
.
into_inner
(
)
.
unwrap
(
)
(
stolen
)
}
pub
(
super
)
unsafe
fn
into_result
(
self
)
-
>
R
{
self
.
result
.
into_inner
(
)
.
into_return_value
(
)
}
}
impl
<
L
F
R
>
Job
for
StackJob
<
L
F
R
>
where
L
:
Latch
+
Sync
F
:
FnOnce
(
bool
)
-
>
R
+
Send
R
:
Send
{
unsafe
fn
execute
(
this
:
*
const
Self
)
{
let
this
=
&
*
this
;
let
abort
=
unwind
:
:
AbortIfPanic
;
let
func
=
(
*
this
.
func
.
get
(
)
)
.
take
(
)
.
unwrap
(
)
;
(
*
this
.
result
.
get
(
)
)
=
match
unwind
:
:
halt_unwinding
(
|
|
func
(
true
)
)
{
Ok
(
x
)
=
>
JobResult
:
:
Ok
(
x
)
Err
(
x
)
=
>
JobResult
:
:
Panic
(
x
)
}
;
this
.
latch
.
set
(
)
;
mem
:
:
forget
(
abort
)
;
}
}
pub
(
super
)
struct
HeapJob
<
BODY
>
where
BODY
:
FnOnce
(
)
+
Send
{
job
:
UnsafeCell
<
Option
<
BODY
>
>
}
impl
<
BODY
>
HeapJob
<
BODY
>
where
BODY
:
FnOnce
(
)
+
Send
{
pub
(
super
)
fn
new
(
func
:
BODY
)
-
>
Self
{
HeapJob
{
job
:
UnsafeCell
:
:
new
(
Some
(
func
)
)
}
}
pub
(
super
)
unsafe
fn
as_job_ref
(
self
:
Box
<
Self
>
)
-
>
JobRef
{
let
this
:
*
const
Self
=
mem
:
:
transmute
(
self
)
;
JobRef
:
:
new
(
this
)
}
}
impl
<
BODY
>
Job
for
HeapJob
<
BODY
>
where
BODY
:
FnOnce
(
)
+
Send
{
unsafe
fn
execute
(
this
:
*
const
Self
)
{
let
this
:
Box
<
Self
>
=
mem
:
:
transmute
(
this
)
;
let
job
=
(
*
this
.
job
.
get
(
)
)
.
take
(
)
.
unwrap
(
)
;
job
(
)
;
}
}
impl
<
T
>
JobResult
<
T
>
{
pub
(
super
)
fn
into_return_value
(
self
)
-
>
T
{
match
self
{
JobResult
:
:
None
=
>
unreachable
!
(
)
JobResult
:
:
Ok
(
x
)
=
>
x
JobResult
:
:
Panic
(
x
)
=
>
unwind
:
:
resume_unwinding
(
x
)
}
}
}
pub
(
super
)
struct
JobFifo
{
inner
:
SegQueue
<
JobRef
>
}
impl
JobFifo
{
pub
(
super
)
fn
new
(
)
-
>
Self
{
JobFifo
{
inner
:
SegQueue
:
:
new
(
)
}
}
pub
(
super
)
unsafe
fn
push
(
&
self
job_ref
:
JobRef
)
-
>
JobRef
{
self
.
inner
.
push
(
job_ref
)
;
JobRef
:
:
new
(
self
)
}
}
impl
Job
for
JobFifo
{
unsafe
fn
execute
(
this
:
*
const
Self
)
{
(
*
this
)
.
inner
.
pop
(
)
.
expect
(
"
job
in
fifo
queue
"
)
.
execute
(
)
}
}
