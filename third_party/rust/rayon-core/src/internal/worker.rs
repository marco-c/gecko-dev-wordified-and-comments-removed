use
std
:
:
fmt
;
use
latch
:
:
LatchProbe
;
use
registry
;
pub
struct
WorkerThread
<
'
w
>
{
thread
:
&
'
w
registry
:
:
WorkerThread
}
impl
<
'
w
>
WorkerThread
<
'
w
>
{
pub
unsafe
fn
wait_until_true
<
F
>
(
&
self
f
:
F
)
where
F
:
Fn
(
)
-
>
bool
{
struct
DummyLatch
<
'
a
F
:
'
a
>
{
f
:
&
'
a
F
}
impl
<
'
a
F
:
Fn
(
)
-
>
bool
>
LatchProbe
for
DummyLatch
<
'
a
F
>
{
fn
probe
(
&
self
)
-
>
bool
{
(
self
.
f
)
(
)
}
}
self
.
thread
.
wait_until
(
&
DummyLatch
{
f
:
&
f
}
)
;
}
}
impl
<
'
w
>
fmt
:
:
Debug
for
WorkerThread
<
'
w
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
WorkerThread
"
)
.
field
(
"
pool
"
&
self
.
thread
.
registry
(
)
.
id
(
)
)
.
field
(
"
index
"
&
self
.
thread
.
index
(
)
)
.
finish
(
)
}
}
pub
fn
if_in_worker_thread
<
F
R
>
(
if_true
:
F
)
-
>
Option
<
R
>
where
F
:
FnOnce
(
&
WorkerThread
)
-
>
R
{
let
worker_thread
=
registry
:
:
WorkerThread
:
:
current
(
)
;
if
worker_thread
.
is_null
(
)
{
None
}
else
{
unsafe
{
let
wt
=
WorkerThread
{
thread
:
&
*
worker_thread
}
;
Some
(
if_true
(
&
wt
)
)
}
}
}
