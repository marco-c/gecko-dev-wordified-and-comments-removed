#
[
cfg
(
rayon_unstable
)
]
use
future
:
:
{
self
Future
RayonFuture
}
;
#
[
allow
(
unused_imports
)
]
use
latch
:
:
{
Latch
SpinLatch
}
;
use
job
:
:
*
;
use
registry
:
:
Registry
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
mem
;
use
std
:
:
sync
:
:
Arc
;
use
unwind
;
pub
fn
spawn
<
F
>
(
func
:
F
)
where
F
:
FnOnce
(
)
+
Send
+
'
static
{
unsafe
{
spawn_in
(
func
&
Registry
:
:
current
(
)
)
}
}
pub
unsafe
fn
spawn_in
<
F
>
(
func
:
F
registry
:
&
Arc
<
Registry
>
)
where
F
:
FnOnce
(
)
+
Send
+
'
static
{
registry
.
increment_terminate_count
(
)
;
let
async_job
=
Box
:
:
new
(
HeapJob
:
:
new
(
{
let
registry
=
registry
.
clone
(
)
;
move
|
|
{
match
unwind
:
:
halt_unwinding
(
func
)
{
Ok
(
(
)
)
=
>
{
}
Err
(
err
)
=
>
{
registry
.
handle_panic
(
err
)
;
}
}
registry
.
terminate
(
)
;
}
}
)
)
;
let
abort_guard
=
unwind
:
:
AbortIfPanic
;
let
job_ref
=
HeapJob
:
:
as_job_ref
(
async_job
)
;
registry
.
inject_or_push
(
job_ref
)
;
mem
:
:
forget
(
abort_guard
)
;
}
#
[
cfg
(
rayon_unstable
)
]
pub
fn
spawn_future
<
F
>
(
future
:
F
)
-
>
RayonFuture
<
F
:
:
Item
F
:
:
Error
>
where
F
:
Future
+
Send
+
'
static
{
unsafe
{
spawn_future_in
(
future
Registry
:
:
current
(
)
)
}
}
#
[
cfg
(
rayon_unstable
)
]
pub
unsafe
fn
spawn_future_in
<
F
>
(
future
:
F
registry
:
Arc
<
Registry
>
)
-
>
RayonFuture
<
F
:
:
Item
F
:
:
Error
>
where
F
:
Future
+
Send
+
'
static
{
let
scope
=
StaticFutureScope
:
:
new
(
registry
.
clone
(
)
)
;
future
:
:
new_rayon_future
(
future
scope
)
}
#
[
cfg
(
rayon_unstable
)
]
struct
StaticFutureScope
{
registry
:
Arc
<
Registry
>
}
#
[
cfg
(
rayon_unstable
)
]
impl
StaticFutureScope
{
unsafe
fn
new
(
registry
:
Arc
<
Registry
>
)
-
>
Self
{
registry
.
increment_terminate_count
(
)
;
StaticFutureScope
{
registry
:
registry
}
}
}
#
[
cfg
(
rayon_unstable
)
]
unsafe
impl
future
:
:
FutureScope
<
'
static
>
for
StaticFutureScope
{
fn
registry
(
&
self
)
-
>
Arc
<
Registry
>
{
self
.
registry
.
clone
(
)
}
fn
future_panicked
(
self
err
:
Box
<
Any
+
Send
>
)
{
self
.
registry
.
handle_panic
(
err
)
;
self
.
registry
.
terminate
(
)
;
}
fn
future_completed
(
self
)
{
self
.
registry
.
terminate
(
)
;
}
}
#
[
cfg
(
test
)
]
mod
test
;
