use
job
:
:
*
;
use
registry
:
:
Registry
;
use
std
:
:
mem
;
use
std
:
:
sync
:
:
Arc
;
use
unwind
;
pub
fn
spawn
<
F
>
(
func
:
F
)
where
F
:
FnOnce
(
)
+
Send
+
'
static
{
unsafe
{
spawn_in
(
func
&
Registry
:
:
current
(
)
)
}
}
pub
unsafe
fn
spawn_in
<
F
>
(
func
:
F
registry
:
&
Arc
<
Registry
>
)
where
F
:
FnOnce
(
)
+
Send
+
'
static
{
registry
.
increment_terminate_count
(
)
;
let
async_job
=
Box
:
:
new
(
HeapJob
:
:
new
(
{
let
registry
=
registry
.
clone
(
)
;
move
|
|
{
match
unwind
:
:
halt_unwinding
(
func
)
{
Ok
(
(
)
)
=
>
{
}
Err
(
err
)
=
>
{
registry
.
handle_panic
(
err
)
;
}
}
registry
.
terminate
(
)
;
}
}
)
)
;
let
abort_guard
=
unwind
:
:
AbortIfPanic
;
let
job_ref
=
HeapJob
:
:
as_job_ref
(
async_job
)
;
registry
.
inject_or_push
(
job_ref
)
;
mem
:
:
forget
(
abort_guard
)
;
}
#
[
cfg
(
test
)
]
mod
test
;
