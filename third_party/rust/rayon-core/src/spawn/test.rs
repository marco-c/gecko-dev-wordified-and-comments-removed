use
scope
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
sync
:
:
Mutex
;
use
std
:
:
sync
:
:
mpsc
:
:
channel
;
use
ThreadPoolBuilder
;
use
super
:
:
spawn
;
#
[
test
]
fn
spawn_then_join_in_worker
(
)
{
let
(
tx
rx
)
=
channel
(
)
;
scope
(
move
|
_
|
{
spawn
(
move
|
|
tx
.
send
(
22
)
.
unwrap
(
)
)
;
}
)
;
assert_eq
!
(
22
rx
.
recv
(
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
spawn_then_join_outside_worker
(
)
{
let
(
tx
rx
)
=
channel
(
)
;
spawn
(
move
|
|
tx
.
send
(
22
)
.
unwrap
(
)
)
;
assert_eq
!
(
22
rx
.
recv
(
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
panic_fwd
(
)
{
let
(
tx
rx
)
=
channel
(
)
;
let
tx
=
Mutex
:
:
new
(
tx
)
;
let
panic_handler
=
move
|
err
:
Box
<
Any
+
Send
>
|
{
let
tx
=
tx
.
lock
(
)
.
unwrap
(
)
;
if
let
Some
(
&
msg
)
=
err
.
downcast_ref
:
:
<
&
str
>
(
)
{
if
msg
=
=
"
Hello
world
!
"
{
tx
.
send
(
1
)
.
unwrap
(
)
;
}
else
{
tx
.
send
(
2
)
.
unwrap
(
)
;
}
}
else
{
tx
.
send
(
3
)
.
unwrap
(
)
;
}
}
;
let
builder
=
ThreadPoolBuilder
:
:
new
(
)
.
panic_handler
(
panic_handler
)
;
builder
.
build
(
)
.
unwrap
(
)
.
spawn
(
move
|
|
panic
!
(
"
Hello
world
!
"
)
)
;
assert_eq
!
(
1
rx
.
recv
(
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
termination_while_things_are_executing
(
)
{
let
(
tx0
rx0
)
=
channel
(
)
;
let
(
tx1
rx1
)
=
channel
(
)
;
{
let
thread_pool
=
ThreadPoolBuilder
:
:
new
(
)
.
build
(
)
.
unwrap
(
)
;
thread_pool
.
spawn
(
move
|
|
{
let
data
=
rx0
.
recv
(
)
.
unwrap
(
)
;
spawn
(
move
|
|
{
tx1
.
send
(
data
)
.
unwrap
(
)
;
}
)
;
}
)
;
}
tx0
.
send
(
22
)
.
unwrap
(
)
;
let
v
=
rx1
.
recv
(
)
.
unwrap
(
)
;
assert_eq
!
(
v
22
)
;
}
#
[
test
]
fn
custom_panic_handler_and_spawn
(
)
{
let
(
tx
rx
)
=
channel
(
)
;
let
tx
=
Mutex
:
:
new
(
tx
)
;
let
panic_handler
=
move
|
e
:
Box
<
Any
+
Send
>
|
{
tx
.
lock
(
)
.
unwrap
(
)
.
send
(
e
)
.
unwrap
(
)
;
}
;
let
builder
=
ThreadPoolBuilder
:
:
new
(
)
.
panic_handler
(
panic_handler
)
;
builder
.
build
(
)
.
unwrap
(
)
.
spawn
(
move
|
|
{
panic
!
(
"
Hello
world
!
"
)
;
}
)
;
let
error
=
rx
.
recv
(
)
.
unwrap
(
)
;
if
let
Some
(
&
msg
)
=
error
.
downcast_ref
:
:
<
&
str
>
(
)
{
assert_eq
!
(
msg
"
Hello
world
!
"
)
;
}
else
{
panic
!
(
"
did
not
receive
a
string
from
panic
handler
"
)
;
}
}
#
[
test
]
fn
custom_panic_handler_and_nested_spawn
(
)
{
let
(
tx
rx
)
=
channel
(
)
;
let
tx
=
Mutex
:
:
new
(
tx
)
;
let
panic_handler
=
move
|
e
|
{
tx
.
lock
(
)
.
unwrap
(
)
.
send
(
e
)
.
unwrap
(
)
;
}
;
const
PANICS
:
usize
=
3
;
let
builder
=
ThreadPoolBuilder
:
:
new
(
)
.
panic_handler
(
panic_handler
)
;
builder
.
build
(
)
.
unwrap
(
)
.
spawn
(
move
|
|
{
for
_
in
0
.
.
PANICS
{
spawn
(
move
|
|
{
panic
!
(
"
Hello
world
!
"
)
;
}
)
;
}
}
)
;
for
_
in
0
.
.
PANICS
{
let
error
=
rx
.
recv
(
)
.
unwrap
(
)
;
if
let
Some
(
&
msg
)
=
error
.
downcast_ref
:
:
<
&
str
>
(
)
{
assert_eq
!
(
msg
"
Hello
world
!
"
)
;
}
else
{
panic
!
(
"
did
not
receive
a
string
from
panic
handler
"
)
;
}
}
}
