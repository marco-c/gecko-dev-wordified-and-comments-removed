#
[
cfg
(
feature
=
"
unstable
"
)
]
use
future
:
:
{
self
Future
RayonFuture
}
;
use
latch
:
:
{
Latch
CountLatch
}
;
use
log
:
:
Event
:
:
*
;
use
job
:
:
HeapJob
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicPtr
Ordering
}
;
use
registry
:
:
{
in_worker
Registry
WorkerThread
}
;
use
unwind
;
#
[
cfg
(
test
)
]
mod
test
;
pub
struct
Scope
<
'
scope
>
{
owner_thread
:
*
const
WorkerThread
panic
:
AtomicPtr
<
Box
<
Any
+
Send
+
'
static
>
>
job_completed_latch
:
CountLatch
marker
:
PhantomData
<
Box
<
FnOnce
(
&
Scope
<
'
scope
>
)
+
'
scope
>
>
}
pub
fn
scope
<
'
scope
OP
R
>
(
op
:
OP
)
-
>
R
where
OP
:
for
<
'
s
>
FnOnce
(
&
'
s
Scope
<
'
scope
>
)
-
>
R
+
'
scope
+
Send
R
:
Send
{
in_worker
(
|
owner_thread
|
{
unsafe
{
let
scope
:
Scope
<
'
scope
>
=
Scope
{
owner_thread
:
owner_thread
as
*
const
WorkerThread
as
*
mut
WorkerThread
panic
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
job_completed_latch
:
CountLatch
:
:
new
(
)
marker
:
PhantomData
}
;
let
result
=
scope
.
execute_job_closure
(
op
)
;
scope
.
steal_till_jobs_complete
(
)
;
result
.
unwrap
(
)
}
}
)
}
impl
<
'
scope
>
Scope
<
'
scope
>
{
pub
fn
spawn
<
BODY
>
(
&
self
body
:
BODY
)
where
BODY
:
FnOnce
(
&
Scope
<
'
scope
>
)
+
'
scope
{
unsafe
{
self
.
job_completed_latch
.
increment
(
)
;
let
job_ref
=
Box
:
:
new
(
HeapJob
:
:
new
(
move
|
|
self
.
execute_job
(
body
)
)
)
.
as_job_ref
(
)
;
let
worker_thread
=
WorkerThread
:
:
current
(
)
;
debug_assert
!
(
!
WorkerThread
:
:
current
(
)
.
is_null
(
)
)
;
let
worker_thread
=
&
*
worker_thread
;
worker_thread
.
push
(
job_ref
)
;
}
}
#
[
cfg
(
feature
=
"
unstable
"
)
]
pub
fn
spawn_future
<
F
>
(
&
self
future
:
F
)
-
>
RayonFuture
<
F
:
:
Item
F
:
:
Error
>
where
F
:
Future
+
Send
+
'
scope
{
let
future_scope
=
unsafe
{
ScopeFutureScope
:
:
new
(
self
)
}
;
return
future
:
:
new_rayon_future
(
future
future_scope
)
;
struct
ScopeFutureScope
<
'
scope
>
{
scope
:
*
const
Scope
<
'
scope
>
}
impl
<
'
scope
>
ScopeFutureScope
<
'
scope
>
{
unsafe
fn
new
(
scope
:
&
Scope
<
'
scope
>
)
-
>
Self
{
scope
.
job_completed_latch
.
increment
(
)
;
ScopeFutureScope
{
scope
:
scope
}
}
}
unsafe
impl
<
'
scope
>
future
:
:
FutureScope
<
'
scope
>
for
ScopeFutureScope
<
'
scope
>
{
fn
registry
(
&
self
)
-
>
Arc
<
Registry
>
{
unsafe
{
(
*
(
*
self
.
scope
)
.
owner_thread
)
.
registry
(
)
.
clone
(
)
}
}
fn
future_completed
(
self
)
{
unsafe
{
(
*
self
.
scope
)
.
job_completed_ok
(
)
;
}
}
fn
future_panicked
(
self
err
:
Box
<
Any
+
Send
>
)
{
unsafe
{
(
*
self
.
scope
)
.
job_panicked
(
err
)
;
}
}
}
}
unsafe
fn
execute_job
<
FUNC
>
(
&
self
func
:
FUNC
)
where
FUNC
:
FnOnce
(
&
Scope
<
'
scope
>
)
+
'
scope
{
let
_
:
Option
<
(
)
>
=
self
.
execute_job_closure
(
func
)
;
}
unsafe
fn
execute_job_closure
<
FUNC
R
>
(
&
self
func
:
FUNC
)
-
>
Option
<
R
>
where
FUNC
:
FnOnce
(
&
Scope
<
'
scope
>
)
-
>
R
+
'
scope
{
match
unwind
:
:
halt_unwinding
(
move
|
|
func
(
self
)
)
{
Ok
(
r
)
=
>
{
self
.
job_completed_ok
(
)
;
Some
(
r
)
}
Err
(
err
)
=
>
{
self
.
job_panicked
(
err
)
;
None
}
}
}
unsafe
fn
job_panicked
(
&
self
err
:
Box
<
Any
+
Send
+
'
static
>
)
{
let
nil
=
ptr
:
:
null_mut
(
)
;
let
mut
err
=
Box
:
:
new
(
err
)
;
if
self
.
panic
.
compare_exchange
(
nil
&
mut
*
err
Ordering
:
:
Release
Ordering
:
:
Relaxed
)
.
is_ok
(
)
{
log
!
(
JobPanickedErrorStored
{
owner_thread
:
(
*
self
.
owner_thread
)
.
index
(
)
}
)
;
mem
:
:
forget
(
err
)
;
}
else
{
log
!
(
JobPanickedErrorNotStored
{
owner_thread
:
(
*
self
.
owner_thread
)
.
index
(
)
}
)
;
}
self
.
job_completed_latch
.
set
(
)
;
}
unsafe
fn
job_completed_ok
(
&
self
)
{
log
!
(
JobCompletedOk
{
owner_thread
:
(
*
self
.
owner_thread
)
.
index
(
)
}
)
;
self
.
job_completed_latch
.
set
(
)
;
}
unsafe
fn
steal_till_jobs_complete
(
&
self
)
{
(
*
self
.
owner_thread
)
.
wait_until
(
&
self
.
job_completed_latch
)
;
let
panic
=
self
.
panic
.
swap
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
if
!
panic
.
is_null
(
)
{
log
!
(
ScopeCompletePanicked
{
owner_thread
:
(
*
self
.
owner_thread
)
.
index
(
)
}
)
;
let
value
:
Box
<
Box
<
Any
+
Send
+
'
static
>
>
=
mem
:
:
transmute
(
panic
)
;
unwind
:
:
resume_unwinding
(
*
value
)
;
}
else
{
log
!
(
ScopeCompleteNoPanic
{
owner_thread
:
(
*
self
.
owner_thread
)
.
index
(
)
}
)
;
}
}
}
