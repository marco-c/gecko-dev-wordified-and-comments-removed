use
latch
:
:
{
Latch
CountLatch
}
;
use
log
:
:
Event
:
:
*
;
use
job
:
:
HeapJob
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
fmt
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicPtr
Ordering
}
;
use
registry
:
:
{
in_worker
WorkerThread
Registry
}
;
use
unwind
;
#
[
cfg
(
test
)
]
mod
test
;
mod
internal
;
pub
struct
Scope
<
'
scope
>
{
owner_thread_index
:
usize
registry
:
Arc
<
Registry
>
panic
:
AtomicPtr
<
Box
<
Any
+
Send
+
'
static
>
>
job_completed_latch
:
CountLatch
marker
:
PhantomData
<
Box
<
FnOnce
(
&
Scope
<
'
scope
>
)
+
Send
+
Sync
+
'
scope
>
>
}
pub
fn
scope
<
'
scope
OP
R
>
(
op
:
OP
)
-
>
R
where
OP
:
for
<
'
s
>
FnOnce
(
&
'
s
Scope
<
'
scope
>
)
-
>
R
+
'
scope
+
Send
R
:
Send
{
in_worker
(
|
owner_thread
_
|
{
unsafe
{
let
scope
:
Scope
<
'
scope
>
=
Scope
{
owner_thread_index
:
owner_thread
.
index
(
)
registry
:
owner_thread
.
registry
(
)
.
clone
(
)
panic
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
job_completed_latch
:
CountLatch
:
:
new
(
)
marker
:
PhantomData
}
;
let
result
=
scope
.
execute_job_closure
(
op
)
;
scope
.
steal_till_jobs_complete
(
owner_thread
)
;
result
.
unwrap
(
)
}
}
)
}
impl
<
'
scope
>
Scope
<
'
scope
>
{
pub
fn
spawn
<
BODY
>
(
&
self
body
:
BODY
)
where
BODY
:
FnOnce
(
&
Scope
<
'
scope
>
)
+
Send
+
'
scope
{
unsafe
{
self
.
job_completed_latch
.
increment
(
)
;
let
job_ref
=
Box
:
:
new
(
HeapJob
:
:
new
(
move
|
|
self
.
execute_job
(
body
)
)
)
.
as_job_ref
(
)
;
self
.
registry
.
inject_or_push
(
job_ref
)
;
}
}
unsafe
fn
execute_job
<
FUNC
>
(
&
self
func
:
FUNC
)
where
FUNC
:
FnOnce
(
&
Scope
<
'
scope
>
)
+
'
scope
{
let
_
:
Option
<
(
)
>
=
self
.
execute_job_closure
(
func
)
;
}
unsafe
fn
execute_job_closure
<
FUNC
R
>
(
&
self
func
:
FUNC
)
-
>
Option
<
R
>
where
FUNC
:
FnOnce
(
&
Scope
<
'
scope
>
)
-
>
R
+
'
scope
{
match
unwind
:
:
halt_unwinding
(
move
|
|
func
(
self
)
)
{
Ok
(
r
)
=
>
{
self
.
job_completed_ok
(
)
;
Some
(
r
)
}
Err
(
err
)
=
>
{
self
.
job_panicked
(
err
)
;
None
}
}
}
unsafe
fn
job_panicked
(
&
self
err
:
Box
<
Any
+
Send
+
'
static
>
)
{
let
nil
=
ptr
:
:
null_mut
(
)
;
let
mut
err
=
Box
:
:
new
(
err
)
;
if
self
.
panic
.
compare_exchange
(
nil
&
mut
*
err
Ordering
:
:
Release
Ordering
:
:
Relaxed
)
.
is_ok
(
)
{
log
!
(
JobPanickedErrorStored
{
owner_thread
:
self
.
owner_thread_index
}
)
;
mem
:
:
forget
(
err
)
;
}
else
{
log
!
(
JobPanickedErrorNotStored
{
owner_thread
:
self
.
owner_thread_index
}
)
;
}
self
.
job_completed_latch
.
set
(
)
;
}
unsafe
fn
job_completed_ok
(
&
self
)
{
log
!
(
JobCompletedOk
{
owner_thread
:
self
.
owner_thread_index
}
)
;
self
.
job_completed_latch
.
set
(
)
;
}
unsafe
fn
steal_till_jobs_complete
(
&
self
owner_thread
:
&
WorkerThread
)
{
owner_thread
.
wait_until
(
&
self
.
job_completed_latch
)
;
let
panic
=
self
.
panic
.
swap
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
if
!
panic
.
is_null
(
)
{
log
!
(
ScopeCompletePanicked
{
owner_thread
:
owner_thread
.
index
(
)
}
)
;
let
value
:
Box
<
Box
<
Any
+
Send
+
'
static
>
>
=
mem
:
:
transmute
(
panic
)
;
unwind
:
:
resume_unwinding
(
*
value
)
;
}
else
{
log
!
(
ScopeCompleteNoPanic
{
owner_thread
:
owner_thread
.
index
(
)
}
)
;
}
}
}
impl
<
'
scope
>
fmt
:
:
Debug
for
Scope
<
'
scope
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Scope
"
)
.
field
(
"
pool_id
"
&
self
.
registry
.
id
(
)
)
.
field
(
"
owner_thread_index
"
&
self
.
owner_thread_index
)
.
field
(
"
panic
"
&
self
.
panic
)
.
field
(
"
job_completed_latch
"
&
self
.
job_completed_latch
)
.
finish
(
)
}
}
