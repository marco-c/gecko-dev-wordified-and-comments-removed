use
Configuration
;
#
[
cfg
(
feature
=
"
unstable
"
)
]
use
future
:
:
{
Future
RayonFuture
}
;
use
latch
:
:
LockLatch
;
#
[
allow
(
unused_imports
)
]
use
log
:
:
Event
:
:
*
;
use
job
:
:
StackJob
;
#
[
cfg
(
feature
=
"
unstable
"
)
]
use
spawn_async
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
error
:
:
Error
;
use
registry
:
:
{
Registry
WorkerThread
}
;
mod
test
;
pub
struct
ThreadPool
{
registry
:
Arc
<
Registry
>
}
impl
ThreadPool
{
pub
fn
new
(
configuration
:
Configuration
)
-
>
Result
<
ThreadPool
Box
<
Error
>
>
{
let
registry
=
try
!
(
Registry
:
:
new
(
configuration
)
)
;
Ok
(
ThreadPool
{
registry
:
registry
}
)
}
pub
fn
install
<
OP
R
>
(
&
self
op
:
OP
)
-
>
R
where
OP
:
FnOnce
(
)
-
>
R
+
Send
{
unsafe
{
let
job_a
=
StackJob
:
:
new
(
op
LockLatch
:
:
new
(
)
)
;
self
.
registry
.
inject
(
&
[
job_a
.
as_job_ref
(
)
]
)
;
job_a
.
latch
.
wait
(
)
;
job_a
.
into_result
(
)
}
}
pub
fn
current_num_threads
(
&
self
)
-
>
usize
{
self
.
registry
.
num_threads
(
)
}
pub
fn
current_thread_index
(
&
self
)
-
>
Option
<
usize
>
{
unsafe
{
let
curr
=
WorkerThread
:
:
current
(
)
;
if
curr
.
is_null
(
)
{
None
}
else
if
(
*
curr
)
.
registry
(
)
.
id
(
)
!
=
self
.
registry
.
id
(
)
{
None
}
else
{
Some
(
(
*
curr
)
.
index
(
)
)
}
}
}
#
[
cfg
(
feature
=
"
unstable
"
)
]
pub
fn
spawn_async
<
OP
>
(
&
self
op
:
OP
)
where
OP
:
FnOnce
(
)
+
Send
+
'
static
{
unsafe
{
spawn_async
:
:
spawn_async_in
(
op
&
self
.
registry
)
}
}
#
[
cfg
(
feature
=
"
unstable
"
)
]
pub
fn
spawn_future_async
<
F
>
(
&
self
future
:
F
)
-
>
RayonFuture
<
F
:
:
Item
F
:
:
Error
>
where
F
:
Future
+
Send
+
'
static
{
unsafe
{
spawn_async
:
:
spawn_future_async_in
(
future
self
.
registry
.
clone
(
)
)
}
}
}
impl
Drop
for
ThreadPool
{
fn
drop
(
&
mut
self
)
{
self
.
registry
.
terminate
(
)
;
}
}
