#
!
[
cfg
(
test
)
]
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
Configuration
;
use
join
;
use
super
:
:
ThreadPool
;
use
unwind
;
#
[
test
]
#
[
should_panic
(
expected
=
"
Hello
world
!
"
)
]
fn
panic_propagate
(
)
{
let
thread_pool
=
ThreadPool
:
:
new
(
Configuration
:
:
new
(
)
)
.
unwrap
(
)
;
thread_pool
.
install
(
|
|
{
panic
!
(
"
Hello
world
!
"
)
;
}
)
;
}
#
[
test
]
fn
workers_stop
(
)
{
let
registry
;
{
let
thread_pool
=
ThreadPool
:
:
new
(
Configuration
:
:
new
(
)
.
num_threads
(
22
)
)
.
unwrap
(
)
;
registry
=
thread_pool
.
install
(
|
|
{
join_a_lot
(
22
)
;
thread_pool
.
registry
.
clone
(
)
}
)
;
assert_eq
!
(
registry
.
num_threads
(
)
22
)
;
}
registry
.
wait_until_stopped
(
)
;
}
fn
join_a_lot
(
n
:
usize
)
{
if
n
>
0
{
join
(
|
|
join_a_lot
(
n
-
1
)
|
|
join_a_lot
(
n
-
1
)
)
;
}
}
#
[
test
]
fn
sleeper_stop
(
)
{
use
std
:
:
{
thread
time
}
;
let
registry
;
{
let
thread_pool
=
ThreadPool
:
:
new
(
Configuration
:
:
new
(
)
.
num_threads
(
22
)
)
.
unwrap
(
)
;
registry
=
thread_pool
.
registry
.
clone
(
)
;
thread
:
:
sleep
(
time
:
:
Duration
:
:
from_secs
(
1
)
)
;
}
registry
.
wait_until_stopped
(
)
;
}
fn
count_handler
(
)
-
>
(
Arc
<
AtomicUsize
>
Box
<
:
:
StartHandler
>
)
{
let
count
=
Arc
:
:
new
(
AtomicUsize
:
:
new
(
0
)
)
;
(
count
.
clone
(
)
Box
:
:
new
(
move
|
_
|
{
count
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
}
)
)
}
fn
wait_for_counter
(
mut
counter
:
Arc
<
AtomicUsize
>
)
-
>
usize
{
use
std
:
:
{
thread
time
}
;
for
_
in
0
.
.
60
{
counter
=
match
Arc
:
:
try_unwrap
(
counter
)
{
Ok
(
counter
)
=
>
return
counter
.
into_inner
(
)
Err
(
counter
)
=
>
{
thread
:
:
sleep
(
time
:
:
Duration
:
:
from_secs
(
1
)
)
;
counter
}
}
;
}
panic
!
(
"
Counter
is
still
shared
!
"
)
;
}
#
[
test
]
fn
failed_thread_stack
(
)
{
let
stack_size
=
:
:
std
:
:
isize
:
:
MAX
as
usize
;
let
(
start_count
start_handler
)
=
count_handler
(
)
;
let
(
exit_count
exit_handler
)
=
count_handler
(
)
;
let
config
=
Configuration
:
:
new
(
)
.
num_threads
(
10
)
.
stack_size
(
stack_size
)
.
start_handler
(
move
|
i
|
start_handler
(
i
)
)
.
exit_handler
(
move
|
i
|
exit_handler
(
i
)
)
;
let
pool
=
ThreadPool
:
:
new
(
config
)
;
assert
!
(
pool
.
is_err
(
)
"
thread
stack
should
have
failed
!
"
)
;
let
start_count
=
wait_for_counter
(
start_count
)
;
assert
!
(
start_count
<
=
1
)
;
assert_eq
!
(
start_count
wait_for_counter
(
exit_count
)
)
;
}
#
[
test
]
fn
panic_thread_name
(
)
{
let
(
start_count
start_handler
)
=
count_handler
(
)
;
let
(
exit_count
exit_handler
)
=
count_handler
(
)
;
let
config
=
Configuration
:
:
new
(
)
.
num_threads
(
10
)
.
start_handler
(
move
|
i
|
start_handler
(
i
)
)
.
exit_handler
(
move
|
i
|
exit_handler
(
i
)
)
.
thread_name
(
|
i
|
{
if
i
>
=
5
{
panic
!
(
)
;
}
format
!
(
"
panic_thread_name
#
{
}
"
i
)
}
)
;
let
pool
=
unwind
:
:
halt_unwinding
(
|
|
ThreadPool
:
:
new
(
config
)
)
;
assert
!
(
pool
.
is_err
(
)
"
thread
-
name
panic
should
propagate
!
"
)
;
assert_eq
!
(
5
wait_for_counter
(
start_count
)
)
;
assert_eq
!
(
5
wait_for_counter
(
exit_count
)
)
;
}
