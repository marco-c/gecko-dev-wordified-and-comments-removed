#
!
[
allow
(
non_camel_case_types
)
]
#
!
[
cfg_attr
(
test
feature
(
conservative_impl_trait
)
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
unstable
"
)
allow
(
warnings
)
)
]
#
[
allow
(
unused_imports
)
]
use
log
:
:
Event
:
:
*
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
env
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
str
:
:
FromStr
;
use
std
:
:
fmt
;
extern
crate
coco
;
#
[
macro_use
]
extern
crate
lazy_static
;
#
[
cfg
(
rayon_unstable
)
]
extern
crate
futures
;
extern
crate
libc
;
extern
crate
num_cpus
;
extern
crate
rand
;
#
[
macro_use
]
mod
log
;
mod
latch
;
mod
join
;
mod
job
;
mod
registry
;
#
[
cfg
(
rayon_unstable
)
]
mod
future
;
mod
scope
;
mod
sleep
;
mod
spawn
;
mod
test
;
mod
thread_pool
;
mod
unwind
;
mod
util
;
pub
use
thread_pool
:
:
ThreadPool
;
pub
use
thread_pool
:
:
current_thread_index
;
pub
use
thread_pool
:
:
current_thread_has_pending_tasks
;
pub
use
join
:
:
join
;
pub
use
scope
:
:
{
scope
Scope
}
;
pub
use
spawn
:
:
spawn
;
#
[
cfg
(
rayon_unstable
)
]
pub
use
spawn
:
:
spawn_future
;
#
[
cfg
(
rayon_unstable
)
]
pub
use
future
:
:
RayonFuture
;
pub
fn
current_num_threads
(
)
-
>
usize
{
:
:
registry
:
:
Registry
:
:
current_num_threads
(
)
}
#
[
derive
(
Default
)
]
pub
struct
Configuration
{
num_threads
:
usize
panic_handler
:
Option
<
Box
<
PanicHandler
>
>
get_thread_name
:
Option
<
Box
<
FnMut
(
usize
)
-
>
String
>
>
stack_size
:
Option
<
usize
>
start_handler
:
Option
<
Box
<
StartHandler
>
>
exit_handler
:
Option
<
Box
<
ExitHandler
>
>
breadth_first
:
bool
}
type
PanicHandler
=
Fn
(
Box
<
Any
+
Send
>
)
+
Send
+
Sync
;
type
StartHandler
=
Fn
(
usize
)
+
Send
+
Sync
;
type
ExitHandler
=
Fn
(
usize
)
+
Send
+
Sync
;
impl
Configuration
{
pub
fn
new
(
)
-
>
Configuration
{
Configuration
:
:
default
(
)
}
fn
get_num_threads
(
&
self
)
-
>
usize
{
if
self
.
num_threads
>
0
{
self
.
num_threads
}
else
{
match
env
:
:
var
(
"
RAYON_NUM_THREADS
"
)
.
ok
(
)
.
and_then
(
|
s
|
usize
:
:
from_str
(
&
s
)
.
ok
(
)
)
{
Some
(
x
)
if
x
>
0
=
>
return
x
Some
(
x
)
if
x
=
=
0
=
>
return
num_cpus
:
:
get
(
)
_
=
>
{
}
}
match
env
:
:
var
(
"
RAYON_RS_NUM_CPUS
"
)
.
ok
(
)
.
and_then
(
|
s
|
usize
:
:
from_str
(
&
s
)
.
ok
(
)
)
{
Some
(
x
)
if
x
>
0
=
>
x
_
=
>
num_cpus
:
:
get
(
)
}
}
}
fn
get_thread_name
(
&
mut
self
index
:
usize
)
-
>
Option
<
String
>
{
self
.
get_thread_name
.
as_mut
(
)
.
map
(
|
c
|
c
(
index
)
)
}
pub
fn
thread_name
<
F
>
(
mut
self
closure
:
F
)
-
>
Self
where
F
:
FnMut
(
usize
)
-
>
String
+
'
static
{
self
.
get_thread_name
=
Some
(
Box
:
:
new
(
closure
)
)
;
self
}
pub
fn
num_threads
(
mut
self
num_threads
:
usize
)
-
>
Configuration
{
self
.
num_threads
=
num_threads
;
self
}
fn
take_panic_handler
(
&
mut
self
)
-
>
Option
<
Box
<
PanicHandler
>
>
{
self
.
panic_handler
.
take
(
)
}
pub
fn
panic_handler
<
H
>
(
mut
self
panic_handler
:
H
)
-
>
Configuration
where
H
:
Fn
(
Box
<
Any
+
Send
>
)
+
Send
+
Sync
+
'
static
{
self
.
panic_handler
=
Some
(
Box
:
:
new
(
panic_handler
)
)
;
self
}
fn
get_stack_size
(
&
self
)
-
>
Option
<
usize
>
{
self
.
stack_size
}
pub
fn
stack_size
(
mut
self
stack_size
:
usize
)
-
>
Self
{
self
.
stack_size
=
Some
(
stack_size
)
;
self
}
pub
fn
breadth_first
(
mut
self
)
-
>
Self
{
self
.
breadth_first
=
true
;
self
}
fn
get_breadth_first
(
&
self
)
-
>
bool
{
self
.
breadth_first
}
fn
take_start_handler
(
&
mut
self
)
-
>
Option
<
Box
<
StartHandler
>
>
{
self
.
start_handler
.
take
(
)
}
pub
fn
start_handler
<
H
>
(
mut
self
start_handler
:
H
)
-
>
Configuration
where
H
:
Fn
(
usize
)
+
Send
+
Sync
+
'
static
{
self
.
start_handler
=
Some
(
Box
:
:
new
(
start_handler
)
)
;
self
}
fn
take_exit_handler
(
&
mut
self
)
-
>
Option
<
Box
<
ExitHandler
>
>
{
self
.
exit_handler
.
take
(
)
}
pub
fn
exit_handler
<
H
>
(
mut
self
exit_handler
:
H
)
-
>
Configuration
where
H
:
Fn
(
usize
)
+
Send
+
Sync
+
'
static
{
self
.
exit_handler
=
Some
(
Box
:
:
new
(
exit_handler
)
)
;
self
}
}
pub
fn
initialize
(
config
:
Configuration
)
-
>
Result
<
(
)
Box
<
Error
>
>
{
let
registry
=
try
!
(
registry
:
:
init_global_registry
(
config
)
)
;
registry
.
wait_until_primed
(
)
;
Ok
(
(
)
)
}
impl
fmt
:
:
Debug
for
Configuration
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
Configuration
{
ref
num_threads
ref
get_thread_name
ref
panic_handler
ref
stack_size
ref
start_handler
ref
exit_handler
ref
breadth_first
}
=
*
self
;
let
get_thread_name
=
get_thread_name
.
as_ref
(
)
.
map
(
|
_
|
"
<
closure
>
"
)
;
let
panic_handler
=
panic_handler
.
as_ref
(
)
.
map
(
|
_
|
"
<
closure
>
"
)
;
let
start_handler
=
start_handler
.
as_ref
(
)
.
map
(
|
_
|
"
<
closure
>
"
)
;
let
exit_handler
=
exit_handler
.
as_ref
(
)
.
map
(
|
_
|
"
<
closure
>
"
)
;
f
.
debug_struct
(
"
Configuration
"
)
.
field
(
"
num_threads
"
num_threads
)
.
field
(
"
get_thread_name
"
&
get_thread_name
)
.
field
(
"
panic_handler
"
&
panic_handler
)
.
field
(
"
stack_size
"
&
stack_size
)
.
field
(
"
start_handler
"
&
start_handler
)
.
field
(
"
exit_handler
"
&
exit_handler
)
.
field
(
"
breadth_first
"
&
breadth_first
)
.
finish
(
)
}
}
