pub
use
crate
:
:
pipeline_cache
:
:
PipelineCacheValidationError
;
use
crate
:
:
{
binding_model
:
:
{
CreateBindGroupLayoutError
CreatePipelineLayoutError
PipelineLayout
}
command
:
:
ColorAttachmentError
device
:
:
{
Device
DeviceError
MissingDownlevelFlags
MissingFeatures
RenderPassContext
}
hal_api
:
:
HalApi
id
:
:
{
PipelineCacheId
PipelineLayoutId
ShaderModuleId
}
resource
:
:
{
ParentDevice
Resource
ResourceInfo
ResourceType
}
resource_log
validation
Label
}
;
use
arrayvec
:
:
ArrayVec
;
use
naga
:
:
error
:
:
ShaderError
;
use
std
:
:
{
borrow
:
:
Cow
marker
:
:
PhantomData
num
:
:
NonZeroU32
sync
:
:
Arc
}
;
use
thiserror
:
:
Error
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
LateSizedBufferGroup
{
pub
(
crate
)
shader_sizes
:
Vec
<
wgt
:
:
BufferAddress
>
}
#
[
allow
(
clippy
:
:
large_enum_variant
)
]
pub
enum
ShaderModuleSource
<
'
a
>
{
#
[
cfg
(
feature
=
"
wgsl
"
)
]
Wgsl
(
Cow
<
'
a
str
>
)
#
[
cfg
(
feature
=
"
glsl
"
)
]
Glsl
(
Cow
<
'
a
str
>
naga
:
:
front
:
:
glsl
:
:
Options
)
#
[
cfg
(
feature
=
"
spirv
"
)
]
SpirV
(
Cow
<
'
a
[
u32
]
>
naga
:
:
front
:
:
spv
:
:
Options
)
Naga
(
Cow
<
'
static
naga
:
:
Module
>
)
#
[
doc
(
hidden
)
]
Dummy
(
PhantomData
<
&
'
a
(
)
>
)
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
ShaderModuleDescriptor
<
'
a
>
{
pub
label
:
Label
<
'
a
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
shader_bound_checks
:
wgt
:
:
ShaderBoundChecks
}
#
[
derive
(
Debug
)
]
pub
struct
ShaderModule
<
A
:
HalApi
>
{
pub
(
crate
)
raw
:
Option
<
A
:
:
ShaderModule
>
pub
(
crate
)
device
:
Arc
<
Device
<
A
>
>
pub
(
crate
)
interface
:
Option
<
validation
:
:
Interface
>
pub
(
crate
)
info
:
ResourceInfo
<
ShaderModule
<
A
>
>
}
impl
<
A
:
HalApi
>
Drop
for
ShaderModule
<
A
>
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
raw
)
=
self
.
raw
.
take
(
)
{
resource_log
!
(
"
Destroy
raw
{
}
"
self
.
error_ident
(
)
)
;
unsafe
{
use
hal
:
:
Device
;
self
.
device
.
raw
(
)
.
destroy_shader_module
(
raw
)
;
}
}
}
}
impl
<
A
:
HalApi
>
Resource
for
ShaderModule
<
A
>
{
const
TYPE
:
ResourceType
=
"
ShaderModule
"
;
type
Marker
=
crate
:
:
id
:
:
markers
:
:
ShaderModule
;
fn
as_info
(
&
self
)
-
>
&
ResourceInfo
<
Self
>
{
&
self
.
info
}
fn
as_info_mut
(
&
mut
self
)
-
>
&
mut
ResourceInfo
<
Self
>
{
&
mut
self
.
info
}
}
impl
<
A
:
HalApi
>
ParentDevice
<
A
>
for
ShaderModule
<
A
>
{
fn
device
(
&
self
)
-
>
&
Arc
<
Device
<
A
>
>
{
&
self
.
device
}
}
impl
<
A
:
HalApi
>
ShaderModule
<
A
>
{
pub
(
crate
)
fn
raw
(
&
self
)
-
>
&
A
:
:
ShaderModule
{
self
.
raw
.
as_ref
(
)
.
unwrap
(
)
}
pub
(
crate
)
fn
finalize_entry_point_name
(
&
self
stage_bit
:
wgt
:
:
ShaderStages
entry_point
:
Option
<
&
str
>
)
-
>
Result
<
String
validation
:
:
StageError
>
{
match
&
self
.
interface
{
Some
(
interface
)
=
>
interface
.
finalize_entry_point_name
(
stage_bit
entry_point
)
None
=
>
entry_point
.
map
(
|
ep
|
ep
.
to_string
(
)
)
.
ok_or
(
validation
:
:
StageError
:
:
NoEntryPointFound
)
}
}
}
#
[
derive
(
Clone
Debug
Error
)
]
#
[
non_exhaustive
]
pub
enum
CreateShaderModuleError
{
#
[
cfg
(
feature
=
"
wgsl
"
)
]
#
[
error
(
transparent
)
]
Parsing
(
#
[
from
]
ShaderError
<
naga
:
:
front
:
:
wgsl
:
:
ParseError
>
)
#
[
cfg
(
feature
=
"
glsl
"
)
]
#
[
error
(
transparent
)
]
ParsingGlsl
(
#
[
from
]
ShaderError
<
naga
:
:
front
:
:
glsl
:
:
ParseErrors
>
)
#
[
cfg
(
feature
=
"
spirv
"
)
]
#
[
error
(
transparent
)
]
ParsingSpirV
(
#
[
from
]
ShaderError
<
naga
:
:
front
:
:
spv
:
:
Error
>
)
#
[
error
(
"
Failed
to
generate
the
backend
-
specific
code
"
)
]
Generation
#
[
error
(
transparent
)
]
Device
(
#
[
from
]
DeviceError
)
#
[
error
(
transparent
)
]
Validation
(
#
[
from
]
ShaderError
<
naga
:
:
WithSpan
<
naga
:
:
valid
:
:
ValidationError
>
>
)
#
[
error
(
transparent
)
]
MissingFeatures
(
#
[
from
]
MissingFeatures
)
#
[
error
(
"
Shader
global
{
bind
:
?
}
uses
a
group
index
{
group
}
that
exceeds
the
max_bind_groups
limit
of
{
limit
}
.
"
)
]
InvalidGroupIndex
{
bind
:
naga
:
:
ResourceBinding
group
:
u32
limit
:
u32
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
ProgrammableStageDescriptor
<
'
a
>
{
pub
module
:
ShaderModuleId
pub
entry_point
:
Option
<
Cow
<
'
a
str
>
>
pub
constants
:
Cow
<
'
a
naga
:
:
back
:
:
PipelineConstants
>
pub
zero_initialize_workgroup_memory
:
bool
pub
vertex_pulling_transform
:
bool
}
pub
type
ImplicitBindGroupCount
=
u8
;
#
[
derive
(
Clone
Debug
Error
)
]
#
[
non_exhaustive
]
pub
enum
ImplicitLayoutError
{
#
[
error
(
"
Missing
IDs
for
deriving
{
0
}
bind
groups
"
)
]
MissingIds
(
ImplicitBindGroupCount
)
#
[
error
(
"
Unable
to
reflect
the
shader
{
0
:
?
}
interface
"
)
]
ReflectionError
(
wgt
:
:
ShaderStages
)
#
[
error
(
transparent
)
]
BindGroup
(
#
[
from
]
CreateBindGroupLayoutError
)
#
[
error
(
transparent
)
]
Pipeline
(
#
[
from
]
CreatePipelineLayoutError
)
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
ComputePipelineDescriptor
<
'
a
>
{
pub
label
:
Label
<
'
a
>
pub
layout
:
Option
<
PipelineLayoutId
>
pub
stage
:
ProgrammableStageDescriptor
<
'
a
>
pub
cache
:
Option
<
PipelineCacheId
>
}
#
[
derive
(
Clone
Debug
Error
)
]
#
[
non_exhaustive
]
pub
enum
CreateComputePipelineError
{
#
[
error
(
transparent
)
]
Device
(
#
[
from
]
DeviceError
)
#
[
error
(
"
Pipeline
layout
is
invalid
"
)
]
InvalidLayout
#
[
error
(
"
Unable
to
derive
an
implicit
layout
"
)
]
Implicit
(
#
[
from
]
ImplicitLayoutError
)
#
[
error
(
"
Error
matching
shader
requirements
against
the
pipeline
"
)
]
Stage
(
#
[
from
]
validation
:
:
StageError
)
#
[
error
(
"
Internal
error
:
{
0
}
"
)
]
Internal
(
String
)
#
[
error
(
transparent
)
]
MissingDownlevelFlags
(
#
[
from
]
MissingDownlevelFlags
)
}
#
[
derive
(
Debug
)
]
pub
struct
ComputePipeline
<
A
:
HalApi
>
{
pub
(
crate
)
raw
:
Option
<
A
:
:
ComputePipeline
>
pub
(
crate
)
layout
:
Arc
<
PipelineLayout
<
A
>
>
pub
(
crate
)
device
:
Arc
<
Device
<
A
>
>
pub
(
crate
)
_shader_module
:
Arc
<
ShaderModule
<
A
>
>
pub
(
crate
)
late_sized_buffer_groups
:
ArrayVec
<
LateSizedBufferGroup
{
hal
:
:
MAX_BIND_GROUPS
}
>
pub
(
crate
)
info
:
ResourceInfo
<
ComputePipeline
<
A
>
>
}
impl
<
A
:
HalApi
>
Drop
for
ComputePipeline
<
A
>
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
raw
)
=
self
.
raw
.
take
(
)
{
resource_log
!
(
"
Destroy
raw
{
}
"
self
.
error_ident
(
)
)
;
unsafe
{
use
hal
:
:
Device
;
self
.
device
.
raw
(
)
.
destroy_compute_pipeline
(
raw
)
;
}
}
}
}
impl
<
A
:
HalApi
>
Resource
for
ComputePipeline
<
A
>
{
const
TYPE
:
ResourceType
=
"
ComputePipeline
"
;
type
Marker
=
crate
:
:
id
:
:
markers
:
:
ComputePipeline
;
fn
as_info
(
&
self
)
-
>
&
ResourceInfo
<
Self
>
{
&
self
.
info
}
fn
as_info_mut
(
&
mut
self
)
-
>
&
mut
ResourceInfo
<
Self
>
{
&
mut
self
.
info
}
}
impl
<
A
:
HalApi
>
ParentDevice
<
A
>
for
ComputePipeline
<
A
>
{
fn
device
(
&
self
)
-
>
&
Arc
<
Device
<
A
>
>
{
&
self
.
device
}
}
impl
<
A
:
HalApi
>
ComputePipeline
<
A
>
{
pub
(
crate
)
fn
raw
(
&
self
)
-
>
&
A
:
:
ComputePipeline
{
self
.
raw
.
as_ref
(
)
.
unwrap
(
)
}
}
#
[
derive
(
Clone
Debug
Error
)
]
#
[
non_exhaustive
]
pub
enum
CreatePipelineCacheError
{
#
[
error
(
transparent
)
]
Device
(
#
[
from
]
DeviceError
)
#
[
error
(
"
Pipeline
cache
validation
failed
"
)
]
Validation
(
#
[
from
]
PipelineCacheValidationError
)
#
[
error
(
transparent
)
]
MissingFeatures
(
#
[
from
]
MissingFeatures
)
#
[
error
(
"
Internal
error
:
{
0
}
"
)
]
Internal
(
String
)
}
impl
From
<
hal
:
:
PipelineCacheError
>
for
CreatePipelineCacheError
{
fn
from
(
value
:
hal
:
:
PipelineCacheError
)
-
>
Self
{
match
value
{
hal
:
:
PipelineCacheError
:
:
Device
(
device
)
=
>
{
CreatePipelineCacheError
:
:
Device
(
device
.
into
(
)
)
}
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
PipelineCache
<
A
:
HalApi
>
{
pub
(
crate
)
raw
:
Option
<
A
:
:
PipelineCache
>
pub
(
crate
)
device
:
Arc
<
Device
<
A
>
>
pub
(
crate
)
info
:
ResourceInfo
<
PipelineCache
<
A
>
>
}
impl
<
A
:
HalApi
>
Drop
for
PipelineCache
<
A
>
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
raw
)
=
self
.
raw
.
take
(
)
{
resource_log
!
(
"
Destroy
raw
{
}
"
self
.
error_ident
(
)
)
;
unsafe
{
use
hal
:
:
Device
;
self
.
device
.
raw
(
)
.
destroy_pipeline_cache
(
raw
)
;
}
}
}
}
impl
<
A
:
HalApi
>
Resource
for
PipelineCache
<
A
>
{
const
TYPE
:
ResourceType
=
"
PipelineCache
"
;
type
Marker
=
crate
:
:
id
:
:
markers
:
:
PipelineCache
;
fn
as_info
(
&
self
)
-
>
&
ResourceInfo
<
Self
>
{
&
self
.
info
}
fn
as_info_mut
(
&
mut
self
)
-
>
&
mut
ResourceInfo
<
Self
>
{
&
mut
self
.
info
}
}
impl
<
A
:
HalApi
>
ParentDevice
<
A
>
for
PipelineCache
<
A
>
{
fn
device
(
&
self
)
-
>
&
Arc
<
Device
<
A
>
>
{
&
self
.
device
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
VertexBufferLayout
<
'
a
>
{
pub
array_stride
:
wgt
:
:
BufferAddress
pub
step_mode
:
wgt
:
:
VertexStepMode
pub
attributes
:
Cow
<
'
a
[
wgt
:
:
VertexAttribute
]
>
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
VertexState
<
'
a
>
{
pub
stage
:
ProgrammableStageDescriptor
<
'
a
>
pub
buffers
:
Cow
<
'
a
[
VertexBufferLayout
<
'
a
>
]
>
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
FragmentState
<
'
a
>
{
pub
stage
:
ProgrammableStageDescriptor
<
'
a
>
pub
targets
:
Cow
<
'
a
[
Option
<
wgt
:
:
ColorTargetState
>
]
>
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
RenderPipelineDescriptor
<
'
a
>
{
pub
label
:
Label
<
'
a
>
pub
layout
:
Option
<
PipelineLayoutId
>
pub
vertex
:
VertexState
<
'
a
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
primitive
:
wgt
:
:
PrimitiveState
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
depth_stencil
:
Option
<
wgt
:
:
DepthStencilState
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
multisample
:
wgt
:
:
MultisampleState
pub
fragment
:
Option
<
FragmentState
<
'
a
>
>
pub
multiview
:
Option
<
NonZeroU32
>
pub
cache
:
Option
<
PipelineCacheId
>
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
PipelineCacheDescriptor
<
'
a
>
{
pub
label
:
Label
<
'
a
>
pub
data
:
Option
<
Cow
<
'
a
[
u8
]
>
>
pub
fallback
:
bool
}
#
[
derive
(
Clone
Debug
Error
)
]
#
[
non_exhaustive
]
pub
enum
ColorStateError
{
#
[
error
(
"
Format
{
0
:
?
}
is
not
renderable
"
)
]
FormatNotRenderable
(
wgt
:
:
TextureFormat
)
#
[
error
(
"
Format
{
0
:
?
}
is
not
blendable
"
)
]
FormatNotBlendable
(
wgt
:
:
TextureFormat
)
#
[
error
(
"
Format
{
0
:
?
}
does
not
have
a
color
aspect
"
)
]
FormatNotColor
(
wgt
:
:
TextureFormat
)
#
[
error
(
"
Sample
count
{
0
}
is
not
supported
by
format
{
1
:
?
}
on
this
device
.
The
WebGPU
spec
guarantees
{
2
:
?
}
samples
are
supported
by
this
format
.
With
the
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
feature
your
device
supports
{
3
:
?
}
.
"
)
]
InvalidSampleCount
(
u32
wgt
:
:
TextureFormat
Vec
<
u32
>
Vec
<
u32
>
)
#
[
error
(
"
Output
format
{
pipeline
}
is
incompatible
with
the
shader
{
shader
}
"
)
]
IncompatibleFormat
{
pipeline
:
validation
:
:
NumericType
shader
:
validation
:
:
NumericType
}
#
[
error
(
"
Blend
factors
for
{
0
:
?
}
must
be
One
"
)
]
InvalidMinMaxBlendFactors
(
wgt
:
:
BlendComponent
)
#
[
error
(
"
Invalid
write
mask
{
0
:
?
}
"
)
]
InvalidWriteMask
(
wgt
:
:
ColorWrites
)
}
#
[
derive
(
Clone
Debug
Error
)
]
#
[
non_exhaustive
]
pub
enum
DepthStencilStateError
{
#
[
error
(
"
Format
{
0
:
?
}
is
not
renderable
"
)
]
FormatNotRenderable
(
wgt
:
:
TextureFormat
)
#
[
error
(
"
Format
{
0
:
?
}
does
not
have
a
depth
aspect
but
depth
test
/
write
is
enabled
"
)
]
FormatNotDepth
(
wgt
:
:
TextureFormat
)
#
[
error
(
"
Format
{
0
:
?
}
does
not
have
a
stencil
aspect
but
stencil
test
/
write
is
enabled
"
)
]
FormatNotStencil
(
wgt
:
:
TextureFormat
)
#
[
error
(
"
Sample
count
{
0
}
is
not
supported
by
format
{
1
:
?
}
on
this
device
.
The
WebGPU
spec
guarantees
{
2
:
?
}
samples
are
supported
by
this
format
.
With
the
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
feature
your
device
supports
{
3
:
?
}
.
"
)
]
InvalidSampleCount
(
u32
wgt
:
:
TextureFormat
Vec
<
u32
>
Vec
<
u32
>
)
}
#
[
derive
(
Clone
Debug
Error
)
]
#
[
non_exhaustive
]
pub
enum
CreateRenderPipelineError
{
#
[
error
(
transparent
)
]
ColorAttachment
(
#
[
from
]
ColorAttachmentError
)
#
[
error
(
transparent
)
]
Device
(
#
[
from
]
DeviceError
)
#
[
error
(
"
Pipeline
layout
is
invalid
"
)
]
InvalidLayout
#
[
error
(
"
Unable
to
derive
an
implicit
layout
"
)
]
Implicit
(
#
[
from
]
ImplicitLayoutError
)
#
[
error
(
"
Color
state
[
{
0
}
]
is
invalid
"
)
]
ColorState
(
u8
#
[
source
]
ColorStateError
)
#
[
error
(
"
Depth
/
stencil
state
is
invalid
"
)
]
DepthStencilState
(
#
[
from
]
DepthStencilStateError
)
#
[
error
(
"
Invalid
sample
count
{
0
}
"
)
]
InvalidSampleCount
(
u32
)
#
[
error
(
"
The
number
of
vertex
buffers
{
given
}
exceeds
the
limit
{
limit
}
"
)
]
TooManyVertexBuffers
{
given
:
u32
limit
:
u32
}
#
[
error
(
"
The
total
number
of
vertex
attributes
{
given
}
exceeds
the
limit
{
limit
}
"
)
]
TooManyVertexAttributes
{
given
:
u32
limit
:
u32
}
#
[
error
(
"
Vertex
buffer
{
index
}
stride
{
given
}
exceeds
the
limit
{
limit
}
"
)
]
VertexStrideTooLarge
{
index
:
u32
given
:
u32
limit
:
u32
}
#
[
error
(
"
Vertex
buffer
{
index
}
stride
{
stride
}
does
not
respect
VERTEX_STRIDE_ALIGNMENT
"
)
]
UnalignedVertexStride
{
index
:
u32
stride
:
wgt
:
:
BufferAddress
}
#
[
error
(
"
Vertex
attribute
at
location
{
location
}
has
invalid
offset
{
offset
}
"
)
]
InvalidVertexAttributeOffset
{
location
:
wgt
:
:
ShaderLocation
offset
:
wgt
:
:
BufferAddress
}
#
[
error
(
"
Two
or
more
vertex
attributes
were
assigned
to
the
same
location
in
the
shader
:
{
0
}
"
)
]
ShaderLocationClash
(
u32
)
#
[
error
(
"
Strip
index
format
was
not
set
to
None
but
to
{
strip_index_format
:
?
}
while
using
the
non
-
strip
topology
{
topology
:
?
}
"
)
]
StripIndexFormatForNonStripTopology
{
strip_index_format
:
Option
<
wgt
:
:
IndexFormat
>
topology
:
wgt
:
:
PrimitiveTopology
}
#
[
error
(
"
Conservative
Rasterization
is
only
supported
for
wgt
:
:
PolygonMode
:
:
Fill
"
)
]
ConservativeRasterizationNonFillPolygonMode
#
[
error
(
transparent
)
]
MissingFeatures
(
#
[
from
]
MissingFeatures
)
#
[
error
(
transparent
)
]
MissingDownlevelFlags
(
#
[
from
]
MissingDownlevelFlags
)
#
[
error
(
"
Error
matching
{
stage
:
?
}
shader
requirements
against
the
pipeline
"
)
]
Stage
{
stage
:
wgt
:
:
ShaderStages
#
[
source
]
error
:
validation
:
:
StageError
}
#
[
error
(
"
Internal
error
in
{
stage
:
?
}
shader
:
{
error
}
"
)
]
Internal
{
stage
:
wgt
:
:
ShaderStages
error
:
String
}
#
[
error
(
"
In
the
provided
shader
the
type
given
for
group
{
group
}
binding
{
binding
}
has
a
size
of
{
size
}
.
As
the
device
does
not
support
DownlevelFlags
:
:
BUFFER_BINDINGS_NOT_16_BYTE_ALIGNED
the
type
must
have
a
size
that
is
a
multiple
of
16
bytes
.
"
)
]
UnalignedShader
{
group
:
u32
binding
:
u32
size
:
u64
}
#
[
error
(
"
Using
the
blend
factor
{
factor
:
?
}
for
render
target
{
target
}
is
not
possible
.
Only
the
first
render
target
may
be
used
when
dual
-
source
blending
.
"
)
]
BlendFactorOnUnsupportedTarget
{
factor
:
wgt
:
:
BlendFactor
target
:
u32
}
#
[
error
(
"
Pipeline
expects
the
shader
entry
point
to
make
use
of
dual
-
source
blending
.
"
)
]
PipelineExpectsShaderToUseDualSourceBlending
#
[
error
(
"
Shader
entry
point
expects
the
pipeline
to
make
use
of
dual
-
source
blending
.
"
)
]
ShaderExpectsPipelineToUseDualSourceBlending
#
[
error
(
"
{
}
"
concat
!
(
"
At
least
one
color
attachment
or
depth
-
stencil
attachment
was
expected
"
"
but
no
render
target
for
the
pipeline
was
specified
.
"
)
)
]
NoTargetSpecified
}
bitflags
:
:
bitflags
!
{
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
PipelineFlags
:
u32
{
const
BLEND_CONSTANT
=
1
<
<
0
;
const
STENCIL_REFERENCE
=
1
<
<
1
;
const
WRITES_DEPTH
=
1
<
<
2
;
const
WRITES_STENCIL
=
1
<
<
3
;
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
VertexStep
{
pub
stride
:
wgt
:
:
BufferAddress
pub
last_stride
:
wgt
:
:
BufferAddress
pub
mode
:
wgt
:
:
VertexStepMode
}
impl
Default
for
VertexStep
{
fn
default
(
)
-
>
Self
{
Self
{
stride
:
0
last_stride
:
0
mode
:
wgt
:
:
VertexStepMode
:
:
Vertex
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
RenderPipeline
<
A
:
HalApi
>
{
pub
(
crate
)
raw
:
Option
<
A
:
:
RenderPipeline
>
pub
(
crate
)
device
:
Arc
<
Device
<
A
>
>
pub
(
crate
)
layout
:
Arc
<
PipelineLayout
<
A
>
>
pub
(
crate
)
_shader_modules
:
ArrayVec
<
Arc
<
ShaderModule
<
A
>
>
{
hal
:
:
MAX_CONCURRENT_SHADER_STAGES
}
>
pub
(
crate
)
pass_context
:
RenderPassContext
pub
(
crate
)
flags
:
PipelineFlags
pub
(
crate
)
strip_index_format
:
Option
<
wgt
:
:
IndexFormat
>
pub
(
crate
)
vertex_steps
:
Vec
<
VertexStep
>
pub
(
crate
)
late_sized_buffer_groups
:
ArrayVec
<
LateSizedBufferGroup
{
hal
:
:
MAX_BIND_GROUPS
}
>
pub
(
crate
)
info
:
ResourceInfo
<
RenderPipeline
<
A
>
>
}
impl
<
A
:
HalApi
>
Drop
for
RenderPipeline
<
A
>
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
raw
)
=
self
.
raw
.
take
(
)
{
resource_log
!
(
"
Destroy
raw
{
}
"
self
.
error_ident
(
)
)
;
unsafe
{
use
hal
:
:
Device
;
self
.
device
.
raw
(
)
.
destroy_render_pipeline
(
raw
)
;
}
}
}
}
impl
<
A
:
HalApi
>
Resource
for
RenderPipeline
<
A
>
{
const
TYPE
:
ResourceType
=
"
RenderPipeline
"
;
type
Marker
=
crate
:
:
id
:
:
markers
:
:
RenderPipeline
;
fn
as_info
(
&
self
)
-
>
&
ResourceInfo
<
Self
>
{
&
self
.
info
}
fn
as_info_mut
(
&
mut
self
)
-
>
&
mut
ResourceInfo
<
Self
>
{
&
mut
self
.
info
}
}
impl
<
A
:
HalApi
>
ParentDevice
<
A
>
for
RenderPipeline
<
A
>
{
fn
device
(
&
self
)
-
>
&
Arc
<
Device
<
A
>
>
{
&
self
.
device
}
}
impl
<
A
:
HalApi
>
RenderPipeline
<
A
>
{
pub
(
crate
)
fn
raw
(
&
self
)
-
>
&
A
:
:
RenderPipeline
{
self
.
raw
.
as_ref
(
)
.
unwrap
(
)
}
}
