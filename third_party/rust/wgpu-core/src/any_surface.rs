use
wgt
:
:
Backend
;
use
crate
:
:
hal_api
:
:
HalApi
;
use
crate
:
:
instance
:
:
HalSurface
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
Arc
;
pub
struct
AnySurface
(
Arc
<
dyn
Any
+
'
static
>
)
;
impl
AnySurface
{
pub
fn
new
<
A
:
HalApi
>
(
surface
:
HalSurface
<
A
>
)
-
>
AnySurface
{
AnySurface
(
Arc
:
:
new
(
surface
)
)
}
pub
fn
backend
(
&
self
)
-
>
Backend
{
#
[
cfg
(
vulkan
)
]
if
self
.
downcast_ref
:
:
<
hal
:
:
api
:
:
Vulkan
>
(
)
.
is_some
(
)
{
return
Backend
:
:
Vulkan
;
}
#
[
cfg
(
metal
)
]
if
self
.
downcast_ref
:
:
<
hal
:
:
api
:
:
Metal
>
(
)
.
is_some
(
)
{
return
Backend
:
:
Metal
;
}
#
[
cfg
(
dx12
)
]
if
self
.
downcast_ref
:
:
<
hal
:
:
api
:
:
Dx12
>
(
)
.
is_some
(
)
{
return
Backend
:
:
Dx12
;
}
#
[
cfg
(
gles
)
]
if
self
.
downcast_ref
:
:
<
hal
:
:
api
:
:
Gles
>
(
)
.
is_some
(
)
{
return
Backend
:
:
Gl
;
}
Backend
:
:
Empty
}
pub
fn
downcast_ref
<
A
:
HalApi
>
(
&
self
)
-
>
Option
<
&
HalSurface
<
A
>
>
{
self
.
0
.
downcast_ref
:
:
<
HalSurface
<
A
>
>
(
)
}
pub
fn
take
<
A
:
HalApi
>
(
self
)
-
>
Option
<
Arc
<
HalSurface
<
A
>
>
>
{
if
(
self
.
0
)
.
is
:
:
<
HalSurface
<
A
>
>
(
)
{
let
raw_erased
:
*
const
(
dyn
Any
+
'
static
)
=
Arc
:
:
into_raw
(
self
.
0
)
;
let
raw_typed
:
*
const
HalSurface
<
A
>
=
raw_erased
.
cast
:
:
<
HalSurface
<
A
>
>
(
)
;
let
arc_typed
:
Arc
<
HalSurface
<
A
>
>
=
unsafe
{
Arc
:
:
from_raw
(
raw_typed
)
}
;
Some
(
arc_typed
)
}
else
{
None
}
}
}
impl
fmt
:
:
Debug
for
AnySurface
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
AnySurface
"
)
}
}
#
[
cfg
(
send_sync
)
]
unsafe
impl
Send
for
AnySurface
{
}
#
[
cfg
(
send_sync
)
]
unsafe
impl
Sync
for
AnySurface
{
}
