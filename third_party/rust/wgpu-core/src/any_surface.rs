use
wgt
:
:
Backend
;
use
crate
:
:
hal_api
:
:
HalApi
;
use
std
:
:
fmt
;
use
std
:
:
mem
:
:
ManuallyDrop
;
use
std
:
:
ptr
:
:
NonNull
;
struct
AnySurfaceVtable
{
backend
:
Backend
drop
:
unsafe
fn
(
*
mut
(
)
)
}
pub
struct
AnySurface
{
data
:
NonNull
<
(
)
>
vtable
:
&
'
static
AnySurfaceVtable
}
impl
AnySurface
{
pub
fn
new
<
A
:
HalApi
>
(
surface
:
A
:
:
Surface
)
-
>
AnySurface
{
unsafe
fn
drop_glue
<
A
:
HalApi
>
(
ptr
:
*
mut
(
)
)
{
unsafe
{
_
=
Box
:
:
from_raw
(
ptr
.
cast
:
:
<
A
:
:
Surface
>
(
)
)
;
}
}
let
data
=
NonNull
:
:
from
(
Box
:
:
leak
(
Box
:
:
new
(
surface
)
)
)
;
AnySurface
{
data
:
data
.
cast
(
)
vtable
:
&
AnySurfaceVtable
{
backend
:
A
:
:
VARIANT
drop
:
drop_glue
:
:
<
A
>
}
}
}
pub
fn
backend
(
&
self
)
-
>
Backend
{
self
.
vtable
.
backend
}
pub
fn
downcast_ref
<
A
:
HalApi
>
(
&
self
)
-
>
Option
<
&
A
:
:
Surface
>
{
if
A
:
:
VARIANT
!
=
self
.
vtable
.
backend
{
return
None
;
}
Some
(
unsafe
{
&
*
self
.
data
.
as_ptr
(
)
.
cast
:
:
<
A
:
:
Surface
>
(
)
}
)
}
pub
fn
take
<
A
:
HalApi
>
(
self
)
-
>
Option
<
A
:
:
Surface
>
{
if
A
:
:
VARIANT
!
=
self
.
vtable
.
backend
{
return
None
;
}
let
this
=
ManuallyDrop
:
:
new
(
self
)
;
Some
(
unsafe
{
*
Box
:
:
from_raw
(
this
.
data
.
as_ptr
(
)
.
cast
:
:
<
A
:
:
Surface
>
(
)
)
}
)
}
}
impl
Drop
for
AnySurface
{
fn
drop
(
&
mut
self
)
{
unsafe
{
(
self
.
vtable
.
drop
)
(
self
.
data
.
as_ptr
(
)
)
}
}
}
impl
fmt
:
:
Debug
for
AnySurface
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
AnySurface
<
{
}
>
"
self
.
vtable
.
backend
)
}
}
#
[
cfg
(
send_sync
)
]
unsafe
impl
Send
for
AnySurface
{
}
#
[
cfg
(
send_sync
)
]
unsafe
impl
Sync
for
AnySurface
{
}
