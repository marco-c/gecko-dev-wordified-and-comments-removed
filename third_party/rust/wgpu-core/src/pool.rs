use
alloc
:
:
sync
:
:
{
Arc
Weak
}
;
use
core
:
:
hash
:
:
Hash
;
use
hashbrown
:
:
{
hash_map
:
:
Entry
HashMap
}
;
use
once_cell
:
:
sync
:
:
OnceCell
;
use
crate
:
:
lock
:
:
{
rank
Mutex
}
;
use
crate
:
:
FastHashMap
;
type
SlotInner
<
V
>
=
Weak
<
V
>
;
type
ResourcePoolSlot
<
V
>
=
Arc
<
OnceCell
<
SlotInner
<
V
>
>
>
;
pub
struct
ResourcePool
<
K
V
>
{
inner
:
Mutex
<
FastHashMap
<
K
ResourcePoolSlot
<
V
>
>
>
}
impl
<
K
:
Clone
+
Eq
+
Hash
V
>
ResourcePool
<
K
V
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
inner
:
Mutex
:
:
new
(
rank
:
:
RESOURCE_POOL_INNER
HashMap
:
:
default
(
)
)
}
}
pub
fn
get_or_init
<
F
E
>
(
&
self
key
:
K
constructor
:
F
)
-
>
Result
<
Arc
<
V
>
E
>
where
F
:
FnOnce
(
K
)
-
>
Result
<
Arc
<
V
>
E
>
{
let
mut
key
=
Some
(
key
)
;
let
mut
constructor
=
Some
(
constructor
)
;
'
race
:
loop
{
let
mut
map_guard
=
self
.
inner
.
lock
(
)
;
let
entry
=
match
map_guard
.
entry
(
key
.
clone
(
)
.
unwrap
(
)
)
{
Entry
:
:
Occupied
(
entry
)
=
>
Arc
:
:
clone
(
entry
.
get
(
)
)
Entry
:
:
Vacant
(
entry
)
=
>
Arc
:
:
clone
(
entry
.
insert
(
Arc
:
:
new
(
OnceCell
:
:
new
(
)
)
)
)
}
;
drop
(
map_guard
)
;
let
mut
strong
=
None
;
let
weak
=
entry
.
get_or_try_init
(
|
|
{
let
strong_inner
=
constructor
.
take
(
)
.
unwrap
(
)
(
key
.
take
(
)
.
unwrap
(
)
)
?
;
let
weak
=
Arc
:
:
downgrade
(
&
strong_inner
)
;
strong
=
Some
(
strong_inner
)
;
Ok
(
weak
)
}
)
?
;
if
let
Some
(
strong
)
=
strong
{
return
Ok
(
strong
)
;
}
if
let
Some
(
strong
)
=
weak
.
upgrade
(
)
{
return
Ok
(
strong
)
;
}
continue
'
race
;
}
}
pub
fn
remove
(
&
self
key
:
&
K
)
{
let
mut
map_guard
=
self
.
inner
.
lock
(
)
;
map_guard
.
remove
(
key
)
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
core
:
:
{
sync
:
:
atomic
:
:
{
AtomicU32
Ordering
}
time
:
:
Duration
}
;
use
std
:
:
{
eprintln
sync
:
:
Barrier
thread
}
;
use
super
:
:
*
;
#
[
test
]
fn
deduplication
(
)
{
let
pool
=
ResourcePool
:
:
<
u32
u32
>
:
:
new
(
)
;
let
mut
counter
=
0_u32
;
let
arc1
=
pool
.
get_or_init
:
:
<
_
(
)
>
(
0
|
key
|
{
counter
+
=
1
;
Ok
(
Arc
:
:
new
(
key
)
)
}
)
.
unwrap
(
)
;
assert_eq
!
(
*
arc1
0
)
;
assert_eq
!
(
counter
1
)
;
let
arc2
=
pool
.
get_or_init
:
:
<
_
(
)
>
(
0
|
key
|
{
counter
+
=
1
;
Ok
(
Arc
:
:
new
(
key
)
)
}
)
.
unwrap
(
)
;
assert
!
(
Arc
:
:
ptr_eq
(
&
arc1
&
arc2
)
)
;
assert_eq
!
(
*
arc2
0
)
;
assert_eq
!
(
counter
1
)
;
drop
(
arc1
)
;
drop
(
arc2
)
;
pool
.
remove
(
&
0
)
;
let
arc3
=
pool
.
get_or_init
:
:
<
_
(
)
>
(
0
|
key
|
{
counter
+
=
1
;
Ok
(
Arc
:
:
new
(
key
)
)
}
)
.
unwrap
(
)
;
assert_eq
!
(
*
arc3
0
)
;
assert_eq
!
(
counter
2
)
;
}
#
[
test
]
fn
concurrent_creation_2_threads
(
)
{
struct
Resources
{
pool
:
ResourcePool
<
u32
u32
>
counter
:
AtomicU32
barrier
:
Barrier
}
let
resources
=
Arc
:
:
new
(
Resources
{
pool
:
ResourcePool
:
:
<
u32
u32
>
:
:
new
(
)
counter
:
AtomicU32
:
:
new
(
0
)
barrier
:
Barrier
:
:
new
(
2
)
}
)
;
fn
thread_inner
(
idx
:
u8
resources
:
&
Resources
)
-
>
Arc
<
u32
>
{
eprintln
!
(
"
{
idx
}
:
prewait
"
)
;
resources
.
barrier
.
wait
(
)
;
eprintln
!
(
"
{
idx
}
:
postwait
"
)
;
let
ret
=
resources
.
pool
.
get_or_init
:
:
<
_
(
)
>
(
0
|
key
|
{
eprintln
!
(
"
{
idx
}
:
init
"
)
;
thread
:
:
sleep
(
Duration
:
:
from_millis
(
250
)
)
;
resources
.
counter
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
Ok
(
Arc
:
:
new
(
key
)
)
}
)
.
unwrap
(
)
;
eprintln
!
(
"
{
idx
}
:
postget
"
)
;
ret
}
let
thread1
=
thread
:
:
spawn
(
{
let
resource_clone
=
Arc
:
:
clone
(
&
resources
)
;
move
|
|
thread_inner
(
1
&
resource_clone
)
}
)
;
let
arc0
=
thread_inner
(
0
&
resources
)
;
assert_eq
!
(
resources
.
counter
.
load
(
Ordering
:
:
Acquire
)
1
)
;
let
arc1
=
thread1
.
join
(
)
.
unwrap
(
)
;
assert
!
(
Arc
:
:
ptr_eq
(
&
arc0
&
arc1
)
)
;
}
#
[
test
]
fn
create_while_drop_2_threads
(
)
{
struct
Resources
{
pool
:
ResourcePool
<
u32
u32
>
barrier
:
Barrier
}
let
resources
=
Arc
:
:
new
(
Resources
{
pool
:
ResourcePool
:
:
<
u32
u32
>
:
:
new
(
)
barrier
:
Barrier
:
:
new
(
2
)
}
)
;
let
existing_entry
=
resources
.
pool
.
get_or_init
:
:
<
_
(
)
>
(
0
|
key
|
Ok
(
Arc
:
:
new
(
key
)
)
)
.
unwrap
(
)
;
drop
(
existing_entry
)
;
fn
thread0_inner
(
resources
:
&
Resources
)
{
eprintln
!
(
"
0
:
prewait
"
)
;
resources
.
barrier
.
wait
(
)
;
eprintln
!
(
"
0
:
postwait
"
)
;
resources
.
pool
.
get_or_init
:
:
<
_
(
)
>
(
0
|
key
|
Ok
(
Arc
:
:
new
(
key
)
)
)
.
unwrap
(
)
;
eprintln
!
(
"
0
:
postget
"
)
;
}
fn
thread1_inner
(
resources
:
&
Resources
)
{
eprintln
!
(
"
1
:
prewait
"
)
;
resources
.
barrier
.
wait
(
)
;
eprintln
!
(
"
1
:
postwait
"
)
;
thread
:
:
sleep
(
Duration
:
:
from_millis
(
250
)
)
;
eprintln
!
(
"
1
:
postsleep
"
)
;
resources
.
pool
.
remove
(
&
0
)
;
eprintln
!
(
"
1
:
removal
"
)
;
}
let
thread1
=
thread
:
:
spawn
(
{
let
resource_clone
=
Arc
:
:
clone
(
&
resources
)
;
move
|
|
thread1_inner
(
&
resource_clone
)
}
)
;
thread0_inner
(
&
resources
)
;
thread1
.
join
(
)
.
unwrap
(
)
;
}
}
