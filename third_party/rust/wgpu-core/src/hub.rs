use
crate
:
:
{
binding_model
:
:
{
BindGroup
BindGroupLayout
PipelineLayout
}
command
:
:
{
CommandBuffer
RenderBundle
}
device
:
:
{
queue
:
:
Queue
Device
}
instance
:
:
{
Adapter
Surface
}
pipeline
:
:
{
ComputePipeline
PipelineCache
RenderPipeline
ShaderModule
}
registry
:
:
{
Registry
RegistryReport
}
resource
:
:
{
Buffer
Fallible
QuerySet
Sampler
StagingBuffer
Texture
TextureView
}
storage
:
:
{
Element
Storage
}
}
;
use
std
:
:
{
fmt
:
:
Debug
sync
:
:
Arc
}
;
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
struct
HubReport
{
pub
adapters
:
RegistryReport
pub
devices
:
RegistryReport
pub
queues
:
RegistryReport
pub
pipeline_layouts
:
RegistryReport
pub
shader_modules
:
RegistryReport
pub
bind_group_layouts
:
RegistryReport
pub
bind_groups
:
RegistryReport
pub
command_buffers
:
RegistryReport
pub
render_bundles
:
RegistryReport
pub
render_pipelines
:
RegistryReport
pub
compute_pipelines
:
RegistryReport
pub
pipeline_caches
:
RegistryReport
pub
query_sets
:
RegistryReport
pub
buffers
:
RegistryReport
pub
textures
:
RegistryReport
pub
texture_views
:
RegistryReport
pub
samplers
:
RegistryReport
}
impl
HubReport
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
adapters
.
is_empty
(
)
}
}
#
[
allow
(
rustdoc
:
:
private_intra_doc_links
)
]
pub
struct
Hub
{
pub
(
crate
)
adapters
:
Registry
<
Arc
<
Adapter
>
>
pub
(
crate
)
devices
:
Registry
<
Arc
<
Device
>
>
pub
(
crate
)
queues
:
Registry
<
Arc
<
Queue
>
>
pub
(
crate
)
pipeline_layouts
:
Registry
<
Fallible
<
PipelineLayout
>
>
pub
(
crate
)
shader_modules
:
Registry
<
Fallible
<
ShaderModule
>
>
pub
(
crate
)
bind_group_layouts
:
Registry
<
Fallible
<
BindGroupLayout
>
>
pub
(
crate
)
bind_groups
:
Registry
<
Fallible
<
BindGroup
>
>
pub
(
crate
)
command_buffers
:
Registry
<
Arc
<
CommandBuffer
>
>
pub
(
crate
)
render_bundles
:
Registry
<
Fallible
<
RenderBundle
>
>
pub
(
crate
)
render_pipelines
:
Registry
<
Fallible
<
RenderPipeline
>
>
pub
(
crate
)
compute_pipelines
:
Registry
<
Fallible
<
ComputePipeline
>
>
pub
(
crate
)
pipeline_caches
:
Registry
<
Fallible
<
PipelineCache
>
>
pub
(
crate
)
query_sets
:
Registry
<
Fallible
<
QuerySet
>
>
pub
(
crate
)
buffers
:
Registry
<
Fallible
<
Buffer
>
>
pub
(
crate
)
staging_buffers
:
Registry
<
StagingBuffer
>
pub
(
crate
)
textures
:
Registry
<
Fallible
<
Texture
>
>
pub
(
crate
)
texture_views
:
Registry
<
Fallible
<
TextureView
>
>
pub
(
crate
)
samplers
:
Registry
<
Fallible
<
Sampler
>
>
}
impl
Hub
{
pub
(
crate
)
fn
new
(
)
-
>
Self
{
Self
{
adapters
:
Registry
:
:
new
(
)
devices
:
Registry
:
:
new
(
)
queues
:
Registry
:
:
new
(
)
pipeline_layouts
:
Registry
:
:
new
(
)
shader_modules
:
Registry
:
:
new
(
)
bind_group_layouts
:
Registry
:
:
new
(
)
bind_groups
:
Registry
:
:
new
(
)
command_buffers
:
Registry
:
:
new
(
)
render_bundles
:
Registry
:
:
new
(
)
render_pipelines
:
Registry
:
:
new
(
)
compute_pipelines
:
Registry
:
:
new
(
)
pipeline_caches
:
Registry
:
:
new
(
)
query_sets
:
Registry
:
:
new
(
)
buffers
:
Registry
:
:
new
(
)
staging_buffers
:
Registry
:
:
new
(
)
textures
:
Registry
:
:
new
(
)
texture_views
:
Registry
:
:
new
(
)
samplers
:
Registry
:
:
new
(
)
}
}
pub
(
crate
)
fn
clear
(
&
self
surface_guard
:
&
Storage
<
Arc
<
Surface
>
>
)
{
let
mut
devices
=
self
.
devices
.
write
(
)
;
for
element
in
devices
.
map
.
iter
(
)
{
if
let
Element
:
:
Occupied
(
ref
device
_
)
=
*
element
{
device
.
prepare_to_die
(
)
;
}
}
self
.
command_buffers
.
write
(
)
.
map
.
clear
(
)
;
self
.
samplers
.
write
(
)
.
map
.
clear
(
)
;
self
.
texture_views
.
write
(
)
.
map
.
clear
(
)
;
self
.
textures
.
write
(
)
.
map
.
clear
(
)
;
self
.
buffers
.
write
(
)
.
map
.
clear
(
)
;
self
.
bind_groups
.
write
(
)
.
map
.
clear
(
)
;
self
.
shader_modules
.
write
(
)
.
map
.
clear
(
)
;
self
.
bind_group_layouts
.
write
(
)
.
map
.
clear
(
)
;
self
.
pipeline_layouts
.
write
(
)
.
map
.
clear
(
)
;
self
.
compute_pipelines
.
write
(
)
.
map
.
clear
(
)
;
self
.
render_pipelines
.
write
(
)
.
map
.
clear
(
)
;
self
.
pipeline_caches
.
write
(
)
.
map
.
clear
(
)
;
self
.
query_sets
.
write
(
)
.
map
.
clear
(
)
;
for
element
in
surface_guard
.
map
.
iter
(
)
{
if
let
Element
:
:
Occupied
(
ref
surface
_epoch
)
=
*
element
{
if
let
Some
(
ref
mut
present
)
=
surface
.
presentation
.
lock
(
)
.
take
(
)
{
let
suf
=
surface
.
raw
(
present
.
device
.
backend
(
)
)
;
unsafe
{
suf
.
unwrap
(
)
.
unconfigure
(
present
.
device
.
raw
(
)
)
;
}
}
}
}
self
.
queues
.
write
(
)
.
map
.
clear
(
)
;
devices
.
map
.
clear
(
)
;
drop
(
devices
)
;
self
.
adapters
.
write
(
)
.
map
.
clear
(
)
;
}
pub
fn
generate_report
(
&
self
)
-
>
HubReport
{
HubReport
{
adapters
:
self
.
adapters
.
generate_report
(
)
devices
:
self
.
devices
.
generate_report
(
)
queues
:
self
.
queues
.
generate_report
(
)
pipeline_layouts
:
self
.
pipeline_layouts
.
generate_report
(
)
shader_modules
:
self
.
shader_modules
.
generate_report
(
)
bind_group_layouts
:
self
.
bind_group_layouts
.
generate_report
(
)
bind_groups
:
self
.
bind_groups
.
generate_report
(
)
command_buffers
:
self
.
command_buffers
.
generate_report
(
)
render_bundles
:
self
.
render_bundles
.
generate_report
(
)
render_pipelines
:
self
.
render_pipelines
.
generate_report
(
)
compute_pipelines
:
self
.
compute_pipelines
.
generate_report
(
)
pipeline_caches
:
self
.
pipeline_caches
.
generate_report
(
)
query_sets
:
self
.
query_sets
.
generate_report
(
)
buffers
:
self
.
buffers
.
generate_report
(
)
textures
:
self
.
textures
.
generate_report
(
)
texture_views
:
self
.
texture_views
.
generate_report
(
)
samplers
:
self
.
samplers
.
generate_report
(
)
}
}
}
