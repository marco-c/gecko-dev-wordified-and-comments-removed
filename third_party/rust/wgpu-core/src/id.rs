use
crate
:
:
{
Epoch
Index
}
;
use
std
:
:
{
cmp
:
:
Ordering
fmt
:
:
{
self
Debug
}
hash
:
:
Hash
marker
:
:
PhantomData
num
:
:
NonZeroU64
}
;
use
wgt
:
:
WasmNotSendSync
;
const
_
:
(
)
=
{
if
std
:
:
mem
:
:
size_of
:
:
<
Index
>
(
)
!
=
4
{
panic
!
(
)
}
}
;
const
_
:
(
)
=
{
if
std
:
:
mem
:
:
size_of
:
:
<
Epoch
>
(
)
!
=
4
{
panic
!
(
)
}
}
;
const
_
:
(
)
=
{
if
std
:
:
mem
:
:
size_of
:
:
<
RawId
>
(
)
!
=
8
{
panic
!
(
)
}
}
;
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
feature
=
"
trace
"
)
derive
(
serde
:
:
Serialize
)
serde
(
into
=
"
SerialId
"
)
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
feature
=
"
replay
"
)
derive
(
serde
:
:
Deserialize
)
serde
(
from
=
"
SerialId
"
)
)
]
#
[
derive
(
Clone
Copy
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
RawId
(
NonZeroU64
)
;
impl
RawId
{
pub
fn
zip
(
index
:
Index
epoch
:
Epoch
)
-
>
RawId
{
let
v
=
(
index
as
u64
)
|
(
(
epoch
as
u64
)
<
<
32
)
;
Self
(
NonZeroU64
:
:
new
(
v
)
.
unwrap
(
)
)
}
pub
fn
unzip
(
self
)
-
>
(
Index
Epoch
)
{
(
self
.
0
.
get
(
)
as
Index
(
self
.
0
.
get
(
)
>
>
32
)
as
Epoch
)
}
}
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
feature
=
"
trace
"
)
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
feature
=
"
replay
"
)
derive
(
serde
:
:
Deserialize
)
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
transparent
)
)
]
pub
struct
Id
<
T
:
Marker
>
(
RawId
PhantomData
<
T
>
)
;
#
[
allow
(
dead_code
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
enum
SerialId
{
Id
(
Index
Epoch
)
}
impl
From
<
RawId
>
for
SerialId
{
fn
from
(
id
:
RawId
)
-
>
Self
{
let
(
index
epoch
)
=
id
.
unzip
(
)
;
Self
:
:
Id
(
index
epoch
)
}
}
impl
From
<
SerialId
>
for
RawId
{
fn
from
(
id
:
SerialId
)
-
>
Self
{
match
id
{
SerialId
:
:
Id
(
index
epoch
)
=
>
RawId
:
:
zip
(
index
epoch
)
}
}
}
impl
<
T
>
Id
<
T
>
where
T
:
Marker
{
pub
unsafe
fn
from_raw
(
raw
:
RawId
)
-
>
Self
{
Self
(
raw
PhantomData
)
}
pub
fn
into_raw
(
self
)
-
>
RawId
{
self
.
0
}
#
[
inline
]
pub
fn
zip
(
index
:
Index
epoch
:
Epoch
)
-
>
Self
{
Id
(
RawId
:
:
zip
(
index
epoch
)
PhantomData
)
}
#
[
inline
]
pub
fn
unzip
(
self
)
-
>
(
Index
Epoch
)
{
self
.
0
.
unzip
(
)
}
}
impl
<
T
>
Copy
for
Id
<
T
>
where
T
:
Marker
{
}
impl
<
T
>
Clone
for
Id
<
T
>
where
T
:
Marker
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
T
>
Debug
for
Id
<
T
>
where
T
:
Marker
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
(
index
epoch
)
=
self
.
unzip
(
)
;
write
!
(
formatter
"
Id
(
{
index
}
{
epoch
}
)
"
)
?
;
Ok
(
(
)
)
}
}
impl
<
T
>
Hash
for
Id
<
T
>
where
T
:
Marker
{
#
[
inline
]
fn
hash
<
H
:
std
:
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
0
.
hash
(
state
)
;
}
}
impl
<
T
>
PartialEq
for
Id
<
T
>
where
T
:
Marker
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
0
=
=
other
.
0
}
}
impl
<
T
>
Eq
for
Id
<
T
>
where
T
:
Marker
{
}
impl
<
T
>
PartialOrd
for
Id
<
T
>
where
T
:
Marker
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
<
T
>
Ord
for
Id
<
T
>
where
T
:
Marker
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
self
.
0
.
cmp
(
&
other
.
0
)
}
}
pub
trait
Marker
:
'
static
+
WasmNotSendSync
{
}
#
[
cfg
(
test
)
]
impl
Marker
for
(
)
{
}
macro_rules
!
ids
{
(
(
(
#
[
(
meta
:
meta
)
*
]
)
*
pub
type
name
:
ident
marker
:
ident
;
)
*
)
=
>
{
/
/
/
Marker
types
for
each
resource
.
pub
mod
markers
{
(
#
[
derive
(
Debug
)
]
pub
enum
marker
{
}
impl
super
:
:
Marker
for
marker
{
}
)
*
}
(
(
#
[
(
meta
)
*
]
)
*
pub
type
name
=
Id
<
self
:
:
markers
:
:
marker
>
;
)
*
}
}
ids
!
{
pub
type
AdapterId
Adapter
;
pub
type
SurfaceId
Surface
;
pub
type
DeviceId
Device
;
pub
type
QueueId
Queue
;
pub
type
BufferId
Buffer
;
pub
type
StagingBufferId
StagingBuffer
;
pub
type
TextureViewId
TextureView
;
pub
type
TextureId
Texture
;
pub
type
SamplerId
Sampler
;
pub
type
BindGroupLayoutId
BindGroupLayout
;
pub
type
PipelineLayoutId
PipelineLayout
;
pub
type
BindGroupId
BindGroup
;
pub
type
ShaderModuleId
ShaderModule
;
pub
type
RenderPipelineId
RenderPipeline
;
pub
type
ComputePipelineId
ComputePipeline
;
pub
type
PipelineCacheId
PipelineCache
;
pub
type
CommandEncoderId
CommandEncoder
;
pub
type
CommandBufferId
CommandBuffer
;
pub
type
RenderPassEncoderId
RenderPassEncoder
;
pub
type
ComputePassEncoderId
ComputePassEncoder
;
pub
type
RenderBundleEncoderId
RenderBundleEncoder
;
pub
type
RenderBundleId
RenderBundle
;
pub
type
QuerySetId
QuerySet
;
}
impl
CommandEncoderId
{
pub
fn
into_command_buffer_id
(
self
)
-
>
CommandBufferId
{
Id
(
self
.
0
PhantomData
)
}
}
impl
CommandBufferId
{
pub
fn
into_command_encoder_id
(
self
)
-
>
CommandEncoderId
{
Id
(
self
.
0
PhantomData
)
}
}
#
[
test
]
fn
test_id
(
)
{
let
indexes
=
[
0
Index
:
:
MAX
/
2
-
1
Index
:
:
MAX
/
2
+
1
Index
:
:
MAX
]
;
let
epochs
=
[
1
Epoch
:
:
MAX
/
2
-
1
Epoch
:
:
MAX
/
2
+
1
Epoch
:
:
MAX
]
;
for
&
i
in
&
indexes
{
for
&
e
in
&
epochs
{
let
id
=
Id
:
:
<
(
)
>
:
:
zip
(
i
e
)
;
let
(
index
epoch
)
=
id
.
unzip
(
)
;
assert_eq
!
(
index
i
)
;
assert_eq
!
(
epoch
e
)
;
}
}
}
