use
parking_lot
:
:
Mutex
;
use
wgt
:
:
Backend
;
use
crate
:
:
{
id
:
:
{
self
}
Epoch
FastHashMap
Index
}
;
use
std
:
:
{
fmt
:
:
Debug
marker
:
:
PhantomData
sync
:
:
Arc
}
;
#
[
derive
(
Debug
Default
)
]
pub
(
super
)
struct
IdentityValues
{
free
:
Vec
<
(
Index
Epoch
)
>
used
:
FastHashMap
<
Epoch
Vec
<
Index
>
>
count
:
usize
}
impl
IdentityValues
{
pub
fn
alloc
<
I
:
id
:
:
TypedId
>
(
&
mut
self
backend
:
Backend
)
-
>
I
{
self
.
count
+
=
1
;
match
self
.
free
.
pop
(
)
{
Some
(
(
index
epoch
)
)
=
>
I
:
:
zip
(
index
epoch
+
1
backend
)
None
=
>
{
let
epoch
=
1
;
let
used
=
self
.
used
.
entry
(
epoch
)
.
or_insert_with
(
Default
:
:
default
)
;
let
index
=
if
let
Some
(
i
)
=
used
.
iter
(
)
.
max_by_key
(
|
v
|
*
v
)
{
i
+
1
}
else
{
0
}
;
used
.
push
(
index
)
;
I
:
:
zip
(
index
epoch
backend
)
}
}
}
pub
fn
mark_as_used
<
I
:
id
:
:
TypedId
>
(
&
mut
self
id
:
I
)
-
>
I
{
self
.
count
+
=
1
;
let
(
index
epoch
_backend
)
=
id
.
unzip
(
)
;
let
used
=
self
.
used
.
entry
(
epoch
)
.
or_insert_with
(
Default
:
:
default
)
;
used
.
push
(
index
)
;
id
}
pub
fn
release
<
I
:
id
:
:
TypedId
>
(
&
mut
self
id
:
I
)
{
let
(
index
epoch
_backend
)
=
id
.
unzip
(
)
;
self
.
free
.
push
(
(
index
epoch
)
)
;
self
.
count
-
=
1
;
}
pub
fn
count
(
&
self
)
-
>
usize
{
self
.
count
}
}
#
[
derive
(
Debug
)
]
pub
struct
IdentityManager
<
I
:
id
:
:
TypedId
>
{
pub
(
super
)
values
:
Mutex
<
IdentityValues
>
_phantom
:
PhantomData
<
I
>
}
impl
<
I
:
id
:
:
TypedId
>
IdentityManager
<
I
>
{
pub
fn
process
(
&
self
backend
:
Backend
)
-
>
I
{
self
.
values
.
lock
(
)
.
alloc
(
backend
)
}
pub
fn
mark_as_used
(
&
self
id
:
I
)
-
>
I
{
self
.
values
.
lock
(
)
.
mark_as_used
(
id
)
}
pub
fn
free
(
&
self
id
:
I
)
{
self
.
values
.
lock
(
)
.
release
(
id
)
}
}
impl
<
I
:
id
:
:
TypedId
>
IdentityManager
<
I
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
values
:
Mutex
:
:
new
(
IdentityValues
:
:
default
(
)
)
_phantom
:
PhantomData
}
}
}
pub
trait
IdentityHandlerFactory
<
I
:
id
:
:
TypedId
>
{
type
Input
:
Copy
;
fn
spawn
(
&
self
)
-
>
Arc
<
IdentityManager
<
I
>
>
{
Arc
:
:
new
(
IdentityManager
:
:
new
(
)
)
}
fn
autogenerate_ids
(
)
-
>
bool
;
fn
input_to_id
(
id_in
:
Self
:
:
Input
)
-
>
I
;
}
#
[
derive
(
Debug
)
]
pub
struct
IdentityManagerFactory
;
impl
<
I
:
id
:
:
TypedId
>
IdentityHandlerFactory
<
I
>
for
IdentityManagerFactory
{
type
Input
=
(
)
;
fn
autogenerate_ids
(
)
-
>
bool
{
true
}
fn
input_to_id
(
_id_in
:
Self
:
:
Input
)
-
>
I
{
unreachable
!
(
"
It
should
not
be
called
"
)
}
}
pub
trait
GlobalIdentityHandlerFactory
:
IdentityHandlerFactory
<
id
:
:
AdapterId
>
+
IdentityHandlerFactory
<
id
:
:
DeviceId
>
+
IdentityHandlerFactory
<
id
:
:
PipelineLayoutId
>
+
IdentityHandlerFactory
<
id
:
:
ShaderModuleId
>
+
IdentityHandlerFactory
<
id
:
:
BindGroupLayoutId
>
+
IdentityHandlerFactory
<
id
:
:
BindGroupId
>
+
IdentityHandlerFactory
<
id
:
:
CommandBufferId
>
+
IdentityHandlerFactory
<
id
:
:
RenderBundleId
>
+
IdentityHandlerFactory
<
id
:
:
RenderPipelineId
>
+
IdentityHandlerFactory
<
id
:
:
ComputePipelineId
>
+
IdentityHandlerFactory
<
id
:
:
QuerySetId
>
+
IdentityHandlerFactory
<
id
:
:
BufferId
>
+
IdentityHandlerFactory
<
id
:
:
StagingBufferId
>
+
IdentityHandlerFactory
<
id
:
:
TextureId
>
+
IdentityHandlerFactory
<
id
:
:
TextureViewId
>
+
IdentityHandlerFactory
<
id
:
:
SamplerId
>
+
IdentityHandlerFactory
<
id
:
:
SurfaceId
>
{
}
impl
GlobalIdentityHandlerFactory
for
IdentityManagerFactory
{
}
pub
type
Input
<
G
I
>
=
<
G
as
IdentityHandlerFactory
<
I
>
>
:
:
Input
;
#
[
test
]
fn
test_epoch_end_of_life
(
)
{
use
id
:
:
TypedId
as
_
;
let
man
=
IdentityManager
:
:
<
id
:
:
BufferId
>
:
:
new
(
)
;
let
forced_id
=
man
.
mark_as_used
(
id
:
:
BufferId
:
:
zip
(
0
1
Backend
:
:
Empty
)
)
;
assert_eq
!
(
forced_id
.
unzip
(
)
.
0
0
)
;
let
id1
=
man
.
process
(
Backend
:
:
Empty
)
;
assert_eq
!
(
id1
.
unzip
(
)
.
0
1
)
;
man
.
free
(
id1
)
;
let
id2
=
man
.
process
(
Backend
:
:
Empty
)
;
assert_eq
!
(
id2
.
unzip
(
)
.
0
1
)
;
assert_eq
!
(
id2
.
unzip
(
)
.
1
2
)
;
}
