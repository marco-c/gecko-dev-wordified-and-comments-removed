mod
allocator
;
mod
bind
;
mod
bundle
;
mod
clear
;
mod
compute
;
mod
compute_command
;
mod
draw
;
mod
memory_init
;
mod
pass
;
mod
query
;
mod
ray_tracing
;
mod
render
;
mod
render_command
;
mod
timestamp_writes
;
mod
transfer
;
mod
transition_resources
;
use
alloc
:
:
{
borrow
:
:
ToOwned
as
_
boxed
:
:
Box
string
:
:
String
sync
:
:
Arc
vec
:
:
Vec
}
;
use
core
:
:
mem
:
:
{
self
ManuallyDrop
}
;
use
core
:
:
ops
;
pub
(
crate
)
use
self
:
:
clear
:
:
clear_texture
;
pub
use
self
:
:
{
bundle
:
:
*
clear
:
:
ClearError
compute
:
:
*
compute_command
:
:
ComputeCommand
draw
:
:
*
query
:
:
*
render
:
:
*
render_command
:
:
RenderCommand
transfer
:
:
*
}
;
pub
(
crate
)
use
allocator
:
:
CommandAllocator
;
pub
(
crate
)
use
timestamp_writes
:
:
ArcPassTimestampWrites
;
pub
use
timestamp_writes
:
:
PassTimestampWrites
;
use
self
:
:
memory_init
:
:
CommandBufferTextureMemoryActions
;
use
crate
:
:
binding_model
:
:
BindingError
;
use
crate
:
:
command
:
:
transition_resources
:
:
TransitionResourcesError
;
use
crate
:
:
device
:
:
queue
:
:
TempResource
;
use
crate
:
:
device
:
:
{
Device
DeviceError
MissingFeatures
}
;
use
crate
:
:
lock
:
:
{
rank
Mutex
}
;
use
crate
:
:
snatch
:
:
SnatchGuard
;
use
crate
:
:
init_tracker
:
:
BufferInitTrackerAction
;
use
crate
:
:
ray_tracing
:
:
{
AsAction
BuildAccelerationStructureError
}
;
use
crate
:
:
resource
:
:
{
DestroyedResourceError
Fallible
InvalidResourceError
Labeled
ParentDevice
as
_
QuerySet
}
;
use
crate
:
:
storage
:
:
Storage
;
use
crate
:
:
track
:
:
{
DeviceTracker
ResourceUsageCompatibilityError
Tracker
UsageScope
}
;
use
crate
:
:
{
api_log
global
:
:
Global
id
resource_log
Label
}
;
use
crate
:
:
{
hal_label
LabelHelpers
}
;
use
wgt
:
:
error
:
:
{
ErrorType
WebGpuError
}
;
use
thiserror
:
:
Error
;
#
[
cfg
(
feature
=
"
trace
"
)
]
use
crate
:
:
device
:
:
trace
:
:
Command
as
TraceCommand
;
const
PUSH_CONSTANT_CLEAR_ARRAY
:
&
[
u32
]
=
&
[
0_u32
;
64
]
;
pub
(
crate
)
enum
CommandEncoderStatus
{
Recording
(
CommandBufferMutable
)
Locked
(
CommandBufferMutable
)
Consumed
Finished
(
CommandBufferMutable
)
Error
(
CommandEncoderError
)
Transitioning
}
impl
CommandEncoderStatus
{
fn
record_with
<
F
:
FnOnce
(
&
mut
CommandBufferMutable
)
-
>
Result
<
(
)
E
>
E
:
Clone
+
Into
<
CommandEncoderError
>
>
(
&
mut
self
f
:
F
)
-
>
Result
<
(
)
EncoderStateError
>
{
match
self
{
Self
:
:
Recording
(
_
)
=
>
{
RecordingGuard
{
inner
:
self
}
.
record
(
f
)
;
Ok
(
(
)
)
}
Self
:
:
Locked
(
_
)
=
>
{
self
.
invalidate
(
EncoderStateError
:
:
Locked
)
;
Ok
(
(
)
)
}
Self
:
:
Finished
(
_
)
=
>
Err
(
self
.
invalidate
(
EncoderStateError
:
:
Ended
)
)
Self
:
:
Consumed
=
>
Err
(
EncoderStateError
:
:
Ended
)
Self
:
:
Error
(
_
)
=
>
Ok
(
(
)
)
Self
:
:
Transitioning
=
>
unreachable
!
(
)
}
}
pub
(
crate
)
fn
record_as_hal_mut
<
T
F
:
FnOnce
(
Option
<
&
mut
CommandBufferMutable
>
)
-
>
T
>
(
&
mut
self
f
:
F
)
-
>
T
{
match
self
{
Self
:
:
Recording
(
_
)
=
>
RecordingGuard
{
inner
:
self
}
.
record_as_hal_mut
(
f
)
Self
:
:
Locked
(
_
)
=
>
{
self
.
invalidate
(
EncoderStateError
:
:
Locked
)
;
f
(
None
)
}
Self
:
:
Finished
(
_
)
=
>
{
self
.
invalidate
(
EncoderStateError
:
:
Ended
)
;
f
(
None
)
}
Self
:
:
Consumed
=
>
f
(
None
)
Self
:
:
Error
(
_
)
=
>
f
(
None
)
Self
:
:
Transitioning
=
>
unreachable
!
(
)
}
}
#
[
cfg
(
feature
=
"
trace
"
)
]
fn
get_inner
(
&
mut
self
)
-
>
&
mut
CommandBufferMutable
{
match
self
{
Self
:
:
Locked
(
inner
)
|
Self
:
:
Finished
(
inner
)
|
Self
:
:
Recording
(
inner
)
=
>
inner
Self
:
:
Consumed
=
>
unreachable
!
(
"
command
encoder
is
consumed
"
)
Self
:
:
Error
(
_
)
=
>
unreachable
!
(
"
passes
in
a
trace
do
not
store
errors
"
)
Self
:
:
Transitioning
=
>
unreachable
!
(
)
}
}
fn
lock_encoder
(
&
mut
self
)
-
>
Result
<
(
)
EncoderStateError
>
{
match
mem
:
:
replace
(
self
Self
:
:
Transitioning
)
{
Self
:
:
Recording
(
inner
)
=
>
{
*
self
=
Self
:
:
Locked
(
inner
)
;
Ok
(
(
)
)
}
st
Self
:
:
Finished
(
_
)
=
>
{
*
self
=
st
;
Err
(
EncoderStateError
:
:
Ended
)
}
Self
:
:
Locked
(
_
)
=
>
Err
(
self
.
invalidate
(
EncoderStateError
:
:
Locked
)
)
st
Self
:
:
Consumed
=
>
{
*
self
=
st
;
Err
(
EncoderStateError
:
:
Ended
)
}
st
Self
:
:
Error
(
_
)
=
>
{
*
self
=
st
;
Err
(
EncoderStateError
:
:
Invalid
)
}
Self
:
:
Transitioning
=
>
unreachable
!
(
)
}
}
fn
unlock_and_record
<
F
:
FnOnce
(
&
mut
CommandBufferMutable
)
-
>
Result
<
(
)
E
>
E
:
Clone
+
Into
<
CommandEncoderError
>
>
(
&
mut
self
f
:
F
)
-
>
Result
<
(
)
EncoderStateError
>
{
match
mem
:
:
replace
(
self
Self
:
:
Transitioning
)
{
Self
:
:
Locked
(
inner
)
=
>
{
*
self
=
Self
:
:
Recording
(
inner
)
;
RecordingGuard
{
inner
:
self
}
.
record
(
f
)
;
Ok
(
(
)
)
}
st
Self
:
:
Finished
(
_
)
=
>
{
*
self
=
st
;
Err
(
EncoderStateError
:
:
Ended
)
}
Self
:
:
Recording
(
_
)
=
>
{
*
self
=
Self
:
:
Error
(
EncoderStateError
:
:
Unlocked
.
into
(
)
)
;
Err
(
EncoderStateError
:
:
Unlocked
)
}
st
Self
:
:
Consumed
=
>
{
*
self
=
st
;
Err
(
EncoderStateError
:
:
Ended
)
}
st
Self
:
:
Error
(
_
)
=
>
{
*
self
=
st
;
Ok
(
(
)
)
}
Self
:
:
Transitioning
=
>
unreachable
!
(
)
}
}
fn
finish
(
&
mut
self
)
-
>
Self
{
match
mem
:
:
replace
(
self
Self
:
:
Consumed
)
{
Self
:
:
Recording
(
mut
inner
)
=
>
{
if
let
Err
(
err
)
=
inner
.
encoder
.
close_if_open
(
)
{
Self
:
:
Error
(
err
.
into
(
)
)
}
else
{
Self
:
:
Finished
(
inner
)
}
}
Self
:
:
Consumed
|
Self
:
:
Finished
(
_
)
=
>
Self
:
:
Error
(
EncoderStateError
:
:
Ended
.
into
(
)
)
Self
:
:
Locked
(
_
)
=
>
Self
:
:
Error
(
EncoderStateError
:
:
Locked
.
into
(
)
)
st
Self
:
:
Error
(
_
)
=
>
st
Self
:
:
Transitioning
=
>
unreachable
!
(
)
}
}
fn
invalidate
<
E
:
Clone
+
Into
<
CommandEncoderError
>
>
(
&
mut
self
err
:
E
)
-
>
E
{
let
enc_err
=
err
.
clone
(
)
.
into
(
)
;
api_log
!
(
"
Invalidating
command
encoder
:
{
enc_err
:
?
}
"
)
;
*
self
=
Self
:
:
Error
(
enc_err
)
;
err
}
}
pub
(
crate
)
struct
RecordingGuard
<
'
a
>
{
inner
:
&
'
a
mut
CommandEncoderStatus
}
impl
<
'
a
>
RecordingGuard
<
'
a
>
{
pub
(
crate
)
fn
mark_successful
(
self
)
{
mem
:
:
forget
(
self
)
}
fn
record
<
F
:
FnOnce
(
&
mut
CommandBufferMutable
)
-
>
Result
<
(
)
E
>
E
:
Clone
+
Into
<
CommandEncoderError
>
>
(
mut
self
f
:
F
)
{
match
f
(
&
mut
self
)
{
Ok
(
(
)
)
=
>
self
.
mark_successful
(
)
Err
(
err
)
=
>
{
self
.
inner
.
invalidate
(
err
)
;
}
}
}
pub
(
crate
)
fn
record_as_hal_mut
<
T
F
:
FnOnce
(
Option
<
&
mut
CommandBufferMutable
>
)
-
>
T
>
(
mut
self
f
:
F
)
-
>
T
{
let
res
=
f
(
Some
(
&
mut
self
)
)
;
self
.
mark_successful
(
)
;
res
}
}
impl
<
'
a
>
Drop
for
RecordingGuard
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
if
matches
!
(
*
self
.
inner
CommandEncoderStatus
:
:
Error
(
_
)
)
{
return
;
}
self
.
inner
.
invalidate
(
EncoderStateError
:
:
Invalid
)
;
}
}
impl
<
'
a
>
ops
:
:
Deref
for
RecordingGuard
<
'
a
>
{
type
Target
=
CommandBufferMutable
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
match
&
*
self
.
inner
{
CommandEncoderStatus
:
:
Recording
(
command_buffer_mutable
)
=
>
command_buffer_mutable
_
=
>
unreachable
!
(
)
}
}
}
impl
<
'
a
>
ops
:
:
DerefMut
for
RecordingGuard
<
'
a
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
match
self
.
inner
{
CommandEncoderStatus
:
:
Recording
(
command_buffer_mutable
)
=
>
command_buffer_mutable
_
=
>
unreachable
!
(
)
}
}
}
pub
(
crate
)
struct
CommandEncoder
{
pub
(
crate
)
device
:
Arc
<
Device
>
pub
(
crate
)
label
:
String
pub
(
crate
)
data
:
Mutex
<
CommandEncoderStatus
>
}
crate
:
:
impl_resource_type
!
(
CommandEncoder
)
;
crate
:
:
impl_labeled
!
(
CommandEncoder
)
;
crate
:
:
impl_parent_device
!
(
CommandEncoder
)
;
crate
:
:
impl_storage_item
!
(
CommandEncoder
)
;
impl
Drop
for
CommandEncoder
{
fn
drop
(
&
mut
self
)
{
resource_log
!
(
"
Drop
{
}
"
self
.
error_ident
(
)
)
;
}
}
pub
(
crate
)
struct
InnerCommandEncoder
{
pub
(
crate
)
raw
:
ManuallyDrop
<
Box
<
dyn
hal
:
:
DynCommandEncoder
>
>
pub
(
crate
)
list
:
Vec
<
Box
<
dyn
hal
:
:
DynCommandBuffer
>
>
pub
(
crate
)
device
:
Arc
<
Device
>
pub
(
crate
)
is_open
:
bool
pub
(
crate
)
label
:
String
}
impl
InnerCommandEncoder
{
fn
close_and_swap
(
&
mut
self
)
-
>
Result
<
(
)
DeviceError
>
{
assert
!
(
self
.
is_open
)
;
self
.
is_open
=
false
;
let
new
=
unsafe
{
self
.
raw
.
end_encoding
(
)
}
.
map_err
(
|
e
|
self
.
device
.
handle_hal_error
(
e
)
)
?
;
self
.
list
.
insert
(
self
.
list
.
len
(
)
-
1
new
)
;
Ok
(
(
)
)
}
pub
(
crate
)
fn
close_and_push_front
(
&
mut
self
)
-
>
Result
<
(
)
DeviceError
>
{
assert
!
(
self
.
is_open
)
;
self
.
is_open
=
false
;
let
new
=
unsafe
{
self
.
raw
.
end_encoding
(
)
}
.
map_err
(
|
e
|
self
.
device
.
handle_hal_error
(
e
)
)
?
;
self
.
list
.
insert
(
0
new
)
;
Ok
(
(
)
)
}
pub
(
crate
)
fn
close
(
&
mut
self
)
-
>
Result
<
(
)
DeviceError
>
{
assert
!
(
self
.
is_open
)
;
self
.
is_open
=
false
;
let
cmd_buf
=
unsafe
{
self
.
raw
.
end_encoding
(
)
}
.
map_err
(
|
e
|
self
.
device
.
handle_hal_error
(
e
)
)
?
;
self
.
list
.
push
(
cmd_buf
)
;
Ok
(
(
)
)
}
fn
close_if_open
(
&
mut
self
)
-
>
Result
<
(
)
DeviceError
>
{
if
self
.
is_open
{
self
.
is_open
=
false
;
let
cmd_buf
=
unsafe
{
self
.
raw
.
end_encoding
(
)
}
.
map_err
(
|
e
|
self
.
device
.
handle_hal_error
(
e
)
)
?
;
self
.
list
.
push
(
cmd_buf
)
;
}
Ok
(
(
)
)
}
pub
(
crate
)
fn
open
(
&
mut
self
)
-
>
Result
<
&
mut
dyn
hal
:
:
DynCommandEncoder
DeviceError
>
{
if
!
self
.
is_open
{
self
.
is_open
=
true
;
let
hal_label
=
hal_label
(
Some
(
self
.
label
.
as_str
(
)
)
self
.
device
.
instance_flags
)
;
unsafe
{
self
.
raw
.
begin_encoding
(
hal_label
)
}
.
map_err
(
|
e
|
self
.
device
.
handle_hal_error
(
e
)
)
?
;
}
Ok
(
self
.
raw
.
as_mut
(
)
)
}
pub
(
crate
)
fn
open_pass
(
&
mut
self
label
:
Option
<
&
str
>
)
-
>
Result
<
&
mut
dyn
hal
:
:
DynCommandEncoder
DeviceError
>
{
assert
!
(
!
self
.
is_open
)
;
self
.
is_open
=
true
;
let
hal_label
=
hal_label
(
label
self
.
device
.
instance_flags
)
;
unsafe
{
self
.
raw
.
begin_encoding
(
hal_label
)
}
.
map_err
(
|
e
|
self
.
device
.
handle_hal_error
(
e
)
)
?
;
Ok
(
self
.
raw
.
as_mut
(
)
)
}
}
impl
Drop
for
InnerCommandEncoder
{
fn
drop
(
&
mut
self
)
{
if
self
.
is_open
{
unsafe
{
self
.
raw
.
discard_encoding
(
)
}
;
}
unsafe
{
self
.
raw
.
reset_all
(
mem
:
:
take
(
&
mut
self
.
list
)
)
;
}
let
raw
=
unsafe
{
ManuallyDrop
:
:
take
(
&
mut
self
.
raw
)
}
;
self
.
device
.
command_allocator
.
release_encoder
(
raw
)
;
}
}
pub
(
crate
)
struct
BakedCommands
{
pub
(
crate
)
encoder
:
InnerCommandEncoder
pub
(
crate
)
trackers
:
Tracker
pub
(
crate
)
temp_resources
:
Vec
<
TempResource
>
pub
(
crate
)
indirect_draw_validation_resources
:
crate
:
:
indirect_validation
:
:
DrawResources
buffer_memory_init_actions
:
Vec
<
BufferInitTrackerAction
>
texture_memory_actions
:
CommandBufferTextureMemoryActions
}
pub
struct
CommandBufferMutable
{
pub
(
crate
)
encoder
:
InnerCommandEncoder
pub
(
crate
)
trackers
:
Tracker
buffer_memory_init_actions
:
Vec
<
BufferInitTrackerAction
>
texture_memory_actions
:
CommandBufferTextureMemoryActions
pub
(
crate
)
pending_query_resets
:
QueryResetMap
as_actions
:
Vec
<
AsAction
>
temp_resources
:
Vec
<
TempResource
>
indirect_draw_validation_resources
:
crate
:
:
indirect_validation
:
:
DrawResources
#
[
cfg
(
feature
=
"
trace
"
)
]
pub
(
crate
)
commands
:
Option
<
Vec
<
TraceCommand
>
>
}
impl
CommandBufferMutable
{
pub
(
crate
)
fn
open_encoder_and_tracker
(
&
mut
self
)
-
>
Result
<
(
&
mut
dyn
hal
:
:
DynCommandEncoder
&
mut
Tracker
)
DeviceError
>
{
let
encoder
=
self
.
encoder
.
open
(
)
?
;
let
tracker
=
&
mut
self
.
trackers
;
Ok
(
(
encoder
tracker
)
)
}
pub
(
crate
)
fn
into_baked_commands
(
self
)
-
>
BakedCommands
{
BakedCommands
{
encoder
:
self
.
encoder
trackers
:
self
.
trackers
temp_resources
:
self
.
temp_resources
indirect_draw_validation_resources
:
self
.
indirect_draw_validation_resources
buffer_memory_init_actions
:
self
.
buffer_memory_init_actions
texture_memory_actions
:
self
.
texture_memory_actions
}
}
}
pub
struct
CommandBuffer
{
pub
(
crate
)
device
:
Arc
<
Device
>
label
:
String
pub
(
crate
)
data
:
Mutex
<
CommandEncoderStatus
>
}
impl
Drop
for
CommandBuffer
{
fn
drop
(
&
mut
self
)
{
resource_log
!
(
"
Drop
{
}
"
self
.
error_ident
(
)
)
;
}
}
impl
CommandEncoder
{
pub
(
crate
)
fn
new
(
encoder
:
Box
<
dyn
hal
:
:
DynCommandEncoder
>
device
:
&
Arc
<
Device
>
label
:
&
Label
)
-
>
Self
{
CommandEncoder
{
device
:
device
.
clone
(
)
label
:
label
.
to_string
(
)
data
:
Mutex
:
:
new
(
rank
:
:
COMMAND_BUFFER_DATA
CommandEncoderStatus
:
:
Recording
(
CommandBufferMutable
{
encoder
:
InnerCommandEncoder
{
raw
:
ManuallyDrop
:
:
new
(
encoder
)
list
:
Vec
:
:
new
(
)
device
:
device
.
clone
(
)
is_open
:
false
label
:
label
.
to_string
(
)
}
trackers
:
Tracker
:
:
new
(
)
buffer_memory_init_actions
:
Default
:
:
default
(
)
texture_memory_actions
:
Default
:
:
default
(
)
pending_query_resets
:
QueryResetMap
:
:
new
(
)
as_actions
:
Default
:
:
default
(
)
temp_resources
:
Default
:
:
default
(
)
indirect_draw_validation_resources
:
crate
:
:
indirect_validation
:
:
DrawResources
:
:
new
(
device
.
clone
(
)
)
#
[
cfg
(
feature
=
"
trace
"
)
]
commands
:
if
device
.
trace
.
lock
(
)
.
is_some
(
)
{
Some
(
Vec
:
:
new
(
)
)
}
else
{
None
}
}
)
)
}
}
pub
(
crate
)
fn
new_invalid
(
device
:
&
Arc
<
Device
>
label
:
&
Label
err
:
CommandEncoderError
)
-
>
Self
{
CommandEncoder
{
device
:
device
.
clone
(
)
label
:
label
.
to_string
(
)
data
:
Mutex
:
:
new
(
rank
:
:
COMMAND_BUFFER_DATA
CommandEncoderStatus
:
:
Error
(
err
)
)
}
}
pub
(
crate
)
fn
insert_barriers_from_tracker
(
raw
:
&
mut
dyn
hal
:
:
DynCommandEncoder
base
:
&
mut
Tracker
head
:
&
Tracker
snatch_guard
:
&
SnatchGuard
)
{
profiling
:
:
scope
!
(
"
insert_barriers
"
)
;
base
.
buffers
.
set_from_tracker
(
&
head
.
buffers
)
;
base
.
textures
.
set_from_tracker
(
&
head
.
textures
)
;
Self
:
:
drain_barriers
(
raw
base
snatch_guard
)
;
}
pub
(
crate
)
fn
insert_barriers_from_scope
(
raw
:
&
mut
dyn
hal
:
:
DynCommandEncoder
base
:
&
mut
Tracker
head
:
&
UsageScope
snatch_guard
:
&
SnatchGuard
)
{
profiling
:
:
scope
!
(
"
insert_barriers
"
)
;
base
.
buffers
.
set_from_usage_scope
(
&
head
.
buffers
)
;
base
.
textures
.
set_from_usage_scope
(
&
head
.
textures
)
;
Self
:
:
drain_barriers
(
raw
base
snatch_guard
)
;
}
pub
(
crate
)
fn
drain_barriers
(
raw
:
&
mut
dyn
hal
:
:
DynCommandEncoder
base
:
&
mut
Tracker
snatch_guard
:
&
SnatchGuard
)
{
profiling
:
:
scope
!
(
"
drain_barriers
"
)
;
let
buffer_barriers
=
base
.
buffers
.
drain_transitions
(
snatch_guard
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
(
transitions
textures
)
=
base
.
textures
.
drain_transitions
(
snatch_guard
)
;
let
texture_barriers
=
transitions
.
into_iter
(
)
.
enumerate
(
)
.
map
(
|
(
i
p
)
|
p
.
into_hal
(
textures
[
i
]
.
unwrap
(
)
.
raw
(
)
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
unsafe
{
raw
.
transition_buffers
(
&
buffer_barriers
)
;
raw
.
transition_textures
(
&
texture_barriers
)
;
}
}
pub
(
crate
)
fn
insert_barriers_from_device_tracker
(
raw
:
&
mut
dyn
hal
:
:
DynCommandEncoder
base
:
&
mut
DeviceTracker
head
:
&
Tracker
snatch_guard
:
&
SnatchGuard
)
{
profiling
:
:
scope
!
(
"
insert_barriers_from_device_tracker
"
)
;
let
buffer_barriers
=
base
.
buffers
.
set_from_tracker_and_drain_transitions
(
&
head
.
buffers
snatch_guard
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
texture_barriers
=
base
.
textures
.
set_from_tracker_and_drain_transitions
(
&
head
.
textures
snatch_guard
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
unsafe
{
raw
.
transition_buffers
(
&
buffer_barriers
)
;
raw
.
transition_textures
(
&
texture_barriers
)
;
}
}
}
impl
CommandBuffer
{
pub
fn
take_finished
(
&
self
)
-
>
Result
<
CommandBufferMutable
CommandEncoderError
>
{
use
CommandEncoderStatus
as
St
;
match
mem
:
:
replace
(
&
mut
*
self
.
data
.
lock
(
)
CommandEncoderStatus
:
:
Error
(
EncoderStateError
:
:
Submitted
.
into
(
)
)
)
{
St
:
:
Finished
(
command_buffer_mutable
)
=
>
Ok
(
command_buffer_mutable
)
St
:
:
Error
(
err
)
=
>
Err
(
err
)
St
:
:
Recording
(
_
)
|
St
:
:
Locked
(
_
)
|
St
:
:
Consumed
|
St
:
:
Transitioning
=
>
unreachable
!
(
)
}
}
}
crate
:
:
impl_resource_type
!
(
CommandBuffer
)
;
crate
:
:
impl_labeled
!
(
CommandBuffer
)
;
crate
:
:
impl_parent_device
!
(
CommandBuffer
)
;
crate
:
:
impl_storage_item
!
(
CommandBuffer
)
;
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
BasePass
<
C
E
>
{
pub
label
:
Option
<
String
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
skip
default
=
"
Option
:
:
default
"
)
)
]
pub
error
:
Option
<
E
>
pub
commands
:
Vec
<
C
>
pub
dynamic_offsets
:
Vec
<
wgt
:
:
DynamicOffset
>
pub
string_data
:
Vec
<
u8
>
pub
push_constant_data
:
Vec
<
u32
>
}
impl
<
C
:
Clone
E
:
Clone
>
BasePass
<
C
E
>
{
fn
new
(
label
:
&
Label
)
-
>
Self
{
Self
{
label
:
label
.
as_deref
(
)
.
map
(
str
:
:
to_owned
)
error
:
None
commands
:
Vec
:
:
new
(
)
dynamic_offsets
:
Vec
:
:
new
(
)
string_data
:
Vec
:
:
new
(
)
push_constant_data
:
Vec
:
:
new
(
)
}
}
fn
new_invalid
(
label
:
&
Label
err
:
E
)
-
>
Self
{
Self
{
label
:
label
.
as_deref
(
)
.
map
(
str
:
:
to_owned
)
error
:
Some
(
err
)
commands
:
Vec
:
:
new
(
)
dynamic_offsets
:
Vec
:
:
new
(
)
string_data
:
Vec
:
:
new
(
)
push_constant_data
:
Vec
:
:
new
(
)
}
}
}
macro_rules
!
pass_base
{
(
pass
:
expr
scope
:
expr
(
)
?
)
=
>
{
match
(
&
pass
.
parent
&
pass
.
base
.
error
)
{
/
/
Pass
is
ended
(
&
None
_
)
=
>
return
Err
(
EncoderStateError
:
:
Ended
)
.
map_pass_err
(
scope
)
/
/
Pass
is
invalid
(
&
Some
(
_
)
&
Some
(
_
)
)
=
>
return
Ok
(
(
)
)
/
/
Pass
is
open
and
valid
(
&
Some
(
_
)
&
None
)
=
>
&
mut
pass
.
base
}
}
;
}
pub
(
crate
)
use
pass_base
;
macro_rules
!
pass_try
{
(
base
:
expr
scope
:
expr
res
:
expr
(
)
?
)
=
>
{
match
res
.
map_pass_err
(
scope
)
{
Ok
(
val
)
=
>
val
Err
(
err
)
=
>
{
base
.
error
.
get_or_insert
(
err
)
;
return
Ok
(
(
)
)
;
}
}
}
;
}
pub
(
crate
)
use
pass_try
;
#
[
derive
(
Clone
Debug
Error
)
]
#
[
non_exhaustive
]
pub
enum
EncoderStateError
{
#
[
error
(
"
Encoder
is
invalid
"
)
]
Invalid
#
[
error
(
"
Encoding
must
not
have
ended
"
)
]
Ended
#
[
error
(
"
Encoder
is
locked
by
a
previously
created
render
/
compute
pass
.
Before
recording
any
new
commands
the
pass
must
be
ended
.
"
)
]
Locked
#
[
error
(
"
Encoder
is
not
currently
locked
.
A
pass
can
only
be
ended
while
the
encoder
is
locked
.
"
)
]
Unlocked
#
[
error
(
"
This
command
buffer
has
already
been
submitted
.
"
)
]
Submitted
}
impl
WebGpuError
for
EncoderStateError
{
fn
webgpu_error_type
(
&
self
)
-
>
ErrorType
{
match
self
{
EncoderStateError
:
:
Invalid
|
EncoderStateError
:
:
Ended
|
EncoderStateError
:
:
Locked
|
EncoderStateError
:
:
Unlocked
|
EncoderStateError
:
:
Submitted
=
>
ErrorType
:
:
Validation
}
}
}
#
[
derive
(
Clone
Debug
Error
)
]
#
[
non_exhaustive
]
pub
enum
CommandEncoderError
{
#
[
error
(
transparent
)
]
State
(
#
[
from
]
EncoderStateError
)
#
[
error
(
transparent
)
]
Device
(
#
[
from
]
DeviceError
)
#
[
error
(
transparent
)
]
InvalidResource
(
#
[
from
]
InvalidResourceError
)
#
[
error
(
transparent
)
]
DestroyedResource
(
#
[
from
]
DestroyedResourceError
)
#
[
error
(
transparent
)
]
ResourceUsage
(
#
[
from
]
ResourceUsageCompatibilityError
)
#
[
error
(
transparent
)
]
MissingFeatures
(
#
[
from
]
MissingFeatures
)
#
[
error
(
transparent
)
]
Transfer
(
#
[
from
]
TransferError
)
#
[
error
(
transparent
)
]
Clear
(
#
[
from
]
ClearError
)
#
[
error
(
transparent
)
]
Query
(
#
[
from
]
QueryError
)
#
[
error
(
transparent
)
]
BuildAccelerationStructure
(
#
[
from
]
BuildAccelerationStructureError
)
#
[
error
(
transparent
)
]
TransitionResources
(
#
[
from
]
TransitionResourcesError
)
#
[
error
(
transparent
)
]
ComputePass
(
#
[
from
]
ComputePassError
)
#
[
error
(
transparent
)
]
RenderPass
(
#
[
from
]
RenderPassError
)
}
impl
CommandEncoderError
{
fn
is_destroyed_error
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
DestroyedResource
(
_
)
|
Self
:
:
Clear
(
ClearError
:
:
DestroyedResource
(
_
)
)
|
Self
:
:
Query
(
QueryError
:
:
DestroyedResource
(
_
)
)
|
Self
:
:
ComputePass
(
ComputePassError
{
inner
:
ComputePassErrorInner
:
:
DestroyedResource
(
_
)
.
.
}
)
|
Self
:
:
RenderPass
(
RenderPassError
{
inner
:
RenderPassErrorInner
:
:
DestroyedResource
(
_
)
.
.
}
)
|
Self
:
:
RenderPass
(
RenderPassError
{
inner
:
RenderPassErrorInner
:
:
RenderCommand
(
RenderCommandError
:
:
DestroyedResource
(
_
)
)
.
.
}
)
|
Self
:
:
RenderPass
(
RenderPassError
{
inner
:
RenderPassErrorInner
:
:
RenderCommand
(
RenderCommandError
:
:
BindingError
(
BindingError
:
:
DestroyedResource
(
_
)
)
)
.
.
}
)
)
}
}
impl
WebGpuError
for
CommandEncoderError
{
fn
webgpu_error_type
(
&
self
)
-
>
ErrorType
{
let
e
:
&
dyn
WebGpuError
=
match
self
{
Self
:
:
Device
(
e
)
=
>
e
Self
:
:
InvalidResource
(
e
)
=
>
e
Self
:
:
MissingFeatures
(
e
)
=
>
e
Self
:
:
State
(
e
)
=
>
e
Self
:
:
DestroyedResource
(
e
)
=
>
e
Self
:
:
Transfer
(
e
)
=
>
e
Self
:
:
Clear
(
e
)
=
>
e
Self
:
:
Query
(
e
)
=
>
e
Self
:
:
BuildAccelerationStructure
(
e
)
=
>
e
Self
:
:
TransitionResources
(
e
)
=
>
e
Self
:
:
ResourceUsage
(
e
)
=
>
e
Self
:
:
ComputePass
(
e
)
=
>
e
Self
:
:
RenderPass
(
e
)
=
>
e
}
;
e
.
webgpu_error_type
(
)
}
}
#
[
derive
(
Clone
Debug
Error
)
]
#
[
non_exhaustive
]
pub
enum
TimestampWritesError
{
#
[
error
(
"
begin
and
end
indices
of
pass
timestamp
writes
are
both
set
to
{
idx
}
which
is
not
allowed
"
)
]
IndicesEqual
{
idx
:
u32
}
#
[
error
(
"
no
begin
or
end
indices
were
specified
for
pass
timestamp
writes
expected
at
least
one
to
be
set
"
)
]
IndicesMissing
}
impl
WebGpuError
for
TimestampWritesError
{
fn
webgpu_error_type
(
&
self
)
-
>
ErrorType
{
match
self
{
Self
:
:
IndicesEqual
{
.
.
}
|
Self
:
:
IndicesMissing
=
>
ErrorType
:
:
Validation
}
}
}
impl
Global
{
pub
fn
command_encoder_finish
(
&
self
encoder_id
:
id
:
:
CommandEncoderId
desc
:
&
wgt
:
:
CommandBufferDescriptor
<
Label
>
id_in
:
Option
<
id
:
:
CommandBufferId
>
)
-
>
(
id
:
:
CommandBufferId
Option
<
CommandEncoderError
>
)
{
profiling
:
:
scope
!
(
"
CommandEncoder
:
:
finish
"
)
;
let
hub
=
&
self
.
hub
;
let
cmd_enc
=
hub
.
command_encoders
.
get
(
encoder_id
)
;
let
data
=
cmd_enc
.
data
.
lock
(
)
.
finish
(
)
;
let
error
=
match
data
{
CommandEncoderStatus
:
:
Error
(
ref
e
)
if
!
e
.
is_destroyed_error
(
)
=
>
Some
(
e
.
clone
(
)
)
_
=
>
None
}
;
let
cmd_buf
=
CommandBuffer
{
device
:
cmd_enc
.
device
.
clone
(
)
label
:
desc
.
label
.
to_string
(
)
data
:
Mutex
:
:
new
(
rank
:
:
COMMAND_BUFFER_DATA
data
)
}
;
let
cmd_buf_id
=
hub
.
command_buffers
.
prepare
(
id_in
)
.
assign
(
Arc
:
:
new
(
cmd_buf
)
)
;
(
cmd_buf_id
error
)
}
pub
fn
command_encoder_push_debug_group
(
&
self
encoder_id
:
id
:
:
CommandEncoderId
label
:
&
str
)
-
>
Result
<
(
)
EncoderStateError
>
{
profiling
:
:
scope
!
(
"
CommandEncoder
:
:
push_debug_group
"
)
;
api_log
!
(
"
CommandEncoder
:
:
push_debug_group
{
label
}
"
)
;
let
hub
=
&
self
.
hub
;
let
cmd_enc
=
hub
.
command_encoders
.
get
(
encoder_id
)
;
let
mut
cmd_buf_data
=
cmd_enc
.
data
.
lock
(
)
;
cmd_buf_data
.
record_with
(
|
cmd_buf_data
|
-
>
Result
<
(
)
CommandEncoderError
>
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
list
)
=
cmd_buf_data
.
commands
{
list
.
push
(
TraceCommand
:
:
PushDebugGroup
(
label
.
to_owned
(
)
)
)
;
}
cmd_enc
.
device
.
check_is_valid
(
)
?
;
let
cmd_buf_raw
=
cmd_buf_data
.
encoder
.
open
(
)
?
;
if
!
cmd_enc
.
device
.
instance_flags
.
contains
(
wgt
:
:
InstanceFlags
:
:
DISCARD_HAL_LABELS
)
{
unsafe
{
cmd_buf_raw
.
begin_debug_marker
(
label
)
;
}
}
Ok
(
(
)
)
}
)
}
pub
fn
command_encoder_insert_debug_marker
(
&
self
encoder_id
:
id
:
:
CommandEncoderId
label
:
&
str
)
-
>
Result
<
(
)
EncoderStateError
>
{
profiling
:
:
scope
!
(
"
CommandEncoder
:
:
insert_debug_marker
"
)
;
api_log
!
(
"
CommandEncoder
:
:
insert_debug_marker
{
label
}
"
)
;
let
hub
=
&
self
.
hub
;
let
cmd_enc
=
hub
.
command_encoders
.
get
(
encoder_id
)
;
let
mut
cmd_buf_data
=
cmd_enc
.
data
.
lock
(
)
;
cmd_buf_data
.
record_with
(
|
cmd_buf_data
|
-
>
Result
<
(
)
CommandEncoderError
>
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
list
)
=
cmd_buf_data
.
commands
{
list
.
push
(
TraceCommand
:
:
InsertDebugMarker
(
label
.
to_owned
(
)
)
)
;
}
cmd_enc
.
device
.
check_is_valid
(
)
?
;
if
!
cmd_enc
.
device
.
instance_flags
.
contains
(
wgt
:
:
InstanceFlags
:
:
DISCARD_HAL_LABELS
)
{
let
cmd_buf_raw
=
cmd_buf_data
.
encoder
.
open
(
)
?
;
unsafe
{
cmd_buf_raw
.
insert_debug_marker
(
label
)
;
}
}
Ok
(
(
)
)
}
)
}
pub
fn
command_encoder_pop_debug_group
(
&
self
encoder_id
:
id
:
:
CommandEncoderId
)
-
>
Result
<
(
)
EncoderStateError
>
{
profiling
:
:
scope
!
(
"
CommandEncoder
:
:
pop_debug_marker
"
)
;
api_log
!
(
"
CommandEncoder
:
:
pop_debug_group
"
)
;
let
hub
=
&
self
.
hub
;
let
cmd_enc
=
hub
.
command_encoders
.
get
(
encoder_id
)
;
let
mut
cmd_buf_data
=
cmd_enc
.
data
.
lock
(
)
;
cmd_buf_data
.
record_with
(
|
cmd_buf_data
|
-
>
Result
<
(
)
CommandEncoderError
>
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
list
)
=
cmd_buf_data
.
commands
{
list
.
push
(
TraceCommand
:
:
PopDebugGroup
)
;
}
cmd_enc
.
device
.
check_is_valid
(
)
?
;
let
cmd_buf_raw
=
cmd_buf_data
.
encoder
.
open
(
)
?
;
if
!
cmd_enc
.
device
.
instance_flags
.
contains
(
wgt
:
:
InstanceFlags
:
:
DISCARD_HAL_LABELS
)
{
unsafe
{
cmd_buf_raw
.
end_debug_marker
(
)
;
}
}
Ok
(
(
)
)
}
)
}
fn
validate_pass_timestamp_writes
<
E
>
(
device
:
&
Device
query_sets
:
&
Storage
<
Fallible
<
QuerySet
>
>
timestamp_writes
:
&
PassTimestampWrites
)
-
>
Result
<
ArcPassTimestampWrites
E
>
where
E
:
From
<
TimestampWritesError
>
+
From
<
QueryUseError
>
+
From
<
DeviceError
>
+
From
<
MissingFeatures
>
+
From
<
InvalidResourceError
>
{
let
&
PassTimestampWrites
{
query_set
beginning_of_pass_write_index
end_of_pass_write_index
}
=
timestamp_writes
;
device
.
require_features
(
wgt
:
:
Features
:
:
TIMESTAMP_QUERY
)
?
;
let
query_set
=
query_sets
.
get
(
query_set
)
.
get
(
)
?
;
query_set
.
same_device
(
device
)
?
;
for
idx
in
[
beginning_of_pass_write_index
end_of_pass_write_index
]
.
into_iter
(
)
.
flatten
(
)
{
query_set
.
validate_query
(
SimplifiedQueryType
:
:
Timestamp
idx
None
)
?
;
}
if
let
Some
(
(
begin
end
)
)
=
beginning_of_pass_write_index
.
zip
(
end_of_pass_write_index
)
{
if
begin
=
=
end
{
return
Err
(
TimestampWritesError
:
:
IndicesEqual
{
idx
:
begin
}
.
into
(
)
)
;
}
}
if
beginning_of_pass_write_index
.
or
(
end_of_pass_write_index
)
.
is_none
(
)
{
return
Err
(
TimestampWritesError
:
:
IndicesMissing
.
into
(
)
)
;
}
Ok
(
ArcPassTimestampWrites
{
query_set
beginning_of_pass_write_index
end_of_pass_write_index
}
)
}
}
fn
push_constant_clear
<
PushFn
>
(
offset
:
u32
size_bytes
:
u32
mut
push_fn
:
PushFn
)
where
PushFn
:
FnMut
(
u32
&
[
u32
]
)
{
let
mut
count_words
=
0_u32
;
let
size_words
=
size_bytes
/
wgt
:
:
PUSH_CONSTANT_ALIGNMENT
;
while
count_words
<
size_words
{
let
count_bytes
=
count_words
*
wgt
:
:
PUSH_CONSTANT_ALIGNMENT
;
let
size_to_write_words
=
(
size_words
-
count_words
)
.
min
(
PUSH_CONSTANT_CLEAR_ARRAY
.
len
(
)
as
u32
)
;
push_fn
(
offset
+
count_bytes
&
PUSH_CONSTANT_CLEAR_ARRAY
[
0
.
.
size_to_write_words
as
usize
]
)
;
count_words
+
=
size_to_write_words
;
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
struct
StateChange
<
T
>
{
last_state
:
Option
<
T
>
}
impl
<
T
:
Copy
+
PartialEq
>
StateChange
<
T
>
{
fn
new
(
)
-
>
Self
{
Self
{
last_state
:
None
}
}
fn
set_and_check_redundant
(
&
mut
self
new_state
:
T
)
-
>
bool
{
let
already_set
=
self
.
last_state
=
=
Some
(
new_state
)
;
self
.
last_state
=
Some
(
new_state
)
;
already_set
}
fn
reset
(
&
mut
self
)
{
self
.
last_state
=
None
;
}
}
impl
<
T
:
Copy
+
PartialEq
>
Default
for
StateChange
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
#
[
derive
(
Debug
)
]
struct
BindGroupStateChange
{
last_states
:
[
StateChange
<
Option
<
id
:
:
BindGroupId
>
>
;
hal
:
:
MAX_BIND_GROUPS
]
}
impl
BindGroupStateChange
{
fn
new
(
)
-
>
Self
{
Self
{
last_states
:
[
StateChange
:
:
new
(
)
;
hal
:
:
MAX_BIND_GROUPS
]
}
}
fn
set_and_check_redundant
(
&
mut
self
bind_group_id
:
Option
<
id
:
:
BindGroupId
>
index
:
u32
dynamic_offsets
:
&
mut
Vec
<
u32
>
offsets
:
&
[
wgt
:
:
DynamicOffset
]
)
-
>
bool
{
if
offsets
.
is_empty
(
)
{
if
let
Some
(
current_bind_group
)
=
self
.
last_states
.
get_mut
(
index
as
usize
)
{
if
current_bind_group
.
set_and_check_redundant
(
bind_group_id
)
{
return
true
;
}
}
}
else
{
if
let
Some
(
current_bind_group
)
=
self
.
last_states
.
get_mut
(
index
as
usize
)
{
current_bind_group
.
reset
(
)
;
}
dynamic_offsets
.
extend_from_slice
(
offsets
)
;
}
false
}
fn
reset
(
&
mut
self
)
{
self
.
last_states
=
[
StateChange
:
:
new
(
)
;
hal
:
:
MAX_BIND_GROUPS
]
;
}
}
impl
Default
for
BindGroupStateChange
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
trait
MapPassErr
<
T
>
{
fn
map_pass_err
(
self
scope
:
PassErrorScope
)
-
>
T
;
}
impl
<
T
E
F
>
MapPassErr
<
Result
<
T
F
>
>
for
Result
<
T
E
>
where
E
:
MapPassErr
<
F
>
{
fn
map_pass_err
(
self
scope
:
PassErrorScope
)
-
>
Result
<
T
F
>
{
self
.
map_err
(
|
err
|
err
.
map_pass_err
(
scope
)
)
}
}
impl
MapPassErr
<
PassStateError
>
for
EncoderStateError
{
fn
map_pass_err
(
self
scope
:
PassErrorScope
)
-
>
PassStateError
{
PassStateError
{
scope
inner
:
self
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
DrawKind
{
Draw
DrawIndirect
MultiDrawIndirect
MultiDrawIndirectCount
}
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
DrawCommandFamily
{
Draw
DrawIndexed
DrawMeshTasks
}
#
[
derive
(
Clone
Copy
Debug
Error
)
]
pub
enum
PassErrorScope
{
#
[
error
(
"
In
a
bundle
parameter
"
)
]
Bundle
#
[
error
(
"
In
a
pass
parameter
"
)
]
Pass
#
[
error
(
"
In
a
set_bind_group
command
"
)
]
SetBindGroup
#
[
error
(
"
In
a
set_pipeline
command
"
)
]
SetPipelineRender
#
[
error
(
"
In
a
set_pipeline
command
"
)
]
SetPipelineCompute
#
[
error
(
"
In
a
set_push_constant
command
"
)
]
SetPushConstant
#
[
error
(
"
In
a
set_vertex_buffer
command
"
)
]
SetVertexBuffer
#
[
error
(
"
In
a
set_index_buffer
command
"
)
]
SetIndexBuffer
#
[
error
(
"
In
a
set_blend_constant
command
"
)
]
SetBlendConstant
#
[
error
(
"
In
a
set_stencil_reference
command
"
)
]
SetStencilReference
#
[
error
(
"
In
a
set_viewport
command
"
)
]
SetViewport
#
[
error
(
"
In
a
set_scissor_rect
command
"
)
]
SetScissorRect
#
[
error
(
"
In
a
draw
command
kind
:
{
kind
:
?
}
"
)
]
Draw
{
kind
:
DrawKind
family
:
DrawCommandFamily
}
#
[
error
(
"
In
a
write_timestamp
command
"
)
]
WriteTimestamp
#
[
error
(
"
In
a
begin_occlusion_query
command
"
)
]
BeginOcclusionQuery
#
[
error
(
"
In
a
end_occlusion_query
command
"
)
]
EndOcclusionQuery
#
[
error
(
"
In
a
begin_pipeline_statistics_query
command
"
)
]
BeginPipelineStatisticsQuery
#
[
error
(
"
In
a
end_pipeline_statistics_query
command
"
)
]
EndPipelineStatisticsQuery
#
[
error
(
"
In
a
execute_bundle
command
"
)
]
ExecuteBundle
#
[
error
(
"
In
a
dispatch
command
indirect
:
{
indirect
}
"
)
]
Dispatch
{
indirect
:
bool
}
#
[
error
(
"
In
a
push_debug_group
command
"
)
]
PushDebugGroup
#
[
error
(
"
In
a
pop_debug_group
command
"
)
]
PopDebugGroup
#
[
error
(
"
In
a
insert_debug_marker
command
"
)
]
InsertDebugMarker
}
#
[
derive
(
Clone
Debug
Error
)
]
#
[
error
(
"
{
scope
}
"
)
]
pub
struct
PassStateError
{
pub
scope
:
PassErrorScope
#
[
source
]
pub
(
super
)
inner
:
EncoderStateError
}
impl
WebGpuError
for
PassStateError
{
fn
webgpu_error_type
(
&
self
)
-
>
ErrorType
{
let
Self
{
scope
:
_
inner
}
=
self
;
inner
.
webgpu_error_type
(
)
}
}
