use
std
:
:
{
collections
:
:
hash_map
:
:
Entry
ops
:
:
Range
sync
:
:
Arc
vec
:
:
Drain
}
;
use
hal
:
:
CommandEncoder
;
use
crate
:
:
{
device
:
:
Device
hal_api
:
:
HalApi
init_tracker
:
:
*
resource
:
:
{
Resource
Texture
}
track
:
:
{
TextureTracker
Tracker
}
FastHashMap
}
;
use
super
:
:
{
clear
:
:
clear_texture
BakedCommands
ClearError
DestroyedBufferError
DestroyedTextureError
}
;
#
[
derive
(
Clone
)
]
pub
(
crate
)
struct
TextureSurfaceDiscard
<
A
:
HalApi
>
{
pub
texture
:
Arc
<
Texture
<
A
>
>
pub
mip_level
:
u32
pub
layer
:
u32
}
pub
(
crate
)
type
SurfacesInDiscardState
<
A
>
=
Vec
<
TextureSurfaceDiscard
<
A
>
>
;
pub
(
crate
)
struct
CommandBufferTextureMemoryActions
<
A
:
HalApi
>
{
init_actions
:
Vec
<
TextureInitTrackerAction
<
A
>
>
discards
:
Vec
<
TextureSurfaceDiscard
<
A
>
>
}
impl
<
A
:
HalApi
>
Default
for
CommandBufferTextureMemoryActions
<
A
>
{
fn
default
(
)
-
>
Self
{
Self
{
init_actions
:
Default
:
:
default
(
)
discards
:
Default
:
:
default
(
)
}
}
}
impl
<
A
:
HalApi
>
CommandBufferTextureMemoryActions
<
A
>
{
pub
(
crate
)
fn
drain_init_actions
(
&
mut
self
)
-
>
Drain
<
TextureInitTrackerAction
<
A
>
>
{
self
.
init_actions
.
drain
(
.
.
)
}
pub
(
crate
)
fn
discard
(
&
mut
self
discard
:
TextureSurfaceDiscard
<
A
>
)
{
self
.
discards
.
push
(
discard
)
;
}
#
[
must_use
]
pub
(
crate
)
fn
register_init_action
(
&
mut
self
action
:
&
TextureInitTrackerAction
<
A
>
)
-
>
SurfacesInDiscardState
<
A
>
{
let
mut
immediately_necessary_clears
=
SurfacesInDiscardState
:
:
new
(
)
;
self
.
init_actions
.
extend
(
action
.
texture
.
initialization_status
.
read
(
)
.
check_action
(
action
)
)
;
let
init_actions
=
&
mut
self
.
init_actions
;
self
.
discards
.
retain
(
|
discarded_surface
|
{
if
discarded_surface
.
texture
.
as_info
(
)
.
id
(
)
=
=
action
.
texture
.
as_info
(
)
.
id
(
)
&
&
action
.
range
.
layer_range
.
contains
(
&
discarded_surface
.
layer
)
&
&
action
.
range
.
mip_range
.
contains
(
&
discarded_surface
.
mip_level
)
{
if
let
MemoryInitKind
:
:
NeedsInitializedMemory
=
action
.
kind
{
immediately_necessary_clears
.
push
(
discarded_surface
.
clone
(
)
)
;
init_actions
.
push
(
TextureInitTrackerAction
{
texture
:
discarded_surface
.
texture
.
clone
(
)
range
:
TextureInitRange
{
mip_range
:
discarded_surface
.
mip_level
.
.
(
discarded_surface
.
mip_level
+
1
)
layer_range
:
discarded_surface
.
layer
.
.
(
discarded_surface
.
layer
+
1
)
}
kind
:
MemoryInitKind
:
:
ImplicitlyInitialized
}
)
;
}
false
}
else
{
true
}
}
)
;
immediately_necessary_clears
}
pub
(
crate
)
fn
register_implicit_init
(
&
mut
self
texture
:
&
Arc
<
Texture
<
A
>
>
range
:
TextureInitRange
)
{
let
must_be_empty
=
self
.
register_init_action
(
&
TextureInitTrackerAction
{
texture
:
texture
.
clone
(
)
range
kind
:
MemoryInitKind
:
:
ImplicitlyInitialized
}
)
;
assert
!
(
must_be_empty
.
is_empty
(
)
)
;
}
}
pub
(
crate
)
fn
fixup_discarded_surfaces
<
A
:
HalApi
InitIter
:
Iterator
<
Item
=
TextureSurfaceDiscard
<
A
>
>
>
(
inits
:
InitIter
encoder
:
&
mut
A
:
:
CommandEncoder
texture_tracker
:
&
mut
TextureTracker
<
A
>
device
:
&
Device
<
A
>
)
{
for
init
in
inits
{
clear_texture
(
&
init
.
texture
TextureInitRange
{
mip_range
:
init
.
mip_level
.
.
(
init
.
mip_level
+
1
)
layer_range
:
init
.
layer
.
.
(
init
.
layer
+
1
)
}
encoder
texture_tracker
&
device
.
alignments
device
.
zero_buffer
.
as_ref
(
)
.
unwrap
(
)
)
.
unwrap
(
)
;
}
}
impl
<
A
:
HalApi
>
BakedCommands
<
A
>
{
pub
(
crate
)
fn
initialize_buffer_memory
(
&
mut
self
device_tracker
:
&
mut
Tracker
<
A
>
)
-
>
Result
<
(
)
DestroyedBufferError
>
{
let
mut
uninitialized_ranges_per_buffer
=
FastHashMap
:
:
default
(
)
;
for
buffer_use
in
self
.
buffer_memory_init_actions
.
drain
(
.
.
)
{
let
mut
initialization_status
=
buffer_use
.
buffer
.
initialization_status
.
write
(
)
;
let
end_remainder
=
buffer_use
.
range
.
end
%
wgt
:
:
COPY_BUFFER_ALIGNMENT
;
let
end
=
if
end_remainder
=
=
0
{
buffer_use
.
range
.
end
}
else
{
buffer_use
.
range
.
end
+
wgt
:
:
COPY_BUFFER_ALIGNMENT
-
end_remainder
}
;
let
uninitialized_ranges
=
initialization_status
.
drain
(
buffer_use
.
range
.
start
.
.
end
)
;
match
buffer_use
.
kind
{
MemoryInitKind
:
:
ImplicitlyInitialized
=
>
{
}
MemoryInitKind
:
:
NeedsInitializedMemory
=
>
{
match
uninitialized_ranges_per_buffer
.
entry
(
buffer_use
.
buffer
.
as_info
(
)
.
id
(
)
)
{
Entry
:
:
Vacant
(
e
)
=
>
{
e
.
insert
(
(
buffer_use
.
buffer
.
clone
(
)
uninitialized_ranges
.
collect
:
:
<
Vec
<
Range
<
wgt
:
:
BufferAddress
>
>
>
(
)
)
)
;
}
Entry
:
:
Occupied
(
mut
e
)
=
>
{
e
.
get_mut
(
)
.
1
.
extend
(
uninitialized_ranges
)
;
}
}
}
}
}
for
(
buffer_id
(
buffer
mut
ranges
)
)
in
uninitialized_ranges_per_buffer
{
ranges
.
sort_by_key
(
|
r
|
r
.
start
)
;
for
i
in
(
1
.
.
ranges
.
len
(
)
)
.
rev
(
)
{
assert
!
(
ranges
[
i
-
1
]
.
end
<
=
ranges
[
i
]
.
start
)
;
if
ranges
[
i
]
.
start
=
=
ranges
[
i
-
1
]
.
end
{
ranges
[
i
-
1
]
.
end
=
ranges
[
i
]
.
end
;
ranges
.
swap_remove
(
i
)
;
}
}
let
transition
=
device_tracker
.
buffers
.
set_single
(
&
buffer
hal
:
:
BufferUses
:
:
COPY_DST
)
.
unwrap
(
)
.
1
;
let
snatch_guard
=
buffer
.
device
.
snatchable_lock
.
read
(
)
;
let
raw_buf
=
buffer
.
raw
.
get
(
&
snatch_guard
)
.
ok_or
(
DestroyedBufferError
(
buffer_id
)
)
?
;
unsafe
{
self
.
encoder
.
transition_buffers
(
transition
.
map
(
|
pending
|
pending
.
into_hal
(
&
buffer
&
snatch_guard
)
)
.
into_iter
(
)
)
;
}
for
range
in
ranges
.
iter
(
)
{
assert
!
(
range
.
start
%
wgt
:
:
COPY_BUFFER_ALIGNMENT
=
=
0
"
Buffer
{
:
?
}
has
an
uninitialized
range
with
a
start
\
not
aligned
to
4
(
start
was
{
}
)
"
raw_buf
range
.
start
)
;
assert
!
(
range
.
end
%
wgt
:
:
COPY_BUFFER_ALIGNMENT
=
=
0
"
Buffer
{
:
?
}
has
an
uninitialized
range
with
an
end
\
not
aligned
to
4
(
end
was
{
}
)
"
raw_buf
range
.
end
)
;
unsafe
{
self
.
encoder
.
clear_buffer
(
raw_buf
range
.
clone
(
)
)
;
}
}
}
Ok
(
(
)
)
}
pub
(
crate
)
fn
initialize_texture_memory
(
&
mut
self
device_tracker
:
&
mut
Tracker
<
A
>
device
:
&
Device
<
A
>
)
-
>
Result
<
(
)
DestroyedTextureError
>
{
let
mut
ranges
:
Vec
<
TextureInitRange
>
=
Vec
:
:
new
(
)
;
for
texture_use
in
self
.
texture_memory_actions
.
drain_init_actions
(
)
{
let
mut
initialization_status
=
texture_use
.
texture
.
initialization_status
.
write
(
)
;
let
use_range
=
texture_use
.
range
;
let
affected_mip_trackers
=
initialization_status
.
mips
.
iter_mut
(
)
.
enumerate
(
)
.
skip
(
use_range
.
mip_range
.
start
as
usize
)
.
take
(
(
use_range
.
mip_range
.
end
-
use_range
.
mip_range
.
start
)
as
usize
)
;
match
texture_use
.
kind
{
MemoryInitKind
:
:
ImplicitlyInitialized
=
>
{
for
(
_
mip_tracker
)
in
affected_mip_trackers
{
mip_tracker
.
drain
(
use_range
.
layer_range
.
clone
(
)
)
;
}
}
MemoryInitKind
:
:
NeedsInitializedMemory
=
>
{
for
(
mip_level
mip_tracker
)
in
affected_mip_trackers
{
for
layer_range
in
mip_tracker
.
drain
(
use_range
.
layer_range
.
clone
(
)
)
{
ranges
.
push
(
TextureInitRange
{
mip_range
:
(
mip_level
as
u32
)
.
.
(
mip_level
as
u32
+
1
)
layer_range
}
)
;
}
}
}
}
for
range
in
ranges
.
drain
(
.
.
)
{
let
clear_result
=
clear_texture
(
&
texture_use
.
texture
range
&
mut
self
.
encoder
&
mut
device_tracker
.
textures
&
device
.
alignments
device
.
zero_buffer
.
as_ref
(
)
.
unwrap
(
)
)
;
if
let
Err
(
ClearError
:
:
InvalidTexture
(
id
)
)
=
clear_result
{
return
Err
(
DestroyedTextureError
(
id
)
)
;
}
if
let
Err
(
error
)
=
clear_result
{
panic
!
(
"
{
error
}
"
)
;
}
}
}
for
surface_discard
in
self
.
texture_memory_actions
.
discards
.
iter
(
)
{
surface_discard
.
texture
.
initialization_status
.
write
(
)
.
discard
(
surface_discard
.
mip_level
surface_discard
.
layer
)
;
}
Ok
(
(
)
)
}
}
