use
crate
:
:
resource
:
:
Resource
;
use
bit_vec
:
:
BitVec
;
use
std
:
:
{
borrow
:
:
Cow
mem
sync
:
:
Arc
}
;
use
wgt
:
:
strict_assert
;
#
[
derive
(
Debug
)
]
pub
(
super
)
struct
ResourceMetadata
<
T
:
Resource
>
{
owned
:
BitVec
<
usize
>
resources
:
Vec
<
Option
<
Arc
<
T
>
>
>
}
impl
<
T
:
Resource
>
ResourceMetadata
<
T
>
{
pub
(
super
)
fn
new
(
)
-
>
Self
{
Self
{
owned
:
BitVec
:
:
default
(
)
resources
:
Vec
:
:
new
(
)
}
}
pub
(
super
)
fn
size
(
&
self
)
-
>
usize
{
self
.
owned
.
len
(
)
}
pub
(
super
)
fn
set_size
(
&
mut
self
size
:
usize
)
{
self
.
resources
.
resize
(
size
None
)
;
resize_bitvec
(
&
mut
self
.
owned
size
)
;
}
pub
(
super
)
fn
clear
(
&
mut
self
)
{
self
.
resources
.
clear
(
)
;
self
.
owned
.
clear
(
)
;
}
#
[
cfg_attr
(
not
(
feature
=
"
strict_asserts
"
)
allow
(
unused_variables
)
)
]
pub
(
super
)
fn
tracker_assert_in_bounds
(
&
self
index
:
usize
)
{
strict_assert
!
(
index
<
self
.
owned
.
len
(
)
)
;
strict_assert
!
(
index
<
self
.
resources
.
len
(
)
)
;
strict_assert
!
(
if
self
.
contains
(
index
)
{
self
.
resources
[
index
]
.
is_some
(
)
}
else
{
true
}
)
;
}
pub
(
super
)
fn
is_empty
(
&
self
)
-
>
bool
{
!
self
.
owned
.
any
(
)
}
pub
(
super
)
fn
contains
(
&
self
index
:
usize
)
-
>
bool
{
self
.
owned
[
index
]
}
#
[
inline
(
always
)
]
pub
(
super
)
unsafe
fn
contains_unchecked
(
&
self
index
:
usize
)
-
>
bool
{
unsafe
{
self
.
owned
.
get
(
index
)
.
unwrap_unchecked
(
)
}
}
#
[
inline
(
always
)
]
pub
(
super
)
unsafe
fn
insert
(
&
mut
self
index
:
usize
resource
:
Arc
<
T
>
)
-
>
&
Arc
<
T
>
{
self
.
owned
.
set
(
index
true
)
;
let
resource_dst
=
unsafe
{
self
.
resources
.
get_unchecked_mut
(
index
)
}
;
resource_dst
.
insert
(
resource
)
}
#
[
inline
(
always
)
]
pub
(
super
)
unsafe
fn
get_resource_unchecked
(
&
self
index
:
usize
)
-
>
&
Arc
<
T
>
{
unsafe
{
self
.
resources
.
get_unchecked
(
index
)
.
as_ref
(
)
.
unwrap_unchecked
(
)
}
}
#
[
inline
(
always
)
]
pub
(
super
)
unsafe
fn
get_ref_count_unchecked
(
&
self
index
:
usize
)
-
>
usize
{
unsafe
{
Arc
:
:
strong_count
(
self
.
get_resource_unchecked
(
index
)
)
}
}
pub
(
super
)
fn
owned_resources
(
&
self
)
-
>
impl
Iterator
<
Item
=
Arc
<
T
>
>
+
'
_
{
if
!
self
.
owned
.
is_empty
(
)
{
self
.
tracker_assert_in_bounds
(
self
.
owned
.
len
(
)
-
1
)
}
;
iterate_bitvec_indices
(
&
self
.
owned
)
.
map
(
move
|
index
|
{
let
resource
=
unsafe
{
self
.
resources
.
get_unchecked
(
index
)
}
;
resource
.
as_ref
(
)
.
unwrap
(
)
.
clone
(
)
}
)
}
pub
(
super
)
fn
drain_resources
(
&
mut
self
)
-
>
Vec
<
Arc
<
T
>
>
{
if
!
self
.
owned
.
is_empty
(
)
{
self
.
tracker_assert_in_bounds
(
self
.
owned
.
len
(
)
-
1
)
}
;
let
mut
resources
=
Vec
:
:
new
(
)
;
iterate_bitvec_indices
(
&
self
.
owned
)
.
for_each
(
|
index
|
{
let
resource
=
unsafe
{
self
.
resources
.
get_unchecked
(
index
)
}
;
resources
.
push
(
resource
.
as_ref
(
)
.
unwrap
(
)
.
clone
(
)
)
;
}
)
;
self
.
owned
.
clear
(
)
;
self
.
resources
.
clear
(
)
;
resources
}
pub
(
super
)
fn
owned_indices
(
&
self
)
-
>
impl
Iterator
<
Item
=
usize
>
+
'
_
{
if
!
self
.
owned
.
is_empty
(
)
{
self
.
tracker_assert_in_bounds
(
self
.
owned
.
len
(
)
-
1
)
}
;
iterate_bitvec_indices
(
&
self
.
owned
)
}
pub
(
super
)
unsafe
fn
remove
(
&
mut
self
index
:
usize
)
{
unsafe
{
*
self
.
resources
.
get_unchecked_mut
(
index
)
=
None
;
}
self
.
owned
.
set
(
index
false
)
;
}
}
pub
(
super
)
enum
ResourceMetadataProvider
<
'
a
T
:
Resource
>
{
Direct
{
resource
:
Cow
<
'
a
Arc
<
T
>
>
}
Indirect
{
metadata
:
&
'
a
ResourceMetadata
<
T
>
}
}
impl
<
T
:
Resource
>
ResourceMetadataProvider
<
'
_
T
>
{
#
[
inline
(
always
)
]
pub
(
super
)
unsafe
fn
get
(
&
self
index
:
usize
)
-
>
&
Arc
<
T
>
{
match
self
{
ResourceMetadataProvider
:
:
Direct
{
resource
}
=
>
resource
ResourceMetadataProvider
:
:
Indirect
{
metadata
}
=
>
{
metadata
.
tracker_assert_in_bounds
(
index
)
;
{
let
resource
=
unsafe
{
metadata
.
resources
.
get_unchecked
(
index
)
}
.
as_ref
(
)
;
unsafe
{
resource
.
unwrap_unchecked
(
)
}
}
}
}
}
}
fn
resize_bitvec
<
B
:
bit_vec
:
:
BitBlock
>
(
vec
:
&
mut
BitVec
<
B
>
size
:
usize
)
{
let
owned_size_to_grow
=
size
.
checked_sub
(
vec
.
len
(
)
)
;
if
let
Some
(
delta
)
=
owned_size_to_grow
{
if
delta
!
=
0
{
vec
.
grow
(
delta
false
)
;
}
}
else
{
vec
.
truncate
(
size
)
;
}
}
fn
iterate_bitvec_indices
(
ownership
:
&
BitVec
<
usize
>
)
-
>
impl
Iterator
<
Item
=
usize
>
+
'
_
{
const
BITS_PER_BLOCK
:
usize
=
mem
:
:
size_of
:
:
<
usize
>
(
)
*
8
;
let
size
=
ownership
.
len
(
)
;
ownership
.
blocks
(
)
.
enumerate
(
)
.
filter
(
|
&
(
_
word
)
|
word
!
=
0
)
.
flat_map
(
move
|
(
word_index
mut
word
)
|
{
let
bit_start
=
word_index
*
BITS_PER_BLOCK
;
let
bit_end
=
(
bit_start
+
BITS_PER_BLOCK
)
.
min
(
size
)
;
(
bit_start
.
.
bit_end
)
.
filter
(
move
|
_
|
{
let
active
=
word
&
0b1
!
=
0
;
word
>
>
=
1
;
active
}
)
}
)
}
