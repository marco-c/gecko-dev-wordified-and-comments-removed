use
std
:
:
sync
:
:
Arc
;
use
crate
:
:
{
lock
:
:
{
rank
Mutex
}
resource
:
:
Resource
resource_log
track
:
:
ResourceMetadata
}
;
use
super
:
:
{
ResourceTracker
TrackerIndex
}
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
StatelessBindGroupState
<
T
:
Resource
>
{
resources
:
Mutex
<
Vec
<
Arc
<
T
>
>
>
}
impl
<
T
:
Resource
>
StatelessBindGroupState
<
T
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
resources
:
Mutex
:
:
new
(
rank
:
:
STATELESS_BIND_GROUP_STATE_RESOURCES
Vec
:
:
new
(
)
)
}
}
pub
(
crate
)
fn
optimize
(
&
self
)
{
let
mut
resources
=
self
.
resources
.
lock
(
)
;
resources
.
sort_unstable_by_key
(
|
resource
|
resource
.
as_info
(
)
.
tracker_index
(
)
)
;
}
pub
fn
used_resources
(
&
self
)
-
>
impl
Iterator
<
Item
=
Arc
<
T
>
>
+
'
_
{
let
resources
=
self
.
resources
.
lock
(
)
;
resources
.
iter
(
)
.
cloned
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_iter
(
)
}
pub
fn
drain_resources
(
&
self
)
-
>
impl
Iterator
<
Item
=
Arc
<
T
>
>
+
'
_
{
let
mut
resources
=
self
.
resources
.
lock
(
)
;
resources
.
drain
(
.
.
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_iter
(
)
}
pub
fn
add_single
(
&
self
resource
:
&
Arc
<
T
>
)
{
let
mut
resources
=
self
.
resources
.
lock
(
)
;
resources
.
push
(
resource
.
clone
(
)
)
;
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
StatelessTracker
<
T
:
Resource
>
{
metadata
:
ResourceMetadata
<
T
>
}
impl
<
T
:
Resource
>
ResourceTracker
for
StatelessTracker
<
T
>
{
fn
remove_abandoned
(
&
mut
self
index
:
TrackerIndex
)
-
>
bool
{
let
index
=
index
.
as_usize
(
)
;
if
index
>
=
self
.
metadata
.
size
(
)
{
return
false
;
}
self
.
tracker_assert_in_bounds
(
index
)
;
unsafe
{
if
self
.
metadata
.
contains_unchecked
(
index
)
{
let
existing_ref_count
=
self
.
metadata
.
get_ref_count_unchecked
(
index
)
;
if
existing_ref_count
<
=
2
{
resource_log
!
(
"
StatelessTracker
<
{
}
>
:
:
remove_abandoned
:
removing
{
}
"
T
:
:
TYPE
self
.
metadata
.
get_resource_unchecked
(
index
)
.
error_ident
(
)
)
;
self
.
metadata
.
remove
(
index
)
;
return
true
;
}
resource_log
!
(
"
StatelessTracker
<
{
}
>
:
:
remove_abandoned
:
not
removing
{
}
ref
count
{
}
"
T
:
:
TYPE
self
.
metadata
.
get_resource_unchecked
(
index
)
.
error_ident
(
)
existing_ref_count
)
;
return
false
;
}
}
resource_log
!
(
"
StatelessTracker
<
{
}
>
:
:
remove_abandoned
:
does
not
contain
index
{
index
:
?
}
"
T
:
:
TYPE
)
;
true
}
}
impl
<
T
:
Resource
>
StatelessTracker
<
T
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
metadata
:
ResourceMetadata
:
:
new
(
)
}
}
fn
tracker_assert_in_bounds
(
&
self
index
:
usize
)
{
self
.
metadata
.
tracker_assert_in_bounds
(
index
)
;
}
pub
fn
set_size
(
&
mut
self
size
:
usize
)
{
self
.
metadata
.
set_size
(
size
)
;
}
fn
allow_index
(
&
mut
self
index
:
usize
)
{
if
index
>
=
self
.
metadata
.
size
(
)
{
self
.
set_size
(
index
+
1
)
;
}
}
pub
fn
used_resources
(
&
self
)
-
>
impl
Iterator
<
Item
=
Arc
<
T
>
>
+
'
_
{
self
.
metadata
.
owned_resources
(
)
}
pub
fn
drain_resources
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
Arc
<
T
>
>
+
'
_
{
let
resources
=
self
.
metadata
.
drain_resources
(
)
;
resources
.
into_iter
(
)
}
pub
fn
insert_single
(
&
mut
self
resource
:
Arc
<
T
>
)
-
>
&
Arc
<
T
>
{
let
index
=
resource
.
as_info
(
)
.
tracker_index
(
)
.
as_usize
(
)
;
self
.
allow_index
(
index
)
;
self
.
tracker_assert_in_bounds
(
index
)
;
unsafe
{
self
.
metadata
.
insert
(
index
resource
)
}
}
pub
fn
add_single
(
&
mut
self
resource
:
&
Arc
<
T
>
)
{
let
index
=
resource
.
as_info
(
)
.
tracker_index
(
)
.
as_usize
(
)
;
self
.
allow_index
(
index
)
;
self
.
tracker_assert_in_bounds
(
index
)
;
unsafe
{
self
.
metadata
.
insert
(
index
resource
.
clone
(
)
)
;
}
}
pub
fn
add_from_tracker
(
&
mut
self
other
:
&
Self
)
{
let
incoming_size
=
other
.
metadata
.
size
(
)
;
if
incoming_size
>
self
.
metadata
.
size
(
)
{
self
.
set_size
(
incoming_size
)
;
}
for
index
in
other
.
metadata
.
owned_indices
(
)
{
self
.
tracker_assert_in_bounds
(
index
)
;
other
.
tracker_assert_in_bounds
(
index
)
;
unsafe
{
let
previously_owned
=
self
.
metadata
.
contains_unchecked
(
index
)
;
if
!
previously_owned
{
let
other_resource
=
other
.
metadata
.
get_resource_unchecked
(
index
)
;
self
.
metadata
.
insert
(
index
other_resource
.
clone
(
)
)
;
}
}
}
}
}
