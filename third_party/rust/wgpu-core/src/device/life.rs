#
[
cfg
(
feature
=
"
trace
"
)
]
use
crate
:
:
device
:
:
trace
;
use
crate
:
:
{
binding_model
:
:
{
BindGroup
BindGroupLayout
PipelineLayout
}
command
:
:
RenderBundle
device
:
:
{
queue
:
:
{
EncoderInFlight
SubmittedWorkDoneClosure
TempResource
}
DeviceError
DeviceLostClosure
}
hal_api
:
:
HalApi
hub
:
:
Hub
id
:
:
{
self
BindGroupId
BindGroupLayoutId
BufferId
ComputePipelineId
PipelineLayoutId
QuerySetId
RenderBundleId
RenderPipelineId
SamplerId
StagingBufferId
TextureId
TextureViewId
}
pipeline
:
:
{
ComputePipeline
RenderPipeline
}
registry
:
:
Registry
resource
:
:
{
self
Buffer
QuerySet
Resource
ResourceType
Sampler
StagingBuffer
Texture
TextureView
}
track
:
:
{
ResourceTracker
Tracker
}
FastHashMap
SubmissionIndex
}
;
use
smallvec
:
:
SmallVec
;
use
parking_lot
:
:
Mutex
;
use
thiserror
:
:
Error
;
use
wgt
:
:
WasmNotSendSync
;
use
std
:
:
{
any
:
:
Any
sync
:
:
Arc
}
;
pub
(
crate
)
trait
ResourceMap
:
Any
+
WasmNotSendSync
{
fn
as_any
(
&
self
)
-
>
&
dyn
Any
;
fn
as_any_mut
(
&
mut
self
)
-
>
&
mut
dyn
Any
;
fn
clear_map
(
&
mut
self
)
;
fn
extend_map
(
&
mut
self
maps
:
&
mut
ResourceMaps
)
;
}
impl
<
Id
R
>
ResourceMap
for
FastHashMap
<
Id
Arc
<
R
>
>
where
Id
:
id
:
:
TypedId
R
:
Resource
<
Id
>
{
fn
as_any
(
&
self
)
-
>
&
dyn
Any
{
self
}
fn
as_any_mut
(
&
mut
self
)
-
>
&
mut
dyn
Any
{
self
}
fn
clear_map
(
&
mut
self
)
{
self
.
clear
(
)
}
fn
extend_map
(
&
mut
self
r
:
&
mut
ResourceMaps
)
{
if
let
Some
(
other
)
=
r
.
maps
.
get_mut
(
R
:
:
TYPE
)
{
if
let
Some
(
other
)
=
other
.
as_any_mut
(
)
.
downcast_mut
:
:
<
Self
>
(
)
{
self
.
extend
(
other
.
drain
(
)
)
;
}
}
}
}
#
[
derive
(
Default
)
]
pub
(
crate
)
struct
ResourceMaps
{
pub
(
crate
)
maps
:
FastHashMap
<
ResourceType
Box
<
dyn
ResourceMap
>
>
}
impl
ResourceMaps
{
fn
add_type
<
Id
R
>
(
&
mut
self
)
-
>
&
mut
Self
where
Id
:
id
:
:
TypedId
R
:
Resource
<
Id
>
{
let
map
=
FastHashMap
:
:
<
Id
Arc
<
R
>
>
:
:
default
(
)
;
self
.
maps
.
insert
(
R
:
:
TYPE
Box
:
:
new
(
map
)
)
;
self
}
fn
map
<
Id
R
>
(
&
self
)
-
>
&
FastHashMap
<
Id
Arc
<
R
>
>
where
Id
:
id
:
:
TypedId
R
:
Resource
<
Id
>
{
let
map
=
self
.
maps
.
get
(
R
:
:
TYPE
)
.
unwrap
(
)
;
let
any_map
=
map
.
as_ref
(
)
.
as_any
(
)
;
let
map
=
any_map
.
downcast_ref
:
:
<
FastHashMap
<
Id
Arc
<
R
>
>
>
(
)
.
unwrap
(
)
;
map
}
fn
map_mut
<
Id
R
>
(
&
mut
self
)
-
>
&
mut
FastHashMap
<
Id
Arc
<
R
>
>
where
Id
:
id
:
:
TypedId
R
:
Resource
<
Id
>
{
let
map
=
self
.
maps
.
entry
(
R
:
:
TYPE
)
.
or_insert_with
(
|
|
Box
:
:
<
FastHashMap
<
Id
Arc
<
R
>
>
>
:
:
default
(
)
)
;
let
any_map
=
map
.
as_mut
(
)
.
as_any_mut
(
)
;
let
map
=
any_map
.
downcast_mut
:
:
<
FastHashMap
<
Id
Arc
<
R
>
>
>
(
)
.
unwrap
(
)
;
map
}
pub
(
crate
)
fn
new
<
A
:
HalApi
>
(
)
-
>
Self
{
let
mut
maps
=
Self
:
:
default
(
)
;
maps
.
add_type
:
:
<
BufferId
Buffer
<
A
>
>
(
)
;
maps
.
add_type
:
:
<
StagingBufferId
StagingBuffer
<
A
>
>
(
)
;
maps
.
add_type
:
:
<
TextureId
Texture
<
A
>
>
(
)
;
maps
.
add_type
:
:
<
TextureViewId
TextureView
<
A
>
>
(
)
;
maps
.
add_type
:
:
<
SamplerId
Sampler
<
A
>
>
(
)
;
maps
.
add_type
:
:
<
BindGroupId
BindGroup
<
A
>
>
(
)
;
maps
.
add_type
:
:
<
BindGroupLayoutId
BindGroupLayout
<
A
>
>
(
)
;
maps
.
add_type
:
:
<
RenderPipelineId
RenderPipeline
<
A
>
>
(
)
;
maps
.
add_type
:
:
<
ComputePipelineId
ComputePipeline
<
A
>
>
(
)
;
maps
.
add_type
:
:
<
PipelineLayoutId
PipelineLayout
<
A
>
>
(
)
;
maps
.
add_type
:
:
<
RenderBundleId
RenderBundle
<
A
>
>
(
)
;
maps
.
add_type
:
:
<
QuerySetId
QuerySet
<
A
>
>
(
)
;
maps
}
pub
(
crate
)
fn
clear
(
&
mut
self
)
{
self
.
maps
.
iter_mut
(
)
.
for_each
(
|
(
_t
map
)
|
map
.
clear_map
(
)
)
;
}
pub
(
crate
)
fn
extend
(
&
mut
self
mut
other
:
Self
)
{
self
.
maps
.
iter_mut
(
)
.
for_each
(
|
(
_t
map
)
|
{
map
.
extend_map
(
&
mut
other
)
;
}
)
;
}
pub
(
crate
)
fn
insert
<
Id
R
>
(
&
mut
self
id
:
Id
r
:
Arc
<
R
>
)
-
>
&
mut
Self
where
Id
:
id
:
:
TypedId
R
:
Resource
<
Id
>
{
self
.
map_mut
(
)
.
insert
(
id
r
)
;
self
}
pub
(
crate
)
fn
contains
<
Id
R
>
(
&
mut
self
id
:
&
Id
)
-
>
bool
where
Id
:
id
:
:
TypedId
R
:
Resource
<
Id
>
{
self
.
map
:
:
<
Id
R
>
(
)
.
contains_key
(
id
)
}
}
struct
ActiveSubmission
<
A
:
HalApi
>
{
index
:
SubmissionIndex
last_resources
:
ResourceMaps
mapped
:
Vec
<
Arc
<
Buffer
<
A
>
>
>
encoders
:
Vec
<
EncoderInFlight
<
A
>
>
work_done_closures
:
SmallVec
<
[
SubmittedWorkDoneClosure
;
1
]
>
}
#
[
derive
(
Clone
Debug
Error
)
]
#
[
non_exhaustive
]
pub
enum
WaitIdleError
{
#
[
error
(
transparent
)
]
Device
(
#
[
from
]
DeviceError
)
#
[
error
(
"
Tried
to
wait
using
a
submission
index
from
the
wrong
device
.
Submission
index
is
from
device
{
0
:
?
}
.
Called
poll
on
device
{
1
:
?
}
.
"
)
]
WrongSubmissionIndex
(
id
:
:
QueueId
id
:
:
DeviceId
)
#
[
error
(
"
GPU
got
stuck
:
(
"
)
]
StuckGpu
}
pub
(
crate
)
struct
LifetimeTracker
<
A
:
HalApi
>
{
mapped
:
Vec
<
Arc
<
Buffer
<
A
>
>
>
pub
future_suspected_buffers
:
Vec
<
Arc
<
Buffer
<
A
>
>
>
pub
future_suspected_textures
:
Vec
<
Arc
<
Texture
<
A
>
>
>
pub
suspected_resources
:
ResourceMaps
active
:
Vec
<
ActiveSubmission
<
A
>
>
free_resources
:
ResourceMaps
ready_to_map
:
Vec
<
Arc
<
Buffer
<
A
>
>
>
work_done_closures
:
SmallVec
<
[
SubmittedWorkDoneClosure
;
1
]
>
pub
device_lost_closure
:
Option
<
DeviceLostClosure
>
}
impl
<
A
:
HalApi
>
LifetimeTracker
<
A
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
mapped
:
Vec
:
:
new
(
)
future_suspected_buffers
:
Vec
:
:
new
(
)
future_suspected_textures
:
Vec
:
:
new
(
)
suspected_resources
:
ResourceMaps
:
:
new
:
:
<
A
>
(
)
active
:
Vec
:
:
new
(
)
free_resources
:
ResourceMaps
:
:
new
:
:
<
A
>
(
)
ready_to_map
:
Vec
:
:
new
(
)
work_done_closures
:
SmallVec
:
:
new
(
)
device_lost_closure
:
None
}
}
pub
fn
queue_empty
(
&
self
)
-
>
bool
{
self
.
active
.
is_empty
(
)
}
pub
fn
track_submission
(
&
mut
self
index
:
SubmissionIndex
temp_resources
:
impl
Iterator
<
Item
=
TempResource
<
A
>
>
encoders
:
Vec
<
EncoderInFlight
<
A
>
>
)
{
let
mut
last_resources
=
ResourceMaps
:
:
new
:
:
<
A
>
(
)
;
for
res
in
temp_resources
{
match
res
{
TempResource
:
:
Buffer
(
raw
)
=
>
{
last_resources
.
insert
(
raw
.
as_info
(
)
.
id
(
)
raw
)
;
}
TempResource
:
:
StagingBuffer
(
raw
)
=
>
{
last_resources
.
insert
(
raw
.
as_info
(
)
.
id
(
)
raw
)
;
}
TempResource
:
:
Texture
(
raw
)
=
>
{
last_resources
.
insert
(
raw
.
as_info
(
)
.
id
(
)
raw
)
;
}
}
}
self
.
active
.
push
(
ActiveSubmission
{
index
last_resources
mapped
:
Vec
:
:
new
(
)
encoders
work_done_closures
:
SmallVec
:
:
new
(
)
}
)
;
}
pub
fn
post_submit
(
&
mut
self
)
{
for
v
in
self
.
future_suspected_buffers
.
drain
(
.
.
)
.
take
(
1
)
{
self
.
suspected_resources
.
insert
(
v
.
as_info
(
)
.
id
(
)
v
)
;
}
for
v
in
self
.
future_suspected_textures
.
drain
(
.
.
)
.
take
(
1
)
{
self
.
suspected_resources
.
insert
(
v
.
as_info
(
)
.
id
(
)
v
)
;
}
}
pub
(
crate
)
fn
map
(
&
mut
self
value
:
&
Arc
<
Buffer
<
A
>
>
)
{
self
.
mapped
.
push
(
value
.
clone
(
)
)
;
}
#
[
must_use
]
pub
fn
triage_submissions
(
&
mut
self
last_done
:
SubmissionIndex
command_allocator
:
&
mut
super
:
:
CommandAllocator
<
A
>
)
-
>
SmallVec
<
[
SubmittedWorkDoneClosure
;
1
]
>
{
profiling
:
:
scope
!
(
"
triage_submissions
"
)
;
let
done_count
=
self
.
active
.
iter
(
)
.
position
(
|
a
|
a
.
index
>
last_done
)
.
unwrap_or
(
self
.
active
.
len
(
)
)
;
let
mut
work_done_closures
:
SmallVec
<
_
>
=
self
.
work_done_closures
.
drain
(
.
.
)
.
collect
(
)
;
for
a
in
self
.
active
.
drain
(
.
.
done_count
)
{
log
:
:
info
!
(
"
Active
submission
{
}
is
done
"
a
.
index
)
;
self
.
free_resources
.
extend
(
a
.
last_resources
)
;
self
.
ready_to_map
.
extend
(
a
.
mapped
)
;
for
encoder
in
a
.
encoders
{
let
raw
=
unsafe
{
encoder
.
land
(
)
}
;
command_allocator
.
release_encoder
(
raw
)
;
}
work_done_closures
.
extend
(
a
.
work_done_closures
)
;
}
work_done_closures
}
pub
fn
cleanup
(
&
mut
self
)
{
profiling
:
:
scope
!
(
"
LifetimeTracker
:
:
cleanup
"
)
;
self
.
free_resources
.
clear
(
)
;
}
pub
fn
schedule_resource_destruction
(
&
mut
self
temp_resource
:
TempResource
<
A
>
last_submit_index
:
SubmissionIndex
)
{
let
resources
=
self
.
active
.
iter_mut
(
)
.
find
(
|
a
|
a
.
index
=
=
last_submit_index
)
.
map_or
(
&
mut
self
.
free_resources
|
a
|
&
mut
a
.
last_resources
)
;
match
temp_resource
{
TempResource
:
:
Buffer
(
raw
)
=
>
{
resources
.
insert
(
raw
.
as_info
(
)
.
id
(
)
raw
)
;
}
TempResource
:
:
StagingBuffer
(
raw
)
=
>
{
resources
.
insert
(
raw
.
as_info
(
)
.
id
(
)
raw
)
;
}
TempResource
:
:
Texture
(
raw
)
=
>
{
resources
.
insert
(
raw
.
as_info
(
)
.
id
(
)
raw
)
;
}
}
}
pub
fn
add_work_done_closure
(
&
mut
self
closure
:
SubmittedWorkDoneClosure
)
{
match
self
.
active
.
last_mut
(
)
{
Some
(
active
)
=
>
{
active
.
work_done_closures
.
push
(
closure
)
;
}
None
=
>
{
self
.
work_done_closures
.
push
(
closure
)
;
}
}
}
}
impl
<
A
:
HalApi
>
LifetimeTracker
<
A
>
{
fn
triage_resources
<
Id
R
F
T
>
(
resources_map
:
&
mut
FastHashMap
<
Id
Arc
<
R
>
>
active
:
&
mut
[
ActiveSubmission
<
A
>
]
free_resources
:
&
mut
ResourceMaps
trackers
:
&
mut
impl
ResourceTracker
<
Id
R
>
registry
:
&
Registry
<
Id
R
>
count_fn
:
F
mut
on_remove
:
T
)
-
>
Vec
<
Arc
<
R
>
>
where
Id
:
id
:
:
TypedId
R
:
Resource
<
Id
>
F
:
Fn
(
u64
&
[
ActiveSubmission
<
A
>
]
&
Id
)
-
>
usize
T
:
FnMut
(
&
Id
&
Arc
<
R
>
)
{
let
mut
removed_resources
=
Vec
:
:
new
(
)
;
resources_map
.
retain
(
|
&
id
resource
|
{
let
submit_index
=
resource
.
as_info
(
)
.
submission_index
(
)
;
let
mut
count
=
1
;
count
+
=
count_fn
(
submit_index
active
&
id
)
;
count
+
=
registry
.
contains
(
id
)
as
usize
;
let
non_referenced_resources
=
active
.
iter_mut
(
)
.
find
(
|
a
|
a
.
index
=
=
submit_index
)
.
map_or
(
&
mut
*
free_resources
|
a
|
&
mut
a
.
last_resources
)
;
count
+
=
non_referenced_resources
.
contains
:
:
<
Id
R
>
(
&
id
)
as
usize
;
let
is_removed
=
trackers
.
remove_abandoned
(
id
count
)
;
if
is_removed
{
on_remove
(
&
id
resource
)
;
removed_resources
.
push
(
resource
.
clone
(
)
)
;
non_referenced_resources
.
insert
(
id
resource
.
clone
(
)
)
;
}
!
is_removed
}
)
;
removed_resources
}
fn
triage_suspected_render_bundles
(
&
mut
self
hub
:
&
Hub
<
A
>
trackers
:
&
Mutex
<
Tracker
<
A
>
>
#
[
cfg
(
feature
=
"
trace
"
)
]
trace
:
&
mut
Option
<
&
mut
trace
:
:
Trace
>
)
-
>
&
mut
Self
{
let
mut
trackers
=
trackers
.
lock
(
)
;
let
resource_map
=
self
.
suspected_resources
.
map_mut
(
)
;
let
mut
removed_resources
=
Self
:
:
triage_resources
(
resource_map
self
.
active
.
as_mut_slice
(
)
&
mut
self
.
free_resources
&
mut
trackers
.
bundles
&
hub
.
render_bundles
|
_submit_index
_active
_id
|
0
|
_bundle_id
_bundle
|
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
t
)
=
*
trace
{
t
.
add
(
trace
:
:
Action
:
:
DestroyRenderBundle
(
*
_bundle_id
)
)
;
}
}
)
;
removed_resources
.
drain
(
.
.
)
.
for_each
(
|
bundle
|
{
for
v
in
bundle
.
used
.
buffers
.
write
(
)
.
drain_resources
(
)
{
self
.
suspected_resources
.
insert
(
v
.
as_info
(
)
.
id
(
)
v
)
;
}
for
v
in
bundle
.
used
.
textures
.
write
(
)
.
drain_resources
(
)
{
self
.
suspected_resources
.
insert
(
v
.
as_info
(
)
.
id
(
)
v
)
;
}
for
v
in
bundle
.
used
.
bind_groups
.
write
(
)
.
drain_resources
(
)
{
self
.
suspected_resources
.
insert
(
v
.
as_info
(
)
.
id
(
)
v
)
;
}
for
v
in
bundle
.
used
.
render_pipelines
.
write
(
)
.
drain_resources
(
)
{
self
.
suspected_resources
.
insert
(
v
.
as_info
(
)
.
id
(
)
v
)
;
}
for
v
in
bundle
.
used
.
query_sets
.
write
(
)
.
drain_resources
(
)
{
self
.
suspected_resources
.
insert
(
v
.
as_info
(
)
.
id
(
)
v
)
;
}
}
)
;
self
}
fn
triage_suspected_bind_groups
(
&
mut
self
hub
:
&
Hub
<
A
>
trackers
:
&
Mutex
<
Tracker
<
A
>
>
#
[
cfg
(
feature
=
"
trace
"
)
]
trace
:
&
mut
Option
<
&
mut
trace
:
:
Trace
>
)
-
>
&
mut
Self
{
let
mut
trackers
=
trackers
.
lock
(
)
;
let
resource_map
=
self
.
suspected_resources
.
map_mut
(
)
;
let
mut
removed_resource
=
Self
:
:
triage_resources
(
resource_map
self
.
active
.
as_mut_slice
(
)
&
mut
self
.
free_resources
&
mut
trackers
.
bind_groups
&
hub
.
bind_groups
|
_submit_index
_active
_id
|
0
|
_bind_group_id
_bind_group
|
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
t
)
=
*
trace
{
t
.
add
(
trace
:
:
Action
:
:
DestroyBindGroup
(
*
_bind_group_id
)
)
;
}
}
)
;
removed_resource
.
drain
(
.
.
)
.
for_each
(
|
bind_group
|
{
for
v
in
bind_group
.
used
.
buffers
.
drain_resources
(
)
{
self
.
suspected_resources
.
insert
(
v
.
as_info
(
)
.
id
(
)
v
)
;
}
for
v
in
bind_group
.
used
.
textures
.
drain_resources
(
)
{
self
.
suspected_resources
.
insert
(
v
.
as_info
(
)
.
id
(
)
v
)
;
}
for
v
in
bind_group
.
used
.
views
.
drain_resources
(
)
{
self
.
suspected_resources
.
insert
(
v
.
as_info
(
)
.
id
(
)
v
)
;
}
for
v
in
bind_group
.
used
.
samplers
.
drain_resources
(
)
{
self
.
suspected_resources
.
insert
(
v
.
as_info
(
)
.
id
(
)
v
)
;
}
bind_group
.
used_buffer_ranges
.
write
(
)
.
clear
(
)
;
bind_group
.
used_texture_ranges
.
write
(
)
.
clear
(
)
;
bind_group
.
dynamic_binding_info
.
write
(
)
.
clear
(
)
;
self
.
suspected_resources
.
insert
(
bind_group
.
layout
.
as_info
(
)
.
id
(
)
bind_group
.
layout
.
clone
(
)
)
;
}
)
;
self
}
fn
triage_suspected_texture_views
(
&
mut
self
hub
:
&
Hub
<
A
>
trackers
:
&
Mutex
<
Tracker
<
A
>
>
#
[
cfg
(
feature
=
"
trace
"
)
]
trace
:
&
mut
Option
<
&
mut
trace
:
:
Trace
>
)
-
>
&
mut
Self
{
let
mut
trackers
=
trackers
.
lock
(
)
;
let
resource_map
=
self
.
suspected_resources
.
map_mut
(
)
;
let
mut
removed_resources
=
Self
:
:
triage_resources
(
resource_map
self
.
active
.
as_mut_slice
(
)
&
mut
self
.
free_resources
&
mut
trackers
.
views
&
hub
.
texture_views
|
_submit_index
_active
_id
|
0
|
_texture_view_id
_texture_view
|
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
t
)
=
*
trace
{
t
.
add
(
trace
:
:
Action
:
:
DestroyTextureView
(
*
_texture_view_id
)
)
;
}
}
)
;
removed_resources
.
drain
(
.
.
)
.
for_each
(
|
texture_view
|
{
let
mut
lock
=
texture_view
.
parent
.
write
(
)
;
if
let
Some
(
parent_texture
)
=
lock
.
take
(
)
{
self
.
suspected_resources
.
insert
(
parent_texture
.
as_info
(
)
.
id
(
)
parent_texture
)
;
}
}
)
;
self
}
fn
triage_suspected_textures
(
&
mut
self
hub
:
&
Hub
<
A
>
trackers
:
&
Mutex
<
Tracker
<
A
>
>
#
[
cfg
(
feature
=
"
trace
"
)
]
trace
:
&
mut
Option
<
&
mut
trace
:
:
Trace
>
)
-
>
&
mut
Self
{
let
mut
trackers
=
trackers
.
lock
(
)
;
let
resource_map
=
self
.
suspected_resources
.
map_mut
(
)
;
Self
:
:
triage_resources
(
resource_map
self
.
active
.
as_mut_slice
(
)
&
mut
self
.
free_resources
&
mut
trackers
.
textures
&
hub
.
textures
|
_submit_index
_active
_id
|
0
|
_texture_id
_texture
|
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
t
)
=
*
trace
{
t
.
add
(
trace
:
:
Action
:
:
DestroyTexture
(
*
_texture_id
)
)
;
}
}
)
;
self
}
fn
triage_suspected_samplers
(
&
mut
self
hub
:
&
Hub
<
A
>
trackers
:
&
Mutex
<
Tracker
<
A
>
>
#
[
cfg
(
feature
=
"
trace
"
)
]
trace
:
&
mut
Option
<
&
mut
trace
:
:
Trace
>
)
-
>
&
mut
Self
{
let
mut
trackers
=
trackers
.
lock
(
)
;
let
resource_map
=
self
.
suspected_resources
.
map_mut
(
)
;
Self
:
:
triage_resources
(
resource_map
self
.
active
.
as_mut_slice
(
)
&
mut
self
.
free_resources
&
mut
trackers
.
samplers
&
hub
.
samplers
|
_submit_index
_active
_id
|
0
|
_sampler_id
_sampler
|
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
t
)
=
*
trace
{
t
.
add
(
trace
:
:
Action
:
:
DestroySampler
(
*
_sampler_id
)
)
;
}
}
)
;
self
}
fn
triage_suspected_buffers
(
&
mut
self
hub
:
&
Hub
<
A
>
trackers
:
&
Mutex
<
Tracker
<
A
>
>
#
[
cfg
(
feature
=
"
trace
"
)
]
trace
:
&
mut
Option
<
&
mut
trace
:
:
Trace
>
)
-
>
&
mut
Self
{
let
mut
trackers
=
trackers
.
lock
(
)
;
let
resource_map
=
self
.
suspected_resources
.
map_mut
(
)
;
let
mut
removed_resources
=
Self
:
:
triage_resources
(
resource_map
self
.
active
.
as_mut_slice
(
)
&
mut
self
.
free_resources
&
mut
trackers
.
buffers
&
hub
.
buffers
|
submit_index
active
buffer_id
|
{
let
mut
count
=
0
;
let
mapped
=
active
.
iter
(
)
.
find
(
|
a
|
a
.
index
=
=
submit_index
)
.
map_or
(
&
self
.
mapped
|
a
|
&
a
.
mapped
)
;
mapped
.
iter
(
)
.
for_each
(
|
b
|
{
if
b
.
as_info
(
)
.
id
(
)
=
=
*
buffer_id
{
count
+
=
1
;
}
}
)
;
count
}
|
_buffer_id
_buffer
|
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
t
)
=
*
trace
{
t
.
add
(
trace
:
:
Action
:
:
DestroyBuffer
(
*
_buffer_id
)
)
;
}
}
)
;
removed_resources
.
drain
(
.
.
)
.
for_each
(
|
buffer
|
{
if
let
resource
:
:
BufferMapState
:
:
Init
{
ref
stage_buffer
.
.
}
=
*
buffer
.
map_state
.
lock
(
)
{
self
.
free_resources
.
insert
(
stage_buffer
.
as_info
(
)
.
id
(
)
stage_buffer
.
clone
(
)
)
;
}
}
)
;
self
}
fn
triage_suspected_compute_pipelines
(
&
mut
self
hub
:
&
Hub
<
A
>
trackers
:
&
Mutex
<
Tracker
<
A
>
>
#
[
cfg
(
feature
=
"
trace
"
)
]
trace
:
&
mut
Option
<
&
mut
trace
:
:
Trace
>
)
-
>
&
mut
Self
{
let
mut
trackers
=
trackers
.
lock
(
)
;
let
resource_map
=
self
.
suspected_resources
.
map_mut
(
)
;
let
mut
removed_resources
=
Self
:
:
triage_resources
(
resource_map
self
.
active
.
as_mut_slice
(
)
&
mut
self
.
free_resources
&
mut
trackers
.
compute_pipelines
&
hub
.
compute_pipelines
|
_submit_index
_active
_id
|
0
|
_compute_pipeline_id
_compute_pipeline
|
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
t
)
=
*
trace
{
t
.
add
(
trace
:
:
Action
:
:
DestroyComputePipeline
(
*
_compute_pipeline_id
)
)
;
}
}
)
;
removed_resources
.
drain
(
.
.
)
.
for_each
(
|
compute_pipeline
|
{
self
.
suspected_resources
.
insert
(
compute_pipeline
.
layout
.
as_info
(
)
.
id
(
)
compute_pipeline
.
layout
.
clone
(
)
)
;
}
)
;
self
}
fn
triage_suspected_render_pipelines
(
&
mut
self
hub
:
&
Hub
<
A
>
trackers
:
&
Mutex
<
Tracker
<
A
>
>
#
[
cfg
(
feature
=
"
trace
"
)
]
trace
:
&
mut
Option
<
&
mut
trace
:
:
Trace
>
)
-
>
&
mut
Self
{
let
mut
trackers
=
trackers
.
lock
(
)
;
let
resource_map
=
self
.
suspected_resources
.
map_mut
(
)
;
let
mut
removed_resources
=
Self
:
:
triage_resources
(
resource_map
self
.
active
.
as_mut_slice
(
)
&
mut
self
.
free_resources
&
mut
trackers
.
render_pipelines
&
hub
.
render_pipelines
|
_submit_index
_active
_id
|
0
|
_render_pipeline_id
_render_pipeline
|
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
t
)
=
*
trace
{
t
.
add
(
trace
:
:
Action
:
:
DestroyRenderPipeline
(
*
_render_pipeline_id
)
)
;
}
}
)
;
removed_resources
.
drain
(
.
.
)
.
for_each
(
|
render_pipeline
|
{
self
.
suspected_resources
.
insert
(
render_pipeline
.
layout
.
as_info
(
)
.
id
(
)
render_pipeline
.
layout
.
clone
(
)
)
;
}
)
;
self
}
fn
triage_suspected_pipeline_layouts
(
&
mut
self
#
[
cfg
(
feature
=
"
trace
"
)
]
trace
:
&
mut
Option
<
&
mut
trace
:
:
Trace
>
)
-
>
&
mut
Self
{
let
mut
removed_resources
=
Vec
:
:
new
(
)
;
self
.
suspected_resources
.
map_mut
:
:
<
PipelineLayoutId
PipelineLayout
<
A
>
>
(
)
.
retain
(
|
_pipeline_layout_id
pipeline_layout
|
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
t
)
=
*
trace
{
t
.
add
(
trace
:
:
Action
:
:
DestroyPipelineLayout
(
*
_pipeline_layout_id
)
)
;
}
removed_resources
.
push
(
pipeline_layout
.
clone
(
)
)
;
false
}
)
;
removed_resources
.
drain
(
.
.
)
.
for_each
(
|
pipeline_layout
|
{
for
bgl
in
&
pipeline_layout
.
bind_group_layouts
{
self
.
suspected_resources
.
insert
(
bgl
.
as_info
(
)
.
id
(
)
bgl
.
clone
(
)
)
;
}
}
)
;
self
}
fn
triage_suspected_bind_group_layouts
(
&
mut
self
#
[
cfg
(
feature
=
"
trace
"
)
]
trace
:
&
mut
Option
<
&
mut
trace
:
:
Trace
>
)
-
>
&
mut
Self
{
self
.
suspected_resources
.
map_mut
:
:
<
BindGroupLayoutId
BindGroupLayout
<
A
>
>
(
)
.
retain
(
|
bind_group_layout_id
bind_group_layout
|
{
#
[
cfg
(
feature
=
"
trace
"
)
]
if
let
Some
(
ref
mut
t
)
=
*
trace
{
t
.
add
(
trace
:
:
Action
:
:
DestroyBindGroupLayout
(
*
bind_group_layout_id
)
)
;
}
self
.
free_resources
.
insert
(
*
bind_group_layout_id
bind_group_layout
.
clone
(
)
)
;
false
}
)
;
self
}
fn
triage_suspected_query_sets
(
&
mut
self
hub
:
&
Hub
<
A
>
trackers
:
&
Mutex
<
Tracker
<
A
>
>
)
-
>
&
mut
Self
{
let
mut
trackers
=
trackers
.
lock
(
)
;
let
resource_map
=
self
.
suspected_resources
.
map_mut
(
)
;
Self
:
:
triage_resources
(
resource_map
self
.
active
.
as_mut_slice
(
)
&
mut
self
.
free_resources
&
mut
trackers
.
query_sets
&
hub
.
query_sets
|
_submit_index
_active
_id
|
0
|
_query_set_id
_query_set
|
{
}
)
;
self
}
fn
triage_suspected_staging_buffers
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
suspected_resources
.
map_mut
:
:
<
StagingBufferId
StagingBuffer
<
A
>
>
(
)
.
retain
(
|
staging_buffer_id
staging_buffer
|
{
self
.
free_resources
.
insert
(
*
staging_buffer_id
staging_buffer
.
clone
(
)
)
;
false
}
)
;
self
}
pub
(
crate
)
fn
triage_suspected
(
&
mut
self
hub
:
&
Hub
<
A
>
trackers
:
&
Mutex
<
Tracker
<
A
>
>
#
[
cfg
(
feature
=
"
trace
"
)
]
mut
trace
:
Option
<
&
mut
trace
:
:
Trace
>
)
{
profiling
:
:
scope
!
(
"
triage_suspected
"
)
;
self
.
triage_suspected_render_bundles
(
hub
trackers
#
[
cfg
(
feature
=
"
trace
"
)
]
&
mut
trace
)
;
self
.
triage_suspected_compute_pipelines
(
hub
trackers
#
[
cfg
(
feature
=
"
trace
"
)
]
&
mut
trace
)
;
self
.
triage_suspected_render_pipelines
(
hub
trackers
#
[
cfg
(
feature
=
"
trace
"
)
]
&
mut
trace
)
;
self
.
triage_suspected_bind_groups
(
hub
trackers
#
[
cfg
(
feature
=
"
trace
"
)
]
&
mut
trace
)
;
self
.
triage_suspected_pipeline_layouts
(
#
[
cfg
(
feature
=
"
trace
"
)
]
&
mut
trace
)
;
self
.
triage_suspected_bind_group_layouts
(
#
[
cfg
(
feature
=
"
trace
"
)
]
&
mut
trace
)
;
self
.
triage_suspected_query_sets
(
hub
trackers
)
;
self
.
triage_suspected_samplers
(
hub
trackers
#
[
cfg
(
feature
=
"
trace
"
)
]
&
mut
trace
)
;
self
.
triage_suspected_staging_buffers
(
)
;
self
.
triage_suspected_texture_views
(
hub
trackers
#
[
cfg
(
feature
=
"
trace
"
)
]
&
mut
trace
)
;
self
.
triage_suspected_textures
(
hub
trackers
#
[
cfg
(
feature
=
"
trace
"
)
]
&
mut
trace
)
;
self
.
triage_suspected_buffers
(
hub
trackers
#
[
cfg
(
feature
=
"
trace
"
)
]
&
mut
trace
)
;
}
pub
(
crate
)
fn
triage_mapped
(
&
mut
self
)
{
if
self
.
mapped
.
is_empty
(
)
{
return
;
}
for
buffer
in
self
.
mapped
.
drain
(
.
.
)
{
let
submit_index
=
buffer
.
info
.
submission_index
(
)
;
log
:
:
trace
!
(
"
Mapping
of
{
:
?
}
at
submission
{
:
?
}
gets
assigned
to
active
{
:
?
}
"
buffer
.
info
.
id
(
)
submit_index
self
.
active
.
iter
(
)
.
position
(
|
a
|
a
.
index
=
=
submit_index
)
)
;
self
.
active
.
iter_mut
(
)
.
find
(
|
a
|
a
.
index
=
=
submit_index
)
.
map_or
(
&
mut
self
.
ready_to_map
|
a
|
&
mut
a
.
mapped
)
.
push
(
buffer
)
;
}
}
#
[
must_use
]
pub
(
crate
)
fn
handle_mapping
(
&
mut
self
hub
:
&
Hub
<
A
>
raw
:
&
A
:
:
Device
trackers
:
&
Mutex
<
Tracker
<
A
>
>
)
-
>
Vec
<
super
:
:
BufferMapPendingClosure
>
{
if
self
.
ready_to_map
.
is_empty
(
)
{
return
Vec
:
:
new
(
)
;
}
let
mut
pending_callbacks
:
Vec
<
super
:
:
BufferMapPendingClosure
>
=
Vec
:
:
with_capacity
(
self
.
ready_to_map
.
len
(
)
)
;
for
buffer
in
self
.
ready_to_map
.
drain
(
.
.
)
{
let
buffer_id
=
buffer
.
info
.
id
(
)
;
let
is_removed
=
{
let
mut
trackers
=
trackers
.
lock
(
)
;
let
mut
count
=
1
;
count
+
=
hub
.
buffers
.
contains
(
buffer_id
)
as
usize
;
trackers
.
buffers
.
remove_abandoned
(
buffer_id
count
)
}
;
if
is_removed
{
*
buffer
.
map_state
.
lock
(
)
=
resource
:
:
BufferMapState
:
:
Idle
;
log
:
:
info
!
(
"
Buffer
ready
to
map
{
:
?
}
is
not
tracked
anymore
"
buffer_id
)
;
self
.
free_resources
.
insert
(
buffer_id
buffer
.
clone
(
)
)
;
}
else
{
let
mapping
=
match
std
:
:
mem
:
:
replace
(
&
mut
*
buffer
.
map_state
.
lock
(
)
resource
:
:
BufferMapState
:
:
Idle
)
{
resource
:
:
BufferMapState
:
:
Waiting
(
pending_mapping
)
=
>
pending_mapping
resource
:
:
BufferMapState
:
:
Idle
=
>
continue
active
resource
:
:
BufferMapState
:
:
Active
{
.
.
}
=
>
{
*
buffer
.
map_state
.
lock
(
)
=
active
;
continue
;
}
_
=
>
panic
!
(
"
No
pending
mapping
.
"
)
}
;
let
status
=
if
mapping
.
range
.
start
!
=
mapping
.
range
.
end
{
log
:
:
debug
!
(
"
Buffer
{
:
?
}
map
state
-
>
Active
"
buffer_id
)
;
let
host
=
mapping
.
op
.
host
;
let
size
=
mapping
.
range
.
end
-
mapping
.
range
.
start
;
match
super
:
:
map_buffer
(
raw
&
buffer
mapping
.
range
.
start
size
host
)
{
Ok
(
ptr
)
=
>
{
*
buffer
.
map_state
.
lock
(
)
=
resource
:
:
BufferMapState
:
:
Active
{
ptr
range
:
mapping
.
range
.
start
.
.
mapping
.
range
.
start
+
size
host
}
;
Ok
(
(
)
)
}
Err
(
e
)
=
>
{
log
:
:
error
!
(
"
Mapping
failed
{
:
?
}
"
e
)
;
Err
(
e
)
}
}
}
else
{
*
buffer
.
map_state
.
lock
(
)
=
resource
:
:
BufferMapState
:
:
Active
{
ptr
:
std
:
:
ptr
:
:
NonNull
:
:
dangling
(
)
range
:
mapping
.
range
host
:
mapping
.
op
.
host
}
;
Ok
(
(
)
)
}
;
pending_callbacks
.
push
(
(
mapping
.
op
status
)
)
;
}
}
pending_callbacks
}
}
