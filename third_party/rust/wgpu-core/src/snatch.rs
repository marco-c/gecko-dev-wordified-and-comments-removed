#
!
[
allow
(
unused
)
]
use
core
:
:
{
cell
:
:
{
Cell
RefCell
UnsafeCell
}
fmt
panic
:
:
{
self
Location
}
}
;
use
std
:
:
{
backtrace
:
:
Backtrace
thread
}
;
use
crate
:
:
lock
:
:
{
rank
RwLock
RwLockReadGuard
RwLockWriteGuard
}
;
pub
struct
SnatchGuard
<
'
a
>
(
RwLockReadGuard
<
'
a
(
)
>
)
;
pub
struct
ExclusiveSnatchGuard
<
'
a
>
(
RwLockWriteGuard
<
'
a
(
)
>
)
;
pub
struct
Snatchable
<
T
>
{
value
:
UnsafeCell
<
Option
<
T
>
>
}
impl
<
T
>
Snatchable
<
T
>
{
pub
fn
new
(
val
:
T
)
-
>
Self
{
Snatchable
{
value
:
UnsafeCell
:
:
new
(
Some
(
val
)
)
}
}
pub
fn
empty
(
)
-
>
Self
{
Snatchable
{
value
:
UnsafeCell
:
:
new
(
None
)
}
}
pub
fn
get
<
'
a
>
(
&
'
a
self
_guard
:
&
'
a
SnatchGuard
)
-
>
Option
<
&
'
a
T
>
{
unsafe
{
(
*
self
.
value
.
get
(
)
)
.
as_ref
(
)
}
}
pub
fn
snatch
(
&
self
_guard
:
&
mut
ExclusiveSnatchGuard
)
-
>
Option
<
T
>
{
unsafe
{
(
*
self
.
value
.
get
(
)
)
.
take
(
)
}
}
pub
fn
take
(
&
mut
self
)
-
>
Option
<
T
>
{
self
.
value
.
get_mut
(
)
.
take
(
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
Snatchable
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
<
snatchable
>
"
)
}
}
unsafe
impl
<
T
>
Sync
for
Snatchable
<
T
>
{
}
struct
LockTrace
{
purpose
:
&
'
static
str
caller
:
&
'
static
Location
<
'
static
>
backtrace
:
Backtrace
}
impl
fmt
:
:
Display
for
LockTrace
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
a
{
}
lock
at
{
}
\
n
{
}
"
self
.
purpose
self
.
caller
self
.
backtrace
)
}
}
#
[
cfg
(
debug_assertions
)
]
impl
LockTrace
{
#
[
track_caller
]
fn
enter
(
purpose
:
&
'
static
str
)
{
let
new
=
LockTrace
{
purpose
caller
:
Location
:
:
caller
(
)
backtrace
:
Backtrace
:
:
capture
(
)
}
;
if
let
Some
(
prev
)
=
SNATCH_LOCK_TRACE
.
take
(
)
{
let
current
=
thread
:
:
current
(
)
;
let
name
=
current
.
name
(
)
.
unwrap_or
(
"
<
unnamed
>
"
)
;
panic
!
(
"
thread
'
{
name
}
'
attempted
to
acquire
a
snatch
lock
recursively
.
\
n
\
-
Currently
trying
to
acquire
{
new
}
\
n
\
-
Previously
acquired
{
prev
}
"
)
;
}
else
{
SNATCH_LOCK_TRACE
.
set
(
Some
(
new
)
)
;
}
}
fn
exit
(
)
{
SNATCH_LOCK_TRACE
.
take
(
)
;
}
}
#
[
cfg
(
not
(
debug_assertions
)
)
]
impl
LockTrace
{
fn
enter
(
purpose
:
&
'
static
str
)
{
}
fn
exit
(
)
{
}
}
std
:
:
thread_local
!
{
static
SNATCH_LOCK_TRACE
:
Cell
<
Option
<
LockTrace
>
>
=
const
{
Cell
:
:
new
(
None
)
}
;
}
pub
struct
SnatchLock
{
lock
:
RwLock
<
(
)
>
}
impl
SnatchLock
{
pub
unsafe
fn
new
(
rank
:
rank
:
:
LockRank
)
-
>
Self
{
SnatchLock
{
lock
:
RwLock
:
:
new
(
rank
(
)
)
}
}
#
[
track_caller
]
pub
fn
read
(
&
self
)
-
>
SnatchGuard
{
LockTrace
:
:
enter
(
"
read
"
)
;
SnatchGuard
(
self
.
lock
.
read
(
)
)
}
#
[
track_caller
]
pub
fn
write
(
&
self
)
-
>
ExclusiveSnatchGuard
{
LockTrace
:
:
enter
(
"
write
"
)
;
ExclusiveSnatchGuard
(
self
.
lock
.
write
(
)
)
}
}
impl
Drop
for
SnatchGuard
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
LockTrace
:
:
exit
(
)
;
}
}
impl
Drop
for
ExclusiveSnatchGuard
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
LockTrace
:
:
exit
(
)
;
}
}
