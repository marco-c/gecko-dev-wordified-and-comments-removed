use
core
:
:
{
cell
:
:
UnsafeCell
fmt
}
;
use
crate
:
:
lock
:
:
{
rank
RwLock
RwLockReadGuard
RwLockWriteGuard
}
;
pub
struct
SnatchGuard
<
'
a
>
(
#
[
expect
(
dead_code
)
]
RwLockReadGuard
<
'
a
(
)
>
)
;
pub
struct
ExclusiveSnatchGuard
<
'
a
>
(
#
[
expect
(
dead_code
)
]
RwLockWriteGuard
<
'
a
(
)
>
)
;
pub
struct
Snatchable
<
T
>
{
value
:
UnsafeCell
<
Option
<
T
>
>
}
impl
<
T
>
Snatchable
<
T
>
{
pub
fn
new
(
val
:
T
)
-
>
Self
{
Snatchable
{
value
:
UnsafeCell
:
:
new
(
Some
(
val
)
)
}
}
#
[
allow
(
dead_code
)
]
pub
fn
empty
(
)
-
>
Self
{
Snatchable
{
value
:
UnsafeCell
:
:
new
(
None
)
}
}
pub
fn
get
<
'
a
>
(
&
'
a
self
_guard
:
&
'
a
SnatchGuard
)
-
>
Option
<
&
'
a
T
>
{
unsafe
{
(
*
self
.
value
.
get
(
)
)
.
as_ref
(
)
}
}
pub
fn
snatch
(
&
self
_guard
:
&
mut
ExclusiveSnatchGuard
)
-
>
Option
<
T
>
{
unsafe
{
(
*
self
.
value
.
get
(
)
)
.
take
(
)
}
}
pub
fn
take
(
&
mut
self
)
-
>
Option
<
T
>
{
self
.
value
.
get_mut
(
)
.
take
(
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
Snatchable
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
<
snatchable
>
"
)
}
}
unsafe
impl
<
T
>
Sync
for
Snatchable
<
T
>
{
}
use
trace
:
:
LockTrace
;
#
[
cfg
(
all
(
debug_assertions
feature
=
"
std
"
)
)
]
mod
trace
{
use
core
:
:
{
cell
:
:
Cell
fmt
panic
:
:
Location
}
;
use
std
:
:
{
backtrace
:
:
Backtrace
thread
}
;
pub
(
super
)
struct
LockTrace
{
purpose
:
&
'
static
str
caller
:
&
'
static
Location
<
'
static
>
backtrace
:
Backtrace
}
impl
fmt
:
:
Display
for
LockTrace
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
a
{
}
lock
at
{
}
\
n
{
}
"
self
.
purpose
self
.
caller
self
.
backtrace
)
}
}
impl
LockTrace
{
#
[
track_caller
]
pub
(
super
)
fn
enter
(
purpose
:
&
'
static
str
)
{
let
new
=
LockTrace
{
purpose
caller
:
Location
:
:
caller
(
)
backtrace
:
Backtrace
:
:
capture
(
)
}
;
if
let
Some
(
prev
)
=
SNATCH_LOCK_TRACE
.
take
(
)
{
let
current
=
thread
:
:
current
(
)
;
let
name
=
current
.
name
(
)
.
unwrap_or
(
"
<
unnamed
>
"
)
;
panic
!
(
"
thread
'
{
name
}
'
attempted
to
acquire
a
snatch
lock
recursively
.
\
n
\
-
Currently
trying
to
acquire
{
new
}
\
n
\
-
Previously
acquired
{
prev
}
"
)
;
}
else
{
SNATCH_LOCK_TRACE
.
set
(
Some
(
new
)
)
;
}
}
pub
(
super
)
fn
exit
(
)
{
SNATCH_LOCK_TRACE
.
take
(
)
;
}
}
std
:
:
thread_local
!
{
static
SNATCH_LOCK_TRACE
:
Cell
<
Option
<
LockTrace
>
>
=
const
{
Cell
:
:
new
(
None
)
}
;
}
}
#
[
cfg
(
not
(
all
(
debug_assertions
feature
=
"
std
"
)
)
)
]
mod
trace
{
pub
(
super
)
struct
LockTrace
{
_private
:
(
)
}
impl
LockTrace
{
pub
(
super
)
fn
enter
(
_purpose
:
&
'
static
str
)
{
}
pub
(
super
)
fn
exit
(
)
{
}
}
}
pub
struct
SnatchLock
{
lock
:
RwLock
<
(
)
>
}
impl
SnatchLock
{
pub
unsafe
fn
new
(
rank
:
rank
:
:
LockRank
)
-
>
Self
{
SnatchLock
{
lock
:
RwLock
:
:
new
(
rank
(
)
)
}
}
#
[
track_caller
]
pub
fn
read
(
&
self
)
-
>
SnatchGuard
{
LockTrace
:
:
enter
(
"
read
"
)
;
SnatchGuard
(
self
.
lock
.
read
(
)
)
}
#
[
track_caller
]
pub
fn
write
(
&
self
)
-
>
ExclusiveSnatchGuard
{
LockTrace
:
:
enter
(
"
write
"
)
;
ExclusiveSnatchGuard
(
self
.
lock
.
write
(
)
)
}
}
impl
Drop
for
SnatchGuard
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
LockTrace
:
:
exit
(
)
;
}
}
impl
Drop
for
ExclusiveSnatchGuard
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
LockTrace
:
:
exit
(
)
;
}
}
