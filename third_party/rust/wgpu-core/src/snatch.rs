#
!
[
allow
(
unused
)
]
use
parking_lot
:
:
{
RwLock
RwLockReadGuard
RwLockWriteGuard
}
;
use
std
:
:
{
backtrace
:
:
Backtrace
cell
:
:
{
Cell
RefCell
UnsafeCell
}
panic
:
:
{
self
Location
}
thread
}
;
pub
struct
SnatchGuard
<
'
a
>
(
RwLockReadGuard
<
'
a
(
)
>
)
;
pub
struct
ExclusiveSnatchGuard
<
'
a
>
(
RwLockWriteGuard
<
'
a
(
)
>
)
;
pub
struct
Snatchable
<
T
>
{
value
:
UnsafeCell
<
Option
<
T
>
>
}
impl
<
T
>
Snatchable
<
T
>
{
pub
fn
new
(
val
:
T
)
-
>
Self
{
Snatchable
{
value
:
UnsafeCell
:
:
new
(
Some
(
val
)
)
}
}
pub
fn
get
(
&
self
_guard
:
&
SnatchGuard
)
-
>
Option
<
&
T
>
{
unsafe
{
(
*
self
.
value
.
get
(
)
)
.
as_ref
(
)
}
}
pub
fn
get_mut
(
&
self
_guard
:
&
mut
ExclusiveSnatchGuard
)
-
>
Option
<
&
mut
T
>
{
unsafe
{
(
*
self
.
value
.
get
(
)
)
.
as_mut
(
)
}
}
pub
fn
snatch
(
&
self
_guard
:
ExclusiveSnatchGuard
)
-
>
Option
<
T
>
{
unsafe
{
(
*
self
.
value
.
get
(
)
)
.
take
(
)
}
}
pub
fn
take
(
&
mut
self
)
-
>
Option
<
T
>
{
self
.
value
.
get_mut
(
)
.
take
(
)
}
}
impl
<
T
>
std
:
:
fmt
:
:
Debug
for
Snatchable
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
<
snatchable
>
"
)
}
}
unsafe
impl
<
T
>
Sync
for
Snatchable
<
T
>
{
}
thread_local
!
{
static
READ_LOCK_LOCATION
:
Cell
<
Option
<
(
&
'
static
Location
<
'
static
>
Backtrace
)
>
>
=
const
{
Cell
:
:
new
(
None
)
}
;
}
pub
struct
SnatchLock
{
lock
:
RwLock
<
(
)
>
}
impl
SnatchLock
{
pub
unsafe
fn
new
(
)
-
>
Self
{
SnatchLock
{
lock
:
RwLock
:
:
new
(
(
)
)
}
}
#
[
track_caller
]
pub
fn
read
(
&
self
)
-
>
SnatchGuard
{
if
cfg
!
(
debug_assertions
)
{
let
caller
=
Location
:
:
caller
(
)
;
let
backtrace
=
Backtrace
:
:
capture
(
)
;
if
let
Some
(
(
prev
bt
)
)
=
READ_LOCK_LOCATION
.
take
(
)
{
let
current
=
thread
:
:
current
(
)
;
let
name
=
current
.
name
(
)
.
unwrap_or
(
"
<
unnamed
>
"
)
;
panic
!
(
"
thread
'
{
name
}
'
attempted
to
acquire
a
snatch
read
lock
recursively
.
\
n
-
{
prev
}
\
n
{
bt
}
\
n
-
{
caller
}
\
n
{
backtrace
}
"
)
;
}
else
{
READ_LOCK_LOCATION
.
set
(
Some
(
(
caller
backtrace
)
)
)
;
}
}
SnatchGuard
(
self
.
lock
.
read
(
)
)
}
pub
fn
write
(
&
self
)
-
>
ExclusiveSnatchGuard
{
ExclusiveSnatchGuard
(
self
.
lock
.
write
(
)
)
}
}
impl
Drop
for
SnatchGuard
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
#
[
cfg
(
debug_assertions
)
]
READ_LOCK_LOCATION
.
take
(
)
;
}
}
