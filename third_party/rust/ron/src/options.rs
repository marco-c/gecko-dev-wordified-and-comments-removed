use
std
:
:
io
;
use
serde
:
:
{
de
ser
}
;
use
serde_derive
:
:
{
Deserialize
Serialize
}
;
use
crate
:
:
{
de
:
:
Deserializer
error
:
:
{
Result
SpannedResult
}
extensions
:
:
Extensions
ser
:
:
{
PrettyConfig
Serializer
}
}
;
#
[
derive
(
Clone
Debug
Serialize
Deserialize
)
]
#
[
serde
(
default
)
]
#
[
non_exhaustive
]
pub
struct
Options
{
pub
default_extensions
:
Extensions
pub
recursion_limit
:
Option
<
usize
>
}
impl
Default
for
Options
{
fn
default
(
)
-
>
Self
{
Self
{
default_extensions
:
Extensions
:
:
empty
(
)
recursion_limit
:
Some
(
128
)
}
}
}
impl
Options
{
#
[
must_use
]
pub
fn
with_default_extension
(
mut
self
default_extension
:
Extensions
)
-
>
Self
{
self
.
default_extensions
|
=
default_extension
;
self
}
#
[
must_use
]
pub
fn
without_default_extension
(
mut
self
default_extension
:
Extensions
)
-
>
Self
{
self
.
default_extensions
&
=
!
default_extension
;
self
}
#
[
must_use
]
pub
fn
with_recursion_limit
(
mut
self
recursion_limit
:
usize
)
-
>
Self
{
self
.
recursion_limit
=
Some
(
recursion_limit
)
;
self
}
#
[
must_use
]
pub
fn
without_recursion_limit
(
mut
self
)
-
>
Self
{
self
.
recursion_limit
=
None
;
self
}
}
impl
Options
{
pub
fn
from_reader
<
R
T
>
(
&
self
mut
rdr
:
R
)
-
>
SpannedResult
<
T
>
where
R
:
io
:
:
Read
T
:
de
:
:
DeserializeOwned
{
let
mut
bytes
=
Vec
:
:
new
(
)
;
rdr
.
read_to_end
(
&
mut
bytes
)
?
;
self
.
from_bytes
(
&
bytes
)
}
pub
fn
from_str
<
'
a
T
>
(
&
self
s
:
&
'
a
str
)
-
>
SpannedResult
<
T
>
where
T
:
de
:
:
Deserialize
<
'
a
>
{
self
.
from_bytes
(
s
.
as_bytes
(
)
)
}
pub
fn
from_bytes
<
'
a
T
>
(
&
self
s
:
&
'
a
[
u8
]
)
-
>
SpannedResult
<
T
>
where
T
:
de
:
:
Deserialize
<
'
a
>
{
self
.
from_bytes_seed
(
s
std
:
:
marker
:
:
PhantomData
)
}
pub
fn
from_reader_seed
<
R
S
T
>
(
&
self
mut
rdr
:
R
seed
:
S
)
-
>
SpannedResult
<
T
>
where
R
:
io
:
:
Read
S
:
for
<
'
a
>
de
:
:
DeserializeSeed
<
'
a
Value
=
T
>
{
let
mut
bytes
=
Vec
:
:
new
(
)
;
rdr
.
read_to_end
(
&
mut
bytes
)
?
;
self
.
from_bytes_seed
(
&
bytes
seed
)
}
pub
fn
from_str_seed
<
'
a
S
T
>
(
&
self
s
:
&
'
a
str
seed
:
S
)
-
>
SpannedResult
<
T
>
where
S
:
de
:
:
DeserializeSeed
<
'
a
Value
=
T
>
{
self
.
from_bytes_seed
(
s
.
as_bytes
(
)
seed
)
}
pub
fn
from_bytes_seed
<
'
a
S
T
>
(
&
self
s
:
&
'
a
[
u8
]
seed
:
S
)
-
>
SpannedResult
<
T
>
where
S
:
de
:
:
DeserializeSeed
<
'
a
Value
=
T
>
{
let
mut
deserializer
=
Deserializer
:
:
from_bytes_with_options
(
s
self
.
clone
(
)
)
?
;
let
value
=
seed
.
deserialize
(
&
mut
deserializer
)
.
map_err
(
|
e
|
deserializer
.
span_error
(
e
)
)
?
;
deserializer
.
end
(
)
.
map_err
(
|
e
|
deserializer
.
span_error
(
e
)
)
?
;
Ok
(
value
)
}
pub
fn
to_writer
<
W
T
>
(
&
self
writer
:
W
value
:
&
T
)
-
>
Result
<
(
)
>
where
W
:
io
:
:
Write
T
:
?
Sized
+
ser
:
:
Serialize
{
let
mut
s
=
Serializer
:
:
with_options
(
writer
None
self
.
clone
(
)
)
?
;
value
.
serialize
(
&
mut
s
)
}
pub
fn
to_writer_pretty
<
W
T
>
(
&
self
writer
:
W
value
:
&
T
config
:
PrettyConfig
)
-
>
Result
<
(
)
>
where
W
:
io
:
:
Write
T
:
?
Sized
+
ser
:
:
Serialize
{
let
mut
s
=
Serializer
:
:
with_options
(
writer
Some
(
config
)
self
.
clone
(
)
)
?
;
value
.
serialize
(
&
mut
s
)
}
pub
fn
to_string
<
T
>
(
&
self
value
:
&
T
)
-
>
Result
<
String
>
where
T
:
?
Sized
+
ser
:
:
Serialize
{
let
mut
output
=
Vec
:
:
new
(
)
;
let
mut
s
=
Serializer
:
:
with_options
(
&
mut
output
None
self
.
clone
(
)
)
?
;
value
.
serialize
(
&
mut
s
)
?
;
Ok
(
String
:
:
from_utf8
(
output
)
.
expect
(
"
Ron
should
be
utf
-
8
"
)
)
}
pub
fn
to_string_pretty
<
T
>
(
&
self
value
:
&
T
config
:
PrettyConfig
)
-
>
Result
<
String
>
where
T
:
?
Sized
+
ser
:
:
Serialize
{
let
mut
output
=
Vec
:
:
new
(
)
;
let
mut
s
=
Serializer
:
:
with_options
(
&
mut
output
Some
(
config
)
self
.
clone
(
)
)
?
;
value
.
serialize
(
&
mut
s
)
?
;
Ok
(
String
:
:
from_utf8
(
output
)
.
expect
(
"
Ron
should
be
utf
-
8
"
)
)
}
}
