use
alloc
:
:
string
:
:
String
;
use
core
:
:
fmt
;
use
serde
:
:
{
de
ser
}
;
use
serde_derive
:
:
{
Deserialize
Serialize
}
;
use
crate
:
:
{
de
:
:
Deserializer
error
:
:
{
Result
SpannedResult
}
extensions
:
:
Extensions
ser
:
:
{
PrettyConfig
Serializer
}
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
{
crate
:
:
error
:
:
{
Position
Span
SpannedError
}
alloc
:
:
vec
:
:
Vec
std
:
:
io
}
;
#
[
derive
(
Clone
Debug
Serialize
Deserialize
)
]
#
[
serde
(
default
)
]
#
[
non_exhaustive
]
pub
struct
Options
{
pub
default_extensions
:
Extensions
pub
recursion_limit
:
Option
<
usize
>
}
impl
Default
for
Options
{
fn
default
(
)
-
>
Self
{
Self
{
default_extensions
:
Extensions
:
:
empty
(
)
recursion_limit
:
Some
(
128
)
}
}
}
impl
Options
{
#
[
must_use
]
pub
fn
with_default_extension
(
mut
self
default_extension
:
Extensions
)
-
>
Self
{
self
.
default_extensions
|
=
default_extension
;
self
}
#
[
must_use
]
pub
fn
without_default_extension
(
mut
self
default_extension
:
Extensions
)
-
>
Self
{
self
.
default_extensions
&
=
!
default_extension
;
self
}
#
[
must_use
]
pub
fn
with_recursion_limit
(
mut
self
recursion_limit
:
usize
)
-
>
Self
{
self
.
recursion_limit
=
Some
(
recursion_limit
)
;
self
}
#
[
must_use
]
pub
fn
without_recursion_limit
(
mut
self
)
-
>
Self
{
self
.
recursion_limit
=
None
;
self
}
}
impl
Options
{
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
from_reader
<
R
T
>
(
&
self
rdr
:
R
)
-
>
SpannedResult
<
T
>
where
R
:
io
:
:
Read
T
:
de
:
:
DeserializeOwned
{
self
.
from_reader_seed
(
rdr
core
:
:
marker
:
:
PhantomData
)
}
pub
fn
from_str
<
'
a
T
>
(
&
self
s
:
&
'
a
str
)
-
>
SpannedResult
<
T
>
where
T
:
de
:
:
Deserialize
<
'
a
>
{
self
.
from_str_seed
(
s
core
:
:
marker
:
:
PhantomData
)
}
pub
fn
from_bytes
<
'
a
T
>
(
&
self
s
:
&
'
a
[
u8
]
)
-
>
SpannedResult
<
T
>
where
T
:
de
:
:
Deserialize
<
'
a
>
{
self
.
from_bytes_seed
(
s
core
:
:
marker
:
:
PhantomData
)
}
#
[
allow
(
clippy
:
:
missing_panics_doc
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
from_reader_seed
<
R
S
T
>
(
&
self
mut
rdr
:
R
seed
:
S
)
-
>
SpannedResult
<
T
>
where
R
:
io
:
:
Read
S
:
for
<
'
a
>
de
:
:
DeserializeSeed
<
'
a
Value
=
T
>
{
let
mut
bytes
=
Vec
:
:
new
(
)
;
let
io_err
=
if
let
Err
(
err
)
=
rdr
.
read_to_end
(
&
mut
bytes
)
{
err
}
else
{
return
self
.
from_bytes_seed
(
&
bytes
seed
)
;
}
;
#
[
allow
(
clippy
:
:
expect_used
)
]
let
valid_input
=
match
core
:
:
str
:
:
from_utf8
(
&
bytes
)
{
Ok
(
valid_input
)
=
>
valid_input
Err
(
err
)
=
>
core
:
:
str
:
:
from_utf8
(
&
bytes
[
.
.
err
.
valid_up_to
(
)
]
)
.
expect
(
"
source
is
valid
up
to
error
"
)
}
;
Err
(
SpannedError
{
code
:
io_err
.
into
(
)
span
:
Span
{
start
:
Position
{
line
:
1
col
:
1
}
end
:
Position
:
:
from_src_end
(
valid_input
)
}
}
)
}
pub
fn
from_str_seed
<
'
a
S
T
>
(
&
self
s
:
&
'
a
str
seed
:
S
)
-
>
SpannedResult
<
T
>
where
S
:
de
:
:
DeserializeSeed
<
'
a
Value
=
T
>
{
let
mut
deserializer
=
Deserializer
:
:
from_str_with_options
(
s
self
)
?
;
let
value
=
seed
.
deserialize
(
&
mut
deserializer
)
.
map_err
(
|
e
|
deserializer
.
span_error
(
e
)
)
?
;
deserializer
.
end
(
)
.
map_err
(
|
e
|
deserializer
.
span_error
(
e
)
)
?
;
Ok
(
value
)
}
pub
fn
from_bytes_seed
<
'
a
S
T
>
(
&
self
s
:
&
'
a
[
u8
]
seed
:
S
)
-
>
SpannedResult
<
T
>
where
S
:
de
:
:
DeserializeSeed
<
'
a
Value
=
T
>
{
let
mut
deserializer
=
Deserializer
:
:
from_bytes_with_options
(
s
self
)
?
;
let
value
=
seed
.
deserialize
(
&
mut
deserializer
)
.
map_err
(
|
e
|
deserializer
.
span_error
(
e
)
)
?
;
deserializer
.
end
(
)
.
map_err
(
|
e
|
deserializer
.
span_error
(
e
)
)
?
;
Ok
(
value
)
}
pub
fn
to_writer
<
W
T
>
(
&
self
writer
:
W
value
:
&
T
)
-
>
Result
<
(
)
>
where
W
:
fmt
:
:
Write
T
:
?
Sized
+
ser
:
:
Serialize
{
let
mut
s
=
Serializer
:
:
with_options
(
writer
None
self
)
?
;
value
.
serialize
(
&
mut
s
)
}
pub
fn
to_writer_pretty
<
W
T
>
(
&
self
writer
:
W
value
:
&
T
config
:
PrettyConfig
)
-
>
Result
<
(
)
>
where
W
:
fmt
:
:
Write
T
:
?
Sized
+
ser
:
:
Serialize
{
let
mut
s
=
Serializer
:
:
with_options
(
writer
Some
(
config
)
self
)
?
;
value
.
serialize
(
&
mut
s
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
to_io_writer
<
W
T
>
(
&
self
writer
:
W
value
:
&
T
)
-
>
Result
<
(
)
>
where
W
:
io
:
:
Write
T
:
?
Sized
+
ser
:
:
Serialize
{
let
mut
adapter
=
Adapter
{
writer
error
:
Ok
(
(
)
)
}
;
let
result
=
self
.
to_writer
(
&
mut
adapter
value
)
;
adapter
.
error
?
;
result
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
to_io_writer_pretty
<
W
T
>
(
&
self
writer
:
W
value
:
&
T
config
:
PrettyConfig
)
-
>
Result
<
(
)
>
where
W
:
io
:
:
Write
T
:
?
Sized
+
ser
:
:
Serialize
{
let
mut
adapter
=
Adapter
{
writer
error
:
Ok
(
(
)
)
}
;
let
result
=
self
.
to_writer_pretty
(
&
mut
adapter
value
config
)
;
adapter
.
error
?
;
result
}
pub
fn
to_string
<
T
>
(
&
self
value
:
&
T
)
-
>
Result
<
String
>
where
T
:
?
Sized
+
ser
:
:
Serialize
{
let
mut
output
=
String
:
:
new
(
)
;
let
mut
s
=
Serializer
:
:
with_options
(
&
mut
output
None
self
)
?
;
value
.
serialize
(
&
mut
s
)
?
;
Ok
(
output
)
}
pub
fn
to_string_pretty
<
T
>
(
&
self
value
:
&
T
config
:
PrettyConfig
)
-
>
Result
<
String
>
where
T
:
?
Sized
+
ser
:
:
Serialize
{
let
mut
output
=
String
:
:
new
(
)
;
let
mut
s
=
Serializer
:
:
with_options
(
&
mut
output
Some
(
config
)
self
)
?
;
value
.
serialize
(
&
mut
s
)
?
;
Ok
(
output
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
struct
Adapter
<
W
:
io
:
:
Write
>
{
writer
:
W
error
:
io
:
:
Result
<
(
)
>
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
T
:
io
:
:
Write
>
fmt
:
:
Write
for
Adapter
<
T
>
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
fmt
:
:
Result
{
match
self
.
writer
.
write_all
(
s
.
as_bytes
(
)
)
{
Ok
(
(
)
)
=
>
Ok
(
(
)
)
Err
(
e
)
=
>
{
self
.
error
=
Err
(
e
)
;
Err
(
fmt
:
:
Error
)
}
}
}
}
