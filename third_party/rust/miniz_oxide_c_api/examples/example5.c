#
define
MINIZ_NO_STDIO
#
define
MINIZ_NO_ARCHIVE_APIS
#
define
MINIZ_NO_TIME
#
define
MINIZ_NO_ZLIB_APIS
#
define
MINIZ_NO_MALLOC
#
include
"
miniz
.
h
"
#
include
<
stdio
.
h
>
#
include
<
limits
.
h
>
typedef
unsigned
char
uint8
;
typedef
unsigned
short
uint16
;
typedef
unsigned
int
uint
;
#
define
my_max
(
a
b
)
(
(
(
a
)
>
(
b
)
)
?
(
a
)
:
(
b
)
)
#
define
my_min
(
a
b
)
(
(
(
a
)
<
(
b
)
)
?
(
a
)
:
(
b
)
)
#
define
IN_BUF_SIZE
(
1024
*
512
)
static
uint8
s_inbuf
[
IN_BUF_SIZE
]
;
#
define
COMP_OUT_BUF_SIZE
(
1024
*
512
)
#
define
OUT_BUF_SIZE
(
1024
*
512
)
static
uint8
s_outbuf
[
OUT_BUF_SIZE
]
;
tdefl_compressor
g_deflator
;
int
main
(
int
argc
char
*
argv
[
]
)
{
const
char
*
pMode
;
FILE
*
pInfile
*
pOutfile
;
uint
infile_size
;
int
level
=
9
;
int
p
=
1
;
const
char
*
pSrc_filename
;
const
char
*
pDst_filename
;
const
void
*
next_in
=
s_inbuf
;
size_t
avail_in
=
0
;
void
*
next_out
=
s_outbuf
;
size_t
avail_out
=
OUT_BUF_SIZE
;
size_t
total_in
=
0
total_out
=
0
;
long
file_loc
;
assert
(
COMP_OUT_BUF_SIZE
<
=
OUT_BUF_SIZE
)
;
printf
(
"
miniz
.
c
example5
(
demonstrates
tinfl
/
tdefl
)
\
n
"
)
;
if
(
argc
<
4
)
{
printf
(
"
File
to
file
compression
/
decompression
using
the
low
-
level
tinfl
/
tdefl
API
'
s
.
\
n
"
)
;
printf
(
"
Usage
:
example5
[
options
]
[
mode
:
c
or
d
]
infile
outfile
\
n
"
)
;
printf
(
"
\
nModes
:
\
n
"
)
;
printf
(
"
c
-
Compresses
file
infile
to
a
zlib
stream
in
file
outfile
\
n
"
)
;
printf
(
"
d
-
Decompress
zlib
stream
in
file
infile
to
file
outfile
\
n
"
)
;
printf
(
"
\
nOptions
:
\
n
"
)
;
printf
(
"
-
l
[
0
-
10
]
-
Compression
level
higher
values
are
slower
0
is
none
.
\
n
"
)
;
return
EXIT_FAILURE
;
}
while
(
(
p
<
argc
)
&
&
(
argv
[
p
]
[
0
]
=
=
'
-
'
)
)
{
switch
(
argv
[
p
]
[
1
]
)
{
case
'
l
'
:
{
level
=
atoi
(
&
argv
[
1
]
[
2
]
)
;
if
(
(
level
<
0
)
|
|
(
level
>
10
)
)
{
printf
(
"
Invalid
level
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
break
;
}
default
:
{
printf
(
"
Invalid
option
:
%
s
\
n
"
argv
[
p
]
)
;
return
EXIT_FAILURE
;
}
}
p
+
+
;
}
if
(
(
argc
-
p
)
<
3
)
{
printf
(
"
Must
specify
mode
input
filename
and
output
filename
after
options
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
else
if
(
(
argc
-
p
)
>
3
)
{
printf
(
"
Too
many
filenames
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
pMode
=
argv
[
p
+
+
]
;
if
(
!
strchr
(
"
cCdD
"
pMode
[
0
]
)
)
{
printf
(
"
Invalid
mode
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
pSrc_filename
=
argv
[
p
+
+
]
;
pDst_filename
=
argv
[
p
+
+
]
;
printf
(
"
Mode
:
%
c
Level
:
%
u
\
nInput
File
:
\
"
%
s
\
"
\
nOutput
File
:
\
"
%
s
\
"
\
n
"
pMode
[
0
]
level
pSrc_filename
pDst_filename
)
;
pInfile
=
fopen
(
pSrc_filename
"
rb
"
)
;
if
(
!
pInfile
)
{
printf
(
"
Failed
opening
input
file
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
fseek
(
pInfile
0
SEEK_END
)
;
file_loc
=
ftell
(
pInfile
)
;
fseek
(
pInfile
0
SEEK_SET
)
;
if
(
(
file_loc
<
0
)
|
|
(
file_loc
>
INT_MAX
)
)
{
printf
(
"
File
is
too
large
to
be
processed
by
this
example
.
\
n
"
)
;
return
EXIT_FAILURE
;
}
infile_size
=
(
uint
)
file_loc
;
pOutfile
=
fopen
(
pDst_filename
"
wb
"
)
;
if
(
!
pOutfile
)
{
printf
(
"
Failed
opening
output
file
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
printf
(
"
Input
file
size
:
%
u
\
n
"
infile_size
)
;
if
(
(
pMode
[
0
]
=
=
'
c
'
)
|
|
(
pMode
[
0
]
=
=
'
C
'
)
)
{
static
const
mz_uint
s_tdefl_num_probes
[
11
]
=
{
0
1
6
32
16
32
128
256
512
768
1500
}
;
tdefl_status
status
;
uint
infile_remaining
=
infile_size
;
mz_uint
comp_flags
=
TDEFL_WRITE_ZLIB_HEADER
|
s_tdefl_num_probes
[
MZ_MIN
(
10
level
)
]
|
(
(
level
<
=
3
)
?
TDEFL_GREEDY_PARSING_FLAG
:
0
)
;
if
(
!
level
)
comp_flags
|
=
TDEFL_FORCE_ALL_RAW_BLOCKS
;
status
=
tdefl_init
(
&
g_deflator
NULL
NULL
comp_flags
)
;
if
(
status
!
=
TDEFL_STATUS_OKAY
)
{
printf
(
"
tdefl_init
(
)
failed
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
avail_out
=
COMP_OUT_BUF_SIZE
;
for
(
;
;
)
{
size_t
in_bytes
out_bytes
;
if
(
!
avail_in
)
{
uint
n
=
my_min
(
IN_BUF_SIZE
infile_remaining
)
;
if
(
fread
(
s_inbuf
1
n
pInfile
)
!
=
n
)
{
printf
(
"
Failed
reading
from
input
file
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
next_in
=
s_inbuf
;
avail_in
=
n
;
infile_remaining
-
=
n
;
}
in_bytes
=
avail_in
;
out_bytes
=
avail_out
;
status
=
tdefl_compress
(
&
g_deflator
next_in
&
in_bytes
next_out
&
out_bytes
infile_remaining
?
TDEFL_NO_FLUSH
:
TDEFL_FINISH
)
;
next_in
=
(
const
char
*
)
next_in
+
in_bytes
;
avail_in
-
=
in_bytes
;
total_in
+
=
in_bytes
;
next_out
=
(
char
*
)
next_out
+
out_bytes
;
avail_out
-
=
out_bytes
;
total_out
+
=
out_bytes
;
if
(
(
status
!
=
TDEFL_STATUS_OKAY
)
|
|
(
!
avail_out
)
)
{
uint
n
=
COMP_OUT_BUF_SIZE
-
(
uint
)
avail_out
;
if
(
fwrite
(
s_outbuf
1
n
pOutfile
)
!
=
n
)
{
printf
(
"
Failed
writing
to
output
file
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
next_out
=
s_outbuf
;
avail_out
=
COMP_OUT_BUF_SIZE
;
}
if
(
status
=
=
TDEFL_STATUS_DONE
)
{
break
;
}
else
if
(
status
!
=
TDEFL_STATUS_OKAY
)
{
printf
(
"
tdefl_compress
(
)
failed
with
status
%
i
!
\
n
"
status
)
;
return
EXIT_FAILURE
;
}
}
}
else
if
(
(
pMode
[
0
]
=
=
'
d
'
)
|
|
(
pMode
[
0
]
=
=
'
D
'
)
)
{
uint
infile_remaining
=
infile_size
;
tinfl_decompressor
inflator
;
tinfl_init
(
&
inflator
)
;
for
(
;
;
)
{
size_t
in_bytes
out_bytes
;
tinfl_status
status
;
if
(
!
avail_in
)
{
uint
n
=
my_min
(
IN_BUF_SIZE
infile_remaining
)
;
if
(
fread
(
s_inbuf
1
n
pInfile
)
!
=
n
)
{
printf
(
"
Failed
reading
from
input
file
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
next_in
=
s_inbuf
;
avail_in
=
n
;
infile_remaining
-
=
n
;
}
in_bytes
=
avail_in
;
out_bytes
=
avail_out
;
status
=
tinfl_decompress
(
&
inflator
(
const
mz_uint8
*
)
next_in
&
in_bytes
s_outbuf
(
mz_uint8
*
)
next_out
&
out_bytes
(
infile_remaining
?
TINFL_FLAG_HAS_MORE_INPUT
:
0
)
|
TINFL_FLAG_PARSE_ZLIB_HEADER
)
;
avail_in
-
=
in_bytes
;
next_in
=
(
const
mz_uint8
*
)
next_in
+
in_bytes
;
total_in
+
=
in_bytes
;
avail_out
-
=
out_bytes
;
next_out
=
(
mz_uint8
*
)
next_out
+
out_bytes
;
total_out
+
=
out_bytes
;
if
(
(
status
<
=
TINFL_STATUS_DONE
)
|
|
(
!
avail_out
)
)
{
uint
n
=
OUT_BUF_SIZE
-
(
uint
)
avail_out
;
if
(
fwrite
(
s_outbuf
1
n
pOutfile
)
!
=
n
)
{
printf
(
"
Failed
writing
to
output
file
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
next_out
=
s_outbuf
;
avail_out
=
OUT_BUF_SIZE
;
}
if
(
status
<
=
TINFL_STATUS_DONE
)
{
if
(
status
=
=
TINFL_STATUS_DONE
)
{
break
;
}
else
{
printf
(
"
tinfl_decompress
(
)
failed
with
status
%
i
!
\
n
"
status
)
;
return
EXIT_FAILURE
;
}
}
}
}
else
{
printf
(
"
Invalid
mode
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
fclose
(
pInfile
)
;
if
(
EOF
=
=
fclose
(
pOutfile
)
)
{
printf
(
"
Failed
writing
to
output
file
!
\
n
"
)
;
return
EXIT_FAILURE
;
}
printf
(
"
Total
input
bytes
:
%
u
\
n
"
(
mz_uint32
)
total_in
)
;
printf
(
"
Total
output
bytes
:
%
u
\
n
"
(
mz_uint32
)
total_out
)
;
printf
(
"
Success
.
\
n
"
)
;
return
EXIT_SUCCESS
;
}
