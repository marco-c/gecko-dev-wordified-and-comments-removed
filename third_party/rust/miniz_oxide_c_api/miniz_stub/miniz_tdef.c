#
include
"
.
.
/
miniz_tdef
.
h
"
#
include
"
.
.
/
miniz
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
typedef
struct
{
mz_uint16
m_key
m_sym_index
;
}
tdefl_sym_freq
;
tdefl_sym_freq
*
tdefl_radix_sort_syms
(
mz_uint
num_syms
tdefl_sym_freq
*
pSyms0
tdefl_sym_freq
*
pSyms1
)
;
void
tdefl_calculate_minimum_redundancy
(
tdefl_sym_freq
*
A
int
n
)
;
enum
{
TDEFL_MAX_SUPPORTED_HUFF_CODESIZE
=
32
}
;
void
tdefl_huffman_enforce_max_code_size
(
int
*
pNum_codes
int
code_list_len
int
max_code_size
)
;
void
tdefl_optimize_huffman_table
(
tdefl_compressor
*
d
int
table_num
int
table_len
int
code_size_limit
int
static_table
)
;
void
tdefl_start_dynamic_block
(
tdefl_compressor
*
d
)
;
void
tdefl_start_static_block
(
tdefl_compressor
*
d
)
;
mz_bool
tdefl_compress_lz_codes
(
tdefl_compressor
*
d
)
;
mz_bool
tdefl_compress_block
(
tdefl_compressor
*
d
mz_bool
static_block
)
;
int
tdefl_flush_block
(
tdefl_compressor
*
d
int
flush
)
;
void
tdefl_find_match
(
tdefl_compressor
*
d
mz_uint
lookahead_pos
mz_uint
max_dist
mz_uint
max_match_len
mz_uint
*
pMatch_dist
mz_uint
*
pMatch_len
)
;
#
if
MINIZ_USE_UNALIGNED_LOADS_AND_STORES
#
ifdef
MINIZ_UNALIGNED_USE_MEMCPY
static
inline
mz_uint16
TDEFL_READ_UNALIGNED_WORD
(
const
mz_uint8
*
p
)
{
mz_uint16
ret
;
memcpy
(
&
ret
p
sizeof
(
mz_uint16
)
)
;
return
ret
;
}
static
inline
mz_uint16
TDEFL_READ_UNALIGNED_WORD2
(
const
mz_uint16
*
p
)
{
mz_uint16
ret
;
memcpy
(
&
ret
p
sizeof
(
mz_uint16
)
)
;
return
ret
;
}
#
else
#
define
TDEFL_READ_UNALIGNED_WORD
(
p
)
*
(
const
mz_uint16
*
)
(
p
)
#
define
TDEFL_READ_UNALIGNED_WORD2
(
p
)
*
(
const
mz_uint16
*
)
(
p
)
#
endif
#
endif
void
tdefl_record_literal
(
tdefl_compressor
*
d
mz_uint8
lit
)
;
void
tdefl_record_match
(
tdefl_compressor
*
d
mz_uint
match_len
mz_uint
match_dist
)
;
mz_bool
tdefl_compress_normal
(
tdefl_compressor
*
d
)
;
tdefl_status
tdefl_flush_output_buffer
(
tdefl_compressor
*
d
)
;
tdefl_status
tdefl_compress
(
tdefl_compressor
*
d
const
void
*
pIn_buf
size_t
*
pIn_buf_size
void
*
pOut_buf
size_t
*
pOut_buf_size
tdefl_flush
flush
)
;
tdefl_status
tdefl_compress_buffer
(
tdefl_compressor
*
d
const
void
*
pIn_buf
size_t
in_buf_size
tdefl_flush
flush
)
;
tdefl_status
tdefl_init
(
tdefl_compressor
*
d
tdefl_put_buf_func_ptr
pPut_buf_func
void
*
pPut_buf_user
int
flags
)
;
tdefl_status
tdefl_get_prev_return_status
(
tdefl_compressor
*
d
)
;
mz_uint32
tdefl_get_adler32
(
tdefl_compressor
*
d
)
;
mz_bool
tdefl_compress_mem_to_output
(
const
void
*
pBuf
size_t
buf_len
tdefl_put_buf_func_ptr
pPut_buf_func
void
*
pPut_buf_user
int
flags
)
;
typedef
struct
{
size_t
m_size
m_capacity
;
mz_uint8
*
m_pBuf
;
mz_bool
m_expandable
;
}
tdefl_output_buffer
;
static
mz_bool
tdefl_output_buffer_putter
(
const
void
*
pBuf
int
len
void
*
pUser
)
{
tdefl_output_buffer
*
p
=
(
tdefl_output_buffer
*
)
pUser
;
size_t
new_size
=
p
-
>
m_size
+
len
;
if
(
new_size
>
p
-
>
m_capacity
)
{
size_t
new_capacity
=
p
-
>
m_capacity
;
mz_uint8
*
pNew_buf
;
if
(
!
p
-
>
m_expandable
)
return
MZ_FALSE
;
do
{
new_capacity
=
MZ_MAX
(
128U
new_capacity
<
<
1U
)
;
}
while
(
new_size
>
new_capacity
)
;
pNew_buf
=
(
mz_uint8
*
)
MZ_REALLOC
(
p
-
>
m_pBuf
new_capacity
)
;
if
(
!
pNew_buf
)
return
MZ_FALSE
;
p
-
>
m_pBuf
=
pNew_buf
;
p
-
>
m_capacity
=
new_capacity
;
}
memcpy
(
(
mz_uint8
*
)
p
-
>
m_pBuf
+
p
-
>
m_size
pBuf
len
)
;
p
-
>
m_size
=
new_size
;
return
MZ_TRUE
;
}
void
*
tdefl_compress_mem_to_heap
(
const
void
*
pSrc_buf
size_t
src_buf_len
size_t
*
pOut_len
int
flags
)
;
size_t
tdefl_compress_mem_to_mem
(
void
*
pOut_buf
size_t
out_buf_len
const
void
*
pSrc_buf
size_t
src_buf_len
int
flags
)
;
#
ifdef
_MSC_VER
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4204
)
/
*
nonstandard
extension
used
:
non
-
constant
aggregate
initializer
(
also
supported
by
GNU
C
and
C99
so
no
big
deal
)
*
/
#
endif
void
*
tdefl_write_image_to_png_file_in_memory_ex
(
const
void
*
pImage
int
w
int
h
int
num_chans
size_t
*
pLen_out
mz_uint
level
mz_bool
flip
)
{
static
const
mz_uint
s_tdefl_png_num_probes
[
11
]
=
{
0
1
6
32
16
32
128
256
512
768
1500
}
;
tdefl_compressor
*
pComp
=
(
tdefl_compressor
*
)
MZ_MALLOC
(
sizeof
(
tdefl_compressor
)
)
;
tdefl_output_buffer
out_buf
;
int
i
bpl
=
w
*
num_chans
y
z
;
mz_uint32
c
;
*
pLen_out
=
0
;
if
(
!
pComp
)
return
NULL
;
MZ_CLEAR_OBJ
(
out_buf
)
;
out_buf
.
m_expandable
=
MZ_TRUE
;
out_buf
.
m_capacity
=
57
+
MZ_MAX
(
64
(
1
+
bpl
)
*
h
)
;
if
(
NULL
=
=
(
out_buf
.
m_pBuf
=
(
mz_uint8
*
)
MZ_MALLOC
(
out_buf
.
m_capacity
)
)
)
{
MZ_FREE
(
pComp
)
;
return
NULL
;
}
for
(
z
=
41
;
z
;
-
-
z
)
tdefl_output_buffer_putter
(
&
z
1
&
out_buf
)
;
tdefl_init
(
pComp
tdefl_output_buffer_putter
&
out_buf
s_tdefl_png_num_probes
[
MZ_MIN
(
10
level
)
]
|
TDEFL_WRITE_ZLIB_HEADER
)
;
for
(
y
=
0
;
y
<
h
;
+
+
y
)
{
tdefl_compress_buffer
(
pComp
&
z
1
TDEFL_NO_FLUSH
)
;
tdefl_compress_buffer
(
pComp
(
mz_uint8
*
)
pImage
+
(
flip
?
(
h
-
1
-
y
)
:
y
)
*
bpl
bpl
TDEFL_NO_FLUSH
)
;
}
if
(
tdefl_compress_buffer
(
pComp
NULL
0
TDEFL_FINISH
)
!
=
TDEFL_STATUS_DONE
)
{
MZ_FREE
(
pComp
)
;
MZ_FREE
(
out_buf
.
m_pBuf
)
;
return
NULL
;
}
*
pLen_out
=
out_buf
.
m_size
-
41
;
{
static
const
mz_uint8
chans
[
]
=
{
0x00
0x00
0x04
0x02
0x06
}
;
mz_uint8
pnghdr
[
41
]
=
{
0x89
0x50
0x4e
0x47
0x0d
0x0a
0x1a
0x0a
0x00
0x00
0x00
0x0d
0x49
0x48
0x44
0x52
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x08
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x49
0x44
0x41
0x54
}
;
pnghdr
[
18
]
=
(
mz_uint8
)
(
w
>
>
8
)
;
pnghdr
[
19
]
=
(
mz_uint8
)
w
;
pnghdr
[
22
]
=
(
mz_uint8
)
(
h
>
>
8
)
;
pnghdr
[
23
]
=
(
mz_uint8
)
h
;
pnghdr
[
25
]
=
chans
[
num_chans
]
;
pnghdr
[
33
]
=
(
mz_uint8
)
(
*
pLen_out
>
>
24
)
;
pnghdr
[
34
]
=
(
mz_uint8
)
(
*
pLen_out
>
>
16
)
;
pnghdr
[
35
]
=
(
mz_uint8
)
(
*
pLen_out
>
>
8
)
;
pnghdr
[
36
]
=
(
mz_uint8
)
*
pLen_out
;
c
=
(
mz_uint32
)
mz_crc32
(
MZ_CRC32_INIT
pnghdr
+
12
17
)
;
for
(
i
=
0
;
i
<
4
;
+
+
i
c
<
<
=
8
)
(
(
mz_uint8
*
)
(
pnghdr
+
29
)
)
[
i
]
=
(
mz_uint8
)
(
c
>
>
24
)
;
memcpy
(
out_buf
.
m_pBuf
pnghdr
41
)
;
}
if
(
!
tdefl_output_buffer_putter
(
"
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
x49
\
x45
\
x4e
\
x44
\
xae
\
x42
\
x60
\
x82
"
16
&
out_buf
)
)
{
*
pLen_out
=
0
;
MZ_FREE
(
pComp
)
;
MZ_FREE
(
out_buf
.
m_pBuf
)
;
return
NULL
;
}
c
=
(
mz_uint32
)
mz_crc32
(
MZ_CRC32_INIT
out_buf
.
m_pBuf
+
41
-
4
*
pLen_out
+
4
)
;
for
(
i
=
0
;
i
<
4
;
+
+
i
c
<
<
=
8
)
(
out_buf
.
m_pBuf
+
out_buf
.
m_size
-
16
)
[
i
]
=
(
mz_uint8
)
(
c
>
>
24
)
;
*
pLen_out
+
=
57
;
MZ_FREE
(
pComp
)
;
return
out_buf
.
m_pBuf
;
}
void
*
tdefl_write_image_to_png_file_in_memory
(
const
void
*
pImage
int
w
int
h
int
num_chans
size_t
*
pLen_out
)
{
return
tdefl_write_image_to_png_file_in_memory_ex
(
pImage
w
h
num_chans
pLen_out
6
MZ_FALSE
)
;
}
tdefl_compressor
*
tdefl_compressor_alloc
(
)
{
return
(
tdefl_compressor
*
)
MZ_MALLOC
(
sizeof
(
tdefl_compressor
)
)
;
}
void
tdefl_compressor_free
(
tdefl_compressor
*
pComp
)
{
MZ_FREE
(
pComp
)
;
}
#
ifdef
_MSC_VER
#
pragma
warning
(
pop
)
#
endif
#
ifdef
__cplusplus
}
#
endif
