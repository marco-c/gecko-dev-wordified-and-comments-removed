use
syntax_pos
:
:
{
Span
FileMap
}
;
use
CodeMapper
;
use
std
:
:
rc
:
:
Rc
;
use
Level
;
#
[
derive
(
Clone
)
]
pub
struct
SnippetData
{
codemap
:
Rc
<
CodeMapper
>
files
:
Vec
<
FileInfo
>
}
#
[
derive
(
Clone
)
]
pub
struct
FileInfo
{
file
:
Rc
<
FileMap
>
primary_span
:
Option
<
Span
>
lines
:
Vec
<
Line
>
}
#
[
derive
(
Clone
Debug
PartialOrd
Ord
PartialEq
Eq
)
]
pub
struct
Line
{
pub
line_index
:
usize
pub
annotations
:
Vec
<
Annotation
>
}
#
[
derive
(
Clone
Debug
PartialOrd
Ord
PartialEq
Eq
)
]
pub
struct
MultilineAnnotation
{
pub
depth
:
usize
pub
line_start
:
usize
pub
line_end
:
usize
pub
start_col
:
usize
pub
end_col
:
usize
pub
is_primary
:
bool
pub
label
:
Option
<
String
>
}
impl
MultilineAnnotation
{
pub
fn
increase_depth
(
&
mut
self
)
{
self
.
depth
+
=
1
;
}
pub
fn
as_start
(
&
self
)
-
>
Annotation
{
Annotation
{
start_col
:
self
.
start_col
end_col
:
self
.
start_col
+
1
is_primary
:
self
.
is_primary
label
:
Some
(
"
starting
here
.
.
.
"
.
to_owned
(
)
)
annotation_type
:
AnnotationType
:
:
MultilineStart
(
self
.
depth
)
}
}
pub
fn
as_end
(
&
self
)
-
>
Annotation
{
Annotation
{
start_col
:
self
.
end_col
-
1
end_col
:
self
.
end_col
is_primary
:
self
.
is_primary
label
:
match
self
.
label
{
Some
(
ref
label
)
=
>
Some
(
format
!
(
"
.
.
.
ending
here
:
{
}
"
label
)
)
None
=
>
Some
(
"
.
.
.
ending
here
"
.
to_owned
(
)
)
}
annotation_type
:
AnnotationType
:
:
MultilineEnd
(
self
.
depth
)
}
}
pub
fn
as_line
(
&
self
)
-
>
Annotation
{
Annotation
{
start_col
:
0
end_col
:
0
is_primary
:
self
.
is_primary
label
:
None
annotation_type
:
AnnotationType
:
:
MultilineLine
(
self
.
depth
)
}
}
}
#
[
derive
(
Clone
Debug
PartialOrd
Ord
PartialEq
Eq
)
]
pub
enum
AnnotationType
{
Singleline
Minimized
Multiline
(
MultilineAnnotation
)
MultilineStart
(
usize
)
MultilineEnd
(
usize
)
MultilineLine
(
usize
)
}
#
[
derive
(
Clone
Debug
PartialOrd
Ord
PartialEq
Eq
)
]
pub
struct
Annotation
{
pub
start_col
:
usize
pub
end_col
:
usize
pub
is_primary
:
bool
pub
label
:
Option
<
String
>
pub
annotation_type
:
AnnotationType
}
impl
Annotation
{
pub
fn
is_minimized
(
&
self
)
-
>
bool
{
match
self
.
annotation_type
{
AnnotationType
:
:
Minimized
=
>
true
_
=
>
false
}
}
pub
fn
is_line
(
&
self
)
-
>
bool
{
if
let
AnnotationType
:
:
MultilineLine
(
_
)
=
self
.
annotation_type
{
true
}
else
{
false
}
}
pub
fn
is_multiline
(
&
self
)
-
>
bool
{
match
self
.
annotation_type
{
AnnotationType
:
:
Multiline
(
_
)
|
AnnotationType
:
:
MultilineStart
(
_
)
|
AnnotationType
:
:
MultilineLine
(
_
)
|
AnnotationType
:
:
MultilineEnd
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
if
self
.
end_col
>
self
.
start_col
{
self
.
end_col
-
self
.
start_col
}
else
{
self
.
start_col
-
self
.
end_col
}
}
pub
fn
has_label
(
&
self
)
-
>
bool
{
if
let
Some
(
ref
label
)
=
self
.
label
{
label
.
len
(
)
>
0
}
else
{
false
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
StyledString
{
pub
text
:
String
pub
style
:
Style
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
)
]
pub
enum
Style
{
HeaderMsg
FileNameStyle
LineAndColumn
LineNumber
Quotation
UnderlinePrimary
UnderlineSecondary
LabelPrimary
LabelSecondary
OldSchoolNoteText
OldSchoolNote
NoStyle
ErrorCode
Level
(
Level
)
Highlight
}
