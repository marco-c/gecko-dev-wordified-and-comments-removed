use
self
:
:
Destination
:
:
*
;
use
syntax_pos
:
:
{
COMMAND_LINE_SP
DUMMY_SP
FileMap
Span
MultiSpan
CharPos
}
;
use
{
Level
CodeSuggestion
DiagnosticBuilder
SubDiagnostic
CodeMapper
}
;
use
RenderSpan
:
:
*
;
use
snippet
:
:
{
Annotation
AnnotationType
Line
MultilineAnnotation
StyledString
Style
}
;
use
styled_buffer
:
:
StyledBuffer
;
use
std
:
:
io
:
:
prelude
:
:
*
;
use
std
:
:
io
;
use
std
:
:
ops
;
use
std
:
:
rc
:
:
Rc
;
use
term
;
pub
trait
Emitter
{
fn
emit
(
&
mut
self
db
:
&
DiagnosticBuilder
)
;
}
impl
Emitter
for
EmitterWriter
{
fn
emit
(
&
mut
self
db
:
&
DiagnosticBuilder
)
{
let
mut
primary_span
=
db
.
span
.
clone
(
)
;
let
mut
children
=
db
.
children
.
clone
(
)
;
self
.
fix_multispans_in_std_macros
(
&
mut
primary_span
&
mut
children
)
;
self
.
emit_messages_default
(
&
db
.
level
&
db
.
styled_message
(
)
&
db
.
code
&
primary_span
&
children
)
;
}
}
pub
const
MAX_HIGHLIGHT_LINES
:
usize
=
6
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
ColorConfig
{
Auto
Always
Never
}
impl
ColorConfig
{
fn
use_color
(
&
self
)
-
>
bool
{
match
*
self
{
ColorConfig
:
:
Always
=
>
true
ColorConfig
:
:
Never
=
>
false
ColorConfig
:
:
Auto
=
>
stderr_isatty
(
)
}
}
}
pub
struct
EmitterWriter
{
dst
:
Destination
cm
:
Option
<
Rc
<
CodeMapper
>
>
}
struct
FileWithAnnotatedLines
{
file
:
Rc
<
FileMap
>
lines
:
Vec
<
Line
>
multiline_depth
:
usize
}
macro_rules
!
print_maybe_styled
{
(
dst
:
expr
style
:
expr
(
arg
:
tt
)
*
)
=
>
{
dst
.
print_maybe_styled
(
format_args
!
(
(
arg
)
*
)
style
false
)
}
}
macro_rules
!
println_maybe_styled
{
(
dst
:
expr
style
:
expr
(
arg
:
tt
)
*
)
=
>
{
dst
.
print_maybe_styled
(
format_args
!
(
(
arg
)
*
)
style
true
)
}
}
impl
EmitterWriter
{
pub
fn
stderr
(
color_config
:
ColorConfig
code_map
:
Option
<
Rc
<
CodeMapper
>
>
)
-
>
EmitterWriter
{
if
color_config
.
use_color
(
)
{
let
dst
=
Destination
:
:
from_stderr
(
)
;
EmitterWriter
{
dst
:
dst
cm
:
code_map
}
}
else
{
EmitterWriter
{
dst
:
Raw
(
Box
:
:
new
(
io
:
:
stderr
(
)
)
)
cm
:
code_map
}
}
}
pub
fn
new
(
dst
:
Box
<
Write
+
Send
>
code_map
:
Option
<
Rc
<
CodeMapper
>
>
)
-
>
EmitterWriter
{
EmitterWriter
{
dst
:
Raw
(
dst
)
cm
:
code_map
}
}
fn
preprocess_annotations
(
&
self
msp
:
&
MultiSpan
)
-
>
Vec
<
FileWithAnnotatedLines
>
{
fn
add_annotation_to_file
(
file_vec
:
&
mut
Vec
<
FileWithAnnotatedLines
>
file
:
Rc
<
FileMap
>
line_index
:
usize
ann
:
Annotation
)
{
for
slot
in
file_vec
.
iter_mut
(
)
{
if
slot
.
file
.
name
=
=
file
.
name
{
for
line_slot
in
&
mut
slot
.
lines
{
if
line_slot
.
line_index
=
=
line_index
{
line_slot
.
annotations
.
push
(
ann
)
;
return
;
}
}
slot
.
lines
.
push
(
Line
{
line_index
:
line_index
annotations
:
vec
!
[
ann
]
}
)
;
slot
.
lines
.
sort
(
)
;
return
;
}
}
file_vec
.
push
(
FileWithAnnotatedLines
{
file
:
file
lines
:
vec
!
[
Line
{
line_index
:
line_index
annotations
:
vec
!
[
ann
]
}
]
multiline_depth
:
0
}
)
;
}
let
mut
output
=
vec
!
[
]
;
let
mut
multiline_annotations
=
vec
!
[
]
;
if
let
Some
(
ref
cm
)
=
self
.
cm
{
for
span_label
in
msp
.
span_labels
(
)
{
if
span_label
.
span
=
=
DUMMY_SP
|
|
span_label
.
span
=
=
COMMAND_LINE_SP
{
continue
;
}
let
lo
=
cm
.
lookup_char_pos
(
span_label
.
span
.
lo
)
;
let
mut
hi
=
cm
.
lookup_char_pos
(
span_label
.
span
.
hi
)
;
let
mut
is_minimized
=
false
;
let
max_multiline_span_length
=
8
;
if
lo
.
line
!
=
hi
.
line
&
&
(
hi
.
line
-
lo
.
line
)
>
max_multiline_span_length
{
hi
.
line
=
lo
.
line
;
hi
.
col
=
CharPos
(
lo
.
col
.
0
+
1
)
;
is_minimized
=
true
;
}
if
lo
.
col
=
=
hi
.
col
&
&
lo
.
line
=
=
hi
.
line
{
hi
.
col
=
CharPos
(
lo
.
col
.
0
+
1
)
;
}
let
mut
ann
=
Annotation
{
start_col
:
lo
.
col
.
0
end_col
:
hi
.
col
.
0
is_primary
:
span_label
.
is_primary
label
:
span_label
.
label
.
clone
(
)
annotation_type
:
AnnotationType
:
:
Singleline
}
;
if
is_minimized
{
ann
.
annotation_type
=
AnnotationType
:
:
Minimized
;
}
else
if
lo
.
line
!
=
hi
.
line
{
let
ml
=
MultilineAnnotation
{
depth
:
1
line_start
:
lo
.
line
line_end
:
hi
.
line
start_col
:
lo
.
col
.
0
end_col
:
hi
.
col
.
0
is_primary
:
span_label
.
is_primary
label
:
span_label
.
label
.
clone
(
)
}
;
ann
.
annotation_type
=
AnnotationType
:
:
Multiline
(
ml
.
clone
(
)
)
;
multiline_annotations
.
push
(
(
lo
.
file
.
clone
(
)
ml
)
)
;
}
;
if
!
ann
.
is_multiline
(
)
{
add_annotation_to_file
(
&
mut
output
lo
.
file
lo
.
line
ann
)
;
}
}
}
multiline_annotations
.
sort_by
(
|
a
b
|
{
(
a
.
1
.
line_start
a
.
1
.
line_end
)
.
cmp
(
&
(
b
.
1
.
line_start
b
.
1
.
line_end
)
)
}
)
;
for
item
in
multiline_annotations
.
clone
(
)
{
let
ann
=
item
.
1
;
for
item
in
multiline_annotations
.
iter_mut
(
)
{
let
ref
mut
a
=
item
.
1
;
if
&
ann
!
=
a
&
&
num_overlap
(
ann
.
line_start
ann
.
line_end
a
.
line_start
a
.
line_end
true
)
{
a
.
increase_depth
(
)
;
}
else
{
break
;
}
}
}
let
mut
max_depth
=
0
;
for
(
file
ann
)
in
multiline_annotations
{
if
ann
.
depth
>
max_depth
{
max_depth
=
ann
.
depth
;
}
add_annotation_to_file
(
&
mut
output
file
.
clone
(
)
ann
.
line_start
ann
.
as_start
(
)
)
;
for
line
in
ann
.
line_start
+
1
.
.
ann
.
line_end
{
add_annotation_to_file
(
&
mut
output
file
.
clone
(
)
line
ann
.
as_line
(
)
)
;
}
add_annotation_to_file
(
&
mut
output
file
ann
.
line_end
ann
.
as_end
(
)
)
;
}
for
file_vec
in
output
.
iter_mut
(
)
{
file_vec
.
multiline_depth
=
max_depth
;
}
output
}
fn
render_source_line
(
&
self
buffer
:
&
mut
StyledBuffer
file
:
Rc
<
FileMap
>
line
:
&
Line
width_offset
:
usize
multiline_depth
:
usize
)
{
let
source_string
=
file
.
get_line
(
line
.
line_index
-
1
)
.
unwrap_or
(
"
"
)
;
let
line_offset
=
buffer
.
num_lines
(
)
;
let
code_offset
=
if
multiline_depth
=
=
0
{
width_offset
}
else
{
width_offset
+
multiline_depth
+
1
}
;
buffer
.
puts
(
line_offset
code_offset
&
source_string
Style
:
:
Quotation
)
;
buffer
.
puts
(
line_offset
0
&
(
line
.
line_index
.
to_string
(
)
)
Style
:
:
LineNumber
)
;
draw_col_separator
(
buffer
line_offset
width_offset
-
2
)
;
let
mut
annotations
=
line
.
annotations
.
clone
(
)
;
annotations
.
sort
(
)
;
annotations
.
reverse
(
)
;
let
mut
annotations_position
=
vec
!
[
]
;
let
mut
line_len
=
0
;
let
mut
p
=
0
;
let
mut
ann_iter
=
annotations
.
iter
(
)
.
peekable
(
)
;
while
let
Some
(
annotation
)
=
ann_iter
.
next
(
)
{
let
peek
=
ann_iter
.
peek
(
)
;
if
let
Some
(
next
)
=
peek
{
if
overlaps
(
next
annotation
)
&
&
!
annotation
.
is_line
(
)
&
&
!
next
.
is_line
(
)
&
&
annotation
.
has_label
(
)
{
p
+
=
1
;
}
}
annotations_position
.
push
(
(
p
annotation
)
)
;
if
let
Some
(
next
)
=
peek
{
let
l
=
if
let
Some
(
ref
label
)
=
next
.
label
{
label
.
len
(
)
+
2
}
else
{
0
}
;
if
(
overlaps
(
next
annotation
)
|
|
next
.
end_col
+
l
>
annotation
.
start_col
)
&
&
!
annotation
.
is_line
(
)
&
&
!
next
.
is_line
(
)
&
&
annotation
.
has_label
(
)
&
&
next
.
has_label
(
)
{
p
+
=
1
;
}
}
if
line_len
<
p
{
line_len
=
p
;
}
}
if
line_len
!
=
0
{
line_len
+
=
1
;
}
if
line
.
annotations
.
is_empty
(
)
|
|
line
.
annotations
.
iter
(
)
.
filter
(
|
a
|
{
if
let
AnnotationType
:
:
MultilineLine
(
depth
)
=
a
.
annotation_type
{
buffer
.
putc
(
line_offset
width_offset
+
depth
-
1
'
|
'
if
a
.
is_primary
{
Style
:
:
UnderlinePrimary
}
else
{
Style
:
:
UnderlineSecondary
}
)
;
false
}
else
{
true
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
len
(
)
=
=
0
{
return
;
}
for
pos
in
0
.
.
line_len
+
1
{
draw_col_separator
(
buffer
line_offset
+
pos
+
1
width_offset
-
2
)
;
buffer
.
putc
(
line_offset
+
pos
+
1
width_offset
-
2
'
|
'
Style
:
:
LineNumber
)
;
}
for
&
(
pos
annotation
)
in
&
annotations_position
{
let
style
=
if
annotation
.
is_primary
{
Style
:
:
UnderlinePrimary
}
else
{
Style
:
:
UnderlineSecondary
}
;
let
pos
=
pos
+
1
;
match
annotation
.
annotation_type
{
AnnotationType
:
:
MultilineStart
(
depth
)
|
AnnotationType
:
:
MultilineEnd
(
depth
)
=
>
{
draw_range
(
buffer
'
_
'
line_offset
+
pos
width_offset
+
depth
code_offset
+
annotation
.
start_col
style
)
;
}
_
=
>
(
)
}
}
for
&
(
pos
annotation
)
in
&
annotations_position
{
let
style
=
if
annotation
.
is_primary
{
Style
:
:
UnderlinePrimary
}
else
{
Style
:
:
UnderlineSecondary
}
;
let
pos
=
pos
+
1
;
if
pos
>
1
&
&
annotation
.
has_label
(
)
{
for
p
in
line_offset
+
1
.
.
line_offset
+
pos
+
1
{
buffer
.
putc
(
p
code_offset
+
annotation
.
start_col
'
|
'
style
)
;
}
}
match
annotation
.
annotation_type
{
AnnotationType
:
:
MultilineStart
(
depth
)
=
>
{
for
p
in
line_offset
+
pos
+
1
.
.
line_offset
+
line_len
+
2
{
buffer
.
putc
(
p
width_offset
+
depth
-
1
'
|
'
style
)
;
}
}
AnnotationType
:
:
MultilineEnd
(
depth
)
=
>
{
for
p
in
line_offset
.
.
line_offset
+
pos
+
1
{
buffer
.
putc
(
p
width_offset
+
depth
-
1
'
|
'
style
)
;
}
}
AnnotationType
:
:
MultilineLine
(
depth
)
=
>
{
for
p
in
line_offset
+
1
.
.
line_offset
+
line_len
+
2
{
buffer
.
putc
(
p
width_offset
+
depth
-
1
'
|
'
style
)
;
}
}
_
=
>
(
)
}
}
for
&
(
pos
annotation
)
in
&
annotations_position
{
let
style
=
if
annotation
.
is_primary
{
Style
:
:
LabelPrimary
}
else
{
Style
:
:
LabelSecondary
}
;
let
(
pos
col
)
=
if
pos
=
=
0
{
(
pos
+
1
annotation
.
end_col
+
1
)
}
else
{
(
pos
+
2
annotation
.
start_col
)
}
;
if
let
Some
(
ref
label
)
=
annotation
.
label
{
buffer
.
puts
(
line_offset
+
pos
code_offset
+
col
&
label
style
)
;
}
}
annotations_position
.
sort_by
(
|
a
b
|
{
a
.
1
.
len
(
)
.
cmp
(
&
b
.
1
.
len
(
)
)
.
reverse
(
)
}
)
;
for
&
(
_
annotation
)
in
&
annotations_position
{
let
(
underline
style
)
=
if
annotation
.
is_primary
{
(
'
^
'
Style
:
:
UnderlinePrimary
)
}
else
{
(
'
-
'
Style
:
:
UnderlineSecondary
)
}
;
for
p
in
annotation
.
start_col
.
.
annotation
.
end_col
{
buffer
.
putc
(
line_offset
+
1
code_offset
+
p
underline
style
)
;
}
}
}
fn
get_multispan_max_line_num
(
&
mut
self
msp
:
&
MultiSpan
)
-
>
usize
{
let
mut
max
=
0
;
if
let
Some
(
ref
cm
)
=
self
.
cm
{
for
primary_span
in
msp
.
primary_spans
(
)
{
if
primary_span
!
=
&
DUMMY_SP
&
&
primary_span
!
=
&
COMMAND_LINE_SP
{
let
hi
=
cm
.
lookup_char_pos
(
primary_span
.
hi
)
;
if
hi
.
line
>
max
{
max
=
hi
.
line
;
}
}
}
for
span_label
in
msp
.
span_labels
(
)
{
if
span_label
.
span
!
=
DUMMY_SP
&
&
span_label
.
span
!
=
COMMAND_LINE_SP
{
let
hi
=
cm
.
lookup_char_pos
(
span_label
.
span
.
hi
)
;
if
hi
.
line
>
max
{
max
=
hi
.
line
;
}
}
}
}
max
}
fn
get_max_line_num
(
&
mut
self
span
:
&
MultiSpan
children
:
&
Vec
<
SubDiagnostic
>
)
-
>
usize
{
let
mut
max
=
0
;
let
primary
=
self
.
get_multispan_max_line_num
(
span
)
;
max
=
if
primary
>
max
{
primary
}
else
{
max
}
;
for
sub
in
children
{
let
sub_result
=
self
.
get_multispan_max_line_num
(
&
sub
.
span
)
;
max
=
if
sub_result
>
max
{
primary
}
else
{
max
}
;
}
max
}
fn
fix_multispan_in_std_macros
(
&
mut
self
span
:
&
mut
MultiSpan
)
-
>
bool
{
let
mut
spans_updated
=
false
;
if
let
Some
(
ref
cm
)
=
self
.
cm
{
let
mut
before_after
:
Vec
<
(
Span
Span
)
>
=
vec
!
[
]
;
let
mut
new_labels
:
Vec
<
(
Span
String
)
>
=
vec
!
[
]
;
for
sp
in
span
.
primary_spans
(
)
{
if
(
*
sp
=
=
COMMAND_LINE_SP
)
|
|
(
*
sp
=
=
DUMMY_SP
)
{
continue
;
}
if
cm
.
span_to_filename
(
sp
.
clone
(
)
)
.
contains
(
"
macros
>
"
)
{
let
v
=
cm
.
macro_backtrace
(
sp
.
clone
(
)
)
;
if
let
Some
(
use_site
)
=
v
.
last
(
)
{
before_after
.
push
(
(
sp
.
clone
(
)
use_site
.
call_site
.
clone
(
)
)
)
;
}
}
for
trace
in
cm
.
macro_backtrace
(
sp
.
clone
(
)
)
.
iter
(
)
.
rev
(
)
{
if
let
Some
(
def_site
)
=
trace
.
def_site_span
{
if
(
def_site
=
=
COMMAND_LINE_SP
)
|
|
(
def_site
=
=
DUMMY_SP
)
{
continue
;
}
if
!
cm
.
span_to_filename
(
def_site
)
.
contains
(
"
macros
>
"
)
&
&
!
trace
.
macro_decl_name
.
starts_with
(
"
#
[
"
)
{
new_labels
.
push
(
(
trace
.
call_site
"
in
this
macro
invocation
"
.
to_string
(
)
)
)
;
break
;
}
}
}
}
for
(
label_span
label_text
)
in
new_labels
{
span
.
push_span_label
(
label_span
label_text
)
;
}
for
sp_label
in
span
.
span_labels
(
)
{
if
(
sp_label
.
span
=
=
COMMAND_LINE_SP
)
|
|
(
sp_label
.
span
=
=
DUMMY_SP
)
{
continue
;
}
if
cm
.
span_to_filename
(
sp_label
.
span
.
clone
(
)
)
.
contains
(
"
macros
>
"
)
{
let
v
=
cm
.
macro_backtrace
(
sp_label
.
span
.
clone
(
)
)
;
if
let
Some
(
use_site
)
=
v
.
last
(
)
{
before_after
.
push
(
(
sp_label
.
span
.
clone
(
)
use_site
.
call_site
.
clone
(
)
)
)
;
}
}
}
for
(
before
after
)
in
before_after
{
span
.
replace
(
before
after
)
;
spans_updated
=
true
;
}
}
spans_updated
}
fn
fix_multispans_in_std_macros
(
&
mut
self
span
:
&
mut
MultiSpan
children
:
&
mut
Vec
<
SubDiagnostic
>
)
{
let
mut
spans_updated
=
self
.
fix_multispan_in_std_macros
(
span
)
;
for
child
in
children
.
iter_mut
(
)
{
spans_updated
|
=
self
.
fix_multispan_in_std_macros
(
&
mut
child
.
span
)
;
}
if
spans_updated
{
children
.
push
(
SubDiagnostic
{
level
:
Level
:
:
Note
message
:
vec
!
[
(
"
this
error
originates
in
a
macro
outside
of
the
current
crate
"
.
to_string
(
)
Style
:
:
NoStyle
)
]
span
:
MultiSpan
:
:
new
(
)
render_span
:
None
}
)
;
}
}
fn
msg_to_buffer
(
&
self
buffer
:
&
mut
StyledBuffer
msg
:
&
Vec
<
(
String
Style
)
>
padding
:
usize
label
:
&
str
override_style
:
Option
<
Style
>
)
{
let
padding
=
(
0
.
.
padding
+
label
.
len
(
)
+
5
)
.
map
(
|
_
|
"
"
)
.
collect
:
:
<
String
>
(
)
;
fn
style_or_override
(
style
:
Style
override_style
:
Option
<
Style
>
)
-
>
Style
{
if
let
Some
(
o
)
=
override_style
{
if
style
=
=
Style
:
:
NoStyle
{
return
o
;
}
}
style
}
let
mut
line_number
=
0
;
for
&
(
ref
text
ref
style
)
in
msg
.
iter
(
)
{
let
lines
=
text
.
split
(
'
\
n
'
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
if
lines
.
len
(
)
>
1
{
for
(
i
line
)
in
lines
.
iter
(
)
.
enumerate
(
)
{
if
i
!
=
0
{
line_number
+
=
1
;
buffer
.
append
(
line_number
&
padding
Style
:
:
NoStyle
)
;
}
buffer
.
append
(
line_number
line
style_or_override
(
*
style
override_style
)
)
;
}
}
else
{
buffer
.
append
(
line_number
text
style_or_override
(
*
style
override_style
)
)
;
}
}
}
fn
emit_message_default
(
&
mut
self
msp
:
&
MultiSpan
msg
:
&
Vec
<
(
String
Style
)
>
code
:
&
Option
<
String
>
level
:
&
Level
max_line_num_len
:
usize
is_secondary
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
buffer
=
StyledBuffer
:
:
new
(
)
;
if
msp
.
primary_spans
(
)
.
is_empty
(
)
&
&
msp
.
span_labels
(
)
.
is_empty
(
)
&
&
is_secondary
{
for
_
in
0
.
.
max_line_num_len
{
buffer
.
prepend
(
0
"
"
Style
:
:
NoStyle
)
;
}
draw_note_separator
(
&
mut
buffer
0
max_line_num_len
+
1
)
;
buffer
.
append
(
0
&
level
.
to_string
(
)
Style
:
:
HeaderMsg
)
;
buffer
.
append
(
0
"
:
"
Style
:
:
NoStyle
)
;
self
.
msg_to_buffer
(
&
mut
buffer
msg
max_line_num_len
"
note
"
None
)
;
}
else
{
buffer
.
append
(
0
&
level
.
to_string
(
)
Style
:
:
Level
(
level
.
clone
(
)
)
)
;
match
code
{
&
Some
(
ref
code
)
=
>
{
buffer
.
append
(
0
"
[
"
Style
:
:
Level
(
level
.
clone
(
)
)
)
;
buffer
.
append
(
0
&
code
Style
:
:
Level
(
level
.
clone
(
)
)
)
;
buffer
.
append
(
0
"
]
"
Style
:
:
Level
(
level
.
clone
(
)
)
)
;
}
_
=
>
{
}
}
buffer
.
append
(
0
"
:
"
Style
:
:
HeaderMsg
)
;
for
&
(
ref
text
_
)
in
msg
.
iter
(
)
{
buffer
.
append
(
0
text
Style
:
:
HeaderMsg
)
;
}
}
let
mut
annotated_files
=
self
.
preprocess_annotations
(
msp
)
;
let
primary_lo
=
if
let
(
Some
(
ref
cm
)
Some
(
ref
primary_span
)
)
=
(
self
.
cm
.
as_ref
(
)
msp
.
primary_span
(
)
.
as_ref
(
)
)
{
if
primary_span
!
=
&
&
DUMMY_SP
&
&
primary_span
!
=
&
&
COMMAND_LINE_SP
{
cm
.
lookup_char_pos
(
primary_span
.
lo
)
}
else
{
try
!
(
emit_to_destination
(
&
buffer
.
render
(
)
level
&
mut
self
.
dst
)
)
;
return
Ok
(
(
)
)
;
}
}
else
{
try
!
(
emit_to_destination
(
&
buffer
.
render
(
)
level
&
mut
self
.
dst
)
)
;
return
Ok
(
(
)
)
;
}
;
if
let
Ok
(
pos
)
=
annotated_files
.
binary_search_by
(
|
x
|
x
.
file
.
name
.
cmp
(
&
primary_lo
.
file
.
name
)
)
{
annotated_files
.
swap
(
0
pos
)
;
}
for
annotated_file
in
annotated_files
{
let
is_primary
=
primary_lo
.
file
.
name
=
=
annotated_file
.
file
.
name
;
if
is_primary
{
let
buffer_msg_line_offset
=
buffer
.
num_lines
(
)
;
buffer
.
prepend
(
buffer_msg_line_offset
"
-
-
>
"
Style
:
:
LineNumber
)
;
let
loc
=
primary_lo
.
clone
(
)
;
buffer
.
append
(
buffer_msg_line_offset
&
format
!
(
"
{
}
:
{
}
:
{
}
"
loc
.
file
.
name
loc
.
line
loc
.
col
.
0
+
1
)
Style
:
:
LineAndColumn
)
;
for
_
in
0
.
.
max_line_num_len
{
buffer
.
prepend
(
buffer_msg_line_offset
"
"
Style
:
:
NoStyle
)
;
}
}
else
{
let
buffer_msg_line_offset
=
buffer
.
num_lines
(
)
;
draw_col_separator
(
&
mut
buffer
buffer_msg_line_offset
max_line_num_len
+
1
)
;
buffer
.
prepend
(
buffer_msg_line_offset
+
1
"
:
:
:
"
Style
:
:
LineNumber
)
;
buffer
.
append
(
buffer_msg_line_offset
+
1
&
annotated_file
.
file
.
name
Style
:
:
LineAndColumn
)
;
for
_
in
0
.
.
max_line_num_len
{
buffer
.
prepend
(
buffer_msg_line_offset
+
1
"
"
Style
:
:
NoStyle
)
;
}
}
let
buffer_msg_line_offset
=
buffer
.
num_lines
(
)
;
draw_col_separator_no_space
(
&
mut
buffer
buffer_msg_line_offset
max_line_num_len
+
1
)
;
for
line_idx
in
0
.
.
annotated_file
.
lines
.
len
(
)
{
self
.
render_source_line
(
&
mut
buffer
annotated_file
.
file
.
clone
(
)
&
annotated_file
.
lines
[
line_idx
]
3
+
max_line_num_len
annotated_file
.
multiline_depth
)
;
if
line_idx
<
(
annotated_file
.
lines
.
len
(
)
-
1
)
{
let
line_idx_delta
=
annotated_file
.
lines
[
line_idx
+
1
]
.
line_index
-
annotated_file
.
lines
[
line_idx
]
.
line_index
;
if
line_idx_delta
>
2
{
let
last_buffer_line_num
=
buffer
.
num_lines
(
)
;
buffer
.
puts
(
last_buffer_line_num
0
"
.
.
.
"
Style
:
:
LineNumber
)
;
}
else
if
line_idx_delta
=
=
2
{
let
unannotated_line
=
annotated_file
.
file
.
get_line
(
annotated_file
.
lines
[
line_idx
]
.
line_index
)
.
unwrap_or
(
"
"
)
;
let
last_buffer_line_num
=
buffer
.
num_lines
(
)
;
buffer
.
puts
(
last_buffer_line_num
0
&
(
annotated_file
.
lines
[
line_idx
+
1
]
.
line_index
-
1
)
.
to_string
(
)
Style
:
:
LineNumber
)
;
draw_col_separator
(
&
mut
buffer
last_buffer_line_num
1
+
max_line_num_len
)
;
buffer
.
puts
(
last_buffer_line_num
3
+
max_line_num_len
&
unannotated_line
Style
:
:
Quotation
)
;
}
}
}
}
try
!
(
emit_to_destination
(
&
buffer
.
render
(
)
level
&
mut
self
.
dst
)
)
;
Ok
(
(
)
)
}
fn
emit_suggestion_default
(
&
mut
self
suggestion
:
&
CodeSuggestion
level
:
&
Level
msg
:
&
Vec
<
(
String
Style
)
>
max_line_num_len
:
usize
)
-
>
io
:
:
Result
<
(
)
>
{
use
std
:
:
borrow
:
:
Borrow
;
let
primary_span
=
suggestion
.
msp
.
primary_span
(
)
.
unwrap
(
)
;
if
let
Some
(
ref
cm
)
=
self
.
cm
{
let
mut
buffer
=
StyledBuffer
:
:
new
(
)
;
buffer
.
append
(
0
&
level
.
to_string
(
)
Style
:
:
Level
(
level
.
clone
(
)
)
)
;
buffer
.
append
(
0
"
:
"
Style
:
:
HeaderMsg
)
;
self
.
msg_to_buffer
(
&
mut
buffer
msg
max_line_num_len
"
suggestion
"
Some
(
Style
:
:
HeaderMsg
)
)
;
let
lines
=
cm
.
span_to_lines
(
primary_span
)
.
unwrap
(
)
;
assert
!
(
!
lines
.
lines
.
is_empty
(
)
)
;
let
complete
=
suggestion
.
splice_lines
(
cm
.
borrow
(
)
)
;
let
mut
lines
=
complete
.
lines
(
)
;
let
mut
row_num
=
1
;
for
line
in
lines
.
by_ref
(
)
.
take
(
MAX_HIGHLIGHT_LINES
)
{
draw_col_separator
(
&
mut
buffer
row_num
max_line_num_len
+
1
)
;
buffer
.
append
(
row_num
line
Style
:
:
NoStyle
)
;
row_num
+
=
1
;
}
if
let
Some
(
_
)
=
lines
.
next
(
)
{
buffer
.
append
(
row_num
"
.
.
.
"
Style
:
:
NoStyle
)
;
}
try
!
(
emit_to_destination
(
&
buffer
.
render
(
)
level
&
mut
self
.
dst
)
)
;
}
Ok
(
(
)
)
}
fn
emit_messages_default
(
&
mut
self
level
:
&
Level
message
:
&
Vec
<
(
String
Style
)
>
code
:
&
Option
<
String
>
span
:
&
MultiSpan
children
:
&
Vec
<
SubDiagnostic
>
)
{
let
max_line_num
=
self
.
get_max_line_num
(
span
children
)
;
let
max_line_num_len
=
max_line_num
.
to_string
(
)
.
len
(
)
;
match
self
.
emit_message_default
(
span
message
code
level
max_line_num_len
false
)
{
Ok
(
(
)
)
=
>
{
if
!
children
.
is_empty
(
)
{
let
mut
buffer
=
StyledBuffer
:
:
new
(
)
;
draw_col_separator_no_space
(
&
mut
buffer
0
max_line_num_len
+
1
)
;
match
emit_to_destination
(
&
buffer
.
render
(
)
level
&
mut
self
.
dst
)
{
Ok
(
(
)
)
=
>
(
)
Err
(
e
)
=
>
panic
!
(
"
failed
to
emit
error
:
{
}
"
e
)
}
}
for
child
in
children
{
match
child
.
render_span
{
Some
(
FullSpan
(
ref
msp
)
)
=
>
{
match
self
.
emit_message_default
(
msp
&
child
.
styled_message
(
)
&
None
&
child
.
level
max_line_num_len
true
)
{
Err
(
e
)
=
>
panic
!
(
"
failed
to
emit
error
:
{
}
"
e
)
_
=
>
(
)
}
}
Some
(
Suggestion
(
ref
cs
)
)
=
>
{
match
self
.
emit_suggestion_default
(
cs
&
child
.
level
&
child
.
styled_message
(
)
max_line_num_len
)
{
Err
(
e
)
=
>
panic
!
(
"
failed
to
emit
error
:
{
}
"
e
)
_
=
>
(
)
}
}
None
=
>
{
match
self
.
emit_message_default
(
&
child
.
span
&
child
.
styled_message
(
)
&
None
&
child
.
level
max_line_num_len
true
)
{
Err
(
e
)
=
>
panic
!
(
"
failed
to
emit
error
:
{
}
"
e
)
_
=
>
(
)
}
}
}
}
}
Err
(
e
)
=
>
panic
!
(
"
failed
to
emit
error
:
{
}
"
e
)
}
match
write
!
(
&
mut
self
.
dst
"
\
n
"
)
{
Err
(
e
)
=
>
panic
!
(
"
failed
to
emit
error
:
{
}
"
e
)
_
=
>
{
match
self
.
dst
.
flush
(
)
{
Err
(
e
)
=
>
panic
!
(
"
failed
to
emit
error
:
{
}
"
e
)
_
=
>
(
)
}
}
}
}
}
fn
draw_col_separator
(
buffer
:
&
mut
StyledBuffer
line
:
usize
col
:
usize
)
{
buffer
.
puts
(
line
col
"
|
"
Style
:
:
LineNumber
)
;
}
fn
draw_col_separator_no_space
(
buffer
:
&
mut
StyledBuffer
line
:
usize
col
:
usize
)
{
draw_col_separator_no_space_with_style
(
buffer
line
col
Style
:
:
LineNumber
)
;
}
fn
draw_col_separator_no_space_with_style
(
buffer
:
&
mut
StyledBuffer
line
:
usize
col
:
usize
style
:
Style
)
{
buffer
.
putc
(
line
col
'
|
'
style
)
;
}
fn
draw_range
(
buffer
:
&
mut
StyledBuffer
symbol
:
char
line
:
usize
col_from
:
usize
col_to
:
usize
style
:
Style
)
{
for
col
in
col_from
.
.
col_to
{
buffer
.
putc
(
line
col
symbol
style
)
;
}
}
fn
draw_note_separator
(
buffer
:
&
mut
StyledBuffer
line
:
usize
col
:
usize
)
{
buffer
.
puts
(
line
col
"
=
"
Style
:
:
LineNumber
)
;
}
trait
SyntexContains
<
Idx
>
{
fn
syntex_contains
(
&
self
item
:
Idx
)
-
>
bool
;
}
impl
<
Idx
>
SyntexContains
<
Idx
>
for
ops
:
:
Range
<
Idx
>
where
Idx
:
PartialOrd
{
fn
syntex_contains
(
&
self
item
:
Idx
)
-
>
bool
{
(
self
.
start
<
=
item
)
&
&
(
item
<
self
.
end
)
}
}
fn
num_overlap
(
a_start
:
usize
a_end
:
usize
b_start
:
usize
b_end
:
usize
inclusive
:
bool
)
-
>
bool
{
let
extra
=
if
inclusive
{
1
}
else
{
0
}
;
(
b_start
.
.
b_end
+
extra
)
.
syntex_contains
(
a_start
)
|
|
(
a_start
.
.
a_end
+
extra
)
.
syntex_contains
(
b_start
)
}
fn
overlaps
(
a1
:
&
Annotation
a2
:
&
Annotation
)
-
>
bool
{
num_overlap
(
a1
.
start_col
a1
.
end_col
a2
.
start_col
a2
.
end_col
false
)
}
fn
emit_to_destination
(
rendered_buffer
:
&
Vec
<
Vec
<
StyledString
>
>
lvl
:
&
Level
dst
:
&
mut
Destination
)
-
>
io
:
:
Result
<
(
)
>
{
use
lock
;
let
_buffer_lock
=
lock
:
:
acquire_global_lock
(
"
rustc_errors
"
)
;
for
line
in
rendered_buffer
{
for
part
in
line
{
try
!
(
dst
.
apply_style
(
lvl
.
clone
(
)
part
.
style
)
)
;
try
!
(
write
!
(
dst
"
{
}
"
part
.
text
)
)
;
try
!
(
dst
.
reset_attrs
(
)
)
;
}
try
!
(
write
!
(
dst
"
\
n
"
)
)
;
}
try
!
(
dst
.
flush
(
)
)
;
Ok
(
(
)
)
}
#
[
cfg
(
unix
)
]
fn
stderr_isatty
(
)
-
>
bool
{
use
libc
;
unsafe
{
libc
:
:
isatty
(
libc
:
:
STDERR_FILENO
)
!
=
0
}
}
#
[
cfg
(
windows
)
]
fn
stderr_isatty
(
)
-
>
bool
{
type
DWORD
=
u32
;
type
BOOL
=
i32
;
type
HANDLE
=
*
mut
u8
;
const
STD_ERROR_HANDLE
:
DWORD
=
-
12i32
as
DWORD
;
extern
"
system
"
{
fn
GetStdHandle
(
which
:
DWORD
)
-
>
HANDLE
;
fn
GetConsoleMode
(
hConsoleHandle
:
HANDLE
lpMode
:
*
mut
DWORD
)
-
>
BOOL
;
}
unsafe
{
let
handle
=
GetStdHandle
(
STD_ERROR_HANDLE
)
;
let
mut
out
=
0
;
GetConsoleMode
(
handle
&
mut
out
)
!
=
0
}
}
pub
type
BufferedStderr
=
term
:
:
Terminal
<
Output
=
BufferedWriter
>
+
Send
;
pub
enum
Destination
{
Terminal
(
Box
<
term
:
:
StderrTerminal
>
)
BufferedTerminal
(
Box
<
BufferedStderr
>
)
Raw
(
Box
<
Write
+
Send
>
)
}
pub
struct
BufferedWriter
{
buffer
:
Vec
<
u8
>
}
impl
BufferedWriter
{
fn
_new
(
)
-
>
BufferedWriter
{
BufferedWriter
{
buffer
:
vec
!
[
]
}
}
}
impl
Write
for
BufferedWriter
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
for
b
in
buf
{
self
.
buffer
.
push
(
*
b
)
;
}
Ok
(
buf
.
len
(
)
)
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
stderr
=
io
:
:
stderr
(
)
;
let
result
=
(
|
|
{
try
!
(
stderr
.
write_all
(
&
self
.
buffer
)
)
;
stderr
.
flush
(
)
}
)
(
)
;
self
.
buffer
.
clear
(
)
;
result
}
}
impl
Destination
{
#
[
cfg
(
not
(
windows
)
)
]
fn
from_stderr
(
)
-
>
Destination
{
let
stderr
:
Option
<
Box
<
BufferedStderr
>
>
=
term
:
:
TerminfoTerminal
:
:
new
(
BufferedWriter
:
:
_new
(
)
)
.
map
(
|
t
|
Box
:
:
new
(
t
)
as
Box
<
BufferedStderr
>
)
;
match
stderr
{
Some
(
t
)
=
>
BufferedTerminal
(
t
)
None
=
>
Raw
(
Box
:
:
new
(
io
:
:
stderr
(
)
)
)
}
}
#
[
cfg
(
windows
)
]
fn
from_stderr
(
)
-
>
Destination
{
let
stderr
:
Option
<
Box
<
term
:
:
StderrTerminal
>
>
=
term
:
:
TerminfoTerminal
:
:
new
(
io
:
:
stderr
(
)
)
.
map
(
|
t
|
Box
:
:
new
(
t
)
as
Box
<
term
:
:
StderrTerminal
>
)
.
or_else
(
|
|
{
term
:
:
WinConsole
:
:
new
(
io
:
:
stderr
(
)
)
.
ok
(
)
.
map
(
|
t
|
Box
:
:
new
(
t
)
as
Box
<
term
:
:
StderrTerminal
>
)
}
)
;
match
stderr
{
Some
(
t
)
=
>
Terminal
(
t
)
None
=
>
Raw
(
Box
:
:
new
(
io
:
:
stderr
(
)
)
)
}
}
fn
apply_style
(
&
mut
self
lvl
:
Level
style
:
Style
)
-
>
io
:
:
Result
<
(
)
>
{
match
style
{
Style
:
:
FileNameStyle
|
Style
:
:
LineAndColumn
=
>
{
}
Style
:
:
LineNumber
=
>
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
Bold
)
)
;
if
cfg
!
(
windows
)
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
ForegroundColor
(
term
:
:
color
:
:
BRIGHT_CYAN
)
)
)
;
}
else
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
ForegroundColor
(
term
:
:
color
:
:
BRIGHT_BLUE
)
)
)
;
}
}
Style
:
:
ErrorCode
=
>
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
Bold
)
)
;
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
ForegroundColor
(
term
:
:
color
:
:
BRIGHT_MAGENTA
)
)
)
;
}
Style
:
:
Quotation
=
>
{
}
Style
:
:
OldSchoolNote
=
>
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
Bold
)
)
;
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
ForegroundColor
(
term
:
:
color
:
:
BRIGHT_GREEN
)
)
)
;
}
Style
:
:
OldSchoolNoteText
|
Style
:
:
HeaderMsg
=
>
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
Bold
)
)
;
if
cfg
!
(
windows
)
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
ForegroundColor
(
term
:
:
color
:
:
BRIGHT_WHITE
)
)
)
;
}
}
Style
:
:
UnderlinePrimary
|
Style
:
:
LabelPrimary
=
>
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
Bold
)
)
;
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
ForegroundColor
(
lvl
.
color
(
)
)
)
)
;
}
Style
:
:
UnderlineSecondary
|
Style
:
:
LabelSecondary
=
>
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
Bold
)
)
;
if
cfg
!
(
windows
)
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
ForegroundColor
(
term
:
:
color
:
:
BRIGHT_CYAN
)
)
)
;
}
else
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
ForegroundColor
(
term
:
:
color
:
:
BRIGHT_BLUE
)
)
)
;
}
}
Style
:
:
NoStyle
=
>
{
}
Style
:
:
Level
(
l
)
=
>
{
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
Bold
)
)
;
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
ForegroundColor
(
l
.
color
(
)
)
)
)
;
}
Style
:
:
Highlight
=
>
try
!
(
self
.
start_attr
(
term
:
:
Attr
:
:
Bold
)
)
}
Ok
(
(
)
)
}
fn
start_attr
(
&
mut
self
attr
:
term
:
:
Attr
)
-
>
io
:
:
Result
<
(
)
>
{
match
*
self
{
Terminal
(
ref
mut
t
)
=
>
{
try
!
(
t
.
attr
(
attr
)
)
;
}
BufferedTerminal
(
ref
mut
t
)
=
>
{
try
!
(
t
.
attr
(
attr
)
)
;
}
Raw
(
_
)
=
>
{
}
}
Ok
(
(
)
)
}
fn
reset_attrs
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
match
*
self
{
Terminal
(
ref
mut
t
)
=
>
{
try
!
(
t
.
reset
(
)
)
;
}
BufferedTerminal
(
ref
mut
t
)
=
>
{
try
!
(
t
.
reset
(
)
)
;
}
Raw
(
_
)
=
>
{
}
}
Ok
(
(
)
)
}
}
impl
Write
for
Destination
{
fn
write
(
&
mut
self
bytes
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
match
*
self
{
Terminal
(
ref
mut
t
)
=
>
t
.
write
(
bytes
)
BufferedTerminal
(
ref
mut
t
)
=
>
t
.
write
(
bytes
)
Raw
(
ref
mut
w
)
=
>
w
.
write
(
bytes
)
}
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
match
*
self
{
Terminal
(
ref
mut
t
)
=
>
t
.
flush
(
)
BufferedTerminal
(
ref
mut
t
)
=
>
t
.
flush
(
)
Raw
(
ref
mut
w
)
=
>
w
.
flush
(
)
}
}
}
