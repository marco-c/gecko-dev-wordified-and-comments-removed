#
!
[
warn
(
missing_docs
)
]
mod
bsp
;
mod
clip
;
mod
polygon
;
pub
use
polygon
:
:
PlaneCut
;
use
euclid
:
:
{
approxeq
:
:
ApproxEq
default
:
:
{
Point3D
Scale
Vector3D
}
}
;
use
std
:
:
ops
;
pub
use
self
:
:
bsp
:
:
BspSplitter
;
pub
use
self
:
:
clip
:
:
Clipper
;
pub
use
self
:
:
polygon
:
:
{
Intersection
LineProjection
Polygon
}
;
fn
is_zero
(
value
:
f64
)
-
>
bool
{
(
value
*
value
)
.
approx_eq
(
&
0
.
0
)
}
fn
is_zero_vec
(
vec
:
Vector3D
<
f64
>
)
-
>
bool
{
vec
.
dot
(
vec
)
.
approx_eq
(
&
0
.
0
)
}
#
[
derive
(
Debug
)
]
pub
struct
Line
{
pub
origin
:
Point3D
<
f64
>
pub
dir
:
Vector3D
<
f64
>
}
impl
Line
{
pub
fn
is_valid
(
&
self
)
-
>
bool
{
is_zero
(
self
.
dir
.
dot
(
self
.
dir
)
-
1
.
0
)
}
pub
fn
matches
(
&
self
other
:
&
Self
)
-
>
bool
{
let
diff
=
self
.
origin
-
other
.
origin
;
is_zero_vec
(
self
.
dir
.
cross
(
other
.
dir
)
)
&
&
is_zero_vec
(
self
.
dir
.
cross
(
diff
)
)
}
fn
intersect_edge
(
&
self
edge
:
ops
:
:
Range
<
Point3D
<
f64
>
>
)
-
>
Option
<
f64
>
{
let
edge_vec
=
edge
.
end
-
edge
.
start
;
let
origin_vec
=
self
.
origin
-
edge
.
start
;
let
pr
=
origin_vec
-
self
.
dir
*
self
.
dir
.
dot
(
origin_vec
)
;
let
pb
=
edge_vec
-
self
.
dir
*
self
.
dir
.
dot
(
edge_vec
)
;
let
denom
=
pb
.
dot
(
pb
)
;
if
denom
.
approx_eq
(
&
0
.
0
)
{
None
}
else
{
Some
(
pr
.
dot
(
pb
)
/
denom
)
}
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
Plane
{
pub
normal
:
Vector3D
<
f64
>
pub
offset
:
f64
}
impl
Clone
for
Plane
{
fn
clone
(
&
self
)
-
>
Self
{
Plane
{
normal
:
self
.
normal
.
clone
(
)
offset
:
self
.
offset
.
clone
(
)
}
}
}
#
[
derive
(
Clone
Debug
Hash
PartialEq
PartialOrd
)
]
pub
struct
NegativeHemisphereError
;
impl
Plane
{
pub
fn
from_unnormalized
(
normal
:
Vector3D
<
f64
>
offset
:
f64
)
-
>
Result
<
Option
<
Self
>
NegativeHemisphereError
>
{
let
square_len
=
normal
.
square_length
(
)
;
if
square_len
<
f64
:
:
approx_epsilon
(
)
*
f64
:
:
approx_epsilon
(
)
{
if
offset
>
0
.
0
{
Ok
(
None
)
}
else
{
Err
(
NegativeHemisphereError
)
}
}
else
{
let
kf
=
1
.
0
/
square_len
.
sqrt
(
)
;
Ok
(
Some
(
Plane
{
normal
:
normal
*
Scale
:
:
new
(
kf
)
offset
:
offset
*
kf
}
)
)
}
}
pub
fn
contains
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
normal
=
=
other
.
normal
&
&
self
.
offset
=
=
other
.
offset
}
pub
fn
signed_distance_to
(
&
self
point
:
&
Point3D
<
f64
>
)
-
>
f64
{
point
.
to_vector
(
)
.
dot
(
self
.
normal
)
+
self
.
offset
}
pub
fn
distance_to_line
(
&
self
line
:
&
Line
)
-
>
f64
{
self
.
signed_distance_to
(
&
line
.
origin
)
/
-
self
.
normal
.
dot
(
line
.
dir
)
}
pub
fn
signed_distance_sum_to
<
A
>
(
&
self
poly
:
&
Polygon
<
A
>
)
-
>
f64
{
poly
.
points
.
iter
(
)
.
fold
(
0
.
0
|
u
p
|
u
+
self
.
signed_distance_to
(
p
)
)
}
pub
fn
are_outside
(
&
self
points
:
&
[
Point3D
<
f64
>
]
)
-
>
bool
{
let
d0
=
self
.
signed_distance_to
(
&
points
[
0
]
)
;
points
[
1
.
.
]
.
iter
(
)
.
all
(
|
p
|
self
.
signed_distance_to
(
p
)
*
d0
>
0
.
0
)
}
pub
fn
intersect
(
&
self
other
:
&
Self
)
-
>
Option
<
Line
>
{
let
w
=
self
.
normal
.
dot
(
other
.
normal
)
;
let
divisor
=
1
.
0
-
w
*
w
;
if
divisor
<
f64
:
:
approx_epsilon
(
)
*
f64
:
:
approx_epsilon
(
)
{
return
None
;
}
let
origin
=
Point3D
:
:
origin
(
)
+
self
.
normal
*
(
(
other
.
offset
*
w
-
self
.
offset
)
/
divisor
)
-
other
.
normal
*
(
(
other
.
offset
-
self
.
offset
*
w
)
/
divisor
)
;
let
cross_dir
=
self
.
normal
.
cross
(
other
.
normal
)
;
Some
(
Line
{
origin
dir
:
cross_dir
.
normalize
(
)
}
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
make_grid
(
count
:
usize
)
-
>
Vec
<
Polygon
<
usize
>
>
{
let
mut
polys
:
Vec
<
Polygon
<
usize
>
>
=
Vec
:
:
with_capacity
(
count
*
3
)
;
let
len
=
count
as
f64
;
polys
.
extend
(
(
0
.
.
count
)
.
map
(
|
i
|
Polygon
{
points
:
[
Point3D
:
:
new
(
0
.
0
i
as
f64
0
.
0
)
Point3D
:
:
new
(
len
i
as
f64
0
.
0
)
Point3D
:
:
new
(
len
i
as
f64
len
)
Point3D
:
:
new
(
0
.
0
i
as
f64
len
)
]
plane
:
Plane
{
normal
:
Vector3D
:
:
new
(
0
.
0
1
.
0
0
.
0
)
offset
:
-
(
i
as
f64
)
}
anchor
:
0
}
)
)
;
polys
.
extend
(
(
0
.
.
count
)
.
map
(
|
i
|
Polygon
{
points
:
[
Point3D
:
:
new
(
i
as
f64
0
.
0
0
.
0
)
Point3D
:
:
new
(
i
as
f64
len
0
.
0
)
Point3D
:
:
new
(
i
as
f64
len
len
)
Point3D
:
:
new
(
i
as
f64
0
.
0
len
)
]
plane
:
Plane
{
normal
:
Vector3D
:
:
new
(
1
.
0
0
.
0
0
.
0
)
offset
:
-
(
i
as
f64
)
}
anchor
:
0
}
)
)
;
polys
.
extend
(
(
0
.
.
count
)
.
map
(
|
i
|
Polygon
{
points
:
[
Point3D
:
:
new
(
0
.
0
0
.
0
i
as
f64
)
Point3D
:
:
new
(
len
0
.
0
i
as
f64
)
Point3D
:
:
new
(
len
len
i
as
f64
)
Point3D
:
:
new
(
0
.
0
len
i
as
f64
)
]
plane
:
Plane
{
normal
:
Vector3D
:
:
new
(
0
.
0
0
.
0
1
.
0
)
offset
:
-
(
i
as
f64
)
}
anchor
:
0
}
)
)
;
polys
}
