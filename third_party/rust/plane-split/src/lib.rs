#
!
[
warn
(
missing_docs
)
]
extern
crate
binary_space_partition
;
extern
crate
euclid
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
num_traits
;
mod
bsp
;
mod
naive
;
use
std
:
:
{
fmt
mem
ops
}
;
use
euclid
:
:
{
Point2D
TypedMatrix4D
TypedPoint3D
TypedRect
}
;
use
euclid
:
:
approxeq
:
:
ApproxEq
;
use
euclid
:
:
trig
:
:
Trig
;
use
num_traits
:
:
{
Float
One
Zero
}
;
pub
use
self
:
:
bsp
:
:
BspSplitter
;
pub
use
self
:
:
naive
:
:
NaiveSplitter
;
fn
is_zero
<
T
>
(
value
:
T
)
-
>
bool
where
T
:
Copy
+
Zero
+
ApproxEq
<
T
>
+
ops
:
:
Mul
<
T
Output
=
T
>
{
(
value
*
value
)
.
approx_eq
(
&
T
:
:
zero
(
)
)
}
fn
is_zero_vec
<
T
U
>
(
vec
:
TypedPoint3D
<
T
U
>
)
-
>
bool
where
T
:
Copy
+
Zero
+
ApproxEq
<
T
>
+
ops
:
:
Add
<
T
Output
=
T
>
+
ops
:
:
Sub
<
T
Output
=
T
>
+
ops
:
:
Mul
<
T
Output
=
T
>
{
vec
.
dot
(
vec
)
.
approx_eq
(
&
T
:
:
zero
(
)
)
}
#
[
derive
(
Debug
)
]
pub
struct
Line
<
T
U
>
{
pub
origin
:
TypedPoint3D
<
T
U
>
pub
dir
:
TypedPoint3D
<
T
U
>
}
impl
<
T
U
>
Line
<
T
U
>
where
T
:
Copy
+
One
+
Zero
+
ApproxEq
<
T
>
+
ops
:
:
Add
<
T
Output
=
T
>
+
ops
:
:
Sub
<
T
Output
=
T
>
+
ops
:
:
Mul
<
T
Output
=
T
>
{
pub
fn
is_valid
(
&
self
)
-
>
bool
{
is_zero
(
self
.
dir
.
dot
(
self
.
dir
)
-
T
:
:
one
(
)
)
}
pub
fn
matches
(
&
self
other
:
&
Self
)
-
>
bool
{
let
diff
=
self
.
origin
-
other
.
origin
;
is_zero_vec
(
self
.
dir
.
cross
(
other
.
dir
)
)
&
&
is_zero_vec
(
self
.
dir
.
cross
(
diff
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
Polygon
<
T
U
>
{
pub
points
:
[
TypedPoint3D
<
T
U
>
;
4
]
pub
normal
:
TypedPoint3D
<
T
U
>
pub
offset
:
T
pub
anchor
:
usize
}
impl
<
T
:
Clone
U
>
Clone
for
Polygon
<
T
U
>
{
fn
clone
(
&
self
)
-
>
Self
{
Polygon
{
points
:
[
self
.
points
[
0
]
.
clone
(
)
self
.
points
[
1
]
.
clone
(
)
self
.
points
[
2
]
.
clone
(
)
self
.
points
[
3
]
.
clone
(
)
]
normal
:
self
.
normal
.
clone
(
)
offset
:
self
.
offset
.
clone
(
)
anchor
:
self
.
anchor
}
}
}
pub
struct
LineProjection
<
T
>
{
pub
markers
:
[
T
;
4
]
}
impl
<
T
>
LineProjection
<
T
>
where
T
:
Copy
+
PartialOrd
+
ops
:
:
Sub
<
T
Output
=
T
>
+
ops
:
:
Add
<
T
Output
=
T
>
{
pub
fn
get_bounds
(
&
self
)
-
>
(
T
T
)
{
let
(
mut
a
mut
b
mut
c
mut
d
)
=
(
self
.
markers
[
0
]
self
.
markers
[
1
]
self
.
markers
[
2
]
self
.
markers
[
3
]
)
;
if
a
>
c
{
mem
:
:
swap
(
&
mut
a
&
mut
c
)
;
}
if
b
>
d
{
mem
:
:
swap
(
&
mut
b
&
mut
d
)
;
}
if
a
>
b
{
mem
:
:
swap
(
&
mut
a
&
mut
b
)
;
}
if
c
>
d
{
mem
:
:
swap
(
&
mut
c
&
mut
d
)
;
}
if
b
>
c
{
mem
:
:
swap
(
&
mut
b
&
mut
c
)
;
}
debug_assert
!
(
a
<
=
b
&
&
b
<
=
c
&
&
c
<
=
d
)
;
(
a
d
)
}
pub
fn
intersect
(
&
self
other
:
&
Self
)
-
>
bool
{
let
span
=
self
.
get_bounds
(
)
;
let
other_span
=
other
.
get_bounds
(
)
;
let
left
=
if
span
.
0
<
other_span
.
0
{
span
.
0
}
else
{
other_span
.
0
}
;
let
right
=
if
span
.
1
>
other_span
.
1
{
span
.
1
}
else
{
other_span
.
1
}
;
right
-
left
<
span
.
1
-
span
.
0
+
other_span
.
1
-
other_span
.
0
}
}
pub
enum
Intersection
<
T
>
{
Coplanar
Outside
Inside
(
T
)
}
impl
<
T
>
Intersection
<
T
>
{
pub
fn
is_outside
(
&
self
)
-
>
bool
{
match
*
self
{
Intersection
:
:
Outside
=
>
true
_
=
>
false
}
}
pub
fn
is_inside
(
&
self
)
-
>
bool
{
match
*
self
{
Intersection
:
:
Inside
(
_
)
=
>
true
_
=
>
false
}
}
}
impl
<
T
U
>
Polygon
<
T
U
>
where
T
:
Copy
+
fmt
:
:
Debug
+
ApproxEq
<
T
>
+
ops
:
:
Sub
<
T
Output
=
T
>
+
ops
:
:
Add
<
T
Output
=
T
>
+
ops
:
:
Mul
<
T
Output
=
T
>
+
ops
:
:
Div
<
T
Output
=
T
>
+
Zero
+
One
+
Float
U
:
fmt
:
:
Debug
{
pub
fn
from_transformed_rect
<
V
>
(
rect
:
TypedRect
<
T
V
>
transform
:
TypedMatrix4D
<
T
V
U
>
anchor
:
usize
)
-
>
Polygon
<
T
U
>
where
T
:
Trig
+
ops
:
:
Neg
<
Output
=
T
>
{
let
points
=
[
transform
.
transform_point3d
(
&
rect
.
origin
.
to_3d
(
)
)
transform
.
transform_point3d
(
&
rect
.
top_right
(
)
.
to_3d
(
)
)
transform
.
transform_point3d
(
&
rect
.
bottom_right
(
)
.
to_3d
(
)
)
transform
.
transform_point3d
(
&
rect
.
bottom_left
(
)
.
to_3d
(
)
)
]
;
let
normal
=
(
points
[
1
]
-
points
[
0
]
)
.
cross
(
points
[
2
]
-
points
[
0
]
)
.
normalize
(
)
;
let
offset
=
-
TypedPoint3D
:
:
new
(
transform
.
m41
transform
.
m42
transform
.
m43
)
.
dot
(
normal
)
;
Polygon
{
points
:
points
normal
:
normal
offset
:
offset
anchor
:
anchor
}
}
pub
fn
untransform_point
(
&
self
point
:
TypedPoint3D
<
T
U
>
)
-
>
Point2D
<
T
>
{
let
a
=
self
.
points
[
1
]
-
self
.
points
[
0
]
;
let
b
=
self
.
points
[
3
]
-
self
.
points
[
0
]
;
let
c
=
point
-
self
.
points
[
0
]
;
let
a2
=
a
.
dot
(
a
)
;
let
ab
=
a
.
dot
(
b
)
;
let
b2
=
b
.
dot
(
b
)
;
let
ca
=
c
.
dot
(
a
)
;
let
cb
=
c
.
dot
(
b
)
;
let
denom
=
ab
*
ab
-
a2
*
b2
;
let
x
=
ab
*
cb
-
b2
*
ca
;
let
y
=
ab
*
ca
-
a2
*
cb
;
Point2D
:
:
new
(
x
y
)
/
denom
}
pub
fn
signed_distance_to
(
&
self
point
:
&
TypedPoint3D
<
T
U
>
)
-
>
T
{
point
.
dot
(
self
.
normal
)
+
self
.
offset
}
pub
fn
distance_to_line
(
&
self
line
:
&
Line
<
T
U
>
)
-
>
T
where
T
:
ops
:
:
Neg
<
Output
=
T
>
{
self
.
signed_distance_to
(
&
line
.
origin
)
/
-
self
.
normal
.
dot
(
line
.
dir
)
}
pub
fn
signed_distance_sum_to
(
&
self
other
:
&
Self
)
-
>
T
{
other
.
points
.
iter
(
)
.
fold
(
T
:
:
zero
(
)
|
sum
p
|
{
sum
+
self
.
signed_distance_to
(
p
)
}
)
}
pub
fn
is_valid
(
&
self
)
-
>
bool
{
let
is_planar
=
self
.
points
.
iter
(
)
.
all
(
|
p
|
is_zero
(
self
.
signed_distance_to
(
p
)
)
)
;
let
edges
=
[
self
.
points
[
1
]
-
self
.
points
[
0
]
self
.
points
[
2
]
-
self
.
points
[
1
]
self
.
points
[
3
]
-
self
.
points
[
2
]
self
.
points
[
0
]
-
self
.
points
[
3
]
]
;
let
anchor
=
edges
[
3
]
.
cross
(
edges
[
0
]
)
;
let
is_winding
=
edges
.
iter
(
)
.
zip
(
edges
[
1
.
.
]
.
iter
(
)
)
.
all
(
|
(
a
&
b
)
|
a
.
cross
(
b
)
.
dot
(
anchor
)
>
=
T
:
:
zero
(
)
)
;
is_planar
&
&
is_winding
}
pub
fn
are_outside
(
&
self
points
:
&
[
TypedPoint3D
<
T
U
>
]
)
-
>
bool
{
let
d0
=
self
.
signed_distance_to
(
&
points
[
0
]
)
;
points
[
1
.
.
]
.
iter
(
)
.
all
(
|
p
|
self
.
signed_distance_to
(
p
)
*
d0
>
T
:
:
zero
(
)
)
}
pub
fn
contains
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
normal
=
=
other
.
normal
&
&
self
.
offset
=
=
other
.
offset
}
pub
fn
project_on
(
&
self
vector
:
&
TypedPoint3D
<
T
U
>
)
-
>
LineProjection
<
T
>
{
LineProjection
{
markers
:
[
vector
.
dot
(
self
.
points
[
0
]
)
vector
.
dot
(
self
.
points
[
1
]
)
vector
.
dot
(
self
.
points
[
2
]
)
vector
.
dot
(
self
.
points
[
3
]
)
]
}
}
pub
fn
intersect
(
&
self
other
:
&
Self
)
-
>
Intersection
<
Line
<
T
U
>
>
{
if
self
.
are_outside
(
&
other
.
points
)
|
|
other
.
are_outside
(
&
self
.
points
)
{
debug
!
(
"
\
t
\
tOutside
"
)
;
return
Intersection
:
:
Outside
}
let
cross_dir
=
self
.
normal
.
cross
(
other
.
normal
)
;
if
cross_dir
.
dot
(
cross_dir
)
<
T
:
:
approx_epsilon
(
)
{
debug
!
(
"
\
t
\
tCoplanar
"
)
;
return
Intersection
:
:
Coplanar
}
let
self_proj
=
self
.
project_on
(
&
cross_dir
)
;
let
other_proj
=
other
.
project_on
(
&
cross_dir
)
;
if
!
self_proj
.
intersect
(
&
other_proj
)
{
debug
!
(
"
\
t
\
tProjection
outside
"
)
;
return
Intersection
:
:
Outside
}
let
w
=
self
.
normal
.
dot
(
other
.
normal
)
;
let
factor
=
T
:
:
one
(
)
/
(
T
:
:
one
(
)
-
w
*
w
)
;
let
center
=
self
.
normal
*
(
(
other
.
offset
*
w
-
self
.
offset
)
*
factor
)
-
other
.
normal
*
(
(
other
.
offset
-
self
.
offset
*
w
)
*
factor
)
;
Intersection
:
:
Inside
(
Line
{
origin
:
center
dir
:
cross_dir
.
normalize
(
)
}
)
}
pub
fn
split
(
&
mut
self
line
:
&
Line
<
T
U
>
)
-
>
(
Option
<
Polygon
<
T
U
>
>
Option
<
Polygon
<
T
U
>
>
)
{
debug
!
(
"
\
tSplitting
"
)
;
if
!
is_zero
(
self
.
normal
.
dot
(
line
.
dir
)
)
|
|
!
is_zero
(
self
.
signed_distance_to
(
&
line
.
origin
)
)
{
debug
!
(
"
\
t
\
tDoes
not
belong
to
the
plane
normal
dot
=
{
:
?
}
origin
distance
=
{
:
?
}
"
self
.
normal
.
dot
(
line
.
dir
)
self
.
signed_distance_to
(
&
line
.
origin
)
)
;
return
(
None
None
)
}
let
mut
cuts
=
[
None
;
4
]
;
for
(
(
&
b
&
a
)
cut
)
in
self
.
points
.
iter
(
)
.
cycle
(
)
.
skip
(
1
)
.
zip
(
self
.
points
.
iter
(
)
)
.
zip
(
cuts
.
iter_mut
(
)
)
{
let
pr
=
line
.
origin
-
a
-
line
.
dir
*
line
.
dir
.
dot
(
line
.
origin
-
a
)
;
let
pb
=
b
-
a
-
line
.
dir
*
line
.
dir
.
dot
(
b
-
a
)
;
let
denom
=
pb
.
dot
(
pb
)
;
if
!
denom
.
approx_eq
(
&
T
:
:
zero
(
)
)
{
let
t
=
pr
.
dot
(
pb
)
/
denom
;
if
t
>
T
:
:
zero
(
)
&
&
t
<
T
:
:
one
(
)
{
*
cut
=
Some
(
a
+
(
b
-
a
)
*
t
)
;
}
}
}
let
first
=
match
cuts
.
iter
(
)
.
position
(
|
c
|
c
.
is_some
(
)
)
{
Some
(
pos
)
=
>
pos
None
=
>
return
(
None
None
)
}
;
let
second
=
match
cuts
[
first
+
1
.
.
]
.
iter
(
)
.
position
(
|
c
|
c
.
is_some
(
)
)
{
Some
(
pos
)
=
>
first
+
1
+
pos
None
=
>
return
(
None
None
)
}
;
debug
!
(
"
\
t
\
tReached
complex
case
[
{
}
{
}
]
"
first
second
)
;
let
(
a
b
)
=
(
cuts
[
first
]
.
unwrap
(
)
cuts
[
second
]
.
unwrap
(
)
)
;
match
second
-
first
{
2
=
>
{
let
mut
other_points
=
self
.
points
;
other_points
[
first
]
=
a
;
other_points
[
(
first
+
3
)
%
4
]
=
b
;
self
.
points
[
first
+
1
]
=
a
;
self
.
points
[
first
+
2
]
=
b
;
let
poly
=
Polygon
{
points
:
other_points
.
.
self
.
clone
(
)
}
;
(
Some
(
poly
)
None
)
}
3
=
>
{
let
xpoints
=
[
self
.
points
[
first
+
1
]
self
.
points
[
first
+
2
]
self
.
points
[
first
+
3
]
b
]
;
let
ypoints
=
[
a
self
.
points
[
first
+
1
]
b
b
]
;
self
.
points
=
[
self
.
points
[
first
]
a
b
b
]
;
let
poly1
=
Polygon
{
points
:
xpoints
.
.
self
.
clone
(
)
}
;
let
poly2
=
Polygon
{
points
:
ypoints
.
.
self
.
clone
(
)
}
;
(
Some
(
poly1
)
Some
(
poly2
)
)
}
1
=
>
{
let
xpoints
=
[
b
self
.
points
[
(
first
+
2
)
%
4
]
self
.
points
[
(
first
+
3
)
%
4
]
self
.
points
[
first
]
]
;
let
ypoints
=
[
self
.
points
[
first
]
a
b
b
]
;
self
.
points
=
[
a
self
.
points
[
first
+
1
]
b
b
]
;
let
poly1
=
Polygon
{
points
:
xpoints
.
.
self
.
clone
(
)
}
;
let
poly2
=
Polygon
{
points
:
ypoints
.
.
self
.
clone
(
)
}
;
(
Some
(
poly1
)
Some
(
poly2
)
)
}
_
=
>
panic
!
(
"
Unexpected
indices
{
}
{
}
"
first
second
)
}
}
}
pub
trait
Splitter
<
T
U
>
{
fn
reset
(
&
mut
self
)
;
fn
add
(
&
mut
self
Polygon
<
T
U
>
)
;
fn
sort
(
&
mut
self
TypedPoint3D
<
T
U
>
)
-
>
&
[
Polygon
<
T
U
>
]
;
fn
solve
(
&
mut
self
input
:
&
[
Polygon
<
T
U
>
]
view
:
TypedPoint3D
<
T
U
>
)
-
>
&
[
Polygon
<
T
U
>
]
where
T
:
Clone
U
:
Clone
{
self
.
reset
(
)
;
for
p
in
input
.
iter
(
)
{
self
.
add
(
p
.
clone
(
)
)
;
}
self
.
sort
(
view
)
}
}
pub
fn
_make_grid
(
count
:
usize
)
-
>
Vec
<
Polygon
<
f32
(
)
>
>
{
let
mut
polys
:
Vec
<
Polygon
<
f32
(
)
>
>
=
Vec
:
:
with_capacity
(
count
*
3
)
;
let
len
=
count
as
f32
;
polys
.
extend
(
(
0
.
.
count
)
.
map
(
|
i
|
Polygon
{
points
:
[
TypedPoint3D
:
:
new
(
0
.
0
i
as
f32
0
.
0
)
TypedPoint3D
:
:
new
(
len
i
as
f32
0
.
0
)
TypedPoint3D
:
:
new
(
len
i
as
f32
len
)
TypedPoint3D
:
:
new
(
0
.
0
i
as
f32
len
)
]
normal
:
TypedPoint3D
:
:
new
(
0
.
0
1
.
0
0
.
0
)
offset
:
-
(
i
as
f32
)
anchor
:
0
}
)
)
;
polys
.
extend
(
(
0
.
.
count
)
.
map
(
|
i
|
Polygon
{
points
:
[
TypedPoint3D
:
:
new
(
i
as
f32
0
.
0
0
.
0
)
TypedPoint3D
:
:
new
(
i
as
f32
len
0
.
0
)
TypedPoint3D
:
:
new
(
i
as
f32
len
len
)
TypedPoint3D
:
:
new
(
i
as
f32
0
.
0
len
)
]
normal
:
TypedPoint3D
:
:
new
(
1
.
0
0
.
0
0
.
0
)
offset
:
-
(
i
as
f32
)
anchor
:
0
}
)
)
;
polys
.
extend
(
(
0
.
.
count
)
.
map
(
|
i
|
Polygon
{
points
:
[
TypedPoint3D
:
:
new
(
0
.
0
0
.
0
i
as
f32
)
TypedPoint3D
:
:
new
(
len
0
.
0
i
as
f32
)
TypedPoint3D
:
:
new
(
len
len
i
as
f32
)
TypedPoint3D
:
:
new
(
0
.
0
len
i
as
f32
)
]
normal
:
TypedPoint3D
:
:
new
(
0
.
0
0
.
0
1
.
0
)
offset
:
-
(
i
as
f32
)
anchor
:
0
}
)
)
;
polys
}
