#
!
[
warn
(
missing_docs
)
]
extern
crate
binary_space_partition
;
extern
crate
euclid
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
num_traits
;
mod
bsp
;
mod
polygon
;
use
std
:
:
{
fmt
mem
ops
}
;
use
euclid
:
:
{
TypedPoint3D
TypedVector3D
}
;
use
euclid
:
:
approxeq
:
:
ApproxEq
;
use
num_traits
:
:
{
Float
One
Zero
}
;
pub
use
self
:
:
bsp
:
:
BspSplitter
;
pub
use
self
:
:
polygon
:
:
{
Intersection
LineProjection
Polygon
}
;
fn
is_zero
<
T
>
(
value
:
T
)
-
>
bool
where
T
:
Copy
+
Zero
+
ApproxEq
<
T
>
+
ops
:
:
Mul
<
T
Output
=
T
>
{
(
value
*
value
)
.
approx_eq
(
&
T
:
:
zero
(
)
)
}
fn
is_zero_vec
<
T
U
>
(
vec
:
TypedVector3D
<
T
U
>
)
-
>
bool
where
T
:
Copy
+
Zero
+
ApproxEq
<
T
>
+
ops
:
:
Add
<
T
Output
=
T
>
+
ops
:
:
Sub
<
T
Output
=
T
>
+
ops
:
:
Mul
<
T
Output
=
T
>
{
vec
.
dot
(
vec
)
.
approx_eq
(
&
T
:
:
zero
(
)
)
}
#
[
derive
(
Debug
)
]
pub
struct
Line
<
T
U
>
{
pub
origin
:
TypedPoint3D
<
T
U
>
pub
dir
:
TypedVector3D
<
T
U
>
}
impl
<
T
U
>
Line
<
T
U
>
where
T
:
Copy
+
One
+
Zero
+
ApproxEq
<
T
>
+
ops
:
:
Add
<
T
Output
=
T
>
+
ops
:
:
Sub
<
T
Output
=
T
>
+
ops
:
:
Mul
<
T
Output
=
T
>
{
pub
fn
is_valid
(
&
self
)
-
>
bool
{
is_zero
(
self
.
dir
.
dot
(
self
.
dir
)
-
T
:
:
one
(
)
)
}
pub
fn
matches
(
&
self
other
:
&
Self
)
-
>
bool
{
let
diff
=
self
.
origin
-
other
.
origin
;
is_zero_vec
(
self
.
dir
.
cross
(
other
.
dir
)
)
&
&
is_zero_vec
(
self
.
dir
.
cross
(
diff
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
Plane
<
T
U
>
{
pub
normal
:
TypedVector3D
<
T
U
>
pub
offset
:
T
}
impl
<
T
:
Clone
U
>
Clone
for
Plane
<
T
U
>
{
fn
clone
(
&
self
)
-
>
Self
{
Plane
{
normal
:
self
.
normal
.
clone
(
)
offset
:
self
.
offset
.
clone
(
)
}
}
}
impl
<
T
:
Copy
+
Zero
+
One
+
Float
+
ApproxEq
<
T
>
+
ops
:
:
Sub
<
T
Output
=
T
>
+
ops
:
:
Add
<
T
Output
=
T
>
+
ops
:
:
Mul
<
T
Output
=
T
>
+
ops
:
:
Div
<
T
Output
=
T
>
U
>
Plane
<
T
U
>
{
pub
fn
contains
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
normal
=
=
other
.
normal
&
&
self
.
offset
=
=
other
.
offset
}
pub
fn
signed_distance_to
(
&
self
point
:
&
TypedPoint3D
<
T
U
>
)
-
>
T
{
point
.
to_vector
(
)
.
dot
(
self
.
normal
)
+
self
.
offset
}
pub
fn
distance_to_line
(
&
self
line
:
&
Line
<
T
U
>
)
-
>
T
where
T
:
ops
:
:
Neg
<
Output
=
T
>
{
self
.
signed_distance_to
(
&
line
.
origin
)
/
-
self
.
normal
.
dot
(
line
.
dir
)
}
pub
fn
signed_distance_sum_to
(
&
self
poly
:
&
Polygon
<
T
U
>
)
-
>
T
{
poly
.
points
.
iter
(
)
.
fold
(
T
:
:
zero
(
)
|
u
p
|
u
+
self
.
signed_distance_to
(
p
)
)
}
pub
fn
are_outside
(
&
self
points
:
&
[
TypedPoint3D
<
T
U
>
]
)
-
>
bool
{
let
d0
=
self
.
signed_distance_to
(
&
points
[
0
]
)
;
points
[
1
.
.
]
.
iter
(
)
.
all
(
|
p
|
self
.
signed_distance_to
(
p
)
*
d0
>
T
:
:
zero
(
)
)
}
pub
fn
intersect
(
&
self
other
:
&
Self
)
-
>
Option
<
Line
<
T
U
>
>
{
let
cross_dir
=
self
.
normal
.
cross
(
other
.
normal
)
;
if
cross_dir
.
dot
(
cross_dir
)
<
T
:
:
approx_epsilon
(
)
{
return
None
}
let
w
=
self
.
normal
.
dot
(
other
.
normal
)
;
let
factor
=
T
:
:
one
(
)
/
(
T
:
:
one
(
)
-
w
*
w
)
;
let
origin
=
TypedPoint3D
:
:
origin
(
)
+
self
.
normal
*
(
(
other
.
offset
*
w
-
self
.
offset
)
*
factor
)
-
other
.
normal
*
(
(
other
.
offset
-
self
.
offset
*
w
)
*
factor
)
;
Some
(
Line
{
origin
dir
:
cross_dir
.
normalize
(
)
}
)
}
}
pub
trait
Splitter
<
T
U
>
{
fn
reset
(
&
mut
self
)
;
fn
add
(
&
mut
self
polygon
:
Polygon
<
T
U
>
)
;
fn
sort
(
&
mut
self
view
:
TypedVector3D
<
T
U
>
)
-
>
&
[
Polygon
<
T
U
>
]
;
fn
solve
(
&
mut
self
input
:
&
[
Polygon
<
T
U
>
]
view
:
TypedVector3D
<
T
U
>
)
-
>
&
[
Polygon
<
T
U
>
]
where
T
:
Clone
U
:
Clone
{
self
.
reset
(
)
;
for
p
in
input
{
self
.
add
(
p
.
clone
(
)
)
;
}
self
.
sort
(
view
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Clipper
<
T
U
>
{
clips
:
Vec
<
Plane
<
T
U
>
>
results
:
Vec
<
Polygon
<
T
U
>
>
temp
:
Vec
<
Polygon
<
T
U
>
>
}
impl
<
T
:
Copy
+
fmt
:
:
Debug
+
ApproxEq
<
T
>
+
ops
:
:
Sub
<
T
Output
=
T
>
+
ops
:
:
Add
<
T
Output
=
T
>
+
ops
:
:
Mul
<
T
Output
=
T
>
+
ops
:
:
Div
<
T
Output
=
T
>
+
Zero
+
One
+
Float
U
:
fmt
:
:
Debug
>
Clipper
<
T
U
>
{
pub
fn
new
(
)
-
>
Self
{
Clipper
{
clips
:
Vec
:
:
new
(
)
results
:
Vec
:
:
new
(
)
temp
:
Vec
:
:
new
(
)
}
}
pub
fn
add
(
&
mut
self
plane
:
Plane
<
T
U
>
)
{
self
.
clips
.
push
(
plane
)
;
}
pub
fn
clip
(
&
mut
self
polygon
:
Polygon
<
T
U
>
)
-
>
&
[
Polygon
<
T
U
>
]
{
self
.
results
.
clear
(
)
;
self
.
results
.
push
(
polygon
)
;
for
clip
in
&
self
.
clips
{
self
.
temp
.
clear
(
)
;
mem
:
:
swap
(
&
mut
self
.
results
&
mut
self
.
temp
)
;
for
mut
poly
in
self
.
temp
.
drain
(
.
.
)
{
if
let
Intersection
:
:
Inside
(
line
)
=
poly
.
intersect_plane
(
clip
)
{
let
(
res1
res2
)
=
poly
.
split
(
&
line
)
;
self
.
results
.
extend
(
res1
.
into_iter
(
)
.
chain
(
res2
.
into_iter
(
)
)
.
filter
(
|
p
|
clip
.
signed_distance_sum_to
(
p
)
>
T
:
:
zero
(
)
)
)
;
}
if
clip
.
signed_distance_sum_to
(
&
poly
)
>
T
:
:
zero
(
)
{
self
.
results
.
push
(
poly
)
;
}
}
}
&
self
.
results
}
}
#
[
doc
(
hidden
)
]
pub
fn
make_grid
(
count
:
usize
)
-
>
Vec
<
Polygon
<
f32
(
)
>
>
{
let
mut
polys
:
Vec
<
Polygon
<
f32
(
)
>
>
=
Vec
:
:
with_capacity
(
count
*
3
)
;
let
len
=
count
as
f32
;
polys
.
extend
(
(
0
.
.
count
)
.
map
(
|
i
|
Polygon
{
points
:
[
TypedPoint3D
:
:
new
(
0
.
0
i
as
f32
0
.
0
)
TypedPoint3D
:
:
new
(
len
i
as
f32
0
.
0
)
TypedPoint3D
:
:
new
(
len
i
as
f32
len
)
TypedPoint3D
:
:
new
(
0
.
0
i
as
f32
len
)
]
plane
:
Plane
{
normal
:
TypedVector3D
:
:
new
(
0
.
0
1
.
0
0
.
0
)
offset
:
-
(
i
as
f32
)
}
anchor
:
0
}
)
)
;
polys
.
extend
(
(
0
.
.
count
)
.
map
(
|
i
|
Polygon
{
points
:
[
TypedPoint3D
:
:
new
(
i
as
f32
0
.
0
0
.
0
)
TypedPoint3D
:
:
new
(
i
as
f32
len
0
.
0
)
TypedPoint3D
:
:
new
(
i
as
f32
len
len
)
TypedPoint3D
:
:
new
(
i
as
f32
0
.
0
len
)
]
plane
:
Plane
{
normal
:
TypedVector3D
:
:
new
(
1
.
0
0
.
0
0
.
0
)
offset
:
-
(
i
as
f32
)
}
anchor
:
0
}
)
)
;
polys
.
extend
(
(
0
.
.
count
)
.
map
(
|
i
|
Polygon
{
points
:
[
TypedPoint3D
:
:
new
(
0
.
0
0
.
0
i
as
f32
)
TypedPoint3D
:
:
new
(
len
0
.
0
i
as
f32
)
TypedPoint3D
:
:
new
(
len
len
i
as
f32
)
TypedPoint3D
:
:
new
(
0
.
0
len
i
as
f32
)
]
plane
:
Plane
{
normal
:
TypedVector3D
:
:
new
(
0
.
0
0
.
0
1
.
0
)
offset
:
-
(
i
as
f32
)
}
anchor
:
0
}
)
)
;
polys
}
