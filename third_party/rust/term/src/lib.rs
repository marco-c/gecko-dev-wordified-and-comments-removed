#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
-
v2
.
png
"
html_favicon_url
=
"
https
:
/
/
doc
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
stebalien
.
github
.
io
/
doc
/
term
/
term
/
"
test
(
attr
(
deny
(
warnings
)
)
)
)
]
#
!
[
deny
(
missing_docs
)
]
#
!
[
cfg_attr
(
test
deny
(
warnings
)
)
]
use
std
:
:
io
:
:
prelude
:
:
*
;
pub
use
terminfo
:
:
TerminfoTerminal
;
#
[
cfg
(
windows
)
]
pub
use
win
:
:
WinConsole
;
use
std
:
:
io
:
:
{
self
Stdout
Stderr
}
;
pub
mod
terminfo
;
#
[
cfg
(
windows
)
]
mod
win
;
pub
type
StdoutTerminal
=
Terminal
<
Output
=
Stdout
>
+
Send
;
pub
type
StderrTerminal
=
Terminal
<
Output
=
Stderr
>
+
Send
;
#
[
cfg
(
not
(
windows
)
)
]
pub
fn
stdout
(
)
-
>
Option
<
Box
<
StdoutTerminal
>
>
{
TerminfoTerminal
:
:
new
(
io
:
:
stdout
(
)
)
.
map
(
|
t
|
Box
:
:
new
(
t
)
as
Box
<
StdoutTerminal
>
)
}
#
[
cfg
(
windows
)
]
pub
fn
stdout
(
)
-
>
Option
<
Box
<
StdoutTerminal
>
>
{
TerminfoTerminal
:
:
new
(
io
:
:
stdout
(
)
)
.
map
(
|
t
|
Box
:
:
new
(
t
)
as
Box
<
StdoutTerminal
>
)
.
or_else
(
|
|
WinConsole
:
:
new
(
io
:
:
stdout
(
)
)
.
ok
(
)
.
map
(
|
t
|
Box
:
:
new
(
t
)
as
Box
<
StdoutTerminal
>
)
)
}
#
[
cfg
(
not
(
windows
)
)
]
pub
fn
stderr
(
)
-
>
Option
<
Box
<
StderrTerminal
>
>
{
TerminfoTerminal
:
:
new
(
io
:
:
stderr
(
)
)
.
map
(
|
t
|
Box
:
:
new
(
t
)
as
Box
<
StderrTerminal
>
)
}
#
[
cfg
(
windows
)
]
pub
fn
stderr
(
)
-
>
Option
<
Box
<
StderrTerminal
>
>
{
TerminfoTerminal
:
:
new
(
io
:
:
stderr
(
)
)
.
map
(
|
t
|
Box
:
:
new
(
t
)
as
Box
<
StderrTerminal
>
)
.
or_else
(
|
|
WinConsole
:
:
new
(
io
:
:
stderr
(
)
)
.
ok
(
)
.
map
(
|
t
|
Box
:
:
new
(
t
)
as
Box
<
StderrTerminal
>
)
)
}
#
[
allow
(
missing_docs
)
]
pub
mod
color
{
pub
type
Color
=
u16
;
pub
const
BLACK
:
Color
=
0
;
pub
const
RED
:
Color
=
1
;
pub
const
GREEN
:
Color
=
2
;
pub
const
YELLOW
:
Color
=
3
;
pub
const
BLUE
:
Color
=
4
;
pub
const
MAGENTA
:
Color
=
5
;
pub
const
CYAN
:
Color
=
6
;
pub
const
WHITE
:
Color
=
7
;
pub
const
BRIGHT_BLACK
:
Color
=
8
;
pub
const
BRIGHT_RED
:
Color
=
9
;
pub
const
BRIGHT_GREEN
:
Color
=
10
;
pub
const
BRIGHT_YELLOW
:
Color
=
11
;
pub
const
BRIGHT_BLUE
:
Color
=
12
;
pub
const
BRIGHT_MAGENTA
:
Color
=
13
;
pub
const
BRIGHT_CYAN
:
Color
=
14
;
pub
const
BRIGHT_WHITE
:
Color
=
15
;
}
#
[
derive
(
Debug
PartialEq
Eq
Copy
Clone
)
]
pub
enum
Attr
{
Bold
Dim
Italic
(
bool
)
Underline
(
bool
)
Blink
Standout
(
bool
)
Reverse
Secure
ForegroundColor
(
color
:
:
Color
)
BackgroundColor
(
color
:
:
Color
)
}
#
[
derive
(
Debug
)
]
pub
enum
Error
{
Io
(
io
:
:
Error
)
TerminfoParsing
(
terminfo
:
:
Error
)
ParameterizedExpansion
(
terminfo
:
:
parm
:
:
Error
)
NotSupported
TermUnset
TerminfoEntryNotFound
CursorDestinationInvalid
ColorOutOfRange
#
[
doc
(
hidden
)
]
__Nonexhaustive
}
impl
std
:
:
cmp
:
:
PartialEq
for
Error
{
fn
eq
(
&
self
other
:
&
Error
)
-
>
bool
{
use
Error
:
:
*
;
match
self
{
&
Io
(
_
)
=
>
false
&
TerminfoParsing
(
ref
inner1
)
=
>
{
match
other
{
&
TerminfoParsing
(
ref
inner2
)
=
>
inner1
=
=
inner2
_
=
>
false
}
}
&
ParameterizedExpansion
(
ref
inner1
)
=
>
{
match
other
{
&
ParameterizedExpansion
(
ref
inner2
)
=
>
inner1
=
=
inner2
_
=
>
false
}
}
&
NotSupported
=
>
{
match
other
{
&
NotSupported
=
>
true
_
=
>
false
}
}
&
TermUnset
=
>
{
match
other
{
&
TermUnset
=
>
true
_
=
>
false
}
}
&
TerminfoEntryNotFound
=
>
{
match
other
{
&
TerminfoEntryNotFound
=
>
true
_
=
>
false
}
}
&
CursorDestinationInvalid
=
>
{
match
other
{
&
CursorDestinationInvalid
=
>
true
_
=
>
false
}
}
&
ColorOutOfRange
=
>
{
match
other
{
&
ColorOutOfRange
=
>
true
_
=
>
false
}
}
&
__Nonexhaustive
=
>
{
match
other
{
&
__Nonexhaustive
=
>
true
_
=
>
false
}
}
}
}
}
pub
type
Result
<
T
>
=
std
:
:
result
:
:
Result
<
T
Error
>
;
impl
std
:
:
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
use
std
:
:
error
:
:
Error
;
if
let
&
:
:
Error
:
:
Io
(
ref
e
)
=
self
{
write
!
(
f
"
{
}
"
e
)
}
else
{
f
.
write_str
(
self
.
description
(
)
)
}
}
}
impl
std
:
:
error
:
:
Error
for
Error
{
fn
description
(
&
self
)
-
>
&
str
{
use
Error
:
:
*
;
use
std
:
:
error
:
:
Error
;
match
self
{
&
Io
(
ref
io
)
=
>
io
.
description
(
)
&
TerminfoParsing
(
ref
e
)
=
>
e
.
description
(
)
&
ParameterizedExpansion
(
ref
e
)
=
>
e
.
description
(
)
&
NotSupported
=
>
"
operation
not
supported
by
the
terminal
"
&
TermUnset
=
>
"
TERM
environment
variable
unset
unable
to
detect
a
terminal
"
&
TerminfoEntryNotFound
=
>
"
could
not
find
a
terminfo
entry
for
this
terminal
"
&
CursorDestinationInvalid
=
>
"
could
not
move
cursor
to
requested
position
"
&
ColorOutOfRange
=
>
"
color
not
supported
by
the
terminal
"
&
__Nonexhaustive
=
>
"
placeholder
variant
that
shouldn
'
t
be
used
"
}
}
fn
cause
(
&
self
)
-
>
Option
<
&
std
:
:
error
:
:
Error
>
{
match
self
{
&
Error
:
:
Io
(
ref
io
)
=
>
Some
(
io
)
&
Error
:
:
TerminfoParsing
(
ref
e
)
=
>
Some
(
e
)
&
Error
:
:
ParameterizedExpansion
(
ref
e
)
=
>
Some
(
e
)
_
=
>
None
}
}
}
impl
From
<
Error
>
for
io
:
:
Error
{
fn
from
(
err
:
Error
)
-
>
io
:
:
Error
{
let
kind
=
match
&
err
{
&
Error
:
:
Io
(
ref
e
)
=
>
e
.
kind
(
)
_
=
>
io
:
:
ErrorKind
:
:
Other
}
;
io
:
:
Error
:
:
new
(
kind
err
)
}
}
impl
std
:
:
convert
:
:
From
<
io
:
:
Error
>
for
Error
{
fn
from
(
val
:
io
:
:
Error
)
-
>
Self
{
Error
:
:
Io
(
val
)
}
}
impl
std
:
:
convert
:
:
From
<
terminfo
:
:
Error
>
for
Error
{
fn
from
(
val
:
terminfo
:
:
Error
)
-
>
Self
{
Error
:
:
TerminfoParsing
(
val
)
}
}
impl
std
:
:
convert
:
:
From
<
terminfo
:
:
parm
:
:
Error
>
for
Error
{
fn
from
(
val
:
terminfo
:
:
parm
:
:
Error
)
-
>
Self
{
Error
:
:
ParameterizedExpansion
(
val
)
}
}
pub
trait
Terminal
:
Write
{
type
Output
:
Write
;
fn
fg
(
&
mut
self
color
:
color
:
:
Color
)
-
>
Result
<
(
)
>
;
fn
bg
(
&
mut
self
color
:
color
:
:
Color
)
-
>
Result
<
(
)
>
;
fn
attr
(
&
mut
self
attr
:
Attr
)
-
>
Result
<
(
)
>
;
fn
supports_attr
(
&
self
attr
:
Attr
)
-
>
bool
;
fn
reset
(
&
mut
self
)
-
>
Result
<
(
)
>
;
fn
supports_reset
(
&
self
)
-
>
bool
;
fn
supports_color
(
&
self
)
-
>
bool
;
fn
cursor_up
(
&
mut
self
)
-
>
Result
<
(
)
>
;
fn
delete_line
(
&
mut
self
)
-
>
Result
<
(
)
>
;
fn
carriage_return
(
&
mut
self
)
-
>
Result
<
(
)
>
;
fn
get_ref
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
Self
:
:
Output
;
fn
get_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Self
:
:
Output
;
fn
into_inner
(
self
)
-
>
Self
:
:
Output
where
Self
:
Sized
;
}
