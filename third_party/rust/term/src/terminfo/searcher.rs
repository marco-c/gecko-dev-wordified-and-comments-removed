use
std
:
:
env
;
use
std
:
:
fs
;
use
std
:
:
path
:
:
PathBuf
;
pub
fn
get_dbpath_for_term
(
term
:
&
str
)
-
>
Option
<
PathBuf
>
{
let
mut
dirs_to_search
=
Vec
:
:
new
(
)
;
let
first_char
=
match
term
.
chars
(
)
.
next
(
)
{
Some
(
c
)
=
>
c
None
=
>
return
None
}
;
if
let
Some
(
dir
)
=
env
:
:
var_os
(
"
TERMINFO
"
)
{
dirs_to_search
.
push
(
PathBuf
:
:
from
(
dir
)
)
;
}
if
let
Ok
(
dirs
)
=
env
:
:
var
(
"
TERMINFO_DIRS
"
)
{
for
i
in
dirs
.
split
(
'
:
'
)
{
if
i
=
=
"
"
{
dirs_to_search
.
push
(
PathBuf
:
:
from
(
"
/
usr
/
share
/
terminfo
"
)
)
;
}
else
{
dirs_to_search
.
push
(
PathBuf
:
:
from
(
i
)
)
;
}
}
}
else
{
if
let
Some
(
mut
homedir
)
=
env
:
:
home_dir
(
)
{
homedir
.
push
(
"
.
terminfo
"
)
;
dirs_to_search
.
push
(
homedir
)
}
dirs_to_search
.
push
(
PathBuf
:
:
from
(
"
/
etc
/
terminfo
"
)
)
;
dirs_to_search
.
push
(
PathBuf
:
:
from
(
"
/
lib
/
terminfo
"
)
)
;
dirs_to_search
.
push
(
PathBuf
:
:
from
(
"
/
usr
/
share
/
terminfo
"
)
)
;
dirs_to_search
.
push
(
PathBuf
:
:
from
(
"
/
boot
/
system
/
data
/
terminfo
"
)
)
;
}
for
mut
p
in
dirs_to_search
{
if
fs
:
:
metadata
(
&
p
)
.
is_ok
(
)
{
p
.
push
(
&
first_char
.
to_string
(
)
)
;
p
.
push
(
&
term
)
;
if
fs
:
:
metadata
(
&
p
)
.
is_ok
(
)
{
return
Some
(
p
)
;
}
p
.
pop
(
)
;
p
.
pop
(
)
;
p
.
push
(
&
format
!
(
"
{
:
x
}
"
first_char
as
usize
)
)
;
p
.
push
(
term
)
;
if
fs
:
:
metadata
(
&
p
)
.
is_ok
(
)
{
return
Some
(
p
)
;
}
}
}
None
}
