#
!
[
deny
(
missing_docs
)
]
use
backend
:
:
{
MidiInput
as
MidiInputImpl
MidiInputConnection
as
MidiInputConnectionImpl
MidiInputPort
as
MidiInputPortImpl
MidiOutput
as
MidiOutputImpl
MidiOutputConnection
as
MidiOutputConnectionImpl
MidiOutputPort
as
MidiOutputPortImpl
}
;
use
errors
:
:
*
;
use
crate
:
:
{
backend
errors
Ignore
InitError
}
;
pub
trait
MidiIO
{
type
Port
:
Clone
;
fn
ports
(
&
self
)
-
>
Vec
<
Self
:
:
Port
>
;
fn
port_count
(
&
self
)
-
>
usize
;
fn
port_name
(
&
self
port
:
&
Self
:
:
Port
)
-
>
Result
<
String
PortInfoError
>
;
}
#
[
derive
(
Clone
PartialEq
)
]
pub
struct
MidiInputPort
{
pub
(
crate
)
imp
:
MidiInputPortImpl
}
impl
MidiInputPort
{
pub
fn
id
(
&
self
)
-
>
String
{
self
.
imp
.
id
(
)
}
}
pub
type
MidiInputPorts
=
Vec
<
MidiInputPort
>
;
pub
struct
MidiInput
{
imp
:
MidiInputImpl
}
impl
MidiInput
{
pub
fn
new
(
client_name
:
&
str
)
-
>
Result
<
Self
InitError
>
{
MidiInputImpl
:
:
new
(
client_name
)
.
map
(
|
imp
|
MidiInput
{
imp
}
)
}
pub
fn
ignore
(
&
mut
self
flags
:
Ignore
)
{
self
.
imp
.
ignore
(
flags
)
;
}
pub
fn
ports
(
&
self
)
-
>
MidiInputPorts
{
self
.
imp
.
ports_internal
(
)
}
pub
fn
port_count
(
&
self
)
-
>
usize
{
self
.
imp
.
port_count
(
)
}
pub
fn
port_name
(
&
self
port
:
&
MidiInputPort
)
-
>
Result
<
String
PortInfoError
>
{
self
.
imp
.
port_name
(
&
port
.
imp
)
}
pub
fn
find_port_by_id
(
&
self
id
:
String
)
-
>
Option
<
MidiInputPort
>
{
self
.
ports
(
)
.
into_iter
(
)
.
find
(
|
port
|
port
.
id
(
)
=
=
id
)
}
pub
fn
connect
<
F
T
:
Send
>
(
self
port
:
&
MidiInputPort
port_name
:
&
str
callback
:
F
data
:
T
)
-
>
Result
<
MidiInputConnection
<
T
>
ConnectError
<
MidiInput
>
>
where
F
:
FnMut
(
u64
&
[
u8
]
&
mut
T
)
+
Send
+
'
static
{
match
self
.
imp
.
connect
(
&
port
.
imp
port_name
callback
data
)
{
Ok
(
imp
)
=
>
Ok
(
MidiInputConnection
{
imp
}
)
Err
(
imp
)
=
>
{
let
kind
=
imp
.
kind
(
)
;
Err
(
ConnectError
:
:
new
(
kind
MidiInput
{
imp
:
imp
.
into_inner
(
)
}
)
)
}
}
}
}
impl
MidiIO
for
MidiInput
{
type
Port
=
MidiInputPort
;
fn
ports
(
&
self
)
-
>
MidiInputPorts
{
self
.
imp
.
ports_internal
(
)
}
fn
port_count
(
&
self
)
-
>
usize
{
self
.
imp
.
port_count
(
)
}
fn
port_name
(
&
self
port
:
&
MidiInputPort
)
-
>
Result
<
String
PortInfoError
>
{
self
.
imp
.
port_name
(
&
port
.
imp
)
}
}
#
[
cfg
(
unix
)
]
impl
<
T
:
Send
>
crate
:
:
os
:
:
unix
:
:
VirtualInput
<
T
>
for
MidiInput
{
fn
create_virtual
<
F
>
(
self
port_name
:
&
str
callback
:
F
data
:
T
)
-
>
Result
<
MidiInputConnection
<
T
>
ConnectError
<
Self
>
>
where
F
:
FnMut
(
u64
&
[
u8
]
&
mut
T
)
+
Send
+
'
static
{
match
self
.
imp
.
create_virtual
(
port_name
callback
data
)
{
Ok
(
imp
)
=
>
Ok
(
MidiInputConnection
{
imp
}
)
Err
(
imp
)
=
>
{
let
kind
=
imp
.
kind
(
)
;
Err
(
ConnectError
:
:
new
(
kind
MidiInput
{
imp
:
imp
.
into_inner
(
)
}
)
)
}
}
}
}
pub
struct
MidiInputConnection
<
T
:
'
static
>
{
imp
:
MidiInputConnectionImpl
<
T
>
}
impl
<
T
>
MidiInputConnection
<
T
>
{
pub
fn
close
(
self
)
-
>
(
MidiInput
T
)
{
let
(
imp
data
)
=
self
.
imp
.
close
(
)
;
(
MidiInput
{
imp
}
data
)
}
}
#
[
derive
(
Clone
PartialEq
)
]
pub
struct
MidiOutputPort
{
pub
(
crate
)
imp
:
MidiOutputPortImpl
}
impl
MidiOutputPort
{
pub
fn
id
(
&
self
)
-
>
String
{
self
.
imp
.
id
(
)
}
}
pub
type
MidiOutputPorts
=
Vec
<
MidiOutputPort
>
;
pub
struct
MidiOutput
{
imp
:
MidiOutputImpl
}
impl
MidiOutput
{
pub
fn
new
(
client_name
:
&
str
)
-
>
Result
<
Self
InitError
>
{
MidiOutputImpl
:
:
new
(
client_name
)
.
map
(
|
imp
|
MidiOutput
{
imp
}
)
}
pub
fn
ports
(
&
self
)
-
>
MidiOutputPorts
{
self
.
imp
.
ports_internal
(
)
}
pub
fn
port_count
(
&
self
)
-
>
usize
{
self
.
imp
.
port_count
(
)
}
pub
fn
port_name
(
&
self
port
:
&
MidiOutputPort
)
-
>
Result
<
String
PortInfoError
>
{
self
.
imp
.
port_name
(
&
port
.
imp
)
}
pub
fn
find_port_by_id
(
&
self
id
:
String
)
-
>
Option
<
MidiOutputPort
>
{
self
.
ports
(
)
.
into_iter
(
)
.
find
(
|
port
|
port
.
id
(
)
=
=
id
)
}
pub
fn
connect
(
self
port
:
&
MidiOutputPort
port_name
:
&
str
)
-
>
Result
<
MidiOutputConnection
ConnectError
<
MidiOutput
>
>
{
match
self
.
imp
.
connect
(
&
port
.
imp
port_name
)
{
Ok
(
imp
)
=
>
Ok
(
MidiOutputConnection
{
imp
}
)
Err
(
imp
)
=
>
{
let
kind
=
imp
.
kind
(
)
;
Err
(
ConnectError
:
:
new
(
kind
MidiOutput
{
imp
:
imp
.
into_inner
(
)
}
)
)
}
}
}
}
impl
MidiIO
for
MidiOutput
{
type
Port
=
MidiOutputPort
;
fn
ports
(
&
self
)
-
>
MidiOutputPorts
{
self
.
imp
.
ports_internal
(
)
}
fn
port_count
(
&
self
)
-
>
usize
{
self
.
imp
.
port_count
(
)
}
fn
port_name
(
&
self
port
:
&
MidiOutputPort
)
-
>
Result
<
String
PortInfoError
>
{
self
.
imp
.
port_name
(
&
port
.
imp
)
}
}
#
[
cfg
(
unix
)
]
impl
crate
:
:
os
:
:
unix
:
:
VirtualOutput
for
MidiOutput
{
fn
create_virtual
(
self
port_name
:
&
str
)
-
>
Result
<
MidiOutputConnection
ConnectError
<
MidiOutput
>
>
{
match
self
.
imp
.
create_virtual
(
port_name
)
{
Ok
(
imp
)
=
>
Ok
(
MidiOutputConnection
{
imp
}
)
Err
(
imp
)
=
>
{
let
kind
=
imp
.
kind
(
)
;
Err
(
ConnectError
:
:
new
(
kind
MidiOutput
{
imp
:
imp
.
into_inner
(
)
}
)
)
}
}
}
}
pub
struct
MidiOutputConnection
{
imp
:
MidiOutputConnectionImpl
}
impl
MidiOutputConnection
{
pub
fn
close
(
self
)
-
>
MidiOutput
{
MidiOutput
{
imp
:
self
.
imp
.
close
(
)
}
}
pub
fn
send
(
&
mut
self
message
:
&
[
u8
]
)
-
>
Result
<
(
)
SendError
>
{
self
.
imp
.
send
(
message
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
test_trait_impls
(
)
{
fn
is_send
<
T
:
Send
>
(
)
{
}
is_send
:
:
<
MidiInput
>
(
)
;
is_send
:
:
<
MidiOutput
>
(
)
;
#
[
cfg
(
not
(
target_arch
=
"
wasm32
"
)
)
]
{
is_send
:
:
<
MidiInputPort
>
(
)
;
is_send
:
:
<
MidiInputConnection
<
(
)
>
>
(
)
;
is_send
:
:
<
MidiOutputPort
>
(
)
;
is_send
:
:
<
MidiOutputConnection
>
(
)
;
}
fn
is_partial_eq
<
T
:
PartialEq
>
(
)
{
}
is_partial_eq
:
:
<
MidiInputPortImpl
>
(
)
;
is_partial_eq
:
:
<
MidiOutputPortImpl
>
(
)
;
is_partial_eq
:
:
<
MidiInputPort
>
(
)
;
is_partial_eq
:
:
<
MidiOutputPort
>
(
)
;
}
}
