#
[
cfg
(
feature
=
"
yaml
"
)
]
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Deprecated
in
Issue
#
3087
maybe
clap
:
:
Parser
would
fit
your
use
case
?
"
)
]
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
load_yaml
{
(
yaml
:
expr
)
=
>
{
&
crate
:
:
YamlLoader
:
:
load_from_str
(
include_str
!
(
yaml
)
)
.
expect
(
"
failed
to
load
YAML
file
"
)
[
0
]
}
;
}
#
[
macro_export
]
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
ArgMatches
:
:
value_of_t
"
)
]
#
[
doc
(
hidden
)
]
macro_rules
!
value_t
{
(
m
:
ident
v
:
expr
t
:
ty
)
=
>
{
crate
:
:
value_t
!
(
m
.
value_of
(
v
)
t
)
}
;
(
m
:
ident
.
value_of
(
v
:
expr
)
t
:
ty
)
=
>
{
m
.
value_of_t
:
:
<
t
>
(
v
)
}
;
}
#
[
macro_export
]
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
ArgMatches
:
:
value_of_t_or_exit
"
)
]
#
[
doc
(
hidden
)
]
macro_rules
!
value_t_or_exit
{
(
m
:
ident
v
:
expr
t
:
ty
)
=
>
{
value_t_or_exit
!
(
m
.
value_of
(
v
)
t
)
}
;
(
m
:
ident
.
value_of
(
v
:
expr
)
t
:
ty
)
=
>
{
m
.
value_of_t_or_exit
:
:
<
t
>
(
v
)
}
;
}
#
[
macro_export
]
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
ArgMatches
:
:
values_of_t
"
)
]
#
[
doc
(
hidden
)
]
macro_rules
!
values_t
{
(
m
:
ident
v
:
expr
t
:
ty
)
=
>
{
values_t
!
(
m
.
values_of
(
v
)
t
)
}
;
(
m
:
ident
.
values_of
(
v
:
expr
)
t
:
ty
)
=
>
{
m
.
values_of_t
:
:
<
t
>
(
v
)
}
;
}
#
[
macro_export
]
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
ArgMatches
:
:
values_of_t_or_exit
"
)
]
#
[
doc
(
hidden
)
]
macro_rules
!
values_t_or_exit
{
(
m
:
ident
v
:
expr
t
:
ty
)
=
>
{
values_t_or_exit
!
(
m
.
values_of
(
v
)
t
)
}
;
(
m
:
ident
.
values_of
(
v
:
expr
)
t
:
ty
)
=
>
{
m
.
values_of_t_or_exit
:
:
<
t
>
(
v
)
}
;
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
ArgEnum
"
)
]
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
_clap_count_exprs
{
(
)
=
>
{
0
}
;
(
e
:
expr
)
=
>
{
1
}
;
(
e
:
expr
(
es
:
expr
)
+
)
=
>
{
1
+
crate
:
:
_clap_count_exprs
!
(
(
es
)
*
)
}
;
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
ArgEnum
"
)
]
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
arg_enum
{
(
as_item
(
i
:
item
)
*
)
=
>
(
(
i
)
*
)
;
(
impls
(
(
tts
:
tt
)
*
)
-
>
(
e
:
ident
(
v
:
ident
)
+
)
)
=
>
{
crate
:
:
arg_enum
!
(
as_item
(
tts
)
*
impl
:
:
std
:
:
str
:
:
FromStr
for
e
{
type
Err
=
String
;
fn
from_str
(
s
:
&
str
)
-
>
:
:
std
:
:
result
:
:
Result
<
Self
Self
:
:
Err
>
{
#
[
allow
(
deprecated
unused_imports
)
]
use
:
:
std
:
:
ascii
:
:
AsciiExt
;
match
s
{
(
stringify
!
(
v
)
|
_
if
s
.
eq_ignore_ascii_case
(
stringify
!
(
v
)
)
=
>
Ok
(
e
:
:
v
)
)
+
_
=
>
Err
(
{
let
v
=
vec
!
[
(
stringify
!
(
v
)
)
+
]
;
format
!
(
"
valid
values
:
{
}
"
v
.
join
(
"
"
)
)
}
)
}
}
}
impl
:
:
std
:
:
fmt
:
:
Display
for
e
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
match
*
self
{
(
e
:
:
v
=
>
write
!
(
f
stringify
!
(
v
)
)
)
+
}
}
}
impl
e
{
#
[
allow
(
dead_code
)
]
pub
fn
variants
(
)
-
>
[
&
'
static
str
;
crate
:
:
_clap_count_exprs
!
(
(
stringify
!
(
v
)
)
+
)
]
{
[
(
stringify
!
(
v
)
)
+
]
}
}
)
;
}
;
(
(
#
[
(
m
:
meta
)
+
]
)
+
pub
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
crate
:
:
arg_enum
!
(
impls
(
(
#
[
(
m
)
+
]
)
+
pub
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
(
(
#
[
(
m
:
meta
)
+
]
)
+
pub
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
crate
:
:
arg_enum
!
(
impls
(
(
#
[
(
m
)
+
]
)
+
pub
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
(
(
#
[
(
m
:
meta
)
+
]
)
+
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
crate
:
:
arg_enum
!
(
impls
(
(
#
[
(
m
)
+
]
)
+
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
(
(
#
[
(
m
:
meta
)
+
]
)
+
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
crate
:
:
arg_enum
!
(
impls
(
(
#
[
(
m
)
+
]
)
+
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
(
pub
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
crate
:
:
arg_enum
!
(
impls
(
pub
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
(
pub
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
crate
:
:
arg_enum
!
(
impls
(
pub
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
(
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
crate
:
:
arg_enum
!
(
impls
(
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
(
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
crate
:
:
arg_enum
!
(
impls
(
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
}
#
[
cfg
(
feature
=
"
cargo
"
)
]
#
[
macro_export
]
macro_rules
!
crate_version
{
(
)
=
>
{
env
!
(
"
CARGO_PKG_VERSION
"
)
}
;
}
#
[
cfg
(
feature
=
"
cargo
"
)
]
#
[
macro_export
]
macro_rules
!
crate_authors
{
(
sep
:
expr
)
=
>
{
{
clap
:
:
lazy_static
:
:
lazy_static
!
{
static
ref
CACHED
:
String
=
env
!
(
"
CARGO_PKG_AUTHORS
"
)
.
replace
(
'
:
'
sep
)
;
}
let
s
:
&
'
static
str
=
&
*
CACHED
;
s
}
}
;
(
)
=
>
{
env
!
(
"
CARGO_PKG_AUTHORS
"
)
}
;
}
#
[
cfg
(
feature
=
"
cargo
"
)
]
#
[
macro_export
]
macro_rules
!
crate_description
{
(
)
=
>
{
env
!
(
"
CARGO_PKG_DESCRIPTION
"
)
}
;
}
#
[
cfg
(
feature
=
"
cargo
"
)
]
#
[
macro_export
]
macro_rules
!
crate_name
{
(
)
=
>
{
env
!
(
"
CARGO_PKG_NAME
"
)
}
;
}
#
[
cfg
(
feature
=
"
cargo
"
)
]
#
[
macro_export
]
macro_rules
!
command
{
(
)
=
>
{
{
crate
:
:
command
!
(
crate
:
:
crate_name
!
(
)
)
}
}
;
(
name
:
expr
)
=
>
{
{
let
mut
cmd
=
crate
:
:
Command
:
:
new
(
name
)
.
version
(
crate
:
:
crate_version
!
(
)
)
;
let
author
=
crate
:
:
crate_authors
!
(
)
;
if
!
author
.
is_empty
(
)
{
cmd
=
cmd
.
author
(
author
)
}
let
about
=
crate
:
:
crate_description
!
(
)
;
if
!
about
.
is_empty
(
)
{
cmd
=
cmd
.
about
(
about
)
}
cmd
}
}
;
}
#
[
cfg
(
not
(
feature
=
"
cargo
"
)
)
]
#
[
macro_export
]
macro_rules
!
command
{
(
)
=
>
{
{
compile_error
!
(
"
cargo
feature
flag
is
required
"
)
;
}
}
;
(
name
:
expr
)
=
>
{
{
compile_error
!
(
"
cargo
feature
flag
is
required
"
)
;
}
}
;
}
#
[
cfg
(
feature
=
"
cargo
"
)
]
#
[
deprecated
(
since
=
"
3
.
1
.
0
"
note
=
"
Replaced
with
clap
:
:
command
!
"
)
]
#
[
macro_export
]
macro_rules
!
app_from_crate
{
(
)
=
>
{
{
let
mut
cmd
=
crate
:
:
Command
:
:
new
(
crate
:
:
crate_name
!
(
)
)
.
version
(
crate
:
:
crate_version
!
(
)
)
;
let
author
=
crate
:
:
crate_authors
!
(
"
"
)
;
if
!
author
.
is_empty
(
)
{
cmd
=
cmd
.
author
(
author
)
}
let
about
=
crate
:
:
crate_description
!
(
)
;
if
!
about
.
is_empty
(
)
{
cmd
=
cmd
.
about
(
about
)
}
cmd
}
}
;
(
sep
:
expr
)
=
>
{
{
let
mut
cmd
=
crate
:
:
Command
:
:
new
(
crate
:
:
crate_name
!
(
)
)
.
version
(
crate
:
:
crate_version
!
(
)
)
;
let
author
=
crate
:
:
crate_authors
!
(
sep
)
;
if
!
author
.
is_empty
(
)
{
cmd
=
cmd
.
author
(
author
)
}
let
about
=
crate
:
:
crate_description
!
(
)
;
if
!
about
.
is_empty
(
)
{
cmd
=
cmd
.
about
(
about
)
}
cmd
}
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
arg_impl
{
(
string
val
:
ident
)
=
>
{
stringify
!
(
val
)
}
;
(
string
val
:
literal
)
=
>
{
{
let
ident_or_string_literal
:
&
str
=
val
;
ident_or_string_literal
}
}
;
(
string
val
:
tt
)
=
>
{
:
:
std
:
:
compile_error
!
(
"
Only
identifiers
or
string
literals
supported
"
)
;
}
;
(
string
)
=
>
{
None
}
;
(
char
val
:
ident
)
=
>
{
{
let
ident_or_char_literal
=
stringify
!
(
val
)
;
debug_assert_eq
!
(
ident_or_char_literal
.
len
(
)
1
"
Single
-
letter
identifier
expected
got
{
}
"
ident_or_char_literal
)
;
ident_or_char_literal
.
chars
(
)
.
next
(
)
.
unwrap
(
)
}
}
;
(
char
val
:
literal
)
=
>
{
{
let
ident_or_char_literal
:
char
=
val
;
ident_or_char_literal
}
}
;
(
char
)
=
>
{
{
None
}
}
;
(
arg
(
arg
:
expr
)
-
-
long
:
ident
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
arg_impl
!
{
arg
(
{
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Flags
should
precede
values
"
)
;
debug_assert
!
(
!
arg
.
is_multiple_occurrences_set
(
)
"
Flags
should
precede
.
.
.
"
)
;
let
mut
arg
=
arg
;
let
long
=
crate
:
:
arg_impl
!
{
string
long
}
;
if
arg
.
get_id
(
)
.
is_empty
(
)
{
arg
=
arg
.
id
(
long
)
;
}
arg
.
long
(
long
)
}
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
-
-
long
:
literal
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
arg_impl
!
{
arg
(
{
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Flags
should
precede
values
"
)
;
debug_assert
!
(
!
arg
.
is_multiple_occurrences_set
(
)
"
Flags
should
precede
.
.
.
"
)
;
let
mut
arg
=
arg
;
let
long
=
crate
:
:
arg_impl
!
{
string
long
}
;
if
arg
.
get_id
(
)
.
is_empty
(
)
{
arg
=
arg
.
id
(
long
)
;
}
arg
.
long
(
long
)
}
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
-
short
:
ident
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
arg_impl
!
{
arg
(
{
debug_assert_eq
!
(
arg
.
get_long
(
)
None
"
Short
flags
should
precede
long
flags
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Flags
should
precede
values
"
)
;
debug_assert
!
(
!
arg
.
is_multiple_occurrences_set
(
)
"
Flags
should
precede
.
.
.
"
)
;
arg
.
short
(
crate
:
:
arg_impl
!
{
char
short
}
)
}
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
-
short
:
literal
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
arg_impl
!
{
arg
(
{
debug_assert_eq
!
(
arg
.
get_long
(
)
None
"
Short
flags
should
precede
long
flags
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Flags
should
precede
values
"
)
;
debug_assert
!
(
!
arg
.
is_multiple_occurrences_set
(
)
"
Flags
should
precede
.
.
.
"
)
;
arg
.
short
(
crate
:
:
arg_impl
!
{
char
short
}
)
}
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
<
value_name
:
ident
>
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
arg_impl
!
{
arg
(
{
debug_assert
!
(
!
arg
.
is_multiple_occurrences_set
(
)
"
Values
should
precede
.
.
.
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Multiple
values
not
yet
supported
"
)
;
let
mut
arg
=
arg
;
arg
=
arg
.
required
(
true
)
;
arg
=
arg
.
takes_value
(
true
)
;
let
value_name
=
crate
:
:
arg_impl
!
{
string
value_name
}
;
if
arg
.
get_id
(
)
.
is_empty
(
)
{
arg
=
arg
.
id
(
value_name
)
;
}
arg
.
value_name
(
value_name
)
}
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
<
value_name
:
literal
>
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
arg_impl
!
{
arg
(
{
debug_assert
!
(
!
arg
.
is_multiple_occurrences_set
(
)
"
Values
should
precede
.
.
.
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Multiple
values
not
yet
supported
"
)
;
let
mut
arg
=
arg
;
arg
=
arg
.
required
(
true
)
;
arg
=
arg
.
takes_value
(
true
)
;
let
value_name
=
crate
:
:
arg_impl
!
{
string
value_name
}
;
if
arg
.
get_id
(
)
.
is_empty
(
)
{
arg
=
arg
.
id
(
value_name
)
;
}
arg
.
value_name
(
value_name
)
}
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
[
value_name
:
ident
]
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
arg_impl
!
{
arg
(
{
debug_assert
!
(
!
arg
.
is_multiple_occurrences_set
(
)
"
Values
should
precede
.
.
.
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Multiple
values
not
yet
supported
"
)
;
let
mut
arg
=
arg
;
if
arg
.
get_long
(
)
.
is_none
(
)
&
&
arg
.
get_short
(
)
.
is_none
(
)
{
arg
=
arg
.
required
(
false
)
;
}
else
{
arg
=
arg
.
min_values
(
0
)
.
max_values
(
1
)
;
}
arg
=
arg
.
takes_value
(
true
)
;
let
value_name
=
crate
:
:
arg_impl
!
{
string
value_name
}
;
if
arg
.
get_id
(
)
.
is_empty
(
)
{
arg
=
arg
.
id
(
value_name
)
;
}
arg
.
value_name
(
value_name
)
}
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
[
value_name
:
literal
]
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
arg_impl
!
{
arg
(
{
debug_assert
!
(
!
arg
.
is_multiple_occurrences_set
(
)
"
Values
should
precede
.
.
.
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Multiple
values
not
yet
supported
"
)
;
let
mut
arg
=
arg
;
if
arg
.
get_long
(
)
.
is_none
(
)
&
&
arg
.
get_short
(
)
.
is_none
(
)
{
arg
=
arg
.
required
(
false
)
;
}
else
{
arg
=
arg
.
min_values
(
0
)
.
max_values
(
1
)
;
}
arg
=
arg
.
takes_value
(
true
)
;
let
value_name
=
crate
:
:
arg_impl
!
{
string
value_name
}
;
if
arg
.
get_id
(
)
.
is_empty
(
)
{
arg
=
arg
.
id
(
value_name
)
;
}
arg
.
value_name
(
value_name
)
}
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
.
.
.
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
arg_impl
!
{
arg
(
{
arg
.
multiple_occurrences
(
true
)
}
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
help
:
literal
)
=
>
{
arg
.
help
(
help
)
}
;
(
arg
(
arg
:
expr
)
)
=
>
{
arg
}
;
}
#
[
macro_export
]
macro_rules
!
arg
{
(
name
:
ident
:
(
tail
:
tt
)
+
)
=
>
{
crate
:
:
arg_impl
!
{
arg
(
crate
:
:
Arg
:
:
new
(
crate
:
:
arg_impl
!
{
string
name
}
)
)
(
tail
)
+
}
}
;
(
(
tail
:
tt
)
+
)
=
>
{
{
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
crate
:
:
Arg
:
:
default
(
)
)
(
tail
)
+
}
;
debug_assert
!
(
!
arg
.
get_id
(
)
.
is_empty
(
)
"
Without
a
value
or
long
flag
the
name
:
prefix
is
required
"
)
;
arg
}
}
;
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
clap
:
:
Parser
for
a
declarative
API
(
Issue
clap
-
rs
/
clap
#
2835
)
"
)
]
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
clap_app
{
(
app
(
builder
:
expr
)
)
=
>
{
builder
}
;
(
app
(
builder
:
expr
)
(
arg
(
name
:
expr
)
:
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
app
(
builder
.
arg
(
crate
:
:
clap_app
!
{
arg
(
crate
:
:
Arg
:
:
new
(
name
)
)
(
-
)
(
tail
)
*
}
)
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
arg
name
:
ident
:
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
app
(
builder
.
arg
(
crate
:
:
clap_app
!
{
arg
(
crate
:
:
Arg
:
:
new
(
stringify
!
(
name
)
)
)
(
-
)
(
tail
)
*
}
)
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
setting
setting
:
ident
)
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
app
(
builder
.
setting
(
crate
:
:
AppSettings
:
:
setting
)
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
attributes
(
attr
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
app
(
crate
:
:
clap_app
!
{
arg
(
builder
)
(
attr
)
*
}
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
group
name
:
ident
=
>
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
app
(
crate
:
:
clap_app
!
{
group
(
builder
crate
:
:
ArgGroup
:
:
new
(
stringify
!
(
name
)
)
)
(
tail
)
*
}
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
group
name
:
ident
!
ident
:
ident
=
>
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
app
(
crate
:
:
clap_app
!
{
group
(
builder
crate
:
:
ArgGroup
:
:
new
(
stringify
!
(
name
)
)
.
ident
(
false
)
)
(
tail
)
*
}
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
group
name
:
ident
+
ident
:
ident
=
>
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
app
(
crate
:
:
clap_app
!
{
group
(
builder
crate
:
:
ArgGroup
:
:
new
(
stringify
!
(
name
)
)
.
ident
(
true
)
)
(
tail
)
*
}
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
subcommand
name
:
ident
=
>
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
app
(
builder
.
subcommand
(
crate
:
:
clap_app
!
{
app
(
crate
:
:
Command
:
:
new
(
stringify
!
(
name
)
)
)
(
tail
)
*
}
)
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
ident
:
ident
:
(
v
:
expr
)
*
)
(
tt
:
tt
)
*
)
=
>
{
/
/
crate
:
:
clap_app
!
{
app
(
builder
.
ident
(
(
v
)
*
)
)
(
tt
)
*
}
crate
:
:
clap_app
!
{
app
(
builder
.
ident
(
(
v
)
*
)
)
(
tt
)
*
}
}
;
(
group
(
builder
:
expr
group
:
expr
)
)
=
>
{
builder
.
group
(
group
)
}
;
(
group
(
builder
:
expr
group
:
expr
)
(
attributes
(
attr
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
group
(
builder
crate
:
:
clap_app
!
{
arg
(
group
)
(
-
)
(
attr
)
*
}
)
(
tt
)
*
}
}
;
(
group
(
builder
:
expr
group
:
expr
)
(
arg
name
:
ident
:
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
group
(
crate
:
:
clap_app
!
{
app
(
builder
)
(
arg
name
:
(
tail
)
*
)
}
group
.
arg
(
stringify
!
(
name
)
)
)
(
tt
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
)
=
>
{
arg
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
-
-
(
long
:
expr
)
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
long
(
long
)
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
-
-
long
:
ident
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
long
(
stringify
!
(
long
)
)
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
-
short
:
ident
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
short
(
stringify
!
(
short
)
.
chars
(
)
.
next
(
)
.
unwrap
(
)
)
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
(
-
)
<
var
:
ident
>
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
value_name
(
stringify
!
(
var
)
)
)
(
+
)
+
takes_value
+
required
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
(
+
)
<
var
:
ident
>
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
value_name
(
stringify
!
(
var
)
)
)
(
+
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
(
-
)
[
var
:
ident
]
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
value_name
(
stringify
!
(
var
)
)
)
(
+
)
+
takes_value
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
(
+
)
[
var
:
ident
]
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
value_name
(
stringify
!
(
var
)
)
)
(
+
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
.
.
.
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
)
modes
+
multiple
+
takes_value
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
#
{
n
:
expr
m
:
expr
}
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
)
modes
min_values
(
n
)
max_values
(
m
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
*
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
)
modes
+
required
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
!
ident
:
ident
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
ident
(
false
)
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
+
ident
:
ident
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
ident
(
true
)
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
{
fn_
:
expr
}
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
validator
(
fn_
)
)
modes
(
tail
)
*
}
}
;
(
as_expr
expr
:
expr
)
=
>
{
expr
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
desc
:
tt
)
=
>
{
arg
.
help
(
crate
:
:
clap_app
!
{
as_expr
desc
}
)
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
ident
:
ident
[
(
target
:
ident
)
*
]
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
(
.
ident
(
stringify
!
(
target
)
)
)
*
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
ident
:
ident
(
(
expr
:
expr
)
*
)
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
ident
(
(
expr
)
*
)
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
ident
:
ident
(
(
expr
:
expr
)
*
)
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
arg
(
arg
.
ident
(
(
expr
)
*
)
)
modes
(
tail
)
*
}
}
;
(
subcommand
name
:
ident
=
>
(
tail
:
tt
)
*
)
=
>
{
crate
:
:
clap_app
!
{
app
(
crate
:
:
Command
:
:
new
(
stringify
!
(
name
)
)
)
(
tail
)
*
}
}
;
(
(
name
:
expr
)
=
>
(
tail
:
tt
)
*
)
=
>
{
{
crate
:
:
clap_app
!
{
app
(
crate
:
:
Command
:
:
new
(
name
)
)
(
tail
)
*
}
}
}
;
(
name
:
ident
=
>
(
tail
:
tt
)
*
)
=
>
{
{
crate
:
:
clap_app
!
{
app
(
crate
:
:
Command
:
:
new
(
stringify
!
(
name
)
)
)
(
tail
)
*
}
}
}
;
}
macro_rules
!
impl_settings
{
(
settings
:
ident
flags
:
ident
(
(
#
[
inner
:
ident
(
args
:
tt
)
*
]
)
*
setting
:
ident
=
>
flag
:
path
)
+
)
=
>
{
impl
flags
{
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
empty
(
)
-
>
Self
{
flags
(
Flags
:
:
empty
(
)
)
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
insert
(
&
mut
self
rhs
:
Self
)
{
self
.
0
.
insert
(
rhs
.
0
)
;
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
remove
(
&
mut
self
rhs
:
Self
)
{
self
.
0
.
remove
(
rhs
.
0
)
;
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
set
(
&
mut
self
s
:
settings
)
{
#
[
allow
(
deprecated
)
]
/
/
some
Settings
might
be
deprecated
match
s
{
(
(
#
[
inner
(
args
)
*
]
)
*
settings
:
:
setting
=
>
self
.
0
.
insert
(
flag
)
)
*
}
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
unset
(
&
mut
self
s
:
settings
)
{
#
[
allow
(
deprecated
)
]
/
/
some
Settings
might
be
deprecated
match
s
{
(
(
#
[
inner
(
args
)
*
]
)
*
settings
:
:
setting
=
>
self
.
0
.
remove
(
flag
)
)
*
}
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
is_set
(
&
self
s
:
settings
)
-
>
bool
{
#
[
allow
(
deprecated
)
]
/
/
some
Settings
might
be
deprecated
match
s
{
(
(
#
[
inner
(
args
)
*
]
)
*
settings
:
:
setting
=
>
self
.
0
.
contains
(
flag
)
)
*
}
}
}
impl
BitOr
for
flags
{
type
Output
=
Self
;
fn
bitor
(
mut
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
0
.
insert
(
rhs
.
0
)
;
self
}
}
impl
From
<
settings
>
for
flags
{
fn
from
(
setting
:
settings
)
-
>
Self
{
let
mut
flags
=
flags
:
:
empty
(
)
;
flags
.
set
(
setting
)
;
flags
}
}
impl
BitOr
<
settings
>
for
flags
{
type
Output
=
Self
;
fn
bitor
(
mut
self
rhs
:
settings
)
-
>
Self
:
:
Output
{
self
.
set
(
rhs
)
;
self
}
}
impl
BitOr
for
settings
{
type
Output
=
flags
;
fn
bitor
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
let
mut
flags
=
flags
:
:
empty
(
)
;
flags
.
set
(
self
)
;
flags
.
set
(
rhs
)
;
flags
}
}
}
}
macro_rules
!
wlnerr
{
(
(
arg
:
tt
)
*
)
=
>
(
{
use
std
:
:
io
:
:
{
Write
stderr
}
;
writeln
!
(
&
mut
stderr
(
)
(
arg
)
*
)
.
ok
(
)
;
}
)
}
#
[
cfg
(
feature
=
"
debug
"
)
]
macro_rules
!
debug
{
(
(
arg
:
tt
)
*
)
=
>
(
{
let
prefix
=
format
!
(
"
[
{
:
>
w
}
]
\
t
"
module_path
!
(
)
w
=
28
)
;
let
body
=
format
!
(
(
arg
)
*
)
;
let
mut
color
=
crate
:
:
output
:
:
fmt
:
:
Colorizer
:
:
new
(
crate
:
:
output
:
:
fmt
:
:
Stream
:
:
Stderr
crate
:
:
ColorChoice
:
:
Auto
)
;
color
.
hint
(
prefix
)
;
color
.
hint
(
body
)
;
color
.
none
(
"
\
n
"
)
;
let
_
=
color
.
print
(
)
;
}
)
}
#
[
cfg
(
not
(
feature
=
"
debug
"
)
)
]
macro_rules
!
debug
{
(
(
arg
:
tt
)
*
)
=
>
{
}
;
}
