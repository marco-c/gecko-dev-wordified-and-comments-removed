#
[
cfg
(
feature
=
"
yaml
"
)
]
#
[
macro_export
]
macro_rules
!
load_yaml
{
(
yml
:
expr
)
=
>
(
&
:
:
clap
:
:
YamlLoader
:
:
load_from_str
(
include_str
!
(
yml
)
)
.
expect
(
"
failed
to
load
YAML
file
"
)
[
0
]
)
;
}
#
[
macro_export
]
macro_rules
!
value_t
{
(
m
:
ident
v
:
expr
t
:
ty
)
=
>
{
value_t
!
(
m
.
value_of
(
v
)
t
)
}
;
(
m
:
ident
.
value_of
(
v
:
expr
)
t
:
ty
)
=
>
{
if
let
Some
(
v
)
=
m
.
value_of
(
v
)
{
match
v
.
parse
:
:
<
t
>
(
)
{
Ok
(
val
)
=
>
Ok
(
val
)
Err
(
_
)
=
>
Err
(
:
:
clap
:
:
Error
:
:
value_validation_auto
(
format
!
(
"
The
argument
'
{
}
'
isn
'
t
a
valid
value
"
v
)
)
)
}
}
else
{
Err
(
:
:
clap
:
:
Error
:
:
argument_not_found_auto
(
v
)
)
}
}
;
}
#
[
macro_export
]
macro_rules
!
value_t_or_exit
{
(
m
:
ident
v
:
expr
t
:
ty
)
=
>
{
value_t_or_exit
!
(
m
.
value_of
(
v
)
t
)
}
;
(
m
:
ident
.
value_of
(
v
:
expr
)
t
:
ty
)
=
>
{
if
let
Some
(
v
)
=
m
.
value_of
(
v
)
{
match
v
.
parse
:
:
<
t
>
(
)
{
Ok
(
val
)
=
>
val
Err
(
_
)
=
>
:
:
clap
:
:
Error
:
:
value_validation_auto
(
format
!
(
"
The
argument
'
{
}
'
isn
'
t
a
valid
value
"
v
)
)
.
exit
(
)
}
}
else
{
:
:
clap
:
:
Error
:
:
argument_not_found_auto
(
v
)
.
exit
(
)
}
}
;
}
#
[
macro_export
]
macro_rules
!
values_t
{
(
m
:
ident
v
:
expr
t
:
ty
)
=
>
{
values_t
!
(
m
.
values_of
(
v
)
t
)
}
;
(
m
:
ident
.
values_of
(
v
:
expr
)
t
:
ty
)
=
>
{
if
let
Some
(
vals
)
=
m
.
values_of
(
v
)
{
let
mut
tmp
=
vec
!
[
]
;
let
mut
err
=
None
;
for
pv
in
vals
{
match
pv
.
parse
:
:
<
t
>
(
)
{
Ok
(
rv
)
=
>
tmp
.
push
(
rv
)
Err
(
.
.
)
=
>
{
err
=
Some
(
:
:
clap
:
:
Error
:
:
value_validation_auto
(
format
!
(
"
The
argument
'
{
}
'
isn
'
t
a
valid
value
"
pv
)
)
)
;
break
}
}
}
match
err
{
Some
(
e
)
=
>
Err
(
e
)
None
=
>
Ok
(
tmp
)
}
}
else
{
Err
(
:
:
clap
:
:
Error
:
:
argument_not_found_auto
(
v
)
)
}
}
;
}
#
[
macro_export
]
macro_rules
!
values_t_or_exit
{
(
m
:
ident
v
:
expr
t
:
ty
)
=
>
{
values_t_or_exit
!
(
m
.
values_of
(
v
)
t
)
}
;
(
m
:
ident
.
values_of
(
v
:
expr
)
t
:
ty
)
=
>
{
if
let
Some
(
vals
)
=
m
.
values_of
(
v
)
{
vals
.
map
(
|
v
|
v
.
parse
:
:
<
t
>
(
)
.
unwrap_or_else
(
|
_
|
{
:
:
clap
:
:
Error
:
:
value_validation_auto
(
format
!
(
"
One
or
more
arguments
aren
'
t
valid
values
"
)
)
.
exit
(
)
}
)
)
.
collect
:
:
<
Vec
<
t
>
>
(
)
}
else
{
:
:
clap
:
:
Error
:
:
argument_not_found_auto
(
v
)
.
exit
(
)
}
}
;
}
#
[
macro_export
]
macro_rules
!
_clap_count_exprs
{
(
)
=
>
{
0
}
;
(
e
:
expr
)
=
>
{
1
}
;
(
e
:
expr
(
es
:
expr
)
+
)
=
>
{
1
+
_clap_count_exprs
!
(
(
es
)
*
)
}
;
}
#
[
macro_export
]
macro_rules
!
arg_enum
{
(
as_item
(
i
:
item
)
*
)
=
>
(
(
i
)
*
)
;
(
impls
(
(
tts
:
tt
)
*
)
-
>
(
e
:
ident
(
v
:
ident
)
+
)
)
=
>
{
arg_enum
!
(
as_item
(
tts
)
*
impl
:
:
std
:
:
str
:
:
FromStr
for
e
{
type
Err
=
String
;
fn
from_str
(
s
:
&
str
)
-
>
:
:
std
:
:
result
:
:
Result
<
Self
Self
:
:
Err
>
{
#
[
allow
(
unused_imports
)
]
use
:
:
std
:
:
ascii
:
:
AsciiExt
;
match
s
{
(
stringify
!
(
v
)
|
_
if
s
.
eq_ignore_ascii_case
(
stringify
!
(
v
)
)
=
>
Ok
(
e
:
:
v
)
)
+
_
=
>
Err
(
{
let
v
=
vec
!
[
(
stringify
!
(
v
)
)
+
]
;
format
!
(
"
valid
values
:
{
}
"
v
.
join
(
"
"
)
)
}
)
}
}
}
impl
:
:
std
:
:
fmt
:
:
Display
for
e
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
match
*
self
{
(
e
:
:
v
=
>
write
!
(
f
stringify
!
(
v
)
)
)
+
}
}
}
impl
e
{
#
[
allow
(
dead_code
)
]
pub
fn
variants
(
)
-
>
[
&
'
static
str
;
_clap_count_exprs
!
(
(
stringify
!
(
v
)
)
+
)
]
{
[
(
stringify
!
(
v
)
)
+
]
}
}
)
;
}
;
(
(
#
[
(
m
:
meta
)
+
]
)
+
pub
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
arg_enum
!
(
impls
(
(
#
[
(
m
)
+
]
)
+
pub
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
(
(
#
[
(
m
:
meta
)
+
]
)
+
pub
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
arg_enum
!
(
impls
(
(
#
[
(
m
)
+
]
)
+
pub
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
(
(
#
[
(
m
:
meta
)
+
]
)
+
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
arg_enum
!
(
(
#
[
(
m
:
meta
)
+
]
)
+
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
;
}
;
(
(
#
[
(
m
:
meta
)
+
]
)
+
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
arg_enum
!
(
impls
(
(
#
[
(
m
)
+
]
)
+
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
(
pub
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
arg_enum
!
(
pub
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
;
}
;
(
pub
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
arg_enum
!
(
impls
(
pub
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
(
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
arg_enum
!
(
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
;
}
;
(
enum
e
:
ident
{
(
v
:
ident
(
=
val
:
expr
)
*
)
+
}
)
=
>
{
arg_enum
!
(
impls
(
enum
e
{
(
v
(
=
val
)
*
)
+
}
)
-
>
(
e
(
v
)
+
)
)
;
}
;
}
#
[
cfg
(
not
(
feature
=
"
no_cargo
"
)
)
]
#
[
macro_export
]
macro_rules
!
crate_version
{
(
)
=
>
{
env
!
(
"
CARGO_PKG_VERSION
"
)
}
;
}
#
[
cfg
(
not
(
feature
=
"
no_cargo
"
)
)
]
#
[
macro_export
]
macro_rules
!
crate_authors
{
(
sep
:
expr
)
=
>
{
{
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
sync
:
:
{
ONCE_INIT
Once
}
;
#
[
allow
(
missing_copy_implementations
)
]
#
[
allow
(
dead_code
)
]
struct
CargoAuthors
{
__private_field
:
(
)
}
;
impl
Deref
for
CargoAuthors
{
type
Target
=
str
;
#
[
allow
(
unsafe_code
)
]
fn
deref
(
&
self
)
-
>
&
'
static
str
{
static
ONCE
:
Once
=
ONCE_INIT
;
static
mut
VALUE
:
*
const
String
=
0
as
*
const
String
;
unsafe
{
ONCE
.
call_once
(
|
|
{
let
s
=
env
!
(
"
CARGO_PKG_AUTHORS
"
)
.
replace
(
'
:
'
sep
)
;
VALUE
=
Box
:
:
into_raw
(
Box
:
:
new
(
s
)
)
;
}
)
;
&
(
*
VALUE
)
[
.
.
]
}
}
}
&
*
CargoAuthors
{
__private_field
:
(
)
}
}
}
;
(
)
=
>
{
env
!
(
"
CARGO_PKG_AUTHORS
"
)
}
;
}
#
[
cfg
(
not
(
feature
=
"
no_cargo
"
)
)
]
#
[
macro_export
]
macro_rules
!
crate_description
{
(
)
=
>
{
env
!
(
"
CARGO_PKG_DESCRIPTION
"
)
}
;
}
#
[
cfg
(
not
(
feature
=
"
no_cargo
"
)
)
]
#
[
macro_export
]
macro_rules
!
crate_name
{
(
)
=
>
{
env
!
(
"
CARGO_PKG_NAME
"
)
}
;
}
#
[
cfg
(
not
(
feature
=
"
no_cargo
"
)
)
]
#
[
macro_export
]
macro_rules
!
app_from_crate
{
(
)
=
>
{
crate
:
:
App
:
:
new
(
crate_name
!
(
)
)
.
version
(
crate_version
!
(
)
)
.
author
(
crate_authors
!
(
)
)
.
about
(
crate_description
!
(
)
)
}
;
(
sep
:
expr
)
=
>
{
crate
:
:
App
:
:
new
(
crate_name
!
(
)
)
.
version
(
crate_version
!
(
)
)
.
author
(
crate_authors
!
(
sep
)
)
.
about
(
crate_description
!
(
)
)
}
;
}
#
[
macro_export
]
macro_rules
!
clap_app
{
(
app
(
builder
:
expr
)
)
=
>
{
builder
}
;
(
app
(
builder
:
expr
)
(
arg
(
name
:
expr
)
:
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
clap_app
!
{
app
(
builder
.
arg
(
clap_app
!
{
arg
(
crate
:
:
Arg
:
:
with_name
(
name
)
)
(
-
)
(
tail
)
*
}
)
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
arg
name
:
ident
:
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
clap_app
!
{
app
(
builder
.
arg
(
clap_app
!
{
arg
(
crate
:
:
Arg
:
:
with_name
(
stringify
!
(
name
)
)
)
(
-
)
(
tail
)
*
}
)
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
setting
setting
:
ident
)
(
tt
:
tt
)
*
)
=
>
{
clap_app
!
{
app
(
builder
.
setting
(
crate
:
:
AppSettings
:
:
setting
)
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
attributes
(
attr
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
clap_app
!
{
app
(
clap_app
!
{
arg
(
builder
)
(
attr
)
*
}
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
group
name
:
ident
=
>
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
clap_app
!
{
app
(
clap_app
!
{
group
(
builder
crate
:
:
ArgGroup
:
:
with_name
(
stringify
!
(
name
)
)
)
(
tail
)
*
}
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
subcommand
name
:
ident
=
>
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
clap_app
!
{
app
(
builder
.
subcommand
(
clap_app
!
{
app
(
crate
:
:
SubCommand
:
:
with_name
(
stringify
!
(
name
)
)
)
(
tail
)
*
}
)
)
(
tt
)
*
}
}
;
(
app
(
builder
:
expr
)
(
ident
:
ident
:
(
v
:
expr
)
*
)
(
tt
:
tt
)
*
)
=
>
{
/
/
clap_app
!
{
app
(
builder
.
ident
(
(
v
)
*
)
)
(
tt
)
*
}
clap_app
!
{
app
(
builder
.
ident
(
(
v
)
*
)
)
(
tt
)
*
}
}
;
(
group
(
builder
:
expr
group
:
expr
)
)
=
>
{
builder
.
group
(
group
)
}
;
(
group
(
builder
:
expr
group
:
expr
)
(
attributes
(
attr
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
clap_app
!
{
group
(
builder
clap_app
!
{
arg
(
group
)
(
-
)
(
attr
)
*
}
)
(
tt
)
*
}
}
;
(
group
(
builder
:
expr
group
:
expr
)
(
arg
name
:
ident
:
(
tail
:
tt
)
*
)
(
tt
:
tt
)
*
)
=
>
{
clap_app
!
{
group
(
clap_app
!
{
app
(
builder
)
(
arg
name
:
(
tail
)
*
)
}
group
.
arg
(
stringify
!
(
name
)
)
)
(
tt
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
)
=
>
{
arg
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
-
-
(
long
:
expr
)
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
.
long
(
long
)
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
-
-
long
:
ident
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
.
long
(
stringify
!
(
long
)
)
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
-
short
:
ident
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
.
short
(
stringify
!
(
short
)
)
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
(
-
)
<
var
:
ident
>
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
.
value_name
(
stringify
!
(
var
)
)
)
(
+
)
+
takes_value
+
required
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
(
+
)
<
var
:
ident
>
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
.
value_name
(
stringify
!
(
var
)
)
)
(
+
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
(
-
)
[
var
:
ident
]
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
.
value_name
(
stringify
!
(
var
)
)
)
(
+
)
+
takes_value
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
(
+
)
[
var
:
ident
]
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
.
value_name
(
stringify
!
(
var
)
)
)
(
+
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
.
.
.
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
)
modes
+
multiple
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
#
{
n
:
expr
m
:
expr
}
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
)
modes
min_values
(
n
)
max_values
(
m
)
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
*
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
)
modes
+
required
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
!
ident
:
ident
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
.
ident
(
false
)
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
+
ident
:
ident
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
.
ident
(
true
)
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
{
fn_
:
expr
}
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
.
validator
(
fn_
)
)
modes
(
tail
)
*
}
}
;
(
as_expr
expr
:
expr
)
=
>
{
expr
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
desc
:
tt
)
=
>
{
arg
.
help
(
clap_app
!
{
as_expr
desc
}
)
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
ident
:
ident
[
(
target
:
ident
)
*
]
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
(
.
ident
(
stringify
!
(
target
)
)
)
*
)
modes
(
tail
)
*
}
}
;
(
arg
(
arg
:
expr
)
modes
:
tt
ident
:
ident
(
(
expr
:
expr
)
*
)
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
arg
(
arg
.
ident
(
(
expr
)
*
)
)
modes
(
tail
)
*
}
}
;
(
subcommand
name
:
ident
=
>
(
tail
:
tt
)
*
)
=
>
{
clap_app
!
{
app
(
crate
:
:
SubCommand
:
:
with_name
(
stringify
!
(
name
)
)
)
(
tail
)
*
}
}
;
(
(
name
:
expr
)
=
>
(
tail
:
tt
)
*
)
=
>
{
{
clap_app
!
{
app
(
crate
:
:
App
:
:
new
(
name
)
)
(
tail
)
*
}
}
}
;
(
name
:
ident
=
>
(
tail
:
tt
)
*
)
=
>
{
{
clap_app
!
{
app
(
crate
:
:
App
:
:
new
(
stringify
!
(
name
)
)
)
(
tail
)
*
}
}
}
;
}
macro_rules
!
impl_settings
{
(
n
:
ident
(
v
:
ident
=
>
c
:
path
)
+
)
=
>
{
pub
fn
set
(
&
mut
self
s
:
n
)
{
match
s
{
(
n
:
:
v
=
>
self
.
0
.
insert
(
c
)
)
+
}
}
pub
fn
unset
(
&
mut
self
s
:
n
)
{
match
s
{
(
n
:
:
v
=
>
self
.
0
.
remove
(
c
)
)
+
}
}
pub
fn
is_set
(
&
self
s
:
n
)
-
>
bool
{
match
s
{
(
n
:
:
v
=
>
self
.
0
.
contains
(
c
)
)
+
}
}
}
;
}
macro_rules
!
wlnerr
(
(
(
arg
:
tt
)
*
)
=
>
(
{
use
std
:
:
io
:
:
{
Write
stderr
}
;
writeln
!
(
&
mut
stderr
(
)
(
arg
)
*
)
.
ok
(
)
;
}
)
)
;
#
[
cfg
(
feature
=
"
debug
"
)
]
#
[
cfg_attr
(
feature
=
"
debug
"
macro_use
)
]
#
[
cfg_attr
(
feature
=
"
debug
"
allow
(
unused_macros
)
)
]
mod
debug_macros
{
macro_rules
!
debugln
{
(
fmt
:
expr
)
=
>
(
println
!
(
concat
!
(
"
DEBUG
:
clap
:
"
fmt
)
)
)
;
(
fmt
:
expr
(
arg
:
tt
)
*
)
=
>
(
println
!
(
concat
!
(
"
DEBUG
:
clap
:
"
fmt
)
(
arg
)
*
)
)
;
}
macro_rules
!
sdebugln
{
(
fmt
:
expr
)
=
>
(
println
!
(
fmt
)
)
;
(
fmt
:
expr
(
arg
:
tt
)
*
)
=
>
(
println
!
(
fmt
(
arg
)
*
)
)
;
}
macro_rules
!
debug
{
(
fmt
:
expr
)
=
>
(
print
!
(
concat
!
(
"
DEBUG
:
clap
:
"
fmt
)
)
)
;
(
fmt
:
expr
(
arg
:
tt
)
*
)
=
>
(
print
!
(
concat
!
(
"
DEBUG
:
clap
:
"
fmt
)
(
arg
)
*
)
)
;
}
macro_rules
!
sdebug
{
(
fmt
:
expr
)
=
>
(
print
!
(
fmt
)
)
;
(
fmt
:
expr
(
arg
:
tt
)
*
)
=
>
(
print
!
(
fmt
(
arg
)
*
)
)
;
}
}
#
[
cfg
(
not
(
feature
=
"
debug
"
)
)
]
#
[
cfg_attr
(
not
(
feature
=
"
debug
"
)
macro_use
)
]
mod
debug_macros
{
macro_rules
!
debugln
{
(
fmt
:
expr
)
=
>
(
)
;
(
fmt
:
expr
(
arg
:
tt
)
*
)
=
>
(
)
;
}
macro_rules
!
sdebugln
{
(
fmt
:
expr
)
=
>
(
)
;
(
fmt
:
expr
(
arg
:
tt
)
*
)
=
>
(
)
;
}
macro_rules
!
debug
{
(
fmt
:
expr
)
=
>
(
)
;
(
fmt
:
expr
(
arg
:
tt
)
*
)
=
>
(
)
;
}
}
macro_rules
!
write_nspaces
{
(
dst
:
expr
num
:
expr
)
=
>
(
{
debugln
!
(
"
write_spaces
!
:
num
=
{
}
"
num
)
;
for
_
in
0
.
.
num
{
dst
.
write_all
(
b
"
"
)
?
;
}
}
)
}
macro_rules
!
vec_remove_all
{
(
vec
:
expr
to_rem
:
expr
)
=
>
{
debugln
!
(
"
vec_remove_all
!
to_rem
=
{
:
?
}
"
to_rem
)
;
for
i
in
(
0
.
.
vec
.
len
(
)
)
.
rev
(
)
{
let
should_remove
=
to_rem
.
any
(
|
name
|
name
=
=
&
vec
[
i
]
)
;
if
should_remove
{
vec
.
swap_remove
(
i
)
;
}
}
}
;
}
macro_rules
!
find_from
{
(
_self
:
expr
arg_name
:
expr
from
:
ident
matcher
:
expr
)
=
>
{
{
let
mut
ret
=
None
;
for
k
in
matcher
.
arg_names
(
)
{
if
let
Some
(
f
)
=
find_by_name
!
(
_self
k
flags
iter
)
{
if
let
Some
(
ref
v
)
=
f
.
from
(
)
{
if
v
.
contains
(
arg_name
)
{
ret
=
Some
(
f
.
to_string
(
)
)
;
}
}
}
if
let
Some
(
o
)
=
find_by_name
!
(
_self
k
opts
iter
)
{
if
let
Some
(
ref
v
)
=
o
.
from
(
)
{
if
v
.
contains
(
&
arg_name
)
{
ret
=
Some
(
o
.
to_string
(
)
)
;
}
}
}
if
let
Some
(
pos
)
=
find_by_name
!
(
_self
k
positionals
values
)
{
if
let
Some
(
ref
v
)
=
pos
.
from
(
)
{
if
v
.
contains
(
arg_name
)
{
ret
=
Some
(
pos
.
b
.
name
.
to_owned
(
)
)
;
}
}
}
}
ret
}
}
;
}
macro_rules
!
find_name_from
{
(
_self
:
expr
arg_name
:
expr
from
:
ident
matcher
:
expr
)
=
>
{
{
let
mut
ret
=
None
;
for
k
in
matcher
.
arg_names
(
)
{
if
let
Some
(
f
)
=
find_by_name
!
(
_self
k
flags
iter
)
{
if
let
Some
(
ref
v
)
=
f
.
from
(
)
{
if
v
.
contains
(
arg_name
)
{
ret
=
Some
(
f
.
b
.
name
)
;
}
}
}
if
let
Some
(
o
)
=
find_by_name
!
(
_self
k
opts
iter
)
{
if
let
Some
(
ref
v
)
=
o
.
from
(
)
{
if
v
.
contains
(
&
arg_name
)
{
ret
=
Some
(
o
.
b
.
name
)
;
}
}
}
if
let
Some
(
pos
)
=
find_by_name
!
(
_self
k
positionals
values
)
{
if
let
Some
(
ref
v
)
=
pos
.
from
(
)
{
if
v
.
contains
(
arg_name
)
{
ret
=
Some
(
pos
.
b
.
name
)
;
}
}
}
}
ret
}
}
;
}
macro_rules
!
find_by_name
{
(
p
:
expr
name
:
expr
what
:
ident
how
:
ident
)
=
>
{
p
.
what
.
how
(
)
.
find
(
|
o
|
o
.
b
.
name
=
=
name
)
}
}
macro_rules
!
find_opt_by_long
{
(
os
_self
:
ident
long
:
expr
)
=
>
{
{
_find_by_long
!
(
_self
long
opts
)
}
}
;
(
_self
:
ident
long
:
expr
)
=
>
{
{
_find_by_long
!
(
_self
long
opts
)
}
}
;
}
macro_rules
!
find_flag_by_long
{
(
os
_self
:
ident
long
:
expr
)
=
>
{
{
_find_by_long
!
(
_self
long
flags
)
}
}
;
(
_self
:
ident
long
:
expr
)
=
>
{
{
_find_by_long
!
(
_self
long
flags
)
}
}
;
}
macro_rules
!
_find_by_long
{
(
_self
:
ident
long
:
expr
what
:
ident
)
=
>
{
{
_self
.
what
.
iter
(
)
.
filter
(
|
a
|
a
.
s
.
long
.
is_some
(
)
)
.
find
(
|
a
|
{
a
.
s
.
long
.
unwrap
(
)
=
=
long
|
|
(
a
.
s
.
aliases
.
is_some
(
)
&
&
a
.
s
.
aliases
.
as_ref
(
)
.
unwrap
(
)
.
iter
(
)
.
any
(
|
&
(
alias
_
)
|
alias
=
=
long
)
)
}
)
}
}
}
macro_rules
!
find_opt_by_short
{
(
_self
:
ident
short
:
expr
)
=
>
{
{
_find_by_short
!
(
_self
short
opts
)
}
}
}
macro_rules
!
find_flag_by_short
{
(
_self
:
ident
short
:
expr
)
=
>
{
{
_find_by_short
!
(
_self
short
flags
)
}
}
}
macro_rules
!
_find_by_short
{
(
_self
:
ident
short
:
expr
what
:
ident
)
=
>
{
{
_self
.
what
.
iter
(
)
.
filter
(
|
a
|
a
.
s
.
short
.
is_some
(
)
)
.
find
(
|
a
|
a
.
s
.
short
.
unwrap
(
)
=
=
short
)
}
}
}
macro_rules
!
find_subcmd
{
(
_self
:
expr
sc
:
expr
)
=
>
{
{
_self
.
subcommands
.
iter
(
)
.
find
(
|
s
|
{
&
*
s
.
p
.
meta
.
name
=
=
sc
|
|
(
s
.
p
.
meta
.
aliases
.
is_some
(
)
&
&
s
.
p
.
meta
.
aliases
.
as_ref
(
)
.
unwrap
(
)
.
iter
(
)
.
any
(
|
&
(
n
_
)
|
n
=
=
sc
)
)
}
)
}
}
;
}
macro_rules
!
shorts
{
(
_self
:
ident
)
=
>
{
{
_shorts_longs
!
(
_self
short
)
}
}
;
}
macro_rules
!
longs
{
(
_self
:
ident
)
=
>
{
{
_shorts_longs
!
(
_self
long
)
}
}
;
}
macro_rules
!
_shorts_longs
{
(
_self
:
ident
what
:
ident
)
=
>
{
{
_self
.
flags
.
iter
(
)
.
filter
(
|
f
|
f
.
s
.
what
.
is_some
(
)
)
.
map
(
|
f
|
f
.
s
.
what
.
as_ref
(
)
.
unwrap
(
)
)
.
chain
(
_self
.
opts
.
iter
(
)
.
filter
(
|
o
|
o
.
s
.
what
.
is_some
(
)
)
.
map
(
|
o
|
o
.
s
.
what
.
as_ref
(
)
.
unwrap
(
)
)
)
}
}
;
}
macro_rules
!
arg_names
{
(
_self
:
ident
)
=
>
{
{
_names
!
(
args
_self
)
}
}
;
}
macro_rules
!
sc_names
{
(
_self
:
ident
)
=
>
{
{
_names
!
(
sc
_self
)
}
}
;
}
macro_rules
!
_names
{
(
args
_self
:
ident
)
=
>
{
{
_self
.
flags
.
iter
(
)
.
map
(
|
f
|
&
*
f
.
b
.
name
)
.
chain
(
_self
.
opts
.
iter
(
)
.
map
(
|
o
|
&
*
o
.
b
.
name
)
.
chain
(
_self
.
positionals
.
values
(
)
.
map
(
|
p
|
&
*
p
.
b
.
name
)
)
)
}
}
;
(
sc
_self
:
ident
)
=
>
{
{
_self
.
subcommands
.
iter
(
)
.
map
(
|
s
|
&
*
s
.
p
.
meta
.
name
)
.
chain
(
_self
.
subcommands
.
iter
(
)
.
filter
(
|
s
|
s
.
p
.
meta
.
aliases
.
is_some
(
)
)
.
flat_map
(
|
s
|
s
.
p
.
meta
.
aliases
.
as_ref
(
)
.
unwrap
(
)
.
iter
(
)
.
map
(
|
&
(
n
_
)
|
n
)
)
)
}
}
}
