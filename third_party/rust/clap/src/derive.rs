use
crate
:
:
{
App
ArgMatches
Error
PossibleValue
}
;
use
std
:
:
ffi
:
:
OsString
;
#
[
cfg_attr
(
not
(
feature
=
"
derive
"
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
feature
=
"
derive
"
doc
=
"
"
)
]
pub
trait
Parser
:
FromArgMatches
+
IntoApp
+
Sized
{
fn
parse
(
)
-
>
Self
{
let
matches
=
<
Self
as
IntoApp
>
:
:
into_app
(
)
.
get_matches
(
)
;
let
res
=
<
Self
as
FromArgMatches
>
:
:
from_arg_matches
(
&
matches
)
.
map_err
(
format_error
:
:
<
Self
>
)
;
match
res
{
Ok
(
s
)
=
>
s
Err
(
e
)
=
>
{
e
.
exit
(
)
}
}
}
fn
try_parse
(
)
-
>
Result
<
Self
Error
>
{
let
matches
=
<
Self
as
IntoApp
>
:
:
into_app
(
)
.
try_get_matches
(
)
?
;
<
Self
as
FromArgMatches
>
:
:
from_arg_matches
(
&
matches
)
.
map_err
(
format_error
:
:
<
Self
>
)
}
fn
parse_from
<
I
T
>
(
itr
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
let
matches
=
<
Self
as
IntoApp
>
:
:
into_app
(
)
.
get_matches_from
(
itr
)
;
let
res
=
<
Self
as
FromArgMatches
>
:
:
from_arg_matches
(
&
matches
)
.
map_err
(
format_error
:
:
<
Self
>
)
;
match
res
{
Ok
(
s
)
=
>
s
Err
(
e
)
=
>
{
e
.
exit
(
)
}
}
}
fn
try_parse_from
<
I
T
>
(
itr
:
I
)
-
>
Result
<
Self
Error
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
let
matches
=
<
Self
as
IntoApp
>
:
:
into_app
(
)
.
try_get_matches_from
(
itr
)
?
;
<
Self
as
FromArgMatches
>
:
:
from_arg_matches
(
&
matches
)
.
map_err
(
format_error
:
:
<
Self
>
)
}
fn
update_from
<
I
T
>
(
&
mut
self
itr
:
I
)
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
let
matches
=
<
Self
as
IntoApp
>
:
:
into_app_for_update
(
)
.
get_matches_from
(
itr
)
;
let
res
=
<
Self
as
FromArgMatches
>
:
:
update_from_arg_matches
(
self
&
matches
)
.
map_err
(
format_error
:
:
<
Self
>
)
;
if
let
Err
(
e
)
=
res
{
e
.
exit
(
)
}
}
fn
try_update_from
<
I
T
>
(
&
mut
self
itr
:
I
)
-
>
Result
<
(
)
Error
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
let
matches
=
<
Self
as
IntoApp
>
:
:
into_app_for_update
(
)
.
try_get_matches_from
(
itr
)
?
;
<
Self
as
FromArgMatches
>
:
:
update_from_arg_matches
(
self
&
matches
)
.
map_err
(
format_error
:
:
<
Self
>
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
StructOpt
:
:
clap
is
replaced
with
IntoApp
:
:
into_app
(
derived
as
part
of
Parser
)
"
)
]
fn
clap
<
'
help
>
(
)
-
>
App
<
'
help
>
{
<
Self
as
IntoApp
>
:
:
into_app
(
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
StructOpt
:
:
from_clap
is
replaced
with
FromArgMatches
:
:
from_arg_matches
(
derived
as
part
of
Parser
)
"
)
]
fn
from_clap
(
matches
:
&
ArgMatches
)
-
>
Self
{
<
Self
as
FromArgMatches
>
:
:
from_arg_matches
(
matches
)
.
unwrap
(
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
StructOpt
:
:
from_args
is
replaced
with
Parser
:
:
parse
(
note
the
change
in
derives
)
"
)
]
fn
from_args
(
)
-
>
Self
{
Self
:
:
parse
(
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
StructOpt
:
:
from_args_safe
is
replaced
with
Parser
:
:
try_parse
(
note
the
change
in
derives
)
"
)
]
fn
from_args_safe
(
)
-
>
Result
<
Self
Error
>
{
Self
:
:
try_parse
(
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
StructOpt
:
:
from_iter
is
replaced
with
Parser
:
:
parse_from
(
note
the
change
in
derives
)
"
)
]
fn
from_iter
<
I
T
>
(
itr
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
Self
:
:
parse_from
(
itr
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
StructOpt
:
:
from_iter_safe
is
replaced
with
Parser
:
:
try_parse_from
(
note
the
change
in
derives
)
"
)
]
fn
from_iter_safe
<
I
T
>
(
itr
:
I
)
-
>
Result
<
Self
Error
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
Self
:
:
try_parse_from
(
itr
)
}
}
pub
trait
IntoApp
:
Sized
{
fn
into_app
<
'
help
>
(
)
-
>
App
<
'
help
>
;
fn
into_app_for_update
<
'
help
>
(
)
-
>
App
<
'
help
>
;
}
pub
trait
FromArgMatches
:
Sized
{
#
[
cfg_attr
(
not
(
feature
=
"
derive
"
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
feature
=
"
derive
"
doc
=
"
no_run
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
derive
"
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
feature
=
"
derive
"
doc
=
"
no_run
"
)
]
fn
from_arg_matches
(
matches
:
&
ArgMatches
)
-
>
Result
<
Self
Error
>
;
fn
update_from_arg_matches
(
&
mut
self
matches
:
&
ArgMatches
)
-
>
Result
<
(
)
Error
>
;
}
#
[
cfg_attr
(
not
(
feature
=
"
derive
"
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
feature
=
"
derive
"
doc
=
"
"
)
]
pub
trait
Args
:
FromArgMatches
+
Sized
{
fn
augment_args
(
app
:
App
<
'
_
>
)
-
>
App
<
'
_
>
;
fn
augment_args_for_update
(
app
:
App
<
'
_
>
)
-
>
App
<
'
_
>
;
}
#
[
cfg_attr
(
not
(
feature
=
"
derive
"
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
feature
=
"
derive
"
doc
=
"
"
)
]
pub
trait
Subcommand
:
FromArgMatches
+
Sized
{
fn
augment_subcommands
(
app
:
App
<
'
_
>
)
-
>
App
<
'
_
>
;
fn
augment_subcommands_for_update
(
app
:
App
<
'
_
>
)
-
>
App
<
'
_
>
;
fn
has_subcommand
(
name
:
&
str
)
-
>
bool
;
}
#
[
cfg_attr
(
not
(
feature
=
"
derive
"
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
feature
=
"
derive
"
doc
=
"
"
)
]
pub
trait
ArgEnum
:
Sized
+
Clone
{
fn
value_variants
<
'
a
>
(
)
-
>
&
'
a
[
Self
]
;
fn
from_str
(
input
:
&
str
ignore_case
:
bool
)
-
>
Result
<
Self
String
>
{
Self
:
:
value_variants
(
)
.
iter
(
)
.
find
(
|
v
|
{
v
.
to_possible_value
(
)
.
expect
(
"
ArgEnum
:
:
value_variants
contains
only
values
with
a
corresponding
ArgEnum
:
:
to_possible_value
"
)
.
matches
(
input
ignore_case
)
}
)
.
cloned
(
)
.
ok_or_else
(
|
|
format
!
(
"
Invalid
variant
:
{
}
"
input
)
)
}
fn
to_possible_value
<
'
a
>
(
&
self
)
-
>
Option
<
PossibleValue
<
'
a
>
>
;
}
impl
<
T
:
Parser
>
Parser
for
Box
<
T
>
{
fn
parse
(
)
-
>
Self
{
Box
:
:
new
(
<
T
as
Parser
>
:
:
parse
(
)
)
}
fn
try_parse
(
)
-
>
Result
<
Self
Error
>
{
<
T
as
Parser
>
:
:
try_parse
(
)
.
map
(
Box
:
:
new
)
}
fn
parse_from
<
I
It
>
(
itr
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
It
>
It
:
Into
<
OsString
>
+
Clone
{
Box
:
:
new
(
<
T
as
Parser
>
:
:
parse_from
(
itr
)
)
}
fn
try_parse_from
<
I
It
>
(
itr
:
I
)
-
>
Result
<
Self
Error
>
where
I
:
IntoIterator
<
Item
=
It
>
It
:
Into
<
OsString
>
+
Clone
{
<
T
as
Parser
>
:
:
try_parse_from
(
itr
)
.
map
(
Box
:
:
new
)
}
}
impl
<
T
:
IntoApp
>
IntoApp
for
Box
<
T
>
{
fn
into_app
<
'
help
>
(
)
-
>
App
<
'
help
>
{
<
T
as
IntoApp
>
:
:
into_app
(
)
}
fn
into_app_for_update
<
'
help
>
(
)
-
>
App
<
'
help
>
{
<
T
as
IntoApp
>
:
:
into_app_for_update
(
)
}
}
impl
<
T
:
FromArgMatches
>
FromArgMatches
for
Box
<
T
>
{
fn
from_arg_matches
(
matches
:
&
ArgMatches
)
-
>
Result
<
Self
Error
>
{
<
T
as
FromArgMatches
>
:
:
from_arg_matches
(
matches
)
.
map
(
Box
:
:
new
)
}
fn
update_from_arg_matches
(
&
mut
self
matches
:
&
ArgMatches
)
-
>
Result
<
(
)
Error
>
{
<
T
as
FromArgMatches
>
:
:
update_from_arg_matches
(
self
matches
)
}
}
impl
<
T
:
Args
>
Args
for
Box
<
T
>
{
fn
augment_args
(
app
:
App
<
'
_
>
)
-
>
App
<
'
_
>
{
<
T
as
Args
>
:
:
augment_args
(
app
)
}
fn
augment_args_for_update
(
app
:
App
<
'
_
>
)
-
>
App
<
'
_
>
{
<
T
as
Args
>
:
:
augment_args_for_update
(
app
)
}
}
impl
<
T
:
Subcommand
>
Subcommand
for
Box
<
T
>
{
fn
augment_subcommands
(
app
:
App
<
'
_
>
)
-
>
App
<
'
_
>
{
<
T
as
Subcommand
>
:
:
augment_subcommands
(
app
)
}
fn
augment_subcommands_for_update
(
app
:
App
<
'
_
>
)
-
>
App
<
'
_
>
{
<
T
as
Subcommand
>
:
:
augment_subcommands_for_update
(
app
)
}
fn
has_subcommand
(
name
:
&
str
)
-
>
bool
{
<
T
as
Subcommand
>
:
:
has_subcommand
(
name
)
}
}
fn
format_error
<
I
:
IntoApp
>
(
err
:
crate
:
:
Error
)
-
>
crate
:
:
Error
{
let
mut
app
=
I
:
:
into_app
(
)
;
err
.
format
(
&
mut
app
)
}
