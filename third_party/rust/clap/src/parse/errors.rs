use
std
:
:
{
borrow
:
:
Cow
convert
:
:
From
error
fmt
:
:
{
self
Debug
Display
Formatter
}
io
:
:
{
self
BufRead
}
result
:
:
Result
as
StdResult
}
;
use
crate
:
:
{
build
:
:
Arg
output
:
:
fmt
:
:
Colorizer
parse
:
:
features
:
:
suggestions
util
:
:
{
color
:
:
ColorChoice
safe_exit
SUCCESS_CODE
USAGE_CODE
}
App
AppSettings
}
;
pub
type
Result
<
T
>
=
StdResult
<
T
Error
>
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
non_exhaustive
]
pub
enum
ErrorKind
{
InvalidValue
UnknownArgument
#
[
cfg_attr
(
not
(
feature
=
"
suggestions
"
)
doc
=
"
no_run
"
)
]
#
[
cfg_attr
(
feature
=
"
suggestions
"
doc
=
"
"
)
]
InvalidSubcommand
UnrecognizedSubcommand
EmptyValue
NoEquals
ValueValidation
TooManyValues
TooFewValues
TooManyOccurrences
WrongNumberOfValues
ArgumentConflict
MissingRequiredArgument
MissingSubcommand
UnexpectedMultipleUsage
#
[
cfg_attr
(
not
(
unix
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
unix
doc
=
"
"
)
]
InvalidUtf8
DisplayHelp
DisplayHelpOnMissingArgumentOrSubcommand
DisplayVersion
ArgumentNotFound
Io
Format
}
#
[
derive
(
Debug
)
]
pub
struct
Error
{
pub
(
crate
)
message
:
Message
pub
kind
:
ErrorKind
pub
info
:
Vec
<
String
>
pub
(
crate
)
source
:
Option
<
Box
<
dyn
error
:
:
Error
+
Send
+
Sync
>
>
wait_on_exit
:
bool
backtrace
:
Option
<
Backtrace
>
}
impl
Error
{
pub
fn
raw
(
kind
:
ErrorKind
message
:
impl
std
:
:
fmt
:
:
Display
)
-
>
Self
{
Self
:
:
new
(
message
.
to_string
(
)
kind
false
)
}
#
[
must_use
]
pub
fn
format
(
mut
self
app
:
&
mut
App
)
-
>
Self
{
app
.
_build
(
)
;
let
usage
=
app
.
render_usage
(
)
;
self
.
message
.
format
(
app
usage
)
;
self
.
wait_on_exit
=
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
;
self
}
#
[
inline
]
pub
fn
use_stderr
(
&
self
)
-
>
bool
{
!
matches
!
(
self
.
kind
ErrorKind
:
:
DisplayHelp
|
ErrorKind
:
:
DisplayVersion
)
}
pub
fn
exit
(
&
self
)
-
>
!
{
if
self
.
use_stderr
(
)
{
let
_
=
self
.
print
(
)
;
if
self
.
wait_on_exit
{
wlnerr
!
(
"
\
nPress
[
ENTER
]
/
[
RETURN
]
to
continue
.
.
.
"
)
;
let
mut
s
=
String
:
:
new
(
)
;
let
i
=
io
:
:
stdin
(
)
;
i
.
lock
(
)
.
read_line
(
&
mut
s
)
.
unwrap
(
)
;
}
safe_exit
(
USAGE_CODE
)
;
}
let
_
=
self
.
print
(
)
;
safe_exit
(
SUCCESS_CODE
)
}
pub
fn
print
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
message
.
formatted
(
)
.
print
(
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
error
"
)
]
pub
fn
with_description
(
description
:
String
kind
:
ErrorKind
)
-
>
Self
{
Error
:
:
raw
(
kind
description
)
}
pub
(
crate
)
fn
new
(
message
:
impl
Into
<
Message
>
kind
:
ErrorKind
wait_on_exit
:
bool
)
-
>
Self
{
Self
{
message
:
message
.
into
(
)
kind
info
:
vec
!
[
]
source
:
None
wait_on_exit
backtrace
:
Backtrace
:
:
new
(
)
}
}
pub
(
crate
)
fn
set_info
(
mut
self
info
:
Vec
<
String
>
)
-
>
Self
{
self
.
info
=
info
;
self
}
pub
(
crate
)
fn
set_source
(
mut
self
source
:
Box
<
dyn
error
:
:
Error
+
Send
+
Sync
>
)
-
>
Self
{
self
.
source
=
Some
(
source
)
;
self
}
pub
(
crate
)
fn
argument_conflict
(
app
:
&
App
arg
:
&
Arg
others
:
Vec
<
String
>
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
let
arg
=
arg
.
to_string
(
)
;
start_error
(
&
mut
c
"
The
argument
'
"
)
;
c
.
warning
(
arg
)
;
c
.
none
(
"
'
cannot
be
used
with
"
)
;
let
mut
info
=
vec
!
[
]
;
match
others
.
len
(
)
{
0
=
>
{
c
.
none
(
"
one
or
more
of
the
other
specified
arguments
"
)
;
}
1
=
>
{
let
v
=
&
others
[
0
]
;
c
.
none
(
"
'
"
)
;
c
.
warning
(
v
.
clone
(
)
)
;
c
.
none
(
"
'
"
)
;
info
.
push
(
v
.
clone
(
)
)
;
}
_
=
>
{
c
.
none
(
"
:
"
)
;
for
v
in
others
{
c
.
none
(
"
\
n
"
)
;
c
.
warning
(
v
.
to_string
(
)
)
;
info
.
push
(
v
.
to_string
(
)
)
;
}
}
}
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
ArgumentConflict
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
info
)
}
pub
(
crate
)
fn
empty_value
(
app
:
&
App
arg
:
&
Arg
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
let
arg
=
arg
.
to_string
(
)
;
start_error
(
&
mut
c
"
The
argument
'
"
)
;
c
.
warning
(
arg
.
clone
(
)
)
;
c
.
none
(
"
'
requires
a
value
but
none
was
supplied
"
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
EmptyValue
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
vec
!
[
arg
]
)
}
pub
(
crate
)
fn
no_equals
(
app
:
&
App
arg
:
String
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
start_error
(
&
mut
c
"
Equal
sign
is
needed
when
assigning
values
to
'
"
)
;
c
.
warning
(
&
arg
)
;
c
.
none
(
"
'
.
"
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
NoEquals
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
vec
!
[
arg
]
)
}
pub
(
crate
)
fn
invalid_value
<
G
>
(
app
:
&
App
bad_val
:
String
good_vals
:
&
[
G
]
arg
:
&
Arg
usage
:
String
)
-
>
Self
where
G
:
AsRef
<
str
>
+
Display
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
let
suffix
=
suggestions
:
:
did_you_mean
(
&
bad_val
good_vals
.
iter
(
)
)
.
pop
(
)
;
let
mut
sorted
:
Vec
<
String
>
=
good_vals
.
iter
(
)
.
map
(
|
v
|
v
.
to_string
(
)
)
.
map
(
|
v
|
{
if
v
.
contains
(
char
:
:
is_whitespace
)
{
format
!
(
"
{
:
?
}
"
v
)
}
else
{
v
}
}
)
.
collect
(
)
;
sorted
.
sort
(
)
;
start_error
(
&
mut
c
"
"
)
;
c
.
warning
(
format
!
(
"
{
:
?
}
"
bad_val
)
)
;
c
.
none
(
"
isn
'
t
a
valid
value
for
'
"
)
;
c
.
warning
(
arg
.
to_string
(
)
)
;
c
.
none
(
"
'
\
n
\
t
[
possible
values
:
"
)
;
if
let
Some
(
(
last
elements
)
)
=
sorted
.
split_last
(
)
{
for
v
in
elements
{
c
.
good
(
v
)
;
c
.
none
(
"
"
)
;
}
c
.
good
(
last
)
;
}
c
.
none
(
"
]
"
)
;
if
let
Some
(
val
)
=
suffix
{
c
.
none
(
"
\
n
\
n
\
tDid
you
mean
"
)
;
c
.
good
(
format
!
(
"
{
:
?
}
"
val
)
)
;
c
.
none
(
"
?
"
)
;
}
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
let
mut
info
=
vec
!
[
arg
.
to_string
(
)
bad_val
]
;
info
.
extend
(
sorted
)
;
Self
:
:
new
(
c
ErrorKind
:
:
InvalidValue
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
info
)
}
pub
(
crate
)
fn
invalid_subcommand
(
app
:
&
App
subcmd
:
String
did_you_mean
:
String
name
:
String
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
start_error
(
&
mut
c
"
The
subcommand
'
"
)
;
c
.
warning
(
subcmd
.
clone
(
)
)
;
c
.
none
(
"
'
wasn
'
t
recognized
\
n
\
n
\
tDid
you
mean
"
)
;
c
.
good
(
did_you_mean
)
;
c
.
none
(
"
"
)
;
c
.
none
(
format
!
(
"
?
\
n
\
nIf
you
believe
you
received
this
message
in
error
try
re
-
running
with
'
{
}
"
name
)
)
;
c
.
good
(
"
-
-
"
)
;
c
.
none
(
format
!
(
"
{
}
'
"
subcmd
)
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
InvalidSubcommand
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
vec
!
[
subcmd
]
)
}
pub
(
crate
)
fn
unrecognized_subcommand
(
app
:
&
App
subcmd
:
String
name
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
start_error
(
&
mut
c
"
The
subcommand
'
"
)
;
c
.
warning
(
subcmd
.
clone
(
)
)
;
c
.
none
(
"
'
wasn
'
t
recognized
\
n
\
n
"
)
;
c
.
warning
(
"
USAGE
:
"
)
;
c
.
none
(
format
!
(
"
\
n
{
}
<
subcommands
>
"
name
)
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
UnrecognizedSubcommand
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
vec
!
[
subcmd
]
)
}
pub
(
crate
)
fn
missing_required_argument
(
app
:
&
App
required
:
Vec
<
String
>
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
start_error
(
&
mut
c
"
The
following
required
arguments
were
not
provided
:
"
)
;
let
mut
info
=
vec
!
[
]
;
for
v
in
required
{
c
.
none
(
"
\
n
"
)
;
c
.
good
(
v
.
to_string
(
)
)
;
info
.
push
(
v
.
to_string
(
)
)
;
}
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
MissingRequiredArgument
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
info
)
}
pub
(
crate
)
fn
missing_subcommand
(
app
:
&
App
name
:
String
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
start_error
(
&
mut
c
"
'
"
)
;
c
.
warning
(
name
)
;
c
.
none
(
"
'
requires
a
subcommand
but
one
was
not
provided
"
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
MissingSubcommand
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
}
pub
(
crate
)
fn
invalid_utf8
(
app
:
&
App
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
start_error
(
&
mut
c
"
Invalid
UTF
-
8
was
detected
in
one
or
more
arguments
"
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
InvalidUtf8
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
}
pub
(
crate
)
fn
too_many_occurrences
(
app
:
&
App
arg
:
&
Arg
max_occurs
:
usize
curr_occurs
:
usize
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
let
verb
=
Error
:
:
singular_or_plural
(
curr_occurs
)
;
start_error
(
&
mut
c
"
The
argument
'
"
)
;
c
.
warning
(
arg
.
to_string
(
)
)
;
c
.
none
(
"
'
allows
at
most
"
)
;
c
.
warning
(
max_occurs
.
to_string
(
)
)
;
c
.
none
(
"
occurrences
but
"
)
;
c
.
warning
(
curr_occurs
.
to_string
(
)
)
;
c
.
none
(
format
!
(
"
{
}
provided
"
verb
)
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
TooManyOccurrences
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
vec
!
[
arg
.
to_string
(
)
curr_occurs
.
to_string
(
)
max_occurs
.
to_string
(
)
]
)
}
pub
(
crate
)
fn
too_many_values
(
app
:
&
App
val
:
String
arg
:
String
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
start_error
(
&
mut
c
"
The
value
'
"
)
;
c
.
warning
(
val
.
clone
(
)
)
;
c
.
none
(
"
'
was
provided
to
'
"
)
;
c
.
warning
(
&
arg
)
;
c
.
none
(
"
'
but
it
wasn
'
t
expecting
any
more
values
"
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
TooManyValues
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
vec
!
[
arg
val
]
)
}
pub
(
crate
)
fn
too_few_values
(
app
:
&
App
arg
:
&
Arg
min_vals
:
usize
curr_vals
:
usize
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
let
verb
=
Error
:
:
singular_or_plural
(
curr_vals
)
;
start_error
(
&
mut
c
"
The
argument
'
"
)
;
c
.
warning
(
arg
.
to_string
(
)
)
;
c
.
none
(
"
'
requires
at
least
"
)
;
c
.
warning
(
min_vals
.
to_string
(
)
)
;
c
.
none
(
"
values
but
only
"
)
;
c
.
warning
(
curr_vals
.
to_string
(
)
)
;
c
.
none
(
format
!
(
"
{
}
provided
"
verb
)
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
TooFewValues
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
vec
!
[
arg
.
to_string
(
)
curr_vals
.
to_string
(
)
min_vals
.
to_string
(
)
]
)
}
pub
(
crate
)
fn
value_validation
(
app
:
&
App
arg
:
String
val
:
String
err
:
Box
<
dyn
error
:
:
Error
+
Send
+
Sync
>
)
-
>
Self
{
let
mut
err
=
Self
:
:
value_validation_with_color
(
arg
val
err
app
.
get_color
(
)
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
;
match
&
mut
err
.
message
{
Message
:
:
Raw
(
_
)
=
>
{
unreachable
!
(
"
value_validation_with_color
only
deals
in
formatted
errors
"
)
}
Message
:
:
Formatted
(
c
)
=
>
try_help
(
app
c
)
}
err
}
pub
(
crate
)
fn
value_validation_without_app
(
arg
:
String
val
:
String
err
:
Box
<
dyn
error
:
:
Error
+
Send
+
Sync
>
)
-
>
Self
{
let
mut
err
=
Self
:
:
value_validation_with_color
(
arg
val
err
ColorChoice
:
:
Never
false
)
;
match
&
mut
err
.
message
{
Message
:
:
Raw
(
_
)
=
>
{
unreachable
!
(
"
value_validation_with_color
only
deals
in
formatted
errors
"
)
}
Message
:
:
Formatted
(
c
)
=
>
{
c
.
none
(
"
\
n
"
)
;
}
}
err
}
fn
value_validation_with_color
(
arg
:
String
val
:
String
err
:
Box
<
dyn
error
:
:
Error
+
Send
+
Sync
>
color
:
ColorChoice
wait_on_exit
:
bool
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
color
)
;
start_error
(
&
mut
c
"
Invalid
value
"
)
;
c
.
none
(
"
for
'
"
)
;
c
.
warning
(
arg
.
clone
(
)
)
;
c
.
none
(
"
'
"
)
;
c
.
none
(
format
!
(
"
:
{
}
"
err
)
)
;
Self
:
:
new
(
c
ErrorKind
:
:
ValueValidation
wait_on_exit
)
.
set_info
(
vec
!
[
arg
val
err
.
to_string
(
)
]
)
.
set_source
(
err
)
}
pub
(
crate
)
fn
wrong_number_of_values
(
app
:
&
App
arg
:
&
Arg
num_vals
:
usize
curr_vals
:
usize
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
let
verb
=
Error
:
:
singular_or_plural
(
curr_vals
)
;
start_error
(
&
mut
c
"
The
argument
'
"
)
;
c
.
warning
(
arg
.
to_string
(
)
)
;
c
.
none
(
"
'
requires
"
)
;
c
.
warning
(
num_vals
.
to_string
(
)
)
;
c
.
none
(
"
values
but
"
)
;
c
.
warning
(
curr_vals
.
to_string
(
)
)
;
c
.
none
(
format
!
(
"
{
}
provided
"
verb
)
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
WrongNumberOfValues
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
vec
!
[
arg
.
to_string
(
)
curr_vals
.
to_string
(
)
num_vals
.
to_string
(
)
]
)
}
pub
(
crate
)
fn
unexpected_multiple_usage
(
app
:
&
App
arg
:
&
Arg
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
let
arg
=
arg
.
to_string
(
)
;
start_error
(
&
mut
c
"
The
argument
'
"
)
;
c
.
warning
(
arg
.
clone
(
)
)
;
c
.
none
(
"
'
was
provided
more
than
once
but
cannot
be
used
multiple
times
"
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
UnexpectedMultipleUsage
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
vec
!
[
arg
]
)
}
pub
(
crate
)
fn
unknown_argument
(
app
:
&
App
arg
:
String
did_you_mean
:
Option
<
(
String
Option
<
String
>
)
>
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
start_error
(
&
mut
c
"
Found
argument
'
"
)
;
c
.
warning
(
arg
.
clone
(
)
)
;
c
.
none
(
"
'
which
wasn
'
t
expected
or
isn
'
t
valid
in
this
context
"
)
;
if
let
Some
(
(
flag
subcmd
)
)
=
did_you_mean
{
let
flag
=
format
!
(
"
-
-
{
}
"
flag
)
;
c
.
none
(
"
\
n
\
n
\
tDid
you
mean
"
)
;
if
let
Some
(
subcmd
)
=
subcmd
{
c
.
none
(
"
to
put
'
"
)
;
c
.
good
(
flag
)
;
c
.
none
(
"
'
after
the
subcommand
'
"
)
;
c
.
good
(
subcmd
)
;
c
.
none
(
"
'
?
"
)
;
}
else
{
c
.
none
(
"
'
"
)
;
c
.
good
(
flag
)
;
c
.
none
(
"
'
?
"
)
;
}
}
if
arg
.
starts_with
(
'
-
'
)
{
c
.
none
(
format
!
(
"
\
n
\
n
\
tIf
you
tried
to
supply
{
}
as
a
value
rather
than
a
flag
use
-
-
{
}
"
arg
arg
)
)
;
}
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
UnknownArgument
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
vec
!
[
arg
]
)
}
pub
(
crate
)
fn
unnecessary_double_dash
(
app
:
&
App
arg
:
String
usage
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
start_error
(
&
mut
c
"
Found
argument
'
"
)
;
c
.
warning
(
arg
.
clone
(
)
)
;
c
.
none
(
"
'
which
wasn
'
t
expected
or
isn
'
t
valid
in
this
context
"
)
;
c
.
none
(
format
!
(
"
\
n
\
n
\
tIf
you
tried
to
supply
{
}
as
a
subcommand
remove
the
'
-
-
'
before
it
.
"
arg
)
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
Self
:
:
new
(
c
ErrorKind
:
:
UnknownArgument
app
.
settings
.
is_set
(
AppSettings
:
:
WaitOnError
)
)
.
set_info
(
vec
!
[
arg
]
)
}
pub
(
crate
)
fn
argument_not_found_auto
(
arg
:
String
)
-
>
Self
{
let
mut
c
=
Colorizer
:
:
new
(
true
ColorChoice
:
:
Never
)
;
start_error
(
&
mut
c
"
The
argument
'
"
)
;
c
.
warning
(
arg
.
clone
(
)
)
;
c
.
none
(
"
'
wasn
'
t
found
\
n
"
)
;
Self
:
:
new
(
c
ErrorKind
:
:
ArgumentNotFound
false
)
.
set_info
(
vec
!
[
arg
]
)
}
fn
singular_or_plural
(
n
:
usize
)
-
>
String
{
if
n
>
1
{
String
:
:
from
(
"
were
"
)
}
else
{
String
:
:
from
(
"
was
"
)
}
}
}
impl
From
<
io
:
:
Error
>
for
Error
{
fn
from
(
e
:
io
:
:
Error
)
-
>
Self
{
Error
:
:
raw
(
ErrorKind
:
:
Io
e
)
}
}
impl
From
<
fmt
:
:
Error
>
for
Error
{
fn
from
(
e
:
fmt
:
:
Error
)
-
>
Self
{
Error
:
:
raw
(
ErrorKind
:
:
Format
e
)
}
}
impl
error
:
:
Error
for
Error
{
#
[
allow
(
trivial_casts
)
]
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
error
:
:
Error
+
'
static
)
>
{
self
.
source
.
as_ref
(
)
.
map
(
|
e
|
e
.
as_ref
(
)
as
_
)
}
}
impl
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
message
.
formatted
(
)
)
?
;
if
let
Some
(
backtrace
)
=
self
.
backtrace
.
as_ref
(
)
{
writeln
!
(
f
)
?
;
writeln
!
(
f
"
Backtrace
:
"
)
?
;
writeln
!
(
f
"
{
}
"
backtrace
)
?
;
}
Ok
(
(
)
)
}
}
fn
start_error
(
c
:
&
mut
Colorizer
msg
:
impl
Into
<
String
>
)
{
c
.
error
(
"
error
:
"
)
;
c
.
none
(
"
"
)
;
c
.
none
(
msg
)
;
}
fn
put_usage
(
c
:
&
mut
Colorizer
usage
:
impl
Into
<
String
>
)
{
c
.
none
(
"
\
n
\
n
"
)
;
c
.
none
(
usage
)
;
}
fn
try_help
(
app
:
&
App
c
:
&
mut
Colorizer
)
{
if
!
app
.
settings
.
is_set
(
AppSettings
:
:
DisableHelpFlag
)
{
c
.
none
(
"
\
n
\
nFor
more
information
try
"
)
;
c
.
good
(
"
-
-
help
"
)
;
c
.
none
(
"
\
n
"
)
;
}
else
if
app
.
has_subcommands
(
)
&
&
!
app
.
settings
.
is_set
(
AppSettings
:
:
DisableHelpSubcommand
)
{
c
.
none
(
"
\
n
\
nFor
more
information
try
"
)
;
c
.
good
(
"
help
"
)
;
c
.
none
(
"
\
n
"
)
;
}
else
{
c
.
none
(
"
\
n
"
)
;
}
}
#
[
derive
(
Clone
Debug
)
]
pub
(
crate
)
enum
Message
{
Raw
(
String
)
Formatted
(
Colorizer
)
}
impl
Message
{
fn
format
(
&
mut
self
app
:
&
App
usage
:
String
)
{
match
self
{
Message
:
:
Raw
(
s
)
=
>
{
let
mut
c
=
Colorizer
:
:
new
(
true
app
.
get_color
(
)
)
;
let
mut
message
=
String
:
:
new
(
)
;
std
:
:
mem
:
:
swap
(
s
&
mut
message
)
;
start_error
(
&
mut
c
message
)
;
put_usage
(
&
mut
c
usage
)
;
try_help
(
app
&
mut
c
)
;
*
self
=
Self
:
:
Formatted
(
c
)
;
}
Message
:
:
Formatted
(
_
)
=
>
{
}
}
}
fn
formatted
(
&
self
)
-
>
Cow
<
Colorizer
>
{
match
self
{
Message
:
:
Raw
(
s
)
=
>
{
let
mut
c
=
Colorizer
:
:
new
(
true
ColorChoice
:
:
Never
)
;
start_error
(
&
mut
c
s
)
;
Cow
:
:
Owned
(
c
)
}
Message
:
:
Formatted
(
c
)
=
>
Cow
:
:
Borrowed
(
c
)
}
}
}
impl
From
<
String
>
for
Message
{
fn
from
(
inner
:
String
)
-
>
Self
{
Self
:
:
Raw
(
inner
)
}
}
impl
From
<
Colorizer
>
for
Message
{
fn
from
(
inner
:
Colorizer
)
-
>
Self
{
Self
:
:
Formatted
(
inner
)
}
}
#
[
cfg
(
feature
=
"
debug
"
)
]
#
[
derive
(
Debug
)
]
struct
Backtrace
(
backtrace
:
:
Backtrace
)
;
#
[
cfg
(
feature
=
"
debug
"
)
]
impl
Backtrace
{
fn
new
(
)
-
>
Option
<
Self
>
{
Some
(
Self
(
backtrace
:
:
Backtrace
:
:
new
(
)
)
)
}
}
#
[
cfg
(
feature
=
"
debug
"
)
]
impl
Display
for
Backtrace
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
"
self
.
0
)
}
}
#
[
cfg
(
not
(
feature
=
"
debug
"
)
)
]
#
[
derive
(
Debug
)
]
struct
Backtrace
;
#
[
cfg
(
not
(
feature
=
"
debug
"
)
)
]
impl
Backtrace
{
fn
new
(
)
-
>
Option
<
Self
>
{
None
}
}
#
[
cfg
(
not
(
feature
=
"
debug
"
)
)
]
impl
Display
for
Backtrace
{
fn
fmt
(
&
self
_
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
Ok
(
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
mod
clap_error_impl_send_sync
{
use
crate
:
:
Error
;
trait
Foo
:
std
:
:
error
:
:
Error
+
Send
+
Sync
+
'
static
{
}
impl
Foo
for
Error
{
}
}
}
