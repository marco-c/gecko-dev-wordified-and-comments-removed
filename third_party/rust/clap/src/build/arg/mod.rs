#
[
cfg
(
debug_assertions
)
]
pub
mod
debug_asserts
;
mod
possible_value
;
mod
settings
;
#
[
cfg
(
test
)
]
mod
tests
;
mod
value_hint
;
pub
use
self
:
:
possible_value
:
:
PossibleValue
;
pub
use
self
:
:
settings
:
:
{
ArgFlags
ArgSettings
}
;
pub
use
self
:
:
value_hint
:
:
ValueHint
;
use
std
:
:
{
borrow
:
:
Cow
cmp
:
:
{
Ord
Ordering
}
error
:
:
Error
ffi
:
:
OsStr
fmt
:
:
{
self
Display
Formatter
}
iter
str
sync
:
:
{
Arc
Mutex
}
}
;
#
[
cfg
(
feature
=
"
env
"
)
]
use
std
:
:
{
env
ffi
:
:
OsString
}
;
#
[
cfg
(
feature
=
"
yaml
"
)
]
use
yaml_rust
:
:
Yaml
;
use
crate
:
:
{
build
:
:
usage_parser
:
:
UsageParser
util
:
:
{
Id
Key
}
INTERNAL_ERROR_MSG
}
;
#
[
cfg
(
feature
=
"
regex
"
)
]
mod
regex
;
#
[
cfg
(
feature
=
"
regex
"
)
]
pub
use
self
:
:
regex
:
:
RegexRef
;
#
[
allow
(
missing_debug_implementations
)
]
#
[
derive
(
Default
Clone
)
]
pub
struct
Arg
<
'
help
>
{
pub
(
crate
)
id
:
Id
pub
(
crate
)
provider
:
ArgProvider
pub
(
crate
)
name
:
&
'
help
str
pub
(
crate
)
help
:
Option
<
&
'
help
str
>
pub
(
crate
)
long_help
:
Option
<
&
'
help
str
>
pub
(
crate
)
blacklist
:
Vec
<
Id
>
pub
(
crate
)
settings
:
ArgFlags
pub
(
crate
)
overrides
:
Vec
<
Id
>
pub
(
crate
)
groups
:
Vec
<
Id
>
pub
(
crate
)
requires
:
Vec
<
(
Option
<
&
'
help
str
>
Id
)
>
pub
(
crate
)
r_ifs
:
Vec
<
(
Id
&
'
help
str
)
>
pub
(
crate
)
r_ifs_all
:
Vec
<
(
Id
&
'
help
str
)
>
pub
(
crate
)
r_unless
:
Vec
<
Id
>
pub
(
crate
)
r_unless_all
:
Vec
<
Id
>
pub
(
crate
)
short
:
Option
<
char
>
pub
(
crate
)
long
:
Option
<
&
'
help
str
>
pub
(
crate
)
aliases
:
Vec
<
(
&
'
help
str
bool
)
>
pub
(
crate
)
short_aliases
:
Vec
<
(
char
bool
)
>
pub
(
crate
)
disp_ord
:
Option
<
usize
>
pub
(
crate
)
possible_vals
:
Vec
<
PossibleValue
<
'
help
>
>
pub
(
crate
)
val_names
:
Vec
<
&
'
help
str
>
pub
(
crate
)
num_vals
:
Option
<
usize
>
pub
(
crate
)
max_occurs
:
Option
<
usize
>
pub
(
crate
)
max_vals
:
Option
<
usize
>
pub
(
crate
)
min_vals
:
Option
<
usize
>
pub
(
crate
)
validator
:
Option
<
Arc
<
Mutex
<
Validator
<
'
help
>
>
>
>
pub
(
crate
)
validator_os
:
Option
<
Arc
<
Mutex
<
ValidatorOs
<
'
help
>
>
>
>
pub
(
crate
)
val_delim
:
Option
<
char
>
pub
(
crate
)
default_vals
:
Vec
<
&
'
help
OsStr
>
pub
(
crate
)
default_vals_ifs
:
Vec
<
(
Id
Option
<
&
'
help
OsStr
>
Option
<
&
'
help
OsStr
>
)
>
pub
(
crate
)
default_missing_vals
:
Vec
<
&
'
help
OsStr
>
#
[
cfg
(
feature
=
"
env
"
)
]
pub
(
crate
)
env
:
Option
<
(
&
'
help
OsStr
Option
<
OsString
>
)
>
pub
(
crate
)
terminator
:
Option
<
&
'
help
str
>
pub
(
crate
)
index
:
Option
<
usize
>
pub
(
crate
)
help_heading
:
Option
<
Option
<
&
'
help
str
>
>
pub
(
crate
)
value_hint
:
ValueHint
}
impl
<
'
help
>
Arg
<
'
help
>
{
pub
fn
new
<
S
:
Into
<
&
'
help
str
>
>
(
n
:
S
)
-
>
Self
{
Arg
:
:
default
(
)
.
name
(
n
)
}
#
[
must_use
]
pub
fn
name
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
n
:
S
)
-
>
Self
{
let
name
=
n
.
into
(
)
;
self
.
id
=
Id
:
:
from
(
&
*
name
)
;
self
.
name
=
name
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
short
(
mut
self
s
:
char
)
-
>
Self
{
assert
!
(
s
!
=
'
-
'
"
short
option
name
cannot
be
-
"
)
;
self
.
short
=
Some
(
s
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
long
(
mut
self
l
:
&
'
help
str
)
-
>
Self
{
self
.
long
=
Some
(
l
.
trim_start_matches
(
|
c
|
c
=
=
'
-
'
)
)
;
self
}
#
[
must_use
]
pub
fn
alias
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
name
:
S
)
-
>
Self
{
self
.
aliases
.
push
(
(
name
.
into
(
)
false
)
)
;
self
}
#
[
must_use
]
pub
fn
short_alias
(
mut
self
name
:
char
)
-
>
Self
{
assert
!
(
name
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_aliases
.
push
(
(
name
false
)
)
;
self
}
#
[
must_use
]
pub
fn
aliases
(
mut
self
names
:
&
[
&
'
help
str
]
)
-
>
Self
{
self
.
aliases
.
extend
(
names
.
iter
(
)
.
map
(
|
&
x
|
(
x
false
)
)
)
;
self
}
#
[
must_use
]
pub
fn
short_aliases
(
mut
self
names
:
&
[
char
]
)
-
>
Self
{
for
s
in
names
{
assert
!
(
s
!
=
&
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_aliases
.
push
(
(
*
s
false
)
)
;
}
self
}
#
[
must_use
]
pub
fn
visible_alias
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
name
:
S
)
-
>
Self
{
self
.
aliases
.
push
(
(
name
.
into
(
)
true
)
)
;
self
}
#
[
must_use
]
pub
fn
visible_short_alias
(
mut
self
name
:
char
)
-
>
Self
{
assert
!
(
name
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_aliases
.
push
(
(
name
true
)
)
;
self
}
#
[
must_use
]
pub
fn
visible_aliases
(
mut
self
names
:
&
[
&
'
help
str
]
)
-
>
Self
{
self
.
aliases
.
extend
(
names
.
iter
(
)
.
map
(
|
n
|
(
*
n
true
)
)
)
;
self
}
#
[
must_use
]
pub
fn
visible_short_aliases
(
mut
self
names
:
&
[
char
]
)
-
>
Self
{
for
n
in
names
{
assert
!
(
n
!
=
&
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_aliases
.
push
(
(
*
n
true
)
)
;
}
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
index
(
mut
self
idx
:
usize
)
-
>
Self
{
self
.
index
=
Some
(
idx
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
last
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
Last
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
Last
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
required
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
Required
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
Required
)
}
}
#
[
must_use
]
pub
fn
requires
<
T
:
Key
>
(
mut
self
arg_id
:
T
)
-
>
Self
{
self
.
requires
.
push
(
(
None
arg_id
.
into
(
)
)
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
exclusive
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
Exclusive
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
Exclusive
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
global
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
Global
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
Global
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
multiple_occurrences
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
MultipleOccurrences
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
MultipleOccurrences
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
max_occurrences
(
mut
self
qty
:
usize
)
-
>
Self
{
self
.
max_occurs
=
Some
(
qty
)
;
if
qty
>
1
{
self
.
multiple_occurrences
(
true
)
}
else
{
self
}
}
#
[
inline
]
pub
fn
is_set
(
&
self
s
:
ArgSettings
)
-
>
bool
{
self
.
settings
.
is_set
(
s
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
setting
<
F
>
(
mut
self
setting
:
F
)
-
>
Self
where
F
:
Into
<
ArgFlags
>
{
self
.
settings
.
insert
(
setting
.
into
(
)
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
unset_setting
<
F
>
(
mut
self
setting
:
F
)
-
>
Self
where
F
:
Into
<
ArgFlags
>
{
self
.
settings
.
remove
(
setting
.
into
(
)
)
;
self
}
}
impl
<
'
help
>
Arg
<
'
help
>
{
#
[
inline
]
#
[
must_use
]
pub
fn
takes_value
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
TakesValue
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
TakesValue
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
multiple_values
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
MultipleValues
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
MultipleValues
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
number_of_values
(
mut
self
qty
:
usize
)
-
>
Self
{
self
.
num_vals
=
Some
(
qty
)
;
self
.
takes_value
(
true
)
.
multiple_values
(
true
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
max_values
(
mut
self
qty
:
usize
)
-
>
Self
{
self
.
max_vals
=
Some
(
qty
)
;
self
.
takes_value
(
true
)
.
multiple_values
(
true
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
min_values
(
mut
self
qty
:
usize
)
-
>
Self
{
self
.
min_vals
=
Some
(
qty
)
;
self
.
takes_value
(
true
)
.
multiple_values
(
true
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
value_name
(
self
name
:
&
'
help
str
)
-
>
Self
{
self
.
value_names
(
&
[
name
]
)
}
#
[
must_use
]
pub
fn
value_names
(
mut
self
names
:
&
[
&
'
help
str
]
)
-
>
Self
{
self
.
val_names
=
names
.
to_vec
(
)
;
self
.
takes_value
(
true
)
}
#
[
must_use
]
pub
fn
value_hint
(
mut
self
value_hint
:
ValueHint
)
-
>
Self
{
self
.
value_hint
=
value_hint
;
self
.
takes_value
(
true
)
}
#
[
must_use
]
pub
fn
validator
<
F
O
E
>
(
mut
self
mut
f
:
F
)
-
>
Self
where
F
:
FnMut
(
&
str
)
-
>
Result
<
O
E
>
+
Send
+
'
help
E
:
Into
<
Box
<
dyn
Error
+
Send
+
Sync
+
'
static
>
>
{
self
.
validator
=
Some
(
Arc
:
:
new
(
Mutex
:
:
new
(
move
|
s
:
&
str
|
{
f
(
s
)
.
map
(
|
_
|
(
)
)
.
map_err
(
|
e
|
e
.
into
(
)
)
}
)
)
)
;
self
}
#
[
cfg_attr
(
not
(
unix
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
unix
doc
=
"
rust
"
)
]
#
[
must_use
]
pub
fn
validator_os
<
F
O
E
>
(
mut
self
mut
f
:
F
)
-
>
Self
where
F
:
FnMut
(
&
OsStr
)
-
>
Result
<
O
E
>
+
Send
+
'
help
E
:
Into
<
Box
<
dyn
Error
+
Send
+
Sync
+
'
static
>
>
{
self
.
validator_os
=
Some
(
Arc
:
:
new
(
Mutex
:
:
new
(
move
|
s
:
&
OsStr
|
{
f
(
s
)
.
map
(
|
_
|
(
)
)
.
map_err
(
|
e
|
e
.
into
(
)
)
}
)
)
)
;
self
}
#
[
cfg
(
feature
=
"
regex
"
)
]
#
[
must_use
]
pub
fn
validator_regex
(
self
regex
:
impl
Into
<
RegexRef
<
'
help
>
>
err_message
:
&
'
help
str
)
-
>
Self
{
let
regex
=
regex
.
into
(
)
;
self
.
validator
(
move
|
s
:
&
str
|
{
if
regex
.
is_match
(
s
)
{
Ok
(
(
)
)
}
else
{
Err
(
err_message
)
}
}
)
}
#
[
must_use
]
pub
fn
possible_value
<
T
>
(
mut
self
value
:
T
)
-
>
Self
where
T
:
Into
<
PossibleValue
<
'
help
>
>
{
self
.
possible_vals
.
push
(
value
.
into
(
)
)
;
self
.
takes_value
(
true
)
}
#
[
must_use
]
pub
fn
possible_values
<
I
T
>
(
mut
self
values
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
PossibleValue
<
'
help
>
>
{
self
.
possible_vals
.
extend
(
values
.
into_iter
(
)
.
map
(
|
value
|
value
.
into
(
)
)
)
;
self
.
takes_value
(
true
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
ignore_case
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
IgnoreCase
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
IgnoreCase
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
allow_hyphen_values
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
AllowHyphenValues
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
AllowHyphenValues
)
}
}
#
[
cfg_attr
(
not
(
unix
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
unix
doc
=
"
rust
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
allow_invalid_utf8
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
AllowInvalidUtf8
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
AllowInvalidUtf8
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
forbid_empty_values
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
ForbidEmptyValues
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
ForbidEmptyValues
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
require_equals
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
RequireEquals
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
RequireEquals
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
use_delimiter
(
mut
self
yes
:
bool
)
-
>
Self
{
if
yes
{
if
self
.
val_delim
.
is_none
(
)
{
self
.
val_delim
=
Some
(
'
'
)
;
}
self
.
takes_value
(
true
)
.
setting
(
ArgSettings
:
:
UseValueDelimiter
)
}
else
{
self
.
val_delim
=
None
;
self
.
unset_setting
(
ArgSettings
:
:
UseValueDelimiter
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
value_delimiter
(
mut
self
d
:
char
)
-
>
Self
{
self
.
val_delim
=
Some
(
d
)
;
self
.
takes_value
(
true
)
.
use_delimiter
(
true
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
require_delimiter
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
RequireDelimiter
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
RequireDelimiter
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
value_terminator
(
mut
self
term
:
&
'
help
str
)
-
>
Self
{
self
.
terminator
=
Some
(
term
)
;
self
.
takes_value
(
true
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
raw
(
self
yes
:
bool
)
-
>
Self
{
self
.
takes_value
(
yes
)
.
multiple_values
(
yes
)
.
allow_hyphen_values
(
yes
)
.
last
(
yes
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_value
(
self
val
:
&
'
help
str
)
-
>
Self
{
self
.
default_values_os
(
&
[
OsStr
:
:
new
(
val
)
]
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_value_os
(
self
val
:
&
'
help
OsStr
)
-
>
Self
{
self
.
default_values_os
(
&
[
val
]
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_values
(
self
vals
:
&
[
&
'
help
str
]
)
-
>
Self
{
let
vals_vec
:
Vec
<
_
>
=
vals
.
iter
(
)
.
map
(
|
val
|
OsStr
:
:
new
(
*
val
)
)
.
collect
(
)
;
self
.
default_values_os
(
&
vals_vec
[
.
.
]
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_values_os
(
mut
self
vals
:
&
[
&
'
help
OsStr
]
)
-
>
Self
{
self
.
default_vals
=
vals
.
to_vec
(
)
;
self
.
takes_value
(
true
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_missing_value
(
self
val
:
&
'
help
str
)
-
>
Self
{
self
.
default_missing_values_os
(
&
[
OsStr
:
:
new
(
val
)
]
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_missing_value_os
(
self
val
:
&
'
help
OsStr
)
-
>
Self
{
self
.
default_missing_values_os
(
&
[
val
]
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_missing_values
(
self
vals
:
&
[
&
'
help
str
]
)
-
>
Self
{
let
vals_vec
:
Vec
<
_
>
=
vals
.
iter
(
)
.
map
(
|
val
|
OsStr
:
:
new
(
*
val
)
)
.
collect
(
)
;
self
.
default_missing_values_os
(
&
vals_vec
[
.
.
]
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_missing_values_os
(
mut
self
vals
:
&
[
&
'
help
OsStr
]
)
-
>
Self
{
self
.
default_missing_vals
=
vals
.
to_vec
(
)
;
self
.
takes_value
(
true
)
}
#
[
cfg
(
feature
=
"
env
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
env
(
self
name
:
&
'
help
str
)
-
>
Self
{
self
.
env_os
(
OsStr
:
:
new
(
name
)
)
}
#
[
cfg
(
feature
=
"
env
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
env_os
(
mut
self
name
:
&
'
help
OsStr
)
-
>
Self
{
self
.
env
=
Some
(
(
name
env
:
:
var_os
(
name
)
)
)
;
self
}
}
impl
<
'
help
>
Arg
<
'
help
>
{
#
[
inline
]
#
[
must_use
]
pub
fn
help
(
mut
self
h
:
impl
Into
<
Option
<
&
'
help
str
>
>
)
-
>
Self
{
self
.
help
=
h
.
into
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
long_help
(
mut
self
h
:
impl
Into
<
Option
<
&
'
help
str
>
>
)
-
>
Self
{
self
.
long_help
=
h
.
into
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
display_order
(
mut
self
ord
:
usize
)
-
>
Self
{
self
.
disp_ord
=
Some
(
ord
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
help_heading
<
O
>
(
mut
self
heading
:
O
)
-
>
Self
where
O
:
Into
<
Option
<
&
'
help
str
>
>
{
self
.
help_heading
=
Some
(
heading
.
into
(
)
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
next_line_help
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
NextLineHelp
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
NextLineHelp
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
Hidden
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
Hidden
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide_possible_values
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HidePossibleValues
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HidePossibleValues
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide_default_value
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HideDefaultValue
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HideDefaultValue
)
}
}
#
[
cfg
(
feature
=
"
env
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
hide_env
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HideEnv
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HideEnv
)
}
}
#
[
cfg
(
feature
=
"
env
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
hide_env_values
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HideEnvValues
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HideEnvValues
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide_short_help
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HiddenShortHelp
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HiddenShortHelp
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide_long_help
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HiddenLongHelp
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HiddenLongHelp
)
}
}
}
impl
<
'
help
>
Arg
<
'
help
>
{
#
[
must_use
]
pub
fn
group
<
T
:
Key
>
(
mut
self
group_id
:
T
)
-
>
Self
{
self
.
groups
.
push
(
group_id
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
groups
<
T
:
Key
>
(
mut
self
group_ids
:
&
[
T
]
)
-
>
Self
{
self
.
groups
.
extend
(
group_ids
.
iter
(
)
.
map
(
Id
:
:
from
)
)
;
self
}
#
[
must_use
]
pub
fn
default_value_if
<
T
:
Key
>
(
self
arg_id
:
T
val
:
Option
<
&
'
help
str
>
default
:
Option
<
&
'
help
str
>
)
-
>
Self
{
self
.
default_value_if_os
(
arg_id
val
.
map
(
OsStr
:
:
new
)
default
.
map
(
OsStr
:
:
new
)
)
}
#
[
must_use
]
pub
fn
default_value_if_os
<
T
:
Key
>
(
mut
self
arg_id
:
T
val
:
Option
<
&
'
help
OsStr
>
default
:
Option
<
&
'
help
OsStr
>
)
-
>
Self
{
self
.
default_vals_ifs
.
push
(
(
arg_id
.
into
(
)
val
default
)
)
;
self
.
takes_value
(
true
)
}
#
[
must_use
]
pub
fn
default_value_ifs
<
T
:
Key
>
(
mut
self
ifs
:
&
[
(
T
Option
<
&
'
help
str
>
Option
<
&
'
help
str
>
)
]
)
-
>
Self
{
for
(
arg
val
default
)
in
ifs
{
self
=
self
.
default_value_if_os
(
arg
val
.
map
(
OsStr
:
:
new
)
default
.
map
(
OsStr
:
:
new
)
)
;
}
self
}
#
[
must_use
]
pub
fn
default_value_ifs_os
<
T
:
Key
>
(
mut
self
ifs
:
&
[
(
T
Option
<
&
'
help
OsStr
>
Option
<
&
'
help
OsStr
>
)
]
)
-
>
Self
{
for
(
arg
val
default
)
in
ifs
{
self
=
self
.
default_value_if_os
(
arg
.
key
(
)
*
val
*
default
)
;
}
self
}
#
[
must_use
]
pub
fn
required_unless_present
<
T
:
Key
>
(
mut
self
arg_id
:
T
)
-
>
Self
{
self
.
r_unless
.
push
(
arg_id
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
required_unless_present_all
<
T
I
>
(
mut
self
names
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Key
{
self
.
r_unless_all
.
extend
(
names
.
into_iter
(
)
.
map
(
Id
:
:
from
)
)
;
self
}
#
[
must_use
]
pub
fn
required_unless_present_any
<
T
I
>
(
mut
self
names
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Key
{
self
.
r_unless
.
extend
(
names
.
into_iter
(
)
.
map
(
Id
:
:
from
)
)
;
self
}
#
[
must_use
]
pub
fn
required_if_eq
<
T
:
Key
>
(
mut
self
arg_id
:
T
val
:
&
'
help
str
)
-
>
Self
{
self
.
r_ifs
.
push
(
(
arg_id
.
into
(
)
val
)
)
;
self
}
#
[
must_use
]
pub
fn
required_if_eq_any
<
T
:
Key
>
(
mut
self
ifs
:
&
[
(
T
&
'
help
str
)
]
)
-
>
Self
{
self
.
r_ifs
.
extend
(
ifs
.
iter
(
)
.
map
(
|
(
id
val
)
|
(
Id
:
:
from_ref
(
id
)
*
val
)
)
)
;
self
}
#
[
must_use
]
pub
fn
required_if_eq_all
<
T
:
Key
>
(
mut
self
ifs
:
&
[
(
T
&
'
help
str
)
]
)
-
>
Self
{
self
.
r_ifs_all
.
extend
(
ifs
.
iter
(
)
.
map
(
|
(
id
val
)
|
(
Id
:
:
from_ref
(
id
)
*
val
)
)
)
;
self
}
#
[
must_use
]
pub
fn
requires_if
<
T
:
Key
>
(
mut
self
val
:
&
'
help
str
arg_id
:
T
)
-
>
Self
{
self
.
requires
.
push
(
(
Some
(
val
)
arg_id
.
into
(
)
)
)
;
self
}
#
[
must_use
]
pub
fn
requires_ifs
<
T
:
Key
>
(
mut
self
ifs
:
&
[
(
&
'
help
str
T
)
]
)
-
>
Self
{
self
.
requires
.
extend
(
ifs
.
iter
(
)
.
map
(
|
(
val
arg
)
|
(
Some
(
*
val
)
Id
:
:
from
(
arg
)
)
)
)
;
self
}
#
[
must_use
]
pub
fn
requires_all
<
T
:
Key
>
(
mut
self
names
:
&
[
T
]
)
-
>
Self
{
self
.
requires
.
extend
(
names
.
iter
(
)
.
map
(
|
s
|
(
None
s
.
into
(
)
)
)
)
;
self
}
#
[
must_use
]
pub
fn
conflicts_with
<
T
:
Key
>
(
mut
self
arg_id
:
T
)
-
>
Self
{
self
.
blacklist
.
push
(
arg_id
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
conflicts_with_all
(
mut
self
names
:
&
[
&
str
]
)
-
>
Self
{
self
.
blacklist
.
extend
(
names
.
iter
(
)
.
map
(
Id
:
:
from
)
)
;
self
}
#
[
must_use
]
pub
fn
overrides_with
<
T
:
Key
>
(
mut
self
arg_id
:
T
)
-
>
Self
{
self
.
overrides
.
push
(
arg_id
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
overrides_with_all
<
T
:
Key
>
(
mut
self
names
:
&
[
T
]
)
-
>
Self
{
self
.
overrides
.
extend
(
names
.
iter
(
)
.
map
(
Id
:
:
from
)
)
;
self
}
}
impl
<
'
help
>
Arg
<
'
help
>
{
#
[
inline
]
pub
fn
get_name
(
&
self
)
-
>
&
'
help
str
{
self
.
name
}
#
[
inline
]
pub
fn
get_help
(
&
self
)
-
>
Option
<
&
'
help
str
>
{
self
.
help
}
#
[
inline
]
pub
fn
get_long_help
(
&
self
)
-
>
Option
<
&
'
help
str
>
{
self
.
long_help
}
#
[
inline
]
pub
fn
get_help_heading
(
&
self
)
-
>
Option
<
&
'
help
str
>
{
self
.
help_heading
.
unwrap_or_default
(
)
}
#
[
inline
]
pub
fn
get_short
(
&
self
)
-
>
Option
<
char
>
{
self
.
short
}
#
[
inline
]
pub
fn
get_visible_short_aliases
(
&
self
)
-
>
Option
<
Vec
<
char
>
>
{
if
self
.
short_aliases
.
is_empty
(
)
{
None
}
else
{
Some
(
self
.
short_aliases
.
iter
(
)
.
filter_map
(
|
(
c
v
)
|
if
*
v
{
Some
(
c
)
}
else
{
None
}
)
.
copied
(
)
.
collect
(
)
)
}
}
#
[
inline
]
pub
fn
get_short_and_visible_aliases
(
&
self
)
-
>
Option
<
Vec
<
char
>
>
{
let
mut
shorts
=
match
self
.
short
{
Some
(
short
)
=
>
vec
!
[
short
]
None
=
>
return
None
}
;
if
let
Some
(
aliases
)
=
self
.
get_visible_short_aliases
(
)
{
shorts
.
extend
(
aliases
)
;
}
Some
(
shorts
)
}
#
[
inline
]
pub
fn
get_long
(
&
self
)
-
>
Option
<
&
'
help
str
>
{
self
.
long
}
#
[
inline
]
pub
fn
get_visible_aliases
(
&
self
)
-
>
Option
<
Vec
<
&
'
help
str
>
>
{
if
self
.
aliases
.
is_empty
(
)
{
None
}
else
{
Some
(
self
.
aliases
.
iter
(
)
.
filter_map
(
|
(
s
v
)
|
if
*
v
{
Some
(
s
)
}
else
{
None
}
)
.
copied
(
)
.
collect
(
)
)
}
}
#
[
inline
]
pub
fn
get_long_and_visible_aliases
(
&
self
)
-
>
Option
<
Vec
<
&
'
help
str
>
>
{
let
mut
longs
=
match
self
.
long
{
Some
(
long
)
=
>
vec
!
[
long
]
None
=
>
return
None
}
;
if
let
Some
(
aliases
)
=
self
.
get_visible_aliases
(
)
{
longs
.
extend
(
aliases
)
;
}
Some
(
longs
)
}
#
[
inline
]
pub
fn
get_possible_values
(
&
self
)
-
>
Option
<
&
[
PossibleValue
]
>
{
if
self
.
possible_vals
.
is_empty
(
)
{
None
}
else
{
Some
(
&
self
.
possible_vals
)
}
}
#
[
inline
]
pub
fn
get_value_names
(
&
self
)
-
>
Option
<
&
[
&
'
help
str
]
>
{
if
self
.
val_names
.
is_empty
(
)
{
None
}
else
{
Some
(
&
self
.
val_names
)
}
}
#
[
inline
]
pub
fn
get_num_vals
(
&
self
)
-
>
Option
<
usize
>
{
self
.
num_vals
}
#
[
inline
]
pub
fn
get_index
(
&
self
)
-
>
Option
<
usize
>
{
self
.
index
}
pub
fn
get_value_hint
(
&
self
)
-
>
ValueHint
{
self
.
value_hint
}
pub
fn
get_global
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
Global
)
}
#
[
cfg
(
feature
=
"
env
"
)
]
pub
fn
get_env
(
&
self
)
-
>
Option
<
&
OsStr
>
{
self
.
env
.
as_ref
(
)
.
map
(
|
x
|
x
.
0
)
}
pub
fn
get_default_values
(
&
self
)
-
>
&
[
&
OsStr
]
{
&
self
.
default_vals
}
pub
fn
is_positional
(
&
self
)
-
>
bool
{
self
.
long
.
is_none
(
)
&
&
self
.
short
.
is_none
(
)
}
}
impl
<
'
help
>
Arg
<
'
help
>
{
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
new
"
)
]
pub
fn
with_name
<
S
:
Into
<
&
'
help
str
>
>
(
n
:
S
)
-
>
Self
{
Self
:
:
new
(
n
)
}
#
[
cfg
(
feature
=
"
yaml
"
)
]
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Deprecated
in
Issue
#
3087
maybe
clap
:
:
Parser
would
fit
your
use
case
?
"
)
]
pub
fn
from_yaml
(
y
:
&
'
help
Yaml
)
-
>
Self
{
#
!
[
allow
(
deprecated
)
]
let
yaml_file_hash
=
y
.
as_hash
(
)
.
expect
(
"
YAML
file
must
be
a
hash
"
)
;
let
(
name_yaml
yaml
)
=
yaml_file_hash
.
iter
(
)
.
next
(
)
.
expect
(
"
There
must
be
one
arg
in
the
YAML
file
"
)
;
let
name_str
=
name_yaml
.
as_str
(
)
.
expect
(
"
Arg
name
must
be
a
string
"
)
;
let
mut
a
=
Arg
:
:
new
(
name_str
)
;
for
(
k
v
)
in
yaml
.
as_hash
(
)
.
expect
(
"
Arg
must
be
a
hash
"
)
{
a
=
match
k
.
as_str
(
)
.
expect
(
"
Arg
fields
must
be
strings
"
)
{
"
short
"
=
>
yaml_to_char
!
(
a
v
short
)
"
long
"
=
>
yaml_to_str
!
(
a
v
long
)
"
aliases
"
=
>
yaml_vec_or_str
!
(
a
v
alias
)
"
help
"
=
>
yaml_to_str
!
(
a
v
help
)
"
long_help
"
=
>
yaml_to_str
!
(
a
v
long_help
)
"
required
"
=
>
yaml_to_bool
!
(
a
v
required
)
"
required_if
"
=
>
yaml_tuple2
!
(
a
v
required_if_eq
)
"
required_ifs
"
=
>
yaml_tuple2
!
(
a
v
required_if_eq
)
"
takes_value
"
=
>
yaml_to_bool
!
(
a
v
takes_value
)
"
index
"
=
>
yaml_to_usize
!
(
a
v
index
)
"
global
"
=
>
yaml_to_bool
!
(
a
v
global
)
"
multiple
"
=
>
yaml_to_bool
!
(
a
v
multiple
)
"
hidden
"
=
>
yaml_to_bool
!
(
a
v
hide
)
"
next_line_help
"
=
>
yaml_to_bool
!
(
a
v
next_line_help
)
"
group
"
=
>
yaml_to_str
!
(
a
v
group
)
"
number_of_values
"
=
>
yaml_to_usize
!
(
a
v
number_of_values
)
"
max_values
"
=
>
yaml_to_usize
!
(
a
v
max_values
)
"
min_values
"
=
>
yaml_to_usize
!
(
a
v
min_values
)
"
value_name
"
=
>
yaml_to_str
!
(
a
v
value_name
)
"
use_delimiter
"
=
>
yaml_to_bool
!
(
a
v
use_delimiter
)
"
allow_hyphen_values
"
=
>
yaml_to_bool
!
(
a
v
allow_hyphen_values
)
"
last
"
=
>
yaml_to_bool
!
(
a
v
last
)
"
require_delimiter
"
=
>
yaml_to_bool
!
(
a
v
require_delimiter
)
"
value_delimiter
"
=
>
yaml_to_char
!
(
a
v
value_delimiter
)
"
required_unless
"
=
>
yaml_to_str
!
(
a
v
required_unless_present
)
"
display_order
"
=
>
yaml_to_usize
!
(
a
v
display_order
)
"
default_value
"
=
>
yaml_to_str
!
(
a
v
default_value
)
"
default_value_if
"
=
>
yaml_tuple3
!
(
a
v
default_value_if
)
"
default_value_ifs
"
=
>
yaml_tuple3
!
(
a
v
default_value_if
)
#
[
cfg
(
feature
=
"
env
"
)
]
"
env
"
=
>
yaml_to_str
!
(
a
v
env
)
"
value_names
"
=
>
yaml_vec_or_str
!
(
a
v
value_name
)
"
groups
"
=
>
yaml_vec_or_str
!
(
a
v
group
)
"
requires
"
=
>
yaml_vec_or_str
!
(
a
v
requires
)
"
requires_if
"
=
>
yaml_tuple2
!
(
a
v
requires_if
)
"
requires_ifs
"
=
>
yaml_tuple2
!
(
a
v
requires_if
)
"
conflicts_with
"
=
>
yaml_vec_or_str
!
(
a
v
conflicts_with
)
"
overrides_with
"
=
>
yaml_to_str
!
(
a
v
overrides_with
)
"
possible_values
"
=
>
yaml_vec_or_str
!
(
a
v
possible_value
)
"
case_insensitive
"
=
>
yaml_to_bool
!
(
a
v
ignore_case
)
"
required_unless_one
"
=
>
yaml_vec
!
(
a
v
required_unless_present_any
)
"
required_unless_all
"
=
>
yaml_vec
!
(
a
v
required_unless_present_all
)
s
=
>
{
panic
!
(
"
Unknown
setting
'
{
}
'
in
YAML
file
for
arg
'
{
}
'
"
s
name_str
)
}
}
}
a
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Deprecated
in
Issue
#
3086
see
clap
:
:
arg
!
"
)
]
pub
fn
from_usage
(
u
:
&
'
help
str
)
-
>
Self
{
UsageParser
:
:
from_usage
(
u
)
.
parse
(
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
required_unless_present
"
)
]
#
[
must_use
]
pub
fn
required_unless
<
T
:
Key
>
(
self
arg_id
:
T
)
-
>
Self
{
self
.
required_unless_present
(
arg_id
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
required_unless_present_all
"
)
]
#
[
must_use
]
pub
fn
required_unless_all
<
T
I
>
(
self
names
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Key
{
self
.
required_unless_present_all
(
names
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
required_unless_present_any
"
)
]
#
[
must_use
]
pub
fn
required_unless_one
<
T
I
>
(
self
names
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Key
{
self
.
required_unless_present_any
(
names
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
required_if_eq
"
)
]
#
[
must_use
]
pub
fn
required_if
<
T
:
Key
>
(
self
arg_id
:
T
val
:
&
'
help
str
)
-
>
Self
{
self
.
required_if_eq
(
arg_id
val
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
required_if_eq_any
"
)
]
#
[
must_use
]
pub
fn
required_ifs
<
T
:
Key
>
(
self
ifs
:
&
[
(
T
&
'
help
str
)
]
)
-
>
Self
{
self
.
required_if_eq_any
(
ifs
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
hide
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
hidden
(
self
yes
:
bool
)
-
>
Self
{
self
.
hide
(
yes
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
ignore_case
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
case_insensitive
(
self
yes
:
bool
)
-
>
Self
{
self
.
ignore_case
(
yes
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
forbid_empty_values
"
)
]
#
[
must_use
]
pub
fn
empty_values
(
self
yes
:
bool
)
-
>
Self
{
self
.
forbid_empty_values
(
!
yes
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Split
into
Arg
:
:
multiple_occurrences
(
most
likely
what
you
want
)
and
Arg
:
:
multiple_values
"
)
]
#
[
must_use
]
pub
fn
multiple
(
self
yes
:
bool
)
-
>
Self
{
self
.
multiple_occurrences
(
yes
)
.
multiple_values
(
yes
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
hide_short_help
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
hidden_short_help
(
self
yes
:
bool
)
-
>
Self
{
self
.
hide_short_help
(
yes
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
hide_long_help
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
hidden_long_help
(
self
yes
:
bool
)
-
>
Self
{
self
.
hide_long_help
(
yes
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
setting
"
)
]
#
[
must_use
]
pub
fn
set
(
self
s
:
ArgSettings
)
-
>
Self
{
self
.
setting
(
s
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
unset_setting
"
)
]
#
[
must_use
]
pub
fn
unset
(
self
s
:
ArgSettings
)
-
>
Self
{
self
.
unset_setting
(
s
)
}
}
impl
<
'
help
>
Arg
<
'
help
>
{
pub
(
crate
)
fn
_build
(
&
mut
self
)
{
if
self
.
is_positional
(
)
{
self
.
settings
.
set
(
ArgSettings
:
:
TakesValue
)
;
}
if
(
self
.
is_set
(
ArgSettings
:
:
UseValueDelimiter
)
|
|
self
.
is_set
(
ArgSettings
:
:
RequireDelimiter
)
)
&
&
self
.
val_delim
.
is_none
(
)
{
self
.
val_delim
=
Some
(
'
'
)
;
}
let
val_names_len
=
self
.
val_names
.
len
(
)
;
if
val_names_len
>
1
{
self
.
settings
.
set
(
ArgSettings
:
:
MultipleValues
)
;
if
self
.
num_vals
.
is_none
(
)
{
self
.
num_vals
=
Some
(
val_names_len
)
;
}
}
let
self_id
=
self
.
id
.
clone
(
)
;
if
self
.
is_positional
(
)
|
|
self
.
is_set
(
ArgSettings
:
:
MultipleOccurrences
)
{
self
.
overrides
.
retain
(
|
e
|
*
e
!
=
self_id
)
;
}
}
pub
(
crate
)
fn
generated
(
mut
self
)
-
>
Self
{
self
.
provider
=
ArgProvider
:
:
Generated
;
self
}
pub
(
crate
)
fn
longest_filter
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
TakesValue
)
|
|
self
.
long
.
is_some
(
)
|
|
self
.
short
.
is_none
(
)
}
pub
(
crate
)
fn
multiple_str
(
&
self
)
-
>
&
str
{
let
mult_vals
=
self
.
val_names
.
len
(
)
>
1
;
if
(
self
.
is_set
(
ArgSettings
:
:
MultipleValues
)
|
|
self
.
is_set
(
ArgSettings
:
:
MultipleOccurrences
)
)
&
&
!
mult_vals
{
"
.
.
.
"
}
else
{
"
"
}
}
pub
(
crate
)
fn
name_no_brackets
(
&
self
)
-
>
Cow
<
str
>
{
debug
!
(
"
Arg
:
:
name_no_brackets
:
{
}
"
self
.
name
)
;
let
mut
delim
=
String
:
:
new
(
)
;
delim
.
push
(
if
self
.
is_set
(
ArgSettings
:
:
RequireDelimiter
)
{
self
.
val_delim
.
expect
(
INTERNAL_ERROR_MSG
)
}
else
{
'
'
}
)
;
if
!
self
.
val_names
.
is_empty
(
)
{
debug
!
(
"
Arg
:
:
name_no_brackets
:
val_names
=
{
:
#
?
}
"
self
.
val_names
)
;
if
self
.
val_names
.
len
(
)
>
1
{
Cow
:
:
Owned
(
self
.
val_names
.
iter
(
)
.
map
(
|
n
|
format
!
(
"
<
{
}
>
"
n
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
join
(
&
*
delim
)
)
}
else
{
Cow
:
:
Borrowed
(
self
.
val_names
.
get
(
0
)
.
expect
(
INTERNAL_ERROR_MSG
)
)
}
}
else
{
debug
!
(
"
Arg
:
:
name_no_brackets
:
just
name
"
)
;
Cow
:
:
Borrowed
(
self
.
name
)
}
}
pub
(
crate
)
fn
is_multiple
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
MultipleValues
)
|
self
.
is_set
(
ArgSettings
:
:
MultipleOccurrences
)
}
pub
(
crate
)
fn
get_display_order
(
&
self
)
-
>
usize
{
self
.
disp_ord
.
unwrap_or
(
999
)
}
}
impl
<
'
help
>
From
<
&
'
_
Arg
<
'
help
>
>
for
Arg
<
'
help
>
{
fn
from
(
a
:
&
Arg
<
'
help
>
)
-
>
Self
{
a
.
clone
(
)
}
}
impl
<
'
help
>
PartialEq
for
Arg
<
'
help
>
{
fn
eq
(
&
self
other
:
&
Arg
<
'
help
>
)
-
>
bool
{
self
.
name
=
=
other
.
name
}
}
impl
<
'
help
>
PartialOrd
for
Arg
<
'
help
>
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
<
'
help
>
Ord
for
Arg
<
'
help
>
{
fn
cmp
(
&
self
other
:
&
Arg
)
-
>
Ordering
{
self
.
name
.
cmp
(
other
.
name
)
}
}
impl
<
'
help
>
Eq
for
Arg
<
'
help
>
{
}
impl
<
'
help
>
Display
for
Arg
<
'
help
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
if
let
Some
(
l
)
=
self
.
long
{
write
!
(
f
"
-
-
{
}
"
l
)
?
;
}
else
if
let
Some
(
s
)
=
self
.
short
{
write
!
(
f
"
-
{
}
"
s
)
?
;
}
if
!
self
.
is_positional
(
)
&
&
self
.
is_set
(
ArgSettings
:
:
TakesValue
)
{
let
sep
=
if
self
.
is_set
(
ArgSettings
:
:
RequireEquals
)
{
"
=
"
}
else
{
"
"
}
;
write
!
(
f
"
{
}
"
sep
)
?
;
}
if
self
.
is_set
(
ArgSettings
:
:
TakesValue
)
|
|
self
.
is_positional
(
)
{
display_arg_val
(
self
|
s
_
|
write
!
(
f
"
{
}
"
s
)
)
?
;
}
Ok
(
(
)
)
}
}
impl
<
'
help
>
fmt
:
:
Debug
for
Arg
<
'
help
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
let
mut
ds
=
f
.
debug_struct
(
"
Arg
"
)
;
#
[
allow
(
unused_mut
)
]
let
mut
ds
=
ds
.
field
(
"
id
"
&
self
.
id
)
.
field
(
"
provider
"
&
self
.
provider
)
.
field
(
"
name
"
&
self
.
name
)
.
field
(
"
help
"
&
self
.
help
)
.
field
(
"
long_help
"
&
self
.
long_help
)
.
field
(
"
blacklist
"
&
self
.
blacklist
)
.
field
(
"
settings
"
&
self
.
settings
)
.
field
(
"
overrides
"
&
self
.
overrides
)
.
field
(
"
groups
"
&
self
.
groups
)
.
field
(
"
requires
"
&
self
.
requires
)
.
field
(
"
r_ifs
"
&
self
.
r_ifs
)
.
field
(
"
r_unless
"
&
self
.
r_unless
)
.
field
(
"
short
"
&
self
.
short
)
.
field
(
"
long
"
&
self
.
long
)
.
field
(
"
aliases
"
&
self
.
aliases
)
.
field
(
"
short_aliases
"
&
self
.
short_aliases
)
.
field
(
"
disp_ord
"
&
self
.
disp_ord
)
.
field
(
"
possible_vals
"
&
self
.
possible_vals
)
.
field
(
"
val_names
"
&
self
.
val_names
)
.
field
(
"
num_vals
"
&
self
.
num_vals
)
.
field
(
"
max_vals
"
&
self
.
max_vals
)
.
field
(
"
min_vals
"
&
self
.
min_vals
)
.
field
(
"
validator
"
&
self
.
validator
.
as_ref
(
)
.
map_or
(
"
None
"
|
_
|
"
Some
(
FnMut
)
"
)
)
.
field
(
"
validator_os
"
&
self
.
validator_os
.
as_ref
(
)
.
map_or
(
"
None
"
|
_
|
"
Some
(
FnMut
)
"
)
)
.
field
(
"
val_delim
"
&
self
.
val_delim
)
.
field
(
"
default_vals
"
&
self
.
default_vals
)
.
field
(
"
default_vals_ifs
"
&
self
.
default_vals_ifs
)
.
field
(
"
terminator
"
&
self
.
terminator
)
.
field
(
"
index
"
&
self
.
index
)
.
field
(
"
help_heading
"
&
self
.
help_heading
)
.
field
(
"
value_hint
"
&
self
.
value_hint
)
.
field
(
"
default_missing_vals
"
&
self
.
default_missing_vals
)
;
#
[
cfg
(
feature
=
"
env
"
)
]
{
ds
=
ds
.
field
(
"
env
"
&
self
.
env
)
;
}
ds
.
finish
(
)
}
}
type
Validator
<
'
a
>
=
dyn
FnMut
(
&
str
)
-
>
Result
<
(
)
Box
<
dyn
Error
+
Send
+
Sync
>
>
+
Send
+
'
a
;
type
ValidatorOs
<
'
a
>
=
dyn
FnMut
(
&
OsStr
)
-
>
Result
<
(
)
Box
<
dyn
Error
+
Send
+
Sync
>
>
+
Send
+
'
a
;
#
[
derive
(
Debug
Clone
Eq
PartialEq
)
]
pub
(
crate
)
enum
ArgProvider
{
Generated
GeneratedMutated
User
}
impl
Default
for
ArgProvider
{
fn
default
(
)
-
>
Self
{
ArgProvider
:
:
User
}
}
pub
(
crate
)
fn
display_arg_val
<
F
T
E
>
(
arg
:
&
Arg
mut
write
:
F
)
-
>
Result
<
(
)
E
>
where
F
:
FnMut
(
&
str
bool
)
-
>
Result
<
T
E
>
{
let
mult_val
=
arg
.
is_set
(
ArgSettings
:
:
MultipleValues
)
;
let
mult_occ
=
arg
.
is_set
(
ArgSettings
:
:
MultipleOccurrences
)
;
let
delim
=
if
arg
.
is_set
(
ArgSettings
:
:
RequireDelimiter
)
{
arg
.
val_delim
.
expect
(
INTERNAL_ERROR_MSG
)
}
else
{
'
'
}
;
if
!
arg
.
val_names
.
is_empty
(
)
{
match
(
arg
.
val_names
.
len
(
)
arg
.
num_vals
)
{
(
1
Some
(
num_vals
)
)
=
>
{
let
arg_name
=
format
!
(
"
<
{
}
>
"
arg
.
val_names
.
get
(
0
)
.
unwrap
(
)
)
;
let
mut
it
=
iter
:
:
repeat
(
arg_name
)
.
take
(
num_vals
)
.
peekable
(
)
;
while
let
Some
(
arg_name
)
=
it
.
next
(
)
{
write
(
&
arg_name
true
)
?
;
if
it
.
peek
(
)
.
is_some
(
)
{
write
(
&
delim
.
to_string
(
)
false
)
?
;
}
}
}
(
num_val_names
_
)
=
>
{
let
mut
it
=
arg
.
val_names
.
iter
(
)
.
peekable
(
)
;
while
let
Some
(
val
)
=
it
.
next
(
)
{
write
(
&
format
!
(
"
<
{
}
>
"
val
)
true
)
?
;
if
it
.
peek
(
)
.
is_some
(
)
{
write
(
&
delim
.
to_string
(
)
false
)
?
;
}
}
if
(
num_val_names
=
=
1
&
&
mult_val
)
|
|
(
arg
.
is_positional
(
)
&
&
mult_occ
)
{
write
(
"
.
.
.
"
true
)
?
;
}
}
}
}
else
if
let
Some
(
num_vals
)
=
arg
.
num_vals
{
let
arg_name
=
format
!
(
"
<
{
}
>
"
arg
.
name
)
;
let
mut
it
=
iter
:
:
repeat
(
&
arg_name
)
.
take
(
num_vals
)
.
peekable
(
)
;
while
let
Some
(
arg_name
)
=
it
.
next
(
)
{
write
(
arg_name
true
)
?
;
if
it
.
peek
(
)
.
is_some
(
)
{
write
(
&
delim
.
to_string
(
)
false
)
?
;
}
}
}
else
if
arg
.
is_positional
(
)
{
write
(
&
format
!
(
"
<
{
}
>
"
arg
.
name
)
true
)
?
;
if
mult_val
|
|
mult_occ
{
write
(
"
.
.
.
"
true
)
?
;
}
}
else
{
write
(
&
format
!
(
"
<
{
}
>
"
arg
.
name
)
true
)
?
;
if
mult_val
{
write
(
"
.
.
.
"
true
)
?
;
}
}
Ok
(
(
)
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
Arg
;
#
[
test
]
fn
flag_display
(
)
{
let
mut
f
=
Arg
:
:
new
(
"
flg
"
)
.
multiple_occurrences
(
true
)
;
f
.
long
=
Some
(
"
flag
"
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
f
)
"
-
-
flag
"
)
;
let
mut
f2
=
Arg
:
:
new
(
"
flg
"
)
;
f2
.
short
=
Some
(
'
f
'
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
f2
)
"
-
f
"
)
;
}
#
[
test
]
fn
flag_display_single_alias
(
)
{
let
mut
f
=
Arg
:
:
new
(
"
flg
"
)
;
f
.
long
=
Some
(
"
flag
"
)
;
f
.
aliases
=
vec
!
[
(
"
als
"
true
)
]
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
f
)
"
-
-
flag
"
)
}
#
[
test
]
fn
flag_display_multiple_aliases
(
)
{
let
mut
f
=
Arg
:
:
new
(
"
flg
"
)
;
f
.
short
=
Some
(
'
f
'
)
;
f
.
aliases
=
vec
!
[
(
"
alias_not_visible
"
false
)
(
"
f2
"
true
)
(
"
f3
"
true
)
(
"
f4
"
true
)
]
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
f
)
"
-
f
"
)
;
}
#
[
test
]
fn
flag_display_single_short_alias
(
)
{
let
mut
f
=
Arg
:
:
new
(
"
flg
"
)
;
f
.
short
=
Some
(
'
a
'
)
;
f
.
short_aliases
=
vec
!
[
(
'
b
'
true
)
]
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
f
)
"
-
a
"
)
}
#
[
test
]
fn
flag_display_multiple_short_aliases
(
)
{
let
mut
f
=
Arg
:
:
new
(
"
flg
"
)
;
f
.
short
=
Some
(
'
a
'
)
;
f
.
short_aliases
=
vec
!
[
(
'
b
'
false
)
(
'
c
'
true
)
(
'
d
'
true
)
(
'
e
'
true
)
]
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
f
)
"
-
a
"
)
;
}
#
[
test
]
fn
option_display_multiple_occurrences
(
)
{
let
o
=
Arg
:
:
new
(
"
opt
"
)
.
long
(
"
option
"
)
.
takes_value
(
true
)
.
multiple_occurrences
(
true
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
o
)
"
-
-
option
<
opt
>
"
)
;
}
#
[
test
]
fn
option_display_multiple_values
(
)
{
let
o
=
Arg
:
:
new
(
"
opt
"
)
.
long
(
"
option
"
)
.
takes_value
(
true
)
.
multiple_values
(
true
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
o
)
"
-
-
option
<
opt
>
.
.
.
"
)
;
}
#
[
test
]
fn
option_display2
(
)
{
let
o2
=
Arg
:
:
new
(
"
opt
"
)
.
short
(
'
o
'
)
.
value_names
(
&
[
"
file
"
"
name
"
]
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
o2
)
"
-
o
<
file
>
<
name
>
"
)
;
}
#
[
test
]
fn
option_display3
(
)
{
let
o2
=
Arg
:
:
new
(
"
opt
"
)
.
short
(
'
o
'
)
.
takes_value
(
true
)
.
multiple_values
(
true
)
.
value_names
(
&
[
"
file
"
"
name
"
]
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
o2
)
"
-
o
<
file
>
<
name
>
"
)
;
}
#
[
test
]
fn
option_display_single_alias
(
)
{
let
o
=
Arg
:
:
new
(
"
opt
"
)
.
takes_value
(
true
)
.
long
(
"
option
"
)
.
visible_alias
(
"
als
"
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
o
)
"
-
-
option
<
opt
>
"
)
;
}
#
[
test
]
fn
option_display_multiple_aliases
(
)
{
let
o
=
Arg
:
:
new
(
"
opt
"
)
.
long
(
"
option
"
)
.
takes_value
(
true
)
.
visible_aliases
(
&
[
"
als2
"
"
als3
"
"
als4
"
]
)
.
alias
(
"
als_not_visible
"
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
o
)
"
-
-
option
<
opt
>
"
)
;
}
#
[
test
]
fn
option_display_single_short_alias
(
)
{
let
o
=
Arg
:
:
new
(
"
opt
"
)
.
takes_value
(
true
)
.
short
(
'
a
'
)
.
visible_short_alias
(
'
b
'
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
o
)
"
-
a
<
opt
>
"
)
;
}
#
[
test
]
fn
option_display_multiple_short_aliases
(
)
{
let
o
=
Arg
:
:
new
(
"
opt
"
)
.
short
(
'
a
'
)
.
takes_value
(
true
)
.
visible_short_aliases
(
&
[
'
b
'
'
c
'
'
d
'
]
)
.
short_alias
(
'
e
'
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
o
)
"
-
a
<
opt
>
"
)
;
}
#
[
test
]
fn
positional_display_multiple_values
(
)
{
let
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
takes_value
(
true
)
.
multiple_values
(
true
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
p
)
"
<
pos
>
.
.
.
"
)
;
}
#
[
test
]
fn
positional_display_multiple_occurrences
(
)
{
let
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
takes_value
(
true
)
.
multiple_occurrences
(
true
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
p
)
"
<
pos
>
.
.
.
"
)
;
}
#
[
test
]
fn
positional_display_required
(
)
{
let
p2
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
required
(
true
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
p2
)
"
<
pos
>
"
)
;
}
#
[
test
]
fn
positional_display_val_names
(
)
{
let
p2
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
value_names
(
&
[
"
file1
"
"
file2
"
]
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
p2
)
"
<
file1
>
<
file2
>
"
)
;
}
#
[
test
]
fn
positional_display_val_names_req
(
)
{
let
p2
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
required
(
true
)
.
value_names
(
&
[
"
file1
"
"
file2
"
]
)
;
assert_eq
!
(
&
*
format
!
(
"
{
}
"
p2
)
"
<
file1
>
<
file2
>
"
)
;
}
}
