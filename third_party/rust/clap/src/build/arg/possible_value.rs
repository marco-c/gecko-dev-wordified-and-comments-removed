use
std
:
:
iter
;
use
crate
:
:
util
:
:
eq_ignore_case
;
#
[
derive
(
Debug
Default
Clone
PartialEq
Eq
)
]
pub
struct
PossibleValue
<
'
help
>
{
pub
(
crate
)
name
:
&
'
help
str
pub
(
crate
)
help
:
Option
<
&
'
help
str
>
pub
(
crate
)
aliases
:
Vec
<
&
'
help
str
>
pub
(
crate
)
hide
:
bool
}
impl
<
'
help
>
PossibleValue
<
'
help
>
{
pub
fn
new
(
name
:
&
'
help
str
)
-
>
Self
{
PossibleValue
{
name
.
.
Default
:
:
default
(
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
help
(
mut
self
help
:
&
'
help
str
)
-
>
Self
{
self
.
help
=
Some
(
help
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide
(
mut
self
yes
:
bool
)
-
>
Self
{
self
.
hide
=
yes
;
self
}
#
[
must_use
]
pub
fn
alias
(
mut
self
name
:
&
'
help
str
)
-
>
Self
{
self
.
aliases
.
push
(
name
)
;
self
}
#
[
must_use
]
pub
fn
aliases
<
I
>
(
mut
self
names
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
&
'
help
str
>
{
self
.
aliases
.
extend
(
names
.
into_iter
(
)
)
;
self
}
}
impl
<
'
help
>
PossibleValue
<
'
help
>
{
#
[
inline
]
pub
fn
get_name
(
&
self
)
-
>
&
'
help
str
{
self
.
name
}
#
[
inline
]
pub
fn
get_help
(
&
self
)
-
>
Option
<
&
'
help
str
>
{
self
.
help
}
#
[
inline
]
pub
fn
is_hidden
(
&
self
)
-
>
bool
{
self
.
hide
}
pub
fn
get_visible_name
(
&
self
)
-
>
Option
<
&
'
help
str
>
{
if
self
.
hide
{
None
}
else
{
Some
(
self
.
name
)
}
}
pub
fn
get_name_and_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
'
help
str
>
+
'
_
{
iter
:
:
once
(
&
self
.
name
)
.
chain
(
&
self
.
aliases
)
.
copied
(
)
}
pub
fn
matches
(
&
self
value
:
&
str
ignore_case
:
bool
)
-
>
bool
{
if
ignore_case
{
self
.
get_name_and_aliases
(
)
.
any
(
|
name
|
eq_ignore_case
(
name
value
)
)
}
else
{
self
.
get_name_and_aliases
(
)
.
any
(
|
name
|
name
=
=
value
)
}
}
}
impl
<
'
help
>
From
<
&
'
help
str
>
for
PossibleValue
<
'
help
>
{
fn
from
(
s
:
&
'
help
str
)
-
>
Self
{
Self
:
:
new
(
s
)
}
}
impl
<
'
help
>
From
<
&
'
help
&
'
help
str
>
for
PossibleValue
<
'
help
>
{
fn
from
(
s
:
&
'
help
&
'
help
str
)
-
>
Self
{
Self
:
:
new
(
s
)
}
}
