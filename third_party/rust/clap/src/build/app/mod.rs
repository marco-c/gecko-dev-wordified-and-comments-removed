#
[
cfg
(
debug_assertions
)
]
mod
debug_asserts
;
mod
settings
;
#
[
cfg
(
test
)
]
mod
tests
;
pub
use
self
:
:
settings
:
:
{
AppFlags
AppSettings
}
;
use
std
:
:
{
collections
:
:
HashMap
env
ffi
:
:
OsString
fmt
io
:
:
{
self
Write
}
ops
:
:
Index
path
:
:
Path
}
;
use
os_str_bytes
:
:
RawOsStr
;
#
[
cfg
(
feature
=
"
yaml
"
)
]
use
yaml_rust
:
:
Yaml
;
use
crate
:
:
{
build
:
:
{
arg
:
:
ArgProvider
Arg
ArgGroup
ArgSettings
}
mkeymap
:
:
MKeyMap
output
:
:
{
fmt
:
:
Colorizer
Help
HelpWriter
Usage
}
parse
:
:
{
ArgMatcher
ArgMatches
Input
Parser
}
util
:
:
{
color
:
:
ColorChoice
Id
Key
}
Error
ErrorKind
Result
as
ClapResult
INTERNAL_ERROR_MSG
}
;
#
[
derive
(
Default
Debug
Clone
PartialEq
Eq
)
]
pub
struct
App
<
'
help
>
{
pub
(
crate
)
id
:
Id
pub
(
crate
)
name
:
String
pub
(
crate
)
long_flag
:
Option
<
&
'
help
str
>
pub
(
crate
)
short_flag
:
Option
<
char
>
pub
(
crate
)
bin_name
:
Option
<
String
>
pub
(
crate
)
author
:
Option
<
&
'
help
str
>
pub
(
crate
)
version
:
Option
<
&
'
help
str
>
pub
(
crate
)
long_version
:
Option
<
&
'
help
str
>
pub
(
crate
)
about
:
Option
<
&
'
help
str
>
pub
(
crate
)
long_about
:
Option
<
&
'
help
str
>
pub
(
crate
)
before_help
:
Option
<
&
'
help
str
>
pub
(
crate
)
before_long_help
:
Option
<
&
'
help
str
>
pub
(
crate
)
after_help
:
Option
<
&
'
help
str
>
pub
(
crate
)
after_long_help
:
Option
<
&
'
help
str
>
pub
(
crate
)
aliases
:
Vec
<
(
&
'
help
str
bool
)
>
pub
(
crate
)
short_flag_aliases
:
Vec
<
(
char
bool
)
>
pub
(
crate
)
long_flag_aliases
:
Vec
<
(
&
'
help
str
bool
)
>
pub
(
crate
)
usage_str
:
Option
<
&
'
help
str
>
pub
(
crate
)
usage
:
Option
<
String
>
pub
(
crate
)
help_str
:
Option
<
&
'
help
str
>
pub
(
crate
)
disp_ord
:
Option
<
usize
>
pub
(
crate
)
term_w
:
Option
<
usize
>
pub
(
crate
)
max_w
:
Option
<
usize
>
pub
(
crate
)
template
:
Option
<
&
'
help
str
>
pub
(
crate
)
settings
:
AppFlags
pub
(
crate
)
g_settings
:
AppFlags
pub
(
crate
)
args
:
MKeyMap
<
'
help
>
pub
(
crate
)
subcommands
:
Vec
<
App
<
'
help
>
>
pub
(
crate
)
replacers
:
HashMap
<
&
'
help
str
&
'
help
[
&
'
help
str
]
>
pub
(
crate
)
groups
:
Vec
<
ArgGroup
<
'
help
>
>
pub
(
crate
)
current_help_heading
:
Option
<
&
'
help
str
>
pub
(
crate
)
subcommand_value_name
:
Option
<
&
'
help
str
>
pub
(
crate
)
subcommand_heading
:
Option
<
&
'
help
str
>
}
impl
<
'
help
>
App
<
'
help
>
{
pub
fn
new
<
S
:
Into
<
String
>
>
(
name
:
S
)
-
>
Self
{
let
name
=
name
.
into
(
)
;
App
{
id
:
Id
:
:
from
(
&
*
name
)
name
.
.
Default
:
:
default
(
)
}
.
arg
(
Arg
:
:
new
(
"
help
"
)
.
long
(
"
help
"
)
.
help
(
"
Print
help
information
"
)
.
global
(
true
)
.
generated
(
)
)
.
arg
(
Arg
:
:
new
(
"
version
"
)
.
long
(
"
version
"
)
.
help
(
"
Print
version
information
"
)
.
global
(
true
)
.
generated
(
)
)
}
#
[
must_use
]
pub
fn
arg
<
A
:
Into
<
Arg
<
'
help
>
>
>
(
mut
self
a
:
A
)
-
>
Self
{
let
mut
arg
=
a
.
into
(
)
;
arg
.
help_heading
.
get_or_insert
(
self
.
current_help_heading
)
;
self
.
args
.
push
(
arg
)
;
self
}
#
[
must_use
]
pub
fn
args
<
I
T
>
(
mut
self
args
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
Arg
<
'
help
>
>
{
let
args
=
args
.
into_iter
(
)
;
let
(
lower
_
)
=
args
.
size_hint
(
)
;
self
.
args
.
reserve
(
lower
)
;
for
arg
in
args
{
self
=
self
.
arg
(
arg
)
;
}
self
}
#
[
must_use
]
pub
fn
mut_arg
<
T
F
>
(
mut
self
arg_id
:
T
f
:
F
)
-
>
Self
where
F
:
FnOnce
(
Arg
<
'
help
>
)
-
>
Arg
<
'
help
>
T
:
Key
+
Into
<
&
'
help
str
>
{
let
arg_id
:
&
str
=
arg_id
.
into
(
)
;
let
id
=
Id
:
:
from
(
arg_id
)
;
let
mut
a
=
self
.
args
.
remove_by_name
(
&
id
)
.
unwrap_or_else
(
|
|
Arg
{
id
name
:
arg_id
.
.
Arg
:
:
default
(
)
}
)
;
if
a
.
provider
=
=
ArgProvider
:
:
Generated
{
a
.
provider
=
ArgProvider
:
:
GeneratedMutated
;
}
self
.
args
.
push
(
f
(
a
)
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
group
<
G
:
Into
<
ArgGroup
<
'
help
>
>
>
(
mut
self
group
:
G
)
-
>
Self
{
self
.
groups
.
push
(
group
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
groups
<
I
T
>
(
mut
self
groups
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
ArgGroup
<
'
help
>
>
{
for
g
in
groups
.
into_iter
(
)
{
self
=
self
.
group
(
g
.
into
(
)
)
;
}
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
subcommand
<
S
:
Into
<
App
<
'
help
>
>
>
(
mut
self
subcmd
:
S
)
-
>
Self
{
self
.
subcommands
.
push
(
subcmd
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
subcommands
<
I
T
>
(
mut
self
subcmds
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
App
<
'
help
>
>
{
for
subcmd
in
subcmds
.
into_iter
(
)
{
self
.
subcommands
.
push
(
subcmd
.
into
(
)
)
;
}
self
}
pub
fn
debug_assert
(
mut
self
)
{
self
.
_build_all
(
)
;
}
pub
fn
error
(
&
mut
self
kind
:
ErrorKind
message
:
impl
std
:
:
fmt
:
:
Display
)
-
>
Error
{
Error
:
:
raw
(
kind
message
)
.
format
(
self
)
}
#
[
inline
]
pub
fn
get_matches
(
self
)
-
>
ArgMatches
{
self
.
get_matches_from
(
&
mut
env
:
:
args_os
(
)
)
}
pub
fn
get_matches_mut
(
&
mut
self
)
-
>
ArgMatches
{
self
.
try_get_matches_from_mut
(
&
mut
env
:
:
args_os
(
)
)
.
unwrap_or_else
(
|
e
|
e
.
exit
(
)
)
}
#
[
inline
]
pub
fn
try_get_matches
(
self
)
-
>
ClapResult
<
ArgMatches
>
{
self
.
try_get_matches_from
(
&
mut
env
:
:
args_os
(
)
)
}
pub
fn
get_matches_from
<
I
T
>
(
mut
self
itr
:
I
)
-
>
ArgMatches
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
self
.
try_get_matches_from_mut
(
itr
)
.
unwrap_or_else
(
|
e
|
{
drop
(
self
)
;
e
.
exit
(
)
}
)
}
pub
fn
try_get_matches_from
<
I
T
>
(
mut
self
itr
:
I
)
-
>
ClapResult
<
ArgMatches
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
self
.
try_get_matches_from_mut
(
itr
)
}
pub
fn
try_get_matches_from_mut
<
I
T
>
(
&
mut
self
itr
:
I
)
-
>
ClapResult
<
ArgMatches
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
let
mut
it
=
Input
:
:
from
(
itr
.
into_iter
(
)
)
;
#
[
cfg
(
feature
=
"
unstable
-
multicall
"
)
]
if
self
.
settings
.
is_set
(
AppSettings
:
:
Multicall
)
{
if
let
Some
(
(
argv0
_
)
)
=
it
.
next
(
)
{
let
argv0
=
Path
:
:
new
(
&
argv0
)
;
if
let
Some
(
command
)
=
argv0
.
file_stem
(
)
.
and_then
(
|
f
|
f
.
to_str
(
)
)
{
let
command
=
command
.
to_owned
(
)
;
debug
!
(
"
App
:
:
try_get_matches_from_mut
:
Parsed
command
{
}
from
argv
"
command
)
;
debug
!
(
"
App
:
:
try_get_matches_from_mut
:
Reinserting
command
into
arguments
so
subcommand
parser
matches
it
"
)
;
it
.
insert
(
&
[
&
command
]
)
;
debug
!
(
"
App
:
:
try_get_matches_from_mut
:
Clearing
name
and
bin_name
so
that
displayed
command
name
starts
with
applet
name
"
)
;
self
.
name
.
clear
(
)
;
self
.
bin_name
=
None
;
return
self
.
_do_parse
(
&
mut
it
)
;
}
}
}
;
if
!
self
.
settings
.
is_set
(
AppSettings
:
:
NoBinaryName
)
{
if
let
Some
(
(
name
_
)
)
=
it
.
next
(
)
{
let
p
=
Path
:
:
new
(
name
)
;
if
let
Some
(
f
)
=
p
.
file_name
(
)
{
if
let
Some
(
s
)
=
f
.
to_str
(
)
{
if
self
.
bin_name
.
is_none
(
)
{
self
.
bin_name
=
Some
(
s
.
to_owned
(
)
)
;
}
}
}
}
}
self
.
_do_parse
(
&
mut
it
)
}
pub
fn
print_help
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
_build
(
)
;
let
color
=
self
.
get_color
(
)
;
let
p
=
Parser
:
:
new
(
self
)
;
let
mut
c
=
Colorizer
:
:
new
(
false
color
)
;
Help
:
:
new
(
HelpWriter
:
:
Buffer
(
&
mut
c
)
&
p
false
)
.
write_help
(
)
?
;
c
.
print
(
)
}
pub
fn
print_long_help
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
_build
(
)
;
let
color
=
self
.
get_color
(
)
;
let
p
=
Parser
:
:
new
(
self
)
;
let
mut
c
=
Colorizer
:
:
new
(
false
color
)
;
Help
:
:
new
(
HelpWriter
:
:
Buffer
(
&
mut
c
)
&
p
true
)
.
write_help
(
)
?
;
c
.
print
(
)
}
pub
fn
write_help
<
W
:
Write
>
(
&
mut
self
w
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
_build
(
)
;
let
p
=
Parser
:
:
new
(
self
)
;
Help
:
:
new
(
HelpWriter
:
:
Normal
(
w
)
&
p
false
)
.
write_help
(
)
?
;
w
.
flush
(
)
}
pub
fn
write_long_help
<
W
:
Write
>
(
&
mut
self
w
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
_build
(
)
;
let
p
=
Parser
:
:
new
(
self
)
;
Help
:
:
new
(
HelpWriter
:
:
Normal
(
w
)
&
p
true
)
.
write_help
(
)
?
;
w
.
flush
(
)
}
pub
fn
render_version
(
&
self
)
-
>
String
{
self
.
_render_version
(
false
)
}
pub
fn
render_long_version
(
&
self
)
-
>
String
{
self
.
_render_version
(
true
)
}
pub
fn
render_usage
(
&
mut
self
)
-
>
String
{
self
.
_build
(
)
;
let
mut
parser
=
Parser
:
:
new
(
self
)
;
parser
.
_build
(
)
;
Usage
:
:
new
(
&
parser
)
.
create_usage_with_title
(
&
[
]
)
}
}
impl
<
'
help
>
App
<
'
help
>
{
#
[
must_use
]
pub
fn
name
<
S
:
Into
<
String
>
>
(
mut
self
name
:
S
)
-
>
Self
{
self
.
name
=
name
.
into
(
)
;
self
}
#
[
must_use
]
pub
fn
bin_name
<
S
:
Into
<
String
>
>
(
mut
self
name
:
S
)
-
>
Self
{
self
.
bin_name
=
Some
(
name
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
author
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
author
:
S
)
-
>
Self
{
self
.
author
=
Some
(
author
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
about
<
O
:
Into
<
Option
<
&
'
help
str
>
>
>
(
mut
self
about
:
O
)
-
>
Self
{
self
.
about
=
about
.
into
(
)
;
self
}
#
[
must_use
]
pub
fn
long_about
<
O
:
Into
<
Option
<
&
'
help
str
>
>
>
(
mut
self
long_about
:
O
)
-
>
Self
{
self
.
long_about
=
long_about
.
into
(
)
;
self
}
#
[
must_use
]
pub
fn
after_help
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
help
:
S
)
-
>
Self
{
self
.
after_help
=
Some
(
help
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
after_long_help
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
help
:
S
)
-
>
Self
{
self
.
after_long_help
=
Some
(
help
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
before_help
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
help
:
S
)
-
>
Self
{
self
.
before_help
=
Some
(
help
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
before_long_help
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
help
:
S
)
-
>
Self
{
self
.
before_long_help
=
Some
(
help
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
version
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
ver
:
S
)
-
>
Self
{
self
.
version
=
Some
(
ver
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
long_version
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
ver
:
S
)
-
>
Self
{
self
.
long_version
=
Some
(
ver
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
override_usage
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
usage
:
S
)
-
>
Self
{
self
.
usage_str
=
Some
(
usage
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
override_help
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
help
:
S
)
-
>
Self
{
self
.
help_str
=
Some
(
help
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
help_template
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
s
:
S
)
-
>
Self
{
self
.
template
=
Some
(
s
.
into
(
)
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
setting
<
F
>
(
mut
self
setting
:
F
)
-
>
Self
where
F
:
Into
<
AppFlags
>
{
self
.
settings
.
insert
(
setting
.
into
(
)
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
unset_setting
<
F
>
(
mut
self
setting
:
F
)
-
>
Self
where
F
:
Into
<
AppFlags
>
{
self
.
settings
.
remove
(
setting
.
into
(
)
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
global_setting
(
mut
self
setting
:
AppSettings
)
-
>
Self
{
self
.
settings
.
set
(
setting
)
;
self
.
g_settings
.
set
(
setting
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
unset_global_setting
(
mut
self
setting
:
AppSettings
)
-
>
Self
{
self
.
settings
.
unset
(
setting
)
;
self
.
g_settings
.
unset
(
setting
)
;
self
}
#
[
cfg
(
feature
=
"
color
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
color
(
self
color
:
ColorChoice
)
-
>
Self
{
#
[
allow
(
deprecated
)
]
match
color
{
ColorChoice
:
:
Auto
=
>
self
.
global_setting
(
AppSettings
:
:
ColorAuto
)
ColorChoice
:
:
Always
=
>
self
.
global_setting
(
AppSettings
:
:
ColorAlways
)
ColorChoice
:
:
Never
=
>
self
.
global_setting
(
AppSettings
:
:
ColorNever
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
help_heading
<
O
>
(
mut
self
heading
:
O
)
-
>
Self
where
O
:
Into
<
Option
<
&
'
help
str
>
>
{
self
.
current_help_heading
=
heading
.
into
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
term_width
(
mut
self
width
:
usize
)
-
>
Self
{
self
.
term_w
=
Some
(
width
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
max_term_width
(
mut
self
w
:
usize
)
-
>
Self
{
self
.
max_w
=
Some
(
w
)
;
self
}
#
[
inline
]
#
[
cfg
(
feature
=
"
unstable
-
replace
"
)
]
#
[
must_use
]
pub
fn
replace
(
mut
self
name
:
&
'
help
str
target
:
&
'
help
[
&
'
help
str
]
)
-
>
Self
{
self
.
replacers
.
insert
(
name
target
)
;
self
}
}
impl
<
'
help
>
App
<
'
help
>
{
#
[
must_use
]
pub
fn
short_flag
(
mut
self
short
:
char
)
-
>
Self
{
self
.
short_flag
=
Some
(
short
)
;
self
}
#
[
must_use
]
pub
fn
long_flag
(
mut
self
long
:
&
'
help
str
)
-
>
Self
{
self
.
long_flag
=
Some
(
long
.
trim_start_matches
(
|
c
|
c
=
=
'
-
'
)
)
;
self
}
#
[
must_use
]
pub
fn
alias
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
name
:
S
)
-
>
Self
{
self
.
aliases
.
push
(
(
name
.
into
(
)
false
)
)
;
self
}
#
[
must_use
]
pub
fn
short_flag_alias
(
mut
self
name
:
char
)
-
>
Self
{
assert
!
(
name
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_flag_aliases
.
push
(
(
name
false
)
)
;
self
}
#
[
must_use
]
pub
fn
long_flag_alias
(
mut
self
name
:
&
'
help
str
)
-
>
Self
{
self
.
long_flag_aliases
.
push
(
(
name
false
)
)
;
self
}
#
[
must_use
]
pub
fn
aliases
(
mut
self
names
:
&
[
&
'
help
str
]
)
-
>
Self
{
self
.
aliases
.
extend
(
names
.
iter
(
)
.
map
(
|
n
|
(
*
n
false
)
)
)
;
self
}
#
[
must_use
]
pub
fn
short_flag_aliases
(
mut
self
names
:
&
[
char
]
)
-
>
Self
{
for
s
in
names
{
assert
!
(
s
!
=
&
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_flag_aliases
.
push
(
(
*
s
false
)
)
;
}
self
}
#
[
must_use
]
pub
fn
long_flag_aliases
(
mut
self
names
:
&
[
&
'
help
str
]
)
-
>
Self
{
for
s
in
names
{
self
.
long_flag_aliases
.
push
(
(
s
false
)
)
;
}
self
}
#
[
must_use
]
pub
fn
visible_alias
<
S
:
Into
<
&
'
help
str
>
>
(
mut
self
name
:
S
)
-
>
Self
{
self
.
aliases
.
push
(
(
name
.
into
(
)
true
)
)
;
self
}
#
[
must_use
]
pub
fn
visible_short_flag_alias
(
mut
self
name
:
char
)
-
>
Self
{
assert
!
(
name
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_flag_aliases
.
push
(
(
name
true
)
)
;
self
}
#
[
must_use
]
pub
fn
visible_long_flag_alias
(
mut
self
name
:
&
'
help
str
)
-
>
Self
{
self
.
long_flag_aliases
.
push
(
(
name
true
)
)
;
self
}
#
[
must_use
]
pub
fn
visible_aliases
(
mut
self
names
:
&
[
&
'
help
str
]
)
-
>
Self
{
self
.
aliases
.
extend
(
names
.
iter
(
)
.
map
(
|
n
|
(
*
n
true
)
)
)
;
self
}
#
[
must_use
]
pub
fn
visible_short_flag_aliases
(
mut
self
names
:
&
[
char
]
)
-
>
Self
{
for
s
in
names
{
assert
!
(
s
!
=
&
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_flag_aliases
.
push
(
(
*
s
true
)
)
;
}
self
}
#
[
must_use
]
pub
fn
visible_long_flag_aliases
(
mut
self
names
:
&
[
&
'
help
str
]
)
-
>
Self
{
for
s
in
names
{
self
.
long_flag_aliases
.
push
(
(
s
true
)
)
;
}
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
display_order
(
mut
self
ord
:
usize
)
-
>
Self
{
self
.
disp_ord
=
Some
(
ord
)
;
self
}
#
[
must_use
]
pub
fn
subcommand_value_name
<
S
>
(
mut
self
value_name
:
S
)
-
>
Self
where
S
:
Into
<
&
'
help
str
>
{
self
.
subcommand_value_name
=
Some
(
value_name
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
subcommand_help_heading
<
T
>
(
mut
self
heading
:
T
)
-
>
Self
where
T
:
Into
<
&
'
help
str
>
{
self
.
subcommand_heading
=
Some
(
heading
.
into
(
)
)
;
self
}
}
impl
<
'
help
>
App
<
'
help
>
{
#
[
inline
]
pub
fn
get_bin_name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
bin_name
.
as_deref
(
)
}
pub
fn
set_bin_name
<
S
:
Into
<
String
>
>
(
&
mut
self
name
:
S
)
{
self
.
bin_name
=
Some
(
name
.
into
(
)
)
;
}
#
[
inline
]
pub
fn
get_name
(
&
self
)
-
>
&
str
{
&
self
.
name
}
#
[
inline
]
pub
fn
get_short_flag
(
&
self
)
-
>
Option
<
char
>
{
self
.
short_flag
}
#
[
inline
]
pub
fn
get_long_flag
(
&
self
)
-
>
Option
<
&
'
help
str
>
{
self
.
long_flag
}
#
[
inline
]
pub
fn
get_about
(
&
self
)
-
>
Option
<
&
'
help
str
>
{
self
.
about
}
#
[
inline
]
pub
fn
get_long_about
(
&
self
)
-
>
Option
<
&
'
help
str
>
{
self
.
long_about
}
#
[
inline
]
pub
fn
get_help_heading
(
&
self
)
-
>
Option
<
&
'
help
str
>
{
self
.
current_help_heading
}
#
[
inline
]
pub
fn
get_visible_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
'
help
str
>
+
'
_
{
self
.
aliases
.
iter
(
)
.
filter
(
|
(
_
vis
)
|
*
vis
)
.
map
(
|
a
|
a
.
0
)
}
#
[
inline
]
pub
fn
get_visible_short_flag_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
char
>
+
'
_
{
self
.
short_flag_aliases
.
iter
(
)
.
filter
(
|
(
_
vis
)
|
*
vis
)
.
map
(
|
a
|
a
.
0
)
}
#
[
inline
]
pub
fn
get_visible_long_flag_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
'
help
str
>
+
'
_
{
self
.
long_flag_aliases
.
iter
(
)
.
filter
(
|
(
_
vis
)
|
*
vis
)
.
map
(
|
a
|
a
.
0
)
}
#
[
inline
]
pub
fn
get_all_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
str
>
+
'
_
{
self
.
aliases
.
iter
(
)
.
map
(
|
a
|
a
.
0
)
}
#
[
inline
]
pub
fn
get_all_short_flag_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
char
>
+
'
_
{
self
.
short_flag_aliases
.
iter
(
)
.
map
(
|
a
|
a
.
0
)
}
#
[
inline
]
pub
fn
get_all_long_flag_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
'
help
str
>
+
'
_
{
self
.
long_flag_aliases
.
iter
(
)
.
map
(
|
a
|
a
.
0
)
}
#
[
inline
]
pub
fn
is_set
(
&
self
s
:
AppSettings
)
-
>
bool
{
self
.
settings
.
is_set
(
s
)
|
|
self
.
g_settings
.
is_set
(
s
)
}
#
[
inline
]
pub
fn
get_color
(
&
self
)
-
>
ColorChoice
{
debug
!
(
"
App
:
:
color
:
Color
setting
.
.
.
"
)
;
if
cfg
!
(
feature
=
"
color
"
)
{
#
[
allow
(
deprecated
)
]
if
self
.
is_set
(
AppSettings
:
:
ColorNever
)
{
debug
!
(
"
Never
"
)
;
ColorChoice
:
:
Never
}
else
if
self
.
is_set
(
AppSettings
:
:
ColorAlways
)
{
debug
!
(
"
Always
"
)
;
ColorChoice
:
:
Always
}
else
{
debug
!
(
"
Auto
"
)
;
ColorChoice
:
:
Auto
}
}
else
{
ColorChoice
:
:
Never
}
}
#
[
inline
]
pub
fn
get_subcommands
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
App
<
'
help
>
>
{
self
.
subcommands
.
iter
(
)
}
#
[
inline
]
pub
fn
get_subcommands_mut
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
&
mut
App
<
'
help
>
>
{
self
.
subcommands
.
iter_mut
(
)
}
#
[
inline
]
pub
fn
has_subcommands
(
&
self
)
-
>
bool
{
!
self
.
subcommands
.
is_empty
(
)
}
#
[
inline
]
pub
fn
find_subcommand
<
T
>
(
&
self
name
:
&
T
)
-
>
Option
<
&
App
<
'
help
>
>
where
T
:
PartialEq
<
str
>
+
?
Sized
{
self
.
get_subcommands
(
)
.
find
(
|
s
|
s
.
aliases_to
(
name
)
)
}
#
[
inline
]
pub
fn
find_subcommand_mut
<
T
>
(
&
mut
self
name
:
&
T
)
-
>
Option
<
&
mut
App
<
'
help
>
>
where
T
:
PartialEq
<
str
>
+
?
Sized
{
self
.
get_subcommands_mut
(
)
.
find
(
|
s
|
s
.
aliases_to
(
name
)
)
}
#
[
inline
]
pub
fn
get_arguments
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Arg
<
'
help
>
>
{
self
.
args
.
args
(
)
}
#
[
inline
]
pub
fn
get_positionals
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Arg
<
'
help
>
>
{
self
.
get_arguments
(
)
.
filter
(
|
a
|
a
.
is_positional
(
)
)
}
pub
fn
get_opts
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Arg
<
'
help
>
>
{
self
.
get_arguments
(
)
.
filter
(
|
a
|
a
.
is_set
(
ArgSettings
:
:
TakesValue
)
&
&
!
a
.
is_positional
(
)
)
}
pub
fn
get_arg_conflicts_with
(
&
self
arg
:
&
Arg
)
-
>
Vec
<
&
Arg
<
'
help
>
>
{
if
arg
.
get_global
(
)
{
self
.
get_global_arg_conflicts_with
(
arg
)
}
else
{
arg
.
blacklist
.
iter
(
)
.
map
(
|
id
|
{
self
.
args
.
args
(
)
.
find
(
|
arg
|
arg
.
id
=
=
*
id
)
.
expect
(
"
App
:
:
get_arg_conflicts_with
:
\
The
passed
arg
conflicts
with
an
arg
unknown
to
the
app
"
)
}
)
.
collect
(
)
}
}
fn
get_global_arg_conflicts_with
(
&
self
arg
:
&
Arg
)
-
>
Vec
<
&
Arg
<
'
help
>
>
{
arg
.
blacklist
.
iter
(
)
.
map
(
|
id
|
{
self
.
args
.
args
(
)
.
chain
(
self
.
get_subcommands_containing
(
arg
)
.
iter
(
)
.
flat_map
(
|
x
|
x
.
args
.
args
(
)
)
)
.
find
(
|
arg
|
arg
.
id
=
=
*
id
)
.
expect
(
"
App
:
:
get_arg_conflicts_with
:
\
The
passed
arg
conflicts
with
an
arg
unknown
to
the
app
"
)
}
)
.
collect
(
)
}
fn
get_subcommands_containing
(
&
self
arg
:
&
Arg
)
-
>
Vec
<
&
App
<
'
help
>
>
{
let
mut
vec
=
std
:
:
vec
:
:
Vec
:
:
new
(
)
;
for
idx
in
0
.
.
self
.
subcommands
.
len
(
)
{
if
self
.
subcommands
[
idx
]
.
args
.
args
(
)
.
any
(
|
ar
|
ar
.
id
=
=
arg
.
id
)
{
vec
.
push
(
&
self
.
subcommands
[
idx
]
)
;
vec
.
append
(
&
mut
self
.
subcommands
[
idx
]
.
get_subcommands_containing
(
arg
)
)
;
}
}
vec
}
}
impl
<
'
help
>
App
<
'
help
>
{
#
[
cfg
(
feature
=
"
yaml
"
)
]
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Deprecated
in
Issue
#
3087
maybe
clap
:
:
Parser
would
fit
your
use
case
?
"
)
]
pub
fn
from_yaml
(
y
:
&
'
help
Yaml
)
-
>
Self
{
#
!
[
allow
(
deprecated
)
]
let
yaml_file_hash
=
y
.
as_hash
(
)
.
expect
(
"
YAML
file
must
be
a
hash
"
)
;
let
(
mut
a
yaml
err
)
=
if
let
Some
(
name
)
=
y
[
"
name
"
]
.
as_str
(
)
{
(
App
:
:
new
(
name
)
yaml_file_hash
"
app
"
.
into
(
)
)
}
else
{
let
(
name_yaml
value_yaml
)
=
yaml_file_hash
.
iter
(
)
.
next
(
)
.
expect
(
"
There
must
be
one
subcommand
in
the
YAML
file
"
)
;
let
name_str
=
name_yaml
.
as_str
(
)
.
expect
(
"
Subcommand
name
must
be
a
string
"
)
;
(
App
:
:
new
(
name_str
)
value_yaml
.
as_hash
(
)
.
expect
(
"
Subcommand
must
be
a
hash
"
)
format
!
(
"
subcommand
'
{
}
'
"
name_str
)
)
}
;
for
(
k
v
)
in
yaml
{
a
=
match
k
.
as_str
(
)
.
expect
(
"
App
fields
must
be
strings
"
)
{
"
version
"
=
>
yaml_to_str
!
(
a
v
version
)
"
long_version
"
=
>
yaml_to_str
!
(
a
v
long_version
)
"
author
"
=
>
yaml_to_str
!
(
a
v
author
)
"
bin_name
"
=
>
yaml_to_str
!
(
a
v
bin_name
)
"
about
"
=
>
yaml_to_str
!
(
a
v
about
)
"
long_about
"
=
>
yaml_to_str
!
(
a
v
long_about
)
"
before_help
"
=
>
yaml_to_str
!
(
a
v
before_help
)
"
after_help
"
=
>
yaml_to_str
!
(
a
v
after_help
)
"
template
"
=
>
yaml_to_str
!
(
a
v
help_template
)
"
usage
"
=
>
yaml_to_str
!
(
a
v
override_usage
)
"
help
"
=
>
yaml_to_str
!
(
a
v
override_help
)
"
help_message
"
=
>
yaml_to_str
!
(
a
v
help_message
)
"
version_message
"
=
>
yaml_to_str
!
(
a
v
version_message
)
"
alias
"
=
>
yaml_to_str
!
(
a
v
alias
)
"
aliases
"
=
>
yaml_vec_or_str
!
(
a
v
alias
)
"
visible_alias
"
=
>
yaml_to_str
!
(
a
v
visible_alias
)
"
visible_aliases
"
=
>
yaml_vec_or_str
!
(
a
v
visible_alias
)
"
display_order
"
=
>
yaml_to_usize
!
(
a
v
display_order
)
"
args
"
=
>
{
if
let
Some
(
vec
)
=
v
.
as_vec
(
)
{
for
arg_yaml
in
vec
{
a
=
a
.
arg
(
Arg
:
:
from_yaml
(
arg_yaml
)
)
;
}
}
else
{
panic
!
(
"
Failed
to
convert
YAML
value
{
:
?
}
to
a
vec
"
v
)
;
}
a
}
"
subcommands
"
=
>
{
if
let
Some
(
vec
)
=
v
.
as_vec
(
)
{
for
sc_yaml
in
vec
{
a
=
a
.
subcommand
(
App
:
:
from_yaml
(
sc_yaml
)
)
;
}
}
else
{
panic
!
(
"
Failed
to
convert
YAML
value
{
:
?
}
to
a
vec
"
v
)
;
}
a
}
"
groups
"
=
>
{
if
let
Some
(
vec
)
=
v
.
as_vec
(
)
{
for
ag_yaml
in
vec
{
a
=
a
.
group
(
ArgGroup
:
:
from
(
ag_yaml
)
)
;
}
}
else
{
panic
!
(
"
Failed
to
convert
YAML
value
{
:
?
}
to
a
vec
"
v
)
;
}
a
}
"
setting
"
|
"
settings
"
=
>
{
yaml_to_setting
!
(
a
v
setting
AppSettings
"
AppSetting
"
err
)
}
"
global_setting
"
|
"
global_settings
"
=
>
{
yaml_to_setting
!
(
a
v
global_setting
AppSettings
"
AppSetting
"
err
)
}
_
=
>
a
}
}
a
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
override_usage
"
)
]
#
[
must_use
]
pub
fn
usage
<
S
:
Into
<
&
'
help
str
>
>
(
self
usage
:
S
)
-
>
Self
{
self
.
override_usage
(
usage
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
override_help
"
)
]
#
[
must_use
]
pub
fn
help
<
S
:
Into
<
&
'
help
str
>
>
(
self
help
:
S
)
-
>
Self
{
self
.
override_help
(
help
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
mut_arg
"
)
]
#
[
must_use
]
pub
fn
help_short
(
self
c
:
char
)
-
>
Self
{
self
.
mut_arg
(
"
help
"
|
a
|
a
.
short
(
c
)
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
mut_arg
"
)
]
#
[
must_use
]
pub
fn
version_short
(
self
c
:
char
)
-
>
Self
{
self
.
mut_arg
(
"
version
"
|
a
|
a
.
short
(
c
)
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
mut_arg
"
)
]
#
[
must_use
]
pub
fn
help_message
(
self
s
:
impl
Into
<
&
'
help
str
>
)
-
>
Self
{
self
.
mut_arg
(
"
help
"
|
a
|
a
.
help
(
s
.
into
(
)
)
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
mut_arg
"
)
]
#
[
must_use
]
pub
fn
version_message
(
self
s
:
impl
Into
<
&
'
help
str
>
)
-
>
Self
{
self
.
mut_arg
(
"
version
"
|
a
|
a
.
help
(
s
.
into
(
)
)
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
help_template
"
)
]
#
[
must_use
]
pub
fn
template
<
S
:
Into
<
&
'
help
str
>
>
(
self
s
:
S
)
-
>
Self
{
self
.
help_template
(
s
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
setting
(
a
|
b
)
"
)
]
#
[
must_use
]
pub
fn
settings
(
mut
self
settings
:
&
[
AppSettings
]
)
-
>
Self
{
for
s
in
settings
{
self
.
settings
.
insert
(
(
*
s
)
.
into
(
)
)
;
}
self
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
unset_setting
(
a
|
b
)
"
)
]
#
[
must_use
]
pub
fn
unset_settings
(
mut
self
settings
:
&
[
AppSettings
]
)
-
>
Self
{
for
s
in
settings
{
self
.
settings
.
remove
(
(
*
s
)
.
into
(
)
)
;
}
self
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
global_setting
(
a
|
b
)
"
)
]
#
[
must_use
]
pub
fn
global_settings
(
mut
self
settings
:
&
[
AppSettings
]
)
-
>
Self
{
for
s
in
settings
{
self
.
settings
.
insert
(
(
*
s
)
.
into
(
)
)
;
self
.
g_settings
.
insert
(
(
*
s
)
.
into
(
)
)
;
}
self
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
term_width
"
)
]
#
[
must_use
]
pub
fn
set_term_width
(
self
width
:
usize
)
-
>
Self
{
self
.
term_width
(
width
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Deprecated
in
Issue
#
3086
see
clap
:
:
arg
!
"
)
]
#
[
must_use
]
pub
fn
arg_from_usage
(
self
usage
:
&
'
help
str
)
-
>
Self
{
#
!
[
allow
(
deprecated
)
]
self
.
arg
(
Arg
:
:
from_usage
(
usage
)
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Deprecated
in
Issue
#
3086
see
clap
:
:
arg
!
"
)
]
#
[
must_use
]
pub
fn
args_from_usage
(
mut
self
usage
:
&
'
help
str
)
-
>
Self
{
#
!
[
allow
(
deprecated
)
]
for
line
in
usage
.
lines
(
)
{
let
l
=
line
.
trim
(
)
;
if
l
.
is_empty
(
)
{
continue
;
}
self
=
self
.
arg
(
Arg
:
:
from_usage
(
l
)
)
;
}
self
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
render_version
"
)
]
pub
fn
write_version
<
W
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
ClapResult
<
(
)
>
{
write
!
(
w
"
{
}
"
self
.
render_version
(
)
)
.
map_err
(
From
:
:
from
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
render_long_version
"
)
]
pub
fn
write_long_version
<
W
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
ClapResult
<
(
)
>
{
write
!
(
w
"
{
}
"
self
.
render_long_version
(
)
)
.
map_err
(
From
:
:
from
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
try_get_matches
"
)
]
pub
fn
get_matches_safe
(
self
)
-
>
ClapResult
<
ArgMatches
>
{
self
.
try_get_matches
(
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
try_get_matches_from
"
)
]
pub
fn
get_matches_from_safe
<
I
T
>
(
self
itr
:
I
)
-
>
ClapResult
<
ArgMatches
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
self
.
try_get_matches_from
(
itr
)
}
#
[
deprecated
(
since
=
"
3
.
0
.
0
"
note
=
"
Replaced
with
App
:
:
try_get_matches_from_mut
"
)
]
pub
fn
get_matches_from_safe_borrow
<
I
T
>
(
&
mut
self
itr
:
I
)
-
>
ClapResult
<
ArgMatches
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
self
.
try_get_matches_from_mut
(
itr
)
}
}
impl
<
'
help
>
App
<
'
help
>
{
fn
get_used_global_args
(
&
self
matcher
:
&
ArgMatcher
)
-
>
Vec
<
Id
>
{
let
global_args
:
Vec
<
_
>
=
self
.
args
.
args
(
)
.
filter
(
|
a
|
a
.
get_global
(
)
)
.
map
(
|
ga
|
ga
.
id
.
clone
(
)
)
.
collect
(
)
;
if
let
Some
(
used_subcommand
)
=
matcher
.
0
.
subcommand
.
as_ref
(
)
{
if
let
Some
(
used_subcommand
)
=
self
.
subcommands
.
iter
(
)
.
find
(
|
subcommand
|
subcommand
.
id
=
=
used_subcommand
.
id
)
{
return
[
global_args
used_subcommand
.
get_used_global_args
(
matcher
)
]
.
concat
(
)
;
}
}
global_args
}
fn
_do_parse
(
&
mut
self
it
:
&
mut
Input
)
-
>
ClapResult
<
ArgMatches
>
{
debug
!
(
"
App
:
:
_do_parse
"
)
;
self
.
_build
(
)
;
let
mut
matcher
=
ArgMatcher
:
:
new
(
self
)
;
let
mut
parser
=
Parser
:
:
new
(
self
)
;
if
let
Err
(
error
)
=
parser
.
get_matches_with
(
&
mut
matcher
it
)
{
if
self
.
is_set
(
AppSettings
:
:
IgnoreErrors
)
{
debug
!
(
"
App
:
:
_do_parse
:
ignoring
error
:
{
}
"
error
)
;
}
else
{
return
Err
(
error
)
;
}
}
let
global_arg_vec
:
Vec
<
Id
>
=
self
.
get_used_global_args
(
&
matcher
)
;
matcher
.
propagate_globals
(
&
global_arg_vec
)
;
Ok
(
matcher
.
into_inner
(
)
)
}
#
[
doc
(
hidden
)
]
pub
fn
_build_all
(
&
mut
self
)
{
self
.
_build
(
)
;
for
subcmd
in
self
.
get_subcommands_mut
(
)
{
subcmd
.
_build
(
)
;
}
self
.
_build_bin_names
(
)
;
}
#
[
doc
(
hidden
)
]
pub
fn
_build
(
&
mut
self
)
{
debug
!
(
"
App
:
:
_build
"
)
;
if
!
self
.
settings
.
is_set
(
AppSettings
:
:
Built
)
{
self
.
settings
=
self
.
settings
|
self
.
g_settings
;
self
.
_propagate
(
)
;
self
.
_check_help_and_version
(
)
;
self
.
_propagate_global_args
(
)
;
self
.
_derive_display_order
(
)
;
let
mut
pos_counter
=
1
;
let
self_override
=
self
.
is_set
(
AppSettings
:
:
AllArgsOverrideSelf
)
;
for
a
in
self
.
args
.
args_mut
(
)
{
for
g
in
&
a
.
groups
{
if
let
Some
(
ag
)
=
self
.
groups
.
iter_mut
(
)
.
find
(
|
grp
|
grp
.
id
=
=
*
g
)
{
ag
.
args
.
push
(
a
.
id
.
clone
(
)
)
;
}
else
{
let
mut
ag
=
ArgGroup
:
:
with_id
(
g
.
clone
(
)
)
;
ag
.
args
.
push
(
a
.
id
.
clone
(
)
)
;
self
.
groups
.
push
(
ag
)
;
}
}
if
a
.
is_set
(
ArgSettings
:
:
Last
)
{
self
.
settings
.
set
(
AppSettings
:
:
DontCollapseArgsInUsage
)
;
}
if
self_override
{
let
self_id
=
a
.
id
.
clone
(
)
;
a
.
overrides
.
push
(
self_id
)
;
}
a
.
_build
(
)
;
if
a
.
is_positional
(
)
&
&
a
.
index
.
is_none
(
)
{
a
.
index
=
Some
(
pos_counter
)
;
pos_counter
+
=
1
;
}
}
self
.
args
.
_build
(
)
;
#
[
cfg
(
debug_assertions
)
]
self
:
:
debug_asserts
:
:
assert_app
(
self
)
;
self
.
settings
.
set
(
AppSettings
:
:
Built
)
;
}
else
{
debug
!
(
"
App
:
:
_build
:
already
built
"
)
;
}
}
fn
_panic_on_missing_help
(
&
self
help_required_globally
:
bool
)
{
if
self
.
is_set
(
AppSettings
:
:
HelpExpected
)
|
|
help_required_globally
{
let
args_missing_help
:
Vec
<
String
>
=
self
.
args
.
args
(
)
.
filter
(
|
arg
|
arg
.
help
.
is_none
(
)
&
&
arg
.
long_help
.
is_none
(
)
)
.
map
(
|
arg
|
String
:
:
from
(
arg
.
name
)
)
.
collect
(
)
;
assert
!
(
args_missing_help
.
is_empty
(
)
"
AppSettings
:
:
HelpExpected
is
enabled
for
the
App
{
}
but
at
least
one
of
its
arguments
does
not
have
either
help
or
long_help
set
.
List
of
such
arguments
:
{
}
"
self
.
name
args_missing_help
.
join
(
"
"
)
)
;
}
for
sub_app
in
&
self
.
subcommands
{
sub_app
.
_panic_on_missing_help
(
help_required_globally
)
;
}
}
#
[
cfg
(
debug_assertions
)
]
fn
two_args_of
<
F
>
(
&
self
condition
:
F
)
-
>
Option
<
(
&
Arg
<
'
help
>
&
Arg
<
'
help
>
)
>
where
F
:
Fn
(
&
Arg
)
-
>
bool
{
two_elements_of
(
self
.
args
.
args
(
)
.
filter
(
|
a
:
&
&
Arg
|
condition
(
a
)
)
)
}
#
[
allow
(
unused
)
]
fn
two_groups_of
<
F
>
(
&
self
condition
:
F
)
-
>
Option
<
(
&
ArgGroup
&
ArgGroup
)
>
where
F
:
Fn
(
&
ArgGroup
)
-
>
bool
{
two_elements_of
(
self
.
groups
.
iter
(
)
.
filter
(
|
a
|
condition
(
a
)
)
)
}
pub
(
crate
)
fn
_propagate_global_args
(
&
mut
self
)
{
debug
!
(
"
App
:
:
_propagate_global_args
:
{
}
"
self
.
name
)
;
for
sc
in
&
mut
self
.
subcommands
{
for
a
in
self
.
args
.
args
(
)
.
filter
(
|
a
|
a
.
get_global
(
)
)
{
let
mut
propagate
=
false
;
let
is_generated
=
matches
!
(
a
.
provider
ArgProvider
:
:
Generated
|
ArgProvider
:
:
GeneratedMutated
)
;
if
is_generated
{
let
generated_pos
=
sc
.
args
.
args
(
)
.
position
(
|
x
|
x
.
id
=
=
a
.
id
&
&
x
.
provider
=
=
ArgProvider
:
:
Generated
)
;
if
let
Some
(
index
)
=
generated_pos
{
sc
.
args
.
remove
(
index
)
;
propagate
=
true
;
}
}
if
propagate
|
|
sc
.
find
(
&
a
.
id
)
.
is_none
(
)
{
sc
.
args
.
push
(
a
.
clone
(
)
)
;
}
}
}
}
pub
(
crate
)
fn
_propagate
(
&
mut
self
)
{
debug
!
(
"
App
:
:
_propagate
:
{
}
"
self
.
name
)
;
let
mut
subcommands
=
std
:
:
mem
:
:
take
(
&
mut
self
.
subcommands
)
;
for
sc
in
&
mut
subcommands
{
self
.
_propagate_subcommand
(
sc
)
;
}
self
.
subcommands
=
subcommands
;
}
fn
_propagate_subcommand
(
&
self
sc
:
&
mut
Self
)
{
{
if
self
.
settings
.
is_set
(
AppSettings
:
:
PropagateVersion
)
{
if
sc
.
version
.
is_none
(
)
&
&
self
.
version
.
is_some
(
)
{
sc
.
version
=
Some
(
self
.
version
.
unwrap
(
)
)
;
}
if
sc
.
long_version
.
is_none
(
)
&
&
self
.
long_version
.
is_some
(
)
{
sc
.
long_version
=
Some
(
self
.
long_version
.
unwrap
(
)
)
;
}
}
sc
.
settings
=
sc
.
settings
|
self
.
g_settings
;
sc
.
g_settings
=
sc
.
g_settings
|
self
.
g_settings
;
sc
.
term_w
=
self
.
term_w
;
sc
.
max_w
=
self
.
max_w
;
}
}
#
[
allow
(
clippy
:
:
blocks_in_if_conditions
)
]
pub
(
crate
)
fn
_check_help_and_version
(
&
mut
self
)
{
debug
!
(
"
App
:
:
_check_help_and_version
"
)
;
if
self
.
is_set
(
AppSettings
:
:
DisableHelpFlag
)
|
|
self
.
args
.
args
(
)
.
any
(
|
x
|
{
x
.
provider
=
=
ArgProvider
:
:
User
&
&
(
x
.
long
=
=
Some
(
"
help
"
)
|
|
x
.
id
=
=
Id
:
:
help_hash
(
)
)
}
)
|
|
self
.
subcommands
.
iter
(
)
.
any
(
|
sc
|
sc
.
long_flag
=
=
Some
(
"
help
"
)
)
{
debug
!
(
"
App
:
:
_check_help_and_version
:
Removing
generated
help
"
)
;
let
generated_help_pos
=
self
.
args
.
args
(
)
.
position
(
|
x
|
x
.
id
=
=
Id
:
:
help_hash
(
)
&
&
x
.
provider
=
=
ArgProvider
:
:
Generated
)
;
if
let
Some
(
index
)
=
generated_help_pos
{
self
.
args
.
remove
(
index
)
;
}
}
else
{
let
other_arg_has_short
=
self
.
args
.
args
(
)
.
any
(
|
x
|
x
.
short
=
=
Some
(
'
h
'
)
)
;
let
help
=
self
.
args
.
args_mut
(
)
.
find
(
|
x
|
x
.
id
=
=
Id
:
:
help_hash
(
)
)
.
expect
(
INTERNAL_ERROR_MSG
)
;
if
!
(
help
.
short
.
is_some
(
)
|
|
other_arg_has_short
|
|
self
.
subcommands
.
iter
(
)
.
any
(
|
sc
|
sc
.
short_flag
=
=
Some
(
'
h
'
)
)
)
{
help
.
short
=
Some
(
'
h
'
)
;
}
}
if
self
.
settings
.
is_set
(
AppSettings
:
:
DisableVersionFlag
)
|
|
(
self
.
version
.
is_none
(
)
&
&
self
.
long_version
.
is_none
(
)
)
|
|
self
.
args
.
args
(
)
.
any
(
|
x
|
{
x
.
provider
=
=
ArgProvider
:
:
User
&
&
(
x
.
long
=
=
Some
(
"
version
"
)
|
|
x
.
id
=
=
Id
:
:
version_hash
(
)
)
}
)
|
|
self
.
subcommands
.
iter
(
)
.
any
(
|
sc
|
sc
.
long_flag
=
=
Some
(
"
version
"
)
)
{
debug
!
(
"
App
:
:
_check_help_and_version
:
Removing
generated
version
"
)
;
let
generated_version_pos
=
self
.
args
.
args
(
)
.
position
(
|
x
|
x
.
id
=
=
Id
:
:
version_hash
(
)
&
&
x
.
provider
=
=
ArgProvider
:
:
Generated
)
;
if
let
Some
(
index
)
=
generated_version_pos
{
self
.
args
.
remove
(
index
)
;
}
}
if
self
.
args
.
args
(
)
.
any
(
|
x
|
{
x
.
id
=
=
Id
:
:
version_hash
(
)
&
&
matches
!
(
x
.
provider
ArgProvider
:
:
Generated
|
ArgProvider
:
:
GeneratedMutated
)
}
)
{
let
other_arg_has_short
=
self
.
args
.
args
(
)
.
any
(
|
x
|
x
.
short
=
=
Some
(
'
V
'
)
)
;
let
version
=
self
.
args
.
args_mut
(
)
.
find
(
|
x
|
x
.
id
=
=
Id
:
:
version_hash
(
)
)
.
expect
(
INTERNAL_ERROR_MSG
)
;
if
!
(
version
.
short
.
is_some
(
)
|
|
other_arg_has_short
|
|
self
.
subcommands
.
iter
(
)
.
any
(
|
sc
|
sc
.
short_flag
=
=
Some
(
'
V
'
)
)
)
{
version
.
short
=
Some
(
'
V
'
)
;
}
}
if
!
self
.
is_set
(
AppSettings
:
:
DisableHelpSubcommand
)
&
&
self
.
has_subcommands
(
)
&
&
!
self
.
subcommands
.
iter
(
)
.
any
(
|
s
|
s
.
id
=
=
Id
:
:
help_hash
(
)
)
{
debug
!
(
"
App
:
:
_check_help_and_version
:
Building
help
subcommand
"
)
;
let
mut
help_subcmd
=
App
:
:
new
(
"
help
"
)
.
about
(
"
Print
this
message
or
the
help
of
the
given
subcommand
(
s
)
"
)
.
arg
(
Arg
:
:
new
(
"
subcommand
"
)
.
index
(
1
)
.
takes_value
(
true
)
.
multiple_occurrences
(
true
)
.
value_name
(
"
SUBCOMMAND
"
)
.
help
(
"
The
subcommand
whose
help
message
to
display
"
)
)
;
self
.
_propagate_subcommand
(
&
mut
help_subcmd
)
;
help_subcmd
.
version
=
None
;
help_subcmd
.
long_version
=
None
;
help_subcmd
=
help_subcmd
.
setting
(
AppSettings
:
:
DisableHelpFlag
)
.
unset_global_setting
(
AppSettings
:
:
PropagateVersion
)
;
self
.
subcommands
.
push
(
help_subcmd
)
;
}
}
pub
(
crate
)
fn
_derive_display_order
(
&
mut
self
)
{
debug
!
(
"
App
:
:
_derive_display_order
:
{
}
"
self
.
name
)
;
if
self
.
settings
.
is_set
(
AppSettings
:
:
DeriveDisplayOrder
)
{
for
(
i
a
)
in
self
.
args
.
args_mut
(
)
.
filter
(
|
a
|
!
a
.
is_positional
(
)
)
.
filter
(
|
a
|
a
.
provider
!
=
ArgProvider
:
:
Generated
)
.
enumerate
(
)
{
a
.
disp_ord
.
get_or_insert
(
i
)
;
}
for
(
i
sc
)
in
&
mut
self
.
subcommands
.
iter_mut
(
)
.
enumerate
(
)
{
sc
.
disp_ord
.
get_or_insert
(
i
)
;
}
}
for
sc
in
&
mut
self
.
subcommands
{
sc
.
_derive_display_order
(
)
;
}
}
#
[
doc
(
hidden
)
]
pub
fn
_build_bin_names
(
&
mut
self
)
{
debug
!
(
"
App
:
:
_build_bin_names
"
)
;
if
!
self
.
is_set
(
AppSettings
:
:
BinNameBuilt
)
{
for
mut
sc
in
&
mut
self
.
subcommands
{
debug
!
(
"
App
:
:
_build_bin_names
:
iter
:
bin_name
set
.
.
.
"
)
;
if
sc
.
bin_name
.
is_none
(
)
{
debug
!
(
"
No
"
)
;
let
bin_name
=
format
!
(
"
{
}
{
}
{
}
"
self
.
bin_name
.
as_ref
(
)
.
unwrap_or
(
&
self
.
name
.
clone
(
)
)
if
self
.
bin_name
.
is_some
(
)
{
"
"
}
else
{
"
"
}
&
*
sc
.
name
)
;
debug
!
(
"
App
:
:
_build_bin_names
:
iter
:
Setting
bin_name
of
{
}
to
{
}
"
self
.
name
bin_name
)
;
sc
.
bin_name
=
Some
(
bin_name
)
;
}
else
{
debug
!
(
"
yes
(
{
:
?
}
)
"
sc
.
bin_name
)
;
}
debug
!
(
"
App
:
:
_build_bin_names
:
iter
:
Calling
build_bin_names
from
.
.
.
{
}
"
sc
.
name
)
;
sc
.
_build_bin_names
(
)
;
}
self
.
set
(
AppSettings
:
:
BinNameBuilt
)
;
}
else
{
debug
!
(
"
App
:
:
_build_bin_names
:
already
built
"
)
;
}
}
pub
(
crate
)
fn
_render_version
(
&
self
use_long
:
bool
)
-
>
String
{
debug
!
(
"
App
:
:
_render_version
"
)
;
let
ver
=
if
use_long
{
self
.
long_version
.
unwrap_or_else
(
|
|
self
.
version
.
unwrap_or
(
"
"
)
)
}
else
{
self
.
version
.
unwrap_or_else
(
|
|
self
.
long_version
.
unwrap_or
(
"
"
)
)
}
;
if
let
Some
(
bn
)
=
self
.
bin_name
.
as_ref
(
)
{
if
bn
.
contains
(
'
'
)
{
format
!
(
"
{
}
{
}
\
n
"
bn
.
replace
(
'
'
"
-
"
)
ver
)
}
else
{
format
!
(
"
{
}
{
}
\
n
"
&
self
.
name
[
.
.
]
ver
)
}
}
else
{
format
!
(
"
{
}
{
}
\
n
"
&
self
.
name
[
.
.
]
ver
)
}
}
pub
(
crate
)
fn
format_group
(
&
self
g
:
&
Id
)
-
>
String
{
let
g_string
=
self
.
unroll_args_in_group
(
g
)
.
iter
(
)
.
filter_map
(
|
x
|
self
.
find
(
x
)
)
.
map
(
|
x
|
{
if
x
.
is_positional
(
)
{
x
.
name_no_brackets
(
)
.
to_string
(
)
}
else
{
x
.
to_string
(
)
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
join
(
"
|
"
)
;
format
!
(
"
<
{
}
>
"
&
*
g_string
)
}
}
pub
(
crate
)
trait
Captures
<
'
a
>
{
}
impl
<
'
a
T
>
Captures
<
'
a
>
for
T
{
}
impl
<
'
help
>
App
<
'
help
>
{
pub
(
crate
)
fn
get_non_positionals
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Arg
<
'
help
>
>
{
self
.
get_arguments
(
)
.
filter
(
|
a
|
!
a
.
is_positional
(
)
)
}
pub
(
crate
)
fn
get_positionals_with_no_heading
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Arg
<
'
help
>
>
{
self
.
get_positionals
(
)
.
filter
(
|
a
|
a
.
get_help_heading
(
)
.
is_none
(
)
)
}
pub
(
crate
)
fn
get_non_positionals_with_no_heading
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Arg
<
'
help
>
>
{
self
.
get_non_positionals
(
)
.
filter
(
|
a
|
a
.
get_help_heading
(
)
.
is_none
(
)
)
}
pub
(
crate
)
fn
find
(
&
self
arg_id
:
&
Id
)
-
>
Option
<
&
Arg
<
'
help
>
>
{
self
.
args
.
args
(
)
.
find
(
|
a
|
a
.
id
=
=
*
arg_id
)
}
#
[
inline
]
pub
(
crate
)
fn
contains_short
(
&
self
s
:
char
)
-
>
bool
{
assert
!
(
self
.
is_set
(
AppSettings
:
:
Built
)
"
If
App
:
:
_build
hasn
'
t
been
called
manually
search
through
Arg
shorts
"
)
;
self
.
args
.
contains
(
s
)
}
#
[
inline
]
pub
(
crate
)
fn
set
(
&
mut
self
s
:
AppSettings
)
{
self
.
settings
.
set
(
s
)
}
#
[
inline
]
pub
(
crate
)
fn
has_args
(
&
self
)
-
>
bool
{
!
self
.
args
.
is_empty
(
)
}
pub
(
crate
)
fn
has_positionals
(
&
self
)
-
>
bool
{
self
.
args
.
keys
(
)
.
any
(
|
x
|
x
.
is_position
(
)
)
}
pub
(
crate
)
fn
has_visible_subcommands
(
&
self
)
-
>
bool
{
self
.
subcommands
.
iter
(
)
.
any
(
|
sc
|
sc
.
name
!
=
"
help
"
&
&
!
sc
.
is_set
(
AppSettings
:
:
Hidden
)
)
}
#
[
inline
]
pub
(
crate
)
fn
aliases_to
<
T
>
(
&
self
name
:
&
T
)
-
>
bool
where
T
:
PartialEq
<
str
>
+
?
Sized
{
*
name
=
=
*
self
.
get_name
(
)
|
|
self
.
get_all_aliases
(
)
.
any
(
|
alias
|
*
name
=
=
*
alias
)
}
#
[
inline
]
pub
(
crate
)
fn
short_flag_aliases_to
(
&
self
flag
:
char
)
-
>
bool
{
Some
(
flag
)
=
=
self
.
short_flag
|
|
self
.
get_all_short_flag_aliases
(
)
.
any
(
|
alias
|
flag
=
=
alias
)
}
#
[
inline
]
pub
(
crate
)
fn
long_flag_aliases_to
<
T
>
(
&
self
flag
:
&
T
)
-
>
bool
where
T
:
PartialEq
<
str
>
+
?
Sized
{
match
self
.
long_flag
{
Some
(
long_flag
)
=
>
{
flag
=
=
long_flag
|
|
self
.
get_all_long_flag_aliases
(
)
.
any
(
|
alias
|
flag
=
=
alias
)
}
None
=
>
self
.
get_all_long_flag_aliases
(
)
.
any
(
|
alias
|
flag
=
=
alias
)
}
}
#
[
cfg
(
debug_assertions
)
]
pub
(
crate
)
fn
id_exists
(
&
self
id
:
&
Id
)
-
>
bool
{
self
.
args
.
args
(
)
.
any
(
|
x
|
x
.
id
=
=
*
id
)
|
|
self
.
groups
.
iter
(
)
.
any
(
|
x
|
x
.
id
=
=
*
id
)
}
pub
(
crate
)
fn
groups_for_arg
<
'
a
>
(
&
'
a
self
arg
:
&
Id
)
-
>
impl
Iterator
<
Item
=
Id
>
+
'
a
{
debug
!
(
"
App
:
:
groups_for_arg
:
id
=
{
:
?
}
"
arg
)
;
let
arg
=
arg
.
clone
(
)
;
self
.
groups
.
iter
(
)
.
filter
(
move
|
grp
|
grp
.
args
.
iter
(
)
.
any
(
|
a
|
a
=
=
&
arg
)
)
.
map
(
|
grp
|
grp
.
id
.
clone
(
)
)
}
pub
(
crate
)
fn
find_group
(
&
self
group_id
:
&
Id
)
-
>
Option
<
&
ArgGroup
<
'
help
>
>
{
self
.
groups
.
iter
(
)
.
find
(
|
g
|
g
.
id
=
=
*
group_id
)
}
pub
(
crate
)
fn
all_subcommand_names
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
str
>
+
Captures
<
'
help
>
{
self
.
get_subcommands
(
)
.
flat_map
(
|
sc
|
{
let
name
=
sc
.
get_name
(
)
;
let
aliases
=
sc
.
get_all_aliases
(
)
;
std
:
:
iter
:
:
once
(
name
)
.
chain
(
aliases
)
}
)
}
pub
(
crate
)
fn
unroll_args_in_group
(
&
self
group
:
&
Id
)
-
>
Vec
<
Id
>
{
debug
!
(
"
App
:
:
unroll_args_in_group
:
group
=
{
:
?
}
"
group
)
;
let
mut
g_vec
=
vec
!
[
group
]
;
let
mut
args
=
vec
!
[
]
;
while
let
Some
(
g
)
=
g_vec
.
pop
(
)
{
for
n
in
self
.
groups
.
iter
(
)
.
find
(
|
grp
|
grp
.
id
=
=
*
g
)
.
expect
(
INTERNAL_ERROR_MSG
)
.
args
.
iter
(
)
{
debug
!
(
"
App
:
:
unroll_args_in_group
:
iter
:
entity
=
{
:
?
}
"
n
)
;
if
!
args
.
contains
(
n
)
{
if
self
.
find
(
n
)
.
is_some
(
)
{
debug
!
(
"
App
:
:
unroll_args_in_group
:
iter
:
this
is
an
arg
"
)
;
args
.
push
(
n
.
clone
(
)
)
}
else
{
debug
!
(
"
App
:
:
unroll_args_in_group
:
iter
:
this
is
a
group
"
)
;
g_vec
.
push
(
n
)
;
}
}
}
}
args
}
pub
(
crate
)
fn
unroll_requirements_for_arg
(
&
self
arg
:
&
Id
matcher
:
&
ArgMatcher
)
-
>
Vec
<
Id
>
{
let
requires_if_or_not
=
|
(
val
req_arg
)
:
&
(
Option
<
&
str
>
Id
)
|
-
>
Option
<
Id
>
{
if
let
Some
(
v
)
=
val
{
if
matcher
.
get
(
arg
)
.
map
(
|
ma
|
ma
.
contains_val
(
v
)
)
.
unwrap_or
(
false
)
{
Some
(
req_arg
.
clone
(
)
)
}
else
{
None
}
}
else
{
Some
(
req_arg
.
clone
(
)
)
}
}
;
let
mut
processed
=
vec
!
[
]
;
let
mut
r_vec
=
vec
!
[
arg
]
;
let
mut
args
=
vec
!
[
]
;
while
let
Some
(
a
)
=
r_vec
.
pop
(
)
{
if
processed
.
contains
(
&
a
)
{
continue
;
}
processed
.
push
(
a
)
;
if
let
Some
(
arg
)
=
self
.
find
(
a
)
{
for
r
in
arg
.
requires
.
iter
(
)
.
filter_map
(
requires_if_or_not
)
{
if
let
Some
(
req
)
=
self
.
find
(
&
r
)
{
if
!
req
.
requires
.
is_empty
(
)
{
r_vec
.
push
(
&
req
.
id
)
}
}
args
.
push
(
r
)
;
}
}
}
args
}
pub
(
crate
)
fn
find_short_subcmd
(
&
self
c
:
char
)
-
>
Option
<
&
str
>
{
self
.
get_subcommands
(
)
.
find
(
|
sc
|
sc
.
short_flag_aliases_to
(
c
)
)
.
map
(
|
sc
|
sc
.
get_name
(
)
)
}
pub
(
crate
)
fn
find_long_subcmd
(
&
self
long
:
&
RawOsStr
)
-
>
Option
<
&
str
>
{
self
.
get_subcommands
(
)
.
find
(
|
sc
|
sc
.
long_flag_aliases_to
(
long
)
)
.
map
(
|
sc
|
sc
.
get_name
(
)
)
}
pub
(
crate
)
fn
get_display_order
(
&
self
)
-
>
usize
{
self
.
disp_ord
.
unwrap_or
(
999
)
}
}
impl
<
'
help
>
Index
<
&
'
_
Id
>
for
App
<
'
help
>
{
type
Output
=
Arg
<
'
help
>
;
fn
index
(
&
self
key
:
&
Id
)
-
>
&
Self
:
:
Output
{
self
.
find
(
key
)
.
expect
(
INTERNAL_ERROR_MSG
)
}
}
impl
fmt
:
:
Display
for
App
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
name
)
}
}
fn
two_elements_of
<
I
T
>
(
mut
iter
:
I
)
-
>
Option
<
(
T
T
)
>
where
I
:
Iterator
<
Item
=
T
>
{
let
first
=
iter
.
next
(
)
;
let
second
=
iter
.
next
(
)
;
match
(
first
second
)
{
(
Some
(
first
)
Some
(
second
)
)
=
>
Some
(
(
first
second
)
)
_
=
>
None
}
}
