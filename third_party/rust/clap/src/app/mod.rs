mod
help
;
mod
meta
;
pub
mod
parser
;
mod
settings
;
mod
usage
;
mod
validator
;
use
std
:
:
result
:
:
Result
as
StdResult
;
use
std
:
:
{
env
ffi
:
:
{
OsStr
OsString
}
fmt
io
:
:
{
self
BufRead
BufWriter
Write
}
path
:
:
Path
process
rc
:
:
Rc
}
;
#
[
cfg
(
feature
=
"
yaml
"
)
]
use
yaml_rust
:
:
Yaml
;
use
crate
:
:
errors
:
:
Result
as
ClapResult
;
use
crate
:
:
{
app
:
:
{
help
:
:
Help
parser
:
:
Parser
}
args
:
:
{
AnyArg
Arg
ArgGroup
ArgMatcher
ArgMatches
ArgSettings
}
completions
:
:
Shell
map
:
:
{
self
VecMap
}
}
;
pub
use
settings
:
:
AppSettings
;
#
[
allow
(
missing_debug_implementations
)
]
pub
struct
App
<
'
a
'
b
>
where
'
a
:
'
b
{
#
[
doc
(
hidden
)
]
pub
p
:
Parser
<
'
a
'
b
>
}
impl
<
'
a
'
b
>
App
<
'
a
'
b
>
{
pub
fn
new
<
S
:
Into
<
String
>
>
(
n
:
S
)
-
>
Self
{
App
{
p
:
Parser
:
:
with_name
(
n
.
into
(
)
)
}
}
pub
fn
get_name
(
&
self
)
-
>
&
str
{
&
self
.
p
.
meta
.
name
}
pub
fn
get_bin_name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
p
.
meta
.
bin_name
.
as_deref
(
)
}
#
[
deprecated
(
since
=
"
2
.
14
.
1
"
note
=
"
Can
never
work
;
use
explicit
App
:
:
author
(
)
and
App
:
:
version
(
)
calls
instead
"
)
]
pub
fn
with_defaults
<
S
:
Into
<
String
>
>
(
n
:
S
)
-
>
Self
{
let
mut
a
=
App
{
p
:
Parser
:
:
with_name
(
n
.
into
(
)
)
}
;
a
.
p
.
meta
.
author
=
Some
(
"
Kevin
K
.
<
kbknapp
gmail
.
com
>
"
)
;
a
.
p
.
meta
.
version
=
Some
(
"
2
.
19
.
2
"
)
;
a
}
#
[
cfg
(
feature
=
"
yaml
"
)
]
pub
fn
from_yaml
(
yaml
:
&
'
a
Yaml
)
-
>
App
<
'
a
'
a
>
{
App
:
:
from
(
yaml
)
}
pub
fn
author
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
author
:
S
)
-
>
Self
{
self
.
p
.
meta
.
author
=
Some
(
author
.
into
(
)
)
;
self
}
pub
fn
bin_name
<
S
:
Into
<
String
>
>
(
mut
self
name
:
S
)
-
>
Self
{
self
.
p
.
meta
.
bin_name
=
Some
(
name
.
into
(
)
)
;
self
}
pub
fn
about
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
about
:
S
)
-
>
Self
{
self
.
p
.
meta
.
about
=
Some
(
about
.
into
(
)
)
;
self
}
pub
fn
long_about
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
about
:
S
)
-
>
Self
{
self
.
p
.
meta
.
long_about
=
Some
(
about
.
into
(
)
)
;
self
}
pub
fn
name
<
S
:
Into
<
String
>
>
(
mut
self
name
:
S
)
-
>
Self
{
self
.
p
.
meta
.
name
=
name
.
into
(
)
;
self
}
pub
fn
after_help
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
help
:
S
)
-
>
Self
{
self
.
p
.
meta
.
more_help
=
Some
(
help
.
into
(
)
)
;
self
}
pub
fn
before_help
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
help
:
S
)
-
>
Self
{
self
.
p
.
meta
.
pre_help
=
Some
(
help
.
into
(
)
)
;
self
}
pub
fn
version
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
ver
:
S
)
-
>
Self
{
self
.
p
.
meta
.
version
=
Some
(
ver
.
into
(
)
)
;
self
}
pub
fn
long_version
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
ver
:
S
)
-
>
Self
{
self
.
p
.
meta
.
long_version
=
Some
(
ver
.
into
(
)
)
;
self
}
pub
fn
usage
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
usage
:
S
)
-
>
Self
{
self
.
p
.
meta
.
usage_str
=
Some
(
usage
.
into
(
)
)
;
self
}
pub
fn
help
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
help
:
S
)
-
>
Self
{
self
.
p
.
meta
.
help_str
=
Some
(
help
.
into
(
)
)
;
self
}
pub
fn
help_short
<
S
:
AsRef
<
str
>
+
'
b
>
(
mut
self
s
:
S
)
-
>
Self
{
self
.
p
.
help_short
(
s
.
as_ref
(
)
)
;
self
}
pub
fn
version_short
<
S
:
AsRef
<
str
>
>
(
mut
self
s
:
S
)
-
>
Self
{
self
.
p
.
version_short
(
s
.
as_ref
(
)
)
;
self
}
pub
fn
help_message
<
S
:
Into
<
&
'
a
str
>
>
(
mut
self
s
:
S
)
-
>
Self
{
self
.
p
.
help_message
=
Some
(
s
.
into
(
)
)
;
self
}
pub
fn
version_message
<
S
:
Into
<
&
'
a
str
>
>
(
mut
self
s
:
S
)
-
>
Self
{
self
.
p
.
version_message
=
Some
(
s
.
into
(
)
)
;
self
}
pub
fn
template
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
s
:
S
)
-
>
Self
{
self
.
p
.
meta
.
template
=
Some
(
s
.
into
(
)
)
;
self
}
pub
fn
setting
(
mut
self
setting
:
AppSettings
)
-
>
Self
{
self
.
p
.
set
(
setting
)
;
self
}
pub
fn
settings
(
mut
self
settings
:
&
[
AppSettings
]
)
-
>
Self
{
for
s
in
settings
{
self
.
p
.
set
(
*
s
)
;
}
self
}
pub
fn
global_setting
(
mut
self
setting
:
AppSettings
)
-
>
Self
{
self
.
p
.
set
(
setting
)
;
self
.
p
.
g_settings
.
set
(
setting
)
;
self
}
pub
fn
global_settings
(
mut
self
settings
:
&
[
AppSettings
]
)
-
>
Self
{
for
s
in
settings
{
self
.
p
.
set
(
*
s
)
;
self
.
p
.
g_settings
.
set
(
*
s
)
}
self
}
pub
fn
unset_setting
(
mut
self
setting
:
AppSettings
)
-
>
Self
{
self
.
p
.
unset
(
setting
)
;
self
}
pub
fn
unset_settings
(
mut
self
settings
:
&
[
AppSettings
]
)
-
>
Self
{
for
s
in
settings
{
self
.
p
.
unset
(
*
s
)
;
}
self
}
pub
fn
set_term_width
(
mut
self
width
:
usize
)
-
>
Self
{
self
.
p
.
meta
.
term_w
=
Some
(
width
)
;
self
}
pub
fn
max_term_width
(
mut
self
w
:
usize
)
-
>
Self
{
self
.
p
.
meta
.
max_w
=
Some
(
w
)
;
self
}
pub
fn
arg
<
A
:
Into
<
Arg
<
'
a
'
b
>
>
>
(
mut
self
a
:
A
)
-
>
Self
{
self
.
p
.
add_arg
(
a
.
into
(
)
)
;
self
}
pub
fn
args
(
mut
self
args
:
&
[
Arg
<
'
a
'
b
>
]
)
-
>
Self
{
for
arg
in
args
{
self
.
p
.
add_arg_ref
(
arg
)
;
}
self
}
pub
fn
arg_from_usage
(
mut
self
usage
:
&
'
a
str
)
-
>
Self
{
self
.
p
.
add_arg
(
Arg
:
:
from_usage
(
usage
)
)
;
self
}
pub
fn
args_from_usage
(
mut
self
usage
:
&
'
a
str
)
-
>
Self
{
for
line
in
usage
.
lines
(
)
{
let
l
=
line
.
trim
(
)
;
if
l
.
is_empty
(
)
{
continue
;
}
self
.
p
.
add_arg
(
Arg
:
:
from_usage
(
l
)
)
;
}
self
}
pub
fn
alias
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
name
:
S
)
-
>
Self
{
if
let
Some
(
ref
mut
als
)
=
self
.
p
.
meta
.
aliases
{
als
.
push
(
(
name
.
into
(
)
false
)
)
;
}
else
{
self
.
p
.
meta
.
aliases
=
Some
(
vec
!
[
(
name
.
into
(
)
false
)
]
)
;
}
self
}
pub
fn
aliases
(
mut
self
names
:
&
[
&
'
b
str
]
)
-
>
Self
{
if
let
Some
(
ref
mut
als
)
=
self
.
p
.
meta
.
aliases
{
for
n
in
names
{
als
.
push
(
(
n
false
)
)
;
}
}
else
{
self
.
p
.
meta
.
aliases
=
Some
(
names
.
iter
(
)
.
map
(
|
n
|
(
*
n
false
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
;
}
self
}
pub
fn
visible_alias
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
name
:
S
)
-
>
Self
{
if
let
Some
(
ref
mut
als
)
=
self
.
p
.
meta
.
aliases
{
als
.
push
(
(
name
.
into
(
)
true
)
)
;
}
else
{
self
.
p
.
meta
.
aliases
=
Some
(
vec
!
[
(
name
.
into
(
)
true
)
]
)
;
}
self
}
pub
fn
visible_aliases
(
mut
self
names
:
&
[
&
'
b
str
]
)
-
>
Self
{
if
let
Some
(
ref
mut
als
)
=
self
.
p
.
meta
.
aliases
{
for
n
in
names
{
als
.
push
(
(
n
true
)
)
;
}
}
else
{
self
.
p
.
meta
.
aliases
=
Some
(
names
.
iter
(
)
.
map
(
|
n
|
(
*
n
true
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
;
}
self
}
pub
fn
group
(
mut
self
group
:
ArgGroup
<
'
a
>
)
-
>
Self
{
self
.
p
.
add_group
(
group
)
;
self
}
pub
fn
groups
(
mut
self
groups
:
&
[
ArgGroup
<
'
a
>
]
)
-
>
Self
{
for
g
in
groups
{
self
=
self
.
group
(
g
.
into
(
)
)
;
}
self
}
pub
fn
subcommand
(
mut
self
subcmd
:
App
<
'
a
'
b
>
)
-
>
Self
{
self
.
p
.
add_subcommand
(
subcmd
)
;
self
}
pub
fn
subcommands
<
I
>
(
mut
self
subcmds
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
App
<
'
a
'
b
>
>
{
for
subcmd
in
subcmds
{
self
.
p
.
add_subcommand
(
subcmd
)
;
}
self
}
pub
fn
display_order
(
mut
self
ord
:
usize
)
-
>
Self
{
self
.
p
.
meta
.
disp_ord
=
ord
;
self
}
pub
fn
print_help
(
&
mut
self
)
-
>
ClapResult
<
(
)
>
{
self
.
p
.
propagate_globals
(
)
;
self
.
p
.
propagate_settings
(
)
;
self
.
p
.
derive_display_order
(
)
;
self
.
p
.
create_help_and_version
(
)
;
let
out
=
io
:
:
stdout
(
)
;
let
mut
buf_w
=
BufWriter
:
:
new
(
out
.
lock
(
)
)
;
self
.
write_help
(
&
mut
buf_w
)
}
pub
fn
print_long_help
(
&
mut
self
)
-
>
ClapResult
<
(
)
>
{
let
out
=
io
:
:
stdout
(
)
;
let
mut
buf_w
=
BufWriter
:
:
new
(
out
.
lock
(
)
)
;
self
.
write_long_help
(
&
mut
buf_w
)
}
pub
fn
write_help
<
W
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
ClapResult
<
(
)
>
{
Help
:
:
write_app_help
(
w
self
false
)
}
pub
fn
write_long_help
<
W
:
Write
>
(
&
mut
self
w
:
&
mut
W
)
-
>
ClapResult
<
(
)
>
{
self
.
p
.
propagate_globals
(
)
;
self
.
p
.
propagate_settings
(
)
;
self
.
p
.
derive_display_order
(
)
;
self
.
p
.
create_help_and_version
(
)
;
Help
:
:
write_app_help
(
w
self
true
)
}
pub
fn
write_version
<
W
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
ClapResult
<
(
)
>
{
self
.
p
.
write_version
(
w
false
)
.
map_err
(
From
:
:
from
)
}
pub
fn
write_long_version
<
W
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
ClapResult
<
(
)
>
{
self
.
p
.
write_version
(
w
true
)
.
map_err
(
From
:
:
from
)
}
pub
fn
gen_completions
<
T
:
Into
<
OsString
>
S
:
Into
<
String
>
>
(
&
mut
self
bin_name
:
S
for_shell
:
Shell
out_dir
:
T
)
{
self
.
p
.
meta
.
bin_name
=
Some
(
bin_name
.
into
(
)
)
;
self
.
p
.
gen_completions
(
for_shell
out_dir
.
into
(
)
)
;
}
pub
fn
gen_completions_to
<
W
:
Write
S
:
Into
<
String
>
>
(
&
mut
self
bin_name
:
S
for_shell
:
Shell
buf
:
&
mut
W
)
{
self
.
p
.
meta
.
bin_name
=
Some
(
bin_name
.
into
(
)
)
;
self
.
p
.
gen_completions_to
(
for_shell
buf
)
;
}
pub
fn
get_matches
(
self
)
-
>
ArgMatches
<
'
a
>
{
self
.
get_matches_from
(
&
mut
env
:
:
args_os
(
)
)
}
pub
fn
get_matches_safe
(
self
)
-
>
ClapResult
<
ArgMatches
<
'
a
>
>
{
self
.
get_matches_from_safe
(
&
mut
env
:
:
args_os
(
)
)
}
pub
fn
get_matches_from
<
I
T
>
(
mut
self
itr
:
I
)
-
>
ArgMatches
<
'
a
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
self
.
get_matches_from_safe_borrow
(
itr
)
.
unwrap_or_else
(
|
e
|
{
if
e
.
use_stderr
(
)
{
wlnerr
!
(
"
{
}
"
e
.
message
)
;
if
self
.
p
.
is_set
(
AppSettings
:
:
WaitOnError
)
{
wlnerr
!
(
"
\
nPress
[
ENTER
]
/
[
RETURN
]
to
continue
.
.
.
"
)
;
let
mut
s
=
String
:
:
new
(
)
;
let
i
=
io
:
:
stdin
(
)
;
i
.
lock
(
)
.
read_line
(
&
mut
s
)
.
unwrap
(
)
;
}
drop
(
self
)
;
drop
(
e
)
;
process
:
:
exit
(
1
)
;
}
drop
(
self
)
;
e
.
exit
(
)
}
)
}
pub
fn
get_matches_from_safe
<
I
T
>
(
mut
self
itr
:
I
)
-
>
ClapResult
<
ArgMatches
<
'
a
>
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
self
.
get_matches_from_safe_borrow
(
itr
)
}
pub
fn
get_matches_from_safe_borrow
<
I
T
>
(
&
mut
self
itr
:
I
)
-
>
ClapResult
<
ArgMatches
<
'
a
>
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
if
!
self
.
p
.
is_set
(
AppSettings
:
:
Propagated
)
{
self
.
p
.
propagate_globals
(
)
;
self
.
p
.
propagate_settings
(
)
;
self
.
p
.
derive_display_order
(
)
;
self
.
p
.
set
(
AppSettings
:
:
Propagated
)
;
}
let
mut
matcher
=
ArgMatcher
:
:
new
(
)
;
let
mut
it
=
itr
.
into_iter
(
)
;
if
!
self
.
p
.
is_set
(
AppSettings
:
:
NoBinaryName
)
{
if
let
Some
(
name
)
=
it
.
next
(
)
{
let
bn_os
=
name
.
into
(
)
;
let
p
=
Path
:
:
new
(
&
*
bn_os
)
;
if
let
Some
(
f
)
=
p
.
file_name
(
)
{
if
let
Some
(
s
)
=
f
.
to_os_string
(
)
.
to_str
(
)
{
if
self
.
p
.
meta
.
bin_name
.
is_none
(
)
{
self
.
p
.
meta
.
bin_name
=
Some
(
s
.
to_owned
(
)
)
;
}
}
}
}
}
if
let
Err
(
e
)
=
self
.
p
.
get_matches_with
(
&
mut
matcher
&
mut
it
.
peekable
(
)
)
{
return
Err
(
e
)
;
}
let
global_arg_vec
:
Vec
<
&
str
>
=
self
.
p
.
global_args
.
iter
(
)
.
map
(
|
ga
|
ga
.
b
.
name
)
.
collect
(
)
;
matcher
.
propagate_globals
(
&
global_arg_vec
)
;
Ok
(
matcher
.
into
(
)
)
}
}
#
[
cfg
(
feature
=
"
yaml
"
)
]
impl
<
'
a
>
From
<
&
'
a
Yaml
>
for
App
<
'
a
'
a
>
{
fn
from
(
mut
yaml
:
&
'
a
Yaml
)
-
>
Self
{
use
crate
:
:
args
:
:
SubCommand
;
let
mut
is_sc
=
None
;
let
mut
a
=
if
let
Some
(
name
)
=
yaml
[
"
name
"
]
.
as_str
(
)
{
App
:
:
new
(
name
)
}
else
{
let
yaml_hash
=
yaml
.
as_hash
(
)
.
unwrap
(
)
;
let
sc_key
=
yaml_hash
.
keys
(
)
.
nth
(
0
)
.
unwrap
(
)
;
is_sc
=
Some
(
yaml_hash
.
get
(
sc_key
)
.
unwrap
(
)
)
;
App
:
:
new
(
sc_key
.
as_str
(
)
.
unwrap
(
)
)
}
;
yaml
=
if
let
Some
(
sc
)
=
is_sc
{
sc
}
else
{
yaml
}
;
macro_rules
!
yaml_str
{
(
a
:
ident
y
:
ident
i
:
ident
)
=
>
{
if
let
Some
(
v
)
=
y
[
stringify
!
(
i
)
]
.
as_str
(
)
{
a
=
a
.
i
(
v
)
;
}
else
if
y
[
stringify
!
(
i
)
]
!
=
Yaml
:
:
BadValue
{
panic
!
(
"
Failed
to
convert
YAML
value
{
:
?
}
to
a
string
"
y
[
stringify
!
(
i
)
]
)
;
}
}
;
}
yaml_str
!
(
a
yaml
version
)
;
yaml_str
!
(
a
yaml
long_version
)
;
yaml_str
!
(
a
yaml
author
)
;
yaml_str
!
(
a
yaml
bin_name
)
;
yaml_str
!
(
a
yaml
about
)
;
yaml_str
!
(
a
yaml
long_about
)
;
yaml_str
!
(
a
yaml
before_help
)
;
yaml_str
!
(
a
yaml
after_help
)
;
yaml_str
!
(
a
yaml
template
)
;
yaml_str
!
(
a
yaml
usage
)
;
yaml_str
!
(
a
yaml
help
)
;
yaml_str
!
(
a
yaml
help_short
)
;
yaml_str
!
(
a
yaml
version_short
)
;
yaml_str
!
(
a
yaml
help_message
)
;
yaml_str
!
(
a
yaml
version_message
)
;
yaml_str
!
(
a
yaml
alias
)
;
yaml_str
!
(
a
yaml
visible_alias
)
;
if
let
Some
(
v
)
=
yaml
[
"
display_order
"
]
.
as_i64
(
)
{
a
=
a
.
display_order
(
v
as
usize
)
;
}
else
if
yaml
[
"
display_order
"
]
!
=
Yaml
:
:
BadValue
{
panic
!
(
"
Failed
to
convert
YAML
value
{
:
?
}
to
a
u64
"
yaml
[
"
display_order
"
]
)
;
}
if
let
Some
(
v
)
=
yaml
[
"
setting
"
]
.
as_str
(
)
{
a
=
a
.
setting
(
v
.
parse
(
)
.
expect
(
"
unknown
AppSetting
found
in
YAML
file
"
)
)
;
}
else
if
yaml
[
"
setting
"
]
!
=
Yaml
:
:
BadValue
{
panic
!
(
"
Failed
to
convert
YAML
value
{
:
?
}
to
an
AppSetting
"
yaml
[
"
setting
"
]
)
;
}
if
let
Some
(
v
)
=
yaml
[
"
settings
"
]
.
as_vec
(
)
{
for
ys
in
v
{
if
let
Some
(
s
)
=
ys
.
as_str
(
)
{
a
=
a
.
setting
(
s
.
parse
(
)
.
expect
(
"
unknown
AppSetting
found
in
YAML
file
"
)
)
;
}
}
}
else
if
let
Some
(
v
)
=
yaml
[
"
settings
"
]
.
as_str
(
)
{
a
=
a
.
setting
(
v
.
parse
(
)
.
expect
(
"
unknown
AppSetting
found
in
YAML
file
"
)
)
;
}
else
if
yaml
[
"
settings
"
]
!
=
Yaml
:
:
BadValue
{
panic
!
(
"
Failed
to
convert
YAML
value
{
:
?
}
to
a
string
"
yaml
[
"
settings
"
]
)
;
}
if
let
Some
(
v
)
=
yaml
[
"
global_setting
"
]
.
as_str
(
)
{
a
=
a
.
setting
(
v
.
parse
(
)
.
expect
(
"
unknown
AppSetting
found
in
YAML
file
"
)
)
;
}
else
if
yaml
[
"
global_setting
"
]
!
=
Yaml
:
:
BadValue
{
panic
!
(
"
Failed
to
convert
YAML
value
{
:
?
}
to
an
AppSetting
"
yaml
[
"
setting
"
]
)
;
}
if
let
Some
(
v
)
=
yaml
[
"
global_settings
"
]
.
as_vec
(
)
{
for
ys
in
v
{
if
let
Some
(
s
)
=
ys
.
as_str
(
)
{
a
=
a
.
global_setting
(
s
.
parse
(
)
.
expect
(
"
unknown
AppSetting
found
in
YAML
file
"
)
)
;
}
}
}
else
if
let
Some
(
v
)
=
yaml
[
"
global_settings
"
]
.
as_str
(
)
{
a
=
a
.
global_setting
(
v
.
parse
(
)
.
expect
(
"
unknown
AppSetting
found
in
YAML
file
"
)
)
;
}
else
if
yaml
[
"
global_settings
"
]
!
=
Yaml
:
:
BadValue
{
panic
!
(
"
Failed
to
convert
YAML
value
{
:
?
}
to
a
string
"
yaml
[
"
global_settings
"
]
)
;
}
macro_rules
!
vec_or_str
{
(
a
:
ident
y
:
ident
as_vec
:
ident
as_single
:
ident
)
=
>
{
{
let
maybe_vec
=
y
[
stringify
!
(
as_vec
)
]
.
as_vec
(
)
;
if
let
Some
(
vec
)
=
maybe_vec
{
for
ys
in
vec
{
if
let
Some
(
s
)
=
ys
.
as_str
(
)
{
a
=
a
.
as_single
(
s
)
;
}
else
{
panic
!
(
"
Failed
to
convert
YAML
value
{
:
?
}
to
a
string
"
ys
)
;
}
}
}
else
{
if
let
Some
(
s
)
=
y
[
stringify
!
(
as_vec
)
]
.
as_str
(
)
{
a
=
a
.
as_single
(
s
)
;
}
else
if
y
[
stringify
!
(
as_vec
)
]
!
=
Yaml
:
:
BadValue
{
panic
!
(
"
Failed
to
convert
YAML
value
{
:
?
}
to
either
a
vec
or
string
"
y
[
stringify
!
(
as_vec
)
]
)
;
}
}
a
}
}
;
}
a
=
vec_or_str
!
(
a
yaml
aliases
alias
)
;
a
=
vec_or_str
!
(
a
yaml
visible_aliases
visible_alias
)
;
if
let
Some
(
v
)
=
yaml
[
"
args
"
]
.
as_vec
(
)
{
for
arg_yaml
in
v
{
a
=
a
.
arg
(
Arg
:
:
from_yaml
(
arg_yaml
.
as_hash
(
)
.
unwrap
(
)
)
)
;
}
}
if
let
Some
(
v
)
=
yaml
[
"
subcommands
"
]
.
as_vec
(
)
{
for
sc_yaml
in
v
{
a
=
a
.
subcommand
(
SubCommand
:
:
from_yaml
(
sc_yaml
)
)
;
}
}
if
let
Some
(
v
)
=
yaml
[
"
groups
"
]
.
as_vec
(
)
{
for
ag_yaml
in
v
{
a
=
a
.
group
(
ArgGroup
:
:
from
(
ag_yaml
.
as_hash
(
)
.
unwrap
(
)
)
)
;
}
}
a
}
}
impl
<
'
a
'
b
>
Clone
for
App
<
'
a
'
b
>
{
fn
clone
(
&
self
)
-
>
Self
{
App
{
p
:
self
.
p
.
clone
(
)
}
}
}
impl
<
'
n
'
e
>
AnyArg
<
'
n
'
e
>
for
App
<
'
n
'
e
>
{
fn
name
(
&
self
)
-
>
&
'
n
str
{
"
"
}
fn
overrides
(
&
self
)
-
>
Option
<
&
[
&
'
e
str
]
>
{
None
}
fn
requires
(
&
self
)
-
>
Option
<
&
[
(
Option
<
&
'
e
str
>
&
'
n
str
)
]
>
{
None
}
fn
blacklist
(
&
self
)
-
>
Option
<
&
[
&
'
e
str
]
>
{
None
}
fn
required_unless
(
&
self
)
-
>
Option
<
&
[
&
'
e
str
]
>
{
None
}
fn
val_names
(
&
self
)
-
>
Option
<
&
VecMap
<
&
'
e
str
>
>
{
None
}
fn
is_set
(
&
self
_
:
ArgSettings
)
-
>
bool
{
false
}
fn
val_terminator
(
&
self
)
-
>
Option
<
&
'
e
str
>
{
None
}
fn
set
(
&
mut
self
_
:
ArgSettings
)
{
unreachable
!
(
"
App
struct
does
not
support
AnyArg
:
:
set
this
is
a
bug
!
"
)
}
fn
has_switch
(
&
self
)
-
>
bool
{
false
}
fn
max_vals
(
&
self
)
-
>
Option
<
u64
>
{
None
}
fn
num_vals
(
&
self
)
-
>
Option
<
u64
>
{
None
}
fn
possible_vals
(
&
self
)
-
>
Option
<
&
[
&
'
e
str
]
>
{
None
}
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
clippy
:
:
type_complexity
)
)
]
fn
validator
(
&
self
)
-
>
Option
<
&
Rc
<
Fn
(
String
)
-
>
StdResult
<
(
)
String
>
>
>
{
None
}
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
clippy
:
:
type_complexity
)
)
]
fn
validator_os
(
&
self
)
-
>
Option
<
&
Rc
<
Fn
(
&
OsStr
)
-
>
StdResult
<
(
)
OsString
>
>
>
{
None
}
fn
min_vals
(
&
self
)
-
>
Option
<
u64
>
{
None
}
fn
short
(
&
self
)
-
>
Option
<
char
>
{
None
}
fn
long
(
&
self
)
-
>
Option
<
&
'
e
str
>
{
None
}
fn
val_delim
(
&
self
)
-
>
Option
<
char
>
{
None
}
fn
takes_value
(
&
self
)
-
>
bool
{
true
}
fn
help
(
&
self
)
-
>
Option
<
&
'
e
str
>
{
self
.
p
.
meta
.
about
}
fn
long_help
(
&
self
)
-
>
Option
<
&
'
e
str
>
{
self
.
p
.
meta
.
long_about
}
fn
default_val
(
&
self
)
-
>
Option
<
&
'
e
OsStr
>
{
None
}
fn
default_vals_ifs
(
&
self
)
-
>
Option
<
map
:
:
Values
<
(
&
'
n
str
Option
<
&
'
e
OsStr
>
&
'
e
OsStr
)
>
>
{
None
}
fn
env
<
'
s
>
(
&
'
s
self
)
-
>
Option
<
(
&
'
n
OsStr
Option
<
&
'
s
OsString
>
)
>
{
None
}
fn
longest_filter
(
&
self
)
-
>
bool
{
true
}
fn
aliases
(
&
self
)
-
>
Option
<
Vec
<
&
'
e
str
>
>
{
if
let
Some
(
ref
aliases
)
=
self
.
p
.
meta
.
aliases
{
let
vis_aliases
:
Vec
<
_
>
=
aliases
.
iter
(
)
.
filter_map
(
|
&
(
n
v
)
|
if
v
{
Some
(
n
)
}
else
{
None
}
)
.
collect
(
)
;
if
vis_aliases
.
is_empty
(
)
{
None
}
else
{
Some
(
vis_aliases
)
}
}
else
{
None
}
}
}
impl
<
'
n
'
e
>
fmt
:
:
Display
for
App
<
'
n
'
e
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
p
.
meta
.
name
)
}
}
