#
!
[
cfg
(
all
(
unix
feature
=
"
clock
"
feature
=
"
std
"
)
)
]
use
std
:
:
{
path
process
thread
}
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
use
chrono
:
:
Days
;
use
chrono
:
:
{
Datelike
Local
NaiveDate
NaiveDateTime
NaiveTime
TimeZone
Timelike
}
;
fn
verify_against_date_command_local
(
path
:
&
'
static
str
dt
:
NaiveDateTime
)
{
let
output
=
process
:
:
Command
:
:
new
(
path
)
.
arg
(
"
-
d
"
)
.
arg
(
format
!
(
"
{
}
-
{
:
02
}
-
{
:
02
}
{
:
02
}
:
05
:
01
"
dt
.
year
(
)
dt
.
month
(
)
dt
.
day
(
)
dt
.
hour
(
)
)
)
.
arg
(
"
+
%
Y
-
%
m
-
%
d
%
H
:
%
M
:
%
S
%
:
z
"
)
.
output
(
)
.
unwrap
(
)
;
let
date_command_str
=
String
:
:
from_utf8
(
output
.
stdout
)
.
unwrap
(
)
;
let
date
=
NaiveDate
:
:
from_ymd_opt
(
dt
.
year
(
)
dt
.
month
(
)
dt
.
day
(
)
)
.
unwrap
(
)
;
match
Local
.
from_local_datetime
(
&
date
.
and_hms_opt
(
dt
.
hour
(
)
5
1
)
.
unwrap
(
)
)
{
chrono
:
:
MappedLocalTime
:
:
Ambiguous
(
a
b
)
=
>
assert
!
(
format
!
(
"
{
}
\
n
"
a
)
=
=
date_command_str
|
|
format
!
(
"
{
}
\
n
"
b
)
=
=
date_command_str
)
chrono
:
:
MappedLocalTime
:
:
Single
(
a
)
=
>
{
assert_eq
!
(
format
!
(
"
{
}
\
n
"
a
)
date_command_str
)
;
}
chrono
:
:
MappedLocalTime
:
:
None
=
>
{
assert_eq
!
(
"
"
date_command_str
)
;
}
}
}
#
[
allow
(
dead_code
)
]
#
[
cfg
(
not
(
target_os
=
"
aix
"
)
)
]
const
DATE_PATH
:
&
str
=
"
/
usr
/
bin
/
date
"
;
#
[
allow
(
dead_code
)
]
#
[
cfg
(
target_os
=
"
aix
"
)
]
const
DATE_PATH
:
&
str
=
"
/
opt
/
freeware
/
bin
/
date
"
;
#
[
cfg
(
test
)
]
fn
assert_run_date_version
(
)
{
match
std
:
:
env
:
:
var_os
(
"
LANG
"
)
{
Some
(
lang
)
=
>
eprintln
!
(
"
LANG
:
{
:
?
}
"
lang
)
None
=
>
eprintln
!
(
"
LANG
not
set
"
)
}
let
out
=
process
:
:
Command
:
:
new
(
DATE_PATH
)
.
arg
(
"
-
-
version
"
)
.
output
(
)
.
unwrap
(
)
;
let
stdout
=
String
:
:
from_utf8
(
out
.
stdout
)
.
unwrap
(
)
;
let
stderr
=
String
:
:
from_utf8
(
out
.
stderr
)
.
unwrap
(
)
;
eprintln
!
(
"
command
:
{
:
?
}
-
-
version
\
nstdout
:
{
:
?
}
\
nstderr
:
{
:
?
}
"
DATE_PATH
stdout
stderr
)
;
assert
!
(
out
.
status
.
success
(
)
"
command
failed
:
{
:
?
}
-
-
version
"
DATE_PATH
)
;
}
#
[
test
]
fn
try_verify_against_date_command
(
)
{
if
!
path
:
:
Path
:
:
new
(
DATE_PATH
)
.
exists
(
)
{
eprintln
!
(
"
date
command
{
:
?
}
not
found
skipping
"
DATE_PATH
)
;
return
;
}
assert_run_date_version
(
)
;
eprintln
!
(
"
Run
command
{
:
?
}
for
every
hour
from
1975
to
2077
skipping
some
years
.
.
.
"
DATE_PATH
)
;
let
mut
children
=
vec
!
[
]
;
for
year
in
[
1975
1976
1977
2020
2021
2022
2073
2074
2075
2076
2077
]
.
iter
(
)
{
children
.
push
(
thread
:
:
spawn
(
|
|
{
let
mut
date
=
NaiveDate
:
:
from_ymd_opt
(
*
year
1
1
)
.
unwrap
(
)
.
and_time
(
NaiveTime
:
:
MIN
)
;
let
end
=
NaiveDate
:
:
from_ymd_opt
(
*
year
+
1
1
1
)
.
unwrap
(
)
.
and_time
(
NaiveTime
:
:
MIN
)
;
while
date
<
=
end
{
verify_against_date_command_local
(
DATE_PATH
date
)
;
date
+
=
chrono
:
:
TimeDelta
:
:
try_hours
(
1
)
.
unwrap
(
)
;
}
}
)
)
;
}
for
child
in
children
{
let
_
=
child
.
join
(
)
;
}
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
verify_against_date_command_format_local
(
path
:
&
'
static
str
dt
:
NaiveDateTime
)
{
let
required_format
=
"
d
%
d
D
%
D
F
%
F
H
%
H
I
%
I
j
%
j
k
%
k
l
%
l
m
%
m
M
%
M
q
%
q
S
%
S
T
%
T
u
%
u
U
%
U
w
%
w
W
%
W
X
%
X
y
%
y
Y
%
Y
z
%
:
z
"
;
let
output
=
process
:
:
Command
:
:
new
(
path
)
.
env
(
"
LANG
"
"
c
"
)
.
env
(
"
LC_ALL
"
"
c
"
)
.
arg
(
"
-
d
"
)
.
arg
(
format
!
(
"
{
}
-
{
:
02
}
-
{
:
02
}
{
:
02
}
:
{
:
02
}
:
{
:
02
}
"
dt
.
year
(
)
dt
.
month
(
)
dt
.
day
(
)
dt
.
hour
(
)
dt
.
minute
(
)
dt
.
second
(
)
)
)
.
arg
(
format
!
(
"
+
{
}
"
required_format
)
)
.
output
(
)
.
unwrap
(
)
;
let
date_command_str
=
String
:
:
from_utf8
(
output
.
stdout
)
.
unwrap
(
)
;
let
date
=
NaiveDate
:
:
from_ymd_opt
(
dt
.
year
(
)
dt
.
month
(
)
dt
.
day
(
)
)
.
unwrap
(
)
;
let
ldt
=
Local
.
from_local_datetime
(
&
date
.
and_hms_opt
(
dt
.
hour
(
)
dt
.
minute
(
)
dt
.
second
(
)
)
.
unwrap
(
)
)
.
unwrap
(
)
;
let
formatted_date
=
format
!
(
"
{
}
\
n
"
ldt
.
format
(
required_format
)
)
;
assert_eq
!
(
date_command_str
formatted_date
)
;
}
#
[
test
]
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
try_verify_against_date_command_format
(
)
{
if
!
path
:
:
Path
:
:
new
(
DATE_PATH
)
.
exists
(
)
{
eprintln
!
(
"
date
command
{
:
?
}
not
found
skipping
"
DATE_PATH
)
;
return
;
}
assert_run_date_version
(
)
;
let
mut
date
=
NaiveDate
:
:
from_ymd_opt
(
1970
1
1
)
.
unwrap
(
)
.
and_hms_opt
(
12
11
13
)
.
unwrap
(
)
;
while
date
.
year
(
)
<
2008
{
verify_against_date_command_format_local
(
DATE_PATH
date
)
;
date
=
date
+
Days
:
:
new
(
55
)
;
}
}
