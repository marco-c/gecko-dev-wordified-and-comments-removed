use
core
:
:
fmt
;
use
format
:
:
{
parse
ParseResult
Parsed
StrftimeItems
}
;
use
naive
:
:
{
NaiveDate
NaiveDateTime
NaiveTime
}
;
use
Weekday
;
use
{
Date
DateTime
}
;
#
[
derive
(
Clone
PartialEq
Debug
Copy
Eq
Hash
)
]
pub
enum
LocalResult
<
T
>
{
None
Single
(
T
)
Ambiguous
(
T
T
)
}
impl
<
T
>
LocalResult
<
T
>
{
pub
fn
single
(
self
)
-
>
Option
<
T
>
{
match
self
{
LocalResult
:
:
Single
(
t
)
=
>
Some
(
t
)
_
=
>
None
}
}
pub
fn
earliest
(
self
)
-
>
Option
<
T
>
{
match
self
{
LocalResult
:
:
Single
(
t
)
|
LocalResult
:
:
Ambiguous
(
t
_
)
=
>
Some
(
t
)
_
=
>
None
}
}
pub
fn
latest
(
self
)
-
>
Option
<
T
>
{
match
self
{
LocalResult
:
:
Single
(
t
)
|
LocalResult
:
:
Ambiguous
(
_
t
)
=
>
Some
(
t
)
_
=
>
None
}
}
pub
fn
map
<
U
F
:
FnMut
(
T
)
-
>
U
>
(
self
mut
f
:
F
)
-
>
LocalResult
<
U
>
{
match
self
{
LocalResult
:
:
None
=
>
LocalResult
:
:
None
LocalResult
:
:
Single
(
v
)
=
>
LocalResult
:
:
Single
(
f
(
v
)
)
LocalResult
:
:
Ambiguous
(
min
max
)
=
>
LocalResult
:
:
Ambiguous
(
f
(
min
)
f
(
max
)
)
}
}
}
impl
<
Tz
:
TimeZone
>
LocalResult
<
Date
<
Tz
>
>
{
#
[
inline
]
pub
fn
and_time
(
self
time
:
NaiveTime
)
-
>
LocalResult
<
DateTime
<
Tz
>
>
{
match
self
{
LocalResult
:
:
Single
(
d
)
=
>
d
.
and_time
(
time
)
.
map_or
(
LocalResult
:
:
None
LocalResult
:
:
Single
)
_
=
>
LocalResult
:
:
None
}
}
#
[
inline
]
pub
fn
and_hms_opt
(
self
hour
:
u32
min
:
u32
sec
:
u32
)
-
>
LocalResult
<
DateTime
<
Tz
>
>
{
match
self
{
LocalResult
:
:
Single
(
d
)
=
>
d
.
and_hms_opt
(
hour
min
sec
)
.
map_or
(
LocalResult
:
:
None
LocalResult
:
:
Single
)
_
=
>
LocalResult
:
:
None
}
}
#
[
inline
]
pub
fn
and_hms_milli_opt
(
self
hour
:
u32
min
:
u32
sec
:
u32
milli
:
u32
)
-
>
LocalResult
<
DateTime
<
Tz
>
>
{
match
self
{
LocalResult
:
:
Single
(
d
)
=
>
d
.
and_hms_milli_opt
(
hour
min
sec
milli
)
.
map_or
(
LocalResult
:
:
None
LocalResult
:
:
Single
)
_
=
>
LocalResult
:
:
None
}
}
#
[
inline
]
pub
fn
and_hms_micro_opt
(
self
hour
:
u32
min
:
u32
sec
:
u32
micro
:
u32
)
-
>
LocalResult
<
DateTime
<
Tz
>
>
{
match
self
{
LocalResult
:
:
Single
(
d
)
=
>
d
.
and_hms_micro_opt
(
hour
min
sec
micro
)
.
map_or
(
LocalResult
:
:
None
LocalResult
:
:
Single
)
_
=
>
LocalResult
:
:
None
}
}
#
[
inline
]
pub
fn
and_hms_nano_opt
(
self
hour
:
u32
min
:
u32
sec
:
u32
nano
:
u32
)
-
>
LocalResult
<
DateTime
<
Tz
>
>
{
match
self
{
LocalResult
:
:
Single
(
d
)
=
>
d
.
and_hms_nano_opt
(
hour
min
sec
nano
)
.
map_or
(
LocalResult
:
:
None
LocalResult
:
:
Single
)
_
=
>
LocalResult
:
:
None
}
}
}
impl
<
T
:
fmt
:
:
Debug
>
LocalResult
<
T
>
{
pub
fn
unwrap
(
self
)
-
>
T
{
match
self
{
LocalResult
:
:
None
=
>
panic
!
(
"
No
such
local
time
"
)
LocalResult
:
:
Single
(
t
)
=
>
t
LocalResult
:
:
Ambiguous
(
t1
t2
)
=
>
{
panic
!
(
"
Ambiguous
local
time
ranging
from
{
:
?
}
to
{
:
?
}
"
t1
t2
)
}
}
}
}
pub
trait
Offset
:
Sized
+
Clone
+
fmt
:
:
Debug
{
fn
fix
(
&
self
)
-
>
FixedOffset
;
}
pub
trait
TimeZone
:
Sized
+
Clone
{
type
Offset
:
Offset
;
fn
ymd
(
&
self
year
:
i32
month
:
u32
day
:
u32
)
-
>
Date
<
Self
>
{
self
.
ymd_opt
(
year
month
day
)
.
unwrap
(
)
}
fn
ymd_opt
(
&
self
year
:
i32
month
:
u32
day
:
u32
)
-
>
LocalResult
<
Date
<
Self
>
>
{
match
NaiveDate
:
:
from_ymd_opt
(
year
month
day
)
{
Some
(
d
)
=
>
self
.
from_local_date
(
&
d
)
None
=
>
LocalResult
:
:
None
}
}
fn
yo
(
&
self
year
:
i32
ordinal
:
u32
)
-
>
Date
<
Self
>
{
self
.
yo_opt
(
year
ordinal
)
.
unwrap
(
)
}
fn
yo_opt
(
&
self
year
:
i32
ordinal
:
u32
)
-
>
LocalResult
<
Date
<
Self
>
>
{
match
NaiveDate
:
:
from_yo_opt
(
year
ordinal
)
{
Some
(
d
)
=
>
self
.
from_local_date
(
&
d
)
None
=
>
LocalResult
:
:
None
}
}
fn
isoywd
(
&
self
year
:
i32
week
:
u32
weekday
:
Weekday
)
-
>
Date
<
Self
>
{
self
.
isoywd_opt
(
year
week
weekday
)
.
unwrap
(
)
}
fn
isoywd_opt
(
&
self
year
:
i32
week
:
u32
weekday
:
Weekday
)
-
>
LocalResult
<
Date
<
Self
>
>
{
match
NaiveDate
:
:
from_isoywd_opt
(
year
week
weekday
)
{
Some
(
d
)
=
>
self
.
from_local_date
(
&
d
)
None
=
>
LocalResult
:
:
None
}
}
fn
timestamp
(
&
self
secs
:
i64
nsecs
:
u32
)
-
>
DateTime
<
Self
>
{
self
.
timestamp_opt
(
secs
nsecs
)
.
unwrap
(
)
}
fn
timestamp_opt
(
&
self
secs
:
i64
nsecs
:
u32
)
-
>
LocalResult
<
DateTime
<
Self
>
>
{
match
NaiveDateTime
:
:
from_timestamp_opt
(
secs
nsecs
)
{
Some
(
dt
)
=
>
LocalResult
:
:
Single
(
self
.
from_utc_datetime
(
&
dt
)
)
None
=
>
LocalResult
:
:
None
}
}
fn
timestamp_millis
(
&
self
millis
:
i64
)
-
>
DateTime
<
Self
>
{
self
.
timestamp_millis_opt
(
millis
)
.
unwrap
(
)
}
fn
timestamp_millis_opt
(
&
self
millis
:
i64
)
-
>
LocalResult
<
DateTime
<
Self
>
>
{
let
(
mut
secs
mut
millis
)
=
(
millis
/
1000
millis
%
1000
)
;
if
millis
<
0
{
secs
-
=
1
;
millis
+
=
1000
;
}
self
.
timestamp_opt
(
secs
millis
as
u32
*
1_000_000
)
}
fn
timestamp_nanos
(
&
self
nanos
:
i64
)
-
>
DateTime
<
Self
>
{
let
(
mut
secs
mut
nanos
)
=
(
nanos
/
1_000_000_000
nanos
%
1_000_000_000
)
;
if
nanos
<
0
{
secs
-
=
1
;
nanos
+
=
1_000_000_000
;
}
self
.
timestamp_opt
(
secs
nanos
as
u32
)
.
unwrap
(
)
}
fn
datetime_from_str
(
&
self
s
:
&
str
fmt
:
&
str
)
-
>
ParseResult
<
DateTime
<
Self
>
>
{
let
mut
parsed
=
Parsed
:
:
new
(
)
;
parse
(
&
mut
parsed
s
StrftimeItems
:
:
new
(
fmt
)
)
?
;
parsed
.
to_datetime_with_timezone
(
self
)
}
fn
from_offset
(
offset
:
&
Self
:
:
Offset
)
-
>
Self
;
fn
offset_from_local_date
(
&
self
local
:
&
NaiveDate
)
-
>
LocalResult
<
Self
:
:
Offset
>
;
fn
offset_from_local_datetime
(
&
self
local
:
&
NaiveDateTime
)
-
>
LocalResult
<
Self
:
:
Offset
>
;
fn
from_local_date
(
&
self
local
:
&
NaiveDate
)
-
>
LocalResult
<
Date
<
Self
>
>
{
self
.
offset_from_local_date
(
local
)
.
map
(
|
offset
|
{
Date
:
:
from_utc
(
*
local
offset
)
}
)
}
fn
from_local_datetime
(
&
self
local
:
&
NaiveDateTime
)
-
>
LocalResult
<
DateTime
<
Self
>
>
{
self
.
offset_from_local_datetime
(
local
)
.
map
(
|
offset
|
DateTime
:
:
from_utc
(
*
local
-
offset
.
fix
(
)
offset
)
)
}
fn
offset_from_utc_date
(
&
self
utc
:
&
NaiveDate
)
-
>
Self
:
:
Offset
;
fn
offset_from_utc_datetime
(
&
self
utc
:
&
NaiveDateTime
)
-
>
Self
:
:
Offset
;
fn
from_utc_date
(
&
self
utc
:
&
NaiveDate
)
-
>
Date
<
Self
>
{
Date
:
:
from_utc
(
*
utc
self
.
offset_from_utc_date
(
utc
)
)
}
fn
from_utc_datetime
(
&
self
utc
:
&
NaiveDateTime
)
-
>
DateTime
<
Self
>
{
DateTime
:
:
from_utc
(
*
utc
self
.
offset_from_utc_datetime
(
utc
)
)
}
}
mod
fixed
;
#
[
cfg
(
feature
=
"
clock
"
)
]
mod
local
;
mod
utc
;
pub
use
self
:
:
fixed
:
:
FixedOffset
;
#
[
cfg
(
feature
=
"
clock
"
)
]
pub
use
self
:
:
local
:
:
Local
;
pub
use
self
:
:
utc
:
:
Utc
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
test_negative_millis
(
)
{
let
dt
=
Utc
.
timestamp_millis
(
-
1000
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
59
:
59
UTC
"
)
;
let
dt
=
Utc
.
timestamp_millis
(
-
7000
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
59
:
53
UTC
"
)
;
let
dt
=
Utc
.
timestamp_millis
(
-
7001
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
59
:
52
.
999
UTC
"
)
;
let
dt
=
Utc
.
timestamp_millis
(
-
7003
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
59
:
52
.
997
UTC
"
)
;
let
dt
=
Utc
.
timestamp_millis
(
-
999
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
59
:
59
.
001
UTC
"
)
;
let
dt
=
Utc
.
timestamp_millis
(
-
1
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
59
:
59
.
999
UTC
"
)
;
let
dt
=
Utc
.
timestamp_millis
(
-
60000
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
59
:
00
UTC
"
)
;
let
dt
=
Utc
.
timestamp_millis
(
-
3600000
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
00
:
00
UTC
"
)
;
for
(
millis
expected
)
in
&
[
(
-
7000
"
1969
-
12
-
31
23
:
59
:
53
UTC
"
)
(
-
7001
"
1969
-
12
-
31
23
:
59
:
52
.
999
UTC
"
)
(
-
7003
"
1969
-
12
-
31
23
:
59
:
52
.
997
UTC
"
)
]
{
match
Utc
.
timestamp_millis_opt
(
*
millis
)
{
LocalResult
:
:
Single
(
dt
)
=
>
{
assert_eq
!
(
dt
.
to_string
(
)
*
expected
)
;
}
e
=
>
panic
!
(
"
Got
{
:
?
}
instead
of
an
okay
answer
"
e
)
}
}
}
#
[
test
]
fn
test_negative_nanos
(
)
{
let
dt
=
Utc
.
timestamp_nanos
(
-
1_000_000_000
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
59
:
59
UTC
"
)
;
let
dt
=
Utc
.
timestamp_nanos
(
-
999_999_999
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
59
:
59
.
000000001
UTC
"
)
;
let
dt
=
Utc
.
timestamp_nanos
(
-
1
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
59
:
59
.
999999999
UTC
"
)
;
let
dt
=
Utc
.
timestamp_nanos
(
-
60_000_000_000
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
59
:
00
UTC
"
)
;
let
dt
=
Utc
.
timestamp_nanos
(
-
3_600_000_000_000
)
;
assert_eq
!
(
dt
.
to_string
(
)
"
1969
-
12
-
31
23
:
00
:
00
UTC
"
)
;
}
#
[
test
]
fn
test_nanos_never_panics
(
)
{
Utc
.
timestamp_nanos
(
i64
:
:
max_value
(
)
)
;
Utc
.
timestamp_nanos
(
i64
:
:
default
(
)
)
;
Utc
.
timestamp_nanos
(
i64
:
:
min_value
(
)
)
;
}
}
