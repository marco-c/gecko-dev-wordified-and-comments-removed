use
std
:
:
fmt
;
use
Weekday
;
use
duration
:
:
Duration
;
use
naive
:
:
date
:
:
NaiveDate
;
use
naive
:
:
time
:
:
NaiveTime
;
use
naive
:
:
datetime
:
:
NaiveDateTime
;
use
date
:
:
Date
;
use
datetime
:
:
DateTime
;
use
format
:
:
{
parse
Parsed
ParseResult
StrftimeItems
}
;
#
[
derive
(
Clone
PartialEq
Debug
)
]
pub
enum
LocalResult
<
T
>
{
None
Single
(
T
)
Ambiguous
(
T
T
)
}
impl
<
T
>
LocalResult
<
T
>
{
pub
fn
single
(
self
)
-
>
Option
<
T
>
{
match
self
{
LocalResult
:
:
Single
(
t
)
=
>
Some
(
t
)
_
=
>
None
}
}
pub
fn
earliest
(
self
)
-
>
Option
<
T
>
{
match
self
{
LocalResult
:
:
Single
(
t
)
|
LocalResult
:
:
Ambiguous
(
t
_
)
=
>
Some
(
t
)
_
=
>
None
}
}
pub
fn
latest
(
self
)
-
>
Option
<
T
>
{
match
self
{
LocalResult
:
:
Single
(
t
)
|
LocalResult
:
:
Ambiguous
(
_
t
)
=
>
Some
(
t
)
_
=
>
None
}
}
pub
fn
map
<
U
F
:
FnMut
(
T
)
-
>
U
>
(
self
mut
f
:
F
)
-
>
LocalResult
<
U
>
{
match
self
{
LocalResult
:
:
None
=
>
LocalResult
:
:
None
LocalResult
:
:
Single
(
v
)
=
>
LocalResult
:
:
Single
(
f
(
v
)
)
LocalResult
:
:
Ambiguous
(
min
max
)
=
>
LocalResult
:
:
Ambiguous
(
f
(
min
)
f
(
max
)
)
}
}
}
impl
<
Tz
:
TimeZone
>
LocalResult
<
Date
<
Tz
>
>
{
#
[
inline
]
pub
fn
and_time
(
self
time
:
NaiveTime
)
-
>
LocalResult
<
DateTime
<
Tz
>
>
{
match
self
{
LocalResult
:
:
Single
(
d
)
=
>
d
.
and_time
(
time
)
.
map_or
(
LocalResult
:
:
None
LocalResult
:
:
Single
)
_
=
>
LocalResult
:
:
None
}
}
#
[
inline
]
pub
fn
and_hms_opt
(
self
hour
:
u32
min
:
u32
sec
:
u32
)
-
>
LocalResult
<
DateTime
<
Tz
>
>
{
match
self
{
LocalResult
:
:
Single
(
d
)
=
>
d
.
and_hms_opt
(
hour
min
sec
)
.
map_or
(
LocalResult
:
:
None
LocalResult
:
:
Single
)
_
=
>
LocalResult
:
:
None
}
}
#
[
inline
]
pub
fn
and_hms_milli_opt
(
self
hour
:
u32
min
:
u32
sec
:
u32
milli
:
u32
)
-
>
LocalResult
<
DateTime
<
Tz
>
>
{
match
self
{
LocalResult
:
:
Single
(
d
)
=
>
d
.
and_hms_milli_opt
(
hour
min
sec
milli
)
.
map_or
(
LocalResult
:
:
None
LocalResult
:
:
Single
)
_
=
>
LocalResult
:
:
None
}
}
#
[
inline
]
pub
fn
and_hms_micro_opt
(
self
hour
:
u32
min
:
u32
sec
:
u32
micro
:
u32
)
-
>
LocalResult
<
DateTime
<
Tz
>
>
{
match
self
{
LocalResult
:
:
Single
(
d
)
=
>
d
.
and_hms_micro_opt
(
hour
min
sec
micro
)
.
map_or
(
LocalResult
:
:
None
LocalResult
:
:
Single
)
_
=
>
LocalResult
:
:
None
}
}
#
[
inline
]
pub
fn
and_hms_nano_opt
(
self
hour
:
u32
min
:
u32
sec
:
u32
nano
:
u32
)
-
>
LocalResult
<
DateTime
<
Tz
>
>
{
match
self
{
LocalResult
:
:
Single
(
d
)
=
>
d
.
and_hms_nano_opt
(
hour
min
sec
nano
)
.
map_or
(
LocalResult
:
:
None
LocalResult
:
:
Single
)
_
=
>
LocalResult
:
:
None
}
}
}
impl
<
T
:
fmt
:
:
Debug
>
LocalResult
<
T
>
{
pub
fn
unwrap
(
self
)
-
>
T
{
match
self
{
LocalResult
:
:
None
=
>
panic
!
(
"
No
such
local
time
"
)
LocalResult
:
:
Single
(
t
)
=
>
t
LocalResult
:
:
Ambiguous
(
t1
t2
)
=
>
{
panic
!
(
"
Ambiguous
local
time
ranging
from
{
:
?
}
to
{
:
?
}
"
t1
t2
)
}
}
}
}
pub
trait
Offset
:
Sized
+
Clone
+
fmt
:
:
Debug
{
fn
local_minus_utc
(
&
self
)
-
>
Duration
;
}
pub
trait
TimeZone
:
Sized
+
Clone
{
type
Offset
:
Offset
;
fn
ymd
(
&
self
year
:
i32
month
:
u32
day
:
u32
)
-
>
Date
<
Self
>
{
self
.
ymd_opt
(
year
month
day
)
.
unwrap
(
)
}
fn
ymd_opt
(
&
self
year
:
i32
month
:
u32
day
:
u32
)
-
>
LocalResult
<
Date
<
Self
>
>
{
match
NaiveDate
:
:
from_ymd_opt
(
year
month
day
)
{
Some
(
d
)
=
>
self
.
from_local_date
(
&
d
)
None
=
>
LocalResult
:
:
None
}
}
fn
yo
(
&
self
year
:
i32
ordinal
:
u32
)
-
>
Date
<
Self
>
{
self
.
yo_opt
(
year
ordinal
)
.
unwrap
(
)
}
fn
yo_opt
(
&
self
year
:
i32
ordinal
:
u32
)
-
>
LocalResult
<
Date
<
Self
>
>
{
match
NaiveDate
:
:
from_yo_opt
(
year
ordinal
)
{
Some
(
d
)
=
>
self
.
from_local_date
(
&
d
)
None
=
>
LocalResult
:
:
None
}
}
fn
isoywd
(
&
self
year
:
i32
week
:
u32
weekday
:
Weekday
)
-
>
Date
<
Self
>
{
self
.
isoywd_opt
(
year
week
weekday
)
.
unwrap
(
)
}
fn
isoywd_opt
(
&
self
year
:
i32
week
:
u32
weekday
:
Weekday
)
-
>
LocalResult
<
Date
<
Self
>
>
{
match
NaiveDate
:
:
from_isoywd_opt
(
year
week
weekday
)
{
Some
(
d
)
=
>
self
.
from_local_date
(
&
d
)
None
=
>
LocalResult
:
:
None
}
}
fn
timestamp
(
&
self
secs
:
i64
nsecs
:
u32
)
-
>
DateTime
<
Self
>
{
self
.
timestamp_opt
(
secs
nsecs
)
.
unwrap
(
)
}
fn
timestamp_opt
(
&
self
secs
:
i64
nsecs
:
u32
)
-
>
LocalResult
<
DateTime
<
Self
>
>
{
match
NaiveDateTime
:
:
from_timestamp_opt
(
secs
nsecs
)
{
Some
(
dt
)
=
>
LocalResult
:
:
Single
(
self
.
from_utc_datetime
(
&
dt
)
)
None
=
>
LocalResult
:
:
None
}
}
fn
datetime_from_str
(
&
self
s
:
&
str
fmt
:
&
str
)
-
>
ParseResult
<
DateTime
<
Self
>
>
{
let
mut
parsed
=
Parsed
:
:
new
(
)
;
try
!
(
parse
(
&
mut
parsed
s
StrftimeItems
:
:
new
(
fmt
)
)
)
;
parsed
.
to_datetime_with_timezone
(
self
)
}
fn
from_offset
(
offset
:
&
Self
:
:
Offset
)
-
>
Self
;
fn
offset_from_local_date
(
&
self
local
:
&
NaiveDate
)
-
>
LocalResult
<
Self
:
:
Offset
>
;
fn
offset_from_local_datetime
(
&
self
local
:
&
NaiveDateTime
)
-
>
LocalResult
<
Self
:
:
Offset
>
;
fn
from_local_date
(
&
self
local
:
&
NaiveDate
)
-
>
LocalResult
<
Date
<
Self
>
>
{
self
.
offset_from_local_date
(
local
)
.
map
(
|
offset
|
{
Date
:
:
from_utc
(
*
local
-
offset
.
local_minus_utc
(
)
offset
)
}
)
}
fn
from_local_datetime
(
&
self
local
:
&
NaiveDateTime
)
-
>
LocalResult
<
DateTime
<
Self
>
>
{
self
.
offset_from_local_datetime
(
local
)
.
map
(
|
offset
|
{
DateTime
:
:
from_utc
(
*
local
-
offset
.
local_minus_utc
(
)
offset
)
}
)
}
fn
offset_from_utc_date
(
&
self
utc
:
&
NaiveDate
)
-
>
Self
:
:
Offset
;
fn
offset_from_utc_datetime
(
&
self
utc
:
&
NaiveDateTime
)
-
>
Self
:
:
Offset
;
fn
from_utc_date
(
&
self
utc
:
&
NaiveDate
)
-
>
Date
<
Self
>
{
Date
:
:
from_utc
(
utc
.
clone
(
)
self
.
offset_from_utc_date
(
utc
)
)
}
fn
from_utc_datetime
(
&
self
utc
:
&
NaiveDateTime
)
-
>
DateTime
<
Self
>
{
DateTime
:
:
from_utc
(
utc
.
clone
(
)
self
.
offset_from_utc_datetime
(
utc
)
)
}
}
pub
mod
utc
;
pub
mod
fixed
;
pub
mod
local
;
