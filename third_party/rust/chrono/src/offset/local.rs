use
oldtime
;
use
{
Datelike
Timelike
}
;
use
naive
:
:
{
NaiveDate
NaiveTime
NaiveDateTime
}
;
use
{
Date
DateTime
}
;
use
super
:
:
{
TimeZone
LocalResult
}
;
use
super
:
:
fixed
:
:
FixedOffset
;
fn
tm_to_datetime
(
mut
tm
:
oldtime
:
:
Tm
)
-
>
DateTime
<
Local
>
{
if
tm
.
tm_sec
>
=
60
{
tm
.
tm_nsec
+
=
(
tm
.
tm_sec
-
59
)
*
1_000_000_000
;
tm
.
tm_sec
=
59
;
}
#
[
cfg
(
not
(
windows
)
)
]
fn
tm_to_naive_date
(
tm
:
&
oldtime
:
:
Tm
)
-
>
NaiveDate
{
NaiveDate
:
:
from_yo
(
tm
.
tm_year
+
1900
tm
.
tm_yday
as
u32
+
1
)
}
#
[
cfg
(
windows
)
]
fn
tm_to_naive_date
(
tm
:
&
oldtime
:
:
Tm
)
-
>
NaiveDate
{
NaiveDate
:
:
from_ymd
(
tm
.
tm_year
+
1900
tm
.
tm_mon
as
u32
+
1
tm
.
tm_mday
as
u32
)
}
let
date
=
tm_to_naive_date
(
&
tm
)
;
let
time
=
NaiveTime
:
:
from_hms_nano
(
tm
.
tm_hour
as
u32
tm
.
tm_min
as
u32
tm
.
tm_sec
as
u32
tm
.
tm_nsec
as
u32
)
;
let
offset
=
FixedOffset
:
:
east
(
tm
.
tm_utcoff
)
;
DateTime
:
:
from_utc
(
date
.
and_time
(
time
)
-
offset
offset
)
}
fn
datetime_to_timespec
(
d
:
&
NaiveDateTime
local
:
bool
)
-
>
oldtime
:
:
Timespec
{
let
tm_utcoff
=
if
local
{
1
}
else
{
0
}
;
let
tm
=
oldtime
:
:
Tm
{
tm_sec
:
d
.
second
(
)
as
i32
tm_min
:
d
.
minute
(
)
as
i32
tm_hour
:
d
.
hour
(
)
as
i32
tm_mday
:
d
.
day
(
)
as
i32
tm_mon
:
d
.
month0
(
)
as
i32
tm_year
:
d
.
year
(
)
-
1900
tm_wday
:
0
tm_yday
:
0
tm_isdst
:
-
1
tm_utcoff
:
tm_utcoff
tm_nsec
:
0
}
;
tm
.
to_timespec
(
)
}
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
Local
;
impl
Local
{
pub
fn
today
(
)
-
>
Date
<
Local
>
{
Local
:
:
now
(
)
.
date
(
)
}
pub
fn
now
(
)
-
>
DateTime
<
Local
>
{
tm_to_datetime
(
oldtime
:
:
now
(
)
)
}
}
impl
TimeZone
for
Local
{
type
Offset
=
FixedOffset
;
fn
from_offset
(
_offset
:
&
FixedOffset
)
-
>
Local
{
Local
}
fn
offset_from_local_date
(
&
self
local
:
&
NaiveDate
)
-
>
LocalResult
<
FixedOffset
>
{
self
.
from_local_date
(
local
)
.
map
(
|
date
|
*
date
.
offset
(
)
)
}
fn
offset_from_local_datetime
(
&
self
local
:
&
NaiveDateTime
)
-
>
LocalResult
<
FixedOffset
>
{
self
.
from_local_datetime
(
local
)
.
map
(
|
datetime
|
*
datetime
.
offset
(
)
)
}
fn
offset_from_utc_date
(
&
self
utc
:
&
NaiveDate
)
-
>
FixedOffset
{
*
self
.
from_utc_date
(
utc
)
.
offset
(
)
}
fn
offset_from_utc_datetime
(
&
self
utc
:
&
NaiveDateTime
)
-
>
FixedOffset
{
*
self
.
from_utc_datetime
(
utc
)
.
offset
(
)
}
fn
from_local_date
(
&
self
local
:
&
NaiveDate
)
-
>
LocalResult
<
Date
<
Local
>
>
{
let
midnight
=
self
.
from_local_datetime
(
&
local
.
and_hms
(
0
0
0
)
)
;
midnight
.
map
(
|
datetime
|
Date
:
:
from_utc
(
*
local
*
datetime
.
offset
(
)
)
)
}
fn
from_local_datetime
(
&
self
local
:
&
NaiveDateTime
)
-
>
LocalResult
<
DateTime
<
Local
>
>
{
let
timespec
=
datetime_to_timespec
(
local
true
)
;
let
mut
tm
=
oldtime
:
:
at
(
timespec
)
;
assert_eq
!
(
tm
.
tm_nsec
0
)
;
tm
.
tm_nsec
=
local
.
nanosecond
(
)
as
i32
;
LocalResult
:
:
Single
(
tm_to_datetime
(
tm
)
)
}
fn
from_utc_date
(
&
self
utc
:
&
NaiveDate
)
-
>
Date
<
Local
>
{
let
midnight
=
self
.
from_utc_datetime
(
&
utc
.
and_hms
(
0
0
0
)
)
;
Date
:
:
from_utc
(
*
utc
*
midnight
.
offset
(
)
)
}
fn
from_utc_datetime
(
&
self
utc
:
&
NaiveDateTime
)
-
>
DateTime
<
Local
>
{
let
timespec
=
datetime_to_timespec
(
utc
false
)
;
let
mut
tm
=
oldtime
:
:
at
(
timespec
)
;
assert_eq
!
(
tm
.
tm_nsec
0
)
;
tm
.
tm_nsec
=
utc
.
nanosecond
(
)
as
i32
;
tm_to_datetime
(
tm
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
Datelike
;
use
offset
:
:
TimeZone
;
use
super
:
:
Local
;
#
[
test
]
fn
test_local_date_sanity_check
(
)
{
assert_eq
!
(
Local
.
ymd
(
2999
12
28
)
.
day
(
)
28
)
;
}
#
[
test
]
fn
test_leap_second
(
)
{
let
today
=
Local
:
:
today
(
)
;
let
dt
=
today
.
and_hms_milli
(
1
2
59
1000
)
;
let
timestr
=
dt
.
time
(
)
.
to_string
(
)
;
assert
!
(
timestr
=
=
"
01
:
02
:
60
"
|
|
timestr
=
=
"
01
:
03
:
00
"
"
unexpected
timestr
{
:
?
}
"
timestr
)
;
let
dt
=
today
.
and_hms_milli
(
1
2
3
1234
)
;
let
timestr
=
dt
.
time
(
)
.
to_string
(
)
;
assert
!
(
timestr
=
=
"
01
:
02
:
03
.
234
"
|
|
timestr
=
=
"
01
:
02
:
04
.
234
"
"
unexpected
timestr
{
:
?
}
"
timestr
)
;
}
}
