use
stdtime
;
use
{
Datelike
Timelike
}
;
use
duration
:
:
Duration
;
use
naive
:
:
date
:
:
NaiveDate
;
use
naive
:
:
time
:
:
NaiveTime
;
use
naive
:
:
datetime
:
:
NaiveDateTime
;
use
date
:
:
Date
;
use
datetime
:
:
DateTime
;
use
super
:
:
{
TimeZone
LocalResult
}
;
use
super
:
:
fixed
:
:
FixedOffset
;
fn
tm_to_datetime
(
mut
tm
:
stdtime
:
:
Tm
)
-
>
DateTime
<
Local
>
{
if
tm
.
tm_sec
>
=
60
{
tm
.
tm_nsec
+
=
(
tm
.
tm_sec
-
59
)
*
1_000_000_000
;
tm
.
tm_sec
=
59
;
}
#
[
cfg
(
not
(
windows
)
)
]
fn
tm_to_naive_date
(
tm
:
&
stdtime
:
:
Tm
)
-
>
NaiveDate
{
NaiveDate
:
:
from_yo
(
tm
.
tm_year
+
1900
tm
.
tm_yday
as
u32
+
1
)
}
#
[
cfg
(
windows
)
]
fn
tm_to_naive_date
(
tm
:
&
stdtime
:
:
Tm
)
-
>
NaiveDate
{
NaiveDate
:
:
from_ymd
(
tm
.
tm_year
+
1900
tm
.
tm_mon
as
u32
+
1
tm
.
tm_mday
as
u32
)
}
let
date
=
tm_to_naive_date
(
&
tm
)
;
let
time
=
NaiveTime
:
:
from_hms_nano
(
tm
.
tm_hour
as
u32
tm
.
tm_min
as
u32
tm
.
tm_sec
as
u32
tm
.
tm_nsec
as
u32
)
;
let
offset
=
FixedOffset
:
:
east
(
tm
.
tm_utcoff
)
;
DateTime
:
:
from_utc
(
date
.
and_time
(
time
)
+
Duration
:
:
seconds
(
-
tm
.
tm_utcoff
as
i64
)
offset
)
}
fn
datetime_to_timespec
(
d
:
&
NaiveDateTime
local
:
bool
)
-
>
stdtime
:
:
Timespec
{
let
tm_utcoff
=
if
local
{
1
}
else
{
0
}
;
let
tm
=
stdtime
:
:
Tm
{
tm_sec
:
d
.
second
(
)
as
i32
tm_min
:
d
.
minute
(
)
as
i32
tm_hour
:
d
.
hour
(
)
as
i32
tm_mday
:
d
.
day
(
)
as
i32
tm_mon
:
d
.
month0
(
)
as
i32
tm_year
:
d
.
year
(
)
-
1900
tm_wday
:
0
tm_yday
:
0
tm_isdst
:
-
1
tm_utcoff
:
tm_utcoff
tm_nsec
:
d
.
nanosecond
(
)
as
i32
}
;
tm
.
to_timespec
(
)
}
#
[
derive
(
Copy
Clone
)
]
#
[
cfg_attr
(
feature
=
"
rustc
-
serialize
"
derive
(
RustcEncodable
RustcDecodable
)
)
]
pub
struct
Local
;
impl
Local
{
pub
fn
today
(
)
-
>
Date
<
Local
>
{
Local
:
:
now
(
)
.
date
(
)
}
pub
fn
now
(
)
-
>
DateTime
<
Local
>
{
tm_to_datetime
(
stdtime
:
:
now
(
)
)
}
}
impl
TimeZone
for
Local
{
type
Offset
=
FixedOffset
;
fn
from_offset
(
_offset
:
&
FixedOffset
)
-
>
Local
{
Local
}
fn
offset_from_local_date
(
&
self
local
:
&
NaiveDate
)
-
>
LocalResult
<
FixedOffset
>
{
self
.
from_local_date
(
local
)
.
map
(
|
date
|
*
date
.
offset
(
)
)
}
fn
offset_from_local_datetime
(
&
self
local
:
&
NaiveDateTime
)
-
>
LocalResult
<
FixedOffset
>
{
self
.
from_local_datetime
(
local
)
.
map
(
|
datetime
|
*
datetime
.
offset
(
)
)
}
fn
offset_from_utc_date
(
&
self
utc
:
&
NaiveDate
)
-
>
FixedOffset
{
*
self
.
from_utc_date
(
utc
)
.
offset
(
)
}
fn
offset_from_utc_datetime
(
&
self
utc
:
&
NaiveDateTime
)
-
>
FixedOffset
{
*
self
.
from_utc_datetime
(
utc
)
.
offset
(
)
}
fn
from_local_date
(
&
self
local
:
&
NaiveDate
)
-
>
LocalResult
<
Date
<
Local
>
>
{
let
midnight
=
self
.
from_local_datetime
(
&
local
.
and_hms
(
0
0
0
)
)
;
midnight
.
map
(
|
datetime
|
Date
:
:
from_utc
(
*
local
datetime
.
offset
(
)
.
clone
(
)
)
)
}
fn
from_local_datetime
(
&
self
local
:
&
NaiveDateTime
)
-
>
LocalResult
<
DateTime
<
Local
>
>
{
let
timespec
=
datetime_to_timespec
(
local
true
)
;
LocalResult
:
:
Single
(
tm_to_datetime
(
stdtime
:
:
at
(
timespec
)
)
)
}
fn
from_utc_date
(
&
self
utc
:
&
NaiveDate
)
-
>
Date
<
Local
>
{
let
midnight
=
self
.
from_utc_datetime
(
&
utc
.
and_hms
(
0
0
0
)
)
;
Date
:
:
from_utc
(
*
utc
midnight
.
offset
(
)
.
clone
(
)
)
}
fn
from_utc_datetime
(
&
self
utc
:
&
NaiveDateTime
)
-
>
DateTime
<
Local
>
{
let
timespec
=
datetime_to_timespec
(
utc
false
)
;
tm_to_datetime
(
stdtime
:
:
at
(
timespec
)
)
}
}
