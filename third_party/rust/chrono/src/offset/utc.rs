use
core
:
:
fmt
;
#
[
cfg
(
all
(
feature
=
"
clock
"
not
(
all
(
target_arch
=
"
wasm32
"
feature
=
"
wasmbind
"
)
)
)
)
]
use
oldtime
;
use
naive
:
:
{
NaiveDate
NaiveDateTime
}
;
#
[
cfg
(
feature
=
"
clock
"
)
]
use
{
Date
DateTime
}
;
use
super
:
:
{
TimeZone
Offset
LocalResult
FixedOffset
}
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
)
]
pub
struct
Utc
;
#
[
cfg
(
feature
=
"
clock
"
)
]
impl
Utc
{
pub
fn
today
(
)
-
>
Date
<
Utc
>
{
Utc
:
:
now
(
)
.
date
(
)
}
#
[
cfg
(
not
(
all
(
target_arch
=
"
wasm32
"
feature
=
"
wasmbind
"
)
)
)
]
pub
fn
now
(
)
-
>
DateTime
<
Utc
>
{
let
spec
=
oldtime
:
:
get_time
(
)
;
let
naive
=
NaiveDateTime
:
:
from_timestamp
(
spec
.
sec
spec
.
nsec
as
u32
)
;
DateTime
:
:
from_utc
(
naive
Utc
)
}
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
feature
=
"
wasmbind
"
)
)
]
pub
fn
now
(
)
-
>
DateTime
<
Utc
>
{
let
now
=
js_sys
:
:
Date
:
:
new_0
(
)
;
let
millisecs_since_unix_epoch
:
u64
=
now
.
get_time
(
)
as
u64
;
let
secs
=
millisecs_since_unix_epoch
/
1000
;
let
nanos
=
1_000_000
*
(
millisecs_since_unix_epoch
-
1000
*
secs
)
;
let
naive
=
NaiveDateTime
:
:
from_timestamp
(
secs
as
i64
nanos
as
u32
)
;
DateTime
:
:
from_utc
(
naive
Utc
)
}
}
impl
TimeZone
for
Utc
{
type
Offset
=
Utc
;
fn
from_offset
(
_state
:
&
Utc
)
-
>
Utc
{
Utc
}
fn
offset_from_local_date
(
&
self
_local
:
&
NaiveDate
)
-
>
LocalResult
<
Utc
>
{
LocalResult
:
:
Single
(
Utc
)
}
fn
offset_from_local_datetime
(
&
self
_local
:
&
NaiveDateTime
)
-
>
LocalResult
<
Utc
>
{
LocalResult
:
:
Single
(
Utc
)
}
fn
offset_from_utc_date
(
&
self
_utc
:
&
NaiveDate
)
-
>
Utc
{
Utc
}
fn
offset_from_utc_datetime
(
&
self
_utc
:
&
NaiveDateTime
)
-
>
Utc
{
Utc
}
}
impl
Offset
for
Utc
{
fn
fix
(
&
self
)
-
>
FixedOffset
{
FixedOffset
:
:
east
(
0
)
}
}
impl
fmt
:
:
Debug
for
Utc
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Z
"
)
}
}
impl
fmt
:
:
Display
for
Utc
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
UTC
"
)
}
}
