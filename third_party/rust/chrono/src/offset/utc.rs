use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
clock
"
)
]
use
oldtime
;
use
naive
:
:
{
NaiveDate
NaiveDateTime
}
;
#
[
cfg
(
feature
=
"
clock
"
)
]
use
{
Date
DateTime
}
;
use
super
:
:
{
TimeZone
Offset
LocalResult
FixedOffset
}
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
)
]
pub
struct
Utc
;
#
[
cfg
(
feature
=
"
clock
"
)
]
impl
Utc
{
pub
fn
today
(
)
-
>
Date
<
Utc
>
{
Utc
:
:
now
(
)
.
date
(
)
}
pub
fn
now
(
)
-
>
DateTime
<
Utc
>
{
let
spec
=
oldtime
:
:
get_time
(
)
;
let
naive
=
NaiveDateTime
:
:
from_timestamp
(
spec
.
sec
spec
.
nsec
as
u32
)
;
DateTime
:
:
from_utc
(
naive
Utc
)
}
}
impl
TimeZone
for
Utc
{
type
Offset
=
Utc
;
fn
from_offset
(
_state
:
&
Utc
)
-
>
Utc
{
Utc
}
fn
offset_from_local_date
(
&
self
_local
:
&
NaiveDate
)
-
>
LocalResult
<
Utc
>
{
LocalResult
:
:
Single
(
Utc
)
}
fn
offset_from_local_datetime
(
&
self
_local
:
&
NaiveDateTime
)
-
>
LocalResult
<
Utc
>
{
LocalResult
:
:
Single
(
Utc
)
}
fn
offset_from_utc_date
(
&
self
_utc
:
&
NaiveDate
)
-
>
Utc
{
Utc
}
fn
offset_from_utc_datetime
(
&
self
_utc
:
&
NaiveDateTime
)
-
>
Utc
{
Utc
}
}
impl
Offset
for
Utc
{
fn
fix
(
&
self
)
-
>
FixedOffset
{
FixedOffset
:
:
east
(
0
)
}
}
impl
fmt
:
:
Debug
for
Utc
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Z
"
)
}
}
impl
fmt
:
:
Display
for
Utc
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
UTC
"
)
}
}
