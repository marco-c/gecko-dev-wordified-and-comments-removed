#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
test
)
)
]
use
core
:
:
borrow
:
:
Borrow
;
use
core
:
:
{
str
fmt
}
;
use
core
:
:
ops
:
:
{
Add
Sub
AddAssign
SubAssign
}
;
use
num_traits
:
:
ToPrimitive
;
use
oldtime
:
:
Duration
as
OldDuration
;
use
{
Weekday
Datelike
}
;
use
div
:
:
div_mod_floor
;
use
naive
:
:
{
NaiveTime
NaiveDateTime
IsoWeek
}
;
use
format
:
:
{
Item
Numeric
Pad
}
;
use
format
:
:
{
parse
Parsed
ParseError
ParseResult
StrftimeItems
}
;
#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
test
)
)
]
use
format
:
:
DelayedFormat
;
use
super
:
:
isoweek
;
use
super
:
:
internals
:
:
{
self
DateImpl
Of
Mdf
YearFlags
}
;
const
MAX_YEAR
:
i32
=
internals
:
:
MAX_YEAR
;
const
MIN_YEAR
:
i32
=
internals
:
:
MIN_YEAR
;
#
[
cfg
(
test
)
]
const
MAX_DAYS_FROM_YEAR_0
:
i32
=
MAX_YEAR
*
365
+
MAX_YEAR
/
4
-
MAX_YEAR
/
100
+
MAX_YEAR
/
400
+
365
;
#
[
cfg
(
test
)
]
const
MIN_DAYS_FROM_YEAR_0
:
i32
=
(
MIN_YEAR
+
400_000
)
*
365
+
(
MIN_YEAR
+
400_000
)
/
4
-
(
MIN_YEAR
+
400_000
)
/
100
+
(
MIN_YEAR
+
400_000
)
/
400
-
146097_000
;
#
[
cfg
(
test
)
]
const
MAX_BITS
:
usize
=
44
;
#
[
derive
(
PartialEq
Eq
Hash
PartialOrd
Ord
Copy
Clone
)
]
pub
struct
NaiveDate
{
ymdf
:
DateImpl
}
pub
const
MIN_DATE
:
NaiveDate
=
NaiveDate
{
ymdf
:
(
MIN_YEAR
<
<
13
)
|
(
1
<
<
4
)
|
0o07
}
;
pub
const
MAX_DATE
:
NaiveDate
=
NaiveDate
{
ymdf
:
(
MAX_YEAR
<
<
13
)
|
(
365
<
<
4
)
|
0o17
}
;
#
[
test
]
fn
test_date_bounds
(
)
{
let
calculated_min
=
NaiveDate
:
:
from_ymd
(
MIN_YEAR
1
1
)
;
let
calculated_max
=
NaiveDate
:
:
from_ymd
(
MAX_YEAR
12
31
)
;
assert
!
(
MIN_DATE
=
=
calculated_min
"
MIN_DATE
should
have
a
year
flag
{
:
?
}
"
calculated_min
.
of
(
)
.
flags
(
)
)
;
assert
!
(
MAX_DATE
=
=
calculated_max
"
MAX_DATE
should
have
a
year
flag
{
:
?
}
"
calculated_max
.
of
(
)
.
flags
(
)
)
;
let
maxsecs
=
MAX_DATE
.
signed_duration_since
(
MIN_DATE
)
.
num_seconds
(
)
;
let
maxsecs
=
maxsecs
+
86401
;
assert
!
(
maxsecs
<
(
1
<
<
MAX_BITS
)
"
The
entire
NaiveDate
range
somehow
exceeds
2
^
{
}
seconds
"
MAX_BITS
)
;
}
impl
NaiveDate
{
fn
from_of
(
year
:
i32
of
:
Of
)
-
>
Option
<
NaiveDate
>
{
if
year
>
=
MIN_YEAR
&
&
year
<
=
MAX_YEAR
&
&
of
.
valid
(
)
{
let
Of
(
of
)
=
of
;
Some
(
NaiveDate
{
ymdf
:
(
year
<
<
13
)
|
(
of
as
DateImpl
)
}
)
}
else
{
None
}
}
fn
from_mdf
(
year
:
i32
mdf
:
Mdf
)
-
>
Option
<
NaiveDate
>
{
NaiveDate
:
:
from_of
(
year
mdf
.
to_of
(
)
)
}
pub
fn
from_ymd
(
year
:
i32
month
:
u32
day
:
u32
)
-
>
NaiveDate
{
NaiveDate
:
:
from_ymd_opt
(
year
month
day
)
.
expect
(
"
invalid
or
out
-
of
-
range
date
"
)
}
pub
fn
from_ymd_opt
(
year
:
i32
month
:
u32
day
:
u32
)
-
>
Option
<
NaiveDate
>
{
let
flags
=
YearFlags
:
:
from_year
(
year
)
;
NaiveDate
:
:
from_mdf
(
year
Mdf
:
:
new
(
month
day
flags
)
)
}
pub
fn
from_yo
(
year
:
i32
ordinal
:
u32
)
-
>
NaiveDate
{
NaiveDate
:
:
from_yo_opt
(
year
ordinal
)
.
expect
(
"
invalid
or
out
-
of
-
range
date
"
)
}
pub
fn
from_yo_opt
(
year
:
i32
ordinal
:
u32
)
-
>
Option
<
NaiveDate
>
{
let
flags
=
YearFlags
:
:
from_year
(
year
)
;
NaiveDate
:
:
from_of
(
year
Of
:
:
new
(
ordinal
flags
)
)
}
pub
fn
from_isoywd
(
year
:
i32
week
:
u32
weekday
:
Weekday
)
-
>
NaiveDate
{
NaiveDate
:
:
from_isoywd_opt
(
year
week
weekday
)
.
expect
(
"
invalid
or
out
-
of
-
range
date
"
)
}
pub
fn
from_isoywd_opt
(
year
:
i32
week
:
u32
weekday
:
Weekday
)
-
>
Option
<
NaiveDate
>
{
let
flags
=
YearFlags
:
:
from_year
(
year
)
;
let
nweeks
=
flags
.
nisoweeks
(
)
;
if
1
<
=
week
&
&
week
<
=
nweeks
{
let
weekord
=
week
*
7
+
weekday
as
u32
;
let
delta
=
flags
.
isoweek_delta
(
)
;
if
weekord
<
=
delta
{
let
prevflags
=
YearFlags
:
:
from_year
(
year
-
1
)
;
NaiveDate
:
:
from_of
(
year
-
1
Of
:
:
new
(
weekord
+
prevflags
.
ndays
(
)
-
delta
prevflags
)
)
}
else
{
let
ordinal
=
weekord
-
delta
;
let
ndays
=
flags
.
ndays
(
)
;
if
ordinal
<
=
ndays
{
NaiveDate
:
:
from_of
(
year
Of
:
:
new
(
ordinal
flags
)
)
}
else
{
let
nextflags
=
YearFlags
:
:
from_year
(
year
+
1
)
;
NaiveDate
:
:
from_of
(
year
+
1
Of
:
:
new
(
ordinal
-
ndays
nextflags
)
)
}
}
}
else
{
None
}
}
#
[
inline
]
pub
fn
from_num_days_from_ce
(
days
:
i32
)
-
>
NaiveDate
{
NaiveDate
:
:
from_num_days_from_ce_opt
(
days
)
.
expect
(
"
out
-
of
-
range
date
"
)
}
pub
fn
from_num_days_from_ce_opt
(
days
:
i32
)
-
>
Option
<
NaiveDate
>
{
let
days
=
days
+
365
;
let
(
year_div_400
cycle
)
=
div_mod_floor
(
days
146_097
)
;
let
(
year_mod_400
ordinal
)
=
internals
:
:
cycle_to_yo
(
cycle
as
u32
)
;
let
flags
=
YearFlags
:
:
from_year_mod_400
(
year_mod_400
as
i32
)
;
NaiveDate
:
:
from_of
(
year_div_400
*
400
+
year_mod_400
as
i32
Of
:
:
new
(
ordinal
flags
)
)
}
pub
fn
parse_from_str
(
s
:
&
str
fmt
:
&
str
)
-
>
ParseResult
<
NaiveDate
>
{
let
mut
parsed
=
Parsed
:
:
new
(
)
;
parse
(
&
mut
parsed
s
StrftimeItems
:
:
new
(
fmt
)
)
?
;
parsed
.
to_naive_date
(
)
}
#
[
inline
]
pub
fn
and_time
(
&
self
time
:
NaiveTime
)
-
>
NaiveDateTime
{
NaiveDateTime
:
:
new
(
*
self
time
)
}
#
[
inline
]
pub
fn
and_hms
(
&
self
hour
:
u32
min
:
u32
sec
:
u32
)
-
>
NaiveDateTime
{
self
.
and_hms_opt
(
hour
min
sec
)
.
expect
(
"
invalid
time
"
)
}
#
[
inline
]
pub
fn
and_hms_opt
(
&
self
hour
:
u32
min
:
u32
sec
:
u32
)
-
>
Option
<
NaiveDateTime
>
{
NaiveTime
:
:
from_hms_opt
(
hour
min
sec
)
.
map
(
|
time
|
self
.
and_time
(
time
)
)
}
#
[
inline
]
pub
fn
and_hms_milli
(
&
self
hour
:
u32
min
:
u32
sec
:
u32
milli
:
u32
)
-
>
NaiveDateTime
{
self
.
and_hms_milli_opt
(
hour
min
sec
milli
)
.
expect
(
"
invalid
time
"
)
}
#
[
inline
]
pub
fn
and_hms_milli_opt
(
&
self
hour
:
u32
min
:
u32
sec
:
u32
milli
:
u32
)
-
>
Option
<
NaiveDateTime
>
{
NaiveTime
:
:
from_hms_milli_opt
(
hour
min
sec
milli
)
.
map
(
|
time
|
self
.
and_time
(
time
)
)
}
#
[
inline
]
pub
fn
and_hms_micro
(
&
self
hour
:
u32
min
:
u32
sec
:
u32
micro
:
u32
)
-
>
NaiveDateTime
{
self
.
and_hms_micro_opt
(
hour
min
sec
micro
)
.
expect
(
"
invalid
time
"
)
}
#
[
inline
]
pub
fn
and_hms_micro_opt
(
&
self
hour
:
u32
min
:
u32
sec
:
u32
micro
:
u32
)
-
>
Option
<
NaiveDateTime
>
{
NaiveTime
:
:
from_hms_micro_opt
(
hour
min
sec
micro
)
.
map
(
|
time
|
self
.
and_time
(
time
)
)
}
#
[
inline
]
pub
fn
and_hms_nano
(
&
self
hour
:
u32
min
:
u32
sec
:
u32
nano
:
u32
)
-
>
NaiveDateTime
{
self
.
and_hms_nano_opt
(
hour
min
sec
nano
)
.
expect
(
"
invalid
time
"
)
}
#
[
inline
]
pub
fn
and_hms_nano_opt
(
&
self
hour
:
u32
min
:
u32
sec
:
u32
nano
:
u32
)
-
>
Option
<
NaiveDateTime
>
{
NaiveTime
:
:
from_hms_nano_opt
(
hour
min
sec
nano
)
.
map
(
|
time
|
self
.
and_time
(
time
)
)
}
#
[
inline
]
fn
mdf
(
&
self
)
-
>
Mdf
{
self
.
of
(
)
.
to_mdf
(
)
}
#
[
inline
]
fn
of
(
&
self
)
-
>
Of
{
Of
(
(
self
.
ymdf
&
0b1_1111_1111_1111
)
as
u32
)
}
#
[
inline
]
fn
with_mdf
(
&
self
mdf
:
Mdf
)
-
>
Option
<
NaiveDate
>
{
self
.
with_of
(
mdf
.
to_of
(
)
)
}
#
[
inline
]
fn
with_of
(
&
self
of
:
Of
)
-
>
Option
<
NaiveDate
>
{
if
of
.
valid
(
)
{
let
Of
(
of
)
=
of
;
Some
(
NaiveDate
{
ymdf
:
(
self
.
ymdf
&
!
0b1_1111_1111_1111
)
|
of
as
DateImpl
}
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
succ
(
&
self
)
-
>
NaiveDate
{
self
.
succ_opt
(
)
.
expect
(
"
out
of
bound
"
)
}
#
[
inline
]
pub
fn
succ_opt
(
&
self
)
-
>
Option
<
NaiveDate
>
{
self
.
with_of
(
self
.
of
(
)
.
succ
(
)
)
.
or_else
(
|
|
NaiveDate
:
:
from_ymd_opt
(
self
.
year
(
)
+
1
1
1
)
)
}
#
[
inline
]
pub
fn
pred
(
&
self
)
-
>
NaiveDate
{
self
.
pred_opt
(
)
.
expect
(
"
out
of
bound
"
)
}
#
[
inline
]
pub
fn
pred_opt
(
&
self
)
-
>
Option
<
NaiveDate
>
{
self
.
with_of
(
self
.
of
(
)
.
pred
(
)
)
.
or_else
(
|
|
NaiveDate
:
:
from_ymd_opt
(
self
.
year
(
)
-
1
12
31
)
)
}
pub
fn
checked_add_signed
(
self
rhs
:
OldDuration
)
-
>
Option
<
NaiveDate
>
{
let
year
=
self
.
year
(
)
;
let
(
mut
year_div_400
year_mod_400
)
=
div_mod_floor
(
year
400
)
;
let
cycle
=
internals
:
:
yo_to_cycle
(
year_mod_400
as
u32
self
.
of
(
)
.
ordinal
(
)
)
;
let
cycle
=
try_opt
!
(
(
cycle
as
i32
)
.
checked_add
(
try_opt
!
(
rhs
.
num_days
(
)
.
to_i32
(
)
)
)
)
;
let
(
cycle_div_400y
cycle
)
=
div_mod_floor
(
cycle
146_097
)
;
year_div_400
+
=
cycle_div_400y
;
let
(
year_mod_400
ordinal
)
=
internals
:
:
cycle_to_yo
(
cycle
as
u32
)
;
let
flags
=
YearFlags
:
:
from_year_mod_400
(
year_mod_400
as
i32
)
;
NaiveDate
:
:
from_of
(
year_div_400
*
400
+
year_mod_400
as
i32
Of
:
:
new
(
ordinal
flags
)
)
}
pub
fn
checked_sub_signed
(
self
rhs
:
OldDuration
)
-
>
Option
<
NaiveDate
>
{
let
year
=
self
.
year
(
)
;
let
(
mut
year_div_400
year_mod_400
)
=
div_mod_floor
(
year
400
)
;
let
cycle
=
internals
:
:
yo_to_cycle
(
year_mod_400
as
u32
self
.
of
(
)
.
ordinal
(
)
)
;
let
cycle
=
try_opt
!
(
(
cycle
as
i32
)
.
checked_sub
(
try_opt
!
(
rhs
.
num_days
(
)
.
to_i32
(
)
)
)
)
;
let
(
cycle_div_400y
cycle
)
=
div_mod_floor
(
cycle
146_097
)
;
year_div_400
+
=
cycle_div_400y
;
let
(
year_mod_400
ordinal
)
=
internals
:
:
cycle_to_yo
(
cycle
as
u32
)
;
let
flags
=
YearFlags
:
:
from_year_mod_400
(
year_mod_400
as
i32
)
;
NaiveDate
:
:
from_of
(
year_div_400
*
400
+
year_mod_400
as
i32
Of
:
:
new
(
ordinal
flags
)
)
}
pub
fn
signed_duration_since
(
self
rhs
:
NaiveDate
)
-
>
OldDuration
{
let
year1
=
self
.
year
(
)
;
let
year2
=
rhs
.
year
(
)
;
let
(
year1_div_400
year1_mod_400
)
=
div_mod_floor
(
year1
400
)
;
let
(
year2_div_400
year2_mod_400
)
=
div_mod_floor
(
year2
400
)
;
let
cycle1
=
i64
:
:
from
(
internals
:
:
yo_to_cycle
(
year1_mod_400
as
u32
self
.
of
(
)
.
ordinal
(
)
)
)
;
let
cycle2
=
i64
:
:
from
(
internals
:
:
yo_to_cycle
(
year2_mod_400
as
u32
rhs
.
of
(
)
.
ordinal
(
)
)
)
;
OldDuration
:
:
days
(
(
i64
:
:
from
(
year1_div_400
)
-
i64
:
:
from
(
year2_div_400
)
)
*
146_097
+
(
cycle1
-
cycle2
)
)
}
#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
test
)
)
]
#
[
inline
]
pub
fn
format_with_items
<
'
a
I
B
>
(
&
self
items
:
I
)
-
>
DelayedFormat
<
I
>
where
I
:
Iterator
<
Item
=
B
>
+
Clone
B
:
Borrow
<
Item
<
'
a
>
>
{
DelayedFormat
:
:
new
(
Some
(
*
self
)
None
items
)
}
#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
test
)
)
]
#
[
inline
]
pub
fn
format
<
'
a
>
(
&
self
fmt
:
&
'
a
str
)
-
>
DelayedFormat
<
StrftimeItems
<
'
a
>
>
{
self
.
format_with_items
(
StrftimeItems
:
:
new
(
fmt
)
)
}
}
impl
Datelike
for
NaiveDate
{
#
[
inline
]
fn
year
(
&
self
)
-
>
i32
{
self
.
ymdf
>
>
13
}
#
[
inline
]
fn
month
(
&
self
)
-
>
u32
{
self
.
mdf
(
)
.
month
(
)
}
#
[
inline
]
fn
month0
(
&
self
)
-
>
u32
{
self
.
mdf
(
)
.
month
(
)
-
1
}
#
[
inline
]
fn
day
(
&
self
)
-
>
u32
{
self
.
mdf
(
)
.
day
(
)
}
#
[
inline
]
fn
day0
(
&
self
)
-
>
u32
{
self
.
mdf
(
)
.
day
(
)
-
1
}
#
[
inline
]
fn
ordinal
(
&
self
)
-
>
u32
{
self
.
of
(
)
.
ordinal
(
)
}
#
[
inline
]
fn
ordinal0
(
&
self
)
-
>
u32
{
self
.
of
(
)
.
ordinal
(
)
-
1
}
#
[
inline
]
fn
weekday
(
&
self
)
-
>
Weekday
{
self
.
of
(
)
.
weekday
(
)
}
#
[
inline
]
fn
iso_week
(
&
self
)
-
>
IsoWeek
{
isoweek
:
:
iso_week_from_yof
(
self
.
year
(
)
self
.
of
(
)
)
}
#
[
inline
]
fn
with_year
(
&
self
year
:
i32
)
-
>
Option
<
NaiveDate
>
{
let
mdf
=
self
.
mdf
(
)
;
let
flags
=
YearFlags
:
:
from_year
(
year
)
;
let
mdf
=
mdf
.
with_flags
(
flags
)
;
NaiveDate
:
:
from_mdf
(
year
mdf
)
}
#
[
inline
]
fn
with_month
(
&
self
month
:
u32
)
-
>
Option
<
NaiveDate
>
{
self
.
with_mdf
(
self
.
mdf
(
)
.
with_month
(
month
)
)
}
#
[
inline
]
fn
with_month0
(
&
self
month0
:
u32
)
-
>
Option
<
NaiveDate
>
{
self
.
with_mdf
(
self
.
mdf
(
)
.
with_month
(
month0
+
1
)
)
}
#
[
inline
]
fn
with_day
(
&
self
day
:
u32
)
-
>
Option
<
NaiveDate
>
{
self
.
with_mdf
(
self
.
mdf
(
)
.
with_day
(
day
)
)
}
#
[
inline
]
fn
with_day0
(
&
self
day0
:
u32
)
-
>
Option
<
NaiveDate
>
{
self
.
with_mdf
(
self
.
mdf
(
)
.
with_day
(
day0
+
1
)
)
}
#
[
inline
]
fn
with_ordinal
(
&
self
ordinal
:
u32
)
-
>
Option
<
NaiveDate
>
{
self
.
with_of
(
self
.
of
(
)
.
with_ordinal
(
ordinal
)
)
}
#
[
inline
]
fn
with_ordinal0
(
&
self
ordinal0
:
u32
)
-
>
Option
<
NaiveDate
>
{
self
.
with_of
(
self
.
of
(
)
.
with_ordinal
(
ordinal0
+
1
)
)
}
}
impl
Add
<
OldDuration
>
for
NaiveDate
{
type
Output
=
NaiveDate
;
#
[
inline
]
fn
add
(
self
rhs
:
OldDuration
)
-
>
NaiveDate
{
self
.
checked_add_signed
(
rhs
)
.
expect
(
"
NaiveDate
+
Duration
overflowed
"
)
}
}
impl
AddAssign
<
OldDuration
>
for
NaiveDate
{
#
[
inline
]
fn
add_assign
(
&
mut
self
rhs
:
OldDuration
)
{
*
self
=
self
.
add
(
rhs
)
;
}
}
impl
Sub
<
OldDuration
>
for
NaiveDate
{
type
Output
=
NaiveDate
;
#
[
inline
]
fn
sub
(
self
rhs
:
OldDuration
)
-
>
NaiveDate
{
self
.
checked_sub_signed
(
rhs
)
.
expect
(
"
NaiveDate
-
Duration
overflowed
"
)
}
}
impl
SubAssign
<
OldDuration
>
for
NaiveDate
{
#
[
inline
]
fn
sub_assign
(
&
mut
self
rhs
:
OldDuration
)
{
*
self
=
self
.
sub
(
rhs
)
;
}
}
impl
Sub
<
NaiveDate
>
for
NaiveDate
{
type
Output
=
OldDuration
;
#
[
inline
]
fn
sub
(
self
rhs
:
NaiveDate
)
-
>
OldDuration
{
self
.
signed_duration_since
(
rhs
)
}
}
impl
fmt
:
:
Debug
for
NaiveDate
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
year
=
self
.
year
(
)
;
let
mdf
=
self
.
mdf
(
)
;
if
0
<
=
year
&
&
year
<
=
9999
{
write
!
(
f
"
{
:
04
}
-
{
:
02
}
-
{
:
02
}
"
year
mdf
.
month
(
)
mdf
.
day
(
)
)
}
else
{
write
!
(
f
"
{
:
+
05
}
-
{
:
02
}
-
{
:
02
}
"
year
mdf
.
month
(
)
mdf
.
day
(
)
)
}
}
}
impl
fmt
:
:
Display
for
NaiveDate
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
impl
str
:
:
FromStr
for
NaiveDate
{
type
Err
=
ParseError
;
fn
from_str
(
s
:
&
str
)
-
>
ParseResult
<
NaiveDate
>
{
const
ITEMS
:
&
'
static
[
Item
<
'
static
>
]
=
&
[
Item
:
:
Numeric
(
Numeric
:
:
Year
Pad
:
:
Zero
)
Item
:
:
Space
(
"
"
)
Item
:
:
Literal
(
"
-
"
)
Item
:
:
Numeric
(
Numeric
:
:
Month
Pad
:
:
Zero
)
Item
:
:
Space
(
"
"
)
Item
:
:
Literal
(
"
-
"
)
Item
:
:
Numeric
(
Numeric
:
:
Day
Pad
:
:
Zero
)
Item
:
:
Space
(
"
"
)
]
;
let
mut
parsed
=
Parsed
:
:
new
(
)
;
parse
(
&
mut
parsed
s
ITEMS
.
iter
(
)
)
?
;
parsed
.
to_naive_date
(
)
}
}
#
[
cfg
(
all
(
test
any
(
feature
=
"
rustc
-
serialize
"
feature
=
"
serde
"
)
)
)
]
fn
test_encodable_json
<
F
E
>
(
to_string
:
F
)
where
F
:
Fn
(
&
NaiveDate
)
-
>
Result
<
String
E
>
E
:
:
:
std
:
:
fmt
:
:
Debug
{
assert_eq
!
(
to_string
(
&
NaiveDate
:
:
from_ymd
(
2014
7
24
)
)
.
ok
(
)
Some
(
r
#
"
"
2014
-
07
-
24
"
"
#
.
into
(
)
)
)
;
assert_eq
!
(
to_string
(
&
NaiveDate
:
:
from_ymd
(
0
1
1
)
)
.
ok
(
)
Some
(
r
#
"
"
0000
-
01
-
01
"
"
#
.
into
(
)
)
)
;
assert_eq
!
(
to_string
(
&
NaiveDate
:
:
from_ymd
(
-
1
12
31
)
)
.
ok
(
)
Some
(
r
#
"
"
-
0001
-
12
-
31
"
"
#
.
into
(
)
)
)
;
assert_eq
!
(
to_string
(
&
MIN_DATE
)
.
ok
(
)
Some
(
r
#
"
"
-
262144
-
01
-
01
"
"
#
.
into
(
)
)
)
;
assert_eq
!
(
to_string
(
&
MAX_DATE
)
.
ok
(
)
Some
(
r
#
"
"
+
262143
-
12
-
31
"
"
#
.
into
(
)
)
)
;
}
#
[
cfg
(
all
(
test
any
(
feature
=
"
rustc
-
serialize
"
feature
=
"
serde
"
)
)
)
]
fn
test_decodable_json
<
F
E
>
(
from_str
:
F
)
where
F
:
Fn
(
&
str
)
-
>
Result
<
NaiveDate
E
>
E
:
:
:
std
:
:
fmt
:
:
Debug
{
use
std
:
:
{
i32
i64
}
;
assert_eq
!
(
from_str
(
r
#
"
"
2016
-
07
-
08
"
"
#
)
.
ok
(
)
Some
(
NaiveDate
:
:
from_ymd
(
2016
7
8
)
)
)
;
assert_eq
!
(
from_str
(
r
#
"
"
2016
-
7
-
8
"
"
#
)
.
ok
(
)
Some
(
NaiveDate
:
:
from_ymd
(
2016
7
8
)
)
)
;
assert_eq
!
(
from_str
(
r
#
"
"
+
002016
-
07
-
08
"
"
#
)
.
ok
(
)
Some
(
NaiveDate
:
:
from_ymd
(
2016
7
8
)
)
)
;
assert_eq
!
(
from_str
(
r
#
"
"
0000
-
01
-
01
"
"
#
)
.
ok
(
)
Some
(
NaiveDate
:
:
from_ymd
(
0
1
1
)
)
)
;
assert_eq
!
(
from_str
(
r
#
"
"
0
-
1
-
1
"
"
#
)
.
ok
(
)
Some
(
NaiveDate
:
:
from_ymd
(
0
1
1
)
)
)
;
assert_eq
!
(
from_str
(
r
#
"
"
-
0001
-
12
-
31
"
"
#
)
.
ok
(
)
Some
(
NaiveDate
:
:
from_ymd
(
-
1
12
31
)
)
)
;
assert_eq
!
(
from_str
(
r
#
"
"
-
262144
-
01
-
01
"
"
#
)
.
ok
(
)
Some
(
MIN_DATE
)
)
;
assert_eq
!
(
from_str
(
r
#
"
"
+
262143
-
12
-
31
"
"
#
)
.
ok
(
)
Some
(
MAX_DATE
)
)
;
assert
!
(
from_str
(
r
#
"
"
"
"
#
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
r
#
"
"
20001231
"
"
#
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
r
#
"
"
2000
-
00
-
00
"
"
#
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
r
#
"
"
2000
-
02
-
30
"
"
#
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
r
#
"
"
2001
-
02
-
29
"
"
#
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
r
#
"
"
2002
-
002
-
28
"
"
#
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
r
#
"
"
yyyy
-
mm
-
dd
"
"
#
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
r
#
"
0
"
#
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
r
#
"
20
.
01
"
#
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
&
i32
:
:
MIN
.
to_string
(
)
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
&
i32
:
:
MAX
.
to_string
(
)
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
&
i64
:
:
MIN
.
to_string
(
)
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
&
i64
:
:
MAX
.
to_string
(
)
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
r
#
"
{
}
"
#
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
r
#
"
{
"
ymdf
"
:
20
}
"
#
)
.
is_err
(
)
)
;
assert
!
(
from_str
(
r
#
"
null
"
#
)
.
is_err
(
)
)
;
}
#
[
cfg
(
feature
=
"
rustc
-
serialize
"
)
]
mod
rustc_serialize
{
use
super
:
:
NaiveDate
;
use
rustc_serialize
:
:
{
Encodable
Encoder
Decodable
Decoder
}
;
impl
Encodable
for
NaiveDate
{
fn
encode
<
S
:
Encoder
>
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
format
!
(
"
{
:
?
}
"
self
)
.
encode
(
s
)
}
}
impl
Decodable
for
NaiveDate
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
NaiveDate
D
:
:
Error
>
{
d
.
read_str
(
)
?
.
parse
(
)
.
map_err
(
|
_
|
d
.
error
(
"
invalid
date
"
)
)
}
}
#
[
cfg
(
test
)
]
use
rustc_serialize
:
:
json
;
#
[
test
]
fn
test_encodable
(
)
{
super
:
:
test_encodable_json
(
json
:
:
encode
)
;
}
#
[
test
]
fn
test_decodable
(
)
{
super
:
:
test_decodable_json
(
json
:
:
decode
)
;
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
mod
serde
{
use
core
:
:
fmt
;
use
super
:
:
NaiveDate
;
use
serdelib
:
:
{
ser
de
}
;
impl
ser
:
:
Serialize
for
NaiveDate
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
struct
FormatWrapped
<
'
a
D
:
'
a
>
{
inner
:
&
'
a
D
}
impl
<
'
a
D
:
fmt
:
:
Debug
>
fmt
:
:
Display
for
FormatWrapped
<
'
a
D
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
inner
.
fmt
(
f
)
}
}
serializer
.
collect_str
(
&
FormatWrapped
{
inner
:
&
self
}
)
}
}
struct
NaiveDateVisitor
;
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
NaiveDateVisitor
{
type
Value
=
NaiveDate
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
formatter
"
a
formatted
date
string
"
)
}
#
[
cfg
(
any
(
feature
=
"
std
"
test
)
)
]
fn
visit_str
<
E
>
(
self
value
:
&
str
)
-
>
Result
<
NaiveDate
E
>
where
E
:
de
:
:
Error
{
value
.
parse
(
)
.
map_err
(
E
:
:
custom
)
}
#
[
cfg
(
not
(
any
(
feature
=
"
std
"
test
)
)
)
]
fn
visit_str
<
E
>
(
self
value
:
&
str
)
-
>
Result
<
NaiveDate
E
>
where
E
:
de
:
:
Error
{
value
.
parse
(
)
.
map_err
(
E
:
:
custom
)
}
}
impl
<
'
de
>
de
:
:
Deserialize
<
'
de
>
for
NaiveDate
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_str
(
NaiveDateVisitor
)
}
}
#
[
cfg
(
test
)
]
extern
crate
serde_json
;
#
[
cfg
(
test
)
]
extern
crate
bincode
;
#
[
test
]
fn
test_serde_serialize
(
)
{
super
:
:
test_encodable_json
(
self
:
:
serde_json
:
:
to_string
)
;
}
#
[
test
]
fn
test_serde_deserialize
(
)
{
super
:
:
test_decodable_json
(
|
input
|
self
:
:
serde_json
:
:
from_str
(
&
input
)
)
;
}
#
[
test
]
fn
test_serde_bincode
(
)
{
use
self
:
:
bincode
:
:
{
Infinite
serialize
deserialize
}
;
let
d
=
NaiveDate
:
:
from_ymd
(
2014
7
24
)
;
let
encoded
=
serialize
(
&
d
Infinite
)
.
unwrap
(
)
;
let
decoded
:
NaiveDate
=
deserialize
(
&
encoded
)
.
unwrap
(
)
;
assert_eq
!
(
d
decoded
)
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
NaiveDate
;
use
super
:
:
{
MIN_DATE
MIN_YEAR
MIN_DAYS_FROM_YEAR_0
}
;
use
super
:
:
{
MAX_DATE
MAX_YEAR
MAX_DAYS_FROM_YEAR_0
}
;
use
{
Datelike
Weekday
}
;
use
std
:
:
{
i32
u32
}
;
use
oldtime
:
:
Duration
;
#
[
test
]
fn
test_date_from_ymd
(
)
{
let
ymd_opt
=
|
y
m
d
|
NaiveDate
:
:
from_ymd_opt
(
y
m
d
)
;
assert
!
(
ymd_opt
(
2012
0
1
)
.
is_none
(
)
)
;
assert
!
(
ymd_opt
(
2012
1
1
)
.
is_some
(
)
)
;
assert
!
(
ymd_opt
(
2012
2
29
)
.
is_some
(
)
)
;
assert
!
(
ymd_opt
(
2014
2
29
)
.
is_none
(
)
)
;
assert
!
(
ymd_opt
(
2014
3
0
)
.
is_none
(
)
)
;
assert
!
(
ymd_opt
(
2014
3
1
)
.
is_some
(
)
)
;
assert
!
(
ymd_opt
(
2014
3
31
)
.
is_some
(
)
)
;
assert
!
(
ymd_opt
(
2014
3
32
)
.
is_none
(
)
)
;
assert
!
(
ymd_opt
(
2014
12
31
)
.
is_some
(
)
)
;
assert
!
(
ymd_opt
(
2014
13
1
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_date_from_yo
(
)
{
let
yo_opt
=
|
y
o
|
NaiveDate
:
:
from_yo_opt
(
y
o
)
;
let
ymd
=
|
y
m
d
|
NaiveDate
:
:
from_ymd
(
y
m
d
)
;
assert_eq
!
(
yo_opt
(
2012
0
)
None
)
;
assert_eq
!
(
yo_opt
(
2012
1
)
Some
(
ymd
(
2012
1
1
)
)
)
;
assert_eq
!
(
yo_opt
(
2012
2
)
Some
(
ymd
(
2012
1
2
)
)
)
;
assert_eq
!
(
yo_opt
(
2012
32
)
Some
(
ymd
(
2012
2
1
)
)
)
;
assert_eq
!
(
yo_opt
(
2012
60
)
Some
(
ymd
(
2012
2
29
)
)
)
;
assert_eq
!
(
yo_opt
(
2012
61
)
Some
(
ymd
(
2012
3
1
)
)
)
;
assert_eq
!
(
yo_opt
(
2012
100
)
Some
(
ymd
(
2012
4
9
)
)
)
;
assert_eq
!
(
yo_opt
(
2012
200
)
Some
(
ymd
(
2012
7
18
)
)
)
;
assert_eq
!
(
yo_opt
(
2012
300
)
Some
(
ymd
(
2012
10
26
)
)
)
;
assert_eq
!
(
yo_opt
(
2012
366
)
Some
(
ymd
(
2012
12
31
)
)
)
;
assert_eq
!
(
yo_opt
(
2012
367
)
None
)
;
assert_eq
!
(
yo_opt
(
2014
0
)
None
)
;
assert_eq
!
(
yo_opt
(
2014
1
)
Some
(
ymd
(
2014
1
1
)
)
)
;
assert_eq
!
(
yo_opt
(
2014
2
)
Some
(
ymd
(
2014
1
2
)
)
)
;
assert_eq
!
(
yo_opt
(
2014
32
)
Some
(
ymd
(
2014
2
1
)
)
)
;
assert_eq
!
(
yo_opt
(
2014
59
)
Some
(
ymd
(
2014
2
28
)
)
)
;
assert_eq
!
(
yo_opt
(
2014
60
)
Some
(
ymd
(
2014
3
1
)
)
)
;
assert_eq
!
(
yo_opt
(
2014
100
)
Some
(
ymd
(
2014
4
10
)
)
)
;
assert_eq
!
(
yo_opt
(
2014
200
)
Some
(
ymd
(
2014
7
19
)
)
)
;
assert_eq
!
(
yo_opt
(
2014
300
)
Some
(
ymd
(
2014
10
27
)
)
)
;
assert_eq
!
(
yo_opt
(
2014
365
)
Some
(
ymd
(
2014
12
31
)
)
)
;
assert_eq
!
(
yo_opt
(
2014
366
)
None
)
;
}
#
[
test
]
fn
test_date_from_isoywd
(
)
{
let
isoywd_opt
=
|
y
w
d
|
NaiveDate
:
:
from_isoywd_opt
(
y
w
d
)
;
let
ymd
=
|
y
m
d
|
NaiveDate
:
:
from_ymd
(
y
m
d
)
;
assert_eq
!
(
isoywd_opt
(
2004
0
Weekday
:
:
Sun
)
None
)
;
assert_eq
!
(
isoywd_opt
(
2004
1
Weekday
:
:
Mon
)
Some
(
ymd
(
2003
12
29
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2004
1
Weekday
:
:
Sun
)
Some
(
ymd
(
2004
1
4
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2004
2
Weekday
:
:
Mon
)
Some
(
ymd
(
2004
1
5
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2004
2
Weekday
:
:
Sun
)
Some
(
ymd
(
2004
1
11
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2004
52
Weekday
:
:
Mon
)
Some
(
ymd
(
2004
12
20
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2004
52
Weekday
:
:
Sun
)
Some
(
ymd
(
2004
12
26
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2004
53
Weekday
:
:
Mon
)
Some
(
ymd
(
2004
12
27
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2004
53
Weekday
:
:
Sun
)
Some
(
ymd
(
2005
1
2
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2004
54
Weekday
:
:
Mon
)
None
)
;
assert_eq
!
(
isoywd_opt
(
2011
0
Weekday
:
:
Sun
)
None
)
;
assert_eq
!
(
isoywd_opt
(
2011
1
Weekday
:
:
Mon
)
Some
(
ymd
(
2011
1
3
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2011
1
Weekday
:
:
Sun
)
Some
(
ymd
(
2011
1
9
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2011
2
Weekday
:
:
Mon
)
Some
(
ymd
(
2011
1
10
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2011
2
Weekday
:
:
Sun
)
Some
(
ymd
(
2011
1
16
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2018
51
Weekday
:
:
Mon
)
Some
(
ymd
(
2018
12
17
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2018
51
Weekday
:
:
Sun
)
Some
(
ymd
(
2018
12
23
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2018
52
Weekday
:
:
Mon
)
Some
(
ymd
(
2018
12
24
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2018
52
Weekday
:
:
Sun
)
Some
(
ymd
(
2018
12
30
)
)
)
;
assert_eq
!
(
isoywd_opt
(
2018
53
Weekday
:
:
Mon
)
None
)
;
}
#
[
test
]
fn
test_date_from_isoywd_and_iso_week
(
)
{
for
year
in
2000
.
.
2401
{
for
week
in
1
.
.
54
{
for
&
weekday
in
[
Weekday
:
:
Mon
Weekday
:
:
Tue
Weekday
:
:
Wed
Weekday
:
:
Thu
Weekday
:
:
Fri
Weekday
:
:
Sat
Weekday
:
:
Sun
]
.
iter
(
)
{
let
d
=
NaiveDate
:
:
from_isoywd_opt
(
year
week
weekday
)
;
if
d
.
is_some
(
)
{
let
d
=
d
.
unwrap
(
)
;
assert_eq
!
(
d
.
weekday
(
)
weekday
)
;
let
w
=
d
.
iso_week
(
)
;
assert_eq
!
(
w
.
year
(
)
year
)
;
assert_eq
!
(
w
.
week
(
)
week
)
;
}
}
}
}
for
year
in
2000
.
.
2401
{
for
month
in
1
.
.
13
{
for
day
in
1
.
.
32
{
let
d
=
NaiveDate
:
:
from_ymd_opt
(
year
month
day
)
;
if
d
.
is_some
(
)
{
let
d
=
d
.
unwrap
(
)
;
let
w
=
d
.
iso_week
(
)
;
let
d_
=
NaiveDate
:
:
from_isoywd
(
w
.
year
(
)
w
.
week
(
)
d
.
weekday
(
)
)
;
assert_eq
!
(
d
d_
)
;
}
}
}
}
}
#
[
test
]
fn
test_date_from_num_days_from_ce
(
)
{
let
from_ndays_from_ce
=
|
days
|
NaiveDate
:
:
from_num_days_from_ce_opt
(
days
)
;
assert_eq
!
(
from_ndays_from_ce
(
1
)
Some
(
NaiveDate
:
:
from_ymd
(
1
1
1
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
2
)
Some
(
NaiveDate
:
:
from_ymd
(
1
1
2
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
31
)
Some
(
NaiveDate
:
:
from_ymd
(
1
1
31
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
32
)
Some
(
NaiveDate
:
:
from_ymd
(
1
2
1
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
59
)
Some
(
NaiveDate
:
:
from_ymd
(
1
2
28
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
60
)
Some
(
NaiveDate
:
:
from_ymd
(
1
3
1
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
365
)
Some
(
NaiveDate
:
:
from_ymd
(
1
12
31
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
365
*
1
+
1
)
Some
(
NaiveDate
:
:
from_ymd
(
2
1
1
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
365
*
2
+
1
)
Some
(
NaiveDate
:
:
from_ymd
(
3
1
1
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
365
*
3
+
1
)
Some
(
NaiveDate
:
:
from_ymd
(
4
1
1
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
365
*
4
+
2
)
Some
(
NaiveDate
:
:
from_ymd
(
5
1
1
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
146097
+
1
)
Some
(
NaiveDate
:
:
from_ymd
(
401
1
1
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
146097
*
5
+
1
)
Some
(
NaiveDate
:
:
from_ymd
(
2001
1
1
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
719163
)
Some
(
NaiveDate
:
:
from_ymd
(
1970
1
1
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
0
)
Some
(
NaiveDate
:
:
from_ymd
(
0
12
31
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
-
365
)
Some
(
NaiveDate
:
:
from_ymd
(
0
1
1
)
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
-
366
)
Some
(
NaiveDate
:
:
from_ymd
(
-
1
12
31
)
)
)
;
for
days
in
(
-
9999
.
.
10001
)
.
map
(
|
x
|
x
*
100
)
{
assert_eq
!
(
from_ndays_from_ce
(
days
)
.
map
(
|
d
|
d
.
num_days_from_ce
(
)
)
Some
(
days
)
)
;
}
assert_eq
!
(
from_ndays_from_ce
(
MIN_DATE
.
num_days_from_ce
(
)
)
Some
(
MIN_DATE
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
MIN_DATE
.
num_days_from_ce
(
)
-
1
)
None
)
;
assert_eq
!
(
from_ndays_from_ce
(
MAX_DATE
.
num_days_from_ce
(
)
)
Some
(
MAX_DATE
)
)
;
assert_eq
!
(
from_ndays_from_ce
(
MAX_DATE
.
num_days_from_ce
(
)
+
1
)
None
)
;
}
#
[
test
]
fn
test_date_fields
(
)
{
fn
check
(
year
:
i32
month
:
u32
day
:
u32
ordinal
:
u32
)
{
let
d1
=
NaiveDate
:
:
from_ymd
(
year
month
day
)
;
assert_eq
!
(
d1
.
year
(
)
year
)
;
assert_eq
!
(
d1
.
month
(
)
month
)
;
assert_eq
!
(
d1
.
day
(
)
day
)
;
assert_eq
!
(
d1
.
ordinal
(
)
ordinal
)
;
let
d2
=
NaiveDate
:
:
from_yo
(
year
ordinal
)
;
assert_eq
!
(
d2
.
year
(
)
year
)
;
assert_eq
!
(
d2
.
month
(
)
month
)
;
assert_eq
!
(
d2
.
day
(
)
day
)
;
assert_eq
!
(
d2
.
ordinal
(
)
ordinal
)
;
assert_eq
!
(
d1
d2
)
;
}
check
(
2012
1
1
1
)
;
check
(
2012
1
2
2
)
;
check
(
2012
2
1
32
)
;
check
(
2012
2
29
60
)
;
check
(
2012
3
1
61
)
;
check
(
2012
4
9
100
)
;
check
(
2012
7
18
200
)
;
check
(
2012
10
26
300
)
;
check
(
2012
12
31
366
)
;
check
(
2014
1
1
1
)
;
check
(
2014
1
2
2
)
;
check
(
2014
2
1
32
)
;
check
(
2014
2
28
59
)
;
check
(
2014
3
1
60
)
;
check
(
2014
4
10
100
)
;
check
(
2014
7
19
200
)
;
check
(
2014
10
27
300
)
;
check
(
2014
12
31
365
)
;
}
#
[
test
]
fn
test_date_weekday
(
)
{
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
1582
10
15
)
.
weekday
(
)
Weekday
:
:
Fri
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
1875
5
20
)
.
weekday
(
)
Weekday
:
:
Thu
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
2000
1
1
)
.
weekday
(
)
Weekday
:
:
Sat
)
;
}
#
[
test
]
fn
test_date_with_fields
(
)
{
let
d
=
NaiveDate
:
:
from_ymd
(
2000
2
29
)
;
assert_eq
!
(
d
.
with_year
(
-
400
)
Some
(
NaiveDate
:
:
from_ymd
(
-
400
2
29
)
)
)
;
assert_eq
!
(
d
.
with_year
(
-
100
)
None
)
;
assert_eq
!
(
d
.
with_year
(
1600
)
Some
(
NaiveDate
:
:
from_ymd
(
1600
2
29
)
)
)
;
assert_eq
!
(
d
.
with_year
(
1900
)
None
)
;
assert_eq
!
(
d
.
with_year
(
2000
)
Some
(
NaiveDate
:
:
from_ymd
(
2000
2
29
)
)
)
;
assert_eq
!
(
d
.
with_year
(
2001
)
None
)
;
assert_eq
!
(
d
.
with_year
(
2004
)
Some
(
NaiveDate
:
:
from_ymd
(
2004
2
29
)
)
)
;
assert_eq
!
(
d
.
with_year
(
i32
:
:
MAX
)
None
)
;
let
d
=
NaiveDate
:
:
from_ymd
(
2000
4
30
)
;
assert_eq
!
(
d
.
with_month
(
0
)
None
)
;
assert_eq
!
(
d
.
with_month
(
1
)
Some
(
NaiveDate
:
:
from_ymd
(
2000
1
30
)
)
)
;
assert_eq
!
(
d
.
with_month
(
2
)
None
)
;
assert_eq
!
(
d
.
with_month
(
3
)
Some
(
NaiveDate
:
:
from_ymd
(
2000
3
30
)
)
)
;
assert_eq
!
(
d
.
with_month
(
4
)
Some
(
NaiveDate
:
:
from_ymd
(
2000
4
30
)
)
)
;
assert_eq
!
(
d
.
with_month
(
12
)
Some
(
NaiveDate
:
:
from_ymd
(
2000
12
30
)
)
)
;
assert_eq
!
(
d
.
with_month
(
13
)
None
)
;
assert_eq
!
(
d
.
with_month
(
u32
:
:
MAX
)
None
)
;
let
d
=
NaiveDate
:
:
from_ymd
(
2000
2
8
)
;
assert_eq
!
(
d
.
with_day
(
0
)
None
)
;
assert_eq
!
(
d
.
with_day
(
1
)
Some
(
NaiveDate
:
:
from_ymd
(
2000
2
1
)
)
)
;
assert_eq
!
(
d
.
with_day
(
29
)
Some
(
NaiveDate
:
:
from_ymd
(
2000
2
29
)
)
)
;
assert_eq
!
(
d
.
with_day
(
30
)
None
)
;
assert_eq
!
(
d
.
with_day
(
u32
:
:
MAX
)
None
)
;
let
d
=
NaiveDate
:
:
from_ymd
(
2000
5
5
)
;
assert_eq
!
(
d
.
with_ordinal
(
0
)
None
)
;
assert_eq
!
(
d
.
with_ordinal
(
1
)
Some
(
NaiveDate
:
:
from_ymd
(
2000
1
1
)
)
)
;
assert_eq
!
(
d
.
with_ordinal
(
60
)
Some
(
NaiveDate
:
:
from_ymd
(
2000
2
29
)
)
)
;
assert_eq
!
(
d
.
with_ordinal
(
61
)
Some
(
NaiveDate
:
:
from_ymd
(
2000
3
1
)
)
)
;
assert_eq
!
(
d
.
with_ordinal
(
366
)
Some
(
NaiveDate
:
:
from_ymd
(
2000
12
31
)
)
)
;
assert_eq
!
(
d
.
with_ordinal
(
367
)
None
)
;
assert_eq
!
(
d
.
with_ordinal
(
u32
:
:
MAX
)
None
)
;
}
#
[
test
]
fn
test_date_num_days_from_ce
(
)
{
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
1
1
1
)
.
num_days_from_ce
(
)
1
)
;
for
year
in
-
9999
.
.
10001
{
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
year
1
1
)
.
num_days_from_ce
(
)
NaiveDate
:
:
from_ymd
(
year
-
1
12
31
)
.
num_days_from_ce
(
)
+
1
)
;
}
}
#
[
test
]
fn
test_date_succ
(
)
{
let
ymd
=
|
y
m
d
|
NaiveDate
:
:
from_ymd
(
y
m
d
)
;
assert_eq
!
(
ymd
(
2014
5
6
)
.
succ_opt
(
)
Some
(
ymd
(
2014
5
7
)
)
)
;
assert_eq
!
(
ymd
(
2014
5
31
)
.
succ_opt
(
)
Some
(
ymd
(
2014
6
1
)
)
)
;
assert_eq
!
(
ymd
(
2014
12
31
)
.
succ_opt
(
)
Some
(
ymd
(
2015
1
1
)
)
)
;
assert_eq
!
(
ymd
(
2016
2
28
)
.
succ_opt
(
)
Some
(
ymd
(
2016
2
29
)
)
)
;
assert_eq
!
(
ymd
(
MAX_DATE
.
year
(
)
12
31
)
.
succ_opt
(
)
None
)
;
}
#
[
test
]
fn
test_date_pred
(
)
{
let
ymd
=
|
y
m
d
|
NaiveDate
:
:
from_ymd
(
y
m
d
)
;
assert_eq
!
(
ymd
(
2016
3
1
)
.
pred_opt
(
)
Some
(
ymd
(
2016
2
29
)
)
)
;
assert_eq
!
(
ymd
(
2015
1
1
)
.
pred_opt
(
)
Some
(
ymd
(
2014
12
31
)
)
)
;
assert_eq
!
(
ymd
(
2014
6
1
)
.
pred_opt
(
)
Some
(
ymd
(
2014
5
31
)
)
)
;
assert_eq
!
(
ymd
(
2014
5
7
)
.
pred_opt
(
)
Some
(
ymd
(
2014
5
6
)
)
)
;
assert_eq
!
(
ymd
(
MIN_DATE
.
year
(
)
1
1
)
.
pred_opt
(
)
None
)
;
}
#
[
test
]
fn
test_date_add
(
)
{
fn
check
(
(
y1
m1
d1
)
:
(
i32
u32
u32
)
rhs
:
Duration
ymd
:
Option
<
(
i32
u32
u32
)
>
)
{
let
lhs
=
NaiveDate
:
:
from_ymd
(
y1
m1
d1
)
;
let
sum
=
ymd
.
map
(
|
(
y
m
d
)
|
NaiveDate
:
:
from_ymd
(
y
m
d
)
)
;
assert_eq
!
(
lhs
.
checked_add_signed
(
rhs
)
sum
)
;
assert_eq
!
(
lhs
.
checked_sub_signed
(
-
rhs
)
sum
)
;
}
check
(
(
2014
1
1
)
Duration
:
:
zero
(
)
Some
(
(
2014
1
1
)
)
)
;
check
(
(
2014
1
1
)
Duration
:
:
seconds
(
86399
)
Some
(
(
2014
1
1
)
)
)
;
check
(
(
2014
1
1
)
Duration
:
:
seconds
(
-
86399
)
Some
(
(
2014
1
1
)
)
)
;
check
(
(
2014
1
1
)
Duration
:
:
days
(
1
)
Some
(
(
2014
1
2
)
)
)
;
check
(
(
2014
1
1
)
Duration
:
:
days
(
-
1
)
Some
(
(
2013
12
31
)
)
)
;
check
(
(
2014
1
1
)
Duration
:
:
days
(
364
)
Some
(
(
2014
12
31
)
)
)
;
check
(
(
2014
1
1
)
Duration
:
:
days
(
365
*
4
+
1
)
Some
(
(
2018
1
1
)
)
)
;
check
(
(
2014
1
1
)
Duration
:
:
days
(
365
*
400
+
97
)
Some
(
(
2414
1
1
)
)
)
;
check
(
(
-
7
1
1
)
Duration
:
:
days
(
365
*
12
+
3
)
Some
(
(
5
1
1
)
)
)
;
check
(
(
0
1
1
)
Duration
:
:
days
(
MAX_DAYS_FROM_YEAR_0
as
i64
)
Some
(
(
MAX_YEAR
12
31
)
)
)
;
check
(
(
0
1
1
)
Duration
:
:
days
(
MAX_DAYS_FROM_YEAR_0
as
i64
+
1
)
None
)
;
check
(
(
0
1
1
)
Duration
:
:
max_value
(
)
None
)
;
check
(
(
0
1
1
)
Duration
:
:
days
(
MIN_DAYS_FROM_YEAR_0
as
i64
)
Some
(
(
MIN_YEAR
1
1
)
)
)
;
check
(
(
0
1
1
)
Duration
:
:
days
(
MIN_DAYS_FROM_YEAR_0
as
i64
-
1
)
None
)
;
check
(
(
0
1
1
)
Duration
:
:
min_value
(
)
None
)
;
}
#
[
test
]
fn
test_date_sub
(
)
{
fn
check
(
(
y1
m1
d1
)
:
(
i32
u32
u32
)
(
y2
m2
d2
)
:
(
i32
u32
u32
)
diff
:
Duration
)
{
let
lhs
=
NaiveDate
:
:
from_ymd
(
y1
m1
d1
)
;
let
rhs
=
NaiveDate
:
:
from_ymd
(
y2
m2
d2
)
;
assert_eq
!
(
lhs
.
signed_duration_since
(
rhs
)
diff
)
;
assert_eq
!
(
rhs
.
signed_duration_since
(
lhs
)
-
diff
)
;
}
check
(
(
2014
1
1
)
(
2014
1
1
)
Duration
:
:
zero
(
)
)
;
check
(
(
2014
1
2
)
(
2014
1
1
)
Duration
:
:
days
(
1
)
)
;
check
(
(
2014
12
31
)
(
2014
1
1
)
Duration
:
:
days
(
364
)
)
;
check
(
(
2015
1
3
)
(
2014
1
1
)
Duration
:
:
days
(
365
+
2
)
)
;
check
(
(
2018
1
1
)
(
2014
1
1
)
Duration
:
:
days
(
365
*
4
+
1
)
)
;
check
(
(
2414
1
1
)
(
2014
1
1
)
Duration
:
:
days
(
365
*
400
+
97
)
)
;
check
(
(
MAX_YEAR
12
31
)
(
0
1
1
)
Duration
:
:
days
(
MAX_DAYS_FROM_YEAR_0
as
i64
)
)
;
check
(
(
MIN_YEAR
1
1
)
(
0
1
1
)
Duration
:
:
days
(
MIN_DAYS_FROM_YEAR_0
as
i64
)
)
;
}
#
[
test
]
fn
test_date_addassignment
(
)
{
let
ymd
=
NaiveDate
:
:
from_ymd
;
let
mut
date
=
ymd
(
2016
10
1
)
;
date
+
=
Duration
:
:
days
(
10
)
;
assert_eq
!
(
date
ymd
(
2016
10
11
)
)
;
date
+
=
Duration
:
:
days
(
30
)
;
assert_eq
!
(
date
ymd
(
2016
11
10
)
)
;
}
#
[
test
]
fn
test_date_subassignment
(
)
{
let
ymd
=
NaiveDate
:
:
from_ymd
;
let
mut
date
=
ymd
(
2016
10
11
)
;
date
-
=
Duration
:
:
days
(
10
)
;
assert_eq
!
(
date
ymd
(
2016
10
1
)
)
;
date
-
=
Duration
:
:
days
(
2
)
;
assert_eq
!
(
date
ymd
(
2016
9
29
)
)
;
}
#
[
test
]
fn
test_date_fmt
(
)
{
assert_eq
!
(
format
!
(
"
{
:
?
}
"
NaiveDate
:
:
from_ymd
(
2012
3
4
)
)
"
2012
-
03
-
04
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
NaiveDate
:
:
from_ymd
(
0
3
4
)
)
"
0000
-
03
-
04
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
NaiveDate
:
:
from_ymd
(
-
307
3
4
)
)
"
-
0307
-
03
-
04
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
NaiveDate
:
:
from_ymd
(
12345
3
4
)
)
"
+
12345
-
03
-
04
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
2012
3
4
)
.
to_string
(
)
"
2012
-
03
-
04
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
0
3
4
)
.
to_string
(
)
"
0000
-
03
-
04
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
-
307
3
4
)
.
to_string
(
)
"
-
0307
-
03
-
04
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
12345
3
4
)
.
to_string
(
)
"
+
12345
-
03
-
04
"
)
;
assert_eq
!
(
format
!
(
"
{
:
+
30
?
}
"
NaiveDate
:
:
from_ymd
(
1234
5
6
)
)
"
1234
-
05
-
06
"
)
;
assert_eq
!
(
format
!
(
"
{
:
30
?
}
"
NaiveDate
:
:
from_ymd
(
12345
6
7
)
)
"
+
12345
-
06
-
07
"
)
;
}
#
[
test
]
fn
test_date_from_str
(
)
{
let
valid
=
[
"
-
0000000123456
-
1
-
2
"
"
-
123456
-
1
-
2
"
"
-
12345
-
1
-
2
"
"
-
1234
-
12
-
31
"
"
-
7
-
6
-
5
"
"
350
-
2
-
28
"
"
360
-
02
-
29
"
"
0360
-
02
-
29
"
"
2015
-
2
-
18
"
"
+
70
-
2
-
18
"
"
+
70000
-
2
-
18
"
"
+
00007
-
2
-
18
"
]
;
for
&
s
in
&
valid
{
let
d
=
match
s
.
parse
:
:
<
NaiveDate
>
(
)
{
Ok
(
d
)
=
>
d
Err
(
e
)
=
>
panic
!
(
"
parsing
{
}
has
failed
:
{
}
"
s
e
)
}
;
let
s_
=
format
!
(
"
{
:
?
}
"
d
)
;
let
d_
=
match
s_
.
parse
:
:
<
NaiveDate
>
(
)
{
Ok
(
d
)
=
>
d
Err
(
e
)
=
>
panic
!
(
"
{
}
is
parsed
into
{
:
?
}
but
reparsing
that
has
failed
:
{
}
"
s
d
e
)
}
;
assert
!
(
d
=
=
d_
"
{
}
is
parsed
into
{
:
?
}
but
reparsed
result
\
{
:
?
}
does
not
match
"
s
d
d_
)
;
}
assert
!
(
"
"
.
parse
:
:
<
NaiveDate
>
(
)
.
is_err
(
)
)
;
assert
!
(
"
x
"
.
parse
:
:
<
NaiveDate
>
(
)
.
is_err
(
)
)
;
assert
!
(
"
2014
"
.
parse
:
:
<
NaiveDate
>
(
)
.
is_err
(
)
)
;
assert
!
(
"
2014
-
01
"
.
parse
:
:
<
NaiveDate
>
(
)
.
is_err
(
)
)
;
assert
!
(
"
2014
-
01
-
00
"
.
parse
:
:
<
NaiveDate
>
(
)
.
is_err
(
)
)
;
assert
!
(
"
2014
-
13
-
57
"
.
parse
:
:
<
NaiveDate
>
(
)
.
is_err
(
)
)
;
assert
!
(
"
9999999
-
9
-
9
"
.
parse
:
:
<
NaiveDate
>
(
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
test_date_parse_from_str
(
)
{
let
ymd
=
|
y
m
d
|
NaiveDate
:
:
from_ymd
(
y
m
d
)
;
assert_eq
!
(
NaiveDate
:
:
parse_from_str
(
"
2014
-
5
-
7T12
:
34
:
56
+
09
:
30
"
"
%
Y
-
%
m
-
%
dT
%
H
:
%
M
:
%
S
%
z
"
)
Ok
(
ymd
(
2014
5
7
)
)
)
;
assert_eq
!
(
NaiveDate
:
:
parse_from_str
(
"
2015
-
W06
-
1
=
2015
-
033
"
"
%
G
-
W
%
V
-
%
u
=
%
Y
-
%
j
"
)
Ok
(
ymd
(
2015
2
2
)
)
)
;
assert_eq
!
(
NaiveDate
:
:
parse_from_str
(
"
Fri
09
Aug
13
"
"
%
a
%
d
%
b
%
y
"
)
Ok
(
ymd
(
2013
8
9
)
)
)
;
assert
!
(
NaiveDate
:
:
parse_from_str
(
"
Sat
09
Aug
2013
"
"
%
a
%
d
%
b
%
Y
"
)
.
is_err
(
)
)
;
assert
!
(
NaiveDate
:
:
parse_from_str
(
"
2014
-
57
"
"
%
Y
-
%
m
-
%
d
"
)
.
is_err
(
)
)
;
assert
!
(
NaiveDate
:
:
parse_from_str
(
"
2014
"
"
%
Y
"
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
test_date_format
(
)
{
let
d
=
NaiveDate
:
:
from_ymd
(
2012
3
4
)
;
assert_eq
!
(
d
.
format
(
"
%
Y
%
C
%
y
%
G
%
g
"
)
.
to_string
(
)
"
2012
20
12
2012
12
"
)
;
assert_eq
!
(
d
.
format
(
"
%
m
%
b
%
h
%
B
"
)
.
to_string
(
)
"
03
Mar
Mar
March
"
)
;
assert_eq
!
(
d
.
format
(
"
%
d
%
e
"
)
.
to_string
(
)
"
04
4
"
)
;
assert_eq
!
(
d
.
format
(
"
%
U
%
W
%
V
"
)
.
to_string
(
)
"
10
09
09
"
)
;
assert_eq
!
(
d
.
format
(
"
%
a
%
A
%
w
%
u
"
)
.
to_string
(
)
"
Sun
Sunday
0
7
"
)
;
assert_eq
!
(
d
.
format
(
"
%
j
"
)
.
to_string
(
)
"
064
"
)
;
assert_eq
!
(
d
.
format
(
"
%
D
%
x
"
)
.
to_string
(
)
"
03
/
04
/
12
03
/
04
/
12
"
)
;
assert_eq
!
(
d
.
format
(
"
%
F
"
)
.
to_string
(
)
"
2012
-
03
-
04
"
)
;
assert_eq
!
(
d
.
format
(
"
%
v
"
)
.
to_string
(
)
"
4
-
Mar
-
2012
"
)
;
assert_eq
!
(
d
.
format
(
"
%
t
%
n
%
%
%
n
%
t
"
)
.
to_string
(
)
"
\
t
\
n
%
\
n
\
t
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
12345
1
1
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
"
+
12345
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
1234
1
1
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
"
1234
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
123
1
1
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
"
0123
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
12
1
1
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
"
0012
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
1
1
1
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
"
0001
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
0
1
1
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
"
0000
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
-
1
1
1
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
"
-
0001
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
-
12
1
1
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
"
-
0012
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
-
123
1
1
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
"
-
0123
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
-
1234
1
1
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
"
-
1234
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
-
12345
1
1
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
"
-
12345
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
2007
12
31
)
.
format
(
"
%
G
%
g
%
U
%
W
%
V
"
)
.
to_string
(
)
"
2008
08
53
53
01
"
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd
(
2010
1
3
)
.
format
(
"
%
G
%
g
%
U
%
W
%
V
"
)
.
to_string
(
)
"
2009
09
01
00
53
"
)
;
}
}
