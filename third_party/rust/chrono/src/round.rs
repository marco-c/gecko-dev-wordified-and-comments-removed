use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
fmt
;
use
core
:
:
marker
:
:
Sized
;
use
core
:
:
ops
:
:
{
Add
Sub
}
;
use
datetime
:
:
DateTime
;
use
oldtime
:
:
Duration
;
#
[
cfg
(
any
(
feature
=
"
std
"
test
)
)
]
use
std
;
use
TimeZone
;
use
Timelike
;
pub
trait
SubsecRound
{
fn
round_subsecs
(
self
digits
:
u16
)
-
>
Self
;
fn
trunc_subsecs
(
self
digits
:
u16
)
-
>
Self
;
}
impl
<
T
>
SubsecRound
for
T
where
T
:
Timelike
+
Add
<
Duration
Output
=
T
>
+
Sub
<
Duration
Output
=
T
>
{
fn
round_subsecs
(
self
digits
:
u16
)
-
>
T
{
let
span
=
span_for_digits
(
digits
)
;
let
delta_down
=
self
.
nanosecond
(
)
%
span
;
if
delta_down
>
0
{
let
delta_up
=
span
-
delta_down
;
if
delta_up
<
=
delta_down
{
self
+
Duration
:
:
nanoseconds
(
delta_up
.
into
(
)
)
}
else
{
self
-
Duration
:
:
nanoseconds
(
delta_down
.
into
(
)
)
}
}
else
{
self
}
}
fn
trunc_subsecs
(
self
digits
:
u16
)
-
>
T
{
let
span
=
span_for_digits
(
digits
)
;
let
delta_down
=
self
.
nanosecond
(
)
%
span
;
if
delta_down
>
0
{
self
-
Duration
:
:
nanoseconds
(
delta_down
.
into
(
)
)
}
else
{
self
}
}
}
fn
span_for_digits
(
digits
:
u16
)
-
>
u32
{
match
digits
{
0
=
>
1_000_000_000
1
=
>
100_000_000
2
=
>
10_000_000
3
=
>
1_000_000
4
=
>
100_000
5
=
>
10_000
6
=
>
1_000
7
=
>
100
8
=
>
10
_
=
>
1
}
}
pub
trait
DurationRound
:
Sized
{
#
[
cfg
(
any
(
feature
=
"
std
"
test
)
)
]
type
Err
:
std
:
:
error
:
:
Error
;
#
[
cfg
(
not
(
any
(
feature
=
"
std
"
test
)
)
)
]
type
Err
:
fmt
:
:
Debug
+
fmt
:
:
Display
;
fn
duration_round
(
self
duration
:
Duration
)
-
>
Result
<
Self
Self
:
:
Err
>
;
fn
duration_trunc
(
self
duration
:
Duration
)
-
>
Result
<
Self
Self
:
:
Err
>
;
}
const
MAX_SECONDS_TIMESTAMP_FOR_NANOS
:
i64
=
9_223_372_036
;
impl
<
Tz
:
TimeZone
>
DurationRound
for
DateTime
<
Tz
>
{
type
Err
=
RoundingError
;
fn
duration_round
(
self
duration
:
Duration
)
-
>
Result
<
Self
Self
:
:
Err
>
{
if
let
Some
(
span
)
=
duration
.
num_nanoseconds
(
)
{
if
self
.
timestamp
(
)
.
abs
(
)
>
MAX_SECONDS_TIMESTAMP_FOR_NANOS
{
return
Err
(
RoundingError
:
:
TimestampExceedsLimit
)
;
}
let
stamp
=
self
.
timestamp_nanos
(
)
;
if
span
>
stamp
.
abs
(
)
{
return
Err
(
RoundingError
:
:
DurationExceedsTimestamp
)
;
}
let
delta_down
=
stamp
%
span
;
if
delta_down
=
=
0
{
Ok
(
self
)
}
else
{
let
(
delta_up
delta_down
)
=
if
delta_down
<
0
{
(
delta_down
.
abs
(
)
span
-
delta_down
.
abs
(
)
)
}
else
{
(
span
-
delta_down
delta_down
)
}
;
if
delta_up
<
=
delta_down
{
Ok
(
self
+
Duration
:
:
nanoseconds
(
delta_up
)
)
}
else
{
Ok
(
self
-
Duration
:
:
nanoseconds
(
delta_down
)
)
}
}
}
else
{
Err
(
RoundingError
:
:
DurationExceedsLimit
)
}
}
fn
duration_trunc
(
self
duration
:
Duration
)
-
>
Result
<
Self
Self
:
:
Err
>
{
if
let
Some
(
span
)
=
duration
.
num_nanoseconds
(
)
{
if
self
.
timestamp
(
)
.
abs
(
)
>
MAX_SECONDS_TIMESTAMP_FOR_NANOS
{
return
Err
(
RoundingError
:
:
TimestampExceedsLimit
)
;
}
let
stamp
=
self
.
timestamp_nanos
(
)
;
if
span
>
stamp
.
abs
(
)
{
return
Err
(
RoundingError
:
:
DurationExceedsTimestamp
)
;
}
let
delta_down
=
stamp
%
span
;
match
delta_down
.
cmp
(
&
0
)
{
Ordering
:
:
Equal
=
>
Ok
(
self
)
Ordering
:
:
Greater
=
>
Ok
(
self
-
Duration
:
:
nanoseconds
(
delta_down
)
)
Ordering
:
:
Less
=
>
Ok
(
self
-
Duration
:
:
nanoseconds
(
span
-
delta_down
.
abs
(
)
)
)
}
}
else
{
Err
(
RoundingError
:
:
DurationExceedsLimit
)
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Copy
)
]
pub
enum
RoundingError
{
DurationExceedsTimestamp
DurationExceedsLimit
TimestampExceedsLimit
}
impl
fmt
:
:
Display
for
RoundingError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
RoundingError
:
:
DurationExceedsTimestamp
=
>
{
write
!
(
f
"
duration
in
nanoseconds
exceeds
timestamp
"
)
}
RoundingError
:
:
DurationExceedsLimit
=
>
{
write
!
(
f
"
duration
exceeds
num_nanoseconds
limit
"
)
}
RoundingError
:
:
TimestampExceedsLimit
=
>
{
write
!
(
f
"
timestamp
exceeds
num_nanoseconds
limit
"
)
}
}
}
}
#
[
cfg
(
any
(
feature
=
"
std
"
test
)
)
]
impl
std
:
:
error
:
:
Error
for
RoundingError
{
#
[
allow
(
deprecated
)
]
fn
description
(
&
self
)
-
>
&
str
{
"
error
from
rounding
or
truncating
with
DurationRound
"
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
Duration
DurationRound
SubsecRound
}
;
use
offset
:
:
{
FixedOffset
TimeZone
Utc
}
;
use
Timelike
;
#
[
test
]
fn
test_round_subsecs
(
)
{
let
pst
=
FixedOffset
:
:
east
(
8
*
60
*
60
)
;
let
dt
=
pst
.
ymd
(
2018
1
11
)
.
and_hms_nano
(
10
5
13
084_660_684
)
;
assert_eq
!
(
dt
.
round_subsecs
(
10
)
dt
)
;
assert_eq
!
(
dt
.
round_subsecs
(
9
)
dt
)
;
assert_eq
!
(
dt
.
round_subsecs
(
8
)
.
nanosecond
(
)
084_660_680
)
;
assert_eq
!
(
dt
.
round_subsecs
(
7
)
.
nanosecond
(
)
084_660_700
)
;
assert_eq
!
(
dt
.
round_subsecs
(
6
)
.
nanosecond
(
)
084_661_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
5
)
.
nanosecond
(
)
084_660_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
4
)
.
nanosecond
(
)
084_700_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
3
)
.
nanosecond
(
)
085_000_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
2
)
.
nanosecond
(
)
080_000_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
1
)
.
nanosecond
(
)
100_000_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
0
)
.
nanosecond
(
)
0
)
;
assert_eq
!
(
dt
.
round_subsecs
(
0
)
.
second
(
)
13
)
;
let
dt
=
Utc
.
ymd
(
2018
1
11
)
.
and_hms_nano
(
10
5
27
750_500_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
9
)
dt
)
;
assert_eq
!
(
dt
.
round_subsecs
(
4
)
dt
)
;
assert_eq
!
(
dt
.
round_subsecs
(
3
)
.
nanosecond
(
)
751_000_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
2
)
.
nanosecond
(
)
750_000_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
1
)
.
nanosecond
(
)
800_000_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
0
)
.
nanosecond
(
)
0
)
;
assert_eq
!
(
dt
.
round_subsecs
(
0
)
.
second
(
)
28
)
;
}
#
[
test
]
fn
test_round_leap_nanos
(
)
{
let
dt
=
Utc
.
ymd
(
2016
12
31
)
.
and_hms_nano
(
23
59
59
1_750_500_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
9
)
dt
)
;
assert_eq
!
(
dt
.
round_subsecs
(
4
)
dt
)
;
assert_eq
!
(
dt
.
round_subsecs
(
2
)
.
nanosecond
(
)
1_750_000_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
1
)
.
nanosecond
(
)
1_800_000_000
)
;
assert_eq
!
(
dt
.
round_subsecs
(
1
)
.
second
(
)
59
)
;
assert_eq
!
(
dt
.
round_subsecs
(
0
)
.
nanosecond
(
)
0
)
;
assert_eq
!
(
dt
.
round_subsecs
(
0
)
.
second
(
)
0
)
;
}
#
[
test
]
fn
test_trunc_subsecs
(
)
{
let
pst
=
FixedOffset
:
:
east
(
8
*
60
*
60
)
;
let
dt
=
pst
.
ymd
(
2018
1
11
)
.
and_hms_nano
(
10
5
13
084_660_684
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
10
)
dt
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
9
)
dt
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
8
)
.
nanosecond
(
)
084_660_680
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
7
)
.
nanosecond
(
)
084_660_600
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
6
)
.
nanosecond
(
)
084_660_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
5
)
.
nanosecond
(
)
084_660_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
4
)
.
nanosecond
(
)
084_600_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
3
)
.
nanosecond
(
)
084_000_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
2
)
.
nanosecond
(
)
080_000_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
1
)
.
nanosecond
(
)
0
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
0
)
.
nanosecond
(
)
0
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
0
)
.
second
(
)
13
)
;
let
dt
=
pst
.
ymd
(
2018
1
11
)
.
and_hms_nano
(
10
5
27
750_500_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
9
)
dt
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
4
)
dt
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
3
)
.
nanosecond
(
)
750_000_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
2
)
.
nanosecond
(
)
750_000_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
1
)
.
nanosecond
(
)
700_000_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
0
)
.
nanosecond
(
)
0
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
0
)
.
second
(
)
27
)
;
}
#
[
test
]
fn
test_trunc_leap_nanos
(
)
{
let
dt
=
Utc
.
ymd
(
2016
12
31
)
.
and_hms_nano
(
23
59
59
1_750_500_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
9
)
dt
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
4
)
dt
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
2
)
.
nanosecond
(
)
1_750_000_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
1
)
.
nanosecond
(
)
1_700_000_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
1
)
.
second
(
)
59
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
0
)
.
nanosecond
(
)
1_000_000_000
)
;
assert_eq
!
(
dt
.
trunc_subsecs
(
0
)
.
second
(
)
59
)
;
}
#
[
test
]
fn
test_duration_round
(
)
{
let
dt
=
Utc
.
ymd
(
2016
12
31
)
.
and_hms_nano
(
23
59
59
175_500_000
)
;
assert_eq
!
(
dt
.
duration_round
(
Duration
:
:
milliseconds
(
10
)
)
.
unwrap
(
)
.
to_string
(
)
"
2016
-
12
-
31
23
:
59
:
59
.
180
UTC
"
)
;
let
dt
=
Utc
.
ymd
(
2012
12
12
)
.
and_hms_milli
(
18
22
30
0
)
;
assert_eq
!
(
dt
.
duration_round
(
Duration
:
:
minutes
(
5
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
12
18
:
25
:
00
UTC
"
)
;
let
dt
=
Utc
.
ymd
(
2012
12
12
)
.
and_hms_milli
(
18
22
29
999
)
;
assert_eq
!
(
dt
.
duration_round
(
Duration
:
:
minutes
(
5
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
12
18
:
20
:
00
UTC
"
)
;
assert_eq
!
(
dt
.
duration_round
(
Duration
:
:
minutes
(
10
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
12
18
:
20
:
00
UTC
"
)
;
assert_eq
!
(
dt
.
duration_round
(
Duration
:
:
minutes
(
30
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
12
18
:
30
:
00
UTC
"
)
;
assert_eq
!
(
dt
.
duration_round
(
Duration
:
:
hours
(
1
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
12
18
:
00
:
00
UTC
"
)
;
assert_eq
!
(
dt
.
duration_round
(
Duration
:
:
days
(
1
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
13
00
:
00
:
00
UTC
"
)
;
}
#
[
test
]
fn
test_duration_round_pre_epoch
(
)
{
let
dt
=
Utc
.
ymd
(
1969
12
12
)
.
and_hms
(
12
12
12
)
;
assert_eq
!
(
dt
.
duration_round
(
Duration
:
:
minutes
(
10
)
)
.
unwrap
(
)
.
to_string
(
)
"
1969
-
12
-
12
12
:
10
:
00
UTC
"
)
;
}
#
[
test
]
fn
test_duration_trunc
(
)
{
let
dt
=
Utc
.
ymd
(
2016
12
31
)
.
and_hms_nano
(
23
59
59
1_75_500_000
)
;
assert_eq
!
(
dt
.
duration_trunc
(
Duration
:
:
milliseconds
(
10
)
)
.
unwrap
(
)
.
to_string
(
)
"
2016
-
12
-
31
23
:
59
:
59
.
170
UTC
"
)
;
let
dt
=
Utc
.
ymd
(
2012
12
12
)
.
and_hms_milli
(
18
22
30
0
)
;
assert_eq
!
(
dt
.
duration_trunc
(
Duration
:
:
minutes
(
5
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
12
18
:
20
:
00
UTC
"
)
;
let
dt
=
Utc
.
ymd
(
2012
12
12
)
.
and_hms_milli
(
18
22
29
999
)
;
assert_eq
!
(
dt
.
duration_trunc
(
Duration
:
:
minutes
(
5
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
12
18
:
20
:
00
UTC
"
)
;
assert_eq
!
(
dt
.
duration_trunc
(
Duration
:
:
minutes
(
10
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
12
18
:
20
:
00
UTC
"
)
;
assert_eq
!
(
dt
.
duration_trunc
(
Duration
:
:
minutes
(
30
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
12
18
:
00
:
00
UTC
"
)
;
assert_eq
!
(
dt
.
duration_trunc
(
Duration
:
:
hours
(
1
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
12
18
:
00
:
00
UTC
"
)
;
assert_eq
!
(
dt
.
duration_trunc
(
Duration
:
:
days
(
1
)
)
.
unwrap
(
)
.
to_string
(
)
"
2012
-
12
-
12
00
:
00
:
00
UTC
"
)
;
}
#
[
test
]
fn
test_duration_trunc_pre_epoch
(
)
{
let
dt
=
Utc
.
ymd
(
1969
12
12
)
.
and_hms
(
12
12
12
)
;
assert_eq
!
(
dt
.
duration_trunc
(
Duration
:
:
minutes
(
10
)
)
.
unwrap
(
)
.
to_string
(
)
"
1969
-
12
-
12
12
:
10
:
00
UTC
"
)
;
}
}
