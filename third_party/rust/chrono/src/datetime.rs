use
core
:
:
{
str
fmt
hash
}
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
ops
:
:
{
Add
Sub
}
;
#
[
cfg
(
any
(
feature
=
"
std
"
test
)
)
]
use
std
:
:
time
:
:
{
SystemTime
UNIX_EPOCH
}
;
use
oldtime
:
:
Duration
as
OldDuration
;
#
[
cfg
(
all
(
not
(
feature
=
"
std
"
)
feature
=
"
alloc
"
)
)
]
use
alloc
:
:
string
:
:
{
String
ToString
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
string
:
:
ToString
;
use
{
Weekday
Timelike
Datelike
}
;
#
[
cfg
(
feature
=
"
clock
"
)
]
use
offset
:
:
Local
;
use
offset
:
:
{
TimeZone
Offset
Utc
FixedOffset
}
;
use
naive
:
:
{
NaiveTime
NaiveDateTime
IsoWeek
}
;
use
Date
;
use
format
:
:
{
Item
Numeric
Pad
Fixed
}
;
use
format
:
:
{
parse
Parsed
ParseError
ParseResult
StrftimeItems
}
;
#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
test
)
)
]
use
format
:
:
DelayedFormat
;
use
core
:
:
borrow
:
:
Borrow
;
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
SecondsFormat
{
Secs
Millis
Micros
Nanos
AutoSi
#
[
doc
(
hidden
)
]
__NonExhaustive
}
#
[
derive
(
Clone
)
]
pub
struct
DateTime
<
Tz
:
TimeZone
>
{
datetime
:
NaiveDateTime
offset
:
Tz
:
:
Offset
}
impl
<
Tz
:
TimeZone
>
DateTime
<
Tz
>
{
#
[
inline
]
pub
fn
from_utc
(
datetime
:
NaiveDateTime
offset
:
Tz
:
:
Offset
)
-
>
DateTime
<
Tz
>
{
DateTime
{
datetime
:
datetime
offset
:
offset
}
}
#
[
inline
]
pub
fn
date
(
&
self
)
-
>
Date
<
Tz
>
{
Date
:
:
from_utc
(
self
.
naive_local
(
)
.
date
(
)
self
.
offset
.
clone
(
)
)
}
#
[
inline
]
pub
fn
time
(
&
self
)
-
>
NaiveTime
{
self
.
datetime
.
time
(
)
+
self
.
offset
.
fix
(
)
}
#
[
inline
]
pub
fn
timestamp
(
&
self
)
-
>
i64
{
self
.
datetime
.
timestamp
(
)
}
#
[
inline
]
pub
fn
timestamp_millis
(
&
self
)
-
>
i64
{
self
.
datetime
.
timestamp_millis
(
)
}
#
[
inline
]
pub
fn
timestamp_nanos
(
&
self
)
-
>
i64
{
self
.
datetime
.
timestamp_nanos
(
)
}
#
[
inline
]
pub
fn
timestamp_subsec_millis
(
&
self
)
-
>
u32
{
self
.
datetime
.
timestamp_subsec_millis
(
)
}
#
[
inline
]
pub
fn
timestamp_subsec_micros
(
&
self
)
-
>
u32
{
self
.
datetime
.
timestamp_subsec_micros
(
)
}
#
[
inline
]
pub
fn
timestamp_subsec_nanos
(
&
self
)
-
>
u32
{
self
.
datetime
.
timestamp_subsec_nanos
(
)
}
#
[
inline
]
pub
fn
offset
(
&
self
)
-
>
&
Tz
:
:
Offset
{
&
self
.
offset
}
#
[
inline
]
pub
fn
timezone
(
&
self
)
-
>
Tz
{
TimeZone
:
:
from_offset
(
&
self
.
offset
)
}
#
[
inline
]
pub
fn
with_timezone
<
Tz2
:
TimeZone
>
(
&
self
tz
:
&
Tz2
)
-
>
DateTime
<
Tz2
>
{
tz
.
from_utc_datetime
(
&
self
.
datetime
)
}
#
[
inline
]
pub
fn
checked_add_signed
(
self
rhs
:
OldDuration
)
-
>
Option
<
DateTime
<
Tz
>
>
{
let
datetime
=
try_opt
!
(
self
.
datetime
.
checked_add_signed
(
rhs
)
)
;
let
tz
=
self
.
timezone
(
)
;
Some
(
tz
.
from_utc_datetime
(
&
datetime
)
)
}
#
[
inline
]
pub
fn
checked_sub_signed
(
self
rhs
:
OldDuration
)
-
>
Option
<
DateTime
<
Tz
>
>
{
let
datetime
=
try_opt
!
(
self
.
datetime
.
checked_sub_signed
(
rhs
)
)
;
let
tz
=
self
.
timezone
(
)
;
Some
(
tz
.
from_utc_datetime
(
&
datetime
)
)
}
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
needless_pass_by_value
)
)
]
#
[
inline
]
pub
fn
signed_duration_since
<
Tz2
:
TimeZone
>
(
self
rhs
:
DateTime
<
Tz2
>
)
-
>
OldDuration
{
self
.
datetime
.
signed_duration_since
(
rhs
.
datetime
)
}
#
[
inline
]
pub
fn
naive_utc
(
&
self
)
-
>
NaiveDateTime
{
self
.
datetime
}
#
[
inline
]
pub
fn
naive_local
(
&
self
)
-
>
NaiveDateTime
{
self
.
datetime
+
self
.
offset
.
fix
(
)
}
}
impl
From
<
DateTime
<
Utc
>
>
for
DateTime
<
FixedOffset
>
{
fn
from
(
src
:
DateTime
<
Utc
>
)
-
>
Self
{
src
.
with_timezone
(
&
FixedOffset
:
:
east
(
0
)
)
}
}
#
[
cfg
(
feature
=
"
clock
"
)
]
impl
From
<
DateTime
<
Utc
>
>
for
DateTime
<
Local
>
{
fn
from
(
src
:
DateTime
<
Utc
>
)
-
>
Self
{
src
.
with_timezone
(
&
Local
)
}
}
impl
From
<
DateTime
<
FixedOffset
>
>
for
DateTime
<
Utc
>
{
fn
from
(
src
:
DateTime
<
FixedOffset
>
)
-
>
Self
{
src
.
with_timezone
(
&
Utc
)
}
}
#
[
cfg
(
feature
=
"
clock
"
)
]
impl
From
<
DateTime
<
FixedOffset
>
>
for
DateTime
<
Local
>
{
fn
from
(
src
:
DateTime
<
FixedOffset
>
)
-
>
Self
{
src
.
with_timezone
(
&
Local
)
}
}
#
[
cfg
(
feature
=
"
clock
"
)
]
impl
From
<
DateTime
<
Local
>
>
for
DateTime
<
Utc
>
{
fn
from
(
src
:
DateTime
<
Local
>
)
-
>
Self
{
src
.
with_timezone
(
&
Utc
)
}
}
#
[
cfg
(
feature
=
"
clock
"
)
]
impl
From
<
DateTime
<
Local
>
>
for
DateTime
<
FixedOffset
>
{
fn
from
(
src
:
DateTime
<
Local
>
)
-
>
Self
{
src
.
with_timezone
(
&
FixedOffset
:
:
east
(
0
)
)
}
}
fn
map_local
<
Tz
:
TimeZone
F
>
(
dt
:
&
DateTime
<
Tz
>
mut
f
:
F
)
-
>
Option
<
DateTime
<
Tz
>
>
where
F
:
FnMut
(
NaiveDateTime
)
-
>
Option
<
NaiveDateTime
>
{
f
(
dt
.
naive_local
(
)
)
.
and_then
(
|
datetime
|
dt
.
timezone
(
)
.
from_local_datetime
(
&
datetime
)
.
single
(
)
)
}
impl
DateTime
<
FixedOffset
>
{
pub
fn
parse_from_rfc2822
(
s
:
&
str
)
-
>
ParseResult
<
DateTime
<
FixedOffset
>
>
{
const
ITEMS
:
&
'
static
[
Item
<
'
static
>
]
=
&
[
Item
:
:
Fixed
(
Fixed
:
:
RFC2822
)
]
;
let
mut
parsed
=
Parsed
:
:
new
(
)
;
parse
(
&
mut
parsed
s
ITEMS
.
iter
(
)
)
?
;
parsed
.
to_datetime
(
)
}
pub
fn
parse_from_rfc3339
(
s
:
&
str
)
-
>
ParseResult
<
DateTime
<
FixedOffset
>
>
{
const
ITEMS
:
&
'
static
[
Item
<
'
static
>
]
=
&
[
Item
:
:
Fixed
(
Fixed
:
:
RFC3339
)
]
;
let
mut
parsed
=
Parsed
:
:
new
(
)
;
parse
(
&
mut
parsed
s
ITEMS
.
iter
(
)
)
?
;
parsed
.
to_datetime
(
)
}
pub
fn
parse_from_str
(
s
:
&
str
fmt
:
&
str
)
-
>
ParseResult
<
DateTime
<
FixedOffset
>
>
{
let
mut
parsed
=
Parsed
:
:
new
(
)
;
parse
(
&
mut
parsed
s
StrftimeItems
:
:
new
(
fmt
)
)
?
;
parsed
.
to_datetime
(
)
}
}
impl
<
Tz
:
TimeZone
>
DateTime
<
Tz
>
where
Tz
:
:
Offset
:
fmt
:
:
Display
{
#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
test
)
)
]
pub
fn
to_rfc2822
(
&
self
)
-
>
String
{
const
ITEMS
:
&
'
static
[
Item
<
'
static
>
]
=
&
[
Item
:
:
Fixed
(
Fixed
:
:
RFC2822
)
]
;
self
.
format_with_items
(
ITEMS
.
iter
(
)
)
.
to_string
(
)
}
#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
test
)
)
]
pub
fn
to_rfc3339
(
&
self
)
-
>
String
{
const
ITEMS
:
&
'
static
[
Item
<
'
static
>
]
=
&
[
Item
:
:
Fixed
(
Fixed
:
:
RFC3339
)
]
;
self
.
format_with_items
(
ITEMS
.
iter
(
)
)
.
to_string
(
)
}
#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
test
)
)
]
pub
fn
to_rfc3339_opts
(
&
self
secform
:
SecondsFormat
use_z
:
bool
)
-
>
String
{
use
format
:
:
Numeric
:
:
*
;
use
format
:
:
Pad
:
:
Zero
;
use
SecondsFormat
:
:
*
;
debug_assert
!
(
secform
!
=
__NonExhaustive
"
Do
not
use
__NonExhaustive
!
"
)
;
const
PREFIX
:
&
'
static
[
Item
<
'
static
>
]
=
&
[
Item
:
:
Numeric
(
Year
Zero
)
Item
:
:
Literal
(
"
-
"
)
Item
:
:
Numeric
(
Month
Zero
)
Item
:
:
Literal
(
"
-
"
)
Item
:
:
Numeric
(
Day
Zero
)
Item
:
:
Literal
(
"
T
"
)
Item
:
:
Numeric
(
Hour
Zero
)
Item
:
:
Literal
(
"
:
"
)
Item
:
:
Numeric
(
Minute
Zero
)
Item
:
:
Literal
(
"
:
"
)
Item
:
:
Numeric
(
Second
Zero
)
]
;
let
ssitem
=
match
secform
{
Secs
=
>
None
Millis
=
>
Some
(
Item
:
:
Fixed
(
Fixed
:
:
Nanosecond3
)
)
Micros
=
>
Some
(
Item
:
:
Fixed
(
Fixed
:
:
Nanosecond6
)
)
Nanos
=
>
Some
(
Item
:
:
Fixed
(
Fixed
:
:
Nanosecond9
)
)
AutoSi
=
>
Some
(
Item
:
:
Fixed
(
Fixed
:
:
Nanosecond
)
)
__NonExhaustive
=
>
unreachable
!
(
)
}
;
let
tzitem
=
Item
:
:
Fixed
(
if
use_z
{
Fixed
:
:
TimezoneOffsetColonZ
}
else
{
Fixed
:
:
TimezoneOffsetColon
}
)
;
match
ssitem
{
None
=
>
self
.
format_with_items
(
PREFIX
.
iter
(
)
.
chain
(
[
tzitem
]
.
iter
(
)
)
)
.
to_string
(
)
Some
(
s
)
=
>
self
.
format_with_items
(
PREFIX
.
iter
(
)
.
chain
(
[
s
tzitem
]
.
iter
(
)
)
)
.
to_string
(
)
}
}
#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
test
)
)
]
#
[
inline
]
pub
fn
format_with_items
<
'
a
I
B
>
(
&
self
items
:
I
)
-
>
DelayedFormat
<
I
>
where
I
:
Iterator
<
Item
=
B
>
+
Clone
B
:
Borrow
<
Item
<
'
a
>
>
{
let
local
=
self
.
naive_local
(
)
;
DelayedFormat
:
:
new_with_offset
(
Some
(
local
.
date
(
)
)
Some
(
local
.
time
(
)
)
&
self
.
offset
items
)
}
#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
test
)
)
]
#
[
inline
]
pub
fn
format
<
'
a
>
(
&
self
fmt
:
&
'
a
str
)
-
>
DelayedFormat
<
StrftimeItems
<
'
a
>
>
{
self
.
format_with_items
(
StrftimeItems
:
:
new
(
fmt
)
)
}
}
impl
<
Tz
:
TimeZone
>
Datelike
for
DateTime
<
Tz
>
{
#
[
inline
]
fn
year
(
&
self
)
-
>
i32
{
self
.
naive_local
(
)
.
year
(
)
}
#
[
inline
]
fn
month
(
&
self
)
-
>
u32
{
self
.
naive_local
(
)
.
month
(
)
}
#
[
inline
]
fn
month0
(
&
self
)
-
>
u32
{
self
.
naive_local
(
)
.
month0
(
)
}
#
[
inline
]
fn
day
(
&
self
)
-
>
u32
{
self
.
naive_local
(
)
.
day
(
)
}
#
[
inline
]
fn
day0
(
&
self
)
-
>
u32
{
self
.
naive_local
(
)
.
day0
(
)
}
#
[
inline
]
fn
ordinal
(
&
self
)
-
>
u32
{
self
.
naive_local
(
)
.
ordinal
(
)
}
#
[
inline
]
fn
ordinal0
(
&
self
)
-
>
u32
{
self
.
naive_local
(
)
.
ordinal0
(
)
}
#
[
inline
]
fn
weekday
(
&
self
)
-
>
Weekday
{
self
.
naive_local
(
)
.
weekday
(
)
}
#
[
inline
]
fn
iso_week
(
&
self
)
-
>
IsoWeek
{
self
.
naive_local
(
)
.
iso_week
(
)
}
#
[
inline
]
fn
with_year
(
&
self
year
:
i32
)
-
>
Option
<
DateTime
<
Tz
>
>
{
map_local
(
self
|
datetime
|
datetime
.
with_year
(
year
)
)
}
#
[
inline
]
fn
with_month
(
&
self
month
:
u32
)
-
>
Option
<
DateTime
<
Tz
>
>
{
map_local
(
self
|
datetime
|
datetime
.
with_month
(
month
)
)
}
#
[
inline
]
fn
with_month0
(
&
self
month0
:
u32
)
-
>
Option
<
DateTime
<
Tz
>
>
{
map_local
(
self
|
datetime
|
datetime
.
with_month0
(
month0
)
)
}
#
[
inline
]
fn
with_day
(
&
self
day
:
u32
)
-
>
Option
<
DateTime
<
Tz
>
>
{
map_local
(
self
|
datetime
|
datetime
.
with_day
(
day
)
)
}
#
[
inline
]
fn
with_day0
(
&
self
day0
:
u32
)
-
>
Option
<
DateTime
<
Tz
>
>
{
map_local
(
self
|
datetime
|
datetime
.
with_day0
(
day0
)
)
}
#
[
inline
]
fn
with_ordinal
(
&
self
ordinal
:
u32
)
-
>
Option
<
DateTime
<
Tz
>
>
{
map_local
(
self
|
datetime
|
datetime
.
with_ordinal
(
ordinal
)
)
}
#
[
inline
]
fn
with_ordinal0
(
&
self
ordinal0
:
u32
)
-
>
Option
<
DateTime
<
Tz
>
>
{
map_local
(
self
|
datetime
|
datetime
.
with_ordinal0
(
ordinal0
)
)
}
}
impl
<
Tz
:
TimeZone
>
Timelike
for
DateTime
<
Tz
>
{
#
[
inline
]
fn
hour
(
&
self
)
-
>
u32
{
self
.
naive_local
(
)
.
hour
(
)
}
#
[
inline
]
fn
minute
(
&
self
)
-
>
u32
{
self
.
naive_local
(
)
.
minute
(
)
}
#
[
inline
]
fn
second
(
&
self
)
-
>
u32
{
self
.
naive_local
(
)
.
second
(
)
}
#
[
inline
]
fn
nanosecond
(
&
self
)
-
>
u32
{
self
.
naive_local
(
)
.
nanosecond
(
)
}
#
[
inline
]
fn
with_hour
(
&
self
hour
:
u32
)
-
>
Option
<
DateTime
<
Tz
>
>
{
map_local
(
self
|
datetime
|
datetime
.
with_hour
(
hour
)
)
}
#
[
inline
]
fn
with_minute
(
&
self
min
:
u32
)
-
>
Option
<
DateTime
<
Tz
>
>
{
map_local
(
self
|
datetime
|
datetime
.
with_minute
(
min
)
)
}
#
[
inline
]
fn
with_second
(
&
self
sec
:
u32
)
-
>
Option
<
DateTime
<
Tz
>
>
{
map_local
(
self
|
datetime
|
datetime
.
with_second
(
sec
)
)
}
#
[
inline
]
fn
with_nanosecond
(
&
self
nano
:
u32
)
-
>
Option
<
DateTime
<
Tz
>
>
{
map_local
(
self
|
datetime
|
datetime
.
with_nanosecond
(
nano
)
)
}
}
impl
<
Tz
:
TimeZone
>
Copy
for
DateTime
<
Tz
>
where
<
Tz
as
TimeZone
>
:
:
Offset
:
Copy
{
}
unsafe
impl
<
Tz
:
TimeZone
>
Send
for
DateTime
<
Tz
>
where
<
Tz
as
TimeZone
>
:
:
Offset
:
Send
{
}
impl
<
Tz
:
TimeZone
Tz2
:
TimeZone
>
PartialEq
<
DateTime
<
Tz2
>
>
for
DateTime
<
Tz
>
{
fn
eq
(
&
self
other
:
&
DateTime
<
Tz2
>
)
-
>
bool
{
self
.
datetime
=
=
other
.
datetime
}
}
impl
<
Tz
:
TimeZone
>
Eq
for
DateTime
<
Tz
>
{
}
impl
<
Tz
:
TimeZone
>
PartialOrd
for
DateTime
<
Tz
>
{
fn
partial_cmp
(
&
self
other
:
&
DateTime
<
Tz
>
)
-
>
Option
<
Ordering
>
{
self
.
datetime
.
partial_cmp
(
&
other
.
datetime
)
}
}
impl
<
Tz
:
TimeZone
>
Ord
for
DateTime
<
Tz
>
{
fn
cmp
(
&
self
other
:
&
DateTime
<
Tz
>
)
-
>
Ordering
{
self
.
datetime
.
cmp
(
&
other
.
datetime
)
}
}
impl
<
Tz
:
TimeZone
>
hash
:
:
Hash
for
DateTime
<
Tz
>
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
datetime
.
hash
(
state
)
}
}
impl
<
Tz
:
TimeZone
>
Add
<
OldDuration
>
for
DateTime
<
Tz
>
{
type
Output
=
DateTime
<
Tz
>
;
#
[
inline
]
fn
add
(
self
rhs
:
OldDuration
)
-
>
DateTime
<
Tz
>
{
self
.
checked_add_signed
(
rhs
)
.
expect
(
"
DateTime
+
Duration
overflowed
"
)
}
}
impl
<
Tz
:
TimeZone
>
Sub
<
OldDuration
>
for
DateTime
<
Tz
>
{
type
Output
=
DateTime
<
Tz
>
;
#
[
inline
]
fn
sub
(
self
rhs
:
OldDuration
)
-
>
DateTime
<
Tz
>
{
self
.
checked_sub_signed
(
rhs
)
.
expect
(
"
DateTime
-
Duration
overflowed
"
)
}
}
impl
<
Tz
:
TimeZone
>
Sub
<
DateTime
<
Tz
>
>
for
DateTime
<
Tz
>
{
type
Output
=
OldDuration
;
#
[
inline
]
fn
sub
(
self
rhs
:
DateTime
<
Tz
>
)
-
>
OldDuration
{
self
.
signed_duration_since
(
rhs
)
}
}
impl
<
Tz
:
TimeZone
>
fmt
:
:
Debug
for
DateTime
<
Tz
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
{
:
?
}
"
self
.
naive_local
(
)
self
.
offset
)
}
}
impl
<
Tz
:
TimeZone
>
fmt
:
:
Display
for
DateTime
<
Tz
>
where
Tz
:
:
Offset
:
fmt
:
:
Display
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
{
}
"
self
.
naive_local
(
)
self
.
offset
)
}
}
impl
str
:
:
FromStr
for
DateTime
<
FixedOffset
>
{
type
Err
=
ParseError
;
fn
from_str
(
s
:
&
str
)
-
>
ParseResult
<
DateTime
<
FixedOffset
>
>
{
const
ITEMS
:
&
'
static
[
Item
<
'
static
>
]
=
&
[
Item
:
:
Numeric
(
Numeric
:
:
Year
Pad
:
:
Zero
)
Item
:
:
Space
(
"
"
)
Item
:
:
Literal
(
"
-
"
)
Item
:
:
Numeric
(
Numeric
:
:
Month
Pad
:
:
Zero
)
Item
:
:
Space
(
"
"
)
Item
:
:
Literal
(
"
-
"
)
Item
:
:
Numeric
(
Numeric
:
:
Day
Pad
:
:
Zero
)
Item
:
:
Space
(
"
"
)
Item
:
:
Literal
(
"
T
"
)
Item
:
:
Numeric
(
Numeric
:
:
Hour
Pad
:
:
Zero
)
Item
:
:
Space
(
"
"
)
Item
:
:
Literal
(
"
:
"
)
Item
:
:
Numeric
(
Numeric
:
:
Minute
Pad
:
:
Zero
)
Item
:
:
Space
(
"
"
)
Item
:
:
Literal
(
"
:
"
)
Item
:
:
Numeric
(
Numeric
:
:
Second
Pad
:
:
Zero
)
Item
:
:
Fixed
(
Fixed
:
:
Nanosecond
)
Item
:
:
Space
(
"
"
)
Item
:
:
Fixed
(
Fixed
:
:
TimezoneOffsetZ
)
Item
:
:
Space
(
"
"
)
]
;
let
mut
parsed
=
Parsed
:
:
new
(
)
;
parse
(
&
mut
parsed
s
ITEMS
.
iter
(
)
)
?
;
parsed
.
to_datetime
(
)
}
}
impl
str
:
:
FromStr
for
DateTime
<
Utc
>
{
type
Err
=
ParseError
;
fn
from_str
(
s
:
&
str
)
-
>
ParseResult
<
DateTime
<
Utc
>
>
{
s
.
parse
:
:
<
DateTime
<
FixedOffset
>
>
(
)
.
map
(
|
dt
|
dt
.
with_timezone
(
&
Utc
)
)
}
}
#
[
cfg
(
feature
=
"
clock
"
)
]
impl
str
:
:
FromStr
for
DateTime
<
Local
>
{
type
Err
=
ParseError
;
fn
from_str
(
s
:
&
str
)
-
>
ParseResult
<
DateTime
<
Local
>
>
{
s
.
parse
:
:
<
DateTime
<
FixedOffset
>
>
(
)
.
map
(
|
dt
|
dt
.
with_timezone
(
&
Local
)
)
}
}
#
[
cfg
(
any
(
feature
=
"
std
"
test
)
)
]
impl
From
<
SystemTime
>
for
DateTime
<
Utc
>
{
fn
from
(
t
:
SystemTime
)
-
>
DateTime
<
Utc
>
{
let
(
sec
nsec
)
=
match
t
.
duration_since
(
UNIX_EPOCH
)
{
Ok
(
dur
)
=
>
(
dur
.
as_secs
(
)
as
i64
dur
.
subsec_nanos
(
)
)
Err
(
e
)
=
>
{
let
dur
=
e
.
duration
(
)
;
let
(
sec
nsec
)
=
(
dur
.
as_secs
(
)
as
i64
dur
.
subsec_nanos
(
)
)
;
if
nsec
=
=
0
{
(
-
sec
0
)
}
else
{
(
-
sec
-
1
1_000_000_000
-
nsec
)
}
}
}
;
Utc
.
timestamp
(
sec
nsec
)
}
}
#
[
cfg
(
feature
=
"
clock
"
)
]
impl
From
<
SystemTime
>
for
DateTime
<
Local
>
{
fn
from
(
t
:
SystemTime
)
-
>
DateTime
<
Local
>
{
DateTime
:
:
<
Utc
>
:
:
from
(
t
)
.
with_timezone
(
&
Local
)
}
}
#
[
cfg
(
any
(
feature
=
"
std
"
test
)
)
]
impl
<
Tz
:
TimeZone
>
From
<
DateTime
<
Tz
>
>
for
SystemTime
{
fn
from
(
dt
:
DateTime
<
Tz
>
)
-
>
SystemTime
{
use
std
:
:
time
:
:
Duration
;
let
sec
=
dt
.
timestamp
(
)
;
let
nsec
=
dt
.
timestamp_subsec_nanos
(
)
;
if
sec
<
0
{
UNIX_EPOCH
-
Duration
:
:
new
(
-
sec
as
u64
0
)
+
Duration
:
:
new
(
0
nsec
)
}
else
{
UNIX_EPOCH
+
Duration
:
:
new
(
sec
as
u64
nsec
)
}
}
}
#
[
test
]
fn
test_auto_conversion
(
)
{
let
utc_dt
=
Utc
.
ymd
(
2018
9
5
)
.
and_hms
(
23
58
0
)
;
let
cdt_dt
=
FixedOffset
:
:
west
(
5
*
60
*
60
)
.
ymd
(
2018
9
5
)
.
and_hms
(
18
58
0
)
;
let
utc_dt2
:
DateTime
<
Utc
>
=
cdt_dt
.
into
(
)
;
assert_eq
!
(
utc_dt
utc_dt2
)
;
}
#
[
cfg
(
all
(
test
any
(
feature
=
"
rustc
-
serialize
"
feature
=
"
serde
"
)
)
)
]
fn
test_encodable_json
<
FUtc
FFixed
E
>
(
to_string_utc
:
FUtc
to_string_fixed
:
FFixed
)
where
FUtc
:
Fn
(
&
DateTime
<
Utc
>
)
-
>
Result
<
String
E
>
FFixed
:
Fn
(
&
DateTime
<
FixedOffset
>
)
-
>
Result
<
String
E
>
E
:
:
:
core
:
:
fmt
:
:
Debug
{
assert_eq
!
(
to_string_utc
(
&
Utc
.
ymd
(
2014
7
24
)
.
and_hms
(
12
34
6
)
)
.
ok
(
)
Some
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06Z
"
"
#
.
into
(
)
)
)
;
assert_eq
!
(
to_string_fixed
(
&
FixedOffset
:
:
east
(
3660
)
.
ymd
(
2014
7
24
)
.
and_hms
(
12
34
6
)
)
.
ok
(
)
Some
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06
+
01
:
01
"
"
#
.
into
(
)
)
)
;
assert_eq
!
(
to_string_fixed
(
&
FixedOffset
:
:
east
(
3650
)
.
ymd
(
2014
7
24
)
.
and_hms
(
12
34
6
)
)
.
ok
(
)
Some
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06
+
01
:
00
:
50
"
"
#
.
into
(
)
)
)
;
}
#
[
cfg
(
all
(
test
feature
=
"
clock
"
any
(
feature
=
"
rustc
-
serialize
"
feature
=
"
serde
"
)
)
)
]
fn
test_decodable_json
<
FUtc
FFixed
FLocal
E
>
(
utc_from_str
:
FUtc
fixed_from_str
:
FFixed
local_from_str
:
FLocal
)
where
FUtc
:
Fn
(
&
str
)
-
>
Result
<
DateTime
<
Utc
>
E
>
FFixed
:
Fn
(
&
str
)
-
>
Result
<
DateTime
<
FixedOffset
>
E
>
FLocal
:
Fn
(
&
str
)
-
>
Result
<
DateTime
<
Local
>
E
>
E
:
:
:
core
:
:
fmt
:
:
Debug
{
fn
norm
<
Tz
:
TimeZone
>
(
dt
:
&
Option
<
DateTime
<
Tz
>
>
)
-
>
Option
<
(
&
DateTime
<
Tz
>
&
Tz
:
:
Offset
)
>
{
dt
.
as_ref
(
)
.
map
(
|
dt
|
(
dt
dt
.
offset
(
)
)
)
}
assert_eq
!
(
norm
(
&
utc_from_str
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06Z
"
"
#
)
.
ok
(
)
)
norm
(
&
Some
(
Utc
.
ymd
(
2014
7
24
)
.
and_hms
(
12
34
6
)
)
)
)
;
assert_eq
!
(
norm
(
&
utc_from_str
(
r
#
"
"
2014
-
07
-
24T13
:
57
:
06
+
01
:
23
"
"
#
)
.
ok
(
)
)
norm
(
&
Some
(
Utc
.
ymd
(
2014
7
24
)
.
and_hms
(
12
34
6
)
)
)
)
;
assert_eq
!
(
norm
(
&
fixed_from_str
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06Z
"
"
#
)
.
ok
(
)
)
norm
(
&
Some
(
FixedOffset
:
:
east
(
0
)
.
ymd
(
2014
7
24
)
.
and_hms
(
12
34
6
)
)
)
)
;
assert_eq
!
(
norm
(
&
fixed_from_str
(
r
#
"
"
2014
-
07
-
24T13
:
57
:
06
+
01
:
23
"
"
#
)
.
ok
(
)
)
norm
(
&
Some
(
FixedOffset
:
:
east
(
60
*
60
+
23
*
60
)
.
ymd
(
2014
7
24
)
.
and_hms
(
13
57
6
)
)
)
)
;
assert_eq
!
(
local_from_str
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06Z
"
"
#
)
.
expect
(
"
local
shouuld
parse
"
)
Utc
.
ymd
(
2014
7
24
)
.
and_hms
(
12
34
6
)
)
;
assert_eq
!
(
local_from_str
(
r
#
"
"
2014
-
07
-
24T13
:
57
:
06
+
01
:
23
"
"
#
)
.
expect
(
"
local
should
parse
with
offset
"
)
Utc
.
ymd
(
2014
7
24
)
.
and_hms
(
12
34
6
)
)
;
assert
!
(
utc_from_str
(
r
#
"
"
2014
-
07
-
32T12
:
34
:
06Z
"
"
#
)
.
is_err
(
)
)
;
assert
!
(
fixed_from_str
(
r
#
"
"
2014
-
07
-
32T12
:
34
:
06Z
"
"
#
)
.
is_err
(
)
)
;
}
#
[
cfg
(
all
(
test
feature
=
"
clock
"
feature
=
"
rustc
-
serialize
"
)
)
]
fn
test_decodable_json_timestamps
<
FUtc
FFixed
FLocal
E
>
(
utc_from_str
:
FUtc
fixed_from_str
:
FFixed
local_from_str
:
FLocal
)
where
FUtc
:
Fn
(
&
str
)
-
>
Result
<
rustc_serialize
:
:
TsSeconds
<
Utc
>
E
>
FFixed
:
Fn
(
&
str
)
-
>
Result
<
rustc_serialize
:
:
TsSeconds
<
FixedOffset
>
E
>
FLocal
:
Fn
(
&
str
)
-
>
Result
<
rustc_serialize
:
:
TsSeconds
<
Local
>
E
>
E
:
:
:
core
:
:
fmt
:
:
Debug
{
fn
norm
<
Tz
:
TimeZone
>
(
dt
:
&
Option
<
DateTime
<
Tz
>
>
)
-
>
Option
<
(
&
DateTime
<
Tz
>
&
Tz
:
:
Offset
)
>
{
dt
.
as_ref
(
)
.
map
(
|
dt
|
(
dt
dt
.
offset
(
)
)
)
}
assert_eq
!
(
norm
(
&
utc_from_str
(
"
0
"
)
.
ok
(
)
.
map
(
DateTime
:
:
from
)
)
norm
(
&
Some
(
Utc
.
ymd
(
1970
1
1
)
.
and_hms
(
0
0
0
)
)
)
)
;
assert_eq
!
(
norm
(
&
utc_from_str
(
"
-
1
"
)
.
ok
(
)
.
map
(
DateTime
:
:
from
)
)
norm
(
&
Some
(
Utc
.
ymd
(
1969
12
31
)
.
and_hms
(
23
59
59
)
)
)
)
;
assert_eq
!
(
norm
(
&
fixed_from_str
(
"
0
"
)
.
ok
(
)
.
map
(
DateTime
:
:
from
)
)
norm
(
&
Some
(
FixedOffset
:
:
east
(
0
)
.
ymd
(
1970
1
1
)
.
and_hms
(
0
0
0
)
)
)
)
;
assert_eq
!
(
norm
(
&
fixed_from_str
(
"
-
1
"
)
.
ok
(
)
.
map
(
DateTime
:
:
from
)
)
norm
(
&
Some
(
FixedOffset
:
:
east
(
0
)
.
ymd
(
1969
12
31
)
.
and_hms
(
23
59
59
)
)
)
)
;
assert_eq
!
(
*
fixed_from_str
(
"
0
"
)
.
expect
(
"
0
timestamp
should
parse
"
)
Utc
.
ymd
(
1970
1
1
)
.
and_hms
(
0
0
0
)
)
;
assert_eq
!
(
*
local_from_str
(
"
-
1
"
)
.
expect
(
"
-
1
timestamp
should
parse
"
)
Utc
.
ymd
(
1969
12
31
)
.
and_hms
(
23
59
59
)
)
;
}
#
[
cfg
(
feature
=
"
rustc
-
serialize
"
)
]
pub
mod
rustc_serialize
{
use
core
:
:
fmt
;
use
core
:
:
ops
:
:
Deref
;
use
super
:
:
DateTime
;
#
[
cfg
(
feature
=
"
clock
"
)
]
use
offset
:
:
Local
;
use
offset
:
:
{
TimeZone
LocalResult
Utc
FixedOffset
}
;
use
rustc_serialize
:
:
{
Encodable
Encoder
Decodable
Decoder
}
;
impl
<
Tz
:
TimeZone
>
Encodable
for
DateTime
<
Tz
>
{
fn
encode
<
S
:
Encoder
>
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
format
!
(
"
{
:
?
}
"
self
)
.
encode
(
s
)
}
}
fn
from
<
T
D
>
(
me
:
LocalResult
<
T
>
d
:
&
mut
D
)
-
>
Result
<
T
D
:
:
Error
>
where
D
:
Decoder
T
:
fmt
:
:
Display
{
match
me
{
LocalResult
:
:
None
=
>
Err
(
d
.
error
(
"
value
is
not
a
legal
timestamp
"
)
)
LocalResult
:
:
Ambiguous
(
.
.
)
=
>
Err
(
d
.
error
(
"
value
is
an
ambiguous
timestamp
"
)
)
LocalResult
:
:
Single
(
val
)
=
>
Ok
(
val
)
}
}
impl
Decodable
for
DateTime
<
FixedOffset
>
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
DateTime
<
FixedOffset
>
D
:
:
Error
>
{
d
.
read_str
(
)
?
.
parse
:
:
<
DateTime
<
FixedOffset
>
>
(
)
.
map_err
(
|
_
|
d
.
error
(
"
invalid
date
and
time
"
)
)
}
}
#
[
allow
(
deprecated
)
]
impl
Decodable
for
TsSeconds
<
FixedOffset
>
{
#
[
allow
(
deprecated
)
]
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
TsSeconds
<
FixedOffset
>
D
:
:
Error
>
{
from
(
FixedOffset
:
:
east
(
0
)
.
timestamp_opt
(
d
.
read_i64
(
)
?
0
)
d
)
.
map
(
TsSeconds
)
}
}
impl
Decodable
for
DateTime
<
Utc
>
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
DateTime
<
Utc
>
D
:
:
Error
>
{
d
.
read_str
(
)
?
.
parse
:
:
<
DateTime
<
FixedOffset
>
>
(
)
.
map
(
|
dt
|
dt
.
with_timezone
(
&
Utc
)
)
.
map_err
(
|
_
|
d
.
error
(
"
invalid
date
and
time
"
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
TsSeconds
<
Tz
:
TimeZone
>
(
DateTime
<
Tz
>
)
;
#
[
allow
(
deprecated
)
]
impl
<
Tz
:
TimeZone
>
From
<
TsSeconds
<
Tz
>
>
for
DateTime
<
Tz
>
{
#
[
allow
(
deprecated
)
]
fn
from
(
obj
:
TsSeconds
<
Tz
>
)
-
>
DateTime
<
Tz
>
{
obj
.
0
}
}
#
[
allow
(
deprecated
)
]
impl
<
Tz
:
TimeZone
>
Deref
for
TsSeconds
<
Tz
>
{
type
Target
=
DateTime
<
Tz
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
#
[
allow
(
deprecated
)
]
impl
Decodable
for
TsSeconds
<
Utc
>
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
TsSeconds
<
Utc
>
D
:
:
Error
>
{
from
(
Utc
.
timestamp_opt
(
d
.
read_i64
(
)
?
0
)
d
)
.
map
(
TsSeconds
)
}
}
#
[
cfg
(
feature
=
"
clock
"
)
]
impl
Decodable
for
DateTime
<
Local
>
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
DateTime
<
Local
>
D
:
:
Error
>
{
match
d
.
read_str
(
)
?
.
parse
:
:
<
DateTime
<
FixedOffset
>
>
(
)
{
Ok
(
dt
)
=
>
Ok
(
dt
.
with_timezone
(
&
Local
)
)
Err
(
_
)
=
>
Err
(
d
.
error
(
"
invalid
date
and
time
"
)
)
}
}
}
#
[
cfg
(
feature
=
"
clock
"
)
]
#
[
allow
(
deprecated
)
]
impl
Decodable
for
TsSeconds
<
Local
>
{
#
[
allow
(
deprecated
)
]
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
TsSeconds
<
Local
>
D
:
:
Error
>
{
from
(
Utc
.
timestamp_opt
(
d
.
read_i64
(
)
?
0
)
d
)
.
map
(
|
dt
|
TsSeconds
(
dt
.
with_timezone
(
&
Local
)
)
)
}
}
#
[
cfg
(
test
)
]
use
rustc_serialize
:
:
json
;
#
[
test
]
fn
test_encodable
(
)
{
super
:
:
test_encodable_json
(
json
:
:
encode
json
:
:
encode
)
;
}
#
[
cfg
(
feature
=
"
clock
"
)
]
#
[
test
]
fn
test_decodable
(
)
{
super
:
:
test_decodable_json
(
json
:
:
decode
json
:
:
decode
json
:
:
decode
)
;
}
#
[
cfg
(
feature
=
"
clock
"
)
]
#
[
test
]
fn
test_decodable_timestamps
(
)
{
super
:
:
test_decodable_json_timestamps
(
json
:
:
decode
json
:
:
decode
json
:
:
decode
)
;
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
pub
mod
serde
{
use
core
:
:
fmt
;
use
super
:
:
DateTime
;
#
[
cfg
(
feature
=
"
clock
"
)
]
use
offset
:
:
Local
;
use
offset
:
:
{
LocalResult
TimeZone
Utc
FixedOffset
}
;
use
serdelib
:
:
{
ser
de
}
;
use
{
SerdeError
ne_timestamp
}
;
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
pub
struct
SecondsTimestampVisitor
;
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
pub
struct
NanoSecondsTimestampVisitor
;
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
pub
struct
MilliSecondsTimestampVisitor
;
fn
serde_from
<
T
E
V
>
(
me
:
LocalResult
<
T
>
ts
:
&
V
)
-
>
Result
<
T
E
>
where
E
:
de
:
:
Error
V
:
fmt
:
:
Display
T
:
fmt
:
:
Display
{
match
me
{
LocalResult
:
:
None
=
>
Err
(
E
:
:
custom
(
ne_timestamp
(
ts
)
)
)
LocalResult
:
:
Ambiguous
(
min
max
)
=
>
Err
(
E
:
:
custom
(
SerdeError
:
:
Ambiguous
{
timestamp
:
ts
min
:
min
max
:
max
}
)
)
LocalResult
:
:
Single
(
val
)
=
>
Ok
(
val
)
}
}
pub
mod
ts_nanoseconds
{
use
core
:
:
fmt
;
use
serdelib
:
:
{
ser
de
}
;
use
{
DateTime
Utc
}
;
use
offset
:
:
TimeZone
;
use
super
:
:
{
serde_from
NanoSecondsTimestampVisitor
}
;
pub
fn
serialize
<
S
>
(
dt
:
&
DateTime
<
Utc
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
serializer
.
serialize_i64
(
dt
.
timestamp_nanos
(
)
)
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
DateTime
<
Utc
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
Ok
(
d
.
deserialize_i64
(
NanoSecondsTimestampVisitor
)
?
)
}
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
NanoSecondsTimestampVisitor
{
type
Value
=
DateTime
<
Utc
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
formatter
"
a
unix
timestamp
in
nanoseconds
"
)
}
fn
visit_i64
<
E
>
(
self
value
:
i64
)
-
>
Result
<
DateTime
<
Utc
>
E
>
where
E
:
de
:
:
Error
{
serde_from
(
Utc
.
timestamp_opt
(
value
/
1_000_000_000
(
value
%
1_000_000_000
)
as
u32
)
&
value
)
}
fn
visit_u64
<
E
>
(
self
value
:
u64
)
-
>
Result
<
DateTime
<
Utc
>
E
>
where
E
:
de
:
:
Error
{
serde_from
(
Utc
.
timestamp_opt
(
(
value
/
1_000_000_000
)
as
i64
(
value
%
1_000_000_000
)
as
u32
)
&
value
)
}
}
}
pub
mod
ts_nanoseconds_option
{
use
core
:
:
fmt
;
use
serdelib
:
:
{
ser
de
}
;
use
{
DateTime
Utc
}
;
use
super
:
:
{
ts_nanoseconds
NanoSecondsTimestampVisitor
}
;
pub
fn
serialize
<
S
>
(
opt
:
&
Option
<
DateTime
<
Utc
>
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
match
*
opt
{
Some
(
ref
dt
)
=
>
ts_nanoseconds
:
:
serialize
(
dt
serializer
)
None
=
>
serializer
.
serialize_none
(
)
}
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
Ok
(
d
.
deserialize_option
(
OptionNanoSecondsTimestampVisitor
)
?
)
}
struct
OptionNanoSecondsTimestampVisitor
;
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
OptionNanoSecondsTimestampVisitor
{
type
Value
=
Option
<
DateTime
<
Utc
>
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
nanoseconds
or
none
"
)
}
fn
visit_some
<
D
>
(
self
d
:
D
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_i64
(
NanoSecondsTimestampVisitor
)
.
map
(
|
val
|
Some
(
val
)
)
}
fn
visit_none
<
E
>
(
self
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
E
>
where
E
:
de
:
:
Error
{
Ok
(
None
)
}
}
}
pub
mod
ts_milliseconds
{
use
core
:
:
fmt
;
use
serdelib
:
:
{
ser
de
}
;
use
{
DateTime
Utc
}
;
use
offset
:
:
TimeZone
;
use
super
:
:
{
serde_from
MilliSecondsTimestampVisitor
}
;
pub
fn
serialize
<
S
>
(
dt
:
&
DateTime
<
Utc
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
serializer
.
serialize_i64
(
dt
.
timestamp_millis
(
)
)
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
DateTime
<
Utc
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
Ok
(
d
.
deserialize_i64
(
MilliSecondsTimestampVisitor
)
.
map
(
|
dt
|
dt
.
with_timezone
(
&
Utc
)
)
?
)
}
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
MilliSecondsTimestampVisitor
{
type
Value
=
DateTime
<
Utc
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
milliseconds
"
)
}
fn
visit_i64
<
E
>
(
self
value
:
i64
)
-
>
Result
<
DateTime
<
Utc
>
E
>
where
E
:
de
:
:
Error
{
serde_from
(
Utc
.
timestamp_opt
(
value
/
1000
(
(
value
%
1000
)
*
1_000_000
)
as
u32
)
&
value
)
}
fn
visit_u64
<
E
>
(
self
value
:
u64
)
-
>
Result
<
DateTime
<
Utc
>
E
>
where
E
:
de
:
:
Error
{
serde_from
(
Utc
.
timestamp_opt
(
(
value
/
1000
)
as
i64
(
(
value
%
1000
)
*
1_000_000
)
as
u32
)
&
value
)
}
}
}
pub
mod
ts_milliseconds_option
{
use
core
:
:
fmt
;
use
serdelib
:
:
{
ser
de
}
;
use
{
DateTime
Utc
}
;
use
super
:
:
{
ts_milliseconds
MilliSecondsTimestampVisitor
}
;
pub
fn
serialize
<
S
>
(
opt
:
&
Option
<
DateTime
<
Utc
>
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
match
*
opt
{
Some
(
ref
dt
)
=
>
ts_milliseconds
:
:
serialize
(
dt
serializer
)
None
=
>
serializer
.
serialize_none
(
)
}
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
Ok
(
d
.
deserialize_option
(
OptionMilliSecondsTimestampVisitor
)
.
map
(
|
opt
|
opt
.
map
(
|
dt
|
dt
.
with_timezone
(
&
Utc
)
)
)
?
)
}
struct
OptionMilliSecondsTimestampVisitor
;
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
OptionMilliSecondsTimestampVisitor
{
type
Value
=
Option
<
DateTime
<
Utc
>
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
milliseconds
or
none
"
)
}
fn
visit_some
<
D
>
(
self
d
:
D
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_i64
(
MilliSecondsTimestampVisitor
)
.
map
(
|
val
|
Some
(
val
)
)
}
fn
visit_none
<
E
>
(
self
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
E
>
where
E
:
de
:
:
Error
{
Ok
(
None
)
}
}
}
pub
mod
ts_seconds
{
use
core
:
:
fmt
;
use
serdelib
:
:
{
ser
de
}
;
use
{
DateTime
Utc
}
;
use
offset
:
:
TimeZone
;
use
super
:
:
{
serde_from
SecondsTimestampVisitor
}
;
pub
fn
serialize
<
S
>
(
dt
:
&
DateTime
<
Utc
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
serializer
.
serialize_i64
(
dt
.
timestamp
(
)
)
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
DateTime
<
Utc
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
Ok
(
d
.
deserialize_i64
(
SecondsTimestampVisitor
)
?
)
}
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
SecondsTimestampVisitor
{
type
Value
=
DateTime
<
Utc
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
seconds
"
)
}
fn
visit_i64
<
E
>
(
self
value
:
i64
)
-
>
Result
<
DateTime
<
Utc
>
E
>
where
E
:
de
:
:
Error
{
serde_from
(
Utc
.
timestamp_opt
(
value
0
)
&
value
)
}
fn
visit_u64
<
E
>
(
self
value
:
u64
)
-
>
Result
<
DateTime
<
Utc
>
E
>
where
E
:
de
:
:
Error
{
serde_from
(
Utc
.
timestamp_opt
(
value
as
i64
0
)
&
value
)
}
}
}
pub
mod
ts_seconds_option
{
use
core
:
:
fmt
;
use
serdelib
:
:
{
ser
de
}
;
use
{
DateTime
Utc
}
;
use
super
:
:
{
ts_seconds
SecondsTimestampVisitor
}
;
pub
fn
serialize
<
S
>
(
opt
:
&
Option
<
DateTime
<
Utc
>
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
match
*
opt
{
Some
(
ref
dt
)
=
>
ts_seconds
:
:
serialize
(
dt
serializer
)
None
=
>
serializer
.
serialize_none
(
)
}
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
Ok
(
d
.
deserialize_option
(
OptionSecondsTimestampVisitor
)
?
)
}
struct
OptionSecondsTimestampVisitor
;
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
OptionSecondsTimestampVisitor
{
type
Value
=
Option
<
DateTime
<
Utc
>
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
seconds
or
none
"
)
}
fn
visit_some
<
D
>
(
self
d
:
D
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_i64
(
SecondsTimestampVisitor
)
.
map
(
|
val
|
Some
(
val
)
)
}
fn
visit_none
<
E
>
(
self
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
E
>
where
E
:
de
:
:
Error
{
Ok
(
None
)
}
}
}
impl
<
Tz
:
TimeZone
>
ser
:
:
Serialize
for
DateTime
<
Tz
>
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
struct
FormatWrapped
<
'
a
D
:
'
a
>
{
inner
:
&
'
a
D
}
impl
<
'
a
D
:
fmt
:
:
Debug
>
fmt
:
:
Display
for
FormatWrapped
<
'
a
D
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
inner
.
fmt
(
f
)
}
}
serializer
.
collect_str
(
&
FormatWrapped
{
inner
:
&
self
}
)
}
}
struct
DateTimeVisitor
;
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
DateTimeVisitor
{
type
Value
=
DateTime
<
FixedOffset
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
formatter
"
a
formatted
date
and
time
string
or
a
unix
timestamp
"
)
}
fn
visit_str
<
E
>
(
self
value
:
&
str
)
-
>
Result
<
DateTime
<
FixedOffset
>
E
>
where
E
:
de
:
:
Error
{
value
.
parse
(
)
.
map_err
(
|
err
:
:
:
format
:
:
ParseError
|
E
:
:
custom
(
err
)
)
}
}
impl
<
'
de
>
de
:
:
Deserialize
<
'
de
>
for
DateTime
<
FixedOffset
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_str
(
DateTimeVisitor
)
}
}
impl
<
'
de
>
de
:
:
Deserialize
<
'
de
>
for
DateTime
<
Utc
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_str
(
DateTimeVisitor
)
.
map
(
|
dt
|
dt
.
with_timezone
(
&
Utc
)
)
}
}
#
[
cfg
(
feature
=
"
clock
"
)
]
impl
<
'
de
>
de
:
:
Deserialize
<
'
de
>
for
DateTime
<
Local
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_str
(
DateTimeVisitor
)
.
map
(
|
dt
|
dt
.
with_timezone
(
&
Local
)
)
}
}
#
[
cfg
(
test
)
]
extern
crate
serde_json
;
#
[
cfg
(
test
)
]
extern
crate
bincode
;
#
[
test
]
fn
test_serde_serialize
(
)
{
super
:
:
test_encodable_json
(
self
:
:
serde_json
:
:
to_string
self
:
:
serde_json
:
:
to_string
)
;
}
#
[
cfg
(
feature
=
"
clock
"
)
]
#
[
test
]
fn
test_serde_deserialize
(
)
{
super
:
:
test_decodable_json
(
|
input
|
self
:
:
serde_json
:
:
from_str
(
&
input
)
|
input
|
self
:
:
serde_json
:
:
from_str
(
&
input
)
|
input
|
self
:
:
serde_json
:
:
from_str
(
&
input
)
)
;
}
#
[
test
]
fn
test_serde_bincode
(
)
{
use
self
:
:
bincode
:
:
{
Infinite
serialize
deserialize
}
;
let
dt
=
Utc
.
ymd
(
2014
7
24
)
.
and_hms
(
12
34
6
)
;
let
encoded
=
serialize
(
&
dt
Infinite
)
.
unwrap
(
)
;
let
decoded
:
DateTime
<
Utc
>
=
deserialize
(
&
encoded
)
.
unwrap
(
)
;
assert_eq
!
(
dt
decoded
)
;
assert_eq
!
(
dt
.
offset
(
)
decoded
.
offset
(
)
)
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
DateTime
;
#
[
cfg
(
feature
=
"
clock
"
)
]
use
Datelike
;
use
naive
:
:
{
NaiveTime
NaiveDate
}
;
#
[
cfg
(
feature
=
"
clock
"
)
]
use
offset
:
:
Local
;
use
offset
:
:
{
TimeZone
Utc
FixedOffset
}
;
use
oldtime
:
:
Duration
;
use
std
:
:
time
:
:
{
SystemTime
UNIX_EPOCH
}
;
#
[
test
]
#
[
allow
(
non_snake_case
)
]
fn
test_datetime_offset
(
)
{
let
Est
=
FixedOffset
:
:
west
(
5
*
60
*
60
)
;
let
Edt
=
FixedOffset
:
:
west
(
4
*
60
*
60
)
;
let
Kst
=
FixedOffset
:
:
east
(
9
*
60
*
60
)
;
assert_eq
!
(
format
!
(
"
{
}
"
Utc
.
ymd
(
2014
5
6
)
.
and_hms
(
7
8
9
)
)
"
2014
-
05
-
06
07
:
08
:
09
UTC
"
)
;
assert_eq
!
(
format
!
(
"
{
}
"
Edt
.
ymd
(
2014
5
6
)
.
and_hms
(
7
8
9
)
)
"
2014
-
05
-
06
07
:
08
:
09
-
04
:
00
"
)
;
assert_eq
!
(
format
!
(
"
{
}
"
Kst
.
ymd
(
2014
5
6
)
.
and_hms
(
7
8
9
)
)
"
2014
-
05
-
06
07
:
08
:
09
+
09
:
00
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
Utc
.
ymd
(
2014
5
6
)
.
and_hms
(
7
8
9
)
)
"
2014
-
05
-
06T07
:
08
:
09Z
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
Edt
.
ymd
(
2014
5
6
)
.
and_hms
(
7
8
9
)
)
"
2014
-
05
-
06T07
:
08
:
09
-
04
:
00
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
Kst
.
ymd
(
2014
5
6
)
.
and_hms
(
7
8
9
)
)
"
2014
-
05
-
06T07
:
08
:
09
+
09
:
00
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
Utc
.
ymd
(
2014
5
6
)
.
and_hms
(
0
0
0
)
)
"
2014
-
05
-
06T00
:
00
:
00Z
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
Edt
.
ymd
(
2014
5
6
)
.
and_hms
(
0
0
0
)
)
"
2014
-
05
-
06T00
:
00
:
00
-
04
:
00
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
Kst
.
ymd
(
2014
5
6
)
.
and_hms
(
0
0
0
)
)
"
2014
-
05
-
06T00
:
00
:
00
+
09
:
00
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
Utc
.
ymd
(
2014
5
6
)
.
and_hms
(
23
59
59
)
)
"
2014
-
05
-
06T23
:
59
:
59Z
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
Edt
.
ymd
(
2014
5
6
)
.
and_hms
(
23
59
59
)
)
"
2014
-
05
-
06T23
:
59
:
59
-
04
:
00
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
Kst
.
ymd
(
2014
5
6
)
.
and_hms
(
23
59
59
)
)
"
2014
-
05
-
06T23
:
59
:
59
+
09
:
00
"
)
;
let
dt
=
Utc
.
ymd
(
2014
5
6
)
.
and_hms
(
7
8
9
)
;
assert_eq
!
(
dt
Edt
.
ymd
(
2014
5
6
)
.
and_hms
(
3
8
9
)
)
;
assert_eq
!
(
dt
+
Duration
:
:
seconds
(
3600
+
60
+
1
)
Utc
.
ymd
(
2014
5
6
)
.
and_hms
(
8
9
10
)
)
;
assert_eq
!
(
dt
.
signed_duration_since
(
Edt
.
ymd
(
2014
5
6
)
.
and_hms
(
10
11
12
)
)
Duration
:
:
seconds
(
-
7
*
3600
-
3
*
60
-
3
)
)
;
assert_eq
!
(
*
Utc
.
ymd
(
2014
5
6
)
.
and_hms
(
7
8
9
)
.
offset
(
)
Utc
)
;
assert_eq
!
(
*
Edt
.
ymd
(
2014
5
6
)
.
and_hms
(
7
8
9
)
.
offset
(
)
Edt
)
;
assert
!
(
*
Edt
.
ymd
(
2014
5
6
)
.
and_hms
(
7
8
9
)
.
offset
(
)
!
=
Est
)
;
}
#
[
test
]
fn
test_datetime_date_and_time
(
)
{
let
tz
=
FixedOffset
:
:
east
(
5
*
60
*
60
)
;
let
d
=
tz
.
ymd
(
2014
5
6
)
.
and_hms
(
7
8
9
)
;
assert_eq
!
(
d
.
time
(
)
NaiveTime
:
:
from_hms
(
7
8
9
)
)
;
assert_eq
!
(
d
.
date
(
)
tz
.
ymd
(
2014
5
6
)
)
;
assert_eq
!
(
d
.
date
(
)
.
naive_local
(
)
NaiveDate
:
:
from_ymd
(
2014
5
6
)
)
;
assert_eq
!
(
d
.
date
(
)
.
and_time
(
d
.
time
(
)
)
Some
(
d
)
)
;
let
tz
=
FixedOffset
:
:
east
(
4
*
60
*
60
)
;
let
d
=
tz
.
ymd
(
2016
5
4
)
.
and_hms
(
3
2
1
)
;
assert_eq
!
(
d
.
time
(
)
NaiveTime
:
:
from_hms
(
3
2
1
)
)
;
assert_eq
!
(
d
.
date
(
)
tz
.
ymd
(
2016
5
4
)
)
;
assert_eq
!
(
d
.
date
(
)
.
naive_local
(
)
NaiveDate
:
:
from_ymd
(
2016
5
4
)
)
;
assert_eq
!
(
d
.
date
(
)
.
and_time
(
d
.
time
(
)
)
Some
(
d
)
)
;
let
tz
=
FixedOffset
:
:
west
(
13
*
60
*
60
)
;
let
d
=
tz
.
ymd
(
2017
8
9
)
.
and_hms
(
12
34
56
)
;
assert_eq
!
(
d
.
time
(
)
NaiveTime
:
:
from_hms
(
12
34
56
)
)
;
assert_eq
!
(
d
.
date
(
)
tz
.
ymd
(
2017
8
9
)
)
;
assert_eq
!
(
d
.
date
(
)
.
naive_local
(
)
NaiveDate
:
:
from_ymd
(
2017
8
9
)
)
;
assert_eq
!
(
d
.
date
(
)
.
and_time
(
d
.
time
(
)
)
Some
(
d
)
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
clock
"
)
]
fn
test_datetime_with_timezone
(
)
{
let
local_now
=
Local
:
:
now
(
)
;
let
utc_now
=
local_now
.
with_timezone
(
&
Utc
)
;
let
local_now2
=
utc_now
.
with_timezone
(
&
Local
)
;
assert_eq
!
(
local_now
local_now2
)
;
}
#
[
test
]
#
[
allow
(
non_snake_case
)
]
fn
test_datetime_rfc2822_and_rfc3339
(
)
{
let
EDT
=
FixedOffset
:
:
east
(
5
*
60
*
60
)
;
assert_eq
!
(
Utc
.
ymd
(
2015
2
18
)
.
and_hms
(
23
16
9
)
.
to_rfc2822
(
)
"
Wed
18
Feb
2015
23
:
16
:
09
+
0000
"
)
;
assert_eq
!
(
Utc
.
ymd
(
2015
2
18
)
.
and_hms
(
23
16
9
)
.
to_rfc3339
(
)
"
2015
-
02
-
18T23
:
16
:
09
+
00
:
00
"
)
;
assert_eq
!
(
EDT
.
ymd
(
2015
2
18
)
.
and_hms_milli
(
23
16
9
150
)
.
to_rfc2822
(
)
"
Wed
18
Feb
2015
23
:
16
:
09
+
0500
"
)
;
assert_eq
!
(
EDT
.
ymd
(
2015
2
18
)
.
and_hms_milli
(
23
16
9
150
)
.
to_rfc3339
(
)
"
2015
-
02
-
18T23
:
16
:
09
.
150
+
05
:
00
"
)
;
assert_eq
!
(
EDT
.
ymd
(
2015
2
18
)
.
and_hms_micro
(
23
59
59
1_234_567
)
.
to_rfc2822
(
)
"
Wed
18
Feb
2015
23
:
59
:
60
+
0500
"
)
;
assert_eq
!
(
EDT
.
ymd
(
2015
2
18
)
.
and_hms_micro
(
23
59
59
1_234_567
)
.
to_rfc3339
(
)
"
2015
-
02
-
18T23
:
59
:
60
.
234567
+
05
:
00
"
)
;
assert_eq
!
(
DateTime
:
:
parse_from_rfc2822
(
"
Wed
18
Feb
2015
23
:
16
:
09
+
0000
"
)
Ok
(
FixedOffset
:
:
east
(
0
)
.
ymd
(
2015
2
18
)
.
and_hms
(
23
16
9
)
)
)
;
assert_eq
!
(
DateTime
:
:
parse_from_rfc3339
(
"
2015
-
02
-
18T23
:
16
:
09Z
"
)
Ok
(
FixedOffset
:
:
east
(
0
)
.
ymd
(
2015
2
18
)
.
and_hms
(
23
16
9
)
)
)
;
assert_eq
!
(
DateTime
:
:
parse_from_rfc2822
(
"
Wed
18
Feb
2015
23
:
59
:
60
+
0500
"
)
Ok
(
EDT
.
ymd
(
2015
2
18
)
.
and_hms_milli
(
23
59
59
1_000
)
)
)
;
assert_eq
!
(
DateTime
:
:
parse_from_rfc3339
(
"
2015
-
02
-
18T23
:
59
:
60
.
234567
+
05
:
00
"
)
Ok
(
EDT
.
ymd
(
2015
2
18
)
.
and_hms_micro
(
23
59
59
1_234_567
)
)
)
;
}
#
[
test
]
fn
test_rfc3339_opts
(
)
{
use
SecondsFormat
:
:
*
;
let
pst
=
FixedOffset
:
:
east
(
8
*
60
*
60
)
;
let
dt
=
pst
.
ymd
(
2018
1
11
)
.
and_hms_nano
(
10
5
13
084_660_000
)
;
assert_eq
!
(
dt
.
to_rfc3339_opts
(
Secs
false
)
"
2018
-
01
-
11T10
:
05
:
13
+
08
:
00
"
)
;
assert_eq
!
(
dt
.
to_rfc3339_opts
(
Secs
true
)
"
2018
-
01
-
11T10
:
05
:
13
+
08
:
00
"
)
;
assert_eq
!
(
dt
.
to_rfc3339_opts
(
Millis
false
)
"
2018
-
01
-
11T10
:
05
:
13
.
084
+
08
:
00
"
)
;
assert_eq
!
(
dt
.
to_rfc3339_opts
(
Micros
false
)
"
2018
-
01
-
11T10
:
05
:
13
.
084660
+
08
:
00
"
)
;
assert_eq
!
(
dt
.
to_rfc3339_opts
(
Nanos
false
)
"
2018
-
01
-
11T10
:
05
:
13
.
084660000
+
08
:
00
"
)
;
assert_eq
!
(
dt
.
to_rfc3339_opts
(
AutoSi
false
)
"
2018
-
01
-
11T10
:
05
:
13
.
084660
+
08
:
00
"
)
;
let
ut
=
DateTime
:
:
<
Utc
>
:
:
from_utc
(
dt
.
naive_utc
(
)
Utc
)
;
assert_eq
!
(
ut
.
to_rfc3339_opts
(
Secs
false
)
"
2018
-
01
-
11T02
:
05
:
13
+
00
:
00
"
)
;
assert_eq
!
(
ut
.
to_rfc3339_opts
(
Secs
true
)
"
2018
-
01
-
11T02
:
05
:
13Z
"
)
;
assert_eq
!
(
ut
.
to_rfc3339_opts
(
Millis
false
)
"
2018
-
01
-
11T02
:
05
:
13
.
084
+
00
:
00
"
)
;
assert_eq
!
(
ut
.
to_rfc3339_opts
(
Millis
true
)
"
2018
-
01
-
11T02
:
05
:
13
.
084Z
"
)
;
assert_eq
!
(
ut
.
to_rfc3339_opts
(
Micros
true
)
"
2018
-
01
-
11T02
:
05
:
13
.
084660Z
"
)
;
assert_eq
!
(
ut
.
to_rfc3339_opts
(
Nanos
true
)
"
2018
-
01
-
11T02
:
05
:
13
.
084660000Z
"
)
;
assert_eq
!
(
ut
.
to_rfc3339_opts
(
AutoSi
true
)
"
2018
-
01
-
11T02
:
05
:
13
.
084660Z
"
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_rfc3339_opts_nonexhaustive
(
)
{
use
SecondsFormat
;
let
dt
=
Utc
.
ymd
(
1999
10
9
)
.
and_hms
(
1
2
3
)
;
dt
.
to_rfc3339_opts
(
SecondsFormat
:
:
__NonExhaustive
true
)
;
}
#
[
test
]
fn
test_datetime_from_str
(
)
{
assert_eq
!
(
"
2015
-
2
-
18T23
:
16
:
9
.
15Z
"
.
parse
:
:
<
DateTime
<
FixedOffset
>
>
(
)
Ok
(
FixedOffset
:
:
east
(
0
)
.
ymd
(
2015
2
18
)
.
and_hms_milli
(
23
16
9
150
)
)
)
;
assert_eq
!
(
"
2015
-
2
-
18T13
:
16
:
9
.
15
-
10
:
00
"
.
parse
:
:
<
DateTime
<
FixedOffset
>
>
(
)
Ok
(
FixedOffset
:
:
west
(
10
*
3600
)
.
ymd
(
2015
2
18
)
.
and_hms_milli
(
13
16
9
150
)
)
)
;
assert
!
(
"
2015
-
2
-
18T23
:
16
:
9
.
15
"
.
parse
:
:
<
DateTime
<
FixedOffset
>
>
(
)
.
is_err
(
)
)
;
assert_eq
!
(
"
2015
-
2
-
18T23
:
16
:
9
.
15Z
"
.
parse
:
:
<
DateTime
<
Utc
>
>
(
)
Ok
(
Utc
.
ymd
(
2015
2
18
)
.
and_hms_milli
(
23
16
9
150
)
)
)
;
assert_eq
!
(
"
2015
-
2
-
18T13
:
16
:
9
.
15
-
10
:
00
"
.
parse
:
:
<
DateTime
<
Utc
>
>
(
)
Ok
(
Utc
.
ymd
(
2015
2
18
)
.
and_hms_milli
(
23
16
9
150
)
)
)
;
assert
!
(
"
2015
-
2
-
18T23
:
16
:
9
.
15
"
.
parse
:
:
<
DateTime
<
Utc
>
>
(
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
test_datetime_parse_from_str
(
)
{
let
ymdhms
=
|
y
m
d
h
n
s
off
|
FixedOffset
:
:
east
(
off
)
.
ymd
(
y
m
d
)
.
and_hms
(
h
n
s
)
;
assert_eq
!
(
DateTime
:
:
parse_from_str
(
"
2014
-
5
-
7T12
:
34
:
56
+
09
:
30
"
"
%
Y
-
%
m
-
%
dT
%
H
:
%
M
:
%
S
%
z
"
)
Ok
(
ymdhms
(
2014
5
7
12
34
56
570
*
60
)
)
)
;
assert
!
(
DateTime
:
:
parse_from_str
(
"
20140507000000
"
"
%
Y
%
m
%
d
%
H
%
M
%
S
"
)
.
is_err
(
)
)
;
assert
!
(
DateTime
:
:
parse_from_str
(
"
Fri
09
Aug
2013
23
:
54
:
35
GMT
"
"
%
a
%
d
%
b
%
Y
%
H
:
%
M
:
%
S
GMT
"
)
.
is_err
(
)
)
;
assert_eq
!
(
Utc
.
datetime_from_str
(
"
Fri
09
Aug
2013
23
:
54
:
35
GMT
"
"
%
a
%
d
%
b
%
Y
%
H
:
%
M
:
%
S
GMT
"
)
Ok
(
Utc
.
ymd
(
2013
8
9
)
.
and_hms
(
23
54
35
)
)
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
clock
"
)
]
fn
test_datetime_format_with_local
(
)
{
let
dt
=
Local
:
:
now
(
)
.
with_month
(
5
)
.
unwrap
(
)
;
assert_eq
!
(
dt
.
format
(
"
%
Y
"
)
.
to_string
(
)
dt
.
with_timezone
(
&
Utc
)
.
format
(
"
%
Y
"
)
.
to_string
(
)
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
clock
"
)
]
fn
test_datetime_is_copy
(
)
{
let
a
=
Utc
:
:
now
(
)
;
let
b
=
a
;
assert_eq
!
(
a
b
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
clock
"
)
]
fn
test_datetime_is_send
(
)
{
use
std
:
:
thread
;
let
a
=
Utc
:
:
now
(
)
;
thread
:
:
spawn
(
move
|
|
{
let
_
=
a
;
}
)
.
join
(
)
.
unwrap
(
)
;
}
#
[
test
]
fn
test_subsecond_part
(
)
{
let
datetime
=
Utc
.
ymd
(
2014
7
8
)
.
and_hms_nano
(
9
10
11
1234567
)
;
assert_eq
!
(
1
datetime
.
timestamp_subsec_millis
(
)
)
;
assert_eq
!
(
1234
datetime
.
timestamp_subsec_micros
(
)
)
;
assert_eq
!
(
1234567
datetime
.
timestamp_subsec_nanos
(
)
)
;
}
#
[
test
]
fn
test_from_system_time
(
)
{
use
std
:
:
time
:
:
Duration
;
let
epoch
=
Utc
.
ymd
(
1970
1
1
)
.
and_hms
(
0
0
0
)
;
assert_eq
!
(
DateTime
:
:
<
Utc
>
:
:
from
(
UNIX_EPOCH
)
epoch
)
;
assert_eq
!
(
DateTime
:
:
<
Utc
>
:
:
from
(
UNIX_EPOCH
+
Duration
:
:
new
(
999_999_999
999_999_999
)
)
Utc
.
ymd
(
2001
9
9
)
.
and_hms_nano
(
1
46
39
999_999_999
)
)
;
assert_eq
!
(
DateTime
:
:
<
Utc
>
:
:
from
(
UNIX_EPOCH
-
Duration
:
:
new
(
999_999_999
999_999_999
)
)
Utc
.
ymd
(
1938
4
24
)
.
and_hms_nano
(
22
13
20
1
)
)
;
assert_eq
!
(
SystemTime
:
:
from
(
epoch
)
UNIX_EPOCH
)
;
assert_eq
!
(
SystemTime
:
:
from
(
Utc
.
ymd
(
2001
9
9
)
.
and_hms_nano
(
1
46
39
999_999_999
)
)
UNIX_EPOCH
+
Duration
:
:
new
(
999_999_999
999_999_999
)
)
;
assert_eq
!
(
SystemTime
:
:
from
(
Utc
.
ymd
(
1938
4
24
)
.
and_hms_nano
(
22
13
20
1
)
)
UNIX_EPOCH
-
Duration
:
:
new
(
999_999_999
999_999_999
)
)
;
#
[
cfg
(
feature
=
"
clock
"
)
]
{
assert_eq
!
(
SystemTime
:
:
from
(
epoch
.
with_timezone
(
&
Local
)
)
UNIX_EPOCH
)
;
}
assert_eq
!
(
SystemTime
:
:
from
(
epoch
.
with_timezone
(
&
FixedOffset
:
:
east
(
32400
)
)
)
UNIX_EPOCH
)
;
assert_eq
!
(
SystemTime
:
:
from
(
epoch
.
with_timezone
(
&
FixedOffset
:
:
west
(
28800
)
)
)
UNIX_EPOCH
)
;
}
#
[
test
]
fn
test_datetime_format_alignment
(
)
{
let
datetime
=
Utc
.
ymd
(
2007
01
02
)
;
let
percent
=
datetime
.
format
(
"
%
%
"
)
;
assert_eq
!
(
"
%
"
format
!
(
"
{
:
>
3
}
"
percent
)
)
;
assert_eq
!
(
"
%
"
format
!
(
"
{
:
<
3
}
"
percent
)
)
;
assert_eq
!
(
"
%
"
format
!
(
"
{
:
^
3
}
"
percent
)
)
;
let
year
=
datetime
.
format
(
"
%
Y
"
)
;
assert_eq
!
(
"
2007
"
format
!
(
"
{
:
>
6
}
"
year
)
)
;
assert_eq
!
(
"
2007
"
format
!
(
"
{
:
<
6
}
"
year
)
)
;
assert_eq
!
(
"
2007
"
format
!
(
"
{
:
^
6
}
"
year
)
)
;
let
tz
=
datetime
.
format
(
"
%
Z
"
)
;
assert_eq
!
(
"
UTC
"
format
!
(
"
{
:
>
5
}
"
tz
)
)
;
assert_eq
!
(
"
UTC
"
format
!
(
"
{
:
<
5
}
"
tz
)
)
;
assert_eq
!
(
"
UTC
"
format
!
(
"
{
:
^
5
}
"
tz
)
)
;
let
ymd
=
datetime
.
format
(
"
%
Y
%
B
%
d
"
)
;
let
ymd_formatted
=
"
2007
January
02
"
;
assert_eq
!
(
format
!
(
"
{
}
"
ymd_formatted
)
format
!
(
"
{
:
>
17
}
"
ymd
)
)
;
assert_eq
!
(
format
!
(
"
{
}
"
ymd_formatted
)
format
!
(
"
{
:
<
17
}
"
ymd
)
)
;
assert_eq
!
(
format
!
(
"
{
}
"
ymd_formatted
)
format
!
(
"
{
:
^
17
}
"
ymd
)
)
;
}
#
[
cfg
(
feature
=
"
bench
"
)
]
#
[
bench
]
fn
bench_datetime_parse_from_rfc2822
(
bh
:
&
mut
test
:
:
Bencher
)
{
bh
.
iter
(
|
|
{
let
str
=
test
:
:
black_box
(
"
Wed
18
Feb
2015
23
:
16
:
09
+
0000
"
)
;
DateTime
:
:
parse_from_rfc2822
(
str
)
.
unwrap
(
)
}
)
;
}
#
[
cfg
(
feature
=
"
bench
"
)
]
#
[
bench
]
fn
bench_datetime_parse_from_rfc3339
(
bh
:
&
mut
test
:
:
Bencher
)
{
bh
.
iter
(
|
|
{
let
str
=
test
:
:
black_box
(
"
2015
-
02
-
18T23
:
59
:
60
.
234567
+
05
:
00
"
)
;
DateTime
:
:
parse_from_rfc3339
(
str
)
.
unwrap
(
)
}
)
;
}
#
[
cfg
(
feature
=
"
bench
"
)
]
#
[
bench
]
fn
bench_datetime_from_str
(
bh
:
&
mut
test
:
:
Bencher
)
{
use
std
:
:
str
:
:
FromStr
;
bh
.
iter
(
|
|
{
let
str
=
test
:
:
black_box
(
"
2019
-
03
-
30T18
:
46
:
57
.
193Z
"
)
;
DateTime
:
:
<
Utc
>
:
:
from_str
(
str
)
.
unwrap
(
)
}
)
;
}
#
[
cfg
(
feature
=
"
bench
"
)
]
#
[
bench
]
fn
bench_datetime_to_rfc2822
(
bh
:
&
mut
test
:
:
Bencher
)
{
let
pst
=
FixedOffset
:
:
east
(
8
*
60
*
60
)
;
let
dt
=
pst
.
ymd
(
2018
1
11
)
.
and_hms_nano
(
10
5
13
084_660_000
)
;
bh
.
iter
(
|
|
{
test
:
:
black_box
(
dt
)
.
to_rfc2822
(
)
}
)
;
}
#
[
cfg
(
feature
=
"
bench
"
)
]
#
[
bench
]
fn
bench_datetime_to_rfc3339
(
bh
:
&
mut
test
:
:
Bencher
)
{
let
pst
=
FixedOffset
:
:
east
(
8
*
60
*
60
)
;
let
dt
=
pst
.
ymd
(
2018
1
11
)
.
and_hms_nano
(
10
5
13
084_660_000
)
;
bh
.
iter
(
|
|
{
test
:
:
black_box
(
dt
)
.
to_rfc3339
(
)
}
)
;
}
}
