use
core
:
:
fmt
;
use
serde
:
:
{
de
ser
}
;
use
super
:
:
DateTime
;
use
crate
:
:
format
:
:
{
SecondsFormat
write_rfc3339
}
;
#
[
cfg
(
feature
=
"
clock
"
)
]
use
crate
:
:
offset
:
:
Local
;
use
crate
:
:
offset
:
:
{
FixedOffset
Offset
TimeZone
Utc
}
;
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
pub
struct
SecondsTimestampVisitor
;
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
pub
struct
NanoSecondsTimestampVisitor
;
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
pub
struct
MicroSecondsTimestampVisitor
;
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
pub
struct
MilliSecondsTimestampVisitor
;
impl
<
Tz
:
TimeZone
>
ser
:
:
Serialize
for
DateTime
<
Tz
>
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
struct
FormatIso8601
<
'
a
Tz
:
TimeZone
>
{
inner
:
&
'
a
DateTime
<
Tz
>
}
impl
<
Tz
:
TimeZone
>
fmt
:
:
Display
for
FormatIso8601
<
'
_
Tz
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
naive
=
self
.
inner
.
naive_local
(
)
;
let
offset
=
self
.
inner
.
offset
.
fix
(
)
;
write_rfc3339
(
f
naive
offset
SecondsFormat
:
:
AutoSi
true
)
}
}
serializer
.
collect_str
(
&
FormatIso8601
{
inner
:
self
}
)
}
}
struct
DateTimeVisitor
;
impl
de
:
:
Visitor
<
'
_
>
for
DateTimeVisitor
{
type
Value
=
DateTime
<
FixedOffset
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
an
RFC
3339
formatted
date
and
time
string
"
)
}
fn
visit_str
<
E
>
(
self
value
:
&
str
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
value
.
parse
(
)
.
map_err
(
E
:
:
custom
)
}
}
impl
<
'
de
>
de
:
:
Deserialize
<
'
de
>
for
DateTime
<
FixedOffset
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_str
(
DateTimeVisitor
)
}
}
impl
<
'
de
>
de
:
:
Deserialize
<
'
de
>
for
DateTime
<
Utc
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_str
(
DateTimeVisitor
)
.
map
(
|
dt
|
dt
.
with_timezone
(
&
Utc
)
)
}
}
#
[
cfg
(
feature
=
"
clock
"
)
]
impl
<
'
de
>
de
:
:
Deserialize
<
'
de
>
for
DateTime
<
Local
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_str
(
DateTimeVisitor
)
.
map
(
|
dt
|
dt
.
with_timezone
(
&
Local
)
)
}
}
pub
mod
ts_nanoseconds
{
use
core
:
:
fmt
;
use
serde
:
:
{
de
ser
}
;
use
crate
:
:
serde
:
:
invalid_ts
;
use
crate
:
:
{
DateTime
Utc
}
;
use
super
:
:
NanoSecondsTimestampVisitor
;
pub
fn
serialize
<
S
>
(
dt
:
&
DateTime
<
Utc
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
serializer
.
serialize_i64
(
dt
.
timestamp_nanos_opt
(
)
.
ok_or
(
ser
:
:
Error
:
:
custom
(
"
value
out
of
range
for
a
timestamp
with
nanosecond
precision
"
)
)
?
)
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
DateTime
<
Utc
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_i64
(
NanoSecondsTimestampVisitor
)
}
impl
de
:
:
Visitor
<
'
_
>
for
NanoSecondsTimestampVisitor
{
type
Value
=
DateTime
<
Utc
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
nanoseconds
"
)
}
fn
visit_i64
<
E
>
(
self
value
:
i64
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
DateTime
:
:
from_timestamp_nanos
(
value
)
)
}
fn
visit_u64
<
E
>
(
self
value
:
u64
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
DateTime
:
:
from_timestamp
(
(
value
/
1_000_000_000
)
as
i64
(
value
%
1_000_000_000
)
as
u32
)
.
ok_or_else
(
|
|
invalid_ts
(
value
)
)
}
}
}
pub
mod
ts_nanoseconds_option
{
use
core
:
:
fmt
;
use
serde
:
:
{
de
ser
}
;
use
crate
:
:
{
DateTime
Utc
}
;
use
super
:
:
NanoSecondsTimestampVisitor
;
pub
fn
serialize
<
S
>
(
opt
:
&
Option
<
DateTime
<
Utc
>
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
match
*
opt
{
Some
(
ref
dt
)
=
>
serializer
.
serialize_some
(
&
dt
.
timestamp_nanos_opt
(
)
.
ok_or
(
ser
:
:
Error
:
:
custom
(
"
value
out
of
range
for
a
timestamp
with
nanosecond
precision
"
)
)
?
)
None
=
>
serializer
.
serialize_none
(
)
}
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_option
(
OptionNanoSecondsTimestampVisitor
)
}
struct
OptionNanoSecondsTimestampVisitor
;
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
OptionNanoSecondsTimestampVisitor
{
type
Value
=
Option
<
DateTime
<
Utc
>
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
nanoseconds
or
none
"
)
}
fn
visit_some
<
D
>
(
self
d
:
D
)
-
>
Result
<
Self
:
:
Value
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_i64
(
NanoSecondsTimestampVisitor
)
.
map
(
Some
)
}
fn
visit_none
<
E
>
(
self
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
None
)
}
fn
visit_unit
<
E
>
(
self
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
None
)
}
}
}
pub
mod
ts_microseconds
{
use
core
:
:
fmt
;
use
serde
:
:
{
de
ser
}
;
use
crate
:
:
serde
:
:
invalid_ts
;
use
crate
:
:
{
DateTime
Utc
}
;
use
super
:
:
MicroSecondsTimestampVisitor
;
pub
fn
serialize
<
S
>
(
dt
:
&
DateTime
<
Utc
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
serializer
.
serialize_i64
(
dt
.
timestamp_micros
(
)
)
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
DateTime
<
Utc
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_i64
(
MicroSecondsTimestampVisitor
)
}
impl
de
:
:
Visitor
<
'
_
>
for
MicroSecondsTimestampVisitor
{
type
Value
=
DateTime
<
Utc
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
microseconds
"
)
}
fn
visit_i64
<
E
>
(
self
value
:
i64
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
DateTime
:
:
from_timestamp_micros
(
value
)
.
ok_or_else
(
|
|
invalid_ts
(
value
)
)
}
fn
visit_u64
<
E
>
(
self
value
:
u64
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
DateTime
:
:
from_timestamp
(
(
value
/
1_000_000
)
as
i64
(
(
value
%
1_000_000
)
*
1_000
)
as
u32
)
.
ok_or_else
(
|
|
invalid_ts
(
value
)
)
}
}
}
pub
mod
ts_microseconds_option
{
use
core
:
:
fmt
;
use
serde
:
:
{
de
ser
}
;
use
super
:
:
MicroSecondsTimestampVisitor
;
use
crate
:
:
{
DateTime
Utc
}
;
pub
fn
serialize
<
S
>
(
opt
:
&
Option
<
DateTime
<
Utc
>
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
match
*
opt
{
Some
(
ref
dt
)
=
>
serializer
.
serialize_some
(
&
dt
.
timestamp_micros
(
)
)
None
=
>
serializer
.
serialize_none
(
)
}
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_option
(
OptionMicroSecondsTimestampVisitor
)
}
struct
OptionMicroSecondsTimestampVisitor
;
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
OptionMicroSecondsTimestampVisitor
{
type
Value
=
Option
<
DateTime
<
Utc
>
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
microseconds
or
none
"
)
}
fn
visit_some
<
D
>
(
self
d
:
D
)
-
>
Result
<
Self
:
:
Value
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_i64
(
MicroSecondsTimestampVisitor
)
.
map
(
Some
)
}
fn
visit_none
<
E
>
(
self
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
None
)
}
fn
visit_unit
<
E
>
(
self
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
None
)
}
}
}
pub
mod
ts_milliseconds
{
use
core
:
:
fmt
;
use
serde
:
:
{
de
ser
}
;
use
crate
:
:
serde
:
:
invalid_ts
;
use
crate
:
:
{
DateTime
Utc
}
;
use
super
:
:
MilliSecondsTimestampVisitor
;
pub
fn
serialize
<
S
>
(
dt
:
&
DateTime
<
Utc
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
serializer
.
serialize_i64
(
dt
.
timestamp_millis
(
)
)
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
DateTime
<
Utc
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_i64
(
MilliSecondsTimestampVisitor
)
.
map
(
|
dt
|
dt
.
with_timezone
(
&
Utc
)
)
}
impl
de
:
:
Visitor
<
'
_
>
for
MilliSecondsTimestampVisitor
{
type
Value
=
DateTime
<
Utc
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
milliseconds
"
)
}
fn
visit_i64
<
E
>
(
self
value
:
i64
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
DateTime
:
:
from_timestamp_millis
(
value
)
.
ok_or_else
(
|
|
invalid_ts
(
value
)
)
}
fn
visit_u64
<
E
>
(
self
value
:
u64
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
DateTime
:
:
from_timestamp
(
(
value
/
1000
)
as
i64
(
(
value
%
1000
)
*
1_000_000
)
as
u32
)
.
ok_or_else
(
|
|
invalid_ts
(
value
)
)
}
}
}
pub
mod
ts_milliseconds_option
{
use
core
:
:
fmt
;
use
serde
:
:
{
de
ser
}
;
use
super
:
:
MilliSecondsTimestampVisitor
;
use
crate
:
:
{
DateTime
Utc
}
;
pub
fn
serialize
<
S
>
(
opt
:
&
Option
<
DateTime
<
Utc
>
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
match
*
opt
{
Some
(
ref
dt
)
=
>
serializer
.
serialize_some
(
&
dt
.
timestamp_millis
(
)
)
None
=
>
serializer
.
serialize_none
(
)
}
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_option
(
OptionMilliSecondsTimestampVisitor
)
.
map
(
|
opt
|
opt
.
map
(
|
dt
|
dt
.
with_timezone
(
&
Utc
)
)
)
}
struct
OptionMilliSecondsTimestampVisitor
;
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
OptionMilliSecondsTimestampVisitor
{
type
Value
=
Option
<
DateTime
<
Utc
>
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
milliseconds
or
none
"
)
}
fn
visit_some
<
D
>
(
self
d
:
D
)
-
>
Result
<
Self
:
:
Value
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_i64
(
MilliSecondsTimestampVisitor
)
.
map
(
Some
)
}
fn
visit_none
<
E
>
(
self
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
None
)
}
fn
visit_unit
<
E
>
(
self
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
None
)
}
}
}
pub
mod
ts_seconds
{
use
core
:
:
fmt
;
use
serde
:
:
{
de
ser
}
;
use
crate
:
:
serde
:
:
invalid_ts
;
use
crate
:
:
{
DateTime
Utc
}
;
use
super
:
:
SecondsTimestampVisitor
;
pub
fn
serialize
<
S
>
(
dt
:
&
DateTime
<
Utc
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
serializer
.
serialize_i64
(
dt
.
timestamp
(
)
)
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
DateTime
<
Utc
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_i64
(
SecondsTimestampVisitor
)
}
impl
de
:
:
Visitor
<
'
_
>
for
SecondsTimestampVisitor
{
type
Value
=
DateTime
<
Utc
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
seconds
"
)
}
fn
visit_i64
<
E
>
(
self
value
:
i64
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
DateTime
:
:
from_timestamp_secs
(
value
)
.
ok_or_else
(
|
|
invalid_ts
(
value
)
)
}
fn
visit_u64
<
E
>
(
self
value
:
u64
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
if
value
>
i64
:
:
MAX
as
u64
{
Err
(
invalid_ts
(
value
)
)
}
else
{
DateTime
:
:
from_timestamp_secs
(
value
as
i64
)
.
ok_or_else
(
|
|
invalid_ts
(
value
)
)
}
}
}
}
pub
mod
ts_seconds_option
{
use
core
:
:
fmt
;
use
serde
:
:
{
de
ser
}
;
use
super
:
:
SecondsTimestampVisitor
;
use
crate
:
:
{
DateTime
Utc
}
;
pub
fn
serialize
<
S
>
(
opt
:
&
Option
<
DateTime
<
Utc
>
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
match
*
opt
{
Some
(
ref
dt
)
=
>
serializer
.
serialize_some
(
&
dt
.
timestamp
(
)
)
None
=
>
serializer
.
serialize_none
(
)
}
}
pub
fn
deserialize
<
'
de
D
>
(
d
:
D
)
-
>
Result
<
Option
<
DateTime
<
Utc
>
>
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_option
(
OptionSecondsTimestampVisitor
)
}
struct
OptionSecondsTimestampVisitor
;
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
OptionSecondsTimestampVisitor
{
type
Value
=
Option
<
DateTime
<
Utc
>
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
unix
timestamp
in
seconds
or
none
"
)
}
fn
visit_some
<
D
>
(
self
d
:
D
)
-
>
Result
<
Self
:
:
Value
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
d
.
deserialize_i64
(
SecondsTimestampVisitor
)
.
map
(
Some
)
}
fn
visit_none
<
E
>
(
self
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
None
)
}
fn
visit_unit
<
E
>
(
self
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
None
)
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
#
[
cfg
(
feature
=
"
clock
"
)
]
use
crate
:
:
Local
;
use
crate
:
:
{
DateTime
FixedOffset
TimeZone
Utc
}
;
use
core
:
:
fmt
;
#
[
test
]
fn
test_serde_serialize
(
)
{
assert_eq
!
(
serde_json
:
:
to_string
(
&
Utc
.
with_ymd_and_hms
(
2014
7
24
12
34
6
)
.
unwrap
(
)
)
.
ok
(
)
Some
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06Z
"
"
#
.
to_owned
(
)
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
FixedOffset
:
:
east_opt
(
3660
)
.
unwrap
(
)
.
with_ymd_and_hms
(
2014
7
24
12
34
6
)
.
unwrap
(
)
)
.
ok
(
)
Some
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06
+
01
:
01
"
"
#
.
to_owned
(
)
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
FixedOffset
:
:
east_opt
(
3650
)
.
unwrap
(
)
.
with_ymd_and_hms
(
2014
7
24
12
34
6
)
.
unwrap
(
)
)
.
ok
(
)
/
/
An
offset
with
seconds
is
not
allowed
by
RFC
3339
so
we
round
it
to
the
nearest
minute
.
/
/
In
this
case
+
01
:
00
:
50
becomes
+
01
:
01
Some
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06
+
01
:
01
"
"
#
.
to_owned
(
)
)
)
;
}
#
[
test
]
fn
test_serde_deserialize
(
)
{
fn
norm
<
Tz
:
TimeZone
>
(
dt
:
&
Option
<
DateTime
<
Tz
>
>
)
-
>
Option
<
(
&
DateTime
<
Tz
>
&
Tz
:
:
Offset
)
>
{
dt
.
as_ref
(
)
.
map
(
|
dt
|
(
dt
dt
.
offset
(
)
)
)
}
let
dt
:
Option
<
DateTime
<
Utc
>
>
=
serde_json
:
:
from_str
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06Z
"
"
#
)
.
ok
(
)
;
assert_eq
!
(
norm
(
&
dt
)
norm
(
&
Some
(
Utc
.
with_ymd_and_hms
(
2014
7
24
12
34
6
)
.
unwrap
(
)
)
)
)
;
let
dt
:
Option
<
DateTime
<
Utc
>
>
=
serde_json
:
:
from_str
(
r
#
"
"
2014
-
07
-
24T13
:
57
:
06
+
01
:
23
"
"
#
)
.
ok
(
)
;
assert_eq
!
(
norm
(
&
dt
)
norm
(
&
Some
(
Utc
.
with_ymd_and_hms
(
2014
7
24
12
34
6
)
.
unwrap
(
)
)
)
)
;
let
dt
:
Option
<
DateTime
<
FixedOffset
>
>
=
serde_json
:
:
from_str
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06Z
"
"
#
)
.
ok
(
)
;
assert_eq
!
(
norm
(
&
dt
)
norm
(
&
Some
(
FixedOffset
:
:
east_opt
(
0
)
.
unwrap
(
)
.
with_ymd_and_hms
(
2014
7
24
12
34
6
)
.
unwrap
(
)
)
)
)
;
let
dt
:
Option
<
DateTime
<
FixedOffset
>
>
=
serde_json
:
:
from_str
(
r
#
"
"
2014
-
07
-
24T13
:
57
:
06
+
01
:
23
"
"
#
)
.
ok
(
)
;
assert_eq
!
(
norm
(
&
dt
)
norm
(
&
Some
(
FixedOffset
:
:
east_opt
(
60
*
60
+
23
*
60
)
.
unwrap
(
)
.
with_ymd_and_hms
(
2014
7
24
13
57
6
)
.
unwrap
(
)
)
)
)
;
#
[
cfg
(
feature
=
"
clock
"
)
]
{
let
dt
:
DateTime
<
Local
>
=
serde_json
:
:
from_str
(
r
#
"
"
2014
-
07
-
24T12
:
34
:
06Z
"
"
#
)
.
expect
(
"
local
should
parse
"
)
;
assert_eq
!
(
dt
Utc
.
with_ymd_and_hms
(
2014
7
24
12
34
6
)
.
unwrap
(
)
)
;
let
dt
:
DateTime
<
Local
>
=
serde_json
:
:
from_str
(
r
#
"
"
2014
-
07
-
24T13
:
57
:
06
+
01
:
23
"
"
#
)
.
expect
(
"
local
should
parse
with
offset
"
)
;
assert_eq
!
(
dt
Utc
.
with_ymd_and_hms
(
2014
7
24
12
34
6
)
.
unwrap
(
)
)
;
}
assert
!
(
serde_json
:
:
from_str
:
:
<
DateTime
<
Utc
>
>
(
r
#
"
"
2014
-
07
-
32T12
:
34
:
06Z
"
"
#
)
.
is_err
(
)
)
;
assert
!
(
serde_json
:
:
from_str
:
:
<
DateTime
<
FixedOffset
>
>
(
r
#
"
"
2014
-
07
-
32T12
:
34
:
06Z
"
"
#
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
test_serde_bincode
(
)
{
use
bincode
:
:
{
deserialize
serialize
}
;
let
dt
=
Utc
.
with_ymd_and_hms
(
2014
7
24
12
34
6
)
.
unwrap
(
)
;
let
encoded
=
serialize
(
&
dt
)
.
unwrap
(
)
;
let
decoded
:
DateTime
<
Utc
>
=
deserialize
(
&
encoded
)
.
unwrap
(
)
;
assert_eq
!
(
dt
decoded
)
;
assert_eq
!
(
dt
.
offset
(
)
decoded
.
offset
(
)
)
;
}
#
[
test
]
fn
test_serde_no_offset_debug
(
)
{
use
crate
:
:
{
MappedLocalTime
NaiveDate
NaiveDateTime
Offset
}
;
use
core
:
:
fmt
:
:
Debug
;
#
[
derive
(
Clone
)
]
struct
TestTimeZone
;
impl
Debug
for
TestTimeZone
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
TEST
"
)
}
}
impl
TimeZone
for
TestTimeZone
{
type
Offset
=
TestTimeZone
;
fn
from_offset
(
_state
:
&
TestTimeZone
)
-
>
TestTimeZone
{
TestTimeZone
}
fn
offset_from_local_date
(
&
self
_local
:
&
NaiveDate
)
-
>
MappedLocalTime
<
TestTimeZone
>
{
MappedLocalTime
:
:
Single
(
TestTimeZone
)
}
fn
offset_from_local_datetime
(
&
self
_local
:
&
NaiveDateTime
)
-
>
MappedLocalTime
<
TestTimeZone
>
{
MappedLocalTime
:
:
Single
(
TestTimeZone
)
}
fn
offset_from_utc_date
(
&
self
_utc
:
&
NaiveDate
)
-
>
TestTimeZone
{
TestTimeZone
}
fn
offset_from_utc_datetime
(
&
self
_utc
:
&
NaiveDateTime
)
-
>
TestTimeZone
{
TestTimeZone
}
}
impl
Offset
for
TestTimeZone
{
fn
fix
(
&
self
)
-
>
FixedOffset
{
FixedOffset
:
:
east_opt
(
15
*
60
*
60
)
.
unwrap
(
)
}
}
let
tz
=
TestTimeZone
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
&
tz
)
"
TEST
"
)
;
let
dt
=
tz
.
with_ymd_and_hms
(
2023
4
24
21
10
33
)
.
unwrap
(
)
;
let
encoded
=
serde_json
:
:
to_string
(
&
dt
)
.
unwrap
(
)
;
dbg
!
(
&
encoded
)
;
let
decoded
:
DateTime
<
FixedOffset
>
=
serde_json
:
:
from_str
(
&
encoded
)
.
unwrap
(
)
;
assert_eq
!
(
dt
decoded
)
;
assert_eq
!
(
dt
.
offset
(
)
.
fix
(
)
*
decoded
.
offset
(
)
)
;
}
}
