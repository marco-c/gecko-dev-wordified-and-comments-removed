use
Weekday
;
use
super
:
:
{
ParseResult
TOO_SHORT
INVALID
OUT_OF_RANGE
}
;
fn
equals
(
s
:
&
str
pattern
:
&
str
)
-
>
bool
{
let
mut
xs
=
s
.
as_bytes
(
)
.
iter
(
)
.
map
(
|
&
c
|
match
c
{
b
'
A
'
.
.
.
b
'
Z
'
=
>
c
+
32
_
=
>
c
}
)
;
let
mut
ys
=
pattern
.
as_bytes
(
)
.
iter
(
)
.
cloned
(
)
;
loop
{
match
(
xs
.
next
(
)
ys
.
next
(
)
)
{
(
None
None
)
=
>
return
true
(
None
_
)
|
(
_
None
)
=
>
return
false
(
Some
(
x
)
Some
(
y
)
)
if
x
!
=
y
=
>
return
false
_
=
>
(
)
}
}
}
pub
fn
number
(
s
:
&
str
min
:
usize
max
:
usize
)
-
>
ParseResult
<
(
&
str
i64
)
>
{
assert
!
(
min
<
=
max
)
;
let
mut
window
=
s
.
as_bytes
(
)
;
if
window
.
len
(
)
>
max
{
window
=
&
window
[
.
.
max
]
;
}
let
upto
=
window
.
iter
(
)
.
position
(
|
&
c
|
c
<
b
'
0
'
|
|
b
'
9
'
<
c
)
.
unwrap_or_else
(
|
|
window
.
len
(
)
)
;
if
upto
<
min
{
return
Err
(
if
window
.
is_empty
(
)
{
TOO_SHORT
}
else
{
INVALID
}
)
;
}
let
v
:
i64
=
try
!
(
s
[
.
.
upto
]
.
parse
(
)
.
map_err
(
|
_
|
OUT_OF_RANGE
)
)
;
Ok
(
(
&
s
[
upto
.
.
]
v
)
)
}
pub
fn
nanosecond
(
s
:
&
str
)
-
>
ParseResult
<
(
&
str
i64
)
>
{
let
origlen
=
s
.
len
(
)
;
let
(
s
v
)
=
try
!
(
number
(
s
1
9
)
)
;
let
consumed
=
origlen
-
s
.
len
(
)
;
static
SCALE
:
[
i64
;
10
]
=
[
0
100_000_000
10_000_000
1_000_000
100_000
10_000
1_000
100
10
1
]
;
let
v
=
try
!
(
v
.
checked_mul
(
SCALE
[
consumed
]
)
.
ok_or
(
OUT_OF_RANGE
)
)
;
let
s
=
s
.
trim_left_matches
(
|
c
:
char
|
'
0
'
<
=
c
&
&
c
<
=
'
9
'
)
;
Ok
(
(
s
v
)
)
}
pub
fn
nanosecond_fixed
(
s
:
&
str
digits
:
usize
)
-
>
ParseResult
<
(
&
str
i64
)
>
{
let
(
s
v
)
=
try
!
(
number
(
s
digits
digits
)
)
;
static
SCALE
:
[
i64
;
10
]
=
[
0
100_000_000
10_000_000
1_000_000
100_000
10_000
1_000
100
10
1
]
;
let
v
=
try
!
(
v
.
checked_mul
(
SCALE
[
digits
]
)
.
ok_or
(
OUT_OF_RANGE
)
)
;
Ok
(
(
s
v
)
)
}
pub
fn
short_month0
(
s
:
&
str
)
-
>
ParseResult
<
(
&
str
u8
)
>
{
if
s
.
len
(
)
<
3
{
return
Err
(
TOO_SHORT
)
;
}
let
buf
=
s
.
as_bytes
(
)
;
let
month0
=
match
(
buf
[
0
]
|
32
buf
[
1
]
|
32
buf
[
2
]
|
32
)
{
(
b
'
j
'
b
'
a
'
b
'
n
'
)
=
>
0
(
b
'
f
'
b
'
e
'
b
'
b
'
)
=
>
1
(
b
'
m
'
b
'
a
'
b
'
r
'
)
=
>
2
(
b
'
a
'
b
'
p
'
b
'
r
'
)
=
>
3
(
b
'
m
'
b
'
a
'
b
'
y
'
)
=
>
4
(
b
'
j
'
b
'
u
'
b
'
n
'
)
=
>
5
(
b
'
j
'
b
'
u
'
b
'
l
'
)
=
>
6
(
b
'
a
'
b
'
u
'
b
'
g
'
)
=
>
7
(
b
'
s
'
b
'
e
'
b
'
p
'
)
=
>
8
(
b
'
o
'
b
'
c
'
b
'
t
'
)
=
>
9
(
b
'
n
'
b
'
o
'
b
'
v
'
)
=
>
10
(
b
'
d
'
b
'
e
'
b
'
c
'
)
=
>
11
_
=
>
return
Err
(
INVALID
)
}
;
Ok
(
(
&
s
[
3
.
.
]
month0
)
)
}
pub
fn
short_weekday
(
s
:
&
str
)
-
>
ParseResult
<
(
&
str
Weekday
)
>
{
if
s
.
len
(
)
<
3
{
return
Err
(
TOO_SHORT
)
;
}
let
buf
=
s
.
as_bytes
(
)
;
let
weekday
=
match
(
buf
[
0
]
|
32
buf
[
1
]
|
32
buf
[
2
]
|
32
)
{
(
b
'
m
'
b
'
o
'
b
'
n
'
)
=
>
Weekday
:
:
Mon
(
b
'
t
'
b
'
u
'
b
'
e
'
)
=
>
Weekday
:
:
Tue
(
b
'
w
'
b
'
e
'
b
'
d
'
)
=
>
Weekday
:
:
Wed
(
b
'
t
'
b
'
h
'
b
'
u
'
)
=
>
Weekday
:
:
Thu
(
b
'
f
'
b
'
r
'
b
'
i
'
)
=
>
Weekday
:
:
Fri
(
b
'
s
'
b
'
a
'
b
'
t
'
)
=
>
Weekday
:
:
Sat
(
b
'
s
'
b
'
u
'
b
'
n
'
)
=
>
Weekday
:
:
Sun
_
=
>
return
Err
(
INVALID
)
}
;
Ok
(
(
&
s
[
3
.
.
]
weekday
)
)
}
pub
fn
short_or_long_month0
(
s
:
&
str
)
-
>
ParseResult
<
(
&
str
u8
)
>
{
static
LONG_MONTH_SUFFIXES
:
[
&
'
static
str
;
12
]
=
[
"
uary
"
"
ruary
"
"
ch
"
"
il
"
"
"
"
e
"
"
y
"
"
ust
"
"
tember
"
"
ober
"
"
ember
"
"
ember
"
]
;
let
(
mut
s
month0
)
=
try
!
(
short_month0
(
s
)
)
;
let
suffix
=
LONG_MONTH_SUFFIXES
[
month0
as
usize
]
;
if
s
.
len
(
)
>
=
suffix
.
len
(
)
&
&
equals
(
&
s
[
.
.
suffix
.
len
(
)
]
suffix
)
{
s
=
&
s
[
suffix
.
len
(
)
.
.
]
;
}
Ok
(
(
s
month0
)
)
}
pub
fn
short_or_long_weekday
(
s
:
&
str
)
-
>
ParseResult
<
(
&
str
Weekday
)
>
{
static
LONG_WEEKDAY_SUFFIXES
:
[
&
'
static
str
;
7
]
=
[
"
day
"
"
sday
"
"
nesday
"
"
rsday
"
"
day
"
"
urday
"
"
day
"
]
;
let
(
mut
s
weekday
)
=
try
!
(
short_weekday
(
s
)
)
;
let
suffix
=
LONG_WEEKDAY_SUFFIXES
[
weekday
.
num_days_from_monday
(
)
as
usize
]
;
if
s
.
len
(
)
>
=
suffix
.
len
(
)
&
&
equals
(
&
s
[
.
.
suffix
.
len
(
)
]
suffix
)
{
s
=
&
s
[
suffix
.
len
(
)
.
.
]
;
}
Ok
(
(
s
weekday
)
)
}
pub
fn
char
(
s
:
&
str
c1
:
u8
)
-
>
ParseResult
<
&
str
>
{
match
s
.
as_bytes
(
)
.
first
(
)
{
Some
(
&
c
)
if
c
=
=
c1
=
>
Ok
(
&
s
[
1
.
.
]
)
Some
(
_
)
=
>
Err
(
INVALID
)
None
=
>
Err
(
TOO_SHORT
)
}
}
pub
fn
space
(
s
:
&
str
)
-
>
ParseResult
<
&
str
>
{
let
s_
=
s
.
trim_left
(
)
;
if
s_
.
len
(
)
<
s
.
len
(
)
{
Ok
(
s_
)
}
else
if
s
.
is_empty
(
)
{
Err
(
TOO_SHORT
)
}
else
{
Err
(
INVALID
)
}
}
pub
fn
colon_or_space
(
s
:
&
str
)
-
>
ParseResult
<
&
str
>
{
Ok
(
s
.
trim_left_matches
(
|
c
:
char
|
c
=
=
'
:
'
|
|
c
.
is_whitespace
(
)
)
)
}
pub
fn
timezone_offset
<
F
>
(
s
:
&
str
consume_colon
:
F
)
-
>
ParseResult
<
(
&
str
i32
)
>
where
F
:
FnMut
(
&
str
)
-
>
ParseResult
<
&
str
>
{
timezone_offset_internal
(
s
consume_colon
false
)
}
fn
timezone_offset_internal
<
F
>
(
mut
s
:
&
str
mut
consume_colon
:
F
allow_missing_minutes
:
bool
)
-
>
ParseResult
<
(
&
str
i32
)
>
where
F
:
FnMut
(
&
str
)
-
>
ParseResult
<
&
str
>
{
fn
digits
(
s
:
&
str
)
-
>
ParseResult
<
(
u8
u8
)
>
{
let
b
=
s
.
as_bytes
(
)
;
if
b
.
len
(
)
<
2
{
Err
(
TOO_SHORT
)
}
else
{
Ok
(
(
b
[
0
]
b
[
1
]
)
)
}
}
let
negative
=
match
s
.
as_bytes
(
)
.
first
(
)
{
Some
(
&
b
'
+
'
)
=
>
false
Some
(
&
b
'
-
'
)
=
>
true
Some
(
_
)
=
>
return
Err
(
INVALID
)
None
=
>
return
Err
(
TOO_SHORT
)
}
;
s
=
&
s
[
1
.
.
]
;
let
hours
=
match
try
!
(
digits
(
s
)
)
{
(
h1
b
'
0
'
.
.
.
b
'
9
'
h2
b
'
0
'
.
.
.
b
'
9
'
)
=
>
i32
:
:
from
(
(
h1
-
b
'
0
'
)
*
10
+
(
h2
-
b
'
0
'
)
)
_
=
>
return
Err
(
INVALID
)
}
;
s
=
&
s
[
2
.
.
]
;
s
=
try
!
(
consume_colon
(
s
)
)
;
let
minutes
=
if
let
Ok
(
ds
)
=
digits
(
s
)
{
match
ds
{
(
m1
b
'
0
'
.
.
.
b
'
5
'
m2
b
'
0
'
.
.
.
b
'
9
'
)
=
>
i32
:
:
from
(
(
m1
-
b
'
0
'
)
*
10
+
(
m2
-
b
'
0
'
)
)
(
b
'
6
'
.
.
.
b
'
9
'
b
'
0
'
.
.
.
b
'
9
'
)
=
>
return
Err
(
OUT_OF_RANGE
)
_
=
>
return
Err
(
INVALID
)
}
}
else
if
allow_missing_minutes
{
0
}
else
{
return
Err
(
TOO_SHORT
)
;
}
;
s
=
match
s
.
len
(
)
{
len
if
len
>
=
2
=
>
&
s
[
2
.
.
]
len
if
len
=
=
0
=
>
s
_
=
>
return
Err
(
TOO_SHORT
)
}
;
let
seconds
=
hours
*
3600
+
minutes
*
60
;
Ok
(
(
s
if
negative
{
-
seconds
}
else
{
seconds
}
)
)
}
pub
fn
timezone_offset_zulu
<
F
>
(
s
:
&
str
colon
:
F
)
-
>
ParseResult
<
(
&
str
i32
)
>
where
F
:
FnMut
(
&
str
)
-
>
ParseResult
<
&
str
>
{
match
s
.
as_bytes
(
)
.
first
(
)
{
Some
(
&
b
'
z
'
)
|
Some
(
&
b
'
Z
'
)
=
>
Ok
(
(
&
s
[
1
.
.
]
0
)
)
_
=
>
timezone_offset
(
s
colon
)
}
}
pub
fn
timezone_offset_permissive
<
F
>
(
s
:
&
str
colon
:
F
)
-
>
ParseResult
<
(
&
str
i32
)
>
where
F
:
FnMut
(
&
str
)
-
>
ParseResult
<
&
str
>
{
match
s
.
as_bytes
(
)
.
first
(
)
{
Some
(
&
b
'
z
'
)
|
Some
(
&
b
'
Z
'
)
=
>
Ok
(
(
&
s
[
1
.
.
]
0
)
)
_
=
>
timezone_offset_internal
(
s
colon
true
)
}
}
pub
fn
timezone_offset_2822
(
s
:
&
str
)
-
>
ParseResult
<
(
&
str
Option
<
i32
>
)
>
{
let
upto
=
s
.
as_bytes
(
)
.
iter
(
)
.
position
(
|
&
c
|
match
c
{
b
'
a
'
.
.
.
b
'
z
'
|
b
'
A
'
.
.
.
b
'
Z
'
=
>
false
_
=
>
true
}
)
.
unwrap_or_else
(
|
|
s
.
len
(
)
)
;
if
upto
>
0
{
let
name
=
&
s
[
.
.
upto
]
;
let
s
=
&
s
[
upto
.
.
]
;
let
offset_hours
=
|
o
|
Ok
(
(
s
Some
(
o
*
3600
)
)
)
;
if
equals
(
name
"
gmt
"
)
|
|
equals
(
name
"
ut
"
)
{
offset_hours
(
0
)
}
else
if
equals
(
name
"
edt
"
)
{
offset_hours
(
-
4
)
}
else
if
equals
(
name
"
est
"
)
|
|
equals
(
name
"
cdt
"
)
{
offset_hours
(
-
5
)
}
else
if
equals
(
name
"
cst
"
)
|
|
equals
(
name
"
mdt
"
)
{
offset_hours
(
-
6
)
}
else
if
equals
(
name
"
mst
"
)
|
|
equals
(
name
"
pdt
"
)
{
offset_hours
(
-
7
)
}
else
if
equals
(
name
"
pst
"
)
{
offset_hours
(
-
8
)
}
else
{
Ok
(
(
s
None
)
)
}
}
else
{
let
(
s_
offset
)
=
try
!
(
timezone_offset
(
s
|
s
|
Ok
(
s
)
)
)
;
if
offset
=
=
0
&
&
s
.
starts_with
(
'
-
'
)
{
Ok
(
(
s_
None
)
)
}
else
{
Ok
(
(
s_
Some
(
offset
)
)
)
}
}
}
