use
std
:
:
fmt
;
use
std
:
:
error
:
:
Error
;
use
{
Datelike
Timelike
}
;
use
div
:
:
{
div_floor
mod_floor
}
;
use
duration
:
:
Duration
;
use
offset
:
:
Offset
;
use
naive
:
:
date
:
:
NaiveDate
;
use
naive
:
:
time
:
:
NaiveTime
;
pub
use
self
:
:
strftime
:
:
StrftimeItems
;
pub
use
self
:
:
parsed
:
:
Parsed
;
pub
use
self
:
:
parse
:
:
parse
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
enum
Pad
{
None
Zero
Space
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
enum
Numeric
{
Year
YearDiv100
YearMod100
IsoYear
IsoYearDiv100
IsoYearMod100
Month
Day
WeekFromSun
WeekFromMon
IsoWeek
NumDaysFromSun
WeekdayFromMon
Ordinal
Hour
Hour12
Minute
Second
Nanosecond
Timestamp
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
enum
Fixed
{
ShortMonthName
LongMonthName
ShortWeekdayName
LongWeekdayName
LowerAmPm
UpperAmPm
Nanosecond
Nanosecond3
Nanosecond6
Nanosecond9
TimezoneName
TimezoneOffsetColon
TimezoneOffsetColonZ
TimezoneOffset
TimezoneOffsetZ
RFC2822
RFC3339
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
enum
Item
<
'
a
>
{
Literal
(
&
'
a
str
)
Space
(
&
'
a
str
)
Numeric
(
Numeric
Pad
)
Fixed
(
Fixed
)
Error
}
macro_rules
!
lit
{
(
x
:
expr
)
=
>
(
Item
:
:
Literal
(
x
)
)
}
macro_rules
!
sp
{
(
x
:
expr
)
=
>
(
Item
:
:
Space
(
x
)
)
}
macro_rules
!
num
{
(
x
:
ident
)
=
>
(
Item
:
:
Numeric
(
Numeric
:
:
x
Pad
:
:
None
)
)
}
macro_rules
!
num0
{
(
x
:
ident
)
=
>
(
Item
:
:
Numeric
(
Numeric
:
:
x
Pad
:
:
Zero
)
)
}
macro_rules
!
nums
{
(
x
:
ident
)
=
>
(
Item
:
:
Numeric
(
Numeric
:
:
x
Pad
:
:
Space
)
)
}
macro_rules
!
fix
{
(
x
:
ident
)
=
>
(
Item
:
:
Fixed
(
Fixed
:
:
x
)
)
}
#
[
derive
(
Debug
Clone
PartialEq
Copy
)
]
pub
struct
ParseError
(
ParseErrorKind
)
;
#
[
derive
(
Debug
Clone
PartialEq
Copy
)
]
enum
ParseErrorKind
{
OutOfRange
Impossible
NotEnough
Invalid
TooShort
TooLong
BadFormat
}
pub
type
ParseResult
<
T
>
=
Result
<
T
ParseError
>
;
impl
fmt
:
:
Display
for
ParseError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
description
(
)
.
fmt
(
f
)
}
}
impl
Error
for
ParseError
{
fn
description
(
&
self
)
-
>
&
str
{
match
self
.
0
{
ParseErrorKind
:
:
OutOfRange
=
>
"
input
is
out
of
range
"
ParseErrorKind
:
:
Impossible
=
>
"
no
possible
date
and
time
matching
input
"
ParseErrorKind
:
:
NotEnough
=
>
"
input
is
not
enough
for
unique
date
and
time
"
ParseErrorKind
:
:
Invalid
=
>
"
input
contains
invalid
characters
"
ParseErrorKind
:
:
TooShort
=
>
"
premature
end
of
input
"
ParseErrorKind
:
:
TooLong
=
>
"
trailing
input
"
ParseErrorKind
:
:
BadFormat
=
>
"
bad
or
unsupported
format
string
"
}
}
}
const
OUT_OF_RANGE
:
ParseError
=
ParseError
(
ParseErrorKind
:
:
OutOfRange
)
;
const
IMPOSSIBLE
:
ParseError
=
ParseError
(
ParseErrorKind
:
:
Impossible
)
;
const
NOT_ENOUGH
:
ParseError
=
ParseError
(
ParseErrorKind
:
:
NotEnough
)
;
const
INVALID
:
ParseError
=
ParseError
(
ParseErrorKind
:
:
Invalid
)
;
const
TOO_SHORT
:
ParseError
=
ParseError
(
ParseErrorKind
:
:
TooShort
)
;
const
TOO_LONG
:
ParseError
=
ParseError
(
ParseErrorKind
:
:
TooLong
)
;
const
BAD_FORMAT
:
ParseError
=
ParseError
(
ParseErrorKind
:
:
BadFormat
)
;
pub
fn
format
<
'
a
I
>
(
w
:
&
mut
fmt
:
:
Formatter
date
:
Option
<
&
NaiveDate
>
time
:
Option
<
&
NaiveTime
>
off
:
Option
<
&
(
String
Duration
)
>
items
:
I
)
-
>
fmt
:
:
Result
where
I
:
Iterator
<
Item
=
Item
<
'
a
>
>
{
static
SHORT_MONTHS
:
[
&
'
static
str
;
12
]
=
[
"
Jan
"
"
Feb
"
"
Mar
"
"
Apr
"
"
May
"
"
Jun
"
"
Jul
"
"
Aug
"
"
Sep
"
"
Oct
"
"
Nov
"
"
Dec
"
]
;
static
LONG_MONTHS
:
[
&
'
static
str
;
12
]
=
[
"
January
"
"
February
"
"
March
"
"
April
"
"
May
"
"
June
"
"
July
"
"
August
"
"
September
"
"
October
"
"
November
"
"
December
"
]
;
static
SHORT_WEEKDAYS
:
[
&
'
static
str
;
7
]
=
[
"
Mon
"
"
Tue
"
"
Wed
"
"
Thu
"
"
Fri
"
"
Sat
"
"
Sun
"
]
;
static
LONG_WEEKDAYS
:
[
&
'
static
str
;
7
]
=
[
"
Monday
"
"
Tuesday
"
"
Wednesday
"
"
Thursday
"
"
Friday
"
"
Saturday
"
"
Sunday
"
]
;
for
item
in
items
{
match
item
{
Item
:
:
Literal
(
s
)
|
Item
:
:
Space
(
s
)
=
>
try
!
(
write
!
(
w
"
{
}
"
s
)
)
Item
:
:
Numeric
(
spec
pad
)
=
>
{
use
self
:
:
Numeric
:
:
*
;
let
week_from_sun
=
|
d
:
&
NaiveDate
|
(
d
.
ordinal
(
)
as
i32
-
d
.
weekday
(
)
.
num_days_from_sunday
(
)
as
i32
+
7
)
/
7
;
let
week_from_mon
=
|
d
:
&
NaiveDate
|
(
d
.
ordinal
(
)
as
i32
-
d
.
weekday
(
)
.
num_days_from_monday
(
)
as
i32
+
7
)
/
7
;
let
(
width
v
)
=
match
spec
{
Year
=
>
(
4
date
.
map
(
|
d
|
d
.
year
(
)
as
i64
)
)
YearDiv100
=
>
(
2
date
.
map
(
|
d
|
div_floor
(
d
.
year
(
)
as
i64
100
)
)
)
YearMod100
=
>
(
2
date
.
map
(
|
d
|
mod_floor
(
d
.
year
(
)
as
i64
100
)
)
)
IsoYear
=
>
(
4
date
.
map
(
|
d
|
d
.
isoweekdate
(
)
.
0
as
i64
)
)
IsoYearDiv100
=
>
(
2
date
.
map
(
|
d
|
div_floor
(
d
.
isoweekdate
(
)
.
0
as
i64
100
)
)
)
IsoYearMod100
=
>
(
2
date
.
map
(
|
d
|
mod_floor
(
d
.
isoweekdate
(
)
.
0
as
i64
100
)
)
)
Month
=
>
(
2
date
.
map
(
|
d
|
d
.
month
(
)
as
i64
)
)
Day
=
>
(
2
date
.
map
(
|
d
|
d
.
day
(
)
as
i64
)
)
WeekFromSun
=
>
(
2
date
.
map
(
|
d
|
week_from_sun
(
d
)
as
i64
)
)
WeekFromMon
=
>
(
2
date
.
map
(
|
d
|
week_from_mon
(
d
)
as
i64
)
)
IsoWeek
=
>
(
2
date
.
map
(
|
d
|
d
.
isoweekdate
(
)
.
1
as
i64
)
)
NumDaysFromSun
=
>
(
1
date
.
map
(
|
d
|
d
.
weekday
(
)
.
num_days_from_sunday
(
)
as
i64
)
)
WeekdayFromMon
=
>
(
1
date
.
map
(
|
d
|
d
.
weekday
(
)
.
number_from_monday
(
)
as
i64
)
)
Ordinal
=
>
(
3
date
.
map
(
|
d
|
d
.
ordinal
(
)
as
i64
)
)
Hour
=
>
(
2
time
.
map
(
|
t
|
t
.
hour
(
)
as
i64
)
)
Hour12
=
>
(
2
time
.
map
(
|
t
|
t
.
hour12
(
)
.
1
as
i64
)
)
Minute
=
>
(
2
time
.
map
(
|
t
|
t
.
minute
(
)
as
i64
)
)
Second
=
>
(
2
time
.
map
(
|
t
|
(
t
.
second
(
)
+
t
.
nanosecond
(
)
/
1_000_000_000
)
as
i64
)
)
Nanosecond
=
>
(
9
time
.
map
(
|
t
|
(
t
.
nanosecond
(
)
%
1_000_000_000
)
as
i64
)
)
Timestamp
=
>
(
1
match
(
date
time
off
)
{
(
Some
(
d
)
Some
(
t
)
None
)
=
>
Some
(
d
.
and_time
(
*
t
)
.
timestamp
(
)
)
(
Some
(
d
)
Some
(
t
)
Some
(
&
(
_
off
)
)
)
=
>
Some
(
(
d
.
and_time
(
*
t
)
-
off
)
.
timestamp
(
)
)
(
_
_
_
)
=
>
None
}
)
}
;
if
let
Some
(
v
)
=
v
{
if
(
spec
=
=
Year
|
|
spec
=
=
IsoYear
)
&
&
!
(
0
<
=
v
&
&
v
<
10000
)
{
match
pad
{
Pad
:
:
None
=
>
try
!
(
write
!
(
w
"
{
:
+
}
"
v
)
)
Pad
:
:
Zero
=
>
try
!
(
write
!
(
w
"
{
:
+
01
}
"
v
width
+
1
)
)
Pad
:
:
Space
=
>
try
!
(
write
!
(
w
"
{
:
+
1
}
"
v
width
+
1
)
)
}
}
else
{
match
pad
{
Pad
:
:
None
=
>
try
!
(
write
!
(
w
"
{
}
"
v
)
)
Pad
:
:
Zero
=
>
try
!
(
write
!
(
w
"
{
:
01
}
"
v
width
)
)
Pad
:
:
Space
=
>
try
!
(
write
!
(
w
"
{
:
1
}
"
v
width
)
)
}
}
}
else
{
return
Err
(
fmt
:
:
Error
)
;
}
}
Item
:
:
Fixed
(
spec
)
=
>
{
use
self
:
:
Fixed
:
:
*
;
fn
write_local_minus_utc
(
w
:
&
mut
fmt
:
:
Formatter
off
:
Duration
allow_zulu
:
bool
use_colon
:
bool
)
-
>
fmt
:
:
Result
{
let
off
=
off
.
num_minutes
(
)
;
if
!
allow_zulu
|
|
off
!
=
0
{
let
(
sign
off
)
=
if
off
<
0
{
(
'
-
'
-
off
)
}
else
{
(
'
+
'
off
)
}
;
if
use_colon
{
write
!
(
w
"
{
}
{
:
02
}
:
{
:
02
}
"
sign
off
/
60
off
%
60
)
}
else
{
write
!
(
w
"
{
}
{
:
02
}
{
:
02
}
"
sign
off
/
60
off
%
60
)
}
}
else
{
write
!
(
w
"
Z
"
)
}
}
let
ret
=
match
spec
{
ShortMonthName
=
>
date
.
map
(
|
d
|
write
!
(
w
"
{
}
"
SHORT_MONTHS
[
d
.
month0
(
)
as
usize
]
)
)
LongMonthName
=
>
date
.
map
(
|
d
|
write
!
(
w
"
{
}
"
LONG_MONTHS
[
d
.
month0
(
)
as
usize
]
)
)
ShortWeekdayName
=
>
date
.
map
(
|
d
|
write
!
(
w
"
{
}
"
SHORT_WEEKDAYS
[
d
.
weekday
(
)
.
num_days_from_monday
(
)
as
usize
]
)
)
LongWeekdayName
=
>
date
.
map
(
|
d
|
write
!
(
w
"
{
}
"
LONG_WEEKDAYS
[
d
.
weekday
(
)
.
num_days_from_monday
(
)
as
usize
]
)
)
LowerAmPm
=
>
time
.
map
(
|
t
|
write
!
(
w
"
{
}
"
if
t
.
hour12
(
)
.
0
{
"
pm
"
}
else
{
"
am
"
}
)
)
UpperAmPm
=
>
time
.
map
(
|
t
|
write
!
(
w
"
{
}
"
if
t
.
hour12
(
)
.
0
{
"
PM
"
}
else
{
"
AM
"
}
)
)
Nanosecond
=
>
time
.
map
(
|
t
|
{
let
nano
=
t
.
nanosecond
(
)
%
1_000_000_000
;
if
nano
=
=
0
{
Ok
(
(
)
)
}
else
if
nano
%
1_000_000
=
=
0
{
write
!
(
w
"
.
{
:
03
}
"
nano
/
1_000_000
)
}
else
if
nano
%
1_000
=
=
0
{
write
!
(
w
"
.
{
:
06
}
"
nano
/
1_000
)
}
else
{
write
!
(
w
"
.
{
:
09
}
"
nano
)
}
}
)
Nanosecond3
=
>
time
.
map
(
|
t
|
{
let
nano
=
t
.
nanosecond
(
)
%
1_000_000_000
;
write
!
(
w
"
.
{
:
03
}
"
nano
/
1_000_000
)
}
)
Nanosecond6
=
>
time
.
map
(
|
t
|
{
let
nano
=
t
.
nanosecond
(
)
%
1_000_000_000
;
write
!
(
w
"
.
{
:
06
}
"
nano
/
1_000
)
}
)
Nanosecond9
=
>
time
.
map
(
|
t
|
{
let
nano
=
t
.
nanosecond
(
)
%
1_000_000_000
;
write
!
(
w
"
.
{
:
09
}
"
nano
)
}
)
TimezoneName
=
>
off
.
map
(
|
&
(
ref
name
_
)
|
write
!
(
w
"
{
}
"
*
name
)
)
TimezoneOffsetColon
=
>
off
.
map
(
|
&
(
_
off
)
|
write_local_minus_utc
(
w
off
false
true
)
)
TimezoneOffsetColonZ
=
>
off
.
map
(
|
&
(
_
off
)
|
write_local_minus_utc
(
w
off
true
true
)
)
TimezoneOffset
=
>
off
.
map
(
|
&
(
_
off
)
|
write_local_minus_utc
(
w
off
false
false
)
)
TimezoneOffsetZ
=
>
off
.
map
(
|
&
(
_
off
)
|
write_local_minus_utc
(
w
off
true
false
)
)
RFC2822
=
>
if
let
(
Some
(
d
)
Some
(
t
)
Some
(
&
(
_
off
)
)
)
=
(
date
time
off
)
{
let
sec
=
t
.
second
(
)
+
t
.
nanosecond
(
)
/
1_000_000_000
;
try
!
(
write
!
(
w
"
{
}
{
:
2
}
{
}
{
:
04
}
{
:
02
}
:
{
:
02
}
:
{
:
02
}
"
SHORT_WEEKDAYS
[
d
.
weekday
(
)
.
num_days_from_monday
(
)
as
usize
]
d
.
day
(
)
SHORT_MONTHS
[
d
.
month0
(
)
as
usize
]
d
.
year
(
)
t
.
hour
(
)
t
.
minute
(
)
sec
)
)
;
Some
(
write_local_minus_utc
(
w
off
false
false
)
)
}
else
{
None
}
RFC3339
=
>
if
let
(
Some
(
d
)
Some
(
t
)
Some
(
&
(
_
off
)
)
)
=
(
date
time
off
)
{
try
!
(
write
!
(
w
"
{
:
?
}
T
{
:
?
}
"
d
t
)
)
;
Some
(
write_local_minus_utc
(
w
off
false
true
)
)
}
else
{
None
}
}
;
match
ret
{
Some
(
ret
)
=
>
try
!
(
ret
)
None
=
>
return
Err
(
fmt
:
:
Error
)
}
}
Item
:
:
Error
=
>
return
Err
(
fmt
:
:
Error
)
}
}
Ok
(
(
)
)
}
pub
mod
parsed
;
mod
scan
;
mod
parse
;
pub
mod
strftime
;
#
[
derive
(
Debug
)
]
pub
struct
DelayedFormat
<
I
>
{
date
:
Option
<
NaiveDate
>
time
:
Option
<
NaiveTime
>
off
:
Option
<
(
String
Duration
)
>
items
:
I
}
impl
<
'
a
I
:
Iterator
<
Item
=
Item
<
'
a
>
>
+
Clone
>
DelayedFormat
<
I
>
{
pub
fn
new
(
date
:
Option
<
NaiveDate
>
time
:
Option
<
NaiveTime
>
items
:
I
)
-
>
DelayedFormat
<
I
>
{
DelayedFormat
{
date
:
date
time
:
time
off
:
None
items
:
items
}
}
pub
fn
new_with_offset
<
Off
>
(
date
:
Option
<
NaiveDate
>
time
:
Option
<
NaiveTime
>
offset
:
&
Off
items
:
I
)
-
>
DelayedFormat
<
I
>
where
Off
:
Offset
+
fmt
:
:
Display
{
let
name_and_diff
=
(
offset
.
to_string
(
)
offset
.
local_minus_utc
(
)
)
;
DelayedFormat
{
date
:
date
time
:
time
off
:
Some
(
name_and_diff
)
items
:
items
}
}
}
impl
<
'
a
I
:
Iterator
<
Item
=
Item
<
'
a
>
>
+
Clone
>
fmt
:
:
Display
for
DelayedFormat
<
I
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
format
(
f
self
.
date
.
as_ref
(
)
self
.
time
.
as_ref
(
)
self
.
off
.
as_ref
(
)
self
.
items
.
clone
(
)
)
}
}
