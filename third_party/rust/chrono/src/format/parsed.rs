use
super
:
:
{
IMPOSSIBLE
NOT_ENOUGH
OUT_OF_RANGE
ParseResult
}
;
use
crate
:
:
naive
:
:
{
NaiveDate
NaiveDateTime
NaiveTime
}
;
use
crate
:
:
offset
:
:
{
FixedOffset
MappedLocalTime
Offset
TimeZone
}
;
use
crate
:
:
{
DateTime
Datelike
TimeDelta
Timelike
Weekday
}
;
#
[
allow
(
clippy
:
:
manual_non_exhaustive
)
]
#
[
derive
(
Clone
PartialEq
Eq
Debug
Default
Hash
)
]
pub
struct
Parsed
{
#
[
doc
(
hidden
)
]
pub
year
:
Option
<
i32
>
#
[
doc
(
hidden
)
]
pub
year_div_100
:
Option
<
i32
>
#
[
doc
(
hidden
)
]
pub
year_mod_100
:
Option
<
i32
>
#
[
doc
(
hidden
)
]
pub
isoyear
:
Option
<
i32
>
#
[
doc
(
hidden
)
]
pub
isoyear_div_100
:
Option
<
i32
>
#
[
doc
(
hidden
)
]
pub
isoyear_mod_100
:
Option
<
i32
>
#
[
doc
(
hidden
)
]
pub
quarter
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
month
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
week_from_sun
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
week_from_mon
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
isoweek
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
weekday
:
Option
<
Weekday
>
#
[
doc
(
hidden
)
]
pub
ordinal
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
day
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
hour_div_12
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
hour_mod_12
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
minute
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
second
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
nanosecond
:
Option
<
u32
>
#
[
doc
(
hidden
)
]
pub
timestamp
:
Option
<
i64
>
#
[
doc
(
hidden
)
]
pub
offset
:
Option
<
i32
>
#
[
doc
(
hidden
)
]
_dummy
:
(
)
}
#
[
inline
]
fn
set_if_consistent
<
T
:
PartialEq
>
(
old
:
&
mut
Option
<
T
>
new
:
T
)
-
>
ParseResult
<
(
)
>
{
match
old
{
Some
(
old
)
if
*
old
!
=
new
=
>
Err
(
IMPOSSIBLE
)
_
=
>
{
*
old
=
Some
(
new
)
;
Ok
(
(
)
)
}
}
}
impl
Parsed
{
#
[
must_use
]
pub
fn
new
(
)
-
>
Parsed
{
Parsed
:
:
default
(
)
}
#
[
inline
]
pub
fn
set_year
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
set_if_consistent
(
&
mut
self
.
year
i32
:
:
try_from
(
value
)
.
map_err
(
|
_
|
OUT_OF_RANGE
)
?
)
}
#
[
inline
]
pub
fn
set_year_div_100
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
0
.
.
=
i32
:
:
MAX
as
i64
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
year_div_100
value
as
i32
)
}
#
[
inline
]
pub
fn
set_year_mod_100
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
0
.
.
100
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
year_mod_100
value
as
i32
)
}
#
[
inline
]
pub
fn
set_isoyear
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
set_if_consistent
(
&
mut
self
.
isoyear
i32
:
:
try_from
(
value
)
.
map_err
(
|
_
|
OUT_OF_RANGE
)
?
)
}
#
[
inline
]
pub
fn
set_isoyear_div_100
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
0
.
.
=
i32
:
:
MAX
as
i64
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
isoyear_div_100
value
as
i32
)
}
#
[
inline
]
pub
fn
set_isoyear_mod_100
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
0
.
.
100
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
isoyear_mod_100
value
as
i32
)
}
#
[
inline
]
pub
fn
set_quarter
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
1
.
.
=
4
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
quarter
value
as
u32
)
}
#
[
inline
]
pub
fn
set_month
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
1
.
.
=
12
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
month
value
as
u32
)
}
#
[
inline
]
pub
fn
set_week_from_sun
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
0
.
.
=
53
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
week_from_sun
value
as
u32
)
}
#
[
inline
]
pub
fn
set_week_from_mon
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
0
.
.
=
53
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
week_from_mon
value
as
u32
)
}
#
[
inline
]
pub
fn
set_isoweek
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
1
.
.
=
53
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
isoweek
value
as
u32
)
}
#
[
inline
]
pub
fn
set_weekday
(
&
mut
self
value
:
Weekday
)
-
>
ParseResult
<
(
)
>
{
set_if_consistent
(
&
mut
self
.
weekday
value
)
}
#
[
inline
]
pub
fn
set_ordinal
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
1
.
.
=
366
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
ordinal
value
as
u32
)
}
#
[
inline
]
pub
fn
set_day
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
1
.
.
=
31
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
day
value
as
u32
)
}
#
[
inline
]
pub
fn
set_ampm
(
&
mut
self
value
:
bool
)
-
>
ParseResult
<
(
)
>
{
set_if_consistent
(
&
mut
self
.
hour_div_12
value
as
u32
)
}
#
[
inline
]
pub
fn
set_hour12
(
&
mut
self
mut
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
1
.
.
=
12
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
if
value
=
=
12
{
value
=
0
}
set_if_consistent
(
&
mut
self
.
hour_mod_12
value
as
u32
)
}
#
[
inline
]
pub
fn
set_hour
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
let
(
hour_div_12
hour_mod_12
)
=
match
value
{
hour
0
.
.
=
11
=
>
(
0
hour
as
u32
)
hour
12
.
.
=
23
=
>
(
1
hour
as
u32
-
12
)
_
=
>
return
Err
(
OUT_OF_RANGE
)
}
;
set_if_consistent
(
&
mut
self
.
hour_div_12
hour_div_12
)
?
;
set_if_consistent
(
&
mut
self
.
hour_mod_12
hour_mod_12
)
}
#
[
inline
]
pub
fn
set_minute
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
0
.
.
=
59
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
minute
value
as
u32
)
}
#
[
inline
]
pub
fn
set_second
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
0
.
.
=
60
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
second
value
as
u32
)
}
#
[
inline
]
pub
fn
set_nanosecond
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
if
!
(
0
.
.
=
999_999_999
)
.
contains
(
&
value
)
{
return
Err
(
OUT_OF_RANGE
)
;
}
set_if_consistent
(
&
mut
self
.
nanosecond
value
as
u32
)
}
#
[
inline
]
pub
fn
set_timestamp
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
set_if_consistent
(
&
mut
self
.
timestamp
value
)
}
#
[
inline
]
pub
fn
set_offset
(
&
mut
self
value
:
i64
)
-
>
ParseResult
<
(
)
>
{
set_if_consistent
(
&
mut
self
.
offset
i32
:
:
try_from
(
value
)
.
map_err
(
|
_
|
OUT_OF_RANGE
)
?
)
}
pub
fn
to_naive_date
(
&
self
)
-
>
ParseResult
<
NaiveDate
>
{
fn
resolve_year
(
y
:
Option
<
i32
>
q
:
Option
<
i32
>
r
:
Option
<
i32
>
)
-
>
ParseResult
<
Option
<
i32
>
>
{
match
(
y
q
r
)
{
(
y
None
None
)
=
>
Ok
(
y
)
(
Some
(
y
)
q
r
Some
(
0
.
.
=
99
)
)
|
(
Some
(
y
)
q
r
None
)
=
>
{
if
y
<
0
{
return
Err
(
IMPOSSIBLE
)
;
}
let
q_
=
y
/
100
;
let
r_
=
y
%
100
;
if
q
.
unwrap_or
(
q_
)
=
=
q_
&
&
r
.
unwrap_or
(
r_
)
=
=
r_
{
Ok
(
Some
(
y
)
)
}
else
{
Err
(
IMPOSSIBLE
)
}
}
(
None
Some
(
q
)
Some
(
r
0
.
.
=
99
)
)
=
>
{
if
q
<
0
{
return
Err
(
IMPOSSIBLE
)
;
}
let
y
=
q
.
checked_mul
(
100
)
.
and_then
(
|
v
|
v
.
checked_add
(
r
)
)
;
Ok
(
Some
(
y
.
ok_or
(
OUT_OF_RANGE
)
?
)
)
}
(
None
None
Some
(
r
0
.
.
=
99
)
)
=
>
Ok
(
Some
(
r
+
if
r
<
70
{
2000
}
else
{
1900
}
)
)
(
None
Some
(
_
)
None
)
=
>
Err
(
NOT_ENOUGH
)
(
_
_
Some
(
_
)
)
=
>
Err
(
OUT_OF_RANGE
)
}
}
let
given_year
=
resolve_year
(
self
.
year
self
.
year_div_100
self
.
year_mod_100
)
?
;
let
given_isoyear
=
resolve_year
(
self
.
isoyear
self
.
isoyear_div_100
self
.
isoyear_mod_100
)
?
;
let
verify_ymd
=
|
date
:
NaiveDate
|
{
let
year
=
date
.
year
(
)
;
let
(
year_div_100
year_mod_100
)
=
if
year
>
=
0
{
(
Some
(
year
/
100
)
Some
(
year
%
100
)
)
}
else
{
(
None
None
)
}
;
let
month
=
date
.
month
(
)
;
let
day
=
date
.
day
(
)
;
self
.
year
.
unwrap_or
(
year
)
=
=
year
&
&
self
.
year_div_100
.
or
(
year_div_100
)
=
=
year_div_100
&
&
self
.
year_mod_100
.
or
(
year_mod_100
)
=
=
year_mod_100
&
&
self
.
month
.
unwrap_or
(
month
)
=
=
month
&
&
self
.
day
.
unwrap_or
(
day
)
=
=
day
}
;
let
verify_isoweekdate
=
|
date
:
NaiveDate
|
{
let
week
=
date
.
iso_week
(
)
;
let
isoyear
=
week
.
year
(
)
;
let
isoweek
=
week
.
week
(
)
;
let
weekday
=
date
.
weekday
(
)
;
let
(
isoyear_div_100
isoyear_mod_100
)
=
if
isoyear
>
=
0
{
(
Some
(
isoyear
/
100
)
Some
(
isoyear
%
100
)
)
}
else
{
(
None
None
)
}
;
self
.
isoyear
.
unwrap_or
(
isoyear
)
=
=
isoyear
&
&
self
.
isoyear_div_100
.
or
(
isoyear_div_100
)
=
=
isoyear_div_100
&
&
self
.
isoyear_mod_100
.
or
(
isoyear_mod_100
)
=
=
isoyear_mod_100
&
&
self
.
isoweek
.
unwrap_or
(
isoweek
)
=
=
isoweek
&
&
self
.
weekday
.
unwrap_or
(
weekday
)
=
=
weekday
}
;
let
verify_ordinal
=
|
date
:
NaiveDate
|
{
let
ordinal
=
date
.
ordinal
(
)
;
let
week_from_sun
=
date
.
weeks_from
(
Weekday
:
:
Sun
)
;
let
week_from_mon
=
date
.
weeks_from
(
Weekday
:
:
Mon
)
;
self
.
ordinal
.
unwrap_or
(
ordinal
)
=
=
ordinal
&
&
self
.
week_from_sun
.
map_or
(
week_from_sun
|
v
|
v
as
i32
)
=
=
week_from_sun
&
&
self
.
week_from_mon
.
map_or
(
week_from_mon
|
v
|
v
as
i32
)
=
=
week_from_mon
}
;
let
(
verified
parsed_date
)
=
match
(
given_year
given_isoyear
self
)
{
(
Some
(
year
)
_
&
Parsed
{
month
:
Some
(
month
)
day
:
Some
(
day
)
.
.
}
)
=
>
{
let
date
=
NaiveDate
:
:
from_ymd_opt
(
year
month
day
)
.
ok_or
(
OUT_OF_RANGE
)
?
;
(
verify_isoweekdate
(
date
)
&
&
verify_ordinal
(
date
)
date
)
}
(
Some
(
year
)
_
&
Parsed
{
ordinal
:
Some
(
ordinal
)
.
.
}
)
=
>
{
let
date
=
NaiveDate
:
:
from_yo_opt
(
year
ordinal
)
.
ok_or
(
OUT_OF_RANGE
)
?
;
(
verify_ymd
(
date
)
&
&
verify_isoweekdate
(
date
)
&
&
verify_ordinal
(
date
)
date
)
}
(
Some
(
year
)
_
&
Parsed
{
week_from_sun
:
Some
(
week
)
weekday
:
Some
(
weekday
)
.
.
}
)
=
>
{
let
date
=
resolve_week_date
(
year
week
weekday
Weekday
:
:
Sun
)
?
;
(
verify_ymd
(
date
)
&
&
verify_isoweekdate
(
date
)
&
&
verify_ordinal
(
date
)
date
)
}
(
Some
(
year
)
_
&
Parsed
{
week_from_mon
:
Some
(
week
)
weekday
:
Some
(
weekday
)
.
.
}
)
=
>
{
let
date
=
resolve_week_date
(
year
week
weekday
Weekday
:
:
Mon
)
?
;
(
verify_ymd
(
date
)
&
&
verify_isoweekdate
(
date
)
&
&
verify_ordinal
(
date
)
date
)
}
(
_
Some
(
isoyear
)
&
Parsed
{
isoweek
:
Some
(
isoweek
)
weekday
:
Some
(
weekday
)
.
.
}
)
=
>
{
let
date
=
NaiveDate
:
:
from_isoywd_opt
(
isoyear
isoweek
weekday
)
;
let
date
=
date
.
ok_or
(
OUT_OF_RANGE
)
?
;
(
verify_ymd
(
date
)
&
&
verify_ordinal
(
date
)
date
)
}
(
_
_
_
)
=
>
return
Err
(
NOT_ENOUGH
)
}
;
if
!
verified
{
return
Err
(
IMPOSSIBLE
)
;
}
else
if
let
Some
(
parsed
)
=
self
.
quarter
{
if
parsed
!
=
parsed_date
.
quarter
(
)
{
return
Err
(
IMPOSSIBLE
)
;
}
}
Ok
(
parsed_date
)
}
pub
fn
to_naive_time
(
&
self
)
-
>
ParseResult
<
NaiveTime
>
{
let
hour_div_12
=
match
self
.
hour_div_12
{
Some
(
v
0
.
.
=
1
)
=
>
v
Some
(
_
)
=
>
return
Err
(
OUT_OF_RANGE
)
None
=
>
return
Err
(
NOT_ENOUGH
)
}
;
let
hour_mod_12
=
match
self
.
hour_mod_12
{
Some
(
v
0
.
.
=
11
)
=
>
v
Some
(
_
)
=
>
return
Err
(
OUT_OF_RANGE
)
None
=
>
return
Err
(
NOT_ENOUGH
)
}
;
let
hour
=
hour_div_12
*
12
+
hour_mod_12
;
let
minute
=
match
self
.
minute
{
Some
(
v
0
.
.
=
59
)
=
>
v
Some
(
_
)
=
>
return
Err
(
OUT_OF_RANGE
)
None
=
>
return
Err
(
NOT_ENOUGH
)
}
;
let
(
second
mut
nano
)
=
match
self
.
second
.
unwrap_or
(
0
)
{
v
0
.
.
=
59
=
>
(
v
0
)
60
=
>
(
59
1_000_000_000
)
_
=
>
return
Err
(
OUT_OF_RANGE
)
}
;
nano
+
=
match
self
.
nanosecond
{
Some
(
v
0
.
.
=
999_999_999
)
if
self
.
second
.
is_some
(
)
=
>
v
Some
(
0
.
.
=
999_999_999
)
=
>
return
Err
(
NOT_ENOUGH
)
Some
(
_
)
=
>
return
Err
(
OUT_OF_RANGE
)
None
=
>
0
}
;
NaiveTime
:
:
from_hms_nano_opt
(
hour
minute
second
nano
)
.
ok_or
(
OUT_OF_RANGE
)
}
pub
fn
to_naive_datetime_with_offset
(
&
self
offset
:
i32
)
-
>
ParseResult
<
NaiveDateTime
>
{
let
date
=
self
.
to_naive_date
(
)
;
let
time
=
self
.
to_naive_time
(
)
;
if
let
(
Ok
(
date
)
Ok
(
time
)
)
=
(
date
time
)
{
let
datetime
=
date
.
and_time
(
time
)
;
let
timestamp
=
datetime
.
and_utc
(
)
.
timestamp
(
)
-
i64
:
:
from
(
offset
)
;
if
let
Some
(
given_timestamp
)
=
self
.
timestamp
{
if
given_timestamp
!
=
timestamp
&
&
!
(
datetime
.
nanosecond
(
)
>
=
1_000_000_000
&
&
given_timestamp
=
=
timestamp
+
1
)
{
return
Err
(
IMPOSSIBLE
)
;
}
}
Ok
(
datetime
)
}
else
if
let
Some
(
timestamp
)
=
self
.
timestamp
{
use
super
:
:
ParseError
as
PE
;
use
super
:
:
ParseErrorKind
:
:
{
Impossible
OutOfRange
}
;
match
(
date
time
)
{
(
Err
(
PE
(
OutOfRange
)
)
_
)
|
(
_
Err
(
PE
(
OutOfRange
)
)
)
=
>
return
Err
(
OUT_OF_RANGE
)
(
Err
(
PE
(
Impossible
)
)
_
)
|
(
_
Err
(
PE
(
Impossible
)
)
)
=
>
return
Err
(
IMPOSSIBLE
)
(
_
_
)
=
>
{
}
}
let
ts
=
timestamp
.
checked_add
(
i64
:
:
from
(
offset
)
)
.
ok_or
(
OUT_OF_RANGE
)
?
;
let
mut
datetime
=
DateTime
:
:
from_timestamp
(
ts
0
)
.
ok_or
(
OUT_OF_RANGE
)
?
.
naive_utc
(
)
;
let
mut
parsed
=
self
.
clone
(
)
;
if
parsed
.
second
=
=
Some
(
60
)
{
match
datetime
.
second
(
)
{
59
=
>
{
}
0
=
>
{
datetime
-
=
TimeDelta
:
:
try_seconds
(
1
)
.
unwrap
(
)
;
}
_
=
>
return
Err
(
IMPOSSIBLE
)
}
}
else
{
parsed
.
set_second
(
i64
:
:
from
(
datetime
.
second
(
)
)
)
?
;
}
parsed
.
set_year
(
i64
:
:
from
(
datetime
.
year
(
)
)
)
?
;
parsed
.
set_ordinal
(
i64
:
:
from
(
datetime
.
ordinal
(
)
)
)
?
;
parsed
.
set_hour
(
i64
:
:
from
(
datetime
.
hour
(
)
)
)
?
;
parsed
.
set_minute
(
i64
:
:
from
(
datetime
.
minute
(
)
)
)
?
;
let
date
=
parsed
.
to_naive_date
(
)
?
;
let
time
=
parsed
.
to_naive_time
(
)
?
;
Ok
(
date
.
and_time
(
time
)
)
}
else
{
date
?
;
time
?
;
unreachable
!
(
)
}
}
pub
fn
to_fixed_offset
(
&
self
)
-
>
ParseResult
<
FixedOffset
>
{
FixedOffset
:
:
east_opt
(
self
.
offset
.
ok_or
(
NOT_ENOUGH
)
?
)
.
ok_or
(
OUT_OF_RANGE
)
}
pub
fn
to_datetime
(
&
self
)
-
>
ParseResult
<
DateTime
<
FixedOffset
>
>
{
let
offset
=
match
(
self
.
offset
self
.
timestamp
)
{
(
Some
(
off
)
_
)
=
>
off
(
None
Some
(
_
)
)
=
>
0
(
None
None
)
=
>
return
Err
(
NOT_ENOUGH
)
}
;
let
datetime
=
self
.
to_naive_datetime_with_offset
(
offset
)
?
;
let
offset
=
FixedOffset
:
:
east_opt
(
offset
)
.
ok_or
(
OUT_OF_RANGE
)
?
;
match
offset
.
from_local_datetime
(
&
datetime
)
{
MappedLocalTime
:
:
None
=
>
Err
(
IMPOSSIBLE
)
MappedLocalTime
:
:
Single
(
t
)
=
>
Ok
(
t
)
MappedLocalTime
:
:
Ambiguous
(
.
.
)
=
>
Err
(
NOT_ENOUGH
)
}
}
pub
fn
to_datetime_with_timezone
<
Tz
:
TimeZone
>
(
&
self
tz
:
&
Tz
)
-
>
ParseResult
<
DateTime
<
Tz
>
>
{
let
mut
guessed_offset
=
0
;
if
let
Some
(
timestamp
)
=
self
.
timestamp
{
let
nanosecond
=
self
.
nanosecond
.
unwrap_or
(
0
)
;
let
dt
=
DateTime
:
:
from_timestamp
(
timestamp
nanosecond
)
.
ok_or
(
OUT_OF_RANGE
)
?
.
naive_utc
(
)
;
guessed_offset
=
tz
.
offset_from_utc_datetime
(
&
dt
)
.
fix
(
)
.
local_minus_utc
(
)
;
}
let
check_offset
=
|
dt
:
&
DateTime
<
Tz
>
|
{
if
let
Some
(
offset
)
=
self
.
offset
{
dt
.
offset
(
)
.
fix
(
)
.
local_minus_utc
(
)
=
=
offset
}
else
{
true
}
}
;
let
datetime
=
self
.
to_naive_datetime_with_offset
(
guessed_offset
)
?
;
match
tz
.
from_local_datetime
(
&
datetime
)
{
MappedLocalTime
:
:
None
=
>
Err
(
IMPOSSIBLE
)
MappedLocalTime
:
:
Single
(
t
)
=
>
{
if
check_offset
(
&
t
)
{
Ok
(
t
)
}
else
{
Err
(
IMPOSSIBLE
)
}
}
MappedLocalTime
:
:
Ambiguous
(
min
max
)
=
>
{
match
(
check_offset
(
&
min
)
check_offset
(
&
max
)
)
{
(
false
false
)
=
>
Err
(
IMPOSSIBLE
)
(
false
true
)
=
>
Ok
(
max
)
(
true
false
)
=
>
Ok
(
min
)
(
true
true
)
=
>
Err
(
NOT_ENOUGH
)
}
}
}
}
#
[
inline
]
pub
fn
year
(
&
self
)
-
>
Option
<
i32
>
{
self
.
year
}
#
[
inline
]
pub
fn
year_div_100
(
&
self
)
-
>
Option
<
i32
>
{
self
.
year_div_100
}
#
[
inline
]
pub
fn
year_mod_100
(
&
self
)
-
>
Option
<
i32
>
{
self
.
year_mod_100
}
#
[
inline
]
pub
fn
isoyear
(
&
self
)
-
>
Option
<
i32
>
{
self
.
isoyear
}
#
[
inline
]
pub
fn
isoyear_div_100
(
&
self
)
-
>
Option
<
i32
>
{
self
.
isoyear_div_100
}
#
[
inline
]
pub
fn
isoyear_mod_100
(
&
self
)
-
>
Option
<
i32
>
{
self
.
isoyear_mod_100
}
#
[
inline
]
pub
fn
quarter
(
&
self
)
-
>
Option
<
u32
>
{
self
.
quarter
}
#
[
inline
]
pub
fn
month
(
&
self
)
-
>
Option
<
u32
>
{
self
.
month
}
#
[
inline
]
pub
fn
week_from_sun
(
&
self
)
-
>
Option
<
u32
>
{
self
.
week_from_sun
}
#
[
inline
]
pub
fn
week_from_mon
(
&
self
)
-
>
Option
<
u32
>
{
self
.
week_from_mon
}
#
[
inline
]
pub
fn
isoweek
(
&
self
)
-
>
Option
<
u32
>
{
self
.
isoweek
}
#
[
inline
]
pub
fn
weekday
(
&
self
)
-
>
Option
<
Weekday
>
{
self
.
weekday
}
#
[
inline
]
pub
fn
ordinal
(
&
self
)
-
>
Option
<
u32
>
{
self
.
ordinal
}
#
[
inline
]
pub
fn
day
(
&
self
)
-
>
Option
<
u32
>
{
self
.
day
}
#
[
inline
]
pub
fn
hour_div_12
(
&
self
)
-
>
Option
<
u32
>
{
self
.
hour_div_12
}
pub
fn
hour_mod_12
(
&
self
)
-
>
Option
<
u32
>
{
self
.
hour_mod_12
}
#
[
inline
]
pub
fn
minute
(
&
self
)
-
>
Option
<
u32
>
{
self
.
minute
}
#
[
inline
]
pub
fn
second
(
&
self
)
-
>
Option
<
u32
>
{
self
.
second
}
#
[
inline
]
pub
fn
nanosecond
(
&
self
)
-
>
Option
<
u32
>
{
self
.
nanosecond
}
#
[
inline
]
pub
fn
timestamp
(
&
self
)
-
>
Option
<
i64
>
{
self
.
timestamp
}
#
[
inline
]
pub
fn
offset
(
&
self
)
-
>
Option
<
i32
>
{
self
.
offset
}
}
fn
resolve_week_date
(
year
:
i32
week
:
u32
weekday
:
Weekday
week_start_day
:
Weekday
)
-
>
ParseResult
<
NaiveDate
>
{
if
week
>
53
{
return
Err
(
OUT_OF_RANGE
)
;
}
let
first_day_of_year
=
NaiveDate
:
:
from_yo_opt
(
year
1
)
.
ok_or
(
OUT_OF_RANGE
)
?
;
let
first_week_start
=
1
+
week_start_day
.
days_since
(
first_day_of_year
.
weekday
(
)
)
as
i32
;
let
weekday
=
weekday
.
days_since
(
week_start_day
)
as
i32
;
let
ordinal
=
first_week_start
+
(
week
as
i32
-
1
)
*
7
+
weekday
;
if
ordinal
<
=
0
{
return
Err
(
IMPOSSIBLE
)
;
}
first_day_of_year
.
with_ordinal
(
ordinal
as
u32
)
.
ok_or
(
IMPOSSIBLE
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
super
:
:
{
IMPOSSIBLE
NOT_ENOUGH
OUT_OF_RANGE
}
;
use
super
:
:
Parsed
;
use
crate
:
:
Datelike
;
use
crate
:
:
Weekday
:
:
*
;
use
crate
:
:
naive
:
:
{
NaiveDate
NaiveTime
}
;
use
crate
:
:
offset
:
:
{
FixedOffset
TimeZone
Utc
}
;
#
[
test
]
fn
test_parsed_set_fields
(
)
{
let
mut
p
=
Parsed
:
:
new
(
)
;
assert_eq
!
(
p
.
set_year
(
1987
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_year
(
1986
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_year
(
1988
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_year
(
1987
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_year_div_100
(
20
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_year_div_100
(
21
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_year_div_100
(
19
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_year_mod_100
(
37
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_year_mod_100
(
38
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_year_mod_100
(
36
)
Err
(
IMPOSSIBLE
)
)
;
let
mut
p
=
Parsed
:
:
new
(
)
;
assert_eq
!
(
p
.
set_year
(
0
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_year_div_100
(
0
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_year_mod_100
(
0
)
Ok
(
(
)
)
)
;
let
mut
p
=
Parsed
:
:
new
(
)
;
assert_eq
!
(
p
.
set_year_div_100
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
p
.
set_year_mod_100
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
p
.
set_year
(
-
1
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_year
(
-
2
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_year
(
0
)
Err
(
IMPOSSIBLE
)
)
;
let
mut
p
=
Parsed
:
:
new
(
)
;
assert_eq
!
(
p
.
set_year_div_100
(
0x1_0000_0008
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
p
.
set_year_div_100
(
8
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_year_div_100
(
0x1_0000_0008
)
Err
(
OUT_OF_RANGE
)
)
;
let
mut
p
=
Parsed
:
:
new
(
)
;
assert_eq
!
(
p
.
set_month
(
7
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_month
(
1
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_month
(
6
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_month
(
8
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_month
(
12
)
Err
(
IMPOSSIBLE
)
)
;
let
mut
p
=
Parsed
:
:
new
(
)
;
assert_eq
!
(
p
.
set_month
(
8
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_month
(
0x1_0000_0008
)
Err
(
OUT_OF_RANGE
)
)
;
let
mut
p
=
Parsed
:
:
new
(
)
;
assert_eq
!
(
p
.
set_hour
(
12
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_hour
(
11
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_hour
(
13
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_hour
(
12
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_ampm
(
false
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_ampm
(
true
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_hour12
(
12
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_hour12
(
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
p
.
set_hour12
(
1
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_hour12
(
11
)
Err
(
IMPOSSIBLE
)
)
;
let
mut
p
=
Parsed
:
:
new
(
)
;
assert_eq
!
(
p
.
set_ampm
(
true
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_hour12
(
7
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_hour
(
7
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_hour
(
18
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_hour
(
19
)
Ok
(
(
)
)
)
;
let
mut
p
=
Parsed
:
:
new
(
)
;
assert_eq
!
(
p
.
set_timestamp
(
1_234_567_890
)
Ok
(
(
)
)
)
;
assert_eq
!
(
p
.
set_timestamp
(
1_234_567_889
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
p
.
set_timestamp
(
1_234_567_891
)
Err
(
IMPOSSIBLE
)
)
;
}
#
[
test
]
fn
test_parsed_set_range
(
)
{
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_year
(
i32
:
:
MIN
as
i64
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_year
(
i32
:
:
MIN
as
i64
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_year
(
i32
:
:
MAX
as
i64
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_year
(
i32
:
:
MAX
as
i64
+
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_year_div_100
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_year_div_100
(
0
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_year_div_100
(
i32
:
:
MAX
as
i64
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_year_div_100
(
i32
:
:
MAX
as
i64
+
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_year_mod_100
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_year_mod_100
(
0
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_year_mod_100
(
99
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_year_mod_100
(
100
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_isoyear
(
i32
:
:
MIN
as
i64
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_isoyear
(
i32
:
:
MIN
as
i64
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_isoyear
(
i32
:
:
MAX
as
i64
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_isoyear
(
i32
:
:
MAX
as
i64
+
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_isoyear_div_100
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_isoyear_div_100
(
0
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_isoyear_div_100
(
99
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_isoyear_div_100
(
i32
:
:
MAX
as
i64
+
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_isoyear_mod_100
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_isoyear_mod_100
(
0
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_isoyear_mod_100
(
99
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_isoyear_mod_100
(
100
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_quarter
(
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_quarter
(
1
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_quarter
(
4
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_quarter
(
5
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_month
(
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_month
(
1
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_month
(
12
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_month
(
13
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_week_from_sun
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_week_from_sun
(
0
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_week_from_sun
(
53
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_week_from_sun
(
54
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_week_from_mon
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_week_from_mon
(
0
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_week_from_mon
(
53
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_week_from_mon
(
54
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_isoweek
(
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_isoweek
(
1
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_isoweek
(
53
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_isoweek
(
54
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_ordinal
(
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_ordinal
(
1
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_ordinal
(
366
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_ordinal
(
367
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_day
(
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_day
(
1
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_day
(
31
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_day
(
32
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_hour12
(
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_hour12
(
1
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_hour12
(
12
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_hour12
(
13
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_hour
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_hour
(
0
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_hour
(
23
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_hour
(
24
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_minute
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_minute
(
0
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_minute
(
59
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_minute
(
60
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_second
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_second
(
0
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_second
(
60
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_second
(
61
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_nanosecond
(
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_nanosecond
(
0
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_nanosecond
(
999_999_999
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_nanosecond
(
1_000_000_000
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_timestamp
(
i64
:
:
MIN
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_timestamp
(
i64
:
:
MAX
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_offset
(
i32
:
:
MIN
as
i64
-
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_offset
(
i32
:
:
MIN
as
i64
)
.
is_ok
(
)
)
;
assert
!
(
Parsed
:
:
new
(
)
.
set_offset
(
i32
:
:
MAX
as
i64
)
.
is_ok
(
)
)
;
assert_eq
!
(
Parsed
:
:
new
(
)
.
set_offset
(
i32
:
:
MAX
as
i64
+
1
)
Err
(
OUT_OF_RANGE
)
)
;
}
#
[
test
]
fn
test_parsed_to_naive_date
(
)
{
macro_rules
!
parse
{
(
(
k
:
ident
:
v
:
expr
)
*
)
=
>
(
Parsed
{
(
k
:
Some
(
v
)
)
*
.
.
Parsed
:
:
new
(
)
}
.
to_naive_date
(
)
)
}
let
ymd
=
|
y
m
d
|
Ok
(
NaiveDate
:
:
from_ymd_opt
(
y
m
d
)
.
unwrap
(
)
)
;
assert_eq
!
(
parse
!
(
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year
:
1984
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year
:
1984
month
:
1
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year
:
1984
month
:
1
day
:
2
)
ymd
(
1984
1
2
)
)
;
assert_eq
!
(
parse
!
(
year
:
1984
day
:
2
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
84
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
84
month
:
1
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
84
month
:
1
day
:
2
)
ymd
(
1984
1
2
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
84
day
:
2
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
month
:
1
day
:
2
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year_mod_100
:
70
month
:
1
day
:
2
)
ymd
(
1970
1
2
)
)
;
assert_eq
!
(
parse
!
(
year_mod_100
:
69
month
:
1
day
:
2
)
ymd
(
2069
1
2
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
84
month
:
2
day
:
29
)
ymd
(
1984
2
29
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
83
month
:
2
day
:
29
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
83
month
:
13
day
:
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
83
month
:
12
day
:
31
)
ymd
(
1983
12
31
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
83
month
:
12
day
:
32
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
83
month
:
12
day
:
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
100
month
:
1
day
:
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
19
year_mod_100
:
-
1
month
:
1
day
:
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
0
year_mod_100
:
0
month
:
1
day
:
1
)
ymd
(
0
1
1
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
-
1
year_mod_100
:
42
month
:
1
day
:
1
)
Err
(
IMPOSSIBLE
)
)
;
let
max_year
=
NaiveDate
:
:
MAX
.
year
(
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
max_year
/
100
year_mod_100
:
max_year
%
100
month
:
1
day
:
1
)
ymd
(
max_year
1
1
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
(
max_year
+
1
)
/
100
year_mod_100
:
(
max_year
+
1
)
%
100
month
:
1
day
:
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year
:
1984
year_div_100
:
19
month
:
1
day
:
1
)
ymd
(
1984
1
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
1984
year_div_100
:
20
month
:
1
day
:
1
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
1984
year_mod_100
:
84
month
:
1
day
:
1
)
ymd
(
1984
1
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
1984
year_mod_100
:
83
month
:
1
day
:
1
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
1984
year_div_100
:
19
year_mod_100
:
84
month
:
1
day
:
1
)
ymd
(
1984
1
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
1984
year_div_100
:
18
year_mod_100
:
94
month
:
1
day
:
1
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
1984
year_div_100
:
18
year_mod_100
:
184
month
:
1
day
:
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year
:
-
1
year_div_100
:
0
year_mod_100
:
-
1
month
:
1
day
:
1
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year
:
-
1
year_div_100
:
-
1
year_mod_100
:
99
month
:
1
day
:
1
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
-
1
year_div_100
:
0
month
:
1
day
:
1
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
-
1
year_mod_100
:
99
month
:
1
day
:
1
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
quarter
:
1
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
quarter
:
1
month
:
1
day
:
1
)
ymd
(
2000
1
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
quarter
:
2
month
:
4
day
:
1
)
ymd
(
2000
4
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
quarter
:
3
month
:
7
day
:
1
)
ymd
(
2000
7
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
quarter
:
4
month
:
10
day
:
1
)
ymd
(
2000
10
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
quarter
:
2
month
:
3
day
:
31
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
quarter
:
4
month
:
3
day
:
31
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
0
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_sun
:
0
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
weekday
:
Sun
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
0
weekday
:
Fri
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_sun
:
0
weekday
:
Fri
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
0
weekday
:
Sat
)
ymd
(
2000
1
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_sun
:
0
weekday
:
Sat
)
ymd
(
2000
1
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
0
weekday
:
Sun
)
ymd
(
2000
1
2
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_sun
:
1
weekday
:
Sun
)
ymd
(
2000
1
2
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
1
weekday
:
Mon
)
ymd
(
2000
1
3
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_sun
:
1
weekday
:
Mon
)
ymd
(
2000
1
3
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
1
weekday
:
Sat
)
ymd
(
2000
1
8
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_sun
:
1
weekday
:
Sat
)
ymd
(
2000
1
8
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
1
weekday
:
Sun
)
ymd
(
2000
1
9
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_sun
:
2
weekday
:
Sun
)
ymd
(
2000
1
9
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
2
weekday
:
Mon
)
ymd
(
2000
1
10
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_sun
:
52
weekday
:
Sat
)
ymd
(
2000
12
30
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_sun
:
53
weekday
:
Sun
)
ymd
(
2000
12
31
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_sun
:
53
weekday
:
Mon
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_sun
:
0xffffffff
weekday
:
Mon
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2006
week_from_sun
:
0
weekday
:
Sat
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2006
week_from_sun
:
1
weekday
:
Sun
)
ymd
(
2006
1
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
1
week_from_sun
:
1
weekday
:
Sat
)
ymd
(
2000
1
8
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
1
week_from_sun
:
2
weekday
:
Sun
)
ymd
(
2000
1
9
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
1
week_from_sun
:
1
weekday
:
Sun
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
week_from_mon
:
2
week_from_sun
:
2
weekday
:
Sun
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
isoyear
:
2004
isoweek
:
53
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
isoyear
:
2004
isoweek
:
53
weekday
:
Fri
)
ymd
(
2004
12
31
)
)
;
assert_eq
!
(
parse
!
(
isoyear
:
2004
isoweek
:
53
weekday
:
Sat
)
ymd
(
2005
1
1
)
)
;
assert_eq
!
(
parse
!
(
isoyear
:
2004
isoweek
:
0xffffffff
weekday
:
Sat
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
isoyear
:
2005
isoweek
:
0
weekday
:
Thu
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
isoyear
:
2005
isoweek
:
5
weekday
:
Thu
)
ymd
(
2005
2
3
)
)
;
assert_eq
!
(
parse
!
(
isoyear
:
2005
weekday
:
Thu
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
ordinal
:
123
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
ordinal
:
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
ordinal
:
1
)
ymd
(
2000
1
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
ordinal
:
60
)
ymd
(
2000
2
29
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
ordinal
:
61
)
ymd
(
2000
3
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
ordinal
:
366
)
ymd
(
2000
12
31
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
ordinal
:
367
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2000
ordinal
:
0xffffffff
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2100
ordinal
:
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2100
ordinal
:
1
)
ymd
(
2100
1
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
2100
ordinal
:
59
)
ymd
(
2100
2
28
)
)
;
assert_eq
!
(
parse
!
(
year
:
2100
ordinal
:
60
)
ymd
(
2100
3
1
)
)
;
assert_eq
!
(
parse
!
(
year
:
2100
ordinal
:
365
)
ymd
(
2100
12
31
)
)
;
assert_eq
!
(
parse
!
(
year
:
2100
ordinal
:
366
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2100
ordinal
:
0xffffffff
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2014
month
:
12
day
:
31
ordinal
:
365
isoyear
:
2015
isoweek
:
1
week_from_sun
:
52
week_from_mon
:
52
weekday
:
Wed
)
ymd
(
2014
12
31
)
)
;
assert_eq
!
(
parse
!
(
year
:
2014
month
:
12
ordinal
:
365
isoyear
:
2015
isoweek
:
1
week_from_sun
:
52
week_from_mon
:
52
)
ymd
(
2014
12
31
)
)
;
assert_eq
!
(
parse
!
(
year
:
2014
month
:
12
day
:
31
ordinal
:
365
isoyear
:
2014
isoweek
:
53
week_from_sun
:
52
week_from_mon
:
52
weekday
:
Wed
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2012
isoyear
:
2015
isoweek
:
1
week_from_sun
:
52
week_from_mon
:
52
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year_div_100
:
20
isoyear_mod_100
:
15
ordinal
:
366
)
Err
(
NOT_ENOUGH
)
)
;
}
#
[
test
]
fn
test_parsed_to_naive_time
(
)
{
macro_rules
!
parse
{
(
(
k
:
ident
:
v
:
expr
)
*
)
=
>
(
Parsed
{
(
k
:
Some
(
v
)
)
*
.
.
Parsed
:
:
new
(
)
}
.
to_naive_time
(
)
)
}
let
hms
=
|
h
m
s
|
Ok
(
NaiveTime
:
:
from_hms_opt
(
h
m
s
)
.
unwrap
(
)
)
;
let
hmsn
=
|
h
m
s
n
|
Ok
(
NaiveTime
:
:
from_hms_nano_opt
(
h
m
s
n
)
.
unwrap
(
)
)
;
assert_eq
!
(
parse
!
(
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
0
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
0
hour_mod_12
:
1
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
0
hour_mod_12
:
1
minute
:
23
)
hms
(
1
23
0
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
0
hour_mod_12
:
1
minute
:
23
second
:
45
)
hms
(
1
23
45
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
0
hour_mod_12
:
1
minute
:
23
second
:
45
nanosecond
:
678_901_234
)
hmsn
(
1
23
45
678_901_234
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
1
hour_mod_12
:
11
minute
:
45
second
:
6
)
hms
(
23
45
6
)
)
;
assert_eq
!
(
parse
!
(
hour_mod_12
:
1
minute
:
23
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
0
hour_mod_12
:
1
minute
:
23
nanosecond
:
456_789_012
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
2
hour_mod_12
:
0
minute
:
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
1
hour_mod_12
:
12
minute
:
0
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
0
hour_mod_12
:
1
minute
:
60
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
0
hour_mod_12
:
1
minute
:
23
second
:
61
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
0
hour_mod_12
:
1
minute
:
23
second
:
34
nanosecond
:
1_000_000_000
)
Err
(
OUT_OF_RANGE
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
0
hour_mod_12
:
1
minute
:
23
second
:
60
)
hmsn
(
1
23
59
1_000_000_000
)
)
;
assert_eq
!
(
parse
!
(
hour_div_12
:
0
hour_mod_12
:
1
minute
:
23
second
:
60
nanosecond
:
999_999_999
)
hmsn
(
1
23
59
1_999_999_999
)
)
;
}
#
[
test
]
fn
test_parsed_to_naive_datetime_with_offset
(
)
{
macro_rules
!
parse
{
(
offset
=
offset
:
expr
;
(
k
:
ident
:
v
:
expr
)
*
)
=
>
(
Parsed
{
(
k
:
Some
(
v
)
)
*
.
.
Parsed
:
:
new
(
)
}
.
to_naive_datetime_with_offset
(
offset
)
)
;
(
(
k
:
ident
:
v
:
expr
)
*
)
=
>
(
parse
!
(
offset
=
0
;
(
k
:
v
)
*
)
)
}
let
ymdhms
=
|
y
m
d
h
n
s
|
{
Ok
(
NaiveDate
:
:
from_ymd_opt
(
y
m
d
)
.
unwrap
(
)
.
and_hms_opt
(
h
n
s
)
.
unwrap
(
)
)
}
;
let
ymdhmsn
=
|
y
m
d
h
n
s
nano
|
{
Ok
(
NaiveDate
:
:
from_ymd_opt
(
y
m
d
)
.
unwrap
(
)
.
and_hms_nano_opt
(
h
n
s
nano
)
.
unwrap
(
)
)
}
;
assert_eq
!
(
parse
!
(
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year
:
2015
month
:
1
day
:
30
hour_div_12
:
1
hour_mod_12
:
2
minute
:
38
)
ymdhms
(
2015
1
30
14
38
0
)
)
;
assert_eq
!
(
parse
!
(
year
:
1997
month
:
1
day
:
30
hour_div_12
:
1
hour_mod_12
:
2
minute
:
38
second
:
5
)
ymdhms
(
1997
1
30
14
38
5
)
)
;
assert_eq
!
(
parse
!
(
year
:
2012
ordinal
:
34
hour_div_12
:
0
hour_mod_12
:
5
minute
:
6
second
:
7
nanosecond
:
890_123_456
)
ymdhmsn
(
2012
2
3
5
6
7
890_123_456
)
)
;
assert_eq
!
(
parse
!
(
timestamp
:
0
)
ymdhms
(
1970
1
1
0
0
0
)
)
;
assert_eq
!
(
parse
!
(
timestamp
:
1
nanosecond
:
0
)
ymdhms
(
1970
1
1
0
0
1
)
)
;
assert_eq
!
(
parse
!
(
timestamp
:
1
nanosecond
:
1
)
ymdhmsn
(
1970
1
1
0
0
1
1
)
)
;
assert_eq
!
(
parse
!
(
timestamp
:
1_420_000_000
)
ymdhms
(
2014
12
31
4
26
40
)
)
;
assert_eq
!
(
parse
!
(
timestamp
:
-
0x1_0000_0000
)
ymdhms
(
1833
11
24
17
31
44
)
)
;
assert_eq
!
(
parse
!
(
year
:
2014
year_div_100
:
20
year_mod_100
:
14
month
:
12
day
:
31
ordinal
:
365
isoyear
:
2015
isoyear_div_100
:
20
isoyear_mod_100
:
15
isoweek
:
1
week_from_sun
:
52
week_from_mon
:
52
weekday
:
Wed
hour_div_12
:
0
hour_mod_12
:
4
minute
:
26
second
:
40
nanosecond
:
12_345_678
timestamp
:
1_420_000_000
)
ymdhmsn
(
2014
12
31
4
26
40
12_345_678
)
)
;
assert_eq
!
(
parse
!
(
year
:
2014
year_div_100
:
20
year_mod_100
:
14
month
:
12
day
:
31
ordinal
:
365
isoyear
:
2015
isoyear_div_100
:
20
isoyear_mod_100
:
15
isoweek
:
1
week_from_sun
:
52
week_from_mon
:
52
weekday
:
Wed
hour_div_12
:
0
hour_mod_12
:
4
minute
:
26
second
:
40
nanosecond
:
12_345_678
timestamp
:
1_419_999_999
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
offset
=
32400
;
year
:
2014
year_div_100
:
20
year_mod_100
:
14
month
:
12
day
:
31
ordinal
:
365
isoyear
:
2015
isoyear_div_100
:
20
isoyear_mod_100
:
15
isoweek
:
1
week_from_sun
:
52
week_from_mon
:
52
weekday
:
Wed
hour_div_12
:
0
hour_mod_12
:
4
minute
:
26
second
:
40
nanosecond
:
12_345_678
timestamp
:
1_419_967_600
)
ymdhmsn
(
2014
12
31
4
26
40
12_345_678
)
)
;
let
max_days_from_year_1970
=
NaiveDate
:
:
MAX
.
signed_duration_since
(
NaiveDate
:
:
from_ymd_opt
(
1970
1
1
)
.
unwrap
(
)
)
;
let
year_0_from_year_1970
=
NaiveDate
:
:
from_ymd_opt
(
0
1
1
)
.
unwrap
(
)
.
signed_duration_since
(
NaiveDate
:
:
from_ymd_opt
(
1970
1
1
)
.
unwrap
(
)
)
;
let
min_days_from_year_1970
=
NaiveDate
:
:
MIN
.
signed_duration_since
(
NaiveDate
:
:
from_ymd_opt
(
1970
1
1
)
.
unwrap
(
)
)
;
assert_eq
!
(
parse
!
(
timestamp
:
min_days_from_year_1970
.
num_seconds
(
)
)
ymdhms
(
NaiveDate
:
:
MIN
.
year
(
)
1
1
0
0
0
)
)
;
assert_eq
!
(
parse
!
(
timestamp
:
year_0_from_year_1970
.
num_seconds
(
)
)
ymdhms
(
0
1
1
0
0
0
)
)
;
assert_eq
!
(
parse
!
(
timestamp
:
max_days_from_year_1970
.
num_seconds
(
)
+
86399
)
ymdhms
(
NaiveDate
:
:
MAX
.
year
(
)
12
31
23
59
59
)
)
;
assert_eq
!
(
parse
!
(
second
:
59
timestamp
:
1_341_100_798
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
second
:
59
timestamp
:
1_341_100_799
)
ymdhms
(
2012
6
30
23
59
59
)
)
;
assert_eq
!
(
parse
!
(
second
:
59
timestamp
:
1_341_100_800
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
second
:
60
timestamp
:
1_341_100_799
)
ymdhmsn
(
2012
6
30
23
59
59
1_000_000_000
)
)
;
assert_eq
!
(
parse
!
(
second
:
60
timestamp
:
1_341_100_800
)
ymdhmsn
(
2012
6
30
23
59
59
1_000_000_000
)
)
;
assert_eq
!
(
parse
!
(
second
:
0
timestamp
:
1_341_100_800
)
ymdhms
(
2012
7
1
0
0
0
)
)
;
assert_eq
!
(
parse
!
(
second
:
1
timestamp
:
1_341_100_800
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
second
:
60
timestamp
:
1_341_100_801
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2012
ordinal
:
182
hour_div_12
:
1
hour_mod_12
:
11
minute
:
59
second
:
59
timestamp
:
1_341_100_798
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2012
ordinal
:
182
hour_div_12
:
1
hour_mod_12
:
11
minute
:
59
second
:
59
timestamp
:
1_341_100_799
)
ymdhms
(
2012
6
30
23
59
59
)
)
;
assert_eq
!
(
parse
!
(
year
:
2012
ordinal
:
182
hour_div_12
:
1
hour_mod_12
:
11
minute
:
59
second
:
59
timestamp
:
1_341_100_800
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2012
ordinal
:
182
hour_div_12
:
1
hour_mod_12
:
11
minute
:
59
second
:
60
timestamp
:
1_341_100_799
)
ymdhmsn
(
2012
6
30
23
59
59
1_000_000_000
)
)
;
assert_eq
!
(
parse
!
(
year
:
2012
ordinal
:
182
hour_div_12
:
1
hour_mod_12
:
11
minute
:
59
second
:
60
timestamp
:
1_341_100_800
)
ymdhmsn
(
2012
6
30
23
59
59
1_000_000_000
)
)
;
assert_eq
!
(
parse
!
(
year
:
2012
ordinal
:
183
hour_div_12
:
0
hour_mod_12
:
0
minute
:
0
second
:
0
timestamp
:
1_341_100_800
)
ymdhms
(
2012
7
1
0
0
0
)
)
;
assert_eq
!
(
parse
!
(
year
:
2012
ordinal
:
183
hour_div_12
:
0
hour_mod_12
:
0
minute
:
0
second
:
1
timestamp
:
1_341_100_800
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2012
ordinal
:
182
hour_div_12
:
1
hour_mod_12
:
11
minute
:
59
second
:
60
timestamp
:
1_341_100_801
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
year
:
2015
month
:
1
day
:
20
weekday
:
Tue
hour_div_12
:
2
hour_mod_12
:
1
minute
:
35
second
:
20
)
Err
(
OUT_OF_RANGE
)
)
;
}
#
[
test
]
fn
test_parsed_to_datetime
(
)
{
macro_rules
!
parse
{
(
(
k
:
ident
:
v
:
expr
)
*
)
=
>
(
Parsed
{
(
k
:
Some
(
v
)
)
*
.
.
Parsed
:
:
new
(
)
}
.
to_datetime
(
)
)
}
let
ymdhmsn
=
|
y
m
d
h
n
s
nano
off
|
{
Ok
(
FixedOffset
:
:
east_opt
(
off
)
.
unwrap
(
)
.
from_local_datetime
(
&
NaiveDate
:
:
from_ymd_opt
(
y
m
d
)
.
unwrap
(
)
.
and_hms_nano_opt
(
h
n
s
nano
)
.
unwrap
(
)
)
.
unwrap
(
)
)
}
;
assert_eq
!
(
parse
!
(
offset
:
0
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year
:
2014
ordinal
:
365
hour_div_12
:
0
hour_mod_12
:
4
minute
:
26
second
:
40
nanosecond
:
12_345_678
)
Err
(
NOT_ENOUGH
)
)
;
assert_eq
!
(
parse
!
(
year
:
2014
ordinal
:
365
hour_div_12
:
0
hour_mod_12
:
4
minute
:
26
second
:
40
nanosecond
:
12_345_678
offset
:
0
)
ymdhmsn
(
2014
12
31
4
26
40
12_345_678
0
)
)
;
assert_eq
!
(
parse
!
(
year
:
2014
ordinal
:
365
hour_div_12
:
1
hour_mod_12
:
1
minute
:
26
second
:
40
nanosecond
:
12_345_678
offset
:
32400
)
ymdhmsn
(
2014
12
31
13
26
40
12_345_678
32400
)
)
;
assert_eq
!
(
parse
!
(
year
:
2014
ordinal
:
365
hour_div_12
:
0
hour_mod_12
:
1
minute
:
42
second
:
4
nanosecond
:
12_345_678
offset
:
-
9876
)
ymdhmsn
(
2014
12
31
1
42
4
12_345_678
-
9876
)
)
;
assert_eq
!
(
parse
!
(
year
:
2015
ordinal
:
1
hour_div_12
:
0
hour_mod_12
:
4
minute
:
26
second
:
40
nanosecond
:
12_345_678
offset
:
86_400
)
Err
(
OUT_OF_RANGE
)
)
;
}
#
[
test
]
fn
test_parsed_to_datetime_with_timezone
(
)
{
macro_rules
!
parse
{
(
tz
:
expr
;
(
k
:
ident
:
v
:
expr
)
*
)
=
>
(
Parsed
{
(
k
:
Some
(
v
)
)
*
.
.
Parsed
:
:
new
(
)
}
.
to_datetime_with_timezone
(
&
tz
)
)
}
assert_eq
!
(
parse
!
(
Utc
;
year
:
2014
ordinal
:
365
hour_div_12
:
0
hour_mod_12
:
4
minute
:
26
second
:
40
nanosecond
:
12_345_678
offset
:
0
)
Ok
(
Utc
.
from_local_datetime
(
&
NaiveDate
:
:
from_ymd_opt
(
2014
12
31
)
.
unwrap
(
)
.
and_hms_nano_opt
(
4
26
40
12_345_678
)
.
unwrap
(
)
)
.
unwrap
(
)
)
)
;
assert_eq
!
(
parse
!
(
Utc
;
year
:
2014
ordinal
:
365
hour_div_12
:
1
hour_mod_12
:
1
minute
:
26
second
:
40
nanosecond
:
12_345_678
offset
:
32400
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
FixedOffset
:
:
east_opt
(
32400
)
.
unwrap
(
)
;
year
:
2014
ordinal
:
365
hour_div_12
:
0
hour_mod_12
:
4
minute
:
26
second
:
40
nanosecond
:
12_345_678
offset
:
0
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
FixedOffset
:
:
east_opt
(
32400
)
.
unwrap
(
)
;
year
:
2014
ordinal
:
365
hour_div_12
:
1
hour_mod_12
:
1
minute
:
26
second
:
40
nanosecond
:
12_345_678
offset
:
32400
)
Ok
(
FixedOffset
:
:
east_opt
(
32400
)
.
unwrap
(
)
.
from_local_datetime
(
&
NaiveDate
:
:
from_ymd_opt
(
2014
12
31
)
.
unwrap
(
)
.
and_hms_nano_opt
(
13
26
40
12_345_678
)
.
unwrap
(
)
)
.
unwrap
(
)
)
)
;
assert_eq
!
(
parse
!
(
Utc
;
timestamp
:
1_420_000_000
offset
:
0
)
Ok
(
Utc
.
with_ymd_and_hms
(
2014
12
31
4
26
40
)
.
unwrap
(
)
)
)
;
assert_eq
!
(
parse
!
(
Utc
;
timestamp
:
1_420_000_000
offset
:
32400
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
FixedOffset
:
:
east_opt
(
32400
)
.
unwrap
(
)
;
timestamp
:
1_420_000_000
offset
:
0
)
Err
(
IMPOSSIBLE
)
)
;
assert_eq
!
(
parse
!
(
FixedOffset
:
:
east_opt
(
32400
)
.
unwrap
(
)
;
timestamp
:
1_420_000_000
offset
:
32400
)
Ok
(
FixedOffset
:
:
east_opt
(
32400
)
.
unwrap
(
)
.
with_ymd_and_hms
(
2014
12
31
13
26
40
)
.
unwrap
(
)
)
)
;
}
#
[
test
]
fn
issue_551
(
)
{
use
crate
:
:
Weekday
;
let
mut
parsed
=
Parsed
:
:
new
(
)
;
parsed
.
year
=
Some
(
2002
)
;
parsed
.
week_from_mon
=
Some
(
22
)
;
parsed
.
weekday
=
Some
(
Weekday
:
:
Mon
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd_opt
(
2002
6
3
)
.
unwrap
(
)
parsed
.
to_naive_date
(
)
.
unwrap
(
)
)
;
parsed
.
year
=
Some
(
2001
)
;
assert_eq
!
(
NaiveDate
:
:
from_ymd_opt
(
2001
5
28
)
.
unwrap
(
)
parsed
.
to_naive_date
(
)
.
unwrap
(
)
)
;
}
}
