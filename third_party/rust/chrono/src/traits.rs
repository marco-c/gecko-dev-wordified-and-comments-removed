use
crate
:
:
{
IsoWeek
Month
Weekday
}
;
pub
trait
Datelike
:
Sized
{
fn
year
(
&
self
)
-
>
i32
;
#
[
inline
]
fn
year_ce
(
&
self
)
-
>
(
bool
u32
)
{
let
year
=
self
.
year
(
)
;
if
year
<
1
{
(
false
(
1
-
year
)
as
u32
)
}
else
{
(
true
year
as
u32
)
}
}
#
[
inline
]
fn
quarter
(
&
self
)
-
>
u32
{
(
self
.
month
(
)
-
1
)
.
div_euclid
(
3
)
+
1
}
fn
month
(
&
self
)
-
>
u32
;
fn
month0
(
&
self
)
-
>
u32
;
fn
day
(
&
self
)
-
>
u32
;
fn
day0
(
&
self
)
-
>
u32
;
fn
ordinal
(
&
self
)
-
>
u32
;
fn
ordinal0
(
&
self
)
-
>
u32
;
fn
weekday
(
&
self
)
-
>
Weekday
;
fn
iso_week
(
&
self
)
-
>
IsoWeek
;
fn
with_year
(
&
self
year
:
i32
)
-
>
Option
<
Self
>
;
fn
with_month
(
&
self
month
:
u32
)
-
>
Option
<
Self
>
;
fn
with_month0
(
&
self
month0
:
u32
)
-
>
Option
<
Self
>
;
fn
with_day
(
&
self
day
:
u32
)
-
>
Option
<
Self
>
;
fn
with_day0
(
&
self
day0
:
u32
)
-
>
Option
<
Self
>
;
fn
with_ordinal
(
&
self
ordinal
:
u32
)
-
>
Option
<
Self
>
;
fn
with_ordinal0
(
&
self
ordinal0
:
u32
)
-
>
Option
<
Self
>
;
fn
num_days_from_ce
(
&
self
)
-
>
i32
{
let
mut
year
=
self
.
year
(
)
-
1
;
let
mut
ndays
=
0
;
if
year
<
0
{
let
excess
=
1
+
(
-
year
)
/
400
;
year
+
=
excess
*
400
;
ndays
-
=
excess
*
146_097
;
}
let
div_100
=
year
/
100
;
ndays
+
=
(
(
year
*
1461
)
>
>
2
)
-
div_100
+
(
div_100
>
>
2
)
;
ndays
+
self
.
ordinal
(
)
as
i32
}
fn
num_days_in_month
(
&
self
)
-
>
u8
{
use
num_traits
:
:
FromPrimitive
;
let
month
=
Month
:
:
from_u32
(
self
.
month
(
)
)
.
unwrap
(
)
;
month
.
num_days
(
self
.
year
(
)
)
.
unwrap
(
)
}
}
pub
trait
Timelike
:
Sized
{
fn
hour
(
&
self
)
-
>
u32
;
#
[
inline
]
fn
hour12
(
&
self
)
-
>
(
bool
u32
)
{
let
hour
=
self
.
hour
(
)
;
let
mut
hour12
=
hour
%
12
;
if
hour12
=
=
0
{
hour12
=
12
;
}
(
hour
>
=
12
hour12
)
}
fn
minute
(
&
self
)
-
>
u32
;
fn
second
(
&
self
)
-
>
u32
;
fn
nanosecond
(
&
self
)
-
>
u32
;
fn
with_hour
(
&
self
hour
:
u32
)
-
>
Option
<
Self
>
;
fn
with_minute
(
&
self
min
:
u32
)
-
>
Option
<
Self
>
;
fn
with_second
(
&
self
sec
:
u32
)
-
>
Option
<
Self
>
;
fn
with_nanosecond
(
&
self
nano
:
u32
)
-
>
Option
<
Self
>
;
#
[
inline
]
fn
num_seconds_from_midnight
(
&
self
)
-
>
u32
{
self
.
hour
(
)
*
3600
+
self
.
minute
(
)
*
60
+
self
.
second
(
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
Datelike
;
use
crate
:
:
{
Days
NaiveDate
}
;
#
[
test
]
fn
test_num_days_from_ce_against_alternative_impl
(
)
{
fn
in_between
(
start
:
i32
end
:
i32
div
:
i32
)
-
>
i32
{
assert
!
(
div
>
0
"
in_between
:
nonpositive
div
=
{
}
"
div
)
;
let
start
=
(
start
.
div_euclid
(
div
)
start
.
rem_euclid
(
div
)
)
;
let
end
=
(
end
.
div_euclid
(
div
)
end
.
rem_euclid
(
div
)
)
;
let
start
=
start
.
0
+
(
start
.
1
!
=
0
)
as
i32
;
let
end
=
end
.
0
+
(
end
.
1
!
=
0
)
as
i32
;
end
-
start
}
fn
num_days_from_ce
<
Date
:
Datelike
>
(
date
:
&
Date
)
-
>
i32
{
let
year
=
date
.
year
(
)
;
let
diff
=
move
|
div
|
in_between
(
1
year
div
)
;
date
.
ordinal
(
)
as
i32
+
365
*
diff
(
1
)
+
diff
(
4
)
-
diff
(
100
)
+
diff
(
400
)
}
for
year
in
NaiveDate
:
:
MIN
.
year
(
)
.
.
=
NaiveDate
:
:
MAX
.
year
(
)
{
let
jan1_year
=
NaiveDate
:
:
from_ymd_opt
(
year
1
1
)
.
unwrap
(
)
;
assert_eq
!
(
jan1_year
.
num_days_from_ce
(
)
num_days_from_ce
(
&
jan1_year
)
"
on
{
:
?
}
"
jan1_year
)
;
let
mid_year
=
jan1_year
+
Days
:
:
new
(
133
)
;
assert_eq
!
(
mid_year
.
num_days_from_ce
(
)
num_days_from_ce
(
&
mid_year
)
"
on
{
:
?
}
"
mid_year
)
;
}
}
#
[
test
]
fn
test_num_days_in_month
(
)
{
let
feb_leap_year
=
NaiveDate
:
:
from_ymd_opt
(
2004
2
1
)
.
unwrap
(
)
;
assert_eq
!
(
feb_leap_year
.
num_days_in_month
(
)
29
)
;
let
feb
=
feb_leap_year
.
with_year
(
2005
)
.
unwrap
(
)
;
assert_eq
!
(
feb
.
num_days_in_month
(
)
28
)
;
let
march
=
feb
.
with_month
(
3
)
.
unwrap
(
)
;
assert_eq
!
(
march
.
num_days_in_month
(
)
31
)
;
}
}
