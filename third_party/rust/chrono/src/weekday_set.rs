use
core
:
:
{
fmt
:
:
{
self
Debug
}
iter
:
:
FusedIterator
}
;
use
crate
:
:
Weekday
;
#
[
derive
(
Clone
Copy
Default
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
WeekdaySet
(
u8
)
;
impl
WeekdaySet
{
pub
const
fn
from_array
<
const
C
:
usize
>
(
days
:
[
Weekday
;
C
]
)
-
>
Self
{
let
mut
acc
=
Self
:
:
EMPTY
;
let
mut
idx
=
0
;
while
idx
<
days
.
len
(
)
{
acc
.
0
|
=
Self
:
:
single
(
days
[
idx
]
)
.
0
;
idx
+
=
1
;
}
acc
}
pub
const
fn
single
(
weekday
:
Weekday
)
-
>
Self
{
match
weekday
{
Weekday
:
:
Mon
=
>
Self
(
0b000_0001
)
Weekday
:
:
Tue
=
>
Self
(
0b000_0010
)
Weekday
:
:
Wed
=
>
Self
(
0b000_0100
)
Weekday
:
:
Thu
=
>
Self
(
0b000_1000
)
Weekday
:
:
Fri
=
>
Self
(
0b001_0000
)
Weekday
:
:
Sat
=
>
Self
(
0b010_0000
)
Weekday
:
:
Sun
=
>
Self
(
0b100_0000
)
}
}
pub
const
fn
single_day
(
self
)
-
>
Option
<
Weekday
>
{
match
self
{
Self
(
0b000_0001
)
=
>
Some
(
Weekday
:
:
Mon
)
Self
(
0b000_0010
)
=
>
Some
(
Weekday
:
:
Tue
)
Self
(
0b000_0100
)
=
>
Some
(
Weekday
:
:
Wed
)
Self
(
0b000_1000
)
=
>
Some
(
Weekday
:
:
Thu
)
Self
(
0b001_0000
)
=
>
Some
(
Weekday
:
:
Fri
)
Self
(
0b010_0000
)
=
>
Some
(
Weekday
:
:
Sat
)
Self
(
0b100_0000
)
=
>
Some
(
Weekday
:
:
Sun
)
_
=
>
None
}
}
pub
fn
insert
(
&
mut
self
day
:
Weekday
)
-
>
bool
{
if
self
.
contains
(
day
)
{
return
false
;
}
self
.
0
|
=
Self
:
:
single
(
day
)
.
0
;
true
}
pub
fn
remove
(
&
mut
self
day
:
Weekday
)
-
>
bool
{
if
self
.
contains
(
day
)
{
self
.
0
&
=
!
Self
:
:
single
(
day
)
.
0
;
return
true
;
}
false
}
pub
const
fn
is_subset
(
self
other
:
Self
)
-
>
bool
{
self
.
intersection
(
other
)
.
0
=
=
self
.
0
}
pub
const
fn
intersection
(
self
other
:
Self
)
-
>
Self
{
Self
(
self
.
0
&
other
.
0
)
}
pub
const
fn
union
(
self
other
:
Self
)
-
>
Self
{
Self
(
self
.
0
|
other
.
0
)
}
pub
const
fn
symmetric_difference
(
self
other
:
Self
)
-
>
Self
{
Self
(
self
.
0
^
other
.
0
)
}
pub
const
fn
difference
(
self
other
:
Self
)
-
>
Self
{
Self
(
self
.
0
&
!
other
.
0
)
}
pub
const
fn
first
(
self
)
-
>
Option
<
Weekday
>
{
if
self
.
is_empty
(
)
{
return
None
;
}
let
bit
=
1
<
<
self
.
0
.
trailing_zeros
(
)
;
Self
(
bit
)
.
single_day
(
)
}
pub
fn
last
(
self
)
-
>
Option
<
Weekday
>
{
if
self
.
is_empty
(
)
{
return
None
;
}
let
bit
=
1
<
<
(
7
-
self
.
0
.
leading_zeros
(
)
)
;
Self
(
bit
)
.
single_day
(
)
}
const
fn
split_at
(
self
weekday
:
Weekday
)
-
>
(
Self
Self
)
{
let
days_after
=
0b1000_0000
-
Self
:
:
single
(
weekday
)
.
0
;
let
days_before
=
days_after
^
0b0111_1111
;
(
Self
(
self
.
0
&
days_before
)
Self
(
self
.
0
&
days_after
)
)
}
pub
const
fn
iter
(
self
start
:
Weekday
)
-
>
WeekdaySetIter
{
WeekdaySetIter
{
days
:
self
start
}
}
pub
const
fn
contains
(
self
day
:
Weekday
)
-
>
bool
{
self
.
0
&
Self
:
:
single
(
day
)
.
0
!
=
0
}
pub
const
fn
is_empty
(
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
pub
const
fn
len
(
self
)
-
>
u8
{
self
.
0
.
count_ones
(
)
as
u8
}
pub
const
EMPTY
:
Self
=
Self
(
0b000_0000
)
;
pub
const
ALL
:
Self
=
Self
(
0b111_1111
)
;
}
impl
Debug
for
WeekdaySet
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
WeekdaySet
(
{
:
0
>
7b
}
)
"
self
.
0
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
WeekdaySetIter
{
days
:
WeekdaySet
start
:
Weekday
}
impl
Iterator
for
WeekdaySetIter
{
type
Item
=
Weekday
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
days
.
is_empty
(
)
{
return
None
;
}
let
(
before
after
)
=
self
.
days
.
split_at
(
self
.
start
)
;
let
days
=
if
after
.
is_empty
(
)
{
before
}
else
{
after
}
;
let
next
=
days
.
first
(
)
.
expect
(
"
the
collection
is
not
empty
"
)
;
self
.
days
.
remove
(
next
)
;
Some
(
next
)
}
}
impl
DoubleEndedIterator
for
WeekdaySetIter
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
days
.
is_empty
(
)
{
return
None
;
}
let
(
before
after
)
=
self
.
days
.
split_at
(
self
.
start
)
;
let
days
=
if
before
.
is_empty
(
)
{
after
}
else
{
before
}
;
let
next_back
=
days
.
last
(
)
.
expect
(
"
the
collection
is
not
empty
"
)
;
self
.
days
.
remove
(
next_back
)
;
Some
(
next_back
)
}
}
impl
ExactSizeIterator
for
WeekdaySetIter
{
fn
len
(
&
self
)
-
>
usize
{
self
.
days
.
len
(
)
.
into
(
)
}
}
impl
FusedIterator
for
WeekdaySetIter
{
}
impl
fmt
:
:
Display
for
WeekdaySet
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
[
"
)
?
;
let
mut
iter
=
self
.
iter
(
Weekday
:
:
Mon
)
;
if
let
Some
(
first
)
=
iter
.
next
(
)
{
write
!
(
f
"
{
first
}
"
)
?
;
}
for
weekday
in
iter
{
write
!
(
f
"
{
weekday
}
"
)
?
;
}
write
!
(
f
"
]
"
)
}
}
impl
FromIterator
<
Weekday
>
for
WeekdaySet
{
fn
from_iter
<
T
:
IntoIterator
<
Item
=
Weekday
>
>
(
iter
:
T
)
-
>
Self
{
iter
.
into_iter
(
)
.
map
(
Self
:
:
single
)
.
fold
(
Self
:
:
EMPTY
Self
:
:
union
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
crate
:
:
Weekday
;
use
super
:
:
WeekdaySet
;
impl
WeekdaySet
{
fn
iter_all
(
)
-
>
impl
Iterator
<
Item
=
Self
>
{
(
0b0000_0000
.
.
0b1000_0000
)
.
map
(
Self
)
}
}
fn
assert_8th_bit_invariant
(
days
:
WeekdaySet
)
{
assert
!
(
days
.
0
&
0b1000_0000
=
=
0
"
the
8
-
th
bit
of
{
days
:
?
}
is
not
0
"
)
;
}
#
[
test
]
fn
debug_prints_8th_bit_if_not_zero
(
)
{
assert_eq
!
(
format
!
(
"
{
:
?
}
"
WeekdaySet
(
0b1000_0000
)
)
"
WeekdaySet
(
10000000
)
"
)
;
}
#
[
test
]
fn
bitwise_set_operations_preserve_8th_bit_invariant
(
)
{
for
set1
in
WeekdaySet
:
:
iter_all
(
)
{
for
set2
in
WeekdaySet
:
:
iter_all
(
)
{
assert_8th_bit_invariant
(
set1
.
union
(
set2
)
)
;
assert_8th_bit_invariant
(
set1
.
intersection
(
set2
)
)
;
assert_8th_bit_invariant
(
set1
.
symmetric_difference
(
set2
)
)
;
}
}
}
#
[
test
]
fn
split_at_is_equivalent_to_iterating
(
)
{
use
Weekday
:
:
*
;
const
WEEK
:
[
Weekday
;
7
]
=
[
Mon
Tue
Wed
Thu
Fri
Sat
Sun
]
;
for
weekdays
in
WeekdaySet
:
:
iter_all
(
)
{
for
split_day
in
WEEK
{
let
expected_before
:
WeekdaySet
=
WEEK
.
into_iter
(
)
.
take_while
(
|
&
day
|
day
!
=
split_day
)
.
filter
(
|
&
day
|
weekdays
.
contains
(
day
)
)
.
collect
(
)
;
let
expected_after
:
WeekdaySet
=
WEEK
.
into_iter
(
)
.
skip_while
(
|
&
day
|
day
!
=
split_day
)
.
filter
(
|
&
day
|
weekdays
.
contains
(
day
)
)
.
collect
(
)
;
assert_eq
!
(
(
expected_before
expected_after
)
weekdays
.
split_at
(
split_day
)
"
split_at
(
{
split_day
}
)
failed
for
{
weekdays
}
"
)
;
}
}
}
}
