#
!
[
doc
(
html_root_url
=
"
https
:
/
/
lifthrasiir
.
github
.
io
/
rust
-
chrono
/
"
)
]
#
!
[
cfg_attr
(
bench
feature
(
test
)
)
]
#
!
[
deny
(
missing_docs
)
]
extern
crate
time
as
stdtime
;
extern
crate
num
;
#
[
cfg
(
feature
=
"
rustc
-
serialize
"
)
]
extern
crate
rustc_serialize
;
#
[
cfg
(
feature
=
"
serde
"
)
]
extern
crate
serde
;
pub
use
duration
:
:
Duration
;
pub
use
offset
:
:
{
TimeZone
Offset
LocalResult
}
;
pub
use
offset
:
:
utc
:
:
UTC
;
pub
use
offset
:
:
fixed
:
:
FixedOffset
;
pub
use
offset
:
:
local
:
:
Local
;
pub
use
naive
:
:
date
:
:
NaiveDate
;
pub
use
naive
:
:
time
:
:
NaiveTime
;
pub
use
naive
:
:
datetime
:
:
NaiveDateTime
;
pub
use
date
:
:
Date
;
pub
use
datetime
:
:
DateTime
;
pub
use
format
:
:
{
ParseError
ParseResult
}
;
macro_rules
!
try_opt
{
(
e
:
expr
)
=
>
(
match
e
{
Some
(
v
)
=
>
v
None
=
>
return
None
}
)
}
mod
div
;
pub
mod
duration
{
pub
use
stdtime
:
:
Duration
;
}
pub
mod
offset
;
pub
mod
naive
{
pub
mod
date
;
pub
mod
time
;
pub
mod
datetime
;
}
pub
mod
date
;
pub
mod
datetime
;
pub
mod
format
;
#
[
derive
(
PartialEq
Eq
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
rustc
-
serialize
"
derive
(
RustcEncodable
RustcDecodable
)
)
]
pub
enum
Weekday
{
Mon
=
0
Tue
=
1
Wed
=
2
Thu
=
3
Fri
=
4
Sat
=
5
Sun
=
6
}
impl
Weekday
{
#
[
inline
]
pub
fn
succ
(
&
self
)
-
>
Weekday
{
match
*
self
{
Weekday
:
:
Mon
=
>
Weekday
:
:
Tue
Weekday
:
:
Tue
=
>
Weekday
:
:
Wed
Weekday
:
:
Wed
=
>
Weekday
:
:
Thu
Weekday
:
:
Thu
=
>
Weekday
:
:
Fri
Weekday
:
:
Fri
=
>
Weekday
:
:
Sat
Weekday
:
:
Sat
=
>
Weekday
:
:
Sun
Weekday
:
:
Sun
=
>
Weekday
:
:
Mon
}
}
#
[
inline
]
pub
fn
pred
(
&
self
)
-
>
Weekday
{
match
*
self
{
Weekday
:
:
Mon
=
>
Weekday
:
:
Sun
Weekday
:
:
Tue
=
>
Weekday
:
:
Mon
Weekday
:
:
Wed
=
>
Weekday
:
:
Tue
Weekday
:
:
Thu
=
>
Weekday
:
:
Wed
Weekday
:
:
Fri
=
>
Weekday
:
:
Thu
Weekday
:
:
Sat
=
>
Weekday
:
:
Fri
Weekday
:
:
Sun
=
>
Weekday
:
:
Sat
}
}
#
[
inline
]
pub
fn
number_from_monday
(
&
self
)
-
>
u32
{
match
*
self
{
Weekday
:
:
Mon
=
>
1
Weekday
:
:
Tue
=
>
2
Weekday
:
:
Wed
=
>
3
Weekday
:
:
Thu
=
>
4
Weekday
:
:
Fri
=
>
5
Weekday
:
:
Sat
=
>
6
Weekday
:
:
Sun
=
>
7
}
}
#
[
inline
]
pub
fn
number_from_sunday
(
&
self
)
-
>
u32
{
match
*
self
{
Weekday
:
:
Mon
=
>
2
Weekday
:
:
Tue
=
>
3
Weekday
:
:
Wed
=
>
4
Weekday
:
:
Thu
=
>
5
Weekday
:
:
Fri
=
>
6
Weekday
:
:
Sat
=
>
7
Weekday
:
:
Sun
=
>
1
}
}
#
[
inline
]
pub
fn
num_days_from_monday
(
&
self
)
-
>
u32
{
match
*
self
{
Weekday
:
:
Mon
=
>
0
Weekday
:
:
Tue
=
>
1
Weekday
:
:
Wed
=
>
2
Weekday
:
:
Thu
=
>
3
Weekday
:
:
Fri
=
>
4
Weekday
:
:
Sat
=
>
5
Weekday
:
:
Sun
=
>
6
}
}
#
[
inline
]
pub
fn
num_days_from_sunday
(
&
self
)
-
>
u32
{
match
*
self
{
Weekday
:
:
Mon
=
>
1
Weekday
:
:
Tue
=
>
2
Weekday
:
:
Wed
=
>
3
Weekday
:
:
Thu
=
>
4
Weekday
:
:
Fri
=
>
5
Weekday
:
:
Sat
=
>
6
Weekday
:
:
Sun
=
>
0
}
}
}
impl
num
:
:
traits
:
:
FromPrimitive
for
Weekday
{
#
[
inline
]
fn
from_i64
(
n
:
i64
)
-
>
Option
<
Weekday
>
{
match
n
{
0
=
>
Some
(
Weekday
:
:
Mon
)
1
=
>
Some
(
Weekday
:
:
Tue
)
2
=
>
Some
(
Weekday
:
:
Wed
)
3
=
>
Some
(
Weekday
:
:
Thu
)
4
=
>
Some
(
Weekday
:
:
Fri
)
5
=
>
Some
(
Weekday
:
:
Sat
)
6
=
>
Some
(
Weekday
:
:
Sun
)
_
=
>
None
}
}
#
[
inline
]
fn
from_u64
(
n
:
u64
)
-
>
Option
<
Weekday
>
{
match
n
{
0
=
>
Some
(
Weekday
:
:
Mon
)
1
=
>
Some
(
Weekday
:
:
Tue
)
2
=
>
Some
(
Weekday
:
:
Wed
)
3
=
>
Some
(
Weekday
:
:
Thu
)
4
=
>
Some
(
Weekday
:
:
Fri
)
5
=
>
Some
(
Weekday
:
:
Sat
)
6
=
>
Some
(
Weekday
:
:
Sun
)
_
=
>
None
}
}
}
pub
trait
Datelike
:
Sized
{
fn
year
(
&
self
)
-
>
i32
;
#
[
inline
]
fn
year_ce
(
&
self
)
-
>
(
bool
u32
)
{
let
year
=
self
.
year
(
)
;
if
year
<
1
{
(
false
(
1
-
year
)
as
u32
)
}
else
{
(
true
year
as
u32
)
}
}
fn
month
(
&
self
)
-
>
u32
;
fn
month0
(
&
self
)
-
>
u32
;
fn
day
(
&
self
)
-
>
u32
;
fn
day0
(
&
self
)
-
>
u32
;
fn
ordinal
(
&
self
)
-
>
u32
;
fn
ordinal0
(
&
self
)
-
>
u32
;
fn
weekday
(
&
self
)
-
>
Weekday
;
fn
isoweekdate
(
&
self
)
-
>
(
i32
u32
Weekday
)
;
fn
with_year
(
&
self
year
:
i32
)
-
>
Option
<
Self
>
;
fn
with_month
(
&
self
month
:
u32
)
-
>
Option
<
Self
>
;
fn
with_month0
(
&
self
month0
:
u32
)
-
>
Option
<
Self
>
;
fn
with_day
(
&
self
day
:
u32
)
-
>
Option
<
Self
>
;
fn
with_day0
(
&
self
day0
:
u32
)
-
>
Option
<
Self
>
;
fn
with_ordinal
(
&
self
ordinal
:
u32
)
-
>
Option
<
Self
>
;
fn
with_ordinal0
(
&
self
ordinal0
:
u32
)
-
>
Option
<
Self
>
;
fn
num_days_from_ce
(
&
self
)
-
>
i32
{
let
mut
year
=
self
.
year
(
)
-
1
;
let
mut
ndays
=
0
;
if
year
<
0
{
let
excess
=
1
+
(
-
year
)
/
400
;
year
+
=
excess
*
400
;
ndays
-
=
excess
*
146097
;
}
let
div_100
=
year
/
100
;
ndays
+
=
(
(
year
*
1461
)
>
>
2
)
-
div_100
+
(
div_100
>
>
2
)
;
ndays
+
self
.
ordinal
(
)
as
i32
}
}
pub
trait
Timelike
:
Sized
{
fn
hour
(
&
self
)
-
>
u32
;
#
[
inline
]
fn
hour12
(
&
self
)
-
>
(
bool
u32
)
{
let
hour
=
self
.
hour
(
)
;
let
mut
hour12
=
hour
%
12
;
if
hour12
=
=
0
{
hour12
=
12
;
}
(
hour
>
=
12
hour12
)
}
fn
minute
(
&
self
)
-
>
u32
;
fn
second
(
&
self
)
-
>
u32
;
fn
nanosecond
(
&
self
)
-
>
u32
;
fn
with_hour
(
&
self
hour
:
u32
)
-
>
Option
<
Self
>
;
fn
with_minute
(
&
self
min
:
u32
)
-
>
Option
<
Self
>
;
fn
with_second
(
&
self
sec
:
u32
)
-
>
Option
<
Self
>
;
fn
with_nanosecond
(
&
self
nano
:
u32
)
-
>
Option
<
Self
>
;
#
[
inline
]
fn
num_seconds_from_midnight
(
&
self
)
-
>
u32
{
self
.
hour
(
)
*
3600
+
self
.
minute
(
)
*
60
+
self
.
second
(
)
}
}
#
[
test
]
fn
test_readme_doomsday
(
)
{
use
num
:
:
iter
:
:
range_inclusive
;
for
y
in
range_inclusive
(
naive
:
:
date
:
:
MIN
.
year
(
)
naive
:
:
date
:
:
MAX
.
year
(
)
)
{
let
d4
=
NaiveDate
:
:
from_ymd
(
y
4
4
)
;
let
d6
=
NaiveDate
:
:
from_ymd
(
y
6
6
)
;
let
d8
=
NaiveDate
:
:
from_ymd
(
y
8
8
)
;
let
d10
=
NaiveDate
:
:
from_ymd
(
y
10
10
)
;
let
d12
=
NaiveDate
:
:
from_ymd
(
y
12
12
)
;
let
d59
=
NaiveDate
:
:
from_ymd
(
y
5
9
)
;
let
d95
=
NaiveDate
:
:
from_ymd
(
y
9
5
)
;
let
d711
=
NaiveDate
:
:
from_ymd
(
y
7
11
)
;
let
d117
=
NaiveDate
:
:
from_ymd
(
y
11
7
)
;
let
d30
=
NaiveDate
:
:
from_ymd
(
y
3
1
)
.
pred
(
)
;
let
weekday
=
d30
.
weekday
(
)
;
let
other_dates
=
[
d4
d6
d8
d10
d12
d59
d95
d711
d117
]
;
assert
!
(
other_dates
.
iter
(
)
.
all
(
|
d
|
d
.
weekday
(
)
=
=
weekday
)
)
;
}
}
