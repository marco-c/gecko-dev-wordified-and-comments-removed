#
!
[
allow
(
dead_code
)
]
use
std
:
:
borrow
:
:
Cow
;
use
darling
:
:
{
util
:
:
Override
FromDeriveInput
FromMeta
}
;
use
syn
:
:
{
Ident
Path
}
;
#
[
derive
(
Debug
FromDeriveInput
)
]
#
[
darling
(
attributes
(
myderive
)
)
]
struct
MyDeriveInput
{
ident
:
Ident
table
:
Override
<
Table
>
}
impl
MyDeriveInput
{
fn
table
(
&
self
)
-
>
Cow
<
'
_
Table
>
{
match
&
self
.
table
{
Override
:
:
Explicit
(
value
)
=
>
Cow
:
:
Borrowed
(
value
)
Override
:
:
Inherit
=
>
Cow
:
:
Owned
(
Table
{
name
:
self
.
ident
.
to_string
(
)
value
:
None
}
)
}
}
}
#
[
derive
(
Debug
Clone
FromMeta
)
]
struct
Table
{
name
:
String
#
[
darling
(
default
)
]
value
:
Option
<
Path
>
}
fn
from_str
(
s
:
&
str
)
-
>
darling
:
:
Result
<
MyDeriveInput
>
{
FromDeriveInput
:
:
from_derive_input
(
&
syn
:
:
parse_str
(
s
)
?
)
}
fn
main
(
)
{
let
missing
=
from_str
(
r
#
"
#
[
derive
(
MyTrait
)
]
struct
Foo
(
u64
)
;
"
#
)
.
unwrap_err
(
)
;
let
short_form
=
from_str
(
r
#
"
#
[
derive
(
MyTrait
)
]
#
[
myderive
(
table
)
]
struct
Foo
(
u64
)
;
"
#
)
.
unwrap
(
)
;
let
long_form
=
from_str
(
r
#
"
#
[
derive
(
MyTrait
)
]
#
[
myderive
(
table
(
name
=
"
Custom
"
)
)
]
struct
Foo
(
u64
)
;
"
#
)
.
unwrap
(
)
;
println
!
(
"
Error
when
missing
:
{
}
"
missing
)
;
println
!
(
"
Short
form
:
{
:
?
}
"
short_form
.
table
(
)
)
;
println
!
(
"
Long
form
:
{
:
?
}
"
long_form
.
table
(
)
)
;
}
