use
core
:
:
marker
:
:
PhantomData
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
borrow
:
:
{
Cow
ToOwned
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
string
:
:
String
;
pub
trait
ZeroFrom
<
'
zf
C
:
?
Sized
>
:
'
zf
{
fn
zero_from
(
other
:
&
'
zf
C
)
-
>
Self
;
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
zf
>
ZeroFrom
<
'
zf
str
>
for
Cow
<
'
zf
str
>
{
#
[
inline
]
fn
zero_from
(
other
:
&
'
zf
str
)
-
>
Self
{
Cow
:
:
Borrowed
(
other
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
zf
>
ZeroFrom
<
'
zf
String
>
for
Cow
<
'
zf
str
>
{
#
[
inline
]
fn
zero_from
(
other
:
&
'
zf
String
)
-
>
Self
{
Cow
:
:
Borrowed
(
other
)
}
}
impl
<
'
zf
>
ZeroFrom
<
'
zf
str
>
for
&
'
zf
str
{
#
[
inline
]
fn
zero_from
(
other
:
&
'
zf
str
)
-
>
Self
{
other
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
zf
>
ZeroFrom
<
'
zf
String
>
for
&
'
zf
str
{
#
[
inline
]
fn
zero_from
(
other
:
&
'
zf
String
)
-
>
Self
{
other
}
}
impl
<
'
zf
C
T
:
ZeroFrom
<
'
zf
C
>
>
ZeroFrom
<
'
zf
Option
<
C
>
>
for
Option
<
T
>
{
fn
zero_from
(
other
:
&
'
zf
Option
<
C
>
)
-
>
Self
{
other
.
as_ref
(
)
.
map
(
|
c
|
<
T
as
ZeroFrom
<
C
>
>
:
:
zero_from
(
c
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
zf
B
:
ToOwned
+
?
Sized
>
ZeroFrom
<
'
zf
Cow
<
'
_
B
>
>
for
Cow
<
'
zf
B
>
{
#
[
inline
]
fn
zero_from
(
other
:
&
'
zf
Cow
<
'
_
B
>
)
-
>
Self
{
Cow
:
:
Borrowed
(
other
)
}
}
impl
<
'
zf
T
:
?
Sized
>
ZeroFrom
<
'
zf
&
'
_
T
>
for
&
'
zf
T
{
#
[
inline
]
fn
zero_from
(
other
:
&
'
zf
&
'
_
T
)
-
>
&
'
zf
T
{
other
}
}
impl
<
'
zf
T
>
ZeroFrom
<
'
zf
[
T
]
>
for
&
'
zf
[
T
]
{
#
[
inline
]
fn
zero_from
(
other
:
&
'
zf
[
T
]
)
-
>
&
'
zf
[
T
]
{
other
}
}
impl
<
'
zf
T
:
?
Sized
+
'
zf
>
ZeroFrom
<
'
zf
PhantomData
<
T
>
>
for
PhantomData
<
T
>
{
fn
zero_from
(
other
:
&
'
zf
PhantomData
<
T
>
)
-
>
Self
{
*
other
}
}
