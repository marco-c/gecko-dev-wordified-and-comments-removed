#
!
[
no_std
]
#
!
[
forbid
(
missing_docs
)
]
pub
use
enumset_derive
:
:
EnumSetType
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
fmt
;
use
core
:
:
fmt
:
:
{
Debug
Formatter
}
;
use
core
:
:
hash
:
:
{
Hash
Hasher
}
;
use
core
:
:
iter
:
:
{
FromIterator
Sum
}
;
use
core
:
:
ops
:
:
*
;
#
[
doc
(
hidden
)
]
pub
mod
__internal
{
use
super
:
:
*
;
pub
use
:
:
core
as
core_export
;
#
[
cfg
(
feature
=
"
serde
"
)
]
pub
use
serde2
as
serde
;
pub
unsafe
trait
EnumSetTypePrivate
{
type
Repr
:
EnumSetTypeRepr
;
const
ALL_BITS
:
Self
:
:
Repr
;
fn
enum_into_u32
(
self
)
-
>
u32
;
unsafe
fn
enum_from_u32
(
val
:
u32
)
-
>
Self
;
#
[
cfg
(
feature
=
"
serde
"
)
]
fn
serialize
<
S
:
serde
:
:
Serializer
>
(
set
:
EnumSet
<
Self
>
ser
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
Self
:
EnumSetType
;
#
[
cfg
(
feature
=
"
serde
"
)
]
fn
deserialize
<
'
de
D
:
serde
:
:
Deserializer
<
'
de
>
>
(
de
:
D
)
-
>
Result
<
EnumSet
<
Self
>
D
:
:
Error
>
where
Self
:
EnumSetType
;
}
}
use
crate
:
:
__internal
:
:
EnumSetTypePrivate
;
#
[
cfg
(
feature
=
"
serde
"
)
]
use
crate
:
:
__internal
:
:
serde
;
#
[
cfg
(
feature
=
"
serde
"
)
]
use
crate
:
:
serde
:
:
{
Serialize
Deserialize
}
;
mod
repr
;
use
crate
:
:
repr
:
:
EnumSetTypeRepr
;
pub
unsafe
trait
EnumSetType
:
Copy
+
Eq
+
EnumSetTypePrivate
{
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
)
]
#
[
repr
(
transparent
)
]
pub
struct
EnumSet
<
T
:
EnumSetType
>
{
#
[
doc
(
hidden
)
]
pub
__priv_repr
:
T
:
:
Repr
}
impl
<
T
:
EnumSetType
>
EnumSet
<
T
>
{
#
[
inline
(
always
)
]
fn
all_bits
(
)
-
>
T
:
:
Repr
{
T
:
:
ALL_BITS
}
#
[
inline
(
always
)
]
pub
fn
new
(
)
-
>
Self
{
EnumSet
{
__priv_repr
:
T
:
:
Repr
:
:
empty
(
)
}
}
#
[
inline
(
always
)
]
pub
fn
only
(
t
:
T
)
-
>
Self
{
let
mut
set
=
Self
:
:
new
(
)
;
set
.
insert
(
t
)
;
set
}
#
[
inline
(
always
)
]
pub
fn
empty
(
)
-
>
Self
{
Self
:
:
new
(
)
}
#
[
inline
(
always
)
]
pub
fn
all
(
)
-
>
Self
{
EnumSet
{
__priv_repr
:
Self
:
:
all_bits
(
)
}
}
#
[
inline
(
always
)
]
pub
fn
bit_width
(
)
-
>
u32
{
T
:
:
Repr
:
:
WIDTH
-
T
:
:
ALL_BITS
.
leading_zeros
(
)
}
#
[
inline
(
always
)
]
pub
fn
variant_count
(
)
-
>
u32
{
T
:
:
ALL_BITS
.
count_ones
(
)
}
#
[
inline
(
always
)
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
__priv_repr
.
count_ones
(
)
as
usize
}
#
[
inline
(
always
)
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
__priv_repr
.
is_empty
(
)
}
#
[
inline
(
always
)
]
pub
fn
clear
(
&
mut
self
)
{
self
.
__priv_repr
=
T
:
:
Repr
:
:
empty
(
)
}
#
[
inline
(
always
)
]
pub
fn
is_disjoint
(
&
self
other
:
Self
)
-
>
bool
{
(
*
self
&
other
)
.
is_empty
(
)
}
#
[
inline
(
always
)
]
pub
fn
is_superset
(
&
self
other
:
Self
)
-
>
bool
{
(
*
self
&
other
)
.
__priv_repr
=
=
other
.
__priv_repr
}
#
[
inline
(
always
)
]
pub
fn
is_subset
(
&
self
other
:
Self
)
-
>
bool
{
other
.
is_superset
(
*
self
)
}
#
[
inline
(
always
)
]
pub
fn
union
(
&
self
other
:
Self
)
-
>
Self
{
EnumSet
{
__priv_repr
:
self
.
__priv_repr
|
other
.
__priv_repr
}
}
#
[
inline
(
always
)
]
pub
fn
intersection
(
&
self
other
:
Self
)
-
>
Self
{
EnumSet
{
__priv_repr
:
self
.
__priv_repr
&
other
.
__priv_repr
}
}
#
[
inline
(
always
)
]
pub
fn
difference
(
&
self
other
:
Self
)
-
>
Self
{
EnumSet
{
__priv_repr
:
self
.
__priv_repr
.
and_not
(
other
.
__priv_repr
)
}
}
#
[
inline
(
always
)
]
pub
fn
symmetrical_difference
(
&
self
other
:
Self
)
-
>
Self
{
EnumSet
{
__priv_repr
:
self
.
__priv_repr
^
other
.
__priv_repr
}
}
#
[
inline
(
always
)
]
pub
fn
complement
(
&
self
)
-
>
Self
{
EnumSet
{
__priv_repr
:
!
self
.
__priv_repr
&
Self
:
:
all_bits
(
)
}
}
#
[
inline
(
always
)
]
pub
fn
contains
(
&
self
value
:
T
)
-
>
bool
{
self
.
__priv_repr
.
has_bit
(
value
.
enum_into_u32
(
)
)
}
#
[
inline
(
always
)
]
pub
fn
insert
(
&
mut
self
value
:
T
)
-
>
bool
{
let
contains
=
!
self
.
contains
(
value
)
;
self
.
__priv_repr
.
add_bit
(
value
.
enum_into_u32
(
)
)
;
contains
}
#
[
inline
(
always
)
]
pub
fn
remove
(
&
mut
self
value
:
T
)
-
>
bool
{
let
contains
=
self
.
contains
(
value
)
;
self
.
__priv_repr
.
remove_bit
(
value
.
enum_into_u32
(
)
)
;
contains
}
#
[
inline
(
always
)
]
pub
fn
insert_all
(
&
mut
self
other
:
Self
)
{
self
.
__priv_repr
=
self
.
__priv_repr
|
other
.
__priv_repr
}
#
[
inline
(
always
)
]
pub
fn
remove_all
(
&
mut
self
other
:
Self
)
{
self
.
__priv_repr
=
self
.
__priv_repr
.
and_not
(
other
.
__priv_repr
)
;
}
pub
fn
iter
(
&
self
)
-
>
EnumSetIter
<
T
>
{
EnumSetIter
:
:
new
(
*
self
)
}
}
macro_rules
!
conversion_impls
{
(
(
for_num
!
(
underlying
:
ty
underlying_str
:
expr
from_fn
:
ident
to_fn
:
ident
from_fn_opt
:
ident
to_fn_opt
:
ident
from
:
ident
try_from
:
ident
from_truncated
:
ident
to
:
ident
try_to
:
ident
to_truncated
:
ident
)
;
)
*
)
=
>
{
impl
<
T
:
EnumSetType
>
EnumSet
<
T
>
{
(
#
[
doc
=
"
Returns
a
"
]
#
[
doc
=
underlying_str
]
#
[
doc
=
"
representing
the
elements
of
this
set
.
\
n
\
nIf
the
underlying
bitset
will
\
not
fit
in
a
"
]
#
[
doc
=
underlying_str
]
#
[
doc
=
"
this
method
will
panic
.
"
]
#
[
inline
(
always
)
]
pub
fn
to
(
&
self
)
-
>
underlying
{
self
.
try_to
(
)
.
expect
(
"
Bitset
will
not
fit
into
this
type
.
"
)
}
#
[
doc
=
"
Tries
to
return
a
"
]
#
[
doc
=
underlying_str
]
#
[
doc
=
"
representing
the
elements
of
this
set
.
\
n
\
nIf
the
underlying
bitset
will
\
not
fit
in
a
"
]
#
[
doc
=
underlying_str
]
#
[
doc
=
"
this
method
will
instead
return
None
.
"
]
#
[
inline
(
always
)
]
pub
fn
try_to
(
&
self
)
-
>
Option
<
underlying
>
{
EnumSetTypeRepr
:
:
to_fn_opt
(
&
self
.
__priv_repr
)
}
#
[
doc
=
"
Returns
a
truncated
"
]
#
[
doc
=
underlying_str
]
#
[
doc
=
"
representing
the
elements
of
this
set
.
\
n
\
nIf
the
underlying
bitset
will
\
not
fit
in
a
"
]
#
[
doc
=
underlying_str
]
#
[
doc
=
"
this
method
will
truncate
any
bits
that
don
'
t
fit
.
"
]
#
[
inline
(
always
)
]
pub
fn
to_truncated
(
&
self
)
-
>
underlying
{
EnumSetTypeRepr
:
:
to_fn
(
&
self
.
__priv_repr
)
}
#
[
doc
=
"
Constructs
a
bitset
from
a
"
]
#
[
doc
=
underlying_str
]
#
[
doc
=
"
.
\
n
\
nIf
a
bit
that
doesn
'
t
correspond
to
an
enum
variant
is
set
this
\
method
will
panic
.
"
]
#
[
inline
(
always
)
]
pub
fn
from
(
bits
:
underlying
)
-
>
Self
{
Self
:
:
try_from
(
bits
)
.
expect
(
"
Bitset
contains
invalid
variants
.
"
)
}
#
[
doc
=
"
Attempts
to
constructs
a
bitset
from
a
"
]
#
[
doc
=
underlying_str
]
#
[
doc
=
"
.
\
n
\
nIf
a
bit
that
doesn
'
t
correspond
to
an
enum
variant
is
set
this
\
method
will
return
None
.
"
]
#
[
inline
(
always
)
]
pub
fn
try_from
(
bits
:
underlying
)
-
>
Option
<
Self
>
{
let
bits
=
T
:
:
Repr
:
:
from_fn_opt
(
bits
)
;
let
mask
=
Self
:
:
all
(
)
.
__priv_repr
;
bits
.
and_then
(
|
bits
|
if
bits
.
and_not
(
mask
)
.
is_empty
(
)
{
Some
(
EnumSet
{
__priv_repr
:
bits
}
)
}
else
{
None
}
)
}
#
[
doc
=
"
Constructs
a
bitset
from
a
"
]
#
[
doc
=
underlying_str
]
#
[
doc
=
"
ignoring
invalid
variants
.
"
]
#
[
inline
(
always
)
]
pub
fn
from_truncated
(
bits
:
underlying
)
-
>
Self
{
let
mask
=
Self
:
:
all
(
)
.
to_truncated
(
)
;
let
bits
=
<
T
:
:
Repr
as
EnumSetTypeRepr
>
:
:
from_fn
(
bits
&
mask
)
;
EnumSet
{
__priv_repr
:
bits
}
}
)
*
}
}
}
conversion_impls
!
{
for_num
!
(
u8
"
u8
"
from_u8
to_u8
from_u8_opt
to_u8_opt
from_u8
try_from_u8
from_u8_truncated
as_u8
try_as_u8
as_u8_truncated
)
;
for_num
!
(
u16
"
u16
"
from_u16
to_u16
from_u16_opt
to_u16_opt
from_u16
try_from_u16
from_u16_truncated
as_u16
try_as_u16
as_u16_truncated
)
;
for_num
!
(
u32
"
u32
"
from_u32
to_u32
from_u32_opt
to_u32_opt
from_u32
try_from_u32
from_u32_truncated
as_u32
try_as_u32
as_u32_truncated
)
;
for_num
!
(
u64
"
u64
"
from_u64
to_u64
from_u64_opt
to_u64_opt
from_u64
try_from_u64
from_u64_truncated
as_u64
try_as_u64
as_u64_truncated
)
;
for_num
!
(
u128
"
u128
"
from_u128
to_u128
from_u128_opt
to_u128_opt
from_u128
try_from_u128
from_u128_truncated
as_u128
try_as_u128
as_u128_truncated
)
;
for_num
!
(
usize
"
usize
"
from_usize
to_usize
from_usize_opt
to_usize_opt
from_usize
try_from_usize
from_usize_truncated
as_usize
try_as_usize
as_usize_truncated
)
;
}
impl
<
T
:
EnumSetType
>
Default
for
EnumSet
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
T
:
EnumSetType
>
IntoIterator
for
EnumSet
<
T
>
{
type
Item
=
T
;
type
IntoIter
=
EnumSetIter
<
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
iter
(
)
}
}
impl
<
T
:
EnumSetType
>
Sum
for
EnumSet
<
T
>
{
fn
sum
<
I
:
Iterator
<
Item
=
Self
>
>
(
iter
:
I
)
-
>
Self
{
iter
.
fold
(
EnumSet
:
:
empty
(
)
|
a
v
|
a
|
v
)
}
}
impl
<
'
a
T
:
EnumSetType
>
Sum
<
&
'
a
EnumSet
<
T
>
>
for
EnumSet
<
T
>
{
fn
sum
<
I
:
Iterator
<
Item
=
&
'
a
Self
>
>
(
iter
:
I
)
-
>
Self
{
iter
.
fold
(
EnumSet
:
:
empty
(
)
|
a
v
|
a
|
*
v
)
}
}
impl
<
T
:
EnumSetType
>
Sum
<
T
>
for
EnumSet
<
T
>
{
fn
sum
<
I
:
Iterator
<
Item
=
T
>
>
(
iter
:
I
)
-
>
Self
{
iter
.
fold
(
EnumSet
:
:
empty
(
)
|
a
v
|
a
|
v
)
}
}
impl
<
'
a
T
:
EnumSetType
>
Sum
<
&
'
a
T
>
for
EnumSet
<
T
>
{
fn
sum
<
I
:
Iterator
<
Item
=
&
'
a
T
>
>
(
iter
:
I
)
-
>
Self
{
iter
.
fold
(
EnumSet
:
:
empty
(
)
|
a
v
|
a
|
*
v
)
}
}
impl
<
T
:
EnumSetType
O
:
Into
<
EnumSet
<
T
>
>
>
Sub
<
O
>
for
EnumSet
<
T
>
{
type
Output
=
Self
;
#
[
inline
(
always
)
]
fn
sub
(
self
other
:
O
)
-
>
Self
:
:
Output
{
self
.
difference
(
other
.
into
(
)
)
}
}
impl
<
T
:
EnumSetType
O
:
Into
<
EnumSet
<
T
>
>
>
BitAnd
<
O
>
for
EnumSet
<
T
>
{
type
Output
=
Self
;
#
[
inline
(
always
)
]
fn
bitand
(
self
other
:
O
)
-
>
Self
:
:
Output
{
self
.
intersection
(
other
.
into
(
)
)
}
}
impl
<
T
:
EnumSetType
O
:
Into
<
EnumSet
<
T
>
>
>
BitOr
<
O
>
for
EnumSet
<
T
>
{
type
Output
=
Self
;
#
[
inline
(
always
)
]
fn
bitor
(
self
other
:
O
)
-
>
Self
:
:
Output
{
self
.
union
(
other
.
into
(
)
)
}
}
impl
<
T
:
EnumSetType
O
:
Into
<
EnumSet
<
T
>
>
>
BitXor
<
O
>
for
EnumSet
<
T
>
{
type
Output
=
Self
;
#
[
inline
(
always
)
]
fn
bitxor
(
self
other
:
O
)
-
>
Self
:
:
Output
{
self
.
symmetrical_difference
(
other
.
into
(
)
)
}
}
impl
<
T
:
EnumSetType
O
:
Into
<
EnumSet
<
T
>
>
>
SubAssign
<
O
>
for
EnumSet
<
T
>
{
#
[
inline
(
always
)
]
fn
sub_assign
(
&
mut
self
rhs
:
O
)
{
*
self
=
*
self
-
rhs
;
}
}
impl
<
T
:
EnumSetType
O
:
Into
<
EnumSet
<
T
>
>
>
BitAndAssign
<
O
>
for
EnumSet
<
T
>
{
#
[
inline
(
always
)
]
fn
bitand_assign
(
&
mut
self
rhs
:
O
)
{
*
self
=
*
self
&
rhs
;
}
}
impl
<
T
:
EnumSetType
O
:
Into
<
EnumSet
<
T
>
>
>
BitOrAssign
<
O
>
for
EnumSet
<
T
>
{
#
[
inline
(
always
)
]
fn
bitor_assign
(
&
mut
self
rhs
:
O
)
{
*
self
=
*
self
|
rhs
;
}
}
impl
<
T
:
EnumSetType
O
:
Into
<
EnumSet
<
T
>
>
>
BitXorAssign
<
O
>
for
EnumSet
<
T
>
{
#
[
inline
(
always
)
]
fn
bitxor_assign
(
&
mut
self
rhs
:
O
)
{
*
self
=
*
self
^
rhs
;
}
}
impl
<
T
:
EnumSetType
>
Not
for
EnumSet
<
T
>
{
type
Output
=
Self
;
#
[
inline
(
always
)
]
fn
not
(
self
)
-
>
Self
:
:
Output
{
self
.
complement
(
)
}
}
impl
<
T
:
EnumSetType
>
From
<
T
>
for
EnumSet
<
T
>
{
fn
from
(
t
:
T
)
-
>
Self
{
EnumSet
:
:
only
(
t
)
}
}
impl
<
T
:
EnumSetType
>
PartialEq
<
T
>
for
EnumSet
<
T
>
{
fn
eq
(
&
self
other
:
&
T
)
-
>
bool
{
self
.
__priv_repr
=
=
EnumSet
:
:
only
(
*
other
)
.
__priv_repr
}
}
impl
<
T
:
EnumSetType
+
Debug
>
Debug
for
EnumSet
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
mut
is_first
=
true
;
f
.
write_str
(
"
EnumSet
(
"
)
?
;
for
v
in
self
.
iter
(
)
{
if
!
is_first
{
f
.
write_str
(
"
|
"
)
?
;
}
is_first
=
false
;
v
.
fmt
(
f
)
?
;
}
f
.
write_str
(
"
)
"
)
?
;
Ok
(
(
)
)
}
}
#
[
allow
(
clippy
:
:
derive_hash_xor_eq
)
]
impl
<
T
:
EnumSetType
>
Hash
for
EnumSet
<
T
>
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
__priv_repr
.
hash
(
state
)
}
}
impl
<
T
:
EnumSetType
>
PartialOrd
for
EnumSet
<
T
>
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
self
.
__priv_repr
.
partial_cmp
(
&
other
.
__priv_repr
)
}
}
impl
<
T
:
EnumSetType
>
Ord
for
EnumSet
<
T
>
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
self
.
__priv_repr
.
cmp
(
&
other
.
__priv_repr
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
T
:
EnumSetType
>
Serialize
for
EnumSet
<
T
>
{
fn
serialize
<
S
:
serde
:
:
Serializer
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
{
T
:
:
serialize
(
*
self
serializer
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
T
:
EnumSetType
>
Deserialize
<
'
de
>
for
EnumSet
<
T
>
{
fn
deserialize
<
D
:
serde
:
:
Deserializer
<
'
de
>
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
{
T
:
:
deserialize
(
deserializer
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
EnumSetIter
<
T
:
EnumSetType
>
{
set
:
EnumSet
<
T
>
}
impl
<
T
:
EnumSetType
>
EnumSetIter
<
T
>
{
fn
new
(
set
:
EnumSet
<
T
>
)
-
>
EnumSetIter
<
T
>
{
EnumSetIter
{
set
}
}
}
impl
<
T
:
EnumSetType
>
Iterator
for
EnumSetIter
<
T
>
{
type
Item
=
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
set
.
is_empty
(
)
{
None
}
else
{
let
bit
=
self
.
set
.
__priv_repr
.
trailing_zeros
(
)
;
self
.
set
.
__priv_repr
.
remove_bit
(
bit
)
;
unsafe
{
Some
(
T
:
:
enum_from_u32
(
bit
)
)
}
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
left
=
self
.
set
.
len
(
)
;
(
left
Some
(
left
)
)
}
}
impl
<
T
:
EnumSetType
>
ExactSizeIterator
for
EnumSetIter
<
T
>
{
}
impl
<
T
:
EnumSetType
>
Extend
<
T
>
for
EnumSet
<
T
>
{
fn
extend
<
I
:
IntoIterator
<
Item
=
T
>
>
(
&
mut
self
iter
:
I
)
{
iter
.
into_iter
(
)
.
for_each
(
|
v
|
{
self
.
insert
(
v
)
;
}
)
;
}
}
impl
<
T
:
EnumSetType
>
FromIterator
<
T
>
for
EnumSet
<
T
>
{
fn
from_iter
<
I
:
IntoIterator
<
Item
=
T
>
>
(
iter
:
I
)
-
>
Self
{
let
mut
set
=
EnumSet
:
:
default
(
)
;
set
.
extend
(
iter
)
;
set
}
}
impl
<
T
:
EnumSetType
>
Extend
<
EnumSet
<
T
>
>
for
EnumSet
<
T
>
{
fn
extend
<
I
:
IntoIterator
<
Item
=
EnumSet
<
T
>
>
>
(
&
mut
self
iter
:
I
)
{
iter
.
into_iter
(
)
.
for_each
(
|
v
|
{
self
.
insert_all
(
v
)
;
}
)
;
}
}
impl
<
T
:
EnumSetType
>
FromIterator
<
EnumSet
<
T
>
>
for
EnumSet
<
T
>
{
fn
from_iter
<
I
:
IntoIterator
<
Item
=
EnumSet
<
T
>
>
>
(
iter
:
I
)
-
>
Self
{
let
mut
set
=
EnumSet
:
:
default
(
)
;
set
.
extend
(
iter
)
;
set
}
}
#
[
macro_export
]
macro_rules
!
enum_set
{
(
(
|
)
*
)
=
>
{
crate
:
:
EnumSet
{
__priv_repr
:
0
}
}
;
(
value
:
path
(
|
)
*
)
=
>
{
{
#
[
allow
(
deprecated
)
]
let
value
=
value
.
__impl_enumset_internal__const_only
(
)
;
value
}
}
;
(
value
:
path
|
(
rest
:
path
)
|
*
(
|
)
*
)
=
>
{
{
#
[
allow
(
deprecated
)
]
let
value
=
value
.
__impl_enumset_internal__const_only
(
)
;
(
#
[
allow
(
deprecated
)
]
let
value
=
rest
.
__impl_enumset_internal__const_merge
(
value
)
;
)
*
value
}
}
;
}
