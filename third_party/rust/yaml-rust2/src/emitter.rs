use
crate
:
:
char_traits
;
use
crate
:
:
yaml
:
:
{
Hash
Yaml
}
;
use
std
:
:
convert
:
:
From
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
:
:
{
self
Display
}
;
#
[
derive
(
Copy
Clone
Debug
)
]
pub
enum
EmitError
{
FmtError
(
fmt
:
:
Error
)
}
impl
Error
for
EmitError
{
fn
cause
(
&
self
)
-
>
Option
<
&
dyn
Error
>
{
None
}
}
impl
Display
for
EmitError
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
EmitError
:
:
FmtError
(
ref
err
)
=
>
Display
:
:
fmt
(
err
formatter
)
}
}
}
impl
From
<
fmt
:
:
Error
>
for
EmitError
{
fn
from
(
f
:
fmt
:
:
Error
)
-
>
Self
{
EmitError
:
:
FmtError
(
f
)
}
}
#
[
allow
(
clippy
:
:
module_name_repetitions
)
]
pub
struct
YamlEmitter
<
'
a
>
{
writer
:
&
'
a
mut
dyn
fmt
:
:
Write
best_indent
:
usize
compact
:
bool
level
:
isize
multiline_strings
:
bool
}
pub
type
EmitResult
=
Result
<
(
)
EmitError
>
;
fn
escape_str
(
wr
:
&
mut
dyn
fmt
:
:
Write
v
:
&
str
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
wr
.
write_str
(
"
\
"
"
)
?
;
let
mut
start
=
0
;
for
(
i
byte
)
in
v
.
bytes
(
)
.
enumerate
(
)
{
let
escaped
=
match
byte
{
b
'
"
'
=
>
"
\
\
\
"
"
b
'
\
\
'
=
>
"
\
\
\
\
"
b
'
\
x00
'
=
>
"
\
\
u0000
"
b
'
\
x01
'
=
>
"
\
\
u0001
"
b
'
\
x02
'
=
>
"
\
\
u0002
"
b
'
\
x03
'
=
>
"
\
\
u0003
"
b
'
\
x04
'
=
>
"
\
\
u0004
"
b
'
\
x05
'
=
>
"
\
\
u0005
"
b
'
\
x06
'
=
>
"
\
\
u0006
"
b
'
\
x07
'
=
>
"
\
\
u0007
"
b
'
\
x08
'
=
>
"
\
\
b
"
b
'
\
t
'
=
>
"
\
\
t
"
b
'
\
n
'
=
>
"
\
\
n
"
b
'
\
x0b
'
=
>
"
\
\
u000b
"
b
'
\
x0c
'
=
>
"
\
\
f
"
b
'
\
r
'
=
>
"
\
\
r
"
b
'
\
x0e
'
=
>
"
\
\
u000e
"
b
'
\
x0f
'
=
>
"
\
\
u000f
"
b
'
\
x10
'
=
>
"
\
\
u0010
"
b
'
\
x11
'
=
>
"
\
\
u0011
"
b
'
\
x12
'
=
>
"
\
\
u0012
"
b
'
\
x13
'
=
>
"
\
\
u0013
"
b
'
\
x14
'
=
>
"
\
\
u0014
"
b
'
\
x15
'
=
>
"
\
\
u0015
"
b
'
\
x16
'
=
>
"
\
\
u0016
"
b
'
\
x17
'
=
>
"
\
\
u0017
"
b
'
\
x18
'
=
>
"
\
\
u0018
"
b
'
\
x19
'
=
>
"
\
\
u0019
"
b
'
\
x1a
'
=
>
"
\
\
u001a
"
b
'
\
x1b
'
=
>
"
\
\
u001b
"
b
'
\
x1c
'
=
>
"
\
\
u001c
"
b
'
\
x1d
'
=
>
"
\
\
u001d
"
b
'
\
x1e
'
=
>
"
\
\
u001e
"
b
'
\
x1f
'
=
>
"
\
\
u001f
"
b
'
\
x7f
'
=
>
"
\
\
u007f
"
_
=
>
continue
}
;
if
start
<
i
{
wr
.
write_str
(
&
v
[
start
.
.
i
]
)
?
;
}
wr
.
write_str
(
escaped
)
?
;
start
=
i
+
1
;
}
if
start
!
=
v
.
len
(
)
{
wr
.
write_str
(
&
v
[
start
.
.
]
)
?
;
}
wr
.
write_str
(
"
\
"
"
)
?
;
Ok
(
(
)
)
}
impl
<
'
a
>
YamlEmitter
<
'
a
>
{
pub
fn
new
(
writer
:
&
'
a
mut
dyn
fmt
:
:
Write
)
-
>
YamlEmitter
<
'
a
>
{
YamlEmitter
{
writer
best_indent
:
2
compact
:
true
level
:
-
1
multiline_strings
:
false
}
}
pub
fn
compact
(
&
mut
self
compact
:
bool
)
{
self
.
compact
=
compact
;
}
#
[
must_use
]
pub
fn
is_compact
(
&
self
)
-
>
bool
{
self
.
compact
}
pub
fn
multiline_strings
(
&
mut
self
multiline_strings
:
bool
)
{
self
.
multiline_strings
=
multiline_strings
;
}
#
[
must_use
]
pub
fn
is_multiline_strings
(
&
self
)
-
>
bool
{
self
.
multiline_strings
}
pub
fn
dump
(
&
mut
self
doc
:
&
Yaml
)
-
>
EmitResult
{
writeln
!
(
self
.
writer
"
-
-
-
"
)
?
;
self
.
level
=
-
1
;
self
.
emit_node
(
doc
)
}
fn
write_indent
(
&
mut
self
)
-
>
EmitResult
{
if
self
.
level
<
=
0
{
return
Ok
(
(
)
)
;
}
for
_
in
0
.
.
self
.
level
{
for
_
in
0
.
.
self
.
best_indent
{
write
!
(
self
.
writer
"
"
)
?
;
}
}
Ok
(
(
)
)
}
fn
emit_node
(
&
mut
self
node
:
&
Yaml
)
-
>
EmitResult
{
match
*
node
{
Yaml
:
:
Array
(
ref
v
)
=
>
self
.
emit_array
(
v
)
Yaml
:
:
Hash
(
ref
h
)
=
>
self
.
emit_hash
(
h
)
Yaml
:
:
String
(
ref
v
)
=
>
{
if
self
.
multiline_strings
&
&
v
.
contains
(
'
\
n
'
)
&
&
char_traits
:
:
is_valid_literal_block_scalar
(
v
)
{
self
.
emit_literal_block
(
v
)
?
;
}
else
if
need_quotes
(
v
)
{
escape_str
(
self
.
writer
v
)
?
;
}
else
{
write
!
(
self
.
writer
"
{
v
}
"
)
?
;
}
Ok
(
(
)
)
}
Yaml
:
:
Boolean
(
v
)
=
>
{
if
v
{
self
.
writer
.
write_str
(
"
true
"
)
?
;
}
else
{
self
.
writer
.
write_str
(
"
false
"
)
?
;
}
Ok
(
(
)
)
}
Yaml
:
:
Integer
(
v
)
=
>
{
write
!
(
self
.
writer
"
{
v
}
"
)
?
;
Ok
(
(
)
)
}
Yaml
:
:
Real
(
ref
v
)
=
>
{
write
!
(
self
.
writer
"
{
v
}
"
)
?
;
Ok
(
(
)
)
}
Yaml
:
:
Null
|
Yaml
:
:
BadValue
=
>
{
write
!
(
self
.
writer
"
~
"
)
?
;
Ok
(
(
)
)
}
Yaml
:
:
Alias
(
_
)
=
>
Ok
(
(
)
)
}
}
fn
emit_literal_block
(
&
mut
self
v
:
&
str
)
-
>
EmitResult
{
let
ends_with_newline
=
v
.
ends_with
(
'
\
n
'
)
;
if
ends_with_newline
{
self
.
writer
.
write_str
(
"
|
"
)
?
;
}
else
{
self
.
writer
.
write_str
(
"
|
-
"
)
?
;
}
self
.
level
+
=
1
;
for
line
in
v
.
lines
(
)
{
writeln
!
(
self
.
writer
)
?
;
self
.
write_indent
(
)
?
;
self
.
writer
.
write_str
(
line
)
?
;
}
self
.
level
-
=
1
;
Ok
(
(
)
)
}
fn
emit_array
(
&
mut
self
v
:
&
[
Yaml
]
)
-
>
EmitResult
{
if
v
.
is_empty
(
)
{
write
!
(
self
.
writer
"
[
]
"
)
?
;
}
else
{
self
.
level
+
=
1
;
for
(
cnt
x
)
in
v
.
iter
(
)
.
enumerate
(
)
{
if
cnt
>
0
{
writeln
!
(
self
.
writer
)
?
;
self
.
write_indent
(
)
?
;
}
write
!
(
self
.
writer
"
-
"
)
?
;
self
.
emit_val
(
true
x
)
?
;
}
self
.
level
-
=
1
;
}
Ok
(
(
)
)
}
fn
emit_hash
(
&
mut
self
h
:
&
Hash
)
-
>
EmitResult
{
if
h
.
is_empty
(
)
{
self
.
writer
.
write_str
(
"
{
}
"
)
?
;
}
else
{
self
.
level
+
=
1
;
for
(
cnt
(
k
v
)
)
in
h
.
iter
(
)
.
enumerate
(
)
{
let
complex_key
=
matches
!
(
*
k
Yaml
:
:
Hash
(
_
)
|
Yaml
:
:
Array
(
_
)
)
;
if
cnt
>
0
{
writeln
!
(
self
.
writer
)
?
;
self
.
write_indent
(
)
?
;
}
if
complex_key
{
write
!
(
self
.
writer
"
?
"
)
?
;
self
.
emit_val
(
true
k
)
?
;
writeln
!
(
self
.
writer
)
?
;
self
.
write_indent
(
)
?
;
write
!
(
self
.
writer
"
:
"
)
?
;
self
.
emit_val
(
true
v
)
?
;
}
else
{
self
.
emit_node
(
k
)
?
;
write
!
(
self
.
writer
"
:
"
)
?
;
self
.
emit_val
(
false
v
)
?
;
}
}
self
.
level
-
=
1
;
}
Ok
(
(
)
)
}
fn
emit_val
(
&
mut
self
inline
:
bool
val
:
&
Yaml
)
-
>
EmitResult
{
match
*
val
{
Yaml
:
:
Array
(
ref
v
)
=
>
{
if
(
inline
&
&
self
.
compact
)
|
|
v
.
is_empty
(
)
{
write
!
(
self
.
writer
"
"
)
?
;
}
else
{
writeln
!
(
self
.
writer
)
?
;
self
.
level
+
=
1
;
self
.
write_indent
(
)
?
;
self
.
level
-
=
1
;
}
self
.
emit_array
(
v
)
}
Yaml
:
:
Hash
(
ref
h
)
=
>
{
if
(
inline
&
&
self
.
compact
)
|
|
h
.
is_empty
(
)
{
write
!
(
self
.
writer
"
"
)
?
;
}
else
{
writeln
!
(
self
.
writer
)
?
;
self
.
level
+
=
1
;
self
.
write_indent
(
)
?
;
self
.
level
-
=
1
;
}
self
.
emit_hash
(
h
)
}
_
=
>
{
write
!
(
self
.
writer
"
"
)
?
;
self
.
emit_node
(
val
)
}
}
}
}
#
[
allow
(
clippy
:
:
doc_markdown
)
]
fn
need_quotes
(
string
:
&
str
)
-
>
bool
{
fn
need_quotes_spaces
(
string
:
&
str
)
-
>
bool
{
string
.
starts_with
(
'
'
)
|
|
string
.
ends_with
(
'
'
)
}
string
.
is_empty
(
)
|
|
need_quotes_spaces
(
string
)
|
|
string
.
starts_with
(
|
character
:
char
|
{
matches
!
(
character
'
&
'
|
'
*
'
|
'
?
'
|
'
|
'
|
'
-
'
|
'
<
'
|
'
>
'
|
'
=
'
|
'
!
'
|
'
%
'
|
'
'
)
}
)
|
|
string
.
contains
(
|
character
:
char
|
{
matches
!
(
character
'
:
'
|
'
{
'
|
'
}
'
|
'
[
'
|
'
]
'
|
'
'
|
'
#
'
|
'
'
|
'
\
"
'
|
'
\
'
'
|
'
\
\
'
|
'
\
0
'
.
.
=
'
\
x06
'
|
'
\
t
'
|
'
\
n
'
|
'
\
r
'
|
'
\
x0e
'
.
.
=
'
\
x1a
'
|
'
\
x1c
'
.
.
=
'
\
x1f
'
)
}
)
|
|
[
"
true
"
"
false
"
"
True
"
"
False
"
"
TRUE
"
"
FALSE
"
"
null
"
"
Null
"
"
NULL
"
"
~
"
"
y
"
"
Y
"
"
n
"
"
N
"
"
yes
"
"
Yes
"
"
YES
"
"
no
"
"
No
"
"
NO
"
"
True
"
"
TRUE
"
"
False
"
"
FALSE
"
"
on
"
"
On
"
"
ON
"
"
off
"
"
Off
"
"
OFF
"
]
.
contains
(
&
string
)
|
|
string
.
starts_with
(
'
.
'
)
|
|
string
.
starts_with
(
"
0x
"
)
|
|
string
.
parse
:
:
<
i64
>
(
)
.
is_ok
(
)
|
|
string
.
parse
:
:
<
f64
>
(
)
.
is_ok
(
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
YamlEmitter
;
use
crate
:
:
YamlLoader
;
#
[
test
]
fn
test_multiline_string
(
)
{
let
input
=
r
#
"
{
foo
:
"
bar
!
\
nbar
!
"
baz
:
42
}
"
#
;
let
parsed
=
YamlLoader
:
:
load_from_str
(
input
)
.
unwrap
(
)
;
let
mut
output
=
String
:
:
new
(
)
;
let
mut
emitter
=
YamlEmitter
:
:
new
(
&
mut
output
)
;
emitter
.
multiline_strings
(
true
)
;
emitter
.
dump
(
&
parsed
[
0
]
)
.
unwrap
(
)
;
}
}
