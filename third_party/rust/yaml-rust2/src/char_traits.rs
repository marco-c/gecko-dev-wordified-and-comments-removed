#
[
inline
]
pub
(
crate
)
fn
is_z
(
c
:
char
)
-
>
bool
{
c
=
=
'
\
0
'
}
#
[
inline
]
pub
(
crate
)
fn
is_break
(
c
:
char
)
-
>
bool
{
c
=
=
'
\
n
'
|
|
c
=
=
'
\
r
'
}
#
[
inline
]
pub
(
crate
)
fn
is_breakz
(
c
:
char
)
-
>
bool
{
is_break
(
c
)
|
|
is_z
(
c
)
}
#
[
inline
]
pub
(
crate
)
fn
is_blank
(
c
:
char
)
-
>
bool
{
c
=
=
'
'
|
|
c
=
=
'
\
t
'
}
#
[
inline
]
pub
(
crate
)
fn
is_blank_or_breakz
(
c
:
char
)
-
>
bool
{
is_blank
(
c
)
|
|
is_breakz
(
c
)
}
#
[
inline
]
pub
(
crate
)
fn
is_digit
(
c
:
char
)
-
>
bool
{
c
.
is_ascii_digit
(
)
}
#
[
inline
]
pub
(
crate
)
fn
is_alpha
(
c
:
char
)
-
>
bool
{
matches
!
(
c
'
0
'
.
.
=
'
9
'
|
'
a
'
.
.
=
'
z
'
|
'
A
'
.
.
=
'
Z
'
|
'
_
'
|
'
-
'
)
}
#
[
inline
]
pub
(
crate
)
fn
is_hex
(
c
:
char
)
-
>
bool
{
c
.
is_ascii_digit
(
)
|
|
(
'
a
'
.
.
=
'
f
'
)
.
contains
(
&
c
)
|
|
(
'
A
'
.
.
=
'
F
'
)
.
contains
(
&
c
)
}
#
[
inline
]
pub
(
crate
)
fn
as_hex
(
c
:
char
)
-
>
u32
{
match
c
{
'
0
'
.
.
=
'
9
'
=
>
(
c
as
u32
)
-
(
'
0
'
as
u32
)
'
a
'
.
.
=
'
f
'
=
>
(
c
as
u32
)
-
(
'
a
'
as
u32
)
+
10
'
A
'
.
.
=
'
F
'
=
>
(
c
as
u32
)
-
(
'
A
'
as
u32
)
+
10
_
=
>
unreachable
!
(
)
}
}
#
[
inline
]
pub
(
crate
)
fn
is_flow
(
c
:
char
)
-
>
bool
{
matches
!
(
c
'
'
|
'
[
'
|
'
]
'
|
'
{
'
|
'
}
'
)
}
#
[
inline
]
pub
(
crate
)
fn
is_bom
(
c
:
char
)
-
>
bool
{
c
=
=
'
\
u
{
FEFF
}
'
}
#
[
inline
]
pub
(
crate
)
fn
is_yaml_non_break
(
c
:
char
)
-
>
bool
{
!
is_break
(
c
)
&
&
!
is_bom
(
c
)
}
#
[
inline
]
pub
(
crate
)
fn
is_yaml_non_space
(
c
:
char
)
-
>
bool
{
is_yaml_non_break
(
c
)
&
&
!
is_blank
(
c
)
}
#
[
inline
]
pub
(
crate
)
fn
is_anchor_char
(
c
:
char
)
-
>
bool
{
is_yaml_non_space
(
c
)
&
&
!
is_flow
(
c
)
&
&
!
is_z
(
c
)
}
#
[
inline
]
pub
(
crate
)
fn
is_word_char
(
c
:
char
)
-
>
bool
{
is_alpha
(
c
)
&
&
c
!
=
'
_
'
}
#
[
inline
]
pub
(
crate
)
fn
is_uri_char
(
c
:
char
)
-
>
bool
{
is_word_char
(
c
)
|
|
"
#
;
/
?
:
&
=
+
_
.
!
~
*
\
'
(
)
[
]
%
"
.
contains
(
c
)
}
#
[
inline
]
pub
(
crate
)
fn
is_tag_char
(
c
:
char
)
-
>
bool
{
is_uri_char
(
c
)
&
&
!
is_flow
(
c
)
&
&
c
!
=
'
!
'
}
#
[
inline
]
pub
(
crate
)
fn
is_valid_literal_block_scalar
(
string
:
&
str
)
-
>
bool
{
string
.
chars
(
)
.
all
(
|
character
:
char
|
matches
!
(
character
'
\
t
'
|
'
\
n
'
|
'
\
x20
'
.
.
=
'
\
x7e
'
|
'
\
u
{
0085
}
'
|
'
\
u
{
00a0
}
'
.
.
=
'
\
u
{
d7fff
}
'
)
)
}
