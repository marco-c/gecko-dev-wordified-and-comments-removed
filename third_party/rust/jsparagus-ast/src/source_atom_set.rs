use
std
:
:
collections
:
:
HashMap
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
pub
struct
SourceAtomSetIndex
{
index
:
usize
}
impl
SourceAtomSetIndex
{
fn
new
(
index
:
usize
)
-
>
Self
{
Self
{
index
}
}
}
impl
From
<
SourceAtomSetIndex
>
for
usize
{
fn
from
(
index
:
SourceAtomSetIndex
)
-
>
usize
{
index
.
index
}
}
macro_rules
!
for_all_common_atoms
{
(
handler
:
ident
(
(
params
:
tt
)
*
)
?
)
=
>
{
/
/
string
representation
method
name
enum
variant
handler
!
(
(
(
params
)
*
)
?
(
"
arguments
"
arguments
Arguments
)
(
"
async
"
async_
Async
)
(
"
await
"
await_
Await
)
(
"
break
"
break_
Break
)
(
"
case
"
case
Case
)
(
"
catch
"
catch
Catch
)
(
"
class
"
class
Class
)
(
"
const
"
const_
Const
)
(
"
continue
"
continue_
Continue
)
(
"
debugger
"
debugger
Debugger
)
(
"
default
"
default
Default
)
(
"
delete
"
delete
Delete
)
(
"
do
"
do_
Do
)
(
"
else
"
else_
Else
)
(
"
enum
"
enum_
Enum
)
(
"
eval
"
eval
Eval
)
(
"
export
"
export
Export
)
(
"
extends
"
extends
Extends
)
(
"
false
"
false_
False
)
(
"
finally
"
finally
Finally
)
(
"
for
"
for_
For
)
(
"
function
"
function
Function
)
(
"
if
"
if_
If
)
(
"
implements
"
implements
Implements
)
(
"
import
"
import
Import
)
(
"
in
"
in_
In
)
(
"
instanceof
"
instanceof
Instanceof
)
(
"
interface
"
interface
Interface
)
(
"
let
"
let_
Let
)
(
"
new
"
new_
New
)
(
"
null
"
null
Null
)
(
"
package
"
package
Package
)
(
"
private
"
private
Private
)
(
"
protected
"
protected
Protected
)
(
"
public
"
public
Public
)
(
"
return
"
return_
Return
)
(
"
static
"
static_
Static
)
(
"
super
"
super_
Super
)
(
"
switch
"
switch
Switch
)
(
"
this
"
this
This
)
(
"
throw
"
throw
Throw
)
(
"
true
"
true_
True
)
(
"
try
"
try_
Try
)
(
"
typeof
"
typeof_
Typeof
)
(
"
var
"
var
Var
)
(
"
void
"
void
Void
)
(
"
while
"
while_
While
)
(
"
with
"
with
With
)
(
"
yield
"
yield_
Yield
)
(
"
use
strict
"
use_strict
UseStrict
)
(
"
__proto__
"
__proto__
Proto
)
)
;
}
}
macro_rules
!
define_enum
{
(
(
s0
:
tt
method0
:
ident
variant0
:
ident
)
(
(
s
:
tt
method
:
ident
variant
:
ident
)
)
*
)
=
>
{
enum
CommonAtoms
{
variant0
=
0
(
variant
)
*
}
}
;
}
for_all_common_atoms
!
(
define_enum
)
;
macro_rules
!
define_struct
{
(
(
(
s
:
tt
method
:
ident
variant
:
ident
)
)
*
)
=
>
{
#
[
derive
(
Debug
)
]
pub
struct
CommonSourceAtomSetIndices
{
}
impl
CommonSourceAtomSetIndices
{
(
pub
fn
method
(
)
-
>
SourceAtomSetIndex
{
SourceAtomSetIndex
:
:
new
(
CommonAtoms
:
:
variant
as
usize
)
}
)
*
}
}
;
}
for_all_common_atoms
!
(
define_struct
)
;
#
[
derive
(
Debug
)
]
pub
struct
SourceAtomSet
<
'
alloc
>
{
atoms
:
Vec
<
String
>
atom_indices
:
HashMap
<
&
'
alloc
str
SourceAtomSetIndex
>
}
impl
<
'
alloc
>
SourceAtomSet
<
'
alloc
>
{
pub
fn
new
(
)
-
>
Self
{
let
mut
result
=
Self
{
atoms
:
Vec
:
:
new
(
)
atom_indices
:
HashMap
:
:
new
(
)
}
;
result
.
insert_common_atoms
(
)
;
result
}
fn
insert_common_atoms
(
&
mut
self
)
{
macro_rules
!
insert_atom
{
(
self
:
ident
(
(
s
:
tt
method
:
ident
variant
:
ident
)
)
*
)
=
>
{
(
self
.
atoms
.
push
(
s
.
to_string
(
)
)
;
self
.
atom_indices
.
insert
(
s
CommonSourceAtomSetIndices
:
:
method
(
)
)
;
)
*
}
;
}
for_all_common_atoms
!
(
insert_atom
self
)
;
}
pub
fn
new_uninitialized
(
)
-
>
Self
{
Self
{
atoms
:
Vec
:
:
new
(
)
atom_indices
:
HashMap
:
:
new
(
)
}
}
pub
fn
insert
(
&
mut
self
s
:
&
'
alloc
str
)
-
>
SourceAtomSetIndex
{
match
self
.
atom_indices
.
get
(
s
)
{
Some
(
index
)
=
>
return
*
index
_
=
>
{
}
}
let
index
=
self
.
atoms
.
len
(
)
;
self
.
atoms
.
push
(
s
.
to_string
(
)
)
;
let
result
=
SourceAtomSetIndex
:
:
new
(
index
)
;
self
.
atom_indices
.
insert
(
s
result
)
;
result
}
pub
fn
get
(
&
self
index
:
SourceAtomSetIndex
)
-
>
String
{
self
.
atoms
[
usize
:
:
from
(
index
)
]
.
clone
(
)
}
}
impl
<
'
alloc
>
From
<
SourceAtomSet
<
'
alloc
>
>
for
Vec
<
String
>
{
fn
from
(
set
:
SourceAtomSet
<
'
alloc
>
)
-
>
Vec
<
String
>
{
set
.
atoms
}
}
