use
core
:
:
ffi
:
:
c_char
;
use
core
:
:
fmt
;
use
crate
:
:
vk
;
#
[
derive
(
Clone
Copy
PartialEq
Eq
PartialOrd
Ord
Debug
)
]
#
[
repr
(
transparent
)
]
pub
struct
Packed24_8
(
u32
)
;
impl
Packed24_8
{
pub
fn
new
(
low_24
:
u32
high_8
:
u8
)
-
>
Self
{
Self
(
(
low_24
&
0x00ff_ffff
)
|
(
u32
:
:
from
(
high_8
)
<
<
24
)
)
}
pub
fn
low_24
(
&
self
)
-
>
u32
{
self
.
0
&
0xffffff
}
pub
fn
high_8
(
&
self
)
-
>
u8
{
(
self
.
0
>
>
24
)
as
u8
}
}
impl
vk
:
:
ColorComponentFlags
{
pub
const
RGBA
:
Self
=
Self
(
Self
:
:
R
.
0
|
Self
:
:
G
.
0
|
Self
:
:
B
.
0
|
Self
:
:
A
.
0
)
;
}
impl
From
<
vk
:
:
Extent2D
>
for
vk
:
:
Extent3D
{
fn
from
(
value
:
vk
:
:
Extent2D
)
-
>
Self
{
Self
{
width
:
value
.
width
height
:
value
.
height
depth
:
1
}
}
}
impl
From
<
vk
:
:
Extent2D
>
for
vk
:
:
Rect2D
{
fn
from
(
extent
:
vk
:
:
Extent2D
)
-
>
Self
{
Self
{
offset
:
Default
:
:
default
(
)
extent
}
}
}
pub
unsafe
trait
TaggedStructure
{
const
STRUCTURE_TYPE
:
vk
:
:
StructureType
;
}
#
[
inline
]
pub
(
crate
)
fn
wrap_c_str_slice_until_nul
(
str
:
&
[
c_char
]
)
-
>
Result
<
&
core
:
:
ffi
:
:
CStr
core
:
:
ffi
:
:
FromBytesUntilNulError
>
{
let
bytes
=
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
str
.
as_ptr
(
)
.
cast
(
)
str
.
len
(
)
)
}
;
core
:
:
ffi
:
:
CStr
:
:
from_bytes_until_nul
(
bytes
)
}
#
[
derive
(
Debug
)
]
pub
struct
CStrTooLargeForStaticArray
{
pub
static_array_size
:
usize
pub
c_str_size
:
usize
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
std
:
:
error
:
:
Error
for
CStrTooLargeForStaticArray
{
}
impl
fmt
:
:
Display
for
CStrTooLargeForStaticArray
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
static
c_char
target
array
of
length
{
}
is
too
small
to
write
a
CStr
(
with
NUL
-
terminator
)
of
length
{
}
"
self
.
static_array_size
self
.
c_str_size
)
}
}
#
[
inline
]
pub
(
crate
)
fn
write_c_str_slice_with_nul
(
target
:
&
mut
[
c_char
]
str
:
&
core
:
:
ffi
:
:
CStr
)
-
>
Result
<
(
)
CStrTooLargeForStaticArray
>
{
let
bytes
=
str
.
to_bytes_with_nul
(
)
;
let
bytes
=
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
bytes
.
as_ptr
(
)
.
cast
(
)
bytes
.
len
(
)
)
}
;
let
static_array_size
=
target
.
len
(
)
;
target
.
get_mut
(
.
.
bytes
.
len
(
)
)
.
ok_or
(
CStrTooLargeForStaticArray
{
static_array_size
c_str_size
:
bytes
.
len
(
)
}
)
?
.
copy_from_slice
(
bytes
)
;
Ok
(
(
)
)
}
