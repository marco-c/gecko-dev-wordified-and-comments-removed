#
!
[
warn
(
clippy
:
:
alloc_instead_of_core
clippy
:
:
use_self
clippy
:
:
std_instead_of_alloc
clippy
:
:
std_instead_of_core
deprecated_in_future
rust_2018_idioms
trivial_casts
trivial_numeric_casts
unused_qualifications
)
]
#
!
[
allow
(
clippy
:
:
too_many_arguments
clippy
:
:
missing_safety_doc
clippy
:
:
upper_case_acronyms
)
]
#
!
[
cfg_attr
(
docsrs
feature
(
doc_cfg
)
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
extern
crate
alloc
;
pub
use
crate
:
:
device
:
:
Device
;
pub
use
crate
:
:
entry
:
:
Entry
;
#
[
cfg
(
feature
=
"
loaded
"
)
]
pub
use
crate
:
:
entry
:
:
LoadingError
;
pub
use
crate
:
:
extensions_generated
:
:
*
;
pub
use
crate
:
:
instance
:
:
Instance
;
pub
use
crate
:
:
tables
:
:
*
;
mod
device
;
mod
entry
;
mod
extensions_generated
;
mod
instance
;
pub
mod
prelude
;
mod
tables
;
pub
mod
util
;
#
[
macro_use
]
pub
mod
vk
;
mod
extensions
;
pub
trait
RawPtr
<
T
>
{
fn
as_raw_ptr
(
&
self
)
-
>
*
const
T
;
}
impl
<
'
r
T
>
RawPtr
<
T
>
for
Option
<
&
'
r
T
>
{
fn
as_raw_ptr
(
&
self
)
-
>
*
const
T
{
match
*
self
{
Some
(
inner
)
=
>
inner
_
=
>
:
:
core
:
:
ptr
:
:
null
(
)
}
}
}
#
[
macro_export
]
macro_rules
!
match_out_struct
{
(
match
p
:
ident
{
(
bind
:
ident
ty
:
path
=
>
body
:
block
(
)
?
)
+
(
_
=
>
any
:
block
(
)
?
)
?
}
)
=
>
{
match
core
:
:
ptr
:
:
addr_of
!
(
(
*
p
)
.
s_type
)
.
read
(
)
{
(
<
ty
as
crate
:
:
vk
:
:
TaggedStructure
>
:
:
STRUCTURE_TYPE
=
>
{
let
bind
=
p
.
cast
:
:
<
ty
>
(
)
.
as_mut
(
)
.
unwrap
(
)
;
body
}
)
+
_
=
>
{
(
any
)
?
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
match_in_struct
{
(
match
p
:
ident
{
(
bind
:
ident
ty
:
path
=
>
body
:
block
(
)
?
)
+
(
_
=
>
any
:
block
(
)
?
)
?
}
)
=
>
{
match
core
:
:
ptr
:
:
addr_of
!
(
(
*
p
)
.
s_type
)
.
read
(
)
{
(
<
ty
as
crate
:
:
vk
:
:
TaggedStructure
>
:
:
STRUCTURE_TYPE
=
>
{
let
bind
=
p
.
cast
:
:
<
ty
>
(
)
.
as_ref
(
)
.
unwrap
(
)
;
body
}
)
+
_
=
>
{
(
any
)
?
}
}
}
;
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
vk
;
use
alloc
:
:
vec
:
:
Vec
;
#
[
test
]
fn
test_ptr_chains
(
)
{
let
mut
variable_pointers
=
vk
:
:
PhysicalDeviceVariablePointerFeatures
:
:
default
(
)
;
let
mut
corner
=
vk
:
:
PhysicalDeviceCornerSampledImageFeaturesNV
:
:
default
(
)
;
let
chain
=
alloc
:
:
vec
!
[
<
*
mut
_
>
:
:
cast
(
&
mut
variable_pointers
)
<
*
mut
_
>
:
:
cast
(
&
mut
corner
)
]
;
let
mut
device_create_info
=
vk
:
:
DeviceCreateInfo
:
:
default
(
)
.
push_next
(
&
mut
corner
)
.
push_next
(
&
mut
variable_pointers
)
;
let
chain2
:
Vec
<
*
mut
vk
:
:
BaseOutStructure
<
'
_
>
>
=
unsafe
{
vk
:
:
ptr_chain_iter
(
&
mut
device_create_info
)
.
skip
(
1
)
.
collect
(
)
}
;
assert_eq
!
(
chain
chain2
)
;
}
}
