use
std
:
:
convert
:
:
TryInto
;
use
crate
:
:
vk
;
pub
type
VkResult
<
T
>
=
Result
<
T
vk
:
:
Result
>
;
impl
From
<
vk
:
:
Result
>
for
VkResult
<
(
)
>
{
fn
from
(
err_code
:
vk
:
:
Result
)
-
>
Self
{
err_code
.
result
(
)
}
}
impl
vk
:
:
Result
{
pub
fn
result
(
self
)
-
>
VkResult
<
(
)
>
{
self
.
result_with_success
(
(
)
)
}
pub
fn
result_with_success
<
T
>
(
self
v
:
T
)
-
>
VkResult
<
T
>
{
match
self
{
vk
:
:
Result
:
:
SUCCESS
=
>
Ok
(
v
)
_
=
>
Err
(
self
)
}
}
}
pub
(
crate
)
unsafe
fn
read_into_uninitialized_vector
<
N
:
Copy
+
Default
+
TryInto
<
usize
>
T
>
(
f
:
impl
Fn
(
&
mut
N
*
mut
T
)
-
>
vk
:
:
Result
)
-
>
VkResult
<
Vec
<
T
>
>
where
<
N
as
TryInto
<
usize
>
>
:
:
Error
:
std
:
:
fmt
:
:
Debug
{
loop
{
let
mut
count
=
N
:
:
default
(
)
;
f
(
&
mut
count
std
:
:
ptr
:
:
null_mut
(
)
)
.
result
(
)
?
;
let
mut
data
=
Vec
:
:
with_capacity
(
count
.
try_into
(
)
.
expect
(
"
N
failed
to
convert
to
usize
"
)
)
;
let
err_code
=
f
(
&
mut
count
data
.
as_mut_ptr
(
)
)
;
if
err_code
!
=
vk
:
:
Result
:
:
INCOMPLETE
{
data
.
set_len
(
count
.
try_into
(
)
.
expect
(
"
N
failed
to
convert
to
usize
"
)
)
;
break
err_code
.
result_with_success
(
data
)
;
}
}
}
pub
(
crate
)
unsafe
fn
read_into_defaulted_vector
<
N
:
Copy
+
Default
+
TryInto
<
usize
>
T
:
Default
+
Clone
>
(
f
:
impl
Fn
(
&
mut
N
*
mut
T
)
-
>
vk
:
:
Result
)
-
>
VkResult
<
Vec
<
T
>
>
where
<
N
as
TryInto
<
usize
>
>
:
:
Error
:
std
:
:
fmt
:
:
Debug
{
loop
{
let
mut
count
=
N
:
:
default
(
)
;
f
(
&
mut
count
std
:
:
ptr
:
:
null_mut
(
)
)
.
result
(
)
?
;
let
mut
data
=
vec
!
[
Default
:
:
default
(
)
;
count
.
try_into
(
)
.
expect
(
"
N
failed
to
convert
to
usize
"
)
]
;
let
err_code
=
f
(
&
mut
count
data
.
as_mut_ptr
(
)
)
;
if
err_code
!
=
vk
:
:
Result
:
:
INCOMPLETE
{
data
.
set_len
(
count
.
try_into
(
)
.
expect
(
"
N
failed
to
convert
to
usize
"
)
)
;
break
err_code
.
result_with_success
(
data
)
;
}
}
}
