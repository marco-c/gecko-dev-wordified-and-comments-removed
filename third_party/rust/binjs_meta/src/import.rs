use
spec
:
:
{
self
Laziness
SpecBuilder
TypeSpec
TypeSum
}
;
use
weedle
:
:
common
:
:
Identifier
;
use
weedle
:
:
types
:
:
*
;
use
weedle
:
:
*
;
fn
nullable
<
T
:
std
:
:
fmt
:
:
Debug
>
(
src
:
&
MayBeNull
<
T
>
dst
:
TypeSpec
)
-
>
spec
:
:
Type
{
if
src
.
q_mark
.
is_some
(
)
{
dst
.
optional
(
)
.
unwrap_or_else
(
|
|
panic
!
(
"
This
type
could
not
be
made
optional
{
:
?
}
"
src
.
type_
)
)
}
else
{
dst
.
required
(
)
}
}
pub
struct
Importer
{
builder
:
SpecBuilder
path
:
Vec
<
String
>
}
impl
Importer
{
pub
fn
import
<
'
a
>
(
sources
:
impl
IntoIterator
<
Item
=
&
'
a
str
>
)
-
>
Result
<
SpecBuilder
weedle
:
:
Err
<
CompleteStr
<
'
a
>
>
>
{
let
mut
importer
=
Importer
{
path
:
Vec
:
:
with_capacity
(
256
)
builder
:
SpecBuilder
:
:
new
(
)
}
;
for
source
in
sources
{
let
ast
=
weedle
:
:
parse
(
source
)
?
;
importer
.
import_all_definitions
(
&
ast
)
;
}
Ok
(
importer
.
builder
)
}
fn
import_all_definitions
(
&
mut
self
ast
:
&
Definitions
)
{
for
definition
in
ast
{
self
.
import_definition
(
&
definition
)
}
}
fn
import_definition
(
&
mut
self
def
:
&
Definition
)
{
match
*
def
{
Definition
:
:
Enum
(
ref
enum_
)
=
>
self
.
import_enum
(
enum_
)
Definition
:
:
Typedef
(
ref
typedef
)
=
>
self
.
import_typedef
(
typedef
)
Definition
:
:
Interface
(
ref
interface
)
=
>
self
.
import_interface
(
interface
)
_
=
>
panic
!
(
"
Not
implemented
:
importing
{
:
?
}
"
def
)
}
}
fn
import_enum
(
&
mut
self
enum_
:
&
EnumDefinition
)
{
let
name
=
self
.
builder
.
node_name
(
enum_
.
identifier
.
0
)
;
let
mut
node
=
self
.
builder
.
add_string_enum
(
&
name
)
.
expect
(
"
Name
already
present
"
)
;
for
variant
in
&
enum_
.
values
.
body
.
list
{
node
.
with_string
(
&
variant
.
0
)
;
}
}
fn
import_typedef
(
&
mut
self
typedef
:
&
TypedefDefinition
)
{
let
name
=
self
.
builder
.
node_name
(
typedef
.
identifier
.
0
)
;
let
type_
=
match
typedef
.
identifier
.
0
{
"
Identifier
"
=
>
TypeSpec
:
:
IdentifierName
.
required
(
)
"
IdentifierName
"
=
>
TypeSpec
:
:
IdentifierName
.
required
(
)
"
PropertyKey
"
=
>
TypeSpec
:
:
PropertyKey
.
required
(
)
_
=
>
self
.
convert_type
(
&
typedef
.
type_
.
type_
)
}
;
debug
!
(
target
:
"
meta
:
:
import
"
"
Importing
typedef
{
type_
:
?
}
{
name
:
?
}
"
type_
=
type_
name
=
name
)
;
let
mut
node
=
self
.
builder
.
add_typedef
(
&
name
)
.
unwrap_or_else
(
|
|
{
panic
!
(
"
Error
:
Name
{
}
is
defined
more
than
once
in
the
spec
.
"
name
)
}
)
;
assert
!
(
!
type_
.
is_optional
(
)
)
;
node
.
with_spec
(
type_
.
spec
)
;
}
fn
import_interface
(
&
mut
self
interface
:
&
InterfaceDefinition
)
{
match
interface
.
identifier
.
0
{
"
Node
"
=
>
{
return
;
}
"
IdentifierName
"
=
>
unimplemented
!
(
)
_
=
>
{
}
}
if
let
Some
(
ref
parent
)
=
interface
.
inheritance
{
assert_eq
!
(
parent
.
identifier
.
0
"
Node
"
)
;
}
self
.
path
.
push
(
interface
.
identifier
.
0
.
to_owned
(
)
)
;
let
mut
fields
=
Vec
:
:
new
(
)
;
for
member
in
&
interface
.
members
.
body
{
if
let
interface
:
:
InterfaceMember
:
:
Attribute
(
interface
:
:
AttributeInterfaceMember
{
modifier
:
None
attributes
identifier
type_
.
.
}
)
=
member
{
let
name
=
self
.
builder
.
field_name
(
identifier
.
0
)
;
let
type_
=
self
.
convert_type
(
&
type_
.
type_
)
;
let
is_lazy
=
attributes
.
iter
(
)
.
flat_map
(
|
attribute
|
&
attribute
.
body
.
list
)
.
find
(
|
attribute
|
match
attribute
{
attribute
:
:
ExtendedAttribute
:
:
NoArgs
(
attribute
:
:
ExtendedAttributeNoArgs
(
Identifier
(
"
Lazy
"
)
)
)
=
>
true
_
=
>
false
}
)
.
is_some
(
)
;
fields
.
push
(
(
name
type_
if
is_lazy
{
Laziness
:
:
Lazy
}
else
{
Laziness
:
:
Eager
}
)
)
;
}
else
{
panic
!
(
"
Expected
an
attribute
got
{
:
?
}
"
member
)
;
}
}
let
name
=
self
.
builder
.
node_name
(
interface
.
identifier
.
0
)
;
let
mut
extends_type_sum
=
None
;
let
mut
scoped_dictionary
=
None
;
{
let
mut
node
=
self
.
builder
.
add_interface
(
&
name
)
.
expect
(
"
Name
already
present
"
)
;
for
(
field_name
field_type
laziness
)
in
fields
.
drain
(
.
.
)
{
node
.
with_field_laziness
(
&
field_name
field_type
laziness
)
;
}
for
attribute
in
interface
.
attributes
.
iter
(
)
.
flat_map
(
|
attribute
|
&
attribute
.
body
.
list
)
{
use
weedle
:
:
attribute
:
:
ExtendedAttribute
:
:
*
;
use
weedle
:
:
attribute
:
:
*
;
match
*
attribute
{
NoArgs
(
ExtendedAttributeNoArgs
(
Identifier
(
"
Skippable
"
)
)
)
=
>
{
panic
!
(
"
Encountered
deprecated
attribute
[
Skippable
]
"
)
;
}
NoArgs
(
ExtendedAttributeNoArgs
(
Identifier
(
"
Scope
"
)
)
)
=
>
{
node
.
with_scope
(
true
)
;
}
Ident
(
ExtendedAttributeIdent
{
lhs_identifier
:
Identifier
(
"
ExtendsTypeSum
"
)
assign
:
_
rhs
:
IdentifierOrString
:
:
Identifier
(
ref
rhs
)
}
)
=
>
{
assert
!
(
extends_type_sum
.
is_none
(
)
)
;
extends_type_sum
=
Some
(
rhs
.
0
)
;
}
Ident
(
ExtendedAttributeIdent
{
lhs_identifier
:
Identifier
(
"
ScopedDictionary
"
)
assign
:
_
rhs
:
IdentifierOrString
:
:
Identifier
(
ref
rhs
)
}
)
=
>
{
assert
!
(
scoped_dictionary
.
is_none
(
)
)
;
scoped_dictionary
=
Some
(
rhs
.
0
)
;
}
_
=
>
panic
!
(
"
Unknown
attribute
{
:
?
}
"
attribute
)
}
}
if
let
Some
(
ref
field_name
)
=
scoped_dictionary
{
node
.
with_scoped_dictionary_str
(
field_name
)
;
}
}
if
let
Some
(
ref
extended
)
=
extends_type_sum
{
let
node_name
=
self
.
builder
.
get_node_name
(
extended
)
.
unwrap_or_else
(
|
|
panic
!
(
"
Could
not
find
node
name
{
}
"
extended
)
)
;
let
mut
typedef
=
self
.
builder
.
get_typedef_mut
(
&
node_name
)
.
unwrap_or_else
(
|
|
panic
!
(
"
Could
not
find
typedef
{
}
"
extended
)
)
;
let
mut
typespec
=
typedef
.
spec_mut
(
)
;
let
typesum
=
if
let
TypeSpec
:
:
TypeSum
(
ref
mut
typesum
)
=
*
typespec
{
typesum
}
else
{
panic
!
(
"
Attempting
to
extend
a
node
that
is
not
a
type
sum
{
}
"
extended
)
;
}
;
typesum
.
with_type_case
(
TypeSpec
:
:
NamedType
(
name
)
)
;
}
self
.
path
.
pop
(
)
;
}
fn
convert_single_type
(
&
mut
self
t
:
&
NonAnyType
)
-
>
spec
:
:
Type
{
match
t
{
NonAnyType
:
:
Boolean
(
ref
b
)
=
>
nullable
(
b
TypeSpec
:
:
Boolean
)
NonAnyType
:
:
Identifier
(
ref
id
)
=
>
nullable
(
id
{
let
name
=
self
.
builder
.
node_name
(
id
.
type_
.
0
)
;
match
name
.
to_str
(
)
{
"
IdentifierName
"
if
self
.
is_at_interface
(
"
StaticMemberAssignmentTarget
"
)
=
>
{
TypeSpec
:
:
PropertyKey
}
"
IdentifierName
"
if
self
.
is_at_interface
(
"
StaticMemberExpression
"
)
=
>
{
TypeSpec
:
:
PropertyKey
}
"
IdentifierName
"
if
self
.
is_at_interface
(
"
ImportSpecifier
"
)
=
>
{
TypeSpec
:
:
PropertyKey
}
"
IdentifierName
"
if
self
.
is_at_interface
(
"
ExportSpecifier
"
)
=
>
{
TypeSpec
:
:
PropertyKey
}
"
IdentifierName
"
if
self
.
is_at_interface
(
"
ExportLocalSpecifier
"
)
=
>
{
TypeSpec
:
:
PropertyKey
}
"
IdentifierName
"
=
>
TypeSpec
:
:
IdentifierName
"
Identifier
"
=
>
TypeSpec
:
:
IdentifierName
_
=
>
TypeSpec
:
:
NamedType
(
name
.
clone
(
)
)
}
}
)
NonAnyType
:
:
DOMString
(
ref
s
)
=
>
nullable
(
s
if
self
.
is_at_interface
(
"
LiteralPropertyName
"
)
{
TypeSpec
:
:
PropertyKey
}
else
{
TypeSpec
:
:
String
}
)
NonAnyType
:
:
FrozenArrayType
(
ref
t
)
=
>
nullable
(
t
TypeSpec
:
:
Array
{
contents
:
Box
:
:
new
(
self
.
convert_type
(
&
t
.
type_
.
generics
.
body
)
)
supports_empty
:
true
}
)
NonAnyType
:
:
FloatingPoint
(
ref
t
)
=
>
nullable
(
t
TypeSpec
:
:
Number
)
NonAnyType
:
:
Integer
(
ref
t
)
=
>
nullable
(
t
TypeSpec
:
:
UnsignedLong
)
_
=
>
{
panic
!
(
"
I
don
'
t
know
how
to
import
{
:
?
}
yet
"
t
)
;
}
}
}
fn
convert_union_type
(
&
mut
self
types
:
&
MayBeNull
<
UnionType
>
)
-
>
spec
:
:
Type
{
let
converted_types
:
Vec
<
_
>
=
types
.
type_
.
body
.
list
.
iter
(
)
.
map
(
|
t
|
match
t
{
UnionMemberType
:
:
Single
(
t
)
=
>
self
.
convert_single_type
(
t
)
UnionMemberType
:
:
Union
(
t
)
=
>
self
.
convert_union_type
(
t
)
}
)
.
map
(
|
t
|
t
.
spec
)
.
collect
(
)
;
nullable
(
types
TypeSpec
:
:
TypeSum
(
TypeSum
:
:
new
(
converted_types
)
)
)
}
fn
convert_type
(
&
mut
self
t
:
&
Type
)
-
>
spec
:
:
Type
{
match
t
{
Type
:
:
Single
(
SingleType
:
:
NonAny
(
t
)
)
=
>
self
.
convert_single_type
(
t
)
Type
:
:
Union
(
types
)
=
>
self
.
convert_union_type
(
types
)
_
=
>
panic
!
(
"
I
don
'
t
know
how
to
import
{
:
?
}
yet
"
t
)
}
}
fn
is_at_interface
(
&
self
name
:
&
str
)
-
>
bool
{
if
self
.
path
.
len
(
)
=
=
0
{
return
false
;
}
self
.
path
[
0
]
.
as_str
(
)
=
=
name
}
}
