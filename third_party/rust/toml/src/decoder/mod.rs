use
std
:
:
error
;
use
std
:
:
fmt
;
use
std
:
:
collections
:
:
{
btree_map
BTreeMap
}
;
use
std
:
:
iter
:
:
Peekable
;
use
Value
;
use
self
:
:
DecodeErrorKind
:
:
*
;
#
[
cfg
(
feature
=
"
rustc
-
serialize
"
)
]
mod
rustc_serialize
;
#
[
cfg
(
feature
=
"
serde
"
)
]
mod
serde
;
pub
struct
Decoder
{
pub
toml
:
Option
<
Value
>
cur_field
:
Option
<
String
>
#
[
cfg_attr
(
feature
=
"
serde
"
allow
(
dead_code
)
)
]
cur_map
:
Peekable
<
btree_map
:
:
IntoIter
<
String
Value
>
>
#
[
cfg_attr
(
feature
=
"
serde
"
allow
(
dead_code
)
)
]
leftover_map
:
:
:
Table
}
#
[
derive
(
PartialEq
Debug
)
]
pub
struct
DecodeError
{
pub
field
:
Option
<
String
>
pub
kind
:
DecodeErrorKind
}
#
[
derive
(
PartialEq
Debug
)
]
pub
enum
DecodeErrorKind
{
ApplicationError
(
String
)
ExpectedField
(
Option
<
&
'
static
str
>
)
UnknownField
ExpectedType
(
&
'
static
str
&
'
static
str
)
ExpectedMapKey
(
usize
)
ExpectedMapElement
(
usize
)
NoEnumVariants
NilTooLong
SyntaxError
CustomError
(
String
)
EndOfStream
InvalidType
(
&
'
static
str
)
}
#
[
cfg
(
feature
=
"
rustc
-
serialize
"
)
]
pub
fn
decode
<
T
:
:
:
rustc_serialize
:
:
Decodable
>
(
toml
:
Value
)
-
>
Option
<
T
>
{
:
:
rustc_serialize
:
:
Decodable
:
:
decode
(
&
mut
Decoder
:
:
new
(
toml
)
)
.
ok
(
)
}
#
[
cfg
(
all
(
not
(
feature
=
"
rustc
-
serialize
"
)
feature
=
"
serde
"
)
)
]
pub
fn
decode
<
T
:
:
:
serde
:
:
Deserialize
>
(
toml
:
Value
)
-
>
Option
<
T
>
{
:
:
serde
:
:
Deserialize
:
:
deserialize
(
&
mut
Decoder
:
:
new
(
toml
)
)
.
ok
(
)
}
#
[
cfg
(
feature
=
"
rustc
-
serialize
"
)
]
pub
fn
decode_str
<
T
:
:
:
rustc_serialize
:
:
Decodable
>
(
s
:
&
str
)
-
>
Option
<
T
>
{
:
:
Parser
:
:
new
(
s
)
.
parse
(
)
.
and_then
(
|
t
|
decode
(
Value
:
:
Table
(
t
)
)
)
}
#
[
cfg
(
all
(
not
(
feature
=
"
rustc
-
serialize
"
)
feature
=
"
serde
"
)
)
]
pub
fn
decode_str
<
T
:
:
:
serde
:
:
Deserialize
>
(
s
:
&
str
)
-
>
Option
<
T
>
{
:
:
Parser
:
:
new
(
s
)
.
parse
(
)
.
and_then
(
|
t
|
decode
(
Value
:
:
Table
(
t
)
)
)
}
impl
Decoder
{
pub
fn
new
(
toml
:
Value
)
-
>
Decoder
{
Decoder
:
:
new_empty
(
Some
(
toml
)
None
)
}
fn
sub_decoder
(
&
self
toml
:
Option
<
Value
>
field
:
&
str
)
-
>
Decoder
{
let
cur_field
=
if
field
.
is_empty
(
)
{
self
.
cur_field
.
clone
(
)
}
else
{
match
self
.
cur_field
{
None
=
>
Some
(
field
.
to_string
(
)
)
Some
(
ref
s
)
=
>
Some
(
format
!
(
"
{
}
.
{
}
"
s
field
)
)
}
}
;
Decoder
:
:
new_empty
(
toml
cur_field
)
}
fn
new_empty
(
toml
:
Option
<
Value
>
cur_field
:
Option
<
String
>
)
-
>
Decoder
{
Decoder
{
toml
:
toml
cur_field
:
cur_field
leftover_map
:
BTreeMap
:
:
new
(
)
cur_map
:
BTreeMap
:
:
new
(
)
.
into_iter
(
)
.
peekable
(
)
}
}
fn
err
(
&
self
kind
:
DecodeErrorKind
)
-
>
DecodeError
{
DecodeError
{
field
:
self
.
cur_field
.
clone
(
)
kind
:
kind
}
}
fn
mismatch
(
&
self
expected
:
&
'
static
str
found
:
&
Option
<
Value
>
)
-
>
DecodeError
{
match
*
found
{
Some
(
ref
val
)
=
>
self
.
err
(
ExpectedType
(
expected
val
.
type_str
(
)
)
)
None
=
>
self
.
err
(
ExpectedField
(
Some
(
expected
)
)
)
}
}
}
impl
fmt
:
:
Display
for
DecodeError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
try
!
(
match
self
.
kind
{
ApplicationError
(
ref
err
)
=
>
{
write
!
(
f
"
{
}
"
err
)
}
ExpectedField
(
expected_type
)
=
>
{
match
expected_type
{
Some
(
"
table
"
)
=
>
write
!
(
f
"
expected
a
section
"
)
Some
(
e
)
=
>
write
!
(
f
"
expected
a
value
of
type
{
}
"
e
)
None
=
>
write
!
(
f
"
expected
a
value
"
)
}
}
UnknownField
=
>
write
!
(
f
"
unknown
field
"
)
ExpectedType
(
expected
found
)
=
>
{
fn
humanize
(
s
:
&
str
)
-
>
String
{
if
s
=
=
"
section
"
{
"
a
section
"
.
to_string
(
)
}
else
{
format
!
(
"
a
value
of
type
{
}
"
s
)
}
}
write
!
(
f
"
expected
{
}
but
found
{
}
"
humanize
(
expected
)
humanize
(
found
)
)
}
ExpectedMapKey
(
idx
)
=
>
{
write
!
(
f
"
expected
at
least
{
}
keys
"
idx
+
1
)
}
ExpectedMapElement
(
idx
)
=
>
{
write
!
(
f
"
expected
at
least
{
}
elements
"
idx
+
1
)
}
NoEnumVariants
=
>
{
write
!
(
f
"
expected
an
enum
variant
to
decode
to
"
)
}
NilTooLong
=
>
{
write
!
(
f
"
expected
0
-
length
string
"
)
}
SyntaxError
=
>
{
write
!
(
f
"
syntax
error
"
)
}
EndOfStream
=
>
{
write
!
(
f
"
end
of
stream
"
)
}
InvalidType
(
s
)
=
>
{
write
!
(
f
"
invalid
type
:
{
}
"
s
)
}
CustomError
(
ref
s
)
=
>
{
write
!
(
f
"
custom
error
:
{
}
"
s
)
}
}
)
;
match
self
.
field
{
Some
(
ref
s
)
=
>
{
write
!
(
f
"
for
the
key
{
}
"
s
)
}
None
=
>
Ok
(
(
)
)
}
}
}
impl
error
:
:
Error
for
DecodeError
{
fn
description
(
&
self
)
-
>
&
str
{
match
self
.
kind
{
ApplicationError
(
ref
s
)
=
>
&
*
*
s
ExpectedField
(
.
.
)
=
>
"
expected
a
field
"
UnknownField
=
>
"
found
an
unknown
field
"
ExpectedType
(
.
.
)
=
>
"
expected
a
type
"
ExpectedMapKey
(
.
.
)
=
>
"
expected
a
map
key
"
ExpectedMapElement
(
.
.
)
=
>
"
expected
a
map
element
"
NoEnumVariants
=
>
"
no
enum
variants
to
decode
to
"
NilTooLong
=
>
"
nonzero
length
string
representing
nil
"
SyntaxError
=
>
"
syntax
error
"
EndOfStream
=
>
"
end
of
stream
"
InvalidType
(
.
.
)
=
>
"
invalid
type
"
CustomError
(
.
.
)
=
>
"
custom
error
"
}
}
}
