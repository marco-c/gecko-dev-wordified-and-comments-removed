#
[
cfg
(
feature
=
"
parse
"
)
]
#
[
cfg
(
feature
=
"
serde
"
)
]
mod
deserializer
;
mod
error
;
#
[
cfg
(
feature
=
"
parse
"
)
]
mod
parser
;
#
[
cfg
(
feature
=
"
parse
"
)
]
#
[
cfg
(
feature
=
"
serde
"
)
]
pub
use
deserializer
:
:
Deserializer
;
#
[
cfg
(
feature
=
"
parse
"
)
]
#
[
cfg
(
feature
=
"
serde
"
)
]
pub
use
deserializer
:
:
ValueDeserializer
;
#
[
cfg
(
feature
=
"
parse
"
)
]
pub
use
parser
:
:
DeArray
;
#
[
cfg
(
feature
=
"
parse
"
)
]
pub
use
parser
:
:
DeFloat
;
#
[
cfg
(
feature
=
"
parse
"
)
]
pub
use
parser
:
:
DeInteger
;
#
[
cfg
(
feature
=
"
parse
"
)
]
pub
use
parser
:
:
DeString
;
#
[
cfg
(
feature
=
"
parse
"
)
]
pub
use
parser
:
:
DeTable
;
#
[
cfg
(
feature
=
"
parse
"
)
]
pub
use
parser
:
:
DeValue
;
pub
use
error
:
:
Error
;
use
crate
:
:
alloc_prelude
:
:
*
;
#
[
cfg
(
feature
=
"
parse
"
)
]
#
[
cfg
(
feature
=
"
serde
"
)
]
pub
fn
from_str
<
'
de
T
>
(
s
:
&
'
de
str
)
-
>
Result
<
T
Error
>
where
T
:
serde_core
:
:
de
:
:
Deserialize
<
'
de
>
{
T
:
:
deserialize
(
Deserializer
:
:
parse
(
s
)
?
)
}
#
[
cfg
(
feature
=
"
parse
"
)
]
#
[
cfg
(
feature
=
"
serde
"
)
]
pub
fn
from_slice
<
'
de
T
>
(
s
:
&
'
de
[
u8
]
)
-
>
Result
<
T
Error
>
where
T
:
serde_core
:
:
de
:
:
Deserialize
<
'
de
>
{
let
s
=
core
:
:
str
:
:
from_utf8
(
s
)
.
map_err
(
|
e
|
Error
:
:
custom
(
e
.
to_string
(
)
None
)
)
?
;
from_str
(
s
)
}
