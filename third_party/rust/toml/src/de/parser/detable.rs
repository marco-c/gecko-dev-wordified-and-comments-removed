use
alloc
:
:
borrow
:
:
Cow
;
use
serde_spanned
:
:
Spanned
;
use
crate
:
:
alloc_prelude
:
:
*
;
use
crate
:
:
de
:
:
DeString
;
use
crate
:
:
de
:
:
DeValue
;
use
crate
:
:
map
:
:
Map
;
pub
type
DeTable
<
'
i
>
=
Map
<
Spanned
<
DeString
<
'
i
>
>
Spanned
<
DeValue
<
'
i
>
>
>
;
impl
<
'
i
>
DeTable
<
'
i
>
{
pub
fn
parse
(
input
:
&
'
i
str
)
-
>
Result
<
Spanned
<
Self
>
crate
:
:
de
:
:
Error
>
{
let
source
=
toml_parser
:
:
Source
:
:
new
(
input
)
;
let
mut
errors
=
crate
:
:
de
:
:
error
:
:
TomlSink
:
:
<
Option
<
_
>
>
:
:
new
(
source
)
;
let
value
=
crate
:
:
de
:
:
parser
:
:
parse_document
(
source
&
mut
errors
)
;
if
let
Some
(
err
)
=
errors
.
into_inner
(
)
{
Err
(
err
)
}
else
{
Ok
(
value
)
}
}
pub
fn
parse_recoverable
(
input
:
&
'
i
str
)
-
>
(
Spanned
<
Self
>
Vec
<
crate
:
:
de
:
:
Error
>
)
{
let
source
=
toml_parser
:
:
Source
:
:
new
(
input
)
;
let
mut
errors
=
crate
:
:
de
:
:
error
:
:
TomlSink
:
:
<
Vec
<
_
>
>
:
:
new
(
source
)
;
let
value
=
crate
:
:
de
:
:
parser
:
:
parse_document
(
source
&
mut
errors
)
;
(
value
errors
.
into_inner
(
)
)
}
pub
fn
make_owned
(
&
mut
self
)
{
self
.
mut_entries
(
|
k
v
|
{
let
owned
=
core
:
:
mem
:
:
take
(
k
.
get_mut
(
)
)
;
*
k
.
get_mut
(
)
=
Cow
:
:
Owned
(
owned
.
into_owned
(
)
)
;
v
.
get_mut
(
)
.
make_owned
(
)
;
}
)
;
}
}
