use
{
crate
:
:
types
:
:
{
MemoryHeap
MemoryType
}
alloc
:
:
borrow
:
:
Cow
core
:
:
ptr
:
:
NonNull
}
;
#
[
derive
(
Debug
)
]
pub
enum
OutOfMemory
{
OutOfDeviceMemory
OutOfHostMemory
}
#
[
derive
(
Debug
)
]
pub
enum
DeviceMapError
{
OutOfDeviceMemory
OutOfHostMemory
MapFailed
}
#
[
derive
(
Debug
)
]
pub
struct
MappedMemoryRange
<
'
a
M
>
{
pub
memory
:
&
'
a
M
pub
offset
:
u64
pub
size
:
u64
}
#
[
derive
(
Debug
)
]
pub
struct
DeviceProperties
<
'
a
>
{
pub
memory_types
:
Cow
<
'
a
[
MemoryType
]
>
pub
memory_heaps
:
Cow
<
'
a
[
MemoryHeap
]
>
pub
max_memory_allocation_count
:
u32
pub
max_memory_allocation_size
:
u64
pub
non_coherent_atom_size
:
u64
pub
buffer_device_address
:
bool
}
bitflags
:
:
bitflags
!
{
/
/
/
Allocation
flags
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
pub
struct
AllocationFlags
:
u8
{
/
/
/
Specifies
that
the
memory
can
be
used
for
buffers
created
/
/
/
with
flag
that
allows
fetching
device
address
.
const
DEVICE_ADDRESS
=
0x1
;
}
}
pub
trait
MemoryDevice
<
M
>
{
unsafe
fn
allocate_memory
(
&
self
size
:
u64
memory_type
:
u32
flags
:
AllocationFlags
)
-
>
Result
<
M
OutOfMemory
>
;
unsafe
fn
deallocate_memory
(
&
self
memory
:
M
)
;
unsafe
fn
map_memory
(
&
self
memory
:
&
mut
M
offset
:
u64
size
:
u64
)
-
>
Result
<
NonNull
<
u8
>
DeviceMapError
>
;
unsafe
fn
unmap_memory
(
&
self
memory
:
&
mut
M
)
;
unsafe
fn
invalidate_memory_ranges
(
&
self
ranges
:
&
[
MappedMemoryRange
<
'
_
M
>
]
)
-
>
Result
<
(
)
OutOfMemory
>
;
unsafe
fn
flush_memory_ranges
(
&
self
ranges
:
&
[
MappedMemoryRange
<
'
_
M
>
]
)
-
>
Result
<
(
)
OutOfMemory
>
;
}
