use
std
:
:
mem
;
pub
trait
Leak
<
T
:
?
Sized
>
{
fn
leak
<
'
a
>
(
self
)
-
>
&
'
a
T
where
T
:
'
a
;
}
impl
<
T
:
?
Sized
>
Leak
<
T
>
for
Box
<
T
>
{
fn
leak
<
'
a
>
(
self
)
-
>
&
'
a
T
where
T
:
'
a
{
let
r
=
Self
:
:
into_raw
(
self
)
;
unsafe
{
&
mut
*
r
}
}
}
impl
Leak
<
str
>
for
String
{
fn
leak
<
'
a
>
(
mut
self
)
-
>
&
'
a
str
where
Self
:
'
a
{
let
r
:
*
mut
str
=
&
mut
self
[
.
.
]
;
mem
:
:
forget
(
self
)
;
unsafe
{
&
mut
*
r
}
}
}
impl
<
T
>
Leak
<
[
T
]
>
for
Vec
<
T
>
{
fn
leak
<
'
a
>
(
mut
self
)
-
>
&
'
a
[
T
]
where
[
T
]
:
'
a
{
let
r
:
*
mut
[
T
]
=
&
mut
self
[
.
.
]
;
mem
:
:
forget
(
self
)
;
unsafe
{
&
mut
*
r
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
#
[
test
]
fn
leak_str
(
)
{
use
super
:
:
Leak
;
use
std
:
:
borrow
:
:
ToOwned
;
let
v
=
"
hi
"
;
let
leaked
:
&
str
=
{
let
o
=
v
.
to_owned
(
)
;
o
.
leak
(
)
}
;
assert_eq
!
(
leaked
v
)
;
let
leaked
:
&
'
static
str
=
{
let
o
=
v
.
to_owned
(
)
;
o
.
leak
(
)
}
;
assert_eq
!
(
leaked
v
)
;
}
#
[
test
]
fn
leak_empty_str
(
)
{
use
super
:
:
Leak
;
use
std
:
:
borrow
:
:
ToOwned
;
let
v
=
"
"
;
let
leaked
:
&
'
static
str
=
{
let
o
=
v
.
to_owned
(
)
;
o
.
leak
(
)
}
;
assert_eq
!
(
leaked
v
)
;
}
#
[
test
]
fn
leak_vec
(
)
{
use
super
:
:
Leak
;
let
v
=
vec
!
[
3
5
]
;
let
leaked
:
&
'
static
[
u8
]
=
{
let
o
=
v
.
clone
(
)
;
o
.
leak
(
)
}
;
assert_eq
!
(
leaked
&
*
v
)
;
}
#
[
test
]
fn
leak_empty_vec
(
)
{
use
super
:
:
Leak
;
let
v
=
vec
!
[
]
;
let
leaked
:
&
'
static
[
u8
]
=
{
let
o
=
v
.
clone
(
)
;
o
.
leak
(
)
}
;
assert_eq
!
(
leaked
&
*
v
)
;
}
#
[
test
]
fn
leak_box
(
)
{
use
super
:
:
Leak
;
let
v
:
Box
<
[
&
str
]
>
=
vec
!
[
"
hi
"
"
there
"
]
.
into_boxed_slice
(
)
;
let
leaked
:
&
'
static
[
&
str
]
=
{
let
o
=
v
.
clone
(
)
;
o
.
leak
(
)
}
;
assert_eq
!
(
leaked
&
*
v
)
;
}
#
[
test
]
fn
leak_nested
(
)
{
use
super
:
:
Leak
;
let
v
:
Box
<
Vec
<
&
str
>
>
=
Box
:
:
new
(
vec
!
[
"
hi
"
"
there
"
]
)
;
let
leaked
:
&
'
static
[
&
str
]
=
{
let
o
=
v
.
clone
(
)
;
o
.
leak
(
)
}
;
assert_eq
!
(
leaked
&
*
*
v
)
;
}
}
