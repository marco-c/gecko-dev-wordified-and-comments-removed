#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
cfg_attr
(
feature
=
"
shrink_to
"
feature
(
shrink_to
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
extern
crate
alloc
;
use
unix_str
:
:
UnixStr
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
unix_str
:
:
UnixString
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
core
:
:
borrow
:
:
Borrow
;
use
core
:
:
cmp
;
use
core
:
:
fmt
;
use
core
:
:
hash
:
:
{
Hash
Hasher
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
core
:
:
iter
;
use
core
:
:
iter
:
:
FusedIterator
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
core
:
:
ops
:
:
{
self
Deref
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
{
borrow
:
:
{
Cow
ToOwned
}
boxed
:
:
Box
rc
:
:
Rc
str
:
:
FromStr
string
:
:
String
sync
:
:
Arc
vec
:
:
Vec
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
error
:
:
Error
;
mod
lossy
;
pub
fn
is_separator
(
c
:
char
)
-
>
bool
{
c
=
=
'
/
'
}
pub
const
MAIN_SEPARATOR
:
char
=
'
/
'
;
fn
iter_after
<
'
a
'
b
I
J
>
(
mut
iter
:
I
mut
prefix
:
J
)
-
>
Option
<
I
>
where
I
:
Iterator
<
Item
=
Component
<
'
a
>
>
+
Clone
J
:
Iterator
<
Item
=
Component
<
'
b
>
>
{
loop
{
let
mut
iter_next
=
iter
.
clone
(
)
;
match
(
iter_next
.
next
(
)
prefix
.
next
(
)
)
{
(
Some
(
ref
x
)
Some
(
ref
y
)
)
if
x
=
=
y
=
>
(
)
(
Some
(
_
)
Some
(
_
)
)
=
>
return
None
(
Some
(
_
)
None
)
=
>
return
Some
(
iter
)
(
None
None
)
=
>
return
Some
(
iter
)
(
None
Some
(
_
)
)
=
>
return
None
}
iter
=
iter_next
;
}
}
fn
unix_str_as_u8_slice
(
s
:
&
UnixStr
)
-
>
&
[
u8
]
{
unsafe
{
&
*
(
s
as
*
const
UnixStr
as
*
const
[
u8
]
)
}
}
unsafe
fn
u8_slice_as_unix_str
(
s
:
&
[
u8
]
)
-
>
&
UnixStr
{
&
*
(
s
as
*
const
[
u8
]
as
*
const
UnixStr
)
}
fn
has_physical_root
(
path
:
&
[
u8
]
)
-
>
bool
{
!
path
.
is_empty
(
)
&
&
path
[
0
]
=
=
b
'
/
'
}
fn
split_file_at_dot
(
file
:
&
UnixStr
)
-
>
(
Option
<
&
UnixStr
>
Option
<
&
UnixStr
>
)
{
unsafe
{
if
unix_str_as_u8_slice
(
file
)
=
=
b
"
.
.
"
{
return
(
Some
(
file
)
None
)
;
}
let
mut
iter
=
unix_str_as_u8_slice
(
file
)
.
rsplitn
(
2
|
b
|
*
b
=
=
b
'
.
'
)
;
let
after
=
iter
.
next
(
)
;
let
before
=
iter
.
next
(
)
;
if
before
=
=
Some
(
b
"
"
)
{
(
Some
(
file
)
None
)
}
else
{
(
before
.
map
(
|
s
|
u8_slice_as_unix_str
(
s
)
)
after
.
map
(
|
s
|
u8_slice_as_unix_str
(
s
)
)
)
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
PartialOrd
Debug
)
]
enum
State
{
Prefix
=
0
StartDir
=
1
Body
=
2
Done
=
3
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
enum
Component
<
'
a
>
{
RootDir
CurDir
ParentDir
Normal
(
&
'
a
UnixStr
)
}
impl
<
'
a
>
Component
<
'
a
>
{
pub
fn
as_unix_str
(
self
)
-
>
&
'
a
UnixStr
{
match
self
{
Component
:
:
RootDir
=
>
UnixStr
:
:
new
(
"
/
"
)
Component
:
:
CurDir
=
>
UnixStr
:
:
new
(
"
.
"
)
Component
:
:
ParentDir
=
>
UnixStr
:
:
new
(
"
.
.
"
)
Component
:
:
Normal
(
path
)
=
>
path
}
}
}
impl
AsRef
<
UnixStr
>
for
Component
<
'
_
>
{
fn
as_ref
(
&
self
)
-
>
&
UnixStr
{
self
.
as_unix_str
(
)
}
}
impl
AsRef
<
Path
>
for
Component
<
'
_
>
{
fn
as_ref
(
&
self
)
-
>
&
Path
{
self
.
as_unix_str
(
)
.
as_ref
(
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
Components
<
'
a
>
{
path
:
&
'
a
[
u8
]
has_physical_root
:
bool
front
:
State
back
:
State
}
#
[
derive
(
Clone
)
]
pub
struct
Iter
<
'
a
>
{
inner
:
Components
<
'
a
>
}
impl
fmt
:
:
Debug
for
Components
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
struct
DebugHelper
<
'
a
>
(
&
'
a
Path
)
;
impl
fmt
:
:
Debug
for
DebugHelper
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
0
.
components
(
)
)
.
finish
(
)
}
}
f
.
debug_tuple
(
"
Components
"
)
.
field
(
&
DebugHelper
(
self
.
as_path
(
)
)
)
.
finish
(
)
}
}
impl
<
'
a
>
Components
<
'
a
>
{
#
[
inline
]
fn
len_before_body
(
&
self
)
-
>
usize
{
let
root
=
if
self
.
front
<
=
State
:
:
StartDir
&
&
self
.
has_physical_root
{
1
}
else
{
0
}
;
let
cur_dir
=
if
self
.
front
<
=
State
:
:
StartDir
&
&
self
.
include_cur_dir
(
)
{
1
}
else
{
0
}
;
root
+
cur_dir
}
#
[
inline
]
fn
finished
(
&
self
)
-
>
bool
{
self
.
front
=
=
State
:
:
Done
|
|
self
.
back
=
=
State
:
:
Done
|
|
self
.
front
>
self
.
back
}
#
[
inline
]
fn
is_sep_byte
(
&
self
b
:
u8
)
-
>
bool
{
b
=
=
b
'
/
'
}
pub
fn
as_path
(
&
self
)
-
>
&
'
a
Path
{
let
mut
comps
=
self
.
clone
(
)
;
if
comps
.
front
=
=
State
:
:
Body
{
comps
.
trim_left
(
)
;
}
if
comps
.
back
=
=
State
:
:
Body
{
comps
.
trim_right
(
)
;
}
unsafe
{
Path
:
:
from_u8_slice
(
comps
.
path
)
}
}
fn
has_root
(
&
self
)
-
>
bool
{
self
.
has_physical_root
}
fn
include_cur_dir
(
&
self
)
-
>
bool
{
if
self
.
has_root
(
)
{
return
false
;
}
let
mut
iter
=
self
.
path
[
.
.
]
.
iter
(
)
;
match
(
iter
.
next
(
)
iter
.
next
(
)
)
{
(
Some
(
&
b
'
.
'
)
None
)
=
>
true
(
Some
(
&
b
'
.
'
)
Some
(
&
b
)
)
=
>
self
.
is_sep_byte
(
b
)
_
=
>
false
}
}
fn
parse_single_component
<
'
b
>
(
&
self
comp
:
&
'
b
[
u8
]
)
-
>
Option
<
Component
<
'
b
>
>
{
match
comp
{
b
"
.
"
=
>
None
b
"
.
.
"
=
>
Some
(
Component
:
:
ParentDir
)
b
"
"
=
>
None
_
=
>
Some
(
Component
:
:
Normal
(
unsafe
{
u8_slice_as_unix_str
(
comp
)
}
)
)
}
}
fn
parse_next_component
(
&
self
)
-
>
(
usize
Option
<
Component
<
'
a
>
>
)
{
debug_assert
!
(
self
.
front
=
=
State
:
:
Body
)
;
let
(
extra
comp
)
=
match
self
.
path
.
iter
(
)
.
position
(
|
b
|
self
.
is_sep_byte
(
*
b
)
)
{
None
=
>
(
0
self
.
path
)
Some
(
i
)
=
>
(
1
&
self
.
path
[
.
.
i
]
)
}
;
(
comp
.
len
(
)
+
extra
self
.
parse_single_component
(
comp
)
)
}
fn
parse_next_component_back
(
&
self
)
-
>
(
usize
Option
<
Component
<
'
a
>
>
)
{
debug_assert
!
(
self
.
back
=
=
State
:
:
Body
)
;
let
start
=
self
.
len_before_body
(
)
;
let
(
extra
comp
)
=
match
self
.
path
[
start
.
.
]
.
iter
(
)
.
rposition
(
|
b
|
self
.
is_sep_byte
(
*
b
)
)
{
None
=
>
(
0
&
self
.
path
[
start
.
.
]
)
Some
(
i
)
=
>
(
1
&
self
.
path
[
start
+
i
+
1
.
.
]
)
}
;
(
comp
.
len
(
)
+
extra
self
.
parse_single_component
(
comp
)
)
}
fn
trim_left
(
&
mut
self
)
{
while
!
self
.
path
.
is_empty
(
)
{
let
(
size
comp
)
=
self
.
parse_next_component
(
)
;
if
comp
.
is_some
(
)
{
return
;
}
else
{
self
.
path
=
&
self
.
path
[
size
.
.
]
;
}
}
}
fn
trim_right
(
&
mut
self
)
{
while
self
.
path
.
len
(
)
>
self
.
len_before_body
(
)
{
let
(
size
comp
)
=
self
.
parse_next_component_back
(
)
;
if
comp
.
is_some
(
)
{
return
;
}
else
{
self
.
path
=
&
self
.
path
[
.
.
self
.
path
.
len
(
)
-
size
]
;
}
}
}
}
impl
AsRef
<
Path
>
for
Components
<
'
_
>
{
fn
as_ref
(
&
self
)
-
>
&
Path
{
self
.
as_path
(
)
}
}
impl
AsRef
<
UnixStr
>
for
Components
<
'
_
>
{
fn
as_ref
(
&
self
)
-
>
&
UnixStr
{
self
.
as_path
(
)
.
as_unix_str
(
)
}
}
impl
fmt
:
:
Debug
for
Iter
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
struct
DebugHelper
<
'
a
>
(
&
'
a
Path
)
;
impl
fmt
:
:
Debug
for
DebugHelper
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
0
.
iter
(
)
)
.
finish
(
)
}
}
f
.
debug_tuple
(
"
Iter
"
)
.
field
(
&
DebugHelper
(
self
.
as_path
(
)
)
)
.
finish
(
)
}
}
impl
<
'
a
>
Iter
<
'
a
>
{
pub
fn
as_path
(
&
self
)
-
>
&
'
a
Path
{
self
.
inner
.
as_path
(
)
}
}
impl
AsRef
<
Path
>
for
Iter
<
'
_
>
{
fn
as_ref
(
&
self
)
-
>
&
Path
{
self
.
as_path
(
)
}
}
impl
AsRef
<
UnixStr
>
for
Iter
<
'
_
>
{
fn
as_ref
(
&
self
)
-
>
&
UnixStr
{
self
.
as_path
(
)
.
as_unix_str
(
)
}
}
impl
<
'
a
>
Iterator
for
Iter
<
'
a
>
{
type
Item
=
&
'
a
UnixStr
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
inner
.
next
(
)
.
map
(
Component
:
:
as_unix_str
)
}
}
impl
<
'
a
>
DoubleEndedIterator
for
Iter
<
'
a
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
inner
.
next_back
(
)
.
map
(
Component
:
:
as_unix_str
)
}
}
impl
FusedIterator
for
Iter
<
'
_
>
{
}
impl
<
'
a
>
Iterator
for
Components
<
'
a
>
{
type
Item
=
Component
<
'
a
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Component
<
'
a
>
>
{
while
!
self
.
finished
(
)
{
match
self
.
front
{
State
:
:
Prefix
=
>
{
self
.
front
=
State
:
:
StartDir
;
}
State
:
:
StartDir
=
>
{
self
.
front
=
State
:
:
Body
;
if
self
.
has_physical_root
{
debug_assert
!
(
!
self
.
path
.
is_empty
(
)
)
;
self
.
path
=
&
self
.
path
[
1
.
.
]
;
return
Some
(
Component
:
:
RootDir
)
;
}
else
if
self
.
include_cur_dir
(
)
{
debug_assert
!
(
!
self
.
path
.
is_empty
(
)
)
;
self
.
path
=
&
self
.
path
[
1
.
.
]
;
return
Some
(
Component
:
:
CurDir
)
;
}
}
State
:
:
Body
if
!
self
.
path
.
is_empty
(
)
=
>
{
let
(
size
comp
)
=
self
.
parse_next_component
(
)
;
self
.
path
=
&
self
.
path
[
size
.
.
]
;
if
comp
.
is_some
(
)
{
return
comp
;
}
}
State
:
:
Body
=
>
{
self
.
front
=
State
:
:
Done
;
}
State
:
:
Done
=
>
unreachable
!
(
)
}
}
None
}
}
impl
<
'
a
>
DoubleEndedIterator
for
Components
<
'
a
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
Component
<
'
a
>
>
{
while
!
self
.
finished
(
)
{
match
self
.
back
{
State
:
:
Body
if
self
.
path
.
len
(
)
>
self
.
len_before_body
(
)
=
>
{
let
(
size
comp
)
=
self
.
parse_next_component_back
(
)
;
self
.
path
=
&
self
.
path
[
.
.
self
.
path
.
len
(
)
-
size
]
;
if
comp
.
is_some
(
)
{
return
comp
;
}
}
State
:
:
Body
=
>
{
self
.
back
=
State
:
:
StartDir
;
}
State
:
:
StartDir
=
>
{
self
.
back
=
State
:
:
Prefix
;
if
self
.
has_physical_root
{
self
.
path
=
&
self
.
path
[
.
.
self
.
path
.
len
(
)
-
1
]
;
return
Some
(
Component
:
:
RootDir
)
;
}
else
if
self
.
include_cur_dir
(
)
{
self
.
path
=
&
self
.
path
[
.
.
self
.
path
.
len
(
)
-
1
]
;
return
Some
(
Component
:
:
CurDir
)
;
}
}
State
:
:
Prefix
=
>
{
self
.
back
=
State
:
:
Done
;
return
None
;
}
State
:
:
Done
=
>
unreachable
!
(
)
}
}
None
}
}
impl
FusedIterator
for
Components
<
'
_
>
{
}
impl
<
'
a
>
cmp
:
:
PartialEq
for
Components
<
'
a
>
{
fn
eq
(
&
self
other
:
&
Components
<
'
a
>
)
-
>
bool
{
Iterator
:
:
eq
(
self
.
clone
(
)
other
.
clone
(
)
)
}
}
impl
cmp
:
:
Eq
for
Components
<
'
_
>
{
}
impl
<
'
a
>
cmp
:
:
PartialOrd
for
Components
<
'
a
>
{
fn
partial_cmp
(
&
self
other
:
&
Components
<
'
a
>
)
-
>
Option
<
cmp
:
:
Ordering
>
{
Iterator
:
:
partial_cmp
(
self
.
clone
(
)
other
.
clone
(
)
)
}
}
impl
cmp
:
:
Ord
for
Components
<
'
_
>
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
cmp
:
:
Ordering
{
Iterator
:
:
cmp
(
self
.
clone
(
)
other
.
clone
(
)
)
}
}
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
Ancestors
<
'
a
>
{
next
:
Option
<
&
'
a
Path
>
}
impl
<
'
a
>
Iterator
for
Ancestors
<
'
a
>
{
type
Item
=
&
'
a
Path
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
next
=
self
.
next
;
self
.
next
=
next
.
and_then
(
Path
:
:
parent
)
;
next
}
}
impl
FusedIterator
for
Ancestors
<
'
_
>
{
}
#
[
derive
(
Clone
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
struct
PathBuf
{
inner
:
UnixString
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
PathBuf
{
fn
as_mut_vec
(
&
mut
self
)
-
>
&
mut
Vec
<
u8
>
{
unsafe
{
&
mut
*
(
self
as
*
mut
PathBuf
as
*
mut
Vec
<
u8
>
)
}
}
pub
fn
new
(
)
-
>
PathBuf
{
PathBuf
{
inner
:
UnixString
:
:
new
(
)
}
}
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
PathBuf
{
PathBuf
{
inner
:
UnixString
:
:
with_capacity
(
capacity
)
}
}
pub
fn
as_path
(
&
self
)
-
>
&
Path
{
self
}
pub
fn
push
<
P
:
AsRef
<
Path
>
>
(
&
mut
self
path
:
P
)
{
self
.
_push
(
path
.
as_ref
(
)
)
}
fn
_push
(
&
mut
self
path
:
&
Path
)
{
let
need_sep
=
self
.
as_mut_vec
(
)
.
last
(
)
.
map
(
|
c
|
*
c
!
=
b
'
/
'
)
.
unwrap_or
(
false
)
;
if
path
.
is_absolute
(
)
|
|
path
.
has_root
(
)
{
self
.
as_mut_vec
(
)
.
truncate
(
0
)
;
}
else
if
need_sep
{
self
.
inner
.
push
(
"
/
"
)
;
}
self
.
inner
.
push
(
path
.
as_unix_str
(
)
)
;
}
pub
fn
pop
(
&
mut
self
)
-
>
bool
{
match
self
.
parent
(
)
.
map
(
|
p
|
p
.
as_unix_str
(
)
.
len
(
)
)
{
Some
(
len
)
=
>
{
self
.
as_mut_vec
(
)
.
truncate
(
len
)
;
true
}
None
=
>
false
}
}
pub
fn
set_file_name
<
S
:
AsRef
<
UnixStr
>
>
(
&
mut
self
file_name
:
S
)
{
self
.
_set_file_name
(
file_name
.
as_ref
(
)
)
}
fn
_set_file_name
(
&
mut
self
file_name
:
&
UnixStr
)
{
if
self
.
file_name
(
)
.
is_some
(
)
{
let
popped
=
self
.
pop
(
)
;
debug_assert
!
(
popped
)
;
}
self
.
push
(
file_name
)
;
}
pub
fn
set_extension
<
S
:
AsRef
<
UnixStr
>
>
(
&
mut
self
extension
:
S
)
-
>
bool
{
self
.
_set_extension
(
extension
.
as_ref
(
)
)
}
fn
_set_extension
(
&
mut
self
extension
:
&
UnixStr
)
-
>
bool
{
let
file_stem
=
match
self
.
file_stem
(
)
{
None
=
>
return
false
Some
(
f
)
=
>
unix_str_as_u8_slice
(
f
)
}
;
let
end_file_stem
=
file_stem
[
file_stem
.
len
(
)
.
.
]
.
as_ptr
(
)
as
usize
;
let
start
=
unix_str_as_u8_slice
(
&
self
.
inner
)
.
as_ptr
(
)
as
usize
;
let
v
=
self
.
as_mut_vec
(
)
;
v
.
truncate
(
end_file_stem
.
wrapping_sub
(
start
)
)
;
let
new
=
unix_str_as_u8_slice
(
extension
)
;
if
!
new
.
is_empty
(
)
{
v
.
reserve_exact
(
new
.
len
(
)
+
1
)
;
v
.
push
(
b
'
.
'
)
;
v
.
extend_from_slice
(
new
)
;
}
true
}
pub
fn
into_unix_string
(
self
)
-
>
UnixString
{
self
.
inner
}
pub
fn
into_boxed_path
(
self
)
-
>
Box
<
Path
>
{
let
rw
=
Box
:
:
into_raw
(
self
.
inner
.
into_boxed_unix_str
(
)
)
as
*
mut
Path
;
unsafe
{
Box
:
:
from_raw
(
rw
)
}
}
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
inner
.
capacity
(
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
inner
.
clear
(
)
}
pub
fn
reserve
(
&
mut
self
additional
:
usize
)
{
self
.
inner
.
reserve
(
additional
)
}
pub
fn
reserve_exact
(
&
mut
self
additional
:
usize
)
{
self
.
inner
.
reserve_exact
(
additional
)
}
pub
fn
shrink_to_fit
(
&
mut
self
)
{
self
.
inner
.
shrink_to_fit
(
)
}
#
[
cfg
(
feature
=
"
shrink_to
"
)
]
pub
fn
shrink_to
(
&
mut
self
min_capacity
:
usize
)
{
self
.
inner
.
shrink_to
(
min_capacity
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
&
Path
>
for
Box
<
Path
>
{
fn
from
(
path
:
&
Path
)
-
>
Box
<
Path
>
{
let
boxed
:
Box
<
UnixStr
>
=
path
.
inner
.
into
(
)
;
let
rw
=
Box
:
:
into_raw
(
boxed
)
as
*
mut
Path
;
unsafe
{
Box
:
:
from_raw
(
rw
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
Cow
<
'
_
Path
>
>
for
Box
<
Path
>
{
#
[
inline
]
fn
from
(
cow
:
Cow
<
'
_
Path
>
)
-
>
Box
<
Path
>
{
match
cow
{
Cow
:
:
Borrowed
(
path
)
=
>
Box
:
:
from
(
path
)
Cow
:
:
Owned
(
path
)
=
>
Box
:
:
from
(
path
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
Box
<
Path
>
>
for
PathBuf
{
fn
from
(
boxed
:
Box
<
Path
>
)
-
>
PathBuf
{
boxed
.
into_path_buf
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
PathBuf
>
for
Box
<
Path
>
{
fn
from
(
p
:
PathBuf
)
-
>
Self
{
p
.
into_boxed_path
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Clone
for
Box
<
Path
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
self
.
to_path_buf
(
)
.
into_boxed_path
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
T
:
?
Sized
+
AsRef
<
UnixStr
>
>
From
<
&
T
>
for
PathBuf
{
fn
from
(
s
:
&
T
)
-
>
Self
{
PathBuf
:
:
from
(
s
.
as_ref
(
)
.
to_unix_string
(
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
UnixString
>
for
PathBuf
{
#
[
inline
]
fn
from
(
s
:
UnixString
)
-
>
Self
{
PathBuf
{
inner
:
s
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
PathBuf
>
for
UnixString
{
fn
from
(
path_buf
:
PathBuf
)
-
>
Self
{
path_buf
.
inner
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
String
>
for
PathBuf
{
fn
from
(
s
:
String
)
-
>
PathBuf
{
PathBuf
:
:
from
(
UnixString
:
:
from
(
s
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
FromStr
for
PathBuf
{
type
Err
=
core
:
:
convert
:
:
Infallible
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
Ok
(
PathBuf
:
:
from
(
s
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
P
:
AsRef
<
Path
>
>
iter
:
:
FromIterator
<
P
>
for
PathBuf
{
fn
from_iter
<
I
:
IntoIterator
<
Item
=
P
>
>
(
iter
:
I
)
-
>
PathBuf
{
let
mut
buf
=
PathBuf
:
:
new
(
)
;
buf
.
extend
(
iter
)
;
buf
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
P
:
AsRef
<
Path
>
>
iter
:
:
Extend
<
P
>
for
PathBuf
{
fn
extend
<
I
:
IntoIterator
<
Item
=
P
>
>
(
&
mut
self
iter
:
I
)
{
iter
.
into_iter
(
)
.
for_each
(
move
|
p
|
self
.
push
(
p
.
as_ref
(
)
)
)
;
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
fmt
:
:
Debug
for
PathBuf
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
*
*
self
formatter
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
ops
:
:
Deref
for
PathBuf
{
type
Target
=
Path
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
Path
{
Path
:
:
new
(
&
self
.
inner
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Borrow
<
Path
>
for
PathBuf
{
fn
borrow
(
&
self
)
-
>
&
Path
{
self
.
deref
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Default
for
PathBuf
{
fn
default
(
)
-
>
Self
{
PathBuf
:
:
new
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
From
<
&
'
a
Path
>
for
Cow
<
'
a
Path
>
{
#
[
inline
]
fn
from
(
s
:
&
'
a
Path
)
-
>
Cow
<
'
a
Path
>
{
Cow
:
:
Borrowed
(
s
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
From
<
PathBuf
>
for
Cow
<
'
a
Path
>
{
#
[
inline
]
fn
from
(
s
:
PathBuf
)
-
>
Cow
<
'
a
Path
>
{
Cow
:
:
Owned
(
s
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
From
<
&
'
a
PathBuf
>
for
Cow
<
'
a
Path
>
{
#
[
inline
]
fn
from
(
p
:
&
'
a
PathBuf
)
-
>
Cow
<
'
a
Path
>
{
Cow
:
:
Borrowed
(
p
.
as_path
(
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
From
<
Cow
<
'
a
Path
>
>
for
PathBuf
{
#
[
inline
]
fn
from
(
p
:
Cow
<
'
a
Path
>
)
-
>
Self
{
p
.
into_owned
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
PathBuf
>
for
Arc
<
Path
>
{
#
[
inline
]
fn
from
(
s
:
PathBuf
)
-
>
Arc
<
Path
>
{
let
arc
:
Arc
<
UnixStr
>
=
Arc
:
:
from
(
s
.
into_unix_string
(
)
)
;
unsafe
{
Arc
:
:
from_raw
(
Arc
:
:
into_raw
(
arc
)
as
*
const
Path
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
&
Path
>
for
Arc
<
Path
>
{
#
[
inline
]
fn
from
(
s
:
&
Path
)
-
>
Arc
<
Path
>
{
let
arc
:
Arc
<
UnixStr
>
=
Arc
:
:
from
(
s
.
as_unix_str
(
)
)
;
unsafe
{
Arc
:
:
from_raw
(
Arc
:
:
into_raw
(
arc
)
as
*
const
Path
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
PathBuf
>
for
Rc
<
Path
>
{
#
[
inline
]
fn
from
(
s
:
PathBuf
)
-
>
Rc
<
Path
>
{
let
rc
:
Rc
<
UnixStr
>
=
Rc
:
:
from
(
s
.
into_unix_string
(
)
)
;
unsafe
{
Rc
:
:
from_raw
(
Rc
:
:
into_raw
(
rc
)
as
*
const
Path
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
&
Path
>
for
Rc
<
Path
>
{
#
[
inline
]
fn
from
(
s
:
&
Path
)
-
>
Rc
<
Path
>
{
let
rc
:
Rc
<
UnixStr
>
=
Rc
:
:
from
(
s
.
as_unix_str
(
)
)
;
unsafe
{
Rc
:
:
from_raw
(
Rc
:
:
into_raw
(
rc
)
as
*
const
Path
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
ToOwned
for
Path
{
type
Owned
=
PathBuf
;
fn
to_owned
(
&
self
)
-
>
PathBuf
{
self
.
to_path_buf
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
cmp
:
:
PartialEq
for
PathBuf
{
fn
eq
(
&
self
other
:
&
PathBuf
)
-
>
bool
{
self
.
components
(
)
=
=
other
.
components
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Hash
for
PathBuf
{
fn
hash
<
H
:
Hasher
>
(
&
self
h
:
&
mut
H
)
{
self
.
as_path
(
)
.
hash
(
h
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
cmp
:
:
Eq
for
PathBuf
{
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
cmp
:
:
PartialOrd
for
PathBuf
{
fn
partial_cmp
(
&
self
other
:
&
PathBuf
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
components
(
)
.
partial_cmp
(
other
.
components
(
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
cmp
:
:
Ord
for
PathBuf
{
fn
cmp
(
&
self
other
:
&
PathBuf
)
-
>
cmp
:
:
Ordering
{
self
.
components
(
)
.
cmp
(
other
.
components
(
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
AsRef
<
UnixStr
>
for
PathBuf
{
fn
as_ref
(
&
self
)
-
>
&
UnixStr
{
&
self
.
inner
[
.
.
]
}
}
pub
struct
Path
{
inner
:
UnixStr
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
pub
struct
StripPrefixError
(
(
)
)
;
impl
Path
{
unsafe
fn
from_u8_slice
(
s
:
&
[
u8
]
)
-
>
&
Path
{
Path
:
:
new
(
u8_slice_as_unix_str
(
s
)
)
}
fn
as_u8_slice
(
&
self
)
-
>
&
[
u8
]
{
unix_str_as_u8_slice
(
&
self
.
inner
)
}
pub
fn
new
<
S
:
AsRef
<
UnixStr
>
+
?
Sized
>
(
s
:
&
S
)
-
>
&
Path
{
unsafe
{
&
*
(
s
.
as_ref
(
)
as
*
const
UnixStr
as
*
const
Path
)
}
}
pub
fn
as_unix_str
(
&
self
)
-
>
&
UnixStr
{
&
self
.
inner
}
pub
fn
to_str
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
inner
.
to_str
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
self
.
inner
.
to_string_lossy
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
to_path_buf
(
&
self
)
-
>
PathBuf
{
PathBuf
:
:
from
(
&
self
.
inner
)
}
pub
fn
is_absolute
(
&
self
)
-
>
bool
{
self
.
has_root
(
)
}
pub
fn
is_relative
(
&
self
)
-
>
bool
{
!
self
.
is_absolute
(
)
}
pub
fn
has_root
(
&
self
)
-
>
bool
{
self
.
components
(
)
.
has_root
(
)
}
pub
fn
parent
(
&
self
)
-
>
Option
<
&
Path
>
{
let
mut
comps
=
self
.
components
(
)
;
let
comp
=
comps
.
next_back
(
)
;
comp
.
and_then
(
|
p
|
match
p
{
Component
:
:
Normal
(
_
)
|
Component
:
:
CurDir
|
Component
:
:
ParentDir
=
>
{
Some
(
comps
.
as_path
(
)
)
}
_
=
>
None
}
)
}
pub
fn
ancestors
(
&
self
)
-
>
Ancestors
<
'
_
>
{
Ancestors
{
next
:
Some
(
&
self
)
}
}
pub
fn
file_name
(
&
self
)
-
>
Option
<
&
UnixStr
>
{
self
.
components
(
)
.
next_back
(
)
.
and_then
(
|
p
|
match
p
{
Component
:
:
Normal
(
p
)
=
>
Some
(
p
)
_
=
>
None
}
)
}
pub
fn
strip_prefix
<
P
>
(
&
self
base
:
P
)
-
>
Result
<
&
Path
StripPrefixError
>
where
P
:
AsRef
<
Path
>
{
self
.
_strip_prefix
(
base
.
as_ref
(
)
)
}
fn
_strip_prefix
(
&
self
base
:
&
Path
)
-
>
Result
<
&
Path
StripPrefixError
>
{
iter_after
(
self
.
components
(
)
base
.
components
(
)
)
.
map
(
|
c
|
c
.
as_path
(
)
)
.
ok_or
(
StripPrefixError
(
(
)
)
)
}
pub
fn
starts_with
<
P
:
AsRef
<
Path
>
>
(
&
self
base
:
P
)
-
>
bool
{
self
.
_starts_with
(
base
.
as_ref
(
)
)
}
fn
_starts_with
(
&
self
base
:
&
Path
)
-
>
bool
{
iter_after
(
self
.
components
(
)
base
.
components
(
)
)
.
is_some
(
)
}
pub
fn
ends_with
<
P
:
AsRef
<
Path
>
>
(
&
self
child
:
P
)
-
>
bool
{
self
.
_ends_with
(
child
.
as_ref
(
)
)
}
fn
_ends_with
(
&
self
child
:
&
Path
)
-
>
bool
{
iter_after
(
self
.
components
(
)
.
rev
(
)
child
.
components
(
)
.
rev
(
)
)
.
is_some
(
)
}
pub
fn
file_stem
(
&
self
)
-
>
Option
<
&
UnixStr
>
{
self
.
file_name
(
)
.
map
(
split_file_at_dot
)
.
and_then
(
|
(
before
after
)
|
before
.
or
(
after
)
)
}
pub
fn
extension
(
&
self
)
-
>
Option
<
&
UnixStr
>
{
self
.
file_name
(
)
.
map
(
split_file_at_dot
)
.
and_then
(
|
(
before
after
)
|
before
.
and
(
after
)
)
}
#
[
must_use
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
join
<
P
:
AsRef
<
Path
>
>
(
&
self
path
:
P
)
-
>
PathBuf
{
self
.
_join
(
path
.
as_ref
(
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
_join
(
&
self
path
:
&
Path
)
-
>
PathBuf
{
let
mut
buf
=
self
.
to_path_buf
(
)
;
buf
.
push
(
path
)
;
buf
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
with_file_name
<
S
:
AsRef
<
UnixStr
>
>
(
&
self
file_name
:
S
)
-
>
PathBuf
{
self
.
_with_file_name
(
file_name
.
as_ref
(
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
_with_file_name
(
&
self
file_name
:
&
UnixStr
)
-
>
PathBuf
{
let
mut
buf
=
self
.
to_path_buf
(
)
;
buf
.
set_file_name
(
file_name
)
;
buf
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
with_extension
<
S
:
AsRef
<
UnixStr
>
>
(
&
self
extension
:
S
)
-
>
PathBuf
{
self
.
_with_extension
(
extension
.
as_ref
(
)
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
_with_extension
(
&
self
extension
:
&
UnixStr
)
-
>
PathBuf
{
let
mut
buf
=
self
.
to_path_buf
(
)
;
buf
.
set_extension
(
extension
)
;
buf
}
pub
fn
components
(
&
self
)
-
>
Components
<
'
_
>
{
Components
{
path
:
self
.
as_u8_slice
(
)
has_physical_root
:
has_physical_root
(
self
.
as_u8_slice
(
)
)
front
:
State
:
:
Prefix
back
:
State
:
:
Body
}
}
pub
fn
iter
(
&
self
)
-
>
Iter
<
'
_
>
{
Iter
{
inner
:
self
.
components
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
into_path_buf
(
self
:
Box
<
Path
>
)
-
>
PathBuf
{
let
rw
=
Box
:
:
into_raw
(
self
)
as
*
mut
UnixStr
;
let
inner
=
unsafe
{
Box
:
:
from_raw
(
rw
)
}
;
PathBuf
{
inner
:
UnixString
:
:
from
(
inner
)
}
}
pub
fn
display
(
&
self
)
-
>
Display
<
'
_
>
{
Display
{
path
:
self
}
}
}
impl
AsRef
<
UnixStr
>
for
Path
{
fn
as_ref
(
&
self
)
-
>
&
UnixStr
{
&
self
.
inner
}
}
impl
fmt
:
:
Debug
for
Path
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
self
.
inner
formatter
)
}
}
impl
cmp
:
:
PartialEq
for
Path
{
fn
eq
(
&
self
other
:
&
Path
)
-
>
bool
{
self
.
components
(
)
.
eq
(
other
.
components
(
)
)
}
}
impl
Hash
for
Path
{
fn
hash
<
H
:
Hasher
>
(
&
self
h
:
&
mut
H
)
{
for
component
in
self
.
components
(
)
{
component
.
hash
(
h
)
;
}
}
}
impl
cmp
:
:
Eq
for
Path
{
}
impl
cmp
:
:
PartialOrd
for
Path
{
fn
partial_cmp
(
&
self
other
:
&
Path
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
components
(
)
.
partial_cmp
(
other
.
components
(
)
)
}
}
impl
cmp
:
:
Ord
for
Path
{
fn
cmp
(
&
self
other
:
&
Path
)
-
>
cmp
:
:
Ordering
{
self
.
components
(
)
.
cmp
(
other
.
components
(
)
)
}
}
impl
AsRef
<
Path
>
for
Path
{
fn
as_ref
(
&
self
)
-
>
&
Path
{
self
}
}
impl
AsRef
<
Path
>
for
UnixStr
{
fn
as_ref
(
&
self
)
-
>
&
Path
{
Path
:
:
new
(
self
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
AsRef
<
Path
>
for
Cow
<
'
_
UnixStr
>
{
fn
as_ref
(
&
self
)
-
>
&
Path
{
Path
:
:
new
(
self
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
AsRef
<
Path
>
for
UnixString
{
fn
as_ref
(
&
self
)
-
>
&
Path
{
Path
:
:
new
(
self
)
}
}
impl
AsRef
<
Path
>
for
str
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
Path
{
Path
:
:
new
(
self
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
AsRef
<
Path
>
for
String
{
fn
as_ref
(
&
self
)
-
>
&
Path
{
Path
:
:
new
(
self
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
AsRef
<
Path
>
for
PathBuf
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
Path
{
self
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
IntoIterator
for
&
'
a
PathBuf
{
type
Item
=
&
'
a
UnixStr
;
type
IntoIter
=
Iter
<
'
a
>
;
fn
into_iter
(
self
)
-
>
Iter
<
'
a
>
{
self
.
iter
(
)
}
}
impl
<
'
a
>
IntoIterator
for
&
'
a
Path
{
type
Item
=
&
'
a
UnixStr
;
type
IntoIter
=
Iter
<
'
a
>
;
fn
into_iter
(
self
)
-
>
Iter
<
'
a
>
{
self
.
iter
(
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
use
serde
:
:
{
de
:
:
{
self
Deserialize
Deserializer
Unexpected
Visitor
}
ser
:
:
{
self
Serialize
Serializer
}
}
;
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
Serialize
for
Path
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
match
self
.
to_str
(
)
{
Some
(
s
)
=
>
s
.
serialize
(
serializer
)
None
=
>
Err
(
ser
:
:
Error
:
:
custom
(
"
path
contains
invalid
UTF
-
8
characters
"
)
)
}
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
Serialize
for
PathBuf
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
self
.
as_path
(
)
.
serialize
(
serializer
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
struct
PathVisitor
;
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
a
>
Visitor
<
'
a
>
for
PathVisitor
{
type
Value
=
&
'
a
Path
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
borrowed
path
"
)
}
fn
visit_borrowed_str
<
E
>
(
self
v
:
&
'
a
str
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
v
.
as_ref
(
)
)
}
fn
visit_borrowed_bytes
<
E
>
(
self
v
:
&
'
a
[
u8
]
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
core
:
:
str
:
:
from_utf8
(
v
)
.
map
(
AsRef
:
:
as_ref
)
.
map_err
(
|
_
|
de
:
:
Error
:
:
invalid_value
(
Unexpected
:
:
Bytes
(
v
)
&
self
)
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
:
'
a
'
a
>
Deserialize
<
'
de
>
for
&
'
a
Path
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_str
(
PathVisitor
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
struct
PathBufVisitor
;
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
>
Visitor
<
'
de
>
for
PathBufVisitor
{
type
Value
=
PathBuf
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
path
string
"
)
}
fn
visit_str
<
E
>
(
self
v
:
&
str
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
From
:
:
from
(
v
)
)
}
fn
visit_string
<
E
>
(
self
v
:
String
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
Ok
(
From
:
:
from
(
v
)
)
}
fn
visit_bytes
<
E
>
(
self
v
:
&
[
u8
]
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
core
:
:
str
:
:
from_utf8
(
v
)
.
map
(
From
:
:
from
)
.
map_err
(
|
_
|
de
:
:
Error
:
:
invalid_value
(
Unexpected
:
:
Bytes
(
v
)
&
self
)
)
}
fn
visit_byte_buf
<
E
>
(
self
v
:
Vec
<
u8
>
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
String
:
:
from_utf8
(
v
)
.
map
(
From
:
:
from
)
.
map_err
(
|
e
|
de
:
:
Error
:
:
invalid_value
(
Unexpected
:
:
Bytes
(
&
e
.
into_bytes
(
)
)
&
self
)
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
>
Deserialize
<
'
de
>
for
PathBuf
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_string
(
PathBufVisitor
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
>
Deserialize
<
'
de
>
for
Box
<
Path
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
Deserialize
:
:
deserialize
(
deserializer
)
.
map
(
PathBuf
:
:
into_boxed_path
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
macro_rules
!
impl_cmp
{
(
lhs
:
ty
rhs
:
ty
)
=
>
{
impl
<
'
a
'
b
>
PartialEq
<
rhs
>
for
lhs
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
rhs
)
-
>
bool
{
<
Path
as
PartialEq
>
:
:
eq
(
self
other
)
}
}
impl
<
'
a
'
b
>
PartialEq
<
lhs
>
for
rhs
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
lhs
)
-
>
bool
{
<
Path
as
PartialEq
>
:
:
eq
(
self
other
)
}
}
impl
<
'
a
'
b
>
PartialOrd
<
rhs
>
for
lhs
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
rhs
)
-
>
Option
<
cmp
:
:
Ordering
>
{
<
Path
as
PartialOrd
>
:
:
partial_cmp
(
self
other
)
}
}
impl
<
'
a
'
b
>
PartialOrd
<
lhs
>
for
rhs
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
lhs
)
-
>
Option
<
cmp
:
:
Ordering
>
{
<
Path
as
PartialOrd
>
:
:
partial_cmp
(
self
other
)
}
}
}
;
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl_cmp
!
(
PathBuf
Path
)
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl_cmp
!
(
PathBuf
&
'
a
Path
)
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl_cmp
!
(
Cow
<
'
a
Path
>
Path
)
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl_cmp
!
(
Cow
<
'
a
Path
>
&
'
b
Path
)
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl_cmp
!
(
Cow
<
'
a
Path
>
PathBuf
)
;
impl
fmt
:
:
Display
for
StripPrefixError
{
#
[
allow
(
deprecated
deprecated_in_future
)
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
"
prefix
not
found
"
.
fmt
(
f
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Error
for
StripPrefixError
{
#
[
allow
(
deprecated
)
]
fn
description
(
&
self
)
-
>
&
str
{
"
prefix
not
found
"
}
}
pub
struct
Display
<
'
a
>
{
path
:
&
'
a
Path
}
impl
fmt
:
:
Debug
for
Display
<
'
_
>
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
self
.
path
formatter
)
}
}
impl
fmt
:
:
Display
for
Display
<
'
_
>
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
lossy
:
:
Utf8Lossy
:
:
from_bytes
(
&
self
.
path
.
as_unix_str
(
)
.
as_bytes
(
)
)
formatter
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
alloc
:
:
rc
:
:
Rc
;
use
alloc
:
:
sync
:
:
Arc
;
macro_rules
!
t
(
(
path
:
expr
iter
:
iter
:
expr
)
=
>
(
{
let
path
=
Path
:
:
new
(
path
)
;
/
/
Forward
iteration
let
comps
=
path
.
iter
(
)
.
map
(
|
p
|
p
.
to_string_lossy
(
)
.
into_owned
(
)
)
.
collect
:
:
<
Vec
<
String
>
>
(
)
;
let
exp
:
&
[
&
str
]
=
&
iter
;
let
exps
=
exp
.
iter
(
)
.
map
(
|
s
|
s
.
to_string
(
)
)
.
collect
:
:
<
Vec
<
String
>
>
(
)
;
assert
!
(
comps
=
=
exps
"
iter
:
Expected
{
:
?
}
found
{
:
?
}
"
exps
comps
)
;
/
/
Reverse
iteration
let
comps
=
Path
:
:
new
(
path
)
.
iter
(
)
.
rev
(
)
.
map
(
|
p
|
p
.
to_string_lossy
(
)
.
into_owned
(
)
)
.
collect
:
:
<
Vec
<
String
>
>
(
)
;
let
exps
=
exps
.
into_iter
(
)
.
rev
(
)
.
collect
:
:
<
Vec
<
String
>
>
(
)
;
assert
!
(
comps
=
=
exps
"
iter
(
)
.
rev
(
)
:
Expected
{
:
?
}
found
{
:
?
}
"
exps
comps
)
;
}
)
;
(
path
:
expr
has_root
:
has_root
:
expr
is_absolute
:
is_absolute
:
expr
)
=
>
(
{
let
path
=
Path
:
:
new
(
path
)
;
let
act_root
=
path
.
has_root
(
)
;
assert
!
(
act_root
=
=
has_root
"
has_root
:
Expected
{
:
?
}
found
{
:
?
}
"
has_root
act_root
)
;
let
act_abs
=
path
.
is_absolute
(
)
;
assert
!
(
act_abs
=
=
is_absolute
"
is_absolute
:
Expected
{
:
?
}
found
{
:
?
}
"
is_absolute
act_abs
)
;
}
)
;
(
path
:
expr
parent
:
parent
:
expr
file_name
:
file
:
expr
)
=
>
(
{
let
path
=
Path
:
:
new
(
path
)
;
let
parent
=
path
.
parent
(
)
.
map
(
|
p
|
p
.
to_str
(
)
.
unwrap
(
)
)
;
let
exp_parent
:
Option
<
&
str
>
=
parent
;
assert
!
(
parent
=
=
exp_parent
"
parent
:
Expected
{
:
?
}
found
{
:
?
}
"
exp_parent
parent
)
;
let
file
=
path
.
file_name
(
)
.
map
(
|
p
|
p
.
to_str
(
)
.
unwrap
(
)
)
;
let
exp_file
:
Option
<
&
str
>
=
file
;
assert
!
(
file
=
=
exp_file
"
file_name
:
Expected
{
:
?
}
found
{
:
?
}
"
exp_file
file
)
;
}
)
;
(
path
:
expr
file_stem
:
file_stem
:
expr
extension
:
extension
:
expr
)
=
>
(
{
let
path
=
Path
:
:
new
(
path
)
;
let
stem
=
path
.
file_stem
(
)
.
map
(
|
p
|
p
.
to_str
(
)
.
unwrap
(
)
)
;
let
exp_stem
:
Option
<
&
str
>
=
file_stem
;
assert
!
(
stem
=
=
exp_stem
"
file_stem
:
Expected
{
:
?
}
found
{
:
?
}
"
exp_stem
stem
)
;
let
ext
=
path
.
extension
(
)
.
map
(
|
p
|
p
.
to_str
(
)
.
unwrap
(
)
)
;
let
exp_ext
:
Option
<
&
str
>
=
extension
;
assert
!
(
ext
=
=
exp_ext
"
extension
:
Expected
{
:
?
}
found
{
:
?
}
"
exp_ext
ext
)
;
}
)
;
(
path
:
expr
iter
:
iter
:
expr
has_root
:
has_root
:
expr
is_absolute
:
is_absolute
:
expr
parent
:
parent
:
expr
file_name
:
file
:
expr
file_stem
:
file_stem
:
expr
extension
:
extension
:
expr
)
=
>
(
{
t
!
(
path
iter
:
iter
)
;
t
!
(
path
has_root
:
has_root
is_absolute
:
is_absolute
)
;
t
!
(
path
parent
:
parent
file_name
:
file
)
;
t
!
(
path
file_stem
:
file_stem
extension
:
extension
)
;
}
)
;
)
;
#
[
test
]
fn
into
(
)
{
use
alloc
:
:
borrow
:
:
Cow
;
let
static_path
=
Path
:
:
new
(
"
/
home
/
foo
"
)
;
let
static_cow_path
:
Cow
<
'
static
Path
>
=
static_path
.
into
(
)
;
let
pathbuf
=
PathBuf
:
:
from
(
"
/
home
/
foo
"
)
;
{
let
path
:
&
Path
=
&
pathbuf
;
let
borrowed_cow_path
:
Cow
<
'
_
Path
>
=
path
.
into
(
)
;
assert_eq
!
(
static_cow_path
borrowed_cow_path
)
;
}
let
owned_cow_path
:
Cow
<
'
static
Path
>
=
pathbuf
.
into
(
)
;
assert_eq
!
(
static_cow_path
owned_cow_path
)
;
}
#
[
test
]
pub
fn
test_decompositions_unix
(
)
{
t
!
(
"
"
iter
:
[
]
has_root
:
false
is_absolute
:
false
parent
:
None
file_name
:
None
file_stem
:
None
extension
:
None
)
;
t
!
(
"
foo
"
iter
:
[
"
foo
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
"
)
file_name
:
Some
(
"
foo
"
)
file_stem
:
Some
(
"
foo
"
)
extension
:
None
)
;
t
!
(
"
/
"
iter
:
[
"
/
"
]
has_root
:
true
is_absolute
:
true
parent
:
None
file_name
:
None
file_stem
:
None
extension
:
None
)
;
t
!
(
"
/
foo
"
iter
:
[
"
/
"
"
foo
"
]
has_root
:
true
is_absolute
:
true
parent
:
Some
(
"
/
"
)
file_name
:
Some
(
"
foo
"
)
file_stem
:
Some
(
"
foo
"
)
extension
:
None
)
;
t
!
(
"
foo
/
"
iter
:
[
"
foo
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
"
)
file_name
:
Some
(
"
foo
"
)
file_stem
:
Some
(
"
foo
"
)
extension
:
None
)
;
t
!
(
"
/
foo
/
"
iter
:
[
"
/
"
"
foo
"
]
has_root
:
true
is_absolute
:
true
parent
:
Some
(
"
/
"
)
file_name
:
Some
(
"
foo
"
)
file_stem
:
Some
(
"
foo
"
)
extension
:
None
)
;
t
!
(
"
foo
/
bar
"
iter
:
[
"
foo
"
"
bar
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
foo
"
)
file_name
:
Some
(
"
bar
"
)
file_stem
:
Some
(
"
bar
"
)
extension
:
None
)
;
t
!
(
"
/
foo
/
bar
"
iter
:
[
"
/
"
"
foo
"
"
bar
"
]
has_root
:
true
is_absolute
:
true
parent
:
Some
(
"
/
foo
"
)
file_name
:
Some
(
"
bar
"
)
file_stem
:
Some
(
"
bar
"
)
extension
:
None
)
;
t
!
(
"
/
/
/
foo
/
/
/
"
iter
:
[
"
/
"
"
foo
"
]
has_root
:
true
is_absolute
:
true
parent
:
Some
(
"
/
"
)
file_name
:
Some
(
"
foo
"
)
file_stem
:
Some
(
"
foo
"
)
extension
:
None
)
;
t
!
(
"
/
/
/
foo
/
/
/
bar
"
iter
:
[
"
/
"
"
foo
"
"
bar
"
]
has_root
:
true
is_absolute
:
true
parent
:
Some
(
"
/
/
/
foo
"
)
file_name
:
Some
(
"
bar
"
)
file_stem
:
Some
(
"
bar
"
)
extension
:
None
)
;
t
!
(
"
.
/
.
"
iter
:
[
"
.
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
"
)
file_name
:
None
file_stem
:
None
extension
:
None
)
;
t
!
(
"
/
.
.
"
iter
:
[
"
/
"
"
.
.
"
]
has_root
:
true
is_absolute
:
true
parent
:
Some
(
"
/
"
)
file_name
:
None
file_stem
:
None
extension
:
None
)
;
t
!
(
"
.
.
/
"
iter
:
[
"
.
.
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
"
)
file_name
:
None
file_stem
:
None
extension
:
None
)
;
t
!
(
"
foo
/
.
"
iter
:
[
"
foo
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
"
)
file_name
:
Some
(
"
foo
"
)
file_stem
:
Some
(
"
foo
"
)
extension
:
None
)
;
t
!
(
"
foo
/
.
.
"
iter
:
[
"
foo
"
"
.
.
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
foo
"
)
file_name
:
None
file_stem
:
None
extension
:
None
)
;
t
!
(
"
foo
/
.
/
"
iter
:
[
"
foo
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
"
)
file_name
:
Some
(
"
foo
"
)
file_stem
:
Some
(
"
foo
"
)
extension
:
None
)
;
t
!
(
"
foo
/
.
/
bar
"
iter
:
[
"
foo
"
"
bar
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
foo
"
)
file_name
:
Some
(
"
bar
"
)
file_stem
:
Some
(
"
bar
"
)
extension
:
None
)
;
t
!
(
"
foo
/
.
.
/
"
iter
:
[
"
foo
"
"
.
.
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
foo
"
)
file_name
:
None
file_stem
:
None
extension
:
None
)
;
t
!
(
"
foo
/
.
.
/
bar
"
iter
:
[
"
foo
"
"
.
.
"
"
bar
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
foo
/
.
.
"
)
file_name
:
Some
(
"
bar
"
)
file_stem
:
Some
(
"
bar
"
)
extension
:
None
)
;
t
!
(
"
.
/
a
"
iter
:
[
"
.
"
"
a
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
.
"
)
file_name
:
Some
(
"
a
"
)
file_stem
:
Some
(
"
a
"
)
extension
:
None
)
;
t
!
(
"
.
"
iter
:
[
"
.
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
"
)
file_name
:
None
file_stem
:
None
extension
:
None
)
;
t
!
(
"
.
/
"
iter
:
[
"
.
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
"
)
file_name
:
None
file_stem
:
None
extension
:
None
)
;
t
!
(
"
a
/
b
"
iter
:
[
"
a
"
"
b
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
a
"
)
file_name
:
Some
(
"
b
"
)
file_stem
:
Some
(
"
b
"
)
extension
:
None
)
;
t
!
(
"
a
/
/
b
"
iter
:
[
"
a
"
"
b
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
a
"
)
file_name
:
Some
(
"
b
"
)
file_stem
:
Some
(
"
b
"
)
extension
:
None
)
;
t
!
(
"
a
/
.
/
b
"
iter
:
[
"
a
"
"
b
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
a
"
)
file_name
:
Some
(
"
b
"
)
file_stem
:
Some
(
"
b
"
)
extension
:
None
)
;
t
!
(
"
a
/
b
/
c
"
iter
:
[
"
a
"
"
b
"
"
c
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
a
/
b
"
)
file_name
:
Some
(
"
c
"
)
file_stem
:
Some
(
"
c
"
)
extension
:
None
)
;
t
!
(
"
.
foo
"
iter
:
[
"
.
foo
"
]
has_root
:
false
is_absolute
:
false
parent
:
Some
(
"
"
)
file_name
:
Some
(
"
.
foo
"
)
file_stem
:
Some
(
"
.
foo
"
)
extension
:
None
)
;
}
#
[
test
]
pub
fn
test_stem_ext
(
)
{
t
!
(
"
foo
"
file_stem
:
Some
(
"
foo
"
)
extension
:
None
)
;
t
!
(
"
foo
.
"
file_stem
:
Some
(
"
foo
"
)
extension
:
Some
(
"
"
)
)
;
t
!
(
"
.
foo
"
file_stem
:
Some
(
"
.
foo
"
)
extension
:
None
)
;
t
!
(
"
foo
.
txt
"
file_stem
:
Some
(
"
foo
"
)
extension
:
Some
(
"
txt
"
)
)
;
t
!
(
"
foo
.
bar
.
txt
"
file_stem
:
Some
(
"
foo
.
bar
"
)
extension
:
Some
(
"
txt
"
)
)
;
t
!
(
"
foo
.
bar
.
"
file_stem
:
Some
(
"
foo
.
bar
"
)
extension
:
Some
(
"
"
)
)
;
t
!
(
"
.
"
file_stem
:
None
extension
:
None
)
;
t
!
(
"
.
.
"
file_stem
:
None
extension
:
None
)
;
t
!
(
"
"
file_stem
:
None
extension
:
None
)
;
}
#
[
test
]
pub
fn
test_push
(
)
{
macro_rules
!
tp
(
(
path
:
expr
push
:
expr
expected
:
expr
)
=
>
(
{
let
mut
actual
=
PathBuf
:
:
from
(
path
)
;
actual
.
push
(
push
)
;
assert
!
(
actual
.
to_str
(
)
=
=
Some
(
expected
)
"
pushing
{
:
?
}
onto
{
:
?
}
:
Expected
{
:
?
}
got
{
:
?
}
"
push
path
expected
actual
.
to_str
(
)
.
unwrap
(
)
)
;
}
)
;
)
;
tp
!
(
"
"
"
foo
"
"
foo
"
)
;
tp
!
(
"
foo
"
"
bar
"
"
foo
/
bar
"
)
;
tp
!
(
"
foo
/
"
"
bar
"
"
foo
/
bar
"
)
;
tp
!
(
"
foo
/
/
"
"
bar
"
"
foo
/
/
bar
"
)
;
tp
!
(
"
foo
/
.
"
"
bar
"
"
foo
/
.
/
bar
"
)
;
tp
!
(
"
foo
.
/
.
"
"
bar
"
"
foo
.
/
.
/
bar
"
)
;
tp
!
(
"
foo
"
"
"
"
foo
/
"
)
;
tp
!
(
"
foo
"
"
.
"
"
foo
/
.
"
)
;
tp
!
(
"
foo
"
"
.
.
"
"
foo
/
.
.
"
)
;
tp
!
(
"
foo
"
"
/
"
"
/
"
)
;
tp
!
(
"
/
foo
/
bar
"
"
/
"
"
/
"
)
;
tp
!
(
"
/
foo
/
bar
"
"
/
baz
"
"
/
baz
"
)
;
tp
!
(
"
/
foo
/
bar
"
"
.
/
baz
"
"
/
foo
/
bar
/
.
/
baz
"
)
;
}
#
[
test
]
pub
fn
test_pop
(
)
{
macro_rules
!
tp
(
(
path
:
expr
expected
:
expr
output
:
expr
)
=
>
(
{
let
mut
actual
=
PathBuf
:
:
from
(
path
)
;
let
output
=
actual
.
pop
(
)
;
assert
!
(
actual
.
to_str
(
)
=
=
Some
(
expected
)
&
&
output
=
=
output
"
popping
from
{
:
?
}
:
Expected
{
:
?
}
/
{
:
?
}
got
{
:
?
}
/
{
:
?
}
"
path
expected
output
actual
.
to_str
(
)
.
unwrap
(
)
output
)
;
}
)
;
)
;
tp
!
(
"
"
"
"
false
)
;
tp
!
(
"
/
"
"
/
"
false
)
;
tp
!
(
"
foo
"
"
"
true
)
;
tp
!
(
"
.
"
"
"
true
)
;
tp
!
(
"
/
foo
"
"
/
"
true
)
;
tp
!
(
"
/
foo
/
bar
"
"
/
foo
"
true
)
;
tp
!
(
"
foo
/
bar
"
"
foo
"
true
)
;
tp
!
(
"
foo
/
.
"
"
"
true
)
;
tp
!
(
"
foo
/
/
bar
"
"
foo
"
true
)
;
}
#
[
test
]
pub
fn
test_set_file_name
(
)
{
macro_rules
!
tfn
(
(
path
:
expr
file
:
expr
expected
:
expr
)
=
>
(
{
let
mut
p
=
PathBuf
:
:
from
(
path
)
;
p
.
set_file_name
(
file
)
;
assert
!
(
p
.
to_str
(
)
=
=
Some
(
expected
)
"
setting
file
name
of
{
:
?
}
to
{
:
?
}
:
Expected
{
:
?
}
got
{
:
?
}
"
path
file
expected
p
.
to_str
(
)
.
unwrap
(
)
)
;
}
)
;
)
;
tfn
!
(
"
foo
"
"
foo
"
"
foo
"
)
;
tfn
!
(
"
foo
"
"
bar
"
"
bar
"
)
;
tfn
!
(
"
foo
"
"
"
"
"
)
;
tfn
!
(
"
"
"
foo
"
"
foo
"
)
;
tfn
!
(
"
.
"
"
foo
"
"
.
/
foo
"
)
;
tfn
!
(
"
foo
/
"
"
bar
"
"
bar
"
)
;
tfn
!
(
"
foo
/
.
"
"
bar
"
"
bar
"
)
;
tfn
!
(
"
.
.
"
"
foo
"
"
.
.
/
foo
"
)
;
tfn
!
(
"
foo
/
.
.
"
"
bar
"
"
foo
/
.
.
/
bar
"
)
;
tfn
!
(
"
/
"
"
foo
"
"
/
foo
"
)
;
}
#
[
test
]
pub
fn
test_set_extension
(
)
{
macro_rules
!
tfe
(
(
path
:
expr
ext
:
expr
expected
:
expr
output
:
expr
)
=
>
(
{
let
mut
p
=
PathBuf
:
:
from
(
path
)
;
let
output
=
p
.
set_extension
(
ext
)
;
assert
!
(
p
.
to_str
(
)
=
=
Some
(
expected
)
&
&
output
=
=
output
"
setting
extension
of
{
:
?
}
to
{
:
?
}
:
Expected
{
:
?
}
/
{
:
?
}
got
{
:
?
}
/
{
:
?
}
"
path
ext
expected
output
p
.
to_str
(
)
.
unwrap
(
)
output
)
;
}
)
;
)
;
tfe
!
(
"
foo
"
"
txt
"
"
foo
.
txt
"
true
)
;
tfe
!
(
"
foo
.
bar
"
"
txt
"
"
foo
.
txt
"
true
)
;
tfe
!
(
"
foo
.
bar
.
baz
"
"
txt
"
"
foo
.
bar
.
txt
"
true
)
;
tfe
!
(
"
.
test
"
"
txt
"
"
.
test
.
txt
"
true
)
;
tfe
!
(
"
foo
.
txt
"
"
"
"
foo
"
true
)
;
tfe
!
(
"
foo
"
"
"
"
foo
"
true
)
;
tfe
!
(
"
"
"
foo
"
"
"
false
)
;
tfe
!
(
"
.
"
"
foo
"
"
.
"
false
)
;
tfe
!
(
"
foo
/
"
"
bar
"
"
foo
.
bar
"
true
)
;
tfe
!
(
"
foo
/
.
"
"
bar
"
"
foo
.
bar
"
true
)
;
tfe
!
(
"
.
.
"
"
foo
"
"
.
.
"
false
)
;
tfe
!
(
"
foo
/
.
.
"
"
bar
"
"
foo
/
.
.
"
false
)
;
tfe
!
(
"
/
"
"
foo
"
"
/
"
false
)
;
}
#
[
test
]
fn
test_eq_receivers
(
)
{
use
alloc
:
:
borrow
:
:
Cow
;
let
borrowed
:
&
Path
=
Path
:
:
new
(
"
foo
/
bar
"
)
;
let
mut
owned
:
PathBuf
=
PathBuf
:
:
new
(
)
;
owned
.
push
(
"
foo
"
)
;
owned
.
push
(
"
bar
"
)
;
let
borrowed_cow
:
Cow
<
'
_
Path
>
=
borrowed
.
into
(
)
;
let
owned_cow
:
Cow
<
'
_
Path
>
=
owned
.
clone
(
)
.
into
(
)
;
macro_rules
!
t
{
(
(
current
:
expr
)
+
)
=
>
{
(
assert_eq
!
(
current
borrowed
)
;
assert_eq
!
(
current
owned
)
;
assert_eq
!
(
current
borrowed_cow
)
;
assert_eq
!
(
current
owned_cow
)
;
)
+
}
}
t
!
(
borrowed
owned
borrowed_cow
owned_cow
)
;
}
#
[
test
]
pub
fn
test_compare
(
)
{
use
std
:
:
collections
:
:
hash_map
:
:
DefaultHasher
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
fn
hash
<
T
:
Hash
>
(
t
:
T
)
-
>
u64
{
let
mut
s
=
DefaultHasher
:
:
new
(
)
;
t
.
hash
(
&
mut
s
)
;
s
.
finish
(
)
}
macro_rules
!
tc
(
(
path1
:
expr
path2
:
expr
eq
:
eq
:
expr
starts_with
:
starts_with
:
expr
ends_with
:
ends_with
:
expr
relative_from
:
relative_from
:
expr
)
=
>
(
{
let
path1
=
Path
:
:
new
(
path1
)
;
let
path2
=
Path
:
:
new
(
path2
)
;
let
eq
=
path1
=
=
path2
;
assert
!
(
eq
=
=
eq
"
{
:
?
}
=
=
{
:
?
}
expected
{
:
?
}
got
{
:
?
}
"
path1
path2
eq
eq
)
;
assert
!
(
eq
=
=
(
hash
(
path1
)
=
=
hash
(
path2
)
)
"
{
:
?
}
=
=
{
:
?
}
expected
{
:
?
}
got
{
}
and
{
}
"
path1
path2
eq
hash
(
path1
)
hash
(
path2
)
)
;
let
starts_with
=
path1
.
starts_with
(
path2
)
;
assert
!
(
starts_with
=
=
starts_with
"
{
:
?
}
.
starts_with
(
{
:
?
}
)
expected
{
:
?
}
got
{
:
?
}
"
path1
path2
starts_with
starts_with
)
;
let
ends_with
=
path1
.
ends_with
(
path2
)
;
assert
!
(
ends_with
=
=
ends_with
"
{
:
?
}
.
ends_with
(
{
:
?
}
)
expected
{
:
?
}
got
{
:
?
}
"
path1
path2
ends_with
ends_with
)
;
let
relative_from
=
path1
.
strip_prefix
(
path2
)
.
map
(
|
p
|
p
.
to_str
(
)
.
unwrap
(
)
)
.
ok
(
)
;
let
exp
:
Option
<
&
str
>
=
relative_from
;
assert
!
(
relative_from
=
=
exp
"
{
:
?
}
.
strip_prefix
(
{
:
?
}
)
expected
{
:
?
}
got
{
:
?
}
"
path1
path2
exp
relative_from
)
;
}
)
;
)
;
tc
!
(
"
"
"
"
eq
:
true
starts_with
:
true
ends_with
:
true
relative_from
:
Some
(
"
"
)
)
;
tc
!
(
"
foo
"
"
"
eq
:
false
starts_with
:
true
ends_with
:
true
relative_from
:
Some
(
"
foo
"
)
)
;
tc
!
(
"
"
"
foo
"
eq
:
false
starts_with
:
false
ends_with
:
false
relative_from
:
None
)
;
tc
!
(
"
foo
"
"
foo
"
eq
:
true
starts_with
:
true
ends_with
:
true
relative_from
:
Some
(
"
"
)
)
;
tc
!
(
"
foo
/
"
"
foo
"
eq
:
true
starts_with
:
true
ends_with
:
true
relative_from
:
Some
(
"
"
)
)
;
tc
!
(
"
foo
/
bar
"
"
foo
"
eq
:
false
starts_with
:
true
ends_with
:
false
relative_from
:
Some
(
"
bar
"
)
)
;
tc
!
(
"
foo
/
bar
/
baz
"
"
foo
/
bar
"
eq
:
false
starts_with
:
true
ends_with
:
false
relative_from
:
Some
(
"
baz
"
)
)
;
tc
!
(
"
foo
/
bar
"
"
foo
/
bar
/
baz
"
eq
:
false
starts_with
:
false
ends_with
:
false
relative_from
:
None
)
;
tc
!
(
"
.
/
foo
/
bar
/
"
"
.
"
eq
:
false
starts_with
:
true
ends_with
:
false
relative_from
:
Some
(
"
foo
/
bar
"
)
)
;
}
#
[
test
]
fn
test_components_debug
(
)
{
let
path
=
Path
:
:
new
(
"
/
tmp
"
)
;
let
mut
components
=
path
.
components
(
)
;
let
expected
=
"
Components
(
[
RootDir
Normal
(
\
"
tmp
\
"
)
]
)
"
;
let
actual
=
format
!
(
"
{
:
?
}
"
components
)
;
assert_eq
!
(
expected
actual
)
;
let
_
=
components
.
next
(
)
.
unwrap
(
)
;
let
expected
=
"
Components
(
[
Normal
(
\
"
tmp
\
"
)
]
)
"
;
let
actual
=
format
!
(
"
{
:
?
}
"
components
)
;
assert_eq
!
(
expected
actual
)
;
let
_
=
components
.
next
(
)
.
unwrap
(
)
;
let
expected
=
"
Components
(
[
]
)
"
;
let
actual
=
format
!
(
"
{
:
?
}
"
components
)
;
assert_eq
!
(
expected
actual
)
;
}
#
[
test
]
fn
test_iter_debug
(
)
{
let
path
=
Path
:
:
new
(
"
/
tmp
"
)
;
let
mut
iter
=
path
.
iter
(
)
;
let
expected
=
"
Iter
(
[
\
"
/
\
"
\
"
tmp
\
"
]
)
"
;
let
actual
=
format
!
(
"
{
:
?
}
"
iter
)
;
assert_eq
!
(
expected
actual
)
;
let
_
=
iter
.
next
(
)
.
unwrap
(
)
;
let
expected
=
"
Iter
(
[
\
"
tmp
\
"
]
)
"
;
let
actual
=
format
!
(
"
{
:
?
}
"
iter
)
;
assert_eq
!
(
expected
actual
)
;
let
_
=
iter
.
next
(
)
.
unwrap
(
)
;
let
expected
=
"
Iter
(
[
]
)
"
;
let
actual
=
format
!
(
"
{
:
?
}
"
iter
)
;
assert_eq
!
(
expected
actual
)
;
}
#
[
test
]
fn
into_boxed
(
)
{
let
orig
:
&
str
=
"
some
/
sort
/
of
/
path
"
;
let
path
=
Path
:
:
new
(
orig
)
;
let
boxed
:
Box
<
Path
>
=
Box
:
:
from
(
path
)
;
let
path_buf
=
path
.
to_owned
(
)
.
into_boxed_path
(
)
.
into_path_buf
(
)
;
assert_eq
!
(
path
&
*
boxed
)
;
assert_eq
!
(
&
*
boxed
&
*
path_buf
)
;
assert_eq
!
(
&
*
path_buf
path
)
;
}
#
[
test
]
fn
into_rc
(
)
{
let
orig
=
"
hello
/
world
"
;
let
path
=
Path
:
:
new
(
orig
)
;
let
rc
:
Rc
<
Path
>
=
Rc
:
:
from
(
path
)
;
let
arc
:
Arc
<
Path
>
=
Arc
:
:
from
(
path
)
;
assert_eq
!
(
&
*
rc
path
)
;
assert_eq
!
(
&
*
arc
path
)
;
let
rc2
:
Rc
<
Path
>
=
Rc
:
:
from
(
path
.
to_owned
(
)
)
;
let
arc2
:
Arc
<
Path
>
=
Arc
:
:
from
(
path
.
to_owned
(
)
)
;
assert_eq
!
(
&
*
rc2
path
)
;
assert_eq
!
(
&
*
arc2
path
)
;
}
}
