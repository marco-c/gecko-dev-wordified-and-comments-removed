use
core
:
:
char
;
use
core
:
:
fmt
:
:
{
self
Write
}
;
use
core
:
:
mem
;
use
core
:
:
str
as
core_str
;
static
UTF8_CHAR_WIDTH
:
[
u8
;
256
]
=
[
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
4
4
4
4
4
0
0
0
0
0
0
0
0
0
0
0
]
;
#
[
inline
]
pub
fn
utf8_char_width
(
b
:
u8
)
-
>
usize
{
UTF8_CHAR_WIDTH
[
b
as
usize
]
as
usize
}
pub
struct
Utf8Lossy
{
bytes
:
[
u8
]
}
impl
Utf8Lossy
{
pub
fn
from_bytes
(
bytes
:
&
[
u8
]
)
-
>
&
Utf8Lossy
{
unsafe
{
mem
:
:
transmute
(
bytes
)
}
}
pub
fn
chunks
(
&
self
)
-
>
Utf8LossyChunksIter
<
'
_
>
{
Utf8LossyChunksIter
{
source
:
&
self
.
bytes
}
}
}
pub
struct
Utf8LossyChunksIter
<
'
a
>
{
source
:
&
'
a
[
u8
]
}
#
[
derive
(
PartialEq
Eq
Debug
)
]
pub
struct
Utf8LossyChunk
<
'
a
>
{
pub
valid
:
&
'
a
str
pub
broken
:
&
'
a
[
u8
]
}
impl
<
'
a
>
Iterator
for
Utf8LossyChunksIter
<
'
a
>
{
type
Item
=
Utf8LossyChunk
<
'
a
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Utf8LossyChunk
<
'
a
>
>
{
if
self
.
source
.
is_empty
(
)
{
return
None
;
}
const
TAG_CONT_U8
:
u8
=
128
;
fn
safe_get
(
xs
:
&
[
u8
]
i
:
usize
)
-
>
u8
{
*
xs
.
get
(
i
)
.
unwrap_or
(
&
0
)
}
let
mut
i
=
0
;
while
i
<
self
.
source
.
len
(
)
{
let
i_
=
i
;
let
byte
=
unsafe
{
*
self
.
source
.
get_unchecked
(
i
)
}
;
i
+
=
1
;
if
byte
<
128
{
}
else
{
let
w
=
utf8_char_width
(
byte
)
;
macro_rules
!
error
{
(
)
=
>
{
{
/
/
SAFETY
:
We
have
checked
up
to
i
that
source
is
valid
UTF
-
8
.
unsafe
{
let
r
=
Utf8LossyChunk
{
valid
:
core_str
:
:
from_utf8_unchecked
(
&
self
.
source
[
0
.
.
i_
]
)
broken
:
&
self
.
source
[
i_
.
.
i
]
}
;
self
.
source
=
&
self
.
source
[
i
.
.
]
;
return
Some
(
r
)
;
}
}
}
;
}
match
w
{
2
=
>
{
if
safe_get
(
self
.
source
i
)
&
192
!
=
TAG_CONT_U8
{
error
!
(
)
;
}
i
+
=
1
;
}
3
=
>
{
match
(
byte
safe_get
(
self
.
source
i
)
)
{
(
0xE0
0xA0
.
.
=
0xBF
)
=
>
(
)
(
0xE1
.
.
=
0xEC
0x80
.
.
=
0xBF
)
=
>
(
)
(
0xED
0x80
.
.
=
0x9F
)
=
>
(
)
(
0xEE
.
.
=
0xEF
0x80
.
.
=
0xBF
)
=
>
(
)
_
=
>
{
error
!
(
)
;
}
}
i
+
=
1
;
if
safe_get
(
self
.
source
i
)
&
192
!
=
TAG_CONT_U8
{
error
!
(
)
;
}
i
+
=
1
;
}
4
=
>
{
match
(
byte
safe_get
(
self
.
source
i
)
)
{
(
0xF0
0x90
.
.
=
0xBF
)
=
>
(
)
(
0xF1
.
.
=
0xF3
0x80
.
.
=
0xBF
)
=
>
(
)
(
0xF4
0x80
.
.
=
0x8F
)
=
>
(
)
_
=
>
{
error
!
(
)
;
}
}
i
+
=
1
;
if
safe_get
(
self
.
source
i
)
&
192
!
=
TAG_CONT_U8
{
error
!
(
)
;
}
i
+
=
1
;
if
safe_get
(
self
.
source
i
)
&
192
!
=
TAG_CONT_U8
{
error
!
(
)
;
}
i
+
=
1
;
}
_
=
>
{
error
!
(
)
;
}
}
}
}
let
r
=
Utf8LossyChunk
{
valid
:
unsafe
{
core_str
:
:
from_utf8_unchecked
(
self
.
source
)
}
broken
:
&
[
]
}
;
self
.
source
=
&
[
]
;
Some
(
r
)
}
}
impl
fmt
:
:
Display
for
Utf8Lossy
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
if
self
.
bytes
.
is_empty
(
)
{
return
"
"
.
fmt
(
f
)
;
}
for
Utf8LossyChunk
{
valid
broken
}
in
self
.
chunks
(
)
{
if
valid
.
len
(
)
=
=
self
.
bytes
.
len
(
)
{
assert
!
(
broken
.
is_empty
(
)
)
;
return
valid
.
fmt
(
f
)
;
}
f
.
write_str
(
valid
)
?
;
if
!
broken
.
is_empty
(
)
{
f
.
write_char
(
char
:
:
REPLACEMENT_CHARACTER
)
?
;
}
}
Ok
(
(
)
)
}
}
