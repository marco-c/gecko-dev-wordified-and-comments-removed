#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
.
png
"
html_favicon_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
docs
.
rs
/
getrandom
/
0
.
2
.
11
"
)
]
#
!
[
no_std
]
#
!
[
warn
(
rust_2018_idioms
unused_lifetimes
missing_docs
)
]
#
!
[
cfg_attr
(
docsrs
feature
(
doc_cfg
)
)
]
#
[
macro_use
]
extern
crate
cfg_if
;
use
crate
:
:
util
:
:
{
slice_as_uninit_mut
slice_assume_init_mut
}
;
use
core
:
:
mem
:
:
MaybeUninit
;
mod
error
;
mod
util
;
#
[
cfg
(
feature
=
"
custom
"
)
]
mod
custom
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
error_impls
;
pub
use
crate
:
:
error
:
:
Error
;
cfg_if
!
{
if
#
[
cfg
(
any
(
target_os
=
"
haiku
"
target_os
=
"
redox
"
target_os
=
"
nto
"
target_os
=
"
aix
"
)
)
]
{
mod
util_libc
;
#
[
path
=
"
use_file
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
{
mod
util_libc
;
mod
use_file
;
#
[
path
=
"
linux_android
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
any
(
target_os
=
"
illumos
"
target_os
=
"
solaris
"
)
)
]
{
mod
util_libc
;
mod
use_file
;
#
[
path
=
"
solaris_illumos
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
any
(
target_os
=
"
freebsd
"
target_os
=
"
netbsd
"
)
)
]
{
mod
util_libc
;
#
[
path
=
"
bsd_arandom
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
target_os
=
"
dragonfly
"
)
]
{
mod
util_libc
;
mod
use_file
;
#
[
path
=
"
dragonfly
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
target_os
=
"
fuchsia
"
)
]
{
#
[
path
=
"
fuchsia
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
any
(
target_os
=
"
ios
"
target_os
=
"
watchos
"
target_os
=
"
tvos
"
)
)
]
{
#
[
path
=
"
apple
-
other
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
target_os
=
"
macos
"
)
]
{
mod
util_libc
;
mod
use_file
;
#
[
path
=
"
macos
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
target_os
=
"
openbsd
"
)
]
{
mod
util_libc
;
#
[
path
=
"
openbsd
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
target_os
=
"
wasi
"
)
)
]
{
#
[
path
=
"
wasi
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
target_os
=
"
hermit
"
)
]
{
#
[
path
=
"
hermit
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
target_os
=
"
vxworks
"
)
]
{
mod
util_libc
;
#
[
path
=
"
vxworks
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
target_os
=
"
solid_asp3
"
)
]
{
#
[
path
=
"
solid
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
target_os
=
"
espidf
"
)
]
{
#
[
path
=
"
espidf
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
windows
)
]
{
#
[
path
=
"
windows
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
all
(
target_os
=
"
horizon
"
target_arch
=
"
arm
"
)
)
]
{
/
/
We
check
for
target_arch
=
"
arm
"
because
the
Nintendo
Switch
also
/
/
uses
Horizon
OS
(
it
is
aarch64
)
.
mod
util_libc
;
#
[
path
=
"
3ds
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
target_os
=
"
vita
"
)
]
{
mod
util_libc
;
#
[
path
=
"
vita
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
target_os
=
"
emscripten
"
)
]
{
mod
util_libc
;
#
[
path
=
"
emscripten
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
all
(
target_arch
=
"
x86_64
"
target_env
=
"
sgx
"
)
)
]
{
#
[
path
=
"
rdrand
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
all
(
feature
=
"
rdrand
"
any
(
target_arch
=
"
x86_64
"
target_arch
=
"
x86
"
)
)
)
]
{
#
[
path
=
"
rdrand
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
all
(
feature
=
"
js
"
any
(
target_arch
=
"
wasm32
"
target_arch
=
"
wasm64
"
)
target_os
=
"
unknown
"
)
)
]
{
#
[
path
=
"
js
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
target_os
=
"
hurd
"
)
]
{
mod
util_libc
;
#
[
path
=
"
hurd
.
rs
"
]
mod
imp
;
}
else
if
#
[
cfg
(
feature
=
"
custom
"
)
]
{
use
custom
as
imp
;
}
else
if
#
[
cfg
(
all
(
any
(
target_arch
=
"
wasm32
"
target_arch
=
"
wasm64
"
)
target_os
=
"
unknown
"
)
)
]
{
compile_error
!
(
"
the
wasm
*
-
unknown
-
unknown
targets
are
not
supported
by
\
default
you
may
need
to
enable
the
\
"
js
\
"
feature
.
\
For
more
information
see
:
\
https
:
/
/
docs
.
rs
/
getrandom
/
#
webassembly
-
support
"
)
;
}
else
{
compile_error
!
(
"
target
is
not
supported
for
more
information
see
:
\
https
:
/
/
docs
.
rs
/
getrandom
/
#
unsupported
-
targets
"
)
;
}
}
#
[
inline
]
pub
fn
getrandom
(
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
getrandom_uninit
(
unsafe
{
slice_as_uninit_mut
(
dest
)
}
)
?
;
Ok
(
(
)
)
}
#
[
inline
]
pub
fn
getrandom_uninit
(
dest
:
&
mut
[
MaybeUninit
<
u8
>
]
)
-
>
Result
<
&
mut
[
u8
]
Error
>
{
if
!
dest
.
is_empty
(
)
{
imp
:
:
getrandom_inner
(
dest
)
?
;
}
Ok
(
unsafe
{
slice_assume_init_mut
(
dest
)
}
)
}
