use
crate
:
:
Error
;
extern
crate
std
;
use
std
:
:
{
mem
:
:
MaybeUninit
thread_local
}
;
use
js_sys
:
:
{
global
Function
Uint8Array
}
;
use
wasm_bindgen
:
:
{
prelude
:
:
wasm_bindgen
JsCast
JsValue
}
;
const
WEB_CRYPTO_BUFFER_SIZE
:
usize
=
256
;
const
NODE_MAX_BUFFER_SIZE
:
usize
=
(
1
<
<
31
)
-
1
;
enum
RngSource
{
Node
(
NodeCrypto
)
Web
(
WebCrypto
Uint8Array
)
}
thread_local
!
(
static
RNG_SOURCE
:
Result
<
RngSource
Error
>
=
getrandom_init
(
)
;
)
;
pub
(
crate
)
fn
getrandom_inner
(
dest
:
&
mut
[
MaybeUninit
<
u8
>
]
)
-
>
Result
<
(
)
Error
>
{
RNG_SOURCE
.
with
(
|
result
|
{
let
source
=
result
.
as_ref
(
)
.
map_err
(
|
&
e
|
e
)
?
;
match
source
{
RngSource
:
:
Node
(
n
)
=
>
{
for
chunk
in
dest
.
chunks_mut
(
NODE_MAX_BUFFER_SIZE
)
{
let
res
=
n
.
random_fill_sync
(
unsafe
{
Uint8Array
:
:
view_mut_raw
(
chunk
.
as_mut_ptr
(
)
as
*
mut
u8
chunk
.
len
(
)
)
}
)
;
if
res
.
is_err
(
)
{
return
Err
(
Error
:
:
NODE_RANDOM_FILL_SYNC
)
;
}
}
}
RngSource
:
:
Web
(
crypto
buf
)
=
>
{
for
chunk
in
dest
.
chunks_mut
(
WEB_CRYPTO_BUFFER_SIZE
)
{
let
sub_buf
=
buf
.
subarray
(
0
chunk
.
len
(
)
as
u32
)
;
if
crypto
.
get_random_values
(
&
sub_buf
)
.
is_err
(
)
{
return
Err
(
Error
:
:
WEB_GET_RANDOM_VALUES
)
;
}
unsafe
{
sub_buf
.
raw_copy_to_ptr
(
chunk
.
as_mut_ptr
(
)
as
*
mut
u8
)
}
;
}
}
}
;
Ok
(
(
)
)
}
)
}
fn
getrandom_init
(
)
-
>
Result
<
RngSource
Error
>
{
let
global
:
Global
=
global
(
)
.
unchecked_into
(
)
;
let
crypto
=
match
global
.
crypto
(
)
{
c
if
c
.
is_object
(
)
=
>
c
_
if
is_node
(
&
global
)
=
>
{
match
Module
:
:
require_fn
(
)
.
and_then
(
JsCast
:
:
dyn_into
:
:
<
Function
>
)
{
Ok
(
require_fn
)
=
>
match
require_fn
.
call1
(
&
global
&
JsValue
:
:
from_str
(
"
crypto
"
)
)
{
Ok
(
n
)
=
>
return
Ok
(
RngSource
:
:
Node
(
n
.
unchecked_into
(
)
)
)
Err
(
_
)
=
>
return
Err
(
Error
:
:
NODE_CRYPTO
)
}
Err
(
_
)
=
>
return
Err
(
Error
:
:
NODE_ES_MODULE
)
}
}
_
=
>
match
global
.
ms_crypto
(
)
{
c
if
c
.
is_object
(
)
=
>
c
_
=
>
return
Err
(
Error
:
:
WEB_CRYPTO
)
}
}
;
let
buf
=
Uint8Array
:
:
new_with_length
(
WEB_CRYPTO_BUFFER_SIZE
as
u32
)
;
Ok
(
RngSource
:
:
Web
(
crypto
buf
)
)
}
fn
is_node
(
global
:
&
Global
)
-
>
bool
{
let
process
=
global
.
process
(
)
;
if
process
.
is_object
(
)
{
let
versions
=
process
.
versions
(
)
;
if
versions
.
is_object
(
)
{
return
versions
.
node
(
)
.
is_string
(
)
;
}
}
false
}
#
[
wasm_bindgen
]
extern
"
C
"
{
type
Global
;
type
WebCrypto
;
#
[
wasm_bindgen
(
method
getter
)
]
fn
crypto
(
this
:
&
Global
)
-
>
WebCrypto
;
#
[
wasm_bindgen
(
method
getter
js_name
=
msCrypto
)
]
fn
ms_crypto
(
this
:
&
Global
)
-
>
WebCrypto
;
#
[
wasm_bindgen
(
method
js_name
=
getRandomValues
catch
)
]
fn
get_random_values
(
this
:
&
WebCrypto
buf
:
&
Uint8Array
)
-
>
Result
<
(
)
JsValue
>
;
type
NodeCrypto
;
#
[
wasm_bindgen
(
method
js_name
=
randomFillSync
catch
)
]
fn
random_fill_sync
(
this
:
&
NodeCrypto
buf
:
Uint8Array
)
-
>
Result
<
(
)
JsValue
>
;
type
Module
;
#
[
wasm_bindgen
(
getter
static_method_of
=
Module
js_class
=
module
js_name
=
require
catch
)
]
fn
require_fn
(
)
-
>
Result
<
JsValue
JsValue
>
;
#
[
wasm_bindgen
(
method
getter
)
]
fn
process
(
this
:
&
Global
)
-
>
Process
;
type
Process
;
#
[
wasm_bindgen
(
method
getter
)
]
fn
versions
(
this
:
&
Process
)
-
>
Versions
;
type
Versions
;
#
[
wasm_bindgen
(
method
getter
)
]
fn
node
(
this
:
&
Versions
)
-
>
JsValue
;
}
