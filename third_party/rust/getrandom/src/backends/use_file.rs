use
crate
:
:
Error
;
use
core
:
:
{
ffi
:
:
c_void
mem
:
:
MaybeUninit
sync
:
:
atomic
:
:
{
AtomicI32
Ordering
}
}
;
#
[
cfg
(
not
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
]
pub
use
crate
:
:
util
:
:
{
inner_u32
inner_u64
}
;
#
[
path
=
"
.
.
/
util_libc
.
rs
"
]
pub
(
super
)
mod
util_libc
;
const
FILE_PATH
:
&
[
u8
]
=
b
"
/
dev
/
urandom
\
0
"
;
const
FD_UNINIT
:
libc
:
:
c_int
=
-
1
;
const
FD_ONGOING_INIT
:
libc
:
:
c_int
=
-
2
;
static
FD
:
AtomicI32
=
AtomicI32
:
:
new
(
FD_UNINIT
)
;
pub
fn
fill_inner
(
dest
:
&
mut
[
MaybeUninit
<
u8
>
]
)
-
>
Result
<
(
)
Error
>
{
let
mut
fd
=
FD
.
load
(
Ordering
:
:
Acquire
)
;
if
fd
=
=
FD_UNINIT
|
|
fd
=
=
FD_ONGOING_INIT
{
fd
=
open_or_wait
(
)
?
;
}
util_libc
:
:
sys_fill_exact
(
dest
|
buf
|
unsafe
{
libc
:
:
read
(
fd
buf
.
as_mut_ptr
(
)
.
cast
:
:
<
c_void
>
(
)
buf
.
len
(
)
)
}
)
}
fn
open_readonly
(
path
:
&
[
u8
]
)
-
>
Result
<
libc
:
:
c_int
Error
>
{
assert
!
(
path
.
iter
(
)
.
any
(
|
&
b
|
b
=
=
0
)
)
;
loop
{
let
fd
=
unsafe
{
libc
:
:
open
(
path
.
as_ptr
(
)
.
cast
:
:
<
libc
:
:
c_char
>
(
)
libc
:
:
O_RDONLY
|
libc
:
:
O_CLOEXEC
)
}
;
if
fd
>
=
0
{
return
Ok
(
fd
)
;
}
let
err
=
util_libc
:
:
last_os_error
(
)
;
if
err
.
raw_os_error
(
)
!
=
Some
(
libc
:
:
EINTR
)
{
return
Err
(
err
)
;
}
}
}
#
[
cold
]
fn
open_or_wait
(
)
-
>
Result
<
libc
:
:
c_int
Error
>
{
loop
{
match
FD
.
load
(
Ordering
:
:
Acquire
)
{
FD_UNINIT
=
>
{
let
res
=
FD
.
compare_exchange_weak
(
FD_UNINIT
FD_ONGOING_INIT
Ordering
:
:
AcqRel
Ordering
:
:
Relaxed
)
;
if
res
.
is_ok
(
)
{
break
;
}
}
FD_ONGOING_INIT
=
>
sync
:
:
wait
(
)
fd
=
>
return
Ok
(
fd
)
}
}
let
res
=
open_fd
(
)
;
let
val
=
match
res
{
Ok
(
fd
)
=
>
fd
Err
(
_
)
=
>
FD_UNINIT
}
;
FD
.
store
(
val
Ordering
:
:
Release
)
;
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
sync
:
:
wake
(
)
;
res
}
fn
open_fd
(
)
-
>
Result
<
libc
:
:
c_int
Error
>
{
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
sync
:
:
wait_until_rng_ready
(
)
?
;
let
fd
=
open_readonly
(
FILE_PATH
)
?
;
debug_assert
!
(
fd
>
=
0
)
;
Ok
(
fd
)
}
#
[
cfg
(
not
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
]
mod
sync
{
pub
(
super
)
fn
wait
(
)
{
let
rqtp
=
libc
:
:
timespec
{
tv_sec
:
0
tv_nsec
:
1_000_000
}
;
let
mut
rmtp
=
libc
:
:
timespec
{
tv_sec
:
0
tv_nsec
:
0
}
;
unsafe
{
libc
:
:
nanosleep
(
&
rqtp
&
mut
rmtp
)
;
}
}
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
mod
sync
{
use
super
:
:
{
open_readonly
util_libc
:
:
last_os_error
Error
FD
FD_ONGOING_INIT
}
;
pub
(
super
)
fn
wait
(
)
{
let
op
=
libc
:
:
FUTEX_WAIT
|
libc
:
:
FUTEX_PRIVATE_FLAG
;
let
timeout_ptr
=
core
:
:
ptr
:
:
null
:
:
<
libc
:
:
timespec
>
(
)
;
let
ret
=
unsafe
{
libc
:
:
syscall
(
libc
:
:
SYS_futex
&
FD
op
FD_ONGOING_INIT
timeout_ptr
)
}
;
debug_assert
!
(
{
match
ret
{
0
=
>
true
-
1
=
>
last_os_error
(
)
.
raw_os_error
(
)
=
=
Some
(
libc
:
:
EAGAIN
)
_
=
>
false
}
}
)
;
}
pub
(
super
)
fn
wake
(
)
{
let
op
=
libc
:
:
FUTEX_WAKE
|
libc
:
:
FUTEX_PRIVATE_FLAG
;
let
ret
=
unsafe
{
libc
:
:
syscall
(
libc
:
:
SYS_futex
&
FD
op
libc
:
:
INT_MAX
)
}
;
debug_assert
!
(
ret
>
=
0
)
;
}
pub
(
super
)
fn
wait_until_rng_ready
(
)
-
>
Result
<
(
)
Error
>
{
let
fd
=
open_readonly
(
b
"
/
dev
/
random
\
0
"
)
?
;
let
mut
pfd
=
libc
:
:
pollfd
{
fd
events
:
libc
:
:
POLLIN
revents
:
0
}
;
let
res
=
loop
{
let
res
=
unsafe
{
libc
:
:
poll
(
&
mut
pfd
1
-
1
)
}
;
if
res
>
=
0
{
debug_assert_eq
!
(
res
1
)
;
break
Ok
(
(
)
)
;
}
let
err
=
last_os_error
(
)
;
match
err
.
raw_os_error
(
)
{
Some
(
libc
:
:
EINTR
)
=
>
continue
_
=
>
break
Err
(
err
)
}
}
;
unsafe
{
libc
:
:
close
(
fd
)
}
;
res
}
}
