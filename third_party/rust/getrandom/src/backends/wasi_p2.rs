use
crate
:
:
Error
;
use
core
:
:
mem
:
:
MaybeUninit
;
use
wasi
:
:
random
:
:
random
:
:
get_random_u64
;
pub
fn
inner_u32
(
)
-
>
Result
<
u32
Error
>
{
let
val
=
get_random_u64
(
)
;
Ok
(
crate
:
:
util
:
:
truncate
(
val
)
)
}
pub
fn
inner_u64
(
)
-
>
Result
<
u64
Error
>
{
Ok
(
get_random_u64
(
)
)
}
pub
fn
fill_inner
(
dest
:
&
mut
[
MaybeUninit
<
u8
>
]
)
-
>
Result
<
(
)
Error
>
{
use
core
:
:
ptr
:
:
copy_nonoverlapping
;
use
wasi
:
:
random
:
:
random
:
:
get_random_u64
;
let
(
prefix
chunks
suffix
)
=
unsafe
{
dest
.
align_to_mut
:
:
<
MaybeUninit
<
u64
>
>
(
)
}
;
if
!
prefix
.
is_empty
(
)
{
let
val
=
get_random_u64
(
)
;
let
src
=
(
&
val
as
*
const
u64
)
.
cast
(
)
;
unsafe
{
copy_nonoverlapping
(
src
prefix
.
as_mut_ptr
(
)
prefix
.
len
(
)
)
;
}
}
for
dst
in
chunks
{
dst
.
write
(
get_random_u64
(
)
)
;
}
if
!
suffix
.
is_empty
(
)
{
let
val
=
get_random_u64
(
)
;
let
src
=
(
&
val
as
*
const
u64
)
.
cast
(
)
;
unsafe
{
copy_nonoverlapping
(
src
suffix
.
as_mut_ptr
(
)
suffix
.
len
(
)
)
;
}
}
Ok
(
(
)
)
}
