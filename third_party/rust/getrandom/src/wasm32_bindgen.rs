extern
crate
std
;
use
core
:
:
cell
:
:
RefCell
;
use
core
:
:
mem
;
use
std
:
:
thread_local
;
use
js_sys
:
:
Uint8Array
;
extern
crate
bindgen
as
wasm_bindgen
;
use
wasm_bindgen
:
:
prelude
:
:
*
;
use
crate
:
:
error
:
:
{
BINDGEN_CRYPTO_UNDEF
BINDGEN_GRV_UNDEF
}
;
use
crate
:
:
Error
;
const
CHUNK_SIZE
:
usize
=
256
;
#
[
derive
(
Clone
Debug
)
]
enum
RngSource
{
Node
(
NodeCrypto
)
Browser
(
BrowserCrypto
Uint8Array
)
}
thread_local
!
(
static
RNG_SOURCE
:
RefCell
<
Option
<
RngSource
>
>
=
RefCell
:
:
new
(
None
)
;
)
;
pub
fn
getrandom_inner
(
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
assert_eq
!
(
mem
:
:
size_of
:
:
<
usize
>
(
)
4
)
;
RNG_SOURCE
.
with
(
|
f
|
{
let
mut
source
=
f
.
borrow_mut
(
)
;
if
source
.
is_none
(
)
{
*
source
=
Some
(
getrandom_init
(
)
?
)
;
}
match
source
.
as_ref
(
)
.
unwrap
(
)
{
RngSource
:
:
Node
(
n
)
=
>
n
.
random_fill_sync
(
dest
)
RngSource
:
:
Browser
(
crypto
buf
)
=
>
{
for
chunk
in
dest
.
chunks_mut
(
CHUNK_SIZE
)
{
let
sub_buf
=
buf
.
subarray
(
0
chunk
.
len
(
)
as
u32
)
;
crypto
.
get_random_values
(
&
sub_buf
)
;
sub_buf
.
copy_to
(
chunk
)
;
}
}
}
;
Ok
(
(
)
)
}
)
}
fn
getrandom_init
(
)
-
>
Result
<
RngSource
Error
>
{
if
let
Ok
(
self_
)
=
Global
:
:
get_self
(
)
{
let
crypto
:
BrowserCrypto
=
match
(
self_
.
crypto
(
)
self_
.
ms_crypto
(
)
)
{
(
crypto
_
)
if
!
crypto
.
is_undefined
(
)
=
>
crypto
.
into
(
)
(
_
crypto
)
if
!
crypto
.
is_undefined
(
)
=
>
crypto
.
into
(
)
_
=
>
return
Err
(
BINDGEN_CRYPTO_UNDEF
)
}
;
if
crypto
.
get_random_values_fn
(
)
.
is_undefined
(
)
{
return
Err
(
BINDGEN_GRV_UNDEF
)
;
}
let
buf
=
Uint8Array
:
:
new_with_length
(
CHUNK_SIZE
as
u32
)
;
return
Ok
(
RngSource
:
:
Browser
(
crypto
buf
)
)
;
}
return
Ok
(
RngSource
:
:
Node
(
MODULE
.
require
(
"
crypto
"
)
)
)
;
}
#
[
wasm_bindgen
]
extern
"
C
"
{
type
Global
;
#
[
wasm_bindgen
(
getter
catch
static_method_of
=
Global
js_class
=
self
js_name
=
self
)
]
fn
get_self
(
)
-
>
Result
<
Self_
JsValue
>
;
type
Self_
;
#
[
wasm_bindgen
(
method
getter
js_name
=
"
msCrypto
"
structural
)
]
fn
ms_crypto
(
me
:
&
Self_
)
-
>
JsValue
;
#
[
wasm_bindgen
(
method
getter
structural
)
]
fn
crypto
(
me
:
&
Self_
)
-
>
JsValue
;
#
[
derive
(
Clone
Debug
)
]
type
BrowserCrypto
;
#
[
wasm_bindgen
(
method
js_name
=
getRandomValues
structural
getter
)
]
fn
get_random_values_fn
(
me
:
&
BrowserCrypto
)
-
>
JsValue
;
#
[
wasm_bindgen
(
method
js_name
=
getRandomValues
structural
)
]
fn
get_random_values
(
me
:
&
BrowserCrypto
buf
:
&
Uint8Array
)
;
#
[
derive
(
Clone
Debug
)
]
type
NodeCrypto
;
#
[
wasm_bindgen
(
method
js_name
=
randomFillSync
structural
)
]
fn
random_fill_sync
(
me
:
&
NodeCrypto
buf
:
&
mut
[
u8
]
)
;
type
NodeModule
;
#
[
wasm_bindgen
(
js_name
=
module
)
]
static
MODULE
:
NodeModule
;
#
[
wasm_bindgen
(
method
)
]
fn
require
(
this
:
&
NodeModule
s
:
&
str
)
-
>
NodeCrypto
;
}
