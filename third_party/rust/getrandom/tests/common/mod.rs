use
super
:
:
getrandom_impl
;
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
target_os
=
"
unknown
"
)
)
]
use
wasm_bindgen_test
:
:
wasm_bindgen_test
as
test
;
#
[
cfg
(
feature
=
"
test
-
in
-
browser
"
)
]
wasm_bindgen_test
:
:
wasm_bindgen_test_configure
!
(
run_in_browser
)
;
#
[
test
]
fn
test_zero
(
)
{
getrandom_impl
(
&
mut
[
0u8
;
0
]
)
.
unwrap
(
)
;
}
#
[
cfg
(
not
(
feature
=
"
custom
"
)
)
]
fn
num_diff_bits
(
s1
:
&
[
u8
]
s2
:
&
[
u8
]
)
-
>
usize
{
assert_eq
!
(
s1
.
len
(
)
s2
.
len
(
)
)
;
s1
.
iter
(
)
.
zip
(
s2
.
iter
(
)
)
.
map
(
|
(
a
b
)
|
(
a
^
b
)
.
count_ones
(
)
as
usize
)
.
sum
(
)
}
#
[
test
]
#
[
cfg
(
not
(
feature
=
"
custom
"
)
)
]
fn
test_diff
(
)
{
let
mut
v1
=
[
0u8
;
1000
]
;
getrandom_impl
(
&
mut
v1
)
.
unwrap
(
)
;
let
mut
v2
=
[
0u8
;
1000
]
;
getrandom_impl
(
&
mut
v2
)
.
unwrap
(
)
;
let
d
=
num_diff_bits
(
&
v1
&
v2
)
;
assert
!
(
d
>
3500
)
;
assert
!
(
d
<
4500
)
;
}
#
[
test
]
#
[
cfg
(
not
(
feature
=
"
custom
"
)
)
]
fn
test_small
(
)
{
for
size
in
1
.
.
=
64
{
let
mut
num_bytes
=
0
;
let
mut
diff_bits
=
0
;
while
num_bytes
<
256
{
let
mut
s1
=
vec
!
[
0u8
;
size
]
;
getrandom_impl
(
&
mut
s1
)
.
unwrap
(
)
;
let
mut
s2
=
vec
!
[
0u8
;
size
]
;
getrandom_impl
(
&
mut
s2
)
.
unwrap
(
)
;
num_bytes
+
=
size
;
diff_bits
+
=
num_diff_bits
(
&
s1
&
s2
)
;
}
assert
!
(
diff_bits
>
3
*
num_bytes
)
;
assert
!
(
diff_bits
<
5
*
num_bytes
)
;
}
}
#
[
test
]
fn
test_huge
(
)
{
let
mut
huge
=
[
0u8
;
100_000
]
;
getrandom_impl
(
&
mut
huge
)
.
unwrap
(
)
;
}
#
[
cfg
(
not
(
target_arch
=
"
wasm32
"
)
)
]
#
[
test
]
fn
test_multithreading
(
)
{
extern
crate
std
;
use
std
:
:
{
sync
:
:
mpsc
:
:
channel
thread
vec
}
;
let
mut
txs
=
vec
!
[
]
;
for
_
in
0
.
.
20
{
let
(
tx
rx
)
=
channel
(
)
;
txs
.
push
(
tx
)
;
thread
:
:
spawn
(
move
|
|
{
rx
.
recv
(
)
.
unwrap
(
)
;
let
mut
v
=
[
0u8
;
1000
]
;
for
_
in
0
.
.
100
{
getrandom_impl
(
&
mut
v
)
.
unwrap
(
)
;
thread
:
:
yield_now
(
)
;
}
}
)
;
}
for
tx
in
txs
.
iter
(
)
{
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
}
