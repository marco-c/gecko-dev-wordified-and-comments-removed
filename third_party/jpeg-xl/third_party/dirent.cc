#
if
defined
(
_WIN32
)
|
|
defined
(
_WIN64
)
#
include
"
third_party
/
dirent
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
ifndef
NOMINMAX
#
define
NOMINMAX
#
endif
#
include
<
windows
.
h
>
#
include
<
memory
>
#
include
<
string
>
int
mkdir
(
const
char
*
path
mode_t
)
{
const
LPSECURITY_ATTRIBUTES
sec
=
nullptr
;
if
(
!
CreateDirectory
(
path
sec
)
)
{
JXL_NOTIFY_ERROR
(
"
Failed
to
create
directory
%
s
"
path
)
;
return
-
1
;
}
return
0
;
}
struct
DIR
{
HANDLE
hFind
;
WIN32_FIND_DATA
findData
;
dirent
ent
;
size_t
numCalls
=
0
;
}
;
static
bool
IsValidDirectory
(
const
char
*
path
)
{
const
DWORD
fileAttributes
=
GetFileAttributes
(
path
)
;
if
(
fileAttributes
=
=
INVALID_FILE_ATTRIBUTES
)
return
false
;
if
(
(
fileAttributes
&
FILE_ATTRIBUTE_DIRECTORY
)
=
=
0
)
return
false
;
return
true
;
}
DIR
*
opendir
(
const
char
*
path
)
{
if
(
!
IsValidDirectory
(
path
)
)
{
errno
=
ENOENT
;
return
nullptr
;
}
std
:
:
unique_ptr
<
DIR
>
d
(
new
DIR
)
;
std
:
:
string
searchPath
(
path
)
;
if
(
searchPath
.
back
(
)
!
=
'
/
'
&
&
searchPath
.
back
(
)
!
=
'
\
\
'
)
{
searchPath
+
=
'
\
\
'
;
}
searchPath
+
=
'
*
'
;
d
-
>
hFind
=
FindFirstFile
(
searchPath
.
c_str
(
)
&
d
-
>
findData
)
;
if
(
d
-
>
hFind
!
=
INVALID_HANDLE_VALUE
)
return
d
.
release
(
)
;
if
(
GetLastError
(
)
=
=
ERROR_NO_MORE_FILES
)
return
d
.
release
(
)
;
JXL_NOTIFY_ERROR
(
"
Failed
to
open
directory
%
s
"
searchPath
.
c_str
(
)
)
;
return
nullptr
;
}
int
closedir
(
DIR
*
dir
)
{
delete
dir
;
return
0
;
}
dirent
*
readdir
(
DIR
*
d
)
{
if
(
d
-
>
hFind
=
=
INVALID_HANDLE_VALUE
)
return
nullptr
;
for
(
;
;
)
{
if
(
d
-
>
numCalls
+
+
!
=
0
)
{
if
(
!
FindNextFile
(
d
-
>
hFind
&
d
-
>
findData
)
)
{
JXL_ASSERT
(
GetLastError
(
)
=
=
ERROR_NO_MORE_FILES
)
;
SetLastError
(
0
)
;
return
nullptr
;
}
}
if
(
(
d
-
>
findData
.
dwFileAttributes
&
(
FILE_ATTRIBUTE_HIDDEN
|
FILE_ATTRIBUTE_SYSTEM
)
)
=
=
0
)
{
d
-
>
ent
.
d_name
=
d
-
>
findData
.
cFileName
;
return
&
d
-
>
ent
;
}
}
}
#
endif
