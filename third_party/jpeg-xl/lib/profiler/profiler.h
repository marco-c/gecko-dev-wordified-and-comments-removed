#
ifndef
LIB_PROFILER_PROFILER_H_
#
define
LIB_PROFILER_PROFILER_H_
#
ifndef
PROFILER_ENABLED
#
define
PROFILER_ENABLED
0
#
endif
#
if
PROFILER_ENABLED
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
hwy
/
targets
.
h
>
#
include
"
lib
/
jxl
/
base
/
arch_macros
.
h
"
#
include
"
lib
/
jxl
/
base
/
cache_aligned
.
h
"
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
profiler
/
tsc_timer
.
h
"
#
if
JXL_ARCH_X64
&
&
HWY_TARGET
!
=
HWY_SCALAR
#
define
PROFILER_BUFFER
1
#
else
#
define
PROFILER_BUFFER
0
#
endif
namespace
jxl
{
class
Packet
{
public
:
static
constexpr
size_t
kOffsetBits
=
27
;
static
constexpr
uintptr_t
kOffsetBias
=
1ULL
<
<
(
kOffsetBits
-
1
)
;
static
constexpr
size_t
kTimestampBits
=
64
-
kOffsetBits
;
static
constexpr
uint64_t
kTimestampMask
=
(
1ULL
<
<
kTimestampBits
)
-
1
;
static
Packet
Make
(
const
uint64_t
biased_offset
const
uint64_t
timestamp
)
{
JXL_DASSERT
(
biased_offset
<
(
1ULL
<
<
kOffsetBits
)
)
;
Packet
packet
;
packet
.
bits_
=
(
biased_offset
<
<
kTimestampBits
)
+
(
timestamp
&
kTimestampMask
)
;
return
packet
;
}
uint64_t
Timestamp
(
)
const
{
return
bits_
&
kTimestampMask
;
}
uintptr_t
BiasedOffset
(
)
const
{
return
(
bits_
>
>
kTimestampBits
)
;
}
private
:
uint64_t
bits_
;
}
;
static_assert
(
sizeof
(
Packet
)
=
=
8
"
Wrong
Packet
size
"
)
;
class
Results
;
class
ThreadSpecific
{
static
constexpr
size_t
kBufferCapacity
=
CacheAligned
:
:
kCacheLineSize
/
sizeof
(
Packet
)
;
public
:
explicit
ThreadSpecific
(
const
char
*
zone_name
)
;
~
ThreadSpecific
(
)
;
void
ComputeOverhead
(
)
;
void
WriteEntry
(
const
char
*
name
const
uint64_t
timestamp
)
{
const
uint64_t
biased_offset
=
reinterpret_cast
<
uintptr_t
>
(
name
)
-
string_origin_
;
Write
(
Packet
:
:
Make
(
biased_offset
timestamp
)
)
;
}
void
WriteExit
(
const
uint64_t
timestamp
)
{
const
uint64_t
biased_offset
=
Packet
:
:
kOffsetBias
;
Write
(
Packet
:
:
Make
(
biased_offset
timestamp
)
)
;
}
void
AnalyzeRemainingPackets
(
)
;
Results
&
GetResults
(
)
{
return
*
results_
;
}
private
:
void
FlushStorage
(
)
;
#
if
PROFILER_BUFFER
void
FlushBuffer
(
)
;
#
endif
void
Write
(
const
Packet
packet
)
{
#
if
PROFILER_BUFFER
if
(
buffer_size_
=
=
kBufferCapacity
)
{
FlushBuffer
(
)
;
}
buffer_
[
buffer_size_
]
=
packet
;
+
+
buffer_size_
;
#
else
if
(
num_packets_
>
=
max_packets_
)
{
FlushStorage
(
)
;
}
packets_
[
num_packets_
]
=
packet
;
+
+
num_packets_
;
#
endif
}
#
if
PROFILER_BUFFER
Packet
buffer_
[
kBufferCapacity
]
;
size_t
buffer_size_
=
0
;
#
endif
Packet
*
const
JXL_RESTRICT
packets_
;
size_t
num_packets_
;
const
size_t
max_packets_
;
uintptr_t
string_origin_
;
Results
*
results_
;
}
;
class
Zone
{
public
:
JXL_NOINLINE
explicit
Zone
(
const
char
*
name
)
{
JXL_COMPILER_FENCE
;
ThreadSpecific
*
JXL_RESTRICT
thread_specific
=
GetThreadSpecific
(
)
;
if
(
JXL_UNLIKELY
(
thread_specific
=
=
nullptr
)
)
{
thread_specific
=
InitThreadSpecific
(
name
)
;
}
JXL_COMPILER_FENCE
;
const
uint64_t
timestamp
=
TicksBefore
(
)
;
thread_specific
-
>
WriteEntry
(
name
timestamp
)
;
}
JXL_NOINLINE
~
Zone
(
)
{
JXL_COMPILER_FENCE
;
const
uint64_t
timestamp
=
TicksAfter
(
)
;
GetThreadSpecific
(
)
-
>
WriteExit
(
timestamp
)
;
JXL_COMPILER_FENCE
;
}
static
void
PrintResults
(
)
;
private
:
static
ThreadSpecific
*
&
GetThreadSpecific
(
)
{
static
thread_local
ThreadSpecific
*
thread_specific
;
return
thread_specific
;
}
ThreadSpecific
*
InitThreadSpecific
(
const
char
*
zone_name
)
;
}
;
#
define
PROFILER_ZONE
(
name
)
\
JXL_COMPILER_FENCE
;
\
const
:
:
jxl
:
:
Zone
zone
(
"
"
name
)
;
\
JXL_COMPILER_FENCE
#
define
PROFILER_FUNC
\
JXL_COMPILER_FENCE
;
\
const
:
:
jxl
:
:
Zone
zone
(
__func__
)
;
\
JXL_COMPILER_FENCE
#
define
PROFILER_PRINT_RESULTS
:
:
jxl
:
:
Zone
:
:
PrintResults
}
#
else
#
define
PROFILER_ZONE
(
name
)
#
define
PROFILER_FUNC
#
define
PROFILER_PRINT_RESULTS
(
)
#
endif
#
endif
