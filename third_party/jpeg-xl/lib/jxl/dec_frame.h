#
ifndef
LIB_JXL_DEC_FRAME_H_
#
define
LIB_JXL_DEC_FRAME_H_
#
include
<
stdint
.
h
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
base
/
span
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
blending
.
h
"
#
include
"
lib
/
jxl
/
codec_in_out
.
h
"
#
include
"
lib
/
jxl
/
common
.
h
"
#
include
"
lib
/
jxl
/
dec_bit_reader
.
h
"
#
include
"
lib
/
jxl
/
dec_cache
.
h
"
#
include
"
lib
/
jxl
/
dec_modular
.
h
"
#
include
"
lib
/
jxl
/
dec_params
.
h
"
#
include
"
lib
/
jxl
/
frame_header
.
h
"
#
include
"
lib
/
jxl
/
headers
.
h
"
#
include
"
lib
/
jxl
/
image_bundle
.
h
"
namespace
jxl
{
Status
DecodeFrameHeader
(
BitReader
*
JXL_RESTRICT
reader
FrameHeader
*
JXL_RESTRICT
frame_header
)
;
Status
DecodeFrame
(
const
DecompressParams
&
dparams
PassesDecoderState
*
dec_state
ThreadPool
*
JXL_RESTRICT
pool
BitReader
*
JXL_RESTRICT
reader
ImageBundle
*
decoded
const
CodecMetadata
&
metadata
const
SizeConstraints
*
constraints
bool
is_preview
=
false
)
;
Status
SkipFrame
(
const
CodecMetadata
&
metadata
BitReader
*
JXL_RESTRICT
reader
bool
is_preview
=
false
)
;
class
FrameDecoder
{
public
:
FrameDecoder
(
PassesDecoderState
*
dec_state
const
CodecMetadata
&
metadata
ThreadPool
*
pool
)
:
dec_state_
(
dec_state
)
pool_
(
pool
)
frame_header_
(
&
metadata
)
{
}
void
SetFrameSizeLimits
(
const
SizeConstraints
*
constraints
)
{
constraints_
=
constraints
;
}
void
SetRenderSpotcolors
(
bool
rsc
)
{
render_spotcolors_
=
rsc
;
}
Status
InitFrame
(
BitReader
*
JXL_RESTRICT
br
ImageBundle
*
decoded
bool
is_preview
bool
allow_partial_frames
bool
allow_partial_dc_global
bool
output_needed
)
;
struct
SectionInfo
{
BitReader
*
JXL_RESTRICT
br
;
size_t
id
;
}
;
enum
SectionStatus
{
kDone
=
0
kSkipped
=
1
kDuplicate
=
2
kPartial
=
3
}
;
Status
ProcessSections
(
const
SectionInfo
*
sections
size_t
num
SectionStatus
*
section_status
)
;
Status
Flush
(
)
;
Status
FinalizeFrame
(
)
;
int
References
(
)
const
;
static
int
SavedAs
(
const
FrameHeader
&
header
)
;
const
std
:
:
vector
<
uint64_t
>
&
SectionOffsets
(
)
const
{
return
section_offsets_
;
}
const
std
:
:
vector
<
uint32_t
>
&
SectionSizes
(
)
const
{
return
section_sizes_
;
}
size_t
NumSections
(
)
const
{
return
section_sizes_
.
size
(
)
;
}
void
SetMaxPasses
(
size_t
max_passes
)
{
max_passes_
=
max_passes
;
}
const
FrameHeader
&
GetFrameHeader
(
)
const
{
return
frame_header_
;
}
bool
HasDecodedDC
(
)
const
{
return
finalized_dc_
;
}
void
MaybeSetRGB8OutputBuffer
(
uint8_t
*
rgb_output
size_t
stride
bool
is_rgba
bool
undo_orientation
)
const
{
if
(
!
CanDoLowMemoryPath
(
undo_orientation
)
)
return
;
dec_state_
-
>
rgb_output
=
rgb_output
;
dec_state_
-
>
rgb_output_is_rgba
=
is_rgba
;
dec_state_
-
>
rgb_stride
=
stride
;
JXL_ASSERT
(
dec_state_
-
>
pixel_callback
=
=
nullptr
)
;
#
if
!
JXL_HIGH_PRECISION
if
(
decoded_
-
>
metadata
(
)
-
>
xyb_encoded
&
&
dec_state_
-
>
output_encoding_info
.
color_encoding
.
IsSRGB
(
)
&
&
dec_state_
-
>
output_encoding_info
.
all_default_opsin
&
&
HasFastXYBTosRGB8
(
)
&
&
frame_header_
.
needs_color_transform
(
)
)
{
dec_state_
-
>
fast_xyb_srgb8_conversion
=
true
;
}
#
endif
}
void
MaybeSetFloatCallback
(
const
std
:
:
function
<
void
(
const
float
*
pixels
size_t
x
size_t
y
size_t
num_pixels
)
>
&
cb
bool
is_rgba
bool
undo_orientation
)
const
{
if
(
!
CanDoLowMemoryPath
(
undo_orientation
)
)
return
;
dec_state_
-
>
pixel_callback
=
cb
;
dec_state_
-
>
rgb_output_is_rgba
=
is_rgba
;
JXL_ASSERT
(
dec_state_
-
>
rgb_output
=
=
nullptr
)
;
}
bool
HasRGBBuffer
(
)
const
{
return
dec_state_
-
>
rgb_output
!
=
nullptr
|
|
dec_state_
-
>
pixel_callback
!
=
nullptr
;
}
private
:
Status
ProcessDCGlobal
(
BitReader
*
br
)
;
Status
ProcessDCGroup
(
size_t
dc_group_id
BitReader
*
br
)
;
void
FinalizeDC
(
)
;
void
AllocateOutput
(
)
;
Status
ProcessACGlobal
(
BitReader
*
br
)
;
Status
ProcessACGroup
(
size_t
ac_group_id
BitReader
*
JXL_RESTRICT
*
br
size_t
num_passes
size_t
thread
bool
force_draw
bool
dc_only
)
;
void
PrepareStorage
(
size_t
num_threads
size_t
num_tasks
)
{
size_t
storage_size
=
std
:
:
min
(
num_threads
num_tasks
)
;
if
(
storage_size
>
group_dec_caches_
.
size
(
)
)
{
group_dec_caches_
.
resize
(
storage_size
)
;
}
dec_state_
-
>
EnsureStorage
(
storage_size
)
;
use_task_id_
=
num_threads
>
num_tasks
;
}
size_t
GetStorageLocation
(
size_t
thread
size_t
task
)
{
if
(
use_task_id_
)
return
task
;
return
thread
;
}
bool
CanDoLowMemoryPath
(
bool
undo_orientation
)
const
{
if
(
undo_orientation
&
&
decoded_
-
>
metadata
(
)
-
>
GetOrientation
(
)
!
=
Orientation
:
:
kIdentity
)
{
return
false
;
}
if
(
ImageBlender
:
:
NeedsBlending
(
dec_state_
)
)
return
false
;
if
(
frame_header_
.
CanBeReferenced
(
)
)
return
false
;
if
(
render_spotcolors_
&
&
decoded_
-
>
metadata
(
)
-
>
Find
(
ExtraChannel
:
:
kSpotColor
)
)
{
return
false
;
}
if
(
decoded_
-
>
AlphaIsPremultiplied
(
)
)
return
false
;
return
true
;
}
PassesDecoderState
*
dec_state_
;
ThreadPool
*
pool_
;
std
:
:
vector
<
uint64_t
>
section_offsets_
;
std
:
:
vector
<
uint32_t
>
section_sizes_
;
size_t
max_passes_
;
FrameHeader
frame_header_
;
FrameDimensions
frame_dim_
;
ImageBundle
*
decoded_
;
ModularFrameDecoder
modular_frame_decoder_
;
bool
allow_partial_frames_
;
bool
allow_partial_dc_global_
;
bool
render_spotcolors_
=
true
;
std
:
:
vector
<
uint8_t
>
processed_section_
;
std
:
:
vector
<
uint8_t
>
decoded_passes_per_ac_group_
;
std
:
:
vector
<
uint8_t
>
decoded_dc_groups_
;
bool
decoded_dc_global_
;
bool
decoded_ac_global_
;
bool
finalized_dc_
=
true
;
bool
is_finalized_
=
true
;
size_t
num_renders_
=
0
;
bool
allocated_
=
false
;
std
:
:
vector
<
GroupDecCache
>
group_dec_caches_
;
const
SizeConstraints
*
constraints_
=
nullptr
;
bool
use_task_id_
=
false
;
}
;
}
#
endif
