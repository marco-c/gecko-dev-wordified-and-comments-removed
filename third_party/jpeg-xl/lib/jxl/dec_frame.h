#
ifndef
LIB_JXL_DEC_FRAME_H_
#
define
LIB_JXL_DEC_FRAME_H_
#
include
<
stdint
.
h
>
#
include
"
jxl
/
decode
.
h
"
#
include
"
jxl
/
types
.
h
"
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
base
/
span
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
blending
.
h
"
#
include
"
lib
/
jxl
/
codec_in_out
.
h
"
#
include
"
lib
/
jxl
/
common
.
h
"
#
include
"
lib
/
jxl
/
dec_bit_reader
.
h
"
#
include
"
lib
/
jxl
/
dec_cache
.
h
"
#
include
"
lib
/
jxl
/
dec_modular
.
h
"
#
include
"
lib
/
jxl
/
frame_header
.
h
"
#
include
"
lib
/
jxl
/
headers
.
h
"
#
include
"
lib
/
jxl
/
image_bundle
.
h
"
namespace
jxl
{
Status
DecodeFrame
(
PassesDecoderState
*
dec_state
ThreadPool
*
JXL_RESTRICT
pool
const
uint8_t
*
next_in
size_t
avail_in
ImageBundle
*
decoded
const
CodecMetadata
&
metadata
bool
use_slow_rendering_pipeline
=
false
)
;
class
FrameDecoder
{
public
:
FrameDecoder
(
PassesDecoderState
*
dec_state
const
CodecMetadata
&
metadata
ThreadPool
*
pool
bool
use_slow_rendering_pipeline
)
:
dec_state_
(
dec_state
)
pool_
(
pool
)
frame_header_
(
&
metadata
)
use_slow_rendering_pipeline_
(
use_slow_rendering_pipeline
)
{
}
void
SetRenderSpotcolors
(
bool
rsc
)
{
render_spotcolors_
=
rsc
;
}
void
SetCoalescing
(
bool
c
)
{
coalescing_
=
c
;
}
Status
InitFrame
(
BitReader
*
JXL_RESTRICT
br
ImageBundle
*
decoded
bool
is_preview
bool
output_needed
)
;
struct
SectionInfo
{
BitReader
*
JXL_RESTRICT
br
;
size_t
id
;
}
;
struct
TocEntry
{
size_t
size
;
size_t
id
;
}
;
enum
SectionStatus
{
kDone
=
0
kSkipped
=
1
kDuplicate
=
2
kPartial
=
3
}
;
Status
ProcessSections
(
const
SectionInfo
*
sections
size_t
num
SectionStatus
*
section_status
)
;
Status
Flush
(
)
;
Status
FinalizeFrame
(
)
;
int
References
(
)
const
;
static
int
SavedAs
(
const
FrameHeader
&
header
)
;
uint64_t
SumSectionSizes
(
)
const
{
return
section_sizes_sum_
;
}
const
std
:
:
vector
<
TocEntry
>
&
Toc
(
)
const
{
return
toc_
;
}
const
FrameHeader
&
GetFrameHeader
(
)
const
{
return
frame_header_
;
}
bool
HasDecodedDC
(
)
const
{
return
finalized_dc_
;
}
bool
HasDecodedAll
(
)
const
{
return
toc_
.
size
(
)
=
=
num_sections_done_
;
}
size_t
NumCompletePasses
(
)
const
{
return
*
std
:
:
min_element
(
decoded_passes_per_ac_group_
.
begin
(
)
decoded_passes_per_ac_group_
.
end
(
)
)
;
}
;
JxlProgressiveDetail
SetPauseAtProgressive
(
JxlProgressiveDetail
prog_detail
)
{
bool
single_section
=
frame_dim_
.
num_groups
=
=
1
&
&
frame_header_
.
passes
.
num_passes
=
=
1
;
if
(
frame_header_
.
frame_type
!
=
kSkipProgressive
&
&
!
single_section
&
&
decoded_
-
>
metadata
(
)
-
>
extra_channel_info
.
empty
(
)
&
&
frame_header_
.
encoding
=
=
FrameEncoding
:
:
kVarDCT
)
{
progressive_detail_
=
prog_detail
;
}
else
{
progressive_detail_
=
JxlProgressiveDetail
:
:
kFrames
;
}
if
(
progressive_detail_
>
=
JxlProgressiveDetail
:
:
kPasses
)
{
for
(
size_t
i
=
1
;
i
<
frame_header_
.
passes
.
num_passes
;
+
+
i
)
{
passes_to_pause_
.
push_back
(
i
)
;
}
}
else
if
(
progressive_detail_
>
=
JxlProgressiveDetail
:
:
kLastPasses
)
{
for
(
size_t
i
=
0
;
i
<
frame_header_
.
passes
.
num_downsample
;
+
+
i
)
{
passes_to_pause_
.
push_back
(
frame_header_
.
passes
.
last_pass
[
i
]
+
1
)
;
}
std
:
:
sort
(
passes_to_pause_
.
begin
(
)
passes_to_pause_
.
end
(
)
)
;
}
return
progressive_detail_
;
}
size_t
NextNumPassesToPause
(
)
const
{
auto
it
=
std
:
:
upper_bound
(
passes_to_pause_
.
begin
(
)
passes_to_pause_
.
end
(
)
NumCompletePasses
(
)
)
;
return
(
it
!
=
passes_to_pause_
.
end
(
)
?
*
it
:
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
)
;
}
void
MaybeSetUnpremultiplyAlpha
(
bool
unpremul_alpha
)
{
const
jxl
:
:
ExtraChannelInfo
*
alpha
=
decoded_
-
>
metadata
(
)
-
>
Find
(
jxl
:
:
ExtraChannel
:
:
kAlpha
)
;
if
(
alpha
&
&
alpha
-
>
alpha_associated
&
&
unpremul_alpha
)
{
dec_state_
-
>
unpremul_alpha
=
true
;
}
}
void
MaybeSetRGB8OutputBuffer
(
uint8_t
*
rgb_output
size_t
stride
bool
is_rgba
bool
undo_orientation
)
const
{
if
(
!
CanDoLowMemoryPath
(
undo_orientation
)
|
|
dec_state_
-
>
unpremul_alpha
)
{
return
;
}
dec_state_
-
>
rgb_output
=
rgb_output
;
dec_state_
-
>
rgb_output_is_rgba
=
is_rgba
;
dec_state_
-
>
rgb_stride
=
stride
;
JXL_ASSERT
(
!
dec_state_
-
>
pixel_callback
.
IsPresent
(
)
)
;
#
if
!
JXL_HIGH_PRECISION
if
(
decoded_
-
>
metadata
(
)
-
>
xyb_encoded
&
&
dec_state_
-
>
output_encoding_info
.
color_encoding
.
IsSRGB
(
)
&
&
dec_state_
-
>
output_encoding_info
.
all_default_opsin
&
&
dec_state_
-
>
output_encoding_info
.
desired_intensity_target
=
=
dec_state_
-
>
output_encoding_info
.
orig_intensity_target
&
&
HasFastXYBTosRGB8
(
)
&
&
frame_header_
.
needs_color_transform
(
)
)
{
dec_state_
-
>
fast_xyb_srgb8_conversion
=
true
;
}
#
endif
}
void
SetFloatCallback
(
const
PixelCallback
&
pixel_callback
size_t
num_channels
bool
unpremul_alpha
bool
undo_orientation
bool
swap_endianness
)
const
{
dec_state_
-
>
pixel_callback
=
pixel_callback
;
dec_state_
-
>
output_channels
=
num_channels
;
dec_state_
-
>
undo_orientation
=
undo_orientation
?
decoded_
-
>
metadata
(
)
-
>
GetOrientation
(
)
:
Orientation
:
:
kIdentity
;
dec_state_
-
>
swap_endianness
=
swap_endianness
;
JXL_ASSERT
(
dec_state_
-
>
rgb_output
=
=
nullptr
)
;
}
bool
HasRGBBuffer
(
)
const
{
return
dec_state_
-
>
rgb_output
!
=
nullptr
|
|
dec_state_
-
>
pixel_callback
.
IsPresent
(
)
;
}
private
:
Status
ProcessDCGlobal
(
BitReader
*
br
)
;
Status
ProcessDCGroup
(
size_t
dc_group_id
BitReader
*
br
)
;
void
FinalizeDC
(
)
;
Status
AllocateOutput
(
)
;
Status
ProcessACGlobal
(
BitReader
*
br
)
;
Status
ProcessACGroup
(
size_t
ac_group_id
BitReader
*
JXL_RESTRICT
*
br
size_t
num_passes
size_t
thread
bool
force_draw
bool
dc_only
)
;
void
MarkSections
(
const
SectionInfo
*
sections
size_t
num
SectionStatus
*
section_status
)
;
Status
PrepareStorage
(
size_t
num_threads
size_t
num_tasks
)
{
size_t
storage_size
=
std
:
:
min
(
num_threads
num_tasks
)
;
if
(
storage_size
>
group_dec_caches_
.
size
(
)
)
{
group_dec_caches_
.
resize
(
storage_size
)
;
}
use_task_id_
=
num_threads
>
num_tasks
;
bool
use_group_ids
=
(
modular_frame_decoder_
.
UsesFullImage
(
)
&
&
(
frame_header_
.
encoding
=
=
FrameEncoding
:
:
kVarDCT
|
|
(
frame_header_
.
flags
&
FrameHeader
:
:
kNoise
)
)
)
;
if
(
dec_state_
-
>
render_pipeline
)
{
JXL_RETURN_IF_ERROR
(
dec_state_
-
>
render_pipeline
-
>
PrepareForThreads
(
storage_size
use_group_ids
)
)
;
}
return
true
;
}
size_t
GetStorageLocation
(
size_t
thread
size_t
task
)
{
if
(
use_task_id_
)
return
task
;
return
thread
;
}
bool
CanDoLowMemoryPath
(
bool
undo_orientation
)
const
{
return
!
(
undo_orientation
&
&
decoded_
-
>
metadata
(
)
-
>
GetOrientation
(
)
!
=
Orientation
:
:
kIdentity
)
;
}
PassesDecoderState
*
dec_state_
;
ThreadPool
*
pool_
;
std
:
:
vector
<
TocEntry
>
toc_
;
uint64_t
section_sizes_sum_
;
FrameHeader
frame_header_
;
FrameDimensions
frame_dim_
;
ImageBundle
*
decoded_
;
ModularFrameDecoder
modular_frame_decoder_
;
bool
render_spotcolors_
=
true
;
bool
coalescing_
=
true
;
std
:
:
vector
<
uint8_t
>
processed_section_
;
std
:
:
vector
<
uint8_t
>
decoded_passes_per_ac_group_
;
std
:
:
vector
<
uint8_t
>
decoded_dc_groups_
;
bool
decoded_dc_global_
;
bool
decoded_ac_global_
;
bool
HasEverything
(
)
const
;
bool
finalized_dc_
=
true
;
size_t
num_sections_done_
=
0
;
bool
is_finalized_
=
true
;
bool
allocated_
=
false
;
std
:
:
vector
<
GroupDecCache
>
group_dec_caches_
;
bool
use_task_id_
=
false
;
bool
use_slow_rendering_pipeline_
;
JxlProgressiveDetail
progressive_detail_
=
kFrames
;
std
:
:
vector
<
int
>
passes_to_pause_
;
}
;
}
#
endif
