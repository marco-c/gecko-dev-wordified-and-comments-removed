#
ifndef
LIB_JXL_ANS_COMMON_H_
#
define
LIB_JXL_ANS_COMMON_H_
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
hwy
/
cache_control
.
h
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
ans_params
.
h
"
#
include
"
lib
/
jxl
/
base
/
byte_order
.
h
"
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
namespace
jxl
{
static
JXL_INLINE
uint32_t
GetPopulationCountPrecision
(
uint32_t
logcount
uint32_t
shift
)
{
int32_t
r
=
std
:
:
min
<
int
>
(
logcount
int
(
shift
)
-
int
(
(
ANS_LOG_TAB_SIZE
-
logcount
)
>
>
1
)
)
;
if
(
r
<
0
)
return
0
;
return
r
;
}
std
:
:
vector
<
int32_t
>
CreateFlatHistogram
(
int
length
int
total_count
)
;
struct
AliasTable
{
struct
Symbol
{
size_t
value
;
size_t
offset
;
size_t
freq
;
}
;
#
pragma
pack
(
push
1
)
struct
Entry
{
uint8_t
cutoff
;
uint8_t
right_value
;
uint16_t
freq0
;
uint16_t
offsets1
;
uint16_t
freq1_xor_freq0
;
}
;
#
pragma
pack
(
pop
)
static
JXL_INLINE
Symbol
Lookup
(
const
Entry
*
JXL_RESTRICT
table
size_t
value
size_t
log_entry_size
size_t
entry_size_minus_1
)
{
const
size_t
i
=
value
>
>
log_entry_size
;
const
size_t
pos
=
value
&
entry_size_minus_1
;
#
if
JXL_BYTE_ORDER_LITTLE
uint64_t
entry
;
memcpy
(
&
entry
&
table
[
i
]
.
cutoff
sizeof
(
entry
)
)
;
const
size_t
cutoff
=
entry
&
0xFF
;
const
size_t
right_value
=
(
entry
>
>
8
)
&
0xFF
;
const
size_t
freq0
=
(
entry
>
>
16
)
&
0xFFFF
;
#
else
const
size_t
cutoff
=
table
[
i
]
.
cutoff
;
const
size_t
right_value
=
table
[
i
]
.
right_value
;
const
size_t
freq0
=
table
[
i
]
.
freq0
;
#
endif
const
bool
greater
=
pos
>
=
cutoff
;
#
if
JXL_BYTE_ORDER_LITTLE
const
uint64_t
conditional
=
greater
?
entry
:
0
;
const
size_t
offsets1_or_0
=
(
conditional
>
>
32
)
&
0xFFFF
;
const
size_t
freq1_xor_freq0_or_0
=
conditional
>
>
48
;
#
else
const
size_t
offsets1_or_0
=
greater
?
table
[
i
]
.
offsets1
:
0
;
const
size_t
freq1_xor_freq0_or_0
=
greater
?
table
[
i
]
.
freq1_xor_freq0
:
0
;
#
endif
Symbol
s
;
s
.
value
=
greater
?
right_value
:
i
;
s
.
offset
=
offsets1_or_0
+
pos
;
s
.
freq
=
freq0
^
freq1_xor_freq0_or_0
;
return
s
;
}
static
HWY_INLINE
void
Prefetch
(
const
Entry
*
JXL_RESTRICT
table
size_t
value
size_t
log_entry_size
)
{
const
size_t
i
=
value
>
>
log_entry_size
;
hwy
:
:
Prefetch
(
table
+
i
)
;
}
}
;
void
InitAliasTable
(
std
:
:
vector
<
int32_t
>
distribution
uint32_t
range
size_t
log_alpha_size
AliasTable
:
:
Entry
*
JXL_RESTRICT
a
)
;
}
#
endif
