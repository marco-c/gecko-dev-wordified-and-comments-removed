#
ifndef
LIB_JXL_ENC_CHROMA_FROM_LUMA_H_
#
define
LIB_JXL_ENC_CHROMA_FROM_LUMA_H_
#
include
<
jxl
/
memory_manager
.
h
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
hwy
/
aligned_allocator
.
h
>
#
include
"
lib
/
jxl
/
ac_strategy
.
h
"
#
include
"
lib
/
jxl
/
base
/
rect
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
chroma_from_luma
.
h
"
#
include
"
lib
/
jxl
/
enc_bit_writer
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
#
include
"
lib
/
jxl
/
quant_weights
.
h
"
#
include
"
lib
/
jxl
/
simd_util
.
h
"
namespace
jxl
{
struct
AuxOut
;
enum
class
LayerType
:
uint8_t
;
class
Quantizer
;
void
ColorCorrelationEncodeDC
(
const
ColorCorrelation
&
color_correlation
BitWriter
*
writer
LayerType
layer
AuxOut
*
aux_out
)
;
struct
CfLHeuristics
{
Status
Init
(
JxlMemoryManager
*
memory_manager
const
Rect
&
rect
)
;
void
PrepareForThreads
(
size_t
num_threads
)
{
mem
=
hwy
:
:
AllocateAligned
<
float
>
(
num_threads
*
ItemsPerThread
(
)
)
;
}
void
ComputeTile
(
const
Rect
&
r
const
Image3F
&
opsin
const
Rect
&
opsin_rect
const
DequantMatrices
&
dequant
const
AcStrategyImage
*
ac_strategy
const
ImageI
*
raw_quant_field
const
Quantizer
*
quantizer
bool
fast
size_t
thread
ColorCorrelationMap
*
cmap
)
;
ImageF
dc_values
;
hwy
:
:
AlignedFreeUniquePtr
<
float
[
]
>
mem
;
static
size_t
ItemsPerThread
(
)
{
const
size_t
dct_scratch_size
=
3
*
(
MaxVectorSize
(
)
/
sizeof
(
float
)
)
*
AcStrategy
:
:
kMaxBlockDim
;
return
AcStrategy
:
:
kMaxCoeffArea
*
3
+
kColorTileDim
*
kColorTileDim
*
4
+
AcStrategy
:
:
kMaxCoeffArea
*
2
+
dct_scratch_size
;
}
}
;
}
#
endif
