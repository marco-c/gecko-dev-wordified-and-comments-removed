#
ifndef
LIB_JXL_BASE_DATA_PARALLEL_H_
#
define
LIB_JXL_BASE_DATA_PARALLEL_H_
#
include
<
jxl
/
parallel_runner
.
h
>
#
include
<
atomic
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
if
JXL_COMPILER_MSVC
#
pragma
warning
(
disable
:
4180
)
#
endif
namespace
jxl
{
class
ThreadPool
{
public
:
ThreadPool
(
JxlParallelRunner
runner
void
*
runner_opaque
)
:
runner_
(
runner
)
runner_opaque_
(
runner
?
runner_opaque
:
static_cast
<
void
*
>
(
this
)
)
{
}
ThreadPool
(
const
ThreadPool
&
)
=
delete
;
ThreadPool
&
operator
&
(
const
ThreadPool
&
)
=
delete
;
JxlParallelRunner
runner
(
)
const
{
return
runner_
;
}
void
*
runner_opaque
(
)
const
{
return
runner_opaque_
;
}
template
<
class
InitFunc
class
DataFunc
>
Status
Run
(
uint32_t
begin
uint32_t
end
const
InitFunc
&
init_func
const
DataFunc
&
data_func
const
char
*
caller
)
{
JXL_ENSURE
(
begin
<
=
end
)
;
if
(
begin
=
=
end
)
return
true
;
RunCallState
<
InitFunc
DataFunc
>
call_state
(
init_func
data_func
)
;
if
(
!
runner_
)
{
void
*
jpegxl_opaque
=
static_cast
<
void
*
>
(
&
call_state
)
;
if
(
call_state
.
CallInitFunc
(
jpegxl_opaque
1
)
!
=
JXL_PARALLEL_RET_SUCCESS
)
{
return
JXL_FAILURE
(
"
Failed
to
initialize
thread
"
)
;
}
for
(
uint32_t
i
=
begin
;
i
<
end
;
i
+
+
)
{
call_state
.
CallDataFunc
(
jpegxl_opaque
i
0
)
;
}
if
(
call_state
.
HasError
(
)
)
{
return
JXL_FAILURE
(
"
[
%
s
]
failed
"
caller
)
;
}
return
true
;
}
JxlParallelRetCode
ret
=
(
*
runner_
)
(
runner_opaque_
static_cast
<
void
*
>
(
&
call_state
)
&
call_state
.
CallInitFunc
&
call_state
.
CallDataFunc
begin
end
)
;
if
(
ret
!
=
JXL_PARALLEL_RET_SUCCESS
|
|
call_state
.
HasError
(
)
)
{
return
JXL_FAILURE
(
"
[
%
s
]
failed
"
caller
)
;
}
return
true
;
}
static
Status
NoInit
(
size_t
num_threads
)
{
return
true
;
}
private
:
template
<
class
InitFunc
class
DataFunc
>
class
RunCallState
final
{
public
:
RunCallState
(
const
InitFunc
&
init_func
const
DataFunc
&
data_func
)
:
init_func_
(
init_func
)
data_func_
(
data_func
)
{
}
static
int
CallInitFunc
(
void
*
jpegxl_opaque
size_t
num_threads
)
{
auto
*
self
=
static_cast
<
RunCallState
<
InitFunc
DataFunc
>
*
>
(
jpegxl_opaque
)
;
if
(
!
self
-
>
init_func_
(
num_threads
)
)
{
self
-
>
has_error_
=
true
;
return
JXL_PARALLEL_RET_RUNNER_ERROR
;
}
return
JXL_PARALLEL_RET_SUCCESS
;
}
static
void
CallDataFunc
(
void
*
jpegxl_opaque
uint32_t
value
size_t
thread_id
)
{
auto
*
self
=
static_cast
<
RunCallState
<
InitFunc
DataFunc
>
*
>
(
jpegxl_opaque
)
;
if
(
self
-
>
has_error_
)
return
;
if
(
!
self
-
>
data_func_
(
value
thread_id
)
)
{
self
-
>
has_error_
=
true
;
}
}
bool
HasError
(
)
const
{
return
has_error_
;
}
private
:
const
InitFunc
&
init_func_
;
const
DataFunc
&
data_func_
;
std
:
:
atomic
<
bool
>
has_error_
{
false
}
;
}
;
const
JxlParallelRunner
runner_
;
void
*
const
runner_opaque_
;
}
;
template
<
class
InitFunc
class
DataFunc
>
Status
RunOnPool
(
ThreadPool
*
pool
const
uint32_t
begin
const
uint32_t
end
const
InitFunc
&
init_func
const
DataFunc
&
data_func
const
char
*
caller
)
{
if
(
pool
=
=
nullptr
)
{
ThreadPool
default_pool
(
nullptr
nullptr
)
;
return
default_pool
.
Run
(
begin
end
init_func
data_func
caller
)
;
}
else
{
return
pool
-
>
Run
(
begin
end
init_func
data_func
caller
)
;
}
}
}
#
if
JXL_COMPILER_MSVC
#
pragma
warning
(
default
:
4180
)
#
endif
#
endif
