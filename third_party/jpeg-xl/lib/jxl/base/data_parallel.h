#
ifndef
LIB_JXL_BASE_DATA_PARALLEL_H_
#
define
LIB_JXL_BASE_DATA_PARALLEL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jxl
/
parallel_runner
.
h
"
#
include
"
lib
/
jxl
/
base
/
bits
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
namespace
jxl
{
class
ThreadPool
{
public
:
struct
SkipInit
{
}
;
ThreadPool
(
JxlParallelRunner
runner
void
*
runner_opaque
)
:
runner_
(
runner
?
runner
:
&
ThreadPool
:
:
SequentialRunnerStatic
)
runner_opaque_
(
runner
?
runner_opaque
:
static_cast
<
void
*
>
(
this
)
)
{
}
ThreadPool
(
const
ThreadPool
&
)
=
delete
;
ThreadPool
&
operator
&
(
const
ThreadPool
&
)
=
delete
;
template
<
class
InitFunc
class
DataFunc
>
Status
Run
(
uint32_t
begin
uint32_t
end
const
InitFunc
&
init_func
const
DataFunc
&
data_func
const
char
*
caller
=
"
"
)
{
JXL_ASSERT
(
begin
<
=
end
)
;
if
(
begin
=
=
end
)
return
true
;
RunCallState
<
InitFunc
DataFunc
>
call_state
(
init_func
data_func
)
;
return
(
*
runner_
)
(
runner_opaque_
static_cast
<
void
*
>
(
&
call_state
)
&
call_state
.
CallInitFunc
&
call_state
.
CallDataFunc
begin
end
)
=
=
0
;
}
template
<
class
DataFunc
>
bool
Run
(
uint32_t
begin
uint32_t
end
const
SkipInit
const
DataFunc
&
data_func
const
char
*
caller
=
"
"
)
{
return
Run
(
begin
end
ReturnTrueInit
data_func
caller
)
;
}
private
:
static
Status
ReturnTrueInit
(
size_t
num_threads
)
{
return
true
;
}
template
<
class
InitFunc
class
DataFunc
>
class
RunCallState
final
{
public
:
RunCallState
(
const
InitFunc
&
init_func
const
DataFunc
&
data_func
)
:
init_func_
(
init_func
)
data_func_
(
data_func
)
{
}
static
int
CallInitFunc
(
void
*
jpegxl_opaque
size_t
num_threads
)
{
const
auto
*
self
=
static_cast
<
RunCallState
<
InitFunc
DataFunc
>
*
>
(
jpegxl_opaque
)
;
return
self
-
>
init_func_
(
num_threads
)
?
0
:
-
1
;
}
static
void
CallDataFunc
(
void
*
jpegxl_opaque
uint32_t
value
size_t
thread_id
)
{
const
auto
*
self
=
static_cast
<
RunCallState
<
InitFunc
DataFunc
>
*
>
(
jpegxl_opaque
)
;
return
self
-
>
data_func_
(
value
thread_id
)
;
}
private
:
const
InitFunc
&
init_func_
;
const
DataFunc
&
data_func_
;
}
;
static
JxlParallelRetCode
SequentialRunnerStatic
(
void
*
runner_opaque
void
*
jpegxl_opaque
JxlParallelRunInit
init
JxlParallelRunFunction
func
uint32_t
start_range
uint32_t
end_range
)
;
const
JxlParallelRunner
runner_
;
void
*
const
runner_opaque_
;
}
;
void
TraceRunBegin
(
const
char
*
caller
double
*
t0
)
;
void
TraceRunEnd
(
const
char
*
caller
double
t0
)
;
template
<
class
InitFunc
class
DataFunc
>
bool
RunOnPool
(
ThreadPool
*
pool
const
uint32_t
begin
const
uint32_t
end
const
InitFunc
&
init_func
const
DataFunc
&
data_func
const
char
*
caller
)
{
Status
ret
=
true
;
double
t0
;
TraceRunBegin
(
caller
&
t0
)
;
if
(
pool
=
=
nullptr
)
{
ThreadPool
default_pool
(
nullptr
nullptr
)
;
ret
=
default_pool
.
Run
(
begin
end
init_func
data_func
caller
)
;
}
else
{
ret
=
pool
-
>
Run
(
begin
end
init_func
data_func
caller
)
;
}
TraceRunEnd
(
caller
t0
)
;
return
ret
;
}
class
Divider
{
public
:
explicit
Divider
(
const
uint32_t
d
)
:
shift_
(
FloorLog2Nonzero
(
d
)
)
{
JXL_ASSERT
(
(
d
&
(
d
-
1
)
)
!
=
0
)
;
const
uint64_t
next_pow2
=
1ULL
<
<
(
shift_
+
1
)
;
mul_
=
(
(
next_pow2
-
d
)
<
<
32
)
/
d
+
1
;
}
inline
uint32_t
operator
(
)
(
const
uint32_t
n
)
const
{
const
uint32_t
hi
=
(
uint64_t
(
mul_
)
*
n
)
>
>
32
;
return
(
hi
+
(
(
n
-
hi
)
>
>
1
)
)
>
>
shift_
;
}
private
:
uint32_t
mul_
;
const
int
shift_
;
}
;
}
#
endif
