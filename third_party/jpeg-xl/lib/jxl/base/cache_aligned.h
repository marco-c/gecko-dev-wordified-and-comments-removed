#
ifndef
LIB_JXL_BASE_CACHE_ALIGNED_H_
#
define
LIB_JXL_BASE_CACHE_ALIGNED_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
memory
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
namespace
jxl
{
class
CacheAligned
{
public
:
static
void
PrintStats
(
)
;
static
constexpr
size_t
kPointerSize
=
sizeof
(
void
*
)
;
static
constexpr
size_t
kCacheLineSize
=
64
;
static
constexpr
size_t
kAlignment
=
2
*
kCacheLineSize
;
static
constexpr
size_t
kAlias
=
2048
;
static
size_t
NextOffset
(
)
;
static
void
*
Allocate
(
size_t
payload_size
size_t
offset
)
;
static
void
*
Allocate
(
const
size_t
payload_size
)
{
return
Allocate
(
payload_size
NextOffset
(
)
)
;
}
static
void
Free
(
const
void
*
aligned_pointer
)
;
}
;
struct
CacheAlignedDeleter
{
void
operator
(
)
(
uint8_t
*
aligned_pointer
)
const
{
return
CacheAligned
:
:
Free
(
aligned_pointer
)
;
}
}
;
using
CacheAlignedUniquePtr
=
std
:
:
unique_ptr
<
uint8_t
[
]
CacheAlignedDeleter
>
;
static
inline
CacheAlignedUniquePtr
AllocateArray
(
const
size_t
bytes
)
{
return
CacheAlignedUniquePtr
(
static_cast
<
uint8_t
*
>
(
CacheAligned
:
:
Allocate
(
bytes
)
)
CacheAlignedDeleter
(
)
)
;
}
static
inline
CacheAlignedUniquePtr
AllocateArray
(
const
size_t
bytes
const
size_t
offset
)
{
return
CacheAlignedUniquePtr
(
static_cast
<
uint8_t
*
>
(
CacheAligned
:
:
Allocate
(
bytes
offset
)
)
CacheAlignedDeleter
(
)
)
;
}
}
#
endif
