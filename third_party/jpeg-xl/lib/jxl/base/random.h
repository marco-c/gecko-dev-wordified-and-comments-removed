#
ifndef
LIB_JXL_BASE_RANDOM_
#
define
LIB_JXL_BASE_RANDOM_
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
namespace
jxl
{
struct
Rng
{
explicit
Rng
(
size_t
seed
)
:
s
{
0x94D049BB133111EBull
0xBF58476D1CE4E5B9ull
+
seed
}
{
}
uint64_t
operator
(
)
(
)
{
uint64_t
s1
=
s
[
0
]
;
const
uint64_t
s0
=
s
[
1
]
;
const
uint64_t
bits
=
s1
+
s0
;
s
[
0
]
=
s0
;
s1
^
=
s1
<
<
23
;
s1
^
=
s0
^
(
s1
>
>
18
)
^
(
s0
>
>
5
)
;
s
[
1
]
=
s1
;
return
bits
;
}
int64_t
UniformI
(
int64_t
begin
int64_t
end
)
{
JXL_DASSERT
(
end
>
begin
)
;
return
static_cast
<
int64_t
>
(
(
*
this
)
(
)
%
static_cast
<
uint64_t
>
(
end
-
begin
)
)
+
begin
;
}
uint64_t
UniformU
(
uint64_t
begin
uint64_t
end
)
{
JXL_DASSERT
(
end
>
begin
)
;
return
(
*
this
)
(
)
%
(
end
-
begin
)
+
begin
;
}
float
UniformF
(
float
begin
float
end
)
{
float
f
;
uint32_t
u
=
(
(
*
this
)
(
)
>
>
(
64
-
23
)
)
|
0x3F800000
;
static_assert
(
sizeof
(
f
)
=
=
sizeof
(
u
)
"
Float
and
U32
must
have
the
same
size
"
)
;
memcpy
(
&
f
&
u
sizeof
(
f
)
)
;
return
(
end
-
begin
)
*
(
f
-
1
.
0f
)
+
begin
;
}
bool
Bernoulli
(
float
p
)
{
return
UniformF
(
0
1
)
<
p
;
}
struct
GeometricDistribution
{
explicit
GeometricDistribution
(
float
p
)
;
private
:
float
inv_log_1mp
;
friend
struct
Rng
;
}
;
uint32_t
Geometric
(
const
GeometricDistribution
&
dist
)
;
template
<
typename
T
>
void
Shuffle
(
T
*
t
size_t
n
)
{
for
(
size_t
i
=
0
;
i
+
1
<
n
;
i
+
+
)
{
size_t
a
=
UniformU
(
i
n
)
;
std
:
:
swap
(
t
[
a
]
t
[
i
]
)
;
}
}
private
:
uint64_t
s
[
2
]
;
}
;
}
#
endif
