#
ifndef
LIB_JXL_BASE_COMMON_H_
#
define
LIB_JXL_BASE_COMMON_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstdio
>
#
include
<
memory
>
#
include
<
string
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
namespace
jxl
{
constexpr
size_t
kBitsPerByte
=
8
;
constexpr
inline
size_t
RoundUpBitsToByteMultiple
(
size_t
bits
)
{
return
(
bits
+
7
)
&
~
size_t
(
7
)
;
}
constexpr
inline
size_t
RoundUpToBlockDim
(
size_t
dim
)
{
return
(
dim
+
7
)
&
~
size_t
(
7
)
;
}
static
inline
bool
JXL_MAYBE_UNUSED
SafeAdd
(
const
uint64_t
a
const
uint64_t
b
uint64_t
&
sum
)
{
sum
=
a
+
b
;
return
sum
>
=
a
;
}
template
<
typename
T1
typename
T2
>
constexpr
inline
T1
DivCeil
(
T1
a
T2
b
)
{
return
(
a
+
b
-
1
)
/
b
;
}
constexpr
inline
size_t
RoundUpTo
(
size_t
what
size_t
align
)
{
return
DivCeil
(
what
align
)
*
align
;
}
constexpr
double
kPi
=
3
.
14159265358979323846264338327950288
;
static
constexpr
float
kDefaultIntensityTarget
=
255
;
template
<
typename
T
>
constexpr
T
Pi
(
T
multiplier
)
{
return
static_cast
<
T
>
(
multiplier
*
kPi
)
;
}
#
if
__cplusplus
<
201402L
template
<
typename
T
typename
.
.
.
Args
>
std
:
:
unique_ptr
<
T
>
make_unique
(
Args
&
&
.
.
.
args
)
{
return
std
:
:
unique_ptr
<
T
>
(
new
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
#
else
using
std
:
:
make_unique
;
#
endif
template
<
typename
T
>
JXL_INLINE
T
Clamp1
(
T
val
T
low
T
hi
)
{
return
val
<
low
?
low
:
val
>
hi
?
hi
:
val
;
}
template
<
typename
T
>
std
:
:
string
ToString
(
T
n
)
{
char
data
[
32
]
=
{
}
;
if
(
T
(
0
.
1
)
!
=
T
(
0
)
)
{
snprintf
(
data
sizeof
(
data
)
"
%
g
"
static_cast
<
double
>
(
n
)
)
;
}
else
if
(
T
(
-
1
)
>
T
(
0
)
)
{
snprintf
(
data
sizeof
(
data
)
"
%
llu
"
static_cast
<
unsigned
long
long
>
(
n
)
)
;
}
else
{
snprintf
(
data
sizeof
(
data
)
"
%
lld
"
static_cast
<
long
long
>
(
n
)
)
;
}
return
data
;
}
}
#
endif
