#
include
"
lib
/
jxl
/
base
/
profiler
.
h
"
#
if
JXL_PROFILER_ENABLED
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
atomic
>
#
include
<
cinttypes
>
#
include
<
hwy
/
cache_control
.
h
>
#
include
<
limits
>
#
include
<
new
>
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
lib
/
jxl
/
base
/
profiler
.
cc
"
#
include
<
hwy
/
foreach_target
.
h
>
#
include
<
hwy
/
highway
.
h
>
HWY_BEFORE_NAMESPACE
(
)
;
namespace
jxl
{
namespace
profiler
{
namespace
HWY_NAMESPACE
{
void
StreamCacheLine
(
const
Packet
*
HWY_RESTRICT
from
Packet
*
HWY_RESTRICT
to
)
{
#
if
HWY_TARGET
=
=
HWY_SCALAR
hwy
:
:
CopyBytes
<
64
>
(
from
to
)
;
#
else
const
HWY_CAPPED
(
uint64_t
2
)
d
;
HWY_FENCE
;
const
uint64_t
*
HWY_RESTRICT
from64
=
reinterpret_cast
<
const
uint64_t
*
>
(
from
)
;
const
auto
v0
=
Load
(
d
from64
+
0
)
;
const
auto
v1
=
Load
(
d
from64
+
2
)
;
const
auto
v2
=
Load
(
d
from64
+
4
)
;
const
auto
v3
=
Load
(
d
from64
+
6
)
;
HWY_FENCE
;
uint64_t
*
HWY_RESTRICT
to64
=
reinterpret_cast
<
uint64_t
*
>
(
to
)
;
Stream
(
v0
d
to64
+
0
)
;
Stream
(
v1
d
to64
+
2
)
;
Stream
(
v2
d
to64
+
4
)
;
Stream
(
v3
d
to64
+
6
)
;
HWY_FENCE
;
#
endif
}
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
jxl
{
namespace
profiler
{
HWY_EXPORT
(
StreamCacheLine
)
;
namespace
{
#
ifndef
PROFILER_THREAD_STORAGE
#
define
PROFILER_THREAD_STORAGE
32ULL
#
endif
#
define
PROFILER_PRINT_OVERHEAD
0
constexpr
size_t
kMaxDepth
=
64
;
constexpr
size_t
kMaxZones
=
256
;
struct
ActiveZone
{
const
char
*
name
;
uint64_t
entry_timestamp
;
uint64_t
child_total
;
}
;
struct
ZoneTotals
{
uint64_t
total_duration
;
const
char
*
name
;
uint64_t
num_calls
;
}
;
template
<
typename
T
>
inline
T
ClampedSubtract
(
const
T
minuend
const
T
subtrahend
)
{
if
(
subtrahend
>
minuend
)
{
return
0
;
}
return
minuend
-
subtrahend
;
}
}
class
Results
{
public
:
Results
(
)
{
memset
(
zones_
0
sizeof
(
zones_
)
)
;
}
uint64_t
ZoneDuration
(
const
Packet
*
packets
)
{
HWY_ASSERT
(
depth_
=
=
0
)
;
HWY_ASSERT
(
num_zones_
=
=
0
)
;
AnalyzePackets
(
packets
2
)
;
const
uint64_t
duration
=
zones_
[
0
]
.
total_duration
;
zones_
[
0
]
.
num_calls
=
0
;
zones_
[
0
]
.
total_duration
=
0
;
HWY_ASSERT
(
depth_
=
=
0
)
;
num_zones_
=
0
;
return
duration
;
}
void
SetSelfOverhead
(
const
uint64_t
self_overhead
)
{
self_overhead_
=
self_overhead
;
}
void
SetChildOverhead
(
const
uint64_t
child_overhead
)
{
child_overhead_
=
child_overhead
;
}
void
AnalyzePackets
(
const
Packet
*
HWY_RESTRICT
packets
const
size_t
num_packets
)
{
hwy
:
:
FlushStream
(
)
;
const
uint64_t
t0
=
TicksBefore
(
)
;
for
(
size_t
i
=
0
;
i
<
num_packets
;
+
+
i
)
{
const
uint64_t
timestamp
=
packets
[
i
]
.
timestamp
;
if
(
packets
[
i
]
.
name
!
=
nullptr
)
{
HWY_ASSERT
(
depth_
<
kMaxDepth
)
;
zone_stack_
[
depth_
]
.
name
=
packets
[
i
]
.
name
;
zone_stack_
[
depth_
]
.
entry_timestamp
=
timestamp
;
zone_stack_
[
depth_
]
.
child_total
=
0
;
+
+
depth_
;
continue
;
}
HWY_ASSERT
(
depth_
!
=
0
)
;
const
ActiveZone
&
active
=
zone_stack_
[
depth_
-
1
]
;
const
uint64_t
duration
=
timestamp
-
active
.
entry_timestamp
;
const
uint64_t
self_duration
=
ClampedSubtract
(
duration
self_overhead_
+
child_overhead_
+
active
.
child_total
)
;
UpdateOrAdd
(
active
.
name
1
self_duration
)
;
-
-
depth_
;
if
(
depth_
!
=
0
)
{
zone_stack_
[
depth_
-
1
]
.
child_total
+
=
duration
+
child_overhead_
;
}
}
const
uint64_t
t1
=
TicksAfter
(
)
;
analyze_elapsed_
+
=
t1
-
t0
;
}
void
Assimilate
(
const
Results
&
other
)
{
const
uint64_t
t0
=
TicksBefore
(
)
;
HWY_ASSERT
(
depth_
=
=
0
)
;
HWY_ASSERT
(
other
.
depth_
=
=
0
)
;
for
(
size_t
i
=
0
;
i
<
other
.
num_zones_
;
+
+
i
)
{
const
ZoneTotals
&
zone
=
other
.
zones_
[
i
]
;
UpdateOrAdd
(
zone
.
name
zone
.
num_calls
zone
.
total_duration
)
;
}
const
uint64_t
t1
=
TicksAfter
(
)
;
analyze_elapsed_
+
=
t1
-
t0
+
other
.
analyze_elapsed_
;
}
void
Print
(
)
{
const
uint64_t
t0
=
TicksBefore
(
)
;
MergeDuplicates
(
)
;
std
:
:
sort
(
zones_
zones_
+
num_zones_
[
]
(
const
ZoneTotals
&
r1
const
ZoneTotals
&
r2
)
{
return
r1
.
total_duration
>
r2
.
total_duration
;
}
)
;
uint64_t
total_visible_duration
=
0
;
for
(
size_t
i
=
0
;
i
<
num_zones_
;
+
+
i
)
{
const
ZoneTotals
&
r
=
zones_
[
i
]
;
if
(
r
.
name
[
0
]
!
=
'
'
)
{
total_visible_duration
+
=
r
.
total_duration
;
printf
(
"
%
-
40s
:
%
10
"
PRIu64
"
x
%
15
"
PRIu64
"
=
%
15
"
PRIu64
"
\
n
"
r
.
name
r
.
num_calls
r
.
total_duration
/
r
.
num_calls
r
.
total_duration
)
;
}
}
const
uint64_t
t1
=
TicksAfter
(
)
;
analyze_elapsed_
+
=
t1
-
t0
;
printf
(
"
Total
clocks
during
analysis
:
%
"
PRIu64
"
\
n
"
analyze_elapsed_
)
;
printf
(
"
Total
clocks
measured
:
%
"
PRIu64
"
\
n
"
total_visible_duration
)
;
}
void
Reset
(
)
{
analyze_elapsed_
=
0
;
HWY_ASSERT
(
depth_
=
=
0
)
;
num_zones_
=
0
;
memset
(
zone_stack_
0
sizeof
(
zone_stack_
)
)
;
memset
(
zones_
0
sizeof
(
zones_
)
)
;
}
private
:
void
UpdateOrAdd
(
const
char
*
name
const
uint64_t
num_calls
const
uint64_t
duration
)
{
if
(
zones_
[
0
]
.
name
=
=
name
)
{
zones_
[
0
]
.
total_duration
+
=
duration
;
zones_
[
0
]
.
num_calls
+
=
num_calls
;
return
;
}
for
(
size_t
i
=
1
;
i
<
num_zones_
;
+
+
i
)
{
if
(
zones_
[
i
]
.
name
=
=
name
)
{
zones_
[
i
]
.
total_duration
+
=
duration
;
zones_
[
i
]
.
num_calls
+
=
num_calls
;
std
:
:
swap
(
zones_
[
i
-
1
]
zones_
[
i
]
)
;
return
;
}
}
HWY_ASSERT
(
num_zones_
<
kMaxZones
)
;
ZoneTotals
*
HWY_RESTRICT
zone
=
zones_
+
num_zones_
;
zone
-
>
name
=
name
;
zone
-
>
num_calls
=
num_calls
;
zone
-
>
total_duration
=
duration
;
+
+
num_zones_
;
}
void
MergeDuplicates
(
)
{
for
(
size_t
i
=
0
;
i
<
num_zones_
;
+
+
i
)
{
for
(
size_t
j
=
i
+
1
;
j
<
num_zones_
;
)
{
if
(
!
strcmp
(
zones_
[
i
]
.
name
zones_
[
j
]
.
name
)
)
{
zones_
[
i
]
.
num_calls
+
=
zones_
[
j
]
.
num_calls
;
zones_
[
i
]
.
total_duration
+
=
zones_
[
j
]
.
total_duration
;
zones_
[
j
]
=
zones_
[
-
-
num_zones_
]
;
}
else
{
+
+
j
;
}
}
}
}
uint64_t
analyze_elapsed_
=
0
;
uint64_t
self_overhead_
=
0
;
uint64_t
child_overhead_
=
0
;
size_t
depth_
=
0
;
size_t
num_zones_
=
0
;
alignas
(
64
)
ActiveZone
zone_stack_
[
kMaxDepth
]
;
alignas
(
64
)
ZoneTotals
zones_
[
kMaxZones
]
;
}
;
ThreadSpecific
:
:
ThreadSpecific
(
)
:
max_packets_
(
PROFILER_THREAD_STORAGE
<
<
16
)
packets_
(
hwy
:
:
AllocateAligned
<
Packet
>
(
max_packets_
)
)
num_packets_
(
0
)
results_
(
hwy
:
:
MakeUniqueAligned
<
Results
>
(
)
)
{
}
ThreadSpecific
:
:
~
ThreadSpecific
(
)
{
}
void
ThreadSpecific
:
:
FlushBuffer
(
)
{
if
(
num_packets_
+
kBufferCapacity
>
max_packets_
)
{
results_
-
>
AnalyzePackets
(
packets_
.
get
(
)
num_packets_
)
;
num_packets_
=
0
;
}
HWY_DYNAMIC_DISPATCH
(
StreamCacheLine
)
(
buffer_
packets_
.
get
(
)
+
num_packets_
)
;
num_packets_
+
=
kBufferCapacity
;
buffer_size_
=
0
;
}
void
ThreadSpecific
:
:
AnalyzeRemainingPackets
(
)
{
if
(
num_packets_
+
buffer_size_
>
max_packets_
)
{
results_
-
>
AnalyzePackets
(
packets_
.
get
(
)
num_packets_
)
;
num_packets_
=
0
;
}
memcpy
(
packets_
.
get
(
)
+
num_packets_
buffer_
buffer_size_
*
sizeof
(
Packet
)
)
;
num_packets_
+
=
buffer_size_
;
buffer_size_
=
0
;
results_
-
>
AnalyzePackets
(
packets_
.
get
(
)
num_packets_
)
;
num_packets_
=
0
;
}
namespace
{
class
HalfSampleMode
{
public
:
template
<
typename
T
>
T
operator
(
)
(
const
T
*
const
HWY_RESTRICT
sorted
const
size_t
num_values
)
const
{
int64_t
center
=
num_values
/
2
;
int64_t
width
=
num_values
;
while
(
width
>
2
)
{
width
=
(
width
+
1
)
/
2
;
center
=
CenterOfIntervalWithMinSlope
(
sorted
num_values
center
width
)
;
}
return
sorted
[
center
]
;
}
private
:
template
<
typename
T
>
static
HWY_INLINE
int64_t
CenterOfIntervalWithMinSlope
(
const
T
*
HWY_RESTRICT
sorted
const
int64_t
total_values
const
int64_t
center
const
int64_t
width
)
{
const
int64_t
radius
=
(
width
+
1
)
/
2
;
auto
compute_slope
=
[
radius
total_values
sorted
]
(
int64_t
c
int64_t
*
actual_center
=
nullptr
)
{
const
int64_t
min
=
std
:
:
max
(
c
-
radius
int64_t
(
0
)
)
;
const
int64_t
max
=
std
:
:
min
(
c
+
radius
total_values
-
1
)
;
HWY_ASSERT
(
min
<
max
)
;
HWY_ASSERT
(
sorted
[
min
]
<
=
sorted
[
max
]
+
std
:
:
numeric_limits
<
float
>
:
:
epsilon
(
)
)
;
const
float
dx
=
max
-
min
+
1
;
const
float
slope
=
(
sorted
[
max
]
-
sorted
[
min
]
)
/
dx
;
if
(
actual_center
!
=
nullptr
)
{
*
actual_center
=
(
min
+
max
+
1
)
/
2
;
}
return
slope
;
}
;
float
min_slope
=
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
;
for
(
int64_t
c
=
center
-
radius
;
c
<
=
center
+
radius
;
+
+
c
)
{
min_slope
=
std
:
:
min
(
min_slope
compute_slope
(
c
)
)
;
}
std
:
:
vector
<
int64_t
>
candidates
;
for
(
int64_t
c
=
center
-
radius
;
c
<
=
center
+
radius
;
+
+
c
)
{
int64_t
actual_center
;
const
float
slope
=
compute_slope
(
c
&
actual_center
)
;
if
(
slope
<
=
min_slope
*
1
.
001f
)
{
candidates
.
push_back
(
actual_center
)
;
}
}
HWY_ASSERT
(
!
candidates
.
empty
(
)
)
;
if
(
candidates
.
size
(
)
=
=
1
)
return
candidates
[
0
]
;
std
:
:
nth_element
(
candidates
.
begin
(
)
candidates
.
begin
(
)
+
candidates
.
size
(
)
/
2
candidates
.
end
(
)
)
;
return
candidates
[
candidates
.
size
(
)
/
2
]
;
}
}
;
}
void
ThreadSpecific
:
:
ComputeOverhead
(
)
{
uint64_t
self_overhead
;
{
const
size_t
kNumSamples
=
32
;
uint32_t
samples
[
kNumSamples
]
;
for
(
size_t
idx_sample
=
0
;
idx_sample
<
kNumSamples
;
+
+
idx_sample
)
{
const
size_t
kNumDurations
=
1024
;
uint32_t
durations
[
kNumDurations
]
;
for
(
size_t
idx_duration
=
0
;
idx_duration
<
kNumDurations
;
+
+
idx_duration
)
{
{
PROFILER_ZONE
(
"
Dummy
Zone
(
never
shown
)
"
)
;
}
const
uint64_t
duration
=
results_
-
>
ZoneDuration
(
buffer_
)
;
buffer_size_
=
0
;
durations
[
idx_duration
]
=
static_cast
<
uint32_t
>
(
duration
)
;
HWY_ASSERT
(
num_packets_
=
=
0
)
;
}
std
:
:
sort
(
durations
durations
+
kNumDurations
)
;
samples
[
idx_sample
]
=
HalfSampleMode
(
)
(
durations
kNumDurations
)
;
}
std
:
:
sort
(
samples
samples
+
kNumSamples
)
;
self_overhead
=
samples
[
kNumSamples
/
2
]
;
#
if
PROFILER_PRINT_OVERHEAD
printf
(
"
Overhead
:
%
"
PRIu64
"
\
n
"
static_cast
<
uint64_t
>
(
self_overhead
)
)
;
#
endif
results_
-
>
SetSelfOverhead
(
self_overhead
)
;
}
const
size_t
kNumSamples
=
32
;
uint32_t
samples
[
kNumSamples
]
;
for
(
size_t
idx_sample
=
0
;
idx_sample
<
kNumSamples
;
+
+
idx_sample
)
{
const
size_t
kNumDurations
=
16
;
uint32_t
durations
[
kNumDurations
]
;
for
(
size_t
idx_duration
=
0
;
idx_duration
<
kNumDurations
;
+
+
idx_duration
)
{
const
size_t
kReps
=
10000
;
HWY_ASSERT
(
kReps
*
2
<
max_packets_
)
;
hwy
:
:
FlushStream
(
)
;
const
uint64_t
t0
=
TicksBefore
(
)
;
for
(
size_t
i
=
0
;
i
<
kReps
;
+
+
i
)
{
PROFILER_ZONE
(
"
Dummy
"
)
;
}
hwy
:
:
FlushStream
(
)
;
const
uint64_t
t1
=
TicksAfter
(
)
;
HWY_ASSERT
(
num_packets_
+
buffer_size_
=
=
kReps
*
2
)
;
buffer_size_
=
0
;
num_packets_
=
0
;
const
uint64_t
avg_duration
=
(
t1
-
t0
+
kReps
/
2
)
/
kReps
;
durations
[
idx_duration
]
=
static_cast
<
uint32_t
>
(
ClampedSubtract
(
avg_duration
self_overhead
)
)
;
}
std
:
:
sort
(
durations
durations
+
kNumDurations
)
;
samples
[
idx_sample
]
=
HalfSampleMode
(
)
(
durations
kNumDurations
)
;
}
std
:
:
sort
(
samples
samples
+
kNumSamples
)
;
const
uint64_t
child_overhead
=
samples
[
9
*
kNumSamples
/
10
]
;
#
if
PROFILER_PRINT_OVERHEAD
printf
(
"
Child
overhead
:
%
"
PRIu64
"
\
n
"
static_cast
<
uint64_t
>
(
child_overhead
)
)
;
#
endif
results_
-
>
SetChildOverhead
(
child_overhead
)
;
}
namespace
{
std
:
:
atomic
<
ThreadSpecific
*
>
&
GetHead
(
)
{
static
std
:
:
atomic
<
ThreadSpecific
*
>
head_
{
nullptr
}
;
return
head_
;
}
}
ThreadSpecific
*
Zone
:
:
InitThreadSpecific
(
)
{
ThreadSpecific
*
thread_specific
=
hwy
:
:
MakeUniqueAligned
<
ThreadSpecific
>
(
)
.
release
(
)
;
std
:
:
atomic
<
ThreadSpecific
*
>
&
head
=
GetHead
(
)
;
ThreadSpecific
*
old_head
=
head
.
load
(
std
:
:
memory_order_relaxed
)
;
thread_specific
-
>
SetNext
(
old_head
)
;
while
(
!
head
.
compare_exchange_weak
(
old_head
thread_specific
std
:
:
memory_order_release
std
:
:
memory_order_relaxed
)
)
{
thread_specific
-
>
SetNext
(
old_head
)
;
}
GetThreadSpecific
(
)
=
thread_specific
;
thread_specific
-
>
ComputeOverhead
(
)
;
return
thread_specific
;
}
void
Zone
:
:
PrintResults
(
)
{
ThreadSpecific
*
head
=
GetHead
(
)
.
load
(
std
:
:
memory_order_relaxed
)
;
ThreadSpecific
*
p
=
head
;
while
(
p
)
{
p
-
>
AnalyzeRemainingPackets
(
)
;
if
(
p
!
=
head
)
{
head
-
>
GetResults
(
)
.
Assimilate
(
p
-
>
GetResults
(
)
)
;
p
-
>
GetResults
(
)
.
Reset
(
)
;
}
p
=
p
-
>
GetNext
(
)
;
}
if
(
head
!
=
nullptr
)
{
head
-
>
GetResults
(
)
.
Print
(
)
;
head
-
>
GetResults
(
)
.
Reset
(
)
;
}
}
}
}
#
endif
#
endif
