#
ifndef
LIB_JXL_BASE_STATUS_H_
#
define
LIB_JXL_BASE_STATUS_H_
#
include
<
stdarg
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
sanitizer_definitions
.
h
"
#
if
JXL_ADDRESS_SANITIZER
|
|
JXL_MEMORY_SANITIZER
|
|
JXL_THREAD_SANITIZER
#
include
"
sanitizer
/
common_interface_defs
.
h
"
#
endif
namespace
jxl
{
#
ifndef
JXL_ENABLE_ASSERT
#
define
JXL_ENABLE_ASSERT
1
#
endif
#
ifndef
JXL_ENABLE_CHECK
#
define
JXL_ENABLE_CHECK
1
#
endif
#
if
defined
(
JXL_DEBUG_ON_ERROR
)
|
|
defined
(
JXL_CRASH_ON_ERROR
)
#
undef
JXL_DEBUG_ON_ERROR
#
define
JXL_DEBUG_ON_ERROR
1
#
else
#
ifdef
NDEBUG
#
define
JXL_DEBUG_ON_ERROR
0
#
else
#
define
JXL_DEBUG_ON_ERROR
1
#
endif
#
endif
#
if
defined
(
JXL_DEBUG_ON_ALL_ERROR
)
#
undef
JXL_DEBUG_ON_ALL_ERROR
#
define
JXL_DEBUG_ON_ALL_ERROR
1
#
undef
JXL_DEBUG_ON_ERROR
#
define
JXL_DEBUG_ON_ERROR
1
#
else
#
define
JXL_DEBUG_ON_ALL_ERROR
0
#
endif
#
ifndef
JXL_DEBUG_V_LEVEL
#
define
JXL_DEBUG_V_LEVEL
0
#
endif
#
ifndef
JXL_DEBUG_ON_ABORT
#
define
JXL_DEBUG_ON_ABORT
JXL_DEBUG_ON_ERROR
#
endif
JXL_FORMAT
(
1
2
)
inline
JXL_NOINLINE
bool
Debug
(
const
char
*
format
.
.
.
)
{
va_list
args
;
va_start
(
args
format
)
;
vfprintf
(
stderr
format
args
)
;
va_end
(
args
)
;
return
false
;
}
#
define
JXL_DEBUG_TMP
(
format
.
.
.
)
\
:
:
jxl
:
:
Debug
(
(
"
%
s
:
%
d
:
"
format
"
\
n
"
)
__FILE__
__LINE__
#
#
__VA_ARGS__
)
#
define
JXL_DEBUG
(
enabled
format
.
.
.
)
\
do
{
\
if
(
enabled
)
{
\
JXL_DEBUG_TMP
(
format
#
#
__VA_ARGS__
)
;
\
}
\
}
while
(
0
)
#
define
JXL_DEBUG_V
(
level
format
.
.
.
)
\
JXL_DEBUG
(
level
<
=
JXL_DEBUG_V_LEVEL
format
#
#
__VA_ARGS__
)
#
ifdef
JXL_DEBUG_WARNING
#
undef
JXL_DEBUG_WARNING
#
define
JXL_DEBUG_WARNING
1
#
else
#
ifdef
NDEBUG
#
define
JXL_DEBUG_WARNING
0
#
else
#
define
JXL_DEBUG_WARNING
1
#
endif
#
endif
#
define
JXL_WARNING
(
format
.
.
.
)
\
JXL_DEBUG
(
JXL_DEBUG_WARNING
format
#
#
__VA_ARGS__
)
JXL_NORETURN
inline
JXL_NOINLINE
bool
Abort
(
)
{
#
if
JXL_ADDRESS_SANITIZER
|
|
JXL_MEMORY_SANITIZER
|
|
JXL_THREAD_SANITIZER
__sanitizer_print_stack_trace
(
)
;
#
endif
#
if
JXL_COMPILER_MSVC
__debugbreak
(
)
;
abort
(
)
;
#
else
__builtin_trap
(
)
;
#
endif
}
#
define
JXL_ABORT
(
format
.
.
.
)
\
(
(
JXL_DEBUG_ON_ABORT
)
&
&
:
:
jxl
:
:
Debug
(
(
"
%
s
:
%
d
:
JXL_ABORT
:
"
format
"
\
n
"
)
\
__FILE__
__LINE__
#
#
__VA_ARGS__
)
\
:
:
jxl
:
:
Abort
(
)
)
#
define
JXL_UNREACHABLE
(
format
.
.
.
)
\
do
{
\
if
(
JXL_DEBUG_WARNING
)
{
\
:
:
jxl
:
:
Debug
(
(
"
%
s
:
%
d
:
JXL_UNREACHABLE
:
"
format
"
\
n
"
)
__FILE__
\
__LINE__
#
#
__VA_ARGS__
)
;
\
:
:
jxl
:
:
Abort
(
)
;
\
}
else
{
\
JXL_UNREACHABLE_BUILTIN
;
\
}
\
}
while
(
0
)
#
if
JXL_ENABLE_ASSERT
#
define
JXL_ASSERT
(
condition
)
\
do
{
\
if
(
!
(
condition
)
)
{
\
JXL_DEBUG
(
JXL_DEBUG_ON_ABORT
"
JXL_ASSERT
:
%
s
"
#
condition
)
;
\
:
:
jxl
:
:
Abort
(
)
;
\
}
\
}
while
(
0
)
#
else
#
define
JXL_ASSERT
(
condition
)
\
do
{
\
}
while
(
0
)
#
endif
#
ifndef
JXL_IS_DEBUG_BUILD
#
if
!
defined
(
NDEBUG
)
|
|
defined
(
ADDRESS_SANITIZER
)
|
|
\
defined
(
MEMORY_SANITIZER
)
|
|
defined
(
THREAD_SANITIZER
)
|
|
\
defined
(
__clang_analyzer__
)
#
define
JXL_IS_DEBUG_BUILD
1
#
else
#
define
JXL_IS_DEBUG_BUILD
0
#
endif
#
endif
#
if
JXL_IS_DEBUG_BUILD
#
define
JXL_DASSERT
(
condition
)
\
do
{
\
if
(
!
(
condition
)
)
{
\
JXL_DEBUG
(
JXL_DEBUG_ON_ABORT
"
JXL_DASSERT
:
%
s
"
#
condition
)
;
\
:
:
jxl
:
:
Abort
(
)
;
\
}
\
}
while
(
0
)
#
else
#
define
JXL_DASSERT
(
condition
)
\
do
{
\
}
while
(
0
)
#
endif
#
if
JXL_ENABLE_CHECK
#
define
JXL_CHECK
(
condition
)
\
do
{
\
if
(
!
(
condition
)
)
{
\
JXL_DEBUG
(
JXL_DEBUG_ON_ABORT
"
JXL_CHECK
:
%
s
"
#
condition
)
;
\
:
:
jxl
:
:
Abort
(
)
;
\
}
\
}
while
(
0
)
#
else
#
define
JXL_CHECK
(
condition
)
\
do
{
\
(
void
)
(
condition
)
;
\
}
while
(
0
)
#
endif
#
define
JXL_STATUS
(
status
format
.
.
.
)
\
:
:
jxl
:
:
StatusMessage
(
:
:
jxl
:
:
Status
(
status
)
"
%
s
:
%
d
:
"
format
"
\
n
"
__FILE__
\
__LINE__
#
#
__VA_ARGS__
)
#
define
JXL_NOTIFY_ERROR
(
format
.
.
.
)
\
(
void
)
JXL_STATUS
(
:
:
jxl
:
:
StatusCode
:
:
kGenericError
"
JXL_ERROR
:
"
format
\
#
#
__VA_ARGS__
)
#
define
JXL_FAILURE
(
format
.
.
.
)
\
(
(
void
)
JXL_STATUS
(
:
:
jxl
:
:
StatusCode
:
:
kGenericError
"
JXL_FAILURE
:
"
format
\
#
#
__VA_ARGS__
)
\
:
:
jxl
:
:
Status
(
:
:
jxl
:
:
StatusCode
:
:
kGenericError
)
)
#
define
JXL_RETURN_IF_ERROR
(
status
)
\
do
{
\
:
:
jxl
:
:
Status
jxl_return_if_error_status
=
(
status
)
;
\
if
(
!
jxl_return_if_error_status
)
{
\
(
void
)
:
:
jxl
:
:
StatusMessage
(
\
jxl_return_if_error_status
\
"
%
s
:
%
d
:
JXL_RETURN_IF_ERROR
code
=
%
d
:
%
s
\
n
"
__FILE__
__LINE__
\
static_cast
<
int
>
(
jxl_return_if_error_status
.
code
(
)
)
#
status
)
;
\
return
jxl_return_if_error_status
;
\
}
\
}
while
(
0
)
#
define
JXL_QUIET_RETURN_IF_ERROR
(
status
)
\
do
{
\
:
:
jxl
:
:
Status
jxl_return_if_error_status
=
(
status
)
;
\
if
(
!
jxl_return_if_error_status
)
{
\
return
jxl_return_if_error_status
;
\
}
\
}
while
(
0
)
enum
class
StatusCode
:
int32_t
{
kNotEnoughBytes
=
-
1
kOk
=
0
kGenericError
=
1
}
;
class
JXL_MUST_USE_RESULT
Status
{
public
:
constexpr
Status
(
bool
ok
)
:
code_
(
ok
?
StatusCode
:
:
kOk
:
StatusCode
:
:
kGenericError
)
{
}
constexpr
Status
(
StatusCode
code
)
:
code_
(
code
)
{
}
constexpr
operator
bool
(
)
const
{
return
code_
=
=
StatusCode
:
:
kOk
;
}
constexpr
StatusCode
code
(
)
const
{
return
code_
;
}
constexpr
bool
IsFatalError
(
)
const
{
return
static_cast
<
int32_t
>
(
code_
)
>
0
;
}
private
:
StatusCode
code_
;
}
;
static
constexpr
Status
OkStatus
(
)
{
return
Status
(
StatusCode
:
:
kOk
)
;
}
inline
JXL_FORMAT
(
2
3
)
Status
StatusMessage
(
const
Status
status
const
char
*
format
.
.
.
)
{
if
(
(
JXL_DEBUG_ON_ERROR
&
&
status
.
IsFatalError
(
)
)
|
|
(
JXL_DEBUG_ON_ALL_ERROR
&
&
!
status
)
)
{
va_list
args
;
va_start
(
args
format
)
;
vfprintf
(
stderr
format
args
)
;
va_end
(
args
)
;
}
#
ifdef
JXL_CRASH_ON_ERROR
if
(
status
.
IsFatalError
(
)
)
{
Abort
(
)
;
}
#
endif
return
status
;
}
template
<
typename
T
>
class
JXL_MUST_USE_RESULT
StatusOr
{
static_assert
(
!
std
:
:
is_convertible
<
StatusCode
T
>
:
:
value
&
&
!
std
:
:
is_convertible
<
T
StatusCode
>
:
:
value
"
You
cannot
make
a
StatusOr
with
a
type
convertible
from
or
to
"
"
StatusCode
"
)
;
static_assert
(
std
:
:
is_move_constructible
<
T
>
:
:
value
&
&
std
:
:
is_move_assignable
<
T
>
:
:
value
"
T
must
be
move
constructible
and
move
assignable
"
)
;
public
:
StatusOr
(
StatusCode
code
)
:
code_
(
code
)
{
JXL_ASSERT
(
code_
!
=
StatusCode
:
:
kOk
)
;
}
StatusOr
(
Status
status
)
:
StatusOr
(
status
.
code
(
)
)
{
}
StatusOr
(
T
&
&
value
)
:
code_
(
StatusCode
:
:
kOk
)
{
new
(
&
storage_
.
data_
)
T
(
std
:
:
move
(
value
)
)
;
}
StatusOr
(
StatusOr
&
&
other
)
noexcept
{
if
(
other
.
ok
(
)
)
{
new
(
&
storage_
.
data_
)
T
(
std
:
:
move
(
other
.
storage_
.
data_
)
)
;
}
code_
=
other
.
code_
;
}
StatusOr
&
operator
=
(
StatusOr
&
&
other
)
noexcept
{
if
(
this
=
=
&
other
)
return
*
this
;
if
(
ok
(
)
&
&
other
.
ok
(
)
)
{
storage_
.
data_
=
std
:
:
move
(
other
.
storage_
.
data_
)
;
}
else
if
(
other
.
ok
(
)
)
{
new
(
&
storage_
.
data_
)
T
(
std
:
:
move
(
other
.
storage_
.
data_
)
)
;
}
else
if
(
ok
(
)
)
{
storage_
.
data_
.
~
T
(
)
;
}
code_
=
other
.
code_
;
return
*
this
;
}
StatusOr
(
const
StatusOr
&
)
=
delete
;
StatusOr
operator
=
(
const
StatusOr
&
)
=
delete
;
bool
ok
(
)
const
{
return
code_
=
=
StatusCode
:
:
kOk
;
}
Status
status
(
)
const
{
return
code_
;
}
T
value
(
)
&
&
{
JXL_ASSERT
(
ok
(
)
)
;
return
std
:
:
move
(
storage_
.
data_
)
;
}
~
StatusOr
(
)
{
if
(
code_
=
=
StatusCode
:
:
kOk
)
{
storage_
.
data_
.
~
T
(
)
;
}
}
private
:
union
Storage
{
char
dummy_
;
T
data_
;
Storage
(
)
{
}
~
Storage
(
)
{
}
}
storage_
;
StatusCode
code_
;
}
;
#
define
JXL_ASSIGN_OR_RETURN
(
lhs
statusor
)
\
PRIVATE_JXL_ASSIGN_OR_RETURN_IMPL
(
\
assign_or_return_temporary_variable
#
#
__LINE__
lhs
statusor
)
#
define
PRIVATE_JXL_ASSIGN_OR_RETURN_IMPL
(
name
lhs
statusor
)
\
auto
name
=
statusor
;
\
JXL_RETURN_IF_ERROR
(
name
.
status
(
)
)
;
\
lhs
=
std
:
:
move
(
name
)
.
value
(
)
;
}
#
endif
