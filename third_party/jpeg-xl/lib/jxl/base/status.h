#
ifndef
LIB_JXL_BASE_STATUS_H_
#
define
LIB_JXL_BASE_STATUS_H_
#
include
<
cstdarg
>
#
include
<
cstdint
>
#
include
<
cstdio
>
#
include
<
cstdlib
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
lib
/
jxl
/
base
/
common
.
h
"
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
namespace
jxl
{
#
ifndef
JXL_DEBUG_V_LEVEL
#
define
JXL_DEBUG_V_LEVEL
0
#
endif
#
ifdef
USE_ANDROID_LOGGER
#
include
<
android
/
log
.
h
>
#
define
LIBJXL_ANDROID_LOG_TAG
(
"
libjxl
"
)
inline
void
android_vprintf
(
const
char
*
format
va_list
args
)
{
char
*
message
=
nullptr
;
int
res
=
vasprintf
(
&
message
format
args
)
;
if
(
res
!
=
-
1
)
{
__android_log_write
(
ANDROID_LOG_DEBUG
LIBJXL_ANDROID_LOG_TAG
message
)
;
free
(
message
)
;
}
}
#
endif
JXL_FORMAT
(
1
2
)
inline
JXL_NOINLINE
bool
Debug
(
const
char
*
format
.
.
.
)
{
va_list
args
;
va_start
(
args
format
)
;
#
ifdef
USE_ANDROID_LOGGER
android_vprintf
(
format
args
)
;
#
else
vfprintf
(
stderr
format
args
)
;
#
endif
va_end
(
args
)
;
return
false
;
}
#
define
JXL_DEBUG_TMP
(
format
.
.
.
)
\
:
:
jxl
:
:
Debug
(
(
"
%
s
:
%
d
:
"
format
"
\
n
"
)
__FILE__
__LINE__
#
#
__VA_ARGS__
)
#
define
JXL_DEBUG
(
enabled
format
.
.
.
)
\
do
{
\
if
(
enabled
)
{
\
JXL_DEBUG_TMP
(
format
#
#
__VA_ARGS__
)
;
\
}
\
}
while
(
0
)
#
if
JXL_DEBUG_V_LEVEL
>
0
#
define
JXL_DEBUG_V
(
level
format
.
.
.
)
\
JXL_DEBUG
(
level
<
=
JXL_DEBUG_V_LEVEL
format
#
#
__VA_ARGS__
)
#
else
#
define
JXL_DEBUG_V
(
level
format
.
.
.
)
#
endif
#
define
JXL_WARNING
(
format
.
.
.
)
\
JXL_DEBUG
(
JXL_IS_DEBUG_BUILD
format
#
#
__VA_ARGS__
)
#
if
JXL_IS_DEBUG_BUILD
JXL_NORETURN
inline
JXL_NOINLINE
bool
Abort
(
)
{
JXL_PRINT_STACK_TRACE
(
)
;
JXL_CRASH
(
)
;
}
#
endif
#
if
JXL_IS_DEBUG_BUILD
#
define
JXL_DEBUG_ABORT
(
format
.
.
.
)
\
do
{
\
if
(
JXL_DEBUG_ON_ABORT
)
{
\
:
:
jxl
:
:
Debug
(
(
"
%
s
:
%
d
:
JXL_DEBUG_ABORT
:
"
format
"
\
n
"
)
__FILE__
\
__LINE__
#
#
__VA_ARGS__
)
;
\
}
\
:
:
jxl
:
:
Abort
(
)
;
\
}
while
(
0
)
;
#
else
#
define
JXL_DEBUG_ABORT
(
format
.
.
.
)
#
endif
#
if
JXL_IS_DEBUG_BUILD
#
define
JXL_UNREACHABLE
(
format
.
.
.
)
\
(
:
:
jxl
:
:
Debug
(
(
"
%
s
:
%
d
:
JXL_UNREACHABLE
:
"
format
"
\
n
"
)
__FILE__
__LINE__
\
#
#
__VA_ARGS__
)
\
:
:
jxl
:
:
Abort
(
)
JXL_FAILURE
(
format
#
#
__VA_ARGS__
)
)
#
else
#
define
JXL_UNREACHABLE
(
format
.
.
.
)
\
JXL_FAILURE
(
"
internal
:
"
format
#
#
__VA_ARGS__
)
#
endif
#
if
JXL_IS_DEBUG_BUILD
#
define
JXL_DASSERT
(
condition
)
\
do
{
\
if
(
!
(
condition
)
)
{
\
JXL_DEBUG
(
JXL_DEBUG_ON_ABORT
"
JXL_DASSERT
:
%
s
"
#
condition
)
;
\
:
:
jxl
:
:
Abort
(
)
;
\
}
\
}
while
(
0
)
#
else
#
define
JXL_DASSERT
(
condition
)
#
endif
#
define
JXL_STATUS
(
status
format
.
.
.
)
\
:
:
jxl
:
:
StatusMessage
(
:
:
jxl
:
:
Status
(
status
)
"
%
s
:
%
d
:
"
format
"
\
n
"
__FILE__
\
__LINE__
#
#
__VA_ARGS__
)
#
define
JXL_NOTIFY_ERROR
(
format
.
.
.
)
\
(
void
)
JXL_STATUS
(
:
:
jxl
:
:
StatusCode
:
:
kGenericError
"
JXL_ERROR
:
"
format
\
#
#
__VA_ARGS__
)
#
define
JXL_FAILURE
(
format
.
.
.
)
\
(
(
void
)
JXL_STATUS
(
:
:
jxl
:
:
StatusCode
:
:
kGenericError
"
JXL_FAILURE
:
"
format
\
#
#
__VA_ARGS__
)
\
:
:
jxl
:
:
Status
(
:
:
jxl
:
:
StatusCode
:
:
kGenericError
)
)
#
define
JXL_RETURN_IF_ERROR
(
status
)
\
do
{
\
:
:
jxl
:
:
Status
jxl_return_if_error_status
=
(
status
)
;
\
if
(
!
jxl_return_if_error_status
)
{
\
(
void
)
:
:
jxl
:
:
StatusMessage
(
\
jxl_return_if_error_status
\
"
%
s
:
%
d
:
JXL_RETURN_IF_ERROR
code
=
%
d
:
%
s
\
n
"
__FILE__
__LINE__
\
static_cast
<
int
>
(
jxl_return_if_error_status
.
code
(
)
)
#
status
)
;
\
return
jxl_return_if_error_status
;
\
}
\
}
while
(
0
)
#
define
JXL_QUIET_RETURN_IF_ERROR
(
status
)
\
do
{
\
:
:
jxl
:
:
Status
jxl_return_if_error_status
=
(
status
)
;
\
if
(
!
jxl_return_if_error_status
)
{
\
return
jxl_return_if_error_status
;
\
}
\
}
while
(
0
)
#
if
JXL_IS_DEBUG_BUILD
#
define
JXL_ENSURE
(
condition
)
\
do
{
\
if
(
!
(
condition
)
)
{
\
:
:
jxl
:
:
Debug
(
"
JXL_ENSURE
:
%
s
"
#
condition
)
;
\
:
:
jxl
:
:
Abort
(
)
;
\
}
\
}
while
(
0
)
#
else
#
define
JXL_ENSURE
(
condition
)
\
do
{
\
if
(
!
(
condition
)
)
{
\
return
JXL_FAILURE
(
"
JXL_ENSURE
:
%
s
"
#
condition
)
;
\
}
\
}
while
(
0
)
#
endif
enum
class
StatusCode
:
int32_t
{
kNotEnoughBytes
=
-
1
kOk
=
0
kGenericError
=
1
}
;
class
JXL_MUST_USE_RESULT
Status
{
public
:
constexpr
Status
(
bool
ok
)
:
code_
(
ok
?
StatusCode
:
:
kOk
:
StatusCode
:
:
kGenericError
)
{
}
constexpr
Status
(
StatusCode
code
)
:
code_
(
code
)
{
}
constexpr
operator
bool
(
)
const
{
return
code_
=
=
StatusCode
:
:
kOk
;
}
constexpr
StatusCode
code
(
)
const
{
return
code_
;
}
constexpr
bool
IsFatalError
(
)
const
{
return
static_cast
<
int32_t
>
(
code_
)
>
0
;
}
private
:
StatusCode
code_
;
}
;
static
constexpr
Status
OkStatus
(
)
{
return
Status
(
StatusCode
:
:
kOk
)
;
}
inline
JXL_FORMAT
(
2
3
)
Status
StatusMessage
(
const
Status
status
const
char
*
format
.
.
.
)
{
if
(
(
JXL_IS_DEBUG_BUILD
&
&
status
.
IsFatalError
(
)
)
|
|
(
JXL_DEBUG_ON_ALL_ERROR
&
&
!
status
)
)
{
va_list
args
;
va_start
(
args
format
)
;
#
ifdef
USE_ANDROID_LOGGER
android_vprintf
(
format
args
)
;
#
else
vfprintf
(
stderr
format
args
)
;
#
endif
va_end
(
args
)
;
}
#
if
JXL_CRASH_ON_ERROR
if
(
status
.
IsFatalError
(
)
)
{
:
:
jxl
:
:
Abort
(
)
;
}
#
endif
return
status
;
}
template
<
typename
T
>
class
JXL_MUST_USE_RESULT
StatusOr
{
static_assert
(
!
std
:
:
is_convertible
<
StatusCode
T
>
:
:
value
&
&
!
std
:
:
is_convertible
<
T
StatusCode
>
:
:
value
"
You
cannot
make
a
StatusOr
with
a
type
convertible
from
or
to
"
"
StatusCode
"
)
;
static_assert
(
std
:
:
is_move_constructible
<
T
>
:
:
value
&
&
std
:
:
is_move_assignable
<
T
>
:
:
value
"
T
must
be
move
constructible
and
move
assignable
"
)
;
public
:
StatusOr
(
StatusCode
code
)
:
code_
(
code
)
{
JXL_DASSERT
(
code_
!
=
StatusCode
:
:
kOk
)
;
}
StatusOr
(
Status
status
)
:
StatusOr
(
status
.
code
(
)
)
{
}
StatusOr
(
T
&
&
value
)
:
code_
(
StatusCode
:
:
kOk
)
{
new
(
&
storage_
.
data_
)
T
(
std
:
:
move
(
value
)
)
;
}
StatusOr
(
StatusOr
&
&
other
)
noexcept
{
if
(
other
.
ok
(
)
)
{
new
(
&
storage_
.
data_
)
T
(
std
:
:
move
(
other
.
storage_
.
data_
)
)
;
}
code_
=
other
.
code_
;
}
StatusOr
&
operator
=
(
StatusOr
&
&
other
)
noexcept
{
if
(
this
=
=
&
other
)
return
*
this
;
if
(
ok
(
)
&
&
other
.
ok
(
)
)
{
storage_
.
data_
=
std
:
:
move
(
other
.
storage_
.
data_
)
;
}
else
if
(
other
.
ok
(
)
)
{
new
(
&
storage_
.
data_
)
T
(
std
:
:
move
(
other
.
storage_
.
data_
)
)
;
}
else
if
(
ok
(
)
)
{
storage_
.
data_
.
~
T
(
)
;
}
code_
=
other
.
code_
;
return
*
this
;
}
StatusOr
(
const
StatusOr
&
)
=
delete
;
StatusOr
operator
=
(
const
StatusOr
&
)
=
delete
;
bool
ok
(
)
const
{
return
code_
=
=
StatusCode
:
:
kOk
;
}
Status
status
(
)
const
{
return
code_
;
}
T
value_
(
)
&
&
{
JXL_DASSERT
(
ok
(
)
)
;
return
std
:
:
move
(
storage_
.
data_
)
;
}
~
StatusOr
(
)
{
if
(
code_
=
=
StatusCode
:
:
kOk
)
{
storage_
.
data_
.
~
T
(
)
;
}
}
private
:
union
Storage
{
char
placeholder_
;
T
data_
;
Storage
(
)
{
}
~
Storage
(
)
{
}
}
storage_
;
StatusCode
code_
;
}
;
#
define
JXL_ASSIGN_OR_RETURN
(
lhs
statusor
)
\
PRIVATE_JXL_ASSIGN_OR_RETURN_IMPL
(
\
JXL_JOIN
(
assign_or_return_temporary_variable
__LINE__
)
lhs
statusor
)
#
define
PRIVATE_JXL_ASSIGN_OR_RETURN_IMPL
(
name
lhs
statusor
)
\
auto
name
=
statusor
;
\
JXL_RETURN_IF_ERROR
(
name
.
status
(
)
)
;
\
lhs
=
std
:
:
move
(
name
)
.
value_
(
)
;
#
define
JXL_ASSIGN_OR_QUIT
(
lhs
statusor
message
)
\
PRIVATE_JXL_ASSIGN_OR_QUIT_IMPL
(
\
JXL_JOIN
(
assign_or_temporary_variable
__LINE__
)
lhs
statusor
\
message
)
#
define
PRIVATE_JXL_ASSIGN_OR_QUIT_IMPL
(
name
lhs
statusor
message
)
\
auto
name
=
statusor
;
\
if
(
!
name
.
ok
(
)
)
{
\
QUIT
(
message
)
;
\
}
\
lhs
=
std
:
:
move
(
name
)
.
value_
(
)
;
}
#
endif
