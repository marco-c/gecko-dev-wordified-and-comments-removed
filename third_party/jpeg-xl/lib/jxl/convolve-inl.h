#
if
defined
(
LIB_JXL_CONVOLVE_INL_H_
)
=
=
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
LIB_JXL_CONVOLVE_INL_H_
#
undef
LIB_JXL_CONVOLVE_INL_H_
#
else
#
define
LIB_JXL_CONVOLVE_INL_H_
#
endif
#
include
<
hwy
/
highway
.
h
>
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
jxl
{
namespace
HWY_NAMESPACE
{
namespace
{
using
hwy
:
:
HWY_NAMESPACE
:
:
Broadcast
;
#
if
HWY_TARGET
!
=
HWY_SCALAR
using
hwy
:
:
HWY_NAMESPACE
:
:
CombineShiftRightBytes
;
#
endif
using
hwy
:
:
HWY_NAMESPACE
:
:
Vec
;
class
Neighbors
{
public
:
using
D
=
HWY_CAPPED
(
float
16
)
;
using
V
=
Vec
<
D
>
;
HWY_INLINE
HWY_MAYBE_UNUSED
static
V
FirstL1
(
const
V
c
)
{
#
if
HWY_CAP_GE256
const
D
d
;
HWY_ALIGN
constexpr
int32_t
lanes
[
16
]
=
{
0
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
}
;
const
auto
indices
=
SetTableIndices
(
d
lanes
)
;
return
TableLookupLanes
(
c
indices
)
;
#
elif
HWY_TARGET
=
=
HWY_SCALAR
return
c
;
#
else
#
if
HWY_TARGET
<
=
(
1
<
<
HWY_HIGHEST_TARGET_BIT_X86
)
return
V
{
_mm_shuffle_ps
(
c
.
raw
c
.
raw
_MM_SHUFFLE
(
2
1
0
0
)
)
}
;
#
else
const
D
d
;
HWY_ALIGN
constexpr
int
lanes
[
4
]
=
{
0
0
1
2
}
;
const
auto
indices
=
SetTableIndices
(
d
lanes
)
;
return
TableLookupLanes
(
c
indices
)
;
#
endif
#
endif
}
HWY_INLINE
HWY_MAYBE_UNUSED
static
V
FirstL2
(
const
V
c
)
{
#
if
HWY_CAP_GE256
const
D
d
;
HWY_ALIGN
constexpr
int32_t
lanes
[
16
]
=
{
1
0
0
1
2
3
4
5
6
7
8
9
10
11
12
13
}
;
const
auto
indices
=
SetTableIndices
(
d
lanes
)
;
return
TableLookupLanes
(
c
indices
)
;
#
elif
HWY_TARGET
=
=
HWY_SCALAR
const
D
d
;
JXL_ASSERT
(
false
)
;
return
Zero
(
d
)
;
#
else
#
if
HWY_TARGET
<
=
(
1
<
<
HWY_HIGHEST_TARGET_BIT_X86
)
return
V
{
_mm_shuffle_ps
(
c
.
raw
c
.
raw
_MM_SHUFFLE
(
1
0
0
1
)
)
}
;
#
else
const
D
d
;
HWY_ALIGN
constexpr
int
lanes
[
4
]
=
{
1
0
0
1
}
;
const
auto
indices
=
SetTableIndices
(
d
lanes
)
;
return
TableLookupLanes
(
c
indices
)
;
#
endif
#
endif
}
HWY_INLINE
HWY_MAYBE_UNUSED
static
V
FirstL3
(
const
V
c
)
{
#
if
HWY_CAP_GE256
const
D
d
;
HWY_ALIGN
constexpr
int32_t
lanes
[
16
]
=
{
2
1
0
0
1
2
3
4
5
6
7
8
9
10
11
12
}
;
const
auto
indices
=
SetTableIndices
(
d
lanes
)
;
return
TableLookupLanes
(
c
indices
)
;
#
elif
HWY_TARGET
=
=
HWY_SCALAR
const
D
d
;
JXL_ASSERT
(
false
)
;
return
Zero
(
d
)
;
#
else
#
if
HWY_TARGET
<
=
(
1
<
<
HWY_HIGHEST_TARGET_BIT_X86
)
return
V
{
_mm_shuffle_ps
(
c
.
raw
c
.
raw
_MM_SHUFFLE
(
0
0
1
2
)
)
}
;
#
else
const
D
d
;
HWY_ALIGN
constexpr
int
lanes
[
4
]
=
{
2
1
0
0
}
;
const
auto
indices
=
SetTableIndices
(
d
lanes
)
;
return
TableLookupLanes
(
c
indices
)
;
#
endif
#
endif
}
}
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
