#
include
"
lib
/
jxl
/
enc_photon_noise
.
h
"
#
include
<
algorithm
>
#
include
"
lib
/
jxl
/
cms
/
opsin_params
.
h
"
namespace
jxl
{
namespace
{
constexpr
float
kPhotonsPerLxSPerUm2
=
11260
;
constexpr
float
kEffectiveQuantumEfficiency
=
0
.
20
;
constexpr
float
kPhotoResponseNonUniformity
=
0
.
005
;
constexpr
float
kInputReferredReadNoise
=
3
;
constexpr
float
kSensorAreaUm2
=
36000
.
f
*
24000
;
template
<
typename
T
>
inline
constexpr
T
Square
(
const
T
x
)
{
return
x
*
x
;
}
template
<
typename
T
>
inline
constexpr
T
Cube
(
const
T
x
)
{
return
x
*
x
*
x
;
}
}
NoiseParams
SimulatePhotonNoise
(
const
size_t
xsize
const
size_t
ysize
const
float
iso
)
{
const
float
kOpsinAbsorbanceBiasCbrt
=
std
:
:
cbrt
(
jxl
:
:
cms
:
:
kOpsinAbsorbanceBias
[
1
]
)
;
const
float
h_18
=
10
/
iso
;
const
float
pixel_area_um2
=
kSensorAreaUm2
/
(
xsize
*
ysize
)
;
const
float
electrons_per_pixel_18
=
kEffectiveQuantumEfficiency
*
kPhotonsPerLxSPerUm2
*
h_18
*
pixel_area_um2
;
NoiseParams
params
;
for
(
size_t
i
=
0
;
i
<
NoiseParams
:
:
kNumNoisePoints
;
+
+
i
)
{
const
float
scaled_index
=
i
/
(
NoiseParams
:
:
kNumNoisePoints
-
2
.
f
)
;
const
float
y
=
2
*
scaled_index
;
const
float
linear
=
std
:
:
max
(
0
.
f
Cube
(
y
-
kOpsinAbsorbanceBiasCbrt
)
+
jxl
:
:
cms
:
:
kOpsinAbsorbanceBias
[
1
]
)
;
const
float
electrons_per_pixel
=
electrons_per_pixel_18
*
(
linear
/
0
.
18f
)
;
const
float
noise
=
std
:
:
sqrt
(
Square
(
kInputReferredReadNoise
)
+
electrons_per_pixel
+
Square
(
kPhotoResponseNonUniformity
*
electrons_per_pixel
)
)
;
const
float
linear_noise
=
noise
*
(
0
.
18f
/
electrons_per_pixel_18
)
;
const
float
opsin_derivative
=
(
1
.
f
/
3
)
/
Square
(
std
:
:
cbrt
(
linear
-
jxl
:
:
cms
:
:
kOpsinAbsorbanceBias
[
1
]
)
)
;
const
float
opsin_noise
=
linear_noise
*
opsin_derivative
;
params
.
lut
[
i
]
=
Clamp1
(
opsin_noise
/
(
0
.
22f
*
std
:
:
sqrt
(
2
.
f
)
*
1
.
13f
)
0
.
f
1
.
f
)
;
}
return
params
;
}
}
