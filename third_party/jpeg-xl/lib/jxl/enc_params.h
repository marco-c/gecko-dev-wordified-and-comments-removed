#
ifndef
LIB_JXL_ENC_PARAMS_H_
#
define
LIB_JXL_ENC_PARAMS_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
"
lib
/
jxl
/
base
/
override
.
h
"
#
include
"
lib
/
jxl
/
butteraugli
/
butteraugli
.
h
"
#
include
"
lib
/
jxl
/
frame_header
.
h
"
#
include
"
lib
/
jxl
/
modular
/
options
.
h
"
#
include
"
lib
/
jxl
/
modular
/
transform
/
transform
.
h
"
namespace
jxl
{
enum
class
SpeedTier
{
kTortoise
=
1
kKitten
=
2
kSquirrel
=
3
kWombat
=
4
kHare
=
5
kCheetah
=
6
kFalcon
=
7
kThunder
=
8
kLightning
=
9
}
;
inline
bool
ParseSpeedTier
(
const
std
:
:
string
&
s
SpeedTier
*
out
)
{
if
(
s
=
=
"
lightning
"
)
{
*
out
=
SpeedTier
:
:
kLightning
;
return
true
;
}
else
if
(
s
=
=
"
thunder
"
)
{
*
out
=
SpeedTier
:
:
kThunder
;
return
true
;
}
else
if
(
s
=
=
"
falcon
"
)
{
*
out
=
SpeedTier
:
:
kFalcon
;
return
true
;
}
else
if
(
s
=
=
"
cheetah
"
)
{
*
out
=
SpeedTier
:
:
kCheetah
;
return
true
;
}
else
if
(
s
=
=
"
hare
"
)
{
*
out
=
SpeedTier
:
:
kHare
;
return
true
;
}
else
if
(
s
=
=
"
fast
"
|
|
s
=
=
"
wombat
"
)
{
*
out
=
SpeedTier
:
:
kWombat
;
return
true
;
}
else
if
(
s
=
=
"
squirrel
"
)
{
*
out
=
SpeedTier
:
:
kSquirrel
;
return
true
;
}
else
if
(
s
=
=
"
kitten
"
)
{
*
out
=
SpeedTier
:
:
kKitten
;
return
true
;
}
else
if
(
s
=
=
"
guetzli
"
|
|
s
=
=
"
tortoise
"
)
{
*
out
=
SpeedTier
:
:
kTortoise
;
return
true
;
}
size_t
st
=
10
-
static_cast
<
size_t
>
(
strtoull
(
s
.
c_str
(
)
nullptr
0
)
)
;
if
(
st
<
=
static_cast
<
size_t
>
(
SpeedTier
:
:
kLightning
)
&
&
st
>
=
static_cast
<
size_t
>
(
SpeedTier
:
:
kTortoise
)
)
{
*
out
=
SpeedTier
(
st
)
;
return
true
;
}
return
false
;
}
inline
const
char
*
SpeedTierName
(
SpeedTier
speed_tier
)
{
switch
(
speed_tier
)
{
case
SpeedTier
:
:
kLightning
:
return
"
lightning
"
;
case
SpeedTier
:
:
kThunder
:
return
"
thunder
"
;
case
SpeedTier
:
:
kFalcon
:
return
"
falcon
"
;
case
SpeedTier
:
:
kCheetah
:
return
"
cheetah
"
;
case
SpeedTier
:
:
kHare
:
return
"
hare
"
;
case
SpeedTier
:
:
kWombat
:
return
"
wombat
"
;
case
SpeedTier
:
:
kSquirrel
:
return
"
squirrel
"
;
case
SpeedTier
:
:
kKitten
:
return
"
kitten
"
;
case
SpeedTier
:
:
kTortoise
:
return
"
tortoise
"
;
}
return
"
INVALID
"
;
}
struct
CompressParams
{
float
butteraugli_distance
=
1
.
0f
;
size_t
target_size
=
0
;
float
target_bitrate
=
0
.
0f
;
float
uniform_quant
=
0
.
0f
;
float
quant_border_bias
=
0
.
0f
;
bool
max_error_mode
=
false
;
float
max_error
[
3
]
=
{
0
.
0
0
.
0
0
.
0
}
;
SpeedTier
speed_tier
=
SpeedTier
:
:
kSquirrel
;
int
brotli_effort
=
-
1
;
size_t
decoding_speed_tier
=
0
;
int
max_butteraugli_iters
=
4
;
int
max_butteraugli_iters_guetzli_mode
=
100
;
ColorTransform
color_transform
=
ColorTransform
:
:
kXYB
;
YCbCrChromaSubsampling
chroma_subsampling
;
bool
modular_mode
=
false
;
size_t
modular_group_size_shift
=
1
;
Override
preview
=
Override
:
:
kDefault
;
Override
noise
=
Override
:
:
kDefault
;
Override
dots
=
Override
:
:
kDefault
;
Override
patches
=
Override
:
:
kDefault
;
Override
gaborish
=
Override
:
:
kDefault
;
int
epf
=
-
1
;
bool
progressive_mode
=
false
;
bool
qprogressive_mode
=
false
;
bool
centerfirst
=
false
;
size_t
center_x
=
static_cast
<
size_t
>
(
-
1
)
;
size_t
center_y
=
static_cast
<
size_t
>
(
-
1
)
;
int
progressive_dc
=
-
1
;
Override
keep_invisible
=
Override
:
:
kDefault
;
bool
clear_metadata
=
false
;
bool
verbose
=
false
;
bool
log_search_state
=
false
;
ButteraugliParams
ba_params
;
bool
force_cfl_jpeg_recompression
=
true
;
float
photon_noise_iso
=
0
;
ModularOptions
options
;
int
responsive
=
-
1
;
std
:
:
vector
<
SqueezeParams
>
squeezes
;
int
colorspace
=
-
1
;
float
channel_colors_pre_transform_percent
=
95
.
f
;
float
channel_colors_percent
=
80
.
f
;
int
palette_colors
=
1
<
<
10
;
bool
lossy_palette
=
false
;
bool
IsLossless
(
)
const
{
return
modular_mode
&
&
butteraugli_distance
=
=
0
.
0f
&
&
color_transform
!
=
jxl
:
:
ColorTransform
:
:
kXYB
;
}
void
SetLossless
(
)
{
modular_mode
=
true
;
butteraugli_distance
=
0
.
0f
;
color_transform
=
jxl
:
:
ColorTransform
:
:
kNone
;
}
int
resampling
=
-
1
;
int
ec_resampling
=
-
1
;
bool
already_downsampled
=
false
;
float
original_butteraugli_distance
=
-
1
.
0f
;
float
quant_ac_rescale
=
1
.
0
;
int
level
=
-
1
;
std
:
:
vector
<
float
>
manual_noise
;
std
:
:
vector
<
float
>
manual_xyb_factors
;
}
;
static
constexpr
float
kMinButteraugliForDynamicAR
=
0
.
5f
;
static
constexpr
float
kMinButteraugliForDots
=
3
.
0f
;
static
constexpr
float
kMinButteraugliToSubtractOriginalPatches
=
3
.
0f
;
static
constexpr
float
kMinButteraugliDistanceForProgressiveDc
=
4
.
5f
;
static
constexpr
float
kMinButteraugliForNoise
=
99
.
0f
;
static
constexpr
float
kMinButteraugliDistance
=
0
.
01f
;
static
constexpr
size_t
kEncTileDim
=
64
;
static
constexpr
size_t
kEncTileDimInBlocks
=
kEncTileDim
/
kBlockDim
;
}
#
endif
