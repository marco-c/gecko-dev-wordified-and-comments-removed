#
ifndef
LIB_JXL_ENC_PARAMS_H_
#
define
LIB_JXL_ENC_PARAMS_H_
#
include
<
jxl
/
encode
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
"
lib
/
jxl
/
base
/
override
.
h
"
#
include
"
lib
/
jxl
/
butteraugli
/
butteraugli
.
h
"
#
include
"
lib
/
jxl
/
enc_progressive_split
.
h
"
#
include
"
lib
/
jxl
/
frame_header
.
h
"
#
include
"
lib
/
jxl
/
modular
/
encoding
/
dec_ma
.
h
"
#
include
"
lib
/
jxl
/
modular
/
options
.
h
"
#
include
"
lib
/
jxl
/
modular
/
transform
/
transform
.
h
"
#
include
"
lib
/
jxl
/
splines
.
h
"
namespace
jxl
{
enum
class
SpeedTier
{
kGlacier
=
0
kTortoise
=
1
kKitten
=
2
kSquirrel
=
3
kWombat
=
4
kHare
=
5
kCheetah
=
6
kFalcon
=
7
kThunder
=
8
kLightning
=
9
}
;
struct
CompressParams
{
float
butteraugli_distance
=
1
.
0f
;
std
:
:
vector
<
float
>
ec_distance
;
bool
max_error_mode
=
false
;
float
max_error
[
3
]
=
{
0
.
0
0
.
0
0
.
0
}
;
SpeedTier
speed_tier
=
SpeedTier
:
:
kSquirrel
;
int
brotli_effort
=
-
1
;
size_t
decoding_speed_tier
=
0
;
ColorTransform
color_transform
=
ColorTransform
:
:
kXYB
;
bool
modular_mode
=
false
;
int
modular_group_size_shift
=
-
1
;
Override
preview
=
Override
:
:
kDefault
;
Override
noise
=
Override
:
:
kDefault
;
Override
dots
=
Override
:
:
kDefault
;
Override
patches
=
Override
:
:
kDefault
;
Override
gaborish
=
Override
:
:
kDefault
;
int
epf
=
-
1
;
bool
progressive_mode
=
false
;
bool
qprogressive_mode
=
false
;
bool
centerfirst
=
false
;
size_t
center_x
=
static_cast
<
size_t
>
(
-
1
)
;
size_t
center_y
=
static_cast
<
size_t
>
(
-
1
)
;
int
progressive_dc
=
-
1
;
Override
keep_invisible
=
Override
:
:
kDefault
;
JxlCmsInterface
cms
;
bool
cms_set
=
false
;
void
SetCms
(
const
JxlCmsInterface
&
cms
)
{
this
-
>
cms
=
cms
;
cms_set
=
true
;
}
bool
force_cfl_jpeg_recompression
=
true
;
bool
jpeg_compress_boxes
=
true
;
bool
jpeg_keep_exif
=
true
;
bool
jpeg_keep_xmp
=
true
;
bool
jpeg_keep_jumbf
=
true
;
float
photon_noise_iso
=
0
;
ModularOptions
options
;
int
responsive
=
-
1
;
std
:
:
vector
<
SqueezeParams
>
squeezes
;
int
colorspace
=
-
1
;
float
channel_colors_pre_transform_percent
=
95
.
f
;
float
channel_colors_percent
=
80
.
f
;
int
palette_colors
=
1
<
<
10
;
bool
lossy_palette
=
false
;
bool
IsLossless
(
)
const
{
return
modular_mode
&
&
ModularPartIsLossless
(
)
;
}
bool
ModularPartIsLossless
(
)
const
{
if
(
modular_mode
)
{
if
(
butteraugli_distance
!
=
0
|
|
color_transform
=
=
jxl
:
:
ColorTransform
:
:
kXYB
)
return
false
;
}
for
(
float
f
:
ec_distance
)
{
if
(
f
>
0
)
return
false
;
if
(
f
<
0
&
&
butteraugli_distance
!
=
0
)
return
false
;
}
if
(
!
modular_mode
&
&
ec_distance
.
empty
(
)
)
return
false
;
return
true
;
}
void
SetLossless
(
)
{
modular_mode
=
true
;
butteraugli_distance
=
0
.
0f
;
for
(
float
&
f
:
ec_distance
)
f
=
0
.
0f
;
color_transform
=
jxl
:
:
ColorTransform
:
:
kNone
;
}
int
resampling
=
-
1
;
int
ec_resampling
=
-
1
;
bool
already_downsampled
=
false
;
float
original_butteraugli_distance
=
-
1
.
0f
;
float
quant_ac_rescale
=
1
.
0
;
int
level
=
-
1
;
int
buffering
=
0
;
std
:
:
vector
<
float
>
manual_noise
;
std
:
:
vector
<
float
>
manual_xyb_factors
;
Tree
custom_fixed_tree
;
Splines
custom_splines
;
const
ProgressiveMode
*
custom_progressive_mode
=
nullptr
;
JxlDebugImageCallback
debug_image
=
nullptr
;
void
*
debug_image_opaque
;
}
;
static
constexpr
float
kMinButteraugliForDynamicAR
=
0
.
5f
;
static
constexpr
float
kMinButteraugliForDots
=
3
.
0f
;
static
constexpr
float
kMinButteraugliToSubtractOriginalPatches
=
3
.
0f
;
static
constexpr
float
kMinButteraugliForNoise
=
99
.
0f
;
static
constexpr
float
kMinButteraugliDistance
=
0
.
001f
;
static
constexpr
size_t
kEncTileDim
=
64
;
static
constexpr
size_t
kEncTileDimInBlocks
=
kEncTileDim
/
kBlockDim
;
}
#
endif
