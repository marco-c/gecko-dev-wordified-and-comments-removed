#
ifndef
LIB_JXL_DECODE_TO_JPEG_H_
#
define
LIB_JXL_DECODE_TO_JPEG_H_
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
jxl
/
decode
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
common
.
h
"
#
include
"
lib
/
jxl
/
image_bundle
.
h
"
#
include
"
lib
/
jxl
/
jpeg
/
dec_jpeg_data
.
h
"
#
if
JPEGXL_ENABLE_TRANSCODE_JPEG
#
include
"
lib
/
jxl
/
jpeg
/
dec_jpeg_data_writer
.
h
"
#
endif
namespace
jxl
{
#
if
JPEGXL_ENABLE_TRANSCODE_JPEG
class
JxlToJpegDecoder
{
public
:
bool
IsOutputSet
(
)
const
{
return
next_out_
!
=
nullptr
;
}
bool
IsParsingBox
(
)
const
{
return
inside_box_
;
}
const
jpeg
:
:
JPEGData
*
JpegData
(
)
const
{
return
jpeg_data_
.
get
(
)
;
}
jpeg
:
:
JPEGData
*
ReleaseJpegData
(
)
{
return
jpeg_data_
.
release
(
)
;
}
JxlDecoderStatus
SetOutputBuffer
(
uint8_t
*
data
size_t
size
)
{
if
(
next_out_
)
return
JXL_DEC_ERROR
;
next_out_
=
data
;
avail_size_
=
size
;
return
JXL_DEC_SUCCESS
;
}
size_t
ReleaseOutputBuffer
(
)
{
size_t
result
=
avail_size_
;
next_out_
=
nullptr
;
avail_size_
=
0
;
return
result
;
}
void
StartBox
(
uint64_t
box_size
size_t
contents_size
)
{
buffer_
.
clear
(
)
;
inside_box_
=
true
;
if
(
box_size
=
=
0
)
{
box_until_eof_
=
true
;
}
else
{
box_size_
=
contents_size
;
}
}
JxlDecoderStatus
Process
(
const
uint8_t
*
*
next_in
size_t
*
avail_in
)
;
Status
SetImageBundleJpegData
(
ImageBundle
*
ib
)
{
if
(
IsOutputSet
(
)
&
&
jpeg_data_
!
=
nullptr
)
{
if
(
!
jpeg
:
:
SetJPEGDataFromICC
(
ib
-
>
metadata
(
)
-
>
color_encoding
.
ICC
(
)
jpeg_data_
.
get
(
)
)
)
{
return
false
;
}
ib
-
>
jpeg_data
.
reset
(
jpeg_data_
.
release
(
)
)
;
}
return
true
;
}
JxlDecoderStatus
WriteOutput
(
const
jpeg
:
:
JPEGData
&
jpeg_data
)
{
uint8_t
*
tmp_next_out
=
next_out_
;
size_t
tmp_avail_size
=
avail_size_
;
auto
write
=
[
&
tmp_next_out
&
tmp_avail_size
]
(
const
uint8_t
*
buf
size_t
len
)
{
size_t
to_write
=
std
:
:
min
<
size_t
>
(
tmp_avail_size
len
)
;
memcpy
(
tmp_next_out
buf
to_write
)
;
tmp_next_out
+
=
to_write
;
tmp_avail_size
-
=
to_write
;
return
to_write
;
}
;
Status
write_result
=
jpeg
:
:
WriteJpeg
(
jpeg_data
write
)
;
if
(
!
write_result
)
{
if
(
tmp_avail_size
=
=
0
)
{
return
JXL_DEC_JPEG_NEED_MORE_OUTPUT
;
}
return
JXL_DEC_ERROR
;
}
next_out_
=
tmp_next_out
;
avail_size_
=
tmp_avail_size
;
return
JXL_DEC_SUCCESS
;
}
private
:
std
:
:
vector
<
uint8_t
>
buffer_
;
std
:
:
unique_ptr
<
jpeg
:
:
JPEGData
>
jpeg_data_
;
bool
inside_box_
=
false
;
bool
box_until_eof_
=
false
;
size_t
box_size_
=
0
;
uint8_t
*
next_out_
=
nullptr
;
size_t
avail_size_
=
0
;
}
;
#
else
class
JxlToJpegDecoder
{
public
:
bool
IsOutputSet
(
)
const
{
return
false
;
}
bool
IsParsingBox
(
)
const
{
return
false
;
}
const
jpeg
:
:
JPEGData
*
JpegData
(
)
const
{
return
nullptr
;
}
jpeg
:
:
JPEGData
*
ReleaseJpegData
(
)
{
return
nullptr
;
}
JxlDecoderStatus
SetOutputBuffer
(
uint8_t
*
size_t
)
{
return
JXL_DEC_ERROR
;
}
size_t
ReleaseOutputBuffer
(
)
{
return
0
;
}
void
StartBox
(
uint64_t
size_t
)
{
}
JxlDecoderStatus
Process
(
const
uint8_t
*
*
next_in
size_t
*
avail_in
)
{
return
JXL_DEC_ERROR
;
}
Status
SetImageBundleJpegData
(
ImageBundle
*
)
{
return
true
;
}
JxlDecoderStatus
WriteOutput
(
const
jpeg
:
:
JPEGData
&
)
{
return
JXL_DEC_SUCCESS
;
}
}
;
#
endif
}
#
endif
