#
include
"
lib
/
jxl
/
ans_common
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
numeric
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
ans_params
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
namespace
jxl
{
std
:
:
vector
<
int32_t
>
CreateFlatHistogram
(
int
length
int
total_count
)
{
JXL_DASSERT
(
length
>
0
)
;
JXL_DASSERT
(
length
<
=
total_count
)
;
const
int
count
=
total_count
/
length
;
std
:
:
vector
<
int32_t
>
result
(
length
count
)
;
const
int
rem_counts
=
total_count
%
length
;
for
(
int
i
=
0
;
i
<
rem_counts
;
+
+
i
)
{
+
+
result
[
i
]
;
}
return
result
;
}
Status
InitAliasTable
(
std
:
:
vector
<
int32_t
>
distribution
uint32_t
log_range
size_t
log_alpha_size
AliasTable
:
:
Entry
*
JXL_RESTRICT
a
)
{
const
uint32_t
range
=
1
<
<
log_range
;
const
size_t
table_size
=
1
<
<
log_alpha_size
;
JXL_ENSURE
(
table_size
<
=
range
)
;
while
(
!
distribution
.
empty
(
)
&
&
distribution
.
back
(
)
=
=
0
)
{
distribution
.
pop_back
(
)
;
}
if
(
distribution
.
empty
(
)
)
{
distribution
.
emplace_back
(
range
)
;
}
JXL_ENSURE
(
distribution
.
size
(
)
<
=
table_size
)
;
const
uint32_t
entry_size
=
range
>
>
log_alpha_size
;
int
single_symbol
=
-
1
;
int
sum
=
0
;
for
(
size_t
sym
=
0
;
sym
<
distribution
.
size
(
)
;
sym
+
+
)
{
int32_t
v
=
distribution
[
sym
]
;
sum
+
=
v
;
if
(
v
=
=
ANS_TAB_SIZE
)
{
JXL_ENSURE
(
single_symbol
=
=
-
1
)
;
single_symbol
=
sym
;
}
}
JXL_ENSURE
(
static_cast
<
uint32_t
>
(
sum
)
=
=
range
)
;
if
(
single_symbol
!
=
-
1
)
{
uint8_t
sym
=
single_symbol
;
JXL_ENSURE
(
single_symbol
=
=
sym
)
;
for
(
size_t
i
=
0
;
i
<
table_size
;
i
+
+
)
{
a
[
i
]
.
right_value
=
sym
;
a
[
i
]
.
cutoff
=
0
;
a
[
i
]
.
offsets1
=
entry_size
*
i
;
a
[
i
]
.
freq0
=
0
;
a
[
i
]
.
freq1_xor_freq0
=
ANS_TAB_SIZE
;
}
return
true
;
}
std
:
:
vector
<
uint32_t
>
underfull_posn
;
std
:
:
vector
<
uint32_t
>
overfull_posn
;
std
:
:
vector
<
uint32_t
>
cutoffs
(
1
<
<
log_alpha_size
)
;
for
(
size_t
i
=
0
;
i
<
distribution
.
size
(
)
;
i
+
+
)
{
cutoffs
[
i
]
=
distribution
[
i
]
;
if
(
cutoffs
[
i
]
>
entry_size
)
{
overfull_posn
.
push_back
(
i
)
;
}
else
if
(
cutoffs
[
i
]
<
entry_size
)
{
underfull_posn
.
push_back
(
i
)
;
}
}
for
(
uint32_t
i
=
distribution
.
size
(
)
;
i
<
table_size
;
i
+
+
)
{
cutoffs
[
i
]
=
0
;
underfull_posn
.
push_back
(
i
)
;
}
while
(
!
overfull_posn
.
empty
(
)
)
{
uint32_t
overfull_i
=
overfull_posn
.
back
(
)
;
overfull_posn
.
pop_back
(
)
;
JXL_ENSURE
(
!
underfull_posn
.
empty
(
)
)
;
uint32_t
underfull_i
=
underfull_posn
.
back
(
)
;
underfull_posn
.
pop_back
(
)
;
uint32_t
underfull_by
=
entry_size
-
cutoffs
[
underfull_i
]
;
cutoffs
[
overfull_i
]
-
=
underfull_by
;
a
[
underfull_i
]
.
right_value
=
overfull_i
;
a
[
underfull_i
]
.
offsets1
=
cutoffs
[
overfull_i
]
;
if
(
cutoffs
[
overfull_i
]
<
entry_size
)
{
underfull_posn
.
push_back
(
overfull_i
)
;
}
else
if
(
cutoffs
[
overfull_i
]
>
entry_size
)
{
overfull_posn
.
push_back
(
overfull_i
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
table_size
;
i
+
+
)
{
if
(
cutoffs
[
i
]
=
=
entry_size
)
{
a
[
i
]
.
right_value
=
i
;
a
[
i
]
.
offsets1
=
0
;
a
[
i
]
.
cutoff
=
0
;
}
else
{
a
[
i
]
.
offsets1
-
=
cutoffs
[
i
]
;
a
[
i
]
.
cutoff
=
cutoffs
[
i
]
;
}
const
size_t
freq0
=
i
<
distribution
.
size
(
)
?
distribution
[
i
]
:
0
;
const
size_t
i1
=
a
[
i
]
.
right_value
;
const
size_t
freq1
=
i1
<
distribution
.
size
(
)
?
distribution
[
i1
]
:
0
;
a
[
i
]
.
freq0
=
static_cast
<
uint16_t
>
(
freq0
)
;
a
[
i
]
.
freq1_xor_freq0
=
static_cast
<
uint16_t
>
(
freq1
^
freq0
)
;
}
return
true
;
}
}
