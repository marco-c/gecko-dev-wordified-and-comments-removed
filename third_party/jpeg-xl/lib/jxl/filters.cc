#
include
"
lib
/
jxl
/
filters
.
h
"
#
include
<
cmath
>
#
include
"
lib
/
jxl
/
base
/
profiler
.
h
"
namespace
jxl
{
Status
FilterWeights
:
:
Init
(
const
LoopFilter
&
lf
const
FrameDimensions
&
frame_dim
)
{
if
(
lf
.
epf_iters
>
0
)
{
sigma
=
ImageF
(
frame_dim
.
xsize_blocks
+
2
*
kSigmaPadding
frame_dim
.
ysize_blocks
+
2
*
kSigmaPadding
)
;
}
if
(
lf
.
gab
)
{
JXL_RETURN_IF_ERROR
(
GaborishWeights
(
lf
)
)
;
}
return
true
;
}
Status
FilterWeights
:
:
GaborishWeights
(
const
LoopFilter
&
lf
)
{
const
float
kZeroEpsilon
=
1e
-
6
;
gab_weights
[
0
]
=
1
;
gab_weights
[
1
]
=
lf
.
gab_x_weight1
;
gab_weights
[
2
]
=
lf
.
gab_x_weight2
;
gab_weights
[
3
]
=
1
;
gab_weights
[
4
]
=
lf
.
gab_y_weight1
;
gab_weights
[
5
]
=
lf
.
gab_y_weight2
;
gab_weights
[
6
]
=
1
;
gab_weights
[
7
]
=
lf
.
gab_b_weight1
;
gab_weights
[
8
]
=
lf
.
gab_b_weight2
;
for
(
size_t
c
=
0
;
c
<
3
;
c
+
+
)
{
const
float
div
=
gab_weights
[
3
*
c
]
+
4
*
(
gab_weights
[
3
*
c
+
1
]
+
gab_weights
[
3
*
c
+
2
]
)
;
if
(
std
:
:
abs
(
div
)
<
kZeroEpsilon
)
{
return
JXL_FAILURE
(
"
Gaborish
weights
lead
to
near
0
unnormalized
kernel
"
)
;
}
const
float
mul
=
1
.
0f
/
div
;
gab_weights
[
3
*
c
]
*
=
mul
;
gab_weights
[
3
*
c
+
1
]
*
=
mul
;
gab_weights
[
3
*
c
+
2
]
*
=
mul
;
}
return
true
;
}
void
FilterPipeline
:
:
ApplyFiltersRow
(
const
LoopFilter
&
lf
const
FilterWeights
&
filter_weights
ssize_t
y
)
{
PROFILER_ZONE
(
"
Gaborish
+
EPF
"
)
;
JXL_DASSERT
(
num_filters
!
=
0
)
;
JXL_ASSERT
(
y
<
static_cast
<
ssize_t
>
(
image_rect
.
ysize
(
)
+
lf
.
Padding
(
)
)
)
;
ssize_t
rows_needed
=
-
static_cast
<
ssize_t
>
(
lf
.
Padding
(
)
)
;
const
size_t
sigma_x_offset
=
image_rect
.
x0
(
)
%
kBlockDim
-
image_rect
.
x0
(
)
%
GroupBorderAssigner
:
:
kPaddingXRound
;
for
(
size_t
i
=
0
;
i
<
num_filters
;
i
+
+
)
{
const
FilterStep
&
filter
=
filters
[
i
]
;
rows_needed
+
=
filter
.
filter_def
.
border
;
y
-
=
filter
.
filter_def
.
border
;
if
(
y
<
rows_needed
)
return
;
FilterRows
rows
(
filter
.
filter_def
.
border
)
;
filter
.
set_input_rows
(
filter
&
rows
y
)
;
filter
.
set_output_rows
(
filter
&
rows
y
)
;
const
size_t
sigma_y
=
kMaxFilterPadding
+
image_rect
.
y0
(
)
+
y
;
if
(
compute_sigma
)
{
rows
.
SetSigma
(
filter_weights
.
sigma
sigma_y
image_rect
.
x0
(
)
-
image_rect
.
x0
(
)
%
kBlockDim
)
;
}
filter
.
filter_def
.
apply
(
rows
lf
filter_weights
filter
.
filter_x0
filter
.
filter_x1
sigma_x_offset
sigma_y
%
kBlockDim
)
;
}
JXL_DASSERT
(
rows_needed
=
=
0
)
;
}
}
