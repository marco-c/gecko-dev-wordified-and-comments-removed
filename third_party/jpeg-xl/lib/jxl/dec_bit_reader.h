#
ifndef
LIB_JXL_DEC_BIT_READER_H_
#
define
LIB_JXL_DEC_BIT_READER_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
ifdef
__BMI2__
#
include
<
immintrin
.
h
>
#
endif
#
include
"
lib
/
jxl
/
base
/
byte_order
.
h
"
#
include
"
lib
/
jxl
/
base
/
common
.
h
"
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
namespace
jxl
{
class
BitReader
{
public
:
static
constexpr
size_t
kMaxBitsPerCall
=
56
;
BitReader
(
)
:
buf_
(
0
)
bits_in_buf_
(
0
)
next_byte_
{
nullptr
}
end_minus_8_
{
nullptr
}
first_byte_
(
nullptr
)
{
}
BitReader
(
const
BitReader
&
)
=
delete
;
template
<
class
ArrayLike
>
explicit
BitReader
(
const
ArrayLike
&
bytes
)
:
buf_
(
0
)
bits_in_buf_
(
0
)
next_byte_
(
bytes
.
data
(
)
)
end_minus_8_
(
bytes
.
data
(
)
-
8
+
bytes
.
size
(
)
)
first_byte_
(
bytes
.
data
(
)
)
{
Refill
(
)
;
}
~
BitReader
(
)
{
JXL_DASSERT
(
close_called_
|
|
!
first_byte_
)
;
}
BitReader
&
operator
=
(
BitReader
&
&
other
)
noexcept
{
JXL_DASSERT
(
close_called_
|
|
!
first_byte_
)
;
JXL_DASSERT
(
!
other
.
close_called_
)
;
buf_
=
other
.
buf_
;
bits_in_buf_
=
other
.
bits_in_buf_
;
next_byte_
=
other
.
next_byte_
;
end_minus_8_
=
other
.
end_minus_8_
;
first_byte_
=
other
.
first_byte_
;
overread_bytes_
=
other
.
overread_bytes_
;
close_called_
=
other
.
close_called_
;
other
.
first_byte_
=
nullptr
;
other
.
next_byte_
=
nullptr
;
return
*
this
;
}
BitReader
&
operator
=
(
const
BitReader
&
other
)
=
delete
;
JXL_INLINE
void
Refill
(
)
{
if
(
JXL_UNLIKELY
(
next_byte_
>
end_minus_8_
)
)
{
BoundsCheckedRefill
(
)
;
}
else
{
buf_
|
=
LoadLE64
(
next_byte_
)
<
<
bits_in_buf_
;
next_byte_
+
=
(
63
-
bits_in_buf_
)
>
>
3
;
bits_in_buf_
|
=
56
;
JXL_DASSERT
(
56
<
=
bits_in_buf_
&
&
bits_in_buf_
<
64
)
;
}
}
template
<
size_t
N
>
JXL_INLINE
uint64_t
PeekFixedBits
(
)
const
{
static_assert
(
N
<
=
kMaxBitsPerCall
"
Reading
too
many
bits
in
one
call
.
"
)
;
JXL_DASSERT
(
!
close_called_
)
;
return
buf_
&
(
(
1ULL
<
<
N
)
-
1
)
;
}
JXL_INLINE
uint64_t
PeekBits
(
size_t
nbits
)
const
{
JXL_DASSERT
(
nbits
<
=
kMaxBitsPerCall
)
;
JXL_DASSERT
(
!
close_called_
)
;
#
if
defined
(
__BMI2__
)
&
&
defined
(
__x86_64__
)
return
_bzhi_u64
(
buf_
nbits
)
;
#
else
const
uint64_t
mask
=
(
1ULL
<
<
nbits
)
-
1
;
return
buf_
&
mask
;
#
endif
}
JXL_INLINE
void
Consume
(
size_t
num_bits
)
{
JXL_DASSERT
(
!
close_called_
)
;
JXL_DASSERT
(
bits_in_buf_
>
=
num_bits
)
;
if
(
JXL_CRASH_ON_ERROR
)
{
JXL_DASSERT
(
bits_in_buf_
>
=
num_bits
+
overread_bytes_
*
kBitsPerByte
)
;
}
bits_in_buf_
-
=
num_bits
;
buf_
>
>
=
num_bits
;
}
JXL_INLINE
uint64_t
ReadBits
(
size_t
nbits
)
{
JXL_DASSERT
(
!
close_called_
)
;
Refill
(
)
;
const
uint64_t
bits
=
PeekBits
(
nbits
)
;
Consume
(
nbits
)
;
return
bits
;
}
template
<
size_t
N
>
JXL_INLINE
uint64_t
ReadFixedBits
(
)
{
JXL_DASSERT
(
!
close_called_
)
;
Refill
(
)
;
const
uint64_t
bits
=
PeekFixedBits
<
N
>
(
)
;
Consume
(
N
)
;
return
bits
;
}
void
SkipBits
(
size_t
skip
)
{
JXL_DASSERT
(
!
close_called_
)
;
if
(
JXL_UNLIKELY
(
skip
<
=
bits_in_buf_
)
)
{
Consume
(
skip
)
;
return
;
}
skip
-
=
bits_in_buf_
;
bits_in_buf_
=
0
;
buf_
=
0
;
const
size_t
whole_bytes
=
skip
/
kBitsPerByte
;
skip
%
=
kBitsPerByte
;
if
(
JXL_UNLIKELY
(
whole_bytes
>
static_cast
<
size_t
>
(
end_minus_8_
+
8
-
next_byte_
)
)
)
{
next_byte_
=
end_minus_8_
+
8
;
skip
+
=
kBitsPerByte
;
}
else
{
next_byte_
+
=
whole_bytes
;
}
Refill
(
)
;
Consume
(
skip
)
;
}
size_t
TotalBitsConsumed
(
)
const
{
const
size_t
bytes_read
=
static_cast
<
size_t
>
(
next_byte_
-
first_byte_
)
;
return
(
bytes_read
+
overread_bytes_
)
*
kBitsPerByte
-
bits_in_buf_
;
}
Status
JumpToByteBoundary
(
)
{
const
size_t
remainder
=
TotalBitsConsumed
(
)
%
kBitsPerByte
;
if
(
remainder
=
=
0
)
return
true
;
if
(
JXL_UNLIKELY
(
ReadBits
(
kBitsPerByte
-
remainder
)
!
=
0
)
)
{
return
JXL_FAILURE
(
"
Non
-
zero
padding
bits
"
)
;
}
return
true
;
}
const
uint8_t
*
FirstByte
(
)
const
{
return
first_byte_
;
}
size_t
TotalBytes
(
)
const
{
return
static_cast
<
size_t
>
(
end_minus_8_
+
8
-
first_byte_
)
;
}
Status
AllReadsWithinBounds
(
)
{
checked_out_of_bounds_bits_
=
TotalBitsConsumed
(
)
;
if
(
TotalBitsConsumed
(
)
>
TotalBytes
(
)
*
kBitsPerByte
)
{
return
false
;
}
return
true
;
}
Status
Close
(
)
{
JXL_DASSERT
(
!
close_called_
)
;
close_called_
=
true
;
if
(
!
first_byte_
)
return
true
;
if
(
TotalBitsConsumed
(
)
>
checked_out_of_bounds_bits_
&
&
TotalBitsConsumed
(
)
>
TotalBytes
(
)
*
kBitsPerByte
)
{
return
JXL_FAILURE
(
"
Read
more
bits
than
available
in
the
bit_reader
"
)
;
}
return
true
;
}
private
:
JXL_NOINLINE
void
BoundsCheckedRefill
(
)
{
const
uint8_t
*
end
=
end_minus_8_
+
8
;
for
(
;
bits_in_buf_
<
64
-
kBitsPerByte
;
bits_in_buf_
+
=
kBitsPerByte
)
{
if
(
next_byte_
>
=
end
)
break
;
buf_
|
=
static_cast
<
uint64_t
>
(
*
next_byte_
+
+
)
<
<
bits_in_buf_
;
}
JXL_DASSERT
(
bits_in_buf_
<
64
)
;
size_t
extra_bytes
=
(
63
-
bits_in_buf_
)
/
kBitsPerByte
;
overread_bytes_
+
=
extra_bytes
;
bits_in_buf_
+
=
extra_bytes
*
kBitsPerByte
;
JXL_DASSERT
(
bits_in_buf_
<
64
)
;
JXL_DASSERT
(
bits_in_buf_
>
=
56
)
;
}
JXL_NOINLINE
uint32_t
BoundsCheckedReadByteAlignedWord
(
)
{
if
(
next_byte_
+
1
<
end_minus_8_
+
8
)
{
uint32_t
ret
=
LoadLE16
(
next_byte_
)
;
next_byte_
+
=
2
;
return
ret
;
}
overread_bytes_
+
=
2
;
return
0
;
}
uint64_t
buf_
;
size_t
bits_in_buf_
;
const
uint8_t
*
JXL_RESTRICT
next_byte_
;
const
uint8_t
*
end_minus_8_
;
const
uint8_t
*
first_byte_
;
uint64_t
overread_bytes_
{
0
}
;
bool
close_called_
{
false
}
;
uint64_t
checked_out_of_bounds_bits_
{
0
}
;
}
;
class
BitReaderScopedCloser
{
public
:
BitReaderScopedCloser
(
BitReader
&
reader
Status
&
status
)
:
reader_
(
&
reader
)
status_
(
&
status
)
{
}
~
BitReaderScopedCloser
(
)
{
if
(
reader_
!
=
nullptr
)
{
Status
close_ret
=
reader_
-
>
Close
(
)
;
if
(
!
close_ret
)
*
status_
=
close_ret
;
}
}
BitReaderScopedCloser
(
const
BitReaderScopedCloser
&
)
=
delete
;
private
:
BitReader
*
reader_
;
Status
*
status_
;
}
;
}
#
endif
