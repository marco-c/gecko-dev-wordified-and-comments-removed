#
ifndef
LIB_JXL_CODEC_IN_OUT_H_
#
define
LIB_JXL_CODEC_IN_OUT_H_
#
include
<
stddef
.
h
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
common
.
h
"
#
include
"
lib
/
jxl
/
frame_header
.
h
"
#
include
"
lib
/
jxl
/
headers
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
#
include
"
lib
/
jxl
/
image_bundle
.
h
"
#
include
"
lib
/
jxl
/
luminance
.
h
"
namespace
jxl
{
struct
CodecInterval
{
CodecInterval
(
)
=
default
;
constexpr
CodecInterval
(
float
min
float
max
)
:
min
(
min
)
width
(
max
-
min
)
{
}
float
min
=
0
.
0f
;
float
width
=
1
.
0f
;
}
;
struct
SizeConstraints
{
uint32_t
dec_max_xsize
=
0xFFFFFFFFu
;
uint32_t
dec_max_ysize
=
0xFFFFFFFFu
;
uint64_t
dec_max_pixels
=
0xFFFFFFFFu
;
}
;
template
<
typename
T
class
=
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
>
:
:
type
>
Status
VerifyDimensions
(
const
SizeConstraints
*
constraints
T
xs
T
ys
)
{
if
(
!
constraints
)
return
true
;
if
(
xs
=
=
0
|
|
ys
=
=
0
)
return
JXL_FAILURE
(
"
Empty
image
.
"
)
;
if
(
xs
>
constraints
-
>
dec_max_xsize
)
return
JXL_FAILURE
(
"
Image
too
wide
.
"
)
;
if
(
ys
>
constraints
-
>
dec_max_ysize
)
return
JXL_FAILURE
(
"
Image
too
tall
.
"
)
;
const
uint64_t
num_pixels
=
static_cast
<
uint64_t
>
(
xs
)
*
ys
;
if
(
num_pixels
>
constraints
-
>
dec_max_pixels
)
{
return
JXL_FAILURE
(
"
Image
too
big
.
"
)
;
}
return
true
;
}
using
CodecIntervals
=
std
:
:
array
<
CodecInterval
4
>
;
class
DecoderHints
{
public
:
void
Add
(
const
std
:
:
string
&
key
const
std
:
:
string
&
value
)
{
kv_
.
emplace_back
(
key
value
)
;
}
template
<
class
Func
>
Status
Foreach
(
const
Func
&
func
)
const
{
for
(
const
KeyValue
&
kv
:
kv_
)
{
Status
ok
=
func
(
kv
.
key
kv
.
value
)
;
if
(
!
ok
)
{
return
JXL_FAILURE
(
"
DecoderHints
:
:
Foreach
returned
false
"
)
;
}
}
return
true
;
}
private
:
struct
KeyValue
{
KeyValue
(
std
:
:
string
key
std
:
:
string
value
)
:
key
(
std
:
:
move
(
key
)
)
value
(
std
:
:
move
(
value
)
)
{
}
std
:
:
string
key
;
std
:
:
string
value
;
}
;
std
:
:
vector
<
KeyValue
>
kv_
;
}
;
struct
Blobs
{
PaddedBytes
exif
;
PaddedBytes
iptc
;
PaddedBytes
jumbf
;
PaddedBytes
xmp
;
}
;
enum
class
DecodeTarget
{
kPixels
kQuantizedCoeffs
}
;
class
CodecInOut
{
public
:
CodecInOut
(
)
:
preview_frame
(
&
metadata
.
m
)
{
frames
.
reserve
(
1
)
;
frames
.
emplace_back
(
&
metadata
.
m
)
;
}
CodecInOut
(
CodecInOut
&
&
)
=
default
;
CodecInOut
&
operator
=
(
CodecInOut
&
&
)
=
default
;
size_t
LastStillFrame
(
)
const
{
JXL_DASSERT
(
frames
.
size
(
)
>
0
)
;
size_t
last
=
0
;
for
(
size_t
i
=
0
;
i
<
frames
.
size
(
)
;
i
+
+
)
{
last
=
i
;
if
(
frames
[
i
]
.
duration
>
0
)
break
;
}
return
last
;
}
ImageBundle
&
Main
(
)
{
return
frames
[
LastStillFrame
(
)
]
;
}
const
ImageBundle
&
Main
(
)
const
{
return
frames
[
LastStillFrame
(
)
]
;
}
void
SetFromImage
(
Image3F
&
&
color
const
ColorEncoding
&
c_current
)
{
Main
(
)
.
SetFromImage
(
std
:
:
move
(
color
)
c_current
)
;
SetIntensityTarget
(
this
)
;
SetSize
(
Main
(
)
.
xsize
(
)
Main
(
)
.
ysize
(
)
)
;
}
void
SetSize
(
size_t
xsize
size_t
ysize
)
{
JXL_CHECK
(
metadata
.
size
.
Set
(
xsize
ysize
)
)
;
}
void
CheckMetadata
(
)
const
{
JXL_CHECK
(
metadata
.
m
.
bit_depth
.
bits_per_sample
!
=
0
)
;
JXL_CHECK
(
!
metadata
.
m
.
color_encoding
.
ICC
(
)
.
empty
(
)
)
;
if
(
preview_frame
.
xsize
(
)
!
=
0
)
preview_frame
.
VerifyMetadata
(
)
;
JXL_CHECK
(
preview_frame
.
metadata
(
)
=
=
&
metadata
.
m
)
;
for
(
const
ImageBundle
&
ib
:
frames
)
{
ib
.
VerifyMetadata
(
)
;
JXL_CHECK
(
ib
.
metadata
(
)
=
=
&
metadata
.
m
)
;
}
}
size_t
xsize
(
)
const
{
return
metadata
.
size
.
xsize
(
)
;
}
size_t
ysize
(
)
const
{
return
metadata
.
size
.
ysize
(
)
;
}
void
ShrinkTo
(
size_t
xsize
size_t
ysize
)
{
for
(
ImageBundle
&
ib
:
frames
)
{
ib
.
ShrinkTo
(
xsize
ysize
)
;
}
SetSize
(
xsize
ysize
)
;
}
Status
TransformTo
(
const
ColorEncoding
&
c_desired
ThreadPool
*
pool
=
nullptr
)
{
if
(
metadata
.
m
.
have_preview
)
{
JXL_RETURN_IF_ERROR
(
preview_frame
.
TransformTo
(
c_desired
pool
)
)
;
}
for
(
ImageBundle
&
ib
:
frames
)
{
JXL_RETURN_IF_ERROR
(
ib
.
TransformTo
(
c_desired
pool
)
)
;
}
return
true
;
}
SizeConstraints
constraints
;
DecoderHints
dec_hints
;
DecodeTarget
dec_target
=
DecodeTarget
:
:
kPixels
;
float
target_nits
=
0
;
uint64_t
dec_pixels
=
0
;
Blobs
blobs
;
CodecMetadata
metadata
;
ImageBundle
preview_frame
;
std
:
:
vector
<
ImageBundle
>
frames
;
bool
use_sjpeg
=
false
;
size_t
jpeg_quality
;
}
;
}
#
endif
