#
include
"
lib
/
jxl
/
image
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
cache_aligned
.
h
"
#
include
"
lib
/
jxl
/
simd_util
.
h
"
#
if
defined
(
MEMORY_SANITIZER
)
#
include
"
lib
/
jxl
/
base
/
common
.
h
"
#
include
"
lib
/
jxl
/
sanitizers
.
h
"
#
endif
namespace
jxl
{
namespace
detail
{
namespace
{
void
InitializePadding
(
PlaneBase
&
plane
const
size_t
sizeof_t
)
{
#
if
defined
(
MEMORY_SANITIZER
)
size_t
xsize
=
plane
.
xsize
(
)
;
size_t
ysize
=
plane
.
ysize
(
)
;
if
(
xsize
=
=
0
|
|
ysize
=
=
0
)
return
;
const
size_t
vec_size
=
MaxVectorSize
(
)
;
if
(
vec_size
=
=
0
)
return
;
const
size_t
valid_size
=
xsize
*
sizeof_t
;
const
size_t
initialize_size
=
RoundUpTo
(
valid_size
vec_size
)
;
if
(
valid_size
=
=
initialize_size
)
return
;
for
(
size_t
y
=
0
;
y
<
ysize
;
+
+
y
)
{
uint8_t
*
JXL_RESTRICT
row
=
plane
.
bytes
(
)
+
y
*
plane
.
bytes_per_row
(
)
;
#
if
defined
(
__clang__
)
&
&
\
(
(
!
defined
(
__apple_build_version__
)
&
&
__clang_major__
<
=
6
)
|
|
\
(
defined
(
__apple_build_version__
)
&
&
\
__apple_build_version__
<
=
10001145
)
)
std
:
:
fill
(
row
msan
:
:
kSanitizerSentinelByte
initialize_size
)
;
#
else
memset
(
row
+
valid_size
msan
:
:
kSanitizerSentinelByte
initialize_size
-
valid_size
)
;
#
endif
}
#
endif
}
}
PlaneBase
:
:
PlaneBase
(
const
size_t
xsize
const
size_t
ysize
const
size_t
sizeof_t
)
:
xsize_
(
static_cast
<
uint32_t
>
(
xsize
)
)
ysize_
(
static_cast
<
uint32_t
>
(
ysize
)
)
orig_xsize_
(
static_cast
<
uint32_t
>
(
xsize
)
)
orig_ysize_
(
static_cast
<
uint32_t
>
(
ysize
)
)
bytes_per_row_
(
BytesPerRow
(
xsize_
sizeof_t
)
)
bytes_
(
nullptr
)
sizeof_t_
(
sizeof_t
)
{
JXL_CHECK
(
xsize
=
=
xsize_
)
;
JXL_CHECK
(
ysize
=
=
ysize_
)
;
JXL_ASSERT
(
sizeof_t
=
=
1
|
|
sizeof_t
=
=
2
|
|
sizeof_t
=
=
4
|
|
sizeof_t
=
=
8
)
;
}
Status
PlaneBase
:
:
Allocate
(
)
{
JXL_CHECK
(
!
bytes_
.
get
(
)
)
;
if
(
xsize_
=
=
0
|
|
ysize_
=
=
0
)
{
return
true
;
}
bytes_
=
AllocateArray
(
bytes_per_row_
*
ysize_
)
;
if
(
!
bytes_
.
get
(
)
)
{
return
JXL_FAILURE
(
"
Failed
to
allocate
memory
for
image
surface
"
)
;
}
InitializePadding
(
*
this
sizeof_t_
)
;
return
true
;
}
void
PlaneBase
:
:
Swap
(
PlaneBase
&
other
)
{
std
:
:
swap
(
xsize_
other
.
xsize_
)
;
std
:
:
swap
(
ysize_
other
.
ysize_
)
;
std
:
:
swap
(
orig_xsize_
other
.
orig_xsize_
)
;
std
:
:
swap
(
orig_ysize_
other
.
orig_ysize_
)
;
std
:
:
swap
(
bytes_per_row_
other
.
bytes_per_row_
)
;
std
:
:
swap
(
bytes_
other
.
bytes_
)
;
}
}
}
