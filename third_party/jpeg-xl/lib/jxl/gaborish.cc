#
include
"
lib
/
jxl
/
gaborish
.
h
"
#
include
<
stddef
.
h
>
#
include
<
hwy
/
base
.
h
>
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
convolve
.
h
"
#
include
"
lib
/
jxl
/
image_ops
.
h
"
namespace
jxl
{
void
GaborishInverse
(
Image3F
*
in_out
float
mul
ThreadPool
*
pool
)
{
JXL_ASSERT
(
mul
>
=
0
.
0f
)
;
constexpr
float
kGaborish
[
5
]
=
{
-
0
.
092359145662814029f
-
0
.
039253623634014627f
0
.
016176494530216929f
0
.
00083458437774987476f
0
.
004512465323949319f
}
;
WeightsSymmetric5
weights
=
{
{
HWY_REP4
(
1
.
0f
)
}
{
HWY_REP4
(
mul
*
kGaborish
[
0
]
)
}
{
HWY_REP4
(
mul
*
kGaborish
[
2
]
)
}
{
HWY_REP4
(
mul
*
kGaborish
[
1
]
)
}
{
HWY_REP4
(
mul
*
kGaborish
[
4
]
)
}
{
HWY_REP4
(
mul
*
kGaborish
[
3
]
)
}
}
;
double
sum
=
static_cast
<
double
>
(
weights
.
c
[
0
]
)
;
sum
+
=
4
*
weights
.
r
[
0
]
;
sum
+
=
4
*
weights
.
R
[
0
]
;
sum
+
=
4
*
weights
.
d
[
0
]
;
sum
+
=
4
*
weights
.
D
[
0
]
;
sum
+
=
8
*
weights
.
L
[
0
]
;
const
float
normalize
=
static_cast
<
float
>
(
1
.
0
/
sum
)
;
for
(
size_t
i
=
0
;
i
<
4
;
+
+
i
)
{
weights
.
c
[
i
]
*
=
normalize
;
weights
.
r
[
i
]
*
=
normalize
;
weights
.
R
[
i
]
*
=
normalize
;
weights
.
d
[
i
]
*
=
normalize
;
weights
.
D
[
i
]
*
=
normalize
;
weights
.
L
[
i
]
*
=
normalize
;
}
ImageF
temp
=
CopyImage
(
in_out
-
>
Plane
(
2
)
)
;
Symmetric5
(
in_out
-
>
Plane
(
0
)
Rect
(
*
in_out
)
weights
pool
&
in_out
-
>
Plane
(
2
)
)
;
Symmetric5
(
in_out
-
>
Plane
(
1
)
Rect
(
*
in_out
)
weights
pool
&
in_out
-
>
Plane
(
0
)
)
;
Symmetric5
(
temp
Rect
(
*
in_out
)
weights
pool
&
in_out
-
>
Plane
(
1
)
)
;
in_out
-
>
Plane
(
0
)
.
Swap
(
in_out
-
>
Plane
(
1
)
)
;
in_out
-
>
Plane
(
0
)
.
Swap
(
in_out
-
>
Plane
(
2
)
)
;
}
}
