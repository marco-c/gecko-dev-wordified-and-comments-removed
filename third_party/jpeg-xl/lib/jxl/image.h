#
ifndef
LIB_JXL_IMAGE_H_
#
define
LIB_JXL_IMAGE_H_
#
if
defined
(
ADDRESS_SANITIZER
)
|
|
defined
(
MEMORY_SANITIZER
)
|
|
\
defined
(
THREAD_SANITIZER
)
#
include
<
cinttypes
>
#
endif
#
include
<
jxl
/
memory_manager
.
h
>
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
utility
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
memory_manager_internal
.
h
"
namespace
jxl
{
namespace
detail
{
struct
PlaneBase
{
PlaneBase
(
)
:
xsize_
(
0
)
ysize_
(
0
)
orig_xsize_
(
0
)
orig_ysize_
(
0
)
bytes_per_row_
(
0
)
sizeof_t_
(
0
)
{
}
PlaneBase
(
const
PlaneBase
&
other
)
=
delete
;
PlaneBase
&
operator
=
(
const
PlaneBase
&
other
)
=
delete
;
PlaneBase
(
PlaneBase
&
&
other
)
noexcept
=
default
;
PlaneBase
&
operator
=
(
PlaneBase
&
&
other
)
noexcept
=
default
;
~
PlaneBase
(
)
=
default
;
void
Swap
(
PlaneBase
&
other
)
;
void
ShrinkTo
(
const
size_t
xsize
const
size_t
ysize
)
{
JXL_CHECK
(
xsize
<
=
orig_xsize_
)
;
JXL_CHECK
(
ysize
<
=
orig_ysize_
)
;
xsize_
=
static_cast
<
uint32_t
>
(
xsize
)
;
ysize_
=
static_cast
<
uint32_t
>
(
ysize
)
;
}
JXL_INLINE
size_t
xsize
(
)
const
{
return
xsize_
;
}
JXL_INLINE
size_t
ysize
(
)
const
{
return
ysize_
;
}
JXL_INLINE
size_t
bytes_per_row
(
)
const
{
return
bytes_per_row_
;
}
JXL_INLINE
JxlMemoryManager
*
memory_manager
(
)
const
{
return
bytes_
.
memory_manager
(
)
;
}
JXL_INLINE
uint8_t
*
bytes
(
)
{
uint8_t
*
p
=
bytes_
.
address
<
uint8_t
>
(
)
;
return
static_cast
<
uint8_t
*
JXL_RESTRICT
>
(
JXL_ASSUME_ALIGNED
(
p
64
)
)
;
}
JXL_INLINE
const
uint8_t
*
bytes
(
)
const
{
const
uint8_t
*
p
=
bytes_
.
address
<
uint8_t
>
(
)
;
return
static_cast
<
const
uint8_t
*
JXL_RESTRICT
>
(
JXL_ASSUME_ALIGNED
(
p
64
)
)
;
}
protected
:
PlaneBase
(
size_t
xsize
size_t
ysize
size_t
sizeof_t
)
;
Status
Allocate
(
JxlMemoryManager
*
memory_manager
)
;
JXL_INLINE
void
*
VoidRow
(
const
size_t
y
)
const
{
#
if
defined
(
ADDRESS_SANITIZER
)
|
|
defined
(
MEMORY_SANITIZER
)
|
|
\
defined
(
THREAD_SANITIZER
)
if
(
y
>
=
ysize_
)
{
JXL_ABORT
(
"
Row
(
%
"
PRIu64
"
)
in
(
%
u
x
%
u
)
image
\
n
"
static_cast
<
uint64_t
>
(
y
)
xsize_
ysize_
)
;
}
#
endif
uint8_t
*
row
=
bytes_
.
address
<
uint8_t
>
(
)
+
y
*
bytes_per_row_
;
return
JXL_ASSUME_ALIGNED
(
row
64
)
;
}
uint32_t
xsize_
;
uint32_t
ysize_
;
uint32_t
orig_xsize_
;
uint32_t
orig_ysize_
;
size_t
bytes_per_row_
;
AlignedMemory
bytes_
;
size_t
sizeof_t_
;
}
;
}
template
<
typename
ComponentType
>
class
Plane
:
public
detail
:
:
PlaneBase
{
public
:
using
T
=
ComponentType
;
static
constexpr
size_t
kNumPlanes
=
1
;
Plane
(
)
=
default
;
static
StatusOr
<
Plane
>
Create
(
JxlMemoryManager
*
memory_manager
const
size_t
xsize
const
size_t
ysize
)
{
Plane
plane
(
xsize
ysize
sizeof
(
T
)
)
;
JXL_RETURN_IF_ERROR
(
plane
.
Allocate
(
memory_manager
)
)
;
return
plane
;
}
JXL_INLINE
T
*
Row
(
const
size_t
y
)
{
return
static_cast
<
T
*
>
(
VoidRow
(
y
)
)
;
}
JXL_INLINE
const
T
*
Row
(
const
size_t
y
)
const
{
return
static_cast
<
const
T
*
>
(
VoidRow
(
y
)
)
;
}
JXL_INLINE
const
T
*
ConstRow
(
const
size_t
y
)
const
{
return
static_cast
<
const
T
*
>
(
VoidRow
(
y
)
)
;
}
JXL_INLINE
intptr_t
PixelsPerRow
(
)
const
{
return
static_cast
<
intptr_t
>
(
bytes_per_row_
/
sizeof
(
T
)
)
;
}
private
:
Plane
(
size_t
xsize
size_t
ysize
size_t
sizeof_t
)
:
detail
:
:
PlaneBase
(
xsize
ysize
sizeof_t
)
{
}
}
;
using
ImageSB
=
Plane
<
int8_t
>
;
using
ImageB
=
Plane
<
uint8_t
>
;
using
ImageS
=
Plane
<
int16_t
>
;
using
ImageU
=
Plane
<
uint16_t
>
;
using
ImageI
=
Plane
<
int32_t
>
;
using
ImageF
=
Plane
<
float
>
;
using
ImageD
=
Plane
<
double
>
;
template
<
typename
ComponentType
>
class
Image3
{
public
:
using
T
=
ComponentType
;
using
PlaneT
=
jxl
:
:
Plane
<
T
>
;
static
constexpr
size_t
kNumPlanes
=
3
;
Image3
(
)
:
planes_
{
PlaneT
(
)
PlaneT
(
)
PlaneT
(
)
}
{
}
Image3
(
const
Image3
&
other
)
=
delete
;
Image3
&
operator
=
(
const
Image3
&
other
)
=
delete
;
Image3
(
Image3
&
&
other
)
noexcept
{
for
(
size_t
i
=
0
;
i
<
kNumPlanes
;
i
+
+
)
{
planes_
[
i
]
=
std
:
:
move
(
other
.
planes_
[
i
]
)
;
}
}
Image3
&
operator
=
(
Image3
&
&
other
)
noexcept
{
for
(
size_t
i
=
0
;
i
<
kNumPlanes
;
i
+
+
)
{
planes_
[
i
]
=
std
:
:
move
(
other
.
planes_
[
i
]
)
;
}
return
*
this
;
}
static
StatusOr
<
Image3
>
Create
(
JxlMemoryManager
*
memory_manager
const
size_t
xsize
const
size_t
ysize
)
{
StatusOr
<
PlaneT
>
plane0
=
PlaneT
:
:
Create
(
memory_manager
xsize
ysize
)
;
JXL_RETURN_IF_ERROR
(
plane0
.
status
(
)
)
;
StatusOr
<
PlaneT
>
plane1
=
PlaneT
:
:
Create
(
memory_manager
xsize
ysize
)
;
JXL_RETURN_IF_ERROR
(
plane1
.
status
(
)
)
;
StatusOr
<
PlaneT
>
plane2
=
PlaneT
:
:
Create
(
memory_manager
xsize
ysize
)
;
JXL_RETURN_IF_ERROR
(
plane2
.
status
(
)
)
;
return
Image3
(
std
:
:
move
(
plane0
)
.
value
(
)
std
:
:
move
(
plane1
)
.
value
(
)
std
:
:
move
(
plane2
)
.
value
(
)
)
;
}
JXL_INLINE
T
*
PlaneRow
(
const
size_t
c
const
size_t
y
)
{
PlaneRowBoundsCheck
(
c
y
)
;
const
size_t
row_offset
=
y
*
planes_
[
0
]
.
bytes_per_row
(
)
;
void
*
row
=
planes_
[
c
]
.
bytes
(
)
+
row_offset
;
return
static_cast
<
T
*
JXL_RESTRICT
>
(
JXL_ASSUME_ALIGNED
(
row
64
)
)
;
}
JXL_INLINE
const
T
*
PlaneRow
(
const
size_t
c
const
size_t
y
)
const
{
PlaneRowBoundsCheck
(
c
y
)
;
const
size_t
row_offset
=
y
*
planes_
[
0
]
.
bytes_per_row
(
)
;
const
void
*
row
=
planes_
[
c
]
.
bytes
(
)
+
row_offset
;
return
static_cast
<
const
T
*
JXL_RESTRICT
>
(
JXL_ASSUME_ALIGNED
(
row
64
)
)
;
}
JXL_INLINE
const
T
*
ConstPlaneRow
(
const
size_t
c
const
size_t
y
)
const
{
PlaneRowBoundsCheck
(
c
y
)
;
return
PlaneRow
(
c
y
)
;
}
JXL_INLINE
const
PlaneT
&
Plane
(
size_t
idx
)
const
{
return
planes_
[
idx
]
;
}
JXL_INLINE
PlaneT
&
Plane
(
size_t
idx
)
{
return
planes_
[
idx
]
;
}
void
Swap
(
Image3
&
other
)
{
for
(
size_t
c
=
0
;
c
<
3
;
+
+
c
)
{
other
.
planes_
[
c
]
.
Swap
(
planes_
[
c
]
)
;
}
}
void
ShrinkTo
(
const
size_t
xsize
const
size_t
ysize
)
{
for
(
PlaneT
&
plane
:
planes_
)
{
plane
.
ShrinkTo
(
xsize
ysize
)
;
}
}
JXL_INLINE
JxlMemoryManager
*
memory_manager
(
)
const
{
return
planes_
[
0
]
.
memory_manager
(
)
;
}
JXL_INLINE
size_t
xsize
(
)
const
{
return
planes_
[
0
]
.
xsize
(
)
;
}
JXL_INLINE
size_t
ysize
(
)
const
{
return
planes_
[
0
]
.
ysize
(
)
;
}
JXL_INLINE
size_t
bytes_per_row
(
)
const
{
return
planes_
[
0
]
.
bytes_per_row
(
)
;
}
JXL_INLINE
intptr_t
PixelsPerRow
(
)
const
{
return
planes_
[
0
]
.
PixelsPerRow
(
)
;
}
private
:
Image3
(
PlaneT
&
&
plane0
PlaneT
&
&
plane1
PlaneT
&
&
plane2
)
{
planes_
[
0
]
=
std
:
:
move
(
plane0
)
;
planes_
[
1
]
=
std
:
:
move
(
plane1
)
;
planes_
[
2
]
=
std
:
:
move
(
plane2
)
;
}
void
PlaneRowBoundsCheck
(
const
size_t
c
const
size_t
y
)
const
{
#
if
defined
(
ADDRESS_SANITIZER
)
|
|
defined
(
MEMORY_SANITIZER
)
|
|
\
defined
(
THREAD_SANITIZER
)
if
(
c
>
=
kNumPlanes
|
|
y
>
=
ysize
(
)
)
{
JXL_ABORT
(
"
PlaneRow
(
%
"
PRIu64
"
%
"
PRIu64
"
)
in
(
%
"
PRIu64
"
x
%
"
PRIu64
"
)
image
\
n
"
static_cast
<
uint64_t
>
(
c
)
static_cast
<
uint64_t
>
(
y
)
static_cast
<
uint64_t
>
(
xsize
(
)
)
static_cast
<
uint64_t
>
(
ysize
(
)
)
)
;
}
#
endif
}
PlaneT
planes_
[
kNumPlanes
]
;
}
;
using
Image3B
=
Image3
<
uint8_t
>
;
using
Image3S
=
Image3
<
int16_t
>
;
using
Image3U
=
Image3
<
uint16_t
>
;
using
Image3I
=
Image3
<
int32_t
>
;
using
Image3F
=
Image3
<
float
>
;
using
Image3D
=
Image3
<
double
>
;
}
#
endif
