#
ifndef
LIB_JXL_IMAGE_H_
#
define
LIB_JXL_IMAGE_H_
#
if
defined
(
ADDRESS_SANITIZER
)
|
|
defined
(
MEMORY_SANITIZER
)
|
|
\
defined
(
THREAD_SANITIZER
)
#
include
<
inttypes
.
h
>
#
endif
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
sstream
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
cache_aligned
.
h
"
namespace
jxl
{
size_t
VectorSize
(
)
;
struct
PlaneBase
{
PlaneBase
(
)
:
xsize_
(
0
)
ysize_
(
0
)
orig_xsize_
(
0
)
orig_ysize_
(
0
)
bytes_per_row_
(
0
)
bytes_
(
nullptr
)
{
}
PlaneBase
(
size_t
xsize
size_t
ysize
size_t
sizeof_t
)
;
PlaneBase
(
const
PlaneBase
&
other
)
=
delete
;
PlaneBase
&
operator
=
(
const
PlaneBase
&
other
)
=
delete
;
PlaneBase
(
PlaneBase
&
&
other
)
noexcept
=
default
;
PlaneBase
&
operator
=
(
PlaneBase
&
&
other
)
noexcept
=
default
;
void
Swap
(
PlaneBase
&
other
)
;
void
ShrinkTo
(
const
size_t
xsize
const
size_t
ysize
)
{
JXL_CHECK
(
xsize
<
=
orig_xsize_
)
;
JXL_CHECK
(
ysize
<
=
orig_ysize_
)
;
xsize_
=
static_cast
<
uint32_t
>
(
xsize
)
;
ysize_
=
static_cast
<
uint32_t
>
(
ysize
)
;
}
JXL_INLINE
size_t
xsize
(
)
const
{
return
xsize_
;
}
JXL_INLINE
size_t
ysize
(
)
const
{
return
ysize_
;
}
JXL_INLINE
size_t
bytes_per_row
(
)
const
{
return
bytes_per_row_
;
}
JXL_INLINE
uint8_t
*
bytes
(
)
{
void
*
p
=
bytes_
.
get
(
)
;
return
static_cast
<
uint8_t
*
JXL_RESTRICT
>
(
JXL_ASSUME_ALIGNED
(
p
64
)
)
;
}
JXL_INLINE
const
uint8_t
*
bytes
(
)
const
{
const
void
*
p
=
bytes_
.
get
(
)
;
return
static_cast
<
const
uint8_t
*
JXL_RESTRICT
>
(
JXL_ASSUME_ALIGNED
(
p
64
)
)
;
}
protected
:
JXL_INLINE
void
*
VoidRow
(
const
size_t
y
)
const
{
#
if
defined
(
ADDRESS_SANITIZER
)
|
|
defined
(
MEMORY_SANITIZER
)
|
|
\
defined
(
THREAD_SANITIZER
)
if
(
y
>
=
ysize_
)
{
JXL_ABORT
(
"
Row
(
%
"
PRIu64
"
)
in
(
%
u
x
%
u
)
image
\
n
"
(
uint64_t
)
y
xsize_
ysize_
)
;
}
#
endif
void
*
row
=
bytes_
.
get
(
)
+
y
*
bytes_per_row_
;
return
JXL_ASSUME_ALIGNED
(
row
64
)
;
}
enum
class
Padding
{
kRoundUp
kUnaligned
}
;
void
InitializePadding
(
size_t
sizeof_t
Padding
padding
)
;
uint32_t
xsize_
;
uint32_t
ysize_
;
uint32_t
orig_xsize_
;
uint32_t
orig_ysize_
;
size_t
bytes_per_row_
;
CacheAlignedUniquePtr
bytes_
;
}
;
template
<
typename
ComponentType
>
class
Plane
:
public
PlaneBase
{
public
:
using
T
=
ComponentType
;
static
constexpr
size_t
kNumPlanes
=
1
;
Plane
(
)
=
default
;
Plane
(
const
size_t
xsize
const
size_t
ysize
)
:
PlaneBase
(
xsize
ysize
sizeof
(
T
)
)
{
}
void
InitializePaddingForUnalignedAccesses
(
)
{
InitializePadding
(
sizeof
(
T
)
Padding
:
:
kUnaligned
)
;
}
JXL_INLINE
T
*
Row
(
const
size_t
y
)
{
return
static_cast
<
T
*
>
(
VoidRow
(
y
)
)
;
}
JXL_INLINE
const
T
*
Row
(
const
size_t
y
)
const
{
return
static_cast
<
const
T
*
>
(
VoidRow
(
y
)
)
;
}
JXL_INLINE
const
T
*
ConstRow
(
const
size_t
y
)
const
{
return
static_cast
<
const
T
*
>
(
VoidRow
(
y
)
)
;
}
JXL_INLINE
intptr_t
PixelsPerRow
(
)
const
{
return
static_cast
<
intptr_t
>
(
bytes_per_row_
/
sizeof
(
T
)
)
;
}
}
;
using
ImageSB
=
Plane
<
int8_t
>
;
using
ImageB
=
Plane
<
uint8_t
>
;
using
ImageS
=
Plane
<
int16_t
>
;
using
ImageU
=
Plane
<
uint16_t
>
;
using
ImageI
=
Plane
<
int32_t
>
;
using
ImageF
=
Plane
<
float
>
;
using
ImageD
=
Plane
<
double
>
;
template
<
class
Image1
class
Image2
>
bool
SameSize
(
const
Image1
&
image1
const
Image2
&
image2
)
{
return
image1
.
xsize
(
)
=
=
image2
.
xsize
(
)
&
&
image1
.
ysize
(
)
=
=
image2
.
ysize
(
)
;
}
template
<
typename
T
>
class
Image3
;
template
<
typename
T
>
class
RectT
{
public
:
constexpr
RectT
(
T
xbegin
T
ybegin
size_t
xsize_max
size_t
ysize_max
T
xend
T
yend
)
:
x0_
(
xbegin
)
y0_
(
ybegin
)
xsize_
(
ClampedSize
(
xbegin
xsize_max
xend
)
)
ysize_
(
ClampedSize
(
ybegin
ysize_max
yend
)
)
{
}
constexpr
RectT
(
T
xbegin
T
ybegin
size_t
xsize
size_t
ysize
)
:
x0_
(
xbegin
)
y0_
(
ybegin
)
xsize_
(
xsize
)
ysize_
(
ysize
)
{
}
template
<
typename
ImageT
>
explicit
RectT
(
const
ImageT
&
image
)
:
RectT
(
0
0
image
.
xsize
(
)
image
.
ysize
(
)
)
{
}
RectT
(
)
:
RectT
(
0
0
0
0
)
{
}
RectT
(
const
RectT
&
)
=
default
;
RectT
&
operator
=
(
const
RectT
&
)
=
default
;
template
<
typename
ImageT
>
RectT
Crop
(
const
ImageT
&
image
)
const
{
return
Intersection
(
RectT
(
image
)
)
;
}
RectT
Crop
(
size_t
area_xsize
size_t
area_ysize
)
const
{
return
Intersection
(
RectT
(
0
0
area_xsize
area_ysize
)
)
;
}
RectT
Lines
(
size_t
y
size_t
num
)
const
{
JXL_DASSERT
(
y
+
num
<
=
ysize_
)
;
return
RectT
(
x0_
y0_
+
y
xsize_
num
)
;
}
RectT
Line
(
size_t
y
)
const
{
return
Lines
(
y
1
)
;
}
JXL_MUST_USE_RESULT
RectT
Intersection
(
const
RectT
&
other
)
const
{
return
RectT
(
std
:
:
max
(
x0_
other
.
x0_
)
std
:
:
max
(
y0_
other
.
y0_
)
xsize_
ysize_
std
:
:
min
(
x1
(
)
other
.
x1
(
)
)
std
:
:
min
(
y1
(
)
other
.
y1
(
)
)
)
;
}
JXL_MUST_USE_RESULT
RectT
Translate
(
int64_t
x_offset
int64_t
y_offset
)
const
{
return
RectT
(
x0_
+
x_offset
y0_
+
y_offset
xsize_
ysize_
)
;
}
template
<
typename
V
>
V
*
Row
(
Plane
<
V
>
*
image
size_t
y
)
const
{
JXL_DASSERT
(
y
+
y0_
>
=
0
)
;
return
image
-
>
Row
(
y
+
y0_
)
+
x0_
;
}
template
<
typename
V
>
const
V
*
Row
(
const
Plane
<
V
>
*
image
size_t
y
)
const
{
JXL_DASSERT
(
y
+
y0_
>
=
0
)
;
return
image
-
>
Row
(
y
+
y0_
)
+
x0_
;
}
template
<
typename
V
>
V
*
PlaneRow
(
Image3
<
V
>
*
image
const
size_t
c
size_t
y
)
const
{
JXL_DASSERT
(
y
+
y0_
>
=
0
)
;
return
image
-
>
PlaneRow
(
c
y
+
y0_
)
+
x0_
;
}
template
<
typename
V
>
const
V
*
ConstRow
(
const
Plane
<
V
>
&
image
size_t
y
)
const
{
JXL_DASSERT
(
y
+
y0_
>
=
0
)
;
return
image
.
ConstRow
(
y
+
y0_
)
+
x0_
;
}
template
<
typename
V
>
const
V
*
ConstPlaneRow
(
const
Image3
<
V
>
&
image
size_t
c
size_t
y
)
const
{
JXL_DASSERT
(
y
+
y0_
>
=
0
)
;
return
image
.
ConstPlaneRow
(
c
y
+
y0_
)
+
x0_
;
}
bool
IsInside
(
const
RectT
&
other
)
const
{
return
x0_
>
=
other
.
x0
(
)
&
&
x1
(
)
<
=
other
.
x1
(
)
&
&
y0_
>
=
other
.
y0
(
)
&
&
y1
(
)
<
=
other
.
y1
(
)
;
}
template
<
class
ImageT
>
bool
IsInside
(
const
ImageT
&
image
)
const
{
return
IsInside
(
RectT
(
image
)
)
;
}
T
x0
(
)
const
{
return
x0_
;
}
T
y0
(
)
const
{
return
y0_
;
}
size_t
xsize
(
)
const
{
return
xsize_
;
}
size_t
ysize
(
)
const
{
return
ysize_
;
}
T
x1
(
)
const
{
return
x0_
+
xsize_
;
}
T
y1
(
)
const
{
return
y0_
+
ysize_
;
}
RectT
<
T
>
ShiftLeft
(
size_t
shiftx
size_t
shifty
)
const
{
return
RectT
<
T
>
(
x0_
*
(
1
<
<
shiftx
)
y0_
*
(
1
<
<
shifty
)
xsize_
<
<
shiftx
ysize_
<
<
shifty
)
;
}
RectT
<
T
>
ShiftLeft
(
size_t
shift
)
const
{
return
ShiftLeft
(
shift
shift
)
;
}
RectT
<
T
>
CeilShiftRight
(
size_t
shiftx
size_t
shifty
)
const
{
JXL_ASSERT
(
x0_
%
(
1
<
<
shiftx
)
=
=
0
)
;
JXL_ASSERT
(
y0_
%
(
1
<
<
shifty
)
=
=
0
)
;
return
RectT
<
T
>
(
x0_
/
(
1
<
<
shiftx
)
y0_
/
(
1
<
<
shifty
)
DivCeil
(
xsize_
T
{
1
}
<
<
shiftx
)
DivCeil
(
ysize_
T
{
1
}
<
<
shifty
)
)
;
}
RectT
<
T
>
CeilShiftRight
(
std
:
:
pair
<
size_t
size_t
>
shift
)
const
{
return
CeilShiftRight
(
shift
.
first
shift
.
second
)
;
}
RectT
<
T
>
CeilShiftRight
(
size_t
shift
)
const
{
return
CeilShiftRight
(
shift
shift
)
;
}
RectT
<
T
>
Extend
(
T
border
RectT
<
T
>
parent
)
const
{
T
new_x0
=
x0
(
)
>
parent
.
x0
(
)
+
border
?
x0
(
)
-
border
:
parent
.
x0
(
)
;
T
new_y0
=
y0
(
)
>
parent
.
y0
(
)
+
border
?
y0
(
)
-
border
:
parent
.
y0
(
)
;
T
new_x1
=
x1
(
)
+
border
>
parent
.
x1
(
)
?
parent
.
x1
(
)
:
x1
(
)
+
border
;
T
new_y1
=
y1
(
)
+
border
>
parent
.
y1
(
)
?
parent
.
y1
(
)
:
y1
(
)
+
border
;
return
RectT
<
T
>
(
new_x0
new_y0
new_x1
-
new_x0
new_y1
-
new_y0
)
;
}
template
<
typename
U
>
RectT
<
U
>
As
(
)
const
{
return
RectT
<
U
>
(
U
(
x0_
)
U
(
y0_
)
U
(
xsize_
)
U
(
ysize_
)
)
;
}
private
:
static
constexpr
size_t
ClampedSize
(
T
begin
size_t
size_max
T
end
)
{
return
(
static_cast
<
T
>
(
begin
+
size_max
)
<
=
end
)
?
size_max
:
(
end
>
begin
?
end
-
begin
:
0
)
;
}
T
x0_
;
T
y0_
;
size_t
xsize_
;
size_t
ysize_
;
}
;
template
<
typename
T
>
std
:
:
string
Description
(
RectT
<
T
>
r
)
{
std
:
:
ostringstream
os
;
os
<
<
"
[
"
<
<
r
.
x0
(
)
<
<
"
.
.
"
<
<
r
.
x1
(
)
<
<
"
)
x
"
<
<
"
[
"
<
<
r
.
y0
(
)
<
<
"
.
.
"
<
<
r
.
y1
(
)
<
<
"
)
"
;
return
os
.
str
(
)
;
}
using
Rect
=
RectT
<
size_t
>
;
template
<
typename
ComponentType
>
class
Image3
{
public
:
using
T
=
ComponentType
;
using
PlaneT
=
jxl
:
:
Plane
<
T
>
;
static
constexpr
size_t
kNumPlanes
=
3
;
Image3
(
)
:
planes_
{
PlaneT
(
)
PlaneT
(
)
PlaneT
(
)
}
{
}
Image3
(
const
size_t
xsize
const
size_t
ysize
)
:
planes_
{
PlaneT
(
xsize
ysize
)
PlaneT
(
xsize
ysize
)
PlaneT
(
xsize
ysize
)
}
{
}
Image3
(
Image3
&
&
other
)
noexcept
{
for
(
size_t
i
=
0
;
i
<
kNumPlanes
;
i
+
+
)
{
planes_
[
i
]
=
std
:
:
move
(
other
.
planes_
[
i
]
)
;
}
}
Image3
(
PlaneT
&
&
plane0
PlaneT
&
&
plane1
PlaneT
&
&
plane2
)
{
JXL_CHECK
(
SameSize
(
plane0
plane1
)
)
;
JXL_CHECK
(
SameSize
(
plane0
plane2
)
)
;
planes_
[
0
]
=
std
:
:
move
(
plane0
)
;
planes_
[
1
]
=
std
:
:
move
(
plane1
)
;
planes_
[
2
]
=
std
:
:
move
(
plane2
)
;
}
Image3
(
const
Image3
&
other
)
=
delete
;
Image3
&
operator
=
(
const
Image3
&
other
)
=
delete
;
Image3
&
operator
=
(
Image3
&
&
other
)
noexcept
{
for
(
size_t
i
=
0
;
i
<
kNumPlanes
;
i
+
+
)
{
planes_
[
i
]
=
std
:
:
move
(
other
.
planes_
[
i
]
)
;
}
return
*
this
;
}
JXL_INLINE
T
*
PlaneRow
(
const
size_t
c
const
size_t
y
)
{
PlaneRowBoundsCheck
(
c
y
)
;
const
size_t
row_offset
=
y
*
planes_
[
0
]
.
bytes_per_row
(
)
;
void
*
row
=
planes_
[
c
]
.
bytes
(
)
+
row_offset
;
return
static_cast
<
T
*
JXL_RESTRICT
>
(
JXL_ASSUME_ALIGNED
(
row
64
)
)
;
}
JXL_INLINE
const
T
*
PlaneRow
(
const
size_t
c
const
size_t
y
)
const
{
PlaneRowBoundsCheck
(
c
y
)
;
const
size_t
row_offset
=
y
*
planes_
[
0
]
.
bytes_per_row
(
)
;
const
void
*
row
=
planes_
[
c
]
.
bytes
(
)
+
row_offset
;
return
static_cast
<
const
T
*
JXL_RESTRICT
>
(
JXL_ASSUME_ALIGNED
(
row
64
)
)
;
}
JXL_INLINE
const
T
*
ConstPlaneRow
(
const
size_t
c
const
size_t
y
)
const
{
PlaneRowBoundsCheck
(
c
y
)
;
return
PlaneRow
(
c
y
)
;
}
JXL_INLINE
const
PlaneT
&
Plane
(
size_t
idx
)
const
{
return
planes_
[
idx
]
;
}
JXL_INLINE
PlaneT
&
Plane
(
size_t
idx
)
{
return
planes_
[
idx
]
;
}
void
Swap
(
Image3
&
other
)
{
for
(
size_t
c
=
0
;
c
<
3
;
+
+
c
)
{
other
.
planes_
[
c
]
.
Swap
(
planes_
[
c
]
)
;
}
}
void
ShrinkTo
(
const
size_t
xsize
const
size_t
ysize
)
{
for
(
PlaneT
&
plane
:
planes_
)
{
plane
.
ShrinkTo
(
xsize
ysize
)
;
}
}
JXL_INLINE
size_t
xsize
(
)
const
{
return
planes_
[
0
]
.
xsize
(
)
;
}
JXL_INLINE
size_t
ysize
(
)
const
{
return
planes_
[
0
]
.
ysize
(
)
;
}
JXL_INLINE
size_t
bytes_per_row
(
)
const
{
return
planes_
[
0
]
.
bytes_per_row
(
)
;
}
JXL_INLINE
intptr_t
PixelsPerRow
(
)
const
{
return
planes_
[
0
]
.
PixelsPerRow
(
)
;
}
private
:
void
PlaneRowBoundsCheck
(
const
size_t
c
const
size_t
y
)
const
{
#
if
defined
(
ADDRESS_SANITIZER
)
|
|
defined
(
MEMORY_SANITIZER
)
|
|
\
defined
(
THREAD_SANITIZER
)
if
(
c
>
=
kNumPlanes
|
|
y
>
=
ysize
(
)
)
{
JXL_ABORT
(
"
PlaneRow
(
%
"
PRIu64
"
%
"
PRIu64
"
)
in
(
%
"
PRIu64
"
x
%
"
PRIu64
"
)
image
\
n
"
static_cast
<
uint64_t
>
(
c
)
static_cast
<
uint64_t
>
(
y
)
static_cast
<
uint64_t
>
(
xsize
(
)
)
static_cast
<
uint64_t
>
(
ysize
(
)
)
)
;
}
#
endif
}
private
:
PlaneT
planes_
[
kNumPlanes
]
;
}
;
using
Image3B
=
Image3
<
uint8_t
>
;
using
Image3S
=
Image3
<
int16_t
>
;
using
Image3U
=
Image3
<
uint16_t
>
;
using
Image3I
=
Image3
<
int32_t
>
;
using
Image3F
=
Image3
<
float
>
;
using
Image3D
=
Image3
<
double
>
;
}
#
endif
