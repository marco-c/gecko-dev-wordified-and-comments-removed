#
ifndef
LIB_JXL_IMAGE_BUNDLE_H_
#
define
LIB_JXL_IMAGE_BUNDLE_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
aux_out_fwd
.
h
"
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
color_encoding_internal
.
h
"
#
include
"
lib
/
jxl
/
common
.
h
"
#
include
"
lib
/
jxl
/
dec_bit_reader
.
h
"
#
include
"
lib
/
jxl
/
dec_xyb
.
h
"
#
include
"
lib
/
jxl
/
enc_bit_writer
.
h
"
#
include
"
lib
/
jxl
/
field_encodings
.
h
"
#
include
"
lib
/
jxl
/
frame_header
.
h
"
#
include
"
lib
/
jxl
/
headers
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
#
include
"
lib
/
jxl
/
image_metadata
.
h
"
#
include
"
lib
/
jxl
/
jpeg
/
jpeg_data
.
h
"
#
include
"
lib
/
jxl
/
opsin_params
.
h
"
#
include
"
lib
/
jxl
/
quantizer
.
h
"
namespace
jxl
{
class
ImageBundle
{
public
:
ImageBundle
(
)
:
metadata_
(
nullptr
)
{
}
explicit
ImageBundle
(
const
ImageMetadata
*
metadata
)
:
metadata_
(
metadata
)
{
}
ImageBundle
(
ImageBundle
&
&
)
=
default
;
ImageBundle
&
operator
=
(
ImageBundle
&
&
)
=
default
;
ImageBundle
Copy
(
)
const
{
ImageBundle
copy
(
metadata_
)
;
copy
.
color_
=
CopyImage
(
color_
)
;
copy
.
c_current_
=
c_current_
;
copy
.
extra_channels_
.
reserve
(
extra_channels_
.
size
(
)
)
;
for
(
const
ImageF
&
plane
:
extra_channels_
)
{
copy
.
extra_channels_
.
emplace_back
(
CopyImage
(
plane
)
)
;
}
copy
.
jpeg_data
=
jpeg_data
?
make_unique
<
jpeg
:
:
JPEGData
>
(
*
jpeg_data
)
:
nullptr
;
copy
.
color_transform
=
color_transform
;
copy
.
chroma_subsampling
=
chroma_subsampling
;
return
copy
;
}
size_t
xsize
(
)
const
{
if
(
IsJPEG
(
)
)
return
jpeg_data
-
>
width
;
if
(
color_
.
xsize
(
)
!
=
0
)
return
color_
.
xsize
(
)
;
return
extra_channels_
.
empty
(
)
?
0
:
extra_channels_
[
0
]
.
xsize
(
)
;
}
size_t
ysize
(
)
const
{
if
(
IsJPEG
(
)
)
return
jpeg_data
-
>
height
;
if
(
color_
.
ysize
(
)
!
=
0
)
return
color_
.
ysize
(
)
;
return
extra_channels_
.
empty
(
)
?
0
:
extra_channels_
[
0
]
.
ysize
(
)
;
}
void
ShrinkTo
(
size_t
xsize
size_t
ysize
)
;
size_t
oriented_xsize
(
)
const
{
if
(
static_cast
<
uint32_t
>
(
metadata_
-
>
GetOrientation
(
)
)
>
4
)
{
return
ysize
(
)
;
}
else
{
return
xsize
(
)
;
}
}
size_t
oriented_ysize
(
)
const
{
if
(
static_cast
<
uint32_t
>
(
metadata_
-
>
GetOrientation
(
)
)
>
4
)
{
return
xsize
(
)
;
}
else
{
return
ysize
(
)
;
}
}
bool
HasColor
(
)
const
{
return
color_
.
xsize
(
)
!
=
0
;
}
void
RemoveColor
(
)
{
color_
=
Image3F
(
)
;
}
const
Image3F
&
color
(
)
const
{
JXL_DASSERT
(
HasColor
(
)
)
;
return
color_
;
}
Image3F
*
color
(
)
{
JXL_DASSERT
(
HasColor
(
)
)
;
return
&
color_
;
}
void
SetFromImage
(
Image3F
&
&
color
const
ColorEncoding
&
c_current
)
;
const
ColorEncoding
&
c_current
(
)
const
{
return
c_current_
;
}
bool
IsGray
(
)
const
{
return
c_current_
.
IsGray
(
)
;
}
bool
IsSRGB
(
)
const
{
return
c_current_
.
IsSRGB
(
)
;
}
bool
IsLinearSRGB
(
)
const
{
return
c_current_
.
white_point
=
=
WhitePoint
:
:
kD65
&
&
c_current_
.
primaries
=
=
Primaries
:
:
kSRGB
&
&
c_current_
.
tf
.
IsLinear
(
)
;
}
void
OverrideProfile
(
const
ColorEncoding
&
new_c_current
)
{
c_current_
=
new_c_current
;
}
Status
TransformTo
(
const
ColorEncoding
&
c_desired
ThreadPool
*
pool
=
nullptr
)
;
Status
CopyTo
(
const
Rect
&
rect
const
ColorEncoding
&
c_desired
Image3B
*
out
ThreadPool
*
pool
=
nullptr
)
const
;
Status
CopyTo
(
const
Rect
&
rect
const
ColorEncoding
&
c_desired
Image3F
*
out
ThreadPool
*
pool
=
nullptr
)
const
;
Status
CopyToSRGB
(
const
Rect
&
rect
Image3B
*
out
ThreadPool
*
pool
=
nullptr
)
const
;
size_t
DetectRealBitdepth
(
)
const
;
void
SetAlpha
(
ImageF
&
&
alpha
bool
alpha_is_premultiplied
)
;
bool
HasAlpha
(
)
const
{
return
metadata_
-
>
Find
(
ExtraChannel
:
:
kAlpha
)
!
=
nullptr
;
}
bool
AlphaIsPremultiplied
(
)
const
{
const
ExtraChannelInfo
*
eci
=
metadata_
-
>
Find
(
ExtraChannel
:
:
kAlpha
)
;
return
(
eci
=
=
nullptr
)
?
false
:
eci
-
>
alpha_associated
;
}
void
PremultiplyAlpha
(
)
;
void
UnpremultiplyAlpha
(
)
;
const
ImageF
&
alpha
(
)
const
;
ImageF
*
alpha
(
)
;
void
SetExtraChannels
(
std
:
:
vector
<
ImageF
>
&
&
extra_channels
)
;
void
ClearExtraChannels
(
)
{
extra_channels_
.
clear
(
)
;
}
bool
HasExtraChannels
(
)
const
{
return
!
extra_channels_
.
empty
(
)
;
}
const
std
:
:
vector
<
ImageF
>
&
extra_channels
(
)
const
{
return
extra_channels_
;
}
std
:
:
vector
<
ImageF
>
&
extra_channels
(
)
{
return
extra_channels_
;
}
const
ImageMetadata
*
metadata
(
)
const
{
return
metadata_
;
}
void
VerifyMetadata
(
)
const
;
void
SetDecodedBytes
(
size_t
decoded_bytes
)
{
decoded_bytes_
=
decoded_bytes
;
}
size_t
decoded_bytes
(
)
const
{
return
decoded_bytes_
;
}
bool
IsJPEG
(
)
const
{
#
if
JPEGXL_ENABLE_TRANSCODE_JPEG
return
jpeg_data
!
=
nullptr
;
#
else
return
false
;
#
endif
}
std
:
:
unique_ptr
<
jpeg
:
:
JPEGData
>
jpeg_data
;
ColorTransform
color_transform
=
ColorTransform
:
:
kNone
;
YCbCrChromaSubsampling
chroma_subsampling
;
FrameOrigin
origin
{
0
0
}
;
uint32_t
duration
=
0
;
bool
use_for_next_frame
=
false
;
bool
blend
=
false
;
BlendMode
blendmode
=
BlendMode
:
:
kBlend
;
std
:
:
string
name
;
private
:
void
VerifySizes
(
)
const
;
const
ImageMetadata
*
metadata_
;
Image3F
color_
;
ColorEncoding
c_current_
;
std
:
:
vector
<
ImageF
>
extra_channels_
;
size_t
decoded_bytes_
=
0
;
}
;
Status
TransformIfNeeded
(
const
ImageBundle
&
in
const
ColorEncoding
&
c_desired
ThreadPool
*
pool
ImageBundle
*
store
const
ImageBundle
*
*
out
)
;
}
#
endif
