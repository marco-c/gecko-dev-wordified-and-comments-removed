#
include
"
lib
/
jxl
/
simd_util
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
lib
/
jxl
/
simd_util
.
cc
"
#
include
<
hwy
/
foreach_target
.
h
>
#
include
<
hwy
/
highway
.
h
>
#
include
"
lib
/
jxl
/
base
/
common
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
cache_aligned
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
jxl
{
namespace
HWY_NAMESPACE
{
size_t
MaxVectorSize
(
)
{
HWY_FULL
(
float
)
df
;
return
Lanes
(
df
)
*
sizeof
(
float
)
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
jxl
{
HWY_EXPORT
(
MaxVectorSize
)
;
size_t
MaxVectorSize
(
)
{
return
HWY_DYNAMIC_DISPATCH
(
MaxVectorSize
)
(
)
;
}
size_t
BytesPerRow
(
const
size_t
xsize
const
size_t
sizeof_t
)
{
if
(
xsize
=
=
0
)
{
return
0
;
}
const
size_t
vec_size
=
MaxVectorSize
(
)
;
size_t
valid_bytes
=
xsize
*
sizeof_t
;
if
(
vec_size
!
=
0
)
{
valid_bytes
+
=
vec_size
-
sizeof_t
;
}
const
size_t
align
=
std
:
:
max
(
vec_size
CacheAligned
:
:
kAlignment
)
;
size_t
bytes_per_row
=
RoundUpTo
(
valid_bytes
align
)
;
if
(
bytes_per_row
%
CacheAligned
:
:
kAlias
=
=
0
)
{
bytes_per_row
+
=
align
;
}
JXL_ASSERT
(
bytes_per_row
%
align
=
=
0
)
;
return
bytes_per_row
;
}
}
#
endif
