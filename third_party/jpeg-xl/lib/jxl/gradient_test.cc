#
include
<
jxl
/
cms
.
h
>
#
include
<
math
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
cmath
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
base
/
common
.
h
"
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
base
/
span
.
h
"
#
include
"
lib
/
jxl
/
codec_in_out
.
h
"
#
include
"
lib
/
jxl
/
color_encoding_internal
.
h
"
#
include
"
lib
/
jxl
/
enc_params
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
#
include
"
lib
/
jxl
/
image_bundle
.
h
"
#
include
"
lib
/
jxl
/
image_ops
.
h
"
#
include
"
lib
/
jxl
/
test_utils
.
h
"
#
include
"
lib
/
jxl
/
testing
.
h
"
namespace
jxl
{
struct
AuxOut
;
namespace
{
double
PointLineDist
(
double
x0
double
y0
double
x1
double
y1
double
x
double
y
)
{
return
(
y1
-
y0
)
*
x
-
(
x1
-
x0
)
*
y
+
x1
*
y0
-
y1
*
x0
;
}
Image3F
GenerateTestGradient
(
uint32_t
color0
uint32_t
color1
double
angle
size_t
xsize
size_t
ysize
)
{
Image3F
image
(
xsize
ysize
)
;
double
x0
=
xsize
/
2
;
double
y0
=
ysize
/
2
;
double
x1
=
x0
+
std
:
:
sin
(
angle
/
360
.
0
*
2
.
0
*
kPi
)
;
double
y1
=
y0
+
std
:
:
cos
(
angle
/
360
.
0
*
2
.
0
*
kPi
)
;
double
maxdist
=
std
:
:
max
<
double
>
(
fabs
(
PointLineDist
(
x0
y0
x1
y1
0
0
)
)
fabs
(
PointLineDist
(
x0
y0
x1
y1
xsize
0
)
)
)
;
for
(
size_t
c
=
0
;
c
<
3
;
+
+
c
)
{
float
c0
=
(
(
color0
>
>
(
8
*
(
2
-
c
)
)
)
&
255
)
;
float
c1
=
(
(
color1
>
>
(
8
*
(
2
-
c
)
)
)
&
255
)
;
for
(
size_t
y
=
0
;
y
<
ysize
;
+
+
y
)
{
float
*
row
=
image
.
PlaneRow
(
c
y
)
;
for
(
size_t
x
=
0
;
x
<
xsize
;
+
+
x
)
{
double
dist
=
PointLineDist
(
x0
y0
x1
y1
x
y
)
;
double
v
=
(
(
dist
/
maxdist
)
+
1
.
0
)
/
2
.
0
;
float
color
=
c0
*
(
1
.
0
-
v
)
+
c1
*
v
;
row
[
x
]
=
color
;
}
}
}
return
image
;
}
static
ImageF
Gradient2
(
const
ImageF
&
image
)
{
size_t
xsize
=
image
.
xsize
(
)
;
size_t
ysize
=
image
.
ysize
(
)
;
ImageF
image2
(
image
.
xsize
(
)
image
.
ysize
(
)
)
;
for
(
size_t
y
=
1
;
y
+
1
<
ysize
;
y
+
+
)
{
const
auto
*
JXL_RESTRICT
row0
=
image
.
Row
(
y
-
1
)
;
const
auto
*
JXL_RESTRICT
row1
=
image
.
Row
(
y
)
;
const
auto
*
JXL_RESTRICT
row2
=
image
.
Row
(
y
+
1
)
;
auto
*
row_out
=
image2
.
Row
(
y
)
;
for
(
size_t
x
=
1
;
x
+
1
<
xsize
;
x
+
+
)
{
float
ddx
=
(
row1
[
x
]
-
row1
[
x
-
1
]
)
-
(
row1
[
x
+
1
]
-
row1
[
x
]
)
;
float
ddy
=
(
row1
[
x
]
-
row0
[
x
]
)
-
(
row2
[
x
]
-
row1
[
x
]
)
;
row_out
[
x
]
=
std
:
:
max
(
fabsf
(
ddx
)
fabsf
(
ddy
)
)
;
}
}
if
(
ysize
>
2
)
{
auto
*
JXL_RESTRICT
row0
=
image2
.
Row
(
0
)
;
const
auto
*
JXL_RESTRICT
row1
=
image2
.
Row
(
1
)
;
const
auto
*
JXL_RESTRICT
row2
=
image2
.
Row
(
ysize
-
2
)
;
auto
*
JXL_RESTRICT
row3
=
image2
.
Row
(
ysize
-
1
)
;
for
(
size_t
x
=
1
;
x
+
1
<
xsize
;
x
+
+
)
{
row0
[
x
]
=
row1
[
x
]
;
row3
[
x
]
=
row2
[
x
]
;
}
}
else
{
const
auto
*
row0_in
=
image
.
Row
(
0
)
;
const
auto
*
row1_in
=
image
.
Row
(
ysize
-
1
)
;
auto
*
row0_out
=
image2
.
Row
(
0
)
;
auto
*
row1_out
=
image2
.
Row
(
ysize
-
1
)
;
for
(
size_t
x
=
1
;
x
+
1
<
xsize
;
x
+
+
)
{
row0_out
[
x
]
=
row1_out
[
x
]
=
fabsf
(
row0_in
[
x
]
-
row1_in
[
x
]
)
;
}
}
if
(
xsize
>
2
)
{
for
(
size_t
y
=
0
;
y
<
ysize
;
y
+
+
)
{
auto
*
row
=
image2
.
Row
(
y
)
;
row
[
0
]
=
row
[
1
]
;
row
[
xsize
-
1
]
=
row
[
xsize
-
2
]
;
}
}
else
{
for
(
size_t
y
=
0
;
y
<
ysize
;
y
+
+
)
{
const
auto
*
JXL_RESTRICT
row_in
=
image
.
Row
(
y
)
;
auto
*
row_out
=
image2
.
Row
(
y
)
;
row_out
[
0
]
=
row_out
[
xsize
-
1
]
=
fabsf
(
row_in
[
0
]
-
row_in
[
xsize
-
1
]
)
;
}
}
return
image2
;
}
static
Image3F
Gradient2
(
const
Image3F
&
image
)
{
return
Image3F
(
Gradient2
(
image
.
Plane
(
0
)
)
Gradient2
(
image
.
Plane
(
1
)
)
Gradient2
(
image
.
Plane
(
2
)
)
)
;
}
void
TestGradient
(
ThreadPool
*
pool
uint32_t
color0
uint32_t
color1
size_t
xsize
size_t
ysize
float
angle
bool
fast_mode
float
butteraugli_distance
bool
use_gradient
=
true
)
{
CompressParams
cparams
;
cparams
.
butteraugli_distance
=
butteraugli_distance
;
if
(
fast_mode
)
{
cparams
.
speed_tier
=
SpeedTier
:
:
kSquirrel
;
}
Image3F
gradient
=
GenerateTestGradient
(
color0
color1
angle
xsize
ysize
)
;
CodecInOut
io
;
io
.
metadata
.
m
.
SetUintSamples
(
8
)
;
io
.
metadata
.
m
.
color_encoding
=
ColorEncoding
:
:
SRGB
(
)
;
io
.
SetFromImage
(
std
:
:
move
(
gradient
)
io
.
metadata
.
m
.
color_encoding
)
;
CodecInOut
io2
;
std
:
:
vector
<
uint8_t
>
compressed
;
EXPECT_TRUE
(
test
:
:
EncodeFile
(
cparams
&
io
&
compressed
pool
)
)
;
EXPECT_TRUE
(
test
:
:
DecodeFile
(
{
}
Bytes
(
compressed
)
&
io2
pool
)
)
;
EXPECT_TRUE
(
io2
.
Main
(
)
.
TransformTo
(
io2
.
metadata
.
m
.
color_encoding
*
JxlGetDefaultCms
(
)
pool
)
)
;
if
(
use_gradient
)
{
Image3F
gradient2
=
Gradient2
(
*
io2
.
Main
(
)
.
color
(
)
)
;
std
:
:
array
<
float
3
>
image_max
;
Image3Max
(
gradient2
&
image_max
)
;
EXPECT_LE
(
image_max
[
0
]
3
.
15
)
;
EXPECT_LE
(
image_max
[
1
]
1
.
72
)
;
EXPECT_LE
(
image_max
[
2
]
5
.
05
)
;
}
}
static
constexpr
bool
fast_mode
=
true
;
TEST
(
GradientTest
SteepGradient
)
{
test
:
:
ThreadPoolForTests
pool
(
8
)
;
TestGradient
(
&
pool
0xd99d58
0x889ab1
512
512
90
fast_mode
3
.
0
)
;
}
TEST
(
GradientTest
SubtleGradient
)
{
test
:
:
ThreadPoolForTests
pool
(
8
)
;
TestGradient
(
&
pool
0xb89b7b
0xa89b8d
512
512
90
fast_mode
4
.
0
)
;
}
}
}
