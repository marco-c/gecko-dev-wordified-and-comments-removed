#
ifndef
LIB_JXL_DEC_PATCH_DICTIONARY_H_
#
define
LIB_JXL_DEC_PATCH_DICTIONARY_H_
#
include
<
stddef
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
tuple
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
common
.
h
"
#
include
"
lib
/
jxl
/
dec_bit_reader
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
#
include
"
lib
/
jxl
/
opsin_params
.
h
"
namespace
jxl
{
enum
class
PatchBlendMode
:
uint8_t
{
kNone
=
0
kReplace
=
1
kAdd
=
2
kMul
=
3
kBlendAbove
=
4
kBlendBelow
=
5
kAlphaWeightedAddAbove
=
6
kAlphaWeightedAddBelow
=
7
kNumBlendModes
}
;
inline
bool
UsesAlpha
(
PatchBlendMode
mode
)
{
return
mode
=
=
PatchBlendMode
:
:
kBlendAbove
|
|
mode
=
=
PatchBlendMode
:
:
kBlendBelow
|
|
mode
=
=
PatchBlendMode
:
:
kAlphaWeightedAddAbove
|
|
mode
=
=
PatchBlendMode
:
:
kAlphaWeightedAddBelow
;
}
inline
bool
UsesClamp
(
PatchBlendMode
mode
)
{
return
UsesAlpha
(
mode
)
|
|
mode
=
=
PatchBlendMode
:
:
kMul
;
}
struct
PatchBlending
{
PatchBlendMode
mode
;
uint32_t
alpha_channel
;
bool
clamp
;
}
;
struct
PatchReferencePosition
{
size_t
ref
x0
y0
xsize
ysize
;
}
;
struct
PatchPosition
{
size_t
x
y
;
size_t
ref_pos_idx
;
}
;
struct
PassesSharedState
;
class
PatchDictionaryEncoder
;
class
PatchDictionary
{
public
:
PatchDictionary
(
)
=
default
;
void
SetPassesSharedState
(
const
PassesSharedState
*
shared
)
{
shared_
=
shared
;
}
bool
HasAny
(
)
const
{
return
!
positions_
.
empty
(
)
;
}
Status
Decode
(
BitReader
*
br
size_t
xsize
size_t
ysize
bool
*
uses_extra_channels
)
;
void
Clear
(
)
{
positions_
.
clear
(
)
;
ComputePatchTree
(
)
;
}
void
AddOneRow
(
float
*
const
*
inout
size_t
y
size_t
x0
size_t
xsize
)
const
;
int
GetReferences
(
)
const
;
std
:
:
vector
<
size_t
>
GetPatchesForRow
(
size_t
y
)
const
;
private
:
friend
class
PatchDictionaryEncoder
;
const
PassesSharedState
*
shared_
;
std
:
:
vector
<
PatchPosition
>
positions_
;
std
:
:
vector
<
PatchReferencePosition
>
ref_positions_
;
std
:
:
vector
<
PatchBlending
>
blendings_
;
struct
PatchTreeNode
{
ssize_t
left_child
;
ssize_t
right_child
;
size_t
y_center
;
size_t
start
;
size_t
num
;
}
;
std
:
:
vector
<
PatchTreeNode
>
patch_tree_
;
std
:
:
vector
<
size_t
>
num_patches_
;
std
:
:
vector
<
std
:
:
pair
<
size_t
size_t
>
>
sorted_patches_y0_
;
std
:
:
vector
<
std
:
:
pair
<
size_t
size_t
>
>
sorted_patches_y1_
;
void
ComputePatchTree
(
)
;
}
;
}
#
endif
