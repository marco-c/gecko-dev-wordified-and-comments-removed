#
ifndef
LIB_JXL_DEC_PATCH_DICTIONARY_H_
#
define
LIB_JXL_DEC_PATCH_DICTIONARY_H_
#
include
<
stddef
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
tuple
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
common
.
h
"
#
include
"
lib
/
jxl
/
dec_bit_reader
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
#
include
"
lib
/
jxl
/
opsin_params
.
h
"
namespace
jxl
{
constexpr
size_t
kMaxPatchSize
=
32
;
enum
class
PatchBlendMode
:
uint8_t
{
kNone
=
0
kReplace
=
1
kAdd
=
2
kMul
=
3
kBlendAbove
=
4
kBlendBelow
=
5
kAlphaWeightedAddAbove
=
6
kAlphaWeightedAddBelow
=
7
kNumBlendModes
}
;
inline
bool
UsesAlpha
(
PatchBlendMode
mode
)
{
return
mode
=
=
PatchBlendMode
:
:
kBlendAbove
|
|
mode
=
=
PatchBlendMode
:
:
kBlendBelow
|
|
mode
=
=
PatchBlendMode
:
:
kAlphaWeightedAddAbove
|
|
mode
=
=
PatchBlendMode
:
:
kAlphaWeightedAddBelow
;
}
inline
bool
UsesClamp
(
PatchBlendMode
mode
)
{
return
UsesAlpha
(
mode
)
|
|
mode
=
=
PatchBlendMode
:
:
kMul
;
}
struct
PatchBlending
{
PatchBlendMode
mode
;
uint32_t
alpha_channel
;
bool
clamp
;
}
;
struct
QuantizedPatch
{
size_t
xsize
;
size_t
ysize
;
QuantizedPatch
(
)
{
for
(
size_t
i
=
0
;
i
<
3
;
i
+
+
)
{
pixels
[
i
]
.
resize
(
kMaxPatchSize
*
kMaxPatchSize
)
;
fpixels
[
i
]
.
resize
(
kMaxPatchSize
*
kMaxPatchSize
)
;
}
}
std
:
:
vector
<
int8_t
>
pixels
[
3
]
=
{
}
;
std
:
:
vector
<
float
>
fpixels
[
3
]
=
{
}
;
bool
operator
=
=
(
const
QuantizedPatch
&
other
)
const
{
if
(
xsize
!
=
other
.
xsize
)
return
false
;
if
(
ysize
!
=
other
.
ysize
)
return
false
;
for
(
size_t
c
=
0
;
c
<
3
;
c
+
+
)
{
if
(
memcmp
(
pixels
[
c
]
.
data
(
)
other
.
pixels
[
c
]
.
data
(
)
sizeof
(
int8_t
)
*
xsize
*
ysize
)
!
=
0
)
return
false
;
}
return
true
;
}
bool
operator
<
(
const
QuantizedPatch
&
other
)
const
{
if
(
xsize
!
=
other
.
xsize
)
return
xsize
<
other
.
xsize
;
if
(
ysize
!
=
other
.
ysize
)
return
ysize
<
other
.
ysize
;
for
(
size_t
c
=
0
;
c
<
3
;
c
+
+
)
{
int
cmp
=
memcmp
(
pixels
[
c
]
.
data
(
)
other
.
pixels
[
c
]
.
data
(
)
sizeof
(
int8_t
)
*
xsize
*
ysize
)
;
if
(
cmp
>
0
)
return
false
;
if
(
cmp
<
0
)
return
true
;
}
return
false
;
}
}
;
using
PatchInfo
=
std
:
:
pair
<
QuantizedPatch
std
:
:
vector
<
std
:
:
pair
<
uint32_t
uint32_t
>
>
>
;
struct
PatchReferencePosition
{
size_t
ref
x0
y0
xsize
ysize
;
bool
operator
<
(
const
PatchReferencePosition
&
oth
)
const
{
return
std
:
:
make_tuple
(
ref
x0
y0
xsize
ysize
)
<
std
:
:
make_tuple
(
oth
.
ref
oth
.
x0
oth
.
y0
oth
.
xsize
oth
.
ysize
)
;
}
bool
operator
=
=
(
const
PatchReferencePosition
&
oth
)
const
{
return
!
(
*
this
<
oth
)
&
&
!
(
oth
<
*
this
)
;
}
}
;
struct
PatchPosition
{
size_t
x
y
;
std
:
:
vector
<
PatchBlending
>
blending
;
PatchReferencePosition
ref_pos
;
bool
operator
<
(
const
PatchPosition
&
oth
)
const
{
return
std
:
:
make_tuple
(
ref_pos
x
y
)
<
std
:
:
make_tuple
(
oth
.
ref_pos
oth
.
x
oth
.
y
)
;
}
}
;
struct
PassesSharedState
;
class
PatchDictionaryEncoder
;
class
PatchDictionary
{
public
:
PatchDictionary
(
)
=
default
;
void
SetPassesSharedState
(
const
PassesSharedState
*
shared
)
{
shared_
=
shared
;
}
bool
HasAny
(
)
const
{
return
!
positions_
.
empty
(
)
;
}
Status
Decode
(
BitReader
*
br
size_t
xsize
size_t
ysize
bool
*
uses_extra_channels
)
;
void
Clear
(
)
{
positions_
.
clear
(
)
;
ComputePatchCache
(
)
;
}
Status
AddTo
(
Image3F
*
opsin
const
Rect
&
opsin_rect
float
*
const
*
extra_channels
const
Rect
&
image_rect
)
const
;
int
GetReferences
(
)
const
;
private
:
friend
class
PatchDictionaryEncoder
;
const
PassesSharedState
*
shared_
;
std
:
:
vector
<
PatchPosition
>
positions_
;
std
:
:
vector
<
size_t
>
sorted_patches_
;
std
:
:
vector
<
size_t
>
patch_starts_
;
void
ComputePatchCache
(
)
;
}
;
}
#
endif
