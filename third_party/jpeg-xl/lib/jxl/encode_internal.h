#
ifndef
LIB_JXL_ENCODE_INTERNAL_H_
#
define
LIB_JXL_ENCODE_INTERNAL_H_
#
include
<
jxl
/
encode
.
h
>
#
include
<
jxl
/
memory_manager
.
h
>
#
include
<
jxl
/
parallel_runner
.
h
>
#
include
<
jxl
/
types
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
base
/
padded_bytes
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
enc_aux_out
.
h
"
#
include
"
lib
/
jxl
/
enc_fast_lossless
.
h
"
#
include
"
lib
/
jxl
/
enc_frame
.
h
"
#
include
"
lib
/
jxl
/
memory_manager_internal
.
h
"
namespace
jxl
{
typedef
struct
JxlEncoderFrameIndexBoxEntryStruct
{
bool
to_be_indexed
;
uint32_t
duration
;
uint64_t
OFFi
;
}
JxlEncoderFrameIndexBoxEntry
;
typedef
struct
JxlEncoderFrameIndexBoxStruct
{
bool
index_box_requested_through_api
=
false
;
int64_t
NF
(
)
const
{
return
entries
.
size
(
)
;
}
bool
StoreFrameIndexBox
(
)
{
for
(
auto
e
:
entries
)
{
if
(
e
.
to_be_indexed
)
{
return
true
;
}
}
return
false
;
}
int32_t
TNUM
=
1
;
int32_t
TDEN
=
1000
;
std
:
:
vector
<
JxlEncoderFrameIndexBoxEntry
>
entries
;
void
AddFrame
(
uint64_t
OFFi
uint32_t
duration
bool
to_be_indexed
)
{
if
(
entries
.
size
(
)
=
=
1
)
{
if
(
OFFi
=
=
entries
[
0
]
.
OFFi
)
{
entries
.
clear
(
)
;
}
}
JxlEncoderFrameIndexBoxEntry
e
;
e
.
to_be_indexed
=
to_be_indexed
;
e
.
OFFi
=
OFFi
;
e
.
duration
=
duration
;
entries
.
push_back
(
e
)
;
}
}
JxlEncoderFrameIndexBox
;
typedef
struct
JxlEncoderFrameSettingsValuesStruct
{
bool
lossless
;
CompressParams
cparams
;
JxlFrameHeader
header
;
std
:
:
vector
<
JxlBlendInfo
>
extra_channel_blend_info
;
std
:
:
string
frame_name
;
JxlBitDepth
image_bit_depth
;
bool
frame_index_box
=
false
;
jxl
:
:
AuxOut
*
aux_out
=
nullptr
;
}
JxlEncoderFrameSettingsValues
;
typedef
std
:
:
array
<
uint8_t
4
>
BoxType
;
constexpr
BoxType
MakeBoxType
(
const
char
*
type
)
{
return
BoxType
(
{
{
static_cast
<
uint8_t
>
(
type
[
0
]
)
static_cast
<
uint8_t
>
(
type
[
1
]
)
static_cast
<
uint8_t
>
(
type
[
2
]
)
static_cast
<
uint8_t
>
(
type
[
3
]
)
}
}
)
;
}
constexpr
std
:
:
array
<
unsigned
char
32
>
kContainerHeader
=
{
0
0
0
0xc
'
J
'
'
X
'
'
L
'
'
'
0xd
0xa
0x87
0xa
0
0
0
0x14
'
f
'
'
t
'
'
y
'
'
p
'
'
j
'
'
x
'
'
l
'
'
'
0
0
0
0
'
j
'
'
x
'
'
l
'
'
'
}
;
constexpr
std
:
:
array
<
unsigned
char
8
>
kLevelBoxHeader
=
{
0
0
0
0x9
'
j
'
'
x
'
'
l
'
'
l
'
}
;
struct
JxlEncoderQueuedFrame
{
JxlEncoderFrameSettingsValues
option_values
;
ImageBundle
frame
;
std
:
:
vector
<
uint8_t
>
ec_initialized
;
}
;
struct
JxlEncoderQueuedBox
{
BoxType
type
;
std
:
:
vector
<
uint8_t
>
contents
;
bool
compress_box
;
}
;
using
FJXLFrameUniquePtr
=
std
:
:
unique_ptr
<
JxlFastLosslessFrameState
decltype
(
&
JxlFastLosslessFreeFrameState
)
>
;
struct
JxlEncoderQueuedInput
{
explicit
JxlEncoderQueuedInput
(
const
JxlMemoryManager
&
memory_manager
)
:
frame
(
nullptr
jxl
:
:
MemoryManagerDeleteHelper
(
&
memory_manager
)
)
box
(
nullptr
jxl
:
:
MemoryManagerDeleteHelper
(
&
memory_manager
)
)
{
}
MemoryManagerUniquePtr
<
JxlEncoderQueuedFrame
>
frame
;
MemoryManagerUniquePtr
<
JxlEncoderQueuedBox
>
box
;
FJXLFrameUniquePtr
fast_lossless_frame
=
{
nullptr
JxlFastLosslessFreeFrameState
}
;
}
;
static
constexpr
size_t
kSmallBoxHeaderSize
=
8
;
static
constexpr
size_t
kLargeBoxHeaderSize
=
16
;
static
constexpr
size_t
kLargeBoxContentSizeThreshold
=
0x100000000ull
-
kSmallBoxHeaderSize
;
size_t
WriteBoxHeader
(
const
jxl
:
:
BoxType
&
type
size_t
size
bool
unbounded
bool
force_large_box
uint8_t
*
output
)
;
template
<
typename
T
>
void
AppendBoxHeader
(
const
jxl
:
:
BoxType
&
type
size_t
size
bool
unbounded
T
*
output
)
{
size_t
current_size
=
output
-
>
size
(
)
;
output
-
>
resize
(
current_size
+
kLargeBoxHeaderSize
)
;
size_t
header_size
=
WriteBoxHeader
(
type
size
unbounded
false
output
-
>
data
(
)
+
current_size
)
;
output
-
>
resize
(
current_size
+
header_size
)
;
}
}
class
JxlOutputProcessorBuffer
;
class
JxlEncoderOutputProcessorWrapper
{
friend
class
JxlOutputProcessorBuffer
;
public
:
JxlEncoderOutputProcessorWrapper
(
)
=
default
;
explicit
JxlEncoderOutputProcessorWrapper
(
JxlEncoderOutputProcessor
processor
)
:
external_output_processor_
(
jxl
:
:
make_unique
<
JxlEncoderOutputProcessor
>
(
processor
)
)
{
}
bool
HasAvailOut
(
)
const
{
return
avail_out_
!
=
nullptr
;
}
jxl
:
:
StatusOr
<
JxlOutputProcessorBuffer
>
GetBuffer
(
size_t
min_size
size_t
requested_size
=
0
)
;
void
Seek
(
size_t
pos
)
;
void
SetFinalizedPosition
(
)
;
size_t
CurrentPosition
(
)
const
{
return
position_
;
}
bool
SetAvailOut
(
uint8_t
*
*
next_out
size_t
*
avail_out
)
;
bool
WasStopRequested
(
)
const
{
return
stop_requested_
;
}
bool
OutputProcessorSet
(
)
const
{
return
external_output_processor_
!
=
nullptr
;
}
bool
HasOutputToWrite
(
)
const
{
return
output_position_
<
finalized_position_
;
}
private
:
void
ReleaseBuffer
(
size_t
bytes_used
)
;
void
FlushOutput
(
)
;
bool
AppendBufferToExternalProcessor
(
void
*
data
size_t
count
)
;
struct
InternalBuffer
{
size_t
written_bytes
=
0
;
jxl
:
:
PaddedBytes
owned_data
;
}
;
std
:
:
map
<
size_t
InternalBuffer
>
internal_buffers_
;
uint8_t
*
*
next_out_
=
nullptr
;
size_t
*
avail_out_
=
nullptr
;
size_t
position_
=
0
;
size_t
finalized_position_
=
0
;
size_t
output_position_
=
0
;
bool
stop_requested_
=
false
;
bool
has_buffer_
=
false
;
std
:
:
unique_ptr
<
JxlEncoderOutputProcessor
>
external_output_processor_
;
}
;
class
JxlOutputProcessorBuffer
{
public
:
size_t
size
(
)
const
{
return
size_
;
}
;
uint8_t
*
data
(
)
{
return
data_
;
}
JxlOutputProcessorBuffer
(
uint8_t
*
buffer
size_t
size
size_t
bytes_used
JxlEncoderOutputProcessorWrapper
*
wrapper
)
:
data_
(
buffer
)
size_
(
size
)
bytes_used_
(
bytes_used
)
wrapper_
(
wrapper
)
{
}
~
JxlOutputProcessorBuffer
(
)
{
release
(
)
;
}
JxlOutputProcessorBuffer
(
const
JxlOutputProcessorBuffer
&
)
=
delete
;
JxlOutputProcessorBuffer
(
JxlOutputProcessorBuffer
&
&
other
)
noexcept
:
JxlOutputProcessorBuffer
(
other
.
data_
other
.
size_
other
.
bytes_used_
other
.
wrapper_
)
{
other
.
data_
=
nullptr
;
other
.
size_
=
0
;
}
void
advance
(
size_t
count
)
{
JXL_ASSERT
(
count
<
=
size_
)
;
data_
+
=
count
;
size_
-
=
count
;
bytes_used_
+
=
count
;
}
void
release
(
)
{
if
(
this
-
>
data_
)
{
wrapper_
-
>
ReleaseBuffer
(
bytes_used_
)
;
}
data_
=
nullptr
;
size_
=
0
;
}
void
append
(
const
void
*
data
size_t
count
)
{
memcpy
(
data_
data
count
)
;
advance
(
count
)
;
}
template
<
typename
T
>
void
append
(
const
T
&
data
)
{
static_assert
(
sizeof
(
*
std
:
:
begin
(
data
)
)
=
=
1
"
Cannot
append
non
-
bytes
"
)
;
append
(
&
*
std
:
:
begin
(
data
)
std
:
:
end
(
data
)
-
std
:
:
begin
(
data
)
)
;
}
JxlOutputProcessorBuffer
&
operator
=
(
const
JxlOutputProcessorBuffer
&
)
=
delete
;
JxlOutputProcessorBuffer
&
operator
=
(
JxlOutputProcessorBuffer
&
&
other
)
noexcept
{
data_
=
other
.
data_
;
size_
=
other
.
size_
;
wrapper_
=
other
.
wrapper_
;
return
*
this
;
}
private
:
uint8_t
*
data_
;
size_t
size_
;
size_t
bytes_used_
;
JxlEncoderOutputProcessorWrapper
*
wrapper_
;
}
;
struct
JxlEncoderStruct
{
JxlEncoderError
error
=
JxlEncoderError
:
:
JXL_ENC_ERR_OK
;
JxlMemoryManager
memory_manager
;
jxl
:
:
MemoryManagerUniquePtr
<
jxl
:
:
ThreadPool
>
thread_pool
{
nullptr
jxl
:
:
MemoryManagerDeleteHelper
(
&
memory_manager
)
}
;
JxlCmsInterface
cms
;
bool
cms_set
;
std
:
:
vector
<
jxl
:
:
MemoryManagerUniquePtr
<
JxlEncoderFrameSettings
>
>
encoder_options
;
size_t
num_queued_frames
;
size_t
num_queued_boxes
;
std
:
:
vector
<
jxl
:
:
JxlEncoderQueuedInput
>
input_queue
;
JxlEncoderOutputProcessorWrapper
output_processor
;
size_t
codestream_bytes_written_beginning_of_frame
;
size_t
codestream_bytes_written_end_of_frame
;
jxl
:
:
JxlEncoderFrameIndexBox
frame_index_box
;
bool
use_container
;
bool
use_boxes
;
int32_t
codestream_level
;
bool
store_jpeg_metadata
;
jxl
:
:
CodecMetadata
metadata
;
std
:
:
vector
<
uint8_t
>
jpeg_metadata
;
bool
wrote_bytes
;
jxl
:
:
CompressParams
last_used_cparams
;
JxlBasicInfo
basic_info
;
size_t
jxlp_counter
;
bool
frames_closed
;
bool
boxes_closed
;
bool
basic_info_set
;
bool
color_encoding_set
;
bool
intensity_target_set
;
bool
allow_expert_options
=
false
;
int
brotli_effort
=
-
1
;
jxl
:
:
Status
ProcessOneEnqueuedInput
(
)
;
bool
MustUseContainer
(
)
const
{
return
use_container
|
|
(
codestream_level
!
=
5
&
&
codestream_level
!
=
-
1
)
|
|
store_jpeg_metadata
|
|
use_boxes
;
}
template
<
typename
WriteBox
>
jxl
:
:
Status
AppendBox
(
const
jxl
:
:
BoxType
&
type
bool
unbounded
size_t
box_max_size
const
WriteBox
&
write_box
)
;
template
<
typename
BoxContents
>
jxl
:
:
Status
AppendBoxWithContents
(
const
jxl
:
:
BoxType
&
type
const
BoxContents
&
contents
)
;
}
;
struct
JxlEncoderFrameSettingsStruct
{
JxlEncoder
*
enc
;
jxl
:
:
JxlEncoderFrameSettingsValues
values
;
}
;
struct
JxlEncoderStatsStruct
{
jxl
:
:
AuxOut
aux_out
;
}
;
#
endif
