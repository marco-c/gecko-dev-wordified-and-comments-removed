#
ifndef
LIB_JXL_ENCODE_INTERNAL_H_
#
define
LIB_JXL_ENCODE_INTERNAL_H_
#
include
<
deque
>
#
include
<
vector
>
#
include
"
enc_fast_lossless
.
h
"
#
include
"
jxl
/
encode
.
h
"
#
include
"
jxl
/
memory_manager
.
h
"
#
include
"
jxl
/
parallel_runner
.
h
"
#
include
"
jxl
/
types
.
h
"
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
enc_frame
.
h
"
#
include
"
lib
/
jxl
/
memory_manager_internal
.
h
"
namespace
jxl
{
typedef
struct
JxlEncoderFrameIndexBoxEntryStruct
{
bool
to_be_indexed
;
uint32_t
duration
;
uint64_t
OFFi
;
}
JxlEncoderFrameIndexBoxEntry
;
typedef
struct
JxlEncoderFrameIndexBoxStruct
{
bool
index_box_requested_through_api
=
false
;
int64_t
NF
(
)
const
{
return
entries
.
size
(
)
;
}
bool
StoreFrameIndexBox
(
)
{
for
(
auto
e
:
entries
)
{
if
(
e
.
to_be_indexed
)
{
return
true
;
}
}
return
false
;
}
int32_t
TNUM
=
1
;
int32_t
TDEN
=
1000
;
std
:
:
vector
<
JxlEncoderFrameIndexBoxEntry
>
entries
;
void
AddFrame
(
uint64_t
OFFi
uint32_t
duration
bool
to_be_indexed
)
{
if
(
entries
.
size
(
)
=
=
1
)
{
if
(
OFFi
=
=
entries
[
0
]
.
OFFi
)
{
entries
.
clear
(
)
;
}
}
JxlEncoderFrameIndexBoxEntry
e
;
e
.
to_be_indexed
=
to_be_indexed
;
e
.
OFFi
=
OFFi
;
e
.
duration
=
duration
;
entries
.
push_back
(
e
)
;
}
}
JxlEncoderFrameIndexBox
;
typedef
struct
JxlEncoderFrameSettingsValuesStruct
{
bool
lossless
;
CompressParams
cparams
;
JxlFrameHeader
header
;
std
:
:
vector
<
JxlBlendInfo
>
extra_channel_blend_info
;
std
:
:
string
frame_name
;
JxlBitDepth
image_bit_depth
;
bool
frame_index_box
=
false
;
}
JxlEncoderFrameSettingsValues
;
typedef
std
:
:
array
<
uint8_t
4
>
BoxType
;
constexpr
BoxType
MakeBoxType
(
const
char
*
type
)
{
return
BoxType
(
{
{
static_cast
<
uint8_t
>
(
type
[
0
]
)
static_cast
<
uint8_t
>
(
type
[
1
]
)
static_cast
<
uint8_t
>
(
type
[
2
]
)
static_cast
<
uint8_t
>
(
type
[
3
]
)
}
}
)
;
}
constexpr
unsigned
char
kContainerHeader
[
]
=
{
0
0
0
0xc
'
J
'
'
X
'
'
L
'
'
'
0xd
0xa
0x87
0xa
0
0
0
0x14
'
f
'
'
t
'
'
y
'
'
p
'
'
j
'
'
x
'
'
l
'
'
'
0
0
0
0
'
j
'
'
x
'
'
l
'
'
'
}
;
constexpr
unsigned
char
kLevelBoxHeader
[
]
=
{
0
0
0
0x9
'
j
'
'
x
'
'
l
'
'
l
'
}
;
struct
JxlEncoderQueuedFrame
{
JxlEncoderFrameSettingsValues
option_values
;
ImageBundle
frame
;
std
:
:
vector
<
uint8_t
>
ec_initialized
;
}
;
struct
JxlEncoderQueuedBox
{
BoxType
type
;
std
:
:
vector
<
uint8_t
>
contents
;
bool
compress_box
;
}
;
using
FJXLFrameUniquePtr
=
std
:
:
unique_ptr
<
JxlFastLosslessFrameState
decltype
(
&
JxlFastLosslessFreeFrameState
)
>
;
struct
JxlEncoderQueuedInput
{
explicit
JxlEncoderQueuedInput
(
const
JxlMemoryManager
&
memory_manager
)
:
frame
(
nullptr
jxl
:
:
MemoryManagerDeleteHelper
(
&
memory_manager
)
)
box
(
nullptr
jxl
:
:
MemoryManagerDeleteHelper
(
&
memory_manager
)
)
{
}
MemoryManagerUniquePtr
<
JxlEncoderQueuedFrame
>
frame
;
MemoryManagerUniquePtr
<
JxlEncoderQueuedBox
>
box
;
FJXLFrameUniquePtr
fast_lossless_frame
=
{
nullptr
JxlFastLosslessFreeFrameState
}
;
}
;
template
<
typename
T
>
void
AppendBoxHeader
(
const
jxl
:
:
BoxType
&
type
size_t
size
bool
unbounded
T
*
output
)
{
uint64_t
box_size
=
0
;
bool
large_size
=
false
;
if
(
!
unbounded
)
{
box_size
=
size
+
8
;
if
(
box_size
>
=
0x100000000ull
)
{
large_size
=
true
;
}
}
{
const
uint64_t
store
=
large_size
?
1
:
box_size
;
for
(
size_t
i
=
0
;
i
<
4
;
i
+
+
)
{
output
-
>
push_back
(
store
>
>
(
8
*
(
3
-
i
)
)
&
0xff
)
;
}
}
for
(
size_t
i
=
0
;
i
<
4
;
i
+
+
)
{
output
-
>
push_back
(
type
[
i
]
)
;
}
if
(
large_size
)
{
for
(
size_t
i
=
0
;
i
<
8
;
i
+
+
)
{
output
-
>
push_back
(
box_size
>
>
(
8
*
(
7
-
i
)
)
&
0xff
)
;
}
}
}
}
struct
JxlEncoderStruct
{
JxlEncoderError
error
=
JxlEncoderError
:
:
JXL_ENC_ERR_OK
;
JxlMemoryManager
memory_manager
;
jxl
:
:
MemoryManagerUniquePtr
<
jxl
:
:
ThreadPool
>
thread_pool
{
nullptr
jxl
:
:
MemoryManagerDeleteHelper
(
&
memory_manager
)
}
;
JxlCmsInterface
cms
;
std
:
:
vector
<
jxl
:
:
MemoryManagerUniquePtr
<
JxlEncoderFrameSettings
>
>
encoder_options
;
size_t
num_queued_frames
;
size_t
num_queued_boxes
;
std
:
:
vector
<
jxl
:
:
JxlEncoderQueuedInput
>
input_queue
;
std
:
:
deque
<
uint8_t
>
output_byte_queue
;
std
:
:
deque
<
jxl
:
:
FJXLFrameUniquePtr
>
output_fast_frame_queue
;
size_t
codestream_bytes_written_beginning_of_frame
;
size_t
codestream_bytes_written_end_of_frame
;
jxl
:
:
JxlEncoderFrameIndexBox
frame_index_box
;
bool
use_container
;
bool
use_boxes
;
int32_t
codestream_level
;
bool
store_jpeg_metadata
;
jxl
:
:
CodecMetadata
metadata
;
std
:
:
vector
<
uint8_t
>
jpeg_metadata
;
bool
wrote_bytes
;
jxl
:
:
CompressParams
last_used_cparams
;
JxlBasicInfo
basic_info
;
size_t
jxlp_counter
;
bool
frames_closed
;
bool
boxes_closed
;
bool
basic_info_set
;
bool
color_encoding_set
;
bool
intensity_target_set
;
int
brotli_effort
=
-
1
;
JxlEncoderStatus
RefillOutputByteQueue
(
)
;
bool
MustUseContainer
(
)
const
{
return
use_container
|
|
(
codestream_level
!
=
5
&
&
codestream_level
!
=
-
1
)
|
|
store_jpeg_metadata
|
|
use_boxes
;
}
void
AppendBoxHeader
(
const
jxl
:
:
BoxType
&
type
size_t
size
bool
unbounded
)
;
}
;
struct
JxlEncoderFrameSettingsStruct
{
JxlEncoder
*
enc
;
jxl
:
:
JxlEncoderFrameSettingsValues
values
;
}
;
#
endif
