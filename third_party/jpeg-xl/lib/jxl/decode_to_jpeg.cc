#
include
"
lib
/
jxl
/
decode_to_jpeg
.
h
"
namespace
jxl
{
#
if
JPEGXL_ENABLE_TRANSCODE_JPEG
JxlDecoderStatus
JxlToJpegDecoder
:
:
Process
(
const
uint8_t
*
*
next_in
size_t
*
avail_in
)
{
if
(
!
inside_box_
)
{
JXL_ABORT
(
"
processing
of
JPEG
reconstruction
data
outside
JPEG
reconstruction
"
"
box
"
)
;
}
Span
<
const
uint8_t
>
to_decode
;
if
(
box_until_eof_
)
{
to_decode
=
Span
<
const
uint8_t
>
(
*
next_in
*
avail_in
)
;
*
next_in
+
=
*
avail_in
;
*
avail_in
=
0
;
}
else
{
size_t
avail_recon_in
=
std
:
:
min
<
size_t
>
(
*
avail_in
box_size_
-
buffer_
.
size
(
)
)
;
to_decode
=
Span
<
const
uint8_t
>
(
*
next_in
avail_recon_in
)
;
*
next_in
+
=
avail_recon_in
;
*
avail_in
-
=
avail_recon_in
;
}
bool
old_data_exists
=
!
buffer_
.
empty
(
)
;
if
(
old_data_exists
)
{
buffer_
.
insert
(
buffer_
.
end
(
)
to_decode
.
data
(
)
to_decode
.
data
(
)
+
to_decode
.
size
(
)
)
;
to_decode
=
Span
<
const
uint8_t
>
(
buffer_
.
data
(
)
buffer_
.
size
(
)
)
;
}
if
(
!
box_until_eof_
&
&
to_decode
.
size
(
)
>
box_size_
)
{
JXL_ABORT
(
"
JPEG
reconstruction
data
to
decode
larger
than
expected
"
)
;
}
if
(
box_until_eof_
|
|
to_decode
.
size
(
)
=
=
box_size_
)
{
jpeg_data_
=
make_unique
<
jpeg
:
:
JPEGData
>
(
)
;
const
auto
status
=
jpeg
:
:
DecodeJPEGData
(
to_decode
jpeg_data_
.
get
(
)
)
;
if
(
status
.
IsFatalError
(
)
)
return
JXL_DEC_ERROR
;
if
(
status
)
{
inside_box_
=
false
;
return
JXL_DEC_JPEG_RECONSTRUCTION
;
}
if
(
box_until_eof_
)
{
if
(
!
old_data_exists
)
{
buffer_
.
insert
(
buffer_
.
end
(
)
to_decode
.
data
(
)
to_decode
.
data
(
)
+
to_decode
.
size
(
)
)
;
}
}
else
{
return
JXL_DEC_ERROR
;
}
}
else
{
if
(
!
old_data_exists
)
{
buffer_
.
insert
(
buffer_
.
end
(
)
to_decode
.
data
(
)
to_decode
.
data
(
)
+
to_decode
.
size
(
)
)
;
}
}
return
JXL_DEC_NEED_MORE_INPUT
;
}
#
endif
}
