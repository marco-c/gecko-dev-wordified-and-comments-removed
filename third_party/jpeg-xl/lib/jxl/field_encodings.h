#
ifndef
LIB_JXL_FIELD_ENCODINGS_H_
#
define
LIB_JXL_FIELD_ENCODINGS_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
hwy
/
base
.
h
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
base
/
bits
.
h
"
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
namespace
jxl
{
#
if
(
JXL_IS_DEBUG_BUILD
)
#
define
JXL_FIELDS_NAME
(
X
)
\
const
char
*
Name
(
)
const
override
{
return
#
X
;
}
#
else
#
define
JXL_FIELDS_NAME
(
X
)
#
endif
class
Visitor
;
class
Fields
{
public
:
virtual
~
Fields
(
)
=
default
;
#
if
(
JXL_IS_DEBUG_BUILD
)
virtual
const
char
*
Name
(
)
const
=
0
;
#
endif
virtual
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
=
0
;
}
;
struct
U32Distr
{
constexpr
explicit
U32Distr
(
uint32_t
d
)
:
d
(
d
)
{
}
static
constexpr
uint32_t
kDirect
=
0x80000000u
;
constexpr
bool
IsDirect
(
)
const
{
return
(
d
&
kDirect
)
!
=
0
;
}
constexpr
uint32_t
Direct
(
)
const
{
return
d
&
(
kDirect
-
1
)
;
}
constexpr
size_t
ExtraBits
(
)
const
{
return
(
d
&
0x1F
)
+
1
;
}
uint32_t
Offset
(
)
const
{
return
(
d
>
>
5
)
&
0x3FFFFFF
;
}
uint32_t
d
;
}
;
constexpr
U32Distr
Val
(
uint32_t
value
)
{
return
U32Distr
(
value
|
U32Distr
:
:
kDirect
)
;
}
constexpr
U32Distr
BitsOffset
(
uint32_t
bits
uint32_t
offset
)
{
return
U32Distr
(
(
(
bits
-
1
)
&
0x1F
)
+
(
(
offset
&
0x3FFFFFF
)
<
<
5
)
)
;
}
constexpr
U32Distr
Bits
(
uint32_t
bits
)
{
return
BitsOffset
(
bits
0
)
;
}
class
U32Enc
{
public
:
constexpr
U32Enc
(
const
U32Distr
d0
const
U32Distr
d1
const
U32Distr
d2
const
U32Distr
d3
)
:
d_
{
d0
d1
d2
d3
}
{
}
U32Distr
GetDistr
(
const
uint32_t
selector
)
const
{
JXL_DASSERT
(
selector
<
4
)
;
return
d_
[
selector
]
;
}
private
:
U32Distr
d_
[
4
]
;
}
;
template
<
typename
T
>
static
inline
constexpr
uint64_t
MakeBit
(
T
index
)
{
return
1ULL
<
<
static_cast
<
uint32_t
>
(
index
)
;
}
template
<
typename
Enum
>
std
:
:
vector
<
Enum
>
Values
(
)
{
uint64_t
bits
=
EnumBits
(
Enum
(
)
)
;
std
:
:
vector
<
Enum
>
values
;
values
.
reserve
(
hwy
:
:
PopCount
(
bits
)
)
;
while
(
bits
!
=
0
)
{
const
int
index
=
Num0BitsBelowLS1Bit_Nonzero
(
bits
)
;
values
.
push_back
(
static_cast
<
Enum
>
(
index
)
)
;
bits
&
=
bits
-
1
;
}
return
values
;
}
template
<
class
Enum
>
Status
EnumValid
(
const
Enum
value
)
{
if
(
static_cast
<
uint32_t
>
(
value
)
>
=
64
)
{
return
JXL_FAILURE
(
"
Value
%
u
too
large
for
%
s
\
n
"
static_cast
<
uint32_t
>
(
value
)
EnumName
(
Enum
(
)
)
)
;
}
const
uint64_t
bit
=
MakeBit
(
value
)
;
if
(
(
EnumBits
(
Enum
(
)
)
&
bit
)
=
=
0
)
{
return
JXL_FAILURE
(
"
Invalid
value
%
u
for
%
s
\
n
"
static_cast
<
uint32_t
>
(
value
)
EnumName
(
Enum
(
)
)
)
;
}
return
true
;
}
}
#
endif
