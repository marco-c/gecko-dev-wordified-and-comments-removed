#
ifndef
LIB_JXL_DEC_CACHE_H_
#
define
LIB_JXL_DEC_CACHE_H_
#
include
<
stdint
.
h
>
#
include
<
hwy
/
base
.
h
>
#
include
"
lib
/
jxl
/
ac_strategy
.
h
"
#
include
"
lib
/
jxl
/
base
/
profiler
.
h
"
#
include
"
lib
/
jxl
/
coeff_order
.
h
"
#
include
"
lib
/
jxl
/
common
.
h
"
#
include
"
lib
/
jxl
/
convolve
.
h
"
#
include
"
lib
/
jxl
/
dec_group_border
.
h
"
#
include
"
lib
/
jxl
/
dec_noise
.
h
"
#
include
"
lib
/
jxl
/
dec_upsample
.
h
"
#
include
"
lib
/
jxl
/
filters
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
#
include
"
lib
/
jxl
/
passes_state
.
h
"
#
include
"
lib
/
jxl
/
quant_weights
.
h
"
namespace
jxl
{
struct
PassesDecoderState
{
PassesSharedState
shared_storage
;
const
PassesSharedState
*
JXL_RESTRICT
shared
=
&
shared_storage
;
Upsampler
upsamplers
[
3
]
;
Image3F
noise
;
Image3F
pre_color_transform_frame
;
std
:
:
vector
<
ImageF
>
pre_color_transform_ec
;
std
:
:
vector
<
ANSCode
>
code
;
std
:
:
vector
<
std
:
:
vector
<
uint8_t
>
>
context_map
;
float
x_dm_multiplier
;
float
b_dm_multiplier
;
Image3F
decoded
;
std
:
:
vector
<
ImageF
>
extra_channels
;
Image3F
borders_horizontal
;
Image3F
borders_vertical
;
uint8_t
*
rgb_output
;
size_t
rgb_stride
=
0
;
bool
fast_xyb_srgb8_conversion
;
bool
rgb_output_is_rgba
;
std
:
:
function
<
void
(
const
float
*
size_t
size_t
size_t
)
>
pixel_callback
;
std
:
:
vector
<
float
>
opaque_alpha
;
std
:
:
vector
<
std
:
:
vector
<
float
>
>
pixel_callback_rows
;
size_t
noise_seed
=
0
;
std
:
:
atomic
<
uint32_t
>
used_acs
{
0
}
;
std
:
:
unique_ptr
<
ACImage
>
coefficients
=
make_unique
<
ACImageT
<
int32_t
>
>
(
0
0
)
;
std
:
:
vector
<
FilterPipeline
>
filter_pipelines
;
FilterWeights
filter_weights
;
GroupBorderAssigner
group_border_assigner
;
bool
EagerFinalizeImageRect
(
)
const
{
return
shared
-
>
frame_header
.
chroma_subsampling
.
Is444
(
)
&
&
shared
-
>
frame_header
.
encoding
=
=
FrameEncoding
:
:
kVarDCT
&
&
shared
-
>
frame_header
.
nonserialized_metadata
-
>
m
.
extra_channel_info
.
empty
(
)
;
}
size_t
FinalizeRectPadding
(
)
const
{
size_t
padding
=
shared
-
>
frame_header
.
loop_filter
.
Padding
(
)
;
padding
+
=
shared
-
>
frame_header
.
upsampling
=
=
1
?
0
:
2
;
JXL_DASSERT
(
padding
<
=
kMaxFinalizeRectPadding
)
;
for
(
auto
ups
:
shared
-
>
frame_header
.
extra_channel_upsampling
)
{
if
(
ups
>
1
)
{
padding
=
std
:
:
max
(
padding
size_t
{
2
}
)
;
}
}
return
padding
;
}
std
:
:
vector
<
Image3F
>
filter_input_storage
;
std
:
:
vector
<
Image3F
>
padded_upsampling_input_storage
;
std
:
:
vector
<
Image3F
>
upsampling_input_storage
;
std
:
:
vector
<
Image3F
>
output_pixel_data_storage
[
4
]
=
{
}
;
std
:
:
vector
<
ImageF
>
ec_temp_images
;
std
:
:
vector
<
Image3F
>
group_data
;
static
constexpr
size_t
kGroupDataYBorder
=
kMaxFinalizeRectPadding
*
2
;
static
constexpr
size_t
kGroupDataXBorder
=
RoundUpToBlockDim
(
kMaxFinalizeRectPadding
)
*
2
+
kBlockDim
;
void
EnsureStorage
(
size_t
num_threads
)
{
if
(
shared
-
>
frame_header
.
loop_filter
.
epf_iters
!
=
0
|
|
shared
-
>
frame_header
.
loop_filter
.
gab
)
{
if
(
filter_pipelines
.
size
(
)
<
num_threads
)
{
filter_pipelines
.
resize
(
num_threads
)
;
}
}
for
(
size_t
_
=
filter_input_storage
.
size
(
)
;
_
<
num_threads
;
_
+
+
)
{
filter_input_storage
.
emplace_back
(
kApplyImageFeaturesTileDim
+
2
*
kGroupDataXBorder
kApplyImageFeaturesTileDim
+
2
*
kGroupDataYBorder
)
;
}
if
(
shared
-
>
frame_header
.
upsampling
!
=
1
)
{
for
(
size_t
_
=
upsampling_input_storage
.
size
(
)
;
_
<
num_threads
;
_
+
+
)
{
upsampling_input_storage
.
emplace_back
(
kApplyImageFeaturesTileDim
+
2
*
kBlockDim
kApplyImageFeaturesTileDim
+
4
)
;
padded_upsampling_input_storage
.
emplace_back
(
kApplyImageFeaturesTileDim
+
2
*
kBlockDim
kApplyImageFeaturesTileDim
+
4
)
;
}
}
for
(
size_t
_
=
group_data
.
size
(
)
;
_
<
num_threads
;
_
+
+
)
{
group_data
.
emplace_back
(
kGroupDim
+
2
*
kGroupDataXBorder
kGroupDim
+
2
*
kGroupDataYBorder
)
;
#
if
MEMORY_SANITIZER
ZeroFillImage
(
&
group_data
.
back
(
)
)
;
#
endif
}
if
(
rgb_output
|
|
pixel_callback
)
{
size_t
log2_upsampling
=
CeilLog2Nonzero
(
shared
-
>
frame_header
.
upsampling
)
;
for
(
size_t
_
=
output_pixel_data_storage
[
log2_upsampling
]
.
size
(
)
;
_
<
num_threads
;
_
+
+
)
{
output_pixel_data_storage
[
log2_upsampling
]
.
emplace_back
(
kApplyImageFeaturesTileDim
<
<
log2_upsampling
kApplyImageFeaturesTileDim
<
<
log2_upsampling
)
;
}
opaque_alpha
.
resize
(
kApplyImageFeaturesTileDim
*
shared
-
>
frame_header
.
upsampling
1
.
0f
)
;
if
(
pixel_callback
)
{
pixel_callback_rows
.
resize
(
num_threads
)
;
for
(
size_t
i
=
0
;
i
<
pixel_callback_rows
.
size
(
)
;
+
+
i
)
{
pixel_callback_rows
[
i
]
.
resize
(
kApplyImageFeaturesTileDim
*
shared
-
>
frame_header
.
upsampling
*
(
rgb_output_is_rgba
?
4
:
3
)
)
;
}
}
}
if
(
shared
-
>
metadata
-
>
m
.
num_extra_channels
*
num_threads
>
ec_temp_images
.
size
(
)
)
{
ec_temp_images
.
resize
(
shared
-
>
metadata
-
>
m
.
num_extra_channels
*
num_threads
)
;
}
for
(
size_t
i
=
0
;
i
<
shared
-
>
metadata
-
>
m
.
num_extra_channels
;
i
+
+
)
{
if
(
shared
-
>
frame_header
.
extra_channel_upsampling
[
i
]
=
=
1
)
continue
;
size_t
xs
=
kApplyImageFeaturesTileDim
*
shared
-
>
frame_header
.
upsampling
/
shared
-
>
frame_header
.
extra_channel_upsampling
[
i
]
+
2
*
kBlockDim
;
size_t
ys
=
kApplyImageFeaturesTileDim
*
shared
-
>
frame_header
.
upsampling
/
shared
-
>
frame_header
.
extra_channel_upsampling
[
i
]
+
4
;
for
(
size_t
t
=
0
;
t
<
num_threads
;
t
+
+
)
{
auto
&
eti
=
ec_temp_images
[
t
*
shared
-
>
metadata
-
>
m
.
num_extra_channels
+
i
]
;
if
(
eti
.
xsize
(
)
<
xs
|
|
eti
.
ysize
(
)
<
ys
)
{
eti
=
ImageF
(
xs
ys
)
;
}
}
}
}
OutputEncodingInfo
output_encoding_info
;
void
Init
(
)
{
x_dm_multiplier
=
std
:
:
pow
(
1
/
(
1
.
25f
)
shared
-
>
frame_header
.
x_qm_scale
-
2
.
0f
)
;
b_dm_multiplier
=
std
:
:
pow
(
1
/
(
1
.
25f
)
shared
-
>
frame_header
.
b_qm_scale
-
2
.
0f
)
;
rgb_output
=
nullptr
;
pixel_callback
=
nullptr
;
rgb_output_is_rgba
=
false
;
fast_xyb_srgb8_conversion
=
false
;
used_acs
=
0
;
group_border_assigner
.
Init
(
shared
-
>
frame_dim
)
;
const
LoopFilter
&
lf
=
shared
-
>
frame_header
.
loop_filter
;
filter_weights
.
Init
(
lf
shared
-
>
frame_dim
)
;
for
(
auto
&
fp
:
filter_pipelines
)
{
fp
.
num_filters
=
0
;
}
for
(
size_t
i
=
0
;
i
<
3
;
i
+
+
)
{
upsamplers
[
i
]
.
Init
(
2
<
<
i
shared
-
>
metadata
-
>
transform_data
)
;
}
}
void
InitForAC
(
ThreadPool
*
pool
)
{
shared_storage
.
coeff_order_size
=
0
;
for
(
uint8_t
o
=
0
;
o
<
AcStrategy
:
:
kNumValidStrategies
;
+
+
o
)
{
if
(
(
(
1
<
<
o
)
&
used_acs
)
=
=
0
)
continue
;
uint8_t
ord
=
kStrategyOrder
[
o
]
;
shared_storage
.
coeff_order_size
=
std
:
:
max
(
kCoeffOrderOffset
[
3
*
(
ord
+
1
)
]
*
kDCTBlockSize
shared_storage
.
coeff_order_size
)
;
}
size_t
sz
=
shared_storage
.
frame_header
.
passes
.
num_passes
*
shared_storage
.
coeff_order_size
;
if
(
sz
>
shared_storage
.
coeff_orders
.
size
(
)
)
{
shared_storage
.
coeff_orders
.
resize
(
sz
)
;
}
if
(
shared
-
>
frame_header
.
flags
&
FrameHeader
:
:
kNoise
)
{
noise
=
Image3F
(
shared
-
>
frame_dim
.
xsize_upsampled_padded
shared
-
>
frame_dim
.
ysize_upsampled_padded
)
;
size_t
num_x_groups
=
DivCeil
(
noise
.
xsize
(
)
kGroupDim
)
;
size_t
num_y_groups
=
DivCeil
(
noise
.
ysize
(
)
kGroupDim
)
;
PROFILER_ZONE
(
"
GenerateNoise
"
)
;
auto
generate_noise
=
[
&
]
(
int
group_index
int
_
)
{
size_t
gx
=
group_index
%
num_x_groups
;
size_t
gy
=
group_index
/
num_x_groups
;
Rect
rect
(
gx
*
kGroupDim
gy
*
kGroupDim
kGroupDim
kGroupDim
noise
.
xsize
(
)
noise
.
ysize
(
)
)
;
RandomImage3
(
noise_seed
+
group_index
rect
&
noise
)
;
}
;
RunOnPool
(
pool
0
num_x_groups
*
num_y_groups
ThreadPool
:
:
SkipInit
(
)
generate_noise
"
Generate
noise
"
)
;
{
PROFILER_ZONE
(
"
High
pass
noise
"
)
;
WeightsSymmetric5
weights
{
{
HWY_REP4
(
-
3
.
84
)
}
{
HWY_REP4
(
0
.
16
)
}
{
HWY_REP4
(
0
.
16
)
}
{
HWY_REP4
(
0
.
16
)
}
{
HWY_REP4
(
0
.
16
)
}
{
HWY_REP4
(
0
.
16
)
}
}
;
ImageF
noise_tmp
(
noise
.
xsize
(
)
noise
.
ysize
(
)
)
;
for
(
size_t
c
=
0
;
c
<
3
;
c
+
+
)
{
Symmetric5
(
noise
.
Plane
(
c
)
Rect
(
noise
)
weights
pool
&
noise_tmp
)
;
std
:
:
swap
(
noise
.
Plane
(
c
)
noise_tmp
)
;
}
noise_seed
+
=
shared
-
>
frame_dim
.
num_groups
;
}
}
EnsureBordersStorage
(
)
;
if
(
!
EagerFinalizeImageRect
(
)
)
{
decoded
=
Image3F
(
shared
-
>
frame_dim
.
xsize_padded
shared
-
>
frame_dim
.
ysize_padded
)
;
}
#
if
MEMORY_SANITIZER
ZeroFillImage
(
&
decoded
)
;
#
endif
}
void
EnsureBordersStorage
(
)
{
if
(
!
EagerFinalizeImageRect
(
)
)
return
;
size_t
padding
=
FinalizeRectPadding
(
)
;
size_t
bordery
=
2
*
padding
;
size_t
borderx
=
padding
+
group_border_assigner
.
PaddingX
(
padding
)
;
Rect
horizontal
=
Rect
(
0
0
shared
-
>
frame_dim
.
xsize_padded
bordery
*
shared
-
>
frame_dim
.
ysize_groups
*
2
)
;
if
(
!
SameSize
(
horizontal
borders_horizontal
)
)
{
borders_horizontal
=
Image3F
(
horizontal
.
xsize
(
)
horizontal
.
ysize
(
)
)
;
}
Rect
vertical
=
Rect
(
0
0
borderx
*
shared
-
>
frame_dim
.
xsize_groups
*
2
shared
-
>
frame_dim
.
ysize_padded
)
;
if
(
!
SameSize
(
vertical
borders_vertical
)
)
{
borders_vertical
=
Image3F
(
vertical
.
xsize
(
)
vertical
.
ysize
(
)
)
;
}
}
}
;
struct
GroupDecCache
{
void
InitOnce
(
size_t
num_passes
size_t
used_acs
)
{
PROFILER_FUNC
;
for
(
size_t
i
=
0
;
i
<
num_passes
;
i
+
+
)
{
if
(
num_nzeroes
[
i
]
.
xsize
(
)
=
=
0
)
{
num_nzeroes
[
i
]
=
Image3I
(
kGroupDimInBlocks
kGroupDimInBlocks
)
;
}
}
size_t
max_block_area
=
0
;
for
(
uint8_t
o
=
0
;
o
<
AcStrategy
:
:
kNumValidStrategies
;
+
+
o
)
{
AcStrategy
acs
=
AcStrategy
:
:
FromRawStrategy
(
o
)
;
if
(
(
used_acs
&
(
1
<
<
o
)
)
=
=
0
)
continue
;
size_t
area
=
acs
.
covered_blocks_x
(
)
*
acs
.
covered_blocks_y
(
)
*
kDCTBlockSize
;
max_block_area
=
std
:
:
max
(
area
max_block_area
)
;
}
if
(
max_block_area
>
max_block_area_
)
{
max_block_area_
=
max_block_area
;
float_memory_
=
hwy
:
:
AllocateAligned
<
float
>
(
max_block_area_
*
4
)
;
int32_memory_
=
hwy
:
:
AllocateAligned
<
int32_t
>
(
max_block_area_
*
3
)
;
int16_memory_
=
hwy
:
:
AllocateAligned
<
int16_t
>
(
max_block_area_
*
3
)
;
}
dec_group_block
=
float_memory_
.
get
(
)
;
scratch_space
=
dec_group_block
+
max_block_area_
*
3
;
dec_group_qblock
=
int32_memory_
.
get
(
)
;
dec_group_qblock16
=
int16_memory_
.
get
(
)
;
}
float
*
dec_group_block
;
int32_t
*
dec_group_qblock
;
int16_t
*
dec_group_qblock16
;
float
*
scratch_space
;
Image3I
num_nzeroes
[
kMaxNumPasses
]
;
private
:
hwy
:
:
AlignedFreeUniquePtr
<
float
[
]
>
float_memory_
;
hwy
:
:
AlignedFreeUniquePtr
<
int32_t
[
]
>
int32_memory_
;
hwy
:
:
AlignedFreeUniquePtr
<
int16_t
[
]
>
int16_memory_
;
size_t
max_block_area_
=
0
;
}
;
}
#
endif
