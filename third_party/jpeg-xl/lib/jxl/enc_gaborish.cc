#
include
"
lib
/
jxl
/
enc_gaborish
.
h
"
#
include
<
stddef
.
h
>
#
include
<
hwy
/
base
.
h
>
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
convolve
.
h
"
#
include
"
lib
/
jxl
/
image_ops
.
h
"
namespace
jxl
{
void
GaborishInverse
(
Image3F
*
in_out
float
mul
[
3
]
ThreadPool
*
pool
)
{
WeightsSymmetric5
weights
[
3
]
;
static
const
float
kGaborish
[
5
]
=
{
-
0
.
090881924078487886f
-
0
.
043663953593472138f
0
.
01392497846646211f
0
.
0036189602184591141f
0
.
0030557936884763499f
}
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
double
sum
=
1
.
0
+
mul
[
i
]
*
4
*
(
kGaborish
[
0
]
+
kGaborish
[
1
]
+
kGaborish
[
2
]
+
kGaborish
[
4
]
+
2
*
kGaborish
[
3
]
)
;
if
(
sum
<
1e
-
5
)
{
sum
=
1e
-
5
;
}
const
float
normalize
=
static_cast
<
float
>
(
1
.
0
/
sum
)
;
const
float
normalize_mul
=
mul
[
i
]
*
normalize
;
weights
[
i
]
=
WeightsSymmetric5
{
{
HWY_REP4
(
normalize
)
}
{
HWY_REP4
(
normalize_mul
*
kGaborish
[
0
]
)
}
{
HWY_REP4
(
normalize_mul
*
kGaborish
[
2
]
)
}
{
HWY_REP4
(
normalize_mul
*
kGaborish
[
1
]
)
}
{
HWY_REP4
(
normalize_mul
*
kGaborish
[
4
]
)
}
{
HWY_REP4
(
normalize_mul
*
kGaborish
[
3
]
)
}
}
;
}
ImageF
temp
=
CopyImage
(
in_out
-
>
Plane
(
2
)
)
;
Symmetric5
(
in_out
-
>
Plane
(
0
)
Rect
(
*
in_out
)
weights
[
0
]
pool
&
in_out
-
>
Plane
(
2
)
)
;
Symmetric5
(
in_out
-
>
Plane
(
1
)
Rect
(
*
in_out
)
weights
[
1
]
pool
&
in_out
-
>
Plane
(
0
)
)
;
Symmetric5
(
temp
Rect
(
*
in_out
)
weights
[
2
]
pool
&
in_out
-
>
Plane
(
1
)
)
;
in_out
-
>
Plane
(
0
)
.
Swap
(
in_out
-
>
Plane
(
1
)
)
;
in_out
-
>
Plane
(
0
)
.
Swap
(
in_out
-
>
Plane
(
2
)
)
;
}
}
