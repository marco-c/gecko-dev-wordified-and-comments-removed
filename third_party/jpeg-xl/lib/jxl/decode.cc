#
include
"
jxl
/
decode
.
h
"
#
include
"
lib
/
jxl
/
base
/
byte_order
.
h
"
#
include
"
lib
/
jxl
/
base
/
span
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
dec_external_image
.
h
"
#
include
"
lib
/
jxl
/
dec_frame
.
h
"
#
include
"
lib
/
jxl
/
dec_modular
.
h
"
#
include
"
lib
/
jxl
/
dec_reconstruct
.
h
"
#
include
"
lib
/
jxl
/
decode_to_jpeg
.
h
"
#
include
"
lib
/
jxl
/
fields
.
h
"
#
include
"
lib
/
jxl
/
headers
.
h
"
#
include
"
lib
/
jxl
/
icc_codec
.
h
"
#
include
"
lib
/
jxl
/
image_bundle
.
h
"
#
include
"
lib
/
jxl
/
loop_filter
.
h
"
#
include
"
lib
/
jxl
/
memory_manager_internal
.
h
"
#
include
"
lib
/
jxl
/
toc
.
h
"
namespace
{
size_t
memory_limit_base_
=
0
;
size_t
cpu_limit_base_
=
0
;
size_t
used_cpu_base_
=
0
;
bool
CheckSizeLimit
(
size_t
xsize
size_t
ysize
)
{
if
(
!
memory_limit_base_
)
return
true
;
if
(
xsize
=
=
0
|
|
ysize
=
=
0
)
return
true
;
size_t
num_pixels
=
xsize
*
ysize
;
if
(
num_pixels
/
xsize
!
=
ysize
)
return
false
;
if
(
num_pixels
>
memory_limit_base_
)
return
false
;
return
true
;
}
bool
OutOfBounds
(
size_t
a
size_t
b
size_t
size
)
{
size_t
pos
=
a
+
b
;
if
(
pos
>
size
)
return
true
;
if
(
pos
<
a
)
return
true
;
return
false
;
}
bool
OutOfBounds
(
size_t
a
size_t
b
size_t
c
size_t
size
)
{
size_t
pos
=
a
+
b
;
if
(
pos
<
b
)
return
true
;
pos
+
=
c
;
if
(
pos
<
c
)
return
true
;
if
(
pos
>
size
)
return
true
;
return
false
;
}
bool
SumOverflows
(
size_t
a
size_t
b
size_t
c
)
{
size_t
sum
=
a
+
b
;
if
(
sum
<
b
)
return
true
;
sum
+
=
c
;
if
(
sum
<
c
)
return
true
;
return
false
;
}
JXL_INLINE
size_t
InitialBasicInfoSizeHint
(
)
{
const
size_t
container_header_size
=
48
;
const
size_t
max_codestream_basic_info_size
=
50
;
return
container_header_size
+
max_codestream_basic_info_size
;
}
#
ifdef
JXL_CRASH_ON_ERROR
#
define
JXL_API_ERROR
(
format
.
.
.
)
\
(
:
:
jxl
:
:
Debug
(
(
"
%
s
:
%
d
:
"
format
"
\
n
"
)
__FILE__
__LINE__
#
#
__VA_ARGS__
)
\
:
:
jxl
:
:
Abort
(
)
JXL_DEC_ERROR
)
#
else
#
define
JXL_API_ERROR
(
format
.
.
.
)
\
(
(
(
JXL_DEBUG_ON_ERROR
)
&
&
\
:
:
jxl
:
:
Debug
(
(
"
%
s
:
%
d
:
"
format
"
\
n
"
)
__FILE__
__LINE__
#
#
__VA_ARGS__
)
)
\
JXL_DEC_ERROR
)
#
endif
JxlDecoderStatus
ConvertStatus
(
JxlDecoderStatus
status
)
{
return
status
;
}
JxlDecoderStatus
ConvertStatus
(
jxl
:
:
Status
status
)
{
return
status
?
JXL_DEC_SUCCESS
:
JXL_DEC_ERROR
;
}
JxlSignature
ReadSignature
(
const
uint8_t
*
buf
size_t
len
size_t
*
pos
)
{
if
(
*
pos
>
=
len
)
return
JXL_SIG_NOT_ENOUGH_BYTES
;
buf
+
=
*
pos
;
len
-
=
*
pos
;
if
(
len
>
=
1
&
&
buf
[
0
]
=
=
0xff
)
{
if
(
len
<
2
)
{
return
JXL_SIG_NOT_ENOUGH_BYTES
;
}
else
if
(
buf
[
1
]
=
=
jxl
:
:
kCodestreamMarker
)
{
*
pos
+
=
2
;
return
JXL_SIG_CODESTREAM
;
}
else
{
return
JXL_SIG_INVALID
;
}
}
if
(
len
>
=
1
&
&
buf
[
0
]
=
=
0
)
{
if
(
len
<
12
)
{
return
JXL_SIG_NOT_ENOUGH_BYTES
;
}
else
if
(
buf
[
1
]
=
=
0
&
&
buf
[
2
]
=
=
0
&
&
buf
[
3
]
=
=
0xC
&
&
buf
[
4
]
=
=
'
J
'
&
&
buf
[
5
]
=
=
'
X
'
&
&
buf
[
6
]
=
=
'
L
'
&
&
buf
[
7
]
=
=
'
'
&
&
buf
[
8
]
=
=
0xD
&
&
buf
[
9
]
=
=
0xA
&
&
buf
[
10
]
=
=
0x87
&
&
buf
[
11
]
=
=
0xA
)
{
*
pos
+
=
12
;
return
JXL_SIG_CONTAINER
;
}
else
{
return
JXL_SIG_INVALID
;
}
}
return
JXL_SIG_INVALID
;
}
}
uint32_t
JxlDecoderVersion
(
void
)
{
return
JPEGXL_MAJOR_VERSION
*
1000000
+
JPEGXL_MINOR_VERSION
*
1000
+
JPEGXL_PATCH_VERSION
;
}
JxlSignature
JxlSignatureCheck
(
const
uint8_t
*
buf
size_t
len
)
{
size_t
pos
=
0
;
return
ReadSignature
(
buf
len
&
pos
)
;
}
namespace
{
size_t
BitsPerChannel
(
JxlDataType
data_type
)
{
switch
(
data_type
)
{
case
JXL_TYPE_BOOLEAN
:
return
1
;
case
JXL_TYPE_UINT8
:
return
8
;
case
JXL_TYPE_UINT16
:
return
16
;
case
JXL_TYPE_UINT32
:
return
32
;
case
JXL_TYPE_FLOAT
:
return
32
;
case
JXL_TYPE_FLOAT16
:
return
16
;
}
return
0
;
}
enum
class
DecoderStage
:
uint32_t
{
kInited
kStarted
kFinished
kError
}
;
enum
class
FrameStage
:
uint32_t
{
kHeader
kTOC
kFull
kFullOutput
}
;
struct
Sections
{
Sections
(
jxl
:
:
FrameDecoder
*
frame_dec
size_t
frame_size
size_t
sections_begin
)
:
frame_dec_
(
frame_dec
)
frame_size_
(
frame_size
)
sections_begin_
(
sections_begin
)
{
}
Sections
(
const
Sections
&
)
=
delete
;
Sections
&
operator
=
(
const
Sections
&
)
=
delete
;
Sections
(
Sections
&
&
)
=
delete
;
Sections
&
operator
=
(
Sections
&
&
)
=
delete
;
~
Sections
(
)
{
CloseInput
(
)
;
}
JxlDecoderStatus
Init
(
)
{
section_received
.
resize
(
frame_dec_
-
>
NumSections
(
)
0
)
;
const
auto
&
offsets
=
frame_dec_
-
>
SectionOffsets
(
)
;
const
auto
&
sizes
=
frame_dec_
-
>
SectionSizes
(
)
;
for
(
size_t
i
=
0
;
i
<
frame_dec_
-
>
NumSections
(
)
;
i
+
+
)
{
if
(
OutOfBounds
(
sections_begin_
offsets
[
i
]
sizes
[
i
]
frame_size_
)
)
{
return
JXL_API_ERROR
(
"
section
out
of
bounds
"
)
;
}
}
return
JXL_DEC_SUCCESS
;
}
void
SetInput
(
const
uint8_t
*
frame
size_t
size
)
{
const
auto
&
offsets
=
frame_dec_
-
>
SectionOffsets
(
)
;
const
auto
&
sizes
=
frame_dec_
-
>
SectionSizes
(
)
;
for
(
size_t
i
=
0
;
i
<
frame_dec_
-
>
NumSections
(
)
;
i
+
+
)
{
if
(
section_received
[
i
]
)
continue
;
if
(
!
OutOfBounds
(
sections_begin_
offsets
[
i
]
sizes
[
i
]
size
)
)
{
section_received
[
i
]
=
1
;
section_info
.
emplace_back
(
jxl
:
:
FrameDecoder
:
:
SectionInfo
{
nullptr
i
}
)
;
section_status
.
emplace_back
(
)
;
}
}
for
(
size_t
i
=
0
;
i
<
section_info
.
size
(
)
;
i
+
+
)
{
size_t
id
=
section_info
[
i
]
.
id
;
JXL_ASSERT
(
section_info
[
i
]
.
br
=
=
nullptr
)
;
section_info
[
i
]
.
br
=
new
jxl
:
:
BitReader
(
jxl
:
:
Span
<
const
uint8_t
>
(
frame
+
sections_begin_
+
offsets
[
id
]
sizes
[
id
]
)
)
;
}
}
JxlDecoderStatus
CloseInput
(
)
{
bool
out_of_bounds
=
false
;
for
(
size_t
i
=
0
;
i
<
section_info
.
size
(
)
;
i
+
+
)
{
if
(
!
section_info
[
i
]
.
br
)
continue
;
if
(
!
section_info
[
i
]
.
br
-
>
AllReadsWithinBounds
(
)
)
{
out_of_bounds
=
true
;
}
JXL_ASSERT
(
section_info
[
i
]
.
br
-
>
Close
(
)
)
;
delete
section_info
[
i
]
.
br
;
section_info
[
i
]
.
br
=
nullptr
;
}
if
(
out_of_bounds
)
{
return
JXL_API_ERROR
(
"
frame
out
of
bounds
"
)
;
}
return
JXL_DEC_SUCCESS
;
}
jxl
:
:
FrameDecoder
*
frame_dec_
;
size_t
frame_size_
;
size_t
sections_begin_
;
std
:
:
vector
<
jxl
:
:
FrameDecoder
:
:
SectionInfo
>
section_info
;
std
:
:
vector
<
jxl
:
:
FrameDecoder
:
:
SectionStatus
>
section_status
;
std
:
:
vector
<
char
>
section_received
;
}
;
std
:
:
vector
<
size_t
>
GetFrameDependencies
(
size_t
index
const
std
:
:
vector
<
int
>
&
saved_as
const
std
:
:
vector
<
int
>
&
references
)
{
JXL_ASSERT
(
references
.
size
(
)
=
=
saved_as
.
size
(
)
)
;
JXL_ASSERT
(
index
<
references
.
size
(
)
)
;
std
:
:
vector
<
size_t
>
result
;
constexpr
size_t
kNumStorage
=
8
;
const
size_t
invalid
=
references
.
size
(
)
;
std
:
:
array
<
std
:
:
vector
<
size_t
>
kNumStorage
>
storage
;
for
(
size_t
s
=
0
;
s
<
kNumStorage
;
+
+
s
)
{
storage
[
s
]
.
resize
(
saved_as
.
size
(
)
)
;
int
mask
=
1
<
<
s
;
size_t
id
=
invalid
;
for
(
size_t
i
=
0
;
i
<
saved_as
.
size
(
)
;
+
+
i
)
{
if
(
saved_as
[
i
]
&
mask
)
{
id
=
i
;
}
storage
[
s
]
[
i
]
=
id
;
}
}
std
:
:
vector
<
char
>
seen
(
index
+
1
0
)
;
std
:
:
vector
<
size_t
>
stack
;
stack
.
push_back
(
index
)
;
seen
[
index
]
=
1
;
for
(
size_t
s
=
0
;
s
<
kNumStorage
;
+
+
s
)
{
size_t
frame_ref
=
storage
[
s
]
[
index
]
;
if
(
frame_ref
=
=
invalid
)
continue
;
if
(
seen
[
frame_ref
]
)
continue
;
stack
.
push_back
(
frame_ref
)
;
seen
[
frame_ref
]
=
1
;
result
.
push_back
(
frame_ref
)
;
}
while
(
!
stack
.
empty
(
)
)
{
size_t
frame_index
=
stack
.
back
(
)
;
stack
.
pop_back
(
)
;
if
(
frame_index
=
=
0
)
continue
;
for
(
size_t
s
=
0
;
s
<
kNumStorage
;
+
+
s
)
{
int
mask
=
1
<
<
s
;
if
(
!
(
references
[
frame_index
]
&
mask
)
)
continue
;
size_t
frame_ref
=
storage
[
s
]
[
frame_index
-
1
]
;
if
(
frame_ref
=
=
invalid
)
continue
;
if
(
seen
[
frame_ref
]
)
continue
;
stack
.
push_back
(
frame_ref
)
;
seen
[
frame_ref
]
=
1
;
result
.
push_back
(
frame_ref
)
;
}
}
return
result
;
}
struct
ExtraChannelOutput
{
JxlPixelFormat
format
;
void
*
buffer
;
size_t
buffer_size
;
}
;
}
struct
JxlDecoderStruct
{
JxlDecoderStruct
(
)
=
default
;
JxlMemoryManager
memory_manager
;
std
:
:
unique_ptr
<
jxl
:
:
ThreadPool
>
thread_pool
;
DecoderStage
stage
;
bool
got_signature
;
bool
first_codestream_seen
;
bool
last_codestream_seen
;
bool
got_basic_info
;
size_t
header_except_icc_bits
=
0
;
bool
got_all_headers
;
bool
post_headers
;
jxl
:
:
ICCReader
icc_reader
;
bool
got_preview_image
;
size_t
file_pos
;
size_t
box_begin
;
size_t
box_end
;
bool
skip_box
;
size_t
codestream_begin
;
size_t
codestream_end
;
bool
keep_orientation
;
int
events_wanted
;
int
orig_events_wanted
;
size_t
basic_info_size_hint
;
bool
have_container
;
bool
preview_out_buffer_set
;
bool
image_out_buffer_set
;
void
*
preview_out_buffer
;
void
*
image_out_buffer
;
JxlImageOutCallback
image_out_callback
;
void
*
image_out_opaque
;
size_t
preview_out_size
;
size_t
image_out_size
;
JxlPixelFormat
preview_out_format
;
JxlPixelFormat
image_out_format
;
std
:
:
vector
<
ExtraChannelOutput
>
extra_channel_output
;
jxl
:
:
CodecMetadata
metadata
;
std
:
:
unique_ptr
<
jxl
:
:
ImageBundle
>
ib
;
jxl
:
:
ColorEncoding
default_enc
;
std
:
:
unique_ptr
<
jxl
:
:
PassesDecoderState
>
passes_state
;
std
:
:
unique_ptr
<
jxl
:
:
FrameDecoder
>
frame_dec
;
std
:
:
unique_ptr
<
Sections
>
sections
;
bool
frame_dec_in_progress
;
std
:
:
unique_ptr
<
jxl
:
:
FrameHeader
>
frame_header
;
size_t
frame_start
;
size_t
frame_size
;
FrameStage
frame_stage
;
bool
is_last_of_still
;
bool
is_last_total
;
size_t
skip_frames
;
bool
skipping_frame
;
size_t
internal_frames
;
size_t
external_frames
;
std
:
:
vector
<
int
>
frame_references
;
std
:
:
vector
<
int
>
frame_saved_as
;
std
:
:
vector
<
size_t
>
frame_external_to_internal
;
std
:
:
vector
<
char
>
frame_required
;
std
:
:
vector
<
uint8_t
>
codestream
;
jxl
:
:
JxlToJpegDecoder
jpeg_decoder
;
size_t
codestream_pos
;
uint64_t
dec_pixels
;
const
uint8_t
*
next_in
;
size_t
avail_in
;
}
;
JxlDecoderStatus
JxlDecoderDefaultPixelFormat
(
const
JxlDecoder
*
dec
JxlPixelFormat
*
format
)
{
if
(
!
dec
-
>
got_basic_info
)
return
JXL_DEC_NEED_MORE_INPUT
;
*
format
=
{
4
JXL_TYPE_FLOAT
JXL_LITTLE_ENDIAN
0
}
;
return
JXL_DEC_SUCCESS
;
}
void
JxlDecoderRewindDecodingState
(
JxlDecoder
*
dec
)
{
dec
-
>
stage
=
DecoderStage
:
:
kInited
;
dec
-
>
got_signature
=
false
;
dec
-
>
first_codestream_seen
=
false
;
dec
-
>
last_codestream_seen
=
false
;
dec
-
>
got_basic_info
=
false
;
dec
-
>
header_except_icc_bits
=
0
;
dec
-
>
got_all_headers
=
false
;
dec
-
>
post_headers
=
false
;
dec
-
>
icc_reader
.
Reset
(
)
;
dec
-
>
got_preview_image
=
false
;
dec
-
>
file_pos
=
0
;
dec
-
>
box_begin
=
0
;
dec
-
>
box_end
=
0
;
dec
-
>
skip_box
=
false
;
dec
-
>
codestream_pos
=
0
;
dec
-
>
codestream_begin
=
0
;
dec
-
>
codestream_end
=
0
;
dec
-
>
events_wanted
=
0
;
dec
-
>
basic_info_size_hint
=
InitialBasicInfoSizeHint
(
)
;
dec
-
>
have_container
=
0
;
dec
-
>
preview_out_buffer_set
=
false
;
dec
-
>
image_out_buffer_set
=
false
;
dec
-
>
preview_out_buffer
=
nullptr
;
dec
-
>
image_out_buffer
=
nullptr
;
dec
-
>
image_out_callback
=
nullptr
;
dec
-
>
image_out_opaque
=
nullptr
;
dec
-
>
preview_out_size
=
0
;
dec
-
>
image_out_size
=
0
;
dec
-
>
extra_channel_output
.
clear
(
)
;
dec
-
>
dec_pixels
=
0
;
dec
-
>
next_in
=
0
;
dec
-
>
avail_in
=
0
;
dec
-
>
passes_state
.
reset
(
nullptr
)
;
dec
-
>
frame_dec
.
reset
(
nullptr
)
;
dec
-
>
sections
.
reset
(
nullptr
)
;
dec
-
>
frame_dec_in_progress
=
false
;
dec
-
>
ib
.
reset
(
)
;
dec
-
>
metadata
=
jxl
:
:
CodecMetadata
(
)
;
dec
-
>
frame_header
.
reset
(
new
jxl
:
:
FrameHeader
(
&
dec
-
>
metadata
)
)
;
dec
-
>
codestream
.
clear
(
)
;
dec
-
>
frame_stage
=
FrameStage
:
:
kHeader
;
dec
-
>
frame_start
=
0
;
dec
-
>
frame_size
=
0
;
dec
-
>
is_last_of_still
=
false
;
dec
-
>
is_last_total
=
false
;
dec
-
>
skip_frames
=
0
;
dec
-
>
skipping_frame
=
false
;
dec
-
>
internal_frames
=
0
;
dec
-
>
external_frames
=
0
;
}
void
JxlDecoderReset
(
JxlDecoder
*
dec
)
{
JxlDecoderRewindDecodingState
(
dec
)
;
dec
-
>
thread_pool
.
reset
(
)
;
dec
-
>
keep_orientation
=
false
;
dec
-
>
orig_events_wanted
=
0
;
dec
-
>
frame_references
.
clear
(
)
;
dec
-
>
frame_saved_as
.
clear
(
)
;
dec
-
>
frame_external_to_internal
.
clear
(
)
;
dec
-
>
frame_required
.
clear
(
)
;
}
JxlDecoder
*
JxlDecoderCreate
(
const
JxlMemoryManager
*
memory_manager
)
{
JxlMemoryManager
local_memory_manager
;
if
(
!
jxl
:
:
MemoryManagerInit
(
&
local_memory_manager
memory_manager
)
)
return
nullptr
;
void
*
alloc
=
jxl
:
:
MemoryManagerAlloc
(
&
local_memory_manager
sizeof
(
JxlDecoder
)
)
;
if
(
!
alloc
)
return
nullptr
;
JxlDecoder
*
dec
=
new
(
alloc
)
JxlDecoder
(
)
;
dec
-
>
memory_manager
=
local_memory_manager
;
JxlDecoderReset
(
dec
)
;
return
dec
;
}
void
JxlDecoderDestroy
(
JxlDecoder
*
dec
)
{
if
(
dec
)
{
dec
-
>
~
JxlDecoder
(
)
;
jxl
:
:
MemoryManagerFree
(
&
dec
-
>
memory_manager
dec
)
;
}
}
void
JxlDecoderRewind
(
JxlDecoder
*
dec
)
{
JxlDecoderRewindDecodingState
(
dec
)
;
}
void
JxlDecoderSkipFrames
(
JxlDecoder
*
dec
size_t
amount
)
{
dec
-
>
skip_frames
+
=
amount
;
dec
-
>
frame_required
.
clear
(
)
;
size_t
next_frame
=
dec
-
>
external_frames
+
dec
-
>
skip_frames
;
if
(
next_frame
<
dec
-
>
frame_external_to_internal
.
size
(
)
)
{
size_t
internal_index
=
dec
-
>
frame_external_to_internal
[
next_frame
]
;
if
(
internal_index
<
dec
-
>
frame_saved_as
.
size
(
)
)
{
std
:
:
vector
<
size_t
>
deps
=
GetFrameDependencies
(
internal_index
dec
-
>
frame_saved_as
dec
-
>
frame_references
)
;
dec
-
>
frame_required
.
resize
(
internal_index
+
1
0
)
;
for
(
size_t
i
=
0
;
i
<
deps
.
size
(
)
;
i
+
+
)
{
JXL_ASSERT
(
deps
[
i
]
<
dec
-
>
frame_required
.
size
(
)
)
;
dec
-
>
frame_required
[
deps
[
i
]
]
=
1
;
}
}
}
}
JXL_EXPORT
JxlDecoderStatus
JxlDecoderSetParallelRunner
(
JxlDecoder
*
dec
JxlParallelRunner
parallel_runner
void
*
parallel_runner_opaque
)
{
if
(
dec
-
>
stage
!
=
DecoderStage
:
:
kInited
)
{
return
JXL_API_ERROR
(
"
parallel_runner
must
be
set
before
starting
"
)
;
}
dec
-
>
thread_pool
.
reset
(
new
jxl
:
:
ThreadPool
(
parallel_runner
parallel_runner_opaque
)
)
;
return
JXL_DEC_SUCCESS
;
}
size_t
JxlDecoderSizeHintBasicInfo
(
const
JxlDecoder
*
dec
)
{
if
(
dec
-
>
got_basic_info
)
return
0
;
return
dec
-
>
basic_info_size_hint
;
}
JxlDecoderStatus
JxlDecoderSubscribeEvents
(
JxlDecoder
*
dec
int
events_wanted
)
{
if
(
dec
-
>
stage
!
=
DecoderStage
:
:
kInited
)
{
return
JXL_DEC_ERROR
;
}
if
(
events_wanted
&
63
)
{
return
JXL_DEC_ERROR
;
}
dec
-
>
events_wanted
=
events_wanted
;
dec
-
>
orig_events_wanted
=
events_wanted
;
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderSetKeepOrientation
(
JxlDecoder
*
dec
JXL_BOOL
keep_orientation
)
{
if
(
dec
-
>
stage
!
=
DecoderStage
:
:
kInited
)
{
return
JXL_API_ERROR
(
"
Must
set
keep_orientation
option
before
starting
"
)
;
}
dec
-
>
keep_orientation
=
!
!
keep_orientation
;
return
JXL_DEC_SUCCESS
;
}
namespace
jxl
{
namespace
{
template
<
class
T
>
bool
CanRead
(
Span
<
const
uint8_t
>
data
BitReader
*
reader
T
*
JXL_RESTRICT
t
)
{
BitReader
reader2
(
data
)
;
reader2
.
SkipBits
(
reader
-
>
TotalBitsConsumed
(
)
)
;
bool
result
=
Bundle
:
:
CanRead
(
&
reader2
t
)
;
JXL_ASSERT
(
reader2
.
Close
(
)
)
;
return
result
;
}
template
<
class
T
>
JxlDecoderStatus
ReadBundle
(
Span
<
const
uint8_t
>
data
BitReader
*
reader
T
*
JXL_RESTRICT
t
)
{
if
(
!
CanRead
(
data
reader
t
)
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
if
(
!
Bundle
:
:
Read
(
reader
t
)
)
{
return
JXL_DEC_ERROR
;
}
return
JXL_DEC_SUCCESS
;
}
#
define
JXL_API_RETURN_IF_ERROR
(
expr
)
\
{
\
JxlDecoderStatus
status_
=
ConvertStatus
(
expr
)
;
\
if
(
status_
!
=
JXL_DEC_SUCCESS
)
return
status_
;
\
}
std
:
:
unique_ptr
<
BitReader
std
:
:
function
<
void
(
BitReader
*
)
>
>
GetBitReader
(
Span
<
const
uint8_t
>
span
)
{
BitReader
*
reader
=
new
BitReader
(
span
)
;
return
std
:
:
unique_ptr
<
BitReader
std
:
:
function
<
void
(
BitReader
*
)
>
>
(
reader
[
]
(
BitReader
*
reader
)
{
(
void
)
reader
-
>
AllReadsWithinBounds
(
)
;
(
void
)
reader
-
>
Close
(
)
;
delete
reader
;
}
)
;
}
JxlDecoderStatus
JxlDecoderReadBasicInfo
(
JxlDecoder
*
dec
const
uint8_t
*
in
size_t
size
)
{
size_t
pos
=
0
;
JxlSignature
signature
=
ReadSignature
(
in
size
&
pos
)
;
if
(
signature
=
=
JXL_SIG_NOT_ENOUGH_BYTES
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
if
(
signature
=
=
JXL_SIG_CONTAINER
)
{
return
JXL_API_ERROR
(
"
invalid
:
nested
container
"
)
;
}
if
(
signature
!
=
JXL_SIG_CODESTREAM
)
{
return
JXL_API_ERROR
(
"
invalid
signature
"
)
;
}
Span
<
const
uint8_t
>
span
(
in
+
pos
size
-
pos
)
;
auto
reader
=
GetBitReader
(
span
)
;
JXL_API_RETURN_IF_ERROR
(
ReadBundle
(
span
reader
.
get
(
)
&
dec
-
>
metadata
.
size
)
)
;
dec
-
>
metadata
.
m
.
nonserialized_only_parse_basic_info
=
true
;
JXL_API_RETURN_IF_ERROR
(
ReadBundle
(
span
reader
.
get
(
)
&
dec
-
>
metadata
.
m
)
)
;
dec
-
>
metadata
.
m
.
nonserialized_only_parse_basic_info
=
false
;
dec
-
>
got_basic_info
=
true
;
dec
-
>
basic_info_size_hint
=
0
;
if
(
!
CheckSizeLimit
(
dec
-
>
metadata
.
size
.
xsize
(
)
dec
-
>
metadata
.
size
.
ysize
(
)
)
)
{
return
JXL_API_ERROR
(
"
image
is
too
large
"
)
;
}
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderReadAllHeaders
(
JxlDecoder
*
dec
const
uint8_t
*
in
size_t
size
)
{
size_t
pos
=
0
;
JxlSignature
signature
=
ReadSignature
(
in
size
&
pos
)
;
if
(
signature
=
=
JXL_SIG_CONTAINER
)
{
return
JXL_API_ERROR
(
"
invalid
:
nested
container
"
)
;
}
if
(
signature
!
=
JXL_SIG_CODESTREAM
)
{
return
JXL_API_ERROR
(
"
invalid
signature
"
)
;
}
Span
<
const
uint8_t
>
span
(
in
+
pos
size
-
pos
)
;
auto
reader
=
GetBitReader
(
span
)
;
if
(
dec
-
>
header_except_icc_bits
!
=
0
)
{
reader
-
>
SkipBits
(
dec
-
>
header_except_icc_bits
)
;
}
else
{
SizeHeader
dummy_size_header
;
JXL_API_RETURN_IF_ERROR
(
ReadBundle
(
span
reader
.
get
(
)
&
dummy_size_header
)
)
;
ImageMetadata
dummy_metadata
;
JXL_API_RETURN_IF_ERROR
(
ReadBundle
(
span
reader
.
get
(
)
&
dummy_metadata
)
)
;
dec
-
>
metadata
.
transform_data
.
nonserialized_xyb_encoded
=
dec
-
>
metadata
.
m
.
xyb_encoded
;
JXL_API_RETURN_IF_ERROR
(
ReadBundle
(
span
reader
.
get
(
)
&
dec
-
>
metadata
.
transform_data
)
)
;
}
dec
-
>
header_except_icc_bits
=
reader
-
>
TotalBitsConsumed
(
)
;
if
(
dec
-
>
metadata
.
m
.
color_encoding
.
WantICC
(
)
)
{
jxl
:
:
Status
status
=
dec
-
>
icc_reader
.
Init
(
reader
.
get
(
)
memory_limit_base_
)
;
if
(
!
reader
-
>
AllReadsWithinBounds
(
)
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
if
(
!
status
)
{
if
(
status
.
code
(
)
=
=
StatusCode
:
:
kNotEnoughBytes
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
return
JXL_DEC_ERROR
;
}
PaddedBytes
icc
;
status
=
dec
-
>
icc_reader
.
Process
(
reader
.
get
(
)
&
icc
)
;
if
(
!
status
)
{
if
(
status
.
code
(
)
=
=
StatusCode
:
:
kNotEnoughBytes
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
return
JXL_DEC_ERROR
;
}
if
(
!
dec
-
>
metadata
.
m
.
color_encoding
.
SetICCRaw
(
std
:
:
move
(
icc
)
)
)
{
return
JXL_DEC_ERROR
;
}
}
dec
-
>
got_all_headers
=
true
;
JXL_API_RETURN_IF_ERROR
(
reader
-
>
JumpToByteBoundary
(
)
)
;
dec
-
>
frame_start
=
pos
+
reader
-
>
TotalBitsConsumed
(
)
/
jxl
:
:
kBitsPerByte
;
if
(
!
dec
-
>
passes_state
)
{
dec
-
>
passes_state
.
reset
(
new
jxl
:
:
PassesDecoderState
(
)
)
;
}
dec
-
>
default_enc
=
ColorEncoding
:
:
LinearSRGB
(
dec
-
>
metadata
.
m
.
color_encoding
.
IsGray
(
)
)
;
JXL_API_RETURN_IF_ERROR
(
dec
-
>
passes_state
-
>
output_encoding_info
.
Set
(
dec
-
>
metadata
dec
-
>
default_enc
)
)
;
return
JXL_DEC_SUCCESS
;
}
static
size_t
GetStride
(
const
JxlDecoder
*
dec
const
JxlPixelFormat
&
format
const
jxl
:
:
ImageBundle
*
frame
=
nullptr
)
{
size_t
xsize
=
dec
-
>
metadata
.
xsize
(
)
;
if
(
!
dec
-
>
keep_orientation
&
&
dec
-
>
metadata
.
m
.
orientation
>
4
)
{
xsize
=
dec
-
>
metadata
.
ysize
(
)
;
}
if
(
frame
)
{
xsize
=
dec
-
>
keep_orientation
?
frame
-
>
xsize
(
)
:
frame
-
>
oriented_xsize
(
)
;
}
size_t
stride
=
xsize
*
(
BitsPerChannel
(
format
.
data_type
)
*
format
.
num_channels
/
jxl
:
:
kBitsPerByte
)
;
if
(
format
.
align
>
1
)
{
stride
=
jxl
:
:
DivCeil
(
stride
format
.
align
)
*
format
.
align
;
}
return
stride
;
}
static
JxlDecoderStatus
ConvertImageInternal
(
const
JxlDecoder
*
dec
const
jxl
:
:
ImageBundle
&
frame
const
JxlPixelFormat
&
format
bool
want_extra_channel
size_t
extra_channel_index
void
*
out_image
size_t
out_size
JxlImageOutCallback
out_callback
void
*
out_opaque
)
{
const
size_t
stride
=
GetStride
(
dec
format
&
frame
)
;
bool
float_format
=
format
.
data_type
=
=
JXL_TYPE_FLOAT
|
|
format
.
data_type
=
=
JXL_TYPE_FLOAT16
;
jxl
:
:
Orientation
undo_orientation
=
dec
-
>
keep_orientation
?
jxl
:
:
Orientation
:
:
kIdentity
:
dec
-
>
metadata
.
m
.
GetOrientation
(
)
;
jxl
:
:
Status
status
(
true
)
;
if
(
want_extra_channel
)
{
status
=
jxl
:
:
ConvertToExternal
(
frame
.
extra_channels
(
)
[
extra_channel_index
]
BitsPerChannel
(
format
.
data_type
)
float_format
format
.
endianness
stride
dec
-
>
thread_pool
.
get
(
)
out_image
out_size
out_callback
out_opaque
undo_orientation
)
;
}
else
{
status
=
jxl
:
:
ConvertToExternal
(
frame
BitsPerChannel
(
format
.
data_type
)
float_format
format
.
num_channels
format
.
endianness
stride
dec
-
>
thread_pool
.
get
(
)
out_image
out_size
out_callback
out_opaque
undo_orientation
)
;
}
return
status
?
JXL_DEC_SUCCESS
:
JXL_DEC_ERROR
;
}
JxlDecoderStatus
ParseFrameHeader
(
jxl
:
:
FrameHeader
*
frame_header
const
uint8_t
*
in
size_t
size
size_t
pos
bool
is_preview
size_t
*
frame_size
int
*
saved_as
)
{
if
(
pos
>
=
size
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
Span
<
const
uint8_t
>
span
(
in
+
pos
size
-
pos
)
;
auto
reader
=
GetBitReader
(
span
)
;
frame_header
-
>
nonserialized_is_preview
=
is_preview
;
jxl
:
:
Status
status
=
DecodeFrameHeader
(
reader
.
get
(
)
frame_header
)
;
jxl
:
:
FrameDimensions
frame_dim
=
frame_header
-
>
ToFrameDimensions
(
)
;
if
(
!
CheckSizeLimit
(
frame_dim
.
xsize_upsampled_padded
frame_dim
.
ysize_upsampled_padded
)
)
{
return
JXL_API_ERROR
(
"
frame
is
too
large
"
)
;
}
if
(
status
.
code
(
)
=
=
StatusCode
:
:
kNotEnoughBytes
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
else
if
(
!
status
)
{
return
JXL_API_ERROR
(
"
invalid
frame
header
"
)
;
}
uint64_t
groups_total_size
;
const
bool
has_ac_global
=
true
;
const
size_t
toc_entries
=
NumTocEntries
(
frame_dim
.
num_groups
frame_dim
.
num_dc_groups
frame_header
-
>
passes
.
num_passes
has_ac_global
)
;
std
:
:
vector
<
uint64_t
>
group_offsets
;
std
:
:
vector
<
uint32_t
>
group_sizes
;
status
=
ReadGroupOffsets
(
toc_entries
reader
.
get
(
)
&
group_offsets
&
group_sizes
&
groups_total_size
)
;
if
(
!
reader
-
>
AllReadsWithinBounds
(
)
|
|
status
.
code
(
)
=
=
StatusCode
:
:
kNotEnoughBytes
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
else
if
(
!
status
)
{
return
JXL_API_ERROR
(
"
invalid
toc
entries
"
)
;
}
JXL_DASSERT
(
(
reader
-
>
TotalBitsConsumed
(
)
%
kBitsPerByte
)
=
=
0
)
;
JXL_API_RETURN_IF_ERROR
(
reader
-
>
JumpToByteBoundary
(
)
)
;
size_t
header_size
=
(
reader
-
>
TotalBitsConsumed
(
)
>
>
3
)
;
*
frame_size
=
header_size
+
groups_total_size
;
if
(
saved_as
!
=
nullptr
)
{
*
saved_as
=
FrameDecoder
:
:
SavedAs
(
*
frame_header
)
;
}
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderProcessInternal
(
JxlDecoder
*
dec
const
uint8_t
*
in
size_t
size
)
{
if
(
!
dec
-
>
thread_pool
)
{
dec
-
>
thread_pool
.
reset
(
new
jxl
:
:
ThreadPool
(
nullptr
nullptr
)
)
;
}
if
(
!
dec
-
>
got_basic_info
)
{
JxlDecoderStatus
status
=
JxlDecoderReadBasicInfo
(
dec
in
size
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
}
if
(
dec
-
>
events_wanted
&
JXL_DEC_BASIC_INFO
)
{
dec
-
>
events_wanted
&
=
~
JXL_DEC_BASIC_INFO
;
return
JXL_DEC_BASIC_INFO
;
}
if
(
!
dec
-
>
got_all_headers
)
{
JxlDecoderStatus
status
=
JxlDecoderReadAllHeaders
(
dec
in
size
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
}
if
(
dec
-
>
events_wanted
&
JXL_DEC_EXTENSIONS
)
{
dec
-
>
events_wanted
&
=
~
JXL_DEC_EXTENSIONS
;
if
(
dec
-
>
metadata
.
m
.
extensions
!
=
0
)
{
return
JXL_DEC_EXTENSIONS
;
}
}
if
(
dec
-
>
events_wanted
&
JXL_DEC_COLOR_ENCODING
)
{
dec
-
>
events_wanted
&
=
~
JXL_DEC_COLOR_ENCODING
;
return
JXL_DEC_COLOR_ENCODING
;
}
dec
-
>
post_headers
=
true
;
if
(
!
dec
-
>
got_preview_image
)
{
bool
parse_preview
=
(
dec
-
>
events_wanted
&
(
JXL_DEC_PREVIEW_IMAGE
|
JXL_DEC_FRAME
|
JXL_DEC_FULL_IMAGE
)
)
;
if
(
!
dec
-
>
metadata
.
m
.
have_preview
)
{
dec
-
>
got_preview_image
=
true
;
}
else
if
(
!
parse_preview
)
{
dec
-
>
got_preview_image
=
true
;
}
else
{
bool
want_preview
=
(
dec
-
>
events_wanted
&
JXL_DEC_PREVIEW_IMAGE
)
;
size_t
frame_size
;
size_t
pos
=
dec
-
>
frame_start
;
dec
-
>
frame_header
.
reset
(
new
FrameHeader
(
&
dec
-
>
metadata
)
)
;
JxlDecoderStatus
status
=
ParseFrameHeader
(
dec
-
>
frame_header
.
get
(
)
in
size
pos
true
&
frame_size
nullptr
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
if
(
OutOfBounds
(
pos
frame_size
size
)
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
if
(
want_preview
&
&
!
dec
-
>
preview_out_buffer_set
)
{
return
JXL_DEC_NEED_PREVIEW_OUT_BUFFER
;
}
jxl
:
:
Span
<
const
uint8_t
>
compressed
(
in
+
dec
-
>
frame_start
size
-
dec
-
>
frame_start
)
;
auto
reader
=
GetBitReader
(
compressed
)
;
jxl
:
:
DecompressParams
dparams
;
dparams
.
preview
=
want_preview
?
jxl
:
:
Override
:
:
kOn
:
jxl
:
:
Override
:
:
kOff
;
jxl
:
:
ImageBundle
ib
(
&
dec
-
>
metadata
.
m
)
;
PassesDecoderState
preview_dec_state
;
JXL_API_RETURN_IF_ERROR
(
preview_dec_state
.
output_encoding_info
.
Set
(
dec
-
>
metadata
ColorEncoding
:
:
LinearSRGB
(
dec
-
>
metadata
.
m
.
color_encoding
.
IsGray
(
)
)
)
)
;
if
(
!
DecodeFrame
(
dparams
&
preview_dec_state
dec
-
>
thread_pool
.
get
(
)
reader
.
get
(
)
&
ib
dec
-
>
metadata
nullptr
true
)
)
{
return
JXL_API_ERROR
(
"
decoding
preview
failed
"
)
;
}
dec
-
>
frame_start
+
=
DivCeil
(
reader
-
>
TotalBitsConsumed
(
)
kBitsPerByte
)
;
dec
-
>
got_preview_image
=
true
;
if
(
want_preview
)
{
if
(
dec
-
>
preview_out_buffer
)
{
JxlDecoderStatus
status
=
ConvertImageInternal
(
dec
ib
dec
-
>
preview_out_format
false
0
dec
-
>
preview_out_buffer
dec
-
>
preview_out_size
nullptr
nullptr
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
}
return
JXL_DEC_PREVIEW_IMAGE
;
}
}
}
for
(
;
;
)
{
if
(
!
(
dec
-
>
events_wanted
&
(
JXL_DEC_FULL_IMAGE
|
JXL_DEC_FRAME
)
)
)
{
break
;
}
if
(
dec
-
>
frame_stage
=
=
FrameStage
:
:
kHeader
&
&
dec
-
>
is_last_total
)
{
break
;
}
if
(
dec
-
>
frame_stage
=
=
FrameStage
:
:
kHeader
)
{
size_t
pos
=
dec
-
>
frame_start
-
dec
-
>
codestream_pos
;
if
(
pos
>
=
size
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
dec
-
>
frame_header
.
reset
(
new
FrameHeader
(
&
dec
-
>
metadata
)
)
;
int
saved_as
=
0
;
JxlDecoderStatus
status
=
ParseFrameHeader
(
dec
-
>
frame_header
.
get
(
)
in
size
pos
false
&
dec
-
>
frame_size
&
saved_as
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
dec
-
>
is_last_total
=
dec
-
>
frame_header
-
>
is_last
;
dec
-
>
is_last_of_still
=
dec
-
>
is_last_total
|
|
dec
-
>
frame_header
-
>
animation_frame
.
duration
>
0
;
const
size_t
internal_frame_index
=
dec
-
>
internal_frames
;
const
size_t
external_frame_index
=
dec
-
>
external_frames
;
if
(
dec
-
>
is_last_of_still
)
dec
-
>
external_frames
+
+
;
dec
-
>
internal_frames
+
+
;
dec
-
>
frame_stage
=
FrameStage
:
:
kTOC
;
if
(
dec
-
>
skip_frames
>
0
)
{
dec
-
>
skipping_frame
=
true
;
if
(
dec
-
>
is_last_of_still
)
{
dec
-
>
skip_frames
-
-
;
}
}
else
{
dec
-
>
skipping_frame
=
false
;
}
if
(
external_frame_index
>
=
dec
-
>
frame_external_to_internal
.
size
(
)
)
{
dec
-
>
frame_external_to_internal
.
push_back
(
internal_frame_index
)
;
JXL_ASSERT
(
dec
-
>
frame_external_to_internal
.
size
(
)
=
=
external_frame_index
+
1
)
;
}
if
(
internal_frame_index
>
=
dec
-
>
frame_saved_as
.
size
(
)
)
{
dec
-
>
frame_saved_as
.
push_back
(
saved_as
)
;
JXL_ASSERT
(
dec
-
>
frame_saved_as
.
size
(
)
=
=
internal_frame_index
+
1
)
;
dec
-
>
frame_references
.
push_back
(
0xff
)
;
JXL_ASSERT
(
dec
-
>
frame_references
.
size
(
)
=
=
internal_frame_index
+
1
)
;
}
if
(
dec
-
>
skipping_frame
)
{
bool
referenceable
=
dec
-
>
frame_header
-
>
CanBeReferenced
(
)
|
|
dec
-
>
frame_header
-
>
frame_type
=
=
FrameType
:
:
kDCFrame
;
if
(
internal_frame_index
<
dec
-
>
frame_required
.
size
(
)
&
&
!
dec
-
>
frame_required
[
internal_frame_index
]
)
{
referenceable
=
false
;
}
if
(
!
referenceable
)
{
dec
-
>
frame_stage
=
FrameStage
:
:
kHeader
;
dec
-
>
frame_start
+
=
dec
-
>
frame_size
;
continue
;
}
}
if
(
(
dec
-
>
events_wanted
&
JXL_DEC_FRAME
)
&
&
dec
-
>
is_last_of_still
)
{
if
(
!
dec
-
>
skipping_frame
)
{
return
JXL_DEC_FRAME
;
}
}
}
if
(
dec
-
>
frame_stage
=
=
FrameStage
:
:
kTOC
)
{
size_t
pos
=
dec
-
>
frame_start
-
dec
-
>
codestream_pos
;
if
(
pos
>
=
size
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
Span
<
const
uint8_t
>
span
(
in
+
pos
size
-
pos
)
;
auto
reader
=
GetBitReader
(
span
)
;
if
(
!
dec
-
>
passes_state
)
{
dec
-
>
passes_state
.
reset
(
new
jxl
:
:
PassesDecoderState
(
)
)
;
}
if
(
!
dec
-
>
ib
)
{
dec
-
>
ib
.
reset
(
new
jxl
:
:
ImageBundle
(
&
dec
-
>
metadata
.
m
)
)
;
}
dec
-
>
frame_dec
.
reset
(
new
FrameDecoder
(
dec
-
>
passes_state
.
get
(
)
dec
-
>
metadata
dec
-
>
thread_pool
.
get
(
)
)
)
;
if
(
!
dec
-
>
jpeg_decoder
.
SetImageBundleJpegData
(
dec
-
>
ib
.
get
(
)
)
)
return
JXL_DEC_ERROR
;
jxl
:
:
Status
status
=
dec
-
>
frame_dec
-
>
InitFrame
(
reader
.
get
(
)
dec
-
>
ib
.
get
(
)
false
true
false
)
;
if
(
!
status
)
JXL_API_RETURN_IF_ERROR
(
status
)
;
size_t
sections_begin
=
DivCeil
(
reader
-
>
TotalBitsConsumed
(
)
kBitsPerByte
)
;
dec
-
>
sections
.
reset
(
new
Sections
(
dec
-
>
frame_dec
.
get
(
)
dec
-
>
frame_size
sections_begin
)
)
;
JXL_API_RETURN_IF_ERROR
(
dec
-
>
sections
-
>
Init
(
)
)
;
if
(
dec
-
>
events_wanted
&
JXL_DEC_FULL_IMAGE
)
{
dec
-
>
frame_dec_in_progress
=
true
;
dec
-
>
frame_stage
=
FrameStage
:
:
kFull
;
}
}
bool
return_full_image
=
false
;
if
(
dec
-
>
frame_stage
=
=
FrameStage
:
:
kFull
)
{
if
(
dec
-
>
events_wanted
&
JXL_DEC_FULL_IMAGE
)
{
if
(
!
dec
-
>
image_out_buffer_set
&
&
(
!
dec
-
>
jpeg_decoder
.
IsOutputSet
(
)
|
|
dec
-
>
ib
-
>
jpeg_data
=
=
nullptr
)
&
&
dec
-
>
is_last_of_still
)
{
if
(
!
dec
-
>
skipping_frame
)
{
return
JXL_DEC_NEED_IMAGE_OUT_BUFFER
;
}
}
}
if
(
dec
-
>
image_out_buffer_set
&
&
!
!
dec
-
>
image_out_buffer
&
&
dec
-
>
image_out_format
.
data_type
=
=
JXL_TYPE_UINT8
&
&
dec
-
>
image_out_format
.
num_channels
>
=
3
&
&
dec
-
>
extra_channel_output
.
empty
(
)
)
{
bool
is_rgba
=
dec
-
>
image_out_format
.
num_channels
=
=
4
;
dec
-
>
frame_dec
-
>
MaybeSetRGB8OutputBuffer
(
reinterpret_cast
<
uint8_t
*
>
(
dec
-
>
image_out_buffer
)
GetStride
(
dec
dec
-
>
image_out_format
)
is_rgba
!
dec
-
>
keep_orientation
)
;
}
const
bool
little_endian
=
dec
-
>
image_out_format
.
endianness
=
=
JXL_LITTLE_ENDIAN
|
|
(
dec
-
>
image_out_format
.
endianness
=
=
JXL_NATIVE_ENDIAN
&
&
IsLittleEndian
(
)
)
;
bool
swap_endianness
=
little_endian
!
=
IsLittleEndian
(
)
;
if
(
dec
-
>
image_out_buffer_set
&
&
!
!
dec
-
>
image_out_callback
&
&
dec
-
>
image_out_format
.
data_type
=
=
JXL_TYPE_FLOAT
&
&
dec
-
>
image_out_format
.
num_channels
>
=
3
&
&
!
swap_endianness
&
&
dec
-
>
frame_dec_in_progress
)
{
bool
is_rgba
=
dec
-
>
image_out_format
.
num_channels
=
=
4
;
dec
-
>
frame_dec
-
>
MaybeSetFloatCallback
(
[
dec
]
(
const
float
*
pixels
size_t
x
size_t
y
size_t
num_pixels
)
{
dec
-
>
image_out_callback
(
dec
-
>
image_out_opaque
x
y
num_pixels
pixels
)
;
}
is_rgba
!
dec
-
>
keep_orientation
)
;
}
size_t
pos
=
dec
-
>
frame_start
-
dec
-
>
codestream_pos
;
if
(
pos
>
=
size
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
dec
-
>
sections
-
>
SetInput
(
in
+
pos
size
-
pos
)
;
if
(
cpu_limit_base_
!
=
0
)
{
FrameDimensions
frame_dim
=
dec
-
>
frame_header
-
>
ToFrameDimensions
(
)
;
size_t
num_pixels
=
frame_dim
.
xsize
*
frame_dim
.
ysize
;
if
(
used_cpu_base_
+
num_pixels
<
used_cpu_base_
)
{
return
JXL_API_ERROR
(
"
used
too
much
CPU
"
)
;
}
used_cpu_base_
+
=
num_pixels
;
if
(
used_cpu_base_
>
cpu_limit_base_
)
{
return
JXL_API_ERROR
(
"
used
too
much
CPU
"
)
;
}
}
jxl
:
:
Status
status
=
dec
-
>
frame_dec
-
>
ProcessSections
(
dec
-
>
sections
-
>
section_info
.
data
(
)
dec
-
>
sections
-
>
section_info
.
size
(
)
dec
-
>
sections
-
>
section_status
.
data
(
)
)
;
JXL_API_RETURN_IF_ERROR
(
dec
-
>
sections
-
>
CloseInput
(
)
)
;
if
(
status
.
IsFatalError
(
)
)
{
return
JXL_API_ERROR
(
"
decoding
frame
failed
"
)
;
}
if
(
status
.
code
(
)
=
=
StatusCode
:
:
kNotEnoughBytes
|
|
dec
-
>
sections
-
>
section_info
.
size
(
)
<
dec
-
>
frame_dec
-
>
NumSections
(
)
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
size_t
internal_index
=
dec
-
>
internal_frames
-
1
;
JXL_ASSERT
(
dec
-
>
frame_references
.
size
(
)
>
internal_index
)
;
dec
-
>
frame_references
[
internal_index
]
=
dec
-
>
frame_dec
-
>
References
(
)
;
if
(
!
dec
-
>
frame_dec
-
>
FinalizeFrame
(
)
)
{
return
JXL_API_ERROR
(
"
decoding
frame
failed
"
)
;
}
dec
-
>
frame_dec_in_progress
=
false
;
dec
-
>
frame_stage
=
FrameStage
:
:
kFullOutput
;
}
if
(
dec
-
>
frame_stage
=
=
FrameStage
:
:
kFullOutput
)
{
if
(
dec
-
>
is_last_of_still
)
{
if
(
dec
-
>
events_wanted
&
JXL_DEC_FULL_IMAGE
)
{
dec
-
>
events_wanted
&
=
~
JXL_DEC_FULL_IMAGE
;
return_full_image
=
true
;
}
dec
-
>
events_wanted
|
=
(
dec
-
>
orig_events_wanted
&
(
JXL_DEC_FULL_IMAGE
|
JXL_DEC_FRAME
)
)
;
if
(
dec
-
>
jpeg_decoder
.
IsOutputSet
(
)
&
&
dec
-
>
ib
-
>
jpeg_data
!
=
nullptr
)
{
JxlDecoderStatus
status
=
dec
-
>
jpeg_decoder
.
WriteOutput
(
*
dec
-
>
ib
-
>
jpeg_data
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
}
else
if
(
return_full_image
&
&
dec
-
>
image_out_buffer_set
)
{
if
(
!
dec
-
>
frame_dec
-
>
HasRGBBuffer
(
)
)
{
JxlDecoderStatus
status
=
ConvertImageInternal
(
dec
*
dec
-
>
ib
dec
-
>
image_out_format
false
0
dec
-
>
image_out_buffer
dec
-
>
image_out_size
dec
-
>
image_out_callback
dec
-
>
image_out_opaque
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
}
dec
-
>
image_out_buffer_set
=
false
;
for
(
size_t
i
=
0
;
i
<
dec
-
>
extra_channel_output
.
size
(
)
;
+
+
i
)
{
void
*
buffer
=
dec
-
>
extra_channel_output
[
i
]
.
buffer
;
if
(
!
buffer
)
continue
;
const
JxlPixelFormat
*
format
=
&
dec
-
>
extra_channel_output
[
i
]
.
format
;
JxlDecoderStatus
status
=
ConvertImageInternal
(
dec
*
dec
-
>
ib
*
format
true
i
buffer
dec
-
>
extra_channel_output
[
i
]
.
buffer_size
nullptr
nullptr
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
}
dec
-
>
extra_channel_output
.
clear
(
)
;
}
}
}
dec
-
>
ib
.
reset
(
)
;
dec
-
>
frame_stage
=
FrameStage
:
:
kHeader
;
dec
-
>
frame_start
+
=
dec
-
>
frame_size
;
if
(
return_full_image
&
&
!
dec
-
>
skipping_frame
)
{
return
JXL_DEC_FULL_IMAGE
;
}
}
dec
-
>
stage
=
DecoderStage
:
:
kFinished
;
return
JXL_DEC_SUCCESS
;
}
}
}
JxlDecoderStatus
JxlDecoderSetInput
(
JxlDecoder
*
dec
const
uint8_t
*
data
size_t
size
)
{
if
(
dec
-
>
next_in
)
return
JXL_DEC_ERROR
;
dec
-
>
next_in
=
data
;
dec
-
>
avail_in
=
size
;
return
JXL_DEC_SUCCESS
;
}
size_t
JxlDecoderReleaseInput
(
JxlDecoder
*
dec
)
{
size_t
result
=
dec
-
>
avail_in
;
dec
-
>
next_in
=
nullptr
;
dec
-
>
avail_in
=
0
;
return
result
;
}
JxlDecoderStatus
JxlDecoderSetJPEGBuffer
(
JxlDecoder
*
dec
uint8_t
*
data
size_t
size
)
{
return
dec
-
>
jpeg_decoder
.
SetOutputBuffer
(
data
size
)
;
}
size_t
JxlDecoderReleaseJPEGBuffer
(
JxlDecoder
*
dec
)
{
return
dec
-
>
jpeg_decoder
.
ReleaseOutputBuffer
(
)
;
}
JxlDecoderStatus
JxlDecoderProcessInput
(
JxlDecoder
*
dec
)
{
const
uint8_t
*
*
next_in
=
&
dec
-
>
next_in
;
size_t
*
avail_in
=
&
dec
-
>
avail_in
;
if
(
dec
-
>
stage
=
=
DecoderStage
:
:
kInited
)
{
dec
-
>
stage
=
DecoderStage
:
:
kStarted
;
}
if
(
dec
-
>
stage
=
=
DecoderStage
:
:
kError
)
{
return
JXL_API_ERROR
(
"
Cannot
keep
using
decoder
after
it
encountered
an
error
use
"
"
JxlDecoderReset
to
reset
it
"
)
;
}
if
(
!
dec
-
>
got_signature
)
{
JxlSignature
sig
=
JxlSignatureCheck
(
*
next_in
*
avail_in
)
;
if
(
sig
=
=
JXL_SIG_INVALID
)
return
JXL_API_ERROR
(
"
invalid
signature
"
)
;
if
(
sig
=
=
JXL_SIG_NOT_ENOUGH_BYTES
)
return
JXL_DEC_NEED_MORE_INPUT
;
dec
-
>
got_signature
=
true
;
if
(
sig
=
=
JXL_SIG_CONTAINER
)
{
dec
-
>
have_container
=
1
;
}
}
size_t
csize
=
*
avail_in
;
if
(
dec
-
>
have_container
)
{
if
(
dec
-
>
skip_box
)
{
size_t
remaining
=
dec
-
>
box_end
-
dec
-
>
file_pos
;
if
(
*
avail_in
<
remaining
)
{
dec
-
>
file_pos
+
=
*
avail_in
;
*
next_in
+
=
*
avail_in
;
*
avail_in
-
=
*
avail_in
;
return
JXL_DEC_NEED_MORE_INPUT
;
}
else
{
dec
-
>
file_pos
+
=
remaining
;
*
next_in
+
=
remaining
;
*
avail_in
-
=
remaining
;
dec
-
>
skip_box
=
false
;
}
}
if
(
dec
-
>
first_codestream_seen
&
&
!
dec
-
>
last_codestream_seen
&
&
dec
-
>
codestream_end
!
=
0
&
&
dec
-
>
file_pos
<
dec
-
>
codestream_end
&
&
dec
-
>
file_pos
+
*
avail_in
>
=
dec
-
>
codestream_end
&
&
!
dec
-
>
codestream
.
empty
(
)
)
{
csize
=
*
avail_in
;
if
(
dec
-
>
codestream_end
&
&
csize
>
dec
-
>
codestream_end
-
dec
-
>
file_pos
)
{
csize
=
dec
-
>
codestream_end
-
dec
-
>
file_pos
;
}
dec
-
>
codestream
.
insert
(
dec
-
>
codestream
.
end
(
)
*
next_in
*
next_in
+
csize
)
;
dec
-
>
file_pos
+
=
csize
;
*
next_in
+
=
csize
;
*
avail_in
-
=
csize
;
}
if
(
dec
-
>
jpeg_decoder
.
IsParsingBox
(
)
)
{
JxlDecoderStatus
recon_result
=
dec
-
>
jpeg_decoder
.
Process
(
next_in
avail_in
)
;
if
(
recon_result
=
=
JXL_DEC_JPEG_RECONSTRUCTION
)
{
if
(
dec
-
>
events_wanted
&
recon_result
)
{
dec
-
>
events_wanted
&
=
~
recon_result
;
return
recon_result
;
}
}
else
{
return
recon_result
;
}
}
if
(
!
dec
-
>
last_codestream_seen
&
&
(
dec
-
>
codestream_begin
=
=
0
|
|
(
dec
-
>
codestream_end
!
=
0
&
&
dec
-
>
file_pos
>
=
dec
-
>
codestream_end
)
)
)
{
size_t
pos
=
0
;
for
(
;
;
)
{
const
uint8_t
*
in
=
*
next_in
;
size_t
size
=
*
avail_in
;
if
(
size
=
=
pos
)
{
break
;
}
if
(
OutOfBounds
(
pos
8
size
)
)
{
dec
-
>
basic_info_size_hint
=
InitialBasicInfoSizeHint
(
)
+
pos
+
8
-
dec
-
>
file_pos
;
return
JXL_DEC_NEED_MORE_INPUT
;
}
size_t
box_start
=
pos
;
uint64_t
box_size
=
LoadBE32
(
in
+
pos
)
;
char
type
[
5
]
=
{
0
}
;
memcpy
(
type
in
+
pos
+
4
4
)
;
pos
+
=
8
;
if
(
box_size
=
=
1
)
{
if
(
OutOfBounds
(
pos
8
size
)
)
return
JXL_DEC_NEED_MORE_INPUT
;
box_size
=
LoadBE64
(
in
+
pos
)
;
pos
+
=
8
;
}
size_t
header_size
=
pos
-
box_start
;
if
(
box_size
>
0
&
&
box_size
<
header_size
)
{
return
JXL_API_ERROR
(
"
invalid
box
size
"
)
;
}
if
(
SumOverflows
(
dec
-
>
file_pos
pos
box_size
)
)
{
return
JXL_API_ERROR
(
"
Box
size
overflow
"
)
;
}
size_t
contents_size
=
(
box_size
=
=
0
)
?
0
:
(
box_size
-
pos
+
box_start
)
;
dec
-
>
box_begin
=
box_start
;
dec
-
>
box_end
=
dec
-
>
file_pos
+
box_start
+
box_size
;
if
(
strcmp
(
type
"
jxlc
"
)
=
=
0
|
|
strcmp
(
type
"
jxlp
"
)
=
=
0
)
{
if
(
dec
-
>
stage
=
=
DecoderStage
:
:
kFinished
)
{
return
JXL_API_ERROR
(
"
unexpected
codestream
box
when
codestream
already
finished
"
)
;
}
size_t
codestream_size
=
contents_size
;
bool
last_codestream
=
false
;
if
(
strcmp
(
type
"
jxlp
"
)
=
=
0
)
{
if
(
OutOfBounds
(
pos
4
size
)
)
return
JXL_DEC_NEED_MORE_INPUT
;
if
(
box_size
!
=
0
&
&
contents_size
<
4
)
{
return
JXL_API_ERROR
(
"
jxlp
box
too
small
to
contain
index
"
)
;
}
codestream_size
-
=
4
;
size_t
jxlp_index
=
LoadBE32
(
in
+
pos
)
;
pos
+
=
4
;
if
(
jxlp_index
&
0x80000000
)
last_codestream
=
true
;
}
else
if
(
strcmp
(
type
"
jxlc
"
)
=
=
0
)
{
last_codestream
=
true
;
}
if
(
!
last_codestream
&
&
box_size
=
=
0
)
{
return
JXL_API_ERROR
(
"
final
box
has
unbounded
size
but
is
a
non
-
final
codestream
"
"
box
"
)
;
}
dec
-
>
first_codestream_seen
=
true
;
if
(
last_codestream
)
dec
-
>
last_codestream_seen
=
true
;
if
(
dec
-
>
codestream_begin
!
=
0
&
&
dec
-
>
codestream
.
empty
(
)
)
{
if
(
dec
-
>
codestream_begin
<
dec
-
>
file_pos
)
{
return
JXL_API_ERROR
(
"
earlier
codestream
box
out
of
range
"
)
;
}
size_t
begin
=
dec
-
>
codestream_begin
-
dec
-
>
file_pos
;
size_t
end
=
dec
-
>
codestream_end
-
dec
-
>
file_pos
;
JXL_ASSERT
(
end
<
=
*
avail_in
)
;
dec
-
>
codestream
.
insert
(
dec
-
>
codestream
.
end
(
)
*
next_in
+
begin
*
next_in
+
end
)
;
}
dec
-
>
codestream_begin
=
dec
-
>
file_pos
+
pos
;
dec
-
>
codestream_end
=
(
box_size
=
=
0
)
?
0
:
(
dec
-
>
codestream_begin
+
codestream_size
)
;
size_t
avail_codestream_size
=
(
box_size
=
=
0
)
?
(
size
-
pos
)
:
std
:
:
min
<
size_t
>
(
size
-
pos
box_size
-
pos
+
box_start
)
;
if
(
!
dec
-
>
codestream
.
empty
(
)
)
{
size_t
begin
=
pos
;
size_t
end
=
std
:
:
min
<
size_t
>
(
*
avail_in
begin
+
avail_codestream_size
)
;
dec
-
>
codestream
.
insert
(
dec
-
>
codestream
.
end
(
)
*
next_in
+
begin
*
next_in
+
end
)
;
pos
+
=
(
end
-
begin
)
;
dec
-
>
file_pos
+
=
pos
;
*
next_in
+
=
pos
;
*
avail_in
-
=
pos
;
pos
=
0
;
if
(
*
avail_in
=
=
0
)
break
;
}
else
{
dec
-
>
file_pos
+
=
pos
;
*
next_in
+
=
pos
;
*
avail_in
-
=
pos
;
pos
=
0
;
if
(
avail_codestream_size
=
=
*
avail_in
)
{
break
;
}
pos
+
=
avail_codestream_size
;
}
}
else
if
(
(
JPEGXL_ENABLE_TRANSCODE_JPEG
)
&
&
(
dec
-
>
orig_events_wanted
&
JXL_DEC_JPEG_RECONSTRUCTION
)
&
&
strcmp
(
type
"
jbrd
"
)
=
=
0
)
{
dec
-
>
jpeg_decoder
.
StartBox
(
box_size
contents_size
)
;
dec
-
>
file_pos
+
=
pos
;
*
next_in
+
=
pos
;
*
avail_in
-
=
pos
;
pos
=
0
;
JxlDecoderStatus
recon_result
=
dec
-
>
jpeg_decoder
.
Process
(
next_in
avail_in
)
;
if
(
recon_result
=
=
JXL_DEC_JPEG_RECONSTRUCTION
)
{
if
(
dec
-
>
events_wanted
&
recon_result
)
{
dec
-
>
events_wanted
&
=
~
recon_result
;
return
recon_result
;
}
}
else
{
return
recon_result
;
}
}
else
{
if
(
box_size
=
=
0
)
{
if
(
!
dec
-
>
first_codestream_seen
)
{
return
JXL_API_ERROR
(
"
didn
'
t
find
any
codestream
box
"
)
;
}
break
;
}
if
(
OutOfBounds
(
pos
contents_size
size
)
)
{
dec
-
>
skip_box
=
true
;
dec
-
>
file_pos
+
=
pos
;
*
next_in
+
=
pos
;
*
avail_in
-
=
pos
;
dec
-
>
basic_info_size_hint
=
InitialBasicInfoSizeHint
(
)
+
pos
+
contents_size
-
dec
-
>
file_pos
;
return
JXL_DEC_NEED_MORE_INPUT
;
}
pos
+
=
contents_size
;
if
(
!
(
dec
-
>
codestream
.
empty
(
)
&
&
dec
-
>
first_codestream_seen
)
)
{
dec
-
>
file_pos
+
=
pos
;
*
next_in
+
=
pos
;
*
avail_in
-
=
pos
;
pos
=
0
;
}
}
}
}
csize
=
*
avail_in
;
if
(
dec
-
>
codestream_end
&
&
csize
>
dec
-
>
codestream_end
-
dec
-
>
file_pos
)
{
csize
=
dec
-
>
codestream_end
-
dec
-
>
file_pos
;
}
}
else
{
if
(
dec
-
>
stage
=
=
DecoderStage
:
:
kFinished
)
{
return
JXL_API_ERROR
(
"
no
more
input
expected
after
non
-
container
codestream
"
)
;
}
}
bool
detected_streaming
=
!
dec
-
>
codestream
.
empty
(
)
;
JxlDecoderStatus
result
;
JXL_DASSERT
(
csize
<
=
*
avail_in
)
;
if
(
detected_streaming
)
{
dec
-
>
codestream
.
insert
(
dec
-
>
codestream
.
end
(
)
*
next_in
*
next_in
+
csize
)
;
dec
-
>
file_pos
+
=
csize
;
*
next_in
+
=
csize
;
*
avail_in
-
=
csize
;
result
=
jxl
:
:
JxlDecoderProcessInternal
(
dec
dec
-
>
codestream
.
data
(
)
dec
-
>
codestream
.
size
(
)
)
;
}
else
{
result
=
jxl
:
:
JxlDecoderProcessInternal
(
dec
*
next_in
csize
)
;
if
(
dec
-
>
got_basic_info
&
&
result
=
=
JXL_DEC_NEED_MORE_INPUT
)
{
dec
-
>
codestream
.
insert
(
dec
-
>
codestream
.
end
(
)
*
next_in
*
next_in
+
csize
)
;
dec
-
>
file_pos
+
=
csize
;
*
next_in
+
=
csize
;
*
avail_in
-
=
csize
;
}
}
return
result
;
}
static_assert
(
sizeof
(
JxlBasicInfo
)
=
=
204
"
JxlBasicInfo
struct
size
should
remain
constant
"
)
;
JxlDecoderStatus
JxlDecoderGetBasicInfo
(
const
JxlDecoder
*
dec
JxlBasicInfo
*
info
)
{
if
(
!
dec
-
>
got_basic_info
)
return
JXL_DEC_NEED_MORE_INPUT
;
if
(
info
)
{
const
jxl
:
:
ImageMetadata
&
meta
=
dec
-
>
metadata
.
m
;
info
-
>
have_container
=
dec
-
>
have_container
;
info
-
>
xsize
=
dec
-
>
metadata
.
size
.
xsize
(
)
;
info
-
>
ysize
=
dec
-
>
metadata
.
size
.
ysize
(
)
;
info
-
>
uses_original_profile
=
!
meta
.
xyb_encoded
;
info
-
>
bits_per_sample
=
meta
.
bit_depth
.
bits_per_sample
;
info
-
>
exponent_bits_per_sample
=
meta
.
bit_depth
.
exponent_bits_per_sample
;
info
-
>
have_preview
=
meta
.
have_preview
;
info
-
>
have_animation
=
meta
.
have_animation
;
info
-
>
orientation
=
static_cast
<
JxlOrientation
>
(
meta
.
orientation
)
;
if
(
!
dec
-
>
keep_orientation
)
{
if
(
info
-
>
orientation
>
=
JXL_ORIENT_TRANSPOSE
)
{
std
:
:
swap
(
info
-
>
xsize
info
-
>
ysize
)
;
}
info
-
>
orientation
=
JXL_ORIENT_IDENTITY
;
}
info
-
>
intensity_target
=
meta
.
IntensityTarget
(
)
;
info
-
>
min_nits
=
meta
.
tone_mapping
.
min_nits
;
info
-
>
relative_to_max_display
=
meta
.
tone_mapping
.
relative_to_max_display
;
info
-
>
linear_below
=
meta
.
tone_mapping
.
linear_below
;
const
jxl
:
:
ExtraChannelInfo
*
alpha
=
meta
.
Find
(
jxl
:
:
ExtraChannel
:
:
kAlpha
)
;
if
(
alpha
!
=
nullptr
)
{
info
-
>
alpha_bits
=
alpha
-
>
bit_depth
.
bits_per_sample
;
info
-
>
alpha_exponent_bits
=
alpha
-
>
bit_depth
.
exponent_bits_per_sample
;
info
-
>
alpha_premultiplied
=
alpha
-
>
alpha_associated
;
}
else
{
info
-
>
alpha_bits
=
0
;
info
-
>
alpha_exponent_bits
=
0
;
info
-
>
alpha_premultiplied
=
0
;
}
info
-
>
num_color_channels
=
meta
.
color_encoding
.
GetColorSpace
(
)
=
=
jxl
:
:
ColorSpace
:
:
kGray
?
1
:
3
;
info
-
>
num_extra_channels
=
meta
.
num_extra_channels
;
if
(
info
-
>
have_preview
)
{
info
-
>
preview
.
xsize
=
dec
-
>
metadata
.
m
.
preview_size
.
xsize
(
)
;
info
-
>
preview
.
ysize
=
dec
-
>
metadata
.
m
.
preview_size
.
ysize
(
)
;
}
if
(
info
-
>
have_animation
)
{
info
-
>
animation
.
tps_numerator
=
dec
-
>
metadata
.
m
.
animation
.
tps_numerator
;
info
-
>
animation
.
tps_denominator
=
dec
-
>
metadata
.
m
.
animation
.
tps_denominator
;
info
-
>
animation
.
num_loops
=
dec
-
>
metadata
.
m
.
animation
.
num_loops
;
info
-
>
animation
.
have_timecodes
=
dec
-
>
metadata
.
m
.
animation
.
have_timecodes
;
}
}
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderGetExtraChannelInfo
(
const
JxlDecoder
*
dec
size_t
index
JxlExtraChannelInfo
*
info
)
{
if
(
!
dec
-
>
got_basic_info
)
return
JXL_DEC_NEED_MORE_INPUT
;
const
std
:
:
vector
<
jxl
:
:
ExtraChannelInfo
>
&
channels
=
dec
-
>
metadata
.
m
.
extra_channel_info
;
if
(
index
>
=
channels
.
size
(
)
)
return
JXL_DEC_ERROR
;
const
jxl
:
:
ExtraChannelInfo
&
channel
=
channels
[
index
]
;
info
-
>
type
=
static_cast
<
JxlExtraChannelType
>
(
channel
.
type
)
;
info
-
>
bits_per_sample
=
channel
.
bit_depth
.
bits_per_sample
;
info
-
>
exponent_bits_per_sample
=
channel
.
bit_depth
.
floating_point_sample
?
channel
.
bit_depth
.
exponent_bits_per_sample
:
0
;
info
-
>
dim_shift
=
channel
.
dim_shift
;
info
-
>
name_length
=
channel
.
name
.
size
(
)
;
info
-
>
alpha_premultiplied
=
channel
.
alpha_associated
;
info
-
>
spot_color
[
0
]
=
channel
.
spot_color
[
0
]
;
info
-
>
spot_color
[
1
]
=
channel
.
spot_color
[
1
]
;
info
-
>
spot_color
[
2
]
=
channel
.
spot_color
[
2
]
;
info
-
>
spot_color
[
3
]
=
channel
.
spot_color
[
3
]
;
info
-
>
cfa_channel
=
channel
.
cfa_channel
;
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderGetExtraChannelName
(
const
JxlDecoder
*
dec
size_t
index
char
*
name
size_t
size
)
{
if
(
!
dec
-
>
got_basic_info
)
return
JXL_DEC_NEED_MORE_INPUT
;
const
std
:
:
vector
<
jxl
:
:
ExtraChannelInfo
>
&
channels
=
dec
-
>
metadata
.
m
.
extra_channel_info
;
if
(
index
>
=
channels
.
size
(
)
)
return
JXL_DEC_ERROR
;
const
jxl
:
:
ExtraChannelInfo
&
channel
=
channels
[
index
]
;
if
(
channel
.
name
.
size
(
)
+
1
>
size
)
return
JXL_DEC_ERROR
;
memcpy
(
name
channel
.
name
.
c_str
(
)
channel
.
name
.
size
(
)
+
1
)
;
return
JXL_DEC_SUCCESS
;
}
namespace
{
JxlDecoderStatus
GetColorEncodingForTarget
(
const
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
JxlColorProfileTarget
target
const
jxl
:
:
ColorEncoding
*
*
encoding
)
{
if
(
!
dec
-
>
got_all_headers
)
return
JXL_DEC_NEED_MORE_INPUT
;
*
encoding
=
nullptr
;
if
(
target
=
=
JXL_COLOR_PROFILE_TARGET_DATA
&
&
dec
-
>
metadata
.
m
.
xyb_encoded
)
{
*
encoding
=
&
dec
-
>
passes_state
-
>
output_encoding_info
.
color_encoding
;
}
else
{
*
encoding
=
&
dec
-
>
metadata
.
m
.
color_encoding
;
}
return
JXL_DEC_SUCCESS
;
}
}
JxlDecoderStatus
JxlDecoderGetColorAsEncodedProfile
(
const
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
JxlColorProfileTarget
target
JxlColorEncoding
*
color_encoding
)
{
const
jxl
:
:
ColorEncoding
*
jxl_color_encoding
=
nullptr
;
JxlDecoderStatus
status
=
GetColorEncodingForTarget
(
dec
format
target
&
jxl_color_encoding
)
;
if
(
status
)
return
status
;
if
(
jxl_color_encoding
-
>
WantICC
(
)
)
return
JXL_DEC_ERROR
;
if
(
color_encoding
)
{
ConvertInternalToExternalColorEncoding
(
*
jxl_color_encoding
color_encoding
)
;
}
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderGetICCProfileSize
(
const
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
JxlColorProfileTarget
target
size_t
*
size
)
{
const
jxl
:
:
ColorEncoding
*
jxl_color_encoding
=
nullptr
;
JxlDecoderStatus
status
=
GetColorEncodingForTarget
(
dec
format
target
&
jxl_color_encoding
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
if
(
jxl_color_encoding
-
>
WantICC
(
)
)
{
jxl
:
:
ColorSpace
color_space
=
dec
-
>
metadata
.
m
.
color_encoding
.
GetColorSpace
(
)
;
if
(
color_space
=
=
jxl
:
:
ColorSpace
:
:
kUnknown
|
|
color_space
=
=
jxl
:
:
ColorSpace
:
:
kXYB
)
{
return
JXL_DEC_ERROR
;
}
}
if
(
size
)
{
*
size
=
jxl_color_encoding
-
>
ICC
(
)
.
size
(
)
;
}
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderGetColorAsICCProfile
(
const
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
JxlColorProfileTarget
target
uint8_t
*
icc_profile
size_t
size
)
{
size_t
wanted_size
;
JxlDecoderStatus
status
=
JxlDecoderGetICCProfileSize
(
dec
format
target
&
wanted_size
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
if
(
size
<
wanted_size
)
return
JXL_API_ERROR
(
"
ICC
profile
output
too
small
"
)
;
const
jxl
:
:
ColorEncoding
*
jxl_color_encoding
=
nullptr
;
status
=
GetColorEncodingForTarget
(
dec
format
target
&
jxl_color_encoding
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
memcpy
(
icc_profile
jxl_color_encoding
-
>
ICC
(
)
.
data
(
)
jxl_color_encoding
-
>
ICC
(
)
.
size
(
)
)
;
return
JXL_DEC_SUCCESS
;
}
namespace
{
JxlDecoderStatus
PrepareSizeCheck
(
const
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
size_t
*
bits
)
{
if
(
!
dec
-
>
got_basic_info
)
{
return
JXL_DEC_NEED_MORE_INPUT
;
}
if
(
format
-
>
num_channels
>
4
)
{
return
JXL_API_ERROR
(
"
More
than
4
channels
not
supported
"
)
;
}
if
(
format
-
>
data_type
=
=
JXL_TYPE_BOOLEAN
)
{
return
JXL_API_ERROR
(
"
Boolean
data
type
not
yet
supported
"
)
;
}
if
(
format
-
>
data_type
=
=
JXL_TYPE_UINT32
)
{
return
JXL_API_ERROR
(
"
uint32
data
type
not
yet
supported
"
)
;
}
*
bits
=
BitsPerChannel
(
format
-
>
data_type
)
;
if
(
*
bits
=
=
0
)
{
return
JXL_API_ERROR
(
"
Invalid
data
type
"
)
;
}
return
JXL_DEC_SUCCESS
;
}
}
JxlDecoderStatus
JxlDecoderFlushImage
(
JxlDecoder
*
dec
)
{
if
(
!
dec
-
>
image_out_buffer
)
return
JXL_DEC_ERROR
;
if
(
!
dec
-
>
sections
|
|
dec
-
>
sections
-
>
section_info
.
empty
(
)
)
{
return
JXL_DEC_ERROR
;
}
if
(
!
dec
-
>
frame_dec
|
|
!
dec
-
>
frame_dec_in_progress
)
{
return
JXL_DEC_ERROR
;
}
if
(
!
dec
-
>
frame_dec
-
>
HasDecodedDC
(
)
)
{
return
JXL_DEC_ERROR
;
}
if
(
!
dec
-
>
frame_dec
-
>
Flush
(
)
)
{
return
JXL_DEC_ERROR
;
}
if
(
dec
-
>
frame_dec
-
>
HasRGBBuffer
(
)
)
{
return
JXL_DEC_SUCCESS
;
}
size_t
xsize
=
dec
-
>
ib
-
>
xsize
(
)
;
size_t
ysize
=
dec
-
>
ib
-
>
ysize
(
)
;
dec
-
>
ib
-
>
ShrinkTo
(
dec
-
>
metadata
.
size
.
xsize
(
)
dec
-
>
metadata
.
size
.
ysize
(
)
)
;
JxlDecoderStatus
status
=
jxl
:
:
ConvertImageInternal
(
dec
*
dec
-
>
ib
dec
-
>
image_out_format
false
0
dec
-
>
image_out_buffer
dec
-
>
image_out_size
nullptr
nullptr
)
;
dec
-
>
ib
-
>
ShrinkTo
(
xsize
ysize
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
return
JXL_DEC_SUCCESS
;
}
JXL_EXPORT
JxlDecoderStatus
JxlDecoderPreviewOutBufferSize
(
const
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
size_t
*
size
)
{
size_t
bits
;
JxlDecoderStatus
status
=
PrepareSizeCheck
(
dec
format
&
bits
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
if
(
format
-
>
num_channels
<
3
&
&
!
dec
-
>
metadata
.
m
.
color_encoding
.
IsGray
(
)
)
{
return
JXL_API_ERROR
(
"
Grayscale
output
not
possible
for
color
image
"
)
;
}
size_t
xsize
=
dec
-
>
metadata
.
oriented_preview_xsize
(
dec
-
>
keep_orientation
)
;
size_t
ysize
=
dec
-
>
metadata
.
oriented_preview_ysize
(
dec
-
>
keep_orientation
)
;
size_t
row_size
=
jxl
:
:
DivCeil
(
xsize
*
format
-
>
num_channels
*
bits
jxl
:
:
kBitsPerByte
)
;
if
(
format
-
>
align
>
1
)
{
row_size
=
jxl
:
:
DivCeil
(
row_size
format
-
>
align
)
*
format
-
>
align
;
}
*
size
=
row_size
*
ysize
;
return
JXL_DEC_SUCCESS
;
}
JXL_EXPORT
JxlDecoderStatus
JxlDecoderSetPreviewOutBuffer
(
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
void
*
buffer
size_t
size
)
{
if
(
!
dec
-
>
got_basic_info
|
|
!
dec
-
>
metadata
.
m
.
have_preview
|
|
!
(
dec
-
>
orig_events_wanted
&
JXL_DEC_PREVIEW_IMAGE
)
)
{
return
JXL_API_ERROR
(
"
No
preview
out
buffer
needed
at
this
time
"
)
;
}
if
(
format
-
>
num_channels
<
3
&
&
!
dec
-
>
metadata
.
m
.
color_encoding
.
IsGray
(
)
)
{
return
JXL_API_ERROR
(
"
Grayscale
output
not
possible
for
color
image
"
)
;
}
size_t
min_size
;
JxlDecoderStatus
status
=
JxlDecoderPreviewOutBufferSize
(
dec
format
&
min_size
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
if
(
size
<
min_size
)
return
JXL_DEC_ERROR
;
dec
-
>
preview_out_buffer_set
=
true
;
dec
-
>
preview_out_buffer
=
buffer
;
dec
-
>
preview_out_size
=
size
;
dec
-
>
preview_out_format
=
*
format
;
return
JXL_DEC_SUCCESS
;
}
JXL_EXPORT
JxlDecoderStatus
JxlDecoderDCOutBufferSize
(
const
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
size_t
*
size
)
{
size_t
bits
;
JxlDecoderStatus
status
=
PrepareSizeCheck
(
dec
format
&
bits
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
size_t
xsize
=
jxl
:
:
DivCeil
(
dec
-
>
metadata
.
oriented_xsize
(
dec
-
>
keep_orientation
)
jxl
:
:
kBlockDim
)
;
size_t
ysize
=
jxl
:
:
DivCeil
(
dec
-
>
metadata
.
oriented_ysize
(
dec
-
>
keep_orientation
)
jxl
:
:
kBlockDim
)
;
size_t
row_size
=
jxl
:
:
DivCeil
(
xsize
*
format
-
>
num_channels
*
bits
jxl
:
:
kBitsPerByte
)
;
if
(
format
-
>
align
>
1
)
{
row_size
=
jxl
:
:
DivCeil
(
row_size
format
-
>
align
)
*
format
-
>
align
;
}
*
size
=
row_size
*
ysize
;
return
JXL_DEC_SUCCESS
;
}
JXL_EXPORT
JxlDecoderStatus
JxlDecoderSetDCOutBuffer
(
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
void
*
buffer
size_t
size
)
{
return
JXL_DEC_SUCCESS
;
}
JXL_EXPORT
JxlDecoderStatus
JxlDecoderImageOutBufferSize
(
const
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
size_t
*
size
)
{
size_t
bits
;
JxlDecoderStatus
status
=
PrepareSizeCheck
(
dec
format
&
bits
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
if
(
format
-
>
num_channels
<
3
&
&
!
dec
-
>
metadata
.
m
.
color_encoding
.
IsGray
(
)
)
{
return
JXL_API_ERROR
(
"
Grayscale
output
not
possible
for
color
image
"
)
;
}
size_t
row_size
=
jxl
:
:
DivCeil
(
dec
-
>
metadata
.
oriented_xsize
(
dec
-
>
keep_orientation
)
*
format
-
>
num_channels
*
bits
jxl
:
:
kBitsPerByte
)
;
if
(
format
-
>
align
>
1
)
{
row_size
=
jxl
:
:
DivCeil
(
row_size
format
-
>
align
)
*
format
-
>
align
;
}
*
size
=
row_size
*
dec
-
>
metadata
.
oriented_ysize
(
dec
-
>
keep_orientation
)
;
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderSetImageOutBuffer
(
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
void
*
buffer
size_t
size
)
{
if
(
!
dec
-
>
got_basic_info
|
|
!
(
dec
-
>
orig_events_wanted
&
JXL_DEC_FULL_IMAGE
)
)
{
return
JXL_API_ERROR
(
"
No
image
out
buffer
needed
at
this
time
"
)
;
}
if
(
dec
-
>
image_out_buffer_set
&
&
!
!
dec
-
>
image_out_callback
)
{
return
JXL_API_ERROR
(
"
Cannot
change
from
image
out
callback
to
image
out
buffer
"
)
;
}
if
(
format
-
>
num_channels
<
3
&
&
!
dec
-
>
metadata
.
m
.
color_encoding
.
IsGray
(
)
)
{
return
JXL_API_ERROR
(
"
Grayscale
output
not
possible
for
color
image
"
)
;
}
size_t
min_size
;
JxlDecoderStatus
status
=
JxlDecoderImageOutBufferSize
(
dec
format
&
min_size
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
if
(
size
<
min_size
)
return
JXL_DEC_ERROR
;
dec
-
>
image_out_buffer_set
=
true
;
dec
-
>
image_out_buffer
=
buffer
;
dec
-
>
image_out_size
=
size
;
dec
-
>
image_out_format
=
*
format
;
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderExtraChannelBufferSize
(
const
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
size_t
*
size
uint32_t
index
)
{
if
(
!
dec
-
>
got_basic_info
|
|
!
(
dec
-
>
orig_events_wanted
&
JXL_DEC_FULL_IMAGE
)
)
{
return
JXL_API_ERROR
(
"
No
extra
channel
buffer
needed
at
this
time
"
)
;
}
if
(
index
>
=
dec
-
>
metadata
.
m
.
num_extra_channels
)
{
return
JXL_API_ERROR
(
"
Invalid
extra
channel
index
"
)
;
}
size_t
num_channels
=
1
;
size_t
bits
;
JxlDecoderStatus
status
=
PrepareSizeCheck
(
dec
format
&
bits
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
size_t
row_size
=
jxl
:
:
DivCeil
(
dec
-
>
metadata
.
oriented_xsize
(
dec
-
>
keep_orientation
)
*
num_channels
*
bits
jxl
:
:
kBitsPerByte
)
;
if
(
format
-
>
align
>
1
)
{
row_size
=
jxl
:
:
DivCeil
(
row_size
format
-
>
align
)
*
format
-
>
align
;
}
*
size
=
row_size
*
dec
-
>
metadata
.
oriented_ysize
(
dec
-
>
keep_orientation
)
;
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderSetExtraChannelBuffer
(
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
void
*
buffer
size_t
size
uint32_t
index
)
{
size_t
min_size
;
JxlDecoderStatus
status
=
JxlDecoderExtraChannelBufferSize
(
dec
format
&
min_size
index
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
if
(
size
<
min_size
)
return
JXL_DEC_ERROR
;
if
(
dec
-
>
extra_channel_output
.
size
(
)
<
=
index
)
{
dec
-
>
extra_channel_output
.
resize
(
dec
-
>
metadata
.
m
.
num_extra_channels
{
{
}
nullptr
0
}
)
;
}
JXL_ASSERT
(
index
<
dec
-
>
extra_channel_output
.
size
(
)
)
;
dec
-
>
extra_channel_output
[
index
]
.
format
=
*
format
;
dec
-
>
extra_channel_output
[
index
]
.
format
.
num_channels
=
1
;
dec
-
>
extra_channel_output
[
index
]
.
buffer
=
buffer
;
dec
-
>
extra_channel_output
[
index
]
.
buffer_size
=
size
;
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderSetImageOutCallback
(
JxlDecoder
*
dec
const
JxlPixelFormat
*
format
JxlImageOutCallback
callback
void
*
opaque
)
{
if
(
dec
-
>
image_out_buffer_set
&
&
!
!
dec
-
>
image_out_buffer
)
{
return
JXL_API_ERROR
(
"
Cannot
change
from
image
out
buffer
to
image
out
callback
"
)
;
}
size_t
bits_dummy
;
JxlDecoderStatus
status
=
PrepareSizeCheck
(
dec
format
&
bits_dummy
)
;
if
(
status
!
=
JXL_DEC_SUCCESS
)
return
status
;
dec
-
>
image_out_buffer_set
=
true
;
dec
-
>
image_out_callback
=
callback
;
dec
-
>
image_out_opaque
=
opaque
;
dec
-
>
image_out_format
=
*
format
;
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderGetFrameHeader
(
const
JxlDecoder
*
dec
JxlFrameHeader
*
header
)
{
if
(
!
dec
-
>
frame_header
|
|
dec
-
>
frame_stage
=
=
FrameStage
:
:
kHeader
)
{
return
JXL_API_ERROR
(
"
no
frame
header
available
"
)
;
}
const
auto
&
metadata
=
dec
-
>
metadata
.
m
;
if
(
metadata
.
have_animation
)
{
header
-
>
duration
=
dec
-
>
frame_header
-
>
animation_frame
.
duration
;
if
(
metadata
.
animation
.
have_timecodes
)
{
header
-
>
timecode
=
dec
-
>
frame_header
-
>
animation_frame
.
timecode
;
}
}
header
-
>
name_length
=
dec
-
>
frame_header
-
>
name
.
size
(
)
;
header
-
>
is_last
=
dec
-
>
frame_header
-
>
is_last
;
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderGetFrameName
(
const
JxlDecoder
*
dec
char
*
name
size_t
size
)
{
if
(
!
dec
-
>
frame_header
|
|
dec
-
>
frame_stage
=
=
FrameStage
:
:
kHeader
)
{
return
JXL_API_ERROR
(
"
no
frame
header
available
"
)
;
}
if
(
size
<
dec
-
>
frame_header
-
>
name
.
size
(
)
+
1
)
{
return
JXL_API_ERROR
(
"
too
small
frame
name
output
buffer
"
)
;
}
memcpy
(
name
dec
-
>
frame_header
-
>
name
.
c_str
(
)
dec
-
>
frame_header
-
>
name
.
size
(
)
+
1
)
;
return
JXL_DEC_SUCCESS
;
}
JxlDecoderStatus
JxlDecoderSetPreferredColorProfile
(
JxlDecoder
*
dec
const
JxlColorEncoding
*
color_encoding
)
{
if
(
!
dec
-
>
got_all_headers
)
{
return
JXL_API_ERROR
(
"
color
info
not
yet
available
"
)
;
}
if
(
dec
-
>
post_headers
)
{
return
JXL_API_ERROR
(
"
too
late
to
set
the
color
encoding
"
)
;
}
if
(
dec
-
>
metadata
.
m
.
color_encoding
.
IsGray
(
)
!
=
(
color_encoding
-
>
color_space
=
=
JXL_COLOR_SPACE_GRAY
)
)
{
return
JXL_API_ERROR
(
"
grayscale
mismatch
"
)
;
}
if
(
color_encoding
-
>
color_space
=
=
JXL_COLOR_SPACE_UNKNOWN
|
|
color_encoding
-
>
color_space
=
=
JXL_COLOR_SPACE_XYB
)
{
return
JXL_API_ERROR
(
"
only
RGB
or
grayscale
output
supported
"
)
;
}
JXL_API_RETURN_IF_ERROR
(
ConvertExternalToInternalColorEncoding
(
*
color_encoding
&
dec
-
>
default_enc
)
)
;
JXL_API_RETURN_IF_ERROR
(
dec
-
>
passes_state
-
>
output_encoding_info
.
Set
(
dec
-
>
metadata
dec
-
>
default_enc
)
)
;
return
JXL_DEC_SUCCESS
;
}
void
SetDecoderMemoryLimitBase_
(
size_t
memory_limit_base
)
{
memory_limit_base_
=
memory_limit_base
;
cpu_limit_base_
=
5
*
memory_limit_base
;
}
