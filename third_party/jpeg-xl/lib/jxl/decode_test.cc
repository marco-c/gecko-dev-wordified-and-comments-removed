#
include
"
jxl
/
decode
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
jxl
/
decode_cxx
.
h
"
#
include
"
jxl
/
thread_parallel_runner
.
h
"
#
include
"
lib
/
extras
/
codec
.
h
"
#
include
"
lib
/
extras
/
codec_jpg
.
h
"
#
include
"
lib
/
jxl
/
base
/
byte_order
.
h
"
#
include
"
lib
/
jxl
/
base
/
file_io
.
h
"
#
include
"
lib
/
jxl
/
base
/
span
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
dec_file
.
h
"
#
include
"
lib
/
jxl
/
enc_butteraugli_comparator
.
h
"
#
include
"
lib
/
jxl
/
enc_external_image
.
h
"
#
include
"
lib
/
jxl
/
enc_file
.
h
"
#
include
"
lib
/
jxl
/
enc_gamma_correct
.
h
"
#
include
"
lib
/
jxl
/
enc_icc_codec
.
h
"
#
include
"
lib
/
jxl
/
encode_internal
.
h
"
#
include
"
lib
/
jxl
/
fields
.
h
"
#
include
"
lib
/
jxl
/
headers
.
h
"
#
include
"
lib
/
jxl
/
icc_codec
.
h
"
#
include
"
lib
/
jxl
/
jpeg
/
enc_jpeg_data
.
h
"
#
include
"
lib
/
jxl
/
test_utils
.
h
"
#
include
"
lib
/
jxl
/
testdata
.
h
"
#
include
"
tools
/
box
/
box
.
h
"
namespace
{
void
AppendU32BE
(
uint32_t
u32
jxl
:
:
PaddedBytes
*
bytes
)
{
bytes
-
>
push_back
(
u32
>
>
24
)
;
bytes
-
>
push_back
(
u32
>
>
16
)
;
bytes
-
>
push_back
(
u32
>
>
8
)
;
bytes
-
>
push_back
(
u32
>
>
0
)
;
}
enum
CodeStreamBoxFormat
{
kCSBF_None
kCSBF_Single
kCSBF_Single_Zero_Terminated
kCSBF_Multi
kCSBF_Multi_Zero_Terminated
kCSBF_Multi_Other_Terminated
kCSBF_Multi_Other_Zero_Terminated
kCSBF_Multi_First_Empty
kCSBF_NUM_ENTRIES
}
;
jxl
:
:
PaddedBytes
GetIccTestProfile
(
)
{
const
uint8_t
*
profile
=
reinterpret_cast
<
const
uint8_t
*
>
(
"
\
0
\
0
\
3
\
200lcms
\
0040
\
0
\
0mntrRGB
XYZ
"
"
\
a
\
344
\
0
\
a
\
0
\
27
\
0
\
21
\
0
"
"
\
0
\
37acspAPPL
\
0
\
0
\
0
\
1
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
1
\
0
\
0
\
366
"
"
\
326
\
0
\
1
\
0
\
0
\
0
\
0
\
323
-
lcms
\
372c
\
207
\
36
\
227
\
200
{
"
"
\
2
\
232s
\
255
\
327
\
340
\
0
\
n
\
26
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
"
"
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
rdesc
\
0
\
0
\
1
"
"
\
0
\
0
\
0Bcprt
\
0
\
0
\
1d
\
0
\
0
\
1
\
0wtpt
\
0
\
0
\
2d
\
0
\
0
\
0
\
24chad
\
0
\
0
\
2x
\
0
\
0
\
0
"
"
bXYZ
\
0
\
0
\
2
\
244
\
0
\
0
\
0
\
24gXYZ
\
0
\
0
\
2
\
270
\
0
\
0
\
0
\
24rXYZ
\
0
\
0
\
2
\
314
\
0
\
0
\
0
\
24rTR
"
"
C
\
0
\
0
\
2
\
340
\
0
\
0
\
0
gTRC
\
0
\
0
\
2
\
340
\
0
\
0
\
0
bTRC
\
0
\
0
\
2
\
340
\
0
\
0
\
0
"
"
chrm
\
0
\
0
\
3
\
0
\
0
\
0
\
0
dmnd
\
0
\
0
\
3
\
0
\
0
\
0
(
"
"
dmdd
\
0
\
0
\
3L
\
0
\
0
\
0002mluc
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
1
\
0
\
0
\
0
\
fenUS
\
0
\
0
\
0
&
"
"
\
0
\
0
\
0
\
34
\
0R
\
0G
\
0B
\
0_
\
0D
\
0006
\
0005
\
0_
\
0S
\
0R
\
0G
\
0_
\
0R
\
0e
\
0l
\
0_
"
"
\
0L
\
0i
\
0n
\
0
\
0mluc
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
1
\
0
\
0
\
0
\
fenUS
\
0
\
0
\
0
\
344
\
0
\
0
\
0
\
34
\
0C
\
0o
\
0
"
"
p
\
0y
\
0r
\
0i
\
0g
\
0h
\
0t
\
0
\
0002
\
0000
\
0001
\
08
\
0
\
0G
\
0o
\
0o
\
0g
\
0l
\
0e
\
0
"
"
\
0L
\
0L
\
0C
\
0
\
0
\
0C
\
0C
\
0
-
\
0B
\
0Y
\
0
-
\
0S
\
0A
\
0
\
0003
\
0
.
\
0000
\
0
"
"
\
0U
\
0n
\
0p
\
0o
\
0r
\
0t
\
0e
\
0d
\
0
"
"
\
0l
\
0i
\
0c
\
0e
\
0n
\
0s
\
0e
\
0
(
\
0h
\
0t
\
0t
\
0p
\
0s
\
0
:
\
0
/
\
0
/
"
"
\
0c
\
0r
\
0e
\
0a
\
0t
\
0i
\
0v
\
0e
\
0c
\
0o
\
0m
\
0m
\
0o
\
0n
\
0s
\
0
.
\
0o
\
0r
\
0g
\
0
/
"
"
\
0l
\
0i
\
0c
\
0e
\
0n
\
0s
\
0e
\
0s
\
0
/
\
0b
\
0y
\
0
-
\
0s
\
0a
\
0
/
\
0003
\
0
.
\
0000
\
0
/
"
"
\
0l
\
0e
\
0g
\
0a
\
0l
\
0c
\
0o
\
0d
\
0e
\
0
)
XYZ
"
"
\
0
\
0
\
0
\
0
\
0
\
0
\
366
\
326
\
0
\
1
\
0
\
0
\
0
\
0
\
323
-
"
"
sf32
\
0
\
0
\
0
\
0
\
0
\
1
\
fB
\
0
\
0
\
5
\
336
\
377
\
377
\
363
%
"
"
\
0
\
0
\
a
\
223
\
0
\
0
\
375
\
220
\
377
\
377
\
373
\
241
\
377
\
377
\
375
\
242
\
0
\
0
\
3
\
334
\
0
\
0
\
300
"
"
nXYZ
\
0
\
0
\
0
\
0
\
0
\
0o
\
240
\
0
\
08
\
365
\
0
\
0
\
3
\
220XYZ
"
"
\
0
\
0
\
0
\
0
\
0
\
0
\
237
\
0
\
0
\
17
\
204
\
0
\
0
\
266
\
304XYZ
"
"
\
0
\
0
\
0
\
0
\
0
\
0b
\
227
\
0
\
0
\
267
\
207
\
0
\
0
\
30
\
331para
\
0
\
0
\
0
\
0
\
0
\
3
\
0
\
0
\
0
\
1
\
0
\
0
\
0
\
1
"
"
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
1
\
0
\
0
\
0
\
0
\
0
\
0chrm
\
0
\
0
\
0
\
0
\
0
\
3
\
0
\
0
\
0
\
0
\
243
\
327
\
0
\
0T
|
"
"
\
0
\
0L
\
315
\
0
\
0
\
231
\
232
\
0
\
0
&
"
"
g
\
0
\
0
\
17
\
\
mluc
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
1
\
0
\
0
\
0
\
fenUS
\
0
\
0
\
0
\
f
\
0
\
0
\
0
\
34
\
0G
\
0o
\
0o
\
0g
"
"
\
0l
\
0emluc
\
0
\
0
\
0
\
0
\
0
\
0
\
0
\
1
\
0
\
0
\
0
\
fenUS
\
0
\
0
\
0
\
26
\
0
\
0
\
0
\
34
\
0I
\
0m
\
0a
\
0g
\
0e
"
"
\
0
\
0c
\
0o
\
0d
\
0e
\
0c
\
0
\
0
"
)
;
size_t
profile_size
=
896
;
jxl
:
:
PaddedBytes
icc_profile
;
icc_profile
.
assign
(
profile
profile
+
profile_size
)
;
return
icc_profile
;
}
}
namespace
jxl
{
namespace
{
PaddedBytes
CreateTestJXLCodestream
(
Span
<
const
uint8_t
>
pixels
size_t
xsize
size_t
ysize
size_t
num_channels
const
CompressParams
&
cparams
CodeStreamBoxFormat
add_container
bool
add_preview
bool
add_icc_profile
=
false
PaddedBytes
*
jpeg_codestream
=
nullptr
)
{
bool
grayscale
=
(
num_channels
<
=
2
)
;
bool
include_alpha
=
!
(
num_channels
&
1
)
&
&
jpeg_codestream
=
=
nullptr
;
size_t
bitdepth
=
jpeg_codestream
=
=
nullptr
?
16
:
8
;
CodecInOut
io
;
io
.
SetSize
(
xsize
ysize
)
;
ColorEncoding
color_encoding
=
jxl
:
:
ColorEncoding
:
:
SRGB
(
grayscale
)
;
if
(
add_icc_profile
)
{
EXPECT_EQ
(
false
grayscale
)
;
EXPECT_TRUE
(
color_encoding
.
SetICC
(
GetIccTestProfile
(
)
)
)
;
}
ThreadPool
pool
(
nullptr
nullptr
)
;
io
.
metadata
.
m
.
SetUintSamples
(
bitdepth
)
;
if
(
include_alpha
)
{
io
.
metadata
.
m
.
SetAlphaBits
(
bitdepth
)
;
}
io
.
metadata
.
m
.
color_encoding
=
color_encoding
;
EXPECT_TRUE
(
ConvertFromExternal
(
pixels
xsize
ysize
color_encoding
include_alpha
false
bitdepth
JXL_BIG_ENDIAN
false
&
pool
&
io
.
Main
(
)
)
)
;
jxl
:
:
PaddedBytes
jpeg_data
;
if
(
jpeg_codestream
!
=
nullptr
)
{
#
if
JPEGXL_ENABLE_JPEG
jxl
:
:
PaddedBytes
jpeg_bytes
;
EXPECT_TRUE
(
EncodeImageJPG
(
&
io
jxl
:
:
JpegEncoder
:
:
kLibJpeg
70
jxl
:
:
YCbCrChromaSubsampling
(
)
&
pool
&
jpeg_bytes
jxl
:
:
DecodeTarget
:
:
kPixels
)
)
;
jpeg_codestream
-
>
append
(
jpeg_bytes
.
data
(
)
jpeg_bytes
.
data
(
)
+
jpeg_bytes
.
size
(
)
)
;
EXPECT_TRUE
(
jxl
:
:
jpeg
:
:
DecodeImageJPG
(
jxl
:
:
Span
<
const
uint8_t
>
(
jpeg_bytes
.
data
(
)
jpeg_bytes
.
size
(
)
)
&
io
)
)
;
EXPECT_TRUE
(
EncodeJPEGData
(
*
io
.
Main
(
)
.
jpeg_data
&
jpeg_data
)
)
;
io
.
metadata
.
m
.
xyb_encoded
=
false
;
#
else
JXL_ABORT
(
"
unable
to
create
reconstructible
JPEG
without
JPEG
support
enabled
"
)
;
#
endif
}
if
(
add_preview
)
{
io
.
preview_frame
=
io
.
Main
(
)
.
Copy
(
)
;
io
.
preview_frame
.
ShrinkTo
(
xsize
/
7
ysize
/
7
)
;
io
.
metadata
.
m
.
have_preview
=
true
;
EXPECT_TRUE
(
io
.
metadata
.
m
.
preview_size
.
Set
(
io
.
preview_frame
.
xsize
(
)
io
.
preview_frame
.
ysize
(
)
)
)
;
}
AuxOut
aux_out
;
PaddedBytes
compressed
;
PassesEncoderState
enc_state
;
EXPECT_TRUE
(
EncodeFile
(
cparams
&
io
&
enc_state
&
compressed
&
aux_out
&
pool
)
)
;
if
(
add_container
!
=
kCSBF_None
)
{
const
uint8_t
header
[
]
=
{
0
0
0
0xc
0x4a
0x58
0x4c
0x20
0xd
0xa
0x87
0xa
0
0
0
0x14
0x66
0x74
0x79
0x70
0x6a
0x78
0x6c
0x20
0
0
0
0
0x6a
0x78
0x6c
0x20
}
;
const
uint8_t
unknown
[
]
=
{
0
0
0
0x18
0x75
0x6e
0x6b
0x6e
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
const
uint8_t
unknown_end
[
]
=
{
0
0
0
0
0x75
0x6e
0x6b
0x6e
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
bool
is_multi
=
add_container
=
=
kCSBF_Multi
|
|
add_container
=
=
kCSBF_Multi_Zero_Terminated
|
|
add_container
=
=
kCSBF_Multi_Other_Terminated
|
|
add_container
=
=
kCSBF_Multi_Other_Zero_Terminated
|
|
add_container
=
=
kCSBF_Multi_First_Empty
;
if
(
is_multi
)
{
size_t
third
=
compressed
.
size
(
)
/
3
;
std
:
:
vector
<
uint8_t
>
compressed0
(
compressed
.
data
(
)
compressed
.
data
(
)
+
third
)
;
std
:
:
vector
<
uint8_t
>
compressed1
(
compressed
.
data
(
)
+
third
compressed
.
data
(
)
+
2
*
third
)
;
std
:
:
vector
<
uint8_t
>
compressed2
(
compressed
.
data
(
)
+
2
*
third
compressed
.
data
(
)
+
compressed
.
size
(
)
)
;
PaddedBytes
c
;
c
.
append
(
header
header
+
sizeof
(
header
)
)
;
if
(
jpeg_codestream
!
=
nullptr
)
{
jxl
:
:
AppendBoxHeader
(
jxl
:
:
MakeBoxType
(
"
jbrd
"
)
jpeg_data
.
size
(
)
false
&
c
)
;
c
.
append
(
jpeg_data
.
data
(
)
jpeg_data
.
data
(
)
+
jpeg_data
.
size
(
)
)
;
}
if
(
add_container
=
=
kCSBF_Multi_First_Empty
)
{
AppendU32BE
(
8
&
c
)
;
c
.
push_back
(
'
j
'
)
;
c
.
push_back
(
'
x
'
)
;
c
.
push_back
(
'
l
'
)
;
c
.
push_back
(
'
p
'
)
;
}
AppendU32BE
(
compressed0
.
size
(
)
+
8
&
c
)
;
c
.
push_back
(
'
j
'
)
;
c
.
push_back
(
'
x
'
)
;
c
.
push_back
(
'
l
'
)
;
c
.
push_back
(
'
p
'
)
;
c
.
append
(
compressed0
.
data
(
)
compressed0
.
data
(
)
+
compressed0
.
size
(
)
)
;
c
.
append
(
unknown
unknown
+
sizeof
(
unknown
)
)
;
c
.
append
(
unknown
unknown
+
sizeof
(
unknown
)
)
;
AppendU32BE
(
8
&
c
)
;
c
.
push_back
(
'
j
'
)
;
c
.
push_back
(
'
x
'
)
;
c
.
push_back
(
'
l
'
)
;
c
.
push_back
(
'
p
'
)
;
AppendU32BE
(
compressed1
.
size
(
)
+
8
&
c
)
;
c
.
push_back
(
'
j
'
)
;
c
.
push_back
(
'
x
'
)
;
c
.
push_back
(
'
l
'
)
;
c
.
push_back
(
'
p
'
)
;
c
.
append
(
compressed1
.
data
(
)
compressed1
.
data
(
)
+
compressed1
.
size
(
)
)
;
AppendU32BE
(
add_container
=
=
kCSBF_Multi
?
(
compressed2
.
size
(
)
+
8
)
:
0
&
c
)
;
c
.
push_back
(
'
j
'
)
;
c
.
push_back
(
'
x
'
)
;
c
.
push_back
(
'
l
'
)
;
c
.
push_back
(
'
p
'
)
;
c
.
append
(
compressed2
.
data
(
)
compressed2
.
data
(
)
+
compressed2
.
size
(
)
)
;
if
(
add_container
=
=
kCSBF_Multi_Other_Terminated
)
{
c
.
append
(
unknown
unknown
+
sizeof
(
unknown
)
)
;
}
if
(
add_container
=
=
kCSBF_Multi_Other_Zero_Terminated
)
{
c
.
append
(
unknown_end
unknown_end
+
sizeof
(
unknown_end
)
)
;
}
compressed
.
swap
(
c
)
;
}
else
{
PaddedBytes
c
;
c
.
append
(
header
header
+
sizeof
(
header
)
)
;
if
(
jpeg_codestream
!
=
nullptr
)
{
jxl
:
:
AppendBoxHeader
(
jxl
:
:
MakeBoxType
(
"
jbrd
"
)
jpeg_data
.
size
(
)
false
&
c
)
;
c
.
append
(
jpeg_data
.
data
(
)
jpeg_data
.
data
(
)
+
jpeg_data
.
size
(
)
)
;
}
AppendU32BE
(
add_container
=
=
kCSBF_Single
?
(
compressed
.
size
(
)
+
8
)
:
0
&
c
)
;
c
.
push_back
(
'
j
'
)
;
c
.
push_back
(
'
x
'
)
;
c
.
push_back
(
'
l
'
)
;
c
.
push_back
(
'
c
'
)
;
c
.
append
(
compressed
.
data
(
)
compressed
.
data
(
)
+
compressed
.
size
(
)
)
;
compressed
.
swap
(
c
)
;
}
}
return
compressed
;
}
std
:
:
vector
<
uint8_t
>
DecodeWithAPI
(
JxlDecoder
*
dec
Span
<
const
uint8_t
>
compressed
const
JxlPixelFormat
&
format
)
{
void
*
runner
=
JxlThreadParallelRunnerCreate
(
NULL
JxlThreadParallelRunnerDefaultNumWorkerThreads
(
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetParallelRunner
(
dec
JxlThreadParallelRunner
runner
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_FULL_IMAGE
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
compressed
.
data
(
)
compressed
.
size
(
)
)
)
;
EXPECT_EQ
(
JXL_DEC_BASIC_INFO
JxlDecoderProcessInput
(
dec
)
)
;
size_t
buffer_size
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderImageOutBufferSize
(
dec
&
format
&
buffer_size
)
)
;
JxlBasicInfo
info
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetBasicInfo
(
dec
&
info
)
)
;
std
:
:
vector
<
uint8_t
>
pixels
(
buffer_size
)
;
EXPECT_EQ
(
JXL_DEC_NEED_IMAGE_OUT_BUFFER
JxlDecoderProcessInput
(
dec
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetImageOutBuffer
(
dec
&
format
pixels
.
data
(
)
pixels
.
size
(
)
)
)
;
EXPECT_EQ
(
JXL_DEC_FULL_IMAGE
JxlDecoderProcessInput
(
dec
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderProcessInput
(
dec
)
)
;
JxlThreadParallelRunnerDestroy
(
runner
)
;
return
pixels
;
}
std
:
:
vector
<
uint8_t
>
DecodeWithAPI
(
Span
<
const
uint8_t
>
compressed
const
JxlPixelFormat
&
format
)
{
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
std
:
:
vector
<
uint8_t
>
pixels
=
DecodeWithAPI
(
dec
compressed
format
)
;
JxlDecoderDestroy
(
dec
)
;
return
pixels
;
}
}
}
namespace
{
bool
Near
(
double
expected
double
value
double
max_dist
)
{
double
dist
=
expected
>
value
?
expected
-
value
:
value
-
expected
;
return
dist
<
=
max_dist
;
}
float
LoadBEFloat
(
const
uint8_t
*
p
)
{
uint32_t
u
=
LoadBE32
(
p
)
;
float
result
;
memcpy
(
&
result
&
u
4
)
;
return
result
;
}
float
LoadLEFloat
(
const
uint8_t
*
p
)
{
uint32_t
u
=
LoadLE32
(
p
)
;
float
result
;
memcpy
(
&
result
&
u
4
)
;
return
result
;
}
float
LoadFloat16
(
uint16_t
bits16
)
{
const
uint32_t
sign
=
bits16
>
>
15
;
const
uint32_t
biased_exp
=
(
bits16
>
>
10
)
&
0x1F
;
const
uint32_t
mantissa
=
bits16
&
0x3FF
;
if
(
biased_exp
=
=
0
)
{
const
float
subnormal
=
(
1
.
0f
/
16384
)
*
(
mantissa
*
(
1
.
0f
/
1024
)
)
;
return
sign
?
-
subnormal
:
subnormal
;
}
const
uint32_t
biased_exp32
=
biased_exp
+
(
127
-
15
)
;
const
uint32_t
mantissa32
=
mantissa
<
<
(
23
-
10
)
;
const
uint32_t
bits32
=
(
sign
<
<
31
)
|
(
biased_exp32
<
<
23
)
|
mantissa32
;
float
result
;
memcpy
(
&
result
&
bits32
4
)
;
return
result
;
}
float
LoadLEFloat16
(
const
uint8_t
*
p
)
{
uint16_t
bits16
=
LoadLE16
(
p
)
;
return
LoadFloat16
(
bits16
)
;
}
float
LoadBEFloat16
(
const
uint8_t
*
p
)
{
uint16_t
bits16
=
LoadBE16
(
p
)
;
return
LoadFloat16
(
bits16
)
;
}
size_t
GetPrecision
(
JxlDataType
data_type
)
{
switch
(
data_type
)
{
case
JXL_TYPE_BOOLEAN
:
return
1
;
case
JXL_TYPE_UINT8
:
return
8
;
case
JXL_TYPE_UINT16
:
return
16
;
case
JXL_TYPE_UINT32
:
return
32
;
case
JXL_TYPE_FLOAT
:
return
24
;
case
JXL_TYPE_FLOAT16
:
return
11
;
}
JXL_ASSERT
(
false
)
;
}
size_t
GetDataBits
(
JxlDataType
data_type
)
{
switch
(
data_type
)
{
case
JXL_TYPE_BOOLEAN
:
return
1
;
case
JXL_TYPE_UINT8
:
return
8
;
case
JXL_TYPE_UINT16
:
return
16
;
case
JXL_TYPE_UINT32
:
return
32
;
case
JXL_TYPE_FLOAT
:
return
32
;
case
JXL_TYPE_FLOAT16
:
return
16
;
}
JXL_ASSERT
(
false
)
;
}
std
:
:
vector
<
double
>
ConvertToRGBA32
(
const
uint8_t
*
pixels
size_t
xsize
size_t
ysize
const
JxlPixelFormat
&
format
)
{
std
:
:
vector
<
double
>
result
(
xsize
*
ysize
*
4
)
;
size_t
num_channels
=
format
.
num_channels
;
bool
gray
=
num_channels
=
=
1
|
|
num_channels
=
=
2
;
bool
alpha
=
num_channels
=
=
2
|
|
num_channels
=
=
4
;
size_t
stride
=
xsize
*
jxl
:
:
DivCeil
(
GetDataBits
(
format
.
data_type
)
*
num_channels
jxl
:
:
kBitsPerByte
)
;
if
(
format
.
align
>
1
)
stride
=
jxl
:
:
RoundUpTo
(
stride
format
.
align
)
;
if
(
format
.
data_type
=
=
JXL_TYPE_BOOLEAN
)
{
for
(
size_t
y
=
0
;
y
<
ysize
;
+
+
y
)
{
jxl
:
:
BitReader
br
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
+
stride
*
y
stride
)
)
;
for
(
size_t
x
=
0
;
x
<
xsize
;
+
+
x
)
{
size_t
j
=
(
y
*
xsize
+
x
)
*
4
;
double
r
=
br
.
ReadBits
(
1
)
;
double
g
=
gray
?
r
:
br
.
ReadBits
(
1
)
;
double
b
=
gray
?
r
:
br
.
ReadBits
(
1
)
;
double
a
=
alpha
?
br
.
ReadBits
(
1
)
:
1
;
result
[
j
+
0
]
=
r
;
result
[
j
+
1
]
=
g
;
result
[
j
+
2
]
=
b
;
result
[
j
+
3
]
=
a
;
}
JXL_CHECK
(
br
.
Close
(
)
)
;
}
}
else
if
(
format
.
data_type
=
=
JXL_TYPE_UINT8
)
{
double
mul
=
1
.
0
/
255
.
0
;
for
(
size_t
y
=
0
;
y
<
ysize
;
+
+
y
)
{
for
(
size_t
x
=
0
;
x
<
xsize
;
+
+
x
)
{
size_t
j
=
(
y
*
xsize
+
x
)
*
4
;
size_t
i
=
y
*
stride
+
x
*
num_channels
;
double
r
=
pixels
[
i
]
;
double
g
=
gray
?
r
:
pixels
[
i
+
1
]
;
double
b
=
gray
?
r
:
pixels
[
i
+
2
]
;
double
a
=
alpha
?
pixels
[
i
+
num_channels
-
1
]
:
255
;
result
[
j
+
0
]
=
r
*
mul
;
result
[
j
+
1
]
=
g
*
mul
;
result
[
j
+
2
]
=
b
*
mul
;
result
[
j
+
3
]
=
a
*
mul
;
}
}
}
else
if
(
format
.
data_type
=
=
JXL_TYPE_UINT16
)
{
double
mul
=
1
.
0
/
65535
.
0
;
for
(
size_t
y
=
0
;
y
<
ysize
;
+
+
y
)
{
for
(
size_t
x
=
0
;
x
<
xsize
;
+
+
x
)
{
size_t
j
=
(
y
*
xsize
+
x
)
*
4
;
size_t
i
=
y
*
stride
+
x
*
num_channels
*
2
;
double
r
g
b
a
;
if
(
format
.
endianness
=
=
JXL_BIG_ENDIAN
)
{
r
=
(
pixels
[
i
+
0
]
<
<
8
)
+
pixels
[
i
+
1
]
;
g
=
gray
?
r
:
(
pixels
[
i
+
2
]
<
<
8
)
+
pixels
[
i
+
3
]
;
b
=
gray
?
r
:
(
pixels
[
i
+
4
]
<
<
8
)
+
pixels
[
i
+
5
]
;
a
=
alpha
?
(
pixels
[
i
+
num_channels
*
2
-
2
]
<
<
8
)
+
pixels
[
i
+
num_channels
*
2
-
1
]
:
65535
;
}
else
{
r
=
(
pixels
[
i
+
1
]
<
<
8
)
+
pixels
[
i
+
0
]
;
g
=
gray
?
r
:
(
pixels
[
i
+
3
]
<
<
8
)
+
pixels
[
i
+
2
]
;
b
=
gray
?
r
:
(
pixels
[
i
+
5
]
<
<
8
)
+
pixels
[
i
+
4
]
;
a
=
alpha
?
(
pixels
[
i
+
num_channels
*
2
-
1
]
<
<
8
)
+
pixels
[
i
+
num_channels
*
2
-
2
]
:
65535
;
}
result
[
j
+
0
]
=
r
*
mul
;
result
[
j
+
1
]
=
g
*
mul
;
result
[
j
+
2
]
=
b
*
mul
;
result
[
j
+
3
]
=
a
*
mul
;
}
}
}
else
if
(
format
.
data_type
=
=
JXL_TYPE_UINT32
)
{
double
mul
=
1
.
0
/
4294967295
.
0
;
for
(
size_t
y
=
0
;
y
<
ysize
;
+
+
y
)
{
for
(
size_t
x
=
0
;
x
<
xsize
;
+
+
x
)
{
size_t
j
=
(
y
*
xsize
+
x
)
*
4
;
size_t
i
=
y
*
stride
+
x
*
num_channels
*
4
;
double
r
g
b
a
;
if
(
format
.
endianness
=
=
JXL_BIG_ENDIAN
)
{
r
=
LoadBE32
(
pixels
+
i
)
;
g
=
gray
?
r
:
LoadBE32
(
pixels
+
i
+
4
)
;
b
=
gray
?
r
:
LoadBE32
(
pixels
+
i
+
8
)
;
a
=
alpha
?
LoadBE32
(
pixels
+
i
+
num_channels
*
2
-
4
)
:
4294967295
;
}
else
{
r
=
LoadLE32
(
pixels
+
i
)
;
g
=
gray
?
r
:
LoadLE32
(
pixels
+
i
+
4
)
;
b
=
gray
?
r
:
LoadLE32
(
pixels
+
i
+
8
)
;
a
=
alpha
?
LoadLE32
(
pixels
+
i
+
num_channels
*
2
-
4
)
:
4294967295
;
}
result
[
j
+
0
]
=
r
*
mul
;
result
[
j
+
1
]
=
g
*
mul
;
result
[
j
+
2
]
=
b
*
mul
;
result
[
j
+
3
]
=
a
*
mul
;
}
}
}
else
if
(
format
.
data_type
=
=
JXL_TYPE_FLOAT
)
{
for
(
size_t
y
=
0
;
y
<
ysize
;
+
+
y
)
{
for
(
size_t
x
=
0
;
x
<
xsize
;
+
+
x
)
{
size_t
j
=
(
y
*
xsize
+
x
)
*
4
;
size_t
i
=
y
*
stride
+
x
*
num_channels
*
4
;
double
r
g
b
a
;
if
(
format
.
endianness
=
=
JXL_BIG_ENDIAN
)
{
r
=
LoadBEFloat
(
pixels
+
i
)
;
g
=
gray
?
r
:
LoadBEFloat
(
pixels
+
i
+
4
)
;
b
=
gray
?
r
:
LoadBEFloat
(
pixels
+
i
+
8
)
;
a
=
alpha
?
LoadBEFloat
(
pixels
+
i
+
num_channels
*
4
-
4
)
:
1
.
0
;
}
else
{
r
=
LoadLEFloat
(
pixels
+
i
)
;
g
=
gray
?
r
:
LoadLEFloat
(
pixels
+
i
+
4
)
;
b
=
gray
?
r
:
LoadLEFloat
(
pixels
+
i
+
8
)
;
a
=
alpha
?
LoadLEFloat
(
pixels
+
i
+
num_channels
*
4
-
4
)
:
1
.
0
;
}
result
[
j
+
0
]
=
r
;
result
[
j
+
1
]
=
g
;
result
[
j
+
2
]
=
b
;
result
[
j
+
3
]
=
a
;
}
}
}
else
if
(
format
.
data_type
=
=
JXL_TYPE_FLOAT16
)
{
for
(
size_t
y
=
0
;
y
<
ysize
;
+
+
y
)
{
for
(
size_t
x
=
0
;
x
<
xsize
;
+
+
x
)
{
size_t
j
=
(
y
*
xsize
+
x
)
*
4
;
size_t
i
=
y
*
stride
+
x
*
num_channels
*
2
;
double
r
g
b
a
;
if
(
format
.
endianness
=
=
JXL_BIG_ENDIAN
)
{
r
=
LoadBEFloat16
(
pixels
+
i
)
;
g
=
gray
?
r
:
LoadBEFloat16
(
pixels
+
i
+
2
)
;
b
=
gray
?
r
:
LoadBEFloat16
(
pixels
+
i
+
4
)
;
a
=
alpha
?
LoadBEFloat16
(
pixels
+
i
+
num_channels
*
2
-
2
)
:
1
.
0
;
}
else
{
r
=
LoadLEFloat16
(
pixels
+
i
)
;
g
=
gray
?
r
:
LoadLEFloat16
(
pixels
+
i
+
2
)
;
b
=
gray
?
r
:
LoadLEFloat16
(
pixels
+
i
+
4
)
;
a
=
alpha
?
LoadLEFloat16
(
pixels
+
i
+
num_channels
*
2
-
2
)
:
1
.
0
;
}
result
[
j
+
0
]
=
r
;
result
[
j
+
1
]
=
g
;
result
[
j
+
2
]
=
b
;
result
[
j
+
3
]
=
a
;
}
}
}
else
{
JXL_ASSERT
(
false
)
;
}
return
result
;
}
size_t
ComparePixels
(
const
uint8_t
*
a
const
uint8_t
*
b
size_t
xsize
size_t
ysize
const
JxlPixelFormat
&
format_a
const
JxlPixelFormat
&
format_b
)
{
std
:
:
vector
<
double
>
a_full
=
ConvertToRGBA32
(
a
xsize
ysize
format_a
)
;
std
:
:
vector
<
double
>
b_full
=
ConvertToRGBA32
(
b
xsize
ysize
format_b
)
;
bool
gray_a
=
format_a
.
num_channels
<
3
;
bool
gray_b
=
format_b
.
num_channels
<
3
;
bool
alpha_a
=
!
(
format_a
.
num_channels
&
1
)
;
bool
alpha_b
=
!
(
format_b
.
num_channels
&
1
)
;
size_t
bits_a
=
GetPrecision
(
format_a
.
data_type
)
;
size_t
bits_b
=
GetPrecision
(
format_b
.
data_type
)
;
size_t
bits
=
std
:
:
min
(
bits_a
bits_b
)
;
double
precision
=
0
.
5
/
(
(
1ull
<
<
bits
)
-
1ull
)
;
if
(
format_a
.
data_type
=
=
JXL_TYPE_FLOAT16
|
|
format_b
.
data_type
=
=
JXL_TYPE_FLOAT16
)
{
precision
=
0
.
5
/
(
(
1ull
<
<
(
bits
-
1
)
)
-
1ull
)
;
}
size_t
numdiff
=
0
;
for
(
size_t
y
=
0
;
y
<
ysize
;
y
+
+
)
{
for
(
size_t
x
=
0
;
x
<
xsize
;
x
+
+
)
{
size_t
i
=
(
y
*
xsize
+
x
)
*
4
;
bool
ok
=
true
;
if
(
gray_a
|
|
gray_b
)
{
if
(
!
Near
(
a_full
[
i
+
0
]
b_full
[
i
+
0
]
precision
)
)
ok
=
false
;
if
(
gray_a
&
&
b_full
[
i
+
0
]
!
=
b_full
[
i
+
1
]
&
&
b_full
[
i
+
2
]
!
=
b_full
[
i
+
2
]
)
{
ok
=
false
;
}
}
else
{
if
(
!
Near
(
a_full
[
i
+
0
]
b_full
[
i
+
0
]
precision
)
|
|
!
Near
(
a_full
[
i
+
1
]
b_full
[
i
+
1
]
precision
)
|
|
!
Near
(
a_full
[
i
+
2
]
b_full
[
i
+
2
]
precision
)
)
{
ok
=
false
;
}
}
if
(
alpha_a
&
&
alpha_b
)
{
if
(
!
Near
(
a_full
[
i
+
3
]
b_full
[
i
+
3
]
precision
)
)
ok
=
false
;
}
else
{
if
(
alpha_b
&
&
!
Near
(
1
.
0
b_full
[
i
+
3
]
precision
)
)
ok
=
false
;
}
if
(
!
ok
)
numdiff
+
+
;
}
}
return
numdiff
;
}
}
TEST
(
DecodeTest
JxlSignatureCheckTest
)
{
std
:
:
vector
<
std
:
:
pair
<
int
std
:
:
vector
<
uint8_t
>
>
>
tests
=
{
{
JXL_SIG_INVALID
{
'
a
'
}
}
{
JXL_SIG_INVALID
{
'
a
'
'
b
'
'
c
'
'
d
'
'
e
'
'
f
'
}
}
{
JXL_SIG_NOT_ENOUGH_BYTES
{
}
}
{
JXL_SIG_NOT_ENOUGH_BYTES
{
0xff
}
}
{
JXL_SIG_INVALID
{
0xff
0xD8
}
}
{
JXL_SIG_CODESTREAM
{
0xff
0x0a
}
}
{
JXL_SIG_CONTAINER
{
0
0
0
0xc
'
J
'
'
X
'
'
L
'
'
'
0xD
0xA
0x87
0xA
}
}
{
JXL_SIG_INVALID
{
0
0
0
0xc
'
J
'
'
X
'
'
L
'
'
'
0xD
0xA
0x87
0
}
}
{
JXL_SIG_NOT_ENOUGH_BYTES
{
0
0
0
0xc
'
J
'
'
X
'
'
L
'
'
'
0xD
0xA
0x87
}
}
{
JXL_SIG_NOT_ENOUGH_BYTES
{
0
}
}
}
;
for
(
const
auto
&
test
:
tests
)
{
EXPECT_EQ
(
test
.
first
JxlSignatureCheck
(
test
.
second
.
data
(
)
test
.
second
.
size
(
)
)
)
<
<
"
Where
test
data
is
"
<
<
:
:
testing
:
:
PrintToString
(
test
.
second
)
;
}
}
TEST
(
DecodeTest
DefaultAllocTest
)
{
JxlDecoder
*
dec
=
JxlDecoderCreate
(
nullptr
)
;
EXPECT_NE
(
nullptr
dec
)
;
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
CustomAllocTest
)
{
struct
CalledCounters
{
int
allocs
=
0
;
int
frees
=
0
;
}
counters
;
JxlMemoryManager
mm
;
mm
.
opaque
=
&
counters
;
mm
.
alloc
=
[
]
(
void
*
opaque
size_t
size
)
{
reinterpret_cast
<
CalledCounters
*
>
(
opaque
)
-
>
allocs
+
+
;
return
malloc
(
size
)
;
}
;
mm
.
free
=
[
]
(
void
*
opaque
void
*
address
)
{
reinterpret_cast
<
CalledCounters
*
>
(
opaque
)
-
>
frees
+
+
;
free
(
address
)
;
}
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
&
mm
)
;
EXPECT_NE
(
nullptr
dec
)
;
EXPECT_LE
(
1
counters
.
allocs
)
;
EXPECT_EQ
(
0
counters
.
frees
)
;
JxlDecoderDestroy
(
dec
)
;
EXPECT_LE
(
1
counters
.
frees
)
;
}
TEST
(
DecodeTest
DefaultParallelRunnerTest
)
{
JxlDecoder
*
dec
=
JxlDecoderCreate
(
nullptr
)
;
EXPECT_NE
(
nullptr
dec
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetParallelRunner
(
dec
nullptr
nullptr
)
)
;
JxlDecoderDestroy
(
dec
)
;
}
std
:
:
vector
<
uint8_t
>
GetTestHeader
(
size_t
xsize
size_t
ysize
size_t
bits_per_sample
size_t
orientation
size_t
alpha_bits
bool
xyb_encoded
bool
have_container
bool
metadata_default
bool
insert_extra_box
const
jxl
:
:
PaddedBytes
&
icc_profile
)
{
jxl
:
:
BitWriter
writer
;
jxl
:
:
BitWriter
:
:
Allotment
allotment
(
&
writer
65536
)
;
if
(
have_container
)
{
const
std
:
:
vector
<
uint8_t
>
signature_box
=
{
0
0
0
0xc
'
J
'
'
X
'
'
L
'
'
'
0xd
0xa
0x87
0xa
}
;
const
std
:
:
vector
<
uint8_t
>
filetype_box
=
{
0
0
0
0x14
'
f
'
'
t
'
'
y
'
'
p
'
'
j
'
'
x
'
'
l
'
'
'
0
0
0
0
'
j
'
'
x
'
'
l
'
'
'
}
;
const
std
:
:
vector
<
uint8_t
>
extra_box_header
=
{
0
0
0
0xff
'
t
'
'
e
'
'
s
'
'
t
'
}
;
const
std
:
:
vector
<
uint8_t
>
codestream_box_header
=
{
0
0
0
0xff
'
j
'
'
x
'
'
l
'
'
c
'
}
;
for
(
size_t
i
=
0
;
i
<
signature_box
.
size
(
)
;
i
+
+
)
{
writer
.
Write
(
8
signature_box
[
i
]
)
;
}
for
(
size_t
i
=
0
;
i
<
filetype_box
.
size
(
)
;
i
+
+
)
{
writer
.
Write
(
8
filetype_box
[
i
]
)
;
}
if
(
insert_extra_box
)
{
for
(
size_t
i
=
0
;
i
<
extra_box_header
.
size
(
)
;
i
+
+
)
{
writer
.
Write
(
8
extra_box_header
[
i
]
)
;
}
for
(
size_t
i
=
0
;
i
<
255
-
8
;
i
+
+
)
{
writer
.
Write
(
8
0
)
;
}
}
for
(
size_t
i
=
0
;
i
<
codestream_box_header
.
size
(
)
;
i
+
+
)
{
writer
.
Write
(
8
codestream_box_header
[
i
]
)
;
}
}
writer
.
Write
(
8
0xff
)
;
writer
.
Write
(
8
0x0a
)
;
jxl
:
:
CodecMetadata
metadata
;
EXPECT_TRUE
(
metadata
.
size
.
Set
(
xsize
ysize
)
)
;
EXPECT_TRUE
(
WriteSizeHeader
(
metadata
.
size
&
writer
0
nullptr
)
)
;
if
(
!
metadata_default
)
{
metadata
.
m
.
SetUintSamples
(
bits_per_sample
)
;
metadata
.
m
.
orientation
=
orientation
;
metadata
.
m
.
SetAlphaBits
(
alpha_bits
)
;
metadata
.
m
.
xyb_encoded
=
xyb_encoded
;
if
(
alpha_bits
!
=
0
)
{
metadata
.
m
.
extra_channel_info
[
0
]
.
name
=
"
alpha_test
"
;
}
}
if
(
!
icc_profile
.
empty
(
)
)
{
jxl
:
:
PaddedBytes
copy
=
icc_profile
;
EXPECT_TRUE
(
metadata
.
m
.
color_encoding
.
SetICC
(
std
:
:
move
(
copy
)
)
)
;
}
EXPECT_TRUE
(
jxl
:
:
Bundle
:
:
Write
(
metadata
.
m
&
writer
0
nullptr
)
)
;
metadata
.
transform_data
.
nonserialized_xyb_encoded
=
metadata
.
m
.
xyb_encoded
;
EXPECT_TRUE
(
jxl
:
:
Bundle
:
:
Write
(
metadata
.
transform_data
&
writer
0
nullptr
)
)
;
if
(
!
icc_profile
.
empty
(
)
)
{
EXPECT_TRUE
(
metadata
.
m
.
color_encoding
.
WantICC
(
)
)
;
EXPECT_TRUE
(
jxl
:
:
WriteICC
(
icc_profile
&
writer
0
nullptr
)
)
;
}
writer
.
ZeroPadToByte
(
)
;
ReclaimAndCharge
(
&
writer
&
allotment
0
nullptr
)
;
return
std
:
:
vector
<
uint8_t
>
(
writer
.
GetSpan
(
)
.
data
(
)
writer
.
GetSpan
(
)
.
data
(
)
+
writer
.
GetSpan
(
)
.
size
(
)
)
;
}
TEST
(
DecodeTest
BasicInfoTest
)
{
size_t
xsize
[
2
]
=
{
50
33
}
;
size_t
ysize
[
2
]
=
{
50
77
}
;
size_t
bits_per_sample
[
2
]
=
{
8
23
}
;
size_t
orientation
[
2
]
=
{
3
5
}
;
size_t
alpha_bits
[
2
]
=
{
0
8
}
;
size_t
have_container
[
2
]
=
{
0
1
}
;
bool
xyb_encoded
=
false
;
std
:
:
vector
<
std
:
:
vector
<
uint8_t
>
>
test_samples
;
test_samples
.
push_back
(
GetTestHeader
(
xsize
[
0
]
ysize
[
0
]
bits_per_sample
[
0
]
orientation
[
0
]
alpha_bits
[
0
]
xyb_encoded
have_container
[
0
]
false
false
{
}
)
)
;
test_samples
.
push_back
(
GetTestHeader
(
xsize
[
1
]
ysize
[
1
]
bits_per_sample
[
1
]
orientation
[
1
]
alpha_bits
[
1
]
xyb_encoded
have_container
[
1
]
false
false
{
}
)
)
;
for
(
size_t
i
=
0
;
i
<
test_samples
.
size
(
)
;
+
+
i
)
{
const
std
:
:
vector
<
uint8_t
>
&
data
=
test_samples
[
i
]
;
for
(
size_t
size
=
0
;
size
<
=
data
.
size
(
)
;
+
+
size
)
{
JxlDecoder
*
dec
=
JxlDecoderCreate
(
nullptr
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
)
)
;
const
uint8_t
*
next_in
=
data
.
data
(
)
;
size_t
avail_in
=
size
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
next_in
avail_in
)
)
;
JxlDecoderStatus
status
=
JxlDecoderProcessInput
(
dec
)
;
JxlBasicInfo
info
;
bool
have_basic_info
=
!
JxlDecoderGetBasicInfo
(
dec
&
info
)
;
if
(
size
=
=
data
.
size
(
)
)
{
EXPECT_EQ
(
JXL_DEC_BASIC_INFO
status
)
;
EXPECT_EQ
(
true
have_basic_info
)
;
EXPECT_EQ
(
have_container
[
i
]
info
.
have_container
)
;
EXPECT_EQ
(
alpha_bits
[
i
]
info
.
alpha_bits
)
;
if
(
orientation
[
i
]
>
=
5
)
{
EXPECT_EQ
(
xsize
[
i
]
info
.
ysize
)
;
EXPECT_EQ
(
ysize
[
i
]
info
.
xsize
)
;
}
else
{
EXPECT_EQ
(
xsize
[
i
]
info
.
xsize
)
;
EXPECT_EQ
(
ysize
[
i
]
info
.
ysize
)
;
}
EXPECT_EQ
(
1
info
.
orientation
)
;
EXPECT_EQ
(
3
info
.
num_color_channels
)
;
if
(
alpha_bits
[
i
]
!
=
0
)
{
EXPECT_EQ
(
1
info
.
num_extra_channels
)
;
JxlExtraChannelInfo
extra
;
EXPECT_EQ
(
0
JxlDecoderGetExtraChannelInfo
(
dec
0
&
extra
)
)
;
EXPECT_EQ
(
alpha_bits
[
i
]
extra
.
bits_per_sample
)
;
EXPECT_EQ
(
JXL_CHANNEL_ALPHA
extra
.
type
)
;
EXPECT_EQ
(
0
extra
.
alpha_associated
)
;
EXPECT_EQ
(
10
extra
.
name_length
)
;
char
name
[
11
]
;
EXPECT_EQ
(
0
JxlDecoderGetExtraChannelName
(
dec
0
name
sizeof
(
name
)
)
)
;
EXPECT_EQ
(
std
:
:
string
(
"
alpha_test
"
)
std
:
:
string
(
name
)
)
;
}
else
{
EXPECT_EQ
(
0
info
.
num_extra_channels
)
;
}
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderProcessInput
(
dec
)
)
;
}
else
{
if
(
size
+
2
<
data
.
size
(
)
)
{
EXPECT_EQ
(
false
have_basic_info
)
;
EXPECT_EQ
(
JXL_DEC_NEED_MORE_INPUT
status
)
;
}
}
EXPECT_EQ
(
JXL_DEC_ERROR
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
)
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
)
)
;
JxlDecoderDestroy
(
dec
)
;
}
}
}
TEST
(
DecodeTest
BufferSizeTest
)
{
size_t
xsize
=
33
;
size_t
ysize
=
77
;
size_t
bits_per_sample
=
8
;
size_t
orientation
=
1
;
size_t
alpha_bits
=
8
;
bool
have_container
=
false
;
bool
xyb_encoded
=
false
;
std
:
:
vector
<
uint8_t
>
header
=
GetTestHeader
(
xsize
ysize
bits_per_sample
orientation
alpha_bits
xyb_encoded
have_container
false
false
{
}
)
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
nullptr
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
)
)
;
const
uint8_t
*
next_in
=
header
.
data
(
)
;
size_t
avail_in
=
header
.
size
(
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
next_in
avail_in
)
)
;
JxlDecoderStatus
status
=
JxlDecoderProcessInput
(
dec
)
;
EXPECT_EQ
(
JXL_DEC_BASIC_INFO
status
)
;
JxlBasicInfo
info
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetBasicInfo
(
dec
&
info
)
)
;
EXPECT_EQ
(
xsize
info
.
xsize
)
;
EXPECT_EQ
(
ysize
info
.
ysize
)
;
JxlPixelFormat
format
=
{
4
JXL_TYPE_UINT8
JXL_LITTLE_ENDIAN
0
}
;
size_t
image_out_size
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderImageOutBufferSize
(
dec
&
format
&
image_out_size
)
)
;
EXPECT_EQ
(
xsize
*
ysize
*
4
image_out_size
)
;
size_t
dc_out_size
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderDCOutBufferSize
(
dec
&
format
&
dc_out_size
)
)
;
EXPECT_EQ
(
5
*
10
*
4
dc_out_size
)
;
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
BasicInfoSizeHintTest
)
{
size_t
xsize
=
50
;
size_t
ysize
=
50
;
size_t
bits_per_sample
=
16
;
size_t
orientation
=
1
;
size_t
alpha_bits
=
0
;
bool
xyb_encoded
=
false
;
std
:
:
vector
<
uint8_t
>
data
=
GetTestHeader
(
xsize
ysize
bits_per_sample
orientation
alpha_bits
xyb_encoded
true
false
true
{
}
)
;
JxlDecoderStatus
status
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
nullptr
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
)
)
;
size_t
hint0
=
JxlDecoderSizeHintBasicInfo
(
dec
)
;
EXPECT_LT
(
hint0
data
.
size
(
)
)
;
const
uint8_t
*
next_in
=
data
.
data
(
)
;
size_t
avail_in
=
std
:
:
min
(
hint0
data
.
size
(
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
next_in
avail_in
)
)
;
status
=
JxlDecoderProcessInput
(
dec
)
;
EXPECT_EQ
(
JXL_DEC_NEED_MORE_INPUT
status
)
;
EXPECT_EQ
(
false
!
JxlDecoderGetBasicInfo
(
dec
nullptr
)
)
;
size_t
num_read
=
avail_in
-
JxlDecoderReleaseInput
(
dec
)
;
EXPECT_LT
(
num_read
data
.
size
(
)
)
;
size_t
hint1
=
JxlDecoderSizeHintBasicInfo
(
dec
)
;
EXPECT_GT
(
hint1
+
num_read
hint0
)
;
avail_in
=
std
:
:
min
<
size_t
>
(
hint1
data
.
size
(
)
-
num_read
)
;
next_in
+
=
num_read
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
next_in
avail_in
)
)
;
status
=
JxlDecoderProcessInput
(
dec
)
;
EXPECT_EQ
(
JXL_DEC_BASIC_INFO
status
)
;
JxlBasicInfo
info
;
EXPECT_EQ
(
true
!
JxlDecoderGetBasicInfo
(
dec
&
info
)
)
;
EXPECT_EQ
(
1
info
.
have_container
)
;
EXPECT_EQ
(
xsize
info
.
xsize
)
;
EXPECT_EQ
(
ysize
info
.
ysize
)
;
EXPECT_EQ
(
orientation
info
.
orientation
)
;
EXPECT_EQ
(
bits_per_sample
info
.
bits_per_sample
)
;
JxlDecoderDestroy
(
dec
)
;
}
std
:
:
vector
<
uint8_t
>
GetIccTestHeader
(
const
jxl
:
:
PaddedBytes
&
icc_profile
bool
xyb_encoded
)
{
size_t
xsize
=
50
;
size_t
ysize
=
50
;
size_t
bits_per_sample
=
16
;
size_t
orientation
=
1
;
size_t
alpha_bits
=
0
;
return
GetTestHeader
(
xsize
ysize
bits_per_sample
orientation
alpha_bits
xyb_encoded
false
false
false
icc_profile
)
;
}
TEST
(
DecodeTest
IccProfileTestOriginal
)
{
jxl
:
:
PaddedBytes
icc_profile
=
GetIccTestProfile
(
)
;
bool
xyb_encoded
=
false
;
std
:
:
vector
<
uint8_t
>
data
=
GetIccTestHeader
(
icc_profile
xyb_encoded
)
;
JxlPixelFormat
format
=
{
4
JXL_TYPE_FLOAT
JXL_LITTLE_ENDIAN
0
}
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
nullptr
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_COLOR_ENCODING
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
data
.
data
(
)
data
.
size
(
)
)
)
;
EXPECT_EQ
(
JXL_DEC_BASIC_INFO
JxlDecoderProcessInput
(
dec
)
)
;
JxlBasicInfo
info
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetBasicInfo
(
dec
&
info
)
)
;
EXPECT_EQ
(
JXL_TRUE
info
.
uses_original_profile
)
;
EXPECT_EQ
(
JXL_DEC_COLOR_ENCODING
JxlDecoderProcessInput
(
dec
)
)
;
EXPECT_EQ
(
JXL_DEC_ERROR
JxlDecoderGetColorAsEncodedProfile
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_ORIGINAL
nullptr
)
)
;
size_t
dec_profile_size
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetICCProfileSize
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_ORIGINAL
&
dec_profile_size
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetICCProfileSize
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_ORIGINAL
nullptr
)
)
;
EXPECT_EQ
(
icc_profile
.
size
(
)
dec_profile_size
)
;
if
(
icc_profile
.
size
(
)
=
=
dec_profile_size
)
{
jxl
:
:
PaddedBytes
icc_profile2
(
icc_profile
.
size
(
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetColorAsICCProfile
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_ORIGINAL
icc_profile2
.
data
(
)
icc_profile2
.
size
(
)
)
)
;
EXPECT_EQ
(
icc_profile
icc_profile2
)
;
}
EXPECT_EQ
(
JXL_DEC_ERROR
JxlDecoderGetColorAsEncodedProfile
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_DATA
nullptr
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetICCProfileSize
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_DATA
&
dec_profile_size
)
)
;
EXPECT_EQ
(
icc_profile
.
size
(
)
dec_profile_size
)
;
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
IccProfileTestXybEncoded
)
{
jxl
:
:
PaddedBytes
icc_profile
=
GetIccTestProfile
(
)
;
bool
xyb_encoded
=
true
;
std
:
:
vector
<
uint8_t
>
data
=
GetIccTestHeader
(
icc_profile
xyb_encoded
)
;
JxlPixelFormat
format
=
{
4
JXL_TYPE_FLOAT
JXL_LITTLE_ENDIAN
0
}
;
JxlPixelFormat
format_int
=
{
4
JXL_TYPE_UINT8
JXL_LITTLE_ENDIAN
0
}
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
nullptr
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_COLOR_ENCODING
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
data
.
data
(
)
data
.
size
(
)
)
)
;
EXPECT_EQ
(
JXL_DEC_BASIC_INFO
JxlDecoderProcessInput
(
dec
)
)
;
JxlBasicInfo
info
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetBasicInfo
(
dec
&
info
)
)
;
EXPECT_EQ
(
JXL_FALSE
info
.
uses_original_profile
)
;
EXPECT_EQ
(
JXL_DEC_COLOR_ENCODING
JxlDecoderProcessInput
(
dec
)
)
;
EXPECT_EQ
(
JXL_DEC_ERROR
JxlDecoderGetColorAsEncodedProfile
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_ORIGINAL
nullptr
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetICCProfileSize
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_ORIGINAL
nullptr
)
)
;
size_t
dec_profile_size
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetICCProfileSize
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_ORIGINAL
&
dec_profile_size
)
)
;
EXPECT_EQ
(
icc_profile
.
size
(
)
dec_profile_size
)
;
if
(
icc_profile
.
size
(
)
=
=
dec_profile_size
)
{
jxl
:
:
PaddedBytes
icc_profile2
(
icc_profile
.
size
(
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetColorAsICCProfile
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_ORIGINAL
icc_profile2
.
data
(
)
icc_profile2
.
size
(
)
)
)
;
EXPECT_EQ
(
icc_profile
icc_profile2
)
;
}
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetColorAsEncodedProfile
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_DATA
nullptr
)
)
;
JxlColorEncoding
pixel_encoding
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetColorAsEncodedProfile
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_DATA
&
pixel_encoding
)
)
;
EXPECT_EQ
(
JXL_PRIMARIES_SRGB
pixel_encoding
.
primaries
)
;
EXPECT_EQ
(
JXL_TRANSFER_FUNCTION_LINEAR
pixel_encoding
.
transfer_function
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetColorAsEncodedProfile
(
dec
&
format_int
JXL_COLOR_PROFILE_TARGET_DATA
&
pixel_encoding
)
)
;
EXPECT_EQ
(
JXL_PRIMARIES_SRGB
pixel_encoding
.
primaries
)
;
EXPECT_EQ
(
JXL_TRANSFER_FUNCTION_SRGB
pixel_encoding
.
transfer_function
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetICCProfileSize
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_DATA
&
dec_profile_size
)
)
;
EXPECT_NE
(
0
dec_profile_size
)
;
if
(
0
!
=
dec_profile_size
)
{
jxl
:
:
PaddedBytes
icc_profile2
(
dec_profile_size
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetColorAsICCProfile
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_DATA
icc_profile2
.
data
(
)
icc_profile2
.
size
(
)
)
)
;
EXPECT_NE
(
icc_profile
icc_profile2
)
;
}
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
ICCPartialTest
)
{
jxl
:
:
PaddedBytes
icc_profile
=
GetIccTestProfile
(
)
;
std
:
:
vector
<
uint8_t
>
data
=
GetIccTestHeader
(
icc_profile
false
)
;
JxlPixelFormat
format
=
{
4
JXL_TYPE_UINT8
JXL_LITTLE_ENDIAN
0
}
;
const
uint8_t
*
next_in
=
data
.
data
(
)
;
size_t
avail_in
=
0
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
nullptr
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_COLOR_ENCODING
)
)
;
bool
seen_basic_info
=
false
;
bool
seen_color_encoding
=
false
;
size_t
total_size
=
0
;
for
(
;
;
)
{
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
next_in
avail_in
)
)
;
JxlDecoderStatus
status
=
JxlDecoderProcessInput
(
dec
)
;
size_t
remaining
=
JxlDecoderReleaseInput
(
dec
)
;
EXPECT_LE
(
remaining
avail_in
)
;
next_in
+
=
avail_in
-
remaining
;
avail_in
=
remaining
;
if
(
status
=
=
JXL_DEC_NEED_MORE_INPUT
)
{
if
(
total_size
>
=
data
.
size
(
)
)
{
FAIL
(
)
;
break
;
}
size_t
increment
=
1
;
if
(
total_size
+
increment
>
data
.
size
(
)
)
{
increment
=
data
.
size
(
)
-
total_size
;
}
total_size
+
=
increment
;
avail_in
+
=
increment
;
}
else
if
(
status
=
=
JXL_DEC_BASIC_INFO
)
{
EXPECT_FALSE
(
seen_basic_info
)
;
seen_basic_info
=
true
;
}
else
if
(
status
=
=
JXL_DEC_COLOR_ENCODING
)
{
EXPECT_TRUE
(
seen_basic_info
)
;
EXPECT_FALSE
(
seen_color_encoding
)
;
seen_color_encoding
=
true
;
size_t
dec_profile_size
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetICCProfileSize
(
dec
&
format
JXL_COLOR_PROFILE_TARGET_ORIGINAL
&
dec_profile_size
)
)
;
EXPECT_EQ
(
icc_profile
.
size
(
)
dec_profile_size
)
;
}
else
if
(
status
=
=
JXL_DEC_SUCCESS
)
{
EXPECT_TRUE
(
seen_color_encoding
)
;
break
;
}
else
{
FAIL
(
)
;
break
;
}
}
EXPECT_TRUE
(
seen_basic_info
)
;
EXPECT_TRUE
(
seen_color_encoding
)
;
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
PixelTest
)
{
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
for
(
int
include_alpha
=
0
;
include_alpha
<
=
1
;
include_alpha
+
+
)
{
uint32_t
orig_channels
=
include_alpha
?
4
:
3
;
for
(
size_t
box
=
0
;
box
<
kCSBF_NUM_ENTRIES
;
+
+
box
)
{
CodeStreamBoxFormat
add_container
=
(
CodeStreamBoxFormat
)
box
;
size_t
xsize
=
123
ysize
=
77
;
size_t
num_pixels
=
xsize
*
ysize
;
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
orig_channels
0
)
;
JxlPixelFormat
format_orig
=
{
orig_channels
JXL_TYPE_UINT16
JXL_BIG_ENDIAN
0
}
;
jxl
:
:
CompressParams
cparams
;
cparams
.
SetLossless
(
)
;
jxl
:
:
PaddedBytes
compressed
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
orig_channels
cparams
add_container
false
)
;
jxl
:
:
PaddedBytes
compressed_with_preview
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
orig_channels
cparams
add_container
true
)
;
for
(
int
big_endian
=
0
;
big_endian
<
=
1
;
+
+
big_endian
)
{
JxlEndianness
endianness
=
big_endian
?
JXL_BIG_ENDIAN
:
JXL_LITTLE_ENDIAN
;
for
(
uint32_t
channels
=
3
;
channels
<
=
orig_channels
;
+
+
channels
)
{
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_UINT8
endianness
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
dec
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
num_pixels
*
channels
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_UINT16
endianness
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
dec
jxl
:
:
Span
<
const
uint8_t
>
(
compressed_with_preview
.
data
(
)
compressed_with_preview
.
size
(
)
)
format
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
num_pixels
*
channels
*
2
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
#
if
0
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_UINT32
endianness
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
dec
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
num_pixels
*
channels
*
4
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
#
endif
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_FLOAT
endianness
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
dec
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
num_pixels
*
channels
*
4
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_FLOAT16
endianness
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
dec
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
num_pixels
*
channels
*
2
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
}
}
}
}
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
PixelTestWithICCProfileLossless
)
{
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
size_t
xsize
=
123
ysize
=
77
;
size_t
num_pixels
=
xsize
*
ysize
;
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
4
0
)
;
JxlPixelFormat
format_orig
=
{
4
JXL_TYPE_UINT16
JXL_BIG_ENDIAN
0
}
;
jxl
:
:
CompressParams
cparams
;
cparams
.
SetLossless
(
)
;
jxl
:
:
PaddedBytes
compressed
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
4
cparams
kCSBF_None
false
true
)
;
for
(
uint32_t
channels
=
3
;
channels
<
=
4
;
+
+
channels
)
{
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_UINT8
JXL_LITTLE_ENDIAN
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
dec
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
num_pixels
*
channels
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_UINT16
JXL_LITTLE_ENDIAN
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
dec
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
num_pixels
*
channels
*
2
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_FLOAT
JXL_LITTLE_ENDIAN
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
dec
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
num_pixels
*
channels
*
4
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
}
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
PixelTestWithICCProfileLossy
)
{
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
size_t
xsize
=
123
ysize
=
77
;
size_t
num_pixels
=
xsize
*
ysize
;
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
3
0
)
;
JxlPixelFormat
format_orig
=
{
3
JXL_TYPE_UINT16
JXL_BIG_ENDIAN
0
}
;
jxl
:
:
CompressParams
cparams
;
jxl
:
:
PaddedBytes
compressed
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
3
cparams
kCSBF_None
false
true
)
;
uint32_t
channels
=
3
;
JxlPixelFormat
format
=
{
channels
JXL_TYPE_FLOAT
JXL_LITTLE_ENDIAN
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
dec
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
num_pixels
*
channels
*
4
pixels2
.
size
(
)
)
;
jxl
:
:
ColorEncoding
color_encoding0
;
EXPECT_TRUE
(
color_encoding0
.
SetICC
(
GetIccTestProfile
(
)
)
)
;
jxl
:
:
Span
<
const
uint8_t
>
span0
(
pixels
.
data
(
)
pixels
.
size
(
)
)
;
jxl
:
:
CodecInOut
io0
;
io0
.
SetSize
(
xsize
ysize
)
;
EXPECT_TRUE
(
ConvertFromExternal
(
span0
xsize
ysize
color_encoding0
false
false
16
format_orig
.
endianness
false
nullptr
&
io0
.
Main
(
)
)
)
;
jxl
:
:
ColorEncoding
color_encoding1
=
jxl
:
:
ColorEncoding
:
:
LinearSRGB
(
false
)
;
jxl
:
:
Span
<
const
uint8_t
>
span1
(
pixels2
.
data
(
)
pixels2
.
size
(
)
)
;
jxl
:
:
CodecInOut
io1
;
io1
.
SetSize
(
xsize
ysize
)
;
EXPECT_TRUE
(
ConvertFromExternal
(
span1
xsize
ysize
color_encoding1
false
false
32
format
.
endianness
false
nullptr
&
io1
.
Main
(
)
)
)
;
jxl
:
:
ButteraugliParams
ba
;
EXPECT_LE
(
ButteraugliDistance
(
io0
io1
ba
nullptr
nullptr
)
2
.
0f
)
;
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
PixelTestOpaqueSrgbLossy
)
{
for
(
unsigned
channels
=
3
;
channels
<
=
4
;
channels
+
+
)
{
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
size_t
xsize
=
123
ysize
=
77
;
size_t
num_pixels
=
xsize
*
ysize
;
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
3
0
)
;
JxlPixelFormat
format_orig
=
{
3
JXL_TYPE_UINT16
JXL_BIG_ENDIAN
0
}
;
jxl
:
:
CompressParams
cparams
;
jxl
:
:
PaddedBytes
compressed
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
3
cparams
kCSBF_None
false
false
)
;
JxlPixelFormat
format
=
{
channels
JXL_TYPE_UINT8
JXL_LITTLE_ENDIAN
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
dec
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
num_pixels
*
channels
pixels2
.
size
(
)
)
;
jxl
:
:
ColorEncoding
color_encoding0
=
jxl
:
:
ColorEncoding
:
:
SRGB
(
false
)
;
jxl
:
:
Span
<
const
uint8_t
>
span0
(
pixels
.
data
(
)
pixels
.
size
(
)
)
;
jxl
:
:
CodecInOut
io0
;
io0
.
SetSize
(
xsize
ysize
)
;
EXPECT_TRUE
(
ConvertFromExternal
(
span0
xsize
ysize
color_encoding0
false
false
16
format_orig
.
endianness
false
nullptr
&
io0
.
Main
(
)
)
)
;
jxl
:
:
ColorEncoding
color_encoding1
=
jxl
:
:
ColorEncoding
:
:
SRGB
(
false
)
;
jxl
:
:
Span
<
const
uint8_t
>
span1
(
pixels2
.
data
(
)
pixels2
.
size
(
)
)
;
jxl
:
:
CodecInOut
io1
;
if
(
channels
=
=
4
)
{
io1
.
metadata
.
m
.
SetAlphaBits
(
8
)
;
io1
.
SetSize
(
xsize
ysize
)
;
EXPECT_TRUE
(
ConvertFromExternal
(
span1
xsize
ysize
color_encoding1
true
false
8
format
.
endianness
false
nullptr
&
io1
.
Main
(
)
)
)
;
io1
.
metadata
.
m
.
SetAlphaBits
(
0
)
;
io1
.
Main
(
)
.
ClearExtraChannels
(
)
;
}
else
{
EXPECT_TRUE
(
ConvertFromExternal
(
span1
xsize
ysize
color_encoding1
false
false
8
format
.
endianness
false
nullptr
&
io1
.
Main
(
)
)
)
;
}
jxl
:
:
ButteraugliParams
ba
;
EXPECT_LE
(
ButteraugliDistance
(
io0
io1
ba
nullptr
nullptr
)
2
.
0f
)
;
JxlDecoderDestroy
(
dec
)
;
}
}
TEST
(
DecodeTest
PixelTestOpaqueSrgbLossyNoise
)
{
for
(
unsigned
channels
=
3
;
channels
<
=
4
;
channels
+
+
)
{
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
size_t
xsize
=
512
ysize
=
300
;
size_t
num_pixels
=
xsize
*
ysize
;
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
3
0
)
;
JxlPixelFormat
format_orig
=
{
3
JXL_TYPE_UINT16
JXL_BIG_ENDIAN
0
}
;
jxl
:
:
CompressParams
cparams
;
cparams
.
noise
=
jxl
:
:
Override
:
:
kOn
;
jxl
:
:
PaddedBytes
compressed
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
3
cparams
kCSBF_None
false
false
)
;
JxlPixelFormat
format
=
{
channels
JXL_TYPE_UINT8
JXL_LITTLE_ENDIAN
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
dec
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
JxlDecoderReset
(
dec
)
;
EXPECT_EQ
(
num_pixels
*
channels
pixels2
.
size
(
)
)
;
jxl
:
:
ColorEncoding
color_encoding0
=
jxl
:
:
ColorEncoding
:
:
SRGB
(
false
)
;
jxl
:
:
Span
<
const
uint8_t
>
span0
(
pixels
.
data
(
)
pixels
.
size
(
)
)
;
jxl
:
:
CodecInOut
io0
;
io0
.
SetSize
(
xsize
ysize
)
;
EXPECT_TRUE
(
ConvertFromExternal
(
span0
xsize
ysize
color_encoding0
false
false
16
format_orig
.
endianness
false
nullptr
&
io0
.
Main
(
)
)
)
;
jxl
:
:
ColorEncoding
color_encoding1
=
jxl
:
:
ColorEncoding
:
:
SRGB
(
false
)
;
jxl
:
:
Span
<
const
uint8_t
>
span1
(
pixels2
.
data
(
)
pixels2
.
size
(
)
)
;
jxl
:
:
CodecInOut
io1
;
if
(
channels
=
=
4
)
{
io1
.
metadata
.
m
.
SetAlphaBits
(
8
)
;
io1
.
SetSize
(
xsize
ysize
)
;
EXPECT_TRUE
(
ConvertFromExternal
(
span1
xsize
ysize
color_encoding1
true
false
8
format
.
endianness
false
nullptr
&
io1
.
Main
(
)
)
)
;
io1
.
metadata
.
m
.
SetAlphaBits
(
0
)
;
io1
.
Main
(
)
.
ClearExtraChannels
(
)
;
}
else
{
EXPECT_TRUE
(
ConvertFromExternal
(
span1
xsize
ysize
color_encoding1
false
false
8
format
.
endianness
false
nullptr
&
io1
.
Main
(
)
)
)
;
}
jxl
:
:
ButteraugliParams
ba
;
EXPECT_LE
(
ButteraugliDistance
(
io0
io1
ba
nullptr
nullptr
)
2
.
0f
)
;
JxlDecoderDestroy
(
dec
)
;
}
}
TEST
(
DecodeTest
GrayscaleTest
)
{
size_t
xsize
=
123
ysize
=
77
;
size_t
num_pixels
=
xsize
*
ysize
;
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
2
0
)
;
JxlPixelFormat
format_orig
=
{
2
JXL_TYPE_UINT16
JXL_BIG_ENDIAN
0
}
;
jxl
:
:
CompressParams
cparams
;
cparams
.
SetLossless
(
)
;
jxl
:
:
PaddedBytes
compressed
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
2
cparams
kCSBF_None
true
)
;
for
(
int
big_endian
=
0
;
big_endian
<
=
1
;
+
+
big_endian
)
{
JxlEndianness
endianness
=
big_endian
?
JXL_BIG_ENDIAN
:
JXL_LITTLE_ENDIAN
;
for
(
uint32_t
channels
=
1
;
channels
<
=
4
;
+
+
channels
)
{
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_UINT8
endianness
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
EXPECT_EQ
(
num_pixels
*
channels
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_UINT16
endianness
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
EXPECT_EQ
(
num_pixels
*
channels
*
2
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
#
if
0
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_UINT32
endianness
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
EXPECT_EQ
(
num_pixels
*
channels
*
4
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
#
endif
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_FLOAT
endianness
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
EXPECT_EQ
(
num_pixels
*
channels
*
4
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
{
JxlPixelFormat
format
=
{
channels
JXL_TYPE_FLOAT16
endianness
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
EXPECT_EQ
(
num_pixels
*
channels
*
2
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
}
}
}
void
TestPartialStream
(
bool
reconstructible_jpeg
)
{
size_t
xsize
=
123
ysize
=
77
;
uint32_t
channels
=
4
;
if
(
reconstructible_jpeg
)
{
channels
=
3
;
}
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
channels
0
)
;
JxlPixelFormat
format_orig
=
{
channels
JXL_TYPE_UINT16
JXL_BIG_ENDIAN
0
}
;
jxl
:
:
CompressParams
cparams
;
if
(
reconstructible_jpeg
)
{
cparams
.
color_transform
=
jxl
:
:
ColorTransform
:
:
kNone
;
}
else
{
cparams
.
SetLossless
(
)
;
}
std
:
:
vector
<
uint8_t
>
pixels2
;
pixels2
.
resize
(
pixels
.
size
(
)
)
;
jxl
:
:
PaddedBytes
jpeg_output
(
64
)
;
size_t
used_jpeg_output
=
0
;
std
:
:
vector
<
jxl
:
:
PaddedBytes
>
codestreams
(
kCSBF_NUM_ENTRIES
)
;
std
:
:
vector
<
jxl
:
:
PaddedBytes
>
jpeg_codestreams
(
kCSBF_NUM_ENTRIES
)
;
for
(
size_t
i
=
0
;
i
<
kCSBF_NUM_ENTRIES
;
+
+
i
)
{
CodeStreamBoxFormat
add_container
=
(
CodeStreamBoxFormat
)
i
;
codestreams
[
i
]
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
channels
cparams
add_container
true
false
reconstructible_jpeg
?
&
jpeg_codestreams
[
i
]
:
nullptr
)
;
}
std
:
:
vector
<
size_t
>
increments
=
{
1
3
17
23
120
700
1050
}
;
for
(
size_t
index
=
0
;
index
<
increments
.
size
(
)
;
index
+
+
)
{
for
(
size_t
i
=
0
;
i
<
kCSBF_NUM_ENTRIES
;
+
+
i
)
{
if
(
reconstructible_jpeg
&
&
(
CodeStreamBoxFormat
)
i
=
=
CodeStreamBoxFormat
:
:
kCSBF_None
)
{
continue
;
}
const
jxl
:
:
PaddedBytes
&
data
=
codestreams
[
i
]
;
const
uint8_t
*
next_in
=
data
.
data
(
)
;
size_t
avail_in
=
0
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
nullptr
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_FULL_IMAGE
|
JXL_DEC_JPEG_RECONSTRUCTION
)
)
;
bool
seen_basic_info
=
false
;
bool
seen_full_image
=
false
;
bool
seen_jpeg_recon
=
false
;
size_t
total_size
=
0
;
for
(
;
;
)
{
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
next_in
avail_in
)
)
;
JxlDecoderStatus
status
=
JxlDecoderProcessInput
(
dec
)
;
size_t
remaining
=
JxlDecoderReleaseInput
(
dec
)
;
EXPECT_LE
(
remaining
avail_in
)
;
next_in
+
=
avail_in
-
remaining
;
avail_in
=
remaining
;
if
(
status
=
=
JXL_DEC_NEED_MORE_INPUT
)
{
if
(
total_size
>
=
data
.
size
(
)
)
{
FAIL
(
)
;
break
;
}
size_t
increment
=
increments
[
index
]
;
if
(
total_size
+
increment
>
data
.
size
(
)
)
{
increment
=
data
.
size
(
)
-
total_size
;
}
total_size
+
=
increment
;
avail_in
+
=
increment
;
}
else
if
(
status
=
=
JXL_DEC_BASIC_INFO
)
{
EXPECT_FALSE
(
seen_basic_info
)
;
if
(
seen_basic_info
)
break
;
seen_basic_info
=
true
;
JxlBasicInfo
info
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetBasicInfo
(
dec
&
info
)
)
;
EXPECT_EQ
(
info
.
xsize
xsize
)
;
EXPECT_EQ
(
info
.
ysize
ysize
)
;
}
else
if
(
status
=
=
JXL_DEC_JPEG_RECONSTRUCTION
)
{
EXPECT_FALSE
(
seen_basic_info
)
;
EXPECT_FALSE
(
seen_full_image
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetJPEGBuffer
(
dec
jpeg_output
.
data
(
)
jpeg_output
.
size
(
)
)
)
;
seen_jpeg_recon
=
true
;
}
else
if
(
status
=
=
JXL_DEC_JPEG_NEED_MORE_OUTPUT
)
{
EXPECT_TRUE
(
seen_jpeg_recon
)
;
used_jpeg_output
=
jpeg_output
.
size
(
)
-
JxlDecoderReleaseJPEGBuffer
(
dec
)
;
jpeg_output
.
resize
(
jpeg_output
.
size
(
)
*
2
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetJPEGBuffer
(
dec
jpeg_output
.
data
(
)
+
used_jpeg_output
jpeg_output
.
size
(
)
-
used_jpeg_output
)
)
;
}
else
if
(
status
=
=
JXL_DEC_NEED_IMAGE_OUT_BUFFER
)
{
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetImageOutBuffer
(
dec
&
format_orig
pixels2
.
data
(
)
pixels2
.
size
(
)
)
)
;
}
else
if
(
status
=
=
JXL_DEC_FULL_IMAGE
)
{
EXPECT_FALSE
(
seen_full_image
)
;
if
(
seen_full_image
)
break
;
EXPECT_TRUE
(
seen_basic_info
)
;
seen_full_image
=
true
;
if
(
reconstructible_jpeg
)
{
used_jpeg_output
=
jpeg_output
.
size
(
)
-
JxlDecoderReleaseJPEGBuffer
(
dec
)
;
EXPECT_EQ
(
used_jpeg_output
jpeg_codestreams
[
i
]
.
size
(
)
)
;
EXPECT_EQ
(
0
memcmp
(
jpeg_output
.
data
(
)
jpeg_codestreams
[
i
]
.
data
(
)
used_jpeg_output
)
)
;
}
else
{
EXPECT_EQ
(
pixels
pixels2
)
;
}
}
else
if
(
status
=
=
JXL_DEC_SUCCESS
)
{
EXPECT_TRUE
(
seen_full_image
)
;
break
;
}
else
{
FAIL
(
)
;
break
;
}
}
EXPECT_TRUE
(
seen_basic_info
)
;
EXPECT_TRUE
(
seen_full_image
)
;
JxlDecoderDestroy
(
dec
)
;
}
}
}
TEST
(
DecodeTest
PixelPartialTest
)
{
TestPartialStream
(
false
)
;
}
#
if
JPEGXL_ENABLE_JPEG
TEST
(
DecodeTest
JPEGPartialTest
)
{
TestPartialStream
(
true
)
;
}
#
endif
TEST
(
DecodeTest
DCTest
)
{
using
jxl
:
:
kBlockDim
;
size_t
xsize
=
260
ysize
=
77
;
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
3
0
)
;
jxl
:
:
CompressParams
cparams
;
jxl
:
:
PaddedBytes
compressed
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
3
cparams
kCSBF_Multi
true
)
;
JxlPixelFormat
format
=
{
3
JXL_TYPE_UINT8
JXL_LITTLE_ENDIAN
0
}
;
size_t
start
=
0
;
size_t
end
=
compressed
.
size
(
)
;
size_t
dc_size
;
for
(
;
;
)
{
dc_size
=
(
start
+
end
)
/
2
;
JxlDecoderStatus
status
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_DC_IMAGE
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
compressed
.
data
(
)
dc_size
)
)
;
status
=
JxlDecoderProcessInput
(
dec
)
;
EXPECT_TRUE
(
status
=
=
JXL_DEC_BASIC_INFO
|
|
status
=
=
JXL_DEC_NEED_MORE_INPUT
)
;
if
(
status
!
=
JXL_DEC_NEED_MORE_INPUT
)
{
status
=
JxlDecoderProcessInput
(
dec
)
;
EXPECT_TRUE
(
status
=
=
JXL_DEC_NEED_DC_OUT_BUFFER
|
|
status
=
=
JXL_DEC_NEED_MORE_INPUT
)
;
}
JxlDecoderDestroy
(
dec
)
;
if
(
status
=
=
JXL_DEC_NEED_MORE_INPUT
)
{
start
=
dc_size
;
if
(
start
=
=
end
|
|
start
+
1
=
=
end
)
{
dc_size
+
+
;
break
;
}
}
else
{
end
=
dc_size
;
if
(
start
=
=
end
|
|
start
+
1
=
=
end
)
{
break
;
}
}
}
EXPECT_LE
(
dc_size
compressed
.
size
(
)
*
9
/
10
)
;
EXPECT_GT
(
dc_size
0
)
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_DC_IMAGE
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
compressed
.
data
(
)
dc_size
)
)
;
EXPECT_EQ
(
JXL_DEC_BASIC_INFO
JxlDecoderProcessInput
(
dec
)
)
;
size_t
buffer_size
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderDCOutBufferSize
(
dec
&
format
&
buffer_size
)
)
;
size_t
xsize_dc
=
(
xsize
+
kBlockDim
-
1
)
/
kBlockDim
;
size_t
ysize_dc
=
(
ysize
+
kBlockDim
-
1
)
/
kBlockDim
;
EXPECT_EQ
(
xsize_dc
*
ysize_dc
*
3
buffer_size
)
;
JxlBasicInfo
info
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetBasicInfo
(
dec
&
info
)
)
;
EXPECT_EQ
(
JXL_DEC_NEED_DC_OUT_BUFFER
JxlDecoderProcessInput
(
dec
)
)
;
std
:
:
vector
<
uint8_t
>
dc
(
buffer_size
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetDCOutBuffer
(
dec
&
format
dc
.
data
(
)
dc
.
size
(
)
)
)
;
EXPECT_EQ
(
JXL_DEC_DC_IMAGE
JxlDecoderProcessInput
(
dec
)
)
;
jxl
:
:
Image3F
dc0
(
xsize_dc
ysize_dc
)
;
jxl
:
:
Image3F
dc1
(
xsize_dc
ysize_dc
)
;
for
(
size_t
y
=
0
;
y
<
ysize_dc
;
y
+
+
)
{
for
(
size_t
x
=
0
;
x
<
xsize_dc
;
x
+
+
)
{
double
r
=
0
g
=
0
b
=
0
;
size_t
num
=
0
;
for
(
size_t
by
=
0
;
by
<
kBlockDim
;
by
+
+
)
{
size_t
y2
=
y
*
kBlockDim
+
by
;
if
(
y2
>
=
ysize
)
break
;
for
(
size_t
bx
=
0
;
bx
<
kBlockDim
;
bx
+
+
)
{
size_t
x2
=
x
*
kBlockDim
+
bx
;
if
(
x2
>
=
xsize
)
break
;
r
+
=
jxl
:
:
Srgb8ToLinearDirect
(
(
1
.
f
/
255
)
*
pixels
[
(
y2
*
xsize
+
x2
)
*
6
+
0
]
)
;
g
+
=
jxl
:
:
Srgb8ToLinearDirect
(
(
1
.
f
/
255
)
*
pixels
[
(
y2
*
xsize
+
x2
)
*
6
+
2
]
)
;
b
+
=
jxl
:
:
Srgb8ToLinearDirect
(
(
1
.
f
/
255
)
*
pixels
[
(
y2
*
xsize
+
x2
)
*
6
+
4
]
)
;
num
+
+
;
}
}
double
mul
=
1
.
0
/
num
;
r
*
=
mul
;
g
*
=
mul
;
b
*
=
mul
;
dc0
.
PlaneRow
(
0
y
)
[
x
]
=
r
;
dc0
.
PlaneRow
(
1
y
)
[
x
]
=
g
;
dc0
.
PlaneRow
(
2
y
)
[
x
]
=
b
;
dc1
.
PlaneRow
(
0
y
)
[
x
]
=
(
1
.
f
/
255
)
*
(
dc
[
(
y
*
xsize_dc
+
x
)
*
3
+
0
]
)
;
dc1
.
PlaneRow
(
1
y
)
[
x
]
=
(
1
.
f
/
255
)
*
(
dc
[
(
y
*
xsize_dc
+
x
)
*
3
+
1
]
)
;
dc1
.
PlaneRow
(
2
y
)
[
x
]
=
(
1
.
f
/
255
)
*
(
dc
[
(
y
*
xsize_dc
+
x
)
*
3
+
2
]
)
;
}
}
jxl
:
:
CodecInOut
dc0_io
;
dc0_io
.
SetFromImage
(
std
:
:
move
(
dc0
)
jxl
:
:
ColorEncoding
:
:
LinearSRGB
(
false
)
)
;
jxl
:
:
CodecInOut
dc1_io
;
dc1_io
.
SetFromImage
(
std
:
:
move
(
dc1
)
jxl
:
:
ColorEncoding
:
:
SRGB
(
false
)
)
;
jxl
:
:
ButteraugliParams
ba
;
EXPECT_LE
(
ButteraugliDistance
(
dc0_io
dc1_io
ba
nullptr
nullptr
)
3
.
0f
)
;
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
DCNotGettableTest
)
{
std
:
:
string
compressed
(
"
\
377
\
n
\
0
\
20
\
260
\
23
\
0H
\
200
(
"
"
\
0
\
334
\
0U
\
17
\
0
\
0
\
250P
\
31e
\
334
\
340
\
345
\
\
\
317
\
227
\
37
:
"
"
\
246m
\
\
gh
\
253m
\
vK
\
22E
\
306
\
261I
\
252C
&
pH
\
22
\
353
"
"
\
363
\
6
\
22
\
bp
\
0
\
200
\
237
\
34
\
231W2d
\
255
\
1
"
68
)
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_DC_IMAGE
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
reinterpret_cast
<
const
uint8_t
*
>
(
compressed
.
data
(
)
)
compressed
.
size
(
)
)
)
;
EXPECT_EQ
(
JXL_DEC_BASIC_INFO
JxlDecoderProcessInput
(
dec
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderProcessInput
(
dec
)
)
;
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
PreviewTest
)
{
size_t
xsize
=
77
ysize
=
120
;
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
3
0
)
;
jxl
:
:
CompressParams
cparams
;
jxl
:
:
PaddedBytes
compressed
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
3
cparams
kCSBF_Multi
true
)
;
JxlPixelFormat
format
=
{
3
JXL_TYPE_UINT8
JXL_LITTLE_ENDIAN
0
}
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
const
uint8_t
*
next_in
=
compressed
.
data
(
)
;
size_t
avail_in
=
compressed
.
size
(
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_PREVIEW_IMAGE
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
next_in
avail_in
)
)
;
EXPECT_EQ
(
JXL_DEC_BASIC_INFO
JxlDecoderProcessInput
(
dec
)
)
;
JxlBasicInfo
info
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetBasicInfo
(
dec
&
info
)
)
;
size_t
buffer_size
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderPreviewOutBufferSize
(
dec
&
format
&
buffer_size
)
)
;
size_t
xsize_preview
=
(
xsize
/
7
)
;
size_t
ysize_preview
=
(
ysize
/
7
)
;
EXPECT_EQ
(
xsize_preview
info
.
preview
.
xsize
)
;
EXPECT_EQ
(
ysize_preview
info
.
preview
.
ysize
)
;
EXPECT_EQ
(
xsize_preview
*
ysize_preview
*
3
buffer_size
)
;
EXPECT_EQ
(
JXL_DEC_NEED_PREVIEW_OUT_BUFFER
JxlDecoderProcessInput
(
dec
)
)
;
std
:
:
vector
<
uint8_t
>
preview
(
xsize_preview
*
ysize_preview
*
3
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetPreviewOutBuffer
(
dec
&
format
preview
.
data
(
)
preview
.
size
(
)
)
)
;
EXPECT_EQ
(
JXL_DEC_PREVIEW_IMAGE
JxlDecoderProcessInput
(
dec
)
)
;
jxl
:
:
Image3F
preview0
(
xsize_preview
ysize_preview
)
;
jxl
:
:
Image3F
preview1
(
xsize_preview
ysize_preview
)
;
for
(
size_t
y
=
0
;
y
<
ysize_preview
;
y
+
+
)
{
for
(
size_t
x
=
0
;
x
<
xsize_preview
;
x
+
+
)
{
preview0
.
PlaneRow
(
0
y
)
[
x
]
=
(
1
.
f
/
255
)
*
(
pixels
[
(
y
*
xsize
+
x
)
*
6
+
0
]
)
;
preview0
.
PlaneRow
(
1
y
)
[
x
]
=
(
1
.
f
/
255
)
*
(
pixels
[
(
y
*
xsize
+
x
)
*
6
+
2
]
)
;
preview0
.
PlaneRow
(
2
y
)
[
x
]
=
(
1
.
f
/
255
)
*
(
pixels
[
(
y
*
xsize
+
x
)
*
6
+
4
]
)
;
preview1
.
PlaneRow
(
0
y
)
[
x
]
=
(
1
.
f
/
255
)
*
(
preview
[
(
y
*
xsize_preview
+
x
)
*
3
+
0
]
)
;
preview1
.
PlaneRow
(
1
y
)
[
x
]
=
(
1
.
f
/
255
)
*
(
preview
[
(
y
*
xsize_preview
+
x
)
*
3
+
1
]
)
;
preview1
.
PlaneRow
(
2
y
)
[
x
]
=
(
1
.
f
/
255
)
*
(
preview
[
(
y
*
xsize_preview
+
x
)
*
3
+
2
]
)
;
}
}
jxl
:
:
CodecInOut
io0
;
io0
.
SetFromImage
(
std
:
:
move
(
preview0
)
jxl
:
:
ColorEncoding
:
:
SRGB
(
false
)
)
;
jxl
:
:
CodecInOut
io1
;
io1
.
SetFromImage
(
std
:
:
move
(
preview1
)
jxl
:
:
ColorEncoding
:
:
SRGB
(
false
)
)
;
jxl
:
:
ButteraugliParams
ba
;
EXPECT_LE
(
ButteraugliDistance
(
io0
io1
ba
nullptr
nullptr
)
0
.
9f
)
;
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
AlignTest
)
{
size_t
xsize
=
123
ysize
=
77
;
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
4
0
)
;
JxlPixelFormat
format_orig
=
{
4
JXL_TYPE_UINT16
JXL_BIG_ENDIAN
0
}
;
jxl
:
:
CompressParams
cparams
;
cparams
.
SetLossless
(
)
;
jxl
:
:
PaddedBytes
compressed
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
4
cparams
kCSBF_None
false
)
;
size_t
align
=
17
;
JxlPixelFormat
format
=
{
3
JXL_TYPE_UINT8
JXL_LITTLE_ENDIAN
align
}
;
size_t
expected_line_bytes
=
(
1
*
3
*
xsize
+
align
-
1
)
/
align
*
align
;
std
:
:
vector
<
uint8_t
>
pixels2
=
jxl
:
:
DecodeWithAPI
(
jxl
:
:
Span
<
const
uint8_t
>
(
compressed
.
data
(
)
compressed
.
size
(
)
)
format
)
;
EXPECT_EQ
(
expected_line_bytes
*
ysize
pixels2
.
size
(
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
pixels
.
data
(
)
pixels2
.
data
(
)
xsize
ysize
format_orig
format
)
)
;
}
TEST
(
DecodeTest
AnimationTest
)
{
size_t
xsize
=
123
ysize
=
77
;
static
const
size_t
num_frames
=
2
;
std
:
:
vector
<
uint8_t
>
frames
[
2
]
;
frames
[
0
]
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
3
0
)
;
frames
[
1
]
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
3
1
)
;
JxlPixelFormat
format
=
{
3
JXL_TYPE_UINT16
JXL_BIG_ENDIAN
0
}
;
jxl
:
:
CodecInOut
io
;
io
.
SetSize
(
xsize
ysize
)
;
io
.
metadata
.
m
.
SetUintSamples
(
16
)
;
io
.
metadata
.
m
.
color_encoding
=
jxl
:
:
ColorEncoding
:
:
SRGB
(
false
)
;
io
.
metadata
.
m
.
have_animation
=
true
;
io
.
frames
.
clear
(
)
;
io
.
frames
.
reserve
(
num_frames
)
;
io
.
SetSize
(
xsize
ysize
)
;
std
:
:
vector
<
uint32_t
>
frame_durations
(
num_frames
)
;
for
(
size_t
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
frame_durations
[
i
]
=
5
+
i
;
}
for
(
size_t
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
jxl
:
:
ImageBundle
bundle
(
&
io
.
metadata
.
m
)
;
EXPECT_TRUE
(
ConvertFromExternal
(
jxl
:
:
Span
<
const
uint8_t
>
(
frames
[
i
]
.
data
(
)
frames
[
i
]
.
size
(
)
)
xsize
ysize
jxl
:
:
ColorEncoding
:
:
SRGB
(
false
)
false
false
16
JXL_BIG_ENDIAN
false
nullptr
&
bundle
)
)
;
bundle
.
duration
=
frame_durations
[
i
]
;
io
.
frames
.
push_back
(
std
:
:
move
(
bundle
)
)
;
}
jxl
:
:
CompressParams
cparams
;
cparams
.
SetLossless
(
)
;
jxl
:
:
AuxOut
aux_out
;
jxl
:
:
PaddedBytes
compressed
;
jxl
:
:
PassesEncoderState
enc_state
;
EXPECT_TRUE
(
jxl
:
:
EncodeFile
(
cparams
&
io
&
enc_state
&
compressed
&
aux_out
nullptr
)
)
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
const
uint8_t
*
next_in
=
compressed
.
data
(
)
;
size_t
avail_in
=
compressed
.
size
(
)
;
void
*
runner
=
JxlThreadParallelRunnerCreate
(
NULL
JxlThreadParallelRunnerDefaultNumWorkerThreads
(
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetParallelRunner
(
dec
JxlThreadParallelRunner
runner
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_FRAME
|
JXL_DEC_FULL_IMAGE
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
next_in
avail_in
)
)
;
EXPECT_EQ
(
JXL_DEC_BASIC_INFO
JxlDecoderProcessInput
(
dec
)
)
;
size_t
buffer_size
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderImageOutBufferSize
(
dec
&
format
&
buffer_size
)
)
;
JxlBasicInfo
info
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetBasicInfo
(
dec
&
info
)
)
;
for
(
size_t
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
std
:
:
vector
<
uint8_t
>
pixels
(
buffer_size
)
;
EXPECT_EQ
(
JXL_DEC_FRAME
JxlDecoderProcessInput
(
dec
)
)
;
JxlFrameHeader
frame_header
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetFrameHeader
(
dec
&
frame_header
)
)
;
EXPECT_EQ
(
frame_durations
[
i
]
frame_header
.
duration
)
;
EXPECT_EQ
(
0
frame_header
.
name_length
)
;
char
name
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetFrameName
(
dec
&
name
1
)
)
;
EXPECT_EQ
(
0
name
)
;
EXPECT_EQ
(
JXL_DEC_NEED_IMAGE_OUT_BUFFER
JxlDecoderProcessInput
(
dec
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetImageOutBuffer
(
dec
&
format
pixels
.
data
(
)
pixels
.
size
(
)
)
)
;
EXPECT_EQ
(
JXL_DEC_FULL_IMAGE
JxlDecoderProcessInput
(
dec
)
)
;
EXPECT_EQ
(
0
ComparePixels
(
frames
[
i
]
.
data
(
)
pixels
.
data
(
)
xsize
ysize
format
format
)
)
;
}
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderProcessInput
(
dec
)
)
;
JxlThreadParallelRunnerDestroy
(
runner
)
;
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
AnimationTestStreaming
)
{
size_t
xsize
=
123
ysize
=
77
;
static
const
size_t
num_frames
=
2
;
std
:
:
vector
<
uint8_t
>
frames
[
2
]
;
frames
[
0
]
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
3
0
)
;
frames
[
1
]
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
3
1
)
;
JxlPixelFormat
format
=
{
3
JXL_TYPE_UINT16
JXL_BIG_ENDIAN
0
}
;
jxl
:
:
CodecInOut
io
;
io
.
SetSize
(
xsize
ysize
)
;
io
.
metadata
.
m
.
SetUintSamples
(
16
)
;
io
.
metadata
.
m
.
color_encoding
=
jxl
:
:
ColorEncoding
:
:
SRGB
(
false
)
;
io
.
metadata
.
m
.
have_animation
=
true
;
io
.
frames
.
clear
(
)
;
io
.
frames
.
reserve
(
num_frames
)
;
io
.
SetSize
(
xsize
ysize
)
;
std
:
:
vector
<
uint32_t
>
frame_durations
(
num_frames
)
;
for
(
size_t
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
frame_durations
[
i
]
=
5
+
i
;
}
for
(
size_t
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
jxl
:
:
ImageBundle
bundle
(
&
io
.
metadata
.
m
)
;
EXPECT_TRUE
(
ConvertFromExternal
(
jxl
:
:
Span
<
const
uint8_t
>
(
frames
[
i
]
.
data
(
)
frames
[
i
]
.
size
(
)
)
xsize
ysize
jxl
:
:
ColorEncoding
:
:
SRGB
(
false
)
false
false
16
JXL_BIG_ENDIAN
false
nullptr
&
bundle
)
)
;
bundle
.
duration
=
frame_durations
[
i
]
;
io
.
frames
.
push_back
(
std
:
:
move
(
bundle
)
)
;
}
jxl
:
:
CompressParams
cparams
;
cparams
.
SetLossless
(
)
;
jxl
:
:
AuxOut
aux_out
;
jxl
:
:
PaddedBytes
compressed
;
jxl
:
:
PassesEncoderState
enc_state
;
EXPECT_TRUE
(
jxl
:
:
EncodeFile
(
cparams
&
io
&
enc_state
&
compressed
&
aux_out
nullptr
)
)
;
const
size_t
step_size
=
16
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
NULL
)
;
const
uint8_t
*
next_in
=
compressed
.
data
(
)
;
size_t
avail_in
=
0
;
size_t
frame_headers_seen
=
0
;
size_t
frames_seen
=
0
;
bool
seen_basic_info
=
false
;
void
*
runner
=
JxlThreadParallelRunnerCreate
(
NULL
JxlThreadParallelRunnerDefaultNumWorkerThreads
(
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetParallelRunner
(
dec
JxlThreadParallelRunner
runner
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_FRAME
|
JXL_DEC_FULL_IMAGE
)
)
;
std
:
:
vector
<
uint8_t
>
frames2
[
2
]
;
for
(
size_t
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
frames2
[
i
]
.
resize
(
frames
[
i
]
.
size
(
)
)
;
}
size_t
total_in
=
0
;
size_t
loop_count
=
0
;
for
(
;
;
)
{
if
(
loop_count
+
+
>
compressed
.
size
(
)
)
{
fprintf
(
stderr
"
Too
many
loops
\
n
"
)
;
FAIL
(
)
;
break
;
}
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
next_in
avail_in
)
)
;
auto
status
=
JxlDecoderProcessInput
(
dec
)
;
size_t
remaining
=
JxlDecoderReleaseInput
(
dec
)
;
EXPECT_LE
(
remaining
avail_in
)
;
next_in
+
=
avail_in
-
remaining
;
avail_in
=
remaining
;
if
(
status
=
=
JXL_DEC_SUCCESS
)
{
break
;
}
else
if
(
status
=
=
JXL_DEC_ERROR
)
{
FAIL
(
)
;
}
else
if
(
status
=
=
JXL_DEC_NEED_MORE_INPUT
)
{
if
(
total_in
>
=
compressed
.
size
(
)
)
{
fprintf
(
stderr
"
Already
gave
all
input
data
\
n
"
)
;
FAIL
(
)
;
break
;
}
size_t
amount
=
step_size
;
if
(
total_in
+
amount
>
compressed
.
size
(
)
)
{
amount
=
compressed
.
size
(
)
-
total_in
;
}
avail_in
+
=
amount
;
total_in
+
=
amount
;
}
else
if
(
status
=
=
JXL_DEC_NEED_IMAGE_OUT_BUFFER
)
{
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetImageOutBuffer
(
dec
&
format
frames2
[
frames_seen
]
.
data
(
)
frames2
[
frames_seen
]
.
size
(
)
)
)
;
}
else
if
(
status
=
=
JXL_DEC_BASIC_INFO
)
{
EXPECT_EQ
(
false
seen_basic_info
)
;
seen_basic_info
=
true
;
JxlBasicInfo
info
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetBasicInfo
(
dec
&
info
)
)
;
EXPECT_EQ
(
xsize
info
.
xsize
)
;
EXPECT_EQ
(
ysize
info
.
ysize
)
;
}
else
if
(
status
=
=
JXL_DEC_FRAME
)
{
EXPECT_EQ
(
true
seen_basic_info
)
;
frame_headers_seen
+
+
;
}
else
if
(
status
=
=
JXL_DEC_FULL_IMAGE
)
{
frames_seen
+
+
;
EXPECT_EQ
(
frame_headers_seen
frames_seen
)
;
}
else
{
fprintf
(
stderr
"
Unexpected
status
:
%
d
\
n
"
(
int
)
status
)
;
FAIL
(
)
;
}
}
EXPECT_EQ
(
true
seen_basic_info
)
;
EXPECT_EQ
(
num_frames
frames_seen
)
;
EXPECT_EQ
(
num_frames
frame_headers_seen
)
;
for
(
size_t
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
EXPECT_EQ
(
frames
[
i
]
frames2
[
i
]
)
;
}
JxlThreadParallelRunnerDestroy
(
runner
)
;
JxlDecoderDestroy
(
dec
)
;
}
TEST
(
DecodeTest
FlushTest
)
{
size_t
xsize
=
333
ysize
=
300
;
uint32_t
num_channels
=
3
;
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
num_channels
0
)
;
jxl
:
:
CompressParams
cparams
;
jxl
:
:
PaddedBytes
data
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
num_channels
cparams
kCSBF_None
true
)
;
JxlPixelFormat
format
=
{
num_channels
JXL_TYPE_UINT16
JXL_BIG_ENDIAN
0
}
;
std
:
:
vector
<
uint8_t
>
pixels2
;
pixels2
.
resize
(
pixels
.
size
(
)
)
;
JxlDecoder
*
dec
=
JxlDecoderCreate
(
nullptr
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
JXL_DEC_BASIC_INFO
|
JXL_DEC_FRAME
|
JXL_DEC_FULL_IMAGE
)
)
;
size_t
first_part
=
data
.
size
(
)
*
3
/
4
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
data
.
data
(
)
first_part
)
)
;
EXPECT_EQ
(
JXL_DEC_BASIC_INFO
JxlDecoderProcessInput
(
dec
)
)
;
JxlBasicInfo
info
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderGetBasicInfo
(
dec
&
info
)
)
;
EXPECT_EQ
(
info
.
xsize
xsize
)
;
EXPECT_EQ
(
info
.
ysize
ysize
)
;
EXPECT_EQ
(
JXL_DEC_FRAME
JxlDecoderProcessInput
(
dec
)
)
;
EXPECT_EQ
(
JXL_DEC_ERROR
JxlDecoderFlushImage
(
dec
)
)
;
size_t
buffer_size
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderImageOutBufferSize
(
dec
&
format
&
buffer_size
)
)
;
EXPECT_EQ
(
pixels2
.
size
(
)
buffer_size
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetImageOutBuffer
(
dec
&
format
pixels2
.
data
(
)
pixels2
.
size
(
)
)
)
;
EXPECT_EQ
(
JXL_DEC_NEED_MORE_INPUT
JxlDecoderProcessInput
(
dec
)
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderFlushImage
(
dec
)
)
;
EXPECT_EQ
(
JXL_DEC_NEED_MORE_INPUT
JxlDecoderProcessInput
(
dec
)
)
;
size_t
consumed
=
first_part
-
JxlDecoderReleaseInput
(
dec
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetInput
(
dec
data
.
data
(
)
+
consumed
data
.
size
(
)
-
consumed
)
)
;
EXPECT_EQ
(
JXL_DEC_FULL_IMAGE
JxlDecoderProcessInput
(
dec
)
)
;
JxlDecoderDestroy
(
dec
)
;
}
void
VerifyJPEGReconstruction
(
const
jxl
:
:
PaddedBytes
&
container
const
jxl
:
:
PaddedBytes
&
jpeg_bytes
)
{
JxlDecoderPtr
dec
=
JxlDecoderMake
(
nullptr
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSubscribeEvents
(
dec
.
get
(
)
JXL_DEC_JPEG_RECONSTRUCTION
|
JXL_DEC_FULL_IMAGE
)
)
;
JxlDecoderSetInput
(
dec
.
get
(
)
container
.
data
(
)
container
.
size
(
)
)
;
EXPECT_EQ
(
JXL_DEC_JPEG_RECONSTRUCTION
JxlDecoderProcessInput
(
dec
.
get
(
)
)
)
;
std
:
:
vector
<
uint8_t
>
reconstructed_buffer
(
128
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetJPEGBuffer
(
dec
.
get
(
)
reconstructed_buffer
.
data
(
)
reconstructed_buffer
.
size
(
)
)
)
;
size_t
used
=
0
;
JxlDecoderStatus
process_result
=
JXL_DEC_JPEG_NEED_MORE_OUTPUT
;
while
(
process_result
=
=
JXL_DEC_JPEG_NEED_MORE_OUTPUT
)
{
used
=
reconstructed_buffer
.
size
(
)
-
JxlDecoderReleaseJPEGBuffer
(
dec
.
get
(
)
)
;
reconstructed_buffer
.
resize
(
reconstructed_buffer
.
size
(
)
*
2
)
;
EXPECT_EQ
(
JXL_DEC_SUCCESS
JxlDecoderSetJPEGBuffer
(
dec
.
get
(
)
reconstructed_buffer
.
data
(
)
+
used
reconstructed_buffer
.
size
(
)
-
used
)
)
;
process_result
=
JxlDecoderProcessInput
(
dec
.
get
(
)
)
;
}
ASSERT_EQ
(
JXL_DEC_FULL_IMAGE
process_result
)
;
used
=
reconstructed_buffer
.
size
(
)
-
JxlDecoderReleaseJPEGBuffer
(
dec
.
get
(
)
)
;
ASSERT_EQ
(
used
jpeg_bytes
.
size
(
)
)
;
EXPECT_EQ
(
0
memcmp
(
reconstructed_buffer
.
data
(
)
jpeg_bytes
.
data
(
)
used
)
)
;
}
#
if
JPEGXL_ENABLE_JPEG
TEST
(
DecodeTest
JPEGReconstructTestCodestream
)
{
size_t
xsize
=
123
;
size_t
ysize
=
77
;
size_t
channels
=
3
;
std
:
:
vector
<
uint8_t
>
pixels
=
jxl
:
:
test
:
:
GetSomeTestImage
(
xsize
ysize
channels
0
)
;
jxl
:
:
CompressParams
cparams
;
cparams
.
color_transform
=
jxl
:
:
ColorTransform
:
:
kNone
;
jxl
:
:
PaddedBytes
jpeg_codestream
;
jxl
:
:
PaddedBytes
compressed
=
jxl
:
:
CreateTestJXLCodestream
(
jxl
:
:
Span
<
const
uint8_t
>
(
pixels
.
data
(
)
pixels
.
size
(
)
)
xsize
ysize
channels
cparams
kCSBF_Single
true
false
&
jpeg_codestream
)
;
VerifyJPEGReconstruction
(
compressed
jpeg_codestream
)
;
}
#
endif
TEST
(
DecodeTest
JPEGReconstructionTest
)
{
const
std
:
:
string
jpeg_path
=
"
imagecompression
.
info
/
flower_foveon
.
png
.
im_q85_420
.
jpg
"
;
const
jxl
:
:
PaddedBytes
orig
=
jxl
:
:
ReadTestData
(
jpeg_path
)
;
jxl
:
:
CodecInOut
orig_io
;
ASSERT_TRUE
(
jxl
:
:
jpeg
:
:
DecodeImageJPG
(
jxl
:
:
Span
<
const
uint8_t
>
(
orig
)
&
orig_io
)
)
;
orig_io
.
metadata
.
m
.
xyb_encoded
=
false
;
jxl
:
:
BitWriter
writer
;
ASSERT_TRUE
(
WriteHeaders
(
&
orig_io
.
metadata
&
writer
nullptr
)
)
;
writer
.
ZeroPadToByte
(
)
;
jxl
:
:
PassesEncoderState
enc_state
;
jxl
:
:
CompressParams
cparams
;
cparams
.
color_transform
=
jxl
:
:
ColorTransform
:
:
kNone
;
ASSERT_TRUE
(
jxl
:
:
EncodeFrame
(
cparams
jxl
:
:
FrameInfo
{
}
&
orig_io
.
metadata
orig_io
.
Main
(
)
&
enc_state
nullptr
&
writer
nullptr
)
)
;
jxl
:
:
PaddedBytes
jpeg_data
;
ASSERT_TRUE
(
EncodeJPEGData
(
*
orig_io
.
Main
(
)
.
jpeg_data
.
get
(
)
&
jpeg_data
)
)
;
jxl
:
:
PaddedBytes
container
;
container
.
append
(
jxl
:
:
kContainerHeader
jxl
:
:
kContainerHeader
+
sizeof
(
jxl
:
:
kContainerHeader
)
)
;
jxl
:
:
AppendBoxHeader
(
jxl
:
:
MakeBoxType
(
"
jbrd
"
)
jpeg_data
.
size
(
)
false
&
container
)
;
container
.
append
(
jpeg_data
.
data
(
)
jpeg_data
.
data
(
)
+
jpeg_data
.
size
(
)
)
;
jxl
:
:
AppendBoxHeader
(
jxl
:
:
MakeBoxType
(
"
jxlc
"
)
0
true
&
container
)
;
jxl
:
:
PaddedBytes
codestream
=
std
:
:
move
(
writer
)
.
TakeBytes
(
)
;
container
.
append
(
codestream
.
data
(
)
codestream
.
data
(
)
+
codestream
.
size
(
)
)
;
VerifyJPEGReconstruction
(
container
orig
)
;
}
