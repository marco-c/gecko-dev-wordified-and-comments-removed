#
ifndef
LIB_JXL_BUTTERAUGLI_BUTTERAUGLI_H_
#
define
LIB_JXL_BUTTERAUGLI_BUTTERAUGLI_H_
#
include
<
jxl
/
memory_manager
.
h
>
#
include
<
atomic
>
#
include
<
cstddef
>
#
include
<
cstdlib
>
#
include
<
cstring
>
#
include
<
memory
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
#
if
!
defined
(
BUTTERAUGLI_ENABLE_CHECKS
)
#
define
BUTTERAUGLI_ENABLE_CHECKS
0
#
endif
#
define
BUTTERAUGLI_RESTRICT
JXL_RESTRICT
namespace
jxl
{
struct
ButteraugliParams
{
float
hf_asymmetry
=
1
.
0f
;
float
xmul
=
1
.
0f
;
float
intensity_target
=
80
.
0f
;
}
;
bool
ButteraugliInterface
(
const
Image3F
&
rgb0
const
Image3F
&
rgb1
const
ButteraugliParams
&
params
ImageF
&
diffmap
double
&
diffvalue
)
;
bool
ButteraugliInterface
(
const
Image3F
&
rgb0
const
Image3F
&
rgb1
float
hf_asymmetry
float
xmul
ImageF
&
diffmap
double
&
diffvalue
)
;
Status
ButteraugliInterfaceInPlace
(
Image3F
&
&
rgb0
Image3F
&
&
rgb1
const
ButteraugliParams
&
params
ImageF
&
diffmap
double
&
diffvalue
)
;
double
ButteraugliFuzzyClass
(
double
score
)
;
double
ButteraugliFuzzyInverse
(
double
seek
)
;
#
ifdef
_MSC_VER
#
define
BUTTERAUGLI_INLINE
__forceinline
#
else
#
define
BUTTERAUGLI_INLINE
inline
#
endif
#
ifdef
__clang__
#
define
BUTTERAUGLI_HAS_ASSUME_ALIGNED
__has_builtin
(
__builtin_assume_aligned
)
#
elif
defined
(
__GNUC__
)
#
define
BUTTERAUGLI_HAS_ASSUME_ALIGNED
1
#
else
#
define
BUTTERAUGLI_HAS_ASSUME_ALIGNED
0
#
endif
#
if
BUTTERAUGLI_HAS_ASSUME_ALIGNED
#
define
BUTTERAUGLI_ASSUME_ALIGNED
(
ptr
align
)
\
__builtin_assume_aligned
(
(
ptr
)
(
align
)
)
#
else
#
define
BUTTERAUGLI_ASSUME_ALIGNED
(
ptr
align
)
(
ptr
)
#
endif
struct
PsychoImage
{
ImageF
uhf
[
2
]
;
ImageF
hf
[
2
]
;
Image3F
mf
;
Image3F
lf
;
}
;
struct
BlurTemp
{
Status
GetTransposed
(
const
ImageF
&
in
ImageF
*
*
out
)
{
JxlMemoryManager
*
memory_manager
=
in
.
memory_manager
(
)
;
if
(
transposed_temp
.
xsize
(
)
=
=
0
)
{
JXL_ASSIGN_OR_RETURN
(
transposed_temp
ImageF
:
:
Create
(
memory_manager
in
.
ysize
(
)
in
.
xsize
(
)
)
)
;
}
*
out
=
&
transposed_temp
;
return
true
;
}
ImageF
transposed_temp
;
}
;
class
ButteraugliComparator
{
public
:
virtual
~
ButteraugliComparator
(
)
=
default
;
static
StatusOr
<
std
:
:
unique_ptr
<
ButteraugliComparator
>
>
Make
(
const
Image3F
&
rgb0
const
ButteraugliParams
&
params
)
;
Status
Diffmap
(
const
Image3F
&
rgb1
ImageF
&
result
)
const
;
Status
DiffmapOpsinDynamicsImage
(
const
Image3F
&
xyb1
ImageF
&
result
)
const
;
Status
DiffmapPsychoImage
(
const
PsychoImage
&
pi1
ImageF
&
diffmap
)
const
;
Status
Mask
(
ImageF
*
BUTTERAUGLI_RESTRICT
mask
)
const
;
private
:
ButteraugliComparator
(
size_t
xsize
size_t
ysize
const
ButteraugliParams
&
params
)
;
Image3F
*
Temp
(
)
const
;
void
ReleaseTemp
(
)
const
;
const
size_t
xsize_
;
const
size_t
ysize_
;
ButteraugliParams
params_
;
PsychoImage
pi0_
;
mutable
Image3F
temp_
;
mutable
std
:
:
atomic_flag
temp_in_use_
=
ATOMIC_FLAG_INIT
;
mutable
BlurTemp
blur_temp_
;
std
:
:
unique_ptr
<
ButteraugliComparator
>
sub_
;
}
;
Status
ButteraugliDiffmap
(
const
Image3F
&
rgb0
const
Image3F
&
rgb1
double
hf_asymmetry
double
xmul
ImageF
&
diffmap
)
;
Status
ButteraugliDiffmap
(
const
Image3F
&
rgb0
const
Image3F
&
rgb1
const
ButteraugliParams
&
params
ImageF
&
diffmap
)
;
double
ButteraugliScoreFromDiffmap
(
const
ImageF
&
diffmap
const
ButteraugliParams
*
params
=
nullptr
)
;
StatusOr
<
Image3F
>
CreateHeatMapImage
(
const
ImageF
&
distmap
double
good_threshold
double
bad_threshold
)
;
}
#
endif
