#
ifndef
LIB_JXL_BUTTERAUGLI_BUTTERAUGLI_H_
#
define
LIB_JXL_BUTTERAUGLI_BUTTERAUGLI_H_
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
atomic
>
#
include
<
cmath
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
common
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
#
include
"
lib
/
jxl
/
image_ops
.
h
"
#
define
BUTTERAUGLI_ENABLE_CHECKS
0
#
define
BUTTERAUGLI_RESTRICT
JXL_RESTRICT
namespace
jxl
{
struct
ButteraugliParams
{
float
hf_asymmetry
=
1
.
0f
;
float
xmul
=
1
.
0f
;
float
intensity_target
=
80
.
0f
;
}
;
bool
ButteraugliInterface
(
const
Image3F
&
rgb0
const
Image3F
&
rgb1
const
ButteraugliParams
&
params
ImageF
&
diffmap
double
&
diffvalue
)
;
bool
ButteraugliInterface
(
const
Image3F
&
rgb0
const
Image3F
&
rgb1
float
hf_asymmetry
float
xmul
ImageF
&
diffmap
double
&
diffvalue
)
;
double
ButteraugliFuzzyClass
(
double
score
)
;
double
ButteraugliFuzzyInverse
(
double
seek
)
;
#
ifdef
_MSC_VER
#
define
BUTTERAUGLI_INLINE
__forceinline
#
else
#
define
BUTTERAUGLI_INLINE
inline
#
endif
#
ifdef
__clang__
#
define
BUTTERAUGLI_HAS_ASSUME_ALIGNED
__has_builtin
(
__builtin_assume_aligned
)
#
elif
defined
(
__GNUC__
)
#
define
BUTTERAUGLI_HAS_ASSUME_ALIGNED
1
#
else
#
define
BUTTERAUGLI_HAS_ASSUME_ALIGNED
0
#
endif
#
if
BUTTERAUGLI_HAS_ASSUME_ALIGNED
#
define
BUTTERAUGLI_ASSUME_ALIGNED
(
ptr
align
)
\
__builtin_assume_aligned
(
(
ptr
)
(
align
)
)
#
else
#
define
BUTTERAUGLI_ASSUME_ALIGNED
(
ptr
align
)
(
ptr
)
#
endif
struct
PsychoImage
{
ImageF
uhf
[
2
]
;
ImageF
hf
[
2
]
;
Image3F
mf
;
Image3F
lf
;
}
;
struct
BlurTemp
{
ImageF
*
GetTransposed
(
const
ImageF
&
in
)
{
if
(
transposed_temp
.
xsize
(
)
=
=
0
)
{
transposed_temp
=
ImageF
(
in
.
ysize
(
)
in
.
xsize
(
)
)
;
}
return
&
transposed_temp
;
}
ImageF
transposed_temp
;
}
;
class
ButteraugliComparator
{
public
:
ButteraugliComparator
(
const
Image3F
&
rgb0
const
ButteraugliParams
&
params
)
;
virtual
~
ButteraugliComparator
(
)
=
default
;
void
Diffmap
(
const
Image3F
&
rgb1
ImageF
&
result
)
const
;
void
DiffmapOpsinDynamicsImage
(
const
Image3F
&
xyb1
ImageF
&
result
)
const
;
void
DiffmapPsychoImage
(
const
PsychoImage
&
pi1
ImageF
&
diffmap
)
const
;
void
Mask
(
ImageF
*
BUTTERAUGLI_RESTRICT
mask
)
const
;
private
:
Image3F
*
Temp
(
)
const
;
void
ReleaseTemp
(
)
const
;
const
size_t
xsize_
;
const
size_t
ysize_
;
ButteraugliParams
params_
;
PsychoImage
pi0_
;
mutable
Image3F
temp_
;
mutable
std
:
:
atomic_flag
temp_in_use_
=
ATOMIC_FLAG_INIT
;
mutable
BlurTemp
blur_temp_
;
std
:
:
unique_ptr
<
ButteraugliComparator
>
sub_
;
}
;
bool
ButteraugliDiffmap
(
const
Image3F
&
rgb0
const
Image3F
&
rgb1
double
hf_asymmetry
double
xmul
ImageF
&
diffmap
)
;
bool
ButteraugliDiffmap
(
const
Image3F
&
rgb0
const
Image3F
&
rgb1
const
ButteraugliParams
&
params
ImageF
&
diffmap
)
;
double
ButteraugliScoreFromDiffmap
(
const
ImageF
&
diffmap
const
ButteraugliParams
*
params
=
nullptr
)
;
Image3F
CreateHeatMapImage
(
const
ImageF
&
distmap
double
good_threshold
double
bad_threshold
)
;
}
#
endif
