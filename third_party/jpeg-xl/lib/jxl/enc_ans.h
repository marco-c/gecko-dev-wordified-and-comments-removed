#
ifndef
LIB_JXL_ENC_ANS_H_
#
define
LIB_JXL_ENC_ANS_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
ans_common
.
h
"
#
include
"
lib
/
jxl
/
ans_params
.
h
"
#
include
"
lib
/
jxl
/
aux_out
.
h
"
#
include
"
lib
/
jxl
/
aux_out_fwd
.
h
"
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
dec_ans
.
h
"
#
include
"
lib
/
jxl
/
enc_ans_params
.
h
"
#
include
"
lib
/
jxl
/
enc_bit_writer
.
h
"
#
include
"
lib
/
jxl
/
huffman_table
.
h
"
namespace
jxl
{
#
define
USE_MULT_BY_RECIPROCAL
#
define
RECIPROCAL_PRECISION
(
32
+
ANS_LOG_TAB_SIZE
)
struct
ANSEncSymbolInfo
{
uint16_t
freq_
;
std
:
:
vector
<
uint16_t
>
reverse_map_
;
#
ifdef
USE_MULT_BY_RECIPROCAL
uint64_t
ifreq_
;
#
endif
uint8_t
depth
;
uint16_t
bits
;
}
;
class
ANSCoder
{
public
:
ANSCoder
(
)
:
state_
(
ANS_SIGNATURE
<
<
16
)
{
}
uint32_t
PutSymbol
(
const
ANSEncSymbolInfo
&
t
uint8_t
*
nbits
)
{
uint32_t
bits
=
0
;
*
nbits
=
0
;
if
(
(
state_
>
>
(
32
-
ANS_LOG_TAB_SIZE
)
)
>
=
t
.
freq_
)
{
bits
=
state_
&
0xffff
;
state_
>
>
=
16
;
*
nbits
=
16
;
}
#
ifdef
USE_MULT_BY_RECIPROCAL
const
uint32_t
v
=
(
state_
*
t
.
ifreq_
)
>
>
RECIPROCAL_PRECISION
;
const
uint32_t
offset
=
t
.
reverse_map_
[
state_
-
v
*
t
.
freq_
]
;
state_
=
(
v
<
<
ANS_LOG_TAB_SIZE
)
+
offset
;
#
else
state_
=
(
(
state_
/
t
.
freq_
)
<
<
ANS_LOG_TAB_SIZE
)
+
t
.
reverse_map_
[
state_
%
t
.
freq_
]
;
#
endif
return
bits
;
}
uint32_t
GetState
(
)
const
{
return
state_
;
}
private
:
uint32_t
state_
;
}
;
using
ANSHistBin
=
int32_t
;
struct
EntropyEncodingData
{
std
:
:
vector
<
std
:
:
vector
<
ANSEncSymbolInfo
>
>
encoding_info
;
bool
use_prefix_code
;
std
:
:
vector
<
HybridUintConfig
>
uint_config
;
LZ77Params
lz77
;
}
;
struct
Token
{
Token
(
uint32_t
c
uint32_t
value
)
:
is_lz77_length
(
false
)
context
(
c
)
value
(
value
)
{
}
uint32_t
is_lz77_length
:
1
;
uint32_t
context
:
31
;
uint32_t
value
;
}
;
float
ANSPopulationCost
(
const
ANSHistBin
*
data
size_t
alphabet_size
)
;
size_t
BuildAndEncodeHistograms
(
const
HistogramParams
&
params
size_t
num_contexts
std
:
:
vector
<
std
:
:
vector
<
Token
>
>
&
tokens
EntropyEncodingData
*
codes
std
:
:
vector
<
uint8_t
>
*
context_map
BitWriter
*
writer
size_t
layer
AuxOut
*
aux_out
)
;
void
WriteTokens
(
const
std
:
:
vector
<
Token
>
&
tokens
const
EntropyEncodingData
&
codes
const
std
:
:
vector
<
uint8_t
>
&
context_map
BitWriter
*
writer
size_t
layer
AuxOut
*
aux_out
)
;
size_t
WriteTokens
(
const
std
:
:
vector
<
Token
>
&
tokens
const
EntropyEncodingData
&
codes
const
std
:
:
vector
<
uint8_t
>
&
context_map
BitWriter
*
writer
)
;
template
<
typename
Writer
>
void
EncodeUintConfigs
(
const
std
:
:
vector
<
HybridUintConfig
>
&
uint_config
Writer
*
writer
size_t
log_alpha_size
)
;
extern
template
void
EncodeUintConfigs
(
const
std
:
:
vector
<
HybridUintConfig
>
&
BitWriter
*
size_t
)
;
void
SetANSFuzzerFriendly
(
bool
ans_fuzzer_friendly
)
;
}
#
endif
