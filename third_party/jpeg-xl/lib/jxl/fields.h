#
ifndef
LIB_JXL_FIELDS_H_
#
define
LIB_JXL_FIELDS_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstdlib
>
#
include
<
cstring
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
dec_bit_reader
.
h
"
#
include
"
lib
/
jxl
/
field_encodings
.
h
"
namespace
jxl
{
struct
AuxOut
;
enum
class
LayerType
:
uint8_t
;
struct
BitWriter
;
namespace
BitsCoder
{
size_t
MaxEncodedBits
(
size_t
bits
)
;
Status
CanEncode
(
size_t
bits
uint32_t
value
size_t
*
JXL_RESTRICT
encoded_bits
)
;
uint32_t
Read
(
size_t
bits
BitReader
*
JXL_RESTRICT
reader
)
;
Status
Write
(
size_t
bits
uint32_t
value
BitWriter
*
JXL_RESTRICT
writer
)
;
}
namespace
U32Coder
{
size_t
MaxEncodedBits
(
U32Enc
enc
)
;
Status
CanEncode
(
U32Enc
enc
uint32_t
value
size_t
*
JXL_RESTRICT
encoded_bits
)
;
uint32_t
Read
(
U32Enc
enc
BitReader
*
JXL_RESTRICT
reader
)
;
Status
Write
(
U32Enc
enc
uint32_t
value
BitWriter
*
JXL_RESTRICT
writer
)
;
Status
ChooseSelector
(
U32Enc
enc
uint32_t
value
uint32_t
*
JXL_RESTRICT
selector
size_t
*
JXL_RESTRICT
total_bits
)
;
}
namespace
U64Coder
{
constexpr
size_t
MaxEncodedBits
(
)
{
return
2
+
12
+
6
*
(
8
+
1
)
+
(
4
+
1
)
;
}
uint64_t
Read
(
BitReader
*
JXL_RESTRICT
reader
)
;
Status
Write
(
uint64_t
value
BitWriter
*
JXL_RESTRICT
writer
)
;
Status
CanEncode
(
uint64_t
value
size_t
*
JXL_RESTRICT
encoded_bits
)
;
}
namespace
F16Coder
{
constexpr
size_t
MaxEncodedBits
(
)
{
return
16
;
}
Status
Read
(
BitReader
*
JXL_RESTRICT
reader
float
*
JXL_RESTRICT
value
)
;
Status
Write
(
float
value
BitWriter
*
JXL_RESTRICT
writer
)
;
Status
CanEncode
(
float
value
size_t
*
JXL_RESTRICT
encoded_bits
)
;
}
namespace
Bundle
{
constexpr
size_t
kMaxExtensions
=
64
;
void
Init
(
Fields
*
JXL_RESTRICT
fields
)
;
void
SetDefault
(
Fields
*
JXL_RESTRICT
fields
)
;
bool
AllDefault
(
const
Fields
&
fields
)
;
size_t
MaxBits
(
const
Fields
&
fields
)
;
Status
CanEncode
(
const
Fields
&
fields
size_t
*
JXL_RESTRICT
extension_bits
size_t
*
JXL_RESTRICT
total_bits
)
;
Status
Read
(
BitReader
*
reader
Fields
*
JXL_RESTRICT
fields
)
;
bool
CanRead
(
BitReader
*
reader
Fields
*
JXL_RESTRICT
fields
)
;
Status
Write
(
const
Fields
&
fields
BitWriter
*
JXL_RESTRICT
writer
LayerType
layer
AuxOut
*
aux_out
)
;
}
class
Visitor
{
public
:
virtual
~
Visitor
(
)
=
default
;
virtual
Status
Visit
(
Fields
*
fields
)
=
0
;
virtual
Status
Bool
(
bool
default_value
bool
*
JXL_RESTRICT
value
)
=
0
;
virtual
Status
U32
(
U32Enc
uint32_t
uint32_t
*
)
=
0
;
Status
U32
(
const
U32Distr
d0
const
U32Distr
d1
const
U32Distr
d2
const
U32Distr
d3
const
uint32_t
default_value
uint32_t
*
JXL_RESTRICT
value
)
{
return
U32
(
U32Enc
(
d0
d1
d2
d3
)
default_value
value
)
;
}
template
<
typename
EnumT
>
Status
Enum
(
const
EnumT
default_value
EnumT
*
JXL_RESTRICT
value
)
{
uint32_t
u32
=
static_cast
<
uint32_t
>
(
*
value
)
;
JXL_RETURN_IF_ERROR
(
U32
(
Val
(
0
)
Val
(
1
)
BitsOffset
(
4
2
)
BitsOffset
(
6
18
)
static_cast
<
uint32_t
>
(
default_value
)
&
u32
)
)
;
*
value
=
static_cast
<
EnumT
>
(
u32
)
;
return
EnumValid
(
*
value
)
;
}
virtual
Status
Bits
(
size_t
bits
uint32_t
default_value
uint32_t
*
JXL_RESTRICT
value
)
=
0
;
virtual
Status
U64
(
uint64_t
default_value
uint64_t
*
JXL_RESTRICT
value
)
=
0
;
virtual
Status
F16
(
float
default_value
float
*
JXL_RESTRICT
value
)
=
0
;
virtual
Status
Conditional
(
bool
condition
)
{
return
condition
;
}
virtual
Status
AllDefault
(
const
Fields
&
bool
*
JXL_RESTRICT
all_default
)
{
JXL_RETURN_IF_ERROR
(
Bool
(
true
all_default
)
)
;
return
*
all_default
;
}
virtual
void
SetDefault
(
Fields
*
)
{
}
virtual
Status
VisitNested
(
Fields
*
fields
)
{
return
Visit
(
fields
)
;
}
virtual
bool
IsReading
(
)
const
{
return
false
;
}
virtual
Status
BeginExtensions
(
uint64_t
*
JXL_RESTRICT
extensions
)
=
0
;
virtual
Status
EndExtensions
(
)
=
0
;
}
;
namespace
fields_internal
{
class
ExtensionStates
{
public
:
void
Push
(
)
{
begun_
<
<
=
1
;
ended_
<
<
=
1
;
}
void
Pop
(
)
{
begun_
>
>
=
1
;
ended_
>
>
=
1
;
}
Status
IsBegun
(
)
const
{
return
(
begun_
&
1
)
!
=
0
;
}
Status
IsEnded
(
)
const
{
return
(
ended_
&
1
)
!
=
0
;
}
void
Begin
(
)
{
JXL_DASSERT
(
!
IsBegun
(
)
)
;
JXL_DASSERT
(
!
IsEnded
(
)
)
;
begun_
+
=
1
;
}
void
End
(
)
{
JXL_DASSERT
(
IsBegun
(
)
)
;
JXL_DASSERT
(
!
IsEnded
(
)
)
;
ended_
+
=
1
;
}
private
:
uint64_t
begun_
=
0
;
uint64_t
ended_
=
0
;
}
;
class
VisitorBase
:
public
Visitor
{
public
:
explicit
VisitorBase
(
)
=
default
;
~
VisitorBase
(
)
override
{
JXL_DASSERT
(
depth_
=
=
0
)
;
}
Status
Visit
(
Fields
*
fields
)
override
{
JXL_ENSURE
(
depth_
<
Bundle
:
:
kMaxExtensions
)
;
depth_
+
=
1
;
extension_states_
.
Push
(
)
;
const
Status
ok
=
fields
-
>
VisitFields
(
this
)
;
if
(
ok
)
{
JXL_DASSERT
(
!
extension_states_
.
IsBegun
(
)
|
|
extension_states_
.
IsEnded
(
)
)
;
}
else
{
}
extension_states_
.
Pop
(
)
;
JXL_DASSERT
(
depth_
!
=
0
)
;
depth_
-
=
1
;
return
ok
;
}
Status
VisitConst
(
const
Fields
&
t
)
{
return
Visit
(
const_cast
<
Fields
*
>
(
&
t
)
)
;
}
Status
Bool
(
bool
default_value
bool
*
JXL_RESTRICT
value
)
override
{
uint32_t
bits
=
*
value
?
1
:
0
;
JXL_RETURN_IF_ERROR
(
Bits
(
1
static_cast
<
uint32_t
>
(
default_value
)
&
bits
)
)
;
JXL_DASSERT
(
bits
<
=
1
)
;
*
value
=
bits
=
=
1
;
return
true
;
}
Status
BeginExtensions
(
uint64_t
*
JXL_RESTRICT
extensions
)
override
{
JXL_RETURN_IF_ERROR
(
U64
(
0
extensions
)
)
;
extension_states_
.
Begin
(
)
;
return
true
;
}
Status
EndExtensions
(
)
override
{
extension_states_
.
End
(
)
;
return
true
;
}
private
:
size_t
depth_
=
0
;
ExtensionStates
extension_states_
;
}
;
}
Status
CheckHasEnoughBits
(
Visitor
*
visitor
size_t
bits
)
;
}
#
endif
