#
ifndef
LIB_JXL_IMAGE_METADATA_H_
#
define
LIB_JXL_IMAGE_METADATA_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
color_encoding_internal
.
h
"
#
include
"
lib
/
jxl
/
dec_xyb
.
h
"
#
include
"
lib
/
jxl
/
fields
.
h
"
#
include
"
lib
/
jxl
/
headers
.
h
"
#
include
"
lib
/
jxl
/
jpeg
/
jpeg_data
.
h
"
#
include
"
lib
/
jxl
/
opsin_params
.
h
"
namespace
jxl
{
enum
class
Orientation
:
uint32_t
{
kIdentity
=
1
kFlipHorizontal
kRotate180
kFlipVertical
kTranspose
kRotate90
kAntiTranspose
kRotate270
}
;
enum
class
ExtraChannel
:
uint32_t
{
kAlpha
kDepth
kSpotColor
kSelectionMask
kBlack
kCFA
kThermal
kReserved0
kReserved1
kReserved2
kReserved3
kReserved4
kReserved5
kReserved6
kReserved7
kUnknown
kOptional
}
;
static
inline
const
char
*
EnumName
(
ExtraChannel
)
{
return
"
ExtraChannel
"
;
}
static
inline
constexpr
uint64_t
EnumBits
(
ExtraChannel
)
{
using
EC
=
ExtraChannel
;
return
MakeBit
(
EC
:
:
kAlpha
)
|
MakeBit
(
EC
:
:
kDepth
)
|
MakeBit
(
EC
:
:
kSpotColor
)
|
MakeBit
(
EC
:
:
kSelectionMask
)
|
MakeBit
(
EC
:
:
kBlack
)
|
MakeBit
(
EC
:
:
kCFA
)
|
MakeBit
(
EC
:
:
kUnknown
)
|
MakeBit
(
EC
:
:
kOptional
)
;
}
struct
BitDepth
:
public
Fields
{
BitDepth
(
)
;
const
char
*
Name
(
)
const
override
{
return
"
BitDepth
"
;
}
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
bool
floating_point_sample
;
uint32_t
bits_per_sample
;
uint32_t
exponent_bits_per_sample
;
}
;
struct
ExtraChannelInfo
:
public
Fields
{
ExtraChannelInfo
(
)
;
const
char
*
Name
(
)
const
override
{
return
"
ExtraChannelInfo
"
;
}
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
size_t
Size
(
size_t
size
)
const
{
const
size_t
mask
=
(
1u
<
<
dim_shift
)
-
1
;
return
(
size
+
mask
)
>
>
dim_shift
;
}
mutable
bool
all_default
;
ExtraChannel
type
;
BitDepth
bit_depth
;
uint32_t
dim_shift
;
std
:
:
string
name
;
bool
alpha_associated
;
float
spot_color
[
4
]
;
uint32_t
cfa_channel
;
}
;
struct
OpsinInverseMatrix
:
public
Fields
{
OpsinInverseMatrix
(
)
;
const
char
*
Name
(
)
const
override
{
return
"
OpsinInverseMatrix
"
;
}
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
OpsinParams
ToOpsinParams
(
float
intensity_target
)
const
{
OpsinParams
opsin_params
;
InitSIMDInverseMatrix
(
inverse_matrix
opsin_params
.
inverse_opsin_matrix
intensity_target
)
;
std
:
:
copy
(
std
:
:
begin
(
opsin_biases
)
std
:
:
end
(
opsin_biases
)
opsin_params
.
opsin_biases
)
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
opsin_params
.
opsin_biases_cbrt
[
i
]
=
cbrtf
(
opsin_params
.
opsin_biases
[
i
]
)
;
}
opsin_params
.
opsin_biases_cbrt
[
3
]
=
opsin_params
.
opsin_biases
[
3
]
=
1
;
std
:
:
copy
(
std
:
:
begin
(
quant_biases
)
std
:
:
end
(
quant_biases
)
opsin_params
.
quant_biases
)
;
return
opsin_params
;
}
mutable
bool
all_default
;
float
inverse_matrix
[
9
]
;
float
opsin_biases
[
3
]
;
float
quant_biases
[
4
]
;
}
;
struct
ToneMapping
:
public
Fields
{
ToneMapping
(
)
;
const
char
*
Name
(
)
const
override
{
return
"
ToneMapping
"
;
}
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
mutable
bool
all_default
;
float
intensity_target
;
float
min_nits
;
bool
relative_to_max_display
;
float
linear_below
;
}
;
struct
CustomTransformData
:
public
Fields
{
CustomTransformData
(
)
;
const
char
*
Name
(
)
const
override
{
return
"
CustomTransformData
"
;
}
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
bool
nonserialized_xyb_encoded
=
false
;
mutable
bool
all_default
;
OpsinInverseMatrix
opsin_inverse_matrix
;
uint32_t
custom_weights_mask
;
float
upsampling2_weights
[
15
]
;
float
upsampling4_weights
[
55
]
;
float
upsampling8_weights
[
210
]
;
}
;
struct
ImageMetadata
:
public
Fields
{
ImageMetadata
(
)
;
const
char
*
Name
(
)
const
override
{
return
"
ImageMetadata
"
;
}
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
uint32_t
GetAlphaBits
(
)
const
{
const
ExtraChannelInfo
*
alpha
=
Find
(
ExtraChannel
:
:
kAlpha
)
;
if
(
alpha
=
=
nullptr
)
return
0
;
JXL_ASSERT
(
alpha
-
>
bit_depth
.
bits_per_sample
!
=
0
)
;
return
alpha
-
>
bit_depth
.
bits_per_sample
;
}
void
SetAlphaBits
(
uint32_t
bits
bool
alpha_is_premultiplied
=
false
)
;
bool
HasAlpha
(
)
const
{
return
GetAlphaBits
(
)
!
=
0
;
}
void
SetUintSamples
(
uint32_t
bits
)
{
bit_depth
.
bits_per_sample
=
bits
;
bit_depth
.
exponent_bits_per_sample
=
0
;
bit_depth
.
floating_point_sample
=
false
;
}
void
SetFloat32Samples
(
)
{
bit_depth
.
bits_per_sample
=
32
;
bit_depth
.
exponent_bits_per_sample
=
8
;
bit_depth
.
floating_point_sample
=
true
;
}
void
SetFloat16Samples
(
)
{
bit_depth
.
bits_per_sample
=
16
;
bit_depth
.
exponent_bits_per_sample
=
5
;
bit_depth
.
floating_point_sample
=
true
;
}
void
SetIntensityTarget
(
float
intensity_target
)
{
tone_mapping
.
intensity_target
=
intensity_target
;
}
float
IntensityTarget
(
)
const
{
JXL_ASSERT
(
tone_mapping
.
intensity_target
!
=
0
)
;
return
tone_mapping
.
intensity_target
;
}
const
ExtraChannelInfo
*
Find
(
ExtraChannel
type
)
const
{
for
(
const
ExtraChannelInfo
&
eci
:
extra_channel_info
)
{
if
(
eci
.
type
=
=
type
)
return
&
eci
;
}
return
nullptr
;
}
ExtraChannelInfo
*
Find
(
ExtraChannel
type
)
{
for
(
ExtraChannelInfo
&
eci
:
extra_channel_info
)
{
if
(
eci
.
type
=
=
type
)
return
&
eci
;
}
return
nullptr
;
}
Orientation
GetOrientation
(
)
const
{
return
static_cast
<
Orientation
>
(
orientation
)
;
}
bool
ExtraFieldsDefault
(
)
const
;
mutable
bool
all_default
;
BitDepth
bit_depth
;
bool
modular_16_bit_buffer_sufficient
;
bool
xyb_encoded
;
ColorEncoding
color_encoding
;
uint32_t
orientation
=
1
;
bool
have_preview
=
false
;
bool
have_animation
=
false
;
bool
have_intrinsic_size
=
false
;
SizeHeader
intrinsic_size
;
ToneMapping
tone_mapping
;
uint32_t
num_extra_channels
;
std
:
:
vector
<
ExtraChannelInfo
>
extra_channel_info
;
CustomTransformData
transform_data
;
PreviewHeader
preview_size
;
AnimationHeader
animation
;
uint64_t
extensions
;
bool
nonserialized_only_parse_basic_info
=
false
;
}
;
Status
ReadImageMetadata
(
BitReader
*
JXL_RESTRICT
reader
ImageMetadata
*
JXL_RESTRICT
metadata
)
;
Status
WriteImageMetadata
(
const
ImageMetadata
&
metadata
BitWriter
*
JXL_RESTRICT
writer
size_t
layer
AuxOut
*
aux_out
)
;
struct
CodecMetadata
{
ImageMetadata
m
;
SizeHeader
size
;
CustomTransformData
transform_data
;
size_t
xsize
(
)
const
{
return
size
.
xsize
(
)
;
}
size_t
ysize
(
)
const
{
return
size
.
ysize
(
)
;
}
}
;
}
#
endif
