#
ifndef
LIB_JXL_IMAGE_METADATA_H_
#
define
LIB_JXL_IMAGE_METADATA_H_
#
include
<
jxl
/
codestream_header
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
color_encoding_internal
.
h
"
#
include
"
lib
/
jxl
/
fields
.
h
"
#
include
"
lib
/
jxl
/
headers
.
h
"
#
include
"
lib
/
jxl
/
jpeg
/
jpeg_data
.
h
"
namespace
jxl
{
struct
AuxOut
;
enum
class
Orientation
:
uint32_t
{
kIdentity
=
JXL_ORIENT_IDENTITY
kFlipHorizontal
=
JXL_ORIENT_FLIP_HORIZONTAL
kRotate180
=
JXL_ORIENT_ROTATE_180
kFlipVertical
=
JXL_ORIENT_FLIP_VERTICAL
kTranspose
=
JXL_ORIENT_TRANSPOSE
kRotate90
=
JXL_ORIENT_ROTATE_90_CW
kAntiTranspose
=
JXL_ORIENT_ANTI_TRANSPOSE
kRotate270
=
JXL_ORIENT_ROTATE_90_CCW
}
;
enum
class
ExtraChannel
:
uint32_t
{
kAlpha
=
JXL_CHANNEL_ALPHA
kDepth
=
JXL_CHANNEL_DEPTH
kSpotColor
=
JXL_CHANNEL_SPOT_COLOR
kSelectionMask
=
JXL_CHANNEL_SELECTION_MASK
kBlack
=
JXL_CHANNEL_BLACK
kCFA
=
JXL_CHANNEL_CFA
kThermal
=
JXL_CHANNEL_THERMAL
kReserved0
=
JXL_CHANNEL_RESERVED0
kReserved1
=
JXL_CHANNEL_RESERVED1
kReserved2
=
JXL_CHANNEL_RESERVED2
kReserved3
=
JXL_CHANNEL_RESERVED3
kReserved4
=
JXL_CHANNEL_RESERVED4
kReserved5
=
JXL_CHANNEL_RESERVED5
kReserved6
=
JXL_CHANNEL_RESERVED6
kReserved7
=
JXL_CHANNEL_RESERVED7
kUnknown
=
JXL_CHANNEL_UNKNOWN
kOptional
=
JXL_CHANNEL_OPTIONAL
}
;
static
inline
const
char
*
EnumName
(
ExtraChannel
)
{
return
"
ExtraChannel
"
;
}
static
inline
constexpr
uint64_t
EnumBits
(
ExtraChannel
)
{
using
EC
=
ExtraChannel
;
return
MakeBit
(
EC
:
:
kAlpha
)
|
MakeBit
(
EC
:
:
kDepth
)
|
MakeBit
(
EC
:
:
kSpotColor
)
|
MakeBit
(
EC
:
:
kSelectionMask
)
|
MakeBit
(
EC
:
:
kBlack
)
|
MakeBit
(
EC
:
:
kCFA
)
|
MakeBit
(
EC
:
:
kThermal
)
|
MakeBit
(
EC
:
:
kUnknown
)
|
MakeBit
(
EC
:
:
kOptional
)
;
}
struct
BitDepth
:
public
Fields
{
BitDepth
(
)
;
JXL_FIELDS_NAME
(
BitDepth
)
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
std
:
:
string
DebugString
(
)
const
;
bool
floating_point_sample
;
uint32_t
bits_per_sample
;
uint32_t
exponent_bits_per_sample
;
}
;
struct
ExtraChannelInfo
:
public
Fields
{
ExtraChannelInfo
(
)
;
JXL_FIELDS_NAME
(
ExtraChannelInfo
)
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
std
:
:
string
DebugString
(
)
const
;
mutable
bool
all_default
;
ExtraChannel
type
;
BitDepth
bit_depth
;
uint32_t
dim_shift
;
std
:
:
string
name
;
bool
alpha_associated
;
float
spot_color
[
4
]
;
uint32_t
cfa_channel
;
}
;
struct
OpsinInverseMatrix
:
public
Fields
{
OpsinInverseMatrix
(
)
;
JXL_FIELDS_NAME
(
OpsinInverseMatrix
)
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
mutable
bool
all_default
;
float
inverse_matrix
[
9
]
;
float
opsin_biases
[
3
]
;
float
quant_biases
[
4
]
;
}
;
struct
ToneMapping
:
public
Fields
{
ToneMapping
(
)
;
JXL_FIELDS_NAME
(
ToneMapping
)
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
mutable
bool
all_default
;
float
intensity_target
;
float
min_nits
;
bool
relative_to_max_display
;
float
linear_below
;
}
;
struct
CustomTransformData
:
public
Fields
{
CustomTransformData
(
)
;
JXL_FIELDS_NAME
(
CustomTransformData
)
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
bool
nonserialized_xyb_encoded
=
false
;
mutable
bool
all_default
;
OpsinInverseMatrix
opsin_inverse_matrix
;
uint32_t
custom_weights_mask
;
float
upsampling2_weights
[
15
]
;
float
upsampling4_weights
[
55
]
;
float
upsampling8_weights
[
210
]
;
}
;
struct
ImageMetadata
:
public
Fields
{
ImageMetadata
(
)
;
JXL_FIELDS_NAME
(
ImageMetadata
)
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
uint32_t
GetAlphaBits
(
)
const
{
const
ExtraChannelInfo
*
alpha
=
Find
(
ExtraChannel
:
:
kAlpha
)
;
if
(
alpha
=
=
nullptr
)
return
0
;
JXL_ASSERT
(
alpha
-
>
bit_depth
.
bits_per_sample
!
=
0
)
;
return
alpha
-
>
bit_depth
.
bits_per_sample
;
}
void
SetAlphaBits
(
uint32_t
bits
bool
alpha_is_premultiplied
=
false
)
;
bool
HasAlpha
(
)
const
{
return
GetAlphaBits
(
)
!
=
0
;
}
void
SetUintSamples
(
uint32_t
bits
)
{
bit_depth
.
bits_per_sample
=
bits
;
bit_depth
.
exponent_bits_per_sample
=
0
;
bit_depth
.
floating_point_sample
=
false
;
if
(
bits
>
12
)
modular_16_bit_buffer_sufficient
=
false
;
}
void
SetFloat32Samples
(
)
{
bit_depth
.
bits_per_sample
=
32
;
bit_depth
.
exponent_bits_per_sample
=
8
;
bit_depth
.
floating_point_sample
=
true
;
modular_16_bit_buffer_sufficient
=
false
;
}
void
SetFloat16Samples
(
)
{
bit_depth
.
bits_per_sample
=
16
;
bit_depth
.
exponent_bits_per_sample
=
5
;
bit_depth
.
floating_point_sample
=
true
;
modular_16_bit_buffer_sufficient
=
false
;
}
void
SetIntensityTarget
(
float
intensity_target
)
{
tone_mapping
.
intensity_target
=
intensity_target
;
}
float
IntensityTarget
(
)
const
{
JXL_ASSERT
(
tone_mapping
.
intensity_target
!
=
0
)
;
return
tone_mapping
.
intensity_target
;
}
const
ExtraChannelInfo
*
Find
(
ExtraChannel
type
)
const
{
for
(
const
ExtraChannelInfo
&
eci
:
extra_channel_info
)
{
if
(
eci
.
type
=
=
type
)
return
&
eci
;
}
return
nullptr
;
}
ExtraChannelInfo
*
Find
(
ExtraChannel
type
)
{
for
(
ExtraChannelInfo
&
eci
:
extra_channel_info
)
{
if
(
eci
.
type
=
=
type
)
return
&
eci
;
}
return
nullptr
;
}
Orientation
GetOrientation
(
)
const
{
return
static_cast
<
Orientation
>
(
orientation
)
;
}
bool
ExtraFieldsDefault
(
)
const
;
std
:
:
string
DebugString
(
)
const
;
mutable
bool
all_default
;
BitDepth
bit_depth
;
bool
modular_16_bit_buffer_sufficient
;
bool
xyb_encoded
;
ColorEncoding
color_encoding
;
uint32_t
orientation
=
1
;
bool
have_preview
=
false
;
bool
have_animation
=
false
;
bool
have_intrinsic_size
=
false
;
SizeHeader
intrinsic_size
;
ToneMapping
tone_mapping
;
uint32_t
num_extra_channels
;
std
:
:
vector
<
ExtraChannelInfo
>
extra_channel_info
;
PreviewHeader
preview_size
;
AnimationHeader
animation
;
uint64_t
extensions
;
bool
nonserialized_only_parse_basic_info
=
false
;
}
;
Status
ReadImageMetadata
(
BitReader
*
JXL_RESTRICT
reader
ImageMetadata
*
JXL_RESTRICT
metadata
)
;
Status
WriteImageMetadata
(
const
ImageMetadata
&
metadata
BitWriter
*
JXL_RESTRICT
writer
size_t
layer
AuxOut
*
aux_out
)
;
struct
CodecMetadata
{
ImageMetadata
m
;
SizeHeader
size
;
CustomTransformData
transform_data
;
size_t
xsize
(
)
const
{
return
size
.
xsize
(
)
;
}
size_t
ysize
(
)
const
{
return
size
.
ysize
(
)
;
}
size_t
oriented_xsize
(
bool
keep_orientation
)
const
{
if
(
static_cast
<
uint32_t
>
(
m
.
GetOrientation
(
)
)
>
4
&
&
!
keep_orientation
)
{
return
ysize
(
)
;
}
else
{
return
xsize
(
)
;
}
}
size_t
oriented_preview_xsize
(
bool
keep_orientation
)
const
{
if
(
static_cast
<
uint32_t
>
(
m
.
GetOrientation
(
)
)
>
4
&
&
!
keep_orientation
)
{
return
m
.
preview_size
.
ysize
(
)
;
}
else
{
return
m
.
preview_size
.
xsize
(
)
;
}
}
size_t
oriented_ysize
(
bool
keep_orientation
)
const
{
if
(
static_cast
<
uint32_t
>
(
m
.
GetOrientation
(
)
)
>
4
&
&
!
keep_orientation
)
{
return
xsize
(
)
;
}
else
{
return
ysize
(
)
;
}
}
size_t
oriented_preview_ysize
(
bool
keep_orientation
)
const
{
if
(
static_cast
<
uint32_t
>
(
m
.
GetOrientation
(
)
)
>
4
&
&
!
keep_orientation
)
{
return
m
.
preview_size
.
xsize
(
)
;
}
else
{
return
m
.
preview_size
.
ysize
(
)
;
}
}
std
:
:
string
DebugString
(
)
const
;
}
;
}
#
endif
