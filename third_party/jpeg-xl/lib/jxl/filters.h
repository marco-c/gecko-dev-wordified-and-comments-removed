#
ifndef
LIB_JXL_FILTERS_H_
#
define
LIB_JXL_FILTERS_H_
#
include
<
stddef
.
h
>
#
include
"
lib
/
jxl
/
common
.
h
"
#
include
"
lib
/
jxl
/
dec_group_border
.
h
"
#
include
"
lib
/
jxl
/
filters_internal
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
#
include
"
lib
/
jxl
/
loop_filter
.
h
"
#
include
"
lib
/
jxl
/
sanitizers
.
h
"
namespace
jxl
{
struct
FilterWeights
{
Status
Init
(
const
LoopFilter
&
lf
const
FrameDimensions
&
frame_dim
)
;
float
gab_weights
[
9
]
;
ImageF
sigma
;
private
:
Status
GaborishWeights
(
const
LoopFilter
&
lf
)
;
}
;
static
constexpr
size_t
kMaxFinalizeRectPadding
=
9
;
constexpr
size_t
kApplyImageFeaturesTileDim
=
256
+
2
*
RoundUpToBlockDim
(
kMaxFinalizeRectPadding
)
;
constexpr
size_t
kTotalStorageRows
=
7
+
5
+
3
;
constexpr
size_t
kMaxFilterBorder
=
1
*
kBlockDim
;
constexpr
size_t
kMaxFilterPadding
=
kMaxFilterBorder
+
kBlockDim
;
static_assert
(
kMaxFilterPadding
%
kBlockDim
=
=
0
"
kMaxFilterPadding
must
be
a
multiple
of
block
size
.
"
)
;
constexpr
size_t
kSigmaBorder
=
kMaxFilterBorder
/
kBlockDim
;
constexpr
size_t
kSigmaPadding
=
kMaxFilterPadding
/
kBlockDim
;
constexpr
size_t
kMaxBorderSize
=
3
;
struct
FilterRows
{
explicit
FilterRows
(
int
border_size
)
:
border_size_
(
border_size
)
{
JXL_DASSERT
(
border_size
<
=
static_cast
<
int
>
(
kMaxBorderSize
)
)
;
}
JXL_INLINE
const
float
*
GetInputRow
(
int
row
size_t
c
)
const
{
JXL_DASSERT
(
-
border_size_
<
=
row
&
&
row
<
=
border_size_
)
;
return
rows_in_
[
c
]
+
offsets_in_
[
kMaxBorderSize
+
row
]
;
}
float
*
GetOutputRow
(
size_t
c
)
const
{
return
rows_out_
[
c
]
;
}
const
float
*
GetSigmaRow
(
)
const
{
JXL_DASSERT
(
row_sigma_
!
=
nullptr
)
;
return
row_sigma_
;
}
template
<
typename
RowMap
>
void
SetInput
(
const
Image3F
&
in
size_t
y_offset
ssize_t
y0
ssize_t
x0
ssize_t
full_image_y_offset
=
0
ssize_t
image_ysize
=
0
)
{
RowMap
row_map
(
full_image_y_offset
image_ysize
)
;
for
(
size_t
c
=
0
;
c
<
3
;
c
+
+
)
{
rows_in_
[
c
]
=
in
.
ConstPlaneRow
(
c
0
)
;
}
for
(
int32_t
i
=
-
border_size_
;
i
<
=
border_size_
;
i
+
+
)
{
size_t
y
=
row_map
(
y0
+
i
)
;
offsets_in_
[
i
+
kMaxBorderSize
]
=
static_cast
<
ssize_t
>
(
(
y
+
y_offset
)
*
in
.
PixelsPerRow
(
)
)
+
x0
;
}
}
template
<
typename
RowMap
>
void
SetOutput
(
Image3F
*
out
size_t
y_offset
ssize_t
y0
ssize_t
x0
)
{
size_t
y
=
RowMap
(
)
(
y0
)
;
for
(
size_t
c
=
0
;
c
<
3
;
c
+
+
)
{
rows_out_
[
c
]
=
out
-
>
PlaneRow
(
c
y
+
y_offset
)
+
x0
;
}
}
void
SetSigma
(
const
ImageF
&
sigma
size_t
y0
size_t
x0
)
{
JXL_DASSERT
(
x0
%
kBlockDim
=
=
0
)
;
row_sigma_
=
sigma
.
ConstRow
(
y0
/
kBlockDim
)
+
x0
/
kBlockDim
;
}
private
:
const
float
*
JXL_RESTRICT
rows_in_
[
3
]
;
ssize_t
offsets_in_
[
2
*
kMaxBorderSize
+
1
]
;
float
*
JXL_RESTRICT
rows_out_
[
3
]
;
const
float
*
JXL_RESTRICT
row_sigma_
{
nullptr
}
;
const
int
border_size_
;
}
;
struct
FilterDefinition
{
void
(
*
apply
)
(
const
FilterRows
&
rows
const
LoopFilter
&
lf
const
FilterWeights
&
filter_weights
size_t
x0
size_t
x1
size_t
sigma_x_offset
size_t
image_y_mod_8
)
;
size_t
border
;
}
;
class
FilterPipeline
{
public
:
FilterPipeline
(
)
:
FilterPipeline
(
kApplyImageFeaturesTileDim
)
{
}
explicit
FilterPipeline
(
size_t
max_rect_xsize
)
:
storage
{
max_rect_xsize
+
2
*
kMaxFilterPadding
+
GroupBorderAssigner
:
:
kPaddingXRound
kTotalStorageRows
}
{
#
if
MEMORY_SANITIZER
for
(
size_t
c
=
0
;
c
<
3
;
c
+
+
)
{
for
(
size_t
y
=
0
;
y
<
storage
.
ysize
(
)
;
y
+
+
)
{
float
*
row
=
storage
.
PlaneRow
(
c
y
)
;
std
:
:
fill
(
row
row
+
kMaxFilterPadding
msan
:
:
kSanitizerSentinel
)
;
std
:
:
fill
(
row
+
storage
.
xsize
(
)
-
kMaxFilterPadding
row
+
storage
.
xsize
(
)
msan
:
:
kSanitizerSentinel
)
;
}
}
#
endif
}
FilterPipeline
(
const
FilterPipeline
&
)
=
delete
;
FilterPipeline
(
FilterPipeline
&
&
)
=
default
;
void
ApplyFiltersRow
(
const
LoopFilter
&
lf
const
FilterWeights
&
filter_weights
ssize_t
y
)
;
struct
FilterStep
{
static
size_t
MaxLeftPadding
(
size_t
image_rect_x0
)
{
return
kMaxFilterPadding
+
image_rect_x0
%
GroupBorderAssigner
:
:
kPaddingXRound
;
}
void
SetInput
(
const
Image3F
*
im_input
const
Rect
&
input_rect
const
Rect
&
image_rect
size_t
image_ysize
)
{
input
=
im_input
;
this
-
>
input_rect
=
input_rect
;
this
-
>
image_rect
=
image_rect
;
this
-
>
image_ysize
=
image_ysize
;
JXL_DASSERT
(
SameSize
(
input_rect
image_rect
)
)
;
set_input_rows
=
[
]
(
const
FilterStep
&
self
FilterRows
*
rows
ssize_t
y0
)
{
ssize_t
full_image_y_offset
=
static_cast
<
ssize_t
>
(
self
.
image_rect
.
y0
(
)
)
-
static_cast
<
ssize_t
>
(
self
.
input_rect
.
y0
(
)
)
;
rows
-
>
SetInput
<
RowMapMirror
>
(
*
(
self
.
input
)
0
self
.
input_rect
.
y0
(
)
+
y0
self
.
input_rect
.
x0
(
)
-
kMaxFilterPadding
full_image_y_offset
self
.
image_ysize
)
;
rows
-
>
SetInput
<
RowMapMirror
>
(
*
(
self
.
input
)
0
self
.
input_rect
.
y0
(
)
+
y0
self
.
input_rect
.
x0
(
)
-
MaxLeftPadding
(
self
.
input_rect
.
x0
(
)
)
full_image_y_offset
self
.
image_ysize
)
;
}
;
}
template
<
size_t
num_rows
>
void
SetInputCyclicStorage
(
const
Image3F
*
storage
size_t
offset_rows
)
{
input
=
storage
;
input_y_offset
=
offset_rows
;
set_input_rows
=
[
]
(
const
FilterStep
&
self
FilterRows
*
rows
ssize_t
y0
)
{
rows
-
>
SetInput
<
RowMapMod
<
num_rows
>
>
(
*
(
self
.
input
)
self
.
input_y_offset
y0
0
)
;
}
;
}
template
<
size_t
num_rows
>
void
SetOutputCyclicStorage
(
Image3F
*
storage
size_t
offset_rows
)
{
output
=
storage
;
output_y_offset
=
offset_rows
;
set_output_rows
=
[
]
(
const
FilterStep
&
self
FilterRows
*
rows
ssize_t
y0
)
{
rows
-
>
SetOutput
<
RowMapMod
<
num_rows
>
>
(
self
.
output
self
.
output_y_offset
y0
0
)
;
}
;
}
void
SetOutput
(
Image3F
*
im_output
const
Rect
&
output_rect
)
{
output
=
im_output
;
this
-
>
output_rect
=
output_rect
;
set_output_rows
=
[
]
(
const
FilterStep
&
self
FilterRows
*
rows
ssize_t
y0
)
{
rows
-
>
SetOutput
<
RowMapId
>
(
self
.
output
0
self
.
output_rect
.
y0
(
)
+
y0
static_cast
<
ssize_t
>
(
self
.
output_rect
.
x0
(
)
)
-
MaxLeftPadding
(
self
.
output_rect
.
x0
(
)
)
)
;
}
;
}
const
Image3F
*
input
;
size_t
input_y_offset
=
0
;
Image3F
*
output
;
size_t
output_y_offset
=
0
;
Rect
input_rect
;
Rect
output_rect
;
Rect
image_rect
;
size_t
image_ysize
;
void
(
*
set_input_rows
)
(
const
FilterStep
&
FilterRows
*
rows
ssize_t
y0
)
;
void
(
*
set_output_rows
)
(
const
FilterStep
&
FilterRows
*
rows
ssize_t
y0
)
;
FilterDefinition
filter_def
;
size_t
filter_x0
filter_x1
;
size_t
output_col_border
;
}
;
template
<
size_t
border
>
void
AddStep
(
const
FilterDefinition
&
filter_def
)
{
JXL_DASSERT
(
num_filters
<
kMaxFilters
)
;
filters
[
num_filters
]
.
filter_def
=
filter_def
;
if
(
num_filters
>
0
)
{
constexpr
size_t
num_rows
=
2
*
border
+
1
;
filters
[
num_filters
-
1
]
.
SetOutputCyclicStorage
<
num_rows
>
(
&
storage
storage_rows_used
)
;
filters
[
num_filters
]
.
SetInputCyclicStorage
<
num_rows
>
(
&
storage
storage_rows_used
)
;
storage_rows_used
+
=
num_rows
;
JXL_DASSERT
(
storage_rows_used
<
=
kTotalStorageRows
)
;
}
num_filters
+
+
;
}
Image3F
storage
;
size_t
storage_rows_used
=
0
;
static
const
size_t
kMaxFilters
=
4
;
FilterStep
filters
[
kMaxFilters
]
;
size_t
num_filters
=
0
;
bool
compute_sigma
=
false
;
Rect
image_rect
;
size_t
total_border
=
0
;
}
;
}
#
endif
