#
ifndef
LIB_JXL_COLOR_ENCODING_INTERNAL_H_
#
define
LIB_JXL_COLOR_ENCODING_INTERNAL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
cmath
>
#
include
<
ostream
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
jxl
/
color_encoding
.
h
"
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
padded_bytes
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
field_encodings
.
h
"
namespace
jxl
{
enum
class
ColorSpace
:
uint32_t
{
kRGB
kGray
kXYB
kUnknown
}
;
static
inline
const
char
*
EnumName
(
ColorSpace
)
{
return
"
ColorSpace
"
;
}
static
inline
constexpr
uint64_t
EnumBits
(
ColorSpace
)
{
using
CS
=
ColorSpace
;
return
MakeBit
(
CS
:
:
kRGB
)
|
MakeBit
(
CS
:
:
kGray
)
|
MakeBit
(
CS
:
:
kXYB
)
|
MakeBit
(
CS
:
:
kUnknown
)
;
}
enum
class
WhitePoint
:
uint32_t
{
kD65
=
1
kCustom
=
2
kE
=
10
kDCI
=
11
}
;
static
inline
const
char
*
EnumName
(
WhitePoint
)
{
return
"
WhitePoint
"
;
}
static
inline
constexpr
uint64_t
EnumBits
(
WhitePoint
)
{
return
MakeBit
(
WhitePoint
:
:
kD65
)
|
MakeBit
(
WhitePoint
:
:
kCustom
)
|
MakeBit
(
WhitePoint
:
:
kE
)
|
MakeBit
(
WhitePoint
:
:
kDCI
)
;
}
enum
class
Primaries
:
uint32_t
{
kSRGB
=
1
kCustom
=
2
k2100
=
9
kP3
=
11
}
;
static
inline
const
char
*
EnumName
(
Primaries
)
{
return
"
Primaries
"
;
}
static
inline
constexpr
uint64_t
EnumBits
(
Primaries
)
{
using
Pr
=
Primaries
;
return
MakeBit
(
Pr
:
:
kSRGB
)
|
MakeBit
(
Pr
:
:
kCustom
)
|
MakeBit
(
Pr
:
:
k2100
)
|
MakeBit
(
Pr
:
:
kP3
)
;
}
enum
class
TransferFunction
:
uint32_t
{
k709
=
1
kUnknown
=
2
kLinear
=
8
kSRGB
=
13
kPQ
=
16
kDCI
=
17
kHLG
=
18
}
;
static
inline
const
char
*
EnumName
(
TransferFunction
)
{
return
"
TransferFunction
"
;
}
static
inline
constexpr
uint64_t
EnumBits
(
TransferFunction
)
{
using
TF
=
TransferFunction
;
return
MakeBit
(
TF
:
:
k709
)
|
MakeBit
(
TF
:
:
kLinear
)
|
MakeBit
(
TF
:
:
kSRGB
)
|
MakeBit
(
TF
:
:
kPQ
)
|
MakeBit
(
TF
:
:
kDCI
)
|
MakeBit
(
TF
:
:
kHLG
)
|
MakeBit
(
TF
:
:
kUnknown
)
;
}
enum
class
RenderingIntent
:
uint32_t
{
kPerceptual
=
0
kRelative
kSaturation
kAbsolute
}
;
static
inline
const
char
*
EnumName
(
RenderingIntent
)
{
return
"
RenderingIntent
"
;
}
static
inline
constexpr
uint64_t
EnumBits
(
RenderingIntent
)
{
using
RI
=
RenderingIntent
;
return
MakeBit
(
RI
:
:
kPerceptual
)
|
MakeBit
(
RI
:
:
kRelative
)
|
MakeBit
(
RI
:
:
kSaturation
)
|
MakeBit
(
RI
:
:
kAbsolute
)
;
}
struct
CIExy
{
double
x
=
0
.
0
;
double
y
=
0
.
0
;
}
;
struct
PrimariesCIExy
{
CIExy
r
;
CIExy
g
;
CIExy
b
;
}
;
struct
Customxy
:
public
Fields
{
Customxy
(
)
;
JXL_FIELDS_NAME
(
Customxy
)
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
CIExy
Get
(
)
const
;
Status
Set
(
const
CIExy
&
xy
)
;
int32_t
x
;
int32_t
y
;
}
;
struct
CustomTransferFunction
:
public
Fields
{
CustomTransferFunction
(
)
;
JXL_FIELDS_NAME
(
CustomTransferFunction
)
bool
SetImplicit
(
)
;
bool
IsGamma
(
)
const
{
return
have_gamma_
;
}
double
GetGamma
(
)
const
{
JXL_ASSERT
(
IsGamma
(
)
)
;
return
gamma_
*
1E
-
7
;
}
Status
SetGamma
(
double
gamma
)
;
TransferFunction
GetTransferFunction
(
)
const
{
JXL_ASSERT
(
!
IsGamma
(
)
)
;
return
transfer_function_
;
}
void
SetTransferFunction
(
const
TransferFunction
tf
)
{
have_gamma_
=
false
;
transfer_function_
=
tf
;
}
bool
IsUnknown
(
)
const
{
return
!
have_gamma_
&
&
(
transfer_function_
=
=
TransferFunction
:
:
kUnknown
)
;
}
bool
IsSRGB
(
)
const
{
return
!
have_gamma_
&
&
(
transfer_function_
=
=
TransferFunction
:
:
kSRGB
)
;
}
bool
IsLinear
(
)
const
{
return
!
have_gamma_
&
&
(
transfer_function_
=
=
TransferFunction
:
:
kLinear
)
;
}
bool
IsPQ
(
)
const
{
return
!
have_gamma_
&
&
(
transfer_function_
=
=
TransferFunction
:
:
kPQ
)
;
}
bool
IsHLG
(
)
const
{
return
!
have_gamma_
&
&
(
transfer_function_
=
=
TransferFunction
:
:
kHLG
)
;
}
bool
Is709
(
)
const
{
return
!
have_gamma_
&
&
(
transfer_function_
=
=
TransferFunction
:
:
k709
)
;
}
bool
IsDCI
(
)
const
{
return
!
have_gamma_
&
&
(
transfer_function_
=
=
TransferFunction
:
:
kDCI
)
;
}
bool
IsSame
(
const
CustomTransferFunction
&
other
)
const
{
if
(
have_gamma_
!
=
other
.
have_gamma_
)
return
false
;
if
(
have_gamma_
)
{
if
(
gamma_
!
=
other
.
gamma_
)
return
false
;
}
else
{
if
(
transfer_function_
!
=
other
.
transfer_function_
)
return
false
;
}
return
true
;
}
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
ColorSpace
nonserialized_color_space
=
ColorSpace
:
:
kRGB
;
private
:
static
constexpr
uint32_t
kGammaMul
=
10000000
;
bool
have_gamma_
;
uint32_t
gamma_
;
TransferFunction
transfer_function_
;
}
;
struct
ColorEncoding
:
public
Fields
{
ColorEncoding
(
)
;
JXL_FIELDS_NAME
(
ColorEncoding
)
static
const
ColorEncoding
&
SRGB
(
bool
is_gray
=
false
)
;
static
const
ColorEncoding
&
LinearSRGB
(
bool
is_gray
=
false
)
;
Status
CreateICC
(
)
;
const
PaddedBytes
&
ICC
(
)
const
{
return
icc_
;
}
void
InternalRemoveICC
(
)
{
icc_
.
clear
(
)
;
}
Status
SetICC
(
PaddedBytes
&
&
icc
)
{
if
(
icc
.
empty
(
)
)
return
false
;
icc_
=
std
:
:
move
(
icc
)
;
if
(
!
SetFieldsFromICC
(
)
)
{
InternalRemoveICC
(
)
;
return
false
;
}
want_icc_
=
true
;
return
true
;
}
Status
SetICCRaw
(
PaddedBytes
&
&
icc
)
{
if
(
icc
.
empty
(
)
)
return
false
;
icc_
=
std
:
:
move
(
icc
)
;
want_icc_
=
true
;
have_fields_
=
false
;
return
true
;
}
bool
WantICC
(
)
const
{
return
want_icc_
;
}
bool
HaveFields
(
)
const
{
return
have_fields_
;
}
void
DecideIfWantICC
(
)
;
bool
IsGray
(
)
const
{
return
color_space_
=
=
ColorSpace
:
:
kGray
;
}
bool
IsCMYK
(
)
const
{
return
cmyk_
;
}
size_t
Channels
(
)
const
{
return
IsGray
(
)
?
1
:
3
;
}
bool
HasPrimaries
(
)
const
{
return
!
IsGray
(
)
&
&
color_space_
!
=
ColorSpace
:
:
kXYB
;
}
bool
ImplicitWhitePoint
(
)
{
if
(
color_space_
=
=
ColorSpace
:
:
kXYB
)
{
white_point
=
WhitePoint
:
:
kD65
;
return
true
;
}
return
false
;
}
bool
IsSRGB
(
)
const
{
if
(
!
have_fields_
)
return
false
;
if
(
!
IsGray
(
)
&
&
color_space_
!
=
ColorSpace
:
:
kRGB
)
return
false
;
if
(
white_point
!
=
WhitePoint
:
:
kD65
)
return
false
;
if
(
primaries
!
=
Primaries
:
:
kSRGB
)
return
false
;
if
(
!
tf
.
IsSRGB
(
)
)
return
false
;
return
true
;
}
bool
IsLinearSRGB
(
)
const
{
if
(
!
have_fields_
)
return
false
;
if
(
!
IsGray
(
)
&
&
color_space_
!
=
ColorSpace
:
:
kRGB
)
return
false
;
if
(
white_point
!
=
WhitePoint
:
:
kD65
)
return
false
;
if
(
primaries
!
=
Primaries
:
:
kSRGB
)
return
false
;
if
(
!
tf
.
IsLinear
(
)
)
return
false
;
return
true
;
}
Status
SetSRGB
(
const
ColorSpace
cs
const
RenderingIntent
ri
=
RenderingIntent
:
:
kRelative
)
{
InternalRemoveICC
(
)
;
JXL_ASSERT
(
cs
=
=
ColorSpace
:
:
kGray
|
|
cs
=
=
ColorSpace
:
:
kRGB
)
;
color_space_
=
cs
;
white_point
=
WhitePoint
:
:
kD65
;
primaries
=
Primaries
:
:
kSRGB
;
tf
.
SetTransferFunction
(
TransferFunction
:
:
kSRGB
)
;
rendering_intent
=
ri
;
return
CreateICC
(
)
;
}
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
ColorSpace
GetColorSpace
(
)
const
{
return
color_space_
;
}
void
SetColorSpace
(
const
ColorSpace
cs
)
{
color_space_
=
cs
;
tf
.
nonserialized_color_space
=
cs
;
}
CIExy
GetWhitePoint
(
)
const
;
Status
SetWhitePoint
(
const
CIExy
&
xy
)
;
PrimariesCIExy
GetPrimaries
(
)
const
;
Status
SetPrimaries
(
const
PrimariesCIExy
&
xy
)
;
bool
SameColorSpace
(
const
ColorEncoding
&
other
)
const
{
if
(
color_space_
!
=
other
.
color_space_
)
return
false
;
if
(
white_point
!
=
other
.
white_point
)
return
false
;
if
(
white_point
=
=
WhitePoint
:
:
kCustom
)
{
if
(
white_
.
x
!
=
other
.
white_
.
x
|
|
white_
.
y
!
=
other
.
white_
.
y
)
return
false
;
}
if
(
HasPrimaries
(
)
!
=
other
.
HasPrimaries
(
)
)
return
false
;
if
(
HasPrimaries
(
)
)
{
if
(
primaries
!
=
other
.
primaries
)
return
false
;
if
(
primaries
=
=
Primaries
:
:
kCustom
)
{
if
(
red_
.
x
!
=
other
.
red_
.
x
|
|
red_
.
y
!
=
other
.
red_
.
y
)
return
false
;
if
(
green_
.
x
!
=
other
.
green_
.
x
|
|
green_
.
y
!
=
other
.
green_
.
y
)
return
false
;
if
(
blue_
.
x
!
=
other
.
blue_
.
x
|
|
blue_
.
y
!
=
other
.
blue_
.
y
)
return
false
;
}
}
return
true
;
}
bool
SameColorEncoding
(
const
ColorEncoding
&
other
)
const
{
return
SameColorSpace
(
other
)
&
&
tf
.
IsSame
(
other
.
tf
)
;
}
mutable
bool
all_default
;
WhitePoint
white_point
;
Primaries
primaries
;
CustomTransferFunction
tf
;
RenderingIntent
rendering_intent
;
private
:
Status
SetFieldsFromICC
(
)
;
bool
want_icc_
;
bool
have_fields_
=
true
;
PaddedBytes
icc_
;
ColorSpace
color_space_
;
bool
cmyk_
=
false
;
Customxy
white_
;
Customxy
red_
;
Customxy
green_
;
Customxy
blue_
;
}
;
static
inline
bool
ApproxEq
(
const
double
a
const
double
b
#
if
JPEGXL_ENABLE_SKCMS
double
max_l1
=
1E
-
3
)
{
#
else
double
max_l1
=
8E
-
5
)
{
#
endif
return
std
:
:
abs
(
a
-
b
)
<
=
max_l1
;
}
std
:
:
string
Description
(
const
ColorEncoding
&
c
)
;
static
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
ColorEncoding
&
c
)
{
return
os
<
<
Description
(
c
)
;
}
void
ConvertInternalToExternalColorEncoding
(
const
jxl
:
:
ColorEncoding
&
internal
JxlColorEncoding
*
external
)
;
Status
ConvertExternalToInternalColorEncoding
(
const
JxlColorEncoding
&
external
jxl
:
:
ColorEncoding
*
internal
)
;
Status
PrimariesToXYZ
(
float
rx
float
ry
float
gx
float
gy
float
bx
float
by
float
wx
float
wy
float
matrix
[
9
]
)
;
Status
PrimariesToXYZD50
(
float
rx
float
ry
float
gx
float
gy
float
bx
float
by
float
wx
float
wy
float
matrix
[
9
]
)
;
Status
AdaptToXYZD50
(
float
wx
float
wy
float
matrix
[
9
]
)
;
}
#
endif
