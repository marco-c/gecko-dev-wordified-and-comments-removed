#
ifndef
JPEGXL_ENABLE_SKCMS
#
define
JPEGXL_ENABLE_SKCMS
0
#
endif
#
include
"
lib
/
jxl
/
enc_color_management
.
h
"
#
include
<
math
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
atomic
>
#
include
<
memory
>
#
include
<
mutex
>
#
include
<
string
>
#
include
<
utility
>
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
lib
/
jxl
/
enc_color_management
.
cc
"
#
include
<
hwy
/
foreach_target
.
h
>
#
include
<
hwy
/
highway
.
h
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
field_encodings
.
h
"
#
include
"
lib
/
jxl
/
linalg
.
h
"
#
include
"
lib
/
jxl
/
transfer_functions
-
inl
.
h
"
#
if
JPEGXL_ENABLE_SKCMS
#
include
"
lib
/
jxl
/
enc_jxl_skcms
.
h
"
#
else
#
include
"
lcms2
.
h
"
#
include
"
lcms2_plugin
.
h
"
#
endif
#
define
JXL_CMS_VERBOSE
0
#
ifndef
LIB_JXL_ENC_COLOR_MANAGEMENT_CC_
#
define
LIB_JXL_ENC_COLOR_MANAGEMENT_CC_
namespace
jxl
{
#
if
JPEGXL_ENABLE_SKCMS
struct
ColorSpaceTransform
:
:
SkcmsICC
{
PaddedBytes
icc_src_
icc_dst_
;
skcms_ICCProfile
profile_src_
profile_dst_
;
}
;
#
endif
}
#
endif
HWY_BEFORE_NAMESPACE
(
)
;
namespace
jxl
{
namespace
HWY_NAMESPACE
{
#
if
JXL_CMS_VERBOSE
>
=
2
const
size_t
kX
=
0
;
#
endif
void
BeforeTransform
(
ColorSpaceTransform
*
t
const
float
*
buf_src
float
*
xform_src
)
{
switch
(
t
-
>
preprocess_
)
{
case
ExtraTF
:
:
kNone
:
JXL_DASSERT
(
false
)
;
break
;
case
ExtraTF
:
:
kPQ
:
{
HWY_FULL
(
float
)
df
;
const
auto
multiplier
=
Set
(
df
t
-
>
intensity_target_
=
=
10000
.
f
?
1
.
0f
:
10000
.
f
/
t
-
>
intensity_target_
)
;
for
(
size_t
i
=
0
;
i
<
t
-
>
buf_src_
.
xsize
(
)
;
i
+
=
Lanes
(
df
)
)
{
const
auto
val
=
Load
(
df
buf_src
+
i
)
;
const
auto
result
=
multiplier
*
TF_PQ
(
)
.
DisplayFromEncoded
(
df
val
)
;
Store
(
result
df
xform_src
+
i
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
pre
in
%
.
4f
%
.
4f
%
.
4f
undoPQ
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_src
[
3
*
kX
]
buf_src
[
3
*
kX
+
1
]
buf_src
[
3
*
kX
+
2
]
xform_src
[
3
*
kX
]
xform_src
[
3
*
kX
+
1
]
xform_src
[
3
*
kX
+
2
]
)
;
#
endif
break
;
}
case
ExtraTF
:
:
kHLG
:
for
(
size_t
i
=
0
;
i
<
t
-
>
buf_src_
.
xsize
(
)
;
+
+
i
)
{
xform_src
[
i
]
=
static_cast
<
float
>
(
TF_HLG
(
)
.
DisplayFromEncoded
(
static_cast
<
double
>
(
buf_src
[
i
]
)
)
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
pre
in
%
.
4f
%
.
4f
%
.
4f
undoHLG
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_src
[
3
*
kX
]
buf_src
[
3
*
kX
+
1
]
buf_src
[
3
*
kX
+
2
]
xform_src
[
3
*
kX
]
xform_src
[
3
*
kX
+
1
]
xform_src
[
3
*
kX
+
2
]
)
;
#
endif
break
;
case
ExtraTF
:
:
kSRGB
:
HWY_FULL
(
float
)
df
;
for
(
size_t
i
=
0
;
i
<
t
-
>
buf_src_
.
xsize
(
)
;
i
+
=
Lanes
(
df
)
)
{
const
auto
val
=
Load
(
df
buf_src
+
i
)
;
const
auto
result
=
TF_SRGB
(
)
.
DisplayFromEncoded
(
val
)
;
Store
(
result
df
xform_src
+
i
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
pre
in
%
.
4f
%
.
4f
%
.
4f
undoSRGB
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_src
[
3
*
kX
]
buf_src
[
3
*
kX
+
1
]
buf_src
[
3
*
kX
+
2
]
xform_src
[
3
*
kX
]
xform_src
[
3
*
kX
+
1
]
xform_src
[
3
*
kX
+
2
]
)
;
#
endif
break
;
}
}
void
AfterTransform
(
ColorSpaceTransform
*
t
float
*
JXL_RESTRICT
buf_dst
)
{
switch
(
t
-
>
postprocess_
)
{
case
ExtraTF
:
:
kNone
:
JXL_DASSERT
(
false
)
;
break
;
case
ExtraTF
:
:
kPQ
:
{
HWY_FULL
(
float
)
df
;
const
auto
multiplier
=
Set
(
df
t
-
>
intensity_target_
=
=
10000
.
f
?
1
.
0f
:
t
-
>
intensity_target_
*
1e
-
4f
)
;
for
(
size_t
i
=
0
;
i
<
t
-
>
buf_dst_
.
xsize
(
)
;
i
+
=
Lanes
(
df
)
)
{
const
auto
val
=
Load
(
df
buf_dst
+
i
)
;
const
auto
result
=
TF_PQ
(
)
.
EncodedFromDisplay
(
df
multiplier
*
val
)
;
Store
(
result
df
buf_dst
+
i
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
after
PQ
enc
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_dst
[
3
*
kX
]
buf_dst
[
3
*
kX
+
1
]
buf_dst
[
3
*
kX
+
2
]
)
;
#
endif
break
;
}
case
ExtraTF
:
:
kHLG
:
for
(
size_t
i
=
0
;
i
<
t
-
>
buf_dst_
.
xsize
(
)
;
+
+
i
)
{
buf_dst
[
i
]
=
static_cast
<
float
>
(
TF_HLG
(
)
.
EncodedFromDisplay
(
static_cast
<
double
>
(
buf_dst
[
i
]
)
)
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
after
HLG
enc
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_dst
[
3
*
kX
]
buf_dst
[
3
*
kX
+
1
]
buf_dst
[
3
*
kX
+
2
]
)
;
#
endif
break
;
case
ExtraTF
:
:
kSRGB
:
HWY_FULL
(
float
)
df
;
for
(
size_t
i
=
0
;
i
<
t
-
>
buf_dst_
.
xsize
(
)
;
i
+
=
Lanes
(
df
)
)
{
const
auto
val
=
Load
(
df
buf_dst
+
i
)
;
const
auto
result
=
TF_SRGB
(
)
.
EncodedFromDisplay
(
HWY_FULL
(
float
)
(
)
val
)
;
Store
(
result
df
buf_dst
+
i
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
after
SRGB
enc
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_dst
[
3
*
kX
]
buf_dst
[
3
*
kX
+
1
]
buf_dst
[
3
*
kX
+
2
]
)
;
#
endif
break
;
}
}
void
DoColorSpaceTransform
(
ColorSpaceTransform
*
t
const
size_t
thread
const
float
*
buf_src
float
*
buf_dst
)
{
float
*
xform_src
=
const_cast
<
float
*
>
(
buf_src
)
;
if
(
t
-
>
preprocess_
!
=
ExtraTF
:
:
kNone
)
{
xform_src
=
t
-
>
buf_src_
.
Row
(
thread
)
;
BeforeTransform
(
t
buf_src
xform_src
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
const
float
in0
=
xform_src
[
3
*
kX
+
0
]
;
const
float
in1
=
xform_src
[
3
*
kX
+
1
]
;
const
float
in2
=
xform_src
[
3
*
kX
+
2
]
;
#
endif
if
(
t
-
>
skip_lcms_
)
{
if
(
buf_dst
!
=
xform_src
)
{
memcpy
(
buf_dst
xform_src
t
-
>
buf_dst_
.
xsize
(
)
*
sizeof
(
*
buf_dst
)
)
;
}
}
else
{
#
if
JPEGXL_ENABLE_SKCMS
JXL_CHECK
(
skcms_Transform
(
xform_src
skcms_PixelFormat_RGB_fff
skcms_AlphaFormat_Opaque
&
t
-
>
skcms_icc_
-
>
profile_src_
buf_dst
skcms_PixelFormat_RGB_fff
skcms_AlphaFormat_Opaque
&
t
-
>
skcms_icc_
-
>
profile_dst_
t
-
>
xsize_
)
)
;
#
else
cmsDoTransform
(
t
-
>
lcms_transform_
xform_src
buf_dst
static_cast
<
cmsUInt32Number
>
(
t
-
>
xsize_
)
)
;
#
endif
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
xform
skip
%
d
:
%
.
4f
%
.
4f
%
.
4f
(
%
p
)
-
>
(
%
p
)
%
.
4f
%
.
4f
%
.
4f
\
n
"
t
-
>
skip_lcms_
in0
in1
in2
xform_src
buf_dst
buf_dst
[
3
*
kX
]
buf_dst
[
3
*
kX
+
1
]
buf_dst
[
3
*
kX
+
2
]
)
;
#
endif
if
(
t
-
>
postprocess_
!
=
ExtraTF
:
:
kNone
)
{
AfterTransform
(
t
buf_dst
)
;
}
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
jxl
{
HWY_EXPORT
(
DoColorSpaceTransform
)
;
void
DoColorSpaceTransform
(
ColorSpaceTransform
*
t
size_t
thread
const
float
*
buf_src
float
*
buf_dst
)
{
return
HWY_DYNAMIC_DISPATCH
(
DoColorSpaceTransform
)
(
t
thread
buf_src
buf_dst
)
;
}
namespace
{
#
define
JXL_CMS_OLD_VERSION
0
static
std
:
:
mutex
&
LcmsMutex
(
)
{
static
std
:
:
mutex
m
;
return
m
;
}
#
if
JPEGXL_ENABLE_SKCMS
JXL_MUST_USE_RESULT
CIExy
CIExyFromXYZ
(
const
float
XYZ
[
3
]
)
{
const
float
factor
=
1
.
f
/
(
XYZ
[
0
]
+
XYZ
[
1
]
+
XYZ
[
2
]
)
;
CIExy
xy
;
xy
.
x
=
XYZ
[
0
]
*
factor
;
xy
.
y
=
XYZ
[
1
]
*
factor
;
return
xy
;
}
#
else
JXL_MUST_USE_RESULT
CIExy
CIExyFromxyY
(
const
cmsCIExyY
&
xyY
)
{
CIExy
xy
;
xy
.
x
=
xyY
.
x
;
xy
.
y
=
xyY
.
y
;
return
xy
;
}
JXL_MUST_USE_RESULT
CIExy
CIExyFromXYZ
(
const
cmsCIEXYZ
&
XYZ
)
{
cmsCIExyY
xyY
;
cmsXYZ2xyY
(
&
xyY
&
XYZ
)
;
return
CIExyFromxyY
(
xyY
)
;
}
JXL_MUST_USE_RESULT
cmsCIEXYZ
D50_XYZ
(
)
{
return
{
0
.
96420288
1
.
0
0
.
82490540
}
;
}
JXL_MUST_USE_RESULT
cmsCIExyY
xyYFromCIExy
(
const
CIExy
&
xy
)
{
const
cmsCIExyY
xyY
=
{
xy
.
x
xy
.
y
1
.
0
}
;
return
xyY
;
}
struct
ProfileDeleter
{
void
operator
(
)
(
void
*
p
)
{
cmsCloseProfile
(
p
)
;
}
}
;
using
Profile
=
std
:
:
unique_ptr
<
void
ProfileDeleter
>
;
struct
TransformDeleter
{
void
operator
(
)
(
void
*
p
)
{
cmsDeleteTransform
(
p
)
;
}
}
;
using
Transform
=
std
:
:
unique_ptr
<
void
TransformDeleter
>
;
struct
CurveDeleter
{
void
operator
(
)
(
cmsToneCurve
*
p
)
{
cmsFreeToneCurve
(
p
)
;
}
}
;
using
Curve
=
std
:
:
unique_ptr
<
cmsToneCurve
CurveDeleter
>
;
Status
CreateProfileXYZ
(
const
cmsContext
context
Profile
*
JXL_RESTRICT
profile
)
{
profile
-
>
reset
(
cmsCreateXYZProfileTHR
(
context
)
)
;
if
(
profile
-
>
get
(
)
=
=
nullptr
)
return
JXL_FAILURE
(
"
Failed
to
create
XYZ
"
)
;
return
true
;
}
#
endif
#
if
JPEGXL_ENABLE_SKCMS
Status
DecodeProfile
(
const
PaddedBytes
&
icc
skcms_ICCProfile
*
const
profile
)
{
if
(
!
skcms_Parse
(
icc
.
data
(
)
icc
.
size
(
)
profile
)
)
{
return
JXL_FAILURE
(
"
Failed
to
parse
ICC
profile
with
%
zu
bytes
"
icc
.
size
(
)
)
;
}
return
true
;
}
#
else
Status
DecodeProfile
(
const
cmsContext
context
const
PaddedBytes
&
icc
Profile
*
profile
)
{
profile
-
>
reset
(
cmsOpenProfileFromMemTHR
(
context
icc
.
data
(
)
icc
.
size
(
)
)
)
;
if
(
profile
-
>
get
(
)
=
=
nullptr
)
{
return
JXL_FAILURE
(
"
Failed
to
decode
profile
"
)
;
}
return
true
;
}
#
endif
#
if
JPEGXL_ENABLE_SKCMS
ColorSpace
ColorSpaceFromProfile
(
const
skcms_ICCProfile
&
profile
)
{
switch
(
profile
.
data_color_space
)
{
case
skcms_Signature_RGB
:
return
ColorSpace
:
:
kRGB
;
case
skcms_Signature_Gray
:
return
ColorSpace
:
:
kGray
;
default
:
return
ColorSpace
:
:
kUnknown
;
}
}
Status
ProfileEquivalentToICC
(
const
skcms_ICCProfile
&
profile1
const
PaddedBytes
&
icc
)
{
skcms_ICCProfile
profile2
;
JXL_RETURN_IF_ERROR
(
skcms_Parse
(
icc
.
data
(
)
icc
.
size
(
)
&
profile2
)
)
;
return
skcms_ApproximatelyEqualProfiles
(
&
profile1
&
profile2
)
;
}
void
MatrixProduct
(
const
skcms_Matrix3x3
&
matrix
const
float
vector_in
[
3
]
float
vector_out
[
3
]
)
{
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
vector_out
[
i
]
=
0
;
for
(
int
j
=
0
;
j
<
3
;
+
+
j
)
{
vector_out
[
i
]
+
=
matrix
.
vals
[
i
]
[
j
]
*
vector_in
[
j
]
;
}
}
}
JXL_MUST_USE_RESULT
Status
UnadaptedWhitePoint
(
const
skcms_ICCProfile
&
profile
CIExy
*
out
)
{
float
media_white_point_XYZ
[
3
]
;
if
(
!
skcms_GetWTPT
(
&
profile
media_white_point_XYZ
)
)
{
return
JXL_FAILURE
(
"
ICC
profile
does
not
contain
WhitePoint
tag
"
)
;
}
skcms_Matrix3x3
CHAD
;
if
(
!
skcms_GetCHAD
(
&
profile
&
CHAD
)
)
{
*
out
=
CIExyFromXYZ
(
media_white_point_XYZ
)
;
return
true
;
}
skcms_Matrix3x3
inverse_CHAD
;
if
(
!
skcms_Matrix3x3_invert
(
&
CHAD
&
inverse_CHAD
)
)
{
return
JXL_FAILURE
(
"
Non
-
invertible
ChromaticAdaptation
matrix
"
)
;
}
float
unadapted_white_point_XYZ
[
3
]
;
MatrixProduct
(
inverse_CHAD
media_white_point_XYZ
unadapted_white_point_XYZ
)
;
*
out
=
CIExyFromXYZ
(
unadapted_white_point_XYZ
)
;
return
true
;
}
Status
IdentifyPrimaries
(
const
skcms_ICCProfile
&
profile
const
CIExy
&
wp_unadapted
ColorEncoding
*
c
)
{
if
(
!
c
-
>
HasPrimaries
(
)
)
return
true
;
skcms_Matrix3x3
CHAD
inverse_CHAD
;
if
(
skcms_GetCHAD
(
&
profile
&
CHAD
)
)
{
JXL_RETURN_IF_ERROR
(
skcms_Matrix3x3_invert
(
&
CHAD
&
inverse_CHAD
)
)
;
}
else
{
static
constexpr
skcms_Matrix3x3
kLMSFromXYZ
=
{
{
{
0
.
8951
0
.
2664
-
0
.
1614
}
{
-
0
.
7502
1
.
7135
0
.
0367
}
{
0
.
0389
-
0
.
0685
1
.
0296
}
}
}
;
static
constexpr
skcms_Matrix3x3
kXYZFromLMS
=
{
{
{
0
.
9869929
-
0
.
1470543
0
.
1599627
}
{
0
.
4323053
0
.
5183603
0
.
0492912
}
{
-
0
.
0085287
0
.
0400428
0
.
9684867
}
}
}
;
static
constexpr
float
kWpD50XYZ
[
3
]
=
{
0
.
96420288
1
.
0
0
.
82490540
}
;
float
wp_unadapted_XYZ
[
3
]
;
JXL_RETURN_IF_ERROR
(
CIEXYZFromWhiteCIExy
(
wp_unadapted
wp_unadapted_XYZ
)
)
;
float
wp_D50_LMS
[
3
]
wp_unadapted_LMS
[
3
]
;
MatrixProduct
(
kLMSFromXYZ
kWpD50XYZ
wp_D50_LMS
)
;
MatrixProduct
(
kLMSFromXYZ
wp_unadapted_XYZ
wp_unadapted_LMS
)
;
inverse_CHAD
=
{
{
{
wp_unadapted_LMS
[
0
]
/
wp_D50_LMS
[
0
]
0
0
}
{
0
wp_unadapted_LMS
[
1
]
/
wp_D50_LMS
[
1
]
0
}
{
0
0
wp_unadapted_LMS
[
2
]
/
wp_D50_LMS
[
2
]
}
}
}
;
inverse_CHAD
=
skcms_Matrix3x3_concat
(
&
kXYZFromLMS
&
inverse_CHAD
)
;
inverse_CHAD
=
skcms_Matrix3x3_concat
(
&
inverse_CHAD
&
kLMSFromXYZ
)
;
}
float
XYZ
[
3
]
;
PrimariesCIExy
primaries
;
CIExy
*
const
chromaticities
[
]
=
{
&
primaries
.
r
&
primaries
.
g
&
primaries
.
b
}
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
float
RGB
[
3
]
=
{
}
;
RGB
[
i
]
=
1
;
skcms_Transform
(
RGB
skcms_PixelFormat_RGB_fff
skcms_AlphaFormat_Opaque
&
profile
XYZ
skcms_PixelFormat_RGB_fff
skcms_AlphaFormat_Opaque
skcms_XYZD50_profile
(
)
1
)
;
float
unadapted_XYZ
[
3
]
;
MatrixProduct
(
inverse_CHAD
XYZ
unadapted_XYZ
)
;
*
chromaticities
[
i
]
=
CIExyFromXYZ
(
unadapted_XYZ
)
;
}
return
c
-
>
SetPrimaries
(
primaries
)
;
}
void
DetectTransferFunction
(
const
skcms_ICCProfile
&
profile
ColorEncoding
*
JXL_RESTRICT
c
)
{
if
(
c
-
>
tf
.
SetImplicit
(
)
)
return
;
for
(
TransferFunction
tf
:
Values
<
TransferFunction
>
(
)
)
{
if
(
tf
=
=
TransferFunction
:
:
kUnknown
)
continue
;
c
-
>
tf
.
SetTransferFunction
(
tf
)
;
skcms_ICCProfile
profile_test
;
PaddedBytes
bytes
;
if
(
MaybeCreateProfile
(
*
c
&
bytes
)
&
&
DecodeProfile
(
bytes
&
profile_test
)
&
&
skcms_ApproximatelyEqualProfiles
(
&
profile
&
profile_test
)
)
{
return
;
}
}
c
-
>
tf
.
SetTransferFunction
(
TransferFunction
:
:
kUnknown
)
;
}
#
else
uint32_t
Type32
(
const
ColorEncoding
&
c
)
{
if
(
c
.
IsGray
(
)
)
return
TYPE_GRAY_FLT
;
return
TYPE_RGB_FLT
;
}
uint32_t
Type64
(
const
ColorEncoding
&
c
)
{
if
(
c
.
IsGray
(
)
)
return
TYPE_GRAY_DBL
;
return
TYPE_RGB_DBL
;
}
ColorSpace
ColorSpaceFromProfile
(
const
Profile
&
profile
)
{
switch
(
cmsGetColorSpace
(
profile
.
get
(
)
)
)
{
case
cmsSigRgbData
:
return
ColorSpace
:
:
kRGB
;
case
cmsSigGrayData
:
return
ColorSpace
:
:
kGray
;
default
:
return
ColorSpace
:
:
kUnknown
;
}
}
Status
ProfileEquivalentToICC
(
const
cmsContext
context
const
Profile
&
profile1
const
PaddedBytes
&
icc
const
ColorEncoding
&
c
)
{
const
uint32_t
type_src
=
Type64
(
c
)
;
Profile
profile2
;
JXL_RETURN_IF_ERROR
(
DecodeProfile
(
context
icc
&
profile2
)
)
;
Profile
profile_xyz
;
JXL_RETURN_IF_ERROR
(
CreateProfileXYZ
(
context
&
profile_xyz
)
)
;
const
uint32_t
intent
=
INTENT_RELATIVE_COLORIMETRIC
;
const
uint32_t
flags
=
cmsFLAGS_NOOPTIMIZE
|
cmsFLAGS_BLACKPOINTCOMPENSATION
|
cmsFLAGS_HIGHRESPRECALC
;
Transform
xform1
(
cmsCreateTransformTHR
(
context
profile1
.
get
(
)
type_src
profile_xyz
.
get
(
)
TYPE_XYZ_DBL
intent
flags
)
)
;
Transform
xform2
(
cmsCreateTransformTHR
(
context
profile2
.
get
(
)
type_src
profile_xyz
.
get
(
)
TYPE_XYZ_DBL
intent
flags
)
)
;
if
(
xform1
=
=
nullptr
|
|
xform2
=
=
nullptr
)
{
return
JXL_FAILURE
(
"
Failed
to
create
transform
"
)
;
}
double
in
[
3
]
;
double
out1
[
3
]
;
double
out2
[
3
]
;
const
double
init
=
1E
-
3
;
const
double
step
=
0
.
2
;
if
(
c
.
IsGray
(
)
)
{
for
(
in
[
0
]
=
init
;
in
[
0
]
<
1
.
0
;
in
[
0
]
+
=
step
/
8
)
{
cmsDoTransform
(
xform1
.
get
(
)
in
out1
1
)
;
cmsDoTransform
(
xform2
.
get
(
)
in
out2
1
)
;
if
(
!
ApproxEq
(
out1
[
0
]
out2
[
0
]
2E
-
4
)
)
{
return
false
;
}
}
}
else
{
for
(
in
[
0
]
=
init
;
in
[
0
]
<
1
.
0
;
in
[
0
]
+
=
step
)
{
for
(
in
[
1
]
=
init
;
in
[
1
]
<
1
.
0
;
in
[
1
]
+
=
step
)
{
for
(
in
[
2
]
=
init
;
in
[
2
]
<
1
.
0
;
in
[
2
]
+
=
step
)
{
cmsDoTransform
(
xform1
.
get
(
)
in
out1
1
)
;
cmsDoTransform
(
xform2
.
get
(
)
in
out2
1
)
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
if
(
!
ApproxEq
(
out1
[
i
]
out2
[
i
]
2E
-
4
)
)
{
return
false
;
}
}
}
}
}
}
return
true
;
}
JXL_MUST_USE_RESULT
cmsCIEXYZ
UnadaptedWhitePoint
(
const
cmsContext
context
const
Profile
&
profile
const
ColorEncoding
&
c
)
{
cmsCIEXYZ
XYZ
=
{
1
.
0
1
.
0
1
.
0
}
;
Profile
profile_xyz
;
if
(
!
CreateProfileXYZ
(
context
&
profile_xyz
)
)
return
XYZ
;
cmsHPROFILE
profiles
[
2
]
=
{
profile
.
get
(
)
profile_xyz
.
get
(
)
}
;
cmsUInt32Number
intents
[
2
]
=
{
INTENT_ABSOLUTE_COLORIMETRIC
INTENT_ABSOLUTE_COLORIMETRIC
}
;
cmsBool
black_compensation
[
2
]
=
{
0
0
}
;
cmsFloat64Number
adaption
[
2
]
=
{
0
.
0
0
.
0
}
;
cmsUInt32Number
flags
=
cmsFLAGS_NOOPTIMIZE
|
cmsFLAGS_HIGHRESPRECALC
;
Transform
xform
(
cmsCreateExtendedTransform
(
context
2
profiles
black_compensation
intents
adaption
nullptr
0
Type64
(
c
)
TYPE_XYZ_DBL
flags
)
)
;
if
(
!
xform
)
return
XYZ
;
const
cmsFloat64Number
in
[
3
]
=
{
1
.
0
1
.
0
1
.
0
}
;
cmsDoTransform
(
xform
.
get
(
)
in
&
XYZ
.
X
1
)
;
return
XYZ
;
}
Status
IdentifyPrimaries
(
const
Profile
&
profile
const
cmsCIEXYZ
&
wp_unadapted
ColorEncoding
*
c
)
{
if
(
!
c
-
>
HasPrimaries
(
)
)
return
true
;
if
(
ColorSpaceFromProfile
(
profile
)
=
=
ColorSpace
:
:
kUnknown
)
return
true
;
const
cmsCIEXYZ
*
adapted_r
=
static_cast
<
const
cmsCIEXYZ
*
>
(
cmsReadTag
(
profile
.
get
(
)
cmsSigRedColorantTag
)
)
;
const
cmsCIEXYZ
*
adapted_g
=
static_cast
<
const
cmsCIEXYZ
*
>
(
cmsReadTag
(
profile
.
get
(
)
cmsSigGreenColorantTag
)
)
;
const
cmsCIEXYZ
*
adapted_b
=
static_cast
<
const
cmsCIEXYZ
*
>
(
cmsReadTag
(
profile
.
get
(
)
cmsSigBlueColorantTag
)
)
;
if
(
adapted_r
=
=
nullptr
|
|
adapted_g
=
=
nullptr
|
|
adapted_b
=
=
nullptr
)
{
return
JXL_FAILURE
(
"
Failed
to
retrieve
colorants
"
)
;
}
const
cmsCIEXYZ
d50
=
D50_XYZ
(
)
;
cmsCIEXYZ
r
g
b
;
cmsAdaptToIlluminant
(
&
r
&
d50
&
wp_unadapted
adapted_r
)
;
cmsAdaptToIlluminant
(
&
g
&
d50
&
wp_unadapted
adapted_g
)
;
cmsAdaptToIlluminant
(
&
b
&
d50
&
wp_unadapted
adapted_b
)
;
const
PrimariesCIExy
rgb
=
{
CIExyFromXYZ
(
r
)
CIExyFromXYZ
(
g
)
CIExyFromXYZ
(
b
)
}
;
return
c
-
>
SetPrimaries
(
rgb
)
;
}
void
DetectTransferFunction
(
const
cmsContext
context
const
Profile
&
profile
ColorEncoding
*
JXL_RESTRICT
c
)
{
if
(
c
-
>
tf
.
SetImplicit
(
)
)
return
;
for
(
TransferFunction
tf
:
Values
<
TransferFunction
>
(
)
)
{
if
(
tf
=
=
TransferFunction
:
:
kUnknown
)
continue
;
c
-
>
tf
.
SetTransferFunction
(
tf
)
;
PaddedBytes
icc_test
;
if
(
MaybeCreateProfile
(
*
c
&
icc_test
)
&
&
ProfileEquivalentToICC
(
context
profile
icc_test
*
c
)
)
{
return
;
}
}
c
-
>
tf
.
SetTransferFunction
(
TransferFunction
:
:
kUnknown
)
;
}
void
ErrorHandler
(
cmsContext
context
cmsUInt32Number
code
const
char
*
text
)
{
JXL_WARNING
(
"
LCMS
error
%
u
:
%
s
"
code
text
)
;
}
cmsContext
GetContext
(
)
{
static
thread_local
void
*
context_
;
if
(
context_
=
=
nullptr
)
{
context_
=
cmsCreateContext
(
nullptr
nullptr
)
;
JXL_ASSERT
(
context_
!
=
nullptr
)
;
cmsSetLogErrorHandlerTHR
(
static_cast
<
cmsContext
>
(
context_
)
&
ErrorHandler
)
;
}
return
static_cast
<
cmsContext
>
(
context_
)
;
}
#
endif
}
Status
ColorEncoding
:
:
SetFieldsFromICC
(
)
{
SetColorSpace
(
ColorSpace
:
:
kUnknown
)
;
tf
.
SetTransferFunction
(
TransferFunction
:
:
kUnknown
)
;
if
(
icc_
.
empty
(
)
)
return
JXL_FAILURE
(
"
Empty
ICC
profile
"
)
;
#
if
JPEGXL_ENABLE_SKCMS
if
(
icc_
.
size
(
)
<
128
)
{
return
JXL_FAILURE
(
"
ICC
file
too
small
"
)
;
}
skcms_ICCProfile
profile
;
JXL_RETURN_IF_ERROR
(
skcms_Parse
(
icc_
.
data
(
)
icc_
.
size
(
)
&
profile
)
)
;
uint32_t
rendering_intent32
=
icc_
[
67
]
;
if
(
rendering_intent32
>
3
|
|
icc_
[
64
]
!
=
0
|
|
icc_
[
65
]
!
=
0
|
|
icc_
[
66
]
!
=
0
)
{
return
JXL_FAILURE
(
"
Invalid
rendering
intent
%
u
\
n
"
rendering_intent32
)
;
}
SetColorSpace
(
ColorSpaceFromProfile
(
profile
)
)
;
CIExy
wp_unadapted
;
JXL_RETURN_IF_ERROR
(
UnadaptedWhitePoint
(
profile
&
wp_unadapted
)
)
;
JXL_RETURN_IF_ERROR
(
SetWhitePoint
(
wp_unadapted
)
)
;
JXL_RETURN_IF_ERROR
(
IdentifyPrimaries
(
profile
wp_unadapted
this
)
)
;
DetectTransferFunction
(
profile
this
)
;
rendering_intent
=
static_cast
<
RenderingIntent
>
(
rendering_intent32
)
;
#
else
std
:
:
lock_guard
<
std
:
:
mutex
>
guard
(
LcmsMutex
(
)
)
;
const
cmsContext
context
=
GetContext
(
)
;
Profile
profile
;
JXL_RETURN_IF_ERROR
(
DecodeProfile
(
context
icc_
&
profile
)
)
;
const
cmsUInt32Number
rendering_intent32
=
cmsGetHeaderRenderingIntent
(
profile
.
get
(
)
)
;
if
(
rendering_intent32
>
3
)
{
return
JXL_FAILURE
(
"
Invalid
rendering
intent
%
u
\
n
"
rendering_intent32
)
;
}
SetColorSpace
(
ColorSpaceFromProfile
(
profile
)
)
;
const
cmsCIEXYZ
wp_unadapted
=
UnadaptedWhitePoint
(
context
profile
*
this
)
;
JXL_RETURN_IF_ERROR
(
SetWhitePoint
(
CIExyFromXYZ
(
wp_unadapted
)
)
)
;
JXL_RETURN_IF_ERROR
(
IdentifyPrimaries
(
profile
wp_unadapted
this
)
)
;
DetectTransferFunction
(
context
profile
this
)
;
rendering_intent
=
static_cast
<
RenderingIntent
>
(
rendering_intent32
)
;
#
endif
return
true
;
}
void
ColorEncoding
:
:
DecideIfWantICC
(
)
{
PaddedBytes
icc_new
;
bool
equivalent
;
#
if
JPEGXL_ENABLE_SKCMS
skcms_ICCProfile
profile
;
if
(
!
DecodeProfile
(
ICC
(
)
&
profile
)
)
return
;
if
(
!
MaybeCreateProfile
(
*
this
&
icc_new
)
)
return
;
equivalent
=
ProfileEquivalentToICC
(
profile
icc_new
)
;
#
else
const
cmsContext
context
=
GetContext
(
)
;
Profile
profile
;
if
(
!
DecodeProfile
(
context
ICC
(
)
&
profile
)
)
return
;
if
(
!
MaybeCreateProfile
(
*
this
&
icc_new
)
)
return
;
equivalent
=
ProfileEquivalentToICC
(
context
profile
icc_new
*
this
)
;
#
endif
JXL_ASSERT
(
equivalent
)
;
want_icc_
=
false
;
}
ColorSpaceTransform
:
:
~
ColorSpaceTransform
(
)
{
#
if
!
JPEGXL_ENABLE_SKCMS
std
:
:
lock_guard
<
std
:
:
mutex
>
guard
(
LcmsMutex
(
)
)
;
TransformDeleter
(
)
(
lcms_transform_
)
;
#
endif
}
ColorSpaceTransform
:
:
ColorSpaceTransform
(
)
#
if
JPEGXL_ENABLE_SKCMS
:
skcms_icc_
(
new
SkcmsICC
(
)
)
#
endif
{
}
Status
ColorSpaceTransform
:
:
Init
(
const
ColorEncoding
&
c_src
const
ColorEncoding
&
c_dst
float
intensity_target
size_t
xsize
const
size_t
num_threads
)
{
std
:
:
lock_guard
<
std
:
:
mutex
>
guard
(
LcmsMutex
(
)
)
;
#
if
JXL_CMS_VERBOSE
printf
(
"
%
s
-
>
%
s
\
n
"
Description
(
c_src
)
.
c_str
(
)
Description
(
c_dst
)
.
c_str
(
)
)
;
#
endif
#
if
JPEGXL_ENABLE_SKCMS
skcms_icc_
-
>
icc_src_
=
c_src
.
ICC
(
)
;
skcms_icc_
-
>
icc_dst_
=
c_dst
.
ICC
(
)
;
JXL_RETURN_IF_ERROR
(
DecodeProfile
(
skcms_icc_
-
>
icc_src_
&
skcms_icc_
-
>
profile_src_
)
)
;
JXL_RETURN_IF_ERROR
(
DecodeProfile
(
skcms_icc_
-
>
icc_dst_
&
skcms_icc_
-
>
profile_dst_
)
)
;
#
else
const
cmsContext
context
=
GetContext
(
)
;
Profile
profile_src
profile_dst
;
JXL_RETURN_IF_ERROR
(
DecodeProfile
(
context
c_src
.
ICC
(
)
&
profile_src
)
)
;
JXL_RETURN_IF_ERROR
(
DecodeProfile
(
context
c_dst
.
ICC
(
)
&
profile_dst
)
)
;
#
endif
skip_lcms_
=
false
;
if
(
c_src
.
SameColorEncoding
(
c_dst
)
)
{
skip_lcms_
=
true
;
#
if
JXL_CMS_VERBOSE
printf
(
"
Skip
CMS
\
n
"
)
;
#
endif
}
const
bool
src_linear
=
c_src
.
tf
.
IsLinear
(
)
;
const
bool
dst_linear
=
c_dst
.
tf
.
IsLinear
(
)
;
if
(
(
(
c_src
.
tf
.
IsPQ
(
)
|
|
c_src
.
tf
.
IsHLG
(
)
)
&
&
dst_linear
)
|
|
(
(
c_dst
.
tf
.
IsPQ
(
)
|
|
c_dst
.
tf
.
IsHLG
(
)
)
&
&
src_linear
)
|
|
(
(
c_src
.
tf
.
IsPQ
(
)
!
=
c_dst
.
tf
.
IsPQ
(
)
)
&
&
intensity_target_
!
=
10000
)
|
|
(
c_src
.
tf
.
IsSRGB
(
)
&
&
dst_linear
)
|
|
(
c_dst
.
tf
.
IsSRGB
(
)
&
&
src_linear
)
)
{
ColorEncoding
c_linear_src
=
c_src
;
ColorEncoding
c_linear_dst
=
c_dst
;
c_linear_src
.
tf
.
SetTransferFunction
(
TransferFunction
:
:
kLinear
)
;
c_linear_dst
.
tf
.
SetTransferFunction
(
TransferFunction
:
:
kLinear
)
;
PaddedBytes
icc_src
icc_dst
;
#
if
JPEGXL_ENABLE_SKCMS
skcms_ICCProfile
new_src
new_dst
;
#
else
Profile
new_src
new_dst
;
#
endif
if
(
MaybeCreateProfile
(
c_linear_src
&
icc_src
)
&
&
MaybeCreateProfile
(
c_linear_dst
&
icc_dst
)
&
&
#
if
JPEGXL_ENABLE_SKCMS
DecodeProfile
(
icc_src
&
new_src
)
&
&
DecodeProfile
(
icc_dst
&
new_dst
)
)
{
#
else
DecodeProfile
(
context
icc_src
&
new_src
)
&
&
DecodeProfile
(
context
icc_dst
&
new_dst
)
)
{
#
endif
if
(
c_src
.
SameColorSpace
(
c_dst
)
)
{
skip_lcms_
=
true
;
}
#
if
JXL_CMS_VERBOSE
printf
(
"
Special
linear
<
-
>
HLG
/
PQ
/
sRGB
;
skip
=
%
d
\
n
"
skip_lcms_
)
;
#
endif
#
if
JPEGXL_ENABLE_SKCMS
skcms_icc_
-
>
icc_src_
=
PaddedBytes
(
)
;
skcms_icc_
-
>
profile_src_
=
new_src
;
skcms_icc_
-
>
icc_dst_
=
PaddedBytes
(
)
;
skcms_icc_
-
>
profile_dst_
=
new_dst
;
#
else
profile_src
.
swap
(
new_src
)
;
profile_dst
.
swap
(
new_dst
)
;
#
endif
if
(
!
c_src
.
tf
.
IsLinear
(
)
)
{
preprocess_
=
c_src
.
tf
.
IsSRGB
(
)
?
ExtraTF
:
:
kSRGB
:
(
c_src
.
tf
.
IsPQ
(
)
?
ExtraTF
:
:
kPQ
:
ExtraTF
:
:
kHLG
)
;
}
if
(
!
c_dst
.
tf
.
IsLinear
(
)
)
{
postprocess_
=
c_dst
.
tf
.
IsSRGB
(
)
?
ExtraTF
:
:
kSRGB
:
(
c_dst
.
tf
.
IsPQ
(
)
?
ExtraTF
:
:
kPQ
:
ExtraTF
:
:
kHLG
)
;
}
}
else
{
JXL_WARNING
(
"
Failed
to
create
extra
linear
profiles
"
)
;
}
}
#
if
JPEGXL_ENABLE_SKCMS
if
(
!
skcms_MakeUsableAsDestination
(
&
skcms_icc_
-
>
profile_dst_
)
)
{
return
JXL_FAILURE
(
"
Failed
to
make
%
s
usable
as
a
color
transform
destination
"
Description
(
c_dst
)
.
c_str
(
)
)
;
}
#
endif
const
size_t
channels_src
=
c_src
.
Channels
(
)
;
const
size_t
channels_dst
=
c_dst
.
Channels
(
)
;
JXL_CHECK
(
channels_src
=
=
channels_dst
)
;
#
if
JXL_CMS_VERBOSE
printf
(
"
Channels
:
%
zu
;
Threads
:
%
zu
\
n
"
channels_src
num_threads
)
;
#
endif
#
if
!
JPEGXL_ENABLE_SKCMS
const
uint32_t
type_src
=
Type32
(
c_src
)
;
const
uint32_t
type_dst
=
Type32
(
c_dst
)
;
const
uint32_t
intent
=
static_cast
<
uint32_t
>
(
c_dst
.
rendering_intent
)
;
const
uint32_t
flags
=
cmsFLAGS_NOCACHE
|
cmsFLAGS_BLACKPOINTCOMPENSATION
|
cmsFLAGS_HIGHRESPRECALC
;
lcms_transform_
=
cmsCreateTransformTHR
(
context
profile_src
.
get
(
)
type_src
profile_dst
.
get
(
)
type_dst
intent
flags
)
;
if
(
lcms_transform_
=
=
nullptr
)
{
return
JXL_FAILURE
(
"
Failed
to
create
transform
"
)
;
}
#
endif
#
if
JPEGXL_ENABLE_SKCMS
buf_src_
=
ImageF
(
xsize
*
3
num_threads
)
;
buf_dst_
=
ImageF
(
xsize
*
3
num_threads
)
;
#
else
buf_src_
=
ImageF
(
xsize
*
channels_src
num_threads
)
;
buf_dst_
=
ImageF
(
xsize
*
channels_dst
num_threads
)
;
#
endif
intensity_target_
=
intensity_target
;
xsize_
=
xsize
;
return
true
;
}
}
#
endif
