#
include
"
lib
/
jxl
/
enc_color_management
.
h
"
#
ifndef
JPEGXL_ENABLE_SKCMS
#
define
JPEGXL_ENABLE_SKCMS
0
#
endif
#
include
<
math
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
atomic
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
lib
/
jxl
/
enc_color_management
.
cc
"
#
include
<
hwy
/
foreach_target
.
h
>
#
include
<
hwy
/
highway
.
h
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
base
/
printf_macros
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
field_encodings
.
h
"
#
include
"
lib
/
jxl
/
linalg
.
h
"
#
include
"
lib
/
jxl
/
transfer_functions
-
inl
.
h
"
#
if
JPEGXL_ENABLE_SKCMS
#
include
"
lib
/
jxl
/
enc_jxl_skcms
.
h
"
#
else
#
include
"
lcms2
.
h
"
#
include
"
lcms2_plugin
.
h
"
#
endif
#
define
JXL_CMS_VERBOSE
0
#
ifndef
LIB_JXL_ENC_COLOR_MANAGEMENT_CC_
#
define
LIB_JXL_ENC_COLOR_MANAGEMENT_CC_
namespace
jxl
{
namespace
{
struct
JxlCms
{
#
if
JPEGXL_ENABLE_SKCMS
PaddedBytes
icc_src
icc_dst
;
skcms_ICCProfile
profile_src
profile_dst
;
#
else
void
*
lcms_transform
;
#
endif
bool
apply_hlg_ootf
;
size_t
hlg_ootf_num_channels
;
std
:
:
array
<
float
3
>
hlg_ootf_luminances
;
size_t
channels_src
;
size_t
channels_dst
;
ImageF
buf_src
;
ImageF
buf_dst
;
float
intensity_target
;
bool
skip_lcms
=
false
;
ExtraTF
preprocess
=
ExtraTF
:
:
kNone
;
ExtraTF
postprocess
=
ExtraTF
:
:
kNone
;
}
;
Status
ApplyHlgOotf
(
JxlCms
*
t
float
*
JXL_RESTRICT
buf
size_t
xsize
bool
forward
)
;
}
}
#
endif
HWY_BEFORE_NAMESPACE
(
)
;
namespace
jxl
{
namespace
HWY_NAMESPACE
{
#
if
JXL_CMS_VERBOSE
>
=
2
const
size_t
kX
=
0
;
#
endif
Status
BeforeTransform
(
JxlCms
*
t
const
float
*
buf_src
float
*
xform_src
size_t
buf_size
)
{
switch
(
t
-
>
preprocess
)
{
case
ExtraTF
:
:
kNone
:
JXL_DASSERT
(
false
)
;
break
;
case
ExtraTF
:
:
kPQ
:
{
HWY_FULL
(
float
)
df
;
const
auto
multiplier
=
Set
(
df
t
-
>
intensity_target
=
=
10000
.
f
?
1
.
0f
:
10000
.
f
/
t
-
>
intensity_target
)
;
for
(
size_t
i
=
0
;
i
<
buf_size
;
i
+
=
Lanes
(
df
)
)
{
const
auto
val
=
Load
(
df
buf_src
+
i
)
;
const
auto
result
=
Mul
(
multiplier
TF_PQ
(
)
.
DisplayFromEncoded
(
df
val
)
)
;
Store
(
result
df
xform_src
+
i
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
pre
in
%
.
4f
%
.
4f
%
.
4f
undoPQ
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_src
[
3
*
kX
]
buf_src
[
3
*
kX
+
1
]
buf_src
[
3
*
kX
+
2
]
xform_src
[
3
*
kX
]
xform_src
[
3
*
kX
+
1
]
xform_src
[
3
*
kX
+
2
]
)
;
#
endif
break
;
}
case
ExtraTF
:
:
kHLG
:
for
(
size_t
i
=
0
;
i
<
buf_size
;
+
+
i
)
{
xform_src
[
i
]
=
static_cast
<
float
>
(
TF_HLG
(
)
.
DisplayFromEncoded
(
static_cast
<
double
>
(
buf_src
[
i
]
)
)
)
;
}
if
(
t
-
>
apply_hlg_ootf
)
{
JXL_RETURN_IF_ERROR
(
ApplyHlgOotf
(
t
xform_src
buf_size
true
)
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
pre
in
%
.
4f
%
.
4f
%
.
4f
undoHLG
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_src
[
3
*
kX
]
buf_src
[
3
*
kX
+
1
]
buf_src
[
3
*
kX
+
2
]
xform_src
[
3
*
kX
]
xform_src
[
3
*
kX
+
1
]
xform_src
[
3
*
kX
+
2
]
)
;
#
endif
break
;
case
ExtraTF
:
:
kSRGB
:
HWY_FULL
(
float
)
df
;
for
(
size_t
i
=
0
;
i
<
buf_size
;
i
+
=
Lanes
(
df
)
)
{
const
auto
val
=
Load
(
df
buf_src
+
i
)
;
const
auto
result
=
TF_SRGB
(
)
.
DisplayFromEncoded
(
val
)
;
Store
(
result
df
xform_src
+
i
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
pre
in
%
.
4f
%
.
4f
%
.
4f
undoSRGB
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_src
[
3
*
kX
]
buf_src
[
3
*
kX
+
1
]
buf_src
[
3
*
kX
+
2
]
xform_src
[
3
*
kX
]
xform_src
[
3
*
kX
+
1
]
xform_src
[
3
*
kX
+
2
]
)
;
#
endif
break
;
}
return
true
;
}
Status
AfterTransform
(
JxlCms
*
t
float
*
JXL_RESTRICT
buf_dst
size_t
buf_size
)
{
switch
(
t
-
>
postprocess
)
{
case
ExtraTF
:
:
kNone
:
JXL_DASSERT
(
false
)
;
break
;
case
ExtraTF
:
:
kPQ
:
{
HWY_FULL
(
float
)
df
;
const
auto
multiplier
=
Set
(
df
t
-
>
intensity_target
=
=
10000
.
f
?
1
.
0f
:
t
-
>
intensity_target
*
1e
-
4f
)
;
for
(
size_t
i
=
0
;
i
<
buf_size
;
i
+
=
Lanes
(
df
)
)
{
const
auto
val
=
Load
(
df
buf_dst
+
i
)
;
const
auto
result
=
TF_PQ
(
)
.
EncodedFromDisplay
(
df
Mul
(
multiplier
val
)
)
;
Store
(
result
df
buf_dst
+
i
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
after
PQ
enc
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_dst
[
3
*
kX
]
buf_dst
[
3
*
kX
+
1
]
buf_dst
[
3
*
kX
+
2
]
)
;
#
endif
break
;
}
case
ExtraTF
:
:
kHLG
:
if
(
t
-
>
apply_hlg_ootf
)
{
JXL_RETURN_IF_ERROR
(
ApplyHlgOotf
(
t
buf_dst
buf_size
false
)
)
;
}
for
(
size_t
i
=
0
;
i
<
buf_size
;
+
+
i
)
{
buf_dst
[
i
]
=
static_cast
<
float
>
(
TF_HLG
(
)
.
EncodedFromDisplay
(
static_cast
<
double
>
(
buf_dst
[
i
]
)
)
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
after
HLG
enc
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_dst
[
3
*
kX
]
buf_dst
[
3
*
kX
+
1
]
buf_dst
[
3
*
kX
+
2
]
)
;
#
endif
break
;
case
ExtraTF
:
:
kSRGB
:
HWY_FULL
(
float
)
df
;
for
(
size_t
i
=
0
;
i
<
buf_size
;
i
+
=
Lanes
(
df
)
)
{
const
auto
val
=
Load
(
df
buf_dst
+
i
)
;
const
auto
result
=
TF_SRGB
(
)
.
EncodedFromDisplay
(
HWY_FULL
(
float
)
(
)
val
)
;
Store
(
result
df
buf_dst
+
i
)
;
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
after
SRGB
enc
%
.
4f
%
.
4f
%
.
4f
\
n
"
buf_dst
[
3
*
kX
]
buf_dst
[
3
*
kX
+
1
]
buf_dst
[
3
*
kX
+
2
]
)
;
#
endif
break
;
}
return
true
;
}
Status
DoColorSpaceTransform
(
void
*
cms_data
const
size_t
thread
const
float
*
buf_src
float
*
buf_dst
size_t
xsize
)
{
JxlCms
*
t
=
reinterpret_cast
<
JxlCms
*
>
(
cms_data
)
;
const
float
*
xform_src
=
buf_src
;
if
(
t
-
>
preprocess
!
=
ExtraTF
:
:
kNone
)
{
float
*
mutable_xform_src
=
t
-
>
buf_src
.
Row
(
thread
)
;
JXL_RETURN_IF_ERROR
(
BeforeTransform
(
t
buf_src
mutable_xform_src
xsize
*
t
-
>
channels_src
)
)
;
xform_src
=
mutable_xform_src
;
}
#
if
JPEGXL_ENABLE_SKCMS
if
(
t
-
>
channels_src
=
=
1
&
&
!
t
-
>
skip_lcms
)
{
float
*
mutable_xform_src
=
t
-
>
buf_src
.
Row
(
thread
)
;
for
(
size_t
i
=
0
;
i
<
xsize
;
+
+
i
)
{
const
size_t
x
=
xsize
-
i
-
1
;
mutable_xform_src
[
x
*
3
]
=
mutable_xform_src
[
x
*
3
+
1
]
=
mutable_xform_src
[
x
*
3
+
2
]
=
xform_src
[
x
]
;
}
xform_src
=
mutable_xform_src
;
}
#
else
if
(
t
-
>
channels_src
=
=
4
&
&
!
t
-
>
skip_lcms
)
{
float
*
mutable_xform_src
=
t
-
>
buf_src
.
Row
(
thread
)
;
for
(
size_t
x
=
0
;
x
<
xsize
*
4
;
+
+
x
)
{
mutable_xform_src
[
x
]
=
100
.
f
-
100
.
f
*
mutable_xform_src
[
x
]
;
}
xform_src
=
mutable_xform_src
;
}
#
endif
#
if
JXL_CMS_VERBOSE
>
=
2
const
float
in0
=
xform_src
[
3
*
kX
+
0
]
;
const
float
in1
=
xform_src
[
3
*
kX
+
1
]
;
const
float
in2
=
xform_src
[
3
*
kX
+
2
]
;
#
endif
if
(
t
-
>
skip_lcms
)
{
if
(
buf_dst
!
=
xform_src
)
{
memcpy
(
buf_dst
xform_src
xsize
*
t
-
>
channels_src
*
sizeof
(
*
buf_dst
)
)
;
}
}
else
{
#
if
JPEGXL_ENABLE_SKCMS
JXL_CHECK
(
skcms_Transform
(
xform_src
(
t
-
>
channels_src
=
=
4
?
skcms_PixelFormat_RGBA_ffff
:
skcms_PixelFormat_RGB_fff
)
skcms_AlphaFormat_Opaque
&
t
-
>
profile_src
buf_dst
skcms_PixelFormat_RGB_fff
skcms_AlphaFormat_Opaque
&
t
-
>
profile_dst
xsize
)
)
;
#
else
cmsDoTransform
(
t
-
>
lcms_transform
xform_src
buf_dst
static_cast
<
cmsUInt32Number
>
(
xsize
)
)
;
#
endif
}
#
if
JXL_CMS_VERBOSE
>
=
2
printf
(
"
xform
skip
%
d
:
%
.
4f
%
.
4f
%
.
4f
(
%
p
)
-
>
(
%
p
)
%
.
4f
%
.
4f
%
.
4f
\
n
"
t
-
>
skip_lcms
in0
in1
in2
xform_src
buf_dst
buf_dst
[
3
*
kX
]
buf_dst
[
3
*
kX
+
1
]
buf_dst
[
3
*
kX
+
2
]
)
;
#
endif
#
if
JPEGXL_ENABLE_SKCMS
if
(
t
-
>
channels_dst
=
=
1
&
&
!
t
-
>
skip_lcms
)
{
float
*
grayscale_buf_dst
=
t
-
>
buf_dst
.
Row
(
thread
)
;
for
(
size_t
x
=
0
;
x
<
xsize
;
+
+
x
)
{
grayscale_buf_dst
[
x
]
=
buf_dst
[
x
*
3
]
;
}
buf_dst
=
grayscale_buf_dst
;
}
#
endif
if
(
t
-
>
postprocess
!
=
ExtraTF
:
:
kNone
)
{
JXL_RETURN_IF_ERROR
(
AfterTransform
(
t
buf_dst
xsize
*
t
-
>
channels_dst
)
)
;
}
return
true
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
jxl
{
namespace
{
HWY_EXPORT
(
DoColorSpaceTransform
)
;
int
DoColorSpaceTransform
(
void
*
t
size_t
thread
const
float
*
buf_src
float
*
buf_dst
size_t
xsize
)
{
return
HWY_DYNAMIC_DISPATCH
(
DoColorSpaceTransform
)
(
t
thread
buf_src
buf_dst
xsize
)
;
}
#
define
JXL_CMS_OLD_VERSION
0
#
if
JPEGXL_ENABLE_SKCMS
JXL_MUST_USE_RESULT
CIExy
CIExyFromXYZ
(
const
float
XYZ
[
3
]
)
{
const
float
factor
=
1
.
f
/
(
XYZ
[
0
]
+
XYZ
[
1
]
+
XYZ
[
2
]
)
;
CIExy
xy
;
xy
.
x
=
XYZ
[
0
]
*
factor
;
xy
.
y
=
XYZ
[
1
]
*
factor
;
return
xy
;
}
#
else
JXL_MUST_USE_RESULT
CIExy
CIExyFromxyY
(
const
cmsCIExyY
&
xyY
)
{
CIExy
xy
;
xy
.
x
=
xyY
.
x
;
xy
.
y
=
xyY
.
y
;
return
xy
;
}
JXL_MUST_USE_RESULT
CIExy
CIExyFromXYZ
(
const
cmsCIEXYZ
&
XYZ
)
{
cmsCIExyY
xyY
;
cmsXYZ2xyY
(
&
xyY
&
XYZ
)
;
return
CIExyFromxyY
(
xyY
)
;
}
JXL_MUST_USE_RESULT
cmsCIEXYZ
D50_XYZ
(
)
{
return
{
0
.
96420288
1
.
0
0
.
82490540
}
;
}
JXL_MUST_USE_RESULT
cmsCIExyY
xyYFromCIExy
(
const
CIExy
&
xy
)
{
const
cmsCIExyY
xyY
=
{
xy
.
x
xy
.
y
1
.
0
}
;
return
xyY
;
}
struct
ProfileDeleter
{
void
operator
(
)
(
void
*
p
)
{
cmsCloseProfile
(
p
)
;
}
}
;
using
Profile
=
std
:
:
unique_ptr
<
void
ProfileDeleter
>
;
struct
TransformDeleter
{
void
operator
(
)
(
void
*
p
)
{
cmsDeleteTransform
(
p
)
;
}
}
;
using
Transform
=
std
:
:
unique_ptr
<
void
TransformDeleter
>
;
struct
CurveDeleter
{
void
operator
(
)
(
cmsToneCurve
*
p
)
{
cmsFreeToneCurve
(
p
)
;
}
}
;
using
Curve
=
std
:
:
unique_ptr
<
cmsToneCurve
CurveDeleter
>
;
Status
CreateProfileXYZ
(
const
cmsContext
context
Profile
*
JXL_RESTRICT
profile
)
{
profile
-
>
reset
(
cmsCreateXYZProfileTHR
(
context
)
)
;
if
(
profile
-
>
get
(
)
=
=
nullptr
)
return
JXL_FAILURE
(
"
Failed
to
create
XYZ
"
)
;
return
true
;
}
#
endif
#
if
JPEGXL_ENABLE_SKCMS
Status
DecodeProfile
(
const
uint8_t
*
icc
size_t
size
skcms_ICCProfile
*
const
profile
)
{
if
(
!
skcms_Parse
(
icc
size
profile
)
)
{
return
JXL_FAILURE
(
"
Failed
to
parse
ICC
profile
with
%
"
PRIuS
"
bytes
"
size
)
;
}
return
true
;
}
#
else
Status
DecodeProfile
(
const
cmsContext
context
const
PaddedBytes
&
icc
Profile
*
profile
)
{
profile
-
>
reset
(
cmsOpenProfileFromMemTHR
(
context
icc
.
data
(
)
icc
.
size
(
)
)
)
;
if
(
profile
-
>
get
(
)
=
=
nullptr
)
{
return
JXL_FAILURE
(
"
Failed
to
decode
profile
"
)
;
}
return
true
;
}
#
endif
#
if
JPEGXL_ENABLE_SKCMS
ColorSpace
ColorSpaceFromProfile
(
const
skcms_ICCProfile
&
profile
)
{
switch
(
profile
.
data_color_space
)
{
case
skcms_Signature_RGB
:
case
skcms_Signature_CMYK
:
return
ColorSpace
:
:
kRGB
;
case
skcms_Signature_Gray
:
return
ColorSpace
:
:
kGray
;
default
:
return
ColorSpace
:
:
kUnknown
;
}
}
Status
ProfileEquivalentToICC
(
const
skcms_ICCProfile
&
profile1
const
PaddedBytes
&
icc
)
{
skcms_ICCProfile
profile2
;
JXL_RETURN_IF_ERROR
(
skcms_Parse
(
icc
.
data
(
)
icc
.
size
(
)
&
profile2
)
)
;
return
skcms_ApproximatelyEqualProfiles
(
&
profile1
&
profile2
)
;
}
void
MatrixProduct
(
const
skcms_Matrix3x3
&
matrix
const
float
vector_in
[
3
]
float
vector_out
[
3
]
)
{
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
vector_out
[
i
]
=
0
;
for
(
int
j
=
0
;
j
<
3
;
+
+
j
)
{
vector_out
[
i
]
+
=
matrix
.
vals
[
i
]
[
j
]
*
vector_in
[
j
]
;
}
}
}
JXL_MUST_USE_RESULT
Status
UnadaptedWhitePoint
(
const
skcms_ICCProfile
&
profile
CIExy
*
out
)
{
float
media_white_point_XYZ
[
3
]
;
if
(
!
skcms_GetWTPT
(
&
profile
media_white_point_XYZ
)
)
{
return
JXL_FAILURE
(
"
ICC
profile
does
not
contain
WhitePoint
tag
"
)
;
}
skcms_Matrix3x3
CHAD
;
if
(
!
skcms_GetCHAD
(
&
profile
&
CHAD
)
)
{
*
out
=
CIExyFromXYZ
(
media_white_point_XYZ
)
;
return
true
;
}
skcms_Matrix3x3
inverse_CHAD
;
if
(
!
skcms_Matrix3x3_invert
(
&
CHAD
&
inverse_CHAD
)
)
{
return
JXL_FAILURE
(
"
Non
-
invertible
ChromaticAdaptation
matrix
"
)
;
}
float
unadapted_white_point_XYZ
[
3
]
;
MatrixProduct
(
inverse_CHAD
media_white_point_XYZ
unadapted_white_point_XYZ
)
;
*
out
=
CIExyFromXYZ
(
unadapted_white_point_XYZ
)
;
return
true
;
}
Status
IdentifyPrimaries
(
const
skcms_ICCProfile
&
profile
const
CIExy
&
wp_unadapted
ColorEncoding
*
c
)
{
if
(
!
c
-
>
HasPrimaries
(
)
)
return
true
;
skcms_Matrix3x3
CHAD
inverse_CHAD
;
if
(
skcms_GetCHAD
(
&
profile
&
CHAD
)
)
{
JXL_RETURN_IF_ERROR
(
skcms_Matrix3x3_invert
(
&
CHAD
&
inverse_CHAD
)
)
;
}
else
{
static
constexpr
skcms_Matrix3x3
kLMSFromXYZ
=
{
{
{
0
.
8951
0
.
2664
-
0
.
1614
}
{
-
0
.
7502
1
.
7135
0
.
0367
}
{
0
.
0389
-
0
.
0685
1
.
0296
}
}
}
;
static
constexpr
skcms_Matrix3x3
kXYZFromLMS
=
{
{
{
0
.
9869929
-
0
.
1470543
0
.
1599627
}
{
0
.
4323053
0
.
5183603
0
.
0492912
}
{
-
0
.
0085287
0
.
0400428
0
.
9684867
}
}
}
;
static
constexpr
float
kWpD50XYZ
[
3
]
=
{
0
.
96420288
1
.
0
0
.
82490540
}
;
float
wp_unadapted_XYZ
[
3
]
;
JXL_RETURN_IF_ERROR
(
CIEXYZFromWhiteCIExy
(
wp_unadapted
wp_unadapted_XYZ
)
)
;
float
wp_D50_LMS
[
3
]
wp_unadapted_LMS
[
3
]
;
MatrixProduct
(
kLMSFromXYZ
kWpD50XYZ
wp_D50_LMS
)
;
MatrixProduct
(
kLMSFromXYZ
wp_unadapted_XYZ
wp_unadapted_LMS
)
;
inverse_CHAD
=
{
{
{
wp_unadapted_LMS
[
0
]
/
wp_D50_LMS
[
0
]
0
0
}
{
0
wp_unadapted_LMS
[
1
]
/
wp_D50_LMS
[
1
]
0
}
{
0
0
wp_unadapted_LMS
[
2
]
/
wp_D50_LMS
[
2
]
}
}
}
;
inverse_CHAD
=
skcms_Matrix3x3_concat
(
&
kXYZFromLMS
&
inverse_CHAD
)
;
inverse_CHAD
=
skcms_Matrix3x3_concat
(
&
inverse_CHAD
&
kLMSFromXYZ
)
;
}
float
XYZ
[
3
]
;
PrimariesCIExy
primaries
;
CIExy
*
const
chromaticities
[
]
=
{
&
primaries
.
r
&
primaries
.
g
&
primaries
.
b
}
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
float
RGB
[
3
]
=
{
}
;
RGB
[
i
]
=
1
;
skcms_Transform
(
RGB
skcms_PixelFormat_RGB_fff
skcms_AlphaFormat_Opaque
&
profile
XYZ
skcms_PixelFormat_RGB_fff
skcms_AlphaFormat_Opaque
skcms_XYZD50_profile
(
)
1
)
;
float
unadapted_XYZ
[
3
]
;
MatrixProduct
(
inverse_CHAD
XYZ
unadapted_XYZ
)
;
*
chromaticities
[
i
]
=
CIExyFromXYZ
(
unadapted_XYZ
)
;
}
return
c
-
>
SetPrimaries
(
primaries
)
;
}
void
DetectTransferFunction
(
const
skcms_ICCProfile
&
profile
ColorEncoding
*
JXL_RESTRICT
c
)
{
if
(
c
-
>
tf
.
SetImplicit
(
)
)
return
;
for
(
TransferFunction
tf
:
Values
<
TransferFunction
>
(
)
)
{
if
(
tf
=
=
TransferFunction
:
:
kUnknown
)
continue
;
c
-
>
tf
.
SetTransferFunction
(
tf
)
;
skcms_ICCProfile
profile_test
;
PaddedBytes
bytes
;
if
(
MaybeCreateProfile
(
*
c
&
bytes
)
&
&
DecodeProfile
(
bytes
.
data
(
)
bytes
.
size
(
)
&
profile_test
)
&
&
skcms_ApproximatelyEqualProfiles
(
&
profile
&
profile_test
)
)
{
return
;
}
}
c
-
>
tf
.
SetTransferFunction
(
TransferFunction
:
:
kUnknown
)
;
}
#
else
uint32_t
Type32
(
const
ColorEncoding
&
c
bool
cmyk
)
{
if
(
cmyk
)
return
TYPE_CMYK_FLT
;
if
(
c
.
IsGray
(
)
)
return
TYPE_GRAY_FLT
;
return
TYPE_RGB_FLT
;
}
uint32_t
Type64
(
const
ColorEncoding
&
c
)
{
if
(
c
.
IsGray
(
)
)
return
TYPE_GRAY_DBL
;
return
TYPE_RGB_DBL
;
}
ColorSpace
ColorSpaceFromProfile
(
const
Profile
&
profile
)
{
switch
(
cmsGetColorSpace
(
profile
.
get
(
)
)
)
{
case
cmsSigRgbData
:
case
cmsSigCmykData
:
return
ColorSpace
:
:
kRGB
;
case
cmsSigGrayData
:
return
ColorSpace
:
:
kGray
;
default
:
return
ColorSpace
:
:
kUnknown
;
}
}
Status
ProfileEquivalentToICC
(
const
cmsContext
context
const
Profile
&
profile1
const
PaddedBytes
&
icc
const
ColorEncoding
&
c
)
{
const
uint32_t
type_src
=
Type64
(
c
)
;
Profile
profile2
;
JXL_RETURN_IF_ERROR
(
DecodeProfile
(
context
icc
&
profile2
)
)
;
Profile
profile_xyz
;
JXL_RETURN_IF_ERROR
(
CreateProfileXYZ
(
context
&
profile_xyz
)
)
;
const
uint32_t
intent
=
INTENT_RELATIVE_COLORIMETRIC
;
const
uint32_t
flags
=
cmsFLAGS_NOOPTIMIZE
|
cmsFLAGS_BLACKPOINTCOMPENSATION
|
cmsFLAGS_HIGHRESPRECALC
;
Transform
xform1
(
cmsCreateTransformTHR
(
context
profile1
.
get
(
)
type_src
profile_xyz
.
get
(
)
TYPE_XYZ_DBL
intent
flags
)
)
;
Transform
xform2
(
cmsCreateTransformTHR
(
context
profile2
.
get
(
)
type_src
profile_xyz
.
get
(
)
TYPE_XYZ_DBL
intent
flags
)
)
;
if
(
xform1
=
=
nullptr
|
|
xform2
=
=
nullptr
)
{
return
JXL_FAILURE
(
"
Failed
to
create
transform
"
)
;
}
double
in
[
3
]
;
double
out1
[
3
]
;
double
out2
[
3
]
;
const
double
init
=
1E
-
3
;
const
double
step
=
0
.
2
;
if
(
c
.
IsGray
(
)
)
{
for
(
in
[
0
]
=
init
;
in
[
0
]
<
1
.
0
;
in
[
0
]
+
=
step
/
8
)
{
cmsDoTransform
(
xform1
.
get
(
)
in
out1
1
)
;
cmsDoTransform
(
xform2
.
get
(
)
in
out2
1
)
;
if
(
!
ApproxEq
(
out1
[
0
]
out2
[
0
]
2E
-
4
)
)
{
return
false
;
}
}
}
else
{
for
(
in
[
0
]
=
init
;
in
[
0
]
<
1
.
0
;
in
[
0
]
+
=
step
)
{
for
(
in
[
1
]
=
init
;
in
[
1
]
<
1
.
0
;
in
[
1
]
+
=
step
)
{
for
(
in
[
2
]
=
init
;
in
[
2
]
<
1
.
0
;
in
[
2
]
+
=
step
)
{
cmsDoTransform
(
xform1
.
get
(
)
in
out1
1
)
;
cmsDoTransform
(
xform2
.
get
(
)
in
out2
1
)
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
if
(
!
ApproxEq
(
out1
[
i
]
out2
[
i
]
2E
-
4
)
)
{
return
false
;
}
}
}
}
}
}
return
true
;
}
JXL_MUST_USE_RESULT
cmsCIEXYZ
UnadaptedWhitePoint
(
const
cmsContext
context
const
Profile
&
profile
const
ColorEncoding
&
c
)
{
const
cmsCIEXYZ
*
white_point
=
static_cast
<
const
cmsCIEXYZ
*
>
(
cmsReadTag
(
profile
.
get
(
)
cmsSigMediaWhitePointTag
)
)
;
if
(
white_point
!
=
nullptr
&
&
cmsReadTag
(
profile
.
get
(
)
cmsSigChromaticAdaptationTag
)
=
=
nullptr
)
{
return
*
white_point
;
}
cmsCIEXYZ
XYZ
=
{
1
.
0
1
.
0
1
.
0
}
;
Profile
profile_xyz
;
if
(
!
CreateProfileXYZ
(
context
&
profile_xyz
)
)
return
XYZ
;
cmsHPROFILE
profiles
[
2
]
=
{
profile
.
get
(
)
profile_xyz
.
get
(
)
}
;
cmsUInt32Number
intents
[
2
]
=
{
INTENT_ABSOLUTE_COLORIMETRIC
INTENT_ABSOLUTE_COLORIMETRIC
}
;
cmsBool
black_compensation
[
2
]
=
{
0
0
}
;
cmsFloat64Number
adaption
[
2
]
=
{
0
.
0
0
.
0
}
;
cmsUInt32Number
flags
=
cmsFLAGS_NOOPTIMIZE
|
cmsFLAGS_HIGHRESPRECALC
;
Transform
xform
(
cmsCreateExtendedTransform
(
context
2
profiles
black_compensation
intents
adaption
nullptr
0
Type64
(
c
)
TYPE_XYZ_DBL
flags
)
)
;
if
(
!
xform
)
return
XYZ
;
const
cmsFloat64Number
in
[
3
]
=
{
1
.
0
1
.
0
1
.
0
}
;
cmsDoTransform
(
xform
.
get
(
)
in
&
XYZ
.
X
1
)
;
return
XYZ
;
}
Status
IdentifyPrimaries
(
const
cmsContext
context
const
Profile
&
profile
const
cmsCIEXYZ
&
wp_unadapted
ColorEncoding
*
c
)
{
if
(
!
c
-
>
HasPrimaries
(
)
)
return
true
;
if
(
ColorSpaceFromProfile
(
profile
)
=
=
ColorSpace
:
:
kUnknown
)
return
true
;
const
cmsCIEXYZ
*
adapted_r
=
static_cast
<
const
cmsCIEXYZ
*
>
(
cmsReadTag
(
profile
.
get
(
)
cmsSigRedColorantTag
)
)
;
const
cmsCIEXYZ
*
adapted_g
=
static_cast
<
const
cmsCIEXYZ
*
>
(
cmsReadTag
(
profile
.
get
(
)
cmsSigGreenColorantTag
)
)
;
const
cmsCIEXYZ
*
adapted_b
=
static_cast
<
const
cmsCIEXYZ
*
>
(
cmsReadTag
(
profile
.
get
(
)
cmsSigBlueColorantTag
)
)
;
cmsCIEXYZ
converted_rgb
[
3
]
;
if
(
adapted_r
=
=
nullptr
|
|
adapted_g
=
=
nullptr
|
|
adapted_b
=
=
nullptr
)
{
Profile
profile_xyz
;
if
(
!
CreateProfileXYZ
(
context
&
profile_xyz
)
)
{
return
JXL_FAILURE
(
"
Failed
to
retrieve
colorants
"
)
;
}
cmsHPROFILE
profiles
[
2
]
=
{
profile
.
get
(
)
profile_xyz
.
get
(
)
}
;
cmsUInt32Number
intents
[
2
]
=
{
INTENT_RELATIVE_COLORIMETRIC
INTENT_RELATIVE_COLORIMETRIC
}
;
cmsBool
black_compensation
[
2
]
=
{
0
0
}
;
cmsFloat64Number
adaption
[
2
]
=
{
0
.
0
0
.
0
}
;
cmsUInt32Number
flags
=
cmsFLAGS_NOOPTIMIZE
|
cmsFLAGS_HIGHRESPRECALC
;
Transform
xform
(
cmsCreateExtendedTransform
(
context
2
profiles
black_compensation
intents
adaption
nullptr
0
Type64
(
*
c
)
TYPE_XYZ_DBL
flags
)
)
;
if
(
!
xform
)
return
JXL_FAILURE
(
"
Failed
to
retrieve
colorants
"
)
;
const
cmsFloat64Number
in
[
9
]
=
{
1
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
0
.
0
1
.
0
}
;
cmsDoTransform
(
xform
.
get
(
)
in
&
converted_rgb
-
>
X
3
)
;
adapted_r
=
&
converted_rgb
[
0
]
;
adapted_g
=
&
converted_rgb
[
1
]
;
adapted_b
=
&
converted_rgb
[
2
]
;
}
const
cmsCIEXYZ
d50
=
D50_XYZ
(
)
;
cmsCIEXYZ
r
g
b
;
cmsAdaptToIlluminant
(
&
r
&
d50
&
wp_unadapted
adapted_r
)
;
cmsAdaptToIlluminant
(
&
g
&
d50
&
wp_unadapted
adapted_g
)
;
cmsAdaptToIlluminant
(
&
b
&
d50
&
wp_unadapted
adapted_b
)
;
const
PrimariesCIExy
rgb
=
{
CIExyFromXYZ
(
r
)
CIExyFromXYZ
(
g
)
CIExyFromXYZ
(
b
)
}
;
return
c
-
>
SetPrimaries
(
rgb
)
;
}
void
DetectTransferFunction
(
const
cmsContext
context
const
Profile
&
profile
ColorEncoding
*
JXL_RESTRICT
c
)
{
if
(
c
-
>
tf
.
SetImplicit
(
)
)
return
;
for
(
TransferFunction
tf
:
Values
<
TransferFunction
>
(
)
)
{
if
(
tf
=
=
TransferFunction
:
:
kUnknown
)
continue
;
c
-
>
tf
.
SetTransferFunction
(
tf
)
;
PaddedBytes
icc_test
;
if
(
MaybeCreateProfile
(
*
c
&
icc_test
)
&
&
ProfileEquivalentToICC
(
context
profile
icc_test
*
c
)
)
{
return
;
}
}
c
-
>
tf
.
SetTransferFunction
(
TransferFunction
:
:
kUnknown
)
;
}
void
ErrorHandler
(
cmsContext
context
cmsUInt32Number
code
const
char
*
text
)
{
JXL_WARNING
(
"
LCMS
error
%
u
:
%
s
"
code
text
)
;
}
cmsContext
GetContext
(
)
{
static
thread_local
void
*
context_
;
if
(
context_
=
=
nullptr
)
{
context_
=
cmsCreateContext
(
nullptr
nullptr
)
;
JXL_ASSERT
(
context_
!
=
nullptr
)
;
cmsSetLogErrorHandlerTHR
(
static_cast
<
cmsContext
>
(
context_
)
&
ErrorHandler
)
;
}
return
static_cast
<
cmsContext
>
(
context_
)
;
}
#
endif
Status
GetPrimariesLuminances
(
const
ColorEncoding
&
encoding
float
luminances
[
3
]
)
{
float
white_XYZ
[
3
]
;
JXL_RETURN_IF_ERROR
(
CIEXYZFromWhiteCIExy
(
encoding
.
GetWhitePoint
(
)
white_XYZ
)
)
;
const
PrimariesCIExy
primaries
=
encoding
.
GetPrimaries
(
)
;
double
chromaticities
[
3
]
[
3
]
=
{
{
primaries
.
r
.
x
primaries
.
g
.
x
primaries
.
b
.
x
}
{
primaries
.
r
.
y
primaries
.
g
.
y
primaries
.
b
.
y
}
{
1
-
primaries
.
r
.
x
-
primaries
.
r
.
y
1
-
primaries
.
g
.
x
-
primaries
.
g
.
y
1
-
primaries
.
b
.
x
-
primaries
.
b
.
y
}
}
;
JXL_RETURN_IF_ERROR
(
Inv3x3Matrix
(
&
chromaticities
[
0
]
[
0
]
)
)
;
const
double
ys
[
3
]
=
{
primaries
.
r
.
y
primaries
.
g
.
y
primaries
.
b
.
y
}
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
luminances
[
i
]
=
ys
[
i
]
*
(
chromaticities
[
i
]
[
0
]
*
white_XYZ
[
0
]
+
chromaticities
[
i
]
[
1
]
*
white_XYZ
[
1
]
+
chromaticities
[
i
]
[
2
]
*
white_XYZ
[
2
]
)
;
}
return
true
;
}
Status
ApplyHlgOotf
(
JxlCms
*
t
float
*
JXL_RESTRICT
buf
size_t
xsize
bool
forward
)
{
if
(
295
<
=
t
-
>
intensity_target
&
&
t
-
>
intensity_target
<
=
305
)
{
return
true
;
}
float
gamma
=
1
.
2f
*
std
:
:
pow
(
1
.
111f
std
:
:
log2
(
t
-
>
intensity_target
*
1e
-
3f
)
)
;
if
(
!
forward
)
gamma
=
1
.
f
/
gamma
;
switch
(
t
-
>
hlg_ootf_num_channels
)
{
case
1
:
for
(
size_t
x
=
0
;
x
<
xsize
;
+
+
x
)
{
buf
[
x
]
=
std
:
:
pow
(
buf
[
x
]
gamma
)
;
}
break
;
case
3
:
for
(
size_t
x
=
0
;
x
<
xsize
;
x
+
=
3
)
{
const
float
luminance
=
buf
[
x
]
*
t
-
>
hlg_ootf_luminances
[
0
]
+
buf
[
x
+
1
]
*
t
-
>
hlg_ootf_luminances
[
1
]
+
buf
[
x
+
2
]
*
t
-
>
hlg_ootf_luminances
[
2
]
;
const
float
ratio
=
std
:
:
pow
(
luminance
gamma
-
1
)
;
if
(
std
:
:
isfinite
(
ratio
)
)
{
buf
[
x
]
*
=
ratio
;
buf
[
x
+
1
]
*
=
ratio
;
buf
[
x
+
2
]
*
=
ratio
;
if
(
forward
&
&
gamma
<
1
)
{
const
float
maximum
=
std
:
:
max
(
buf
[
x
]
std
:
:
max
(
buf
[
x
+
1
]
buf
[
x
+
2
]
)
)
;
if
(
maximum
>
1
)
{
const
float
normalizer
=
1
.
f
/
maximum
;
buf
[
x
]
*
=
normalizer
;
buf
[
x
+
1
]
*
=
normalizer
;
buf
[
x
+
2
]
*
=
normalizer
;
}
}
}
}
break
;
default
:
return
JXL_FAILURE
(
"
HLG
OOTF
not
implemented
for
%
"
PRIuS
"
channels
"
t
-
>
hlg_ootf_num_channels
)
;
}
return
true
;
}
}
Status
ColorEncoding
:
:
SetFieldsFromICC
(
)
{
SetColorSpace
(
ColorSpace
:
:
kUnknown
)
;
tf
.
SetTransferFunction
(
TransferFunction
:
:
kUnknown
)
;
if
(
icc_
.
empty
(
)
)
return
JXL_FAILURE
(
"
Empty
ICC
profile
"
)
;
#
if
JPEGXL_ENABLE_SKCMS
if
(
icc_
.
size
(
)
<
128
)
{
return
JXL_FAILURE
(
"
ICC
file
too
small
"
)
;
}
skcms_ICCProfile
profile
;
JXL_RETURN_IF_ERROR
(
skcms_Parse
(
icc_
.
data
(
)
icc_
.
size
(
)
&
profile
)
)
;
uint32_t
rendering_intent32
=
icc_
[
67
]
;
if
(
rendering_intent32
>
3
|
|
icc_
[
64
]
!
=
0
|
|
icc_
[
65
]
!
=
0
|
|
icc_
[
66
]
!
=
0
)
{
return
JXL_FAILURE
(
"
Invalid
rendering
intent
%
u
\
n
"
rendering_intent32
)
;
}
SetColorSpace
(
ColorSpaceFromProfile
(
profile
)
)
;
cmyk_
=
(
profile
.
data_color_space
=
=
skcms_Signature_CMYK
)
;
CIExy
wp_unadapted
;
JXL_RETURN_IF_ERROR
(
UnadaptedWhitePoint
(
profile
&
wp_unadapted
)
)
;
JXL_RETURN_IF_ERROR
(
SetWhitePoint
(
wp_unadapted
)
)
;
JXL_RETURN_IF_ERROR
(
IdentifyPrimaries
(
profile
wp_unadapted
this
)
)
;
DetectTransferFunction
(
profile
this
)
;
rendering_intent
=
static_cast
<
RenderingIntent
>
(
rendering_intent32
)
;
#
else
const
cmsContext
context
=
GetContext
(
)
;
Profile
profile
;
JXL_RETURN_IF_ERROR
(
DecodeProfile
(
context
icc_
&
profile
)
)
;
const
cmsUInt32Number
rendering_intent32
=
cmsGetHeaderRenderingIntent
(
profile
.
get
(
)
)
;
if
(
rendering_intent32
>
3
)
{
return
JXL_FAILURE
(
"
Invalid
rendering
intent
%
u
\
n
"
rendering_intent32
)
;
}
rendering_intent
=
static_cast
<
RenderingIntent
>
(
rendering_intent32
)
;
SetColorSpace
(
ColorSpaceFromProfile
(
profile
)
)
;
if
(
cmsGetColorSpace
(
profile
.
get
(
)
)
=
=
cmsSigCmykData
)
{
cmyk_
=
true
;
return
true
;
}
const
cmsCIEXYZ
wp_unadapted
=
UnadaptedWhitePoint
(
context
profile
*
this
)
;
JXL_RETURN_IF_ERROR
(
SetWhitePoint
(
CIExyFromXYZ
(
wp_unadapted
)
)
)
;
JXL_RETURN_IF_ERROR
(
IdentifyPrimaries
(
context
profile
wp_unadapted
this
)
)
;
DetectTransferFunction
(
context
profile
this
)
;
#
endif
return
true
;
}
void
ColorEncoding
:
:
DecideIfWantICC
(
)
{
PaddedBytes
icc_new
;
bool
equivalent
;
#
if
JPEGXL_ENABLE_SKCMS
skcms_ICCProfile
profile
;
if
(
!
DecodeProfile
(
ICC
(
)
.
data
(
)
ICC
(
)
.
size
(
)
&
profile
)
)
return
;
if
(
!
MaybeCreateProfile
(
*
this
&
icc_new
)
)
return
;
equivalent
=
ProfileEquivalentToICC
(
profile
icc_new
)
;
#
else
const
cmsContext
context
=
GetContext
(
)
;
Profile
profile
;
if
(
!
DecodeProfile
(
context
ICC
(
)
&
profile
)
)
return
;
if
(
cmsGetColorSpace
(
profile
.
get
(
)
)
=
=
cmsSigCmykData
)
return
;
if
(
!
MaybeCreateProfile
(
*
this
&
icc_new
)
)
return
;
equivalent
=
ProfileEquivalentToICC
(
context
profile
icc_new
*
this
)
;
#
endif
JXL_ASSERT
(
equivalent
)
;
want_icc_
=
false
;
}
namespace
{
void
JxlCmsDestroy
(
void
*
cms_data
)
{
if
(
cms_data
=
=
nullptr
)
return
;
JxlCms
*
t
=
reinterpret_cast
<
JxlCms
*
>
(
cms_data
)
;
#
if
!
JPEGXL_ENABLE_SKCMS
TransformDeleter
(
)
(
t
-
>
lcms_transform
)
;
#
endif
delete
t
;
}
void
*
JxlCmsInit
(
void
*
init_data
size_t
num_threads
size_t
xsize
const
JxlColorProfile
*
input
const
JxlColorProfile
*
output
float
intensity_target
)
{
auto
t
=
jxl
:
:
make_unique
<
JxlCms
>
(
)
;
PaddedBytes
icc_src
icc_dst
;
icc_src
.
assign
(
input
-
>
icc
.
data
input
-
>
icc
.
data
+
input
-
>
icc
.
size
)
;
ColorEncoding
c_src
;
if
(
!
c_src
.
SetICC
(
std
:
:
move
(
icc_src
)
)
)
{
JXL_NOTIFY_ERROR
(
"
JxlCmsInit
:
failed
to
parse
input
ICC
"
)
;
return
nullptr
;
}
icc_dst
.
assign
(
output
-
>
icc
.
data
output
-
>
icc
.
data
+
output
-
>
icc
.
size
)
;
ColorEncoding
c_dst
;
if
(
!
c_dst
.
SetICC
(
std
:
:
move
(
icc_dst
)
)
)
{
JXL_NOTIFY_ERROR
(
"
JxlCmsInit
:
failed
to
parse
output
ICC
"
)
;
return
nullptr
;
}
#
if
JXL_CMS_VERBOSE
printf
(
"
%
s
-
>
%
s
\
n
"
Description
(
c_src
)
.
c_str
(
)
Description
(
c_dst
)
.
c_str
(
)
)
;
#
endif
#
if
JPEGXL_ENABLE_SKCMS
if
(
!
DecodeProfile
(
input
-
>
icc
.
data
input
-
>
icc
.
size
&
t
-
>
profile_src
)
)
{
JXL_NOTIFY_ERROR
(
"
JxlCmsInit
:
skcms
failed
to
parse
input
ICC
"
)
;
return
nullptr
;
}
if
(
!
DecodeProfile
(
output
-
>
icc
.
data
output
-
>
icc
.
size
&
t
-
>
profile_dst
)
)
{
JXL_NOTIFY_ERROR
(
"
JxlCmsInit
:
skcms
failed
to
parse
output
ICC
"
)
;
return
nullptr
;
}
#
else
const
cmsContext
context
=
GetContext
(
)
;
Profile
profile_src
profile_dst
;
if
(
!
DecodeProfile
(
context
c_src
.
ICC
(
)
&
profile_src
)
)
{
JXL_NOTIFY_ERROR
(
"
JxlCmsInit
:
lcms
failed
to
parse
input
ICC
"
)
;
return
nullptr
;
}
if
(
!
DecodeProfile
(
context
c_dst
.
ICC
(
)
&
profile_dst
)
)
{
JXL_NOTIFY_ERROR
(
"
JxlCmsInit
:
lcms
failed
to
parse
output
ICC
"
)
;
return
nullptr
;
}
#
endif
t
-
>
skip_lcms
=
false
;
if
(
c_src
.
SameColorEncoding
(
c_dst
)
)
{
t
-
>
skip_lcms
=
true
;
#
if
JXL_CMS_VERBOSE
printf
(
"
Skip
CMS
\
n
"
)
;
#
endif
}
t
-
>
apply_hlg_ootf
=
c_src
.
tf
.
IsHLG
(
)
!
=
c_dst
.
tf
.
IsHLG
(
)
;
if
(
t
-
>
apply_hlg_ootf
)
{
const
ColorEncoding
*
c_hlg
=
c_src
.
tf
.
IsHLG
(
)
?
&
c_src
:
&
c_dst
;
t
-
>
hlg_ootf_num_channels
=
c_hlg
-
>
Channels
(
)
;
if
(
t
-
>
hlg_ootf_num_channels
=
=
3
&
&
!
GetPrimariesLuminances
(
*
c_hlg
t
-
>
hlg_ootf_luminances
.
data
(
)
)
)
{
JXL_NOTIFY_ERROR
(
"
JxlCmsInit
:
failed
to
compute
the
luminances
of
primaries
"
)
;
return
nullptr
;
}
}
bool
src_linear
=
c_src
.
tf
.
IsLinear
(
)
;
const
bool
dst_linear
=
c_dst
.
tf
.
IsLinear
(
)
;
if
(
c_src
.
tf
.
IsPQ
(
)
|
|
c_src
.
tf
.
IsHLG
(
)
|
|
(
c_src
.
tf
.
IsSRGB
(
)
&
&
dst_linear
&
&
c_src
.
SameColorSpace
(
c_dst
)
)
)
{
ColorEncoding
c_linear_src
=
c_src
;
c_linear_src
.
tf
.
SetTransferFunction
(
TransferFunction
:
:
kLinear
)
;
#
if
JPEGXL_ENABLE_SKCMS
skcms_ICCProfile
new_src
;
#
else
Profile
new_src
;
#
endif
if
(
MaybeCreateProfile
(
c_linear_src
&
icc_src
)
&
&
#
if
JPEGXL_ENABLE_SKCMS
DecodeProfile
(
icc_src
.
data
(
)
icc_src
.
size
(
)
&
new_src
)
)
{
#
else
DecodeProfile
(
context
icc_src
&
new_src
)
)
{
#
endif
#
if
JXL_CMS_VERBOSE
printf
(
"
Special
HLG
/
PQ
/
sRGB
-
>
linear
\
n
"
)
;
#
endif
#
if
JPEGXL_ENABLE_SKCMS
t
-
>
icc_src
=
std
:
:
move
(
icc_src
)
;
t
-
>
profile_src
=
new_src
;
#
else
profile_src
.
swap
(
new_src
)
;
#
endif
t
-
>
preprocess
=
c_src
.
tf
.
IsSRGB
(
)
?
ExtraTF
:
:
kSRGB
:
(
c_src
.
tf
.
IsPQ
(
)
?
ExtraTF
:
:
kPQ
:
ExtraTF
:
:
kHLG
)
;
c_src
=
c_linear_src
;
src_linear
=
true
;
}
else
{
if
(
t
-
>
apply_hlg_ootf
)
{
JXL_NOTIFY_ERROR
(
"
Failed
to
create
extra
linear
source
profile
and
HLG
OOTF
"
"
required
"
)
;
return
nullptr
;
}
JXL_WARNING
(
"
Failed
to
create
extra
linear
destination
profile
"
)
;
}
}
if
(
c_dst
.
tf
.
IsPQ
(
)
|
|
c_dst
.
tf
.
IsHLG
(
)
|
|
(
c_dst
.
tf
.
IsSRGB
(
)
&
&
src_linear
&
&
c_src
.
SameColorSpace
(
c_dst
)
)
)
{
ColorEncoding
c_linear_dst
=
c_dst
;
c_linear_dst
.
tf
.
SetTransferFunction
(
TransferFunction
:
:
kLinear
)
;
#
if
JPEGXL_ENABLE_SKCMS
skcms_ICCProfile
new_dst
;
#
else
Profile
new_dst
;
#
endif
if
(
MaybeCreateProfile
(
c_linear_dst
&
icc_dst
)
&
&
#
if
JPEGXL_ENABLE_SKCMS
DecodeProfile
(
icc_dst
.
data
(
)
icc_dst
.
size
(
)
&
new_dst
)
)
{
#
else
DecodeProfile
(
context
icc_dst
&
new_dst
)
)
{
#
endif
#
if
JXL_CMS_VERBOSE
printf
(
"
Special
linear
-
>
HLG
/
PQ
/
sRGB
\
n
"
)
;
#
endif
#
if
JPEGXL_ENABLE_SKCMS
t
-
>
icc_dst
=
std
:
:
move
(
icc_dst
)
;
t
-
>
profile_dst
=
new_dst
;
#
else
profile_dst
.
swap
(
new_dst
)
;
#
endif
t
-
>
postprocess
=
c_dst
.
tf
.
IsSRGB
(
)
?
ExtraTF
:
:
kSRGB
:
(
c_dst
.
tf
.
IsPQ
(
)
?
ExtraTF
:
:
kPQ
:
ExtraTF
:
:
kHLG
)
;
c_dst
=
c_linear_dst
;
}
else
{
if
(
t
-
>
apply_hlg_ootf
)
{
JXL_NOTIFY_ERROR
(
"
Failed
to
create
extra
linear
destination
profile
and
inverse
"
"
HLG
OOTF
required
"
)
;
return
nullptr
;
}
JXL_WARNING
(
"
Failed
to
create
extra
linear
destination
profile
"
)
;
}
}
if
(
c_src
.
SameColorEncoding
(
c_dst
)
)
{
#
if
JXL_CMS_VERBOSE
printf
(
"
Same
intermediary
linear
profiles
skipping
CMS
\
n
"
)
;
#
endif
t
-
>
skip_lcms
=
true
;
}
#
if
JPEGXL_ENABLE_SKCMS
if
(
!
skcms_MakeUsableAsDestination
(
&
t
-
>
profile_dst
)
)
{
JXL_NOTIFY_ERROR
(
"
Failed
to
make
%
s
usable
as
a
color
transform
destination
"
Description
(
c_dst
)
.
c_str
(
)
)
;
return
nullptr
;
}
#
endif
const
size_t
channels_src
=
(
c_src
.
IsCMYK
(
)
?
4
:
c_src
.
Channels
(
)
)
;
const
size_t
channels_dst
=
c_dst
.
Channels
(
)
;
JXL_CHECK
(
channels_src
=
=
channels_dst
|
|
(
channels_src
=
=
4
&
&
channels_dst
=
=
3
)
)
;
#
if
JXL_CMS_VERBOSE
printf
(
"
Channels
:
%
"
PRIuS
"
;
Threads
:
%
"
PRIuS
"
\
n
"
channels_src
num_threads
)
;
#
endif
#
if
!
JPEGXL_ENABLE_SKCMS
const
uint32_t
type_src
=
Type32
(
c_src
channels_src
=
=
4
)
;
const
uint32_t
type_dst
=
Type32
(
c_dst
false
)
;
const
uint32_t
intent
=
static_cast
<
uint32_t
>
(
c_dst
.
rendering_intent
)
;
const
uint32_t
flags
=
cmsFLAGS_NOCACHE
|
cmsFLAGS_BLACKPOINTCOMPENSATION
|
cmsFLAGS_HIGHRESPRECALC
;
t
-
>
lcms_transform
=
cmsCreateTransformTHR
(
context
profile_src
.
get
(
)
type_src
profile_dst
.
get
(
)
type_dst
intent
flags
)
;
if
(
t
-
>
lcms_transform
=
=
nullptr
)
{
JXL_NOTIFY_ERROR
(
"
Failed
to
create
transform
"
)
;
return
nullptr
;
}
#
endif
t
-
>
channels_src
=
channels_src
;
t
-
>
channels_dst
=
channels_dst
;
#
if
JPEGXL_ENABLE_SKCMS
t
-
>
buf_src
=
ImageF
(
xsize
*
(
channels_src
=
=
4
?
4
:
3
)
num_threads
)
;
t
-
>
buf_dst
=
ImageF
(
xsize
*
3
num_threads
)
;
#
else
t
-
>
buf_src
=
ImageF
(
xsize
*
channels_src
num_threads
)
;
t
-
>
buf_dst
=
ImageF
(
xsize
*
channels_dst
num_threads
)
;
#
endif
t
-
>
intensity_target
=
intensity_target
;
return
t
.
release
(
)
;
}
float
*
JxlCmsGetSrcBuf
(
void
*
cms_data
size_t
thread
)
{
JxlCms
*
t
=
reinterpret_cast
<
JxlCms
*
>
(
cms_data
)
;
return
t
-
>
buf_src
.
Row
(
thread
)
;
}
float
*
JxlCmsGetDstBuf
(
void
*
cms_data
size_t
thread
)
{
JxlCms
*
t
=
reinterpret_cast
<
JxlCms
*
>
(
cms_data
)
;
return
t
-
>
buf_dst
.
Row
(
thread
)
;
}
}
const
JxlCmsInterface
&
GetJxlCms
(
)
{
static
constexpr
JxlCmsInterface
kInterface
=
{
nullptr
&
JxlCmsInit
&
JxlCmsGetSrcBuf
&
JxlCmsGetDstBuf
&
DoColorSpaceTransform
&
JxlCmsDestroy
}
;
return
kInterface
;
}
}
#
endif
