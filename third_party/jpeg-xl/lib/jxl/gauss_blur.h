#
ifndef
LIB_JXL_GAUSS_BLUR_H_
#
define
LIB_JXL_GAUSS_BLUR_H_
#
include
<
stddef
.
h
>
#
include
<
cmath
>
#
include
<
hwy
/
aligned_allocator
.
h
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
namespace
jxl
{
template
<
typename
T
>
std
:
:
vector
<
T
>
GaussianKernel
(
int
radius
T
sigma
)
{
JXL_ASSERT
(
sigma
>
0
.
0
)
;
std
:
:
vector
<
T
>
kernel
(
2
*
radius
+
1
)
;
const
T
scaler
=
-
1
.
0
/
(
2
*
sigma
*
sigma
)
;
double
sum
=
0
.
0
;
for
(
int
i
=
-
radius
;
i
<
=
radius
;
+
+
i
)
{
const
T
val
=
std
:
:
exp
(
scaler
*
i
*
i
)
;
kernel
[
i
+
radius
]
=
val
;
sum
+
=
val
;
}
for
(
size_t
i
=
0
;
i
<
kernel
.
size
(
)
;
+
+
i
)
{
kernel
[
i
]
/
=
sum
;
}
return
kernel
;
}
ImageF
ConvolveAndSample
(
const
ImageF
&
in
const
std
:
:
vector
<
float
>
&
kernel
const
size_t
res
)
;
void
ExtrapolateBorders
(
const
float
*
const
JXL_RESTRICT
row_in
float
*
const
JXL_RESTRICT
row_out
const
int
xsize
const
int
radius
)
;
#
pragma
pack
(
push
1
)
struct
RecursiveGaussian
{
float
n2
[
3
*
4
]
;
float
d1
[
3
*
4
]
;
float
mul_prev
[
3
*
4
]
;
float
mul_prev2
[
3
*
4
]
;
float
mul_in
[
3
*
4
]
;
size_t
radius
;
}
;
#
pragma
pack
(
pop
)
hwy
:
:
AlignedUniquePtr
<
RecursiveGaussian
>
CreateRecursiveGaussian
(
double
sigma
)
;
void
FastGaussian1D
(
const
hwy
:
:
AlignedUniquePtr
<
RecursiveGaussian
>
&
rg
const
float
*
JXL_RESTRICT
in
intptr_t
width
float
*
JXL_RESTRICT
out
)
;
void
FastGaussian
(
const
hwy
:
:
AlignedUniquePtr
<
RecursiveGaussian
>
&
rg
const
ImageF
&
in
ThreadPool
*
pool
ImageF
*
JXL_RESTRICT
temp
ImageF
*
JXL_RESTRICT
out
)
;
}
#
endif
