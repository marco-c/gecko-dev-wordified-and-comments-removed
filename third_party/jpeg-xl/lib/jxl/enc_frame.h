#
ifndef
LIB_JXL_ENC_FRAME_H_
#
define
LIB_JXL_ENC_FRAME_H_
#
include
<
jxl
/
types
.
h
>
#
include
<
string
>
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
enc_bit_writer
.
h
"
#
include
"
lib
/
jxl
/
enc_cache
.
h
"
#
include
"
lib
/
jxl
/
enc_params
.
h
"
#
include
"
lib
/
jxl
/
encode_internal
.
h
"
#
include
"
lib
/
jxl
/
frame_header
.
h
"
#
include
"
lib
/
jxl
/
image_bundle
.
h
"
namespace
jxl
{
struct
AuxOut
;
struct
FrameInfo
{
bool
save_before_color_transform
=
false
;
bool
ib_needs_color_transform
=
true
;
FrameType
frame_type
=
FrameType
:
:
kRegularFrame
;
size_t
dc_level
=
0
;
bool
is_last
=
true
;
bool
is_preview
=
false
;
size_t
save_as_reference
=
0
;
size_t
source
=
1
;
size_t
clamp
=
1
;
int
alpha_channel
=
-
1
;
FrameOrigin
origin
{
0
0
}
;
bool
blend
=
false
;
BlendMode
blendmode
=
BlendMode
:
:
kBlend
;
JxlBitDepth
image_bit_depth
=
{
}
;
uint32_t
duration
=
0
;
uint32_t
timecode
=
0
;
std
:
:
string
name
;
std
:
:
vector
<
BlendingInfo
>
extra_channel_blending_info
;
}
;
Status
ParamsPostInit
(
CompressParams
*
p
)
;
Status
EncodeFrame
(
const
CompressParams
&
cparams_orig
const
FrameInfo
&
frame_info
const
CodecMetadata
*
metadata
JxlEncoderChunkedFrameAdapter
&
frame_data
const
JxlCmsInterface
&
cms
ThreadPool
*
pool
JxlEncoderOutputProcessorWrapper
*
output_processor
AuxOut
*
aux_out
)
;
Status
EncodeFrame
(
const
CompressParams
&
cparams_orig
const
FrameInfo
&
frame_info
const
CodecMetadata
*
metadata
const
ImageBundle
&
ib
const
JxlCmsInterface
&
cms
ThreadPool
*
pool
BitWriter
*
writer
AuxOut
*
aux_out
)
;
}
#
endif
