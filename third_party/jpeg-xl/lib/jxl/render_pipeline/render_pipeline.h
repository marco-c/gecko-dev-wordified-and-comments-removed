#
ifndef
LIB_JXL_RENDER_PIPELINE_RENDER_PIPELINE_H_
#
define
LIB_JXL_RENDER_PIPELINE_RENDER_PIPELINE_H_
#
include
<
stdint
.
h
>
#
include
"
lib
/
jxl
/
filters
.
h
"
#
include
"
lib
/
jxl
/
render_pipeline
/
render_pipeline_stage
.
h
"
namespace
jxl
{
class
RenderPipelineInput
{
public
:
RenderPipelineInput
(
const
RenderPipelineInput
&
)
=
delete
;
RenderPipelineInput
(
RenderPipelineInput
&
&
other
)
noexcept
{
*
this
=
std
:
:
move
(
other
)
;
}
RenderPipelineInput
&
operator
=
(
RenderPipelineInput
&
&
other
)
noexcept
{
pipeline_
=
other
.
pipeline_
;
group_id_
=
other
.
group_id_
;
thread_id_
=
other
.
thread_id_
;
buffers_
=
std
:
:
move
(
other
.
buffers_
)
;
other
.
pipeline_
=
nullptr
;
return
*
this
;
}
RenderPipelineInput
(
)
=
default
;
void
Done
(
)
;
const
std
:
:
pair
<
ImageF
*
Rect
>
&
GetBuffer
(
size_t
c
)
const
{
JXL_ASSERT
(
c
<
buffers_
.
size
(
)
)
;
return
buffers_
[
c
]
;
}
private
:
RenderPipeline
*
pipeline_
=
nullptr
;
size_t
group_id_
;
size_t
thread_id_
;
std
:
:
vector
<
std
:
:
pair
<
ImageF
*
Rect
>
>
buffers_
;
friend
class
RenderPipeline
;
}
;
class
RenderPipeline
{
public
:
class
Builder
{
public
:
explicit
Builder
(
size_t
num_c
)
:
num_c_
(
num_c
)
{
JXL_ASSERT
(
num_c
>
0
)
;
}
void
AddStage
(
std
:
:
unique_ptr
<
RenderPipelineStage
>
stage
)
;
void
UseSimpleImplementation
(
)
{
use_simple_implementation_
=
true
;
}
void
UsesNoise
(
)
{
uses_noise_
=
true
;
}
std
:
:
unique_ptr
<
RenderPipeline
>
Finalize
(
FrameDimensions
frame_dimensions
)
&
&
;
private
:
std
:
:
vector
<
std
:
:
unique_ptr
<
RenderPipelineStage
>
>
stages_
;
size_t
num_c_
;
bool
use_simple_implementation_
=
false
;
bool
uses_noise_
=
false
;
}
;
friend
class
Builder
;
virtual
~
RenderPipeline
(
)
=
default
;
Status
IsInitialized
(
)
const
{
for
(
const
auto
&
stage
:
stages_
)
{
JXL_RETURN_IF_ERROR
(
stage
-
>
IsInitialized
(
)
)
;
}
return
true
;
}
void
PrepareForThreads
(
size_t
num
)
;
RenderPipelineInput
GetInputBuffers
(
size_t
group_id
size_t
thread_id
)
;
size_t
PassesWithAllInput
(
)
const
{
return
*
std
:
:
min_element
(
group_completed_passes_
.
begin
(
)
group_completed_passes_
.
end
(
)
)
;
}
protected
:
std
:
:
vector
<
std
:
:
unique_ptr
<
RenderPipelineStage
>
>
stages_
;
std
:
:
vector
<
std
:
:
vector
<
std
:
:
pair
<
size_t
size_t
>
>
>
channel_shifts_
;
std
:
:
vector
<
size_t
>
padding_
;
FrameDimensions
frame_dimensions_
;
bool
uses_noise_
;
std
:
:
vector
<
uint8_t
>
group_completed_passes_
;
std
:
:
vector
<
CacheAlignedUniquePtr
>
temp_buffers_
;
friend
class
RenderPipelineInput
;
private
:
void
InputReady
(
size_t
group_id
size_t
thread_id
const
std
:
:
vector
<
std
:
:
pair
<
ImageF
*
Rect
>
>
&
buffers
)
;
virtual
std
:
:
vector
<
std
:
:
pair
<
ImageF
*
Rect
>
>
PrepareBuffers
(
size_t
group_id
size_t
thread_id
)
=
0
;
virtual
void
ProcessBuffers
(
size_t
group_id
size_t
thread_id
)
=
0
;
virtual
void
PrepareForThreadsInternal
(
size_t
num
)
=
0
;
}
;
}
#
endif
