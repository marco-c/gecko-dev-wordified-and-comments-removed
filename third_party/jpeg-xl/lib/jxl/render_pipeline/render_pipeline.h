#
ifndef
LIB_JXL_RENDER_PIPELINE_RENDER_PIPELINE_H_
#
define
LIB_JXL_RENDER_PIPELINE_RENDER_PIPELINE_H_
#
include
<
jxl
/
memory_manager
.
h
>
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
base
/
rect
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
frame_dimensions
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
#
include
"
lib
/
jxl
/
render_pipeline
/
render_pipeline_stage
.
h
"
namespace
jxl
{
class
RenderPipelineInput
{
public
:
RenderPipelineInput
(
const
RenderPipelineInput
&
)
=
delete
;
RenderPipelineInput
(
RenderPipelineInput
&
&
other
)
noexcept
{
*
this
=
std
:
:
move
(
other
)
;
}
RenderPipelineInput
&
operator
=
(
RenderPipelineInput
&
&
other
)
noexcept
{
pipeline_
=
other
.
pipeline_
;
group_id_
=
other
.
group_id_
;
thread_id_
=
other
.
thread_id_
;
buffers_
=
std
:
:
move
(
other
.
buffers_
)
;
other
.
pipeline_
=
nullptr
;
return
*
this
;
}
RenderPipelineInput
(
)
=
default
;
Status
Done
(
)
;
const
std
:
:
pair
<
ImageF
*
Rect
>
&
GetBuffer
(
size_t
c
)
const
{
JXL_ASSERT
(
c
<
buffers_
.
size
(
)
)
;
return
buffers_
[
c
]
;
}
private
:
RenderPipeline
*
pipeline_
=
nullptr
;
size_t
group_id_
;
size_t
thread_id_
;
std
:
:
vector
<
std
:
:
pair
<
ImageF
*
Rect
>
>
buffers_
;
friend
class
RenderPipeline
;
}
;
class
RenderPipeline
{
public
:
class
Builder
{
public
:
explicit
Builder
(
JxlMemoryManager
*
memory_manager
size_t
num_c
)
:
memory_manager_
(
memory_manager
)
num_c_
(
num_c
)
{
JXL_ASSERT
(
num_c
>
0
)
;
}
Status
AddStage
(
std
:
:
unique_ptr
<
RenderPipelineStage
>
stage
)
;
void
UseSimpleImplementation
(
)
{
use_simple_implementation_
=
true
;
}
StatusOr
<
std
:
:
unique_ptr
<
RenderPipeline
>
>
Finalize
(
FrameDimensions
frame_dimensions
)
&
&
;
private
:
JxlMemoryManager
*
memory_manager_
;
std
:
:
vector
<
std
:
:
unique_ptr
<
RenderPipelineStage
>
>
stages_
;
size_t
num_c_
;
bool
use_simple_implementation_
=
false
;
}
;
friend
class
Builder
;
virtual
~
RenderPipeline
(
)
=
default
;
Status
IsInitialized
(
)
const
{
for
(
const
auto
&
stage
:
stages_
)
{
JXL_RETURN_IF_ERROR
(
stage
-
>
IsInitialized
(
)
)
;
}
return
true
;
}
Status
PrepareForThreads
(
size_t
num
bool
use_group_ids
)
;
RenderPipelineInput
GetInputBuffers
(
size_t
group_id
size_t
thread_id
)
;
size_t
PassesWithAllInput
(
)
const
{
return
*
std
:
:
min_element
(
group_completed_passes_
.
begin
(
)
group_completed_passes_
.
end
(
)
)
;
}
virtual
void
ClearDone
(
size_t
i
)
{
}
protected
:
explicit
RenderPipeline
(
JxlMemoryManager
*
memory_manager
)
:
memory_manager_
(
memory_manager
)
{
}
JxlMemoryManager
*
memory_manager_
;
std
:
:
vector
<
std
:
:
unique_ptr
<
RenderPipelineStage
>
>
stages_
;
std
:
:
vector
<
std
:
:
vector
<
std
:
:
pair
<
size_t
size_t
>
>
>
channel_shifts_
;
std
:
:
vector
<
std
:
:
vector
<
std
:
:
pair
<
size_t
size_t
>
>
>
padding_
;
FrameDimensions
frame_dimensions_
;
std
:
:
vector
<
uint8_t
>
group_completed_passes_
;
friend
class
RenderPipelineInput
;
private
:
Status
InputReady
(
size_t
group_id
size_t
thread_id
const
std
:
:
vector
<
std
:
:
pair
<
ImageF
*
Rect
>
>
&
buffers
)
;
virtual
std
:
:
vector
<
std
:
:
pair
<
ImageF
*
Rect
>
>
PrepareBuffers
(
size_t
group_id
size_t
thread_id
)
=
0
;
virtual
Status
ProcessBuffers
(
size_t
group_id
size_t
thread_id
)
=
0
;
virtual
Status
PrepareForThreadsInternal
(
size_t
num
bool
use_group_ids
)
=
0
;
virtual
Status
Init
(
)
{
return
true
;
}
}
;
}
#
endif
