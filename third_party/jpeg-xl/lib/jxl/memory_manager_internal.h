#
ifndef
LIB_JXL_MEMORY_MANAGER_INTERNAL_H_
#
define
LIB_JXL_MEMORY_MANAGER_INTERNAL_H_
#
include
<
jxl
/
memory_manager
.
h
>
#
include
<
cstddef
>
#
include
<
memory
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
namespace
jxl
{
namespace
memory_manager_internal
{
static
constexpr
size_t
kAlignment
=
2
*
64
;
static_assert
(
(
kAlignment
&
(
kAlignment
-
1
)
)
=
=
0
"
kAlignment
must
be
a
power
of
2
"
)
;
static
constexpr
size_t
kNumAlignmentGroups
=
16
;
static
constexpr
size_t
kAlias
=
kNumAlignmentGroups
*
kAlignment
;
static_assert
(
(
kNumAlignmentGroups
&
(
kNumAlignmentGroups
-
1
)
)
=
=
0
"
kNumAlignmentGroups
must
be
a
power
of
2
"
)
;
}
Status
MemoryManagerInit
(
JxlMemoryManager
*
self
const
JxlMemoryManager
*
memory_manager
)
;
void
*
MemoryManagerAlloc
(
const
JxlMemoryManager
*
memory_manager
size_t
size
)
;
void
MemoryManagerFree
(
const
JxlMemoryManager
*
memory_manager
void
*
address
)
;
class
MemoryManagerDeleteHelper
{
public
:
explicit
MemoryManagerDeleteHelper
(
const
JxlMemoryManager
*
memory_manager
)
:
memory_manager_
(
memory_manager
)
{
}
template
<
typename
T
>
void
operator
(
)
(
T
*
address
)
const
{
if
(
!
address
)
{
return
;
}
address
-
>
~
T
(
)
;
return
memory_manager_
-
>
free
(
memory_manager_
-
>
opaque
address
)
;
}
private
:
const
JxlMemoryManager
*
memory_manager_
;
}
;
template
<
typename
T
>
using
MemoryManagerUniquePtr
=
std
:
:
unique_ptr
<
T
MemoryManagerDeleteHelper
>
;
template
<
typename
T
typename
.
.
.
Args
>
JXL_INLINE
MemoryManagerUniquePtr
<
T
>
MemoryManagerMakeUnique
(
const
JxlMemoryManager
*
memory_manager
Args
&
&
.
.
.
args
)
{
T
*
mem
=
static_cast
<
T
*
>
(
memory_manager
-
>
alloc
(
memory_manager
-
>
opaque
sizeof
(
T
)
)
)
;
if
(
!
mem
)
{
return
MemoryManagerUniquePtr
<
T
>
(
nullptr
MemoryManagerDeleteHelper
(
memory_manager
)
)
;
}
return
MemoryManagerUniquePtr
<
T
>
(
new
(
mem
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
MemoryManagerDeleteHelper
(
memory_manager
)
)
;
}
size_t
BytesPerRow
(
size_t
xsize
size_t
sizeof_t
)
;
class
AlignedMemory
{
public
:
AlignedMemory
(
)
:
allocation_
(
nullptr
)
memory_manager_
(
nullptr
)
address_
(
nullptr
)
{
}
AlignedMemory
(
const
AlignedMemory
&
other
)
=
delete
;
AlignedMemory
&
operator
=
(
const
AlignedMemory
&
other
)
=
delete
;
AlignedMemory
(
AlignedMemory
&
&
other
)
noexcept
;
AlignedMemory
&
operator
=
(
AlignedMemory
&
&
other
)
noexcept
;
~
AlignedMemory
(
)
;
static
StatusOr
<
AlignedMemory
>
Create
(
JxlMemoryManager
*
memory_manager
size_t
size
)
;
template
<
typename
T
>
T
*
address
(
)
const
{
return
reinterpret_cast
<
T
*
>
(
address_
)
;
}
JxlMemoryManager
*
memory_manager
(
)
const
{
return
memory_manager_
;
}
private
:
AlignedMemory
(
JxlMemoryManager
*
memory_manager
void
*
allocation
)
;
void
*
allocation_
;
JxlMemoryManager
*
memory_manager_
;
void
*
address_
;
}
;
}
#
endif
