#
ifndef
LIB_JXL_MEMORY_MANAGER_INTERNAL_H_
#
define
LIB_JXL_MEMORY_MANAGER_INTERNAL_H_
#
include
<
jxl
/
memory_manager
.
h
>
#
include
<
cstddef
>
#
include
<
memory
>
#
include
<
utility
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
namespace
jxl
{
namespace
memory_manager_internal
{
static
constexpr
size_t
kAlignment
=
2
*
64
;
static_assert
(
(
kAlignment
&
(
kAlignment
-
1
)
)
=
=
0
"
kAlignment
must
be
a
power
of
2
"
)
;
static
constexpr
size_t
kNumAlignmentGroups
=
16
;
static
constexpr
size_t
kAlias
=
kNumAlignmentGroups
*
kAlignment
;
static_assert
(
(
kNumAlignmentGroups
&
(
kNumAlignmentGroups
-
1
)
)
=
=
0
"
kNumAlignmentGroups
must
be
a
power
of
2
"
)
;
}
Status
MemoryManagerInit
(
JxlMemoryManager
*
self
const
JxlMemoryManager
*
memory_manager
)
;
void
*
MemoryManagerAlloc
(
const
JxlMemoryManager
*
memory_manager
size_t
size
)
;
void
MemoryManagerFree
(
const
JxlMemoryManager
*
memory_manager
void
*
address
)
;
class
MemoryManagerDeleteHelper
{
public
:
explicit
MemoryManagerDeleteHelper
(
const
JxlMemoryManager
*
memory_manager
)
:
memory_manager_
(
memory_manager
)
{
}
template
<
typename
T
>
void
operator
(
)
(
T
*
address
)
const
{
if
(
!
address
)
{
return
;
}
address
-
>
~
T
(
)
;
return
memory_manager_
-
>
free
(
memory_manager_
-
>
opaque
address
)
;
}
private
:
const
JxlMemoryManager
*
memory_manager_
;
}
;
template
<
typename
T
>
using
MemoryManagerUniquePtr
=
std
:
:
unique_ptr
<
T
MemoryManagerDeleteHelper
>
;
template
<
typename
T
typename
.
.
.
Args
>
JXL_INLINE
MemoryManagerUniquePtr
<
T
>
MemoryManagerMakeUnique
(
const
JxlMemoryManager
*
memory_manager
Args
&
&
.
.
.
args
)
{
T
*
mem
=
static_cast
<
T
*
>
(
memory_manager
-
>
alloc
(
memory_manager
-
>
opaque
sizeof
(
T
)
)
)
;
if
(
!
mem
)
{
return
MemoryManagerUniquePtr
<
T
>
(
nullptr
MemoryManagerDeleteHelper
(
memory_manager
)
)
;
}
return
MemoryManagerUniquePtr
<
T
>
(
new
(
mem
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
MemoryManagerDeleteHelper
(
memory_manager
)
)
;
}
size_t
BytesPerRow
(
size_t
xsize
size_t
sizeof_t
)
;
class
AlignedMemory
{
public
:
AlignedMemory
(
)
:
allocation_
(
nullptr
)
memory_manager_
(
nullptr
)
address_
(
nullptr
)
{
}
AlignedMemory
(
const
AlignedMemory
&
other
)
=
delete
;
AlignedMemory
&
operator
=
(
const
AlignedMemory
&
other
)
=
delete
;
AlignedMemory
(
AlignedMemory
&
&
other
)
noexcept
;
AlignedMemory
&
operator
=
(
AlignedMemory
&
&
other
)
noexcept
;
~
AlignedMemory
(
)
;
static
StatusOr
<
AlignedMemory
>
Create
(
JxlMemoryManager
*
memory_manager
size_t
size
size_t
pre_padding
=
0
)
;
explicit
operator
bool
(
)
const
noexcept
{
return
(
address_
!
=
nullptr
)
;
}
template
<
typename
T
>
T
*
address
(
)
const
{
return
reinterpret_cast
<
T
*
>
(
address_
)
;
}
JxlMemoryManager
*
memory_manager
(
)
const
{
return
memory_manager_
;
}
private
:
AlignedMemory
(
JxlMemoryManager
*
memory_manager
void
*
allocation
size_t
pre_padding
)
;
void
*
allocation_
;
JxlMemoryManager
*
memory_manager_
;
void
*
address_
;
}
;
template
<
typename
T
>
class
AlignedArray
{
public
:
AlignedArray
(
)
:
size_
(
0
)
{
}
static
StatusOr
<
AlignedArray
>
Create
(
JxlMemoryManager
*
memory_manager
size_t
size
)
{
size_t
storage_size
=
size
*
sizeof
(
T
)
;
JXL_ASSIGN_OR_RETURN
(
AlignedMemory
storage
AlignedMemory
:
:
Create
(
memory_manager
storage_size
)
)
;
T
*
items
=
storage
.
address
<
T
>
(
)
;
for
(
size_t
i
=
0
;
i
<
size
;
+
+
i
)
{
new
(
items
+
i
)
T
(
)
;
}
return
AlignedArray
<
T
>
(
std
:
:
move
(
storage
)
size
)
;
}
AlignedArray
(
const
AlignedArray
&
other
)
=
delete
;
AlignedArray
&
operator
=
(
const
AlignedArray
&
other
)
=
delete
;
AlignedArray
(
AlignedArray
&
&
other
)
noexcept
{
size_
=
other
.
size_
;
storage_
=
std
:
:
move
(
other
.
storage_
)
;
other
.
size_
=
0
;
}
AlignedArray
&
operator
=
(
AlignedArray
&
&
other
)
noexcept
{
if
(
this
=
=
&
other
)
return
*
this
;
size_
=
other
.
size_
;
storage_
=
std
:
:
move
(
other
.
storage_
)
;
other
.
size_
=
0
;
return
*
this
;
}
~
AlignedArray
(
)
{
if
(
!
size_
)
return
;
T
*
items
=
storage_
.
address
<
T
>
(
)
;
for
(
size_t
i
=
0
;
i
<
size_
;
+
+
i
)
{
items
[
i
]
.
~
T
(
)
;
}
}
T
&
operator
[
]
(
const
size_t
i
)
{
JXL_DASSERT
(
i
<
size_
)
;
return
*
(
storage_
.
address
<
T
>
(
)
+
i
)
;
}
const
T
&
operator
[
]
(
const
size_t
i
)
const
{
JXL_DASSERT
(
i
<
size_
)
;
return
*
(
storage_
.
address
<
T
>
(
)
+
i
)
;
}
private
:
explicit
AlignedArray
(
AlignedMemory
&
&
storage
size_t
size
)
:
size_
(
size
)
storage_
(
std
:
:
move
(
storage
)
)
{
}
size_t
size_
;
AlignedMemory
storage_
;
}
;
}
#
endif
