#
ifndef
LIB_JXL_ENC_BIT_WRITER_H_
#
define
LIB_JXL_ENC_BIT_WRITER_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
padded_bytes
.
h
"
#
include
"
lib
/
jxl
/
base
/
span
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
common
.
h
"
namespace
jxl
{
struct
BitWriter
{
static
constexpr
size_t
kMaxBitsPerCall
=
56
;
BitWriter
(
)
:
bits_written_
(
0
)
{
}
BitWriter
(
const
BitWriter
&
)
=
delete
;
BitWriter
&
operator
=
(
const
BitWriter
&
)
=
delete
;
BitWriter
(
BitWriter
&
&
)
=
default
;
BitWriter
&
operator
=
(
BitWriter
&
&
)
=
default
;
size_t
BitsWritten
(
)
const
{
return
bits_written_
;
}
Span
<
const
uint8_t
>
GetSpan
(
)
const
{
JXL_ASSERT
(
bits_written_
%
kBitsPerByte
=
=
0
)
;
return
Span
<
const
uint8_t
>
(
storage_
.
data
(
)
bits_written_
/
kBitsPerByte
)
;
}
PaddedBytes
&
&
TakeBytes
(
)
&
&
{
JXL_ASSERT
(
bits_written_
%
kBitsPerByte
=
=
0
)
;
storage_
.
resize
(
bits_written_
/
kBitsPerByte
)
;
return
std
:
:
move
(
storage_
)
;
}
private
:
void
AppendByteAligned
(
const
Span
<
const
uint8_t
>
&
span
)
;
public
:
void
AppendByteAligned
(
const
BitWriter
&
other
)
;
void
AppendByteAligned
(
const
std
:
:
vector
<
std
:
:
unique_ptr
<
BitWriter
>
>
&
others
)
;
void
AppendByteAligned
(
const
std
:
:
vector
<
BitWriter
>
&
others
)
;
class
Allotment
{
public
:
Allotment
(
BitWriter
*
JXL_RESTRICT
writer
size_t
max_bits
)
;
~
Allotment
(
)
;
size_t
MaxBits
(
)
const
{
return
max_bits_
;
}
void
FinishedHistogram
(
BitWriter
*
JXL_RESTRICT
writer
)
;
size_t
HistogramBits
(
)
const
{
JXL_ASSERT
(
called_
)
;
return
histogram_bits_
;
}
void
PrivateReclaim
(
BitWriter
*
JXL_RESTRICT
writer
size_t
*
JXL_RESTRICT
used_bits
size_t
*
JXL_RESTRICT
unused_bits
)
;
private
:
size_t
prev_bits_written_
;
const
size_t
max_bits_
;
size_t
histogram_bits_
=
0
;
bool
called_
=
false
;
Allotment
*
parent_
;
}
;
void
Write
(
size_t
n_bits
uint64_t
bits
)
;
void
ZeroPadToByte
(
)
{
const
size_t
remainder_bits
=
RoundUpBitsToByteMultiple
(
bits_written_
)
-
bits_written_
;
if
(
remainder_bits
=
=
0
)
return
;
Write
(
remainder_bits
0
)
;
JXL_ASSERT
(
bits_written_
%
kBitsPerByte
=
=
0
)
;
}
private
:
size_t
bits_written_
;
PaddedBytes
storage_
;
Allotment
*
current_allotment_
=
nullptr
;
}
;
}
#
endif
