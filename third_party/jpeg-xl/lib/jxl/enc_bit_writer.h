#
ifndef
LIB_JXL_ENC_BIT_WRITER_H_
#
define
LIB_JXL_ENC_BIT_WRITER_H_
#
include
<
jxl
/
memory_manager
.
h
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
functional
>
#
include
<
memory
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
base
/
common
.
h
"
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
span
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
padded_bytes
.
h
"
namespace
jxl
{
struct
AuxOut
;
enum
class
LayerType
:
uint8_t
;
struct
BitWriter
{
static
constexpr
size_t
kMaxBitsPerCall
=
56
;
explicit
BitWriter
(
JxlMemoryManager
*
memory_manager
)
:
bits_written_
(
0
)
storage_
(
memory_manager
)
{
}
BitWriter
(
const
BitWriter
&
)
=
delete
;
BitWriter
&
operator
=
(
const
BitWriter
&
)
=
delete
;
BitWriter
(
BitWriter
&
&
)
=
default
;
BitWriter
&
operator
=
(
BitWriter
&
&
)
=
default
;
size_t
BitsWritten
(
)
const
{
return
bits_written_
;
}
JxlMemoryManager
*
memory_manager
(
)
const
{
return
storage_
.
memory_manager
(
)
;
}
Span
<
const
uint8_t
>
GetSpan
(
)
const
{
JXL_DASSERT
(
bits_written_
%
kBitsPerByte
=
=
0
)
;
return
Bytes
(
storage_
.
data
(
)
DivCeil
(
bits_written_
kBitsPerByte
)
)
;
}
PaddedBytes
&
&
TakeBytes
(
)
&
&
{
JXL_DASSERT
(
bits_written_
%
kBitsPerByte
=
=
0
)
;
Status
status
=
storage_
.
resize
(
DivCeil
(
bits_written_
kBitsPerByte
)
)
;
JXL_DASSERT
(
status
)
;
(
void
)
status
;
return
std
:
:
move
(
storage_
)
;
}
Status
AppendByteAligned
(
const
Span
<
const
uint8_t
>
&
span
)
;
Status
AppendByteAligned
(
const
std
:
:
vector
<
std
:
:
unique_ptr
<
BitWriter
>
>
&
others
)
;
Status
AppendUnaligned
(
const
BitWriter
&
other
)
;
void
Write
(
size_t
n_bits
uint64_t
bits
)
;
void
ZeroPadToByte
(
)
{
const
size_t
remainder_bits
=
RoundUpBitsToByteMultiple
(
bits_written_
)
-
bits_written_
;
if
(
remainder_bits
=
=
0
)
return
;
Write
(
remainder_bits
0
)
;
JXL_DASSERT
(
bits_written_
%
kBitsPerByte
=
=
0
)
;
}
Status
WithMaxBits
(
size_t
max_bits
LayerType
layer
AuxOut
*
JXL_RESTRICT
aux_out
const
std
:
:
function
<
Status
(
)
>
&
function
bool
finished_histogram
=
false
)
;
private
:
class
Allotment
{
public
:
explicit
Allotment
(
size_t
max_bits
)
;
~
Allotment
(
)
;
Allotment
(
const
Allotment
&
other
)
=
delete
;
Allotment
(
Allotment
&
&
other
)
=
delete
;
Allotment
&
operator
=
(
const
Allotment
&
)
=
delete
;
Allotment
&
operator
=
(
Allotment
&
&
)
=
delete
;
Status
FinishedHistogram
(
BitWriter
*
JXL_RESTRICT
writer
)
;
size_t
HistogramBits
(
)
const
{
JXL_DASSERT
(
called_
)
;
return
histogram_bits_
;
}
Status
ReclaimAndCharge
(
BitWriter
*
JXL_RESTRICT
writer
LayerType
layer
AuxOut
*
JXL_RESTRICT
aux_out
)
;
private
:
friend
struct
BitWriter
;
Status
Init
(
BitWriter
*
JXL_RESTRICT
writer
)
;
Status
PrivateReclaim
(
BitWriter
*
JXL_RESTRICT
writer
size_t
*
JXL_RESTRICT
used_bits
size_t
*
JXL_RESTRICT
unused_bits
)
;
size_t
prev_bits_written_
;
const
size_t
max_bits_
;
size_t
histogram_bits_
=
0
;
bool
called_
=
false
;
Allotment
*
parent_
;
}
;
size_t
bits_written_
;
PaddedBytes
storage_
;
Allotment
*
current_allotment_
=
nullptr
;
}
;
}
#
endif
