#
ifndef
LIB_JXL_FRAME_HEADER_H_
#
define
LIB_JXL_FRAME_HEADER_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
override
.
h
"
#
include
"
lib
/
jxl
/
base
/
padded_bytes
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
coeff_order_fwd
.
h
"
#
include
"
lib
/
jxl
/
common
.
h
"
#
include
"
lib
/
jxl
/
dec_bit_reader
.
h
"
#
include
"
lib
/
jxl
/
fields
.
h
"
#
include
"
lib
/
jxl
/
image_metadata
.
h
"
#
include
"
lib
/
jxl
/
loop_filter
.
h
"
namespace
jxl
{
static
inline
Status
VisitNameString
(
Visitor
*
JXL_RESTRICT
visitor
std
:
:
string
*
name
)
{
uint32_t
name_length
=
static_cast
<
uint32_t
>
(
name
-
>
length
(
)
)
;
JXL_QUIET_RETURN_IF_ERROR
(
visitor
-
>
U32
(
Val
(
0
)
Bits
(
4
)
BitsOffset
(
5
16
)
BitsOffset
(
10
48
)
0
&
name_length
)
)
;
if
(
visitor
-
>
IsReading
(
)
)
{
name
-
>
resize
(
name_length
)
;
}
for
(
size_t
i
=
0
;
i
<
name_length
;
i
+
+
)
{
uint32_t
c
=
static_cast
<
uint8_t
>
(
(
*
name
)
[
i
]
)
;
JXL_QUIET_RETURN_IF_ERROR
(
visitor
-
>
Bits
(
8
0
&
c
)
)
;
(
*
name
)
[
i
]
=
static_cast
<
char
>
(
c
)
;
}
return
true
;
}
enum
class
FrameEncoding
:
uint32_t
{
kVarDCT
kModular
}
;
enum
class
ColorTransform
:
uint32_t
{
kXYB
kNone
kYCbCr
}
;
inline
std
:
:
array
<
int
3
>
JpegOrder
(
ColorTransform
ct
bool
is_gray
)
{
if
(
is_gray
)
{
return
{
{
0
0
0
}
}
;
}
JXL_ASSERT
(
ct
!
=
ColorTransform
:
:
kXYB
)
;
if
(
ct
=
=
ColorTransform
:
:
kYCbCr
)
{
return
{
{
1
0
2
}
}
;
}
else
{
return
{
{
0
1
2
}
}
;
}
}
struct
YCbCrChromaSubsampling
:
public
Fields
{
YCbCrChromaSubsampling
(
)
;
JXL_FIELDS_NAME
(
YCbCrChromaSubsampling
)
size_t
HShift
(
size_t
c
)
const
{
return
maxhs_
-
kHShift
[
channel_mode_
[
c
]
]
;
}
size_t
VShift
(
size_t
c
)
const
{
return
maxvs_
-
kVShift
[
channel_mode_
[
c
]
]
;
}
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
{
for
(
size_t
i
=
0
;
i
<
3
;
i
+
+
)
{
JXL_QUIET_RETURN_IF_ERROR
(
visitor
-
>
Bits
(
2
0
&
channel_mode_
[
i
]
)
)
;
}
Recompute
(
)
;
return
true
;
}
uint8_t
MaxHShift
(
)
const
{
return
maxhs_
;
}
uint8_t
MaxVShift
(
)
const
{
return
maxvs_
;
}
uint8_t
RawHShift
(
size_t
c
)
const
{
return
kHShift
[
channel_mode_
[
c
]
]
;
}
uint8_t
RawVShift
(
size_t
c
)
const
{
return
kVShift
[
channel_mode_
[
c
]
]
;
}
Status
Set
(
const
uint8_t
*
hsample
const
uint8_t
*
vsample
)
{
for
(
size_t
c
=
0
;
c
<
3
;
c
+
+
)
{
size_t
cjpeg
=
c
<
2
?
c
^
1
:
c
;
size_t
i
=
0
;
for
(
;
i
<
4
;
i
+
+
)
{
if
(
1
<
<
kHShift
[
i
]
=
=
hsample
[
cjpeg
]
&
&
1
<
<
kVShift
[
i
]
=
=
vsample
[
cjpeg
]
)
{
channel_mode_
[
c
]
=
i
;
break
;
}
}
if
(
i
=
=
4
)
{
return
JXL_FAILURE
(
"
Invalid
subsample
mode
"
)
;
}
}
Recompute
(
)
;
return
true
;
}
bool
Is444
(
)
const
{
return
HShift
(
0
)
=
=
0
&
&
VShift
(
0
)
=
=
0
&
&
HShift
(
2
)
=
=
0
&
&
VShift
(
2
)
=
=
0
&
&
HShift
(
1
)
=
=
0
&
&
VShift
(
1
)
=
=
0
;
}
bool
Is420
(
)
const
{
return
HShift
(
0
)
=
=
1
&
&
VShift
(
0
)
=
=
1
&
&
HShift
(
2
)
=
=
1
&
&
VShift
(
2
)
=
=
1
&
&
HShift
(
1
)
=
=
0
&
&
VShift
(
1
)
=
=
0
;
}
bool
Is422
(
)
const
{
return
HShift
(
0
)
=
=
1
&
&
VShift
(
0
)
=
=
0
&
&
HShift
(
2
)
=
=
1
&
&
VShift
(
2
)
=
=
0
&
&
HShift
(
1
)
=
=
0
&
&
VShift
(
1
)
=
=
0
;
}
bool
Is440
(
)
const
{
return
HShift
(
0
)
=
=
0
&
&
VShift
(
0
)
=
=
1
&
&
HShift
(
2
)
=
=
0
&
&
VShift
(
2
)
=
=
1
&
&
HShift
(
1
)
=
=
0
&
&
VShift
(
1
)
=
=
0
;
}
std
:
:
string
DebugString
(
)
const
{
if
(
Is444
(
)
)
return
"
444
"
;
if
(
Is420
(
)
)
return
"
420
"
;
if
(
Is422
(
)
)
return
"
422
"
;
if
(
Is440
(
)
)
return
"
440
"
;
return
"
cs
"
+
std
:
:
to_string
(
channel_mode_
[
0
]
)
+
std
:
:
to_string
(
channel_mode_
[
1
]
)
+
std
:
:
to_string
(
channel_mode_
[
2
]
)
;
}
private
:
void
Recompute
(
)
{
maxhs_
=
0
;
maxvs_
=
0
;
for
(
size_t
i
=
0
;
i
<
3
;
i
+
+
)
{
maxhs_
=
std
:
:
max
(
maxhs_
kHShift
[
channel_mode_
[
i
]
]
)
;
maxvs_
=
std
:
:
max
(
maxvs_
kVShift
[
channel_mode_
[
i
]
]
)
;
}
}
static
const
uint8_t
kHShift
[
4
]
;
static
const
uint8_t
kVShift
[
4
]
;
uint32_t
channel_mode_
[
3
]
;
uint8_t
maxhs_
;
uint8_t
maxvs_
;
}
;
enum
class
BlendMode
{
kReplace
=
0
kAdd
=
1
kBlend
=
2
kAlphaWeightedAdd
=
3
kMul
=
4
}
;
struct
BlendingInfo
:
public
Fields
{
BlendingInfo
(
)
;
JXL_FIELDS_NAME
(
BlendingInfo
)
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
BlendMode
mode
;
uint32_t
alpha_channel
;
bool
clamp
;
uint32_t
source
;
std
:
:
string
DebugString
(
)
const
;
size_t
nonserialized_num_extra_channels
=
0
;
bool
nonserialized_is_partial_frame
=
false
;
}
;
struct
FrameOrigin
{
int32_t
x0
y0
;
}
;
struct
FrameSize
{
uint32_t
xsize
ysize
;
}
;
struct
AnimationFrame
:
public
Fields
{
explicit
AnimationFrame
(
const
CodecMetadata
*
metadata
)
;
JXL_FIELDS_NAME
(
AnimationFrame
)
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
uint32_t
duration
;
uint32_t
timecode
;
const
CodecMetadata
*
nonserialized_metadata
=
nullptr
;
}
;
struct
Passes
:
public
Fields
{
Passes
(
)
;
JXL_FIELDS_NAME
(
Passes
)
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
void
GetDownsamplingBracket
(
size_t
pass
int
&
minShift
int
&
maxShift
)
const
{
maxShift
=
2
;
minShift
=
3
;
for
(
size_t
i
=
0
;
;
i
+
+
)
{
for
(
uint32_t
j
=
0
;
j
<
num_downsample
;
+
+
j
)
{
if
(
i
=
=
last_pass
[
j
]
)
{
if
(
downsample
[
j
]
=
=
8
)
minShift
=
3
;
if
(
downsample
[
j
]
=
=
4
)
minShift
=
2
;
if
(
downsample
[
j
]
=
=
2
)
minShift
=
1
;
if
(
downsample
[
j
]
=
=
1
)
minShift
=
0
;
}
}
if
(
i
=
=
num_passes
-
1
)
minShift
=
0
;
if
(
i
=
=
pass
)
return
;
maxShift
=
minShift
-
1
;
}
}
uint32_t
GetDownsamplingTargetForCompletedPasses
(
uint32_t
num_p
)
const
{
if
(
num_p
>
=
num_passes
)
return
1
;
uint32_t
retval
=
8
;
for
(
uint32_t
i
=
0
;
i
<
num_downsample
;
+
+
i
)
{
if
(
num_p
>
last_pass
[
i
]
)
{
retval
=
std
:
:
min
(
retval
downsample
[
i
]
)
;
}
}
return
retval
;
}
std
:
:
string
DebugString
(
)
const
;
uint32_t
num_passes
;
uint32_t
num_downsample
;
uint32_t
downsample
[
kMaxNumPasses
]
;
uint32_t
last_pass
[
kMaxNumPasses
]
;
uint32_t
shift
[
kMaxNumPasses
]
;
}
;
enum
FrameType
{
kRegularFrame
=
0
kDCFrame
=
1
kReferenceOnly
=
2
kSkipProgressive
=
3
}
;
struct
FrameHeader
:
public
Fields
{
enum
Flags
{
kNoise
=
1
kPatches
=
2
kSplines
=
16
kUseDcFrame
=
32
kSkipAdaptiveDCSmoothing
=
128
}
;
explicit
FrameHeader
(
const
CodecMetadata
*
metadata
)
;
JXL_FIELDS_NAME
(
FrameHeader
)
Status
VisitFields
(
Visitor
*
JXL_RESTRICT
visitor
)
override
;
void
UpdateFlag
(
const
bool
condition
const
uint64_t
flag
)
{
if
(
condition
)
{
flags
|
=
flag
;
}
else
{
flags
&
=
~
flag
;
}
}
bool
CanBeReferenced
(
)
const
{
return
!
is_last
&
&
frame_type
!
=
FrameType
:
:
kDCFrame
&
&
(
animation_frame
.
duration
=
=
0
|
|
save_as_reference
!
=
0
)
;
}
mutable
bool
all_default
;
FrameEncoding
encoding
;
FrameType
frame_type
=
FrameType
:
:
kRegularFrame
;
uint64_t
flags
;
ColorTransform
color_transform
;
YCbCrChromaSubsampling
chroma_subsampling
;
uint32_t
group_size_shift
;
uint32_t
x_qm_scale
;
uint32_t
b_qm_scale
;
std
:
:
string
name
;
Passes
passes
;
bool
custom_size_or_origin
;
FrameSize
frame_size
;
uint32_t
upsampling
;
std
:
:
vector
<
uint32_t
>
extra_channel_upsampling
;
FrameOrigin
frame_origin
;
BlendingInfo
blending_info
;
std
:
:
vector
<
BlendingInfo
>
extra_channel_blending_info
;
AnimationFrame
animation_frame
;
bool
is_last
;
uint32_t
save_as_reference
;
bool
save_before_color_transform
;
uint32_t
dc_level
;
const
CodecMetadata
*
nonserialized_metadata
=
nullptr
;
LoopFilter
loop_filter
;
bool
nonserialized_is_preview
=
false
;
size_t
default_xsize
(
)
const
{
if
(
!
nonserialized_metadata
)
return
0
;
if
(
nonserialized_is_preview
)
{
return
nonserialized_metadata
-
>
m
.
preview_size
.
xsize
(
)
;
}
return
nonserialized_metadata
-
>
xsize
(
)
;
}
size_t
default_ysize
(
)
const
{
if
(
!
nonserialized_metadata
)
return
0
;
if
(
nonserialized_is_preview
)
{
return
nonserialized_metadata
-
>
m
.
preview_size
.
ysize
(
)
;
}
return
nonserialized_metadata
-
>
ysize
(
)
;
}
FrameDimensions
ToFrameDimensions
(
)
const
{
size_t
xsize
=
default_xsize
(
)
;
size_t
ysize
=
default_ysize
(
)
;
xsize
=
frame_size
.
xsize
?
frame_size
.
xsize
:
xsize
;
ysize
=
frame_size
.
ysize
?
frame_size
.
ysize
:
ysize
;
if
(
dc_level
!
=
0
)
{
xsize
=
DivCeil
(
xsize
1
<
<
(
3
*
dc_level
)
)
;
ysize
=
DivCeil
(
ysize
1
<
<
(
3
*
dc_level
)
)
;
}
FrameDimensions
frame_dim
;
frame_dim
.
Set
(
xsize
ysize
group_size_shift
chroma_subsampling
.
MaxHShift
(
)
chroma_subsampling
.
MaxVShift
(
)
encoding
=
=
FrameEncoding
:
:
kModular
upsampling
)
;
return
frame_dim
;
}
bool
needs_color_transform
(
)
const
{
return
!
save_before_color_transform
|
|
frame_type
=
=
FrameType
:
:
kRegularFrame
|
|
frame_type
=
=
FrameType
:
:
kSkipProgressive
;
}
std
:
:
string
DebugString
(
)
const
;
uint64_t
extensions
;
}
;
Status
ReadFrameHeader
(
BitReader
*
JXL_RESTRICT
reader
FrameHeader
*
JXL_RESTRICT
frame
)
;
static
constexpr
U32Enc
kOrderEnc
=
U32Enc
(
Val
(
0x5F
)
Val
(
0x13
)
Val
(
0
)
Bits
(
kNumOrders
)
)
;
}
#
endif
