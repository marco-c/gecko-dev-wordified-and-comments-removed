#
ifndef
LIB_JXL_MODULAR_ENCODING_ENC_MA_H_
#
define
LIB_JXL_MODULAR_ENCODING_ENC_MA_H_
#
include
<
numeric
>
#
include
"
lib
/
jxl
/
enc_ans
.
h
"
#
include
"
lib
/
jxl
/
entropy_coder
.
h
"
#
include
"
lib
/
jxl
/
modular
/
encoding
/
dec_ma
.
h
"
#
include
"
lib
/
jxl
/
modular
/
modular_image
.
h
"
#
include
"
lib
/
jxl
/
modular
/
options
.
h
"
namespace
jxl
{
struct
TreeSamples
{
bool
HasSamples
(
)
const
{
return
!
residuals
.
empty
(
)
&
&
!
residuals
[
0
]
.
empty
(
)
;
}
size_t
NumDistinctSamples
(
)
const
{
return
sample_counts
.
size
(
)
;
}
size_t
NumSamples
(
)
const
{
return
num_samples
;
}
Status
SetPredictor
(
Predictor
predictor
ModularOptions
:
:
TreeMode
wp_tree_mode
)
;
Status
SetProperties
(
const
std
:
:
vector
<
uint32_t
>
&
properties
ModularOptions
:
:
TreeMode
wp_tree_mode
)
;
size_t
Token
(
size_t
pred
size_t
i
)
const
{
return
residuals
[
pred
]
[
i
]
.
tok
;
}
size_t
NBits
(
size_t
pred
size_t
i
)
const
{
return
residuals
[
pred
]
[
i
]
.
nbits
;
}
size_t
Count
(
size_t
i
)
const
{
return
sample_counts
[
i
]
;
}
size_t
PredictorIndex
(
Predictor
predictor
)
const
{
const
auto
predictor_elem
=
std
:
:
find
(
predictors
.
begin
(
)
predictors
.
end
(
)
predictor
)
;
JXL_DASSERT
(
predictor_elem
!
=
predictors
.
end
(
)
)
;
return
predictor_elem
-
predictors
.
begin
(
)
;
}
size_t
PropertyIndex
(
size_t
property
)
const
{
const
auto
property_elem
=
std
:
:
find
(
props_to_use
.
begin
(
)
props_to_use
.
end
(
)
property
)
;
JXL_DASSERT
(
property_elem
!
=
props_to_use
.
end
(
)
)
;
return
property_elem
-
props_to_use
.
begin
(
)
;
}
size_t
NumPropertyValues
(
size_t
property_index
)
const
{
return
compact_properties
[
property_index
]
.
size
(
)
+
1
;
}
size_t
Property
(
size_t
property_index
size_t
i
)
const
{
return
props
[
property_index
]
[
i
]
;
}
int
UnquantizeProperty
(
size_t
property_index
uint32_t
quant
)
const
{
JXL_ASSERT
(
quant
<
compact_properties
[
property_index
]
.
size
(
)
)
;
return
compact_properties
[
property_index
]
[
quant
]
;
}
Predictor
PredictorFromIndex
(
size_t
index
)
const
{
JXL_DASSERT
(
index
<
predictors
.
size
(
)
)
;
return
predictors
[
index
]
;
}
size_t
PropertyFromIndex
(
size_t
index
)
const
{
JXL_DASSERT
(
index
<
props_to_use
.
size
(
)
)
;
return
props_to_use
[
index
]
;
}
size_t
NumPredictors
(
)
const
{
return
predictors
.
size
(
)
;
}
size_t
NumProperties
(
)
const
{
return
props_to_use
.
size
(
)
;
}
void
PrepareForSamples
(
size_t
num_samples
)
;
void
AddSample
(
pixel_type_w
pixel
const
Properties
&
properties
const
pixel_type_w
*
predictions
)
;
void
PreQuantizeProperties
(
const
StaticPropRange
&
range
const
std
:
:
vector
<
ModularMultiplierInfo
>
&
multiplier_info
const
std
:
:
vector
<
uint32_t
>
&
group_pixel_count
const
std
:
:
vector
<
uint32_t
>
&
channel_pixel_count
std
:
:
vector
<
pixel_type
>
&
pixel_samples
std
:
:
vector
<
pixel_type
>
&
diff_samples
size_t
max_property_values
)
;
void
AllSamplesDone
(
)
{
dedup_table_
=
std
:
:
vector
<
uint32_t
>
(
)
;
}
uint32_t
QuantizeProperty
(
uint32_t
prop
pixel_type
v
)
const
{
v
=
std
:
:
min
(
std
:
:
max
(
v
-
kPropertyRange
)
kPropertyRange
)
+
kPropertyRange
;
return
property_mapping
[
prop
]
[
v
]
;
}
void
Swap
(
size_t
a
size_t
b
)
;
void
ThreeShuffle
(
size_t
a
size_t
b
size_t
c
)
;
private
:
struct
ResidualToken
{
uint8_t
tok
;
uint8_t
nbits
;
}
;
std
:
:
vector
<
std
:
:
vector
<
ResidualToken
>
>
residuals
;
std
:
:
vector
<
uint16_t
>
sample_counts
;
std
:
:
vector
<
std
:
:
vector
<
uint8_t
>
>
props
;
std
:
:
vector
<
std
:
:
vector
<
int32_t
>
>
compact_properties
;
std
:
:
vector
<
uint32_t
>
props_to_use
;
std
:
:
vector
<
Predictor
>
predictors
;
static
constexpr
int32_t
kPropertyRange
=
511
;
std
:
:
vector
<
std
:
:
vector
<
uint8_t
>
>
property_mapping
;
size_t
num_samples
=
0
;
static
constexpr
uint32_t
kDedupEntryUnused
{
static_cast
<
uint32_t
>
(
-
1
)
}
;
std
:
:
vector
<
uint32_t
>
dedup_table_
;
bool
IsSameSample
(
size_t
a
size_t
b
)
const
;
size_t
Hash1
(
size_t
a
)
const
;
size_t
Hash2
(
size_t
a
)
const
;
void
InitTable
(
size_t
size
)
;
bool
AddToTableAndMerge
(
size_t
a
)
;
void
AddToTable
(
size_t
a
)
;
}
;
void
TokenizeTree
(
const
Tree
&
tree
std
:
:
vector
<
Token
>
*
tokens
Tree
*
decoder_tree
)
;
void
CollectPixelSamples
(
const
Image
&
image
const
ModularOptions
&
options
size_t
group_id
std
:
:
vector
<
uint32_t
>
&
group_pixel_count
std
:
:
vector
<
uint32_t
>
&
channel_pixel_count
std
:
:
vector
<
pixel_type
>
&
pixel_samples
std
:
:
vector
<
pixel_type
>
&
diff_samples
)
;
void
ComputeBestTree
(
TreeSamples
&
tree_samples
float
threshold
const
std
:
:
vector
<
ModularMultiplierInfo
>
&
mul_info
StaticPropRange
static_prop_range
float
fast_decode_multiplier
Tree
*
tree
)
;
}
#
endif
