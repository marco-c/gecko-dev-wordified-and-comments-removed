#
ifndef
LIB_JXL_MODULAR_OPTIONS_H_
#
define
LIB_JXL_MODULAR_OPTIONS_H_
#
include
<
array
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
vector
>
#
include
"
lib
/
jxl
/
enc_ans_params
.
h
"
namespace
jxl
{
using
PropertyVal
=
int32_t
;
using
Properties
=
std
:
:
vector
<
PropertyVal
>
;
enum
class
Predictor
:
uint32_t
{
Zero
=
0
Left
=
1
Top
=
2
Average0
=
3
Select
=
4
Gradient
=
5
Weighted
=
6
TopRight
=
7
TopLeft
=
8
LeftLeft
=
9
Average1
=
10
Average2
=
11
Average3
=
12
Average4
=
13
Best
=
14
Variable
=
15
}
;
constexpr
Predictor
kUndefinedPredictor
=
static_cast
<
Predictor
>
(
~
0u
)
;
constexpr
size_t
kNumModularPredictors
=
static_cast
<
size_t
>
(
Predictor
:
:
Average4
)
+
1
;
constexpr
size_t
kNumModularEncoderPredictors
=
static_cast
<
size_t
>
(
Predictor
:
:
Variable
)
+
1
;
static
constexpr
ssize_t
kNumStaticProperties
=
2
;
using
StaticPropRange
=
std
:
:
array
<
std
:
:
array
<
uint32_t
2
>
kNumStaticProperties
>
;
struct
ModularMultiplierInfo
{
StaticPropRange
range
;
uint32_t
multiplier
;
}
;
struct
ModularOptions
{
size_t
max_chan_size
=
0xFFFFFF
;
size_t
group_dim
=
0x1FFFFFFF
;
float
nb_repeats
=
.
5f
;
int
max_properties
=
0
;
std
:
:
vector
<
uint32_t
>
splitting_heuristics_properties
=
{
0
1
15
9
10
11
12
13
}
;
float
splitting_heuristics_node_threshold
=
96
;
size_t
max_property_values
=
32
;
Predictor
predictor
=
kUndefinedPredictor
;
int
wp_mode
=
0
;
float
fast_decode_multiplier
=
1
.
01f
;
enum
class
TreeMode
{
kGradientOnly
kWPOnly
kNoWP
kDefault
}
;
TreeMode
wp_tree_mode
=
TreeMode
:
:
kDefault
;
bool
skip_encoder_fast_path
=
false
;
enum
class
TreeKind
{
kTrivialTreeNoPredictor
kLearn
kJpegTranscodeACMeta
kFalconACMeta
kACMeta
kWPFixedDC
kGradientFixedDC
}
;
TreeKind
tree_kind
=
TreeKind
:
:
kLearn
;
HistogramParams
histogram_params
;
bool
zero_tokens
=
false
;
}
;
}
#
endif
