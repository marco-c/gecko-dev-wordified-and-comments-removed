#
ifndef
LIB_JXL_BASE_PADDED_BYTES_H_
#
define
LIB_JXL_BASE_PADDED_BYTES_H_
#
include
<
jxl
/
memory_manager
.
h
>
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
initializer_list
>
#
include
<
utility
>
#
include
"
lib
/
jxl
/
base
/
compiler_specific
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
memory_manager_internal
.
h
"
namespace
jxl
{
class
PaddedBytes
{
public
:
explicit
PaddedBytes
(
JxlMemoryManager
*
memory_manager
)
:
memory_manager_
(
memory_manager
)
size_
(
0
)
capacity_
(
0
)
{
}
PaddedBytes
(
JxlMemoryManager
*
memory_manager
size_t
size
)
:
memory_manager_
(
memory_manager
)
size_
(
size
)
capacity_
(
0
)
{
reserve
(
size
)
;
}
PaddedBytes
(
JxlMemoryManager
*
memory_manager
size_t
size
uint8_t
value
)
:
memory_manager_
(
memory_manager
)
size_
(
size
)
capacity_
(
0
)
{
reserve
(
size
)
;
if
(
size_
!
=
0
)
{
memset
(
data
(
)
value
size
)
;
}
}
PaddedBytes
(
const
PaddedBytes
&
other
)
:
memory_manager_
(
other
.
memory_manager_
)
size_
(
other
.
size_
)
capacity_
(
0
)
{
reserve
(
size_
)
;
if
(
data
(
)
!
=
nullptr
)
memcpy
(
data
(
)
other
.
data
(
)
size_
)
;
}
PaddedBytes
&
operator
=
(
const
PaddedBytes
&
other
)
{
if
(
this
=
=
&
other
)
return
*
this
;
resize
(
other
.
size
(
)
)
;
if
(
data
(
)
!
=
nullptr
)
memmove
(
data
(
)
other
.
data
(
)
size_
)
;
return
*
this
;
}
PaddedBytes
(
PaddedBytes
&
&
other
)
noexcept
:
memory_manager_
(
other
.
memory_manager_
)
size_
(
other
.
size_
)
capacity_
(
other
.
capacity_
)
data_
(
std
:
:
move
(
other
.
data_
)
)
{
other
.
size_
=
other
.
capacity_
=
0
;
}
PaddedBytes
&
operator
=
(
PaddedBytes
&
&
other
)
noexcept
{
memory_manager_
=
other
.
memory_manager_
;
size_
=
other
.
size_
;
capacity_
=
other
.
capacity_
;
data_
=
std
:
:
move
(
other
.
data_
)
;
if
(
&
other
!
=
this
)
{
other
.
size_
=
other
.
capacity_
=
0
;
}
return
*
this
;
}
JxlMemoryManager
*
memory_manager
(
)
const
{
return
memory_manager_
;
}
void
swap
(
PaddedBytes
&
other
)
noexcept
{
std
:
:
swap
(
memory_manager_
other
.
memory_manager_
)
;
std
:
:
swap
(
size_
other
.
size_
)
;
std
:
:
swap
(
capacity_
other
.
capacity_
)
;
std
:
:
swap
(
data_
other
.
data_
)
;
}
void
reserve
(
size_t
capacity
)
{
if
(
capacity
<
=
capacity_
)
return
;
size_t
new_capacity
=
std
:
:
max
(
capacity
3
*
capacity_
/
2
)
;
new_capacity
=
std
:
:
max
<
size_t
>
(
64
new_capacity
)
;
StatusOr
<
AlignedMemory
>
new_data_or
=
AlignedMemory
:
:
Create
(
memory_manager_
new_capacity
+
8
)
;
if
(
!
new_data_or
.
ok
(
)
)
{
size_
=
capacity_
=
0
;
return
;
}
AlignedMemory
new_data
=
std
:
:
move
(
new_data_or
)
.
value
(
)
;
if
(
data_
.
address
<
void
>
(
)
=
=
nullptr
)
{
new_data
.
address
<
uint8_t
>
(
)
[
0
]
=
0
;
}
else
{
memmove
(
new_data
.
address
<
void
>
(
)
data_
.
address
<
void
>
(
)
size_
)
;
new_data
.
address
<
uint8_t
>
(
)
[
size_
]
=
0
;
}
capacity_
=
new_capacity
;
data_
=
std
:
:
move
(
new_data
)
;
}
void
resize
(
size_t
size
)
{
reserve
(
size
)
;
size_
=
(
data
(
)
=
=
nullptr
)
?
0
:
size
;
}
void
resize
(
size_t
size
uint8_t
value
)
{
size_t
old_size
=
size_
;
resize
(
size
)
;
if
(
size_
>
old_size
)
{
memset
(
data
(
)
+
old_size
value
size_
-
old_size
)
;
}
}
void
push_back
(
uint8_t
x
)
{
if
(
size_
=
=
capacity_
)
{
reserve
(
capacity_
+
1
)
;
if
(
data
(
)
=
=
nullptr
)
return
;
}
data_
.
address
<
uint8_t
>
(
)
[
size_
+
+
]
=
x
;
}
size_t
size
(
)
const
{
return
size_
;
}
size_t
capacity
(
)
const
{
return
capacity_
;
}
uint8_t
*
data
(
)
{
return
data_
.
address
<
uint8_t
>
(
)
;
}
const
uint8_t
*
data
(
)
const
{
return
data_
.
address
<
uint8_t
>
(
)
;
}
void
clear
(
)
{
resize
(
0
)
;
}
bool
empty
(
)
const
{
return
size
(
)
=
=
0
;
}
void
assign
(
std
:
:
initializer_list
<
uint8_t
>
il
)
{
resize
(
il
.
size
(
)
)
;
memcpy
(
data
(
)
il
.
begin
(
)
il
.
size
(
)
)
;
}
uint8_t
*
begin
(
)
{
return
data
(
)
;
}
const
uint8_t
*
begin
(
)
const
{
return
data
(
)
;
}
uint8_t
*
end
(
)
{
return
begin
(
)
+
size
(
)
;
}
const
uint8_t
*
end
(
)
const
{
return
begin
(
)
+
size
(
)
;
}
uint8_t
&
operator
[
]
(
const
size_t
i
)
{
BoundsCheck
(
i
)
;
return
data
(
)
[
i
]
;
}
const
uint8_t
&
operator
[
]
(
const
size_t
i
)
const
{
BoundsCheck
(
i
)
;
return
data
(
)
[
i
]
;
}
uint8_t
&
back
(
)
{
JXL_ASSERT
(
size
(
)
!
=
0
)
;
return
data
(
)
[
size
(
)
-
1
]
;
}
const
uint8_t
&
back
(
)
const
{
JXL_ASSERT
(
size
(
)
!
=
0
)
;
return
data
(
)
[
size
(
)
-
1
]
;
}
template
<
typename
T
>
void
append
(
const
T
&
other
)
{
append
(
reinterpret_cast
<
const
uint8_t
*
>
(
other
.
data
(
)
)
reinterpret_cast
<
const
uint8_t
*
>
(
other
.
data
(
)
)
+
other
.
size
(
)
)
;
}
void
append
(
const
uint8_t
*
begin
const
uint8_t
*
end
)
{
if
(
end
-
begin
>
0
)
{
size_t
old_size
=
size
(
)
;
resize
(
size
(
)
+
(
end
-
begin
)
)
;
memcpy
(
data
(
)
+
old_size
begin
end
-
begin
)
;
}
}
private
:
void
BoundsCheck
(
size_t
i
)
const
{
JXL_ASSERT
(
i
<
=
size
(
)
)
;
}
JxlMemoryManager
*
memory_manager_
;
size_t
size_
;
size_t
capacity_
;
AlignedMemory
data_
;
}
;
template
<
typename
T
>
static
inline
void
Append
(
const
T
&
s
PaddedBytes
*
out
size_t
*
JXL_RESTRICT
byte_pos
)
{
memcpy
(
out
-
>
data
(
)
+
*
byte_pos
s
.
data
(
)
s
.
size
(
)
)
;
*
byte_pos
+
=
s
.
size
(
)
;
JXL_CHECK
(
*
byte_pos
<
=
out
-
>
size
(
)
)
;
}
}
#
endif
