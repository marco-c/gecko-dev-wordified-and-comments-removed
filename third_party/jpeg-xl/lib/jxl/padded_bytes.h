#
ifndef
LIB_JXL_BASE_PADDED_BYTES_H_
#
define
LIB_JXL_BASE_PADDED_BYTES_H_
#
include
<
jxl
/
memory_manager
.
h
>
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
initializer_list
>
#
include
<
utility
>
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
memory_manager_internal
.
h
"
namespace
jxl
{
class
PaddedBytes
{
public
:
explicit
PaddedBytes
(
JxlMemoryManager
*
memory_manager
)
:
memory_manager_
(
memory_manager
)
size_
(
0
)
capacity_
(
0
)
{
}
static
StatusOr
<
PaddedBytes
>
WithInitialSpace
(
JxlMemoryManager
*
memory_manager
size_t
size
)
{
PaddedBytes
result
(
memory_manager
)
;
JXL_RETURN_IF_ERROR
(
result
.
Init
(
size
)
)
;
return
result
;
}
PaddedBytes
(
const
PaddedBytes
&
)
=
delete
;
PaddedBytes
&
operator
=
(
const
PaddedBytes
&
)
=
delete
;
PaddedBytes
(
PaddedBytes
&
&
other
)
noexcept
:
memory_manager_
(
other
.
memory_manager_
)
size_
(
other
.
size_
)
capacity_
(
other
.
capacity_
)
data_
(
std
:
:
move
(
other
.
data_
)
)
{
other
.
size_
=
other
.
capacity_
=
0
;
}
PaddedBytes
&
operator
=
(
PaddedBytes
&
&
other
)
noexcept
{
memory_manager_
=
other
.
memory_manager_
;
size_
=
other
.
size_
;
capacity_
=
other
.
capacity_
;
data_
=
std
:
:
move
(
other
.
data_
)
;
if
(
&
other
!
=
this
)
{
other
.
size_
=
other
.
capacity_
=
0
;
}
return
*
this
;
}
JxlMemoryManager
*
memory_manager
(
)
const
{
return
memory_manager_
;
}
void
swap
(
PaddedBytes
&
other
)
noexcept
{
std
:
:
swap
(
memory_manager_
other
.
memory_manager_
)
;
std
:
:
swap
(
size_
other
.
size_
)
;
std
:
:
swap
(
capacity_
other
.
capacity_
)
;
std
:
:
swap
(
data_
other
.
data_
)
;
}
Status
reserve
(
size_t
capacity
)
{
if
(
capacity
<
=
capacity_
)
return
true
;
size_t
new_capacity
=
std
:
:
max
(
capacity
3
*
capacity_
/
2
)
;
new_capacity
=
std
:
:
max
<
size_t
>
(
64
new_capacity
)
;
JXL_ASSIGN_OR_RETURN
(
AlignedMemory
new_data
AlignedMemory
:
:
Create
(
memory_manager_
new_capacity
+
8
)
)
;
if
(
data_
.
address
<
void
>
(
)
=
=
nullptr
)
{
new_data
.
address
<
uint8_t
>
(
)
[
0
]
=
0
;
}
else
{
memmove
(
new_data
.
address
<
void
>
(
)
data_
.
address
<
void
>
(
)
size_
)
;
new_data
.
address
<
uint8_t
>
(
)
[
size_
]
=
0
;
}
capacity_
=
new_capacity
;
data_
=
std
:
:
move
(
new_data
)
;
return
true
;
}
Status
resize
(
size_t
size
)
{
JXL_RETURN_IF_ERROR
(
reserve
(
size
)
)
;
size_
=
size
;
return
true
;
}
Status
resize
(
size_t
size
uint8_t
value
)
{
size_t
old_size
=
size_
;
JXL_RETURN_IF_ERROR
(
resize
(
size
)
)
;
if
(
size_
>
old_size
)
{
memset
(
data
(
)
+
old_size
value
size_
-
old_size
)
;
}
return
true
;
}
Status
push_back
(
uint8_t
x
)
{
if
(
size_
=
=
capacity_
)
{
JXL_RETURN_IF_ERROR
(
reserve
(
capacity_
+
1
)
)
;
}
data_
.
address
<
uint8_t
>
(
)
[
size_
+
+
]
=
x
;
return
true
;
}
size_t
size
(
)
const
{
return
size_
;
}
size_t
capacity
(
)
const
{
return
capacity_
;
}
uint8_t
*
data
(
)
{
return
data_
.
address
<
uint8_t
>
(
)
;
}
const
uint8_t
*
data
(
)
const
{
return
data_
.
address
<
uint8_t
>
(
)
;
}
void
clear
(
)
{
static_cast
<
void
>
(
resize
(
0
)
)
;
}
bool
empty
(
)
const
{
return
size
(
)
=
=
0
;
}
Status
assign
(
std
:
:
initializer_list
<
uint8_t
>
il
)
{
JXL_RETURN_IF_ERROR
(
resize
(
il
.
size
(
)
)
)
;
memcpy
(
data
(
)
il
.
begin
(
)
il
.
size
(
)
)
;
return
true
;
}
uint8_t
*
begin
(
)
{
return
data
(
)
;
}
const
uint8_t
*
begin
(
)
const
{
return
data
(
)
;
}
uint8_t
*
end
(
)
{
return
begin
(
)
+
size
(
)
;
}
const
uint8_t
*
end
(
)
const
{
return
begin
(
)
+
size
(
)
;
}
uint8_t
&
operator
[
]
(
const
size_t
i
)
{
BoundsCheck
(
i
)
;
return
data
(
)
[
i
]
;
}
const
uint8_t
&
operator
[
]
(
const
size_t
i
)
const
{
BoundsCheck
(
i
)
;
return
data
(
)
[
i
]
;
}
template
<
typename
T
>
Status
append
(
const
T
&
other
)
{
return
append
(
reinterpret_cast
<
const
uint8_t
*
>
(
other
.
data
(
)
)
reinterpret_cast
<
const
uint8_t
*
>
(
other
.
data
(
)
)
+
other
.
size
(
)
)
;
}
Status
append
(
const
uint8_t
*
begin
const
uint8_t
*
end
)
{
if
(
end
-
begin
>
0
)
{
size_t
old_size
=
size
(
)
;
JXL_RETURN_IF_ERROR
(
resize
(
size
(
)
+
(
end
-
begin
)
)
)
;
memcpy
(
data
(
)
+
old_size
begin
end
-
begin
)
;
}
return
true
;
}
private
:
Status
Init
(
size_t
size
)
{
size_
=
size
;
return
reserve
(
size
)
;
}
void
BoundsCheck
(
size_t
i
)
const
{
JXL_DASSERT
(
i
<
=
size
(
)
)
;
}
JxlMemoryManager
*
memory_manager_
;
size_t
size_
;
size_t
capacity_
;
AlignedMemory
data_
;
}
;
}
#
endif
