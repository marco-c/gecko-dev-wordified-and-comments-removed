#
if
defined
(
LIB_JXL_DCT_BLOCK_INL_H_
)
=
=
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
LIB_JXL_DCT_BLOCK_INL_H_
#
undef
LIB_JXL_DCT_BLOCK_INL_H_
#
else
#
define
LIB_JXL_DCT_BLOCK_INL_H_
#
endif
#
include
<
stddef
.
h
>
#
include
<
hwy
/
highway
.
h
>
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
jxl
{
namespace
HWY_NAMESPACE
{
namespace
{
using
hwy
:
:
HWY_NAMESPACE
:
:
Vec
;
template
<
size_t
N
>
using
BlockDesc
=
HWY_CAPPED
(
float
N
)
;
class
DCTFrom
{
public
:
DCTFrom
(
const
float
*
data
size_t
stride
)
:
stride_
(
stride
)
data_
(
data
)
{
}
template
<
typename
D
>
HWY_INLINE
Vec
<
D
>
LoadPart
(
D
const
size_t
row
size_t
i
)
const
{
JXL_DASSERT
(
Lanes
(
D
(
)
)
<
=
stride_
)
;
return
LoadU
(
D
(
)
Address
(
row
i
)
)
;
}
HWY_INLINE
float
Read
(
const
size_t
row
const
size_t
i
)
const
{
return
*
Address
(
row
i
)
;
}
constexpr
HWY_INLINE
const
float
*
Address
(
const
size_t
row
const
size_t
i
)
const
{
return
data_
+
row
*
stride_
+
i
;
}
size_t
Stride
(
)
const
{
return
stride_
;
}
private
:
size_t
stride_
;
const
float
*
JXL_RESTRICT
data_
;
}
;
class
DCTTo
{
public
:
DCTTo
(
float
*
data
size_t
stride
)
:
stride_
(
stride
)
data_
(
data
)
{
}
template
<
typename
D
>
HWY_INLINE
void
StorePart
(
D
const
Vec
<
D
>
&
v
const
size_t
row
size_t
i
)
const
{
JXL_DASSERT
(
Lanes
(
D
(
)
)
<
=
stride_
)
;
StoreU
(
v
D
(
)
Address
(
row
i
)
)
;
}
HWY_INLINE
void
Write
(
float
v
const
size_t
row
const
size_t
i
)
const
{
*
Address
(
row
i
)
=
v
;
}
constexpr
HWY_INLINE
float
*
Address
(
const
size_t
row
const
size_t
i
)
const
{
return
data_
+
row
*
stride_
+
i
;
}
size_t
Stride
(
)
const
{
return
stride_
;
}
private
:
size_t
stride_
;
float
*
JXL_RESTRICT
data_
;
}
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
