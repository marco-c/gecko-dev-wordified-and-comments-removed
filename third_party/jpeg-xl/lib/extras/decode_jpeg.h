#
ifndef
LIB_EXTRAS_DECODE_JPEG_H_
#
define
LIB_EXTRAS_DECODE_JPEG_H_
#
include
<
stdint
.
h
>
#
include
<
array
>
#
include
<
vector
>
#
include
"
hwy
/
aligned_allocator
.
h
"
#
include
"
lib
/
extras
/
packed_image
.
h
"
#
include
"
lib
/
jxl
/
base
/
data_parallel
.
h
"
#
include
"
lib
/
jxl
/
base
/
status
.
h
"
#
include
"
lib
/
jxl
/
image
.
h
"
namespace
jxl
{
namespace
extras
{
constexpr
int
kMaxComponents
=
4
;
typedef
int16_t
coeff_t
;
struct
JPEGComponent
{
JPEGComponent
(
)
:
id
(
0
)
h_samp_factor
(
1
)
v_samp_factor
(
1
)
quant_idx
(
0
)
width_in_blocks
(
0
)
height_in_blocks
(
0
)
{
}
uint32_t
id
;
int
h_samp_factor
;
int
v_samp_factor
;
uint32_t
quant_idx
;
uint32_t
width_in_blocks
;
uint32_t
height_in_blocks
;
hwy
:
:
AlignedFreeUniquePtr
<
coeff_t
[
]
>
coeffs
;
}
;
struct
HuffmanTableEntry
{
HuffmanTableEntry
(
)
:
bits
(
0
)
value
(
0xffff
)
{
}
uint8_t
bits
;
uint16_t
value
;
}
;
struct
JPEGQuantTable
{
std
:
:
array
<
int32_t
kDCTBlockSize
>
values
;
uint32_t
index
=
0
;
}
;
struct
JPEGComponentScanInfo
{
uint32_t
comp_idx
;
uint32_t
dc_tbl_idx
;
uint32_t
ac_tbl_idx
;
uint32_t
mcu_ysize_blocks
;
uint32_t
mcu_xsize_blocks
;
}
;
struct
JPEGScanInfo
{
uint32_t
Ss
;
uint32_t
Se
;
uint32_t
Ah
;
uint32_t
Al
;
uint32_t
num_components
=
0
;
std
:
:
array
<
JPEGComponentScanInfo
kMaxComponents
>
components
;
size_t
MCU_rows
;
size_t
MCU_cols
;
}
;
struct
MCUCodingState
{
coeff_t
last_dc_coeff
[
kMaxComponents
]
;
int
eobrun
;
std
:
:
vector
<
coeff_t
>
coeffs
;
}
;
class
JpegDecoder
{
public
:
enum
class
Status
{
kSuccess
kNeedMoreInput
kError
}
;
Status
SetInput
(
const
uint8_t
*
data
size_t
len
)
;
Status
SetOutput
(
PackedImage
*
image
)
;
Status
ReadHeaders
(
)
;
Status
ReadScanLines
(
size_t
*
num_output_rows
size_t
max_output_rows
)
;
size_t
xsize
(
)
const
{
return
xsize_
;
}
size_t
ysize
(
)
const
{
return
ysize_
;
}
size_t
num_channels
(
)
const
{
return
components_
.
size
(
)
;
}
const
std
:
:
vector
<
uint8_t
>
&
icc_profile
(
)
const
{
return
icc_profile_
;
}
private
:
enum
class
State
{
kStart
kProcessMarkers
kScan
kRender
kEnd
}
;
State
state_
=
State
:
:
kStart
;
const
uint8_t
*
next_in_
=
nullptr
;
size_t
avail_in_
=
0
;
std
:
:
vector
<
uint8_t
>
codestream_copy_
;
size_t
codestream_unconsumed_
=
0
;
size_t
codestream_pos_
=
0
;
size_t
codestream_bits_ahead_
=
0
;
bool
found_soi_
=
false
;
bool
found_app0_
=
false
;
bool
found_dri_
=
false
;
bool
found_sof_
=
false
;
bool
found_eoi_
=
false
;
size_t
xsize_
=
0
;
size_t
ysize_
=
0
;
bool
is_ycbcr_
=
true
;
size_t
icc_index_
=
0
;
size_t
icc_total_
=
0
;
std
:
:
vector
<
uint8_t
>
icc_profile_
;
size_t
restart_interval_
=
0
;
std
:
:
vector
<
JPEGQuantTable
>
quant_
;
std
:
:
vector
<
JPEGComponent
>
components_
;
std
:
:
vector
<
HuffmanTableEntry
>
dc_huff_lut_
;
std
:
:
vector
<
HuffmanTableEntry
>
ac_huff_lut_
;
uint8_t
huff_slot_defined_
[
256
]
=
{
}
;
bool
is_progressive_
;
int
max_h_samp_
;
int
max_v_samp_
;
size_t
iMCU_rows_
;
size_t
iMCU_cols_
;
size_t
iMCU_width_
;
size_t
iMCU_height_
;
uint16_t
scan_progression_
[
kMaxComponents
]
[
kDCTBlockSize
]
;
JPEGScanInfo
scan_info_
;
size_t
scan_mcu_row_
;
size_t
scan_mcu_col_
;
coeff_t
last_dc_coeff_
[
kMaxComponents
]
;
int
eobrun_
;
int
restarts_to_go_
;
int
next_restart_marker_
;
MCUCodingState
mcu_
;
PackedImage
*
output_
;
Image3F
MCU_row_buf_
;
size_t
MCU_buf_current_row_
;
size_t
MCU_buf_ready_rows_
;
size_t
output_row_
;
size_t
output_mcu_row_
;
size_t
output_ci_
;
std
:
:
vector
<
ImageF
>
chroma_
;
std
:
:
vector
<
size_t
>
component_order_
;
hwy
:
:
AlignedFreeUniquePtr
<
float
[
]
>
idct_scratch_
;
hwy
:
:
AlignedFreeUniquePtr
<
float
[
]
>
upsample_scratch_
;
hwy
:
:
AlignedFreeUniquePtr
<
uint8_t
[
]
>
output_scratch_
;
hwy
:
:
AlignedFreeUniquePtr
<
float
[
]
>
dequant_
;
hwy
:
:
AlignedFreeUniquePtr
<
int
[
]
>
nonzeros_
;
hwy
:
:
AlignedFreeUniquePtr
<
int
[
]
>
sumabs_
;
std
:
:
vector
<
size_t
>
num_processed_blocks_
;
hwy
:
:
AlignedFreeUniquePtr
<
float
[
]
>
biases_
;
void
AdvanceInput
(
size_t
size
)
;
void
AdvanceCodestream
(
size_t
size
)
;
Status
RequestMoreInput
(
)
;
Status
GetCodestreamInput
(
const
uint8_t
*
*
data
size_t
*
len
)
;
Status
ProcessMarker
(
const
uint8_t
*
data
size_t
len
size_t
*
pos
)
;
Status
ProcessSOF
(
const
uint8_t
*
data
size_t
len
)
;
Status
ProcessSOS
(
const
uint8_t
*
data
size_t
len
)
;
Status
ProcessDHT
(
const
uint8_t
*
data
size_t
len
)
;
Status
ProcessDQT
(
const
uint8_t
*
data
size_t
len
)
;
Status
ProcessDRI
(
const
uint8_t
*
data
size_t
len
)
;
Status
ProcessAPP
(
const
uint8_t
*
data
size_t
len
)
;
Status
ProcessCOM
(
const
uint8_t
*
data
size_t
len
)
;
Status
ProcessScan
(
const
uint8_t
*
data
size_t
len
size_t
*
pos
)
;
void
SaveMCUCodingState
(
)
;
void
RestoreMCUCodingState
(
)
;
void
PrepareForOutput
(
)
;
void
ProcessOutput
(
size_t
*
num_output_rows
size_t
max_output_rows
)
;
}
;
Status
DecodeJpeg
(
const
std
:
:
vector
<
uint8_t
>
&
compressed
JxlDataType
output_data_type
ThreadPool
*
pool
PackedPixelFile
*
ppf
)
;
}
}
#
endif
