#
ifndef
CONTENT_ANALYSIS_DEMO_HANDLER_MISBEHAVING_H_
#
define
CONTENT_ANALYSIS_DEMO_HANDLER_MISBEHAVING_H_
#
include
<
time
.
h
>
#
include
<
algorithm
>
#
include
<
chrono
>
#
include
<
fstream
>
#
include
<
map
>
#
include
<
iostream
>
#
include
<
utility
>
#
include
<
vector
>
#
include
<
regex
>
#
include
<
windows
.
h
>
#
include
"
content_analysis
/
sdk
/
analysis
.
pb
.
h
"
#
include
"
content_analysis
/
sdk
/
analysis_agent
.
h
"
#
include
"
agent
/
src
/
event_win
.
h
"
enum
class
Mode
{
#
define
AGENT_MODE
(
name
)
Mode_
#
#
name
#
include
"
modes
.
h
"
#
undef
AGENT_MODE
}
;
extern
std
:
:
map
<
std
:
:
string
Mode
>
sStringToMode
;
extern
std
:
:
map
<
Mode
std
:
:
string
>
sModeToString
;
static
DWORD
WriteBigMessageToPipe
(
HANDLE
pipe
const
std
:
:
string
&
message
)
{
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
top
message
size
is
"
<
<
message
.
size
(
)
<
<
std
:
:
endl
;
if
(
message
.
empty
(
)
)
{
return
ERROR_SUCCESS
;
}
OVERLAPPED
overlapped
;
memset
(
&
overlapped
0
sizeof
(
overlapped
)
)
;
overlapped
.
hEvent
=
CreateEvent
(
nullptr
TRUE
FALSE
nullptr
)
;
if
(
overlapped
.
hEvent
=
=
nullptr
)
{
return
GetLastError
(
)
;
}
DWORD
err
=
ERROR_SUCCESS
;
const
char
*
cursor
=
message
.
data
(
)
;
for
(
DWORD
size
=
message
.
length
(
)
;
size
>
0
;
)
{
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
top
of
loop
remaining
size
"
<
<
size
<
<
std
:
:
endl
;
if
(
WriteFile
(
pipe
cursor
size
nullptr
&
overlapped
)
)
{
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
:
success
"
<
<
std
:
:
endl
;
err
=
ERROR_SUCCESS
;
break
;
}
err
=
GetLastError
(
)
;
if
(
err
!
=
ERROR_IO_PENDING
)
{
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
:
returning
error
from
WriteFile
"
<
<
err
<
<
std
:
:
endl
;
break
;
}
DWORD
written
;
if
(
!
GetOverlappedResult
(
pipe
&
overlapped
&
written
TRUE
)
)
{
err
=
GetLastError
(
)
;
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
:
returning
error
from
"
"
GetOverlappedREsult
"
<
<
err
<
<
std
:
:
endl
;
break
;
}
err
=
ERROR_SUCCESS
;
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
:
bottom
of
loop
wrote
"
<
<
written
<
<
std
:
:
endl
;
cursor
+
=
written
;
size
-
=
written
;
}
CloseHandle
(
overlapped
.
hEvent
)
;
return
err
;
}
class
MisbehavingHandler
final
:
public
content_analysis
:
:
sdk
:
:
AgentEventHandler
{
public
:
using
Event
=
content_analysis
:
:
sdk
:
:
ContentAnalysisEvent
;
static
std
:
:
unique_ptr
<
AgentEventHandler
>
Create
(
unsigned
long
delay
const
std
:
:
string
&
modeStr
)
{
auto
it
=
sStringToMode
.
find
(
modeStr
)
;
if
(
it
=
=
sStringToMode
.
end
(
)
)
{
std
:
:
cout
<
<
"
\
"
"
<
<
modeStr
<
<
"
\
"
"
<
<
"
is
not
a
valid
mode
!
"
<
<
std
:
:
endl
;
return
nullptr
;
}
return
std
:
:
unique_ptr
<
AgentEventHandler
>
(
new
MisbehavingHandler
(
delay
it
-
>
second
)
)
;
}
private
:
MisbehavingHandler
(
unsigned
long
delay
Mode
mode
)
:
delay_
(
delay
)
mode_
(
mode
)
{
}
template
<
size_t
N
>
DWORD
SendBytesOverPipe
(
const
unsigned
char
(
&
bytes
)
[
N
]
const
std
:
:
unique_ptr
<
Event
>
&
event
)
{
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
eventWin
=
static_cast
<
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
>
(
event
.
get
(
)
)
;
HANDLE
pipe
=
eventWin
-
>
Pipe
(
)
;
std
:
:
string
s
(
reinterpret_cast
<
const
char
*
>
(
bytes
)
N
)
;
return
WriteBigMessageToPipe
(
pipe
s
)
;
}
void
AnalyzeContent
(
std
:
:
unique_ptr
<
Event
>
event
)
{
std
:
:
cout
<
<
std
:
:
endl
<
<
"
-
-
-
-
-
-
-
-
-
-
"
<
<
std
:
:
endl
<
<
std
:
:
endl
;
DumpRequest
(
event
-
>
GetRequest
(
)
)
;
std
:
:
cout
<
<
"
Mode
is
"
<
<
sModeToString
[
mode_
]
<
<
std
:
:
endl
;
if
(
mode_
=
=
Mode
:
:
Mode_largeResponse
)
{
for
(
size_t
i
=
0
;
i
<
1000
;
+
+
i
)
{
content_analysis
:
:
sdk
:
:
ContentAnalysisResponse_Result
*
result
=
event
-
>
GetResponse
(
)
.
add_results
(
)
;
result
-
>
set_tag
(
"
someTag
"
)
;
content_analysis
:
:
sdk
:
:
ContentAnalysisResponse_Result_TriggeredRule
*
triggeredRule
=
result
-
>
add_triggered_rules
(
)
;
triggeredRule
-
>
set_rule_id
(
"
some_id
"
)
;
triggeredRule
-
>
set_rule_name
(
"
some_name
"
)
;
}
}
else
if
(
mode_
=
=
Mode
:
:
Mode_invalidUtf8StringStartByteIsContinuationByte
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
x80
\
x41
\
x41
\
x41
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_invalidUtf8StringEndsInMiddleOfMultibyteSequence
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
x41
\
xf0
\
x90
\
x8d
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_invalidUtf8StringOverlongEncoding
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
xf0
\
x82
\
x82
\
xac
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_invalidUtf8StringMultibyteSequenceTooShort
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
xf0
\
x90
\
x8d
\
x41
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_invalidUtf8StringDecodesToInvalidCodePoint
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
xf7
\
xbf
\
xbf
\
xbf
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_stringWithEmbeddedNull
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
x41
\
x00
\
x41
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_zeroResults
)
{
event
-
>
GetResponse
(
)
.
clear_results
(
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_resultWithInvalidStatus
)
{
}
else
{
bool
block
=
false
;
if
(
event
-
>
GetRequest
(
)
.
has_text_content
(
)
)
{
block
=
ShouldBlockRequest
(
event
-
>
GetRequest
(
)
.
text_content
(
)
)
;
}
else
if
(
event
-
>
GetRequest
(
)
.
has_file_path
(
)
)
{
block
=
ShouldBlockRequest
(
event
-
>
GetRequest
(
)
.
file_path
(
)
)
;
}
if
(
block
)
{
auto
rc
=
content_analysis
:
:
sdk
:
:
SetEventVerdictToBlock
(
event
.
get
(
)
)
;
std
:
:
cout
<
<
"
Verdict
:
block
"
;
if
(
rc
!
=
content_analysis
:
:
sdk
:
:
ResultCode
:
:
OK
)
{
std
:
:
cout
<
<
"
error
:
"
<
<
content_analysis
:
:
sdk
:
:
ResultCodeToString
(
rc
)
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
"
<
<
event
-
>
DebugString
(
)
<
<
std
:
:
endl
;
}
std
:
:
cout
<
<
std
:
:
endl
;
}
else
{
std
:
:
cout
<
<
"
Verdict
:
allow
"
<
<
std
:
:
endl
;
}
}
std
:
:
cout
<
<
std
:
:
endl
;
if
(
delay_
>
0
)
{
std
:
:
cout
<
<
"
[
Demo
]
delaying
request
processing
for
"
<
<
delay_
<
<
"
s
"
<
<
std
:
:
endl
;
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
seconds
(
delay_
)
)
;
}
if
(
mode_
=
=
Mode
:
:
Mode_largeResponse
)
{
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
eventWin
=
static_cast
<
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
>
(
event
.
get
(
)
)
;
HANDLE
pipe
=
eventWin
-
>
Pipe
(
)
;
std
:
:
cout
<
<
"
largeResponse
about
to
write
"
<
<
std
:
:
endl
;
DWORD
result
=
WriteBigMessageToPipe
(
pipe
eventWin
-
>
SerializeStringToSendToBrowser
(
)
)
;
std
:
:
cout
<
<
"
largeResponse
done
writing
with
error
"
<
<
result
<
<
std
:
:
endl
;
eventWin
-
>
SetResponseSent
(
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_resultWithInvalidStatus
)
{
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
eventWin
=
static_cast
<
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
>
(
event
.
get
(
)
)
;
HANDLE
pipe
=
eventWin
-
>
Pipe
(
)
;
std
:
:
string
serializedString
=
eventWin
-
>
SerializeStringToSendToBrowser
(
)
;
serializedString
[
serializedString
.
length
(
)
-
1
]
=
100
;
WriteBigMessageToPipe
(
pipe
serializedString
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageTruncatedInMiddleOfString
)
{
unsigned
char
bytes
[
5
]
;
bytes
[
0
]
=
10
;
bytes
[
1
]
=
13
;
bytes
[
2
]
=
65
;
bytes
[
3
]
=
66
;
bytes
[
4
]
=
67
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithInvalidWireType
)
{
unsigned
char
bytes
[
5
]
;
bytes
[
0
]
=
15
;
bytes
[
1
]
=
3
;
bytes
[
2
]
=
65
;
bytes
[
3
]
=
66
;
bytes
[
4
]
=
67
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithUnusedFieldNumber
)
{
unsigned
char
bytes
[
5
]
;
bytes
[
0
]
=
82
;
bytes
[
1
]
=
3
;
bytes
[
2
]
=
65
;
bytes
[
3
]
=
66
;
bytes
[
4
]
=
67
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithWrongStringWireType
)
{
unsigned
char
bytes
[
2
]
;
bytes
[
0
]
=
10
;
bytes
[
1
]
=
42
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithZeroTag
)
{
unsigned
char
bytes
[
1
]
;
bytes
[
0
]
=
0
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithZeroFieldButNonzeroWireType
)
{
unsigned
char
bytes
[
5
]
;
bytes
[
0
]
=
2
;
bytes
[
1
]
=
3
;
bytes
[
2
]
=
65
;
bytes
[
3
]
=
66
;
bytes
[
4
]
=
67
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithGroupEnd
)
{
unsigned
char
bytes
[
1
]
;
bytes
[
0
]
=
12
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageTruncatedInMiddleOfVarint
)
{
unsigned
char
bytes
[
2
]
;
bytes
[
0
]
=
16
;
bytes
[
1
]
=
128
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageTruncatedInMiddleOfTag
)
{
unsigned
char
bytes
[
1
]
;
bytes
[
0
]
=
128
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
{
std
:
:
cout
<
<
"
(
misbehaving
)
Handler
:
:
AnalyzeContent
(
)
about
to
call
"
"
event
-
>
Send
(
)
mode
is
"
<
<
sModeToString
[
mode_
]
<
<
std
:
:
endl
;
auto
rc
=
event
-
>
Send
(
)
;
if
(
rc
!
=
content_analysis
:
:
sdk
:
:
ResultCode
:
:
OK
)
{
std
:
:
cout
<
<
"
[
Demo
]
Error
sending
response
:
"
<
<
content_analysis
:
:
sdk
:
:
ResultCodeToString
(
rc
)
<
<
std
:
:
endl
;
std
:
:
cout
<
<
event
-
>
DebugString
(
)
<
<
std
:
:
endl
;
}
}
}
private
:
void
OnBrowserConnected
(
const
content_analysis
:
:
sdk
:
:
BrowserInfo
&
info
)
override
{
std
:
:
cout
<
<
std
:
:
endl
<
<
"
=
=
=
=
=
=
=
=
=
=
"
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
Browser
connected
pid
=
"
<
<
info
.
pid
<
<
std
:
:
endl
;
}
void
OnBrowserDisconnected
(
const
content_analysis
:
:
sdk
:
:
BrowserInfo
&
info
)
override
{
std
:
:
cout
<
<
std
:
:
endl
<
<
"
Browser
disconnected
pid
=
"
<
<
info
.
pid
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
=
=
=
=
=
=
=
=
=
=
"
<
<
std
:
:
endl
;
}
void
OnAnalysisRequested
(
std
:
:
unique_ptr
<
Event
>
event
)
override
{
AnalyzeContent
(
std
:
:
move
(
event
)
)
;
}
void
OnResponseAcknowledged
(
const
content_analysis
:
:
sdk
:
:
ContentAnalysisAcknowledgement
&
ack
)
override
{
const
char
*
final_action
=
"
<
Unknown
>
"
;
if
(
ack
.
has_final_action
(
)
)
{
switch
(
ack
.
final_action
(
)
)
{
case
content_analysis
:
:
sdk
:
:
ContentAnalysisAcknowledgement
:
:
ACTION_UNSPECIFIED
:
final_action
=
"
<
Unspecified
>
"
;
break
;
case
content_analysis
:
:
sdk
:
:
ContentAnalysisAcknowledgement
:
:
ALLOW
:
final_action
=
"
Allow
"
;
break
;
case
content_analysis
:
:
sdk
:
:
ContentAnalysisAcknowledgement
:
:
REPORT_ONLY
:
final_action
=
"
Report
only
"
;
break
;
case
content_analysis
:
:
sdk
:
:
ContentAnalysisAcknowledgement
:
:
WARN
:
final_action
=
"
Warn
"
;
break
;
case
content_analysis
:
:
sdk
:
:
ContentAnalysisAcknowledgement
:
:
BLOCK
:
final_action
=
"
Block
"
;
break
;
}
}
std
:
:
cout
<
<
"
Ack
:
"
<
<
ack
.
request_token
(
)
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
Final
action
:
"
<
<
final_action
<
<
std
:
:
endl
;
}
void
OnCancelRequests
(
const
content_analysis
:
:
sdk
:
:
ContentAnalysisCancelRequests
&
cancel
)
override
{
std
:
:
cout
<
<
"
Cancel
:
"
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
User
action
ID
:
"
<
<
cancel
.
user_action_id
(
)
<
<
std
:
:
endl
;
}
void
OnInternalError
(
const
char
*
context
content_analysis
:
:
sdk
:
:
ResultCode
error
)
override
{
std
:
:
cout
<
<
std
:
:
endl
<
<
"
*
ERROR
*
:
context
=
\
"
"
<
<
context
<
<
"
\
"
"
<
<
content_analysis
:
:
sdk
:
:
ResultCodeToString
(
error
)
<
<
std
:
:
endl
;
}
void
DumpRequest
(
const
content_analysis
:
:
sdk
:
:
ContentAnalysisRequest
&
request
)
{
std
:
:
string
connector
=
"
<
Unknown
>
"
;
if
(
request
.
has_analysis_connector
(
)
)
{
switch
(
request
.
analysis_connector
(
)
)
{
case
content_analysis
:
:
sdk
:
:
FILE_DOWNLOADED
:
connector
=
"
download
"
;
break
;
case
content_analysis
:
:
sdk
:
:
FILE_ATTACHED
:
connector
=
"
attach
"
;
break
;
case
content_analysis
:
:
sdk
:
:
BULK_DATA_ENTRY
:
connector
=
"
bulk
-
data
-
entry
"
;
break
;
case
content_analysis
:
:
sdk
:
:
PRINT
:
connector
=
"
print
"
;
break
;
case
content_analysis
:
:
sdk
:
:
FILE_TRANSFER
:
connector
=
"
file
-
transfer
"
;
break
;
default
:
break
;
}
}
std
:
:
string
url
=
request
.
has_request_data
(
)
&
&
request
.
request_data
(
)
.
has_url
(
)
?
request
.
request_data
(
)
.
url
(
)
:
"
<
No
URL
>
"
;
std
:
:
string
tab_title
=
request
.
has_request_data
(
)
&
&
request
.
request_data
(
)
.
has_tab_title
(
)
?
request
.
request_data
(
)
.
tab_title
(
)
:
"
<
No
tab
title
>
"
;
std
:
:
string
filename
=
request
.
has_request_data
(
)
&
&
request
.
request_data
(
)
.
has_filename
(
)
?
request
.
request_data
(
)
.
filename
(
)
:
"
<
No
filename
>
"
;
std
:
:
string
digest
=
request
.
has_request_data
(
)
&
&
request
.
request_data
(
)
.
has_digest
(
)
?
request
.
request_data
(
)
.
digest
(
)
:
"
<
No
digest
>
"
;
std
:
:
string
file_path
=
request
.
has_file_path
(
)
?
request
.
file_path
(
)
:
"
<
none
>
"
;
std
:
:
string
text_content
=
request
.
has_text_content
(
)
?
request
.
text_content
(
)
:
"
<
none
>
"
;
std
:
:
string
machine_user
=
request
.
has_client_metadata
(
)
&
&
request
.
client_metadata
(
)
.
has_browser
(
)
&
&
request
.
client_metadata
(
)
.
browser
(
)
.
has_machine_user
(
)
?
request
.
client_metadata
(
)
.
browser
(
)
.
machine_user
(
)
:
"
<
No
machine
user
>
"
;
std
:
:
string
email
=
request
.
has_request_data
(
)
&
&
request
.
request_data
(
)
.
has_email
(
)
?
request
.
request_data
(
)
.
email
(
)
:
"
<
No
email
>
"
;
time_t
t
=
request
.
expires_at
(
)
;
std
:
:
string
user_action_id
=
request
.
has_user_action_id
(
)
?
request
.
user_action_id
(
)
:
"
<
No
user
action
id
>
"
;
std
:
:
cout
<
<
"
Request
:
"
<
<
request
.
request_token
(
)
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
User
action
ID
:
"
<
<
user_action_id
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
Expires
at
:
"
<
<
ctime
(
&
t
)
;
std
:
:
cout
<
<
"
Connector
:
"
<
<
connector
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
URL
:
"
<
<
url
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
Tab
title
:
"
<
<
tab_title
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
Filename
:
"
<
<
filename
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
Digest
:
"
<
<
digest
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
Filepath
:
"
<
<
file_path
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
Text
content
:
'
"
<
<
text_content
<
<
"
'
"
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
Machine
user
:
"
<
<
machine_user
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
Email
:
"
<
<
email
<
<
std
:
:
endl
;
}
bool
ReadContentFromFile
(
const
std
:
:
string
&
file_path
std
:
:
string
*
content
)
{
std
:
:
ifstream
file
(
file_path
std
:
:
ios
:
:
in
|
std
:
:
ios
:
:
binary
|
std
:
:
ios
:
:
ate
)
;
if
(
!
file
.
is_open
(
)
)
return
false
;
int
size
=
file
.
tellg
(
)
;
if
(
size
>
1024
*
1024
)
return
false
;
content
-
>
resize
(
size
+
1
)
;
file
.
seekg
(
0
std
:
:
ios
:
:
beg
)
;
file
.
read
(
&
(
*
content
)
[
0
]
size
)
;
content
-
>
at
(
size
)
=
0
;
return
true
;
}
bool
ShouldBlockRequest
(
const
std
:
:
string
&
content
)
{
std
:
:
cout
<
<
"
'
"
<
<
content
<
<
"
'
was
not
blocked
\
n
"
;
return
false
;
}
unsigned
long
delay_
;
Mode
mode_
;
}
;
#
endif
