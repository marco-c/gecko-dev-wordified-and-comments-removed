#
ifndef
CONTENT_ANALYSIS_DEMO_HANDLER_MISBEHAVING_H_
#
define
CONTENT_ANALYSIS_DEMO_HANDLER_MISBEHAVING_H_
#
include
<
time
.
h
>
#
include
<
algorithm
>
#
include
<
chrono
>
#
include
<
fstream
>
#
include
<
map
>
#
include
<
iostream
>
#
include
<
utility
>
#
include
<
vector
>
#
include
<
regex
>
#
include
<
windows
.
h
>
#
include
"
content_analysis
/
sdk
/
analysis
.
pb
.
h
"
#
include
"
content_analysis
/
sdk
/
analysis_agent
.
h
"
#
include
"
agent
/
src
/
event_win
.
h
"
#
include
"
handler
.
h
"
enum
class
Mode
{
#
define
AGENT_MODE
(
name
)
Mode_
#
#
name
#
include
"
modes
.
h
"
#
undef
AGENT_MODE
}
;
extern
std
:
:
map
<
std
:
:
string
Mode
>
sStringToMode
;
extern
std
:
:
map
<
Mode
std
:
:
string
>
sModeToString
;
static
DWORD
WriteBigMessageToPipe
(
HANDLE
pipe
const
std
:
:
string
&
message
)
{
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
top
message
size
is
"
<
<
message
.
size
(
)
<
<
std
:
:
endl
;
if
(
message
.
empty
(
)
)
{
return
ERROR_SUCCESS
;
}
OVERLAPPED
overlapped
;
memset
(
&
overlapped
0
sizeof
(
overlapped
)
)
;
overlapped
.
hEvent
=
CreateEvent
(
nullptr
TRUE
FALSE
nullptr
)
;
if
(
overlapped
.
hEvent
=
=
nullptr
)
{
return
GetLastError
(
)
;
}
DWORD
err
=
ERROR_SUCCESS
;
const
char
*
cursor
=
message
.
data
(
)
;
for
(
DWORD
size
=
message
.
length
(
)
;
size
>
0
;
)
{
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
top
of
loop
remaining
size
"
<
<
size
<
<
std
:
:
endl
;
if
(
WriteFile
(
pipe
cursor
size
nullptr
&
overlapped
)
)
{
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
:
success
"
<
<
std
:
:
endl
;
err
=
ERROR_SUCCESS
;
break
;
}
err
=
GetLastError
(
)
;
if
(
err
!
=
ERROR_IO_PENDING
)
{
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
:
returning
error
from
WriteFile
"
<
<
err
<
<
std
:
:
endl
;
break
;
}
DWORD
written
;
if
(
!
GetOverlappedResult
(
pipe
&
overlapped
&
written
TRUE
)
)
{
err
=
GetLastError
(
)
;
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
:
returning
error
from
"
"
GetOverlappedREsult
"
<
<
err
<
<
std
:
:
endl
;
break
;
}
err
=
ERROR_SUCCESS
;
std
:
:
cout
<
<
"
[
demo
]
WriteBigMessageToPipe
:
bottom
of
loop
wrote
"
<
<
written
<
<
std
:
:
endl
;
cursor
+
=
written
;
size
-
=
written
;
}
CloseHandle
(
overlapped
.
hEvent
)
;
return
err
;
}
class
MisbehavingHandler
final
:
public
Handler
{
public
:
using
Event
=
content_analysis
:
:
sdk
:
:
ContentAnalysisEvent
;
static
std
:
:
unique_ptr
<
AgentEventHandler
>
Create
(
const
std
:
:
string
&
modeStr
std
:
:
vector
<
unsigned
long
>
&
&
delays
const
std
:
:
string
&
print_data_file_path
RegexArray
&
&
toBlock
=
RegexArray
(
)
RegexArray
&
&
toWarn
=
RegexArray
(
)
RegexArray
&
&
toReport
=
RegexArray
(
)
)
{
auto
it
=
sStringToMode
.
find
(
modeStr
)
;
if
(
it
=
=
sStringToMode
.
end
(
)
)
{
std
:
:
cout
<
<
"
\
"
"
<
<
modeStr
<
<
"
\
"
"
<
<
"
is
not
a
valid
mode
!
"
<
<
std
:
:
endl
;
return
nullptr
;
}
return
std
:
:
unique_ptr
<
AgentEventHandler
>
(
new
MisbehavingHandler
(
it
-
>
second
std
:
:
move
(
delays
)
print_data_file_path
std
:
:
move
(
toBlock
)
std
:
:
move
(
toWarn
)
std
:
:
move
(
toReport
)
)
)
;
}
private
:
MisbehavingHandler
(
Mode
mode
std
:
:
vector
<
unsigned
long
>
&
&
delays
const
std
:
:
string
&
print_data_file_path
RegexArray
&
&
toBlock
=
RegexArray
(
)
RegexArray
&
&
toWarn
=
RegexArray
(
)
RegexArray
&
&
toReport
=
RegexArray
(
)
)
:
Handler
(
std
:
:
move
(
delays
)
print_data_file_path
std
:
:
move
(
toBlock
)
std
:
:
move
(
toWarn
)
std
:
:
move
(
toReport
)
)
mode_
(
mode
)
{
}
template
<
size_t
N
>
DWORD
SendBytesOverPipe
(
const
unsigned
char
(
&
bytes
)
[
N
]
const
std
:
:
unique_ptr
<
Event
>
&
event
)
{
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
eventWin
=
static_cast
<
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
>
(
event
.
get
(
)
)
;
HANDLE
pipe
=
eventWin
-
>
Pipe
(
)
;
std
:
:
string
s
(
reinterpret_cast
<
const
char
*
>
(
bytes
)
N
)
;
return
WriteBigMessageToPipe
(
pipe
s
)
;
}
bool
SetCustomResponse
(
AtomicCout
&
aout
std
:
:
unique_ptr
<
Event
>
&
event
)
override
{
std
:
:
cout
<
<
std
:
:
endl
<
<
"
-
-
-
-
-
-
-
-
-
-
"
<
<
std
:
:
endl
<
<
std
:
:
endl
;
std
:
:
cout
<
<
"
Mode
is
"
<
<
sModeToString
[
mode_
]
<
<
std
:
:
endl
;
bool
handled
=
true
;
if
(
mode_
=
=
Mode
:
:
Mode_largeResponse
)
{
for
(
size_t
i
=
0
;
i
<
1000
;
+
+
i
)
{
content_analysis
:
:
sdk
:
:
ContentAnalysisResponse_Result
*
result
=
event
-
>
GetResponse
(
)
.
add_results
(
)
;
result
-
>
set_tag
(
"
someTag
"
)
;
content_analysis
:
:
sdk
:
:
ContentAnalysisResponse_Result_TriggeredRule
*
triggeredRule
=
result
-
>
add_triggered_rules
(
)
;
triggeredRule
-
>
set_rule_id
(
"
some_id
"
)
;
triggeredRule
-
>
set_rule_name
(
"
some_name
"
)
;
}
}
else
if
(
mode_
=
=
Mode
:
:
Mode_invalidUtf8StringStartByteIsContinuationByte
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
x80
\
x41
\
x41
\
x41
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_invalidUtf8StringEndsInMiddleOfMultibyteSequence
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
x41
\
xf0
\
x90
\
x8d
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_invalidUtf8StringOverlongEncoding
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
xf0
\
x82
\
x82
\
xac
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_invalidUtf8StringMultibyteSequenceTooShort
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
xf0
\
x90
\
x8d
\
x41
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_invalidUtf8StringDecodesToInvalidCodePoint
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
xf7
\
xbf
\
xbf
\
xbf
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_stringWithEmbeddedNull
)
{
event
-
>
GetResponse
(
)
.
set_request_token
(
"
\
x41
\
x00
\
x41
"
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_zeroResults
)
{
event
-
>
GetResponse
(
)
.
clear_results
(
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_resultWithInvalidStatus
)
{
}
else
{
handled
=
false
;
}
return
handled
;
}
bool
SendCustomResponse
(
std
:
:
unique_ptr
<
Event
>
&
event
)
override
{
if
(
mode_
=
=
Mode
:
:
Mode_largeResponse
)
{
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
eventWin
=
static_cast
<
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
>
(
event
.
get
(
)
)
;
HANDLE
pipe
=
eventWin
-
>
Pipe
(
)
;
std
:
:
cout
<
<
"
largeResponse
about
to
write
"
<
<
std
:
:
endl
;
DWORD
result
=
WriteBigMessageToPipe
(
pipe
eventWin
-
>
SerializeStringToSendToBrowser
(
)
)
;
std
:
:
cout
<
<
"
largeResponse
done
writing
with
error
"
<
<
result
<
<
std
:
:
endl
;
eventWin
-
>
SetResponseSent
(
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_resultWithInvalidStatus
)
{
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
eventWin
=
static_cast
<
content_analysis
:
:
sdk
:
:
ContentAnalysisEventWin
*
>
(
event
.
get
(
)
)
;
HANDLE
pipe
=
eventWin
-
>
Pipe
(
)
;
std
:
:
string
serializedString
=
eventWin
-
>
SerializeStringToSendToBrowser
(
)
;
serializedString
[
serializedString
.
length
(
)
-
1
]
=
100
;
WriteBigMessageToPipe
(
pipe
serializedString
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageTruncatedInMiddleOfString
)
{
unsigned
char
bytes
[
5
]
;
bytes
[
0
]
=
10
;
bytes
[
1
]
=
13
;
bytes
[
2
]
=
65
;
bytes
[
3
]
=
66
;
bytes
[
4
]
=
67
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithInvalidWireType
)
{
unsigned
char
bytes
[
5
]
;
bytes
[
0
]
=
15
;
bytes
[
1
]
=
3
;
bytes
[
2
]
=
65
;
bytes
[
3
]
=
66
;
bytes
[
4
]
=
67
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithUnusedFieldNumber
)
{
unsigned
char
bytes
[
5
]
;
bytes
[
0
]
=
82
;
bytes
[
1
]
=
3
;
bytes
[
2
]
=
65
;
bytes
[
3
]
=
66
;
bytes
[
4
]
=
67
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithWrongStringWireType
)
{
unsigned
char
bytes
[
2
]
;
bytes
[
0
]
=
10
;
bytes
[
1
]
=
42
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithZeroTag
)
{
unsigned
char
bytes
[
1
]
;
bytes
[
0
]
=
0
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithZeroFieldButNonzeroWireType
)
{
unsigned
char
bytes
[
5
]
;
bytes
[
0
]
=
2
;
bytes
[
1
]
=
3
;
bytes
[
2
]
=
65
;
bytes
[
3
]
=
66
;
bytes
[
4
]
=
67
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageWithGroupEnd
)
{
unsigned
char
bytes
[
1
]
;
bytes
[
0
]
=
12
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageTruncatedInMiddleOfVarint
)
{
unsigned
char
bytes
[
2
]
;
bytes
[
0
]
=
16
;
bytes
[
1
]
=
128
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
if
(
mode_
=
=
Mode
:
:
Mode_messageTruncatedInMiddleOfTag
)
{
unsigned
char
bytes
[
1
]
;
bytes
[
0
]
=
128
;
SendBytesOverPipe
(
bytes
event
)
;
}
else
{
return
false
;
}
return
true
;
}
private
:
Mode
mode_
;
}
;
#
endif
