#
include
<
vector
>
#
include
<
windows
.
h
>
#
include
<
sddl
.
h
>
#
include
"
utils_win
.
h
"
namespace
content_analysis
{
namespace
sdk
{
namespace
internal
{
std
:
:
string
GetUserSID
(
)
{
std
:
:
string
sid
;
HANDLE
handle
;
if
(
!
OpenThreadToken
(
GetCurrentThread
(
)
TOKEN_QUERY
TRUE
&
handle
)
&
&
!
OpenProcessToken
(
GetCurrentProcess
(
)
TOKEN_QUERY
&
handle
)
)
{
return
std
:
:
string
(
)
;
}
DWORD
length
=
0
;
std
:
:
vector
<
char
>
buffer
;
if
(
!
GetTokenInformation
(
handle
TokenUser
nullptr
0
&
length
)
)
{
DWORD
err
=
GetLastError
(
)
;
if
(
err
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
buffer
.
resize
(
length
)
;
}
}
if
(
GetTokenInformation
(
handle
TokenUser
buffer
.
data
(
)
buffer
.
size
(
)
&
length
)
)
{
TOKEN_USER
*
info
=
reinterpret_cast
<
TOKEN_USER
*
>
(
buffer
.
data
(
)
)
;
char
*
sid_string
;
if
(
ConvertSidToStringSidA
(
info
-
>
User
.
Sid
&
sid_string
)
)
{
sid
=
sid_string
;
LocalFree
(
sid_string
)
;
}
}
CloseHandle
(
handle
)
;
return
sid
;
}
std
:
:
string
BuildPipeName
(
const
char
*
prefix
const
std
:
:
string
&
base
bool
user_specific
)
{
std
:
:
string
pipename
=
prefix
;
if
(
!
user_specific
)
pipename
+
=
"
ProtectedPrefix
\
\
Administrators
\
\
"
;
pipename
+
=
base
;
if
(
user_specific
)
{
std
:
:
string
sid
=
GetUserSID
(
)
;
if
(
sid
.
empty
(
)
)
return
std
:
:
string
(
)
;
pipename
+
=
"
.
"
+
sid
;
}
return
pipename
;
}
std
:
:
string
GetPipeNameForAgent
(
const
std
:
:
string
&
base
bool
user_specific
)
{
return
BuildPipeName
(
kPipePrefixForAgent
base
user_specific
)
;
}
std
:
:
string
GetPipeNameForClient
(
const
std
:
:
string
&
base
bool
user_specific
)
{
return
BuildPipeName
(
kPipePrefixForClient
base
user_specific
)
;
}
DWORD
CreatePipe
(
const
std
:
:
string
&
name
bool
user_specific
bool
is_first_pipe
HANDLE
*
handle
)
{
DWORD
err
=
ERROR_SUCCESS
;
DWORD
mode
=
PIPE_ACCESS_DUPLEX
|
FILE_FLAG_OVERLAPPED
;
constexpr
char
kDaclEveryone
[
]
=
"
D
:
"
"
(
A
;
OICI
;
GA
;
;
;
CO
)
"
"
(
A
;
OICI
;
GA
;
;
;
BA
)
"
"
(
A
;
OICI
;
GRGW
;
;
;
WD
)
"
;
constexpr
char
kDaclUserSpecific
[
]
=
"
D
:
"
"
(
A
;
OICI
;
GA
;
;
;
CO
)
"
"
(
A
;
OICI
;
GA
;
;
;
BA
)
"
"
(
A
;
OICI
;
GRGW
;
;
;
IU
)
"
;
SECURITY_ATTRIBUTES
sa
;
memset
(
&
sa
0
sizeof
(
sa
)
)
;
sa
.
nLength
=
sizeof
(
sa
)
;
sa
.
bInheritHandle
=
FALSE
;
if
(
!
ConvertStringSecurityDescriptorToSecurityDescriptorA
(
user_specific
?
kDaclUserSpecific
:
kDaclEveryone
SDDL_REVISION_1
&
sa
.
lpSecurityDescriptor
nullptr
)
)
{
err
=
GetLastError
(
)
;
return
err
;
}
if
(
is_first_pipe
)
{
mode
|
=
FILE_FLAG_FIRST_PIPE_INSTANCE
;
}
*
handle
=
CreateNamedPipeA
(
name
.
c_str
(
)
mode
PIPE_TYPE_MESSAGE
|
PIPE_READMODE_MESSAGE
|
PIPE_WAIT
|
PIPE_REJECT_REMOTE_CLIENTS
PIPE_UNLIMITED_INSTANCES
kBufferSize
kBufferSize
0
&
sa
)
;
if
(
*
handle
=
=
INVALID_HANDLE_VALUE
)
{
err
=
GetLastError
(
)
;
}
LocalFree
(
sa
.
lpSecurityDescriptor
)
;
return
err
;
}
bool
GetProcessPath
(
unsigned
long
pid
std
:
:
string
*
binary_path
)
{
HANDLE
hProc
=
OpenProcess
(
PROCESS_QUERY_LIMITED_INFORMATION
FALSE
pid
)
;
if
(
hProc
=
=
nullptr
)
{
return
false
;
}
char
path
[
MAX_PATH
]
;
DWORD
size
=
sizeof
(
path
)
;
DWORD
length
=
QueryFullProcessImageNameA
(
hProc
0
path
&
size
)
;
CloseHandle
(
hProc
)
;
if
(
length
=
=
0
)
{
return
false
;
}
*
binary_path
=
path
;
return
true
;
}
ScopedOverlapped
:
:
ScopedOverlapped
(
)
{
memset
(
&
overlapped_
0
sizeof
(
overlapped_
)
)
;
overlapped_
.
hEvent
=
CreateEvent
(
nullptr
TRUE
FALSE
nullptr
)
;
}
ScopedOverlapped
:
:
~
ScopedOverlapped
(
)
{
if
(
overlapped_
.
hEvent
!
=
nullptr
)
{
CloseHandle
(
overlapped_
.
hEvent
)
;
}
}
}
}
}
