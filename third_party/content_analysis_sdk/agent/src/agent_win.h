#
ifndef
CONTENT_ANALYSIS_AGENT_SRC_AGENT_WIN_H_
#
define
CONTENT_ANALYSIS_AGENT_SRC_AGENT_WIN_H_
#
include
<
windows
.
h
>
#
include
<
memory
>
#
include
<
sstream
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
agent_base
.
h
"
namespace
content_analysis
{
namespace
sdk
{
class
AgentWin
:
public
AgentBase
{
public
:
AgentWin
(
Config
config
std
:
:
unique_ptr
<
AgentEventHandler
>
handler
ResultCode
*
rc
)
;
~
AgentWin
(
)
override
;
ResultCode
HandleEvents
(
)
override
;
ResultCode
Stop
(
)
override
;
std
:
:
string
DebugString
(
)
const
override
;
ResultCode
HandleOneEventForTesting
(
)
;
bool
IsAClientConnectedForTesting
(
)
;
private
:
class
Connection
{
public
:
Connection
(
const
std
:
:
string
&
pipename
bool
user_specific
AgentEventHandler
*
handler
bool
is_first_pipe
ResultCode
*
rc
)
;
Connection
(
const
Connection
&
other
)
=
delete
;
Connection
(
Connection
&
&
other
)
=
delete
;
Connection
&
operator
=
(
const
Connection
&
other
)
=
delete
;
Connection
&
operator
=
(
Connection
&
&
other
)
=
delete
;
~
Connection
(
)
;
bool
IsValid
(
)
const
{
return
handle_
!
=
INVALID_HANDLE_VALUE
;
}
bool
IsConnected
(
)
const
{
return
is_connected_
;
}
HANDLE
GetWaitHandle
(
)
const
{
return
overlapped_
.
hEvent
;
}
ResultCode
Reset
(
const
std
:
:
string
&
pipename
bool
user_specific
)
;
ResultCode
HandleEvent
(
HANDLE
wait_handle
)
;
void
AppendDebugString
(
std
:
:
stringstream
&
state
)
const
;
private
:
ResultCode
ConnectPipe
(
)
;
ResultCode
ResetInternal
(
const
std
:
:
string
&
pipename
bool
user_specific
bool
is_first_pipe
)
;
void
Cleanup
(
)
;
ResultCode
QueueReadFile
(
bool
reset_cursor
)
;
ResultCode
OnReadFile
(
BOOL
done_reading
DWORD
count
)
;
ResultCode
CallHandler
(
)
;
ResultCode
BuildBrowserInfo
(
)
;
ResultCode
NotifyIfError
(
const
char
*
context
ResultCode
rc
DWORD
err
=
ERROR_SUCCESS
)
;
AgentEventHandler
*
handler_
=
nullptr
;
HANDLE
handle_
=
INVALID_HANDLE_VALUE
;
OVERLAPPED
overlapped_
;
bool
is_connected_
=
false
;
BrowserInfo
browser_info_
;
std
:
:
vector
<
char
>
buffer_
;
char
*
cursor_
=
nullptr
;
DWORD
read_size_
=
0
;
DWORD
final_size_
=
0
;
}
;
void
GetHandles
(
std
:
:
vector
<
HANDLE
>
&
wait_handles
)
const
;
ResultCode
HandleOneEvent
(
std
:
:
vector
<
HANDLE
>
&
wait_handles
bool
*
stopped
)
;
void
Shutdown
(
)
;
std
:
:
string
pipename_
;
std
:
:
vector
<
std
:
:
unique_ptr
<
Connection
>
>
connections_
;
HANDLE
stop_event_
=
nullptr
;
}
;
}
}
#
endif
