#
include
<
sstream
>
#
include
<
utility
>
#
include
<
vector
>
#
include
<
windows
.
h
>
#
include
<
sddl
.
h
>
#
include
"
common
/
utils_win
.
h
"
#
include
"
agent_utils_win
.
h
"
#
include
"
agent_win
.
h
"
#
include
"
event_win
.
h
"
namespace
content_analysis
{
namespace
sdk
{
const
DWORD
kMinNumListeningPipeInstances
=
2
;
const
DWORD
kMinNumWaitHandles
=
kMinNumListeningPipeInstances
+
1
;
std
:
:
unique_ptr
<
Agent
>
Agent
:
:
Create
(
Config
config
std
:
:
unique_ptr
<
AgentEventHandler
>
handler
ResultCode
*
rc
)
{
auto
agent
=
std
:
:
make_unique
<
AgentWin
>
(
std
:
:
move
(
config
)
std
:
:
move
(
handler
)
rc
)
;
return
*
rc
=
=
ResultCode
:
:
OK
?
std
:
:
move
(
agent
)
:
nullptr
;
}
AgentWin
:
:
Connection
:
:
Connection
(
const
std
:
:
string
&
pipename
bool
user_specific
AgentEventHandler
*
handler
bool
is_first_pipe
ResultCode
*
rc
)
:
handler_
(
handler
)
{
*
rc
=
ResultCode
:
:
OK
;
memset
(
&
overlapped_
0
sizeof
(
overlapped_
)
)
;
overlapped_
.
hEvent
=
CreateEvent
(
nullptr
TRUE
FALSE
nullptr
)
;
if
(
!
overlapped_
.
hEvent
)
{
*
rc
=
ResultCode
:
:
ERR_CANNOT_CREATE_CHANNEL_IO_EVENT
;
return
;
}
*
rc
=
ResetInternal
(
pipename
user_specific
is_first_pipe
)
;
}
AgentWin
:
:
Connection
:
:
~
Connection
(
)
{
Cleanup
(
)
;
if
(
handle_
!
=
INVALID_HANDLE_VALUE
)
{
CloseHandle
(
handle_
)
;
}
if
(
overlapped_
.
hEvent
)
{
CloseHandle
(
overlapped_
.
hEvent
)
;
}
}
ResultCode
AgentWin
:
:
Connection
:
:
Reset
(
const
std
:
:
string
&
pipename
bool
user_specific
)
{
return
NotifyIfError
(
"
ConnectionReset
"
ResetInternal
(
pipename
user_specific
false
)
)
;
}
ResultCode
AgentWin
:
:
Connection
:
:
HandleEvent
(
HANDLE
handle
)
{
auto
rc
=
ResultCode
:
:
OK
;
DWORD
count
;
BOOL
success
=
GetOverlappedResult
(
handle
&
overlapped_
&
count
FALSE
)
;
if
(
!
is_connected_
)
{
if
(
success
)
{
is_connected_
=
true
;
buffer_
.
resize
(
internal
:
:
kBufferSize
)
;
rc
=
BuildBrowserInfo
(
)
;
if
(
rc
=
=
ResultCode
:
:
OK
)
{
handler_
-
>
OnBrowserConnected
(
browser_info_
)
;
}
}
else
{
rc
=
ErrorToResultCode
(
GetLastError
(
)
)
;
NotifyIfError
(
"
GetOverlappedResult
"
rc
)
;
}
}
else
{
rc
=
OnReadFile
(
success
count
)
;
}
if
(
rc
=
=
ResultCode
:
:
OK
|
|
rc
=
=
ResultCode
:
:
ERR_MORE_DATA
)
{
rc
=
QueueReadFile
(
rc
=
=
ResultCode
:
:
OK
)
;
}
if
(
rc
!
=
ResultCode
:
:
OK
&
&
rc
!
=
ResultCode
:
:
ERR_IO_PENDING
&
&
rc
!
=
ResultCode
:
:
ERR_MORE_DATA
)
{
Cleanup
(
)
;
}
else
{
rc
=
ResultCode
:
:
OK
;
}
return
rc
;
}
void
AgentWin
:
:
Connection
:
:
AppendDebugString
(
std
:
:
stringstream
&
state
)
const
{
state
<
<
"
{
handle
=
"
<
<
handle_
;
state
<
<
"
connected
=
"
<
<
is_connected_
;
state
<
<
"
pid
=
"
<
<
browser_info_
.
pid
;
state
<
<
"
rsize
=
"
<
<
read_size_
;
state
<
<
"
fsize
=
"
<
<
final_size_
;
state
<
<
"
}
"
;
}
ResultCode
AgentWin
:
:
Connection
:
:
ConnectPipe
(
)
{
if
(
ConnectNamedPipe
(
handle_
&
overlapped_
)
)
{
return
ErrorToResultCode
(
GetLastError
(
)
)
;
}
DWORD
err
=
GetLastError
(
)
;
if
(
err
=
=
ERROR_IO_PENDING
)
{
return
ResultCode
:
:
OK
;
}
else
if
(
err
=
=
ERROR_PIPE_CONNECTED
)
{
if
(
SetEvent
(
overlapped_
.
hEvent
)
)
{
err
=
ERROR_SUCCESS
;
}
else
{
err
=
GetLastError
(
)
;
}
}
return
ErrorToResultCode
(
err
)
;
}
ResultCode
AgentWin
:
:
Connection
:
:
ResetInternal
(
const
std
:
:
string
&
pipename
bool
user_specific
bool
is_first_pipe
)
{
auto
rc
=
ResultCode
:
:
OK
;
if
(
handle_
!
=
INVALID_HANDLE_VALUE
)
{
if
(
!
DisconnectNamedPipe
(
handle_
)
)
{
rc
=
ErrorToResultCode
(
GetLastError
(
)
)
;
}
}
else
{
rc
=
ErrorToResultCode
(
internal
:
:
CreatePipe
(
pipename
user_specific
is_first_pipe
&
handle_
)
)
;
}
if
(
rc
=
=
ResultCode
:
:
OK
&
&
!
ResetEvent
(
overlapped_
.
hEvent
)
)
{
rc
=
ErrorToResultCode
(
GetLastError
(
)
)
;
}
if
(
rc
=
=
ResultCode
:
:
OK
)
{
rc
=
ConnectPipe
(
)
;
}
if
(
rc
!
=
ResultCode
:
:
OK
)
{
Cleanup
(
)
;
handle_
=
INVALID_HANDLE_VALUE
;
}
return
rc
;
}
void
AgentWin
:
:
Connection
:
:
Cleanup
(
)
{
if
(
is_connected_
&
&
handler_
)
{
handler_
-
>
OnBrowserDisconnected
(
browser_info_
)
;
}
is_connected_
=
false
;
browser_info_
=
BrowserInfo
(
)
;
buffer_
.
clear
(
)
;
cursor_
=
nullptr
;
read_size_
=
0
;
final_size_
=
0
;
if
(
handle_
!
=
INVALID_HANDLE_VALUE
)
{
CancelIoEx
(
handle_
nullptr
)
;
}
}
ResultCode
AgentWin
:
:
Connection
:
:
QueueReadFile
(
bool
reset_cursor
)
{
if
(
reset_cursor
)
{
cursor_
=
buffer_
.
data
(
)
;
read_size_
=
buffer_
.
size
(
)
;
final_size_
=
0
;
}
auto
rc
=
ResultCode
:
:
OK
;
DWORD
count
;
if
(
!
ReadFile
(
handle_
cursor_
read_size_
&
count
&
overlapped_
)
)
{
DWORD
err
=
GetLastError
(
)
;
rc
=
ErrorToResultCode
(
err
)
;
if
(
rc
!
=
ResultCode
:
:
ERR_IO_PENDING
&
&
rc
!
=
ResultCode
:
:
ERR_BROKEN_PIPE
&
&
rc
!
=
ResultCode
:
:
ERR_MORE_DATA
)
{
NotifyIfError
(
"
QueueReadFile
"
rc
err
)
;
}
}
return
rc
;
}
ResultCode
AgentWin
:
:
Connection
:
:
OnReadFile
(
BOOL
done_reading
DWORD
count
)
{
final_size_
+
=
count
;
if
(
done_reading
)
{
return
CallHandler
(
)
;
}
DWORD
err
=
GetLastError
(
)
;
if
(
err
=
=
ERROR_MORE_DATA
)
{
read_size_
=
internal
:
:
kBufferSize
;
buffer_
.
resize
(
buffer_
.
size
(
)
+
read_size_
)
;
cursor_
=
buffer_
.
data
(
)
+
buffer_
.
size
(
)
-
read_size_
;
return
ErrorToResultCode
(
err
)
;
}
return
NotifyIfError
(
"
OnReadFile
"
ErrorToResultCode
(
err
)
)
;
}
ResultCode
AgentWin
:
:
Connection
:
:
CallHandler
(
)
{
ChromeToAgent
message
;
if
(
!
message
.
ParseFromArray
(
buffer_
.
data
(
)
final_size_
)
)
{
return
NotifyIfError
(
"
ParseChromeToAgent
"
ResultCode
:
:
ERR_INVALID_REQUEST_FROM_BROWSER
)
;
}
auto
rc
=
ResultCode
:
:
OK
;
if
(
message
.
has_request
(
)
)
{
auto
event
=
std
:
:
make_unique
<
ContentAnalysisEventWin
>
(
handle_
browser_info_
std
:
:
move
(
*
message
.
mutable_request
(
)
)
)
;
rc
=
event
-
>
Init
(
)
;
if
(
rc
=
=
ResultCode
:
:
OK
)
{
handler_
-
>
OnAnalysisRequested
(
std
:
:
move
(
event
)
)
;
}
else
{
NotifyIfError
(
"
RequestValidation
"
rc
)
;
}
}
else
if
(
message
.
has_ack
(
)
)
{
handler_
-
>
OnResponseAcknowledged
(
message
.
ack
(
)
)
;
}
else
if
(
message
.
has_cancel
(
)
)
{
handler_
-
>
OnCancelRequests
(
message
.
cancel
(
)
)
;
}
else
{
rc
=
NotifyIfError
(
"
NoRequestOrAck
"
ResultCode
:
:
ERR_INVALID_REQUEST_FROM_BROWSER
)
;
}
return
rc
;
}
ResultCode
AgentWin
:
:
Connection
:
:
BuildBrowserInfo
(
)
{
if
(
!
GetNamedPipeClientProcessId
(
handle_
&
browser_info_
.
pid
)
)
{
return
NotifyIfError
(
"
BuildBrowserInfo
"
ResultCode
:
:
ERR_CANNOT_GET_BROWSER_PID
)
;
}
if
(
!
internal
:
:
GetProcessPath
(
browser_info_
.
pid
&
browser_info_
.
binary_path
)
)
{
return
NotifyIfError
(
"
BuildBrowserInfo
"
ResultCode
:
:
ERR_CANNOT_GET_BROWSER_BINARY_PATH
)
;
}
return
ResultCode
:
:
OK
;
}
ResultCode
AgentWin
:
:
Connection
:
:
NotifyIfError
(
const
char
*
context
ResultCode
rc
DWORD
err
)
{
if
(
handler_
&
&
rc
!
=
ResultCode
:
:
OK
)
{
std
:
:
stringstream
stm
;
stm
<
<
context
<
<
"
pid
=
"
<
<
browser_info_
.
pid
;
if
(
err
!
=
ERROR_SUCCESS
)
{
stm
<
<
context
<
<
"
err
=
"
<
<
err
;
}
handler_
-
>
OnInternalError
(
stm
.
str
(
)
.
c_str
(
)
rc
)
;
}
return
rc
;
}
AgentWin
:
:
AgentWin
(
Config
config
std
:
:
unique_ptr
<
AgentEventHandler
>
event_handler
ResultCode
*
rc
)
:
AgentBase
(
std
:
:
move
(
config
)
std
:
:
move
(
event_handler
)
)
{
*
rc
=
ResultCode
:
:
OK
;
if
(
handler
(
)
=
=
nullptr
)
{
*
rc
=
ResultCode
:
:
ERR_AGENT_EVENT_HANDLER_NOT_SPECIFIED
;
return
;
}
stop_event_
=
CreateEvent
(
nullptr
TRUE
FALSE
nullptr
)
;
if
(
stop_event_
=
=
nullptr
)
{
*
rc
=
ResultCode
:
:
ERR_CANNOT_CREATE_AGENT_STOP_EVENT
;
return
;
}
std
:
:
string
pipename
=
internal
:
:
GetPipeNameForAgent
(
configuration
(
)
.
name
configuration
(
)
.
user_specific
)
;
if
(
pipename
.
empty
(
)
)
{
*
rc
=
ResultCode
:
:
ERR_INVALID_CHANNEL_NAME
;
return
;
}
pipename_
=
pipename
;
connections_
.
reserve
(
kMinNumListeningPipeInstances
)
;
for
(
DWORD
i
=
0
;
i
<
kMinNumListeningPipeInstances
;
+
+
i
)
{
connections_
.
emplace_back
(
std
:
:
make_unique
<
Connection
>
(
pipename_
configuration
(
)
.
user_specific
handler
(
)
i
=
=
0
rc
)
)
;
if
(
*
rc
!
=
ResultCode
:
:
OK
|
|
!
connections_
.
back
(
)
-
>
IsValid
(
)
)
{
Shutdown
(
)
;
break
;
}
}
}
AgentWin
:
:
~
AgentWin
(
)
{
Shutdown
(
)
;
}
ResultCode
AgentWin
:
:
HandleEvents
(
)
{
std
:
:
vector
<
HANDLE
>
wait_handles
;
auto
rc
=
ResultCode
:
:
OK
;
bool
stopped
=
false
;
while
(
!
stopped
&
&
rc
=
=
ResultCode
:
:
OK
)
{
rc
=
HandleOneEvent
(
wait_handles
&
stopped
)
;
}
return
rc
;
}
ResultCode
AgentWin
:
:
Stop
(
)
{
SetEvent
(
stop_event_
)
;
return
AgentBase
:
:
Stop
(
)
;
}
std
:
:
string
AgentWin
:
:
DebugString
(
)
const
{
std
:
:
stringstream
state
;
state
.
setf
(
std
:
:
ios
:
:
boolalpha
)
;
state
<
<
"
AgentWin
{
pipe
=
\
"
"
<
<
pipename_
;
state
<
<
"
\
"
stop
=
"
<
<
stop_event_
;
for
(
size_t
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
{
state
<
<
"
conn
"
<
<
i
;
connections_
[
i
]
-
>
AppendDebugString
(
state
)
;
}
state
<
<
"
}
"
<
<
std
:
:
ends
;
return
state
.
str
(
)
;
}
void
AgentWin
:
:
GetHandles
(
std
:
:
vector
<
HANDLE
>
&
wait_handles
)
const
{
wait_handles
.
clear
(
)
;
wait_handles
.
reserve
(
1
+
connections_
.
size
(
)
)
;
for
(
auto
&
state
:
connections_
)
{
HANDLE
wait_handle
=
state
-
>
GetWaitHandle
(
)
;
if
(
!
wait_handle
)
{
wait_handles
.
clear
(
)
;
break
;
}
wait_handles
.
push_back
(
wait_handle
)
;
}
wait_handles
.
push_back
(
stop_event_
)
;
}
ResultCode
AgentWin
:
:
HandleOneEventForTesting
(
)
{
std
:
:
vector
<
HANDLE
>
wait_handles
;
bool
stopped
;
return
HandleOneEvent
(
wait_handles
&
stopped
)
;
}
bool
AgentWin
:
:
IsAClientConnectedForTesting
(
)
{
for
(
const
auto
&
state
:
connections_
)
{
if
(
state
-
>
IsConnected
(
)
)
{
return
true
;
}
}
return
false
;
}
ResultCode
AgentWin
:
:
HandleOneEvent
(
std
:
:
vector
<
HANDLE
>
&
wait_handles
bool
*
stopped
)
{
*
stopped
=
false
;
GetHandles
(
wait_handles
)
;
if
(
wait_handles
.
size
(
)
<
kMinNumWaitHandles
)
{
return
NotifyError
(
"
GetHandles
"
ResultCode
:
:
ERR_AGENT_NOT_INITIALIZED
)
;
}
DWORD
index
=
WaitForMultipleObjects
(
wait_handles
.
size
(
)
wait_handles
.
data
(
)
FALSE
INFINITE
)
;
if
(
index
=
=
WAIT_FAILED
)
{
return
NotifyError
(
"
WaitForMultipleObjects
"
ErrorToResultCode
(
GetLastError
(
)
)
)
;
}
index
-
=
WAIT_OBJECT_0
;
if
(
index
=
=
wait_handles
.
size
(
)
-
1
)
{
*
stopped
=
true
;
return
ResultCode
:
:
OK
;
}
auto
&
connection
=
connections_
[
index
]
;
bool
was_listening
=
!
connection
-
>
IsConnected
(
)
;
auto
rc
=
connection
-
>
HandleEvent
(
wait_handles
[
index
]
)
;
if
(
rc
!
=
ResultCode
:
:
OK
)
{
if
(
!
was_listening
&
&
connections_
.
size
(
)
>
kMinNumListeningPipeInstances
)
{
connections_
.
erase
(
connections_
.
begin
(
)
+
index
)
;
}
else
{
rc
=
connection
-
>
Reset
(
pipename_
configuration
(
)
.
user_specific
)
;
}
}
if
(
rc
=
=
ResultCode
:
:
OK
&
&
was_listening
&
&
connection
-
>
IsConnected
(
)
)
{
connections_
.
emplace_back
(
std
:
:
make_unique
<
Connection
>
(
pipename_
configuration
(
)
.
user_specific
handler
(
)
false
&
rc
)
)
;
}
return
ResultCode
:
:
OK
;
}
void
AgentWin
:
:
Shutdown
(
)
{
connections_
.
clear
(
)
;
pipename_
.
clear
(
)
;
if
(
stop_event_
!
=
nullptr
)
{
CloseHandle
(
stop_event_
)
;
stop_event_
=
nullptr
;
}
}
}
}
