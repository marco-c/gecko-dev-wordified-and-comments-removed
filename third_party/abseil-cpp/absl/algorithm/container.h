#
ifndef
ABSL_ALGORITHM_CONTAINER_H_
#
define
ABSL_ALGORITHM_CONTAINER_H_
#
include
<
algorithm
>
#
include
<
cassert
>
#
include
<
iterator
>
#
include
<
numeric
>
#
include
<
type_traits
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
algorithm
/
algorithm
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_algorithm_internal
{
using
std
:
:
begin
;
using
std
:
:
end
;
template
<
typename
C
>
using
ContainerIter
=
decltype
(
begin
(
std
:
:
declval
<
C
&
>
(
)
)
)
;
template
<
typename
C1
typename
C2
>
using
ContainerIterPairType
=
decltype
(
std
:
:
make_pair
(
ContainerIter
<
C1
>
(
)
ContainerIter
<
C2
>
(
)
)
)
;
template
<
typename
C
>
using
ContainerDifferenceType
=
decltype
(
std
:
:
distance
(
std
:
:
declval
<
ContainerIter
<
C
>
>
(
)
std
:
:
declval
<
ContainerIter
<
C
>
>
(
)
)
)
;
template
<
typename
C
>
using
ContainerPointerType
=
typename
std
:
:
iterator_traits
<
ContainerIter
<
C
>
>
:
:
pointer
;
template
<
typename
C
>
ContainerIter
<
C
>
c_begin
(
C
&
c
)
{
return
begin
(
c
)
;
}
template
<
typename
C
>
ContainerIter
<
C
>
c_end
(
C
&
c
)
{
return
end
(
c
)
;
}
template
<
typename
T
>
struct
IsUnorderedContainer
:
std
:
:
false_type
{
}
;
template
<
class
Key
class
T
class
Hash
class
KeyEqual
class
Allocator
>
struct
IsUnorderedContainer
<
std
:
:
unordered_map
<
Key
T
Hash
KeyEqual
Allocator
>
>
:
std
:
:
true_type
{
}
;
template
<
class
Key
class
Hash
class
KeyEqual
class
Allocator
>
struct
IsUnorderedContainer
<
std
:
:
unordered_set
<
Key
Hash
KeyEqual
Allocator
>
>
:
std
:
:
true_type
{
}
;
}
template
<
typename
C
typename
EqualityComparable
>
bool
c_linear_search
(
const
C
&
c
EqualityComparable
&
&
value
)
{
return
linear_search
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
EqualityComparable
>
(
value
)
)
;
}
template
<
typename
C
>
container_algorithm_internal
:
:
ContainerDifferenceType
<
const
C
>
c_distance
(
const
C
&
c
)
{
return
std
:
:
distance
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
)
;
}
template
<
typename
C
typename
Pred
>
bool
c_all_of
(
const
C
&
c
Pred
&
&
pred
)
{
return
std
:
:
all_of
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C
typename
Pred
>
bool
c_any_of
(
const
C
&
c
Pred
&
&
pred
)
{
return
std
:
:
any_of
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C
typename
Pred
>
bool
c_none_of
(
const
C
&
c
Pred
&
&
pred
)
{
return
std
:
:
none_of
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C
typename
Function
>
decay_t
<
Function
>
c_for_each
(
C
&
&
c
Function
&
&
f
)
{
return
std
:
:
for_each
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Function
>
(
f
)
)
;
}
template
<
typename
C
typename
T
>
container_algorithm_internal
:
:
ContainerIter
<
C
>
c_find
(
C
&
c
T
&
&
value
)
{
return
std
:
:
find
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
T
>
(
value
)
)
;
}
template
<
typename
C
typename
Pred
>
container_algorithm_internal
:
:
ContainerIter
<
C
>
c_find_if
(
C
&
c
Pred
&
&
pred
)
{
return
std
:
:
find_if
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C
typename
Pred
>
container_algorithm_internal
:
:
ContainerIter
<
C
>
c_find_if_not
(
C
&
c
Pred
&
&
pred
)
{
return
std
:
:
find_if_not
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
Sequence1
typename
Sequence2
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence1
>
c_find_end
(
Sequence1
&
sequence
Sequence2
&
subsequence
)
{
return
std
:
:
find_end
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
container_algorithm_internal
:
:
c_begin
(
subsequence
)
container_algorithm_internal
:
:
c_end
(
subsequence
)
)
;
}
template
<
typename
Sequence1
typename
Sequence2
typename
BinaryPredicate
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence1
>
c_find_end
(
Sequence1
&
sequence
Sequence2
&
subsequence
BinaryPredicate
&
&
pred
)
{
return
std
:
:
find_end
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
container_algorithm_internal
:
:
c_begin
(
subsequence
)
container_algorithm_internal
:
:
c_end
(
subsequence
)
std
:
:
forward
<
BinaryPredicate
>
(
pred
)
)
;
}
template
<
typename
C1
typename
C2
>
container_algorithm_internal
:
:
ContainerIter
<
C1
>
c_find_first_of
(
C1
&
container
C2
&
options
)
{
return
std
:
:
find_first_of
(
container_algorithm_internal
:
:
c_begin
(
container
)
container_algorithm_internal
:
:
c_end
(
container
)
container_algorithm_internal
:
:
c_begin
(
options
)
container_algorithm_internal
:
:
c_end
(
options
)
)
;
}
template
<
typename
C1
typename
C2
typename
BinaryPredicate
>
container_algorithm_internal
:
:
ContainerIter
<
C1
>
c_find_first_of
(
C1
&
container
C2
&
options
BinaryPredicate
&
&
pred
)
{
return
std
:
:
find_first_of
(
container_algorithm_internal
:
:
c_begin
(
container
)
container_algorithm_internal
:
:
c_end
(
container
)
container_algorithm_internal
:
:
c_begin
(
options
)
container_algorithm_internal
:
:
c_end
(
options
)
std
:
:
forward
<
BinaryPredicate
>
(
pred
)
)
;
}
template
<
typename
Sequence
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_adjacent_find
(
Sequence
&
sequence
)
{
return
std
:
:
adjacent_find
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
Sequence
typename
BinaryPredicate
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_adjacent_find
(
Sequence
&
sequence
BinaryPredicate
&
&
pred
)
{
return
std
:
:
adjacent_find
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
BinaryPredicate
>
(
pred
)
)
;
}
template
<
typename
C
typename
T
>
container_algorithm_internal
:
:
ContainerDifferenceType
<
const
C
>
c_count
(
const
C
&
c
T
&
&
value
)
{
return
std
:
:
count
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
T
>
(
value
)
)
;
}
template
<
typename
C
typename
Pred
>
container_algorithm_internal
:
:
ContainerDifferenceType
<
const
C
>
c_count_if
(
const
C
&
c
Pred
&
&
pred
)
{
return
std
:
:
count_if
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C1
typename
C2
>
container_algorithm_internal
:
:
ContainerIterPairType
<
C1
C2
>
c_mismatch
(
C1
&
c1
C2
&
c2
)
{
return
std
:
:
mismatch
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
)
;
}
template
<
typename
C1
typename
C2
typename
BinaryPredicate
>
container_algorithm_internal
:
:
ContainerIterPairType
<
C1
C2
>
c_mismatch
(
C1
&
c1
C2
&
c2
BinaryPredicate
pred
)
{
return
std
:
:
mismatch
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
pred
)
;
}
template
<
typename
C1
typename
C2
>
bool
c_equal
(
const
C1
&
c1
const
C2
&
c2
)
{
return
std
:
:
equal
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
)
;
}
template
<
typename
C1
typename
C2
typename
BinaryPredicate
>
bool
c_equal
(
const
C1
&
c1
const
C2
&
c2
BinaryPredicate
&
&
pred
)
{
return
std
:
:
equal
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
std
:
:
forward
<
BinaryPredicate
>
(
pred
)
)
;
}
template
<
typename
C1
typename
C2
>
bool
c_is_permutation
(
const
C1
&
c1
const
C2
&
c2
)
{
return
std
:
:
is_permutation
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
)
;
}
template
<
typename
C1
typename
C2
typename
BinaryPredicate
>
bool
c_is_permutation
(
const
C1
&
c1
const
C2
&
c2
BinaryPredicate
&
&
pred
)
{
return
std
:
:
is_permutation
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
std
:
:
forward
<
BinaryPredicate
>
(
pred
)
)
;
}
template
<
typename
Sequence1
typename
Sequence2
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence1
>
c_search
(
Sequence1
&
sequence
Sequence2
&
subsequence
)
{
return
std
:
:
search
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
container_algorithm_internal
:
:
c_begin
(
subsequence
)
container_algorithm_internal
:
:
c_end
(
subsequence
)
)
;
}
template
<
typename
Sequence1
typename
Sequence2
typename
BinaryPredicate
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence1
>
c_search
(
Sequence1
&
sequence
Sequence2
&
subsequence
BinaryPredicate
&
&
pred
)
{
return
std
:
:
search
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
container_algorithm_internal
:
:
c_begin
(
subsequence
)
container_algorithm_internal
:
:
c_end
(
subsequence
)
std
:
:
forward
<
BinaryPredicate
>
(
pred
)
)
;
}
template
<
typename
Sequence
typename
Size
typename
T
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_search_n
(
Sequence
&
sequence
Size
count
T
&
&
value
)
{
return
std
:
:
search_n
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
count
std
:
:
forward
<
T
>
(
value
)
)
;
}
template
<
typename
Sequence
typename
Size
typename
T
typename
BinaryPredicate
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_search_n
(
Sequence
&
sequence
Size
count
T
&
&
value
BinaryPredicate
&
&
pred
)
{
return
std
:
:
search_n
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
count
std
:
:
forward
<
T
>
(
value
)
std
:
:
forward
<
BinaryPredicate
>
(
pred
)
)
;
}
template
<
typename
InputSequence
typename
OutputIterator
>
OutputIterator
c_copy
(
const
InputSequence
&
input
OutputIterator
output
)
{
return
std
:
:
copy
(
container_algorithm_internal
:
:
c_begin
(
input
)
container_algorithm_internal
:
:
c_end
(
input
)
output
)
;
}
template
<
typename
C
typename
Size
typename
OutputIterator
>
OutputIterator
c_copy_n
(
const
C
&
input
Size
n
OutputIterator
output
)
{
return
std
:
:
copy_n
(
container_algorithm_internal
:
:
c_begin
(
input
)
n
output
)
;
}
template
<
typename
InputSequence
typename
OutputIterator
typename
Pred
>
OutputIterator
c_copy_if
(
const
InputSequence
&
input
OutputIterator
output
Pred
&
&
pred
)
{
return
std
:
:
copy_if
(
container_algorithm_internal
:
:
c_begin
(
input
)
container_algorithm_internal
:
:
c_end
(
input
)
output
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C
typename
BidirectionalIterator
>
BidirectionalIterator
c_copy_backward
(
const
C
&
src
BidirectionalIterator
dest
)
{
return
std
:
:
copy_backward
(
container_algorithm_internal
:
:
c_begin
(
src
)
container_algorithm_internal
:
:
c_end
(
src
)
dest
)
;
}
template
<
typename
C
typename
OutputIterator
>
OutputIterator
c_move
(
C
&
&
src
OutputIterator
dest
)
{
return
std
:
:
move
(
container_algorithm_internal
:
:
c_begin
(
src
)
container_algorithm_internal
:
:
c_end
(
src
)
dest
)
;
}
template
<
typename
C
typename
BidirectionalIterator
>
BidirectionalIterator
c_move_backward
(
C
&
&
src
BidirectionalIterator
dest
)
{
return
std
:
:
move_backward
(
container_algorithm_internal
:
:
c_begin
(
src
)
container_algorithm_internal
:
:
c_end
(
src
)
dest
)
;
}
template
<
typename
C1
typename
C2
>
container_algorithm_internal
:
:
ContainerIter
<
C2
>
c_swap_ranges
(
C1
&
c1
C2
&
c2
)
{
auto
first1
=
container_algorithm_internal
:
:
c_begin
(
c1
)
;
auto
last1
=
container_algorithm_internal
:
:
c_end
(
c1
)
;
auto
first2
=
container_algorithm_internal
:
:
c_begin
(
c2
)
;
auto
last2
=
container_algorithm_internal
:
:
c_end
(
c2
)
;
using
std
:
:
swap
;
for
(
;
first1
!
=
last1
&
&
first2
!
=
last2
;
+
+
first1
(
void
)
+
+
first2
)
{
swap
(
*
first1
*
first2
)
;
}
return
first2
;
}
template
<
typename
InputSequence
typename
OutputIterator
typename
UnaryOp
>
OutputIterator
c_transform
(
const
InputSequence
&
input
OutputIterator
output
UnaryOp
&
&
unary_op
)
{
return
std
:
:
transform
(
container_algorithm_internal
:
:
c_begin
(
input
)
container_algorithm_internal
:
:
c_end
(
input
)
output
std
:
:
forward
<
UnaryOp
>
(
unary_op
)
)
;
}
template
<
typename
InputSequence1
typename
InputSequence2
typename
OutputIterator
typename
BinaryOp
>
OutputIterator
c_transform
(
const
InputSequence1
&
input1
const
InputSequence2
&
input2
OutputIterator
output
BinaryOp
&
&
binary_op
)
{
auto
first1
=
container_algorithm_internal
:
:
c_begin
(
input1
)
;
auto
last1
=
container_algorithm_internal
:
:
c_end
(
input1
)
;
auto
first2
=
container_algorithm_internal
:
:
c_begin
(
input2
)
;
auto
last2
=
container_algorithm_internal
:
:
c_end
(
input2
)
;
for
(
;
first1
!
=
last1
&
&
first2
!
=
last2
;
+
+
first1
(
void
)
+
+
first2
+
+
output
)
{
*
output
=
binary_op
(
*
first1
*
first2
)
;
}
return
output
;
}
template
<
typename
Sequence
typename
T
>
void
c_replace
(
Sequence
&
sequence
const
T
&
old_value
const
T
&
new_value
)
{
std
:
:
replace
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
old_value
new_value
)
;
}
template
<
typename
C
typename
Pred
typename
T
>
void
c_replace_if
(
C
&
c
Pred
&
&
pred
T
&
&
new_value
)
{
std
:
:
replace_if
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Pred
>
(
pred
)
std
:
:
forward
<
T
>
(
new_value
)
)
;
}
template
<
typename
C
typename
OutputIterator
typename
T
>
OutputIterator
c_replace_copy
(
const
C
&
c
OutputIterator
result
T
&
&
old_value
T
&
&
new_value
)
{
return
std
:
:
replace_copy
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
result
std
:
:
forward
<
T
>
(
old_value
)
std
:
:
forward
<
T
>
(
new_value
)
)
;
}
template
<
typename
C
typename
OutputIterator
typename
Pred
typename
T
>
OutputIterator
c_replace_copy_if
(
const
C
&
c
OutputIterator
result
Pred
&
&
pred
const
T
&
new_value
)
{
return
std
:
:
replace_copy_if
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
result
std
:
:
forward
<
Pred
>
(
pred
)
new_value
)
;
}
template
<
typename
C
typename
T
>
void
c_fill
(
C
&
c
const
T
&
value
)
{
std
:
:
fill
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
value
)
;
}
template
<
typename
C
typename
Size
typename
T
>
void
c_fill_n
(
C
&
c
Size
n
const
T
&
value
)
{
std
:
:
fill_n
(
container_algorithm_internal
:
:
c_begin
(
c
)
n
value
)
;
}
template
<
typename
C
typename
Generator
>
void
c_generate
(
C
&
c
Generator
&
&
gen
)
{
std
:
:
generate
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Generator
>
(
gen
)
)
;
}
template
<
typename
C
typename
Size
typename
Generator
>
container_algorithm_internal
:
:
ContainerIter
<
C
>
c_generate_n
(
C
&
c
Size
n
Generator
&
&
gen
)
{
return
std
:
:
generate_n
(
container_algorithm_internal
:
:
c_begin
(
c
)
n
std
:
:
forward
<
Generator
>
(
gen
)
)
;
}
template
<
typename
C
typename
OutputIterator
typename
T
>
OutputIterator
c_remove_copy
(
const
C
&
c
OutputIterator
result
const
T
&
value
)
{
return
std
:
:
remove_copy
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
result
value
)
;
}
template
<
typename
C
typename
OutputIterator
typename
Pred
>
OutputIterator
c_remove_copy_if
(
const
C
&
c
OutputIterator
result
Pred
&
&
pred
)
{
return
std
:
:
remove_copy_if
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
result
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C
typename
OutputIterator
>
OutputIterator
c_unique_copy
(
const
C
&
c
OutputIterator
result
)
{
return
std
:
:
unique_copy
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
result
)
;
}
template
<
typename
C
typename
OutputIterator
typename
BinaryPredicate
>
OutputIterator
c_unique_copy
(
const
C
&
c
OutputIterator
result
BinaryPredicate
&
&
pred
)
{
return
std
:
:
unique_copy
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
result
std
:
:
forward
<
BinaryPredicate
>
(
pred
)
)
;
}
template
<
typename
Sequence
>
void
c_reverse
(
Sequence
&
sequence
)
{
std
:
:
reverse
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
C
typename
OutputIterator
>
OutputIterator
c_reverse_copy
(
const
C
&
sequence
OutputIterator
result
)
{
return
std
:
:
reverse_copy
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
result
)
;
}
template
<
typename
C
typename
Iterator
=
container_algorithm_internal
:
:
ContainerIter
<
C
>
>
Iterator
c_rotate
(
C
&
sequence
Iterator
middle
)
{
return
absl
:
:
rotate
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
middle
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
C
typename
OutputIterator
>
OutputIterator
c_rotate_copy
(
const
C
&
sequence
container_algorithm_internal
:
:
ContainerIter
<
const
C
>
middle
OutputIterator
result
)
{
return
std
:
:
rotate_copy
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
middle
container_algorithm_internal
:
:
c_end
(
sequence
)
result
)
;
}
template
<
typename
RandomAccessContainer
typename
UniformRandomBitGenerator
>
void
c_shuffle
(
RandomAccessContainer
&
c
UniformRandomBitGenerator
&
&
gen
)
{
std
:
:
shuffle
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
UniformRandomBitGenerator
>
(
gen
)
)
;
}
template
<
typename
C
typename
Pred
>
bool
c_is_partitioned
(
const
C
&
c
Pred
&
&
pred
)
{
return
std
:
:
is_partitioned
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C
typename
Pred
>
container_algorithm_internal
:
:
ContainerIter
<
C
>
c_partition
(
C
&
c
Pred
&
&
pred
)
{
return
std
:
:
partition
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C
typename
Pred
>
container_algorithm_internal
:
:
ContainerIter
<
C
>
c_stable_partition
(
C
&
c
Pred
&
&
pred
)
{
return
std
:
:
stable_partition
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C
typename
OutputIterator1
typename
OutputIterator2
typename
Pred
>
std
:
:
pair
<
OutputIterator1
OutputIterator2
>
c_partition_copy
(
const
C
&
c
OutputIterator1
out_true
OutputIterator2
out_false
Pred
&
&
pred
)
{
return
std
:
:
partition_copy
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
out_true
out_false
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C
typename
Pred
>
container_algorithm_internal
:
:
ContainerIter
<
C
>
c_partition_point
(
C
&
c
Pred
&
&
pred
)
{
return
std
:
:
partition_point
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
Pred
>
(
pred
)
)
;
}
template
<
typename
C
>
void
c_sort
(
C
&
c
)
{
std
:
:
sort
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
)
;
}
template
<
typename
C
typename
LessThan
>
void
c_sort
(
C
&
c
LessThan
&
&
comp
)
{
std
:
:
sort
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C
>
void
c_stable_sort
(
C
&
c
)
{
std
:
:
stable_sort
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
)
;
}
template
<
typename
C
typename
LessThan
>
void
c_stable_sort
(
C
&
c
LessThan
&
&
comp
)
{
std
:
:
stable_sort
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C
>
bool
c_is_sorted
(
const
C
&
c
)
{
return
std
:
:
is_sorted
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
)
;
}
template
<
typename
C
typename
LessThan
>
bool
c_is_sorted
(
const
C
&
c
LessThan
&
&
comp
)
{
return
std
:
:
is_sorted
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
RandomAccessContainer
>
void
c_partial_sort
(
RandomAccessContainer
&
sequence
container_algorithm_internal
:
:
ContainerIter
<
RandomAccessContainer
>
middle
)
{
std
:
:
partial_sort
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
middle
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
RandomAccessContainer
typename
LessThan
>
void
c_partial_sort
(
RandomAccessContainer
&
sequence
container_algorithm_internal
:
:
ContainerIter
<
RandomAccessContainer
>
middle
LessThan
&
&
comp
)
{
std
:
:
partial_sort
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
middle
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C
typename
RandomAccessContainer
>
container_algorithm_internal
:
:
ContainerIter
<
RandomAccessContainer
>
c_partial_sort_copy
(
const
C
&
sequence
RandomAccessContainer
&
result
)
{
return
std
:
:
partial_sort_copy
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
container_algorithm_internal
:
:
c_begin
(
result
)
container_algorithm_internal
:
:
c_end
(
result
)
)
;
}
template
<
typename
C
typename
RandomAccessContainer
typename
LessThan
>
container_algorithm_internal
:
:
ContainerIter
<
RandomAccessContainer
>
c_partial_sort_copy
(
const
C
&
sequence
RandomAccessContainer
&
result
LessThan
&
&
comp
)
{
return
std
:
:
partial_sort_copy
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
container_algorithm_internal
:
:
c_begin
(
result
)
container_algorithm_internal
:
:
c_end
(
result
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C
>
container_algorithm_internal
:
:
ContainerIter
<
C
>
c_is_sorted_until
(
C
&
c
)
{
return
std
:
:
is_sorted_until
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
)
;
}
template
<
typename
C
typename
LessThan
>
container_algorithm_internal
:
:
ContainerIter
<
C
>
c_is_sorted_until
(
C
&
c
LessThan
&
&
comp
)
{
return
std
:
:
is_sorted_until
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
RandomAccessContainer
>
void
c_nth_element
(
RandomAccessContainer
&
sequence
container_algorithm_internal
:
:
ContainerIter
<
RandomAccessContainer
>
nth
)
{
std
:
:
nth_element
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
nth
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
RandomAccessContainer
typename
LessThan
>
void
c_nth_element
(
RandomAccessContainer
&
sequence
container_algorithm_internal
:
:
ContainerIter
<
RandomAccessContainer
>
nth
LessThan
&
&
comp
)
{
std
:
:
nth_element
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
nth
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
Sequence
typename
T
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_lower_bound
(
Sequence
&
sequence
const
T
&
value
)
{
return
std
:
:
lower_bound
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
value
)
;
}
template
<
typename
Sequence
typename
T
typename
LessThan
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_lower_bound
(
Sequence
&
sequence
const
T
&
value
LessThan
&
&
comp
)
{
return
std
:
:
lower_bound
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
value
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
Sequence
typename
T
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_upper_bound
(
Sequence
&
sequence
const
T
&
value
)
{
return
std
:
:
upper_bound
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
value
)
;
}
template
<
typename
Sequence
typename
T
typename
LessThan
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_upper_bound
(
Sequence
&
sequence
const
T
&
value
LessThan
&
&
comp
)
{
return
std
:
:
upper_bound
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
value
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
Sequence
typename
T
>
container_algorithm_internal
:
:
ContainerIterPairType
<
Sequence
Sequence
>
c_equal_range
(
Sequence
&
sequence
const
T
&
value
)
{
return
std
:
:
equal_range
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
value
)
;
}
template
<
typename
Sequence
typename
T
typename
LessThan
>
container_algorithm_internal
:
:
ContainerIterPairType
<
Sequence
Sequence
>
c_equal_range
(
Sequence
&
sequence
const
T
&
value
LessThan
&
&
comp
)
{
return
std
:
:
equal_range
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
value
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
Sequence
typename
T
>
bool
c_binary_search
(
const
Sequence
&
sequence
const
T
&
value
)
{
return
std
:
:
binary_search
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
value
)
;
}
template
<
typename
Sequence
typename
T
typename
LessThan
>
bool
c_binary_search
(
const
Sequence
&
sequence
const
T
&
value
LessThan
&
&
comp
)
{
return
std
:
:
binary_search
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
value
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C1
typename
C2
typename
OutputIterator
>
OutputIterator
c_merge
(
const
C1
&
c1
const
C2
&
c2
OutputIterator
result
)
{
return
std
:
:
merge
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
result
)
;
}
template
<
typename
C1
typename
C2
typename
OutputIterator
typename
LessThan
>
OutputIterator
c_merge
(
const
C1
&
c1
const
C2
&
c2
OutputIterator
result
LessThan
&
&
comp
)
{
return
std
:
:
merge
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
result
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C
>
void
c_inplace_merge
(
C
&
c
container_algorithm_internal
:
:
ContainerIter
<
C
>
middle
)
{
std
:
:
inplace_merge
(
container_algorithm_internal
:
:
c_begin
(
c
)
middle
container_algorithm_internal
:
:
c_end
(
c
)
)
;
}
template
<
typename
C
typename
LessThan
>
void
c_inplace_merge
(
C
&
c
container_algorithm_internal
:
:
ContainerIter
<
C
>
middle
LessThan
&
&
comp
)
{
std
:
:
inplace_merge
(
container_algorithm_internal
:
:
c_begin
(
c
)
middle
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C1
typename
C2
>
bool
c_includes
(
const
C1
&
c1
const
C2
&
c2
)
{
return
std
:
:
includes
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
)
;
}
template
<
typename
C1
typename
C2
typename
LessThan
>
bool
c_includes
(
const
C1
&
c1
const
C2
&
c2
LessThan
&
&
comp
)
{
return
std
:
:
includes
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C1
typename
C2
typename
OutputIterator
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C1
>
:
:
value
void
>
:
:
type
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C2
>
:
:
value
void
>
:
:
type
>
OutputIterator
c_set_union
(
const
C1
&
c1
const
C2
&
c2
OutputIterator
output
)
{
return
std
:
:
set_union
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
output
)
;
}
template
<
typename
C1
typename
C2
typename
OutputIterator
typename
LessThan
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C1
>
:
:
value
void
>
:
:
type
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C2
>
:
:
value
void
>
:
:
type
>
OutputIterator
c_set_union
(
const
C1
&
c1
const
C2
&
c2
OutputIterator
output
LessThan
&
&
comp
)
{
return
std
:
:
set_union
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
output
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C1
typename
C2
typename
OutputIterator
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C1
>
:
:
value
void
>
:
:
type
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C2
>
:
:
value
void
>
:
:
type
>
OutputIterator
c_set_intersection
(
const
C1
&
c1
const
C2
&
c2
OutputIterator
output
)
{
assert
(
absl
:
:
c_is_sorted
(
c1
)
)
;
assert
(
absl
:
:
c_is_sorted
(
c2
)
)
;
return
std
:
:
set_intersection
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
output
)
;
}
template
<
typename
C1
typename
C2
typename
OutputIterator
typename
LessThan
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C1
>
:
:
value
void
>
:
:
type
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C2
>
:
:
value
void
>
:
:
type
>
OutputIterator
c_set_intersection
(
const
C1
&
c1
const
C2
&
c2
OutputIterator
output
LessThan
&
&
comp
)
{
assert
(
absl
:
:
c_is_sorted
(
c1
comp
)
)
;
assert
(
absl
:
:
c_is_sorted
(
c2
comp
)
)
;
return
std
:
:
set_intersection
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
output
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C1
typename
C2
typename
OutputIterator
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C1
>
:
:
value
void
>
:
:
type
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C2
>
:
:
value
void
>
:
:
type
>
OutputIterator
c_set_difference
(
const
C1
&
c1
const
C2
&
c2
OutputIterator
output
)
{
return
std
:
:
set_difference
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
output
)
;
}
template
<
typename
C1
typename
C2
typename
OutputIterator
typename
LessThan
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C1
>
:
:
value
void
>
:
:
type
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C2
>
:
:
value
void
>
:
:
type
>
OutputIterator
c_set_difference
(
const
C1
&
c1
const
C2
&
c2
OutputIterator
output
LessThan
&
&
comp
)
{
return
std
:
:
set_difference
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
output
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C1
typename
C2
typename
OutputIterator
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C1
>
:
:
value
void
>
:
:
type
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C2
>
:
:
value
void
>
:
:
type
>
OutputIterator
c_set_symmetric_difference
(
const
C1
&
c1
const
C2
&
c2
OutputIterator
output
)
{
return
std
:
:
set_symmetric_difference
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
output
)
;
}
template
<
typename
C1
typename
C2
typename
OutputIterator
typename
LessThan
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C1
>
:
:
value
void
>
:
:
type
typename
=
typename
std
:
:
enable_if
<
!
container_algorithm_internal
:
:
IsUnorderedContainer
<
C2
>
:
:
value
void
>
:
:
type
>
OutputIterator
c_set_symmetric_difference
(
const
C1
&
c1
const
C2
&
c2
OutputIterator
output
LessThan
&
&
comp
)
{
return
std
:
:
set_symmetric_difference
(
container_algorithm_internal
:
:
c_begin
(
c1
)
container_algorithm_internal
:
:
c_end
(
c1
)
container_algorithm_internal
:
:
c_begin
(
c2
)
container_algorithm_internal
:
:
c_end
(
c2
)
output
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
RandomAccessContainer
>
void
c_push_heap
(
RandomAccessContainer
&
sequence
)
{
std
:
:
push_heap
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
RandomAccessContainer
typename
LessThan
>
void
c_push_heap
(
RandomAccessContainer
&
sequence
LessThan
&
&
comp
)
{
std
:
:
push_heap
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
RandomAccessContainer
>
void
c_pop_heap
(
RandomAccessContainer
&
sequence
)
{
std
:
:
pop_heap
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
RandomAccessContainer
typename
LessThan
>
void
c_pop_heap
(
RandomAccessContainer
&
sequence
LessThan
&
&
comp
)
{
std
:
:
pop_heap
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
RandomAccessContainer
>
void
c_make_heap
(
RandomAccessContainer
&
sequence
)
{
std
:
:
make_heap
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
RandomAccessContainer
typename
LessThan
>
void
c_make_heap
(
RandomAccessContainer
&
sequence
LessThan
&
&
comp
)
{
std
:
:
make_heap
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
RandomAccessContainer
>
void
c_sort_heap
(
RandomAccessContainer
&
sequence
)
{
std
:
:
sort_heap
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
RandomAccessContainer
typename
LessThan
>
void
c_sort_heap
(
RandomAccessContainer
&
sequence
LessThan
&
&
comp
)
{
std
:
:
sort_heap
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
RandomAccessContainer
>
bool
c_is_heap
(
const
RandomAccessContainer
&
sequence
)
{
return
std
:
:
is_heap
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
RandomAccessContainer
typename
LessThan
>
bool
c_is_heap
(
const
RandomAccessContainer
&
sequence
LessThan
&
&
comp
)
{
return
std
:
:
is_heap
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
RandomAccessContainer
>
container_algorithm_internal
:
:
ContainerIter
<
RandomAccessContainer
>
c_is_heap_until
(
RandomAccessContainer
&
sequence
)
{
return
std
:
:
is_heap_until
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
RandomAccessContainer
typename
LessThan
>
container_algorithm_internal
:
:
ContainerIter
<
RandomAccessContainer
>
c_is_heap_until
(
RandomAccessContainer
&
sequence
LessThan
&
&
comp
)
{
return
std
:
:
is_heap_until
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
Sequence
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_min_element
(
Sequence
&
sequence
)
{
return
std
:
:
min_element
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
Sequence
typename
LessThan
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_min_element
(
Sequence
&
sequence
LessThan
&
&
comp
)
{
return
std
:
:
min_element
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
Sequence
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_max_element
(
Sequence
&
sequence
)
{
return
std
:
:
max_element
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
)
;
}
template
<
typename
Sequence
typename
LessThan
>
container_algorithm_internal
:
:
ContainerIter
<
Sequence
>
c_max_element
(
Sequence
&
sequence
LessThan
&
&
comp
)
{
return
std
:
:
max_element
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C
>
container_algorithm_internal
:
:
ContainerIterPairType
<
C
C
>
c_minmax_element
(
C
&
c
)
{
return
std
:
:
minmax_element
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
)
;
}
template
<
typename
C
typename
LessThan
>
container_algorithm_internal
:
:
ContainerIterPairType
<
C
C
>
c_minmax_element
(
C
&
c
LessThan
&
&
comp
)
{
return
std
:
:
minmax_element
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
Sequence1
typename
Sequence2
>
bool
c_lexicographical_compare
(
const
Sequence1
&
sequence1
const
Sequence2
&
sequence2
)
{
return
std
:
:
lexicographical_compare
(
container_algorithm_internal
:
:
c_begin
(
sequence1
)
container_algorithm_internal
:
:
c_end
(
sequence1
)
container_algorithm_internal
:
:
c_begin
(
sequence2
)
container_algorithm_internal
:
:
c_end
(
sequence2
)
)
;
}
template
<
typename
Sequence1
typename
Sequence2
typename
LessThan
>
bool
c_lexicographical_compare
(
const
Sequence1
&
sequence1
const
Sequence2
&
sequence2
LessThan
&
&
comp
)
{
return
std
:
:
lexicographical_compare
(
container_algorithm_internal
:
:
c_begin
(
sequence1
)
container_algorithm_internal
:
:
c_end
(
sequence1
)
container_algorithm_internal
:
:
c_begin
(
sequence2
)
container_algorithm_internal
:
:
c_end
(
sequence2
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C
>
bool
c_next_permutation
(
C
&
c
)
{
return
std
:
:
next_permutation
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
)
;
}
template
<
typename
C
typename
LessThan
>
bool
c_next_permutation
(
C
&
c
LessThan
&
&
comp
)
{
return
std
:
:
next_permutation
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
C
>
bool
c_prev_permutation
(
C
&
c
)
{
return
std
:
:
prev_permutation
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
)
;
}
template
<
typename
C
typename
LessThan
>
bool
c_prev_permutation
(
C
&
c
LessThan
&
&
comp
)
{
return
std
:
:
prev_permutation
(
container_algorithm_internal
:
:
c_begin
(
c
)
container_algorithm_internal
:
:
c_end
(
c
)
std
:
:
forward
<
LessThan
>
(
comp
)
)
;
}
template
<
typename
Sequence
typename
T
>
void
c_iota
(
Sequence
&
sequence
const
T
&
value
)
{
std
:
:
iota
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
value
)
;
}
template
<
typename
Sequence
typename
T
>
decay_t
<
T
>
c_accumulate
(
const
Sequence
&
sequence
T
&
&
init
)
{
return
std
:
:
accumulate
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
T
>
(
init
)
)
;
}
template
<
typename
Sequence
typename
T
typename
BinaryOp
>
decay_t
<
T
>
c_accumulate
(
const
Sequence
&
sequence
T
&
&
init
BinaryOp
&
&
binary_op
)
{
return
std
:
:
accumulate
(
container_algorithm_internal
:
:
c_begin
(
sequence
)
container_algorithm_internal
:
:
c_end
(
sequence
)
std
:
:
forward
<
T
>
(
init
)
std
:
:
forward
<
BinaryOp
>
(
binary_op
)
)
;
}
template
<
typename
Sequence1
typename
Sequence2
typename
T
>
decay_t
<
T
>
c_inner_product
(
const
Sequence1
&
factors1
const
Sequence2
&
factors2
T
&
&
sum
)
{
return
std
:
:
inner_product
(
container_algorithm_internal
:
:
c_begin
(
factors1
)
container_algorithm_internal
:
:
c_end
(
factors1
)
container_algorithm_internal
:
:
c_begin
(
factors2
)
std
:
:
forward
<
T
>
(
sum
)
)
;
}
template
<
typename
Sequence1
typename
Sequence2
typename
T
typename
BinaryOp1
typename
BinaryOp2
>
decay_t
<
T
>
c_inner_product
(
const
Sequence1
&
factors1
const
Sequence2
&
factors2
T
&
&
sum
BinaryOp1
&
&
op1
BinaryOp2
&
&
op2
)
{
return
std
:
:
inner_product
(
container_algorithm_internal
:
:
c_begin
(
factors1
)
container_algorithm_internal
:
:
c_end
(
factors1
)
container_algorithm_internal
:
:
c_begin
(
factors2
)
std
:
:
forward
<
T
>
(
sum
)
std
:
:
forward
<
BinaryOp1
>
(
op1
)
std
:
:
forward
<
BinaryOp2
>
(
op2
)
)
;
}
template
<
typename
InputSequence
typename
OutputIt
>
OutputIt
c_adjacent_difference
(
const
InputSequence
&
input
OutputIt
output_first
)
{
return
std
:
:
adjacent_difference
(
container_algorithm_internal
:
:
c_begin
(
input
)
container_algorithm_internal
:
:
c_end
(
input
)
output_first
)
;
}
template
<
typename
InputSequence
typename
OutputIt
typename
BinaryOp
>
OutputIt
c_adjacent_difference
(
const
InputSequence
&
input
OutputIt
output_first
BinaryOp
&
&
op
)
{
return
std
:
:
adjacent_difference
(
container_algorithm_internal
:
:
c_begin
(
input
)
container_algorithm_internal
:
:
c_end
(
input
)
output_first
std
:
:
forward
<
BinaryOp
>
(
op
)
)
;
}
template
<
typename
InputSequence
typename
OutputIt
>
OutputIt
c_partial_sum
(
const
InputSequence
&
input
OutputIt
output_first
)
{
return
std
:
:
partial_sum
(
container_algorithm_internal
:
:
c_begin
(
input
)
container_algorithm_internal
:
:
c_end
(
input
)
output_first
)
;
}
template
<
typename
InputSequence
typename
OutputIt
typename
BinaryOp
>
OutputIt
c_partial_sum
(
const
InputSequence
&
input
OutputIt
output_first
BinaryOp
&
&
op
)
{
return
std
:
:
partial_sum
(
container_algorithm_internal
:
:
c_begin
(
input
)
container_algorithm_internal
:
:
c_end
(
input
)
output_first
std
:
:
forward
<
BinaryOp
>
(
op
)
)
;
}
ABSL_NAMESPACE_END
}
#
endif
