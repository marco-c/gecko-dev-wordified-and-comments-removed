#
ifndef
ABSL_UTILITY_UTILITY_H_
#
define
ABSL_UTILITY_UTILITY_H_
#
include
<
cstddef
>
#
include
<
cstdlib
>
#
include
<
tuple
>
#
include
<
utility
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
inline_variable
.
h
"
#
include
"
absl
/
base
/
internal
/
invoke
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
T
T
.
.
.
Ints
>
struct
integer_sequence
{
using
value_type
=
T
;
static
constexpr
size_t
size
(
)
noexcept
{
return
sizeof
.
.
.
(
Ints
)
;
}
}
;
template
<
size_t
.
.
.
Ints
>
using
index_sequence
=
integer_sequence
<
size_t
Ints
.
.
.
>
;
namespace
utility_internal
{
template
<
typename
Seq
size_t
SeqSize
size_t
Rem
>
struct
Extend
;
template
<
typename
T
T
.
.
.
Ints
size_t
SeqSize
>
struct
Extend
<
integer_sequence
<
T
Ints
.
.
.
>
SeqSize
0
>
{
using
type
=
integer_sequence
<
T
Ints
.
.
.
(
Ints
+
SeqSize
)
.
.
.
>
;
}
;
template
<
typename
T
T
.
.
.
Ints
size_t
SeqSize
>
struct
Extend
<
integer_sequence
<
T
Ints
.
.
.
>
SeqSize
1
>
{
using
type
=
integer_sequence
<
T
Ints
.
.
.
(
Ints
+
SeqSize
)
.
.
.
2
*
SeqSize
>
;
}
;
template
<
typename
T
size_t
N
>
struct
Gen
{
using
type
=
typename
Extend
<
typename
Gen
<
T
N
/
2
>
:
:
type
N
/
2
N
%
2
>
:
:
type
;
}
;
template
<
typename
T
>
struct
Gen
<
T
0
>
{
using
type
=
integer_sequence
<
T
>
;
}
;
template
<
typename
T
>
struct
InPlaceTypeTag
{
explicit
InPlaceTypeTag
(
)
=
delete
;
InPlaceTypeTag
(
const
InPlaceTypeTag
&
)
=
delete
;
InPlaceTypeTag
&
operator
=
(
const
InPlaceTypeTag
&
)
=
delete
;
}
;
template
<
size_t
I
>
struct
InPlaceIndexTag
{
explicit
InPlaceIndexTag
(
)
=
delete
;
InPlaceIndexTag
(
const
InPlaceIndexTag
&
)
=
delete
;
InPlaceIndexTag
&
operator
=
(
const
InPlaceIndexTag
&
)
=
delete
;
}
;
}
template
<
typename
T
T
N
>
using
make_integer_sequence
=
typename
utility_internal
:
:
Gen
<
T
N
>
:
:
type
;
template
<
size_t
N
>
using
make_index_sequence
=
make_integer_sequence
<
size_t
N
>
;
template
<
typename
.
.
.
Ts
>
using
index_sequence_for
=
make_index_sequence
<
sizeof
.
.
.
(
Ts
)
>
;
#
ifdef
ABSL_USES_STD_OPTIONAL
using
std
:
:
in_place_t
;
using
std
:
:
in_place
;
#
else
struct
in_place_t
{
}
;
ABSL_INTERNAL_INLINE_CONSTEXPR
(
in_place_t
in_place
{
}
)
;
#
endif
#
if
defined
(
ABSL_USES_STD_ANY
)
|
|
defined
(
ABSL_USES_STD_VARIANT
)
using
std
:
:
in_place_type
;
using
std
:
:
in_place_type_t
;
#
else
template
<
typename
T
>
using
in_place_type_t
=
void
(
*
)
(
utility_internal
:
:
InPlaceTypeTag
<
T
>
)
;
template
<
typename
T
>
void
in_place_type
(
utility_internal
:
:
InPlaceTypeTag
<
T
>
)
{
}
#
endif
#
ifdef
ABSL_USES_STD_VARIANT
using
std
:
:
in_place_index
;
using
std
:
:
in_place_index_t
;
#
else
template
<
size_t
I
>
using
in_place_index_t
=
void
(
*
)
(
utility_internal
:
:
InPlaceIndexTag
<
I
>
)
;
template
<
size_t
I
>
void
in_place_index
(
utility_internal
:
:
InPlaceIndexTag
<
I
>
)
{
}
#
endif
template
<
typename
T
>
constexpr
absl
:
:
remove_reference_t
<
T
>
&
&
move
(
T
&
&
t
)
noexcept
{
return
static_cast
<
absl
:
:
remove_reference_t
<
T
>
&
&
>
(
t
)
;
}
template
<
typename
T
>
constexpr
T
&
&
forward
(
absl
:
:
remove_reference_t
<
T
>
&
t
)
noexcept
{
return
static_cast
<
T
&
&
>
(
t
)
;
}
namespace
utility_internal
{
template
<
typename
Functor
typename
Tuple
std
:
:
size_t
.
.
.
Indexes
>
auto
apply_helper
(
Functor
&
&
functor
Tuple
&
&
t
index_sequence
<
Indexes
.
.
.
>
)
-
>
decltype
(
absl
:
:
base_internal
:
:
invoke
(
absl
:
:
forward
<
Functor
>
(
functor
)
std
:
:
get
<
Indexes
>
(
absl
:
:
forward
<
Tuple
>
(
t
)
)
.
.
.
)
)
{
return
absl
:
:
base_internal
:
:
invoke
(
absl
:
:
forward
<
Functor
>
(
functor
)
std
:
:
get
<
Indexes
>
(
absl
:
:
forward
<
Tuple
>
(
t
)
)
.
.
.
)
;
}
}
template
<
typename
Functor
typename
Tuple
>
auto
apply
(
Functor
&
&
functor
Tuple
&
&
t
)
-
>
decltype
(
utility_internal
:
:
apply_helper
(
absl
:
:
forward
<
Functor
>
(
functor
)
absl
:
:
forward
<
Tuple
>
(
t
)
absl
:
:
make_index_sequence
<
std
:
:
tuple_size
<
typename
std
:
:
remove_reference
<
Tuple
>
:
:
type
>
:
:
value
>
{
}
)
)
{
return
utility_internal
:
:
apply_helper
(
absl
:
:
forward
<
Functor
>
(
functor
)
absl
:
:
forward
<
Tuple
>
(
t
)
absl
:
:
make_index_sequence
<
std
:
:
tuple_size
<
typename
std
:
:
remove_reference
<
Tuple
>
:
:
type
>
:
:
value
>
{
}
)
;
}
template
<
typename
T
typename
U
=
T
>
T
exchange
(
T
&
obj
U
&
&
new_value
)
{
T
old_value
=
absl
:
:
move
(
obj
)
;
obj
=
absl
:
:
forward
<
U
>
(
new_value
)
;
return
old_value
;
}
namespace
utility_internal
{
template
<
typename
T
typename
Tuple
size_t
.
.
.
I
>
T
make_from_tuple_impl
(
Tuple
&
&
tup
absl
:
:
index_sequence
<
I
.
.
.
>
)
{
return
T
(
std
:
:
get
<
I
>
(
std
:
:
forward
<
Tuple
>
(
tup
)
)
.
.
.
)
;
}
}
template
<
typename
T
typename
Tuple
>
constexpr
T
make_from_tuple
(
Tuple
&
&
tup
)
{
return
utility_internal
:
:
make_from_tuple_impl
<
T
>
(
std
:
:
forward
<
Tuple
>
(
tup
)
absl
:
:
make_index_sequence
<
std
:
:
tuple_size
<
absl
:
:
decay_t
<
Tuple
>
>
:
:
value
>
{
}
)
;
}
ABSL_NAMESPACE_END
}
#
endif
