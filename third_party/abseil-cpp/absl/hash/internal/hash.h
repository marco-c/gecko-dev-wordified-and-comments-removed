#
ifndef
ABSL_HASH_INTERNAL_HASH_H_
#
define
ABSL_HASH_INTERNAL_HASH_H_
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
bitset
>
#
include
<
cmath
>
#
include
<
cstddef
>
#
include
<
cstring
>
#
include
<
deque
>
#
include
<
forward_list
>
#
include
<
functional
>
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
list
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
string
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
unaligned_access
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
include
"
absl
/
container
/
fixed_array
.
h
"
#
include
"
absl
/
hash
/
internal
/
city
.
h
"
#
include
"
absl
/
hash
/
internal
/
low_level_hash
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
numeric
/
bits
.
h
"
#
include
"
absl
/
numeric
/
int128
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
absl
/
types
/
variant
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
#
ifdef
ABSL_HAVE_STD_STRING_VIEW
#
include
<
string_view
>
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
class
HashState
;
namespace
hash_internal
{
constexpr
size_t
PiecewiseChunkSize
(
)
{
return
1024
;
}
class
PiecewiseCombiner
{
public
:
PiecewiseCombiner
(
)
:
position_
(
0
)
{
}
PiecewiseCombiner
(
const
PiecewiseCombiner
&
)
=
delete
;
PiecewiseCombiner
&
operator
=
(
const
PiecewiseCombiner
&
)
=
delete
;
template
<
typename
H
>
H
add_buffer
(
H
state
const
unsigned
char
*
data
size_t
size
)
;
template
<
typename
H
>
H
add_buffer
(
H
state
const
char
*
data
size_t
size
)
{
return
add_buffer
(
std
:
:
move
(
state
)
reinterpret_cast
<
const
unsigned
char
*
>
(
data
)
size
)
;
}
template
<
typename
H
>
H
finalize
(
H
state
)
;
private
:
unsigned
char
buf_
[
PiecewiseChunkSize
(
)
]
;
size_t
position_
;
}
;
template
<
typename
T
>
struct
is_hashable
;
template
<
typename
H
>
class
HashStateBase
{
public
:
template
<
typename
T
typename
.
.
.
Ts
>
static
H
combine
(
H
state
const
T
&
value
const
Ts
&
.
.
.
values
)
;
static
H
combine
(
H
state
)
{
return
state
;
}
template
<
typename
T
>
static
H
combine_contiguous
(
H
state
const
T
*
data
size_t
size
)
;
template
<
typename
I
>
static
H
combine_unordered
(
H
state
I
begin
I
end
)
;
using
AbslInternalPiecewiseCombiner
=
PiecewiseCombiner
;
template
<
typename
T
>
using
is_hashable
=
absl
:
:
hash_internal
:
:
is_hashable
<
T
>
;
private
:
template
<
typename
I
>
struct
CombineUnorderedCallback
{
I
begin
;
I
end
;
template
<
typename
InnerH
typename
ElementStateConsumer
>
void
operator
(
)
(
InnerH
inner_state
ElementStateConsumer
cb
)
{
for
(
;
begin
!
=
end
;
+
+
begin
)
{
inner_state
=
H
:
:
combine
(
std
:
:
move
(
inner_state
)
*
begin
)
;
cb
(
inner_state
)
;
}
}
}
;
}
;
template
<
typename
T
typename
Enable
=
void
>
struct
is_uniquely_represented
:
std
:
:
false_type
{
}
;
template
<
>
struct
is_uniquely_represented
<
unsigned
char
>
:
std
:
:
true_type
{
}
;
template
<
typename
Integral
>
struct
is_uniquely_represented
<
Integral
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
Integral
>
:
:
value
>
:
:
type
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
is_uniquely_represented
<
bool
>
:
std
:
:
false_type
{
}
;
template
<
typename
H
typename
T
>
H
hash_bytes
(
H
hash_state
const
T
&
value
)
{
const
unsigned
char
*
start
=
reinterpret_cast
<
const
unsigned
char
*
>
(
&
value
)
;
return
H
:
:
combine_contiguous
(
std
:
:
move
(
hash_state
)
start
sizeof
(
value
)
)
;
}
template
<
typename
H
typename
B
>
typename
std
:
:
enable_if
<
std
:
:
is_same
<
B
bool
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
B
value
)
{
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
static_cast
<
unsigned
char
>
(
value
?
1
:
0
)
)
;
}
template
<
typename
H
typename
Enum
>
typename
std
:
:
enable_if
<
std
:
:
is_enum
<
Enum
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
Enum
e
)
{
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
static_cast
<
typename
std
:
:
underlying_type
<
Enum
>
:
:
type
>
(
e
)
)
;
}
template
<
typename
H
typename
Float
>
typename
std
:
:
enable_if
<
std
:
:
is_same
<
Float
float
>
:
:
value
|
|
std
:
:
is_same
<
Float
double
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
Float
value
)
{
return
hash_internal
:
:
hash_bytes
(
std
:
:
move
(
hash_state
)
value
=
=
0
?
0
:
value
)
;
}
template
<
typename
H
typename
LongDouble
>
typename
std
:
:
enable_if
<
std
:
:
is_same
<
LongDouble
long
double
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
LongDouble
value
)
{
const
int
category
=
std
:
:
fpclassify
(
value
)
;
switch
(
category
)
{
case
FP_INFINITE
:
hash_state
=
H
:
:
combine
(
std
:
:
move
(
hash_state
)
std
:
:
signbit
(
value
)
)
;
break
;
case
FP_NAN
:
case
FP_ZERO
:
default
:
break
;
case
FP_NORMAL
:
case
FP_SUBNORMAL
:
int
exp
;
auto
mantissa
=
static_cast
<
double
>
(
std
:
:
frexp
(
value
&
exp
)
)
;
hash_state
=
H
:
:
combine
(
std
:
:
move
(
hash_state
)
mantissa
exp
)
;
}
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
category
)
;
}
template
<
typename
H
typename
T
size_t
N
>
H
AbslHashValue
(
H
hash_state
T
(
&
)
[
N
]
)
{
static_assert
(
sizeof
(
T
)
=
=
-
1
"
Hashing
C
arrays
is
not
allowed
.
For
string
literals
wrap
the
literal
"
"
in
absl
:
:
string_view
(
)
.
To
hash
the
array
contents
use
"
"
absl
:
:
MakeSpan
(
)
or
make
the
array
an
std
:
:
array
.
To
hash
the
array
"
"
address
use
&
array
[
0
]
.
"
)
;
return
hash_state
;
}
template
<
typename
H
typename
T
>
std
:
:
enable_if_t
<
std
:
:
is_pointer
<
T
>
:
:
value
H
>
AbslHashValue
(
H
hash_state
T
ptr
)
{
auto
v
=
reinterpret_cast
<
uintptr_t
>
(
ptr
)
;
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
v
v
)
;
}
template
<
typename
H
>
H
AbslHashValue
(
H
hash_state
std
:
:
nullptr_t
)
{
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
static_cast
<
void
*
>
(
nullptr
)
)
;
}
template
<
typename
H
typename
T
typename
C
>
H
AbslHashValue
(
H
hash_state
T
C
:
:
*
ptr
)
{
auto
salient_ptm_size
=
[
]
(
std
:
:
size_t
n
)
-
>
std
:
:
size_t
{
#
if
defined
(
_MSC_VER
)
if
(
alignof
(
T
C
:
:
*
)
=
=
alignof
(
int
)
)
{
return
n
;
}
else
{
return
n
=
=
24
?
20
:
n
=
=
16
?
12
:
n
;
}
#
else
#
ifdef
__cpp_lib_has_unique_object_representations
static_assert
(
std
:
:
has_unique_object_representations
<
T
C
:
:
*
>
:
:
value
)
;
#
endif
return
n
;
#
endif
}
;
return
H
:
:
combine_contiguous
(
std
:
:
move
(
hash_state
)
reinterpret_cast
<
unsigned
char
*
>
(
&
ptr
)
salient_ptm_size
(
sizeof
ptr
)
)
;
}
template
<
typename
H
typename
T1
typename
T2
>
typename
std
:
:
enable_if
<
is_hashable
<
T1
>
:
:
value
&
&
is_hashable
<
T2
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
pair
<
T1
T2
>
&
p
)
{
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
p
.
first
p
.
second
)
;
}
template
<
typename
H
typename
Tuple
size_t
.
.
.
Is
>
H
hash_tuple
(
H
hash_state
const
Tuple
&
t
absl
:
:
index_sequence
<
Is
.
.
.
>
)
{
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
std
:
:
get
<
Is
>
(
t
)
.
.
.
)
;
}
template
<
typename
H
typename
.
.
.
Ts
>
#
if
defined
(
_MSC_VER
)
H
#
else
typename
std
:
:
enable_if
<
absl
:
:
conjunction
<
is_hashable
<
Ts
>
.
.
.
>
:
:
value
H
>
:
:
type
#
endif
AbslHashValue
(
H
hash_state
const
std
:
:
tuple
<
Ts
.
.
.
>
&
t
)
{
return
hash_internal
:
:
hash_tuple
(
std
:
:
move
(
hash_state
)
t
absl
:
:
make_index_sequence
<
sizeof
.
.
.
(
Ts
)
>
(
)
)
;
}
template
<
typename
H
typename
T
typename
D
>
H
AbslHashValue
(
H
hash_state
const
std
:
:
unique_ptr
<
T
D
>
&
ptr
)
{
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
ptr
.
get
(
)
)
;
}
template
<
typename
H
typename
T
>
H
AbslHashValue
(
H
hash_state
const
std
:
:
shared_ptr
<
T
>
&
ptr
)
{
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
ptr
.
get
(
)
)
;
}
template
<
typename
H
>
H
AbslHashValue
(
H
hash_state
absl
:
:
string_view
str
)
{
return
H
:
:
combine
(
H
:
:
combine_contiguous
(
std
:
:
move
(
hash_state
)
str
.
data
(
)
str
.
size
(
)
)
str
.
size
(
)
)
;
}
template
<
typename
Char
typename
Alloc
typename
H
typename
=
absl
:
:
enable_if_t
<
std
:
:
is_same
<
Char
wchar_t
>
:
:
value
|
|
std
:
:
is_same
<
Char
char16_t
>
:
:
value
|
|
std
:
:
is_same
<
Char
char32_t
>
:
:
value
>
>
H
AbslHashValue
(
H
hash_state
const
std
:
:
basic_string
<
Char
std
:
:
char_traits
<
Char
>
Alloc
>
&
str
)
{
return
H
:
:
combine
(
H
:
:
combine_contiguous
(
std
:
:
move
(
hash_state
)
str
.
data
(
)
str
.
size
(
)
)
str
.
size
(
)
)
;
}
#
ifdef
ABSL_HAVE_STD_STRING_VIEW
template
<
typename
Char
typename
H
typename
=
absl
:
:
enable_if_t
<
std
:
:
is_same
<
Char
wchar_t
>
:
:
value
|
|
std
:
:
is_same
<
Char
char16_t
>
:
:
value
|
|
std
:
:
is_same
<
Char
char32_t
>
:
:
value
>
>
H
AbslHashValue
(
H
hash_state
std
:
:
basic_string_view
<
Char
>
str
)
{
return
H
:
:
combine
(
H
:
:
combine_contiguous
(
std
:
:
move
(
hash_state
)
str
.
data
(
)
str
.
size
(
)
)
str
.
size
(
)
)
;
}
#
endif
template
<
typename
H
typename
T
size_t
N
>
typename
std
:
:
enable_if
<
is_hashable
<
T
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
array
<
T
N
>
&
array
)
{
return
H
:
:
combine_contiguous
(
std
:
:
move
(
hash_state
)
array
.
data
(
)
array
.
size
(
)
)
;
}
template
<
typename
H
typename
T
typename
Allocator
>
typename
std
:
:
enable_if
<
is_hashable
<
T
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
deque
<
T
Allocator
>
&
deque
)
{
for
(
const
auto
&
t
:
deque
)
{
hash_state
=
H
:
:
combine
(
std
:
:
move
(
hash_state
)
t
)
;
}
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
deque
.
size
(
)
)
;
}
template
<
typename
H
typename
T
typename
Allocator
>
typename
std
:
:
enable_if
<
is_hashable
<
T
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
forward_list
<
T
Allocator
>
&
list
)
{
size_t
size
=
0
;
for
(
const
T
&
t
:
list
)
{
hash_state
=
H
:
:
combine
(
std
:
:
move
(
hash_state
)
t
)
;
+
+
size
;
}
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
size
)
;
}
template
<
typename
H
typename
T
typename
Allocator
>
typename
std
:
:
enable_if
<
is_hashable
<
T
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
list
<
T
Allocator
>
&
list
)
{
for
(
const
auto
&
t
:
list
)
{
hash_state
=
H
:
:
combine
(
std
:
:
move
(
hash_state
)
t
)
;
}
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
list
.
size
(
)
)
;
}
template
<
typename
H
typename
T
typename
Allocator
>
typename
std
:
:
enable_if
<
is_hashable
<
T
>
:
:
value
&
&
!
std
:
:
is_same
<
T
bool
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
vector
<
T
Allocator
>
&
vector
)
{
return
H
:
:
combine
(
H
:
:
combine_contiguous
(
std
:
:
move
(
hash_state
)
vector
.
data
(
)
vector
.
size
(
)
)
vector
.
size
(
)
)
;
}
#
if
defined
(
ABSL_IS_BIG_ENDIAN
)
&
&
\
(
defined
(
__GLIBCXX__
)
|
|
defined
(
__GLIBCPP__
)
)
template
<
typename
H
typename
T
typename
Allocator
>
typename
std
:
:
enable_if
<
is_hashable
<
T
>
:
:
value
&
&
std
:
:
is_same
<
T
bool
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
vector
<
T
Allocator
>
&
vector
)
{
typename
H
:
:
AbslInternalPiecewiseCombiner
combiner
;
for
(
const
auto
&
i
:
vector
)
{
unsigned
char
c
=
static_cast
<
unsigned
char
>
(
i
)
;
hash_state
=
combiner
.
add_buffer
(
std
:
:
move
(
hash_state
)
&
c
sizeof
(
c
)
)
;
}
return
H
:
:
combine
(
combiner
.
finalize
(
std
:
:
move
(
hash_state
)
)
vector
.
size
(
)
)
;
}
#
else
template
<
typename
H
typename
T
typename
Allocator
>
typename
std
:
:
enable_if
<
is_hashable
<
T
>
:
:
value
&
&
std
:
:
is_same
<
T
bool
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
vector
<
T
Allocator
>
&
vector
)
{
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
std
:
:
hash
<
std
:
:
vector
<
T
Allocator
>
>
{
}
(
vector
)
vector
.
size
(
)
)
;
}
#
endif
template
<
typename
H
typename
Key
typename
T
typename
Compare
typename
Allocator
>
typename
std
:
:
enable_if
<
is_hashable
<
Key
>
:
:
value
&
&
is_hashable
<
T
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
map
<
Key
T
Compare
Allocator
>
&
map
)
{
for
(
const
auto
&
t
:
map
)
{
hash_state
=
H
:
:
combine
(
std
:
:
move
(
hash_state
)
t
)
;
}
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
map
.
size
(
)
)
;
}
template
<
typename
H
typename
Key
typename
T
typename
Compare
typename
Allocator
>
typename
std
:
:
enable_if
<
is_hashable
<
Key
>
:
:
value
&
&
is_hashable
<
T
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
multimap
<
Key
T
Compare
Allocator
>
&
map
)
{
for
(
const
auto
&
t
:
map
)
{
hash_state
=
H
:
:
combine
(
std
:
:
move
(
hash_state
)
t
)
;
}
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
map
.
size
(
)
)
;
}
template
<
typename
H
typename
Key
typename
Compare
typename
Allocator
>
typename
std
:
:
enable_if
<
is_hashable
<
Key
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
set
<
Key
Compare
Allocator
>
&
set
)
{
for
(
const
auto
&
t
:
set
)
{
hash_state
=
H
:
:
combine
(
std
:
:
move
(
hash_state
)
t
)
;
}
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
set
.
size
(
)
)
;
}
template
<
typename
H
typename
Key
typename
Compare
typename
Allocator
>
typename
std
:
:
enable_if
<
is_hashable
<
Key
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
multiset
<
Key
Compare
Allocator
>
&
set
)
{
for
(
const
auto
&
t
:
set
)
{
hash_state
=
H
:
:
combine
(
std
:
:
move
(
hash_state
)
t
)
;
}
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
set
.
size
(
)
)
;
}
template
<
typename
H
typename
Key
typename
Hash
typename
KeyEqual
typename
Alloc
>
typename
std
:
:
enable_if
<
is_hashable
<
Key
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
unordered_set
<
Key
Hash
KeyEqual
Alloc
>
&
s
)
{
return
H
:
:
combine
(
H
:
:
combine_unordered
(
std
:
:
move
(
hash_state
)
s
.
begin
(
)
s
.
end
(
)
)
s
.
size
(
)
)
;
}
template
<
typename
H
typename
Key
typename
Hash
typename
KeyEqual
typename
Alloc
>
typename
std
:
:
enable_if
<
is_hashable
<
Key
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
unordered_multiset
<
Key
Hash
KeyEqual
Alloc
>
&
s
)
{
return
H
:
:
combine
(
H
:
:
combine_unordered
(
std
:
:
move
(
hash_state
)
s
.
begin
(
)
s
.
end
(
)
)
s
.
size
(
)
)
;
}
template
<
typename
H
typename
Key
typename
T
typename
Hash
typename
KeyEqual
typename
Alloc
>
typename
std
:
:
enable_if
<
is_hashable
<
Key
>
:
:
value
&
&
is_hashable
<
T
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
unordered_map
<
Key
T
Hash
KeyEqual
Alloc
>
&
s
)
{
return
H
:
:
combine
(
H
:
:
combine_unordered
(
std
:
:
move
(
hash_state
)
s
.
begin
(
)
s
.
end
(
)
)
s
.
size
(
)
)
;
}
template
<
typename
H
typename
Key
typename
T
typename
Hash
typename
KeyEqual
typename
Alloc
>
typename
std
:
:
enable_if
<
is_hashable
<
Key
>
:
:
value
&
&
is_hashable
<
T
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
std
:
:
unordered_multimap
<
Key
T
Hash
KeyEqual
Alloc
>
&
s
)
{
return
H
:
:
combine
(
H
:
:
combine_unordered
(
std
:
:
move
(
hash_state
)
s
.
begin
(
)
s
.
end
(
)
)
s
.
size
(
)
)
;
}
template
<
typename
H
typename
T
>
typename
std
:
:
enable_if
<
is_hashable
<
T
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
std
:
:
reference_wrapper
<
T
>
opt
)
{
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
opt
.
get
(
)
)
;
}
template
<
typename
H
typename
T
>
typename
std
:
:
enable_if
<
is_hashable
<
T
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
absl
:
:
optional
<
T
>
&
opt
)
{
if
(
opt
)
hash_state
=
H
:
:
combine
(
std
:
:
move
(
hash_state
)
*
opt
)
;
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
opt
.
has_value
(
)
)
;
}
template
<
typename
H
>
struct
VariantVisitor
{
H
&
&
hash_state
;
template
<
typename
T
>
H
operator
(
)
(
const
T
&
t
)
const
{
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
t
)
;
}
}
;
template
<
typename
H
typename
.
.
.
T
>
typename
std
:
:
enable_if
<
conjunction
<
is_hashable
<
T
>
.
.
.
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
hash_state
const
absl
:
:
variant
<
T
.
.
.
>
&
v
)
{
if
(
!
v
.
valueless_by_exception
(
)
)
{
hash_state
=
absl
:
:
visit
(
VariantVisitor
<
H
>
{
std
:
:
move
(
hash_state
)
}
v
)
;
}
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
v
.
index
(
)
)
;
}
#
if
defined
(
ABSL_IS_BIG_ENDIAN
)
&
&
\
(
defined
(
__GLIBCXX__
)
|
|
defined
(
__GLIBCPP__
)
)
template
<
typename
H
size_t
N
>
H
AbslHashValue
(
H
hash_state
const
std
:
:
bitset
<
N
>
&
set
)
{
typename
H
:
:
AbslInternalPiecewiseCombiner
combiner
;
for
(
size_t
i
=
0
;
i
<
N
;
i
+
+
)
{
unsigned
char
c
=
static_cast
<
unsigned
char
>
(
set
[
i
]
)
;
hash_state
=
combiner
.
add_buffer
(
std
:
:
move
(
hash_state
)
&
c
sizeof
(
c
)
)
;
}
return
H
:
:
combine
(
combiner
.
finalize
(
std
:
:
move
(
hash_state
)
)
N
)
;
}
#
endif
template
<
typename
H
typename
T
>
typename
std
:
:
enable_if
<
is_uniquely_represented
<
T
>
:
:
value
H
>
:
:
type
hash_range_or_bytes
(
H
hash_state
const
T
*
data
size_t
size
)
{
const
auto
*
bytes
=
reinterpret_cast
<
const
unsigned
char
*
>
(
data
)
;
return
H
:
:
combine_contiguous
(
std
:
:
move
(
hash_state
)
bytes
sizeof
(
T
)
*
size
)
;
}
template
<
typename
H
typename
T
>
typename
std
:
:
enable_if
<
!
is_uniquely_represented
<
T
>
:
:
value
H
>
:
:
type
hash_range_or_bytes
(
H
hash_state
const
T
*
data
size_t
size
)
{
for
(
const
auto
end
=
data
+
size
;
data
<
end
;
+
+
data
)
{
hash_state
=
H
:
:
combine
(
std
:
:
move
(
hash_state
)
*
data
)
;
}
return
hash_state
;
}
#
if
defined
(
ABSL_INTERNAL_LEGACY_HASH_NAMESPACE
)
&
&
\
ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
#
define
ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
1
#
else
#
define
ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
0
#
endif
struct
HashSelect
{
private
:
struct
State
:
HashStateBase
<
State
>
{
static
State
combine_contiguous
(
State
hash_state
const
unsigned
char
*
size_t
)
;
using
State
:
:
HashStateBase
:
:
combine_contiguous
;
}
;
struct
UniquelyRepresentedProbe
{
template
<
typename
H
typename
T
>
static
auto
Invoke
(
H
state
const
T
&
value
)
-
>
absl
:
:
enable_if_t
<
is_uniquely_represented
<
T
>
:
:
value
H
>
{
return
hash_internal
:
:
hash_bytes
(
std
:
:
move
(
state
)
value
)
;
}
}
;
struct
HashValueProbe
{
template
<
typename
H
typename
T
>
static
auto
Invoke
(
H
state
const
T
&
value
)
-
>
absl
:
:
enable_if_t
<
std
:
:
is_same
<
H
decltype
(
AbslHashValue
(
std
:
:
move
(
state
)
value
)
)
>
:
:
value
H
>
{
return
AbslHashValue
(
std
:
:
move
(
state
)
value
)
;
}
}
;
struct
LegacyHashProbe
{
#
if
ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
template
<
typename
H
typename
T
>
static
auto
Invoke
(
H
state
const
T
&
value
)
-
>
absl
:
:
enable_if_t
<
std
:
:
is_convertible
<
decltype
(
ABSL_INTERNAL_LEGACY_HASH_NAMESPACE
:
:
hash
<
T
>
(
)
(
value
)
)
size_t
>
:
:
value
H
>
{
return
hash_internal
:
:
hash_bytes
(
std
:
:
move
(
state
)
ABSL_INTERNAL_LEGACY_HASH_NAMESPACE
:
:
hash
<
T
>
{
}
(
value
)
)
;
}
#
endif
}
;
struct
StdHashProbe
{
template
<
typename
H
typename
T
>
static
auto
Invoke
(
H
state
const
T
&
value
)
-
>
absl
:
:
enable_if_t
<
type_traits_internal
:
:
IsHashable
<
T
>
:
:
value
H
>
{
return
hash_internal
:
:
hash_bytes
(
std
:
:
move
(
state
)
std
:
:
hash
<
T
>
{
}
(
value
)
)
;
}
}
;
template
<
typename
Hash
typename
T
>
struct
Probe
:
Hash
{
private
:
template
<
typename
H
typename
=
decltype
(
H
:
:
Invoke
(
std
:
:
declval
<
State
>
(
)
std
:
:
declval
<
const
T
&
>
(
)
)
)
>
static
std
:
:
true_type
Test
(
int
)
;
template
<
typename
U
>
static
std
:
:
false_type
Test
(
char
)
;
public
:
static
constexpr
bool
value
=
decltype
(
Test
<
Hash
>
(
0
)
)
:
:
value
;
}
;
public
:
template
<
typename
T
>
using
Apply
=
absl
:
:
disjunction
<
Probe
<
UniquelyRepresentedProbe
T
>
Probe
<
HashValueProbe
T
>
Probe
<
LegacyHashProbe
T
>
Probe
<
StdHashProbe
T
>
std
:
:
false_type
>
;
}
;
template
<
typename
T
>
struct
is_hashable
:
std
:
:
integral_constant
<
bool
HashSelect
:
:
template
Apply
<
T
>
:
:
value
>
{
}
;
class
ABSL_DLL
MixingHashState
:
public
HashStateBase
<
MixingHashState
>
{
#
ifdef
ABSL_HAVE_INTRINSIC_INT128
using
uint128
=
__uint128_t
;
#
else
using
uint128
=
absl
:
:
uint128
;
#
endif
static
constexpr
uint64_t
kMul
=
sizeof
(
size_t
)
=
=
4
?
uint64_t
{
0xcc9e2d51
}
:
uint64_t
{
0x9ddfea08eb382d69
}
;
template
<
typename
T
>
using
IntegralFastPath
=
conjunction
<
std
:
:
is_integral
<
T
>
is_uniquely_represented
<
T
>
>
;
public
:
MixingHashState
(
MixingHashState
&
&
)
=
default
;
MixingHashState
&
operator
=
(
MixingHashState
&
&
)
=
default
;
static
MixingHashState
combine_contiguous
(
MixingHashState
hash_state
const
unsigned
char
*
first
size_t
size
)
{
return
MixingHashState
(
CombineContiguousImpl
(
hash_state
.
state_
first
size
std
:
:
integral_constant
<
int
sizeof
(
size_t
)
>
{
}
)
)
;
}
using
MixingHashState
:
:
HashStateBase
:
:
combine_contiguous
;
template
<
typename
T
absl
:
:
enable_if_t
<
IntegralFastPath
<
T
>
:
:
value
int
>
=
0
>
static
size_t
hash
(
T
value
)
{
return
static_cast
<
size_t
>
(
Mix
(
Seed
(
)
static_cast
<
std
:
:
make_unsigned_t
<
T
>
>
(
value
)
)
)
;
}
template
<
typename
T
absl
:
:
enable_if_t
<
!
IntegralFastPath
<
T
>
:
:
value
int
>
=
0
>
static
size_t
hash
(
const
T
&
value
)
{
return
static_cast
<
size_t
>
(
combine
(
MixingHashState
{
}
value
)
.
state_
)
;
}
private
:
MixingHashState
(
)
:
state_
(
Seed
(
)
)
{
}
friend
class
MixingHashState
:
:
HashStateBase
;
template
<
typename
CombinerT
>
static
MixingHashState
RunCombineUnordered
(
MixingHashState
state
CombinerT
combiner
)
{
uint64_t
unordered_state
=
0
;
combiner
(
MixingHashState
{
}
[
&
]
(
MixingHashState
&
inner_state
)
{
auto
element_state
=
inner_state
.
state_
;
unordered_state
+
=
element_state
;
if
(
unordered_state
<
element_state
)
{
+
+
unordered_state
;
}
inner_state
=
MixingHashState
{
}
;
}
)
;
return
MixingHashState
:
:
combine
(
std
:
:
move
(
state
)
unordered_state
)
;
}
friend
class
absl
:
:
HashState
;
MixingHashState
(
const
MixingHashState
&
)
=
default
;
explicit
MixingHashState
(
uint64_t
state
)
:
state_
(
state
)
{
}
static
uint64_t
CombineContiguousImpl
(
uint64_t
state
const
unsigned
char
*
first
size_t
len
std
:
:
integral_constant
<
int
4
>
)
;
static
uint64_t
CombineContiguousImpl
(
uint64_t
state
const
unsigned
char
*
first
size_t
len
std
:
:
integral_constant
<
int
8
>
)
;
static
uint64_t
CombineLargeContiguousImpl32
(
uint64_t
state
const
unsigned
char
*
first
size_t
len
)
;
static
uint64_t
CombineLargeContiguousImpl64
(
uint64_t
state
const
unsigned
char
*
first
size_t
len
)
;
static
std
:
:
pair
<
uint64_t
uint64_t
>
Read9To16
(
const
unsigned
char
*
p
size_t
len
)
{
uint64_t
low_mem
=
absl
:
:
base_internal
:
:
UnalignedLoad64
(
p
)
;
uint64_t
high_mem
=
absl
:
:
base_internal
:
:
UnalignedLoad64
(
p
+
len
-
8
)
;
#
ifdef
ABSL_IS_LITTLE_ENDIAN
uint64_t
most_significant
=
high_mem
;
uint64_t
least_significant
=
low_mem
;
#
else
uint64_t
most_significant
=
low_mem
;
uint64_t
least_significant
=
high_mem
;
#
endif
return
{
least_significant
most_significant
}
;
}
static
uint64_t
Read4To8
(
const
unsigned
char
*
p
size_t
len
)
{
uint32_t
low_mem
=
absl
:
:
base_internal
:
:
UnalignedLoad32
(
p
)
;
uint32_t
high_mem
=
absl
:
:
base_internal
:
:
UnalignedLoad32
(
p
+
len
-
4
)
;
#
ifdef
ABSL_IS_LITTLE_ENDIAN
uint32_t
most_significant
=
high_mem
;
uint32_t
least_significant
=
low_mem
;
#
else
uint32_t
most_significant
=
low_mem
;
uint32_t
least_significant
=
high_mem
;
#
endif
return
(
static_cast
<
uint64_t
>
(
most_significant
)
<
<
(
len
-
4
)
*
8
)
|
least_significant
;
}
static
uint32_t
Read1To3
(
const
unsigned
char
*
p
size_t
len
)
{
unsigned
char
mem0
=
p
[
0
]
;
unsigned
char
mem1
=
p
[
len
/
2
]
;
unsigned
char
mem2
=
p
[
len
-
1
]
;
#
ifdef
ABSL_IS_LITTLE_ENDIAN
unsigned
char
significant2
=
mem2
;
unsigned
char
significant1
=
mem1
;
unsigned
char
significant0
=
mem0
;
#
else
unsigned
char
significant2
=
mem0
;
unsigned
char
significant1
=
len
=
=
2
?
mem0
:
mem1
;
unsigned
char
significant0
=
mem2
;
#
endif
return
static_cast
<
uint32_t
>
(
significant0
|
(
significant1
<
<
(
len
/
2
*
8
)
)
|
(
significant2
<
<
(
(
len
-
1
)
*
8
)
)
)
;
}
ABSL_ATTRIBUTE_ALWAYS_INLINE
static
uint64_t
Mix
(
uint64_t
state
uint64_t
v
)
{
using
MultType
=
absl
:
:
conditional_t
<
sizeof
(
size_t
)
=
=
4
uint64_t
uint128
>
;
MultType
m
=
state
+
v
;
m
*
=
kMul
;
return
static_cast
<
uint64_t
>
(
m
^
(
m
>
>
(
sizeof
(
m
)
*
8
/
2
)
)
)
;
}
static
uint64_t
LowLevelHashImpl
(
const
unsigned
char
*
data
size_t
len
)
;
ABSL_ATTRIBUTE_ALWAYS_INLINE
static
uint64_t
Hash64
(
const
unsigned
char
*
data
size_t
len
)
{
#
ifdef
ABSL_HAVE_INTRINSIC_INT128
return
LowLevelHashImpl
(
data
len
)
;
#
else
return
hash_internal
:
:
CityHash64
(
reinterpret_cast
<
const
char
*
>
(
data
)
len
)
;
#
endif
}
ABSL_ATTRIBUTE_ALWAYS_INLINE
static
uint64_t
Seed
(
)
{
#
if
(
!
defined
(
__clang__
)
|
|
__clang_major__
>
11
)
&
&
\
(
!
defined
(
__apple_build_version__
)
|
|
\
__apple_build_version__
>
=
19558921
)
return
static_cast
<
uint64_t
>
(
reinterpret_cast
<
uintptr_t
>
(
&
kSeed
)
)
;
#
else
return
static_cast
<
uint64_t
>
(
reinterpret_cast
<
uintptr_t
>
(
kSeed
)
)
;
#
endif
}
static
const
void
*
const
kSeed
;
uint64_t
state_
;
}
;
inline
uint64_t
MixingHashState
:
:
CombineContiguousImpl
(
uint64_t
state
const
unsigned
char
*
first
size_t
len
std
:
:
integral_constant
<
int
4
>
)
{
uint64_t
v
;
if
(
len
>
8
)
{
if
(
ABSL_PREDICT_FALSE
(
len
>
PiecewiseChunkSize
(
)
)
)
{
return
CombineLargeContiguousImpl32
(
state
first
len
)
;
}
v
=
hash_internal
:
:
CityHash32
(
reinterpret_cast
<
const
char
*
>
(
first
)
len
)
;
}
else
if
(
len
>
=
4
)
{
v
=
Read4To8
(
first
len
)
;
}
else
if
(
len
>
0
)
{
v
=
Read1To3
(
first
len
)
;
}
else
{
return
state
;
}
return
Mix
(
state
v
)
;
}
inline
uint64_t
MixingHashState
:
:
CombineContiguousImpl
(
uint64_t
state
const
unsigned
char
*
first
size_t
len
std
:
:
integral_constant
<
int
8
>
)
{
uint64_t
v
;
if
(
len
>
16
)
{
if
(
ABSL_PREDICT_FALSE
(
len
>
PiecewiseChunkSize
(
)
)
)
{
return
CombineLargeContiguousImpl64
(
state
first
len
)
;
}
v
=
Hash64
(
first
len
)
;
}
else
if
(
len
>
8
)
{
auto
p
=
Read9To16
(
first
len
)
;
uint64_t
lo
=
p
.
first
;
uint64_t
hi
=
p
.
second
;
lo
=
absl
:
:
rotr
(
lo
53
)
;
state
+
=
kMul
;
lo
+
=
state
;
state
^
=
hi
;
uint128
m
=
state
;
m
*
=
lo
;
return
static_cast
<
uint64_t
>
(
m
^
(
m
>
>
64
)
)
;
}
else
if
(
len
>
=
4
)
{
v
=
Read4To8
(
first
len
)
;
}
else
if
(
len
>
0
)
{
v
=
Read1To3
(
first
len
)
;
}
else
{
return
state
;
}
return
Mix
(
state
v
)
;
}
struct
AggregateBarrier
{
}
;
struct
PoisonedHash
:
private
AggregateBarrier
{
PoisonedHash
(
)
=
delete
;
PoisonedHash
(
const
PoisonedHash
&
)
=
delete
;
PoisonedHash
&
operator
=
(
const
PoisonedHash
&
)
=
delete
;
}
;
template
<
typename
T
>
struct
HashImpl
{
size_t
operator
(
)
(
const
T
&
value
)
const
{
return
MixingHashState
:
:
hash
(
value
)
;
}
}
;
template
<
typename
T
>
struct
Hash
:
absl
:
:
conditional_t
<
is_hashable
<
T
>
:
:
value
HashImpl
<
T
>
PoisonedHash
>
{
}
;
template
<
typename
H
>
template
<
typename
T
typename
.
.
.
Ts
>
H
HashStateBase
<
H
>
:
:
combine
(
H
state
const
T
&
value
const
Ts
&
.
.
.
values
)
{
return
H
:
:
combine
(
hash_internal
:
:
HashSelect
:
:
template
Apply
<
T
>
:
:
Invoke
(
std
:
:
move
(
state
)
value
)
values
.
.
.
)
;
}
template
<
typename
H
>
template
<
typename
T
>
H
HashStateBase
<
H
>
:
:
combine_contiguous
(
H
state
const
T
*
data
size_t
size
)
{
return
hash_internal
:
:
hash_range_or_bytes
(
std
:
:
move
(
state
)
data
size
)
;
}
template
<
typename
H
>
template
<
typename
I
>
H
HashStateBase
<
H
>
:
:
combine_unordered
(
H
state
I
begin
I
end
)
{
return
H
:
:
RunCombineUnordered
(
std
:
:
move
(
state
)
CombineUnorderedCallback
<
I
>
{
begin
end
}
)
;
}
template
<
typename
H
>
H
PiecewiseCombiner
:
:
add_buffer
(
H
state
const
unsigned
char
*
data
size_t
size
)
{
if
(
position_
+
size
<
PiecewiseChunkSize
(
)
)
{
memcpy
(
buf_
+
position_
data
size
)
;
position_
+
=
size
;
return
state
;
}
if
(
position_
!
=
0
)
{
const
size_t
bytes_needed
=
PiecewiseChunkSize
(
)
-
position_
;
memcpy
(
buf_
+
position_
data
bytes_needed
)
;
state
=
H
:
:
combine_contiguous
(
std
:
:
move
(
state
)
buf_
PiecewiseChunkSize
(
)
)
;
data
+
=
bytes_needed
;
size
-
=
bytes_needed
;
}
while
(
size
>
=
PiecewiseChunkSize
(
)
)
{
state
=
H
:
:
combine_contiguous
(
std
:
:
move
(
state
)
data
PiecewiseChunkSize
(
)
)
;
data
+
=
PiecewiseChunkSize
(
)
;
size
-
=
PiecewiseChunkSize
(
)
;
}
memcpy
(
buf_
data
size
)
;
position_
=
size
;
return
state
;
}
template
<
typename
H
>
H
PiecewiseCombiner
:
:
finalize
(
H
state
)
{
return
H
:
:
combine_contiguous
(
std
:
:
move
(
state
)
buf_
position_
)
;
}
}
ABSL_NAMESPACE_END
}
#
endif
