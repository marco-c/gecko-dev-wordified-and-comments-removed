#
include
"
absl
/
strings
/
str_cat
.
h
"
#
include
<
assert
.
h
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
initializer_list
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
nullability
.
h
"
#
include
"
absl
/
strings
/
internal
/
resize_uninitialized
.
h
"
#
include
"
absl
/
strings
/
numbers
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
{
absl
:
:
Nonnull
<
char
*
>
Append
(
absl
:
:
Nonnull
<
char
*
>
out
const
AlphaNum
&
x
)
{
char
*
after
=
out
+
x
.
size
(
)
;
if
(
x
.
size
(
)
!
=
0
)
{
memcpy
(
out
x
.
data
(
)
x
.
size
(
)
)
;
}
return
after
;
}
}
std
:
:
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
)
{
std
:
:
string
result
;
absl
:
:
strings_internal
:
:
STLStringResizeUninitialized
(
&
result
a
.
size
(
)
+
b
.
size
(
)
)
;
char
*
const
begin
=
&
result
[
0
]
;
char
*
out
=
begin
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
assert
(
out
=
=
begin
+
result
.
size
(
)
)
;
return
result
;
}
std
:
:
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
)
{
std
:
:
string
result
;
strings_internal
:
:
STLStringResizeUninitialized
(
&
result
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
)
;
char
*
const
begin
=
&
result
[
0
]
;
char
*
out
=
begin
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
out
=
Append
(
out
c
)
;
assert
(
out
=
=
begin
+
result
.
size
(
)
)
;
return
result
;
}
std
:
:
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
)
{
std
:
:
string
result
;
strings_internal
:
:
STLStringResizeUninitialized
(
&
result
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
+
d
.
size
(
)
)
;
char
*
const
begin
=
&
result
[
0
]
;
char
*
out
=
begin
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
out
=
Append
(
out
c
)
;
out
=
Append
(
out
d
)
;
assert
(
out
=
=
begin
+
result
.
size
(
)
)
;
return
result
;
}
namespace
strings_internal
{
void
STLStringAppendUninitializedAmortized
(
std
:
:
string
*
dest
size_t
to_append
)
{
strings_internal
:
:
AppendUninitializedTraits
<
std
:
:
string
>
:
:
Append
(
dest
to_append
)
;
}
template
<
typename
Integer
>
std
:
:
enable_if_t
<
std
:
:
is_integral
<
Integer
>
:
:
value
std
:
:
string
>
IntegerToString
(
Integer
i
)
{
std
:
:
string
str
;
const
auto
is_negative
=
absl
:
:
numbers_internal
:
:
IsNegative
(
i
)
;
const
uint32_t
digits
=
absl
:
:
numbers_internal
:
:
Base10Digits
(
absl
:
:
numbers_internal
:
:
UnsignedAbsoluteValue
(
i
)
)
;
absl
:
:
strings_internal
:
:
STLStringResizeUninitialized
(
&
str
digits
+
static_cast
<
uint32_t
>
(
is_negative
)
)
;
absl
:
:
numbers_internal
:
:
FastIntToBufferBackward
(
i
&
str
[
str
.
size
(
)
]
digits
)
;
return
str
;
}
template
<
>
std
:
:
string
IntegerToString
(
long
i
)
{
if
(
sizeof
(
i
)
<
=
sizeof
(
int
)
)
{
return
IntegerToString
(
static_cast
<
int
>
(
i
)
)
;
}
else
{
return
IntegerToString
(
static_cast
<
long
long
>
(
i
)
)
;
}
}
template
<
>
std
:
:
string
IntegerToString
(
unsigned
long
i
)
{
if
(
sizeof
(
i
)
<
=
sizeof
(
unsigned
int
)
)
{
return
IntegerToString
(
static_cast
<
unsigned
int
>
(
i
)
)
;
}
else
{
return
IntegerToString
(
static_cast
<
unsigned
long
long
>
(
i
)
)
;
}
}
template
<
typename
Float
>
std
:
:
enable_if_t
<
std
:
:
is_floating_point
<
Float
>
:
:
value
std
:
:
string
>
FloatToString
(
Float
f
)
{
std
:
:
string
result
;
strings_internal
:
:
STLStringResizeUninitialized
(
&
result
numbers_internal
:
:
kSixDigitsToBufferSize
)
;
char
*
start
=
&
result
[
0
]
;
result
.
erase
(
numbers_internal
:
:
SixDigitsToBuffer
(
f
start
)
)
;
return
result
;
}
std
:
:
string
SingleArgStrCat
(
int
x
)
{
return
IntegerToString
(
x
)
;
}
std
:
:
string
SingleArgStrCat
(
unsigned
int
x
)
{
return
IntegerToString
(
x
)
;
}
std
:
:
string
SingleArgStrCat
(
long
x
)
{
return
IntegerToString
(
x
)
;
}
std
:
:
string
SingleArgStrCat
(
unsigned
long
x
)
{
return
IntegerToString
(
x
)
;
}
std
:
:
string
SingleArgStrCat
(
long
long
x
)
{
return
IntegerToString
(
x
)
;
}
std
:
:
string
SingleArgStrCat
(
unsigned
long
long
x
)
{
return
IntegerToString
(
x
)
;
}
std
:
:
string
SingleArgStrCat
(
float
x
)
{
return
FloatToString
(
x
)
;
}
std
:
:
string
SingleArgStrCat
(
double
x
)
{
return
FloatToString
(
x
)
;
}
template
<
class
Integer
>
std
:
:
enable_if_t
<
std
:
:
is_integral
<
Integer
>
:
:
value
void
>
AppendIntegerToString
(
std
:
:
string
&
str
Integer
i
)
{
const
auto
is_negative
=
absl
:
:
numbers_internal
:
:
IsNegative
(
i
)
;
const
uint32_t
digits
=
absl
:
:
numbers_internal
:
:
Base10Digits
(
absl
:
:
numbers_internal
:
:
UnsignedAbsoluteValue
(
i
)
)
;
absl
:
:
strings_internal
:
:
STLStringAppendUninitializedAmortized
(
&
str
digits
+
static_cast
<
uint32_t
>
(
is_negative
)
)
;
absl
:
:
numbers_internal
:
:
FastIntToBufferBackward
(
i
&
str
[
str
.
size
(
)
]
digits
)
;
}
template
<
>
void
AppendIntegerToString
(
std
:
:
string
&
str
long
i
)
{
if
(
sizeof
(
i
)
<
=
sizeof
(
int
)
)
{
return
AppendIntegerToString
(
str
static_cast
<
int
>
(
i
)
)
;
}
else
{
return
AppendIntegerToString
(
str
static_cast
<
long
long
>
(
i
)
)
;
}
}
template
<
>
void
AppendIntegerToString
(
std
:
:
string
&
str
unsigned
long
i
)
{
if
(
sizeof
(
i
)
<
=
sizeof
(
unsigned
int
)
)
{
return
AppendIntegerToString
(
str
static_cast
<
unsigned
int
>
(
i
)
)
;
}
else
{
return
AppendIntegerToString
(
str
static_cast
<
unsigned
long
long
>
(
i
)
)
;
}
}
void
SingleArgStrAppend
(
std
:
:
string
&
str
int
x
)
{
return
AppendIntegerToString
(
str
x
)
;
}
void
SingleArgStrAppend
(
std
:
:
string
&
str
unsigned
int
x
)
{
return
AppendIntegerToString
(
str
x
)
;
}
void
SingleArgStrAppend
(
std
:
:
string
&
str
long
x
)
{
return
AppendIntegerToString
(
str
x
)
;
}
void
SingleArgStrAppend
(
std
:
:
string
&
str
unsigned
long
x
)
{
return
AppendIntegerToString
(
str
x
)
;
}
void
SingleArgStrAppend
(
std
:
:
string
&
str
long
long
x
)
{
return
AppendIntegerToString
(
str
x
)
;
}
void
SingleArgStrAppend
(
std
:
:
string
&
str
unsigned
long
long
x
)
{
return
AppendIntegerToString
(
str
x
)
;
}
std
:
:
string
CatPieces
(
std
:
:
initializer_list
<
absl
:
:
string_view
>
pieces
)
{
std
:
:
string
result
;
size_t
total_size
=
0
;
for
(
absl
:
:
string_view
piece
:
pieces
)
total_size
+
=
piece
.
size
(
)
;
strings_internal
:
:
STLStringResizeUninitialized
(
&
result
total_size
)
;
char
*
const
begin
=
&
result
[
0
]
;
char
*
out
=
begin
;
for
(
absl
:
:
string_view
piece
:
pieces
)
{
const
size_t
this_size
=
piece
.
size
(
)
;
if
(
this_size
!
=
0
)
{
memcpy
(
out
piece
.
data
(
)
this_size
)
;
out
+
=
this_size
;
}
}
assert
(
out
=
=
begin
+
result
.
size
(
)
)
;
return
result
;
}
#
define
ASSERT_NO_OVERLAP
(
dest
src
)
\
assert
(
(
(
src
)
.
size
(
)
=
=
0
)
|
|
\
(
uintptr_t
(
(
src
)
.
data
(
)
-
(
dest
)
.
data
(
)
)
>
uintptr_t
(
(
dest
)
.
size
(
)
)
)
)
void
AppendPieces
(
absl
:
:
Nonnull
<
std
:
:
string
*
>
dest
std
:
:
initializer_list
<
absl
:
:
string_view
>
pieces
)
{
size_t
old_size
=
dest
-
>
size
(
)
;
size_t
to_append
=
0
;
for
(
absl
:
:
string_view
piece
:
pieces
)
{
ASSERT_NO_OVERLAP
(
*
dest
piece
)
;
to_append
+
=
piece
.
size
(
)
;
}
strings_internal
:
:
STLStringAppendUninitializedAmortized
(
dest
to_append
)
;
char
*
const
begin
=
&
(
*
dest
)
[
0
]
;
char
*
out
=
begin
+
old_size
;
for
(
absl
:
:
string_view
piece
:
pieces
)
{
const
size_t
this_size
=
piece
.
size
(
)
;
if
(
this_size
!
=
0
)
{
memcpy
(
out
piece
.
data
(
)
this_size
)
;
out
+
=
this_size
;
}
}
assert
(
out
=
=
begin
+
dest
-
>
size
(
)
)
;
}
}
void
StrAppend
(
absl
:
:
Nonnull
<
std
:
:
string
*
>
dest
const
AlphaNum
&
a
)
{
ASSERT_NO_OVERLAP
(
*
dest
a
)
;
std
:
:
string
:
:
size_type
old_size
=
dest
-
>
size
(
)
;
strings_internal
:
:
STLStringAppendUninitializedAmortized
(
dest
a
.
size
(
)
)
;
char
*
const
begin
=
&
(
*
dest
)
[
0
]
;
char
*
out
=
begin
+
old_size
;
out
=
Append
(
out
a
)
;
assert
(
out
=
=
begin
+
dest
-
>
size
(
)
)
;
}
void
StrAppend
(
absl
:
:
Nonnull
<
std
:
:
string
*
>
dest
const
AlphaNum
&
a
const
AlphaNum
&
b
)
{
ASSERT_NO_OVERLAP
(
*
dest
a
)
;
ASSERT_NO_OVERLAP
(
*
dest
b
)
;
std
:
:
string
:
:
size_type
old_size
=
dest
-
>
size
(
)
;
strings_internal
:
:
STLStringAppendUninitializedAmortized
(
dest
a
.
size
(
)
+
b
.
size
(
)
)
;
char
*
const
begin
=
&
(
*
dest
)
[
0
]
;
char
*
out
=
begin
+
old_size
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
assert
(
out
=
=
begin
+
dest
-
>
size
(
)
)
;
}
void
StrAppend
(
absl
:
:
Nonnull
<
std
:
:
string
*
>
dest
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
)
{
ASSERT_NO_OVERLAP
(
*
dest
a
)
;
ASSERT_NO_OVERLAP
(
*
dest
b
)
;
ASSERT_NO_OVERLAP
(
*
dest
c
)
;
std
:
:
string
:
:
size_type
old_size
=
dest
-
>
size
(
)
;
strings_internal
:
:
STLStringAppendUninitializedAmortized
(
dest
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
)
;
char
*
const
begin
=
&
(
*
dest
)
[
0
]
;
char
*
out
=
begin
+
old_size
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
out
=
Append
(
out
c
)
;
assert
(
out
=
=
begin
+
dest
-
>
size
(
)
)
;
}
void
StrAppend
(
absl
:
:
Nonnull
<
std
:
:
string
*
>
dest
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
)
{
ASSERT_NO_OVERLAP
(
*
dest
a
)
;
ASSERT_NO_OVERLAP
(
*
dest
b
)
;
ASSERT_NO_OVERLAP
(
*
dest
c
)
;
ASSERT_NO_OVERLAP
(
*
dest
d
)
;
std
:
:
string
:
:
size_type
old_size
=
dest
-
>
size
(
)
;
strings_internal
:
:
STLStringAppendUninitializedAmortized
(
dest
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
+
d
.
size
(
)
)
;
char
*
const
begin
=
&
(
*
dest
)
[
0
]
;
char
*
out
=
begin
+
old_size
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
out
=
Append
(
out
c
)
;
out
=
Append
(
out
d
)
;
assert
(
out
=
=
begin
+
dest
-
>
size
(
)
)
;
}
ABSL_NAMESPACE_END
}
