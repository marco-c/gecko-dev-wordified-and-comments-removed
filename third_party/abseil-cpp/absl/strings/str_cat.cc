#
include
"
absl
/
strings
/
str_cat
.
h
"
#
include
<
assert
.
h
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
initializer_list
>
#
include
<
limits
>
#
include
<
string
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
base
/
nullability
.
h
"
#
include
"
absl
/
strings
/
internal
/
resize_uninitialized
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
{
inline
absl
:
:
Nonnull
<
char
*
>
Append
(
absl
:
:
Nonnull
<
char
*
>
out
const
AlphaNum
&
x
)
{
char
*
after
=
out
+
x
.
size
(
)
;
if
(
x
.
size
(
)
!
=
0
)
{
memcpy
(
out
x
.
data
(
)
x
.
size
(
)
)
;
}
return
after
;
}
inline
void
STLStringAppendUninitializedAmortized
(
std
:
:
string
*
dest
size_t
to_append
)
{
strings_internal
:
:
AppendUninitializedTraits
<
std
:
:
string
>
:
:
Append
(
dest
to_append
)
;
}
}
std
:
:
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
)
{
std
:
:
string
result
;
constexpr
uint64_t
kMaxSize
=
uint64_t
{
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
}
;
const
uint64_t
result_size
=
static_cast
<
uint64_t
>
(
a
.
size
(
)
)
+
static_cast
<
uint64_t
>
(
b
.
size
(
)
)
;
ABSL_INTERNAL_CHECK
(
result_size
<
=
kMaxSize
"
size_t
overflow
"
)
;
absl
:
:
strings_internal
:
:
STLStringResizeUninitialized
(
&
result
static_cast
<
size_t
>
(
result_size
)
)
;
char
*
const
begin
=
&
result
[
0
]
;
char
*
out
=
begin
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
assert
(
out
=
=
begin
+
result
.
size
(
)
)
;
return
result
;
}
std
:
:
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
)
{
std
:
:
string
result
;
constexpr
uint64_t
kMaxSize
=
uint64_t
{
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
}
;
const
uint64_t
result_size
=
static_cast
<
uint64_t
>
(
a
.
size
(
)
)
+
static_cast
<
uint64_t
>
(
b
.
size
(
)
)
+
static_cast
<
uint64_t
>
(
c
.
size
(
)
)
;
ABSL_INTERNAL_CHECK
(
result_size
<
=
kMaxSize
"
size_t
overflow
"
)
;
strings_internal
:
:
STLStringResizeUninitialized
(
&
result
static_cast
<
size_t
>
(
result_size
)
)
;
char
*
const
begin
=
&
result
[
0
]
;
char
*
out
=
begin
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
out
=
Append
(
out
c
)
;
assert
(
out
=
=
begin
+
result
.
size
(
)
)
;
return
result
;
}
std
:
:
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
)
{
std
:
:
string
result
;
constexpr
uint64_t
kMaxSize
=
uint64_t
{
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
}
;
const
uint64_t
result_size
=
static_cast
<
uint64_t
>
(
a
.
size
(
)
)
+
static_cast
<
uint64_t
>
(
b
.
size
(
)
)
+
static_cast
<
uint64_t
>
(
c
.
size
(
)
)
+
static_cast
<
uint64_t
>
(
d
.
size
(
)
)
;
ABSL_INTERNAL_CHECK
(
result_size
<
=
kMaxSize
"
size_t
overflow
"
)
;
strings_internal
:
:
STLStringResizeUninitialized
(
&
result
static_cast
<
size_t
>
(
result_size
)
)
;
char
*
const
begin
=
&
result
[
0
]
;
char
*
out
=
begin
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
out
=
Append
(
out
c
)
;
out
=
Append
(
out
d
)
;
assert
(
out
=
=
begin
+
result
.
size
(
)
)
;
return
result
;
}
namespace
strings_internal
{
std
:
:
string
CatPieces
(
std
:
:
initializer_list
<
absl
:
:
string_view
>
pieces
)
{
std
:
:
string
result
;
constexpr
uint64_t
kMaxSize
=
uint64_t
{
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
}
;
uint64_t
total_size
=
0
;
for
(
absl
:
:
string_view
piece
:
pieces
)
{
total_size
+
=
piece
.
size
(
)
;
}
ABSL_INTERNAL_CHECK
(
total_size
<
=
kMaxSize
"
size_t
overflow
"
)
;
strings_internal
:
:
STLStringResizeUninitialized
(
&
result
static_cast
<
size_t
>
(
total_size
)
)
;
char
*
const
begin
=
&
result
[
0
]
;
char
*
out
=
begin
;
for
(
absl
:
:
string_view
piece
:
pieces
)
{
const
size_t
this_size
=
piece
.
size
(
)
;
if
(
this_size
!
=
0
)
{
memcpy
(
out
piece
.
data
(
)
this_size
)
;
out
+
=
this_size
;
}
}
assert
(
out
=
=
begin
+
result
.
size
(
)
)
;
return
result
;
}
#
define
ASSERT_NO_OVERLAP
(
dest
src
)
\
assert
(
(
(
src
)
.
size
(
)
=
=
0
)
|
|
\
(
uintptr_t
(
(
src
)
.
data
(
)
-
(
dest
)
.
data
(
)
)
>
uintptr_t
(
(
dest
)
.
size
(
)
)
)
)
void
AppendPieces
(
absl
:
:
Nonnull
<
std
:
:
string
*
>
dest
std
:
:
initializer_list
<
absl
:
:
string_view
>
pieces
)
{
size_t
old_size
=
dest
-
>
size
(
)
;
size_t
to_append
=
0
;
for
(
absl
:
:
string_view
piece
:
pieces
)
{
ASSERT_NO_OVERLAP
(
*
dest
piece
)
;
to_append
+
=
piece
.
size
(
)
;
}
STLStringAppendUninitializedAmortized
(
dest
to_append
)
;
char
*
const
begin
=
&
(
*
dest
)
[
0
]
;
char
*
out
=
begin
+
old_size
;
for
(
absl
:
:
string_view
piece
:
pieces
)
{
const
size_t
this_size
=
piece
.
size
(
)
;
if
(
this_size
!
=
0
)
{
memcpy
(
out
piece
.
data
(
)
this_size
)
;
out
+
=
this_size
;
}
}
assert
(
out
=
=
begin
+
dest
-
>
size
(
)
)
;
}
}
void
StrAppend
(
absl
:
:
Nonnull
<
std
:
:
string
*
>
dest
const
AlphaNum
&
a
)
{
ASSERT_NO_OVERLAP
(
*
dest
a
)
;
std
:
:
string
:
:
size_type
old_size
=
dest
-
>
size
(
)
;
STLStringAppendUninitializedAmortized
(
dest
a
.
size
(
)
)
;
char
*
const
begin
=
&
(
*
dest
)
[
0
]
;
char
*
out
=
begin
+
old_size
;
out
=
Append
(
out
a
)
;
assert
(
out
=
=
begin
+
dest
-
>
size
(
)
)
;
}
void
StrAppend
(
absl
:
:
Nonnull
<
std
:
:
string
*
>
dest
const
AlphaNum
&
a
const
AlphaNum
&
b
)
{
ASSERT_NO_OVERLAP
(
*
dest
a
)
;
ASSERT_NO_OVERLAP
(
*
dest
b
)
;
std
:
:
string
:
:
size_type
old_size
=
dest
-
>
size
(
)
;
STLStringAppendUninitializedAmortized
(
dest
a
.
size
(
)
+
b
.
size
(
)
)
;
char
*
const
begin
=
&
(
*
dest
)
[
0
]
;
char
*
out
=
begin
+
old_size
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
assert
(
out
=
=
begin
+
dest
-
>
size
(
)
)
;
}
void
StrAppend
(
absl
:
:
Nonnull
<
std
:
:
string
*
>
dest
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
)
{
ASSERT_NO_OVERLAP
(
*
dest
a
)
;
ASSERT_NO_OVERLAP
(
*
dest
b
)
;
ASSERT_NO_OVERLAP
(
*
dest
c
)
;
std
:
:
string
:
:
size_type
old_size
=
dest
-
>
size
(
)
;
STLStringAppendUninitializedAmortized
(
dest
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
)
;
char
*
const
begin
=
&
(
*
dest
)
[
0
]
;
char
*
out
=
begin
+
old_size
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
out
=
Append
(
out
c
)
;
assert
(
out
=
=
begin
+
dest
-
>
size
(
)
)
;
}
void
StrAppend
(
absl
:
:
Nonnull
<
std
:
:
string
*
>
dest
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
)
{
ASSERT_NO_OVERLAP
(
*
dest
a
)
;
ASSERT_NO_OVERLAP
(
*
dest
b
)
;
ASSERT_NO_OVERLAP
(
*
dest
c
)
;
ASSERT_NO_OVERLAP
(
*
dest
d
)
;
std
:
:
string
:
:
size_type
old_size
=
dest
-
>
size
(
)
;
STLStringAppendUninitializedAmortized
(
dest
a
.
size
(
)
+
b
.
size
(
)
+
c
.
size
(
)
+
d
.
size
(
)
)
;
char
*
const
begin
=
&
(
*
dest
)
[
0
]
;
char
*
out
=
begin
+
old_size
;
out
=
Append
(
out
a
)
;
out
=
Append
(
out
b
)
;
out
=
Append
(
out
c
)
;
out
=
Append
(
out
d
)
;
assert
(
out
=
=
begin
+
dest
-
>
size
(
)
)
;
}
ABSL_NAMESPACE_END
}
