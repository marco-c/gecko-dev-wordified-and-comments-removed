#
ifndef
ABSL_STRINGS_INTERNAL_STR_FORMAT_PARSER_H_
#
define
ABSL_STRINGS_INTERNAL_STR_FORMAT_PARSER_H_
#
include
<
stddef
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
cassert
>
#
include
<
cstring
>
#
include
<
initializer_list
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
strings
/
internal
/
str_format
/
checker
.
h
"
#
include
"
absl
/
strings
/
internal
/
str_format
/
constexpr_parser
.
h
"
#
include
"
absl
/
strings
/
internal
/
str_format
/
extension
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
str_format_internal
{
std
:
:
string
LengthModToString
(
LengthMod
v
)
;
const
char
*
ConsumeUnboundConversionNoInline
(
const
char
*
p
const
char
*
end
UnboundConversion
*
conv
int
*
next_arg
)
;
template
<
typename
Consumer
>
bool
ParseFormatString
(
string_view
src
Consumer
consumer
)
{
int
next_arg
=
0
;
const
char
*
p
=
src
.
data
(
)
;
const
char
*
const
end
=
p
+
src
.
size
(
)
;
while
(
p
!
=
end
)
{
const
char
*
percent
=
static_cast
<
const
char
*
>
(
memchr
(
p
'
%
'
static_cast
<
size_t
>
(
end
-
p
)
)
)
;
if
(
!
percent
)
{
return
consumer
.
Append
(
string_view
(
p
static_cast
<
size_t
>
(
end
-
p
)
)
)
;
}
if
(
ABSL_PREDICT_FALSE
(
!
consumer
.
Append
(
string_view
(
p
static_cast
<
size_t
>
(
percent
-
p
)
)
)
)
)
{
return
false
;
}
if
(
ABSL_PREDICT_FALSE
(
percent
+
1
>
=
end
)
)
return
false
;
auto
tag
=
GetTagForChar
(
percent
[
1
]
)
;
if
(
tag
.
is_conv
(
)
)
{
if
(
ABSL_PREDICT_FALSE
(
next_arg
<
0
)
)
{
return
false
;
}
p
=
percent
+
2
;
UnboundConversion
conv
;
conv
.
conv
=
tag
.
as_conv
(
)
;
conv
.
arg_position
=
+
+
next_arg
;
if
(
ABSL_PREDICT_FALSE
(
!
consumer
.
ConvertOne
(
conv
string_view
(
percent
+
1
1
)
)
)
)
{
return
false
;
}
}
else
if
(
percent
[
1
]
!
=
'
%
'
)
{
UnboundConversion
conv
;
p
=
ConsumeUnboundConversionNoInline
(
percent
+
1
end
&
conv
&
next_arg
)
;
if
(
ABSL_PREDICT_FALSE
(
p
=
=
nullptr
)
)
return
false
;
if
(
ABSL_PREDICT_FALSE
(
!
consumer
.
ConvertOne
(
conv
string_view
(
percent
+
1
static_cast
<
size_t
>
(
p
-
(
percent
+
1
)
)
)
)
)
)
{
return
false
;
}
}
else
{
if
(
ABSL_PREDICT_FALSE
(
!
consumer
.
Append
(
"
%
"
)
)
)
return
false
;
p
=
percent
+
2
;
continue
;
}
}
return
true
;
}
constexpr
bool
EnsureConstexpr
(
string_view
s
)
{
return
s
.
empty
(
)
|
|
s
[
0
]
=
=
s
[
0
]
;
}
class
ParsedFormatBase
{
public
:
explicit
ParsedFormatBase
(
string_view
format
bool
allow_ignored
std
:
:
initializer_list
<
FormatConversionCharSet
>
convs
)
;
ParsedFormatBase
(
const
ParsedFormatBase
&
other
)
{
*
this
=
other
;
}
ParsedFormatBase
(
ParsedFormatBase
&
&
other
)
{
*
this
=
std
:
:
move
(
other
)
;
}
ParsedFormatBase
&
operator
=
(
const
ParsedFormatBase
&
other
)
{
if
(
this
=
=
&
other
)
return
*
this
;
has_error_
=
other
.
has_error_
;
items_
=
other
.
items_
;
size_t
text_size
=
items_
.
empty
(
)
?
0
:
items_
.
back
(
)
.
text_end
;
data_
=
std
:
:
make_unique
<
char
[
]
>
(
text_size
)
;
if
(
text_size
>
0
)
{
memcpy
(
data_
.
get
(
)
other
.
data_
.
get
(
)
text_size
)
;
}
return
*
this
;
}
ParsedFormatBase
&
operator
=
(
ParsedFormatBase
&
&
other
)
{
if
(
this
=
=
&
other
)
return
*
this
;
has_error_
=
other
.
has_error_
;
data_
=
std
:
:
move
(
other
.
data_
)
;
items_
=
std
:
:
move
(
other
.
items_
)
;
other
.
items_
.
clear
(
)
;
return
*
this
;
}
template
<
typename
Consumer
>
bool
ProcessFormat
(
Consumer
consumer
)
const
{
const
char
*
const
base
=
data_
.
get
(
)
;
string_view
text
(
base
0
)
;
for
(
const
auto
&
item
:
items_
)
{
const
char
*
const
end
=
text
.
data
(
)
+
text
.
size
(
)
;
text
=
string_view
(
end
static_cast
<
size_t
>
(
(
base
+
item
.
text_end
)
-
end
)
)
;
if
(
item
.
is_conversion
)
{
if
(
!
consumer
.
ConvertOne
(
item
.
conv
text
)
)
return
false
;
}
else
{
if
(
!
consumer
.
Append
(
text
)
)
return
false
;
}
}
return
!
has_error_
;
}
bool
has_error
(
)
const
{
return
has_error_
;
}
private
:
bool
MatchesConversions
(
bool
allow_ignored
std
:
:
initializer_list
<
FormatConversionCharSet
>
convs
)
const
;
struct
ParsedFormatConsumer
;
struct
ConversionItem
{
bool
is_conversion
;
size_t
text_end
;
UnboundConversion
conv
;
}
;
bool
has_error_
;
std
:
:
unique_ptr
<
char
[
]
>
data_
;
std
:
:
vector
<
ConversionItem
>
items_
;
}
;
template
<
FormatConversionCharSet
.
.
.
C
>
class
ExtendedParsedFormat
:
public
str_format_internal
:
:
ParsedFormatBase
{
public
:
explicit
ExtendedParsedFormat
(
string_view
format
)
#
ifdef
ABSL_INTERNAL_ENABLE_FORMAT_CHECKER
__attribute__
(
(
enable_if
(
str_format_internal
:
:
EnsureConstexpr
(
format
)
"
Format
string
is
not
constexpr
.
"
)
enable_if
(
str_format_internal
:
:
ValidFormatImpl
<
C
.
.
.
>
(
format
)
"
Format
specified
does
not
match
the
template
arguments
.
"
)
)
)
#
endif
:
ExtendedParsedFormat
(
format
false
)
{
}
static
std
:
:
unique_ptr
<
ExtendedParsedFormat
>
New
(
string_view
format
)
{
return
New
(
format
false
)
;
}
static
std
:
:
unique_ptr
<
ExtendedParsedFormat
>
NewAllowIgnored
(
string_view
format
)
{
return
New
(
format
true
)
;
}
private
:
static
std
:
:
unique_ptr
<
ExtendedParsedFormat
>
New
(
string_view
format
bool
allow_ignored
)
{
std
:
:
unique_ptr
<
ExtendedParsedFormat
>
conv
(
new
ExtendedParsedFormat
(
format
allow_ignored
)
)
;
if
(
conv
-
>
has_error
(
)
)
return
nullptr
;
return
conv
;
}
ExtendedParsedFormat
(
string_view
s
bool
allow_ignored
)
:
ParsedFormatBase
(
s
allow_ignored
{
C
.
.
.
}
)
{
}
}
;
}
ABSL_NAMESPACE_END
}
#
endif
