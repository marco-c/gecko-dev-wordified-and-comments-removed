#
include
"
absl
/
strings
/
internal
/
cordz_handle
.
h
"
#
include
<
atomic
>
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
synchronization
/
mutex
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
cord_internal
{
namespace
{
struct
Queue
{
Queue
(
)
=
default
;
absl
:
:
Mutex
mutex
;
std
:
:
atomic
<
CordzHandle
*
>
dq_tail
ABSL_GUARDED_BY
(
mutex
)
{
nullptr
}
;
bool
IsEmpty
(
)
const
ABSL_NO_THREAD_SAFETY_ANALYSIS
{
return
dq_tail
.
load
(
std
:
:
memory_order_acquire
)
=
=
nullptr
;
}
}
;
static
Queue
*
GlobalQueue
(
)
{
static
Queue
*
global_queue
=
new
Queue
;
return
global_queue
;
}
}
CordzHandle
:
:
CordzHandle
(
bool
is_snapshot
)
:
is_snapshot_
(
is_snapshot
)
{
Queue
*
global_queue
=
GlobalQueue
(
)
;
if
(
is_snapshot
)
{
MutexLock
lock
(
&
global_queue
-
>
mutex
)
;
CordzHandle
*
dq_tail
=
global_queue
-
>
dq_tail
.
load
(
std
:
:
memory_order_acquire
)
;
if
(
dq_tail
!
=
nullptr
)
{
dq_prev_
=
dq_tail
;
dq_tail
-
>
dq_next_
=
this
;
}
global_queue
-
>
dq_tail
.
store
(
this
std
:
:
memory_order_release
)
;
}
}
CordzHandle
:
:
~
CordzHandle
(
)
{
Queue
*
global_queue
=
GlobalQueue
(
)
;
if
(
is_snapshot_
)
{
std
:
:
vector
<
CordzHandle
*
>
to_delete
;
{
MutexLock
lock
(
&
global_queue
-
>
mutex
)
;
CordzHandle
*
next
=
dq_next_
;
if
(
dq_prev_
=
=
nullptr
)
{
while
(
next
&
&
!
next
-
>
is_snapshot_
)
{
to_delete
.
push_back
(
next
)
;
next
=
next
-
>
dq_next_
;
}
}
else
{
dq_prev_
-
>
dq_next_
=
next
;
}
if
(
next
)
{
next
-
>
dq_prev_
=
dq_prev_
;
}
else
{
global_queue
-
>
dq_tail
.
store
(
dq_prev_
std
:
:
memory_order_release
)
;
}
}
for
(
CordzHandle
*
handle
:
to_delete
)
{
delete
handle
;
}
}
}
bool
CordzHandle
:
:
SafeToDelete
(
)
const
{
return
is_snapshot_
|
|
GlobalQueue
(
)
-
>
IsEmpty
(
)
;
}
void
CordzHandle
:
:
Delete
(
CordzHandle
*
handle
)
{
assert
(
handle
)
;
if
(
handle
)
{
Queue
*
const
queue
=
GlobalQueue
(
)
;
if
(
!
handle
-
>
SafeToDelete
(
)
)
{
MutexLock
lock
(
&
queue
-
>
mutex
)
;
CordzHandle
*
dq_tail
=
queue
-
>
dq_tail
.
load
(
std
:
:
memory_order_acquire
)
;
if
(
dq_tail
!
=
nullptr
)
{
handle
-
>
dq_prev_
=
dq_tail
;
dq_tail
-
>
dq_next_
=
handle
;
queue
-
>
dq_tail
.
store
(
handle
std
:
:
memory_order_release
)
;
return
;
}
}
delete
handle
;
}
}
std
:
:
vector
<
const
CordzHandle
*
>
CordzHandle
:
:
DiagnosticsGetDeleteQueue
(
)
{
std
:
:
vector
<
const
CordzHandle
*
>
handles
;
Queue
*
global_queue
=
GlobalQueue
(
)
;
MutexLock
lock
(
&
global_queue
-
>
mutex
)
;
CordzHandle
*
dq_tail
=
global_queue
-
>
dq_tail
.
load
(
std
:
:
memory_order_acquire
)
;
for
(
const
CordzHandle
*
p
=
dq_tail
;
p
;
p
=
p
-
>
dq_prev_
)
{
handles
.
push_back
(
p
)
;
}
return
handles
;
}
bool
CordzHandle
:
:
DiagnosticsHandleIsSafeToInspect
(
const
CordzHandle
*
handle
)
const
{
if
(
!
is_snapshot_
)
return
false
;
if
(
handle
=
=
nullptr
)
return
true
;
if
(
handle
-
>
is_snapshot_
)
return
false
;
bool
snapshot_found
=
false
;
Queue
*
global_queue
=
GlobalQueue
(
)
;
MutexLock
lock
(
&
global_queue
-
>
mutex
)
;
for
(
const
CordzHandle
*
p
=
global_queue
-
>
dq_tail
;
p
;
p
=
p
-
>
dq_prev_
)
{
if
(
p
=
=
handle
)
return
!
snapshot_found
;
if
(
p
=
=
this
)
snapshot_found
=
true
;
}
ABSL_ASSERT
(
snapshot_found
)
;
return
true
;
}
std
:
:
vector
<
const
CordzHandle
*
>
CordzHandle
:
:
DiagnosticsGetSafeToInspectDeletedHandles
(
)
{
std
:
:
vector
<
const
CordzHandle
*
>
handles
;
if
(
!
is_snapshot
(
)
)
{
return
handles
;
}
Queue
*
global_queue
=
GlobalQueue
(
)
;
MutexLock
lock
(
&
global_queue
-
>
mutex
)
;
for
(
const
CordzHandle
*
p
=
dq_next_
;
p
!
=
nullptr
;
p
=
p
-
>
dq_next_
)
{
if
(
!
p
-
>
is_snapshot
(
)
)
{
handles
.
push_back
(
p
)
;
}
}
return
handles
;
}
}
ABSL_NAMESPACE_END
}
