#
ifndef
ABSL_STRINGS_CORD_TEST_HELPERS_H_
#
define
ABSL_STRINGS_CORD_TEST_HELPERS_H_
#
include
<
cstdint
>
#
include
<
iostream
>
#
include
<
string
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
strings
/
cord
.
h
"
#
include
"
absl
/
strings
/
internal
/
cord_internal
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
enum
class
TestCordSize
{
kEmpty
=
0
kInlined
=
cord_internal
:
:
kMaxInline
/
2
+
1
kStringSso1
=
15
kStringSso2
=
22
kSmall
=
cord_internal
:
:
kMaxBytesToCopy
/
2
+
1
kMedium
=
cord_internal
:
:
kMaxFlatLength
/
2
+
1
kLarge
=
cord_internal
:
:
kMaxFlatLength
*
4
}
;
inline
absl
:
:
string_view
ToString
(
TestCordSize
size
)
{
switch
(
size
)
{
case
TestCordSize
:
:
kEmpty
:
return
"
Empty
"
;
case
TestCordSize
:
:
kInlined
:
return
"
Inlined
"
;
case
TestCordSize
:
:
kSmall
:
return
"
Small
"
;
case
TestCordSize
:
:
kStringSso1
:
return
"
StringSso1
"
;
case
TestCordSize
:
:
kStringSso2
:
return
"
StringSso2
"
;
case
TestCordSize
:
:
kMedium
:
return
"
Medium
"
;
case
TestCordSize
:
:
kLarge
:
return
"
Large
"
;
}
return
"
?
?
?
"
;
}
inline
size_t
Length
(
TestCordSize
size
)
{
return
static_cast
<
size_t
>
(
size
)
;
}
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
stream
TestCordSize
size
)
{
return
stream
<
<
ToString
(
size
)
;
}
template
<
typename
Container
>
Cord
MakeFragmentedCord
(
const
Container
&
c
)
{
Cord
result
;
for
(
const
auto
&
s
:
c
)
{
auto
*
external
=
new
std
:
:
string
(
s
)
;
Cord
tmp
=
absl
:
:
MakeCordFromExternal
(
*
external
[
external
]
(
absl
:
:
string_view
)
{
delete
external
;
}
)
;
tmp
.
Prepend
(
result
)
;
result
=
tmp
;
}
return
result
;
}
inline
Cord
MakeFragmentedCord
(
std
:
:
initializer_list
<
absl
:
:
string_view
>
list
)
{
return
MakeFragmentedCord
<
std
:
:
initializer_list
<
absl
:
:
string_view
>
>
(
list
)
;
}
ABSL_NAMESPACE_END
}
#
endif
