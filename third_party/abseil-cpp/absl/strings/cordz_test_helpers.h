#
ifndef
ABSL_STRINGS_CORDZ_TEST_HELPERS_H_
#
define
ABSL_STRINGS_CORDZ_TEST_HELPERS_H_
#
include
<
utility
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
strings
/
cord
.
h
"
#
include
"
absl
/
strings
/
internal
/
cord_internal
.
h
"
#
include
"
absl
/
strings
/
internal
/
cordz_info
.
h
"
#
include
"
absl
/
strings
/
internal
/
cordz_sample_token
.
h
"
#
include
"
absl
/
strings
/
internal
/
cordz_statistics
.
h
"
#
include
"
absl
/
strings
/
internal
/
cordz_update_tracker
.
h
"
#
include
"
absl
/
strings
/
str_cat
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
inline
const
cord_internal
:
:
CordzInfo
*
GetCordzInfoForTesting
(
const
Cord
&
cord
)
{
if
(
!
cord
.
contents_
.
is_tree
(
)
)
return
nullptr
;
return
cord
.
contents_
.
cordz_info
(
)
;
}
inline
bool
CordzInfoIsListed
(
const
cord_internal
:
:
CordzInfo
*
cordz_info
cord_internal
:
:
CordzSampleToken
token
=
{
}
)
{
for
(
const
cord_internal
:
:
CordzInfo
&
info
:
token
)
{
if
(
cordz_info
=
=
&
info
)
return
true
;
}
return
false
;
}
MATCHER_P
(
HasValidCordzInfoOf
method
"
CordzInfo
matches
cord
"
)
{
const
cord_internal
:
:
CordzInfo
*
cord_info
=
GetCordzInfoForTesting
(
arg
)
;
if
(
cord_info
=
=
nullptr
)
{
*
result_listener
<
<
"
cord
is
not
sampled
"
;
return
false
;
}
if
(
!
CordzInfoIsListed
(
cord_info
)
)
{
*
result_listener
<
<
"
cord
is
sampled
but
not
listed
"
;
return
false
;
}
cord_internal
:
:
CordzStatistics
stat
=
cord_info
-
>
GetCordzStatistics
(
)
;
if
(
stat
.
size
!
=
arg
.
size
(
)
)
{
*
result_listener
<
<
"
cordz
size
"
<
<
stat
.
size
<
<
"
does
not
match
cord
size
"
<
<
arg
.
size
(
)
;
return
false
;
}
if
(
stat
.
update_tracker
.
Value
(
method
)
!
=
1
)
{
*
result_listener
<
<
"
Expected
method
count
1
for
"
<
<
method
<
<
"
found
"
<
<
stat
.
update_tracker
.
Value
(
method
)
;
return
false
;
}
return
true
;
}
MATCHER_P2
(
CordzMethodCountEq
method
n
absl
:
:
StrCat
(
"
CordzInfo
method
count
equals
"
n
)
)
{
const
cord_internal
:
:
CordzInfo
*
cord_info
=
GetCordzInfoForTesting
(
arg
)
;
if
(
cord_info
=
=
nullptr
)
{
*
result_listener
<
<
"
cord
is
not
sampled
"
;
return
false
;
}
cord_internal
:
:
CordzStatistics
stat
=
cord_info
-
>
GetCordzStatistics
(
)
;
if
(
stat
.
update_tracker
.
Value
(
method
)
!
=
n
)
{
*
result_listener
<
<
"
Expected
method
count
"
<
<
n
<
<
"
for
"
<
<
method
<
<
"
found
"
<
<
stat
.
update_tracker
.
Value
(
method
)
;
return
false
;
}
return
true
;
}
class
CordzSamplingIntervalHelper
{
public
:
explicit
CordzSamplingIntervalHelper
(
int32_t
interval
)
:
orig_mean_interval_
(
absl
:
:
cord_internal
:
:
get_cordz_mean_interval
(
)
)
{
absl
:
:
cord_internal
:
:
set_cordz_mean_interval
(
interval
)
;
absl
:
:
cord_internal
:
:
cordz_set_next_sample_for_testing
(
interval
)
;
}
~
CordzSamplingIntervalHelper
(
)
{
absl
:
:
cord_internal
:
:
set_cordz_mean_interval
(
orig_mean_interval_
)
;
absl
:
:
cord_internal
:
:
cordz_set_next_sample_for_testing
(
orig_mean_interval_
)
;
}
private
:
int32_t
orig_mean_interval_
;
}
;
struct
TestCordRep
{
cord_internal
:
:
CordRepFlat
*
rep
;
TestCordRep
(
)
{
rep
=
cord_internal
:
:
CordRepFlat
:
:
New
(
100
)
;
rep
-
>
length
=
100
;
memset
(
rep
-
>
Data
(
)
1
100
)
;
}
~
TestCordRep
(
)
{
cord_internal
:
:
CordRep
:
:
Unref
(
rep
)
;
}
}
;
struct
TestCordData
{
TestCordRep
rep
;
cord_internal
:
:
InlineData
data
{
rep
.
rep
}
;
}
;
template
<
typename
.
.
.
Args
>
Cord
UnsampledCord
(
Args
.
.
.
args
)
{
CordzSamplingIntervalHelper
never
(
9999
)
;
Cord
cord
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
ABSL_ASSERT
(
GetCordzInfoForTesting
(
cord
)
=
=
nullptr
)
;
return
cord
;
}
ABSL_NAMESPACE_END
}
#
endif
