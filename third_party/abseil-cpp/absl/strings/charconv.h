#
ifndef
ABSL_STRINGS_CHARCONV_H_
#
define
ABSL_STRINGS_CHARCONV_H_
#
include
<
system_error
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
nullability
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
enum
class
chars_format
{
scientific
=
1
fixed
=
2
hex
=
4
general
=
fixed
|
scientific
}
;
struct
from_chars_result
{
absl
:
:
Nonnull
<
const
char
*
>
ptr
;
std
:
:
errc
ec
;
}
;
absl
:
:
from_chars_result
from_chars
(
absl
:
:
Nonnull
<
const
char
*
>
first
absl
:
:
Nonnull
<
const
char
*
>
last
double
&
value
chars_format
fmt
=
chars_format
:
:
general
)
;
absl
:
:
from_chars_result
from_chars
(
absl
:
:
Nonnull
<
const
char
*
>
first
absl
:
:
Nonnull
<
const
char
*
>
last
float
&
value
chars_format
fmt
=
chars_format
:
:
general
)
;
inline
constexpr
chars_format
operator
&
(
chars_format
lhs
chars_format
rhs
)
{
return
static_cast
<
chars_format
>
(
static_cast
<
int
>
(
lhs
)
&
static_cast
<
int
>
(
rhs
)
)
;
}
inline
constexpr
chars_format
operator
|
(
chars_format
lhs
chars_format
rhs
)
{
return
static_cast
<
chars_format
>
(
static_cast
<
int
>
(
lhs
)
|
static_cast
<
int
>
(
rhs
)
)
;
}
inline
constexpr
chars_format
operator
^
(
chars_format
lhs
chars_format
rhs
)
{
return
static_cast
<
chars_format
>
(
static_cast
<
int
>
(
lhs
)
^
static_cast
<
int
>
(
rhs
)
)
;
}
inline
constexpr
chars_format
operator
~
(
chars_format
arg
)
{
return
static_cast
<
chars_format
>
(
~
static_cast
<
int
>
(
arg
)
)
;
}
inline
chars_format
&
operator
&
=
(
chars_format
&
lhs
chars_format
rhs
)
{
lhs
=
lhs
&
rhs
;
return
lhs
;
}
inline
chars_format
&
operator
|
=
(
chars_format
&
lhs
chars_format
rhs
)
{
lhs
=
lhs
|
rhs
;
return
lhs
;
}
inline
chars_format
&
operator
^
=
(
chars_format
&
lhs
chars_format
rhs
)
{
lhs
=
lhs
^
rhs
;
return
lhs
;
}
ABSL_NAMESPACE_END
}
#
endif
