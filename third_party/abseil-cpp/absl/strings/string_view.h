#
ifndef
ABSL_STRINGS_STRING_VIEW_H_
#
define
ABSL_STRINGS_STRING_VIEW_H_
#
include
<
algorithm
>
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
<
cstring
>
#
include
<
iosfwd
>
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
string
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
nullability
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
throw_delegate
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
ifdef
ABSL_USES_STD_STRING_VIEW
#
include
<
string_view
>
namespace
absl
{
ABSL_NAMESPACE_BEGIN
using
string_view
=
std
:
:
string_view
;
ABSL_NAMESPACE_END
}
#
else
#
if
ABSL_HAVE_BUILTIN
(
__builtin_memcmp
)
|
|
\
(
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
)
|
|
\
(
defined
(
_MSC_VER
)
&
&
_MSC_VER
>
=
1928
)
#
define
ABSL_INTERNAL_STRING_VIEW_MEMCMP
__builtin_memcmp
#
else
#
define
ABSL_INTERNAL_STRING_VIEW_MEMCMP
memcmp
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
push
#
pragma
clang
diagnostic
ignored
"
-
Wcomma
"
#
endif
class
ABSL_ATTRIBUTE_VIEW
string_view
{
public
:
using
traits_type
=
std
:
:
char_traits
<
char
>
;
using
value_type
=
char
;
using
pointer
=
absl
:
:
Nullable
<
char
*
>
;
using
const_pointer
=
absl
:
:
Nullable
<
const
char
*
>
;
using
reference
=
char
&
;
using
const_reference
=
const
char
&
;
using
const_iterator
=
absl
:
:
Nullable
<
const
char
*
>
;
using
iterator
=
const_iterator
;
using
const_reverse_iterator
=
std
:
:
reverse_iterator
<
const_iterator
>
;
using
reverse_iterator
=
const_reverse_iterator
;
using
size_type
=
size_t
;
using
difference_type
=
std
:
:
ptrdiff_t
;
using
absl_internal_is_view
=
std
:
:
true_type
;
static
constexpr
size_type
npos
=
static_cast
<
size_type
>
(
-
1
)
;
constexpr
string_view
(
)
noexcept
:
ptr_
(
nullptr
)
length_
(
0
)
{
}
template
<
typename
Allocator
>
string_view
(
const
std
:
:
basic_string
<
char
std
:
:
char_traits
<
char
>
Allocator
>
&
str
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
noexcept
:
string_view
(
str
.
data
(
)
str
.
size
(
)
SkipCheckLengthTag
{
}
)
{
}
constexpr
string_view
(
absl
:
:
Nonnull
<
const
char
*
>
str
)
:
ptr_
(
str
)
length_
(
str
?
StrlenInternal
(
str
)
:
0
)
{
}
constexpr
string_view
(
absl
:
:
Nullable
<
const
char
*
>
data
size_type
len
)
:
ptr_
(
data
)
length_
(
CheckLengthInternal
(
len
)
)
{
}
constexpr
string_view
(
const
string_view
&
)
noexcept
=
default
;
string_view
&
operator
=
(
const
string_view
&
)
noexcept
=
default
;
constexpr
const_iterator
begin
(
)
const
noexcept
{
return
ptr_
;
}
constexpr
const_iterator
end
(
)
const
noexcept
{
return
ptr_
+
length_
;
}
constexpr
const_iterator
cbegin
(
)
const
noexcept
{
return
begin
(
)
;
}
constexpr
const_iterator
cend
(
)
const
noexcept
{
return
end
(
)
;
}
const_reverse_iterator
rbegin
(
)
const
noexcept
{
return
const_reverse_iterator
(
end
(
)
)
;
}
const_reverse_iterator
rend
(
)
const
noexcept
{
return
const_reverse_iterator
(
begin
(
)
)
;
}
const_reverse_iterator
crbegin
(
)
const
noexcept
{
return
rbegin
(
)
;
}
const_reverse_iterator
crend
(
)
const
noexcept
{
return
rend
(
)
;
}
constexpr
size_type
size
(
)
const
noexcept
{
return
length_
;
}
constexpr
size_type
length
(
)
const
noexcept
{
return
size
(
)
;
}
constexpr
size_type
max_size
(
)
const
noexcept
{
return
kMaxSize
;
}
constexpr
bool
empty
(
)
const
noexcept
{
return
length_
=
=
0
;
}
constexpr
const_reference
operator
[
]
(
size_type
i
)
const
{
ABSL_HARDENING_ASSERT
(
i
<
size
(
)
)
;
return
ptr_
[
i
]
;
}
constexpr
const_reference
at
(
size_type
i
)
const
{
if
(
ABSL_PREDICT_FALSE
(
i
>
=
size
(
)
)
)
{
base_internal
:
:
ThrowStdOutOfRange
(
"
absl
:
:
string_view
:
:
at
"
)
;
}
return
ptr_
[
i
]
;
}
constexpr
const_reference
front
(
)
const
{
ABSL_HARDENING_ASSERT
(
!
empty
(
)
)
;
return
ptr_
[
0
]
;
}
constexpr
const_reference
back
(
)
const
{
ABSL_HARDENING_ASSERT
(
!
empty
(
)
)
;
return
ptr_
[
size
(
)
-
1
]
;
}
constexpr
const_pointer
data
(
)
const
noexcept
{
return
ptr_
;
}
constexpr
void
remove_prefix
(
size_type
n
)
{
ABSL_HARDENING_ASSERT
(
n
<
=
length_
)
;
ptr_
+
=
n
;
length_
-
=
n
;
}
constexpr
void
remove_suffix
(
size_type
n
)
{
ABSL_HARDENING_ASSERT
(
n
<
=
length_
)
;
length_
-
=
n
;
}
constexpr
void
swap
(
string_view
&
s
)
noexcept
{
auto
t
=
*
this
;
*
this
=
s
;
s
=
t
;
}
template
<
typename
A
>
explicit
operator
std
:
:
basic_string
<
char
traits_type
A
>
(
)
const
{
if
(
!
data
(
)
)
return
{
}
;
return
std
:
:
basic_string
<
char
traits_type
A
>
(
data
(
)
size
(
)
)
;
}
size_type
copy
(
char
*
buf
size_type
n
size_type
pos
=
0
)
const
{
if
(
ABSL_PREDICT_FALSE
(
pos
>
length_
)
)
{
base_internal
:
:
ThrowStdOutOfRange
(
"
absl
:
:
string_view
:
:
copy
"
)
;
}
size_type
rlen
=
(
std
:
:
min
)
(
length_
-
pos
n
)
;
if
(
rlen
>
0
)
{
const
char
*
start
=
ptr_
+
pos
;
traits_type
:
:
copy
(
buf
start
rlen
)
;
}
return
rlen
;
}
constexpr
string_view
substr
(
size_type
pos
=
0
size_type
n
=
npos
)
const
{
if
(
ABSL_PREDICT_FALSE
(
pos
>
length_
)
)
{
base_internal
:
:
ThrowStdOutOfRange
(
"
absl
:
:
string_view
:
:
substr
"
)
;
}
return
string_view
(
ptr_
+
pos
Min
(
n
length_
-
pos
)
)
;
}
constexpr
int
compare
(
string_view
x
)
const
noexcept
{
return
CompareImpl
(
length_
x
.
length_
Min
(
length_
x
.
length_
)
=
=
0
?
0
:
ABSL_INTERNAL_STRING_VIEW_MEMCMP
(
ptr_
x
.
ptr_
Min
(
length_
x
.
length_
)
)
)
;
}
constexpr
int
compare
(
size_type
pos1
size_type
count1
string_view
v
)
const
{
return
substr
(
pos1
count1
)
.
compare
(
v
)
;
}
constexpr
int
compare
(
size_type
pos1
size_type
count1
string_view
v
size_type
pos2
size_type
count2
)
const
{
return
substr
(
pos1
count1
)
.
compare
(
v
.
substr
(
pos2
count2
)
)
;
}
constexpr
int
compare
(
absl
:
:
Nonnull
<
const
char
*
>
s
)
const
{
return
compare
(
string_view
(
s
)
)
;
}
constexpr
int
compare
(
size_type
pos1
size_type
count1
absl
:
:
Nonnull
<
const
char
*
>
s
)
const
{
return
substr
(
pos1
count1
)
.
compare
(
string_view
(
s
)
)
;
}
constexpr
int
compare
(
size_type
pos1
size_type
count1
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
count2
)
const
{
return
substr
(
pos1
count1
)
.
compare
(
string_view
(
s
count2
)
)
;
}
size_type
find
(
string_view
s
size_type
pos
=
0
)
const
noexcept
;
size_type
find
(
char
c
size_type
pos
=
0
)
const
noexcept
;
size_type
find
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
size_type
count
)
const
{
return
find
(
string_view
(
s
count
)
pos
)
;
}
size_type
find
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
=
0
)
const
{
return
find
(
string_view
(
s
)
pos
)
;
}
size_type
rfind
(
string_view
s
size_type
pos
=
npos
)
const
noexcept
;
size_type
rfind
(
char
c
size_type
pos
=
npos
)
const
noexcept
;
size_type
rfind
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
size_type
count
)
const
{
return
rfind
(
string_view
(
s
count
)
pos
)
;
}
size_type
rfind
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
=
npos
)
const
{
return
rfind
(
string_view
(
s
)
pos
)
;
}
size_type
find_first_of
(
string_view
s
size_type
pos
=
0
)
const
noexcept
;
size_type
find_first_of
(
char
c
size_type
pos
=
0
)
const
noexcept
{
return
find
(
c
pos
)
;
}
size_type
find_first_of
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
size_type
count
)
const
{
return
find_first_of
(
string_view
(
s
count
)
pos
)
;
}
size_type
find_first_of
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
=
0
)
const
{
return
find_first_of
(
string_view
(
s
)
pos
)
;
}
size_type
find_last_of
(
string_view
s
size_type
pos
=
npos
)
const
noexcept
;
size_type
find_last_of
(
char
c
size_type
pos
=
npos
)
const
noexcept
{
return
rfind
(
c
pos
)
;
}
size_type
find_last_of
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
size_type
count
)
const
{
return
find_last_of
(
string_view
(
s
count
)
pos
)
;
}
size_type
find_last_of
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
=
npos
)
const
{
return
find_last_of
(
string_view
(
s
)
pos
)
;
}
size_type
find_first_not_of
(
string_view
s
size_type
pos
=
0
)
const
noexcept
;
size_type
find_first_not_of
(
char
c
size_type
pos
=
0
)
const
noexcept
;
size_type
find_first_not_of
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
size_type
count
)
const
{
return
find_first_not_of
(
string_view
(
s
count
)
pos
)
;
}
size_type
find_first_not_of
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
=
0
)
const
{
return
find_first_not_of
(
string_view
(
s
)
pos
)
;
}
size_type
find_last_not_of
(
string_view
s
size_type
pos
=
npos
)
const
noexcept
;
size_type
find_last_not_of
(
char
c
size_type
pos
=
npos
)
const
noexcept
;
size_type
find_last_not_of
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
size_type
count
)
const
{
return
find_last_not_of
(
string_view
(
s
count
)
pos
)
;
}
size_type
find_last_not_of
(
absl
:
:
Nonnull
<
const
char
*
>
s
size_type
pos
=
npos
)
const
{
return
find_last_not_of
(
string_view
(
s
)
pos
)
;
}
#
if
ABSL_INTERNAL_CPLUSPLUS_LANG
>
=
202002L
constexpr
bool
starts_with
(
string_view
s
)
const
noexcept
{
return
s
.
empty
(
)
|
|
(
size
(
)
>
=
s
.
size
(
)
&
&
ABSL_INTERNAL_STRING_VIEW_MEMCMP
(
data
(
)
s
.
data
(
)
s
.
size
(
)
)
=
=
0
)
;
}
constexpr
bool
starts_with
(
char
c
)
const
noexcept
{
return
!
empty
(
)
&
&
front
(
)
=
=
c
;
}
constexpr
bool
starts_with
(
const
char
*
s
)
const
{
return
starts_with
(
string_view
(
s
)
)
;
}
constexpr
bool
ends_with
(
string_view
s
)
const
noexcept
{
return
s
.
empty
(
)
|
|
(
size
(
)
>
=
s
.
size
(
)
&
&
ABSL_INTERNAL_STRING_VIEW_MEMCMP
(
data
(
)
+
(
size
(
)
-
s
.
size
(
)
)
s
.
data
(
)
s
.
size
(
)
)
=
=
0
)
;
}
constexpr
bool
ends_with
(
char
c
)
const
noexcept
{
return
!
empty
(
)
&
&
back
(
)
=
=
c
;
}
constexpr
bool
ends_with
(
const
char
*
s
)
const
{
return
ends_with
(
string_view
(
s
)
)
;
}
#
endif
private
:
struct
SkipCheckLengthTag
{
}
;
string_view
(
absl
:
:
Nullable
<
const
char
*
>
data
size_type
len
SkipCheckLengthTag
)
noexcept
:
ptr_
(
data
)
length_
(
len
)
{
}
static
constexpr
size_type
kMaxSize
=
(
std
:
:
numeric_limits
<
difference_type
>
:
:
max
)
(
)
;
static
constexpr
size_type
CheckLengthInternal
(
size_type
len
)
{
ABSL_HARDENING_ASSERT
(
len
<
=
kMaxSize
)
;
return
len
;
}
static
constexpr
size_type
StrlenInternal
(
absl
:
:
Nonnull
<
const
char
*
>
str
)
{
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
const
char
*
begin
=
str
;
while
(
*
str
!
=
'
\
0
'
)
+
+
str
;
return
str
-
begin
;
#
elif
ABSL_HAVE_BUILTIN
(
__builtin_strlen
)
|
|
\
(
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
)
return
__builtin_strlen
(
str
)
;
#
else
return
str
?
strlen
(
str
)
:
0
;
#
endif
}
static
constexpr
size_t
Min
(
size_type
length_a
size_type
length_b
)
{
return
length_a
<
length_b
?
length_a
:
length_b
;
}
static
constexpr
int
CompareImpl
(
size_type
length_a
size_type
length_b
int
compare_result
)
{
return
compare_result
=
=
0
?
static_cast
<
int
>
(
length_a
>
length_b
)
-
static_cast
<
int
>
(
length_a
<
length_b
)
:
(
compare_result
<
0
?
-
1
:
1
)
;
}
absl
:
:
Nullable
<
const
char
*
>
ptr_
;
size_type
length_
;
}
;
constexpr
bool
operator
=
=
(
string_view
x
string_view
y
)
noexcept
{
return
x
.
size
(
)
=
=
y
.
size
(
)
&
&
(
x
.
empty
(
)
|
|
ABSL_INTERNAL_STRING_VIEW_MEMCMP
(
x
.
data
(
)
y
.
data
(
)
x
.
size
(
)
)
=
=
0
)
;
}
constexpr
bool
operator
!
=
(
string_view
x
string_view
y
)
noexcept
{
return
!
(
x
=
=
y
)
;
}
constexpr
bool
operator
<
(
string_view
x
string_view
y
)
noexcept
{
return
x
.
compare
(
y
)
<
0
;
}
constexpr
bool
operator
>
(
string_view
x
string_view
y
)
noexcept
{
return
y
<
x
;
}
constexpr
bool
operator
<
=
(
string_view
x
string_view
y
)
noexcept
{
return
!
(
y
<
x
)
;
}
constexpr
bool
operator
>
=
(
string_view
x
string_view
y
)
noexcept
{
return
!
(
x
<
y
)
;
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
o
string_view
piece
)
;
ABSL_NAMESPACE_END
}
#
undef
ABSL_INTERNAL_STRING_VIEW_MEMCMP
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
pop
#
endif
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
inline
string_view
ClippedSubstr
(
string_view
s
size_t
pos
size_t
n
=
string_view
:
:
npos
)
{
pos
=
(
std
:
:
min
)
(
pos
static_cast
<
size_t
>
(
s
.
size
(
)
)
)
;
return
s
.
substr
(
pos
n
)
;
}
constexpr
string_view
NullSafeStringView
(
absl
:
:
Nullable
<
const
char
*
>
p
)
{
return
p
?
string_view
(
p
)
:
string_view
(
)
;
}
ABSL_NAMESPACE_END
}
#
endif
