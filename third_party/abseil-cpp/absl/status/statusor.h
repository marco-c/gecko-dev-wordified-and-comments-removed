#
ifndef
ABSL_STATUS_STATUSOR_H_
#
define
ABSL_STATUS_STATUSOR_H_
#
include
<
exception
>
#
include
<
initializer_list
>
#
include
<
new
>
#
include
<
ostream
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
nullability
.
h
"
#
include
"
absl
/
base
/
call_once
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
status
/
internal
/
statusor_internal
.
h
"
#
include
"
absl
/
status
/
status
.
h
"
#
include
"
absl
/
strings
/
has_absl_stringify
.
h
"
#
include
"
absl
/
strings
/
has_ostream_operator
.
h
"
#
include
"
absl
/
strings
/
str_format
.
h
"
#
include
"
absl
/
types
/
variant
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
class
BadStatusOrAccess
:
public
std
:
:
exception
{
public
:
explicit
BadStatusOrAccess
(
absl
:
:
Status
status
)
;
~
BadStatusOrAccess
(
)
override
=
default
;
BadStatusOrAccess
(
const
BadStatusOrAccess
&
other
)
;
BadStatusOrAccess
&
operator
=
(
const
BadStatusOrAccess
&
other
)
;
BadStatusOrAccess
(
BadStatusOrAccess
&
&
other
)
;
BadStatusOrAccess
&
operator
=
(
BadStatusOrAccess
&
&
other
)
;
absl
:
:
Nonnull
<
const
char
*
>
what
(
)
const
noexcept
override
;
const
absl
:
:
Status
&
status
(
)
const
;
private
:
void
InitWhat
(
)
const
;
absl
:
:
Status
status_
;
mutable
absl
:
:
once_flag
init_what_
;
mutable
std
:
:
string
what_
;
}
;
template
<
typename
T
>
#
if
ABSL_HAVE_CPP_ATTRIBUTE
(
nodiscard
)
class
[
[
nodiscard
]
]
StatusOr
;
#
else
class
ABSL_MUST_USE_RESULT
StatusOr
;
#
endif
template
<
typename
T
>
class
StatusOr
:
private
internal_statusor
:
:
StatusOrData
<
T
>
private
internal_statusor
:
:
CopyCtorBase
<
T
>
private
internal_statusor
:
:
MoveCtorBase
<
T
>
private
internal_statusor
:
:
CopyAssignBase
<
T
>
private
internal_statusor
:
:
MoveAssignBase
<
T
>
{
template
<
typename
U
>
friend
class
StatusOr
;
typedef
internal_statusor
:
:
StatusOrData
<
T
>
Base
;
public
:
typedef
T
value_type
;
explicit
StatusOr
(
)
;
StatusOr
(
const
StatusOr
&
)
=
default
;
StatusOr
&
operator
=
(
const
StatusOr
&
)
=
default
;
StatusOr
(
StatusOr
&
&
)
=
default
;
StatusOr
&
operator
=
(
StatusOr
&
&
)
=
default
;
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionFromStatusOrValid
<
false
T
U
false
const
U
&
>
:
:
value
int
>
=
0
>
StatusOr
(
const
StatusOr
<
U
>
&
other
)
:
Base
(
static_cast
<
const
typename
StatusOr
<
U
>
:
:
Base
&
>
(
other
)
)
{
}
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionFromStatusOrValid
<
false
T
U
true
const
U
&
>
:
:
value
int
>
=
0
>
StatusOr
(
const
StatusOr
<
U
>
&
other
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
:
Base
(
static_cast
<
const
typename
StatusOr
<
U
>
:
:
Base
&
>
(
other
)
)
{
}
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionFromStatusOrValid
<
true
T
U
false
const
U
&
>
:
:
value
int
>
=
0
>
explicit
StatusOr
(
const
StatusOr
<
U
>
&
other
)
:
Base
(
static_cast
<
const
typename
StatusOr
<
U
>
:
:
Base
&
>
(
other
)
)
{
}
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionFromStatusOrValid
<
true
T
U
true
const
U
&
>
:
:
value
int
>
=
0
>
explicit
StatusOr
(
const
StatusOr
<
U
>
&
other
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
:
Base
(
static_cast
<
const
typename
StatusOr
<
U
>
:
:
Base
&
>
(
other
)
)
{
}
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionFromStatusOrValid
<
false
T
U
false
U
&
&
>
:
:
value
int
>
=
0
>
StatusOr
(
StatusOr
<
U
>
&
&
other
)
:
Base
(
static_cast
<
typename
StatusOr
<
U
>
:
:
Base
&
&
>
(
other
)
)
{
}
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionFromStatusOrValid
<
false
T
U
true
U
&
&
>
:
:
value
int
>
=
0
>
StatusOr
(
StatusOr
<
U
>
&
&
other
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
:
Base
(
static_cast
<
typename
StatusOr
<
U
>
:
:
Base
&
&
>
(
other
)
)
{
}
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionFromStatusOrValid
<
true
T
U
false
U
&
&
>
:
:
value
int
>
=
0
>
explicit
StatusOr
(
StatusOr
<
U
>
&
&
other
)
:
Base
(
static_cast
<
typename
StatusOr
<
U
>
:
:
Base
&
&
>
(
other
)
)
{
}
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionFromStatusOrValid
<
true
T
U
true
U
&
&
>
:
:
value
int
>
=
0
>
explicit
StatusOr
(
StatusOr
<
U
>
&
&
other
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
:
Base
(
static_cast
<
typename
StatusOr
<
U
>
:
:
Base
&
&
>
(
other
)
)
{
}
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsStatusOrAssignmentValid
<
T
const
U
&
false
>
:
:
value
int
>
=
0
>
StatusOr
&
operator
=
(
const
StatusOr
<
U
>
&
other
)
{
this
-
>
Assign
(
other
)
;
return
*
this
;
}
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsStatusOrAssignmentValid
<
T
const
U
&
true
>
:
:
value
int
>
=
0
>
StatusOr
&
operator
=
(
const
StatusOr
<
U
>
&
other
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
{
this
-
>
Assign
(
other
)
;
return
*
this
;
}
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsStatusOrAssignmentValid
<
T
U
&
&
false
>
:
:
value
int
>
=
0
>
StatusOr
&
operator
=
(
StatusOr
<
U
>
&
&
other
)
{
this
-
>
Assign
(
std
:
:
move
(
other
)
)
;
return
*
this
;
}
template
<
typename
U
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsStatusOrAssignmentValid
<
T
U
&
&
true
>
:
:
value
int
>
=
0
>
StatusOr
&
operator
=
(
StatusOr
<
U
>
&
&
other
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
{
this
-
>
Assign
(
std
:
:
move
(
other
)
)
;
return
*
this
;
}
template
<
typename
U
=
absl
:
:
Status
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionFromStatusValid
<
false
T
U
>
:
:
value
int
>
=
0
>
StatusOr
(
U
&
&
v
)
:
Base
(
std
:
:
forward
<
U
>
(
v
)
)
{
}
template
<
typename
U
=
absl
:
:
Status
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionFromStatusValid
<
true
T
U
>
:
:
value
int
>
=
0
>
explicit
StatusOr
(
U
&
&
v
)
:
Base
(
std
:
:
forward
<
U
>
(
v
)
)
{
}
template
<
typename
U
=
absl
:
:
Status
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionFromStatusValid
<
false
T
U
>
:
:
value
int
>
=
0
>
StatusOr
&
operator
=
(
U
&
&
v
)
{
this
-
>
AssignStatus
(
std
:
:
forward
<
U
>
(
v
)
)
;
return
*
this
;
}
template
<
typename
U
=
T
typename
std
:
:
enable_if
<
internal_statusor
:
:
IsAssignmentValid
<
T
U
false
>
:
:
value
int
>
:
:
type
=
0
>
StatusOr
&
operator
=
(
U
&
&
v
)
{
this
-
>
Assign
(
std
:
:
forward
<
U
>
(
v
)
)
;
return
*
this
;
}
template
<
typename
U
=
T
typename
std
:
:
enable_if
<
internal_statusor
:
:
IsAssignmentValid
<
T
U
true
>
:
:
value
int
>
:
:
type
=
0
>
StatusOr
&
operator
=
(
U
&
&
v
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
{
this
-
>
Assign
(
std
:
:
forward
<
U
>
(
v
)
)
;
return
*
this
;
}
template
<
typename
.
.
.
Args
>
explicit
StatusOr
(
absl
:
:
in_place_t
Args
&
&
.
.
.
args
)
;
template
<
typename
U
typename
.
.
.
Args
>
explicit
StatusOr
(
absl
:
:
in_place_t
std
:
:
initializer_list
<
U
>
ilist
Args
&
&
.
.
.
args
)
;
template
<
typename
U
=
T
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionValid
<
false
T
U
false
>
:
:
value
int
>
=
0
>
StatusOr
(
U
&
&
u
)
:
StatusOr
(
absl
:
:
in_place
std
:
:
forward
<
U
>
(
u
)
)
{
}
template
<
typename
U
=
T
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionValid
<
false
T
U
true
>
:
:
value
int
>
=
0
>
StatusOr
(
U
&
&
u
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
:
StatusOr
(
absl
:
:
in_place
std
:
:
forward
<
U
>
(
u
)
)
{
}
template
<
typename
U
=
T
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionValid
<
true
T
U
false
>
:
:
value
int
>
=
0
>
explicit
StatusOr
(
U
&
&
u
)
:
StatusOr
(
absl
:
:
in_place
std
:
:
forward
<
U
>
(
u
)
)
{
}
template
<
typename
U
=
T
absl
:
:
enable_if_t
<
internal_statusor
:
:
IsConstructionValid
<
true
T
U
true
>
:
:
value
int
>
=
0
>
explicit
StatusOr
(
U
&
&
u
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
:
StatusOr
(
absl
:
:
in_place
std
:
:
forward
<
U
>
(
u
)
)
{
}
ABSL_MUST_USE_RESULT
bool
ok
(
)
const
{
return
this
-
>
status_
.
ok
(
)
;
}
const
Status
&
status
(
)
const
&
;
Status
status
(
)
&
&
;
const
T
&
value
(
)
const
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
;
T
&
value
(
)
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
;
const
T
&
&
value
(
)
const
&
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
;
T
&
&
value
(
)
&
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
;
const
T
&
operator
*
(
)
const
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
;
T
&
operator
*
(
)
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
;
const
T
&
&
operator
*
(
)
const
&
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
;
T
&
&
operator
*
(
)
&
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
;
const
T
*
operator
-
>
(
)
const
ABSL_ATTRIBUTE_LIFETIME_BOUND
;
T
*
operator
-
>
(
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
;
template
<
typename
U
>
T
value_or
(
U
&
&
default_value
)
const
&
;
template
<
typename
U
>
T
value_or
(
U
&
&
default_value
)
&
&
;
void
IgnoreError
(
)
const
;
template
<
typename
.
.
.
Args
>
T
&
emplace
(
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
if
(
ok
(
)
)
{
this
-
>
Clear
(
)
;
this
-
>
MakeValue
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
else
{
this
-
>
MakeValue
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
this
-
>
status_
=
absl
:
:
OkStatus
(
)
;
}
return
this
-
>
data_
;
}
template
<
typename
U
typename
.
.
.
Args
absl
:
:
enable_if_t
<
std
:
:
is_constructible
<
T
std
:
:
initializer_list
<
U
>
&
Args
&
&
.
.
.
>
:
:
value
int
>
=
0
>
T
&
emplace
(
std
:
:
initializer_list
<
U
>
ilist
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
if
(
ok
(
)
)
{
this
-
>
Clear
(
)
;
this
-
>
MakeValue
(
ilist
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
else
{
this
-
>
MakeValue
(
ilist
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
this
-
>
status_
=
absl
:
:
OkStatus
(
)
;
}
return
this
-
>
data_
;
}
using
internal_statusor
:
:
StatusOrData
<
T
>
:
:
AssignStatus
;
private
:
using
internal_statusor
:
:
StatusOrData
<
T
>
:
:
Assign
;
template
<
typename
U
>
void
Assign
(
const
absl
:
:
StatusOr
<
U
>
&
other
)
;
template
<
typename
U
>
void
Assign
(
absl
:
:
StatusOr
<
U
>
&
&
other
)
;
}
;
template
<
typename
T
>
bool
operator
=
=
(
const
StatusOr
<
T
>
&
lhs
const
StatusOr
<
T
>
&
rhs
)
{
if
(
lhs
.
ok
(
)
&
&
rhs
.
ok
(
)
)
return
*
lhs
=
=
*
rhs
;
return
lhs
.
status
(
)
=
=
rhs
.
status
(
)
;
}
template
<
typename
T
>
bool
operator
!
=
(
const
StatusOr
<
T
>
&
lhs
const
StatusOr
<
T
>
&
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
absl
:
:
HasOstreamOperator
<
T
>
:
:
value
int
>
:
:
type
=
0
>
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
StatusOr
<
T
>
&
status_or
)
{
if
(
status_or
.
ok
(
)
)
{
os
<
<
status_or
.
value
(
)
;
}
else
{
os
<
<
internal_statusor
:
:
StringifyRandom
:
:
OpenBrackets
(
)
<
<
status_or
.
status
(
)
<
<
internal_statusor
:
:
StringifyRandom
:
:
CloseBrackets
(
)
;
}
return
os
;
}
template
<
typename
Sink
typename
T
typename
std
:
:
enable_if
<
absl
:
:
HasAbslStringify
<
T
>
:
:
value
int
>
:
:
type
=
0
>
void
AbslStringify
(
Sink
&
sink
const
StatusOr
<
T
>
&
status_or
)
{
if
(
status_or
.
ok
(
)
)
{
absl
:
:
Format
(
&
sink
"
%
v
"
status_or
.
value
(
)
)
;
}
else
{
absl
:
:
Format
(
&
sink
"
%
s
%
v
%
s
"
internal_statusor
:
:
StringifyRandom
:
:
OpenBrackets
(
)
status_or
.
status
(
)
internal_statusor
:
:
StringifyRandom
:
:
CloseBrackets
(
)
)
;
}
}
template
<
typename
T
>
StatusOr
<
T
>
:
:
StatusOr
(
)
:
Base
(
Status
(
absl
:
:
StatusCode
:
:
kUnknown
"
"
)
)
{
}
template
<
typename
T
>
template
<
typename
U
>
inline
void
StatusOr
<
T
>
:
:
Assign
(
const
StatusOr
<
U
>
&
other
)
{
if
(
other
.
ok
(
)
)
{
this
-
>
Assign
(
*
other
)
;
}
else
{
this
-
>
AssignStatus
(
other
.
status
(
)
)
;
}
}
template
<
typename
T
>
template
<
typename
U
>
inline
void
StatusOr
<
T
>
:
:
Assign
(
StatusOr
<
U
>
&
&
other
)
{
if
(
other
.
ok
(
)
)
{
this
-
>
Assign
(
*
std
:
:
move
(
other
)
)
;
}
else
{
this
-
>
AssignStatus
(
std
:
:
move
(
other
)
.
status
(
)
)
;
}
}
template
<
typename
T
>
template
<
typename
.
.
.
Args
>
StatusOr
<
T
>
:
:
StatusOr
(
absl
:
:
in_place_t
Args
&
&
.
.
.
args
)
:
Base
(
absl
:
:
in_place
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
template
<
typename
T
>
template
<
typename
U
typename
.
.
.
Args
>
StatusOr
<
T
>
:
:
StatusOr
(
absl
:
:
in_place_t
std
:
:
initializer_list
<
U
>
ilist
Args
&
&
.
.
.
args
)
:
Base
(
absl
:
:
in_place
ilist
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
template
<
typename
T
>
const
Status
&
StatusOr
<
T
>
:
:
status
(
)
const
&
{
return
this
-
>
status_
;
}
template
<
typename
T
>
Status
StatusOr
<
T
>
:
:
status
(
)
&
&
{
return
ok
(
)
?
OkStatus
(
)
:
std
:
:
move
(
this
-
>
status_
)
;
}
template
<
typename
T
>
const
T
&
StatusOr
<
T
>
:
:
value
(
)
const
&
{
if
(
!
this
-
>
ok
(
)
)
internal_statusor
:
:
ThrowBadStatusOrAccess
(
this
-
>
status_
)
;
return
this
-
>
data_
;
}
template
<
typename
T
>
T
&
StatusOr
<
T
>
:
:
value
(
)
&
{
if
(
!
this
-
>
ok
(
)
)
internal_statusor
:
:
ThrowBadStatusOrAccess
(
this
-
>
status_
)
;
return
this
-
>
data_
;
}
template
<
typename
T
>
const
T
&
&
StatusOr
<
T
>
:
:
value
(
)
const
&
&
{
if
(
!
this
-
>
ok
(
)
)
{
internal_statusor
:
:
ThrowBadStatusOrAccess
(
std
:
:
move
(
this
-
>
status_
)
)
;
}
return
std
:
:
move
(
this
-
>
data_
)
;
}
template
<
typename
T
>
T
&
&
StatusOr
<
T
>
:
:
value
(
)
&
&
{
if
(
!
this
-
>
ok
(
)
)
{
internal_statusor
:
:
ThrowBadStatusOrAccess
(
std
:
:
move
(
this
-
>
status_
)
)
;
}
return
std
:
:
move
(
this
-
>
data_
)
;
}
template
<
typename
T
>
const
T
&
StatusOr
<
T
>
:
:
operator
*
(
)
const
&
{
this
-
>
EnsureOk
(
)
;
return
this
-
>
data_
;
}
template
<
typename
T
>
T
&
StatusOr
<
T
>
:
:
operator
*
(
)
&
{
this
-
>
EnsureOk
(
)
;
return
this
-
>
data_
;
}
template
<
typename
T
>
const
T
&
&
StatusOr
<
T
>
:
:
operator
*
(
)
const
&
&
{
this
-
>
EnsureOk
(
)
;
return
std
:
:
move
(
this
-
>
data_
)
;
}
template
<
typename
T
>
T
&
&
StatusOr
<
T
>
:
:
operator
*
(
)
&
&
{
this
-
>
EnsureOk
(
)
;
return
std
:
:
move
(
this
-
>
data_
)
;
}
template
<
typename
T
>
absl
:
:
Nonnull
<
const
T
*
>
StatusOr
<
T
>
:
:
operator
-
>
(
)
const
{
this
-
>
EnsureOk
(
)
;
return
&
this
-
>
data_
;
}
template
<
typename
T
>
absl
:
:
Nonnull
<
T
*
>
StatusOr
<
T
>
:
:
operator
-
>
(
)
{
this
-
>
EnsureOk
(
)
;
return
&
this
-
>
data_
;
}
template
<
typename
T
>
template
<
typename
U
>
T
StatusOr
<
T
>
:
:
value_or
(
U
&
&
default_value
)
const
&
{
if
(
ok
(
)
)
{
return
this
-
>
data_
;
}
return
std
:
:
forward
<
U
>
(
default_value
)
;
}
template
<
typename
T
>
template
<
typename
U
>
T
StatusOr
<
T
>
:
:
value_or
(
U
&
&
default_value
)
&
&
{
if
(
ok
(
)
)
{
return
std
:
:
move
(
this
-
>
data_
)
;
}
return
std
:
:
forward
<
U
>
(
default_value
)
;
}
template
<
typename
T
>
void
StatusOr
<
T
>
:
:
IgnoreError
(
)
const
{
}
ABSL_NAMESPACE_END
}
#
endif
