#
ifndef
ABSL_STATUS_INTERNAL_STATUS_INTERNAL_H_
#
define
ABSL_STATUS_INTERNAL_STATUS_INTERNAL_H_
#
include
<
atomic
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
nullability
.
h
"
#
include
"
absl
/
container
/
inlined_vector
.
h
"
#
include
"
absl
/
strings
/
cord
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
ifndef
SWIG
namespace
absl
{
ABSL_NAMESPACE_BEGIN
#
if
ABSL_HAVE_CPP_ATTRIBUTE
(
nodiscard
)
class
[
[
nodiscard
]
]
ABSL_ATTRIBUTE_TRIVIAL_ABI
Status
;
#
else
class
ABSL_MUST_USE_RESULT
ABSL_ATTRIBUTE_TRIVIAL_ABI
Status
;
#
endif
ABSL_NAMESPACE_END
}
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
enum
class
StatusCode
:
int
;
enum
class
StatusToStringMode
:
int
;
namespace
status_internal
{
struct
Payload
{
std
:
:
string
type_url
;
absl
:
:
Cord
payload
;
}
;
using
Payloads
=
absl
:
:
InlinedVector
<
Payload
1
>
;
class
StatusRep
{
public
:
StatusRep
(
absl
:
:
StatusCode
code_arg
absl
:
:
string_view
message_arg
std
:
:
unique_ptr
<
status_internal
:
:
Payloads
>
payloads_arg
)
:
ref_
(
int32_t
{
1
}
)
code_
(
code_arg
)
message_
(
message_arg
)
payloads_
(
std
:
:
move
(
payloads_arg
)
)
{
}
absl
:
:
StatusCode
code
(
)
const
{
return
code_
;
}
const
std
:
:
string
&
message
(
)
const
{
return
message_
;
}
void
Ref
(
)
const
{
ref_
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
}
void
Unref
(
)
const
;
absl
:
:
optional
<
absl
:
:
Cord
>
GetPayload
(
absl
:
:
string_view
type_url
)
const
;
void
SetPayload
(
absl
:
:
string_view
type_url
absl
:
:
Cord
payload
)
;
struct
EraseResult
{
bool
erased
;
uintptr_t
new_rep
;
}
;
EraseResult
ErasePayload
(
absl
:
:
string_view
type_url
)
;
void
ForEachPayload
(
absl
:
:
FunctionRef
<
void
(
absl
:
:
string_view
const
absl
:
:
Cord
&
)
>
visitor
)
const
;
std
:
:
string
ToString
(
StatusToStringMode
mode
)
const
;
bool
operator
=
=
(
const
StatusRep
&
other
)
const
;
bool
operator
!
=
(
const
StatusRep
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
absl
:
:
Nonnull
<
StatusRep
*
>
CloneAndUnref
(
)
const
;
private
:
mutable
std
:
:
atomic
<
int32_t
>
ref_
;
absl
:
:
StatusCode
code_
;
std
:
:
string
message_
;
std
:
:
unique_ptr
<
status_internal
:
:
Payloads
>
payloads_
;
}
;
absl
:
:
StatusCode
MapToLocalCode
(
int
value
)
;
ABSL_ATTRIBUTE_PURE_FUNCTION
absl
:
:
Nonnull
<
const
char
*
>
MakeCheckFailString
(
absl
:
:
Nonnull
<
const
absl
:
:
Status
*
>
status
absl
:
:
Nonnull
<
const
char
*
>
prefix
)
;
}
ABSL_NAMESPACE_END
}
#
endif
