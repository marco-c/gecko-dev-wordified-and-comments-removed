#
ifndef
ABSL_DEBUGGING_INTERNAL_STACKTRACE_ARM_INL_H_
#
define
ABSL_DEBUGGING_INTERNAL_STACKTRACE_ARM_INL_H_
#
include
<
cstdint
>
#
include
"
absl
/
debugging
/
internal
/
addresses
.
h
"
#
include
"
absl
/
debugging
/
stacktrace
.
h
"
template
<
bool
STRICT_UNWINDING
>
static
void
*
*
NextStackFrame
(
void
*
*
old_sp
)
{
void
*
*
new_sp
=
(
void
*
*
)
old_sp
[
-
1
]
;
if
(
STRICT_UNWINDING
)
{
if
(
new_sp
<
=
old_sp
)
return
nullptr
;
if
(
(
uintptr_t
)
new_sp
-
(
uintptr_t
)
old_sp
>
100000
)
return
nullptr
;
}
else
{
if
(
new_sp
=
=
old_sp
)
return
nullptr
;
if
(
(
new_sp
>
old_sp
)
&
&
(
(
uintptr_t
)
new_sp
-
(
uintptr_t
)
old_sp
>
1000000
)
)
return
nullptr
;
}
if
(
(
uintptr_t
)
new_sp
&
(
sizeof
(
void
*
)
-
1
)
)
return
nullptr
;
return
new_sp
;
}
#
ifdef
__GNUC__
void
StacktraceArmDummyFunction
(
)
__attribute__
(
(
noinline
)
)
;
void
StacktraceArmDummyFunction
(
)
{
__asm__
volatile
(
"
"
)
;
}
#
else
#
error
StacktraceArmDummyFunction
(
)
needs
to
be
ported
to
this
platform
.
#
endif
template
<
bool
IS_STACK_FRAMES
bool
IS_WITH_CONTEXT
>
static
int
UnwindImpl
(
void
*
*
result
uintptr_t
*
frames
int
*
sizes
int
max_depth
int
skip_count
const
void
*
int
*
min_dropped_frames
)
{
#
ifdef
__GNUC__
void
*
*
sp
=
reinterpret_cast
<
void
*
*
>
(
__builtin_frame_address
(
0
)
)
;
#
else
#
error
reading
stack
point
not
yet
supported
on
this
platform
.
#
endif
StacktraceArmDummyFunction
(
)
;
int
n
=
0
;
while
(
sp
&
&
n
<
max_depth
)
{
void
*
*
next_sp
=
NextStackFrame
<
!
IS_STACK_FRAMES
>
(
sp
)
;
if
(
skip_count
>
0
)
{
skip_count
-
-
;
}
else
{
result
[
n
]
=
*
sp
;
if
(
IS_STACK_FRAMES
)
{
if
(
frames
!
=
nullptr
)
{
frames
[
n
]
=
absl
:
:
debugging_internal
:
:
StripPointerMetadata
(
sp
)
+
1
*
sizeof
(
void
*
)
;
}
if
(
sizes
!
=
nullptr
)
{
if
(
next_sp
>
sp
)
{
sizes
[
n
]
=
absl
:
:
debugging_internal
:
:
StripPointerMetadata
(
next_sp
)
-
absl
:
:
debugging_internal
:
:
StripPointerMetadata
(
sp
)
;
}
else
{
sizes
[
n
]
=
0
;
}
}
}
n
+
+
;
}
sp
=
next_sp
;
}
if
(
min_dropped_frames
!
=
nullptr
)
{
const
int
kMaxUnwind
=
200
;
int
num_dropped_frames
=
0
;
for
(
int
j
=
0
;
sp
!
=
nullptr
&
&
j
<
kMaxUnwind
;
j
+
+
)
{
if
(
skip_count
>
0
)
{
skip_count
-
-
;
}
else
{
num_dropped_frames
+
+
;
}
sp
=
NextStackFrame
<
!
IS_STACK_FRAMES
>
(
sp
)
;
}
*
min_dropped_frames
=
num_dropped_frames
;
}
return
n
;
}
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
debugging_internal
{
bool
StackTraceWorksForTest
(
)
{
return
false
;
}
}
ABSL_NAMESPACE_END
}
#
endif
