#
include
"
absl
/
debugging
/
internal
/
decode_rust_punycode
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
nullability
.
h
"
#
include
"
absl
/
debugging
/
internal
/
bounded_utf8_length_sequence
.
h
"
#
include
"
absl
/
debugging
/
internal
/
utf8_for_code_point
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
debugging_internal
{
namespace
{
constexpr
uint32_t
kMaxChars
=
256
;
constexpr
uint32_t
kBase
=
36
kTMin
=
1
kTMax
=
26
kSkew
=
38
kDamp
=
700
;
constexpr
uint32_t
kMaxCodePoint
=
0x10ffff
;
constexpr
uint32_t
kMaxI
=
1
<
<
30
;
bool
ConsumeOptionalAsciiPrefix
(
const
char
*
&
punycode_begin
const
char
*
const
punycode_end
char
*
const
out_begin
char
*
const
out_end
uint32_t
&
num_ascii_chars
)
{
num_ascii_chars
=
0
;
int
last_underscore
=
-
1
;
for
(
int
i
=
0
;
i
<
punycode_end
-
punycode_begin
;
+
+
i
)
{
const
char
c
=
punycode_begin
[
i
]
;
if
(
c
=
=
'
_
'
)
{
last_underscore
=
i
;
continue
;
}
if
(
'
a
'
<
=
c
&
&
c
<
=
'
z
'
)
continue
;
if
(
'
A
'
<
=
c
&
&
c
<
=
'
Z
'
)
continue
;
if
(
'
0
'
<
=
c
&
&
c
<
=
'
9
'
)
continue
;
return
false
;
}
if
(
last_underscore
<
0
)
return
true
;
if
(
last_underscore
=
=
0
)
return
false
;
if
(
last_underscore
+
1
>
out_end
-
out_begin
)
return
false
;
num_ascii_chars
=
static_cast
<
uint32_t
>
(
last_underscore
)
;
std
:
:
memcpy
(
out_begin
punycode_begin
num_ascii_chars
)
;
out_begin
[
num_ascii_chars
]
=
'
\
0
'
;
punycode_begin
+
=
num_ascii_chars
+
1
;
return
true
;
}
int
DigitValue
(
char
c
)
{
if
(
'
0
'
<
=
c
&
&
c
<
=
'
9
'
)
return
c
-
'
0
'
+
26
;
if
(
'
a
'
<
=
c
&
&
c
<
=
'
z
'
)
return
c
-
'
a
'
;
if
(
'
A
'
<
=
c
&
&
c
<
=
'
Z
'
)
return
c
-
'
A
'
;
return
-
1
;
}
bool
ScanNextDelta
(
const
char
*
&
punycode_begin
const
char
*
const
punycode_end
uint32_t
bias
uint32_t
&
i
)
{
uint64_t
w
=
1
;
for
(
uint32_t
k
=
kBase
;
punycode_begin
!
=
punycode_end
;
k
+
=
kBase
)
{
const
int
digit_value
=
DigitValue
(
*
punycode_begin
+
+
)
;
if
(
digit_value
<
0
)
return
false
;
const
uint64_t
new_i
=
i
+
static_cast
<
uint64_t
>
(
digit_value
)
*
w
;
static_assert
(
kMaxI
>
=
kMaxChars
*
kMaxCodePoint
"
kMaxI
is
too
small
to
prevent
spurious
failures
on
good
input
"
)
;
if
(
new_i
>
kMaxI
)
return
false
;
static_assert
(
kMaxI
<
(
uint64_t
{
1
}
<
<
32
)
"
Make
kMaxI
smaller
or
i
64
bits
wide
to
prevent
silent
wraparound
"
)
;
i
=
static_cast
<
uint32_t
>
(
new_i
)
;
uint32_t
t
;
if
(
k
<
=
bias
+
kTMin
)
{
t
=
kTMin
;
}
else
if
(
k
>
=
bias
+
kTMax
)
{
t
=
kTMax
;
}
else
{
t
=
k
-
bias
;
}
if
(
static_cast
<
uint32_t
>
(
digit_value
)
<
t
)
return
true
;
w
*
=
kBase
-
t
;
}
return
false
;
}
}
absl
:
:
Nullable
<
char
*
>
DecodeRustPunycode
(
DecodeRustPunycodeOptions
options
)
{
const
char
*
punycode_begin
=
options
.
punycode_begin
;
const
char
*
const
punycode_end
=
options
.
punycode_end
;
char
*
const
out_begin
=
options
.
out_begin
;
char
*
const
out_end
=
options
.
out_end
;
const
size_t
out_size
=
static_cast
<
size_t
>
(
out_end
-
out_begin
)
;
if
(
out_size
=
=
0
)
return
nullptr
;
*
out_begin
=
'
\
0
'
;
uint32_t
n
=
128
i
=
0
bias
=
72
num_chars
=
0
;
if
(
!
ConsumeOptionalAsciiPrefix
(
punycode_begin
punycode_end
out_begin
out_end
num_chars
)
)
{
return
nullptr
;
}
uint32_t
total_utf8_bytes
=
num_chars
;
BoundedUtf8LengthSequence
<
kMaxChars
>
utf8_lengths
;
while
(
punycode_begin
!
=
punycode_end
)
{
if
(
num_chars
>
=
kMaxChars
)
return
nullptr
;
const
uint32_t
old_i
=
i
;
if
(
!
ScanNextDelta
(
punycode_begin
punycode_end
bias
i
)
)
return
nullptr
;
uint32_t
delta
=
i
-
old_i
;
delta
/
=
(
old_i
=
=
0
?
kDamp
:
2
)
;
delta
+
=
delta
/
(
num_chars
+
1
)
;
bias
=
0
;
while
(
delta
>
(
(
kBase
-
kTMin
)
*
kTMax
)
/
2
)
{
delta
/
=
kBase
-
kTMin
;
bias
+
=
kBase
;
}
bias
+
=
(
(
kBase
-
kTMin
+
1
)
*
delta
)
/
(
delta
+
kSkew
)
;
static_assert
(
kMaxI
+
kMaxCodePoint
<
(
uint64_t
{
1
}
<
<
32
)
"
Make
kMaxI
smaller
or
n
64
bits
wide
to
prevent
silent
wraparound
"
)
;
n
+
=
i
/
(
num_chars
+
1
)
;
i
%
=
num_chars
+
1
;
Utf8ForCodePoint
utf8_for_code_point
(
n
)
;
if
(
!
utf8_for_code_point
.
ok
(
)
)
return
nullptr
;
if
(
total_utf8_bytes
+
utf8_for_code_point
.
length
+
1
>
out_size
)
{
return
nullptr
;
}
uint32_t
n_index
=
utf8_lengths
.
InsertAndReturnSumOfPredecessors
(
i
utf8_for_code_point
.
length
)
;
std
:
:
memmove
(
out_begin
+
n_index
+
utf8_for_code_point
.
length
out_begin
+
n_index
total_utf8_bytes
+
1
-
n_index
)
;
std
:
:
memcpy
(
out_begin
+
n_index
utf8_for_code_point
.
bytes
utf8_for_code_point
.
length
)
;
total_utf8_bytes
+
=
utf8_for_code_point
.
length
;
+
+
num_chars
;
+
+
i
;
}
return
out_begin
+
total_utf8_bytes
;
}
}
ABSL_NAMESPACE_END
}
