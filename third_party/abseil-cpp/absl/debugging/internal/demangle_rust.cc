#
include
"
absl
/
debugging
/
internal
/
demangle_rust
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
limits
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
debugging
/
internal
/
decode_rust_punycode
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
debugging_internal
{
namespace
{
constexpr
int
kMaxReturns
=
1
<
<
17
;
bool
IsDigit
(
char
c
)
{
return
'
0
'
<
=
c
&
&
c
<
=
'
9
'
;
}
bool
IsLower
(
char
c
)
{
return
'
a
'
<
=
c
&
&
c
<
=
'
z
'
;
}
bool
IsUpper
(
char
c
)
{
return
'
A
'
<
=
c
&
&
c
<
=
'
Z
'
;
}
bool
IsAlpha
(
char
c
)
{
return
IsLower
(
c
)
|
|
IsUpper
(
c
)
;
}
bool
IsIdentifierChar
(
char
c
)
{
return
IsAlpha
(
c
)
|
|
IsDigit
(
c
)
|
|
c
=
=
'
_
'
;
}
bool
IsLowerHexDigit
(
char
c
)
{
return
IsDigit
(
c
)
|
|
(
'
a
'
<
=
c
&
&
c
<
=
'
f
'
)
;
}
const
char
*
BasicTypeName
(
char
c
)
{
switch
(
c
)
{
case
'
a
'
:
return
"
i8
"
;
case
'
b
'
:
return
"
bool
"
;
case
'
c
'
:
return
"
char
"
;
case
'
d
'
:
return
"
f64
"
;
case
'
e
'
:
return
"
str
"
;
case
'
f
'
:
return
"
f32
"
;
case
'
h
'
:
return
"
u8
"
;
case
'
i
'
:
return
"
isize
"
;
case
'
j
'
:
return
"
usize
"
;
case
'
l
'
:
return
"
i32
"
;
case
'
m
'
:
return
"
u32
"
;
case
'
n
'
:
return
"
i128
"
;
case
'
o
'
:
return
"
u128
"
;
case
'
p
'
:
return
"
_
"
;
case
'
s
'
:
return
"
i16
"
;
case
'
t
'
:
return
"
u16
"
;
case
'
u
'
:
return
"
(
)
"
;
case
'
v
'
:
return
"
.
.
.
"
;
case
'
x
'
:
return
"
i64
"
;
case
'
y
'
:
return
"
u64
"
;
case
'
z
'
:
return
"
!
"
;
}
return
nullptr
;
}
class
RustSymbolParser
{
public
:
RustSymbolParser
(
const
char
*
encoding
char
*
out
char
*
const
out_end
)
:
encoding_
(
encoding
)
out_
(
out
)
out_end_
(
out_end
)
{
if
(
out_
!
=
out_end_
)
*
out_
=
'
\
0
'
;
}
[
[
nodiscard
]
]
bool
Parse
(
)
&
&
{
#
define
ABSL_DEMANGLER_RECURSE
(
callee
caller
)
\
do
{
\
if
(
recursion_depth_
=
=
kStackSize
)
return
false
;
\
/
*
The
next
continue
will
switch
on
this
saved
value
.
.
.
*
/
\
recursion_stack_
[
recursion_depth_
+
+
]
=
caller
;
\
goto
callee
;
\
/
*
.
.
.
and
will
land
here
resuming
the
suspended
code
.
*
/
\
case
caller
:
{
}
\
}
while
(
0
)
int
iter
=
0
;
goto
whole_encoding
;
for
(
;
iter
<
kMaxReturns
&
&
recursion_depth_
>
0
;
+
+
iter
)
{
switch
(
recursion_stack_
[
-
-
recursion_depth_
]
)
{
whole_encoding
:
if
(
!
Eat
(
'
_
'
)
|
|
!
Eat
(
'
R
'
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
path
kInstantiatingCrate
)
;
if
(
IsAlpha
(
Peek
(
)
)
)
{
+
+
silence_depth_
;
ABSL_DEMANGLER_RECURSE
(
path
kVendorSpecificSuffix
)
;
}
switch
(
Take
(
)
)
{
case
'
.
'
:
case
'
'
:
case
'
\
0
'
:
return
true
;
}
return
false
;
path
:
switch
(
Take
(
)
)
{
case
'
C
'
:
goto
crate_root
;
case
'
M
'
:
goto
inherent_impl
;
case
'
X
'
:
goto
trait_impl
;
case
'
Y
'
:
goto
trait_definition
;
case
'
N
'
:
goto
nested_path
;
case
'
I
'
:
goto
generic_args
;
case
'
B
'
:
goto
path_backref
;
default
:
return
false
;
}
crate_root
:
if
(
!
ParseIdentifier
(
)
)
return
false
;
continue
;
inherent_impl
:
if
(
!
Emit
(
"
<
"
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
impl_path
kInherentImplType
)
;
ABSL_DEMANGLER_RECURSE
(
type
kInherentImplEnding
)
;
if
(
!
Emit
(
"
>
"
)
)
return
false
;
continue
;
trait_impl
:
if
(
!
Emit
(
"
<
"
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
impl_path
kTraitImplType
)
;
ABSL_DEMANGLER_RECURSE
(
type
kTraitImplInfix
)
;
if
(
!
Emit
(
"
as
"
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
path
kTraitImplEnding
)
;
if
(
!
Emit
(
"
>
"
)
)
return
false
;
continue
;
impl_path
:
+
+
silence_depth_
;
{
int
ignored_disambiguator
;
if
(
!
ParseDisambiguator
(
ignored_disambiguator
)
)
return
false
;
}
ABSL_DEMANGLER_RECURSE
(
path
kImplPathEnding
)
;
-
-
silence_depth_
;
continue
;
trait_definition
:
if
(
!
Emit
(
"
<
"
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
type
kTraitDefinitionInfix
)
;
if
(
!
Emit
(
"
as
"
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
path
kTraitDefinitionEnding
)
;
if
(
!
Emit
(
"
>
"
)
)
return
false
;
continue
;
nested_path
:
if
(
IsUpper
(
Peek
(
)
)
)
{
if
(
!
PushNamespace
(
Take
(
)
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
path
kIdentifierInUppercaseNamespace
)
;
if
(
!
Emit
(
"
:
:
"
)
)
return
false
;
if
(
!
ParseIdentifier
(
PopNamespace
(
)
)
)
return
false
;
continue
;
}
if
(
IsLower
(
Take
(
)
)
)
{
ABSL_DEMANGLER_RECURSE
(
path
kIdentifierInLowercaseNamespace
)
;
if
(
!
Emit
(
"
:
:
"
)
)
return
false
;
if
(
!
ParseIdentifier
(
)
)
return
false
;
continue
;
}
return
false
;
type
:
if
(
IsLower
(
Peek
(
)
)
)
{
const
char
*
type_name
=
BasicTypeName
(
Take
(
)
)
;
if
(
type_name
=
=
nullptr
|
|
!
Emit
(
type_name
)
)
return
false
;
continue
;
}
if
(
Eat
(
'
A
'
)
)
{
if
(
!
Emit
(
"
[
"
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
type
kArraySize
)
;
if
(
!
Emit
(
"
;
"
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
constant
kFinishArray
)
;
if
(
!
Emit
(
"
]
"
)
)
return
false
;
continue
;
}
if
(
Eat
(
'
S
'
)
)
{
if
(
!
Emit
(
"
[
"
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
type
kSliceEnding
)
;
if
(
!
Emit
(
"
]
"
)
)
return
false
;
continue
;
}
if
(
Eat
(
'
T
'
)
)
goto
tuple_type
;
if
(
Eat
(
'
R
'
)
)
{
if
(
!
Emit
(
"
&
"
)
)
return
false
;
if
(
!
ParseOptionalLifetime
(
)
)
return
false
;
goto
type
;
}
if
(
Eat
(
'
Q
'
)
)
{
if
(
!
Emit
(
"
&
mut
"
)
)
return
false
;
if
(
!
ParseOptionalLifetime
(
)
)
return
false
;
goto
type
;
}
if
(
Eat
(
'
P
'
)
)
{
if
(
!
Emit
(
"
*
const
"
)
)
return
false
;
goto
type
;
}
if
(
Eat
(
'
O
'
)
)
{
if
(
!
Emit
(
"
*
mut
"
)
)
return
false
;
goto
type
;
}
if
(
Eat
(
'
F
'
)
)
goto
fn_type
;
if
(
Eat
(
'
D
'
)
)
goto
dyn_trait_type
;
if
(
Eat
(
'
B
'
)
)
goto
type_backref
;
goto
path
;
tuple_type
:
if
(
!
Emit
(
"
(
"
)
)
return
false
;
if
(
Eat
(
'
E
'
)
)
{
if
(
!
Emit
(
"
)
"
)
)
return
false
;
continue
;
}
ABSL_DEMANGLER_RECURSE
(
type
kAfterFirstTupleElement
)
;
if
(
Eat
(
'
E
'
)
)
{
if
(
!
Emit
(
"
)
"
)
)
return
false
;
continue
;
}
if
(
!
Emit
(
"
"
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
type
kAfterSecondTupleElement
)
;
if
(
Eat
(
'
E
'
)
)
{
if
(
!
Emit
(
"
)
"
)
)
return
false
;
continue
;
}
if
(
!
Emit
(
"
"
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
type
kAfterThirdTupleElement
)
;
if
(
Eat
(
'
E
'
)
)
{
if
(
!
Emit
(
"
)
"
)
)
return
false
;
continue
;
}
if
(
!
Emit
(
"
.
.
.
)
"
)
)
return
false
;
+
+
silence_depth_
;
while
(
!
Eat
(
'
E
'
)
)
{
ABSL_DEMANGLER_RECURSE
(
type
kAfterSubsequentTupleElement
)
;
}
-
-
silence_depth_
;
continue
;
fn_type
:
if
(
!
Emit
(
"
fn
.
.
.
"
)
)
return
false
;
+
+
silence_depth_
;
if
(
!
ParseOptionalBinder
(
)
)
return
false
;
(
void
)
Eat
(
'
U
'
)
;
if
(
Eat
(
'
K
'
)
)
{
if
(
!
Eat
(
'
C
'
)
&
&
!
ParseUndisambiguatedIdentifier
(
)
)
return
false
;
}
while
(
!
Eat
(
'
E
'
)
)
{
ABSL_DEMANGLER_RECURSE
(
type
kContinueParameterList
)
;
}
ABSL_DEMANGLER_RECURSE
(
type
kFinishFn
)
;
-
-
silence_depth_
;
continue
;
dyn_trait_type
:
if
(
!
Emit
(
"
dyn
"
)
)
return
false
;
if
(
!
ParseOptionalBinder
(
)
)
return
false
;
if
(
!
Eat
(
'
E
'
)
)
{
ABSL_DEMANGLER_RECURSE
(
dyn_trait
kBeginAutoTraits
)
;
while
(
!
Eat
(
'
E
'
)
)
{
if
(
!
Emit
(
"
+
"
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
dyn_trait
kContinueAutoTraits
)
;
}
}
if
(
!
ParseRequiredLifetime
(
)
)
return
false
;
continue
;
dyn_trait
:
ABSL_DEMANGLER_RECURSE
(
path
kContinueDynTrait
)
;
if
(
Peek
(
)
=
=
'
p
'
)
{
if
(
!
Emit
(
"
<
>
"
)
)
return
false
;
+
+
silence_depth_
;
while
(
Eat
(
'
p
'
)
)
{
if
(
!
ParseUndisambiguatedIdentifier
(
)
)
return
false
;
ABSL_DEMANGLER_RECURSE
(
type
kContinueAssocBinding
)
;
}
-
-
silence_depth_
;
}
continue
;
constant
:
if
(
Eat
(
'
B
'
)
)
goto
const_backref
;
if
(
Eat
(
'
p
'
)
)
{
if
(
!
Emit
(
"
_
"
)
)
return
false
;
continue
;
}
+
+
silence_depth_
;
ABSL_DEMANGLER_RECURSE
(
type
kConstData
)
;
-
-
silence_depth_
;
if
(
Eat
(
'
n
'
)
&
&
!
EmitChar
(
'
-
'
)
)
return
false
;
if
(
!
Emit
(
"
0x
"
)
)
return
false
;
if
(
Eat
(
'
0
'
)
)
{
if
(
!
EmitChar
(
'
0
'
)
)
return
false
;
if
(
!
Eat
(
'
_
'
)
)
return
false
;
continue
;
}
while
(
IsLowerHexDigit
(
Peek
(
)
)
)
{
if
(
!
EmitChar
(
Take
(
)
)
)
return
false
;
}
if
(
!
Eat
(
'
_
'
)
)
return
false
;
continue
;
generic_args
:
ABSL_DEMANGLER_RECURSE
(
path
kBeginGenericArgList
)
;
if
(
!
Emit
(
"
:
:
<
>
"
)
)
return
false
;
+
+
silence_depth_
;
while
(
!
Eat
(
'
E
'
)
)
{
ABSL_DEMANGLER_RECURSE
(
generic_arg
kContinueGenericArgList
)
;
}
-
-
silence_depth_
;
continue
;
generic_arg
:
if
(
Peek
(
)
=
=
'
L
'
)
{
if
(
!
ParseOptionalLifetime
(
)
)
return
false
;
continue
;
}
if
(
Eat
(
'
K
'
)
)
goto
constant
;
goto
type
;
path_backref
:
if
(
!
BeginBackref
(
)
)
return
false
;
if
(
silence_depth_
=
=
0
)
{
ABSL_DEMANGLER_RECURSE
(
path
kPathBackrefEnding
)
;
}
EndBackref
(
)
;
continue
;
type_backref
:
if
(
!
BeginBackref
(
)
)
return
false
;
if
(
silence_depth_
=
=
0
)
{
ABSL_DEMANGLER_RECURSE
(
type
kTypeBackrefEnding
)
;
}
EndBackref
(
)
;
continue
;
const_backref
:
if
(
!
BeginBackref
(
)
)
return
false
;
if
(
silence_depth_
=
=
0
)
{
ABSL_DEMANGLER_RECURSE
(
constant
kConstantBackrefEnding
)
;
}
EndBackref
(
)
;
continue
;
}
}
return
false
;
}
private
:
enum
ReturnAddress
:
uint8_t
{
kInstantiatingCrate
kVendorSpecificSuffix
kIdentifierInUppercaseNamespace
kIdentifierInLowercaseNamespace
kInherentImplType
kInherentImplEnding
kTraitImplType
kTraitImplInfix
kTraitImplEnding
kImplPathEnding
kTraitDefinitionInfix
kTraitDefinitionEnding
kArraySize
kFinishArray
kSliceEnding
kAfterFirstTupleElement
kAfterSecondTupleElement
kAfterThirdTupleElement
kAfterSubsequentTupleElement
kContinueParameterList
kFinishFn
kBeginAutoTraits
kContinueAutoTraits
kContinueDynTrait
kContinueAssocBinding
kConstData
kBeginGenericArgList
kContinueGenericArgList
kPathBackrefEnding
kTypeBackrefEnding
kConstantBackrefEnding
}
;
enum
{
kStackSize
=
256
kNamespaceStackSize
=
64
kPositionStackSize
=
16
}
;
char
Peek
(
)
const
{
return
encoding_
[
pos_
]
;
}
char
Take
(
)
{
return
encoding_
[
pos_
+
+
]
;
}
[
[
nodiscard
]
]
bool
Eat
(
char
want
)
{
if
(
encoding_
[
pos_
]
!
=
want
)
return
false
;
+
+
pos_
;
return
true
;
}
[
[
nodiscard
]
]
bool
EmitChar
(
char
c
)
{
if
(
silence_depth_
>
0
)
return
true
;
if
(
out_end_
-
out_
<
2
)
return
false
;
*
out_
+
+
=
c
;
*
out_
=
'
\
0
'
;
return
true
;
}
[
[
nodiscard
]
]
bool
Emit
(
const
char
*
token
)
{
if
(
silence_depth_
>
0
)
return
true
;
const
size_t
token_length
=
std
:
:
strlen
(
token
)
;
const
size_t
bytes_to_copy
=
token_length
+
1
;
if
(
static_cast
<
size_t
>
(
out_end_
-
out_
)
<
bytes_to_copy
)
return
false
;
std
:
:
memcpy
(
out_
token
bytes_to_copy
)
;
out_
+
=
token_length
;
return
true
;
}
[
[
nodiscard
]
]
bool
EmitDisambiguator
(
int
disambiguator
)
{
if
(
disambiguator
<
0
)
return
EmitChar
(
'
?
'
)
;
if
(
disambiguator
=
=
0
)
return
EmitChar
(
'
0
'
)
;
char
digits
[
3
*
sizeof
(
disambiguator
)
]
=
{
}
;
size_t
leading_digit_index
=
sizeof
(
digits
)
-
1
;
for
(
;
disambiguator
>
0
;
disambiguator
/
=
10
)
{
digits
[
-
-
leading_digit_index
]
=
static_cast
<
char
>
(
'
0
'
+
disambiguator
%
10
)
;
}
return
Emit
(
digits
+
leading_digit_index
)
;
}
[
[
nodiscard
]
]
bool
ParseDisambiguator
(
int
&
value
)
{
value
=
-
1
;
if
(
!
Eat
(
'
s
'
)
)
{
value
=
0
;
return
true
;
}
int
base_62_value
=
0
;
if
(
!
ParseBase62Number
(
base_62_value
)
)
return
false
;
value
=
base_62_value
<
0
?
-
1
:
base_62_value
+
1
;
return
true
;
}
[
[
nodiscard
]
]
bool
ParseBase62Number
(
int
&
value
)
{
value
=
-
1
;
if
(
Eat
(
'
_
'
)
)
{
value
=
0
;
return
true
;
}
int
encoded_number
=
0
;
bool
overflowed
=
false
;
while
(
IsAlpha
(
Peek
(
)
)
|
|
IsDigit
(
Peek
(
)
)
)
{
const
char
c
=
Take
(
)
;
if
(
encoded_number
>
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
/
62
)
{
overflowed
=
true
;
}
else
{
int
digit
;
if
(
IsDigit
(
c
)
)
{
digit
=
c
-
'
0
'
;
}
else
if
(
IsLower
(
c
)
)
{
digit
=
c
-
'
a
'
+
10
;
}
else
{
digit
=
c
-
'
A
'
+
36
;
}
encoded_number
=
62
*
encoded_number
+
digit
;
}
}
if
(
!
Eat
(
'
_
'
)
)
return
false
;
if
(
!
overflowed
)
value
=
encoded_number
+
1
;
return
true
;
}
[
[
nodiscard
]
]
bool
ParseIdentifier
(
char
uppercase_namespace
=
'
\
0
'
)
{
int
disambiguator
=
0
;
if
(
!
ParseDisambiguator
(
disambiguator
)
)
return
false
;
return
ParseUndisambiguatedIdentifier
(
uppercase_namespace
disambiguator
)
;
}
[
[
nodiscard
]
]
bool
ParseUndisambiguatedIdentifier
(
char
uppercase_namespace
=
'
\
0
'
int
disambiguator
=
0
)
{
const
bool
is_punycoded
=
Eat
(
'
u
'
)
;
if
(
!
IsDigit
(
Peek
(
)
)
)
return
false
;
int
num_bytes
=
0
;
if
(
!
ParseDecimalNumber
(
num_bytes
)
)
return
false
;
(
void
)
Eat
(
'
_
'
)
;
if
(
is_punycoded
)
{
DecodeRustPunycodeOptions
options
;
options
.
punycode_begin
=
&
encoding_
[
pos_
]
;
options
.
punycode_end
=
&
encoding_
[
pos_
]
+
num_bytes
;
options
.
out_begin
=
out_
;
options
.
out_end
=
out_end_
;
out_
=
DecodeRustPunycode
(
options
)
;
if
(
out_
=
=
nullptr
)
return
false
;
pos_
+
=
static_cast
<
size_t
>
(
num_bytes
)
;
}
if
(
uppercase_namespace
!
=
'
\
0
'
)
{
switch
(
uppercase_namespace
)
{
case
'
C
'
:
if
(
!
Emit
(
"
{
closure
"
)
)
return
false
;
break
;
case
'
S
'
:
if
(
!
Emit
(
"
{
shim
"
)
)
return
false
;
break
;
default
:
if
(
!
EmitChar
(
'
{
'
)
|
|
!
EmitChar
(
uppercase_namespace
)
)
return
false
;
break
;
}
if
(
num_bytes
>
0
&
&
!
Emit
(
"
:
"
)
)
return
false
;
}
if
(
!
is_punycoded
)
{
for
(
int
i
=
0
;
i
<
num_bytes
;
+
+
i
)
{
const
char
c
=
Take
(
)
;
if
(
!
IsIdentifierChar
(
c
)
&
&
(
c
&
0x80
)
=
=
0
)
{
return
false
;
}
if
(
!
EmitChar
(
c
)
)
return
false
;
}
}
if
(
uppercase_namespace
!
=
'
\
0
'
)
{
if
(
!
EmitChar
(
'
#
'
)
)
return
false
;
if
(
!
EmitDisambiguator
(
disambiguator
)
)
return
false
;
if
(
!
EmitChar
(
'
}
'
)
)
return
false
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
ParseDecimalNumber
(
int
&
value
)
{
value
=
-
1
;
if
(
!
IsDigit
(
Peek
(
)
)
)
return
false
;
int
encoded_number
=
Take
(
)
-
'
0
'
;
if
(
encoded_number
=
=
0
)
{
value
=
0
;
return
true
;
}
while
(
IsDigit
(
Peek
(
)
)
&
&
encoded_number
<
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
/
10
)
{
encoded_number
=
10
*
encoded_number
+
(
Take
(
)
-
'
0
'
)
;
}
if
(
IsDigit
(
Peek
(
)
)
)
return
false
;
value
=
encoded_number
;
return
true
;
}
[
[
nodiscard
]
]
bool
ParseOptionalBinder
(
)
{
if
(
!
Eat
(
'
G
'
)
)
return
true
;
int
ignored_binding_count
;
return
ParseBase62Number
(
ignored_binding_count
)
;
}
[
[
nodiscard
]
]
bool
ParseOptionalLifetime
(
)
{
if
(
!
Eat
(
'
L
'
)
)
return
true
;
int
ignored_de_bruijn_index
;
return
ParseBase62Number
(
ignored_de_bruijn_index
)
;
}
[
[
nodiscard
]
]
bool
ParseRequiredLifetime
(
)
{
if
(
Peek
(
)
!
=
'
L
'
)
return
false
;
return
ParseOptionalLifetime
(
)
;
}
[
[
nodiscard
]
]
bool
PushNamespace
(
char
ns
)
{
if
(
namespace_depth_
=
=
kNamespaceStackSize
)
return
false
;
namespace_stack_
[
namespace_depth_
+
+
]
=
ns
;
return
true
;
}
char
PopNamespace
(
)
{
return
namespace_stack_
[
-
-
namespace_depth_
]
;
}
[
[
nodiscard
]
]
bool
PushPosition
(
int
position
)
{
if
(
position_depth_
=
=
kPositionStackSize
)
return
false
;
position_stack_
[
position_depth_
+
+
]
=
position
;
return
true
;
}
int
PopPosition
(
)
{
return
position_stack_
[
-
-
position_depth_
]
;
}
[
[
nodiscard
]
]
bool
BeginBackref
(
)
{
int
offset
=
0
;
const
int
offset_of_this_backref
=
pos_
-
2
-
1
;
if
(
!
ParseBase62Number
(
offset
)
|
|
offset
<
0
|
|
offset
>
=
offset_of_this_backref
)
{
return
false
;
}
offset
+
=
2
;
if
(
!
PushPosition
(
pos_
)
)
return
false
;
pos_
=
offset
;
return
true
;
}
void
EndBackref
(
)
{
pos_
=
PopPosition
(
)
;
}
ReturnAddress
recursion_stack_
[
kStackSize
]
=
{
}
;
int
recursion_depth_
=
0
;
char
namespace_stack_
[
kNamespaceStackSize
]
=
{
}
;
int
namespace_depth_
=
0
;
int
position_stack_
[
kPositionStackSize
]
=
{
}
;
int
position_depth_
=
0
;
int
silence_depth_
=
0
;
int
pos_
=
0
;
const
char
*
encoding_
=
nullptr
;
char
*
out_
=
nullptr
;
char
*
out_end_
=
nullptr
;
}
;
}
bool
DemangleRustSymbolEncoding
(
const
char
*
mangled
char
*
out
size_t
out_size
)
{
return
RustSymbolParser
(
mangled
out
out
+
out_size
)
.
Parse
(
)
;
}
}
ABSL_NAMESPACE_END
}
