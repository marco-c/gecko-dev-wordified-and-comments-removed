#
ifndef
ABSL_DEBUGGING_INTERNAL_STACKTRACE_GENERIC_INL_H_
#
define
ABSL_DEBUGGING_INTERNAL_STACKTRACE_GENERIC_INL_H_
#
include
<
execinfo
.
h
>
#
include
<
atomic
>
#
include
<
cstring
>
#
include
"
absl
/
debugging
/
stacktrace
.
h
"
#
include
"
absl
/
base
/
attributes
.
h
"
static
__thread
int
recursive
=
0
;
static
std
:
:
atomic
<
bool
>
disable_stacktraces
(
true
)
;
template
<
bool
IS_STACK_FRAMES
bool
IS_WITH_CONTEXT
>
static
int
UnwindImpl
(
void
*
*
result
uintptr_t
*
frames
int
*
sizes
int
max_depth
int
skip_count
const
void
*
ucp
int
*
min_dropped_frames
)
{
if
(
recursive
|
|
disable_stacktraces
.
load
(
std
:
:
memory_order_relaxed
)
)
{
return
0
;
}
+
+
recursive
;
static_cast
<
void
>
(
ucp
)
;
static
const
int
kStackLength
=
64
;
void
*
stack
[
kStackLength
]
;
int
size
;
size
=
backtrace
(
stack
kStackLength
)
;
skip_count
+
+
;
int
result_count
=
size
-
skip_count
;
if
(
result_count
<
0
)
result_count
=
0
;
if
(
result_count
>
max_depth
)
result_count
=
max_depth
;
for
(
int
i
=
0
;
i
<
result_count
;
i
+
+
)
result
[
i
]
=
stack
[
i
+
skip_count
]
;
if
(
IS_STACK_FRAMES
)
{
if
(
frames
!
=
nullptr
)
{
memset
(
frames
0
sizeof
(
*
frames
)
*
static_cast
<
size_t
>
(
result_count
)
)
;
}
if
(
sizes
!
=
nullptr
)
{
memset
(
sizes
0
sizeof
(
*
sizes
)
*
static_cast
<
size_t
>
(
result_count
)
)
;
}
}
if
(
min_dropped_frames
!
=
nullptr
)
{
if
(
size
-
skip_count
-
max_depth
>
0
)
{
*
min_dropped_frames
=
size
-
skip_count
-
max_depth
;
}
else
{
*
min_dropped_frames
=
0
;
}
}
-
-
recursive
;
return
result_count
;
}
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
debugging_internal
{
bool
StackTraceWorksForTest
(
)
{
return
false
;
}
}
ABSL_NAMESPACE_END
}
#
endif
