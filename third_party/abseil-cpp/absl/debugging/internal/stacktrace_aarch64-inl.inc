#
ifndef
ABSL_DEBUGGING_INTERNAL_STACKTRACE_AARCH64_INL_H_
#
define
ABSL_DEBUGGING_INTERNAL_STACKTRACE_AARCH64_INL_H_
#
if
defined
(
__linux__
)
#
include
<
signal
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
ucontext
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
<
atomic
>
#
include
<
cassert
>
#
include
<
cstdint
>
#
include
<
iostream
>
#
include
<
limits
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
debugging
/
internal
/
address_is_readable
.
h
"
#
include
"
absl
/
debugging
/
internal
/
vdso_support
.
h
"
#
include
"
absl
/
debugging
/
stacktrace
.
h
"
static
const
size_t
kUnknownFrameSize
=
0
;
constexpr
uintptr_t
kUnknownStackEnd
=
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
-
sizeof
(
void
*
)
;
#
if
defined
(
__linux__
)
static
const
unsigned
char
*
GetKernelRtSigreturnAddress
(
)
{
constexpr
uintptr_t
kImpossibleAddress
=
1
;
ABSL_CONST_INIT
static
std
:
:
atomic
<
uintptr_t
>
memoized
{
kImpossibleAddress
}
;
uintptr_t
address
=
memoized
.
load
(
std
:
:
memory_order_relaxed
)
;
if
(
address
!
=
kImpossibleAddress
)
{
return
reinterpret_cast
<
const
unsigned
char
*
>
(
address
)
;
}
address
=
reinterpret_cast
<
uintptr_t
>
(
nullptr
)
;
#
ifdef
ABSL_HAVE_VDSO_SUPPORT
absl
:
:
debugging_internal
:
:
VDSOSupport
vdso
;
if
(
vdso
.
IsPresent
(
)
)
{
absl
:
:
debugging_internal
:
:
VDSOSupport
:
:
SymbolInfo
symbol_info
;
auto
lookup
=
[
&
]
(
int
type
)
{
return
vdso
.
LookupSymbol
(
"
__kernel_rt_sigreturn
"
"
LINUX_2
.
6
.
39
"
type
&
symbol_info
)
;
}
;
if
(
(
!
lookup
(
STT_FUNC
)
&
&
!
lookup
(
STT_NOTYPE
)
)
|
|
symbol_info
.
address
=
=
nullptr
)
{
assert
(
false
&
&
"
VDSO
is
present
but
doesn
'
t
have
expected
symbol
"
)
;
}
else
{
if
(
reinterpret_cast
<
uintptr_t
>
(
symbol_info
.
address
)
!
=
kImpossibleAddress
)
{
address
=
reinterpret_cast
<
uintptr_t
>
(
symbol_info
.
address
)
;
}
else
{
assert
(
false
&
&
"
VDSO
returned
invalid
address
"
)
;
}
}
}
#
endif
memoized
.
store
(
address
std
:
:
memory_order_relaxed
)
;
return
reinterpret_cast
<
const
unsigned
char
*
>
(
address
)
;
}
#
endif
template
<
typename
T
>
static
size_t
ComputeStackFrameSize
(
const
T
*
low
const
T
*
high
)
{
const
char
*
low_char_ptr
=
reinterpret_cast
<
const
char
*
>
(
low
)
;
const
char
*
high_char_ptr
=
reinterpret_cast
<
const
char
*
>
(
high
)
;
return
low
<
high
?
static_cast
<
size_t
>
(
high_char_ptr
-
low_char_ptr
)
:
kUnknownFrameSize
;
}
struct
StackInfo
{
uintptr_t
stack_low
;
uintptr_t
stack_high
;
uintptr_t
sig_stack_low
;
uintptr_t
sig_stack_high
;
}
;
static
bool
InsideSignalStack
(
void
*
*
ptr
const
StackInfo
*
stack_info
)
{
uintptr_t
comparable_ptr
=
reinterpret_cast
<
uintptr_t
>
(
ptr
)
;
return
(
comparable_ptr
>
=
stack_info
-
>
sig_stack_low
&
&
comparable_ptr
<
stack_info
-
>
sig_stack_high
)
;
}
template
<
bool
STRICT_UNWINDING
bool
WITH_CONTEXT
>
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY
static
void
*
*
NextStackFrame
(
void
*
*
old_frame_pointer
const
void
*
uc
const
StackInfo
*
stack_info
)
{
void
*
*
new_frame_pointer
=
reinterpret_cast
<
void
*
*
>
(
*
old_frame_pointer
)
;
#
if
defined
(
__linux__
)
if
(
WITH_CONTEXT
&
&
uc
!
=
nullptr
)
{
if
(
old_frame_pointer
[
1
]
=
=
GetKernelRtSigreturnAddress
(
)
)
{
const
ucontext_t
*
ucv
=
static_cast
<
const
ucontext_t
*
>
(
uc
)
;
void
*
*
const
pre_signal_frame_pointer
=
reinterpret_cast
<
void
*
*
>
(
ucv
-
>
uc_mcontext
.
regs
[
29
]
)
;
if
(
pre_signal_frame_pointer
>
=
old_frame_pointer
)
{
new_frame_pointer
=
pre_signal_frame_pointer
;
}
if
(
!
absl
:
:
debugging_internal
:
:
AddressIsReadable
(
new_frame_pointer
)
)
return
nullptr
;
}
}
#
endif
if
(
(
reinterpret_cast
<
uintptr_t
>
(
new_frame_pointer
)
&
7
)
!
=
0
)
return
nullptr
;
if
(
InsideSignalStack
(
new_frame_pointer
stack_info
)
=
=
InsideSignalStack
(
old_frame_pointer
stack_info
)
)
{
const
size_t
max_size
=
STRICT_UNWINDING
?
100000
:
1000000
;
const
size_t
frame_size
=
ComputeStackFrameSize
(
old_frame_pointer
new_frame_pointer
)
;
if
(
frame_size
=
=
kUnknownFrameSize
)
return
nullptr
;
if
(
frame_size
>
max_size
)
{
size_t
stack_low
=
stack_info
-
>
stack_low
;
size_t
stack_high
=
stack_info
-
>
stack_high
;
if
(
InsideSignalStack
(
new_frame_pointer
stack_info
)
)
{
stack_low
=
stack_info
-
>
sig_stack_low
;
stack_high
=
stack_info
-
>
sig_stack_high
;
}
if
(
stack_high
<
kUnknownStackEnd
&
&
static_cast
<
size_t
>
(
getpagesize
(
)
)
<
stack_low
)
{
const
uintptr_t
new_fp_u
=
reinterpret_cast
<
uintptr_t
>
(
new_frame_pointer
)
;
if
(
!
(
stack_low
<
new_fp_u
&
&
new_fp_u
<
=
stack_high
)
)
{
return
nullptr
;
}
}
else
{
return
nullptr
;
}
}
}
return
new_frame_pointer
;
}
template
<
bool
IS_STACK_FRAMES
bool
IS_WITH_CONTEXT
>
ABSL_ATTRIBUTE_NOINLINE
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY
static
int
UnwindImpl
(
void
*
*
result
int
*
sizes
int
max_depth
int
skip_count
const
void
*
ucp
int
*
min_dropped_frames
)
{
#
ifdef
__GNUC__
void
*
*
frame_pointer
=
reinterpret_cast
<
void
*
*
>
(
__builtin_frame_address
(
0
)
)
;
#
else
#
error
reading
stack
point
not
yet
supported
on
this
platform
.
#
endif
skip_count
+
+
;
int
n
=
0
;
StackInfo
stack_info
;
stack_info
.
stack_low
=
static_cast
<
uintptr_t
>
(
getpagesize
(
)
)
;
stack_info
.
stack_high
=
kUnknownStackEnd
;
stack_info
.
sig_stack_low
=
stack_info
.
stack_low
;
stack_info
.
sig_stack_high
=
kUnknownStackEnd
;
void
*
prev_return_address
=
nullptr
;
void
*
*
prev_frame_pointer
=
nullptr
;
while
(
frame_pointer
&
&
n
<
max_depth
)
{
if
(
skip_count
>
0
)
{
skip_count
-
-
;
}
else
{
result
[
n
]
=
prev_return_address
;
if
(
IS_STACK_FRAMES
)
{
sizes
[
n
]
=
static_cast
<
int
>
(
ComputeStackFrameSize
(
prev_frame_pointer
frame_pointer
)
)
;
}
n
+
+
;
}
prev_return_address
=
frame_pointer
[
1
]
;
prev_frame_pointer
=
frame_pointer
;
frame_pointer
=
NextStackFrame
<
!
IS_STACK_FRAMES
IS_WITH_CONTEXT
>
(
frame_pointer
ucp
&
stack_info
)
;
}
if
(
min_dropped_frames
!
=
nullptr
)
{
const
int
kMaxUnwind
=
200
;
int
num_dropped_frames
=
0
;
for
(
int
j
=
0
;
frame_pointer
!
=
nullptr
&
&
j
<
kMaxUnwind
;
j
+
+
)
{
if
(
skip_count
>
0
)
{
skip_count
-
-
;
}
else
{
num_dropped_frames
+
+
;
}
frame_pointer
=
NextStackFrame
<
!
IS_STACK_FRAMES
IS_WITH_CONTEXT
>
(
frame_pointer
ucp
&
stack_info
)
;
}
*
min_dropped_frames
=
num_dropped_frames
;
}
return
n
;
}
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
debugging_internal
{
bool
StackTraceWorksForTest
(
)
{
return
true
;
}
}
ABSL_NAMESPACE_END
}
#
endif
