#
ifndef
ABSL_DEBUGGING_INTERNAL_STACKTRACE_X86_INL_INC_
#
define
ABSL_DEBUGGING_INTERNAL_STACKTRACE_X86_INL_INC_
#
if
defined
(
__linux__
)
&
&
(
defined
(
__i386__
)
|
|
defined
(
__x86_64__
)
)
#
include
<
ucontext
.
h
>
#
endif
#
if
!
defined
(
_WIN32
)
#
include
<
unistd
.
h
>
#
endif
#
include
<
cassert
>
#
include
<
cstdint
>
#
include
<
limits
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
include
"
absl
/
debugging
/
internal
/
address_is_readable
.
h
"
#
include
"
absl
/
debugging
/
internal
/
addresses
.
h
"
#
include
"
absl
/
debugging
/
internal
/
vdso_support
.
h
"
#
include
"
absl
/
debugging
/
stacktrace
.
h
"
using
absl
:
:
debugging_internal
:
:
AddressIsReadable
;
#
if
defined
(
__linux__
)
&
&
defined
(
__i386__
)
static
const
int
kMaxBytes
=
10
;
static
int
CountPushInstructions
(
const
unsigned
char
*
const
addr
)
{
int
result
=
0
;
for
(
int
i
=
0
;
i
<
kMaxBytes
;
+
+
i
)
{
if
(
addr
[
i
]
=
=
0x89
)
{
if
(
addr
[
i
+
1
]
=
=
0xE5
)
{
return
0
;
}
+
+
i
;
}
else
if
(
addr
[
i
]
=
=
0x0F
&
&
(
addr
[
i
+
1
]
=
=
0x34
|
|
addr
[
i
+
1
]
=
=
0x05
)
)
{
return
result
;
}
else
if
(
(
addr
[
i
]
&
0xF0
)
=
=
0x50
)
{
+
+
result
;
}
else
if
(
addr
[
i
]
=
=
0xCD
&
&
addr
[
i
+
1
]
=
=
0x80
)
{
assert
(
result
=
=
0
)
;
return
0
;
}
else
{
assert
(
false
&
&
"
unexpected
instruction
in
__kernel_vsyscall
"
)
;
return
0
;
}
}
assert
(
false
&
&
"
did
not
find
SYSENTER
or
SYSCALL
in
__kernel_vsyscall
"
)
;
return
0
;
}
#
endif
static
const
int
kMaxFrameBytes
=
100000
;
constexpr
uintptr_t
kUnknownStackEnd
=
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
-
sizeof
(
void
*
)
;
static
uintptr_t
GetFP
(
const
void
*
vuc
)
{
#
if
!
defined
(
__linux__
)
static_cast
<
void
>
(
vuc
)
;
#
else
if
(
vuc
!
=
nullptr
)
{
auto
*
uc
=
reinterpret_cast
<
const
ucontext_t
*
>
(
vuc
)
;
#
if
defined
(
__i386__
)
const
auto
bp
=
uc
-
>
uc_mcontext
.
gregs
[
REG_EBP
]
;
const
auto
sp
=
uc
-
>
uc_mcontext
.
gregs
[
REG_ESP
]
;
#
elif
defined
(
__x86_64__
)
const
auto
bp
=
uc
-
>
uc_mcontext
.
gregs
[
REG_RBP
]
;
const
auto
sp
=
uc
-
>
uc_mcontext
.
gregs
[
REG_RSP
]
;
#
else
const
uintptr_t
bp
=
0
;
const
uintptr_t
sp
=
0
;
#
endif
if
(
bp
>
=
sp
&
&
bp
-
sp
<
=
kMaxFrameBytes
)
return
static_cast
<
uintptr_t
>
(
bp
)
;
return
static_cast
<
uintptr_t
>
(
sp
)
;
}
#
endif
return
0
;
}
template
<
bool
STRICT_UNWINDING
bool
WITH_CONTEXT
>
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY
static
void
*
*
NextStackFrame
(
void
*
*
old_fp
const
void
*
uc
size_t
stack_low
size_t
stack_high
)
{
void
*
*
new_fp
=
(
void
*
*
)
*
old_fp
;
#
if
defined
(
__linux__
)
&
&
defined
(
__i386__
)
if
(
WITH_CONTEXT
&
&
uc
!
=
nullptr
)
{
static
int
num_push_instructions
=
-
1
;
static
const
unsigned
char
*
kernel_rt_sigreturn_address
=
nullptr
;
static
const
unsigned
char
*
kernel_vsyscall_address
=
nullptr
;
if
(
num_push_instructions
=
=
-
1
)
{
#
ifdef
ABSL_HAVE_VDSO_SUPPORT
absl
:
:
debugging_internal
:
:
VDSOSupport
vdso
;
if
(
vdso
.
IsPresent
(
)
)
{
absl
:
:
debugging_internal
:
:
VDSOSupport
:
:
SymbolInfo
rt_sigreturn_symbol_info
;
absl
:
:
debugging_internal
:
:
VDSOSupport
:
:
SymbolInfo
vsyscall_symbol_info
;
if
(
!
vdso
.
LookupSymbol
(
"
__kernel_rt_sigreturn
"
"
LINUX_2
.
5
"
STT_FUNC
&
rt_sigreturn_symbol_info
)
|
|
!
vdso
.
LookupSymbol
(
"
__kernel_vsyscall
"
"
LINUX_2
.
5
"
STT_FUNC
&
vsyscall_symbol_info
)
|
|
rt_sigreturn_symbol_info
.
address
=
=
nullptr
|
|
vsyscall_symbol_info
.
address
=
=
nullptr
)
{
assert
(
false
&
&
"
VDSO
is
present
but
doesn
'
t
have
expected
symbols
"
)
;
num_push_instructions
=
0
;
}
else
{
kernel_rt_sigreturn_address
=
reinterpret_cast
<
const
unsigned
char
*
>
(
rt_sigreturn_symbol_info
.
address
)
;
kernel_vsyscall_address
=
reinterpret_cast
<
const
unsigned
char
*
>
(
vsyscall_symbol_info
.
address
)
;
num_push_instructions
=
CountPushInstructions
(
kernel_vsyscall_address
)
;
}
}
else
{
num_push_instructions
=
0
;
}
#
else
num_push_instructions
=
0
;
#
endif
}
if
(
num_push_instructions
!
=
0
&
&
kernel_rt_sigreturn_address
!
=
nullptr
&
&
old_fp
[
1
]
=
=
kernel_rt_sigreturn_address
)
{
const
ucontext_t
*
ucv
=
static_cast
<
const
ucontext_t
*
>
(
uc
)
;
void
*
*
const
reg_ebp
=
reinterpret_cast
<
void
*
*
>
(
ucv
-
>
uc_mcontext
.
gregs
[
REG_EBP
]
)
;
const
unsigned
char
*
const
reg_eip
=
reinterpret_cast
<
unsigned
char
*
>
(
ucv
-
>
uc_mcontext
.
gregs
[
REG_EIP
]
)
;
if
(
new_fp
=
=
reg_ebp
&
&
kernel_vsyscall_address
<
=
reg_eip
&
&
reg_eip
-
kernel_vsyscall_address
<
kMaxBytes
)
{
void
*
*
const
reg_esp
=
reinterpret_cast
<
void
*
*
>
(
ucv
-
>
uc_mcontext
.
gregs
[
REG_ESP
]
)
;
if
(
reg_esp
&
&
(
(
uintptr_t
)
reg_esp
&
(
sizeof
(
reg_esp
)
-
1
)
)
=
=
0
)
{
void
*
const
reg_esp2
=
reg_esp
[
num_push_instructions
-
1
]
;
if
(
AddressIsReadable
(
reg_esp2
)
)
{
new_fp
=
reinterpret_cast
<
void
*
*
>
(
reg_esp2
)
;
}
}
}
}
}
#
endif
const
uintptr_t
old_fp_u
=
reinterpret_cast
<
uintptr_t
>
(
old_fp
)
;
const
uintptr_t
new_fp_u
=
reinterpret_cast
<
uintptr_t
>
(
new_fp
)
;
if
(
STRICT_UNWINDING
&
&
(
!
WITH_CONTEXT
|
|
uc
=
=
nullptr
|
|
new_fp_u
!
=
GetFP
(
uc
)
)
)
{
if
(
new_fp_u
<
=
old_fp_u
)
return
nullptr
;
if
(
new_fp_u
-
old_fp_u
>
kMaxFrameBytes
)
{
if
(
stack_high
<
kUnknownStackEnd
&
&
static_cast
<
size_t
>
(
getpagesize
(
)
)
<
stack_low
)
{
if
(
!
(
stack_low
<
new_fp_u
&
&
new_fp_u
<
=
stack_high
)
)
{
return
nullptr
;
}
}
else
{
return
nullptr
;
}
}
if
(
stack_low
<
old_fp_u
&
&
old_fp_u
<
=
stack_high
)
{
if
(
!
(
stack_low
<
new_fp_u
&
&
new_fp_u
<
=
stack_high
)
)
{
return
nullptr
;
}
}
else
{
}
}
else
{
if
(
new_fp
=
=
nullptr
)
return
nullptr
;
if
(
new_fp
=
=
old_fp
)
return
nullptr
;
}
if
(
new_fp_u
&
(
sizeof
(
void
*
)
-
1
)
)
return
nullptr
;
#
ifdef
__i386__
if
(
new_fp_u
>
=
0xffffe000
)
return
nullptr
;
#
endif
#
if
!
defined
(
_WIN32
)
if
(
!
STRICT_UNWINDING
)
{
if
(
!
AddressIsReadable
(
new_fp
)
)
{
return
nullptr
;
}
}
#
endif
return
new_fp
;
}
template
<
bool
IS_STACK_FRAMES
bool
IS_WITH_CONTEXT
>
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY
ABSL_ATTRIBUTE_NOINLINE
static
int
UnwindImpl
(
void
*
*
result
uintptr_t
*
frames
int
*
sizes
int
max_depth
int
skip_count
const
void
*
ucp
int
*
min_dropped_frames
)
{
int
n
=
0
;
void
*
*
fp
=
reinterpret_cast
<
void
*
*
>
(
__builtin_frame_address
(
0
)
)
;
size_t
stack_low
=
static_cast
<
size_t
>
(
getpagesize
(
)
)
;
size_t
stack_high
=
kUnknownStackEnd
;
while
(
fp
&
&
n
<
max_depth
)
{
if
(
*
(
fp
+
1
)
=
=
reinterpret_cast
<
void
*
>
(
0
)
)
{
break
;
}
void
*
*
next_fp
=
NextStackFrame
<
!
IS_STACK_FRAMES
IS_WITH_CONTEXT
>
(
fp
ucp
stack_low
stack_high
)
;
if
(
skip_count
>
0
)
{
skip_count
-
-
;
}
else
{
result
[
n
]
=
*
(
fp
+
1
)
;
if
(
IS_STACK_FRAMES
)
{
if
(
frames
)
{
frames
[
n
]
=
absl
:
:
debugging_internal
:
:
StripPointerMetadata
(
fp
)
+
2
*
sizeof
(
void
*
)
;
}
if
(
sizes
)
{
if
(
next_fp
>
fp
)
{
sizes
[
n
]
=
static_cast
<
int
>
(
absl
:
:
debugging_internal
:
:
StripPointerMetadata
(
next_fp
)
-
absl
:
:
debugging_internal
:
:
StripPointerMetadata
(
fp
)
)
;
}
else
{
sizes
[
n
]
=
0
;
}
}
}
n
+
+
;
}
fp
=
next_fp
;
}
if
(
min_dropped_frames
!
=
nullptr
)
{
const
int
kMaxUnwind
=
1000
;
int
num_dropped_frames
=
0
;
for
(
int
j
=
0
;
fp
!
=
nullptr
&
&
j
<
kMaxUnwind
;
j
+
+
)
{
if
(
skip_count
>
0
)
{
skip_count
-
-
;
}
else
{
num_dropped_frames
+
+
;
}
fp
=
NextStackFrame
<
!
IS_STACK_FRAMES
IS_WITH_CONTEXT
>
(
fp
ucp
stack_low
stack_high
)
;
}
*
min_dropped_frames
=
num_dropped_frames
;
}
return
n
;
}
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
debugging_internal
{
bool
StackTraceWorksForTest
(
)
{
return
true
;
}
}
ABSL_NAMESPACE_END
}
#
endif
