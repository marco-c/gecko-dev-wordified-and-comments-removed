#
include
"
absl
/
debugging
/
stacktrace
.
h
"
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
atomic
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
include
"
absl
/
debugging
/
internal
/
stacktrace_config
.
h
"
#
if
defined
(
ABSL_STACKTRACE_INL_HEADER
)
#
include
ABSL_STACKTRACE_INL_HEADER
#
else
#
error
Cannot
calculate
stack
trace
:
will
need
to
write
for
your
environment
#
include
"
absl
/
debugging
/
internal
/
stacktrace_aarch64
-
inl
.
inc
"
#
include
"
absl
/
debugging
/
internal
/
stacktrace_arm
-
inl
.
inc
"
#
include
"
absl
/
debugging
/
internal
/
stacktrace_emscripten
-
inl
.
inc
"
#
include
"
absl
/
debugging
/
internal
/
stacktrace_generic
-
inl
.
inc
"
#
include
"
absl
/
debugging
/
internal
/
stacktrace_powerpc
-
inl
.
inc
"
#
include
"
absl
/
debugging
/
internal
/
stacktrace_riscv
-
inl
.
inc
"
#
include
"
absl
/
debugging
/
internal
/
stacktrace_unimplemented
-
inl
.
inc
"
#
include
"
absl
/
debugging
/
internal
/
stacktrace_win32
-
inl
.
inc
"
#
include
"
absl
/
debugging
/
internal
/
stacktrace_x86
-
inl
.
inc
"
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
{
typedef
int
(
*
Unwinder
)
(
void
*
*
int
*
int
int
const
void
*
int
*
)
;
std
:
:
atomic
<
Unwinder
>
custom
;
template
<
bool
IS_STACK_FRAMES
bool
IS_WITH_CONTEXT
>
ABSL_ATTRIBUTE_ALWAYS_INLINE
inline
int
Unwind
(
void
*
*
result
uintptr_t
*
frames
int
*
sizes
int
max_depth
int
skip_count
const
void
*
uc
int
*
min_dropped_frames
)
{
Unwinder
g
=
custom
.
load
(
std
:
:
memory_order_acquire
)
;
int
size
;
+
+
skip_count
;
if
(
g
!
=
nullptr
)
{
size
=
(
*
g
)
(
result
sizes
max_depth
skip_count
uc
min_dropped_frames
)
;
if
(
frames
!
=
nullptr
)
{
std
:
:
fill
(
frames
frames
+
size
uintptr_t
(
)
)
;
}
}
else
{
size
=
UnwindImpl
<
IS_STACK_FRAMES
IS_WITH_CONTEXT
>
(
result
frames
sizes
max_depth
skip_count
uc
min_dropped_frames
)
;
}
ABSL_BLOCK_TAIL_CALL_OPTIMIZATION
(
)
;
return
size
;
}
}
ABSL_ATTRIBUTE_NOINLINE
ABSL_ATTRIBUTE_NO_TAIL_CALL
int
internal_stacktrace
:
:
GetStackFrames
(
void
*
*
result
uintptr_t
*
frames
int
*
sizes
int
max_depth
int
skip_count
)
{
return
Unwind
<
true
false
>
(
result
frames
sizes
max_depth
skip_count
nullptr
nullptr
)
;
}
ABSL_ATTRIBUTE_NOINLINE
ABSL_ATTRIBUTE_NO_TAIL_CALL
int
internal_stacktrace
:
:
GetStackFramesWithContext
(
void
*
*
result
uintptr_t
*
frames
int
*
sizes
int
max_depth
int
skip_count
const
void
*
uc
int
*
min_dropped_frames
)
{
return
Unwind
<
true
true
>
(
result
frames
sizes
max_depth
skip_count
uc
min_dropped_frames
)
;
}
ABSL_ATTRIBUTE_NOINLINE
ABSL_ATTRIBUTE_NO_TAIL_CALL
int
GetStackTrace
(
void
*
*
result
int
max_depth
int
skip_count
)
{
return
Unwind
<
false
false
>
(
result
nullptr
nullptr
max_depth
skip_count
nullptr
nullptr
)
;
}
ABSL_ATTRIBUTE_NOINLINE
ABSL_ATTRIBUTE_NO_TAIL_CALL
int
GetStackTraceWithContext
(
void
*
*
result
int
max_depth
int
skip_count
const
void
*
uc
int
*
min_dropped_frames
)
{
return
Unwind
<
false
true
>
(
result
nullptr
nullptr
max_depth
skip_count
uc
min_dropped_frames
)
;
}
void
SetStackUnwinder
(
Unwinder
w
)
{
custom
.
store
(
w
std
:
:
memory_order_release
)
;
}
ABSL_ATTRIBUTE_ALWAYS_INLINE
static
inline
int
DefaultStackUnwinderImpl
(
void
*
*
pcs
uintptr_t
*
frames
int
*
sizes
int
depth
int
skip
const
void
*
uc
int
*
min_dropped_frames
)
{
skip
+
+
;
decltype
(
&
UnwindImpl
<
false
false
>
)
f
;
if
(
sizes
=
=
nullptr
)
{
if
(
uc
=
=
nullptr
)
{
f
=
&
UnwindImpl
<
false
false
>
;
}
else
{
f
=
&
UnwindImpl
<
false
true
>
;
}
}
else
{
if
(
uc
=
=
nullptr
)
{
f
=
&
UnwindImpl
<
true
false
>
;
}
else
{
f
=
&
UnwindImpl
<
true
true
>
;
}
}
return
(
*
f
)
(
pcs
frames
sizes
depth
skip
uc
min_dropped_frames
)
;
}
ABSL_ATTRIBUTE_NOINLINE
ABSL_ATTRIBUTE_NO_TAIL_CALL
int
internal_stacktrace
:
:
DefaultStackUnwinder
(
void
*
*
pcs
uintptr_t
*
frames
int
*
sizes
int
depth
int
skip
const
void
*
uc
int
*
min_dropped_frames
)
{
int
n
=
DefaultStackUnwinderImpl
(
pcs
frames
sizes
depth
skip
uc
min_dropped_frames
)
;
ABSL_BLOCK_TAIL_CALL_OPTIMIZATION
(
)
;
return
n
;
}
ABSL_ATTRIBUTE_NOINLINE
ABSL_ATTRIBUTE_NO_TAIL_CALL
int
DefaultStackUnwinder
(
void
*
*
pcs
int
*
sizes
int
depth
int
skip
const
void
*
uc
int
*
min_dropped_frames
)
{
int
n
=
DefaultStackUnwinderImpl
(
pcs
nullptr
sizes
depth
skip
uc
min_dropped_frames
)
;
ABSL_BLOCK_TAIL_CALL_OPTIMIZATION
(
)
;
return
n
;
}
ABSL_NAMESPACE_END
}
