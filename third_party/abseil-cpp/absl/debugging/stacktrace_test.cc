#
include
"
absl
/
debugging
/
stacktrace
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
types
/
span
.
h
"
namespace
{
using
:
:
testing
:
:
Contains
;
struct
StackTrace
{
static
constexpr
int
kStackCount
=
64
;
int
depth
;
void
*
result
[
kStackCount
]
;
uintptr_t
frames
[
kStackCount
]
;
int
sizes
[
kStackCount
]
;
}
;
#
if
defined
(
__linux__
)
&
&
(
defined
(
__x86_64__
)
|
|
defined
(
__aarch64__
)
)
ABSL_ATTRIBUTE_NOINLINE
void
Unwind
(
void
*
p
)
{
ABSL_ATTRIBUTE_UNUSED
static
void
*
volatile
sink
=
p
;
constexpr
int
kSize
=
16
;
void
*
stack
[
kSize
]
;
int
frames
[
kSize
]
;
absl
:
:
GetStackTrace
(
stack
kSize
0
)
;
absl
:
:
GetStackFrames
(
stack
frames
kSize
0
)
;
}
ABSL_ATTRIBUTE_NOINLINE
void
HugeFrame
(
)
{
char
buffer
[
1
<
<
20
]
;
Unwind
(
buffer
)
;
ABSL_BLOCK_TAIL_CALL_OPTIMIZATION
(
)
;
}
TEST
(
StackTrace
HugeFrame
)
{
HugeFrame
(
)
;
ABSL_BLOCK_TAIL_CALL_OPTIMIZATION
(
)
;
}
#
endif
#
if
ABSL_HAVE_BUILTIN
(
__builtin_frame_address
)
struct
FrameInfo
{
const
void
*
return_address
;
uintptr_t
frame_address
;
}
;
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY
ABSL_ATTRIBUTE_NOINLINE
static
FrameInfo
CaptureBacktraceNoInline
(
StackTrace
&
backtrace
)
{
FrameInfo
result
;
result
.
return_address
=
__builtin_return_address
(
0
)
;
const
int
kMaxReturnAddressIndex
=
5
;
void
*
const
*
bfa
=
static_cast
<
void
*
const
*
>
(
__builtin_frame_address
(
0
)
)
;
backtrace
.
depth
=
absl
:
:
internal_stacktrace
:
:
GetStackFramesWithContext
(
backtrace
.
result
backtrace
.
frames
backtrace
.
sizes
StackTrace
:
:
kStackCount
0
nullptr
nullptr
)
;
ptrdiff_t
i
;
for
(
i
=
0
;
i
<
kMaxReturnAddressIndex
;
+
+
i
)
{
if
(
bfa
[
i
]
=
=
result
.
return_address
)
{
break
;
}
}
result
.
frame_address
=
i
<
kMaxReturnAddressIndex
?
reinterpret_cast
<
uintptr_t
>
(
bfa
+
i
+
1
)
:
0
;
return
result
;
}
TEST
(
StackTrace
CanonicalFrameAddresses
)
{
StackTrace
backtrace
;
const
auto
[
return_address
frame_address
]
=
CaptureBacktraceNoInline
(
backtrace
)
;
auto
return_addresses
=
absl
:
:
MakeSpan
(
backtrace
.
result
)
.
subspan
(
0
static_cast
<
size_t
>
(
backtrace
.
depth
)
)
;
auto
frame_addresses
=
absl
:
:
MakeSpan
(
backtrace
.
frames
)
.
subspan
(
0
static_cast
<
size_t
>
(
backtrace
.
depth
)
)
;
bool
support_is_expected
=
false
;
if
(
support_is_expected
)
{
bool
supported
=
static_cast
<
size_t
>
(
std
:
:
count
(
frame_addresses
.
begin
(
)
frame_addresses
.
end
(
)
0
)
)
<
frame_addresses
.
size
(
)
;
EXPECT_TRUE
(
supported
)
;
if
(
supported
)
{
ASSERT_TRUE
(
frame_address
)
<
<
"
unable
to
obtain
frame
address
corresponding
to
return
address
"
;
EXPECT_THAT
(
return_addresses
Contains
(
return_address
)
.
Times
(
1
)
)
;
EXPECT_THAT
(
frame_addresses
Contains
(
frame_address
)
.
Times
(
1
)
)
;
ptrdiff_t
ifound
=
std
:
:
find
(
return_addresses
.
begin
(
)
return_addresses
.
end
(
)
return_address
)
-
return_addresses
.
begin
(
)
;
ASSERT_LT
(
ifound
backtrace
.
depth
)
;
EXPECT_EQ
(
frame_addresses
[
static_cast
<
size_t
>
(
ifound
)
]
frame_address
)
;
}
}
}
#
endif
}
