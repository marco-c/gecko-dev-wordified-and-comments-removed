#
ifndef
ABSL_SYNCHRONIZATION_INTERNAL_GRAPHCYCLES_H_
#
define
ABSL_SYNCHRONIZATION_INTERNAL_GRAPHCYCLES_H_
#
include
<
cstdint
>
#
include
"
absl
/
base
/
config
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
synchronization_internal
{
struct
GraphId
{
uint64_t
handle
;
bool
operator
=
=
(
const
GraphId
&
x
)
const
{
return
handle
=
=
x
.
handle
;
}
bool
operator
!
=
(
const
GraphId
&
x
)
const
{
return
handle
!
=
x
.
handle
;
}
}
;
inline
GraphId
InvalidGraphId
(
)
{
return
GraphId
{
0
}
;
}
class
GraphCycles
{
public
:
GraphCycles
(
)
;
~
GraphCycles
(
)
;
GraphId
GetId
(
void
*
ptr
)
;
void
RemoveNode
(
void
*
ptr
)
;
void
*
Ptr
(
GraphId
id
)
;
bool
InsertEdge
(
GraphId
source_node
GraphId
dest_node
)
;
void
RemoveEdge
(
GraphId
source_node
GraphId
dest_node
)
;
bool
HasNode
(
GraphId
node
)
;
bool
HasEdge
(
GraphId
source_node
GraphId
dest_node
)
const
;
bool
IsReachable
(
GraphId
source_node
GraphId
dest_node
)
const
;
int
FindPath
(
GraphId
source
GraphId
dest
int
max_path_len
GraphId
path
[
]
)
const
;
void
UpdateStackTrace
(
GraphId
id
int
priority
int
(
*
get_stack_trace
)
(
void
*
*
int
)
)
;
int
GetStackTrace
(
GraphId
id
void
*
*
*
ptr
)
;
bool
CheckInvariants
(
)
const
;
void
TestOnlyAddNodes
(
uint32_t
n
)
;
struct
Rep
;
private
:
Rep
*
rep_
;
GraphCycles
(
const
GraphCycles
&
)
=
delete
;
GraphCycles
&
operator
=
(
const
GraphCycles
&
)
=
delete
;
}
;
}
ABSL_NAMESPACE_END
}
#
endif
