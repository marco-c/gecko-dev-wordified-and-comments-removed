#
include
"
absl
/
synchronization
/
internal
/
win32_waiter
.
h
"
#
ifdef
ABSL_INTERNAL_HAVE_WIN32_WAITER
#
include
<
windows
.
h
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
base
/
internal
/
thread_identity
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
synchronization
/
internal
/
kernel_timeout
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
synchronization_internal
{
#
ifdef
ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
constexpr
char
Win32Waiter
:
:
kName
[
]
;
#
endif
class
Win32Waiter
:
:
WinHelper
{
public
:
static
SRWLOCK
*
GetLock
(
Win32Waiter
*
w
)
{
return
reinterpret_cast
<
SRWLOCK
*
>
(
&
w
-
>
mu_storage_
)
;
}
static
CONDITION_VARIABLE
*
GetCond
(
Win32Waiter
*
w
)
{
return
reinterpret_cast
<
CONDITION_VARIABLE
*
>
(
&
w
-
>
cv_storage_
)
;
}
static_assert
(
sizeof
(
SRWLOCK
)
=
=
sizeof
(
void
*
)
"
mu_storage_
does
not
have
the
same
size
as
SRWLOCK
"
)
;
static_assert
(
alignof
(
SRWLOCK
)
=
=
alignof
(
void
*
)
"
mu_storage_
does
not
have
the
same
alignment
as
SRWLOCK
"
)
;
static_assert
(
sizeof
(
CONDITION_VARIABLE
)
=
=
sizeof
(
void
*
)
"
ABSL_CONDITION_VARIABLE_STORAGE
does
not
have
the
same
size
"
"
as
CONDITION_VARIABLE
"
)
;
static_assert
(
alignof
(
CONDITION_VARIABLE
)
=
=
alignof
(
void
*
)
"
cv_storage_
does
not
have
the
same
alignment
as
CONDITION_VARIABLE
"
)
;
static_assert
(
std
:
:
is_trivially_constructible
<
SRWLOCK
>
:
:
value
"
The
SRWLOCK
type
must
be
trivially
constructible
"
)
;
static_assert
(
std
:
:
is_trivially_constructible
<
CONDITION_VARIABLE
>
:
:
value
"
The
CONDITION_VARIABLE
type
must
be
trivially
constructible
"
)
;
static_assert
(
std
:
:
is_trivially_destructible
<
SRWLOCK
>
:
:
value
"
The
SRWLOCK
type
must
be
trivially
destructible
"
)
;
static_assert
(
std
:
:
is_trivially_destructible
<
CONDITION_VARIABLE
>
:
:
value
"
The
CONDITION_VARIABLE
type
must
be
trivially
destructible
"
)
;
}
;
class
LockHolder
{
public
:
explicit
LockHolder
(
SRWLOCK
*
mu
)
:
mu_
(
mu
)
{
AcquireSRWLockExclusive
(
mu_
)
;
}
LockHolder
(
const
LockHolder
&
)
=
delete
;
LockHolder
&
operator
=
(
const
LockHolder
&
)
=
delete
;
~
LockHolder
(
)
{
ReleaseSRWLockExclusive
(
mu_
)
;
}
private
:
SRWLOCK
*
mu_
;
}
;
Win32Waiter
:
:
Win32Waiter
(
)
{
auto
*
mu
=
:
:
new
(
static_cast
<
void
*
>
(
&
mu_storage_
)
)
SRWLOCK
;
auto
*
cv
=
:
:
new
(
static_cast
<
void
*
>
(
&
cv_storage_
)
)
CONDITION_VARIABLE
;
InitializeSRWLock
(
mu
)
;
InitializeConditionVariable
(
cv
)
;
waiter_count_
=
0
;
wakeup_count_
=
0
;
}
bool
Win32Waiter
:
:
Wait
(
KernelTimeout
t
)
{
SRWLOCK
*
mu
=
WinHelper
:
:
GetLock
(
this
)
;
CONDITION_VARIABLE
*
cv
=
WinHelper
:
:
GetCond
(
this
)
;
LockHolder
h
(
mu
)
;
+
+
waiter_count_
;
bool
first_pass
=
true
;
while
(
wakeup_count_
=
=
0
)
{
if
(
!
first_pass
)
MaybeBecomeIdle
(
)
;
if
(
!
SleepConditionVariableSRW
(
cv
mu
t
.
InMillisecondsFromNow
(
)
0
)
)
{
const
unsigned
long
err
{
GetLastError
(
)
}
;
if
(
err
=
=
ERROR_TIMEOUT
)
{
-
-
waiter_count_
;
return
false
;
}
else
{
ABSL_RAW_LOG
(
FATAL
"
SleepConditionVariableSRW
failed
:
%
lu
"
err
)
;
}
}
first_pass
=
false
;
}
-
-
wakeup_count_
;
-
-
waiter_count_
;
return
true
;
}
void
Win32Waiter
:
:
Post
(
)
{
LockHolder
h
(
WinHelper
:
:
GetLock
(
this
)
)
;
+
+
wakeup_count_
;
InternalCondVarPoke
(
)
;
}
void
Win32Waiter
:
:
Poke
(
)
{
LockHolder
h
(
WinHelper
:
:
GetLock
(
this
)
)
;
InternalCondVarPoke
(
)
;
}
void
Win32Waiter
:
:
InternalCondVarPoke
(
)
{
if
(
waiter_count_
!
=
0
)
{
WakeConditionVariable
(
WinHelper
:
:
GetCond
(
this
)
)
;
}
}
}
ABSL_NAMESPACE_END
}
#
endif
