#
ifndef
ABSL_SYNCHRONIZATION_INTERNAL_KERNEL_TIMEOUT_H_
#
define
ABSL_SYNCHRONIZATION_INTERNAL_KERNEL_TIMEOUT_H_
#
ifndef
_WIN32
#
include
<
sys
/
types
.
h
>
#
endif
#
include
<
algorithm
>
#
include
<
chrono
>
#
include
<
cstdint
>
#
include
<
ctime
>
#
include
<
limits
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
time
/
clock
.
h
"
#
include
"
absl
/
time
/
time
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
synchronization_internal
{
class
KernelTimeout
{
public
:
explicit
KernelTimeout
(
absl
:
:
Time
t
)
;
explicit
KernelTimeout
(
absl
:
:
Duration
d
)
;
constexpr
KernelTimeout
(
)
:
rep_
(
kNoTimeout
)
{
}
static
constexpr
KernelTimeout
Never
(
)
{
return
KernelTimeout
(
)
;
}
bool
has_timeout
(
)
const
{
return
rep_
!
=
kNoTimeout
;
}
bool
is_absolute_timeout
(
)
const
{
return
(
rep_
&
1
)
=
=
0
;
}
bool
is_relative_timeout
(
)
const
{
return
(
rep_
&
1
)
=
=
1
;
}
struct
timespec
MakeAbsTimespec
(
)
const
;
struct
timespec
MakeRelativeTimespec
(
)
const
;
#
ifndef
_WIN32
struct
timespec
MakeClockAbsoluteTimespec
(
clockid_t
c
)
const
;
#
endif
int64_t
MakeAbsNanos
(
)
const
;
typedef
unsigned
long
DWord
;
DWord
InMillisecondsFromNow
(
)
const
;
std
:
:
chrono
:
:
time_point
<
std
:
:
chrono
:
:
system_clock
>
ToChronoTimePoint
(
)
const
;
std
:
:
chrono
:
:
nanoseconds
ToChronoDuration
(
)
const
;
static
constexpr
bool
SupportsSteadyClock
(
)
{
return
true
;
}
private
:
static
int64_t
SteadyClockNow
(
)
;
uint64_t
rep_
;
int64_t
RawAbsNanos
(
)
const
{
return
static_cast
<
int64_t
>
(
rep_
>
>
1
)
;
}
int64_t
InNanosecondsFromNow
(
)
const
;
static
constexpr
uint64_t
kNoTimeout
=
(
std
:
:
numeric_limits
<
uint64_t
>
:
:
max
)
(
)
;
static
constexpr
int64_t
kMaxNanos
=
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
)
(
)
;
}
;
}
ABSL_NAMESPACE_END
}
#
endif
