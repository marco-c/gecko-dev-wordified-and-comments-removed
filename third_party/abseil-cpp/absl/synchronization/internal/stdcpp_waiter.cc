#
include
"
absl
/
synchronization
/
internal
/
stdcpp_waiter
.
h
"
#
ifdef
ABSL_INTERNAL_HAVE_STDCPP_WAITER
#
include
<
chrono
>
#
include
<
condition_variable
>
#
include
<
mutex
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
base
/
internal
/
thread_identity
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
synchronization
/
internal
/
kernel_timeout
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
synchronization_internal
{
StdcppWaiter
:
:
StdcppWaiter
(
)
:
waiter_count_
(
0
)
wakeup_count_
(
0
)
{
}
bool
StdcppWaiter
:
:
Wait
(
KernelTimeout
t
)
{
std
:
:
unique_lock
<
std
:
:
mutex
>
lock
(
mu_
)
;
+
+
waiter_count_
;
bool
first_pass
=
true
;
while
(
wakeup_count_
=
=
0
)
{
if
(
!
first_pass
)
MaybeBecomeIdle
(
)
;
if
(
!
t
.
has_timeout
(
)
)
{
cv_
.
wait
(
lock
)
;
}
else
{
auto
wait_result
=
t
.
SupportsSteadyClock
(
)
&
&
t
.
is_relative_timeout
(
)
?
cv_
.
wait_for
(
lock
t
.
ToChronoDuration
(
)
)
:
cv_
.
wait_until
(
lock
t
.
ToChronoTimePoint
(
)
)
;
if
(
wait_result
=
=
std
:
:
cv_status
:
:
timeout
)
{
-
-
waiter_count_
;
return
false
;
}
}
first_pass
=
false
;
}
-
-
wakeup_count_
;
-
-
waiter_count_
;
return
true
;
}
void
StdcppWaiter
:
:
Post
(
)
{
std
:
:
lock_guard
<
std
:
:
mutex
>
lock
(
mu_
)
;
+
+
wakeup_count_
;
InternalCondVarPoke
(
)
;
}
void
StdcppWaiter
:
:
Poke
(
)
{
std
:
:
lock_guard
<
std
:
:
mutex
>
lock
(
mu_
)
;
InternalCondVarPoke
(
)
;
}
void
StdcppWaiter
:
:
InternalCondVarPoke
(
)
{
if
(
waiter_count_
!
=
0
)
{
cv_
.
notify_one
(
)
;
}
}
}
ABSL_NAMESPACE_END
}
#
endif
