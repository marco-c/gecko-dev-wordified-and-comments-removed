#
include
"
absl
/
synchronization
/
notification
.
h
"
#
include
<
thread
>
#
include
<
vector
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
synchronization
/
mutex
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
class
ThreadSafeCounter
{
public
:
ThreadSafeCounter
(
)
:
count_
(
0
)
{
}
void
Increment
(
)
{
MutexLock
lock
(
&
mutex_
)
;
+
+
count_
;
}
int
Get
(
)
const
{
MutexLock
lock
(
&
mutex_
)
;
return
count_
;
}
void
WaitUntilGreaterOrEqual
(
int
n
)
{
MutexLock
lock
(
&
mutex_
)
;
auto
cond
=
[
this
n
]
(
)
{
return
count_
>
=
n
;
}
;
mutex_
.
Await
(
Condition
(
&
cond
)
)
;
}
private
:
mutable
Mutex
mutex_
;
int
count_
;
}
;
static
void
RunWorker
(
int
i
ThreadSafeCounter
*
ready_counter
Notification
*
notification
ThreadSafeCounter
*
done_counter
)
{
ready_counter
-
>
Increment
(
)
;
notification
-
>
WaitForNotification
(
)
;
done_counter
-
>
Increment
(
)
;
}
static
void
BasicTests
(
bool
notify_before_waiting
Notification
*
notification
)
{
EXPECT_FALSE
(
notification
-
>
HasBeenNotified
(
)
)
;
EXPECT_FALSE
(
notification
-
>
WaitForNotificationWithTimeout
(
absl
:
:
Milliseconds
(
0
)
)
)
;
EXPECT_FALSE
(
notification
-
>
WaitForNotificationWithDeadline
(
absl
:
:
Now
(
)
)
)
;
const
absl
:
:
Duration
delay
=
absl
:
:
Milliseconds
(
50
)
;
const
absl
:
:
Time
start
=
absl
:
:
Now
(
)
;
EXPECT_FALSE
(
notification
-
>
WaitForNotificationWithTimeout
(
delay
)
)
;
const
absl
:
:
Duration
elapsed
=
absl
:
:
Now
(
)
-
start
;
const
absl
:
:
Duration
slop
=
absl
:
:
Milliseconds
(
5
)
;
EXPECT_LE
(
delay
-
slop
elapsed
)
<
<
"
WaitForNotificationWithTimeout
returned
"
<
<
delay
-
elapsed
<
<
"
early
(
with
"
<
<
slop
<
<
"
slop
)
start
time
was
"
<
<
start
;
ThreadSafeCounter
ready_counter
;
ThreadSafeCounter
done_counter
;
if
(
notify_before_waiting
)
{
notification
-
>
Notify
(
)
;
}
const
int
kNumThreads
=
10
;
std
:
:
vector
<
std
:
:
thread
>
workers
;
for
(
int
i
=
0
;
i
<
kNumThreads
;
+
+
i
)
{
workers
.
push_back
(
std
:
:
thread
(
&
RunWorker
i
&
ready_counter
notification
&
done_counter
)
)
;
}
if
(
!
notify_before_waiting
)
{
ready_counter
.
WaitUntilGreaterOrEqual
(
kNumThreads
)
;
EXPECT_EQ
(
0
done_counter
.
Get
(
)
)
;
notification
-
>
Notify
(
)
;
}
notification
-
>
WaitForNotification
(
)
;
EXPECT_TRUE
(
notification
-
>
HasBeenNotified
(
)
)
;
EXPECT_TRUE
(
notification
-
>
WaitForNotificationWithTimeout
(
absl
:
:
Seconds
(
0
)
)
)
;
EXPECT_TRUE
(
notification
-
>
WaitForNotificationWithDeadline
(
absl
:
:
Now
(
)
)
)
;
for
(
std
:
:
thread
&
worker
:
workers
)
{
worker
.
join
(
)
;
}
EXPECT_EQ
(
kNumThreads
ready_counter
.
Get
(
)
)
;
EXPECT_EQ
(
kNumThreads
done_counter
.
Get
(
)
)
;
}
TEST
(
NotificationTest
SanityTest
)
{
Notification
local_notification1
local_notification2
;
BasicTests
(
false
&
local_notification1
)
;
BasicTests
(
true
&
local_notification2
)
;
}
ABSL_NAMESPACE_END
}
