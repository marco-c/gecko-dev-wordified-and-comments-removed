#
if
defined
(
_WIN32
)
|
|
defined
(
_WIN64
)
#
define
_CRT_SECURE_NO_WARNINGS
1
#
endif
#
include
"
time_zone_libc
.
h
"
#
include
<
chrono
>
#
include
<
ctime
>
#
include
<
limits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
time
/
internal
/
cctz
/
include
/
cctz
/
civil_time
.
h
"
#
include
"
absl
/
time
/
internal
/
cctz
/
include
/
cctz
/
time_zone
.
h
"
#
if
defined
(
_AIX
)
extern
"
C
"
{
extern
long
altzone
;
}
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
time_internal
{
namespace
cctz
{
namespace
{
#
if
defined
(
_WIN32
)
|
|
defined
(
_WIN64
)
auto
tm_gmtoff
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
_timezone
+
_dstbias
)
{
const
bool
is_dst
=
tm
.
tm_isdst
>
0
;
return
_timezone
+
(
is_dst
?
_dstbias
:
0
)
;
}
auto
tm_zone
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
_tzname
[
0
]
)
{
const
bool
is_dst
=
tm
.
tm_isdst
>
0
;
return
_tzname
[
is_dst
]
;
}
#
elif
defined
(
__sun
)
|
|
defined
(
_AIX
)
auto
tm_gmtoff
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
timezone
)
{
const
bool
is_dst
=
tm
.
tm_isdst
>
0
;
return
is_dst
?
altzone
:
timezone
;
}
auto
tm_zone
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
tzname
[
0
]
)
{
const
bool
is_dst
=
tm
.
tm_isdst
>
0
;
return
tzname
[
is_dst
]
;
}
#
elif
defined
(
__native_client__
)
|
|
defined
(
__myriad2__
)
|
|
\
defined
(
__EMSCRIPTEN__
)
auto
tm_gmtoff
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
_timezone
+
0
)
{
const
bool
is_dst
=
tm
.
tm_isdst
>
0
;
return
_timezone
+
(
is_dst
?
60
*
60
:
0
)
;
}
auto
tm_zone
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
tzname
[
0
]
)
{
const
bool
is_dst
=
tm
.
tm_isdst
>
0
;
return
tzname
[
is_dst
]
;
}
#
elif
defined
(
__VXWORKS__
)
auto
tm_gmtoff
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
timezone
+
0
)
{
const
bool
is_dst
=
tm
.
tm_isdst
>
0
;
return
timezone
+
(
is_dst
?
60
*
60
:
0
)
;
}
auto
tm_zone
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
tzname
[
0
]
)
{
const
bool
is_dst
=
tm
.
tm_isdst
>
0
;
return
tzname
[
is_dst
]
;
}
#
else
#
if
defined
(
tm_gmtoff
)
auto
tm_gmtoff
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
tm
.
tm_gmtoff
)
{
return
tm
.
tm_gmtoff
;
}
#
elif
defined
(
__tm_gmtoff
)
auto
tm_gmtoff
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
tm
.
__tm_gmtoff
)
{
return
tm
.
__tm_gmtoff
;
}
#
else
template
<
typename
T
>
auto
tm_gmtoff
(
const
T
&
tm
)
-
>
decltype
(
tm
.
tm_gmtoff
)
{
return
tm
.
tm_gmtoff
;
}
template
<
typename
T
>
auto
tm_gmtoff
(
const
T
&
tm
)
-
>
decltype
(
tm
.
__tm_gmtoff
)
{
return
tm
.
__tm_gmtoff
;
}
#
endif
#
if
defined
(
tm_zone
)
auto
tm_zone
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
tm
.
tm_zone
)
{
return
tm
.
tm_zone
;
}
#
elif
defined
(
__tm_zone
)
auto
tm_zone
(
const
std
:
:
tm
&
tm
)
-
>
decltype
(
tm
.
__tm_zone
)
{
return
tm
.
__tm_zone
;
}
#
else
template
<
typename
T
>
auto
tm_zone
(
const
T
&
tm
)
-
>
decltype
(
tm
.
tm_zone
)
{
return
tm
.
tm_zone
;
}
template
<
typename
T
>
auto
tm_zone
(
const
T
&
tm
)
-
>
decltype
(
tm
.
__tm_zone
)
{
return
tm
.
__tm_zone
;
}
#
endif
#
endif
using
tm_gmtoff_t
=
decltype
(
tm_gmtoff
(
std
:
:
tm
{
}
)
)
;
inline
std
:
:
tm
*
gm_time
(
const
std
:
:
time_t
*
timep
std
:
:
tm
*
result
)
{
#
if
defined
(
_WIN32
)
|
|
defined
(
_WIN64
)
return
gmtime_s
(
result
timep
)
?
nullptr
:
result
;
#
else
return
gmtime_r
(
timep
result
)
;
#
endif
}
inline
std
:
:
tm
*
local_time
(
const
std
:
:
time_t
*
timep
std
:
:
tm
*
result
)
{
#
if
defined
(
_WIN32
)
|
|
defined
(
_WIN64
)
return
localtime_s
(
result
timep
)
?
nullptr
:
result
;
#
else
return
localtime_r
(
timep
result
)
;
#
endif
}
bool
make_time
(
const
civil_second
&
cs
int
is_dst
std
:
:
time_t
*
t
std
:
:
tm
*
tm
)
{
tm
-
>
tm_year
=
static_cast
<
int
>
(
cs
.
year
(
)
-
year_t
{
1900
}
)
;
tm
-
>
tm_mon
=
cs
.
month
(
)
-
1
;
tm
-
>
tm_mday
=
cs
.
day
(
)
;
tm
-
>
tm_hour
=
cs
.
hour
(
)
;
tm
-
>
tm_min
=
cs
.
minute
(
)
;
tm
-
>
tm_sec
=
cs
.
second
(
)
;
tm
-
>
tm_isdst
=
is_dst
;
*
t
=
std
:
:
mktime
(
tm
)
;
if
(
*
t
=
=
std
:
:
time_t
{
-
1
}
)
{
std
:
:
tm
tm2
;
const
std
:
:
tm
*
tmp
=
local_time
(
t
&
tm2
)
;
if
(
tmp
=
=
nullptr
|
|
tmp
-
>
tm_year
!
=
tm
-
>
tm_year
|
|
tmp
-
>
tm_mon
!
=
tm
-
>
tm_mon
|
|
tmp
-
>
tm_mday
!
=
tm
-
>
tm_mday
|
|
tmp
-
>
tm_hour
!
=
tm
-
>
tm_hour
|
|
tmp
-
>
tm_min
!
=
tm
-
>
tm_min
|
|
tmp
-
>
tm_sec
!
=
tm
-
>
tm_sec
)
{
return
false
;
}
}
return
true
;
}
std
:
:
time_t
find_trans
(
std
:
:
time_t
lo
std
:
:
time_t
hi
tm_gmtoff_t
offset
)
{
std
:
:
tm
tm
;
while
(
lo
+
1
!
=
hi
)
{
const
std
:
:
time_t
mid
=
lo
+
(
hi
-
lo
)
/
2
;
std
:
:
tm
*
tmp
=
local_time
(
&
mid
&
tm
)
;
if
(
tmp
!
=
nullptr
)
{
if
(
tm_gmtoff
(
*
tmp
)
=
=
offset
)
{
hi
=
mid
;
}
else
{
lo
=
mid
;
}
}
else
{
while
(
+
+
lo
!
=
hi
)
{
tmp
=
local_time
(
&
lo
&
tm
)
;
if
(
tmp
!
=
nullptr
)
{
if
(
tm_gmtoff
(
*
tmp
)
=
=
offset
)
break
;
}
}
return
lo
;
}
}
return
hi
;
}
}
std
:
:
unique_ptr
<
TimeZoneLibC
>
TimeZoneLibC
:
:
Make
(
const
std
:
:
string
&
name
)
{
return
std
:
:
unique_ptr
<
TimeZoneLibC
>
(
new
TimeZoneLibC
(
name
)
)
;
}
time_zone
:
:
absolute_lookup
TimeZoneLibC
:
:
BreakTime
(
const
time_point
<
seconds
>
&
tp
)
const
{
time_zone
:
:
absolute_lookup
al
;
al
.
offset
=
0
;
al
.
is_dst
=
false
;
al
.
abbr
=
"
-
00
"
;
const
std
:
:
int_fast64_t
s
=
ToUnixSeconds
(
tp
)
;
if
(
s
<
std
:
:
numeric_limits
<
std
:
:
time_t
>
:
:
min
(
)
)
{
al
.
cs
=
civil_second
:
:
min
(
)
;
return
al
;
}
if
(
s
>
std
:
:
numeric_limits
<
std
:
:
time_t
>
:
:
max
(
)
)
{
al
.
cs
=
civil_second
:
:
max
(
)
;
return
al
;
}
const
std
:
:
time_t
t
=
static_cast
<
std
:
:
time_t
>
(
s
)
;
std
:
:
tm
tm
;
std
:
:
tm
*
tmp
=
local_
?
local_time
(
&
t
&
tm
)
:
gm_time
(
&
t
&
tm
)
;
if
(
tmp
=
=
nullptr
)
{
al
.
cs
=
(
s
<
0
)
?
civil_second
:
:
min
(
)
:
civil_second
:
:
max
(
)
;
return
al
;
}
const
year_t
year
=
tmp
-
>
tm_year
+
year_t
{
1900
}
;
al
.
cs
=
civil_second
(
year
tmp
-
>
tm_mon
+
1
tmp
-
>
tm_mday
tmp
-
>
tm_hour
tmp
-
>
tm_min
tmp
-
>
tm_sec
)
;
al
.
offset
=
static_cast
<
int
>
(
tm_gmtoff
(
*
tmp
)
)
;
al
.
abbr
=
local_
?
tm_zone
(
*
tmp
)
:
"
UTC
"
;
al
.
is_dst
=
tmp
-
>
tm_isdst
>
0
;
return
al
;
}
time_zone
:
:
civil_lookup
TimeZoneLibC
:
:
MakeTime
(
const
civil_second
&
cs
)
const
{
if
(
!
local_
)
{
static
const
civil_second
min_tp_cs
=
civil_second
(
)
+
ToUnixSeconds
(
time_point
<
seconds
>
:
:
min
(
)
)
;
static
const
civil_second
max_tp_cs
=
civil_second
(
)
+
ToUnixSeconds
(
time_point
<
seconds
>
:
:
max
(
)
)
;
const
time_point
<
seconds
>
tp
=
(
cs
<
min_tp_cs
)
?
time_point
<
seconds
>
:
:
min
(
)
:
(
cs
>
max_tp_cs
)
?
time_point
<
seconds
>
:
:
max
(
)
:
FromUnixSeconds
(
cs
-
civil_second
(
)
)
;
return
{
time_zone
:
:
civil_lookup
:
:
UNIQUE
tp
tp
tp
}
;
}
if
(
cs
.
year
(
)
<
0
)
{
if
(
cs
.
year
(
)
<
std
:
:
numeric_limits
<
int
>
:
:
min
(
)
+
year_t
{
1900
}
)
{
const
time_point
<
seconds
>
tp
=
time_point
<
seconds
>
:
:
min
(
)
;
return
{
time_zone
:
:
civil_lookup
:
:
UNIQUE
tp
tp
tp
}
;
}
}
else
{
if
(
cs
.
year
(
)
-
year_t
{
1900
}
>
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
{
const
time_point
<
seconds
>
tp
=
time_point
<
seconds
>
:
:
max
(
)
;
return
{
time_zone
:
:
civil_lookup
:
:
UNIQUE
tp
tp
tp
}
;
}
}
std
:
:
time_t
t0
t1
;
std
:
:
tm
tm0
tm1
;
if
(
make_time
(
cs
0
&
t0
&
tm0
)
&
&
make_time
(
cs
1
&
t1
&
tm1
)
)
{
if
(
tm0
.
tm_isdst
=
=
tm1
.
tm_isdst
)
{
const
time_point
<
seconds
>
tp
=
FromUnixSeconds
(
tm0
.
tm_isdst
?
t1
:
t0
)
;
return
{
time_zone
:
:
civil_lookup
:
:
UNIQUE
tp
tp
tp
}
;
}
tm_gmtoff_t
offset
=
tm_gmtoff
(
tm0
)
;
if
(
t0
<
t1
)
{
std
:
:
swap
(
t0
t1
)
;
offset
=
tm_gmtoff
(
tm1
)
;
}
const
std
:
:
time_t
tt
=
find_trans
(
t1
t0
offset
)
;
const
time_point
<
seconds
>
trans
=
FromUnixSeconds
(
tt
)
;
if
(
tm0
.
tm_isdst
)
{
const
time_point
<
seconds
>
pre
=
FromUnixSeconds
(
t0
)
;
const
time_point
<
seconds
>
post
=
FromUnixSeconds
(
t1
)
;
return
{
time_zone
:
:
civil_lookup
:
:
SKIPPED
pre
trans
post
}
;
}
const
time_point
<
seconds
>
pre
=
FromUnixSeconds
(
t1
)
;
const
time_point
<
seconds
>
post
=
FromUnixSeconds
(
t0
)
;
return
{
time_zone
:
:
civil_lookup
:
:
REPEATED
pre
trans
post
}
;
}
const
time_point
<
seconds
>
tp
=
(
cs
<
civil_second
(
)
)
?
time_point
<
seconds
>
:
:
min
(
)
:
time_point
<
seconds
>
:
:
max
(
)
;
return
{
time_zone
:
:
civil_lookup
:
:
UNIQUE
tp
tp
tp
}
;
}
bool
TimeZoneLibC
:
:
NextTransition
(
const
time_point
<
seconds
>
&
time_zone
:
:
civil_transition
*
)
const
{
return
false
;
}
bool
TimeZoneLibC
:
:
PrevTransition
(
const
time_point
<
seconds
>
&
time_zone
:
:
civil_transition
*
)
const
{
return
false
;
}
std
:
:
string
TimeZoneLibC
:
:
Version
(
)
const
{
return
std
:
:
string
(
)
;
}
std
:
:
string
TimeZoneLibC
:
:
Description
(
)
const
{
return
local_
?
"
localtime
"
:
"
UTC
"
;
}
TimeZoneLibC
:
:
TimeZoneLibC
(
const
std
:
:
string
&
name
)
:
local_
(
name
=
=
"
localtime
"
)
{
}
}
}
ABSL_NAMESPACE_END
}
