#
ifndef
ABSL_LOG_INTERNAL_STRUCTURED_H_
#
define
ABSL_LOG_INTERNAL_STRUCTURED_H_
#
include
<
ostream
>
#
include
<
string
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
absl
/
log
/
internal
/
log_message
.
h
"
#
include
"
absl
/
log
/
internal
/
structured_proto
.
h
"
#
include
"
absl
/
strings
/
str_cat
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
log_internal
{
class
ABSL_MUST_USE_RESULT
AsLiteralImpl
final
{
public
:
explicit
AsLiteralImpl
(
absl
:
:
string_view
str
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
:
str_
(
str
)
{
}
AsLiteralImpl
(
const
AsLiteralImpl
&
)
=
default
;
AsLiteralImpl
&
operator
=
(
const
AsLiteralImpl
&
)
=
default
;
private
:
absl
:
:
string_view
str_
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
AsLiteralImpl
&
&
as_literal
)
{
return
os
<
<
as_literal
.
str_
;
}
void
AddToMessage
(
log_internal
:
:
LogMessage
&
m
)
{
m
.
CopyToEncodedBuffer
<
log_internal
:
:
LogMessage
:
:
StringType
:
:
kLiteral
>
(
str_
)
;
}
friend
log_internal
:
:
LogMessage
&
operator
<
<
(
log_internal
:
:
LogMessage
&
m
AsLiteralImpl
as_literal
)
{
as_literal
.
AddToMessage
(
m
)
;
return
m
;
}
}
;
enum
class
StructuredStringType
{
kLiteral
kNotLiteral
}
;
template
<
StructuredStringType
str_type
>
class
ABSL_MUST_USE_RESULT
AsStructuredStringTypeImpl
final
{
public
:
constexpr
AsStructuredStringTypeImpl
(
absl
:
:
string_view
str
ABSL_ATTRIBUTE_LIFETIME_BOUND
StructuredProtoField
field
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
:
str_
(
str
)
field_
(
field
)
{
}
private
:
absl
:
:
string_view
str_
;
StructuredProtoField
field_
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
AsStructuredStringTypeImpl
&
impl
)
{
return
os
<
<
impl
.
str_
;
}
void
AddToMessage
(
LogMessage
&
m
)
const
{
if
(
str_type
=
=
StructuredStringType
:
:
kLiteral
)
{
return
m
.
CopyToEncodedBufferWithStructuredProtoField
<
log_internal
:
:
LogMessage
:
:
StringType
:
:
kLiteral
>
(
field_
str_
)
;
}
else
{
return
m
.
CopyToEncodedBufferWithStructuredProtoField
<
log_internal
:
:
LogMessage
:
:
StringType
:
:
kNotLiteral
>
(
field_
str_
)
;
}
}
friend
LogMessage
&
operator
<
<
(
LogMessage
&
m
const
AsStructuredStringTypeImpl
&
impl
)
{
impl
.
AddToMessage
(
m
)
;
return
m
;
}
}
;
using
AsStructuredLiteralImpl
=
AsStructuredStringTypeImpl
<
StructuredStringType
:
:
kLiteral
>
;
using
AsStructuredNotLiteralImpl
=
AsStructuredStringTypeImpl
<
StructuredStringType
:
:
kNotLiteral
>
;
template
<
typename
T
>
class
ABSL_MUST_USE_RESULT
AsStructuredValueImpl
final
{
public
:
using
ValueFormatter
=
absl
:
:
AnyInvocable
<
std
:
:
string
(
T
)
const
>
;
constexpr
AsStructuredValueImpl
(
T
value
ABSL_ATTRIBUTE_LIFETIME_BOUND
StructuredProtoField
field
ABSL_ATTRIBUTE_LIFETIME_BOUND
ValueFormatter
value_formatter
=
[
]
(
T
value
)
{
return
absl
:
:
StrCat
(
value
)
;
}
)
:
value_
(
value
)
field_
(
field
)
value_formatter_
(
std
:
:
move
(
value_formatter
)
)
{
}
private
:
T
value_
;
StructuredProtoField
field_
;
ValueFormatter
value_formatter_
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
AsStructuredValueImpl
&
impl
)
{
return
os
<
<
impl
.
value_formatter_
(
impl
.
value_
)
;
}
void
AddToMessage
(
LogMessage
&
m
)
const
{
m
.
CopyToEncodedBufferWithStructuredProtoField
<
log_internal
:
:
LogMessage
:
:
StringType
:
:
kNotLiteral
>
(
field_
value_formatter_
(
value_
)
)
;
}
friend
LogMessage
&
operator
<
<
(
LogMessage
&
m
const
AsStructuredValueImpl
&
impl
)
{
impl
.
AddToMessage
(
m
)
;
return
m
;
}
}
;
template
<
typename
T
>
AsStructuredValueImpl
(
T
value
StructuredProtoField
field
)
-
>
AsStructuredValueImpl
<
T
>
;
template
<
typename
T
>
AsStructuredValueImpl
(
T
value
StructuredProtoField
field
typename
AsStructuredValueImpl
<
T
>
:
:
ValueFormatter
value_formatter
)
-
>
AsStructuredValueImpl
<
T
>
;
}
ABSL_NAMESPACE_END
}
#
endif
