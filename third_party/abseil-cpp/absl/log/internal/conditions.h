#
ifndef
ABSL_LOG_INTERNAL_CONDITIONS_H_
#
define
ABSL_LOG_INTERNAL_CONDITIONS_H_
#
if
defined
(
_WIN32
)
|
|
defined
(
__hexagon__
)
#
include
<
cstdlib
>
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
<
stdlib
.
h
>
#
include
<
atomic
>
#
include
<
cstdint
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
log
/
internal
/
voidify
.
h
"
#
define
ABSL_LOG_INTERNAL_STATELESS_CONDITION
(
condition
)
\
switch
(
0
)
\
case
0
:
\
default
:
\
!
(
condition
)
?
(
void
)
0
:
:
:
absl
:
:
log_internal
:
:
Voidify
(
)
&
&
#
define
ABSL_LOG_INTERNAL_STATEFUL_CONDITION
(
condition
)
\
for
(
bool
absl_log_internal_stateful_condition_do_log
(
condition
)
;
\
absl_log_internal_stateful_condition_do_log
;
\
absl_log_internal_stateful_condition_do_log
=
false
)
\
ABSL_LOG_INTERNAL_STATEFUL_CONDITION_IMPL
#
define
ABSL_LOG_INTERNAL_STATEFUL_CONDITION_IMPL
(
kind
.
.
.
)
\
for
(
static
:
:
absl
:
:
log_internal
:
:
Log
#
#
kind
#
#
State
\
absl_log_internal_stateful_condition_state
;
\
absl_log_internal_stateful_condition_do_log
&
&
\
absl_log_internal_stateful_condition_state
.
ShouldLog
(
__VA_ARGS__
)
;
\
absl_log_internal_stateful_condition_do_log
=
false
)
\
for
(
const
uint32_t
COUNTER
ABSL_ATTRIBUTE_UNUSED
=
\
absl_log_internal_stateful_condition_state
.
counter
(
)
;
\
absl_log_internal_stateful_condition_do_log
;
\
absl_log_internal_stateful_condition_do_log
=
false
)
\
:
:
absl
:
:
log_internal
:
:
Voidify
(
)
&
&
#
ifdef
ABSL_MIN_LOG_LEVEL
#
define
ABSL_LOG_INTERNAL_CONDITION_INFO
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
\
(
condition
)
&
&
:
:
absl
:
:
LogSeverity
:
:
kInfo
>
=
\
static_cast
<
:
:
absl
:
:
LogSeverity
>
(
ABSL_MIN_LOG_LEVEL
)
)
#
define
ABSL_LOG_INTERNAL_CONDITION_WARNING
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
\
(
condition
)
&
&
:
:
absl
:
:
LogSeverity
:
:
kWarning
>
=
\
static_cast
<
:
:
absl
:
:
LogSeverity
>
(
ABSL_MIN_LOG_LEVEL
)
)
#
define
ABSL_LOG_INTERNAL_CONDITION_ERROR
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
\
(
condition
)
&
&
:
:
absl
:
:
LogSeverity
:
:
kError
>
=
\
static_cast
<
:
:
absl
:
:
LogSeverity
>
(
ABSL_MIN_LOG_LEVEL
)
)
#
define
ABSL_LOG_INTERNAL_CONDITION_DO_NOT_SUBMIT
(
type
condition
)
\
ABSL_LOG_INTERNAL_CONDITION_ERROR
(
type
condition
)
#
define
ABSL_LOG_INTERNAL_CONDITION_FATAL
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
\
(
(
condition
)
\
?
(
:
:
absl
:
:
LogSeverity
:
:
kFatal
>
=
\
static_cast
<
:
:
absl
:
:
LogSeverity
>
(
ABSL_MIN_LOG_LEVEL
)
\
?
true
\
:
(
:
:
absl
:
:
log_internal
:
:
AbortQuietly
(
)
false
)
)
\
:
false
)
)
#
define
ABSL_LOG_INTERNAL_CONDITION_QFATAL
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
\
(
(
condition
)
\
?
(
:
:
absl
:
:
LogSeverity
:
:
kFatal
>
=
\
static_cast
<
:
:
absl
:
:
LogSeverity
>
(
ABSL_MIN_LOG_LEVEL
)
\
?
true
\
:
(
:
:
absl
:
:
log_internal
:
:
ExitQuietly
(
)
false
)
)
\
:
false
)
)
#
define
ABSL_LOG_INTERNAL_CONDITION_DFATAL
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
\
(
ABSL_ASSUME
(
absl
:
:
kLogDebugFatal
=
=
absl
:
:
LogSeverity
:
:
kError
|
|
\
absl
:
:
kLogDebugFatal
=
=
absl
:
:
LogSeverity
:
:
kFatal
)
\
(
condition
)
&
&
\
(
:
:
absl
:
:
kLogDebugFatal
>
=
\
static_cast
<
:
:
absl
:
:
LogSeverity
>
(
ABSL_MIN_LOG_LEVEL
)
|
|
\
(
:
:
absl
:
:
kLogDebugFatal
=
=
:
:
absl
:
:
LogSeverity
:
:
kFatal
&
&
\
(
:
:
absl
:
:
log_internal
:
:
AbortQuietly
(
)
false
)
)
)
)
)
#
define
ABSL_LOG_INTERNAL_CONDITION_LEVEL
(
severity
)
\
for
(
int
absl_log_internal_severity_loop
=
1
;
\
absl_log_internal_severity_loop
;
absl_log_internal_severity_loop
=
0
)
\
for
(
const
absl
:
:
LogSeverity
absl_log_internal_severity
=
\
:
:
absl
:
:
NormalizeLogSeverity
(
severity
)
;
\
absl_log_internal_severity_loop
;
absl_log_internal_severity_loop
=
0
)
\
ABSL_LOG_INTERNAL_CONDITION_LEVEL_IMPL
#
define
ABSL_LOG_INTERNAL_CONDITION_LEVEL_IMPL
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
(
\
(
condition
)
&
&
\
(
absl_log_internal_severity
>
=
\
static_cast
<
:
:
absl
:
:
LogSeverity
>
(
ABSL_MIN_LOG_LEVEL
)
|
|
\
(
absl_log_internal_severity
=
=
:
:
absl
:
:
LogSeverity
:
:
kFatal
&
&
\
(
:
:
absl
:
:
log_internal
:
:
AbortQuietly
(
)
false
)
)
)
)
)
#
else
#
define
ABSL_LOG_INTERNAL_CONDITION_INFO
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
condition
)
#
define
ABSL_LOG_INTERNAL_CONDITION_WARNING
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
condition
)
#
define
ABSL_LOG_INTERNAL_CONDITION_ERROR
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
condition
)
#
define
ABSL_LOG_INTERNAL_CONDITION_DO_NOT_SUBMIT
(
type
condition
)
\
ABSL_LOG_INTERNAL_CONDITION_ERROR
(
type
condition
)
#
define
ABSL_LOG_INTERNAL_CONDITION_FATAL
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
condition
)
#
define
ABSL_LOG_INTERNAL_CONDITION_QFATAL
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
condition
)
#
define
ABSL_LOG_INTERNAL_CONDITION_DFATAL
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
condition
)
#
define
ABSL_LOG_INTERNAL_CONDITION_LEVEL
(
severity
)
\
for
(
int
absl_log_internal_severity_loop
=
1
;
\
absl_log_internal_severity_loop
;
absl_log_internal_severity_loop
=
0
)
\
for
(
const
absl
:
:
LogSeverity
absl_log_internal_severity
=
\
:
:
absl
:
:
NormalizeLogSeverity
(
severity
)
;
\
absl_log_internal_severity_loop
;
absl_log_internal_severity_loop
=
0
)
\
ABSL_LOG_INTERNAL_CONDITION_LEVEL_IMPL
#
define
ABSL_LOG_INTERNAL_CONDITION_LEVEL_IMPL
(
type
condition
)
\
ABSL_LOG_INTERNAL_
#
#
type
#
#
_CONDITION
(
condition
)
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
log_internal
{
class
LogEveryNState
final
{
public
:
bool
ShouldLog
(
int
n
)
;
uint32_t
counter
(
)
{
return
counter_
.
load
(
std
:
:
memory_order_relaxed
)
;
}
private
:
std
:
:
atomic
<
uint32_t
>
counter_
{
0
}
;
}
;
class
LogFirstNState
final
{
public
:
bool
ShouldLog
(
int
n
)
;
uint32_t
counter
(
)
{
return
counter_
.
load
(
std
:
:
memory_order_relaxed
)
;
}
private
:
std
:
:
atomic
<
uint32_t
>
counter_
{
0
}
;
}
;
class
LogEveryPow2State
final
{
public
:
bool
ShouldLog
(
)
;
uint32_t
counter
(
)
{
return
counter_
.
load
(
std
:
:
memory_order_relaxed
)
;
}
private
:
std
:
:
atomic
<
uint32_t
>
counter_
{
0
}
;
}
;
class
LogEveryNSecState
final
{
public
:
bool
ShouldLog
(
double
seconds
)
;
uint32_t
counter
(
)
{
return
counter_
.
load
(
std
:
:
memory_order_relaxed
)
;
}
private
:
std
:
:
atomic
<
uint32_t
>
counter_
{
0
}
;
std
:
:
atomic
<
int64_t
>
next_log_time_cycles_
{
0
}
;
}
;
[
[
noreturn
]
]
inline
void
AbortQuietly
(
)
{
abort
(
)
;
}
[
[
noreturn
]
]
inline
void
ExitQuietly
(
)
{
_exit
(
1
)
;
}
}
ABSL_NAMESPACE_END
}
#
endif
