#
ifndef
ABSL_FLAGS_MARSHALLING_H_
#
define
ABSL_FLAGS_MARSHALLING_H_
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
numeric
/
int128
.
h
"
#
if
defined
(
ABSL_HAVE_STD_OPTIONAL
)
&
&
!
defined
(
ABSL_USES_STD_OPTIONAL
)
#
include
<
optional
>
#
endif
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
T
>
inline
bool
ParseFlag
(
absl
:
:
string_view
input
T
*
dst
std
:
:
string
*
error
)
;
template
<
typename
T
>
inline
std
:
:
string
UnparseFlag
(
const
T
&
v
)
;
namespace
flags_internal
{
bool
AbslParseFlag
(
absl
:
:
string_view
bool
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
short
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
unsigned
short
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
int
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
unsigned
int
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
long
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
unsigned
long
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
long
long
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
unsigned
long
long
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
absl
:
:
int128
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
absl
:
:
uint128
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
float
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
double
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
std
:
:
string
*
std
:
:
string
*
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
std
:
:
vector
<
std
:
:
string
>
*
std
:
:
string
*
)
;
template
<
typename
T
>
bool
AbslParseFlag
(
absl
:
:
string_view
text
absl
:
:
optional
<
T
>
*
f
std
:
:
string
*
err
)
{
if
(
text
.
empty
(
)
)
{
*
f
=
absl
:
:
nullopt
;
return
true
;
}
T
value
;
if
(
!
absl
:
:
ParseFlag
(
text
&
value
err
)
)
return
false
;
*
f
=
std
:
:
move
(
value
)
;
return
true
;
}
#
if
defined
(
ABSL_HAVE_STD_OPTIONAL
)
&
&
!
defined
(
ABSL_USES_STD_OPTIONAL
)
template
<
typename
T
>
bool
AbslParseFlag
(
absl
:
:
string_view
text
std
:
:
optional
<
T
>
*
f
std
:
:
string
*
err
)
{
if
(
text
.
empty
(
)
)
{
*
f
=
std
:
:
nullopt
;
return
true
;
}
T
value
;
if
(
!
absl
:
:
ParseFlag
(
text
&
value
err
)
)
return
false
;
*
f
=
std
:
:
move
(
value
)
;
return
true
;
}
#
endif
template
<
typename
T
>
bool
InvokeParseFlag
(
absl
:
:
string_view
input
T
*
dst
std
:
:
string
*
err
)
{
return
AbslParseFlag
(
input
dst
err
)
;
}
std
:
:
string
AbslUnparseFlag
(
absl
:
:
string_view
v
)
;
std
:
:
string
AbslUnparseFlag
(
const
std
:
:
vector
<
std
:
:
string
>
&
)
;
template
<
typename
T
>
std
:
:
string
AbslUnparseFlag
(
const
absl
:
:
optional
<
T
>
&
f
)
{
return
f
.
has_value
(
)
?
absl
:
:
UnparseFlag
(
*
f
)
:
"
"
;
}
#
if
defined
(
ABSL_HAVE_STD_OPTIONAL
)
&
&
!
defined
(
ABSL_USES_STD_OPTIONAL
)
template
<
typename
T
>
std
:
:
string
AbslUnparseFlag
(
const
std
:
:
optional
<
T
>
&
f
)
{
return
f
.
has_value
(
)
?
absl
:
:
UnparseFlag
(
*
f
)
:
"
"
;
}
#
endif
template
<
typename
T
>
std
:
:
string
Unparse
(
const
T
&
v
)
{
return
AbslUnparseFlag
(
v
)
;
}
std
:
:
string
Unparse
(
bool
v
)
;
std
:
:
string
Unparse
(
short
v
)
;
std
:
:
string
Unparse
(
unsigned
short
v
)
;
std
:
:
string
Unparse
(
int
v
)
;
std
:
:
string
Unparse
(
unsigned
int
v
)
;
std
:
:
string
Unparse
(
long
v
)
;
std
:
:
string
Unparse
(
unsigned
long
v
)
;
std
:
:
string
Unparse
(
long
long
v
)
;
std
:
:
string
Unparse
(
unsigned
long
long
v
)
;
std
:
:
string
Unparse
(
absl
:
:
int128
v
)
;
std
:
:
string
Unparse
(
absl
:
:
uint128
v
)
;
std
:
:
string
Unparse
(
float
v
)
;
std
:
:
string
Unparse
(
double
v
)
;
}
template
<
typename
T
>
inline
bool
ParseFlag
(
absl
:
:
string_view
input
T
*
dst
std
:
:
string
*
error
)
{
return
flags_internal
:
:
InvokeParseFlag
(
input
dst
error
)
;
}
template
<
typename
T
>
inline
std
:
:
string
UnparseFlag
(
const
T
&
v
)
{
return
flags_internal
:
:
Unparse
(
v
)
;
}
enum
class
LogSeverity
:
int
;
bool
AbslParseFlag
(
absl
:
:
string_view
absl
:
:
LogSeverity
*
std
:
:
string
*
)
;
std
:
:
string
AbslUnparseFlag
(
absl
:
:
LogSeverity
)
;
ABSL_NAMESPACE_END
}
#
endif
