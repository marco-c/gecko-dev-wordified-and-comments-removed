#
ifndef
ABSL_CRC_INTERNAL_CRC_MEMCPY_H_
#
define
ABSL_CRC_INTERNAL_CRC_MEMCPY_H_
#
include
<
cstddef
>
#
include
<
memory
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
crc
/
crc32c
.
h
"
#
include
"
absl
/
crc
/
internal
/
crc32_x86_arm_combined_simd
.
h
"
#
if
defined
(
ABSL_CRC_INTERNAL_HAVE_X86_SIMD
)
#
define
ABSL_INTERNAL_HAVE_X86_64_ACCELERATED_CRC_MEMCPY_ENGINE
1
#
elif
defined
(
ABSL_CRC_INTERNAL_HAVE_ARM_SIMD
)
#
define
ABSL_INTERNAL_HAVE_ARM_ACCELERATED_CRC_MEMCPY_ENGINE
1
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
crc_internal
{
class
CrcMemcpyEngine
{
public
:
virtual
~
CrcMemcpyEngine
(
)
=
default
;
virtual
crc32c_t
Compute
(
void
*
__restrict
dst
const
void
*
__restrict
src
std
:
:
size_t
length
crc32c_t
initial_crc
)
const
=
0
;
protected
:
CrcMemcpyEngine
(
)
=
default
;
}
;
class
CrcMemcpy
{
public
:
static
crc32c_t
CrcAndCopy
(
void
*
__restrict
dst
const
void
*
__restrict
src
std
:
:
size_t
length
crc32c_t
initial_crc
=
crc32c_t
{
0
}
bool
non_temporal
=
false
)
{
static
const
ArchSpecificEngines
engines
=
GetArchSpecificEngines
(
)
;
auto
*
engine
=
non_temporal
?
engines
.
non_temporal
:
engines
.
temporal
;
return
engine
-
>
Compute
(
dst
src
length
initial_crc
)
;
}
static
std
:
:
unique_ptr
<
CrcMemcpyEngine
>
GetTestEngine
(
int
vector
int
integer
)
;
private
:
struct
ArchSpecificEngines
{
CrcMemcpyEngine
*
temporal
;
CrcMemcpyEngine
*
non_temporal
;
}
;
static
ArchSpecificEngines
GetArchSpecificEngines
(
)
;
}
;
class
FallbackCrcMemcpyEngine
:
public
CrcMemcpyEngine
{
public
:
FallbackCrcMemcpyEngine
(
)
=
default
;
FallbackCrcMemcpyEngine
(
const
FallbackCrcMemcpyEngine
&
)
=
delete
;
FallbackCrcMemcpyEngine
operator
=
(
const
FallbackCrcMemcpyEngine
&
)
=
delete
;
crc32c_t
Compute
(
void
*
__restrict
dst
const
void
*
__restrict
src
std
:
:
size_t
length
crc32c_t
initial_crc
)
const
override
;
}
;
class
CrcNonTemporalMemcpyEngine
:
public
CrcMemcpyEngine
{
public
:
CrcNonTemporalMemcpyEngine
(
)
=
default
;
CrcNonTemporalMemcpyEngine
(
const
CrcNonTemporalMemcpyEngine
&
)
=
delete
;
CrcNonTemporalMemcpyEngine
operator
=
(
const
CrcNonTemporalMemcpyEngine
&
)
=
delete
;
crc32c_t
Compute
(
void
*
__restrict
dst
const
void
*
__restrict
src
std
:
:
size_t
length
crc32c_t
initial_crc
)
const
override
;
}
;
class
CrcNonTemporalMemcpyAVXEngine
:
public
CrcMemcpyEngine
{
public
:
CrcNonTemporalMemcpyAVXEngine
(
)
=
default
;
CrcNonTemporalMemcpyAVXEngine
(
const
CrcNonTemporalMemcpyAVXEngine
&
)
=
delete
;
CrcNonTemporalMemcpyAVXEngine
operator
=
(
const
CrcNonTemporalMemcpyAVXEngine
&
)
=
delete
;
crc32c_t
Compute
(
void
*
__restrict
dst
const
void
*
__restrict
src
std
:
:
size_t
length
crc32c_t
initial_crc
)
const
override
;
}
;
inline
crc32c_t
Crc32CAndCopy
(
void
*
__restrict
dst
const
void
*
__restrict
src
std
:
:
size_t
length
crc32c_t
initial_crc
=
crc32c_t
{
0
}
bool
non_temporal
=
false
)
{
return
CrcMemcpy
:
:
CrcAndCopy
(
dst
src
length
initial_crc
non_temporal
)
;
}
}
ABSL_NAMESPACE_END
}
#
endif
