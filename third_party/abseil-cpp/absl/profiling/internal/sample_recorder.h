#
ifndef
ABSL_PROFILING_INTERNAL_SAMPLE_RECORDER_H_
#
define
ABSL_PROFILING_INTERNAL_SAMPLE_RECORDER_H_
#
include
<
atomic
>
#
include
<
cstddef
>
#
include
<
functional
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
thread_annotations
.
h
"
#
include
"
absl
/
synchronization
/
mutex
.
h
"
#
include
"
absl
/
time
/
time
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
profiling_internal
{
template
<
typename
T
>
struct
Sample
{
absl
:
:
Mutex
init_mu
;
T
*
next
=
nullptr
;
T
*
dead
ABSL_GUARDED_BY
(
init_mu
)
=
nullptr
;
int64_t
weight
;
}
;
template
<
typename
T
>
class
SampleRecorder
{
public
:
SampleRecorder
(
)
;
~
SampleRecorder
(
)
;
template
<
typename
.
.
.
Targs
>
T
*
Register
(
Targs
&
&
.
.
.
args
)
;
void
Unregister
(
T
*
sample
)
;
using
DisposeCallback
=
void
(
*
)
(
const
T
&
)
;
DisposeCallback
SetDisposeCallback
(
DisposeCallback
f
)
;
int64_t
Iterate
(
const
std
:
:
function
<
void
(
const
T
&
stack
)
>
&
f
)
;
size_t
GetMaxSamples
(
)
const
;
void
SetMaxSamples
(
size_t
max
)
;
private
:
void
PushNew
(
T
*
sample
)
;
void
PushDead
(
T
*
sample
)
;
template
<
typename
.
.
.
Targs
>
T
*
PopDead
(
Targs
.
.
.
args
)
;
std
:
:
atomic
<
size_t
>
dropped_samples_
;
std
:
:
atomic
<
size_t
>
size_estimate_
;
std
:
:
atomic
<
size_t
>
max_samples_
{
1
<
<
20
}
;
std
:
:
atomic
<
T
*
>
all_
;
T
graveyard_
;
std
:
:
atomic
<
DisposeCallback
>
dispose_
;
}
;
template
<
typename
T
>
typename
SampleRecorder
<
T
>
:
:
DisposeCallback
SampleRecorder
<
T
>
:
:
SetDisposeCallback
(
DisposeCallback
f
)
{
return
dispose_
.
exchange
(
f
std
:
:
memory_order_relaxed
)
;
}
template
<
typename
T
>
SampleRecorder
<
T
>
:
:
SampleRecorder
(
)
:
dropped_samples_
(
0
)
size_estimate_
(
0
)
all_
(
nullptr
)
dispose_
(
nullptr
)
{
absl
:
:
MutexLock
l
(
&
graveyard_
.
init_mu
)
;
graveyard_
.
dead
=
&
graveyard_
;
}
template
<
typename
T
>
SampleRecorder
<
T
>
:
:
~
SampleRecorder
(
)
{
T
*
s
=
all_
.
load
(
std
:
:
memory_order_acquire
)
;
while
(
s
!
=
nullptr
)
{
T
*
next
=
s
-
>
next
;
delete
s
;
s
=
next
;
}
}
template
<
typename
T
>
void
SampleRecorder
<
T
>
:
:
PushNew
(
T
*
sample
)
{
sample
-
>
next
=
all_
.
load
(
std
:
:
memory_order_relaxed
)
;
while
(
!
all_
.
compare_exchange_weak
(
sample
-
>
next
sample
std
:
:
memory_order_release
std
:
:
memory_order_relaxed
)
)
{
}
}
template
<
typename
T
>
void
SampleRecorder
<
T
>
:
:
PushDead
(
T
*
sample
)
{
if
(
auto
*
dispose
=
dispose_
.
load
(
std
:
:
memory_order_relaxed
)
)
{
dispose
(
*
sample
)
;
}
absl
:
:
MutexLock
graveyard_lock
(
&
graveyard_
.
init_mu
)
;
absl
:
:
MutexLock
sample_lock
(
&
sample
-
>
init_mu
)
;
sample
-
>
dead
=
graveyard_
.
dead
;
graveyard_
.
dead
=
sample
;
}
template
<
typename
T
>
template
<
typename
.
.
.
Targs
>
T
*
SampleRecorder
<
T
>
:
:
PopDead
(
Targs
.
.
.
args
)
{
absl
:
:
MutexLock
graveyard_lock
(
&
graveyard_
.
init_mu
)
;
T
*
sample
=
graveyard_
.
dead
;
if
(
sample
=
=
&
graveyard_
)
return
nullptr
;
absl
:
:
MutexLock
sample_lock
(
&
sample
-
>
init_mu
)
;
graveyard_
.
dead
=
sample
-
>
dead
;
sample
-
>
dead
=
nullptr
;
sample
-
>
PrepareForSampling
(
std
:
:
forward
<
Targs
>
(
args
)
.
.
.
)
;
return
sample
;
}
template
<
typename
T
>
template
<
typename
.
.
.
Targs
>
T
*
SampleRecorder
<
T
>
:
:
Register
(
Targs
&
&
.
.
.
args
)
{
size_t
size
=
size_estimate_
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
if
(
size
>
max_samples_
.
load
(
std
:
:
memory_order_relaxed
)
)
{
size_estimate_
.
fetch_sub
(
1
std
:
:
memory_order_relaxed
)
;
dropped_samples_
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
return
nullptr
;
}
T
*
sample
=
PopDead
(
args
.
.
.
)
;
if
(
sample
=
=
nullptr
)
{
sample
=
new
T
(
)
;
{
absl
:
:
MutexLock
sample_lock
(
&
sample
-
>
init_mu
)
;
sample
-
>
init_mu
.
ForgetDeadlockInfo
(
)
;
sample
-
>
PrepareForSampling
(
std
:
:
forward
<
Targs
>
(
args
)
.
.
.
)
;
}
PushNew
(
sample
)
;
}
return
sample
;
}
template
<
typename
T
>
void
SampleRecorder
<
T
>
:
:
Unregister
(
T
*
sample
)
{
PushDead
(
sample
)
;
size_estimate_
.
fetch_sub
(
1
std
:
:
memory_order_relaxed
)
;
}
template
<
typename
T
>
int64_t
SampleRecorder
<
T
>
:
:
Iterate
(
const
std
:
:
function
<
void
(
const
T
&
stack
)
>
&
f
)
{
T
*
s
=
all_
.
load
(
std
:
:
memory_order_acquire
)
;
while
(
s
!
=
nullptr
)
{
absl
:
:
MutexLock
l
(
&
s
-
>
init_mu
)
;
if
(
s
-
>
dead
=
=
nullptr
)
{
f
(
*
s
)
;
}
s
=
s
-
>
next
;
}
return
dropped_samples_
.
load
(
std
:
:
memory_order_relaxed
)
;
}
template
<
typename
T
>
void
SampleRecorder
<
T
>
:
:
SetMaxSamples
(
size_t
max
)
{
max_samples_
.
store
(
max
std
:
:
memory_order_release
)
;
}
template
<
typename
T
>
size_t
SampleRecorder
<
T
>
:
:
GetMaxSamples
(
)
const
{
return
max_samples_
.
load
(
std
:
:
memory_order_acquire
)
;
}
}
ABSL_NAMESPACE_END
}
#
endif
