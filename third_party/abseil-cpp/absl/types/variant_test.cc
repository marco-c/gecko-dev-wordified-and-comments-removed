#
include
"
absl
/
types
/
variant
.
h
"
#
include
<
memory
>
#
include
<
string
>
#
include
<
variant
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
namespace
absl
{
namespace
{
using
:
:
testing
:
:
DoubleEq
;
using
:
:
testing
:
:
Pointee
;
using
:
:
testing
:
:
VariantWith
;
struct
Convertible2
;
struct
Convertible1
{
Convertible1
(
)
{
}
Convertible1
(
const
Convertible1
&
)
{
}
Convertible1
&
operator
=
(
const
Convertible1
&
)
{
return
*
this
;
}
Convertible1
(
const
Convertible2
&
)
{
}
}
;
struct
Convertible2
{
Convertible2
(
)
{
}
Convertible2
(
const
Convertible2
&
)
{
}
Convertible2
&
operator
=
(
const
Convertible2
&
)
{
return
*
this
;
}
Convertible2
(
const
Convertible1
&
)
{
}
}
;
TEST
(
VariantTest
TestRvalueConversion
)
{
std
:
:
variant
<
Convertible1
Convertible2
>
v
(
ConvertVariantTo
<
std
:
:
variant
<
Convertible1
Convertible2
>
>
(
(
std
:
:
variant
<
Convertible2
Convertible1
>
(
Convertible1
(
)
)
)
)
)
;
ASSERT_TRUE
(
absl
:
:
holds_alternative
<
Convertible1
>
(
v
)
)
;
v
=
ConvertVariantTo
<
std
:
:
variant
<
Convertible1
Convertible2
>
>
(
std
:
:
variant
<
Convertible2
Convertible1
>
(
Convertible2
(
)
)
)
;
ASSERT_TRUE
(
absl
:
:
holds_alternative
<
Convertible2
>
(
v
)
)
;
}
TEST
(
VariantTest
TestLvalueConversion
)
{
std
:
:
variant
<
Convertible2
Convertible1
>
source
(
(
Convertible1
(
)
)
)
;
std
:
:
variant
<
Convertible1
Convertible2
>
v
(
ConvertVariantTo
<
std
:
:
variant
<
Convertible1
Convertible2
>
>
(
source
)
)
;
ASSERT_TRUE
(
absl
:
:
holds_alternative
<
Convertible1
>
(
v
)
)
;
source
=
Convertible2
(
)
;
v
=
ConvertVariantTo
<
std
:
:
variant
<
Convertible1
Convertible2
>
>
(
source
)
;
ASSERT_TRUE
(
absl
:
:
holds_alternative
<
Convertible2
>
(
v
)
)
;
}
TEST
(
VariantTest
TestMoveConversion
)
{
using
Variant
=
std
:
:
variant
<
std
:
:
unique_ptr
<
const
int
>
std
:
:
unique_ptr
<
const
std
:
:
string
>
>
;
using
OtherVariant
=
std
:
:
variant
<
std
:
:
unique_ptr
<
int
>
std
:
:
unique_ptr
<
std
:
:
string
>
>
;
Variant
var
(
ConvertVariantTo
<
Variant
>
(
OtherVariant
{
std
:
:
make_unique
<
int
>
(
0
)
}
)
)
;
ASSERT_TRUE
(
absl
:
:
holds_alternative
<
std
:
:
unique_ptr
<
const
int
>
>
(
var
)
)
;
ASSERT_NE
(
absl
:
:
get
<
std
:
:
unique_ptr
<
const
int
>
>
(
var
)
nullptr
)
;
EXPECT_EQ
(
0
*
absl
:
:
get
<
std
:
:
unique_ptr
<
const
int
>
>
(
var
)
)
;
var
=
ConvertVariantTo
<
Variant
>
(
OtherVariant
(
std
:
:
make_unique
<
std
:
:
string
>
(
"
foo
"
)
)
)
;
ASSERT_TRUE
(
absl
:
:
holds_alternative
<
std
:
:
unique_ptr
<
const
std
:
:
string
>
>
(
var
)
)
;
EXPECT_EQ
(
"
foo
"
*
absl
:
:
get
<
std
:
:
unique_ptr
<
const
std
:
:
string
>
>
(
var
)
)
;
}
TEST
(
VariantTest
DoesNotMoveFromLvalues
)
{
using
Variant
=
std
:
:
variant
<
std
:
:
shared_ptr
<
const
int
>
std
:
:
shared_ptr
<
const
std
:
:
string
>
>
;
using
OtherVariant
=
std
:
:
variant
<
std
:
:
shared_ptr
<
int
>
std
:
:
shared_ptr
<
std
:
:
string
>
>
;
Variant
v1
(
std
:
:
make_shared
<
const
int
>
(
0
)
)
;
Variant
v2
(
v1
)
;
EXPECT_EQ
(
absl
:
:
get
<
std
:
:
shared_ptr
<
const
int
>
>
(
v1
)
absl
:
:
get
<
std
:
:
shared_ptr
<
const
int
>
>
(
v2
)
)
;
v1
=
std
:
:
make_shared
<
const
std
:
:
string
>
(
"
foo
"
)
;
v2
=
v1
;
EXPECT_EQ
(
absl
:
:
get
<
std
:
:
shared_ptr
<
const
std
:
:
string
>
>
(
v1
)
absl
:
:
get
<
std
:
:
shared_ptr
<
const
std
:
:
string
>
>
(
v2
)
)
;
OtherVariant
other
(
std
:
:
make_shared
<
int
>
(
0
)
)
;
Variant
v3
(
ConvertVariantTo
<
Variant
>
(
other
)
)
;
EXPECT_EQ
(
absl
:
:
get
<
std
:
:
shared_ptr
<
int
>
>
(
other
)
absl
:
:
get
<
std
:
:
shared_ptr
<
const
int
>
>
(
v3
)
)
;
other
=
std
:
:
make_shared
<
std
:
:
string
>
(
"
foo
"
)
;
v3
=
ConvertVariantTo
<
Variant
>
(
other
)
;
EXPECT_EQ
(
absl
:
:
get
<
std
:
:
shared_ptr
<
std
:
:
string
>
>
(
other
)
absl
:
:
get
<
std
:
:
shared_ptr
<
const
std
:
:
string
>
>
(
v3
)
)
;
}
TEST
(
VariantTest
TestRvalueConversionViaConvertVariantTo
)
{
variant
<
Convertible1
Convertible2
>
v
(
ConvertVariantTo
<
std
:
:
variant
<
Convertible1
Convertible2
>
>
(
(
std
:
:
variant
<
Convertible2
Convertible1
>
(
Convertible1
(
)
)
)
)
)
;
ASSERT_TRUE
(
absl
:
:
holds_alternative
<
Convertible1
>
(
v
)
)
;
v
=
ConvertVariantTo
<
std
:
:
variant
<
Convertible1
Convertible2
>
>
(
std
:
:
variant
<
Convertible2
Convertible1
>
(
Convertible2
(
)
)
)
;
ASSERT_TRUE
(
absl
:
:
holds_alternative
<
Convertible2
>
(
v
)
)
;
}
TEST
(
VariantTest
TestLvalueConversionViaConvertVariantTo
)
{
variant
<
Convertible2
Convertible1
>
source
(
(
Convertible1
(
)
)
)
;
variant
<
Convertible1
Convertible2
>
v
(
ConvertVariantTo
<
std
:
:
variant
<
Convertible1
Convertible2
>
>
(
source
)
)
;
ASSERT_TRUE
(
absl
:
:
holds_alternative
<
Convertible1
>
(
v
)
)
;
source
=
Convertible2
(
)
;
v
=
ConvertVariantTo
<
std
:
:
variant
<
Convertible1
Convertible2
>
>
(
source
)
;
ASSERT_TRUE
(
absl
:
:
holds_alternative
<
Convertible2
>
(
v
)
)
;
}
TEST
(
VariantTest
TestMoveConversionViaConvertVariantTo
)
{
using
Variant
=
std
:
:
variant
<
std
:
:
unique_ptr
<
const
int
>
std
:
:
unique_ptr
<
const
std
:
:
string
>
>
;
using
OtherVariant
=
std
:
:
variant
<
std
:
:
unique_ptr
<
int
>
std
:
:
unique_ptr
<
std
:
:
string
>
>
;
Variant
var
(
ConvertVariantTo
<
Variant
>
(
OtherVariant
{
std
:
:
make_unique
<
int
>
(
3
)
}
)
)
;
EXPECT_THAT
(
absl
:
:
get_if
<
std
:
:
unique_ptr
<
const
int
>
>
(
&
var
)
Pointee
(
Pointee
(
3
)
)
)
;
var
=
ConvertVariantTo
<
Variant
>
(
OtherVariant
(
std
:
:
make_unique
<
std
:
:
string
>
(
"
foo
"
)
)
)
;
EXPECT_THAT
(
absl
:
:
get_if
<
std
:
:
unique_ptr
<
const
std
:
:
string
>
>
(
&
var
)
Pointee
(
Pointee
(
std
:
:
string
(
"
foo
"
)
)
)
)
;
}
}
}
