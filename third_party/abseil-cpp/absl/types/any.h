#
ifndef
ABSL_TYPES_ANY_H_
#
define
ABSL_TYPES_ANY_H_
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
#
ifdef
ABSL_USES_STD_ANY
#
include
<
any
>
namespace
absl
{
ABSL_NAMESPACE_BEGIN
using
std
:
:
any
;
using
std
:
:
any_cast
;
using
std
:
:
bad_any_cast
;
using
std
:
:
make_any
;
ABSL_NAMESPACE_END
}
#
else
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
initializer_list
>
#
include
<
memory
>
#
include
<
stdexcept
>
#
include
<
type_traits
>
#
include
<
typeinfo
>
#
include
<
utility
>
#
include
"
absl
/
base
/
internal
/
fast_type_id
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
types
/
bad_any_cast
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
class
any
;
void
swap
(
any
&
x
any
&
y
)
noexcept
;
template
<
typename
T
typename
.
.
.
Args
>
any
make_any
(
Args
&
&
.
.
.
args
)
;
template
<
typename
T
typename
U
typename
.
.
.
Args
>
any
make_any
(
std
:
:
initializer_list
<
U
>
il
Args
&
&
.
.
.
args
)
;
template
<
typename
ValueType
>
ValueType
any_cast
(
const
any
&
operand
)
;
template
<
typename
ValueType
>
ValueType
any_cast
(
any
&
operand
)
;
template
<
typename
ValueType
>
ValueType
any_cast
(
any
&
&
operand
)
;
template
<
typename
ValueType
>
const
ValueType
*
any_cast
(
const
any
*
operand
)
noexcept
;
template
<
typename
ValueType
>
ValueType
*
any_cast
(
any
*
operand
)
noexcept
;
class
any
{
private
:
template
<
typename
T
>
struct
IsInPlaceType
;
public
:
constexpr
any
(
)
noexcept
;
any
(
const
any
&
other
)
:
obj_
(
other
.
has_value
(
)
?
other
.
obj_
-
>
Clone
(
)
:
std
:
:
unique_ptr
<
ObjInterface
>
(
)
)
{
}
any
(
any
&
&
other
)
noexcept
=
default
;
template
<
typename
T
typename
VT
=
absl
:
:
decay_t
<
T
>
absl
:
:
enable_if_t
<
!
absl
:
:
disjunction
<
std
:
:
is_same
<
any
VT
>
IsInPlaceType
<
VT
>
absl
:
:
negation
<
std
:
:
is_copy_constructible
<
VT
>
>
>
:
:
value
>
*
=
nullptr
>
any
(
T
&
&
value
)
:
obj_
(
new
Obj
<
VT
>
(
in_place
std
:
:
forward
<
T
>
(
value
)
)
)
{
}
template
<
typename
T
typename
.
.
.
Args
typename
VT
=
absl
:
:
decay_t
<
T
>
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
std
:
:
is_copy_constructible
<
VT
>
std
:
:
is_constructible
<
VT
Args
.
.
.
>
>
:
:
value
>
*
=
nullptr
>
explicit
any
(
in_place_type_t
<
T
>
Args
&
&
.
.
.
args
)
:
obj_
(
new
Obj
<
VT
>
(
in_place
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
{
}
template
<
typename
T
typename
U
typename
.
.
.
Args
typename
VT
=
absl
:
:
decay_t
<
T
>
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
std
:
:
is_copy_constructible
<
VT
>
std
:
:
is_constructible
<
VT
std
:
:
initializer_list
<
U
>
&
Args
.
.
.
>
>
:
:
value
>
*
=
nullptr
>
explicit
any
(
in_place_type_t
<
T
>
std
:
:
initializer_list
<
U
>
ilist
Args
&
&
.
.
.
args
)
:
obj_
(
new
Obj
<
VT
>
(
in_place
ilist
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
{
}
any
&
operator
=
(
const
any
&
rhs
)
{
any
(
rhs
)
.
swap
(
*
this
)
;
return
*
this
;
}
any
&
operator
=
(
any
&
&
rhs
)
noexcept
{
any
(
std
:
:
move
(
rhs
)
)
.
swap
(
*
this
)
;
return
*
this
;
}
template
<
typename
T
typename
VT
=
absl
:
:
decay_t
<
T
>
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
absl
:
:
negation
<
std
:
:
is_same
<
VT
any
>
>
std
:
:
is_copy_constructible
<
VT
>
>
:
:
value
>
*
=
nullptr
>
any
&
operator
=
(
T
&
&
rhs
)
{
any
tmp
(
in_place_type_t
<
VT
>
(
)
std
:
:
forward
<
T
>
(
rhs
)
)
;
tmp
.
swap
(
*
this
)
;
return
*
this
;
}
template
<
typename
T
typename
.
.
.
Args
typename
VT
=
absl
:
:
decay_t
<
T
>
absl
:
:
enable_if_t
<
std
:
:
is_copy_constructible
<
VT
>
:
:
value
&
&
std
:
:
is_constructible
<
VT
Args
.
.
.
>
:
:
value
>
*
=
nullptr
>
VT
&
emplace
(
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
reset
(
)
;
Obj
<
VT
>
*
const
object_ptr
=
new
Obj
<
VT
>
(
in_place
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
obj_
=
std
:
:
unique_ptr
<
ObjInterface
>
(
object_ptr
)
;
return
object_ptr
-
>
value
;
}
template
<
typename
T
typename
U
typename
.
.
.
Args
typename
VT
=
absl
:
:
decay_t
<
T
>
absl
:
:
enable_if_t
<
std
:
:
is_copy_constructible
<
VT
>
:
:
value
&
&
std
:
:
is_constructible
<
VT
std
:
:
initializer_list
<
U
>
&
Args
.
.
.
>
:
:
value
>
*
=
nullptr
>
VT
&
emplace
(
std
:
:
initializer_list
<
U
>
ilist
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
reset
(
)
;
Obj
<
VT
>
*
const
object_ptr
=
new
Obj
<
VT
>
(
in_place
ilist
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
obj_
=
std
:
:
unique_ptr
<
ObjInterface
>
(
object_ptr
)
;
return
object_ptr
-
>
value
;
}
void
reset
(
)
noexcept
{
obj_
=
nullptr
;
}
void
swap
(
any
&
other
)
noexcept
{
obj_
.
swap
(
other
.
obj_
)
;
}
bool
has_value
(
)
const
noexcept
{
return
obj_
!
=
nullptr
;
}
#
ifdef
ABSL_INTERNAL_HAS_RTTI
const
std
:
:
type_info
&
type
(
)
const
noexcept
{
if
(
has_value
(
)
)
{
return
obj_
-
>
Type
(
)
;
}
return
typeid
(
void
)
;
}
#
endif
private
:
class
ObjInterface
{
public
:
virtual
~
ObjInterface
(
)
=
default
;
virtual
std
:
:
unique_ptr
<
ObjInterface
>
Clone
(
)
const
=
0
;
virtual
const
void
*
ObjTypeId
(
)
const
noexcept
=
0
;
#
ifdef
ABSL_INTERNAL_HAS_RTTI
virtual
const
std
:
:
type_info
&
Type
(
)
const
noexcept
=
0
;
#
endif
}
;
template
<
typename
T
>
class
Obj
:
public
ObjInterface
{
public
:
template
<
typename
.
.
.
Args
>
explicit
Obj
(
in_place_t
Args
&
&
.
.
.
args
)
:
value
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
std
:
:
unique_ptr
<
ObjInterface
>
Clone
(
)
const
final
{
return
std
:
:
unique_ptr
<
ObjInterface
>
(
new
Obj
(
in_place
value
)
)
;
}
const
void
*
ObjTypeId
(
)
const
noexcept
final
{
return
IdForType
<
T
>
(
)
;
}
#
ifdef
ABSL_INTERNAL_HAS_RTTI
const
std
:
:
type_info
&
Type
(
)
const
noexcept
final
{
return
typeid
(
T
)
;
}
#
endif
T
value
;
}
;
std
:
:
unique_ptr
<
ObjInterface
>
CloneObj
(
)
const
{
if
(
!
obj_
)
return
nullptr
;
return
obj_
-
>
Clone
(
)
;
}
template
<
typename
T
>
constexpr
static
const
void
*
IdForType
(
)
{
using
NormalizedType
=
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
T
>
:
:
type
>
:
:
type
;
return
base_internal
:
:
FastTypeId
<
NormalizedType
>
(
)
;
}
const
void
*
GetObjTypeId
(
)
const
{
return
obj_
?
obj_
-
>
ObjTypeId
(
)
:
base_internal
:
:
FastTypeId
<
void
>
(
)
;
}
template
<
typename
ValueType
>
friend
ValueType
any_cast
(
const
any
&
operand
)
;
template
<
typename
ValueType
>
friend
ValueType
any_cast
(
any
&
operand
)
;
template
<
typename
T
>
friend
const
T
*
any_cast
(
const
any
*
operand
)
noexcept
;
template
<
typename
T
>
friend
T
*
any_cast
(
any
*
operand
)
noexcept
;
std
:
:
unique_ptr
<
ObjInterface
>
obj_
;
}
;
constexpr
any
:
:
any
(
)
noexcept
=
default
;
template
<
typename
T
>
struct
any
:
:
IsInPlaceType
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
any
:
:
IsInPlaceType
<
in_place_type_t
<
T
>
>
:
std
:
:
true_type
{
}
;
inline
void
swap
(
any
&
x
any
&
y
)
noexcept
{
x
.
swap
(
y
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
any
make_any
(
Args
&
&
.
.
.
args
)
{
return
any
(
in_place_type_t
<
T
>
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
U
typename
.
.
.
Args
>
any
make_any
(
std
:
:
initializer_list
<
U
>
il
Args
&
&
.
.
.
args
)
{
return
any
(
in_place_type_t
<
T
>
(
)
il
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
ValueType
>
ValueType
any_cast
(
const
any
&
operand
)
{
using
U
=
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
ValueType
>
:
:
type
>
:
:
type
;
static_assert
(
std
:
:
is_constructible
<
ValueType
const
U
&
>
:
:
value
"
Invalid
ValueType
"
)
;
auto
*
const
result
=
(
any_cast
<
U
>
)
(
&
operand
)
;
if
(
result
=
=
nullptr
)
{
any_internal
:
:
ThrowBadAnyCast
(
)
;
}
return
static_cast
<
ValueType
>
(
*
result
)
;
}
template
<
typename
ValueType
>
ValueType
any_cast
(
any
&
operand
)
{
using
U
=
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
ValueType
>
:
:
type
>
:
:
type
;
static_assert
(
std
:
:
is_constructible
<
ValueType
U
&
>
:
:
value
"
Invalid
ValueType
"
)
;
auto
*
result
=
(
any_cast
<
U
>
)
(
&
operand
)
;
if
(
result
=
=
nullptr
)
{
any_internal
:
:
ThrowBadAnyCast
(
)
;
}
return
static_cast
<
ValueType
>
(
*
result
)
;
}
template
<
typename
ValueType
>
ValueType
any_cast
(
any
&
&
operand
)
{
using
U
=
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
ValueType
>
:
:
type
>
:
:
type
;
static_assert
(
std
:
:
is_constructible
<
ValueType
U
>
:
:
value
"
Invalid
ValueType
"
)
;
return
static_cast
<
ValueType
>
(
std
:
:
move
(
(
any_cast
<
U
&
>
)
(
operand
)
)
)
;
}
template
<
typename
T
>
const
T
*
any_cast
(
const
any
*
operand
)
noexcept
{
using
U
=
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
T
>
:
:
type
>
:
:
type
;
return
operand
&
&
operand
-
>
GetObjTypeId
(
)
=
=
any
:
:
IdForType
<
U
>
(
)
?
std
:
:
addressof
(
static_cast
<
const
any
:
:
Obj
<
U
>
*
>
(
operand
-
>
obj_
.
get
(
)
)
-
>
value
)
:
nullptr
;
}
template
<
typename
T
>
T
*
any_cast
(
any
*
operand
)
noexcept
{
using
U
=
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
T
>
:
:
type
>
:
:
type
;
return
operand
&
&
operand
-
>
GetObjTypeId
(
)
=
=
any
:
:
IdForType
<
U
>
(
)
?
std
:
:
addressof
(
static_cast
<
any
:
:
Obj
<
U
>
*
>
(
operand
-
>
obj_
.
get
(
)
)
-
>
value
)
:
nullptr
;
}
ABSL_NAMESPACE_END
}
#
endif
#
endif
