#
ifndef
ABSL_TYPES_VARIANT_H_
#
define
ABSL_TYPES_VARIANT_H_
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
#
ifdef
ABSL_USES_STD_VARIANT
#
include
<
variant
>
namespace
absl
{
ABSL_NAMESPACE_BEGIN
using
std
:
:
bad_variant_access
;
using
std
:
:
get
;
using
std
:
:
get_if
;
using
std
:
:
holds_alternative
;
using
std
:
:
monostate
;
using
std
:
:
variant
;
using
std
:
:
variant_alternative
;
using
std
:
:
variant_alternative_t
;
using
std
:
:
variant_npos
;
using
std
:
:
variant_size
;
using
std
:
:
variant_size_v
;
using
std
:
:
visit
;
ABSL_NAMESPACE_END
}
#
else
#
include
<
functional
>
#
include
<
new
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
types
/
internal
/
variant
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
.
.
.
Ts
>
class
variant
;
template
<
typename
.
.
.
Ts
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
std
:
:
is_move_constructible
<
Ts
>
.
.
.
type_traits_internal
:
:
IsSwappable
<
Ts
>
.
.
.
>
:
:
value
int
>
=
0
>
void
swap
(
variant
<
Ts
.
.
.
>
&
v
variant
<
Ts
.
.
.
>
&
w
)
noexcept
(
noexcept
(
v
.
swap
(
w
)
)
)
{
v
.
swap
(
w
)
;
}
template
<
class
T
>
struct
variant_size
;
template
<
class
.
.
.
Ts
>
struct
variant_size
<
variant
<
Ts
.
.
.
>
>
:
std
:
:
integral_constant
<
std
:
:
size_t
sizeof
.
.
.
(
Ts
)
>
{
}
;
template
<
class
T
>
struct
variant_size
<
const
T
>
:
variant_size
<
T
>
:
:
type
{
}
;
template
<
class
T
>
struct
variant_size
<
volatile
T
>
:
variant_size
<
T
>
:
:
type
{
}
;
template
<
class
T
>
struct
variant_size
<
const
volatile
T
>
:
variant_size
<
T
>
:
:
type
{
}
;
template
<
std
:
:
size_t
I
class
T
>
struct
variant_alternative
;
template
<
std
:
:
size_t
I
class
.
.
.
Types
>
struct
variant_alternative
<
I
variant
<
Types
.
.
.
>
>
{
using
type
=
variant_internal
:
:
VariantAlternativeSfinaeT
<
I
variant
<
Types
.
.
.
>
>
;
}
;
template
<
std
:
:
size_t
I
class
T
>
struct
variant_alternative
<
I
const
T
>
{
using
type
=
const
typename
variant_alternative
<
I
T
>
:
:
type
;
}
;
template
<
std
:
:
size_t
I
class
T
>
struct
variant_alternative
<
I
volatile
T
>
{
using
type
=
volatile
typename
variant_alternative
<
I
T
>
:
:
type
;
}
;
template
<
std
:
:
size_t
I
class
T
>
struct
variant_alternative
<
I
const
volatile
T
>
{
using
type
=
const
volatile
typename
variant_alternative
<
I
T
>
:
:
type
;
}
;
template
<
std
:
:
size_t
I
class
T
>
using
variant_alternative_t
=
typename
variant_alternative
<
I
T
>
:
:
type
;
template
<
class
T
class
.
.
.
Types
>
constexpr
bool
holds_alternative
(
const
variant
<
Types
.
.
.
>
&
v
)
noexcept
{
static_assert
(
variant_internal
:
:
UnambiguousIndexOfImpl
<
variant
<
Types
.
.
.
>
T
0
>
:
:
value
!
=
sizeof
.
.
.
(
Types
)
"
The
type
T
must
occur
exactly
once
in
Types
.
.
.
"
)
;
return
v
.
index
(
)
=
=
variant_internal
:
:
UnambiguousIndexOf
<
variant
<
Types
.
.
.
>
T
>
:
:
value
;
}
template
<
class
T
class
.
.
.
Types
>
constexpr
T
&
get
(
variant
<
Types
.
.
.
>
&
v
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
CheckedAccess
<
variant_internal
:
:
IndexOf
<
T
Types
.
.
.
>
:
:
value
>
(
v
)
;
}
template
<
class
T
class
.
.
.
Types
>
constexpr
T
&
&
get
(
variant
<
Types
.
.
.
>
&
&
v
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
CheckedAccess
<
variant_internal
:
:
IndexOf
<
T
Types
.
.
.
>
:
:
value
>
(
std
:
:
move
(
v
)
)
;
}
template
<
class
T
class
.
.
.
Types
>
constexpr
const
T
&
get
(
const
variant
<
Types
.
.
.
>
&
v
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
CheckedAccess
<
variant_internal
:
:
IndexOf
<
T
Types
.
.
.
>
:
:
value
>
(
v
)
;
}
template
<
class
T
class
.
.
.
Types
>
constexpr
const
T
&
&
get
(
const
variant
<
Types
.
.
.
>
&
&
v
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
CheckedAccess
<
variant_internal
:
:
IndexOf
<
T
Types
.
.
.
>
:
:
value
>
(
std
:
:
move
(
v
)
)
;
}
template
<
std
:
:
size_t
I
class
.
.
.
Types
>
constexpr
variant_alternative_t
<
I
variant
<
Types
.
.
.
>
>
&
get
(
variant
<
Types
.
.
.
>
&
v
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
CheckedAccess
<
I
>
(
v
)
;
}
template
<
std
:
:
size_t
I
class
.
.
.
Types
>
constexpr
variant_alternative_t
<
I
variant
<
Types
.
.
.
>
>
&
&
get
(
variant
<
Types
.
.
.
>
&
&
v
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
CheckedAccess
<
I
>
(
std
:
:
move
(
v
)
)
;
}
template
<
std
:
:
size_t
I
class
.
.
.
Types
>
constexpr
const
variant_alternative_t
<
I
variant
<
Types
.
.
.
>
>
&
get
(
const
variant
<
Types
.
.
.
>
&
v
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
CheckedAccess
<
I
>
(
v
)
;
}
template
<
std
:
:
size_t
I
class
.
.
.
Types
>
constexpr
const
variant_alternative_t
<
I
variant
<
Types
.
.
.
>
>
&
&
get
(
const
variant
<
Types
.
.
.
>
&
&
v
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
CheckedAccess
<
I
>
(
std
:
:
move
(
v
)
)
;
}
template
<
std
:
:
size_t
I
class
.
.
.
Types
>
constexpr
absl
:
:
add_pointer_t
<
variant_alternative_t
<
I
variant
<
Types
.
.
.
>
>
>
get_if
(
variant
<
Types
.
.
.
>
*
v
)
noexcept
{
return
(
v
!
=
nullptr
&
&
v
-
>
index
(
)
=
=
I
)
?
std
:
:
addressof
(
variant_internal
:
:
VariantCoreAccess
:
:
Access
<
I
>
(
*
v
)
)
:
nullptr
;
}
template
<
std
:
:
size_t
I
class
.
.
.
Types
>
constexpr
absl
:
:
add_pointer_t
<
const
variant_alternative_t
<
I
variant
<
Types
.
.
.
>
>
>
get_if
(
const
variant
<
Types
.
.
.
>
*
v
)
noexcept
{
return
(
v
!
=
nullptr
&
&
v
-
>
index
(
)
=
=
I
)
?
std
:
:
addressof
(
variant_internal
:
:
VariantCoreAccess
:
:
Access
<
I
>
(
*
v
)
)
:
nullptr
;
}
template
<
class
T
class
.
.
.
Types
>
constexpr
absl
:
:
add_pointer_t
<
T
>
get_if
(
variant
<
Types
.
.
.
>
*
v
)
noexcept
{
return
absl
:
:
get_if
<
variant_internal
:
:
IndexOf
<
T
Types
.
.
.
>
:
:
value
>
(
v
)
;
}
template
<
class
T
class
.
.
.
Types
>
constexpr
absl
:
:
add_pointer_t
<
const
T
>
get_if
(
const
variant
<
Types
.
.
.
>
*
v
)
noexcept
{
return
absl
:
:
get_if
<
variant_internal
:
:
IndexOf
<
T
Types
.
.
.
>
:
:
value
>
(
v
)
;
}
template
<
typename
Visitor
typename
.
.
.
Variants
>
variant_internal
:
:
VisitResult
<
Visitor
Variants
.
.
.
>
visit
(
Visitor
&
&
vis
Variants
&
&
.
.
.
vars
)
{
return
variant_internal
:
:
VisitIndices
<
variant_size
<
absl
:
:
decay_t
<
Variants
>
>
:
:
value
.
.
.
>
:
:
Run
(
variant_internal
:
:
PerformVisitation
<
Visitor
Variants
.
.
.
>
{
std
:
:
forward_as_tuple
(
std
:
:
forward
<
Variants
>
(
vars
)
.
.
.
)
std
:
:
forward
<
Visitor
>
(
vis
)
}
vars
.
index
(
)
.
.
.
)
;
}
struct
monostate
{
}
;
constexpr
bool
operator
<
(
monostate
monostate
)
noexcept
{
return
false
;
}
constexpr
bool
operator
>
(
monostate
monostate
)
noexcept
{
return
false
;
}
constexpr
bool
operator
<
=
(
monostate
monostate
)
noexcept
{
return
true
;
}
constexpr
bool
operator
>
=
(
monostate
monostate
)
noexcept
{
return
true
;
}
constexpr
bool
operator
=
=
(
monostate
monostate
)
noexcept
{
return
true
;
}
constexpr
bool
operator
!
=
(
monostate
monostate
)
noexcept
{
return
false
;
}
template
<
typename
T0
typename
.
.
.
Tn
>
class
variant
<
T0
Tn
.
.
.
>
:
private
variant_internal
:
:
VariantBase
<
T0
Tn
.
.
.
>
{
static_assert
(
absl
:
:
conjunction
<
std
:
:
is_object
<
T0
>
std
:
:
is_object
<
Tn
>
.
.
.
>
:
:
value
"
Attempted
to
instantiate
a
variant
containing
a
non
-
object
"
"
type
.
"
)
;
static_assert
(
absl
:
:
conjunction
<
negation
<
std
:
:
is_array
<
T0
>
>
negation
<
std
:
:
is_array
<
Tn
>
>
.
.
.
>
:
:
value
"
Attempted
to
instantiate
a
variant
containing
an
array
type
.
"
)
;
static_assert
(
absl
:
:
conjunction
<
std
:
:
is_nothrow_destructible
<
T0
>
std
:
:
is_nothrow_destructible
<
Tn
>
.
.
.
>
:
:
value
"
Attempted
to
instantiate
a
variant
containing
a
non
-
nothrow
"
"
destructible
type
.
"
)
;
friend
struct
variant_internal
:
:
VariantCoreAccess
;
private
:
using
Base
=
variant_internal
:
:
VariantBase
<
T0
Tn
.
.
.
>
;
public
:
constexpr
variant
(
)
=
default
;
variant
(
const
variant
&
other
)
=
default
;
variant
(
variant
&
&
other
)
=
default
;
template
<
class
T
std
:
:
size_t
I
=
std
:
:
enable_if
<
variant_internal
:
:
IsNeitherSelfNorInPlace
<
variant
absl
:
:
decay_t
<
T
>
>
:
:
value
variant_internal
:
:
IndexOfConstructedType
<
variant
T
>
>
:
:
type
:
:
value
class
Tj
=
absl
:
:
variant_alternative_t
<
I
variant
>
absl
:
:
enable_if_t
<
std
:
:
is_constructible
<
Tj
T
>
:
:
value
>
*
=
nullptr
>
constexpr
variant
(
T
&
&
t
)
noexcept
(
std
:
:
is_nothrow_constructible
<
Tj
T
>
:
:
value
)
:
Base
(
variant_internal
:
:
EmplaceTag
<
I
>
(
)
std
:
:
forward
<
T
>
(
t
)
)
{
}
template
<
class
T
class
.
.
.
Args
typename
std
:
:
enable_if
<
std
:
:
is_constructible
<
variant_internal
:
:
UnambiguousTypeOfT
<
variant
T
>
Args
.
.
.
>
:
:
value
>
:
:
type
*
=
nullptr
>
constexpr
explicit
variant
(
in_place_type_t
<
T
>
Args
&
&
.
.
.
args
)
:
Base
(
variant_internal
:
:
EmplaceTag
<
variant_internal
:
:
UnambiguousIndexOf
<
variant
T
>
:
:
value
>
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
template
<
class
T
class
U
class
.
.
.
Args
typename
std
:
:
enable_if
<
std
:
:
is_constructible
<
variant_internal
:
:
UnambiguousTypeOfT
<
variant
T
>
std
:
:
initializer_list
<
U
>
&
Args
.
.
.
>
:
:
value
>
:
:
type
*
=
nullptr
>
constexpr
explicit
variant
(
in_place_type_t
<
T
>
std
:
:
initializer_list
<
U
>
il
Args
&
&
.
.
.
args
)
:
Base
(
variant_internal
:
:
EmplaceTag
<
variant_internal
:
:
UnambiguousIndexOf
<
variant
T
>
:
:
value
>
(
)
il
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
template
<
std
:
:
size_t
I
class
.
.
.
Args
typename
std
:
:
enable_if
<
std
:
:
is_constructible
<
variant_internal
:
:
VariantAlternativeSfinaeT
<
I
variant
>
Args
.
.
.
>
:
:
value
>
:
:
type
*
=
nullptr
>
constexpr
explicit
variant
(
in_place_index_t
<
I
>
Args
&
&
.
.
.
args
)
:
Base
(
variant_internal
:
:
EmplaceTag
<
I
>
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
template
<
std
:
:
size_t
I
class
U
class
.
.
.
Args
typename
std
:
:
enable_if
<
std
:
:
is_constructible
<
variant_internal
:
:
VariantAlternativeSfinaeT
<
I
variant
>
std
:
:
initializer_list
<
U
>
&
Args
.
.
.
>
:
:
value
>
:
:
type
*
=
nullptr
>
constexpr
explicit
variant
(
in_place_index_t
<
I
>
std
:
:
initializer_list
<
U
>
il
Args
&
&
.
.
.
args
)
:
Base
(
variant_internal
:
:
EmplaceTag
<
I
>
(
)
il
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
~
variant
(
)
=
default
;
variant
&
operator
=
(
const
variant
&
other
)
=
default
;
variant
&
operator
=
(
variant
&
&
other
)
=
default
;
template
<
class
T
std
:
:
size_t
I
=
std
:
:
enable_if
<
!
std
:
:
is_same
<
absl
:
:
decay_t
<
T
>
variant
>
:
:
value
variant_internal
:
:
IndexOfConstructedType
<
variant
T
>
>
:
:
type
:
:
value
class
Tj
=
absl
:
:
variant_alternative_t
<
I
variant
>
typename
std
:
:
enable_if
<
std
:
:
is_assignable
<
Tj
&
T
>
:
:
value
&
&
std
:
:
is_constructible
<
Tj
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
variant
&
operator
=
(
T
&
&
t
)
noexcept
(
std
:
:
is_nothrow_assignable
<
Tj
&
T
>
:
:
value
&
&
std
:
:
is_nothrow_constructible
<
Tj
T
>
:
:
value
)
{
variant_internal
:
:
VisitIndices
<
sizeof
.
.
.
(
Tn
)
+
1
>
:
:
Run
(
variant_internal
:
:
VariantCoreAccess
:
:
MakeConversionAssignVisitor
(
this
std
:
:
forward
<
T
>
(
t
)
)
index
(
)
)
;
return
*
this
;
}
template
<
class
T
class
.
.
.
Args
typename
std
:
:
enable_if
<
std
:
:
is_constructible
<
absl
:
:
variant_alternative_t
<
variant_internal
:
:
UnambiguousIndexOf
<
variant
T
>
:
:
value
variant
>
Args
.
.
.
>
:
:
value
>
:
:
type
*
=
nullptr
>
T
&
emplace
(
Args
&
&
.
.
.
args
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
Replace
<
variant_internal
:
:
UnambiguousIndexOf
<
variant
T
>
:
:
value
>
(
this
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
class
T
class
U
class
.
.
.
Args
typename
std
:
:
enable_if
<
std
:
:
is_constructible
<
absl
:
:
variant_alternative_t
<
variant_internal
:
:
UnambiguousIndexOf
<
variant
T
>
:
:
value
variant
>
std
:
:
initializer_list
<
U
>
&
Args
.
.
.
>
:
:
value
>
:
:
type
*
=
nullptr
>
T
&
emplace
(
std
:
:
initializer_list
<
U
>
il
Args
&
&
.
.
.
args
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
Replace
<
variant_internal
:
:
UnambiguousIndexOf
<
variant
T
>
:
:
value
>
(
this
il
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
std
:
:
size_t
I
class
.
.
.
Args
typename
std
:
:
enable_if
<
std
:
:
is_constructible
<
absl
:
:
variant_alternative_t
<
I
variant
>
Args
.
.
.
>
:
:
value
>
:
:
type
*
=
nullptr
>
absl
:
:
variant_alternative_t
<
I
variant
>
&
emplace
(
Args
&
&
.
.
.
args
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
Replace
<
I
>
(
this
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
std
:
:
size_t
I
class
U
class
.
.
.
Args
typename
std
:
:
enable_if
<
std
:
:
is_constructible
<
absl
:
:
variant_alternative_t
<
I
variant
>
std
:
:
initializer_list
<
U
>
&
Args
.
.
.
>
:
:
value
>
:
:
type
*
=
nullptr
>
absl
:
:
variant_alternative_t
<
I
variant
>
&
emplace
(
std
:
:
initializer_list
<
U
>
il
Args
&
&
.
.
.
args
)
{
return
variant_internal
:
:
VariantCoreAccess
:
:
Replace
<
I
>
(
this
il
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
constexpr
bool
valueless_by_exception
(
)
const
noexcept
{
return
this
-
>
index_
=
=
absl
:
:
variant_npos
;
}
constexpr
std
:
:
size_t
index
(
)
const
noexcept
{
return
this
-
>
index_
;
}
void
swap
(
variant
&
rhs
)
noexcept
(
absl
:
:
conjunction
<
std
:
:
is_nothrow_move_constructible
<
T0
>
std
:
:
is_nothrow_move_constructible
<
Tn
>
.
.
.
type_traits_internal
:
:
IsNothrowSwappable
<
T0
>
type_traits_internal
:
:
IsNothrowSwappable
<
Tn
>
.
.
.
>
:
:
value
)
{
return
variant_internal
:
:
VisitIndices
<
sizeof
.
.
.
(
Tn
)
+
1
>
:
:
Run
(
variant_internal
:
:
Swap
<
T0
Tn
.
.
.
>
{
this
&
rhs
}
rhs
.
index
(
)
)
;
}
}
;
template
<
>
class
variant
<
>
;
template
<
typename
.
.
.
Types
>
constexpr
variant_internal
:
:
RequireAllHaveEqualT
<
Types
.
.
.
>
operator
=
=
(
const
variant
<
Types
.
.
.
>
&
a
const
variant
<
Types
.
.
.
>
&
b
)
{
return
(
a
.
index
(
)
=
=
b
.
index
(
)
)
&
&
variant_internal
:
:
VisitIndices
<
sizeof
.
.
.
(
Types
)
>
:
:
Run
(
variant_internal
:
:
EqualsOp
<
Types
.
.
.
>
{
&
a
&
b
}
a
.
index
(
)
)
;
}
template
<
typename
.
.
.
Types
>
constexpr
variant_internal
:
:
RequireAllHaveNotEqualT
<
Types
.
.
.
>
operator
!
=
(
const
variant
<
Types
.
.
.
>
&
a
const
variant
<
Types
.
.
.
>
&
b
)
{
return
(
a
.
index
(
)
!
=
b
.
index
(
)
)
|
|
variant_internal
:
:
VisitIndices
<
sizeof
.
.
.
(
Types
)
>
:
:
Run
(
variant_internal
:
:
NotEqualsOp
<
Types
.
.
.
>
{
&
a
&
b
}
a
.
index
(
)
)
;
}
template
<
typename
.
.
.
Types
>
constexpr
variant_internal
:
:
RequireAllHaveLessThanT
<
Types
.
.
.
>
operator
<
(
const
variant
<
Types
.
.
.
>
&
a
const
variant
<
Types
.
.
.
>
&
b
)
{
return
(
a
.
index
(
)
!
=
b
.
index
(
)
)
?
(
a
.
index
(
)
+
1
)
<
(
b
.
index
(
)
+
1
)
:
variant_internal
:
:
VisitIndices
<
sizeof
.
.
.
(
Types
)
>
:
:
Run
(
variant_internal
:
:
LessThanOp
<
Types
.
.
.
>
{
&
a
&
b
}
a
.
index
(
)
)
;
}
template
<
typename
.
.
.
Types
>
constexpr
variant_internal
:
:
RequireAllHaveGreaterThanT
<
Types
.
.
.
>
operator
>
(
const
variant
<
Types
.
.
.
>
&
a
const
variant
<
Types
.
.
.
>
&
b
)
{
return
(
a
.
index
(
)
!
=
b
.
index
(
)
)
?
(
a
.
index
(
)
+
1
)
>
(
b
.
index
(
)
+
1
)
:
variant_internal
:
:
VisitIndices
<
sizeof
.
.
.
(
Types
)
>
:
:
Run
(
variant_internal
:
:
GreaterThanOp
<
Types
.
.
.
>
{
&
a
&
b
}
a
.
index
(
)
)
;
}
template
<
typename
.
.
.
Types
>
constexpr
variant_internal
:
:
RequireAllHaveLessThanOrEqualT
<
Types
.
.
.
>
operator
<
=
(
const
variant
<
Types
.
.
.
>
&
a
const
variant
<
Types
.
.
.
>
&
b
)
{
return
(
a
.
index
(
)
!
=
b
.
index
(
)
)
?
(
a
.
index
(
)
+
1
)
<
(
b
.
index
(
)
+
1
)
:
variant_internal
:
:
VisitIndices
<
sizeof
.
.
.
(
Types
)
>
:
:
Run
(
variant_internal
:
:
LessThanOrEqualsOp
<
Types
.
.
.
>
{
&
a
&
b
}
a
.
index
(
)
)
;
}
template
<
typename
.
.
.
Types
>
constexpr
variant_internal
:
:
RequireAllHaveGreaterThanOrEqualT
<
Types
.
.
.
>
operator
>
=
(
const
variant
<
Types
.
.
.
>
&
a
const
variant
<
Types
.
.
.
>
&
b
)
{
return
(
a
.
index
(
)
!
=
b
.
index
(
)
)
?
(
a
.
index
(
)
+
1
)
>
(
b
.
index
(
)
+
1
)
:
variant_internal
:
:
VisitIndices
<
sizeof
.
.
.
(
Types
)
>
:
:
Run
(
variant_internal
:
:
GreaterThanOrEqualsOp
<
Types
.
.
.
>
{
&
a
&
b
}
a
.
index
(
)
)
;
}
ABSL_NAMESPACE_END
}
namespace
std
{
template
<
>
struct
hash
<
absl
:
:
monostate
>
{
std
:
:
size_t
operator
(
)
(
absl
:
:
monostate
)
const
{
return
0
;
}
}
;
template
<
class
.
.
.
T
>
struct
hash
<
absl
:
:
variant
<
T
.
.
.
>
>
:
absl
:
:
variant_internal
:
:
VariantHashBase
<
absl
:
:
variant
<
T
.
.
.
>
void
absl
:
:
remove_const_t
<
T
>
.
.
.
>
{
}
;
}
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
variant_internal
{
template
<
typename
To
>
struct
ConversionVisitor
{
template
<
typename
T
>
To
operator
(
)
(
T
&
&
v
)
const
{
return
To
(
std
:
:
forward
<
T
>
(
v
)
)
;
}
}
;
}
template
<
typename
To
typename
Variant
>
To
ConvertVariantTo
(
Variant
&
&
variant
)
{
return
absl
:
:
visit
(
variant_internal
:
:
ConversionVisitor
<
To
>
{
}
std
:
:
forward
<
Variant
>
(
variant
)
)
;
}
ABSL_NAMESPACE_END
}
#
endif
