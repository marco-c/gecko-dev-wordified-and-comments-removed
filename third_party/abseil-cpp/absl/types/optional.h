#
ifndef
ABSL_TYPES_OPTIONAL_H_
#
define
ABSL_TYPES_OPTIONAL_H_
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
#
ifdef
ABSL_USES_STD_OPTIONAL
#
include
<
optional
>
namespace
absl
{
ABSL_NAMESPACE_BEGIN
using
std
:
:
bad_optional_access
;
using
std
:
:
optional
;
using
std
:
:
make_optional
;
using
std
:
:
nullopt_t
;
using
std
:
:
nullopt
;
ABSL_NAMESPACE_END
}
#
else
#
include
<
cassert
>
#
include
<
functional
>
#
include
<
initializer_list
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
nullability
.
h
"
#
include
"
absl
/
base
/
internal
/
inline_variable
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
types
/
bad_optional_access
.
h
"
#
include
"
absl
/
types
/
internal
/
optional
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
struct
nullopt_t
{
explicit
constexpr
nullopt_t
(
optional_internal
:
:
init_t
)
noexcept
{
}
}
;
ABSL_INTERNAL_INLINE_CONSTEXPR
(
nullopt_t
nullopt
nullopt_t
(
optional_internal
:
:
init_t
(
)
)
)
;
template
<
typename
T
>
class
optional
:
private
optional_internal
:
:
optional_data
<
T
>
private
optional_internal
:
:
optional_ctor_base
<
optional_internal
:
:
ctor_copy_traits
<
T
>
:
:
traits
>
private
optional_internal
:
:
optional_assign_base
<
optional_internal
:
:
assign_copy_traits
<
T
>
:
:
traits
>
{
using
data_base
=
optional_internal
:
:
optional_data
<
T
>
;
public
:
typedef
T
value_type
;
constexpr
optional
(
)
noexcept
=
default
;
constexpr
optional
(
nullopt_t
)
noexcept
{
}
optional
(
const
optional
&
)
=
default
;
optional
(
optional
&
&
)
=
default
;
template
<
typename
InPlaceT
typename
.
.
.
Args
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
std
:
:
is_same
<
InPlaceT
in_place_t
>
std
:
:
is_constructible
<
T
Args
&
&
.
.
.
>
>
:
:
value
>
*
=
nullptr
>
constexpr
explicit
optional
(
InPlaceT
Args
&
&
.
.
.
args
)
:
data_base
(
in_place_t
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
template
<
typename
U
typename
.
.
.
Args
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_constructible
<
T
std
:
:
initializer_list
<
U
>
&
Args
&
&
.
.
.
>
:
:
value
>
:
:
type
>
constexpr
explicit
optional
(
in_place_t
std
:
:
initializer_list
<
U
>
il
Args
&
&
.
.
.
args
)
:
data_base
(
in_place_t
(
)
il
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
template
<
typename
U
=
T
typename
std
:
:
enable_if
<
absl
:
:
conjunction
<
absl
:
:
negation
<
std
:
:
is_same
<
in_place_t
typename
std
:
:
decay
<
U
>
:
:
type
>
>
absl
:
:
negation
<
std
:
:
is_same
<
optional
<
T
>
typename
std
:
:
decay
<
U
>
:
:
type
>
>
std
:
:
is_convertible
<
U
&
&
T
>
std
:
:
is_constructible
<
T
U
&
&
>
>
:
:
value
bool
>
:
:
type
=
false
>
constexpr
optional
(
U
&
&
v
)
:
data_base
(
in_place_t
(
)
std
:
:
forward
<
U
>
(
v
)
)
{
}
template
<
typename
U
=
T
typename
std
:
:
enable_if
<
absl
:
:
conjunction
<
absl
:
:
negation
<
std
:
:
is_same
<
in_place_t
typename
std
:
:
decay
<
U
>
:
:
type
>
>
absl
:
:
negation
<
std
:
:
is_same
<
optional
<
T
>
typename
std
:
:
decay
<
U
>
:
:
type
>
>
absl
:
:
negation
<
std
:
:
is_convertible
<
U
&
&
T
>
>
std
:
:
is_constructible
<
T
U
&
&
>
>
:
:
value
bool
>
:
:
type
=
false
>
explicit
constexpr
optional
(
U
&
&
v
)
:
data_base
(
in_place_t
(
)
std
:
:
forward
<
U
>
(
v
)
)
{
}
template
<
typename
U
typename
std
:
:
enable_if
<
absl
:
:
conjunction
<
absl
:
:
negation
<
std
:
:
is_same
<
T
U
>
>
std
:
:
is_constructible
<
T
const
U
&
>
absl
:
:
negation
<
optional_internal
:
:
is_constructible_convertible_from_optional
<
T
U
>
>
std
:
:
is_convertible
<
const
U
&
T
>
>
:
:
value
bool
>
:
:
type
=
false
>
optional
(
const
optional
<
U
>
&
rhs
)
{
if
(
rhs
)
{
this
-
>
construct
(
*
rhs
)
;
}
}
template
<
typename
U
typename
std
:
:
enable_if
<
absl
:
:
conjunction
<
absl
:
:
negation
<
std
:
:
is_same
<
T
U
>
>
std
:
:
is_constructible
<
T
const
U
&
>
absl
:
:
negation
<
optional_internal
:
:
is_constructible_convertible_from_optional
<
T
U
>
>
absl
:
:
negation
<
std
:
:
is_convertible
<
const
U
&
T
>
>
>
:
:
value
bool
>
:
:
type
=
false
>
explicit
optional
(
const
optional
<
U
>
&
rhs
)
{
if
(
rhs
)
{
this
-
>
construct
(
*
rhs
)
;
}
}
template
<
typename
U
typename
std
:
:
enable_if
<
absl
:
:
conjunction
<
absl
:
:
negation
<
std
:
:
is_same
<
T
U
>
>
std
:
:
is_constructible
<
T
U
&
&
>
absl
:
:
negation
<
optional_internal
:
:
is_constructible_convertible_from_optional
<
T
U
>
>
std
:
:
is_convertible
<
U
&
&
T
>
>
:
:
value
bool
>
:
:
type
=
false
>
optional
(
optional
<
U
>
&
&
rhs
)
{
if
(
rhs
)
{
this
-
>
construct
(
std
:
:
move
(
*
rhs
)
)
;
}
}
template
<
typename
U
typename
std
:
:
enable_if
<
absl
:
:
conjunction
<
absl
:
:
negation
<
std
:
:
is_same
<
T
U
>
>
std
:
:
is_constructible
<
T
U
&
&
>
absl
:
:
negation
<
optional_internal
:
:
is_constructible_convertible_from_optional
<
T
U
>
>
absl
:
:
negation
<
std
:
:
is_convertible
<
U
&
&
T
>
>
>
:
:
value
bool
>
:
:
type
=
false
>
explicit
optional
(
optional
<
U
>
&
&
rhs
)
{
if
(
rhs
)
{
this
-
>
construct
(
std
:
:
move
(
*
rhs
)
)
;
}
}
~
optional
(
)
=
default
;
optional
&
operator
=
(
nullopt_t
)
noexcept
{
this
-
>
destruct
(
)
;
return
*
this
;
}
optional
&
operator
=
(
const
optional
&
src
)
=
default
;
optional
&
operator
=
(
optional
&
&
src
)
=
default
;
template
<
typename
U
=
T
int
&
.
.
.
typename
=
typename
std
:
:
enable_if
<
absl
:
:
conjunction
<
absl
:
:
negation
<
std
:
:
is_same
<
optional
<
T
>
typename
std
:
:
decay
<
U
>
:
:
type
>
>
absl
:
:
negation
<
absl
:
:
conjunction
<
std
:
:
is_scalar
<
T
>
std
:
:
is_same
<
T
typename
std
:
:
decay
<
U
>
:
:
type
>
>
>
std
:
:
is_constructible
<
T
U
>
std
:
:
is_assignable
<
T
&
U
>
>
:
:
value
>
:
:
type
>
optional
&
operator
=
(
U
&
&
v
)
{
this
-
>
assign
(
std
:
:
forward
<
U
>
(
v
)
)
;
return
*
this
;
}
template
<
typename
U
int
&
.
.
.
typename
=
typename
std
:
:
enable_if
<
absl
:
:
conjunction
<
absl
:
:
negation
<
std
:
:
is_same
<
T
U
>
>
std
:
:
is_constructible
<
T
const
U
&
>
std
:
:
is_assignable
<
T
&
const
U
&
>
absl
:
:
negation
<
optional_internal
:
:
is_constructible_convertible_assignable_from_optional
<
T
U
>
>
>
:
:
value
>
:
:
type
>
optional
&
operator
=
(
const
optional
<
U
>
&
rhs
)
{
if
(
rhs
)
{
this
-
>
assign
(
*
rhs
)
;
}
else
{
this
-
>
destruct
(
)
;
}
return
*
this
;
}
template
<
typename
U
int
&
.
.
.
typename
=
typename
std
:
:
enable_if
<
absl
:
:
conjunction
<
absl
:
:
negation
<
std
:
:
is_same
<
T
U
>
>
std
:
:
is_constructible
<
T
U
>
std
:
:
is_assignable
<
T
&
U
>
absl
:
:
negation
<
optional_internal
:
:
is_constructible_convertible_assignable_from_optional
<
T
U
>
>
>
:
:
value
>
:
:
type
>
optional
&
operator
=
(
optional
<
U
>
&
&
rhs
)
{
if
(
rhs
)
{
this
-
>
assign
(
std
:
:
move
(
*
rhs
)
)
;
}
else
{
this
-
>
destruct
(
)
;
}
return
*
this
;
}
ABSL_ATTRIBUTE_REINITIALIZES
void
reset
(
)
noexcept
{
this
-
>
destruct
(
)
;
}
template
<
typename
.
.
.
Args
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_constructible
<
T
Args
&
&
.
.
.
>
:
:
value
>
:
:
type
>
T
&
emplace
(
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
this
-
>
destruct
(
)
;
this
-
>
construct
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
return
reference
(
)
;
}
template
<
typename
U
typename
.
.
.
Args
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_constructible
<
T
std
:
:
initializer_list
<
U
>
&
Args
&
&
.
.
.
>
:
:
value
>
:
:
type
>
T
&
emplace
(
std
:
:
initializer_list
<
U
>
il
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
this
-
>
destruct
(
)
;
this
-
>
construct
(
il
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
return
reference
(
)
;
}
void
swap
(
optional
&
rhs
)
noexcept
(
std
:
:
is_nothrow_move_constructible
<
T
>
:
:
value
&
&
type_traits_internal
:
:
IsNothrowSwappable
<
T
>
:
:
value
)
{
if
(
*
this
)
{
if
(
rhs
)
{
type_traits_internal
:
:
Swap
(
*
*
this
*
rhs
)
;
}
else
{
rhs
.
construct
(
std
:
:
move
(
*
*
this
)
)
;
this
-
>
destruct
(
)
;
}
}
else
{
if
(
rhs
)
{
this
-
>
construct
(
std
:
:
move
(
*
rhs
)
)
;
rhs
.
destruct
(
)
;
}
else
{
}
}
}
absl
:
:
Nonnull
<
const
T
*
>
operator
-
>
(
)
const
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
ABSL_HARDENING_ASSERT
(
this
-
>
engaged_
)
;
return
std
:
:
addressof
(
this
-
>
data_
)
;
}
absl
:
:
Nonnull
<
T
*
>
operator
-
>
(
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
ABSL_HARDENING_ASSERT
(
this
-
>
engaged_
)
;
return
std
:
:
addressof
(
this
-
>
data_
)
;
}
constexpr
const
T
&
operator
*
(
)
const
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
ABSL_HARDENING_ASSERT
(
this
-
>
engaged_
)
;
return
reference
(
)
;
}
T
&
operator
*
(
)
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
ABSL_HARDENING_ASSERT
(
this
-
>
engaged_
)
;
return
reference
(
)
;
}
constexpr
const
T
&
&
operator
*
(
)
const
&
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
ABSL_HARDENING_ASSERT
(
this
-
>
engaged_
)
;
return
std
:
:
move
(
reference
(
)
)
;
}
T
&
&
operator
*
(
)
&
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
ABSL_HARDENING_ASSERT
(
this
-
>
engaged_
)
;
return
std
:
:
move
(
reference
(
)
)
;
}
constexpr
explicit
operator
bool
(
)
const
noexcept
{
return
this
-
>
engaged_
;
}
constexpr
bool
has_value
(
)
const
noexcept
{
return
this
-
>
engaged_
;
}
#
ifdef
_MSC_VER
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4702
)
#
endif
constexpr
const
T
&
value
(
)
const
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
static_cast
<
bool
>
(
*
this
)
?
reference
(
)
:
(
optional_internal
:
:
throw_bad_optional_access
(
)
reference
(
)
)
;
}
T
&
value
(
)
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
static_cast
<
bool
>
(
*
this
)
?
reference
(
)
:
(
optional_internal
:
:
throw_bad_optional_access
(
)
reference
(
)
)
;
}
T
&
&
value
(
)
&
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
std
:
:
move
(
static_cast
<
bool
>
(
*
this
)
?
reference
(
)
:
(
optional_internal
:
:
throw_bad_optional_access
(
)
reference
(
)
)
)
;
}
constexpr
const
T
&
&
value
(
)
const
&
&
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
std
:
:
move
(
static_cast
<
bool
>
(
*
this
)
?
reference
(
)
:
(
optional_internal
:
:
throw_bad_optional_access
(
)
reference
(
)
)
)
;
}
#
ifdef
_MSC_VER
#
pragma
warning
(
pop
)
#
endif
template
<
typename
U
>
constexpr
T
value_or
(
U
&
&
v
)
const
&
{
static_assert
(
std
:
:
is_copy_constructible
<
value_type
>
:
:
value
"
optional
<
T
>
:
:
value_or
:
T
must
be
copy
constructible
"
)
;
static_assert
(
std
:
:
is_convertible
<
U
&
&
value_type
>
:
:
value
"
optional
<
T
>
:
:
value_or
:
U
must
be
convertible
to
T
"
)
;
return
static_cast
<
bool
>
(
*
this
)
?
*
*
this
:
static_cast
<
T
>
(
std
:
:
forward
<
U
>
(
v
)
)
;
}
template
<
typename
U
>
T
value_or
(
U
&
&
v
)
&
&
{
static_assert
(
std
:
:
is_move_constructible
<
value_type
>
:
:
value
"
optional
<
T
>
:
:
value_or
:
T
must
be
move
constructible
"
)
;
static_assert
(
std
:
:
is_convertible
<
U
&
&
value_type
>
:
:
value
"
optional
<
T
>
:
:
value_or
:
U
must
be
convertible
to
T
"
)
;
return
static_cast
<
bool
>
(
*
this
)
?
std
:
:
move
(
*
*
this
)
:
static_cast
<
T
>
(
std
:
:
forward
<
U
>
(
v
)
)
;
}
private
:
constexpr
const
T
&
reference
(
)
const
{
return
this
-
>
data_
;
}
T
&
reference
(
)
{
return
this
-
>
data_
;
}
static_assert
(
!
std
:
:
is_same
<
nullopt_t
typename
std
:
:
remove_cv
<
T
>
:
:
type
>
:
:
value
"
optional
<
nullopt_t
>
is
not
allowed
.
"
)
;
static_assert
(
!
std
:
:
is_same
<
in_place_t
typename
std
:
:
remove_cv
<
T
>
:
:
type
>
:
:
value
"
optional
<
in_place_t
>
is
not
allowed
.
"
)
;
static_assert
(
!
std
:
:
is_reference
<
T
>
:
:
value
"
optional
<
reference
>
is
not
allowed
.
"
)
;
}
;
template
<
typename
T
typename
std
:
:
enable_if
<
std
:
:
is_move_constructible
<
T
>
:
:
value
&
&
type_traits_internal
:
:
IsSwappable
<
T
>
:
:
value
bool
>
:
:
type
=
false
>
void
swap
(
optional
<
T
>
&
a
optional
<
T
>
&
b
)
noexcept
(
noexcept
(
a
.
swap
(
b
)
)
)
{
a
.
swap
(
b
)
;
}
template
<
typename
T
>
constexpr
optional
<
typename
std
:
:
decay
<
T
>
:
:
type
>
make_optional
(
T
&
&
v
)
{
return
optional
<
typename
std
:
:
decay
<
T
>
:
:
type
>
(
std
:
:
forward
<
T
>
(
v
)
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
constexpr
optional
<
T
>
make_optional
(
Args
&
&
.
.
.
args
)
{
return
optional
<
T
>
(
in_place_t
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
U
typename
.
.
.
Args
>
constexpr
optional
<
T
>
make_optional
(
std
:
:
initializer_list
<
U
>
il
Args
&
&
.
.
.
args
)
{
return
optional
<
T
>
(
in_place_t
(
)
il
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
=
=
(
const
optional
<
T
>
&
x
const
optional
<
U
>
&
y
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
=
=
*
y
)
)
{
return
static_cast
<
bool
>
(
x
)
!
=
static_cast
<
bool
>
(
y
)
?
false
:
static_cast
<
bool
>
(
x
)
=
=
false
?
true
:
static_cast
<
bool
>
(
*
x
=
=
*
y
)
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
!
=
(
const
optional
<
T
>
&
x
const
optional
<
U
>
&
y
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
!
=
*
y
)
)
{
return
static_cast
<
bool
>
(
x
)
!
=
static_cast
<
bool
>
(
y
)
?
true
:
static_cast
<
bool
>
(
x
)
=
=
false
?
false
:
static_cast
<
bool
>
(
*
x
!
=
*
y
)
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
<
(
const
optional
<
T
>
&
x
const
optional
<
U
>
&
y
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
<
*
y
)
)
{
return
!
y
?
false
:
!
x
?
true
:
static_cast
<
bool
>
(
*
x
<
*
y
)
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
>
(
const
optional
<
T
>
&
x
const
optional
<
U
>
&
y
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
>
*
y
)
)
{
return
!
x
?
false
:
!
y
?
true
:
static_cast
<
bool
>
(
*
x
>
*
y
)
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
<
=
(
const
optional
<
T
>
&
x
const
optional
<
U
>
&
y
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
<
=
*
y
)
)
{
return
!
x
?
true
:
!
y
?
false
:
static_cast
<
bool
>
(
*
x
<
=
*
y
)
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
>
=
(
const
optional
<
T
>
&
x
const
optional
<
U
>
&
y
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
>
=
*
y
)
)
{
return
!
y
?
true
:
!
x
?
false
:
static_cast
<
bool
>
(
*
x
>
=
*
y
)
;
}
template
<
typename
T
>
constexpr
bool
operator
=
=
(
const
optional
<
T
>
&
x
nullopt_t
)
noexcept
{
return
!
x
;
}
template
<
typename
T
>
constexpr
bool
operator
=
=
(
nullopt_t
const
optional
<
T
>
&
x
)
noexcept
{
return
!
x
;
}
template
<
typename
T
>
constexpr
bool
operator
!
=
(
const
optional
<
T
>
&
x
nullopt_t
)
noexcept
{
return
static_cast
<
bool
>
(
x
)
;
}
template
<
typename
T
>
constexpr
bool
operator
!
=
(
nullopt_t
const
optional
<
T
>
&
x
)
noexcept
{
return
static_cast
<
bool
>
(
x
)
;
}
template
<
typename
T
>
constexpr
bool
operator
<
(
const
optional
<
T
>
&
nullopt_t
)
noexcept
{
return
false
;
}
template
<
typename
T
>
constexpr
bool
operator
<
(
nullopt_t
const
optional
<
T
>
&
x
)
noexcept
{
return
static_cast
<
bool
>
(
x
)
;
}
template
<
typename
T
>
constexpr
bool
operator
<
=
(
const
optional
<
T
>
&
x
nullopt_t
)
noexcept
{
return
!
x
;
}
template
<
typename
T
>
constexpr
bool
operator
<
=
(
nullopt_t
const
optional
<
T
>
&
)
noexcept
{
return
true
;
}
template
<
typename
T
>
constexpr
bool
operator
>
(
const
optional
<
T
>
&
x
nullopt_t
)
noexcept
{
return
static_cast
<
bool
>
(
x
)
;
}
template
<
typename
T
>
constexpr
bool
operator
>
(
nullopt_t
const
optional
<
T
>
&
)
noexcept
{
return
false
;
}
template
<
typename
T
>
constexpr
bool
operator
>
=
(
const
optional
<
T
>
&
nullopt_t
)
noexcept
{
return
true
;
}
template
<
typename
T
>
constexpr
bool
operator
>
=
(
nullopt_t
const
optional
<
T
>
&
x
)
noexcept
{
return
!
x
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
=
=
(
const
optional
<
T
>
&
x
const
U
&
v
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
=
=
v
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
*
x
=
=
v
)
:
false
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
=
=
(
const
U
&
v
const
optional
<
T
>
&
x
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
v
=
=
*
x
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
v
=
=
*
x
)
:
false
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
!
=
(
const
optional
<
T
>
&
x
const
U
&
v
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
!
=
v
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
*
x
!
=
v
)
:
true
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
!
=
(
const
U
&
v
const
optional
<
T
>
&
x
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
v
!
=
*
x
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
v
!
=
*
x
)
:
true
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
<
(
const
optional
<
T
>
&
x
const
U
&
v
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
<
v
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
*
x
<
v
)
:
true
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
<
(
const
U
&
v
const
optional
<
T
>
&
x
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
v
<
*
x
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
v
<
*
x
)
:
false
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
<
=
(
const
optional
<
T
>
&
x
const
U
&
v
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
<
=
v
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
*
x
<
=
v
)
:
true
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
<
=
(
const
U
&
v
const
optional
<
T
>
&
x
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
v
<
=
*
x
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
v
<
=
*
x
)
:
false
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
>
(
const
optional
<
T
>
&
x
const
U
&
v
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
>
v
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
*
x
>
v
)
:
false
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
>
(
const
U
&
v
const
optional
<
T
>
&
x
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
v
>
*
x
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
v
>
*
x
)
:
true
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
>
=
(
const
optional
<
T
>
&
x
const
U
&
v
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
*
x
>
=
v
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
*
x
>
=
v
)
:
false
;
}
template
<
typename
T
typename
U
>
constexpr
auto
operator
>
=
(
const
U
&
v
const
optional
<
T
>
&
x
)
-
>
decltype
(
optional_internal
:
:
convertible_to_bool
(
v
>
=
*
x
)
)
{
return
static_cast
<
bool
>
(
x
)
?
static_cast
<
bool
>
(
v
>
=
*
x
)
:
true
;
}
ABSL_NAMESPACE_END
}
namespace
std
{
template
<
typename
T
>
struct
hash
<
absl
:
:
optional
<
T
>
>
:
absl
:
:
optional_internal
:
:
optional_hash_base
<
T
>
{
}
;
}
#
undef
ABSL_MSVC_CONSTEXPR_BUG_IN_UNION_LIKE_CLASS
#
endif
#
endif
