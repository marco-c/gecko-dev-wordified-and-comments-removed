#
include
"
absl
/
base
/
internal
/
thread_identity
.
h
"
#
include
<
thread
>
#
include
<
vector
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
internal
/
spinlock
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
base
/
thread_annotations
.
h
"
#
include
"
absl
/
synchronization
/
internal
/
per_thread_sem
.
h
"
#
include
"
absl
/
synchronization
/
mutex
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
base_internal
{
namespace
{
ABSL_CONST_INIT
static
absl
:
:
base_internal
:
:
SpinLock
map_lock
(
absl
:
:
kConstInit
base_internal
:
:
SCHEDULE_KERNEL_ONLY
)
;
ABSL_CONST_INIT
static
int
num_identities_reused
ABSL_GUARDED_BY
(
map_lock
)
;
static
const
void
*
const
kCheckNoIdentity
=
reinterpret_cast
<
void
*
>
(
1
)
;
static
void
TestThreadIdentityCurrent
(
const
void
*
assert_no_identity
)
{
ThreadIdentity
*
identity
;
if
(
assert_no_identity
=
=
kCheckNoIdentity
)
{
identity
=
CurrentThreadIdentityIfPresent
(
)
;
EXPECT_TRUE
(
identity
=
=
nullptr
)
;
}
identity
=
synchronization_internal
:
:
GetOrCreateCurrentThreadIdentity
(
)
;
EXPECT_TRUE
(
identity
!
=
nullptr
)
;
ThreadIdentity
*
identity_no_init
;
identity_no_init
=
CurrentThreadIdentityIfPresent
(
)
;
EXPECT_TRUE
(
identity
=
=
identity_no_init
)
;
EXPECT_EQ
(
0
reinterpret_cast
<
intptr_t
>
(
&
identity
-
>
per_thread_synch
)
%
PerThreadSynch
:
:
kAlignment
)
;
EXPECT_EQ
(
identity
identity
-
>
per_thread_synch
.
thread_identity
(
)
)
;
absl
:
:
base_internal
:
:
SpinLockHolder
l
(
&
map_lock
)
;
num_identities_reused
+
+
;
}
TEST
(
ThreadIdentityTest
BasicIdentityWorks
)
{
TestThreadIdentityCurrent
(
nullptr
)
;
}
TEST
(
ThreadIdentityTest
BasicIdentityWorksThreaded
)
{
static
const
int
kNumLoops
=
3
;
static
const
int
kNumThreads
=
32
;
for
(
int
iter
=
0
;
iter
<
kNumLoops
;
iter
+
+
)
{
std
:
:
vector
<
std
:
:
thread
>
threads
;
for
(
int
i
=
0
;
i
<
kNumThreads
;
+
+
i
)
{
threads
.
push_back
(
std
:
:
thread
(
TestThreadIdentityCurrent
kCheckNoIdentity
)
)
;
}
for
(
auto
&
thread
:
threads
)
{
thread
.
join
(
)
;
}
}
absl
:
:
base_internal
:
:
SpinLockHolder
l
(
&
map_lock
)
;
EXPECT_LT
(
kNumThreads
num_identities_reused
)
;
}
TEST
(
ThreadIdentityTest
ReusedThreadIdentityMutexTest
)
{
static
const
int
kNumLoops
=
10
;
static
const
int
kNumThreads
=
12
;
static
const
int
kNumMutexes
=
3
;
static
const
int
kNumLockLoops
=
5
;
Mutex
mutexes
[
kNumMutexes
]
;
for
(
int
iter
=
0
;
iter
<
kNumLoops
;
+
+
iter
)
{
std
:
:
vector
<
std
:
:
thread
>
threads
;
for
(
int
thread
=
0
;
thread
<
kNumThreads
;
+
+
thread
)
{
threads
.
push_back
(
std
:
:
thread
(
[
&
]
(
)
{
for
(
int
l
=
0
;
l
<
kNumLockLoops
;
+
+
l
)
{
for
(
int
m
=
0
;
m
<
kNumMutexes
;
+
+
m
)
{
MutexLock
lock
(
&
mutexes
[
m
]
)
;
}
}
}
)
)
;
}
for
(
auto
&
thread
:
threads
)
{
thread
.
join
(
)
;
}
}
}
}
}
ABSL_NAMESPACE_END
}
