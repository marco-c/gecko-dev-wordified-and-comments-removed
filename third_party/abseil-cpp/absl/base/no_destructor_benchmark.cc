#
include
<
cstdint
>
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
base
/
no_destructor
.
h
"
#
include
"
benchmark
/
benchmark
.
h
"
namespace
{
constexpr
int
kNumObjects
=
1
;
constexpr
int
kObjSize
=
sizeof
(
void
*
)
*
1
;
class
BM_Blob
{
public
:
BM_Blob
(
int
val
)
{
for
(
auto
&
d
:
data_
)
d
=
val
;
}
BM_Blob
(
)
:
BM_Blob
(
-
1
)
{
}
void
Verify
(
int
val
)
const
{
for
(
auto
&
d
:
data_
)
ABSL_INTERNAL_CHECK
(
d
=
=
val
"
"
)
;
}
private
:
int
data_
[
kObjSize
/
sizeof
(
int
)
>
0
?
kObjSize
/
sizeof
(
int
)
:
1
]
;
}
;
template
<
int
i
>
const
BM_Blob
&
NoDestrBlobFunc
(
)
{
static
absl
:
:
NoDestructor
<
BM_Blob
>
x
(
i
)
;
return
*
x
;
}
template
<
int
i
>
const
BM_Blob
&
OnHeapBlobFunc
(
)
{
static
BM_Blob
*
x
=
new
BM_Blob
(
i
)
;
return
*
x
;
}
typedef
const
BM_Blob
&
(
*
FuncType
)
(
)
;
static
BM_Blob
direct_blob
(
0
)
;
void
BM_Direct
(
benchmark
:
:
State
&
state
)
{
for
(
auto
s
:
state
)
{
direct_blob
.
Verify
(
0
)
;
}
}
BENCHMARK
(
BM_Direct
)
;
void
BM_NoDestr
(
benchmark
:
:
State
&
state
)
{
for
(
auto
s
:
state
)
{
NoDestrBlobFunc
<
0
>
(
)
.
Verify
(
0
)
;
}
}
BENCHMARK
(
BM_NoDestr
)
;
void
BM_OnHeap
(
benchmark
:
:
State
&
state
)
{
for
(
auto
s
:
state
)
{
OnHeapBlobFunc
<
0
>
(
)
.
Verify
(
0
)
;
}
}
BENCHMARK
(
BM_OnHeap
)
;
enum
BM_Type
{
kNoDestr
kOnHeap
kDirect
}
;
template
<
int
n
>
FuncType
BlobFunc
(
BM_Type
t
int
i
)
{
if
(
i
=
=
n
)
{
switch
(
t
)
{
case
kNoDestr
:
return
&
NoDestrBlobFunc
<
n
>
;
case
kOnHeap
:
return
&
OnHeapBlobFunc
<
n
>
;
case
kDirect
:
return
nullptr
;
}
}
return
BlobFunc
<
n
-
1
>
(
t
i
)
;
}
template
<
>
FuncType
BlobFunc
<
0
>
(
BM_Type
t
int
i
)
{
ABSL_INTERNAL_CHECK
(
i
=
=
0
"
"
)
;
switch
(
t
)
{
case
kNoDestr
:
return
&
NoDestrBlobFunc
<
0
>
;
case
kOnHeap
:
return
&
OnHeapBlobFunc
<
0
>
;
case
kDirect
:
return
nullptr
;
}
return
nullptr
;
}
static
BM_Blob
direct_blobs
[
kNumObjects
]
;
int
RandIdx
(
int
i
)
{
return
(
static_cast
<
int64_t
>
(
i
)
*
13
)
%
kNumObjects
;
}
template
<
BM_Type
t
>
void
BM_Many
(
benchmark
:
:
State
&
state
)
{
FuncType
funcs
[
kNumObjects
]
;
for
(
int
i
=
0
;
i
<
kNumObjects
;
+
+
i
)
{
funcs
[
i
]
=
BlobFunc
<
kNumObjects
-
1
>
(
t
i
)
;
}
if
(
t
=
=
kDirect
)
{
for
(
auto
s
:
state
)
{
int
idx
=
RandIdx
(
state
.
iterations
(
)
)
;
direct_blobs
[
idx
]
.
Verify
(
-
1
)
;
}
}
else
{
for
(
auto
s
:
state
)
{
int
idx
=
RandIdx
(
state
.
iterations
(
)
)
;
funcs
[
idx
]
(
)
.
Verify
(
idx
)
;
}
}
}
void
BM_DirectMany
(
benchmark
:
:
State
&
state
)
{
BM_Many
<
kDirect
>
(
state
)
;
}
void
BM_NoDestrMany
(
benchmark
:
:
State
&
state
)
{
BM_Many
<
kNoDestr
>
(
state
)
;
}
void
BM_OnHeapMany
(
benchmark
:
:
State
&
state
)
{
BM_Many
<
kOnHeap
>
(
state
)
;
}
BENCHMARK
(
BM_DirectMany
)
;
BENCHMARK
(
BM_NoDestrMany
)
;
BENCHMARK
(
BM_OnHeapMany
)
;
}
