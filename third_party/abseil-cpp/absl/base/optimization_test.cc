#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
namespace
{
TEST
(
PredictTest
PredictTrue
)
{
EXPECT_TRUE
(
ABSL_PREDICT_TRUE
(
true
)
)
;
EXPECT_FALSE
(
ABSL_PREDICT_TRUE
(
false
)
)
;
EXPECT_TRUE
(
ABSL_PREDICT_TRUE
(
1
=
=
1
)
)
;
EXPECT_FALSE
(
ABSL_PREDICT_TRUE
(
1
=
=
2
)
)
;
if
(
ABSL_PREDICT_TRUE
(
false
)
)
ADD_FAILURE
(
)
;
if
(
!
ABSL_PREDICT_TRUE
(
true
)
)
ADD_FAILURE
(
)
;
EXPECT_TRUE
(
ABSL_PREDICT_TRUE
(
true
)
&
&
true
)
;
EXPECT_TRUE
(
ABSL_PREDICT_TRUE
(
true
)
|
|
false
)
;
}
TEST
(
PredictTest
PredictFalse
)
{
EXPECT_TRUE
(
ABSL_PREDICT_FALSE
(
true
)
)
;
EXPECT_FALSE
(
ABSL_PREDICT_FALSE
(
false
)
)
;
EXPECT_TRUE
(
ABSL_PREDICT_FALSE
(
1
=
=
1
)
)
;
EXPECT_FALSE
(
ABSL_PREDICT_FALSE
(
1
=
=
2
)
)
;
if
(
ABSL_PREDICT_FALSE
(
false
)
)
ADD_FAILURE
(
)
;
if
(
!
ABSL_PREDICT_FALSE
(
true
)
)
ADD_FAILURE
(
)
;
EXPECT_TRUE
(
ABSL_PREDICT_FALSE
(
true
)
&
&
true
)
;
EXPECT_TRUE
(
ABSL_PREDICT_FALSE
(
true
)
|
|
false
)
;
}
TEST
(
PredictTest
OneEvaluation
)
{
int
x
=
0
;
if
(
ABSL_PREDICT_TRUE
(
(
+
+
x
)
=
=
0
)
)
ADD_FAILURE
(
)
;
EXPECT_EQ
(
x
1
)
;
if
(
ABSL_PREDICT_FALSE
(
(
+
+
x
)
=
=
0
)
)
ADD_FAILURE
(
)
;
EXPECT_EQ
(
x
2
)
;
}
TEST
(
PredictTest
OperatorOrder
)
{
EXPECT_TRUE
(
ABSL_PREDICT_TRUE
(
1
&
&
2
)
=
=
true
)
;
EXPECT_TRUE
(
ABSL_PREDICT_FALSE
(
1
&
&
2
)
=
=
true
)
;
EXPECT_TRUE
(
!
ABSL_PREDICT_TRUE
(
1
=
=
2
)
)
;
EXPECT_TRUE
(
!
ABSL_PREDICT_FALSE
(
1
=
=
2
)
)
;
}
TEST
(
PredictTest
Pointer
)
{
const
int
x
=
3
;
const
int
*
good_intptr
=
&
x
;
const
int
*
null_intptr
=
nullptr
;
EXPECT_TRUE
(
ABSL_PREDICT_TRUE
(
good_intptr
)
)
;
EXPECT_FALSE
(
ABSL_PREDICT_TRUE
(
null_intptr
)
)
;
EXPECT_TRUE
(
ABSL_PREDICT_FALSE
(
good_intptr
)
)
;
EXPECT_FALSE
(
ABSL_PREDICT_FALSE
(
null_intptr
)
)
;
}
TEST
(
PredictTest
Optional
)
{
absl
:
:
optional
<
bool
>
has_value
(
false
)
;
absl
:
:
optional
<
bool
>
no_value
;
EXPECT_TRUE
(
ABSL_PREDICT_TRUE
(
has_value
)
)
;
EXPECT_FALSE
(
ABSL_PREDICT_TRUE
(
no_value
)
)
;
EXPECT_TRUE
(
ABSL_PREDICT_FALSE
(
has_value
)
)
;
EXPECT_FALSE
(
ABSL_PREDICT_FALSE
(
no_value
)
)
;
}
class
ImplicitlyConvertibleToBool
{
public
:
explicit
ImplicitlyConvertibleToBool
(
bool
value
)
:
value_
(
value
)
{
}
operator
bool
(
)
const
{
return
value_
;
}
private
:
bool
value_
;
}
;
TEST
(
PredictTest
ImplicitBoolConversion
)
{
const
ImplicitlyConvertibleToBool
is_true
(
true
)
;
const
ImplicitlyConvertibleToBool
is_false
(
false
)
;
if
(
!
ABSL_PREDICT_TRUE
(
is_true
)
)
ADD_FAILURE
(
)
;
if
(
ABSL_PREDICT_TRUE
(
is_false
)
)
ADD_FAILURE
(
)
;
if
(
!
ABSL_PREDICT_FALSE
(
is_true
)
)
ADD_FAILURE
(
)
;
if
(
ABSL_PREDICT_FALSE
(
is_false
)
)
ADD_FAILURE
(
)
;
}
class
ExplicitlyConvertibleToBool
{
public
:
explicit
ExplicitlyConvertibleToBool
(
bool
value
)
:
value_
(
value
)
{
}
explicit
operator
bool
(
)
const
{
return
value_
;
}
private
:
bool
value_
;
}
;
TEST
(
PredictTest
ExplicitBoolConversion
)
{
const
ExplicitlyConvertibleToBool
is_true
(
true
)
;
const
ExplicitlyConvertibleToBool
is_false
(
false
)
;
if
(
!
ABSL_PREDICT_TRUE
(
is_true
)
)
ADD_FAILURE
(
)
;
if
(
ABSL_PREDICT_TRUE
(
is_false
)
)
ADD_FAILURE
(
)
;
if
(
!
ABSL_PREDICT_FALSE
(
is_true
)
)
ADD_FAILURE
(
)
;
if
(
ABSL_PREDICT_FALSE
(
is_false
)
)
ADD_FAILURE
(
)
;
}
TEST
(
AbslAssume
Compiles
)
{
int
x
=
0
;
ABSL_ASSUME
(
x
>
=
0
)
;
EXPECT_EQ
(
x
0
)
;
ABSL_ASSUME
(
x
>
=
0
)
(
x
>
=
0
)
?
+
+
x
:
-
-
x
;
EXPECT_EQ
(
x
1
)
;
}
}
