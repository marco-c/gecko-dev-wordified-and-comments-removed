#
ifndef
ABSL_RANDOM_INTERNAL_SEED_MATERIAL_H_
#
define
ABSL_RANDOM_INTERNAL_SEED_MATERIAL_H_
#
include
<
cassert
>
#
include
<
cstdint
>
#
include
<
cstdlib
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
random
/
internal
/
fast_uniform_bits
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
absl
/
types
/
span
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal
{
constexpr
size_t
SeedBitsToBlocks
(
size_t
seed_size
)
{
return
(
seed_size
+
31
)
/
32
;
}
constexpr
size_t
kEntropyBitsNeeded
=
256
;
constexpr
size_t
kEntropyBlocksNeeded
=
random_internal
:
:
SeedBitsToBlocks
(
kEntropyBitsNeeded
)
;
static_assert
(
kEntropyBlocksNeeded
>
0
"
Entropy
used
to
seed
URBGs
must
be
nonzero
.
"
)
;
[
[
nodiscard
]
]
bool
ReadSeedMaterialFromOSEntropy
(
absl
:
:
Span
<
uint32_t
>
values
)
;
template
<
typename
URBG
>
[
[
nodiscard
]
]
bool
ReadSeedMaterialFromURBG
(
URBG
*
urbg
absl
:
:
Span
<
uint32_t
>
values
)
{
random_internal
:
:
FastUniformBits
<
uint32_t
>
distr
;
assert
(
urbg
!
=
nullptr
&
&
values
.
data
(
)
!
=
nullptr
)
;
if
(
urbg
=
=
nullptr
|
|
values
.
data
(
)
=
=
nullptr
)
{
return
false
;
}
for
(
uint32_t
&
seed_value
:
values
)
{
seed_value
=
distr
(
*
urbg
)
;
}
return
true
;
}
void
MixIntoSeedMaterial
(
absl
:
:
Span
<
const
uint32_t
>
sequence
absl
:
:
Span
<
uint32_t
>
seed_material
)
;
absl
:
:
optional
<
uint32_t
>
GetSaltMaterial
(
)
;
}
ABSL_NAMESPACE_END
}
#
endif
