#
include
"
absl
/
random
/
internal
/
nonsecure_base
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
iterator
>
#
include
<
random
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
random
/
distributions
.
h
"
#
include
"
absl
/
random
/
random
.
h
"
namespace
{
using
ExampleNonsecureURBG
=
absl
:
:
random_internal
:
:
NonsecureURBGBase
<
std
:
:
mt19937
>
;
template
<
typename
T
>
void
Use
(
const
T
&
)
{
}
}
TEST
(
NonsecureURBGBase
DefaultConstructorIsValid
)
{
ExampleNonsecureURBG
urbg
;
}
TEST
(
RecommendedTemplates
CanBeConstructed
)
{
absl
:
:
BitGen
default_generator
;
absl
:
:
InsecureBitGen
insecure_generator
;
}
TEST
(
RecommendedTemplates
CanDiscardValues
)
{
absl
:
:
BitGen
default_generator
;
absl
:
:
InsecureBitGen
insecure_generator
;
default_generator
.
discard
(
5
)
;
insecure_generator
.
discard
(
5
)
;
}
TEST
(
NonsecureURBGBase
StandardInterface
)
{
using
E
=
absl
:
:
random_internal
:
:
NonsecureURBGBase
<
std
:
:
minstd_rand
>
;
using
T
=
typename
E
:
:
result_type
;
static_assert
(
!
std
:
:
is_copy_constructible
<
E
>
:
:
value
"
NonsecureURBGBase
should
not
be
copy
constructible
"
)
;
static_assert
(
!
absl
:
:
is_copy_assignable
<
E
>
:
:
value
"
NonsecureURBGBase
should
not
be
copy
assignable
"
)
;
static_assert
(
std
:
:
is_move_constructible
<
E
>
:
:
value
"
NonsecureURBGBase
should
be
move
constructible
"
)
;
static_assert
(
absl
:
:
is_move_assignable
<
E
>
:
:
value
"
NonsecureURBGBase
should
be
move
assignable
"
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
std
:
:
declval
<
E
>
(
)
(
)
)
T
>
:
:
value
"
return
type
of
operator
(
)
must
be
result_type
"
)
;
{
const
E
x
y
;
Use
(
x
)
;
Use
(
y
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
x
=
=
y
)
bool
>
:
:
value
"
return
type
of
operator
=
=
must
be
bool
"
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
x
!
=
y
)
bool
>
:
:
value
"
return
type
of
operator
=
=
must
be
bool
"
)
;
}
E
e
;
std
:
:
seed_seq
q
{
1
2
3
}
;
E
{
}
;
E
{
q
}
;
{
E
tmp
(
q
)
;
E
m
=
std
:
:
move
(
tmp
)
;
E
n
(
std
:
:
move
(
m
)
)
;
EXPECT_TRUE
(
e
!
=
n
)
;
}
{
E
a
(
q
)
;
E
b
(
q
)
;
EXPECT_TRUE
(
a
!
=
e
)
;
EXPECT_TRUE
(
a
=
=
b
)
;
a
(
)
;
EXPECT_TRUE
(
a
!
=
b
)
;
}
unsigned
long
long
z
=
1
;
e
.
discard
(
z
)
;
}
TEST
(
NonsecureURBGBase
SeedSeqConstructorIsValid
)
{
std
:
:
seed_seq
seq
;
ExampleNonsecureURBG
rbg
(
seq
)
;
}
TEST
(
NonsecureURBGBase
CompatibleWithDistributionUtils
)
{
ExampleNonsecureURBG
rbg
;
absl
:
:
Uniform
(
rbg
0
100
)
;
absl
:
:
Uniform
(
rbg
0
.
5
0
.
7
)
;
absl
:
:
Poisson
<
uint32_t
>
(
rbg
)
;
absl
:
:
Exponential
<
float
>
(
rbg
)
;
}
TEST
(
NonsecureURBGBase
CompatibleWithStdDistributions
)
{
ExampleNonsecureURBG
rbg
;
static_cast
<
void
>
(
std
:
:
uniform_int_distribution
<
uint32_t
>
(
0
100
)
(
rbg
)
)
;
static_cast
<
void
>
(
std
:
:
uniform_real_distribution
<
float
>
(
)
(
rbg
)
)
;
static_cast
<
void
>
(
std
:
:
bernoulli_distribution
(
0
.
2
)
(
rbg
)
)
;
}
TEST
(
NonsecureURBGBase
ConsecutiveDefaultInstancesYieldUniqueVariates
)
{
const
size_t
kNumSamples
=
128
;
ExampleNonsecureURBG
rbg1
;
ExampleNonsecureURBG
rbg2
;
for
(
size_t
i
=
0
;
i
<
kNumSamples
;
i
+
+
)
{
EXPECT_NE
(
rbg1
(
)
rbg2
(
)
)
;
}
}
TEST
(
NonsecureURBGBase
EqualSeedSequencesYieldEqualVariates
)
{
std
:
:
seed_seq
seq
;
ExampleNonsecureURBG
rbg1
(
seq
)
;
ExampleNonsecureURBG
rbg2
(
seq
)
;
for
(
uint32_t
i
=
0
;
i
<
1000
;
i
+
+
)
{
EXPECT_EQ
(
rbg1
(
)
rbg2
(
)
)
;
}
rbg1
.
discard
(
100
)
;
rbg2
.
discard
(
100
)
;
for
(
uint32_t
i
=
0
;
i
<
1000
;
i
+
+
)
{
EXPECT_EQ
(
rbg1
(
)
rbg2
(
)
)
;
}
}
TEST
(
RandenPoolSeedSeqTest
SeederWorksForU32
)
{
absl
:
:
random_internal
:
:
RandenPoolSeedSeq
seeder
;
uint32_t
state
[
2
]
=
{
0
0
}
;
seeder
.
generate
(
std
:
:
begin
(
state
)
std
:
:
end
(
state
)
)
;
EXPECT_FALSE
(
state
[
0
]
=
=
0
&
&
state
[
1
]
=
=
0
)
;
}
TEST
(
RandenPoolSeedSeqTest
SeederWorksForU64
)
{
absl
:
:
random_internal
:
:
RandenPoolSeedSeq
seeder
;
uint64_t
state
[
2
]
=
{
0
0
}
;
seeder
.
generate
(
std
:
:
begin
(
state
)
std
:
:
end
(
state
)
)
;
EXPECT_FALSE
(
state
[
0
]
=
=
0
&
&
state
[
1
]
=
=
0
)
;
EXPECT_FALSE
(
(
state
[
0
]
>
>
32
)
=
=
0
&
&
(
state
[
1
]
>
>
32
)
=
=
0
)
;
}
TEST
(
RandenPoolSeedSeqTest
SeederWorksForS32
)
{
absl
:
:
random_internal
:
:
RandenPoolSeedSeq
seeder
;
int32_t
state
[
2
]
=
{
0
0
}
;
seeder
.
generate
(
std
:
:
begin
(
state
)
std
:
:
end
(
state
)
)
;
EXPECT_FALSE
(
state
[
0
]
=
=
0
&
&
state
[
1
]
=
=
0
)
;
}
TEST
(
RandenPoolSeedSeqTest
SeederWorksForVector
)
{
absl
:
:
random_internal
:
:
RandenPoolSeedSeq
seeder
;
std
:
:
vector
<
uint32_t
>
state
(
2
)
;
seeder
.
generate
(
std
:
:
begin
(
state
)
std
:
:
end
(
state
)
)
;
EXPECT_FALSE
(
state
[
0
]
=
=
0
&
&
state
[
1
]
=
=
0
)
;
}
