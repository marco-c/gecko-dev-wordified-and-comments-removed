#
include
"
absl
/
random
/
internal
/
entropy_pool
.
h
"
#
include
<
bitset
>
#
include
<
cmath
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
thread
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
container
/
flat_hash_set
.
h
"
#
include
"
absl
/
synchronization
/
mutex
.
h
"
namespace
{
using
:
:
absl
:
:
random_internal
:
:
GetEntropyFromRandenPool
;
TEST
(
EntropyPoolTest
DistinctSequencesPerThread
)
{
using
result_type
=
uint32_t
;
constexpr
int
kNumThreads
=
12
;
constexpr
size_t
kValuesPerThread
=
32
;
std
:
:
vector
<
std
:
:
vector
<
result_type
>
>
data
;
{
absl
:
:
Mutex
mu
;
std
:
:
vector
<
std
:
:
thread
>
threads
;
for
(
int
i
=
0
;
i
<
kNumThreads
;
i
+
+
)
{
threads
.
emplace_back
(
[
&
]
(
)
{
std
:
:
vector
<
result_type
>
v
(
kValuesPerThread
)
;
GetEntropyFromRandenPool
(
v
.
data
(
)
sizeof
(
result_type
)
*
v
.
size
(
)
)
;
absl
:
:
MutexLock
l
(
&
mu
)
;
data
.
push_back
(
std
:
:
move
(
v
)
)
;
}
)
;
}
for
(
auto
&
t
:
threads
)
t
.
join
(
)
;
}
EXPECT_EQ
(
data
.
size
(
)
kNumThreads
)
;
size_t
expected_size
=
0
;
absl
:
:
flat_hash_set
<
result_type
>
seen
;
for
(
const
auto
&
v
:
data
)
{
expected_size
+
=
v
.
size
(
)
;
for
(
result_type
x
:
v
)
seen
.
insert
(
x
)
;
}
EXPECT_GE
(
seen
.
size
(
)
expected_size
-
1
)
;
}
TEST
(
EntropyPoolTest
ValidateDistribution
)
{
using
result_type
=
uint32_t
;
constexpr
int
kNumOutputs
=
16
;
std
:
:
vector
<
result_type
>
a
(
kNumOutputs
)
;
std
:
:
vector
<
result_type
>
b
(
kNumOutputs
)
;
GetEntropyFromRandenPool
(
a
.
data
(
)
sizeof
(
a
[
0
]
)
*
a
.
size
(
)
)
;
GetEntropyFromRandenPool
(
b
.
data
(
)
sizeof
(
b
[
0
]
)
*
b
.
size
(
)
)
;
size_t
changed_bits
=
0
;
size_t
total_set
=
0
;
size_t
equal_count
=
0
;
size_t
zero_count
=
0
;
for
(
size_t
i
=
0
;
i
<
a
.
size
(
)
;
+
+
i
)
{
std
:
:
bitset
<
sizeof
(
result_type
)
*
8
>
changed_set
(
a
[
i
]
^
b
[
i
]
)
;
changed_bits
+
=
changed_set
.
count
(
)
;
std
:
:
bitset
<
sizeof
(
result_type
)
*
8
>
a_set
(
a
[
i
]
)
;
std
:
:
bitset
<
sizeof
(
result_type
)
*
8
>
b_set
(
b
[
i
]
)
;
total_set
+
=
a_set
.
count
(
)
+
b_set
.
count
(
)
;
equal_count
+
=
(
a
[
i
]
=
=
b
[
i
]
)
?
1
:
0
;
zero_count
+
=
(
a
[
i
]
=
=
0
)
?
1
:
0
;
zero_count
+
=
(
b
[
i
]
=
=
0
)
?
1
:
0
;
}
constexpr
size_t
kNBits
=
kNumOutputs
*
sizeof
(
result_type
)
*
8
;
EXPECT_NEAR
(
changed_bits
kNBits
*
0
.
5
5
*
std
:
:
sqrt
(
kNBits
)
)
<
<
"
"
<
<
changed_bits
/
static_cast
<
double
>
(
kNBits
)
;
EXPECT_NEAR
(
total_set
kNBits
5
*
std
:
:
sqrt
(
2
*
kNBits
)
)
<
<
"
"
<
<
total_set
/
static_cast
<
double
>
(
2
*
kNBits
)
;
EXPECT_LE
(
equal_count
1
)
;
EXPECT_LE
(
zero_count
1
)
;
}
}
