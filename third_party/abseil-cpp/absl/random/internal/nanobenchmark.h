#
ifndef
ABSL_RANDOM_INTERNAL_NANOBENCHMARK_H_
#
define
ABSL_RANDOM_INTERNAL_NANOBENCHMARK_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
absl
/
base
/
config
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal_nanobenchmark
{
using
FuncInput
=
size_t
;
using
FuncOutput
=
uint64_t
;
using
Func
=
FuncOutput
(
*
)
(
const
void
*
FuncInput
)
;
struct
Params
{
static
constexpr
size_t
kTimerSamples
=
256
;
size_t
precision_divisor
=
1024
;
size_t
subset_ratio
=
2
;
double
seconds_per_eval
=
4E
-
3
;
size_t
min_samples_per_eval
=
7
;
size_t
min_mode_samples
=
64
;
double
target_rel_mad
=
0
.
002
;
size_t
max_evals
=
9
;
size_t
max_measure_retries
=
2
;
bool
verbose
=
true
;
}
;
struct
Result
{
FuncInput
input
;
float
ticks
;
float
variability
;
}
;
void
PinThreadToCPU
(
const
int
cpu
=
-
1
)
;
double
InvariantTicksPerSecond
(
)
;
size_t
Measure
(
const
Func
func
const
void
*
arg
const
FuncInput
*
inputs
const
size_t
num_inputs
Result
*
results
const
Params
&
p
=
Params
(
)
)
;
template
<
class
Closure
>
static
FuncOutput
CallClosure
(
const
void
*
f
const
FuncInput
input
)
{
return
(
*
reinterpret_cast
<
const
Closure
*
>
(
f
)
)
(
input
)
;
}
template
<
class
Closure
>
static
inline
size_t
MeasureClosure
(
const
Closure
&
closure
const
FuncInput
*
inputs
const
size_t
num_inputs
Result
*
results
const
Params
&
p
=
Params
(
)
)
{
return
Measure
(
reinterpret_cast
<
Func
>
(
&
CallClosure
<
Closure
>
)
reinterpret_cast
<
const
void
*
>
(
&
closure
)
inputs
num_inputs
results
p
)
;
}
}
ABSL_NAMESPACE_END
}
#
endif
