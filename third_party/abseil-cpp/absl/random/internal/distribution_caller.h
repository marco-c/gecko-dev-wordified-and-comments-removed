#
ifndef
ABSL_RANDOM_INTERNAL_DISTRIBUTION_CALLER_H_
#
define
ABSL_RANDOM_INTERNAL_DISTRIBUTION_CALLER_H_
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
fast_type_id
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal
{
template
<
typename
URBG
>
struct
DistributionCaller
{
static_assert
(
!
std
:
:
is_pointer
<
URBG
>
:
:
value
"
You
must
pass
a
reference
not
a
pointer
.
"
)
;
template
<
template
<
class
.
.
.
>
class
Trait
class
AlwaysVoid
class
.
.
.
Args
>
struct
detector
:
std
:
:
false_type
{
}
;
template
<
template
<
class
.
.
.
>
class
Trait
class
.
.
.
Args
>
struct
detector
<
Trait
absl
:
:
void_t
<
Trait
<
Args
.
.
.
>
>
Args
.
.
.
>
:
std
:
:
true_type
{
}
;
template
<
class
T
>
using
invoke_mock_t
=
decltype
(
std
:
:
declval
<
T
*
>
(
)
-
>
InvokeMock
(
std
:
:
declval
<
base_internal
:
:
FastTypeIdType
>
(
)
std
:
:
declval
<
void
*
>
(
)
std
:
:
declval
<
void
*
>
(
)
)
)
;
using
HasInvokeMock
=
typename
detector
<
invoke_mock_t
void
URBG
>
:
:
type
;
template
<
typename
DistrT
typename
.
.
.
Args
>
static
typename
DistrT
:
:
result_type
Impl
(
std
:
:
false_type
URBG
*
urbg
Args
&
&
.
.
.
args
)
{
DistrT
dist
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
return
dist
(
*
urbg
)
;
}
template
<
typename
DistrT
typename
.
.
.
Args
>
static
typename
DistrT
:
:
result_type
Impl
(
std
:
:
true_type
URBG
*
urbg
Args
&
&
.
.
.
args
)
{
using
ResultT
=
typename
DistrT
:
:
result_type
;
using
ArgTupleT
=
std
:
:
tuple
<
absl
:
:
decay_t
<
Args
>
.
.
.
>
;
using
KeyT
=
ResultT
(
DistrT
ArgTupleT
)
;
ArgTupleT
arg_tuple
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
ResultT
result
;
if
(
!
urbg
-
>
InvokeMock
(
base_internal
:
:
FastTypeId
<
KeyT
>
(
)
&
arg_tuple
&
result
)
)
{
auto
dist
=
absl
:
:
make_from_tuple
<
DistrT
>
(
arg_tuple
)
;
result
=
dist
(
*
urbg
)
;
}
return
result
;
}
template
<
typename
DistrT
typename
.
.
.
Args
>
static
typename
DistrT
:
:
result_type
Call
(
URBG
*
urbg
Args
&
&
.
.
.
args
)
{
return
Impl
<
DistrT
Args
.
.
.
>
(
HasInvokeMock
{
}
urbg
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
;
}
ABSL_NAMESPACE_END
}
#
endif
