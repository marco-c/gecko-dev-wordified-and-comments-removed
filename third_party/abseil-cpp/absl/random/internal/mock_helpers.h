#
ifndef
ABSL_RANDOM_INTERNAL_MOCK_HELPERS_H_
#
define
ABSL_RANDOM_INTERNAL_MOCK_HELPERS_H_
#
include
<
utility
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
fast_type_id
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal
{
struct
NoOpValidator
{
template
<
typename
ResultT
typename
.
.
.
Args
>
static
void
Validate
(
ResultT
Args
&
&
.
.
.
)
{
}
}
;
class
MockHelpers
{
using
IdType
=
:
:
absl
:
:
base_internal
:
:
FastTypeIdType
;
template
<
typename
KeyT
>
struct
KeySignature
;
template
<
typename
ResultT
typename
DiscriminatorT
typename
ArgTupleT
>
struct
KeySignature
<
ResultT
(
DiscriminatorT
ArgTupleT
)
>
{
using
result_type
=
ResultT
;
using
discriminator_type
=
DiscriminatorT
;
using
arg_tuple_type
=
ArgTupleT
;
}
;
template
<
class
T
>
using
invoke_mock_t
=
decltype
(
std
:
:
declval
<
T
*
>
(
)
-
>
InvokeMock
(
std
:
:
declval
<
IdType
>
(
)
std
:
:
declval
<
void
*
>
(
)
std
:
:
declval
<
void
*
>
(
)
)
)
;
template
<
typename
KeyT
typename
ReturnT
typename
ArgTupleT
typename
URBG
typename
.
.
.
Args
>
static
absl
:
:
optional
<
ReturnT
>
InvokeMockImpl
(
char
URBG
*
Args
&
&
.
.
.
)
{
return
absl
:
:
nullopt
;
}
template
<
typename
KeyT
typename
ReturnT
typename
ArgTupleT
typename
URBG
typename
=
invoke_mock_t
<
URBG
>
typename
.
.
.
Args
>
static
absl
:
:
optional
<
ReturnT
>
InvokeMockImpl
(
int
URBG
*
urbg
Args
&
&
.
.
.
args
)
{
ArgTupleT
arg_tuple
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
ReturnT
result
;
if
(
urbg
-
>
InvokeMock
(
base_internal
:
:
FastTypeId
<
KeyT
>
(
)
&
arg_tuple
&
result
)
)
{
return
result
;
}
return
absl
:
:
nullopt
;
}
public
:
template
<
typename
URBG
>
static
inline
bool
PrivateInvokeMock
(
URBG
*
urbg
IdType
key_id
void
*
args_tuple
void
*
result
)
{
return
urbg
-
>
InvokeMock
(
key_id
args_tuple
result
)
;
}
template
<
typename
KeyT
typename
URBG
typename
.
.
.
Args
>
static
auto
MaybeInvokeMock
(
URBG
*
urbg
Args
&
&
.
.
.
args
)
-
>
absl
:
:
optional
<
typename
KeySignature
<
KeyT
>
:
:
result_type
>
{
return
InvokeMockImpl
<
KeyT
typename
KeySignature
<
KeyT
>
:
:
result_type
typename
KeySignature
<
KeyT
>
:
:
arg_tuple_type
URBG
>
(
0
urbg
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
KeyT
typename
ValidatorT
typename
MockURBG
>
static
auto
MockFor
(
MockURBG
&
m
ValidatorT
)
-
>
decltype
(
m
.
template
RegisterMock
<
typename
KeySignature
<
KeyT
>
:
:
result_type
typename
KeySignature
<
KeyT
>
:
:
arg_tuple_type
>
(
m
std
:
:
declval
<
IdType
>
(
)
ValidatorT
(
)
)
)
{
return
m
.
template
RegisterMock
<
typename
KeySignature
<
KeyT
>
:
:
result_type
typename
KeySignature
<
KeyT
>
:
:
arg_tuple_type
>
(
m
:
:
absl
:
:
base_internal
:
:
FastTypeId
<
KeyT
>
(
)
ValidatorT
(
)
)
;
}
template
<
typename
KeyT
typename
MockURBG
>
static
decltype
(
auto
)
MockFor
(
MockURBG
&
m
)
{
return
MockFor
<
KeyT
>
(
m
NoOpValidator
(
)
)
;
}
}
;
}
ABSL_NAMESPACE_END
}
#
endif
