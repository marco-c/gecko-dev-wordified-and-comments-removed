#
ifndef
ABSL_RANDOM_DISCRETE_DISTRIBUTION_H_
#
define
ABSL_RANDOM_DISCRETE_DISTRIBUTION_H_
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
<
initializer_list
>
#
include
<
istream
>
#
include
<
limits
>
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
random
/
bernoulli_distribution
.
h
"
#
include
"
absl
/
random
/
internal
/
iostream_state_saver
.
h
"
#
include
"
absl
/
random
/
uniform_int_distribution
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
IntType
=
int
>
class
discrete_distribution
{
public
:
using
result_type
=
IntType
;
class
param_type
{
public
:
using
distribution_type
=
discrete_distribution
;
param_type
(
)
{
init
(
)
;
}
template
<
typename
InputIterator
>
explicit
param_type
(
InputIterator
begin
InputIterator
end
)
:
p_
(
begin
end
)
{
init
(
)
;
}
explicit
param_type
(
std
:
:
initializer_list
<
double
>
weights
)
:
p_
(
weights
)
{
init
(
)
;
}
template
<
class
UnaryOperation
>
explicit
param_type
(
size_t
nw
double
xmin
double
xmax
UnaryOperation
fw
)
{
if
(
nw
>
0
)
{
p_
.
reserve
(
nw
)
;
double
delta
=
(
xmax
-
xmin
)
/
static_cast
<
double
>
(
nw
)
;
assert
(
delta
>
0
)
;
double
t
=
delta
*
0
.
5
;
for
(
size_t
i
=
0
;
i
<
nw
;
+
+
i
)
{
p_
.
push_back
(
fw
(
xmin
+
i
*
delta
+
t
)
)
;
}
}
init
(
)
;
}
const
std
:
:
vector
<
double
>
&
probabilities
(
)
const
{
return
p_
;
}
size_t
n
(
)
const
{
return
p_
.
size
(
)
-
1
;
}
friend
bool
operator
=
=
(
const
param_type
&
a
const
param_type
&
b
)
{
return
a
.
probabilities
(
)
=
=
b
.
probabilities
(
)
;
}
friend
bool
operator
!
=
(
const
param_type
&
a
const
param_type
&
b
)
{
return
!
(
a
=
=
b
)
;
}
private
:
friend
class
discrete_distribution
;
void
init
(
)
;
std
:
:
vector
<
double
>
p_
;
std
:
:
vector
<
std
:
:
pair
<
double
size_t
>
>
q_
;
static_assert
(
std
:
:
is_integral
<
result_type
>
:
:
value
"
Class
-
template
absl
:
:
discrete_distribution
<
>
must
be
"
"
parameterized
using
an
integral
type
.
"
)
;
}
;
discrete_distribution
(
)
:
param_
(
)
{
}
explicit
discrete_distribution
(
const
param_type
&
p
)
:
param_
(
p
)
{
}
template
<
typename
InputIterator
>
explicit
discrete_distribution
(
InputIterator
begin
InputIterator
end
)
:
param_
(
begin
end
)
{
}
explicit
discrete_distribution
(
std
:
:
initializer_list
<
double
>
weights
)
:
param_
(
weights
)
{
}
template
<
class
UnaryOperation
>
explicit
discrete_distribution
(
size_t
nw
double
xmin
double
xmax
UnaryOperation
fw
)
:
param_
(
nw
xmin
xmax
std
:
:
move
(
fw
)
)
{
}
void
reset
(
)
{
}
template
<
typename
URBG
>
result_type
operator
(
)
(
URBG
&
g
)
{
return
(
*
this
)
(
g
param_
)
;
}
template
<
typename
URBG
>
result_type
operator
(
)
(
URBG
&
g
const
param_type
&
p
)
;
const
param_type
&
param
(
)
const
{
return
param_
;
}
void
param
(
const
param_type
&
p
)
{
param_
=
p
;
}
result_type
(
min
)
(
)
const
{
return
0
;
}
result_type
(
max
)
(
)
const
{
return
static_cast
<
result_type
>
(
param_
.
n
(
)
)
;
}
const
std
:
:
vector
<
double
>
&
probabilities
(
)
const
{
return
param_
.
probabilities
(
)
;
}
friend
bool
operator
=
=
(
const
discrete_distribution
&
a
const
discrete_distribution
&
b
)
{
return
a
.
param_
=
=
b
.
param_
;
}
friend
bool
operator
!
=
(
const
discrete_distribution
&
a
const
discrete_distribution
&
b
)
{
return
a
.
param_
!
=
b
.
param_
;
}
private
:
param_type
param_
;
}
;
namespace
random_internal
{
std
:
:
vector
<
std
:
:
pair
<
double
size_t
>
>
InitDiscreteDistribution
(
std
:
:
vector
<
double
>
*
probabilities
)
;
}
template
<
typename
IntType
>
void
discrete_distribution
<
IntType
>
:
:
param_type
:
:
init
(
)
{
if
(
p_
.
empty
(
)
)
{
p_
.
push_back
(
1
.
0
)
;
q_
.
emplace_back
(
1
.
0
0
)
;
}
else
{
assert
(
n
(
)
<
=
(
std
:
:
numeric_limits
<
IntType
>
:
:
max
)
(
)
)
;
q_
=
random_internal
:
:
InitDiscreteDistribution
(
&
p_
)
;
}
}
template
<
typename
IntType
>
template
<
typename
URBG
>
typename
discrete_distribution
<
IntType
>
:
:
result_type
discrete_distribution
<
IntType
>
:
:
operator
(
)
(
URBG
&
g
const
param_type
&
p
)
{
const
auto
idx
=
absl
:
:
uniform_int_distribution
<
result_type
>
(
0
p
.
n
(
)
)
(
g
)
;
const
auto
&
q
=
p
.
q_
[
idx
]
;
const
bool
selected
=
absl
:
:
bernoulli_distribution
(
q
.
first
)
(
g
)
;
return
selected
?
idx
:
static_cast
<
result_type
>
(
q
.
second
)
;
}
template
<
typename
CharT
typename
Traits
typename
IntType
>
std
:
:
basic_ostream
<
CharT
Traits
>
&
operator
<
<
(
std
:
:
basic_ostream
<
CharT
Traits
>
&
os
const
discrete_distribution
<
IntType
>
&
x
)
{
auto
saver
=
random_internal
:
:
make_ostream_state_saver
(
os
)
;
const
auto
&
probabilities
=
x
.
param
(
)
.
probabilities
(
)
;
os
<
<
probabilities
.
size
(
)
;
os
.
precision
(
random_internal
:
:
stream_precision_helper
<
double
>
:
:
kPrecision
)
;
for
(
const
auto
&
p
:
probabilities
)
{
os
<
<
os
.
fill
(
)
<
<
p
;
}
return
os
;
}
template
<
typename
CharT
typename
Traits
typename
IntType
>
std
:
:
basic_istream
<
CharT
Traits
>
&
operator
>
>
(
std
:
:
basic_istream
<
CharT
Traits
>
&
is
discrete_distribution
<
IntType
>
&
x
)
{
using
param_type
=
typename
discrete_distribution
<
IntType
>
:
:
param_type
;
auto
saver
=
random_internal
:
:
make_istream_state_saver
(
is
)
;
size_t
n
;
std
:
:
vector
<
double
>
p
;
is
>
>
n
;
if
(
is
.
fail
(
)
)
return
is
;
if
(
n
>
0
)
{
p
.
reserve
(
n
)
;
for
(
IntType
i
=
0
;
i
<
n
&
&
!
is
.
fail
(
)
;
+
+
i
)
{
auto
tmp
=
random_internal
:
:
read_floating_point
<
double
>
(
is
)
;
if
(
is
.
fail
(
)
)
return
is
;
p
.
push_back
(
tmp
)
;
}
}
x
.
param
(
param_type
(
p
.
begin
(
)
p
.
end
(
)
)
)
;
return
is
;
}
ABSL_NAMESPACE_END
}
#
endif
