#
ifndef
ABSL_RANDOM_GAUSSIAN_DISTRIBUTION_H_
#
define
ABSL_RANDOM_GAUSSIAN_DISTRIBUTION_H_
#
include
<
cmath
>
#
include
<
cstdint
>
#
include
<
istream
>
#
include
<
limits
>
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
random
/
internal
/
fast_uniform_bits
.
h
"
#
include
"
absl
/
random
/
internal
/
generate_real
.
h
"
#
include
"
absl
/
random
/
internal
/
iostream_state_saver
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal
{
class
ABSL_DLL
gaussian_distribution_base
{
public
:
template
<
typename
URBG
>
inline
double
zignor
(
URBG
&
g
)
;
private
:
friend
class
TableGenerator
;
template
<
typename
URBG
>
inline
double
zignor_fallback
(
URBG
&
g
bool
neg
)
;
static
constexpr
double
kR
=
3
.
442619855899
;
static
constexpr
double
kRInv
=
0
.
29047645161474317
;
static
constexpr
double
kV
=
9
.
91256303526217e
-
3
;
static
constexpr
uint64_t
kMask
=
0x07f
;
struct
Tables
{
double
x
[
kMask
+
2
]
;
double
f
[
kMask
+
2
]
;
}
;
static
const
Tables
zg_
;
random_internal
:
:
FastUniformBits
<
uint64_t
>
fast_u64_
;
}
;
}
template
<
typename
RealType
=
double
>
class
gaussian_distribution
:
random_internal
:
:
gaussian_distribution_base
{
public
:
using
result_type
=
RealType
;
class
param_type
{
public
:
using
distribution_type
=
gaussian_distribution
;
explicit
param_type
(
result_type
mean
=
0
result_type
stddev
=
1
)
:
mean_
(
mean
)
stddev_
(
stddev
)
{
}
result_type
mean
(
)
const
{
return
mean_
;
}
result_type
stddev
(
)
const
{
return
stddev_
;
}
friend
bool
operator
=
=
(
const
param_type
&
a
const
param_type
&
b
)
{
return
a
.
mean_
=
=
b
.
mean_
&
&
a
.
stddev_
=
=
b
.
stddev_
;
}
friend
bool
operator
!
=
(
const
param_type
&
a
const
param_type
&
b
)
{
return
!
(
a
=
=
b
)
;
}
private
:
result_type
mean_
;
result_type
stddev_
;
static_assert
(
std
:
:
is_floating_point
<
RealType
>
:
:
value
"
Class
-
template
absl
:
:
gaussian_distribution
<
>
must
be
parameterized
"
"
using
a
floating
-
point
type
.
"
)
;
}
;
gaussian_distribution
(
)
:
gaussian_distribution
(
0
)
{
}
explicit
gaussian_distribution
(
result_type
mean
result_type
stddev
=
1
)
:
param_
(
mean
stddev
)
{
}
explicit
gaussian_distribution
(
const
param_type
&
p
)
:
param_
(
p
)
{
}
void
reset
(
)
{
}
template
<
typename
URBG
>
result_type
operator
(
)
(
URBG
&
g
)
{
return
(
*
this
)
(
g
param_
)
;
}
template
<
typename
URBG
>
result_type
operator
(
)
(
URBG
&
g
const
param_type
&
p
)
;
param_type
param
(
)
const
{
return
param_
;
}
void
param
(
const
param_type
&
p
)
{
param_
=
p
;
}
result_type
(
min
)
(
)
const
{
return
-
std
:
:
numeric_limits
<
result_type
>
:
:
infinity
(
)
;
}
result_type
(
max
)
(
)
const
{
return
std
:
:
numeric_limits
<
result_type
>
:
:
infinity
(
)
;
}
result_type
mean
(
)
const
{
return
param_
.
mean
(
)
;
}
result_type
stddev
(
)
const
{
return
param_
.
stddev
(
)
;
}
friend
bool
operator
=
=
(
const
gaussian_distribution
&
a
const
gaussian_distribution
&
b
)
{
return
a
.
param_
=
=
b
.
param_
;
}
friend
bool
operator
!
=
(
const
gaussian_distribution
&
a
const
gaussian_distribution
&
b
)
{
return
a
.
param_
!
=
b
.
param_
;
}
private
:
param_type
param_
;
}
;
template
<
typename
RealType
>
template
<
typename
URBG
>
typename
gaussian_distribution
<
RealType
>
:
:
result_type
gaussian_distribution
<
RealType
>
:
:
operator
(
)
(
URBG
&
g
const
param_type
&
p
)
{
return
p
.
mean
(
)
+
p
.
stddev
(
)
*
static_cast
<
result_type
>
(
zignor
(
g
)
)
;
}
template
<
typename
CharT
typename
Traits
typename
RealType
>
std
:
:
basic_ostream
<
CharT
Traits
>
&
operator
<
<
(
std
:
:
basic_ostream
<
CharT
Traits
>
&
os
const
gaussian_distribution
<
RealType
>
&
x
)
{
auto
saver
=
random_internal
:
:
make_ostream_state_saver
(
os
)
;
os
.
precision
(
random_internal
:
:
stream_precision_helper
<
RealType
>
:
:
kPrecision
)
;
os
<
<
x
.
mean
(
)
<
<
os
.
fill
(
)
<
<
x
.
stddev
(
)
;
return
os
;
}
template
<
typename
CharT
typename
Traits
typename
RealType
>
std
:
:
basic_istream
<
CharT
Traits
>
&
operator
>
>
(
std
:
:
basic_istream
<
CharT
Traits
>
&
is
gaussian_distribution
<
RealType
>
&
x
)
{
using
result_type
=
typename
gaussian_distribution
<
RealType
>
:
:
result_type
;
using
param_type
=
typename
gaussian_distribution
<
RealType
>
:
:
param_type
;
auto
saver
=
random_internal
:
:
make_istream_state_saver
(
is
)
;
auto
mean
=
random_internal
:
:
read_floating_point
<
result_type
>
(
is
)
;
if
(
is
.
fail
(
)
)
return
is
;
auto
stddev
=
random_internal
:
:
read_floating_point
<
result_type
>
(
is
)
;
if
(
!
is
.
fail
(
)
)
{
x
.
param
(
param_type
(
mean
stddev
)
)
;
}
return
is
;
}
namespace
random_internal
{
template
<
typename
URBG
>
inline
double
gaussian_distribution_base
:
:
zignor_fallback
(
URBG
&
g
bool
neg
)
{
using
random_internal
:
:
GeneratePositiveTag
;
using
random_internal
:
:
GenerateRealFromBits
;
double
x
y
;
do
{
x
=
kRInv
*
std
:
:
log
(
GenerateRealFromBits
<
double
GeneratePositiveTag
false
>
(
fast_u64_
(
g
)
)
)
;
y
=
-
std
:
:
log
(
GenerateRealFromBits
<
double
GeneratePositiveTag
false
>
(
fast_u64_
(
g
)
)
)
;
}
while
(
(
y
+
y
)
<
(
x
*
x
)
)
;
return
neg
?
(
x
-
kR
)
:
(
kR
-
x
)
;
}
template
<
typename
URBG
>
inline
double
gaussian_distribution_base
:
:
zignor
(
URBG
&
g
)
{
using
random_internal
:
:
GeneratePositiveTag
;
using
random_internal
:
:
GenerateRealFromBits
;
using
random_internal
:
:
GenerateSignedTag
;
while
(
true
)
{
uint64_t
bits
=
fast_u64_
(
g
)
;
int
i
=
static_cast
<
int
>
(
bits
&
kMask
)
;
double
j
=
GenerateRealFromBits
<
double
GenerateSignedTag
false
>
(
bits
)
;
const
double
x
=
j
*
zg_
.
x
[
i
]
;
if
(
std
:
:
abs
(
x
)
<
zg_
.
x
[
i
+
1
]
)
{
return
x
;
}
if
(
i
=
=
0
)
{
return
zignor_fallback
(
g
j
<
0
)
;
}
double
v
=
GenerateRealFromBits
<
double
GeneratePositiveTag
false
>
(
fast_u64_
(
g
)
)
;
if
(
(
zg_
.
f
[
i
+
1
]
+
v
*
(
zg_
.
f
[
i
]
-
zg_
.
f
[
i
+
1
]
)
)
<
std
:
:
exp
(
-
0
.
5
*
x
*
x
)
)
{
return
x
;
}
}
}
}
ABSL_NAMESPACE_END
}
#
endif
