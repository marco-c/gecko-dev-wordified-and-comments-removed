#
ifndef
ABSL_FUNCTIONAL_OVERLOAD_H_
#
define
ABSL_FUNCTIONAL_OVERLOAD_H_
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
#
if
defined
(
ABSL_INTERNAL_CPLUSPLUS_LANG
)
&
&
\
ABSL_INTERNAL_CPLUSPLUS_LANG
>
=
201703L
template
<
int
&
.
.
.
ExplicitArgumentBarrier
typename
.
.
.
T
>
auto
Overload
(
T
&
&
.
.
.
ts
)
{
struct
OverloadImpl
:
absl
:
:
remove_cvref_t
<
T
>
.
.
.
{
using
absl
:
:
remove_cvref_t
<
T
>
:
:
operator
(
)
.
.
.
;
}
;
return
OverloadImpl
{
std
:
:
forward
<
T
>
(
ts
)
.
.
.
}
;
}
#
else
namespace
functional_internal
{
template
<
typename
T
>
constexpr
bool
kDependentFalse
=
false
;
}
template
<
typename
Dependent
=
int
typename
.
.
.
T
>
auto
Overload
(
T
&
&
.
.
.
)
{
static_assert
(
functional_internal
:
:
kDependentFalse
<
Dependent
>
"
Overload
is
only
usable
with
C
+
+
17
or
above
.
"
)
;
}
#
endif
ABSL_NAMESPACE_END
}
#
endif
