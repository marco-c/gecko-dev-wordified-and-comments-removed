#
ifndef
ABSL_FUNCTIONAL_INTERNAL_FRONT_BINDER_H_
#
define
ABSL_FUNCTIONAL_INTERNAL_FRONT_BINDER_H_
#
include
<
cstddef
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
container
/
internal
/
compressed_tuple
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
functional_internal
{
template
<
class
R
class
Tuple
size_t
.
.
.
Idx
class
.
.
.
Args
>
R
Apply
(
Tuple
&
&
bound
absl
:
:
index_sequence
<
Idx
.
.
.
>
Args
&
&
.
.
.
free
)
{
return
std
:
:
invoke
(
std
:
:
forward
<
Tuple
>
(
bound
)
.
template
get
<
Idx
>
(
)
.
.
.
std
:
:
forward
<
Args
>
(
free
)
.
.
.
)
;
}
template
<
class
F
class
.
.
.
BoundArgs
>
class
FrontBinder
{
using
BoundArgsT
=
absl
:
:
container_internal
:
:
CompressedTuple
<
F
BoundArgs
.
.
.
>
;
using
Idx
=
absl
:
:
make_index_sequence
<
sizeof
.
.
.
(
BoundArgs
)
+
1
>
;
BoundArgsT
bound_args_
;
public
:
template
<
class
.
.
.
Ts
>
constexpr
explicit
FrontBinder
(
absl
:
:
in_place_t
Ts
&
&
.
.
.
ts
)
:
bound_args_
(
std
:
:
forward
<
Ts
>
(
ts
)
.
.
.
)
{
}
template
<
class
.
.
.
FreeArgs
class
R
=
std
:
:
invoke_result_t
<
F
&
BoundArgs
&
.
.
.
FreeArgs
&
&
.
.
.
>
>
R
operator
(
)
(
FreeArgs
&
&
.
.
.
free_args
)
&
{
return
functional_internal
:
:
Apply
<
R
>
(
bound_args_
Idx
(
)
std
:
:
forward
<
FreeArgs
>
(
free_args
)
.
.
.
)
;
}
template
<
class
.
.
.
FreeArgs
class
R
=
std
:
:
invoke_result_t
<
const
F
&
const
BoundArgs
&
.
.
.
FreeArgs
&
&
.
.
.
>
>
R
operator
(
)
(
FreeArgs
&
&
.
.
.
free_args
)
const
&
{
return
functional_internal
:
:
Apply
<
R
>
(
bound_args_
Idx
(
)
std
:
:
forward
<
FreeArgs
>
(
free_args
)
.
.
.
)
;
}
template
<
class
.
.
.
FreeArgs
class
R
=
std
:
:
invoke_result_t
<
F
&
&
BoundArgs
&
&
.
.
.
FreeArgs
&
&
.
.
.
>
>
R
operator
(
)
(
FreeArgs
&
&
.
.
.
free_args
)
&
&
{
return
functional_internal
:
:
Apply
<
R
>
(
std
:
:
move
(
bound_args_
)
Idx
(
)
std
:
:
forward
<
FreeArgs
>
(
free_args
)
.
.
.
)
;
}
template
<
class
.
.
.
FreeArgs
class
R
=
std
:
:
invoke_result_t
<
const
F
&
&
const
BoundArgs
&
&
.
.
.
FreeArgs
&
&
.
.
.
>
>
R
operator
(
)
(
FreeArgs
&
&
.
.
.
free_args
)
const
&
&
{
return
functional_internal
:
:
Apply
<
R
>
(
std
:
:
move
(
bound_args_
)
Idx
(
)
std
:
:
forward
<
FreeArgs
>
(
free_args
)
.
.
.
)
;
}
}
;
template
<
class
F
class
.
.
.
BoundArgs
>
using
bind_front_t
=
FrontBinder
<
decay_t
<
F
>
absl
:
:
decay_t
<
BoundArgs
>
.
.
.
>
;
}
ABSL_NAMESPACE_END
}
#
endif
