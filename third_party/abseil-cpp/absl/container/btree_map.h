#
ifndef
ABSL_CONTAINER_BTREE_MAP_H_
#
define
ABSL_CONTAINER_BTREE_MAP_H_
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
container
/
internal
/
btree
.
h
"
#
include
"
absl
/
container
/
internal
/
btree_container
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
template
<
typename
Key
typename
Data
typename
Compare
typename
Alloc
int
TargetNodeSize
bool
IsMulti
>
struct
map_params
;
}
template
<
typename
Key
typename
Value
typename
Compare
=
std
:
:
less
<
Key
>
typename
Alloc
=
std
:
:
allocator
<
std
:
:
pair
<
const
Key
Value
>
>
>
class
btree_map
:
public
container_internal
:
:
btree_map_container
<
container_internal
:
:
btree
<
container_internal
:
:
map_params
<
Key
Value
Compare
Alloc
256
false
>
>
>
{
using
Base
=
typename
btree_map
:
:
btree_map_container
;
public
:
btree_map
(
)
{
}
using
Base
:
:
Base
;
using
Base
:
:
begin
;
using
Base
:
:
cbegin
;
using
Base
:
:
end
;
using
Base
:
:
cend
;
using
Base
:
:
empty
;
using
Base
:
:
max_size
;
using
Base
:
:
size
;
using
Base
:
:
clear
;
using
Base
:
:
erase
;
using
Base
:
:
insert
;
using
Base
:
:
insert_or_assign
;
using
Base
:
:
emplace
;
using
Base
:
:
emplace_hint
;
using
Base
:
:
try_emplace
;
using
Base
:
:
extract
;
using
Base
:
:
extract_and_get_next
;
using
Base
:
:
merge
;
using
Base
:
:
swap
;
using
Base
:
:
at
;
using
Base
:
:
contains
;
using
Base
:
:
count
;
using
Base
:
:
equal_range
;
using
Base
:
:
find
;
using
Base
:
:
lower_bound
;
using
Base
:
:
upper_bound
;
using
Base
:
:
operator
[
]
;
using
Base
:
:
get_allocator
;
using
Base
:
:
key_comp
;
using
Base
:
:
value_comp
;
}
;
template
<
typename
K
typename
V
typename
C
typename
A
>
void
swap
(
btree_map
<
K
V
C
A
>
&
x
btree_map
<
K
V
C
A
>
&
y
)
{
return
x
.
swap
(
y
)
;
}
template
<
typename
K
typename
V
typename
C
typename
A
typename
Pred
>
typename
btree_map
<
K
V
C
A
>
:
:
size_type
erase_if
(
btree_map
<
K
V
C
A
>
&
map
Pred
pred
)
{
return
container_internal
:
:
btree_access
:
:
erase_if
(
map
std
:
:
move
(
pred
)
)
;
}
template
<
typename
Key
typename
Value
typename
Compare
=
std
:
:
less
<
Key
>
typename
Alloc
=
std
:
:
allocator
<
std
:
:
pair
<
const
Key
Value
>
>
>
class
btree_multimap
:
public
container_internal
:
:
btree_multimap_container
<
container_internal
:
:
btree
<
container_internal
:
:
map_params
<
Key
Value
Compare
Alloc
256
true
>
>
>
{
using
Base
=
typename
btree_multimap
:
:
btree_multimap_container
;
public
:
btree_multimap
(
)
{
}
using
Base
:
:
Base
;
using
Base
:
:
begin
;
using
Base
:
:
cbegin
;
using
Base
:
:
end
;
using
Base
:
:
cend
;
using
Base
:
:
empty
;
using
Base
:
:
max_size
;
using
Base
:
:
size
;
using
Base
:
:
clear
;
using
Base
:
:
erase
;
using
Base
:
:
insert
;
using
Base
:
:
emplace
;
using
Base
:
:
emplace_hint
;
using
Base
:
:
extract
;
using
Base
:
:
extract_and_get_next
;
using
Base
:
:
merge
;
using
Base
:
:
swap
;
using
Base
:
:
contains
;
using
Base
:
:
count
;
using
Base
:
:
equal_range
;
using
Base
:
:
find
;
using
Base
:
:
lower_bound
;
using
Base
:
:
upper_bound
;
using
Base
:
:
get_allocator
;
using
Base
:
:
key_comp
;
using
Base
:
:
value_comp
;
}
;
template
<
typename
K
typename
V
typename
C
typename
A
>
void
swap
(
btree_multimap
<
K
V
C
A
>
&
x
btree_multimap
<
K
V
C
A
>
&
y
)
{
return
x
.
swap
(
y
)
;
}
template
<
typename
K
typename
V
typename
C
typename
A
typename
Pred
>
typename
btree_multimap
<
K
V
C
A
>
:
:
size_type
erase_if
(
btree_multimap
<
K
V
C
A
>
&
map
Pred
pred
)
{
return
container_internal
:
:
btree_access
:
:
erase_if
(
map
std
:
:
move
(
pred
)
)
;
}
namespace
container_internal
{
template
<
typename
Key
typename
Data
typename
Compare
typename
Alloc
int
TargetNodeSize
bool
IsMulti
>
struct
map_params
:
common_params
<
Key
Compare
Alloc
TargetNodeSize
IsMulti
true
map_slot_policy
<
Key
Data
>
>
{
using
super_type
=
typename
map_params
:
:
common_params
;
using
mapped_type
=
Data
;
using
slot_policy
=
typename
super_type
:
:
slot_policy
;
using
slot_type
=
typename
super_type
:
:
slot_type
;
using
value_type
=
typename
super_type
:
:
value_type
;
using
init_type
=
typename
super_type
:
:
init_type
;
template
<
typename
V
>
static
auto
key
(
const
V
&
value
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
-
>
decltype
(
(
value
.
first
)
)
{
return
value
.
first
;
}
static
const
Key
&
key
(
const
slot_type
*
s
)
{
return
slot_policy
:
:
key
(
s
)
;
}
static
const
Key
&
key
(
slot_type
*
s
)
{
return
slot_policy
:
:
key
(
s
)
;
}
static
auto
mutable_key
(
slot_type
*
s
)
-
>
decltype
(
slot_policy
:
:
mutable_key
(
s
)
)
{
return
slot_policy
:
:
mutable_key
(
s
)
;
}
static
mapped_type
&
value
(
value_type
*
value
)
{
return
value
-
>
second
;
}
}
;
}
ABSL_NAMESPACE_END
}
#
endif
