#
ifndef
ABSL_CONTAINER_INTERNAL_RAW_HASH_MAP_H_
#
define
ABSL_CONTAINER_INTERNAL_RAW_HASH_MAP_H_
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
throw_delegate
.
h
"
#
include
"
absl
/
container
/
internal
/
common_policy_traits
.
h
"
#
include
"
absl
/
container
/
internal
/
container_memory
.
h
"
#
include
"
absl
/
container
/
internal
/
raw_hash_set
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
template
<
class
Policy
class
Hash
class
Eq
class
Alloc
>
class
raw_hash_map
:
public
raw_hash_set
<
Policy
Hash
Eq
Alloc
>
{
template
<
class
P
>
using
MappedReference
=
decltype
(
P
:
:
value
(
std
:
:
addressof
(
std
:
:
declval
<
typename
raw_hash_map
:
:
reference
>
(
)
)
)
)
;
template
<
class
P
>
using
MappedConstReference
=
decltype
(
P
:
:
value
(
std
:
:
addressof
(
std
:
:
declval
<
typename
raw_hash_map
:
:
const_reference
>
(
)
)
)
)
;
template
<
class
K
>
using
key_arg
=
typename
KeyArg
<
IsTransparent
<
Eq
>
:
:
value
&
&
IsTransparent
<
Hash
>
:
:
value
>
:
:
template
type
<
K
typename
Policy
:
:
key_type
>
;
template
<
class
K
bool
Value
typename
=
void
>
using
LifetimeBoundK
=
HasValue
<
Value
std
:
:
conditional_t
<
policy_trait_element_is_owner
<
Policy
>
:
:
value
std
:
:
false_type
type_traits_internal
:
:
IsLifetimeBoundAssignment
<
typename
Policy
:
:
key_type
K
>
>
>
;
template
<
class
V
bool
Value
typename
=
void
>
using
LifetimeBoundV
=
HasValue
<
Value
type_traits_internal
:
:
IsLifetimeBoundAssignment
<
typename
Policy
:
:
mapped_type
V
>
>
;
template
<
class
K
bool
KValue
class
V
bool
VValue
typename
.
.
.
Dummy
>
using
LifetimeBoundKV
=
absl
:
:
conjunction
<
LifetimeBoundK
<
K
KValue
absl
:
:
void_t
<
Dummy
.
.
.
>
>
LifetimeBoundV
<
V
VValue
>
>
;
public
:
using
key_type
=
typename
Policy
:
:
key_type
;
using
mapped_type
=
typename
Policy
:
:
mapped_type
;
static_assert
(
!
std
:
:
is_reference
<
key_type
>
:
:
value
"
"
)
;
static_assert
(
!
std
:
:
is_reference
<
mapped_type
>
:
:
value
"
"
)
;
using
iterator
=
typename
raw_hash_map
:
:
raw_hash_set
:
:
iterator
;
using
const_iterator
=
typename
raw_hash_map
:
:
raw_hash_set
:
:
const_iterator
;
raw_hash_map
(
)
{
}
using
raw_hash_map
:
:
raw_hash_set
:
:
raw_hash_set
;
#
define
ABSL_INTERNAL_X
(
Func
Callee
KQual
VQual
KValue
VValue
Tail
.
.
.
)
\
template
<
\
typename
K
=
key_type
class
V
=
mapped_type
\
ABSL_INTERNAL_IF_
#
#
KValue
#
#
_NOR_
#
#
VValue
(
\
int
=
(
EnableIf
<
LifetimeBoundKV
<
K
KValue
V
VValue
\
IfRRef
<
int
KQual
>
:
:
AddPtr
<
K
>
\
IfRRef
<
int
VQual
>
:
:
AddPtr
<
V
>
>
>
(
)
)
\
ABSL_INTERNAL_SINGLE_ARG
(
\
int
&
.
.
.
\
decltype
(
EnableIf
<
LifetimeBoundKV
<
K
KValue
V
VValue
>
>
(
)
)
=
\
0
)
)
>
\
decltype
(
auto
)
Func
(
\
__VA_ARGS__
key_arg
<
K
>
KQual
k
ABSL_INTERNAL_IF_
#
#
KValue
(
\
ABSL_INTERNAL_ATTRIBUTE_CAPTURED_BY
(
this
)
)
\
V
VQual
v
ABSL_INTERNAL_IF_
#
#
VValue
(
ABSL_INTERNAL_ATTRIBUTE_CAPTURED_BY
(
\
this
)
)
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
\
return
ABSL_INTERNAL_IF_
#
#
KValue
#
#
_OR_
#
#
VValue
(
\
(
this
-
>
template
Func
<
K
V
0
>
)
Callee
)
(
\
std
:
:
forward
<
decltype
(
k
)
>
(
k
)
std
:
:
forward
<
decltype
(
v
)
>
(
v
)
)
Tail
;
\
}
\
static_assert
(
true
"
This
is
to
force
a
semicolon
.
"
)
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
const
&
false
false
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
const
&
false
true
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
const
&
true
false
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
const
&
true
true
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
&
&
false
false
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
&
&
false
true
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
&
&
true
false
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
&
&
true
true
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
const
&
false
false
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
const
&
false
true
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
const
&
true
false
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
const
&
true
true
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
&
&
false
false
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
&
&
false
true
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
&
&
true
false
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
&
&
true
true
ABSL_INTERNAL_SINGLE_ARG
(
)
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
const
&
false
false
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
const
&
false
true
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
const
&
true
false
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
const
&
true
true
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
&
&
false
false
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
&
&
false
true
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
&
&
true
false
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
const
&
&
&
true
true
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
const
&
false
false
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
const
&
false
true
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
const
&
true
false
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
const
&
true
true
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
&
&
false
false
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
&
&
false
true
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
&
&
true
false
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
ABSL_INTERNAL_X
(
insert_or_assign
insert_or_assign_impl
&
&
&
&
true
true
.
first
const_iterator
ABSL_INTERNAL_COMMA
)
;
#
undef
ABSL_INTERNAL_X
template
<
class
K
=
key_type
int
=
EnableIf
<
LifetimeBoundK
<
K
false
K
*
>
>
(
)
class
.
.
.
Args
typename
std
:
:
enable_if
<
!
std
:
:
is_convertible
<
K
const_iterator
>
:
:
value
int
>
:
:
type
=
0
>
std
:
:
pair
<
iterator
bool
>
try_emplace
(
key_arg
<
K
>
&
&
k
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
try_emplace_impl
(
std
:
:
forward
<
K
>
(
k
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
class
K
=
key_type
class
.
.
.
Args
EnableIf
<
LifetimeBoundK
<
K
true
K
*
>
>
=
0
typename
std
:
:
enable_if
<
!
std
:
:
is_convertible
<
K
const_iterator
>
:
:
value
int
>
:
:
type
=
0
>
std
:
:
pair
<
iterator
bool
>
try_emplace
(
key_arg
<
K
>
&
&
k
ABSL_INTERNAL_ATTRIBUTE_CAPTURED_BY
(
this
)
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
this
-
>
template
try_emplace
<
K
0
>
(
std
:
:
forward
<
K
>
(
k
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
class
K
=
key_type
int
=
EnableIf
<
LifetimeBoundK
<
K
false
>
>
(
)
class
.
.
.
Args
typename
std
:
:
enable_if
<
!
std
:
:
is_convertible
<
K
const_iterator
>
:
:
value
int
>
:
:
type
=
0
>
std
:
:
pair
<
iterator
bool
>
try_emplace
(
const
key_arg
<
K
>
&
k
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
try_emplace_impl
(
k
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
class
K
=
key_type
class
.
.
.
Args
EnableIf
<
LifetimeBoundK
<
K
true
>
>
=
0
typename
std
:
:
enable_if
<
!
std
:
:
is_convertible
<
K
const_iterator
>
:
:
value
int
>
:
:
type
=
0
>
std
:
:
pair
<
iterator
bool
>
try_emplace
(
const
key_arg
<
K
>
&
k
ABSL_INTERNAL_ATTRIBUTE_CAPTURED_BY
(
this
)
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
this
-
>
template
try_emplace
<
K
0
>
(
k
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
class
K
=
key_type
int
=
EnableIf
<
LifetimeBoundK
<
K
false
K
*
>
>
(
)
class
.
.
.
Args
>
iterator
try_emplace
(
const_iterator
key_arg
<
K
>
&
&
k
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
try_emplace
(
std
:
:
forward
<
K
>
(
k
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
.
first
;
}
template
<
class
K
=
key_type
class
.
.
.
Args
EnableIf
<
LifetimeBoundK
<
K
true
K
*
>
>
=
0
>
iterator
try_emplace
(
const_iterator
hint
key_arg
<
K
>
&
&
k
ABSL_INTERNAL_ATTRIBUTE_CAPTURED_BY
(
this
)
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
this
-
>
template
try_emplace
<
K
0
>
(
hint
std
:
:
forward
<
K
>
(
k
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
class
K
=
key_type
int
=
EnableIf
<
LifetimeBoundK
<
K
false
>
>
(
)
class
.
.
.
Args
>
iterator
try_emplace
(
const_iterator
const
key_arg
<
K
>
&
k
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
try_emplace
(
k
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
.
first
;
}
template
<
class
K
=
key_type
class
.
.
.
Args
EnableIf
<
LifetimeBoundK
<
K
true
>
>
=
0
>
iterator
try_emplace
(
const_iterator
hint
const
key_arg
<
K
>
&
k
ABSL_INTERNAL_ATTRIBUTE_CAPTURED_BY
(
this
)
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
this
-
>
template
try_emplace
<
K
0
>
(
hint
std
:
:
forward
<
K
>
(
k
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
class
K
=
key_type
class
P
=
Policy
>
MappedReference
<
P
>
at
(
const
key_arg
<
K
>
&
key
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
auto
it
=
this
-
>
find
(
key
)
;
if
(
it
=
=
this
-
>
end
(
)
)
{
base_internal
:
:
ThrowStdOutOfRange
(
"
absl
:
:
container_internal
:
:
raw_hash_map
<
>
:
:
at
"
)
;
}
return
Policy
:
:
value
(
&
*
it
)
;
}
template
<
class
K
=
key_type
class
P
=
Policy
>
MappedConstReference
<
P
>
at
(
const
key_arg
<
K
>
&
key
)
const
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
auto
it
=
this
-
>
find
(
key
)
;
if
(
it
=
=
this
-
>
end
(
)
)
{
base_internal
:
:
ThrowStdOutOfRange
(
"
absl
:
:
container_internal
:
:
raw_hash_map
<
>
:
:
at
"
)
;
}
return
Policy
:
:
value
(
&
*
it
)
;
}
template
<
class
K
=
key_type
class
P
=
Policy
int
=
EnableIf
<
LifetimeBoundK
<
K
false
K
*
>
>
(
)
>
MappedReference
<
P
>
operator
[
]
(
key_arg
<
K
>
&
&
key
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
Policy
:
:
value
(
&
this
-
>
unchecked_deref
(
try_emplace
(
std
:
:
forward
<
K
>
(
key
)
)
.
first
)
)
;
}
template
<
class
K
=
key_type
class
P
=
Policy
int
&
.
.
.
EnableIf
<
LifetimeBoundK
<
K
true
K
*
>
>
=
0
>
MappedReference
<
P
>
operator
[
]
(
key_arg
<
K
>
&
&
key
ABSL_INTERNAL_ATTRIBUTE_CAPTURED_BY
(
this
)
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
this
-
>
template
operator
[
]
<
K
P
0
>
(
std
:
:
forward
<
K
>
(
key
)
)
;
}
template
<
class
K
=
key_type
class
P
=
Policy
int
=
EnableIf
<
LifetimeBoundK
<
K
false
>
>
(
)
>
MappedReference
<
P
>
operator
[
]
(
const
key_arg
<
K
>
&
key
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
Policy
:
:
value
(
&
this
-
>
unchecked_deref
(
try_emplace
(
key
)
.
first
)
)
;
}
template
<
class
K
=
key_type
class
P
=
Policy
int
&
.
.
.
EnableIf
<
LifetimeBoundK
<
K
true
>
>
=
0
>
MappedReference
<
P
>
operator
[
]
(
const
key_arg
<
K
>
&
key
ABSL_INTERNAL_ATTRIBUTE_CAPTURED_BY
(
this
)
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
this
-
>
template
operator
[
]
<
K
P
0
>
(
key
)
;
}
private
:
template
<
class
K
class
V
>
std
:
:
pair
<
iterator
bool
>
insert_or_assign_impl
(
K
&
&
k
V
&
&
v
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
auto
res
=
this
-
>
find_or_prepare_insert
(
k
)
;
if
(
res
.
second
)
{
this
-
>
emplace_at
(
res
.
first
std
:
:
forward
<
K
>
(
k
)
std
:
:
forward
<
V
>
(
v
)
)
;
}
else
{
Policy
:
:
value
(
&
*
res
.
first
)
=
std
:
:
forward
<
V
>
(
v
)
;
}
return
res
;
}
template
<
class
K
=
key_type
class
.
.
.
Args
>
std
:
:
pair
<
iterator
bool
>
try_emplace_impl
(
K
&
&
k
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
auto
res
=
this
-
>
find_or_prepare_insert
(
k
)
;
if
(
res
.
second
)
{
this
-
>
emplace_at
(
res
.
first
std
:
:
piecewise_construct
std
:
:
forward_as_tuple
(
std
:
:
forward
<
K
>
(
k
)
)
std
:
:
forward_as_tuple
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
return
res
;
}
}
;
}
ABSL_NAMESPACE_END
}
#
endif
