#
ifndef
ABSL_CONTAINER_INTERNAL_HASH_FUNCTION_DEFAULTS_H_
#
define
ABSL_CONTAINER_INTERNAL_HASH_FUNCTION_DEFAULTS_H_
#
include
<
cstddef
>
#
include
<
functional
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
container
/
internal
/
common
.
h
"
#
include
"
absl
/
hash
/
hash
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
strings
/
cord
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
ifdef
ABSL_HAVE_STD_STRING_VIEW
#
include
<
string_view
>
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
template
<
class
T
class
E
=
void
>
struct
HashEq
{
using
Hash
=
absl
:
:
Hash
<
T
>
;
using
Eq
=
std
:
:
equal_to
<
T
>
;
}
;
struct
StringHash
{
using
is_transparent
=
void
;
size_t
operator
(
)
(
absl
:
:
string_view
v
)
const
{
return
absl
:
:
Hash
<
absl
:
:
string_view
>
{
}
(
v
)
;
}
size_t
operator
(
)
(
const
absl
:
:
Cord
&
v
)
const
{
return
absl
:
:
Hash
<
absl
:
:
Cord
>
{
}
(
v
)
;
}
}
;
struct
StringEq
{
using
is_transparent
=
void
;
bool
operator
(
)
(
absl
:
:
string_view
lhs
absl
:
:
string_view
rhs
)
const
{
return
lhs
=
=
rhs
;
}
bool
operator
(
)
(
const
absl
:
:
Cord
&
lhs
const
absl
:
:
Cord
&
rhs
)
const
{
return
lhs
=
=
rhs
;
}
bool
operator
(
)
(
const
absl
:
:
Cord
&
lhs
absl
:
:
string_view
rhs
)
const
{
return
lhs
=
=
rhs
;
}
bool
operator
(
)
(
absl
:
:
string_view
lhs
const
absl
:
:
Cord
&
rhs
)
const
{
return
lhs
=
=
rhs
;
}
}
;
struct
StringHashEq
{
using
Hash
=
StringHash
;
using
Eq
=
StringEq
;
}
;
template
<
>
struct
HashEq
<
std
:
:
string
>
:
StringHashEq
{
}
;
template
<
>
struct
HashEq
<
absl
:
:
string_view
>
:
StringHashEq
{
}
;
template
<
>
struct
HashEq
<
absl
:
:
Cord
>
:
StringHashEq
{
}
;
#
ifdef
ABSL_HAVE_STD_STRING_VIEW
template
<
typename
TChar
>
struct
BasicStringHash
{
using
is_transparent
=
void
;
size_t
operator
(
)
(
std
:
:
basic_string_view
<
TChar
>
v
)
const
{
return
absl
:
:
Hash
<
std
:
:
basic_string_view
<
TChar
>
>
{
}
(
v
)
;
}
}
;
template
<
typename
TChar
>
struct
BasicStringEq
{
using
is_transparent
=
void
;
bool
operator
(
)
(
std
:
:
basic_string_view
<
TChar
>
lhs
std
:
:
basic_string_view
<
TChar
>
rhs
)
const
{
return
lhs
=
=
rhs
;
}
}
;
template
<
typename
TChar
>
struct
BasicStringHashEq
{
using
Hash
=
BasicStringHash
<
TChar
>
;
using
Eq
=
BasicStringEq
<
TChar
>
;
}
;
template
<
>
struct
HashEq
<
std
:
:
wstring
>
:
BasicStringHashEq
<
wchar_t
>
{
}
;
template
<
>
struct
HashEq
<
std
:
:
wstring_view
>
:
BasicStringHashEq
<
wchar_t
>
{
}
;
template
<
>
struct
HashEq
<
std
:
:
u16string
>
:
BasicStringHashEq
<
char16_t
>
{
}
;
template
<
>
struct
HashEq
<
std
:
:
u16string_view
>
:
BasicStringHashEq
<
char16_t
>
{
}
;
template
<
>
struct
HashEq
<
std
:
:
u32string
>
:
BasicStringHashEq
<
char32_t
>
{
}
;
template
<
>
struct
HashEq
<
std
:
:
u32string_view
>
:
BasicStringHashEq
<
char32_t
>
{
}
;
#
endif
template
<
class
T
>
struct
HashEq
<
T
*
>
{
struct
Hash
{
using
is_transparent
=
void
;
template
<
class
U
>
size_t
operator
(
)
(
const
U
&
ptr
)
const
{
return
absl
:
:
Hash
<
const
T
*
>
{
}
(
HashEq
:
:
ToPtr
(
ptr
)
)
;
}
}
;
struct
Eq
{
using
is_transparent
=
void
;
template
<
class
A
class
B
>
bool
operator
(
)
(
const
A
&
a
const
B
&
b
)
const
{
return
HashEq
:
:
ToPtr
(
a
)
=
=
HashEq
:
:
ToPtr
(
b
)
;
}
}
;
private
:
static
const
T
*
ToPtr
(
const
T
*
ptr
)
{
return
ptr
;
}
template
<
class
U
class
D
>
static
const
T
*
ToPtr
(
const
std
:
:
unique_ptr
<
U
D
>
&
ptr
)
{
return
ptr
.
get
(
)
;
}
template
<
class
U
>
static
const
T
*
ToPtr
(
const
std
:
:
shared_ptr
<
U
>
&
ptr
)
{
return
ptr
.
get
(
)
;
}
}
;
template
<
class
T
class
D
>
struct
HashEq
<
std
:
:
unique_ptr
<
T
D
>
>
:
HashEq
<
T
*
>
{
}
;
template
<
class
T
>
struct
HashEq
<
std
:
:
shared_ptr
<
T
>
>
:
HashEq
<
T
*
>
{
}
;
template
<
typename
T
typename
E
=
void
>
struct
HasAbslContainerHash
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
HasAbslContainerHash
<
T
absl
:
:
void_t
<
typename
T
:
:
absl_container_hash
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
typename
E
=
void
>
struct
HasAbslContainerEq
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
HasAbslContainerEq
<
T
absl
:
:
void_t
<
typename
T
:
:
absl_container_eq
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
typename
E
=
void
>
struct
AbslContainerEq
{
using
type
=
std
:
:
equal_to
<
>
;
}
;
template
<
typename
T
>
struct
AbslContainerEq
<
T
typename
std
:
:
enable_if_t
<
HasAbslContainerEq
<
T
>
:
:
value
>
>
{
using
type
=
typename
T
:
:
absl_container_eq
;
}
;
template
<
typename
T
typename
E
=
void
>
struct
AbslContainerHash
{
using
type
=
void
;
}
;
template
<
typename
T
>
struct
AbslContainerHash
<
T
typename
std
:
:
enable_if_t
<
HasAbslContainerHash
<
T
>
:
:
value
>
>
{
using
type
=
typename
T
:
:
absl_container_hash
;
}
;
template
<
typename
T
>
struct
HashEq
<
T
typename
std
:
:
enable_if_t
<
HasAbslContainerHash
<
T
>
:
:
value
>
>
{
using
Hash
=
typename
AbslContainerHash
<
T
>
:
:
type
;
using
Eq
=
typename
AbslContainerEq
<
T
>
:
:
type
;
static_assert
(
IsTransparent
<
Hash
>
:
:
value
"
absl_container_hash
must
be
transparent
.
To
achieve
it
add
a
"
"
using
is_transparent
=
void
;
clause
to
this
type
.
"
)
;
static_assert
(
IsTransparent
<
Eq
>
:
:
value
"
absl_container_eq
must
be
transparent
.
To
achieve
it
add
a
"
"
using
is_transparent
=
void
;
clause
to
this
type
.
"
)
;
}
;
template
<
class
T
>
using
hash_default_hash
=
typename
container_internal
:
:
HashEq
<
T
>
:
:
Hash
;
template
<
class
T
>
using
hash_default_eq
=
typename
container_internal
:
:
HashEq
<
T
>
:
:
Eq
;
}
ABSL_NAMESPACE_END
}
#
endif
