#
ifndef
ABSL_CONTAINER_INTERNAL_HASHTABLE_DEBUG_H_
#
define
ABSL_CONTAINER_INTERNAL_HASHTABLE_DEBUG_H_
#
include
<
cstddef
>
#
include
<
algorithm
>
#
include
<
type_traits
>
#
include
<
vector
>
#
include
"
absl
/
container
/
internal
/
hashtable_debug_hooks
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
template
<
typename
C
>
size_t
GetHashtableDebugNumProbes
(
const
C
&
c
const
typename
C
:
:
key_type
&
key
)
{
return
absl
:
:
container_internal
:
:
hashtable_debug_internal
:
:
HashtableDebugAccess
<
C
>
:
:
GetNumProbes
(
c
key
)
;
}
template
<
typename
C
>
std
:
:
vector
<
size_t
>
GetHashtableDebugNumProbesHistogram
(
const
C
&
container
)
{
std
:
:
vector
<
size_t
>
v
;
for
(
auto
it
=
container
.
begin
(
)
;
it
!
=
container
.
end
(
)
;
+
+
it
)
{
size_t
num_probes
=
GetHashtableDebugNumProbes
(
container
absl
:
:
container_internal
:
:
hashtable_debug_internal
:
:
GetKey
<
C
>
(
*
it
0
)
)
;
v
.
resize
(
(
std
:
:
max
)
(
v
.
size
(
)
num_probes
+
1
)
)
;
v
[
num_probes
]
+
+
;
}
return
v
;
}
struct
HashtableDebugProbeSummary
{
size_t
total_elements
;
size_t
total_num_probes
;
double
mean
;
}
;
template
<
typename
C
>
HashtableDebugProbeSummary
GetHashtableDebugProbeSummary
(
const
C
&
container
)
{
auto
probes
=
GetHashtableDebugNumProbesHistogram
(
container
)
;
HashtableDebugProbeSummary
summary
=
{
}
;
for
(
size_t
i
=
0
;
i
<
probes
.
size
(
)
;
+
+
i
)
{
summary
.
total_elements
+
=
probes
[
i
]
;
summary
.
total_num_probes
+
=
probes
[
i
]
*
i
;
}
summary
.
mean
=
1
.
0
*
summary
.
total_num_probes
/
summary
.
total_elements
;
return
summary
;
}
template
<
typename
C
>
size_t
AllocatedByteSize
(
const
C
&
c
)
{
return
absl
:
:
container_internal
:
:
hashtable_debug_internal
:
:
HashtableDebugAccess
<
C
>
:
:
AllocatedByteSize
(
c
)
;
}
}
ABSL_NAMESPACE_END
}
#
endif
