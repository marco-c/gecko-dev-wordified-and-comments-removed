#
include
<
cstddef
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
container
/
flat_hash_map
.
h
"
#
include
"
absl
/
container
/
flat_hash_set
.
h
"
#
include
"
absl
/
container
/
internal
/
hashtablez_sampler
.
h
"
#
include
"
absl
/
container
/
node_hash_map
.
h
"
#
include
"
absl
/
container
/
node_hash_set
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
namespace
{
#
if
defined
(
ABSL_INTERNAL_HASHTABLEZ_SAMPLE
)
template
<
class
Table
>
void
TestInlineElementSize
(
HashtablezSampler
&
sampler
std
:
:
unordered_set
<
const
HashtablezInfo
*
>
&
preexisting_info
std
:
:
vector
<
Table
>
&
tables
const
std
:
:
vector
<
typename
Table
:
:
value_type
>
&
values
size_t
expected_element_size
)
{
EXPECT_GT
(
values
.
size
(
)
0
)
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
tables
.
emplace_back
(
)
;
tables
.
back
(
)
.
insert
(
values
.
begin
(
)
values
.
end
(
)
)
;
}
size_t
new_count
=
0
;
sampler
.
Iterate
(
[
&
]
(
const
HashtablezInfo
&
info
)
{
if
(
preexisting_info
.
insert
(
&
info
)
.
second
)
{
EXPECT_EQ
(
info
.
inline_element_size
expected_element_size
)
;
+
+
new_count
;
}
}
)
;
EXPECT_GT
(
new_count
0
)
;
}
struct
bigstruct
{
char
a
[
1000
]
;
friend
bool
operator
=
=
(
const
bigstruct
&
x
const
bigstruct
&
y
)
{
return
memcmp
(
x
.
a
y
.
a
sizeof
(
x
.
a
)
)
=
=
0
;
}
template
<
typename
H
>
friend
H
AbslHashValue
(
H
h
const
bigstruct
&
c
)
{
return
H
:
:
combine_contiguous
(
std
:
:
move
(
h
)
c
.
a
sizeof
(
c
.
a
)
)
;
}
}
;
#
endif
TEST
(
FlatHashMap
SampleElementSize
)
{
#
if
defined
(
ABSL_INTERNAL_HASHTABLEZ_SAMPLE
)
SetHashtablezEnabled
(
true
)
;
SetHashtablezSampleParameter
(
1
)
;
TestOnlyRefreshSamplingStateForCurrentThread
(
)
;
auto
&
sampler
=
GlobalHashtablezSampler
(
)
;
std
:
:
vector
<
flat_hash_map
<
int
bigstruct
>
>
flat_map_tables
;
std
:
:
vector
<
flat_hash_set
<
bigstruct
>
>
flat_set_tables
;
std
:
:
vector
<
node_hash_map
<
int
bigstruct
>
>
node_map_tables
;
std
:
:
vector
<
node_hash_set
<
bigstruct
>
>
node_set_tables
;
std
:
:
vector
<
bigstruct
>
set_values
=
{
bigstruct
{
{
0
}
}
bigstruct
{
{
1
}
}
}
;
std
:
:
vector
<
std
:
:
pair
<
const
int
bigstruct
>
>
map_values
=
{
{
0
bigstruct
{
}
}
{
1
bigstruct
{
}
}
}
;
std
:
:
unordered_set
<
const
HashtablezInfo
*
>
preexisting_info
;
sampler
.
Iterate
(
[
&
]
(
const
HashtablezInfo
&
info
)
{
preexisting_info
.
insert
(
&
info
)
;
}
)
;
TestInlineElementSize
(
sampler
preexisting_info
flat_map_tables
map_values
sizeof
(
int
)
+
sizeof
(
bigstruct
)
)
;
TestInlineElementSize
(
sampler
preexisting_info
node_map_tables
map_values
sizeof
(
void
*
)
)
;
TestInlineElementSize
(
sampler
preexisting_info
flat_set_tables
set_values
sizeof
(
bigstruct
)
)
;
TestInlineElementSize
(
sampler
preexisting_info
node_set_tables
set_values
sizeof
(
void
*
)
)
;
#
endif
}
}
}
ABSL_NAMESPACE_END
}
