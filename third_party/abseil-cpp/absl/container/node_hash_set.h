#
ifndef
ABSL_CONTAINER_NODE_HASH_SET_H_
#
define
ABSL_CONTAINER_NODE_HASH_SET_H_
#
include
<
cstddef
>
#
include
<
type_traits
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
container
/
internal
/
container_memory
.
h
"
#
include
"
absl
/
container
/
internal
/
hash_function_defaults
.
h
"
#
include
"
absl
/
container
/
internal
/
node_slot_policy
.
h
"
#
include
"
absl
/
container
/
internal
/
raw_hash_set
.
h
"
#
include
"
absl
/
memory
/
memory
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
template
<
typename
T
>
struct
NodeHashSetPolicy
;
}
template
<
class
T
class
Hash
=
absl
:
:
container_internal
:
:
hash_default_hash
<
T
>
class
Eq
=
absl
:
:
container_internal
:
:
hash_default_eq
<
T
>
class
Alloc
=
std
:
:
allocator
<
T
>
>
class
node_hash_set
:
public
absl
:
:
container_internal
:
:
raw_hash_set
<
absl
:
:
container_internal
:
:
NodeHashSetPolicy
<
T
>
Hash
Eq
Alloc
>
{
using
Base
=
typename
node_hash_set
:
:
raw_hash_set
;
public
:
node_hash_set
(
)
{
}
using
Base
:
:
Base
;
using
Base
:
:
begin
;
using
Base
:
:
cbegin
;
using
Base
:
:
cend
;
using
Base
:
:
end
;
using
Base
:
:
capacity
;
using
Base
:
:
empty
;
using
Base
:
:
max_size
;
using
Base
:
:
size
;
using
Base
:
:
clear
;
using
Base
:
:
erase
;
using
Base
:
:
insert
;
using
Base
:
:
emplace
;
using
Base
:
:
emplace_hint
;
using
Base
:
:
extract
;
using
Base
:
:
merge
;
using
Base
:
:
swap
;
using
Base
:
:
rehash
;
using
Base
:
:
reserve
;
using
Base
:
:
contains
;
using
Base
:
:
count
;
using
Base
:
:
equal_range
;
using
Base
:
:
find
;
using
Base
:
:
bucket_count
;
using
Base
:
:
load_factor
;
using
Base
:
:
max_load_factor
;
using
Base
:
:
get_allocator
;
using
Base
:
:
hash_function
;
using
Base
:
:
key_eq
;
}
;
template
<
typename
T
typename
H
typename
E
typename
A
typename
Predicate
>
typename
node_hash_set
<
T
H
E
A
>
:
:
size_type
erase_if
(
node_hash_set
<
T
H
E
A
>
&
c
Predicate
pred
)
{
return
container_internal
:
:
EraseIf
(
pred
&
c
)
;
}
namespace
container_internal
{
template
<
class
T
>
struct
NodeHashSetPolicy
:
absl
:
:
container_internal
:
:
node_slot_policy
<
T
&
NodeHashSetPolicy
<
T
>
>
{
using
key_type
=
T
;
using
init_type
=
T
;
using
constant_iterators
=
std
:
:
true_type
;
template
<
class
Allocator
class
.
.
.
Args
>
static
T
*
new_element
(
Allocator
*
alloc
Args
&
&
.
.
.
args
)
{
using
ValueAlloc
=
typename
absl
:
:
allocator_traits
<
Allocator
>
:
:
template
rebind_alloc
<
T
>
;
ValueAlloc
value_alloc
(
*
alloc
)
;
T
*
res
=
absl
:
:
allocator_traits
<
ValueAlloc
>
:
:
allocate
(
value_alloc
1
)
;
absl
:
:
allocator_traits
<
ValueAlloc
>
:
:
construct
(
value_alloc
res
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
return
res
;
}
template
<
class
Allocator
>
static
void
delete_element
(
Allocator
*
alloc
T
*
elem
)
{
using
ValueAlloc
=
typename
absl
:
:
allocator_traits
<
Allocator
>
:
:
template
rebind_alloc
<
T
>
;
ValueAlloc
value_alloc
(
*
alloc
)
;
absl
:
:
allocator_traits
<
ValueAlloc
>
:
:
destroy
(
value_alloc
elem
)
;
absl
:
:
allocator_traits
<
ValueAlloc
>
:
:
deallocate
(
value_alloc
elem
1
)
;
}
template
<
class
F
class
.
.
.
Args
>
static
decltype
(
absl
:
:
container_internal
:
:
DecomposeValue
(
std
:
:
declval
<
F
>
(
)
std
:
:
declval
<
Args
>
(
)
.
.
.
)
)
apply
(
F
&
&
f
Args
&
&
.
.
.
args
)
{
return
absl
:
:
container_internal
:
:
DecomposeValue
(
std
:
:
forward
<
F
>
(
f
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
static
size_t
element_space_used
(
const
T
*
)
{
return
sizeof
(
T
)
;
}
template
<
class
Hash
>
static
constexpr
HashSlotFn
get_hash_slot_fn
(
)
{
return
&
TypeErasedDerefAndApplyToSlotFn
<
Hash
T
>
;
}
}
;
}
namespace
container_algorithm_internal
{
template
<
class
Key
class
Hash
class
KeyEqual
class
Allocator
>
struct
IsUnorderedContainer
<
absl
:
:
node_hash_set
<
Key
Hash
KeyEqual
Allocator
>
>
:
std
:
:
true_type
{
}
;
}
ABSL_NAMESPACE_END
}
#
endif
