#
ifndef
ABSL_META_TYPE_TRAITS_H_
#
define
ABSL_META_TYPE_TRAITS_H_
#
include
<
cstddef
>
#
include
<
functional
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
vector
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
ifdef
__cpp_lib_span
#
include
<
span
>
#
endif
#
ifdef
ABSL_HAVE_STD_STRING_VIEW
#
include
<
string_view
>
#
endif
#
if
defined
(
__STDCPP_DEFAULT_NEW_ALIGNMENT__
)
#
define
ABSL_INTERNAL_DEFAULT_NEW_ALIGNMENT
__STDCPP_DEFAULT_NEW_ALIGNMENT__
#
else
#
define
ABSL_INTERNAL_DEFAULT_NEW_ALIGNMENT
alignof
(
std
:
:
max_align_t
)
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
type_traits_internal
{
template
<
typename
.
.
.
Ts
>
struct
VoidTImpl
{
using
type
=
void
;
}
;
template
<
class
Enabler
template
<
class
.
.
.
>
class
Op
class
.
.
.
Args
>
struct
is_detected_impl
{
using
type
=
std
:
:
false_type
;
}
;
template
<
template
<
class
.
.
.
>
class
Op
class
.
.
.
Args
>
struct
is_detected_impl
<
typename
VoidTImpl
<
Op
<
Args
.
.
.
>
>
:
:
type
Op
Args
.
.
.
>
{
using
type
=
std
:
:
true_type
;
}
;
template
<
template
<
class
.
.
.
>
class
Op
class
.
.
.
Args
>
struct
is_detected
:
is_detected_impl
<
void
Op
Args
.
.
.
>
:
:
type
{
}
;
}
template
<
typename
.
.
.
Ts
>
using
void_t
=
typename
type_traits_internal
:
:
VoidTImpl
<
Ts
.
.
.
>
:
:
type
;
using
std
:
:
add_const_t
;
using
std
:
:
add_cv_t
;
using
std
:
:
add_lvalue_reference_t
;
using
std
:
:
add_pointer_t
;
using
std
:
:
add_rvalue_reference_t
;
using
std
:
:
add_volatile_t
;
using
std
:
:
common_type_t
;
using
std
:
:
conditional_t
;
using
std
:
:
conjunction
;
using
std
:
:
decay_t
;
using
std
:
:
enable_if_t
;
using
std
:
:
disjunction
;
using
std
:
:
is_copy_assignable
;
using
std
:
:
is_function
;
using
std
:
:
is_move_assignable
;
using
std
:
:
is_trivially_copy_assignable
;
using
std
:
:
is_trivially_copy_constructible
;
using
std
:
:
is_trivially_default_constructible
;
using
std
:
:
is_trivially_destructible
;
using
std
:
:
is_trivially_move_assignable
;
using
std
:
:
is_trivially_move_constructible
;
using
std
:
:
make_signed_t
;
using
std
:
:
make_unsigned_t
;
using
std
:
:
negation
;
using
std
:
:
remove_all_extents_t
;
using
std
:
:
remove_const_t
;
using
std
:
:
remove_cv_t
;
using
std
:
:
remove_extent_t
;
using
std
:
:
remove_pointer_t
;
using
std
:
:
remove_reference_t
;
using
std
:
:
remove_volatile_t
;
using
std
:
:
underlying_type_t
;
#
if
defined
(
__cpp_lib_remove_cvref
)
&
&
__cpp_lib_remove_cvref
>
=
201711L
template
<
typename
T
>
using
remove_cvref
=
std
:
:
remove_cvref
<
T
>
;
template
<
typename
T
>
using
remove_cvref_t
=
typename
std
:
:
remove_cvref
<
T
>
:
:
type
;
#
else
template
<
typename
T
>
struct
remove_cvref
{
using
type
=
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
T
>
:
:
type
>
:
:
type
;
}
;
template
<
typename
T
>
using
remove_cvref_t
=
typename
remove_cvref
<
T
>
:
:
type
;
#
endif
namespace
type_traits_internal
{
#
if
(
defined
(
__cpp_lib_is_invocable
)
&
&
__cpp_lib_is_invocable
>
=
201703L
)
|
|
\
(
defined
(
_MSVC_LANG
)
&
&
_MSVC_LANG
>
=
201703L
)
template
<
typename
>
struct
result_of
;
template
<
typename
F
typename
.
.
.
Args
>
struct
result_of
<
F
(
Args
.
.
.
)
>
:
std
:
:
invoke_result
<
F
Args
.
.
.
>
{
}
;
#
else
template
<
typename
F
>
using
result_of
=
std
:
:
result_of
<
F
>
;
#
endif
}
template
<
typename
F
>
using
result_of_t
=
typename
type_traits_internal
:
:
result_of
<
F
>
:
:
type
;
namespace
type_traits_internal
{
#
if
defined
(
_MSC_VER
)
|
|
(
defined
(
_LIBCPP_VERSION
)
&
&
\
_LIBCPP_VERSION
<
4000
&
&
_LIBCPP_STD_VER
>
11
)
#
define
ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
0
#
else
#
define
ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
1
#
endif
#
if
!
ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
template
<
typename
Key
typename
=
size_t
>
struct
IsHashable
:
std
:
:
true_type
{
}
;
#
else
template
<
typename
Key
typename
=
void
>
struct
IsHashable
:
std
:
:
false_type
{
}
;
template
<
typename
Key
>
struct
IsHashable
<
Key
absl
:
:
enable_if_t
<
std
:
:
is_convertible
<
decltype
(
std
:
:
declval
<
std
:
:
hash
<
Key
>
&
>
(
)
(
std
:
:
declval
<
Key
const
&
>
(
)
)
)
std
:
:
size_t
>
:
:
value
>
>
:
std
:
:
true_type
{
}
;
#
endif
struct
AssertHashEnabledHelper
{
private
:
static
void
Sink
(
.
.
.
)
{
}
struct
NAT
{
}
;
template
<
class
Key
>
static
auto
GetReturnType
(
int
)
-
>
decltype
(
std
:
:
declval
<
std
:
:
hash
<
Key
>
>
(
)
(
std
:
:
declval
<
Key
const
&
>
(
)
)
)
;
template
<
class
Key
>
static
NAT
GetReturnType
(
.
.
.
)
;
template
<
class
Key
>
static
std
:
:
nullptr_t
DoIt
(
)
{
static_assert
(
IsHashable
<
Key
>
:
:
value
"
std
:
:
hash
<
Key
>
does
not
provide
a
call
operator
"
)
;
static_assert
(
std
:
:
is_default_constructible
<
std
:
:
hash
<
Key
>
>
:
:
value
"
std
:
:
hash
<
Key
>
must
be
default
constructible
when
it
is
enabled
"
)
;
static_assert
(
std
:
:
is_copy_constructible
<
std
:
:
hash
<
Key
>
>
:
:
value
"
std
:
:
hash
<
Key
>
must
be
copy
constructible
when
it
is
enabled
"
)
;
static_assert
(
absl
:
:
is_copy_assignable
<
std
:
:
hash
<
Key
>
>
:
:
value
"
std
:
:
hash
<
Key
>
must
be
copy
assignable
when
it
is
enabled
"
)
;
using
ReturnType
=
decltype
(
GetReturnType
<
Key
>
(
0
)
)
;
static_assert
(
std
:
:
is_same
<
ReturnType
NAT
>
:
:
value
|
|
std
:
:
is_same
<
ReturnType
size_t
>
:
:
value
"
std
:
:
hash
<
Key
>
must
return
size_t
"
)
;
return
nullptr
;
}
template
<
class
.
.
.
Ts
>
friend
void
AssertHashEnabled
(
)
;
}
;
template
<
class
.
.
.
Ts
>
inline
void
AssertHashEnabled
(
)
{
using
Helper
=
AssertHashEnabledHelper
;
Helper
:
:
Sink
(
Helper
:
:
DoIt
<
Ts
>
(
)
.
.
.
)
;
}
}
namespace
swap_internal
{
using
std
:
:
swap
;
void
swap
(
)
;
template
<
class
T
>
using
IsSwappableImpl
=
decltype
(
swap
(
std
:
:
declval
<
T
&
>
(
)
std
:
:
declval
<
T
&
>
(
)
)
)
;
template
<
class
T
class
IsNoexcept
=
std
:
:
integral_constant
<
bool
noexcept
(
swap
(
std
:
:
declval
<
T
&
>
(
)
std
:
:
declval
<
T
&
>
(
)
)
)
>
>
using
IsNothrowSwappableImpl
=
typename
std
:
:
enable_if
<
IsNoexcept
:
:
value
>
:
:
type
;
template
<
class
T
>
struct
IsSwappable
:
absl
:
:
type_traits_internal
:
:
is_detected
<
IsSwappableImpl
T
>
{
}
;
template
<
class
T
>
struct
IsNothrowSwappable
:
absl
:
:
type_traits_internal
:
:
is_detected
<
IsNothrowSwappableImpl
T
>
{
}
;
template
<
class
T
absl
:
:
enable_if_t
<
IsSwappable
<
T
>
:
:
value
int
>
=
0
>
void
Swap
(
T
&
lhs
T
&
rhs
)
noexcept
(
IsNothrowSwappable
<
T
>
:
:
value
)
{
swap
(
lhs
rhs
)
;
}
using
StdSwapIsUnconstrained
=
IsSwappable
<
void
(
)
>
;
}
namespace
type_traits_internal
{
using
swap_internal
:
:
IsNothrowSwappable
;
using
swap_internal
:
:
IsSwappable
;
using
swap_internal
:
:
StdSwapIsUnconstrained
;
using
swap_internal
:
:
Swap
;
}
#
if
ABSL_HAVE_BUILTIN
(
__is_trivially_relocatable
)
&
&
\
(
defined
(
__cpp_impl_trivially_relocatable
)
|
|
\
(
!
defined
(
__clang__
)
&
&
!
defined
(
__APPLE__
)
&
&
!
defined
(
__NVCC__
)
)
)
template
<
class
T
>
struct
is_trivially_relocatable
:
std
:
:
integral_constant
<
bool
__is_trivially_relocatable
(
T
)
>
{
}
;
#
elif
ABSL_HAVE_BUILTIN
(
__is_trivially_relocatable
)
&
&
defined
(
__clang__
)
&
&
\
!
(
defined
(
_WIN32
)
|
|
defined
(
_WIN64
)
)
&
&
!
defined
(
__APPLE__
)
&
&
\
!
defined
(
__NVCC__
)
template
<
class
T
>
struct
is_trivially_relocatable
:
std
:
:
integral_constant
<
bool
std
:
:
is_trivially_copyable
<
T
>
:
:
value
|
|
(
__is_trivially_relocatable
(
T
)
&
&
std
:
:
is_trivially_move_assignable
<
T
>
:
:
value
)
>
{
}
;
#
else
template
<
class
T
>
struct
is_trivially_relocatable
:
std
:
:
is_trivially_copyable
<
T
>
{
}
;
#
endif
#
if
defined
(
ABSL_HAVE_CONSTANT_EVALUATED
)
constexpr
bool
is_constant_evaluated
(
)
noexcept
{
#
ifdef
__cpp_lib_is_constant_evaluated
return
std
:
:
is_constant_evaluated
(
)
;
#
elif
ABSL_HAVE_BUILTIN
(
__builtin_is_constant_evaluated
)
return
__builtin_is_constant_evaluated
(
)
;
#
endif
}
#
endif
namespace
type_traits_internal
{
template
<
typename
T
typename
=
void
>
struct
IsOwnerImpl
:
std
:
:
false_type
{
static_assert
(
std
:
:
is_same
<
T
absl
:
:
remove_cvref_t
<
T
>
>
:
:
value
"
type
must
lack
qualifiers
"
)
;
}
;
template
<
typename
T
>
struct
IsOwnerImpl
<
T
std
:
:
enable_if_t
<
std
:
:
is_class
<
typename
T
:
:
absl_internal_is_view
>
:
:
value
>
>
:
absl
:
:
negation
<
typename
T
:
:
absl_internal_is_view
>
{
}
;
template
<
typename
T
>
struct
IsOwner
:
IsOwnerImpl
<
T
>
{
}
;
template
<
typename
T
typename
Traits
typename
Alloc
>
struct
IsOwner
<
std
:
:
basic_string
<
T
Traits
Alloc
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
typename
Alloc
>
struct
IsOwner
<
std
:
:
vector
<
T
Alloc
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
typename
=
void
>
struct
IsViewImpl
:
std
:
:
false_type
{
static_assert
(
std
:
:
is_same
<
T
absl
:
:
remove_cvref_t
<
T
>
>
:
:
value
"
type
must
lack
qualifiers
"
)
;
}
;
template
<
typename
T
>
struct
IsViewImpl
<
T
std
:
:
enable_if_t
<
std
:
:
is_class
<
typename
T
:
:
absl_internal_is_view
>
:
:
value
>
>
:
T
:
:
absl_internal_is_view
{
}
;
template
<
typename
T
>
struct
IsView
:
std
:
:
integral_constant
<
bool
std
:
:
is_pointer
<
T
>
:
:
value
|
|
IsViewImpl
<
T
>
:
:
value
>
{
}
;
#
ifdef
ABSL_HAVE_STD_STRING_VIEW
template
<
typename
Char
typename
Traits
>
struct
IsView
<
std
:
:
basic_string_view
<
Char
Traits
>
>
:
std
:
:
true_type
{
}
;
#
endif
#
ifdef
__cpp_lib_span
template
<
typename
T
>
struct
IsView
<
std
:
:
span
<
T
>
>
:
std
:
:
true_type
{
}
;
#
endif
template
<
typename
T
typename
U
>
using
IsLifetimeBoundAssignment
=
absl
:
:
conjunction
<
std
:
:
integral_constant
<
bool
!
std
:
:
is_lvalue_reference
<
U
>
:
:
value
>
IsOwner
<
absl
:
:
remove_cvref_t
<
U
>
>
IsView
<
absl
:
:
remove_cvref_t
<
T
>
>
>
;
}
ABSL_NAMESPACE_END
}
#
endif
