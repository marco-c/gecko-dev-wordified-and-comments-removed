#
include
"
threading
.
h
"
int
g_ZSTD_threading_useless_symbol
;
#
if
defined
(
ZSTD_MULTITHREAD
)
&
&
defined
(
_WIN32
)
#
include
<
process
.
h
>
#
include
<
errno
.
h
>
typedef
struct
{
void
*
(
*
start_routine
)
(
void
*
)
;
void
*
arg
;
int
initialized
;
ZSTD_pthread_cond_t
initialized_cond
;
ZSTD_pthread_mutex_t
initialized_mutex
;
}
ZSTD_thread_params_t
;
static
unsigned
__stdcall
worker
(
void
*
arg
)
{
void
*
(
*
start_routine
)
(
void
*
)
;
void
*
thread_arg
;
{
ZSTD_thread_params_t
*
thread_param
=
(
ZSTD_thread_params_t
*
)
arg
;
thread_arg
=
thread_param
-
>
arg
;
start_routine
=
thread_param
-
>
start_routine
;
ZSTD_pthread_mutex_lock
(
&
thread_param
-
>
initialized_mutex
)
;
thread_param
-
>
initialized
=
1
;
ZSTD_pthread_cond_signal
(
&
thread_param
-
>
initialized_cond
)
;
ZSTD_pthread_mutex_unlock
(
&
thread_param
-
>
initialized_mutex
)
;
}
start_routine
(
thread_arg
)
;
return
0
;
}
int
ZSTD_pthread_create
(
ZSTD_pthread_t
*
thread
const
void
*
unused
void
*
(
*
start_routine
)
(
void
*
)
void
*
arg
)
{
ZSTD_thread_params_t
thread_param
;
(
void
)
unused
;
if
(
thread
=
=
NULL
)
return
-
1
;
*
thread
=
NULL
;
thread_param
.
start_routine
=
start_routine
;
thread_param
.
arg
=
arg
;
thread_param
.
initialized
=
0
;
if
(
ZSTD_pthread_cond_init
(
&
thread_param
.
initialized_cond
NULL
)
)
{
return
-
1
;
}
if
(
ZSTD_pthread_mutex_init
(
&
thread_param
.
initialized_mutex
NULL
)
)
{
ZSTD_pthread_cond_destroy
(
&
thread_param
.
initialized_cond
)
;
return
-
1
;
}
*
thread
=
(
HANDLE
)
_beginthreadex
(
NULL
0
worker
&
thread_param
0
NULL
)
;
if
(
*
thread
=
=
NULL
)
{
ZSTD_pthread_mutex_destroy
(
&
thread_param
.
initialized_mutex
)
;
ZSTD_pthread_cond_destroy
(
&
thread_param
.
initialized_cond
)
;
return
errno
;
}
ZSTD_pthread_mutex_lock
(
&
thread_param
.
initialized_mutex
)
;
while
(
!
thread_param
.
initialized
)
{
ZSTD_pthread_cond_wait
(
&
thread_param
.
initialized_cond
&
thread_param
.
initialized_mutex
)
;
}
ZSTD_pthread_mutex_unlock
(
&
thread_param
.
initialized_mutex
)
;
ZSTD_pthread_mutex_destroy
(
&
thread_param
.
initialized_mutex
)
;
ZSTD_pthread_cond_destroy
(
&
thread_param
.
initialized_cond
)
;
return
0
;
}
int
ZSTD_pthread_join
(
ZSTD_pthread_t
thread
)
{
DWORD
result
;
if
(
!
thread
)
return
0
;
result
=
WaitForSingleObject
(
thread
INFINITE
)
;
CloseHandle
(
thread
)
;
switch
(
result
)
{
case
WAIT_OBJECT_0
:
return
0
;
case
WAIT_ABANDONED
:
return
EINVAL
;
default
:
return
GetLastError
(
)
;
}
}
#
endif
#
if
defined
(
ZSTD_MULTITHREAD
)
&
&
DEBUGLEVEL
>
=
1
&
&
!
defined
(
_WIN32
)
#
define
ZSTD_DEPS_NEED_MALLOC
#
include
"
zstd_deps
.
h
"
int
ZSTD_pthread_mutex_init
(
ZSTD_pthread_mutex_t
*
mutex
pthread_mutexattr_t
const
*
attr
)
{
assert
(
mutex
!
=
NULL
)
;
*
mutex
=
(
pthread_mutex_t
*
)
ZSTD_malloc
(
sizeof
(
pthread_mutex_t
)
)
;
if
(
!
*
mutex
)
return
1
;
return
pthread_mutex_init
(
*
mutex
attr
)
;
}
int
ZSTD_pthread_mutex_destroy
(
ZSTD_pthread_mutex_t
*
mutex
)
{
assert
(
mutex
!
=
NULL
)
;
if
(
!
*
mutex
)
return
0
;
{
int
const
ret
=
pthread_mutex_destroy
(
*
mutex
)
;
ZSTD_free
(
*
mutex
)
;
return
ret
;
}
}
int
ZSTD_pthread_cond_init
(
ZSTD_pthread_cond_t
*
cond
pthread_condattr_t
const
*
attr
)
{
assert
(
cond
!
=
NULL
)
;
*
cond
=
(
pthread_cond_t
*
)
ZSTD_malloc
(
sizeof
(
pthread_cond_t
)
)
;
if
(
!
*
cond
)
return
1
;
return
pthread_cond_init
(
*
cond
attr
)
;
}
int
ZSTD_pthread_cond_destroy
(
ZSTD_pthread_cond_t
*
cond
)
{
assert
(
cond
!
=
NULL
)
;
if
(
!
*
cond
)
return
0
;
{
int
const
ret
=
pthread_cond_destroy
(
*
cond
)
;
ZSTD_free
(
*
cond
)
;
return
ret
;
}
}
#
endif
