#
include
"
.
.
/
common
/
allocations
.
h
"
#
include
"
zstd_deps
.
h
"
#
include
"
debug
.
h
"
#
include
"
pool
.
h
"
#
if
defined
(
_MSC_VER
)
#
pragma
warning
(
disable
:
4204
)
/
*
disable
:
C4204
:
non
-
constant
aggregate
initializer
*
/
#
endif
#
ifdef
ZSTD_MULTITHREAD
#
include
"
threading
.
h
"
typedef
struct
POOL_job_s
{
POOL_function
function
;
void
*
opaque
;
}
POOL_job
;
struct
POOL_ctx_s
{
ZSTD_customMem
customMem
;
ZSTD_pthread_t
*
threads
;
size_t
threadCapacity
;
size_t
threadLimit
;
POOL_job
*
queue
;
size_t
queueHead
;
size_t
queueTail
;
size_t
queueSize
;
size_t
numThreadsBusy
;
int
queueEmpty
;
ZSTD_pthread_mutex_t
queueMutex
;
ZSTD_pthread_cond_t
queuePushCond
;
ZSTD_pthread_cond_t
queuePopCond
;
int
shutdown
;
}
;
static
void
*
POOL_thread
(
void
*
opaque
)
{
POOL_ctx
*
const
ctx
=
(
POOL_ctx
*
)
opaque
;
if
(
!
ctx
)
{
return
NULL
;
}
for
(
;
;
)
{
ZSTD_pthread_mutex_lock
(
&
ctx
-
>
queueMutex
)
;
while
(
ctx
-
>
queueEmpty
|
|
(
ctx
-
>
numThreadsBusy
>
=
ctx
-
>
threadLimit
)
)
{
if
(
ctx
-
>
shutdown
)
{
ZSTD_pthread_mutex_unlock
(
&
ctx
-
>
queueMutex
)
;
return
opaque
;
}
ZSTD_pthread_cond_wait
(
&
ctx
-
>
queuePopCond
&
ctx
-
>
queueMutex
)
;
}
{
POOL_job
const
job
=
ctx
-
>
queue
[
ctx
-
>
queueHead
]
;
ctx
-
>
queueHead
=
(
ctx
-
>
queueHead
+
1
)
%
ctx
-
>
queueSize
;
ctx
-
>
numThreadsBusy
+
+
;
ctx
-
>
queueEmpty
=
(
ctx
-
>
queueHead
=
=
ctx
-
>
queueTail
)
;
ZSTD_pthread_cond_signal
(
&
ctx
-
>
queuePushCond
)
;
ZSTD_pthread_mutex_unlock
(
&
ctx
-
>
queueMutex
)
;
job
.
function
(
job
.
opaque
)
;
ZSTD_pthread_mutex_lock
(
&
ctx
-
>
queueMutex
)
;
ctx
-
>
numThreadsBusy
-
-
;
ZSTD_pthread_cond_signal
(
&
ctx
-
>
queuePushCond
)
;
ZSTD_pthread_mutex_unlock
(
&
ctx
-
>
queueMutex
)
;
}
}
assert
(
0
)
;
}
POOL_ctx
*
ZSTD_createThreadPool
(
size_t
numThreads
)
{
return
POOL_create
(
numThreads
0
)
;
}
POOL_ctx
*
POOL_create
(
size_t
numThreads
size_t
queueSize
)
{
return
POOL_create_advanced
(
numThreads
queueSize
ZSTD_defaultCMem
)
;
}
POOL_ctx
*
POOL_create_advanced
(
size_t
numThreads
size_t
queueSize
ZSTD_customMem
customMem
)
{
POOL_ctx
*
ctx
;
if
(
!
numThreads
)
{
return
NULL
;
}
ctx
=
(
POOL_ctx
*
)
ZSTD_customCalloc
(
sizeof
(
POOL_ctx
)
customMem
)
;
if
(
!
ctx
)
{
return
NULL
;
}
ctx
-
>
queueSize
=
queueSize
+
1
;
ctx
-
>
queue
=
(
POOL_job
*
)
ZSTD_customCalloc
(
ctx
-
>
queueSize
*
sizeof
(
POOL_job
)
customMem
)
;
ctx
-
>
queueHead
=
0
;
ctx
-
>
queueTail
=
0
;
ctx
-
>
numThreadsBusy
=
0
;
ctx
-
>
queueEmpty
=
1
;
{
int
error
=
0
;
error
|
=
ZSTD_pthread_mutex_init
(
&
ctx
-
>
queueMutex
NULL
)
;
error
|
=
ZSTD_pthread_cond_init
(
&
ctx
-
>
queuePushCond
NULL
)
;
error
|
=
ZSTD_pthread_cond_init
(
&
ctx
-
>
queuePopCond
NULL
)
;
if
(
error
)
{
POOL_free
(
ctx
)
;
return
NULL
;
}
}
ctx
-
>
shutdown
=
0
;
ctx
-
>
threads
=
(
ZSTD_pthread_t
*
)
ZSTD_customCalloc
(
numThreads
*
sizeof
(
ZSTD_pthread_t
)
customMem
)
;
ctx
-
>
threadCapacity
=
0
;
ctx
-
>
customMem
=
customMem
;
if
(
!
ctx
-
>
threads
|
|
!
ctx
-
>
queue
)
{
POOL_free
(
ctx
)
;
return
NULL
;
}
{
size_t
i
;
for
(
i
=
0
;
i
<
numThreads
;
+
+
i
)
{
if
(
ZSTD_pthread_create
(
&
ctx
-
>
threads
[
i
]
NULL
&
POOL_thread
ctx
)
)
{
ctx
-
>
threadCapacity
=
i
;
POOL_free
(
ctx
)
;
return
NULL
;
}
}
ctx
-
>
threadCapacity
=
numThreads
;
ctx
-
>
threadLimit
=
numThreads
;
}
return
ctx
;
}
static
void
POOL_join
(
POOL_ctx
*
ctx
)
{
ZSTD_pthread_mutex_lock
(
&
ctx
-
>
queueMutex
)
;
ctx
-
>
shutdown
=
1
;
ZSTD_pthread_mutex_unlock
(
&
ctx
-
>
queueMutex
)
;
ZSTD_pthread_cond_broadcast
(
&
ctx
-
>
queuePushCond
)
;
ZSTD_pthread_cond_broadcast
(
&
ctx
-
>
queuePopCond
)
;
{
size_t
i
;
for
(
i
=
0
;
i
<
ctx
-
>
threadCapacity
;
+
+
i
)
{
ZSTD_pthread_join
(
ctx
-
>
threads
[
i
]
)
;
}
}
}
void
POOL_free
(
POOL_ctx
*
ctx
)
{
if
(
!
ctx
)
{
return
;
}
POOL_join
(
ctx
)
;
ZSTD_pthread_mutex_destroy
(
&
ctx
-
>
queueMutex
)
;
ZSTD_pthread_cond_destroy
(
&
ctx
-
>
queuePushCond
)
;
ZSTD_pthread_cond_destroy
(
&
ctx
-
>
queuePopCond
)
;
ZSTD_customFree
(
ctx
-
>
queue
ctx
-
>
customMem
)
;
ZSTD_customFree
(
ctx
-
>
threads
ctx
-
>
customMem
)
;
ZSTD_customFree
(
ctx
ctx
-
>
customMem
)
;
}
void
POOL_joinJobs
(
POOL_ctx
*
ctx
)
{
ZSTD_pthread_mutex_lock
(
&
ctx
-
>
queueMutex
)
;
while
(
!
ctx
-
>
queueEmpty
|
|
ctx
-
>
numThreadsBusy
>
0
)
{
ZSTD_pthread_cond_wait
(
&
ctx
-
>
queuePushCond
&
ctx
-
>
queueMutex
)
;
}
ZSTD_pthread_mutex_unlock
(
&
ctx
-
>
queueMutex
)
;
}
void
ZSTD_freeThreadPool
(
ZSTD_threadPool
*
pool
)
{
POOL_free
(
pool
)
;
}
size_t
POOL_sizeof
(
const
POOL_ctx
*
ctx
)
{
if
(
ctx
=
=
NULL
)
return
0
;
return
sizeof
(
*
ctx
)
+
ctx
-
>
queueSize
*
sizeof
(
POOL_job
)
+
ctx
-
>
threadCapacity
*
sizeof
(
ZSTD_pthread_t
)
;
}
static
int
POOL_resize_internal
(
POOL_ctx
*
ctx
size_t
numThreads
)
{
if
(
numThreads
<
=
ctx
-
>
threadCapacity
)
{
if
(
!
numThreads
)
return
1
;
ctx
-
>
threadLimit
=
numThreads
;
return
0
;
}
{
ZSTD_pthread_t
*
const
threadPool
=
(
ZSTD_pthread_t
*
)
ZSTD_customCalloc
(
numThreads
*
sizeof
(
ZSTD_pthread_t
)
ctx
-
>
customMem
)
;
if
(
!
threadPool
)
return
1
;
ZSTD_memcpy
(
threadPool
ctx
-
>
threads
ctx
-
>
threadCapacity
*
sizeof
(
ZSTD_pthread_t
)
)
;
ZSTD_customFree
(
ctx
-
>
threads
ctx
-
>
customMem
)
;
ctx
-
>
threads
=
threadPool
;
{
size_t
threadId
;
for
(
threadId
=
ctx
-
>
threadCapacity
;
threadId
<
numThreads
;
+
+
threadId
)
{
if
(
ZSTD_pthread_create
(
&
threadPool
[
threadId
]
NULL
&
POOL_thread
ctx
)
)
{
ctx
-
>
threadCapacity
=
threadId
;
return
1
;
}
}
}
}
ctx
-
>
threadCapacity
=
numThreads
;
ctx
-
>
threadLimit
=
numThreads
;
return
0
;
}
int
POOL_resize
(
POOL_ctx
*
ctx
size_t
numThreads
)
{
int
result
;
if
(
ctx
=
=
NULL
)
return
1
;
ZSTD_pthread_mutex_lock
(
&
ctx
-
>
queueMutex
)
;
result
=
POOL_resize_internal
(
ctx
numThreads
)
;
ZSTD_pthread_cond_broadcast
(
&
ctx
-
>
queuePopCond
)
;
ZSTD_pthread_mutex_unlock
(
&
ctx
-
>
queueMutex
)
;
return
result
;
}
static
int
isQueueFull
(
POOL_ctx
const
*
ctx
)
{
if
(
ctx
-
>
queueSize
>
1
)
{
return
ctx
-
>
queueHead
=
=
(
(
ctx
-
>
queueTail
+
1
)
%
ctx
-
>
queueSize
)
;
}
else
{
return
(
ctx
-
>
numThreadsBusy
=
=
ctx
-
>
threadLimit
)
|
|
!
ctx
-
>
queueEmpty
;
}
}
static
void
POOL_add_internal
(
POOL_ctx
*
ctx
POOL_function
function
void
*
opaque
)
{
POOL_job
job
;
job
.
function
=
function
;
job
.
opaque
=
opaque
;
assert
(
ctx
!
=
NULL
)
;
if
(
ctx
-
>
shutdown
)
return
;
ctx
-
>
queueEmpty
=
0
;
ctx
-
>
queue
[
ctx
-
>
queueTail
]
=
job
;
ctx
-
>
queueTail
=
(
ctx
-
>
queueTail
+
1
)
%
ctx
-
>
queueSize
;
ZSTD_pthread_cond_signal
(
&
ctx
-
>
queuePopCond
)
;
}
void
POOL_add
(
POOL_ctx
*
ctx
POOL_function
function
void
*
opaque
)
{
assert
(
ctx
!
=
NULL
)
;
ZSTD_pthread_mutex_lock
(
&
ctx
-
>
queueMutex
)
;
while
(
isQueueFull
(
ctx
)
&
&
(
!
ctx
-
>
shutdown
)
)
{
ZSTD_pthread_cond_wait
(
&
ctx
-
>
queuePushCond
&
ctx
-
>
queueMutex
)
;
}
POOL_add_internal
(
ctx
function
opaque
)
;
ZSTD_pthread_mutex_unlock
(
&
ctx
-
>
queueMutex
)
;
}
int
POOL_tryAdd
(
POOL_ctx
*
ctx
POOL_function
function
void
*
opaque
)
{
assert
(
ctx
!
=
NULL
)
;
ZSTD_pthread_mutex_lock
(
&
ctx
-
>
queueMutex
)
;
if
(
isQueueFull
(
ctx
)
)
{
ZSTD_pthread_mutex_unlock
(
&
ctx
-
>
queueMutex
)
;
return
0
;
}
POOL_add_internal
(
ctx
function
opaque
)
;
ZSTD_pthread_mutex_unlock
(
&
ctx
-
>
queueMutex
)
;
return
1
;
}
#
else
struct
POOL_ctx_s
{
int
dummy
;
}
;
static
POOL_ctx
g_poolCtx
;
POOL_ctx
*
POOL_create
(
size_t
numThreads
size_t
queueSize
)
{
return
POOL_create_advanced
(
numThreads
queueSize
ZSTD_defaultCMem
)
;
}
POOL_ctx
*
POOL_create_advanced
(
size_t
numThreads
size_t
queueSize
ZSTD_customMem
customMem
)
{
(
void
)
numThreads
;
(
void
)
queueSize
;
(
void
)
customMem
;
return
&
g_poolCtx
;
}
void
POOL_free
(
POOL_ctx
*
ctx
)
{
assert
(
!
ctx
|
|
ctx
=
=
&
g_poolCtx
)
;
(
void
)
ctx
;
}
void
POOL_joinJobs
(
POOL_ctx
*
ctx
)
{
assert
(
!
ctx
|
|
ctx
=
=
&
g_poolCtx
)
;
(
void
)
ctx
;
}
int
POOL_resize
(
POOL_ctx
*
ctx
size_t
numThreads
)
{
(
void
)
ctx
;
(
void
)
numThreads
;
return
0
;
}
void
POOL_add
(
POOL_ctx
*
ctx
POOL_function
function
void
*
opaque
)
{
(
void
)
ctx
;
function
(
opaque
)
;
}
int
POOL_tryAdd
(
POOL_ctx
*
ctx
POOL_function
function
void
*
opaque
)
{
(
void
)
ctx
;
function
(
opaque
)
;
return
1
;
}
size_t
POOL_sizeof
(
const
POOL_ctx
*
ctx
)
{
if
(
ctx
=
=
NULL
)
return
0
;
assert
(
ctx
=
=
&
g_poolCtx
)
;
return
sizeof
(
*
ctx
)
;
}
#
endif
