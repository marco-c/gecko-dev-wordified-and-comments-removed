import
*
as
asn1js
from
"
asn1js
"
;
import
*
as
pvutils
from
"
pvutils
"
;
import
*
as
common
from
"
.
/
common
"
;
import
{
ResponseData
ResponseDataJson
ResponseDataSchema
}
from
"
.
/
ResponseData
"
;
import
{
AlgorithmIdentifier
AlgorithmIdentifierJson
AlgorithmIdentifierSchema
}
from
"
.
/
AlgorithmIdentifier
"
;
import
{
Certificate
CertificateJson
CertificateSchema
checkCA
}
from
"
.
/
Certificate
"
;
import
{
CertID
}
from
"
.
/
CertID
"
;
import
{
RelativeDistinguishedNames
}
from
"
.
/
RelativeDistinguishedNames
"
;
import
{
CertificateChainValidationEngine
}
from
"
.
/
CertificateChainValidationEngine
"
;
import
*
as
Schema
from
"
.
/
Schema
"
;
import
{
PkiObject
PkiObjectParameters
}
from
"
.
/
PkiObject
"
;
import
{
AsnError
}
from
"
.
/
errors
"
;
import
{
EMPTY_STRING
}
from
"
.
/
constants
"
;
const
TBS_RESPONSE_DATA
=
"
tbsResponseData
"
;
const
SIGNATURE_ALGORITHM
=
"
signatureAlgorithm
"
;
const
SIGNATURE
=
"
signature
"
;
const
CERTS
=
"
certs
"
;
const
BASIC_OCSP_RESPONSE
=
"
BasicOCSPResponse
"
;
const
BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA
=
{
BASIC_OCSP_RESPONSE
}
.
{
TBS_RESPONSE_DATA
}
;
const
BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM
=
{
BASIC_OCSP_RESPONSE
}
.
{
SIGNATURE_ALGORITHM
}
;
const
BASIC_OCSP_RESPONSE_SIGNATURE
=
{
BASIC_OCSP_RESPONSE
}
.
{
SIGNATURE
}
;
const
BASIC_OCSP_RESPONSE_CERTS
=
{
BASIC_OCSP_RESPONSE
}
.
{
CERTS
}
;
const
CLEAR_PROPS
=
[
BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA
BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM
BASIC_OCSP_RESPONSE_SIGNATURE
BASIC_OCSP_RESPONSE_CERTS
]
;
export
interface
IBasicOCSPResponse
{
tbsResponseData
:
ResponseData
;
signatureAlgorithm
:
AlgorithmIdentifier
;
signature
:
asn1js
.
BitString
;
certs
?
:
Certificate
[
]
;
}
export
interface
CertificateStatus
{
isForCertificate
:
boolean
;
status
:
number
;
}
export
type
BasicOCSPResponseParameters
=
PkiObjectParameters
&
Partial
<
IBasicOCSPResponse
>
;
export
interface
BasicOCSPResponseVerifyParams
{
trustedCerts
?
:
Certificate
[
]
;
}
export
interface
BasicOCSPResponseJson
{
tbsResponseData
:
ResponseDataJson
;
signatureAlgorithm
:
AlgorithmIdentifierJson
;
signature
:
asn1js
.
BitStringJson
;
certs
?
:
CertificateJson
[
]
;
}
export
class
BasicOCSPResponse
extends
PkiObject
implements
IBasicOCSPResponse
{
public
static
override
CLASS_NAME
=
"
BasicOCSPResponse
"
;
public
tbsResponseData
!
:
ResponseData
;
public
signatureAlgorithm
!
:
AlgorithmIdentifier
;
public
signature
!
:
asn1js
.
BitString
;
public
certs
?
:
Certificate
[
]
;
constructor
(
parameters
:
BasicOCSPResponseParameters
=
{
}
)
{
super
(
)
;
this
.
tbsResponseData
=
pvutils
.
getParametersValue
(
parameters
TBS_RESPONSE_DATA
BasicOCSPResponse
.
defaultValues
(
TBS_RESPONSE_DATA
)
)
;
this
.
signatureAlgorithm
=
pvutils
.
getParametersValue
(
parameters
SIGNATURE_ALGORITHM
BasicOCSPResponse
.
defaultValues
(
SIGNATURE_ALGORITHM
)
)
;
this
.
signature
=
pvutils
.
getParametersValue
(
parameters
SIGNATURE
BasicOCSPResponse
.
defaultValues
(
SIGNATURE
)
)
;
if
(
CERTS
in
parameters
)
{
this
.
certs
=
pvutils
.
getParametersValue
(
parameters
CERTS
BasicOCSPResponse
.
defaultValues
(
CERTS
)
)
;
}
if
(
parameters
.
schema
)
{
this
.
fromSchema
(
parameters
.
schema
)
;
}
}
public
static
override
defaultValues
(
memberName
:
typeof
TBS_RESPONSE_DATA
)
:
ResponseData
;
public
static
override
defaultValues
(
memberName
:
typeof
SIGNATURE_ALGORITHM
)
:
AlgorithmIdentifier
;
public
static
override
defaultValues
(
memberName
:
typeof
SIGNATURE
)
:
asn1js
.
BitString
;
public
static
override
defaultValues
(
memberName
:
typeof
CERTS
)
:
Certificate
[
]
;
public
static
override
defaultValues
(
memberName
:
string
)
:
any
{
switch
(
memberName
)
{
case
TBS_RESPONSE_DATA
:
return
new
ResponseData
(
)
;
case
SIGNATURE_ALGORITHM
:
return
new
AlgorithmIdentifier
(
)
;
case
SIGNATURE
:
return
new
asn1js
.
BitString
(
)
;
case
CERTS
:
return
[
]
;
default
:
return
super
.
defaultValues
(
memberName
)
;
}
}
public
static
compareWithDefault
(
memberName
:
string
memberValue
:
any
)
:
boolean
{
switch
(
memberName
)
{
case
"
type
"
:
{
let
comparisonResult
=
(
(
ResponseData
.
compareWithDefault
(
"
tbs
"
memberValue
.
tbs
)
)
&
&
(
ResponseData
.
compareWithDefault
(
"
responderID
"
memberValue
.
responderID
)
)
&
&
(
ResponseData
.
compareWithDefault
(
"
producedAt
"
memberValue
.
producedAt
)
)
&
&
(
ResponseData
.
compareWithDefault
(
"
responses
"
memberValue
.
responses
)
)
)
;
if
(
"
responseExtensions
"
in
memberValue
)
comparisonResult
=
comparisonResult
&
&
(
ResponseData
.
compareWithDefault
(
"
responseExtensions
"
memberValue
.
responseExtensions
)
)
;
return
comparisonResult
;
}
case
SIGNATURE_ALGORITHM
:
return
(
(
memberValue
.
algorithmId
=
=
=
EMPTY_STRING
)
&
&
(
(
"
algorithmParams
"
in
memberValue
)
=
=
=
false
)
)
;
case
SIGNATURE
:
return
(
memberValue
.
isEqual
(
BasicOCSPResponse
.
defaultValues
(
memberName
)
)
)
;
case
CERTS
:
return
(
memberValue
.
length
=
=
=
0
)
;
default
:
return
super
.
defaultValues
(
memberName
)
;
}
}
public
static
override
schema
(
parameters
:
Schema
.
SchemaParameters
<
{
tbsResponseData
?
:
ResponseDataSchema
;
signatureAlgorithm
?
:
AlgorithmIdentifierSchema
;
signature
?
:
string
;
certs
?
:
CertificateSchema
;
}
>
=
{
}
)
:
Schema
.
SchemaType
{
const
names
=
pvutils
.
getParametersValue
<
NonNullable
<
typeof
parameters
.
names
>
>
(
parameters
"
names
"
{
}
)
;
return
(
new
asn1js
.
Sequence
(
{
name
:
(
names
.
blockName
|
|
BASIC_OCSP_RESPONSE
)
value
:
[
ResponseData
.
schema
(
names
.
tbsResponseData
|
|
{
names
:
{
blockName
:
BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA
}
}
)
AlgorithmIdentifier
.
schema
(
names
.
signatureAlgorithm
|
|
{
names
:
{
blockName
:
BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM
}
}
)
new
asn1js
.
BitString
(
{
name
:
(
names
.
signature
|
|
BASIC_OCSP_RESPONSE_SIGNATURE
)
}
)
new
asn1js
.
Constructed
(
{
optional
:
true
idBlock
:
{
tagClass
:
3
tagNumber
:
0
}
value
:
[
new
asn1js
.
Sequence
(
{
value
:
[
new
asn1js
.
Repeated
(
{
name
:
BASIC_OCSP_RESPONSE_CERTS
value
:
Certificate
.
schema
(
names
.
certs
|
|
{
}
)
}
)
]
}
)
]
}
)
]
}
)
)
;
}
public
fromSchema
(
schema
:
Schema
.
SchemaType
)
:
void
{
pvutils
.
clearProps
(
schema
CLEAR_PROPS
)
;
const
asn1
=
asn1js
.
compareSchema
(
schema
schema
BasicOCSPResponse
.
schema
(
)
)
;
AsnError
.
assertSchema
(
asn1
this
.
className
)
;
this
.
tbsResponseData
=
new
ResponseData
(
{
schema
:
asn1
.
result
[
BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA
]
}
)
;
this
.
signatureAlgorithm
=
new
AlgorithmIdentifier
(
{
schema
:
asn1
.
result
[
BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM
]
}
)
;
this
.
signature
=
asn1
.
result
[
BASIC_OCSP_RESPONSE_SIGNATURE
]
;
if
(
BASIC_OCSP_RESPONSE_CERTS
in
asn1
.
result
)
{
this
.
certs
=
Array
.
from
(
asn1
.
result
[
BASIC_OCSP_RESPONSE_CERTS
]
element
=
>
new
Certificate
(
{
schema
:
element
}
)
)
;
}
}
public
toSchema
(
)
:
asn1js
.
Sequence
{
const
outputArray
=
[
]
;
outputArray
.
push
(
this
.
tbsResponseData
.
toSchema
(
)
)
;
outputArray
.
push
(
this
.
signatureAlgorithm
.
toSchema
(
)
)
;
outputArray
.
push
(
this
.
signature
)
;
if
(
this
.
certs
)
{
outputArray
.
push
(
new
asn1js
.
Constructed
(
{
idBlock
:
{
tagClass
:
3
tagNumber
:
0
}
value
:
[
new
asn1js
.
Sequence
(
{
value
:
Array
.
from
(
this
.
certs
o
=
>
o
.
toSchema
(
)
)
}
)
]
}
)
)
;
}
return
(
new
asn1js
.
Sequence
(
{
value
:
outputArray
}
)
)
;
}
public
toJSON
(
)
:
BasicOCSPResponseJson
{
const
res
:
BasicOCSPResponseJson
=
{
tbsResponseData
:
this
.
tbsResponseData
.
toJSON
(
)
signatureAlgorithm
:
this
.
signatureAlgorithm
.
toJSON
(
)
signature
:
this
.
signature
.
toJSON
(
)
}
;
if
(
this
.
certs
)
{
res
.
certs
=
Array
.
from
(
this
.
certs
o
=
>
o
.
toJSON
(
)
)
;
}
return
res
;
}
public
async
getCertificateStatus
(
certificate
:
Certificate
issuerCertificate
:
Certificate
crypto
=
common
.
getCrypto
(
true
)
)
:
Promise
<
CertificateStatus
>
{
const
result
=
{
isForCertificate
:
false
status
:
2
}
;
const
hashesObject
:
Record
<
string
number
>
=
{
}
;
const
certIDs
:
CertID
[
]
=
[
]
;
for
(
const
response
of
this
.
tbsResponseData
.
responses
)
{
const
hashAlgorithm
=
crypto
.
getAlgorithmByOID
(
response
.
certID
.
hashAlgorithm
.
algorithmId
true
"
CertID
.
hashAlgorithm
"
)
;
if
(
!
hashesObject
[
hashAlgorithm
.
name
]
)
{
hashesObject
[
hashAlgorithm
.
name
]
=
1
;
const
certID
=
new
CertID
(
)
;
certIDs
.
push
(
certID
)
;
await
certID
.
createForCertificate
(
certificate
{
hashAlgorithm
:
hashAlgorithm
.
name
issuerCertificate
}
crypto
)
;
}
}
for
(
const
response
of
this
.
tbsResponseData
.
responses
)
{
for
(
const
id
of
certIDs
)
{
if
(
response
.
certID
.
isEqual
(
id
)
)
{
result
.
isForCertificate
=
true
;
try
{
switch
(
response
.
certStatus
.
idBlock
.
isConstructed
)
{
case
true
:
if
(
response
.
certStatus
.
idBlock
.
tagNumber
=
=
=
1
)
result
.
status
=
1
;
break
;
case
false
:
switch
(
response
.
certStatus
.
idBlock
.
tagNumber
)
{
case
0
:
result
.
status
=
0
;
break
;
case
2
:
result
.
status
=
2
;
break
;
default
:
}
break
;
default
:
}
}
catch
{
}
return
result
;
}
}
}
return
result
;
}
async
sign
(
privateKey
:
CryptoKey
hashAlgorithm
=
"
SHA
-
1
"
crypto
=
common
.
getCrypto
(
true
)
)
:
Promise
<
void
>
{
if
(
!
privateKey
)
{
throw
new
Error
(
"
Need
to
provide
a
private
key
for
signing
"
)
;
}
const
signatureParams
=
await
crypto
.
getSignatureParameters
(
privateKey
hashAlgorithm
)
;
const
algorithm
=
signatureParams
.
parameters
.
algorithm
;
if
(
!
(
"
name
"
in
algorithm
)
)
{
throw
new
Error
(
"
Empty
algorithm
"
)
;
}
this
.
signatureAlgorithm
=
signatureParams
.
signatureAlgorithm
;
this
.
tbsResponseData
.
tbsView
=
new
Uint8Array
(
this
.
tbsResponseData
.
toSchema
(
true
)
.
toBER
(
)
)
;
const
signature
=
await
crypto
.
signWithPrivateKey
(
this
.
tbsResponseData
.
tbsView
as
BufferSource
privateKey
{
algorithm
}
)
;
this
.
signature
=
new
asn1js
.
BitString
(
{
valueHex
:
signature
}
)
;
}
public
async
verify
(
params
:
BasicOCSPResponseVerifyParams
=
{
}
crypto
=
common
.
getCrypto
(
true
)
)
:
Promise
<
boolean
>
{
let
signerCert
:
Certificate
|
null
=
null
;
let
certIndex
=
-
1
;
const
trustedCerts
:
Certificate
[
]
=
params
.
trustedCerts
|
|
[
]
;
if
(
!
this
.
certs
)
{
throw
new
Error
(
"
No
certificates
attached
to
the
BasicOCSPResponse
"
)
;
}
switch
(
true
)
{
case
(
this
.
tbsResponseData
.
responderID
instanceof
RelativeDistinguishedNames
)
:
for
(
const
[
index
certificate
]
of
this
.
certs
.
entries
(
)
)
{
if
(
certificate
.
subject
.
isEqual
(
this
.
tbsResponseData
.
responderID
)
)
{
certIndex
=
index
;
break
;
}
}
break
;
case
(
this
.
tbsResponseData
.
responderID
instanceof
asn1js
.
OctetString
)
:
for
(
const
[
index
cert
]
of
this
.
certs
.
entries
(
)
)
{
const
hash
=
await
crypto
.
digest
(
{
name
:
"
sha
-
1
"
}
cert
.
subjectPublicKeyInfo
.
subjectPublicKey
.
valueBlock
.
valueHexView
as
BufferSource
)
;
if
(
pvutils
.
isEqualBuffer
(
hash
this
.
tbsResponseData
.
responderID
.
valueBlock
.
valueHex
)
)
{
certIndex
=
index
;
break
;
}
}
break
;
default
:
throw
new
Error
(
"
Wrong
value
for
responderID
"
)
;
}
if
(
certIndex
=
=
=
(
-
1
)
)
throw
new
Error
(
"
Correct
certificate
was
not
found
in
OCSP
response
"
)
;
signerCert
=
this
.
certs
[
certIndex
]
;
const
additionalCerts
:
Certificate
[
]
=
[
signerCert
]
;
for
(
const
cert
of
this
.
certs
)
{
const
caCert
=
await
checkCA
(
cert
signerCert
)
;
if
(
caCert
)
{
additionalCerts
.
push
(
caCert
)
;
}
}
const
certChain
=
new
CertificateChainValidationEngine
(
{
certs
:
additionalCerts
trustedCerts
}
)
;
const
verificationResult
=
await
certChain
.
verify
(
{
}
crypto
)
;
if
(
!
verificationResult
.
result
)
{
throw
new
Error
(
"
Validation
of
signer
'
s
certificate
failed
"
)
;
}
return
crypto
.
verifyWithPublicKey
(
this
.
tbsResponseData
.
tbsView
as
BufferSource
this
.
signature
this
.
certs
[
certIndex
]
.
subjectPublicKeyInfo
this
.
signatureAlgorithm
)
;
}
}
