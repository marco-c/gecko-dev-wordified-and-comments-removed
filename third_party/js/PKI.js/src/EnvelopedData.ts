import
*
as
asn1js
from
"
asn1js
"
;
import
*
as
pvutils
from
"
pvutils
"
;
import
{
BufferSourceConverter
}
from
"
pvtsutils
"
;
import
*
as
common
from
"
.
/
common
"
;
import
{
OriginatorInfo
OriginatorInfoJson
}
from
"
.
/
OriginatorInfo
"
;
import
{
RecipientInfo
RecipientInfoJson
}
from
"
.
/
RecipientInfo
"
;
import
{
EncryptedContentInfo
EncryptedContentInfoJson
EncryptedContentInfoSchema
EncryptedContentInfoSplit
}
from
"
.
/
EncryptedContentInfo
"
;
import
{
Attribute
AttributeJson
}
from
"
.
/
Attribute
"
;
import
{
AlgorithmIdentifier
AlgorithmIdentifierParameters
}
from
"
.
/
AlgorithmIdentifier
"
;
import
{
RSAESOAEPParams
}
from
"
.
/
RSAESOAEPParams
"
;
import
{
KeyTransRecipientInfo
}
from
"
.
/
KeyTransRecipientInfo
"
;
import
{
IssuerAndSerialNumber
}
from
"
.
/
IssuerAndSerialNumber
"
;
import
{
RecipientKeyIdentifier
}
from
"
.
/
RecipientKeyIdentifier
"
;
import
{
RecipientEncryptedKey
}
from
"
.
/
RecipientEncryptedKey
"
;
import
{
KeyAgreeRecipientIdentifier
}
from
"
.
/
KeyAgreeRecipientIdentifier
"
;
import
{
KeyAgreeRecipientInfo
KeyAgreeRecipientInfoParameters
}
from
"
.
/
KeyAgreeRecipientInfo
"
;
import
{
RecipientEncryptedKeys
}
from
"
.
/
RecipientEncryptedKeys
"
;
import
{
KEKRecipientInfo
}
from
"
.
/
KEKRecipientInfo
"
;
import
{
KEKIdentifier
}
from
"
.
/
KEKIdentifier
"
;
import
{
PBKDF2Params
}
from
"
.
/
PBKDF2Params
"
;
import
{
PasswordRecipientinfo
}
from
"
.
/
PasswordRecipientinfo
"
;
import
{
ECCCMSSharedInfo
}
from
"
.
/
ECCCMSSharedInfo
"
;
import
{
OriginatorIdentifierOrKey
}
from
"
.
/
OriginatorIdentifierOrKey
"
;
import
{
OriginatorPublicKey
}
from
"
.
/
OriginatorPublicKey
"
;
import
*
as
Schema
from
"
.
/
Schema
"
;
import
{
Certificate
}
from
"
.
/
Certificate
"
;
import
{
ArgumentError
AsnError
}
from
"
.
/
errors
"
;
import
{
PkiObject
PkiObjectParameters
}
from
"
.
/
PkiObject
"
;
import
{
EMPTY_STRING
}
from
"
.
/
constants
"
;
const
VERSION
=
"
version
"
;
const
ORIGINATOR_INFO
=
"
originatorInfo
"
;
const
RECIPIENT_INFOS
=
"
recipientInfos
"
;
const
ENCRYPTED_CONTENT_INFO
=
"
encryptedContentInfo
"
;
const
UNPROTECTED_ATTRS
=
"
unprotectedAttrs
"
;
const
CLEAR_PROPS
=
[
VERSION
ORIGINATOR_INFO
RECIPIENT_INFOS
ENCRYPTED_CONTENT_INFO
UNPROTECTED_ATTRS
]
;
const
defaultEncryptionParams
=
{
kdfAlgorithm
:
"
SHA
-
512
"
kekEncryptionLength
:
256
}
;
const
curveLengthByName
:
Record
<
string
number
>
=
{
"
P
-
256
"
:
256
"
P
-
384
"
:
384
"
P
-
521
"
:
528
}
;
export
interface
IEnvelopedData
{
version
:
number
;
originatorInfo
?
:
OriginatorInfo
;
recipientInfos
:
RecipientInfo
[
]
;
encryptedContentInfo
:
EncryptedContentInfo
;
unprotectedAttrs
?
:
Attribute
[
]
;
}
export
interface
EnvelopedDataJson
{
version
:
number
;
originatorInfo
?
:
OriginatorInfoJson
;
recipientInfos
:
RecipientInfoJson
[
]
;
encryptedContentInfo
:
EncryptedContentInfoJson
;
unprotectedAttrs
?
:
AttributeJson
[
]
;
}
export
type
EnvelopedDataParameters
=
PkiObjectParameters
&
Partial
<
IEnvelopedData
>
&
EncryptedContentInfoSplit
;
export
interface
EnvelopedDataEncryptionParams
{
kekEncryptionLength
:
number
;
kdfAlgorithm
:
string
;
}
export
interface
EnvelopedDataDecryptBaseParams
{
preDefinedData
?
:
BufferSource
;
recipientCertificate
?
:
Certificate
;
}
export
interface
EnvelopedDataDecryptKeyParams
extends
EnvelopedDataDecryptBaseParams
{
recipientPrivateKey
:
CryptoKey
;
crypto
?
:
Crypto
;
}
export
interface
EnvelopedDataDecryptBufferParams
extends
EnvelopedDataDecryptBaseParams
{
recipientPrivateKey
?
:
BufferSource
;
}
export
type
EnvelopedDataDecryptParams
=
EnvelopedDataDecryptBufferParams
|
EnvelopedDataDecryptKeyParams
;
export
class
EnvelopedData
extends
PkiObject
implements
IEnvelopedData
{
public
static
override
CLASS_NAME
=
"
EnvelopedData
"
;
public
version
!
:
number
;
public
originatorInfo
?
:
OriginatorInfo
;
public
recipientInfos
!
:
RecipientInfo
[
]
;
public
encryptedContentInfo
!
:
EncryptedContentInfo
;
public
unprotectedAttrs
?
:
Attribute
[
]
;
public
policy
:
Required
<
EncryptedContentInfoSplit
>
;
constructor
(
parameters
:
EnvelopedDataParameters
=
{
}
)
{
super
(
)
;
this
.
version
=
pvutils
.
getParametersValue
(
parameters
VERSION
EnvelopedData
.
defaultValues
(
VERSION
)
)
;
if
(
ORIGINATOR_INFO
in
parameters
)
{
this
.
originatorInfo
=
pvutils
.
getParametersValue
(
parameters
ORIGINATOR_INFO
EnvelopedData
.
defaultValues
(
ORIGINATOR_INFO
)
)
;
}
this
.
recipientInfos
=
pvutils
.
getParametersValue
(
parameters
RECIPIENT_INFOS
EnvelopedData
.
defaultValues
(
RECIPIENT_INFOS
)
)
;
this
.
encryptedContentInfo
=
pvutils
.
getParametersValue
(
parameters
ENCRYPTED_CONTENT_INFO
EnvelopedData
.
defaultValues
(
ENCRYPTED_CONTENT_INFO
)
)
;
if
(
UNPROTECTED_ATTRS
in
parameters
)
{
this
.
unprotectedAttrs
=
pvutils
.
getParametersValue
(
parameters
UNPROTECTED_ATTRS
EnvelopedData
.
defaultValues
(
UNPROTECTED_ATTRS
)
)
;
}
this
.
policy
=
{
disableSplit
:
!
!
parameters
.
disableSplit
}
;
if
(
parameters
.
schema
)
{
this
.
fromSchema
(
parameters
.
schema
)
;
}
}
public
static
override
defaultValues
(
memberName
:
typeof
VERSION
)
:
number
;
public
static
override
defaultValues
(
memberName
:
typeof
ORIGINATOR_INFO
)
:
OriginatorInfo
;
public
static
override
defaultValues
(
memberName
:
typeof
RECIPIENT_INFOS
)
:
RecipientInfo
[
]
;
public
static
override
defaultValues
(
memberName
:
typeof
ENCRYPTED_CONTENT_INFO
)
:
EncryptedContentInfo
;
public
static
override
defaultValues
(
memberName
:
typeof
UNPROTECTED_ATTRS
)
:
Attribute
[
]
;
public
static
override
defaultValues
(
memberName
:
string
)
:
any
{
switch
(
memberName
)
{
case
VERSION
:
return
0
;
case
ORIGINATOR_INFO
:
return
new
OriginatorInfo
(
)
;
case
RECIPIENT_INFOS
:
return
[
]
;
case
ENCRYPTED_CONTENT_INFO
:
return
new
EncryptedContentInfo
(
)
;
case
UNPROTECTED_ATTRS
:
return
[
]
;
default
:
return
super
.
defaultValues
(
memberName
)
;
}
}
public
static
compareWithDefault
(
memberName
:
string
memberValue
:
any
)
:
boolean
{
switch
(
memberName
)
{
case
VERSION
:
return
(
memberValue
=
=
=
EnvelopedData
.
defaultValues
(
memberName
)
)
;
case
ORIGINATOR_INFO
:
return
(
(
memberValue
.
certs
.
certificates
.
length
=
=
=
0
)
&
&
(
memberValue
.
crls
.
crls
.
length
=
=
=
0
)
)
;
case
RECIPIENT_INFOS
:
case
UNPROTECTED_ATTRS
:
return
(
memberValue
.
length
=
=
=
0
)
;
case
ENCRYPTED_CONTENT_INFO
:
return
(
(
EncryptedContentInfo
.
compareWithDefault
(
"
contentType
"
memberValue
.
contentType
)
)
&
&
(
EncryptedContentInfo
.
compareWithDefault
(
"
contentEncryptionAlgorithm
"
memberValue
.
contentEncryptionAlgorithm
)
&
&
(
EncryptedContentInfo
.
compareWithDefault
(
"
encryptedContent
"
memberValue
.
encryptedContent
)
)
)
)
;
default
:
return
super
.
defaultValues
(
memberName
)
;
}
}
public
static
override
schema
(
parameters
:
Schema
.
SchemaParameters
<
{
version
?
:
string
;
originatorInfo
?
:
string
;
recipientInfos
?
:
string
;
encryptedContentInfo
?
:
EncryptedContentInfoSchema
;
unprotectedAttrs
?
:
string
;
}
>
=
{
}
)
:
Schema
.
SchemaType
{
const
names
=
pvutils
.
getParametersValue
<
NonNullable
<
typeof
parameters
.
names
>
>
(
parameters
"
names
"
{
}
)
;
return
(
new
asn1js
.
Sequence
(
{
name
:
(
names
.
blockName
|
|
EMPTY_STRING
)
value
:
[
new
asn1js
.
Integer
(
{
name
:
(
names
.
version
|
|
EMPTY_STRING
)
}
)
new
asn1js
.
Constructed
(
{
name
:
(
names
.
originatorInfo
|
|
EMPTY_STRING
)
optional
:
true
idBlock
:
{
tagClass
:
3
tagNumber
:
0
}
value
:
OriginatorInfo
.
schema
(
)
.
valueBlock
.
value
}
)
new
asn1js
.
Set
(
{
value
:
[
new
asn1js
.
Repeated
(
{
name
:
(
names
.
recipientInfos
|
|
EMPTY_STRING
)
value
:
RecipientInfo
.
schema
(
)
}
)
]
}
)
EncryptedContentInfo
.
schema
(
names
.
encryptedContentInfo
|
|
{
}
)
new
asn1js
.
Constructed
(
{
optional
:
true
idBlock
:
{
tagClass
:
3
tagNumber
:
1
}
value
:
[
new
asn1js
.
Repeated
(
{
name
:
(
names
.
unprotectedAttrs
|
|
EMPTY_STRING
)
value
:
Attribute
.
schema
(
)
}
)
]
}
)
]
}
)
)
;
}
public
fromSchema
(
schema
:
Schema
.
SchemaType
)
:
void
{
pvutils
.
clearProps
(
schema
CLEAR_PROPS
)
;
const
asn1
=
asn1js
.
compareSchema
(
schema
schema
EnvelopedData
.
schema
(
{
names
:
{
version
:
VERSION
originatorInfo
:
ORIGINATOR_INFO
recipientInfos
:
RECIPIENT_INFOS
encryptedContentInfo
:
{
names
:
{
blockName
:
ENCRYPTED_CONTENT_INFO
}
}
unprotectedAttrs
:
UNPROTECTED_ATTRS
}
}
)
)
;
AsnError
.
assertSchema
(
asn1
this
.
className
)
;
this
.
version
=
asn1
.
result
.
version
.
valueBlock
.
valueDec
;
if
(
ORIGINATOR_INFO
in
asn1
.
result
)
{
this
.
originatorInfo
=
new
OriginatorInfo
(
{
schema
:
new
asn1js
.
Sequence
(
{
value
:
asn1
.
result
.
originatorInfo
.
valueBlock
.
value
}
)
}
)
;
}
this
.
recipientInfos
=
Array
.
from
(
asn1
.
result
.
recipientInfos
o
=
>
new
RecipientInfo
(
{
schema
:
o
}
)
)
;
this
.
encryptedContentInfo
=
new
EncryptedContentInfo
(
{
schema
:
asn1
.
result
.
encryptedContentInfo
}
)
;
if
(
UNPROTECTED_ATTRS
in
asn1
.
result
)
this
.
unprotectedAttrs
=
Array
.
from
(
asn1
.
result
.
unprotectedAttrs
o
=
>
new
Attribute
(
{
schema
:
o
}
)
)
;
}
public
toSchema
(
)
:
asn1js
.
Sequence
{
const
outputArray
=
[
]
;
outputArray
.
push
(
new
asn1js
.
Integer
(
{
value
:
this
.
version
}
)
)
;
if
(
this
.
originatorInfo
)
{
outputArray
.
push
(
new
asn1js
.
Constructed
(
{
optional
:
true
idBlock
:
{
tagClass
:
3
tagNumber
:
0
}
value
:
this
.
originatorInfo
.
toSchema
(
)
.
valueBlock
.
value
}
)
)
;
}
outputArray
.
push
(
new
asn1js
.
Set
(
{
value
:
Array
.
from
(
this
.
recipientInfos
o
=
>
o
.
toSchema
(
)
)
}
)
)
;
outputArray
.
push
(
this
.
encryptedContentInfo
.
toSchema
(
)
)
;
if
(
this
.
unprotectedAttrs
)
{
outputArray
.
push
(
new
asn1js
.
Constructed
(
{
optional
:
true
idBlock
:
{
tagClass
:
3
tagNumber
:
1
}
value
:
Array
.
from
(
this
.
unprotectedAttrs
o
=
>
o
.
toSchema
(
)
)
}
)
)
;
}
return
(
new
asn1js
.
Sequence
(
{
value
:
outputArray
}
)
)
;
}
public
toJSON
(
)
:
EnvelopedDataJson
{
const
res
:
EnvelopedDataJson
=
{
version
:
this
.
version
recipientInfos
:
Array
.
from
(
this
.
recipientInfos
o
=
>
o
.
toJSON
(
)
)
encryptedContentInfo
:
this
.
encryptedContentInfo
.
toJSON
(
)
}
;
if
(
this
.
originatorInfo
)
res
.
originatorInfo
=
this
.
originatorInfo
.
toJSON
(
)
;
if
(
this
.
unprotectedAttrs
)
res
.
unprotectedAttrs
=
Array
.
from
(
this
.
unprotectedAttrs
o
=
>
o
.
toJSON
(
)
)
;
return
res
;
}
public
addRecipientByCertificate
(
certificate
:
Certificate
parameters
?
:
object
variant
?
:
number
crypto
=
common
.
getCrypto
(
true
)
)
:
boolean
{
const
encryptionParameters
=
Object
.
assign
(
{
useOAEP
:
true
oaepHashAlgorithm
:
"
SHA
-
512
"
}
defaultEncryptionParams
parameters
|
|
{
}
)
;
if
(
certificate
.
subjectPublicKeyInfo
.
algorithm
.
algorithmId
.
indexOf
(
"
1
.
2
.
840
.
113549
"
)
!
=
=
(
-
1
)
)
variant
=
1
;
else
{
if
(
certificate
.
subjectPublicKeyInfo
.
algorithm
.
algorithmId
.
indexOf
(
"
1
.
2
.
840
.
10045
"
)
!
=
=
(
-
1
)
)
variant
=
2
;
else
throw
new
Error
(
Unknown
type
of
certificate
'
s
public
key
:
{
certificate
.
subjectPublicKeyInfo
.
algorithm
.
algorithmId
}
)
;
}
switch
(
variant
)
{
case
1
:
{
let
algorithmId
;
let
algorithmParams
;
if
(
encryptionParameters
.
useOAEP
=
=
=
true
)
{
algorithmId
=
crypto
.
getOIDByAlgorithm
(
{
name
:
"
RSA
-
OAEP
"
}
true
"
keyEncryptionAlgorithm
"
)
;
const
hashOID
=
crypto
.
getOIDByAlgorithm
(
{
name
:
encryptionParameters
.
oaepHashAlgorithm
}
true
"
RSAES
-
OAEP
-
params
"
)
;
const
hashAlgorithm
=
new
AlgorithmIdentifier
(
{
algorithmId
:
hashOID
algorithmParams
:
new
asn1js
.
Null
(
)
}
)
;
const
rsaOAEPParams
=
new
RSAESOAEPParams
(
{
hashAlgorithm
maskGenAlgorithm
:
new
AlgorithmIdentifier
(
{
algorithmId
:
"
1
.
2
.
840
.
113549
.
1
.
1
.
8
"
algorithmParams
:
hashAlgorithm
.
toSchema
(
)
}
)
}
)
;
algorithmParams
=
rsaOAEPParams
.
toSchema
(
)
;
}
else
{
algorithmId
=
crypto
.
getOIDByAlgorithm
(
{
name
:
"
RSAES
-
PKCS1
-
v1_5
"
}
)
;
if
(
algorithmId
=
=
=
EMPTY_STRING
)
throw
new
Error
(
"
Can
not
find
OID
for
RSAES
-
PKCS1
-
v1_5
"
)
;
algorithmParams
=
new
asn1js
.
Null
(
)
;
}
const
keyInfo
=
new
KeyTransRecipientInfo
(
{
version
:
0
rid
:
new
IssuerAndSerialNumber
(
{
issuer
:
certificate
.
issuer
serialNumber
:
certificate
.
serialNumber
}
)
keyEncryptionAlgorithm
:
new
AlgorithmIdentifier
(
{
algorithmId
algorithmParams
}
)
recipientCertificate
:
certificate
}
)
;
this
.
recipientInfos
.
push
(
new
RecipientInfo
(
{
variant
:
1
value
:
keyInfo
}
)
)
;
}
break
;
case
2
:
{
const
recipientIdentifier
=
new
KeyAgreeRecipientIdentifier
(
{
variant
:
1
value
:
new
IssuerAndSerialNumber
(
{
issuer
:
certificate
.
issuer
serialNumber
:
certificate
.
serialNumber
}
)
}
)
;
this
.
_addKeyAgreeRecipientInfo
(
recipientIdentifier
encryptionParameters
{
recipientCertificate
:
certificate
}
crypto
)
;
}
break
;
default
:
throw
new
Error
(
Unknown
"
variant
"
value
:
{
variant
}
)
;
}
return
true
;
}
public
addRecipientByPreDefinedData
(
preDefinedData
:
ArrayBuffer
parameters
:
{
keyIdentifier
?
:
ArrayBuffer
;
hmacHashAlgorithm
?
:
string
;
iterationCount
?
:
number
;
keyEncryptionAlgorithm
?
:
AesKeyGenParams
;
keyEncryptionAlgorithmParams
?
:
any
;
}
=
{
}
variant
:
number
crypto
=
common
.
getCrypto
(
true
)
)
{
ArgumentError
.
assert
(
preDefinedData
"
preDefinedData
"
"
ArrayBuffer
"
)
;
if
(
!
preDefinedData
.
byteLength
)
{
throw
new
Error
(
"
Pre
-
defined
data
could
have
zero
length
"
)
;
}
if
(
!
parameters
.
keyIdentifier
)
{
const
keyIdentifierBuffer
=
new
ArrayBuffer
(
16
)
;
const
keyIdentifierView
=
new
Uint8Array
(
keyIdentifierBuffer
)
;
crypto
.
getRandomValues
(
keyIdentifierView
)
;
parameters
.
keyIdentifier
=
keyIdentifierBuffer
;
}
if
(
!
parameters
.
hmacHashAlgorithm
)
parameters
.
hmacHashAlgorithm
=
"
SHA
-
512
"
;
if
(
parameters
.
iterationCount
=
=
=
undefined
)
{
parameters
.
iterationCount
=
2048
;
}
if
(
!
parameters
.
keyEncryptionAlgorithm
)
{
parameters
.
keyEncryptionAlgorithm
=
{
name
:
"
AES
-
KW
"
length
:
256
}
;
}
if
(
!
parameters
.
keyEncryptionAlgorithmParams
)
parameters
.
keyEncryptionAlgorithmParams
=
new
asn1js
.
Null
(
)
;
switch
(
variant
)
{
case
1
:
{
const
kekOID
=
crypto
.
getOIDByAlgorithm
(
parameters
.
keyEncryptionAlgorithm
true
"
keyEncryptionAlgorithm
"
)
;
const
keyInfo
=
new
KEKRecipientInfo
(
{
version
:
4
kekid
:
new
KEKIdentifier
(
{
keyIdentifier
:
new
asn1js
.
OctetString
(
{
valueHex
:
parameters
.
keyIdentifier
}
)
}
)
keyEncryptionAlgorithm
:
new
AlgorithmIdentifier
(
{
algorithmId
:
kekOID
algorithmParams
:
parameters
.
keyEncryptionAlgorithmParams
}
)
preDefinedKEK
:
preDefinedData
}
)
;
this
.
recipientInfos
.
push
(
new
RecipientInfo
(
{
variant
:
3
value
:
keyInfo
}
)
)
;
}
break
;
case
2
:
{
const
pbkdf2OID
=
crypto
.
getOIDByAlgorithm
(
{
name
:
"
PBKDF2
"
}
true
"
keyDerivationAlgorithm
"
)
;
const
saltBuffer
=
new
ArrayBuffer
(
64
)
;
const
saltView
=
new
Uint8Array
(
saltBuffer
)
;
crypto
.
getRandomValues
(
saltView
)
;
const
hmacOID
=
crypto
.
getOIDByAlgorithm
(
{
name
:
"
HMAC
"
hash
:
{
name
:
parameters
.
hmacHashAlgorithm
}
}
as
Algorithm
true
"
hmacHashAlgorithm
"
)
;
const
pbkdf2Params
=
new
PBKDF2Params
(
{
salt
:
new
asn1js
.
OctetString
(
{
valueHex
:
saltBuffer
}
)
iterationCount
:
parameters
.
iterationCount
prf
:
new
AlgorithmIdentifier
(
{
algorithmId
:
hmacOID
algorithmParams
:
new
asn1js
.
Null
(
)
}
)
}
)
;
const
kekOID
=
crypto
.
getOIDByAlgorithm
(
parameters
.
keyEncryptionAlgorithm
true
"
keyEncryptionAlgorithm
"
)
;
const
keyInfo
=
new
PasswordRecipientinfo
(
{
version
:
0
keyDerivationAlgorithm
:
new
AlgorithmIdentifier
(
{
algorithmId
:
pbkdf2OID
algorithmParams
:
pbkdf2Params
.
toSchema
(
)
}
)
keyEncryptionAlgorithm
:
new
AlgorithmIdentifier
(
{
algorithmId
:
kekOID
algorithmParams
:
parameters
.
keyEncryptionAlgorithmParams
}
)
password
:
preDefinedData
}
)
;
this
.
recipientInfos
.
push
(
new
RecipientInfo
(
{
variant
:
4
value
:
keyInfo
}
)
)
;
}
break
;
default
:
throw
new
Error
(
Unknown
value
for
"
variant
"
:
{
variant
}
)
;
}
}
addRecipientByKeyIdentifier
(
key
?
:
CryptoKey
keyId
?
:
ArrayBuffer
parameters
?
:
any
crypto
=
common
.
getCrypto
(
true
)
)
{
const
encryptionParameters
=
Object
.
assign
(
{
}
defaultEncryptionParams
parameters
|
|
{
}
)
;
const
recipientIdentifier
=
new
KeyAgreeRecipientIdentifier
(
{
variant
:
2
value
:
new
RecipientKeyIdentifier
(
{
subjectKeyIdentifier
:
new
asn1js
.
OctetString
(
{
valueHex
:
keyId
}
)
}
)
}
)
;
this
.
_addKeyAgreeRecipientInfo
(
recipientIdentifier
encryptionParameters
{
recipientPublicKey
:
key
}
crypto
)
;
}
private
_addKeyAgreeRecipientInfo
(
recipientIdentifier
:
KeyAgreeRecipientIdentifier
encryptionParameters
:
EnvelopedDataEncryptionParams
extraRecipientInfoParams
:
KeyAgreeRecipientInfoParameters
crypto
=
common
.
getCrypto
(
true
)
)
{
const
encryptedKey
=
new
RecipientEncryptedKey
(
{
rid
:
recipientIdentifier
}
)
;
const
aesKWoid
=
crypto
.
getOIDByAlgorithm
(
{
name
:
"
AES
-
KW
"
length
:
encryptionParameters
.
kekEncryptionLength
}
as
Algorithm
true
"
keyEncryptionAlgorithm
"
)
;
const
aesKW
=
new
AlgorithmIdentifier
(
{
algorithmId
:
aesKWoid
}
)
;
const
ecdhOID
=
crypto
.
getOIDByAlgorithm
(
{
name
:
"
ECDH
"
kdf
:
encryptionParameters
.
kdfAlgorithm
}
as
Algorithm
true
"
KeyAgreeRecipientInfo
"
)
;
const
ukmBuffer
=
new
ArrayBuffer
(
64
)
;
const
ukmView
=
new
Uint8Array
(
ukmBuffer
)
;
crypto
.
getRandomValues
(
ukmView
)
;
const
recipientInfoParams
=
{
version
:
3
ukm
:
new
asn1js
.
OctetString
(
{
valueHex
:
ukmBuffer
}
)
keyEncryptionAlgorithm
:
new
AlgorithmIdentifier
(
{
algorithmId
:
ecdhOID
algorithmParams
:
aesKW
.
toSchema
(
)
}
)
recipientEncryptedKeys
:
new
RecipientEncryptedKeys
(
{
encryptedKeys
:
[
encryptedKey
]
}
)
}
;
const
keyInfo
=
new
KeyAgreeRecipientInfo
(
Object
.
assign
(
recipientInfoParams
extraRecipientInfoParams
)
)
;
this
.
recipientInfos
.
push
(
new
RecipientInfo
(
{
variant
:
2
value
:
keyInfo
}
)
)
;
}
public
async
encrypt
(
contentEncryptionAlgorithm
:
Algorithm
contentToEncrypt
:
ArrayBuffer
crypto
=
common
.
getCrypto
(
true
)
)
:
Promise
<
(
void
|
{
ecdhPrivateKey
:
CryptoKey
;
}
)
[
]
>
{
const
ivBuffer
=
new
ArrayBuffer
(
16
)
;
const
ivView
=
new
Uint8Array
(
ivBuffer
)
;
crypto
.
getRandomValues
(
ivView
)
;
const
contentView
=
new
Uint8Array
(
contentToEncrypt
)
;
const
contentEncryptionOID
=
crypto
.
getOIDByAlgorithm
(
contentEncryptionAlgorithm
true
"
contentEncryptionAlgorithm
"
)
;
const
sessionKey
=
await
crypto
.
generateKey
(
contentEncryptionAlgorithm
as
AesKeyAlgorithm
true
[
"
encrypt
"
]
)
;
const
encryptedContent
=
await
crypto
.
encrypt
(
{
name
:
contentEncryptionAlgorithm
.
name
iv
:
ivView
}
sessionKey
contentView
)
;
const
exportedSessionKey
=
await
crypto
.
exportKey
(
"
raw
"
sessionKey
)
;
this
.
version
=
2
;
this
.
encryptedContentInfo
=
new
EncryptedContentInfo
(
{
disableSplit
:
this
.
policy
.
disableSplit
contentType
:
"
1
.
2
.
840
.
113549
.
1
.
7
.
1
"
contentEncryptionAlgorithm
:
new
AlgorithmIdentifier
(
{
algorithmId
:
contentEncryptionOID
algorithmParams
:
new
asn1js
.
OctetString
(
{
valueHex
:
ivBuffer
}
)
}
)
encryptedContent
:
new
asn1js
.
OctetString
(
{
valueHex
:
encryptedContent
}
)
}
)
;
const
SubKeyAgreeRecipientInfo
=
async
(
index
:
number
)
=
>
{
const
recipientInfo
=
this
.
recipientInfos
[
index
]
.
value
as
KeyAgreeRecipientInfo
;
let
recipientCurve
:
string
;
let
recipientPublicKey
:
CryptoKey
;
if
(
recipientInfo
.
recipientPublicKey
)
{
recipientCurve
=
(
recipientInfo
.
recipientPublicKey
.
algorithm
as
EcKeyAlgorithm
)
.
namedCurve
;
recipientPublicKey
=
recipientInfo
.
recipientPublicKey
;
}
else
if
(
recipientInfo
.
recipientCertificate
)
{
const
curveObject
=
recipientInfo
.
recipientCertificate
.
subjectPublicKeyInfo
.
algorithm
.
algorithmParams
;
if
(
curveObject
.
constructor
.
blockName
(
)
!
=
=
asn1js
.
ObjectIdentifier
.
blockName
(
)
)
throw
new
Error
(
Incorrect
"
recipientCertificate
"
for
index
{
index
}
)
;
const
curveOID
=
curveObject
.
valueBlock
.
toString
(
)
;
switch
(
curveOID
)
{
case
"
1
.
2
.
840
.
10045
.
3
.
1
.
7
"
:
recipientCurve
=
"
P
-
256
"
;
break
;
case
"
1
.
3
.
132
.
0
.
34
"
:
recipientCurve
=
"
P
-
384
"
;
break
;
case
"
1
.
3
.
132
.
0
.
35
"
:
recipientCurve
=
"
P
-
521
"
;
break
;
default
:
throw
new
Error
(
Incorrect
curve
OID
for
index
{
index
}
)
;
}
recipientPublicKey
=
await
recipientInfo
.
recipientCertificate
.
getPublicKey
(
{
algorithm
:
{
algorithm
:
{
name
:
"
ECDH
"
namedCurve
:
recipientCurve
}
as
EcKeyAlgorithm
usages
:
[
]
}
}
crypto
)
;
}
else
{
throw
new
Error
(
"
Unsupported
RecipientInfo
"
)
;
}
const
recipientCurveLength
=
curveLengthByName
[
recipientCurve
]
;
const
ecdhKeys
=
await
crypto
.
generateKey
(
{
name
:
"
ECDH
"
namedCurve
:
recipientCurve
}
as
EcKeyGenParams
true
[
"
deriveBits
"
]
)
;
const
exportedECDHPublicKey
=
await
crypto
.
exportKey
(
"
spki
"
ecdhKeys
.
publicKey
)
;
const
derivedBits
=
await
crypto
.
deriveBits
(
{
name
:
"
ECDH
"
public
:
recipientPublicKey
}
ecdhKeys
.
privateKey
recipientCurveLength
)
;
const
aesKWAlgorithm
=
new
AlgorithmIdentifier
(
{
schema
:
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmParams
}
)
;
const
kwAlgorithm
=
crypto
.
getAlgorithmByOID
<
AesKeyAlgorithm
>
(
aesKWAlgorithm
.
algorithmId
true
"
aesKWAlgorithm
"
)
;
let
kwLength
=
kwAlgorithm
.
length
;
const
kwLengthBuffer
=
new
ArrayBuffer
(
4
)
;
const
kwLengthView
=
new
Uint8Array
(
kwLengthBuffer
)
;
for
(
let
j
=
3
;
j
>
=
0
;
j
-
-
)
{
kwLengthView
[
j
]
=
kwLength
;
kwLength
>
>
=
8
;
}
const
eccInfo
=
new
ECCCMSSharedInfo
(
{
keyInfo
:
new
AlgorithmIdentifier
(
{
algorithmId
:
aesKWAlgorithm
.
algorithmId
}
)
entityUInfo
:
(
recipientInfo
as
KeyAgreeRecipientInfo
)
.
ukm
suppPubInfo
:
new
asn1js
.
OctetString
(
{
valueHex
:
kwLengthBuffer
}
)
}
)
;
const
encodedInfo
=
eccInfo
.
toSchema
(
)
.
toBER
(
false
)
;
const
ecdhAlgorithm
=
crypto
.
getAlgorithmByOID
<
any
>
(
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmId
true
"
ecdhAlgorithm
"
)
;
const
derivedKeyRaw
=
await
common
.
kdf
(
ecdhAlgorithm
.
kdf
derivedBits
kwAlgorithm
.
length
encodedInfo
crypto
)
;
const
awsKW
=
await
crypto
.
importKey
(
"
raw
"
derivedKeyRaw
{
name
:
"
AES
-
KW
"
}
true
[
"
wrapKey
"
]
)
;
const
wrappedKey
=
await
crypto
.
wrapKey
(
"
raw
"
sessionKey
awsKW
{
name
:
"
AES
-
KW
"
}
)
;
const
originator
=
new
OriginatorIdentifierOrKey
(
)
;
originator
.
variant
=
3
;
originator
.
value
=
OriginatorPublicKey
.
fromBER
(
exportedECDHPublicKey
)
;
recipientInfo
.
originator
=
originator
;
recipientInfo
.
recipientEncryptedKeys
.
encryptedKeys
[
0
]
.
encryptedKey
=
new
asn1js
.
OctetString
(
{
valueHex
:
wrappedKey
}
)
;
return
{
ecdhPrivateKey
:
ecdhKeys
.
privateKey
}
;
}
;
const
SubKeyTransRecipientInfo
=
async
(
index
:
number
)
=
>
{
const
recipientInfo
=
this
.
recipientInfos
[
index
]
.
value
as
KeyTransRecipientInfo
;
const
algorithmParameters
=
crypto
.
getAlgorithmByOID
<
any
>
(
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmId
true
"
keyEncryptionAlgorithm
"
)
;
if
(
algorithmParameters
.
name
=
=
=
"
RSA
-
OAEP
"
)
{
const
schema
=
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmParams
;
const
rsaOAEPParams
=
new
RSAESOAEPParams
(
{
schema
}
)
;
algorithmParameters
.
hash
=
crypto
.
getAlgorithmByOID
(
rsaOAEPParams
.
hashAlgorithm
.
algorithmId
)
;
if
(
(
"
name
"
in
algorithmParameters
.
hash
)
=
=
=
false
)
throw
new
Error
(
Incorrect
OID
for
hash
algorithm
:
{
rsaOAEPParams
.
hashAlgorithm
.
algorithmId
}
)
;
}
try
{
const
publicKey
=
await
recipientInfo
.
recipientCertificate
.
getPublicKey
(
{
algorithm
:
{
algorithm
:
algorithmParameters
usages
:
[
"
encrypt
"
"
wrapKey
"
]
}
}
crypto
)
;
const
encryptedKey
=
await
crypto
.
encrypt
(
publicKey
.
algorithm
publicKey
exportedSessionKey
)
;
recipientInfo
.
encryptedKey
=
new
asn1js
.
OctetString
(
{
valueHex
:
encryptedKey
}
)
;
}
catch
{
}
}
;
const
SubKEKRecipientInfo
=
async
(
index
:
number
)
=
>
{
const
recipientInfo
=
this
.
recipientInfos
[
index
]
.
value
as
KEKRecipientInfo
;
const
kekAlgorithm
=
crypto
.
getAlgorithmByOID
(
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmId
true
"
kekAlgorithm
"
)
;
const
kekKey
=
await
crypto
.
importKey
(
"
raw
"
new
Uint8Array
(
recipientInfo
.
preDefinedKEK
)
kekAlgorithm
true
[
"
wrapKey
"
]
)
;
const
wrappedKey
=
await
crypto
.
wrapKey
(
"
raw
"
sessionKey
kekKey
kekAlgorithm
)
;
recipientInfo
.
encryptedKey
=
new
asn1js
.
OctetString
(
{
valueHex
:
wrappedKey
}
)
;
}
;
const
SubPasswordRecipientinfo
=
async
(
index
:
number
)
=
>
{
const
recipientInfo
=
this
.
recipientInfos
[
index
]
.
value
as
PasswordRecipientinfo
;
let
pbkdf2Params
:
PBKDF2Params
;
if
(
!
recipientInfo
.
keyDerivationAlgorithm
)
throw
new
Error
(
"
Please
append
encoded
\
"
keyDerivationAlgorithm
\
"
"
)
;
if
(
!
recipientInfo
.
keyDerivationAlgorithm
.
algorithmParams
)
throw
new
Error
(
"
Incorrectly
encoded
\
"
keyDerivationAlgorithm
\
"
"
)
;
try
{
pbkdf2Params
=
new
PBKDF2Params
(
{
schema
:
recipientInfo
.
keyDerivationAlgorithm
.
algorithmParams
}
)
;
}
catch
{
throw
new
Error
(
"
Incorrectly
encoded
\
"
keyDerivationAlgorithm
\
"
"
)
;
}
const
passwordView
=
new
Uint8Array
(
recipientInfo
.
password
)
;
const
derivationKey
=
await
crypto
.
importKey
(
"
raw
"
passwordView
"
PBKDF2
"
false
[
"
deriveKey
"
]
)
;
const
kekAlgorithm
=
crypto
.
getAlgorithmByOID
<
any
>
(
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmId
true
"
kekAlgorithm
"
)
;
let
hmacHashAlgorithm
=
"
SHA
-
1
"
;
if
(
pbkdf2Params
.
prf
)
{
const
prfAlgorithm
=
crypto
.
getAlgorithmByOID
<
any
>
(
pbkdf2Params
.
prf
.
algorithmId
true
"
prfAlgorithm
"
)
;
hmacHashAlgorithm
=
prfAlgorithm
.
hash
.
name
;
}
const
saltView
=
new
Uint8Array
(
pbkdf2Params
.
salt
.
valueBlock
.
valueHex
)
;
const
iterations
=
pbkdf2Params
.
iterationCount
;
const
derivedKey
=
await
crypto
.
deriveKey
(
{
name
:
"
PBKDF2
"
hash
:
{
name
:
hmacHashAlgorithm
}
salt
:
saltView
iterations
}
derivationKey
kekAlgorithm
true
[
"
wrapKey
"
]
)
;
const
wrappedKey
=
await
crypto
.
wrapKey
(
"
raw
"
sessionKey
derivedKey
kekAlgorithm
)
;
recipientInfo
.
encryptedKey
=
new
asn1js
.
OctetString
(
{
valueHex
:
wrappedKey
}
)
;
}
;
const
res
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
recipientInfos
.
length
;
i
+
+
)
{
switch
(
this
.
recipientInfos
[
i
]
.
variant
)
{
case
1
:
res
.
push
(
await
SubKeyTransRecipientInfo
(
i
)
)
;
break
;
case
2
:
res
.
push
(
await
SubKeyAgreeRecipientInfo
(
i
)
)
;
break
;
case
3
:
res
.
push
(
await
SubKEKRecipientInfo
(
i
)
)
;
break
;
case
4
:
res
.
push
(
await
SubPasswordRecipientinfo
(
i
)
)
;
break
;
default
:
throw
new
Error
(
Unknown
recipient
type
in
array
with
index
{
i
}
)
;
}
}
return
res
;
}
async
decrypt
(
recipientIndex
:
number
parameters
:
EnvelopedDataDecryptParams
crypto
=
common
.
getCrypto
(
true
)
)
{
const
decryptionParameters
=
parameters
|
|
{
}
;
if
(
(
recipientIndex
+
1
)
>
this
.
recipientInfos
.
length
)
{
throw
new
Error
(
Maximum
value
for
"
index
"
is
:
{
this
.
recipientInfos
.
length
-
1
}
)
;
}
const
SubKeyAgreeRecipientInfo
=
async
(
index
:
number
)
=
>
{
const
recipientInfo
=
this
.
recipientInfos
[
index
]
.
value
as
KeyAgreeRecipientInfo
;
let
curveOID
:
string
;
let
recipientCurve
:
string
;
let
recipientCurveLength
:
number
;
const
originator
=
recipientInfo
.
originator
;
if
(
decryptionParameters
.
recipientCertificate
)
{
const
curveObject
=
decryptionParameters
.
recipientCertificate
.
subjectPublicKeyInfo
.
algorithm
.
algorithmParams
;
if
(
curveObject
.
constructor
.
blockName
(
)
!
=
=
asn1js
.
ObjectIdentifier
.
blockName
(
)
)
{
throw
new
Error
(
Incorrect
"
recipientCertificate
"
for
index
{
index
}
)
;
}
curveOID
=
curveObject
.
valueBlock
.
toString
(
)
;
}
else
if
(
originator
.
value
.
algorithm
.
algorithmParams
)
{
const
curveObject
=
originator
.
value
.
algorithm
.
algorithmParams
;
if
(
curveObject
.
constructor
.
blockName
(
)
!
=
=
asn1js
.
ObjectIdentifier
.
blockName
(
)
)
{
throw
new
Error
(
Incorrect
originator
for
index
{
index
}
)
;
}
curveOID
=
curveObject
.
valueBlock
.
toString
(
)
;
}
else
{
throw
new
Error
(
"
Parameter
\
"
recipientCertificate
\
"
is
mandatory
for
\
"
KeyAgreeRecipientInfo
\
"
if
algorithm
params
are
missing
from
originator
"
)
;
}
if
(
!
decryptionParameters
.
recipientPrivateKey
)
throw
new
Error
(
"
Parameter
\
"
recipientPrivateKey
\
"
is
mandatory
for
\
"
KeyAgreeRecipientInfo
\
"
"
)
;
switch
(
curveOID
)
{
case
"
1
.
2
.
840
.
10045
.
3
.
1
.
7
"
:
recipientCurve
=
"
P
-
256
"
;
recipientCurveLength
=
256
;
break
;
case
"
1
.
3
.
132
.
0
.
34
"
:
recipientCurve
=
"
P
-
384
"
;
recipientCurveLength
=
384
;
break
;
case
"
1
.
3
.
132
.
0
.
35
"
:
recipientCurve
=
"
P
-
521
"
;
recipientCurveLength
=
528
;
break
;
default
:
throw
new
Error
(
Incorrect
curve
OID
for
index
{
index
}
)
;
}
let
ecdhPrivateKey
:
CryptoKey
;
let
keyCrypto
:
SubtleCrypto
=
crypto
;
if
(
BufferSourceConverter
.
isBufferSource
(
decryptionParameters
.
recipientPrivateKey
)
)
{
ecdhPrivateKey
=
await
crypto
.
importKey
(
"
pkcs8
"
decryptionParameters
.
recipientPrivateKey
{
name
:
"
ECDH
"
namedCurve
:
recipientCurve
}
as
EcKeyImportParams
true
[
"
deriveBits
"
]
)
;
}
else
{
ecdhPrivateKey
=
decryptionParameters
.
recipientPrivateKey
;
if
(
"
crypto
"
in
decryptionParameters
&
&
decryptionParameters
.
crypto
)
{
keyCrypto
=
decryptionParameters
.
crypto
.
subtle
;
}
}
if
(
(
"
algorithmParams
"
in
originator
.
value
.
algorithm
)
=
=
=
false
)
originator
.
value
.
algorithm
.
algorithmParams
=
new
asn1js
.
ObjectIdentifier
(
{
value
:
curveOID
}
)
;
const
buffer
=
originator
.
value
.
toSchema
(
)
.
toBER
(
false
)
;
const
ecdhPublicKey
=
await
crypto
.
importKey
(
"
spki
"
buffer
{
name
:
"
ECDH
"
namedCurve
:
recipientCurve
}
as
EcKeyImportParams
true
[
]
)
;
const
sharedSecret
=
await
keyCrypto
.
deriveBits
(
{
name
:
"
ECDH
"
public
:
ecdhPublicKey
}
ecdhPrivateKey
recipientCurveLength
)
;
async
function
applyKDF
(
includeAlgorithmParams
?
:
boolean
)
{
includeAlgorithmParams
=
includeAlgorithmParams
|
|
false
;
const
aesKWAlgorithm
=
new
AlgorithmIdentifier
(
{
schema
:
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmParams
}
)
;
const
kwAlgorithm
=
crypto
.
getAlgorithmByOID
<
any
>
(
aesKWAlgorithm
.
algorithmId
true
"
kwAlgorithm
"
)
;
let
kwLength
=
kwAlgorithm
.
length
;
const
kwLengthBuffer
=
new
ArrayBuffer
(
4
)
;
const
kwLengthView
=
new
Uint8Array
(
kwLengthBuffer
)
;
for
(
let
j
=
3
;
j
>
=
0
;
j
-
-
)
{
kwLengthView
[
j
]
=
kwLength
;
kwLength
>
>
=
8
;
}
const
keyInfoAlgorithm
:
AlgorithmIdentifierParameters
=
{
algorithmId
:
aesKWAlgorithm
.
algorithmId
}
;
if
(
includeAlgorithmParams
)
{
keyInfoAlgorithm
.
algorithmParams
=
new
asn1js
.
Null
(
)
;
}
const
eccInfo
=
new
ECCCMSSharedInfo
(
{
keyInfo
:
new
AlgorithmIdentifier
(
keyInfoAlgorithm
)
entityUInfo
:
recipientInfo
.
ukm
suppPubInfo
:
new
asn1js
.
OctetString
(
{
valueHex
:
kwLengthBuffer
}
)
}
)
;
const
encodedInfo
=
eccInfo
.
toSchema
(
)
.
toBER
(
false
)
;
const
ecdhAlgorithm
=
crypto
.
getAlgorithmByOID
<
any
>
(
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmId
true
"
ecdhAlgorithm
"
)
;
if
(
!
ecdhAlgorithm
.
name
)
{
throw
new
Error
(
Incorrect
OID
for
key
encryption
algorithm
:
{
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmId
}
)
;
}
return
common
.
kdf
(
ecdhAlgorithm
.
kdf
sharedSecret
kwAlgorithm
.
length
encodedInfo
crypto
)
;
}
const
kdfResult
=
await
applyKDF
(
)
;
const
importAesKwKey
=
async
(
kdfResult
:
ArrayBuffer
)
=
>
{
return
crypto
.
importKey
(
"
raw
"
kdfResult
{
name
:
"
AES
-
KW
"
}
true
[
"
unwrapKey
"
]
)
;
}
;
const
aesKwKey
=
await
importAesKwKey
(
kdfResult
)
;
const
unwrapSessionKey
=
async
(
aesKwKey
:
CryptoKey
)
=
>
{
const
algorithmId
=
this
.
encryptedContentInfo
.
contentEncryptionAlgorithm
.
algorithmId
;
const
contentEncryptionAlgorithm
=
crypto
.
getAlgorithmByOID
<
any
>
(
algorithmId
true
"
contentEncryptionAlgorithm
"
)
;
return
crypto
.
unwrapKey
(
"
raw
"
recipientInfo
.
recipientEncryptedKeys
.
encryptedKeys
[
0
]
.
encryptedKey
.
valueBlock
.
valueHexView
as
BufferSource
aesKwKey
{
name
:
"
AES
-
KW
"
}
contentEncryptionAlgorithm
true
[
"
decrypt
"
]
)
;
}
;
try
{
return
await
unwrapSessionKey
(
aesKwKey
)
;
}
catch
{
const
kdfResult
=
await
applyKDF
(
true
)
;
const
aesKwKey
=
await
importAesKwKey
(
kdfResult
)
;
return
unwrapSessionKey
(
aesKwKey
)
;
}
}
;
const
SubKeyTransRecipientInfo
=
async
(
index
:
number
)
=
>
{
const
recipientInfo
=
this
.
recipientInfos
[
index
]
.
value
as
KeyTransRecipientInfo
;
if
(
!
decryptionParameters
.
recipientPrivateKey
)
{
throw
new
Error
(
"
Parameter
\
"
recipientPrivateKey
\
"
is
mandatory
for
\
"
KeyTransRecipientInfo
\
"
"
)
;
}
const
algorithmParameters
=
crypto
.
getAlgorithmByOID
<
any
>
(
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmId
true
"
keyEncryptionAlgorithm
"
)
;
if
(
algorithmParameters
.
name
=
=
=
"
RSA
-
OAEP
"
)
{
const
schema
=
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmParams
;
const
rsaOAEPParams
=
new
RSAESOAEPParams
(
{
schema
}
)
;
algorithmParameters
.
hash
=
crypto
.
getAlgorithmByOID
(
rsaOAEPParams
.
hashAlgorithm
.
algorithmId
)
;
if
(
(
"
name
"
in
algorithmParameters
.
hash
)
=
=
=
false
)
throw
new
Error
(
Incorrect
OID
for
hash
algorithm
:
{
rsaOAEPParams
.
hashAlgorithm
.
algorithmId
}
)
;
}
let
privateKey
:
CryptoKey
;
let
keyCrypto
:
SubtleCrypto
=
crypto
;
if
(
BufferSourceConverter
.
isBufferSource
(
decryptionParameters
.
recipientPrivateKey
)
)
{
privateKey
=
await
crypto
.
importKey
(
"
pkcs8
"
decryptionParameters
.
recipientPrivateKey
algorithmParameters
true
[
"
decrypt
"
]
)
;
}
else
{
privateKey
=
decryptionParameters
.
recipientPrivateKey
;
if
(
"
crypto
"
in
decryptionParameters
&
&
decryptionParameters
.
crypto
)
{
keyCrypto
=
decryptionParameters
.
crypto
.
subtle
;
}
}
const
sessionKey
=
await
keyCrypto
.
decrypt
(
privateKey
.
algorithm
privateKey
recipientInfo
.
encryptedKey
.
valueBlock
.
valueHexView
as
BufferSource
)
;
const
algorithmId
=
this
.
encryptedContentInfo
.
contentEncryptionAlgorithm
.
algorithmId
;
const
contentEncryptionAlgorithm
=
crypto
.
getAlgorithmByOID
(
algorithmId
true
"
contentEncryptionAlgorithm
"
)
;
if
(
(
"
name
"
in
contentEncryptionAlgorithm
)
=
=
=
false
)
throw
new
Error
(
Incorrect
"
contentEncryptionAlgorithm
"
:
{
algorithmId
}
)
;
return
crypto
.
importKey
(
"
raw
"
sessionKey
contentEncryptionAlgorithm
true
[
"
decrypt
"
]
)
;
}
;
const
SubKEKRecipientInfo
=
async
(
index
:
number
)
=
>
{
const
recipientInfo
=
this
.
recipientInfos
[
index
]
.
value
as
KEKRecipientInfo
;
if
(
!
decryptionParameters
.
preDefinedData
)
throw
new
Error
(
"
Parameter
\
"
preDefinedData
\
"
is
mandatory
for
\
"
KEKRecipientInfo
\
"
"
)
;
const
kekAlgorithm
=
crypto
.
getAlgorithmByOID
<
any
>
(
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmId
true
"
kekAlgorithm
"
)
;
const
importedKey
=
await
crypto
.
importKey
(
"
raw
"
decryptionParameters
.
preDefinedData
kekAlgorithm
true
[
"
unwrapKey
"
]
)
;
const
algorithmId
=
this
.
encryptedContentInfo
.
contentEncryptionAlgorithm
.
algorithmId
;
const
contentEncryptionAlgorithm
=
crypto
.
getAlgorithmByOID
<
any
>
(
algorithmId
true
"
contentEncryptionAlgorithm
"
)
;
if
(
!
contentEncryptionAlgorithm
.
name
)
{
throw
new
Error
(
Incorrect
"
contentEncryptionAlgorithm
"
:
{
algorithmId
}
)
;
}
return
crypto
.
unwrapKey
(
"
raw
"
recipientInfo
.
encryptedKey
.
valueBlock
.
valueHexView
as
BufferSource
importedKey
kekAlgorithm
contentEncryptionAlgorithm
true
[
"
decrypt
"
]
)
;
}
;
const
SubPasswordRecipientinfo
=
async
(
index
:
number
)
=
>
{
const
recipientInfo
=
this
.
recipientInfos
[
index
]
.
value
as
PasswordRecipientinfo
;
let
pbkdf2Params
:
PBKDF2Params
;
if
(
!
decryptionParameters
.
preDefinedData
)
{
throw
new
Error
(
"
Parameter
\
"
preDefinedData
\
"
is
mandatory
for
\
"
KEKRecipientInfo
\
"
"
)
;
}
if
(
!
recipientInfo
.
keyDerivationAlgorithm
)
{
throw
new
Error
(
"
Please
append
encoded
\
"
keyDerivationAlgorithm
\
"
"
)
;
}
if
(
!
recipientInfo
.
keyDerivationAlgorithm
.
algorithmParams
)
{
throw
new
Error
(
"
Incorrectly
encoded
\
"
keyDerivationAlgorithm
\
"
"
)
;
}
try
{
pbkdf2Params
=
new
PBKDF2Params
(
{
schema
:
recipientInfo
.
keyDerivationAlgorithm
.
algorithmParams
}
)
;
}
catch
{
throw
new
Error
(
"
Incorrectly
encoded
\
"
keyDerivationAlgorithm
\
"
"
)
;
}
const
pbkdf2Key
=
await
crypto
.
importKey
(
"
raw
"
decryptionParameters
.
preDefinedData
"
PBKDF2
"
false
[
"
deriveKey
"
]
)
;
const
kekAlgorithm
=
crypto
.
getAlgorithmByOID
<
any
>
(
recipientInfo
.
keyEncryptionAlgorithm
.
algorithmId
true
"
keyEncryptionAlgorithm
"
)
;
const
hmacHashAlgorithm
=
pbkdf2Params
.
prf
?
crypto
.
getAlgorithmByOID
<
any
>
(
pbkdf2Params
.
prf
.
algorithmId
true
"
prfAlgorithm
"
)
.
hash
.
name
:
"
SHA
-
1
"
;
const
saltView
=
new
Uint8Array
(
pbkdf2Params
.
salt
.
valueBlock
.
valueHex
)
;
const
iterations
=
pbkdf2Params
.
iterationCount
;
const
kekKey
=
await
crypto
.
deriveKey
(
{
name
:
"
PBKDF2
"
hash
:
{
name
:
hmacHashAlgorithm
}
salt
:
saltView
iterations
}
pbkdf2Key
kekAlgorithm
true
[
"
unwrapKey
"
]
)
;
const
algorithmId
=
this
.
encryptedContentInfo
.
contentEncryptionAlgorithm
.
algorithmId
;
const
contentEncryptionAlgorithm
=
crypto
.
getAlgorithmByOID
<
any
>
(
algorithmId
true
"
contentEncryptionAlgorithm
"
)
;
return
crypto
.
unwrapKey
(
"
raw
"
recipientInfo
.
encryptedKey
.
valueBlock
.
valueHexView
as
BufferSource
kekKey
kekAlgorithm
contentEncryptionAlgorithm
true
[
"
decrypt
"
]
)
;
}
;
let
unwrappedKey
:
CryptoKey
;
switch
(
this
.
recipientInfos
[
recipientIndex
]
.
variant
)
{
case
1
:
unwrappedKey
=
await
SubKeyTransRecipientInfo
(
recipientIndex
)
;
break
;
case
2
:
unwrappedKey
=
await
SubKeyAgreeRecipientInfo
(
recipientIndex
)
;
break
;
case
3
:
unwrappedKey
=
await
SubKEKRecipientInfo
(
recipientIndex
)
;
break
;
case
4
:
unwrappedKey
=
await
SubPasswordRecipientinfo
(
recipientIndex
)
;
break
;
default
:
throw
new
Error
(
Unknown
recipient
type
in
array
with
index
{
recipientIndex
}
)
;
}
const
algorithmId
=
this
.
encryptedContentInfo
.
contentEncryptionAlgorithm
.
algorithmId
;
const
contentEncryptionAlgorithm
=
crypto
.
getAlgorithmByOID
(
algorithmId
true
"
contentEncryptionAlgorithm
"
)
;
const
ivBuffer
=
this
.
encryptedContentInfo
.
contentEncryptionAlgorithm
.
algorithmParams
.
valueBlock
.
valueHex
;
const
ivView
=
new
Uint8Array
(
ivBuffer
)
;
if
(
!
this
.
encryptedContentInfo
.
encryptedContent
)
{
throw
new
Error
(
"
Required
property
encryptedContent
is
empty
"
)
;
}
const
dataBuffer
=
this
.
encryptedContentInfo
.
getEncryptedContent
(
)
;
return
crypto
.
decrypt
(
{
name
:
(
contentEncryptionAlgorithm
as
any
)
.
name
iv
:
ivView
}
unwrappedKey
dataBuffer
)
;
}
}
