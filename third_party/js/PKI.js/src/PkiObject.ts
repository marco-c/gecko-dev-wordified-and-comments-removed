import
*
as
asn1js
from
"
asn1js
"
;
import
*
as
pvtsutils
from
"
pvtsutils
"
;
import
{
AsnError
}
from
"
.
/
errors
"
;
import
*
as
Schema
from
"
.
/
Schema
"
;
export
interface
PkiObjectParameters
{
schema
?
:
Schema
.
SchemaType
;
}
interface
PkiObjectConstructor
<
T
extends
PkiObject
=
PkiObject
>
{
new
(
params
:
PkiObjectParameters
)
:
T
;
CLASS_NAME
:
string
;
}
export
abstract
class
PkiObject
{
public
static
CLASS_NAME
=
"
PkiObject
"
;
public
static
blockName
(
)
:
string
{
return
this
.
CLASS_NAME
;
}
public
static
fromBER
<
T
extends
PkiObject
>
(
this
:
PkiObjectConstructor
<
T
>
raw
:
BufferSource
)
:
T
{
const
asn1
=
asn1js
.
fromBER
(
raw
)
;
AsnError
.
assert
(
asn1
this
.
name
)
;
try
{
return
new
this
(
{
schema
:
asn1
.
result
}
)
;
}
catch
(
e
)
{
throw
new
AsnError
(
Cannot
create
'
{
this
.
CLASS_NAME
}
'
from
ASN
.
1
object
)
;
}
}
public
static
defaultValues
(
memberName
:
string
)
:
any
{
throw
new
Error
(
Invalid
member
name
for
{
this
.
CLASS_NAME
}
class
:
{
memberName
}
)
;
}
public
static
schema
(
parameters
:
Schema
.
SchemaParameters
=
{
}
)
:
Schema
.
SchemaType
{
throw
new
Error
(
Method
'
{
this
.
CLASS_NAME
}
.
schema
'
should
be
overridden
)
;
}
public
get
className
(
)
:
string
{
return
(
this
.
constructor
as
unknown
as
{
CLASS_NAME
:
string
;
}
)
.
CLASS_NAME
;
}
public
abstract
fromSchema
(
schema
:
Schema
.
SchemaType
)
:
void
;
public
abstract
toSchema
(
encodeFlag
?
:
boolean
)
:
Schema
.
SchemaType
;
public
abstract
toJSON
(
)
:
any
;
public
toString
(
encoding
:
"
hex
"
|
"
base64
"
|
"
base64url
"
=
"
hex
"
)
:
string
{
let
schema
:
Schema
.
SchemaType
;
try
{
schema
=
this
.
toSchema
(
)
;
}
catch
{
schema
=
this
.
toSchema
(
true
)
;
}
return
pvtsutils
.
Convert
.
ToString
(
schema
.
toBER
(
)
encoding
)
;
}
}
