import
*
as
asn1js
from
"
asn1js
"
;
import
*
as
pvtsutils
from
"
pvtsutils
"
;
import
*
as
pvutils
from
"
pvutils
"
;
import
*
as
common
from
"
.
/
common
"
;
import
{
PublicKeyInfo
PublicKeyInfoJson
}
from
"
.
/
PublicKeyInfo
"
;
import
{
RelativeDistinguishedNames
RelativeDistinguishedNamesJson
RelativeDistinguishedNamesSchema
}
from
"
.
/
RelativeDistinguishedNames
"
;
import
{
AlgorithmIdentifier
AlgorithmIdentifierJson
}
from
"
.
/
AlgorithmIdentifier
"
;
import
{
Attribute
AttributeJson
AttributeSchema
}
from
"
.
/
Attribute
"
;
import
*
as
Schema
from
"
.
/
Schema
"
;
import
{
CryptoEnginePublicKeyParams
}
from
"
.
/
CryptoEngine
/
CryptoEngineInterface
"
;
import
{
AsnError
}
from
"
.
/
errors
"
;
import
{
PkiObject
PkiObjectParameters
}
from
"
.
/
PkiObject
"
;
import
{
EMPTY_BUFFER
}
from
"
.
/
constants
"
;
const
TBS
=
"
tbs
"
;
const
VERSION
=
"
version
"
;
const
SUBJECT
=
"
subject
"
;
const
SPKI
=
"
subjectPublicKeyInfo
"
;
const
ATTRIBUTES
=
"
attributes
"
;
const
SIGNATURE_ALGORITHM
=
"
signatureAlgorithm
"
;
const
SIGNATURE_VALUE
=
"
signatureValue
"
;
const
CSR_INFO
=
"
CertificationRequestInfo
"
;
const
CSR_INFO_VERSION
=
{
CSR_INFO
}
.
version
;
const
CSR_INFO_SUBJECT
=
{
CSR_INFO
}
.
subject
;
const
CSR_INFO_SPKI
=
{
CSR_INFO
}
.
subjectPublicKeyInfo
;
const
CSR_INFO_ATTRS
=
{
CSR_INFO
}
.
attributes
;
const
CLEAR_PROPS
=
[
CSR_INFO
CSR_INFO_VERSION
CSR_INFO_SUBJECT
CSR_INFO_SPKI
CSR_INFO_ATTRS
SIGNATURE_ALGORITHM
SIGNATURE_VALUE
]
;
export
interface
ICertificationRequest
{
tbs
:
ArrayBuffer
;
version
:
number
;
subject
:
RelativeDistinguishedNames
;
subjectPublicKeyInfo
:
PublicKeyInfo
;
attributes
?
:
Attribute
[
]
;
signatureAlgorithm
:
AlgorithmIdentifier
;
signatureValue
:
asn1js
.
BitString
;
}
export
interface
CertificationRequestJson
{
tbs
:
string
;
version
:
number
;
subject
:
RelativeDistinguishedNamesJson
;
subjectPublicKeyInfo
:
PublicKeyInfoJson
|
JsonWebKey
;
attributes
?
:
AttributeJson
[
]
;
signatureAlgorithm
:
AlgorithmIdentifierJson
;
signatureValue
:
asn1js
.
BitStringJson
;
}
export
interface
CertificationRequestInfoParameters
{
names
?
:
{
blockName
?
:
string
;
CertificationRequestInfo
?
:
string
;
CertificationRequestInfoVersion
?
:
string
;
subject
?
:
RelativeDistinguishedNamesSchema
;
CertificationRequestInfoAttributes
?
:
string
;
attributes
?
:
AttributeSchema
;
}
;
}
function
CertificationRequestInfo
(
parameters
:
CertificationRequestInfoParameters
=
{
}
)
{
const
names
=
pvutils
.
getParametersValue
<
NonNullable
<
typeof
parameters
.
names
>
>
(
parameters
"
names
"
{
}
)
;
return
(
new
asn1js
.
Sequence
(
{
name
:
(
names
.
CertificationRequestInfo
|
|
CSR_INFO
)
value
:
[
new
asn1js
.
Integer
(
{
name
:
(
names
.
CertificationRequestInfoVersion
|
|
CSR_INFO_VERSION
)
}
)
RelativeDistinguishedNames
.
schema
(
names
.
subject
|
|
{
names
:
{
blockName
:
CSR_INFO_SUBJECT
}
}
)
PublicKeyInfo
.
schema
(
{
names
:
{
blockName
:
CSR_INFO_SPKI
}
}
)
new
asn1js
.
Constructed
(
{
optional
:
true
idBlock
:
{
tagClass
:
3
tagNumber
:
0
}
value
:
[
new
asn1js
.
Repeated
(
{
optional
:
true
name
:
(
names
.
CertificationRequestInfoAttributes
|
|
CSR_INFO_ATTRS
)
value
:
Attribute
.
schema
(
names
.
attributes
|
|
{
}
)
}
)
]
}
)
]
}
)
)
;
}
export
type
CertificationRequestParameters
=
PkiObjectParameters
&
Partial
<
ICertificationRequest
>
;
export
class
CertificationRequest
extends
PkiObject
implements
ICertificationRequest
{
public
static
override
CLASS_NAME
=
"
CertificationRequest
"
;
public
tbsView
!
:
Uint8Array
;
public
get
tbs
(
)
:
ArrayBuffer
{
return
pvtsutils
.
BufferSourceConverter
.
toArrayBuffer
(
this
.
tbsView
)
;
}
public
set
tbs
(
value
:
ArrayBuffer
)
{
this
.
tbsView
=
new
Uint8Array
(
value
)
;
}
public
version
!
:
number
;
public
subject
!
:
RelativeDistinguishedNames
;
public
subjectPublicKeyInfo
!
:
PublicKeyInfo
;
public
attributes
?
:
Attribute
[
]
;
public
signatureAlgorithm
!
:
AlgorithmIdentifier
;
public
signatureValue
!
:
asn1js
.
BitString
;
constructor
(
parameters
:
CertificationRequestParameters
=
{
}
)
{
super
(
)
;
this
.
tbsView
=
new
Uint8Array
(
pvutils
.
getParametersValue
(
parameters
TBS
CertificationRequest
.
defaultValues
(
TBS
)
)
)
;
this
.
version
=
pvutils
.
getParametersValue
(
parameters
VERSION
CertificationRequest
.
defaultValues
(
VERSION
)
)
;
this
.
subject
=
pvutils
.
getParametersValue
(
parameters
SUBJECT
CertificationRequest
.
defaultValues
(
SUBJECT
)
)
;
this
.
subjectPublicKeyInfo
=
pvutils
.
getParametersValue
(
parameters
SPKI
CertificationRequest
.
defaultValues
(
SPKI
)
)
;
if
(
ATTRIBUTES
in
parameters
)
{
this
.
attributes
=
pvutils
.
getParametersValue
(
parameters
ATTRIBUTES
CertificationRequest
.
defaultValues
(
ATTRIBUTES
)
)
;
}
this
.
signatureAlgorithm
=
pvutils
.
getParametersValue
(
parameters
SIGNATURE_ALGORITHM
CertificationRequest
.
defaultValues
(
SIGNATURE_ALGORITHM
)
)
;
this
.
signatureValue
=
pvutils
.
getParametersValue
(
parameters
SIGNATURE_VALUE
CertificationRequest
.
defaultValues
(
SIGNATURE_VALUE
)
)
;
if
(
parameters
.
schema
)
{
this
.
fromSchema
(
parameters
.
schema
)
;
}
}
public
static
override
defaultValues
(
memberName
:
typeof
TBS
)
:
ArrayBuffer
;
public
static
override
defaultValues
(
memberName
:
typeof
VERSION
)
:
number
;
public
static
override
defaultValues
(
memberName
:
typeof
SUBJECT
)
:
RelativeDistinguishedNames
;
public
static
override
defaultValues
(
memberName
:
typeof
SPKI
)
:
PublicKeyInfo
;
public
static
override
defaultValues
(
memberName
:
typeof
ATTRIBUTES
)
:
Attribute
[
]
;
public
static
override
defaultValues
(
memberName
:
typeof
SIGNATURE_ALGORITHM
)
:
AlgorithmIdentifier
;
public
static
override
defaultValues
(
memberName
:
typeof
SIGNATURE_VALUE
)
:
asn1js
.
BitString
;
public
static
override
defaultValues
(
memberName
:
string
)
:
any
{
switch
(
memberName
)
{
case
TBS
:
return
EMPTY_BUFFER
;
case
VERSION
:
return
0
;
case
SUBJECT
:
return
new
RelativeDistinguishedNames
(
)
;
case
SPKI
:
return
new
PublicKeyInfo
(
)
;
case
ATTRIBUTES
:
return
[
]
;
case
SIGNATURE_ALGORITHM
:
return
new
AlgorithmIdentifier
(
)
;
case
SIGNATURE_VALUE
:
return
new
asn1js
.
BitString
(
)
;
default
:
return
super
.
defaultValues
(
memberName
)
;
}
}
static
override
schema
(
parameters
:
Schema
.
SchemaParameters
<
{
certificationRequestInfo
?
:
CertificationRequestInfoParameters
;
signatureAlgorithm
?
:
string
;
signatureValue
?
:
string
;
}
>
=
{
}
)
:
Schema
.
SchemaType
{
const
names
=
pvutils
.
getParametersValue
<
NonNullable
<
typeof
parameters
.
names
>
>
(
parameters
"
names
"
{
}
)
;
return
(
new
asn1js
.
Sequence
(
{
value
:
[
CertificationRequestInfo
(
names
.
certificationRequestInfo
|
|
{
}
)
new
asn1js
.
Sequence
(
{
name
:
(
names
.
signatureAlgorithm
|
|
SIGNATURE_ALGORITHM
)
value
:
[
new
asn1js
.
ObjectIdentifier
(
)
new
asn1js
.
Any
(
{
optional
:
true
}
)
]
}
)
new
asn1js
.
BitString
(
{
name
:
(
names
.
signatureValue
|
|
SIGNATURE_VALUE
)
}
)
]
}
)
)
;
}
public
fromSchema
(
schema
:
Schema
.
SchemaType
)
:
void
{
pvutils
.
clearProps
(
schema
CLEAR_PROPS
)
;
const
asn1
=
asn1js
.
compareSchema
(
schema
schema
CertificationRequest
.
schema
(
)
)
;
AsnError
.
assertSchema
(
asn1
this
.
className
)
;
this
.
tbsView
=
(
asn1
.
result
.
CertificationRequestInfo
as
asn1js
.
Sequence
)
.
valueBeforeDecodeView
;
this
.
version
=
asn1
.
result
[
CSR_INFO_VERSION
]
.
valueBlock
.
valueDec
;
this
.
subject
=
new
RelativeDistinguishedNames
(
{
schema
:
asn1
.
result
[
CSR_INFO_SUBJECT
]
}
)
;
this
.
subjectPublicKeyInfo
=
new
PublicKeyInfo
(
{
schema
:
asn1
.
result
[
CSR_INFO_SPKI
]
}
)
;
if
(
CSR_INFO_ATTRS
in
asn1
.
result
)
{
this
.
attributes
=
Array
.
from
(
asn1
.
result
[
CSR_INFO_ATTRS
]
element
=
>
new
Attribute
(
{
schema
:
element
}
)
)
;
}
this
.
signatureAlgorithm
=
new
AlgorithmIdentifier
(
{
schema
:
asn1
.
result
.
signatureAlgorithm
}
)
;
this
.
signatureValue
=
asn1
.
result
.
signatureValue
;
}
protected
encodeTBS
(
)
:
asn1js
.
Sequence
{
const
outputArray
=
[
new
asn1js
.
Integer
(
{
value
:
this
.
version
}
)
this
.
subject
.
toSchema
(
)
this
.
subjectPublicKeyInfo
.
toSchema
(
)
]
;
if
(
ATTRIBUTES
in
this
)
{
outputArray
.
push
(
new
asn1js
.
Constructed
(
{
idBlock
:
{
tagClass
:
3
tagNumber
:
0
}
value
:
Array
.
from
(
this
.
attributes
|
|
[
]
o
=
>
o
.
toSchema
(
)
)
}
)
)
;
}
return
(
new
asn1js
.
Sequence
(
{
value
:
outputArray
}
)
)
;
}
public
toSchema
(
encodeFlag
=
false
)
:
asn1js
.
Sequence
{
let
tbsSchema
;
if
(
encodeFlag
=
=
=
false
)
{
if
(
this
.
tbsView
.
byteLength
=
=
=
0
)
{
return
CertificationRequest
.
schema
(
)
;
}
const
asn1
=
asn1js
.
fromBER
(
this
.
tbsView
)
;
AsnError
.
assert
(
asn1
"
PKCS
#
10
Certificate
Request
"
)
;
tbsSchema
=
asn1
.
result
;
}
else
{
tbsSchema
=
this
.
encodeTBS
(
)
;
}
return
(
new
asn1js
.
Sequence
(
{
value
:
[
tbsSchema
this
.
signatureAlgorithm
.
toSchema
(
)
this
.
signatureValue
]
}
)
)
;
}
public
toJSON
(
)
:
CertificationRequestJson
{
const
object
:
CertificationRequestJson
=
{
tbs
:
pvtsutils
.
Convert
.
ToHex
(
this
.
tbsView
)
version
:
this
.
version
subject
:
this
.
subject
.
toJSON
(
)
subjectPublicKeyInfo
:
this
.
subjectPublicKeyInfo
.
toJSON
(
)
signatureAlgorithm
:
this
.
signatureAlgorithm
.
toJSON
(
)
signatureValue
:
this
.
signatureValue
.
toJSON
(
)
}
;
if
(
ATTRIBUTES
in
this
)
{
object
.
attributes
=
Array
.
from
(
this
.
attributes
|
|
[
]
o
=
>
o
.
toJSON
(
)
)
;
}
return
object
;
}
async
sign
(
privateKey
:
CryptoKey
hashAlgorithm
=
"
SHA
-
1
"
crypto
=
common
.
getCrypto
(
true
)
)
:
Promise
<
void
>
{
if
(
!
privateKey
)
{
throw
new
Error
(
"
Need
to
provide
a
private
key
for
signing
"
)
;
}
const
signatureParams
=
await
crypto
.
getSignatureParameters
(
privateKey
hashAlgorithm
)
;
const
parameters
=
signatureParams
.
parameters
;
this
.
signatureAlgorithm
=
signatureParams
.
signatureAlgorithm
;
this
.
tbsView
=
new
Uint8Array
(
this
.
encodeTBS
(
)
.
toBER
(
)
)
;
const
signature
=
await
crypto
.
signWithPrivateKey
(
this
.
tbsView
privateKey
parameters
as
any
)
;
this
.
signatureValue
=
new
asn1js
.
BitString
(
{
valueHex
:
signature
}
)
;
}
public
async
verify
(
crypto
=
common
.
getCrypto
(
true
)
)
:
Promise
<
boolean
>
{
return
crypto
.
verifyWithPublicKey
(
this
.
tbsView
this
.
signatureValue
this
.
subjectPublicKeyInfo
this
.
signatureAlgorithm
)
;
}
public
async
getPublicKey
(
parameters
?
:
CryptoEnginePublicKeyParams
crypto
=
common
.
getCrypto
(
true
)
)
:
Promise
<
CryptoKey
>
{
return
crypto
.
getPublicKey
(
this
.
subjectPublicKeyInfo
this
.
signatureAlgorithm
parameters
)
;
}
}
