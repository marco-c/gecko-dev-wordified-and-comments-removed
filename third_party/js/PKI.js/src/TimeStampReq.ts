import
*
as
asn1js
from
"
asn1js
"
;
import
*
as
pvutils
from
"
pvutils
"
;
import
{
MessageImprint
MessageImprintJson
MessageImprintSchema
}
from
"
.
/
MessageImprint
"
;
import
{
Extension
ExtensionJson
}
from
"
.
/
Extension
"
;
import
*
as
Schema
from
"
.
/
Schema
"
;
import
{
PkiObject
PkiObjectParameters
}
from
"
.
/
PkiObject
"
;
import
{
AsnError
}
from
"
.
/
errors
"
;
import
{
EMPTY_STRING
}
from
"
.
/
constants
"
;
const
VERSION
=
"
version
"
;
const
MESSAGE_IMPRINT
=
"
messageImprint
"
;
const
REQ_POLICY
=
"
reqPolicy
"
;
const
NONCE
=
"
nonce
"
;
const
CERT_REQ
=
"
certReq
"
;
const
EXTENSIONS
=
"
extensions
"
;
const
TIME_STAMP_REQ
=
"
TimeStampReq
"
;
const
TIME_STAMP_REQ_VERSION
=
{
TIME_STAMP_REQ
}
.
{
VERSION
}
;
const
TIME_STAMP_REQ_MESSAGE_IMPRINT
=
{
TIME_STAMP_REQ
}
.
{
MESSAGE_IMPRINT
}
;
const
TIME_STAMP_REQ_POLICY
=
{
TIME_STAMP_REQ
}
.
{
REQ_POLICY
}
;
const
TIME_STAMP_REQ_NONCE
=
{
TIME_STAMP_REQ
}
.
{
NONCE
}
;
const
TIME_STAMP_REQ_CERT_REQ
=
{
TIME_STAMP_REQ
}
.
{
CERT_REQ
}
;
const
TIME_STAMP_REQ_EXTENSIONS
=
{
TIME_STAMP_REQ
}
.
{
EXTENSIONS
}
;
const
CLEAR_PROPS
=
[
TIME_STAMP_REQ_VERSION
TIME_STAMP_REQ_MESSAGE_IMPRINT
TIME_STAMP_REQ_POLICY
TIME_STAMP_REQ_NONCE
TIME_STAMP_REQ_CERT_REQ
TIME_STAMP_REQ_EXTENSIONS
]
;
export
interface
ITimeStampReq
{
version
:
number
;
messageImprint
:
MessageImprint
;
reqPolicy
?
:
string
;
nonce
?
:
asn1js
.
Integer
;
certReq
?
:
boolean
;
extensions
?
:
Extension
[
]
;
}
export
interface
TimeStampReqJson
{
version
:
number
;
messageImprint
:
MessageImprintJson
;
reqPolicy
?
:
string
;
nonce
?
:
asn1js
.
IntegerJson
;
certReq
?
:
boolean
;
extensions
?
:
ExtensionJson
[
]
;
}
export
type
TimeStampReqParameters
=
PkiObjectParameters
&
Partial
<
ITimeStampReq
>
;
export
class
TimeStampReq
extends
PkiObject
implements
ITimeStampReq
{
public
static
override
CLASS_NAME
=
"
TimeStampReq
"
;
public
version
!
:
number
;
public
messageImprint
!
:
MessageImprint
;
public
reqPolicy
?
:
string
;
public
nonce
?
:
asn1js
.
Integer
;
public
certReq
?
:
boolean
;
public
extensions
?
:
Extension
[
]
;
constructor
(
parameters
:
TimeStampReqParameters
=
{
}
)
{
super
(
)
;
this
.
version
=
pvutils
.
getParametersValue
(
parameters
VERSION
TimeStampReq
.
defaultValues
(
VERSION
)
)
;
this
.
messageImprint
=
pvutils
.
getParametersValue
(
parameters
MESSAGE_IMPRINT
TimeStampReq
.
defaultValues
(
MESSAGE_IMPRINT
)
)
;
if
(
REQ_POLICY
in
parameters
)
{
this
.
reqPolicy
=
pvutils
.
getParametersValue
(
parameters
REQ_POLICY
TimeStampReq
.
defaultValues
(
REQ_POLICY
)
)
;
}
if
(
NONCE
in
parameters
)
{
this
.
nonce
=
pvutils
.
getParametersValue
(
parameters
NONCE
TimeStampReq
.
defaultValues
(
NONCE
)
)
;
}
if
(
CERT_REQ
in
parameters
)
{
this
.
certReq
=
pvutils
.
getParametersValue
(
parameters
CERT_REQ
TimeStampReq
.
defaultValues
(
CERT_REQ
)
)
;
}
if
(
EXTENSIONS
in
parameters
)
{
this
.
extensions
=
pvutils
.
getParametersValue
(
parameters
EXTENSIONS
TimeStampReq
.
defaultValues
(
EXTENSIONS
)
)
;
}
if
(
parameters
.
schema
)
{
this
.
fromSchema
(
parameters
.
schema
)
;
}
}
public
static
override
defaultValues
(
memberName
:
typeof
VERSION
)
:
number
;
public
static
override
defaultValues
(
memberName
:
typeof
MESSAGE_IMPRINT
)
:
MessageImprint
;
public
static
override
defaultValues
(
memberName
:
typeof
REQ_POLICY
)
:
string
;
public
static
override
defaultValues
(
memberName
:
typeof
NONCE
)
:
asn1js
.
Integer
;
public
static
override
defaultValues
(
memberName
:
typeof
CERT_REQ
)
:
boolean
;
public
static
override
defaultValues
(
memberName
:
typeof
EXTENSIONS
)
:
Extension
[
]
;
public
static
override
defaultValues
(
memberName
:
string
)
:
any
{
switch
(
memberName
)
{
case
VERSION
:
return
0
;
case
MESSAGE_IMPRINT
:
return
new
MessageImprint
(
)
;
case
REQ_POLICY
:
return
EMPTY_STRING
;
case
NONCE
:
return
new
asn1js
.
Integer
(
)
;
case
CERT_REQ
:
return
false
;
case
EXTENSIONS
:
return
[
]
;
default
:
return
super
.
defaultValues
(
memberName
)
;
}
}
public
static
compareWithDefault
(
memberName
:
string
memberValue
:
any
)
:
boolean
{
switch
(
memberName
)
{
case
VERSION
:
case
REQ_POLICY
:
case
CERT_REQ
:
return
(
memberValue
=
=
=
TimeStampReq
.
defaultValues
(
memberName
as
typeof
CERT_REQ
)
)
;
case
MESSAGE_IMPRINT
:
return
(
(
MessageImprint
.
compareWithDefault
(
"
hashAlgorithm
"
memberValue
.
hashAlgorithm
)
)
&
&
(
MessageImprint
.
compareWithDefault
(
"
hashedMessage
"
memberValue
.
hashedMessage
)
)
)
;
case
NONCE
:
return
(
memberValue
.
isEqual
(
TimeStampReq
.
defaultValues
(
memberName
)
)
)
;
case
EXTENSIONS
:
return
(
memberValue
.
length
=
=
=
0
)
;
default
:
return
super
.
defaultValues
(
memberName
)
;
}
}
public
static
override
schema
(
parameters
:
Schema
.
SchemaParameters
<
{
version
?
:
string
;
messageImprint
?
:
MessageImprintSchema
;
reqPolicy
?
:
string
;
nonce
?
:
string
;
certReq
?
:
string
;
extensions
?
:
string
;
}
>
=
{
}
)
:
Schema
.
SchemaType
{
const
names
=
pvutils
.
getParametersValue
<
NonNullable
<
typeof
parameters
.
names
>
>
(
parameters
"
names
"
{
}
)
;
return
(
new
asn1js
.
Sequence
(
{
name
:
(
names
.
blockName
|
|
TIME_STAMP_REQ
)
value
:
[
new
asn1js
.
Integer
(
{
name
:
(
names
.
version
|
|
TIME_STAMP_REQ_VERSION
)
}
)
MessageImprint
.
schema
(
names
.
messageImprint
|
|
{
names
:
{
blockName
:
TIME_STAMP_REQ_MESSAGE_IMPRINT
}
}
)
new
asn1js
.
ObjectIdentifier
(
{
name
:
(
names
.
reqPolicy
|
|
TIME_STAMP_REQ_POLICY
)
optional
:
true
}
)
new
asn1js
.
Integer
(
{
name
:
(
names
.
nonce
|
|
TIME_STAMP_REQ_NONCE
)
optional
:
true
}
)
new
asn1js
.
Boolean
(
{
name
:
(
names
.
certReq
|
|
TIME_STAMP_REQ_CERT_REQ
)
optional
:
true
}
)
new
asn1js
.
Constructed
(
{
optional
:
true
idBlock
:
{
tagClass
:
3
tagNumber
:
0
}
value
:
[
new
asn1js
.
Repeated
(
{
name
:
(
names
.
extensions
|
|
TIME_STAMP_REQ_EXTENSIONS
)
value
:
Extension
.
schema
(
)
}
)
]
}
)
]
}
)
)
;
}
public
fromSchema
(
schema
:
Schema
.
SchemaType
)
:
void
{
pvutils
.
clearProps
(
schema
CLEAR_PROPS
)
;
const
asn1
=
asn1js
.
compareSchema
(
schema
schema
TimeStampReq
.
schema
(
)
)
;
AsnError
.
assertSchema
(
asn1
this
.
className
)
;
this
.
version
=
asn1
.
result
[
TIME_STAMP_REQ_VERSION
]
.
valueBlock
.
valueDec
;
this
.
messageImprint
=
new
MessageImprint
(
{
schema
:
asn1
.
result
[
TIME_STAMP_REQ_MESSAGE_IMPRINT
]
}
)
;
if
(
TIME_STAMP_REQ_POLICY
in
asn1
.
result
)
this
.
reqPolicy
=
asn1
.
result
[
TIME_STAMP_REQ_POLICY
]
.
valueBlock
.
toString
(
)
;
if
(
TIME_STAMP_REQ_NONCE
in
asn1
.
result
)
this
.
nonce
=
asn1
.
result
[
TIME_STAMP_REQ_NONCE
]
;
if
(
TIME_STAMP_REQ_CERT_REQ
in
asn1
.
result
)
this
.
certReq
=
asn1
.
result
[
TIME_STAMP_REQ_CERT_REQ
]
.
valueBlock
.
value
;
if
(
TIME_STAMP_REQ_EXTENSIONS
in
asn1
.
result
)
this
.
extensions
=
Array
.
from
(
asn1
.
result
[
TIME_STAMP_REQ_EXTENSIONS
]
element
=
>
new
Extension
(
{
schema
:
element
}
)
)
;
}
public
toSchema
(
)
:
asn1js
.
Sequence
{
const
outputArray
=
[
]
;
outputArray
.
push
(
new
asn1js
.
Integer
(
{
value
:
this
.
version
}
)
)
;
outputArray
.
push
(
this
.
messageImprint
.
toSchema
(
)
)
;
if
(
this
.
reqPolicy
)
outputArray
.
push
(
new
asn1js
.
ObjectIdentifier
(
{
value
:
this
.
reqPolicy
}
)
)
;
if
(
this
.
nonce
)
outputArray
.
push
(
this
.
nonce
)
;
if
(
(
CERT_REQ
in
this
)
&
&
(
TimeStampReq
.
compareWithDefault
(
CERT_REQ
this
.
certReq
)
=
=
=
false
)
)
outputArray
.
push
(
new
asn1js
.
Boolean
(
{
value
:
this
.
certReq
}
)
)
;
if
(
this
.
extensions
)
{
outputArray
.
push
(
new
asn1js
.
Constructed
(
{
idBlock
:
{
tagClass
:
3
tagNumber
:
0
}
value
:
Array
.
from
(
this
.
extensions
o
=
>
o
.
toSchema
(
)
)
}
)
)
;
}
return
(
new
asn1js
.
Sequence
(
{
value
:
outputArray
}
)
)
;
}
public
toJSON
(
)
:
TimeStampReqJson
{
const
res
:
TimeStampReqJson
=
{
version
:
this
.
version
messageImprint
:
this
.
messageImprint
.
toJSON
(
)
}
;
if
(
this
.
reqPolicy
!
=
=
undefined
)
res
.
reqPolicy
=
this
.
reqPolicy
;
if
(
this
.
nonce
!
=
=
undefined
)
res
.
nonce
=
this
.
nonce
.
toJSON
(
)
;
if
(
(
this
.
certReq
!
=
=
undefined
)
&
&
(
TimeStampReq
.
compareWithDefault
(
CERT_REQ
this
.
certReq
)
=
=
=
false
)
)
res
.
certReq
=
this
.
certReq
;
if
(
this
.
extensions
)
{
res
.
extensions
=
Array
.
from
(
this
.
extensions
o
=
>
o
.
toJSON
(
)
)
;
}
return
res
;
}
}
