import
*
as
asn1js
from
"
asn1js
"
;
import
*
as
pvutils
from
"
pvutils
"
;
import
{
AlgorithmIdentifier
}
from
"
.
/
AlgorithmIdentifier
"
;
import
{
EMPTY_BUFFER
}
from
"
.
/
constants
"
;
import
type
{
CryptoEngineAlgorithmOperation
CryptoEngineAlgorithmParams
ICryptoEngine
}
from
"
.
/
CryptoEngine
/
CryptoEngineInterface
"
;
import
{
ArgumentError
}
from
"
.
/
errors
"
;
export
{
ICryptoEngine
}
from
"
.
/
CryptoEngine
/
CryptoEngineInterface
"
;
export
interface
GlobalCryptoEngine
{
name
:
string
;
crypto
:
ICryptoEngine
|
null
;
}
export
let
engine
:
GlobalCryptoEngine
=
{
name
:
"
none
"
crypto
:
null
}
;
function
isCryptoEngine
(
engine
:
unknown
)
:
engine
is
ICryptoEngine
{
return
engine
&
&
typeof
engine
=
=
=
"
object
"
&
&
"
crypto
"
in
engine
?
true
:
false
;
}
export
function
setEngine
(
name
:
string
crypto
:
ICryptoEngine
|
Crypto
subtle
:
ICryptoEngine
|
SubtleCrypto
)
:
void
;
export
function
setEngine
(
name
:
string
crypto
?
:
ICryptoEngine
)
:
void
;
export
function
setEngine
(
name
:
string
.
.
.
args
:
any
[
]
)
:
void
{
let
crypto
:
ICryptoEngine
|
null
=
null
;
if
(
args
.
length
<
2
)
{
if
(
args
.
length
)
{
crypto
=
args
[
0
]
;
}
else
{
crypto
=
typeof
self
!
=
=
"
undefined
"
&
&
self
.
crypto
?
new
CryptoEngine
(
{
name
:
"
browser
"
crypto
:
self
.
crypto
}
)
:
null
;
}
}
else
{
const
cryptoArg
=
args
[
0
]
;
const
subtleArg
=
args
[
1
]
;
if
(
isCryptoEngine
(
subtleArg
)
)
{
crypto
=
subtleArg
;
}
else
if
(
isCryptoEngine
(
cryptoArg
)
)
{
crypto
=
cryptoArg
;
}
else
if
(
"
subtle
"
in
cryptoArg
&
&
"
getRandomValues
"
in
cryptoArg
)
{
crypto
=
new
CryptoEngine
(
{
crypto
:
cryptoArg
}
)
;
}
}
if
(
(
typeof
process
!
=
=
"
undefined
"
)
&
&
(
"
pid
"
in
process
)
&
&
(
typeof
global
!
=
=
"
undefined
"
)
&
&
(
typeof
window
=
=
=
"
undefined
"
)
)
{
if
(
typeof
(
global
as
any
)
[
process
.
pid
]
=
=
=
"
undefined
"
)
{
(
global
as
any
)
[
process
.
pid
]
=
{
}
;
}
else
{
if
(
typeof
(
global
as
any
)
[
process
.
pid
]
!
=
=
"
object
"
)
{
throw
new
Error
(
Name
global
.
{
process
.
pid
}
already
exists
and
it
is
not
an
object
)
;
}
}
if
(
typeof
(
global
as
any
)
[
process
.
pid
]
.
pkijs
=
=
=
"
undefined
"
)
{
(
global
as
any
)
[
process
.
pid
]
.
pkijs
=
{
}
;
}
else
{
if
(
typeof
(
global
as
any
)
[
process
.
pid
]
.
pkijs
!
=
=
"
object
"
)
{
throw
new
Error
(
Name
global
.
{
process
.
pid
}
.
pkijs
already
exists
and
it
is
not
an
object
)
;
}
}
(
global
as
any
)
[
process
.
pid
]
.
pkijs
.
engine
=
{
name
:
name
crypto
}
;
}
else
{
engine
=
{
name
:
name
crypto
}
;
}
}
export
function
getEngine
(
)
:
GlobalCryptoEngine
{
if
(
(
typeof
process
!
=
=
"
undefined
"
)
&
&
(
"
pid
"
in
process
)
&
&
(
typeof
global
!
=
=
"
undefined
"
)
&
&
(
typeof
window
=
=
=
"
undefined
"
)
)
{
let
_engine
;
try
{
_engine
=
(
global
as
any
)
[
process
.
pid
]
.
pkijs
.
engine
;
}
catch
(
ex
)
{
throw
new
Error
(
"
Please
call
'
setEngine
'
before
call
to
'
getEngine
'
"
)
;
}
return
_engine
;
}
return
engine
;
}
export
function
getCrypto
(
safety
?
:
boolean
)
:
ICryptoEngine
|
null
;
export
function
getCrypto
(
safety
:
true
)
:
ICryptoEngine
;
export
function
getCrypto
(
safety
=
false
)
:
ICryptoEngine
|
null
{
const
_engine
=
getEngine
(
)
;
if
(
!
_engine
.
crypto
&
&
safety
)
{
throw
new
Error
(
"
Unable
to
create
WebCrypto
object
"
)
;
}
return
_engine
.
crypto
;
}
export
function
getRandomValues
(
view
:
Uint8Array
)
{
return
getCrypto
(
true
)
.
getRandomValues
(
view
)
;
}
export
function
getOIDByAlgorithm
(
algorithm
:
Algorithm
safety
?
:
boolean
target
?
:
string
)
{
return
getCrypto
(
true
)
.
getOIDByAlgorithm
(
algorithm
safety
target
)
;
}
export
function
getAlgorithmParameters
(
algorithmName
:
string
operation
:
CryptoEngineAlgorithmOperation
)
:
CryptoEngineAlgorithmParams
{
return
getCrypto
(
true
)
.
getAlgorithmParameters
(
algorithmName
operation
)
;
}
export
function
createCMSECDSASignature
(
signatureBuffer
:
ArrayBuffer
)
:
ArrayBuffer
{
if
(
(
signatureBuffer
.
byteLength
%
2
)
!
=
=
0
)
return
EMPTY_BUFFER
;
const
length
=
signatureBuffer
.
byteLength
/
2
;
const
rBuffer
=
new
ArrayBuffer
(
length
)
;
const
rView
=
new
Uint8Array
(
rBuffer
)
;
rView
.
set
(
new
Uint8Array
(
signatureBuffer
0
length
)
)
;
const
rInteger
=
new
asn1js
.
Integer
(
{
valueHex
:
rBuffer
}
)
;
const
sBuffer
=
new
ArrayBuffer
(
length
)
;
const
sView
=
new
Uint8Array
(
sBuffer
)
;
sView
.
set
(
new
Uint8Array
(
signatureBuffer
length
length
)
)
;
const
sInteger
=
new
asn1js
.
Integer
(
{
valueHex
:
sBuffer
}
)
;
return
(
new
asn1js
.
Sequence
(
{
value
:
[
rInteger
.
convertToDER
(
)
sInteger
.
convertToDER
(
)
]
}
)
)
.
toBER
(
false
)
;
}
export
function
createECDSASignatureFromCMS
(
cmsSignature
:
asn1js
.
AsnType
pointSize
:
number
)
:
ArrayBuffer
{
if
(
!
(
cmsSignature
instanceof
asn1js
.
Sequence
&
&
cmsSignature
.
valueBlock
.
value
.
length
=
=
=
2
&
&
cmsSignature
.
valueBlock
.
value
[
0
]
instanceof
asn1js
.
Integer
&
&
cmsSignature
.
valueBlock
.
value
[
1
]
instanceof
asn1js
.
Integer
)
)
return
EMPTY_BUFFER
;
const
rValueView
=
cmsSignature
.
valueBlock
.
value
[
0
]
.
convertFromDER
(
)
.
valueBlock
.
valueHexView
;
const
sValueView
=
cmsSignature
.
valueBlock
.
value
[
1
]
.
convertFromDER
(
)
.
valueBlock
.
valueHexView
;
const
res
=
new
Uint8Array
(
pointSize
*
2
)
;
res
.
set
(
rValueView
pointSize
-
rValueView
.
byteLength
)
;
res
.
set
(
sValueView
(
2
*
pointSize
)
-
sValueView
.
byteLength
)
;
return
res
.
buffer
;
}
export
function
getAlgorithmByOID
<
T
extends
Algorithm
=
Algorithm
>
(
oid
:
string
safety
?
:
boolean
target
?
:
string
)
:
T
|
object
;
export
function
getAlgorithmByOID
<
T
extends
Algorithm
=
Algorithm
>
(
oid
:
string
safety
:
true
target
?
:
string
)
:
T
;
export
function
getAlgorithmByOID
(
oid
:
string
safety
=
false
target
?
:
string
)
:
any
{
return
getCrypto
(
true
)
.
getAlgorithmByOID
(
oid
safety
target
)
;
}
export
function
getHashAlgorithm
(
signatureAlgorithm
:
AlgorithmIdentifier
)
:
string
{
return
getCrypto
(
true
)
.
getHashAlgorithm
(
signatureAlgorithm
)
;
}
async
function
kdfWithCounter
(
hashFunction
:
string
zBuffer
:
ArrayBuffer
Counter
:
number
SharedInfo
:
ArrayBuffer
crypto
:
ICryptoEngine
)
:
Promise
<
{
counter
:
number
;
result
:
ArrayBuffer
;
}
>
{
switch
(
hashFunction
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
case
"
SHA
-
256
"
:
case
"
SHA
-
384
"
:
case
"
SHA
-
512
"
:
break
;
default
:
throw
new
ArgumentError
(
Unknown
hash
function
:
{
hashFunction
}
)
;
}
ArgumentError
.
assert
(
zBuffer
"
zBuffer
"
"
ArrayBuffer
"
)
;
if
(
zBuffer
.
byteLength
=
=
=
0
)
throw
new
ArgumentError
(
"
'
zBuffer
'
has
zero
length
error
"
)
;
ArgumentError
.
assert
(
SharedInfo
"
SharedInfo
"
"
ArrayBuffer
"
)
;
if
(
Counter
>
255
)
throw
new
ArgumentError
(
"
Please
set
'
Counter
'
argument
to
value
less
or
equal
to
255
"
)
;
const
counterBuffer
=
new
ArrayBuffer
(
4
)
;
const
counterView
=
new
Uint8Array
(
counterBuffer
)
;
counterView
[
0
]
=
0x00
;
counterView
[
1
]
=
0x00
;
counterView
[
2
]
=
0x00
;
counterView
[
3
]
=
Counter
;
let
combinedBuffer
=
EMPTY_BUFFER
;
combinedBuffer
=
pvutils
.
utilConcatBuf
(
combinedBuffer
zBuffer
)
;
combinedBuffer
=
pvutils
.
utilConcatBuf
(
combinedBuffer
counterBuffer
)
;
combinedBuffer
=
pvutils
.
utilConcatBuf
(
combinedBuffer
SharedInfo
)
;
const
result
=
await
crypto
.
digest
(
{
name
:
hashFunction
}
combinedBuffer
)
;
return
{
counter
:
Counter
result
}
;
}
export
async
function
kdf
(
hashFunction
:
string
Zbuffer
:
ArrayBuffer
keydatalen
:
number
SharedInfo
:
ArrayBuffer
crypto
=
getCrypto
(
true
)
)
{
let
hashLength
=
0
;
let
maxCounter
=
1
;
switch
(
hashFunction
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
hashLength
=
160
;
break
;
case
"
SHA
-
256
"
:
hashLength
=
256
;
break
;
case
"
SHA
-
384
"
:
hashLength
=
384
;
break
;
case
"
SHA
-
512
"
:
hashLength
=
512
;
break
;
default
:
throw
new
ArgumentError
(
Unknown
hash
function
:
{
hashFunction
}
)
;
}
ArgumentError
.
assert
(
Zbuffer
"
Zbuffer
"
"
ArrayBuffer
"
)
;
if
(
Zbuffer
.
byteLength
=
=
=
0
)
throw
new
ArgumentError
(
"
'
Zbuffer
'
has
zero
length
error
"
)
;
ArgumentError
.
assert
(
SharedInfo
"
SharedInfo
"
"
ArrayBuffer
"
)
;
const
quotient
=
keydatalen
/
hashLength
;
if
(
Math
.
floor
(
quotient
)
>
0
)
{
maxCounter
=
Math
.
floor
(
quotient
)
;
if
(
(
quotient
-
maxCounter
)
>
0
)
maxCounter
+
+
;
}
const
incomingResult
=
[
]
;
for
(
let
i
=
1
;
i
<
=
maxCounter
;
i
+
+
)
incomingResult
.
push
(
await
kdfWithCounter
(
hashFunction
Zbuffer
i
SharedInfo
crypto
)
)
;
let
combinedBuffer
=
EMPTY_BUFFER
;
let
currentCounter
=
1
;
let
found
=
true
;
while
(
found
)
{
found
=
false
;
for
(
const
result
of
incomingResult
)
{
if
(
result
.
counter
=
=
=
currentCounter
)
{
combinedBuffer
=
pvutils
.
utilConcatBuf
(
combinedBuffer
result
.
result
)
;
found
=
true
;
break
;
}
}
currentCounter
+
+
;
}
keydatalen
>
>
=
3
;
if
(
combinedBuffer
.
byteLength
>
keydatalen
)
{
const
newBuffer
=
new
ArrayBuffer
(
keydatalen
)
;
const
newView
=
new
Uint8Array
(
newBuffer
)
;
const
combinedView
=
new
Uint8Array
(
combinedBuffer
)
;
for
(
let
i
=
0
;
i
<
keydatalen
;
i
+
+
)
newView
[
i
]
=
combinedView
[
i
]
;
return
newBuffer
;
}
return
combinedBuffer
;
}
import
{
CryptoEngine
}
from
"
.
/
CryptoEngine
/
CryptoEngine
"
;
