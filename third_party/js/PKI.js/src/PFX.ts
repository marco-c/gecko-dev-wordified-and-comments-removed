import
*
as
asn1js
from
"
asn1js
"
;
import
*
as
pvutils
from
"
pvutils
"
;
import
*
as
common
from
"
.
/
common
"
;
import
{
ContentInfo
ContentInfoJson
ContentInfoSchema
}
from
"
.
/
ContentInfo
"
;
import
{
MacData
MacDataJson
MacDataSchema
}
from
"
.
/
MacData
"
;
import
{
DigestInfo
}
from
"
.
/
DigestInfo
"
;
import
{
AlgorithmIdentifier
}
from
"
.
/
AlgorithmIdentifier
"
;
import
{
SignedData
}
from
"
.
/
SignedData
"
;
import
{
EncapsulatedContentInfo
}
from
"
.
/
EncapsulatedContentInfo
"
;
import
{
Attribute
}
from
"
.
/
Attribute
"
;
import
{
SignerInfo
}
from
"
.
/
SignerInfo
"
;
import
{
IssuerAndSerialNumber
}
from
"
.
/
IssuerAndSerialNumber
"
;
import
{
SignedAndUnsignedAttributes
}
from
"
.
/
SignedAndUnsignedAttributes
"
;
import
{
AuthenticatedSafe
}
from
"
.
/
AuthenticatedSafe
"
;
import
*
as
Schema
from
"
.
/
Schema
"
;
import
{
Certificate
}
from
"
.
/
Certificate
"
;
import
{
ArgumentError
AsnError
ParameterError
}
from
"
.
/
errors
"
;
import
{
PkiObject
PkiObjectParameters
}
from
"
.
/
PkiObject
"
;
import
{
BufferSourceConverter
}
from
"
pvtsutils
"
;
import
{
EMPTY_STRING
}
from
"
.
/
constants
"
;
const
VERSION
=
"
version
"
;
const
AUTH_SAFE
=
"
authSafe
"
;
const
MAC_DATA
=
"
macData
"
;
const
PARSED_VALUE
=
"
parsedValue
"
;
const
CLERA_PROPS
=
[
VERSION
AUTH_SAFE
MAC_DATA
]
;
export
interface
IPFX
{
version
:
number
;
authSafe
:
ContentInfo
;
macData
?
:
MacData
;
parsedValue
?
:
PFXParsedValue
;
}
export
interface
PFXJson
{
version
:
number
;
authSafe
:
ContentInfoJson
;
macData
?
:
MacDataJson
;
}
export
type
PFXParameters
=
PkiObjectParameters
&
Partial
<
IPFX
>
;
export
interface
PFXParsedValue
{
authenticatedSafe
?
:
AuthenticatedSafe
;
integrityMode
?
:
number
;
}
export
type
MakeInternalValuesParams
=
object
|
{
iterations
:
number
;
pbkdf2HashAlgorithm
:
Algorithm
;
hmacHashAlgorithm
:
string
;
password
:
ArrayBuffer
;
}
|
{
signingCertificate
:
Certificate
;
privateKey
:
CryptoKey
;
hashAlgorithm
:
string
;
}
;
export
class
PFX
extends
PkiObject
implements
IPFX
{
public
static
override
CLASS_NAME
=
"
PFX
"
;
public
version
!
:
number
;
public
authSafe
!
:
ContentInfo
;
public
macData
?
:
MacData
;
public
parsedValue
?
:
PFXParsedValue
;
constructor
(
parameters
:
PFXParameters
=
{
}
)
{
super
(
)
;
this
.
version
=
pvutils
.
getParametersValue
(
parameters
VERSION
PFX
.
defaultValues
(
VERSION
)
)
;
this
.
authSafe
=
pvutils
.
getParametersValue
(
parameters
AUTH_SAFE
PFX
.
defaultValues
(
AUTH_SAFE
)
)
;
if
(
MAC_DATA
in
parameters
)
{
this
.
macData
=
pvutils
.
getParametersValue
(
parameters
MAC_DATA
PFX
.
defaultValues
(
MAC_DATA
)
)
;
}
if
(
PARSED_VALUE
in
parameters
)
{
this
.
parsedValue
=
pvutils
.
getParametersValue
(
parameters
PARSED_VALUE
PFX
.
defaultValues
(
PARSED_VALUE
)
)
;
}
if
(
parameters
.
schema
)
{
this
.
fromSchema
(
parameters
.
schema
)
;
}
}
public
static
override
defaultValues
(
memberName
:
typeof
VERSION
)
:
number
;
public
static
override
defaultValues
(
memberName
:
typeof
AUTH_SAFE
)
:
ContentInfo
;
public
static
override
defaultValues
(
memberName
:
typeof
MAC_DATA
)
:
MacData
;
public
static
override
defaultValues
(
memberName
:
typeof
PARSED_VALUE
)
:
PFXParsedValue
;
public
static
override
defaultValues
(
memberName
:
string
)
:
any
{
switch
(
memberName
)
{
case
VERSION
:
return
3
;
case
AUTH_SAFE
:
return
(
new
ContentInfo
(
)
)
;
case
MAC_DATA
:
return
(
new
MacData
(
)
)
;
case
PARSED_VALUE
:
return
{
}
;
default
:
return
super
.
defaultValues
(
memberName
)
;
}
}
public
static
compareWithDefault
(
memberName
:
string
memberValue
:
any
)
:
boolean
{
switch
(
memberName
)
{
case
VERSION
:
return
(
memberValue
=
=
=
PFX
.
defaultValues
(
memberName
)
)
;
case
AUTH_SAFE
:
return
(
(
ContentInfo
.
compareWithDefault
(
"
contentType
"
memberValue
.
contentType
)
)
&
&
(
ContentInfo
.
compareWithDefault
(
"
content
"
memberValue
.
content
)
)
)
;
case
MAC_DATA
:
return
(
(
MacData
.
compareWithDefault
(
"
mac
"
memberValue
.
mac
)
)
&
&
(
MacData
.
compareWithDefault
(
"
macSalt
"
memberValue
.
macSalt
)
)
&
&
(
MacData
.
compareWithDefault
(
"
iterations
"
memberValue
.
iterations
)
)
)
;
case
PARSED_VALUE
:
return
(
(
memberValue
instanceof
Object
)
&
&
(
Object
.
keys
(
memberValue
)
.
length
=
=
=
0
)
)
;
default
:
return
super
.
defaultValues
(
memberName
)
;
}
}
public
static
override
schema
(
parameters
:
Schema
.
SchemaParameters
<
{
version
?
:
string
;
authSafe
?
:
ContentInfoSchema
;
macData
?
:
MacDataSchema
;
}
>
=
{
}
)
:
Schema
.
SchemaType
{
const
names
=
pvutils
.
getParametersValue
<
NonNullable
<
typeof
parameters
.
names
>
>
(
parameters
"
names
"
{
}
)
;
return
(
new
asn1js
.
Sequence
(
{
name
:
(
names
.
blockName
|
|
EMPTY_STRING
)
value
:
[
new
asn1js
.
Integer
(
{
name
:
(
names
.
version
|
|
VERSION
)
}
)
ContentInfo
.
schema
(
names
.
authSafe
|
|
{
names
:
{
blockName
:
AUTH_SAFE
}
}
)
MacData
.
schema
(
names
.
macData
|
|
{
names
:
{
blockName
:
MAC_DATA
optional
:
true
}
}
)
]
}
)
)
;
}
public
fromSchema
(
schema
:
Schema
.
SchemaType
)
:
void
{
pvutils
.
clearProps
(
schema
CLERA_PROPS
)
;
const
asn1
=
asn1js
.
compareSchema
(
schema
schema
PFX
.
schema
(
{
names
:
{
version
:
VERSION
authSafe
:
{
names
:
{
blockName
:
AUTH_SAFE
}
}
macData
:
{
names
:
{
blockName
:
MAC_DATA
}
}
}
}
)
)
;
AsnError
.
assertSchema
(
asn1
this
.
className
)
;
this
.
version
=
asn1
.
result
.
version
.
valueBlock
.
valueDec
;
this
.
authSafe
=
new
ContentInfo
(
{
schema
:
asn1
.
result
.
authSafe
}
)
;
if
(
MAC_DATA
in
asn1
.
result
)
this
.
macData
=
new
MacData
(
{
schema
:
asn1
.
result
.
macData
}
)
;
}
public
toSchema
(
)
:
asn1js
.
Sequence
{
const
outputArray
=
[
new
asn1js
.
Integer
(
{
value
:
this
.
version
}
)
this
.
authSafe
.
toSchema
(
)
]
;
if
(
this
.
macData
)
{
outputArray
.
push
(
this
.
macData
.
toSchema
(
)
)
;
}
return
(
new
asn1js
.
Sequence
(
{
value
:
outputArray
}
)
)
;
}
public
toJSON
(
)
:
PFXJson
{
const
output
:
PFXJson
=
{
version
:
this
.
version
authSafe
:
this
.
authSafe
.
toJSON
(
)
}
;
if
(
this
.
macData
)
{
output
.
macData
=
this
.
macData
.
toJSON
(
)
;
}
return
output
;
}
public
async
makeInternalValues
(
parameters
:
MakeInternalValuesParams
=
{
}
crypto
=
common
.
getCrypto
(
true
)
)
{
ArgumentError
.
assert
(
parameters
"
parameters
"
"
object
"
)
;
if
(
!
this
.
parsedValue
)
{
throw
new
Error
(
"
Please
call
\
"
parseValues
\
"
function
first
in
order
to
make
\
"
parsedValue
\
"
data
"
)
;
}
ParameterError
.
assertEmpty
(
this
.
parsedValue
.
integrityMode
"
integrityMode
"
"
parsedValue
"
)
;
ParameterError
.
assertEmpty
(
this
.
parsedValue
.
authenticatedSafe
"
authenticatedSafe
"
"
parsedValue
"
)
;
switch
(
this
.
parsedValue
.
integrityMode
)
{
case
0
:
{
if
(
!
(
"
iterations
"
in
parameters
)
)
throw
new
ParameterError
(
"
iterations
"
)
;
ParameterError
.
assertEmpty
(
parameters
.
pbkdf2HashAlgorithm
"
pbkdf2HashAlgorithm
"
)
;
ParameterError
.
assertEmpty
(
parameters
.
hmacHashAlgorithm
"
hmacHashAlgorithm
"
)
;
ParameterError
.
assertEmpty
(
parameters
.
password
"
password
"
)
;
const
saltBuffer
=
new
ArrayBuffer
(
64
)
;
const
saltView
=
new
Uint8Array
(
saltBuffer
)
;
crypto
.
getRandomValues
(
saltView
)
;
const
data
=
this
.
parsedValue
.
authenticatedSafe
.
toSchema
(
)
.
toBER
(
false
)
;
this
.
authSafe
=
new
ContentInfo
(
{
contentType
:
ContentInfo
.
DATA
content
:
new
asn1js
.
OctetString
(
{
valueHex
:
data
}
)
}
)
;
const
result
=
await
crypto
.
stampDataWithPassword
(
{
password
:
parameters
.
password
hashAlgorithm
:
parameters
.
hmacHashAlgorithm
salt
:
saltBuffer
iterationCount
:
parameters
.
iterations
contentToStamp
:
data
}
)
;
this
.
macData
=
new
MacData
(
{
mac
:
new
DigestInfo
(
{
digestAlgorithm
:
new
AlgorithmIdentifier
(
{
algorithmId
:
crypto
.
getOIDByAlgorithm
(
{
name
:
parameters
.
hmacHashAlgorithm
}
true
"
hmacHashAlgorithm
"
)
}
)
digest
:
new
asn1js
.
OctetString
(
{
valueHex
:
result
}
)
}
)
macSalt
:
new
asn1js
.
OctetString
(
{
valueHex
:
saltBuffer
}
)
iterations
:
parameters
.
iterations
}
)
;
}
break
;
case
1
:
{
if
(
!
(
"
signingCertificate
"
in
parameters
)
)
{
throw
new
ParameterError
(
"
signingCertificate
"
)
;
}
ParameterError
.
assertEmpty
(
parameters
.
privateKey
"
privateKey
"
)
;
ParameterError
.
assertEmpty
(
parameters
.
hashAlgorithm
"
hashAlgorithm
"
)
;
const
toBeSigned
=
this
.
parsedValue
.
authenticatedSafe
.
toSchema
(
)
.
toBER
(
false
)
;
const
cmsSigned
=
new
SignedData
(
{
version
:
1
encapContentInfo
:
new
EncapsulatedContentInfo
(
{
eContentType
:
"
1
.
2
.
840
.
113549
.
1
.
7
.
1
"
eContent
:
new
asn1js
.
OctetString
(
{
valueHex
:
toBeSigned
}
)
}
)
certificates
:
[
parameters
.
signingCertificate
]
}
)
;
const
result
=
await
crypto
.
digest
(
{
name
:
parameters
.
hashAlgorithm
}
new
Uint8Array
(
toBeSigned
)
)
;
const
signedAttr
:
Attribute
[
]
=
[
]
;
signedAttr
.
push
(
new
Attribute
(
{
type
:
"
1
.
2
.
840
.
113549
.
1
.
9
.
3
"
values
:
[
new
asn1js
.
ObjectIdentifier
(
{
value
:
"
1
.
2
.
840
.
113549
.
1
.
7
.
1
"
}
)
]
}
)
)
;
signedAttr
.
push
(
new
Attribute
(
{
type
:
"
1
.
2
.
840
.
113549
.
1
.
9
.
5
"
values
:
[
new
asn1js
.
UTCTime
(
{
valueDate
:
new
Date
(
)
}
)
]
}
)
)
;
signedAttr
.
push
(
new
Attribute
(
{
type
:
"
1
.
2
.
840
.
113549
.
1
.
9
.
4
"
values
:
[
new
asn1js
.
OctetString
(
{
valueHex
:
result
}
)
]
}
)
)
;
cmsSigned
.
signerInfos
.
push
(
new
SignerInfo
(
{
version
:
1
sid
:
new
IssuerAndSerialNumber
(
{
issuer
:
parameters
.
signingCertificate
.
issuer
serialNumber
:
parameters
.
signingCertificate
.
serialNumber
}
)
signedAttrs
:
new
SignedAndUnsignedAttributes
(
{
type
:
0
attributes
:
signedAttr
}
)
}
)
)
;
await
cmsSigned
.
sign
(
parameters
.
privateKey
0
parameters
.
hashAlgorithm
undefined
crypto
)
;
this
.
authSafe
=
new
ContentInfo
(
{
contentType
:
"
1
.
2
.
840
.
113549
.
1
.
7
.
2
"
content
:
cmsSigned
.
toSchema
(
true
)
}
)
;
}
break
;
default
:
throw
new
Error
(
Parameter
"
integrityMode
"
has
unknown
value
:
{
this
.
parsedValue
.
integrityMode
}
)
;
}
}
public
async
parseInternalValues
(
parameters
:
{
checkIntegrity
?
:
boolean
;
password
?
:
ArrayBuffer
;
}
crypto
=
common
.
getCrypto
(
true
)
)
{
ArgumentError
.
assert
(
parameters
"
parameters
"
"
object
"
)
;
if
(
parameters
.
checkIntegrity
=
=
=
undefined
)
{
parameters
.
checkIntegrity
=
true
;
}
this
.
parsedValue
=
{
}
;
switch
(
this
.
authSafe
.
contentType
)
{
case
ContentInfo
.
DATA
:
{
ParameterError
.
assertEmpty
(
parameters
.
password
"
password
"
)
;
this
.
parsedValue
.
integrityMode
=
0
;
ArgumentError
.
assert
(
this
.
authSafe
.
content
"
authSafe
.
content
"
asn1js
.
OctetString
)
;
const
authSafeContent
=
this
.
authSafe
.
content
.
getValue
(
)
;
this
.
parsedValue
.
authenticatedSafe
=
AuthenticatedSafe
.
fromBER
(
authSafeContent
)
;
if
(
parameters
.
checkIntegrity
)
{
if
(
!
this
.
macData
)
{
throw
new
Error
(
"
Absent
\
"
macData
\
"
value
can
not
check
PKCS
#
12
data
integrity
"
)
;
}
const
hashAlgorithm
=
crypto
.
getAlgorithmByOID
(
this
.
macData
.
mac
.
digestAlgorithm
.
algorithmId
true
"
digestAlgorithm
"
)
;
const
result
=
await
crypto
.
verifyDataStampedWithPassword
(
{
password
:
parameters
.
password
hashAlgorithm
:
hashAlgorithm
.
name
salt
:
BufferSourceConverter
.
toArrayBuffer
(
this
.
macData
.
macSalt
.
valueBlock
.
valueHexView
)
iterationCount
:
this
.
macData
.
iterations
|
|
1
contentToVerify
:
authSafeContent
signatureToVerify
:
BufferSourceConverter
.
toArrayBuffer
(
this
.
macData
.
mac
.
digest
.
valueBlock
.
valueHexView
)
}
)
;
if
(
!
result
)
{
throw
new
Error
(
"
Integrity
for
the
PKCS
#
12
data
is
broken
!
"
)
;
}
}
}
break
;
case
ContentInfo
.
SIGNED_DATA
:
{
this
.
parsedValue
.
integrityMode
=
1
;
const
cmsSigned
=
new
SignedData
(
{
schema
:
this
.
authSafe
.
content
}
)
;
const
eContent
=
cmsSigned
.
encapContentInfo
.
eContent
;
ParameterError
.
assert
(
eContent
"
eContent
"
"
cmsSigned
.
encapContentInfo
"
)
;
ArgumentError
.
assert
(
eContent
"
eContent
"
asn1js
.
OctetString
)
;
const
data
=
eContent
.
getValue
(
)
;
this
.
parsedValue
.
authenticatedSafe
=
AuthenticatedSafe
.
fromBER
(
data
)
;
const
ok
=
await
cmsSigned
.
verify
(
{
signer
:
0
checkChain
:
false
}
crypto
)
;
if
(
!
ok
)
{
throw
new
Error
(
"
Integrity
for
the
PKCS
#
12
data
is
broken
!
"
)
;
}
}
break
;
default
:
throw
new
Error
(
Incorrect
value
for
"
this
.
authSafe
.
contentType
"
:
{
this
.
authSafe
.
contentType
}
)
;
}
}
}
