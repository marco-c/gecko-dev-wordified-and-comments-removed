import
{
sha1
}
from
"
noble
/
hashes
/
sha1
"
;
import
{
sha256
sha384
sha512
}
from
"
noble
/
hashes
/
sha2
"
;
import
*
as
asn1js
from
"
asn1js
"
;
import
*
as
pvutils
from
"
pvutils
"
;
import
*
as
pvtsutils
from
"
pvtsutils
"
;
import
*
as
common
from
"
.
.
/
common
"
;
import
{
PublicKeyInfo
}
from
"
.
.
/
PublicKeyInfo
"
;
import
{
PrivateKeyInfo
}
from
"
.
.
/
PrivateKeyInfo
"
;
import
{
AlgorithmIdentifier
}
from
"
.
.
/
AlgorithmIdentifier
"
;
import
{
EncryptedContentInfo
}
from
"
.
.
/
EncryptedContentInfo
"
;
import
{
IRSASSAPSSParams
RSASSAPSSParams
}
from
"
.
.
/
RSASSAPSSParams
"
;
import
{
PBKDF2Params
}
from
"
.
.
/
PBKDF2Params
"
;
import
{
PBES2Params
}
from
"
.
.
/
PBES2Params
"
;
import
{
ArgumentError
AsnError
ParameterError
}
from
"
.
.
/
errors
"
;
import
*
as
type
from
"
.
/
CryptoEngineInterface
"
;
import
{
AbstractCryptoEngine
}
from
"
.
/
AbstractCryptoEngine
"
;
import
{
EMPTY_STRING
}
from
"
.
.
/
constants
"
;
import
{
ECNamedCurves
}
from
"
.
.
/
ECNamedCurves
"
;
async
function
makePKCS12B2Key
(
hashAlgorithm
:
string
keyLength
:
number
password
:
ArrayBuffer
salt
:
ArrayBuffer
iterationCount
:
number
)
{
let
u
:
number
;
let
v
:
number
;
let
md
:
(
input
:
Uint8Array
)
=
>
Uint8Array
;
switch
(
hashAlgorithm
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
u
=
20
;
v
=
64
;
md
=
sha1
;
break
;
case
"
SHA
-
256
"
:
u
=
32
;
v
=
64
;
md
=
sha256
;
break
;
case
"
SHA
-
384
"
:
u
=
48
;
v
=
128
;
md
=
sha384
;
break
;
case
"
SHA
-
512
"
:
u
=
64
;
v
=
128
;
md
=
sha512
;
break
;
default
:
throw
new
Error
(
"
Unsupported
hashing
algorithm
"
)
;
}
const
originalPassword
=
new
Uint8Array
(
password
)
;
let
decodedPassword
=
new
TextDecoder
(
)
.
decode
(
password
)
;
const
encodedPassword
=
new
TextEncoder
(
)
.
encode
(
decodedPassword
)
;
if
(
encodedPassword
.
some
(
(
byte
i
)
=
>
byte
!
=
=
originalPassword
[
i
]
)
)
{
decodedPassword
=
String
.
fromCharCode
(
.
.
.
originalPassword
)
;
}
const
passwordTransformed
=
new
Uint8Array
(
decodedPassword
.
length
*
2
+
2
)
;
const
passwordView
=
new
DataView
(
passwordTransformed
.
buffer
)
;
for
(
let
i
=
0
;
i
<
decodedPassword
.
length
;
i
+
+
)
{
passwordView
.
setUint16
(
i
*
2
decodedPassword
.
charCodeAt
(
i
)
false
)
;
}
passwordView
.
setUint16
(
decodedPassword
.
length
*
2
0
false
)
;
const
D
=
new
Uint8Array
(
v
)
.
fill
(
3
)
;
const
saltView
=
new
Uint8Array
(
salt
)
;
const
S
=
new
Uint8Array
(
v
*
Math
.
ceil
(
saltView
.
length
/
v
)
)
.
map
(
(
_
i
)
=
>
saltView
[
i
%
saltView
.
length
]
)
;
const
P
=
new
Uint8Array
(
v
*
Math
.
ceil
(
passwordTransformed
.
length
/
v
)
)
.
map
(
(
_
i
)
=
>
passwordTransformed
[
i
%
passwordTransformed
.
length
]
)
;
let
I
=
new
Uint8Array
(
S
.
length
+
P
.
length
)
;
I
.
set
(
S
)
;
I
.
set
(
P
S
.
length
)
;
const
c
=
Math
.
ceil
(
(
keyLength
>
>
3
)
/
u
)
;
const
result
:
number
[
]
=
[
]
;
for
(
let
i
=
0
;
i
<
c
;
i
+
+
)
{
let
A
:
Uint8Array
=
new
Uint8Array
(
D
.
length
+
I
.
length
)
;
A
.
set
(
D
)
;
A
.
set
(
I
D
.
length
)
;
for
(
let
j
=
0
;
j
<
iterationCount
;
j
+
+
)
{
A
=
md
(
A
)
;
}
const
B
=
new
Uint8Array
(
v
)
.
map
(
(
_
i
)
=
>
A
[
i
%
A
.
length
]
)
;
const
k
=
Math
.
ceil
(
saltView
.
length
/
v
)
+
Math
.
ceil
(
passwordTransformed
.
length
/
v
)
;
const
iRound
:
number
[
]
=
[
]
;
for
(
let
j
=
0
;
j
<
k
;
j
+
+
)
{
const
chunk
=
Array
.
from
(
I
.
slice
(
j
*
v
(
j
+
1
)
*
v
)
)
;
let
x
=
0x1ff
;
for
(
let
l
=
B
.
length
-
1
;
l
>
=
0
;
l
-
-
)
{
x
>
>
=
8
;
x
+
=
B
[
l
]
+
(
chunk
[
l
]
|
|
0
)
;
chunk
[
l
]
=
x
&
0xff
;
}
iRound
.
push
(
.
.
.
chunk
)
;
}
I
=
new
Uint8Array
(
iRound
)
;
result
.
push
(
.
.
.
A
)
;
}
return
new
Uint8Array
(
result
.
slice
(
0
keyLength
>
>
3
)
)
.
buffer
;
}
function
prepareAlgorithm
(
data
:
globalThis
.
AlgorithmIdentifier
|
EcdsaParams
)
:
Algorithm
&
{
hash
?
:
Algorithm
;
}
{
const
res
=
typeof
data
=
=
=
"
string
"
?
{
name
:
data
}
:
data
;
if
(
"
hash
"
in
(
res
as
EcdsaParams
)
)
{
return
{
.
.
.
res
hash
:
prepareAlgorithm
(
(
res
as
EcdsaParams
)
.
hash
)
}
;
}
return
res
;
}
export
class
CryptoEngine
extends
AbstractCryptoEngine
{
public
override
async
importKey
(
format
:
KeyFormat
keyData
:
BufferSource
|
JsonWebKey
algorithm
:
globalThis
.
AlgorithmIdentifier
extractable
:
boolean
keyUsages
:
KeyUsage
[
]
)
:
Promise
<
CryptoKey
>
{
let
jwk
:
JsonWebKey
=
{
}
;
const
alg
=
prepareAlgorithm
(
algorithm
)
;
switch
(
format
.
toLowerCase
(
)
)
{
case
"
raw
"
:
return
this
.
subtle
.
importKey
(
"
raw
"
keyData
as
BufferSource
algorithm
extractable
keyUsages
)
;
case
"
spki
"
:
{
const
asn1
=
asn1js
.
fromBER
(
pvtsutils
.
BufferSourceConverter
.
toArrayBuffer
(
keyData
as
BufferSource
)
)
;
AsnError
.
assert
(
asn1
"
keyData
"
)
;
const
publicKeyInfo
=
new
PublicKeyInfo
(
)
;
try
{
publicKeyInfo
.
fromSchema
(
asn1
.
result
)
;
}
catch
{
throw
new
ArgumentError
(
"
Incorrect
keyData
"
)
;
}
switch
(
alg
.
name
.
toUpperCase
(
)
)
{
case
"
RSA
-
PSS
"
:
{
if
(
!
alg
.
hash
)
{
throw
new
ParameterError
(
"
hash
"
"
algorithm
.
hash
"
"
Incorrect
hash
algorithm
:
Hash
algorithm
is
missed
"
)
;
}
switch
(
alg
.
hash
.
name
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
jwk
.
alg
=
"
PS1
"
;
break
;
case
"
SHA
-
256
"
:
jwk
.
alg
=
"
PS256
"
;
break
;
case
"
SHA
-
384
"
:
jwk
.
alg
=
"
PS384
"
;
break
;
case
"
SHA
-
512
"
:
jwk
.
alg
=
"
PS512
"
;
break
;
default
:
throw
new
Error
(
Incorrect
hash
algorithm
:
{
alg
.
hash
.
name
.
toUpperCase
(
)
}
)
;
}
}
case
"
RSASSA
-
PKCS1
-
V1_5
"
:
{
keyUsages
=
[
"
verify
"
]
;
jwk
.
kty
=
"
RSA
"
;
jwk
.
ext
=
extractable
;
jwk
.
key_ops
=
keyUsages
;
if
(
publicKeyInfo
.
algorithm
.
algorithmId
!
=
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
1
"
)
throw
new
Error
(
Incorrect
public
key
algorithm
:
{
publicKeyInfo
.
algorithm
.
algorithmId
}
)
;
if
(
!
jwk
.
alg
)
{
if
(
!
alg
.
hash
)
{
throw
new
ParameterError
(
"
hash
"
"
algorithm
.
hash
"
"
Incorrect
hash
algorithm
:
Hash
algorithm
is
missed
"
)
;
}
switch
(
alg
.
hash
.
name
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
jwk
.
alg
=
"
RS1
"
;
break
;
case
"
SHA
-
256
"
:
jwk
.
alg
=
"
RS256
"
;
break
;
case
"
SHA
-
384
"
:
jwk
.
alg
=
"
RS384
"
;
break
;
case
"
SHA
-
512
"
:
jwk
.
alg
=
"
RS512
"
;
break
;
default
:
throw
new
Error
(
Incorrect
hash
algorithm
:
{
alg
.
hash
.
name
.
toUpperCase
(
)
}
)
;
}
}
const
publicKeyJSON
=
publicKeyInfo
.
toJSON
(
)
;
Object
.
assign
(
jwk
publicKeyJSON
)
;
}
break
;
case
"
ECDSA
"
:
keyUsages
=
[
"
verify
"
]
;
case
"
ECDH
"
:
{
jwk
=
{
kty
:
"
EC
"
ext
:
extractable
key_ops
:
keyUsages
}
;
if
(
publicKeyInfo
.
algorithm
.
algorithmId
!
=
=
"
1
.
2
.
840
.
10045
.
2
.
1
"
)
{
throw
new
Error
(
Incorrect
public
key
algorithm
:
{
publicKeyInfo
.
algorithm
.
algorithmId
}
)
;
}
const
publicKeyJSON
=
publicKeyInfo
.
toJSON
(
)
;
Object
.
assign
(
jwk
publicKeyJSON
)
;
}
break
;
case
"
RSA
-
OAEP
"
:
{
jwk
.
kty
=
"
RSA
"
;
jwk
.
ext
=
extractable
;
jwk
.
key_ops
=
keyUsages
;
if
(
this
.
name
.
toLowerCase
(
)
=
=
=
"
safari
"
)
jwk
.
alg
=
"
RSA
-
OAEP
"
;
else
{
if
(
!
alg
.
hash
)
{
throw
new
ParameterError
(
"
hash
"
"
algorithm
.
hash
"
"
Incorrect
hash
algorithm
:
Hash
algorithm
is
missed
"
)
;
}
switch
(
alg
.
hash
.
name
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
jwk
.
alg
=
"
RSA
-
OAEP
"
;
break
;
case
"
SHA
-
256
"
:
jwk
.
alg
=
"
RSA
-
OAEP
-
256
"
;
break
;
case
"
SHA
-
384
"
:
jwk
.
alg
=
"
RSA
-
OAEP
-
384
"
;
break
;
case
"
SHA
-
512
"
:
jwk
.
alg
=
"
RSA
-
OAEP
-
512
"
;
break
;
default
:
throw
new
Error
(
Incorrect
hash
algorithm
:
{
alg
.
hash
.
name
.
toUpperCase
(
)
}
)
;
}
}
const
publicKeyJSON
=
publicKeyInfo
.
toJSON
(
)
;
Object
.
assign
(
jwk
publicKeyJSON
)
;
}
break
;
case
"
RSAES
-
PKCS1
-
V1_5
"
:
{
jwk
.
kty
=
"
RSA
"
;
jwk
.
ext
=
extractable
;
jwk
.
key_ops
=
keyUsages
;
jwk
.
alg
=
"
PS1
"
;
const
publicKeyJSON
=
publicKeyInfo
.
toJSON
(
)
;
Object
.
assign
(
jwk
publicKeyJSON
)
;
}
break
;
default
:
throw
new
Error
(
Incorrect
algorithm
name
:
{
alg
.
name
.
toUpperCase
(
)
}
)
;
}
}
break
;
case
"
pkcs8
"
:
{
const
privateKeyInfo
=
new
PrivateKeyInfo
(
)
;
const
asn1
=
asn1js
.
fromBER
(
pvtsutils
.
BufferSourceConverter
.
toArrayBuffer
(
keyData
as
BufferSource
)
)
;
AsnError
.
assert
(
asn1
"
keyData
"
)
;
try
{
privateKeyInfo
.
fromSchema
(
asn1
.
result
)
;
}
catch
{
throw
new
Error
(
"
Incorrect
keyData
"
)
;
}
if
(
!
privateKeyInfo
.
parsedKey
)
throw
new
Error
(
"
Incorrect
keyData
"
)
;
switch
(
alg
.
name
.
toUpperCase
(
)
)
{
case
"
RSA
-
PSS
"
:
{
switch
(
alg
.
hash
?
.
name
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
jwk
.
alg
=
"
PS1
"
;
break
;
case
"
SHA
-
256
"
:
jwk
.
alg
=
"
PS256
"
;
break
;
case
"
SHA
-
384
"
:
jwk
.
alg
=
"
PS384
"
;
break
;
case
"
SHA
-
512
"
:
jwk
.
alg
=
"
PS512
"
;
break
;
default
:
throw
new
Error
(
Incorrect
hash
algorithm
:
{
alg
.
hash
?
.
name
.
toUpperCase
(
)
}
)
;
}
}
case
"
RSASSA
-
PKCS1
-
V1_5
"
:
{
keyUsages
=
[
"
sign
"
]
;
jwk
.
kty
=
"
RSA
"
;
jwk
.
ext
=
extractable
;
jwk
.
key_ops
=
keyUsages
;
if
(
privateKeyInfo
.
privateKeyAlgorithm
.
algorithmId
!
=
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
1
"
)
throw
new
Error
(
Incorrect
private
key
algorithm
:
{
privateKeyInfo
.
privateKeyAlgorithm
.
algorithmId
}
)
;
if
(
(
"
alg
"
in
jwk
)
=
=
=
false
)
{
switch
(
alg
.
hash
?
.
name
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
jwk
.
alg
=
"
RS1
"
;
break
;
case
"
SHA
-
256
"
:
jwk
.
alg
=
"
RS256
"
;
break
;
case
"
SHA
-
384
"
:
jwk
.
alg
=
"
RS384
"
;
break
;
case
"
SHA
-
512
"
:
jwk
.
alg
=
"
RS512
"
;
break
;
default
:
throw
new
Error
(
Incorrect
hash
algorithm
:
{
alg
.
hash
?
.
name
.
toUpperCase
(
)
}
)
;
}
}
const
privateKeyJSON
=
privateKeyInfo
.
toJSON
(
)
;
Object
.
assign
(
jwk
privateKeyJSON
)
;
}
break
;
case
"
ECDSA
"
:
keyUsages
=
[
"
sign
"
]
;
case
"
ECDH
"
:
{
jwk
=
{
kty
:
"
EC
"
ext
:
extractable
key_ops
:
keyUsages
}
;
if
(
privateKeyInfo
.
privateKeyAlgorithm
.
algorithmId
!
=
=
"
1
.
2
.
840
.
10045
.
2
.
1
"
)
throw
new
Error
(
Incorrect
algorithm
:
{
privateKeyInfo
.
privateKeyAlgorithm
.
algorithmId
}
)
;
const
privateKeyJSON
=
privateKeyInfo
.
toJSON
(
)
;
Object
.
assign
(
jwk
privateKeyJSON
)
;
}
break
;
case
"
RSA
-
OAEP
"
:
{
jwk
.
kty
=
"
RSA
"
;
jwk
.
ext
=
extractable
;
jwk
.
key_ops
=
keyUsages
;
if
(
this
.
name
.
toLowerCase
(
)
=
=
=
"
safari
"
)
jwk
.
alg
=
"
RSA
-
OAEP
"
;
else
{
switch
(
alg
.
hash
?
.
name
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
jwk
.
alg
=
"
RSA
-
OAEP
"
;
break
;
case
"
SHA
-
256
"
:
jwk
.
alg
=
"
RSA
-
OAEP
-
256
"
;
break
;
case
"
SHA
-
384
"
:
jwk
.
alg
=
"
RSA
-
OAEP
-
384
"
;
break
;
case
"
SHA
-
512
"
:
jwk
.
alg
=
"
RSA
-
OAEP
-
512
"
;
break
;
default
:
throw
new
Error
(
Incorrect
hash
algorithm
:
{
alg
.
hash
?
.
name
.
toUpperCase
(
)
}
)
;
}
}
const
privateKeyJSON
=
privateKeyInfo
.
toJSON
(
)
;
Object
.
assign
(
jwk
privateKeyJSON
)
;
}
break
;
case
"
RSAES
-
PKCS1
-
V1_5
"
:
{
keyUsages
=
[
"
decrypt
"
]
;
jwk
.
kty
=
"
RSA
"
;
jwk
.
ext
=
extractable
;
jwk
.
key_ops
=
keyUsages
;
jwk
.
alg
=
"
PS1
"
;
const
privateKeyJSON
=
privateKeyInfo
.
toJSON
(
)
;
Object
.
assign
(
jwk
privateKeyJSON
)
;
}
break
;
default
:
throw
new
Error
(
Incorrect
algorithm
name
:
{
alg
.
name
.
toUpperCase
(
)
}
)
;
}
}
break
;
case
"
jwk
"
:
jwk
=
keyData
as
JsonWebKey
;
break
;
default
:
throw
new
Error
(
Incorrect
format
:
{
format
}
)
;
}
if
(
this
.
name
.
toLowerCase
(
)
=
=
=
"
safari
"
)
{
try
{
return
this
.
subtle
.
importKey
(
"
jwk
"
pvutils
.
stringToArrayBuffer
(
JSON
.
stringify
(
jwk
)
)
as
any
algorithm
extractable
keyUsages
)
;
}
catch
{
return
this
.
subtle
.
importKey
(
"
jwk
"
jwk
algorithm
extractable
keyUsages
)
;
}
}
return
this
.
subtle
.
importKey
(
"
jwk
"
jwk
algorithm
extractable
keyUsages
)
;
}
public
override
exportKey
(
format
:
"
jwk
"
key
:
CryptoKey
)
:
Promise
<
JsonWebKey
>
;
public
override
exportKey
(
format
:
Exclude
<
KeyFormat
"
jwk
"
>
key
:
CryptoKey
)
:
Promise
<
ArrayBuffer
>
;
public
override
exportKey
(
format
:
string
key
:
CryptoKey
)
:
Promise
<
ArrayBuffer
|
JsonWebKey
>
;
public
override
async
exportKey
(
format
:
KeyFormat
key
:
CryptoKey
)
:
Promise
<
ArrayBuffer
|
JsonWebKey
>
{
let
jwk
=
await
this
.
subtle
.
exportKey
(
"
jwk
"
key
)
;
if
(
this
.
name
.
toLowerCase
(
)
=
=
=
"
safari
"
)
{
if
(
jwk
instanceof
ArrayBuffer
)
{
jwk
=
JSON
.
parse
(
pvutils
.
arrayBufferToString
(
jwk
)
)
;
}
}
switch
(
format
.
toLowerCase
(
)
)
{
case
"
raw
"
:
return
this
.
subtle
.
exportKey
(
"
raw
"
key
)
;
case
"
spki
"
:
{
const
publicKeyInfo
=
new
PublicKeyInfo
(
)
;
try
{
publicKeyInfo
.
fromJSON
(
jwk
)
;
}
catch
{
throw
new
Error
(
"
Incorrect
key
data
"
)
;
}
return
publicKeyInfo
.
toSchema
(
)
.
toBER
(
false
)
;
}
case
"
pkcs8
"
:
{
const
privateKeyInfo
=
new
PrivateKeyInfo
(
)
;
try
{
privateKeyInfo
.
fromJSON
(
jwk
)
;
}
catch
{
throw
new
Error
(
"
Incorrect
key
data
"
)
;
}
return
privateKeyInfo
.
toSchema
(
)
.
toBER
(
false
)
;
}
case
"
jwk
"
:
return
jwk
;
default
:
throw
new
Error
(
Incorrect
format
:
{
format
}
)
;
}
}
public
async
convert
(
inputFormat
:
KeyFormat
outputFormat
:
KeyFormat
keyData
:
ArrayBuffer
|
JsonWebKey
algorithm
:
Algorithm
extractable
:
boolean
keyUsages
:
KeyUsage
[
]
)
{
if
(
inputFormat
.
toLowerCase
(
)
=
=
=
outputFormat
.
toLowerCase
(
)
)
{
return
keyData
;
}
const
key
=
await
this
.
importKey
(
inputFormat
keyData
algorithm
extractable
keyUsages
)
;
return
this
.
exportKey
(
outputFormat
key
)
;
}
public
getAlgorithmByOID
<
T
extends
Algorithm
=
Algorithm
>
(
oid
:
string
safety
?
:
boolean
target
?
:
string
)
:
T
|
object
;
public
getAlgorithmByOID
<
T
extends
Algorithm
=
Algorithm
>
(
oid
:
string
safety
:
true
target
?
:
string
)
:
T
;
public
getAlgorithmByOID
(
oid
:
string
safety
=
false
target
?
:
string
)
:
any
{
switch
(
oid
)
{
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
1
"
:
return
{
name
:
"
RSAES
-
PKCS1
-
v1_5
"
}
;
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
5
"
:
return
{
name
:
"
RSASSA
-
PKCS1
-
v1_5
"
hash
:
{
name
:
"
SHA
-
1
"
}
}
;
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
11
"
:
return
{
name
:
"
RSASSA
-
PKCS1
-
v1_5
"
hash
:
{
name
:
"
SHA
-
256
"
}
}
;
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
12
"
:
return
{
name
:
"
RSASSA
-
PKCS1
-
v1_5
"
hash
:
{
name
:
"
SHA
-
384
"
}
}
;
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
13
"
:
return
{
name
:
"
RSASSA
-
PKCS1
-
v1_5
"
hash
:
{
name
:
"
SHA
-
512
"
}
}
;
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
10
"
:
return
{
name
:
"
RSA
-
PSS
"
}
;
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
7
"
:
return
{
name
:
"
RSA
-
OAEP
"
}
;
case
"
1
.
2
.
840
.
10045
.
2
.
1
"
:
case
"
1
.
2
.
840
.
10045
.
4
.
1
"
:
return
{
name
:
"
ECDSA
"
hash
:
{
name
:
"
SHA
-
1
"
}
}
;
case
"
1
.
2
.
840
.
10045
.
4
.
3
.
2
"
:
return
{
name
:
"
ECDSA
"
hash
:
{
name
:
"
SHA
-
256
"
}
}
;
case
"
1
.
2
.
840
.
10045
.
4
.
3
.
3
"
:
return
{
name
:
"
ECDSA
"
hash
:
{
name
:
"
SHA
-
384
"
}
}
;
case
"
1
.
2
.
840
.
10045
.
4
.
3
.
4
"
:
return
{
name
:
"
ECDSA
"
hash
:
{
name
:
"
SHA
-
512
"
}
}
;
case
"
1
.
3
.
133
.
16
.
840
.
63
.
0
.
2
"
:
return
{
name
:
"
ECDH
"
kdf
:
"
SHA
-
1
"
}
;
case
"
1
.
3
.
132
.
1
.
11
.
1
"
:
return
{
name
:
"
ECDH
"
kdf
:
"
SHA
-
256
"
}
;
case
"
1
.
3
.
132
.
1
.
11
.
2
"
:
return
{
name
:
"
ECDH
"
kdf
:
"
SHA
-
384
"
}
;
case
"
1
.
3
.
132
.
1
.
11
.
3
"
:
return
{
name
:
"
ECDH
"
kdf
:
"
SHA
-
512
"
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
2
"
:
return
{
name
:
"
AES
-
CBC
"
length
:
128
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
22
"
:
return
{
name
:
"
AES
-
CBC
"
length
:
192
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
42
"
:
return
{
name
:
"
AES
-
CBC
"
length
:
256
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
6
"
:
return
{
name
:
"
AES
-
GCM
"
length
:
128
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
26
"
:
return
{
name
:
"
AES
-
GCM
"
length
:
192
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
46
"
:
return
{
name
:
"
AES
-
GCM
"
length
:
256
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
4
"
:
return
{
name
:
"
AES
-
CFB
"
length
:
128
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
24
"
:
return
{
name
:
"
AES
-
CFB
"
length
:
192
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
44
"
:
return
{
name
:
"
AES
-
CFB
"
length
:
256
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
5
"
:
return
{
name
:
"
AES
-
KW
"
length
:
128
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
25
"
:
return
{
name
:
"
AES
-
KW
"
length
:
192
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
45
"
:
return
{
name
:
"
AES
-
KW
"
length
:
256
}
;
case
"
1
.
2
.
840
.
113549
.
2
.
7
"
:
return
{
name
:
"
HMAC
"
hash
:
{
name
:
"
SHA
-
1
"
}
}
;
case
"
1
.
2
.
840
.
113549
.
2
.
9
"
:
return
{
name
:
"
HMAC
"
hash
:
{
name
:
"
SHA
-
256
"
}
}
;
case
"
1
.
2
.
840
.
113549
.
2
.
10
"
:
return
{
name
:
"
HMAC
"
hash
:
{
name
:
"
SHA
-
384
"
}
}
;
case
"
1
.
2
.
840
.
113549
.
2
.
11
"
:
return
{
name
:
"
HMAC
"
hash
:
{
name
:
"
SHA
-
512
"
}
}
;
case
"
1
.
2
.
840
.
113549
.
1
.
9
.
16
.
3
.
5
"
:
return
{
name
:
"
DH
"
}
;
case
"
1
.
3
.
14
.
3
.
2
.
26
"
:
return
{
name
:
"
SHA
-
1
"
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
2
.
1
"
:
return
{
name
:
"
SHA
-
256
"
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
2
.
2
"
:
return
{
name
:
"
SHA
-
384
"
}
;
case
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
2
.
3
"
:
return
{
name
:
"
SHA
-
512
"
}
;
case
"
1
.
2
.
840
.
113549
.
1
.
5
.
12
"
:
return
{
name
:
"
PBKDF2
"
}
;
case
"
1
.
2
.
840
.
10045
.
3
.
1
.
7
"
:
return
{
name
:
"
P
-
256
"
}
;
case
"
1
.
3
.
132
.
0
.
34
"
:
return
{
name
:
"
P
-
384
"
}
;
case
"
1
.
3
.
132
.
0
.
35
"
:
return
{
name
:
"
P
-
521
"
}
;
default
:
}
if
(
safety
)
{
throw
new
Error
(
Unsupported
algorithm
identifier
{
target
?
for
{
target
}
:
EMPTY_STRING
}
:
{
oid
}
)
;
}
return
{
}
;
}
public
getOIDByAlgorithm
(
algorithm
:
Algorithm
safety
=
false
target
?
:
string
)
:
string
{
let
result
=
EMPTY_STRING
;
switch
(
algorithm
.
name
.
toUpperCase
(
)
)
{
case
"
RSAES
-
PKCS1
-
V1_5
"
:
result
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
1
"
;
break
;
case
"
RSASSA
-
PKCS1
-
V1_5
"
:
switch
(
(
algorithm
as
any
)
.
hash
.
name
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
result
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
5
"
;
break
;
case
"
SHA
-
256
"
:
result
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
11
"
;
break
;
case
"
SHA
-
384
"
:
result
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
12
"
;
break
;
case
"
SHA
-
512
"
:
result
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
13
"
;
break
;
default
:
}
break
;
case
"
RSA
-
PSS
"
:
result
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
10
"
;
break
;
case
"
RSA
-
OAEP
"
:
result
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
7
"
;
break
;
case
"
ECDSA
"
:
switch
(
(
algorithm
as
any
)
.
hash
.
name
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
result
=
"
1
.
2
.
840
.
10045
.
4
.
1
"
;
break
;
case
"
SHA
-
256
"
:
result
=
"
1
.
2
.
840
.
10045
.
4
.
3
.
2
"
;
break
;
case
"
SHA
-
384
"
:
result
=
"
1
.
2
.
840
.
10045
.
4
.
3
.
3
"
;
break
;
case
"
SHA
-
512
"
:
result
=
"
1
.
2
.
840
.
10045
.
4
.
3
.
4
"
;
break
;
default
:
}
break
;
case
"
ECDH
"
:
switch
(
(
algorithm
as
any
)
.
kdf
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
result
=
"
1
.
3
.
133
.
16
.
840
.
63
.
0
.
2
"
;
break
;
case
"
SHA
-
256
"
:
result
=
"
1
.
3
.
132
.
1
.
11
.
1
"
;
break
;
case
"
SHA
-
384
"
:
result
=
"
1
.
3
.
132
.
1
.
11
.
2
"
;
break
;
case
"
SHA
-
512
"
:
result
=
"
1
.
3
.
132
.
1
.
11
.
3
"
;
break
;
default
:
}
break
;
case
"
AES
-
CTR
"
:
break
;
case
"
AES
-
CBC
"
:
switch
(
(
algorithm
as
any
)
.
length
)
{
case
128
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
2
"
;
break
;
case
192
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
22
"
;
break
;
case
256
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
42
"
;
break
;
default
:
}
break
;
case
"
AES
-
CMAC
"
:
break
;
case
"
AES
-
GCM
"
:
switch
(
(
algorithm
as
any
)
.
length
)
{
case
128
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
6
"
;
break
;
case
192
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
26
"
;
break
;
case
256
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
46
"
;
break
;
default
:
}
break
;
case
"
AES
-
CFB
"
:
switch
(
(
algorithm
as
any
)
.
length
)
{
case
128
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
4
"
;
break
;
case
192
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
24
"
;
break
;
case
256
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
44
"
;
break
;
default
:
}
break
;
case
"
AES
-
KW
"
:
switch
(
(
algorithm
as
any
)
.
length
)
{
case
128
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
5
"
;
break
;
case
192
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
25
"
;
break
;
case
256
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
1
.
45
"
;
break
;
default
:
}
break
;
case
"
HMAC
"
:
switch
(
(
algorithm
as
any
)
.
hash
.
name
.
toUpperCase
(
)
)
{
case
"
SHA
-
1
"
:
result
=
"
1
.
2
.
840
.
113549
.
2
.
7
"
;
break
;
case
"
SHA
-
256
"
:
result
=
"
1
.
2
.
840
.
113549
.
2
.
9
"
;
break
;
case
"
SHA
-
384
"
:
result
=
"
1
.
2
.
840
.
113549
.
2
.
10
"
;
break
;
case
"
SHA
-
512
"
:
result
=
"
1
.
2
.
840
.
113549
.
2
.
11
"
;
break
;
default
:
}
break
;
case
"
DH
"
:
result
=
"
1
.
2
.
840
.
113549
.
1
.
9
.
16
.
3
.
5
"
;
break
;
case
"
SHA
-
1
"
:
result
=
"
1
.
3
.
14
.
3
.
2
.
26
"
;
break
;
case
"
SHA
-
256
"
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
2
.
1
"
;
break
;
case
"
SHA
-
384
"
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
2
.
2
"
;
break
;
case
"
SHA
-
512
"
:
result
=
"
2
.
16
.
840
.
1
.
101
.
3
.
4
.
2
.
3
"
;
break
;
case
"
CONCAT
"
:
break
;
case
"
HKDF
"
:
break
;
case
"
PBKDF2
"
:
result
=
"
1
.
2
.
840
.
113549
.
1
.
5
.
12
"
;
break
;
case
"
P
-
256
"
:
result
=
"
1
.
2
.
840
.
10045
.
3
.
1
.
7
"
;
break
;
case
"
P
-
384
"
:
result
=
"
1
.
3
.
132
.
0
.
34
"
;
break
;
case
"
P
-
521
"
:
result
=
"
1
.
3
.
132
.
0
.
35
"
;
break
;
default
:
}
if
(
!
result
&
&
safety
)
{
throw
new
Error
(
Unsupported
algorithm
{
target
?
for
{
target
}
:
EMPTY_STRING
}
:
{
algorithm
.
name
}
)
;
}
return
result
;
}
public
getAlgorithmParameters
(
algorithmName
:
string
operation
:
type
.
CryptoEngineAlgorithmOperation
)
:
type
.
CryptoEngineAlgorithmParams
{
let
result
:
type
.
CryptoEngineAlgorithmParams
=
{
algorithm
:
{
}
usages
:
[
]
}
;
switch
(
algorithmName
.
toUpperCase
(
)
)
{
case
"
RSAES
-
PKCS1
-
V1_5
"
:
case
"
RSASSA
-
PKCS1
-
V1_5
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
generatekey
"
:
result
=
{
algorithm
:
{
name
:
"
RSASSA
-
PKCS1
-
v1_5
"
modulusLength
:
2048
publicExponent
:
new
Uint8Array
(
[
0x01
0x00
0x01
]
)
hash
:
{
name
:
"
SHA
-
256
"
}
}
usages
:
[
"
sign
"
"
verify
"
]
}
;
break
;
case
"
verify
"
:
case
"
sign
"
:
case
"
importkey
"
:
result
=
{
algorithm
:
{
name
:
"
RSASSA
-
PKCS1
-
v1_5
"
hash
:
{
name
:
"
SHA
-
256
"
}
}
usages
:
[
"
verify
"
]
}
;
break
;
case
"
exportkey
"
:
default
:
return
{
algorithm
:
{
name
:
"
RSASSA
-
PKCS1
-
v1_5
"
}
usages
:
[
]
}
;
}
break
;
case
"
RSA
-
PSS
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
sign
"
:
case
"
verify
"
:
result
=
{
algorithm
:
{
name
:
"
RSA
-
PSS
"
hash
:
{
name
:
"
SHA
-
1
"
}
saltLength
:
20
}
usages
:
[
"
sign
"
"
verify
"
]
}
;
break
;
case
"
generatekey
"
:
result
=
{
algorithm
:
{
name
:
"
RSA
-
PSS
"
modulusLength
:
2048
publicExponent
:
new
Uint8Array
(
[
0x01
0x00
0x01
]
)
hash
:
{
name
:
"
SHA
-
1
"
}
}
usages
:
[
"
sign
"
"
verify
"
]
}
;
break
;
case
"
importkey
"
:
result
=
{
algorithm
:
{
name
:
"
RSA
-
PSS
"
hash
:
{
name
:
"
SHA
-
1
"
}
}
usages
:
[
"
verify
"
]
}
;
break
;
case
"
exportkey
"
:
default
:
return
{
algorithm
:
{
name
:
"
RSA
-
PSS
"
}
usages
:
[
]
}
;
}
break
;
case
"
RSA
-
OAEP
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
encrypt
"
:
case
"
decrypt
"
:
result
=
{
algorithm
:
{
name
:
"
RSA
-
OAEP
"
}
usages
:
[
"
encrypt
"
"
decrypt
"
]
}
;
break
;
case
"
generatekey
"
:
result
=
{
algorithm
:
{
name
:
"
RSA
-
OAEP
"
modulusLength
:
2048
publicExponent
:
new
Uint8Array
(
[
0x01
0x00
0x01
]
)
hash
:
{
name
:
"
SHA
-
256
"
}
}
usages
:
[
"
encrypt
"
"
decrypt
"
"
wrapKey
"
"
unwrapKey
"
]
}
;
break
;
case
"
importkey
"
:
result
=
{
algorithm
:
{
name
:
"
RSA
-
OAEP
"
hash
:
{
name
:
"
SHA
-
256
"
}
}
usages
:
[
"
encrypt
"
]
}
;
break
;
case
"
exportkey
"
:
default
:
return
{
algorithm
:
{
name
:
"
RSA
-
OAEP
"
}
usages
:
[
]
}
;
}
break
;
case
"
ECDSA
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
generatekey
"
:
result
=
{
algorithm
:
{
name
:
"
ECDSA
"
namedCurve
:
"
P
-
256
"
}
usages
:
[
"
sign
"
"
verify
"
]
}
;
break
;
case
"
importkey
"
:
result
=
{
algorithm
:
{
name
:
"
ECDSA
"
namedCurve
:
"
P
-
256
"
}
usages
:
[
"
verify
"
]
}
;
break
;
case
"
verify
"
:
case
"
sign
"
:
result
=
{
algorithm
:
{
name
:
"
ECDSA
"
hash
:
{
name
:
"
SHA
-
256
"
}
}
usages
:
[
"
sign
"
]
}
;
break
;
default
:
return
{
algorithm
:
{
name
:
"
ECDSA
"
}
usages
:
[
]
}
;
}
break
;
case
"
ECDH
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
exportkey
"
:
case
"
importkey
"
:
case
"
generatekey
"
:
result
=
{
algorithm
:
{
name
:
"
ECDH
"
namedCurve
:
"
P
-
256
"
}
usages
:
[
"
deriveKey
"
"
deriveBits
"
]
}
;
break
;
case
"
derivekey
"
:
case
"
derivebits
"
:
result
=
{
algorithm
:
{
name
:
"
ECDH
"
namedCurve
:
"
P
-
256
"
public
:
[
]
}
usages
:
[
"
encrypt
"
"
decrypt
"
]
}
;
break
;
default
:
return
{
algorithm
:
{
name
:
"
ECDH
"
}
usages
:
[
]
}
;
}
break
;
case
"
AES
-
CTR
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
importkey
"
:
case
"
exportkey
"
:
case
"
generatekey
"
:
result
=
{
algorithm
:
{
name
:
"
AES
-
CTR
"
length
:
256
}
usages
:
[
"
encrypt
"
"
decrypt
"
"
wrapKey
"
"
unwrapKey
"
]
}
;
break
;
case
"
decrypt
"
:
case
"
encrypt
"
:
result
=
{
algorithm
:
{
name
:
"
AES
-
CTR
"
counter
:
new
Uint8Array
(
16
)
length
:
10
}
usages
:
[
"
encrypt
"
"
decrypt
"
"
wrapKey
"
"
unwrapKey
"
]
}
;
break
;
default
:
return
{
algorithm
:
{
name
:
"
AES
-
CTR
"
}
usages
:
[
]
}
;
}
break
;
case
"
AES
-
CBC
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
importkey
"
:
case
"
exportkey
"
:
case
"
generatekey
"
:
result
=
{
algorithm
:
{
name
:
"
AES
-
CBC
"
length
:
256
}
usages
:
[
"
encrypt
"
"
decrypt
"
"
wrapKey
"
"
unwrapKey
"
]
}
;
break
;
case
"
decrypt
"
:
case
"
encrypt
"
:
result
=
{
algorithm
:
{
name
:
"
AES
-
CBC
"
iv
:
this
.
getRandomValues
(
new
Uint8Array
(
16
)
)
}
usages
:
[
"
encrypt
"
"
decrypt
"
"
wrapKey
"
"
unwrapKey
"
]
}
;
break
;
default
:
return
{
algorithm
:
{
name
:
"
AES
-
CBC
"
}
usages
:
[
]
}
;
}
break
;
case
"
AES
-
GCM
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
importkey
"
:
case
"
exportkey
"
:
case
"
generatekey
"
:
result
=
{
algorithm
:
{
name
:
"
AES
-
GCM
"
length
:
256
}
usages
:
[
"
encrypt
"
"
decrypt
"
"
wrapKey
"
"
unwrapKey
"
]
}
;
break
;
case
"
decrypt
"
:
case
"
encrypt
"
:
result
=
{
algorithm
:
{
name
:
"
AES
-
GCM
"
iv
:
this
.
getRandomValues
(
new
Uint8Array
(
16
)
)
}
usages
:
[
"
encrypt
"
"
decrypt
"
"
wrapKey
"
"
unwrapKey
"
]
}
;
break
;
default
:
return
{
algorithm
:
{
name
:
"
AES
-
GCM
"
}
usages
:
[
]
}
;
}
break
;
case
"
AES
-
KW
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
importkey
"
:
case
"
exportkey
"
:
case
"
generatekey
"
:
case
"
wrapkey
"
:
case
"
unwrapkey
"
:
result
=
{
algorithm
:
{
name
:
"
AES
-
KW
"
length
:
256
}
usages
:
[
"
wrapKey
"
"
unwrapKey
"
]
}
;
break
;
default
:
return
{
algorithm
:
{
name
:
"
AES
-
KW
"
}
usages
:
[
]
}
;
}
break
;
case
"
HMAC
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
sign
"
:
case
"
verify
"
:
result
=
{
algorithm
:
{
name
:
"
HMAC
"
}
usages
:
[
"
sign
"
"
verify
"
]
}
;
break
;
case
"
importkey
"
:
case
"
exportkey
"
:
case
"
generatekey
"
:
result
=
{
algorithm
:
{
name
:
"
HMAC
"
length
:
32
hash
:
{
name
:
"
SHA
-
256
"
}
}
usages
:
[
"
sign
"
"
verify
"
]
}
;
break
;
default
:
return
{
algorithm
:
{
name
:
"
HMAC
"
}
usages
:
[
]
}
;
}
break
;
case
"
HKDF
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
derivekey
"
:
result
=
{
algorithm
:
{
name
:
"
HKDF
"
hash
:
"
SHA
-
256
"
salt
:
new
Uint8Array
(
[
]
)
info
:
new
Uint8Array
(
[
]
)
}
usages
:
[
"
encrypt
"
"
decrypt
"
]
}
;
break
;
default
:
return
{
algorithm
:
{
name
:
"
HKDF
"
}
usages
:
[
]
}
;
}
break
;
case
"
PBKDF2
"
:
switch
(
operation
.
toLowerCase
(
)
)
{
case
"
derivekey
"
:
result
=
{
algorithm
:
{
name
:
"
PBKDF2
"
hash
:
{
name
:
"
SHA
-
256
"
}
salt
:
new
Uint8Array
(
[
]
)
iterations
:
10000
}
usages
:
[
"
encrypt
"
"
decrypt
"
]
}
;
break
;
default
:
return
{
algorithm
:
{
name
:
"
PBKDF2
"
}
usages
:
[
]
}
;
}
break
;
default
:
}
return
result
;
}
getHashAlgorithm
(
signatureAlgorithm
:
AlgorithmIdentifier
)
:
string
{
let
result
=
EMPTY_STRING
;
switch
(
signatureAlgorithm
.
algorithmId
)
{
case
"
1
.
2
.
840
.
10045
.
4
.
1
"
:
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
5
"
:
result
=
"
SHA
-
1
"
;
break
;
case
"
1
.
2
.
840
.
10045
.
4
.
3
.
2
"
:
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
11
"
:
result
=
"
SHA
-
256
"
;
break
;
case
"
1
.
2
.
840
.
10045
.
4
.
3
.
3
"
:
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
12
"
:
result
=
"
SHA
-
384
"
;
break
;
case
"
1
.
2
.
840
.
10045
.
4
.
3
.
4
"
:
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
13
"
:
result
=
"
SHA
-
512
"
;
break
;
case
"
1
.
2
.
840
.
113549
.
1
.
1
.
10
"
:
{
try
{
const
params
=
new
RSASSAPSSParams
(
{
schema
:
signatureAlgorithm
.
algorithmParams
}
)
;
if
(
params
.
hashAlgorithm
)
{
const
algorithm
=
this
.
getAlgorithmByOID
(
params
.
hashAlgorithm
.
algorithmId
)
;
if
(
"
name
"
in
algorithm
)
{
result
=
algorithm
.
name
;
}
else
{
return
EMPTY_STRING
;
}
}
else
result
=
"
SHA
-
1
"
;
}
catch
{
}
}
break
;
default
:
}
return
result
;
}
public
async
encryptEncryptedContentInfo
(
parameters
:
type
.
CryptoEngineEncryptParams
)
:
Promise
<
EncryptedContentInfo
>
{
ParameterError
.
assert
(
parameters
"
password
"
"
contentEncryptionAlgorithm
"
"
hmacHashAlgorithm
"
"
iterationCount
"
"
contentToEncrypt
"
"
contentToEncrypt
"
"
contentType
"
)
;
const
contentEncryptionOID
=
this
.
getOIDByAlgorithm
(
parameters
.
contentEncryptionAlgorithm
true
"
contentEncryptionAlgorithm
"
)
;
const
pbkdf2OID
=
this
.
getOIDByAlgorithm
(
{
name
:
"
PBKDF2
"
}
true
"
PBKDF2
"
)
;
const
hmacOID
=
this
.
getOIDByAlgorithm
(
{
name
:
"
HMAC
"
hash
:
{
name
:
parameters
.
hmacHashAlgorithm
}
}
as
Algorithm
true
"
hmacHashAlgorithm
"
)
;
const
ivBuffer
=
new
ArrayBuffer
(
16
)
;
const
ivView
=
new
Uint8Array
(
ivBuffer
)
;
this
.
getRandomValues
(
ivView
)
;
const
saltBuffer
=
new
ArrayBuffer
(
64
)
;
const
saltView
=
new
Uint8Array
(
saltBuffer
)
;
this
.
getRandomValues
(
saltView
)
;
const
contentView
=
new
Uint8Array
(
parameters
.
contentToEncrypt
)
;
const
pbkdf2Params
=
new
PBKDF2Params
(
{
salt
:
new
asn1js
.
OctetString
(
{
valueHex
:
saltBuffer
}
)
iterationCount
:
parameters
.
iterationCount
prf
:
new
AlgorithmIdentifier
(
{
algorithmId
:
hmacOID
algorithmParams
:
new
asn1js
.
Null
(
)
}
)
}
)
;
const
passwordView
=
new
Uint8Array
(
parameters
.
password
)
;
const
pbkdfKey
=
await
this
.
importKey
(
"
raw
"
passwordView
"
PBKDF2
"
false
[
"
deriveKey
"
]
)
;
const
derivedKey
=
await
this
.
deriveKey
(
{
name
:
"
PBKDF2
"
hash
:
{
name
:
parameters
.
hmacHashAlgorithm
}
salt
:
saltView
iterations
:
parameters
.
iterationCount
}
pbkdfKey
parameters
.
contentEncryptionAlgorithm
false
[
"
encrypt
"
]
)
;
const
encryptedData
=
await
this
.
encrypt
(
{
name
:
parameters
.
contentEncryptionAlgorithm
.
name
iv
:
ivView
}
derivedKey
contentView
)
;
const
pbes2Parameters
=
new
PBES2Params
(
{
keyDerivationFunc
:
new
AlgorithmIdentifier
(
{
algorithmId
:
pbkdf2OID
algorithmParams
:
pbkdf2Params
.
toSchema
(
)
}
)
encryptionScheme
:
new
AlgorithmIdentifier
(
{
algorithmId
:
contentEncryptionOID
algorithmParams
:
new
asn1js
.
OctetString
(
{
valueHex
:
ivBuffer
}
)
}
)
}
)
;
return
new
EncryptedContentInfo
(
{
contentType
:
parameters
.
contentType
contentEncryptionAlgorithm
:
new
AlgorithmIdentifier
(
{
algorithmId
:
"
1
.
2
.
840
.
113549
.
1
.
5
.
13
"
algorithmParams
:
pbes2Parameters
.
toSchema
(
)
}
)
encryptedContent
:
new
asn1js
.
OctetString
(
{
valueHex
:
encryptedData
}
)
}
)
;
}
public
async
decryptEncryptedContentInfo
(
parameters
:
type
.
CryptoEngineDecryptParams
)
:
Promise
<
ArrayBuffer
>
{
ParameterError
.
assert
(
parameters
"
password
"
"
encryptedContentInfo
"
)
;
if
(
parameters
.
encryptedContentInfo
.
contentEncryptionAlgorithm
.
algorithmId
!
=
=
"
1
.
2
.
840
.
113549
.
1
.
5
.
13
"
)
throw
new
Error
(
Unknown
"
contentEncryptionAlgorithm
"
:
{
parameters
.
encryptedContentInfo
.
contentEncryptionAlgorithm
.
algorithmId
}
)
;
let
pbes2Parameters
:
PBES2Params
;
try
{
pbes2Parameters
=
new
PBES2Params
(
{
schema
:
parameters
.
encryptedContentInfo
.
contentEncryptionAlgorithm
.
algorithmParams
}
)
;
}
catch
{
throw
new
Error
(
"
Incorrectly
encoded
\
"
pbes2Parameters
\
"
"
)
;
}
let
pbkdf2Params
;
try
{
pbkdf2Params
=
new
PBKDF2Params
(
{
schema
:
pbes2Parameters
.
keyDerivationFunc
.
algorithmParams
}
)
;
}
catch
{
throw
new
Error
(
"
Incorrectly
encoded
\
"
pbkdf2Params
\
"
"
)
;
}
const
contentEncryptionAlgorithm
=
this
.
getAlgorithmByOID
(
pbes2Parameters
.
encryptionScheme
.
algorithmId
true
)
;
const
ivBuffer
=
pbes2Parameters
.
encryptionScheme
.
algorithmParams
.
valueBlock
.
valueHex
;
const
ivView
=
new
Uint8Array
(
ivBuffer
)
;
const
saltBuffer
=
pbkdf2Params
.
salt
.
valueBlock
.
valueHex
;
const
saltView
=
new
Uint8Array
(
saltBuffer
)
;
const
iterationCount
=
pbkdf2Params
.
iterationCount
;
let
hmacHashAlgorithm
=
"
SHA
-
1
"
;
if
(
pbkdf2Params
.
prf
)
{
const
algorithm
=
this
.
getAlgorithmByOID
<
any
>
(
pbkdf2Params
.
prf
.
algorithmId
true
)
;
hmacHashAlgorithm
=
algorithm
.
hash
.
name
;
}
const
pbkdfKey
=
await
this
.
importKey
(
"
raw
"
parameters
.
password
"
PBKDF2
"
false
[
"
deriveKey
"
]
)
;
const
result
=
await
this
.
deriveKey
(
{
name
:
"
PBKDF2
"
hash
:
{
name
:
hmacHashAlgorithm
}
salt
:
saltView
iterations
:
iterationCount
}
pbkdfKey
contentEncryptionAlgorithm
as
any
false
[
"
decrypt
"
]
)
;
const
dataBuffer
=
parameters
.
encryptedContentInfo
.
getEncryptedContent
(
)
;
return
this
.
decrypt
(
{
name
:
contentEncryptionAlgorithm
.
name
iv
:
ivView
}
result
dataBuffer
)
;
}
public
async
stampDataWithPassword
(
parameters
:
type
.
CryptoEngineStampDataWithPasswordParams
)
:
Promise
<
ArrayBuffer
>
{
if
(
(
parameters
instanceof
Object
)
=
=
=
false
)
throw
new
Error
(
"
Parameters
must
have
type
\
"
Object
\
"
"
)
;
ParameterError
.
assert
(
parameters
"
password
"
"
hashAlgorithm
"
"
iterationCount
"
"
salt
"
"
contentToStamp
"
)
;
let
length
:
number
;
switch
(
parameters
.
hashAlgorithm
.
toLowerCase
(
)
)
{
case
"
sha
-
1
"
:
length
=
160
;
break
;
case
"
sha
-
256
"
:
length
=
256
;
break
;
case
"
sha
-
384
"
:
length
=
384
;
break
;
case
"
sha
-
512
"
:
length
=
512
;
break
;
default
:
throw
new
Error
(
Incorrect
"
parameters
.
hashAlgorithm
"
parameter
:
{
parameters
.
hashAlgorithm
}
)
;
}
const
hmacAlgorithm
=
{
name
:
"
HMAC
"
length
hash
:
{
name
:
parameters
.
hashAlgorithm
}
}
;
const
pkcsKey
=
await
makePKCS12B2Key
(
parameters
.
hashAlgorithm
length
parameters
.
password
parameters
.
salt
parameters
.
iterationCount
)
;
const
hmacKey
=
await
this
.
importKey
(
"
raw
"
new
Uint8Array
(
pkcsKey
)
hmacAlgorithm
false
[
"
sign
"
]
)
;
return
this
.
sign
(
hmacAlgorithm
hmacKey
new
Uint8Array
(
parameters
.
contentToStamp
)
)
;
}
public
async
verifyDataStampedWithPassword
(
parameters
:
type
.
CryptoEngineVerifyDataStampedWithPasswordParams
)
:
Promise
<
boolean
>
{
ParameterError
.
assert
(
parameters
"
password
"
"
hashAlgorithm
"
"
salt
"
"
iterationCount
"
"
contentToVerify
"
"
signatureToVerify
"
)
;
let
length
=
0
;
switch
(
parameters
.
hashAlgorithm
.
toLowerCase
(
)
)
{
case
"
sha
-
1
"
:
length
=
160
;
break
;
case
"
sha
-
256
"
:
length
=
256
;
break
;
case
"
sha
-
384
"
:
length
=
384
;
break
;
case
"
sha
-
512
"
:
length
=
512
;
break
;
default
:
throw
new
Error
(
Incorrect
"
parameters
.
hashAlgorithm
"
parameter
:
{
parameters
.
hashAlgorithm
}
)
;
}
const
hmacAlgorithm
=
{
name
:
"
HMAC
"
length
hash
:
{
name
:
parameters
.
hashAlgorithm
}
}
;
const
pkcsKey
=
await
makePKCS12B2Key
(
parameters
.
hashAlgorithm
length
parameters
.
password
parameters
.
salt
parameters
.
iterationCount
)
;
const
hmacKey
=
await
this
.
importKey
(
"
raw
"
new
Uint8Array
(
pkcsKey
)
hmacAlgorithm
false
[
"
verify
"
]
)
;
return
this
.
verify
(
hmacAlgorithm
hmacKey
new
Uint8Array
(
parameters
.
signatureToVerify
)
new
Uint8Array
(
parameters
.
contentToVerify
)
)
;
}
public
async
getSignatureParameters
(
privateKey
:
CryptoKey
hashAlgorithm
=
"
SHA
-
1
"
)
:
Promise
<
type
.
CryptoEngineSignatureParams
>
{
this
.
getOIDByAlgorithm
(
{
name
:
hashAlgorithm
}
true
"
hashAlgorithm
"
)
;
const
signatureAlgorithm
=
new
AlgorithmIdentifier
(
)
;
const
parameters
=
this
.
getAlgorithmParameters
(
privateKey
.
algorithm
.
name
"
sign
"
)
;
if
(
!
Object
.
keys
(
parameters
.
algorithm
)
.
length
)
{
throw
new
Error
(
"
Parameter
'
algorithm
'
is
empty
"
)
;
}
const
algorithm
=
parameters
.
algorithm
as
any
;
if
(
"
hash
"
in
privateKey
.
algorithm
&
&
privateKey
.
algorithm
.
hash
&
&
(
privateKey
.
algorithm
.
hash
as
Algorithm
)
.
name
)
{
algorithm
.
hash
.
name
=
(
privateKey
.
algorithm
.
hash
as
Algorithm
)
.
name
;
}
else
{
algorithm
.
hash
.
name
=
hashAlgorithm
;
}
switch
(
privateKey
.
algorithm
.
name
.
toUpperCase
(
)
)
{
case
"
RSASSA
-
PKCS1
-
V1_5
"
:
case
"
ECDSA
"
:
signatureAlgorithm
.
algorithmId
=
this
.
getOIDByAlgorithm
(
algorithm
true
)
;
break
;
case
"
RSA
-
PSS
"
:
{
switch
(
algorithm
.
hash
.
name
.
toUpperCase
(
)
)
{
case
"
SHA
-
256
"
:
algorithm
.
saltLength
=
32
;
break
;
case
"
SHA
-
384
"
:
algorithm
.
saltLength
=
48
;
break
;
case
"
SHA
-
512
"
:
algorithm
.
saltLength
=
64
;
break
;
default
:
}
const
paramsObject
:
Partial
<
IRSASSAPSSParams
>
=
{
}
;
if
(
algorithm
.
hash
.
name
.
toUpperCase
(
)
!
=
=
"
SHA
-
1
"
)
{
const
hashAlgorithmOID
=
this
.
getOIDByAlgorithm
(
{
name
:
algorithm
.
hash
.
name
}
true
"
hashAlgorithm
"
)
;
paramsObject
.
hashAlgorithm
=
new
AlgorithmIdentifier
(
{
algorithmId
:
hashAlgorithmOID
algorithmParams
:
new
asn1js
.
Null
(
)
}
)
;
paramsObject
.
maskGenAlgorithm
=
new
AlgorithmIdentifier
(
{
algorithmId
:
"
1
.
2
.
840
.
113549
.
1
.
1
.
8
"
algorithmParams
:
paramsObject
.
hashAlgorithm
.
toSchema
(
)
}
)
;
}
if
(
algorithm
.
saltLength
!
=
=
20
)
paramsObject
.
saltLength
=
algorithm
.
saltLength
;
const
pssParameters
=
new
RSASSAPSSParams
(
paramsObject
)
;
signatureAlgorithm
.
algorithmId
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
10
"
;
signatureAlgorithm
.
algorithmParams
=
pssParameters
.
toSchema
(
)
;
}
break
;
default
:
throw
new
Error
(
Unsupported
signature
algorithm
:
{
privateKey
.
algorithm
.
name
}
)
;
}
return
{
signatureAlgorithm
parameters
}
;
}
public
async
signWithPrivateKey
(
data
:
BufferSource
privateKey
:
CryptoKey
parameters
:
type
.
CryptoEngineSignWithPrivateKeyParams
)
:
Promise
<
ArrayBuffer
>
{
const
signature
=
await
this
.
sign
(
parameters
.
algorithm
privateKey
data
)
;
if
(
parameters
.
algorithm
.
name
=
=
=
"
ECDSA
"
)
{
return
common
.
createCMSECDSASignature
(
signature
)
;
}
return
signature
;
}
public
fillPublicKeyParameters
(
publicKeyInfo
:
PublicKeyInfo
signatureAlgorithm
:
AlgorithmIdentifier
)
:
type
.
CryptoEnginePublicKeyParams
{
const
parameters
=
{
}
as
any
;
const
shaAlgorithm
=
this
.
getHashAlgorithm
(
signatureAlgorithm
)
;
if
(
shaAlgorithm
=
=
=
EMPTY_STRING
)
throw
new
Error
(
Unsupported
signature
algorithm
:
{
signatureAlgorithm
.
algorithmId
}
)
;
let
algorithmId
:
string
;
if
(
signatureAlgorithm
.
algorithmId
=
=
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
10
"
)
algorithmId
=
signatureAlgorithm
.
algorithmId
;
else
algorithmId
=
publicKeyInfo
.
algorithm
.
algorithmId
;
const
algorithmObject
=
this
.
getAlgorithmByOID
(
algorithmId
true
)
;
parameters
.
algorithm
=
this
.
getAlgorithmParameters
(
algorithmObject
.
name
"
importKey
"
)
;
if
(
"
hash
"
in
parameters
.
algorithm
.
algorithm
)
parameters
.
algorithm
.
algorithm
.
hash
.
name
=
shaAlgorithm
;
if
(
algorithmObject
.
name
=
=
=
"
ECDSA
"
)
{
const
publicKeyAlgorithm
=
publicKeyInfo
.
algorithm
;
if
(
!
publicKeyAlgorithm
.
algorithmParams
)
{
throw
new
Error
(
"
Algorithm
parameters
for
ECDSA
public
key
are
missed
"
)
;
}
const
publicKeyAlgorithmParams
=
publicKeyAlgorithm
.
algorithmParams
;
if
(
"
idBlock
"
in
publicKeyAlgorithm
.
algorithmParams
)
{
if
(
!
(
(
publicKeyAlgorithmParams
.
idBlock
.
tagClass
=
=
=
1
)
&
&
(
publicKeyAlgorithmParams
.
idBlock
.
tagNumber
=
=
=
6
)
)
)
{
throw
new
Error
(
"
Incorrect
type
for
ECDSA
public
key
parameters
"
)
;
}
}
const
curveObject
=
this
.
getAlgorithmByOID
(
publicKeyAlgorithmParams
.
valueBlock
.
toString
(
)
true
)
;
parameters
.
algorithm
.
algorithm
.
namedCurve
=
curveObject
.
name
;
}
return
parameters
;
}
public
async
getPublicKey
(
publicKeyInfo
:
PublicKeyInfo
signatureAlgorithm
:
AlgorithmIdentifier
parameters
?
:
type
.
CryptoEnginePublicKeyParams
)
:
Promise
<
CryptoKey
>
{
if
(
!
parameters
)
{
parameters
=
this
.
fillPublicKeyParameters
(
publicKeyInfo
signatureAlgorithm
)
;
}
const
publicKeyInfoBuffer
=
publicKeyInfo
.
toSchema
(
)
.
toBER
(
false
)
;
return
this
.
importKey
(
"
spki
"
publicKeyInfoBuffer
parameters
.
algorithm
.
algorithm
as
Algorithm
true
parameters
.
algorithm
.
usages
)
;
}
public
async
verifyWithPublicKey
(
data
:
BufferSource
signature
:
asn1js
.
BitString
|
asn1js
.
OctetString
publicKeyInfo
:
PublicKeyInfo
signatureAlgorithm
:
AlgorithmIdentifier
shaAlgorithm
?
:
string
)
:
Promise
<
boolean
>
{
let
publicKey
:
CryptoKey
;
if
(
!
shaAlgorithm
)
{
shaAlgorithm
=
this
.
getHashAlgorithm
(
signatureAlgorithm
)
;
if
(
!
shaAlgorithm
)
throw
new
Error
(
Unsupported
signature
algorithm
:
{
signatureAlgorithm
.
algorithmId
}
)
;
publicKey
=
await
this
.
getPublicKey
(
publicKeyInfo
signatureAlgorithm
)
;
}
else
{
const
parameters
=
{
}
as
type
.
CryptoEnginePublicKeyParams
;
let
algorithmId
;
if
(
signatureAlgorithm
.
algorithmId
=
=
=
"
1
.
2
.
840
.
113549
.
1
.
1
.
10
"
)
algorithmId
=
signatureAlgorithm
.
algorithmId
;
else
algorithmId
=
publicKeyInfo
.
algorithm
.
algorithmId
;
const
algorithmObject
=
this
.
getAlgorithmByOID
(
algorithmId
true
)
;
parameters
.
algorithm
=
this
.
getAlgorithmParameters
(
algorithmObject
.
name
"
importKey
"
)
;
if
(
"
hash
"
in
parameters
.
algorithm
.
algorithm
)
(
parameters
.
algorithm
.
algorithm
as
any
)
.
hash
.
name
=
shaAlgorithm
;
if
(
algorithmObject
.
name
=
=
=
"
ECDSA
"
)
{
let
algorithmParamsChecked
=
false
;
if
(
(
"
algorithmParams
"
in
publicKeyInfo
.
algorithm
)
=
=
=
true
)
{
if
(
"
idBlock
"
in
publicKeyInfo
.
algorithm
.
algorithmParams
)
{
if
(
(
publicKeyInfo
.
algorithm
.
algorithmParams
.
idBlock
.
tagClass
=
=
=
1
)
&
&
(
publicKeyInfo
.
algorithm
.
algorithmParams
.
idBlock
.
tagNumber
=
=
=
6
)
)
algorithmParamsChecked
=
true
;
}
}
if
(
algorithmParamsChecked
=
=
=
false
)
{
throw
new
Error
(
"
Incorrect
type
for
ECDSA
public
key
parameters
"
)
;
}
const
curveObject
=
this
.
getAlgorithmByOID
(
publicKeyInfo
.
algorithm
.
algorithmParams
.
valueBlock
.
toString
(
)
true
)
;
(
parameters
.
algorithm
.
algorithm
as
any
)
.
namedCurve
=
curveObject
.
name
;
}
publicKey
=
await
this
.
getPublicKey
(
publicKeyInfo
null
as
any
parameters
)
;
}
const
algorithm
=
this
.
getAlgorithmParameters
(
publicKey
.
algorithm
.
name
"
verify
"
)
;
if
(
"
hash
"
in
algorithm
.
algorithm
)
(
algorithm
.
algorithm
as
any
)
.
hash
.
name
=
shaAlgorithm
;
let
signatureValue
:
Uint8Array
|
ArrayBuffer
=
signature
.
valueBlock
.
valueHexView
;
if
(
publicKey
.
algorithm
.
name
=
=
=
"
ECDSA
"
)
{
const
namedCurve
=
ECNamedCurves
.
find
(
(
publicKey
.
algorithm
as
EcKeyAlgorithm
)
.
namedCurve
)
;
if
(
!
namedCurve
)
{
throw
new
Error
(
"
Unsupported
named
curve
in
use
"
)
;
}
const
asn1
=
asn1js
.
fromBER
(
signatureValue
)
;
AsnError
.
assert
(
asn1
"
Signature
value
"
)
;
signatureValue
=
common
.
createECDSASignatureFromCMS
(
asn1
.
result
namedCurve
.
size
)
;
}
if
(
publicKey
.
algorithm
.
name
=
=
=
"
RSA
-
PSS
"
)
{
const
pssParameters
=
new
RSASSAPSSParams
(
{
schema
:
signatureAlgorithm
.
algorithmParams
}
)
;
if
(
"
saltLength
"
in
pssParameters
)
(
algorithm
.
algorithm
as
any
)
.
saltLength
=
pssParameters
.
saltLength
;
else
(
algorithm
.
algorithm
as
any
)
.
saltLength
=
20
;
let
hashAlgo
=
"
SHA
-
1
"
;
if
(
"
hashAlgorithm
"
in
pssParameters
)
{
const
hashAlgorithm
=
this
.
getAlgorithmByOID
(
pssParameters
.
hashAlgorithm
.
algorithmId
true
)
;
hashAlgo
=
hashAlgorithm
.
name
;
}
(
algorithm
.
algorithm
as
any
)
.
hash
.
name
=
hashAlgo
;
}
return
this
.
verify
(
(
algorithm
.
algorithm
as
any
)
publicKey
signatureValue
as
BufferSource
data
)
;
}
}
