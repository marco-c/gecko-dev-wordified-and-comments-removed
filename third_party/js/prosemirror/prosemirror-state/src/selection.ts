import
{
Slice
Fragment
ResolvedPos
Node
}
from
"
prosemirror
-
model
"
import
{
ReplaceStep
ReplaceAroundStep
Mappable
}
from
"
prosemirror
-
transform
"
import
{
Transaction
}
from
"
.
/
transaction
"
const
classesById
=
Object
.
create
(
null
)
export
abstract
class
Selection
{
constructor
(
readonly
anchor
:
ResolvedPos
readonly
head
:
ResolvedPos
ranges
?
:
readonly
SelectionRange
[
]
)
{
this
.
ranges
=
ranges
|
|
[
new
SelectionRange
(
anchor
.
min
(
head
)
anchor
.
max
(
head
)
)
]
}
ranges
:
readonly
SelectionRange
[
]
get
anchor
(
)
{
return
this
.
anchor
.
pos
}
get
head
(
)
{
return
this
.
head
.
pos
}
get
from
(
)
{
return
this
.
from
.
pos
}
get
to
(
)
{
return
this
.
to
.
pos
}
get
from
(
)
{
return
this
.
ranges
[
0
]
.
from
}
get
to
(
)
{
return
this
.
ranges
[
0
]
.
to
}
get
empty
(
)
:
boolean
{
let
ranges
=
this
.
ranges
for
(
let
i
=
0
;
i
<
ranges
.
length
;
i
+
+
)
if
(
ranges
[
i
]
.
from
.
pos
!
=
ranges
[
i
]
.
to
.
pos
)
return
false
return
true
}
abstract
eq
(
selection
:
Selection
)
:
boolean
abstract
map
(
doc
:
Node
mapping
:
Mappable
)
:
Selection
content
(
)
{
return
this
.
from
.
doc
.
slice
(
this
.
from
this
.
to
true
)
}
replace
(
tr
:
Transaction
content
=
Slice
.
empty
)
{
let
lastNode
=
content
.
content
.
lastChild
lastParent
=
null
for
(
let
i
=
0
;
i
<
content
.
openEnd
;
i
+
+
)
{
lastParent
=
lastNode
!
lastNode
=
lastNode
!
.
lastChild
}
let
mapFrom
=
tr
.
steps
.
length
ranges
=
this
.
ranges
for
(
let
i
=
0
;
i
<
ranges
.
length
;
i
+
+
)
{
let
{
from
to
}
=
ranges
[
i
]
mapping
=
tr
.
mapping
.
slice
(
mapFrom
)
tr
.
replaceRange
(
mapping
.
map
(
from
.
pos
)
mapping
.
map
(
to
.
pos
)
i
?
Slice
.
empty
:
content
)
if
(
i
=
=
0
)
selectionToInsertionEnd
(
tr
mapFrom
(
lastNode
?
lastNode
.
isInline
:
lastParent
&
&
lastParent
.
isTextblock
)
?
-
1
:
1
)
}
}
replaceWith
(
tr
:
Transaction
node
:
Node
)
{
let
mapFrom
=
tr
.
steps
.
length
ranges
=
this
.
ranges
for
(
let
i
=
0
;
i
<
ranges
.
length
;
i
+
+
)
{
let
{
from
to
}
=
ranges
[
i
]
mapping
=
tr
.
mapping
.
slice
(
mapFrom
)
let
from
=
mapping
.
map
(
from
.
pos
)
to
=
mapping
.
map
(
to
.
pos
)
if
(
i
)
{
tr
.
deleteRange
(
from
to
)
}
else
{
tr
.
replaceRangeWith
(
from
to
node
)
selectionToInsertionEnd
(
tr
mapFrom
node
.
isInline
?
-
1
:
1
)
}
}
}
abstract
toJSON
(
)
:
any
static
findFrom
(
pos
:
ResolvedPos
dir
:
number
textOnly
:
boolean
=
false
)
:
Selection
|
null
{
let
inner
=
pos
.
parent
.
inlineContent
?
new
TextSelection
(
pos
)
:
findSelectionIn
(
pos
.
node
(
0
)
pos
.
parent
pos
.
pos
pos
.
index
(
)
dir
textOnly
)
if
(
inner
)
return
inner
for
(
let
depth
=
pos
.
depth
-
1
;
depth
>
=
0
;
depth
-
-
)
{
let
found
=
dir
<
0
?
findSelectionIn
(
pos
.
node
(
0
)
pos
.
node
(
depth
)
pos
.
before
(
depth
+
1
)
pos
.
index
(
depth
)
dir
textOnly
)
:
findSelectionIn
(
pos
.
node
(
0
)
pos
.
node
(
depth
)
pos
.
after
(
depth
+
1
)
pos
.
index
(
depth
)
+
1
dir
textOnly
)
if
(
found
)
return
found
}
return
null
}
static
near
(
pos
:
ResolvedPos
bias
=
1
)
:
Selection
{
return
this
.
findFrom
(
pos
bias
)
|
|
this
.
findFrom
(
pos
-
bias
)
|
|
new
AllSelection
(
pos
.
node
(
0
)
)
}
static
atStart
(
doc
:
Node
)
:
Selection
{
return
findSelectionIn
(
doc
doc
0
0
1
)
|
|
new
AllSelection
(
doc
)
}
static
atEnd
(
doc
:
Node
)
:
Selection
{
return
findSelectionIn
(
doc
doc
doc
.
content
.
size
doc
.
childCount
-
1
)
|
|
new
AllSelection
(
doc
)
}
static
fromJSON
(
doc
:
Node
json
:
any
)
:
Selection
{
if
(
!
json
|
|
!
json
.
type
)
throw
new
RangeError
(
"
Invalid
input
for
Selection
.
fromJSON
"
)
let
cls
=
classesById
[
json
.
type
]
if
(
!
cls
)
throw
new
RangeError
(
No
selection
type
{
json
.
type
}
defined
)
return
cls
.
fromJSON
(
doc
json
)
}
static
jsonID
(
id
:
string
selectionClass
:
{
fromJSON
:
(
doc
:
Node
json
:
any
)
=
>
Selection
}
)
{
if
(
id
in
classesById
)
throw
new
RangeError
(
"
Duplicate
use
of
selection
JSON
ID
"
+
id
)
classesById
[
id
]
=
selectionClass
;
(
selectionClass
as
any
)
.
prototype
.
jsonID
=
id
return
selectionClass
}
getBookmark
(
)
:
SelectionBookmark
{
return
TextSelection
.
between
(
this
.
anchor
this
.
head
)
.
getBookmark
(
)
}
declare
visible
:
boolean
}
Selection
.
prototype
.
visible
=
true
export
interface
SelectionBookmark
{
map
:
(
mapping
:
Mappable
)
=
>
SelectionBookmark
resolve
:
(
doc
:
Node
)
=
>
Selection
}
export
class
SelectionRange
{
constructor
(
readonly
from
:
ResolvedPos
readonly
to
:
ResolvedPos
)
{
}
}
let
warnedAboutTextSelection
=
false
function
checkTextSelection
(
pos
:
ResolvedPos
)
{
if
(
!
warnedAboutTextSelection
&
&
!
pos
.
parent
.
inlineContent
)
{
warnedAboutTextSelection
=
true
console
[
"
warn
"
]
(
"
TextSelection
endpoint
not
pointing
into
a
node
with
inline
content
(
"
+
pos
.
parent
.
type
.
name
+
"
)
"
)
}
}
export
class
TextSelection
extends
Selection
{
constructor
(
anchor
:
ResolvedPos
head
=
anchor
)
{
checkTextSelection
(
anchor
)
checkTextSelection
(
head
)
super
(
anchor
head
)
}
get
cursor
(
)
{
return
this
.
anchor
.
pos
=
=
this
.
head
.
pos
?
this
.
head
:
null
}
map
(
doc
:
Node
mapping
:
Mappable
)
:
Selection
{
let
head
=
doc
.
resolve
(
mapping
.
map
(
this
.
head
)
)
if
(
!
head
.
parent
.
inlineContent
)
return
Selection
.
near
(
head
)
let
anchor
=
doc
.
resolve
(
mapping
.
map
(
this
.
anchor
)
)
return
new
TextSelection
(
anchor
.
parent
.
inlineContent
?
anchor
:
head
head
)
}
replace
(
tr
:
Transaction
content
=
Slice
.
empty
)
{
super
.
replace
(
tr
content
)
if
(
content
=
=
Slice
.
empty
)
{
let
marks
=
this
.
from
.
marksAcross
(
this
.
to
)
if
(
marks
)
tr
.
ensureMarks
(
marks
)
}
}
eq
(
other
:
Selection
)
:
boolean
{
return
other
instanceof
TextSelection
&
&
other
.
anchor
=
=
this
.
anchor
&
&
other
.
head
=
=
this
.
head
}
getBookmark
(
)
{
return
new
TextBookmark
(
this
.
anchor
this
.
head
)
}
toJSON
(
)
:
any
{
return
{
type
:
"
text
"
anchor
:
this
.
anchor
head
:
this
.
head
}
}
static
fromJSON
(
doc
:
Node
json
:
any
)
{
if
(
typeof
json
.
anchor
!
=
"
number
"
|
|
typeof
json
.
head
!
=
"
number
"
)
throw
new
RangeError
(
"
Invalid
input
for
TextSelection
.
fromJSON
"
)
return
new
TextSelection
(
doc
.
resolve
(
json
.
anchor
)
doc
.
resolve
(
json
.
head
)
)
}
static
create
(
doc
:
Node
anchor
:
number
head
=
anchor
)
{
let
anchor
=
doc
.
resolve
(
anchor
)
return
new
this
(
anchor
head
=
=
anchor
?
anchor
:
doc
.
resolve
(
head
)
)
}
static
between
(
anchor
:
ResolvedPos
head
:
ResolvedPos
bias
?
:
number
)
:
Selection
{
let
dPos
=
anchor
.
pos
-
head
.
pos
if
(
!
bias
|
|
dPos
)
bias
=
dPos
>
=
0
?
1
:
-
1
if
(
!
head
.
parent
.
inlineContent
)
{
let
found
=
Selection
.
findFrom
(
head
bias
true
)
|
|
Selection
.
findFrom
(
head
-
bias
true
)
if
(
found
)
head
=
found
.
head
else
return
Selection
.
near
(
head
bias
)
}
if
(
!
anchor
.
parent
.
inlineContent
)
{
if
(
dPos
=
=
0
)
{
anchor
=
head
}
else
{
anchor
=
(
Selection
.
findFrom
(
anchor
-
bias
true
)
|
|
Selection
.
findFrom
(
anchor
bias
true
)
)
!
.
anchor
if
(
(
anchor
.
pos
<
head
.
pos
)
!
=
(
dPos
<
0
)
)
anchor
=
head
}
}
return
new
TextSelection
(
anchor
head
)
}
}
Selection
.
jsonID
(
"
text
"
TextSelection
)
class
TextBookmark
{
constructor
(
readonly
anchor
:
number
readonly
head
:
number
)
{
}
map
(
mapping
:
Mappable
)
{
return
new
TextBookmark
(
mapping
.
map
(
this
.
anchor
)
mapping
.
map
(
this
.
head
)
)
}
resolve
(
doc
:
Node
)
{
return
TextSelection
.
between
(
doc
.
resolve
(
this
.
anchor
)
doc
.
resolve
(
this
.
head
)
)
}
}
export
class
NodeSelection
extends
Selection
{
constructor
(
pos
:
ResolvedPos
)
{
let
node
=
pos
.
nodeAfter
!
let
end
=
pos
.
node
(
0
)
.
resolve
(
pos
.
pos
+
node
.
nodeSize
)
super
(
pos
end
)
this
.
node
=
node
}
node
:
Node
map
(
doc
:
Node
mapping
:
Mappable
)
:
Selection
{
let
{
deleted
pos
}
=
mapping
.
mapResult
(
this
.
anchor
)
let
pos
=
doc
.
resolve
(
pos
)
if
(
deleted
)
return
Selection
.
near
(
pos
)
return
new
NodeSelection
(
pos
)
}
content
(
)
{
return
new
Slice
(
Fragment
.
from
(
this
.
node
)
0
0
)
}
eq
(
other
:
Selection
)
:
boolean
{
return
other
instanceof
NodeSelection
&
&
other
.
anchor
=
=
this
.
anchor
}
toJSON
(
)
:
any
{
return
{
type
:
"
node
"
anchor
:
this
.
anchor
}
}
getBookmark
(
)
{
return
new
NodeBookmark
(
this
.
anchor
)
}
static
fromJSON
(
doc
:
Node
json
:
any
)
{
if
(
typeof
json
.
anchor
!
=
"
number
"
)
throw
new
RangeError
(
"
Invalid
input
for
NodeSelection
.
fromJSON
"
)
return
new
NodeSelection
(
doc
.
resolve
(
json
.
anchor
)
)
}
static
create
(
doc
:
Node
from
:
number
)
{
return
new
NodeSelection
(
doc
.
resolve
(
from
)
)
}
static
isSelectable
(
node
:
Node
)
{
return
!
node
.
isText
&
&
node
.
type
.
spec
.
selectable
!
=
=
false
}
}
NodeSelection
.
prototype
.
visible
=
false
Selection
.
jsonID
(
"
node
"
NodeSelection
)
class
NodeBookmark
{
constructor
(
readonly
anchor
:
number
)
{
}
map
(
mapping
:
Mappable
)
{
let
{
deleted
pos
}
=
mapping
.
mapResult
(
this
.
anchor
)
return
deleted
?
new
TextBookmark
(
pos
pos
)
:
new
NodeBookmark
(
pos
)
}
resolve
(
doc
:
Node
)
{
let
pos
=
doc
.
resolve
(
this
.
anchor
)
node
=
pos
.
nodeAfter
if
(
node
&
&
NodeSelection
.
isSelectable
(
node
)
)
return
new
NodeSelection
(
pos
)
return
Selection
.
near
(
pos
)
}
}
export
class
AllSelection
extends
Selection
{
constructor
(
doc
:
Node
)
{
super
(
doc
.
resolve
(
0
)
doc
.
resolve
(
doc
.
content
.
size
)
)
}
replace
(
tr
:
Transaction
content
=
Slice
.
empty
)
{
if
(
content
=
=
Slice
.
empty
)
{
tr
.
delete
(
0
tr
.
doc
.
content
.
size
)
let
sel
=
Selection
.
atStart
(
tr
.
doc
)
if
(
!
sel
.
eq
(
tr
.
selection
)
)
tr
.
setSelection
(
sel
)
}
else
{
super
.
replace
(
tr
content
)
}
}
toJSON
(
)
:
any
{
return
{
type
:
"
all
"
}
}
static
fromJSON
(
doc
:
Node
)
{
return
new
AllSelection
(
doc
)
}
map
(
doc
:
Node
)
{
return
new
AllSelection
(
doc
)
}
eq
(
other
:
Selection
)
{
return
other
instanceof
AllSelection
}
getBookmark
(
)
{
return
AllBookmark
}
}
Selection
.
jsonID
(
"
all
"
AllSelection
)
const
AllBookmark
=
{
map
(
)
{
return
this
}
resolve
(
doc
:
Node
)
{
return
new
AllSelection
(
doc
)
}
}
function
findSelectionIn
(
doc
:
Node
node
:
Node
pos
:
number
index
:
number
dir
:
number
text
=
false
)
:
Selection
|
null
{
if
(
node
.
inlineContent
)
return
TextSelection
.
create
(
doc
pos
)
for
(
let
i
=
index
-
(
dir
>
0
?
0
:
1
)
;
dir
>
0
?
i
<
node
.
childCount
:
i
>
=
0
;
i
+
=
dir
)
{
let
child
=
node
.
child
(
i
)
if
(
!
child
.
isAtom
)
{
let
inner
=
findSelectionIn
(
doc
child
pos
+
dir
dir
<
0
?
child
.
childCount
:
0
dir
text
)
if
(
inner
)
return
inner
}
else
if
(
!
text
&
&
NodeSelection
.
isSelectable
(
child
)
)
{
return
NodeSelection
.
create
(
doc
pos
-
(
dir
<
0
?
child
.
nodeSize
:
0
)
)
}
pos
+
=
child
.
nodeSize
*
dir
}
return
null
}
function
selectionToInsertionEnd
(
tr
:
Transaction
startLen
:
number
bias
:
number
)
{
let
last
=
tr
.
steps
.
length
-
1
if
(
last
<
startLen
)
return
let
step
=
tr
.
steps
[
last
]
if
(
!
(
step
instanceof
ReplaceStep
|
|
step
instanceof
ReplaceAroundStep
)
)
return
let
map
=
tr
.
mapping
.
maps
[
last
]
end
:
number
|
undefined
map
.
forEach
(
(
_from
_to
_newFrom
newTo
)
=
>
{
if
(
end
=
=
null
)
end
=
newTo
}
)
tr
.
setSelection
(
Selection
.
near
(
tr
.
doc
.
resolve
(
end
!
)
bias
)
)
}
