import
{
Transform
Step
}
from
"
prosemirror
-
transform
"
import
{
Mark
MarkType
Node
Slice
}
from
"
prosemirror
-
model
"
import
{
type
EditorView
}
from
"
prosemirror
-
view
"
import
{
Selection
}
from
"
.
/
selection
"
import
{
Plugin
PluginKey
}
from
"
.
/
plugin
"
import
{
EditorState
}
from
"
.
/
state
"
export
type
Command
=
(
state
:
EditorState
dispatch
?
:
(
tr
:
Transaction
)
=
>
void
view
?
:
EditorView
)
=
>
boolean
const
UPDATED_SEL
=
1
UPDATED_MARKS
=
2
UPDATED_SCROLL
=
4
export
class
Transaction
extends
Transform
{
time
:
number
private
curSelection
:
Selection
private
curSelectionFor
=
0
private
updated
=
0
private
meta
:
{
[
name
:
string
]
:
any
}
=
Object
.
create
(
null
)
storedMarks
:
readonly
Mark
[
]
|
null
constructor
(
state
:
EditorState
)
{
super
(
state
.
doc
)
this
.
time
=
Date
.
now
(
)
this
.
curSelection
=
state
.
selection
this
.
storedMarks
=
state
.
storedMarks
}
get
selection
(
)
:
Selection
{
if
(
this
.
curSelectionFor
<
this
.
steps
.
length
)
{
this
.
curSelection
=
this
.
curSelection
.
map
(
this
.
doc
this
.
mapping
.
slice
(
this
.
curSelectionFor
)
)
this
.
curSelectionFor
=
this
.
steps
.
length
}
return
this
.
curSelection
}
setSelection
(
selection
:
Selection
)
:
this
{
if
(
selection
.
from
.
doc
!
=
this
.
doc
)
throw
new
RangeError
(
"
Selection
passed
to
setSelection
must
point
at
the
current
document
"
)
this
.
curSelection
=
selection
this
.
curSelectionFor
=
this
.
steps
.
length
this
.
updated
=
(
this
.
updated
|
UPDATED_SEL
)
&
~
UPDATED_MARKS
this
.
storedMarks
=
null
return
this
}
get
selectionSet
(
)
{
return
(
this
.
updated
&
UPDATED_SEL
)
>
0
}
setStoredMarks
(
marks
:
readonly
Mark
[
]
|
null
)
:
this
{
this
.
storedMarks
=
marks
this
.
updated
|
=
UPDATED_MARKS
return
this
}
ensureMarks
(
marks
:
readonly
Mark
[
]
)
:
this
{
if
(
!
Mark
.
sameSet
(
this
.
storedMarks
|
|
this
.
selection
.
from
.
marks
(
)
marks
)
)
this
.
setStoredMarks
(
marks
)
return
this
}
addStoredMark
(
mark
:
Mark
)
:
this
{
return
this
.
ensureMarks
(
mark
.
addToSet
(
this
.
storedMarks
|
|
this
.
selection
.
head
.
marks
(
)
)
)
}
removeStoredMark
(
mark
:
Mark
|
MarkType
)
:
this
{
return
this
.
ensureMarks
(
mark
.
removeFromSet
(
this
.
storedMarks
|
|
this
.
selection
.
head
.
marks
(
)
)
)
}
get
storedMarksSet
(
)
{
return
(
this
.
updated
&
UPDATED_MARKS
)
>
0
}
addStep
(
step
:
Step
doc
:
Node
)
{
super
.
addStep
(
step
doc
)
this
.
updated
=
this
.
updated
&
~
UPDATED_MARKS
this
.
storedMarks
=
null
}
setTime
(
time
:
number
)
:
this
{
this
.
time
=
time
return
this
}
replaceSelection
(
slice
:
Slice
)
:
this
{
this
.
selection
.
replace
(
this
slice
)
return
this
}
replaceSelectionWith
(
node
:
Node
inheritMarks
=
true
)
:
this
{
let
selection
=
this
.
selection
if
(
inheritMarks
)
node
=
node
.
mark
(
this
.
storedMarks
|
|
(
selection
.
empty
?
selection
.
from
.
marks
(
)
:
(
selection
.
from
.
marksAcross
(
selection
.
to
)
|
|
Mark
.
none
)
)
)
selection
.
replaceWith
(
this
node
)
return
this
}
deleteSelection
(
)
:
this
{
this
.
selection
.
replace
(
this
)
return
this
}
insertText
(
text
:
string
from
?
:
number
to
?
:
number
)
:
this
{
let
schema
=
this
.
doc
.
type
.
schema
if
(
from
=
=
null
)
{
if
(
!
text
)
return
this
.
deleteSelection
(
)
return
this
.
replaceSelectionWith
(
schema
.
text
(
text
)
true
)
}
else
{
if
(
to
=
=
null
)
to
=
from
if
(
!
text
)
return
this
.
deleteRange
(
from
to
)
let
marks
=
this
.
storedMarks
if
(
!
marks
)
{
let
from
=
this
.
doc
.
resolve
(
from
)
marks
=
to
=
=
from
?
from
.
marks
(
)
:
from
.
marksAcross
(
this
.
doc
.
resolve
(
to
)
)
}
this
.
replaceRangeWith
(
from
to
schema
.
text
(
text
marks
)
)
if
(
!
this
.
selection
.
empty
&
&
this
.
selection
.
to
=
=
from
+
text
.
length
)
this
.
setSelection
(
Selection
.
near
(
this
.
selection
.
to
)
)
return
this
}
}
setMeta
(
key
:
string
|
Plugin
|
PluginKey
value
:
any
)
:
this
{
this
.
meta
[
typeof
key
=
=
"
string
"
?
key
:
key
.
key
]
=
value
return
this
}
getMeta
(
key
:
string
|
Plugin
|
PluginKey
)
{
return
this
.
meta
[
typeof
key
=
=
"
string
"
?
key
:
key
.
key
]
}
get
isGeneric
(
)
{
for
(
let
_
in
this
.
meta
)
return
false
return
true
}
scrollIntoView
(
)
:
this
{
this
.
updated
|
=
UPDATED_SCROLL
return
this
}
get
scrolledIntoView
(
)
{
return
(
this
.
updated
&
UPDATED_SCROLL
)
>
0
}
}
