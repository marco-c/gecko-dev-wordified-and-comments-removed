import
{
Node
Mark
Schema
}
from
"
prosemirror
-
model
"
import
{
Selection
TextSelection
}
from
"
.
/
selection
"
import
{
Transaction
}
from
"
.
/
transaction
"
import
{
Plugin
StateField
}
from
"
.
/
plugin
"
function
bind
<
T
extends
Function
>
(
f
:
T
self
:
any
)
:
T
{
return
!
self
|
|
!
f
?
f
:
f
.
bind
(
self
)
}
class
FieldDesc
<
T
>
{
init
:
(
config
:
EditorStateConfig
instance
:
EditorState
)
=
>
T
apply
:
(
tr
:
Transaction
value
:
T
oldState
:
EditorState
newState
:
EditorState
)
=
>
T
constructor
(
readonly
name
:
string
desc
:
StateField
<
any
>
self
?
:
any
)
{
this
.
init
=
bind
(
desc
.
init
self
)
this
.
apply
=
bind
(
desc
.
apply
self
)
}
}
const
baseFields
=
[
new
FieldDesc
<
Node
>
(
"
doc
"
{
init
(
config
)
{
return
config
.
doc
|
|
config
.
schema
!
.
topNodeType
.
createAndFill
(
)
}
apply
(
tr
)
{
return
tr
.
doc
}
}
)
new
FieldDesc
<
Selection
>
(
"
selection
"
{
init
(
config
instance
)
{
return
config
.
selection
|
|
Selection
.
atStart
(
instance
.
doc
)
}
apply
(
tr
)
{
return
tr
.
selection
}
}
)
new
FieldDesc
<
readonly
Mark
[
]
|
null
>
(
"
storedMarks
"
{
init
(
config
)
{
return
config
.
storedMarks
|
|
null
}
apply
(
tr
_marks
_old
state
)
{
return
(
state
.
selection
as
TextSelection
)
.
cursor
?
tr
.
storedMarks
:
null
}
}
)
new
FieldDesc
<
number
>
(
"
scrollToSelection
"
{
init
(
)
{
return
0
}
apply
(
tr
prev
)
{
return
tr
.
scrolledIntoView
?
prev
+
1
:
prev
}
}
)
]
class
Configuration
{
fields
:
FieldDesc
<
any
>
[
]
plugins
:
Plugin
[
]
=
[
]
pluginsByKey
:
{
[
key
:
string
]
:
Plugin
}
=
Object
.
create
(
null
)
constructor
(
readonly
schema
:
Schema
plugins
?
:
readonly
Plugin
[
]
)
{
this
.
fields
=
baseFields
.
slice
(
)
if
(
plugins
)
plugins
.
forEach
(
plugin
=
>
{
if
(
this
.
pluginsByKey
[
plugin
.
key
]
)
throw
new
RangeError
(
"
Adding
different
instances
of
a
keyed
plugin
(
"
+
plugin
.
key
+
"
)
"
)
this
.
plugins
.
push
(
plugin
)
this
.
pluginsByKey
[
plugin
.
key
]
=
plugin
if
(
plugin
.
spec
.
state
)
this
.
fields
.
push
(
new
FieldDesc
<
any
>
(
plugin
.
key
plugin
.
spec
.
state
plugin
)
)
}
)
}
}
export
interface
EditorStateConfig
{
schema
?
:
Schema
doc
?
:
Node
selection
?
:
Selection
storedMarks
?
:
readonly
Mark
[
]
|
null
plugins
?
:
readonly
Plugin
[
]
}
export
class
EditorState
{
constructor
(
readonly
config
:
Configuration
)
{
}
declare
doc
:
Node
declare
selection
:
Selection
declare
storedMarks
:
readonly
Mark
[
]
|
null
get
schema
(
)
:
Schema
{
return
this
.
config
.
schema
}
get
plugins
(
)
:
readonly
Plugin
[
]
{
return
this
.
config
.
plugins
}
apply
(
tr
:
Transaction
)
:
EditorState
{
return
this
.
applyTransaction
(
tr
)
.
state
}
filterTransaction
(
tr
:
Transaction
ignore
=
-
1
)
{
for
(
let
i
=
0
;
i
<
this
.
config
.
plugins
.
length
;
i
+
+
)
if
(
i
!
=
ignore
)
{
let
plugin
=
this
.
config
.
plugins
[
i
]
if
(
plugin
.
spec
.
filterTransaction
&
&
!
plugin
.
spec
.
filterTransaction
.
call
(
plugin
tr
this
)
)
return
false
}
return
true
}
applyTransaction
(
rootTr
:
Transaction
)
:
{
state
:
EditorState
transactions
:
readonly
Transaction
[
]
}
{
if
(
!
this
.
filterTransaction
(
rootTr
)
)
return
{
state
:
this
transactions
:
[
]
}
let
trs
=
[
rootTr
]
newState
=
this
.
applyInner
(
rootTr
)
seen
=
null
for
(
;
;
)
{
let
haveNew
=
false
for
(
let
i
=
0
;
i
<
this
.
config
.
plugins
.
length
;
i
+
+
)
{
let
plugin
=
this
.
config
.
plugins
[
i
]
if
(
plugin
.
spec
.
appendTransaction
)
{
let
n
=
seen
?
seen
[
i
]
.
n
:
0
oldState
=
seen
?
seen
[
i
]
.
state
:
this
let
tr
=
n
<
trs
.
length
&
&
plugin
.
spec
.
appendTransaction
.
call
(
plugin
n
?
trs
.
slice
(
n
)
:
trs
oldState
newState
)
if
(
tr
&
&
newState
.
filterTransaction
(
tr
i
)
)
{
tr
.
setMeta
(
"
appendedTransaction
"
rootTr
)
if
(
!
seen
)
{
seen
=
[
]
for
(
let
j
=
0
;
j
<
this
.
config
.
plugins
.
length
;
j
+
+
)
seen
.
push
(
j
<
i
?
{
state
:
newState
n
:
trs
.
length
}
:
{
state
:
this
n
:
0
}
)
}
trs
.
push
(
tr
)
newState
=
newState
.
applyInner
(
tr
)
haveNew
=
true
}
if
(
seen
)
seen
[
i
]
=
{
state
:
newState
n
:
trs
.
length
}
}
}
if
(
!
haveNew
)
return
{
state
:
newState
transactions
:
trs
}
}
}
applyInner
(
tr
:
Transaction
)
{
if
(
!
tr
.
before
.
eq
(
this
.
doc
)
)
throw
new
RangeError
(
"
Applying
a
mismatched
transaction
"
)
let
newInstance
=
new
EditorState
(
this
.
config
)
fields
=
this
.
config
.
fields
for
(
let
i
=
0
;
i
<
fields
.
length
;
i
+
+
)
{
let
field
=
fields
[
i
]
;
(
newInstance
as
any
)
[
field
.
name
]
=
field
.
apply
(
tr
(
this
as
any
)
[
field
.
name
]
this
newInstance
)
}
return
newInstance
}
get
tr
(
)
:
Transaction
{
return
new
Transaction
(
this
)
}
static
create
(
config
:
EditorStateConfig
)
{
let
config
=
new
Configuration
(
config
.
doc
?
config
.
doc
.
type
.
schema
:
config
.
schema
!
config
.
plugins
)
let
instance
=
new
EditorState
(
config
)
for
(
let
i
=
0
;
i
<
config
.
fields
.
length
;
i
+
+
)
(
instance
as
any
)
[
config
.
fields
[
i
]
.
name
]
=
config
.
fields
[
i
]
.
init
(
config
instance
)
return
instance
}
reconfigure
(
config
:
{
plugins
?
:
readonly
Plugin
[
]
}
)
{
let
config
=
new
Configuration
(
this
.
schema
config
.
plugins
)
let
fields
=
config
.
fields
instance
=
new
EditorState
(
config
)
for
(
let
i
=
0
;
i
<
fields
.
length
;
i
+
+
)
{
let
name
=
fields
[
i
]
.
name
;
(
instance
as
any
)
[
name
]
=
this
.
hasOwnProperty
(
name
)
?
(
this
as
any
)
[
name
]
:
fields
[
i
]
.
init
(
config
instance
)
}
return
instance
}
toJSON
(
pluginFields
?
:
{
[
propName
:
string
]
:
Plugin
}
)
:
any
{
let
result
:
any
=
{
doc
:
this
.
doc
.
toJSON
(
)
selection
:
this
.
selection
.
toJSON
(
)
}
if
(
this
.
storedMarks
)
result
.
storedMarks
=
this
.
storedMarks
.
map
(
m
=
>
m
.
toJSON
(
)
)
if
(
pluginFields
&
&
typeof
pluginFields
=
=
'
object
'
)
for
(
let
prop
in
pluginFields
)
{
if
(
prop
=
=
"
doc
"
|
|
prop
=
=
"
selection
"
)
throw
new
RangeError
(
"
The
JSON
fields
doc
and
selection
are
reserved
"
)
let
plugin
=
pluginFields
[
prop
]
state
=
plugin
.
spec
.
state
if
(
state
&
&
state
.
toJSON
)
result
[
prop
]
=
state
.
toJSON
.
call
(
plugin
(
this
as
any
)
[
plugin
.
key
]
)
}
return
result
}
static
fromJSON
(
config
:
{
schema
:
Schema
plugins
?
:
readonly
Plugin
[
]
}
json
:
any
pluginFields
?
:
{
[
propName
:
string
]
:
Plugin
}
)
{
if
(
!
json
)
throw
new
RangeError
(
"
Invalid
input
for
EditorState
.
fromJSON
"
)
if
(
!
config
.
schema
)
throw
new
RangeError
(
"
Required
config
field
'
schema
'
missing
"
)
let
config
=
new
Configuration
(
config
.
schema
config
.
plugins
)
let
instance
=
new
EditorState
(
config
)
config
.
fields
.
forEach
(
field
=
>
{
if
(
field
.
name
=
=
"
doc
"
)
{
instance
.
doc
=
Node
.
fromJSON
(
config
.
schema
json
.
doc
)
}
else
if
(
field
.
name
=
=
"
selection
"
)
{
instance
.
selection
=
Selection
.
fromJSON
(
instance
.
doc
json
.
selection
)
}
else
if
(
field
.
name
=
=
"
storedMarks
"
)
{
if
(
json
.
storedMarks
)
instance
.
storedMarks
=
json
.
storedMarks
.
map
(
config
.
schema
.
markFromJSON
)
}
else
{
if
(
pluginFields
)
for
(
let
prop
in
pluginFields
)
{
let
plugin
=
pluginFields
[
prop
]
state
=
plugin
.
spec
.
state
if
(
plugin
.
key
=
=
field
.
name
&
&
state
&
&
state
.
fromJSON
&
&
Object
.
prototype
.
hasOwnProperty
.
call
(
json
prop
)
)
{
;
(
instance
as
any
)
[
field
.
name
]
=
state
.
fromJSON
.
call
(
plugin
config
json
[
prop
]
instance
)
return
}
}
;
(
instance
as
any
)
[
field
.
name
]
=
field
.
init
(
config
instance
)
}
}
)
return
instance
}
}
