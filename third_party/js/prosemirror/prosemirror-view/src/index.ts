import
{
NodeSelection
EditorState
Plugin
PluginView
Transaction
Selection
}
from
"
prosemirror
-
state
"
import
{
Slice
ResolvedPos
DOMParser
DOMSerializer
Node
Mark
}
from
"
prosemirror
-
model
"
import
{
scrollRectIntoView
posAtCoords
coordsAtPos
endOfTextblock
storeScrollPos
resetScrollPos
focusPreventScroll
}
from
"
.
/
domcoords
"
import
{
docViewDesc
ViewDesc
NodeView
NodeViewDesc
MarkView
}
from
"
.
/
viewdesc
"
import
{
initInput
destroyInput
dispatchEvent
ensureListeners
clearComposition
InputState
doPaste
Dragging
findCompositionNode
}
from
"
.
/
input
"
import
{
selectionToDOM
anchorInRightPlace
syncNodeSelection
}
from
"
.
/
selection
"
import
{
Decoration
viewDecorations
DecorationSource
}
from
"
.
/
decoration
"
import
{
DOMObserver
safariShadowSelectionRange
}
from
"
.
/
domobserver
"
import
{
readDOMChange
}
from
"
.
/
domchange
"
import
{
DOMSelection
DOMNode
DOMSelectionRange
deepActiveElement
clearReusedRange
}
from
"
.
/
dom
"
import
*
as
browser
from
"
.
/
browser
"
export
{
Decoration
DecorationSet
DecorationAttrs
DecorationSource
}
from
"
.
/
decoration
"
export
{
NodeView
MarkView
ViewMutationRecord
}
from
"
.
/
viewdesc
"
import
{
serializeForClipboard
parseFromClipboard
}
from
"
.
/
clipboard
"
import
{
endComposition
}
from
"
.
/
input
"
export
const
__parseFromClipboard
=
parseFromClipboard
export
const
__endComposition
=
endComposition
export
class
EditorView
{
_props
:
DirectEditorProps
private
directPlugins
:
readonly
Plugin
[
]
private
_root
:
Document
|
ShadowRoot
|
null
=
null
focused
=
false
trackWrites
:
DOMNode
|
null
=
null
private
mounted
=
false
markCursor
:
readonly
Mark
[
]
|
null
=
null
cursorWrapper
:
{
dom
:
DOMNode
deco
:
Decoration
}
|
null
=
null
nodeViews
:
NodeViewSet
lastSelectedViewDesc
:
ViewDesc
|
undefined
=
undefined
docView
:
NodeViewDesc
input
=
new
InputState
private
prevDirectPlugins
:
readonly
Plugin
[
]
=
[
]
private
pluginViews
:
PluginView
[
]
=
[
]
declare
domObserver
:
DOMObserver
requiresGeckoHackNode
:
boolean
=
false
public
state
:
EditorState
constructor
(
place
:
null
|
DOMNode
|
(
(
editor
:
HTMLElement
)
=
>
void
)
|
{
mount
:
HTMLElement
}
props
:
DirectEditorProps
)
{
this
.
_props
=
props
this
.
state
=
props
.
state
this
.
directPlugins
=
props
.
plugins
|
|
[
]
this
.
directPlugins
.
forEach
(
checkStateComponent
)
this
.
dispatch
=
this
.
dispatch
.
bind
(
this
)
this
.
dom
=
(
place
&
&
(
place
as
{
mount
:
HTMLElement
}
)
.
mount
)
|
|
document
.
createElement
(
"
div
"
)
if
(
place
)
{
if
(
(
place
as
DOMNode
)
.
appendChild
)
(
place
as
DOMNode
)
.
appendChild
(
this
.
dom
)
else
if
(
typeof
place
=
=
"
function
"
)
place
(
this
.
dom
)
else
if
(
(
place
as
{
mount
:
HTMLElement
}
)
.
mount
)
this
.
mounted
=
true
}
this
.
editable
=
getEditable
(
this
)
updateCursorWrapper
(
this
)
this
.
nodeViews
=
buildNodeViews
(
this
)
this
.
docView
=
docViewDesc
(
this
.
state
.
doc
computeDocDeco
(
this
)
viewDecorations
(
this
)
this
.
dom
this
)
this
.
domObserver
=
new
DOMObserver
(
this
(
from
to
typeOver
added
)
=
>
readDOMChange
(
this
from
to
typeOver
added
)
)
this
.
domObserver
.
start
(
)
initInput
(
this
)
this
.
updatePluginViews
(
)
}
readonly
dom
:
HTMLElement
editable
:
boolean
dragging
:
null
|
{
slice
:
Slice
move
:
boolean
}
=
null
get
composing
(
)
{
return
this
.
input
.
composing
}
get
props
(
)
{
if
(
this
.
_props
.
state
!
=
this
.
state
)
{
let
prev
=
this
.
_props
this
.
_props
=
{
}
as
any
for
(
let
name
in
prev
)
(
this
.
_props
as
any
)
[
name
]
=
(
prev
as
any
)
[
name
]
this
.
_props
.
state
=
this
.
state
}
return
this
.
_props
}
update
(
props
:
DirectEditorProps
)
{
if
(
props
.
handleDOMEvents
!
=
this
.
_props
.
handleDOMEvents
)
ensureListeners
(
this
)
let
prevProps
=
this
.
_props
this
.
_props
=
props
if
(
props
.
plugins
)
{
props
.
plugins
.
forEach
(
checkStateComponent
)
this
.
directPlugins
=
props
.
plugins
}
this
.
updateStateInner
(
props
.
state
prevProps
)
}
setProps
(
props
:
Partial
<
DirectEditorProps
>
)
{
let
updated
=
{
}
as
DirectEditorProps
for
(
let
name
in
this
.
_props
)
(
updated
as
any
)
[
name
]
=
(
this
.
_props
as
any
)
[
name
]
updated
.
state
=
this
.
state
for
(
let
name
in
props
)
(
updated
as
any
)
[
name
]
=
(
props
as
any
)
[
name
]
this
.
update
(
updated
)
}
updateState
(
state
:
EditorState
)
{
this
.
updateStateInner
(
state
this
.
_props
)
}
private
updateStateInner
(
state
:
EditorState
prevProps
:
DirectEditorProps
)
{
let
prev
=
this
.
state
redraw
=
false
updateSel
=
false
if
(
state
.
storedMarks
&
&
this
.
composing
)
{
clearComposition
(
this
)
updateSel
=
true
}
this
.
state
=
state
let
pluginsChanged
=
prev
.
plugins
!
=
state
.
plugins
|
|
this
.
_props
.
plugins
!
=
prevProps
.
plugins
if
(
pluginsChanged
|
|
this
.
_props
.
plugins
!
=
prevProps
.
plugins
|
|
this
.
_props
.
nodeViews
!
=
prevProps
.
nodeViews
)
{
let
nodeViews
=
buildNodeViews
(
this
)
if
(
changedNodeViews
(
nodeViews
this
.
nodeViews
)
)
{
this
.
nodeViews
=
nodeViews
redraw
=
true
}
}
if
(
pluginsChanged
|
|
prevProps
.
handleDOMEvents
!
=
this
.
_props
.
handleDOMEvents
)
{
ensureListeners
(
this
)
}
this
.
editable
=
getEditable
(
this
)
updateCursorWrapper
(
this
)
let
innerDeco
=
viewDecorations
(
this
)
outerDeco
=
computeDocDeco
(
this
)
let
scroll
=
prev
.
plugins
!
=
state
.
plugins
&
&
!
prev
.
doc
.
eq
(
state
.
doc
)
?
"
reset
"
:
(
state
as
any
)
.
scrollToSelection
>
(
prev
as
any
)
.
scrollToSelection
?
"
to
selection
"
:
"
preserve
"
let
updateDoc
=
redraw
|
|
!
this
.
docView
.
matchesNode
(
state
.
doc
outerDeco
innerDeco
)
if
(
updateDoc
|
|
!
state
.
selection
.
eq
(
prev
.
selection
)
)
updateSel
=
true
let
oldScrollPos
=
scroll
=
=
"
preserve
"
&
&
updateSel
&
&
this
.
dom
.
style
.
overflowAnchor
=
=
null
&
&
storeScrollPos
(
this
)
if
(
updateSel
)
{
this
.
domObserver
.
stop
(
)
let
forceSelUpdate
=
updateDoc
&
&
(
browser
.
ie
|
|
browser
.
chrome
)
&
&
!
this
.
composing
&
&
!
prev
.
selection
.
empty
&
&
!
state
.
selection
.
empty
&
&
selectionContextChanged
(
prev
.
selection
state
.
selection
)
if
(
updateDoc
)
{
let
chromeKludge
=
browser
.
chrome
?
(
this
.
trackWrites
=
this
.
domSelectionRange
(
)
.
focusNode
)
:
null
if
(
this
.
composing
)
this
.
input
.
compositionNode
=
findCompositionNode
(
this
)
if
(
redraw
|
|
!
this
.
docView
.
update
(
state
.
doc
outerDeco
innerDeco
this
)
)
{
this
.
docView
.
updateOuterDeco
(
outerDeco
)
this
.
docView
.
destroy
(
)
this
.
docView
=
docViewDesc
(
state
.
doc
outerDeco
innerDeco
this
.
dom
this
)
}
if
(
chromeKludge
&
&
!
this
.
trackWrites
)
forceSelUpdate
=
true
}
if
(
forceSelUpdate
|
|
!
(
this
.
input
.
mouseDown
&
&
this
.
domObserver
.
currentSelection
.
eq
(
this
.
domSelectionRange
(
)
)
&
&
anchorInRightPlace
(
this
)
)
)
{
selectionToDOM
(
this
forceSelUpdate
)
}
else
{
syncNodeSelection
(
this
state
.
selection
)
this
.
domObserver
.
setCurSelection
(
)
}
this
.
domObserver
.
start
(
)
}
this
.
updatePluginViews
(
prev
)
if
(
(
this
.
dragging
as
Dragging
)
?
.
node
&
&
!
prev
.
doc
.
eq
(
state
.
doc
)
)
this
.
updateDraggedNode
(
this
.
dragging
as
Dragging
prev
)
if
(
scroll
=
=
"
reset
"
)
{
this
.
dom
.
scrollTop
=
0
}
else
if
(
scroll
=
=
"
to
selection
"
)
{
this
.
scrollToSelection
(
)
}
else
if
(
oldScrollPos
)
{
resetScrollPos
(
oldScrollPos
)
}
}
scrollToSelection
(
)
{
let
startDOM
=
this
.
domSelectionRange
(
)
.
focusNode
if
(
!
startDOM
|
|
!
this
.
dom
.
contains
(
startDOM
.
nodeType
=
=
1
?
startDOM
:
startDOM
.
parentNode
)
)
{
}
else
if
(
this
.
someProp
(
"
handleScrollToSelection
"
f
=
>
f
(
this
)
)
)
{
}
else
if
(
this
.
state
.
selection
instanceof
NodeSelection
)
{
let
target
=
this
.
docView
.
domAfterPos
(
this
.
state
.
selection
.
from
)
if
(
target
.
nodeType
=
=
1
)
scrollRectIntoView
(
this
(
target
as
HTMLElement
)
.
getBoundingClientRect
(
)
startDOM
)
}
else
{
scrollRectIntoView
(
this
this
.
coordsAtPos
(
this
.
state
.
selection
.
head
1
)
startDOM
)
}
}
private
destroyPluginViews
(
)
{
let
view
while
(
view
=
this
.
pluginViews
.
pop
(
)
)
if
(
view
.
destroy
)
view
.
destroy
(
)
}
private
updatePluginViews
(
prevState
?
:
EditorState
)
{
if
(
!
prevState
|
|
prevState
.
plugins
!
=
this
.
state
.
plugins
|
|
this
.
directPlugins
!
=
this
.
prevDirectPlugins
)
{
this
.
prevDirectPlugins
=
this
.
directPlugins
this
.
destroyPluginViews
(
)
for
(
let
i
=
0
;
i
<
this
.
directPlugins
.
length
;
i
+
+
)
{
let
plugin
=
this
.
directPlugins
[
i
]
if
(
plugin
.
spec
.
view
)
this
.
pluginViews
.
push
(
plugin
.
spec
.
view
(
this
)
)
}
for
(
let
i
=
0
;
i
<
this
.
state
.
plugins
.
length
;
i
+
+
)
{
let
plugin
=
this
.
state
.
plugins
[
i
]
if
(
plugin
.
spec
.
view
)
this
.
pluginViews
.
push
(
plugin
.
spec
.
view
(
this
)
)
}
}
else
{
for
(
let
i
=
0
;
i
<
this
.
pluginViews
.
length
;
i
+
+
)
{
let
pluginView
=
this
.
pluginViews
[
i
]
if
(
pluginView
.
update
)
pluginView
.
update
(
this
prevState
)
}
}
}
private
updateDraggedNode
(
dragging
:
Dragging
prev
:
EditorState
)
{
let
sel
=
dragging
.
node
!
found
=
-
1
if
(
this
.
state
.
doc
.
nodeAt
(
sel
.
from
)
=
=
sel
.
node
)
{
found
=
sel
.
from
}
else
{
let
movedPos
=
sel
.
from
+
(
this
.
state
.
doc
.
content
.
size
-
prev
.
doc
.
content
.
size
)
let
moved
=
movedPos
>
0
&
&
this
.
state
.
doc
.
nodeAt
(
movedPos
)
if
(
moved
=
=
sel
.
node
)
found
=
movedPos
}
this
.
dragging
=
new
Dragging
(
dragging
.
slice
dragging
.
move
found
<
0
?
undefined
:
NodeSelection
.
create
(
this
.
state
.
doc
found
)
)
}
someProp
<
PropName
extends
keyof
EditorProps
Result
>
(
propName
:
PropName
f
:
(
value
:
NonNullable
<
EditorProps
[
PropName
]
>
)
=
>
Result
)
:
Result
|
undefined
someProp
<
PropName
extends
keyof
EditorProps
>
(
propName
:
PropName
)
:
NonNullable
<
EditorProps
[
PropName
]
>
|
undefined
someProp
<
PropName
extends
keyof
EditorProps
Result
>
(
propName
:
PropName
f
?
:
(
value
:
NonNullable
<
EditorProps
[
PropName
]
>
)
=
>
Result
)
:
Result
|
undefined
{
let
prop
=
this
.
_props
&
&
this
.
_props
[
propName
]
value
if
(
prop
!
=
null
&
&
(
value
=
f
?
f
(
prop
as
any
)
:
prop
)
)
return
value
as
any
for
(
let
i
=
0
;
i
<
this
.
directPlugins
.
length
;
i
+
+
)
{
let
prop
=
this
.
directPlugins
[
i
]
.
props
[
propName
]
if
(
prop
!
=
null
&
&
(
value
=
f
?
f
(
prop
as
any
)
:
prop
)
)
return
value
as
any
}
let
plugins
=
this
.
state
.
plugins
if
(
plugins
)
for
(
let
i
=
0
;
i
<
plugins
.
length
;
i
+
+
)
{
let
prop
=
plugins
[
i
]
.
props
[
propName
]
if
(
prop
!
=
null
&
&
(
value
=
f
?
f
(
prop
as
any
)
:
prop
)
)
return
value
as
any
}
}
hasFocus
(
)
{
if
(
browser
.
ie
)
{
let
node
=
this
.
root
.
activeElement
if
(
node
=
=
this
.
dom
)
return
true
if
(
!
node
|
|
!
this
.
dom
.
contains
(
node
)
)
return
false
while
(
node
&
&
this
.
dom
!
=
node
&
&
this
.
dom
.
contains
(
node
)
)
{
if
(
(
node
as
HTMLElement
)
.
contentEditable
=
=
'
false
'
)
return
false
node
=
node
.
parentElement
}
return
true
}
return
this
.
root
.
activeElement
=
=
this
.
dom
}
focus
(
)
{
this
.
domObserver
.
stop
(
)
if
(
this
.
editable
)
focusPreventScroll
(
this
.
dom
)
selectionToDOM
(
this
)
this
.
domObserver
.
start
(
)
}
get
root
(
)
:
Document
|
ShadowRoot
{
let
cached
=
this
.
_root
if
(
cached
=
=
null
)
for
(
let
search
=
this
.
dom
.
parentNode
;
search
;
search
=
search
.
parentNode
)
{
if
(
search
.
nodeType
=
=
9
|
|
(
search
.
nodeType
=
=
11
&
&
(
search
as
any
)
.
host
)
)
{
if
(
!
(
search
as
any
)
.
getSelection
)
Object
.
getPrototypeOf
(
search
)
.
getSelection
=
(
)
=
>
(
search
as
DOMNode
)
.
ownerDocument
!
.
getSelection
(
)
return
this
.
_root
=
search
as
Document
|
ShadowRoot
}
}
return
cached
|
|
document
}
updateRoot
(
)
{
this
.
_root
=
null
}
posAtCoords
(
coords
:
{
left
:
number
top
:
number
}
)
:
{
pos
:
number
inside
:
number
}
|
null
{
return
posAtCoords
(
this
coords
)
}
coordsAtPos
(
pos
:
number
side
=
1
)
:
{
left
:
number
right
:
number
top
:
number
bottom
:
number
}
{
return
coordsAtPos
(
this
pos
side
)
}
domAtPos
(
pos
:
number
side
=
0
)
:
{
node
:
DOMNode
offset
:
number
}
{
return
this
.
docView
.
domFromPos
(
pos
side
)
}
nodeDOM
(
pos
:
number
)
:
DOMNode
|
null
{
let
desc
=
this
.
docView
.
descAt
(
pos
)
return
desc
?
(
desc
as
NodeViewDesc
)
.
nodeDOM
:
null
}
posAtDOM
(
node
:
DOMNode
offset
:
number
bias
=
-
1
)
:
number
{
let
pos
=
this
.
docView
.
posFromDOM
(
node
offset
bias
)
if
(
pos
=
=
null
)
throw
new
RangeError
(
"
DOM
position
not
inside
the
editor
"
)
return
pos
}
endOfTextblock
(
dir
:
"
up
"
|
"
down
"
|
"
left
"
|
"
right
"
|
"
forward
"
|
"
backward
"
state
?
:
EditorState
)
:
boolean
{
return
endOfTextblock
(
this
state
|
|
this
.
state
dir
)
}
pasteHTML
(
html
:
string
event
?
:
ClipboardEvent
)
{
return
doPaste
(
this
"
"
html
false
event
|
|
new
ClipboardEvent
(
"
paste
"
)
)
}
pasteText
(
text
:
string
event
?
:
ClipboardEvent
)
{
return
doPaste
(
this
text
null
true
event
|
|
new
ClipboardEvent
(
"
paste
"
)
)
}
serializeForClipboard
(
slice
:
Slice
)
:
{
dom
:
HTMLElement
text
:
string
slice
:
Slice
}
{
return
serializeForClipboard
(
this
slice
)
}
destroy
(
)
{
if
(
!
this
.
docView
)
return
destroyInput
(
this
)
this
.
destroyPluginViews
(
)
if
(
this
.
mounted
)
{
this
.
docView
.
update
(
this
.
state
.
doc
[
]
viewDecorations
(
this
)
this
)
this
.
dom
.
textContent
=
"
"
}
else
if
(
this
.
dom
.
parentNode
)
{
this
.
dom
.
parentNode
.
removeChild
(
this
.
dom
)
}
this
.
docView
.
destroy
(
)
;
(
this
as
any
)
.
docView
=
null
clearReusedRange
(
)
}
get
isDestroyed
(
)
{
return
this
.
docView
=
=
null
}
dispatchEvent
(
event
:
Event
)
{
return
dispatchEvent
(
this
event
)
}
declare
dispatch
:
(
tr
:
Transaction
)
=
>
void
domSelectionRange
(
)
:
DOMSelectionRange
{
let
sel
=
this
.
domSelection
(
)
if
(
!
sel
)
return
{
focusNode
:
null
focusOffset
:
0
anchorNode
:
null
anchorOffset
:
0
}
return
browser
.
safari
&
&
this
.
root
.
nodeType
=
=
=
11
&
&
deepActiveElement
(
this
.
dom
.
ownerDocument
)
=
=
this
.
dom
&
&
safariShadowSelectionRange
(
this
sel
)
|
|
sel
}
domSelection
(
)
:
DOMSelection
|
null
{
return
(
this
.
root
as
Document
)
.
getSelection
(
)
}
}
EditorView
.
prototype
.
dispatch
=
function
(
tr
:
Transaction
)
{
let
dispatchTransaction
=
this
.
_props
.
dispatchTransaction
if
(
dispatchTransaction
)
dispatchTransaction
.
call
(
this
tr
)
else
this
.
updateState
(
this
.
state
.
apply
(
tr
)
)
}
function
computeDocDeco
(
view
:
EditorView
)
{
let
attrs
=
Object
.
create
(
null
)
attrs
.
class
=
"
ProseMirror
"
attrs
.
contenteditable
=
String
(
view
.
editable
)
view
.
someProp
(
"
attributes
"
value
=
>
{
if
(
typeof
value
=
=
"
function
"
)
value
=
value
(
view
.
state
)
if
(
value
)
for
(
let
attr
in
value
)
{
if
(
attr
=
=
"
class
"
)
attrs
.
class
+
=
"
"
+
value
[
attr
]
else
if
(
attr
=
=
"
style
"
)
attrs
.
style
=
(
attrs
.
style
?
attrs
.
style
+
"
;
"
:
"
"
)
+
value
[
attr
]
else
if
(
!
attrs
[
attr
]
&
&
attr
!
=
"
contenteditable
"
&
&
attr
!
=
"
nodeName
"
)
attrs
[
attr
]
=
String
(
value
[
attr
]
)
}
}
)
if
(
!
attrs
.
translate
)
attrs
.
translate
=
"
no
"
return
[
Decoration
.
node
(
0
view
.
state
.
doc
.
content
.
size
attrs
)
]
}
function
updateCursorWrapper
(
view
:
EditorView
)
{
if
(
view
.
markCursor
)
{
let
dom
=
document
.
createElement
(
"
img
"
)
dom
.
className
=
"
ProseMirror
-
separator
"
dom
.
setAttribute
(
"
mark
-
placeholder
"
"
true
"
)
dom
.
setAttribute
(
"
alt
"
"
"
)
view
.
cursorWrapper
=
{
dom
deco
:
Decoration
.
widget
(
view
.
state
.
selection
.
from
dom
{
raw
:
true
marks
:
view
.
markCursor
}
as
any
)
}
}
else
{
view
.
cursorWrapper
=
null
}
}
function
getEditable
(
view
:
EditorView
)
{
return
!
view
.
someProp
(
"
editable
"
value
=
>
value
(
view
.
state
)
=
=
=
false
)
}
function
selectionContextChanged
(
sel1
:
Selection
sel2
:
Selection
)
{
let
depth
=
Math
.
min
(
sel1
.
anchor
.
sharedDepth
(
sel1
.
head
)
sel2
.
anchor
.
sharedDepth
(
sel2
.
head
)
)
return
sel1
.
anchor
.
start
(
depth
)
!
=
sel2
.
anchor
.
start
(
depth
)
}
function
buildNodeViews
(
view
:
EditorView
)
{
let
result
:
NodeViewSet
=
Object
.
create
(
null
)
function
add
(
obj
:
NodeViewSet
)
{
for
(
let
prop
in
obj
)
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
result
prop
)
)
result
[
prop
]
=
obj
[
prop
]
}
view
.
someProp
(
"
nodeViews
"
add
)
view
.
someProp
(
"
markViews
"
add
)
return
result
}
function
changedNodeViews
(
a
:
NodeViewSet
b
:
NodeViewSet
)
{
let
nA
=
0
nB
=
0
for
(
let
prop
in
a
)
{
if
(
a
[
prop
]
!
=
b
[
prop
]
)
return
true
nA
+
+
}
for
(
let
_
in
b
)
nB
+
+
return
nA
!
=
nB
}
function
checkStateComponent
(
plugin
:
Plugin
)
{
if
(
plugin
.
spec
.
state
|
|
plugin
.
spec
.
filterTransaction
|
|
plugin
.
spec
.
appendTransaction
)
throw
new
RangeError
(
"
Plugins
passed
directly
to
the
view
must
not
have
a
state
component
"
)
}
export
type
NodeViewConstructor
=
(
node
:
Node
view
:
EditorView
getPos
:
(
)
=
>
number
|
undefined
decorations
:
readonly
Decoration
[
]
innerDecorations
:
DecorationSource
)
=
>
NodeView
export
type
MarkViewConstructor
=
(
mark
:
Mark
view
:
EditorView
inline
:
boolean
)
=
>
MarkView
type
NodeViewSet
=
{
[
name
:
string
]
:
NodeViewConstructor
|
MarkViewConstructor
}
export
interface
DOMEventMap
extends
HTMLElementEventMap
{
[
event
:
string
]
:
any
}
export
interface
EditorProps
<
P
=
any
>
{
handleDOMEvents
?
:
{
[
event
in
keyof
DOMEventMap
]
?
:
(
this
:
P
view
:
EditorView
event
:
DOMEventMap
[
event
]
)
=
>
boolean
|
void
}
handleKeyDown
?
:
(
this
:
P
view
:
EditorView
event
:
KeyboardEvent
)
=
>
boolean
|
void
handleKeyPress
?
:
(
this
:
P
view
:
EditorView
event
:
KeyboardEvent
)
=
>
boolean
|
void
handleTextInput
?
:
(
this
:
P
view
:
EditorView
from
:
number
to
:
number
text
:
string
deflt
:
(
)
=
>
Transaction
)
=
>
boolean
|
void
handleClickOn
?
:
(
this
:
P
view
:
EditorView
pos
:
number
node
:
Node
nodePos
:
number
event
:
MouseEvent
direct
:
boolean
)
=
>
boolean
|
void
handleClick
?
:
(
this
:
P
view
:
EditorView
pos
:
number
event
:
MouseEvent
)
=
>
boolean
|
void
handleDoubleClickOn
?
:
(
this
:
P
view
:
EditorView
pos
:
number
node
:
Node
nodePos
:
number
event
:
MouseEvent
direct
:
boolean
)
=
>
boolean
|
void
handleDoubleClick
?
:
(
this
:
P
view
:
EditorView
pos
:
number
event
:
MouseEvent
)
=
>
boolean
|
void
handleTripleClickOn
?
:
(
this
:
P
view
:
EditorView
pos
:
number
node
:
Node
nodePos
:
number
event
:
MouseEvent
direct
:
boolean
)
=
>
boolean
|
void
handleTripleClick
?
:
(
this
:
P
view
:
EditorView
pos
:
number
event
:
MouseEvent
)
=
>
boolean
|
void
handlePaste
?
:
(
this
:
P
view
:
EditorView
event
:
ClipboardEvent
slice
:
Slice
)
=
>
boolean
|
void
handleDrop
?
:
(
this
:
P
view
:
EditorView
event
:
DragEvent
slice
:
Slice
moved
:
boolean
)
=
>
boolean
|
void
handleScrollToSelection
?
:
(
this
:
P
view
:
EditorView
)
=
>
boolean
dragCopies
?
:
(
event
:
DragEvent
)
=
>
boolean
createSelectionBetween
?
:
(
this
:
P
view
:
EditorView
anchor
:
ResolvedPos
head
:
ResolvedPos
)
=
>
Selection
|
null
domParser
?
:
DOMParser
transformPastedHTML
?
:
(
this
:
P
html
:
string
view
:
EditorView
)
=
>
string
clipboardParser
?
:
DOMParser
transformPastedText
?
:
(
this
:
P
text
:
string
plain
:
boolean
view
:
EditorView
)
=
>
string
clipboardTextParser
?
:
(
this
:
P
text
:
string
context
:
ResolvedPos
plain
:
boolean
view
:
EditorView
)
=
>
Slice
transformPasted
?
:
(
this
:
P
slice
:
Slice
view
:
EditorView
plain
:
boolean
)
=
>
Slice
transformCopied
?
:
(
this
:
P
slice
:
Slice
view
:
EditorView
)
=
>
Slice
nodeViews
?
:
{
[
node
:
string
]
:
NodeViewConstructor
}
markViews
?
:
{
[
mark
:
string
]
:
MarkViewConstructor
}
clipboardSerializer
?
:
DOMSerializer
clipboardTextSerializer
?
:
(
this
:
P
content
:
Slice
view
:
EditorView
)
=
>
string
decorations
?
:
(
this
:
P
state
:
EditorState
)
=
>
DecorationSource
|
null
|
undefined
editable
?
:
(
this
:
P
state
:
EditorState
)
=
>
boolean
attributes
?
:
{
[
name
:
string
]
:
string
}
|
(
(
state
:
EditorState
)
=
>
{
[
name
:
string
]
:
string
}
)
scrollThreshold
?
:
number
|
{
top
:
number
right
:
number
bottom
:
number
left
:
number
}
scrollMargin
?
:
number
|
{
top
:
number
right
:
number
bottom
:
number
left
:
number
}
}
export
interface
DirectEditorProps
extends
EditorProps
{
state
:
EditorState
plugins
?
:
readonly
Plugin
[
]
dispatchTransaction
?
:
(
tr
:
Transaction
)
=
>
void
}
