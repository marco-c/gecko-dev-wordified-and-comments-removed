import
{
Fragment
Slice
Node
Mark
Schema
}
from
"
prosemirror
-
model
"
import
{
Step
StepResult
}
from
"
.
/
step
"
import
{
Mappable
}
from
"
.
/
map
"
function
mapFragment
(
fragment
:
Fragment
f
:
(
child
:
Node
parent
:
Node
i
:
number
)
=
>
Node
parent
:
Node
)
:
Fragment
{
let
mapped
=
[
]
for
(
let
i
=
0
;
i
<
fragment
.
childCount
;
i
+
+
)
{
let
child
=
fragment
.
child
(
i
)
if
(
child
.
content
.
size
)
child
=
child
.
copy
(
mapFragment
(
child
.
content
f
child
)
)
if
(
child
.
isInline
)
child
=
f
(
child
parent
i
)
mapped
.
push
(
child
)
}
return
Fragment
.
fromArray
(
mapped
)
}
export
class
AddMarkStep
extends
Step
{
constructor
(
readonly
from
:
number
readonly
to
:
number
readonly
mark
:
Mark
)
{
super
(
)
}
apply
(
doc
:
Node
)
{
let
oldSlice
=
doc
.
slice
(
this
.
from
this
.
to
)
from
=
doc
.
resolve
(
this
.
from
)
let
parent
=
from
.
node
(
from
.
sharedDepth
(
this
.
to
)
)
let
slice
=
new
Slice
(
mapFragment
(
oldSlice
.
content
(
node
parent
)
=
>
{
if
(
!
node
.
isAtom
|
|
!
parent
.
type
.
allowsMarkType
(
this
.
mark
.
type
)
)
return
node
return
node
.
mark
(
this
.
mark
.
addToSet
(
node
.
marks
)
)
}
parent
)
oldSlice
.
openStart
oldSlice
.
openEnd
)
return
StepResult
.
fromReplace
(
doc
this
.
from
this
.
to
slice
)
}
invert
(
)
:
Step
{
return
new
RemoveMarkStep
(
this
.
from
this
.
to
this
.
mark
)
}
map
(
mapping
:
Mappable
)
:
Step
|
null
{
let
from
=
mapping
.
mapResult
(
this
.
from
1
)
to
=
mapping
.
mapResult
(
this
.
to
-
1
)
if
(
from
.
deleted
&
&
to
.
deleted
|
|
from
.
pos
>
=
to
.
pos
)
return
null
return
new
AddMarkStep
(
from
.
pos
to
.
pos
this
.
mark
)
}
merge
(
other
:
Step
)
:
Step
|
null
{
if
(
other
instanceof
AddMarkStep
&
&
other
.
mark
.
eq
(
this
.
mark
)
&
&
this
.
from
<
=
other
.
to
&
&
this
.
to
>
=
other
.
from
)
return
new
AddMarkStep
(
Math
.
min
(
this
.
from
other
.
from
)
Math
.
max
(
this
.
to
other
.
to
)
this
.
mark
)
return
null
}
toJSON
(
)
:
any
{
return
{
stepType
:
"
addMark
"
mark
:
this
.
mark
.
toJSON
(
)
from
:
this
.
from
to
:
this
.
to
}
}
static
fromJSON
(
schema
:
Schema
json
:
any
)
{
if
(
typeof
json
.
from
!
=
"
number
"
|
|
typeof
json
.
to
!
=
"
number
"
)
throw
new
RangeError
(
"
Invalid
input
for
AddMarkStep
.
fromJSON
"
)
return
new
AddMarkStep
(
json
.
from
json
.
to
schema
.
markFromJSON
(
json
.
mark
)
)
}
}
Step
.
jsonID
(
"
addMark
"
AddMarkStep
)
export
class
RemoveMarkStep
extends
Step
{
constructor
(
readonly
from
:
number
readonly
to
:
number
readonly
mark
:
Mark
)
{
super
(
)
}
apply
(
doc
:
Node
)
{
let
oldSlice
=
doc
.
slice
(
this
.
from
this
.
to
)
let
slice
=
new
Slice
(
mapFragment
(
oldSlice
.
content
node
=
>
{
return
node
.
mark
(
this
.
mark
.
removeFromSet
(
node
.
marks
)
)
}
doc
)
oldSlice
.
openStart
oldSlice
.
openEnd
)
return
StepResult
.
fromReplace
(
doc
this
.
from
this
.
to
slice
)
}
invert
(
)
:
Step
{
return
new
AddMarkStep
(
this
.
from
this
.
to
this
.
mark
)
}
map
(
mapping
:
Mappable
)
:
Step
|
null
{
let
from
=
mapping
.
mapResult
(
this
.
from
1
)
to
=
mapping
.
mapResult
(
this
.
to
-
1
)
if
(
from
.
deleted
&
&
to
.
deleted
|
|
from
.
pos
>
=
to
.
pos
)
return
null
return
new
RemoveMarkStep
(
from
.
pos
to
.
pos
this
.
mark
)
}
merge
(
other
:
Step
)
:
Step
|
null
{
if
(
other
instanceof
RemoveMarkStep
&
&
other
.
mark
.
eq
(
this
.
mark
)
&
&
this
.
from
<
=
other
.
to
&
&
this
.
to
>
=
other
.
from
)
return
new
RemoveMarkStep
(
Math
.
min
(
this
.
from
other
.
from
)
Math
.
max
(
this
.
to
other
.
to
)
this
.
mark
)
return
null
}
toJSON
(
)
:
any
{
return
{
stepType
:
"
removeMark
"
mark
:
this
.
mark
.
toJSON
(
)
from
:
this
.
from
to
:
this
.
to
}
}
static
fromJSON
(
schema
:
Schema
json
:
any
)
{
if
(
typeof
json
.
from
!
=
"
number
"
|
|
typeof
json
.
to
!
=
"
number
"
)
throw
new
RangeError
(
"
Invalid
input
for
RemoveMarkStep
.
fromJSON
"
)
return
new
RemoveMarkStep
(
json
.
from
json
.
to
schema
.
markFromJSON
(
json
.
mark
)
)
}
}
Step
.
jsonID
(
"
removeMark
"
RemoveMarkStep
)
export
class
AddNodeMarkStep
extends
Step
{
constructor
(
readonly
pos
:
number
readonly
mark
:
Mark
)
{
super
(
)
}
apply
(
doc
:
Node
)
{
let
node
=
doc
.
nodeAt
(
this
.
pos
)
if
(
!
node
)
return
StepResult
.
fail
(
"
No
node
at
mark
step
'
s
position
"
)
let
updated
=
node
.
type
.
create
(
node
.
attrs
null
this
.
mark
.
addToSet
(
node
.
marks
)
)
return
StepResult
.
fromReplace
(
doc
this
.
pos
this
.
pos
+
1
new
Slice
(
Fragment
.
from
(
updated
)
0
node
.
isLeaf
?
0
:
1
)
)
}
invert
(
doc
:
Node
)
:
Step
{
let
node
=
doc
.
nodeAt
(
this
.
pos
)
if
(
node
)
{
let
newSet
=
this
.
mark
.
addToSet
(
node
.
marks
)
if
(
newSet
.
length
=
=
node
.
marks
.
length
)
{
for
(
let
i
=
0
;
i
<
node
.
marks
.
length
;
i
+
+
)
if
(
!
node
.
marks
[
i
]
.
isInSet
(
newSet
)
)
return
new
AddNodeMarkStep
(
this
.
pos
node
.
marks
[
i
]
)
return
new
AddNodeMarkStep
(
this
.
pos
this
.
mark
)
}
}
return
new
RemoveNodeMarkStep
(
this
.
pos
this
.
mark
)
}
map
(
mapping
:
Mappable
)
:
Step
|
null
{
let
pos
=
mapping
.
mapResult
(
this
.
pos
1
)
return
pos
.
deletedAfter
?
null
:
new
AddNodeMarkStep
(
pos
.
pos
this
.
mark
)
}
toJSON
(
)
:
any
{
return
{
stepType
:
"
addNodeMark
"
pos
:
this
.
pos
mark
:
this
.
mark
.
toJSON
(
)
}
}
static
fromJSON
(
schema
:
Schema
json
:
any
)
{
if
(
typeof
json
.
pos
!
=
"
number
"
)
throw
new
RangeError
(
"
Invalid
input
for
AddNodeMarkStep
.
fromJSON
"
)
return
new
AddNodeMarkStep
(
json
.
pos
schema
.
markFromJSON
(
json
.
mark
)
)
}
}
Step
.
jsonID
(
"
addNodeMark
"
AddNodeMarkStep
)
export
class
RemoveNodeMarkStep
extends
Step
{
constructor
(
readonly
pos
:
number
readonly
mark
:
Mark
)
{
super
(
)
}
apply
(
doc
:
Node
)
{
let
node
=
doc
.
nodeAt
(
this
.
pos
)
if
(
!
node
)
return
StepResult
.
fail
(
"
No
node
at
mark
step
'
s
position
"
)
let
updated
=
node
.
type
.
create
(
node
.
attrs
null
this
.
mark
.
removeFromSet
(
node
.
marks
)
)
return
StepResult
.
fromReplace
(
doc
this
.
pos
this
.
pos
+
1
new
Slice
(
Fragment
.
from
(
updated
)
0
node
.
isLeaf
?
0
:
1
)
)
}
invert
(
doc
:
Node
)
:
Step
{
let
node
=
doc
.
nodeAt
(
this
.
pos
)
if
(
!
node
|
|
!
this
.
mark
.
isInSet
(
node
.
marks
)
)
return
this
return
new
AddNodeMarkStep
(
this
.
pos
this
.
mark
)
}
map
(
mapping
:
Mappable
)
:
Step
|
null
{
let
pos
=
mapping
.
mapResult
(
this
.
pos
1
)
return
pos
.
deletedAfter
?
null
:
new
RemoveNodeMarkStep
(
pos
.
pos
this
.
mark
)
}
toJSON
(
)
:
any
{
return
{
stepType
:
"
removeNodeMark
"
pos
:
this
.
pos
mark
:
this
.
mark
.
toJSON
(
)
}
}
static
fromJSON
(
schema
:
Schema
json
:
any
)
{
if
(
typeof
json
.
pos
!
=
"
number
"
)
throw
new
RangeError
(
"
Invalid
input
for
RemoveNodeMarkStep
.
fromJSON
"
)
return
new
RemoveNodeMarkStep
(
json
.
pos
schema
.
markFromJSON
(
json
.
mark
)
)
}
}
Step
.
jsonID
(
"
removeNodeMark
"
RemoveNodeMarkStep
)
