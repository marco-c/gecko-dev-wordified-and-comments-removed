import
{
Node
NodeType
Mark
MarkType
ContentMatch
Slice
Fragment
NodeRange
Attrs
}
from
"
prosemirror
-
model
"
import
{
Mapping
}
from
"
.
/
map
"
import
{
Step
}
from
"
.
/
step
"
import
{
addMark
removeMark
clearIncompatible
}
from
"
.
/
mark
"
import
{
replaceStep
replaceRange
replaceRangeWith
deleteRange
}
from
"
.
/
replace
"
import
{
lift
wrap
setBlockType
setNodeMarkup
split
join
}
from
"
.
/
structure
"
import
{
AttrStep
DocAttrStep
}
from
"
.
/
attr_step
"
import
{
AddNodeMarkStep
RemoveNodeMarkStep
}
from
"
.
/
mark_step
"
export
let
TransformError
=
class
extends
Error
{
}
TransformError
=
function
TransformError
(
this
:
any
message
:
string
)
{
let
err
=
Error
.
call
(
this
message
)
;
(
err
as
any
)
.
__proto__
=
TransformError
.
prototype
return
err
}
as
any
TransformError
.
prototype
=
Object
.
create
(
Error
.
prototype
)
TransformError
.
prototype
.
constructor
=
TransformError
TransformError
.
prototype
.
name
=
"
TransformError
"
export
class
Transform
{
readonly
steps
:
Step
[
]
=
[
]
readonly
docs
:
Node
[
]
=
[
]
readonly
mapping
:
Mapping
=
new
Mapping
constructor
(
public
doc
:
Node
)
{
}
get
before
(
)
{
return
this
.
docs
.
length
?
this
.
docs
[
0
]
:
this
.
doc
}
step
(
step
:
Step
)
{
let
result
=
this
.
maybeStep
(
step
)
if
(
result
.
failed
)
throw
new
TransformError
(
result
.
failed
)
return
this
}
maybeStep
(
step
:
Step
)
{
let
result
=
step
.
apply
(
this
.
doc
)
if
(
!
result
.
failed
)
this
.
addStep
(
step
result
.
doc
!
)
return
result
}
get
docChanged
(
)
{
return
this
.
steps
.
length
>
0
}
addStep
(
step
:
Step
doc
:
Node
)
{
this
.
docs
.
push
(
this
.
doc
)
this
.
steps
.
push
(
step
)
this
.
mapping
.
appendMap
(
step
.
getMap
(
)
)
this
.
doc
=
doc
}
replace
(
from
:
number
to
=
from
slice
=
Slice
.
empty
)
:
this
{
let
step
=
replaceStep
(
this
.
doc
from
to
slice
)
if
(
step
)
this
.
step
(
step
)
return
this
}
replaceWith
(
from
:
number
to
:
number
content
:
Fragment
|
Node
|
readonly
Node
[
]
)
:
this
{
return
this
.
replace
(
from
to
new
Slice
(
Fragment
.
from
(
content
)
0
0
)
)
}
delete
(
from
:
number
to
:
number
)
:
this
{
return
this
.
replace
(
from
to
Slice
.
empty
)
}
insert
(
pos
:
number
content
:
Fragment
|
Node
|
readonly
Node
[
]
)
:
this
{
return
this
.
replaceWith
(
pos
pos
content
)
}
replaceRange
(
from
:
number
to
:
number
slice
:
Slice
)
:
this
{
replaceRange
(
this
from
to
slice
)
return
this
}
replaceRangeWith
(
from
:
number
to
:
number
node
:
Node
)
:
this
{
replaceRangeWith
(
this
from
to
node
)
return
this
}
deleteRange
(
from
:
number
to
:
number
)
:
this
{
deleteRange
(
this
from
to
)
return
this
}
lift
(
range
:
NodeRange
target
:
number
)
:
this
{
lift
(
this
range
target
)
return
this
}
join
(
pos
:
number
depth
:
number
=
1
)
:
this
{
join
(
this
pos
depth
)
return
this
}
wrap
(
range
:
NodeRange
wrappers
:
readonly
{
type
:
NodeType
attrs
?
:
Attrs
|
null
}
[
]
)
:
this
{
wrap
(
this
range
wrappers
)
return
this
}
setBlockType
(
from
:
number
to
=
from
type
:
NodeType
attrs
:
Attrs
|
null
|
(
(
oldNode
:
Node
)
=
>
Attrs
)
=
null
)
:
this
{
setBlockType
(
this
from
to
type
attrs
)
return
this
}
setNodeMarkup
(
pos
:
number
type
?
:
NodeType
|
null
attrs
:
Attrs
|
null
=
null
marks
?
:
readonly
Mark
[
]
)
:
this
{
setNodeMarkup
(
this
pos
type
attrs
marks
)
return
this
}
setNodeAttribute
(
pos
:
number
attr
:
string
value
:
any
)
:
this
{
this
.
step
(
new
AttrStep
(
pos
attr
value
)
)
return
this
}
setDocAttribute
(
attr
:
string
value
:
any
)
:
this
{
this
.
step
(
new
DocAttrStep
(
attr
value
)
)
return
this
}
addNodeMark
(
pos
:
number
mark
:
Mark
)
:
this
{
this
.
step
(
new
AddNodeMarkStep
(
pos
mark
)
)
return
this
}
removeNodeMark
(
pos
:
number
mark
:
Mark
|
MarkType
)
:
this
{
let
node
=
this
.
doc
.
nodeAt
(
pos
)
if
(
!
node
)
throw
new
RangeError
(
"
No
node
at
position
"
+
pos
)
if
(
mark
instanceof
Mark
)
{
if
(
mark
.
isInSet
(
node
.
marks
)
)
this
.
step
(
new
RemoveNodeMarkStep
(
pos
mark
)
)
}
else
{
let
set
=
node
.
marks
found
steps
:
Step
[
]
=
[
]
while
(
found
=
mark
.
isInSet
(
set
)
)
{
steps
.
push
(
new
RemoveNodeMarkStep
(
pos
found
)
)
set
=
found
.
removeFromSet
(
set
)
}
for
(
let
i
=
steps
.
length
-
1
;
i
>
=
0
;
i
-
-
)
this
.
step
(
steps
[
i
]
)
}
return
this
}
split
(
pos
:
number
depth
=
1
typesAfter
?
:
(
null
|
{
type
:
NodeType
attrs
?
:
Attrs
|
null
}
)
[
]
)
{
split
(
this
pos
depth
typesAfter
)
return
this
}
addMark
(
from
:
number
to
:
number
mark
:
Mark
)
:
this
{
addMark
(
this
from
to
mark
)
return
this
}
removeMark
(
from
:
number
to
:
number
mark
?
:
Mark
|
MarkType
|
null
)
{
removeMark
(
this
from
to
mark
)
return
this
}
clearIncompatible
(
pos
:
number
parentType
:
NodeType
match
?
:
ContentMatch
)
{
clearIncompatible
(
this
pos
parentType
match
)
return
this
}
}
