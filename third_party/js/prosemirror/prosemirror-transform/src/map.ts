export
interface
Mappable
{
map
:
(
pos
:
number
assoc
?
:
number
)
=
>
number
mapResult
:
(
pos
:
number
assoc
?
:
number
)
=
>
MapResult
}
const
lower16
=
0xffff
const
factor16
=
Math
.
pow
(
2
16
)
function
makeRecover
(
index
:
number
offset
:
number
)
{
return
index
+
offset
*
factor16
}
function
recoverIndex
(
value
:
number
)
{
return
value
&
lower16
}
function
recoverOffset
(
value
:
number
)
{
return
(
value
-
(
value
&
lower16
)
)
/
factor16
}
const
DEL_BEFORE
=
1
DEL_AFTER
=
2
DEL_ACROSS
=
4
DEL_SIDE
=
8
export
class
MapResult
{
constructor
(
readonly
pos
:
number
readonly
delInfo
:
number
readonly
recover
:
number
|
null
)
{
}
get
deleted
(
)
{
return
(
this
.
delInfo
&
DEL_SIDE
)
>
0
}
get
deletedBefore
(
)
{
return
(
this
.
delInfo
&
(
DEL_BEFORE
|
DEL_ACROSS
)
)
>
0
}
get
deletedAfter
(
)
{
return
(
this
.
delInfo
&
(
DEL_AFTER
|
DEL_ACROSS
)
)
>
0
}
get
deletedAcross
(
)
{
return
(
this
.
delInfo
&
DEL_ACROSS
)
>
0
}
}
export
class
StepMap
implements
Mappable
{
constructor
(
readonly
ranges
:
readonly
number
[
]
readonly
inverted
=
false
)
{
if
(
!
ranges
.
length
&
&
StepMap
.
empty
)
return
StepMap
.
empty
}
recover
(
value
:
number
)
{
let
diff
=
0
index
=
recoverIndex
(
value
)
if
(
!
this
.
inverted
)
for
(
let
i
=
0
;
i
<
index
;
i
+
+
)
diff
+
=
this
.
ranges
[
i
*
3
+
2
]
-
this
.
ranges
[
i
*
3
+
1
]
return
this
.
ranges
[
index
*
3
]
+
diff
+
recoverOffset
(
value
)
}
mapResult
(
pos
:
number
assoc
=
1
)
:
MapResult
{
return
this
.
_map
(
pos
assoc
false
)
as
MapResult
}
map
(
pos
:
number
assoc
=
1
)
:
number
{
return
this
.
_map
(
pos
assoc
true
)
as
number
}
_map
(
pos
:
number
assoc
:
number
simple
:
boolean
)
{
let
diff
=
0
oldIndex
=
this
.
inverted
?
2
:
1
newIndex
=
this
.
inverted
?
1
:
2
for
(
let
i
=
0
;
i
<
this
.
ranges
.
length
;
i
+
=
3
)
{
let
start
=
this
.
ranges
[
i
]
-
(
this
.
inverted
?
diff
:
0
)
if
(
start
>
pos
)
break
let
oldSize
=
this
.
ranges
[
i
+
oldIndex
]
newSize
=
this
.
ranges
[
i
+
newIndex
]
end
=
start
+
oldSize
if
(
pos
<
=
end
)
{
let
side
=
!
oldSize
?
assoc
:
pos
=
=
start
?
-
1
:
pos
=
=
end
?
1
:
assoc
let
result
=
start
+
diff
+
(
side
<
0
?
0
:
newSize
)
if
(
simple
)
return
result
let
recover
=
pos
=
=
(
assoc
<
0
?
start
:
end
)
?
null
:
makeRecover
(
i
/
3
pos
-
start
)
let
del
=
pos
=
=
start
?
DEL_AFTER
:
pos
=
=
end
?
DEL_BEFORE
:
DEL_ACROSS
if
(
assoc
<
0
?
pos
!
=
start
:
pos
!
=
end
)
del
|
=
DEL_SIDE
return
new
MapResult
(
result
del
recover
)
}
diff
+
=
newSize
-
oldSize
}
return
simple
?
pos
+
diff
:
new
MapResult
(
pos
+
diff
0
null
)
}
touches
(
pos
:
number
recover
:
number
)
{
let
diff
=
0
index
=
recoverIndex
(
recover
)
let
oldIndex
=
this
.
inverted
?
2
:
1
newIndex
=
this
.
inverted
?
1
:
2
for
(
let
i
=
0
;
i
<
this
.
ranges
.
length
;
i
+
=
3
)
{
let
start
=
this
.
ranges
[
i
]
-
(
this
.
inverted
?
diff
:
0
)
if
(
start
>
pos
)
break
let
oldSize
=
this
.
ranges
[
i
+
oldIndex
]
end
=
start
+
oldSize
if
(
pos
<
=
end
&
&
i
=
=
index
*
3
)
return
true
diff
+
=
this
.
ranges
[
i
+
newIndex
]
-
oldSize
}
return
false
}
forEach
(
f
:
(
oldStart
:
number
oldEnd
:
number
newStart
:
number
newEnd
:
number
)
=
>
void
)
{
let
oldIndex
=
this
.
inverted
?
2
:
1
newIndex
=
this
.
inverted
?
1
:
2
for
(
let
i
=
0
diff
=
0
;
i
<
this
.
ranges
.
length
;
i
+
=
3
)
{
let
start
=
this
.
ranges
[
i
]
oldStart
=
start
-
(
this
.
inverted
?
diff
:
0
)
newStart
=
start
+
(
this
.
inverted
?
0
:
diff
)
let
oldSize
=
this
.
ranges
[
i
+
oldIndex
]
newSize
=
this
.
ranges
[
i
+
newIndex
]
f
(
oldStart
oldStart
+
oldSize
newStart
newStart
+
newSize
)
diff
+
=
newSize
-
oldSize
}
}
invert
(
)
{
return
new
StepMap
(
this
.
ranges
!
this
.
inverted
)
}
toString
(
)
{
return
(
this
.
inverted
?
"
-
"
:
"
"
)
+
JSON
.
stringify
(
this
.
ranges
)
}
static
offset
(
n
:
number
)
{
return
n
=
=
0
?
StepMap
.
empty
:
new
StepMap
(
n
<
0
?
[
0
-
n
0
]
:
[
0
0
n
]
)
}
static
empty
=
new
StepMap
(
[
]
)
}
export
class
Mapping
implements
Mappable
{
constructor
(
maps
?
:
readonly
StepMap
[
]
public
mirror
?
:
number
[
]
public
from
=
0
public
to
=
maps
?
maps
.
length
:
0
)
{
this
.
_maps
=
(
maps
as
StepMap
[
]
)
|
|
[
]
this
.
ownData
=
!
(
maps
|
|
mirror
)
}
get
maps
(
)
:
readonly
StepMap
[
]
{
return
this
.
_maps
}
private
_maps
:
StepMap
[
]
private
ownData
:
boolean
slice
(
from
=
0
to
=
this
.
maps
.
length
)
{
return
new
Mapping
(
this
.
_maps
this
.
mirror
from
to
)
}
appendMap
(
map
:
StepMap
mirrors
?
:
number
)
{
if
(
!
this
.
ownData
)
{
this
.
_maps
=
this
.
_maps
.
slice
(
)
this
.
mirror
=
this
.
mirror
&
&
this
.
mirror
.
slice
(
)
this
.
ownData
=
true
}
this
.
to
=
this
.
_maps
.
push
(
map
)
if
(
mirrors
!
=
null
)
this
.
setMirror
(
this
.
_maps
.
length
-
1
mirrors
)
}
appendMapping
(
mapping
:
Mapping
)
{
for
(
let
i
=
0
startSize
=
this
.
_maps
.
length
;
i
<
mapping
.
_maps
.
length
;
i
+
+
)
{
let
mirr
=
mapping
.
getMirror
(
i
)
this
.
appendMap
(
mapping
.
_maps
[
i
]
mirr
!
=
null
&
&
mirr
<
i
?
startSize
+
mirr
:
undefined
)
}
}
getMirror
(
n
:
number
)
:
number
|
undefined
{
if
(
this
.
mirror
)
for
(
let
i
=
0
;
i
<
this
.
mirror
.
length
;
i
+
+
)
if
(
this
.
mirror
[
i
]
=
=
n
)
return
this
.
mirror
[
i
+
(
i
%
2
?
-
1
:
1
)
]
}
setMirror
(
n
:
number
m
:
number
)
{
if
(
!
this
.
mirror
)
this
.
mirror
=
[
]
this
.
mirror
.
push
(
n
m
)
}
appendMappingInverted
(
mapping
:
Mapping
)
{
for
(
let
i
=
mapping
.
maps
.
length
-
1
totalSize
=
this
.
_maps
.
length
+
mapping
.
_maps
.
length
;
i
>
=
0
;
i
-
-
)
{
let
mirr
=
mapping
.
getMirror
(
i
)
this
.
appendMap
(
mapping
.
_maps
[
i
]
.
invert
(
)
mirr
!
=
null
&
&
mirr
>
i
?
totalSize
-
mirr
-
1
:
undefined
)
}
}
invert
(
)
{
let
inverse
=
new
Mapping
inverse
.
appendMappingInverted
(
this
)
return
inverse
}
map
(
pos
:
number
assoc
=
1
)
{
if
(
this
.
mirror
)
return
this
.
_map
(
pos
assoc
true
)
as
number
for
(
let
i
=
this
.
from
;
i
<
this
.
to
;
i
+
+
)
pos
=
this
.
_maps
[
i
]
.
map
(
pos
assoc
)
return
pos
}
mapResult
(
pos
:
number
assoc
=
1
)
{
return
this
.
_map
(
pos
assoc
false
)
as
MapResult
}
_map
(
pos
:
number
assoc
:
number
simple
:
boolean
)
{
let
delInfo
=
0
for
(
let
i
=
this
.
from
;
i
<
this
.
to
;
i
+
+
)
{
let
map
=
this
.
_maps
[
i
]
result
=
map
.
mapResult
(
pos
assoc
)
if
(
result
.
recover
!
=
null
)
{
let
corr
=
this
.
getMirror
(
i
)
if
(
corr
!
=
null
&
&
corr
>
i
&
&
corr
<
this
.
to
)
{
i
=
corr
pos
=
this
.
_maps
[
corr
]
.
recover
(
result
.
recover
)
continue
}
}
delInfo
|
=
result
.
delInfo
pos
=
result
.
pos
}
return
simple
?
pos
:
new
MapResult
(
pos
delInfo
null
)
}
}
