import
{
compareDeep
}
from
"
.
/
comparedeep
"
import
{
Attrs
MarkType
Schema
}
from
"
.
/
schema
"
export
class
Mark
{
constructor
(
readonly
type
:
MarkType
readonly
attrs
:
Attrs
)
{
}
addToSet
(
set
:
readonly
Mark
[
]
)
:
readonly
Mark
[
]
{
let
copy
placed
=
false
for
(
let
i
=
0
;
i
<
set
.
length
;
i
+
+
)
{
let
other
=
set
[
i
]
if
(
this
.
eq
(
other
)
)
return
set
if
(
this
.
type
.
excludes
(
other
.
type
)
)
{
if
(
!
copy
)
copy
=
set
.
slice
(
0
i
)
}
else
if
(
other
.
type
.
excludes
(
this
.
type
)
)
{
return
set
}
else
{
if
(
!
placed
&
&
other
.
type
.
rank
>
this
.
type
.
rank
)
{
if
(
!
copy
)
copy
=
set
.
slice
(
0
i
)
copy
.
push
(
this
)
placed
=
true
}
if
(
copy
)
copy
.
push
(
other
)
}
}
if
(
!
copy
)
copy
=
set
.
slice
(
)
if
(
!
placed
)
copy
.
push
(
this
)
return
copy
}
removeFromSet
(
set
:
readonly
Mark
[
]
)
:
readonly
Mark
[
]
{
for
(
let
i
=
0
;
i
<
set
.
length
;
i
+
+
)
if
(
this
.
eq
(
set
[
i
]
)
)
return
set
.
slice
(
0
i
)
.
concat
(
set
.
slice
(
i
+
1
)
)
return
set
}
isInSet
(
set
:
readonly
Mark
[
]
)
{
for
(
let
i
=
0
;
i
<
set
.
length
;
i
+
+
)
if
(
this
.
eq
(
set
[
i
]
)
)
return
true
return
false
}
eq
(
other
:
Mark
)
{
return
this
=
=
other
|
|
(
this
.
type
=
=
other
.
type
&
&
compareDeep
(
this
.
attrs
other
.
attrs
)
)
}
toJSON
(
)
:
any
{
let
obj
:
any
=
{
type
:
this
.
type
.
name
}
for
(
let
_
in
this
.
attrs
)
{
obj
.
attrs
=
this
.
attrs
break
}
return
obj
}
static
fromJSON
(
schema
:
Schema
json
:
any
)
{
if
(
!
json
)
throw
new
RangeError
(
"
Invalid
input
for
Mark
.
fromJSON
"
)
let
type
=
schema
.
marks
[
json
.
type
]
if
(
!
type
)
throw
new
RangeError
(
There
is
no
mark
type
{
json
.
type
}
in
this
schema
)
let
mark
=
type
.
create
(
json
.
attrs
)
type
.
checkAttrs
(
mark
.
attrs
)
return
mark
}
static
sameSet
(
a
:
readonly
Mark
[
]
b
:
readonly
Mark
[
]
)
{
if
(
a
=
=
b
)
return
true
if
(
a
.
length
!
=
b
.
length
)
return
false
for
(
let
i
=
0
;
i
<
a
.
length
;
i
+
+
)
if
(
!
a
[
i
]
.
eq
(
b
[
i
]
)
)
return
false
return
true
}
static
setFrom
(
marks
?
:
Mark
|
readonly
Mark
[
]
|
null
)
:
readonly
Mark
[
]
{
if
(
!
marks
|
|
Array
.
isArray
(
marks
)
&
&
marks
.
length
=
=
0
)
return
Mark
.
none
if
(
marks
instanceof
Mark
)
return
[
marks
]
let
copy
=
marks
.
slice
(
)
copy
.
sort
(
(
a
b
)
=
>
a
.
type
.
rank
-
b
.
type
.
rank
)
return
copy
}
static
none
:
readonly
Mark
[
]
=
[
]
}
