import
OrderedMap
from
"
orderedmap
"
import
{
Node
TextNode
}
from
"
.
/
node
"
import
{
Fragment
}
from
"
.
/
fragment
"
import
{
Mark
}
from
"
.
/
mark
"
import
{
ContentMatch
}
from
"
.
/
content
"
import
{
DOMOutputSpec
}
from
"
.
/
to_dom
"
import
{
ParseRule
TagParseRule
}
from
"
.
/
from_dom
"
export
type
Attrs
=
{
readonly
[
attr
:
string
]
:
any
}
function
defaultAttrs
(
attrs
:
{
[
name
:
string
]
:
Attribute
}
)
{
let
defaults
=
Object
.
create
(
null
)
for
(
let
attrName
in
attrs
)
{
let
attr
=
attrs
[
attrName
]
if
(
!
attr
.
hasDefault
)
return
null
defaults
[
attrName
]
=
attr
.
default
}
return
defaults
}
function
computeAttrs
(
attrs
:
{
[
name
:
string
]
:
Attribute
}
value
:
Attrs
|
null
)
{
let
built
=
Object
.
create
(
null
)
for
(
let
name
in
attrs
)
{
let
given
=
value
&
&
value
[
name
]
if
(
given
=
=
=
undefined
)
{
let
attr
=
attrs
[
name
]
if
(
attr
.
hasDefault
)
given
=
attr
.
default
else
throw
new
RangeError
(
"
No
value
supplied
for
attribute
"
+
name
)
}
built
[
name
]
=
given
}
return
built
}
export
function
checkAttrs
(
attrs
:
{
[
name
:
string
]
:
Attribute
}
values
:
Attrs
type
:
string
name
:
string
)
{
for
(
let
name
in
values
)
if
(
!
(
name
in
attrs
)
)
throw
new
RangeError
(
Unsupported
attribute
{
name
}
for
{
type
}
of
type
{
name
}
)
for
(
let
name
in
attrs
)
{
let
attr
=
attrs
[
name
]
if
(
attr
.
validate
)
attr
.
validate
(
values
[
name
]
)
}
}
function
initAttrs
(
typeName
:
string
attrs
?
:
{
[
name
:
string
]
:
AttributeSpec
}
)
{
let
result
:
{
[
name
:
string
]
:
Attribute
}
=
Object
.
create
(
null
)
if
(
attrs
)
for
(
let
name
in
attrs
)
result
[
name
]
=
new
Attribute
(
typeName
name
attrs
[
name
]
)
return
result
}
export
class
NodeType
{
groups
:
readonly
string
[
]
attrs
:
{
[
name
:
string
]
:
Attribute
}
defaultAttrs
:
Attrs
constructor
(
readonly
name
:
string
readonly
schema
:
Schema
readonly
spec
:
NodeSpec
)
{
this
.
groups
=
spec
.
group
?
spec
.
group
.
split
(
"
"
)
:
[
]
this
.
attrs
=
initAttrs
(
name
spec
.
attrs
)
this
.
defaultAttrs
=
defaultAttrs
(
this
.
attrs
)
;
(
this
as
any
)
.
contentMatch
=
null
;
(
this
as
any
)
.
inlineContent
=
null
this
.
isBlock
=
!
(
spec
.
inline
|
|
name
=
=
"
text
"
)
this
.
isText
=
name
=
=
"
text
"
}
declare
inlineContent
:
boolean
isBlock
:
boolean
isText
:
boolean
get
isInline
(
)
{
return
!
this
.
isBlock
}
get
isTextblock
(
)
{
return
this
.
isBlock
&
&
this
.
inlineContent
}
get
isLeaf
(
)
{
return
this
.
contentMatch
=
=
ContentMatch
.
empty
}
get
isAtom
(
)
{
return
this
.
isLeaf
|
|
!
!
this
.
spec
.
atom
}
isInGroup
(
group
:
string
)
{
return
this
.
groups
.
indexOf
(
group
)
>
-
1
}
declare
contentMatch
:
ContentMatch
markSet
:
readonly
MarkType
[
]
|
null
=
null
get
whitespace
(
)
:
"
pre
"
|
"
normal
"
{
return
this
.
spec
.
whitespace
|
|
(
this
.
spec
.
code
?
"
pre
"
:
"
normal
"
)
}
hasRequiredAttrs
(
)
{
for
(
let
n
in
this
.
attrs
)
if
(
this
.
attrs
[
n
]
.
isRequired
)
return
true
return
false
}
compatibleContent
(
other
:
NodeType
)
{
return
this
=
=
other
|
|
this
.
contentMatch
.
compatible
(
other
.
contentMatch
)
}
computeAttrs
(
attrs
:
Attrs
|
null
)
:
Attrs
{
if
(
!
attrs
&
&
this
.
defaultAttrs
)
return
this
.
defaultAttrs
else
return
computeAttrs
(
this
.
attrs
attrs
)
}
create
(
attrs
:
Attrs
|
null
=
null
content
?
:
Fragment
|
Node
|
readonly
Node
[
]
|
null
marks
?
:
readonly
Mark
[
]
)
{
if
(
this
.
isText
)
throw
new
Error
(
"
NodeType
.
create
can
'
t
construct
text
nodes
"
)
return
new
Node
(
this
this
.
computeAttrs
(
attrs
)
Fragment
.
from
(
content
)
Mark
.
setFrom
(
marks
)
)
}
createChecked
(
attrs
:
Attrs
|
null
=
null
content
?
:
Fragment
|
Node
|
readonly
Node
[
]
|
null
marks
?
:
readonly
Mark
[
]
)
{
content
=
Fragment
.
from
(
content
)
this
.
checkContent
(
content
)
return
new
Node
(
this
this
.
computeAttrs
(
attrs
)
content
Mark
.
setFrom
(
marks
)
)
}
createAndFill
(
attrs
:
Attrs
|
null
=
null
content
?
:
Fragment
|
Node
|
readonly
Node
[
]
|
null
marks
?
:
readonly
Mark
[
]
)
{
attrs
=
this
.
computeAttrs
(
attrs
)
content
=
Fragment
.
from
(
content
)
if
(
content
.
size
)
{
let
before
=
this
.
contentMatch
.
fillBefore
(
content
)
if
(
!
before
)
return
null
content
=
before
.
append
(
content
)
}
let
matched
=
this
.
contentMatch
.
matchFragment
(
content
)
let
after
=
matched
&
&
matched
.
fillBefore
(
Fragment
.
empty
true
)
if
(
!
after
)
return
null
return
new
Node
(
this
attrs
(
content
as
Fragment
)
.
append
(
after
)
Mark
.
setFrom
(
marks
)
)
}
validContent
(
content
:
Fragment
)
{
let
result
=
this
.
contentMatch
.
matchFragment
(
content
)
if
(
!
result
|
|
!
result
.
validEnd
)
return
false
for
(
let
i
=
0
;
i
<
content
.
childCount
;
i
+
+
)
if
(
!
this
.
allowsMarks
(
content
.
child
(
i
)
.
marks
)
)
return
false
return
true
}
checkContent
(
content
:
Fragment
)
{
if
(
!
this
.
validContent
(
content
)
)
throw
new
RangeError
(
Invalid
content
for
node
{
this
.
name
}
:
{
content
.
toString
(
)
.
slice
(
0
50
)
}
)
}
checkAttrs
(
attrs
:
Attrs
)
{
checkAttrs
(
this
.
attrs
attrs
"
node
"
this
.
name
)
}
allowsMarkType
(
markType
:
MarkType
)
{
return
this
.
markSet
=
=
null
|
|
this
.
markSet
.
indexOf
(
markType
)
>
-
1
}
allowsMarks
(
marks
:
readonly
Mark
[
]
)
{
if
(
this
.
markSet
=
=
null
)
return
true
for
(
let
i
=
0
;
i
<
marks
.
length
;
i
+
+
)
if
(
!
this
.
allowsMarkType
(
marks
[
i
]
.
type
)
)
return
false
return
true
}
allowedMarks
(
marks
:
readonly
Mark
[
]
)
:
readonly
Mark
[
]
{
if
(
this
.
markSet
=
=
null
)
return
marks
let
copy
for
(
let
i
=
0
;
i
<
marks
.
length
;
i
+
+
)
{
if
(
!
this
.
allowsMarkType
(
marks
[
i
]
.
type
)
)
{
if
(
!
copy
)
copy
=
marks
.
slice
(
0
i
)
}
else
if
(
copy
)
{
copy
.
push
(
marks
[
i
]
)
}
}
return
!
copy
?
marks
:
copy
.
length
?
copy
:
Mark
.
none
}
static
compile
<
Nodes
extends
string
>
(
nodes
:
OrderedMap
<
NodeSpec
>
schema
:
Schema
<
Nodes
>
)
:
{
readonly
[
name
in
Nodes
]
:
NodeType
}
{
let
result
=
Object
.
create
(
null
)
nodes
.
forEach
(
(
name
spec
)
=
>
result
[
name
]
=
new
NodeType
(
name
schema
spec
)
)
let
topType
=
schema
.
spec
.
topNode
|
|
"
doc
"
if
(
!
result
[
topType
]
)
throw
new
RangeError
(
"
Schema
is
missing
its
top
node
type
(
'
"
+
topType
+
"
'
)
"
)
if
(
!
result
.
text
)
throw
new
RangeError
(
"
Every
schema
needs
a
'
text
'
type
"
)
for
(
let
_
in
result
.
text
.
attrs
)
throw
new
RangeError
(
"
The
text
node
type
should
not
have
attributes
"
)
return
result
}
}
function
validateType
(
typeName
:
string
attrName
:
string
type
:
string
)
{
let
types
=
type
.
split
(
"
|
"
)
return
(
value
:
any
)
=
>
{
let
name
=
value
=
=
=
null
?
"
null
"
:
typeof
value
if
(
types
.
indexOf
(
name
)
<
0
)
throw
new
RangeError
(
Expected
value
of
type
{
types
}
for
attribute
{
attrName
}
on
type
{
typeName
}
got
{
name
}
)
}
}
class
Attribute
{
hasDefault
:
boolean
default
:
any
validate
:
undefined
|
(
(
value
:
any
)
=
>
void
)
constructor
(
typeName
:
string
attrName
:
string
options
:
AttributeSpec
)
{
this
.
hasDefault
=
Object
.
prototype
.
hasOwnProperty
.
call
(
options
"
default
"
)
this
.
default
=
options
.
default
this
.
validate
=
typeof
options
.
validate
=
=
"
string
"
?
validateType
(
typeName
attrName
options
.
validate
)
:
options
.
validate
}
get
isRequired
(
)
{
return
!
this
.
hasDefault
}
}
export
class
MarkType
{
attrs
:
{
[
name
:
string
]
:
Attribute
}
declare
excluded
:
readonly
MarkType
[
]
instance
:
Mark
|
null
constructor
(
readonly
name
:
string
readonly
rank
:
number
readonly
schema
:
Schema
readonly
spec
:
MarkSpec
)
{
this
.
attrs
=
initAttrs
(
name
spec
.
attrs
)
;
(
this
as
any
)
.
excluded
=
null
let
defaults
=
defaultAttrs
(
this
.
attrs
)
this
.
instance
=
defaults
?
new
Mark
(
this
defaults
)
:
null
}
create
(
attrs
:
Attrs
|
null
=
null
)
{
if
(
!
attrs
&
&
this
.
instance
)
return
this
.
instance
return
new
Mark
(
this
computeAttrs
(
this
.
attrs
attrs
)
)
}
static
compile
(
marks
:
OrderedMap
<
MarkSpec
>
schema
:
Schema
)
{
let
result
=
Object
.
create
(
null
)
rank
=
0
marks
.
forEach
(
(
name
spec
)
=
>
result
[
name
]
=
new
MarkType
(
name
rank
+
+
schema
spec
)
)
return
result
}
removeFromSet
(
set
:
readonly
Mark
[
]
)
:
readonly
Mark
[
]
{
for
(
var
i
=
0
;
i
<
set
.
length
;
i
+
+
)
if
(
set
[
i
]
.
type
=
=
this
)
{
set
=
set
.
slice
(
0
i
)
.
concat
(
set
.
slice
(
i
+
1
)
)
i
-
-
}
return
set
}
isInSet
(
set
:
readonly
Mark
[
]
)
:
Mark
|
undefined
{
for
(
let
i
=
0
;
i
<
set
.
length
;
i
+
+
)
if
(
set
[
i
]
.
type
=
=
this
)
return
set
[
i
]
}
checkAttrs
(
attrs
:
Attrs
)
{
checkAttrs
(
this
.
attrs
attrs
"
mark
"
this
.
name
)
}
excludes
(
other
:
MarkType
)
{
return
this
.
excluded
.
indexOf
(
other
)
>
-
1
}
}
export
interface
SchemaSpec
<
Nodes
extends
string
=
any
Marks
extends
string
=
any
>
{
nodes
:
{
[
name
in
Nodes
]
:
NodeSpec
}
|
OrderedMap
<
NodeSpec
>
marks
?
:
{
[
name
in
Marks
]
:
MarkSpec
}
|
OrderedMap
<
MarkSpec
>
topNode
?
:
string
}
export
interface
NodeSpec
{
content
?
:
string
marks
?
:
string
group
?
:
string
inline
?
:
boolean
atom
?
:
boolean
attrs
?
:
{
[
name
:
string
]
:
AttributeSpec
}
selectable
?
:
boolean
draggable
?
:
boolean
code
?
:
boolean
whitespace
?
:
"
pre
"
|
"
normal
"
definingAsContext
?
:
boolean
definingForContent
?
:
boolean
defining
?
:
boolean
isolating
?
:
boolean
toDOM
?
:
(
node
:
Node
)
=
>
DOMOutputSpec
parseDOM
?
:
readonly
TagParseRule
[
]
toDebugString
?
:
(
node
:
Node
)
=
>
string
leafText
?
:
(
node
:
Node
)
=
>
string
linebreakReplacement
?
:
boolean
[
key
:
string
]
:
any
}
export
interface
MarkSpec
{
attrs
?
:
{
[
name
:
string
]
:
AttributeSpec
}
inclusive
?
:
boolean
excludes
?
:
string
group
?
:
string
spanning
?
:
boolean
code
?
:
boolean
toDOM
?
:
(
mark
:
Mark
inline
:
boolean
)
=
>
DOMOutputSpec
parseDOM
?
:
readonly
ParseRule
[
]
[
key
:
string
]
:
any
}
export
interface
AttributeSpec
{
default
?
:
any
validate
?
:
string
|
(
(
value
:
any
)
=
>
void
)
}
export
class
Schema
<
Nodes
extends
string
=
any
Marks
extends
string
=
any
>
{
spec
:
{
nodes
:
OrderedMap
<
NodeSpec
>
marks
:
OrderedMap
<
MarkSpec
>
topNode
?
:
string
}
nodes
:
{
readonly
[
name
in
Nodes
]
:
NodeType
}
&
{
readonly
[
key
:
string
]
:
NodeType
}
marks
:
{
readonly
[
name
in
Marks
]
:
MarkType
}
&
{
readonly
[
key
:
string
]
:
MarkType
}
linebreakReplacement
:
NodeType
|
null
=
null
constructor
(
spec
:
SchemaSpec
<
Nodes
Marks
>
)
{
let
instanceSpec
=
this
.
spec
=
{
}
as
any
for
(
let
prop
in
spec
)
instanceSpec
[
prop
]
=
(
spec
as
any
)
[
prop
]
instanceSpec
.
nodes
=
OrderedMap
.
from
(
spec
.
nodes
)
instanceSpec
.
marks
=
OrderedMap
.
from
(
spec
.
marks
|
|
{
}
)
this
.
nodes
=
NodeType
.
compile
(
this
.
spec
.
nodes
this
)
this
.
marks
=
MarkType
.
compile
(
this
.
spec
.
marks
this
)
let
contentExprCache
=
Object
.
create
(
null
)
for
(
let
prop
in
this
.
nodes
)
{
if
(
prop
in
this
.
marks
)
throw
new
RangeError
(
prop
+
"
can
not
be
both
a
node
and
a
mark
"
)
let
type
=
this
.
nodes
[
prop
]
contentExpr
=
type
.
spec
.
content
|
|
"
"
markExpr
=
type
.
spec
.
marks
type
.
contentMatch
=
contentExprCache
[
contentExpr
]
|
|
(
contentExprCache
[
contentExpr
]
=
ContentMatch
.
parse
(
contentExpr
this
.
nodes
)
)
;
(
type
as
any
)
.
inlineContent
=
type
.
contentMatch
.
inlineContent
if
(
type
.
spec
.
linebreakReplacement
)
{
if
(
this
.
linebreakReplacement
)
throw
new
RangeError
(
"
Multiple
linebreak
nodes
defined
"
)
if
(
!
type
.
isInline
|
|
!
type
.
isLeaf
)
throw
new
RangeError
(
"
Linebreak
replacement
nodes
must
be
inline
leaf
nodes
"
)
this
.
linebreakReplacement
=
type
}
type
.
markSet
=
markExpr
=
=
"
_
"
?
null
:
markExpr
?
gatherMarks
(
this
markExpr
.
split
(
"
"
)
)
:
markExpr
=
=
"
"
|
|
!
type
.
inlineContent
?
[
]
:
null
}
for
(
let
prop
in
this
.
marks
)
{
let
type
=
this
.
marks
[
prop
]
excl
=
type
.
spec
.
excludes
type
.
excluded
=
excl
=
=
null
?
[
type
]
:
excl
=
=
"
"
?
[
]
:
gatherMarks
(
this
excl
.
split
(
"
"
)
)
}
this
.
nodeFromJSON
=
json
=
>
Node
.
fromJSON
(
this
json
)
this
.
markFromJSON
=
json
=
>
Mark
.
fromJSON
(
this
json
)
this
.
topNodeType
=
this
.
nodes
[
this
.
spec
.
topNode
|
|
"
doc
"
]
this
.
cached
.
wrappings
=
Object
.
create
(
null
)
}
topNodeType
:
NodeType
cached
:
{
[
key
:
string
]
:
any
}
=
Object
.
create
(
null
)
node
(
type
:
string
|
NodeType
attrs
:
Attrs
|
null
=
null
content
?
:
Fragment
|
Node
|
readonly
Node
[
]
marks
?
:
readonly
Mark
[
]
)
{
if
(
typeof
type
=
=
"
string
"
)
type
=
this
.
nodeType
(
type
)
else
if
(
!
(
type
instanceof
NodeType
)
)
throw
new
RangeError
(
"
Invalid
node
type
:
"
+
type
)
else
if
(
type
.
schema
!
=
this
)
throw
new
RangeError
(
"
Node
type
from
different
schema
used
(
"
+
type
.
name
+
"
)
"
)
return
type
.
createChecked
(
attrs
content
marks
)
}
text
(
text
:
string
marks
?
:
readonly
Mark
[
]
|
null
)
:
Node
{
let
type
=
this
.
nodes
.
text
return
new
TextNode
(
type
type
.
defaultAttrs
text
Mark
.
setFrom
(
marks
)
)
}
mark
(
type
:
string
|
MarkType
attrs
?
:
Attrs
|
null
)
{
if
(
typeof
type
=
=
"
string
"
)
type
=
this
.
marks
[
type
]
return
type
.
create
(
attrs
)
}
nodeFromJSON
:
(
json
:
any
)
=
>
Node
markFromJSON
:
(
json
:
any
)
=
>
Mark
nodeType
(
name
:
string
)
{
let
found
=
this
.
nodes
[
name
]
if
(
!
found
)
throw
new
RangeError
(
"
Unknown
node
type
:
"
+
name
)
return
found
}
}
function
gatherMarks
(
schema
:
Schema
marks
:
readonly
string
[
]
)
{
let
found
:
MarkType
[
]
=
[
]
for
(
let
i
=
0
;
i
<
marks
.
length
;
i
+
+
)
{
let
name
=
marks
[
i
]
mark
=
schema
.
marks
[
name
]
ok
=
mark
if
(
mark
)
{
found
.
push
(
mark
)
}
else
{
for
(
let
prop
in
schema
.
marks
)
{
let
mark
=
schema
.
marks
[
prop
]
if
(
name
=
=
"
_
"
|
|
(
mark
.
spec
.
group
&
&
mark
.
spec
.
group
.
split
(
"
"
)
.
indexOf
(
name
)
>
-
1
)
)
found
.
push
(
ok
=
mark
)
}
}
if
(
!
ok
)
throw
new
SyntaxError
(
"
Unknown
mark
type
:
'
"
+
marks
[
i
]
+
"
'
"
)
}
return
found
}
