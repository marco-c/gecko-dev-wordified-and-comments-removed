import
{
Mark
}
from
"
.
/
mark
"
import
{
Node
}
from
"
.
/
node
"
export
class
ResolvedPos
{
depth
:
number
constructor
(
readonly
pos
:
number
readonly
path
:
any
[
]
readonly
parentOffset
:
number
)
{
this
.
depth
=
path
.
length
/
3
-
1
}
resolveDepth
(
val
:
number
|
undefined
|
null
)
{
if
(
val
=
=
null
)
return
this
.
depth
if
(
val
<
0
)
return
this
.
depth
+
val
return
val
}
get
parent
(
)
{
return
this
.
node
(
this
.
depth
)
}
get
doc
(
)
{
return
this
.
node
(
0
)
}
node
(
depth
?
:
number
|
null
)
:
Node
{
return
this
.
path
[
this
.
resolveDepth
(
depth
)
*
3
]
}
index
(
depth
?
:
number
|
null
)
:
number
{
return
this
.
path
[
this
.
resolveDepth
(
depth
)
*
3
+
1
]
}
indexAfter
(
depth
?
:
number
|
null
)
:
number
{
depth
=
this
.
resolveDepth
(
depth
)
return
this
.
index
(
depth
)
+
(
depth
=
=
this
.
depth
&
&
!
this
.
textOffset
?
0
:
1
)
}
start
(
depth
?
:
number
|
null
)
:
number
{
depth
=
this
.
resolveDepth
(
depth
)
return
depth
=
=
0
?
0
:
this
.
path
[
depth
*
3
-
1
]
+
1
}
end
(
depth
?
:
number
|
null
)
:
number
{
depth
=
this
.
resolveDepth
(
depth
)
return
this
.
start
(
depth
)
+
this
.
node
(
depth
)
.
content
.
size
}
before
(
depth
?
:
number
|
null
)
:
number
{
depth
=
this
.
resolveDepth
(
depth
)
if
(
!
depth
)
throw
new
RangeError
(
"
There
is
no
position
before
the
top
-
level
node
"
)
return
depth
=
=
this
.
depth
+
1
?
this
.
pos
:
this
.
path
[
depth
*
3
-
1
]
}
after
(
depth
?
:
number
|
null
)
:
number
{
depth
=
this
.
resolveDepth
(
depth
)
if
(
!
depth
)
throw
new
RangeError
(
"
There
is
no
position
after
the
top
-
level
node
"
)
return
depth
=
=
this
.
depth
+
1
?
this
.
pos
:
this
.
path
[
depth
*
3
-
1
]
+
this
.
path
[
depth
*
3
]
.
nodeSize
}
get
textOffset
(
)
:
number
{
return
this
.
pos
-
this
.
path
[
this
.
path
.
length
-
1
]
}
get
nodeAfter
(
)
:
Node
|
null
{
let
parent
=
this
.
parent
index
=
this
.
index
(
this
.
depth
)
if
(
index
=
=
parent
.
childCount
)
return
null
let
dOff
=
this
.
pos
-
this
.
path
[
this
.
path
.
length
-
1
]
child
=
parent
.
child
(
index
)
return
dOff
?
parent
.
child
(
index
)
.
cut
(
dOff
)
:
child
}
get
nodeBefore
(
)
:
Node
|
null
{
let
index
=
this
.
index
(
this
.
depth
)
let
dOff
=
this
.
pos
-
this
.
path
[
this
.
path
.
length
-
1
]
if
(
dOff
)
return
this
.
parent
.
child
(
index
)
.
cut
(
0
dOff
)
return
index
=
=
0
?
null
:
this
.
parent
.
child
(
index
-
1
)
}
posAtIndex
(
index
:
number
depth
?
:
number
|
null
)
:
number
{
depth
=
this
.
resolveDepth
(
depth
)
let
node
=
this
.
path
[
depth
*
3
]
pos
=
depth
=
=
0
?
0
:
this
.
path
[
depth
*
3
-
1
]
+
1
for
(
let
i
=
0
;
i
<
index
;
i
+
+
)
pos
+
=
node
.
child
(
i
)
.
nodeSize
return
pos
}
marks
(
)
:
readonly
Mark
[
]
{
let
parent
=
this
.
parent
index
=
this
.
index
(
)
if
(
parent
.
content
.
size
=
=
0
)
return
Mark
.
none
if
(
this
.
textOffset
)
return
parent
.
child
(
index
)
.
marks
let
main
=
parent
.
maybeChild
(
index
-
1
)
other
=
parent
.
maybeChild
(
index
)
if
(
!
main
)
{
let
tmp
=
main
;
main
=
other
;
other
=
tmp
}
let
marks
=
main
!
.
marks
for
(
var
i
=
0
;
i
<
marks
.
length
;
i
+
+
)
if
(
marks
[
i
]
.
type
.
spec
.
inclusive
=
=
=
false
&
&
(
!
other
|
|
!
marks
[
i
]
.
isInSet
(
other
.
marks
)
)
)
marks
=
marks
[
i
-
-
]
.
removeFromSet
(
marks
)
return
marks
}
marksAcross
(
end
:
ResolvedPos
)
:
readonly
Mark
[
]
|
null
{
let
after
=
this
.
parent
.
maybeChild
(
this
.
index
(
)
)
if
(
!
after
|
|
!
after
.
isInline
)
return
null
let
marks
=
after
.
marks
next
=
end
.
parent
.
maybeChild
(
end
.
index
(
)
)
for
(
var
i
=
0
;
i
<
marks
.
length
;
i
+
+
)
if
(
marks
[
i
]
.
type
.
spec
.
inclusive
=
=
=
false
&
&
(
!
next
|
|
!
marks
[
i
]
.
isInSet
(
next
.
marks
)
)
)
marks
=
marks
[
i
-
-
]
.
removeFromSet
(
marks
)
return
marks
}
sharedDepth
(
pos
:
number
)
:
number
{
for
(
let
depth
=
this
.
depth
;
depth
>
0
;
depth
-
-
)
if
(
this
.
start
(
depth
)
<
=
pos
&
&
this
.
end
(
depth
)
>
=
pos
)
return
depth
return
0
}
blockRange
(
other
:
ResolvedPos
=
this
pred
?
:
(
node
:
Node
)
=
>
boolean
)
:
NodeRange
|
null
{
if
(
other
.
pos
<
this
.
pos
)
return
other
.
blockRange
(
this
)
for
(
let
d
=
this
.
depth
-
(
this
.
parent
.
inlineContent
|
|
this
.
pos
=
=
other
.
pos
?
1
:
0
)
;
d
>
=
0
;
d
-
-
)
if
(
other
.
pos
<
=
this
.
end
(
d
)
&
&
(
!
pred
|
|
pred
(
this
.
node
(
d
)
)
)
)
return
new
NodeRange
(
this
other
d
)
return
null
}
sameParent
(
other
:
ResolvedPos
)
:
boolean
{
return
this
.
pos
-
this
.
parentOffset
=
=
other
.
pos
-
other
.
parentOffset
}
max
(
other
:
ResolvedPos
)
:
ResolvedPos
{
return
other
.
pos
>
this
.
pos
?
other
:
this
}
min
(
other
:
ResolvedPos
)
:
ResolvedPos
{
return
other
.
pos
<
this
.
pos
?
other
:
this
}
toString
(
)
{
let
str
=
"
"
for
(
let
i
=
1
;
i
<
=
this
.
depth
;
i
+
+
)
str
+
=
(
str
?
"
/
"
:
"
"
)
+
this
.
node
(
i
)
.
type
.
name
+
"
_
"
+
this
.
index
(
i
-
1
)
return
str
+
"
:
"
+
this
.
parentOffset
}
static
resolve
(
doc
:
Node
pos
:
number
)
:
ResolvedPos
{
if
(
!
(
pos
>
=
0
&
&
pos
<
=
doc
.
content
.
size
)
)
throw
new
RangeError
(
"
Position
"
+
pos
+
"
out
of
range
"
)
let
path
:
Array
<
Node
|
number
>
=
[
]
let
start
=
0
parentOffset
=
pos
for
(
let
node
=
doc
;
;
)
{
let
{
index
offset
}
=
node
.
content
.
findIndex
(
parentOffset
)
let
rem
=
parentOffset
-
offset
path
.
push
(
node
index
start
+
offset
)
if
(
!
rem
)
break
node
=
node
.
child
(
index
)
if
(
node
.
isText
)
break
parentOffset
=
rem
-
1
start
+
=
offset
+
1
}
return
new
ResolvedPos
(
pos
path
parentOffset
)
}
static
resolveCached
(
doc
:
Node
pos
:
number
)
:
ResolvedPos
{
let
cache
=
resolveCache
.
get
(
doc
)
if
(
cache
)
{
for
(
let
i
=
0
;
i
<
cache
.
elts
.
length
;
i
+
+
)
{
let
elt
=
cache
.
elts
[
i
]
if
(
elt
.
pos
=
=
pos
)
return
elt
}
}
else
{
resolveCache
.
set
(
doc
cache
=
new
ResolveCache
)
}
let
result
=
cache
.
elts
[
cache
.
i
]
=
ResolvedPos
.
resolve
(
doc
pos
)
cache
.
i
=
(
cache
.
i
+
1
)
%
resolveCacheSize
return
result
}
}
class
ResolveCache
{
elts
:
ResolvedPos
[
]
=
[
]
i
=
0
}
const
resolveCacheSize
=
12
resolveCache
=
new
WeakMap
<
Node
ResolveCache
>
(
)
export
class
NodeRange
{
constructor
(
readonly
from
:
ResolvedPos
readonly
to
:
ResolvedPos
readonly
depth
:
number
)
{
}
get
start
(
)
{
return
this
.
from
.
before
(
this
.
depth
+
1
)
}
get
end
(
)
{
return
this
.
to
.
after
(
this
.
depth
+
1
)
}
get
parent
(
)
{
return
this
.
from
.
node
(
this
.
depth
)
}
get
startIndex
(
)
{
return
this
.
from
.
index
(
this
.
depth
)
}
get
endIndex
(
)
{
return
this
.
to
.
indexAfter
(
this
.
depth
)
}
}
