import
{
Fragment
}
from
"
.
/
fragment
"
import
{
Mark
}
from
"
.
/
mark
"
import
{
Schema
NodeType
Attrs
MarkType
}
from
"
.
/
schema
"
import
{
Slice
replace
}
from
"
.
/
replace
"
import
{
ResolvedPos
}
from
"
.
/
resolvedpos
"
import
{
compareDeep
}
from
"
.
/
comparedeep
"
const
emptyAttrs
:
Attrs
=
Object
.
create
(
null
)
export
class
Node
{
constructor
(
readonly
type
:
NodeType
readonly
attrs
:
Attrs
content
?
:
Fragment
|
null
readonly
marks
=
Mark
.
none
)
{
this
.
content
=
content
|
|
Fragment
.
empty
}
readonly
content
:
Fragment
get
children
(
)
{
return
this
.
content
.
content
}
readonly
text
:
string
|
undefined
get
nodeSize
(
)
:
number
{
return
this
.
isLeaf
?
1
:
2
+
this
.
content
.
size
}
get
childCount
(
)
{
return
this
.
content
.
childCount
}
child
(
index
:
number
)
{
return
this
.
content
.
child
(
index
)
}
maybeChild
(
index
:
number
)
{
return
this
.
content
.
maybeChild
(
index
)
}
forEach
(
f
:
(
node
:
Node
offset
:
number
index
:
number
)
=
>
void
)
{
this
.
content
.
forEach
(
f
)
}
nodesBetween
(
from
:
number
to
:
number
f
:
(
node
:
Node
pos
:
number
parent
:
Node
|
null
index
:
number
)
=
>
void
|
boolean
startPos
=
0
)
{
this
.
content
.
nodesBetween
(
from
to
f
startPos
this
)
}
descendants
(
f
:
(
node
:
Node
pos
:
number
parent
:
Node
|
null
index
:
number
)
=
>
void
|
boolean
)
{
this
.
nodesBetween
(
0
this
.
content
.
size
f
)
}
get
textContent
(
)
{
return
(
this
.
isLeaf
&
&
this
.
type
.
spec
.
leafText
)
?
this
.
type
.
spec
.
leafText
(
this
)
:
this
.
textBetween
(
0
this
.
content
.
size
"
"
)
}
textBetween
(
from
:
number
to
:
number
blockSeparator
?
:
string
|
null
leafText
?
:
null
|
string
|
(
(
leafNode
:
Node
)
=
>
string
)
)
{
return
this
.
content
.
textBetween
(
from
to
blockSeparator
leafText
)
}
get
firstChild
(
)
:
Node
|
null
{
return
this
.
content
.
firstChild
}
get
lastChild
(
)
:
Node
|
null
{
return
this
.
content
.
lastChild
}
eq
(
other
:
Node
)
{
return
this
=
=
other
|
|
(
this
.
sameMarkup
(
other
)
&
&
this
.
content
.
eq
(
other
.
content
)
)
}
sameMarkup
(
other
:
Node
)
{
return
this
.
hasMarkup
(
other
.
type
other
.
attrs
other
.
marks
)
}
hasMarkup
(
type
:
NodeType
attrs
?
:
Attrs
|
null
marks
?
:
readonly
Mark
[
]
)
:
boolean
{
return
this
.
type
=
=
type
&
&
compareDeep
(
this
.
attrs
attrs
|
|
type
.
defaultAttrs
|
|
emptyAttrs
)
&
&
Mark
.
sameSet
(
this
.
marks
marks
|
|
Mark
.
none
)
}
copy
(
content
:
Fragment
|
null
=
null
)
:
Node
{
if
(
content
=
=
this
.
content
)
return
this
return
new
Node
(
this
.
type
this
.
attrs
content
this
.
marks
)
}
mark
(
marks
:
readonly
Mark
[
]
)
:
Node
{
return
marks
=
=
this
.
marks
?
this
:
new
Node
(
this
.
type
this
.
attrs
this
.
content
marks
)
}
cut
(
from
:
number
to
:
number
=
this
.
content
.
size
)
:
Node
{
if
(
from
=
=
0
&
&
to
=
=
this
.
content
.
size
)
return
this
return
this
.
copy
(
this
.
content
.
cut
(
from
to
)
)
}
slice
(
from
:
number
to
:
number
=
this
.
content
.
size
includeParents
=
false
)
{
if
(
from
=
=
to
)
return
Slice
.
empty
let
from
=
this
.
resolve
(
from
)
to
=
this
.
resolve
(
to
)
let
depth
=
includeParents
?
0
:
from
.
sharedDepth
(
to
)
let
start
=
from
.
start
(
depth
)
node
=
from
.
node
(
depth
)
let
content
=
node
.
content
.
cut
(
from
.
pos
-
start
to
.
pos
-
start
)
return
new
Slice
(
content
from
.
depth
-
depth
to
.
depth
-
depth
)
}
replace
(
from
:
number
to
:
number
slice
:
Slice
)
{
return
replace
(
this
.
resolve
(
from
)
this
.
resolve
(
to
)
slice
)
}
nodeAt
(
pos
:
number
)
:
Node
|
null
{
for
(
let
node
:
Node
|
null
=
this
;
;
)
{
let
{
index
offset
}
=
node
.
content
.
findIndex
(
pos
)
node
=
node
.
maybeChild
(
index
)
if
(
!
node
)
return
null
if
(
offset
=
=
pos
|
|
node
.
isText
)
return
node
pos
-
=
offset
+
1
}
}
childAfter
(
pos
:
number
)
:
{
node
:
Node
|
null
index
:
number
offset
:
number
}
{
let
{
index
offset
}
=
this
.
content
.
findIndex
(
pos
)
return
{
node
:
this
.
content
.
maybeChild
(
index
)
index
offset
}
}
childBefore
(
pos
:
number
)
:
{
node
:
Node
|
null
index
:
number
offset
:
number
}
{
if
(
pos
=
=
0
)
return
{
node
:
null
index
:
0
offset
:
0
}
let
{
index
offset
}
=
this
.
content
.
findIndex
(
pos
)
if
(
offset
<
pos
)
return
{
node
:
this
.
content
.
child
(
index
)
index
offset
}
let
node
=
this
.
content
.
child
(
index
-
1
)
return
{
node
index
:
index
-
1
offset
:
offset
-
node
.
nodeSize
}
}
resolve
(
pos
:
number
)
{
return
ResolvedPos
.
resolveCached
(
this
pos
)
}
resolveNoCache
(
pos
:
number
)
{
return
ResolvedPos
.
resolve
(
this
pos
)
}
rangeHasMark
(
from
:
number
to
:
number
type
:
Mark
|
MarkType
)
:
boolean
{
let
found
=
false
if
(
to
>
from
)
this
.
nodesBetween
(
from
to
node
=
>
{
if
(
type
.
isInSet
(
node
.
marks
)
)
found
=
true
return
!
found
}
)
return
found
}
get
isBlock
(
)
{
return
this
.
type
.
isBlock
}
get
isTextblock
(
)
{
return
this
.
type
.
isTextblock
}
get
inlineContent
(
)
{
return
this
.
type
.
inlineContent
}
get
isInline
(
)
{
return
this
.
type
.
isInline
}
get
isText
(
)
{
return
this
.
type
.
isText
}
get
isLeaf
(
)
{
return
this
.
type
.
isLeaf
}
get
isAtom
(
)
{
return
this
.
type
.
isAtom
}
toString
(
)
:
string
{
if
(
this
.
type
.
spec
.
toDebugString
)
return
this
.
type
.
spec
.
toDebugString
(
this
)
let
name
=
this
.
type
.
name
if
(
this
.
content
.
size
)
name
+
=
"
(
"
+
this
.
content
.
toStringInner
(
)
+
"
)
"
return
wrapMarks
(
this
.
marks
name
)
}
contentMatchAt
(
index
:
number
)
{
let
match
=
this
.
type
.
contentMatch
.
matchFragment
(
this
.
content
0
index
)
if
(
!
match
)
throw
new
Error
(
"
Called
contentMatchAt
on
a
node
with
invalid
content
"
)
return
match
}
canReplace
(
from
:
number
to
:
number
replacement
=
Fragment
.
empty
start
=
0
end
=
replacement
.
childCount
)
{
let
one
=
this
.
contentMatchAt
(
from
)
.
matchFragment
(
replacement
start
end
)
let
two
=
one
&
&
one
.
matchFragment
(
this
.
content
to
)
if
(
!
two
|
|
!
two
.
validEnd
)
return
false
for
(
let
i
=
start
;
i
<
end
;
i
+
+
)
if
(
!
this
.
type
.
allowsMarks
(
replacement
.
child
(
i
)
.
marks
)
)
return
false
return
true
}
canReplaceWith
(
from
:
number
to
:
number
type
:
NodeType
marks
?
:
readonly
Mark
[
]
)
{
if
(
marks
&
&
!
this
.
type
.
allowsMarks
(
marks
)
)
return
false
let
start
=
this
.
contentMatchAt
(
from
)
.
matchType
(
type
)
let
end
=
start
&
&
start
.
matchFragment
(
this
.
content
to
)
return
end
?
end
.
validEnd
:
false
}
canAppend
(
other
:
Node
)
{
if
(
other
.
content
.
size
)
return
this
.
canReplace
(
this
.
childCount
this
.
childCount
other
.
content
)
else
return
this
.
type
.
compatibleContent
(
other
.
type
)
}
check
(
)
{
this
.
type
.
checkContent
(
this
.
content
)
this
.
type
.
checkAttrs
(
this
.
attrs
)
let
copy
=
Mark
.
none
for
(
let
i
=
0
;
i
<
this
.
marks
.
length
;
i
+
+
)
{
let
mark
=
this
.
marks
[
i
]
mark
.
type
.
checkAttrs
(
mark
.
attrs
)
copy
=
mark
.
addToSet
(
copy
)
}
if
(
!
Mark
.
sameSet
(
copy
this
.
marks
)
)
throw
new
RangeError
(
Invalid
collection
of
marks
for
node
{
this
.
type
.
name
}
:
{
this
.
marks
.
map
(
m
=
>
m
.
type
.
name
)
}
)
this
.
content
.
forEach
(
node
=
>
node
.
check
(
)
)
}
toJSON
(
)
:
any
{
let
obj
:
any
=
{
type
:
this
.
type
.
name
}
for
(
let
_
in
this
.
attrs
)
{
obj
.
attrs
=
this
.
attrs
break
}
if
(
this
.
content
.
size
)
obj
.
content
=
this
.
content
.
toJSON
(
)
if
(
this
.
marks
.
length
)
obj
.
marks
=
this
.
marks
.
map
(
n
=
>
n
.
toJSON
(
)
)
return
obj
}
static
fromJSON
(
schema
:
Schema
json
:
any
)
:
Node
{
if
(
!
json
)
throw
new
RangeError
(
"
Invalid
input
for
Node
.
fromJSON
"
)
let
marks
:
Mark
[
]
|
undefined
=
undefined
if
(
json
.
marks
)
{
if
(
!
Array
.
isArray
(
json
.
marks
)
)
throw
new
RangeError
(
"
Invalid
mark
data
for
Node
.
fromJSON
"
)
marks
=
json
.
marks
.
map
(
schema
.
markFromJSON
)
}
if
(
json
.
type
=
=
"
text
"
)
{
if
(
typeof
json
.
text
!
=
"
string
"
)
throw
new
RangeError
(
"
Invalid
text
node
in
JSON
"
)
return
schema
.
text
(
json
.
text
marks
)
}
let
content
=
Fragment
.
fromJSON
(
schema
json
.
content
)
let
node
=
schema
.
nodeType
(
json
.
type
)
.
create
(
json
.
attrs
content
marks
)
node
.
type
.
checkAttrs
(
node
.
attrs
)
return
node
}
}
;
(
Node
.
prototype
as
any
)
.
text
=
undefined
export
class
TextNode
extends
Node
{
readonly
text
:
string
constructor
(
type
:
NodeType
attrs
:
Attrs
content
:
string
marks
?
:
readonly
Mark
[
]
)
{
super
(
type
attrs
null
marks
)
if
(
!
content
)
throw
new
RangeError
(
"
Empty
text
nodes
are
not
allowed
"
)
this
.
text
=
content
}
toString
(
)
{
if
(
this
.
type
.
spec
.
toDebugString
)
return
this
.
type
.
spec
.
toDebugString
(
this
)
return
wrapMarks
(
this
.
marks
JSON
.
stringify
(
this
.
text
)
)
}
get
textContent
(
)
{
return
this
.
text
}
textBetween
(
from
:
number
to
:
number
)
{
return
this
.
text
.
slice
(
from
to
)
}
get
nodeSize
(
)
{
return
this
.
text
.
length
}
mark
(
marks
:
readonly
Mark
[
]
)
{
return
marks
=
=
this
.
marks
?
this
:
new
TextNode
(
this
.
type
this
.
attrs
this
.
text
marks
)
}
withText
(
text
:
string
)
{
if
(
text
=
=
this
.
text
)
return
this
return
new
TextNode
(
this
.
type
this
.
attrs
text
this
.
marks
)
}
cut
(
from
=
0
to
=
this
.
text
.
length
)
{
if
(
from
=
=
0
&
&
to
=
=
this
.
text
.
length
)
return
this
return
this
.
withText
(
this
.
text
.
slice
(
from
to
)
)
}
eq
(
other
:
Node
)
{
return
this
.
sameMarkup
(
other
)
&
&
this
.
text
=
=
other
.
text
}
toJSON
(
)
{
let
base
=
super
.
toJSON
(
)
base
.
text
=
this
.
text
return
base
}
}
function
wrapMarks
(
marks
:
readonly
Mark
[
]
str
:
string
)
{
for
(
let
i
=
marks
.
length
-
1
;
i
>
=
0
;
i
-
-
)
str
=
marks
[
i
]
.
type
.
name
+
"
(
"
+
str
+
"
)
"
return
str
}
