#
ifndef
DAV1D_TESTS_CHECKASM_CHECKASM_H
#
define
DAV1D_TESTS_CHECKASM_CHECKASM_H
#
include
"
config
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
if
ARCH_X86_64
&
&
defined
(
_WIN32
)
#
include
<
windows
.
h
>
#
define
checkasm_context
CONTEXT
#
define
checkasm_save_context
(
)
RtlCaptureContext
(
&
checkasm_context_buf
)
#
define
checkasm_load_context
(
)
RtlRestoreContext
(
&
checkasm_context_buf
NULL
)
#
else
#
include
<
setjmp
.
h
>
#
define
checkasm_context
jmp_buf
#
define
checkasm_save_context
(
)
setjmp
(
checkasm_context_buf
)
#
define
checkasm_load_context
(
)
longjmp
(
checkasm_context_buf
1
)
#
endif
#
include
"
include
/
common
/
attributes
.
h
"
#
include
"
include
/
common
/
bitdepth
.
h
"
#
include
"
include
/
common
/
intops
.
h
"
int
xor128_rand
(
void
)
;
#
define
rnd
xor128_rand
#
define
decl_check_bitfns
(
name
)
\
name
#
#
_8bpc
(
void
)
;
\
name
#
#
_16bpc
(
void
)
void
checkasm_check_msac
(
void
)
;
decl_check_bitfns
(
void
checkasm_check_cdef
)
;
decl_check_bitfns
(
void
checkasm_check_filmgrain
)
;
decl_check_bitfns
(
void
checkasm_check_ipred
)
;
decl_check_bitfns
(
void
checkasm_check_itx
)
;
decl_check_bitfns
(
void
checkasm_check_loopfilter
)
;
decl_check_bitfns
(
void
checkasm_check_looprestoration
)
;
decl_check_bitfns
(
void
checkasm_check_mc
)
;
void
*
checkasm_check_func
(
void
*
func
const
char
*
name
.
.
.
)
;
int
checkasm_bench_func
(
void
)
;
int
checkasm_fail_func
(
const
char
*
msg
.
.
.
)
;
void
checkasm_update_bench
(
int
iterations
uint64_t
cycles
)
;
void
checkasm_report
(
const
char
*
name
.
.
.
)
;
void
checkasm_set_signal_handler_state
(
int
enabled
)
;
extern
checkasm_context
checkasm_context_buf
;
int
float_near_ulp
(
float
a
float
b
unsigned
max_ulp
)
;
int
float_near_abs_eps
(
float
a
float
b
float
eps
)
;
int
float_near_abs_eps_ulp
(
float
a
float
b
float
eps
unsigned
max_ulp
)
;
int
float_near_ulp_array
(
const
float
*
a
const
float
*
b
unsigned
max_ulp
int
len
)
;
int
float_near_abs_eps_array
(
const
float
*
a
const
float
*
b
float
eps
int
len
)
;
int
float_near_abs_eps_array_ulp
(
const
float
*
a
const
float
*
b
float
eps
unsigned
max_ulp
int
len
)
;
static
void
*
func_ref
*
func_new
;
#
define
BENCH_RUNS
(
1
<
<
12
)
/
*
Trade
-
off
between
accuracy
and
speed
*
/
#
define
check_func
(
func
.
.
.
)
\
(
func_ref
=
checkasm_check_func
(
(
func_new
=
func
)
__VA_ARGS__
)
)
#
define
declare_func
(
ret
.
.
.
)
\
declare_new
(
ret
__VA_ARGS__
)
\
typedef
ret
func_type
(
__VA_ARGS__
)
;
\
checkasm_save_context
(
)
#
define
fail
(
)
checkasm_fail_func
(
"
%
s
:
%
d
"
__FILE__
__LINE__
)
#
define
report
checkasm_report
#
define
call_ref
(
.
.
.
)
\
(
checkasm_set_signal_handler_state
(
1
)
\
(
(
func_type
*
)
func_ref
)
(
__VA_ARGS__
)
)
;
\
checkasm_set_signal_handler_state
(
0
)
#
if
HAVE_ASM
#
if
ARCH_X86
#
ifdef
_MSC_VER
#
include
<
intrin
.
h
>
#
define
readtime
(
)
(
_mm_lfence
(
)
__rdtsc
(
)
)
#
else
static
inline
uint64_t
readtime
(
void
)
{
uint32_t
eax
edx
;
__asm__
__volatile__
(
"
lfence
\
nrdtsc
"
:
"
=
a
"
(
eax
)
"
=
d
"
(
edx
)
)
;
return
(
(
(
uint64_t
)
edx
)
<
<
32
)
|
eax
;
}
#
define
readtime
readtime
#
endif
#
elif
ARCH_AARCH64
#
ifdef
_MSC_VER
#
include
<
windows
.
h
>
#
define
readtime
(
)
(
_InstructionSynchronizationBarrier
(
)
ReadTimeStampCounter
(
)
)
#
else
static
inline
uint64_t
readtime
(
void
)
{
uint64_t
cycle_counter
;
__asm__
__volatile__
(
"
isb
\
nmrs
%
0
pmccntr_el0
"
:
"
=
r
"
(
cycle_counter
)
:
:
"
memory
"
)
;
return
cycle_counter
;
}
#
define
readtime
readtime
#
endif
#
elif
ARCH_ARM
&
&
!
defined
(
_MSC_VER
)
&
&
__ARM_ARCH
>
=
7
static
inline
uint64_t
readtime
(
void
)
{
uint32_t
cycle_counter
;
__asm__
__volatile__
(
"
isb
\
nmrc
p15
0
%
0
c9
c13
0
"
:
"
=
r
"
(
cycle_counter
)
:
:
"
memory
"
)
;
return
cycle_counter
;
}
#
define
readtime
readtime
#
elif
ARCH_PPC64LE
static
inline
uint64_t
readtime
(
void
)
{
uint32_t
tbu
tbl
temp
;
__asm__
__volatile__
(
"
1
:
\
n
"
"
mfspr
%
2
269
\
n
"
"
mfspr
%
0
268
\
n
"
"
mfspr
%
1
269
\
n
"
"
cmpw
%
2
%
1
\
n
"
"
bne
1b
\
n
"
:
"
=
r
"
(
tbl
)
"
=
r
"
(
tbu
)
"
=
r
"
(
temp
)
:
:
"
cc
"
)
;
return
(
(
(
uint64_t
)
tbu
)
<
<
32
)
|
(
uint64_t
)
tbl
;
}
#
define
readtime
readtime
#
endif
void
checkasm_checked_call
(
void
*
func
.
.
.
)
;
#
if
ARCH_X86_64
void
checkasm_stack_clobber
(
uint64_t
clobber
.
.
.
)
;
void
checkasm_simd_warmup
(
void
)
;
#
define
declare_new
(
ret
.
.
.
)
\
ret
(
*
checked_call
)
(
void
*
int
int
int
int
int
__VA_ARGS__
)
=
\
(
void
*
)
checkasm_checked_call
;
#
define
CLOB
(
UINT64_C
(
0xdeadbeefdeadbeef
)
)
#
define
call_new
(
.
.
.
)
\
(
checkasm_set_signal_handler_state
(
1
)
\
checkasm_simd_warmup
(
)
\
checkasm_stack_clobber
(
CLOB
CLOB
CLOB
CLOB
CLOB
CLOB
CLOB
\
CLOB
CLOB
CLOB
CLOB
CLOB
CLOB
CLOB
\
CLOB
CLOB
CLOB
CLOB
CLOB
CLOB
CLOB
)
\
checked_call
(
func_new
0
0
0
0
0
__VA_ARGS__
)
)
;
\
checkasm_set_signal_handler_state
(
0
)
#
elif
ARCH_X86_32
#
define
declare_new
(
ret
.
.
.
)
\
ret
(
*
checked_call
)
(
void
*
__VA_ARGS__
)
=
(
void
*
)
checkasm_checked_call
;
#
define
call_new
(
.
.
.
)
\
(
checkasm_set_signal_handler_state
(
1
)
\
checked_call
(
func_new
__VA_ARGS__
)
)
;
\
checkasm_set_signal_handler_state
(
0
)
#
elif
ARCH_ARM
void
checkasm_checked_call_vfp
(
void
*
func
int
dummy
.
.
.
)
;
#
define
declare_new
(
ret
.
.
.
)
\
ret
(
*
checked_call
)
(
void
*
int
dummy
__VA_ARGS__
)
=
\
(
void
*
)
checkasm_checked_call_vfp
;
#
define
call_new
(
.
.
.
)
\
(
checkasm_set_signal_handler_state
(
1
)
\
checked_call
(
func_new
0
__VA_ARGS__
)
)
;
\
checkasm_set_signal_handler_state
(
0
)
#
elif
ARCH_AARCH64
&
&
!
defined
(
__APPLE__
)
void
checkasm_stack_clobber
(
uint64_t
clobber
.
.
.
)
;
#
define
declare_new
(
ret
.
.
.
)
\
ret
(
*
checked_call
)
(
void
*
int
int
int
int
int
int
int
\
__VA_ARGS__
)
=
\
(
void
*
)
checkasm_checked_call
;
#
define
CLOB
(
UINT64_C
(
0xdeadbeefdeadbeef
)
)
#
define
call_new
(
.
.
.
)
\
(
checkasm_set_signal_handler_state
(
1
)
\
checkasm_stack_clobber
(
CLOB
CLOB
CLOB
CLOB
CLOB
CLOB
\
CLOB
CLOB
CLOB
CLOB
CLOB
CLOB
\
CLOB
CLOB
CLOB
CLOB
CLOB
CLOB
\
CLOB
CLOB
CLOB
CLOB
CLOB
)
\
checked_call
(
func_new
0
0
0
0
0
0
0
__VA_ARGS__
)
)
;
\
checkasm_set_signal_handler_state
(
0
)
#
else
#
define
declare_new
(
ret
.
.
.
)
#
define
call_new
(
.
.
.
)
\
(
checkasm_set_signal_handler_state
(
1
)
\
(
(
func_type
*
)
func_new
)
(
__VA_ARGS__
)
)
;
\
checkasm_set_signal_handler_state
(
0
)
#
endif
#
else
#
define
declare_new
(
ret
.
.
.
)
#
define
call_new
(
.
.
.
)
\
(
checkasm_set_signal_handler_state
(
1
)
\
(
(
func_type
*
)
func_new
)
(
__VA_ARGS__
)
)
;
\
checkasm_set_signal_handler_state
(
0
)
#
endif
#
ifdef
readtime
#
define
bench_new
(
.
.
.
)
\
do
{
\
if
(
checkasm_bench_func
(
)
)
{
\
checkasm_set_signal_handler_state
(
1
)
;
\
func_type
*
tfunc
=
func_new
;
\
uint64_t
tsum
=
0
;
\
int
ti
tcount
=
0
;
\
for
(
ti
=
0
;
ti
<
BENCH_RUNS
;
ti
+
+
)
{
\
uint64_t
t
=
readtime
(
)
;
\
tfunc
(
__VA_ARGS__
)
;
\
tfunc
(
__VA_ARGS__
)
;
\
tfunc
(
__VA_ARGS__
)
;
\
tfunc
(
__VA_ARGS__
)
;
\
t
=
readtime
(
)
-
t
;
\
if
(
t
*
tcount
<
=
tsum
*
4
&
&
ti
>
0
)
{
\
tsum
+
=
t
;
\
tcount
+
+
;
\
}
\
}
\
checkasm_set_signal_handler_state
(
0
)
;
\
checkasm_update_bench
(
tcount
tsum
)
;
\
}
\
}
while
(
0
)
#
else
#
define
bench_new
(
.
.
.
)
do
{
}
while
(
0
)
#
endif
#
define
DECL_CHECKASM_CHECK_FUNC
(
type
)
\
int
checkasm_check_
#
#
type
(
const
char
*
const
file
const
int
line
\
const
type
*
const
buf1
const
ptrdiff_t
stride1
\
const
type
*
const
buf2
const
ptrdiff_t
stride2
\
const
int
w
const
int
h
const
char
*
const
name
)
DECL_CHECKASM_CHECK_FUNC
(
uint8_t
)
;
DECL_CHECKASM_CHECK_FUNC
(
uint16_t
)
;
DECL_CHECKASM_CHECK_FUNC
(
int16_t
)
;
DECL_CHECKASM_CHECK_FUNC
(
int32_t
)
;
#
define
PASTE
(
a
b
)
a
#
#
b
#
define
CONCAT
(
a
b
)
PASTE
(
a
b
)
#
define
checkasm_check
(
prefix
.
.
.
)
CONCAT
(
checkasm_check_
prefix
)
(
__FILE__
__LINE__
__VA_ARGS__
)
#
ifdef
BITDEPTH
#
define
checkasm_check_pixel
(
.
.
.
)
checkasm_check
(
PIXEL_TYPE
__VA_ARGS__
)
#
define
checkasm_check_coef
(
.
.
.
)
checkasm_check
(
COEF_TYPE
__VA_ARGS__
)
#
endif
#
endif
