#
include
<
errno
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
dav1d
/
dav1d
.
h
>
#
include
"
dav1d_fuzzer
.
h
"
static
unsigned
r32le
(
const
uint8_t
*
const
p
)
{
return
(
(
uint32_t
)
p
[
3
]
<
<
24U
)
|
(
p
[
2
]
<
<
16U
)
|
(
p
[
1
]
<
<
8U
)
|
p
[
0
]
;
}
#
define
DAV1D_FUZZ_MAX_SIZE
4096
#
if
defined
(
DAV1D_FUZZ_MAX_SIZE
)
static
int
(
*
default_picture_allocator
)
(
Dav1dPicture
*
void
*
)
;
static
int
fuzz_picture_allocator
(
Dav1dPicture
*
pic
void
*
cookie
)
{
if
(
pic
-
>
p
.
w
>
DAV1D_FUZZ_MAX_SIZE
|
|
pic
-
>
p
.
h
>
DAV1D_FUZZ_MAX_SIZE
)
return
-
EINVAL
;
return
default_picture_allocator
(
pic
cookie
)
;
}
#
endif
int
LLVMFuzzerTestOneInput
(
const
uint8_t
*
data
size_t
size
)
{
Dav1dSettings
settings
=
{
0
}
;
Dav1dContext
*
ctx
=
NULL
;
Dav1dPicture
pic
;
const
uint8_t
*
ptr
=
data
;
int
err
;
dav1d_version
(
)
;
if
(
size
<
32
)
goto
end
;
ptr
+
=
32
;
dav1d_default_settings
(
&
settings
)
;
#
ifdef
DAV1D_MT_FUZZING
settings
.
n_frame_threads
=
settings
.
n_tile_threads
=
2
;
#
else
settings
.
n_frame_threads
=
settings
.
n_tile_threads
=
1
;
#
endif
#
if
defined
(
DAV1D_FUZZ_MAX_SIZE
)
default_picture_allocator
=
settings
.
allocator
.
alloc_picture_callback
;
settings
.
allocator
.
alloc_picture_callback
=
fuzz_picture_allocator
;
#
endif
err
=
dav1d_open
(
&
ctx
&
settings
)
;
if
(
err
<
0
)
goto
end
;
while
(
ptr
<
=
data
+
size
-
12
)
{
Dav1dData
buf
;
uint8_t
*
p
;
size_t
frame_size
=
r32le
(
ptr
)
;
ptr
+
=
12
;
if
(
frame_size
>
size
|
|
ptr
>
data
+
size
-
frame_size
)
break
;
if
(
!
frame_size
)
continue
;
p
=
dav1d_data_create
(
&
buf
frame_size
)
;
if
(
!
p
)
goto
cleanup
;
memcpy
(
p
ptr
frame_size
)
;
ptr
+
=
frame_size
;
do
{
if
(
(
err
=
dav1d_send_data
(
ctx
&
buf
)
)
<
0
)
{
if
(
err
!
=
-
EAGAIN
)
break
;
}
memset
(
&
pic
0
sizeof
(
pic
)
)
;
err
=
dav1d_get_picture
(
ctx
&
pic
)
;
if
(
err
=
=
0
)
{
dav1d_picture_unref
(
&
pic
)
;
}
else
if
(
err
!
=
-
EAGAIN
)
{
break
;
}
}
while
(
buf
.
sz
>
0
)
;
if
(
buf
.
sz
>
0
)
dav1d_data_unref
(
&
buf
)
;
}
do
{
memset
(
&
pic
0
sizeof
(
pic
)
)
;
err
=
dav1d_get_picture
(
ctx
&
pic
)
;
if
(
err
=
=
0
)
dav1d_picture_unref
(
&
pic
)
;
}
while
(
err
!
=
-
EAGAIN
)
;
cleanup
:
dav1d_flush
(
ctx
)
;
dav1d_close
(
&
ctx
)
;
end
:
return
0
;
}
