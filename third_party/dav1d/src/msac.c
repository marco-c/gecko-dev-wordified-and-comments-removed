#
include
"
config
.
h
"
#
include
<
limits
.
h
>
#
include
"
common
/
intops
.
h
"
#
include
"
src
/
msac
.
h
"
#
define
EC_PROB_SHIFT
6
#
define
EC_MIN_PROB
4
/
/
must
be
<
=
(
1
<
<
EC_PROB_SHIFT
)
/
16
#
define
EC_WIN_SIZE
(
sizeof
(
ec_win
)
<
<
3
)
static
inline
void
ctx_refill
(
MsacContext
*
s
)
{
const
uint8_t
*
buf_pos
=
s
-
>
buf_pos
;
const
uint8_t
*
buf_end
=
s
-
>
buf_end
;
int
c
=
EC_WIN_SIZE
-
s
-
>
cnt
-
24
;
ec_win
dif
=
s
-
>
dif
;
while
(
c
>
=
0
&
&
buf_pos
<
buf_end
)
{
dif
^
=
(
(
ec_win
)
*
buf_pos
+
+
)
<
<
c
;
c
-
=
8
;
}
s
-
>
dif
=
dif
;
s
-
>
cnt
=
EC_WIN_SIZE
-
c
-
24
;
s
-
>
buf_pos
=
buf_pos
;
}
static
inline
void
ctx_norm
(
MsacContext
*
s
ec_win
dif
unsigned
rng
)
{
const
int
d
=
15
^
(
31
^
clz
(
rng
)
)
;
assert
(
rng
<
=
65535U
)
;
s
-
>
cnt
-
=
d
;
s
-
>
dif
=
(
(
dif
+
1
)
<
<
d
)
-
1
;
s
-
>
rng
=
rng
<
<
d
;
if
(
s
-
>
cnt
<
0
)
ctx_refill
(
s
)
;
}
unsigned
dav1d_msac_decode_bool_equi_c
(
MsacContext
*
const
s
)
{
ec_win
vw
dif
=
s
-
>
dif
;
unsigned
ret
v
r
=
s
-
>
rng
;
assert
(
(
dif
>
>
(
EC_WIN_SIZE
-
16
)
)
<
r
)
;
v
=
(
(
r
>
>
8
)
<
<
7
)
+
EC_MIN_PROB
;
vw
=
(
ec_win
)
v
<
<
(
EC_WIN_SIZE
-
16
)
;
ret
=
dif
>
=
vw
;
dif
-
=
ret
*
vw
;
v
+
=
ret
*
(
r
-
2
*
v
)
;
ctx_norm
(
s
dif
v
)
;
return
!
ret
;
}
unsigned
dav1d_msac_decode_bool_c
(
MsacContext
*
const
s
const
unsigned
f
)
{
ec_win
vw
dif
=
s
-
>
dif
;
unsigned
ret
v
r
=
s
-
>
rng
;
assert
(
(
dif
>
>
(
EC_WIN_SIZE
-
16
)
)
<
r
)
;
v
=
(
(
r
>
>
8
)
*
(
f
>
>
EC_PROB_SHIFT
)
>
>
(
7
-
EC_PROB_SHIFT
)
)
+
EC_MIN_PROB
;
vw
=
(
ec_win
)
v
<
<
(
EC_WIN_SIZE
-
16
)
;
ret
=
dif
>
=
vw
;
dif
-
=
ret
*
vw
;
v
+
=
ret
*
(
r
-
2
*
v
)
;
ctx_norm
(
s
dif
v
)
;
return
!
ret
;
}
int
dav1d_msac_decode_subexp
(
MsacContext
*
const
s
const
int
ref
const
int
n
const
unsigned
k
)
{
int
i
=
0
;
int
a
=
0
;
int
b
=
k
;
while
(
(
2
<
<
b
)
<
n
)
{
if
(
!
dav1d_msac_decode_bool_equi
(
s
)
)
break
;
b
=
k
+
i
+
+
;
a
=
(
1
<
<
b
)
;
}
const
unsigned
v
=
dav1d_msac_decode_bools
(
s
b
)
+
a
;
return
ref
*
2
<
=
n
?
inv_recenter
(
ref
v
)
:
n
-
1
-
inv_recenter
(
n
-
1
-
ref
v
)
;
}
static
unsigned
decode_symbol
(
MsacContext
*
const
s
const
uint16_t
*
const
cdf
const
size_t
n_symbols
)
{
const
unsigned
c
=
s
-
>
dif
>
>
(
EC_WIN_SIZE
-
16
)
;
unsigned
u
v
=
s
-
>
rng
r
=
s
-
>
rng
>
>
8
ret
=
0
;
assert
(
!
cdf
[
n_symbols
-
1
]
)
;
do
{
u
=
v
;
v
=
r
*
(
cdf
[
ret
+
+
]
>
>
EC_PROB_SHIFT
)
;
v
>
>
=
7
-
EC_PROB_SHIFT
;
v
+
=
EC_MIN_PROB
*
(
int
)
(
n_symbols
-
ret
)
;
}
while
(
c
<
v
)
;
assert
(
u
<
=
s
-
>
rng
)
;
ctx_norm
(
s
s
-
>
dif
-
(
(
ec_win
)
v
<
<
(
EC_WIN_SIZE
-
16
)
)
u
-
v
)
;
return
ret
-
1
;
}
unsigned
dav1d_msac_decode_symbol_adapt_c
(
MsacContext
*
const
s
uint16_t
*
const
cdf
const
size_t
n_symbols
)
{
const
unsigned
val
=
decode_symbol
(
s
cdf
n_symbols
)
;
if
(
s
-
>
allow_update_cdf
)
{
const
unsigned
count
=
cdf
[
n_symbols
]
;
const
int
rate
=
(
(
count
>
>
4
)
|
4
)
+
(
n_symbols
>
3
)
;
unsigned
i
;
for
(
i
=
0
;
i
<
val
;
i
+
+
)
cdf
[
i
]
+
=
(
32768
-
cdf
[
i
]
)
>
>
rate
;
for
(
;
i
<
n_symbols
-
1
;
i
+
+
)
cdf
[
i
]
-
=
cdf
[
i
]
>
>
rate
;
cdf
[
n_symbols
]
=
count
+
(
count
<
32
)
;
}
return
val
;
}
unsigned
dav1d_msac_decode_bool_adapt_c
(
MsacContext
*
const
s
uint16_t
*
const
cdf
)
{
const
unsigned
bit
=
dav1d_msac_decode_bool
(
s
*
cdf
)
;
if
(
s
-
>
allow_update_cdf
)
{
const
unsigned
count
=
cdf
[
1
]
;
const
int
rate
=
(
count
>
>
4
)
|
4
;
if
(
bit
)
cdf
[
0
]
+
=
(
32768
-
cdf
[
0
]
)
>
>
rate
;
else
cdf
[
0
]
-
=
cdf
[
0
]
>
>
rate
;
cdf
[
1
]
=
count
+
(
count
<
32
)
;
}
return
bit
;
}
void
dav1d_msac_init
(
MsacContext
*
const
s
const
uint8_t
*
const
data
const
size_t
sz
const
int
disable_cdf_update_flag
)
{
s
-
>
buf_pos
=
data
;
s
-
>
buf_end
=
data
+
sz
;
s
-
>
dif
=
(
(
ec_win
)
1
<
<
(
EC_WIN_SIZE
-
1
)
)
-
1
;
s
-
>
rng
=
0x8000
;
s
-
>
cnt
=
-
15
;
s
-
>
allow_update_cdf
=
!
disable_cdf_update_flag
;
ctx_refill
(
s
)
;
}
