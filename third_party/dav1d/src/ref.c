#
include
"
config
.
h
"
#
include
"
common
/
mem
.
h
"
#
include
"
src
/
ref
.
h
"
static
void
default_free_callback
(
const
uint8_t
*
const
data
void
*
const
user_data
)
{
assert
(
data
=
=
user_data
)
;
dav1d_free_aligned
(
user_data
)
;
}
Dav1dRef
*
dav1d_ref_create
(
const
size_t
size
)
{
void
*
data
=
dav1d_alloc_aligned
(
size
32
)
;
if
(
!
data
)
return
NULL
;
Dav1dRef
*
const
res
=
dav1d_ref_wrap
(
data
default_free_callback
data
)
;
if
(
res
)
res
-
>
data
=
data
;
else
dav1d_free_aligned
(
data
)
;
return
res
;
}
Dav1dRef
*
dav1d_ref_wrap
(
const
uint8_t
*
const
ptr
void
(
*
free_callback
)
(
const
uint8_t
*
data
void
*
user_data
)
void
*
const
user_data
)
{
Dav1dRef
*
res
=
malloc
(
sizeof
(
Dav1dRef
)
)
;
if
(
!
res
)
return
NULL
;
res
-
>
data
=
NULL
;
res
-
>
const_data
=
ptr
;
atomic_init
(
&
res
-
>
ref_cnt
1
)
;
res
-
>
free_callback
=
free_callback
;
res
-
>
user_data
=
user_data
;
return
res
;
}
void
dav1d_ref_inc
(
Dav1dRef
*
const
ref
)
{
atomic_fetch_add
(
&
ref
-
>
ref_cnt
1
)
;
}
void
dav1d_ref_dec
(
Dav1dRef
*
*
const
pref
)
{
assert
(
pref
!
=
NULL
)
;
Dav1dRef
*
const
ref
=
*
pref
;
if
(
!
ref
)
return
;
if
(
atomic_fetch_sub
(
&
ref
-
>
ref_cnt
1
)
=
=
1
)
{
ref
-
>
free_callback
(
ref
-
>
const_data
ref
-
>
user_data
)
;
free
(
ref
)
;
}
*
pref
=
NULL
;
}
int
dav1d_ref_is_writable
(
Dav1dRef
*
const
ref
)
{
return
atomic_load
(
&
ref
-
>
ref_cnt
)
=
=
1
&
&
ref
-
>
data
;
}
