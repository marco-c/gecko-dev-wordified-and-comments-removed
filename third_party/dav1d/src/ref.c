#
include
"
config
.
h
"
#
include
"
src
/
ref
.
h
"
static
void
default_free_callback
(
const
uint8_t
*
const
data
void
*
const
user_data
)
{
assert
(
data
=
=
user_data
)
;
dav1d_free_aligned
(
user_data
)
;
}
Dav1dRef
*
dav1d_ref_create
(
const
enum
AllocationType
type
size_t
size
)
{
size
=
(
size
+
sizeof
(
void
*
)
-
1
)
&
~
(
sizeof
(
void
*
)
-
1
)
;
uint8_t
*
const
data
=
dav1d_alloc_aligned
(
type
size
+
sizeof
(
Dav1dRef
)
64
)
;
if
(
!
data
)
return
NULL
;
Dav1dRef
*
const
res
=
(
Dav1dRef
*
)
(
data
+
size
)
;
res
-
>
const_data
=
res
-
>
user_data
=
res
-
>
data
=
data
;
atomic_init
(
&
res
-
>
ref_cnt
1
)
;
res
-
>
free_ref
=
0
;
res
-
>
free_callback
=
default_free_callback
;
return
res
;
}
static
void
pool_free_callback
(
const
uint8_t
*
const
data
void
*
const
user_data
)
{
dav1d_mem_pool_push
(
(
Dav1dMemPool
*
)
data
user_data
)
;
}
Dav1dRef
*
dav1d_ref_create_using_pool
(
Dav1dMemPool
*
const
pool
size_t
size
)
{
size
=
(
size
+
sizeof
(
void
*
)
-
1
)
&
~
(
sizeof
(
void
*
)
-
1
)
;
Dav1dMemPoolBuffer
*
const
buf
=
dav1d_mem_pool_pop
(
pool
size
+
sizeof
(
Dav1dRef
)
)
;
if
(
!
buf
)
return
NULL
;
Dav1dRef
*
const
res
=
&
(
(
Dav1dRef
*
)
buf
)
[
-
1
]
;
res
-
>
data
=
buf
-
>
data
;
res
-
>
const_data
=
pool
;
atomic_init
(
&
res
-
>
ref_cnt
1
)
;
res
-
>
free_ref
=
0
;
res
-
>
free_callback
=
pool_free_callback
;
res
-
>
user_data
=
buf
;
return
res
;
}
void
dav1d_ref_dec
(
Dav1dRef
*
*
const
pref
)
{
assert
(
pref
!
=
NULL
)
;
Dav1dRef
*
const
ref
=
*
pref
;
if
(
!
ref
)
return
;
*
pref
=
NULL
;
if
(
atomic_fetch_sub
(
&
ref
-
>
ref_cnt
1
)
=
=
1
)
{
const
int
free_ref
=
ref
-
>
free_ref
;
ref
-
>
free_callback
(
ref
-
>
const_data
ref
-
>
user_data
)
;
if
(
free_ref
)
dav1d_free
(
ref
)
;
}
}
