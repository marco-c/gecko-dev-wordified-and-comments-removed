#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
highway_test
.
cc
"
#
include
"
hwy
/
foreach_target
.
h
"
#
include
"
hwy
/
highway
.
h
"
#
include
"
hwy
/
nanobenchmark
.
h
"
#
include
"
hwy
/
tests
/
test_util
-
inl
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
struct
TestSet
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
auto
v0
=
Zero
(
d
)
;
const
size_t
N
=
Lanes
(
d
)
;
auto
expected
=
AllocateAligned
<
T
>
(
N
)
;
std
:
:
fill
(
expected
.
get
(
)
expected
.
get
(
)
+
N
T
(
0
)
)
;
HWY_ASSERT_VEC_EQ
(
d
expected
.
get
(
)
v0
)
;
const
auto
v2
=
Set
(
d
T
(
2
)
)
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
expected
[
i
]
=
2
;
}
HWY_ASSERT_VEC_EQ
(
d
expected
.
get
(
)
v2
)
;
const
auto
vi
=
Iota
(
d
T
(
5
)
)
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
expected
[
i
]
=
T
(
5
+
i
)
;
}
HWY_ASSERT_VEC_EQ
(
d
expected
.
get
(
)
vi
)
;
const
auto
vu
=
Undefined
(
d
)
;
Store
(
vu
d
expected
.
get
(
)
)
;
}
}
;
HWY_NOINLINE
void
TestAllSet
(
)
{
ForAllTypes
(
ForPartialVectors
<
TestSet
>
(
)
)
;
}
struct
TestOverflow
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
auto
v1
=
Set
(
d
T
(
1
)
)
;
const
auto
vmax
=
Set
(
d
LimitsMax
<
T
>
(
)
)
;
const
auto
vmin
=
Set
(
d
LimitsMin
<
T
>
(
)
)
;
HWY_ASSERT_VEC_EQ
(
d
vmax
vmin
-
v1
)
;
HWY_ASSERT_VEC_EQ
(
d
vmin
vmax
+
v1
)
;
}
}
;
HWY_NOINLINE
void
TestAllOverflow
(
)
{
ForIntegerTypes
(
ForPartialVectors
<
TestOverflow
>
(
)
)
;
}
struct
TestSignBitInteger
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
auto
v0
=
Zero
(
d
)
;
const
auto
all
=
VecFromMask
(
d
Eq
(
v0
v0
)
)
;
const
auto
vs
=
SignBit
(
d
)
;
const
auto
other
=
Sub
(
vs
Set
(
d
1
)
)
;
HWY_ASSERT_VEC_EQ
(
d
v0
Add
(
vs
vs
)
)
;
HWY_ASSERT_VEC_EQ
(
d
all
Add
(
vs
other
)
)
;
}
}
;
struct
TestSignBitFloat
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
auto
v0
=
Zero
(
d
)
;
const
auto
vs
=
SignBit
(
d
)
;
const
auto
vp
=
Set
(
d
2
.
25
)
;
const
auto
vn
=
Set
(
d
-
2
.
25
)
;
HWY_ASSERT_VEC_EQ
(
d
Or
(
vp
vs
)
vn
)
;
HWY_ASSERT_VEC_EQ
(
d
AndNot
(
vs
vn
)
vp
)
;
HWY_ASSERT_VEC_EQ
(
d
v0
vs
)
;
}
}
;
HWY_NOINLINE
void
TestAllSignBit
(
)
{
ForIntegerTypes
(
ForPartialVectors
<
TestSignBitInteger
>
(
)
)
;
ForFloatTypes
(
ForPartialVectors
<
TestSignBitFloat
>
(
)
)
;
}
template
<
typename
TF
>
bool
IsNaN
(
TF
f
)
{
MakeUnsigned
<
TF
>
bits
;
memcpy
(
&
bits
&
f
sizeof
(
TF
)
)
;
bits
+
=
bits
;
bits
>
>
=
1
;
return
bits
>
ExponentMask
<
decltype
(
bits
)
>
(
)
;
}
template
<
class
D
class
V
>
HWY_NOINLINE
void
AssertNaN
(
const
D
d
const
V
v
const
char
*
file
int
line
)
{
using
T
=
TFromD
<
D
>
;
const
T
lane
=
GetLane
(
v
)
;
if
(
!
IsNaN
(
lane
)
)
{
const
std
:
:
string
type_name
=
TypeName
(
T
(
)
Lanes
(
d
)
)
;
MakeUnsigned
<
T
>
bits
;
memcpy
(
&
bits
&
lane
sizeof
(
T
)
)
;
Abort
(
file
line
"
Expected
%
s
NaN
got
%
E
(
%
zu
)
"
type_name
.
c_str
(
)
lane
size_t
(
bits
)
)
;
}
}
#
define
HWY_ASSERT_NAN
(
d
v
)
AssertNaN
(
d
v
__FILE__
__LINE__
)
struct
TestNaN
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
auto
v1
=
Set
(
d
T
(
Unpredictable1
(
)
)
)
;
const
auto
nan
=
IfThenElse
(
Eq
(
v1
Set
(
d
T
(
1
)
)
)
NaN
(
d
)
v1
)
;
HWY_ASSERT_NAN
(
d
nan
)
;
HWY_ASSERT_NAN
(
d
Add
(
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
Add
(
v1
nan
)
)
;
HWY_ASSERT_NAN
(
d
Sub
(
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
Sub
(
v1
nan
)
)
;
HWY_ASSERT_NAN
(
d
Mul
(
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
Mul
(
v1
nan
)
)
;
HWY_ASSERT_NAN
(
d
Div
(
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
Div
(
v1
nan
)
)
;
HWY_ASSERT_NAN
(
d
MulAdd
(
nan
v1
v1
)
)
;
HWY_ASSERT_NAN
(
d
MulAdd
(
v1
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
MulAdd
(
v1
v1
nan
)
)
;
HWY_ASSERT_NAN
(
d
MulSub
(
nan
v1
v1
)
)
;
HWY_ASSERT_NAN
(
d
MulSub
(
v1
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
MulSub
(
v1
v1
nan
)
)
;
HWY_ASSERT_NAN
(
d
NegMulAdd
(
nan
v1
v1
)
)
;
HWY_ASSERT_NAN
(
d
NegMulAdd
(
v1
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
NegMulAdd
(
v1
v1
nan
)
)
;
HWY_ASSERT_NAN
(
d
NegMulSub
(
nan
v1
v1
)
)
;
HWY_ASSERT_NAN
(
d
NegMulSub
(
v1
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
NegMulSub
(
v1
v1
nan
)
)
;
HWY_ASSERT_NAN
(
d
Sqrt
(
nan
)
)
;
HWY_ASSERT_NAN
(
d
Abs
(
nan
)
)
;
HWY_ASSERT_NAN
(
d
Neg
(
nan
)
)
;
HWY_ASSERT_NAN
(
d
CopySign
(
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
CopySignToAbs
(
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
Ceil
(
nan
)
)
;
HWY_ASSERT_NAN
(
d
Floor
(
nan
)
)
;
HWY_ASSERT_NAN
(
d
Round
(
nan
)
)
;
HWY_ASSERT_NAN
(
d
Trunc
(
nan
)
)
;
HWY_ASSERT_NAN
(
d
Or
(
nan
v1
)
)
;
HWY_ASSERT
(
AllFalse
(
Eq
(
nan
v1
)
)
)
;
HWY_ASSERT
(
AllFalse
(
Gt
(
nan
v1
)
)
)
;
HWY_ASSERT
(
AllFalse
(
Lt
(
nan
v1
)
)
)
;
HWY_ASSERT
(
AllFalse
(
Ge
(
nan
v1
)
)
)
;
HWY_ASSERT
(
AllFalse
(
Le
(
nan
v1
)
)
)
;
HWY_ASSERT_NAN
(
d
SumOfLanes
(
nan
)
)
;
#
if
HWY_TARGET
!
=
HWY_RVV
HWY_ASSERT_NAN
(
d
MinOfLanes
(
nan
)
)
;
HWY_ASSERT_NAN
(
d
MaxOfLanes
(
nan
)
)
;
#
endif
#
if
HWY_ARCH_X86
&
&
HWY_TARGET
!
=
HWY_SCALAR
HWY_ASSERT_VEC_EQ
(
d
v1
Min
(
nan
v1
)
)
;
HWY_ASSERT_VEC_EQ
(
d
v1
Max
(
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
Min
(
v1
nan
)
)
;
HWY_ASSERT_NAN
(
d
Max
(
v1
nan
)
)
;
#
elif
HWY_ARCH_WASM
#
elif
HWY_TARGET
=
=
HWY_NEON
&
&
HWY_ARCH_ARM_V7
HWY_ASSERT_NAN
(
d
Min
(
v1
nan
)
)
;
HWY_ASSERT_NAN
(
d
Max
(
v1
nan
)
)
;
HWY_ASSERT_NAN
(
d
Min
(
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
Max
(
nan
v1
)
)
;
#
else
HWY_ASSERT_VEC_EQ
(
d
v1
Min
(
nan
v1
)
)
;
HWY_ASSERT_VEC_EQ
(
d
v1
Max
(
nan
v1
)
)
;
HWY_ASSERT_VEC_EQ
(
d
v1
Min
(
v1
nan
)
)
;
HWY_ASSERT_VEC_EQ
(
d
v1
Max
(
v1
nan
)
)
;
#
endif
HWY_ASSERT_NAN
(
d
Min
(
nan
nan
)
)
;
HWY_ASSERT_NAN
(
d
Max
(
nan
nan
)
)
;
HWY_ASSERT
(
AllFalse
(
Eq
(
nan
v1
)
)
)
;
HWY_ASSERT
(
AllFalse
(
Gt
(
nan
v1
)
)
)
;
HWY_ASSERT
(
AllFalse
(
Lt
(
nan
v1
)
)
)
;
HWY_ASSERT
(
AllFalse
(
Ge
(
nan
v1
)
)
)
;
HWY_ASSERT
(
AllFalse
(
Le
(
nan
v1
)
)
)
;
}
}
;
struct
TestF32NaN
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
auto
v1
=
Set
(
d
T
(
Unpredictable1
(
)
)
)
;
const
auto
nan
=
IfThenElse
(
Eq
(
v1
Set
(
d
T
(
1
)
)
)
NaN
(
d
)
v1
)
;
HWY_ASSERT_NAN
(
d
ApproximateReciprocal
(
nan
)
)
;
HWY_ASSERT_NAN
(
d
ApproximateReciprocalSqrt
(
nan
)
)
;
HWY_ASSERT_NAN
(
d
AbsDiff
(
nan
v1
)
)
;
HWY_ASSERT_NAN
(
d
AbsDiff
(
v1
nan
)
)
;
}
}
;
HWY_NOINLINE
void
TestAllNaN
(
)
{
ForFloatTypes
(
ForPartialVectors
<
TestNaN
>
(
)
)
;
ForPartialVectors
<
TestF32NaN
>
(
)
(
float
(
)
)
;
}
struct
TestCopyAndAssign
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
auto
v3
=
Iota
(
d
3
)
;
auto
v3b
(
v3
)
;
HWY_ASSERT_VEC_EQ
(
d
v3
v3b
)
;
auto
v3c
=
Undefined
(
d
)
;
v3c
=
v3
;
HWY_ASSERT_VEC_EQ
(
d
v3
v3c
)
;
}
}
;
HWY_NOINLINE
void
TestAllCopyAndAssign
(
)
{
ForAllTypes
(
ForPartialVectors
<
TestCopyAndAssign
>
(
)
)
;
}
struct
TestGetLane
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
HWY_ASSERT_EQ
(
T
(
0
)
GetLane
(
Zero
(
d
)
)
)
;
HWY_ASSERT_EQ
(
T
(
1
)
GetLane
(
Set
(
d
1
)
)
)
;
}
}
;
HWY_NOINLINE
void
TestAllGetLane
(
)
{
ForAllTypes
(
ForPartialVectors
<
TestGetLane
>
(
)
)
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
hwy
{
HWY_BEFORE_TEST
(
HighwayTest
)
;
HWY_EXPORT_AND_TEST_P
(
HighwayTest
TestAllSet
)
;
HWY_EXPORT_AND_TEST_P
(
HighwayTest
TestAllOverflow
)
;
HWY_EXPORT_AND_TEST_P
(
HighwayTest
TestAllSignBit
)
;
HWY_EXPORT_AND_TEST_P
(
HighwayTest
TestAllNaN
)
;
HWY_EXPORT_AND_TEST_P
(
HighwayTest
TestAllCopyAndAssign
)
;
HWY_EXPORT_AND_TEST_P
(
HighwayTest
TestAllGetLane
)
;
}
#
endif
