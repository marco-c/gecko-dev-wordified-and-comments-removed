#
include
"
hwy
/
timer
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
chrono
>
#
include
<
ratio
>
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
robust_statistics
.
h
"
#
include
"
hwy
/
timer
-
inl
.
h
"
#
if
HWY_ARCH_X86
&
&
!
HWY_COMPILER_MSVC
#
include
<
cpuid
.
h
>
#
endif
namespace
hwy
{
namespace
timer
=
hwy
:
:
HWY_NAMESPACE
:
:
timer
;
namespace
platform
{
namespace
{
HWY_MAYBE_UNUSED
double
MeasureNominalClockRate
(
)
{
double
max_ticks_per_sec
=
0
.
0
;
for
(
int
rep
=
0
;
rep
<
3
;
+
+
rep
)
{
auto
time0
=
std
:
:
chrono
:
:
steady_clock
:
:
now
(
)
;
using
Time
=
decltype
(
time0
)
;
const
timer
:
:
Ticks
ticks0
=
timer
:
:
Start
(
)
;
const
Time
time_min
=
time0
+
std
:
:
chrono
:
:
milliseconds
(
10
)
;
Time
time1
;
timer
:
:
Ticks
ticks1
;
for
(
;
;
)
{
time1
=
std
:
:
chrono
:
:
steady_clock
:
:
now
(
)
;
ticks1
=
timer
:
:
Start
(
)
;
if
(
time1
>
=
time_min
)
break
;
}
const
double
dticks
=
static_cast
<
double
>
(
ticks1
-
ticks0
)
;
std
:
:
chrono
:
:
duration
<
double
std
:
:
ratio
<
1
>
>
dtime
=
time1
-
time0
;
const
double
ticks_per_sec
=
dticks
/
dtime
.
count
(
)
;
max_ticks_per_sec
=
std
:
:
max
(
max_ticks_per_sec
ticks_per_sec
)
;
}
return
max_ticks_per_sec
;
}
#
if
HWY_ARCH_X86
void
Cpuid
(
const
uint32_t
level
const
uint32_t
count
uint32_t
*
HWY_RESTRICT
abcd
)
{
#
if
HWY_COMPILER_MSVC
int
regs
[
4
]
;
__cpuidex
(
regs
level
count
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
abcd
[
i
]
=
regs
[
i
]
;
}
#
else
uint32_t
a
;
uint32_t
b
;
uint32_t
c
;
uint32_t
d
;
__cpuid_count
(
level
count
a
b
c
d
)
;
abcd
[
0
]
=
a
;
abcd
[
1
]
=
b
;
abcd
[
2
]
=
c
;
abcd
[
3
]
=
d
;
#
endif
}
bool
HasRDTSCP
(
)
{
uint32_t
abcd
[
4
]
;
Cpuid
(
0x80000001U
0
abcd
)
;
return
(
abcd
[
3
]
&
(
1u
<
<
27
)
)
!
=
0
;
}
void
GetBrandString
(
char
*
cpu100
)
{
uint32_t
abcd
[
4
]
;
Cpuid
(
0x80000000U
0
abcd
)
;
if
(
abcd
[
0
]
<
0x80000004U
)
{
cpu100
[
0
]
=
'
\
0
'
;
return
;
}
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
Cpuid
(
static_cast
<
uint32_t
>
(
0x80000002U
+
i
)
0
abcd
)
;
CopyBytes
<
sizeof
(
abcd
)
>
(
&
abcd
[
0
]
cpu100
+
i
*
16
)
;
}
cpu100
[
48
]
=
'
\
0
'
;
}
#
endif
}
HWY_DLLEXPORT
double
Now
(
)
{
static
const
double
mul
=
1
.
0
/
InvariantTicksPerSecond
(
)
;
return
static_cast
<
double
>
(
timer
:
:
Start
(
)
)
*
mul
;
}
HWY_DLLEXPORT
bool
HaveTimerStop
(
char
*
cpu100
)
{
#
if
HWY_ARCH_X86
if
(
!
HasRDTSCP
(
)
)
{
GetBrandString
(
cpu100
)
;
return
false
;
}
#
endif
cpu100
[
0
]
=
'
?
'
;
cpu100
[
1
]
=
'
\
0
'
;
return
true
;
}
HWY_DLLEXPORT
double
InvariantTicksPerSecond
(
)
{
#
if
HWY_ARCH_PPC
&
&
defined
(
__GLIBC__
)
&
&
defined
(
__powerpc64__
)
return
static_cast
<
double
>
(
__ppc_get_timebase_freq
(
)
)
;
#
elif
HWY_ARCH_X86
|
|
HWY_ARCH_RVV
|
|
(
HWY_ARCH_ARM_A64
&
&
!
HWY_COMPILER_MSVC
)
static
const
double
freq
=
MeasureNominalClockRate
(
)
;
return
freq
;
#
elif
defined
(
_WIN32
)
|
|
defined
(
_WIN64
)
LARGE_INTEGER
freq
;
(
void
)
QueryPerformanceFrequency
(
&
freq
)
;
return
static_cast
<
double
>
(
freq
.
QuadPart
)
;
#
elif
defined
(
__APPLE__
)
mach_timebase_info_data_t
timebase
;
(
void
)
mach_timebase_info
(
&
timebase
)
;
return
static_cast
<
double
>
(
timebase
.
denom
)
/
timebase
.
numer
*
1E9
;
#
else
return
1E9
;
#
endif
}
HWY_DLLEXPORT
uint64_t
TimerResolution
(
)
{
char
cpu100
[
100
]
;
bool
can_use_stop
=
HaveTimerStop
(
cpu100
)
;
constexpr
size_t
kTimerSamples
=
256
;
timer
:
:
Ticks
repetitions
[
kTimerSamples
]
;
for
(
size_t
rep
=
0
;
rep
<
kTimerSamples
;
+
+
rep
)
{
timer
:
:
Ticks
samples
[
kTimerSamples
]
;
if
(
can_use_stop
)
{
for
(
size_t
i
=
0
;
i
<
kTimerSamples
;
+
+
i
)
{
const
timer
:
:
Ticks
t0
=
timer
:
:
Start
(
)
;
const
timer
:
:
Ticks
t1
=
timer
:
:
Stop
(
)
;
samples
[
i
]
=
t1
-
t0
;
}
}
else
{
for
(
size_t
i
=
0
;
i
<
kTimerSamples
;
+
+
i
)
{
const
timer
:
:
Ticks
t0
=
timer
:
:
Start
(
)
;
const
timer
:
:
Ticks
t1
=
timer
:
:
Start
(
)
;
samples
[
i
]
=
t1
-
t0
;
}
}
repetitions
[
rep
]
=
robust_statistics
:
:
Mode
(
samples
)
;
}
return
robust_statistics
:
:
Mode
(
repetitions
)
;
}
}
}
