#
include
"
hwy
/
abort
.
h
"
#
include
<
stdarg
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
atomic
>
#
include
<
string
>
#
include
"
hwy
/
base
.
h
"
#
if
HWY_IS_ASAN
|
|
HWY_IS_MSAN
|
|
HWY_IS_TSAN
#
include
"
sanitizer
/
common_interface_defs
.
h
"
#
endif
namespace
hwy
{
namespace
{
std
:
:
atomic
<
WarnFunc
>
&
AtomicWarnFunc
(
)
{
static
std
:
:
atomic
<
WarnFunc
>
func
;
return
func
;
}
std
:
:
atomic
<
AbortFunc
>
&
AtomicAbortFunc
(
)
{
static
std
:
:
atomic
<
AbortFunc
>
func
;
return
func
;
}
std
:
:
string
GetBaseName
(
std
:
:
string
const
&
file_name
)
{
auto
last_slash
=
file_name
.
find_last_of
(
"
/
\
\
"
)
;
return
file_name
.
substr
(
last_slash
+
1
)
;
}
}
HWY_DLLEXPORT
WarnFunc
&
GetWarnFunc
(
)
{
static
WarnFunc
func
;
func
=
AtomicWarnFunc
(
)
.
load
(
)
;
return
func
;
}
HWY_DLLEXPORT
AbortFunc
&
GetAbortFunc
(
)
{
static
AbortFunc
func
;
func
=
AtomicAbortFunc
(
)
.
load
(
)
;
return
func
;
}
HWY_DLLEXPORT
WarnFunc
SetWarnFunc
(
WarnFunc
func
)
{
return
AtomicWarnFunc
(
)
.
exchange
(
func
)
;
}
HWY_DLLEXPORT
AbortFunc
SetAbortFunc
(
AbortFunc
func
)
{
return
AtomicAbortFunc
(
)
.
exchange
(
func
)
;
}
HWY_DLLEXPORT
void
HWY_FORMAT
(
3
4
)
Warn
(
const
char
*
file
int
line
const
char
*
format
.
.
.
)
{
char
buf
[
800
]
;
va_list
args
;
va_start
(
args
format
)
;
vsnprintf
(
buf
sizeof
(
buf
)
format
args
)
;
va_end
(
args
)
;
WarnFunc
handler
=
AtomicWarnFunc
(
)
.
load
(
)
;
if
(
handler
!
=
nullptr
)
{
handler
(
file
line
buf
)
;
}
else
{
fprintf
(
stderr
"
Warn
at
%
s
:
%
d
:
%
s
\
n
"
GetBaseName
(
file
)
.
data
(
)
line
buf
)
;
}
}
HWY_DLLEXPORT
HWY_NORETURN
void
HWY_FORMAT
(
3
4
)
Abort
(
const
char
*
file
int
line
const
char
*
format
.
.
.
)
{
char
buf
[
800
]
;
va_list
args
;
va_start
(
args
format
)
;
vsnprintf
(
buf
sizeof
(
buf
)
format
args
)
;
va_end
(
args
)
;
AbortFunc
handler
=
AtomicAbortFunc
(
)
.
load
(
)
;
if
(
handler
!
=
nullptr
)
{
handler
(
file
line
buf
)
;
}
else
{
fprintf
(
stderr
"
Abort
at
%
s
:
%
d
:
%
s
\
n
"
GetBaseName
(
file
)
.
data
(
)
line
buf
)
;
}
#
if
HWY_IS_ASAN
|
|
HWY_IS_MSAN
|
|
HWY_IS_TSAN
__sanitizer_print_stack_trace
(
)
;
#
endif
fflush
(
stderr
)
;
#
if
HWY_ARCH_RISCV
exit
(
1
)
;
#
elif
HWY_IS_DEBUG_BUILD
&
&
!
HWY_COMPILER_MSVC
&
&
!
HWY_ARCH_ARM
__builtin_trap
(
)
;
#
else
abort
(
)
;
#
endif
}
}
