#
ifndef
HIGHWAY_HWY_BIT_SET_H_
#
define
HIGHWAY_HWY_BIT_SET_H_
#
include
<
stddef
.
h
>
#
include
<
atomic
>
#
include
"
hwy
/
base
.
h
"
namespace
hwy
{
class
BitSet64
{
public
:
constexpr
size_t
MaxSize
(
)
const
{
return
64
;
}
void
Set
(
size_t
i
)
{
HWY_DASSERT
(
i
<
64
)
;
bits_
|
=
(
1ULL
<
<
i
)
;
HWY_DASSERT
(
Get
(
i
)
)
;
}
void
SetNonzeroBitsFrom64
(
uint64_t
bits
)
{
bits_
|
=
bits
;
}
void
Clear
(
size_t
i
)
{
HWY_DASSERT
(
i
<
64
)
;
bits_
&
=
~
(
1ULL
<
<
i
)
;
}
bool
Get
(
size_t
i
)
const
{
HWY_DASSERT
(
i
<
64
)
;
return
(
bits_
&
(
1ULL
<
<
i
)
)
!
=
0
;
}
bool
Any
(
)
const
{
return
bits_
!
=
0
;
}
bool
All
(
)
const
{
return
bits_
=
=
~
uint64_t
{
0
}
;
}
size_t
First
(
)
const
{
HWY_DASSERT
(
Any
(
)
)
;
return
Num0BitsBelowLS1Bit_Nonzero64
(
bits_
)
;
}
size_t
First0
(
)
const
{
HWY_DASSERT
(
!
All
(
)
)
;
return
Num0BitsBelowLS1Bit_Nonzero64
(
~
bits_
)
;
}
uint64_t
Get64
(
)
const
{
return
bits_
;
}
template
<
class
Func
>
void
Foreach
(
const
Func
&
func
)
const
{
uint64_t
remaining_bits
=
bits_
;
while
(
remaining_bits
!
=
0
)
{
const
size_t
i
=
Num0BitsBelowLS1Bit_Nonzero64
(
remaining_bits
)
;
remaining_bits
&
=
remaining_bits
-
1
;
func
(
i
)
;
}
}
size_t
Count
(
)
const
{
return
PopCount
(
bits_
)
;
}
private
:
uint64_t
bits_
=
0
;
}
;
template
<
size_t
kMaxSize
>
class
BitSet
{
static_assert
(
kMaxSize
!
=
0
"
BitSet
requires
non
-
zero
size
"
)
;
public
:
constexpr
size_t
MaxSize
(
)
const
{
return
kMaxSize
;
}
void
Set
(
size_t
i
)
{
HWY_DASSERT
(
i
<
kMaxSize
)
;
const
size_t
idx
=
i
/
64
;
const
size_t
mod
=
i
%
64
;
bits_
[
idx
]
.
Set
(
mod
)
;
}
void
Clear
(
size_t
i
)
{
HWY_DASSERT
(
i
<
kMaxSize
)
;
const
size_t
idx
=
i
/
64
;
const
size_t
mod
=
i
%
64
;
bits_
[
idx
]
.
Clear
(
mod
)
;
HWY_DASSERT
(
!
Get
(
i
)
)
;
}
bool
Get
(
size_t
i
)
const
{
HWY_DASSERT
(
i
<
kMaxSize
)
;
const
size_t
idx
=
i
/
64
;
const
size_t
mod
=
i
%
64
;
return
bits_
[
idx
]
.
Get
(
mod
)
;
}
bool
Any
(
)
const
{
for
(
const
BitSet64
&
bits
:
bits_
)
{
if
(
bits
.
Any
(
)
)
return
true
;
}
return
false
;
}
bool
All
(
)
const
{
for
(
size_t
idx
=
0
;
idx
<
kNum64
-
1
;
+
+
idx
)
{
if
(
!
bits_
[
idx
]
.
All
(
)
)
return
false
;
}
constexpr
size_t
kRemainder
=
kMaxSize
%
64
;
if
(
kRemainder
=
=
0
)
{
return
bits_
[
kNum64
-
1
]
.
All
(
)
;
}
return
bits_
[
kNum64
-
1
]
.
Count
(
)
=
=
kRemainder
;
}
size_t
First
(
)
const
{
HWY_DASSERT
(
Any
(
)
)
;
for
(
size_t
idx
=
0
;
;
+
+
idx
)
{
HWY_DASSERT
(
idx
<
kNum64
)
;
if
(
bits_
[
idx
]
.
Any
(
)
)
return
idx
*
64
+
bits_
[
idx
]
.
First
(
)
;
}
}
size_t
First0
(
)
const
{
HWY_DASSERT
(
!
All
(
)
)
;
for
(
size_t
idx
=
0
;
;
+
+
idx
)
{
HWY_DASSERT
(
idx
<
kNum64
)
;
if
(
!
bits_
[
idx
]
.
All
(
)
)
{
const
size_t
first0
=
idx
*
64
+
bits_
[
idx
]
.
First0
(
)
;
HWY_DASSERT
(
first0
<
kMaxSize
)
;
return
first0
;
}
}
}
template
<
class
Func
>
void
Foreach
(
const
Func
&
func
)
const
{
for
(
size_t
idx
=
0
;
idx
<
kNum64
;
+
+
idx
)
{
bits_
[
idx
]
.
Foreach
(
[
idx
&
func
]
(
size_t
mod
)
{
func
(
idx
*
64
+
mod
)
;
}
)
;
}
}
size_t
Count
(
)
const
{
size_t
total
=
0
;
for
(
const
BitSet64
&
bits
:
bits_
)
{
total
+
=
bits
.
Count
(
)
;
}
return
total
;
}
private
:
static
constexpr
size_t
kNum64
=
DivCeil
(
kMaxSize
size_t
{
64
}
)
;
BitSet64
bits_
[
kNum64
]
;
}
;
template
<
size_t
kMaxSize
>
class
AtomicBitSet
{
static_assert
(
kMaxSize
!
=
0
"
AtomicBitSet
requires
non
-
zero
size
"
)
;
static
constexpr
auto
kAcq
=
std
:
:
memory_order_acquire
;
static
constexpr
auto
kRel
=
std
:
:
memory_order_release
;
public
:
constexpr
size_t
MaxSize
(
)
const
{
return
kMaxSize
;
}
void
Set
(
size_t
i
)
{
HWY_DASSERT
(
i
<
kMaxSize
)
;
const
size_t
idx
=
i
/
64
;
const
size_t
mod
=
i
%
64
;
bits_
[
idx
]
.
fetch_or
(
1ULL
<
<
mod
kRel
)
;
}
void
Clear
(
size_t
i
)
{
HWY_DASSERT
(
i
<
kMaxSize
)
;
const
size_t
idx
=
i
/
64
;
const
size_t
mod
=
i
%
64
;
bits_
[
idx
]
.
fetch_and
(
~
(
1ULL
<
<
mod
)
kRel
)
;
HWY_DASSERT
(
!
Get
(
i
)
)
;
}
bool
Get
(
size_t
i
)
const
{
HWY_DASSERT
(
i
<
kMaxSize
)
;
const
size_t
idx
=
i
/
64
;
const
size_t
mod
=
i
%
64
;
return
(
(
bits_
[
idx
]
.
load
(
kAcq
)
&
(
1ULL
<
<
mod
)
)
)
!
=
0
;
}
bool
Any
(
)
const
{
for
(
const
std
:
:
atomic
<
uint64_t
>
&
bits
:
bits_
)
{
if
(
bits
.
load
(
kAcq
)
)
return
true
;
}
return
false
;
}
bool
All
(
)
const
{
for
(
size_t
idx
=
0
;
idx
<
kNum64
-
1
;
+
+
idx
)
{
if
(
bits_
[
idx
]
.
load
(
kAcq
)
!
=
~
uint64_t
{
0
}
)
return
false
;
}
constexpr
size_t
kRemainder
=
kMaxSize
%
64
;
const
uint64_t
last_bits
=
bits_
[
kNum64
-
1
]
.
load
(
kAcq
)
;
if
(
kRemainder
=
=
0
)
{
return
last_bits
=
=
~
uint64_t
{
0
}
;
}
return
PopCount
(
last_bits
)
=
=
kRemainder
;
}
size_t
First
(
)
const
{
HWY_DASSERT
(
Any
(
)
)
;
for
(
size_t
idx
=
0
;
;
+
+
idx
)
{
HWY_DASSERT
(
idx
<
kNum64
)
;
const
uint64_t
bits
=
bits_
[
idx
]
.
load
(
kAcq
)
;
if
(
bits
!
=
0
)
{
return
idx
*
64
+
Num0BitsBelowLS1Bit_Nonzero64
(
bits
)
;
}
}
}
size_t
First0
(
)
const
{
HWY_DASSERT
(
!
All
(
)
)
;
for
(
size_t
idx
=
0
;
;
+
+
idx
)
{
HWY_DASSERT
(
idx
<
kNum64
)
;
const
uint64_t
inv_bits
=
~
bits_
[
idx
]
.
load
(
kAcq
)
;
if
(
inv_bits
!
=
0
)
{
const
size_t
first0
=
idx
*
64
+
Num0BitsBelowLS1Bit_Nonzero64
(
inv_bits
)
;
HWY_DASSERT
(
first0
<
kMaxSize
)
;
return
first0
;
}
}
}
template
<
class
Func
>
void
Foreach
(
const
Func
&
func
)
const
{
for
(
size_t
idx
=
0
;
idx
<
kNum64
;
+
+
idx
)
{
uint64_t
remaining_bits
=
bits_
[
idx
]
.
load
(
kAcq
)
;
while
(
remaining_bits
!
=
0
)
{
const
size_t
i
=
Num0BitsBelowLS1Bit_Nonzero64
(
remaining_bits
)
;
remaining_bits
&
=
remaining_bits
-
1
;
func
(
idx
*
64
+
i
)
;
}
}
}
size_t
Count
(
)
const
{
size_t
total
=
0
;
for
(
const
std
:
:
atomic
<
uint64_t
>
&
bits
:
bits_
)
{
total
+
=
PopCount
(
bits
.
load
(
kAcq
)
)
;
}
return
total
;
}
private
:
static
constexpr
size_t
kNum64
=
DivCeil
(
kMaxSize
size_t
{
64
}
)
;
std
:
:
atomic
<
uint64_t
>
bits_
[
kNum64
]
=
{
}
;
}
;
template
<
size_t
kMaxSize
=
4096
>
class
BitSet4096
{
static_assert
(
kMaxSize
!
=
0
"
BitSet4096
requires
non
-
zero
size
"
)
;
public
:
constexpr
size_t
MaxSize
(
)
const
{
return
kMaxSize
;
}
void
Set
(
size_t
i
)
{
HWY_DASSERT
(
i
<
kMaxSize
)
;
const
size_t
idx
=
i
/
64
;
const
size_t
mod
=
i
%
64
;
bits_
[
idx
]
.
Set
(
mod
)
;
nonzero_
.
Set
(
idx
)
;
HWY_DASSERT
(
Get
(
i
)
)
;
}
void
SetNonzeroBitsFrom64
(
uint64_t
bits
)
{
bits_
[
0
]
.
SetNonzeroBitsFrom64
(
bits
)
;
if
(
bits
)
nonzero_
.
Set
(
0
)
;
}
void
Clear
(
size_t
i
)
{
HWY_DASSERT
(
i
<
kMaxSize
)
;
const
size_t
idx
=
i
/
64
;
const
size_t
mod
=
i
%
64
;
bits_
[
idx
]
.
Clear
(
mod
)
;
if
(
!
bits_
[
idx
]
.
Any
(
)
)
{
nonzero_
.
Clear
(
idx
)
;
}
HWY_DASSERT
(
!
Get
(
i
)
)
;
}
bool
Get
(
size_t
i
)
const
{
HWY_DASSERT
(
i
<
kMaxSize
)
;
const
size_t
idx
=
i
/
64
;
const
size_t
mod
=
i
%
64
;
return
bits_
[
idx
]
.
Get
(
mod
)
;
}
bool
Any
(
)
const
{
return
nonzero_
.
Any
(
)
;
}
bool
All
(
)
const
{
if
(
nonzero_
.
Count
(
)
!
=
kNum64
)
return
false
;
return
Count
(
)
=
=
kMaxSize
;
}
size_t
First
(
)
const
{
HWY_DASSERT
(
Any
(
)
)
;
const
size_t
idx
=
nonzero_
.
First
(
)
;
return
idx
*
64
+
bits_
[
idx
]
.
First
(
)
;
}
size_t
First0
(
)
const
{
HWY_DASSERT
(
!
All
(
)
)
;
for
(
size_t
idx
=
0
;
;
+
+
idx
)
{
HWY_DASSERT
(
idx
<
kNum64
)
;
if
(
!
bits_
[
idx
]
.
All
(
)
)
{
const
size_t
first0
=
idx
*
64
+
bits_
[
idx
]
.
First0
(
)
;
HWY_DASSERT
(
first0
<
kMaxSize
)
;
return
first0
;
}
}
}
uint64_t
Get64
(
)
const
{
return
bits_
[
0
]
.
Get64
(
)
;
}
template
<
class
Func
>
void
Foreach
(
const
Func
&
func
)
const
{
nonzero_
.
Foreach
(
[
&
func
this
]
(
size_t
idx
)
{
bits_
[
idx
]
.
Foreach
(
[
idx
&
func
]
(
size_t
mod
)
{
func
(
idx
*
64
+
mod
)
;
}
)
;
}
)
;
}
size_t
Count
(
)
const
{
size_t
total
=
0
;
nonzero_
.
Foreach
(
[
&
total
this
]
(
size_t
idx
)
{
total
+
=
bits_
[
idx
]
.
Count
(
)
;
}
)
;
return
total
;
}
private
:
static_assert
(
kMaxSize
<
=
64
*
64
"
One
BitSet64
insufficient
"
)
;
static
constexpr
size_t
kNum64
=
DivCeil
(
kMaxSize
size_t
{
64
}
)
;
BitSet64
nonzero_
;
BitSet64
bits_
[
kNum64
]
;
}
;
}
#
endif
