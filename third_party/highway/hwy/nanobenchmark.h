#
ifndef
HIGHWAY_HWY_NANOBENCHMARK_H_
#
define
HIGHWAY_HWY_NANOBENCHMARK_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
hwy
/
highway_export
.
h
"
#
ifndef
NANOBENCHMARK_ENABLE_CHECKS
#
define
NANOBENCHMARK_ENABLE_CHECKS
0
#
endif
#
define
NANOBENCHMARK_CHECK_ALWAYS
(
condition
)
\
while
(
!
(
condition
)
)
{
\
fprintf
(
stderr
"
Nanobenchmark
check
failed
at
line
%
d
\
n
"
__LINE__
)
;
\
abort
(
)
;
\
}
#
if
NANOBENCHMARK_ENABLE_CHECKS
#
define
NANOBENCHMARK_CHECK
(
condition
)
NANOBENCHMARK_CHECK_ALWAYS
(
condition
)
#
else
#
define
NANOBENCHMARK_CHECK
(
condition
)
#
endif
namespace
hwy
{
namespace
platform
{
HWY_DLLEXPORT
double
InvariantTicksPerSecond
(
)
;
HWY_DLLEXPORT
double
Now
(
)
;
HWY_DLLEXPORT
uint64_t
TimerResolution
(
)
;
}
HWY_DLLEXPORT
int
Unpredictable1
(
)
;
using
FuncInput
=
size_t
;
using
FuncOutput
=
uint64_t
;
using
Func
=
FuncOutput
(
*
)
(
const
void
*
FuncInput
)
;
struct
Params
{
static
constexpr
size_t
kTimerSamples
=
256
;
size_t
precision_divisor
=
1024
;
size_t
subset_ratio
=
2
;
double
seconds_per_eval
=
4E
-
3
;
size_t
min_samples_per_eval
=
7
;
size_t
min_mode_samples
=
64
;
double
target_rel_mad
=
0
.
002
;
size_t
max_evals
=
9
;
bool
verbose
=
true
;
}
;
struct
Result
{
FuncInput
input
;
float
ticks
;
float
variability
;
}
;
HWY_DLLEXPORT
size_t
Measure
(
Func
func
const
uint8_t
*
arg
const
FuncInput
*
inputs
size_t
num_inputs
Result
*
results
const
Params
&
p
=
Params
(
)
)
;
template
<
class
Closure
>
static
FuncOutput
CallClosure
(
const
Closure
*
f
const
FuncInput
input
)
{
return
(
*
f
)
(
input
)
;
}
template
<
class
Closure
>
static
inline
size_t
MeasureClosure
(
const
Closure
&
closure
const
FuncInput
*
inputs
const
size_t
num_inputs
Result
*
results
const
Params
&
p
=
Params
(
)
)
{
return
Measure
(
reinterpret_cast
<
Func
>
(
&
CallClosure
<
Closure
>
)
reinterpret_cast
<
const
uint8_t
*
>
(
&
closure
)
inputs
num_inputs
results
p
)
;
}
}
#
endif
