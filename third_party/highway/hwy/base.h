#
ifndef
HIGHWAY_HWY_BASE_H_
#
define
HIGHWAY_HWY_BASE_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
atomic
>
#
include
<
cfloat
>
#
if
(
defined
__CDT_PARSER__
)
|
|
(
defined
__INTELLISENSE__
)
|
|
\
(
defined
Q_CREATOR_RUN
)
|
|
(
defined
(
__CLANGD__
)
)
#
define
HWY_IDE
1
#
else
#
define
HWY_IDE
0
#
endif
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
#
define
HWY_COMPILER_MSVC
_MSC_VER
#
else
#
define
HWY_COMPILER_MSVC
0
#
endif
#
ifdef
__INTEL_COMPILER
#
define
HWY_COMPILER_ICC
__INTEL_COMPILER
#
else
#
define
HWY_COMPILER_ICC
0
#
endif
#
ifdef
__GNUC__
#
define
HWY_COMPILER_GCC
(
__GNUC__
*
100
+
__GNUC_MINOR__
)
#
else
#
define
HWY_COMPILER_GCC
0
#
endif
#
ifdef
__clang__
#
ifdef
__APPLE__
#
if
__has_warning
(
"
-
Wformat
-
insufficient
-
args
"
)
#
define
HWY_COMPILER_CLANG
1200
#
elif
__has_warning
(
"
-
Wimplicit
-
const
-
int
-
float
-
conversion
"
)
#
define
HWY_COMPILER_CLANG
1100
#
elif
__has_warning
(
"
-
Wmisleading
-
indentation
"
)
#
define
HWY_COMPILER_CLANG
1000
#
elif
defined
(
__FILE_NAME__
)
#
define
HWY_COMPILER_CLANG
900
#
elif
__has_warning
(
"
-
Wextra
-
semi
-
stmt
"
)
|
|
\
__has_builtin
(
__builtin_rotateleft32
)
#
define
HWY_COMPILER_CLANG
800
#
elif
__has_warning
(
"
-
Wc
+
+
98
-
compat
-
extra
-
semi
"
)
#
define
HWY_COMPILER_CLANG
700
#
else
#
define
HWY_COMPILER_CLANG
600
#
endif
#
else
#
define
HWY_COMPILER_CLANG
(
__clang_major__
*
100
+
__clang_minor__
)
#
endif
#
else
#
define
HWY_COMPILER_CLANG
0
#
endif
#
if
!
HWY_COMPILER_MSVC
&
&
!
HWY_COMPILER_ICC
&
&
!
HWY_COMPILER_GCC
&
&
\
!
HWY_COMPILER_CLANG
#
error
"
Unsupported
compiler
"
#
endif
#
define
HWY_STR_IMPL
(
macro
)
#
macro
#
define
HWY_STR
(
macro
)
HWY_STR_IMPL
(
macro
)
#
if
HWY_COMPILER_MSVC
#
include
<
intrin
.
h
>
#
define
HWY_RESTRICT
__restrict
#
define
HWY_INLINE
__forceinline
#
define
HWY_NOINLINE
__declspec
(
noinline
)
#
define
HWY_FLATTEN
#
define
HWY_NORETURN
__declspec
(
noreturn
)
#
define
HWY_LIKELY
(
expr
)
(
expr
)
#
define
HWY_UNLIKELY
(
expr
)
(
expr
)
#
define
HWY_PRAGMA
(
tokens
)
__pragma
(
tokens
)
#
define
HWY_DIAGNOSTICS
(
tokens
)
HWY_PRAGMA
(
warning
(
tokens
)
)
#
define
HWY_DIAGNOSTICS_OFF
(
msc
gcc
)
HWY_DIAGNOSTICS
(
msc
)
#
define
HWY_MAYBE_UNUSED
#
define
HWY_HAS_ASSUME_ALIGNED
0
#
if
(
_MSC_VER
>
=
1700
)
#
define
HWY_MUST_USE_RESULT
_Check_return_
#
else
#
define
HWY_MUST_USE_RESULT
#
endif
#
else
#
define
HWY_RESTRICT
__restrict__
#
define
HWY_INLINE
inline
__attribute__
(
(
always_inline
)
)
#
define
HWY_NOINLINE
__attribute__
(
(
noinline
)
)
#
define
HWY_FLATTEN
__attribute__
(
(
flatten
)
)
#
define
HWY_NORETURN
__attribute__
(
(
noreturn
)
)
#
define
HWY_LIKELY
(
expr
)
__builtin_expect
(
!
!
(
expr
)
1
)
#
define
HWY_UNLIKELY
(
expr
)
__builtin_expect
(
!
!
(
expr
)
0
)
#
define
HWY_PRAGMA
(
tokens
)
_Pragma
(
#
tokens
)
#
define
HWY_DIAGNOSTICS
(
tokens
)
HWY_PRAGMA
(
GCC
diagnostic
tokens
)
#
define
HWY_DIAGNOSTICS_OFF
(
msc
gcc
)
HWY_DIAGNOSTICS
(
gcc
)
#
define
HWY_MAYBE_UNUSED
__attribute__
(
(
unused
)
)
#
define
HWY_MUST_USE_RESULT
__attribute__
(
(
warn_unused_result
)
)
#
endif
#
ifdef
__has_builtin
#
define
HWY_HAS_BUILTIN
(
name
)
__has_builtin
(
name
)
#
else
#
define
HWY_HAS_BUILTIN
(
name
)
0
#
endif
#
ifdef
__has_attribute
#
define
HWY_HAS_ATTRIBUTE
(
name
)
__has_attribute
(
name
)
#
else
#
define
HWY_HAS_ATTRIBUTE
(
name
)
0
#
endif
#
if
HWY_HAS_ATTRIBUTE
(
__format__
)
#
define
HWY_FORMAT
(
idx_fmt
idx_arg
)
\
__attribute__
(
(
__format__
(
__printf__
idx_fmt
idx_arg
)
)
)
#
else
#
define
HWY_FORMAT
(
idx_fmt
idx_arg
)
#
endif
#
if
HWY_HAS_BUILTIN
(
__builtin_assume_aligned
)
#
define
HWY_ASSUME_ALIGNED
(
ptr
align
)
__builtin_assume_aligned
(
(
ptr
)
(
align
)
)
#
else
#
define
HWY_ASSUME_ALIGNED
(
ptr
align
)
(
ptr
)
/
*
not
supported
*
/
#
endif
#
if
HWY_COMPILER_CLANG
#
define
HWY_PUSH_ATTRIBUTES
(
targets_str
)
\
HWY_PRAGMA
(
clang
attribute
push
(
__attribute__
(
(
target
(
targets_str
)
)
)
\
apply_to
=
function
)
)
#
define
HWY_POP_ATTRIBUTES
HWY_PRAGMA
(
clang
attribute
pop
)
#
elif
HWY_COMPILER_GCC
#
define
HWY_PUSH_ATTRIBUTES
(
targets_str
)
\
HWY_PRAGMA
(
GCC
push_options
)
HWY_PRAGMA
(
GCC
target
targets_str
)
#
define
HWY_POP_ATTRIBUTES
HWY_PRAGMA
(
GCC
pop_options
)
#
else
#
define
HWY_PUSH_ATTRIBUTES
(
targets_str
)
#
define
HWY_POP_ATTRIBUTES
#
endif
#
if
defined
(
__i386__
)
|
|
defined
(
_M_IX86
)
#
define
HWY_ARCH_X86_32
1
#
else
#
define
HWY_ARCH_X86_32
0
#
endif
#
if
defined
(
__x86_64__
)
|
|
defined
(
_M_X64
)
#
define
HWY_ARCH_X86_64
1
#
else
#
define
HWY_ARCH_X86_64
0
#
endif
#
if
HWY_ARCH_X86_32
&
&
HWY_ARCH_X86_64
#
error
"
Cannot
have
both
x86
-
32
and
x86
-
64
"
#
endif
#
if
HWY_ARCH_X86_32
|
|
HWY_ARCH_X86_64
#
define
HWY_ARCH_X86
1
#
else
#
define
HWY_ARCH_X86
0
#
endif
#
if
defined
(
__powerpc64__
)
|
|
defined
(
_M_PPC
)
#
define
HWY_ARCH_PPC
1
#
else
#
define
HWY_ARCH_PPC
0
#
endif
#
if
defined
(
__ARM_ARCH_ISA_A64
)
|
|
defined
(
__aarch64__
)
|
|
defined
(
_M_ARM64
)
#
define
HWY_ARCH_ARM_A64
1
#
else
#
define
HWY_ARCH_ARM_A64
0
#
endif
#
if
defined
(
__arm__
)
|
|
defined
(
_M_ARM
)
#
define
HWY_ARCH_ARM_V7
1
#
else
#
define
HWY_ARCH_ARM_V7
0
#
endif
#
if
HWY_ARCH_ARM_A64
&
&
HWY_ARCH_ARM_V7
#
error
"
Cannot
have
both
A64
and
V7
"
#
endif
#
if
HWY_ARCH_ARM_A64
|
|
HWY_ARCH_ARM_V7
#
define
HWY_ARCH_ARM
1
#
else
#
define
HWY_ARCH_ARM
0
#
endif
#
if
defined
(
__EMSCRIPTEN__
)
|
|
defined
(
__wasm__
)
|
|
defined
(
__WASM__
)
#
define
HWY_ARCH_WASM
1
#
else
#
define
HWY_ARCH_WASM
0
#
endif
#
ifdef
__riscv
#
define
HWY_ARCH_RVV
1
#
else
#
define
HWY_ARCH_RVV
0
#
endif
#
if
(
HWY_ARCH_X86
+
HWY_ARCH_PPC
+
HWY_ARCH_ARM
+
HWY_ARCH_WASM
+
\
HWY_ARCH_RVV
)
>
1
#
error
"
Must
not
detect
more
than
one
architecture
"
#
endif
#
define
HWY_API
static
HWY_INLINE
HWY_FLATTEN
HWY_MAYBE_UNUSED
#
define
HWY_CONCAT_IMPL
(
a
b
)
a
#
#
b
#
define
HWY_CONCAT
(
a
b
)
HWY_CONCAT_IMPL
(
a
b
)
#
define
HWY_MIN
(
a
b
)
(
(
a
)
<
(
b
)
?
(
a
)
:
(
b
)
)
#
define
HWY_MAX
(
a
b
)
(
(
a
)
>
(
b
)
?
(
a
)
:
(
b
)
)
#
if
HWY_ARCH_X86
#
define
HWY_FENCE
std
:
:
atomic_thread_fence
(
std
:
:
memory_order_acq_rel
)
#
else
#
define
HWY_FENCE
#
endif
#
define
HWY_REP4
(
literal
)
literal
literal
literal
literal
#
define
HWY_ABORT
(
format
.
.
.
)
\
:
:
hwy
:
:
Abort
(
__FILE__
__LINE__
format
#
#
__VA_ARGS__
)
#
define
HWY_ASSERT
(
condition
)
\
do
{
\
if
(
!
(
condition
)
)
{
\
HWY_ABORT
(
"
Assert
%
s
"
#
condition
)
;
\
}
\
}
while
(
0
)
#
if
!
defined
(
NDEBUG
)
|
|
defined
(
ADDRESS_SANITIZER
)
|
|
\
defined
(
MEMORY_SANITIZER
)
|
|
defined
(
THREAD_SANITIZER
)
#
define
HWY_DASSERT
(
condition
)
HWY_ASSERT
(
condition
)
#
else
#
define
HWY_DASSERT
(
condition
)
\
do
{
\
}
while
(
0
)
#
endif
namespace
hwy
{
#
if
HWY_ARCH_X86
static
constexpr
HWY_MAYBE_UNUSED
size_t
kMaxVectorSize
=
64
;
#
define
HWY_ALIGN_MAX
alignas
(
64
)
#
elif
HWY_ARCH_RVV
static
constexpr
HWY_MAYBE_UNUSED
size_t
kMaxVectorSize
=
4096
;
#
define
HWY_ALIGN_MAX
alignas
(
8
)
/
/
only
elements
need
be
aligned
#
else
static
constexpr
HWY_MAYBE_UNUSED
size_t
kMaxVectorSize
=
16
;
#
define
HWY_ALIGN_MAX
alignas
(
16
)
#
endif
#
if
HWY_ARCH_RVV
&
&
HWY_COMPILER_GCC
#
define
HWY_NATIVE_FLOAT16
1
#
else
#
define
HWY_NATIVE_FLOAT16
0
#
endif
#
if
HWY_NATIVE_FLOAT16
using
float16_t
=
__fp16
;
#
else
#
pragma
pack
(
push
1
)
struct
float16_t
{
uint16_t
bits
;
}
;
#
pragma
pack
(
pop
)
#
endif
using
float32_t
=
float
;
using
float64_t
=
double
;
template
<
bool
Condition
class
T
>
struct
EnableIfT
{
}
;
template
<
class
T
>
struct
EnableIfT
<
true
T
>
{
using
type
=
T
;
}
;
template
<
bool
Condition
class
T
=
void
>
using
EnableIf
=
typename
EnableIfT
<
Condition
T
>
:
:
type
;
#
define
HWY_IF_LE128
(
T
N
)
hwy
:
:
EnableIf
<
N
*
sizeof
(
T
)
<
=
16
>
*
=
nullptr
#
define
HWY_IF_LE64
(
T
N
)
hwy
:
:
EnableIf
<
N
*
sizeof
(
T
)
<
=
8
>
*
=
nullptr
#
define
HWY_IF_LE32
(
T
N
)
hwy
:
:
EnableIf
<
N
*
sizeof
(
T
)
<
=
4
>
*
=
nullptr
#
define
HWY_IF_UNSIGNED
(
T
)
hwy
:
:
EnableIf
<
!
IsSigned
<
T
>
(
)
>
*
=
nullptr
#
define
HWY_IF_SIGNED
(
T
)
\
hwy
:
:
EnableIf
<
IsSigned
<
T
>
(
)
&
&
!
IsFloat
<
T
>
(
)
>
*
=
nullptr
#
define
HWY_IF_FLOAT
(
T
)
hwy
:
:
EnableIf
<
hwy
:
:
IsFloat
<
T
>
(
)
>
*
=
nullptr
#
define
HWY_IF_NOT_FLOAT
(
T
)
hwy
:
:
EnableIf
<
!
hwy
:
:
IsFloat
<
T
>
(
)
>
*
=
nullptr
#
define
HWY_IF_LANE_SIZE
(
T
bytes
)
\
hwy
:
:
EnableIf
<
sizeof
(
T
)
=
=
(
bytes
)
>
*
=
nullptr
#
define
HWY_IF_NOT_LANE_SIZE
(
T
bytes
)
\
hwy
:
:
EnableIf
<
sizeof
(
T
)
!
=
(
bytes
)
>
*
=
nullptr
template
<
size_t
N
>
struct
SizeTag
{
}
;
template
<
typename
T
>
constexpr
bool
IsFloat
(
)
{
return
T
(
1
.
25
)
!
=
T
(
1
)
;
}
template
<
typename
T
>
constexpr
bool
IsSigned
(
)
{
return
T
(
0
)
>
T
(
-
1
)
;
}
template
<
typename
T
>
constexpr
T
LimitsMax
(
)
{
static_assert
(
!
IsFloat
<
T
>
(
)
"
Only
for
integer
types
"
)
;
return
IsSigned
<
T
>
(
)
?
T
(
(
1ULL
<
<
(
sizeof
(
T
)
*
8
-
1
)
)
-
1
)
:
static_cast
<
T
>
(
~
0ull
)
;
}
template
<
typename
T
>
constexpr
T
LimitsMin
(
)
{
static_assert
(
!
IsFloat
<
T
>
(
)
"
Only
for
integer
types
"
)
;
return
IsSigned
<
T
>
(
)
?
T
(
-
1
)
-
LimitsMax
<
T
>
(
)
:
T
(
0
)
;
}
template
<
typename
T
>
constexpr
T
LowestValue
(
)
{
return
LimitsMin
<
T
>
(
)
;
}
template
<
>
constexpr
float
LowestValue
<
float
>
(
)
{
return
-
FLT_MAX
;
}
template
<
>
constexpr
double
LowestValue
<
double
>
(
)
{
return
-
DBL_MAX
;
}
template
<
typename
T
>
constexpr
T
HighestValue
(
)
{
return
LimitsMax
<
T
>
(
)
;
}
template
<
>
constexpr
float
HighestValue
<
float
>
(
)
{
return
FLT_MAX
;
}
template
<
>
constexpr
double
HighestValue
<
double
>
(
)
{
return
DBL_MAX
;
}
template
<
typename
T
>
constexpr
T
ExponentMask
(
)
{
static_assert
(
sizeof
(
T
)
=
=
0
"
Only
instantiate
the
specializations
"
)
;
return
0
;
}
template
<
>
constexpr
uint32_t
ExponentMask
<
uint32_t
>
(
)
{
return
0x7F800000
;
}
template
<
>
constexpr
uint64_t
ExponentMask
<
uint64_t
>
(
)
{
return
0x7FF0000000000000ULL
;
}
template
<
typename
T
>
constexpr
T
MantissaEnd
(
)
{
static_assert
(
sizeof
(
T
)
=
=
0
"
Only
instantiate
the
specializations
"
)
;
return
0
;
}
template
<
>
constexpr
float
MantissaEnd
<
float
>
(
)
{
return
8388608
.
0f
;
}
template
<
>
constexpr
double
MantissaEnd
<
double
>
(
)
{
return
4503599627370496
.
0
;
}
namespace
detail
{
template
<
typename
T
>
struct
Relations
;
template
<
>
struct
Relations
<
uint8_t
>
{
using
Unsigned
=
uint8_t
;
using
Signed
=
int8_t
;
using
Wide
=
uint16_t
;
}
;
template
<
>
struct
Relations
<
int8_t
>
{
using
Unsigned
=
uint8_t
;
using
Signed
=
int8_t
;
using
Wide
=
int16_t
;
}
;
template
<
>
struct
Relations
<
uint16_t
>
{
using
Unsigned
=
uint16_t
;
using
Signed
=
int16_t
;
using
Wide
=
uint32_t
;
using
Narrow
=
uint8_t
;
}
;
template
<
>
struct
Relations
<
int16_t
>
{
using
Unsigned
=
uint16_t
;
using
Signed
=
int16_t
;
using
Wide
=
int32_t
;
using
Narrow
=
int8_t
;
}
;
template
<
>
struct
Relations
<
uint32_t
>
{
using
Unsigned
=
uint32_t
;
using
Signed
=
int32_t
;
using
Float
=
float
;
using
Wide
=
uint64_t
;
using
Narrow
=
uint16_t
;
}
;
template
<
>
struct
Relations
<
int32_t
>
{
using
Unsigned
=
uint32_t
;
using
Signed
=
int32_t
;
using
Float
=
float
;
using
Wide
=
int64_t
;
using
Narrow
=
int16_t
;
}
;
template
<
>
struct
Relations
<
uint64_t
>
{
using
Unsigned
=
uint64_t
;
using
Signed
=
int64_t
;
using
Float
=
double
;
using
Narrow
=
uint32_t
;
}
;
template
<
>
struct
Relations
<
int64_t
>
{
using
Unsigned
=
uint64_t
;
using
Signed
=
int64_t
;
using
Float
=
double
;
using
Narrow
=
int32_t
;
}
;
template
<
>
struct
Relations
<
float16_t
>
{
using
Unsigned
=
uint16_t
;
using
Signed
=
int16_t
;
using
Float
=
float16_t
;
using
Wide
=
float
;
}
;
template
<
>
struct
Relations
<
float
>
{
using
Unsigned
=
uint32_t
;
using
Signed
=
int32_t
;
using
Float
=
float
;
using
Wide
=
double
;
}
;
template
<
>
struct
Relations
<
double
>
{
using
Unsigned
=
uint64_t
;
using
Signed
=
int64_t
;
using
Float
=
double
;
using
Narrow
=
float
;
}
;
}
template
<
typename
T
>
using
MakeUnsigned
=
typename
detail
:
:
Relations
<
T
>
:
:
Unsigned
;
template
<
typename
T
>
using
MakeSigned
=
typename
detail
:
:
Relations
<
T
>
:
:
Signed
;
template
<
typename
T
>
using
MakeFloat
=
typename
detail
:
:
Relations
<
T
>
:
:
Float
;
template
<
typename
T
>
using
MakeWide
=
typename
detail
:
:
Relations
<
T
>
:
:
Wide
;
template
<
typename
T
>
using
MakeNarrow
=
typename
detail
:
:
Relations
<
T
>
:
:
Narrow
;
template
<
typename
T1
typename
T2
>
constexpr
inline
T1
DivCeil
(
T1
a
T2
b
)
{
return
(
a
+
b
-
1
)
/
b
;
}
constexpr
inline
size_t
RoundUpTo
(
size_t
what
size_t
align
)
{
return
DivCeil
(
what
align
)
*
align
;
}
HWY_API
size_t
Num0BitsBelowLS1Bit_Nonzero32
(
const
uint32_t
x
)
{
#
if
HWY_COMPILER_MSVC
unsigned
long
index
;
_BitScanForward
(
&
index
x
)
;
return
index
;
#
else
return
static_cast
<
size_t
>
(
__builtin_ctz
(
x
)
)
;
#
endif
}
HWY_API
size_t
PopCount
(
uint64_t
x
)
{
#
if
HWY_COMPILER_CLANG
|
|
HWY_COMPILER_GCC
return
static_cast
<
size_t
>
(
__builtin_popcountll
(
x
)
)
;
#
elif
HWY_COMPILER_MSVC
&
&
HWY_ARCH_X86_64
return
_mm_popcnt_u64
(
x
)
;
#
elif
HWY_COMPILER_MSVC
&
&
HWY_ARCH_X86_32
return
_mm_popcnt_u32
(
uint32_t
(
x
)
)
+
_mm_popcnt_u32
(
uint32_t
(
x
>
>
32
)
)
;
#
else
x
-
=
(
(
x
>
>
1
)
&
0x55555555U
)
;
x
=
(
(
(
x
>
>
2
)
&
0x33333333U
)
+
(
x
&
0x33333333U
)
)
;
x
=
(
(
(
x
>
>
4
)
+
x
)
&
0x0F0F0F0FU
)
;
x
+
=
(
x
>
>
8
)
;
x
+
=
(
x
>
>
16
)
;
x
+
=
(
x
>
>
32
)
;
x
=
x
&
0x0000007FU
;
return
(
unsigned
int
)
x
;
#
endif
}
template
<
size_t
kBytes
typename
From
typename
To
>
HWY_API
void
CopyBytes
(
const
From
*
from
To
*
to
)
{
#
if
HWY_COMPILER_MSVC
const
uint8_t
*
HWY_RESTRICT
from_bytes
=
reinterpret_cast
<
const
uint8_t
*
>
(
from
)
;
uint8_t
*
HWY_RESTRICT
to_bytes
=
reinterpret_cast
<
uint8_t
*
>
(
to
)
;
for
(
size_t
i
=
0
;
i
<
kBytes
;
+
+
i
)
{
to_bytes
[
i
]
=
from_bytes
[
i
]
;
}
#
else
__builtin_memcpy
(
to
from
kBytes
)
;
#
endif
}
HWY_NORETURN
void
HWY_FORMAT
(
3
4
)
Abort
(
const
char
*
file
int
line
const
char
*
format
.
.
.
)
;
}
#
endif
