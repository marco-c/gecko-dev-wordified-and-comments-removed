#
ifndef
HIGHWAY_HWY_BASE_H_
#
define
HIGHWAY_HWY_BASE_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
hwy
/
detect_compiler_arch
.
h
"
#
include
"
hwy
/
highway_export
.
h
"
#
if
HWY_ARCH_X86
#
include
<
atomic
>
#
endif
#
define
HWY_STR_IMPL
(
macro
)
#
macro
#
define
HWY_STR
(
macro
)
HWY_STR_IMPL
(
macro
)
#
if
HWY_COMPILER_MSVC
#
include
<
intrin
.
h
>
#
define
HWY_RESTRICT
__restrict
#
define
HWY_INLINE
__forceinline
#
define
HWY_NOINLINE
__declspec
(
noinline
)
#
define
HWY_FLATTEN
#
define
HWY_NORETURN
__declspec
(
noreturn
)
#
define
HWY_LIKELY
(
expr
)
(
expr
)
#
define
HWY_UNLIKELY
(
expr
)
(
expr
)
#
define
HWY_PRAGMA
(
tokens
)
__pragma
(
tokens
)
#
define
HWY_DIAGNOSTICS
(
tokens
)
HWY_PRAGMA
(
warning
(
tokens
)
)
#
define
HWY_DIAGNOSTICS_OFF
(
msc
gcc
)
HWY_DIAGNOSTICS
(
msc
)
#
define
HWY_MAYBE_UNUSED
#
define
HWY_HAS_ASSUME_ALIGNED
0
#
if
(
_MSC_VER
>
=
1700
)
#
define
HWY_MUST_USE_RESULT
_Check_return_
#
else
#
define
HWY_MUST_USE_RESULT
#
endif
#
else
#
define
HWY_RESTRICT
__restrict__
#
ifdef
__OPTIMIZE__
#
define
HWY_INLINE
inline
__attribute__
(
(
always_inline
)
)
#
else
#
define
HWY_INLINE
inline
#
endif
#
define
HWY_NOINLINE
__attribute__
(
(
noinline
)
)
#
define
HWY_FLATTEN
__attribute__
(
(
flatten
)
)
#
define
HWY_NORETURN
__attribute__
(
(
noreturn
)
)
#
define
HWY_LIKELY
(
expr
)
__builtin_expect
(
!
!
(
expr
)
1
)
#
define
HWY_UNLIKELY
(
expr
)
__builtin_expect
(
!
!
(
expr
)
0
)
#
define
HWY_PRAGMA
(
tokens
)
_Pragma
(
#
tokens
)
#
define
HWY_DIAGNOSTICS
(
tokens
)
HWY_PRAGMA
(
GCC
diagnostic
tokens
)
#
define
HWY_DIAGNOSTICS_OFF
(
msc
gcc
)
HWY_DIAGNOSTICS
(
gcc
)
#
define
HWY_MAYBE_UNUSED
__attribute__
(
(
unused
)
)
#
define
HWY_MUST_USE_RESULT
__attribute__
(
(
warn_unused_result
)
)
#
endif
#
if
HWY_HAS_ATTRIBUTE
(
__format__
)
#
define
HWY_FORMAT
(
idx_fmt
idx_arg
)
\
__attribute__
(
(
__format__
(
__printf__
idx_fmt
idx_arg
)
)
)
#
else
#
define
HWY_FORMAT
(
idx_fmt
idx_arg
)
#
endif
#
if
HWY_HAS_BUILTIN
(
__builtin_assume_aligned
)
#
define
HWY_ASSUME_ALIGNED
(
ptr
align
)
__builtin_assume_aligned
(
(
ptr
)
(
align
)
)
#
else
#
define
HWY_ASSUME_ALIGNED
(
ptr
align
)
(
ptr
)
/
*
not
supported
*
/
#
endif
#
if
HWY_COMPILER_CLANG
#
define
HWY_PUSH_ATTRIBUTES
(
targets_str
)
\
HWY_PRAGMA
(
clang
attribute
push
(
__attribute__
(
(
target
(
targets_str
)
)
)
\
apply_to
=
function
)
)
#
define
HWY_POP_ATTRIBUTES
HWY_PRAGMA
(
clang
attribute
pop
)
#
elif
HWY_COMPILER_GCC
#
define
HWY_PUSH_ATTRIBUTES
(
targets_str
)
\
HWY_PRAGMA
(
GCC
push_options
)
HWY_PRAGMA
(
GCC
target
targets_str
)
#
define
HWY_POP_ATTRIBUTES
HWY_PRAGMA
(
GCC
pop_options
)
#
else
#
define
HWY_PUSH_ATTRIBUTES
(
targets_str
)
#
define
HWY_POP_ATTRIBUTES
#
endif
#
define
HWY_API
static
HWY_INLINE
HWY_FLATTEN
HWY_MAYBE_UNUSED
#
define
HWY_CONCAT_IMPL
(
a
b
)
a
#
#
b
#
define
HWY_CONCAT
(
a
b
)
HWY_CONCAT_IMPL
(
a
b
)
#
define
HWY_MIN
(
a
b
)
(
(
a
)
<
(
b
)
?
(
a
)
:
(
b
)
)
#
define
HWY_MAX
(
a
b
)
(
(
a
)
>
(
b
)
?
(
a
)
:
(
b
)
)
#
if
HWY_ARCH_X86
#
define
HWY_FENCE
std
:
:
atomic_thread_fence
(
std
:
:
memory_order_acq_rel
)
#
else
#
define
HWY_FENCE
#
endif
#
define
HWY_REP4
(
literal
)
literal
literal
literal
literal
#
define
HWY_ABORT
(
format
.
.
.
)
\
:
:
hwy
:
:
Abort
(
__FILE__
__LINE__
format
#
#
__VA_ARGS__
)
#
define
HWY_ASSERT
(
condition
)
\
do
{
\
if
(
!
(
condition
)
)
{
\
HWY_ABORT
(
"
Assert
%
s
"
#
condition
)
;
\
}
\
}
while
(
0
)
#
if
HWY_HAS_FEATURE
(
memory_sanitizer
)
|
|
defined
(
MEMORY_SANITIZER
)
#
define
HWY_IS_MSAN
1
#
else
#
define
HWY_IS_MSAN
0
#
endif
#
if
HWY_HAS_FEATURE
(
address_sanitizer
)
|
|
defined
(
ADDRESS_SANITIZER
)
#
define
HWY_IS_ASAN
1
#
else
#
define
HWY_IS_ASAN
0
#
endif
#
if
HWY_HAS_FEATURE
(
thread_sanitizer
)
|
|
defined
(
THREAD_SANITIZER
)
#
define
HWY_IS_TSAN
1
#
else
#
define
HWY_IS_TSAN
0
#
endif
#
if
HWY_IS_MSAN
#
define
HWY_ATTR_NO_MSAN
__attribute__
(
(
no_sanitize_memory
)
)
#
else
#
define
HWY_ATTR_NO_MSAN
#
endif
#
if
!
defined
(
HWY_IS_DEBUG_BUILD
)
#
if
(
!
defined
(
__OPTIMIZE__
)
&
&
!
defined
(
NDEBUG
)
)
|
|
HWY_IS_ASAN
|
|
\
HWY_IS_MSAN
|
|
HWY_IS_TSAN
|
|
defined
(
__clang_analyzer__
)
#
define
HWY_IS_DEBUG_BUILD
1
#
else
#
define
HWY_IS_DEBUG_BUILD
0
#
endif
#
endif
#
if
HWY_IS_DEBUG_BUILD
#
define
HWY_DASSERT
(
condition
)
HWY_ASSERT
(
condition
)
#
else
#
define
HWY_DASSERT
(
condition
)
\
do
{
\
}
while
(
0
)
#
endif
namespace
hwy
{
#
if
HWY_ARCH_X86
static
constexpr
HWY_MAYBE_UNUSED
size_t
kMaxVectorSize
=
64
;
#
elif
HWY_ARCH_RVV
&
&
defined
(
__riscv_vector
)
static
constexpr
HWY_MAYBE_UNUSED
size_t
kMaxVectorSize
=
4096
;
#
else
static
constexpr
HWY_MAYBE_UNUSED
size_t
kMaxVectorSize
=
16
;
#
endif
#
if
HWY_ARCH_X86
#
define
HWY_ALIGN_MAX
alignas
(
64
)
#
elif
HWY_ARCH_RVV
&
&
defined
(
__riscv_vector
)
#
define
HWY_ALIGN_MAX
alignas
(
8
)
/
/
only
elements
need
be
aligned
#
else
#
define
HWY_ALIGN_MAX
alignas
(
16
)
#
endif
#
pragma
pack
(
push
1
)
#
if
(
(
HWY_ARCH_ARM_A64
|
|
(
__ARM_FP
&
2
)
)
&
&
HWY_COMPILER_GCC
)
using
float16_t
=
__fp16
;
#
elif
HWY_ARCH_RVV
&
&
HWY_COMPILER_CLANG
&
&
defined
(
__riscv_zvfh
)
using
float16_t
=
_Float16
;
#
else
struct
float16_t
{
uint16_t
bits
;
}
;
#
endif
struct
bfloat16_t
{
uint16_t
bits
;
}
;
#
pragma
pack
(
pop
)
using
float32_t
=
float
;
using
float64_t
=
double
;
#
pragma
pack
(
push
1
)
struct
alignas
(
16
)
uint128_t
{
uint64_t
lo
;
uint64_t
hi
;
}
;
struct
alignas
(
16
)
K64V64
{
uint64_t
value
;
uint64_t
key
;
}
;
#
pragma
pack
(
pop
)
static
inline
HWY_MAYBE_UNUSED
bool
operator
<
(
const
uint128_t
&
a
const
uint128_t
&
b
)
{
return
(
a
.
hi
=
=
b
.
hi
)
?
a
.
lo
<
b
.
lo
:
a
.
hi
<
b
.
hi
;
}
static
inline
HWY_MAYBE_UNUSED
bool
operator
>
(
const
uint128_t
&
a
const
uint128_t
&
b
)
{
return
b
<
a
;
}
static
inline
HWY_MAYBE_UNUSED
bool
operator
<
(
const
K64V64
&
a
const
K64V64
&
b
)
{
return
a
.
key
<
b
.
key
;
}
static
inline
HWY_MAYBE_UNUSED
bool
operator
>
(
const
K64V64
&
a
const
K64V64
&
b
)
{
return
b
<
a
;
}
template
<
bool
Condition
>
struct
EnableIfT
{
}
;
template
<
>
struct
EnableIfT
<
true
>
{
using
type
=
void
;
}
;
template
<
bool
Condition
>
using
EnableIf
=
typename
EnableIfT
<
Condition
>
:
:
type
;
template
<
typename
T
typename
U
>
struct
IsSameT
{
enum
{
value
=
0
}
;
}
;
template
<
typename
T
>
struct
IsSameT
<
T
T
>
{
enum
{
value
=
1
}
;
}
;
template
<
typename
T
typename
U
>
HWY_API
constexpr
bool
IsSame
(
)
{
return
IsSameT
<
T
U
>
:
:
value
;
}
#
define
HWY_IF_LE128
(
T
N
)
hwy
:
:
EnableIf
<
N
*
sizeof
(
T
)
<
=
16
>
*
=
nullptr
#
define
HWY_IF_LE64
(
T
N
)
hwy
:
:
EnableIf
<
N
*
sizeof
(
T
)
<
=
8
>
*
=
nullptr
#
define
HWY_IF_LE32
(
T
N
)
hwy
:
:
EnableIf
<
N
*
sizeof
(
T
)
<
=
4
>
*
=
nullptr
#
define
HWY_IF_GE32
(
T
N
)
hwy
:
:
EnableIf
<
N
*
sizeof
(
T
)
>
=
4
>
*
=
nullptr
#
define
HWY_IF_GE64
(
T
N
)
hwy
:
:
EnableIf
<
N
*
sizeof
(
T
)
>
=
8
>
*
=
nullptr
#
define
HWY_IF_GE128
(
T
N
)
hwy
:
:
EnableIf
<
N
*
sizeof
(
T
)
>
=
16
>
*
=
nullptr
#
define
HWY_IF_GT128
(
T
N
)
hwy
:
:
EnableIf
<
(
N
*
sizeof
(
T
)
>
16
)
>
*
=
nullptr
#
define
HWY_IF_UNSIGNED
(
T
)
hwy
:
:
EnableIf
<
!
IsSigned
<
T
>
(
)
>
*
=
nullptr
#
define
HWY_IF_SIGNED
(
T
)
\
hwy
:
:
EnableIf
<
IsSigned
<
T
>
(
)
&
&
!
IsFloat
<
T
>
(
)
>
*
=
nullptr
#
define
HWY_IF_FLOAT
(
T
)
hwy
:
:
EnableIf
<
hwy
:
:
IsFloat
<
T
>
(
)
>
*
=
nullptr
#
define
HWY_IF_NOT_FLOAT
(
T
)
hwy
:
:
EnableIf
<
!
hwy
:
:
IsFloat
<
T
>
(
)
>
*
=
nullptr
#
define
HWY_IF_LANE_SIZE
(
T
bytes
)
\
hwy
:
:
EnableIf
<
sizeof
(
T
)
=
=
(
bytes
)
>
*
=
nullptr
#
define
HWY_IF_NOT_LANE_SIZE
(
T
bytes
)
\
hwy
:
:
EnableIf
<
sizeof
(
T
)
!
=
(
bytes
)
>
*
=
nullptr
#
define
HWY_IF_LANE_SIZE_LT
(
T
bytes
)
\
hwy
:
:
EnableIf
<
sizeof
(
T
)
<
(
bytes
)
>
*
=
nullptr
#
define
HWY_IF_LANES_PER_BLOCK
(
T
N
LANES
)
\
hwy
:
:
EnableIf
<
HWY_MIN
(
sizeof
(
T
)
*
N
16
)
/
sizeof
(
T
)
=
=
(
LANES
)
>
*
=
nullptr
template
<
size_t
N
>
struct
SizeTag
{
}
;
template
<
class
T
>
struct
RemoveConstT
{
using
type
=
T
;
}
;
template
<
class
T
>
struct
RemoveConstT
<
const
T
>
{
using
type
=
T
;
}
;
template
<
class
T
>
using
RemoveConst
=
typename
RemoveConstT
<
T
>
:
:
type
;
namespace
detail
{
template
<
typename
T
>
struct
Relations
;
template
<
>
struct
Relations
<
uint8_t
>
{
using
Unsigned
=
uint8_t
;
using
Signed
=
int8_t
;
using
Wide
=
uint16_t
;
enum
{
is_signed
=
0
}
;
enum
{
is_float
=
0
}
;
}
;
template
<
>
struct
Relations
<
int8_t
>
{
using
Unsigned
=
uint8_t
;
using
Signed
=
int8_t
;
using
Wide
=
int16_t
;
enum
{
is_signed
=
1
}
;
enum
{
is_float
=
0
}
;
}
;
template
<
>
struct
Relations
<
uint16_t
>
{
using
Unsigned
=
uint16_t
;
using
Signed
=
int16_t
;
using
Wide
=
uint32_t
;
using
Narrow
=
uint8_t
;
enum
{
is_signed
=
0
}
;
enum
{
is_float
=
0
}
;
}
;
template
<
>
struct
Relations
<
int16_t
>
{
using
Unsigned
=
uint16_t
;
using
Signed
=
int16_t
;
using
Wide
=
int32_t
;
using
Narrow
=
int8_t
;
enum
{
is_signed
=
1
}
;
enum
{
is_float
=
0
}
;
}
;
template
<
>
struct
Relations
<
uint32_t
>
{
using
Unsigned
=
uint32_t
;
using
Signed
=
int32_t
;
using
Float
=
float
;
using
Wide
=
uint64_t
;
using
Narrow
=
uint16_t
;
enum
{
is_signed
=
0
}
;
enum
{
is_float
=
0
}
;
}
;
template
<
>
struct
Relations
<
int32_t
>
{
using
Unsigned
=
uint32_t
;
using
Signed
=
int32_t
;
using
Float
=
float
;
using
Wide
=
int64_t
;
using
Narrow
=
int16_t
;
enum
{
is_signed
=
1
}
;
enum
{
is_float
=
0
}
;
}
;
template
<
>
struct
Relations
<
uint64_t
>
{
using
Unsigned
=
uint64_t
;
using
Signed
=
int64_t
;
using
Float
=
double
;
using
Wide
=
uint128_t
;
using
Narrow
=
uint32_t
;
enum
{
is_signed
=
0
}
;
enum
{
is_float
=
0
}
;
}
;
template
<
>
struct
Relations
<
int64_t
>
{
using
Unsigned
=
uint64_t
;
using
Signed
=
int64_t
;
using
Float
=
double
;
using
Narrow
=
int32_t
;
enum
{
is_signed
=
1
}
;
enum
{
is_float
=
0
}
;
}
;
template
<
>
struct
Relations
<
uint128_t
>
{
using
Unsigned
=
uint128_t
;
using
Narrow
=
uint64_t
;
enum
{
is_signed
=
0
}
;
enum
{
is_float
=
0
}
;
}
;
template
<
>
struct
Relations
<
float16_t
>
{
using
Unsigned
=
uint16_t
;
using
Signed
=
int16_t
;
using
Float
=
float16_t
;
using
Wide
=
float
;
enum
{
is_signed
=
1
}
;
enum
{
is_float
=
1
}
;
}
;
template
<
>
struct
Relations
<
bfloat16_t
>
{
using
Unsigned
=
uint16_t
;
using
Signed
=
int16_t
;
using
Wide
=
float
;
enum
{
is_signed
=
1
}
;
enum
{
is_float
=
1
}
;
}
;
template
<
>
struct
Relations
<
float
>
{
using
Unsigned
=
uint32_t
;
using
Signed
=
int32_t
;
using
Float
=
float
;
using
Wide
=
double
;
using
Narrow
=
float16_t
;
enum
{
is_signed
=
1
}
;
enum
{
is_float
=
1
}
;
}
;
template
<
>
struct
Relations
<
double
>
{
using
Unsigned
=
uint64_t
;
using
Signed
=
int64_t
;
using
Float
=
double
;
using
Narrow
=
float
;
enum
{
is_signed
=
1
}
;
enum
{
is_float
=
1
}
;
}
;
template
<
size_t
N
>
struct
TypeFromSize
;
template
<
>
struct
TypeFromSize
<
1
>
{
using
Unsigned
=
uint8_t
;
using
Signed
=
int8_t
;
}
;
template
<
>
struct
TypeFromSize
<
2
>
{
using
Unsigned
=
uint16_t
;
using
Signed
=
int16_t
;
}
;
template
<
>
struct
TypeFromSize
<
4
>
{
using
Unsigned
=
uint32_t
;
using
Signed
=
int32_t
;
using
Float
=
float
;
}
;
template
<
>
struct
TypeFromSize
<
8
>
{
using
Unsigned
=
uint64_t
;
using
Signed
=
int64_t
;
using
Float
=
double
;
}
;
template
<
>
struct
TypeFromSize
<
16
>
{
using
Unsigned
=
uint128_t
;
}
;
}
template
<
typename
T
>
using
MakeUnsigned
=
typename
detail
:
:
Relations
<
T
>
:
:
Unsigned
;
template
<
typename
T
>
using
MakeSigned
=
typename
detail
:
:
Relations
<
T
>
:
:
Signed
;
template
<
typename
T
>
using
MakeFloat
=
typename
detail
:
:
Relations
<
T
>
:
:
Float
;
template
<
typename
T
>
using
MakeWide
=
typename
detail
:
:
Relations
<
T
>
:
:
Wide
;
template
<
typename
T
>
using
MakeNarrow
=
typename
detail
:
:
Relations
<
T
>
:
:
Narrow
;
template
<
size_t
N
>
using
UnsignedFromSize
=
typename
detail
:
:
TypeFromSize
<
N
>
:
:
Unsigned
;
template
<
size_t
N
>
using
SignedFromSize
=
typename
detail
:
:
TypeFromSize
<
N
>
:
:
Signed
;
template
<
size_t
N
>
using
FloatFromSize
=
typename
detail
:
:
TypeFromSize
<
N
>
:
:
Float
;
using
UnsignedTag
=
SizeTag
<
0
>
;
using
SignedTag
=
SizeTag
<
0x100
>
;
using
FloatTag
=
SizeTag
<
0x200
>
;
template
<
typename
T
class
R
=
detail
:
:
Relations
<
T
>
>
constexpr
auto
TypeTag
(
)
-
>
hwy
:
:
SizeTag
<
(
(
R
:
:
is_signed
+
R
:
:
is_float
)
<
<
8
)
>
{
return
hwy
:
:
SizeTag
<
(
(
R
:
:
is_signed
+
R
:
:
is_float
)
<
<
8
)
>
(
)
;
}
using
NonFloatTag
=
SizeTag
<
0x400
>
;
template
<
typename
T
class
R
=
detail
:
:
Relations
<
T
>
>
constexpr
auto
IsFloatTag
(
)
-
>
hwy
:
:
SizeTag
<
(
R
:
:
is_float
?
0x200
:
0x400
)
>
{
return
hwy
:
:
SizeTag
<
(
R
:
:
is_float
?
0x200
:
0x400
)
>
(
)
;
}
template
<
typename
T
>
HWY_API
constexpr
bool
IsFloat
(
)
{
return
IsSame
<
T
float
>
(
)
|
|
IsSame
<
T
double
>
(
)
;
}
template
<
typename
T
>
HWY_API
constexpr
bool
IsSigned
(
)
{
return
T
(
0
)
>
T
(
-
1
)
;
}
template
<
>
constexpr
bool
IsSigned
<
float16_t
>
(
)
{
return
true
;
}
template
<
>
constexpr
bool
IsSigned
<
bfloat16_t
>
(
)
{
return
true
;
}
template
<
typename
T
>
HWY_API
constexpr
T
LimitsMax
(
)
{
static_assert
(
!
IsFloat
<
T
>
(
)
"
Only
for
integer
types
"
)
;
using
TU
=
MakeUnsigned
<
T
>
;
return
static_cast
<
T
>
(
IsSigned
<
T
>
(
)
?
(
static_cast
<
TU
>
(
~
0ull
)
>
>
1
)
:
static_cast
<
TU
>
(
~
0ull
)
)
;
}
template
<
typename
T
>
HWY_API
constexpr
T
LimitsMin
(
)
{
static_assert
(
!
IsFloat
<
T
>
(
)
"
Only
for
integer
types
"
)
;
return
IsSigned
<
T
>
(
)
?
T
(
-
1
)
-
LimitsMax
<
T
>
(
)
:
T
(
0
)
;
}
template
<
typename
T
>
HWY_API
constexpr
T
LowestValue
(
)
{
return
LimitsMin
<
T
>
(
)
;
}
template
<
>
constexpr
float
LowestValue
<
float
>
(
)
{
return
-
3
.
402823466e
+
38F
;
}
template
<
>
constexpr
double
LowestValue
<
double
>
(
)
{
return
-
1
.
7976931348623158e
+
308
;
}
template
<
typename
T
>
HWY_API
constexpr
T
HighestValue
(
)
{
return
LimitsMax
<
T
>
(
)
;
}
template
<
>
constexpr
float
HighestValue
<
float
>
(
)
{
return
3
.
402823466e
+
38F
;
}
template
<
>
constexpr
double
HighestValue
<
double
>
(
)
{
return
1
.
7976931348623158e
+
308
;
}
template
<
typename
T
>
constexpr
int
MantissaBits
(
)
{
static_assert
(
sizeof
(
T
)
=
=
0
"
Only
instantiate
the
specializations
"
)
;
return
0
;
}
template
<
>
constexpr
int
MantissaBits
<
float
>
(
)
{
return
23
;
}
template
<
>
constexpr
int
MantissaBits
<
double
>
(
)
{
return
52
;
}
template
<
typename
T
>
constexpr
MakeSigned
<
T
>
MaxExponentTimes2
(
)
{
return
-
(
MakeSigned
<
T
>
{
1
}
<
<
(
MantissaBits
<
T
>
(
)
+
1
)
)
;
}
template
<
typename
T
>
constexpr
MakeUnsigned
<
T
>
SignMask
(
)
{
return
MakeUnsigned
<
T
>
{
1
}
<
<
(
sizeof
(
T
)
*
8
-
1
)
;
}
template
<
typename
T
>
constexpr
MakeUnsigned
<
T
>
ExponentMask
(
)
{
return
(
~
(
MakeUnsigned
<
T
>
{
1
}
<
<
MantissaBits
<
T
>
(
)
)
+
1
)
&
~
SignMask
<
T
>
(
)
;
}
template
<
typename
T
>
constexpr
MakeUnsigned
<
T
>
MantissaMask
(
)
{
return
(
MakeUnsigned
<
T
>
{
1
}
<
<
MantissaBits
<
T
>
(
)
)
-
1
;
}
template
<
typename
T
>
constexpr
T
MantissaEnd
(
)
{
static_assert
(
sizeof
(
T
)
=
=
0
"
Only
instantiate
the
specializations
"
)
;
return
0
;
}
template
<
>
constexpr
float
MantissaEnd
<
float
>
(
)
{
return
8388608
.
0f
;
}
template
<
>
constexpr
double
MantissaEnd
<
double
>
(
)
{
return
4503599627370496
.
0
;
}
template
<
typename
T
>
constexpr
int
ExponentBits
(
)
{
return
8
*
sizeof
(
T
)
-
1
-
MantissaBits
<
T
>
(
)
;
}
template
<
typename
T
>
constexpr
MakeSigned
<
T
>
MaxExponentField
(
)
{
return
(
MakeSigned
<
T
>
{
1
}
<
<
ExponentBits
<
T
>
(
)
)
-
1
;
}
template
<
typename
T1
typename
T2
>
constexpr
inline
T1
DivCeil
(
T1
a
T2
b
)
{
return
(
a
+
b
-
1
)
/
b
;
}
constexpr
inline
size_t
RoundUpTo
(
size_t
what
size_t
align
)
{
return
DivCeil
(
what
align
)
*
align
;
}
HWY_API
size_t
Num0BitsBelowLS1Bit_Nonzero32
(
const
uint32_t
x
)
{
#
if
HWY_COMPILER_MSVC
unsigned
long
index
;
_BitScanForward
(
&
index
x
)
;
return
index
;
#
else
return
static_cast
<
size_t
>
(
__builtin_ctz
(
x
)
)
;
#
endif
}
HWY_API
size_t
Num0BitsBelowLS1Bit_Nonzero64
(
const
uint64_t
x
)
{
#
if
HWY_COMPILER_MSVC
#
if
HWY_ARCH_X86_64
unsigned
long
index
;
_BitScanForward64
(
&
index
x
)
;
return
index
;
#
else
uint32_t
lsb
=
static_cast
<
uint32_t
>
(
x
&
0xFFFFFFFF
)
;
unsigned
long
index
;
if
(
lsb
=
=
0
)
{
uint32_t
msb
=
static_cast
<
uint32_t
>
(
x
>
>
32u
)
;
_BitScanForward
(
&
index
msb
)
;
return
32
+
index
;
}
else
{
_BitScanForward
(
&
index
lsb
)
;
return
index
;
}
#
endif
#
else
return
static_cast
<
size_t
>
(
__builtin_ctzll
(
x
)
)
;
#
endif
}
HWY_API
size_t
Num0BitsAboveMS1Bit_Nonzero32
(
const
uint32_t
x
)
{
#
if
HWY_COMPILER_MSVC
unsigned
long
index
;
_BitScanReverse
(
&
index
x
)
;
return
31
-
index
;
#
else
return
static_cast
<
size_t
>
(
__builtin_clz
(
x
)
)
;
#
endif
}
HWY_API
size_t
Num0BitsAboveMS1Bit_Nonzero64
(
const
uint64_t
x
)
{
#
if
HWY_COMPILER_MSVC
#
if
HWY_ARCH_X86_64
unsigned
long
index
;
_BitScanReverse64
(
&
index
x
)
;
return
63
-
index
;
#
else
const
uint32_t
msb
=
static_cast
<
uint32_t
>
(
x
>
>
32u
)
;
unsigned
long
index
;
if
(
msb
=
=
0
)
{
const
uint32_t
lsb
=
static_cast
<
uint32_t
>
(
x
&
0xFFFFFFFF
)
;
_BitScanReverse
(
&
index
lsb
)
;
return
63
-
index
;
}
else
{
_BitScanReverse
(
&
index
msb
)
;
return
31
-
index
;
}
#
endif
#
else
return
static_cast
<
size_t
>
(
__builtin_clzll
(
x
)
)
;
#
endif
}
HWY_API
size_t
PopCount
(
uint64_t
x
)
{
#
if
HWY_COMPILER_GCC
return
static_cast
<
size_t
>
(
__builtin_popcountll
(
x
)
)
;
#
elif
HWY_COMPILER_MSVC
&
&
HWY_ARCH_X86_64
&
&
defined
(
__AVX__
)
return
_mm_popcnt_u64
(
x
)
;
#
elif
HWY_COMPILER_MSVC
&
&
HWY_ARCH_X86_32
&
&
defined
(
__AVX__
)
return
_mm_popcnt_u32
(
static_cast
<
uint32_t
>
(
x
&
0xFFFFFFFFu
)
)
+
_mm_popcnt_u32
(
static_cast
<
uint32_t
>
(
x
>
>
32
)
)
;
#
else
x
-
=
(
(
x
>
>
1
)
&
0x5555555555555555ULL
)
;
x
=
(
(
(
x
>
>
2
)
&
0x3333333333333333ULL
)
+
(
x
&
0x3333333333333333ULL
)
)
;
x
=
(
(
(
x
>
>
4
)
+
x
)
&
0x0F0F0F0F0F0F0F0FULL
)
;
x
+
=
(
x
>
>
8
)
;
x
+
=
(
x
>
>
16
)
;
x
+
=
(
x
>
>
32
)
;
return
static_cast
<
size_t
>
(
x
&
0x7Fu
)
;
#
endif
}
template
<
typename
TI
>
constexpr
size_t
FloorLog2
(
TI
x
)
{
return
x
=
=
TI
{
1
}
?
0
:
static_cast
<
size_t
>
(
FloorLog2
(
static_cast
<
TI
>
(
x
>
>
1
)
)
+
1
)
;
}
template
<
typename
TI
>
constexpr
size_t
CeilLog2
(
TI
x
)
{
return
x
=
=
TI
{
1
}
?
0
:
static_cast
<
size_t
>
(
FloorLog2
(
static_cast
<
TI
>
(
x
-
1
)
)
+
1
)
;
}
#
if
HWY_COMPILER_MSVC
&
&
HWY_ARCH_X86_64
#
pragma
intrinsic
(
_umul128
)
#
endif
HWY_API
uint64_t
Mul128
(
uint64_t
a
uint64_t
b
uint64_t
*
HWY_RESTRICT
upper
)
{
#
if
defined
(
__SIZEOF_INT128__
)
__uint128_t
product
=
(
__uint128_t
)
a
*
(
__uint128_t
)
b
;
*
upper
=
(
uint64_t
)
(
product
>
>
64
)
;
return
(
uint64_t
)
(
product
&
0xFFFFFFFFFFFFFFFFULL
)
;
#
elif
HWY_COMPILER_MSVC
&
&
HWY_ARCH_X86_64
return
_umul128
(
a
b
upper
)
;
#
else
constexpr
uint64_t
kLo32
=
0xFFFFFFFFU
;
const
uint64_t
lo_lo
=
(
a
&
kLo32
)
*
(
b
&
kLo32
)
;
const
uint64_t
hi_lo
=
(
a
>
>
32
)
*
(
b
&
kLo32
)
;
const
uint64_t
lo_hi
=
(
a
&
kLo32
)
*
(
b
>
>
32
)
;
const
uint64_t
hi_hi
=
(
a
>
>
32
)
*
(
b
>
>
32
)
;
const
uint64_t
t
=
(
lo_lo
>
>
32
)
+
(
hi_lo
&
kLo32
)
+
lo_hi
;
*
upper
=
(
hi_lo
>
>
32
)
+
(
t
>
>
32
)
+
hi_hi
;
return
(
t
<
<
32
)
|
(
lo_lo
&
kLo32
)
;
#
endif
}
#
if
HWY_COMPILER_MSVC
#
pragma
intrinsic
(
memcpy
)
#
pragma
intrinsic
(
memset
)
#
endif
template
<
size_t
kBytes
typename
From
typename
To
>
HWY_API
void
CopyBytes
(
const
From
*
from
To
*
to
)
{
#
if
HWY_COMPILER_MSVC
memcpy
(
to
from
kBytes
)
;
#
else
__builtin_memcpy
(
to
from
kBytes
)
;
#
endif
}
template
<
size_t
kBytes
typename
To
>
HWY_API
void
ZeroBytes
(
To
*
to
)
{
#
if
HWY_COMPILER_MSVC
memset
(
to
0
kBytes
)
;
#
else
__builtin_memset
(
to
0
kBytes
)
;
#
endif
}
HWY_API
float
F32FromBF16
(
bfloat16_t
bf
)
{
uint32_t
bits
=
bf
.
bits
;
bits
<
<
=
16
;
float
f
;
CopyBytes
<
4
>
(
&
bits
&
f
)
;
return
f
;
}
HWY_API
bfloat16_t
BF16FromF32
(
float
f
)
{
uint32_t
bits
;
CopyBytes
<
4
>
(
&
f
&
bits
)
;
bfloat16_t
bf
;
bf
.
bits
=
static_cast
<
uint16_t
>
(
bits
>
>
16
)
;
return
bf
;
}
HWY_DLLEXPORT
HWY_NORETURN
void
HWY_FORMAT
(
3
4
)
Abort
(
const
char
*
file
int
line
const
char
*
format
.
.
.
)
;
}
#
endif
