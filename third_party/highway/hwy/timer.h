#
ifndef
HIGHWAY_HWY_TIMER_H_
#
define
HIGHWAY_HWY_TIMER_H_
#
include
<
stdint
.
h
>
#
include
<
time
.
h
>
#
include
"
hwy
/
base
.
h
"
#
if
defined
(
_WIN32
)
|
|
defined
(
_WIN64
)
#
ifndef
NOMINMAX
#
define
NOMINMAX
#
endif
#
ifndef
WIN32_LEAN_AND_MEAN
#
define
WIN32_LEAN_AND_MEAN
#
endif
#
include
<
windows
.
h
>
#
endif
#
if
defined
(
__APPLE__
)
#
include
<
mach
/
mach
.
h
>
#
include
<
mach
/
mach_time
.
h
>
#
endif
#
if
defined
(
__HAIKU__
)
#
include
<
OS
.
h
>
#
endif
#
if
HWY_ARCH_PPC
&
&
defined
(
__GLIBC__
)
&
&
defined
(
__powerpc64__
)
#
include
<
sys
/
platform
/
ppc
.
h
>
#
endif
#
if
HWY_ARCH_X86
&
&
HWY_COMPILER_MSVC
#
include
<
intrin
.
h
>
#
endif
namespace
hwy
{
namespace
platform
{
HWY_DLLEXPORT
double
Now
(
)
;
HWY_DLLEXPORT
bool
HaveTimerStop
(
char
*
cpu100
)
;
HWY_DLLEXPORT
double
InvariantTicksPerSecond
(
)
;
HWY_DLLEXPORT
uint64_t
TimerResolution
(
)
;
HWY_DLLEXPORT
bool
GetCpuString
(
char
*
cpu100
)
;
}
struct
Timestamp
{
Timestamp
(
)
{
t
=
platform
:
:
Now
(
)
;
}
double
t
;
}
;
static
inline
double
SecondsSince
(
const
Timestamp
&
t0
)
{
const
Timestamp
t1
;
return
t1
.
t
-
t0
.
t
;
}
namespace
timer
{
using
Ticks
=
uint64_t
;
static
HWY_INLINE
Ticks
Start
(
)
{
Ticks
t
;
#
if
HWY_ARCH_PPC
&
&
defined
(
__GLIBC__
)
&
&
defined
(
__powerpc64__
)
asm
volatile
(
"
mfspr
%
0
%
1
"
:
"
=
r
"
(
t
)
:
"
i
"
(
268
)
)
;
#
elif
HWY_ARCH_ARM_A64
&
&
!
HWY_COMPILER_MSVC
asm
volatile
(
"
mrs
%
0
cntvct_el0
"
:
"
=
r
"
(
t
)
)
;
#
elif
HWY_ARCH_X86
&
&
HWY_COMPILER_MSVC
_ReadWriteBarrier
(
)
;
_mm_lfence
(
)
;
_ReadWriteBarrier
(
)
;
t
=
__rdtsc
(
)
;
_ReadWriteBarrier
(
)
;
_mm_lfence
(
)
;
_ReadWriteBarrier
(
)
;
#
elif
HWY_ARCH_X86_64
asm
volatile
(
"
lfence
\
n
\
t
"
"
rdtsc
\
n
\
t
"
"
shl
32
%
%
rdx
\
n
\
t
"
"
or
%
%
rdx
%
0
\
n
\
t
"
"
lfence
"
:
"
=
a
"
(
t
)
:
:
"
rdx
"
"
memory
"
"
cc
"
)
;
#
elif
HWY_ARCH_RISCV
asm
volatile
(
"
fence
;
rdtime
%
0
"
:
"
=
r
"
(
t
)
)
;
#
elif
defined
(
_WIN32
)
|
|
defined
(
_WIN64
)
LARGE_INTEGER
counter
;
(
void
)
QueryPerformanceCounter
(
&
counter
)
;
t
=
counter
.
QuadPart
;
#
elif
defined
(
__APPLE__
)
t
=
mach_absolute_time
(
)
;
#
elif
defined
(
__HAIKU__
)
t
=
system_time_nsecs
(
)
;
#
else
timespec
ts
;
clock_gettime
(
CLOCK_MONOTONIC
&
ts
)
;
t
=
static_cast
<
Ticks
>
(
ts
.
tv_sec
*
1000000000LL
+
ts
.
tv_nsec
)
;
#
endif
return
t
;
}
static
HWY_INLINE
Ticks
Stop
(
)
{
uint64_t
t
;
#
if
HWY_ARCH_PPC
&
&
defined
(
__GLIBC__
)
&
&
defined
(
__powerpc64__
)
asm
volatile
(
"
mfspr
%
0
%
1
"
:
"
=
r
"
(
t
)
:
"
i
"
(
268
)
)
;
#
elif
HWY_ARCH_ARM_A64
&
&
!
HWY_COMPILER_MSVC
asm
volatile
(
"
mrs
%
0
cntvct_el0
"
:
"
=
r
"
(
t
)
)
;
#
elif
HWY_ARCH_X86
&
&
HWY_COMPILER_MSVC
_ReadWriteBarrier
(
)
;
unsigned
aux
;
t
=
__rdtscp
(
&
aux
)
;
_ReadWriteBarrier
(
)
;
_mm_lfence
(
)
;
_ReadWriteBarrier
(
)
;
#
elif
HWY_ARCH_X86_64
asm
volatile
(
"
rdtscp
\
n
\
t
"
"
shl
32
%
%
rdx
\
n
\
t
"
"
or
%
%
rdx
%
0
\
n
\
t
"
"
lfence
"
:
"
=
a
"
(
t
)
:
:
"
rcx
"
"
rdx
"
"
memory
"
"
cc
"
)
;
#
else
t
=
Start
(
)
;
#
endif
return
t
;
}
}
class
Timer
{
public
:
Timer
(
)
{
char
cpu100
[
100
]
;
have_timer_stop_
=
platform
:
:
HaveTimerStop
(
cpu100
)
;
}
timer
:
:
Ticks
Before
(
)
const
{
return
timer
:
:
Start
(
)
;
}
timer
:
:
Ticks
After
(
)
const
{
return
have_timer_stop_
?
timer
:
:
Stop
(
)
:
timer
:
:
Start
(
)
;
}
private
:
bool
have_timer_stop_
;
}
;
static
inline
double
Seconds
(
timer
:
:
Ticks
ticks
)
{
return
static_cast
<
double
>
(
ticks
)
/
platform
:
:
InvariantTicksPerSecond
(
)
;
}
class
Stopwatch
{
public
:
explicit
Stopwatch
(
const
Timer
&
timestamps
)
:
timer_
(
timestamps
)
{
Reset
(
)
;
}
timer
:
:
Ticks
Origin
(
)
const
{
return
t0_
;
}
void
Reset
(
)
{
t0_
=
timer_
.
Before
(
)
;
}
timer
:
:
Ticks
Elapsed
(
)
{
const
timer
:
:
Ticks
t1
=
timer_
.
After
(
)
;
const
timer
:
:
Ticks
elapsed
=
t1
-
t0_
;
t0_
=
t1
;
return
elapsed
;
}
private
:
const
Timer
&
timer_
;
timer
:
:
Ticks
t0_
;
}
;
}
#
endif
