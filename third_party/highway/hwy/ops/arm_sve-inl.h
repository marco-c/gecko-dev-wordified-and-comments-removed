#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
arm_sve
.
h
>
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
ops
/
shared
-
inl
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
template
<
class
V
>
struct
DFromV_t
{
}
;
template
<
class
V
>
using
DFromV
=
typename
DFromV_t
<
RemoveConst
<
V
>
>
:
:
type
;
template
<
class
V
>
using
TFromV
=
TFromD
<
DFromV
<
V
>
>
;
#
define
HWY_IF_UNSIGNED_V
(
V
)
HWY_IF_UNSIGNED
(
TFromV
<
V
>
)
#
define
HWY_IF_SIGNED_V
(
V
)
HWY_IF_SIGNED
(
TFromV
<
V
>
)
#
define
HWY_IF_FLOAT_V
(
V
)
HWY_IF_FLOAT
(
TFromV
<
V
>
)
#
define
HWY_IF_LANE_SIZE_V
(
V
bytes
)
HWY_IF_LANE_SIZE
(
TFromV
<
V
>
bytes
)
namespace
detail
{
#
define
HWY_SVE_FOREACH_U08
(
X_MACRO
NAME
OP
)
X_MACRO
(
uint
u
8
8
NAME
OP
)
#
define
HWY_SVE_FOREACH_U16
(
X_MACRO
NAME
OP
)
X_MACRO
(
uint
u
16
8
NAME
OP
)
#
define
HWY_SVE_FOREACH_U32
(
X_MACRO
NAME
OP
)
\
X_MACRO
(
uint
u
32
16
NAME
OP
)
#
define
HWY_SVE_FOREACH_U64
(
X_MACRO
NAME
OP
)
\
X_MACRO
(
uint
u
64
32
NAME
OP
)
#
define
HWY_SVE_FOREACH_I08
(
X_MACRO
NAME
OP
)
X_MACRO
(
int
s
8
8
NAME
OP
)
#
define
HWY_SVE_FOREACH_I16
(
X_MACRO
NAME
OP
)
X_MACRO
(
int
s
16
8
NAME
OP
)
#
define
HWY_SVE_FOREACH_I32
(
X_MACRO
NAME
OP
)
X_MACRO
(
int
s
32
16
NAME
OP
)
#
define
HWY_SVE_FOREACH_I64
(
X_MACRO
NAME
OP
)
X_MACRO
(
int
s
64
32
NAME
OP
)
#
define
HWY_SVE_FOREACH_F16
(
X_MACRO
NAME
OP
)
\
X_MACRO
(
float
f
16
16
NAME
OP
)
#
define
HWY_SVE_FOREACH_F32
(
X_MACRO
NAME
OP
)
\
X_MACRO
(
float
f
32
16
NAME
OP
)
#
define
HWY_SVE_FOREACH_F64
(
X_MACRO
NAME
OP
)
\
X_MACRO
(
float
f
64
32
NAME
OP
)
#
define
HWY_SVE_FOREACH_U
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_U08
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_U16
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_U32
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_U64
(
X_MACRO
NAME
OP
)
#
define
HWY_SVE_FOREACH_I
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_I08
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_I16
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_I32
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_I64
(
X_MACRO
NAME
OP
)
#
define
HWY_SVE_FOREACH_F
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_F16
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_F32
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_F64
(
X_MACRO
NAME
OP
)
#
define
HWY_SVE_FOREACH_UI08
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_U08
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_I08
(
X_MACRO
NAME
OP
)
#
define
HWY_SVE_FOREACH_UI16
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_U16
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_I16
(
X_MACRO
NAME
OP
)
#
define
HWY_SVE_FOREACH_UI32
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_U32
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_I32
(
X_MACRO
NAME
OP
)
#
define
HWY_SVE_FOREACH_UI64
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_U64
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_I64
(
X_MACRO
NAME
OP
)
#
define
HWY_SVE_FOREACH_UIF3264
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_UI32
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_UI64
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_F32
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_F64
(
X_MACRO
NAME
OP
)
#
define
HWY_SVE_FOREACH_UI
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_U
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_I
(
X_MACRO
NAME
OP
)
#
define
HWY_SVE_FOREACH_IF
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_I
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_F
(
X_MACRO
NAME
OP
)
#
define
HWY_SVE_FOREACH
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_U
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_I
(
X_MACRO
NAME
OP
)
\
HWY_SVE_FOREACH_F
(
X_MACRO
NAME
OP
)
#
define
HWY_SVE_T
(
BASE
BITS
)
BASE
#
#
BITS
#
#
_t
#
define
HWY_SVE_D
(
BASE
BITS
N
POW2
)
Simd
<
HWY_SVE_T
(
BASE
BITS
)
N
POW2
>
#
define
HWY_SVE_V
(
BASE
BITS
)
sv
#
#
BASE
#
#
BITS
#
#
_t
}
#
define
HWY_SPECIALIZE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
>
\
struct
DFromV_t
<
HWY_SVE_V
(
BASE
BITS
)
>
{
\
using
type
=
ScalableTag
<
HWY_SVE_T
(
BASE
BITS
)
>
;
\
}
;
HWY_SVE_FOREACH
(
HWY_SPECIALIZE
_
_
)
#
undef
HWY_SPECIALIZE
#
define
HWY_SVE_RETV_ARGPV
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
v
)
;
\
}
#
define
HWY_SVE_RETV_ARGV
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
v
)
;
\
}
#
define
HWY_SVE_RETV_ARGPVN
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_V
(
BASE
BITS
)
a
HWY_SVE_T
(
BASE
BITS
)
b
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
a
b
)
;
\
}
#
define
HWY_SVE_RETV_ARGVN
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_V
(
BASE
BITS
)
a
HWY_SVE_T
(
BASE
BITS
)
b
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
a
b
)
;
\
}
#
define
HWY_SVE_RETV_ARGPVV
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_V
(
BASE
BITS
)
a
HWY_SVE_V
(
BASE
BITS
)
b
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
a
b
)
;
\
}
#
define
HWY_SVE_RETV_ARGVV
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_V
(
BASE
BITS
)
a
HWY_SVE_V
(
BASE
BITS
)
b
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
a
b
)
;
\
}
namespace
detail
{
HWY_INLINE
size_t
AllHardwareLanes
(
hwy
:
:
SizeTag
<
1
>
)
{
return
svcntb_pat
(
SV_ALL
)
;
}
HWY_INLINE
size_t
AllHardwareLanes
(
hwy
:
:
SizeTag
<
2
>
)
{
return
svcnth_pat
(
SV_ALL
)
;
}
HWY_INLINE
size_t
AllHardwareLanes
(
hwy
:
:
SizeTag
<
4
>
)
{
return
svcntw_pat
(
SV_ALL
)
;
}
HWY_INLINE
size_t
AllHardwareLanes
(
hwy
:
:
SizeTag
<
8
>
)
{
return
svcntd_pat
(
SV_ALL
)
;
}
HWY_INLINE
size_t
HardwareLanes
(
hwy
:
:
SizeTag
<
1
>
)
{
return
svcntb_pat
(
SV_POW2
)
;
}
HWY_INLINE
size_t
HardwareLanes
(
hwy
:
:
SizeTag
<
2
>
)
{
return
svcnth_pat
(
SV_POW2
)
;
}
HWY_INLINE
size_t
HardwareLanes
(
hwy
:
:
SizeTag
<
4
>
)
{
return
svcntw_pat
(
SV_POW2
)
;
}
HWY_INLINE
size_t
HardwareLanes
(
hwy
:
:
SizeTag
<
8
>
)
{
return
svcntd_pat
(
SV_POW2
)
;
}
}
template
<
typename
T
size_t
N
int
kPow2
>
HWY_API
size_t
Lanes
(
Simd
<
T
N
kPow2
>
d
)
{
const
size_t
actual
=
detail
:
:
HardwareLanes
(
hwy
:
:
SizeTag
<
sizeof
(
T
)
>
(
)
)
;
if
(
detail
:
:
IsFull
(
d
)
)
return
actual
;
return
HWY_MIN
(
detail
:
:
ScaleByPower
(
actual
kPow2
)
N
)
;
}
#
define
HWY_SVE_FIRSTN
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
svbool_t
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
size_t
count
)
{
\
const
size_t
limit
=
detail
:
:
IsFull
(
d
)
?
count
:
HWY_MIN
(
Lanes
(
d
)
count
)
;
\
return
sv
#
#
OP
#
#
_b
#
#
BITS
#
#
_u32
(
uint32_t
{
0
}
static_cast
<
uint32_t
>
(
limit
)
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_FIRSTN
FirstN
whilelt
)
#
undef
HWY_SVE_FIRSTN
namespace
detail
{
#
define
HWY_SVE_PTRUE
(
BITS
)
svptrue_pat_b
#
#
BITS
(
SV_POW2
)
#
define
HWY_SVE_WRAP_PTRUE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
svbool_t
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
d
*
/
)
{
\
return
HWY_SVE_PTRUE
(
BITS
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_WRAP_PTRUE
PTrue
ptrue
)
#
undef
HWY_SVE_WRAP_PTRUE
HWY_API
svbool_t
PFalse
(
)
{
return
svpfalse_b
(
)
;
}
template
<
class
D
>
svbool_t
MakeMask
(
D
d
)
{
return
IsFull
(
d
)
?
PTrue
(
d
)
:
FirstN
(
d
Lanes
(
d
)
)
;
}
}
#
define
HWY_SVE_SET
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
d
*
/
\
HWY_SVE_T
(
BASE
BITS
)
arg
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
arg
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_SET
Set
dup_n
)
#
undef
HWY_SVE_SET
template
<
size_t
N
int
kPow2
>
svuint16_t
Set
(
Simd
<
bfloat16_t
N
kPow2
>
d
bfloat16_t
arg
)
{
return
Set
(
RebindToUnsigned
<
decltype
(
d
)
>
(
)
arg
.
bits
)
;
}
template
<
class
D
>
using
VFromD
=
decltype
(
Set
(
D
(
)
TFromD
<
D
>
(
)
)
)
;
template
<
class
D
>
VFromD
<
D
>
Zero
(
D
d
)
{
return
Set
(
d
0
)
;
}
#
define
HWY_SVE_UNDEFINED
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
d
*
/
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_UNDEFINED
Undefined
undef
)
namespace
detail
{
#
define
HWY_SVE_CAST_NOP
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
BitCastToByte
(
HWY_SVE_V
(
BASE
BITS
)
v
)
{
\
return
v
;
\
}
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
BitCastFromByte
(
\
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
d
*
/
HWY_SVE_V
(
BASE
BITS
)
v
)
{
\
return
v
;
\
}
#
define
HWY_SVE_CAST
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_INLINE
svuint8_t
BitCastToByte
(
HWY_SVE_V
(
BASE
BITS
)
v
)
{
\
return
sv
#
#
OP
#
#
_u8_
#
#
CHAR
#
#
BITS
(
v
)
;
\
}
\
template
<
size_t
N
int
kPow2
>
\
HWY_INLINE
HWY_SVE_V
(
BASE
BITS
)
\
BitCastFromByte
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
d
*
/
svuint8_t
v
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_u8
(
v
)
;
\
}
HWY_SVE_FOREACH_U08
(
HWY_SVE_CAST_NOP
_
_
)
HWY_SVE_FOREACH_I08
(
HWY_SVE_CAST
_
reinterpret
)
HWY_SVE_FOREACH_UI16
(
HWY_SVE_CAST
_
reinterpret
)
HWY_SVE_FOREACH_UI32
(
HWY_SVE_CAST
_
reinterpret
)
HWY_SVE_FOREACH_UI64
(
HWY_SVE_CAST
_
reinterpret
)
HWY_SVE_FOREACH_F
(
HWY_SVE_CAST
_
reinterpret
)
#
undef
HWY_SVE_CAST_NOP
#
undef
HWY_SVE_CAST
template
<
size_t
N
int
kPow2
>
HWY_INLINE
svuint16_t
BitCastFromByte
(
Simd
<
bfloat16_t
N
kPow2
>
svuint8_t
v
)
{
return
BitCastFromByte
(
Simd
<
uint16_t
N
kPow2
>
(
)
v
)
;
}
}
template
<
class
D
class
FromV
>
HWY_API
VFromD
<
D
>
BitCast
(
D
d
FromV
v
)
{
return
detail
:
:
BitCastFromByte
(
d
detail
:
:
BitCastToByte
(
v
)
)
;
}
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPV
Not
not
)
namespace
detail
{
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPVN
AndN
and_n
)
}
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPVV
And
and
)
template
<
class
V
HWY_IF_FLOAT_V
(
V
)
>
HWY_API
V
And
(
const
V
a
const
V
b
)
{
const
DFromV
<
V
>
df
;
const
RebindToUnsigned
<
decltype
(
df
)
>
du
;
return
BitCast
(
df
And
(
BitCast
(
du
a
)
BitCast
(
du
b
)
)
)
;
}
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPVV
Or
orr
)
template
<
class
V
HWY_IF_FLOAT_V
(
V
)
>
HWY_API
V
Or
(
const
V
a
const
V
b
)
{
const
DFromV
<
V
>
df
;
const
RebindToUnsigned
<
decltype
(
df
)
>
du
;
return
BitCast
(
df
Or
(
BitCast
(
du
a
)
BitCast
(
du
b
)
)
)
;
}
namespace
detail
{
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPVN
XorN
eor_n
)
}
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPVV
Xor
eor
)
template
<
class
V
HWY_IF_FLOAT_V
(
V
)
>
HWY_API
V
Xor
(
const
V
a
const
V
b
)
{
const
DFromV
<
V
>
df
;
const
RebindToUnsigned
<
decltype
(
df
)
>
du
;
return
BitCast
(
df
Xor
(
BitCast
(
du
a
)
BitCast
(
du
b
)
)
)
;
}
namespace
detail
{
#
define
HWY_SVE_RETV_ARGPVN_SWAP
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_T
(
BASE
BITS
)
a
HWY_SVE_V
(
BASE
BITS
)
b
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
b
a
)
;
\
}
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPVN_SWAP
AndNotN
bic_n
)
#
undef
HWY_SVE_RETV_ARGPVN_SWAP
}
#
define
HWY_SVE_RETV_ARGPVV_SWAP
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_V
(
BASE
BITS
)
a
HWY_SVE_V
(
BASE
BITS
)
b
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
b
a
)
;
\
}
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPVV_SWAP
AndNot
bic
)
#
undef
HWY_SVE_RETV_ARGPVV_SWAP
template
<
class
V
HWY_IF_FLOAT_V
(
V
)
>
HWY_API
V
AndNot
(
const
V
a
const
V
b
)
{
const
DFromV
<
V
>
df
;
const
RebindToUnsigned
<
decltype
(
df
)
>
du
;
return
BitCast
(
df
AndNot
(
BitCast
(
du
a
)
BitCast
(
du
b
)
)
)
;
}
template
<
class
V
>
HWY_API
V
OrAnd
(
const
V
o
const
V
a1
const
V
a2
)
{
return
Or
(
o
And
(
a1
a2
)
)
;
}
#
ifdef
HWY_NATIVE_POPCNT
#
undef
HWY_NATIVE_POPCNT
#
else
#
define
HWY_NATIVE_POPCNT
#
endif
#
define
HWY_SVE_POPCNT
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v
)
{
\
return
BitCast
(
DFromV
<
decltype
(
v
)
>
(
)
\
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
v
)
)
;
\
}
HWY_SVE_FOREACH_UI
(
HWY_SVE_POPCNT
PopulationCount
cnt
)
#
undef
HWY_SVE_POPCNT
HWY_SVE_FOREACH_IF
(
HWY_SVE_RETV_ARGPV
Neg
neg
)
HWY_SVE_FOREACH_IF
(
HWY_SVE_RETV_ARGPV
Abs
abs
)
template
<
class
V
>
HWY_API
V
CopySign
(
const
V
magn
const
V
sign
)
{
const
auto
msb
=
SignBit
(
DFromV
<
V
>
(
)
)
;
return
Or
(
AndNot
(
msb
magn
)
And
(
msb
sign
)
)
;
}
template
<
class
V
>
HWY_API
V
CopySignToAbs
(
const
V
abs
const
V
sign
)
{
const
auto
msb
=
SignBit
(
DFromV
<
V
>
(
)
)
;
return
Or
(
abs
And
(
msb
sign
)
)
;
}
namespace
detail
{
HWY_SVE_FOREACH
(
HWY_SVE_RETV_ARGPVN
AddN
add_n
)
}
HWY_SVE_FOREACH
(
HWY_SVE_RETV_ARGPVV
Add
add
)
namespace
detail
{
#
define
HWY_SVE_RETV_ARGPVN_MASK
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
svbool_t
pg
HWY_SVE_V
(
BASE
BITS
)
a
HWY_SVE_T
(
BASE
BITS
)
b
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_z
(
pg
a
b
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_RETV_ARGPVN_MASK
SubN
sub_n
)
#
undef
HWY_SVE_RETV_ARGPVN_MASK
}
HWY_SVE_FOREACH
(
HWY_SVE_RETV_ARGPVV
Sub
sub
)
HWY_API
svuint64_t
SumsOf8
(
const
svuint8_t
v
)
{
const
ScalableTag
<
uint32_t
>
du32
;
const
ScalableTag
<
uint64_t
>
du64
;
const
svbool_t
pg
=
detail
:
:
PTrue
(
du64
)
;
const
svuint32_t
sums_of_4
=
svdot_n_u32
(
Zero
(
du32
)
v
1
)
;
const
svuint64_t
hi
=
svlsr_n_u64_x
(
pg
BitCast
(
du64
sums_of_4
)
32
)
;
const
svuint64_t
lo
=
svextw_u64_x
(
pg
BitCast
(
du64
sums_of_4
)
)
;
return
Add
(
hi
lo
)
;
}
HWY_SVE_FOREACH_UI08
(
HWY_SVE_RETV_ARGVV
SaturatedAdd
qadd
)
HWY_SVE_FOREACH_UI16
(
HWY_SVE_RETV_ARGVV
SaturatedAdd
qadd
)
HWY_SVE_FOREACH_UI08
(
HWY_SVE_RETV_ARGVV
SaturatedSub
qsub
)
HWY_SVE_FOREACH_UI16
(
HWY_SVE_RETV_ARGVV
SaturatedSub
qsub
)
HWY_SVE_FOREACH_IF
(
HWY_SVE_RETV_ARGPVV
AbsDiff
abd
)
#
define
HWY_SVE_SHIFT_N
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
int
kBits
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
v
kBits
)
;
\
}
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
#
#
Same
(
HWY_SVE_V
(
BASE
BITS
)
v
HWY_SVE_T
(
uint
BITS
)
bits
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
v
bits
)
;
\
}
HWY_SVE_FOREACH_UI
(
HWY_SVE_SHIFT_N
ShiftLeft
lsl_n
)
HWY_SVE_FOREACH_U
(
HWY_SVE_SHIFT_N
ShiftRight
lsr_n
)
HWY_SVE_FOREACH_I
(
HWY_SVE_SHIFT_N
ShiftRight
asr_n
)
#
undef
HWY_SVE_SHIFT_N
template
<
int
kBits
class
V
>
HWY_API
V
RotateRight
(
const
V
v
)
{
constexpr
size_t
kSizeInBits
=
sizeof
(
TFromV
<
V
>
)
*
8
;
static_assert
(
0
<
=
kBits
&
&
kBits
<
kSizeInBits
"
Invalid
shift
count
"
)
;
if
(
kBits
=
=
0
)
return
v
;
return
Or
(
ShiftRight
<
kBits
>
(
v
)
ShiftLeft
<
kSizeInBits
-
kBits
>
(
v
)
)
;
}
#
define
HWY_SVE_SHIFT
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v
HWY_SVE_V
(
BASE
BITS
)
bits
)
{
\
const
RebindToUnsigned
<
DFromV
<
decltype
(
v
)
>
>
du
;
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
v
\
BitCast
(
du
bits
)
)
;
\
}
HWY_SVE_FOREACH_UI
(
HWY_SVE_SHIFT
Shl
lsl
)
HWY_SVE_FOREACH_U
(
HWY_SVE_SHIFT
Shr
lsr
)
HWY_SVE_FOREACH_I
(
HWY_SVE_SHIFT
Shr
asr
)
#
undef
HWY_SVE_SHIFT
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPVV
Min
min
)
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPVV
Max
max
)
HWY_SVE_FOREACH_F
(
HWY_SVE_RETV_ARGPVV
Min
minnm
)
HWY_SVE_FOREACH_F
(
HWY_SVE_RETV_ARGPVV
Max
maxnm
)
namespace
detail
{
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPVN
MinN
min_n
)
HWY_SVE_FOREACH_UI
(
HWY_SVE_RETV_ARGPVN
MaxN
max_n
)
}
HWY_SVE_FOREACH_UI16
(
HWY_SVE_RETV_ARGPVV
Mul
mul
)
HWY_SVE_FOREACH_UIF3264
(
HWY_SVE_RETV_ARGPVV
Mul
mul
)
HWY_SVE_FOREACH_UI16
(
HWY_SVE_RETV_ARGPVV
MulHigh
mulh
)
namespace
detail
{
HWY_SVE_FOREACH_UI32
(
HWY_SVE_RETV_ARGPVV
MulHigh
mulh
)
HWY_SVE_FOREACH_U64
(
HWY_SVE_RETV_ARGPVV
MulHigh
mulh
)
}
HWY_SVE_FOREACH_F
(
HWY_SVE_RETV_ARGPVV
Div
div
)
HWY_SVE_FOREACH_F32
(
HWY_SVE_RETV_ARGV
ApproximateReciprocal
recpe
)
HWY_SVE_FOREACH_F
(
HWY_SVE_RETV_ARGPV
Sqrt
sqrt
)
HWY_SVE_FOREACH_F32
(
HWY_SVE_RETV_ARGV
ApproximateReciprocalSqrt
rsqrte
)
#
define
HWY_SVE_FMA
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_V
(
BASE
BITS
)
mul
HWY_SVE_V
(
BASE
BITS
)
x
\
HWY_SVE_V
(
BASE
BITS
)
add
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
x
mul
add
)
;
\
}
HWY_SVE_FOREACH_F
(
HWY_SVE_FMA
MulAdd
mad
)
HWY_SVE_FOREACH_F
(
HWY_SVE_FMA
NegMulAdd
msb
)
HWY_SVE_FOREACH_F
(
HWY_SVE_FMA
MulSub
nmsb
)
HWY_SVE_FOREACH_F
(
HWY_SVE_FMA
NegMulSub
nmad
)
#
undef
HWY_SVE_FMA
HWY_SVE_FOREACH_F
(
HWY_SVE_RETV_ARGPV
Round
rintn
)
HWY_SVE_FOREACH_F
(
HWY_SVE_RETV_ARGPV
Floor
rintm
)
HWY_SVE_FOREACH_F
(
HWY_SVE_RETV_ARGPV
Ceil
rintp
)
HWY_SVE_FOREACH_F
(
HWY_SVE_RETV_ARGPV
Trunc
rintz
)
template
<
class
D
typename
MFrom
>
HWY_API
svbool_t
RebindMask
(
const
D
const
MFrom
mask
)
{
return
mask
;
}
HWY_API
svbool_t
Not
(
svbool_t
m
)
{
return
svnot_b_z
(
HWY_SVE_PTRUE
(
8
)
m
)
;
}
HWY_API
svbool_t
And
(
svbool_t
a
svbool_t
b
)
{
return
svand_b_z
(
b
b
a
)
;
}
HWY_API
svbool_t
AndNot
(
svbool_t
a
svbool_t
b
)
{
return
svbic_b_z
(
b
b
a
)
;
}
HWY_API
svbool_t
Or
(
svbool_t
a
svbool_t
b
)
{
return
svsel_b
(
a
a
b
)
;
}
HWY_API
svbool_t
Xor
(
svbool_t
a
svbool_t
b
)
{
return
svsel_b
(
a
svnand_b_z
(
a
a
b
)
b
)
;
}
#
define
HWY_SVE_COUNT_TRUE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
size_t
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
svbool_t
m
)
{
\
return
sv
#
#
OP
#
#
_b
#
#
BITS
(
detail
:
:
MakeMask
(
d
)
m
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_COUNT_TRUE
CountTrue
cntp
)
#
undef
HWY_SVE_COUNT_TRUE
namespace
detail
{
#
define
HWY_SVE_COUNT_TRUE_FULL
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
size_t
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
d
*
/
svbool_t
m
)
{
\
return
sv
#
#
OP
#
#
_b
#
#
BITS
(
svptrue_b
#
#
BITS
(
)
m
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_COUNT_TRUE_FULL
CountTrueFull
cntp
)
#
undef
HWY_SVE_COUNT_TRUE_FULL
}
template
<
class
D
>
HWY_API
bool
AllFalse
(
D
d
svbool_t
m
)
{
return
!
svptest_any
(
detail
:
:
MakeMask
(
d
)
m
)
;
}
template
<
class
D
>
HWY_API
bool
AllTrue
(
D
d
svbool_t
m
)
{
return
CountTrue
(
d
m
)
=
=
Lanes
(
d
)
;
}
template
<
class
D
>
HWY_API
intptr_t
FindFirstTrue
(
D
d
svbool_t
m
)
{
return
AllFalse
(
d
m
)
?
intptr_t
{
-
1
}
:
static_cast
<
intptr_t
>
(
CountTrue
(
d
svbrkb_b_z
(
detail
:
:
MakeMask
(
d
)
m
)
)
)
;
}
#
define
HWY_SVE_IF_THEN_ELSE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
svbool_t
m
HWY_SVE_V
(
BASE
BITS
)
yes
HWY_SVE_V
(
BASE
BITS
)
no
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
m
yes
no
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_IF_THEN_ELSE
IfThenElse
sel
)
#
undef
HWY_SVE_IF_THEN_ELSE
template
<
class
M
class
V
>
HWY_API
V
IfThenElseZero
(
const
M
mask
const
V
yes
)
{
return
IfThenElse
(
mask
yes
Zero
(
DFromV
<
V
>
(
)
)
)
;
}
template
<
class
M
class
V
>
HWY_API
V
IfThenZeroElse
(
const
M
mask
const
V
no
)
{
return
IfThenElse
(
mask
Zero
(
DFromV
<
V
>
(
)
)
no
)
;
}
#
define
HWY_SVE_COMPARE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
svbool_t
NAME
(
HWY_SVE_V
(
BASE
BITS
)
a
HWY_SVE_V
(
BASE
BITS
)
b
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
HWY_SVE_PTRUE
(
BITS
)
a
b
)
;
\
}
#
define
HWY_SVE_COMPARE_N
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
svbool_t
NAME
(
HWY_SVE_V
(
BASE
BITS
)
a
HWY_SVE_T
(
BASE
BITS
)
b
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
HWY_SVE_PTRUE
(
BITS
)
a
b
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_COMPARE
Eq
cmpeq
)
namespace
detail
{
HWY_SVE_FOREACH
(
HWY_SVE_COMPARE_N
EqN
cmpeq_n
)
}
HWY_SVE_FOREACH
(
HWY_SVE_COMPARE
Ne
cmpne
)
namespace
detail
{
HWY_SVE_FOREACH
(
HWY_SVE_COMPARE_N
NeN
cmpne_n
)
}
HWY_SVE_FOREACH
(
HWY_SVE_COMPARE
Lt
cmplt
)
namespace
detail
{
HWY_SVE_FOREACH
(
HWY_SVE_COMPARE_N
LtN
cmplt_n
)
}
HWY_SVE_FOREACH_F
(
HWY_SVE_COMPARE
Le
cmple
)
#
undef
HWY_SVE_COMPARE
#
undef
HWY_SVE_COMPARE_N
template
<
class
V
>
HWY_API
svbool_t
Gt
(
const
V
a
const
V
b
)
{
return
Lt
(
b
a
)
;
}
template
<
class
V
>
HWY_API
svbool_t
Ge
(
const
V
a
const
V
b
)
{
return
Le
(
b
a
)
;
}
template
<
class
V
>
HWY_API
svbool_t
TestBit
(
const
V
a
const
V
bit
)
{
return
detail
:
:
NeN
(
And
(
a
bit
)
0
)
;
}
template
<
class
V
>
HWY_API
svbool_t
MaskFromVec
(
const
V
v
)
{
return
detail
:
:
NeN
(
v
static_cast
<
TFromV
<
V
>
>
(
0
)
)
;
}
template
<
class
D
HWY_IF_NOT_FLOAT_D
(
D
)
>
HWY_API
VFromD
<
D
>
VecFromMask
(
const
D
d
svbool_t
mask
)
{
const
auto
v0
=
Zero
(
RebindToSigned
<
decltype
(
d
)
>
(
)
)
;
return
BitCast
(
d
detail
:
:
SubN
(
mask
v0
1
)
)
;
}
template
<
class
D
HWY_IF_FLOAT_D
(
D
)
>
HWY_API
VFromD
<
D
>
VecFromMask
(
const
D
d
svbool_t
mask
)
{
return
BitCast
(
d
VecFromMask
(
RebindToUnsigned
<
D
>
(
)
mask
)
)
;
}
template
<
class
V
>
HWY_API
V
IfVecThenElse
(
const
V
mask
const
V
yes
const
V
no
)
{
return
IfThenElse
(
MaskFromVec
(
mask
)
yes
no
)
;
}
#
define
HWY_SVE_LOAD
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
\
const
HWY_SVE_T
(
BASE
BITS
)
*
HWY_RESTRICT
p
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
detail
:
:
MakeMask
(
d
)
p
)
;
\
}
#
define
HWY_SVE_MASKED_LOAD
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
svbool_t
m
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
d
*
/
\
const
HWY_SVE_T
(
BASE
BITS
)
*
HWY_RESTRICT
p
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
m
p
)
;
\
}
#
define
HWY_SVE_LOAD_DUP128
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
d
*
/
\
const
HWY_SVE_T
(
BASE
BITS
)
*
HWY_RESTRICT
p
)
{
\
/
*
All
-
true
predicate
to
load
all
128
bits
.
*
/
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
HWY_SVE_PTRUE
(
8
)
p
)
;
\
}
#
define
HWY_SVE_STORE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
void
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v
\
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
\
HWY_SVE_T
(
BASE
BITS
)
*
HWY_RESTRICT
p
)
{
\
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
detail
:
:
MakeMask
(
d
)
p
v
)
;
\
}
#
define
HWY_SVE_MASKED_STORE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
void
NAME
(
svbool_t
m
HWY_SVE_V
(
BASE
BITS
)
v
\
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
d
*
/
\
HWY_SVE_T
(
BASE
BITS
)
*
HWY_RESTRICT
p
)
{
\
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
m
p
v
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_LOAD
Load
ld1
)
HWY_SVE_FOREACH
(
HWY_SVE_MASKED_LOAD
MaskedLoad
ld1
)
HWY_SVE_FOREACH
(
HWY_SVE_LOAD_DUP128
LoadDup128
ld1rq
)
HWY_SVE_FOREACH
(
HWY_SVE_STORE
Store
st1
)
HWY_SVE_FOREACH
(
HWY_SVE_STORE
Stream
stnt1
)
HWY_SVE_FOREACH
(
HWY_SVE_MASKED_STORE
MaskedStore
st1
)
#
undef
HWY_SVE_LOAD
#
undef
HWY_SVE_MASKED_LOAD
#
undef
HWY_SVE_LOAD_DUP128
#
undef
HWY_SVE_STORE
#
undef
HWY_SVE_MASKED_STORE
template
<
size_t
N
int
kPow2
>
HWY_API
svuint16_t
Load
(
Simd
<
bfloat16_t
N
kPow2
>
d
const
bfloat16_t
*
HWY_RESTRICT
p
)
{
return
Load
(
RebindToUnsigned
<
decltype
(
d
)
>
(
)
reinterpret_cast
<
const
uint16_t
*
HWY_RESTRICT
>
(
p
)
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
void
Store
(
svuint16_t
v
Simd
<
bfloat16_t
N
kPow2
>
d
bfloat16_t
*
HWY_RESTRICT
p
)
{
Store
(
v
RebindToUnsigned
<
decltype
(
d
)
>
(
)
reinterpret_cast
<
uint16_t
*
HWY_RESTRICT
>
(
p
)
)
;
}
template
<
class
D
>
HWY_API
VFromD
<
D
>
LoadU
(
D
d
const
TFromD
<
D
>
*
HWY_RESTRICT
p
)
{
return
Load
(
d
p
)
;
}
template
<
class
V
class
D
>
HWY_API
void
StoreU
(
const
V
v
D
d
TFromD
<
D
>
*
HWY_RESTRICT
p
)
{
Store
(
v
d
p
)
;
}
#
define
HWY_SVE_SCATTER_OFFSET
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
void
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v
\
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
\
HWY_SVE_T
(
BASE
BITS
)
*
HWY_RESTRICT
base
\
HWY_SVE_V
(
int
BITS
)
offset
)
{
\
sv
#
#
OP
#
#
_s
#
#
BITS
#
#
offset_
#
#
CHAR
#
#
BITS
(
detail
:
:
MakeMask
(
d
)
base
offset
\
v
)
;
\
}
#
define
HWY_SVE_SCATTER_INDEX
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
void
NAME
(
\
HWY_SVE_V
(
BASE
BITS
)
v
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
\
HWY_SVE_T
(
BASE
BITS
)
*
HWY_RESTRICT
base
HWY_SVE_V
(
int
BITS
)
index
)
{
\
sv
#
#
OP
#
#
_s
#
#
BITS
#
#
index_
#
#
CHAR
#
#
BITS
(
detail
:
:
MakeMask
(
d
)
base
index
v
)
;
\
}
HWY_SVE_FOREACH_UIF3264
(
HWY_SVE_SCATTER_OFFSET
ScatterOffset
st1_scatter
)
HWY_SVE_FOREACH_UIF3264
(
HWY_SVE_SCATTER_INDEX
ScatterIndex
st1_scatter
)
#
undef
HWY_SVE_SCATTER_OFFSET
#
undef
HWY_SVE_SCATTER_INDEX
#
define
HWY_SVE_GATHER_OFFSET
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
\
const
HWY_SVE_T
(
BASE
BITS
)
*
HWY_RESTRICT
base
\
HWY_SVE_V
(
int
BITS
)
offset
)
{
\
return
sv
#
#
OP
#
#
_s
#
#
BITS
#
#
offset_
#
#
CHAR
#
#
BITS
(
detail
:
:
MakeMask
(
d
)
base
\
offset
)
;
\
}
#
define
HWY_SVE_GATHER_INDEX
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
\
const
HWY_SVE_T
(
BASE
BITS
)
*
HWY_RESTRICT
base
\
HWY_SVE_V
(
int
BITS
)
index
)
{
\
return
sv
#
#
OP
#
#
_s
#
#
BITS
#
#
index_
#
#
CHAR
#
#
BITS
(
detail
:
:
MakeMask
(
d
)
base
\
index
)
;
\
}
HWY_SVE_FOREACH_UIF3264
(
HWY_SVE_GATHER_OFFSET
GatherOffset
ld1_gather
)
HWY_SVE_FOREACH_UIF3264
(
HWY_SVE_GATHER_INDEX
GatherIndex
ld1_gather
)
#
undef
HWY_SVE_GATHER_OFFSET
#
undef
HWY_SVE_GATHER_INDEX
#
define
HWY_SVE_STORE3
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
void
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v0
HWY_SVE_V
(
BASE
BITS
)
v1
\
HWY_SVE_V
(
BASE
BITS
)
v2
\
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
\
HWY_SVE_T
(
BASE
BITS
)
*
HWY_RESTRICT
unaligned
)
{
\
const
sv
#
#
BASE
#
#
BITS
#
#
x3_t
triple
=
svcreate3
#
#
_
#
#
CHAR
#
#
BITS
(
v0
v1
v2
)
;
\
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
detail
:
:
MakeMask
(
d
)
unaligned
triple
)
;
\
}
HWY_SVE_FOREACH_U08
(
HWY_SVE_STORE3
StoreInterleaved3
st3
)
#
undef
HWY_SVE_STORE3
#
define
HWY_SVE_STORE4
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
void
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v0
HWY_SVE_V
(
BASE
BITS
)
v1
\
HWY_SVE_V
(
BASE
BITS
)
v2
HWY_SVE_V
(
BASE
BITS
)
v3
\
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
\
HWY_SVE_T
(
BASE
BITS
)
*
HWY_RESTRICT
unaligned
)
{
\
const
sv
#
#
BASE
#
#
BITS
#
#
x4_t
quad
=
\
svcreate4
#
#
_
#
#
CHAR
#
#
BITS
(
v0
v1
v2
v3
)
;
\
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
detail
:
:
MakeMask
(
d
)
unaligned
quad
)
;
\
}
HWY_SVE_FOREACH_U08
(
HWY_SVE_STORE4
StoreInterleaved4
st4
)
#
undef
HWY_SVE_STORE4
#
define
HWY_SVE_PROMOTE_TO
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
NAME
(
\
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
tag
*
/
HWY_SVE_V
(
BASE
HALF
)
v
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
v
)
;
\
}
HWY_SVE_FOREACH_UI16
(
HWY_SVE_PROMOTE_TO
PromoteTo
unpklo
)
HWY_SVE_FOREACH_UI32
(
HWY_SVE_PROMOTE_TO
PromoteTo
unpklo
)
HWY_SVE_FOREACH_UI64
(
HWY_SVE_PROMOTE_TO
PromoteTo
unpklo
)
template
<
size_t
N
int
kPow2
>
HWY_API
svuint32_t
PromoteTo
(
Simd
<
uint32_t
N
kPow2
>
dto
svuint8_t
vfrom
)
{
const
RepartitionToWide
<
DFromV
<
decltype
(
vfrom
)
>
>
d2
;
return
PromoteTo
(
dto
PromoteTo
(
d2
vfrom
)
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svint32_t
PromoteTo
(
Simd
<
int32_t
N
kPow2
>
dto
svint8_t
vfrom
)
{
const
RepartitionToWide
<
DFromV
<
decltype
(
vfrom
)
>
>
d2
;
return
PromoteTo
(
dto
PromoteTo
(
d2
vfrom
)
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svuint32_t
U32FromU8
(
svuint8_t
v
)
{
return
PromoteTo
(
Simd
<
uint32_t
N
kPow2
>
(
)
v
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svint16_t
PromoteTo
(
Simd
<
int16_t
N
kPow2
>
dto
svuint8_t
vfrom
)
{
const
RebindToUnsigned
<
decltype
(
dto
)
>
du
;
return
BitCast
(
dto
PromoteTo
(
du
vfrom
)
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svint32_t
PromoteTo
(
Simd
<
int32_t
N
kPow2
>
dto
svuint16_t
vfrom
)
{
const
RebindToUnsigned
<
decltype
(
dto
)
>
du
;
return
BitCast
(
dto
PromoteTo
(
du
vfrom
)
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svint32_t
PromoteTo
(
Simd
<
int32_t
N
kPow2
>
dto
svuint8_t
vfrom
)
{
const
Repartition
<
uint16_t
DFromV
<
decltype
(
vfrom
)
>
>
du16
;
const
Repartition
<
int16_t
decltype
(
du16
)
>
di16
;
return
PromoteTo
(
dto
BitCast
(
di16
PromoteTo
(
du16
vfrom
)
)
)
;
}
namespace
detail
{
HWY_SVE_FOREACH
(
HWY_SVE_RETV_ARGVV
ZipLower
zip1
)
}
template
<
size_t
N
int
kPow2
>
HWY_API
svfloat32_t
PromoteTo
(
Simd
<
float32_t
N
kPow2
>
const
svfloat16_t
v
)
{
const
svfloat16_t
vv
=
detail
:
:
ZipLower
(
v
v
)
;
return
svcvt_f32_f16_x
(
detail
:
:
PTrue
(
Simd
<
float16_t
N
kPow2
>
(
)
)
vv
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svfloat64_t
PromoteTo
(
Simd
<
float64_t
N
kPow2
>
const
svfloat32_t
v
)
{
const
svfloat32_t
vv
=
detail
:
:
ZipLower
(
v
v
)
;
return
svcvt_f64_f32_x
(
detail
:
:
PTrue
(
Simd
<
float32_t
N
kPow2
>
(
)
)
vv
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svfloat64_t
PromoteTo
(
Simd
<
float64_t
N
kPow2
>
const
svint32_t
v
)
{
const
svint32_t
vv
=
detail
:
:
ZipLower
(
v
v
)
;
return
svcvt_f64_s32_x
(
detail
:
:
PTrue
(
Simd
<
int32_t
N
kPow2
>
(
)
)
vv
)
;
}
namespace
detail
{
HWY_SVE_FOREACH_UI32
(
HWY_SVE_PROMOTE_TO
PromoteUpperTo
unpkhi
)
#
undef
HWY_SVE_PROMOTE_TO
template
<
size_t
N
int
kPow2
>
HWY_API
svfloat32_t
PromoteUpperTo
(
Simd
<
float
N
kPow2
>
df
svfloat16_t
v
)
{
const
RebindToUnsigned
<
decltype
(
df
)
>
du
;
const
RepartitionToNarrow
<
decltype
(
du
)
>
dn
;
return
BitCast
(
df
PromoteUpperTo
(
du
BitCast
(
dn
v
)
)
)
;
}
}
namespace
detail
{
template
<
typename
TN
class
VU
>
VU
SaturateU
(
VU
v
)
{
return
detail
:
:
MinN
(
v
static_cast
<
TFromV
<
VU
>
>
(
LimitsMax
<
TN
>
(
)
)
)
;
}
template
<
typename
TN
class
VI
>
VI
SaturateI
(
VI
v
)
{
return
detail
:
:
MinN
(
detail
:
:
MaxN
(
v
LimitsMin
<
TN
>
(
)
)
LimitsMax
<
TN
>
(
)
)
;
}
}
template
<
size_t
N
int
kPow2
>
HWY_API
svuint8_t
DemoteTo
(
Simd
<
uint8_t
N
kPow2
>
dn
const
svint16_t
v
)
{
const
DFromV
<
decltype
(
v
)
>
di
;
const
RebindToUnsigned
<
decltype
(
di
)
>
du
;
using
TN
=
TFromD
<
decltype
(
dn
)
>
;
const
svuint16_t
clamped
=
BitCast
(
du
detail
:
:
MaxN
(
v
0
)
)
;
const
svuint8_t
vn
=
BitCast
(
dn
detail
:
:
SaturateU
<
TN
>
(
clamped
)
)
;
return
svuzp1_u8
(
vn
vn
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svuint16_t
DemoteTo
(
Simd
<
uint16_t
N
kPow2
>
dn
const
svint32_t
v
)
{
const
DFromV
<
decltype
(
v
)
>
di
;
const
RebindToUnsigned
<
decltype
(
di
)
>
du
;
using
TN
=
TFromD
<
decltype
(
dn
)
>
;
const
svuint32_t
clamped
=
BitCast
(
du
detail
:
:
MaxN
(
v
0
)
)
;
const
svuint16_t
vn
=
BitCast
(
dn
detail
:
:
SaturateU
<
TN
>
(
clamped
)
)
;
return
svuzp1_u16
(
vn
vn
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svuint8_t
DemoteTo
(
Simd
<
uint8_t
N
kPow2
>
dn
const
svint32_t
v
)
{
const
DFromV
<
decltype
(
v
)
>
di
;
const
RebindToUnsigned
<
decltype
(
di
)
>
du
;
const
RepartitionToNarrow
<
decltype
(
du
)
>
d2
;
using
TN
=
TFromD
<
decltype
(
dn
)
>
;
const
svuint32_t
clamped
=
BitCast
(
du
detail
:
:
MaxN
(
v
0
)
)
;
const
svuint16_t
cast16
=
BitCast
(
d2
detail
:
:
SaturateU
<
TN
>
(
clamped
)
)
;
const
svuint8_t
x2
=
BitCast
(
dn
svuzp1_u16
(
cast16
cast16
)
)
;
return
svuzp1_u8
(
x2
x2
)
;
}
HWY_API
svuint8_t
U8FromU32
(
const
svuint32_t
v
)
{
const
DFromV
<
svuint32_t
>
du32
;
const
RepartitionToNarrow
<
decltype
(
du32
)
>
du16
;
const
RepartitionToNarrow
<
decltype
(
du16
)
>
du8
;
const
svuint16_t
cast16
=
BitCast
(
du16
v
)
;
const
svuint16_t
x2
=
svuzp1_u16
(
cast16
cast16
)
;
const
svuint8_t
cast8
=
BitCast
(
du8
x2
)
;
return
svuzp1_u8
(
cast8
cast8
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svint8_t
DemoteTo
(
Simd
<
int8_t
N
kPow2
>
dn
const
svint16_t
v
)
{
#
if
HWY_TARGET
=
=
HWY_SVE2
const
svint8_t
vn
=
BitCast
(
dn
svqxtnb_s16
(
v
)
)
;
#
else
using
TN
=
TFromD
<
decltype
(
dn
)
>
;
const
svint8_t
vn
=
BitCast
(
dn
detail
:
:
SaturateI
<
TN
>
(
v
)
)
;
#
endif
return
svuzp1_s8
(
vn
vn
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svint16_t
DemoteTo
(
Simd
<
int16_t
N
kPow2
>
dn
const
svint32_t
v
)
{
#
if
HWY_TARGET
=
=
HWY_SVE2
const
svint16_t
vn
=
BitCast
(
dn
svqxtnb_s32
(
v
)
)
;
#
else
using
TN
=
TFromD
<
decltype
(
dn
)
>
;
const
svint16_t
vn
=
BitCast
(
dn
detail
:
:
SaturateI
<
TN
>
(
v
)
)
;
#
endif
return
svuzp1_s16
(
vn
vn
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svint8_t
DemoteTo
(
Simd
<
int8_t
N
kPow2
>
dn
const
svint32_t
v
)
{
const
RepartitionToWide
<
decltype
(
dn
)
>
d2
;
#
if
HWY_TARGET
=
=
HWY_SVE2
const
svint16_t
cast16
=
BitCast
(
d2
svqxtnb_s16
(
svqxtnb_s32
(
v
)
)
)
;
#
else
using
TN
=
TFromD
<
decltype
(
dn
)
>
;
const
svint16_t
cast16
=
BitCast
(
d2
detail
:
:
SaturateI
<
TN
>
(
v
)
)
;
#
endif
const
svint8_t
v2
=
BitCast
(
dn
svuzp1_s16
(
cast16
cast16
)
)
;
return
BitCast
(
dn
svuzp1_s8
(
v2
v2
)
)
;
}
namespace
detail
{
#
define
HWY_SVE_CONCAT_EVERY_SECOND
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_INLINE
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_V
(
BASE
BITS
)
hi
HWY_SVE_V
(
BASE
BITS
)
lo
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
lo
hi
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_CONCAT_EVERY_SECOND
ConcatEven
uzp1
)
HWY_SVE_FOREACH
(
HWY_SVE_CONCAT_EVERY_SECOND
ConcatOdd
uzp2
)
#
undef
HWY_SVE_CONCAT_EVERY_SECOND
#
define
HWY_SVE_SPLICE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
NAME
(
\
HWY_SVE_V
(
BASE
BITS
)
hi
HWY_SVE_V
(
BASE
BITS
)
lo
svbool_t
mask
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
mask
lo
hi
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_SPLICE
Splice
splice
)
#
undef
HWY_SVE_SPLICE
}
template
<
class
D
>
HWY_API
VFromD
<
D
>
ConcatOdd
(
D
d
VFromD
<
D
>
hi
VFromD
<
D
>
lo
)
{
#
if
0
return
detail
:
:
ConcatOdd
(
hi
lo
)
;
#
else
const
VFromD
<
D
>
hi_odd
=
detail
:
:
ConcatOdd
(
hi
hi
)
;
const
VFromD
<
D
>
lo_odd
=
detail
:
:
ConcatOdd
(
lo
lo
)
;
return
detail
:
:
Splice
(
hi_odd
lo_odd
FirstN
(
d
Lanes
(
d
)
/
2
)
)
;
#
endif
}
template
<
class
D
>
HWY_API
VFromD
<
D
>
ConcatEven
(
D
d
VFromD
<
D
>
hi
VFromD
<
D
>
lo
)
{
#
if
0
return
detail
:
:
ConcatEven
(
hi
lo
)
;
#
else
const
VFromD
<
D
>
hi_odd
=
detail
:
:
ConcatEven
(
hi
hi
)
;
const
VFromD
<
D
>
lo_odd
=
detail
:
:
ConcatEven
(
lo
lo
)
;
return
detail
:
:
Splice
(
hi_odd
lo_odd
FirstN
(
d
Lanes
(
d
)
/
2
)
)
;
#
endif
}
template
<
size_t
N
int
kPow2
>
HWY_API
svfloat16_t
DemoteTo
(
Simd
<
float16_t
N
kPow2
>
d
const
svfloat32_t
v
)
{
const
svfloat16_t
in_even
=
svcvt_f16_f32_x
(
detail
:
:
PTrue
(
d
)
v
)
;
return
detail
:
:
ConcatEven
(
in_even
in_even
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svuint16_t
DemoteTo
(
Simd
<
bfloat16_t
N
kPow2
>
svfloat32_t
v
)
{
const
svuint16_t
in_even
=
BitCast
(
ScalableTag
<
uint16_t
>
(
)
v
)
;
return
detail
:
:
ConcatOdd
(
in_even
in_even
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svfloat32_t
DemoteTo
(
Simd
<
float32_t
N
kPow2
>
d
const
svfloat64_t
v
)
{
const
svfloat32_t
in_even
=
svcvt_f32_f64_x
(
detail
:
:
PTrue
(
d
)
v
)
;
return
detail
:
:
ConcatEven
(
in_even
in_even
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svint32_t
DemoteTo
(
Simd
<
int32_t
N
kPow2
>
d
const
svfloat64_t
v
)
{
const
svint32_t
in_even
=
svcvt_s32_f64_x
(
detail
:
:
PTrue
(
d
)
v
)
;
return
detail
:
:
ConcatEven
(
in_even
in_even
)
;
}
#
define
HWY_SVE_CONVERT
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
d
*
/
HWY_SVE_V
(
int
BITS
)
v
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
#
#
_s
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
v
)
;
\
}
\
/
*
Truncates
(
rounds
toward
zero
)
.
*
/
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
int
BITS
)
\
NAME
(
HWY_SVE_D
(
int
BITS
N
kPow2
)
/
*
d
*
/
HWY_SVE_V
(
BASE
BITS
)
v
)
{
\
return
sv
#
#
OP
#
#
_s
#
#
BITS
#
#
_
#
#
CHAR
#
#
BITS
#
#
_x
(
HWY_SVE_PTRUE
(
BITS
)
v
)
;
\
}
HWY_SVE_FOREACH_F
(
HWY_SVE_CONVERT
ConvertTo
cvt
)
#
undef
HWY_SVE_CONVERT
template
<
class
VF
class
DI
=
RebindToSigned
<
DFromV
<
VF
>
>
>
HWY_API
VFromD
<
DI
>
NearestInt
(
VF
v
)
{
return
ConvertTo
(
DI
(
)
Round
(
v
)
)
;
}
#
define
HWY_SVE_IOTA
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
/
*
d
*
/
\
HWY_SVE_T
(
BASE
BITS
)
first
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
first
1
)
;
\
}
HWY_SVE_FOREACH_UI
(
HWY_SVE_IOTA
Iota
index
)
#
undef
HWY_SVE_IOTA
template
<
class
D
HWY_IF_FLOAT_D
(
D
)
>
HWY_API
VFromD
<
D
>
Iota
(
const
D
d
TFromD
<
D
>
first
)
{
const
RebindToSigned
<
D
>
di
;
return
detail
:
:
AddN
(
ConvertTo
(
d
Iota
(
di
0
)
)
first
)
;
}
namespace
detail
{
template
<
class
D
>
svbool_t
MaskLowerHalf
(
D
d
)
{
return
FirstN
(
d
Lanes
(
d
)
/
2
)
;
}
template
<
class
D
>
svbool_t
MaskUpperHalf
(
D
d
)
{
return
AndNot
(
MaskLowerHalf
(
d
)
detail
:
:
MakeMask
(
d
)
)
;
}
#
define
HWY_SVE_EXT
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
kIndex
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_V
(
BASE
BITS
)
hi
HWY_SVE_V
(
BASE
BITS
)
lo
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
lo
hi
kIndex
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_EXT
Ext
ext
)
#
undef
HWY_SVE_EXT
}
template
<
class
D
class
V
>
HWY_API
V
ConcatUpperLower
(
const
D
d
const
V
hi
const
V
lo
)
{
return
IfThenElse
(
detail
:
:
MaskLowerHalf
(
d
)
lo
hi
)
;
}
template
<
class
D
class
V
>
HWY_API
V
ConcatLowerLower
(
const
D
d
const
V
hi
const
V
lo
)
{
return
detail
:
:
Splice
(
hi
lo
detail
:
:
MaskLowerHalf
(
d
)
)
;
}
template
<
class
D
class
V
>
HWY_API
V
ConcatLowerUpper
(
const
D
d
const
V
hi
const
V
lo
)
{
return
detail
:
:
Splice
(
hi
lo
detail
:
:
MaskUpperHalf
(
d
)
)
;
}
template
<
class
D
class
V
>
HWY_API
V
ConcatUpperUpper
(
const
D
d
const
V
hi
const
V
lo
)
{
const
svbool_t
mask_upper
=
detail
:
:
MaskUpperHalf
(
d
)
;
const
V
lo_upper
=
detail
:
:
Splice
(
lo
lo
mask_upper
)
;
return
IfThenElse
(
mask_upper
hi
lo_upper
)
;
}
template
<
class
D
class
V2
>
HWY_API
VFromD
<
D
>
Combine
(
const
D
d
const
V2
hi
const
V2
lo
)
{
return
ConcatLowerLower
(
d
hi
lo
)
;
}
template
<
class
D
class
V
>
HWY_API
V
ZeroExtendVector
(
const
D
d
const
V
lo
)
{
return
Combine
(
d
Zero
(
Half
<
D
>
(
)
)
lo
)
;
}
template
<
class
D2
class
V
>
HWY_API
V
LowerHalf
(
D2
const
V
v
)
{
return
v
;
}
template
<
class
V
>
HWY_API
V
LowerHalf
(
const
V
v
)
{
return
v
;
}
template
<
class
D2
class
V
>
HWY_API
V
UpperHalf
(
const
D2
const
V
v
)
{
return
detail
:
:
Splice
(
v
v
detail
:
:
MaskUpperHalf
(
Twice
<
D2
>
(
)
)
)
;
}
#
define
HWY_SVE_GET_LANE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_T
(
BASE
BITS
)
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
detail
:
:
PFalse
(
)
v
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_GET_LANE
GetLane
lasta
)
#
undef
HWY_SVE_GET_LANE
namespace
detail
{
HWY_SVE_FOREACH
(
HWY_SVE_RETV_ARGVV
InterleaveEven
trn1
)
}
template
<
class
V
>
HWY_API
V
DupEven
(
const
V
v
)
{
return
detail
:
:
InterleaveEven
(
v
v
)
;
}
namespace
detail
{
HWY_SVE_FOREACH
(
HWY_SVE_RETV_ARGVV
InterleaveOdd
trn2
)
}
template
<
class
V
>
HWY_API
V
DupOdd
(
const
V
v
)
{
return
detail
:
:
InterleaveOdd
(
v
v
)
;
}
namespace
detail
{
HWY_SVE_FOREACH
(
HWY_SVE_RETV_ARGVN
Insert
insr_n
)
}
template
<
class
V
>
HWY_API
V
OddEven
(
const
V
odd
const
V
even
)
{
const
auto
even_in_odd
=
detail
:
:
Insert
(
even
0
)
;
return
detail
:
:
InterleaveOdd
(
even_in_odd
odd
)
;
}
template
<
class
V
>
HWY_API
V
OddEvenBlocks
(
const
V
odd
const
V
even
)
{
const
RebindToUnsigned
<
DFromV
<
V
>
>
du
;
using
TU
=
TFromD
<
decltype
(
du
)
>
;
constexpr
size_t
kShift
=
CeilLog2
(
16
/
sizeof
(
TU
)
)
;
const
auto
idx_block
=
ShiftRight
<
kShift
>
(
Iota
(
du
0
)
)
;
const
auto
lsb
=
detail
:
:
AndN
(
idx_block
static_cast
<
TU
>
(
1
)
)
;
const
svbool_t
is_even
=
detail
:
:
EqN
(
lsb
static_cast
<
TU
>
(
0
)
)
;
return
IfThenElse
(
is_even
even
odd
)
;
}
template
<
class
D
class
VI
>
HWY_API
VFromD
<
RebindToUnsigned
<
D
>
>
IndicesFromVec
(
D
d
VI
vec
)
{
using
TI
=
TFromV
<
VI
>
;
static_assert
(
sizeof
(
TFromD
<
D
>
)
=
=
sizeof
(
TI
)
"
Index
/
lane
size
mismatch
"
)
;
const
RebindToUnsigned
<
D
>
du
;
const
auto
indices
=
BitCast
(
du
vec
)
;
#
if
HWY_IS_DEBUG_BUILD
HWY_DASSERT
(
AllTrue
(
du
detail
:
:
LtN
(
indices
static_cast
<
TI
>
(
Lanes
(
d
)
)
)
)
)
;
#
else
(
void
)
d
;
#
endif
return
indices
;
}
template
<
class
D
typename
TI
>
HWY_API
VFromD
<
RebindToUnsigned
<
D
>
>
SetTableIndices
(
D
d
const
TI
*
idx
)
{
static_assert
(
sizeof
(
TFromD
<
D
>
)
=
=
sizeof
(
TI
)
"
Index
size
must
match
lane
"
)
;
return
IndicesFromVec
(
d
LoadU
(
Rebind
<
TI
D
>
(
)
idx
)
)
;
}
#
define
HWY_SVE_TABLE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v
HWY_SVE_V
(
uint
BITS
)
idx
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
v
idx
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_TABLE
TableLookupLanes
tbl
)
#
undef
HWY_SVE_TABLE
namespace
detail
{
template
<
typename
T
size_t
N
int
kPow2
>
constexpr
size_t
LanesPerBlock
(
Simd
<
T
N
kPow2
>
)
{
return
HWY_MIN
(
16
/
sizeof
(
T
)
detail
:
:
ScaleByPower
(
N
kPow2
)
)
;
}
}
template
<
class
V
>
HWY_API
V
SwapAdjacentBlocks
(
const
V
v
)
{
const
DFromV
<
V
>
d
;
const
RebindToUnsigned
<
decltype
(
d
)
>
du
;
constexpr
auto
kLanesPerBlock
=
static_cast
<
TFromV
<
V
>
>
(
detail
:
:
LanesPerBlock
(
d
)
)
;
const
VFromD
<
decltype
(
du
)
>
idx
=
detail
:
:
XorN
(
Iota
(
du
0
)
kLanesPerBlock
)
;
return
TableLookupLanes
(
v
idx
)
;
}
#
if
0
#
error
"
Update
macro
"
#
endif
#
define
HWY_SVE_REVERSE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
HWY_SVE_V
(
BASE
BITS
)
v
)
{
\
const
auto
reversed
=
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
v
)
;
\
/
*
Shift
right
to
remove
extra
(
non
-
pow2
and
remainder
)
lanes
.
*
/
\
const
size_t
all_lanes
=
\
detail
:
:
AllHardwareLanes
(
hwy
:
:
SizeTag
<
BITS
/
8
>
(
)
)
;
\
/
*
TODO
(
janwas
)
:
on
SVE2
use
whilege
.
*
/
\
/
*
Avoids
FirstN
truncating
to
the
return
vector
size
.
*
/
\
const
ScalableTag
<
HWY_SVE_T
(
BASE
BITS
)
>
dfull
;
\
const
svbool_t
mask
=
Not
(
FirstN
(
dfull
all_lanes
-
Lanes
(
d
)
)
)
;
\
return
detail
:
:
Splice
(
reversed
reversed
mask
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_REVERSE
Reverse
rev
)
#
undef
HWY_SVE_REVERSE
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
2
)
>
HWY_API
VFromD
<
D
>
Reverse2
(
D
d
const
VFromD
<
D
>
v
)
{
const
RebindToUnsigned
<
decltype
(
d
)
>
du
;
const
RepartitionToWide
<
decltype
(
du
)
>
dw
;
return
BitCast
(
d
svrevh_u32_x
(
detail
:
:
PTrue
(
d
)
BitCast
(
dw
v
)
)
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
4
)
>
HWY_API
VFromD
<
D
>
Reverse2
(
D
d
const
VFromD
<
D
>
v
)
{
const
RebindToUnsigned
<
decltype
(
d
)
>
du
;
const
RepartitionToWide
<
decltype
(
du
)
>
dw
;
return
BitCast
(
d
svrevw_u64_x
(
detail
:
:
PTrue
(
d
)
BitCast
(
dw
v
)
)
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
8
)
>
HWY_API
VFromD
<
D
>
Reverse2
(
D
const
VFromD
<
D
>
v
)
{
const
auto
even_in_odd
=
detail
:
:
Insert
(
v
0
)
;
return
detail
:
:
InterleaveOdd
(
v
even_in_odd
)
;
}
template
<
class
D
>
HWY_API
VFromD
<
D
>
Reverse4
(
D
d
const
VFromD
<
D
>
v
)
{
const
RebindToUnsigned
<
decltype
(
d
)
>
du
;
const
auto
idx
=
detail
:
:
XorN
(
Iota
(
du
0
)
3
)
;
return
TableLookupLanes
(
v
idx
)
;
}
template
<
class
D
>
HWY_API
VFromD
<
D
>
Reverse8
(
D
d
const
VFromD
<
D
>
v
)
{
const
RebindToUnsigned
<
decltype
(
d
)
>
du
;
const
auto
idx
=
detail
:
:
XorN
(
Iota
(
du
0
)
7
)
;
return
TableLookupLanes
(
v
idx
)
;
}
#
define
HWY_SVE_COMPRESS
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
NAME
(
HWY_SVE_V
(
BASE
BITS
)
v
svbool_t
mask
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
mask
v
)
;
\
}
HWY_SVE_FOREACH_UIF3264
(
HWY_SVE_COMPRESS
Compress
compact
)
#
undef
HWY_SVE_COMPRESS
template
<
class
V
HWY_IF_LANE_SIZE_V
(
V
2
)
>
HWY_API
V
Compress
(
V
v
svbool_t
mask16
)
{
static_assert
(
!
IsSame
<
V
svfloat16_t
>
(
)
"
Must
use
overload
"
)
;
const
DFromV
<
V
>
d16
;
const
RepartitionToWide
<
decltype
(
d16
)
>
dw
;
const
auto
v32L
=
PromoteTo
(
dw
v
)
;
const
auto
v32H
=
detail
:
:
PromoteUpperTo
(
dw
v
)
;
const
svbool_t
mask32L
=
svunpklo_b
(
mask16
)
;
const
svbool_t
mask32H
=
svunpkhi_b
(
mask16
)
;
const
auto
compressedL
=
Compress
(
v32L
mask32L
)
;
const
auto
compressedH
=
Compress
(
v32H
mask32H
)
;
const
V
evenL
=
BitCast
(
d16
compressedL
)
;
const
V
evenH
=
BitCast
(
d16
compressedH
)
;
const
V
v16L
=
detail
:
:
ConcatEven
(
evenL
evenL
)
;
const
V
v16H
=
detail
:
:
ConcatEven
(
evenH
evenH
)
;
const
size_t
countL
=
detail
:
:
CountTrueFull
(
dw
mask32L
)
;
const
auto
compressed_maskL
=
FirstN
(
d16
countL
)
;
return
detail
:
:
Splice
(
v16H
v16L
compressed_maskL
)
;
}
HWY_API
svfloat16_t
Compress
(
svfloat16_t
v
svbool_t
mask16
)
{
const
DFromV
<
decltype
(
v
)
>
df
;
const
RebindToSigned
<
decltype
(
df
)
>
di
;
return
BitCast
(
df
Compress
(
BitCast
(
di
v
)
mask16
)
)
;
}
template
<
class
V
class
M
class
D
>
HWY_API
size_t
CompressStore
(
const
V
v
const
M
mask
const
D
d
TFromD
<
D
>
*
HWY_RESTRICT
unaligned
)
{
StoreU
(
Compress
(
v
mask
)
d
unaligned
)
;
return
CountTrue
(
d
mask
)
;
}
template
<
class
V
class
M
class
D
>
HWY_API
size_t
CompressBlendedStore
(
const
V
v
const
M
mask
const
D
d
TFromD
<
D
>
*
HWY_RESTRICT
unaligned
)
{
const
size_t
count
=
CountTrue
(
d
mask
)
;
const
svbool_t
store_mask
=
FirstN
(
d
count
)
;
MaskedStore
(
store_mask
Compress
(
v
mask
)
d
unaligned
)
;
return
count
;
}
namespace
detail
{
template
<
class
D
class
V
>
HWY_INLINE
V
OffsetsOf128BitBlocks
(
const
D
d
const
V
iota0
)
{
using
T
=
MakeUnsigned
<
TFromD
<
D
>
>
;
return
detail
:
:
AndNotN
(
static_cast
<
T
>
(
LanesPerBlock
(
d
)
-
1
)
iota0
)
;
}
template
<
size_t
kLanes
class
D
>
svbool_t
FirstNPerBlock
(
D
d
)
{
const
RebindToSigned
<
decltype
(
d
)
>
di
;
constexpr
size_t
kLanesPerBlock
=
detail
:
:
LanesPerBlock
(
di
)
;
const
auto
idx_mod
=
detail
:
:
AndN
(
Iota
(
di
0
)
kLanesPerBlock
-
1
)
;
return
detail
:
:
LtN
(
BitCast
(
di
idx_mod
)
kLanes
)
;
}
}
template
<
size_t
kBytes
class
D
class
V
=
VFromD
<
D
>
>
HWY_API
V
CombineShiftRightBytes
(
const
D
d
const
V
hi
const
V
lo
)
{
const
Repartition
<
uint8_t
decltype
(
d
)
>
d8
;
const
auto
hi8
=
BitCast
(
d8
hi
)
;
const
auto
lo8
=
BitCast
(
d8
lo
)
;
const
auto
hi_up
=
detail
:
:
Splice
(
hi8
hi8
FirstN
(
d8
16
-
kBytes
)
)
;
const
auto
lo_down
=
detail
:
:
Ext
<
kBytes
>
(
lo8
lo8
)
;
const
svbool_t
is_lo
=
detail
:
:
FirstNPerBlock
<
16
-
kBytes
>
(
d8
)
;
return
BitCast
(
d
IfThenElse
(
is_lo
lo_down
hi_up
)
)
;
}
template
<
class
V
>
HWY_API
V
Shuffle2301
(
const
V
v
)
{
const
DFromV
<
V
>
d
;
static_assert
(
sizeof
(
TFromD
<
decltype
(
d
)
>
)
=
=
4
"
Defined
for
32
-
bit
types
"
)
;
return
Reverse2
(
d
v
)
;
}
template
<
class
V
>
HWY_API
V
Shuffle2103
(
const
V
v
)
{
const
DFromV
<
V
>
d
;
const
Repartition
<
uint8_t
decltype
(
d
)
>
d8
;
static_assert
(
sizeof
(
TFromD
<
decltype
(
d
)
>
)
=
=
4
"
Defined
for
32
-
bit
types
"
)
;
const
svuint8_t
v8
=
BitCast
(
d8
v
)
;
return
BitCast
(
d
CombineShiftRightBytes
<
12
>
(
d8
v8
v8
)
)
;
}
template
<
class
V
>
HWY_API
V
Shuffle0321
(
const
V
v
)
{
const
DFromV
<
V
>
d
;
const
Repartition
<
uint8_t
decltype
(
d
)
>
d8
;
static_assert
(
sizeof
(
TFromD
<
decltype
(
d
)
>
)
=
=
4
"
Defined
for
32
-
bit
types
"
)
;
const
svuint8_t
v8
=
BitCast
(
d8
v
)
;
return
BitCast
(
d
CombineShiftRightBytes
<
4
>
(
d8
v8
v8
)
)
;
}
template
<
class
V
>
HWY_API
V
Shuffle1032
(
const
V
v
)
{
const
DFromV
<
V
>
d
;
const
Repartition
<
uint8_t
decltype
(
d
)
>
d8
;
static_assert
(
sizeof
(
TFromD
<
decltype
(
d
)
>
)
=
=
4
"
Defined
for
32
-
bit
types
"
)
;
const
svuint8_t
v8
=
BitCast
(
d8
v
)
;
return
BitCast
(
d
CombineShiftRightBytes
<
8
>
(
d8
v8
v8
)
)
;
}
template
<
class
V
>
HWY_API
V
Shuffle01
(
const
V
v
)
{
const
DFromV
<
V
>
d
;
const
Repartition
<
uint8_t
decltype
(
d
)
>
d8
;
static_assert
(
sizeof
(
TFromD
<
decltype
(
d
)
>
)
=
=
8
"
Defined
for
64
-
bit
types
"
)
;
const
svuint8_t
v8
=
BitCast
(
d8
v
)
;
return
BitCast
(
d
CombineShiftRightBytes
<
8
>
(
d8
v8
v8
)
)
;
}
template
<
class
V
>
HWY_API
V
Shuffle0123
(
const
V
v
)
{
return
Shuffle2301
(
Shuffle1032
(
v
)
)
;
}
template
<
class
D
class
V
=
VFromD
<
D
>
>
HWY_API
V
ReverseBlocks
(
D
d
V
v
)
{
const
Repartition
<
uint64_t
D
>
du64
;
return
BitCast
(
d
Shuffle01
(
Reverse
(
du64
BitCast
(
du64
v
)
)
)
)
;
}
template
<
class
V
class
VI
>
HWY_API
VI
TableLookupBytes
(
const
V
v
const
VI
idx
)
{
const
DFromV
<
VI
>
d
;
const
Repartition
<
uint8_t
decltype
(
d
)
>
du8
;
const
auto
offsets128
=
detail
:
:
OffsetsOf128BitBlocks
(
du8
Iota
(
du8
0
)
)
;
const
auto
idx8
=
Add
(
BitCast
(
du8
idx
)
offsets128
)
;
return
BitCast
(
d
TableLookupLanes
(
BitCast
(
du8
v
)
idx8
)
)
;
}
template
<
class
V
class
VI
>
HWY_API
VI
TableLookupBytesOr0
(
const
V
v
const
VI
idx
)
{
const
DFromV
<
VI
>
d
;
const
Repartition
<
int8_t
decltype
(
d
)
>
di8
;
auto
idx8
=
BitCast
(
di8
idx
)
;
const
auto
msb
=
detail
:
:
LtN
(
idx8
0
)
;
const
auto
lookup
=
TableLookupBytes
(
BitCast
(
di8
v
)
idx8
)
;
return
BitCast
(
d
IfThenZeroElse
(
msb
lookup
)
)
;
}
template
<
int
kLane
class
V
>
HWY_API
V
Broadcast
(
const
V
v
)
{
const
DFromV
<
V
>
d
;
const
RebindToUnsigned
<
decltype
(
d
)
>
du
;
constexpr
size_t
kLanesPerBlock
=
detail
:
:
LanesPerBlock
(
du
)
;
static_assert
(
0
<
=
kLane
&
&
kLane
<
kLanesPerBlock
"
Invalid
lane
"
)
;
auto
idx
=
detail
:
:
OffsetsOf128BitBlocks
(
du
Iota
(
du
0
)
)
;
if
(
kLane
!
=
0
)
{
idx
=
detail
:
:
AddN
(
idx
kLane
)
;
}
return
TableLookupLanes
(
v
idx
)
;
}
template
<
size_t
kLanes
class
D
class
V
=
VFromD
<
D
>
>
HWY_API
V
ShiftLeftLanes
(
D
d
const
V
v
)
{
const
auto
zero
=
Zero
(
d
)
;
const
auto
shifted
=
detail
:
:
Splice
(
v
zero
FirstN
(
d
kLanes
)
)
;
return
IfThenElse
(
detail
:
:
FirstNPerBlock
<
kLanes
>
(
d
)
zero
shifted
)
;
}
template
<
size_t
kLanes
class
V
>
HWY_API
V
ShiftLeftLanes
(
const
V
v
)
{
return
ShiftLeftLanes
<
kLanes
>
(
DFromV
<
V
>
(
)
v
)
;
}
template
<
size_t
kLanes
class
D
class
V
=
VFromD
<
D
>
>
HWY_API
V
ShiftRightLanes
(
D
d
V
v
)
{
if
(
!
detail
:
:
IsFull
(
d
)
)
{
v
=
IfThenElseZero
(
detail
:
:
MakeMask
(
d
)
v
)
;
}
const
auto
shifted
=
detail
:
:
Ext
<
kLanes
>
(
v
v
)
;
constexpr
size_t
kLanesPerBlock
=
detail
:
:
LanesPerBlock
(
d
)
;
const
svbool_t
mask
=
detail
:
:
FirstNPerBlock
<
kLanesPerBlock
-
kLanes
>
(
d
)
;
return
IfThenElseZero
(
mask
shifted
)
;
}
template
<
int
kBytes
class
D
class
V
=
VFromD
<
D
>
>
HWY_API
V
ShiftLeftBytes
(
const
D
d
const
V
v
)
{
const
Repartition
<
uint8_t
decltype
(
d
)
>
d8
;
return
BitCast
(
d
ShiftLeftLanes
<
kBytes
>
(
BitCast
(
d8
v
)
)
)
;
}
template
<
int
kBytes
class
V
>
HWY_API
V
ShiftLeftBytes
(
const
V
v
)
{
return
ShiftLeftBytes
<
kBytes
>
(
DFromV
<
V
>
(
)
v
)
;
}
template
<
int
kBytes
class
D
class
V
=
VFromD
<
D
>
>
HWY_API
V
ShiftRightBytes
(
const
D
d
const
V
v
)
{
const
Repartition
<
uint8_t
decltype
(
d
)
>
d8
;
return
BitCast
(
d
ShiftRightLanes
<
kBytes
>
(
d8
BitCast
(
d8
v
)
)
)
;
}
template
<
class
D
class
V
>
HWY_API
V
InterleaveLower
(
D
d
const
V
a
const
V
b
)
{
static_assert
(
IsSame
<
TFromD
<
D
>
TFromV
<
V
>
>
(
)
"
D
/
V
mismatch
"
)
;
const
Repartition
<
uint64_t
decltype
(
d
)
>
d64
;
const
auto
a64
=
BitCast
(
d64
a
)
;
const
auto
b64
=
BitCast
(
d64
b
)
;
const
auto
a_blocks
=
detail
:
:
ConcatEven
(
a64
a64
)
;
const
auto
b_blocks
=
detail
:
:
ConcatEven
(
b64
b64
)
;
return
detail
:
:
ZipLower
(
BitCast
(
d
a_blocks
)
BitCast
(
d
b_blocks
)
)
;
}
template
<
class
V
>
HWY_API
V
InterleaveLower
(
const
V
a
const
V
b
)
{
return
InterleaveLower
(
DFromV
<
V
>
(
)
a
b
)
;
}
template
<
class
D
class
V
=
VFromD
<
D
>
hwy
:
:
EnableIf
<
detail
:
:
IsFull
(
D
(
)
)
>
*
=
nullptr
>
HWY_API
V
InterleaveUpper
(
D
d
const
V
a
const
V
b
)
{
const
Repartition
<
uint64_t
decltype
(
d
)
>
d64
;
const
auto
a64
=
BitCast
(
d64
a
)
;
const
auto
b64
=
BitCast
(
d64
b
)
;
const
auto
a_blocks
=
detail
:
:
ConcatOdd
(
a64
a64
)
;
const
auto
b_blocks
=
detail
:
:
ConcatOdd
(
b64
b64
)
;
return
detail
:
:
ZipLower
(
BitCast
(
d
a_blocks
)
BitCast
(
d
b_blocks
)
)
;
}
template
<
class
D
class
V
=
VFromD
<
D
>
hwy
:
:
EnableIf
<
!
detail
:
:
IsFull
(
D
(
)
)
>
*
=
nullptr
>
HWY_API
V
InterleaveUpper
(
D
d
const
V
a
const
V
b
)
{
if
(
Lanes
(
d
)
*
sizeof
(
TFromD
<
D
>
)
<
16
)
{
const
Half
<
decltype
(
d
)
>
d2
;
return
InterleaveLower
(
d
UpperHalf
(
d2
a
)
UpperHalf
(
d2
b
)
)
;
}
return
InterleaveUpper
(
DFromV
<
V
>
(
)
a
b
)
;
}
template
<
class
V
class
DW
=
RepartitionToWide
<
DFromV
<
V
>
>
>
HWY_API
VFromD
<
DW
>
ZipLower
(
DW
dw
V
a
V
b
)
{
const
RepartitionToNarrow
<
DW
>
dn
;
static_assert
(
IsSame
<
TFromD
<
decltype
(
dn
)
>
TFromV
<
V
>
>
(
)
"
D
/
V
mismatch
"
)
;
return
BitCast
(
dw
InterleaveLower
(
dn
a
b
)
)
;
}
template
<
class
V
class
D
=
DFromV
<
V
>
class
DW
=
RepartitionToWide
<
D
>
>
HWY_API
VFromD
<
DW
>
ZipLower
(
const
V
a
const
V
b
)
{
return
BitCast
(
DW
(
)
InterleaveLower
(
D
(
)
a
b
)
)
;
}
template
<
class
V
class
DW
=
RepartitionToWide
<
DFromV
<
V
>
>
>
HWY_API
VFromD
<
DW
>
ZipUpper
(
DW
dw
V
a
V
b
)
{
const
RepartitionToNarrow
<
DW
>
dn
;
static_assert
(
IsSame
<
TFromD
<
decltype
(
dn
)
>
TFromV
<
V
>
>
(
)
"
D
/
V
mismatch
"
)
;
return
BitCast
(
dw
InterleaveUpper
(
dn
a
b
)
)
;
}
#
define
HWY_SVE_REDUCE
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
template
<
size_t
N
int
kPow2
>
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_D
(
BASE
BITS
N
kPow2
)
d
HWY_SVE_V
(
BASE
BITS
)
v
)
{
\
return
Set
(
d
static_cast
<
HWY_SVE_T
(
BASE
BITS
)
>
(
\
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
detail
:
:
MakeMask
(
d
)
v
)
)
)
;
\
}
HWY_SVE_FOREACH
(
HWY_SVE_REDUCE
SumOfLanes
addv
)
HWY_SVE_FOREACH_UI
(
HWY_SVE_REDUCE
MinOfLanes
minv
)
HWY_SVE_FOREACH_UI
(
HWY_SVE_REDUCE
MaxOfLanes
maxv
)
HWY_SVE_FOREACH_F
(
HWY_SVE_REDUCE
MinOfLanes
minnmv
)
HWY_SVE_FOREACH_F
(
HWY_SVE_REDUCE
MaxOfLanes
maxnmv
)
#
undef
HWY_SVE_REDUCE
template
<
size_t
N
int
kPow2
>
HWY_API
svfloat32_t
PromoteTo
(
Simd
<
float32_t
N
kPow2
>
df32
const
svuint16_t
v
)
{
return
BitCast
(
df32
detail
:
:
ZipLower
(
svdup_n_u16
(
0
)
v
)
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svuint16_t
ReorderDemote2To
(
Simd
<
bfloat16_t
N
kPow2
>
dbf16
svfloat32_t
a
svfloat32_t
b
)
{
const
RebindToUnsigned
<
decltype
(
dbf16
)
>
du16
;
const
Repartition
<
uint32_t
decltype
(
dbf16
)
>
du32
;
const
svuint32_t
b_in_even
=
ShiftRight
<
16
>
(
BitCast
(
du32
b
)
)
;
return
BitCast
(
dbf16
OddEven
(
BitCast
(
du16
a
)
BitCast
(
du16
b_in_even
)
)
)
;
}
template
<
class
V
>
HWY_API
V
ZeroIfNegative
(
const
V
v
)
{
return
IfThenZeroElse
(
detail
:
:
LtN
(
v
0
)
v
)
;
}
template
<
class
V
>
HWY_API
V
BroadcastSignBit
(
const
V
v
)
{
return
ShiftRight
<
sizeof
(
TFromV
<
V
>
)
*
8
-
1
>
(
v
)
;
}
template
<
class
V
>
HWY_API
V
IfNegativeThenElse
(
V
v
V
yes
V
no
)
{
static_assert
(
IsSigned
<
TFromV
<
V
>
>
(
)
"
Only
works
for
signed
/
float
"
)
;
const
DFromV
<
V
>
d
;
const
RebindToSigned
<
decltype
(
d
)
>
di
;
const
svbool_t
m
=
MaskFromVec
(
BitCast
(
d
BroadcastSignBit
(
BitCast
(
di
v
)
)
)
)
;
return
IfThenElse
(
m
yes
no
)
;
}
#
if
HWY_TARGET
=
=
HWY_SVE2
HWY_SVE_FOREACH_U08
(
HWY_SVE_RETV_ARGPVV
AverageRound
rhadd
)
HWY_SVE_FOREACH_U16
(
HWY_SVE_RETV_ARGPVV
AverageRound
rhadd
)
#
else
template
<
class
V
>
V
AverageRound
(
const
V
a
const
V
b
)
{
return
ShiftRight
<
1
>
(
detail
:
:
AddN
(
Add
(
a
b
)
1
)
)
;
}
#
endif
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
1
)
>
HWY_INLINE
svbool_t
LoadMaskBits
(
D
d
const
uint8_t
*
HWY_RESTRICT
bits
)
{
const
RebindToUnsigned
<
D
>
du
;
const
svuint8_t
iota
=
Iota
(
du
0
)
;
const
svuint8_t
bytes
=
BitCast
(
du
svld1ub_u64
(
detail
:
:
PTrue
(
d
)
bits
)
)
;
const
svuint8_t
rep8
=
svtbl_u8
(
bytes
detail
:
:
AndNotN
(
7
iota
)
)
;
const
svuint8_t
bit
=
Shl
(
Set
(
du
1
)
detail
:
:
AndN
(
iota
7
)
)
;
return
TestBit
(
rep8
bit
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
2
)
>
HWY_INLINE
svbool_t
LoadMaskBits
(
D
const
uint8_t
*
HWY_RESTRICT
bits
)
{
const
RebindToUnsigned
<
D
>
du
;
const
Repartition
<
uint8_t
D
>
du8
;
const
svuint8_t
bytes
=
svld1
(
FirstN
(
du8
(
Lanes
(
du
)
+
7
)
/
8
)
bits
)
;
const
svuint8_t
rep16
=
svtbl_u8
(
bytes
ShiftRight
<
4
>
(
Iota
(
du8
0
)
)
)
;
const
svuint16_t
bit
=
Shl
(
Set
(
du
1
)
detail
:
:
AndN
(
Iota
(
du
0
)
7
)
)
;
return
TestBit
(
BitCast
(
du
rep16
)
bit
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
4
)
>
HWY_INLINE
svbool_t
LoadMaskBits
(
D
const
uint8_t
*
HWY_RESTRICT
bits
)
{
const
RebindToUnsigned
<
D
>
du
;
const
Repartition
<
uint8_t
D
>
du8
;
const
svuint8_t
bytes
=
svld1
(
FirstN
(
du8
8
)
bits
)
;
const
svuint8_t
rep32
=
svtbl_u8
(
bytes
ShiftRight
<
5
>
(
Iota
(
du8
0
)
)
)
;
const
svuint32_t
bit
=
Shl
(
Set
(
du
1
)
detail
:
:
AndN
(
Iota
(
du
0
)
7
)
)
;
return
TestBit
(
BitCast
(
du
rep32
)
bit
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
8
)
>
HWY_INLINE
svbool_t
LoadMaskBits
(
D
const
uint8_t
*
HWY_RESTRICT
bits
)
{
const
RebindToUnsigned
<
D
>
du
;
uint32_t
mask_bits
;
CopyBytes
<
4
>
(
bits
&
mask_bits
)
;
const
auto
vbits
=
Set
(
du
mask_bits
)
;
const
svuint64_t
bit
=
Shl
(
Set
(
du
1
)
Iota
(
du
0
)
)
;
return
TestBit
(
vbits
bit
)
;
}
namespace
detail
{
template
<
class
T
HWY_IF_LANE_SIZE
(
T
1
)
>
HWY_INLINE
svuint8_t
BoolFromMask
(
svbool_t
m
)
{
return
svdup_n_u8_z
(
m
1
)
;
}
template
<
class
T
HWY_IF_LANE_SIZE
(
T
2
)
>
HWY_INLINE
svuint8_t
BoolFromMask
(
svbool_t
m
)
{
const
ScalableTag
<
uint8_t
>
d8
;
const
svuint8_t
b16
=
BitCast
(
d8
svdup_n_u16_z
(
m
1
)
)
;
return
detail
:
:
ConcatEven
(
b16
b16
)
;
}
template
<
class
T
HWY_IF_LANE_SIZE
(
T
4
)
>
HWY_INLINE
svuint8_t
BoolFromMask
(
svbool_t
m
)
{
return
U8FromU32
(
svdup_n_u32_z
(
m
1
)
)
;
}
template
<
class
T
HWY_IF_LANE_SIZE
(
T
8
)
>
HWY_INLINE
svuint8_t
BoolFromMask
(
svbool_t
m
)
{
const
ScalableTag
<
uint32_t
>
d32
;
const
svuint32_t
b64
=
BitCast
(
d32
svdup_n_u64_z
(
m
1
)
)
;
return
U8FromU32
(
detail
:
:
ConcatEven
(
b64
b64
)
)
;
}
HWY_INLINE
svuint64_t
BitsFromBool
(
svuint8_t
x
)
{
const
ScalableTag
<
uint8_t
>
d8
;
const
ScalableTag
<
uint16_t
>
d16
;
const
ScalableTag
<
uint32_t
>
d32
;
const
ScalableTag
<
uint64_t
>
d64
;
x
=
Or
(
x
BitCast
(
d8
ShiftRight
<
7
>
(
BitCast
(
d16
x
)
)
)
)
;
x
=
Or
(
x
BitCast
(
d8
ShiftRight
<
14
>
(
BitCast
(
d32
x
)
)
)
)
;
x
=
Or
(
x
BitCast
(
d8
ShiftRight
<
28
>
(
BitCast
(
d64
x
)
)
)
)
;
return
BitCast
(
d64
x
)
;
}
}
template
<
class
D
>
HWY_API
size_t
StoreMaskBits
(
D
d
svbool_t
m
uint8_t
*
bits
)
{
svuint64_t
bits_in_u64
=
detail
:
:
BitsFromBool
(
detail
:
:
BoolFromMask
<
TFromD
<
D
>
>
(
m
)
)
;
const
size_t
num_bits
=
Lanes
(
d
)
;
const
size_t
num_bytes
=
(
num_bits
+
8
-
1
)
/
8
;
svst1b_u64
(
FirstN
(
ScalableTag
<
uint64_t
>
(
)
num_bytes
)
bits
bits_in_u64
)
;
if
(
num_bits
<
8
)
{
const
int
mask
=
(
1
<
<
num_bits
)
-
1
;
bits
[
0
]
=
static_cast
<
uint8_t
>
(
bits
[
0
]
&
mask
)
;
}
return
num_bytes
;
}
template
<
class
V
>
HWY_INLINE
V
CompressBits
(
V
v
const
uint8_t
*
HWY_RESTRICT
bits
)
{
return
Compress
(
v
LoadMaskBits
(
DFromV
<
V
>
(
)
bits
)
)
;
}
template
<
class
D
>
HWY_API
size_t
CompressBitsStore
(
VFromD
<
D
>
v
const
uint8_t
*
HWY_RESTRICT
bits
D
d
TFromD
<
D
>
*
HWY_RESTRICT
unaligned
)
{
return
CompressStore
(
v
LoadMaskBits
(
d
bits
)
d
unaligned
)
;
}
#
if
HWY_TARGET
=
=
HWY_SVE2
namespace
detail
{
#
define
HWY_SVE_MUL_EVEN
(
BASE
CHAR
BITS
HALF
NAME
OP
)
\
HWY_API
HWY_SVE_V
(
BASE
BITS
)
\
NAME
(
HWY_SVE_V
(
BASE
HALF
)
a
HWY_SVE_V
(
BASE
HALF
)
b
)
{
\
return
sv
#
#
OP
#
#
_
#
#
CHAR
#
#
BITS
(
a
b
)
;
\
}
HWY_SVE_FOREACH_UI64
(
HWY_SVE_MUL_EVEN
MulEven
mullb
)
#
undef
HWY_SVE_MUL_EVEN
}
#
endif
template
<
class
V
class
DW
=
RepartitionToWide
<
DFromV
<
V
>
>
>
HWY_API
VFromD
<
DW
>
MulEven
(
const
V
a
const
V
b
)
{
#
if
HWY_TARGET
=
=
HWY_SVE2
return
BitCast
(
DW
(
)
detail
:
:
MulEven
(
a
b
)
)
;
#
else
const
auto
lo
=
Mul
(
a
b
)
;
const
auto
hi
=
detail
:
:
MulHigh
(
a
b
)
;
return
BitCast
(
DW
(
)
detail
:
:
InterleaveEven
(
lo
hi
)
)
;
#
endif
}
HWY_API
svuint64_t
MulEven
(
const
svuint64_t
a
const
svuint64_t
b
)
{
const
auto
lo
=
Mul
(
a
b
)
;
const
auto
hi
=
detail
:
:
MulHigh
(
a
b
)
;
return
detail
:
:
InterleaveEven
(
lo
hi
)
;
}
HWY_API
svuint64_t
MulOdd
(
const
svuint64_t
a
const
svuint64_t
b
)
{
const
auto
lo
=
Mul
(
a
b
)
;
const
auto
hi
=
detail
:
:
MulHigh
(
a
b
)
;
return
detail
:
:
InterleaveOdd
(
lo
hi
)
;
}
template
<
size_t
N
int
kPow2
>
HWY_API
svfloat32_t
ReorderWidenMulAccumulate
(
Simd
<
float
N
kPow2
>
df32
svuint16_t
a
svuint16_t
b
const
svfloat32_t
sum0
svfloat32_t
&
sum1
)
{
const
Repartition
<
uint16_t
decltype
(
df32
)
>
du16
;
const
RebindToUnsigned
<
decltype
(
df32
)
>
du32
;
const
svuint16_t
zero
=
Zero
(
du16
)
;
const
svuint32_t
a0
=
ZipLower
(
du32
zero
BitCast
(
du16
a
)
)
;
const
svuint32_t
a1
=
ZipUpper
(
du32
zero
BitCast
(
du16
a
)
)
;
const
svuint32_t
b0
=
ZipLower
(
du32
zero
BitCast
(
du16
b
)
)
;
const
svuint32_t
b1
=
ZipUpper
(
du32
zero
BitCast
(
du16
b
)
)
;
sum1
=
MulAdd
(
BitCast
(
df32
a1
)
BitCast
(
df32
b1
)
sum1
)
;
return
MulAdd
(
BitCast
(
df32
a0
)
BitCast
(
df32
b0
)
sum0
)
;
}
#
if
defined
(
__ARM_FEATURE_SVE2_AES
)
#
ifdef
HWY_NATIVE_AES
#
undef
HWY_NATIVE_AES
#
else
#
define
HWY_NATIVE_AES
#
endif
HWY_API
svuint8_t
AESRound
(
svuint8_t
state
svuint8_t
round_key
)
{
const
svuint8_t
zero
=
svdup_n_u8
(
0
)
;
return
Xor
(
svaesmc_u8
(
svaese_u8
(
state
zero
)
)
round_key
)
;
}
HWY_API
svuint8_t
AESLastRound
(
svuint8_t
state
svuint8_t
round_key
)
{
return
Xor
(
svaese_u8
(
state
svdup_n_u8
(
0
)
)
round_key
)
;
}
HWY_API
svuint64_t
CLMulLower
(
const
svuint64_t
a
const
svuint64_t
b
)
{
return
svpmullb_pair
(
a
b
)
;
}
HWY_API
svuint64_t
CLMulUpper
(
const
svuint64_t
a
const
svuint64_t
b
)
{
return
svpmullt_pair
(
a
b
)
;
}
#
endif
template
<
class
D
>
HWY_INLINE
svbool_t
Lt128
(
D
const
svuint64_t
a
const
svuint64_t
b
)
{
static_assert
(
!
IsSigned
<
TFromD
<
D
>
>
(
)
&
&
sizeof
(
TFromD
<
D
>
)
=
=
8
"
Use
u64
"
)
;
const
svbool_t
eqHL
=
Eq
(
a
b
)
;
const
svbool_t
ltHL
=
Lt
(
a
b
)
;
const
svbool_t
cmpLL
=
svtrn1_b64
(
ltHL
ltHL
)
;
const
svbool_t
outHx
=
svsel_b
(
eqHL
cmpLL
ltHL
)
;
return
svtrn2_b64
(
outHx
outHx
)
;
}
template
<
class
D
>
HWY_INLINE
svuint64_t
Min128
(
D
d
const
svuint64_t
a
const
svuint64_t
b
)
{
return
IfThenElse
(
Lt128
(
d
a
b
)
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
svuint64_t
Max128
(
D
d
const
svuint64_t
a
const
svuint64_t
b
)
{
return
IfThenElse
(
Lt128
(
d
a
b
)
b
a
)
;
}
namespace
detail
{
#
undef
HWY_IF_FLOAT_V
#
undef
HWY_IF_LANE_SIZE_V
#
undef
HWY_IF_SIGNED_V
#
undef
HWY_IF_UNSIGNED_V
#
undef
HWY_SVE_D
#
undef
HWY_SVE_FOREACH
#
undef
HWY_SVE_FOREACH_F
#
undef
HWY_SVE_FOREACH_F16
#
undef
HWY_SVE_FOREACH_F32
#
undef
HWY_SVE_FOREACH_F64
#
undef
HWY_SVE_FOREACH_I
#
undef
HWY_SVE_FOREACH_I08
#
undef
HWY_SVE_FOREACH_I16
#
undef
HWY_SVE_FOREACH_I32
#
undef
HWY_SVE_FOREACH_I64
#
undef
HWY_SVE_FOREACH_IF
#
undef
HWY_SVE_FOREACH_U
#
undef
HWY_SVE_FOREACH_U08
#
undef
HWY_SVE_FOREACH_U16
#
undef
HWY_SVE_FOREACH_U32
#
undef
HWY_SVE_FOREACH_U64
#
undef
HWY_SVE_FOREACH_UI
#
undef
HWY_SVE_FOREACH_UI08
#
undef
HWY_SVE_FOREACH_UI16
#
undef
HWY_SVE_FOREACH_UI32
#
undef
HWY_SVE_FOREACH_UI64
#
undef
HWY_SVE_FOREACH_UIF3264
#
undef
HWY_SVE_PTRUE
#
undef
HWY_SVE_RETV_ARGPV
#
undef
HWY_SVE_RETV_ARGPVN
#
undef
HWY_SVE_RETV_ARGPVV
#
undef
HWY_SVE_RETV_ARGV
#
undef
HWY_SVE_RETV_ARGVN
#
undef
HWY_SVE_RETV_ARGVV
#
undef
HWY_SVE_T
#
undef
HWY_SVE_UNDEFINED
#
undef
HWY_SVE_V
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
