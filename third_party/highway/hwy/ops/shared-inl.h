#
include
<
cmath
>
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
ops
/
set_macros
-
inl
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
template
<
typename
Lane
size_t
N
int
kPow2
>
struct
Simd
{
constexpr
Simd
(
)
=
default
;
using
T
=
Lane
;
static_assert
(
(
N
&
(
N
-
1
)
)
=
=
0
&
&
N
!
=
0
"
N
must
be
a
power
of
two
"
)
;
static
constexpr
size_t
kPrivateN
=
N
;
static
constexpr
int
kPrivatePow2
=
kPow2
;
template
<
typename
NewT
>
static
constexpr
size_t
NewN
(
)
{
return
(
N
*
sizeof
(
T
)
+
sizeof
(
NewT
)
-
1
)
/
sizeof
(
NewT
)
;
}
#
if
HWY_HAVE_SCALABLE
template
<
typename
NewT
>
static
constexpr
int
Pow2Ratio
(
)
{
return
(
sizeof
(
NewT
)
>
sizeof
(
T
)
)
?
static_cast
<
int
>
(
CeilLog2
(
sizeof
(
NewT
)
/
sizeof
(
T
)
)
)
:
-
static_cast
<
int
>
(
CeilLog2
(
sizeof
(
T
)
/
sizeof
(
NewT
)
)
)
;
}
#
endif
#
if
HWY_HAVE_SCALABLE
template
<
typename
NewT
>
using
Rebind
=
Simd
<
NewT
N
kPow2
+
Pow2Ratio
<
NewT
>
(
)
>
;
#
else
template
<
typename
NewT
>
using
Rebind
=
Simd
<
NewT
N
kPow2
>
;
#
endif
template
<
typename
NewT
>
using
Repartition
=
Simd
<
NewT
NewN
<
NewT
>
(
)
kPow2
>
;
#
if
HWY_HAVE_SCALABLE
using
Half
=
Simd
<
T
(
N
+
1
)
/
2
kPow2
-
1
>
;
#
else
using
Half
=
Simd
<
T
(
N
+
1
)
/
2
kPow2
>
;
#
endif
#
if
HWY_HAVE_SCALABLE
using
Twice
=
Simd
<
T
2
*
N
kPow2
+
1
>
;
#
else
using
Twice
=
Simd
<
T
2
*
N
kPow2
>
;
#
endif
}
;
namespace
detail
{
template
<
typename
T
size_t
N
int
kPow2
>
constexpr
bool
IsFull
(
Simd
<
T
N
kPow2
>
)
{
return
N
=
=
HWY_LANES
(
T
)
&
&
kPow2
=
=
0
;
}
constexpr
size_t
ScaleByPower
(
size_t
N
int
pow2
)
{
#
if
HWY_TARGET
=
=
HWY_RVV
return
pow2
>
=
0
?
(
N
<
<
pow2
)
:
(
N
>
>
(
-
pow2
)
)
;
#
else
return
pow2
>
=
0
?
N
:
(
N
>
>
(
-
pow2
)
)
;
#
endif
}
template
<
typename
T
int
kPow2
>
struct
ScalableTagChecker
{
static_assert
(
-
3
<
=
kPow2
&
&
kPow2
<
=
3
"
Fraction
must
be
1
/
8
to
8
"
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
using
type
=
Simd
<
T
HWY_LANES
(
T
)
kPow2
>
;
#
elif
HWY_HAVE_SCALABLE
using
type
=
Simd
<
T
HWY_LANES
(
T
)
HWY_MIN
(
kPow2
0
)
>
;
#
elif
HWY_TARGET
=
=
HWY_SCALAR
using
type
=
Simd
<
T
1
0
>
;
#
else
using
type
=
Simd
<
T
ScaleByPower
(
HWY_LANES
(
T
)
HWY_MIN
(
kPow2
0
)
)
0
>
;
#
endif
}
;
template
<
typename
T
size_t
kLimit
>
struct
CappedTagChecker
{
static_assert
(
kLimit
!
=
0
"
Does
not
make
sense
to
have
zero
lanes
"
)
;
static
constexpr
size_t
kLimitPow2
=
size_t
{
1
}
<
<
hwy
:
:
FloorLog2
(
kLimit
)
;
using
type
=
Simd
<
T
HWY_MIN
(
kLimitPow2
HWY_LANES
(
T
)
)
0
>
;
}
;
template
<
typename
T
size_t
kNumLanes
>
struct
FixedTagChecker
{
static_assert
(
kNumLanes
!
=
0
"
Does
not
make
sense
to
have
zero
lanes
"
)
;
static_assert
(
kNumLanes
<
=
HWY_LANES
(
T
)
"
Too
many
lanes
"
)
;
using
type
=
Simd
<
T
kNumLanes
0
>
;
}
;
}
template
<
typename
T
int
kPow2
=
0
>
using
ScalableTag
=
typename
detail
:
:
ScalableTagChecker
<
T
kPow2
>
:
:
type
;
template
<
typename
T
size_t
kLimit
>
using
CappedTag
=
typename
detail
:
:
CappedTagChecker
<
T
kLimit
>
:
:
type
;
template
<
typename
T
size_t
kNumLanes
>
using
FixedTag
=
typename
detail
:
:
FixedTagChecker
<
T
kNumLanes
>
:
:
type
;
template
<
class
D
>
using
TFromD
=
typename
D
:
:
T
;
template
<
class
T
class
D
>
using
Rebind
=
typename
D
:
:
template
Rebind
<
T
>
;
template
<
class
D
>
using
RebindToSigned
=
Rebind
<
MakeSigned
<
TFromD
<
D
>
>
D
>
;
template
<
class
D
>
using
RebindToUnsigned
=
Rebind
<
MakeUnsigned
<
TFromD
<
D
>
>
D
>
;
template
<
class
D
>
using
RebindToFloat
=
Rebind
<
MakeFloat
<
TFromD
<
D
>
>
D
>
;
template
<
class
T
class
D
>
using
Repartition
=
typename
D
:
:
template
Repartition
<
T
>
;
template
<
class
D
>
using
RepartitionToWide
=
Repartition
<
MakeWide
<
TFromD
<
D
>
>
D
>
;
template
<
class
D
>
using
RepartitionToNarrow
=
Repartition
<
MakeNarrow
<
TFromD
<
D
>
>
D
>
;
template
<
class
D
>
using
Half
=
typename
D
:
:
Half
;
template
<
class
D
>
using
Twice
=
typename
D
:
:
Twice
;
template
<
typename
T
>
using
Full32
=
Simd
<
T
4
/
sizeof
(
T
)
0
>
;
template
<
typename
T
>
using
Full64
=
Simd
<
T
8
/
sizeof
(
T
)
0
>
;
template
<
typename
T
>
using
Full128
=
Simd
<
T
16
/
sizeof
(
T
)
0
>
;
#
define
HWY_IF_UNSIGNED_D
(
D
)
HWY_IF_UNSIGNED
(
TFromD
<
D
>
)
#
define
HWY_IF_SIGNED_D
(
D
)
HWY_IF_SIGNED
(
TFromD
<
D
>
)
#
define
HWY_IF_FLOAT_D
(
D
)
HWY_IF_FLOAT
(
TFromD
<
D
>
)
#
define
HWY_IF_NOT_FLOAT_D
(
D
)
HWY_IF_NOT_FLOAT
(
TFromD
<
D
>
)
#
define
HWY_IF_LANE_SIZE_D
(
D
bytes
)
HWY_IF_LANE_SIZE
(
TFromD
<
D
>
bytes
)
#
define
HWY_IF_NOT_LANE_SIZE_D
(
D
bytes
)
HWY_IF_NOT_LANE_SIZE
(
TFromD
<
D
>
bytes
)
#
define
HWY_IF_LT128_D
(
D
)
\
hwy
:
:
EnableIf
<
D
:
:
kPrivateN
*
sizeof
(
TFromD
<
D
>
)
<
16
>
*
=
nullptr
#
define
HWY_IF_GE128_D
(
D
)
\
hwy
:
:
EnableIf
<
D
:
:
kPrivateN
*
sizeof
(
TFromD
<
D
>
)
>
=
16
>
*
=
nullptr
#
define
HWY_IF_UNSIGNED_V
(
V
)
HWY_IF_UNSIGNED
(
TFromV
<
V
>
)
#
define
HWY_IF_SIGNED_V
(
V
)
HWY_IF_SIGNED
(
TFromV
<
V
>
)
#
define
HWY_IF_FLOAT_V
(
V
)
HWY_IF_FLOAT
(
TFromV
<
V
>
)
#
define
HWY_IF_LANE_SIZE_V
(
V
bytes
)
HWY_IF_LANE_SIZE
(
TFromV
<
V
>
bytes
)
#
define
HWY_IF_NOT_LANE_SIZE_V
(
V
bytes
)
HWY_IF_NOT_LANE_SIZE
(
TFromV
<
V
>
bytes
)
template
<
class
D
>
HWY_INLINE
HWY_MAYBE_UNUSED
constexpr
int
Pow2
(
D
)
{
return
D
:
:
kPrivatePow2
;
}
#
define
HWY_IF_POW2_GE
(
D
MIN
)
hwy
:
:
EnableIf
<
Pow2
<
D
>
(
D
(
)
)
>
=
(
MIN
)
>
*
=
nullptr
#
if
HWY_HAVE_SCALABLE
template
<
class
D
>
HWY_INLINE
HWY_MAYBE_UNUSED
constexpr
size_t
MaxLanes
(
D
)
{
return
detail
:
:
ScaleByPower
(
HWY_MIN
(
D
:
:
kPrivateN
HWY_LANES
(
TFromD
<
D
>
)
)
D
:
:
kPrivatePow2
)
;
}
#
else
template
<
class
D
>
HWY_INLINE
HWY_MAYBE_UNUSED
constexpr
size_t
MaxLanes
(
D
)
{
return
D
:
:
kPrivateN
;
}
template
<
typename
T
size_t
N
int
kPow2
>
HWY_INLINE
HWY_MAYBE_UNUSED
size_t
Lanes
(
Simd
<
T
N
kPow2
>
)
{
return
N
;
}
#
endif
#
if
HWY_COMPILER_GCC_ACTUAL
&
&
(
HWY_OS_WIN
|
|
HWY_ARCH_ARM_A64
)
template
<
class
V
>
using
VecArg
=
const
V
&
;
#
else
template
<
class
V
>
using
VecArg
=
V
;
#
endif
}
}
HWY_AFTER_NAMESPACE
(
)
;
