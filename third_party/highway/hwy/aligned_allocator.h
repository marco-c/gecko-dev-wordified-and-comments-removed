#
ifndef
HIGHWAY_HWY_ALIGNED_ALLOCATOR_H_
#
define
HIGHWAY_HWY_ALIGNED_ALLOCATOR_H_
#
include
<
memory
>
#
include
<
utility
>
#
include
"
hwy
/
base
.
h
"
namespace
hwy
{
#
define
HWY_ALIGNMENT
64
using
AllocPtr
=
void
*
(
*
)
(
void
*
opaque
size_t
bytes
)
;
using
FreePtr
=
void
(
*
)
(
void
*
opaque
void
*
memory
)
;
HWY_DLLEXPORT
void
*
AllocateAlignedBytes
(
size_t
payload_size
AllocPtr
alloc_ptr
void
*
opaque_ptr
)
;
HWY_DLLEXPORT
void
FreeAlignedBytes
(
const
void
*
aligned_pointer
FreePtr
free_ptr
void
*
opaque_ptr
)
;
class
AlignedDeleter
{
public
:
AlignedDeleter
(
)
:
free_
(
nullptr
)
opaque_ptr_
(
nullptr
)
{
}
AlignedDeleter
(
FreePtr
free_ptr
void
*
opaque_ptr
)
:
free_
(
free_ptr
)
opaque_ptr_
(
opaque_ptr
)
{
}
template
<
typename
T
>
void
operator
(
)
(
T
*
aligned_pointer
)
const
{
return
DeleteAlignedArray
(
aligned_pointer
free_
opaque_ptr_
TypedArrayDeleter
<
T
>
)
;
}
private
:
template
<
typename
T
>
static
void
TypedArrayDeleter
(
void
*
ptr
size_t
size_in_bytes
)
{
size_t
elems
=
size_in_bytes
/
sizeof
(
T
)
;
for
(
size_t
i
=
0
;
i
<
elems
;
i
+
+
)
{
(
static_cast
<
T
*
>
(
ptr
)
+
i
)
-
>
~
T
(
)
;
}
}
using
ArrayDeleter
=
void
(
*
)
(
void
*
t_ptr
size_t
t_size
)
;
HWY_DLLEXPORT
static
void
DeleteAlignedArray
(
void
*
aligned_pointer
FreePtr
free_ptr
void
*
opaque_ptr
ArrayDeleter
deleter
)
;
FreePtr
free_
;
void
*
opaque_ptr_
;
}
;
template
<
typename
T
>
using
AlignedUniquePtr
=
std
:
:
unique_ptr
<
T
AlignedDeleter
>
;
template
<
typename
T
typename
.
.
.
Args
>
AlignedUniquePtr
<
T
>
MakeUniqueAlignedWithAlloc
(
AllocPtr
alloc
FreePtr
free
void
*
opaque
Args
&
&
.
.
.
args
)
{
T
*
ptr
=
static_cast
<
T
*
>
(
AllocateAlignedBytes
(
sizeof
(
T
)
alloc
opaque
)
)
;
return
AlignedUniquePtr
<
T
>
(
new
(
ptr
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
AlignedDeleter
(
free
opaque
)
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
AlignedUniquePtr
<
T
>
MakeUniqueAligned
(
Args
&
&
.
.
.
args
)
{
T
*
ptr
=
static_cast
<
T
*
>
(
AllocateAlignedBytes
(
sizeof
(
T
)
nullptr
nullptr
)
)
;
return
AlignedUniquePtr
<
T
>
(
new
(
ptr
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
AlignedDeleter
(
)
)
;
}
namespace
detail
{
static
inline
constexpr
size_t
ShiftCount
(
size_t
n
)
{
return
(
n
<
=
1
)
?
0
:
1
+
ShiftCount
(
n
/
2
)
;
}
template
<
typename
T
>
T
*
AllocateAlignedItems
(
size_t
items
AllocPtr
alloc_ptr
void
*
opaque_ptr
)
{
constexpr
size_t
size
=
sizeof
(
T
)
;
constexpr
bool
is_pow2
=
(
size
&
(
size
-
1
)
)
=
=
0
;
constexpr
size_t
bits
=
ShiftCount
(
size
)
;
static_assert
(
!
is_pow2
|
|
(
1ull
<
<
bits
)
=
=
size
"
ShiftCount
is
incorrect
"
)
;
const
size_t
bytes
=
is_pow2
?
items
<
<
bits
:
items
*
size
;
const
size_t
check
=
is_pow2
?
bytes
>
>
bits
:
bytes
/
size
;
if
(
check
!
=
items
)
{
return
nullptr
;
}
return
static_cast
<
T
*
>
(
AllocateAlignedBytes
(
bytes
alloc_ptr
opaque_ptr
)
)
;
}
}
template
<
typename
T
typename
.
.
.
Args
>
AlignedUniquePtr
<
T
[
]
>
MakeUniqueAlignedArrayWithAlloc
(
size_t
items
AllocPtr
alloc
FreePtr
free
void
*
opaque
Args
&
&
.
.
.
args
)
{
T
*
ptr
=
detail
:
:
AllocateAlignedItems
<
T
>
(
items
alloc
opaque
)
;
if
(
ptr
!
=
nullptr
)
{
for
(
size_t
i
=
0
;
i
<
items
;
i
+
+
)
{
new
(
ptr
+
i
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
return
AlignedUniquePtr
<
T
[
]
>
(
ptr
AlignedDeleter
(
free
opaque
)
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
AlignedUniquePtr
<
T
[
]
>
MakeUniqueAlignedArray
(
size_t
items
Args
&
&
.
.
.
args
)
{
return
MakeUniqueAlignedArrayWithAlloc
<
T
Args
.
.
.
>
(
items
nullptr
nullptr
nullptr
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
class
AlignedFreer
{
public
:
static
void
DoNothing
(
void
*
void
*
)
{
}
AlignedFreer
(
)
:
free_
(
nullptr
)
opaque_ptr_
(
nullptr
)
{
}
AlignedFreer
(
FreePtr
free_ptr
void
*
opaque_ptr
)
:
free_
(
free_ptr
)
opaque_ptr_
(
opaque_ptr
)
{
}
template
<
typename
T
>
void
operator
(
)
(
T
*
aligned_pointer
)
const
{
FreeAlignedBytes
(
aligned_pointer
free_
opaque_ptr_
)
;
}
private
:
FreePtr
free_
;
void
*
opaque_ptr_
;
}
;
template
<
typename
T
>
using
AlignedFreeUniquePtr
=
std
:
:
unique_ptr
<
T
AlignedFreer
>
;
template
<
typename
T
>
AlignedFreeUniquePtr
<
T
[
]
>
AllocateAligned
(
const
size_t
items
AllocPtr
alloc
FreePtr
free
void
*
opaque
)
{
return
AlignedFreeUniquePtr
<
T
[
]
>
(
detail
:
:
AllocateAlignedItems
<
T
>
(
items
alloc
opaque
)
AlignedFreer
(
free
opaque
)
)
;
}
template
<
typename
T
>
AlignedFreeUniquePtr
<
T
[
]
>
AllocateAligned
(
const
size_t
items
)
{
return
AllocateAligned
<
T
>
(
items
nullptr
nullptr
nullptr
)
;
}
}
#
endif
