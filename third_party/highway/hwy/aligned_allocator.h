#
ifndef
HIGHWAY_HWY_ALIGNED_ALLOCATOR_H_
#
define
HIGHWAY_HWY_ALIGNED_ALLOCATOR_H_
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
cassert
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
initializer_list
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
per_target
.
h
"
#
include
<
mozilla
/
Attributes
.
h
>
namespace
hwy
{
#
define
HWY_ALIGNMENT
128
template
<
typename
T
>
HWY_API
constexpr
bool
IsAligned
(
T
*
ptr
size_t
align
=
HWY_ALIGNMENT
)
{
return
reinterpret_cast
<
uintptr_t
>
(
ptr
)
%
align
=
=
0
;
}
using
AllocPtr
=
void
*
(
*
)
(
void
*
opaque
size_t
bytes
)
;
using
FreePtr
=
void
(
*
)
(
void
*
opaque
void
*
memory
)
;
HWY_DLLEXPORT
void
*
AllocateAlignedBytes
(
size_t
payload_size
AllocPtr
alloc_ptr
=
nullptr
void
*
opaque_ptr
=
nullptr
)
;
HWY_DLLEXPORT
void
FreeAlignedBytes
(
const
void
*
aligned_pointer
FreePtr
free_ptr
void
*
opaque_ptr
)
;
class
AlignedDeleter
{
public
:
AlignedDeleter
(
)
:
free_
(
nullptr
)
opaque_ptr_
(
nullptr
)
{
}
AlignedDeleter
(
FreePtr
free_ptr
void
*
opaque_ptr
)
:
free_
(
free_ptr
)
opaque_ptr_
(
opaque_ptr
)
{
}
template
<
typename
T
>
void
operator
(
)
(
T
*
aligned_pointer
)
const
{
return
DeleteAlignedArray
(
aligned_pointer
free_
opaque_ptr_
TypedArrayDeleter
<
T
>
)
;
}
private
:
template
<
typename
T
>
static
void
TypedArrayDeleter
(
void
*
ptr
size_t
size_in_bytes
)
{
size_t
elems
=
size_in_bytes
/
sizeof
(
T
)
;
for
(
size_t
i
=
0
;
i
<
elems
;
i
+
+
)
{
(
static_cast
<
T
*
>
(
ptr
)
+
i
)
-
>
~
T
(
)
;
}
}
using
ArrayDeleter
=
void
(
*
)
(
void
*
t_ptr
size_t
t_size
)
;
HWY_DLLEXPORT
static
void
DeleteAlignedArray
(
void
*
aligned_pointer
FreePtr
free_ptr
void
*
opaque_ptr
ArrayDeleter
deleter
)
;
FreePtr
free_
;
void
*
opaque_ptr_
;
}
;
template
<
typename
T
>
using
AlignedUniquePtr
=
std
:
:
unique_ptr
<
T
AlignedDeleter
>
;
template
<
typename
T
typename
.
.
.
Args
>
AlignedUniquePtr
<
T
>
MakeUniqueAlignedWithAlloc
(
AllocPtr
alloc
FreePtr
free
void
*
opaque
Args
&
&
.
.
.
args
)
{
T
*
ptr
=
static_cast
<
T
*
>
(
AllocateAlignedBytes
(
sizeof
(
T
)
alloc
opaque
)
)
;
return
AlignedUniquePtr
<
T
>
(
new
(
ptr
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
AlignedDeleter
(
free
opaque
)
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
AlignedUniquePtr
<
T
>
MakeUniqueAligned
(
Args
&
&
.
.
.
args
)
{
T
*
ptr
=
static_cast
<
T
*
>
(
AllocateAlignedBytes
(
sizeof
(
T
)
)
)
;
return
AlignedUniquePtr
<
T
>
(
new
(
ptr
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
AlignedDeleter
(
)
)
;
}
template
<
class
T
>
struct
AlignedAllocator
{
using
value_type
=
T
;
AlignedAllocator
(
)
=
default
;
template
<
class
V
>
explicit
AlignedAllocator
(
const
AlignedAllocator
<
V
>
&
)
noexcept
{
}
template
<
class
V
>
value_type
*
allocate
(
V
n
)
{
static_assert
(
std
:
:
is_integral
<
V
>
:
:
value
"
AlignedAllocator
only
supports
integer
types
"
)
;
static_assert
(
sizeof
(
V
)
<
=
sizeof
(
std
:
:
size_t
)
"
V
n
must
be
smaller
or
equal
size_t
to
avoid
overflow
"
)
;
return
static_cast
<
value_type
*
>
(
AllocateAlignedBytes
(
static_cast
<
std
:
:
size_t
>
(
n
)
*
sizeof
(
value_type
)
)
)
;
}
template
<
class
V
>
void
deallocate
(
value_type
*
p
HWY_MAYBE_UNUSED
V
n
)
{
return
FreeAlignedBytes
(
p
nullptr
nullptr
)
;
}
}
;
template
<
class
T
class
V
>
constexpr
bool
operator
=
=
(
const
AlignedAllocator
<
T
>
&
const
AlignedAllocator
<
V
>
&
)
noexcept
{
return
true
;
}
template
<
class
T
class
V
>
constexpr
bool
operator
!
=
(
const
AlignedAllocator
<
T
>
&
const
AlignedAllocator
<
V
>
&
)
noexcept
{
return
false
;
}
template
<
class
T
>
using
AlignedVector
=
std
:
:
vector
<
T
AlignedAllocator
<
T
>
>
;
namespace
detail
{
static
inline
constexpr
size_t
ShiftCount
(
size_t
n
)
{
return
(
n
<
=
1
)
?
0
:
1
+
ShiftCount
(
n
/
2
)
;
}
template
<
typename
T
>
T
*
AllocateAlignedItems
(
size_t
items
AllocPtr
alloc_ptr
void
*
opaque_ptr
)
{
constexpr
size_t
kSize
=
sizeof
(
T
)
;
constexpr
bool
kIsPow2
=
(
kSize
&
(
kSize
-
1
)
)
=
=
0
;
constexpr
size_t
kBits
=
ShiftCount
(
kSize
)
;
static_assert
(
!
kIsPow2
|
|
(
1ull
<
<
kBits
)
=
=
kSize
"
ShiftCount
has
a
bug
"
)
;
const
size_t
bytes
=
kIsPow2
?
items
<
<
kBits
:
items
*
kSize
;
const
size_t
check
=
kIsPow2
?
bytes
>
>
kBits
:
bytes
/
kSize
;
if
(
check
!
=
items
)
{
return
nullptr
;
}
return
static_cast
<
T
*
>
(
AllocateAlignedBytes
(
bytes
alloc_ptr
opaque_ptr
)
)
;
}
}
template
<
typename
T
typename
.
.
.
Args
>
AlignedUniquePtr
<
T
[
]
>
MakeUniqueAlignedArrayWithAlloc
(
size_t
items
AllocPtr
alloc
FreePtr
free
void
*
opaque
Args
&
&
.
.
.
args
)
{
T
*
ptr
=
detail
:
:
AllocateAlignedItems
<
T
>
(
items
alloc
opaque
)
;
if
(
ptr
!
=
nullptr
)
{
for
(
size_t
i
=
0
;
i
<
items
;
i
+
+
)
{
new
(
ptr
+
i
)
T
(
args
.
.
.
)
;
}
}
return
AlignedUniquePtr
<
T
[
]
>
(
ptr
AlignedDeleter
(
free
opaque
)
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
AlignedUniquePtr
<
T
[
]
>
MakeUniqueAlignedArray
(
size_t
items
Args
&
&
.
.
.
args
)
{
return
MakeUniqueAlignedArrayWithAlloc
<
T
Args
.
.
.
>
(
items
nullptr
nullptr
nullptr
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
class
AlignedFreer
{
public
:
static
void
DoNothing
(
void
*
void
*
)
{
}
AlignedFreer
(
)
:
free_
(
nullptr
)
opaque_ptr_
(
nullptr
)
{
}
AlignedFreer
(
FreePtr
free_ptr
void
*
opaque_ptr
)
:
free_
(
free_ptr
)
opaque_ptr_
(
opaque_ptr
)
{
}
template
<
typename
T
>
void
operator
(
)
(
T
*
aligned_pointer
)
const
{
FreeAlignedBytes
(
aligned_pointer
free_
opaque_ptr_
)
;
}
private
:
FreePtr
free_
;
void
*
opaque_ptr_
;
}
;
template
<
typename
T
>
using
AlignedFreeUniquePtr
=
std
:
:
unique_ptr
<
T
AlignedFreer
>
;
template
<
typename
T
>
AlignedFreeUniquePtr
<
T
[
]
>
AllocateAligned
(
const
size_t
items
AllocPtr
alloc
FreePtr
free
void
*
opaque
)
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
AllocateAligned
:
requires
trivially
copyable
T
"
)
;
static_assert
(
std
:
:
is_trivially_destructible
<
T
>
:
:
value
"
AllocateAligned
:
requires
trivially
destructible
T
"
)
;
return
AlignedFreeUniquePtr
<
T
[
]
>
(
detail
:
:
AllocateAlignedItems
<
T
>
(
items
alloc
opaque
)
AlignedFreer
(
free
opaque
)
)
;
}
template
<
typename
T
>
AlignedFreeUniquePtr
<
T
[
]
>
AllocateAligned
(
const
size_t
items
)
{
return
AllocateAligned
<
T
>
(
items
nullptr
nullptr
nullptr
)
;
}
template
<
typename
T
>
class
Span
{
public
:
Span
(
)
=
default
;
Span
(
T
*
data
size_t
size
)
:
size_
(
size
)
data_
(
data
)
{
}
template
<
typename
U
>
MOZ_IMPLICIT
Span
(
U
u
)
:
Span
(
u
.
data
(
)
u
.
size
(
)
)
{
}
MOZ_IMPLICIT
Span
(
std
:
:
initializer_list
<
const
T
>
v
)
:
Span
(
v
.
begin
(
)
v
.
size
(
)
)
{
}
Span
<
T
>
&
operator
=
(
std
:
:
initializer_list
<
const
T
>
v
)
{
HWY_DASSERT
(
size_
=
=
v
.
size
(
)
)
;
CopyBytes
(
v
.
begin
(
)
data_
sizeof
(
T
)
*
std
:
:
min
(
size_
v
.
size
(
)
)
)
;
return
*
this
;
}
size_t
size
(
)
const
{
return
size_
;
}
T
*
data
(
)
{
return
data_
;
}
T
*
data
(
)
const
{
return
data_
;
}
T
&
operator
[
]
(
size_t
index
)
const
{
return
data_
[
index
]
;
}
T
*
begin
(
)
{
return
data_
;
}
constexpr
const
T
*
cbegin
(
)
const
{
return
data_
;
}
T
*
end
(
)
{
return
data_
+
size_
;
}
constexpr
const
T
*
cend
(
)
const
{
return
data_
+
size_
;
}
private
:
size_t
size_
=
0
;
T
*
data_
=
nullptr
;
}
;
template
<
typename
T
size_t
axes
>
class
AlignedNDArray
{
static_assert
(
std
:
:
is_trivial
<
T
>
:
:
value
"
AlignedNDArray
can
only
contain
trivial
types
"
)
;
public
:
AlignedNDArray
(
AlignedNDArray
&
&
other
)
=
default
;
AlignedNDArray
&
operator
=
(
AlignedNDArray
&
&
other
)
=
default
;
explicit
AlignedNDArray
(
std
:
:
array
<
size_t
axes
>
shape
)
:
shape_
(
shape
)
{
sizes_
=
ComputeSizes
(
shape_
)
;
memory_shape_
=
shape_
;
memory_shape_
[
axes
-
1
]
=
RoundUpTo
(
memory_shape_
[
axes
-
1
]
VectorBytes
(
)
)
;
memory_sizes_
=
ComputeSizes
(
memory_shape_
)
;
buffer_
=
hwy
:
:
AllocateAligned
<
T
>
(
memory_size
(
)
)
;
hwy
:
:
ZeroBytes
(
buffer_
.
get
(
)
memory_size
(
)
*
sizeof
(
T
)
)
;
}
Span
<
T
>
operator
[
]
(
std
:
:
array
<
const
size_t
axes
-
1
>
indices
)
{
return
Span
<
T
>
(
buffer_
.
get
(
)
+
Offset
(
indices
)
sizes_
[
indices
.
size
(
)
]
)
;
}
Span
<
const
T
>
operator
[
]
(
std
:
:
array
<
const
size_t
axes
-
1
>
indices
)
const
{
return
Span
<
const
T
>
(
buffer_
.
get
(
)
+
Offset
(
indices
)
sizes_
[
indices
.
size
(
)
]
)
;
}
const
std
:
:
array
<
size_t
axes
>
&
shape
(
)
const
{
return
shape_
;
}
const
std
:
:
array
<
size_t
axes
>
&
memory_shape
(
)
const
{
return
memory_shape_
;
}
size_t
size
(
)
const
{
return
sizes_
[
0
]
;
}
size_t
memory_size
(
)
const
{
return
memory_sizes_
[
0
]
;
}
T
*
data
(
)
{
return
buffer_
.
get
(
)
;
}
const
T
*
data
(
)
const
{
return
buffer_
.
get
(
)
;
}
void
truncate
(
const
std
:
:
array
<
size_t
axes
>
&
new_shape
)
{
#
if
HWY_IS_DEBUG_BUILD
for
(
size_t
axis_index
=
0
;
axis_index
<
axes
;
+
+
axis_index
)
{
HWY_ASSERT
(
new_shape
[
axis_index
]
<
=
shape_
[
axis_index
]
)
;
}
#
endif
shape_
=
new_shape
;
sizes_
=
ComputeSizes
(
shape_
)
;
}
private
:
std
:
:
array
<
size_t
axes
>
shape_
;
std
:
:
array
<
size_t
axes
>
memory_shape_
;
std
:
:
array
<
size_t
axes
+
1
>
sizes_
;
std
:
:
array
<
size_t
axes
+
1
>
memory_sizes_
;
hwy
:
:
AlignedFreeUniquePtr
<
T
[
]
>
buffer_
;
size_t
Offset
(
std
:
:
array
<
const
size_t
axes
-
1
>
indices
)
const
{
size_t
offset
=
0
;
size_t
shape_index
=
0
;
for
(
const
size_t
axis_index
:
indices
)
{
offset
+
=
memory_sizes_
[
shape_index
+
1
]
*
axis_index
;
shape_index
+
+
;
}
return
offset
;
}
static
std
:
:
array
<
size_t
axes
+
1
>
ComputeSizes
(
std
:
:
array
<
size_t
axes
>
shape
)
{
std
:
:
array
<
size_t
axes
+
1
>
sizes
;
size_t
axis
=
shape
.
size
(
)
;
sizes
[
axis
]
=
1
;
while
(
axis
>
0
)
{
-
-
axis
;
sizes
[
axis
]
=
sizes
[
axis
+
1
]
*
shape
[
axis
]
;
}
return
sizes
;
}
}
;
}
#
endif
