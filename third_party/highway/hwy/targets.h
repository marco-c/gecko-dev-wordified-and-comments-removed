#
ifndef
HIGHWAY_HWY_TARGETS_H_
#
define
HIGHWAY_HWY_TARGETS_H_
#
include
<
vector
>
#
include
"
hwy
/
base
.
h
"
#
define
HWY_AVX3
8
#
define
HWY_AVX2
16
#
define
HWY_SSE4
64
#
define
HWY_HIGHEST_TARGET_BIT_X86
9
#
define
HWY_SVE2
0x400
#
define
HWY_SVE
0x800
#
define
HWY_NEON
0x2000
#
define
HWY_HIGHEST_TARGET_BIT_ARM
13
#
define
HWY_PPC8
0x10000
/
/
v2
.
07
or
3
#
define
HWY_HIGHEST_TARGET_BIT_PPC
18
#
define
HWY_WASM
0x100000
#
define
HWY_HIGHEST_TARGET_BIT_WASM
20
#
define
HWY_RVV
0x1000000
#
define
HWY_HIGHEST_TARGET_BIT_RVV
24
#
define
HWY_SCALAR
0x20000000
#
define
HWY_HIGHEST_TARGET_BIT_SCALAR
29
#
ifndef
HWY_DISABLED_TARGETS
#
define
HWY_DISABLED_TARGETS
0
#
endif
#
ifndef
HWY_BROKEN_TARGETS
#
if
HWY_ARCH_X86
&
&
(
HWY_COMPILER_CLANG
!
=
0
&
&
HWY_COMPILER_CLANG
<
700
)
#
define
HWY_BROKEN_TARGETS
(
HWY_SSE4
|
HWY_AVX2
|
HWY_AVX3
)
#
if
!
defined
(
HWY_COMPILE_ONLY_SCALAR
)
#
pragma
message
(
"
x86
Clang
<
=
6
:
define
HWY_COMPILE_ONLY_SCALAR
or
upgrade
.
"
)
#
endif
#
elif
HWY_ARCH_X86_32
#
define
HWY_BROKEN_TARGETS
(
HWY_AVX2
|
HWY_AVX3
)
#
elif
HWY_COMPILER_MSVC
!
=
0
#
define
HWY_BROKEN_TARGETS
(
HWY_AVX3
)
#
elif
HWY_ARCH_ARM_V7
&
&
(
defined
(
__ARM_BIG_ENDIAN
)
|
|
defined
(
__BIG_ENDIAN
)
)
#
define
HWY_BROKEN_TARGETS
(
HWY_NEON
)
#
else
#
define
HWY_BROKEN_TARGETS
0
#
endif
#
endif
#
define
HWY_ENABLED
(
targets
)
\
(
(
targets
)
&
~
(
(
HWY_DISABLED_TARGETS
)
|
(
HWY_BROKEN_TARGETS
)
)
)
#
ifndef
HWY_BASELINE_TARGETS
#
if
HWY_ARCH_WASM
&
&
defined
(
__wasm_simd128__
)
#
define
HWY_BASELINE_WASM
HWY_WASM
#
else
#
define
HWY_BASELINE_WASM
0
#
endif
#
if
HWY_ARCH_PPC
&
&
defined
(
__VSX__
)
&
&
0
#
define
HWY_BASELINE_PPC8
HWY_PPC8
#
else
#
define
HWY_BASELINE_PPC8
0
#
endif
#
if
HWY_ARCH_ARM
&
&
defined
(
__ARM_FEATURE_SVE2
)
&
&
0
#
define
HWY_BASELINE_SVE2
HWY_SVE2
#
else
#
define
HWY_BASELINE_SVE2
0
#
endif
#
if
HWY_ARCH_ARM
&
&
defined
(
__ARM_FEATURE_SVE
)
&
&
0
#
define
HWY_BASELINE_SVE
HWY_SVE
#
else
#
define
HWY_BASELINE_SVE
0
#
endif
#
if
HWY_ARCH_ARM
&
&
(
defined
(
__ARM_NEON__
)
|
|
defined
(
__ARM_NEON
)
)
#
define
HWY_BASELINE_NEON
HWY_NEON
#
else
#
define
HWY_BASELINE_NEON
0
#
endif
#
if
HWY_ARCH_X86
&
&
\
(
defined
(
__SSE4_1__
)
|
|
(
HWY_COMPILER_MSVC
!
=
0
&
&
defined
(
__AVX__
)
)
)
#
define
HWY_BASELINE_SSE4
HWY_SSE4
#
else
#
define
HWY_BASELINE_SSE4
0
#
endif
#
if
HWY_ARCH_X86
&
&
defined
(
__AVX2__
)
#
define
HWY_BASELINE_AVX2
HWY_AVX2
#
else
#
define
HWY_BASELINE_AVX2
0
#
endif
#
if
HWY_ARCH_X86
&
&
defined
(
__AVX512F__
)
#
define
HWY_BASELINE_AVX3
HWY_AVX3
#
else
#
define
HWY_BASELINE_AVX3
0
#
endif
#
if
HWY_ARCH_RVV
&
&
defined
(
__riscv_vector
)
#
define
HWY_BASELINE_RVV
HWY_RVV
#
else
#
define
HWY_BASELINE_RVV
0
#
endif
#
define
HWY_BASELINE_TARGETS
\
(
HWY_SCALAR
|
HWY_BASELINE_WASM
|
HWY_BASELINE_PPC8
|
HWY_BASELINE_SVE2
|
\
HWY_BASELINE_SVE
|
HWY_BASELINE_NEON
|
HWY_BASELINE_SSE4
|
\
HWY_BASELINE_AVX2
|
HWY_BASELINE_AVX3
|
HWY_BASELINE_RVV
)
#
endif
#
define
HWY_ENABLED_BASELINE
HWY_ENABLED
(
HWY_BASELINE_TARGETS
)
#
if
HWY_ENABLED_BASELINE
=
=
0
#
error
"
At
least
one
baseline
target
must
be
defined
and
enabled
"
#
endif
#
define
HWY_STATIC_TARGET
(
HWY_ENABLED_BASELINE
&
-
HWY_ENABLED_BASELINE
)
#
define
HWY_TARGET
HWY_STATIC_TARGET
#
if
(
defined
(
HWY_COMPILE_ONLY_SCALAR
)
+
defined
(
HWY_COMPILE_ONLY_STATIC
)
+
\
defined
(
HWY_COMPILE_ALL_ATTAINABLE
)
)
>
1
#
error
"
Invalid
config
:
can
only
define
a
single
policy
for
targets
"
#
endif
#
if
HWY_ARCH_X86
#
define
HWY_ATTAINABLE_TARGETS
\
HWY_ENABLED
(
HWY_SCALAR
|
HWY_SSE4
|
HWY_AVX2
|
HWY_AVX3
)
#
else
#
define
HWY_ATTAINABLE_TARGETS
HWY_ENABLED_BASELINE
#
endif
#
if
defined
(
HWY_COMPILE_ONLY_SCALAR
)
#
undef
HWY_STATIC_TARGET
#
define
HWY_STATIC_TARGET
HWY_SCALAR
/
/
override
baseline
#
define
HWY_TARGETS
HWY_SCALAR
#
elif
defined
(
HWY_COMPILE_ONLY_STATIC
)
#
define
HWY_TARGETS
HWY_STATIC_TARGET
#
elif
defined
(
HWY_COMPILE_ALL_ATTAINABLE
)
|
|
defined
(
HWY_IS_TEST
)
#
define
HWY_TARGETS
HWY_ATTAINABLE_TARGETS
#
else
#
define
HWY_TARGETS
(
HWY_ATTAINABLE_TARGETS
&
(
2
*
HWY_STATIC_TARGET
-
1
)
)
#
endif
#
if
(
HWY_TARGETS
&
HWY_STATIC_TARGET
)
=
=
0
#
error
"
Logic
error
:
best
baseline
should
be
included
in
dynamic
targets
"
#
endif
namespace
hwy
{
uint32_t
SupportedTargets
(
)
;
void
DisableTargets
(
uint32_t
disabled_targets
)
;
#
if
(
HWY_TARGETS
&
(
HWY_TARGETS
-
1
)
)
=
=
0
#
define
HWY_SUPPORTED_TARGETS
HWY_TARGETS
#
else
#
define
HWY_SUPPORTED_TARGETS
hwy
:
:
SupportedTargets
(
)
#
endif
void
SetSupportedTargetsForTest
(
uint32_t
targets
)
;
bool
SupportedTargetsCalledForTest
(
)
;
HWY_INLINE
std
:
:
vector
<
uint32_t
>
SupportedAndGeneratedTargets
(
)
{
std
:
:
vector
<
uint32_t
>
ret
;
for
(
uint32_t
targets
=
SupportedTargets
(
)
&
HWY_TARGETS
;
targets
!
=
0
;
targets
=
targets
&
(
targets
-
1
)
)
{
uint32_t
current_target
=
targets
&
~
(
targets
-
1
)
;
ret
.
push_back
(
current_target
)
;
}
return
ret
;
}
static
inline
HWY_MAYBE_UNUSED
const
char
*
TargetName
(
uint32_t
target
)
{
switch
(
target
)
{
#
if
HWY_ARCH_X86
case
HWY_SSE4
:
return
"
SSE4
"
;
case
HWY_AVX2
:
return
"
AVX2
"
;
case
HWY_AVX3
:
return
"
AVX3
"
;
#
endif
#
if
HWY_ARCH_ARM
case
HWY_SVE2
:
return
"
SVE2
"
;
case
HWY_SVE
:
return
"
SVE
"
;
case
HWY_NEON
:
return
"
Neon
"
;
#
endif
#
if
HWY_ARCH_PPC
case
HWY_PPC8
:
return
"
Power8
"
;
#
endif
#
if
HWY_ARCH_WASM
case
HWY_WASM
:
return
"
Wasm
"
;
#
endif
#
if
HWY_ARCH_RVV
case
HWY_RVV
:
return
"
RVV
"
;
#
endif
case
HWY_SCALAR
:
return
"
Scalar
"
;
default
:
return
"
Unknown
"
;
}
}
#
define
HWY_CHOSEN_TARGET_MASK_SCALAR
(
1u
<
<
(
HWY_MAX_DYNAMIC_TARGETS
+
1
)
)
#
define
HWY_CHOSEN_TARGET_SHIFT
(
X
)
\
(
(
(
(
X
)
>
>
(
HWY_HIGHEST_TARGET_BIT
+
1
-
HWY_MAX_DYNAMIC_TARGETS
)
)
&
\
(
(
1u
<
<
HWY_MAX_DYNAMIC_TARGETS
)
-
1
)
)
\
<
<
1
)
#
define
HWY_CHOSEN_TARGET_MASK_TARGETS
\
(
HWY_CHOSEN_TARGET_SHIFT
(
HWY_TARGETS
)
|
HWY_CHOSEN_TARGET_MASK_SCALAR
|
1u
)
#
if
HWY_ARCH_X86
#
define
HWY_MAX_DYNAMIC_TARGETS
10
#
define
HWY_HIGHEST_TARGET_BIT
HWY_HIGHEST_TARGET_BIT_X86
#
define
HWY_CHOOSE_TARGET_LIST
(
func_name
)
\
nullptr
/
*
reserved
*
/
\
nullptr
/
*
reserved
*
/
\
nullptr
/
*
reserved
*
/
\
HWY_CHOOSE_AVX3
(
func_name
)
/
*
AVX3
*
/
\
HWY_CHOOSE_AVX2
(
func_name
)
/
*
AVX2
*
/
\
nullptr
/
*
AVX
*
/
\
HWY_CHOOSE_SSE4
(
func_name
)
/
*
SSE4
*
/
\
nullptr
/
*
SSSE3
*
/
\
nullptr
/
*
SSE3
*
/
\
nullptr
/
*
SSE2
*
/
#
elif
HWY_ARCH_ARM
#
define
HWY_MAX_DYNAMIC_TARGETS
4
#
define
HWY_HIGHEST_TARGET_BIT
HWY_HIGHEST_TARGET_BIT_ARM
#
define
HWY_CHOOSE_TARGET_LIST
(
func_name
)
\
HWY_CHOOSE_SVE2
(
func_name
)
/
*
SVE2
*
/
\
HWY_CHOOSE_SVE
(
func_name
)
/
*
SVE
*
/
\
nullptr
/
*
reserved
*
/
\
HWY_CHOOSE_NEON
(
func_name
)
/
*
NEON
*
/
#
elif
HWY_ARCH_PPC
#
define
HWY_MAX_DYNAMIC_TARGETS
5
#
define
HWY_HIGHEST_TARGET_BIT
HWY_HIGHEST_TARGET_BIT_PPC
#
define
HWY_CHOOSE_TARGET_LIST
(
func_name
)
\
nullptr
/
*
reserved
*
/
\
nullptr
/
*
reserved
*
/
\
HWY_CHOOSE_PPC8
(
func_name
)
/
*
PPC8
*
/
\
nullptr
/
*
VSX
*
/
\
nullptr
/
*
AltiVec
*
/
#
elif
HWY_ARCH_WASM
#
define
HWY_MAX_DYNAMIC_TARGETS
4
#
define
HWY_HIGHEST_TARGET_BIT
HWY_HIGHEST_TARGET_BIT_WASM
#
define
HWY_CHOOSE_TARGET_LIST
(
func_name
)
\
nullptr
/
*
reserved
*
/
\
nullptr
/
*
reserved
*
/
\
nullptr
/
*
reserved
*
/
\
HWY_CHOOSE_WASM
(
func_name
)
/
*
WASM
*
/
#
elif
HWY_ARCH_RVV
#
define
HWY_MAX_DYNAMIC_TARGETS
4
#
define
HWY_HIGHEST_TARGET_BIT
HWY_HIGHEST_TARGET_BIT_RVV
#
define
HWY_CHOOSE_TARGET_LIST
(
func_name
)
\
nullptr
/
*
reserved
*
/
\
nullptr
/
*
reserved
*
/
\
nullptr
/
*
reserved
*
/
\
HWY_CHOOSE_RVV
(
func_name
)
/
*
RVV
*
/
#
else
#
define
HWY_MAX_DYNAMIC_TARGETS
1
#
define
HWY_HIGHEST_TARGET_BIT
HWY_HIGHEST_TARGET_BIT_SCALAR
#
endif
struct
ChosenTarget
{
public
:
void
Update
(
)
;
void
DeInit
(
)
{
mask_
.
store
(
1
)
;
}
bool
IsInitialized
(
)
const
{
return
mask_
.
load
(
)
!
=
1
;
}
size_t
HWY_INLINE
GetIndex
(
)
const
{
return
hwy
:
:
Num0BitsBelowLS1Bit_Nonzero32
(
mask_
.
load
(
)
&
HWY_CHOSEN_TARGET_MASK_TARGETS
)
;
}
private
:
std
:
:
atomic
<
uint32_t
>
mask_
{
1
}
;
}
;
extern
ChosenTarget
chosen_target
;
}
#
endif
