#
if
defined
(
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
)
=
=
\
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
#
undef
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
#
else
#
define
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
#
endif
#
include
"
hwy
/
contrib
/
sort
/
disabled_targets
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
shared
-
inl
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
vqsort
.
h
"
#
include
"
hwy
/
highway
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
namespace
detail
{
struct
KeyLane
{
constexpr
size_t
LanesPerKey
(
)
const
{
return
1
;
}
template
<
typename
T
>
HWY_INLINE
void
Swap
(
T
*
a
T
*
b
)
const
{
const
T
temp
=
*
a
;
*
a
=
*
b
;
*
b
=
temp
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SetKey
(
D
d
const
TFromD
<
D
>
*
key
)
const
{
return
Set
(
d
*
key
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys2
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse2
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys4
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse4
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys8
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse8
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys16
(
D
d
Vec
<
D
>
v
)
const
{
static_assert
(
SortConstants
:
:
kMaxCols
<
=
16
"
Assumes
u32x16
=
512
bit
"
)
;
return
ReverseKeys
(
d
v
)
;
}
template
<
class
V
>
HWY_INLINE
V
OddEvenKeys
(
const
V
odd
const
V
even
)
const
{
return
OddEven
(
odd
even
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
2
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentPairs
(
D
d
const
Vec
<
D
>
v
)
const
{
const
Repartition
<
uint32_t
D
>
du32
;
return
BitCast
(
d
Shuffle2301
(
BitCast
(
du32
v
)
)
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
4
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentPairs
(
D
const
Vec
<
D
>
v
)
const
{
return
Shuffle1032
(
v
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentPairs
(
D
const
Vec
<
D
>
v
)
const
{
return
SwapAdjacentBlocks
(
v
)
;
}
template
<
class
D
HWY_IF_NOT_LANE_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentQuads
(
D
d
const
Vec
<
D
>
v
)
const
{
#
if
HWY_HAVE_FLOAT64
const
RepartitionToWide
<
D
>
dw
;
#
else
const
RepartitionToWide
<
RebindToUnsigned
<
D
>
>
dw
;
#
endif
return
BitCast
(
d
SwapAdjacentPairs
(
dw
BitCast
(
dw
v
)
)
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentQuads
(
D
d
const
Vec
<
D
>
v
)
const
{
return
ConcatLowerUpper
(
d
v
v
)
;
}
template
<
class
D
HWY_IF_NOT_LANE_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenPairs
(
D
d
const
Vec
<
D
>
odd
const
Vec
<
D
>
even
)
const
{
#
if
HWY_HAVE_FLOAT64
const
RepartitionToWide
<
D
>
dw
;
#
else
const
RepartitionToWide
<
RebindToUnsigned
<
D
>
>
dw
;
#
endif
return
BitCast
(
d
OddEven
(
BitCast
(
dw
odd
)
BitCast
(
dw
even
)
)
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenPairs
(
D
Vec
<
D
>
odd
Vec
<
D
>
even
)
const
{
return
OddEvenBlocks
(
odd
even
)
;
}
template
<
class
D
HWY_IF_NOT_LANE_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenQuads
(
D
d
Vec
<
D
>
odd
Vec
<
D
>
even
)
const
{
#
if
HWY_HAVE_FLOAT64
const
RepartitionToWide
<
D
>
dw
;
#
else
const
RepartitionToWide
<
RebindToUnsigned
<
D
>
>
dw
;
#
endif
return
BitCast
(
d
OddEvenPairs
(
dw
BitCast
(
dw
odd
)
BitCast
(
dw
even
)
)
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenQuads
(
D
d
Vec
<
D
>
odd
Vec
<
D
>
even
)
const
{
return
ConcatUpperLower
(
d
odd
even
)
;
}
}
;
struct
OrderAscending
:
public
KeyLane
{
using
Order
=
SortAscending
;
template
<
typename
T
>
HWY_INLINE
bool
Compare1
(
const
T
*
a
const
T
*
b
)
{
return
*
a
<
*
b
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
TFromD
<
D
>
*
HWY_RESTRICT
)
const
{
return
MinOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
TFromD
<
D
>
*
HWY_RESTRICT
)
const
{
return
MaxOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
}
;
struct
OrderDescending
:
public
KeyLane
{
using
Order
=
SortDescending
;
template
<
typename
T
>
HWY_INLINE
bool
Compare1
(
const
T
*
a
const
T
*
b
)
{
return
*
b
<
*
a
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt
(
b
a
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
TFromD
<
D
>
*
HWY_RESTRICT
)
const
{
return
MaxOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
TFromD
<
D
>
*
HWY_RESTRICT
)
const
{
return
MinOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
}
;
template
<
class
Base
>
struct
LaneTraits
:
public
Base
{
constexpr
bool
Is128
(
)
const
{
return
false
;
}
template
<
class
D
>
HWY_INLINE
void
Sort2
(
D
d
Vec
<
D
>
&
a
Vec
<
D
>
&
b
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
const
Vec
<
D
>
a_copy
=
a
;
#
if
HWY_AVX3
<
HWY_TARGET
&
&
HWY_TARGET
<
=
HWY_SSSE3
if
(
sizeof
(
TFromD
<
D
>
)
=
=
8
)
{
const
Mask
<
D
>
cmp
=
base
-
>
Compare
(
d
a
b
)
;
a
=
IfThenElse
(
cmp
a
b
)
;
b
=
IfThenElse
(
cmp
b
a_copy
)
;
return
;
}
#
endif
a
=
base
-
>
First
(
d
a
b
)
;
b
=
base
-
>
Last
(
d
a_copy
b
)
;
}
template
<
class
D
HWY_IF_LANE_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance1
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys2
(
d
v
)
;
#
if
HWY_AVX3
<
HWY_TARGET
&
&
HWY_TARGET
<
=
HWY_SSSE3
const
Vec
<
D
>
cmp
=
VecFromMask
(
d
base
-
>
Compare
(
d
v
swapped
)
)
;
return
IfVecThenElse
(
DupOdd
(
cmp
)
swapped
v
)
;
#
else
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenKeys
(
swapped
v
)
;
#
endif
}
template
<
class
D
HWY_IF_NOT_LANE_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance1
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys2
(
d
v
)
;
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenKeys
(
swapped
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsReverse4
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys4
(
d
v
)
;
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenPairs
(
d
swapped
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance4
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
SwapAdjacentQuads
(
d
v
)
;
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenQuads
(
d
swapped
v
)
;
}
}
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
