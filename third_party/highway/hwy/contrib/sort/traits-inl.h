#
if
defined
(
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
)
=
=
\
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
#
undef
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
#
else
#
define
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
#
endif
#
include
"
hwy
/
contrib
/
sort
/
shared
-
inl
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
vqsort
.
h
"
#
include
"
hwy
/
highway
.
h
"
#
include
"
hwy
/
print
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
namespace
detail
{
template
<
typename
T
>
struct
KeyLaneBase
{
static
constexpr
bool
Is128
(
)
{
return
false
;
}
constexpr
size_t
LanesPerKey
(
)
const
{
return
1
;
}
using
LaneType
=
T
;
using
KeyType
=
T
;
const
char
*
KeyString
(
)
const
{
return
IsSame
<
T
float
>
(
)
?
"
f32
"
:
IsSame
<
T
double
>
(
)
?
"
f64
"
:
IsSame
<
T
int16_t
>
(
)
?
"
i16
"
:
IsSame
<
T
int32_t
>
(
)
?
"
i32
"
:
IsSame
<
T
int64_t
>
(
)
?
"
i64
"
:
IsSame
<
T
uint16_t
>
(
)
?
"
u32
"
:
IsSame
<
T
uint32_t
>
(
)
?
"
u32
"
:
IsSame
<
T
uint64_t
>
(
)
?
"
u64
"
:
"
?
"
;
}
}
;
#
if
VQSORT_ENABLED
|
|
HWY_IDE
template
<
typename
T
>
struct
KeyLane
:
public
KeyLaneBase
<
T
>
{
static
constexpr
bool
IsKV
(
)
{
return
false
;
}
HWY_INLINE
void
Swap
(
T
*
a
T
*
b
)
const
{
const
T
temp
=
*
a
;
*
a
=
*
b
;
*
b
=
temp
;
}
template
<
class
V
class
M
>
HWY_INLINE
V
CompressKeys
(
V
keys
M
mask
)
const
{
return
CompressNot
(
keys
mask
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SetKey
(
D
d
const
T
*
key
)
const
{
return
Set
(
d
*
key
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
EqualKeys
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Eq
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
NotEqualKeys
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Ne
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
bool
NoKeyDifference
(
D
Vec
<
D
>
diff
)
const
{
const
RebindToUnsigned
<
D
>
du
;
return
AllTrue
(
du
Eq
(
BitCast
(
du
diff
)
Zero
(
du
)
)
)
;
}
HWY_INLINE
bool
Equal1
(
const
T
*
a
const
T
*
b
)
const
{
return
*
a
=
=
*
b
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys2
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse2
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys4
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse4
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys8
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse8
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys16
(
D
d
Vec
<
D
>
v
)
const
{
static_assert
(
SortConstants
:
:
kMaxCols
<
=
16
"
Assumes
u32x16
=
512
bit
"
)
;
return
ReverseKeys
(
d
v
)
;
}
template
<
class
V
>
HWY_INLINE
V
OddEvenKeys
(
const
V
odd
const
V
even
)
const
{
return
OddEven
(
odd
even
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
2
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentPairs
(
D
d
const
Vec
<
D
>
v
)
const
{
const
Repartition
<
uint32_t
D
>
du32
;
return
BitCast
(
d
Shuffle2301
(
BitCast
(
du32
v
)
)
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
4
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentPairs
(
D
const
Vec
<
D
>
v
)
const
{
return
Shuffle1032
(
v
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentPairs
(
D
const
Vec
<
D
>
v
)
const
{
return
SwapAdjacentBlocks
(
v
)
;
}
template
<
class
D
HWY_IF_NOT_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentQuads
(
D
d
const
Vec
<
D
>
v
)
const
{
#
if
HWY_HAVE_FLOAT64
const
RepartitionToWide
<
D
>
dw
;
#
else
const
RepartitionToWide
<
RebindToUnsigned
<
D
>
>
dw
;
#
endif
return
BitCast
(
d
SwapAdjacentPairs
(
dw
BitCast
(
dw
v
)
)
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentQuads
(
D
d
const
Vec
<
D
>
v
)
const
{
return
ConcatLowerUpper
(
d
v
v
)
;
}
template
<
class
D
HWY_IF_NOT_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenPairs
(
D
d
const
Vec
<
D
>
odd
const
Vec
<
D
>
even
)
const
{
#
if
HWY_HAVE_FLOAT64
const
RepartitionToWide
<
D
>
dw
;
#
else
const
RepartitionToWide
<
RebindToUnsigned
<
D
>
>
dw
;
#
endif
return
BitCast
(
d
OddEven
(
BitCast
(
dw
odd
)
BitCast
(
dw
even
)
)
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenPairs
(
D
Vec
<
D
>
odd
Vec
<
D
>
even
)
const
{
return
OddEvenBlocks
(
odd
even
)
;
}
template
<
class
D
HWY_IF_NOT_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenQuads
(
D
d
Vec
<
D
>
odd
Vec
<
D
>
even
)
const
{
#
if
HWY_HAVE_FLOAT64
const
RepartitionToWide
<
D
>
dw
;
#
else
const
RepartitionToWide
<
RebindToUnsigned
<
D
>
>
dw
;
#
endif
return
BitCast
(
d
OddEvenPairs
(
dw
BitCast
(
dw
odd
)
BitCast
(
dw
even
)
)
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenQuads
(
D
d
Vec
<
D
>
odd
Vec
<
D
>
even
)
const
{
return
ConcatUpperLower
(
d
odd
even
)
;
}
}
;
template
<
typename
T
>
struct
OrderAscending
:
public
KeyLane
<
T
>
{
using
Order
=
SortAscending
;
HWY_INLINE
bool
Compare1
(
const
T
*
a
const
T
*
b
)
{
return
*
a
<
*
b
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
T
*
HWY_RESTRICT
)
const
{
return
MinOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
T
*
HWY_RESTRICT
)
const
{
return
MaxOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
T
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
T
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
return
Sub
(
v
Set
(
d
hwy
:
:
Epsilon
<
T
>
(
)
)
)
;
}
}
;
template
<
typename
T
>
struct
OrderDescending
:
public
KeyLane
<
T
>
{
using
Order
=
SortDescending
;
HWY_INLINE
bool
Compare1
(
const
T
*
a
const
T
*
b
)
{
return
*
b
<
*
a
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt
(
b
a
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
T
*
HWY_RESTRICT
)
const
{
return
MaxOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
T
*
HWY_RESTRICT
)
const
{
return
MinOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
T
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
T
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
return
Add
(
v
Set
(
d
hwy
:
:
Epsilon
<
T
>
(
)
)
)
;
}
}
;
struct
KeyValue64
:
public
KeyLane
<
uint64_t
>
{
static
constexpr
bool
IsKV
(
)
{
return
true
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
EqualKeys
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Eq
(
ShiftRight
<
32
>
(
a
)
ShiftRight
<
32
>
(
b
)
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
NotEqualKeys
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Ne
(
ShiftRight
<
32
>
(
a
)
ShiftRight
<
32
>
(
b
)
)
;
}
HWY_INLINE
bool
Equal1
(
const
uint64_t
*
a
const
uint64_t
*
b
)
const
{
return
(
*
a
>
>
32
)
=
=
(
*
b
>
>
32
)
;
}
template
<
class
D
>
HWY_INLINE
bool
NoKeyDifference
(
D
Vec
<
D
>
diff
)
const
{
const
RebindToUnsigned
<
D
>
du
;
const
Vec
<
decltype
(
du
)
>
zero
=
Zero
(
du
)
;
const
Vec
<
decltype
(
du
)
>
keys
=
ShiftRight
<
32
>
(
diff
)
;
return
AllTrue
(
du
Eq
(
BitCast
(
du
keys
)
zero
)
)
;
}
}
;
struct
OrderAscendingKV64
:
public
KeyValue64
{
using
Order
=
SortAscending
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
(
*
a
>
>
32
)
<
(
*
b
>
>
32
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt
(
ShiftRight
<
32
>
(
a
)
ShiftRight
<
32
>
(
b
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
uint64_t
*
HWY_RESTRICT
)
const
{
return
MinOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
uint64_t
*
HWY_RESTRICT
)
const
{
return
MaxOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
return
Sub
(
v
Set
(
d
uint64_t
{
1
}
)
)
;
}
}
;
struct
OrderDescendingKV64
:
public
KeyValue64
{
using
Order
=
SortDescending
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
(
*
b
>
>
32
)
<
(
*
a
>
>
32
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt
(
ShiftRight
<
32
>
(
b
)
ShiftRight
<
32
>
(
a
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
uint64_t
*
HWY_RESTRICT
)
const
{
return
MaxOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
uint64_t
*
HWY_RESTRICT
)
const
{
return
MinOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
return
Add
(
v
Set
(
d
uint64_t
{
1
}
)
)
;
}
}
;
template
<
class
Base
>
struct
TraitsLane
:
public
Base
{
template
<
class
D
>
HWY_INLINE
void
Sort2
(
D
d
Vec
<
D
>
&
a
Vec
<
D
>
&
b
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
const
Vec
<
D
>
a_copy
=
a
;
#
if
HWY_AVX3
<
HWY_TARGET
&
&
HWY_TARGET
<
=
HWY_SSSE3
if
(
sizeof
(
TFromD
<
D
>
)
=
=
8
)
{
const
Mask
<
D
>
cmp
=
base
-
>
Compare
(
d
a
b
)
;
a
=
IfThenElse
(
cmp
a
b
)
;
b
=
IfThenElse
(
cmp
b
a_copy
)
;
return
;
}
#
endif
a
=
base
-
>
First
(
d
a
b
)
;
b
=
base
-
>
Last
(
d
a_copy
b
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance1
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys2
(
d
v
)
;
#
if
HWY_AVX3
<
HWY_TARGET
&
&
HWY_TARGET
<
=
HWY_SSSE3
const
Vec
<
D
>
cmp
=
VecFromMask
(
d
base
-
>
Compare
(
d
v
swapped
)
)
;
return
IfVecThenElse
(
DupOdd
(
cmp
)
swapped
v
)
;
#
else
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenKeys
(
swapped
v
)
;
#
endif
}
template
<
class
D
HWY_IF_NOT_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance1
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys2
(
d
v
)
;
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenKeys
(
swapped
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsReverse4
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys4
(
d
v
)
;
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenPairs
(
d
swapped
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance4
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
SwapAdjacentQuads
(
d
v
)
;
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenQuads
(
d
swapped
v
)
;
}
}
;
#
else
template
<
typename
T
>
struct
OrderAscending
:
public
KeyLaneBase
<
T
>
{
using
Order
=
SortAscending
;
HWY_INLINE
bool
Compare1
(
const
T
*
a
const
T
*
b
)
{
return
*
a
<
*
b
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
{
return
Lt
(
a
b
)
;
}
}
;
template
<
typename
T
>
struct
OrderDescending
:
public
KeyLaneBase
<
T
>
{
using
Order
=
SortDescending
;
HWY_INLINE
bool
Compare1
(
const
T
*
a
const
T
*
b
)
{
return
*
b
<
*
a
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
{
return
Lt
(
b
a
)
;
}
}
;
template
<
class
Order
>
struct
TraitsLane
:
public
Order
{
template
<
typename
T
>
HWY_INLINE
void
Swap
(
T
*
a
T
*
b
)
const
{
const
T
temp
=
*
a
;
*
a
=
*
b
;
*
b
=
temp
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SetKey
(
D
d
const
TFromD
<
D
>
*
key
)
const
{
return
Set
(
d
*
key
)
;
}
}
;
#
endif
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
