#
if
defined
(
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
)
=
=
\
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
#
undef
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
#
else
#
define
HIGHWAY_HWY_CONTRIB_SORT_TRAITS_TOGGLE
#
endif
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
hwy
/
contrib
/
sort
/
order
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
shared
-
inl
.
h
"
#
include
"
hwy
/
highway
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
namespace
detail
{
template
<
typename
LaneTypeArg
typename
KeyTypeArg
>
struct
KeyLaneBase
{
static
constexpr
bool
Is128
(
)
{
return
false
;
}
constexpr
size_t
LanesPerKey
(
)
const
{
return
1
;
}
using
LaneType
=
LaneTypeArg
;
using
KeyType
=
KeyTypeArg
;
const
char
*
KeyString
(
)
const
{
return
IsSame
<
KeyTypeArg
float16_t
>
(
)
?
"
f16
"
:
IsSame
<
KeyTypeArg
float
>
(
)
?
"
f32
"
:
IsSame
<
KeyTypeArg
double
>
(
)
?
"
f64
"
:
IsSame
<
KeyTypeArg
int16_t
>
(
)
?
"
i16
"
:
IsSame
<
KeyTypeArg
int32_t
>
(
)
?
"
i32
"
:
IsSame
<
KeyTypeArg
int64_t
>
(
)
?
"
i64
"
:
IsSame
<
KeyTypeArg
uint16_t
>
(
)
?
"
u32
"
:
IsSame
<
KeyTypeArg
uint32_t
>
(
)
?
"
u32
"
:
IsSame
<
KeyTypeArg
uint64_t
>
(
)
?
"
u64
"
:
IsSame
<
KeyTypeArg
hwy
:
:
K32V32
>
(
)
?
"
k
+
v
=
64
"
:
"
?
"
;
}
}
;
template
<
class
D
HWY_IF_FLOAT_OR_SPECIAL_D
(
D
)
>
Vec
<
D
>
LargestSortValue
(
D
d
)
{
return
Inf
(
d
)
;
}
template
<
class
D
HWY_IF_NOT_FLOAT_NOR_SPECIAL_D
(
D
)
>
Vec
<
D
>
LargestSortValue
(
D
d
)
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
HWY_IF_FLOAT_OR_SPECIAL_D
(
D
)
>
Vec
<
D
>
SmallestSortValue
(
D
d
)
{
return
Neg
(
Inf
(
d
)
)
;
}
template
<
class
D
HWY_IF_NOT_FLOAT_NOR_SPECIAL_D
(
D
)
>
Vec
<
D
>
SmallestSortValue
(
D
d
)
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
HWY_IF_FLOAT_OR_SPECIAL_D
(
D
)
>
Vec
<
D
>
LargerSortValue
(
D
d
Vec
<
D
>
v
)
{
HWY_DASSERT
(
AllFalse
(
d
IsNaN
(
v
)
)
)
;
using
T
=
TFromD
<
decltype
(
d
)
>
;
const
RebindToUnsigned
<
D
>
du
;
using
VU
=
Vec
<
decltype
(
du
)
>
;
using
TU
=
TFromD
<
decltype
(
du
)
>
;
const
VU
vu
=
BitCast
(
du
Abs
(
v
)
)
;
const
Mask
<
decltype
(
du
)
>
was_pos
=
Le
(
BitCast
(
du
v
)
SignBit
(
du
)
)
;
const
VU
add
=
IfThenElse
(
was_pos
Set
(
du
1u
)
Set
(
du
LimitsMax
<
TU
>
(
)
)
)
;
v
=
BitCast
(
d
Add
(
vu
add
)
)
;
const
Mask
<
D
>
was_pos_f
=
RebindMask
(
d
was_pos
)
;
v
=
IfThenElse
(
IsFinite
(
v
)
v
IfThenElse
(
was_pos_f
Inf
(
d
)
Set
(
d
HighestValue
<
T
>
(
)
)
)
)
;
return
IfThenElse
(
was_pos_f
v
Neg
(
v
)
)
;
}
template
<
class
D
HWY_IF_FLOAT_OR_SPECIAL_D
(
D
)
>
Vec
<
D
>
SmallerSortValue
(
D
d
Vec
<
D
>
v
)
{
HWY_DASSERT
(
AllFalse
(
d
IsNaN
(
v
)
)
)
;
using
T
=
TFromD
<
decltype
(
d
)
>
;
const
RebindToUnsigned
<
D
>
du
;
using
VU
=
Vec
<
decltype
(
du
)
>
;
using
TU
=
TFromD
<
decltype
(
du
)
>
;
const
VU
vu
=
BitCast
(
du
Abs
(
v
)
)
;
const
Mask
<
D
>
was_pos
=
Gt
(
v
Zero
(
d
)
)
;
const
VU
add
=
IfThenElse
(
RebindMask
(
du
was_pos
)
Set
(
du
LimitsMax
<
TU
>
(
)
)
Set
(
du
1
)
)
;
v
=
BitCast
(
d
Add
(
vu
add
)
)
;
v
=
IfThenElse
(
IsFinite
(
v
)
v
IfThenElse
(
was_pos
Set
(
d
HighestValue
<
T
>
(
)
)
Inf
(
d
)
)
)
;
return
IfThenElse
(
was_pos
v
Neg
(
v
)
)
;
}
template
<
class
D
HWY_IF_NOT_FLOAT_NOR_SPECIAL_D
(
D
)
>
Vec
<
D
>
LargerSortValue
(
D
d
Vec
<
D
>
v
)
{
return
Add
(
v
Set
(
d
TFromD
<
D
>
{
1
}
)
)
;
}
template
<
class
D
HWY_IF_NOT_FLOAT_NOR_SPECIAL_D
(
D
)
>
Vec
<
D
>
SmallerSortValue
(
D
d
Vec
<
D
>
v
)
{
return
Sub
(
v
Set
(
d
TFromD
<
D
>
{
1
}
)
)
;
}
#
if
VQSORT_ENABLED
|
|
HWY_IDE
template
<
typename
LaneType
typename
KeyType
>
struct
KeyLane
:
public
KeyLaneBase
<
LaneType
KeyType
>
{
HWY_INLINE
void
Swap
(
LaneType
*
a
LaneType
*
b
)
const
{
const
LaneType
temp
=
*
a
;
*
a
=
*
b
;
*
b
=
temp
;
}
template
<
class
V
class
M
>
HWY_INLINE
V
CompressKeys
(
V
keys
M
mask
)
const
{
return
CompressNot
(
keys
mask
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SetKey
(
D
d
const
LaneType
*
key
)
const
{
return
Set
(
d
*
key
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
EqualKeys
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Eq
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
NotEqualKeys
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Ne
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
bool
NoKeyDifference
(
D
Vec
<
D
>
diff
)
const
{
const
RebindToUnsigned
<
D
>
du
;
return
AllTrue
(
du
Eq
(
BitCast
(
du
diff
)
Zero
(
du
)
)
)
;
}
HWY_INLINE
bool
Equal1
(
const
LaneType
*
a
const
LaneType
*
b
)
const
{
return
*
a
=
=
*
b
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys2
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse2
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys4
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse4
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys8
(
D
d
Vec
<
D
>
v
)
const
{
return
Reverse8
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys16
(
D
d
Vec
<
D
>
v
)
const
{
static_assert
(
SortConstants
:
:
kMaxCols
<
=
16
"
Assumes
u32x16
=
512
bit
"
)
;
return
ReverseKeys
(
d
v
)
;
}
template
<
class
V
>
HWY_INLINE
V
OddEvenKeys
(
const
V
odd
const
V
even
)
const
{
return
OddEven
(
odd
even
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
2
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentPairs
(
D
d
const
Vec
<
D
>
v
)
const
{
const
Repartition
<
uint32_t
D
>
du32
;
return
BitCast
(
d
Shuffle2301
(
BitCast
(
du32
v
)
)
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
4
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentPairs
(
D
const
Vec
<
D
>
v
)
const
{
return
Shuffle1032
(
v
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentPairs
(
D
const
Vec
<
D
>
v
)
const
{
return
SwapAdjacentBlocks
(
v
)
;
}
template
<
class
D
HWY_IF_NOT_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentQuads
(
D
d
const
Vec
<
D
>
v
)
const
{
#
if
HWY_HAVE_FLOAT64
const
RepartitionToWide
<
D
>
dw
;
#
else
const
RepartitionToWide
<
RebindToUnsigned
<
D
>
>
dw
;
#
endif
return
BitCast
(
d
SwapAdjacentPairs
(
dw
BitCast
(
dw
v
)
)
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentQuads
(
D
d
const
Vec
<
D
>
v
)
const
{
return
ConcatLowerUpper
(
d
v
v
)
;
}
template
<
class
D
HWY_IF_NOT_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenPairs
(
D
d
const
Vec
<
D
>
odd
const
Vec
<
D
>
even
)
const
{
#
if
HWY_HAVE_FLOAT64
const
RepartitionToWide
<
D
>
dw
;
#
else
const
RepartitionToWide
<
RebindToUnsigned
<
D
>
>
dw
;
#
endif
return
BitCast
(
d
OddEven
(
BitCast
(
dw
odd
)
BitCast
(
dw
even
)
)
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenPairs
(
D
Vec
<
D
>
odd
Vec
<
D
>
even
)
const
{
return
OddEvenBlocks
(
odd
even
)
;
}
template
<
class
D
HWY_IF_NOT_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenQuads
(
D
d
Vec
<
D
>
odd
Vec
<
D
>
even
)
const
{
#
if
HWY_HAVE_FLOAT64
const
RepartitionToWide
<
D
>
dw
;
#
else
const
RepartitionToWide
<
RebindToUnsigned
<
D
>
>
dw
;
#
endif
return
BitCast
(
d
OddEvenPairs
(
dw
BitCast
(
dw
odd
)
BitCast
(
dw
even
)
)
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
OddEvenQuads
(
D
d
Vec
<
D
>
odd
Vec
<
D
>
even
)
const
{
return
ConcatUpperLower
(
d
odd
even
)
;
}
}
;
template
<
typename
T
>
struct
OrderAscending
:
public
KeyLane
<
T
T
>
{
static
constexpr
bool
IsKV
(
)
{
return
false
;
}
using
Order
=
SortAscending
;
using
OrderForSortingNetwork
=
OrderAscending
<
T
>
;
HWY_INLINE
bool
Compare1
(
const
T
*
a
const
T
*
b
)
const
{
return
*
a
<
*
b
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
T
*
HWY_RESTRICT
)
const
{
return
MinOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
T
*
HWY_RESTRICT
)
const
{
return
MaxOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
SmallestSortValue
(
d
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
LargestSortValue
(
d
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
return
SmallerSortValue
(
d
v
)
;
}
}
;
template
<
typename
T
>
struct
OrderDescending
:
public
KeyLane
<
T
T
>
{
static
constexpr
bool
IsKV
(
)
{
return
false
;
}
using
Order
=
SortDescending
;
using
OrderForSortingNetwork
=
OrderDescending
<
T
>
;
HWY_INLINE
bool
Compare1
(
const
T
*
a
const
T
*
b
)
const
{
return
*
b
<
*
a
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt
(
b
a
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
T
*
HWY_RESTRICT
)
const
{
return
MaxOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
T
*
HWY_RESTRICT
)
const
{
return
MinOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
LargestSortValue
(
d
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
SmallestSortValue
(
d
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
return
LargerSortValue
(
d
v
)
;
}
}
;
struct
KeyValue64
:
public
KeyLane
<
uint64_t
hwy
:
:
K32V32
>
{
static
constexpr
bool
IsKV
(
)
{
return
true
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
EqualKeys
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Eq
(
ShiftRight
<
32
>
(
a
)
ShiftRight
<
32
>
(
b
)
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
NotEqualKeys
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Ne
(
ShiftRight
<
32
>
(
a
)
ShiftRight
<
32
>
(
b
)
)
;
}
HWY_INLINE
bool
Equal1
(
const
uint64_t
*
a
const
uint64_t
*
b
)
const
{
return
(
*
a
>
>
32
)
=
=
(
*
b
>
>
32
)
;
}
template
<
class
D
>
HWY_INLINE
bool
NoKeyDifference
(
D
Vec
<
D
>
diff
)
const
{
const
RebindToUnsigned
<
D
>
du
;
const
Vec
<
decltype
(
du
)
>
zero
=
Zero
(
du
)
;
const
Vec
<
decltype
(
du
)
>
keys
=
ShiftRight
<
32
>
(
diff
)
;
return
AllTrue
(
du
Eq
(
BitCast
(
du
keys
)
zero
)
)
;
}
}
;
struct
OrderAscendingKV64
:
public
KeyValue64
{
using
Order
=
SortAscending
;
using
OrderForSortingNetwork
=
OrderAscending
<
LaneType
>
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
const
{
return
(
*
a
>
>
32
)
<
(
*
b
>
>
32
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt
(
ShiftRight
<
32
>
(
a
)
ShiftRight
<
32
>
(
b
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
uint64_t
*
HWY_RESTRICT
)
const
{
return
MinOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
uint64_t
*
HWY_RESTRICT
)
const
{
return
MaxOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
return
Sub
(
v
Set
(
d
uint64_t
{
1
}
<
<
32
)
)
;
}
}
;
struct
OrderDescendingKV64
:
public
KeyValue64
{
using
Order
=
SortDescending
;
using
OrderForSortingNetwork
=
OrderDescending
<
LaneType
>
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
const
{
return
(
*
b
>
>
32
)
<
(
*
a
>
>
32
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt
(
ShiftRight
<
32
>
(
b
)
ShiftRight
<
32
>
(
a
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
uint64_t
*
HWY_RESTRICT
)
const
{
return
MaxOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
uint64_t
*
HWY_RESTRICT
)
const
{
return
MinOfLanes
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
return
Add
(
v
Set
(
d
uint64_t
{
1
}
<
<
32
)
)
;
}
}
;
template
<
class
Base
>
struct
TraitsLane
:
public
Base
{
using
TraitsForSortingNetwork
=
TraitsLane
<
typename
Base
:
:
OrderForSortingNetwork
>
;
template
<
class
D
>
HWY_INLINE
void
Sort2
(
D
d
Vec
<
D
>
&
a
Vec
<
D
>
&
b
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
const
Vec
<
D
>
a_copy
=
a
;
#
if
HWY_AVX3
<
HWY_TARGET
&
&
HWY_TARGET
<
=
HWY_SSSE3
if
(
sizeof
(
TFromD
<
D
>
)
=
=
8
)
{
const
Mask
<
D
>
cmp
=
base
-
>
Compare
(
d
a
b
)
;
a
=
IfThenElse
(
cmp
a
b
)
;
b
=
IfThenElse
(
cmp
b
a_copy
)
;
return
;
}
#
endif
a
=
base
-
>
First
(
d
a
b
)
;
b
=
base
-
>
Last
(
d
a_copy
b
)
;
}
template
<
class
D
HWY_IF_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance1
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys2
(
d
v
)
;
#
if
HWY_AVX3
<
HWY_TARGET
&
&
HWY_TARGET
<
=
HWY_SSSE3
const
Vec
<
D
>
cmp
=
VecFromMask
(
d
base
-
>
Compare
(
d
v
swapped
)
)
;
return
IfVecThenElse
(
DupOdd
(
cmp
)
swapped
v
)
;
#
else
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenKeys
(
swapped
v
)
;
#
endif
}
template
<
class
D
HWY_IF_NOT_T_SIZE_D
(
D
8
)
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance1
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys2
(
d
v
)
;
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenKeys
(
swapped
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsReverse4
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys4
(
d
v
)
;
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenPairs
(
d
swapped
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance4
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
SwapAdjacentQuads
(
d
v
)
;
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenQuads
(
d
swapped
v
)
;
}
}
;
#
else
template
<
typename
T
>
struct
OrderAscending
:
public
KeyLaneBase
<
T
T
>
{
using
Order
=
SortAscending
;
HWY_INLINE
bool
Compare1
(
const
T
*
a
const
T
*
b
)
const
{
return
*
a
<
*
b
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
{
return
Lt
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
LargestSortValue
(
d
)
;
}
}
;
template
<
typename
T
>
struct
OrderDescending
:
public
KeyLaneBase
<
T
T
>
{
using
Order
=
SortDescending
;
HWY_INLINE
bool
Compare1
(
const
T
*
a
const
T
*
b
)
const
{
return
*
b
<
*
a
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
{
return
Lt
(
b
a
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
SmallestSortValue
(
d
)
;
}
}
;
template
<
class
Order
>
struct
TraitsLane
:
public
Order
{
template
<
typename
T
>
HWY_INLINE
void
Swap
(
T
*
a
T
*
b
)
const
{
const
T
temp
=
*
a
;
*
a
=
*
b
;
*
b
=
temp
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SetKey
(
D
d
const
TFromD
<
D
>
*
key
)
const
{
return
Set
(
d
*
key
)
;
}
}
;
#
endif
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
