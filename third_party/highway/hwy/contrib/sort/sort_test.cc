#
include
<
inttypes
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
hwy
/
contrib
/
sort
/
sort_test
.
cc
"
#
include
"
hwy
/
foreach_target
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
sort
-
inl
.
h
"
#
include
"
hwy
/
tests
/
test_util
-
inl
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
#
if
HWY_TARGET
!
=
HWY_SCALAR
&
&
HWY_ARCH_X86
template
<
class
D
>
size_t
K
(
D
d
)
{
return
SortBatchSize
(
d
)
;
}
template
<
SortOrder
kOrder
class
D
>
void
Validate
(
D
d
const
TFromD
<
D
>
*
in
const
TFromD
<
D
>
*
out
)
{
const
size_t
N
=
Lanes
(
d
)
;
for
(
size_t
i
=
0
;
i
<
K
(
d
)
-
1
;
+
+
i
)
{
if
(
!
verify
:
:
Compare
(
out
[
i
]
out
[
i
+
1
]
kOrder
)
)
{
printf
(
"
range
=
%
"
PRIu64
"
lane
=
%
"
PRIu64
"
N
=
%
"
PRIu64
"
%
.
0f
%
.
0f
\
n
\
n
"
static_cast
<
uint64_t
>
(
i
)
static_cast
<
uint64_t
>
(
i
)
static_cast
<
uint64_t
>
(
N
)
static_cast
<
float
>
(
out
[
i
+
0
]
)
static_cast
<
float
>
(
out
[
i
+
1
]
)
)
;
for
(
size_t
i
=
0
;
i
<
K
(
d
)
;
+
+
i
)
{
printf
(
"
%
.
0f
\
n
"
static_cast
<
float
>
(
out
[
i
]
)
)
;
}
printf
(
"
\
n
\
nin
was
:
\
n
"
)
;
for
(
size_t
i
=
0
;
i
<
K
(
d
)
;
+
+
i
)
{
printf
(
"
%
.
0f
\
n
"
static_cast
<
float
>
(
in
[
i
]
)
)
;
}
fflush
(
stdout
)
;
HWY_ABORT
(
"
Sort
is
incorrect
"
)
;
}
}
double
expected_sum
=
0
.
0
;
double
actual_sum
=
0
.
0
;
for
(
size_t
i
=
0
;
i
<
K
(
d
)
;
+
+
i
)
{
expected_sum
+
=
in
[
i
]
;
actual_sum
+
=
out
[
i
]
;
}
if
(
expected_sum
!
=
actual_sum
)
{
for
(
size_t
i
=
0
;
i
<
K
(
d
)
;
+
+
i
)
{
printf
(
"
%
.
0f
%
.
0f
\
n
"
static_cast
<
float
>
(
in
[
i
]
)
static_cast
<
float
>
(
out
[
i
]
)
)
;
}
HWY_ABORT
(
"
Mismatch
"
)
;
}
}
class
TestReverse
{
template
<
SortOrder
kOrder
class
D
>
void
TestOrder
(
D
d
RandomState
&
)
{
using
T
=
TFromD
<
D
>
;
const
size_t
N
=
Lanes
(
d
)
;
HWY_ASSERT
(
(
N
%
4
)
=
=
0
)
;
auto
in
=
AllocateAligned
<
T
>
(
K
(
d
)
)
;
auto
inout
=
AllocateAligned
<
T
>
(
K
(
d
)
)
;
const
size_t
expected_size
=
SortBatchSize
(
d
)
;
for
(
size_t
i
=
0
;
i
<
K
(
d
)
;
+
+
i
)
{
in
[
i
]
=
static_cast
<
T
>
(
K
(
d
)
-
i
)
;
inout
[
i
]
=
in
[
i
]
;
}
const
size_t
actual_size
=
SortBatch
<
kOrder
>
(
d
inout
.
get
(
)
)
;
HWY_ASSERT_EQ
(
expected_size
actual_size
)
;
Validate
<
kOrder
>
(
d
in
.
get
(
)
inout
.
get
(
)
)
;
}
public
:
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
RandomState
rng
;
TestOrder
<
SortOrder
:
:
kAscending
>
(
d
rng
)
;
TestOrder
<
SortOrder
:
:
kDescending
>
(
d
rng
)
;
}
}
;
void
TestAllReverse
(
)
{
TestReverse
test
;
test
(
int32_t
(
)
CappedTag
<
int32_t
16
>
(
)
)
;
test
(
uint32_t
(
)
CappedTag
<
uint32_t
16
>
(
)
)
;
}
class
TestRanges
{
template
<
SortOrder
kOrder
class
D
>
void
TestOrder
(
D
d
RandomState
&
rng
)
{
using
T
=
TFromD
<
D
>
;
const
size_t
N
=
Lanes
(
d
)
;
HWY_ASSERT
(
(
N
%
4
)
=
=
0
)
;
auto
in
=
AllocateAligned
<
T
>
(
K
(
d
)
)
;
auto
inout
=
AllocateAligned
<
T
>
(
K
(
d
)
)
;
const
size_t
expected_size
=
SortBatchSize
(
d
)
;
constexpr
size_t
kRange
=
8
;
for
(
size_t
range
=
0
;
range
<
K
(
d
)
;
range
+
=
kRange
)
{
for
(
size_t
bits
=
0
;
bits
<
(
1ull
<
<
kRange
)
;
+
+
bits
)
{
for
(
size_t
i
=
0
;
i
<
K
(
d
)
;
+
+
i
)
{
in
[
i
]
=
inout
[
i
]
=
static_cast
<
T
>
(
Random32
(
&
rng
)
&
0xFF
)
;
}
for
(
size_t
i
=
0
;
i
<
kRange
;
+
+
i
)
{
in
[
range
+
i
]
=
inout
[
range
+
i
]
=
(
bits
>
>
i
)
&
1
;
}
const
size_t
actual_size
=
SortBatch
<
kOrder
>
(
d
inout
.
get
(
)
)
;
HWY_ASSERT_EQ
(
expected_size
actual_size
)
;
Validate
<
kOrder
>
(
d
in
.
get
(
)
inout
.
get
(
)
)
;
}
}
}
public
:
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
RandomState
rng
;
TestOrder
<
SortOrder
:
:
kAscending
>
(
d
rng
)
;
TestOrder
<
SortOrder
:
:
kDescending
>
(
d
rng
)
;
}
}
;
void
TestAllRanges
(
)
{
TestRanges
test
;
test
(
int32_t
(
)
CappedTag
<
int32_t
16
>
(
)
)
;
test
(
uint32_t
(
)
CappedTag
<
uint32_t
16
>
(
)
)
;
}
#
else
void
TestAllReverse
(
)
{
}
void
TestAllRanges
(
)
{
}
#
endif
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
hwy
{
HWY_BEFORE_TEST
(
SortTest
)
;
HWY_EXPORT_AND_TEST_P
(
SortTest
TestAllReverse
)
;
HWY_EXPORT_AND_TEST_P
(
SortTest
TestAllRanges
)
;
}
int
main
(
int
argc
char
*
*
argv
)
{
:
:
testing
:
:
InitGoogleTest
(
&
argc
argv
)
;
return
RUN_ALL_TESTS
(
)
;
}
#
endif
