#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
vector
>
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
hwy
/
contrib
/
sort
/
bench_sort
.
cc
"
#
include
"
hwy
/
foreach_target
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
algo
-
inl
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
vqsort
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
result
-
inl
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
sorting_networks
-
inl
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
traits
-
inl
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
traits128
-
inl
.
h
"
#
include
"
hwy
/
tests
/
test_util
-
inl
.
h
"
#
define
SORT_100M
0
#
define
SORT_BENCH_BASE_AND_PARTITION
0
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
extern
int64_t
first_sort_target
;
namespace
HWY_NAMESPACE
{
namespace
{
using
detail
:
:
TraitsLane
;
using
detail
:
:
OrderAscending
;
using
detail
:
:
OrderDescending
;
using
detail
:
:
SharedTraits
;
#
if
VQSORT_ENABLED
using
detail
:
:
OrderAscending128
;
using
detail
:
:
OrderAscendingKV128
;
using
detail
:
:
Traits128
;
#
endif
#
if
(
VQSORT_ENABLED
&
&
SORT_BENCH_BASE_AND_PARTITION
)
|
|
HWY_IDE
template
<
class
Traits
>
HWY_NOINLINE
void
BenchPartition
(
)
{
using
LaneType
=
typename
Traits
:
:
LaneType
;
using
KeyType
=
typename
Traits
:
:
KeyType
;
const
SortTag
<
LaneType
>
d
;
detail
:
:
SharedTraits
<
Traits
>
st
;
const
Dist
dist
=
Dist
:
:
kUniform8
;
double
sum
=
0
.
0
;
constexpr
size_t
kLPK
=
st
.
LanesPerKey
(
)
;
HWY_ALIGN
LaneType
buf
[
SortConstants
:
:
BufBytes
<
LaneType
>
(
HWY_MAX_BYTES
kLPK
)
/
sizeof
(
LaneType
)
]
;
uint64_t
*
HWY_RESTRICT
state
=
GetGeneratorState
(
)
;
const
size_t
max_log2
=
AdjustedLog2Reps
(
20
)
;
for
(
size_t
log2
=
max_log2
;
log2
<
max_log2
+
1
;
+
+
log2
)
{
const
size_t
num_lanes
=
1ull
<
<
log2
;
const
size_t
num_keys
=
num_lanes
/
kLPK
;
auto
aligned
=
hwy
:
:
AllocateAligned
<
LaneType
>
(
num_lanes
)
;
std
:
:
vector
<
double
>
seconds
;
const
size_t
num_reps
=
(
1ull
<
<
(
14
-
log2
/
2
)
)
*
30
;
for
(
size_t
rep
=
0
;
rep
<
num_reps
;
+
+
rep
)
{
(
void
)
GenerateInput
(
dist
aligned
.
get
(
)
num_lanes
)
;
detail
:
:
DrawSamples
(
d
st
aligned
.
get
(
)
num_lanes
buf
state
)
;
detail
:
:
SortSamples
(
d
st
buf
)
;
auto
pivot
=
detail
:
:
ChoosePivotByRank
(
d
st
buf
)
;
const
Timestamp
t0
;
detail
:
:
Partition
(
d
st
aligned
.
get
(
)
num_lanes
-
1
pivot
buf
)
;
seconds
.
push_back
(
SecondsSince
(
t0
)
)
;
sum
+
=
static_cast
<
double
>
(
aligned
.
get
(
)
[
num_lanes
/
2
]
)
;
}
Result
(
Algo
:
:
kVQSort
dist
num_keys
1
SummarizeMeasurements
(
seconds
)
sizeof
(
KeyType
)
st
.
KeyString
(
)
)
.
Print
(
)
;
}
HWY_ASSERT
(
sum
!
=
999999
)
;
}
HWY_NOINLINE
void
BenchAllPartition
(
)
{
if
(
HWY_TARGET
=
=
HWY_SSSE3
)
{
return
;
}
BenchPartition
<
TraitsLane
<
OrderDescending
<
float
>
>
>
(
)
;
BenchPartition
<
TraitsLane
<
OrderDescending
<
int32_t
>
>
>
(
)
;
BenchPartition
<
TraitsLane
<
OrderDescending
<
int64_t
>
>
>
(
)
;
BenchPartition
<
Traits128
<
OrderAscending128
>
>
(
)
;
BenchPartition
<
Traits128
<
OrderAscendingKV128
>
>
(
)
;
}
template
<
class
Traits
>
HWY_NOINLINE
void
BenchBase
(
std
:
:
vector
<
Result
>
&
results
)
{
if
(
HWY_TARGET
=
=
HWY_SSSE3
|
|
HWY_TARGET
=
=
HWY_SSE4
)
{
return
;
}
using
LaneType
=
typename
Traits
:
:
LaneType
;
using
KeyType
=
typename
Traits
:
:
KeyType
;
const
SortTag
<
LaneType
>
d
;
detail
:
:
SharedTraits
<
Traits
>
st
;
const
Dist
dist
=
Dist
:
:
kUniform32
;
const
size_t
N
=
Lanes
(
d
)
;
constexpr
size_t
kLPK
=
st
.
LanesPerKey
(
)
;
const
size_t
num_lanes
=
SortConstants
:
:
BaseCaseNumLanes
<
kLPK
>
(
N
)
;
const
size_t
num_keys
=
num_lanes
/
kLPK
;
auto
keys
=
hwy
:
:
AllocateAligned
<
LaneType
>
(
num_lanes
)
;
auto
buf
=
hwy
:
:
AllocateAligned
<
LaneType
>
(
num_lanes
+
N
)
;
std
:
:
vector
<
double
>
seconds
;
double
sum
=
0
;
constexpr
size_t
kMul
=
AdjustedReps
(
600
)
;
for
(
size_t
rep
=
0
;
rep
<
30
;
+
+
rep
)
{
InputStats
<
LaneType
>
input_stats
=
GenerateInput
(
dist
keys
.
get
(
)
num_lanes
)
;
const
Timestamp
t0
;
for
(
size_t
i
=
0
;
i
<
kMul
;
+
+
i
)
{
detail
:
:
BaseCase
(
d
st
keys
.
get
(
)
keys
.
get
(
)
+
num_lanes
num_lanes
buf
.
get
(
)
)
;
sum
+
=
static_cast
<
double
>
(
keys
[
0
]
)
;
}
seconds
.
push_back
(
SecondsSince
(
t0
)
)
;
HWY_ASSERT
(
VerifySort
(
st
input_stats
keys
.
get
(
)
num_lanes
"
BenchBase
"
)
)
;
}
HWY_ASSERT
(
sum
<
1E99
)
;
results
.
emplace_back
(
Algo
:
:
kVQSort
dist
num_keys
*
kMul
1
SummarizeMeasurements
(
seconds
)
sizeof
(
KeyType
)
st
.
KeyString
(
)
)
;
}
HWY_NOINLINE
void
BenchAllBase
(
)
{
if
(
HWY_TARGET
=
=
HWY_SSSE3
)
{
return
;
}
std
:
:
vector
<
Result
>
results
;
BenchBase
<
TraitsLane
<
OrderAscending
<
float
>
>
>
(
results
)
;
BenchBase
<
TraitsLane
<
OrderDescending
<
int64_t
>
>
>
(
results
)
;
BenchBase
<
Traits128
<
OrderAscending128
>
>
(
results
)
;
for
(
const
Result
&
r
:
results
)
{
r
.
Print
(
)
;
}
}
#
endif
std
:
:
vector
<
Algo
>
AlgoForBench
(
)
{
return
{
#
if
HAVE_AVX2SORT
Algo
:
:
kSEA
#
endif
#
if
HAVE_PARALLEL_IPS4O
Algo
:
:
kParallelIPS4O
#
elif
HAVE_IPS4O
Algo
:
:
kIPS4O
#
endif
#
if
HAVE_PDQSORT
Algo
:
:
kPDQ
#
endif
#
if
HAVE_SORT512
Algo
:
:
kSort512
#
endif
#
if
HAVE_VXSORT
&
&
(
(
VXSORT_AVX3
&
&
HWY_TARGET
=
=
HWY_AVX3
)
|
|
\
(
!
VXSORT_AVX3
&
&
HWY_TARGET
=
=
HWY_AVX2
)
)
Algo
:
:
kVXSort
#
endif
#
if
HAVE_INTEL
&
&
HWY_TARGET
<
=
HWY_AVX3
Algo
:
:
kIntel
#
endif
#
if
!
HAVE_PARALLEL_IPS4O
#
if
!
SORT_100M
Algo
:
:
kStd
#
endif
Algo
:
:
kVQSort
#
endif
}
;
}
template
<
class
Traits
>
HWY_NOINLINE
void
BenchSort
(
size_t
num_keys
)
{
if
(
first_sort_target
=
=
0
)
first_sort_target
=
HWY_TARGET
;
SharedState
shared
;
detail
:
:
SharedTraits
<
Traits
>
st
;
using
Order
=
typename
Traits
:
:
Order
;
using
LaneType
=
typename
Traits
:
:
LaneType
;
using
KeyType
=
typename
Traits
:
:
KeyType
;
const
size_t
num_lanes
=
num_keys
*
st
.
LanesPerKey
(
)
;
auto
aligned
=
hwy
:
:
AllocateAligned
<
LaneType
>
(
num_lanes
)
;
const
size_t
reps
=
num_keys
>
1000
*
1000
?
10
:
30
;
for
(
Algo
algo
:
AlgoForBench
(
)
)
{
#
if
!
HAVE_VXSORT
if
(
algo
!
=
Algo
:
:
kVQSort
&
&
HWY_TARGET
!
=
first_sort_target
)
{
continue
;
}
#
endif
for
(
Dist
dist
:
AllDist
(
)
)
{
std
:
:
vector
<
double
>
seconds
;
for
(
size_t
rep
=
0
;
rep
<
reps
;
+
+
rep
)
{
InputStats
<
LaneType
>
input_stats
=
GenerateInput
(
dist
aligned
.
get
(
)
num_lanes
)
;
const
Timestamp
t0
;
Run
<
Order
>
(
algo
reinterpret_cast
<
KeyType
*
>
(
aligned
.
get
(
)
)
num_keys
shared
0
)
;
seconds
.
push_back
(
SecondsSince
(
t0
)
)
;
HWY_ASSERT
(
VerifySort
(
st
input_stats
aligned
.
get
(
)
num_lanes
"
BenchSort
"
)
)
;
}
Result
(
algo
dist
num_keys
1
SummarizeMeasurements
(
seconds
)
sizeof
(
KeyType
)
st
.
KeyString
(
)
)
.
Print
(
)
;
}
}
}
enum
class
BenchmarkModes
{
kDefault
k1M
kAllSmall
kSmallPow2
kPow4
kPow10
}
;
std
:
:
vector
<
size_t
>
SizesToBenchmark
(
BenchmarkModes
mode
)
{
std
:
:
vector
<
size_t
>
sizes
;
switch
(
mode
)
{
default
:
case
BenchmarkModes
:
:
kDefault
:
#
if
HAVE_PARALLEL_IPS4O
|
|
SORT_100M
sizes
.
push_back
(
100
*
1000
*
size_t
{
1000
}
)
;
#
else
sizes
.
push_back
(
100
)
;
sizes
.
push_back
(
100
*
1000
)
;
#
endif
break
;
case
BenchmarkModes
:
:
k1M
:
sizes
.
push_back
(
1000
*
1000
)
;
break
;
case
BenchmarkModes
:
:
kAllSmall
:
sizes
.
reserve
(
128
)
;
for
(
size_t
i
=
1
;
i
<
=
128
;
+
+
i
)
{
sizes
.
push_back
(
i
)
;
}
break
;
case
BenchmarkModes
:
:
kSmallPow2
:
for
(
size_t
size
=
2
;
size
<
=
128
;
size
*
=
2
)
{
sizes
.
push_back
(
size
)
;
}
break
;
case
BenchmarkModes
:
:
kPow4
:
for
(
size_t
size
=
4
;
size
<
=
256
*
1024
;
size
*
=
4
)
{
sizes
.
push_back
(
size
)
;
}
break
;
case
BenchmarkModes
:
:
kPow10
:
for
(
size_t
size
=
10
;
size
<
=
100
*
1000
;
size
*
=
10
)
{
sizes
.
push_back
(
size
)
;
}
break
;
}
return
sizes
;
}
HWY_NOINLINE
void
BenchAllSort
(
)
{
if
(
HWY_SSE4
<
=
HWY_TARGET
&
&
HWY_TARGET
<
=
HWY_SSE2
)
{
return
;
}
#
if
HAVE_INTEL
if
(
HWY_TARGET
>
HWY_AVX3
)
return
;
#
endif
for
(
size_t
num_keys
:
SizesToBenchmark
(
BenchmarkModes
:
:
kSmallPow2
)
)
{
#
if
!
HAVE_INTEL
BenchSort
<
TraitsLane
<
OrderAscending
<
float
>
>
>
(
num_keys
)
;
#
endif
BenchSort
<
TraitsLane
<
OtherOrder
<
int32_t
>
>
>
(
num_keys
)
;
BenchSort
<
TraitsLane
<
OrderAscending
<
int64_t
>
>
>
(
num_keys
)
;
#
if
!
HAVE_VXSORT
&
&
!
HAVE_INTEL
&
&
VQSORT_ENABLED
BenchSort
<
Traits128
<
OrderAscending128
>
>
(
num_keys
)
;
BenchSort
<
Traits128
<
OrderAscendingKV128
>
>
(
num_keys
)
;
#
endif
}
}
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
hwy
{
int64_t
first_sort_target
=
0
;
namespace
{
HWY_BEFORE_TEST
(
BenchSort
)
;
#
if
SORT_BENCH_BASE_AND_PARTITION
HWY_EXPORT_AND_TEST_P
(
BenchSort
BenchAllPartition
)
;
HWY_EXPORT_AND_TEST_P
(
BenchSort
BenchAllBase
)
;
#
endif
HWY_EXPORT_AND_TEST_P
(
BenchSort
BenchAllSort
)
;
}
}
#
endif
