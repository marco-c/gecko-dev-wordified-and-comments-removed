#
if
defined
(
HIGHWAY_HWY_CONTRIB_SORT_TRAITS128_TOGGLE
)
=
=
\
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HIGHWAY_HWY_CONTRIB_SORT_TRAITS128_TOGGLE
#
undef
HIGHWAY_HWY_CONTRIB_SORT_TRAITS128_TOGGLE
#
else
#
define
HIGHWAY_HWY_CONTRIB_SORT_TRAITS128_TOGGLE
#
endif
#
include
<
string
>
#
include
"
hwy
/
contrib
/
sort
/
shared
-
inl
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
vqsort
.
h
"
#
include
"
hwy
/
highway
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
namespace
detail
{
#
if
VQSORT_ENABLED
|
|
HWY_IDE
struct
KeyAny128
{
constexpr
bool
Is128
(
)
const
{
return
true
;
}
constexpr
size_t
LanesPerKey
(
)
const
{
return
2
;
}
using
LaneType
=
uint64_t
;
HWY_INLINE
void
Swap
(
LaneType
*
a
LaneType
*
b
)
const
{
const
FixedTag
<
LaneType
2
>
d
;
const
auto
temp
=
LoadU
(
d
a
)
;
StoreU
(
LoadU
(
d
b
)
d
a
)
;
StoreU
(
temp
d
b
)
;
}
template
<
class
V
class
M
>
HWY_INLINE
V
CompressKeys
(
V
keys
M
mask
)
const
{
return
CompressBlocksNot
(
keys
mask
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SetKey
(
D
d
const
TFromD
<
D
>
*
key
)
const
{
return
LoadDup128
(
d
key
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys
(
D
d
Vec
<
D
>
v
)
const
{
return
ReverseBlocks
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys2
(
D
const
Vec
<
D
>
v
)
const
{
return
SwapAdjacentBlocks
(
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys4
(
D
d
const
Vec
<
D
>
v
)
const
{
HWY_DASSERT
(
Lanes
(
d
)
<
=
64
/
sizeof
(
TFromD
<
D
>
)
)
;
return
ReverseKeys
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
OddEvenPairs
(
D
d
const
Vec
<
D
>
odd
const
Vec
<
D
>
even
)
const
{
HWY_DASSERT
(
Lanes
(
d
)
<
=
64
/
sizeof
(
TFromD
<
D
>
)
)
;
return
ConcatUpperLower
(
d
odd
even
)
;
}
template
<
class
V
>
HWY_INLINE
V
OddEvenKeys
(
const
V
odd
const
V
even
)
const
{
return
OddEvenBlocks
(
odd
even
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys8
(
D
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys16
(
D
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentPairs
(
D
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentQuads
(
D
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
OddEvenQuads
(
D
Vec
<
D
>
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
}
;
struct
Key128
:
public
KeyAny128
{
using
KeyType
=
hwy
:
:
uint128_t
;
std
:
:
string
KeyString
(
)
const
{
return
"
U128
"
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
EqualKeys
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Eq128
(
a
b
)
;
}
HWY_INLINE
bool
Equal1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
a
[
0
]
=
=
b
[
0
]
&
&
a
[
1
]
=
=
b
[
1
]
;
}
}
;
struct
OrderAscending128
:
public
Key128
{
using
Order
=
SortAscending
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
(
a
[
1
]
=
=
b
[
1
]
)
?
a
[
0
]
<
b
[
0
]
:
a
[
1
]
<
b
[
1
]
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt128
(
d
a
b
)
;
}
template
<
class
V
>
HWY_INLINE
Mask
<
DFromV
<
V
>
>
CompareLanes
(
V
a
V
b
)
const
{
return
Lt
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min128
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max128
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
}
;
struct
OrderDescending128
:
public
Key128
{
using
Order
=
SortDescending
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
(
a
[
1
]
=
=
b
[
1
]
)
?
b
[
0
]
<
a
[
0
]
:
b
[
1
]
<
a
[
1
]
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt128
(
d
b
a
)
;
}
template
<
class
V
>
HWY_INLINE
Mask
<
DFromV
<
V
>
>
CompareLanes
(
V
a
V
b
)
const
{
return
Lt
(
b
a
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max128
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min128
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
}
;
struct
KeyValue128
:
public
KeyAny128
{
using
KeyType
=
K64V64
;
std
:
:
string
KeyString
(
)
const
{
return
"
KV128
"
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
EqualKeys
(
D
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Eq128Upper
(
a
b
)
;
}
HWY_INLINE
bool
Equal1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
a
[
1
]
=
=
b
[
1
]
;
}
}
;
struct
OrderAscendingKV128
:
public
KeyValue128
{
using
Order
=
SortAscending
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
a
[
1
]
<
b
[
1
]
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt128Upper
(
d
a
b
)
;
}
template
<
class
V
>
HWY_INLINE
Mask
<
DFromV
<
V
>
>
CompareLanes
(
V
a
V
b
)
const
{
return
Lt
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min128Upper
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max128Upper
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
}
;
struct
OrderDescendingKV128
:
public
KeyValue128
{
using
Order
=
SortDescending
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
b
[
1
]
<
a
[
1
]
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt128Upper
(
d
b
a
)
;
}
template
<
class
V
>
HWY_INLINE
Mask
<
DFromV
<
V
>
>
CompareLanes
(
V
a
V
b
)
const
{
return
Lt
(
b
a
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max128Upper
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min128Upper
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
}
;
template
<
class
Base
>
class
Traits128
:
public
Base
{
#
if
HWY_TARGET
<
=
HWY_AVX2
|
|
HWY_TARGET
=
=
HWY_SVE_256
template
<
class
D
>
HWY_INLINE
HWY_MAYBE_UNUSED
Vec
<
D
>
CompareTop
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
const
Mask
<
D
>
eqHL
=
Eq
(
a
b
)
;
const
Vec
<
D
>
ltHL
=
VecFromMask
(
d
base
-
>
CompareLanes
(
a
b
)
)
;
#
if
HWY_TARGET
=
=
HWY_SVE_256
return
IfThenElse
(
eqHL
DupEven
(
ltHL
)
ltHL
)
;
#
else
const
Vec
<
D
>
ltLX
=
ShiftLeftLanes
<
1
>
(
ltHL
)
;
return
OrAnd
(
ltHL
VecFromMask
(
d
eqHL
)
ltLX
)
;
#
endif
}
template
<
class
V
>
HWY_INLINE
V
ReplicateTop4x
(
V
v
)
const
{
#
if
HWY_TARGET
=
=
HWY_SVE_256
return
svdup_lane_u64
(
v
3
)
;
#
elif
HWY_TARGET
<
=
HWY_AVX3
return
V
{
_mm512_permutex_epi64
(
v
.
raw
_MM_SHUFFLE
(
3
3
3
3
)
)
}
;
#
else
return
V
{
_mm256_permute4x64_epi64
(
v
.
raw
_MM_SHUFFLE
(
3
3
3
3
)
)
}
;
#
endif
}
#
endif
public
:
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
TFromD
<
D
>
*
HWY_RESTRICT
buf
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
const
size_t
N
=
Lanes
(
d
)
;
Store
(
v
d
buf
)
;
v
=
base
-
>
SetKey
(
d
buf
+
0
)
;
for
(
size_t
i
=
base
-
>
LanesPerKey
(
)
;
i
<
N
;
i
+
=
base
-
>
LanesPerKey
(
)
)
{
v
=
base
-
>
First
(
d
v
base
-
>
SetKey
(
d
buf
+
i
)
)
;
}
return
v
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
TFromD
<
D
>
*
HWY_RESTRICT
buf
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
const
size_t
N
=
Lanes
(
d
)
;
Store
(
v
d
buf
)
;
v
=
base
-
>
SetKey
(
d
buf
+
0
)
;
for
(
size_t
i
=
base
-
>
LanesPerKey
(
)
;
i
<
N
;
i
+
=
base
-
>
LanesPerKey
(
)
)
{
v
=
base
-
>
Last
(
d
v
base
-
>
SetKey
(
d
buf
+
i
)
)
;
}
return
v
;
}
template
<
class
D
>
HWY_INLINE
void
Sort2
(
D
d
Vec
<
D
>
&
a
Vec
<
D
>
&
b
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
const
Vec
<
D
>
a_copy
=
a
;
const
auto
lt
=
base
-
>
Compare
(
d
a
b
)
;
a
=
IfThenElse
(
lt
a
b
)
;
b
=
IfThenElse
(
lt
b
a_copy
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance1
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys2
(
d
v
)
;
#
if
HWY_TARGET
<
=
HWY_AVX2
|
|
HWY_TARGET
=
=
HWY_SVE_256
const
Vec
<
D
>
select
=
ReplicateTop4x
(
CompareTop
(
d
v
swapped
)
)
;
return
IfVecThenElse
(
select
swapped
v
)
;
#
else
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenKeys
(
swapped
v
)
;
#
endif
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsReverse4
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys4
(
d
v
)
;
#
if
HWY_TARGET
<
=
HWY_AVX3
const
Vec512
<
uint64_t
>
outHx
=
CompareTop
(
d
v
swapped
)
;
alignas
(
64
)
uint64_t
kIndices
[
8
]
=
{
7
7
5
5
5
5
7
7
}
;
const
Vec512
<
uint64_t
>
select
=
TableLookupLanes
(
outHx
SetTableIndices
(
d
kIndices
)
)
;
return
IfVecThenElse
(
select
swapped
v
)
;
#
else
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenPairs
(
d
swapped
v
)
;
#
endif
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance4
(
D
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
}
;
#
endif
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
