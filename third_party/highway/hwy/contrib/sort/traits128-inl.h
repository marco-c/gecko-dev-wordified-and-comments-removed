#
if
defined
(
HIGHWAY_HWY_CONTRIB_SORT_TRAITS128_TOGGLE
)
=
=
\
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HIGHWAY_HWY_CONTRIB_SORT_TRAITS128_TOGGLE
#
undef
HIGHWAY_HWY_CONTRIB_SORT_TRAITS128_TOGGLE
#
else
#
define
HIGHWAY_HWY_CONTRIB_SORT_TRAITS128_TOGGLE
#
endif
#
include
<
string
>
#
include
"
hwy
/
contrib
/
sort
/
shared
-
inl
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
vqsort
.
h
"
#
include
"
hwy
/
highway
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
namespace
detail
{
#
if
VQSORT_ENABLED
|
|
HWY_IDE
struct
KeyAny128
{
static
constexpr
bool
Is128
(
)
{
return
true
;
}
constexpr
size_t
LanesPerKey
(
)
const
{
return
2
;
}
using
LaneType
=
uint64_t
;
HWY_INLINE
void
Swap
(
LaneType
*
a
LaneType
*
b
)
const
{
const
FixedTag
<
LaneType
2
>
d
;
const
auto
temp
=
LoadU
(
d
a
)
;
StoreU
(
LoadU
(
d
b
)
d
a
)
;
StoreU
(
temp
d
b
)
;
}
template
<
class
V
class
M
>
HWY_INLINE
V
CompressKeys
(
V
keys
M
mask
)
const
{
return
CompressBlocksNot
(
keys
mask
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SetKey
(
D
d
const
TFromD
<
D
>
*
key
)
const
{
return
LoadDup128
(
d
key
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys
(
D
d
Vec
<
D
>
v
)
const
{
return
ReverseBlocks
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys2
(
D
const
Vec
<
D
>
v
)
const
{
return
SwapAdjacentBlocks
(
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys4
(
D
d
const
Vec
<
D
>
v
)
const
{
HWY_DASSERT
(
Lanes
(
d
)
<
=
64
/
sizeof
(
TFromD
<
D
>
)
)
;
return
ReverseKeys
(
d
v
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
OddEvenPairs
(
D
d
const
Vec
<
D
>
odd
const
Vec
<
D
>
even
)
const
{
HWY_DASSERT
(
Lanes
(
d
)
<
=
64
/
sizeof
(
TFromD
<
D
>
)
)
;
return
ConcatUpperLower
(
d
odd
even
)
;
}
template
<
class
V
>
HWY_INLINE
V
OddEvenKeys
(
const
V
odd
const
V
even
)
const
{
return
OddEvenBlocks
(
odd
even
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys8
(
D
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
ReverseKeys16
(
D
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentPairs
(
D
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SwapAdjacentQuads
(
D
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
OddEvenQuads
(
D
Vec
<
D
>
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
}
;
struct
Key128
:
public
KeyAny128
{
static
constexpr
bool
IsKV
(
)
{
return
false
;
}
using
KeyType
=
hwy
:
:
uint128_t
;
std
:
:
string
KeyString
(
)
const
{
return
"
U128
"
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
EqualKeys
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Eq128
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
NotEqualKeys
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Ne128
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
bool
NoKeyDifference
(
D
Vec
<
D
>
diff
)
const
{
const
RebindToUnsigned
<
D
>
du
;
return
AllTrue
(
du
Eq
(
BitCast
(
du
diff
)
Zero
(
du
)
)
)
;
}
HWY_INLINE
bool
Equal1
(
const
LaneType
*
a
const
LaneType
*
b
)
const
{
return
a
[
0
]
=
=
b
[
0
]
&
&
a
[
1
]
=
=
b
[
1
]
;
}
}
;
struct
OrderAscending128
:
public
Key128
{
using
Order
=
SortAscending
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
(
a
[
1
]
=
=
b
[
1
]
)
?
a
[
0
]
<
b
[
0
]
:
a
[
1
]
<
b
[
1
]
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt128
(
d
a
b
)
;
}
template
<
class
V
>
HWY_INLINE
Mask
<
DFromV
<
V
>
>
CompareLanes
(
V
a
V
b
)
const
{
return
Lt
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min128
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max128
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
const
Vec
<
D
>
k0
=
Zero
(
d
)
;
const
Vec
<
D
>
k1
=
OddEven
(
k0
Set
(
d
uint64_t
{
1
}
)
)
;
const
Mask
<
D
>
borrow
=
Eq
(
v
k0
)
;
const
Vec
<
D
>
adjust
=
ShiftLeftLanes
<
1
>
(
IfThenElseZero
(
borrow
k1
)
)
;
return
Sub
(
Sub
(
v
k1
)
adjust
)
;
}
}
;
struct
OrderDescending128
:
public
Key128
{
using
Order
=
SortDescending
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
(
a
[
1
]
=
=
b
[
1
]
)
?
b
[
0
]
<
a
[
0
]
:
b
[
1
]
<
a
[
1
]
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt128
(
d
b
a
)
;
}
template
<
class
V
>
HWY_INLINE
Mask
<
DFromV
<
V
>
>
CompareLanes
(
V
a
V
b
)
const
{
return
Lt
(
b
a
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max128
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min128
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
const
Vec
<
D
>
k1
=
OddEven
(
Zero
(
d
)
Set
(
d
uint64_t
{
1
}
)
)
;
const
Vec
<
D
>
added
=
Add
(
v
k1
)
;
const
Mask
<
D
>
overflowed
=
Lt
(
added
v
)
;
const
Vec
<
D
>
adjust
=
ShiftLeftLanes
<
1
>
(
IfThenElseZero
(
overflowed
k1
)
)
;
return
Add
(
added
adjust
)
;
}
}
;
struct
KeyValue128
:
public
KeyAny128
{
static
constexpr
bool
IsKV
(
)
{
return
true
;
}
using
KeyType
=
K64V64
;
std
:
:
string
KeyString
(
)
const
{
return
"
KV128
"
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
EqualKeys
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Eq128Upper
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
NotEqualKeys
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Ne128Upper
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
bool
NoKeyDifference
(
D
Vec
<
D
>
diff
)
const
{
const
RebindToUnsigned
<
D
>
du
;
const
Vec
<
decltype
(
du
)
>
zero
=
Zero
(
du
)
;
const
Vec
<
decltype
(
du
)
>
keys
=
OddEven
(
diff
zero
)
;
return
AllTrue
(
du
Eq
(
BitCast
(
du
keys
)
zero
)
)
;
}
HWY_INLINE
bool
Equal1
(
const
LaneType
*
a
const
LaneType
*
b
)
const
{
return
a
[
1
]
=
=
b
[
1
]
;
}
}
;
struct
OrderAscendingKV128
:
public
KeyValue128
{
using
Order
=
SortAscending
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
a
[
1
]
<
b
[
1
]
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt128Upper
(
d
a
b
)
;
}
template
<
class
V
>
HWY_INLINE
Mask
<
DFromV
<
V
>
>
CompareLanes
(
V
a
V
b
)
const
{
return
Lt
(
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min128Upper
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max128Upper
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
const
Vec
<
D
>
k1
=
OddEven
(
Set
(
d
uint64_t
{
1
}
)
Zero
(
d
)
)
;
return
Sub
(
v
k1
)
;
}
}
;
struct
OrderDescendingKV128
:
public
KeyValue128
{
using
Order
=
SortDescending
;
HWY_INLINE
bool
Compare1
(
const
LaneType
*
a
const
LaneType
*
b
)
{
return
b
[
1
]
<
a
[
1
]
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
Compare
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
return
Lt128Upper
(
d
b
a
)
;
}
template
<
class
V
>
HWY_INLINE
Mask
<
DFromV
<
V
>
>
CompareLanes
(
V
a
V
b
)
const
{
return
Lt
(
b
a
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
First
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Max128Upper
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
Last
(
D
d
const
Vec
<
D
>
a
const
Vec
<
D
>
b
)
const
{
return
Min128Upper
(
d
a
b
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
HighestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastValue
(
D
d
)
const
{
return
Set
(
d
hwy
:
:
LowestValue
<
TFromD
<
D
>
>
(
)
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
PrevValue
(
D
d
Vec
<
D
>
v
)
const
{
const
Vec
<
D
>
k1
=
OddEven
(
Set
(
d
uint64_t
{
1
}
)
Zero
(
d
)
)
;
return
Add
(
v
k1
)
;
}
}
;
template
<
class
Base
>
class
Traits128
:
public
Base
{
#
if
HWY_TARGET
<
=
HWY_AVX2
|
|
HWY_TARGET
=
=
HWY_SVE_256
template
<
class
D
>
HWY_INLINE
HWY_MAYBE_UNUSED
Vec
<
D
>
CompareTop
(
D
d
Vec
<
D
>
a
Vec
<
D
>
b
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
const
Mask
<
D
>
eqHL
=
Eq
(
a
b
)
;
const
Vec
<
D
>
ltHL
=
VecFromMask
(
d
base
-
>
CompareLanes
(
a
b
)
)
;
#
if
HWY_TARGET
=
=
HWY_SVE_256
return
IfThenElse
(
eqHL
DupEven
(
ltHL
)
ltHL
)
;
#
else
const
Vec
<
D
>
ltLX
=
ShiftLeftLanes
<
1
>
(
ltHL
)
;
return
OrAnd
(
ltHL
VecFromMask
(
d
eqHL
)
ltLX
)
;
#
endif
}
template
<
class
V
>
HWY_INLINE
V
ReplicateTop4x
(
V
v
)
const
{
#
if
HWY_TARGET
=
=
HWY_SVE_256
return
svdup_lane_u64
(
v
3
)
;
#
elif
HWY_TARGET
<
=
HWY_AVX3
return
V
{
_mm512_permutex_epi64
(
v
.
raw
_MM_SHUFFLE
(
3
3
3
3
)
)
}
;
#
else
return
V
{
_mm256_permute4x64_epi64
(
v
.
raw
_MM_SHUFFLE
(
3
3
3
3
)
)
}
;
#
endif
}
#
endif
public
:
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
FirstOfLanes
(
D
d
Vec
<
D
>
v
TFromD
<
D
>
*
HWY_RESTRICT
buf
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
const
size_t
N
=
Lanes
(
d
)
;
Store
(
v
d
buf
)
;
v
=
base
-
>
SetKey
(
d
buf
+
0
)
;
for
(
size_t
i
=
base
-
>
LanesPerKey
(
)
;
i
<
N
;
i
+
=
base
-
>
LanesPerKey
(
)
)
{
v
=
base
-
>
First
(
d
v
base
-
>
SetKey
(
d
buf
+
i
)
)
;
}
return
v
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
LastOfLanes
(
D
d
Vec
<
D
>
v
TFromD
<
D
>
*
HWY_RESTRICT
buf
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
const
size_t
N
=
Lanes
(
d
)
;
Store
(
v
d
buf
)
;
v
=
base
-
>
SetKey
(
d
buf
+
0
)
;
for
(
size_t
i
=
base
-
>
LanesPerKey
(
)
;
i
<
N
;
i
+
=
base
-
>
LanesPerKey
(
)
)
{
v
=
base
-
>
Last
(
d
v
base
-
>
SetKey
(
d
buf
+
i
)
)
;
}
return
v
;
}
template
<
class
D
>
HWY_INLINE
void
Sort2
(
D
d
Vec
<
D
>
&
a
Vec
<
D
>
&
b
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
const
Vec
<
D
>
a_copy
=
a
;
const
auto
lt
=
base
-
>
Compare
(
d
a
b
)
;
a
=
IfThenElse
(
lt
a
b
)
;
b
=
IfThenElse
(
lt
b
a_copy
)
;
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance1
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys2
(
d
v
)
;
#
if
HWY_TARGET
<
=
HWY_AVX2
|
|
HWY_TARGET
=
=
HWY_SVE_256
const
Vec
<
D
>
select
=
ReplicateTop4x
(
CompareTop
(
d
v
swapped
)
)
;
return
IfVecThenElse
(
select
swapped
v
)
;
#
else
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenKeys
(
swapped
v
)
;
#
endif
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsReverse4
(
D
d
Vec
<
D
>
v
)
const
{
const
Base
*
base
=
static_cast
<
const
Base
*
>
(
this
)
;
Vec
<
D
>
swapped
=
base
-
>
ReverseKeys4
(
d
v
)
;
#
if
HWY_TARGET
<
=
HWY_AVX3
const
Vec512
<
uint64_t
>
outHx
=
CompareTop
(
d
v
swapped
)
;
alignas
(
64
)
uint64_t
kIndices
[
8
]
=
{
7
7
5
5
5
5
7
7
}
;
const
Vec512
<
uint64_t
>
select
=
TableLookupLanes
(
outHx
SetTableIndices
(
d
kIndices
)
)
;
return
IfVecThenElse
(
select
swapped
v
)
;
#
else
Sort2
(
d
v
swapped
)
;
return
base
-
>
OddEvenPairs
(
d
swapped
v
)
;
#
endif
}
template
<
class
D
>
HWY_INLINE
Vec
<
D
>
SortPairsDistance4
(
D
Vec
<
D
>
)
const
{
HWY_ASSERT
(
0
)
;
}
}
;
#
endif
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
