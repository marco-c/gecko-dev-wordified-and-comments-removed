#
ifndef
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_INL_H_
#
define
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_INL_H_
#
ifndef
VQSORT_PRINT
#
define
VQSORT_PRINT
0
#
endif
#
ifndef
VQSORT_SECURE_RNG
#
define
VQSORT_SECURE_RNG
0
#
endif
#
if
VQSORT_SECURE_RNG
#
include
"
third_party
/
absl
/
random
/
random
.
h
"
#
endif
#
if
VQSORT_PRINT
#
include
<
stdio
.
h
>
#
endif
#
include
<
string
.
h
>
#
include
"
hwy
/
cache_control
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
vqsort
.
h
"
#
if
HWY_IS_MSAN
#
include
<
sanitizer
/
msan_interface
.
h
>
#
endif
#
endif
#
if
defined
(
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_TOGGLE
)
=
=
\
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_TOGGLE
#
undef
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_TOGGLE
#
else
#
define
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_TOGGLE
#
endif
#
if
VQSORT_PRINT
#
include
"
hwy
/
print
-
inl
.
h
"
#
endif
#
include
"
hwy
/
contrib
/
sort
/
shared
-
inl
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
sorting_networks
-
inl
.
h
"
#
include
"
hwy
/
highway
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
namespace
detail
{
using
Constants
=
hwy
:
:
SortConstants
;
template
<
class
Traits
typename
T
>
void
SiftDown
(
Traits
st
T
*
HWY_RESTRICT
lanes
const
size_t
num_lanes
size_t
start
)
{
constexpr
size_t
N1
=
st
.
LanesPerKey
(
)
;
const
FixedTag
<
T
N1
>
d
;
while
(
start
<
num_lanes
)
{
const
size_t
left
=
2
*
start
+
N1
;
const
size_t
right
=
2
*
start
+
2
*
N1
;
if
(
left
>
=
num_lanes
)
break
;
size_t
idx_larger
=
start
;
const
auto
key_j
=
st
.
SetKey
(
d
lanes
+
start
)
;
if
(
AllTrue
(
d
st
.
Compare
(
d
key_j
st
.
SetKey
(
d
lanes
+
left
)
)
)
)
{
idx_larger
=
left
;
}
if
(
right
<
num_lanes
&
&
AllTrue
(
d
st
.
Compare
(
d
st
.
SetKey
(
d
lanes
+
idx_larger
)
st
.
SetKey
(
d
lanes
+
right
)
)
)
)
{
idx_larger
=
right
;
}
if
(
idx_larger
=
=
start
)
break
;
st
.
Swap
(
lanes
+
start
lanes
+
idx_larger
)
;
start
=
idx_larger
;
}
}
template
<
class
Traits
typename
T
>
void
HeapSort
(
Traits
st
T
*
HWY_RESTRICT
lanes
const
size_t
num_lanes
)
{
constexpr
size_t
N1
=
st
.
LanesPerKey
(
)
;
if
(
num_lanes
<
2
*
N1
)
return
;
for
(
size_t
i
=
(
(
num_lanes
-
N1
)
/
N1
/
2
)
*
N1
;
i
!
=
(
~
N1
+
1
)
;
i
-
=
N1
)
{
SiftDown
(
st
lanes
num_lanes
i
)
;
}
for
(
size_t
i
=
num_lanes
-
N1
;
i
!
=
0
;
i
-
=
N1
)
{
st
.
Swap
(
lanes
+
0
lanes
+
i
)
;
SiftDown
(
st
lanes
i
0
)
;
}
}
#
if
VQSORT_ENABLED
|
|
HWY_IDE
template
<
class
D
class
Traits
typename
T
>
HWY_NOINLINE
void
BaseCase
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
T
*
HWY_RESTRICT
keys_end
size_t
num
T
*
HWY_RESTRICT
buf
)
{
const
size_t
N
=
Lanes
(
d
)
;
using
V
=
decltype
(
Zero
(
d
)
)
;
if
(
HWY_UNLIKELY
(
num
<
=
1
)
)
return
;
const
size_t
num_pow2
=
size_t
{
1
}
<
<
(
32
-
Num0BitsAboveMS1Bit_Nonzero32
(
static_cast
<
uint32_t
>
(
num
-
1
)
)
)
;
HWY_DASSERT
(
num
<
=
num_pow2
&
&
num_pow2
<
=
Constants
:
:
BaseCaseNum
(
N
)
)
;
const
size_t
cols
=
HWY_MAX
(
st
.
LanesPerKey
(
)
num_pow2
>
>
Constants
:
:
kMaxRowsLog2
)
;
HWY_DASSERT
(
cols
<
=
N
)
;
const
size_t
N_sn
=
Lanes
(
CappedTag
<
T
Constants
:
:
kMaxCols
>
(
)
)
;
if
(
HWY_LIKELY
(
keys
+
N_sn
*
Constants
:
:
kMaxRows
<
=
keys_end
)
)
{
SortingNetwork
(
st
keys
N_sn
)
;
return
;
}
size_t
i
;
for
(
i
=
0
;
i
+
N
<
=
num
;
i
+
=
N
)
{
Store
(
LoadU
(
d
keys
+
i
)
d
buf
+
i
)
;
}
SafeCopyN
(
num
-
i
d
keys
+
i
buf
+
i
)
;
i
=
num
;
const
V
kPadding
=
st
.
LastValue
(
d
)
;
for
(
;
i
<
(
cols
*
Constants
:
:
kMaxRows
+
N
)
;
i
+
=
N
)
{
StoreU
(
kPadding
d
buf
+
i
)
;
}
SortingNetwork
(
st
buf
cols
)
;
for
(
i
=
0
;
i
+
N
<
=
num
;
i
+
=
N
)
{
StoreU
(
Load
(
d
buf
+
i
)
d
keys
+
i
)
;
}
SafeCopyN
(
num
-
i
d
buf
+
i
keys
+
i
)
;
}
template
<
class
D
class
Traits
class
T
>
HWY_NOINLINE
void
PartitionToMultipleOfUnroll
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
&
left
size_t
&
right
const
Vec
<
D
>
pivot
T
*
HWY_RESTRICT
buf
)
{
constexpr
size_t
kUnroll
=
Constants
:
:
kPartitionUnroll
;
const
size_t
N
=
Lanes
(
d
)
;
size_t
readL
=
left
;
size_t
bufR
=
0
;
const
size_t
num
=
right
-
left
;
const
size_t
num_rem
=
(
num
<
2
*
kUnroll
*
N
)
?
num
:
(
num
&
(
kUnroll
*
N
-
1
)
)
;
size_t
i
=
0
;
for
(
;
i
+
N
<
=
num_rem
;
i
+
=
N
)
{
const
Vec
<
D
>
vL
=
LoadU
(
d
keys
+
readL
)
;
readL
+
=
N
;
const
auto
comp
=
st
.
Compare
(
d
pivot
vL
)
;
left
+
=
CompressBlendedStore
(
vL
Not
(
comp
)
d
keys
+
left
)
;
bufR
+
=
CompressStore
(
vL
comp
d
buf
+
bufR
)
;
}
if
(
HWY_LIKELY
(
i
!
=
num_rem
)
)
{
const
auto
mask
=
FirstN
(
d
num_rem
-
i
)
;
const
Vec
<
D
>
vL
=
LoadU
(
d
keys
+
readL
)
;
const
auto
comp
=
st
.
Compare
(
d
pivot
vL
)
;
left
+
=
CompressBlendedStore
(
vL
AndNot
(
comp
mask
)
d
keys
+
left
)
;
bufR
+
=
CompressStore
(
vL
And
(
comp
mask
)
d
buf
+
bufR
)
;
}
#
if
HWY_IS_MSAN
__msan_unpoison
(
buf
bufR
*
sizeof
(
T
)
)
;
#
endif
right
-
=
bufR
;
memcpy
(
keys
+
left
keys
+
right
bufR
*
sizeof
(
T
)
)
;
memcpy
(
keys
+
right
buf
bufR
*
sizeof
(
T
)
)
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
void
StoreLeftRight
(
D
d
Traits
st
const
Vec
<
D
>
v
const
Vec
<
D
>
pivot
T
*
HWY_RESTRICT
keys
size_t
&
writeL
size_t
&
remaining
)
{
const
size_t
N
=
Lanes
(
d
)
;
const
auto
comp
=
st
.
Compare
(
d
pivot
v
)
;
remaining
-
=
N
;
if
(
hwy
:
:
HWY_NAMESPACE
:
:
CompressIsPartition
<
T
>
:
:
value
|
|
(
HWY_MAX_BYTES
=
=
16
&
&
st
.
Is128
(
)
)
)
{
const
auto
lr
=
st
.
CompressKeys
(
v
comp
)
;
const
size_t
num_left
=
N
-
CountTrue
(
d
comp
)
;
StoreU
(
lr
d
keys
+
writeL
)
;
StoreU
(
lr
d
keys
+
remaining
+
writeL
)
;
writeL
+
=
num_left
;
}
else
{
const
size_t
num_left
=
CompressStore
(
v
Not
(
comp
)
d
keys
+
writeL
)
;
writeL
+
=
num_left
;
(
void
)
CompressBlendedStore
(
v
comp
d
keys
+
remaining
+
writeL
)
;
}
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
void
StoreLeftRight4
(
D
d
Traits
st
const
Vec
<
D
>
v0
const
Vec
<
D
>
v1
const
Vec
<
D
>
v2
const
Vec
<
D
>
v3
const
Vec
<
D
>
pivot
T
*
HWY_RESTRICT
keys
size_t
&
writeL
size_t
&
remaining
)
{
StoreLeftRight
(
d
st
v0
pivot
keys
writeL
remaining
)
;
StoreLeftRight
(
d
st
v1
pivot
keys
writeL
remaining
)
;
StoreLeftRight
(
d
st
v2
pivot
keys
writeL
remaining
)
;
StoreLeftRight
(
d
st
v3
pivot
keys
writeL
remaining
)
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_NOINLINE
size_t
Partition
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
left
size_t
right
const
Vec
<
D
>
pivot
T
*
HWY_RESTRICT
buf
)
{
using
V
=
decltype
(
Zero
(
d
)
)
;
const
size_t
N
=
Lanes
(
d
)
;
HWY_DASSERT
(
right
-
left
>
2
*
N
)
;
right
-
=
N
;
const
size_t
last
=
right
;
const
V
vlast
=
LoadU
(
d
keys
+
last
)
;
PartitionToMultipleOfUnroll
(
d
st
keys
left
right
pivot
buf
)
;
constexpr
size_t
kUnroll
=
Constants
:
:
kPartitionUnroll
;
size_t
writeL
=
left
;
size_t
remaining
=
right
-
left
;
const
size_t
num
=
right
-
left
;
if
(
HWY_LIKELY
(
num
!
=
0
)
)
{
HWY_DASSERT
(
num
>
=
2
*
kUnroll
*
N
)
;
HWY_DASSERT
(
(
num
&
(
kUnroll
*
N
-
1
)
)
=
=
0
)
;
const
V
vL0
=
LoadU
(
d
keys
+
left
+
0
*
N
)
;
const
V
vL1
=
LoadU
(
d
keys
+
left
+
1
*
N
)
;
const
V
vL2
=
LoadU
(
d
keys
+
left
+
2
*
N
)
;
const
V
vL3
=
LoadU
(
d
keys
+
left
+
3
*
N
)
;
left
+
=
kUnroll
*
N
;
right
-
=
kUnroll
*
N
;
const
V
vR0
=
LoadU
(
d
keys
+
right
+
0
*
N
)
;
const
V
vR1
=
LoadU
(
d
keys
+
right
+
1
*
N
)
;
const
V
vR2
=
LoadU
(
d
keys
+
right
+
2
*
N
)
;
const
V
vR3
=
LoadU
(
d
keys
+
right
+
3
*
N
)
;
while
(
left
!
=
right
)
{
V
v0
v1
v2
v3
;
const
size_t
capacityL
=
left
-
writeL
;
HWY_DASSERT
(
capacityL
<
=
num
)
;
if
(
kUnroll
*
N
<
capacityL
)
{
right
-
=
kUnroll
*
N
;
v0
=
LoadU
(
d
keys
+
right
+
0
*
N
)
;
v1
=
LoadU
(
d
keys
+
right
+
1
*
N
)
;
v2
=
LoadU
(
d
keys
+
right
+
2
*
N
)
;
v3
=
LoadU
(
d
keys
+
right
+
3
*
N
)
;
hwy
:
:
Prefetch
(
keys
+
right
-
3
*
kUnroll
*
N
)
;
}
else
{
v0
=
LoadU
(
d
keys
+
left
+
0
*
N
)
;
v1
=
LoadU
(
d
keys
+
left
+
1
*
N
)
;
v2
=
LoadU
(
d
keys
+
left
+
2
*
N
)
;
v3
=
LoadU
(
d
keys
+
left
+
3
*
N
)
;
left
+
=
kUnroll
*
N
;
hwy
:
:
Prefetch
(
keys
+
left
+
3
*
kUnroll
*
N
)
;
}
StoreLeftRight4
(
d
st
v0
v1
v2
v3
pivot
keys
writeL
remaining
)
;
}
StoreLeftRight4
(
d
st
vL0
vL1
vL2
vL3
pivot
keys
writeL
remaining
)
;
StoreLeftRight4
(
d
st
vR0
vR1
vR2
vR3
pivot
keys
writeL
remaining
)
;
}
HWY_DASSERT
(
remaining
=
=
0
)
;
const
size_t
totalR
=
last
-
writeL
;
const
size_t
startR
=
totalR
<
N
?
writeL
+
totalR
-
N
:
writeL
;
StoreU
(
LoadU
(
d
keys
+
startR
)
d
keys
+
last
)
;
const
auto
comp
=
st
.
Compare
(
d
pivot
vlast
)
;
writeL
+
=
CompressBlendedStore
(
vlast
Not
(
comp
)
d
keys
+
writeL
)
;
(
void
)
CompressBlendedStore
(
vlast
comp
d
keys
+
writeL
)
;
return
writeL
;
}
template
<
class
Traits
class
V
>
HWY_INLINE
V
MedianOf3
(
Traits
st
V
v0
V
v1
V
v2
)
{
const
DFromV
<
V
>
d
;
if
(
st
.
Is128
(
)
)
{
const
auto
sum
=
Xor
(
Xor
(
v0
v1
)
v2
)
;
const
auto
first
=
st
.
First
(
d
st
.
First
(
d
v0
v1
)
v2
)
;
const
auto
last
=
st
.
Last
(
d
st
.
Last
(
d
v0
v1
)
v2
)
;
return
Xor
(
Xor
(
sum
first
)
last
)
;
}
st
.
Sort2
(
d
v0
v2
)
;
v1
=
st
.
Last
(
d
v0
v1
)
;
v1
=
st
.
First
(
d
v1
v2
)
;
return
v1
;
}
#
if
VQSORT_SECURE_RNG
using
Generator
=
absl
:
:
BitGen
;
#
else
#
pragma
pack
(
push
1
)
class
Generator
{
public
:
Generator
(
const
void
*
heap
size_t
num
)
{
Sorter
:
:
Fill24Bytes
(
heap
num
&
a_
)
;
k_
=
1
;
}
explicit
Generator
(
uint64_t
seed
)
{
a_
=
b_
=
w_
=
seed
;
k_
=
1
;
}
uint64_t
operator
(
)
(
)
{
const
uint64_t
b
=
b_
;
w_
+
=
k_
;
const
uint64_t
next
=
a_
^
w_
;
a_
=
(
b
+
(
b
<
<
3
)
)
^
(
b
>
>
11
)
;
const
uint64_t
rot
=
(
b
<
<
24
)
|
(
b
>
>
40
)
;
b_
=
rot
+
next
;
return
next
;
}
private
:
uint64_t
a_
;
uint64_t
b_
;
uint64_t
w_
;
uint64_t
k_
;
}
;
#
pragma
pack
(
pop
)
#
endif
HWY_INLINE
size_t
RandomChunkIndex
(
const
uint32_t
num_chunks
uint32_t
bits
)
{
const
uint64_t
chunk_index
=
(
static_cast
<
uint64_t
>
(
bits
)
*
num_chunks
)
>
>
32
;
HWY_DASSERT
(
chunk_index
<
num_chunks
)
;
return
static_cast
<
size_t
>
(
chunk_index
)
;
}
template
<
class
Traits
typename
T
>
HWY_INLINE
void
SortSamples
(
Traits
st
T
*
HWY_RESTRICT
buf
)
{
constexpr
size_t
kSampleLanes
=
3
*
64
/
sizeof
(
T
)
;
const
CappedTag
<
T
16
/
sizeof
(
T
)
>
d128
;
const
size_t
N128
=
Lanes
(
d128
)
;
constexpr
size_t
kCols
=
HWY_MIN
(
16
/
sizeof
(
T
)
Constants
:
:
kMaxCols
)
;
constexpr
size_t
kBytes
=
kCols
*
Constants
:
:
kMaxRows
*
sizeof
(
T
)
;
static_assert
(
192
<
=
kBytes
"
"
)
;
const
auto
kPadding
=
st
.
LastValue
(
d128
)
;
for
(
size_t
i
=
kSampleLanes
;
i
<
=
kBytes
/
sizeof
(
T
)
;
i
+
=
N128
)
{
StoreU
(
kPadding
d128
buf
+
i
)
;
}
SortingNetwork
(
st
buf
kCols
)
;
}
template
<
class
Traits
typename
T
>
HWY_INLINE
size_t
PivotRank
(
Traits
st
T
*
HWY_RESTRICT
buf
)
{
constexpr
size_t
kSampleLanes
=
3
*
64
/
sizeof
(
T
)
;
constexpr
size_t
N1
=
st
.
LanesPerKey
(
)
;
constexpr
size_t
kRankMid
=
kSampleLanes
/
2
;
static_assert
(
kRankMid
%
N1
=
=
0
"
Mid
is
not
an
aligned
key
"
)
;
size_t
rank_prev
=
kRankMid
-
N1
;
for
(
;
st
.
Equal1
(
buf
+
rank_prev
buf
+
kRankMid
)
;
rank_prev
-
=
N1
)
{
if
(
rank_prev
=
=
0
)
return
0
;
}
size_t
rank_next
=
rank_prev
+
N1
;
for
(
;
st
.
Equal1
(
buf
+
rank_next
buf
+
kRankMid
)
;
rank_next
+
=
N1
)
{
if
(
rank_next
=
=
kSampleLanes
-
N1
)
return
rank_prev
;
}
const
size_t
excess_if_median
=
rank_next
-
kRankMid
;
const
size_t
excess_if_prev
=
kRankMid
-
rank_prev
;
return
excess_if_median
<
excess_if_prev
?
kRankMid
:
rank_prev
;
}
#
if
VQSORT_PRINT
template
<
class
D
class
Traits
typename
T
>
HWY_NOINLINE
void
ScanMinMax
(
D
d
Traits
st
const
T
*
HWY_RESTRICT
keys
size_t
num
T
*
HWY_RESTRICT
buf
Vec
<
D
>
&
first
Vec
<
D
>
&
last
)
{
const
size_t
N
=
Lanes
(
d
)
;
first
=
st
.
LastValue
(
d
)
;
last
=
st
.
FirstValue
(
d
)
;
size_t
i
=
0
;
for
(
;
i
+
N
<
=
num
;
i
+
=
N
)
{
const
Vec
<
D
>
v
=
LoadU
(
d
keys
+
i
)
;
first
=
st
.
First
(
d
v
first
)
;
last
=
st
.
Last
(
d
v
last
)
;
}
if
(
HWY_LIKELY
(
i
!
=
num
)
)
{
HWY_DASSERT
(
num
>
=
N
)
;
const
Vec
<
D
>
v
=
LoadU
(
d
keys
+
num
-
N
)
;
first
=
st
.
First
(
d
v
first
)
;
last
=
st
.
Last
(
d
v
last
)
;
}
first
=
st
.
FirstOfLanes
(
d
first
buf
)
;
last
=
st
.
LastOfLanes
(
d
last
buf
)
;
}
#
endif
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
bool
ScanEqual
(
D
d
Traits
st
const
T
*
HWY_RESTRICT
keys
size_t
num
)
{
using
V
=
Vec
<
decltype
(
d
)
>
;
const
size_t
N
=
Lanes
(
d
)
;
HWY_DASSERT
(
num
>
=
N
)
;
const
V
reference
=
st
.
SetKey
(
d
keys
)
;
const
V
zero
=
Zero
(
d
)
;
V
diff0
=
zero
;
V
diff1
=
zero
;
constexpr
size_t
kLoops
=
4
;
const
size_t
lanes_per_group
=
kLoops
*
2
*
N
;
size_t
i
=
0
;
for
(
;
i
+
lanes_per_group
<
=
num
;
i
+
=
lanes_per_group
)
{
for
(
size_t
loop
=
0
;
loop
<
kLoops
;
+
+
loop
)
{
const
V
v0
=
LoadU
(
d
keys
+
i
+
loop
*
2
*
N
)
;
const
V
v1
=
LoadU
(
d
keys
+
i
+
loop
*
2
*
N
+
N
)
;
diff0
=
Or
(
diff0
Xor
(
v0
reference
)
)
;
diff1
=
Or
(
diff1
Xor
(
v1
reference
)
)
;
}
diff0
=
Or
(
diff0
diff1
)
;
if
(
!
AllTrue
(
d
Eq
(
diff0
zero
)
)
)
{
return
false
;
}
}
for
(
;
i
+
N
<
=
num
;
i
+
=
N
)
{
const
V
v0
=
LoadU
(
d
keys
+
i
)
;
diff0
=
Or
(
diff0
Xor
(
v0
reference
)
)
;
if
(
!
AllTrue
(
d
Eq
(
diff0
zero
)
)
)
{
return
false
;
}
}
if
(
HWY_LIKELY
(
i
!
=
num
)
)
{
const
V
v0
=
LoadU
(
d
keys
+
num
-
N
)
;
diff0
=
Or
(
diff0
Xor
(
v0
reference
)
)
;
if
(
!
AllTrue
(
d
Eq
(
diff0
zero
)
)
)
{
return
false
;
}
}
return
true
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
Vec
<
D
>
ScanForPrev
(
D
d
Traits
st
const
T
*
HWY_RESTRICT
keys
size_t
num
Vec
<
D
>
reference
T
*
HWY_RESTRICT
buf
)
{
const
size_t
N
=
Lanes
(
d
)
;
HWY_DASSERT
(
num
>
=
N
)
;
Vec
<
D
>
prev
=
st
.
FirstValue
(
d
)
;
Mask
<
D
>
any_found
=
st
.
Compare
(
d
prev
prev
)
;
size_t
i
=
0
;
for
(
;
i
+
N
<
=
num
;
i
+
=
N
)
{
const
Vec
<
D
>
curr
=
LoadU
(
d
keys
+
i
)
;
const
auto
is_before
=
st
.
Compare
(
d
curr
reference
)
;
any_found
=
Or
(
any_found
is_before
)
;
prev
=
IfThenElse
(
is_before
st
.
Last
(
d
prev
curr
)
prev
)
;
}
if
(
HWY_LIKELY
(
i
!
=
num
)
)
{
const
Vec
<
D
>
curr
=
LoadU
(
d
keys
+
num
-
N
)
;
const
auto
is_before
=
st
.
Compare
(
d
curr
reference
)
;
any_found
=
Or
(
any_found
is_before
)
;
prev
=
IfThenElse
(
is_before
st
.
Last
(
d
prev
curr
)
prev
)
;
}
const
Vec
<
D
>
candidate
=
st
.
LastOfLanes
(
d
prev
buf
)
;
return
IfThenElse
(
any_found
candidate
reference
)
;
}
enum
class
PivotResult
{
kNormal
kAllEqual
}
;
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
void
DrawSamples
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
num
T
*
HWY_RESTRICT
buf
Generator
&
rng
)
{
using
V
=
decltype
(
Zero
(
d
)
)
;
const
size_t
N
=
Lanes
(
d
)
;
const
size_t
lanes_per_chunk
=
Constants
:
:
LanesPerChunk
(
sizeof
(
T
)
N
)
;
HWY_DASSERT
(
num
>
=
2
*
lanes_per_chunk
)
;
const
size_t
misalign
=
(
reinterpret_cast
<
uintptr_t
>
(
keys
)
/
sizeof
(
T
)
)
&
(
lanes_per_chunk
-
1
)
;
if
(
misalign
!
=
0
)
{
const
size_t
consume
=
lanes_per_chunk
-
misalign
;
keys
+
=
consume
;
num
-
=
consume
;
}
uint64_t
*
bits64
=
reinterpret_cast
<
uint64_t
*
>
(
buf
)
;
for
(
size_t
i
=
0
;
i
<
5
;
+
+
i
)
{
bits64
[
i
]
=
rng
(
)
;
}
const
uint32_t
*
bits
=
reinterpret_cast
<
const
uint32_t
*
>
(
buf
)
;
const
uint32_t
lpc32
=
static_cast
<
uint32_t
>
(
lanes_per_chunk
)
;
const
size_t
log2_lpc
=
Num0BitsBelowLS1Bit_Nonzero32
(
lpc32
)
;
const
size_t
num_chunks64
=
num
>
>
log2_lpc
;
const
uint32_t
num_chunks
=
static_cast
<
uint32_t
>
(
HWY_MIN
(
num_chunks64
0xFFFFFFFFull
)
)
;
const
size_t
offset0
=
RandomChunkIndex
(
num_chunks
bits
[
0
]
)
<
<
log2_lpc
;
const
size_t
offset1
=
RandomChunkIndex
(
num_chunks
bits
[
1
]
)
<
<
log2_lpc
;
const
size_t
offset2
=
RandomChunkIndex
(
num_chunks
bits
[
2
]
)
<
<
log2_lpc
;
const
size_t
offset3
=
RandomChunkIndex
(
num_chunks
bits
[
3
]
)
<
<
log2_lpc
;
const
size_t
offset4
=
RandomChunkIndex
(
num_chunks
bits
[
4
]
)
<
<
log2_lpc
;
const
size_t
offset5
=
RandomChunkIndex
(
num_chunks
bits
[
5
]
)
<
<
log2_lpc
;
const
size_t
offset6
=
RandomChunkIndex
(
num_chunks
bits
[
6
]
)
<
<
log2_lpc
;
const
size_t
offset7
=
RandomChunkIndex
(
num_chunks
bits
[
7
]
)
<
<
log2_lpc
;
const
size_t
offset8
=
RandomChunkIndex
(
num_chunks
bits
[
8
]
)
<
<
log2_lpc
;
for
(
size_t
i
=
0
;
i
<
lanes_per_chunk
;
i
+
=
N
)
{
const
V
v0
=
Load
(
d
keys
+
offset0
+
i
)
;
const
V
v1
=
Load
(
d
keys
+
offset1
+
i
)
;
const
V
v2
=
Load
(
d
keys
+
offset2
+
i
)
;
const
V
medians0
=
MedianOf3
(
st
v0
v1
v2
)
;
Store
(
medians0
d
buf
+
i
)
;
const
V
v3
=
Load
(
d
keys
+
offset3
+
i
)
;
const
V
v4
=
Load
(
d
keys
+
offset4
+
i
)
;
const
V
v5
=
Load
(
d
keys
+
offset5
+
i
)
;
const
V
medians1
=
MedianOf3
(
st
v3
v4
v5
)
;
Store
(
medians1
d
buf
+
i
+
lanes_per_chunk
)
;
const
V
v6
=
Load
(
d
keys
+
offset6
+
i
)
;
const
V
v7
=
Load
(
d
keys
+
offset7
+
i
)
;
const
V
v8
=
Load
(
d
keys
+
offset8
+
i
)
;
const
V
medians2
=
MedianOf3
(
st
v6
v7
v8
)
;
Store
(
medians2
d
buf
+
i
+
lanes_per_chunk
*
2
)
;
}
}
template
<
class
D
class
Traits
typename
T
>
HWY_NOINLINE
Vec
<
D
>
ChoosePivot
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
const
size_t
begin
const
size_t
end
T
*
HWY_RESTRICT
buf
Generator
&
rng
PivotResult
&
result
)
{
using
V
=
decltype
(
Zero
(
d
)
)
;
const
size_t
N
=
Lanes
(
d
)
;
constexpr
size_t
kSampleLanes
=
3
*
64
/
sizeof
(
T
)
;
constexpr
size_t
N1
=
st
.
LanesPerKey
(
)
;
const
size_t
num
=
end
-
begin
;
#
if
VQSORT_PRINT
fprintf
(
stderr
"
\
nChoosePivot
num
%
zu
:
\
n
"
num
)
;
#
endif
DrawSamples
(
d
st
keys
+
begin
num
buf
rng
)
;
SortSamples
(
st
buf
)
;
#
if
VQSORT_PRINT
for
(
size_t
i
=
0
;
i
<
kSampleLanes
;
i
+
=
N
)
{
Print
(
d
"
"
Load
(
d
buf
+
i
)
0
N
)
;
}
#
endif
if
(
st
.
Equal1
(
buf
buf
+
kSampleLanes
-
N1
)
)
{
const
bool
all_eq
=
ScanEqual
(
d
st
keys
+
begin
num
)
;
#
if
VQSORT_PRINT
fprintf
(
stderr
"
Pivot
num
=
%
zu
all
eq
samples
keys
also
:
%
d
\
n
"
num
all_eq
)
;
#
endif
if
(
all_eq
)
{
result
=
PivotResult
:
:
kAllEqual
;
return
Zero
(
d
)
;
}
result
=
PivotResult
:
:
kNormal
;
const
V
reference
=
st
.
SetKey
(
d
buf
)
;
const
V
pivot
=
ScanForPrev
(
d
st
keys
+
begin
num
reference
buf
)
;
#
if
VQSORT_PRINT
Print
(
d
"
PREV
pivot
"
pivot
0
st
.
LanesPerKey
(
)
)
;
#
endif
return
pivot
;
}
const
size_t
pivot_rank
=
PivotRank
(
st
buf
)
;
const
Vec
<
D
>
pivot
=
st
.
SetKey
(
d
buf
+
pivot_rank
)
;
#
if
VQSORT_PRINT
fprintf
(
stderr
"
Pivot
rank
%
zu
=
%
.
0f
\
n
"
pivot_rank
static_cast
<
double
>
(
GetLane
(
pivot
)
)
)
;
#
endif
result
=
PivotResult
:
:
kNormal
;
return
pivot
;
}
template
<
class
D
class
Traits
typename
T
>
void
Recurse
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
T
*
HWY_RESTRICT
keys_end
const
size_t
begin
const
size_t
end
const
Vec
<
D
>
pivot
T
*
HWY_RESTRICT
buf
Generator
&
rng
size_t
remaining_levels
)
{
HWY_DASSERT
(
begin
+
1
<
end
)
;
const
size_t
num
=
end
-
begin
;
#
if
VQSORT_PRINT
fprintf
(
stderr
"
-
Recurse
remaining
%
zu
[
%
zu
%
zu
)
len
%
zu
\
n
"
remaining_levels
begin
end
num
)
;
Vec
<
D
>
first
last
;
ScanMinMax
(
d
st
keys
+
begin
num
buf
first
last
)
;
Print
(
d
"
first
"
first
0
st
.
LanesPerKey
(
)
)
;
Print
(
d
"
last
"
last
0
st
.
LanesPerKey
(
)
)
;
#
endif
if
(
HWY_UNLIKELY
(
remaining_levels
=
=
0
)
)
{
#
if
VQSORT_PRINT
fprintf
(
stderr
"
HeapSort
reached
size
=
%
zu
\
n
"
num
)
;
#
endif
HeapSort
(
st
keys
+
begin
num
)
;
return
;
}
const
ptrdiff_t
base_case_num
=
static_cast
<
ptrdiff_t
>
(
Constants
:
:
BaseCaseNum
(
Lanes
(
d
)
)
)
;
const
size_t
bound
=
Partition
(
d
st
keys
begin
end
pivot
buf
)
;
const
ptrdiff_t
num_left
=
static_cast
<
ptrdiff_t
>
(
bound
)
-
static_cast
<
ptrdiff_t
>
(
begin
)
;
const
ptrdiff_t
num_right
=
static_cast
<
ptrdiff_t
>
(
end
)
-
static_cast
<
ptrdiff_t
>
(
bound
)
;
HWY_ASSERT
(
num_right
!
=
0
)
;
if
(
HWY_UNLIKELY
(
num_left
<
=
base_case_num
)
)
{
BaseCase
(
d
st
keys
+
begin
keys_end
static_cast
<
size_t
>
(
num_left
)
buf
)
;
}
else
{
PivotResult
result
;
const
Vec
<
D
>
next_pivot
=
ChoosePivot
(
d
st
keys
begin
bound
buf
rng
result
)
;
if
(
result
!
=
PivotResult
:
:
kAllEqual
)
{
Recurse
(
d
st
keys
keys_end
begin
bound
next_pivot
buf
rng
remaining_levels
-
1
)
;
}
}
if
(
HWY_UNLIKELY
(
num_right
<
=
base_case_num
)
)
{
BaseCase
(
d
st
keys
+
bound
keys_end
static_cast
<
size_t
>
(
num_right
)
buf
)
;
}
else
{
PivotResult
result
;
const
Vec
<
D
>
next_pivot
=
ChoosePivot
(
d
st
keys
bound
end
buf
rng
result
)
;
if
(
result
!
=
PivotResult
:
:
kAllEqual
)
{
Recurse
(
d
st
keys
keys_end
bound
end
next_pivot
buf
rng
remaining_levels
-
1
)
;
}
}
}
template
<
class
D
class
Traits
typename
T
>
bool
HandleSpecialCases
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
num
T
*
HWY_RESTRICT
buf
)
{
const
size_t
N
=
Lanes
(
d
)
;
const
size_t
base_case_num
=
Constants
:
:
BaseCaseNum
(
N
)
;
const
bool
partial_128
=
!
IsFull
(
d
)
&
&
N
<
2
&
&
st
.
Is128
(
)
;
constexpr
bool
kPotentiallyHuge
=
HWY_MAX_BYTES
/
sizeof
(
T
)
>
Constants
:
:
kMaxRows
*
Constants
:
:
kMaxCols
;
const
bool
huge_vec
=
kPotentiallyHuge
&
&
(
2
*
N
>
base_case_num
)
;
if
(
partial_128
|
|
huge_vec
)
{
HeapSort
(
st
keys
num
)
;
return
true
;
}
if
(
HWY_UNLIKELY
(
num
<
=
base_case_num
)
)
{
BaseCase
(
d
st
keys
keys
+
num
num
buf
)
;
return
true
;
}
return
false
;
}
#
endif
}
template
<
class
D
class
Traits
typename
T
>
void
Sort
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
num
T
*
HWY_RESTRICT
buf
)
{
#
if
VQSORT_PRINT
fprintf
(
stderr
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
Sort
num
%
zu
\
n
"
num
)
;
#
endif
#
if
VQSORT_ENABLED
|
|
HWY_IDE
#
if
!
HWY_HAVE_SCALABLE
HWY_ALIGN
T
storage
[
SortConstants
:
:
BufNum
<
T
>
(
HWY_LANES
(
T
)
)
]
=
{
}
;
static_assert
(
sizeof
(
storage
)
<
=
8192
"
Unexpectedly
large
check
size
"
)
;
buf
=
storage
;
#
endif
if
(
detail
:
:
HandleSpecialCases
(
d
st
keys
num
buf
)
)
return
;
#
if
HWY_MAX_BYTES
>
64
if
(
Lanes
(
d
)
>
64
/
sizeof
(
T
)
)
{
return
Sort
(
CappedTag
<
T
64
/
sizeof
(
T
)
>
(
)
st
keys
num
buf
)
;
}
#
endif
detail
:
:
Generator
rng
(
keys
num
)
;
detail
:
:
PivotResult
result
;
const
Vec
<
D
>
pivot
=
detail
:
:
ChoosePivot
(
d
st
keys
0
num
buf
rng
result
)
;
if
(
result
!
=
detail
:
:
PivotResult
:
:
kAllEqual
)
{
const
size_t
max_levels
=
2
*
hwy
:
:
CeilLog2
(
num
)
+
4
;
detail
:
:
Recurse
(
d
st
keys
keys
+
num
0
num
pivot
buf
rng
max_levels
)
;
}
#
else
(
void
)
d
;
(
void
)
buf
;
return
detail
:
:
HeapSort
(
st
keys
num
)
;
#
endif
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
