#
ifndef
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_INL_H_
#
define
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_INL_H_
#
ifndef
VQSORT_PRINT
#
define
VQSORT_PRINT
0
#
endif
#
ifndef
VQSORT_SECURE_RNG
#
define
VQSORT_SECURE_RNG
0
#
endif
#
if
VQSORT_SECURE_RNG
#
include
"
third_party
/
absl
/
random
/
random
.
h
"
#
endif
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
"
hwy
/
cache_control
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
vqsort
.
h
"
#
if
HWY_IS_MSAN
#
include
<
sanitizer
/
msan_interface
.
h
>
#
endif
#
endif
#
if
defined
(
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_TOGGLE
)
=
=
\
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_TOGGLE
#
undef
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_TOGGLE
#
else
#
define
HIGHWAY_HWY_CONTRIB_SORT_VQSORT_TOGGLE
#
endif
#
if
VQSORT_PRINT
#
include
"
hwy
/
print
-
inl
.
h
"
#
endif
#
include
"
hwy
/
contrib
/
sort
/
shared
-
inl
.
h
"
#
include
"
hwy
/
contrib
/
sort
/
sorting_networks
-
inl
.
h
"
#
include
"
hwy
/
highway
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
namespace
detail
{
using
Constants
=
hwy
:
:
SortConstants
;
HWY_INLINE
void
UnpoisonIfMemorySanitizer
(
void
*
p
size_t
bytes
)
{
#
if
HWY_IS_MSAN
__msan_unpoison
(
p
bytes
)
;
#
else
(
void
)
p
;
(
void
)
bytes
;
#
endif
}
template
<
class
D
>
HWY_INLINE
void
MaybePrintVector
(
D
d
const
char
*
label
Vec
<
D
>
v
size_t
start
=
0
size_t
max_lanes
=
16
)
{
#
if
VQSORT_PRINT
>
=
2
Print
(
d
label
v
start
max_lanes
)
;
#
else
(
void
)
d
;
(
void
)
label
;
(
void
)
v
;
(
void
)
start
;
(
void
)
max_lanes
;
#
endif
}
template
<
class
Traits
typename
T
>
void
SiftDown
(
Traits
st
T
*
HWY_RESTRICT
lanes
const
size_t
num_lanes
size_t
start
)
{
constexpr
size_t
N1
=
st
.
LanesPerKey
(
)
;
const
FixedTag
<
T
N1
>
d
;
while
(
start
<
num_lanes
)
{
const
size_t
left
=
2
*
start
+
N1
;
const
size_t
right
=
2
*
start
+
2
*
N1
;
if
(
left
>
=
num_lanes
)
break
;
size_t
idx_larger
=
start
;
const
auto
key_j
=
st
.
SetKey
(
d
lanes
+
start
)
;
if
(
AllTrue
(
d
st
.
Compare
(
d
key_j
st
.
SetKey
(
d
lanes
+
left
)
)
)
)
{
idx_larger
=
left
;
}
if
(
right
<
num_lanes
&
&
AllTrue
(
d
st
.
Compare
(
d
st
.
SetKey
(
d
lanes
+
idx_larger
)
st
.
SetKey
(
d
lanes
+
right
)
)
)
)
{
idx_larger
=
right
;
}
if
(
idx_larger
=
=
start
)
break
;
st
.
Swap
(
lanes
+
start
lanes
+
idx_larger
)
;
start
=
idx_larger
;
}
}
template
<
class
Traits
typename
T
>
void
HeapSort
(
Traits
st
T
*
HWY_RESTRICT
lanes
const
size_t
num_lanes
)
{
constexpr
size_t
N1
=
st
.
LanesPerKey
(
)
;
if
(
num_lanes
<
2
*
N1
)
return
;
for
(
size_t
i
=
(
(
num_lanes
-
N1
)
/
N1
/
2
)
*
N1
;
i
!
=
(
~
N1
+
1
)
;
i
-
=
N1
)
{
SiftDown
(
st
lanes
num_lanes
i
)
;
}
for
(
size_t
i
=
num_lanes
-
N1
;
i
!
=
0
;
i
-
=
N1
)
{
st
.
Swap
(
lanes
+
0
lanes
+
i
)
;
SiftDown
(
st
lanes
i
0
)
;
}
}
#
if
VQSORT_ENABLED
|
|
HWY_IDE
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
void
BaseCase
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
T
*
HWY_RESTRICT
keys_end
size_t
num
T
*
HWY_RESTRICT
buf
)
{
const
size_t
N
=
Lanes
(
d
)
;
using
V
=
decltype
(
Zero
(
d
)
)
;
if
(
HWY_UNLIKELY
(
num
<
=
1
)
)
return
;
const
size_t
num_pow2
=
size_t
{
1
}
<
<
(
32
-
Num0BitsAboveMS1Bit_Nonzero32
(
static_cast
<
uint32_t
>
(
num
-
1
)
)
)
;
HWY_DASSERT
(
num
<
=
num_pow2
&
&
num_pow2
<
=
Constants
:
:
BaseCaseNum
(
N
)
)
;
const
size_t
cols
=
HWY_MAX
(
st
.
LanesPerKey
(
)
num_pow2
>
>
Constants
:
:
kMaxRowsLog2
)
;
HWY_DASSERT
(
cols
<
=
N
)
;
const
size_t
N_sn
=
Lanes
(
CappedTag
<
T
Constants
:
:
kMaxCols
>
(
)
)
;
if
(
HWY_LIKELY
(
keys
+
N_sn
*
Constants
:
:
kMaxRows
<
=
keys_end
)
)
{
SortingNetwork
(
st
keys
N_sn
)
;
return
;
}
size_t
i
;
for
(
i
=
0
;
i
+
N
<
=
num
;
i
+
=
N
)
{
Store
(
LoadU
(
d
keys
+
i
)
d
buf
+
i
)
;
}
SafeCopyN
(
num
-
i
d
keys
+
i
buf
+
i
)
;
i
=
num
;
const
V
kPadding
=
st
.
LastValue
(
d
)
;
for
(
;
i
<
(
cols
*
Constants
:
:
kMaxRows
+
N
)
;
i
+
=
N
)
{
StoreU
(
kPadding
d
buf
+
i
)
;
}
SortingNetwork
(
st
buf
cols
)
;
for
(
i
=
0
;
i
+
N
<
=
num
;
i
+
=
N
)
{
StoreU
(
Load
(
d
buf
+
i
)
d
keys
+
i
)
;
}
SafeCopyN
(
num
-
i
d
buf
+
i
keys
+
i
)
;
}
template
<
class
D
class
Traits
class
T
>
HWY_INLINE
size_t
PartitionToMultipleOfUnroll
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
&
num
const
Vec
<
D
>
pivot
T
*
HWY_RESTRICT
buf
)
{
constexpr
size_t
kUnroll
=
Constants
:
:
kPartitionUnroll
;
const
size_t
N
=
Lanes
(
d
)
;
size_t
readL
=
0
;
T
*
HWY_RESTRICT
posL
=
keys
;
size_t
bufR
=
0
;
const
size_t
num_rem
=
(
num
<
2
*
kUnroll
*
N
)
?
num
:
(
num
&
(
kUnroll
*
N
-
1
)
)
;
size_t
i
=
0
;
for
(
;
i
+
N
<
=
num_rem
;
i
+
=
N
)
{
const
Vec
<
D
>
vL
=
LoadU
(
d
keys
+
readL
)
;
readL
+
=
N
;
const
auto
comp
=
st
.
Compare
(
d
pivot
vL
)
;
posL
+
=
CompressBlendedStore
(
vL
Not
(
comp
)
d
posL
)
;
bufR
+
=
CompressStore
(
vL
comp
d
buf
+
bufR
)
;
}
if
(
HWY_LIKELY
(
i
!
=
num_rem
)
)
{
const
auto
mask
=
FirstN
(
d
num_rem
-
i
)
;
const
Vec
<
D
>
vL
=
LoadU
(
d
keys
+
readL
)
;
const
auto
comp
=
st
.
Compare
(
d
pivot
vL
)
;
posL
+
=
CompressBlendedStore
(
vL
AndNot
(
comp
mask
)
d
posL
)
;
bufR
+
=
CompressStore
(
vL
And
(
comp
mask
)
d
buf
+
bufR
)
;
}
UnpoisonIfMemorySanitizer
(
buf
bufR
*
sizeof
(
T
)
)
;
num
-
=
bufR
;
memcpy
(
posL
keys
+
num
bufR
*
sizeof
(
T
)
)
;
memcpy
(
keys
+
num
buf
bufR
*
sizeof
(
T
)
)
;
return
static_cast
<
size_t
>
(
posL
-
keys
)
;
}
template
<
class
V
>
V
OrXor
(
const
V
o
const
V
x1
const
V
x2
)
{
return
Or
(
o
Xor
(
x1
x2
)
)
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
void
StoreLeftRight
(
D
d
Traits
st
const
Vec
<
D
>
v
const
Vec
<
D
>
pivot
T
*
HWY_RESTRICT
keys
size_t
&
writeL
size_t
&
remaining
)
{
const
size_t
N
=
Lanes
(
d
)
;
const
auto
comp
=
st
.
Compare
(
d
pivot
v
)
;
remaining
-
=
N
;
if
(
hwy
:
:
HWY_NAMESPACE
:
:
CompressIsPartition
<
T
>
:
:
value
|
|
(
HWY_MAX_BYTES
=
=
16
&
&
st
.
Is128
(
)
)
)
{
const
auto
lr
=
st
.
CompressKeys
(
v
comp
)
;
const
size_t
num_left
=
N
-
CountTrue
(
d
comp
)
;
StoreU
(
lr
d
keys
+
writeL
)
;
StoreU
(
lr
d
keys
+
remaining
+
writeL
)
;
writeL
+
=
num_left
;
}
else
{
const
size_t
num_left
=
CompressStore
(
v
Not
(
comp
)
d
keys
+
writeL
)
;
writeL
+
=
num_left
;
(
void
)
CompressBlendedStore
(
v
comp
d
keys
+
remaining
+
writeL
)
;
}
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
void
StoreLeftRight4
(
D
d
Traits
st
const
Vec
<
D
>
v0
const
Vec
<
D
>
v1
const
Vec
<
D
>
v2
const
Vec
<
D
>
v3
const
Vec
<
D
>
pivot
T
*
HWY_RESTRICT
keys
size_t
&
writeL
size_t
&
remaining
)
{
StoreLeftRight
(
d
st
v0
pivot
keys
writeL
remaining
)
;
StoreLeftRight
(
d
st
v1
pivot
keys
writeL
remaining
)
;
StoreLeftRight
(
d
st
v2
pivot
keys
writeL
remaining
)
;
StoreLeftRight
(
d
st
v3
pivot
keys
writeL
remaining
)
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
size_t
Partition
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
num
const
Vec
<
D
>
pivot
T
*
HWY_RESTRICT
buf
)
{
using
V
=
decltype
(
Zero
(
d
)
)
;
const
size_t
N
=
Lanes
(
d
)
;
HWY_DASSERT
(
num
>
2
*
N
)
;
num
-
=
N
;
size_t
last
=
num
;
const
V
vlast
=
LoadU
(
d
keys
+
last
)
;
const
size_t
consumedL
=
PartitionToMultipleOfUnroll
(
d
st
keys
num
pivot
buf
)
;
keys
+
=
consumedL
;
last
-
=
consumedL
;
num
-
=
consumedL
;
constexpr
size_t
kUnroll
=
Constants
:
:
kPartitionUnroll
;
size_t
writeL
=
0
;
size_t
remaining
=
num
;
const
T
*
HWY_RESTRICT
readL
=
keys
;
const
T
*
HWY_RESTRICT
readR
=
keys
+
num
;
if
(
HWY_LIKELY
(
num
!
=
0
)
)
{
HWY_DASSERT
(
num
>
=
2
*
kUnroll
*
N
)
;
HWY_DASSERT
(
(
num
&
(
kUnroll
*
N
-
1
)
)
=
=
0
)
;
const
V
vL0
=
LoadU
(
d
readL
+
0
*
N
)
;
const
V
vL1
=
LoadU
(
d
readL
+
1
*
N
)
;
const
V
vL2
=
LoadU
(
d
readL
+
2
*
N
)
;
const
V
vL3
=
LoadU
(
d
readL
+
3
*
N
)
;
readL
+
=
kUnroll
*
N
;
readR
-
=
kUnroll
*
N
;
const
V
vR0
=
LoadU
(
d
readR
+
0
*
N
)
;
const
V
vR1
=
LoadU
(
d
readR
+
1
*
N
)
;
const
V
vR2
=
LoadU
(
d
readR
+
2
*
N
)
;
const
V
vR3
=
LoadU
(
d
readR
+
3
*
N
)
;
while
(
readL
!
=
readR
)
{
V
v0
v1
v2
v3
;
const
size_t
capacityL
=
static_cast
<
size_t
>
(
(
readL
-
keys
)
-
static_cast
<
ptrdiff_t
>
(
writeL
)
)
;
HWY_DASSERT
(
capacityL
<
=
num
)
;
if
(
kUnroll
*
N
<
capacityL
)
{
readR
-
=
kUnroll
*
N
;
v0
=
LoadU
(
d
readR
+
0
*
N
)
;
v1
=
LoadU
(
d
readR
+
1
*
N
)
;
v2
=
LoadU
(
d
readR
+
2
*
N
)
;
v3
=
LoadU
(
d
readR
+
3
*
N
)
;
hwy
:
:
Prefetch
(
readR
-
3
*
kUnroll
*
N
)
;
}
else
{
v0
=
LoadU
(
d
readL
+
0
*
N
)
;
v1
=
LoadU
(
d
readL
+
1
*
N
)
;
v2
=
LoadU
(
d
readL
+
2
*
N
)
;
v3
=
LoadU
(
d
readL
+
3
*
N
)
;
readL
+
=
kUnroll
*
N
;
hwy
:
:
Prefetch
(
readL
+
3
*
kUnroll
*
N
)
;
}
StoreLeftRight4
(
d
st
v0
v1
v2
v3
pivot
keys
writeL
remaining
)
;
}
StoreLeftRight4
(
d
st
vL0
vL1
vL2
vL3
pivot
keys
writeL
remaining
)
;
StoreLeftRight4
(
d
st
vR0
vR1
vR2
vR3
pivot
keys
writeL
remaining
)
;
}
HWY_DASSERT
(
remaining
=
=
0
)
;
const
size_t
totalR
=
last
-
writeL
;
const
size_t
startR
=
totalR
<
N
?
writeL
+
totalR
-
N
:
writeL
;
StoreU
(
LoadU
(
d
keys
+
startR
)
d
keys
+
last
)
;
const
auto
comp
=
st
.
Compare
(
d
pivot
vlast
)
;
writeL
+
=
CompressBlendedStore
(
vlast
Not
(
comp
)
d
keys
+
writeL
)
;
(
void
)
CompressBlendedStore
(
vlast
comp
d
keys
+
writeL
)
;
return
consumedL
+
writeL
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_NOINLINE
bool
MaybePartitionTwoValue
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
num
const
Vec
<
D
>
valueL
const
Vec
<
D
>
valueR
Vec
<
D
>
&
third
T
*
HWY_RESTRICT
buf
)
{
const
size_t
N
=
Lanes
(
d
)
;
size_t
i
=
0
;
size_t
writeL
=
0
;
for
(
;
i
+
N
<
=
num
;
i
+
=
N
)
{
const
Vec
<
D
>
v
=
LoadU
(
d
keys
+
i
)
;
const
Mask
<
D
>
eqL
=
st
.
EqualKeys
(
d
v
valueL
)
;
const
Mask
<
D
>
eqR
=
st
.
EqualKeys
(
d
v
valueR
)
;
if
(
HWY_UNLIKELY
(
!
AllTrue
(
d
Or
(
eqL
eqR
)
)
)
)
{
const
size_t
lane
=
FindKnownFirstTrue
(
d
ExclusiveNeither
(
eqL
eqR
)
)
;
third
=
st
.
SetKey
(
d
keys
+
i
+
lane
)
;
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
found
3rd
value
at
vec
%
zu
;
writeL
%
zu
\
n
"
i
writeL
)
;
}
for
(
;
writeL
+
N
<
=
i
;
writeL
+
=
N
)
{
StoreU
(
valueR
d
keys
+
writeL
)
;
}
BlendedStore
(
valueR
FirstN
(
d
i
-
writeL
)
d
keys
+
writeL
)
;
return
false
;
}
StoreU
(
valueL
d
keys
+
writeL
)
;
writeL
+
=
CountTrue
(
d
eqL
)
;
}
const
size_t
remaining
=
num
-
i
;
SafeCopyN
(
remaining
d
keys
+
i
buf
)
;
const
Vec
<
D
>
v
=
Load
(
d
buf
)
;
const
Mask
<
D
>
valid
=
FirstN
(
d
remaining
)
;
const
Mask
<
D
>
eqL
=
And
(
st
.
EqualKeys
(
d
v
valueL
)
valid
)
;
const
Mask
<
D
>
eqR
=
st
.
EqualKeys
(
d
v
valueR
)
;
const
Mask
<
D
>
eq
=
Or
(
Or
(
eqL
eqR
)
Not
(
valid
)
)
;
if
(
HWY_UNLIKELY
(
!
AllTrue
(
d
eq
)
)
)
{
const
size_t
lane
=
FindKnownFirstTrue
(
d
Not
(
eq
)
)
;
third
=
st
.
SetKey
(
d
keys
+
i
+
lane
)
;
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
found
3rd
value
at
partial
vec
%
zu
;
writeL
%
zu
\
n
"
i
writeL
)
;
}
for
(
;
writeL
+
N
<
=
i
;
writeL
+
=
N
)
{
StoreU
(
valueR
d
keys
+
writeL
)
;
}
BlendedStore
(
valueR
FirstN
(
d
i
-
writeL
)
d
keys
+
writeL
)
;
return
false
;
}
BlendedStore
(
valueL
valid
d
keys
+
writeL
)
;
writeL
+
=
CountTrue
(
d
eqL
)
;
i
=
writeL
;
for
(
;
i
+
N
<
=
num
;
i
+
=
N
)
{
StoreU
(
valueR
d
keys
+
i
)
;
}
BlendedStore
(
valueR
FirstN
(
d
num
-
i
)
d
keys
+
i
)
;
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
Successful
MaybePartitionTwoValue
\
n
"
)
;
}
return
true
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
bool
MaybePartitionTwoValueR
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
num
const
Vec
<
D
>
valueL
const
Vec
<
D
>
valueR
Vec
<
D
>
&
third
T
*
HWY_RESTRICT
buf
)
{
const
size_t
N
=
Lanes
(
d
)
;
HWY_DASSERT
(
num
>
=
N
)
;
size_t
pos
=
num
-
N
;
size_t
countR
=
0
;
for
(
;
pos
<
num
;
pos
-
=
N
)
{
const
Vec
<
D
>
v
=
LoadU
(
d
keys
+
pos
)
;
const
Mask
<
D
>
eqL
=
st
.
EqualKeys
(
d
v
valueL
)
;
const
Mask
<
D
>
eqR
=
st
.
EqualKeys
(
d
v
valueR
)
;
if
(
HWY_UNLIKELY
(
!
AllTrue
(
d
Or
(
eqL
eqR
)
)
)
)
{
const
size_t
lane
=
FindKnownFirstTrue
(
d
ExclusiveNeither
(
eqL
eqR
)
)
;
third
=
st
.
SetKey
(
d
keys
+
pos
+
lane
)
;
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
found
3rd
value
at
vec
%
zu
;
countR
%
zu
\
n
"
pos
countR
)
;
MaybePrintVector
(
d
"
third
"
third
0
st
.
LanesPerKey
(
)
)
;
}
pos
+
=
N
;
HWY_DASSERT
(
countR
<
=
num
-
pos
)
;
const
size_t
endL
=
num
-
countR
;
for
(
;
pos
+
N
<
=
endL
;
pos
+
=
N
)
{
StoreU
(
valueL
d
keys
+
pos
)
;
}
BlendedStore
(
valueL
FirstN
(
d
endL
-
pos
)
d
keys
+
pos
)
;
return
false
;
}
StoreU
(
valueR
d
keys
+
pos
)
;
countR
+
=
CountTrue
(
d
eqR
)
;
}
const
size_t
remaining
=
pos
+
N
;
HWY_DASSERT
(
remaining
<
=
N
)
;
const
Vec
<
D
>
v
=
LoadU
(
d
keys
)
;
const
Mask
<
D
>
valid
=
FirstN
(
d
remaining
)
;
const
Mask
<
D
>
eqL
=
st
.
EqualKeys
(
d
v
valueL
)
;
const
Mask
<
D
>
eqR
=
And
(
st
.
EqualKeys
(
d
v
valueR
)
valid
)
;
const
Mask
<
D
>
eq
=
Or
(
Or
(
eqL
eqR
)
Not
(
valid
)
)
;
if
(
HWY_UNLIKELY
(
!
AllTrue
(
d
eq
)
)
)
{
const
size_t
lane
=
FindKnownFirstTrue
(
d
Not
(
eq
)
)
;
third
=
st
.
SetKey
(
d
keys
+
lane
)
;
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
found
3rd
value
at
partial
vec
%
zu
;
writeR
%
zu
\
n
"
pos
countR
)
;
MaybePrintVector
(
d
"
third
"
third
0
st
.
LanesPerKey
(
)
)
;
}
pos
+
=
N
;
HWY_DASSERT
(
countR
<
=
num
-
pos
)
;
const
size_t
endL
=
num
-
countR
;
for
(
;
pos
+
N
<
=
endL
;
pos
+
=
N
)
{
StoreU
(
valueL
d
keys
+
pos
)
;
}
BlendedStore
(
valueL
FirstN
(
d
endL
-
pos
)
d
keys
+
pos
)
;
return
false
;
}
const
size_t
lastR
=
CountTrue
(
d
eqR
)
;
countR
+
=
lastR
;
StoreU
(
valueR
d
keys
)
;
const
size_t
endL
=
num
-
countR
;
size_t
i
=
0
;
for
(
;
i
+
N
<
=
endL
;
i
+
=
N
)
{
StoreU
(
valueL
d
keys
+
i
)
;
}
Store
(
valueL
d
buf
)
;
SafeCopyN
(
endL
-
i
d
buf
keys
+
i
)
;
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
MaybePartitionTwoValueR
countR
%
zu
pos
%
zu
i
%
zu
endL
%
zu
\
n
"
countR
pos
i
endL
)
;
}
return
true
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
bool
PartitionIfTwoKeys
(
D
d
Traits
st
const
Vec
<
D
>
pivot
T
*
HWY_RESTRICT
keys
size_t
num
const
size_t
idx_second
const
Vec
<
D
>
second
Vec
<
D
>
&
third
T
*
HWY_RESTRICT
buf
)
{
const
bool
is_pivotR
=
AllFalse
(
d
st
.
Compare
(
d
pivot
second
)
)
;
if
(
VQSORT_PRINT
>
=
1
)
{
fprintf
(
stderr
"
Samples
all
equal
diff
at
%
zu
isPivotR
%
d
\
n
"
idx_second
is_pivotR
)
;
}
HWY_DASSERT
(
AllFalse
(
d
st
.
EqualKeys
(
d
second
pivot
)
)
)
;
return
is_pivotR
?
MaybePartitionTwoValueR
(
d
st
keys
num
second
pivot
third
buf
)
:
MaybePartitionTwoValue
(
d
st
keys
+
idx_second
num
-
idx_second
pivot
second
third
buf
)
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
bool
PartitionIfTwoSamples
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
num
T
*
HWY_RESTRICT
samples
)
{
constexpr
size_t
kSampleLanes
=
3
*
64
/
sizeof
(
T
)
;
constexpr
size_t
N1
=
st
.
LanesPerKey
(
)
;
const
Vec
<
D
>
valueL
=
st
.
SetKey
(
d
samples
)
;
const
Vec
<
D
>
valueR
=
st
.
SetKey
(
d
samples
+
kSampleLanes
-
N1
)
;
HWY_DASSERT
(
AllTrue
(
d
st
.
Compare
(
d
valueL
valueR
)
)
)
;
HWY_DASSERT
(
AllFalse
(
d
st
.
EqualKeys
(
d
valueL
valueR
)
)
)
;
const
Vec
<
D
>
prev
=
st
.
PrevValue
(
d
valueR
)
;
if
(
HWY_UNLIKELY
(
!
AllTrue
(
d
st
.
EqualKeys
(
d
valueL
prev
)
)
)
)
{
return
false
;
}
T
*
HWY_RESTRICT
buf
=
samples
+
kSampleLanes
;
Vec
<
D
>
third
;
return
MaybePartitionTwoValue
(
d
st
keys
num
valueL
valueR
third
buf
)
;
}
template
<
class
Traits
class
V
>
HWY_INLINE
V
MedianOf3
(
Traits
st
V
v0
V
v1
V
v2
)
{
const
DFromV
<
V
>
d
;
if
(
st
.
Is128
(
)
)
{
const
auto
sum
=
Xor
(
Xor
(
v0
v1
)
v2
)
;
const
auto
first
=
st
.
First
(
d
st
.
First
(
d
v0
v1
)
v2
)
;
const
auto
last
=
st
.
Last
(
d
st
.
Last
(
d
v0
v1
)
v2
)
;
return
Xor
(
Xor
(
sum
first
)
last
)
;
}
st
.
Sort2
(
d
v0
v2
)
;
v1
=
st
.
Last
(
d
v0
v1
)
;
v1
=
st
.
First
(
d
v1
v2
)
;
return
v1
;
}
#
if
VQSORT_SECURE_RNG
using
Generator
=
absl
:
:
BitGen
;
#
else
#
pragma
pack
(
push
1
)
class
Generator
{
public
:
Generator
(
const
void
*
heap
size_t
num
)
{
Sorter
:
:
Fill24Bytes
(
heap
num
&
a_
)
;
k_
=
1
;
}
explicit
Generator
(
uint64_t
seed
)
{
a_
=
b_
=
w_
=
seed
;
k_
=
1
;
}
uint64_t
operator
(
)
(
)
{
const
uint64_t
b
=
b_
;
w_
+
=
k_
;
const
uint64_t
next
=
a_
^
w_
;
a_
=
(
b
+
(
b
<
<
3
)
)
^
(
b
>
>
11
)
;
const
uint64_t
rot
=
(
b
<
<
24
)
|
(
b
>
>
40
)
;
b_
=
rot
+
next
;
return
next
;
}
private
:
uint64_t
a_
;
uint64_t
b_
;
uint64_t
w_
;
uint64_t
k_
;
}
;
#
pragma
pack
(
pop
)
#
endif
HWY_INLINE
size_t
RandomChunkIndex
(
const
uint32_t
num_chunks
uint32_t
bits
)
{
const
uint64_t
chunk_index
=
(
static_cast
<
uint64_t
>
(
bits
)
*
num_chunks
)
>
>
32
;
HWY_DASSERT
(
chunk_index
<
num_chunks
)
;
return
static_cast
<
size_t
>
(
chunk_index
)
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
void
DrawSamples
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
num
T
*
HWY_RESTRICT
buf
Generator
&
rng
)
{
using
V
=
decltype
(
Zero
(
d
)
)
;
const
size_t
N
=
Lanes
(
d
)
;
constexpr
size_t
kLanesPerChunk
=
Constants
:
:
LanesPerChunk
(
sizeof
(
T
)
)
;
HWY_DASSERT
(
num
>
=
2
*
kLanesPerChunk
)
;
const
size_t
misalign
=
(
reinterpret_cast
<
uintptr_t
>
(
keys
)
/
sizeof
(
T
)
)
&
(
kLanesPerChunk
-
1
)
;
if
(
misalign
!
=
0
)
{
const
size_t
consume
=
kLanesPerChunk
-
misalign
;
keys
+
=
consume
;
num
-
=
consume
;
}
uint64_t
*
bits64
=
reinterpret_cast
<
uint64_t
*
>
(
buf
)
;
for
(
size_t
i
=
0
;
i
<
5
;
+
+
i
)
{
bits64
[
i
]
=
rng
(
)
;
}
const
uint32_t
*
bits
=
reinterpret_cast
<
const
uint32_t
*
>
(
buf
)
;
const
size_t
num_chunks64
=
num
/
kLanesPerChunk
;
const
uint32_t
num_chunks
=
static_cast
<
uint32_t
>
(
HWY_MIN
(
num_chunks64
0xFFFFFFFFull
)
)
;
const
size_t
offset0
=
RandomChunkIndex
(
num_chunks
bits
[
0
]
)
*
kLanesPerChunk
;
const
size_t
offset1
=
RandomChunkIndex
(
num_chunks
bits
[
1
]
)
*
kLanesPerChunk
;
const
size_t
offset2
=
RandomChunkIndex
(
num_chunks
bits
[
2
]
)
*
kLanesPerChunk
;
const
size_t
offset3
=
RandomChunkIndex
(
num_chunks
bits
[
3
]
)
*
kLanesPerChunk
;
const
size_t
offset4
=
RandomChunkIndex
(
num_chunks
bits
[
4
]
)
*
kLanesPerChunk
;
const
size_t
offset5
=
RandomChunkIndex
(
num_chunks
bits
[
5
]
)
*
kLanesPerChunk
;
const
size_t
offset6
=
RandomChunkIndex
(
num_chunks
bits
[
6
]
)
*
kLanesPerChunk
;
const
size_t
offset7
=
RandomChunkIndex
(
num_chunks
bits
[
7
]
)
*
kLanesPerChunk
;
const
size_t
offset8
=
RandomChunkIndex
(
num_chunks
bits
[
8
]
)
*
kLanesPerChunk
;
for
(
size_t
i
=
0
;
i
<
kLanesPerChunk
;
i
+
=
N
)
{
const
V
v0
=
Load
(
d
keys
+
offset0
+
i
)
;
const
V
v1
=
Load
(
d
keys
+
offset1
+
i
)
;
const
V
v2
=
Load
(
d
keys
+
offset2
+
i
)
;
const
V
medians0
=
MedianOf3
(
st
v0
v1
v2
)
;
Store
(
medians0
d
buf
+
i
)
;
const
V
v3
=
Load
(
d
keys
+
offset3
+
i
)
;
const
V
v4
=
Load
(
d
keys
+
offset4
+
i
)
;
const
V
v5
=
Load
(
d
keys
+
offset5
+
i
)
;
const
V
medians1
=
MedianOf3
(
st
v3
v4
v5
)
;
Store
(
medians1
d
buf
+
i
+
kLanesPerChunk
)
;
const
V
v6
=
Load
(
d
keys
+
offset6
+
i
)
;
const
V
v7
=
Load
(
d
keys
+
offset7
+
i
)
;
const
V
v8
=
Load
(
d
keys
+
offset8
+
i
)
;
const
V
medians2
=
MedianOf3
(
st
v6
v7
v8
)
;
Store
(
medians2
d
buf
+
i
+
kLanesPerChunk
*
2
)
;
}
}
template
<
class
D
class
Traits
>
HWY_INLINE
bool
UnsortedSampleEqual
(
D
d
Traits
st
const
TFromD
<
D
>
*
HWY_RESTRICT
samples
)
{
constexpr
size_t
kSampleLanes
=
3
*
64
/
sizeof
(
TFromD
<
D
>
)
;
const
size_t
N
=
Lanes
(
d
)
;
using
V
=
Vec
<
D
>
;
const
V
first
=
st
.
SetKey
(
d
samples
)
;
V
diff
=
Zero
(
d
)
;
size_t
i
=
0
;
for
(
;
i
+
N
<
=
kSampleLanes
;
i
+
=
N
)
{
const
V
v
=
Load
(
d
samples
+
i
)
;
diff
=
OrXor
(
diff
first
v
)
;
}
const
V
v
=
Load
(
d
samples
+
i
)
;
const
auto
valid
=
FirstN
(
d
kSampleLanes
-
i
)
;
diff
=
IfThenElse
(
valid
OrXor
(
diff
first
v
)
diff
)
;
return
st
.
NoKeyDifference
(
d
diff
)
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
void
SortSamples
(
D
d
Traits
st
T
*
HWY_RESTRICT
buf
)
{
constexpr
size_t
kSampleLanes
=
3
*
64
/
sizeof
(
T
)
;
const
CappedTag
<
T
16
/
sizeof
(
T
)
>
d128
;
const
size_t
N128
=
Lanes
(
d128
)
;
constexpr
size_t
kCols
=
HWY_MIN
(
16
/
sizeof
(
T
)
Constants
:
:
kMaxCols
)
;
constexpr
size_t
kBytes
=
kCols
*
Constants
:
:
kMaxRows
*
sizeof
(
T
)
;
static_assert
(
192
<
=
kBytes
"
"
)
;
const
auto
kPadding
=
st
.
LastValue
(
d128
)
;
for
(
size_t
i
=
kSampleLanes
;
i
<
=
kBytes
/
sizeof
(
T
)
;
i
+
=
N128
)
{
StoreU
(
kPadding
d128
buf
+
i
)
;
}
SortingNetwork
(
st
buf
kCols
)
;
if
(
VQSORT_PRINT
>
=
2
)
{
const
size_t
N
=
Lanes
(
d
)
;
fprintf
(
stderr
"
Samples
:
\
n
"
)
;
for
(
size_t
i
=
0
;
i
<
kSampleLanes
;
i
+
=
N
)
{
MaybePrintVector
(
d
"
"
Load
(
d
buf
+
i
)
0
N
)
;
}
}
}
enum
class
PivotResult
{
kDone
kNormal
kIsFirst
kWasLast
}
;
HWY_INLINE
const
char
*
PivotResultString
(
PivotResult
result
)
{
switch
(
result
)
{
case
PivotResult
:
:
kDone
:
return
"
done
"
;
case
PivotResult
:
:
kNormal
:
return
"
normal
"
;
case
PivotResult
:
:
kIsFirst
:
return
"
first
"
;
case
PivotResult
:
:
kWasLast
:
return
"
last
"
;
}
return
"
unknown
"
;
}
template
<
class
Traits
typename
T
>
HWY_INLINE
size_t
PivotRank
(
Traits
st
const
T
*
HWY_RESTRICT
samples
)
{
constexpr
size_t
kSampleLanes
=
3
*
64
/
sizeof
(
T
)
;
constexpr
size_t
N1
=
st
.
LanesPerKey
(
)
;
constexpr
size_t
kRankMid
=
kSampleLanes
/
2
;
static_assert
(
kRankMid
%
N1
=
=
0
"
Mid
is
not
an
aligned
key
"
)
;
size_t
rank_prev
=
kRankMid
-
N1
;
for
(
;
st
.
Equal1
(
samples
+
rank_prev
samples
+
kRankMid
)
;
rank_prev
-
=
N1
)
{
if
(
rank_prev
=
=
0
)
return
0
;
}
size_t
rank_next
=
rank_prev
+
N1
;
for
(
;
st
.
Equal1
(
samples
+
rank_next
samples
+
kRankMid
)
;
rank_next
+
=
N1
)
{
if
(
rank_next
=
=
kSampleLanes
-
N1
)
return
rank_prev
;
}
const
size_t
excess_if_median
=
rank_next
-
kRankMid
;
const
size_t
excess_if_prev
=
kRankMid
-
rank_prev
;
return
excess_if_median
<
excess_if_prev
?
kRankMid
:
rank_prev
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
Vec
<
D
>
ChoosePivotByRank
(
D
d
Traits
st
const
T
*
HWY_RESTRICT
samples
)
{
const
size_t
pivot_rank
=
PivotRank
(
st
samples
)
;
const
Vec
<
D
>
pivot
=
st
.
SetKey
(
d
samples
+
pivot_rank
)
;
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
Pivot
rank
%
zu
=
%
f
\
n
"
pivot_rank
static_cast
<
double
>
(
GetLane
(
pivot
)
)
)
;
}
constexpr
size_t
kSampleLanes
=
3
*
64
/
sizeof
(
T
)
;
constexpr
size_t
N1
=
st
.
LanesPerKey
(
)
;
const
Vec
<
D
>
last
=
st
.
SetKey
(
d
samples
+
kSampleLanes
-
N1
)
;
const
bool
all_neq
=
AllTrue
(
d
st
.
NotEqualKeys
(
d
pivot
last
)
)
;
(
void
)
all_neq
;
HWY_DASSERT
(
all_neq
)
;
return
pivot
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
bool
AllEqual
(
D
d
Traits
st
const
Vec
<
D
>
pivot
const
T
*
HWY_RESTRICT
keys
size_t
num
size_t
*
HWY_RESTRICT
first_mismatch
)
{
const
size_t
N
=
Lanes
(
d
)
;
HWY_DASSERT
(
num
>
=
N
)
;
const
Vec
<
D
>
zero
=
Zero
(
d
)
;
const
size_t
misalign
=
(
reinterpret_cast
<
uintptr_t
>
(
keys
)
/
sizeof
(
T
)
)
&
(
N
-
1
)
;
HWY_DASSERT
(
misalign
%
st
.
LanesPerKey
(
)
=
=
0
)
;
const
size_t
consume
=
N
-
misalign
;
{
const
Vec
<
D
>
v
=
LoadU
(
d
keys
)
;
const
Mask
<
D
>
diff
=
And
(
FirstN
(
d
consume
)
st
.
NotEqualKeys
(
d
v
pivot
)
)
;
if
(
HWY_UNLIKELY
(
!
AllFalse
(
d
diff
)
)
)
{
const
size_t
lane
=
FindKnownFirstTrue
(
d
diff
)
;
*
first_mismatch
=
lane
;
return
false
;
}
}
size_t
i
=
consume
;
HWY_DASSERT
(
(
(
reinterpret_cast
<
uintptr_t
>
(
keys
+
i
)
/
sizeof
(
T
)
)
&
(
N
-
1
)
)
=
=
0
)
;
Vec
<
D
>
diff0
=
zero
;
Vec
<
D
>
diff1
=
zero
;
constexpr
size_t
kLoops
=
8
;
const
size_t
lanes_per_group
=
kLoops
*
2
*
N
;
for
(
;
i
+
lanes_per_group
<
=
num
;
i
+
=
lanes_per_group
)
{
HWY_DEFAULT_UNROLL
for
(
size_t
loop
=
0
;
loop
<
kLoops
;
+
+
loop
)
{
const
Vec
<
D
>
v0
=
Load
(
d
keys
+
i
+
loop
*
2
*
N
)
;
const
Vec
<
D
>
v1
=
Load
(
d
keys
+
i
+
loop
*
2
*
N
+
N
)
;
diff0
=
OrXor
(
diff0
v0
pivot
)
;
diff1
=
OrXor
(
diff1
v1
pivot
)
;
}
if
(
HWY_UNLIKELY
(
!
st
.
NoKeyDifference
(
d
Or
(
diff0
diff1
)
)
)
)
{
for
(
;
;
i
+
=
N
)
{
const
Vec
<
D
>
v
=
Load
(
d
keys
+
i
)
;
const
Mask
<
D
>
diff
=
st
.
NotEqualKeys
(
d
v
pivot
)
;
if
(
HWY_UNLIKELY
(
!
AllFalse
(
d
diff
)
)
)
{
const
size_t
lane
=
FindKnownFirstTrue
(
d
diff
)
;
*
first_mismatch
=
i
+
lane
;
return
false
;
}
}
}
}
for
(
;
i
+
N
<
=
num
;
i
+
=
N
)
{
const
Vec
<
D
>
v
=
Load
(
d
keys
+
i
)
;
const
Mask
<
D
>
diff
=
st
.
NotEqualKeys
(
d
v
pivot
)
;
if
(
HWY_UNLIKELY
(
!
AllFalse
(
d
diff
)
)
)
{
const
size_t
lane
=
FindKnownFirstTrue
(
d
diff
)
;
*
first_mismatch
=
i
+
lane
;
return
false
;
}
}
i
=
num
-
N
;
const
Vec
<
D
>
v
=
LoadU
(
d
keys
+
i
)
;
const
Mask
<
D
>
diff
=
st
.
NotEqualKeys
(
d
v
pivot
)
;
if
(
HWY_UNLIKELY
(
!
AllFalse
(
d
diff
)
)
)
{
const
size_t
lane
=
FindKnownFirstTrue
(
d
diff
)
;
*
first_mismatch
=
i
+
lane
;
return
false
;
}
if
(
VQSORT_PRINT
>
=
1
)
{
fprintf
(
stderr
"
All
keys
equal
\
n
"
)
;
}
return
true
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
bool
ExistsAnyBefore
(
D
d
Traits
st
const
T
*
HWY_RESTRICT
keys
size_t
num
const
Vec
<
D
>
pivot
)
{
const
size_t
N
=
Lanes
(
d
)
;
HWY_DASSERT
(
num
>
=
N
)
;
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
Scanning
for
before
\
n
"
)
;
}
size_t
i
=
0
;
constexpr
size_t
kLoops
=
16
;
const
size_t
lanes_per_group
=
kLoops
*
N
;
Vec
<
D
>
first
=
pivot
;
for
(
;
i
+
lanes_per_group
<
=
num
;
i
+
=
lanes_per_group
)
{
HWY_DEFAULT_UNROLL
for
(
size_t
loop
=
0
;
loop
<
kLoops
;
+
+
loop
)
{
const
Vec
<
D
>
curr
=
LoadU
(
d
keys
+
i
+
loop
*
N
)
;
first
=
st
.
First
(
d
first
curr
)
;
}
if
(
HWY_UNLIKELY
(
!
AllFalse
(
d
st
.
Compare
(
d
first
pivot
)
)
)
)
{
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
Stopped
scanning
at
end
of
group
%
zu
\
n
"
i
+
lanes_per_group
)
;
}
return
true
;
}
}
for
(
;
i
+
N
<
=
num
;
i
+
=
N
)
{
const
Vec
<
D
>
curr
=
LoadU
(
d
keys
+
i
)
;
if
(
HWY_UNLIKELY
(
!
AllFalse
(
d
st
.
Compare
(
d
curr
pivot
)
)
)
)
{
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
Stopped
scanning
at
%
zu
\
n
"
i
)
;
}
return
true
;
}
}
if
(
HWY_LIKELY
(
i
!
=
num
)
)
{
const
Vec
<
D
>
curr
=
LoadU
(
d
keys
+
num
-
N
)
;
if
(
HWY_UNLIKELY
(
!
AllFalse
(
d
st
.
Compare
(
d
curr
pivot
)
)
)
)
{
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
Stopped
scanning
at
last
%
zu
\
n
"
num
-
N
)
;
}
return
true
;
}
}
return
false
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
bool
ExistsAnyAfter
(
D
d
Traits
st
const
T
*
HWY_RESTRICT
keys
size_t
num
const
Vec
<
D
>
pivot
)
{
const
size_t
N
=
Lanes
(
d
)
;
HWY_DASSERT
(
num
>
=
N
)
;
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
Scanning
for
after
\
n
"
)
;
}
size_t
i
=
0
;
constexpr
size_t
kLoops
=
16
;
const
size_t
lanes_per_group
=
kLoops
*
N
;
Vec
<
D
>
last
=
pivot
;
for
(
;
i
+
lanes_per_group
<
=
num
;
i
+
=
lanes_per_group
)
{
HWY_DEFAULT_UNROLL
for
(
size_t
loop
=
0
;
loop
<
kLoops
;
+
+
loop
)
{
const
Vec
<
D
>
curr
=
LoadU
(
d
keys
+
i
+
loop
*
N
)
;
last
=
st
.
Last
(
d
last
curr
)
;
}
if
(
HWY_UNLIKELY
(
!
AllFalse
(
d
st
.
Compare
(
d
pivot
last
)
)
)
)
{
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
Stopped
scanning
at
end
of
group
%
zu
\
n
"
i
+
lanes_per_group
)
;
}
return
true
;
}
}
for
(
;
i
+
N
<
=
num
;
i
+
=
N
)
{
const
Vec
<
D
>
curr
=
LoadU
(
d
keys
+
i
)
;
if
(
HWY_UNLIKELY
(
!
AllFalse
(
d
st
.
Compare
(
d
pivot
curr
)
)
)
)
{
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
Stopped
scanning
at
%
zu
\
n
"
i
)
;
}
return
true
;
}
}
if
(
HWY_LIKELY
(
i
!
=
num
)
)
{
const
Vec
<
D
>
curr
=
LoadU
(
d
keys
+
num
-
N
)
;
if
(
HWY_UNLIKELY
(
!
AllFalse
(
d
st
.
Compare
(
d
pivot
curr
)
)
)
)
{
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
Stopped
scanning
at
last
%
zu
\
n
"
num
-
N
)
;
}
return
true
;
}
}
return
false
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
Vec
<
D
>
ChoosePivotForEqualSamples
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
num
T
*
HWY_RESTRICT
samples
Vec
<
D
>
second
Vec
<
D
>
third
PivotResult
&
result
)
{
const
Vec
<
D
>
pivot
=
st
.
SetKey
(
d
samples
)
;
if
(
HWY_UNLIKELY
(
AllTrue
(
d
st
.
EqualKeys
(
d
pivot
st
.
FirstValue
(
d
)
)
)
)
)
{
result
=
PivotResult
:
:
kIsFirst
;
return
pivot
;
}
if
(
HWY_UNLIKELY
(
AllTrue
(
d
st
.
EqualKeys
(
d
pivot
st
.
LastValue
(
d
)
)
)
)
)
{
result
=
PivotResult
:
:
kWasLast
;
return
st
.
PrevValue
(
d
pivot
)
;
}
if
(
st
.
IsKV
(
)
)
{
const
bool
before
=
!
AllFalse
(
d
st
.
Compare
(
d
second
pivot
)
)
;
if
(
HWY_UNLIKELY
(
before
)
)
{
if
(
HWY_UNLIKELY
(
ExistsAnyAfter
(
d
st
keys
num
pivot
)
)
)
{
result
=
PivotResult
:
:
kNormal
;
return
pivot
;
}
result
=
PivotResult
:
:
kWasLast
;
return
st
.
PrevValue
(
d
pivot
)
;
}
if
(
HWY_UNLIKELY
(
ExistsAnyBefore
(
d
st
keys
num
pivot
)
)
)
{
result
=
PivotResult
:
:
kNormal
;
return
pivot
;
}
}
else
{
st
.
Sort2
(
d
second
third
)
;
HWY_DASSERT
(
AllTrue
(
d
st
.
Compare
(
d
second
third
)
)
)
;
const
bool
before
=
!
AllFalse
(
d
st
.
Compare
(
d
second
pivot
)
)
;
const
bool
after
=
!
AllFalse
(
d
st
.
Compare
(
d
pivot
third
)
)
;
HWY_DASSERT
(
before
|
|
after
)
;
if
(
HWY_UNLIKELY
(
before
)
)
{
if
(
HWY_UNLIKELY
(
after
|
|
ExistsAnyAfter
(
d
st
keys
num
pivot
)
)
)
{
result
=
PivotResult
:
:
kNormal
;
return
pivot
;
}
result
=
PivotResult
:
:
kWasLast
;
return
st
.
PrevValue
(
d
pivot
)
;
}
if
(
HWY_UNLIKELY
(
ExistsAnyBefore
(
d
st
keys
num
pivot
)
)
)
{
result
=
PivotResult
:
:
kNormal
;
return
pivot
;
}
}
result
=
PivotResult
:
:
kIsFirst
;
return
pivot
;
}
template
<
class
D
class
Traits
typename
T
>
HWY_NOINLINE
void
PrintMinMax
(
D
d
Traits
st
const
T
*
HWY_RESTRICT
keys
size_t
num
T
*
HWY_RESTRICT
buf
)
{
if
(
VQSORT_PRINT
>
=
2
)
{
const
size_t
N
=
Lanes
(
d
)
;
if
(
num
<
N
)
return
;
Vec
<
D
>
first
=
st
.
LastValue
(
d
)
;
Vec
<
D
>
last
=
st
.
FirstValue
(
d
)
;
size_t
i
=
0
;
for
(
;
i
+
N
<
=
num
;
i
+
=
N
)
{
const
Vec
<
D
>
v
=
LoadU
(
d
keys
+
i
)
;
first
=
st
.
First
(
d
v
first
)
;
last
=
st
.
Last
(
d
v
last
)
;
}
if
(
HWY_LIKELY
(
i
!
=
num
)
)
{
HWY_DASSERT
(
num
>
=
N
)
;
const
Vec
<
D
>
v
=
LoadU
(
d
keys
+
num
-
N
)
;
first
=
st
.
First
(
d
v
first
)
;
last
=
st
.
Last
(
d
v
last
)
;
}
first
=
st
.
FirstOfLanes
(
d
first
buf
)
;
last
=
st
.
LastOfLanes
(
d
last
buf
)
;
MaybePrintVector
(
d
"
first
"
first
0
st
.
LanesPerKey
(
)
)
;
MaybePrintVector
(
d
"
last
"
last
0
st
.
LanesPerKey
(
)
)
;
}
}
template
<
class
D
class
Traits
typename
T
>
HWY_NOINLINE
void
Recurse
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
T
*
HWY_RESTRICT
keys_end
const
size_t
num
T
*
HWY_RESTRICT
buf
Generator
&
rng
const
size_t
remaining_levels
)
{
HWY_DASSERT
(
num
!
=
0
)
;
if
(
HWY_UNLIKELY
(
num
<
=
Constants
:
:
BaseCaseNum
(
Lanes
(
d
)
)
)
)
{
BaseCase
(
d
st
keys
keys_end
num
buf
)
;
return
;
}
if
(
VQSORT_PRINT
>
=
1
)
{
fprintf
(
stderr
"
\
n
\
n
=
=
=
Recurse
depth
=
%
zu
len
=
%
zu
\
n
"
remaining_levels
num
)
;
PrintMinMax
(
d
st
keys
num
buf
)
;
}
DrawSamples
(
d
st
keys
num
buf
rng
)
;
Vec
<
D
>
pivot
;
PivotResult
result
=
PivotResult
:
:
kNormal
;
if
(
HWY_UNLIKELY
(
UnsortedSampleEqual
(
d
st
buf
)
)
)
{
pivot
=
st
.
SetKey
(
d
buf
)
;
size_t
idx_second
=
0
;
if
(
HWY_UNLIKELY
(
AllEqual
(
d
st
pivot
keys
num
&
idx_second
)
)
)
{
return
;
}
HWY_DASSERT
(
idx_second
%
st
.
LanesPerKey
(
)
=
=
0
)
;
const
Vec
<
D
>
second
=
st
.
SetKey
(
d
keys
+
idx_second
)
;
MaybePrintVector
(
d
"
pivot
"
pivot
0
st
.
LanesPerKey
(
)
)
;
MaybePrintVector
(
d
"
second
"
second
0
st
.
LanesPerKey
(
)
)
;
Vec
<
D
>
third
;
if
(
HWY_UNLIKELY
(
!
st
.
IsKV
(
)
&
&
PartitionIfTwoKeys
(
d
st
pivot
keys
num
idx_second
second
third
buf
)
)
)
{
return
;
}
pivot
=
ChoosePivotForEqualSamples
(
d
st
keys
num
buf
second
third
result
)
;
}
else
{
SortSamples
(
d
st
buf
)
;
if
(
HWY_UNLIKELY
(
!
st
.
IsKV
(
)
&
&
PartitionIfTwoSamples
(
d
st
keys
num
buf
)
)
)
{
return
;
}
pivot
=
ChoosePivotByRank
(
d
st
buf
)
;
}
if
(
HWY_UNLIKELY
(
remaining_levels
=
=
0
)
)
{
if
(
VQSORT_PRINT
>
=
1
)
{
fprintf
(
stderr
"
HeapSort
reached
size
=
%
zu
\
n
"
num
)
;
}
HeapSort
(
st
keys
num
)
;
return
;
}
const
size_t
bound
=
Partition
(
d
st
keys
num
pivot
buf
)
;
if
(
VQSORT_PRINT
>
=
2
)
{
fprintf
(
stderr
"
bound
%
zu
num
%
zu
result
%
s
\
n
"
bound
num
PivotResultString
(
result
)
)
;
}
HWY_DASSERT
(
bound
!
=
0
)
;
HWY_DASSERT
(
bound
!
=
num
)
;
if
(
HWY_LIKELY
(
result
!
=
PivotResult
:
:
kIsFirst
)
)
{
Recurse
(
d
st
keys
keys_end
bound
buf
rng
remaining_levels
-
1
)
;
}
if
(
HWY_LIKELY
(
result
!
=
PivotResult
:
:
kWasLast
)
)
{
Recurse
(
d
st
keys
+
bound
keys_end
num
-
bound
buf
rng
remaining_levels
-
1
)
;
}
}
template
<
class
D
class
Traits
typename
T
>
HWY_INLINE
bool
HandleSpecialCases
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
num
)
{
const
size_t
N
=
Lanes
(
d
)
;
const
size_t
base_case_num
=
Constants
:
:
BaseCaseNum
(
N
)
;
const
bool
partial_128
=
!
IsFull
(
d
)
&
&
N
<
2
&
&
st
.
Is128
(
)
;
constexpr
bool
kPotentiallyHuge
=
HWY_MAX_BYTES
/
sizeof
(
T
)
>
Constants
:
:
kMaxRows
*
Constants
:
:
kMaxCols
;
const
bool
huge_vec
=
kPotentiallyHuge
&
&
(
2
*
N
>
base_case_num
)
;
if
(
partial_128
|
|
huge_vec
)
{
if
(
VQSORT_PRINT
>
=
1
)
{
fprintf
(
stderr
"
WARNING
:
using
slow
HeapSort
:
partial
%
d
huge
%
d
\
n
"
partial_128
huge_vec
)
;
}
HeapSort
(
st
keys
num
)
;
return
true
;
}
return
false
;
}
#
endif
}
template
<
class
D
class
Traits
typename
T
>
void
Sort
(
D
d
Traits
st
T
*
HWY_RESTRICT
keys
size_t
num
T
*
HWY_RESTRICT
buf
)
{
if
(
VQSORT_PRINT
>
=
1
)
{
fprintf
(
stderr
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
Sort
num
%
zu
\
n
"
num
)
;
}
#
if
VQSORT_ENABLED
|
|
HWY_IDE
#
if
!
HWY_HAVE_SCALABLE
HWY_ALIGN
T
storage
[
SortConstants
:
:
BufNum
<
T
>
(
HWY_LANES
(
T
)
)
]
=
{
}
;
static_assert
(
sizeof
(
storage
)
<
=
8192
"
Unexpectedly
large
check
size
"
)
;
buf
=
storage
;
#
endif
if
(
detail
:
:
HandleSpecialCases
(
d
st
keys
num
)
)
return
;
#
if
HWY_MAX_BYTES
>
64
if
(
HWY_UNLIKELY
(
Lanes
(
d
)
>
64
/
sizeof
(
T
)
)
)
{
return
Sort
(
CappedTag
<
T
64
/
sizeof
(
T
)
>
(
)
st
keys
num
buf
)
;
}
#
endif
detail
:
:
Generator
rng
(
keys
num
)
;
const
size_t
max_levels
=
2
*
hwy
:
:
CeilLog2
(
num
)
+
4
;
detail
:
:
Recurse
(
d
st
keys
keys
+
num
num
buf
rng
max_levels
)
;
#
else
(
void
)
d
;
(
void
)
buf
;
if
(
VQSORT_PRINT
>
=
1
)
{
fprintf
(
stderr
"
WARNING
:
using
slow
HeapSort
because
vqsort
disabled
\
n
"
)
;
}
return
detail
:
:
HeapSort
(
st
keys
num
)
;
#
endif
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
