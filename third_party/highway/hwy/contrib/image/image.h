#
ifndef
HIGHWAY_HWY_CONTRIB_IMAGE_IMAGE_H_
#
define
HIGHWAY_HWY_CONTRIB_IMAGE_IMAGE_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
utility
>
#
include
"
hwy
/
aligned_allocator
.
h
"
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
highway_export
.
h
"
namespace
hwy
{
struct
HWY_CONTRIB_DLLEXPORT
ImageBase
{
static
size_t
VectorSize
(
)
;
static
size_t
BytesPerRow
(
const
size_t
xsize
const
size_t
sizeof_t
)
;
ImageBase
(
)
:
xsize_
(
0
)
ysize_
(
0
)
bytes_per_row_
(
0
)
bytes_
(
nullptr
AlignedFreer
(
&
AlignedFreer
:
:
DoNothing
nullptr
)
)
{
}
ImageBase
(
size_t
xsize
size_t
ysize
size_t
sizeof_t
)
;
ImageBase
(
size_t
xsize
size_t
ysize
size_t
bytes_per_row
void
*
aligned
)
;
ImageBase
(
const
ImageBase
&
other
)
=
delete
;
ImageBase
&
operator
=
(
const
ImageBase
&
other
)
=
delete
;
ImageBase
(
ImageBase
&
&
other
)
noexcept
=
default
;
ImageBase
&
operator
=
(
ImageBase
&
&
other
)
noexcept
=
default
;
void
Swap
(
ImageBase
&
other
)
;
void
ShrinkTo
(
const
size_t
xsize
const
size_t
ysize
)
{
xsize_
=
static_cast
<
uint32_t
>
(
xsize
)
;
ysize_
=
static_cast
<
uint32_t
>
(
ysize
)
;
}
HWY_INLINE
size_t
xsize
(
)
const
{
return
xsize_
;
}
HWY_INLINE
size_t
ysize
(
)
const
{
return
ysize_
;
}
HWY_INLINE
size_t
bytes_per_row
(
)
const
{
return
bytes_per_row_
;
}
HWY_INLINE
uint8_t
*
bytes
(
)
{
void
*
p
=
bytes_
.
get
(
)
;
return
static_cast
<
uint8_t
*
HWY_RESTRICT
>
(
HWY_ASSUME_ALIGNED
(
p
64
)
)
;
}
HWY_INLINE
const
uint8_t
*
bytes
(
)
const
{
const
void
*
p
=
bytes_
.
get
(
)
;
return
static_cast
<
const
uint8_t
*
HWY_RESTRICT
>
(
HWY_ASSUME_ALIGNED
(
p
64
)
)
;
}
protected
:
HWY_INLINE
void
*
VoidRow
(
const
size_t
y
)
const
{
#
if
HWY_IS_ASAN
|
|
HWY_IS_MSAN
|
|
HWY_IS_TSAN
if
(
y
>
=
ysize_
)
{
HWY_ABORT
(
"
Row
(
%
d
)
>
=
%
u
\
n
"
static_cast
<
int
>
(
y
)
ysize_
)
;
}
#
endif
void
*
row
=
bytes_
.
get
(
)
+
y
*
bytes_per_row_
;
return
HWY_ASSUME_ALIGNED
(
row
64
)
;
}
enum
class
Padding
{
kRoundUp
kUnaligned
}
;
void
InitializePadding
(
size_t
sizeof_t
Padding
padding
)
;
uint32_t
xsize_
;
uint32_t
ysize_
;
size_t
bytes_per_row_
;
AlignedFreeUniquePtr
<
uint8_t
[
]
>
bytes_
;
}
;
template
<
typename
ComponentType
>
class
Image
:
public
ImageBase
{
public
:
using
T
=
ComponentType
;
Image
(
)
=
default
;
Image
(
const
size_t
xsize
const
size_t
ysize
)
:
ImageBase
(
xsize
ysize
sizeof
(
T
)
)
{
}
Image
(
const
size_t
xsize
const
size_t
ysize
size_t
bytes_per_row
void
*
aligned
)
:
ImageBase
(
xsize
ysize
bytes_per_row
aligned
)
{
}
void
InitializePaddingForUnalignedAccesses
(
)
{
InitializePadding
(
sizeof
(
T
)
Padding
:
:
kUnaligned
)
;
}
HWY_INLINE
const
T
*
ConstRow
(
const
size_t
y
)
const
{
return
static_cast
<
const
T
*
>
(
VoidRow
(
y
)
)
;
}
HWY_INLINE
const
T
*
ConstRow
(
const
size_t
y
)
{
return
static_cast
<
const
T
*
>
(
VoidRow
(
y
)
)
;
}
HWY_INLINE
T
*
MutableRow
(
const
size_t
y
)
const
{
return
static_cast
<
T
*
>
(
VoidRow
(
y
)
)
;
}
HWY_INLINE
T
*
MutableRow
(
const
size_t
y
)
{
return
static_cast
<
T
*
>
(
VoidRow
(
y
)
)
;
}
HWY_INLINE
intptr_t
PixelsPerRow
(
)
const
{
return
static_cast
<
intptr_t
>
(
bytes_per_row_
/
sizeof
(
T
)
)
;
}
}
;
using
ImageF
=
Image
<
float
>
;
template
<
typename
ComponentType
>
class
Image3
{
public
:
using
T
=
ComponentType
;
using
ImageT
=
Image
<
T
>
;
static
constexpr
size_t
kNumPlanes
=
3
;
Image3
(
)
:
planes_
{
ImageT
(
)
ImageT
(
)
ImageT
(
)
}
{
}
Image3
(
const
size_t
xsize
const
size_t
ysize
)
:
planes_
{
ImageT
(
xsize
ysize
)
ImageT
(
xsize
ysize
)
ImageT
(
xsize
ysize
)
}
{
}
Image3
(
Image3
&
&
other
)
noexcept
{
for
(
size_t
i
=
0
;
i
<
kNumPlanes
;
i
+
+
)
{
planes_
[
i
]
=
std
:
:
move
(
other
.
planes_
[
i
]
)
;
}
}
Image3
(
ImageT
&
&
plane0
ImageT
&
&
plane1
ImageT
&
&
plane2
)
{
if
(
!
SameSize
(
plane0
plane1
)
|
|
!
SameSize
(
plane0
plane2
)
)
{
HWY_ABORT
(
"
Not
same
size
:
%
d
x
%
d
%
d
x
%
d
%
d
x
%
d
\
n
"
static_cast
<
int
>
(
plane0
.
xsize
(
)
)
static_cast
<
int
>
(
plane0
.
ysize
(
)
)
static_cast
<
int
>
(
plane1
.
xsize
(
)
)
static_cast
<
int
>
(
plane1
.
ysize
(
)
)
static_cast
<
int
>
(
plane2
.
xsize
(
)
)
static_cast
<
int
>
(
plane2
.
ysize
(
)
)
)
;
}
planes_
[
0
]
=
std
:
:
move
(
plane0
)
;
planes_
[
1
]
=
std
:
:
move
(
plane1
)
;
planes_
[
2
]
=
std
:
:
move
(
plane2
)
;
}
Image3
(
const
Image3
&
other
)
=
delete
;
Image3
&
operator
=
(
const
Image3
&
other
)
=
delete
;
Image3
&
operator
=
(
Image3
&
&
other
)
noexcept
{
for
(
size_t
i
=
0
;
i
<
kNumPlanes
;
i
+
+
)
{
planes_
[
i
]
=
std
:
:
move
(
other
.
planes_
[
i
]
)
;
}
return
*
this
;
}
HWY_INLINE
const
T
*
ConstPlaneRow
(
const
size_t
c
const
size_t
y
)
const
{
return
static_cast
<
const
T
*
>
(
VoidPlaneRow
(
c
y
)
)
;
}
HWY_INLINE
const
T
*
ConstPlaneRow
(
const
size_t
c
const
size_t
y
)
{
return
static_cast
<
const
T
*
>
(
VoidPlaneRow
(
c
y
)
)
;
}
HWY_INLINE
T
*
MutablePlaneRow
(
const
size_t
c
const
size_t
y
)
const
{
return
static_cast
<
T
*
>
(
VoidPlaneRow
(
c
y
)
)
;
}
HWY_INLINE
T
*
MutablePlaneRow
(
const
size_t
c
const
size_t
y
)
{
return
static_cast
<
T
*
>
(
VoidPlaneRow
(
c
y
)
)
;
}
HWY_INLINE
const
ImageT
&
Plane
(
size_t
idx
)
const
{
return
planes_
[
idx
]
;
}
void
Swap
(
Image3
&
other
)
{
for
(
size_t
c
=
0
;
c
<
3
;
+
+
c
)
{
other
.
planes_
[
c
]
.
Swap
(
planes_
[
c
]
)
;
}
}
void
ShrinkTo
(
const
size_t
xsize
const
size_t
ysize
)
{
for
(
ImageT
&
plane
:
planes_
)
{
plane
.
ShrinkTo
(
xsize
ysize
)
;
}
}
HWY_INLINE
size_t
xsize
(
)
const
{
return
planes_
[
0
]
.
xsize
(
)
;
}
HWY_INLINE
size_t
ysize
(
)
const
{
return
planes_
[
0
]
.
ysize
(
)
;
}
HWY_INLINE
size_t
bytes_per_row
(
)
const
{
return
planes_
[
0
]
.
bytes_per_row
(
)
;
}
HWY_INLINE
intptr_t
PixelsPerRow
(
)
const
{
return
planes_
[
0
]
.
PixelsPerRow
(
)
;
}
private
:
HWY_INLINE
void
*
VoidPlaneRow
(
const
size_t
c
const
size_t
y
)
const
{
#
if
HWY_IS_ASAN
|
|
HWY_IS_MSAN
|
|
HWY_IS_TSAN
if
(
c
>
=
kNumPlanes
|
|
y
>
=
ysize
(
)
)
{
HWY_ABORT
(
"
PlaneRow
(
%
d
%
d
)
>
=
%
d
\
n
"
static_cast
<
int
>
(
c
)
static_cast
<
int
>
(
y
)
static_cast
<
int
>
(
ysize
(
)
)
)
;
}
#
endif
const
size_t
row_offset
=
y
*
planes_
[
0
]
.
bytes_per_row
(
)
;
const
void
*
row
=
planes_
[
c
]
.
bytes
(
)
+
row_offset
;
return
static_cast
<
const
T
*
HWY_RESTRICT
>
(
HWY_ASSUME_ALIGNED
(
row
HWY_ALIGNMENT
)
)
;
}
private
:
ImageT
planes_
[
kNumPlanes
]
;
}
;
using
Image3F
=
Image3
<
float
>
;
class
Rect
{
public
:
constexpr
Rect
(
size_t
xbegin
size_t
ybegin
size_t
xsize_max
size_t
ysize_max
size_t
xend
size_t
yend
)
:
x0_
(
xbegin
)
y0_
(
ybegin
)
xsize_
(
ClampedSize
(
xbegin
xsize_max
xend
)
)
ysize_
(
ClampedSize
(
ybegin
ysize_max
yend
)
)
{
}
constexpr
Rect
(
size_t
xbegin
size_t
ybegin
size_t
xsize
size_t
ysize
)
:
x0_
(
xbegin
)
y0_
(
ybegin
)
xsize_
(
xsize
)
ysize_
(
ysize
)
{
}
template
<
typename
Image
>
explicit
Rect
(
const
Image
&
image
)
:
Rect
(
0
0
image
.
xsize
(
)
image
.
ysize
(
)
)
{
}
Rect
(
)
:
Rect
(
0
0
0
0
)
{
}
Rect
(
const
Rect
&
)
=
default
;
Rect
&
operator
=
(
const
Rect
&
)
=
default
;
Rect
Subrect
(
size_t
xbegin
size_t
ybegin
size_t
xsize_max
size_t
ysize_max
)
{
return
Rect
(
x0_
+
xbegin
y0_
+
ybegin
xsize_max
ysize_max
x0_
+
xsize_
y0_
+
ysize_
)
;
}
template
<
typename
T
>
const
T
*
ConstRow
(
const
Image
<
T
>
*
image
size_t
y
)
const
{
return
image
-
>
ConstRow
(
y
+
y0_
)
+
x0_
;
}
template
<
typename
T
>
T
*
MutableRow
(
const
Image
<
T
>
*
image
size_t
y
)
const
{
return
image
-
>
MutableRow
(
y
+
y0_
)
+
x0_
;
}
template
<
typename
T
>
const
T
*
ConstPlaneRow
(
const
Image3
<
T
>
&
image
size_t
c
size_t
y
)
const
{
return
image
.
ConstPlaneRow
(
c
y
+
y0_
)
+
x0_
;
}
template
<
typename
T
>
T
*
MutablePlaneRow
(
Image3
<
T
>
*
image
const
size_t
c
size_t
y
)
const
{
return
image
-
>
MutablePlaneRow
(
c
y
+
y0_
)
+
x0_
;
}
template
<
class
ImageT
>
bool
IsInside
(
const
ImageT
&
image
)
const
{
return
(
x0_
+
xsize_
<
=
image
.
xsize
(
)
)
&
&
(
y0_
+
ysize_
<
=
image
.
ysize
(
)
)
;
}
size_t
x0
(
)
const
{
return
x0_
;
}
size_t
y0
(
)
const
{
return
y0_
;
}
size_t
xsize
(
)
const
{
return
xsize_
;
}
size_t
ysize
(
)
const
{
return
ysize_
;
}
private
:
static
constexpr
size_t
ClampedSize
(
size_t
begin
size_t
size_max
size_t
end
)
{
return
(
begin
+
size_max
<
=
end
)
?
size_max
:
(
end
>
begin
?
end
-
begin
:
0
)
;
}
size_t
x0_
;
size_t
y0_
;
size_t
xsize_
;
size_t
ysize_
;
}
;
template
<
class
Image1
class
Image2
>
HWY_MAYBE_UNUSED
bool
SameSize
(
const
Image1
&
image1
const
Image2
&
image2
)
{
return
image1
.
xsize
(
)
=
=
image2
.
xsize
(
)
&
&
image1
.
ysize
(
)
=
=
image2
.
ysize
(
)
;
}
static
HWY_INLINE
HWY_MAYBE_UNUSED
size_t
Mirror
(
int64_t
x
const
int64_t
xsize
)
{
HWY_DASSERT
(
xsize
!
=
0
)
;
while
(
x
<
0
|
|
x
>
=
xsize
)
{
if
(
x
<
0
)
{
x
=
-
x
-
1
;
}
else
{
x
=
2
*
xsize
-
1
-
x
;
}
}
return
static_cast
<
size_t
>
(
x
)
;
}
struct
WrapMirror
{
HWY_INLINE
size_t
operator
(
)
(
const
int64_t
coord
const
size_t
size
)
const
{
return
Mirror
(
coord
static_cast
<
int64_t
>
(
size
)
)
;
}
}
;
struct
WrapUnchanged
{
HWY_INLINE
size_t
operator
(
)
(
const
int64_t
coord
size_t
)
const
{
return
static_cast
<
size_t
>
(
coord
)
;
}
}
;
class
WrapRowMirror
{
public
:
template
<
class
View
>
WrapRowMirror
(
const
View
&
image
size_t
ysize
)
:
first_row_
(
image
.
ConstRow
(
0
)
)
last_row_
(
image
.
ConstRow
(
ysize
-
1
)
)
{
}
const
float
*
operator
(
)
(
const
float
*
const
HWY_RESTRICT
row
const
int64_t
stride
)
const
{
if
(
row
<
first_row_
)
{
const
int64_t
num_before
=
first_row_
-
row
;
return
first_row_
+
num_before
-
stride
;
}
if
(
row
>
last_row_
)
{
const
int64_t
num_after
=
row
-
last_row_
;
return
last_row_
-
num_after
+
stride
;
}
return
row
;
}
private
:
const
float
*
const
HWY_RESTRICT
first_row_
;
const
float
*
const
HWY_RESTRICT
last_row_
;
}
;
struct
WrapRowUnchanged
{
HWY_INLINE
const
float
*
operator
(
)
(
const
float
*
const
HWY_RESTRICT
row
int64_t
)
const
{
return
row
;
}
}
;
}
#
endif
