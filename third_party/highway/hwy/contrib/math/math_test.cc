#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
cfloat
>
#
include
<
cmath
>
#
include
"
hwy
/
base
.
h
"
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
hwy
/
contrib
/
math
/
math_test
.
cc
"
#
include
"
hwy
/
foreach_target
.
h
"
#
include
"
hwy
/
highway
.
h
"
#
include
"
hwy
/
contrib
/
math
/
math
-
inl
.
h
"
#
include
"
hwy
/
tests
/
test_util
-
inl
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
namespace
{
#
undef
HWY_MATH_TEST_EXCESS_PRECISION
#
if
HWY_ARCH_X86_32
&
&
HWY_COMPILER_GCC_ACTUAL
&
&
\
(
HWY_TARGET
=
=
HWY_SCALAR
|
|
HWY_TARGET
=
=
HWY_EMU128
)
#
if
HWY_COMPILER_GCC_ACTUAL
>
=
1300
#
define
HWY_MATH_TEST_EXCESS_PRECISION
0
#
else
#
if
defined
(
__SSE2__
)
#
define
HWY_MATH_TEST_EXCESS_PRECISION
0
#
else
#
define
HWY_MATH_TEST_EXCESS_PRECISION
1
#
pragma
message
(
\
"
Skipping
scalar
math_test
on
32
-
bit
x86
GCC
<
13
without
HWY_CMAKE_SSE2
"
)
#
endif
#
endif
#
else
#
define
HWY_MATH_TEST_EXCESS_PRECISION
0
#
endif
template
<
class
T
class
D
>
HWY_NOINLINE
void
TestMath
(
const
char
*
name
T
(
*
fx1
)
(
T
)
Vec
<
D
>
(
*
fxN
)
(
D
VecArg
<
Vec
<
D
>
>
)
D
d
T
min
T
max
uint64_t
max_error_ulp
)
{
if
(
HWY_MATH_TEST_EXCESS_PRECISION
)
{
static
bool
once
=
true
;
if
(
once
)
{
once
=
false
;
HWY_WARN
(
"
Skipping
math_test
due
to
GCC
issue
with
excess
precision
.
\
n
"
)
;
}
return
;
}
using
UintT
=
MakeUnsigned
<
T
>
;
const
UintT
min_bits
=
BitCastScalar
<
UintT
>
(
min
)
;
const
UintT
max_bits
=
BitCastScalar
<
UintT
>
(
max
)
;
int
range_count
=
1
;
UintT
ranges
[
2
]
[
2
]
=
{
{
min_bits
max_bits
}
{
0
0
}
}
;
if
(
(
min
<
T
{
0
}
)
&
&
(
max
>
T
{
0
}
)
)
{
ranges
[
0
]
[
0
]
=
BitCastScalar
<
UintT
>
(
ConvertScalarTo
<
T
>
(
+
0
.
0
)
)
;
ranges
[
0
]
[
1
]
=
max_bits
;
ranges
[
1
]
[
0
]
=
BitCastScalar
<
UintT
>
(
ConvertScalarTo
<
T
>
(
-
0
.
0
)
)
;
ranges
[
1
]
[
1
]
=
min_bits
;
range_count
=
2
;
}
uint64_t
max_ulp
=
0
;
constexpr
UintT
kSamplesPerRange
=
static_cast
<
UintT
>
(
AdjustedReps
(
4000
)
)
;
for
(
int
range_index
=
0
;
range_index
<
range_count
;
+
+
range_index
)
{
const
UintT
start
=
ranges
[
range_index
]
[
0
]
;
const
UintT
stop
=
ranges
[
range_index
]
[
1
]
;
const
UintT
step
=
HWY_MAX
(
1
(
(
stop
-
start
)
/
kSamplesPerRange
)
)
;
for
(
UintT
value_bits
=
start
;
value_bits
<
=
stop
;
value_bits
+
=
step
)
{
const
T
value
=
BitCastScalar
<
T
>
(
HWY_MIN
(
HWY_MAX
(
start
value_bits
)
stop
)
)
;
const
T
actual
=
GetLane
(
fxN
(
d
Set
(
d
value
)
)
)
;
const
T
expected
=
fx1
(
value
)
;
#
if
HWY_TARGET
<
=
HWY_NEON_WITHOUT_AES
&
&
HWY_ARCH_ARM_V7
if
(
(
std
:
:
abs
(
value
)
<
1e
-
37f
)
|
|
(
std
:
:
abs
(
expected
)
<
1e
-
37f
)
)
{
continue
;
}
#
endif
const
auto
ulp
=
hwy
:
:
detail
:
:
ComputeUlpDelta
(
actual
expected
)
;
max_ulp
=
HWY_MAX
(
max_ulp
ulp
)
;
if
(
ulp
>
max_error_ulp
)
{
fprintf
(
stderr
"
%
s
:
%
s
(
%
f
)
expected
%
E
actual
%
E
ulp
%
g
max
ulp
%
u
\
n
"
hwy
:
:
TypeName
(
T
(
)
Lanes
(
d
)
)
.
c_str
(
)
name
value
static_cast
<
double
>
(
expected
)
static_cast
<
double
>
(
actual
)
static_cast
<
double
>
(
ulp
)
static_cast
<
uint32_t
>
(
max_error_ulp
)
)
;
}
}
}
fprintf
(
stderr
"
%
s
:
%
s
max_ulp
%
g
\
n
"
hwy
:
:
TypeName
(
T
(
)
Lanes
(
d
)
)
.
c_str
(
)
name
static_cast
<
double
>
(
max_ulp
)
)
;
HWY_ASSERT
(
max_ulp
<
=
max_error_ulp
)
;
}
#
define
DEFINE_MATH_TEST_FUNC
(
NAME
)
\
HWY_NOINLINE
void
TestAll
#
#
NAME
(
)
{
\
ForFloat3264Types
(
ForPartialVectors
<
Test
#
#
NAME
>
(
)
)
;
\
}
#
undef
DEFINE_MATH_TEST
#
define
DEFINE_MATH_TEST
(
NAME
F32x1
F32xN
F32_MIN
F32_MAX
F32_ERROR
\
F64x1
F64xN
F64_MIN
F64_MAX
F64_ERROR
)
\
struct
Test
#
#
NAME
{
\
template
<
class
T
class
D
HWY_IF_T_SIZE
(
T
4
)
>
\
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
\
TestMath
<
T
D
>
(
HWY_STR
(
NAME
)
F32x1
F32xN
d
F32_MIN
F32_MAX
\
F32_ERROR
)
;
\
}
\
template
<
class
T
class
D
HWY_IF_T_SIZE
(
T
8
)
>
\
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
\
TestMath
<
T
D
>
(
HWY_STR
(
NAME
)
F64x1
F64xN
d
static_cast
<
T
>
(
F64_MIN
)
\
static_cast
<
T
>
(
F64_MAX
)
F64_ERROR
)
;
\
}
\
}
;
\
DEFINE_MATH_TEST_FUNC
(
NAME
)
DEFINE_MATH_TEST
(
Exp
std
:
:
exp
CallExp
-
FLT_MAX
+
104
.
0f
1
std
:
:
exp
CallExp
-
DBL_MAX
+
104
.
0
1
)
DEFINE_MATH_TEST
(
Exp2
std
:
:
exp2
CallExp2
-
FLT_MAX
+
128
.
0f
2
std
:
:
exp2
CallExp2
-
DBL_MAX
+
128
.
0
2
)
DEFINE_MATH_TEST
(
Expm1
std
:
:
expm1
CallExpm1
-
FLT_MAX
+
104
.
0f
4
std
:
:
expm1
CallExpm1
-
DBL_MAX
+
104
.
0
4
)
DEFINE_MATH_TEST
(
Log
std
:
:
log
CallLog
+
FLT_MIN
+
FLT_MAX
1
std
:
:
log
CallLog
+
DBL_MIN
+
DBL_MAX
1
)
DEFINE_MATH_TEST
(
Log10
std
:
:
log10
CallLog10
+
FLT_MIN
+
FLT_MAX
2
std
:
:
log10
CallLog10
+
DBL_MIN
+
DBL_MAX
2
)
DEFINE_MATH_TEST
(
Log1p
std
:
:
log1p
CallLog1p
+
0
.
0f
+
1e37f
3
std
:
:
log1p
CallLog1p
+
0
.
0
+
DBL_MAX
2
)
DEFINE_MATH_TEST
(
Log2
std
:
:
log2
CallLog2
+
FLT_MIN
+
FLT_MAX
2
std
:
:
log2
CallLog2
+
DBL_MIN
+
DBL_MAX
2
)
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
hwy
{
namespace
{
HWY_BEFORE_TEST
(
HwyMathTest
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMathTest
TestAllExp
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMathTest
TestAllExp2
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMathTest
TestAllExpm1
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMathTest
TestAllLog
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMathTest
TestAllLog10
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMathTest
TestAllLog1p
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMathTest
TestAllLog2
)
;
HWY_AFTER_TEST
(
)
;
}
}
HWY_TEST_MAIN
(
)
;
#
endif
