#
include
<
algorithm
>
#
include
<
vector
>
#
include
"
hwy
/
aligned_allocator
.
h
"
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
print
.
h
"
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
hwy
/
contrib
/
algo
/
find_test
.
cc
"
#
include
"
hwy
/
foreach_target
.
h
"
#
include
"
hwy
/
contrib
/
algo
/
find
-
inl
.
h
"
#
include
"
hwy
/
tests
/
test_util
-
inl
.
h
"
#
if
__cplusplus
<
201402L
#
define
HWY_GENERIC_LAMBDA
0
#
else
#
define
HWY_GENERIC_LAMBDA
1
#
endif
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
template
<
typename
T
>
T
Random
(
RandomState
&
rng
)
{
const
int32_t
bits
=
static_cast
<
int32_t
>
(
Random32
(
&
rng
)
)
&
1023
;
const
double
val
=
(
bits
-
512
)
/
64
.
0
;
return
static_cast
<
T
>
(
HWY_MAX
(
hwy
:
:
LowestValue
<
T
>
(
)
val
)
)
;
}
#
if
!
HWY_GENERIC_LAMBDA
class
GreaterThan
{
public
:
GreaterThan
(
int
val
)
:
val_
(
val
)
{
}
template
<
class
D
class
V
>
Mask
<
D
>
operator
(
)
(
D
d
V
v
)
const
{
return
Gt
(
v
Set
(
d
static_cast
<
TFromD
<
D
>
>
(
val_
)
)
)
;
}
private
:
int
val_
;
}
;
#
endif
template
<
class
Test
>
struct
ForeachCountAndMisalign
{
template
<
typename
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
const
{
RandomState
rng
;
const
size_t
N
=
Lanes
(
d
)
;
const
size_t
misalignments
[
3
]
=
{
0
N
/
4
3
*
N
/
5
}
;
std
:
:
vector
<
size_t
>
counts
(
AdjustedReps
(
512
)
)
;
for
(
size_t
&
count
:
counts
)
{
count
=
static_cast
<
size_t
>
(
rng
(
)
)
%
(
16
*
N
+
1
)
;
}
counts
[
0
]
=
0
;
for
(
size_t
count
:
counts
)
{
for
(
size_t
m
:
misalignments
)
{
Test
(
)
(
d
count
m
rng
)
;
}
}
}
}
;
struct
TestFind
{
template
<
class
D
>
void
operator
(
)
(
D
d
size_t
count
size_t
misalign
RandomState
&
rng
)
{
using
T
=
TFromD
<
D
>
;
AlignedFreeUniquePtr
<
T
[
]
>
storage
=
AllocateAligned
<
T
>
(
HWY_MAX
(
1
misalign
+
count
)
)
;
T
*
in
=
storage
.
get
(
)
+
misalign
;
for
(
size_t
i
=
0
;
i
<
count
;
+
+
i
)
{
in
[
i
]
=
Random
<
T
>
(
rng
)
;
}
for
(
size_t
pos
=
0
;
pos
<
count
;
+
+
pos
)
{
const
size_t
actual
=
Find
(
d
in
[
pos
]
in
count
)
;
if
(
!
IsEqual
(
in
[
pos
]
in
[
actual
]
)
)
{
fprintf
(
stderr
"
%
s
count
%
d
found
%
.
15f
at
%
d
but
wanted
%
.
15f
\
n
"
hwy
:
:
TypeName
(
T
(
)
Lanes
(
d
)
)
.
c_str
(
)
static_cast
<
int
>
(
count
)
static_cast
<
double
>
(
in
[
actual
]
)
static_cast
<
int
>
(
actual
)
static_cast
<
double
>
(
in
[
pos
]
)
)
;
HWY_ASSERT
(
false
)
;
}
for
(
size_t
i
=
0
;
i
<
actual
;
+
+
i
)
{
if
(
IsEqual
(
in
[
i
]
in
[
pos
]
)
)
{
fprintf
(
stderr
"
%
s
count
%
d
found
%
f
at
%
d
but
Find
returned
%
d
\
n
"
hwy
:
:
TypeName
(
T
(
)
Lanes
(
d
)
)
.
c_str
(
)
static_cast
<
int
>
(
count
)
static_cast
<
double
>
(
in
[
i
]
)
static_cast
<
int
>
(
i
)
static_cast
<
int
>
(
actual
)
)
;
HWY_ASSERT
(
false
)
;
}
}
}
HWY_ASSERT_EQ
(
count
Find
(
d
T
{
9
}
in
count
)
)
;
HWY_ASSERT_EQ
(
count
Find
(
d
static_cast
<
T
>
(
-
9
)
in
count
)
)
;
}
}
;
void
TestAllFind
(
)
{
ForAllTypes
(
ForPartialVectors
<
ForeachCountAndMisalign
<
TestFind
>
>
(
)
)
;
}
struct
TestFindIf
{
template
<
class
D
>
void
operator
(
)
(
D
d
size_t
count
size_t
misalign
RandomState
&
rng
)
{
using
T
=
TFromD
<
D
>
;
using
TI
=
MakeSigned
<
T
>
;
AlignedFreeUniquePtr
<
T
[
]
>
storage
=
AllocateAligned
<
T
>
(
HWY_MAX
(
1
misalign
+
count
)
)
;
T
*
in
=
storage
.
get
(
)
+
misalign
;
for
(
size_t
i
=
0
;
i
<
count
;
+
+
i
)
{
in
[
i
]
=
Random
<
T
>
(
rng
)
;
HWY_ASSERT
(
in
[
i
]
<
8
)
;
HWY_ASSERT
(
!
hwy
:
:
IsSigned
<
T
>
(
)
|
|
static_cast
<
TI
>
(
in
[
i
]
)
>
=
-
8
)
;
}
bool
found_any
=
false
;
bool
not_found_any
=
false
;
const
int
min_val
=
IsSigned
<
T
>
(
)
?
-
9
:
0
;
for
(
int
val
=
min_val
;
val
<
=
9
;
+
+
val
)
{
#
if
HWY_GENERIC_LAMBDA
const
auto
greater
=
[
val
]
(
const
auto
d
const
auto
v
)
HWY_ATTR
{
return
Gt
(
v
Set
(
d
static_cast
<
T
>
(
val
)
)
)
;
}
;
#
else
const
GreaterThan
greater
(
val
)
;
#
endif
const
size_t
actual
=
FindIf
(
d
in
count
greater
)
;
found_any
|
=
actual
<
count
;
not_found_any
|
=
actual
=
=
count
;
const
auto
pos
=
std
:
:
find_if
(
in
in
+
count
[
val
]
(
T
x
)
{
return
x
>
static_cast
<
T
>
(
val
)
;
}
)
;
const
size_t
expected
=
static_cast
<
size_t
>
(
pos
-
in
)
;
if
(
expected
!
=
actual
)
{
fprintf
(
stderr
"
%
s
count
%
d
val
%
d
expected
%
d
actual
%
d
\
n
"
hwy
:
:
TypeName
(
T
(
)
Lanes
(
d
)
)
.
c_str
(
)
static_cast
<
int
>
(
count
)
val
static_cast
<
int
>
(
expected
)
static_cast
<
int
>
(
actual
)
)
;
hwy
:
:
detail
:
:
PrintArray
(
hwy
:
:
detail
:
:
MakeTypeInfo
<
T
>
(
)
"
in
"
in
count
0
count
)
;
HWY_ASSERT
(
false
)
;
}
}
HWY_ASSERT
(
not_found_any
)
;
if
(
count
!
=
0
&
&
in
[
0
]
!
=
0
)
{
HWY_ASSERT
(
found_any
)
;
}
}
}
;
void
TestAllFindIf
(
)
{
ForAllTypes
(
ForPartialVectors
<
ForeachCountAndMisalign
<
TestFindIf
>
>
(
)
)
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
hwy
{
HWY_BEFORE_TEST
(
FindTest
)
;
HWY_EXPORT_AND_TEST_P
(
FindTest
TestAllFind
)
;
HWY_EXPORT_AND_TEST_P
(
FindTest
TestAllFindIf
)
;
}
#
endif
