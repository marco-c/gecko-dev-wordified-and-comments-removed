#
if
defined
(
HIGHWAY_HWY_CONTRIB_ALGO_TRANSFORM_INL_H_
)
=
=
\
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HIGHWAY_HWY_CONTRIB_ALGO_TRANSFORM_INL_H_
#
undef
HIGHWAY_HWY_CONTRIB_ALGO_TRANSFORM_INL_H_
#
else
#
define
HIGHWAY_HWY_CONTRIB_ALGO_TRANSFORM_INL_H_
#
endif
#
include
<
stddef
.
h
>
#
include
"
hwy
/
highway
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
template
<
class
D
class
Func
typename
T
=
TFromD
<
D
>
>
void
Generate
(
D
d
T
*
HWY_RESTRICT
out
size_t
count
const
Func
&
func
)
{
const
RebindToUnsigned
<
D
>
du
;
using
TU
=
TFromD
<
decltype
(
du
)
>
;
const
size_t
N
=
Lanes
(
d
)
;
size_t
idx
=
0
;
Vec
<
decltype
(
du
)
>
vidx
=
Iota
(
du
0
)
;
if
(
count
>
=
N
)
{
for
(
;
idx
<
=
count
-
N
;
idx
+
=
N
)
{
StoreU
(
func
(
d
vidx
)
d
out
+
idx
)
;
vidx
=
Add
(
vidx
Set
(
du
static_cast
<
TU
>
(
N
)
)
)
;
}
}
if
(
HWY_UNLIKELY
(
idx
=
=
count
)
)
return
;
const
size_t
remaining
=
count
-
idx
;
HWY_DASSERT
(
0
!
=
remaining
&
&
remaining
<
N
)
;
StoreN
(
func
(
d
vidx
)
d
out
+
idx
remaining
)
;
}
template
<
class
D
class
Func
typename
T
=
TFromD
<
D
>
>
void
Foreach
(
D
d
const
T
*
HWY_RESTRICT
in
const
size_t
count
const
Vec
<
D
>
no
const
Func
&
func
)
{
const
size_t
N
=
Lanes
(
d
)
;
size_t
idx
=
0
;
if
(
count
>
=
N
)
{
for
(
;
idx
<
=
count
-
N
;
idx
+
=
N
)
{
const
Vec
<
D
>
v
=
LoadU
(
d
in
+
idx
)
;
func
(
d
v
)
;
}
}
if
(
HWY_UNLIKELY
(
idx
=
=
count
)
)
return
;
const
size_t
remaining
=
count
-
idx
;
HWY_DASSERT
(
0
!
=
remaining
&
&
remaining
<
N
)
;
const
Vec
<
D
>
v
=
LoadNOr
(
no
d
in
+
idx
remaining
)
;
func
(
d
v
)
;
}
template
<
class
D
class
Func
typename
T
=
TFromD
<
D
>
>
void
Transform
(
D
d
T
*
HWY_RESTRICT
inout
size_t
count
const
Func
&
func
)
{
const
size_t
N
=
Lanes
(
d
)
;
size_t
idx
=
0
;
if
(
count
>
=
N
)
{
for
(
;
idx
<
=
count
-
N
;
idx
+
=
N
)
{
const
Vec
<
D
>
v
=
LoadU
(
d
inout
+
idx
)
;
StoreU
(
func
(
d
v
)
d
inout
+
idx
)
;
}
}
if
(
HWY_UNLIKELY
(
idx
=
=
count
)
)
return
;
const
size_t
remaining
=
count
-
idx
;
HWY_DASSERT
(
0
!
=
remaining
&
&
remaining
<
N
)
;
const
Vec
<
D
>
v
=
LoadN
(
d
inout
+
idx
remaining
)
;
StoreN
(
func
(
d
v
)
d
inout
+
idx
remaining
)
;
}
template
<
class
D
class
Func
typename
T
=
TFromD
<
D
>
>
void
Transform1
(
D
d
T
*
HWY_RESTRICT
inout
size_t
count
const
T
*
HWY_RESTRICT
in1
const
Func
&
func
)
{
const
size_t
N
=
Lanes
(
d
)
;
size_t
idx
=
0
;
if
(
count
>
=
N
)
{
for
(
;
idx
<
=
count
-
N
;
idx
+
=
N
)
{
const
Vec
<
D
>
v
=
LoadU
(
d
inout
+
idx
)
;
const
Vec
<
D
>
v1
=
LoadU
(
d
in1
+
idx
)
;
StoreU
(
func
(
d
v
v1
)
d
inout
+
idx
)
;
}
}
if
(
HWY_UNLIKELY
(
idx
=
=
count
)
)
return
;
const
size_t
remaining
=
count
-
idx
;
HWY_DASSERT
(
0
!
=
remaining
&
&
remaining
<
N
)
;
const
Vec
<
D
>
v
=
LoadN
(
d
inout
+
idx
remaining
)
;
const
Vec
<
D
>
v1
=
LoadN
(
d
in1
+
idx
remaining
)
;
StoreN
(
func
(
d
v
v1
)
d
inout
+
idx
remaining
)
;
}
template
<
class
D
class
Func
typename
T
=
TFromD
<
D
>
>
void
Transform2
(
D
d
T
*
HWY_RESTRICT
inout
size_t
count
const
T
*
HWY_RESTRICT
in1
const
T
*
HWY_RESTRICT
in2
const
Func
&
func
)
{
const
size_t
N
=
Lanes
(
d
)
;
size_t
idx
=
0
;
if
(
count
>
=
N
)
{
for
(
;
idx
<
=
count
-
N
;
idx
+
=
N
)
{
const
Vec
<
D
>
v
=
LoadU
(
d
inout
+
idx
)
;
const
Vec
<
D
>
v1
=
LoadU
(
d
in1
+
idx
)
;
const
Vec
<
D
>
v2
=
LoadU
(
d
in2
+
idx
)
;
StoreU
(
func
(
d
v
v1
v2
)
d
inout
+
idx
)
;
}
}
if
(
HWY_UNLIKELY
(
idx
=
=
count
)
)
return
;
const
size_t
remaining
=
count
-
idx
;
HWY_DASSERT
(
0
!
=
remaining
&
&
remaining
<
N
)
;
const
Vec
<
D
>
v
=
LoadN
(
d
inout
+
idx
remaining
)
;
const
Vec
<
D
>
v1
=
LoadN
(
d
in1
+
idx
remaining
)
;
const
Vec
<
D
>
v2
=
LoadN
(
d
in2
+
idx
remaining
)
;
StoreN
(
func
(
d
v
v1
v2
)
d
inout
+
idx
remaining
)
;
}
template
<
class
D
typename
T
=
TFromD
<
D
>
>
void
Replace
(
D
d
T
*
HWY_RESTRICT
inout
size_t
count
T
new_t
T
old_t
)
{
const
size_t
N
=
Lanes
(
d
)
;
const
Vec
<
D
>
old_v
=
Set
(
d
old_t
)
;
const
Vec
<
D
>
new_v
=
Set
(
d
new_t
)
;
size_t
idx
=
0
;
if
(
count
>
=
N
)
{
for
(
;
idx
<
=
count
-
N
;
idx
+
=
N
)
{
Vec
<
D
>
v
=
LoadU
(
d
inout
+
idx
)
;
StoreU
(
IfThenElse
(
Eq
(
v
old_v
)
new_v
v
)
d
inout
+
idx
)
;
}
}
if
(
HWY_UNLIKELY
(
idx
=
=
count
)
)
return
;
const
size_t
remaining
=
count
-
idx
;
HWY_DASSERT
(
0
!
=
remaining
&
&
remaining
<
N
)
;
const
Vec
<
D
>
v
=
LoadN
(
d
inout
+
idx
remaining
)
;
StoreN
(
IfThenElse
(
Eq
(
v
old_v
)
new_v
v
)
d
inout
+
idx
remaining
)
;
}
template
<
class
D
class
Func
typename
T
=
TFromD
<
D
>
>
void
ReplaceIf
(
D
d
T
*
HWY_RESTRICT
inout
size_t
count
T
new_t
const
Func
&
func
)
{
const
size_t
N
=
Lanes
(
d
)
;
const
Vec
<
D
>
new_v
=
Set
(
d
new_t
)
;
size_t
idx
=
0
;
if
(
count
>
=
N
)
{
for
(
;
idx
<
=
count
-
N
;
idx
+
=
N
)
{
Vec
<
D
>
v
=
LoadU
(
d
inout
+
idx
)
;
StoreU
(
IfThenElse
(
func
(
d
v
)
new_v
v
)
d
inout
+
idx
)
;
}
}
if
(
HWY_UNLIKELY
(
idx
=
=
count
)
)
return
;
const
size_t
remaining
=
count
-
idx
;
HWY_DASSERT
(
0
!
=
remaining
&
&
remaining
<
N
)
;
const
Vec
<
D
>
v
=
LoadN
(
d
inout
+
idx
remaining
)
;
StoreN
(
IfThenElse
(
func
(
d
v
)
new_v
v
)
d
inout
+
idx
remaining
)
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
