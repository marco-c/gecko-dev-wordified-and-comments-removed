#
include
"
hwy
/
profiler
.
h
"
#
include
"
hwy
/
highway_export
.
h
"
#
if
PROFILER_ENABLED
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
robust_statistics
.
h
"
#
include
"
hwy
/
timer
.
h
"
#
endif
namespace
hwy
{
#
if
PROFILER_ENABLED
constexpr
bool
kPrintOverhead
=
true
;
thread_local
size_t
Profiler
:
:
s_thread
=
~
size_t
{
0
}
;
std
:
:
atomic
<
size_t
>
Profiler
:
:
s_num_threads
{
0
}
;
static
uint64_t
DetectSelfOverhead
(
Profiler
&
profiler
size_t
thread
)
{
profiler
:
:
Results
results
;
const
size_t
kNumSamples
=
25
;
uint32_t
samples
[
kNumSamples
]
;
for
(
size_t
idx_sample
=
0
;
idx_sample
<
kNumSamples
;
+
+
idx_sample
)
{
const
size_t
kNumDurations
=
700
;
uint32_t
durations
[
kNumDurations
]
;
for
(
size_t
idx_duration
=
0
;
idx_duration
<
kNumDurations
;
+
+
idx_duration
)
{
{
static
const
profiler
:
:
ZoneHandle
zone
=
profiler
.
AddZone
(
"
DetectSelfOverhead
"
)
;
PROFILER_ZONE3
(
profiler
0
zone
)
;
}
durations
[
idx_duration
]
=
static_cast
<
uint32_t
>
(
profiler
.
GetThread
(
thread
)
.
GetFirstDurationAndReset
(
thread
profiler
.
Accumulators
(
)
)
)
;
}
samples
[
idx_sample
]
=
robust_statistics
:
:
Mode
(
durations
kNumDurations
)
;
}
return
robust_statistics
:
:
Mode
(
samples
kNumSamples
)
;
}
static
uint64_t
DetectChildOverhead
(
Profiler
&
profiler
size_t
thread
uint64_t
self_overhead
)
{
const
size_t
kMaxSamples
=
30
;
uint32_t
samples
[
kMaxSamples
]
;
size_t
num_samples
=
0
;
for
(
size_t
s
=
0
;
s
<
2
*
kMaxSamples
&
&
num_samples
<
kMaxSamples
;
+
+
s
)
{
const
size_t
kNumDurations
=
50
;
uint32_t
durations
[
kNumDurations
]
;
for
(
size_t
d
=
0
;
d
<
kNumDurations
;
+
+
d
)
{
constexpr
size_t
kReps
=
500
;
HWY_FENCE
;
const
uint64_t
t0
=
timer
:
:
Start
(
)
;
for
(
size_t
r
=
0
;
r
<
kReps
;
+
+
r
)
{
static
const
profiler
:
:
ZoneHandle
zone
=
profiler
.
AddZone
(
"
DetectChildOverhead
"
)
;
PROFILER_ZONE3
(
profiler
0
zone
)
;
}
const
uint64_t
t1
=
timer
:
:
Stop
(
)
;
HWY_FENCE
;
(
void
)
profiler
.
GetThread
(
thread
)
.
GetFirstDurationAndReset
(
thread
profiler
.
Accumulators
(
)
)
;
const
uint64_t
avg_duration
=
(
t1
-
t0
+
kReps
/
2
)
/
kReps
;
durations
[
d
]
=
static_cast
<
uint32_t
>
(
profiler
:
:
PerThread
:
:
ClampedSubtract
(
avg_duration
self_overhead
)
)
;
}
samples
[
num_samples
]
=
robust_statistics
:
:
Mode
(
durations
kNumDurations
)
;
num_samples
+
=
(
samples
[
num_samples
]
!
=
0
)
;
}
return
num_samples
=
=
0
?
0
:
robust_statistics
:
:
Mode
(
samples
num_samples
)
;
}
Profiler
:
:
Profiler
(
)
{
const
uint64_t
t0
=
timer
:
:
Start
(
)
;
InitThread
(
)
;
char
cpu
[
100
]
;
if
(
HWY_UNLIKELY
(
!
platform
:
:
HaveTimerStop
(
cpu
)
)
)
{
HWY_ABORT
(
"
CPU
%
s
is
too
old
for
PROFILER_ENABLED
=
1
exiting
"
cpu
)
;
}
profiler
:
:
Overheads
overheads
;
constexpr
size_t
kThread
=
0
;
overheads
.
self
=
DetectSelfOverhead
(
*
this
kThread
)
;
overheads
.
child
=
DetectChildOverhead
(
*
this
kThread
overheads
.
self
)
;
for
(
size_t
thread
=
0
;
thread
<
profiler
:
:
kMaxThreads
;
+
+
thread
)
{
threads_
[
thread
]
.
SetOverheads
(
overheads
)
;
}
HWY_IF_CONSTEXPR
(
kPrintOverhead
)
{
printf
(
"
Self
overhead
:
%
.
0f
;
child
:
%
.
0f
;
elapsed
%
.
1f
ms
\
n
"
static_cast
<
double
>
(
overheads
.
self
)
static_cast
<
double
>
(
overheads
.
child
)
static_cast
<
double
>
(
timer
:
:
Stop
(
)
-
t0
)
/
platform
:
:
InvariantTicksPerSecond
(
)
*
1E3
)
;
}
}
#
endif
HWY_DLLEXPORT
Profiler
&
Profiler
:
:
Get
(
)
{
static
Profiler
profiler
;
return
profiler
;
}
}
