#
include
"
hwy
/
targets
.
h
"
#
include
<
stdarg
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
hwy
/
highway
.
h
"
#
include
"
hwy
/
per_target
.
h
"
#
if
HWY_IS_ASAN
|
|
HWY_IS_MSAN
|
|
HWY_IS_TSAN
#
include
"
sanitizer
/
common_interface_defs
.
h
"
#
endif
#
if
HWY_ARCH_X86
#
include
<
xmmintrin
.
h
>
#
if
HWY_COMPILER_MSVC
#
include
<
intrin
.
h
>
#
else
#
include
<
cpuid
.
h
>
#
endif
#
elif
(
HWY_ARCH_ARM
|
|
HWY_ARCH_PPC
|
|
HWY_ARCH_S390X
)
&
&
HWY_OS_LINUX
#
ifndef
TOOLCHAIN_MISS_ASM_HWCAP_H
#
include
<
asm
/
hwcap
.
h
>
#
endif
#
ifndef
TOOLCHAIN_MISS_SYS_AUXV_H
#
include
<
sys
/
auxv
.
h
>
#
endif
#
endif
namespace
hwy
{
namespace
{
int64_t
supported_targets_for_test_
=
0
;
int64_t
supported_mask_
=
LimitsMax
<
int64_t
>
(
)
;
#
if
HWY_ARCH_X86
&
&
HWY_HAVE_RUNTIME_DISPATCH
namespace
x86
{
HWY_INLINE
void
Cpuid
(
const
uint32_t
level
const
uint32_t
count
uint32_t
*
HWY_RESTRICT
abcd
)
{
#
if
HWY_COMPILER_MSVC
int
regs
[
4
]
;
__cpuidex
(
regs
level
count
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
abcd
[
i
]
=
regs
[
i
]
;
}
#
else
uint32_t
a
;
uint32_t
b
;
uint32_t
c
;
uint32_t
d
;
__cpuid_count
(
level
count
a
b
c
d
)
;
abcd
[
0
]
=
a
;
abcd
[
1
]
=
b
;
abcd
[
2
]
=
c
;
abcd
[
3
]
=
d
;
#
endif
}
HWY_INLINE
bool
IsBitSet
(
const
uint32_t
reg
const
int
index
)
{
return
(
reg
&
(
1U
<
<
index
)
)
!
=
0
;
}
uint32_t
ReadXCR0
(
)
{
#
if
HWY_COMPILER_MSVC
return
static_cast
<
uint32_t
>
(
_xgetbv
(
0
)
)
;
#
else
uint32_t
xcr0
xcr0_high
;
const
uint32_t
index
=
0
;
asm
volatile
(
"
.
byte
0x0F
0x01
0xD0
"
:
"
=
a
"
(
xcr0
)
"
=
d
"
(
xcr0_high
)
:
"
c
"
(
index
)
)
;
return
xcr0
;
#
endif
}
bool
IsAMD
(
)
{
uint32_t
abcd
[
4
]
;
Cpuid
(
0
0
abcd
)
;
const
uint32_t
max_level
=
abcd
[
0
]
;
return
max_level
>
=
1
&
&
abcd
[
1
]
=
=
0x68747541
&
&
abcd
[
2
]
=
=
0x444d4163
&
&
abcd
[
3
]
=
=
0x69746e65
;
}
enum
class
FeatureIndex
:
uint32_t
{
kSSE
=
0
kSSE2
kSSE3
kSSSE3
kSSE41
kSSE42
kCLMUL
kAES
kAVX
kAVX2
kF16C
kFMA
kLZCNT
kBMI
kBMI2
kAVX512F
kAVX512VL
kAVX512CD
kAVX512DQ
kAVX512BW
kAVX512FP16
kVNNI
kVPCLMULQDQ
kVBMI
kVBMI2
kVAES
kPOPCNTDQ
kBITALG
kGFNI
kSentinel
}
;
static_assert
(
static_cast
<
size_t
>
(
FeatureIndex
:
:
kSentinel
)
<
64
"
Too
many
bits
for
u64
"
)
;
HWY_INLINE
constexpr
uint64_t
Bit
(
FeatureIndex
index
)
{
return
1ull
<
<
static_cast
<
size_t
>
(
index
)
;
}
uint64_t
FlagsFromCPUID
(
)
{
uint64_t
flags
=
0
;
uint32_t
abcd
[
4
]
;
Cpuid
(
0
0
abcd
)
;
const
uint32_t
max_level
=
abcd
[
0
]
;
Cpuid
(
1
0
abcd
)
;
flags
|
=
IsBitSet
(
abcd
[
3
]
25
)
?
Bit
(
FeatureIndex
:
:
kSSE
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
3
]
26
)
?
Bit
(
FeatureIndex
:
:
kSSE2
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
0
)
?
Bit
(
FeatureIndex
:
:
kSSE3
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
1
)
?
Bit
(
FeatureIndex
:
:
kCLMUL
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
9
)
?
Bit
(
FeatureIndex
:
:
kSSSE3
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
12
)
?
Bit
(
FeatureIndex
:
:
kFMA
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
19
)
?
Bit
(
FeatureIndex
:
:
kSSE41
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
20
)
?
Bit
(
FeatureIndex
:
:
kSSE42
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
25
)
?
Bit
(
FeatureIndex
:
:
kAES
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
28
)
?
Bit
(
FeatureIndex
:
:
kAVX
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
29
)
?
Bit
(
FeatureIndex
:
:
kF16C
)
:
0
;
Cpuid
(
0x80000001U
0
abcd
)
;
flags
|
=
IsBitSet
(
abcd
[
2
]
5
)
?
Bit
(
FeatureIndex
:
:
kLZCNT
)
:
0
;
if
(
max_level
>
=
7
)
{
Cpuid
(
7
0
abcd
)
;
flags
|
=
IsBitSet
(
abcd
[
1
]
3
)
?
Bit
(
FeatureIndex
:
:
kBMI
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
1
]
5
)
?
Bit
(
FeatureIndex
:
:
kAVX2
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
1
]
8
)
?
Bit
(
FeatureIndex
:
:
kBMI2
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
1
]
16
)
?
Bit
(
FeatureIndex
:
:
kAVX512F
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
1
]
17
)
?
Bit
(
FeatureIndex
:
:
kAVX512DQ
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
1
]
28
)
?
Bit
(
FeatureIndex
:
:
kAVX512CD
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
1
]
30
)
?
Bit
(
FeatureIndex
:
:
kAVX512BW
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
1
]
31
)
?
Bit
(
FeatureIndex
:
:
kAVX512VL
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
1
)
?
Bit
(
FeatureIndex
:
:
kVBMI
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
6
)
?
Bit
(
FeatureIndex
:
:
kVBMI2
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
8
)
?
Bit
(
FeatureIndex
:
:
kGFNI
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
9
)
?
Bit
(
FeatureIndex
:
:
kVAES
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
10
)
?
Bit
(
FeatureIndex
:
:
kVPCLMULQDQ
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
11
)
?
Bit
(
FeatureIndex
:
:
kVNNI
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
12
)
?
Bit
(
FeatureIndex
:
:
kBITALG
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
2
]
14
)
?
Bit
(
FeatureIndex
:
:
kPOPCNTDQ
)
:
0
;
flags
|
=
IsBitSet
(
abcd
[
3
]
23
)
?
Bit
(
FeatureIndex
:
:
kAVX512FP16
)
:
0
;
}
return
flags
;
}
constexpr
uint64_t
kGroupSSE2
=
Bit
(
FeatureIndex
:
:
kSSE
)
|
Bit
(
FeatureIndex
:
:
kSSE2
)
;
constexpr
uint64_t
kGroupSSSE3
=
Bit
(
FeatureIndex
:
:
kSSE3
)
|
Bit
(
FeatureIndex
:
:
kSSSE3
)
|
kGroupSSE2
;
constexpr
uint64_t
kGroupSSE4
=
Bit
(
FeatureIndex
:
:
kSSE41
)
|
Bit
(
FeatureIndex
:
:
kSSE42
)
|
Bit
(
FeatureIndex
:
:
kCLMUL
)
|
Bit
(
FeatureIndex
:
:
kAES
)
|
kGroupSSSE3
;
#
ifdef
HWY_DISABLE_BMI2_FMA
constexpr
uint64_t
kGroupBMI2_FMA
=
0
;
#
else
constexpr
uint64_t
kGroupBMI2_FMA
=
Bit
(
FeatureIndex
:
:
kBMI
)
|
Bit
(
FeatureIndex
:
:
kBMI2
)
|
Bit
(
FeatureIndex
:
:
kFMA
)
;
#
endif
#
ifdef
HWY_DISABLE_F16C
constexpr
uint64_t
kGroupF16C
=
0
;
#
else
constexpr
uint64_t
kGroupF16C
=
Bit
(
FeatureIndex
:
:
kF16C
)
;
#
endif
constexpr
uint64_t
kGroupAVX2
=
Bit
(
FeatureIndex
:
:
kAVX
)
|
Bit
(
FeatureIndex
:
:
kAVX2
)
|
Bit
(
FeatureIndex
:
:
kLZCNT
)
|
kGroupBMI2_FMA
|
kGroupF16C
|
kGroupSSE4
;
constexpr
uint64_t
kGroupAVX3
=
Bit
(
FeatureIndex
:
:
kAVX512F
)
|
Bit
(
FeatureIndex
:
:
kAVX512VL
)
|
Bit
(
FeatureIndex
:
:
kAVX512DQ
)
|
Bit
(
FeatureIndex
:
:
kAVX512BW
)
|
Bit
(
FeatureIndex
:
:
kAVX512CD
)
|
kGroupAVX2
;
constexpr
uint64_t
kGroupAVX3_DL
=
Bit
(
FeatureIndex
:
:
kVNNI
)
|
Bit
(
FeatureIndex
:
:
kVPCLMULQDQ
)
|
Bit
(
FeatureIndex
:
:
kVBMI
)
|
Bit
(
FeatureIndex
:
:
kVBMI2
)
|
Bit
(
FeatureIndex
:
:
kVAES
)
|
Bit
(
FeatureIndex
:
:
kPOPCNTDQ
)
|
Bit
(
FeatureIndex
:
:
kBITALG
)
|
Bit
(
FeatureIndex
:
:
kGFNI
)
|
kGroupAVX3
;
constexpr
uint64_t
kGroupAVX3_SPR
=
Bit
(
FeatureIndex
:
:
kAVX512FP16
)
|
kGroupAVX3_DL
;
int64_t
DetectTargets
(
)
{
int64_t
bits
=
0
;
#
if
HWY_ARCH_X86_64
bits
|
=
HWY_SSE2
;
#
endif
const
uint64_t
flags
=
FlagsFromCPUID
(
)
;
if
(
(
flags
&
kGroupAVX3_SPR
)
=
=
kGroupAVX3_SPR
)
{
bits
|
=
HWY_AVX3_SPR
;
}
if
(
(
flags
&
kGroupAVX3_DL
)
=
=
kGroupAVX3_DL
)
{
bits
|
=
HWY_AVX3_DL
;
}
if
(
(
flags
&
kGroupAVX3
)
=
=
kGroupAVX3
)
{
bits
|
=
HWY_AVX3
;
}
if
(
(
flags
&
kGroupAVX2
)
=
=
kGroupAVX2
)
{
bits
|
=
HWY_AVX2
;
}
if
(
(
flags
&
kGroupSSE4
)
=
=
kGroupSSE4
)
{
bits
|
=
HWY_SSE4
;
}
if
(
(
flags
&
kGroupSSSE3
)
=
=
kGroupSSSE3
)
{
bits
|
=
HWY_SSSE3
;
}
#
if
HWY_ARCH_X86_32
if
(
(
flags
&
kGroupSSE2
)
=
=
kGroupSSE2
)
{
bits
|
=
HWY_SSE2
;
}
#
endif
uint32_t
abcd
[
4
]
;
Cpuid
(
1
0
abcd
)
;
const
bool
has_osxsave
=
IsBitSet
(
abcd
[
2
]
27
)
;
if
(
has_osxsave
)
{
const
uint32_t
xcr0
=
ReadXCR0
(
)
;
const
int64_t
min_avx3
=
HWY_AVX3
|
HWY_AVX3_DL
|
HWY_AVX3_SPR
;
const
int64_t
min_avx2
=
HWY_AVX2
|
min_avx3
;
if
(
!
IsBitSet
(
xcr0
1
)
)
{
#
if
HWY_ARCH_X86_64
bits
&
=
~
min_avx2
;
#
else
bits
&
=
~
(
HWY_SSE2
|
HWY_SSSE3
|
HWY_SSE4
|
min_avx2
)
;
#
endif
}
if
(
!
IsBitSet
(
xcr0
2
)
)
{
bits
&
=
~
min_avx2
;
}
if
(
!
IsBitSet
(
xcr0
5
)
|
|
!
IsBitSet
(
xcr0
6
)
|
|
!
IsBitSet
(
xcr0
7
)
)
{
bits
&
=
~
min_avx3
;
}
}
if
(
(
bits
&
HWY_AVX3_DL
)
&
&
IsAMD
(
)
)
{
bits
|
=
HWY_AVX3_ZEN4
;
}
return
bits
;
}
}
#
elif
HWY_ARCH_ARM
&
&
HWY_HAVE_RUNTIME_DISPATCH
namespace
arm
{
int64_t
DetectTargets
(
)
{
int64_t
bits
=
0
;
using
CapBits
=
unsigned
long
;
const
CapBits
hw
=
getauxval
(
AT_HWCAP
)
;
(
void
)
hw
;
#
if
HWY_ARCH_ARM_A64
bits
|
=
HWY_NEON_WITHOUT_AES
;
#
if
defined
(
HWCAP_AES
)
if
(
hw
&
HWCAP_AES
)
{
bits
|
=
HWY_NEON
;
}
#
endif
#
if
defined
(
HWCAP_SVE
)
if
(
hw
&
HWCAP_SVE
)
{
bits
|
=
HWY_SVE
;
}
#
endif
#
ifndef
HWCAP2_SVE2
#
define
HWCAP2_SVE2
(
1
<
<
1
)
#
endif
#
ifndef
HWCAP2_SVEAES
#
define
HWCAP2_SVEAES
(
1
<
<
2
)
#
endif
const
CapBits
hw2
=
getauxval
(
AT_HWCAP2
)
;
if
(
(
hw2
&
HWCAP2_SVE2
)
&
&
(
hw2
&
HWCAP2_SVEAES
)
)
{
bits
|
=
HWY_SVE2
;
}
#
else
#
if
defined
(
HWCAP_NEON
)
&
&
defined
(
HWCAP_VFPv4
)
if
(
(
hw
&
HWCAP_NEON
)
&
&
(
hw
&
HWCAP_VFPv4
)
)
{
bits
|
=
HWY_NEON_WITHOUT_AES
;
}
#
endif
#
endif
return
bits
;
}
}
#
elif
HWY_ARCH_PPC
&
&
HWY_HAVE_RUNTIME_DISPATCH
namespace
ppc
{
#
ifndef
PPC_FEATURE_HAS_ALTIVEC
#
define
PPC_FEATURE_HAS_ALTIVEC
0x10000000
#
endif
#
ifndef
PPC_FEATURE_HAS_VSX
#
define
PPC_FEATURE_HAS_VSX
0x00000080
#
endif
#
ifndef
PPC_FEATURE2_ARCH_2_07
#
define
PPC_FEATURE2_ARCH_2_07
0x80000000
#
endif
#
ifndef
PPC_FEATURE2_VEC_CRYPTO
#
define
PPC_FEATURE2_VEC_CRYPTO
0x02000000
#
endif
#
ifndef
PPC_FEATURE2_ARCH_3_00
#
define
PPC_FEATURE2_ARCH_3_00
0x00800000
#
endif
#
ifndef
PPC_FEATURE2_ARCH_3_1
#
define
PPC_FEATURE2_ARCH_3_1
0x00040000
#
endif
using
CapBits
=
unsigned
long
;
constexpr
CapBits
kGroupVSX
=
PPC_FEATURE_HAS_ALTIVEC
|
PPC_FEATURE_HAS_VSX
;
#
if
defined
(
HWY_DISABLE_PPC8_CRYPTO
)
constexpr
CapBits
kGroupPPC8
=
PPC_FEATURE2_ARCH_2_07
;
#
else
constexpr
CapBits
kGroupPPC8
=
PPC_FEATURE2_ARCH_2_07
|
PPC_FEATURE2_VEC_CRYPTO
;
#
endif
constexpr
CapBits
kGroupPPC9
=
kGroupPPC8
|
PPC_FEATURE2_ARCH_3_00
;
constexpr
CapBits
kGroupPPC10
=
kGroupPPC9
|
PPC_FEATURE2_ARCH_3_1
;
int64_t
DetectTargets
(
)
{
int64_t
bits
=
0
;
#
if
defined
(
AT_HWCAP
)
&
&
defined
(
AT_HWCAP2
)
const
CapBits
hw
=
getauxval
(
AT_HWCAP
)
;
if
(
(
hw
&
kGroupVSX
)
=
=
kGroupVSX
)
{
const
CapBits
hw2
=
getauxval
(
AT_HWCAP2
)
;
if
(
(
hw2
&
kGroupPPC8
)
=
=
kGroupPPC8
)
{
bits
|
=
HWY_PPC8
;
}
if
(
(
hw2
&
kGroupPPC9
)
=
=
kGroupPPC9
)
{
bits
|
=
HWY_PPC9
;
}
if
(
(
hw2
&
kGroupPPC10
)
=
=
kGroupPPC10
)
{
bits
|
=
HWY_PPC10
;
}
}
#
endif
return
bits
;
}
}
#
elif
HWY_ARCH_S390X
&
&
HWY_HAVE_RUNTIME_DISPATCH
namespace
s390x
{
#
ifndef
HWCAP_S390_VX
#
define
HWCAP_S390_VX
2048
#
endif
#
ifndef
HWCAP_S390_VXE
#
define
HWCAP_S390_VXE
8192
#
endif
#
ifndef
HWCAP_S390_VXRS_EXT2
#
define
HWCAP_S390_VXRS_EXT2
32768
#
endif
using
CapBits
=
unsigned
long
;
constexpr
CapBits
kGroupZ14
=
HWCAP_S390_VX
|
HWCAP_S390_VXE
;
constexpr
CapBits
kGroupZ15
=
HWCAP_S390_VX
|
HWCAP_S390_VXE
|
HWCAP_S390_VXRS_EXT2
;
int64_t
DetectTargets
(
)
{
int64_t
bits
=
0
;
#
if
defined
(
AT_HWCAP
)
const
CapBits
hw
=
getauxval
(
AT_HWCAP
)
;
if
(
(
hw
&
kGroupZ14
)
=
=
kGroupZ14
)
{
bits
|
=
HWY_Z14
;
}
if
(
(
hw
&
kGroupZ15
)
=
=
kGroupZ15
)
{
bits
|
=
HWY_Z15
;
}
#
endif
return
bits
;
}
}
#
endif
int64_t
DetectTargets
(
)
{
int64_t
bits
=
HWY_SCALAR
|
HWY_EMU128
;
#
if
HWY_ARCH_X86
&
&
HWY_HAVE_RUNTIME_DISPATCH
bits
|
=
x86
:
:
DetectTargets
(
)
;
#
elif
HWY_ARCH_ARM
&
&
HWY_HAVE_RUNTIME_DISPATCH
bits
|
=
arm
:
:
DetectTargets
(
)
;
#
elif
HWY_ARCH_PPC
&
&
HWY_HAVE_RUNTIME_DISPATCH
bits
|
=
ppc
:
:
DetectTargets
(
)
;
#
elif
HWY_ARCH_S390X
&
&
HWY_HAVE_RUNTIME_DISPATCH
bits
|
=
s390x
:
:
DetectTargets
(
)
;
#
else
bits
|
=
HWY_ENABLED_BASELINE
;
#
endif
if
(
(
bits
&
HWY_ENABLED_BASELINE
)
!
=
HWY_ENABLED_BASELINE
)
{
const
uint64_t
bits_u
=
static_cast
<
uint64_t
>
(
bits
)
;
const
uint64_t
enabled
=
static_cast
<
uint64_t
>
(
HWY_ENABLED_BASELINE
)
;
fprintf
(
stderr
"
WARNING
:
CPU
supports
0x
%
08x
%
08x
software
requires
0x
%
08x
%
08x
\
n
"
static_cast
<
uint32_t
>
(
bits_u
>
>
32
)
static_cast
<
uint32_t
>
(
bits_u
&
0xFFFFFFFF
)
static_cast
<
uint32_t
>
(
enabled
>
>
32
)
static_cast
<
uint32_t
>
(
enabled
&
0xFFFFFFFF
)
)
;
}
return
bits
;
}
}
HWY_DLLEXPORT
HWY_NORETURN
void
HWY_FORMAT
(
3
4
)
Abort
(
const
char
*
file
int
line
const
char
*
format
.
.
.
)
{
char
buf
[
800
]
;
va_list
args
;
va_start
(
args
format
)
;
vsnprintf
(
buf
sizeof
(
buf
)
format
args
)
;
va_end
(
args
)
;
fprintf
(
stderr
"
Abort
at
%
s
:
%
d
:
%
s
\
n
"
file
line
buf
)
;
#
if
HWY_IS_ASAN
|
|
HWY_IS_MSAN
|
|
HWY_IS_TSAN
__sanitizer_print_stack_trace
(
)
;
#
endif
fflush
(
stderr
)
;
#
if
HWY_ARCH_RVV
exit
(
1
)
;
#
elif
HWY_IS_DEBUG_BUILD
&
&
!
HWY_COMPILER_MSVC
__builtin_trap
(
)
;
#
else
abort
(
)
;
#
endif
}
HWY_DLLEXPORT
void
DisableTargets
(
int64_t
disabled_targets
)
{
supported_mask_
=
static_cast
<
int64_t
>
(
~
disabled_targets
)
;
GetChosenTarget
(
)
.
DeInit
(
)
;
}
HWY_DLLEXPORT
void
SetSupportedTargetsForTest
(
int64_t
targets
)
{
supported_targets_for_test_
=
targets
;
GetChosenTarget
(
)
.
DeInit
(
)
;
}
HWY_DLLEXPORT
int64_t
SupportedTargets
(
)
{
int64_t
targets
=
supported_targets_for_test_
;
if
(
HWY_LIKELY
(
targets
=
=
0
)
)
{
targets
=
DetectTargets
(
)
;
GetChosenTarget
(
)
.
Update
(
targets
)
;
if
(
HWY_ARCH_ARM_A64
)
{
const
size_t
vec_bytes
=
VectorBytes
(
)
;
if
(
(
targets
&
HWY_SVE
)
&
&
vec_bytes
=
=
32
)
{
targets
=
static_cast
<
int64_t
>
(
targets
|
HWY_SVE_256
)
;
}
else
{
targets
=
static_cast
<
int64_t
>
(
targets
&
~
HWY_SVE_256
)
;
}
if
(
(
targets
&
HWY_SVE2
)
&
&
vec_bytes
=
=
16
)
{
targets
=
static_cast
<
int64_t
>
(
targets
|
HWY_SVE2_128
)
;
}
else
{
targets
=
static_cast
<
int64_t
>
(
targets
&
~
HWY_SVE2_128
)
;
}
}
}
targets
&
=
supported_mask_
;
return
targets
=
=
0
?
HWY_STATIC_TARGET
:
targets
;
}
HWY_DLLEXPORT
ChosenTarget
&
GetChosenTarget
(
)
{
static
ChosenTarget
chosen_target
;
return
chosen_target
;
}
}
