#
include
"
hwy
/
nanobenchmark
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
time
.
h
>
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
atomic
>
#
include
<
limits
>
#
include
<
numeric
>
#
include
<
random
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
hwy
/
base
.
h
"
#
if
HWY_ARCH_PPC
#
include
<
sys
/
platform
/
ppc
.
h
>
#
elif
HWY_ARCH_X86
#
if
HWY_COMPILER_MSVC
#
include
<
intrin
.
h
>
#
else
#
include
<
cpuid
.
h
>
#
endif
#
endif
namespace
hwy
{
namespace
platform
{
namespace
{
#
if
HWY_ARCH_X86
void
Cpuid
(
const
uint32_t
level
const
uint32_t
count
uint32_t
*
HWY_RESTRICT
abcd
)
{
#
if
HWY_COMPILER_MSVC
int
regs
[
4
]
;
__cpuidex
(
regs
level
count
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
abcd
[
i
]
=
regs
[
i
]
;
}
#
else
uint32_t
a
;
uint32_t
b
;
uint32_t
c
;
uint32_t
d
;
__cpuid_count
(
level
count
a
b
c
d
)
;
abcd
[
0
]
=
a
;
abcd
[
1
]
=
b
;
abcd
[
2
]
=
c
;
abcd
[
3
]
=
d
;
#
endif
}
std
:
:
string
BrandString
(
)
{
char
brand_string
[
49
]
;
std
:
:
array
<
uint32_t
4
>
abcd
;
Cpuid
(
0x80000000U
0
abcd
.
data
(
)
)
;
if
(
abcd
[
0
]
<
0x80000004U
)
{
return
std
:
:
string
(
)
;
}
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
Cpuid
(
static_cast
<
uint32_t
>
(
0x80000002U
+
i
)
0
abcd
.
data
(
)
)
;
memcpy
(
brand_string
+
i
*
16
abcd
.
data
(
)
sizeof
(
abcd
)
)
;
}
brand_string
[
48
]
=
0
;
return
brand_string
;
}
double
NominalClockRate
(
)
{
const
std
:
:
string
&
brand_string
=
BrandString
(
)
;
const
char
*
prefixes
[
3
]
=
{
"
MHz
"
"
GHz
"
"
THz
"
}
;
const
double
multipliers
[
3
]
=
{
1E6
1E9
1E12
}
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
const
size_t
pos_prefix
=
brand_string
.
find
(
prefixes
[
i
]
)
;
if
(
pos_prefix
!
=
std
:
:
string
:
:
npos
)
{
const
size_t
pos_space
=
brand_string
.
rfind
(
'
'
pos_prefix
-
1
)
;
if
(
pos_space
!
=
std
:
:
string
:
:
npos
)
{
const
std
:
:
string
digits
=
brand_string
.
substr
(
pos_space
+
1
pos_prefix
-
pos_space
-
1
)
;
return
std
:
:
stod
(
digits
)
*
multipliers
[
i
]
;
}
}
}
return
0
.
0
;
}
#
endif
}
double
InvariantTicksPerSecond
(
)
{
#
if
HWY_ARCH_PPC
return
__ppc_get_timebase_freq
(
)
;
#
elif
HWY_ARCH_X86
return
NominalClockRate
(
)
;
#
else
return
1E9
;
#
endif
}
}
namespace
{
template
<
class
T
>
inline
void
PreventElision
(
T
&
&
output
)
{
#
if
HWY_COMPILER_MSVC
=
=
0
asm
volatile
(
"
"
:
"
+
r
"
(
output
)
:
:
"
memory
"
)
;
#
else
static
std
:
:
atomic
<
T
>
dummy
(
T
{
}
)
;
dummy
.
store
(
output
std
:
:
memory_order_relaxed
)
;
#
endif
}
namespace
timer
{
inline
uint64_t
Start64
(
)
{
uint64_t
t
;
#
if
HWY_ARCH_PPC
asm
volatile
(
"
mfspr
%
0
%
1
"
:
"
=
r
"
(
t
)
:
"
i
"
(
268
)
)
;
#
elif
HWY_ARCH_X86
&
&
HWY_COMPILER_MSVC
_ReadWriteBarrier
(
)
;
_mm_lfence
(
)
;
_ReadWriteBarrier
(
)
;
t
=
__rdtsc
(
)
;
_ReadWriteBarrier
(
)
;
_mm_lfence
(
)
;
_ReadWriteBarrier
(
)
;
#
elif
HWY_ARCH_X86_64
asm
volatile
(
"
lfence
\
n
\
t
"
"
rdtsc
\
n
\
t
"
"
shl
32
%
%
rdx
\
n
\
t
"
"
or
%
%
rdx
%
0
\
n
\
t
"
"
lfence
"
:
"
=
a
"
(
t
)
:
:
"
rdx
"
"
memory
"
"
cc
"
)
;
#
elif
HWY_ARCH_RVV
asm
volatile
(
"
rdcycle
%
0
"
:
"
=
r
"
(
t
)
)
;
#
else
timespec
ts
;
clock_gettime
(
CLOCK_MONOTONIC
&
ts
)
;
t
=
ts
.
tv_sec
*
1000000000LL
+
ts
.
tv_nsec
;
#
endif
return
t
;
}
inline
uint64_t
Stop64
(
)
{
uint64_t
t
;
#
if
HWY_ARCH_PPC
asm
volatile
(
"
mfspr
%
0
%
1
"
:
"
=
r
"
(
t
)
:
"
i
"
(
268
)
)
;
#
elif
HWY_ARCH_X86
&
&
HWY_COMPILER_MSVC
_ReadWriteBarrier
(
)
;
unsigned
aux
;
t
=
__rdtscp
(
&
aux
)
;
_ReadWriteBarrier
(
)
;
_mm_lfence
(
)
;
_ReadWriteBarrier
(
)
;
#
elif
HWY_ARCH_X86_64
asm
volatile
(
"
rdtscp
\
n
\
t
"
"
shl
32
%
%
rdx
\
n
\
t
"
"
or
%
%
rdx
%
0
\
n
\
t
"
"
lfence
"
:
"
=
a
"
(
t
)
:
:
"
rcx
"
"
rdx
"
"
memory
"
"
cc
"
)
;
#
else
t
=
Start64
(
)
;
#
endif
return
t
;
}
inline
uint32_t
Start32
(
)
{
uint32_t
t
;
#
if
HWY_ARCH_X86
&
&
HWY_COMPILER_MSVC
_ReadWriteBarrier
(
)
;
_mm_lfence
(
)
;
_ReadWriteBarrier
(
)
;
t
=
static_cast
<
uint32_t
>
(
__rdtsc
(
)
)
;
_ReadWriteBarrier
(
)
;
_mm_lfence
(
)
;
_ReadWriteBarrier
(
)
;
#
elif
HWY_ARCH_X86_64
asm
volatile
(
"
lfence
\
n
\
t
"
"
rdtsc
\
n
\
t
"
"
lfence
"
:
"
=
a
"
(
t
)
:
:
"
rdx
"
"
memory
"
)
;
#
elif
HWY_ARCH_RVV
asm
volatile
(
"
rdcycle
%
0
"
:
"
=
r
"
(
t
)
)
;
#
else
t
=
static_cast
<
uint32_t
>
(
Start64
(
)
)
;
#
endif
return
t
;
}
inline
uint32_t
Stop32
(
)
{
uint32_t
t
;
#
if
HWY_ARCH_X86
&
&
HWY_COMPILER_MSVC
_ReadWriteBarrier
(
)
;
unsigned
aux
;
t
=
static_cast
<
uint32_t
>
(
__rdtscp
(
&
aux
)
)
;
_ReadWriteBarrier
(
)
;
_mm_lfence
(
)
;
_ReadWriteBarrier
(
)
;
#
elif
HWY_ARCH_X86_64
asm
volatile
(
"
rdtscp
\
n
\
t
"
"
lfence
"
:
"
=
a
"
(
t
)
:
:
"
rcx
"
"
rdx
"
"
memory
"
)
;
#
else
t
=
static_cast
<
uint32_t
>
(
Stop64
(
)
)
;
#
endif
return
t
;
}
}
namespace
robust_statistics
{
template
<
class
T
>
void
CountingSort
(
T
*
values
size_t
num_values
)
{
using
Unique
=
std
:
:
pair
<
T
int
>
;
std
:
:
vector
<
Unique
>
unique
;
for
(
size_t
i
=
0
;
i
<
num_values
;
+
+
i
)
{
const
T
value
=
values
[
i
]
;
const
auto
pos
=
std
:
:
find_if
(
unique
.
begin
(
)
unique
.
end
(
)
[
value
]
(
const
Unique
u
)
{
return
u
.
first
=
=
value
;
}
)
;
if
(
pos
=
=
unique
.
end
(
)
)
{
unique
.
push_back
(
std
:
:
make_pair
(
value
1
)
)
;
}
else
{
+
+
pos
-
>
second
;
}
}
std
:
:
sort
(
unique
.
begin
(
)
unique
.
end
(
)
)
;
T
*
HWY_RESTRICT
p
=
values
;
for
(
const
auto
&
value_count
:
unique
)
{
std
:
:
fill
(
p
p
+
value_count
.
second
value_count
.
first
)
;
p
+
=
value_count
.
second
;
}
NANOBENCHMARK_CHECK
(
p
=
=
values
+
num_values
)
;
}
template
<
typename
T
>
size_t
MinRange
(
const
T
*
const
HWY_RESTRICT
sorted
const
size_t
idx_begin
const
size_t
half_count
)
{
T
min_range
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
;
size_t
min_idx
=
0
;
for
(
size_t
idx
=
idx_begin
;
idx
<
idx_begin
+
half_count
;
+
+
idx
)
{
NANOBENCHMARK_CHECK
(
sorted
[
idx
]
<
=
sorted
[
idx
+
half_count
]
)
;
const
T
range
=
sorted
[
idx
+
half_count
]
-
sorted
[
idx
]
;
if
(
range
<
min_range
)
{
min_range
=
range
;
min_idx
=
idx
;
}
}
return
min_idx
;
}
template
<
typename
T
>
T
ModeOfSorted
(
const
T
*
const
HWY_RESTRICT
sorted
const
size_t
num_values
)
{
size_t
idx_begin
=
0
;
size_t
half_count
=
num_values
/
2
;
while
(
half_count
>
1
)
{
idx_begin
=
MinRange
(
sorted
idx_begin
half_count
)
;
half_count
>
>
=
1
;
}
const
T
x
=
sorted
[
idx_begin
+
0
]
;
if
(
half_count
=
=
0
)
{
return
x
;
}
NANOBENCHMARK_CHECK
(
half_count
=
=
1
)
;
const
T
average
=
(
x
+
sorted
[
idx_begin
+
1
]
+
1
)
/
2
;
return
average
;
}
template
<
typename
T
>
T
Mode
(
T
*
values
const
size_t
num_values
)
{
CountingSort
(
values
num_values
)
;
return
ModeOfSorted
(
values
num_values
)
;
}
template
<
typename
T
size_t
N
>
T
Mode
(
T
(
&
values
)
[
N
]
)
{
return
Mode
(
&
values
[
0
]
N
)
;
}
template
<
typename
T
>
T
Median
(
T
*
values
const
size_t
num_values
)
{
NANOBENCHMARK_CHECK
(
!
values
-
>
empty
(
)
)
;
std
:
:
sort
(
values
values
+
num_values
)
;
const
size_t
half
=
num_values
/
2
;
if
(
num_values
%
2
)
{
return
values
[
half
]
;
}
return
(
values
[
half
]
+
values
[
half
-
1
]
+
1
)
/
2
;
}
template
<
typename
T
>
T
MedianAbsoluteDeviation
(
const
T
*
values
const
size_t
num_values
const
T
median
)
{
NANOBENCHMARK_CHECK
(
num_values
!
=
0
)
;
std
:
:
vector
<
T
>
abs_deviations
;
abs_deviations
.
reserve
(
num_values
)
;
for
(
size_t
i
=
0
;
i
<
num_values
;
+
+
i
)
{
const
int64_t
abs
=
std
:
:
abs
(
int64_t
(
values
[
i
]
)
-
int64_t
(
median
)
)
;
abs_deviations
.
push_back
(
static_cast
<
T
>
(
abs
)
)
;
}
return
Median
(
abs_deviations
.
data
(
)
num_values
)
;
}
}
using
Ticks
=
uint32_t
;
Ticks
TimerResolution
(
)
{
Ticks
repetitions
[
Params
:
:
kTimerSamples
]
;
for
(
size_t
rep
=
0
;
rep
<
Params
:
:
kTimerSamples
;
+
+
rep
)
{
Ticks
samples
[
Params
:
:
kTimerSamples
]
;
for
(
size_t
i
=
0
;
i
<
Params
:
:
kTimerSamples
;
+
+
i
)
{
const
Ticks
t0
=
timer
:
:
Start32
(
)
;
const
Ticks
t1
=
timer
:
:
Stop32
(
)
;
samples
[
i
]
=
t1
-
t0
;
}
repetitions
[
rep
]
=
robust_statistics
:
:
Mode
(
samples
)
;
}
return
robust_statistics
:
:
Mode
(
repetitions
)
;
}
static
const
Ticks
timer_resolution
=
TimerResolution
(
)
;
template
<
class
Lambda
>
Ticks
SampleUntilStable
(
const
double
max_rel_mad
double
*
rel_mad
const
Params
&
p
const
Lambda
&
lambda
)
{
Ticks
t0
=
timer
:
:
Start32
(
)
;
lambda
(
)
;
Ticks
t1
=
timer
:
:
Stop32
(
)
;
Ticks
est
=
t1
-
t0
;
static
const
double
ticks_per_second
=
platform
:
:
InvariantTicksPerSecond
(
)
;
const
size_t
ticks_per_eval
=
static_cast
<
size_t
>
(
ticks_per_second
*
p
.
seconds_per_eval
)
;
size_t
samples_per_eval
=
est
=
=
0
?
p
.
min_samples_per_eval
:
ticks_per_eval
/
est
;
samples_per_eval
=
std
:
:
max
(
samples_per_eval
p
.
min_samples_per_eval
)
;
std
:
:
vector
<
Ticks
>
samples
;
samples
.
reserve
(
1
+
samples_per_eval
)
;
samples
.
push_back
(
est
)
;
const
Ticks
max_abs_mad
=
(
timer_resolution
+
99
)
/
100
;
*
rel_mad
=
0
.
0
;
for
(
size_t
eval
=
0
;
eval
<
p
.
max_evals
;
+
+
eval
samples_per_eval
*
=
2
)
{
samples
.
reserve
(
samples
.
size
(
)
+
samples_per_eval
)
;
for
(
size_t
i
=
0
;
i
<
samples_per_eval
;
+
+
i
)
{
t0
=
timer
:
:
Start32
(
)
;
lambda
(
)
;
t1
=
timer
:
:
Stop32
(
)
;
samples
.
push_back
(
t1
-
t0
)
;
}
if
(
samples
.
size
(
)
>
=
p
.
min_mode_samples
)
{
est
=
robust_statistics
:
:
Mode
(
samples
.
data
(
)
samples
.
size
(
)
)
;
}
else
{
est
=
robust_statistics
:
:
Median
(
samples
.
data
(
)
samples
.
size
(
)
)
;
}
NANOBENCHMARK_CHECK
(
est
!
=
0
)
;
const
Ticks
abs_mad
=
robust_statistics
:
:
MedianAbsoluteDeviation
(
samples
.
data
(
)
samples
.
size
(
)
est
)
;
*
rel_mad
=
static_cast
<
double
>
(
int
(
abs_mad
)
)
/
est
;
if
(
*
rel_mad
<
=
max_rel_mad
|
|
abs_mad
<
=
max_abs_mad
)
{
if
(
p
.
verbose
)
{
printf
(
"
%
6zu
samples
=
>
%
5u
(
abs_mad
=
%
4u
rel_mad
=
%
4
.
2f
%
%
)
\
n
"
samples
.
size
(
)
est
abs_mad
*
rel_mad
*
100
.
0
)
;
}
return
est
;
}
}
if
(
p
.
verbose
)
{
printf
(
"
WARNING
:
rel_mad
=
%
4
.
2f
%
%
still
exceeds
%
4
.
2f
%
%
after
%
6zu
samples
.
\
n
"
*
rel_mad
*
100
.
0
max_rel_mad
*
100
.
0
samples
.
size
(
)
)
;
}
return
est
;
}
using
InputVec
=
std
:
:
vector
<
FuncInput
>
;
InputVec
UniqueInputs
(
const
FuncInput
*
inputs
const
size_t
num_inputs
)
{
InputVec
unique
(
inputs
inputs
+
num_inputs
)
;
std
:
:
sort
(
unique
.
begin
(
)
unique
.
end
(
)
)
;
unique
.
erase
(
std
:
:
unique
(
unique
.
begin
(
)
unique
.
end
(
)
)
unique
.
end
(
)
)
;
return
unique
;
}
size_t
NumSkip
(
const
Func
func
const
uint8_t
*
arg
const
InputVec
&
unique
const
Params
&
p
)
{
Ticks
min_duration
=
~
0u
;
for
(
const
FuncInput
input
:
unique
)
{
const
uint64_t
t0
=
timer
:
:
Start64
(
)
;
PreventElision
(
func
(
arg
input
)
)
;
const
uint64_t
t1
=
timer
:
:
Stop64
(
)
;
const
uint64_t
elapsed
=
t1
-
t0
;
if
(
elapsed
>
=
(
1ULL
<
<
30
)
)
{
fprintf
(
stderr
"
Measurement
failed
:
need
64
-
bit
timer
for
input
=
%
zu
\
n
"
input
)
;
return
0
;
}
double
rel_mad
;
const
Ticks
total
=
SampleUntilStable
(
p
.
target_rel_mad
&
rel_mad
p
[
func
arg
input
]
(
)
{
PreventElision
(
func
(
arg
input
)
)
;
}
)
;
min_duration
=
std
:
:
min
(
min_duration
total
-
timer_resolution
)
;
}
const
size_t
max_skip
=
p
.
precision_divisor
;
const
size_t
num_skip
=
min_duration
=
=
0
?
0
:
(
max_skip
+
min_duration
-
1
)
/
min_duration
;
if
(
p
.
verbose
)
{
printf
(
"
res
=
%
u
max_skip
=
%
zu
min_dur
=
%
u
num_skip
=
%
zu
\
n
"
timer_resolution
max_skip
min_duration
num_skip
)
;
}
return
num_skip
;
}
InputVec
ReplicateInputs
(
const
FuncInput
*
inputs
const
size_t
num_inputs
const
size_t
num_unique
const
size_t
num_skip
const
Params
&
p
)
{
InputVec
full
;
if
(
num_unique
=
=
1
)
{
full
.
assign
(
p
.
subset_ratio
*
num_skip
inputs
[
0
]
)
;
return
full
;
}
full
.
reserve
(
p
.
subset_ratio
*
num_skip
*
num_inputs
)
;
for
(
size_t
i
=
0
;
i
<
p
.
subset_ratio
*
num_skip
;
+
+
i
)
{
full
.
insert
(
full
.
end
(
)
inputs
inputs
+
num_inputs
)
;
}
std
:
:
mt19937
rng
;
std
:
:
shuffle
(
full
.
begin
(
)
full
.
end
(
)
rng
)
;
return
full
;
}
void
FillSubset
(
const
InputVec
&
full
const
FuncInput
input_to_skip
const
size_t
num_skip
InputVec
*
subset
)
{
const
size_t
count
=
static_cast
<
size_t
>
(
std
:
:
count
(
full
.
begin
(
)
full
.
end
(
)
input_to_skip
)
)
;
std
:
:
vector
<
uint32_t
>
omit
(
count
)
;
std
:
:
iota
(
omit
.
begin
(
)
omit
.
end
(
)
0
)
;
std
:
:
mt19937
rng
;
std
:
:
shuffle
(
omit
.
begin
(
)
omit
.
end
(
)
rng
)
;
omit
.
resize
(
num_skip
)
;
std
:
:
sort
(
omit
.
begin
(
)
omit
.
end
(
)
)
;
uint32_t
occurrence
=
~
0u
;
size_t
idx_omit
=
0
;
size_t
idx_subset
=
0
;
for
(
const
FuncInput
next
:
full
)
{
if
(
next
=
=
input_to_skip
)
{
+
+
occurrence
;
if
(
idx_omit
<
num_skip
)
{
if
(
occurrence
=
=
omit
[
idx_omit
]
)
{
+
+
idx_omit
;
continue
;
}
}
}
if
(
idx_subset
<
subset
-
>
size
(
)
)
{
(
*
subset
)
[
idx_subset
+
+
]
=
next
;
}
}
NANOBENCHMARK_CHECK
(
idx_subset
=
=
subset
-
>
size
(
)
)
;
NANOBENCHMARK_CHECK
(
idx_omit
=
=
omit
.
size
(
)
)
;
NANOBENCHMARK_CHECK
(
occurrence
=
=
count
-
1
)
;
}
Ticks
TotalDuration
(
const
Func
func
const
uint8_t
*
arg
const
InputVec
*
inputs
const
Params
&
p
double
*
max_rel_mad
)
{
double
rel_mad
;
const
Ticks
duration
=
SampleUntilStable
(
p
.
target_rel_mad
&
rel_mad
p
[
func
arg
inputs
]
(
)
{
for
(
const
FuncInput
input
:
*
inputs
)
{
PreventElision
(
func
(
arg
input
)
)
;
}
}
)
;
*
max_rel_mad
=
std
:
:
max
(
*
max_rel_mad
rel_mad
)
;
return
duration
;
}
HWY_NOINLINE
FuncOutput
EmptyFunc
(
const
void
*
const
FuncInput
input
)
{
return
input
;
}
Ticks
Overhead
(
const
uint8_t
*
arg
const
InputVec
*
inputs
const
Params
&
p
)
{
double
rel_mad
;
return
SampleUntilStable
(
0
.
0
&
rel_mad
p
[
arg
inputs
]
(
)
{
for
(
const
FuncInput
input
:
*
inputs
)
{
PreventElision
(
EmptyFunc
(
arg
input
)
)
;
}
}
)
;
}
}
int
Unpredictable1
(
)
{
return
timer
:
:
Start64
(
)
!
=
~
0ULL
;
}
size_t
Measure
(
const
Func
func
const
uint8_t
*
arg
const
FuncInput
*
inputs
const
size_t
num_inputs
Result
*
results
const
Params
&
p
)
{
NANOBENCHMARK_CHECK
(
num_inputs
!
=
0
)
;
const
InputVec
&
unique
=
UniqueInputs
(
inputs
num_inputs
)
;
const
size_t
num_skip
=
NumSkip
(
func
arg
unique
p
)
;
if
(
num_skip
=
=
0
)
return
0
;
const
float
mul
=
1
.
0f
/
static_cast
<
float
>
(
static_cast
<
int
>
(
num_skip
)
)
;
const
InputVec
&
full
=
ReplicateInputs
(
inputs
num_inputs
unique
.
size
(
)
num_skip
p
)
;
InputVec
subset
(
full
.
size
(
)
-
num_skip
)
;
const
Ticks
overhead
=
Overhead
(
arg
&
full
p
)
;
const
Ticks
overhead_skip
=
Overhead
(
arg
&
subset
p
)
;
if
(
overhead
<
overhead_skip
)
{
fprintf
(
stderr
"
Measurement
failed
:
overhead
%
u
<
%
u
\
n
"
overhead
overhead_skip
)
;
return
0
;
}
if
(
p
.
verbose
)
{
printf
(
"
#
inputs
=
%
5zu
%
5zu
overhead
=
%
5u
%
5u
\
n
"
full
.
size
(
)
subset
.
size
(
)
overhead
overhead_skip
)
;
}
double
max_rel_mad
=
0
.
0
;
const
Ticks
total
=
TotalDuration
(
func
arg
&
full
p
&
max_rel_mad
)
;
for
(
size_t
i
=
0
;
i
<
unique
.
size
(
)
;
+
+
i
)
{
FillSubset
(
full
unique
[
i
]
num_skip
&
subset
)
;
const
Ticks
total_skip
=
TotalDuration
(
func
arg
&
subset
p
&
max_rel_mad
)
;
if
(
total
<
total_skip
)
{
fprintf
(
stderr
"
Measurement
failed
:
total
%
u
<
%
u
\
n
"
total
total_skip
)
;
return
0
;
}
const
Ticks
duration
=
(
total
-
overhead
)
-
(
total_skip
-
overhead_skip
)
;
results
[
i
]
.
input
=
unique
[
i
]
;
results
[
i
]
.
ticks
=
static_cast
<
float
>
(
duration
)
*
mul
;
results
[
i
]
.
variability
=
static_cast
<
float
>
(
max_rel_mad
)
;
}
return
unique
.
size
(
)
;
}
}
