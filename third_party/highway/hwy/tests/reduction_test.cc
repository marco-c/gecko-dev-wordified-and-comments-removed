#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
tests
/
reduction_test
.
cc
"
#
include
"
hwy
/
foreach_target
.
h
"
#
include
"
hwy
/
highway
.
h
"
#
include
"
hwy
/
tests
/
test_util
-
inl
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
struct
TestSumOfLanes
{
template
<
typename
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
size_t
N
=
Lanes
(
d
)
;
auto
in_lanes
=
AllocateAligned
<
T
>
(
N
)
;
double
sum
=
0
.
0
;
constexpr
size_t
kBits
=
HWY_MIN
(
sizeof
(
T
)
*
8
-
1
51
)
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
in_lanes
[
i
]
=
i
<
kBits
?
static_cast
<
T
>
(
1ull
<
<
i
)
:
0
;
sum
+
=
static_cast
<
double
>
(
in_lanes
[
i
]
)
;
}
HWY_ASSERT_VEC_EQ
(
d
Set
(
d
T
(
sum
)
)
SumOfLanes
(
d
Load
(
d
in_lanes
.
get
(
)
)
)
)
;
sum
=
0
.
0
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
sum
+
=
static_cast
<
double
>
(
i
)
;
}
HWY_ASSERT_VEC_EQ
(
d
Set
(
d
T
(
sum
)
)
SumOfLanes
(
d
Iota
(
d
0
)
)
)
;
}
}
;
HWY_NOINLINE
void
TestAllSumOfLanes
(
)
{
ForUIF3264
(
ForPartialVectors
<
TestSumOfLanes
>
(
)
)
;
ForUI16
(
ForPartialVectors
<
TestSumOfLanes
>
(
)
)
;
}
struct
TestMinOfLanes
{
template
<
typename
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
size_t
N
=
Lanes
(
d
)
;
auto
in_lanes
=
AllocateAligned
<
T
>
(
N
)
;
T
min
=
HighestValue
<
T
>
(
)
;
constexpr
size_t
kBits
=
HWY_MIN
(
sizeof
(
T
)
*
8
-
1
51
)
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
in_lanes
[
i
]
=
i
<
kBits
?
static_cast
<
T
>
(
1ull
<
<
i
)
:
2
;
min
=
HWY_MIN
(
min
in_lanes
[
i
]
)
;
}
HWY_ASSERT_VEC_EQ
(
d
Set
(
d
min
)
MinOfLanes
(
d
Load
(
d
in_lanes
.
get
(
)
)
)
)
;
min
=
HighestValue
<
T
>
(
)
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
in_lanes
[
i
]
=
static_cast
<
T
>
(
N
-
i
)
;
min
=
HWY_MIN
(
min
in_lanes
[
i
]
)
;
}
HWY_ASSERT_VEC_EQ
(
d
Set
(
d
min
)
MinOfLanes
(
d
Load
(
d
in_lanes
.
get
(
)
)
)
)
;
min
=
HighestValue
<
T
>
(
)
;
const
T
input_copy
[
]
=
{
static_cast
<
T
>
(
-
1
)
static_cast
<
T
>
(
-
2
)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
}
;
size_t
i
=
0
;
for
(
;
i
<
HWY_MIN
(
N
sizeof
(
input_copy
)
/
sizeof
(
T
)
)
;
+
+
i
)
{
in_lanes
[
i
]
=
input_copy
[
i
]
;
min
=
HWY_MIN
(
min
input_copy
[
i
]
)
;
}
for
(
;
i
<
N
;
+
+
i
)
{
in_lanes
[
i
]
=
min
;
}
HWY_ASSERT_VEC_EQ
(
d
Set
(
d
min
)
MinOfLanes
(
d
Load
(
d
in_lanes
.
get
(
)
)
)
)
;
}
}
;
struct
TestMaxOfLanes
{
template
<
typename
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
size_t
N
=
Lanes
(
d
)
;
auto
in_lanes
=
AllocateAligned
<
T
>
(
N
)
;
T
max
=
LowestValue
<
T
>
(
)
;
constexpr
size_t
kBits
=
HWY_MIN
(
sizeof
(
T
)
*
8
-
1
51
)
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
in_lanes
[
i
]
=
i
<
kBits
?
static_cast
<
T
>
(
1ull
<
<
i
)
:
0
;
max
=
HWY_MAX
(
max
in_lanes
[
i
]
)
;
}
HWY_ASSERT_VEC_EQ
(
d
Set
(
d
max
)
MaxOfLanes
(
d
Load
(
d
in_lanes
.
get
(
)
)
)
)
;
max
=
LowestValue
<
T
>
(
)
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
in_lanes
[
i
]
=
static_cast
<
T
>
(
i
)
;
max
=
HWY_MAX
(
max
in_lanes
[
i
]
)
;
}
HWY_ASSERT_VEC_EQ
(
d
Set
(
d
max
)
MaxOfLanes
(
d
Load
(
d
in_lanes
.
get
(
)
)
)
)
;
max
=
LowestValue
<
T
>
(
)
;
const
T
input_copy
[
]
=
{
static_cast
<
T
>
(
-
1
)
static_cast
<
T
>
(
-
2
)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
}
;
size_t
i
=
0
;
for
(
;
i
<
HWY_MIN
(
N
sizeof
(
input_copy
)
/
sizeof
(
T
)
)
;
+
+
i
)
{
in_lanes
[
i
]
=
input_copy
[
i
]
;
max
=
HWY_MAX
(
max
in_lanes
[
i
]
)
;
}
for
(
;
i
<
N
;
+
+
i
)
{
in_lanes
[
i
]
=
max
;
}
HWY_ASSERT_VEC_EQ
(
d
Set
(
d
max
)
MaxOfLanes
(
d
Load
(
d
in_lanes
.
get
(
)
)
)
)
;
}
}
;
HWY_NOINLINE
void
TestAllMinMaxOfLanes
(
)
{
const
ForPartialVectors
<
TestMinOfLanes
>
test_min
;
const
ForPartialVectors
<
TestMaxOfLanes
>
test_max
;
ForUIF3264
(
test_min
)
;
ForUIF3264
(
test_max
)
;
ForUI16
(
test_min
)
;
ForUI16
(
test_max
)
;
}
struct
TestSumsOf8
{
template
<
typename
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
RandomState
rng
;
const
size_t
N
=
Lanes
(
d
)
;
if
(
N
<
8
)
return
;
const
Repartition
<
uint64_t
D
>
du64
;
auto
in_lanes
=
AllocateAligned
<
T
>
(
N
)
;
auto
sum_lanes
=
AllocateAligned
<
uint64_t
>
(
N
/
8
)
;
for
(
size_t
rep
=
0
;
rep
<
100
;
+
+
rep
)
{
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
in_lanes
[
i
]
=
Random64
(
&
rng
)
&
0xFF
;
}
for
(
size_t
idx_sum
=
0
;
idx_sum
<
N
/
8
;
+
+
idx_sum
)
{
uint64_t
sum
=
0
;
for
(
size_t
i
=
0
;
i
<
8
;
+
+
i
)
{
sum
+
=
in_lanes
[
idx_sum
*
8
+
i
]
;
}
sum_lanes
[
idx_sum
]
=
sum
;
}
const
Vec
<
D
>
in
=
Load
(
d
in_lanes
.
get
(
)
)
;
HWY_ASSERT_VEC_EQ
(
du64
sum_lanes
.
get
(
)
SumsOf8
(
in
)
)
;
}
}
}
;
HWY_NOINLINE
void
TestAllSumsOf8
(
)
{
ForGEVectors
<
64
TestSumsOf8
>
(
)
(
uint8_t
(
)
)
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
hwy
{
HWY_BEFORE_TEST
(
HwyReductionTest
)
;
HWY_EXPORT_AND_TEST_P
(
HwyReductionTest
TestAllSumOfLanes
)
;
HWY_EXPORT_AND_TEST_P
(
HwyReductionTest
TestAllMinMaxOfLanes
)
;
HWY_EXPORT_AND_TEST_P
(
HwyReductionTest
TestAllSumsOf8
)
;
}
#
endif
