#
ifndef
HWY_TESTS_TEST_UTIL_H_
#
define
HWY_TESTS_TEST_UTIL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
string
>
#
include
"
hwy
/
aligned_allocator
.
h
"
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
highway
.
h
"
#
include
"
hwy
/
highway_export
.
h
"
namespace
hwy
{
constexpr
size_t
kTestMaxVectorSize
=
64
;
class
RandomState
{
public
:
explicit
RandomState
(
const
uint64_t
seed
=
0x123456789ull
)
{
s0_
=
SplitMix64
(
seed
+
0x9E3779B97F4A7C15ull
)
;
s1_
=
SplitMix64
(
s0_
)
;
}
HWY_INLINE
uint64_t
operator
(
)
(
)
{
uint64_t
s1
=
s0_
;
const
uint64_t
s0
=
s1_
;
const
uint64_t
bits
=
s1
+
s0
;
s0_
=
s0
;
s1
^
=
s1
<
<
23
;
s1
^
=
s0
^
(
s1
>
>
18
)
^
(
s0
>
>
5
)
;
s1_
=
s1
;
return
bits
;
}
private
:
static
uint64_t
SplitMix64
(
uint64_t
z
)
{
z
=
(
z
^
(
z
>
>
30
)
)
*
0xBF58476D1CE4E5B9ull
;
z
=
(
z
^
(
z
>
>
27
)
)
*
0x94D049BB133111EBull
;
return
z
^
(
z
>
>
31
)
;
}
uint64_t
s0_
;
uint64_t
s1_
;
}
;
static
HWY_INLINE
uint32_t
Random32
(
RandomState
*
rng
)
{
return
static_cast
<
uint32_t
>
(
(
*
rng
)
(
)
)
;
}
static
HWY_INLINE
uint64_t
Random64
(
RandomState
*
rng
)
{
return
(
*
rng
)
(
)
;
}
template
<
class
T
>
inline
void
PreventElision
(
T
&
&
output
)
{
#
if
HWY_COMPILER_MSVC
(
void
)
output
;
#
else
asm
volatile
(
"
"
:
"
+
r
"
(
output
)
:
:
"
memory
"
)
;
#
endif
}
HWY_TEST_DLLEXPORT
bool
BytesEqual
(
const
void
*
p1
const
void
*
p2
const
size_t
size
size_t
*
pos
=
nullptr
)
;
void
AssertStringEqual
(
const
char
*
expected
const
char
*
actual
const
char
*
target_name
const
char
*
filename
int
line
)
;
namespace
detail
{
template
<
typename
T
typename
TU
=
MakeUnsigned
<
T
>
>
TU
ComputeUlpDelta
(
const
T
expected
const
T
actual
)
{
if
(
expected
=
=
actual
)
return
0
;
if
(
std
:
:
isnan
(
expected
)
&
&
std
:
:
isnan
(
actual
)
)
return
0
;
TU
ux
uy
;
CopyBytes
<
sizeof
(
T
)
>
(
&
expected
&
ux
)
;
CopyBytes
<
sizeof
(
T
)
>
(
&
actual
&
uy
)
;
const
TU
ulp
=
HWY_MAX
(
ux
uy
)
-
HWY_MIN
(
ux
uy
)
;
return
ulp
;
}
struct
TypeInfo
{
size_t
sizeof_t
;
bool
is_float
;
bool
is_signed
;
}
;
template
<
typename
T
>
HWY_INLINE
TypeInfo
MakeTypeInfo
(
)
{
TypeInfo
info
;
info
.
sizeof_t
=
sizeof
(
T
)
;
info
.
is_float
=
IsFloat
<
T
>
(
)
;
info
.
is_signed
=
IsSigned
<
T
>
(
)
;
return
info
;
}
HWY_TEST_DLLEXPORT
bool
IsEqual
(
const
TypeInfo
&
info
const
void
*
expected_ptr
const
void
*
actual_ptr
)
;
HWY_TEST_DLLEXPORT
void
TypeName
(
const
TypeInfo
&
info
size_t
N
char
*
string100
)
;
HWY_TEST_DLLEXPORT
void
PrintArray
(
const
TypeInfo
&
info
const
char
*
caption
const
void
*
array_void
size_t
N
size_t
lane_u
=
0
size_t
max_lanes
=
7
)
;
HWY_TEST_DLLEXPORT
HWY_NORETURN
void
PrintMismatchAndAbort
(
const
TypeInfo
&
info
const
void
*
expected_ptr
const
void
*
actual_ptr
const
char
*
target_name
const
char
*
filename
int
line
size_t
lane
=
0
size_t
num_lanes
=
1
)
;
HWY_TEST_DLLEXPORT
void
AssertArrayEqual
(
const
TypeInfo
&
info
const
void
*
expected_void
const
void
*
actual_void
size_t
N
const
char
*
target_name
const
char
*
filename
int
line
)
;
}
template
<
typename
T
>
std
:
:
string
TypeName
(
T
size_t
N
)
{
char
string100
[
100
]
;
detail
:
:
TypeName
(
detail
:
:
MakeTypeInfo
<
T
>
(
)
N
string100
)
;
return
string100
;
}
template
<
typename
T
>
HWY_INLINE
bool
IsEqual
(
const
T
expected
const
T
actual
)
{
const
auto
info
=
detail
:
:
MakeTypeInfo
<
T
>
(
)
;
return
detail
:
:
IsEqual
(
info
&
expected
&
actual
)
;
}
template
<
typename
T
>
HWY_INLINE
void
AssertEqual
(
const
T
expected
const
T
actual
const
char
*
target_name
const
char
*
filename
int
line
size_t
lane
=
0
)
{
const
auto
info
=
detail
:
:
MakeTypeInfo
<
T
>
(
)
;
if
(
!
detail
:
:
IsEqual
(
info
&
expected
&
actual
)
)
{
detail
:
:
PrintMismatchAndAbort
(
info
&
expected
&
actual
target_name
filename
line
lane
)
;
}
}
}
#
endif
