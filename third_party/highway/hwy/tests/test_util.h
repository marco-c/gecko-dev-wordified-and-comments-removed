#
ifndef
HWY_TESTS_TEST_UTIL_H_
#
define
HWY_TESTS_TEST_UTIL_H_
#
include
<
string
.
h
>
#
include
<
cmath
>
#
include
<
string
>
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
print
.
h
"
namespace
hwy
{
HWY_MAYBE_UNUSED
constexpr
size_t
kTestMaxVectorSize
=
64
;
class
RandomState
{
public
:
explicit
RandomState
(
const
uint64_t
seed
=
0x123456789ull
)
{
s0_
=
SplitMix64
(
seed
+
0x9E3779B97F4A7C15ull
)
;
s1_
=
SplitMix64
(
s0_
)
;
}
HWY_INLINE
uint64_t
operator
(
)
(
)
{
uint64_t
s1
=
s0_
;
const
uint64_t
s0
=
s1_
;
const
uint64_t
bits
=
s1
+
s0
;
s0_
=
s0
;
s1
^
=
s1
<
<
23
;
s1
^
=
s0
^
(
s1
>
>
18
)
^
(
s0
>
>
5
)
;
s1_
=
s1
;
return
bits
;
}
private
:
static
uint64_t
SplitMix64
(
uint64_t
z
)
{
z
=
(
z
^
(
z
>
>
30
)
)
*
0xBF58476D1CE4E5B9ull
;
z
=
(
z
^
(
z
>
>
27
)
)
*
0x94D049BB133111EBull
;
return
z
^
(
z
>
>
31
)
;
}
uint64_t
s0_
;
uint64_t
s1_
;
}
;
static
HWY_INLINE
uint32_t
Random32
(
RandomState
*
rng
)
{
return
static_cast
<
uint32_t
>
(
(
*
rng
)
(
)
)
;
}
static
HWY_INLINE
uint64_t
Random64
(
RandomState
*
rng
)
{
return
(
*
rng
)
(
)
;
}
template
<
class
T
HWY_IF_FLOAT_OR_SPECIAL
(
T
)
>
static
HWY_INLINE
T
RandomFiniteValue
(
RandomState
*
rng
)
{
const
uint64_t
rand_bits
=
Random64
(
rng
)
;
using
TU
=
MakeUnsigned
<
T
>
;
constexpr
TU
kExponentMask
=
ExponentMask
<
T
>
(
)
;
constexpr
TU
kSignMantMask
=
static_cast
<
TU
>
(
~
kExponentMask
)
;
constexpr
TU
kMaxExpField
=
static_cast
<
TU
>
(
MaxExponentField
<
T
>
(
)
)
;
constexpr
int
kNumOfMantBits
=
MantissaBits
<
T
>
(
)
;
const
TU
orig_exp_field_val
=
static_cast
<
TU
>
(
(
rand_bits
>
>
kNumOfMantBits
)
&
kMaxExpField
)
;
const
TU
sign_mant_bits
=
static_cast
<
TU
>
(
rand_bits
&
kSignMantMask
)
;
const
TU
exp_bits
=
static_cast
<
TU
>
(
HWY_MIN
(
HWY_MAX
(
orig_exp_field_val
1
)
kMaxExpField
-
1
)
<
<
kNumOfMantBits
)
;
return
BitCastScalar
<
T
>
(
static_cast
<
TU
>
(
sign_mant_bits
|
exp_bits
)
)
;
}
template
<
class
T
HWY_IF_NOT_FLOAT_NOR_SPECIAL
(
T
)
>
static
HWY_INLINE
T
RandomFiniteValue
(
RandomState
*
rng
)
{
using
TU
=
MakeUnsigned
<
T
>
;
return
static_cast
<
T
>
(
Random64
(
rng
)
&
LimitsMax
<
TU
>
(
)
)
;
}
HWY_TEST_DLLEXPORT
bool
BytesEqual
(
const
void
*
p1
const
void
*
p2
size_t
size
size_t
*
pos
=
nullptr
)
;
void
AssertStringEqual
(
const
char
*
expected
const
char
*
actual
const
char
*
target_name
const
char
*
filename
int
line
)
;
namespace
detail
{
template
<
typename
T
typename
TU
=
MakeUnsigned
<
T
>
>
TU
ComputeUlpDelta
(
const
T
expected
const
T
actual
)
{
if
(
expected
=
=
actual
)
return
0
;
if
(
std
:
:
isnan
(
expected
)
&
&
std
:
:
isnan
(
actual
)
)
return
0
;
TU
ux
uy
;
CopySameSize
(
&
expected
&
ux
)
;
CopySameSize
(
&
actual
&
uy
)
;
const
TU
ulp
=
HWY_MAX
(
ux
uy
)
-
HWY_MIN
(
ux
uy
)
;
return
ulp
;
}
HWY_TEST_DLLEXPORT
bool
IsEqual
(
const
TypeInfo
&
info
const
void
*
expected_ptr
const
void
*
actual_ptr
)
;
HWY_TEST_DLLEXPORT
HWY_NORETURN
void
PrintMismatchAndAbort
(
const
TypeInfo
&
info
const
void
*
expected_ptr
const
void
*
actual_ptr
const
char
*
target_name
const
char
*
filename
int
line
size_t
lane
=
0
size_t
num_lanes
=
1
)
;
HWY_TEST_DLLEXPORT
void
AssertArrayEqual
(
const
TypeInfo
&
info
const
void
*
expected_void
const
void
*
actual_void
size_t
N
const
char
*
target_name
const
char
*
filename
int
line
)
;
}
template
<
typename
T
>
std
:
:
string
TypeName
(
T
size_t
N
)
{
char
string100
[
100
]
;
detail
:
:
TypeName
(
detail
:
:
MakeTypeInfo
<
T
>
(
)
N
string100
)
;
return
string100
;
}
template
<
typename
T1
typename
T2
>
using
LargestType
=
If
<
IsFloat
<
T1
>
(
)
|
|
IsFloat
<
T2
>
(
)
FloatFromSize
<
HWY_MAX
(
sizeof
(
T1
)
sizeof
(
T2
)
)
>
If
<
IsSigned
<
T1
>
(
)
|
|
IsSigned
<
T2
>
(
)
SignedFromSize
<
HWY_MAX
(
sizeof
(
T1
)
sizeof
(
T2
)
)
>
UnsignedFromSize
<
HWY_MAX
(
sizeof
(
T1
)
sizeof
(
T2
)
)
>
>
>
;
template
<
typename
TTo
typename
T
HWY_IF_NOT_FLOAT_NOR_SPECIAL
(
TTo
)
HWY_IF_T_SIZE_LE
(
TTo
4
)
>
T
WrapTo
(
T
value
)
{
return
static_cast
<
T
>
(
static_cast
<
uint64_t
>
(
value
)
&
(
(
uint64_t
{
1
}
<
<
(
sizeof
(
TTo
)
*
8
)
)
-
1
)
)
;
}
template
<
typename
TTo
typename
T
HWY_IF_NOT_FLOAT_NOR_SPECIAL
(
TTo
)
HWY_IF_T_SIZE_GT
(
TTo
4
)
>
T
WrapTo
(
T
value
)
{
return
value
;
}
template
<
typename
TTo
typename
T
HWY_IF_FLOAT_OR_SPECIAL
(
TTo
)
>
T
WrapTo
(
T
value
)
{
return
value
;
}
template
<
typename
TExpected
typename
TActual
>
HWY_INLINE
bool
IsEqual
(
const
TExpected
texpected
const
TActual
actual
)
{
const
TActual
expected
=
ConvertScalarTo
<
TActual
>
(
WrapTo
<
TActual
>
(
texpected
)
)
;
const
auto
info
=
detail
:
:
MakeTypeInfo
<
TActual
>
(
)
;
return
detail
:
:
IsEqual
(
info
&
expected
&
actual
)
;
}
template
<
typename
TExpected
typename
TActual
>
HWY_INLINE
void
AssertEqual
(
const
TExpected
texpected
const
TActual
actual
const
char
*
target_name
const
char
*
filename
int
line
size_t
lane
=
0
)
{
const
TActual
expected
=
ConvertScalarTo
<
TActual
>
(
WrapTo
<
TActual
>
(
texpected
)
)
;
const
auto
info
=
detail
:
:
MakeTypeInfo
<
TActual
>
(
)
;
if
(
!
detail
:
:
IsEqual
(
info
&
expected
&
actual
)
)
{
detail
:
:
PrintMismatchAndAbort
(
info
&
expected
&
actual
target_name
filename
line
lane
)
;
}
}
template
<
typename
T
>
HWY_INLINE
void
AssertArrayEqual
(
const
T
*
expected
const
T
*
actual
size_t
count
const
char
*
target_name
const
char
*
filename
int
line
)
{
const
auto
info
=
hwy
:
:
detail
:
:
MakeTypeInfo
<
T
>
(
)
;
detail
:
:
AssertArrayEqual
(
info
expected
actual
count
target_name
filename
line
)
;
}
template
<
typename
T
>
HWY_INLINE
void
AssertArraySimilar
(
const
T
*
expected
const
T
*
actual
size_t
count
const
char
*
target_name
const
char
*
filename
int
line
)
{
const
double
tolerance
=
(
hwy
:
:
IsSame
<
RemoveCvRef
<
T
>
float16_t
>
(
)
?
128
.
0
:
1
.
0
)
/
(
uint64_t
{
1
}
<
<
MantissaBits
<
T
>
(
)
)
;
for
(
size_t
i
=
0
;
i
<
count
;
+
+
i
)
{
const
double
exp
=
ConvertScalarTo
<
double
>
(
expected
[
i
]
)
;
const
double
act
=
ConvertScalarTo
<
double
>
(
actual
[
i
]
)
;
const
double
l1
=
ScalarAbs
(
act
-
exp
)
;
if
(
exp
=
=
0
.
0
)
{
if
(
l1
>
tolerance
)
{
HWY_ABORT
(
"
%
s
%
s
:
%
d
%
s
mismatch
%
zu
of
%
zu
:
%
E
%
E
l1
%
E
tol
%
E
\
n
"
target_name
filename
line
TypeName
(
T
(
)
1
)
.
c_str
(
)
i
count
exp
act
l1
tolerance
)
;
}
}
else
{
const
double
rel
=
l1
/
exp
;
if
(
rel
>
tolerance
)
{
HWY_ABORT
(
"
%
s
%
s
:
%
d
%
s
mismatch
%
zu
of
%
zu
:
%
E
%
E
rel
%
E
tol
%
E
\
n
"
target_name
filename
line
TypeName
(
T
(
)
1
)
.
c_str
(
)
i
count
exp
act
rel
tolerance
)
;
}
}
}
}
}
#
endif
