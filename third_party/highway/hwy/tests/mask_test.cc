#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
tests
/
mask_test
.
cc
"
#
include
"
hwy
/
foreach_target
.
h
"
#
include
"
hwy
/
highway
.
h
"
#
include
"
hwy
/
tests
/
test_util
-
inl
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
struct
TestFromVec
{
template
<
typename
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
size_t
N
=
Lanes
(
d
)
;
auto
lanes
=
AllocateAligned
<
T
>
(
N
)
;
memset
(
lanes
.
get
(
)
0
N
*
sizeof
(
T
)
)
;
const
auto
actual_false
=
MaskFromVec
(
Load
(
d
lanes
.
get
(
)
)
)
;
HWY_ASSERT_MASK_EQ
(
d
MaskFalse
(
d
)
actual_false
)
;
memset
(
lanes
.
get
(
)
0xFF
N
*
sizeof
(
T
)
)
;
const
auto
actual_true
=
MaskFromVec
(
Load
(
d
lanes
.
get
(
)
)
)
;
HWY_ASSERT_MASK_EQ
(
d
MaskTrue
(
d
)
actual_true
)
;
}
}
;
HWY_NOINLINE
void
TestAllFromVec
(
)
{
ForAllTypes
(
ForPartialVectors
<
TestFromVec
>
(
)
)
;
}
struct
TestFirstN
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
size_t
N
=
Lanes
(
d
)
;
auto
bool_lanes
=
AllocateAligned
<
T
>
(
N
)
;
using
TN
=
SignedFromSize
<
HWY_MIN
(
sizeof
(
size_t
)
sizeof
(
T
)
)
>
;
const
size_t
max_len
=
static_cast
<
size_t
>
(
LimitsMax
<
TN
>
(
)
)
;
const
size_t
max_lanes
=
HWY_MIN
(
2
*
N
AdjustedReps
(
512
)
)
;
for
(
size_t
len
=
0
;
len
<
=
HWY_MIN
(
max_lanes
max_len
)
;
+
+
len
)
{
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
bool_lanes
[
i
]
=
(
i
<
len
)
?
T
{
1
}
:
0
;
}
const
auto
expected
=
Eq
(
Load
(
d
bool_lanes
.
get
(
)
)
Set
(
d
T
{
1
}
)
)
;
HWY_ASSERT_MASK_EQ
(
d
expected
FirstN
(
d
len
)
)
;
}
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
bool_lanes
[
i
]
=
(
i
<
max_len
)
?
T
{
1
}
:
0
;
}
const
auto
expected
=
Eq
(
Load
(
d
bool_lanes
.
get
(
)
)
Set
(
d
T
{
1
}
)
)
;
HWY_ASSERT_MASK_EQ
(
d
expected
FirstN
(
d
max_len
)
)
;
}
}
;
HWY_NOINLINE
void
TestAllFirstN
(
)
{
ForAllTypes
(
ForPartialVectors
<
TestFirstN
>
(
)
)
;
}
struct
TestMaskVec
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
RandomState
rng
;
using
TI
=
MakeSigned
<
T
>
;
const
Rebind
<
TI
D
>
di
;
const
size_t
N
=
Lanes
(
d
)
;
auto
bool_lanes
=
AllocateAligned
<
TI
>
(
N
)
;
for
(
size_t
rep
=
0
;
rep
<
AdjustedReps
(
200
)
;
+
+
rep
)
{
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
bool_lanes
[
i
]
=
(
Random32
(
&
rng
)
&
1024
)
?
TI
(
1
)
:
TI
(
0
)
;
}
const
auto
mask
=
RebindMask
(
d
Gt
(
Load
(
di
bool_lanes
.
get
(
)
)
Zero
(
di
)
)
)
;
HWY_ASSERT_MASK_EQ
(
d
mask
MaskFromVec
(
VecFromMask
(
d
mask
)
)
)
;
}
}
}
;
HWY_NOINLINE
void
TestAllMaskVec
(
)
{
const
ForPartialVectors
<
TestMaskVec
>
test
;
test
(
uint16_t
(
)
)
;
test
(
int16_t
(
)
)
;
ForUIF3264
(
test
)
;
}
struct
TestAllTrueFalse
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
auto
zero
=
Zero
(
d
)
;
auto
v
=
zero
;
const
size_t
N
=
Lanes
(
d
)
;
auto
lanes
=
AllocateAligned
<
T
>
(
N
)
;
std
:
:
fill
(
lanes
.
get
(
)
lanes
.
get
(
)
+
N
T
(
0
)
)
;
HWY_ASSERT
(
AllTrue
(
d
Eq
(
v
zero
)
)
)
;
HWY_ASSERT
(
!
AllFalse
(
d
Eq
(
v
zero
)
)
)
;
const
bool
expected_all_false
=
(
N
!
=
1
)
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
lanes
[
i
]
=
T
(
1
)
;
v
=
Load
(
d
lanes
.
get
(
)
)
;
HWY_ASSERT
(
!
AllTrue
(
d
Eq
(
v
zero
)
)
)
;
HWY_ASSERT
(
expected_all_false
^
AllFalse
(
d
Eq
(
v
zero
)
)
)
;
lanes
[
i
]
=
T
(
-
1
)
;
v
=
Load
(
d
lanes
.
get
(
)
)
;
HWY_ASSERT
(
!
AllTrue
(
d
Eq
(
v
zero
)
)
)
;
HWY_ASSERT
(
expected_all_false
^
AllFalse
(
d
Eq
(
v
zero
)
)
)
;
lanes
[
i
]
=
T
(
0
)
;
v
=
Load
(
d
lanes
.
get
(
)
)
;
HWY_ASSERT
(
AllTrue
(
d
Eq
(
v
zero
)
)
)
;
HWY_ASSERT
(
!
AllFalse
(
d
Eq
(
v
zero
)
)
)
;
}
}
}
;
HWY_NOINLINE
void
TestAllAllTrueFalse
(
)
{
ForAllTypes
(
ForPartialVectors
<
TestAllTrueFalse
>
(
)
)
;
}
struct
TestCountTrue
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
using
TI
=
MakeSigned
<
T
>
;
const
Rebind
<
TI
D
>
di
;
const
size_t
N
=
Lanes
(
di
)
;
auto
bool_lanes
=
AllocateAligned
<
TI
>
(
N
)
;
memset
(
bool_lanes
.
get
(
)
0
N
*
sizeof
(
TI
)
)
;
const
size_t
max_lanes
=
HWY_MIN
(
N
size_t
(
10
)
)
;
for
(
size_t
code
=
0
;
code
<
(
1ull
<
<
max_lanes
)
;
+
+
code
)
{
size_t
expected
=
0
;
for
(
size_t
i
=
0
;
i
<
max_lanes
;
+
+
i
)
{
const
bool
is_true
=
(
code
&
(
1ull
<
<
i
)
)
!
=
0
;
bool_lanes
[
i
]
=
is_true
?
TI
(
1
)
:
TI
(
0
)
;
expected
+
=
is_true
;
}
const
auto
mask
=
RebindMask
(
d
Gt
(
Load
(
di
bool_lanes
.
get
(
)
)
Zero
(
di
)
)
)
;
const
size_t
actual
=
CountTrue
(
d
mask
)
;
HWY_ASSERT_EQ
(
expected
actual
)
;
}
}
}
;
HWY_NOINLINE
void
TestAllCountTrue
(
)
{
ForAllTypes
(
ForPartialVectors
<
TestCountTrue
>
(
)
)
;
}
struct
TestFindFirstTrue
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
using
TI
=
MakeSigned
<
T
>
;
const
Rebind
<
TI
D
>
di
;
const
size_t
N
=
Lanes
(
di
)
;
auto
bool_lanes
=
AllocateAligned
<
TI
>
(
N
)
;
memset
(
bool_lanes
.
get
(
)
0
N
*
sizeof
(
TI
)
)
;
const
size_t
max_lanes
=
AdjustedLog2Reps
(
HWY_MIN
(
N
size_t
(
9
)
)
)
;
HWY_ASSERT_EQ
(
intptr_t
(
-
1
)
FindFirstTrue
(
d
MaskFalse
(
d
)
)
)
;
HWY_ASSERT_EQ
(
intptr_t
(
0
)
FindFirstTrue
(
d
MaskTrue
(
d
)
)
)
;
HWY_ASSERT_EQ
(
size_t
(
0
)
FindKnownFirstTrue
(
d
MaskTrue
(
d
)
)
)
;
for
(
size_t
code
=
1
;
code
<
(
1ull
<
<
max_lanes
)
;
+
+
code
)
{
for
(
size_t
i
=
0
;
i
<
max_lanes
;
+
+
i
)
{
bool_lanes
[
i
]
=
(
code
&
(
1ull
<
<
i
)
)
?
TI
(
1
)
:
TI
(
0
)
;
}
const
size_t
expected
=
Num0BitsBelowLS1Bit_Nonzero32
(
static_cast
<
uint32_t
>
(
code
)
)
;
const
auto
mask
=
RebindMask
(
d
Gt
(
Load
(
di
bool_lanes
.
get
(
)
)
Zero
(
di
)
)
)
;
HWY_ASSERT_EQ
(
static_cast
<
intptr_t
>
(
expected
)
FindFirstTrue
(
d
mask
)
)
;
HWY_ASSERT_EQ
(
expected
FindKnownFirstTrue
(
d
mask
)
)
;
}
}
}
;
HWY_NOINLINE
void
TestAllFindFirstTrue
(
)
{
ForAllTypes
(
ForPartialVectors
<
TestFindFirstTrue
>
(
)
)
;
}
struct
TestLogicalMask
{
template
<
class
T
class
D
>
HWY_NOINLINE
void
operator
(
)
(
T
D
d
)
{
const
auto
m0
=
MaskFalse
(
d
)
;
const
auto
m_all
=
MaskTrue
(
d
)
;
using
TI
=
MakeSigned
<
T
>
;
const
Rebind
<
TI
D
>
di
;
const
size_t
N
=
Lanes
(
di
)
;
auto
bool_lanes
=
AllocateAligned
<
TI
>
(
N
)
;
memset
(
bool_lanes
.
get
(
)
0
N
*
sizeof
(
TI
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m0
Not
(
m_all
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m_all
Not
(
m0
)
)
;
Print
(
d
"
.
"
VecFromMask
(
d
ExclusiveNeither
(
m0
m0
)
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m_all
ExclusiveNeither
(
m0
m0
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m0
ExclusiveNeither
(
m_all
m0
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m0
ExclusiveNeither
(
m0
m_all
)
)
;
const
size_t
max_lanes
=
AdjustedLog2Reps
(
HWY_MIN
(
N
size_t
(
6
)
)
)
;
for
(
size_t
code
=
0
;
code
<
(
1ull
<
<
max_lanes
)
;
+
+
code
)
{
for
(
size_t
i
=
0
;
i
<
max_lanes
;
+
+
i
)
{
bool_lanes
[
i
]
=
(
code
&
(
1ull
<
<
i
)
)
?
TI
(
1
)
:
TI
(
0
)
;
}
const
auto
m
=
RebindMask
(
d
Gt
(
Load
(
di
bool_lanes
.
get
(
)
)
Zero
(
di
)
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m0
Xor
(
m
m
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m0
AndNot
(
m
m
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m0
AndNot
(
m_all
m
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m
Or
(
m
m
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m
Or
(
m0
m
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m
Or
(
m
m0
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m
Xor
(
m0
m
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m
Xor
(
m
m0
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m
And
(
m
m
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m
And
(
m_all
m
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m
And
(
m
m_all
)
)
;
HWY_ASSERT_MASK_EQ
(
d
m
AndNot
(
m0
m
)
)
;
}
}
}
;
HWY_NOINLINE
void
TestAllLogicalMask
(
)
{
ForAllTypes
(
ForPartialVectors
<
TestLogicalMask
>
(
)
)
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
hwy
{
HWY_BEFORE_TEST
(
HwyMaskTest
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMaskTest
TestAllFromVec
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMaskTest
TestAllFirstN
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMaskTest
TestAllMaskVec
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMaskTest
TestAllAllTrueFalse
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMaskTest
TestAllCountTrue
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMaskTest
TestAllFindFirstTrue
)
;
HWY_EXPORT_AND_TEST_P
(
HwyMaskTest
TestAllLogicalMask
)
;
}
#
endif
