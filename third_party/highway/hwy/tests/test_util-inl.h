#
include
<
stdint
.
h
>
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
tests
/
hwy_gtest
.
h
"
#
include
"
hwy
/
tests
/
test_util
.
h
"
#
include
"
hwy
/
print
-
inl
.
h
"
#
if
defined
(
HIGHWAY_HWY_TESTS_TEST_UTIL_INL_H_
)
=
=
\
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HIGHWAY_HWY_TESTS_TEST_UTIL_INL_H_
#
undef
HIGHWAY_HWY_TESTS_TEST_UTIL_INL_H_
#
else
#
define
HIGHWAY_HWY_TESTS_TEST_UTIL_INL_H_
#
endif
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
template
<
class
D
typename
T
=
TFromD
<
D
>
class
V
=
Vec
<
D
>
>
HWY_INLINE
void
AssertVecEqual
(
D
d
const
T
*
expected
VecArg
<
V
>
actual
const
char
*
filename
const
int
line
)
{
const
size_t
N
=
Lanes
(
d
)
;
auto
actual_lanes
=
AllocateAligned
<
T
>
(
N
)
;
Store
(
actual
d
actual_lanes
.
get
(
)
)
;
const
auto
info
=
hwy
:
:
detail
:
:
MakeTypeInfo
<
T
>
(
)
;
const
char
*
target_name
=
hwy
:
:
TargetName
(
HWY_TARGET
)
;
hwy
:
:
detail
:
:
AssertArrayEqual
(
info
expected
actual_lanes
.
get
(
)
N
target_name
filename
line
)
;
}
template
<
class
D
typename
T
=
TFromD
<
D
>
class
V
=
Vec
<
D
>
>
HWY_INLINE
void
AssertVecEqual
(
D
d
VecArg
<
V
>
expected
VecArg
<
V
>
actual
const
char
*
filename
int
line
)
{
auto
expected_lanes
=
AllocateAligned
<
T
>
(
Lanes
(
d
)
)
;
Store
(
expected
d
expected_lanes
.
get
(
)
)
;
AssertVecEqual
(
d
expected_lanes
.
get
(
)
actual
filename
line
)
;
}
template
<
class
D
>
HWY_NOINLINE
void
AssertMaskEqual
(
D
d
VecArg
<
Mask
<
D
>
>
a
VecArg
<
Mask
<
D
>
>
b
const
char
*
filename
int
line
)
{
const
Vec
<
D
>
va
=
VecFromMask
(
d
a
)
;
const
Vec
<
D
>
vb
=
VecFromMask
(
d
b
)
;
AssertVecEqual
(
d
va
vb
filename
line
)
;
const
char
*
target_name
=
hwy
:
:
TargetName
(
HWY_TARGET
)
;
AssertEqual
(
CountTrue
(
d
a
)
CountTrue
(
d
b
)
target_name
filename
line
)
;
AssertEqual
(
AllTrue
(
d
a
)
AllTrue
(
d
b
)
target_name
filename
line
)
;
AssertEqual
(
AllFalse
(
d
a
)
AllFalse
(
d
b
)
target_name
filename
line
)
;
const
size_t
N
=
Lanes
(
d
)
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
const
Rebind
<
uint8_t
D
>
d8
;
#
else
const
Repartition
<
uint8_t
D
>
d8
;
#
endif
const
size_t
N8
=
Lanes
(
d8
)
;
auto
bits_a
=
AllocateAligned
<
uint8_t
>
(
HWY_MAX
(
size_t
{
8
}
N8
)
)
;
auto
bits_b
=
AllocateAligned
<
uint8_t
>
(
size_t
{
HWY_MAX
(
8
N8
)
}
)
;
memset
(
bits_a
.
get
(
)
0
N8
)
;
memset
(
bits_b
.
get
(
)
0
N8
)
;
const
size_t
num_bytes_a
=
StoreMaskBits
(
d
a
bits_a
.
get
(
)
)
;
const
size_t
num_bytes_b
=
StoreMaskBits
(
d
b
bits_b
.
get
(
)
)
;
AssertEqual
(
num_bytes_a
num_bytes_b
target_name
filename
line
)
;
size_t
i
=
0
;
for
(
;
i
<
N
/
8
;
+
+
i
)
{
if
(
bits_a
[
i
]
!
=
bits_b
[
i
]
)
{
fprintf
(
stderr
"
Mismatch
in
byte
%
d
:
%
d
!
=
%
d
\
n
"
static_cast
<
int
>
(
i
)
bits_a
[
i
]
bits_b
[
i
]
)
;
Print
(
d8
"
expect
"
Load
(
d8
bits_a
.
get
(
)
)
0
N8
)
;
Print
(
d8
"
actual
"
Load
(
d8
bits_b
.
get
(
)
)
0
N8
)
;
hwy
:
:
Abort
(
filename
line
"
Masks
not
equal
"
)
;
}
}
const
size_t
remainder
=
N
%
8
;
if
(
remainder
!
=
0
)
{
const
int
mask
=
(
1
<
<
remainder
)
-
1
;
const
int
valid_a
=
bits_a
[
i
]
&
mask
;
const
int
valid_b
=
bits_b
[
i
]
&
mask
;
if
(
valid_a
!
=
valid_b
)
{
fprintf
(
stderr
"
Mismatch
in
last
byte
%
d
:
%
d
!
=
%
d
\
n
"
static_cast
<
int
>
(
i
)
valid_a
valid_b
)
;
Print
(
d8
"
expect
"
Load
(
d8
bits_a
.
get
(
)
)
0
N8
)
;
Print
(
d8
"
actual
"
Load
(
d8
bits_b
.
get
(
)
)
0
N8
)
;
hwy
:
:
Abort
(
filename
line
"
Masks
not
equal
"
)
;
}
}
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
MaskTrue
(
const
D
d
)
{
return
FirstN
(
d
Lanes
(
d
)
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
MaskFalse
(
const
D
d
)
{
const
auto
zero
=
Zero
(
RebindToSigned
<
D
>
(
)
)
;
return
RebindMask
(
d
Lt
(
zero
zero
)
)
;
}
#
ifndef
HWY_ASSERT_EQ
#
define
HWY_ASSERT_EQ
(
expected
actual
)
\
hwy
:
:
AssertEqual
(
expected
actual
hwy
:
:
TargetName
(
HWY_TARGET
)
__FILE__
\
__LINE__
)
#
define
HWY_ASSERT_ARRAY_EQ
(
expected
actual
count
)
\
hwy
:
:
AssertArrayEqual
(
expected
actual
count
hwy
:
:
TargetName
(
HWY_TARGET
)
\
__FILE__
__LINE__
)
#
define
HWY_ASSERT_STRING_EQ
(
expected
actual
)
\
hwy
:
:
AssertStringEqual
(
expected
actual
hwy
:
:
TargetName
(
HWY_TARGET
)
\
__FILE__
__LINE__
)
#
define
HWY_ASSERT_VEC_EQ
(
d
expected
actual
)
\
AssertVecEqual
(
d
expected
actual
__FILE__
__LINE__
)
#
define
HWY_ASSERT_MASK_EQ
(
d
expected
actual
)
\
AssertMaskEqual
(
d
expected
actual
__FILE__
__LINE__
)
#
endif
namespace
detail
{
template
<
typename
T
size_t
kMul
size_t
kMinArg
class
Test
>
struct
ForeachCappedR
{
static
void
Do
(
size_t
min_lanes
size_t
max_lanes
)
{
const
CappedTag
<
T
kMul
*
kMinArg
>
d
;
const
size_t
lanes
=
Lanes
(
d
)
;
if
(
lanes
<
min_lanes
)
return
;
if
(
lanes
<
=
max_lanes
)
{
Test
(
)
(
T
(
)
d
)
;
}
ForeachCappedR
<
T
kMul
/
2
kMinArg
Test
>
:
:
Do
(
min_lanes
max_lanes
)
;
}
}
;
template
<
typename
T
size_t
kMinArg
class
Test
>
struct
ForeachCappedR
<
T
0
kMinArg
Test
>
{
static
void
Do
(
size_t
size_t
)
{
}
}
;
#
if
HWY_HAVE_SCALABLE
template
<
typename
T
>
constexpr
int
MinPow2
(
)
{
return
HWY_MAX
(
-
3
-
static_cast
<
int
>
(
CeilLog2
(
16
/
sizeof
(
T
)
)
)
)
;
}
template
<
typename
T
int
kPow2
int
kAddPow2
class
Test
>
struct
ForeachShiftR
{
static
void
Do
(
size_t
min_lanes
)
{
const
ScalableTag
<
T
kPow2
+
kAddPow2
>
d
;
if
(
Lanes
(
d
)
>
=
min_lanes
)
{
Test
(
)
(
T
(
)
d
)
;
}
else
{
fprintf
(
stderr
"
%
d
lanes
<
%
d
:
T
=
%
d
pow
=
%
d
\
n
"
static_cast
<
int
>
(
Lanes
(
d
)
)
static_cast
<
int
>
(
min_lanes
)
static_cast
<
int
>
(
sizeof
(
T
)
)
kPow2
+
kAddPow2
)
;
HWY_ASSERT
(
min_lanes
!
=
1
)
;
}
ForeachShiftR
<
T
kPow2
+
1
kAddPow2
Test
>
:
:
Do
(
min_lanes
)
;
}
}
;
template
<
typename
T
int
kAddPow2
class
Test
>
struct
ForeachShiftR
<
T
4
kAddPow2
Test
>
{
static
void
Do
(
size_t
)
{
}
}
;
#
else
#
endif
}
template
<
class
Test
int
kPow2
=
1
>
class
ForExtendableVectors
{
mutable
bool
called_
=
false
;
public
:
~
ForExtendableVectors
(
)
{
if
(
!
called_
)
{
HWY_ABORT
(
"
Test
is
incorrect
ensure
operator
(
)
is
called
"
)
;
}
}
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
called_
=
true
;
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
const
size_t
max_lanes
=
Lanes
(
ScalableTag
<
T
>
(
)
)
>
>
kPow2
;
(
void
)
kMaxCapped
;
(
void
)
max_lanes
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
#
else
detail
:
:
ForeachCappedR
<
T
(
kMaxCapped
>
>
kPow2
)
1
Test
>
:
:
Do
(
1
max_lanes
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
detail
:
:
ForeachShiftR
<
T
detail
:
:
MinPow2
<
T
>
(
)
+
kPow2
-
kPow2
Test
>
:
:
Do
(
1
)
;
#
elif
HWY_HAVE_SCALABLE
detail
:
:
ForeachShiftR
<
T
detail
:
:
MinPow2
<
T
>
(
)
+
kPow2
+
3
-
kPow2
-
3
Test
>
:
:
Do
(
1
)
;
#
endif
#
endif
}
}
;
template
<
class
Test
int
kPow2
=
1
>
class
ForShrinkableVectors
{
mutable
bool
called_
=
false
;
public
:
~
ForShrinkableVectors
(
)
{
if
(
!
called_
)
{
HWY_ABORT
(
"
Test
is
incorrect
ensure
operator
(
)
is
called
"
)
;
}
}
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
called_
=
true
;
constexpr
size_t
kMinLanes
=
size_t
{
1
}
<
<
kPow2
;
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
constexpr
size_t
max_lanes
=
kMaxCapped
;
(
void
)
kMinLanes
;
(
void
)
max_lanes
;
(
void
)
max_lanes
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
#
else
detail
:
:
ForeachCappedR
<
T
(
kMaxCapped
>
>
kPow2
)
kMinLanes
Test
>
:
:
Do
(
kMinLanes
max_lanes
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
detail
:
:
ForeachShiftR
<
T
detail
:
:
MinPow2
<
T
>
(
)
+
kPow2
0
Test
>
:
:
Do
(
kMinLanes
)
;
#
elif
HWY_HAVE_SCALABLE
detail
:
:
ForeachShiftR
<
T
detail
:
:
MinPow2
<
T
>
(
)
+
kPow2
+
3
-
3
Test
>
:
:
Do
(
kMinLanes
)
;
#
endif
#
endif
}
}
;
template
<
size_t
kMinBits
class
Test
>
class
ForGEVectors
{
mutable
bool
called_
=
false
;
public
:
~
ForGEVectors
(
)
{
if
(
!
called_
)
{
HWY_ABORT
(
"
Test
is
incorrect
ensure
operator
(
)
is
called
"
)
;
}
}
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
called_
=
true
;
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
constexpr
size_t
kMinLanes
=
kMinBits
/
8
/
sizeof
(
T
)
;
constexpr
size_t
max_lanes
=
kMaxCapped
;
(
void
)
max_lanes
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
(
void
)
kMinLanes
;
#
else
detail
:
:
ForeachCappedR
<
T
HWY_LANES
(
T
)
/
kMinLanes
kMinLanes
Test
>
:
:
Do
(
kMinLanes
max_lanes
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
constexpr
size_t
kRatio
=
128
/
kMinBits
;
constexpr
int
kMinPow2
=
kRatio
=
=
0
?
0
:
-
static_cast
<
int
>
(
CeilLog2
(
kRatio
)
)
;
detail
:
:
ForeachShiftR
<
T
kMinPow2
0
Test
>
:
:
Do
(
kMinLanes
)
;
#
elif
HWY_HAVE_SCALABLE
constexpr
size_t
kRatio
=
128
/
kMinBits
;
constexpr
int
kMinPow2
=
kRatio
=
=
0
?
0
:
-
static_cast
<
int
>
(
CeilLog2
(
kRatio
)
)
;
detail
:
:
ForeachShiftR
<
T
kMinPow2
+
3
-
3
Test
>
:
:
Do
(
kMinLanes
)
;
#
endif
#
endif
}
}
;
template
<
class
Test
>
using
ForGE128Vectors
=
ForGEVectors
<
128
Test
>
;
template
<
class
Test
int
kPow2
=
1
>
class
ForPromoteVectors
{
mutable
bool
called_
=
false
;
public
:
~
ForPromoteVectors
(
)
{
if
(
!
called_
)
{
HWY_ABORT
(
"
Test
is
incorrect
ensure
operator
(
)
is
called
"
)
;
}
}
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
called_
=
true
;
constexpr
size_t
kFactor
=
size_t
{
1
}
<
<
kPow2
;
static_assert
(
kFactor
>
=
2
&
&
kFactor
*
sizeof
(
T
)
<
=
sizeof
(
uint64_t
)
"
"
)
;
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
constexpr
size_t
kMinLanes
=
kFactor
;
const
size_t
max_lanes
=
Lanes
(
ScalableTag
<
T
>
(
)
)
>
>
kPow2
;
(
void
)
kMaxCapped
;
(
void
)
kMinLanes
;
(
void
)
max_lanes
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
detail
:
:
ForeachCappedR
<
T
1
1
Test
>
:
:
Do
(
1
1
)
;
#
else
detail
:
:
ForeachCappedR
<
T
(
kMaxCapped
>
>
kPow2
)
1
Test
>
:
:
Do
(
kMinLanes
max_lanes
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
detail
:
:
ForeachShiftR
<
T
detail
:
:
MinPow2
<
T
>
(
)
+
kPow2
-
kPow2
Test
>
:
:
Do
(
kMinLanes
)
;
#
elif
HWY_HAVE_SCALABLE
detail
:
:
ForeachShiftR
<
T
detail
:
:
MinPow2
<
T
>
(
)
+
kPow2
+
3
-
kPow2
-
3
Test
>
:
:
Do
(
kMinLanes
)
;
#
endif
#
endif
}
}
;
template
<
class
Test
int
kPow2
=
1
>
class
ForDemoteVectors
{
mutable
bool
called_
=
false
;
public
:
~
ForDemoteVectors
(
)
{
if
(
!
called_
)
{
HWY_ABORT
(
"
Test
is
incorrect
ensure
operator
(
)
is
called
"
)
;
}
}
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
called_
=
true
;
constexpr
size_t
kMinLanes
=
size_t
{
1
}
<
<
kPow2
;
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
constexpr
size_t
max_lanes
=
kMaxCapped
;
(
void
)
kMinLanes
;
(
void
)
max_lanes
;
(
void
)
max_lanes
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
detail
:
:
ForeachCappedR
<
T
1
1
Test
>
:
:
Do
(
1
1
)
;
#
else
detail
:
:
ForeachCappedR
<
T
(
kMaxCapped
>
>
kPow2
)
kMinLanes
Test
>
:
:
Do
(
kMinLanes
max_lanes
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
detail
:
:
ForeachShiftR
<
T
detail
:
:
MinPow2
<
T
>
(
)
+
kPow2
0
Test
>
:
:
Do
(
kMinLanes
)
;
#
elif
HWY_HAVE_SCALABLE
detail
:
:
ForeachShiftR
<
T
detail
:
:
MinPow2
<
T
>
(
)
+
kPow2
+
3
-
3
Test
>
:
:
Do
(
kMinLanes
)
;
#
endif
#
endif
}
}
;
template
<
class
Test
int
kPow2
=
1
>
class
ForHalfVectors
{
mutable
bool
called_
=
false
;
public
:
~
ForHalfVectors
(
)
{
if
(
!
called_
)
{
HWY_ABORT
(
"
Test
is
incorrect
ensure
operator
(
)
is
called
"
)
;
}
}
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
called_
=
true
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
detail
:
:
ForeachCappedR
<
T
1
1
Test
>
:
:
Do
(
1
1
)
;
#
else
constexpr
size_t
kMinLanes
=
size_t
{
1
}
<
<
kPow2
;
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
detail
:
:
ForeachCappedR
<
T
(
kMaxCapped
>
>
kPow2
)
kMinLanes
Test
>
:
:
Do
(
kMinLanes
kMaxCapped
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
detail
:
:
ForeachShiftR
<
T
detail
:
:
MinPow2
<
T
>
(
)
+
kPow2
0
Test
>
:
:
Do
(
kMinLanes
)
;
#
elif
HWY_HAVE_SCALABLE
detail
:
:
ForeachShiftR
<
T
detail
:
:
MinPow2
<
T
>
(
)
+
kPow2
+
3
-
3
Test
>
:
:
Do
(
kMinLanes
)
;
#
endif
#
endif
}
}
;
template
<
class
Test
>
class
ForPartialVectors
{
mutable
bool
called_
=
false
;
public
:
~
ForPartialVectors
(
)
{
if
(
!
called_
)
{
HWY_ABORT
(
"
Test
is
incorrect
ensure
operator
(
)
is
called
"
)
;
}
}
template
<
typename
T
>
void
operator
(
)
(
T
t
)
const
{
called_
=
true
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
(
void
)
t
;
detail
:
:
ForeachCappedR
<
T
1
1
Test
>
:
:
Do
(
1
1
)
;
#
else
ForExtendableVectors
<
Test
0
>
(
)
(
t
)
;
#
endif
}
}
;
template
<
class
Func
>
void
ForSignedTypes
(
const
Func
&
func
)
{
func
(
int8_t
(
)
)
;
func
(
int16_t
(
)
)
;
func
(
int32_t
(
)
)
;
#
if
HWY_HAVE_INTEGER64
func
(
int64_t
(
)
)
;
#
endif
}
template
<
class
Func
>
void
ForUnsignedTypes
(
const
Func
&
func
)
{
func
(
uint8_t
(
)
)
;
func
(
uint16_t
(
)
)
;
func
(
uint32_t
(
)
)
;
#
if
HWY_HAVE_INTEGER64
func
(
uint64_t
(
)
)
;
#
endif
}
template
<
class
Func
>
void
ForIntegerTypes
(
const
Func
&
func
)
{
ForSignedTypes
(
func
)
;
ForUnsignedTypes
(
func
)
;
}
template
<
class
Func
>
void
ForFloatTypes
(
const
Func
&
func
)
{
func
(
float
(
)
)
;
#
if
HWY_HAVE_FLOAT64
func
(
double
(
)
)
;
#
endif
}
template
<
class
Func
>
void
ForAllTypes
(
const
Func
&
func
)
{
ForIntegerTypes
(
func
)
;
ForFloatTypes
(
func
)
;
}
template
<
class
Func
>
void
ForUI8
(
const
Func
&
func
)
{
func
(
uint8_t
(
)
)
;
func
(
int8_t
(
)
)
;
}
template
<
class
Func
>
void
ForUI16
(
const
Func
&
func
)
{
func
(
uint16_t
(
)
)
;
func
(
int16_t
(
)
)
;
}
template
<
class
Func
>
void
ForUIF16
(
const
Func
&
func
)
{
ForUI16
(
func
)
;
#
if
HWY_HAVE_FLOAT16
func
(
float16_t
(
)
)
;
#
endif
}
template
<
class
Func
>
void
ForUI32
(
const
Func
&
func
)
{
func
(
uint32_t
(
)
)
;
func
(
int32_t
(
)
)
;
}
template
<
class
Func
>
void
ForUIF32
(
const
Func
&
func
)
{
ForUI32
(
func
)
;
func
(
float
(
)
)
;
}
template
<
class
Func
>
void
ForUI64
(
const
Func
&
func
)
{
#
if
HWY_HAVE_INTEGER64
func
(
uint64_t
(
)
)
;
func
(
int64_t
(
)
)
;
#
endif
}
template
<
class
Func
>
void
ForUIF64
(
const
Func
&
func
)
{
ForUI64
(
func
)
;
#
if
HWY_HAVE_FLOAT64
func
(
double
(
)
)
;
#
endif
}
template
<
class
Func
>
void
ForUI3264
(
const
Func
&
func
)
{
ForUI32
(
func
)
;
ForUI64
(
func
)
;
}
template
<
class
Func
>
void
ForUIF3264
(
const
Func
&
func
)
{
ForUIF32
(
func
)
;
ForUIF64
(
func
)
;
}
template
<
class
Func
>
void
ForUI163264
(
const
Func
&
func
)
{
ForUI16
(
func
)
;
ForUI3264
(
func
)
;
}
template
<
class
Func
>
void
ForUIF163264
(
const
Func
&
func
)
{
ForUIF16
(
func
)
;
ForUIF3264
(
func
)
;
}
constexpr
size_t
AdjustedReps
(
size_t
max_reps
)
{
#
if
HWY_ARCH_RVV
return
HWY_MAX
(
max_reps
/
32
2
)
;
#
elif
HWY_IS_DEBUG_BUILD
return
HWY_MAX
(
max_reps
/
8
2
)
;
#
elif
HWY_ARCH_ARM
return
HWY_MAX
(
max_reps
/
4
2
)
;
#
else
return
HWY_MAX
(
max_reps
2
)
;
#
endif
}
constexpr
size_t
AdjustedLog2Reps
(
size_t
max_pow2
)
{
#
if
HWY_ARCH_RVV
return
HWY_MIN
(
max_pow2
-
4
max_pow2
)
;
#
elif
HWY_IS_DEBUG_BUILD
return
HWY_MIN
(
max_pow2
-
1
max_pow2
)
;
#
elif
HWY_ARCH_ARM
return
HWY_MIN
(
max_pow2
-
1
max_pow2
)
;
#
else
return
max_pow2
;
#
endif
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
