#
include
<
inttypes
.
h
>
#
include
<
stdint
.
h
>
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
tests
/
hwy_gtest
.
h
"
#
include
"
hwy
/
tests
/
test_util
.
h
"
#
if
defined
(
HIGHWAY_HWY_TESTS_TEST_UTIL_INL_H_
)
=
=
\
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HIGHWAY_HWY_TESTS_TEST_UTIL_INL_H_
#
undef
HIGHWAY_HWY_TESTS_TEST_UTIL_INL_H_
#
else
#
define
HIGHWAY_HWY_TESTS_TEST_UTIL_INL_H_
#
endif
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
template
<
typename
T
HWY_IF_LANE_SIZE
(
T
1
)
>
HWY_NOINLINE
void
PrintValue
(
T
value
)
{
uint8_t
byte
;
CopyBytes
<
1
>
(
&
value
&
byte
)
;
fprintf
(
stderr
"
0x
%
02X
"
byte
)
;
}
#
if
HWY_HAVE_FLOAT16
HWY_NOINLINE
void
PrintValue
(
float16_t
value
)
{
uint16_t
bits
;
CopyBytes
<
2
>
(
&
value
&
bits
)
;
fprintf
(
stderr
"
0x
%
02X
"
bits
)
;
}
#
endif
template
<
typename
T
HWY_IF_NOT_LANE_SIZE
(
T
1
)
>
HWY_NOINLINE
void
PrintValue
(
T
value
)
{
fprintf
(
stderr
"
%
g
"
double
(
value
)
)
;
}
template
<
class
D
class
V
=
Vec
<
D
>
>
void
Print
(
const
D
d
const
char
*
caption
VecArg
<
V
>
v
size_t
lane_u
=
0
size_t
max_lanes
=
7
)
{
using
T
=
TFromD
<
D
>
;
const
size_t
N
=
Lanes
(
d
)
;
auto
lanes
=
AllocateAligned
<
T
>
(
N
)
;
Store
(
v
d
lanes
.
get
(
)
)
;
const
auto
info
=
hwy
:
:
detail
:
:
MakeTypeInfo
<
T
>
(
)
;
hwy
:
:
detail
:
:
PrintArray
(
info
caption
lanes
.
get
(
)
N
lane_u
max_lanes
)
;
}
template
<
class
D
typename
T
=
TFromD
<
D
>
class
V
=
Vec
<
D
>
>
HWY_INLINE
void
AssertVecEqual
(
D
d
const
T
*
expected
VecArg
<
V
>
actual
const
char
*
filename
const
int
line
)
{
const
size_t
N
=
Lanes
(
d
)
;
auto
actual_lanes
=
AllocateAligned
<
T
>
(
N
)
;
Store
(
actual
d
actual_lanes
.
get
(
)
)
;
const
auto
info
=
hwy
:
:
detail
:
:
MakeTypeInfo
<
T
>
(
)
;
const
char
*
target_name
=
hwy
:
:
TargetName
(
HWY_TARGET
)
;
hwy
:
:
detail
:
:
AssertArrayEqual
(
info
expected
actual_lanes
.
get
(
)
N
target_name
filename
line
)
;
}
template
<
class
D
typename
T
=
TFromD
<
D
>
class
V
=
Vec
<
D
>
>
HWY_INLINE
void
AssertVecEqual
(
D
d
VecArg
<
V
>
expected
VecArg
<
V
>
actual
const
char
*
filename
int
line
)
{
auto
expected_lanes
=
AllocateAligned
<
T
>
(
Lanes
(
d
)
)
;
Store
(
expected
d
expected_lanes
.
get
(
)
)
;
AssertVecEqual
(
d
expected_lanes
.
get
(
)
actual
filename
line
)
;
}
template
<
class
D
>
HWY_NOINLINE
void
AssertMaskEqual
(
D
d
VecArg
<
Mask
<
D
>
>
a
VecArg
<
Mask
<
D
>
>
b
const
char
*
filename
int
line
)
{
const
Vec
<
D
>
va
=
VecFromMask
(
d
a
)
;
const
Vec
<
D
>
vb
=
VecFromMask
(
d
b
)
;
AssertVecEqual
(
d
va
vb
filename
line
)
;
const
char
*
target_name
=
hwy
:
:
TargetName
(
HWY_TARGET
)
;
AssertEqual
(
CountTrue
(
d
a
)
CountTrue
(
d
b
)
target_name
filename
line
)
;
AssertEqual
(
AllTrue
(
d
a
)
AllTrue
(
d
b
)
target_name
filename
line
)
;
AssertEqual
(
AllFalse
(
d
a
)
AllFalse
(
d
b
)
target_name
filename
line
)
;
#
if
HWY_TARGET
!
=
HWY_RVV
&
&
HWY_TARGET
!
=
HWY_SCALAR
const
size_t
N
=
Lanes
(
d
)
;
const
Repartition
<
uint8_t
D
>
d8
;
const
size_t
N8
=
Lanes
(
d8
)
;
auto
bits_a
=
AllocateAligned
<
uint8_t
>
(
HWY_MAX
(
8
N8
)
)
;
auto
bits_b
=
AllocateAligned
<
uint8_t
>
(
HWY_MAX
(
8
N8
)
)
;
memset
(
bits_a
.
get
(
)
0
N8
)
;
memset
(
bits_b
.
get
(
)
0
N8
)
;
const
size_t
num_bytes_a
=
StoreMaskBits
(
d
a
bits_a
.
get
(
)
)
;
const
size_t
num_bytes_b
=
StoreMaskBits
(
d
b
bits_b
.
get
(
)
)
;
AssertEqual
(
num_bytes_a
num_bytes_b
target_name
filename
line
)
;
size_t
i
=
0
;
for
(
;
i
<
N
/
8
;
+
+
i
)
{
if
(
bits_a
[
i
]
!
=
bits_b
[
i
]
)
{
fprintf
(
stderr
"
Mismatch
in
byte
%
"
PRIu64
"
:
%
d
!
=
%
d
\
n
"
static_cast
<
uint64_t
>
(
i
)
bits_a
[
i
]
bits_b
[
i
]
)
;
Print
(
d8
"
expect
"
Load
(
d8
bits_a
.
get
(
)
)
0
N8
)
;
Print
(
d8
"
actual
"
Load
(
d8
bits_b
.
get
(
)
)
0
N8
)
;
hwy
:
:
Abort
(
filename
line
"
Masks
not
equal
"
)
;
}
}
const
size_t
remainder
=
N
%
8
;
if
(
remainder
!
=
0
)
{
const
int
mask
=
(
1
<
<
remainder
)
-
1
;
const
int
valid_a
=
bits_a
[
i
]
&
mask
;
const
int
valid_b
=
bits_b
[
i
]
&
mask
;
if
(
valid_a
!
=
valid_b
)
{
fprintf
(
stderr
"
Mismatch
in
last
byte
%
"
PRIu64
"
:
%
d
!
=
%
d
\
n
"
static_cast
<
uint64_t
>
(
i
)
valid_a
valid_b
)
;
Print
(
d8
"
expect
"
Load
(
d8
bits_a
.
get
(
)
)
0
N8
)
;
Print
(
d8
"
actual
"
Load
(
d8
bits_b
.
get
(
)
)
0
N8
)
;
hwy
:
:
Abort
(
filename
line
"
Masks
not
equal
"
)
;
}
}
#
endif
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
MaskTrue
(
const
D
d
)
{
return
FirstN
(
d
Lanes
(
d
)
)
;
}
template
<
class
D
>
HWY_INLINE
Mask
<
D
>
MaskFalse
(
const
D
d
)
{
const
auto
zero
=
Zero
(
RebindToSigned
<
D
>
(
)
)
;
return
RebindMask
(
d
Lt
(
zero
zero
)
)
;
}
#
ifndef
HWY_ASSERT_EQ
#
define
HWY_ASSERT_EQ
(
expected
actual
)
\
hwy
:
:
AssertEqual
(
expected
actual
hwy
:
:
TargetName
(
HWY_TARGET
)
__FILE__
\
__LINE__
)
#
define
HWY_ASSERT_STRING_EQ
(
expected
actual
)
\
hwy
:
:
AssertStringEqual
(
expected
actual
hwy
:
:
TargetName
(
HWY_TARGET
)
\
__FILE__
__LINE__
)
#
define
HWY_ASSERT_VEC_EQ
(
d
expected
actual
)
\
AssertVecEqual
(
d
expected
actual
__FILE__
__LINE__
)
#
define
HWY_ASSERT_MASK_EQ
(
d
expected
actual
)
\
AssertMaskEqual
(
d
expected
actual
__FILE__
__LINE__
)
#
endif
template
<
typename
T
size_t
kMul
size_t
kMinArg
class
Test
>
struct
ForeachCappedR
{
static
void
Do
(
size_t
min_lanes
size_t
max_lanes
)
{
const
CappedTag
<
T
kMul
*
kMinArg
>
d
;
const
size_t
lanes
=
Lanes
(
d
)
;
if
(
lanes
<
min_lanes
)
return
;
if
(
lanes
<
=
max_lanes
)
{
Test
(
)
(
T
(
)
d
)
;
}
ForeachCappedR
<
T
kMul
/
2
kMinArg
Test
>
:
:
Do
(
min_lanes
max_lanes
)
;
}
}
;
template
<
typename
T
size_t
kMinArg
class
Test
>
struct
ForeachCappedR
<
T
0
kMinArg
Test
>
{
static
void
Do
(
size_t
size_t
)
{
}
}
;
#
if
HWY_HAVE_SCALABLE
constexpr
int
MinVectorSize
(
)
{
#
if
HWY_TARGET
=
=
HWY_RVV
return
8
;
#
else
return
16
;
#
endif
}
template
<
typename
T
>
constexpr
int
MinPow2
(
)
{
return
HWY_MAX
(
-
3
-
static_cast
<
int
>
(
CeilLog2
(
MinVectorSize
(
)
/
sizeof
(
T
)
)
)
)
;
}
template
<
typename
T
int
kPow2
int
kAddPow2
class
Test
>
struct
ForeachShiftR
{
static
void
Do
(
size_t
min_lanes
)
{
const
ScalableTag
<
T
kPow2
+
kAddPow2
>
d
;
if
(
Lanes
(
d
)
>
=
min_lanes
)
{
Test
(
)
(
T
(
)
d
)
;
}
else
{
fprintf
(
stderr
"
%
d
lanes
<
%
d
:
T
=
%
d
pow
=
%
d
\
n
"
static_cast
<
int
>
(
Lanes
(
d
)
)
static_cast
<
int
>
(
min_lanes
)
static_cast
<
int
>
(
sizeof
(
T
)
)
kPow2
+
kAddPow2
)
;
HWY_ASSERT
(
min_lanes
!
=
1
)
;
}
ForeachShiftR
<
T
kPow2
+
1
kAddPow2
Test
>
:
:
Do
(
min_lanes
)
;
}
}
;
template
<
typename
T
int
kAddPow2
class
Test
>
struct
ForeachShiftR
<
T
4
kAddPow2
Test
>
{
static
void
Do
(
size_t
)
{
}
}
;
#
else
#
endif
template
<
class
Test
int
kPow2
=
1
>
struct
ForExtendableVectors
{
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
const
size_t
max_lanes
=
Lanes
(
ScalableTag
<
T
>
(
)
)
>
>
kPow2
;
(
void
)
kMaxCapped
;
(
void
)
max_lanes
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
#
else
ForeachCappedR
<
T
(
kMaxCapped
>
>
kPow2
)
1
Test
>
:
:
Do
(
1
max_lanes
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
ForeachShiftR
<
T
MinPow2
<
T
>
(
)
+
kPow2
-
kPow2
Test
>
:
:
Do
(
1
)
;
#
elif
HWY_HAVE_SCALABLE
ForeachShiftR
<
T
MinPow2
<
T
>
(
)
+
kPow2
+
3
-
kPow2
-
3
Test
>
:
:
Do
(
1
)
;
#
endif
#
endif
}
}
;
template
<
class
Test
int
kPow2
=
1
>
struct
ForShrinkableVectors
{
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
constexpr
size_t
kMinLanes
=
size_t
{
1
}
<
<
kPow2
;
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
constexpr
size_t
max_lanes
=
kMaxCapped
;
(
void
)
kMinLanes
;
(
void
)
max_lanes
;
(
void
)
max_lanes
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
#
else
ForeachCappedR
<
T
(
kMaxCapped
>
>
kPow2
)
kMinLanes
Test
>
:
:
Do
(
kMinLanes
max_lanes
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
ForeachShiftR
<
T
MinPow2
<
T
>
(
)
+
kPow2
0
Test
>
:
:
Do
(
kMinLanes
)
;
#
elif
HWY_HAVE_SCALABLE
ForeachShiftR
<
T
MinPow2
<
T
>
(
)
+
kPow2
+
3
-
3
Test
>
:
:
Do
(
kMinLanes
)
;
#
endif
#
endif
}
}
;
template
<
size_t
kMinBits
class
Test
>
struct
ForGEVectors
{
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
constexpr
size_t
kMinLanes
=
kMinBits
/
8
/
sizeof
(
T
)
;
constexpr
size_t
max_lanes
=
kMaxCapped
;
(
void
)
max_lanes
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
(
void
)
kMinLanes
;
#
else
ForeachCappedR
<
T
HWY_LANES
(
T
)
/
kMinLanes
kMinLanes
Test
>
:
:
Do
(
kMinLanes
max_lanes
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
constexpr
size_t
kRatio
=
MinVectorSize
(
)
*
8
/
kMinBits
;
constexpr
int
kMinPow2
=
kRatio
=
=
0
?
0
:
-
static_cast
<
int
>
(
CeilLog2
(
kRatio
)
)
;
ForeachShiftR
<
T
kMinPow2
0
Test
>
:
:
Do
(
kMinLanes
)
;
#
elif
HWY_HAVE_SCALABLE
constexpr
size_t
kRatio
=
MinVectorSize
(
)
*
8
/
kMinBits
;
constexpr
int
kMinPow2
=
kRatio
=
=
0
?
0
:
-
static_cast
<
int
>
(
CeilLog2
(
kRatio
)
)
;
ForeachShiftR
<
T
kMinPow2
+
3
-
3
Test
>
:
:
Do
(
kMinLanes
)
;
#
endif
#
endif
}
}
;
template
<
class
Test
>
using
ForGE128Vectors
=
ForGEVectors
<
128
Test
>
;
template
<
class
Test
int
kPow2
=
1
>
struct
ForPromoteVectors
{
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
constexpr
size_t
kFactor
=
size_t
{
1
}
<
<
kPow2
;
static_assert
(
kFactor
>
=
2
&
&
kFactor
*
sizeof
(
T
)
<
=
sizeof
(
uint64_t
)
"
"
)
;
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
constexpr
size_t
kMinLanes
=
kFactor
;
const
size_t
max_lanes
=
Lanes
(
ScalableTag
<
T
>
(
)
)
>
>
kPow2
;
(
void
)
kMaxCapped
;
(
void
)
kMinLanes
;
(
void
)
max_lanes
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
ForeachCappedR
<
T
1
1
Test
>
:
:
Do
(
1
1
)
;
#
else
ForeachCappedR
<
T
(
kMaxCapped
>
>
kPow2
)
1
Test
>
:
:
Do
(
kMinLanes
max_lanes
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
ForeachShiftR
<
T
MinPow2
<
T
>
(
)
+
kPow2
-
kPow2
Test
>
:
:
Do
(
kMinLanes
)
;
#
elif
HWY_HAVE_SCALABLE
ForeachShiftR
<
T
MinPow2
<
T
>
(
)
+
kPow2
+
3
-
kPow2
-
3
Test
>
:
:
Do
(
kMinLanes
)
;
#
endif
#
endif
}
}
;
template
<
class
Test
int
kPow2
=
1
>
struct
ForDemoteVectors
{
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
constexpr
size_t
kMinLanes
=
size_t
{
1
}
<
<
kPow2
;
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
constexpr
size_t
max_lanes
=
kMaxCapped
;
(
void
)
kMinLanes
;
(
void
)
max_lanes
;
(
void
)
max_lanes
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
ForeachCappedR
<
T
1
1
Test
>
:
:
Do
(
1
1
)
;
#
else
ForeachCappedR
<
T
(
kMaxCapped
>
>
kPow2
)
kMinLanes
Test
>
:
:
Do
(
kMinLanes
max_lanes
)
;
#
if
HWY_TARGET
=
=
HWY_RVV
ForeachShiftR
<
T
MinPow2
<
T
>
(
)
+
kPow2
0
Test
>
:
:
Do
(
kMinLanes
)
;
#
elif
HWY_HAVE_SCALABLE
ForeachShiftR
<
T
MinPow2
<
T
>
(
)
+
kPow2
+
3
-
3
Test
>
:
:
Do
(
kMinLanes
)
;
#
endif
#
endif
}
}
;
template
<
class
Test
int
kPow2
=
1
>
struct
ForHalfVectors
{
template
<
typename
T
>
void
operator
(
)
(
T
)
const
{
constexpr
size_t
kMinLanes
=
size_t
{
1
}
<
<
kPow2
;
constexpr
size_t
kMaxCapped
=
HWY_LANES
(
T
)
;
constexpr
size_t
max_lanes
=
kMaxCapped
;
(
void
)
kMinLanes
;
(
void
)
max_lanes
;
(
void
)
max_lanes
;
#
if
HWY_TARGET
=
=
HWY_SCALAR
ForeachCappedR
<
T
1
1
Test
>
:
:
Do
(
1
1
)
;
#
else
#
if
HWY_TARGET
=
=
HWY_RVV
ForeachShiftR
<
T
MinPow2
<
T
>
(
)
+
kPow2
0
Test
>
:
:
Do
(
kMinLanes
)
;
#
elif
HWY_HAVE_SCALABLE
ForeachShiftR
<
T
MinPow2
<
T
>
(
)
+
kPow2
+
3
-
3
Test
>
:
:
Do
(
kMinLanes
)
;
#
endif
#
endif
}
}
;
template
<
class
Test
>
struct
ForPartialVectors
{
template
<
typename
T
>
void
operator
(
)
(
T
t
)
const
{
ForExtendableVectors
<
Test
0
>
(
)
(
t
)
;
}
}
;
template
<
class
Func
>
void
ForSignedTypes
(
const
Func
&
func
)
{
func
(
int8_t
(
)
)
;
func
(
int16_t
(
)
)
;
func
(
int32_t
(
)
)
;
#
if
HWY_HAVE_INTEGER64
func
(
int64_t
(
)
)
;
#
endif
}
template
<
class
Func
>
void
ForUnsignedTypes
(
const
Func
&
func
)
{
func
(
uint8_t
(
)
)
;
func
(
uint16_t
(
)
)
;
func
(
uint32_t
(
)
)
;
#
if
HWY_HAVE_INTEGER64
func
(
uint64_t
(
)
)
;
#
endif
}
template
<
class
Func
>
void
ForIntegerTypes
(
const
Func
&
func
)
{
ForSignedTypes
(
func
)
;
ForUnsignedTypes
(
func
)
;
}
template
<
class
Func
>
void
ForFloatTypes
(
const
Func
&
func
)
{
func
(
float
(
)
)
;
#
if
HWY_HAVE_FLOAT64
func
(
double
(
)
)
;
#
endif
}
template
<
class
Func
>
void
ForAllTypes
(
const
Func
&
func
)
{
ForIntegerTypes
(
func
)
;
ForFloatTypes
(
func
)
;
}
template
<
class
Func
>
void
ForUIF16
(
const
Func
&
func
)
{
func
(
uint16_t
(
)
)
;
func
(
int16_t
(
)
)
;
#
if
HWY_HAVE_FLOAT16
func
(
float16_t
(
)
)
;
#
endif
}
template
<
class
Func
>
void
ForUIF32
(
const
Func
&
func
)
{
func
(
uint32_t
(
)
)
;
func
(
int32_t
(
)
)
;
func
(
float
(
)
)
;
}
template
<
class
Func
>
void
ForUIF64
(
const
Func
&
func
)
{
#
if
HWY_HAVE_INTEGER64
func
(
uint64_t
(
)
)
;
func
(
int64_t
(
)
)
;
#
endif
#
if
HWY_HAVE_FLOAT64
func
(
double
(
)
)
;
#
endif
}
template
<
class
Func
>
void
ForUIF3264
(
const
Func
&
func
)
{
ForUIF32
(
func
)
;
ForUIF64
(
func
)
;
}
template
<
class
Func
>
void
ForUIF163264
(
const
Func
&
func
)
{
ForUIF16
(
func
)
;
ForUIF3264
(
func
)
;
}
constexpr
size_t
AdjustedReps
(
size_t
max_reps
)
{
#
if
HWY_ARCH_RVV
return
HWY_MAX
(
max_reps
/
32
2
)
;
#
elif
HWY_ARCH_ARM
return
HWY_MAX
(
max_reps
/
4
2
)
;
#
elif
HWY_IS_DEBUG_BUILD
return
HWY_MAX
(
max_reps
/
8
2
)
;
#
else
return
HWY_MAX
(
max_reps
2
)
;
#
endif
}
constexpr
size_t
AdjustedLog2Reps
(
size_t
max_pow2
)
{
#
if
HWY_ARCH_RVV
return
HWY_MIN
(
max_pow2
-
4
max_pow2
)
;
#
elif
HWY_ARCH_ARM
return
HWY_MIN
(
max_pow2
-
1
max_pow2
)
;
#
elif
HWY_IS_DEBUG_BUILD
return
HWY_MIN
(
max_pow2
-
1
max_pow2
)
;
#
else
return
max_pow2
;
#
endif
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
