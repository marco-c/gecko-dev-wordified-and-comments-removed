#
ifndef
HWY_TESTS_HWY_GTEST_H_
#
define
HWY_TESTS_HWY_GTEST_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
hwy
/
highway
.
h
"
namespace
hwy
{
#
ifdef
INSTANTIATE_TEST_SUITE_P
#
define
HWY_GTEST_INSTANTIATE_TEST_SUITE_P
INSTANTIATE_TEST_SUITE_P
#
else
#
define
HWY_GTEST_INSTANTIATE_TEST_SUITE_P
INSTANTIATE_TEST_CASE_P
#
endif
class
TestWithParamTarget
:
public
testing
:
:
TestWithParam
<
uint32_t
>
{
protected
:
void
SetUp
(
)
override
{
SetSupportedTargetsForTest
(
GetParam
(
)
)
;
}
void
TearDown
(
)
override
{
#
if
(
HWY_TARGETS
&
(
HWY_TARGETS
-
1
)
)
!
=
0
EXPECT_TRUE
(
SupportedTargetsCalledForTest
(
)
)
<
<
"
This
hwy
target
parametric
test
doesn
'
t
use
dynamic
-
dispatch
and
"
"
doesn
'
t
need
to
be
parametric
.
"
;
#
endif
SetSupportedTargetsForTest
(
0
)
;
}
}
;
static
inline
std
:
:
string
TestParamTargetName
(
const
testing
:
:
TestParamInfo
<
uint32_t
>
&
info
)
{
return
TargetName
(
info
.
param
)
;
}
#
define
HWY_TARGET_INSTANTIATE_TEST_SUITE_P
(
suite
)
\
HWY_GTEST_INSTANTIATE_TEST_SUITE_P
(
\
suite
#
#
Group
suite
\
testing
:
:
ValuesIn
(
:
:
hwy
:
:
SupportedAndGeneratedTargets
(
)
)
\
:
:
hwy
:
:
TestParamTargetName
)
template
<
typename
T
>
class
TestWithParamTargetAndT
:
public
:
:
testing
:
:
TestWithParam
<
std
:
:
tuple
<
uint32_t
T
>
>
{
public
:
using
HwyParamType
=
T
;
protected
:
void
SetUp
(
)
override
{
SetSupportedTargetsForTest
(
std
:
:
get
<
0
>
(
:
:
testing
:
:
TestWithParam
<
std
:
:
tuple
<
uint32_t
T
>
>
:
:
GetParam
(
)
)
)
;
}
void
TearDown
(
)
override
{
#
if
(
HWY_TARGETS
&
(
HWY_TARGETS
-
1
)
)
!
=
0
EXPECT_TRUE
(
SupportedTargetsCalledForTest
(
)
)
<
<
"
This
hwy
target
parametric
test
doesn
'
t
use
dynamic
-
dispatch
and
"
"
doesn
'
t
need
to
be
parametric
.
"
;
#
endif
SetSupportedTargetsForTest
(
0
)
;
}
T
GetParam
(
)
{
return
std
:
:
get
<
1
>
(
:
:
testing
:
:
TestWithParam
<
std
:
:
tuple
<
uint32_t
T
>
>
:
:
GetParam
(
)
)
;
}
}
;
template
<
typename
T
>
std
:
:
string
TestParamTargetNameAndT
(
const
testing
:
:
TestParamInfo
<
std
:
:
tuple
<
uint32_t
T
>
>
&
info
)
{
return
std
:
:
string
(
TargetName
(
std
:
:
get
<
0
>
(
info
.
param
)
)
)
+
"
_
"
+
:
:
testing
:
:
PrintToString
(
std
:
:
get
<
1
>
(
info
.
param
)
)
;
}
#
define
HWY_TARGET_INSTANTIATE_TEST_SUITE_P_T
(
suite
generator
)
\
HWY_GTEST_INSTANTIATE_TEST_SUITE_P
(
\
suite
#
#
Group
suite
\
:
:
testing
:
:
Combine
(
\
testing
:
:
ValuesIn
(
:
:
hwy
:
:
SupportedAndGeneratedTargets
(
)
)
\
generator
)
\
:
:
hwy
:
:
TestParamTargetNameAndT
<
suite
:
:
HwyParamType
>
)
#
define
HWY_EXPORT_AND_TEST_P
(
suite
func_name
)
\
HWY_EXPORT
(
func_name
)
;
\
TEST_P
(
suite
func_name
)
{
HWY_DYNAMIC_DISPATCH
(
func_name
)
(
)
;
}
\
static_assert
(
true
"
For
requiring
trailing
semicolon
"
)
#
define
HWY_EXPORT_AND_TEST_P_T
(
suite
func_name
)
\
HWY_EXPORT
(
func_name
)
;
\
TEST_P
(
suite
func_name
)
{
HWY_DYNAMIC_DISPATCH
(
func_name
)
(
GetParam
(
)
)
;
}
\
static_assert
(
true
"
For
requiring
trailing
semicolon
"
)
#
define
HWY_BEFORE_TEST
(
suite
)
\
class
suite
:
public
hwy
:
:
TestWithParamTarget
{
}
;
\
HWY_TARGET_INSTANTIATE_TEST_SUITE_P
(
suite
)
;
\
static_assert
(
true
"
For
requiring
trailing
semicolon
"
)
}
#
endif
