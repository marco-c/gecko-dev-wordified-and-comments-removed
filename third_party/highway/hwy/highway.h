#
ifndef
HWY_HIGHWAY_INCLUDED
#
define
HWY_HIGHWAY_INCLUDED
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
targets
.
h
"
namespace
hwy
{
#
define
HWY_MAJOR
0
#
define
HWY_MINOR
12
#
define
HWY_PATCH
1
#
define
HWY_FULL1
(
T
)
hwy
:
:
HWY_NAMESPACE
:
:
Simd
<
T
HWY_LANES
(
T
)
>
#
define
HWY_3TH_ARG
(
arg1
arg2
arg3
.
.
.
)
arg3
#
define
HWY_FULL_RECOMPOSER
(
args_with_paren
)
HWY_3TH_ARG
args_with_paren
#
define
HWY_CHOOSE_FULL
(
.
.
.
)
\
HWY_FULL_RECOMPOSER
(
(
__VA_ARGS__
HWY_FULL2
HWY_FULL1
)
)
#
define
HWY_FULL
(
.
.
.
)
HWY_CHOOSE_FULL
(
__VA_ARGS__
(
)
)
(
__VA_ARGS__
)
#
define
HWY_CAPPED
(
T
MAX_N
)
\
hwy
:
:
HWY_NAMESPACE
:
:
Simd
<
T
HWY_MIN
(
MAX_N
HWY_LANES
(
T
)
)
>
#
ifndef
HWY_ONCE
#
define
HWY_ONCE
1
#
endif
#
if
HWY_STATIC_TARGET
=
=
HWY_SCALAR
#
define
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
N_SCALAR
:
:
FUNC_NAME
#
elif
HWY_STATIC_TARGET
=
=
HWY_RVV
#
define
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
N_RVV
:
:
FUNC_NAME
#
elif
HWY_STATIC_TARGET
=
=
HWY_WASM
#
define
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
N_WASM
:
:
FUNC_NAME
#
elif
HWY_STATIC_TARGET
=
=
HWY_NEON
#
define
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
N_NEON
:
:
FUNC_NAME
#
elif
HWY_STATIC_TARGET
=
=
HWY_SVE
#
define
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
N_SVE
:
:
FUNC_NAME
#
elif
HWY_STATIC_TARGET
=
=
HWY_SVE2
#
define
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
N_SVE2
:
:
FUNC_NAME
#
elif
HWY_STATIC_TARGET
=
=
HWY_PPC8
#
define
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
N_PPC8
:
:
FUNC_NAME
#
elif
HWY_STATIC_TARGET
=
=
HWY_SSE4
#
define
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
N_SSE4
:
:
FUNC_NAME
#
elif
HWY_STATIC_TARGET
=
=
HWY_AVX2
#
define
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
N_AVX2
:
:
FUNC_NAME
#
elif
HWY_STATIC_TARGET
=
=
HWY_AVX3
#
define
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
N_AVX3
:
:
FUNC_NAME
#
endif
template
<
typename
RetType
typename
.
.
.
Args
>
struct
FunctionCache
{
public
:
typedef
RetType
(
FunctionType
)
(
Args
.
.
.
)
;
template
<
FunctionType
*
const
table
[
]
>
static
RetType
ChooseAndCall
(
Args
.
.
.
args
)
{
chosen_target
.
Update
(
)
;
return
(
table
[
chosen_target
.
GetIndex
(
)
]
)
(
args
.
.
.
)
;
}
}
;
template
<
typename
RetType
typename
.
.
.
Args
>
FunctionCache
<
RetType
Args
.
.
.
>
FunctionCacheFactory
(
RetType
(
*
)
(
Args
.
.
.
)
)
{
return
FunctionCache
<
RetType
Args
.
.
.
>
(
)
;
}
#
if
HWY_TARGETS
&
HWY_SCALAR
#
define
HWY_CHOOSE_SCALAR
(
FUNC_NAME
)
&
N_SCALAR
:
:
FUNC_NAME
#
else
#
define
HWY_CHOOSE_SCALAR
(
FUNC_NAME
)
&
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
#
endif
#
if
HWY_TARGETS
&
HWY_WASM
#
define
HWY_CHOOSE_WASM
(
FUNC_NAME
)
&
N_WASM
:
:
FUNC_NAME
#
else
#
define
HWY_CHOOSE_WASM
(
FUNC_NAME
)
nullptr
#
endif
#
if
HWY_TARGETS
&
HWY_RVV
#
define
HWY_CHOOSE_RVV
(
FUNC_NAME
)
&
N_RVV
:
:
FUNC_NAME
#
else
#
define
HWY_CHOOSE_RVV
(
FUNC_NAME
)
nullptr
#
endif
#
if
HWY_TARGETS
&
HWY_NEON
#
define
HWY_CHOOSE_NEON
(
FUNC_NAME
)
&
N_NEON
:
:
FUNC_NAME
#
else
#
define
HWY_CHOOSE_NEON
(
FUNC_NAME
)
nullptr
#
endif
#
if
HWY_TARGETS
&
HWY_SVE
#
define
HWY_CHOOSE_SVE
(
FUNC_NAME
)
&
N_SVE
:
:
FUNC_NAME
#
else
#
define
HWY_CHOOSE_SVE
(
FUNC_NAME
)
nullptr
#
endif
#
if
HWY_TARGETS
&
HWY_SVE2
#
define
HWY_CHOOSE_SVE2
(
FUNC_NAME
)
&
N_SVE2
:
:
FUNC_NAME
#
else
#
define
HWY_CHOOSE_SVE2
(
FUNC_NAME
)
nullptr
#
endif
#
if
HWY_TARGETS
&
HWY_PPC8
#
define
HWY_CHOOSE_PCC8
(
FUNC_NAME
)
&
N_PPC8
:
:
FUNC_NAME
#
else
#
define
HWY_CHOOSE_PPC8
(
FUNC_NAME
)
nullptr
#
endif
#
if
HWY_TARGETS
&
HWY_SSE4
#
define
HWY_CHOOSE_SSE4
(
FUNC_NAME
)
&
N_SSE4
:
:
FUNC_NAME
#
else
#
define
HWY_CHOOSE_SSE4
(
FUNC_NAME
)
nullptr
#
endif
#
if
HWY_TARGETS
&
HWY_AVX2
#
define
HWY_CHOOSE_AVX2
(
FUNC_NAME
)
&
N_AVX2
:
:
FUNC_NAME
#
else
#
define
HWY_CHOOSE_AVX2
(
FUNC_NAME
)
nullptr
#
endif
#
if
HWY_TARGETS
&
HWY_AVX3
#
define
HWY_CHOOSE_AVX3
(
FUNC_NAME
)
&
N_AVX3
:
:
FUNC_NAME
#
else
#
define
HWY_CHOOSE_AVX3
(
FUNC_NAME
)
nullptr
#
endif
#
define
HWY_DISPATCH_TABLE
(
FUNC_NAME
)
\
HWY_CONCAT
(
FUNC_NAME
HighwayDispatchTable
)
#
if
HWY_IDE
|
|
(
(
HWY_TARGETS
&
(
HWY_TARGETS
-
1
)
)
=
=
0
)
#
define
HWY_EXPORT
(
FUNC_NAME
)
\
HWY_MAYBE_UNUSED
static
decltype
(
&
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
)
\
const
HWY_DISPATCH_TABLE
(
FUNC_NAME
)
[
1
]
=
{
\
&
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
}
#
define
HWY_DYNAMIC_DISPATCH
(
FUNC_NAME
)
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
#
else
#
define
HWY_EXPORT
(
FUNC_NAME
)
\
static
decltype
(
&
HWY_STATIC_DISPATCH
(
FUNC_NAME
)
)
\
const
HWY_DISPATCH_TABLE
(
FUNC_NAME
)
[
HWY_MAX_DYNAMIC_TARGETS
+
2
]
=
{
\
/
*
The
first
entry
in
the
table
initializes
the
global
cache
and
\
*
calls
the
appropriate
function
.
*
/
\
&
decltype
(
hwy
:
:
FunctionCacheFactory
(
&
HWY_STATIC_DISPATCH
(
\
FUNC_NAME
)
)
)
:
:
ChooseAndCall
<
HWY_DISPATCH_TABLE
(
FUNC_NAME
)
>
\
HWY_CHOOSE_TARGET_LIST
(
FUNC_NAME
)
\
HWY_CHOOSE_SCALAR
(
FUNC_NAME
)
\
}
#
define
HWY_DYNAMIC_DISPATCH
(
FUNC_NAME
)
\
(
*
(
HWY_DISPATCH_TABLE
(
FUNC_NAME
)
[
hwy
:
:
chosen_target
.
GetIndex
(
)
]
)
)
#
endif
}
#
endif
#
if
defined
(
HWY_HIGHWAY_PER_TARGET
)
=
=
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HWY_HIGHWAY_PER_TARGET
#
undef
HWY_HIGHWAY_PER_TARGET
#
else
#
define
HWY_HIGHWAY_PER_TARGET
#
endif
#
undef
HWY_FULL2
#
if
HWY_TARGET
=
=
HWY_RVV
#
define
HWY_FULL2
(
T
LMUL
)
hwy
:
:
HWY_NAMESPACE
:
:
Simd
<
T
HWY_LANES
(
T
)
*
(
LMUL
)
>
#
else
#
define
HWY_FULL2
(
T
LMUL
)
hwy
:
:
HWY_NAMESPACE
:
:
Simd
<
T
HWY_LANES
(
T
)
>
#
endif
#
if
HWY_TARGET
=
=
HWY_SSE4
#
include
"
hwy
/
ops
/
x86_128
-
inl
.
h
"
#
elif
HWY_TARGET
=
=
HWY_AVX2
#
include
"
hwy
/
ops
/
x86_256
-
inl
.
h
"
#
elif
HWY_TARGET
=
=
HWY_AVX3
#
include
"
hwy
/
ops
/
x86_512
-
inl
.
h
"
#
elif
HWY_TARGET
=
=
HWY_PPC8
#
error
"
PPC
is
not
yet
supported
"
#
elif
HWY_TARGET
=
=
HWY_NEON
#
include
"
hwy
/
ops
/
arm_neon
-
inl
.
h
"
#
elif
HWY_TARGET
=
=
HWY_SVE
|
|
HWY_TARGET
=
=
HWY_SVE2
#
include
"
hwy
/
ops
/
arm_sve
-
inl
.
h
"
#
elif
HWY_TARGET
=
=
HWY_WASM
#
include
"
hwy
/
ops
/
wasm_128
-
inl
.
h
"
#
elif
HWY_TARGET
=
=
HWY_RVV
#
include
"
hwy
/
ops
/
rvv
-
inl
.
h
"
#
elif
HWY_TARGET
=
=
HWY_SCALAR
#
include
"
hwy
/
ops
/
scalar
-
inl
.
h
"
#
else
#
pragma
message
(
"
HWY_TARGET
does
not
match
any
known
target
"
)
#
endif
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
template
<
class
V
>
using
LaneType
=
decltype
(
GetLane
(
V
(
)
)
)
;
template
<
class
D
>
using
Vec
=
decltype
(
Zero
(
D
(
)
)
)
;
template
<
class
D
>
using
Mask
=
decltype
(
MaskFromVec
(
Zero
(
D
(
)
)
)
)
;
template
<
class
V
>
HWY_API
V
Clamp
(
const
V
v
const
V
lo
const
V
hi
)
{
return
Min
(
Max
(
lo
v
)
hi
)
;
}
#
if
HWY_TARGET
!
=
HWY_SCALAR
&
&
HWY_TARGET
!
=
HWY_RVV
template
<
size_t
kLanes
class
V
>
HWY_API
V
CombineShiftRightLanes
(
const
V
hi
const
V
lo
)
{
return
CombineShiftRightBytes
<
kLanes
*
sizeof
(
LaneType
<
V
>
)
>
(
hi
lo
)
;
}
#
endif
template
<
class
D
>
HWY_API
Vec
<
D
>
SignBit
(
D
d
)
{
using
Unsigned
=
MakeUnsigned
<
TFromD
<
D
>
>
;
const
Unsigned
bit
=
Unsigned
(
1
)
<
<
(
sizeof
(
Unsigned
)
*
8
-
1
)
;
return
BitCast
(
d
Set
(
Rebind
<
Unsigned
D
>
(
)
bit
)
)
;
}
template
<
class
D
>
HWY_API
Vec
<
D
>
NaN
(
D
d
)
{
const
RebindToSigned
<
D
>
di
;
return
BitCast
(
d
Set
(
di
LimitsMax
<
TFromD
<
decltype
(
di
)
>
>
(
)
)
)
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
