#
include
"
hwy
/
examples
/
skeleton
.
h
"
#
include
<
stdio
.
h
>
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
hwy
/
examples
/
skeleton
.
cc
"
#
include
"
hwy
/
foreach_target
.
h
"
#
include
"
hwy
/
highway
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
skeleton
{
namespace
HWY_NAMESPACE
{
namespace
hn
=
hwy
:
:
HWY_NAMESPACE
;
template
<
class
DF
>
HWY_ATTR_NO_MSAN
void
OneFloorLog2
(
const
DF
df
const
uint8_t
*
HWY_RESTRICT
values
uint8_t
*
HWY_RESTRICT
log2
)
{
const
hn
:
:
RebindToSigned
<
DF
>
d32
;
const
hn
:
:
Rebind
<
uint8_t
DF
>
d8
;
const
auto
u8
=
hn
:
:
Load
(
d8
values
)
;
const
auto
bits
=
hn
:
:
BitCast
(
d32
hn
:
:
ConvertTo
(
df
hn
:
:
PromoteTo
(
d32
u8
)
)
)
;
const
auto
exponent
=
hn
:
:
Sub
(
hn
:
:
ShiftRight
<
23
>
(
bits
)
hn
:
:
Set
(
d32
127
)
)
;
hn
:
:
Store
(
hn
:
:
DemoteTo
(
d8
exponent
)
d8
log2
)
;
}
void
CodepathDemo
(
)
{
#
if
HWY_HAVE_INTEGER64
const
char
*
gather
=
"
Has
int64
"
;
#
else
const
char
*
gather
=
"
No
int64
"
;
#
endif
printf
(
"
Target
%
s
:
%
s
\
n
"
hwy
:
:
TargetName
(
HWY_TARGET
)
gather
)
;
}
void
FloorLog2
(
const
uint8_t
*
HWY_RESTRICT
values
size_t
count
uint8_t
*
HWY_RESTRICT
log2
)
{
CodepathDemo
(
)
;
const
hn
:
:
ScalableTag
<
float
>
df
;
const
size_t
N
=
hn
:
:
Lanes
(
df
)
;
size_t
i
=
0
;
for
(
;
i
+
N
<
=
count
;
i
+
=
N
)
{
OneFloorLog2
(
df
values
+
i
log2
+
i
)
;
}
for
(
;
i
<
count
;
+
+
i
)
{
hn
:
:
CappedTag
<
float
1
>
d1
;
OneFloorLog2
(
d1
values
+
i
log2
+
i
)
;
}
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
skeleton
{
HWY_EXPORT
(
FloorLog2
)
;
HWY_DLLEXPORT
void
CallFloorLog2
(
const
uint8_t
*
HWY_RESTRICT
in
const
size_t
count
uint8_t
*
HWY_RESTRICT
out
)
{
return
HWY_DYNAMIC_DISPATCH
(
FloorLog2
)
(
in
count
out
)
;
}
}
#
endif
