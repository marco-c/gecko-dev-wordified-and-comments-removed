#
include
"
hwy
/
examples
/
skeleton
.
h
"
#
include
<
stdio
.
h
>
#
undef
HWY_TARGET_INCLUDE
#
define
HWY_TARGET_INCLUDE
"
hwy
/
examples
/
skeleton
.
cc
"
#
include
"
hwy
/
foreach_target
.
h
"
#
include
"
hwy
/
highway
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
skeleton
{
namespace
HWY_NAMESPACE
{
using
namespace
hwy
:
:
HWY_NAMESPACE
;
#
if
HWY_COMPILER_CLANG
&
&
defined
(
MEMORY_SANITIZER
)
&
&
defined
(
__OPTIMIZE__
)
#
define
ATTR_MSAN
__attribute__
(
(
optnone
)
)
#
else
#
define
ATTR_MSAN
#
endif
template
<
class
DF
>
ATTR_MSAN
void
OneFloorLog2
(
const
DF
df
const
uint8_t
*
HWY_RESTRICT
values
uint8_t
*
HWY_RESTRICT
log2
)
{
const
RebindToSigned
<
DF
>
d32
;
const
Rebind
<
uint8_t
DF
>
d8
;
const
auto
u8
=
Load
(
d8
values
)
;
const
auto
bits
=
BitCast
(
d32
ConvertTo
(
df
PromoteTo
(
d32
u8
)
)
)
;
const
auto
exponent
=
Sub
(
ShiftRight
<
23
>
(
bits
)
Set
(
d32
127
)
)
;
Store
(
DemoteTo
(
d8
exponent
)
d8
log2
)
;
}
void
CodepathDemo
(
)
{
#
if
HWY_HAVE_INTEGER64
const
char
*
gather
=
"
Has
int64
"
;
#
else
const
char
*
gather
=
"
No
int64
"
;
#
endif
printf
(
"
Target
%
s
:
%
s
\
n
"
hwy
:
:
TargetName
(
HWY_TARGET
)
gather
)
;
}
void
FloorLog2
(
const
uint8_t
*
HWY_RESTRICT
values
size_t
count
uint8_t
*
HWY_RESTRICT
log2
)
{
CodepathDemo
(
)
;
const
ScalableTag
<
float
>
df
;
const
size_t
N
=
Lanes
(
df
)
;
size_t
i
=
0
;
for
(
;
i
+
N
<
=
count
;
i
+
=
N
)
{
OneFloorLog2
(
df
values
+
i
log2
+
i
)
;
}
for
(
;
i
<
count
;
+
+
i
)
{
CappedTag
<
float
1
>
d1
;
OneFloorLog2
(
d1
values
+
i
log2
+
i
)
;
}
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
if
HWY_ONCE
namespace
skeleton
{
HWY_EXPORT
(
FloorLog2
)
;
void
CallFloorLog2
(
const
uint8_t
*
HWY_RESTRICT
in
const
size_t
count
uint8_t
*
HWY_RESTRICT
out
)
{
return
HWY_DYNAMIC_DISPATCH
(
FloorLog2
)
(
in
count
out
)
;
}
}
#
endif
