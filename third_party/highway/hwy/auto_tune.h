#
ifndef
HIGHWAY_HWY_AUTO_TUNE_H_
#
define
HIGHWAY_HWY_AUTO_TUNE_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
cmath
>
#
include
<
vector
>
#
include
"
hwy
/
aligned_allocator
.
h
"
#
include
"
hwy
/
base
.
h
"
#
if
defined
(
HWY_HEADER_ONLY
)
#
define
HWY_AUTOTUNE_STDSORT
#
endif
#
ifdef
HWY_AUTOTUNE_STDSORT
#
include
<
algorithm
>
#
else
#
include
"
hwy
/
contrib
/
sort
/
vqsort
.
h
"
#
endif
namespace
hwy
{
class
CostDistribution
{
public
:
static
constexpr
size_t
kMaxValues
=
14
;
void
Notify
(
const
double
x
)
{
if
(
HWY_UNLIKELY
(
x
<
0
.
0
)
)
{
HWY_WARN
(
"
Ignoring
negative
cost
%
f
.
"
x
)
;
return
;
}
if
(
HWY_LIKELY
(
IsOnline
(
)
)
)
return
OnlineNotify
(
x
)
;
values_
[
num_values_
+
+
]
=
x
;
HWY_DASSERT
(
num_values_
<
=
kMaxValues
)
;
if
(
HWY_UNLIKELY
(
num_values_
=
=
kMaxValues
)
)
{
WarmUpOnline
(
)
;
HWY_DASSERT
(
IsOnline
(
)
)
;
}
}
double
EstimateCost
(
)
{
if
(
!
IsOnline
(
)
)
{
WarmUpOnline
(
)
;
HWY_DASSERT
(
IsOnline
(
)
)
;
}
return
Mean
(
)
;
}
double
&
M1
(
)
{
return
values_
[
0
]
;
}
double
&
M2
(
)
{
return
values_
[
1
]
;
}
double
&
Mean
(
)
{
return
values_
[
2
]
;
}
double
&
Stddev
(
)
{
return
values_
[
3
]
;
}
double
&
Lower
(
)
{
return
values_
[
4
]
;
}
double
&
Upper
(
)
{
return
values_
[
5
]
;
}
private
:
static
double
Median
(
double
*
to_sort
size_t
n
)
{
HWY_DASSERT
(
n
>
=
2
)
;
#
ifdef
HWY_AUTOTUNE_STDSORT
std
:
:
sort
(
to_sort
to_sort
+
n
)
;
#
else
#
if
!
HWY_ARCH_ARM_V7
VQSort
(
to_sort
n
SortAscending
(
)
)
;
#
else
VQSort
(
reinterpret_cast
<
uint64_t
*
>
(
to_sort
)
n
SortAscending
(
)
)
;
#
endif
#
endif
if
(
n
&
1
)
return
to_sort
[
n
/
2
]
;
return
(
to_sort
[
n
/
2
]
+
to_sort
[
n
/
2
-
1
]
)
*
0
.
5
;
}
static
double
MAD
(
const
double
*
values
size_t
n
const
double
median
)
{
double
abs_dev
[
kMaxValues
]
;
for
(
size_t
i
=
0
;
i
<
n
;
+
+
i
)
{
abs_dev
[
i
]
=
ScalarAbs
(
values
[
i
]
-
median
)
;
}
return
Median
(
abs_dev
n
)
;
}
void
RemoveOutliers
(
)
{
if
(
num_values_
<
3
)
return
;
HWY_DASSERT
(
num_values_
<
=
kMaxValues
)
;
const
double
median
=
Median
(
values_
num_values_
)
;
const
double
mad
=
MAD
(
values_
num_values_
median
)
;
if
(
mad
=
=
0
.
0
)
{
const
double
skewness
=
(
values_
[
num_values_
-
1
]
-
median
)
-
(
median
-
values_
[
0
]
)
;
const
size_t
trim
=
HWY_MAX
(
num_values_
/
2
size_t
{
2
}
)
;
const
size_t
left
=
HWY_MAX
(
skewness
<
0
.
0
?
trim
*
3
/
4
:
trim
/
4
size_t
{
1
}
)
;
num_values_
-
=
trim
;
HWY_DASSERT
(
num_values_
>
=
1
)
;
memmove
(
values_
values_
+
left
num_values_
*
sizeof
(
values_
[
0
]
)
)
;
return
;
}
const
double
upper
=
median
+
5
.
0
*
mad
;
const
double
lower
=
median
-
5
.
0
*
mad
;
size_t
right
=
num_values_
-
1
;
while
(
values_
[
right
]
>
upper
)
-
-
right
;
HWY_DASSERT
(
right
>
=
num_values_
/
2
)
;
size_t
left
=
0
;
while
(
left
<
right
&
&
values_
[
left
]
<
lower
)
+
+
left
;
HWY_DASSERT
(
left
<
=
num_values_
/
2
)
;
num_values_
=
right
-
left
+
1
;
memmove
(
values_
values_
+
left
num_values_
*
sizeof
(
values_
[
0
]
)
)
;
}
double
SampleMean
(
)
const
{
HWY_DASSERT
(
!
IsOnline
(
)
&
&
0
!
=
num_values_
&
&
num_values_
<
=
kMaxValues
)
;
double
sum
=
0
.
0
;
for
(
size_t
i
=
0
;
i
<
num_values_
;
+
+
i
)
{
sum
+
=
values_
[
i
]
;
}
return
sum
/
static_cast
<
double
>
(
num_values_
)
;
}
double
SampleVariance
(
double
sample_mean
)
const
{
HWY_DASSERT
(
sample_mean
>
=
0
.
0
)
;
HWY_DASSERT
(
!
IsOnline
(
)
&
&
0
!
=
num_values_
&
&
num_values_
<
=
kMaxValues
)
;
if
(
HWY_UNLIKELY
(
num_values_
=
=
1
)
)
return
0
.
0
;
double
sum2
=
0
.
0
;
for
(
size_t
i
=
0
;
i
<
num_values_
;
+
+
i
)
{
const
double
d
=
values_
[
i
]
-
sample_mean
;
sum2
+
=
d
*
d
;
}
return
sum2
/
static_cast
<
double
>
(
num_values_
-
1
)
;
}
bool
IsOnline
(
)
const
{
return
online_n_
>
0
.
0
;
}
void
OnlineNotify
(
double
x
)
{
x
=
HWY_MIN
(
HWY_MAX
(
Lower
(
)
x
)
Upper
(
)
)
;
const
double
n_minus_1
=
online_n_
;
online_n_
+
=
1
.
0
;
const
double
d
=
x
-
M1
(
)
;
const
double
d_div_n
=
d
/
online_n_
;
M1
(
)
+
=
d_div_n
;
HWY_DASSERT
(
M1
(
)
>
=
Lower
(
)
)
;
M2
(
)
+
=
d
*
n_minus_1
*
d_div_n
;
const
double
stddev
=
std
:
:
sqrt
(
M2
(
)
/
HWY_MAX
(
1
.
0
n_minus_1
)
)
;
constexpr
double
kNew
=
0
.
2
;
constexpr
double
kOld
=
1
.
0
-
kNew
;
Mean
(
)
=
M1
(
)
*
kNew
+
Mean
(
)
*
kOld
;
Stddev
(
)
=
stddev
*
kNew
+
Stddev
(
)
*
kOld
;
Lower
(
)
=
Mean
(
)
-
3
.
5
*
Stddev
(
)
;
Upper
(
)
=
Mean
(
)
+
3
.
5
*
Stddev
(
)
;
}
void
WarmUpOnline
(
)
{
RemoveOutliers
(
)
;
const
double
sample_mean
=
SampleMean
(
)
;
const
double
sample_variance
=
SampleVariance
(
sample_mean
)
;
double
copy
[
kMaxValues
]
;
hwy
:
:
CopyBytes
(
values_
copy
num_values_
*
sizeof
(
values_
[
0
]
)
)
;
M1
(
)
=
M2
(
)
=
0
.
0
;
Mean
(
)
=
sample_mean
;
Stddev
(
)
=
std
:
:
sqrt
(
sample_variance
)
;
if
(
Stddev
(
)
=
=
0
.
0
)
Stddev
(
)
=
Mean
(
)
/
2
;
Lower
(
)
=
Mean
(
)
-
4
.
0
*
Stddev
(
)
;
Upper
(
)
=
Mean
(
)
+
4
.
0
*
Stddev
(
)
;
for
(
size_t
i
=
0
;
i
<
num_values_
;
+
+
i
)
{
OnlineNotify
(
copy
[
i
]
)
;
}
HWY_DASSERT
(
IsOnline
(
)
)
;
}
size_t
num_values_
=
0
;
#
if
SIZE_MAX
=
=
0xFFFFFFFFu
HWY_MAYBE_UNUSED
uint32_t
padding_
=
0
;
#
endif
double
online_n_
=
0
.
0
;
double
values_
[
kMaxValues
]
;
}
;
static_assert
(
sizeof
(
CostDistribution
)
=
=
128
"
"
)
;
class
NextWithSkip
{
public
:
NextWithSkip
(
)
{
}
explicit
NextWithSkip
(
size_t
num
)
{
links_
.
reserve
(
num
)
;
for
(
size_t
i
=
0
;
i
<
num
;
+
+
i
)
{
links_
.
emplace_back
(
i
num
)
;
}
}
size_t
Next
(
size_t
pos
)
{
HWY_DASSERT
(
pos
<
links_
.
size
(
)
)
;
HWY_DASSERT
(
!
links_
[
pos
]
.
IsRemoved
(
)
)
;
return
links_
[
pos
]
.
Next
(
)
;
}
void
Skip
(
size_t
pos
)
{
HWY_DASSERT
(
!
links_
[
pos
]
.
IsRemoved
(
)
)
;
const
size_t
prev
=
links_
[
pos
]
.
Prev
(
)
;
const
size_t
next
=
links_
[
pos
]
.
Next
(
)
;
if
(
prev
=
=
pos
|
|
next
=
=
pos
)
return
;
links_
[
next
]
.
SetPrev
(
prev
)
;
links_
[
prev
]
.
SetNext
(
next
)
;
links_
[
pos
]
.
Remove
(
)
;
}
private
:
class
Link
{
static
constexpr
size_t
kBits
=
14
;
static
constexpr
size_t
kShift
=
32
-
kBits
;
static
constexpr
uint32_t
kMaxNum
=
1u
<
<
kBits
;
public
:
Link
(
size_t
pos
size_t
num
)
{
HWY_DASSERT
(
num
<
kMaxNum
)
;
const
size_t
prev
=
pos
=
=
0
?
num
-
1
:
pos
-
1
;
const
size_t
next
=
pos
=
=
num
-
1
?
0
:
pos
+
1
;
bits_
=
(
static_cast
<
uint32_t
>
(
next
)
<
<
kShift
)
|
static_cast
<
uint32_t
>
(
prev
)
;
HWY_DASSERT
(
Next
(
)
=
=
next
&
&
Prev
(
)
=
=
prev
)
;
HWY_DASSERT
(
!
IsRemoved
(
)
)
;
}
bool
IsRemoved
(
)
const
{
return
(
bits_
&
kMaxNum
)
!
=
0
;
}
void
Remove
(
)
{
bits_
|
=
kMaxNum
;
}
size_t
Next
(
)
const
{
return
bits_
>
>
kShift
;
}
size_t
Prev
(
)
const
{
return
bits_
&
(
kMaxNum
-
1
)
;
}
void
SetNext
(
size_t
next
)
{
HWY_DASSERT
(
next
<
kMaxNum
)
;
bits_
&
=
(
~
0u
>
>
kBits
)
;
bits_
|
=
static_cast
<
uint32_t
>
(
next
)
<
<
kShift
;
HWY_DASSERT
(
Next
(
)
=
=
next
)
;
HWY_DASSERT
(
!
IsRemoved
(
)
)
;
}
void
SetPrev
(
size_t
prev
)
{
HWY_DASSERT
(
prev
<
kMaxNum
)
;
bits_
&
=
~
(
kMaxNum
-
1
)
;
bits_
|
=
static_cast
<
uint32_t
>
(
prev
)
;
HWY_DASSERT
(
Prev
(
)
=
=
prev
)
;
HWY_DASSERT
(
!
IsRemoved
(
)
)
;
}
private
:
uint32_t
bits_
;
}
;
std
:
:
vector
<
Link
>
links_
;
}
;
template
<
typename
Config
size_t
kMinSamples
=
2
>
class
AutoTune
{
public
:
const
Config
*
Best
(
)
const
{
return
best_
;
}
bool
HasCandidates
(
)
const
{
return
!
candidates_
.
empty
(
)
;
}
void
SetCandidates
(
std
:
:
vector
<
Config
>
candidates
)
{
HWY_DASSERT
(
!
Best
(
)
&
&
!
HasCandidates
(
)
)
;
candidates_
.
swap
(
candidates
)
;
HWY_DASSERT
(
HasCandidates
(
)
)
;
costs_
.
resize
(
candidates_
.
size
(
)
)
;
list_
=
NextWithSkip
(
candidates_
.
size
(
)
)
;
}
Span
<
const
Config
>
Candidates
(
)
const
{
HWY_DASSERT
(
HasCandidates
(
)
)
;
return
Span
<
const
Config
>
(
candidates_
.
data
(
)
candidates_
.
size
(
)
)
;
}
Span
<
CostDistribution
>
Costs
(
)
{
return
Span
<
CostDistribution
>
(
costs_
.
data
(
)
costs_
.
size
(
)
)
;
}
const
Config
&
NextConfig
(
)
const
{
HWY_DASSERT
(
HasCandidates
(
)
)
;
return
candidates_
[
config_idx_
]
;
}
void
NotifyCost
(
uint64_t
cost
)
{
HWY_DASSERT
(
!
Best
(
)
&
&
HasCandidates
(
)
)
;
costs_
[
config_idx_
]
.
Notify
(
static_cast
<
double
>
(
cost
)
)
;
const
size_t
my_idx
=
config_idx_
;
const
double
my_cost
=
rounds_complete_
>
=
kMinSamples
?
costs_
[
config_idx_
]
.
EstimateCost
(
)
:
0
.
0
;
config_idx_
=
list_
.
Next
(
config_idx_
)
;
if
(
my_cost
>
skip_if_above_
)
{
list_
.
Skip
(
my_idx
)
;
}
if
(
HWY_UNLIKELY
(
config_idx_
<
=
my_idx
)
)
{
+
+
rounds_complete_
;
if
(
rounds_complete_
>
=
kMinSamples
)
{
double
best_cost
=
HighestValue
<
double
>
(
)
;
size_t
idx_min
=
0
;
for
(
size_t
i
=
0
;
i
<
candidates_
.
size
(
)
;
+
+
i
)
{
const
double
estimate
=
costs_
[
i
]
.
EstimateCost
(
)
;
if
(
estimate
<
best_cost
)
{
best_cost
=
estimate
;
idx_min
=
i
;
}
}
skip_if_above_
=
best_cost
*
1
.
25
;
if
(
HWY_UNLIKELY
(
rounds_complete_
=
=
3
*
kMinSamples
/
2
+
1
)
)
{
best_
=
&
candidates_
[
idx_min
]
;
HWY_DASSERT
(
Best
(
)
)
;
}
}
}
}
bool
ShouldPrint
(
)
{
return
rounds_complete_
>
kMinSamples
;
}
private
:
const
Config
*
best_
=
nullptr
;
std
:
:
vector
<
Config
>
candidates_
;
std
:
:
vector
<
CostDistribution
>
costs_
;
size_t
config_idx_
=
0
;
NextWithSkip
list_
;
size_t
rounds_complete_
=
0
;
double
skip_if_above_
=
0
.
0
;
}
;
}
#
endif
