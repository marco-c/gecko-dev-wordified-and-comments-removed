#
include
"
hwy
/
targets
.
h
"
#
include
"
hwy
/
detect_targets
.
h
"
#
include
"
hwy
/
tests
/
test_util
-
inl
.
h
"
namespace
fake
{
#
define
DECLARE_FUNCTION
(
TGT
)
\
namespace
N_
#
#
TGT
{
\
/
*
Function
argument
is
just
to
ensure
/
demonstrate
they
are
possible
.
*
/
\
int64_t
FakeFunction
(
int
)
{
return
HWY_
#
#
TGT
;
}
\
}
DECLARE_FUNCTION
(
AVX3_ZEN4
)
DECLARE_FUNCTION
(
AVX3_DL
)
DECLARE_FUNCTION
(
AVX3
)
DECLARE_FUNCTION
(
AVX2
)
DECLARE_FUNCTION
(
SSE4
)
DECLARE_FUNCTION
(
SSSE3
)
DECLARE_FUNCTION
(
SSE2
)
DECLARE_FUNCTION
(
SVE2_128
)
DECLARE_FUNCTION
(
SVE_256
)
DECLARE_FUNCTION
(
SVE2
)
DECLARE_FUNCTION
(
SVE
)
DECLARE_FUNCTION
(
NEON
)
DECLARE_FUNCTION
(
NEON_WITHOUT_AES
)
DECLARE_FUNCTION
(
PPC10
)
DECLARE_FUNCTION
(
PPC9
)
DECLARE_FUNCTION
(
PPC8
)
DECLARE_FUNCTION
(
WASM
)
DECLARE_FUNCTION
(
WASM_EMU256
)
DECLARE_FUNCTION
(
RVV
)
DECLARE_FUNCTION
(
SCALAR
)
DECLARE_FUNCTION
(
EMU128
)
HWY_EXPORT
(
FakeFunction
)
;
void
CallFunctionForTarget
(
int64_t
target
int
line
)
{
if
(
(
HWY_TARGETS
&
target
)
=
=
0
)
return
;
hwy
:
:
SetSupportedTargetsForTest
(
target
)
;
hwy
:
:
GetChosenTarget
(
)
.
Update
(
hwy
:
:
SupportedTargets
(
)
)
;
EXPECT_EQ
(
target
HWY_DYNAMIC_DISPATCH
(
FakeFunction
)
(
42
)
)
<
<
line
;
hwy
:
:
GetChosenTarget
(
)
.
DeInit
(
)
;
#
if
HWY_DISPATCH_WORKAROUND
EXPECT_EQ
(
HWY_STATIC_TARGET
HWY_DYNAMIC_DISPATCH
(
FakeFunction
)
(
42
)
)
<
<
line
;
#
else
EXPECT_EQ
(
target
HWY_DYNAMIC_DISPATCH
(
FakeFunction
)
(
42
)
)
<
<
line
;
#
endif
EXPECT_EQ
(
target
HWY_DYNAMIC_DISPATCH
(
FakeFunction
)
(
42
)
)
<
<
line
;
}
void
CheckFakeFunction
(
)
{
CallFunctionForTarget
(
HWY_AVX3_ZEN4
__LINE__
)
;
CallFunctionForTarget
(
HWY_AVX3_DL
__LINE__
)
;
CallFunctionForTarget
(
HWY_AVX3
__LINE__
)
;
CallFunctionForTarget
(
HWY_AVX2
__LINE__
)
;
CallFunctionForTarget
(
HWY_SSE4
__LINE__
)
;
CallFunctionForTarget
(
HWY_SSSE3
__LINE__
)
;
CallFunctionForTarget
(
HWY_SSE2
__LINE__
)
;
CallFunctionForTarget
(
HWY_SVE2_128
__LINE__
)
;
CallFunctionForTarget
(
HWY_SVE_256
__LINE__
)
;
CallFunctionForTarget
(
HWY_SVE2
__LINE__
)
;
CallFunctionForTarget
(
HWY_SVE
__LINE__
)
;
CallFunctionForTarget
(
HWY_NEON
__LINE__
)
;
CallFunctionForTarget
(
HWY_NEON_WITHOUT_AES
__LINE__
)
;
CallFunctionForTarget
(
HWY_PPC10
__LINE__
)
;
CallFunctionForTarget
(
HWY_PPC9
__LINE__
)
;
CallFunctionForTarget
(
HWY_PPC8
__LINE__
)
;
CallFunctionForTarget
(
HWY_WASM
__LINE__
)
;
CallFunctionForTarget
(
HWY_WASM_EMU256
__LINE__
)
;
CallFunctionForTarget
(
HWY_RVV
__LINE__
)
;
#
if
defined
(
HWY_COMPILE_ONLY_SCALAR
)
|
|
HWY_BROKEN_EMU128
CallFunctionForTarget
(
HWY_SCALAR
__LINE__
)
;
#
else
CallFunctionForTarget
(
HWY_EMU128
__LINE__
)
;
#
endif
}
}
namespace
hwy
{
class
HwyTargetsTest
:
public
testing
:
:
Test
{
protected
:
void
TearDown
(
)
override
{
SetSupportedTargetsForTest
(
0
)
;
DisableTargets
(
0
)
;
}
}
;
TEST_F
(
HwyTargetsTest
ChosenTargetOrderTest
)
{
fake
:
:
CheckFakeFunction
(
)
;
}
TEST_F
(
HwyTargetsTest
DisabledTargetsTest
)
{
DisableTargets
(
~
0LL
)
;
HWY_ASSERT
(
HWY_STATIC_TARGET
=
=
SupportedTargets
(
)
)
;
DisableTargets
(
0
)
;
const
int64_t
current_targets
=
SupportedTargets
(
)
;
const
int64_t
enabled_baseline
=
static_cast
<
int64_t
>
(
HWY_ENABLED_BASELINE
)
;
const
int64_t
fallback
=
HWY_SCALAR
|
HWY_EMU128
;
if
(
(
current_targets
&
~
enabled_baseline
&
~
fallback
)
=
=
0
)
{
return
;
}
const
int64_t
best_target
=
current_targets
&
(
~
current_targets
+
1
)
;
DisableTargets
(
best_target
)
;
HWY_ASSERT
(
(
best_target
^
current_targets
)
=
=
SupportedTargets
(
)
)
;
DisableTargets
(
0
)
;
}
}
