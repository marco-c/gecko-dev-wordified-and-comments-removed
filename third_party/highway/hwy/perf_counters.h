#
ifndef
HIGHWAY_HWY_PERF_COUNTERS_H_
#
define
HIGHWAY_HWY_PERF_COUNTERS_H_
#
include
<
stddef
.
h
>
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
bit_set
.
h
"
namespace
hwy
{
namespace
platform
{
#
pragma
pack
(
push
1
)
class
PerfCounters
{
public
:
static
constexpr
size_t
kCapacity
=
14
;
enum
Counter
{
kRefCycles
=
0
kInstructions
kBranches
kBranchMispredicts
kBusCycles
kCacheRefs
kCacheMisses
kL3Loads
kL3Stores
kPageFaults
kMigrations
}
;
static
inline
const
char
*
Name
(
Counter
c
)
{
switch
(
c
)
{
case
kRefCycles
:
return
"
ref_cycles
"
;
case
kInstructions
:
return
"
instructions
"
;
case
kBranches
:
return
"
branches
"
;
case
kBranchMispredicts
:
return
"
branch_mispredicts
"
;
case
kBusCycles
:
return
"
bus_cycles
"
;
case
kCacheRefs
:
return
"
cache_refs
"
;
case
kCacheMisses
:
return
"
cache_misses
"
;
case
kL3Loads
:
return
"
l3_load
"
;
case
kL3Stores
:
return
"
l3_store
"
;
case
kPageFaults
:
return
"
page_fault
"
;
case
kMigrations
:
return
"
migration
"
;
default
:
HWY_UNREACHABLE
;
}
}
HWY_DLLEXPORT
static
bool
Init
(
)
;
HWY_DLLEXPORT
static
bool
StartAll
(
)
;
HWY_DLLEXPORT
static
void
StopAllAndReset
(
)
;
HWY_DLLEXPORT
PerfCounters
(
)
;
bool
AnyValid
(
)
const
{
return
valid_
.
Any
(
)
;
}
bool
IsValid
(
Counter
c
)
const
{
const
size_t
bit_idx
=
static_cast
<
size_t
>
(
c
)
;
return
valid_
.
Get
(
bit_idx
)
;
}
double
MaxExtrapolate
(
)
const
{
return
max_extrapolate_
;
}
double
Get
(
Counter
c
)
const
{
return
IsValid
(
c
)
?
values_
[
IndexForCounter
(
c
)
]
:
0
.
0
;
}
template
<
class
Visitor
>
void
Foreach
(
const
Visitor
&
visitor
)
{
valid_
.
Foreach
(
[
&
]
(
size_t
bit_idx
)
{
const
Counter
c
=
static_cast
<
Counter
>
(
bit_idx
)
;
visitor
(
values_
[
IndexForCounter
(
c
)
]
c
)
;
}
)
;
}
private
:
HWY_DLLEXPORT
static
size_t
IndexForCounter
(
Counter
c
)
;
BitSet64
valid_
;
double
max_extrapolate_
;
double
values_
[
kCapacity
]
;
}
;
#
pragma
pack
(
pop
)
}
}
#
endif
