#
include
"
hwy
/
aligned_allocator
.
h
"
#
include
<
stddef
.
h
>
#
include
<
array
>
#
include
<
new
>
#
include
<
random
>
#
include
<
vector
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
hwy
/
base
.
h
"
namespace
{
template
<
size_t
N
>
class
SampleObject
{
public
:
SampleObject
(
)
{
data_
[
0
]
=
'
a
'
;
}
explicit
SampleObject
(
int
*
counter
)
:
counter_
(
counter
)
{
if
(
counter
)
(
*
counter
)
+
+
;
data_
[
0
]
=
'
b
'
;
}
~
SampleObject
(
)
{
if
(
counter_
)
(
*
counter_
)
-
-
;
}
static_assert
(
N
>
sizeof
(
int
*
)
"
SampleObject
size
too
small
.
"
)
;
int
*
counter_
=
nullptr
;
char
data_
[
N
-
sizeof
(
int
*
)
]
;
}
;
class
FakeAllocator
{
public
:
static
void
*
StaticAlloc
(
void
*
opaque
size_t
bytes
)
{
return
reinterpret_cast
<
FakeAllocator
*
>
(
opaque
)
-
>
Alloc
(
bytes
)
;
}
static
void
StaticFree
(
void
*
opaque
void
*
memory
)
{
return
reinterpret_cast
<
FakeAllocator
*
>
(
opaque
)
-
>
Free
(
memory
)
;
}
size_t
PendingAllocs
(
)
{
return
allocs_
.
size
(
)
;
}
private
:
void
*
Alloc
(
size_t
bytes
)
{
void
*
ret
=
malloc
(
bytes
)
;
allocs_
.
insert
(
ret
)
;
return
ret
;
}
void
Free
(
void
*
memory
)
{
if
(
!
memory
)
return
;
EXPECT_NE
(
allocs_
.
end
(
)
allocs_
.
find
(
memory
)
)
;
free
(
memory
)
;
allocs_
.
erase
(
memory
)
;
}
std
:
:
set
<
void
*
>
allocs_
;
}
;
}
namespace
hwy
{
class
AlignedAllocatorTest
:
public
testing
:
:
Test
{
}
;
TEST
(
AlignedAllocatorTest
FreeNullptr
)
{
FreeAlignedBytes
(
nullptr
nullptr
nullptr
)
;
}
TEST
(
AlignedAllocatorTest
Log2
)
{
EXPECT_EQ
(
0u
detail
:
:
ShiftCount
(
1
)
)
;
EXPECT_EQ
(
1u
detail
:
:
ShiftCount
(
2
)
)
;
EXPECT_EQ
(
3u
detail
:
:
ShiftCount
(
8
)
)
;
}
TEST
(
AlignedAllocatorTest
Overflow
)
{
constexpr
size_t
max
=
~
size_t
(
0
)
;
constexpr
size_t
msb
=
(
max
>
>
1
)
+
1
;
using
Size5
=
std
:
:
array
<
uint8_t
5
>
;
using
Size10
=
std
:
:
array
<
uint8_t
10
>
;
EXPECT_EQ
(
nullptr
detail
:
:
AllocateAlignedItems
<
uint32_t
>
(
max
/
2
nullptr
nullptr
)
)
;
EXPECT_EQ
(
nullptr
detail
:
:
AllocateAlignedItems
<
uint32_t
>
(
max
/
3
nullptr
nullptr
)
)
;
EXPECT_EQ
(
nullptr
detail
:
:
AllocateAlignedItems
<
Size5
>
(
max
/
4
nullptr
nullptr
)
)
;
EXPECT_EQ
(
nullptr
detail
:
:
AllocateAlignedItems
<
uint16_t
>
(
msb
nullptr
nullptr
)
)
;
EXPECT_EQ
(
nullptr
detail
:
:
AllocateAlignedItems
<
double
>
(
msb
+
1
nullptr
nullptr
)
)
;
EXPECT_EQ
(
nullptr
detail
:
:
AllocateAlignedItems
<
Size10
>
(
msb
/
4
nullptr
nullptr
)
)
;
}
TEST
(
AlignedAllocatorTest
AllocDefaultPointers
)
{
const
size_t
kSize
=
7777
;
void
*
ptr
=
AllocateAlignedBytes
(
kSize
nullptr
nullptr
)
;
ASSERT_NE
(
nullptr
ptr
)
;
EXPECT_EQ
(
0U
reinterpret_cast
<
uintptr_t
>
(
ptr
)
%
HWY_ALIGNMENT
)
;
char
*
p
=
static_cast
<
char
*
>
(
ptr
)
;
size_t
ret
=
0
;
for
(
size_t
i
=
0
;
i
<
kSize
;
i
+
+
)
{
p
[
i
]
=
static_cast
<
char
>
(
i
&
0x7F
)
;
if
(
i
)
ret
+
=
static_cast
<
size_t
>
(
p
[
i
]
*
p
[
i
-
1
]
)
;
}
EXPECT_NE
(
0U
ret
)
;
FreeAlignedBytes
(
ptr
nullptr
nullptr
)
;
}
TEST
(
AlignedAllocatorTest
EmptyAlignedUniquePtr
)
{
AlignedUniquePtr
<
SampleObject
<
32
>
>
ptr
(
nullptr
AlignedDeleter
(
)
)
;
AlignedUniquePtr
<
SampleObject
<
32
>
[
]
>
arr
(
nullptr
AlignedDeleter
(
)
)
;
}
TEST
(
AlignedAllocatorTest
EmptyAlignedFreeUniquePtr
)
{
AlignedFreeUniquePtr
<
SampleObject
<
32
>
>
ptr
(
nullptr
AlignedFreer
(
)
)
;
AlignedFreeUniquePtr
<
SampleObject
<
32
>
[
]
>
arr
(
nullptr
AlignedFreer
(
)
)
;
}
TEST
(
AlignedAllocatorTest
CustomAlloc
)
{
FakeAllocator
fake_alloc
;
const
size_t
kSize
=
7777
;
void
*
ptr
=
AllocateAlignedBytes
(
kSize
&
FakeAllocator
:
:
StaticAlloc
&
fake_alloc
)
;
ASSERT_NE
(
nullptr
ptr
)
;
EXPECT_EQ
(
1U
fake_alloc
.
PendingAllocs
(
)
)
;
EXPECT_EQ
(
0U
reinterpret_cast
<
uintptr_t
>
(
ptr
)
%
HWY_ALIGNMENT
)
;
FreeAlignedBytes
(
ptr
&
FakeAllocator
:
:
StaticFree
&
fake_alloc
)
;
EXPECT_EQ
(
0U
fake_alloc
.
PendingAllocs
(
)
)
;
}
TEST
(
AlignedAllocatorTest
MakeUniqueAlignedDefaultConstructor
)
{
{
auto
ptr
=
MakeUniqueAligned
<
SampleObject
<
24
>
>
(
)
;
EXPECT_EQ
(
'
a
'
ptr
-
>
data_
[
0
]
)
;
EXPECT_EQ
(
nullptr
ptr
-
>
counter_
)
;
}
}
TEST
(
AlignedAllocatorTest
MakeUniqueAligned
)
{
int
counter
=
0
;
{
auto
ptr
=
MakeUniqueAligned
<
SampleObject
<
24
>
>
(
&
counter
)
;
EXPECT_EQ
(
1
counter
)
;
EXPECT_EQ
(
'
b
'
ptr
-
>
data_
[
0
]
)
;
}
EXPECT_EQ
(
0
counter
)
;
}
TEST
(
AlignedAllocatorTest
MakeUniqueAlignedArray
)
{
int
counter
=
0
;
{
auto
arr
=
MakeUniqueAlignedArray
<
SampleObject
<
24
>
>
(
7
&
counter
)
;
EXPECT_EQ
(
7
counter
)
;
for
(
size_t
i
=
0
;
i
<
7
;
i
+
+
)
{
EXPECT_EQ
(
'
b
'
arr
[
i
]
.
data_
[
0
]
)
<
<
"
Where
i
=
"
<
<
i
;
}
}
EXPECT_EQ
(
0
counter
)
;
}
TEST
(
AlignedAllocatorTest
AllocSingleInt
)
{
auto
ptr
=
AllocateAligned
<
uint32_t
>
(
1
)
;
ASSERT_NE
(
nullptr
ptr
.
get
(
)
)
;
EXPECT_EQ
(
0U
reinterpret_cast
<
uintptr_t
>
(
ptr
.
get
(
)
)
%
HWY_ALIGNMENT
)
;
ptr
.
reset
(
nullptr
)
;
EXPECT_EQ
(
nullptr
ptr
.
get
(
)
)
;
}
TEST
(
AlignedAllocatorTest
AllocMultipleInt
)
{
const
size_t
kSize
=
7777
;
auto
ptr
=
AllocateAligned
<
uint32_t
>
(
kSize
)
;
ASSERT_NE
(
nullptr
ptr
.
get
(
)
)
;
EXPECT_EQ
(
0U
reinterpret_cast
<
uintptr_t
>
(
ptr
.
get
(
)
)
%
HWY_ALIGNMENT
)
;
EXPECT_EQ
(
&
(
ptr
[
0
]
)
+
1
&
(
ptr
[
1
]
)
)
;
size_t
ret
=
0
;
for
(
size_t
i
=
0
;
i
<
kSize
;
i
+
+
)
{
ptr
[
i
]
=
static_cast
<
uint32_t
>
(
i
)
;
if
(
i
)
ret
+
=
ptr
[
i
]
*
ptr
[
i
-
1
]
;
}
EXPECT_NE
(
0U
ret
)
;
}
TEST
(
AlignedAllocatorTest
AllocateAlignedObjectWithoutDestructor
)
{
int
counter
=
0
;
{
auto
obj
=
AllocateAligned
<
SampleObject
<
24
>
>
(
1
)
;
obj
[
0
]
.
counter_
=
&
counter
;
}
EXPECT_EQ
(
0
counter
)
;
}
TEST
(
AlignedAllocatorTest
MakeUniqueAlignedArrayWithCustomAlloc
)
{
FakeAllocator
fake_alloc
;
int
counter
=
0
;
{
auto
arr
=
MakeUniqueAlignedArrayWithAlloc
<
SampleObject
<
24
>
>
(
7
FakeAllocator
:
:
StaticAlloc
FakeAllocator
:
:
StaticFree
&
fake_alloc
&
counter
)
;
ASSERT_NE
(
nullptr
arr
.
get
(
)
)
;
EXPECT_EQ
(
1u
fake_alloc
.
PendingAllocs
(
)
)
;
EXPECT_EQ
(
7
counter
)
;
for
(
size_t
i
=
0
;
i
<
7
;
i
+
+
)
{
EXPECT_EQ
(
'
b
'
arr
[
i
]
.
data_
[
0
]
)
<
<
"
Where
i
=
"
<
<
i
;
}
}
EXPECT_EQ
(
0
counter
)
;
EXPECT_EQ
(
0u
fake_alloc
.
PendingAllocs
(
)
)
;
}
TEST
(
AlignedAllocatorTest
DefaultInit
)
{
std
:
:
vector
<
AlignedUniquePtr
<
int
[
]
>
>
ptrs
;
std
:
:
vector
<
AlignedFreeUniquePtr
<
double
[
]
>
>
free_ptrs
;
ptrs
.
resize
(
128
)
;
free_ptrs
.
resize
(
128
)
;
std
:
:
mt19937
rng
(
129
)
;
std
:
:
uniform_int_distribution
<
size_t
>
dist
(
0
127
)
;
ptrs
[
dist
(
rng
)
]
=
MakeUniqueAlignedArray
<
int
>
(
123
)
;
free_ptrs
[
dist
(
rng
)
]
=
AllocateAligned
<
double
>
(
456
)
;
const
auto
addr1
=
reinterpret_cast
<
uintptr_t
>
(
ptrs
[
dist
(
rng
)
]
.
get
(
)
)
;
const
auto
addr2
=
reinterpret_cast
<
uintptr_t
>
(
free_ptrs
[
dist
(
rng
)
]
.
get
(
)
)
;
constexpr
size_t
kBits
=
sizeof
(
uintptr_t
)
*
8
;
EXPECT_EQ
(
(
addr1
>
>
(
kBits
-
1
)
)
>
>
(
kBits
-
1
)
(
addr2
>
>
(
kBits
-
1
)
)
>
>
(
kBits
-
1
)
)
;
}
}
int
main
(
int
argc
char
*
*
argv
)
{
:
:
testing
:
:
InitGoogleTest
(
&
argc
argv
)
;
return
RUN_ALL_TESTS
(
)
;
}
