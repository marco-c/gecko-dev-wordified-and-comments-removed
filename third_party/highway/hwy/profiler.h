#
ifndef
HIGHWAY_HWY_PROFILER_H_
#
define
HIGHWAY_HWY_PROFILER_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
atomic
>
#
include
<
functional
>
#
include
"
hwy
/
base
.
h
"
#
include
"
hwy
/
highway_export
.
h
"
#
ifndef
PROFILER_ENABLED
#
define
PROFILER_ENABLED
0
#
endif
#
if
PROFILER_ENABLED
#
include
<
stdio
.
h
>
#
include
<
algorithm
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
hwy
/
aligned_allocator
.
h
"
#
include
"
hwy
/
bit_set
.
h
"
#
include
"
hwy
/
timer
.
h
"
#
endif
namespace
hwy
{
enum
class
ProfilerFlags
:
uint32_t
{
kDefault
=
0
kInclusive
=
1
}
;
using
ProfilerFunc
=
std
:
:
function
<
void
(
void
)
>
;
template
<
size_t
kMaxStrings
>
class
StringTable
{
static
constexpr
std
:
:
memory_order
kRelaxed
=
std
:
:
memory_order_relaxed
;
static
constexpr
std
:
:
memory_order
kAcq
=
std
:
:
memory_order_acquire
;
static
constexpr
std
:
:
memory_order
kRel
=
std
:
:
memory_order_release
;
public
:
const
char
*
Name
(
size_t
idx
)
const
{
return
ptrs_
[
idx
]
.
load
(
kRelaxed
)
;
}
size_t
Add
(
const
char
*
name
)
{
const
size_t
num_strings
=
next_ptr_
.
load
(
kAcq
)
;
HWY_ASSERT
(
num_strings
<
kMaxStrings
)
;
for
(
size_t
idx
=
1
;
idx
<
num_strings
;
+
+
idx
)
{
const
char
*
existing
=
ptrs_
[
idx
]
.
load
(
kAcq
)
;
HWY_ASSERT
(
existing
!
=
nullptr
)
;
if
(
HWY_UNLIKELY
(
!
strcmp
(
existing
name
)
)
)
{
return
idx
;
}
}
const
size_t
len
=
strlen
(
name
)
+
1
;
const
size_t
pos
=
next_char_
.
fetch_add
(
len
kRelaxed
)
;
HWY_ASSERT
(
pos
+
len
<
=
sizeof
(
chars_
)
)
;
strcpy
(
chars_
+
pos
name
)
;
for
(
;
;
)
{
size_t
idx
=
next_ptr_
.
load
(
kRelaxed
)
;
HWY_ASSERT
(
idx
<
kMaxStrings
)
;
const
char
*
expected
=
nullptr
;
if
(
HWY_LIKELY
(
ptrs_
[
idx
]
.
compare_exchange_weak
(
expected
chars_
+
pos
kRel
kRelaxed
)
)
)
{
next_ptr_
.
store
(
idx
+
1
kRel
)
;
HWY_DASSERT
(
!
strcmp
(
Name
(
idx
)
name
)
)
;
return
idx
;
}
if
(
HWY_UNLIKELY
(
!
strcmp
(
expected
name
)
)
)
{
HWY_DASSERT
(
!
strcmp
(
Name
(
idx
)
name
)
)
;
return
idx
;
}
}
}
private
:
std
:
:
atomic
<
const
char
*
>
ptrs_
[
kMaxStrings
]
;
std
:
:
atomic
<
size_t
>
next_ptr_
{
1
}
;
std
:
:
atomic
<
size_t
>
next_char_
{
0
}
;
char
chars_
[
kMaxStrings
*
55
]
;
}
;
#
if
PROFILER_ENABLED
namespace
profiler
{
HWY_INLINE_VAR
constexpr
size_t
kNumFlags
=
1
;
HWY_INLINE_VAR
constexpr
size_t
kMaxDepth
=
13
;
HWY_INLINE_VAR
constexpr
size_t
kMaxZones
=
128
;
HWY_INLINE_VAR
constexpr
size_t
kMaxWorkers
=
256
;
class
ZoneHandle
{
public
:
ZoneHandle
(
)
:
bits_
(
0
)
{
}
ZoneHandle
(
size_t
zone_idx
ProfilerFlags
flags
)
{
HWY_DASSERT
(
0
!
=
zone_idx
&
&
zone_idx
<
kMaxZones
)
;
const
uint32_t
flags_u
=
static_cast
<
uint32_t
>
(
flags
)
;
HWY_DASSERT
(
flags_u
<
(
1u
<
<
kNumFlags
)
)
;
bits_
=
(
static_cast
<
uint32_t
>
(
zone_idx
)
<
<
kNumFlags
)
|
flags_u
;
HWY_DASSERT
(
ZoneIdx
(
)
=
=
zone_idx
)
;
}
ZoneHandle
(
const
ZoneHandle
&
other
)
=
default
;
ZoneHandle
&
operator
=
(
const
ZoneHandle
&
other
)
=
default
;
bool
operator
=
=
(
const
ZoneHandle
other
)
const
{
return
bits_
=
=
other
.
bits_
;
}
bool
operator
!
=
(
const
ZoneHandle
other
)
const
{
return
bits_
!
=
other
.
bits_
;
}
size_t
ZoneIdx
(
)
const
{
HWY_DASSERT
(
bits_
!
=
0
)
;
const
size_t
zone_idx
=
bits_
>
>
kNumFlags
;
HWY_DASSERT
(
0
!
=
zone_idx
&
&
zone_idx
<
kMaxZones
)
;
return
zone_idx
;
}
bool
IsInclusive
(
)
const
{
HWY_DASSERT
(
bits_
!
=
0
)
;
return
(
bits_
&
static_cast
<
uint32_t
>
(
ProfilerFlags
:
:
kInclusive
)
)
!
=
0
;
}
uint64_t
ChildTotalMask
(
)
const
{
const
uint32_t
bit
=
bits_
&
static_cast
<
uint32_t
>
(
ProfilerFlags
:
:
kInclusive
)
;
return
uint64_t
{
bit
}
-
1
;
}
private
:
uint32_t
bits_
;
}
;
class
Zones
{
public
:
const
char
*
Name
(
ZoneHandle
zone
)
const
{
return
strings_
.
Name
(
zone
.
ZoneIdx
(
)
)
;
}
ZoneHandle
AddZone
(
const
char
*
name
ProfilerFlags
flags
)
{
return
ZoneHandle
(
strings_
.
Add
(
name
)
flags
)
;
}
private
:
StringTable
<
kMaxZones
>
strings_
;
}
;
class
Funcs
{
static
constexpr
auto
kAcq
=
std
:
:
memory_order_acquire
;
static
constexpr
auto
kRel
=
std
:
:
memory_order_release
;
public
:
void
Add
(
intptr_t
key
ProfilerFunc
func
)
{
HWY_ASSERT
(
key
!
=
0
&
&
key
!
=
kPending
)
;
HWY_ASSERT
(
func
)
;
for
(
size_t
i
=
0
;
i
<
kMaxFuncs
;
+
+
i
)
{
intptr_t
expected
=
0
;
if
(
!
keys_
[
i
]
.
compare_exchange_strong
(
expected
kPending
kRel
)
)
{
continue
;
}
funcs_
[
i
]
=
std
:
:
move
(
func
)
;
keys_
[
i
]
.
store
(
key
kRel
)
;
return
;
}
HWY_ABORT
(
"
Funcs
:
:
Add
:
no
free
slot
increase
kMaxFuncs
.
"
)
;
}
void
Remove
(
intptr_t
key
)
{
HWY_ASSERT
(
key
!
=
0
&
&
key
!
=
kPending
)
;
for
(
size_t
i
=
0
;
i
<
kMaxFuncs
;
+
+
i
)
{
intptr_t
actual
=
keys_
[
i
]
.
load
(
kAcq
)
;
if
(
actual
=
=
key
)
{
if
(
!
keys_
[
i
]
.
compare_exchange_strong
(
actual
kPending
kRel
)
)
{
HWY_WARN
(
"
Funcs
:
CAS
failed
why
is
there
a
concurrent
Remove
?
"
)
;
}
funcs_
[
i
]
=
ProfilerFunc
(
)
;
keys_
[
i
]
.
store
(
0
kRel
)
;
return
;
}
}
HWY_ABORT
(
"
Funcs
:
:
Remove
:
failed
to
find
key
%
p
.
"
reinterpret_cast
<
void
*
>
(
key
)
)
;
}
void
CallAll
(
)
const
{
for
(
size_t
i
=
0
;
i
<
kMaxFuncs
;
+
+
i
)
{
intptr_t
key
=
keys_
[
i
]
.
load
(
kAcq
)
;
if
(
key
!
=
0
&
&
key
!
=
kPending
)
{
funcs_
[
i
]
(
)
;
}
}
}
private
:
static
constexpr
size_t
kMaxFuncs
=
64
;
static
constexpr
intptr_t
kPending
=
-
1
;
ProfilerFunc
funcs_
[
kMaxFuncs
]
;
std
:
:
atomic
<
intptr_t
>
keys_
[
kMaxFuncs
]
=
{
}
;
}
;
struct
Accumulator
{
void
Add
(
ZoneHandle
new_zone
uint64_t
self_duration
)
{
duration
+
=
self_duration
;
HWY_DASSERT
(
new_zone
!
=
ZoneHandle
(
)
)
;
HWY_DASSERT
(
zone
=
=
ZoneHandle
(
)
|
|
zone
=
=
new_zone
)
;
zone
=
new_zone
;
num_calls
+
=
1
;
}
void
Take
(
Accumulator
&
other
)
{
duration
+
=
other
.
duration
;
other
.
duration
=
0
;
HWY_DASSERT
(
other
.
zone
!
=
ZoneHandle
(
)
)
;
HWY_DASSERT
(
zone
=
=
ZoneHandle
(
)
|
|
zone
=
=
other
.
zone
)
;
zone
=
other
.
zone
;
num_calls
+
=
other
.
num_calls
;
other
.
num_calls
=
0
;
}
uint64_t
duration
=
0
;
ZoneHandle
zone
;
uint32_t
num_calls
=
0
;
}
;
static_assert
(
sizeof
(
Accumulator
)
=
=
16
"
Wrong
Accumulator
size
"
)
;
using
ZoneSet
=
hwy
:
:
BitSet
<
kMaxZones
>
;
using
WorkerSet
=
hwy
:
:
BitSet
<
kMaxWorkers
>
;
using
AtomicWorkerSet
=
hwy
:
:
AtomicBitSet
<
kMaxWorkers
>
;
class
ConcurrencyStats
{
public
:
ConcurrencyStats
(
)
{
Reset
(
)
;
}
void
Notify
(
const
size_t
x
)
{
sum_
+
=
x
;
+
+
n_
;
min_
=
HWY_MIN
(
min_
x
)
;
max_
=
HWY_MAX
(
max_
x
)
;
}
size_t
Count
(
)
const
{
return
n_
;
}
size_t
Min
(
)
const
{
return
min_
;
}
size_t
Max
(
)
const
{
return
max_
;
}
double
Mean
(
)
const
{
return
static_cast
<
double
>
(
sum_
)
/
static_cast
<
double
>
(
n_
)
;
}
void
Reset
(
)
{
sum_
=
0
;
n_
=
0
;
min_
=
hwy
:
:
HighestValue
<
size_t
>
(
)
;
max_
=
hwy
:
:
LowestValue
<
size_t
>
(
)
;
}
private
:
uint64_t
sum_
;
size_t
n_
;
size_t
min_
;
size_t
max_
;
}
;
static_assert
(
sizeof
(
ConcurrencyStats
)
=
=
(
8
+
3
*
sizeof
(
size_t
)
)
"
"
)
;
class
Results
{
public
:
void
TakeAccumulator
(
const
size_t
global_idx
const
size_t
zone_idx
Accumulator
&
other
)
{
HWY_DASSERT
(
global_idx
<
kMaxWorkers
)
;
HWY_DASSERT
(
zone_idx
<
kMaxZones
)
;
HWY_DASSERT
(
other
.
zone
.
ZoneIdx
(
)
=
=
zone_idx
)
;
visited_zones_
.
Set
(
zone_idx
)
;
totals_
[
zone_idx
]
.
Take
(
other
)
;
workers_
[
zone_idx
]
.
Set
(
global_idx
)
;
}
void
CountWorkersAndReset
(
const
size_t
zone_idx
)
{
HWY_DASSERT
(
zone_idx
<
kMaxZones
)
;
const
size_t
num_workers
=
workers_
[
zone_idx
]
.
Count
(
)
;
if
(
num_workers
!
=
0
)
{
concurrency_
[
zone_idx
]
.
Notify
(
num_workers
)
;
}
workers_
[
zone_idx
]
=
WorkerSet
(
)
;
}
void
CountWorkersAndReset
(
)
{
visited_zones_
.
Foreach
(
[
&
]
(
size_t
zone_idx
)
{
CountWorkersAndReset
(
zone_idx
)
;
}
)
;
}
void
PrintAndReset
(
const
Zones
&
zones
)
{
const
double
inv_freq
=
1
.
0
/
hwy
:
:
platform
:
:
InvariantTicksPerSecond
(
)
;
std
:
:
vector
<
uint32_t
>
indices
;
indices
.
reserve
(
visited_zones_
.
Count
(
)
)
;
visited_zones_
.
Foreach
(
[
&
]
(
size_t
zone_idx
)
{
indices
.
push_back
(
static_cast
<
uint32_t
>
(
zone_idx
)
)
;
CountWorkersAndReset
(
zone_idx
)
;
}
)
;
std
:
:
sort
(
indices
.
begin
(
)
indices
.
end
(
)
[
&
]
(
uint32_t
a
uint32_t
b
)
{
return
totals_
[
a
]
.
duration
>
totals_
[
b
]
.
duration
;
}
)
;
for
(
uint32_t
zone_idx
:
indices
)
{
Accumulator
&
total
=
totals_
[
zone_idx
]
;
HWY_ASSERT
(
total
.
zone
.
ZoneIdx
(
)
=
=
zone_idx
)
;
HWY_ASSERT
(
total
.
num_calls
!
=
0
)
;
ConcurrencyStats
&
concurrency
=
concurrency_
[
zone_idx
]
;
const
double
duration
=
static_cast
<
double
>
(
total
.
duration
)
;
const
double
per_call
=
static_cast
<
double
>
(
total
.
duration
)
/
total
.
num_calls
;
const
double
avg_concurrency
=
concurrency
.
Mean
(
)
;
const
double
concurrency_divisor
=
HWY_MAX
(
1
.
0
avg_concurrency
)
;
printf
(
"
%
s
%
-
40s
:
%
10
.
0f
x
%
15
.
0f
/
%
5
.
1f
(
%
5zu
%
3zu
-
%
3zu
)
=
%
9
.
6f
\
n
"
total
.
zone
.
IsInclusive
(
)
?
"
(
I
)
"
:
"
"
zones
.
Name
(
total
.
zone
)
static_cast
<
double
>
(
total
.
num_calls
)
per_call
avg_concurrency
concurrency
.
Count
(
)
concurrency
.
Min
(
)
concurrency
.
Max
(
)
duration
*
inv_freq
/
concurrency_divisor
)
;
total
=
Accumulator
(
)
;
concurrency
.
Reset
(
)
;
}
visited_zones_
=
ZoneSet
(
)
;
}
private
:
ZoneSet
visited_zones_
;
Accumulator
totals_
[
kMaxZones
]
;
WorkerSet
workers_
[
kMaxZones
]
;
ConcurrencyStats
concurrency_
[
kMaxZones
]
;
}
;
struct
Overheads
{
uint64_t
self
=
0
;
uint64_t
child
=
0
;
}
;
static_assert
(
sizeof
(
Overheads
)
=
=
16
"
Wrong
Overheads
size
"
)
;
class
Accumulators
{
static
constexpr
size_t
kPerLine
=
HWY_ALIGNMENT
/
sizeof
(
Accumulator
)
;
public
:
Accumulator
&
Get
(
const
size_t
global_idx
const
size_t
zone_idx
)
{
HWY_DASSERT
(
global_idx
<
kMaxWorkers
)
;
HWY_DASSERT
(
zone_idx
<
kMaxZones
)
;
const
size_t
line
=
zone_idx
/
kPerLine
;
const
size_t
offset
=
zone_idx
%
kPerLine
;
return
zones_
[
(
line
*
kMaxWorkers
+
global_idx
)
*
kPerLine
+
offset
]
;
}
private
:
Accumulator
zones_
[
kMaxZones
*
kMaxWorkers
]
;
}
;
class
PerWorker
{
public
:
template
<
typename
T
>
static
T
ClampedSubtract
(
const
T
minuend
const
T
subtrahend
)
{
static_assert
(
IsUnsigned
<
T
>
(
)
"
"
)
;
const
T
difference
=
minuend
-
subtrahend
;
const
T
no_underflow
=
(
subtrahend
>
minuend
)
?
T
{
0
}
:
~
T
{
0
}
;
return
difference
&
no_underflow
;
}
void
SetOverheads
(
const
Overheads
&
overheads
)
{
overheads_
=
overheads
;
}
void
Enter
(
const
uint64_t
t_enter
)
{
const
size_t
depth
=
depth_
;
HWY_DASSERT
(
depth
<
kMaxDepth
)
;
t_enter_
[
depth
]
=
t_enter
;
child_total_
[
1
+
depth
]
=
0
;
depth_
=
1
+
depth
;
}
void
Exit
(
const
uint64_t
t_exit
const
size_t
global_idx
const
ZoneHandle
zone
Accumulators
&
accumulators
)
{
HWY_DASSERT
(
depth_
>
0
)
;
const
size_t
depth
=
depth_
-
1
;
const
size_t
zone_idx
=
zone
.
ZoneIdx
(
)
;
const
uint64_t
duration
=
t_exit
-
t_enter_
[
depth
]
;
const
uint64_t
child_total
=
child_total_
[
1
+
depth
]
&
zone
.
ChildTotalMask
(
)
;
const
uint64_t
self_duration
=
ClampedSubtract
(
duration
overheads_
.
self
+
overheads_
.
child
+
child_total
)
;
accumulators
.
Get
(
global_idx
zone_idx
)
.
Add
(
zone
self_duration
)
;
visited_zones_
.
Set
(
zone_idx
)
;
child_total_
[
1
+
depth
-
1
]
+
=
duration
+
overheads_
.
child
;
depth_
=
depth
;
}
uint64_t
GetFirstDurationAndReset
(
size_t
global_idx
Accumulators
&
accumulators
)
{
HWY_DASSERT
(
depth_
=
=
0
)
;
HWY_DASSERT
(
visited_zones_
.
Count
(
)
=
=
1
)
;
const
size_t
zone_idx
=
visited_zones_
.
First
(
)
;
HWY_DASSERT
(
zone_idx
<
=
3
)
;
HWY_DASSERT
(
visited_zones_
.
Get
(
zone_idx
)
)
;
visited_zones_
.
Clear
(
zone_idx
)
;
Accumulator
&
zone
=
accumulators
.
Get
(
global_idx
zone_idx
)
;
const
uint64_t
duration
=
zone
.
duration
;
zone
=
Accumulator
(
)
;
return
duration
;
}
void
MoveTo
(
const
size_t
global_idx
Accumulators
&
accumulators
Results
&
results
)
{
visited_zones_
.
Foreach
(
[
&
]
(
size_t
zone_idx
)
{
results
.
TakeAccumulator
(
global_idx
zone_idx
accumulators
.
Get
(
global_idx
zone_idx
)
)
;
}
)
;
visited_zones_
=
ZoneSet
(
)
;
}
private
:
ZoneSet
visited_zones_
;
uint64_t
depth_
=
0
;
Overheads
overheads_
;
uint64_t
t_enter_
[
kMaxDepth
]
;
uint64_t
child_total_
[
1
+
kMaxDepth
]
=
{
0
}
;
}
;
static_assert
(
sizeof
(
PerWorker
)
=
=
256
"
Wrong
size
"
)
;
}
class
Profiler
{
public
:
static
HWY_DLLEXPORT
Profiler
&
Get
(
)
;
static
size_t
Thread
(
)
{
return
s_global_idx
;
}
static
size_t
GlobalIdx
(
)
{
return
s_global_idx
;
}
static
void
SetGlobalIdx
(
size_t
global_idx
)
{
s_global_idx
=
global_idx
;
}
void
ReserveWorker
(
size_t
global_idx
)
{
HWY_ASSERT
(
!
workers_reserved_
.
Get
(
global_idx
)
)
;
workers_reserved_
.
Set
(
global_idx
)
;
}
void
FreeWorker
(
size_t
global_idx
)
{
HWY_ASSERT
(
workers_reserved_
.
Get
(
global_idx
)
)
;
workers_reserved_
.
Clear
(
global_idx
)
;
}
void
Enter
(
uint64_t
t_enter
size_t
global_idx
)
{
GetWorker
(
global_idx
)
.
Enter
(
t_enter
)
;
}
void
Exit
(
uint64_t
t_exit
size_t
global_idx
profiler
:
:
ZoneHandle
zone
)
{
GetWorker
(
global_idx
)
.
Exit
(
t_exit
global_idx
zone
accumulators_
)
;
}
uint64_t
GetFirstDurationAndReset
(
size_t
global_idx
)
{
return
GetWorker
(
global_idx
)
.
GetFirstDurationAndReset
(
global_idx
accumulators_
)
;
}
const
char
*
Name
(
profiler
:
:
ZoneHandle
zone
)
const
{
return
zones_
.
Name
(
zone
)
;
}
profiler
:
:
ZoneHandle
AddZone
(
const
char
*
name
ProfilerFlags
flags
=
ProfilerFlags
:
:
kDefault
)
{
return
zones_
.
AddZone
(
name
flags
)
;
}
void
AddFunc
(
void
*
owner
ProfilerFunc
func
)
{
funcs_
.
Add
(
reinterpret_cast
<
intptr_t
>
(
owner
)
func
)
;
}
void
RemoveFunc
(
void
*
owner
)
{
funcs_
.
Remove
(
reinterpret_cast
<
intptr_t
>
(
owner
)
)
;
}
bool
IsRootRun
(
)
{
return
!
run_active_
.
test_and_set
(
std
:
:
memory_order_acquire
)
;
}
void
EndRootRun
(
)
{
UpdateResults
(
)
;
results_
.
CountWorkersAndReset
(
)
;
run_active_
.
clear
(
std
:
:
memory_order_release
)
;
}
void
PrintResults
(
)
{
UpdateResults
(
)
;
results_
.
PrintAndReset
(
zones_
)
;
funcs_
.
CallAll
(
)
;
}
void
SetMaxThreads
(
size_t
)
{
}
private
:
Profiler
(
)
;
profiler
:
:
PerWorker
&
GetWorker
(
size_t
global_idx
)
{
HWY_DASSERT
(
workers_reserved_
.
Get
(
global_idx
)
)
;
return
workers_
[
global_idx
]
;
}
void
UpdateResults
(
)
{
std
:
:
atomic_thread_fence
(
std
:
:
memory_order_acquire
)
;
workers_reserved_
.
Foreach
(
[
&
]
(
size_t
global_idx
)
{
workers_
[
global_idx
]
.
MoveTo
(
global_idx
accumulators_
results_
)
;
}
)
;
}
static
thread_local
size_t
s_global_idx
;
profiler
:
:
AtomicWorkerSet
workers_reserved_
;
std
:
:
atomic_flag
run_active_
=
ATOMIC_FLAG_INIT
;
profiler
:
:
Funcs
funcs_
;
profiler
:
:
PerWorker
workers_
[
profiler
:
:
kMaxWorkers
]
;
profiler
:
:
Accumulators
accumulators_
;
profiler
:
:
Results
results_
;
profiler
:
:
Zones
zones_
;
}
;
namespace
profiler
{
class
Zone
{
public
:
Zone
(
Profiler
&
profiler
size_t
global_idx
ZoneHandle
zone
)
:
profiler_
(
profiler
)
{
HWY_FENCE
;
const
uint64_t
t_enter
=
timer
:
:
Start
(
)
;
HWY_FENCE
;
global_idx_
=
static_cast
<
uint32_t
>
(
global_idx
)
;
zone_
=
zone
;
profiler
.
Enter
(
t_enter
global_idx
)
;
HWY_FENCE
;
}
~
Zone
(
)
{
HWY_FENCE
;
const
uint64_t
t_exit
=
timer
:
:
Stop
(
)
;
profiler_
.
Exit
(
t_exit
static_cast
<
size_t
>
(
global_idx_
)
zone_
)
;
HWY_FENCE
;
}
private
:
Profiler
&
profiler_
;
uint32_t
global_idx_
;
ZoneHandle
zone_
;
}
;
}
#
else
namespace
profiler
{
struct
ZoneHandle
{
}
;
}
struct
Profiler
{
static
HWY_DLLEXPORT
Profiler
&
Get
(
)
;
static
size_t
Thread
(
)
{
return
0
;
}
static
size_t
GlobalIdx
(
)
{
return
0
;
}
static
void
SetGlobalIdx
(
size_t
)
{
}
void
ReserveWorker
(
size_t
)
{
}
void
FreeWorker
(
size_t
)
{
}
void
Enter
(
uint64_t
size_t
)
{
}
void
Exit
(
uint64_t
size_t
profiler
:
:
ZoneHandle
)
{
}
uint64_t
GetFirstDurationAndReset
(
size_t
)
{
return
0
;
}
const
char
*
Name
(
profiler
:
:
ZoneHandle
)
const
{
return
nullptr
;
}
profiler
:
:
ZoneHandle
AddZone
(
const
char
*
ProfilerFlags
=
ProfilerFlags
:
:
kDefault
)
{
return
profiler
:
:
ZoneHandle
(
)
;
}
void
AddFunc
(
void
*
ProfilerFunc
)
{
}
void
RemoveFunc
(
void
*
)
{
}
bool
IsRootRun
(
)
{
return
false
;
}
void
EndRootRun
(
)
{
}
void
PrintResults
(
)
{
}
void
SetMaxThreads
(
size_t
)
{
}
}
;
namespace
profiler
{
struct
Zone
{
Zone
(
Profiler
&
size_t
ZoneHandle
)
{
}
}
;
}
#
endif
}
#
define
PROFILER_ZONE3
(
p
global_idx
zone
)
\
HWY_FENCE
;
\
const
hwy
:
:
profiler
:
:
Zone
HWY_CONCAT
(
Z
__LINE__
)
(
p
global_idx
zone
)
;
\
HWY_FENCE
#
define
PROFILER_ZONE2
(
global_idx
name
)
\
static
const
hwy
:
:
profiler
:
:
ZoneHandle
HWY_CONCAT
(
zone
__LINE__
)
=
\
hwy
:
:
Profiler
:
:
Get
(
)
.
AddZone
(
name
)
;
\
PROFILER_ZONE3
(
hwy
:
:
Profiler
:
:
Get
(
)
global_idx
HWY_CONCAT
(
zone
__LINE__
)
)
#
define
PROFILER_FUNC2
(
global_idx
)
PROFILER_ZONE2
(
global_idx
__func__
)
#
define
PROFILER_ZONE
(
name
)
PROFILER_ZONE2
(
hwy
:
:
Profiler
:
:
GlobalIdx
(
)
name
)
#
define
PROFILER_FUNC
PROFILER_FUNC2
(
hwy
:
:
Profiler
:
:
GlobalIdx
(
)
)
#
define
PROFILER_ADD_ZONE
(
name
)
hwy
:
:
Profiler
:
:
Get
(
)
.
AddZone
(
name
)
#
define
PROFILER_IS_ROOT_RUN
(
)
hwy
:
:
Profiler
:
:
Get
(
)
.
IsRootRun
(
)
#
define
PROFILER_END_ROOT_RUN
(
)
hwy
:
:
Profiler
:
:
Get
(
)
.
EndRootRun
(
)
#
define
PROFILER_PRINT_RESULTS
(
)
hwy
:
:
Profiler
:
:
Get
(
)
.
PrintResults
(
)
#
endif
