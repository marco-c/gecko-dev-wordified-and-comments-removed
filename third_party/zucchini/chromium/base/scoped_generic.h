#
ifndef
BASE_SCOPED_GENERIC_H_
#
define
BASE_SCOPED_GENERIC_H_
#
include
<
stdlib
.
h
>
#
include
<
type_traits
>
#
include
"
base
/
check
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
namespace
base
{
struct
ScopedGenericOwnershipTracking
{
}
;
template
<
typename
T
typename
Traits
>
class
ScopedGeneric
{
private
:
struct
Data
:
public
Traits
{
explicit
Data
(
const
T
&
in
)
:
generic
(
in
)
{
}
Data
(
const
T
&
in
const
Traits
&
other
)
:
Traits
(
other
)
generic
(
in
)
{
}
T
generic
;
}
;
public
:
typedef
T
element_type
;
typedef
Traits
traits_type
;
ScopedGeneric
(
)
:
data_
(
traits_type
:
:
InvalidValue
(
)
)
{
}
explicit
ScopedGeneric
(
const
element_type
&
value
)
:
data_
(
value
)
{
TrackAcquire
(
data_
.
generic
)
;
}
ScopedGeneric
(
const
element_type
&
value
const
traits_type
&
traits
)
:
data_
(
value
traits
)
{
TrackAcquire
(
data_
.
generic
)
;
}
ScopedGeneric
(
ScopedGeneric
<
T
Traits
>
&
&
rvalue
)
:
data_
(
rvalue
.
release
(
)
rvalue
.
get_traits
(
)
)
{
TrackAcquire
(
data_
.
generic
)
;
}
ScopedGeneric
(
const
ScopedGeneric
&
)
=
delete
;
ScopedGeneric
&
operator
=
(
const
ScopedGeneric
&
)
=
delete
;
virtual
~
ScopedGeneric
(
)
{
CHECK
(
!
receiving_
)
;
FreeIfNecessary
(
)
;
}
ScopedGeneric
&
operator
=
(
ScopedGeneric
<
T
Traits
>
&
&
rvalue
)
{
reset
(
rvalue
.
release
(
)
)
;
return
*
this
;
}
void
reset
(
const
element_type
&
value
=
traits_type
:
:
InvalidValue
(
)
)
{
if
(
data_
.
generic
!
=
traits_type
:
:
InvalidValue
(
)
&
&
data_
.
generic
=
=
value
)
abort
(
)
;
FreeIfNecessary
(
)
;
data_
.
generic
=
value
;
TrackAcquire
(
value
)
;
}
[
[
nodiscard
]
]
element_type
release
(
)
{
element_type
old_generic
=
data_
.
generic
;
data_
.
generic
=
traits_type
:
:
InvalidValue
(
)
;
TrackRelease
(
old_generic
)
;
return
old_generic
;
}
class
Receiver
{
public
:
explicit
Receiver
(
ScopedGeneric
&
parent
)
:
scoped_generic_
(
&
parent
)
{
CHECK
(
!
scoped_generic_
-
>
receiving_
)
;
scoped_generic_
-
>
receiving_
=
true
;
}
Receiver
(
const
Receiver
&
)
=
delete
;
Receiver
&
operator
=
(
const
Receiver
&
)
=
delete
;
Receiver
(
Receiver
&
&
move
)
{
CHECK
(
!
used_
)
;
CHECK
(
!
move
.
used_
)
;
scoped_generic_
=
move
.
scoped_generic_
;
move
.
scoped_generic_
=
nullptr
;
}
Receiver
&
operator
=
(
Receiver
&
&
move
)
{
CHECK
(
!
used_
)
;
CHECK
(
!
move
.
used_
)
;
scoped_generic_
=
move
.
scoped_generic_
;
move
.
scoped_generic_
=
nullptr
;
}
~
Receiver
(
)
{
if
(
scoped_generic_
)
{
CHECK
(
scoped_generic_
-
>
receiving_
)
;
scoped_generic_
-
>
reset
(
value_
)
;
scoped_generic_
-
>
receiving_
=
false
;
}
}
T
*
get
(
)
{
used_
=
true
;
return
&
value_
;
}
private
:
T
value_
=
Traits
:
:
InvalidValue
(
)
;
raw_ptr
<
ScopedGeneric
<
T
Traits
>
>
scoped_generic_
;
bool
used_
=
false
;
}
;
const
element_type
&
get
(
)
const
{
return
data_
.
generic
;
}
bool
is_valid
(
)
const
{
return
data_
.
generic
!
=
traits_type
:
:
InvalidValue
(
)
;
}
bool
operator
=
=
(
const
element_type
&
value
)
const
{
return
data_
.
generic
=
=
value
;
}
bool
operator
!
=
(
const
element_type
&
value
)
const
{
return
data_
.
generic
!
=
value
;
}
Traits
&
get_traits
(
)
{
return
data_
;
}
const
Traits
&
get_traits
(
)
const
{
return
data_
;
}
private
:
void
FreeIfNecessary
(
)
{
if
(
data_
.
generic
!
=
traits_type
:
:
InvalidValue
(
)
)
{
TrackRelease
(
data_
.
generic
)
;
data_
.
Free
(
data_
.
generic
)
;
data_
.
generic
=
traits_type
:
:
InvalidValue
(
)
;
}
}
template
<
typename
Void
=
void
>
typename
std
:
:
enable_if_t
<
std
:
:
is_base_of
<
ScopedGenericOwnershipTracking
Traits
>
:
:
value
Void
>
TrackAcquire
(
const
T
&
value
)
{
if
(
value
!
=
traits_type
:
:
InvalidValue
(
)
)
{
data_
.
Acquire
(
static_cast
<
const
ScopedGeneric
&
>
(
*
this
)
value
)
;
}
}
template
<
typename
Void
=
void
>
typename
std
:
:
enable_if_t
<
!
std
:
:
is_base_of
<
ScopedGenericOwnershipTracking
Traits
>
:
:
value
Void
>
TrackAcquire
(
const
T
&
value
)
{
}
template
<
typename
Void
=
void
>
typename
std
:
:
enable_if_t
<
std
:
:
is_base_of
<
ScopedGenericOwnershipTracking
Traits
>
:
:
value
Void
>
TrackRelease
(
const
T
&
value
)
{
if
(
value
!
=
traits_type
:
:
InvalidValue
(
)
)
{
data_
.
Release
(
static_cast
<
const
ScopedGeneric
&
>
(
*
this
)
value
)
;
}
}
template
<
typename
Void
=
void
>
typename
std
:
:
enable_if_t
<
!
std
:
:
is_base_of
<
ScopedGenericOwnershipTracking
Traits
>
:
:
value
Void
>
TrackRelease
(
const
T
&
value
)
{
}
template
<
typename
T2
typename
Traits2
>
bool
operator
=
=
(
const
ScopedGeneric
<
T2
Traits2
>
&
p2
)
const
;
template
<
typename
T2
typename
Traits2
>
bool
operator
!
=
(
const
ScopedGeneric
<
T2
Traits2
>
&
p2
)
const
;
Data
data_
;
bool
receiving_
=
false
;
}
;
template
<
class
T
class
Traits
>
void
swap
(
const
ScopedGeneric
<
T
Traits
>
&
a
const
ScopedGeneric
<
T
Traits
>
&
b
)
{
a
.
swap
(
b
)
;
}
template
<
class
T
class
Traits
>
bool
operator
=
=
(
const
T
&
value
const
ScopedGeneric
<
T
Traits
>
&
scoped
)
{
return
value
=
=
scoped
.
get
(
)
;
}
template
<
class
T
class
Traits
>
bool
operator
!
=
(
const
T
&
value
const
ScopedGeneric
<
T
Traits
>
&
scoped
)
{
return
value
!
=
scoped
.
get
(
)
;
}
}
#
endif
