#
ifndef
BASE_ALLOCATOR_PARTITION_ALLOCATOR_POINTERS_RAW_REF_H_
#
define
BASE_ALLOCATOR_PARTITION_ALLOCATOR_POINTERS_RAW_REF_H_
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
allocator
/
partition_allocator
/
partition_alloc_base
/
augmentations
/
compiler_specific
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
partition_alloc_base
/
compiler_specific
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
partition_alloc_buildflags
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
partition_alloc_config
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
pointers
/
raw_ptr
.
h
"
namespace
base
{
template
<
class
T
RawPtrTraits
Traits
>
class
raw_ref
;
namespace
internal
{
template
<
class
T
>
struct
is_raw_ref
:
std
:
:
false_type
{
}
;
template
<
class
T
RawPtrTraits
Traits
>
struct
is_raw_ref
<
:
:
base
:
:
raw_ref
<
T
Traits
>
>
:
std
:
:
true_type
{
}
;
template
<
class
T
>
constexpr
inline
bool
is_raw_ref_v
=
is_raw_ref
<
T
>
:
:
value
;
}
template
<
class
T
RawPtrTraits
Traits
=
RawPtrTraits
:
:
kEmpty
>
class
PA_TRIVIAL_ABI
PA_GSL_POINTER
raw_ref
{
using
Inner
=
raw_ptr
<
T
Traits
|
RawPtrTraits
:
:
kDisableHooks
>
;
static
constexpr
bool
kNeedClearAfterMove
=
!
Inner
:
:
kZeroOnMove
;
public
:
using
Impl
=
typename
Inner
:
:
Impl
;
PA_ALWAYS_INLINE
constexpr
static
raw_ref
from_ptr
(
T
*
ptr
)
noexcept
{
PA_RAW_PTR_CHECK
(
ptr
)
;
return
raw_ref
(
*
ptr
)
;
}
PA_ALWAYS_INLINE
constexpr
explicit
raw_ref
(
T
&
p
)
noexcept
:
inner_
(
std
:
:
addressof
(
p
)
)
{
}
PA_ALWAYS_INLINE
constexpr
raw_ref
&
operator
=
(
T
&
p
)
noexcept
{
inner_
.
operator
=
(
&
p
)
;
return
*
this
;
}
raw_ref
(
const
T
&
&
p
)
=
delete
;
raw_ref
&
operator
=
(
const
T
&
&
p
)
=
delete
;
PA_ALWAYS_INLINE
constexpr
raw_ref
(
const
raw_ref
&
p
)
noexcept
:
inner_
(
p
.
inner_
)
{
PA_RAW_PTR_CHECK
(
inner_
)
;
}
PA_ALWAYS_INLINE
constexpr
raw_ref
(
raw_ref
&
&
p
)
noexcept
:
inner_
(
std
:
:
move
(
p
.
inner_
)
)
{
PA_RAW_PTR_CHECK
(
inner_
)
;
if
constexpr
(
kNeedClearAfterMove
)
{
p
.
inner_
=
nullptr
;
}
}
PA_ALWAYS_INLINE
constexpr
raw_ref
&
operator
=
(
const
raw_ref
&
p
)
noexcept
{
PA_RAW_PTR_CHECK
(
p
.
inner_
)
;
inner_
.
operator
=
(
p
.
inner_
)
;
return
*
this
;
}
PA_ALWAYS_INLINE
constexpr
raw_ref
&
operator
=
(
raw_ref
&
&
p
)
noexcept
{
PA_RAW_PTR_CHECK
(
p
.
inner_
)
;
inner_
.
operator
=
(
std
:
:
move
(
p
.
inner_
)
)
;
if
constexpr
(
kNeedClearAfterMove
)
{
p
.
inner_
=
nullptr
;
}
return
*
this
;
}
template
<
class
U
RawPtrTraits
PassedTraits
class
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
&
T
&
>
>
>
PA_ALWAYS_INLINE
constexpr
raw_ref
(
const
raw_ref
<
U
PassedTraits
>
&
p
)
noexcept
:
inner_
(
p
.
inner_
)
{
PA_RAW_PTR_CHECK
(
inner_
)
;
}
template
<
class
U
RawPtrTraits
PassedTraits
class
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
&
T
&
>
>
>
PA_ALWAYS_INLINE
constexpr
raw_ref
(
raw_ref
<
U
PassedTraits
>
&
&
p
)
noexcept
:
inner_
(
std
:
:
move
(
p
.
inner_
)
)
{
PA_RAW_PTR_CHECK
(
inner_
)
;
if
constexpr
(
kNeedClearAfterMove
)
{
p
.
inner_
=
nullptr
;
}
}
template
<
class
U
RawPtrTraits
PassedTraits
class
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
&
T
&
>
>
>
PA_ALWAYS_INLINE
constexpr
raw_ref
&
operator
=
(
const
raw_ref
<
U
PassedTraits
>
&
p
)
noexcept
{
PA_RAW_PTR_CHECK
(
p
.
inner_
)
;
inner_
.
operator
=
(
p
.
inner_
)
;
return
*
this
;
}
template
<
class
U
RawPtrTraits
PassedTraits
class
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
&
T
&
>
>
>
PA_ALWAYS_INLINE
constexpr
raw_ref
&
operator
=
(
raw_ref
<
U
PassedTraits
>
&
&
p
)
noexcept
{
PA_RAW_PTR_CHECK
(
p
.
inner_
)
;
inner_
.
operator
=
(
std
:
:
move
(
p
.
inner_
)
)
;
if
constexpr
(
kNeedClearAfterMove
)
{
p
.
inner_
=
nullptr
;
}
return
*
this
;
}
PA_ALWAYS_INLINE
constexpr
T
&
operator
*
(
)
const
{
PA_RAW_PTR_CHECK
(
inner_
)
;
return
inner_
.
operator
*
(
)
;
}
PA_ALWAYS_INLINE
constexpr
T
&
get
(
)
const
{
PA_RAW_PTR_CHECK
(
inner_
)
;
return
*
inner_
.
get
(
)
;
}
PA_ALWAYS_INLINE
constexpr
T
*
operator
-
>
(
)
const
PA_ATTRIBUTE_RETURNS_NONNULL
{
PA_RAW_PTR_CHECK
(
inner_
)
;
return
inner_
.
operator
-
>
(
)
;
}
PA_ALWAYS_INLINE
void
ReportIfDangling
(
)
const
noexcept
{
inner_
.
ReportIfDangling
(
)
;
}
PA_ALWAYS_INLINE
friend
constexpr
void
swap
(
raw_ref
&
lhs
raw_ref
&
rhs
)
noexcept
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
swap
(
lhs
.
inner_
rhs
.
inner_
)
;
}
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
friend
bool
operator
=
=
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
;
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
friend
bool
operator
!
=
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
;
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
friend
bool
operator
<
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
;
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
friend
bool
operator
>
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
;
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
friend
bool
operator
<
=
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
;
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
friend
bool
operator
>
=
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
;
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
=
=
(
const
raw_ref
&
lhs
const
U
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
return
lhs
.
inner_
=
=
&
rhs
;
}
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
!
=
(
const
raw_ref
&
lhs
const
U
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
return
lhs
.
inner_
!
=
&
rhs
;
}
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
<
(
const
raw_ref
&
lhs
const
U
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
return
lhs
.
inner_
<
&
rhs
;
}
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
>
(
const
raw_ref
&
lhs
const
U
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
return
lhs
.
inner_
>
&
rhs
;
}
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
<
=
(
const
raw_ref
&
lhs
const
U
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
return
lhs
.
inner_
<
=
&
rhs
;
}
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
>
=
(
const
raw_ref
&
lhs
const
U
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
return
lhs
.
inner_
>
=
&
rhs
;
}
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
=
=
(
const
U
&
lhs
const
raw_ref
&
rhs
)
{
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
&
lhs
=
=
rhs
.
inner_
;
}
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
!
=
(
const
U
&
lhs
const
raw_ref
&
rhs
)
{
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
&
lhs
!
=
rhs
.
inner_
;
}
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
<
(
const
U
&
lhs
const
raw_ref
&
rhs
)
{
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
&
lhs
<
rhs
.
inner_
;
}
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
>
(
const
U
&
lhs
const
raw_ref
&
rhs
)
{
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
&
lhs
>
rhs
.
inner_
;
}
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
<
=
(
const
U
&
lhs
const
raw_ref
&
rhs
)
{
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
&
lhs
<
=
rhs
.
inner_
;
}
template
<
class
U
class
=
std
:
:
enable_if_t
<
!
internal
:
:
is_raw_ref_v
<
U
>
void
>
>
PA_ALWAYS_INLINE
friend
bool
operator
>
=
(
const
U
&
lhs
const
raw_ref
&
rhs
)
{
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
&
lhs
>
=
rhs
.
inner_
;
}
private
:
template
<
class
U
RawPtrTraits
R
>
friend
class
raw_ref
;
Inner
inner_
;
}
;
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
=
=
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
lhs
.
inner_
=
=
rhs
.
inner_
;
}
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
!
=
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
lhs
.
inner_
!
=
rhs
.
inner_
;
}
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
<
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
lhs
.
inner_
<
rhs
.
inner_
;
}
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
>
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
lhs
.
inner_
>
rhs
.
inner_
;
}
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
<
=
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
lhs
.
inner_
<
=
rhs
.
inner_
;
}
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
>
=
(
const
raw_ref
<
U
Traits1
>
&
lhs
const
raw_ref
<
V
Traits2
>
&
rhs
)
{
PA_RAW_PTR_CHECK
(
lhs
.
inner_
)
;
PA_RAW_PTR_CHECK
(
rhs
.
inner_
)
;
return
lhs
.
inner_
>
=
rhs
.
inner_
;
}
template
<
class
T
>
raw_ref
(
T
&
)
-
>
raw_ref
<
T
>
;
template
<
class
T
>
raw_ref
(
const
T
&
)
-
>
raw_ref
<
const
T
>
;
template
<
typename
T
>
struct
IsRawRef
:
std
:
:
false_type
{
}
;
template
<
typename
T
RawPtrTraits
Traits
>
struct
IsRawRef
<
raw_ref
<
T
Traits
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
>
inline
constexpr
bool
IsRawRefV
=
IsRawRef
<
T
>
:
:
value
;
template
<
typename
T
>
struct
RemoveRawRef
{
using
type
=
T
;
}
;
template
<
typename
T
RawPtrTraits
Traits
>
struct
RemoveRawRef
<
raw_ref
<
T
Traits
>
>
{
using
type
=
T
;
}
;
template
<
typename
T
>
using
RemoveRawRefT
=
typename
RemoveRawRef
<
T
>
:
:
type
;
}
using
base
:
:
raw_ref
;
template
<
base
:
:
RawPtrTraits
Traits
=
base
:
:
RawPtrTraits
:
:
kEmpty
typename
T
>
auto
ToRawRef
(
T
&
ref
)
{
return
raw_ref
<
T
Traits
>
(
ref
)
;
}
namespace
std
{
template
<
typename
T
base
:
:
RawPtrTraits
Traits
>
struct
less
<
raw_ref
<
T
Traits
>
>
{
using
Impl
=
typename
raw_ref
<
T
Traits
>
:
:
Impl
;
using
is_transparent
=
void
;
bool
operator
(
)
(
const
raw_ref
<
T
Traits
>
&
lhs
const
raw_ref
<
T
Traits
>
&
rhs
)
const
{
Impl
:
:
IncrementLessCountForTest
(
)
;
return
lhs
<
rhs
;
}
bool
operator
(
)
(
T
&
lhs
const
raw_ref
<
T
Traits
>
&
rhs
)
const
{
Impl
:
:
IncrementLessCountForTest
(
)
;
return
lhs
<
rhs
;
}
bool
operator
(
)
(
const
raw_ref
<
T
Traits
>
&
lhs
T
&
rhs
)
const
{
Impl
:
:
IncrementLessCountForTest
(
)
;
return
lhs
<
rhs
;
}
}
;
template
<
typename
T
:
:
base
:
:
RawPtrTraits
Traits
>
struct
pointer_traits
<
:
:
raw_ref
<
T
Traits
>
>
{
using
pointer
=
:
:
raw_ref
<
T
Traits
>
;
using
element_type
=
T
;
using
difference_type
=
ptrdiff_t
;
template
<
typename
U
>
using
rebind
=
:
:
raw_ref
<
U
Traits
>
;
static
constexpr
pointer
pointer_to
(
element_type
&
r
)
noexcept
{
return
pointer
(
r
)
;
}
static
constexpr
element_type
*
to_address
(
pointer
p
)
noexcept
{
return
&
(
p
.
get
(
)
)
;
}
}
;
}
#
endif
