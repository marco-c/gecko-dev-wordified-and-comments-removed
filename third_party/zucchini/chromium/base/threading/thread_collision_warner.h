#
ifndef
BASE_THREADING_THREAD_COLLISION_WARNER_H_
#
define
BASE_THREADING_THREAD_COLLISION_WARNER_H_
#
include
"
base
/
atomicops
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
if
!
defined
(
NDEBUG
)
#
define
DFAKE_UNIQUE_VARIABLE_CONCAT
(
a
b
)
a
#
#
b
#
define
DFAKE_UNIQUE_VARIABLE_CONCAT1
(
a
b
)
DFAKE_UNIQUE_VARIABLE_CONCAT
(
a
b
)
#
define
DFAKE_UNIQUE_VARIABLE_NAME
(
a
)
DFAKE_UNIQUE_VARIABLE_CONCAT1
(
a
__LINE__
)
#
define
DFAKE_MUTEX
(
obj
)
\
mutable
base
:
:
ThreadCollisionWarner
obj
#
define
DFAKE_SCOPED_LOCK
(
obj
)
\
base
:
:
ThreadCollisionWarner
:
:
ScopedCheck
DFAKE_UNIQUE_VARIABLE_NAME
(
\
s_check_
)
(
&
obj
)
#
define
DFAKE_SCOPED_RECURSIVE_LOCK
(
obj
)
\
base
:
:
ThreadCollisionWarner
:
:
ScopedRecursiveCheck
\
DFAKE_UNIQUE_VARIABLE_NAME
(
sr_check
)
(
&
obj
)
#
define
DFAKE_SCOPED_LOCK_THREAD_LOCKED
(
obj
)
\
base
:
:
ThreadCollisionWarner
:
:
Check
DFAKE_UNIQUE_VARIABLE_NAME
(
check_
)
(
&
obj
)
#
else
#
define
DFAKE_MUTEX
(
obj
)
typedef
void
InternalFakeMutexType
#
#
obj
#
define
DFAKE_SCOPED_LOCK
(
obj
)
(
(
void
)
0
)
#
define
DFAKE_SCOPED_RECURSIVE_LOCK
(
obj
)
(
(
void
)
0
)
#
define
DFAKE_SCOPED_LOCK_THREAD_LOCKED
(
obj
)
(
(
void
)
0
)
#
endif
namespace
base
{
struct
BASE_EXPORT
AsserterBase
{
virtual
~
AsserterBase
(
)
=
default
;
virtual
void
warn
(
)
=
0
;
}
;
struct
BASE_EXPORT
DCheckAsserter
:
public
AsserterBase
{
~
DCheckAsserter
(
)
override
=
default
;
void
warn
(
)
override
;
}
;
class
BASE_EXPORT
ThreadCollisionWarner
{
public
:
explicit
ThreadCollisionWarner
(
AsserterBase
*
asserter
=
new
DCheckAsserter
(
)
)
:
valid_thread_id_
(
0
)
counter_
(
0
)
asserter_
(
asserter
)
{
}
ThreadCollisionWarner
(
const
ThreadCollisionWarner
&
)
=
delete
;
ThreadCollisionWarner
&
operator
=
(
const
ThreadCollisionWarner
&
)
=
delete
;
~
ThreadCollisionWarner
(
)
{
asserter_
.
ClearAndDelete
(
)
;
}
class
BASE_EXPORT
Check
{
public
:
explicit
Check
(
ThreadCollisionWarner
*
warner
)
:
warner_
(
warner
)
{
warner_
-
>
EnterSelf
(
)
;
}
Check
(
const
Check
&
)
=
delete
;
Check
&
operator
=
(
const
Check
&
)
=
delete
;
~
Check
(
)
=
default
;
private
:
raw_ptr
<
ThreadCollisionWarner
>
warner_
;
}
;
class
BASE_EXPORT
ScopedCheck
{
public
:
explicit
ScopedCheck
(
ThreadCollisionWarner
*
warner
)
:
warner_
(
warner
)
{
warner_
-
>
Enter
(
)
;
}
ScopedCheck
(
const
ScopedCheck
&
)
=
delete
;
ScopedCheck
&
operator
=
(
const
ScopedCheck
&
)
=
delete
;
~
ScopedCheck
(
)
{
warner_
-
>
Leave
(
)
;
}
private
:
raw_ptr
<
ThreadCollisionWarner
>
warner_
;
}
;
class
BASE_EXPORT
ScopedRecursiveCheck
{
public
:
explicit
ScopedRecursiveCheck
(
ThreadCollisionWarner
*
warner
)
:
warner_
(
warner
)
{
warner_
-
>
EnterSelf
(
)
;
}
ScopedRecursiveCheck
(
const
ScopedRecursiveCheck
&
)
=
delete
;
ScopedRecursiveCheck
&
operator
=
(
const
ScopedRecursiveCheck
&
)
=
delete
;
~
ScopedRecursiveCheck
(
)
{
warner_
-
>
Leave
(
)
;
}
private
:
raw_ptr
<
ThreadCollisionWarner
>
warner_
;
}
;
private
:
void
EnterSelf
(
)
;
void
Enter
(
)
;
void
Leave
(
)
;
volatile
subtle
:
:
Atomic32
valid_thread_id_
;
volatile
subtle
:
:
Atomic32
counter_
;
raw_ptr
<
AsserterBase
>
asserter_
;
}
;
}
#
endif
