#
ifndef
BASE_MAC_SCOPED_TYPEREF_H_
#
define
BASE_MAC_SCOPED_TYPEREF_H_
#
include
"
base
/
check
.
h
"
#
include
"
base
/
memory
/
scoped_policy
.
h
"
namespace
base
{
template
<
typename
T
>
struct
ScopedTypeRefTraits
;
template
<
typename
T
typename
Traits
=
ScopedTypeRefTraits
<
T
>
>
class
ScopedTypeRef
{
public
:
using
element_type
=
T
;
explicit
constexpr
ScopedTypeRef
(
element_type
object
=
Traits
:
:
InvalidValue
(
)
base
:
:
scoped_policy
:
:
OwnershipPolicy
policy
=
base
:
:
scoped_policy
:
:
ASSUME
)
:
object_
(
object
)
{
if
(
object_
&
&
policy
=
=
base
:
:
scoped_policy
:
:
RETAIN
)
object_
=
Traits
:
:
Retain
(
object_
)
;
}
ScopedTypeRef
(
const
ScopedTypeRef
<
T
Traits
>
&
that
)
:
object_
(
that
.
object_
)
{
if
(
object_
)
object_
=
Traits
:
:
Retain
(
object_
)
;
}
template
<
typename
R
typename
RTraits
>
explicit
ScopedTypeRef
(
const
ScopedTypeRef
<
R
RTraits
>
&
that_as_subclass
)
:
object_
(
that_as_subclass
.
get
(
)
)
{
if
(
object_
)
object_
=
Traits
:
:
Retain
(
object_
)
;
}
ScopedTypeRef
(
ScopedTypeRef
<
T
Traits
>
&
&
that
)
:
object_
(
that
.
object_
)
{
that
.
object_
=
Traits
:
:
InvalidValue
(
)
;
}
~
ScopedTypeRef
(
)
{
if
(
object_
)
Traits
:
:
Release
(
object_
)
;
}
ScopedTypeRef
&
operator
=
(
const
ScopedTypeRef
<
T
Traits
>
&
that
)
{
reset
(
that
.
get
(
)
base
:
:
scoped_policy
:
:
RETAIN
)
;
return
*
this
;
}
[
[
nodiscard
]
]
element_type
*
InitializeInto
(
)
{
DCHECK
(
!
object_
)
;
return
&
object_
;
}
void
reset
(
const
ScopedTypeRef
<
T
Traits
>
&
that
)
{
reset
(
that
.
get
(
)
base
:
:
scoped_policy
:
:
RETAIN
)
;
}
void
reset
(
element_type
object
=
Traits
:
:
InvalidValue
(
)
base
:
:
scoped_policy
:
:
OwnershipPolicy
policy
=
base
:
:
scoped_policy
:
:
ASSUME
)
{
if
(
object
&
&
policy
=
=
base
:
:
scoped_policy
:
:
RETAIN
)
object
=
Traits
:
:
Retain
(
object
)
;
if
(
object_
)
Traits
:
:
Release
(
object_
)
;
object_
=
object
;
}
bool
operator
=
=
(
const
ScopedTypeRef
&
that
)
const
{
return
object_
=
=
that
.
object_
;
}
bool
operator
!
=
(
const
ScopedTypeRef
&
that
)
const
{
return
object_
!
=
that
.
object_
;
}
operator
element_type
(
)
const
{
return
object_
;
}
element_type
get
(
)
const
{
return
object_
;
}
void
swap
(
ScopedTypeRef
&
that
)
{
element_type
temp
=
that
.
object_
;
that
.
object_
=
object_
;
object_
=
temp
;
}
[
[
nodiscard
]
]
element_type
release
(
)
{
element_type
temp
=
object_
;
object_
=
Traits
:
:
InvalidValue
(
)
;
return
temp
;
}
private
:
element_type
object_
;
}
;
}
#
endif
