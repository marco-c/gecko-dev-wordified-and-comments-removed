#
ifndef
BASE_RANGES_ALGORITHM_H_
#
define
BASE_RANGES_ALGORITHM_H_
#
include
<
algorithm
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
check
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
cxx20_is_constant_evaluated
.
h
"
#
include
"
base
/
functional
/
identity
.
h
"
#
include
"
base
/
functional
/
invoke
.
h
"
#
include
"
base
/
memory
/
raw_ptr_exclusion
.
h
"
#
include
"
base
/
ranges
/
functional
.
h
"
#
include
"
base
/
ranges
/
ranges
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
Pred
typename
Proj
>
constexpr
auto
ProjectedUnaryPredicate
(
Pred
&
pred
Proj
&
proj
)
noexcept
{
return
[
&
pred
&
proj
]
(
auto
&
&
arg
)
-
>
bool
{
return
base
:
:
invoke
(
pred
base
:
:
invoke
(
proj
std
:
:
forward
<
decltype
(
arg
)
>
(
arg
)
)
)
;
}
;
}
template
<
typename
Pred
typename
Proj1
typename
Proj2
bool
kPermute
=
false
>
class
BinaryPredicateProjector
{
public
:
constexpr
BinaryPredicateProjector
(
Pred
&
pred
Proj1
&
proj1
Proj2
&
proj2
)
:
pred_
(
pred
)
proj1_
(
proj1
)
proj2_
(
proj2
)
{
}
private
:
template
<
typename
ProjT
typename
ProjU
typename
T
typename
U
>
using
InvokeResult
=
std
:
:
invoke_result_t
<
Pred
&
std
:
:
invoke_result_t
<
ProjT
&
T
&
&
>
std
:
:
invoke_result_t
<
ProjU
&
U
&
&
>
>
;
template
<
typename
T
typename
U
typename
=
InvokeResult
<
Proj1
Proj2
T
U
>
>
constexpr
std
:
:
pair
<
Proj1
&
Proj2
&
>
GetProjs
(
priority_tag
<
3
>
)
const
{
return
{
proj1_
proj2_
}
;
}
template
<
typename
T
typename
U
bool
LazyPermute
=
kPermute
typename
=
std
:
:
enable_if_t
<
LazyPermute
>
typename
=
InvokeResult
<
Proj2
Proj1
T
U
>
>
constexpr
std
:
:
pair
<
Proj2
&
Proj1
&
>
GetProjs
(
priority_tag
<
2
>
)
const
{
return
{
proj2_
proj1_
}
;
}
template
<
typename
T
typename
U
bool
LazyPermute
=
kPermute
typename
=
std
:
:
enable_if_t
<
LazyPermute
>
typename
=
InvokeResult
<
Proj1
Proj1
T
U
>
>
constexpr
std
:
:
pair
<
Proj1
&
Proj1
&
>
GetProjs
(
priority_tag
<
1
>
)
const
{
return
{
proj1_
proj1_
}
;
}
template
<
typename
T
typename
U
bool
LazyPermute
=
kPermute
typename
=
std
:
:
enable_if_t
<
LazyPermute
>
typename
=
InvokeResult
<
Proj2
Proj2
T
U
>
>
constexpr
std
:
:
pair
<
Proj2
&
Proj2
&
>
GetProjs
(
priority_tag
<
0
>
)
const
{
return
{
proj2_
proj2_
}
;
}
public
:
template
<
typename
T
typename
U
>
constexpr
bool
operator
(
)
(
T
&
&
lhs
U
&
&
rhs
)
const
{
auto
projs
=
GetProjs
<
T
U
>
(
priority_tag
<
3
>
(
)
)
;
return
base
:
:
invoke
(
pred_
base
:
:
invoke
(
projs
.
first
std
:
:
forward
<
T
>
(
lhs
)
)
base
:
:
invoke
(
projs
.
second
std
:
:
forward
<
U
>
(
rhs
)
)
)
;
}
private
:
RAW_PTR_EXCLUSION
Pred
&
pred_
;
RAW_PTR_EXCLUSION
Proj1
&
proj1_
;
RAW_PTR_EXCLUSION
Proj2
&
proj2_
;
}
;
template
<
typename
Pred
typename
Proj1
typename
Proj2
>
constexpr
auto
ProjectedBinaryPredicate
(
Pred
&
pred
Proj1
&
proj1
Proj2
&
proj2
)
noexcept
{
return
BinaryPredicateProjector
<
Pred
Proj1
Proj2
>
(
pred
proj1
proj2
)
;
}
template
<
typename
Pred
typename
Proj1
typename
Proj2
>
constexpr
auto
PermutedProjectedBinaryPredicate
(
Pred
&
pred
Proj1
&
proj1
Proj2
&
proj2
)
noexcept
{
return
BinaryPredicateProjector
<
Pred
Proj1
Proj2
true
>
(
pred
proj1
proj2
)
;
}
template
<
typename
Iter
typename
=
decltype
(
+
+
std
:
:
declval
<
Iter
&
>
(
)
)
typename
=
decltype
(
std
:
:
declval
<
Iter
&
>
(
)
+
+
)
>
using
iterator_category_t
=
typename
std
:
:
iterator_traits
<
Iter
>
:
:
iterator_category
;
template
<
typename
Range
>
using
range_category_t
=
iterator_category_t
<
ranges
:
:
iterator_t
<
Range
>
>
;
}
namespace
ranges
{
template
<
typename
I
typename
F
>
struct
in_fun_result
{
NO_UNIQUE_ADDRESS
I
in
;
NO_UNIQUE_ADDRESS
F
fun
;
template
<
typename
I2
typename
F2
std
:
:
enable_if_t
<
std
:
:
is_convertible
<
const
I
&
I2
>
{
}
&
&
std
:
:
is_convertible
<
const
F
&
F2
>
{
}
>
>
constexpr
operator
in_fun_result
<
I2
F2
>
(
)
const
&
{
return
{
in
fun
}
;
}
template
<
typename
I2
typename
F2
std
:
:
enable_if_t
<
std
:
:
is_convertible
<
I
I2
>
{
}
&
&
std
:
:
is_convertible
<
F
F2
>
{
}
>
>
constexpr
operator
in_fun_result
<
I2
F2
>
(
)
&
&
{
return
{
std
:
:
move
(
in
)
std
:
:
move
(
fun
)
}
;
}
}
;
template
<
typename
InputIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
>
constexpr
bool
all_of
(
InputIterator
first
InputIterator
last
Pred
pred
Proj
proj
=
{
}
)
{
for
(
;
first
!
=
last
;
+
+
first
)
{
if
(
!
base
:
:
invoke
(
pred
base
:
:
invoke
(
proj
*
first
)
)
)
return
false
;
}
return
true
;
}
template
<
typename
Range
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
bool
all_of
(
Range
&
&
range
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
all_of
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
>
constexpr
bool
any_of
(
InputIterator
first
InputIterator
last
Pred
pred
Proj
proj
=
{
}
)
{
for
(
;
first
!
=
last
;
+
+
first
)
{
if
(
base
:
:
invoke
(
pred
base
:
:
invoke
(
proj
*
first
)
)
)
return
true
;
}
return
false
;
}
template
<
typename
Range
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
bool
any_of
(
Range
&
&
range
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
any_of
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
>
constexpr
bool
none_of
(
InputIterator
first
InputIterator
last
Pred
pred
Proj
proj
=
{
}
)
{
for
(
;
first
!
=
last
;
+
+
first
)
{
if
(
base
:
:
invoke
(
pred
base
:
:
invoke
(
proj
*
first
)
)
)
return
false
;
}
return
true
;
}
template
<
typename
Range
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
bool
none_of
(
Range
&
&
range
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
none_of
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
I
typename
F
>
using
for_each_result
=
in_fun_result
<
I
F
>
;
template
<
typename
InputIterator
typename
Fun
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
>
constexpr
auto
for_each
(
InputIterator
first
InputIterator
last
Fun
f
Proj
proj
=
{
}
)
{
for
(
;
first
!
=
last
;
+
+
first
)
base
:
:
invoke
(
f
base
:
:
invoke
(
proj
*
first
)
)
;
return
for_each_result
<
InputIterator
Fun
>
{
first
std
:
:
move
(
f
)
}
;
}
template
<
typename
Range
typename
Fun
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
for_each
(
Range
&
&
range
Fun
f
Proj
proj
=
{
}
)
{
return
ranges
:
:
for_each
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
f
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
I
typename
F
>
using
for_each_n_result
=
in_fun_result
<
I
F
>
;
template
<
typename
InputIterator
typename
Size
typename
Fun
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
>
constexpr
auto
for_each_n
(
InputIterator
first
Size
n
Fun
f
Proj
proj
=
{
}
)
{
while
(
n
>
0
)
{
base
:
:
invoke
(
f
base
:
:
invoke
(
proj
*
first
)
)
;
+
+
first
;
-
-
n
;
}
return
for_each_n_result
<
InputIterator
Fun
>
{
first
std
:
:
move
(
f
)
}
;
}
template
<
typename
InputIterator
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
>
constexpr
auto
find
(
InputIterator
first
InputIterator
last
const
T
&
value
Proj
proj
=
{
}
)
{
for
(
;
first
!
=
last
;
+
+
first
)
{
if
(
base
:
:
invoke
(
proj
*
first
)
=
=
value
)
break
;
}
return
first
;
}
template
<
typename
Range
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
find
(
Range
&
&
range
const
T
&
value
Proj
proj
=
{
}
)
{
return
ranges
:
:
find
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
value
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
>
constexpr
auto
find_if
(
InputIterator
first
InputIterator
last
Pred
pred
Proj
proj
=
{
}
)
{
return
std
:
:
find_if
(
first
last
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
)
;
}
template
<
typename
Range
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
find_if
(
Range
&
&
range
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
find_if
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
>
constexpr
auto
find_if_not
(
InputIterator
first
InputIterator
last
Pred
pred
Proj
proj
=
{
}
)
{
return
std
:
:
find_if_not
(
first
last
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
)
;
}
template
<
typename
Range
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
find_if_not
(
Range
&
&
range
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
find_if_not
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator1
typename
ForwardIterator2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator1
>
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
ForwardIterator1
Proj1
>
projected
<
ForwardIterator2
Proj2
>
>
>
constexpr
auto
find_end
(
ForwardIterator1
first1
ForwardIterator1
last1
ForwardIterator2
first2
ForwardIterator2
last2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
std
:
:
find_end
(
first1
last1
first2
last2
internal
:
:
ProjectedBinaryPredicate
(
pred
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
>
constexpr
auto
find_end
(
Range1
&
&
range1
Range2
&
&
range2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
find_end
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
ForwardIterator1
typename
ForwardIterator2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator1
>
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
ForwardIterator1
Proj1
>
projected
<
ForwardIterator2
Proj2
>
>
>
constexpr
auto
find_first_of
(
ForwardIterator1
first1
ForwardIterator1
last1
ForwardIterator2
first2
ForwardIterator2
last2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
std
:
:
find_first_of
(
first1
last1
first2
last2
internal
:
:
ProjectedBinaryPredicate
(
pred
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
>
constexpr
auto
find_first_of
(
Range1
&
&
range1
Range2
&
&
range2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
find_first_of
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
ForwardIterator
typename
Pred
=
ranges
:
:
equal_to
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
adjacent_find
(
ForwardIterator
first
ForwardIterator
last
Pred
pred
=
{
}
Proj
proj
=
{
}
)
{
if
(
first
=
=
last
)
return
last
;
for
(
ForwardIterator
next
=
first
;
+
+
next
!
=
last
;
+
+
first
)
{
if
(
base
:
:
invoke
(
pred
base
:
:
invoke
(
proj
*
first
)
base
:
:
invoke
(
proj
*
next
)
)
)
{
return
first
;
}
}
return
last
;
}
template
<
typename
Range
typename
Pred
=
ranges
:
:
equal_to
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
adjacent_find
(
Range
&
&
range
Pred
pred
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
adjacent_find
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
>
constexpr
auto
count
(
InputIterator
first
InputIterator
last
const
T
&
value
Proj
proj
=
{
}
)
{
return
std
:
:
count_if
(
first
last
[
&
proj
&
value
]
(
auto
&
&
lhs
)
{
return
base
:
:
invoke
(
proj
std
:
:
forward
<
decltype
(
lhs
)
>
(
lhs
)
)
=
=
value
;
}
)
;
}
template
<
typename
Range
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
count
(
Range
&
&
range
const
T
&
value
Proj
proj
=
{
}
)
{
return
ranges
:
:
count
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
value
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
>
constexpr
auto
count_if
(
InputIterator
first
InputIterator
last
Pred
pred
Proj
proj
=
{
}
)
{
return
std
:
:
count_if
(
first
last
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
)
;
}
template
<
typename
Range
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
count_if
(
Range
&
&
range
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
count_if
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator1
typename
ForwardIterator2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator1
>
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
ForwardIterator1
Proj1
>
projected
<
ForwardIterator2
Proj2
>
>
>
constexpr
auto
mismatch
(
ForwardIterator1
first1
ForwardIterator1
last1
ForwardIterator2
first2
ForwardIterator2
last2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
std
:
:
mismatch
(
first1
last1
first2
last2
internal
:
:
ProjectedBinaryPredicate
(
pred
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
>
constexpr
auto
mismatch
(
Range1
&
&
range1
Range2
&
&
range2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
mismatch
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
ForwardIterator1
typename
ForwardIterator2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator1
>
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
ForwardIterator1
Proj1
>
projected
<
ForwardIterator2
Proj2
>
>
>
constexpr
bool
equal
(
ForwardIterator1
first1
ForwardIterator1
last1
ForwardIterator2
first2
ForwardIterator2
last2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
if
(
base
:
:
is_constant_evaluated
(
)
)
{
for
(
;
first1
!
=
last1
&
&
first2
!
=
last2
;
+
+
first1
+
+
first2
)
{
if
(
!
base
:
:
invoke
(
pred
base
:
:
invoke
(
proj1
*
first1
)
base
:
:
invoke
(
proj2
*
first2
)
)
)
{
return
false
;
}
}
return
first1
=
=
last1
&
&
first2
=
=
last2
;
}
return
std
:
:
equal
(
first1
last1
first2
last2
internal
:
:
ProjectedBinaryPredicate
(
pred
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
>
constexpr
bool
equal
(
Range1
&
&
range1
Range2
&
&
range2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
equal
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
ForwardIterator1
typename
ForwardIterator2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator1
>
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
ForwardIterator1
Proj1
>
projected
<
ForwardIterator2
Proj2
>
>
>
constexpr
bool
is_permutation
(
ForwardIterator1
first1
ForwardIterator1
last1
ForwardIterator2
first2
ForwardIterator2
last2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
std
:
:
is_permutation
(
first1
last1
first2
last2
internal
:
:
PermutedProjectedBinaryPredicate
(
pred
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
>
constexpr
bool
is_permutation
(
Range1
&
&
range1
Range2
&
&
range2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
is_permutation
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
ForwardIterator1
typename
ForwardIterator2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator1
>
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
ForwardIterator1
Proj1
>
projected
<
ForwardIterator2
Proj2
>
>
>
constexpr
auto
search
(
ForwardIterator1
first1
ForwardIterator1
last1
ForwardIterator2
first2
ForwardIterator2
last2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
std
:
:
search
(
first1
last1
first2
last2
internal
:
:
ProjectedBinaryPredicate
(
pred
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
Pred
=
ranges
:
:
equal_to
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
indirect_result_t
<
Pred
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
>
constexpr
auto
search
(
Range1
&
&
range1
Range2
&
&
range2
Pred
pred
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
search
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
ForwardIterator
typename
Size
typename
T
typename
Pred
=
ranges
:
:
equal_to
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
search_n
(
ForwardIterator
first
ForwardIterator
last
Size
count
const
T
&
value
Pred
pred
=
{
}
Proj
proj
=
{
}
)
{
identity
value_proj
;
return
std
:
:
search_n
(
first
last
count
value
internal
:
:
ProjectedBinaryPredicate
(
pred
proj
value_proj
)
)
;
}
template
<
typename
Range
typename
Size
typename
T
typename
Pred
=
ranges
:
:
equal_to
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
search_n
(
Range
&
&
range
Size
count
const
T
&
value
Pred
pred
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
search_n
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
count
value
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
OutputIterator
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
copy
(
InputIterator
first
InputIterator
last
OutputIterator
result
)
{
return
std
:
:
copy
(
first
last
result
)
;
}
template
<
typename
Range
typename
OutputIterator
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
copy
(
Range
&
&
range
OutputIterator
result
)
{
return
ranges
:
:
copy
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
)
;
}
template
<
typename
InputIterator
typename
Size
typename
OutputIterator
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
copy_n
(
InputIterator
first
Size
n
OutputIterator
result
)
{
return
std
:
:
copy_n
(
first
n
result
)
;
}
template
<
typename
InputIterator
typename
OutputIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
copy_if
(
InputIterator
first
InputIterator
last
OutputIterator
result
Pred
pred
Proj
proj
=
{
}
)
{
return
std
:
:
copy_if
(
first
last
result
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
)
;
}
template
<
typename
Range
typename
OutputIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
copy_if
(
Range
&
&
range
OutputIterator
result
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
copy_if
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
BidirectionalIterator1
typename
BidirectionalIterator2
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator1
>
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator2
>
>
constexpr
auto
copy_backward
(
BidirectionalIterator1
first
BidirectionalIterator1
last
BidirectionalIterator2
result
)
{
return
std
:
:
copy_backward
(
first
last
result
)
;
}
template
<
typename
Range
typename
BidirectionalIterator
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator
>
>
constexpr
auto
copy_backward
(
Range
&
&
range
BidirectionalIterator
result
)
{
return
ranges
:
:
copy_backward
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
)
;
}
template
<
typename
InputIterator
typename
OutputIterator
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
move
(
InputIterator
first
InputIterator
last
OutputIterator
result
)
{
return
std
:
:
move
(
first
last
result
)
;
}
template
<
typename
Range
typename
OutputIterator
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
move
(
Range
&
&
range
OutputIterator
result
)
{
return
ranges
:
:
move
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
)
;
}
template
<
typename
BidirectionalIterator1
typename
BidirectionalIterator2
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator1
>
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator2
>
>
constexpr
auto
move_backward
(
BidirectionalIterator1
first
BidirectionalIterator1
last
BidirectionalIterator2
result
)
{
return
std
:
:
move_backward
(
first
last
result
)
;
}
template
<
typename
Range
typename
BidirectionalIterator
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator
>
>
constexpr
auto
move_backward
(
Range
&
&
range
BidirectionalIterator
result
)
{
return
ranges
:
:
move_backward
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
)
;
}
template
<
typename
ForwardIterator1
typename
ForwardIterator2
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator1
>
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator2
>
>
constexpr
auto
swap_ranges
(
ForwardIterator1
first1
ForwardIterator1
last1
ForwardIterator2
first2
ForwardIterator2
last2
)
{
last1
=
std
:
:
next
(
first1
std
:
:
min
(
std
:
:
distance
(
first1
last1
)
std
:
:
distance
(
first2
last2
)
)
)
;
return
std
:
:
swap_ranges
(
first1
last1
first2
)
;
}
template
<
typename
Range1
typename
Range2
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
>
constexpr
auto
swap_ranges
(
Range1
&
&
range1
Range2
&
&
range2
)
{
return
ranges
:
:
swap_ranges
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
)
;
}
template
<
typename
InputIterator
typename
OutputIterator
typename
UnaryOperation
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
UnaryOperation
&
projected
<
InputIterator
Proj
>
>
>
constexpr
auto
transform
(
InputIterator
first1
InputIterator
last1
OutputIterator
result
UnaryOperation
op
Proj
proj
=
{
}
)
{
return
std
:
:
transform
(
first1
last1
result
[
&
op
&
proj
]
(
auto
&
&
arg
)
{
return
base
:
:
invoke
(
op
base
:
:
invoke
(
proj
std
:
:
forward
<
decltype
(
arg
)
>
(
arg
)
)
)
;
}
)
;
}
template
<
typename
Range
typename
OutputIterator
typename
UnaryOperation
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
UnaryOperation
&
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
transform
(
Range
&
&
range
OutputIterator
result
UnaryOperation
op
Proj
proj
=
{
}
)
{
return
ranges
:
:
transform
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
std
:
:
move
(
op
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator1
typename
ForwardIterator2
typename
OutputIterator
typename
BinaryOperation
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator1
>
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
BinaryOperation
&
projected
<
ForwardIterator1
Proj1
>
projected
<
ForwardIterator2
Proj2
>
>
>
constexpr
auto
transform
(
ForwardIterator1
first1
ForwardIterator1
last1
ForwardIterator2
first2
ForwardIterator2
last2
OutputIterator
result
BinaryOperation
binary_op
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
last1
=
std
:
:
next
(
first1
std
:
:
min
(
std
:
:
distance
(
first1
last1
)
std
:
:
distance
(
first2
last2
)
)
)
;
return
std
:
:
transform
(
first1
last1
first2
result
[
&
binary_op
&
proj1
&
proj2
]
(
auto
&
&
lhs
auto
&
&
rhs
)
{
return
base
:
:
invoke
(
binary_op
base
:
:
invoke
(
proj1
std
:
:
forward
<
decltype
(
lhs
)
>
(
lhs
)
)
base
:
:
invoke
(
proj2
std
:
:
forward
<
decltype
(
rhs
)
>
(
rhs
)
)
)
;
}
)
;
}
template
<
typename
Range1
typename
Range2
typename
OutputIterator
typename
BinaryOperation
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
BinaryOperation
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
>
constexpr
auto
transform
(
Range1
&
&
range1
Range2
&
&
range2
OutputIterator
result
BinaryOperation
binary_op
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
transform
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
result
std
:
:
move
(
binary_op
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
ForwardIterator
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
replace
(
ForwardIterator
first
ForwardIterator
last
const
T
&
old_value
const
T
&
new_value
Proj
proj
=
{
}
)
{
std
:
:
replace_if
(
first
last
[
&
proj
&
old_value
]
(
auto
&
&
lhs
)
{
return
base
:
:
invoke
(
proj
std
:
:
forward
<
decltype
(
lhs
)
>
(
lhs
)
)
=
=
old_value
;
}
new_value
)
;
return
last
;
}
template
<
typename
Range
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
replace
(
Range
&
&
range
const
T
&
old_value
const
T
&
new_value
Proj
proj
=
{
}
)
{
return
ranges
:
:
replace
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
old_value
new_value
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
Predicate
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
replace_if
(
ForwardIterator
first
ForwardIterator
last
Predicate
pred
const
T
&
new_value
Proj
proj
=
{
}
)
{
std
:
:
replace_if
(
first
last
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
new_value
)
;
return
last
;
}
template
<
typename
Range
typename
Predicate
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
replace_if
(
Range
&
&
range
Predicate
pred
const
T
&
new_value
Proj
proj
=
{
}
)
{
return
ranges
:
:
replace_if
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
new_value
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
OutputIterator
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
replace_copy
(
InputIterator
first
InputIterator
last
OutputIterator
result
const
T
&
old_value
const
T
&
new_value
Proj
proj
=
{
}
)
{
std
:
:
replace_copy_if
(
first
last
result
[
&
proj
&
old_value
]
(
auto
&
&
lhs
)
{
return
base
:
:
invoke
(
proj
std
:
:
forward
<
decltype
(
lhs
)
>
(
lhs
)
)
=
=
old_value
;
}
new_value
)
;
return
last
;
}
template
<
typename
Range
typename
OutputIterator
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
replace_copy
(
Range
&
&
range
OutputIterator
result
const
T
&
old_value
const
T
&
new_value
Proj
proj
=
{
}
)
{
return
ranges
:
:
replace_copy
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
old_value
new_value
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
OutputIterator
typename
Predicate
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
replace_copy_if
(
InputIterator
first
InputIterator
last
OutputIterator
result
Predicate
pred
const
T
&
new_value
Proj
proj
=
{
}
)
{
return
std
:
:
replace_copy_if
(
first
last
result
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
new_value
)
;
}
template
<
typename
Range
typename
OutputIterator
typename
Predicate
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
replace_copy_if
(
Range
&
&
range
OutputIterator
result
Predicate
pred
const
T
&
new_value
Proj
proj
=
{
}
)
{
return
ranges
:
:
replace_copy_if
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
pred
new_value
std
:
:
move
(
proj
)
)
;
}
template
<
typename
OutputIterator
typename
T
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
fill
(
OutputIterator
first
OutputIterator
last
const
T
&
value
)
{
std
:
:
fill
(
first
last
value
)
;
return
last
;
}
template
<
typename
Range
typename
T
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
fill
(
Range
&
&
range
const
T
&
value
)
{
return
ranges
:
:
fill
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
value
)
;
}
template
<
typename
OutputIterator
typename
Size
typename
T
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
fill_n
(
OutputIterator
first
Size
n
const
T
&
value
)
{
return
std
:
:
fill_n
(
first
n
value
)
;
}
template
<
typename
OutputIterator
typename
Generator
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
generate
(
OutputIterator
first
OutputIterator
last
Generator
gen
)
{
std
:
:
generate
(
first
last
std
:
:
move
(
gen
)
)
;
return
last
;
}
template
<
typename
Range
typename
Generator
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
generate
(
Range
&
&
range
Generator
gen
)
{
return
ranges
:
:
generate
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
gen
)
)
;
}
template
<
typename
OutputIterator
typename
Size
typename
Generator
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
generate_n
(
OutputIterator
first
Size
n
Generator
gen
)
{
return
std
:
:
generate_n
(
first
n
std
:
:
move
(
gen
)
)
;
}
template
<
typename
ForwardIterator
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
remove
(
ForwardIterator
first
ForwardIterator
last
const
T
&
value
Proj
proj
=
{
}
)
{
return
std
:
:
remove_if
(
first
last
[
&
proj
&
value
]
(
auto
&
&
lhs
)
{
return
base
:
:
invoke
(
proj
std
:
:
forward
<
decltype
(
lhs
)
>
(
lhs
)
)
=
=
value
;
}
)
;
}
template
<
typename
Range
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
remove
(
Range
&
&
range
const
T
&
value
Proj
proj
=
{
}
)
{
return
ranges
:
:
remove
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
value
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
Predicate
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
remove_if
(
ForwardIterator
first
ForwardIterator
last
Predicate
pred
Proj
proj
=
{
}
)
{
return
std
:
:
remove_if
(
first
last
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
)
;
}
template
<
typename
Range
typename
Predicate
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
remove_if
(
Range
&
&
range
Predicate
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
remove_if
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
OutputIterator
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
remove_copy
(
InputIterator
first
InputIterator
last
OutputIterator
result
const
T
&
value
Proj
proj
=
{
}
)
{
return
std
:
:
remove_copy_if
(
first
last
result
[
&
proj
&
value
]
(
auto
&
&
lhs
)
{
return
base
:
:
invoke
(
proj
std
:
:
forward
<
decltype
(
lhs
)
>
(
lhs
)
)
=
=
value
;
}
)
;
}
template
<
typename
Range
typename
OutputIterator
typename
T
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
remove_copy
(
Range
&
&
range
OutputIterator
result
const
T
&
value
Proj
proj
=
{
}
)
{
return
ranges
:
:
remove_copy
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
value
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
OutputIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
remove_copy_if
(
InputIterator
first
InputIterator
last
OutputIterator
result
Pred
pred
Proj
proj
=
{
}
)
{
return
std
:
:
remove_copy_if
(
first
last
result
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
)
;
}
template
<
typename
Range
typename
OutputIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
remove_copy_if
(
Range
&
&
range
OutputIterator
result
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
remove_copy_if
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
Comp
=
ranges
:
:
equal_to
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
ForwardIterator
Proj
>
projected
<
ForwardIterator
Proj
>
>
>
constexpr
auto
unique
(
ForwardIterator
first
ForwardIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
std
:
:
unique
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
equal_to
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
unique
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
unique
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
OutputIterator
typename
Comp
=
ranges
:
:
equal_to
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
unique_copy
(
ForwardIterator
first
ForwardIterator
last
OutputIterator
result
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
std
:
:
unique_copy
(
first
last
result
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
Range
typename
OutputIterator
typename
Comp
=
ranges
:
:
equal_to
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
unique_copy
(
Range
&
&
range
OutputIterator
result
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
unique_copy
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
BidirectionalIterator
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator
>
>
constexpr
auto
reverse
(
BidirectionalIterator
first
BidirectionalIterator
last
)
{
std
:
:
reverse
(
first
last
)
;
return
last
;
}
template
<
typename
Range
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
reverse
(
Range
&
&
range
)
{
return
ranges
:
:
reverse
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
)
;
}
template
<
typename
BidirectionalIterator
typename
OutputIterator
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
reverse_copy
(
BidirectionalIterator
first
BidirectionalIterator
last
OutputIterator
result
)
{
return
std
:
:
reverse_copy
(
first
last
result
)
;
}
template
<
typename
Range
typename
OutputIterator
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
reverse_copy
(
Range
&
&
range
OutputIterator
result
)
{
return
ranges
:
:
reverse_copy
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
result
)
;
}
template
<
typename
ForwardIterator
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
rotate
(
ForwardIterator
first
ForwardIterator
middle
ForwardIterator
last
)
{
return
std
:
:
rotate
(
first
middle
last
)
;
}
template
<
typename
Range
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
rotate
(
Range
&
&
range
iterator_t
<
Range
>
middle
)
{
return
ranges
:
:
rotate
(
ranges
:
:
begin
(
range
)
middle
ranges
:
:
end
(
range
)
)
;
}
template
<
typename
ForwardIterator
typename
OutputIterator
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
rotate_copy
(
ForwardIterator
first
ForwardIterator
middle
ForwardIterator
last
OutputIterator
result
)
{
return
std
:
:
rotate_copy
(
first
middle
last
result
)
;
}
template
<
typename
Range
typename
OutputIterator
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
>
constexpr
auto
rotate_copy
(
Range
&
&
range
iterator_t
<
Range
>
middle
OutputIterator
result
)
{
return
ranges
:
:
rotate_copy
(
ranges
:
:
begin
(
range
)
middle
ranges
:
:
end
(
range
)
result
)
;
}
template
<
typename
RandomAccessIterator
typename
UniformRandomBitGenerator
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
>
constexpr
auto
shuffle
(
RandomAccessIterator
first
RandomAccessIterator
last
UniformRandomBitGenerator
&
&
g
)
{
std
:
:
shuffle
(
first
last
std
:
:
forward
<
UniformRandomBitGenerator
>
(
g
)
)
;
return
last
;
}
template
<
typename
Range
typename
UniformRandomBitGenerator
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
shuffle
(
Range
&
&
range
UniformRandomBitGenerator
&
&
g
)
{
return
ranges
:
:
shuffle
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
forward
<
UniformRandomBitGenerator
>
(
g
)
)
;
}
template
<
typename
RandomAccessIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
RandomAccessIterator
Proj
>
projected
<
RandomAccessIterator
Proj
>
>
>
constexpr
auto
sort
(
RandomAccessIterator
first
RandomAccessIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
std
:
:
sort
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
return
last
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
sort
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
sort
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
RandomAccessIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
RandomAccessIterator
Proj
>
projected
<
RandomAccessIterator
Proj
>
>
>
constexpr
auto
stable_sort
(
RandomAccessIterator
first
RandomAccessIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
std
:
:
stable_sort
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
return
last
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
stable_sort
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
stable_sort
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
RandomAccessIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
RandomAccessIterator
Proj
>
projected
<
RandomAccessIterator
Proj
>
>
>
constexpr
auto
partial_sort
(
RandomAccessIterator
first
RandomAccessIterator
middle
RandomAccessIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
std
:
:
partial_sort
(
first
middle
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
return
last
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
partial_sort
(
Range
&
&
range
iterator_t
<
Range
>
middle
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
partial_sort
(
ranges
:
:
begin
(
range
)
middle
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
RandomAccessIterator
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator
Proj1
>
projected
<
RandomAccessIterator
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
RandomAccessIterator
Proj2
>
projected
<
InputIterator
Proj1
>
>
>
constexpr
auto
partial_sort_copy
(
InputIterator
first
InputIterator
last
RandomAccessIterator
result_first
RandomAccessIterator
result_last
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
std
:
:
partial_sort_copy
(
first
last
result_first
result_last
internal
:
:
PermutedProjectedBinaryPredicate
(
comp
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range2
>
Proj2
>
projected
<
iterator_t
<
Range1
>
Proj1
>
>
>
constexpr
auto
partial_sort_copy
(
Range1
&
&
range
Range2
&
&
result_range
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
partial_sort_copy
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
ranges
:
:
begin
(
result_range
)
ranges
:
:
end
(
result_range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
ForwardIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
ForwardIterator
Proj
>
projected
<
ForwardIterator
Proj
>
>
>
constexpr
auto
is_sorted_until
(
ForwardIterator
first
ForwardIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
if
(
first
=
=
last
)
return
last
;
for
(
ForwardIterator
next
=
first
;
+
+
next
!
=
last
;
+
+
first
)
{
if
(
base
:
:
invoke
(
comp
base
:
:
invoke
(
proj
*
next
)
base
:
:
invoke
(
proj
*
first
)
)
)
{
return
next
;
}
}
return
last
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
is_sorted_until
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
is_sorted_until
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
ForwardIterator
Proj
>
projected
<
ForwardIterator
Proj
>
>
>
constexpr
auto
is_sorted
(
ForwardIterator
first
ForwardIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
is_sorted_until
(
first
last
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
=
=
last
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
is_sorted
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
is_sorted
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
RandomAccessIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
RandomAccessIterator
Proj
>
projected
<
RandomAccessIterator
Proj
>
>
>
constexpr
auto
nth_element
(
RandomAccessIterator
first
RandomAccessIterator
nth
RandomAccessIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
std
:
:
nth_element
(
first
nth
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
return
last
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
nth_element
(
Range
&
&
range
iterator_t
<
Range
>
nth
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
nth_element
(
ranges
:
:
begin
(
range
)
nth
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
lower_bound
(
ForwardIterator
first
ForwardIterator
last
const
T
&
value
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
identity
value_proj
;
return
std
:
:
lower_bound
(
first
last
value
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
value_proj
)
)
;
}
template
<
typename
Range
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
lower_bound
(
Range
&
&
range
const
T
&
value
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
lower_bound
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
value
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
upper_bound
(
ForwardIterator
first
ForwardIterator
last
const
T
&
value
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
identity
value_proj
;
return
std
:
:
upper_bound
(
first
last
value
internal
:
:
ProjectedBinaryPredicate
(
comp
value_proj
proj
)
)
;
}
template
<
typename
Range
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
upper_bound
(
Range
&
&
range
const
T
&
value
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
upper_bound
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
value
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
equal_range
(
ForwardIterator
first
ForwardIterator
last
const
T
&
value
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
std
:
:
make_pair
(
ranges
:
:
lower_bound
(
first
last
value
comp
proj
)
ranges
:
:
upper_bound
(
first
last
value
comp
proj
)
)
;
}
template
<
typename
Range
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
equal_range
(
Range
&
&
range
const
T
&
value
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
equal_range
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
value
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
binary_search
(
ForwardIterator
first
ForwardIterator
last
const
T
&
value
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
first
=
ranges
:
:
lower_bound
(
first
last
value
comp
proj
)
;
return
first
!
=
last
&
&
!
base
:
:
invoke
(
comp
value
base
:
:
invoke
(
proj
*
first
)
)
;
}
template
<
typename
Range
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
binary_search
(
Range
&
&
range
const
T
&
value
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
binary_search
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
value
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
is_partitioned
(
ForwardIterator
first
ForwardIterator
last
Pred
pred
Proj
proj
=
{
}
)
{
return
std
:
:
is_partitioned
(
first
last
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
)
;
}
template
<
typename
Range
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
is_partitioned
(
Range
&
&
range
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
is_partitioned
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
partition
(
ForwardIterator
first
ForwardIterator
last
Pred
pred
Proj
proj
=
{
}
)
{
return
std
:
:
partition
(
first
last
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
)
;
}
template
<
typename
Range
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
partition
(
Range
&
&
range
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
partition
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
BidirectionalIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator
>
>
constexpr
auto
stable_partition
(
BidirectionalIterator
first
BidirectionalIterator
last
Pred
pred
Proj
proj
=
{
}
)
{
return
std
:
:
stable_partition
(
first
last
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
)
;
}
template
<
typename
Range
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
stable_partition
(
Range
&
&
range
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
stable_partition
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator
typename
OutputIterator1
typename
OutputIterator2
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator1
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator2
>
>
constexpr
auto
partition_copy
(
InputIterator
first
InputIterator
last
OutputIterator1
out_true
OutputIterator2
out_false
Pred
pred
Proj
proj
=
{
}
)
{
return
std
:
:
partition_copy
(
first
last
out_true
out_false
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
)
;
}
template
<
typename
Range
typename
OutputIterator1
typename
OutputIterator2
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator1
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator2
>
>
constexpr
auto
partition_copy
(
Range
&
&
range
OutputIterator1
out_true
OutputIterator2
out_false
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
partition_copy
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
out_true
out_false
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
>
constexpr
auto
partition_point
(
ForwardIterator
first
ForwardIterator
last
Pred
pred
Proj
proj
=
{
}
)
{
return
std
:
:
partition_point
(
first
last
internal
:
:
ProjectedUnaryPredicate
(
pred
proj
)
)
;
}
template
<
typename
Range
typename
Pred
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
partition_point
(
Range
&
&
range
Pred
pred
Proj
proj
=
{
}
)
{
return
ranges
:
:
partition_point
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
pred
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator1
typename
InputIterator2
typename
OutputIterator
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator1
>
typename
=
internal
:
:
iterator_category_t
<
InputIterator2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator1
Proj1
>
projected
<
InputIterator2
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator2
Proj2
>
projected
<
InputIterator1
Proj1
>
>
>
constexpr
auto
merge
(
InputIterator1
first1
InputIterator1
last1
InputIterator2
first2
InputIterator2
last2
OutputIterator
result
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
std
:
:
merge
(
first1
last1
first2
last2
result
internal
:
:
PermutedProjectedBinaryPredicate
(
comp
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
OutputIterator
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range2
>
Proj2
>
projected
<
iterator_t
<
Range1
>
Proj1
>
>
>
constexpr
auto
merge
(
Range1
&
&
range1
Range2
&
&
range2
OutputIterator
result
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
merge
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
result
std
:
:
move
(
comp
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
BidirectionalIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator
>
>
constexpr
auto
inplace_merge
(
BidirectionalIterator
first
BidirectionalIterator
middle
BidirectionalIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
std
:
:
inplace_merge
(
first
middle
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
return
last
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
inplace_merge
(
Range
&
&
range
iterator_t
<
Range
>
middle
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
inplace_merge
(
ranges
:
:
begin
(
range
)
middle
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
InputIterator1
typename
InputIterator2
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator1
>
typename
=
internal
:
:
iterator_category_t
<
InputIterator2
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator1
Proj1
>
projected
<
InputIterator2
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator2
Proj2
>
projected
<
InputIterator1
Proj1
>
>
>
constexpr
auto
includes
(
InputIterator1
first1
InputIterator1
last1
InputIterator2
first2
InputIterator2
last2
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
DCHECK
(
ranges
:
:
is_sorted
(
first1
last1
comp
proj1
)
)
;
DCHECK
(
ranges
:
:
is_sorted
(
first2
last2
comp
proj2
)
)
;
return
std
:
:
includes
(
first1
last1
first2
last2
internal
:
:
PermutedProjectedBinaryPredicate
(
comp
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range2
>
Proj2
>
projected
<
iterator_t
<
Range1
>
Proj1
>
>
>
constexpr
auto
includes
(
Range1
&
&
range1
Range2
&
&
range2
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
includes
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
InputIterator1
typename
InputIterator2
typename
OutputIterator
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator1
>
typename
=
internal
:
:
iterator_category_t
<
InputIterator2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator1
Proj1
>
projected
<
InputIterator2
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator2
Proj2
>
projected
<
InputIterator1
Proj1
>
>
>
constexpr
auto
set_union
(
InputIterator1
first1
InputIterator1
last1
InputIterator2
first2
InputIterator2
last2
OutputIterator
result
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
std
:
:
set_union
(
first1
last1
first2
last2
result
internal
:
:
PermutedProjectedBinaryPredicate
(
comp
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
OutputIterator
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range2
>
Proj2
>
projected
<
iterator_t
<
Range1
>
Proj1
>
>
>
constexpr
auto
set_union
(
Range1
&
&
range1
Range2
&
&
range2
OutputIterator
result
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
set_union
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
result
std
:
:
move
(
comp
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
InputIterator1
typename
InputIterator2
typename
OutputIterator
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator1
>
typename
=
internal
:
:
iterator_category_t
<
InputIterator2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator1
Proj1
>
projected
<
InputIterator2
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator2
Proj2
>
projected
<
InputIterator1
Proj1
>
>
>
constexpr
auto
set_intersection
(
InputIterator1
first1
InputIterator1
last1
InputIterator2
first2
InputIterator2
last2
OutputIterator
result
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
std
:
:
set_intersection
(
first1
last1
first2
last2
result
internal
:
:
PermutedProjectedBinaryPredicate
(
comp
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
OutputIterator
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range2
>
Proj2
>
projected
<
iterator_t
<
Range1
>
Proj1
>
>
>
constexpr
auto
set_intersection
(
Range1
&
&
range1
Range2
&
&
range2
OutputIterator
result
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
set_intersection
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
result
std
:
:
move
(
comp
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
InputIterator1
typename
InputIterator2
typename
OutputIterator
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator1
>
typename
=
internal
:
:
iterator_category_t
<
InputIterator2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator1
Proj1
>
projected
<
InputIterator2
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator2
Proj2
>
projected
<
InputIterator1
Proj1
>
>
>
constexpr
auto
set_difference
(
InputIterator1
first1
InputIterator1
last1
InputIterator2
first2
InputIterator2
last2
OutputIterator
result
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
std
:
:
set_difference
(
first1
last1
first2
last2
result
internal
:
:
PermutedProjectedBinaryPredicate
(
comp
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
OutputIterator
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range2
>
Proj2
>
projected
<
iterator_t
<
Range1
>
Proj1
>
>
>
constexpr
auto
set_difference
(
Range1
&
&
range1
Range2
&
&
range2
OutputIterator
result
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
set_difference
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
result
std
:
:
move
(
comp
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
InputIterator1
typename
InputIterator2
typename
OutputIterator
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
InputIterator1
>
typename
=
internal
:
:
iterator_category_t
<
InputIterator2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator1
Proj1
>
projected
<
InputIterator2
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
InputIterator2
Proj2
>
projected
<
InputIterator1
Proj1
>
>
>
constexpr
auto
set_symmetric_difference
(
InputIterator1
first1
InputIterator1
last1
InputIterator2
first2
InputIterator2
last2
OutputIterator
result
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
std
:
:
set_symmetric_difference
(
first1
last1
first2
last2
result
internal
:
:
PermutedProjectedBinaryPredicate
(
comp
proj1
proj2
)
)
;
}
template
<
typename
Range1
typename
Range2
typename
OutputIterator
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
internal
:
:
iterator_category_t
<
OutputIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range2
>
Proj2
>
projected
<
iterator_t
<
Range1
>
Proj1
>
>
>
constexpr
auto
set_symmetric_difference
(
Range1
&
&
range1
Range2
&
&
range2
OutputIterator
result
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
set_symmetric_difference
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
result
std
:
:
move
(
comp
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
RandomAccessIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
RandomAccessIterator
Proj
>
projected
<
RandomAccessIterator
Proj
>
>
>
constexpr
auto
push_heap
(
RandomAccessIterator
first
RandomAccessIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
std
:
:
push_heap
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
return
last
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
push_heap
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
push_heap
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
RandomAccessIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
RandomAccessIterator
Proj
>
projected
<
RandomAccessIterator
Proj
>
>
>
constexpr
auto
pop_heap
(
RandomAccessIterator
first
RandomAccessIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
std
:
:
pop_heap
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
return
last
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
pop_heap
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
pop_heap
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
RandomAccessIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
RandomAccessIterator
Proj
>
projected
<
RandomAccessIterator
Proj
>
>
>
constexpr
auto
make_heap
(
RandomAccessIterator
first
RandomAccessIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
std
:
:
make_heap
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
return
last
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
make_heap
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
make_heap
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
RandomAccessIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
RandomAccessIterator
Proj
>
projected
<
RandomAccessIterator
Proj
>
>
>
constexpr
auto
sort_heap
(
RandomAccessIterator
first
RandomAccessIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
std
:
:
sort_heap
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
return
last
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
sort_heap
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
sort_heap
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
RandomAccessIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
RandomAccessIterator
Proj
>
projected
<
RandomAccessIterator
Proj
>
>
>
constexpr
auto
is_heap
(
RandomAccessIterator
first
RandomAccessIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
std
:
:
is_heap
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
is_heap
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
is_heap
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
RandomAccessIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
RandomAccessIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
RandomAccessIterator
Proj
>
projected
<
RandomAccessIterator
Proj
>
>
>
constexpr
auto
is_heap_until
(
RandomAccessIterator
first
RandomAccessIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
std
:
:
is_heap_until
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
is_heap_until
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
is_heap_until
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
>
constexpr
const
T
&
min
(
const
T
&
a
const
T
&
b
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
base
:
:
invoke
(
comp
base
:
:
invoke
(
proj
b
)
base
:
:
invoke
(
proj
a
)
)
?
b
:
a
;
}
template
<
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
>
constexpr
T
min
(
std
:
:
initializer_list
<
T
>
ilist
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
*
std
:
:
min_element
(
ilist
.
begin
(
)
ilist
.
end
(
)
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
min
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
*
std
:
:
min_element
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
>
constexpr
const
T
&
max
(
const
T
&
a
const
T
&
b
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
base
:
:
invoke
(
comp
base
:
:
invoke
(
proj
a
)
base
:
:
invoke
(
proj
b
)
)
?
b
:
a
;
}
template
<
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
>
constexpr
T
max
(
std
:
:
initializer_list
<
T
>
ilist
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
*
std
:
:
max_element
(
ilist
.
begin
(
)
ilist
.
end
(
)
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
max
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
*
std
:
:
max_element
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
>
constexpr
auto
minmax
(
const
T
&
a
const
T
&
b
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
std
:
:
minmax
(
a
b
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
>
constexpr
auto
minmax
(
std
:
:
initializer_list
<
T
>
ilist
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
auto
it
=
std
:
:
minmax_element
(
ranges
:
:
begin
(
ilist
)
ranges
:
:
end
(
ilist
)
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
return
std
:
:
pair
<
T
T
>
{
*
it
.
first
*
it
.
second
}
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
>
constexpr
auto
minmax
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
using
T
=
range_value_t
<
Range
>
;
auto
it
=
std
:
:
minmax_element
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
return
std
:
:
pair
<
T
T
>
{
*
it
.
first
*
it
.
second
}
;
}
template
<
typename
ForwardIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
ForwardIterator
Proj
>
projected
<
ForwardIterator
Proj
>
>
>
constexpr
auto
min_element
(
ForwardIterator
first
ForwardIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
std
:
:
min_element
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
min_element
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
min_element
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
ForwardIterator
Proj
>
projected
<
ForwardIterator
Proj
>
>
>
constexpr
auto
max_element
(
ForwardIterator
first
ForwardIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
std
:
:
max_element
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
max_element
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
max_element
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
ForwardIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
ForwardIterator
Proj
>
projected
<
ForwardIterator
Proj
>
>
>
constexpr
auto
minmax_element
(
ForwardIterator
first
ForwardIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
std
:
:
minmax_element
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
minmax_element
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
minmax_element
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
T
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
>
constexpr
const
T
&
clamp
(
const
T
&
v
const
T
&
lo
const
T
&
hi
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
auto
&
&
projected_v
=
base
:
:
invoke
(
proj
v
)
;
if
(
base
:
:
invoke
(
comp
projected_v
base
:
:
invoke
(
proj
lo
)
)
)
return
lo
;
return
base
:
:
invoke
(
comp
base
:
:
invoke
(
proj
hi
)
projected_v
)
?
hi
:
v
;
}
template
<
typename
ForwardIterator1
typename
ForwardIterator2
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator1
>
typename
=
internal
:
:
iterator_category_t
<
ForwardIterator2
>
typename
=
indirect_result_t
<
Comp
&
projected
<
ForwardIterator1
Proj1
>
projected
<
ForwardIterator2
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
ForwardIterator2
Proj2
>
projected
<
ForwardIterator1
Proj1
>
>
>
constexpr
bool
lexicographical_compare
(
ForwardIterator1
first1
ForwardIterator1
last1
ForwardIterator2
first2
ForwardIterator2
last2
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
for
(
;
first1
!
=
last1
&
&
first2
!
=
last2
;
+
+
first1
+
+
first2
)
{
auto
&
&
projected_first1
=
base
:
:
invoke
(
proj1
*
first1
)
;
auto
&
&
projected_first2
=
base
:
:
invoke
(
proj2
*
first2
)
;
if
(
base
:
:
invoke
(
comp
projected_first1
projected_first2
)
)
return
true
;
if
(
base
:
:
invoke
(
comp
projected_first2
projected_first1
)
)
return
false
;
}
return
first2
!
=
last2
;
}
template
<
typename
Range1
typename
Range2
typename
Comp
=
ranges
:
:
less
typename
Proj1
=
identity
typename
Proj2
=
identity
typename
=
internal
:
:
range_category_t
<
Range1
>
typename
=
internal
:
:
range_category_t
<
Range2
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range1
>
Proj1
>
projected
<
iterator_t
<
Range2
>
Proj2
>
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range2
>
Proj2
>
projected
<
iterator_t
<
Range1
>
Proj1
>
>
>
constexpr
bool
lexicographical_compare
(
Range1
&
&
range1
Range2
&
&
range2
Comp
comp
=
{
}
Proj1
proj1
=
{
}
Proj2
proj2
=
{
}
)
{
return
ranges
:
:
lexicographical_compare
(
ranges
:
:
begin
(
range1
)
ranges
:
:
end
(
range1
)
ranges
:
:
begin
(
range2
)
ranges
:
:
end
(
range2
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj1
)
std
:
:
move
(
proj2
)
)
;
}
template
<
typename
BidirectionalIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
BidirectionalIterator
Proj
>
projected
<
BidirectionalIterator
Proj
>
>
>
constexpr
auto
next_permutation
(
BidirectionalIterator
first
BidirectionalIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
std
:
:
next_permutation
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
next_permutation
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
next_permutation
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
template
<
typename
BidirectionalIterator
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
iterator_category_t
<
BidirectionalIterator
>
typename
=
indirect_result_t
<
Comp
&
projected
<
BidirectionalIterator
Proj
>
projected
<
BidirectionalIterator
Proj
>
>
>
constexpr
auto
prev_permutation
(
BidirectionalIterator
first
BidirectionalIterator
last
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
std
:
:
prev_permutation
(
first
last
internal
:
:
ProjectedBinaryPredicate
(
comp
proj
proj
)
)
;
}
template
<
typename
Range
typename
Comp
=
ranges
:
:
less
typename
Proj
=
identity
typename
=
internal
:
:
range_category_t
<
Range
>
typename
=
indirect_result_t
<
Comp
&
projected
<
iterator_t
<
Range
>
Proj
>
projected
<
iterator_t
<
Range
>
Proj
>
>
>
constexpr
auto
prev_permutation
(
Range
&
&
range
Comp
comp
=
{
}
Proj
proj
=
{
}
)
{
return
ranges
:
:
prev_permutation
(
ranges
:
:
begin
(
range
)
ranges
:
:
end
(
range
)
std
:
:
move
(
comp
)
std
:
:
move
(
proj
)
)
;
}
}
}
#
endif
