#
include
"
base
/
time
/
time
.
h
"
#
import
<
Foundation
/
Foundation
.
h
>
#
include
<
mach
/
mach
.
h
>
#
include
<
mach
/
mach_time
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
time
.
h
>
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
mac
/
mach_logging
.
h
"
#
include
"
base
/
mac
/
scoped_cftyperef
.
h
"
#
include
"
base
/
mac
/
scoped_mach_port
.
h
"
#
include
"
base
/
numerics
/
safe_conversions
.
h
"
#
include
"
base
/
time
/
time_override
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
!
BUILDFLAG
(
ENABLE_MACH_ABSOLUTE_TIME_TICKS
)
#
include
<
errno
.
h
>
#
include
<
time
.
h
>
#
include
"
base
/
ios
/
ios_util
.
h
"
#
endif
#
if
!
defined
(
__has_feature
)
|
|
!
__has_feature
(
objc_arc
)
#
error
"
This
file
requires
ARC
support
.
"
#
endif
namespace
{
#
if
BUILDFLAG
(
ENABLE_MACH_ABSOLUTE_TIME_TICKS
)
mach_timebase_info_data_t
*
MachTimebaseInfo
(
)
{
static
mach_timebase_info_data_t
timebase_info
=
[
]
(
)
{
mach_timebase_info_data_t
info
;
kern_return_t
kr
=
mach_timebase_info
(
&
info
)
;
MACH_DCHECK
(
kr
=
=
KERN_SUCCESS
kr
)
<
<
"
mach_timebase_info
"
;
DCHECK
(
info
.
numer
)
;
DCHECK
(
info
.
denom
)
;
return
info
;
}
(
)
;
return
&
timebase_info
;
}
int64_t
MachTimeToMicroseconds
(
uint64_t
mach_time
)
{
mach_timebase_info_data_t
*
timebase_info
=
MachTimebaseInfo
(
)
;
if
(
timebase_info
-
>
numer
=
=
timebase_info
-
>
denom
)
{
return
static_cast
<
int64_t
>
(
mach_time
/
base
:
:
Time
:
:
kNanosecondsPerMicrosecond
)
;
}
uint64_t
microseconds
=
0
;
const
uint64_t
divisor
=
timebase_info
-
>
denom
*
base
:
:
Time
:
:
kNanosecondsPerMicrosecond
;
microseconds
=
mach_time
/
divisor
;
const
uint64_t
mach_time_remainder
=
mach_time
%
divisor
;
CHECK
(
!
__builtin_umulll_overflow
(
microseconds
timebase_info
-
>
numer
&
microseconds
)
)
;
uint64_t
least_significant_microseconds
=
(
mach_time_remainder
*
timebase_info
-
>
numer
)
/
divisor
;
CHECK
(
!
__builtin_uaddll_overflow
(
microseconds
least_significant_microseconds
&
microseconds
)
)
;
return
base
:
:
checked_cast
<
int64_t
>
(
microseconds
)
;
}
#
endif
int64_t
ComputeCurrentTicks
(
)
{
#
if
!
BUILDFLAG
(
ENABLE_MACH_ABSOLUTE_TIME_TICKS
)
struct
timespec
tp
;
int
res
=
clock_gettime
(
CLOCK_MONOTONIC
&
tp
)
;
DCHECK_EQ
(
res
0
)
<
<
"
Failed
clock_gettime
errno
:
"
<
<
errno
;
return
(
int64_t
)
tp
.
tv_sec
*
1000000
+
tp
.
tv_nsec
/
1000
;
#
else
return
MachTimeToMicroseconds
(
mach_absolute_time
(
)
)
;
#
endif
}
int64_t
ComputeThreadTicks
(
)
{
mach_port_t
thread_port
=
pthread_mach_thread_np
(
pthread_self
(
)
)
;
if
(
thread_port
=
=
MACH_PORT_NULL
)
{
DLOG
(
ERROR
)
<
<
"
Failed
to
get
pthread_mach_thread_np
(
)
"
;
return
0
;
}
mach_msg_type_number_t
thread_info_count
=
THREAD_BASIC_INFO_COUNT
;
thread_basic_info_data_t
thread_info_data
;
kern_return_t
kr
=
thread_info
(
thread_port
THREAD_BASIC_INFO
reinterpret_cast
<
thread_info_t
>
(
&
thread_info_data
)
&
thread_info_count
)
;
MACH_DCHECK
(
kr
=
=
KERN_SUCCESS
kr
)
<
<
"
thread_info
"
;
base
:
:
CheckedNumeric
<
int64_t
>
absolute_micros
(
thread_info_data
.
user_time
.
seconds
+
thread_info_data
.
system_time
.
seconds
)
;
absolute_micros
*
=
base
:
:
Time
:
:
kMicrosecondsPerSecond
;
absolute_micros
+
=
(
thread_info_data
.
user_time
.
microseconds
+
thread_info_data
.
system_time
.
microseconds
)
;
return
absolute_micros
.
ValueOrDie
(
)
;
}
}
namespace
base
{
namespace
subtle
{
Time
TimeNowIgnoringOverride
(
)
{
return
Time
:
:
FromCFAbsoluteTime
(
CFAbsoluteTimeGetCurrent
(
)
)
;
}
Time
TimeNowFromSystemTimeIgnoringOverride
(
)
{
return
TimeNowIgnoringOverride
(
)
;
}
}
Time
Time
:
:
FromCFAbsoluteTime
(
CFAbsoluteTime
t
)
{
static_assert
(
std
:
:
numeric_limits
<
CFAbsoluteTime
>
:
:
has_infinity
"
CFAbsoluteTime
must
have
an
infinity
value
"
)
;
if
(
t
=
=
0
)
return
Time
(
)
;
return
(
t
=
=
std
:
:
numeric_limits
<
CFAbsoluteTime
>
:
:
infinity
(
)
)
?
Max
(
)
:
(
UnixEpoch
(
)
+
Seconds
(
double
{
t
+
kCFAbsoluteTimeIntervalSince1970
}
)
)
;
}
CFAbsoluteTime
Time
:
:
ToCFAbsoluteTime
(
)
const
{
static_assert
(
std
:
:
numeric_limits
<
CFAbsoluteTime
>
:
:
has_infinity
"
CFAbsoluteTime
must
have
an
infinity
value
"
)
;
if
(
is_null
(
)
)
return
0
;
return
is_max
(
)
?
std
:
:
numeric_limits
<
CFAbsoluteTime
>
:
:
infinity
(
)
:
(
CFAbsoluteTime
{
(
*
this
-
UnixEpoch
(
)
)
.
InSecondsF
(
)
}
-
kCFAbsoluteTimeIntervalSince1970
)
;
}
Time
Time
:
:
FromNSDate
(
NSDate
*
date
)
{
DCHECK
(
date
)
;
return
FromCFAbsoluteTime
(
date
.
timeIntervalSinceReferenceDate
)
;
}
NSDate
*
Time
:
:
ToNSDate
(
)
const
{
return
[
NSDate
dateWithTimeIntervalSinceReferenceDate
:
ToCFAbsoluteTime
(
)
]
;
}
#
if
BUILDFLAG
(
ENABLE_MACH_ABSOLUTE_TIME_TICKS
)
TimeDelta
TimeDelta
:
:
FromMachTime
(
uint64_t
mach_time
)
{
return
Microseconds
(
MachTimeToMicroseconds
(
mach_time
)
)
;
}
#
endif
namespace
subtle
{
TimeTicks
TimeTicksNowIgnoringOverride
(
)
{
return
TimeTicks
(
)
+
Microseconds
(
ComputeCurrentTicks
(
)
)
;
}
}
bool
TimeTicks
:
:
IsHighResolution
(
)
{
return
true
;
}
bool
TimeTicks
:
:
IsConsistentAcrossProcesses
(
)
{
return
true
;
}
#
if
BUILDFLAG
(
ENABLE_MACH_ABSOLUTE_TIME_TICKS
)
TimeTicks
TimeTicks
:
:
FromMachAbsoluteTime
(
uint64_t
mach_absolute_time
)
{
return
TimeTicks
(
MachTimeToMicroseconds
(
mach_absolute_time
)
)
;
}
mach_timebase_info_data_t
TimeTicks
:
:
SetMachTimebaseInfoForTesting
(
mach_timebase_info_data_t
timebase
)
{
mach_timebase_info_data_t
orig_timebase
=
*
MachTimebaseInfo
(
)
;
*
MachTimebaseInfo
(
)
=
timebase
;
return
orig_timebase
;
}
#
endif
TimeTicks
:
:
Clock
TimeTicks
:
:
GetClock
(
)
{
#
if
!
BUILDFLAG
(
ENABLE_MACH_ABSOLUTE_TIME_TICKS
)
return
Clock
:
:
IOS_CF_ABSOLUTE_TIME_MINUS_KERN_BOOTTIME
;
#
else
return
Clock
:
:
MAC_MACH_ABSOLUTE_TIME
;
#
endif
}
namespace
subtle
{
ThreadTicks
ThreadTicksNowIgnoringOverride
(
)
{
return
ThreadTicks
(
)
+
Microseconds
(
ComputeThreadTicks
(
)
)
;
}
}
}
