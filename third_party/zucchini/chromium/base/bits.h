#
ifndef
BASE_BITS_H_
#
define
BASE_BITS_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
"
base
/
check
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
namespace
bits
{
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
std
:
:
is_integral
<
T
>
:
:
value
>
>
constexpr
bool
IsPowerOfTwo
(
T
value
)
{
return
value
>
0
&
&
(
value
&
(
value
-
1
)
)
=
=
0
;
}
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
>
>
constexpr
T
AlignDown
(
T
size
T
alignment
)
{
DCHECK
(
IsPowerOfTwo
(
alignment
)
)
;
return
size
&
~
(
alignment
-
1
)
;
}
template
<
typename
T
typename
=
typename
std
:
:
enable_if
<
sizeof
(
T
)
=
=
1
>
:
:
type
>
inline
T
*
AlignDown
(
T
*
ptr
uintptr_t
alignment
)
{
return
reinterpret_cast
<
T
*
>
(
AlignDown
(
reinterpret_cast
<
uintptr_t
>
(
ptr
)
alignment
)
)
;
}
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
>
>
constexpr
T
AlignUp
(
T
size
T
alignment
)
{
DCHECK
(
IsPowerOfTwo
(
alignment
)
)
;
return
(
size
+
alignment
-
1
)
&
~
(
alignment
-
1
)
;
}
template
<
typename
T
typename
=
typename
std
:
:
enable_if
<
sizeof
(
T
)
=
=
1
>
:
:
type
>
inline
T
*
AlignUp
(
T
*
ptr
uintptr_t
alignment
)
{
return
reinterpret_cast
<
T
*
>
(
AlignUp
(
reinterpret_cast
<
uintptr_t
>
(
ptr
)
alignment
)
)
;
}
template
<
typename
T
int
bits
=
sizeof
(
T
)
*
8
>
ALWAYS_INLINE
constexpr
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
&
&
sizeof
(
T
)
<
=
8
int
>
:
:
type
CountLeadingZeroBits
(
T
value
)
{
static_assert
(
bits
>
0
"
invalid
instantiation
"
)
;
return
LIKELY
(
value
)
?
bits
=
=
64
?
__builtin_clzll
(
static_cast
<
uint64_t
>
(
value
)
)
:
__builtin_clz
(
static_cast
<
uint32_t
>
(
value
)
)
-
(
32
-
bits
)
:
bits
;
}
template
<
typename
T
int
bits
=
sizeof
(
T
)
*
8
>
ALWAYS_INLINE
constexpr
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
&
&
sizeof
(
T
)
<
=
8
int
>
:
:
type
CountTrailingZeroBits
(
T
value
)
{
return
LIKELY
(
value
)
?
bits
=
=
64
?
__builtin_ctzll
(
static_cast
<
uint64_t
>
(
value
)
)
:
__builtin_ctz
(
static_cast
<
uint32_t
>
(
value
)
)
:
bits
;
}
constexpr
int
Log2Floor
(
uint32_t
n
)
{
return
31
-
CountLeadingZeroBits
(
n
)
;
}
constexpr
int
Log2Ceiling
(
uint32_t
n
)
{
return
(
n
?
32
:
-
1
)
-
CountLeadingZeroBits
(
n
-
1
)
;
}
template
<
typename
T
>
constexpr
T
LeftmostBit
(
)
{
static_assert
(
std
:
:
is_integral
<
T
>
:
:
value
"
This
function
can
only
be
used
with
integral
types
.
"
)
;
T
one
(
1u
)
;
return
one
<
<
(
8
*
sizeof
(
T
)
-
1
)
;
}
}
}
#
endif
