#
ifndef
BASE_FUNCTIONAL_FUNCTION_REF_H_
#
define
BASE_FUNCTIONAL_FUNCTION_REF_H_
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
functional
/
bind_internal
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
base
/
attributes
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
functional
/
function_ref
.
h
"
namespace
base
{
template
<
typename
Signature
>
class
FunctionRef
;
template
<
typename
R
typename
.
.
.
Args
>
class
FunctionRef
<
R
(
Args
.
.
.
)
>
{
private
:
template
<
typename
Functor
typename
FunctorReturnType
=
typename
internal
:
:
BindTypeHelper
<
Functor
>
:
:
ReturnType
typename
FunctorArgsAsTypeList
=
typename
internal
:
:
BindTypeHelper
<
Functor
>
:
:
RunParamsList
>
using
EnableIfCompatible
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
FunctorReturnType
R
>
&
&
std
:
:
is_same_v
<
FunctorArgsAsTypeList
internal
:
:
TypeList
<
Args
.
.
.
>
>
>
;
public
:
template
<
typename
Functor
typename
=
EnableIfCompatible
<
Functor
>
>
FunctionRef
(
const
Functor
&
functor
ABSL_ATTRIBUTE_LIFETIME_BOUND
)
:
wrapped_func_ref_
(
functor
)
{
}
FunctionRef
(
)
=
delete
;
FunctionRef
(
const
FunctionRef
&
)
=
default
;
FunctionRef
&
operator
=
(
const
FunctionRef
&
)
=
delete
;
R
operator
(
)
(
Args
.
.
.
args
)
const
{
return
wrapped_func_ref_
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
absl
:
:
FunctionRef
<
R
(
Args
.
.
.
)
>
ToAbsl
(
)
const
{
return
wrapped_func_ref_
;
}
template
<
typename
Signature
>
operator
absl
:
:
FunctionRef
<
Signature
>
(
)
=
delete
;
private
:
absl
:
:
FunctionRef
<
R
(
Args
.
.
.
)
>
wrapped_func_ref_
;
}
;
}
#
endif
