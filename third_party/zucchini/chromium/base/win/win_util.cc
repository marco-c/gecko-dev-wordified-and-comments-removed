#
include
"
base
/
win
/
win_util
.
h
"
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
<
aclapi
.
h
>
#
include
<
cfgmgr32
.
h
>
#
include
<
initguid
.
h
>
#
include
<
lm
.
h
>
#
include
<
powrprof
.
h
>
#
include
<
shobjidl
.
h
>
#
include
<
inspectable
.
h
>
#
include
<
mdmregistration
.
h
>
#
include
<
objbase
.
h
>
#
include
<
propkey
.
h
>
#
include
<
psapi
.
h
>
#
include
<
roapi
.
h
>
#
include
<
sddl
.
h
>
#
include
<
setupapi
.
h
>
#
include
<
shellscalingapi
.
h
>
#
include
<
signal
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
strsafe
.
h
>
#
include
<
tchar
.
h
>
#
include
<
tpcshrd
.
h
>
#
include
<
uiviewsettingsinterop
.
h
>
#
include
<
windows
.
ui
.
viewmanagement
.
h
>
#
include
<
winstring
.
h
>
#
include
<
wrl
/
client
.
h
>
#
include
<
wrl
/
wrappers
/
corewrappers
.
h
>
#
include
<
limits
>
#
include
<
memory
>
#
include
<
utility
>
#
include
"
base
/
base_switches
.
h
"
#
include
"
base
/
command_line
.
h
"
#
include
"
base
/
files
/
file_path
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
metrics
/
histogram_functions
.
h
"
#
include
"
base
/
notreached
.
h
"
#
include
"
base
/
scoped_native_library
.
h
"
#
include
"
base
/
strings
/
string_util
.
h
"
#
include
"
base
/
strings
/
string_util_win
.
h
"
#
include
"
base
/
strings
/
utf_string_conversions
.
h
"
#
include
"
base
/
threading
/
scoped_thread_priority
.
h
"
#
include
"
base
/
threading
/
thread_restrictions
.
h
"
#
include
"
base
/
timer
/
elapsed_timer
.
h
"
#
include
"
base
/
win
/
access_token
.
h
"
#
include
"
base
/
win
/
core_winrt_util
.
h
"
#
include
"
base
/
win
/
propvarutil
.
h
"
#
include
"
base
/
win
/
registry
.
h
"
#
include
"
base
/
win
/
scoped_co_mem
.
h
"
#
include
"
base
/
win
/
scoped_handle
.
h
"
#
include
"
base
/
win
/
scoped_hstring
.
h
"
#
include
"
base
/
win
/
scoped_propvariant
.
h
"
#
include
"
base
/
win
/
shlwapi
.
h
"
#
include
"
base
/
win
/
static_constants
.
h
"
#
include
"
base
/
win
/
windows_version
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
types
/
optional
.
h
"
#
else
#
include
<
processthreadsapi
.
h
>
#
endif
namespace
base
{
namespace
win
{
#
if
!
defined
(
MOZ_ZUCCHINI
)
namespace
{
bool
SetPropVariantValueForPropertyStore
(
IPropertyStore
*
property_store
const
PROPERTYKEY
&
property_key
const
ScopedPropVariant
&
property_value
)
{
DCHECK
(
property_store
)
;
HRESULT
result
=
property_store
-
>
SetValue
(
property_key
property_value
.
get
(
)
)
;
if
(
result
=
=
S_OK
)
result
=
property_store
-
>
Commit
(
)
;
if
(
SUCCEEDED
(
result
)
)
return
true
;
#
if
DCHECK_IS_ON
(
)
if
(
HRESULT_FACILITY
(
result
)
=
=
FACILITY_WIN32
)
:
:
SetLastError
(
HRESULT_CODE
(
result
)
)
;
DPLOG
(
ERROR
)
<
<
"
Failed
to
set
property
with
GUID
"
<
<
WStringFromGUID
(
property_key
.
fmtid
)
<
<
"
PID
"
<
<
property_key
.
pid
;
#
endif
return
false
;
}
void
__cdecl
ForceCrashOnSigAbort
(
int
)
{
*
(
(
volatile
int
*
)
nullptr
)
=
0x1337
;
}
POWER_PLATFORM_ROLE
GetPlatformRole
(
)
{
return
PowerDeterminePlatformRoleEx
(
POWER_PLATFORM_ROLE_V2
)
;
}
bool
EnablePerMonitorV2
(
)
{
if
(
!
IsUser32AndGdi32Available
(
)
)
return
false
;
static
const
auto
set_process_dpi_awareness_context_func
=
reinterpret_cast
<
decltype
(
&
:
:
SetProcessDpiAwarenessContext
)
>
(
GetUser32FunctionPointer
(
"
SetProcessDpiAwarenessContext
"
)
)
;
if
(
set_process_dpi_awareness_context_func
)
{
return
set_process_dpi_awareness_context_func
(
DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2
)
;
}
DCHECK_LT
(
GetVersion
(
)
Version
:
:
WIN10_RS2
)
<
<
"
SetProcessDpiAwarenessContext
should
be
available
on
all
platforms
"
"
>
=
Windows
10
Redstone
2
"
;
return
false
;
}
bool
*
GetDomainEnrollmentStateStorage
(
)
{
static
bool
state
=
IsOS
(
OS_DOMAINMEMBER
)
;
return
&
state
;
}
bool
*
GetRegisteredWithManagementStateStorage
(
)
{
static
bool
state
=
[
]
(
)
{
SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY
(
)
;
ScopedNativeLibrary
library
(
FilePath
(
FILE_PATH_LITERAL
(
"
MDMRegistration
.
dll
"
)
)
)
;
if
(
!
library
.
is_valid
(
)
)
return
false
;
using
IsDeviceRegisteredWithManagementFunction
=
decltype
(
&
:
:
IsDeviceRegisteredWithManagement
)
;
IsDeviceRegisteredWithManagementFunction
is_device_registered_with_management_function
=
reinterpret_cast
<
IsDeviceRegisteredWithManagementFunction
>
(
library
.
GetFunctionPointer
(
"
IsDeviceRegisteredWithManagement
"
)
)
;
if
(
!
is_device_registered_with_management_function
)
return
false
;
BOOL
is_managed
=
FALSE
;
HRESULT
hr
=
is_device_registered_with_management_function
(
&
is_managed
0
nullptr
)
;
return
SUCCEEDED
(
hr
)
&
&
is_managed
;
}
(
)
;
return
&
state
;
}
bool
*
GetAzureADJoinStateStorage
(
)
{
static
bool
state
=
[
]
(
)
{
base
:
:
ElapsedTimer
timer
;
SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY
(
)
;
ScopedNativeLibrary
netapi32
(
base
:
:
LoadSystemLibrary
(
FILE_PATH_LITERAL
(
"
netapi32
.
dll
"
)
)
)
;
if
(
!
netapi32
.
is_valid
(
)
)
return
false
;
const
auto
net_get_aad_join_information_function
=
reinterpret_cast
<
decltype
(
&
:
:
NetGetAadJoinInformation
)
>
(
netapi32
.
GetFunctionPointer
(
"
NetGetAadJoinInformation
"
)
)
;
if
(
!
net_get_aad_join_information_function
)
return
false
;
const
auto
net_free_aad_join_information_function
=
reinterpret_cast
<
decltype
(
&
:
:
NetFreeAadJoinInformation
)
>
(
netapi32
.
GetFunctionPointer
(
"
NetFreeAadJoinInformation
"
)
)
;
DPCHECK
(
net_free_aad_join_information_function
)
;
DSREG_JOIN_INFO
*
join_info
=
nullptr
;
HRESULT
hr
=
net_get_aad_join_information_function
(
nullptr
&
join_info
)
;
const
bool
is_aad_joined
=
SUCCEEDED
(
hr
)
&
&
join_info
;
if
(
join_info
)
{
net_free_aad_join_information_function
(
join_info
)
;
}
base
:
:
UmaHistogramTimes
(
"
EnterpriseCheck
.
AzureADJoinStatusCheckTime
"
timer
.
Elapsed
(
)
)
;
return
is_aad_joined
;
}
(
)
;
return
&
state
;
}
NativeLibrary
PinUser32Internal
(
NativeLibraryLoadError
*
error
)
{
static
NativeLibraryLoadError
load_error
;
static
const
NativeLibrary
user32_module
=
PinSystemLibrary
(
FILE_PATH_LITERAL
(
"
user32
.
dll
"
)
&
load_error
)
;
if
(
!
user32_module
&
&
error
)
error
-
>
code
=
load_error
.
code
;
return
user32_module
;
}
}
bool
IsWindows10OrGreaterTabletMode
(
HWND
hwnd
)
{
if
(
GetVersion
(
)
>
=
Version
:
:
WIN11
)
{
constexpr
int
kKeyboardPresent
=
1
;
base
:
:
win
:
:
RegKey
registry_key
(
HKEY_LOCAL_MACHINE
L
"
System
\
\
CurrentControlSet
\
\
Control
\
\
PriorityControl
"
KEY_READ
)
;
DWORD
slate_mode
=
0
;
bool
value_exists
=
registry_key
.
ReadValueDW
(
L
"
ConvertibleSlateMode
"
&
slate_mode
)
=
=
ERROR_SUCCESS
;
return
!
(
value_exists
&
&
slate_mode
=
=
kKeyboardPresent
)
&
&
IsDeviceUsedAsATablet
(
nullptr
)
;
}
ScopedHString
view_settings_guid
=
ScopedHString
:
:
Create
(
RuntimeClass_Windows_UI_ViewManagement_UIViewSettings
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IUIViewSettingsInterop
>
view_settings_interop
;
HRESULT
hr
=
:
:
RoGetActivationFactory
(
view_settings_guid
.
get
(
)
IID_PPV_ARGS
(
&
view_settings_interop
)
)
;
if
(
FAILED
(
hr
)
)
return
false
;
Microsoft
:
:
WRL
:
:
ComPtr
<
ABI
:
:
Windows
:
:
UI
:
:
ViewManagement
:
:
IUIViewSettings
>
view_settings
;
hr
=
view_settings_interop
-
>
GetForWindow
(
hwnd
IID_PPV_ARGS
(
&
view_settings
)
)
;
if
(
FAILED
(
hr
)
)
return
false
;
ABI
:
:
Windows
:
:
UI
:
:
ViewManagement
:
:
UserInteractionMode
mode
=
ABI
:
:
Windows
:
:
UI
:
:
ViewManagement
:
:
UserInteractionMode_Mouse
;
view_settings
-
>
get_UserInteractionMode
(
&
mode
)
;
return
mode
=
=
ABI
:
:
Windows
:
:
UI
:
:
ViewManagement
:
:
UserInteractionMode_Touch
;
}
bool
IsKeyboardPresentOnSlate
(
HWND
hwnd
std
:
:
string
*
reason
)
{
bool
result
=
false
;
if
(
CommandLine
:
:
ForCurrentProcess
(
)
-
>
HasSwitch
(
switches
:
:
kDisableUsbKeyboardDetect
)
)
{
if
(
reason
)
*
reason
=
"
Detection
disabled
"
;
return
false
;
}
if
(
(
GetSystemMetrics
(
SM_DIGITIZER
)
&
NID_INTEGRATED_TOUCH
)
!
=
NID_INTEGRATED_TOUCH
)
{
if
(
reason
)
{
*
reason
+
=
"
NID_INTEGRATED_TOUCH
\
n
"
;
result
=
true
;
}
else
{
return
true
;
}
}
if
(
IsTabletDevice
(
reason
hwnd
)
)
{
if
(
reason
)
*
reason
+
=
"
Tablet
device
.
\
n
"
;
return
false
;
}
if
(
!
reason
)
return
true
;
*
reason
+
=
"
Not
a
tablet
device
"
;
result
=
true
;
using
GetAutoRotationState
=
decltype
(
&
:
:
GetAutoRotationState
)
;
static
const
auto
get_rotation_state
=
reinterpret_cast
<
GetAutoRotationState
>
(
GetUser32FunctionPointer
(
"
GetAutoRotationState
"
)
)
;
if
(
get_rotation_state
)
{
AR_STATE
auto_rotation_state
=
AR_ENABLED
;
get_rotation_state
(
&
auto_rotation_state
)
;
if
(
(
auto_rotation_state
&
AR_NOSENSOR
)
|
|
(
auto_rotation_state
&
AR_NOT_SUPPORTED
)
)
{
if
(
!
reason
)
return
true
;
*
reason
+
=
(
auto_rotation_state
&
AR_NOSENSOR
)
?
"
AR_NOSENSOR
\
n
"
:
"
AR_NOT_SUPPORTED
\
n
"
;
result
=
true
;
}
}
const
GUID
KEYBOARD_CLASS_GUID
=
{
0x4D36E96B
0xE325
0x11CE
{
0xBF
0xC1
0x08
0x00
0x2B
0xE1
0x03
0x18
}
}
;
HDEVINFO
device_info
=
SetupDiGetClassDevs
(
&
KEYBOARD_CLASS_GUID
nullptr
nullptr
DIGCF_PRESENT
)
;
if
(
device_info
=
=
INVALID_HANDLE_VALUE
)
{
if
(
reason
)
*
reason
+
=
"
No
keyboard
info
\
n
"
;
return
result
;
}
for
(
DWORD
i
=
0
;
;
+
+
i
)
{
SP_DEVINFO_DATA
device_info_data
=
{
0
}
;
device_info_data
.
cbSize
=
sizeof
(
device_info_data
)
;
if
(
!
SetupDiEnumDeviceInfo
(
device_info
i
&
device_info_data
)
)
break
;
wchar_t
device_id
[
MAX_DEVICE_ID_LEN
]
;
CONFIGRET
status
=
CM_Get_Device_ID
(
device_info_data
.
DevInst
device_id
MAX_DEVICE_ID_LEN
0
)
;
if
(
status
=
=
CR_SUCCESS
)
{
if
(
StartsWith
(
device_id
L
"
ACPI
"
CompareCase
:
:
INSENSITIVE_ASCII
)
|
|
StartsWith
(
device_id
L
"
HID
\
\
VID
"
CompareCase
:
:
INSENSITIVE_ASCII
)
)
{
if
(
reason
)
{
*
reason
+
=
"
device
:
"
;
*
reason
+
=
WideToUTF8
(
device_id
)
;
*
reason
+
=
'
\
n
'
;
}
result
=
true
;
}
}
}
return
result
;
}
static
bool
g_crash_on_process_detach
=
false
;
bool
GetUserSidString
(
std
:
:
wstring
*
user_sid
)
{
absl
:
:
optional
<
AccessToken
>
token
=
AccessToken
:
:
FromCurrentProcess
(
)
;
if
(
!
token
)
return
false
;
absl
:
:
optional
<
std
:
:
wstring
>
sid_string
=
token
-
>
User
(
)
.
ToSddlString
(
)
;
if
(
!
sid_string
)
return
false
;
*
user_sid
=
*
sid_string
;
return
true
;
}
class
ScopedAllowBlockingForUserAccountControl
:
public
ScopedAllowBlocking
{
}
;
bool
UserAccountControlIsEnabled
(
)
{
ScopedAllowBlockingForUserAccountControl
allow_blocking
;
RegKey
key
(
HKEY_LOCAL_MACHINE
L
"
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Policies
\
\
System
"
KEY_READ
)
;
DWORD
uac_enabled
;
if
(
key
.
ReadValueDW
(
L
"
EnableLUA
"
&
uac_enabled
)
!
=
ERROR_SUCCESS
)
{
return
true
;
}
return
(
uac_enabled
!
=
0
)
;
}
bool
SetBooleanValueForPropertyStore
(
IPropertyStore
*
property_store
const
PROPERTYKEY
&
property_key
bool
property_bool_value
)
{
ScopedPropVariant
property_value
;
if
(
FAILED
(
InitPropVariantFromBoolean
(
property_bool_value
property_value
.
Receive
(
)
)
)
)
{
return
false
;
}
return
SetPropVariantValueForPropertyStore
(
property_store
property_key
property_value
)
;
}
bool
SetStringValueForPropertyStore
(
IPropertyStore
*
property_store
const
PROPERTYKEY
&
property_key
const
wchar_t
*
property_string_value
)
{
ScopedPropVariant
property_value
;
if
(
FAILED
(
InitPropVariantFromString
(
property_string_value
property_value
.
Receive
(
)
)
)
)
{
return
false
;
}
return
SetPropVariantValueForPropertyStore
(
property_store
property_key
property_value
)
;
}
bool
SetClsidForPropertyStore
(
IPropertyStore
*
property_store
const
PROPERTYKEY
&
property_key
const
CLSID
&
property_clsid_value
)
{
ScopedPropVariant
property_value
;
if
(
FAILED
(
InitPropVariantFromCLSID
(
property_clsid_value
property_value
.
Receive
(
)
)
)
)
{
return
false
;
}
return
SetPropVariantValueForPropertyStore
(
property_store
property_key
property_value
)
;
}
bool
SetAppIdForPropertyStore
(
IPropertyStore
*
property_store
const
wchar_t
*
app_id
)
{
DCHECK_LT
(
lstrlen
(
app_id
)
128
)
;
DCHECK_EQ
(
wcschr
(
app_id
L
'
'
)
nullptr
)
;
return
SetStringValueForPropertyStore
(
property_store
PKEY_AppUserModel_ID
app_id
)
;
}
static
const
wchar_t
kAutoRunKeyPath
[
]
=
L
"
Software
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Run
"
;
bool
AddCommandToAutoRun
(
HKEY
root_key
const
std
:
:
wstring
&
name
const
std
:
:
wstring
&
command
)
{
RegKey
autorun_key
(
root_key
kAutoRunKeyPath
KEY_SET_VALUE
)
;
return
(
autorun_key
.
WriteValue
(
name
.
c_str
(
)
command
.
c_str
(
)
)
=
=
ERROR_SUCCESS
)
;
}
bool
RemoveCommandFromAutoRun
(
HKEY
root_key
const
std
:
:
wstring
&
name
)
{
RegKey
autorun_key
(
root_key
kAutoRunKeyPath
KEY_SET_VALUE
)
;
return
(
autorun_key
.
DeleteValue
(
name
.
c_str
(
)
)
=
=
ERROR_SUCCESS
)
;
}
bool
ReadCommandFromAutoRun
(
HKEY
root_key
const
std
:
:
wstring
&
name
std
:
:
wstring
*
command
)
{
RegKey
autorun_key
(
root_key
kAutoRunKeyPath
KEY_QUERY_VALUE
)
;
return
(
autorun_key
.
ReadValue
(
name
.
c_str
(
)
command
)
=
=
ERROR_SUCCESS
)
;
}
void
SetShouldCrashOnProcessDetach
(
bool
crash
)
{
g_crash_on_process_detach
=
crash
;
}
bool
ShouldCrashOnProcessDetach
(
)
{
return
g_crash_on_process_detach
;
}
void
SetAbortBehaviorForCrashReporting
(
)
{
_set_abort_behavior
(
0
_WRITE_ABORT_MSG
|
_CALL_REPORTFAULT
)
;
signal
(
SIGABRT
ForceCrashOnSigAbort
)
;
}
bool
IsTabletDevice
(
std
:
:
string
*
reason
HWND
hwnd
)
{
if
(
IsWindows10OrGreaterTabletMode
(
hwnd
)
)
return
true
;
return
IsDeviceUsedAsATablet
(
reason
)
;
}
bool
IsDeviceUsedAsATablet
(
std
:
:
string
*
reason
)
{
absl
:
:
optional
<
bool
>
ret
;
if
(
GetSystemMetrics
(
SM_MAXIMUMTOUCHES
)
=
=
0
)
{
if
(
reason
)
{
*
reason
+
=
"
Device
does
not
support
touch
.
\
n
"
;
ret
=
false
;
}
else
{
return
false
;
}
}
if
(
GetSystemMetrics
(
SM_SYSTEMDOCKED
)
!
=
0
)
{
if
(
reason
)
{
*
reason
+
=
"
SM_SYSTEMDOCKED
\
n
"
;
if
(
!
ret
.
has_value
(
)
)
ret
=
false
;
}
else
{
return
false
;
}
}
using
GetAutoRotationStateType
=
decltype
(
GetAutoRotationState
)
*
;
static
const
auto
get_auto_rotation_state_func
=
reinterpret_cast
<
GetAutoRotationStateType
>
(
GetUser32FunctionPointer
(
"
GetAutoRotationState
"
)
)
;
if
(
get_auto_rotation_state_func
)
{
AR_STATE
rotation_state
=
AR_ENABLED
;
if
(
get_auto_rotation_state_func
(
&
rotation_state
)
&
&
(
rotation_state
&
(
AR_NOT_SUPPORTED
|
AR_LAPTOP
|
AR_NOSENSOR
)
)
!
=
0
)
return
ret
.
has_value
(
)
?
ret
.
value
(
)
:
false
;
}
POWER_PLATFORM_ROLE
role
=
GetPlatformRole
(
)
;
bool
is_tablet
=
false
;
if
(
role
=
=
PlatformRoleMobile
|
|
role
=
=
PlatformRoleSlate
)
{
is_tablet
=
!
GetSystemMetrics
(
SM_CONVERTIBLESLATEMODE
)
;
if
(
!
is_tablet
)
{
if
(
reason
)
{
*
reason
+
=
"
Not
in
slate
mode
.
\
n
"
;
if
(
!
ret
.
has_value
(
)
)
ret
=
false
;
}
else
{
return
false
;
}
}
else
if
(
reason
)
{
*
reason
+
=
(
role
=
=
PlatformRoleMobile
)
?
"
PlatformRoleMobile
\
n
"
:
"
PlatformRoleSlate
\
n
"
;
}
}
else
if
(
reason
)
{
*
reason
+
=
"
Device
role
is
not
mobile
or
slate
.
\
n
"
;
}
return
ret
.
has_value
(
)
?
ret
.
value
(
)
:
is_tablet
;
}
bool
IsEnrolledToDomain
(
)
{
return
*
GetDomainEnrollmentStateStorage
(
)
;
}
bool
IsDeviceRegisteredWithManagement
(
)
{
if
(
OSInfo
:
:
GetInstance
(
)
-
>
version_type
(
)
=
=
SUITE_HOME
)
return
false
;
return
*
GetRegisteredWithManagementStateStorage
(
)
;
}
bool
IsJoinedToAzureAD
(
)
{
return
*
GetAzureADJoinStateStorage
(
)
;
}
#
endif
bool
IsUser32AndGdi32Available
(
)
{
static
auto
is_user32_and_gdi32_available
=
[
]
(
)
{
PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY
policy
=
{
}
;
if
(
:
:
GetProcessMitigationPolicy
(
GetCurrentProcess
(
)
ProcessSystemCallDisablePolicy
&
policy
sizeof
(
policy
)
)
)
{
return
policy
.
DisallowWin32kSystemCalls
=
=
0
;
}
return
true
;
}
(
)
;
return
is_user32_and_gdi32_available
;
}
#
if
!
defined
(
MOZ_ZUCCHINI
)
bool
GetLoadedModulesSnapshot
(
HANDLE
process
std
:
:
vector
<
HMODULE
>
*
snapshot
)
{
DCHECK
(
snapshot
)
;
DCHECK_EQ
(
0u
snapshot
-
>
size
(
)
)
;
snapshot
-
>
resize
(
128
)
;
int
retries_remaining
=
5
;
do
{
DWORD
bytes_required
=
0
;
DCHECK_GE
(
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
snapshot
-
>
size
(
)
*
sizeof
(
HMODULE
)
)
;
if
(
!
:
:
EnumProcessModules
(
process
&
(
*
snapshot
)
[
0
]
static_cast
<
DWORD
>
(
snapshot
-
>
size
(
)
*
sizeof
(
HMODULE
)
)
&
bytes_required
)
)
{
DPLOG
(
ERROR
)
<
<
"
:
:
EnumProcessModules
failed
.
"
;
return
false
;
}
DCHECK_EQ
(
0u
bytes_required
%
sizeof
(
HMODULE
)
)
;
size_t
num_modules
=
bytes_required
/
sizeof
(
HMODULE
)
;
if
(
num_modules
<
=
snapshot
-
>
size
(
)
)
{
snapshot
-
>
erase
(
snapshot
-
>
begin
(
)
+
static_cast
<
ptrdiff_t
>
(
num_modules
)
snapshot
-
>
end
(
)
)
;
return
true
;
}
else
if
(
num_modules
=
=
0
)
{
DLOG
(
ERROR
)
<
<
"
Can
'
t
determine
the
module
list
size
.
"
;
return
false
;
}
else
{
snapshot
-
>
resize
(
num_modules
+
8
nullptr
)
;
}
}
while
(
-
-
retries_remaining
)
;
DLOG
(
ERROR
)
<
<
"
Failed
to
enumerate
modules
.
"
;
return
false
;
}
void
EnableFlicks
(
HWND
hwnd
)
{
:
:
RemoveProp
(
hwnd
MICROSOFT_TABLETPENSERVICE_PROPERTY
)
;
}
void
DisableFlicks
(
HWND
hwnd
)
{
:
:
SetProp
(
hwnd
MICROSOFT_TABLETPENSERVICE_PROPERTY
reinterpret_cast
<
HANDLE
>
(
TABLET_DISABLE_FLICKS
|
TABLET_DISABLE_FLICKFALLBACKKEYS
)
)
;
}
void
EnableHighDPISupport
(
)
{
if
(
!
IsUser32AndGdi32Available
(
)
)
return
;
if
(
EnablePerMonitorV2
(
)
)
return
;
PROCESS_DPI_AWARENESS
process_dpi_awareness
=
PROCESS_PER_MONITOR_DPI_AWARE
;
if
(
!
:
:
SetProcessDpiAwareness
(
process_dpi_awareness
)
)
{
BOOL
result
=
:
:
SetProcessDPIAware
(
)
;
DCHECK
(
result
)
<
<
"
SetProcessDPIAware
failed
.
"
;
}
}
std
:
:
wstring
WStringFromGUID
(
const
:
:
GUID
&
rguid
)
{
constexpr
int
kGuidStringCharacters
=
1
+
8
+
1
+
4
+
1
+
4
+
1
+
4
+
1
+
12
+
1
+
1
;
wchar_t
guid_string
[
kGuidStringCharacters
]
;
CHECK
(
SUCCEEDED
(
StringCchPrintfW
(
guid_string
kGuidStringCharacters
L
"
{
%
08lX
-
%
04X
-
%
04X
-
%
02X
%
02X
-
%
02X
%
02X
%
02X
%
02X
%
02X
%
02X
}
"
rguid
.
Data1
rguid
.
Data2
rguid
.
Data3
rguid
.
Data4
[
0
]
rguid
.
Data4
[
1
]
rguid
.
Data4
[
2
]
rguid
.
Data4
[
3
]
rguid
.
Data4
[
4
]
rguid
.
Data4
[
5
]
rguid
.
Data4
[
6
]
rguid
.
Data4
[
7
]
)
)
)
;
return
std
:
:
wstring
(
guid_string
kGuidStringCharacters
-
1
)
;
}
bool
PinUser32
(
NativeLibraryLoadError
*
error
)
{
return
PinUser32Internal
(
error
)
!
=
nullptr
;
}
void
*
GetUser32FunctionPointer
(
const
char
*
function_name
NativeLibraryLoadError
*
error
)
{
NativeLibrary
user32_module
=
PinUser32Internal
(
error
)
;
if
(
user32_module
)
return
GetFunctionPointerFromNativeLibrary
(
user32_module
function_name
)
;
return
nullptr
;
}
std
:
:
wstring
GetWindowObjectName
(
HANDLE
handle
)
{
std
:
:
wstring
object_name
;
DWORD
size
=
0
;
:
:
GetUserObjectInformation
(
handle
UOI_NAME
nullptr
0
&
size
)
;
if
(
!
size
)
{
DPCHECK
(
false
)
;
return
object_name
;
}
LOG_ASSERT
(
size
%
sizeof
(
wchar_t
)
=
=
0u
)
;
if
(
!
:
:
GetUserObjectInformation
(
handle
UOI_NAME
WriteInto
(
&
object_name
size
/
sizeof
(
wchar_t
)
)
size
&
size
)
)
{
DPCHECK
(
false
)
;
}
return
object_name
;
}
bool
IsRunningUnderDesktopName
(
WStringPiece
desktop_name
)
{
HDESK
thread_desktop
=
:
:
GetThreadDesktop
(
:
:
GetCurrentThreadId
(
)
)
;
if
(
!
thread_desktop
)
return
false
;
std
:
:
wstring
current_desktop_name
=
GetWindowObjectName
(
thread_desktop
)
;
return
EqualsCaseInsensitiveASCII
(
AsStringPiece16
(
current_desktop_name
)
AsStringPiece16
(
desktop_name
)
)
;
}
bool
IsCurrentSessionRemote
(
)
{
if
(
:
:
GetSystemMetrics
(
SM_REMOTESESSION
)
)
return
true
;
DWORD
current_session_id
=
0
;
if
(
!
:
:
ProcessIdToSessionId
(
:
:
GetCurrentProcessId
(
)
&
current_session_id
)
)
return
false
;
static
constexpr
wchar_t
kRdpSettingsKeyName
[
]
=
L
"
SYSTEM
\
\
CurrentControlSet
\
\
Control
\
\
Terminal
Server
"
;
RegKey
key
(
HKEY_LOCAL_MACHINE
kRdpSettingsKeyName
KEY_READ
)
;
if
(
!
key
.
Valid
(
)
)
return
false
;
static
constexpr
wchar_t
kGlassSessionIdValueName
[
]
=
L
"
GlassSessionId
"
;
DWORD
glass_session_id
=
0
;
if
(
key
.
ReadValueDW
(
kGlassSessionIdValueName
&
glass_session_id
)
!
=
ERROR_SUCCESS
)
return
false
;
return
current_session_id
!
=
glass_session_id
;
}
#
if
!
defined
(
OFFICIAL_BUILD
)
bool
IsAppVerifierEnabled
(
const
std
:
:
wstring
&
process_name
)
{
RegKey
key
;
return
key
.
Open
(
HKEY_LOCAL_MACHINE
(
L
"
SOFTWARE
\
\
Microsoft
\
\
Windows
NT
\
\
CurrentVersion
\
\
Image
File
"
L
"
Execution
Options
\
\
"
+
process_name
)
.
c_str
(
)
KEY_READ
|
KEY_WOW64_64KEY
)
=
=
ERROR_SUCCESS
&
&
key
.
HasValue
(
L
"
GlobalFlag
"
)
;
}
#
endif
bool
IsAppVerifierLoaded
(
)
{
return
GetModuleHandleA
(
kApplicationVerifierDllName
)
;
}
ScopedDomainStateForTesting
:
:
ScopedDomainStateForTesting
(
bool
state
)
:
initial_state_
(
IsEnrolledToDomain
(
)
)
{
*
GetDomainEnrollmentStateStorage
(
)
=
state
;
}
ScopedDomainStateForTesting
:
:
~
ScopedDomainStateForTesting
(
)
{
*
GetDomainEnrollmentStateStorage
(
)
=
initial_state_
;
}
ScopedDeviceRegisteredWithManagementForTesting
:
:
ScopedDeviceRegisteredWithManagementForTesting
(
bool
state
)
:
initial_state_
(
IsDeviceRegisteredWithManagement
(
)
)
{
*
GetRegisteredWithManagementStateStorage
(
)
=
state
;
}
ScopedDeviceRegisteredWithManagementForTesting
:
:
~
ScopedDeviceRegisteredWithManagementForTesting
(
)
{
*
GetRegisteredWithManagementStateStorage
(
)
=
initial_state_
;
}
ScopedAzureADJoinStateForTesting
:
:
ScopedAzureADJoinStateForTesting
(
bool
state
)
:
initial_state_
(
std
:
:
exchange
(
*
GetAzureADJoinStateStorage
(
)
state
)
)
{
}
ScopedAzureADJoinStateForTesting
:
:
~
ScopedAzureADJoinStateForTesting
(
)
{
*
GetAzureADJoinStateStorage
(
)
=
initial_state_
;
}
#
endif
}
}
