#
ifndef
BASE_SYNCHRONIZATION_LOCK_IMPL_H_
#
define
BASE_SYNCHRONIZATION_LOCK_IMPL_H_
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check
.
h
"
#
include
"
base
/
dcheck_is_on
.
h
"
#
include
"
base
/
thread_annotations
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
BUILDFLAG
(
IS_WIN
)
#
include
"
base
/
win
/
windows_types
.
h
"
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
#
include
<
errno
.
h
>
#
include
<
pthread
.
h
>
#
include
<
string
.
h
>
#
endif
namespace
base
{
class
Lock
;
class
ConditionVariable
;
namespace
win
{
namespace
internal
{
class
AutoNativeLock
;
class
ScopedHandleVerifier
;
}
}
namespace
internal
{
class
BASE_EXPORT
LockImpl
{
public
:
LockImpl
(
const
LockImpl
&
)
=
delete
;
LockImpl
&
operator
=
(
const
LockImpl
&
)
=
delete
;
private
:
friend
class
base
:
:
Lock
;
friend
class
base
:
:
ConditionVariable
;
friend
class
base
:
:
win
:
:
internal
:
:
AutoNativeLock
;
friend
class
base
:
:
win
:
:
internal
:
:
ScopedHandleVerifier
;
#
if
BUILDFLAG
(
IS_WIN
)
using
NativeHandle
=
CHROME_SRWLOCK
;
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
using
NativeHandle
=
pthread_mutex_t
;
#
endif
LockImpl
(
)
;
~
LockImpl
(
)
;
inline
bool
Try
(
)
;
inline
void
Lock
(
)
;
inline
void
Unlock
(
)
;
NativeHandle
*
native_handle
(
)
{
return
&
native_handle_
;
}
#
if
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
static
bool
PriorityInheritanceAvailable
(
)
;
#
endif
void
LockInternal
(
)
;
NativeHandle
native_handle_
;
}
;
void
LockImpl
:
:
Lock
(
)
{
if
(
Try
(
)
)
{
return
;
}
LockInternal
(
)
;
}
#
if
BUILDFLAG
(
IS_WIN
)
bool
LockImpl
:
:
Try
(
)
{
return
!
!
:
:
TryAcquireSRWLockExclusive
(
reinterpret_cast
<
PSRWLOCK
>
(
&
native_handle_
)
)
;
}
void
LockImpl
:
:
Unlock
(
)
{
:
:
ReleaseSRWLockExclusive
(
reinterpret_cast
<
PSRWLOCK
>
(
&
native_handle_
)
)
;
}
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
#
if
DCHECK_IS_ON
(
)
BASE_EXPORT
void
dcheck_trylock_result
(
int
rv
)
;
BASE_EXPORT
void
dcheck_unlock_result
(
int
rv
)
;
#
endif
bool
LockImpl
:
:
Try
(
)
{
int
rv
=
pthread_mutex_trylock
(
&
native_handle_
)
;
#
if
DCHECK_IS_ON
(
)
dcheck_trylock_result
(
rv
)
;
#
endif
return
rv
=
=
0
;
}
void
LockImpl
:
:
Unlock
(
)
{
[
[
maybe_unused
]
]
int
rv
=
pthread_mutex_unlock
(
&
native_handle_
)
;
#
if
DCHECK_IS_ON
(
)
dcheck_unlock_result
(
rv
)
;
#
endif
}
#
endif
template
<
class
LockType
>
class
SCOPED_LOCKABLE
BasicAutoLock
{
public
:
struct
AlreadyAcquired
{
}
;
explicit
BasicAutoLock
(
LockType
&
lock
)
EXCLUSIVE_LOCK_FUNCTION
(
lock
)
:
lock_
(
lock
)
{
lock_
.
Acquire
(
)
;
}
BasicAutoLock
(
LockType
&
lock
const
AlreadyAcquired
&
)
EXCLUSIVE_LOCKS_REQUIRED
(
lock
)
:
lock_
(
lock
)
{
lock_
.
AssertAcquired
(
)
;
}
BasicAutoLock
(
const
BasicAutoLock
&
)
=
delete
;
BasicAutoLock
&
operator
=
(
const
BasicAutoLock
&
)
=
delete
;
~
BasicAutoLock
(
)
UNLOCK_FUNCTION
(
)
{
lock_
.
AssertAcquired
(
)
;
lock_
.
Release
(
)
;
}
private
:
LockType
&
lock_
;
}
;
template
<
class
LockType
>
class
SCOPED_LOCKABLE
BasicAutoTryLock
{
public
:
explicit
BasicAutoTryLock
(
LockType
&
lock
)
EXCLUSIVE_LOCK_FUNCTION
(
lock
)
:
lock_
(
lock
)
is_acquired_
(
lock_
.
Try
(
)
)
{
}
BasicAutoTryLock
(
const
BasicAutoTryLock
&
)
=
delete
;
BasicAutoTryLock
&
operator
=
(
const
BasicAutoTryLock
&
)
=
delete
;
~
BasicAutoTryLock
(
)
UNLOCK_FUNCTION
(
)
{
if
(
is_acquired_
)
{
lock_
.
AssertAcquired
(
)
;
lock_
.
Release
(
)
;
}
}
bool
is_acquired
(
)
const
{
return
is_acquired_
;
}
private
:
LockType
&
lock_
;
const
bool
is_acquired_
;
}
;
template
<
class
LockType
>
class
BasicAutoUnlock
{
public
:
explicit
BasicAutoUnlock
(
LockType
&
lock
)
:
lock_
(
lock
)
{
lock_
.
AssertAcquired
(
)
;
lock_
.
Release
(
)
;
}
BasicAutoUnlock
(
const
BasicAutoUnlock
&
)
=
delete
;
BasicAutoUnlock
&
operator
=
(
const
BasicAutoUnlock
&
)
=
delete
;
~
BasicAutoUnlock
(
)
{
lock_
.
Acquire
(
)
;
}
private
:
LockType
&
lock_
;
}
;
template
<
class
LockType
>
class
SCOPED_LOCKABLE
BasicAutoLockMaybe
{
public
:
explicit
BasicAutoLockMaybe
(
LockType
*
lock
)
EXCLUSIVE_LOCK_FUNCTION
(
lock
)
:
lock_
(
lock
)
{
if
(
lock_
)
lock_
-
>
Acquire
(
)
;
}
BasicAutoLockMaybe
(
const
BasicAutoLockMaybe
&
)
=
delete
;
BasicAutoLockMaybe
&
operator
=
(
const
BasicAutoLockMaybe
&
)
=
delete
;
~
BasicAutoLockMaybe
(
)
UNLOCK_FUNCTION
(
)
{
if
(
lock_
)
{
lock_
-
>
AssertAcquired
(
)
;
lock_
-
>
Release
(
)
;
}
}
private
:
LockType
*
const
lock_
;
}
;
template
<
class
LockType
>
class
SCOPED_LOCKABLE
BasicReleasableAutoLock
{
public
:
explicit
BasicReleasableAutoLock
(
LockType
*
lock
)
EXCLUSIVE_LOCK_FUNCTION
(
lock
)
:
lock_
(
lock
)
{
DCHECK
(
lock_
)
;
lock_
-
>
Acquire
(
)
;
}
BasicReleasableAutoLock
(
const
BasicReleasableAutoLock
&
)
=
delete
;
BasicReleasableAutoLock
&
operator
=
(
const
BasicReleasableAutoLock
&
)
=
delete
;
~
BasicReleasableAutoLock
(
)
UNLOCK_FUNCTION
(
)
{
if
(
lock_
)
{
lock_
-
>
AssertAcquired
(
)
;
lock_
-
>
Release
(
)
;
}
}
void
Release
(
)
UNLOCK_FUNCTION
(
)
{
DCHECK
(
lock_
)
;
lock_
-
>
AssertAcquired
(
)
;
lock_
-
>
Release
(
)
;
lock_
=
nullptr
;
}
private
:
LockType
*
lock_
;
}
;
}
}
#
endif
