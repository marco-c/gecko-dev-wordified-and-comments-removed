#
ifndef
BASE_FILES_FILE_UTIL_H_
#
define
BASE_FILES_FILE_UTIL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
limits
>
#
include
<
set
>
#
include
<
string
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
containers
/
span
.
h
"
#
include
"
base
/
files
/
file
.
h
"
#
include
"
base
/
files
/
file_path
.
h
"
#
include
"
base
/
files
/
scoped_file
.
h
"
#
include
"
base
/
functional
/
callback
.
h
"
#
include
"
build
/
build_config
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
types
/
optional
.
h
"
#
if
BUILDFLAG
(
IS_WIN
)
#
include
"
base
/
win
/
windows_types
.
h
"
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
#
include
<
sys
/
stat
.
h
>
#
include
<
unistd
.
h
>
#
include
"
base
/
posix
/
eintr_wrapper
.
h
"
#
endif
namespace
base
{
class
Environment
;
class
Time
;
BASE_EXPORT
FilePath
MakeAbsoluteFilePath
(
const
FilePath
&
input
)
;
#
if
BUILDFLAG
(
IS_POSIX
)
[
[
nodiscard
]
]
BASE_EXPORT
absl
:
:
optional
<
FilePath
>
MakeAbsoluteFilePathNoResolveSymbolicLinks
(
const
FilePath
&
input
)
;
#
endif
BASE_EXPORT
int64_t
ComputeDirectorySize
(
const
FilePath
&
root_path
)
;
BASE_EXPORT
bool
DeleteFile
(
const
FilePath
&
path
)
;
BASE_EXPORT
bool
DeletePathRecursively
(
const
FilePath
&
path
)
;
BASE_EXPORT
OnceClosure
GetDeleteFileCallback
(
const
FilePath
&
path
OnceCallback
<
void
(
bool
)
>
reply_callback
=
{
}
)
;
BASE_EXPORT
OnceClosure
GetDeletePathRecursivelyCallback
(
const
FilePath
&
path
OnceCallback
<
void
(
bool
)
>
reply_callback
=
{
}
)
;
#
if
BUILDFLAG
(
IS_WIN
)
BASE_EXPORT
bool
DeleteFileAfterReboot
(
const
FilePath
&
path
)
;
BASE_EXPORT
bool
PreventExecuteMapping
(
const
FilePath
&
path
)
;
BASE_EXPORT
void
SetExtraNoExecuteAllowedPath
(
int
path_key
)
;
#
endif
BASE_EXPORT
bool
Move
(
const
FilePath
&
from_path
const
FilePath
&
to_path
)
;
BASE_EXPORT
bool
ReplaceFile
(
const
FilePath
&
from_path
const
FilePath
&
to_path
File
:
:
Error
*
error
)
;
BASE_EXPORT
bool
CopyFile
(
const
FilePath
&
from_path
const
FilePath
&
to_path
)
;
BASE_EXPORT
bool
CopyFileContents
(
File
&
infile
File
&
outfile
)
;
BASE_EXPORT
bool
CopyDirectory
(
const
FilePath
&
from_path
const
FilePath
&
to_path
bool
recursive
)
;
BASE_EXPORT
bool
CopyDirectoryExcl
(
const
FilePath
&
from_path
const
FilePath
&
to_path
bool
recursive
)
;
BASE_EXPORT
bool
PathExists
(
const
FilePath
&
path
)
;
BASE_EXPORT
bool
PathIsReadable
(
const
FilePath
&
path
)
;
BASE_EXPORT
bool
PathIsWritable
(
const
FilePath
&
path
)
;
BASE_EXPORT
bool
DirectoryExists
(
const
FilePath
&
path
)
;
BASE_EXPORT
bool
ContentsEqual
(
const
FilePath
&
filename1
const
FilePath
&
filename2
)
;
BASE_EXPORT
bool
TextContentsEqual
(
const
FilePath
&
filename1
const
FilePath
&
filename2
)
;
BASE_EXPORT
absl
:
:
optional
<
std
:
:
vector
<
uint8_t
>
>
ReadFileToBytes
(
const
FilePath
&
path
)
;
BASE_EXPORT
bool
ReadFileToString
(
const
FilePath
&
path
std
:
:
string
*
contents
)
;
BASE_EXPORT
bool
ReadFileToStringWithMaxSize
(
const
FilePath
&
path
std
:
:
string
*
contents
size_t
max_size
)
;
BASE_EXPORT
bool
ReadStreamToString
(
FILE
*
stream
std
:
:
string
*
contents
)
;
BASE_EXPORT
bool
ReadStreamToStringWithMaxSize
(
FILE
*
stream
size_t
max_size
std
:
:
string
*
contents
)
;
#
if
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
BASE_EXPORT
bool
ReadFromFD
(
int
fd
char
*
buffer
size_t
bytes
)
;
BASE_EXPORT
ScopedFD
CreateAndOpenFdForTemporaryFileInDir
(
const
FilePath
&
dir
FilePath
*
path
)
;
#
endif
#
if
BUILDFLAG
(
IS_POSIX
)
BASE_EXPORT
bool
ReadFileToStringNonBlocking
(
const
base
:
:
FilePath
&
file
std
:
:
string
*
ret
)
;
BASE_EXPORT
bool
CreateSymbolicLink
(
const
FilePath
&
target
const
FilePath
&
symlink
)
;
BASE_EXPORT
bool
ReadSymbolicLink
(
const
FilePath
&
symlink
FilePath
*
target
)
;
BASE_EXPORT
absl
:
:
optional
<
FilePath
>
ReadSymbolicLinkAbsolute
(
const
FilePath
&
symlink
)
;
enum
FilePermissionBits
{
FILE_PERMISSION_MASK
=
S_IRWXU
|
S_IRWXG
|
S_IRWXO
FILE_PERMISSION_USER_MASK
=
S_IRWXU
FILE_PERMISSION_GROUP_MASK
=
S_IRWXG
FILE_PERMISSION_OTHERS_MASK
=
S_IRWXO
FILE_PERMISSION_READ_BY_USER
=
S_IRUSR
FILE_PERMISSION_WRITE_BY_USER
=
S_IWUSR
FILE_PERMISSION_EXECUTE_BY_USER
=
S_IXUSR
FILE_PERMISSION_READ_BY_GROUP
=
S_IRGRP
FILE_PERMISSION_WRITE_BY_GROUP
=
S_IWGRP
FILE_PERMISSION_EXECUTE_BY_GROUP
=
S_IXGRP
FILE_PERMISSION_READ_BY_OTHERS
=
S_IROTH
FILE_PERMISSION_WRITE_BY_OTHERS
=
S_IWOTH
FILE_PERMISSION_EXECUTE_BY_OTHERS
=
S_IXOTH
}
;
BASE_EXPORT
bool
GetPosixFilePermissions
(
const
FilePath
&
path
int
*
mode
)
;
BASE_EXPORT
bool
SetPosixFilePermissions
(
const
FilePath
&
path
int
mode
)
;
BASE_EXPORT
bool
ExecutableExistsInPath
(
Environment
*
env
const
FilePath
:
:
StringType
&
executable
)
;
#
if
BUILDFLAG
(
IS_LINUX
)
|
|
BUILDFLAG
(
IS_CHROMEOS
)
|
|
BUILDFLAG
(
IS_AIX
)
BASE_EXPORT
bool
IsPathExecutable
(
const
FilePath
&
path
)
;
#
endif
#
endif
BASE_EXPORT
bool
IsDirectoryEmpty
(
const
FilePath
&
dir_path
)
;
BASE_EXPORT
bool
GetTempDir
(
FilePath
*
path
)
;
BASE_EXPORT
FilePath
GetHomeDir
(
)
;
BASE_EXPORT
File
CreateAndOpenTemporaryFileInDir
(
const
FilePath
&
dir
FilePath
*
temp_file
)
;
BASE_EXPORT
bool
CreateTemporaryFile
(
FilePath
*
path
)
;
BASE_EXPORT
bool
CreateTemporaryFileInDir
(
const
FilePath
&
dir
FilePath
*
temp_file
)
;
BASE_EXPORT
FilePath
FormatTemporaryFileName
(
FilePath
:
:
StringPieceType
identifier
)
;
BASE_EXPORT
ScopedFILE
CreateAndOpenTemporaryStream
(
FilePath
*
path
)
;
BASE_EXPORT
ScopedFILE
CreateAndOpenTemporaryStreamInDir
(
const
FilePath
&
dir
FilePath
*
path
)
;
#
if
BUILDFLAG
(
IS_WIN
)
BASE_EXPORT
bool
GetSecureSystemTemp
(
FilePath
*
temp
)
;
#
endif
BASE_EXPORT
bool
CreateNewTempDirectory
(
const
FilePath
:
:
StringType
&
prefix
FilePath
*
new_temp_path
)
;
BASE_EXPORT
bool
CreateTemporaryDirInDir
(
const
FilePath
&
base_dir
const
FilePath
:
:
StringType
&
prefix
FilePath
*
new_dir
)
;
BASE_EXPORT
bool
CreateDirectoryAndGetError
(
const
FilePath
&
full_path
File
:
:
Error
*
error
)
;
BASE_EXPORT
bool
CreateDirectory
(
const
FilePath
&
full_path
)
;
BASE_EXPORT
bool
GetFileSize
(
const
FilePath
&
file_path
int64_t
*
file_size
)
;
BASE_EXPORT
bool
NormalizeFilePath
(
const
FilePath
&
path
FilePath
*
real_path
)
;
#
if
BUILDFLAG
(
IS_WIN
)
BASE_EXPORT
bool
DevicePathToDriveLetterPath
(
const
FilePath
&
device_path
FilePath
*
drive_letter_path
)
;
BASE_EXPORT
FilePath
MakeLongFilePath
(
const
FilePath
&
input
)
;
BASE_EXPORT
bool
CreateWinHardLink
(
const
FilePath
&
to_file
const
FilePath
&
from_file
)
;
#
endif
BASE_EXPORT
bool
IsLink
(
const
FilePath
&
file_path
)
;
BASE_EXPORT
bool
GetFileInfo
(
const
FilePath
&
file_path
File
:
:
Info
*
info
)
;
BASE_EXPORT
bool
TouchFile
(
const
FilePath
&
path
const
Time
&
last_accessed
const
Time
&
last_modified
)
;
BASE_EXPORT
FILE
*
OpenFile
(
const
FilePath
&
filename
const
char
*
mode
)
;
BASE_EXPORT
bool
CloseFile
(
FILE
*
file
)
;
BASE_EXPORT
FILE
*
FileToFILE
(
File
file
const
char
*
mode
)
;
BASE_EXPORT
File
FILEToFile
(
FILE
*
file_stream
)
;
BASE_EXPORT
bool
TruncateFile
(
FILE
*
file
)
;
BASE_EXPORT
int
ReadFile
(
const
FilePath
&
filename
char
*
data
int
max_size
)
;
BASE_EXPORT
int
WriteFile
(
const
FilePath
&
filename
const
char
*
data
int
size
)
;
BASE_EXPORT
bool
WriteFile
(
const
FilePath
&
filename
span
<
const
uint8_t
>
data
)
;
BASE_EXPORT
bool
WriteFile
(
const
FilePath
&
filename
StringPiece
data
)
;
#
if
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
BASE_EXPORT
bool
WriteFileDescriptor
(
int
fd
span
<
const
uint8_t
>
data
)
;
BASE_EXPORT
bool
WriteFileDescriptor
(
int
fd
StringPiece
data
)
;
BASE_EXPORT
bool
AllocateFileRegion
(
File
*
file
int64_t
offset
size_t
size
)
;
#
endif
BASE_EXPORT
bool
AppendToFile
(
const
FilePath
&
filename
span
<
const
uint8_t
>
data
)
;
BASE_EXPORT
bool
AppendToFile
(
const
FilePath
&
filename
StringPiece
data
)
;
BASE_EXPORT
bool
GetCurrentDirectory
(
FilePath
*
path
)
;
BASE_EXPORT
bool
SetCurrentDirectory
(
const
FilePath
&
path
)
;
enum
{
kMaxUniqueFiles
=
100
}
;
BASE_EXPORT
int
GetUniquePathNumber
(
const
FilePath
&
path
)
;
BASE_EXPORT
FilePath
GetUniquePath
(
const
FilePath
&
path
)
;
BASE_EXPORT
bool
SetNonBlocking
(
int
fd
)
;
BASE_EXPORT
bool
PreReadFile
(
const
FilePath
&
file_path
bool
is_executable
int64_t
max_bytes
=
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
;
#
if
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
BASE_EXPORT
bool
CreatePipe
(
ScopedFD
*
read_fd
ScopedFD
*
write_fd
bool
non_blocking
=
false
)
;
BASE_EXPORT
bool
CreateLocalNonBlockingPipe
(
int
fds
[
2
]
)
;
BASE_EXPORT
bool
SetCloseOnExec
(
int
fd
)
;
#
endif
#
if
BUILDFLAG
(
IS_MAC
)
BASE_EXPORT
bool
VerifyPathControlledByUser
(
const
base
:
:
FilePath
&
base
const
base
:
:
FilePath
&
path
uid_t
owner_uid
const
std
:
:
set
<
gid_t
>
&
group_gids
)
;
BASE_EXPORT
bool
VerifyPathControlledByAdmin
(
const
base
:
:
FilePath
&
path
)
;
#
endif
BASE_EXPORT
int
GetMaximumPathComponentLength
(
const
base
:
:
FilePath
&
path
)
;
#
if
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
BASE_EXPORT
bool
GetShmemTempDir
(
bool
executable
FilePath
*
path
)
;
#
endif
namespace
internal
{
BASE_EXPORT
bool
MoveUnsafe
(
const
FilePath
&
from_path
const
FilePath
&
to_path
)
;
#
if
BUILDFLAG
(
IS_WIN
)
BASE_EXPORT
bool
CopyAndDeleteDirectory
(
const
FilePath
&
from_path
const
FilePath
&
to_path
)
;
#
endif
#
if
BUILDFLAG
(
IS_LINUX
)
|
|
BUILDFLAG
(
IS_CHROMEOS
)
|
|
BUILDFLAG
(
IS_ANDROID
)
BASE_EXPORT
bool
CopyFileContentsWithSendfile
(
File
&
infile
File
&
outfile
bool
&
retry_slow
)
;
#
endif
bool
PreReadFileSlow
(
const
FilePath
&
file_path
int64_t
max_bytes
)
;
}
}
#
endif
