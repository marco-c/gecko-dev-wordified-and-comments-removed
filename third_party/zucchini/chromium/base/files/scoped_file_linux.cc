#
include
"
base
/
files
/
scoped_file
.
h
"
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
<
dlfcn
.
h
>
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
atomic
>
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
debug
/
stack_trace
.
h
"
#
include
"
base
/
immediate_crash
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
strings
/
string_piece
.
h
"
namespace
{
const
int
kMaxTrackedFds
=
4096
;
std
:
:
atomic_bool
g_is_ownership_enforced
{
false
}
;
std
:
:
array
<
std
:
:
atomic_bool
kMaxTrackedFds
>
g_is_fd_owned
;
NOINLINE
void
CrashOnFdOwnershipViolation
(
)
{
RAW_LOG
(
ERROR
"
Crashing
due
to
FD
ownership
violation
:
\
n
"
)
;
base
:
:
debug
:
:
StackTrace
(
)
.
Print
(
)
;
base
:
:
ImmediateCrash
(
)
;
}
bool
CanTrack
(
int
fd
)
{
return
fd
>
=
0
&
&
fd
<
kMaxTrackedFds
;
}
void
UpdateAndCheckFdOwnership
(
int
fd
bool
owned
)
{
if
(
CanTrack
(
fd
)
&
&
g_is_fd_owned
[
static_cast
<
size_t
>
(
fd
)
]
.
exchange
(
owned
)
=
=
owned
&
&
g_is_ownership_enforced
)
{
CrashOnFdOwnershipViolation
(
)
;
}
}
}
#
endif
namespace
base
{
namespace
internal
{
void
ScopedFDCloseTraits
:
:
Acquire
(
const
ScopedFD
&
owner
int
fd
)
{
#
if
!
defined
(
MOZ_ZUCCHINI
)
UpdateAndCheckFdOwnership
(
fd
true
)
;
#
endif
}
void
ScopedFDCloseTraits
:
:
Release
(
const
ScopedFD
&
owner
int
fd
)
{
#
if
!
defined
(
MOZ_ZUCCHINI
)
UpdateAndCheckFdOwnership
(
fd
false
)
;
#
endif
}
}
#
if
!
defined
(
MOZ_ZUCCHINI
)
namespace
subtle
{
void
EnableFDOwnershipEnforcement
(
bool
enabled
)
{
g_is_ownership_enforced
=
enabled
;
}
void
ResetFDOwnership
(
)
{
std
:
:
fill
(
g_is_fd_owned
.
begin
(
)
g_is_fd_owned
.
end
(
)
false
)
;
}
}
bool
IsFDOwned
(
int
fd
)
{
return
CanTrack
(
fd
)
&
&
g_is_fd_owned
[
static_cast
<
size_t
>
(
fd
)
]
;
}
#
endif
}
#
if
!
defined
(
MOZ_ZUCCHINI
)
using
LibcCloseFuncPtr
=
int
(
*
)
(
int
)
;
LibcCloseFuncPtr
LoadCloseSymbol
(
)
{
#
if
defined
(
THREAD_SANITIZER
)
return
reinterpret_cast
<
LibcCloseFuncPtr
>
(
dlsym
(
RTLD_DEFAULT
"
__interceptor___close
"
)
)
;
#
else
return
reinterpret_cast
<
LibcCloseFuncPtr
>
(
dlsym
(
RTLD_NEXT
"
close
"
)
)
;
#
endif
}
extern
"
C
"
{
NO_SANITIZE
(
"
cfi
-
icall
"
)
__attribute__
(
(
visibility
(
"
default
"
)
noinline
)
)
int
close
(
int
fd
)
{
static
LibcCloseFuncPtr
libc_close
=
LoadCloseSymbol
(
)
;
if
(
base
:
:
IsFDOwned
(
fd
)
&
&
g_is_ownership_enforced
)
CrashOnFdOwnershipViolation
(
)
;
if
(
libc_close
=
=
nullptr
)
{
RAW_LOG
(
ERROR
"
close
symbol
missing
\
n
"
)
;
base
:
:
ImmediateCrash
(
)
;
}
return
libc_close
(
fd
)
;
}
}
#
endif
