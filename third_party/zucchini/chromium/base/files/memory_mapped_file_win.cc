#
include
"
base
/
files
/
memory_mapped_file
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
limits
>
#
include
<
string
>
#
include
"
base
/
files
/
file_path
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
numerics
/
checked_math
.
h
"
#
include
"
base
/
threading
/
scoped_blocking_call
.
h
"
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
win
/
pe_image
.
h
"
#
endif
#
include
<
windows
.
h
>
#
include
<
winnt
.
h
>
namespace
base
{
MemoryMappedFile
:
:
MemoryMappedFile
(
)
=
default
;
#
if
!
defined
(
MOZ_ZUCCHINI
)
bool
MemoryMappedFile
:
:
MapImageToMemory
(
Access
access
)
{
ScopedBlockingCall
scoped_blocking_call
(
FROM_HERE
BlockingType
:
:
MAY_BLOCK
)
;
if
(
!
file_
.
IsValid
(
)
)
return
false
;
file_mapping_
.
Set
(
:
:
CreateFileMapping
(
file_
.
GetPlatformFile
(
)
nullptr
PAGE_READONLY
|
SEC_IMAGE_NO_EXECUTE
0
0
NULL
)
)
;
if
(
!
file_mapping_
.
is_valid
(
)
)
return
false
;
data_
=
static_cast
<
uint8_t
*
>
(
:
:
MapViewOfFile
(
file_mapping_
.
get
(
)
FILE_MAP_READ
0
0
0
)
)
;
if
(
!
data_
)
return
false
;
base
:
:
win
:
:
PEImage
pe_image
(
data_
)
;
length_
=
pe_image
.
GetNTHeaders
(
)
-
>
OptionalHeader
.
SizeOfImage
;
return
true
;
}
#
endif
bool
MemoryMappedFile
:
:
MapFileRegionToMemory
(
const
MemoryMappedFile
:
:
Region
&
region
Access
access
)
{
ScopedBlockingCall
scoped_blocking_call
(
FROM_HERE
BlockingType
:
:
MAY_BLOCK
)
;
#
if
!
defined
(
MOZ_ZUCCHINI
)
DCHECK
(
access
!
=
READ_CODE_IMAGE
|
|
region
=
=
Region
:
:
kWholeFile
)
;
#
endif
if
(
!
file_
.
IsValid
(
)
)
return
false
;
DWORD
flags
=
0
;
ULARGE_INTEGER
size
=
{
}
;
switch
(
access
)
{
case
READ_ONLY
:
flags
|
=
PAGE_READONLY
;
break
;
case
READ_WRITE
:
flags
|
=
PAGE_READWRITE
;
break
;
case
READ_WRITE_EXTEND
:
flags
|
=
PAGE_READWRITE
;
size
.
QuadPart
=
region
.
size
;
break
;
#
if
!
defined
(
MOZ_ZUCCHINI
)
case
READ_CODE_IMAGE
:
return
MapImageToMemory
(
access
)
;
#
endif
}
file_mapping_
.
Set
(
:
:
CreateFileMapping
(
file_
.
GetPlatformFile
(
)
NULL
flags
size
.
HighPart
size
.
LowPart
NULL
)
)
;
if
(
!
file_mapping_
.
is_valid
(
)
)
return
false
;
ULARGE_INTEGER
map_start
=
{
}
;
SIZE_T
map_size
=
0
;
int32_t
data_offset
=
0
;
if
(
region
=
=
MemoryMappedFile
:
:
Region
:
:
kWholeFile
)
{
DCHECK_NE
(
READ_WRITE_EXTEND
access
)
;
int64_t
file_len
=
file_
.
GetLength
(
)
;
if
(
file_len
<
=
0
|
|
!
IsValueInRangeForNumericType
<
size_t
>
(
file_len
)
)
return
false
;
length_
=
static_cast
<
size_t
>
(
file_len
)
;
}
else
{
int64_t
aligned_start
=
0
;
size_t
ignored
=
0U
;
CalculateVMAlignedBoundaries
(
region
.
offset
region
.
size
&
aligned_start
&
ignored
&
data_offset
)
;
base
:
:
CheckedNumeric
<
SIZE_T
>
full_map_size
=
region
.
size
;
full_map_size
+
=
data_offset
;
if
(
aligned_start
<
0
|
|
!
full_map_size
.
IsValid
(
)
)
{
DLOG
(
ERROR
)
<
<
"
Region
bounds
are
not
valid
for
MapViewOfFile
"
;
return
false
;
}
map_start
.
QuadPart
=
static_cast
<
uint64_t
>
(
aligned_start
)
;
map_size
=
full_map_size
.
ValueOrDie
(
)
;
length_
=
region
.
size
;
}
data_
=
static_cast
<
uint8_t
*
>
(
:
:
MapViewOfFile
(
file_mapping_
.
get
(
)
(
flags
&
PAGE_READONLY
)
?
FILE_MAP_READ
:
FILE_MAP_WRITE
map_start
.
HighPart
map_start
.
LowPart
map_size
)
)
;
if
(
data_
=
=
nullptr
)
return
false
;
data_
+
=
data_offset
;
return
true
;
}
void
MemoryMappedFile
:
:
CloseHandles
(
)
{
if
(
data_
)
:
:
UnmapViewOfFile
(
data_
)
;
if
(
file_mapping_
.
is_valid
(
)
)
file_mapping_
.
Close
(
)
;
if
(
file_
.
IsValid
(
)
)
file_
.
Close
(
)
;
data_
=
nullptr
;
length_
=
0
;
}
}
