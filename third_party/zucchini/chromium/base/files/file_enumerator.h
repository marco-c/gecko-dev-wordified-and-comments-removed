#
ifndef
BASE_FILES_FILE_ENUMERATOR_H_
#
define
BASE_FILES_FILE_ENUMERATOR_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
vector
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
containers
/
stack
.
h
"
#
include
"
base
/
files
/
file
.
h
"
#
include
"
base
/
files
/
file_path
.
h
"
#
include
"
base
/
functional
/
function_ref
.
h
"
#
include
"
base
/
time
/
time
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
BUILDFLAG
(
IS_WIN
)
#
include
"
base
/
win
/
windows_types
.
h
"
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
#
include
<
sys
/
stat
.
h
>
#
include
<
unistd
.
h
>
#
include
<
unordered_set
>
#
endif
namespace
base
{
class
BASE_EXPORT
FileEnumerator
{
public
:
class
BASE_EXPORT
FileInfo
{
public
:
FileInfo
(
)
;
~
FileInfo
(
)
;
bool
IsDirectory
(
)
const
;
FilePath
GetName
(
)
const
;
int64_t
GetSize
(
)
const
;
Time
GetLastModifiedTime
(
)
const
;
#
if
BUILDFLAG
(
IS_WIN
)
const
WIN32_FIND_DATA
&
find_data
(
)
const
{
return
*
ChromeToWindowsType
(
&
find_data_
)
;
}
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
const
stat_wrapper_t
&
stat
(
)
const
{
return
stat_
;
}
#
endif
private
:
friend
class
FileEnumerator
;
#
if
BUILDFLAG
(
IS_WIN
)
CHROME_WIN32_FIND_DATA
find_data_
;
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
stat_wrapper_t
stat_
;
FilePath
filename_
;
#
endif
}
;
enum
FileType
{
FILES
=
1
<
<
0
DIRECTORIES
=
1
<
<
1
INCLUDE_DOT_DOT
=
1
<
<
2
NAMES_ONLY
=
1
<
<
3
#
if
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
SHOW_SYM_LINKS
=
1
<
<
4
#
endif
}
;
enum
class
FolderSearchPolicy
{
MATCH_ONLY
ALL
}
;
enum
class
ErrorPolicy
{
IGNORE_ERRORS
STOP_ENUMERATION
}
;
FileEnumerator
(
const
FilePath
&
root_path
bool
recursive
int
file_type
)
;
FileEnumerator
(
const
FilePath
&
root_path
bool
recursive
int
file_type
const
FilePath
:
:
StringType
&
pattern
)
;
FileEnumerator
(
const
FilePath
&
root_path
bool
recursive
int
file_type
const
FilePath
:
:
StringType
&
pattern
FolderSearchPolicy
folder_search_policy
)
;
FileEnumerator
(
const
FilePath
&
root_path
bool
recursive
int
file_type
const
FilePath
:
:
StringType
&
pattern
FolderSearchPolicy
folder_search_policy
ErrorPolicy
error_policy
)
;
FileEnumerator
(
const
FileEnumerator
&
)
=
delete
;
FileEnumerator
&
operator
=
(
const
FileEnumerator
&
)
=
delete
;
~
FileEnumerator
(
)
;
void
ForEach
(
FunctionRef
<
void
(
const
FilePath
&
path
)
>
ref
)
;
FilePath
Next
(
)
;
FileInfo
GetInfo
(
)
const
;
File
:
:
Error
GetError
(
)
const
{
return
error_
;
}
private
:
bool
ShouldSkip
(
const
FilePath
&
path
)
;
bool
IsTypeMatched
(
bool
is_dir
)
const
;
bool
IsPatternMatched
(
const
FilePath
&
src
)
const
;
#
if
BUILDFLAG
(
IS_WIN
)
const
WIN32_FIND_DATA
&
find_data
(
)
const
{
return
*
ChromeToWindowsType
(
&
find_data_
)
;
}
bool
has_find_data_
=
false
;
CHROME_WIN32_FIND_DATA
find_data_
;
HANDLE
find_handle_
=
INVALID_HANDLE_VALUE
;
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
std
:
:
vector
<
FileInfo
>
directory_entries_
;
std
:
:
unordered_set
<
decltype
(
stat_wrapper_t
:
:
st_ino
)
>
visited_directories_
;
size_t
current_directory_entry_
;
#
endif
FilePath
root_path_
;
const
bool
recursive_
;
int
file_type_
;
FilePath
:
:
StringType
pattern_
;
const
FolderSearchPolicy
folder_search_policy_
;
const
ErrorPolicy
error_policy_
;
File
:
:
Error
error_
=
File
:
:
FILE_OK
;
base
:
:
stack
<
FilePath
>
pending_paths_
;
}
;
}
#
endif
