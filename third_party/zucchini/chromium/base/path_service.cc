#
include
"
base
/
path_service
.
h
"
#
include
<
unordered_map
>
#
include
<
utility
>
#
include
"
base
/
check_op
.
h
"
#
include
"
base
/
files
/
file_path
.
h
"
#
include
"
base
/
files
/
file_util
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
base
/
memory
/
raw_ptr_exclusion
.
h
"
#
include
"
base
/
synchronization
/
lock
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
BUILDFLAG
(
IS_WIN
)
#
include
<
windows
.
h
>
#
include
<
shellapi
.
h
>
#
include
<
shlobj
.
h
>
#
endif
namespace
base
{
bool
PathProvider
(
int
key
FilePath
*
result
)
;
#
if
BUILDFLAG
(
IS_WIN
)
bool
PathProviderWin
(
int
key
FilePath
*
result
)
;
#
elif
BUILDFLAG
(
IS_MAC
)
bool
PathProviderMac
(
int
key
FilePath
*
result
)
;
#
elif
BUILDFLAG
(
IS_IOS
)
bool
PathProviderIOS
(
int
key
FilePath
*
result
)
;
#
elif
BUILDFLAG
(
IS_ANDROID
)
bool
PathProviderAndroid
(
int
key
FilePath
*
result
)
;
#
elif
BUILDFLAG
(
IS_FUCHSIA
)
bool
PathProviderFuchsia
(
int
key
FilePath
*
result
)
;
#
elif
BUILDFLAG
(
IS_POSIX
)
bool
PathProviderPosix
(
int
key
FilePath
*
result
)
;
#
endif
namespace
{
typedef
std
:
:
unordered_map
<
int
FilePath
>
PathMap
;
struct
Provider
{
PathService
:
:
ProviderFunc
func
;
RAW_PTR_EXCLUSION
struct
Provider
*
next
;
#
ifndef
NDEBUG
int
key_start
;
int
key_end
;
#
endif
bool
is_static
;
}
;
Provider
base_provider
=
{
PathProvider
nullptr
#
ifndef
NDEBUG
PATH_START
PATH_END
#
endif
true
}
;
#
if
BUILDFLAG
(
IS_WIN
)
Provider
base_provider_win
=
{
PathProviderWin
&
base_provider
#
ifndef
NDEBUG
PATH_WIN_START
PATH_WIN_END
#
endif
true
}
;
#
endif
#
if
BUILDFLAG
(
IS_MAC
)
Provider
base_provider_mac
=
{
PathProviderMac
&
base_provider
#
ifndef
NDEBUG
PATH_MAC_START
PATH_MAC_END
#
endif
true
}
;
#
endif
#
if
BUILDFLAG
(
IS_IOS
)
Provider
base_provider_ios
=
{
PathProviderIOS
&
base_provider
#
ifndef
NDEBUG
PATH_IOS_START
PATH_IOS_END
#
endif
true
}
;
#
endif
#
if
BUILDFLAG
(
IS_ANDROID
)
Provider
base_provider_android
=
{
PathProviderAndroid
&
base_provider
#
ifndef
NDEBUG
PATH_ANDROID_START
PATH_ANDROID_END
#
endif
true
}
;
#
endif
#
if
BUILDFLAG
(
IS_FUCHSIA
)
Provider
base_provider_fuchsia
=
{
PathProviderFuchsia
&
base_provider
#
ifndef
NDEBUG
0
0
#
endif
true
}
;
#
endif
#
if
BUILDFLAG
(
IS_POSIX
)
&
&
!
BUILDFLAG
(
IS_APPLE
)
&
&
!
BUILDFLAG
(
IS_ANDROID
)
Provider
base_provider_posix
=
{
PathProviderPosix
&
base_provider
#
ifndef
NDEBUG
PATH_POSIX_START
PATH_POSIX_END
#
endif
true
}
;
#
endif
struct
PathData
{
Lock
lock
;
PathMap
cache
;
PathMap
overrides
;
raw_ptr
<
Provider
>
providers
;
bool
cache_disabled
;
PathData
(
)
:
cache_disabled
(
false
)
{
#
if
BUILDFLAG
(
IS_WIN
)
providers
=
&
base_provider_win
;
#
elif
BUILDFLAG
(
IS_MAC
)
providers
=
&
base_provider_mac
;
#
elif
BUILDFLAG
(
IS_IOS
)
providers
=
&
base_provider_ios
;
#
elif
BUILDFLAG
(
IS_ANDROID
)
providers
=
&
base_provider_android
;
#
elif
BUILDFLAG
(
IS_FUCHSIA
)
providers
=
&
base_provider_fuchsia
;
#
elif
BUILDFLAG
(
IS_POSIX
)
providers
=
&
base_provider_posix
;
#
endif
}
}
;
static
PathData
*
GetPathData
(
)
{
static
auto
*
path_data
=
new
PathData
(
)
;
return
path_data
;
}
bool
LockedGetFromCache
(
int
key
const
PathData
*
path_data
FilePath
*
result
)
EXCLUSIVE_LOCKS_REQUIRED
(
path_data
-
>
lock
)
{
if
(
path_data
-
>
cache_disabled
)
return
false
;
auto
it
=
path_data
-
>
cache
.
find
(
key
)
;
if
(
it
!
=
path_data
-
>
cache
.
end
(
)
)
{
*
result
=
it
-
>
second
;
return
true
;
}
return
false
;
}
bool
LockedGetFromOverrides
(
int
key
PathData
*
path_data
FilePath
*
result
)
EXCLUSIVE_LOCKS_REQUIRED
(
path_data
-
>
lock
)
{
PathMap
:
:
const_iterator
it
=
path_data
-
>
overrides
.
find
(
key
)
;
if
(
it
!
=
path_data
-
>
overrides
.
end
(
)
)
{
if
(
!
path_data
-
>
cache_disabled
)
path_data
-
>
cache
[
key
]
=
it
-
>
second
;
*
result
=
it
-
>
second
;
return
true
;
}
return
false
;
}
}
bool
PathService
:
:
Get
(
int
key
FilePath
*
result
)
{
PathData
*
path_data
=
GetPathData
(
)
;
DCHECK
(
path_data
)
;
DCHECK
(
result
)
;
DCHECK_GT
(
key
PATH_START
)
;
if
(
key
=
=
DIR_CURRENT
)
return
GetCurrentDirectory
(
result
)
;
Provider
*
provider
=
nullptr
;
{
AutoLock
scoped_lock
(
path_data
-
>
lock
)
;
if
(
LockedGetFromCache
(
key
path_data
result
)
)
return
true
;
if
(
LockedGetFromOverrides
(
key
path_data
result
)
)
return
true
;
provider
=
path_data
-
>
providers
;
}
FilePath
path
;
while
(
provider
)
{
if
(
provider
-
>
func
(
key
&
path
)
)
break
;
DCHECK
(
path
.
empty
(
)
)
<
<
"
provider
should
not
have
modified
path
"
;
provider
=
provider
-
>
next
;
}
if
(
path
.
empty
(
)
)
return
false
;
if
(
path
.
ReferencesParent
(
)
)
{
path
=
MakeAbsoluteFilePath
(
path
)
;
if
(
path
.
empty
(
)
)
return
false
;
}
*
result
=
path
;
AutoLock
scoped_lock
(
path_data
-
>
lock
)
;
if
(
!
path_data
-
>
cache_disabled
)
path_data
-
>
cache
[
key
]
=
path
;
return
true
;
}
FilePath
PathService
:
:
CheckedGet
(
int
key
)
{
FilePath
path
;
LOG_IF
(
FATAL
!
Get
(
key
&
path
)
)
<
<
"
Failed
to
get
the
path
for
"
<
<
key
;
return
path
;
}
bool
PathService
:
:
Override
(
int
key
const
FilePath
&
path
)
{
return
OverrideAndCreateIfNeeded
(
key
path
false
true
)
;
}
bool
PathService
:
:
OverrideAndCreateIfNeeded
(
int
key
const
FilePath
&
path
bool
is_absolute
bool
create
)
{
PathData
*
path_data
=
GetPathData
(
)
;
DCHECK
(
path_data
)
;
DCHECK_GT
(
key
PATH_START
)
<
<
"
invalid
path
key
"
;
FilePath
file_path
=
path
;
if
(
create
&
&
!
CreateDirectory
(
file_path
)
)
{
return
false
;
}
if
(
!
is_absolute
)
{
file_path
=
MakeAbsoluteFilePath
(
file_path
)
;
if
(
file_path
.
empty
(
)
)
return
false
;
}
DCHECK
(
file_path
.
IsAbsolute
(
)
)
;
AutoLock
scoped_lock
(
path_data
-
>
lock
)
;
path_data
-
>
cache
.
clear
(
)
;
path_data
-
>
overrides
[
key
]
=
std
:
:
move
(
file_path
)
;
return
true
;
}
bool
PathService
:
:
RemoveOverrideForTests
(
int
key
)
{
PathData
*
path_data
=
GetPathData
(
)
;
DCHECK
(
path_data
)
;
AutoLock
scoped_lock
(
path_data
-
>
lock
)
;
if
(
path_data
-
>
overrides
.
find
(
key
)
=
=
path_data
-
>
overrides
.
end
(
)
)
return
false
;
path_data
-
>
cache
.
clear
(
)
;
path_data
-
>
overrides
.
erase
(
key
)
;
return
true
;
}
bool
PathService
:
:
IsOverriddenForTests
(
int
key
)
{
PathData
*
path_data
=
GetPathData
(
)
;
DCHECK
(
path_data
)
;
AutoLock
scoped_lock
(
path_data
-
>
lock
)
;
return
path_data
-
>
overrides
.
find
(
key
)
!
=
path_data
-
>
overrides
.
end
(
)
;
}
void
PathService
:
:
RegisterProvider
(
ProviderFunc
func
int
key_start
int
key_end
)
{
PathData
*
path_data
=
GetPathData
(
)
;
DCHECK
(
path_data
)
;
DCHECK_GT
(
key_end
key_start
)
;
Provider
*
p
;
p
=
new
Provider
;
p
-
>
is_static
=
false
;
p
-
>
func
=
func
;
#
ifndef
NDEBUG
p
-
>
key_start
=
key_start
;
p
-
>
key_end
=
key_end
;
#
endif
AutoLock
scoped_lock
(
path_data
-
>
lock
)
;
#
ifndef
NDEBUG
Provider
*
iter
=
path_data
-
>
providers
;
while
(
iter
)
{
DCHECK
(
key_start
>
=
iter
-
>
key_end
|
|
key_end
<
=
iter
-
>
key_start
)
<
<
"
path
provider
collision
"
;
iter
=
iter
-
>
next
;
}
#
endif
p
-
>
next
=
path_data
-
>
providers
;
path_data
-
>
providers
=
p
;
}
void
PathService
:
:
DisableCache
(
)
{
PathData
*
path_data
=
GetPathData
(
)
;
DCHECK
(
path_data
)
;
AutoLock
scoped_lock
(
path_data
-
>
lock
)
;
path_data
-
>
cache
.
clear
(
)
;
path_data
-
>
cache_disabled
=
true
;
}
}
