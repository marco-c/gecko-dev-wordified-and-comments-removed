#
ifndef
BASE_COMMAND_LINE_H_
#
define
BASE_COMMAND_LINE_H_
#
include
<
stddef
.
h
>
#
include
<
functional
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
containers
/
span
.
h
"
#
include
"
base
/
debug
/
debugging_buildflags
.
h
"
#
include
"
base
/
strings
/
string_piece
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
BUILDFLAG
(
ENABLE_COMMANDLINE_SEQUENCE_CHECKS
)
#
include
"
base
/
sequence_checker
.
h
"
#
endif
namespace
base
{
class
DuplicateSwitchHandler
;
class
FilePath
;
class
BASE_EXPORT
CommandLine
{
public
:
#
if
BUILDFLAG
(
IS_WIN
)
using
StringType
=
std
:
:
wstring
;
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
using
StringType
=
std
:
:
string
;
#
endif
using
CharType
=
StringType
:
:
value_type
;
using
StringPieceType
=
base
:
:
BasicStringPiece
<
CharType
>
;
using
StringVector
=
std
:
:
vector
<
StringType
>
;
using
SwitchMap
=
std
:
:
map
<
std
:
:
string
StringType
std
:
:
less
<
>
>
;
enum
NoProgram
{
NO_PROGRAM
}
;
explicit
CommandLine
(
NoProgram
no_program
)
;
explicit
CommandLine
(
const
FilePath
&
program
)
;
CommandLine
(
int
argc
const
CharType
*
const
*
argv
)
;
explicit
CommandLine
(
const
StringVector
&
argv
)
;
CommandLine
(
const
CommandLine
&
other
)
;
CommandLine
&
operator
=
(
const
CommandLine
&
other
)
;
~
CommandLine
(
)
;
#
if
BUILDFLAG
(
IS_WIN
)
static
void
set_slash_is_not_a_switch
(
)
;
static
void
InitUsingArgvForTesting
(
int
argc
const
char
*
const
*
argv
)
;
#
endif
static
bool
Init
(
int
argc
const
char
*
const
*
argv
)
;
static
void
Reset
(
)
;
static
CommandLine
*
ForCurrentProcess
(
)
;
static
bool
InitializedForCurrentProcess
(
)
;
#
if
BUILDFLAG
(
IS_WIN
)
static
CommandLine
FromString
(
StringPieceType
command_line
)
;
#
endif
void
InitFromArgv
(
int
argc
const
CharType
*
const
*
argv
)
;
void
InitFromArgv
(
const
StringVector
&
argv
)
;
StringType
GetCommandLineString
(
)
const
;
#
if
BUILDFLAG
(
IS_WIN
)
static
std
:
:
wstring
QuoteForCommandLineToArgvW
(
const
std
:
:
wstring
&
arg
)
;
StringType
GetCommandLineStringForShell
(
)
const
;
StringType
GetCommandLineStringWithUnsafeInsertSequences
(
)
const
;
#
endif
StringType
GetArgumentsString
(
)
const
;
const
StringVector
&
argv
(
)
const
{
return
argv_
;
}
FilePath
GetProgram
(
)
const
;
void
SetProgram
(
const
FilePath
&
program
)
;
bool
HasSwitch
(
StringPiece
switch_string
)
const
;
bool
HasSwitch
(
const
char
switch_constant
[
]
)
const
;
std
:
:
string
GetSwitchValueASCII
(
StringPiece
switch_string
)
const
;
FilePath
GetSwitchValuePath
(
StringPiece
switch_string
)
const
;
StringType
GetSwitchValueNative
(
StringPiece
switch_string
)
const
;
const
SwitchMap
&
GetSwitches
(
)
const
{
return
switches_
;
}
void
AppendSwitch
(
StringPiece
switch_string
)
;
void
AppendSwitchPath
(
StringPiece
switch_string
const
FilePath
&
path
)
;
void
AppendSwitchNative
(
StringPiece
switch_string
StringPieceType
value
)
;
void
AppendSwitchASCII
(
StringPiece
switch_string
StringPiece
value
)
;
void
RemoveSwitch
(
const
base
:
:
StringPiece
switch_key_without_prefix
)
;
void
CopySwitchesFrom
(
const
CommandLine
&
source
span
<
const
char
*
const
>
switches
)
;
StringVector
GetArgs
(
)
const
;
void
AppendArg
(
StringPiece
value
)
;
void
AppendArgPath
(
const
FilePath
&
value
)
;
void
AppendArgNative
(
StringPieceType
value
)
;
void
AppendArguments
(
const
CommandLine
&
other
bool
include_program
)
;
void
PrependWrapper
(
StringPieceType
wrapper
)
;
#
if
BUILDFLAG
(
IS_WIN
)
void
ParseFromString
(
StringPieceType
command_line
)
;
bool
HasSingleArgumentSwitch
(
)
const
{
return
has_single_argument_switch_
;
}
#
endif
void
DetachFromCurrentSequence
(
)
;
static
void
SetDuplicateSwitchHandler
(
std
:
:
unique_ptr
<
DuplicateSwitchHandler
>
)
;
private
:
#
if
BUILDFLAG
(
ENABLE_COMMANDLINE_SEQUENCE_CHECKS
)
class
InstanceBoundSequenceChecker
{
public
:
InstanceBoundSequenceChecker
(
)
=
default
;
InstanceBoundSequenceChecker
(
const
InstanceBoundSequenceChecker
&
other
)
{
}
InstanceBoundSequenceChecker
&
operator
=
(
const
InstanceBoundSequenceChecker
&
other
)
{
return
*
this
;
}
InstanceBoundSequenceChecker
(
InstanceBoundSequenceChecker
&
&
)
=
delete
;
InstanceBoundSequenceChecker
&
operator
=
(
InstanceBoundSequenceChecker
&
&
)
=
delete
;
void
Detach
(
)
{
DETACH_FROM_SEQUENCE
(
sequence_checker_
)
;
}
void
Check
(
)
{
DCHECK_CALLED_ON_VALID_SEQUENCE
(
sequence_checker_
)
;
}
private
:
SEQUENCE_CHECKER
(
sequence_checker_
)
;
}
;
#
endif
CommandLine
(
)
=
delete
;
void
AppendSwitchesAndArguments
(
const
StringVector
&
argv
)
;
StringType
GetArgumentsStringInternal
(
bool
allow_unsafe_insert_sequences
)
const
;
#
if
BUILDFLAG
(
IS_WIN
)
void
ParseAsSingleArgument
(
const
StringType
&
single_arg_switch_string
)
;
StringPieceType
raw_command_line_string_
;
bool
has_single_argument_switch_
=
false
;
#
endif
static
CommandLine
*
current_process_commandline_
;
StringVector
argv_
;
SwitchMap
switches_
;
ptrdiff_t
begin_args_
;
#
if
BUILDFLAG
(
ENABLE_COMMANDLINE_SEQUENCE_CHECKS
)
InstanceBoundSequenceChecker
sequence_checker_
;
#
endif
}
;
class
BASE_EXPORT
DuplicateSwitchHandler
{
public
:
virtual
void
ResolveDuplicate
(
base
:
:
StringPiece
key
CommandLine
:
:
StringPieceType
new_value
CommandLine
:
:
StringType
&
out_value
)
=
0
;
virtual
~
DuplicateSwitchHandler
(
)
=
default
;
}
;
}
#
endif
