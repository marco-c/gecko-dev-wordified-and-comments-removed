#
include
"
components
/
zucchini
/
buffer_source
.
h
"
#
include
"
base
/
ranges
/
algorithm
.
h
"
#
include
"
components
/
zucchini
/
algorithm
.
h
"
namespace
zucchini
{
BufferSource
:
:
BufferSource
(
const
ConstBufferView
&
buffer
)
:
ConstBufferView
(
buffer
)
{
}
BufferSource
:
:
BufferSource
(
const
ConstBufferView
&
buffer
size_type
offset
)
:
ConstBufferView
(
buffer
)
{
Skip
(
offset
)
;
}
bool
BufferSource
:
:
Skip
(
size_type
n
)
{
if
(
n
>
Remaining
(
)
)
{
remove_prefix
(
Remaining
(
)
)
;
return
false
;
}
remove_prefix
(
n
)
;
return
true
;
}
bool
BufferSource
:
:
CheckNextBytes
(
std
:
:
initializer_list
<
uint8_t
>
bytes
)
const
{
if
(
Remaining
(
)
<
bytes
.
size
(
)
)
{
return
false
;
}
return
base
:
:
ranges
:
:
mismatch
(
bytes
*
this
)
.
first
=
=
bytes
.
end
(
)
;
}
bool
BufferSource
:
:
ConsumeBytes
(
std
:
:
initializer_list
<
uint8_t
>
bytes
)
{
if
(
!
CheckNextBytes
(
bytes
)
)
{
return
false
;
}
remove_prefix
(
bytes
.
size
(
)
)
;
return
true
;
}
bool
BufferSource
:
:
GetRegion
(
size_type
count
ConstBufferView
*
buffer
)
{
DCHECK_NE
(
begin
(
)
nullptr
)
;
if
(
Remaining
(
)
<
count
)
{
return
false
;
}
*
buffer
=
ConstBufferView
(
begin
(
)
count
)
;
remove_prefix
(
count
)
;
return
true
;
}
bool
BufferSource
:
:
GetUleb128
(
uint32_t
*
ret
)
{
int
shift_lim
=
static_cast
<
int
>
(
std
:
:
min
<
size_type
>
(
kMaxLeb128Size
size
(
)
)
)
*
7
;
const_iterator
cur
=
cbegin
(
)
;
uint32_t
value
=
0U
;
for
(
int
shift
=
0
;
shift
<
shift_lim
;
shift
+
=
7
+
+
cur
)
{
uint32_t
b
=
*
cur
;
value
|
=
static_cast
<
uint32_t
>
(
b
&
0x7F
)
<
<
shift
;
if
(
!
(
b
&
0x80
)
)
{
*
ret
=
value
;
seek
(
cur
+
1
)
;
return
true
;
}
}
return
false
;
}
bool
BufferSource
:
:
GetSleb128
(
int32_t
*
ret
)
{
int
shift_lim
=
static_cast
<
int
>
(
std
:
:
min
<
size_type
>
(
kMaxLeb128Size
size
(
)
)
)
*
7
;
const_iterator
cur
=
cbegin
(
)
;
int32_t
value
=
0
;
for
(
int
shift
=
0
;
shift
<
shift_lim
;
shift
+
=
7
+
+
cur
)
{
uint32_t
b
=
*
cur
;
value
|
=
static_cast
<
int32_t
>
(
static_cast
<
uint32_t
>
(
b
&
0x7F
)
<
<
shift
)
;
if
(
!
(
b
&
0x80
)
)
{
*
ret
=
(
shift
=
=
28
)
?
value
:
SignExtend
(
shift
+
6
value
)
;
seek
(
cur
+
1
)
;
return
true
;
}
}
return
false
;
}
bool
BufferSource
:
:
SkipLeb128
(
)
{
int
lim
=
static_cast
<
int
>
(
std
:
:
min
<
size_type
>
(
kMaxLeb128Size
size
(
)
)
)
;
const_iterator
cur
=
cbegin
(
)
;
for
(
int
i
=
0
;
i
<
lim
;
+
+
i
+
+
cur
)
{
if
(
!
(
*
cur
&
0x80
)
)
{
seek
(
cur
+
1
)
;
return
true
;
}
}
return
false
;
}
}
