#
ifndef
COMPONENTS_ZUCCHINI_BUFFER_SOURCE_H_
#
define
COMPONENTS_ZUCCHINI_BUFFER_SOURCE_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
initializer_list
>
#
include
<
type_traits
>
#
include
"
base
/
check_op
.
h
"
#
include
"
components
/
zucchini
/
buffer_view
.
h
"
namespace
zucchini
{
class
BufferSource
:
public
ConstBufferView
{
public
:
enum
:
size_t
{
kMaxLeb128Size
=
5
}
;
static
BufferSource
FromRange
(
const_iterator
first
const_iterator
last
)
{
return
BufferSource
(
ConstBufferView
:
:
FromRange
(
first
last
)
)
;
}
using
ConstBufferView
:
:
ConstBufferView
;
BufferSource
(
)
=
default
;
explicit
BufferSource
(
const
ConstBufferView
&
buffer
)
;
BufferSource
(
const
ConstBufferView
&
buffer
size_type
offset
)
;
BufferSource
(
const
BufferSource
&
)
=
default
;
BufferSource
&
operator
=
(
BufferSource
&
&
)
=
default
;
bool
Skip
(
size_type
n
)
;
template
<
class
T
>
bool
CheckNextValue
(
const
T
&
value
)
const
{
static_assert
(
std
:
:
is_integral
<
T
>
:
:
value
"
Value
type
must
be
an
integral
type
"
)
;
DCHECK_NE
(
begin
(
)
nullptr
)
;
if
(
Remaining
(
)
<
sizeof
(
T
)
)
{
return
false
;
}
T
next_value
=
{
}
;
:
:
memcpy
(
&
next_value
begin
(
)
sizeof
(
T
)
)
;
return
value
=
=
next_value
;
}
bool
CheckNextBytes
(
std
:
:
initializer_list
<
uint8_t
>
bytes
)
const
;
bool
ConsumeBytes
(
std
:
:
initializer_list
<
uint8_t
>
bytes
)
;
template
<
class
T
>
bool
GetValue
(
T
*
value
)
{
static_assert
(
std
:
:
is_standard_layout
<
T
>
:
:
value
"
Value
type
must
be
a
standard
layout
type
"
)
;
DCHECK_NE
(
begin
(
)
nullptr
)
;
if
(
Remaining
(
)
<
sizeof
(
T
)
)
{
return
false
;
}
:
:
memcpy
(
value
begin
(
)
sizeof
(
T
)
)
;
remove_prefix
(
sizeof
(
T
)
)
;
return
true
;
}
template
<
class
T
>
const
T
*
GetPointer
(
)
{
static_assert
(
std
:
:
is_standard_layout
<
T
>
:
:
value
"
Value
type
must
be
a
standard
layout
type
"
)
;
static_assert
(
alignof
(
T
)
=
=
1
"
Value
type
requires
byte
alignment
"
)
;
DCHECK_NE
(
begin
(
)
nullptr
)
;
if
(
Remaining
(
)
<
sizeof
(
T
)
)
{
return
nullptr
;
}
const
T
*
ptr
=
reinterpret_cast
<
const
T
*
>
(
begin
(
)
)
;
remove_prefix
(
sizeof
(
T
)
)
;
return
ptr
;
}
template
<
class
T
>
const
T
*
GetArray
(
size_t
count
)
{
static_assert
(
std
:
:
is_standard_layout
<
T
>
:
:
value
"
Value
type
must
be
a
standard
layout
type
"
)
;
static_assert
(
alignof
(
T
)
=
=
1
"
Value
type
requires
byte
alignment
"
)
;
if
(
Remaining
(
)
/
sizeof
(
T
)
<
count
)
{
return
nullptr
;
}
const
T
*
array
=
reinterpret_cast
<
const
T
*
>
(
begin
(
)
)
;
remove_prefix
(
count
*
sizeof
(
T
)
)
;
return
array
;
}
bool
GetRegion
(
size_type
size
ConstBufferView
*
buffer
)
;
bool
GetUleb128
(
uint32_t
*
value
)
;
bool
GetSleb128
(
int32_t
*
value
)
;
bool
SkipLeb128
(
)
;
size_type
Remaining
(
)
const
{
return
size
(
)
;
}
}
;
}
#
endif
