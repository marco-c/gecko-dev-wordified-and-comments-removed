#
include
"
components
/
zucchini
/
reloc_elf
.
h
"
#
include
<
stdint
.
h
>
#
include
<
memory
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
base
/
numerics
/
safe_conversions
.
h
"
#
include
"
base
/
ranges
/
algorithm
.
h
"
#
include
"
components
/
zucchini
/
address_translator
.
h
"
#
include
"
components
/
zucchini
/
algorithm
.
h
"
#
include
"
components
/
zucchini
/
disassembler_elf
.
h
"
#
include
"
components
/
zucchini
/
image_utils
.
h
"
#
include
"
components
/
zucchini
/
test_utils
.
h
"
#
include
"
components
/
zucchini
/
type_elf
.
h
"
#
include
"
testing
/
gtest
/
include
/
gtest
/
gtest
.
h
"
namespace
zucchini
{
namespace
{
template
<
class
Elf_Shdr
>
SectionDimensionsElf
MakeSectionDimensions
(
const
BufferRegion
&
region
offset_t
entry_size
)
{
using
sh_offset_t
=
decltype
(
Elf_Shdr
:
:
sh_offset
)
;
using
sh_size_t
=
decltype
(
Elf_Shdr
:
:
sh_size
)
;
using
sh_entsize_t
=
decltype
(
Elf_Shdr
:
:
sh_entsize
)
;
return
SectionDimensionsElf
{
Elf_Shdr
{
0
0
0
0
base
:
:
checked_cast
<
sh_offset_t
>
(
region
.
offset
)
base
:
:
checked_cast
<
sh_size_t
>
(
region
.
size
)
0
0
0
base
:
:
checked_cast
<
sh_entsize_t
>
(
entry_size
)
}
}
;
}
template
<
class
ELF_INTEL_TRAITS
>
class
FakeImageWithReloc
{
public
:
using
ElfIntelTraits
=
ELF_INTEL_TRAITS
;
struct
RelocSpec
{
offset_t
start
;
std
:
:
vector
<
uint8_t
>
data
;
}
;
FakeImageWithReloc
(
size_t
image_size
rva_t
base_rva
const
std
:
:
vector
<
RelocSpec
>
&
reloc_specs
)
:
image_data_
(
image_size
0xFF
)
mutable_image_
(
&
image_data_
[
0
]
image_data_
.
size
(
)
)
{
translator_
.
Initialize
(
{
{
0
static_cast
<
offset_t
>
(
image_size
)
base_rva
static_cast
<
rva_t
>
(
image_size
)
}
}
)
;
for
(
const
RelocSpec
&
reloc_spec
:
reloc_specs
)
{
BufferRegion
reloc_region
=
{
reloc_spec
.
start
reloc_spec
.
data
.
size
(
)
}
;
base
:
:
ranges
:
:
copy
(
reloc_spec
.
data
image_data_
.
begin
(
)
+
reloc_region
.
lo
(
)
)
;
section_dimensions_
.
emplace_back
(
MakeSectionDimensions
<
typename
ElfIntelTraits
:
:
Elf_Shdr
>
(
reloc_region
ElfIntelTraits
:
:
kVAWidth
)
)
;
reloc_regions_
.
push_back
(
reloc_region
)
;
}
}
std
:
:
vector
<
Reference
>
ExtractRelocReferences
(
)
{
const
size_t
image_size
=
image_data_
.
size
(
)
;
ConstBufferView
image
=
{
image_data_
.
data
(
)
image_size
}
;
auto
reader
=
std
:
:
make_unique
<
RelocReaderElf
>
(
image
ElfIntelTraits
:
:
kBitness
section_dimensions_
ElfIntelTraits
:
:
kRelType
0
image_size
translator_
)
;
std
:
:
vector
<
Reference
>
refs
;
for
(
absl
:
:
optional
<
Reference
>
ref
=
reader
-
>
GetNext
(
)
;
ref
.
has_value
(
)
;
ref
=
reader
-
>
GetNext
(
)
)
{
refs
.
push_back
(
ref
.
value
(
)
)
;
}
return
refs
;
}
std
:
:
unique_ptr
<
RelocWriterElf
>
MakeRelocWriter
(
)
{
return
std
:
:
move
(
std
:
:
make_unique
<
RelocWriterElf
>
(
mutable_image_
ElfIntelTraits
:
:
kBitness
translator_
)
)
;
}
std
:
:
vector
<
uint8_t
>
GetRawRelocData
(
int
reloc_index
)
{
BufferRegion
reloc_region
=
reloc_regions_
[
reloc_index
]
;
return
Sub
(
image_data_
reloc_region
.
lo
(
)
reloc_region
.
hi
(
)
)
;
}
private
:
std
:
:
vector
<
uint8_t
>
image_data_
;
MutableBufferView
mutable_image_
;
std
:
:
vector
<
BufferRegion
>
reloc_regions_
;
std
:
:
vector
<
SectionDimensionsElf
>
section_dimensions_
;
AddressTranslator
translator_
;
}
;
}
TEST
(
RelocElfTest
ReadWrite32
)
{
constexpr
size_t
kImageSize
=
0x3000
;
constexpr
rva_t
kBaseRva
=
0x40000
;
constexpr
offset_t
kRelocStart0
=
0x600
;
std
:
:
vector
<
uint8_t
>
reloc_data0
=
ParseHexString
(
"
C0
10
04
00
08
00
00
00
"
"
F8
10
04
00
08
AB
CD
EF
"
"
00
10
04
00
00
AB
CD
EF
"
"
00
10
04
00
07
AB
CD
EF
"
)
;
constexpr
offset_t
kRelocStart1
=
0x620
;
std
:
:
vector
<
uint8_t
>
reloc_data1
=
ParseHexString
(
"
BC
20
04
00
08
00
00
00
"
"
A0
20
04
00
08
AB
CD
EF
"
)
;
FakeImageWithReloc
<
Elf32IntelTraits
>
fake_image
(
kImageSize
kBaseRva
{
{
kRelocStart0
reloc_data0
}
{
kRelocStart1
reloc_data1
}
}
)
;
std
:
:
vector
<
Reference
>
exp_refs
{
{
0x600
0x10C0
}
{
0x608
0x10F8
}
{
0x620
0x20BC
}
{
0x628
0x20A0
}
}
;
EXPECT_EQ
(
exp_refs
fake_image
.
ExtractRelocReferences
(
)
)
;
std
:
:
unique_ptr
<
RelocWriterElf
>
writer
=
fake_image
.
MakeRelocWriter
(
)
;
writer
-
>
PutNext
(
{
0x608
0x1F83
}
)
;
std
:
:
vector
<
uint8_t
>
exp_reloc_data0
=
ParseHexString
(
"
C0
10
04
00
08
00
00
00
"
"
83
1F
04
00
08
AB
CD
EF
"
"
00
10
04
00
00
AB
CD
EF
"
"
00
10
04
00
07
AB
CD
EF
"
)
;
EXPECT_EQ
(
exp_reloc_data0
fake_image
.
GetRawRelocData
(
0
)
)
;
writer
-
>
PutNext
(
{
0x628
0x2950
}
)
;
std
:
:
vector
<
uint8_t
>
exp_reloc_data1
=
ParseHexString
(
"
BC
20
04
00
08
00
00
00
"
"
50
29
04
00
08
AB
CD
EF
"
)
;
EXPECT_EQ
(
exp_reloc_data1
fake_image
.
GetRawRelocData
(
1
)
)
;
}
TEST
(
RelocElfTest
Limit32
)
{
constexpr
size_t
kImageSize
=
0x3000
;
constexpr
offset_t
kBaseRva
=
0x40000
;
constexpr
offset_t
kRelocStart
=
0x600
;
std
:
:
vector
<
uint8_t
>
reloc_data
=
ParseHexString
(
"
00
00
04
00
08
00
00
00
"
"
00
10
04
00
08
00
00
00
"
"
F0
2F
04
00
08
00
00
00
"
"
F8
2F
04
00
08
00
00
00
"
"
FC
2F
04
00
08
00
00
00
"
"
FD
2F
04
00
08
00
00
00
"
"
FE
2F
04
00
08
00
00
00
"
"
FF
2F
04
00
08
00
00
00
"
"
00
30
04
00
08
00
00
00
"
"
01
30
04
00
08
00
00
00
"
"
FC
FF
FF
7F
08
00
00
00
"
"
FE
FF
FF
7F
08
00
00
00
"
"
00
00
00
80
08
00
00
00
"
"
FC
FF
FF
FF
08
00
00
00
"
"
FF
FF
FF
FF
08
00
00
00
"
"
34
12
04
00
08
00
00
00
"
)
;
FakeImageWithReloc
<
Elf32IntelTraits
>
fake_image
(
kImageSize
kBaseRva
{
{
kRelocStart
reloc_data
}
}
)
;
std
:
:
vector
<
Reference
>
exp_refs
{
{
0x600
0x0000
}
{
0x608
0x1000
}
{
0x610
0x2FF0
}
{
0x618
0x2FF8
}
{
0x620
0x2FFC
}
{
0x678
0x1234
}
}
;
EXPECT_EQ
(
exp_refs
fake_image
.
ExtractRelocReferences
(
)
)
;
}
TEST
(
RelocElfTest
Limit64
)
{
constexpr
size_t
kImageSize
=
0x3000
;
constexpr
offset_t
kBaseRva
=
0x40000
;
constexpr
offset_t
kRelocStart
=
0x600
;
std
:
:
vector
<
uint8_t
>
reloc_data
=
ParseHexString
(
"
00
00
04
00
00
00
00
00
08
00
00
00
00
00
00
00
"
"
00
10
04
00
00
00
00
00
08
00
00
00
00
00
00
00
"
"
F0
2F
04
00
00
00
00
00
08
00
00
00
00
00
00
00
"
"
F4
2F
04
00
00
00
00
00
08
00
00
00
00
00
00
00
"
"
F8
2F
04
00
00
00
00
00
08
00
00
00
00
00
00
00
"
"
F9
2F
04
00
00
00
00
00
08
00
00
00
00
00
00
00
"
"
FC
2F
04
00
00
00
00
00
08
00
00
00
00
00
00
00
"
"
FF
2F
04
00
00
00
00
00
08
00
00
00
00
00
00
00
"
"
00
30
04
00
00
00
00
00
08
00
00
00
00
00
00
00
"
"
01
30
04
00
00
00
00
00
08
00
00
00
00
00
00
00
"
"
FC
FF
FF
7F
00
00
00
00
08
00
00
00
00
00
00
00
"
"
FE
FF
FF
7F
00
00
00
00
08
00
00
00
00
00
00
00
"
"
00
00
00
80
00
00
00
00
08
00
00
00
00
00
00
00
"
"
FC
FF
FF
FF
00
00
00
00
08
00
00
00
00
00
00
00
"
"
FF
FF
FF
FF
00
00
00
00
08
00
00
00
00
00
00
00
"
"
00
00
04
00
01
00
00
00
08
00
00
00
00
00
00
00
"
"
FF
FF
FF
FF
FF
FF
FF
FF
08
00
00
00
00
00
00
00
"
"
F8
FF
FF
FF
FF
FF
FF
FF
08
00
00
00
00
00
00
00
"
"
34
12
04
00
00
00
00
00
08
00
00
00
00
00
00
00
"
)
;
FakeImageWithReloc
<
Elf64IntelTraits
>
fake_image
(
kImageSize
kBaseRva
{
{
kRelocStart
reloc_data
}
}
)
;
std
:
:
vector
<
Reference
>
exp_refs
{
{
0x600
0x0000
}
{
0x610
0x1000
}
{
0x620
0x2FF0
}
{
0x630
0x2FF4
}
{
0x640
0x2FF8
}
{
0x720
0x1234
}
}
;
EXPECT_EQ
(
exp_refs
fake_image
.
ExtractRelocReferences
(
)
)
;
}
}
