#
ifndef
COMPONENTS_ZUCCHINI_TARGET_POOL_H_
#
define
COMPONENTS_ZUCCHINI_TARGET_POOL_H_
#
include
<
stddef
.
h
>
#
include
<
deque
>
#
include
<
vector
>
#
include
"
components
/
zucchini
/
image_utils
.
h
"
#
include
"
components
/
zucchini
/
patch_reader
.
h
"
namespace
zucchini
{
class
OffsetMapper
;
class
TargetSource
;
class
TargetPool
{
public
:
using
const_iterator
=
std
:
:
deque
<
offset_t
>
:
:
const_iterator
;
TargetPool
(
)
;
explicit
TargetPool
(
std
:
:
deque
<
offset_t
>
&
&
targets
)
;
TargetPool
(
TargetPool
&
&
)
;
TargetPool
(
const
TargetPool
&
)
;
~
TargetPool
(
)
;
void
InsertTargets
(
const
std
:
:
vector
<
offset_t
>
&
targets
)
;
void
InsertTargets
(
TargetSource
*
targets
)
;
void
InsertTargets
(
const
std
:
:
vector
<
Reference
>
&
references
)
;
void
InsertTargets
(
ReferenceReader
&
&
references
)
;
void
AddType
(
TypeTag
type
)
{
types_
.
push_back
(
type
)
;
}
key_t
KeyForOffset
(
offset_t
offset
)
const
;
key_t
KeyForNearestOffset
(
offset_t
offset
)
const
;
offset_t
OffsetForKey
(
key_t
key
)
const
{
return
targets_
[
key
]
;
}
bool
KeyIsValid
(
key_t
key
)
const
{
return
key
<
targets_
.
size
(
)
;
}
void
FilterAndProject
(
const
OffsetMapper
&
offset_mapper
)
;
const
std
:
:
deque
<
offset_t
>
&
targets
(
)
const
{
return
targets_
;
}
const
std
:
:
vector
<
TypeTag
>
&
types
(
)
const
{
return
types_
;
}
size_t
size
(
)
const
{
return
targets_
.
size
(
)
;
}
const_iterator
begin
(
)
const
{
return
targets_
.
cbegin
(
)
;
}
const_iterator
end
(
)
const
{
return
targets_
.
cend
(
)
;
}
private
:
std
:
:
vector
<
TypeTag
>
types_
;
std
:
:
deque
<
offset_t
>
targets_
;
}
;
}
#
endif
