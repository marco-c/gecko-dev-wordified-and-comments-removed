#
ifndef
COMPONENTS_ZUCCHINI_DISASSEMBLER_ELF_H_
#
define
COMPONENTS_ZUCCHINI_DISASSEMBLER_ELF_H_
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
deque
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
components
/
zucchini
/
address_translator
.
h
"
#
include
"
components
/
zucchini
/
buffer_view
.
h
"
#
include
"
components
/
zucchini
/
disassembler
.
h
"
#
include
"
components
/
zucchini
/
image_utils
.
h
"
#
include
"
components
/
zucchini
/
rel32_finder
.
h
"
#
include
"
components
/
zucchini
/
rel32_utils
.
h
"
#
include
"
components
/
zucchini
/
reloc_elf
.
h
"
#
include
"
components
/
zucchini
/
type_elf
.
h
"
namespace
zucchini
{
struct
ArmReferencePool
{
enum
:
uint8_t
{
kPoolReloc
kPoolAbs32
kPoolRel32
}
;
}
;
struct
AArch32ReferenceType
{
enum
:
uint8_t
{
kReloc
kAbs32
kRel32_A24
kRel32_T8
kRel32_T11
kRel32_T20
kRel32_T24
kTypeCount
}
;
}
;
struct
AArch64ReferenceType
{
enum
:
uint8_t
{
kReloc
kAbs32
kRel32_Immd14
kRel32_Immd19
kRel32_Immd26
kTypeCount
}
;
}
;
struct
Elf32Traits
{
static
constexpr
uint16_t
kVersion
=
1
;
static
constexpr
Bitness
kBitness
=
kBit32
;
static
constexpr
elf
:
:
FileClass
kIdentificationClass
=
elf
:
:
ELFCLASS32
;
using
Elf_Shdr
=
elf
:
:
Elf32_Shdr
;
using
Elf_Phdr
=
elf
:
:
Elf32_Phdr
;
using
Elf_Ehdr
=
elf
:
:
Elf32_Ehdr
;
using
Elf_Rel
=
elf
:
:
Elf32_Rel
;
using
Elf_Rela
=
elf
:
:
Elf32_Rela
;
}
;
struct
Elf32IntelTraits
:
public
Elf32Traits
{
static
constexpr
ExecutableType
kExeType
=
kExeTypeElfX86
;
static
const
char
kExeTypeString
[
]
;
static
constexpr
elf
:
:
MachineArchitecture
kMachineValue
=
elf
:
:
EM_386
;
static
constexpr
uint32_t
kRelType
=
elf
:
:
R_386_RELATIVE
;
enum
:
uint32_t
{
kVAWidth
=
4
}
;
using
Rel32FinderUse
=
Rel32FinderX86
;
}
;
struct
ElfAArch32Traits
:
public
Elf32Traits
{
static
constexpr
ExecutableType
kExeType
=
kExeTypeElfAArch32
;
static
const
char
kExeTypeString
[
]
;
static
constexpr
elf
:
:
MachineArchitecture
kMachineValue
=
elf
:
:
EM_ARM
;
static
constexpr
uint32_t
kRelType
=
elf
:
:
R_ARM_RELATIVE
;
enum
:
uint32_t
{
kVAWidth
=
4
}
;
using
ArmReferenceType
=
AArch32ReferenceType
;
using
Rel32FinderUse
=
Rel32FinderAArch32
;
}
;
struct
Elf64Traits
{
static
constexpr
uint16_t
kVersion
=
1
;
static
constexpr
Bitness
kBitness
=
kBit64
;
static
constexpr
elf
:
:
FileClass
kIdentificationClass
=
elf
:
:
ELFCLASS64
;
using
Elf_Shdr
=
elf
:
:
Elf64_Shdr
;
using
Elf_Phdr
=
elf
:
:
Elf64_Phdr
;
using
Elf_Ehdr
=
elf
:
:
Elf64_Ehdr
;
using
Elf_Rel
=
elf
:
:
Elf64_Rel
;
using
Elf_Rela
=
elf
:
:
Elf64_Rela
;
}
;
struct
Elf64IntelTraits
:
public
Elf64Traits
{
static
constexpr
ExecutableType
kExeType
=
kExeTypeElfX64
;
static
const
char
kExeTypeString
[
]
;
static
constexpr
elf
:
:
MachineArchitecture
kMachineValue
=
elf
:
:
EM_X86_64
;
static
constexpr
uint32_t
kRelType
=
elf
:
:
R_X86_64_RELATIVE
;
enum
:
uint32_t
{
kVAWidth
=
8
}
;
using
Rel32FinderUse
=
Rel32FinderX64
;
}
;
struct
ElfAArch64Traits
:
public
Elf64Traits
{
static
constexpr
ExecutableType
kExeType
=
kExeTypeElfAArch64
;
static
const
char
kExeTypeString
[
]
;
static
constexpr
elf
:
:
MachineArchitecture
kMachineValue
=
elf
:
:
EM_AARCH64
;
static
constexpr
uint32_t
kRelType
=
elf
:
:
R_AARCH64_RELATIVE
;
enum
:
uint32_t
{
kVAWidth
=
8
}
;
using
ArmReferenceType
=
AArch64ReferenceType
;
using
Rel32FinderUse
=
Rel32FinderAArch64
;
}
;
template
<
class
ELF_SHDR
>
bool
IsTargetOffsetInElfSectionList
(
const
std
:
:
vector
<
const
ELF_SHDR
*
>
&
sorted_headers
offset_t
offset
)
{
auto
comp
=
[
]
(
offset_t
offset
const
ELF_SHDR
*
header
)
-
>
bool
{
return
offset
<
header
-
>
sh_offset
;
}
;
auto
it
=
std
:
:
upper_bound
(
sorted_headers
.
begin
(
)
sorted_headers
.
end
(
)
offset
comp
)
;
if
(
it
=
=
sorted_headers
.
begin
(
)
)
return
false
;
-
-
it
;
return
offset
>
=
(
*
it
)
-
>
sh_offset
&
&
offset
-
(
*
it
)
-
>
sh_offset
<
(
*
it
)
-
>
sh_size
;
}
template
<
class
TRAITS
>
class
DisassemblerElf
:
public
Disassembler
{
public
:
using
Traits
=
TRAITS
;
static
constexpr
uint16_t
kVersion
=
Traits
:
:
kVersion
;
static
bool
QuickDetect
(
ConstBufferView
image
)
;
DisassemblerElf
(
const
DisassemblerElf
&
)
=
delete
;
const
DisassemblerElf
&
operator
=
(
const
DisassemblerElf
&
)
=
delete
;
~
DisassemblerElf
(
)
override
;
ExecutableType
GetExeType
(
)
const
override
;
std
:
:
string
GetExeTypeString
(
)
const
override
;
std
:
:
vector
<
ReferenceGroup
>
MakeReferenceGroups
(
)
const
override
=
0
;
std
:
:
unique_ptr
<
ReferenceReader
>
MakeReadRelocs
(
offset_t
lo
offset_t
hi
)
;
std
:
:
unique_ptr
<
ReferenceWriter
>
MakeWriteRelocs
(
MutableBufferView
image
)
;
const
AddressTranslator
&
translator
(
)
const
{
return
translator_
;
}
protected
:
friend
Disassembler
;
DisassemblerElf
(
)
;
bool
Parse
(
ConstBufferView
image
)
override
;
static
constexpr
elf
:
:
MachineArchitecture
supported_architecture
(
)
{
return
Traits
:
:
kMachineValue
;
}
static
constexpr
uint32_t
supported_relocation_type
(
)
{
return
Traits
:
:
kRelType
;
}
virtual
void
ParseExecSection
(
const
typename
Traits
:
:
Elf_Shdr
&
section
)
=
0
;
virtual
void
PostProcessRel32
(
)
=
0
;
bool
ParseHeader
(
)
;
void
ExtractInterestingSectionHeaders
(
)
;
void
GetAbs32FromRelocSections
(
)
;
void
GetRel32FromCodeSections
(
)
;
void
ParseSections
(
)
;
raw_ptr
<
const
typename
Traits
:
:
Elf_Ehdr
>
header_
=
nullptr
;
elf
:
:
Elf32_Half
sections_count_
=
0
;
raw_ptr
<
const
typename
Traits
:
:
Elf_Shdr
AllowPtrArithmetic
>
sections_
=
nullptr
;
elf
:
:
Elf32_Half
segments_count_
=
0
;
raw_ptr
<
const
typename
Traits
:
:
Elf_Phdr
AllowPtrArithmetic
>
segments_
=
nullptr
;
std
:
:
vector
<
int
>
section_judgements_
;
AddressTranslator
translator_
;
AddressTranslator
identity_translator_
;
std
:
:
vector
<
SectionDimensionsElf
>
reloc_section_dims_
;
std
:
:
vector
<
const
typename
Traits
:
:
Elf_Shdr
*
>
exec_headers_
;
std
:
:
deque
<
offset_t
>
abs32_locations_
;
}
;
template
<
class
TRAITS
>
class
DisassemblerElfIntel
:
public
DisassemblerElf
<
TRAITS
>
{
public
:
using
Traits
=
TRAITS
;
enum
ReferenceType
:
uint8_t
{
kReloc
kAbs32
kRel32
kTypeCount
}
;
DisassemblerElfIntel
(
)
;
DisassemblerElfIntel
(
const
DisassemblerElfIntel
&
)
=
delete
;
const
DisassemblerElfIntel
&
operator
=
(
const
DisassemblerElfIntel
&
)
=
delete
;
~
DisassemblerElfIntel
(
)
override
;
std
:
:
vector
<
ReferenceGroup
>
MakeReferenceGroups
(
)
const
override
;
void
ParseExecSection
(
const
typename
Traits
:
:
Elf_Shdr
&
section
)
override
;
void
PostProcessRel32
(
)
override
;
std
:
:
unique_ptr
<
ReferenceReader
>
MakeReadAbs32
(
offset_t
lo
offset_t
hi
)
;
std
:
:
unique_ptr
<
ReferenceWriter
>
MakeWriteAbs32
(
MutableBufferView
image
)
;
std
:
:
unique_ptr
<
ReferenceReader
>
MakeReadRel32
(
offset_t
lo
offset_t
hi
)
;
std
:
:
unique_ptr
<
ReferenceWriter
>
MakeWriteRel32
(
MutableBufferView
image
)
;
private
:
std
:
:
deque
<
offset_t
>
rel32_locations_
;
}
;
using
DisassemblerElfX86
=
DisassemblerElfIntel
<
Elf32IntelTraits
>
;
using
DisassemblerElfX64
=
DisassemblerElfIntel
<
Elf64IntelTraits
>
;
template
<
class
TRAITS
>
class
DisassemblerElfArm
:
public
DisassemblerElf
<
TRAITS
>
{
public
:
using
Traits
=
TRAITS
;
DisassemblerElfArm
(
)
;
DisassemblerElfArm
(
const
DisassemblerElfArm
&
)
=
delete
;
const
DisassemblerElfArm
&
operator
=
(
const
DisassemblerElfArm
&
)
=
delete
;
~
DisassemblerElfArm
(
)
override
;
bool
IsTargetOffsetInExecSection
(
offset_t
offset
)
const
;
virtual
std
:
:
unique_ptr
<
typename
Traits
:
:
Rel32FinderUse
>
MakeRel32Finder
(
const
typename
Traits
:
:
Elf_Shdr
&
section
)
=
0
;
void
ParseExecSection
(
const
typename
Traits
:
:
Elf_Shdr
&
section
)
override
;
void
PostProcessRel32
(
)
override
;
std
:
:
unique_ptr
<
ReferenceReader
>
MakeReadAbs32
(
offset_t
lo
offset_t
hi
)
;
std
:
:
unique_ptr
<
ReferenceWriter
>
MakeWriteAbs32
(
MutableBufferView
image
)
;
template
<
class
ADDR_TRAITS
>
std
:
:
unique_ptr
<
ReferenceReader
>
MakeReadRel32
(
offset_t
lower
offset_t
upper
)
;
template
<
class
ADDR_TRAITS
>
std
:
:
unique_ptr
<
ReferenceWriter
>
MakeWriteRel32
(
MutableBufferView
image
)
;
template
<
class
ADDR_TRAITS
>
std
:
:
unique_ptr
<
ReferenceMixer
>
MakeMixRel32
(
ConstBufferView
old_image
ConstBufferView
new_image
)
;
protected
:
std
:
:
deque
<
offset_t
>
rel32_locations_table_
[
Traits
:
:
ArmReferenceType
:
:
kTypeCount
]
;
}
;
class
DisassemblerElfAArch32
:
public
DisassemblerElfArm
<
ElfAArch32Traits
>
{
public
:
DisassemblerElfAArch32
(
)
;
DisassemblerElfAArch32
(
const
DisassemblerElfAArch32
&
)
=
delete
;
const
DisassemblerElfAArch32
&
operator
=
(
const
DisassemblerElfAArch32
&
)
=
delete
;
~
DisassemblerElfAArch32
(
)
override
;
std
:
:
vector
<
ReferenceGroup
>
MakeReferenceGroups
(
)
const
override
;
std
:
:
unique_ptr
<
typename
Traits
:
:
Rel32FinderUse
>
MakeRel32Finder
(
const
typename
Traits
:
:
Elf_Shdr
&
section
)
override
;
bool
IsExecSectionThumb2
(
const
typename
Traits
:
:
Elf_Shdr
&
section
)
const
;
}
;
class
DisassemblerElfAArch64
:
public
DisassemblerElfArm
<
ElfAArch64Traits
>
{
public
:
DisassemblerElfAArch64
(
)
;
DisassemblerElfAArch64
(
const
DisassemblerElfAArch64
&
)
=
delete
;
const
DisassemblerElfAArch64
&
operator
=
(
const
DisassemblerElfAArch64
&
)
=
delete
;
~
DisassemblerElfAArch64
(
)
override
;
std
:
:
vector
<
ReferenceGroup
>
MakeReferenceGroups
(
)
const
override
;
std
:
:
unique_ptr
<
typename
Traits
:
:
Rel32FinderUse
>
MakeRel32Finder
(
const
typename
Traits
:
:
Elf_Shdr
&
section
)
override
;
}
;
}
#
endif
