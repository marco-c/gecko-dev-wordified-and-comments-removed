#
ifndef
COMPONENTS_ZUCCHINI_IMPOSED_ENSEMBLE_MATCHER_H_
#
define
COMPONENTS_ZUCCHINI_IMPOSED_ENSEMBLE_MATCHER_H_
#
include
<
stddef
.
h
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
components
/
zucchini
/
buffer_view
.
h
"
#
include
"
components
/
zucchini
/
element_detection
.
h
"
#
include
"
components
/
zucchini
/
ensemble_matcher
.
h
"
namespace
zucchini
{
class
ImposedMatchParser
{
public
:
enum
Status
{
kSuccess
kInvalidDelimiter
kParseError
kOutOfBound
kOverlapInNew
kTypeMismatch
}
;
ImposedMatchParser
(
)
;
ImposedMatchParser
(
const
ImposedMatchParser
&
)
=
delete
;
const
ImposedMatchParser
&
operator
=
(
const
ImposedMatchParser
&
)
=
delete
;
~
ImposedMatchParser
(
)
;
Status
Parse
(
std
:
:
string
imposed_matches
ConstBufferView
old_image
ConstBufferView
new_image
ElementDetector
&
&
detector
)
;
size_t
num_identical
(
)
const
{
return
num_identical_
;
}
std
:
:
vector
<
ElementMatch
>
*
mutable_matches
(
)
{
return
&
matches_
;
}
std
:
:
vector
<
ElementMatch
>
*
mutable_bad_matches
(
)
{
return
&
bad_matches_
;
}
private
:
size_t
num_identical_
=
0
;
std
:
:
vector
<
ElementMatch
>
matches_
;
std
:
:
vector
<
ElementMatch
>
bad_matches_
;
}
;
class
ImposedEnsembleMatcher
:
public
EnsembleMatcher
{
public
:
explicit
ImposedEnsembleMatcher
(
const
std
:
:
string
&
imposed_matches
)
;
ImposedEnsembleMatcher
(
const
ImposedEnsembleMatcher
&
)
=
delete
;
const
ImposedEnsembleMatcher
&
operator
=
(
const
ImposedEnsembleMatcher
&
)
=
delete
;
~
ImposedEnsembleMatcher
(
)
override
;
bool
RunMatch
(
ConstBufferView
old_image
ConstBufferView
new_image
)
override
;
private
:
const
std
:
:
string
imposed_matches_
;
}
;
}
#
endif
