#
ifndef
COMPONENTS_ZUCCHINI_EQUIVALENCE_MAP_H_
#
define
COMPONENTS_ZUCCHINI_EQUIVALENCE_MAP_H_
#
include
<
stddef
.
h
>
#
include
<
deque
>
#
include
<
limits
>
#
include
<
vector
>
#
include
"
components
/
zucchini
/
image_index
.
h
"
#
include
"
components
/
zucchini
/
image_utils
.
h
"
#
include
"
components
/
zucchini
/
targets_affinity
.
h
"
namespace
zucchini
{
constexpr
double
kMismatchFatal
=
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
class
EncodedView
;
class
EquivalenceSource
;
double
GetTokenSimilarity
(
const
ImageIndex
&
old_image_index
const
ImageIndex
&
new_image_index
const
std
:
:
vector
<
TargetsAffinity
>
&
targets_affinities
offset_t
src
offset_t
dst
)
;
double
GetEquivalenceSimilarity
(
const
ImageIndex
&
old_image_index
const
ImageIndex
&
new_image_index
const
std
:
:
vector
<
TargetsAffinity
>
&
targets_affinities
const
Equivalence
&
equivalence
)
;
EquivalenceCandidate
ExtendEquivalenceForward
(
const
ImageIndex
&
old_image_index
const
ImageIndex
&
new_image_index
const
std
:
:
vector
<
TargetsAffinity
>
&
targets_affinities
const
EquivalenceCandidate
&
equivalence
double
min_similarity
)
;
EquivalenceCandidate
ExtendEquivalenceBackward
(
const
ImageIndex
&
old_image_index
const
ImageIndex
&
new_image_index
const
std
:
:
vector
<
TargetsAffinity
>
&
targets_affinities
const
EquivalenceCandidate
&
equivalence
double
min_similarity
)
;
EquivalenceCandidate
VisitEquivalenceSeed
(
const
ImageIndex
&
old_image_index
const
ImageIndex
&
new_image_index
const
std
:
:
vector
<
TargetsAffinity
>
&
targets_affinities
offset_t
src
offset_t
dst
double
min_similarity
)
;
class
OffsetMapper
{
public
:
using
const_iterator
=
std
:
:
deque
<
Equivalence
>
:
:
const_iterator
;
OffsetMapper
(
std
:
:
deque
<
Equivalence
>
&
&
equivalences
offset_t
old_image_size
offset_t
new_image_size
)
;
OffsetMapper
(
EquivalenceSource
&
&
equivalence_source
offset_t
old_image_size
offset_t
new_image_size
)
;
OffsetMapper
(
const
EquivalenceMap
&
equivalence_map
offset_t
old_image_size
offset_t
new_image_size
)
;
~
OffsetMapper
(
)
;
size_t
size
(
)
const
{
return
equivalences_
.
size
(
)
;
}
const_iterator
begin
(
)
const
{
return
equivalences_
.
begin
(
)
;
}
const_iterator
end
(
)
const
{
return
equivalences_
.
end
(
)
;
}
offset_t
NaiveExtendedForwardProject
(
const
Equivalence
&
unit
offset_t
offset
)
const
;
offset_t
ExtendedForwardProject
(
offset_t
offset
)
const
;
void
ForwardProjectAll
(
std
:
:
deque
<
offset_t
>
*
offsets
)
const
;
const
std
:
:
deque
<
Equivalence
>
equivalences
(
)
const
{
return
equivalences_
;
}
static
void
PruneEquivalencesAndSortBySource
(
std
:
:
deque
<
Equivalence
>
*
equivalences
)
;
private
:
std
:
:
deque
<
Equivalence
>
equivalences_
;
const
offset_t
old_image_size_
;
const
offset_t
new_image_size_
;
}
;
class
EquivalenceMap
{
public
:
using
const_iterator
=
std
:
:
vector
<
EquivalenceCandidate
>
:
:
const_iterator
;
EquivalenceMap
(
)
;
explicit
EquivalenceMap
(
std
:
:
vector
<
EquivalenceCandidate
>
&
&
candidates
)
;
EquivalenceMap
(
EquivalenceMap
&
&
)
;
EquivalenceMap
(
const
EquivalenceMap
&
)
=
delete
;
~
EquivalenceMap
(
)
;
void
Build
(
const
std
:
:
vector
<
offset_t
>
&
old_sa
const
EncodedView
&
old_view
const
EncodedView
&
new_view
const
std
:
:
vector
<
TargetsAffinity
>
&
targets_affinities
double
min_similarity
)
;
size_t
size
(
)
const
{
return
candidates_
.
size
(
)
;
}
const_iterator
begin
(
)
const
{
return
candidates_
.
begin
(
)
;
}
const_iterator
end
(
)
const
{
return
candidates_
.
end
(
)
;
}
private
:
void
CreateCandidates
(
const
std
:
:
vector
<
offset_t
>
&
old_sa
const
EncodedView
&
old_view
const
EncodedView
&
new_view
const
std
:
:
vector
<
TargetsAffinity
>
&
targets_affinities
double
min_similarity
)
;
void
SortByDestination
(
)
;
void
Prune
(
const
EncodedView
&
old_view
const
EncodedView
&
new_view
const
std
:
:
vector
<
TargetsAffinity
>
&
targets_affinities
double
min_similarity
)
;
std
:
:
vector
<
EquivalenceCandidate
>
candidates_
;
}
;
}
#
endif
