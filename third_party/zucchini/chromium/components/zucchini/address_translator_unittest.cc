#
include
"
components
/
zucchini
/
address_translator
.
h
"
#
include
<
string
>
#
include
<
utility
>
#
include
"
base
/
format_macros
.
h
"
#
include
"
base
/
ranges
/
algorithm
.
h
"
#
include
"
base
/
strings
/
stringprintf
.
h
"
#
include
"
testing
/
gtest
/
include
/
gtest
/
gtest
.
h
"
namespace
zucchini
{
namespace
{
struct
OffsetToRvaTestCase
{
offset_t
input
;
rva_t
expect
;
}
;
struct
RvaToOffsetTestCase
{
rva_t
input
;
offset_t
expect
;
}
;
class
TestAddressTranslator
:
public
AddressTranslator
{
public
:
using
AddressTranslator
:
:
AddressTranslator
;
AddressTranslator
:
:
Status
InitializeWithStrings
(
const
std
:
:
vector
<
std
:
:
string
>
&
specs
)
{
std
:
:
vector
<
Unit
>
units
;
units
.
reserve
(
specs
.
size
(
)
)
;
for
(
const
std
:
:
string
&
s
:
specs
)
{
size_t
sep
=
s
.
find
(
'
|
'
)
;
CHECK_NE
(
sep
std
:
:
string
:
:
npos
)
;
std
:
:
string
s1
=
s
.
substr
(
0
sep
)
;
std
:
:
string
s2
=
s
.
substr
(
sep
+
1
)
;
auto
first_non_blank
=
[
]
(
const
std
:
:
string
&
t
)
{
auto
is_blank
=
[
]
(
char
ch
)
{
return
ch
=
=
'
.
'
;
}
;
return
base
:
:
ranges
:
:
find_if_not
(
t
is_blank
)
-
t
.
begin
(
)
;
}
;
auto
count_non_special
=
[
]
(
const
std
:
:
string
&
t
)
{
auto
is_special
=
[
]
(
char
ch
)
{
return
ch
=
=
'
.
'
|
|
ch
=
=
'
!
'
;
}
;
return
t
.
size
(
)
-
base
:
:
ranges
:
:
count_if
(
t
is_special
)
;
}
;
units
.
push_back
(
{
static_cast
<
offset_t
>
(
first_non_blank
(
s1
)
)
static_cast
<
offset_t
>
(
count_non_special
(
s1
)
)
static_cast
<
rva_t
>
(
first_non_blank
(
s2
)
)
static_cast
<
rva_t
>
(
count_non_special
(
s2
)
)
}
)
;
}
return
Initialize
(
std
:
:
move
(
units
)
)
;
}
}
;
void
SimpleTest
(
const
std
:
:
vector
<
std
:
:
string
>
&
specs
AddressTranslator
:
:
Status
expected
const
std
:
:
string
&
case_name
)
{
TestAddressTranslator
translator
;
auto
result
=
translator
.
InitializeWithStrings
(
specs
)
;
EXPECT_EQ
(
expected
result
)
<
<
case_name
;
}
class
TwoUnitOverlapTester
{
public
:
struct
TestCase
{
std
:
:
string
unit_str
;
AddressTranslator
:
:
Status
expected
;
}
;
static
void
RunTest
(
const
std
:
:
string
&
unit_str1
const
std
:
:
vector
<
TestCase
>
&
test_cases
)
{
for
(
size_t
i
=
0
;
i
<
test_cases
.
size
(
)
;
+
+
i
)
{
const
auto
&
test_case
=
test_cases
[
i
]
;
const
std
:
:
string
&
unit_str2
=
test_case
.
unit_str
;
const
std
:
:
string
str
=
base
:
:
StringPrintf
(
"
Case
#
%
"
PRIuS
"
:
%
s
"
i
unit_str2
.
c_str
(
)
)
;
SimpleTest
(
{
unit_str1
unit_str2
}
test_case
.
expected
str
)
;
SimpleTest
(
{
unit_str2
unit_str1
}
test_case
.
expected
str
)
;
}
}
}
;
}
TEST
(
AddressTranslatorTest
Empty
)
{
using
AT
=
AddressTranslator
;
TestAddressTranslator
translator
;
EXPECT_EQ
(
AT
:
:
kSuccess
translator
.
Initialize
(
std
:
:
vector
<
AddressTranslator
:
:
Unit
>
(
)
)
)
;
offset_t
fake_offset_begin
=
translator
.
fake_offset_begin
(
)
;
AddressTranslator
:
:
OffsetToRvaCache
offset_to_rva
(
translator
)
;
AddressTranslator
:
:
RvaToOffsetCache
rva_to_offset
(
translator
)
;
EXPECT_EQ
(
kInvalidRva
translator
.
OffsetToRva
(
0U
)
)
;
EXPECT_EQ
(
kInvalidRva
translator
.
OffsetToRva
(
100U
)
)
;
EXPECT_EQ
(
kInvalidRva
offset_to_rva
.
Convert
(
0U
)
)
;
EXPECT_EQ
(
kInvalidRva
offset_to_rva
.
Convert
(
100U
)
)
;
EXPECT_EQ
(
kInvalidOffset
translator
.
RvaToOffset
(
0U
)
)
;
EXPECT_EQ
(
kInvalidOffset
translator
.
RvaToOffset
(
100U
)
)
;
EXPECT_EQ
(
kInvalidOffset
rva_to_offset
.
Convert
(
0U
)
)
;
EXPECT_EQ
(
kInvalidOffset
rva_to_offset
.
Convert
(
100U
)
)
;
EXPECT_EQ
(
kInvalidRva
translator
.
OffsetToRva
(
fake_offset_begin
)
)
;
EXPECT_EQ
(
kInvalidRva
offset_to_rva
.
Convert
(
fake_offset_begin
)
)
;
}
TEST
(
AddressTranslatorTest
Single
)
{
using
AT
=
AddressTranslator
;
TestAddressTranslator
translator
;
EXPECT_EQ
(
AT
:
:
kSuccess
translator
.
Initialize
(
{
{
10U
+
20U
100U
+
20U
}
}
)
)
;
offset_t
fake_offset_begin
=
translator
.
fake_offset_begin
(
)
;
AddressTranslator
:
:
OffsetToRvaCache
offset_to_rva
(
translator
)
;
AddressTranslator
:
:
RvaToOffsetCache
rva_to_offset
(
translator
)
;
EXPECT_EQ
(
30U
fake_offset_begin
)
;
OffsetToRvaTestCase
test_cases1
[
]
=
{
{
0U
kInvalidRva
}
{
9U
kInvalidRva
}
{
10U
100U
}
{
20U
110U
}
{
29U
119U
}
{
30U
kInvalidRva
}
}
;
for
(
auto
&
test_case
:
test_cases1
)
{
EXPECT_EQ
(
test_case
.
expect
translator
.
OffsetToRva
(
test_case
.
input
)
)
;
EXPECT_EQ
(
test_case
.
expect
offset_to_rva
.
Convert
(
test_case
.
input
)
)
;
}
RvaToOffsetTestCase
test_cases2
[
]
=
{
{
0U
kInvalidOffset
}
{
99U
kInvalidOffset
}
{
100U
10U
}
{
110U
20U
}
{
119U
29U
}
{
120U
kInvalidOffset
}
}
;
for
(
auto
&
test_case
:
test_cases2
)
{
EXPECT_EQ
(
test_case
.
expect
translator
.
RvaToOffset
(
test_case
.
input
)
)
;
EXPECT_EQ
(
test_case
.
expect
rva_to_offset
.
Convert
(
test_case
.
input
)
)
;
}
}
TEST
(
AddressTranslatorTest
SingleDanglingRva
)
{
using
AT
=
AddressTranslator
;
TestAddressTranslator
translator
;
EXPECT_EQ
(
AT
:
:
kSuccess
translator
.
Initialize
(
{
{
10U
+
20U
100U
+
20U
+
7U
}
}
)
)
;
offset_t
fake_offset_begin
=
translator
.
fake_offset_begin
(
)
;
EXPECT_EQ
(
30U
fake_offset_begin
)
;
AddressTranslator
:
:
OffsetToRvaCache
offset_to_rva
(
translator
)
;
AddressTranslator
:
:
RvaToOffsetCache
rva_to_offset
(
translator
)
;
OffsetToRvaTestCase
test_cases1
[
]
=
{
{
0U
kInvalidRva
}
{
9U
kInvalidRva
}
{
10U
100U
}
{
20U
110U
}
{
29U
119U
}
{
30U
kInvalidRva
}
{
fake_offset_begin
+
100U
kInvalidRva
}
{
fake_offset_begin
+
119U
kInvalidRva
}
{
fake_offset_begin
+
120U
120U
}
{
fake_offset_begin
+
126U
126U
}
{
fake_offset_begin
+
127U
kInvalidRva
}
}
;
for
(
auto
&
test_case
:
test_cases1
)
{
EXPECT_EQ
(
test_case
.
expect
translator
.
OffsetToRva
(
test_case
.
input
)
)
;
EXPECT_EQ
(
test_case
.
expect
offset_to_rva
.
Convert
(
test_case
.
input
)
)
;
}
RvaToOffsetTestCase
test_cases2
[
]
=
{
{
0U
kInvalidOffset
}
{
99U
kInvalidOffset
}
{
100U
10U
}
{
110U
20U
}
{
119U
29U
}
{
120U
fake_offset_begin
+
120U
}
{
126U
fake_offset_begin
+
126U
}
{
127U
kInvalidOffset
}
}
;
for
(
auto
&
test_case
:
test_cases2
)
{
EXPECT_EQ
(
test_case
.
expect
translator
.
RvaToOffset
(
test_case
.
input
)
)
;
EXPECT_EQ
(
test_case
.
expect
rva_to_offset
.
Convert
(
test_case
.
input
)
)
;
}
}
TEST
(
AddressTranslatorTest
BasicUsage
)
{
using
AT
=
AddressTranslator
;
TestAddressTranslator
translator
;
auto
result
=
translator
.
Initialize
(
{
{
10U
+
20U
200U
+
20U
+
5U
}
{
40U
+
30U
300U
+
20U
}
{
50U
+
20U
310U
+
20U
}
{
70U
+
40U
100U
+
20U
}
{
90U
+
20U
120U
+
20U
}
}
)
;
EXPECT_EQ
(
AT
:
:
kSuccess
result
)
;
offset_t
fake_offset_begin
=
translator
.
fake_offset_begin
(
)
;
EXPECT_EQ
(
110U
fake_offset_begin
)
;
AddressTranslator
:
:
OffsetToRvaCache
offset_to_rva
(
translator
)
;
AddressTranslator
:
:
RvaToOffsetCache
rva_to_offset
(
translator
)
;
OffsetToRvaTestCase
test_cases1
[
]
=
{
{
0U
kInvalidRva
}
{
9U
kInvalidRva
}
{
10U
200U
}
{
20U
210U
}
{
29U
219U
}
{
30U
kInvalidRva
}
{
39U
kInvalidRva
}
{
40U
300U
}
{
55U
315U
}
{
69U
329U
}
{
70U
100U
}
{
90U
120U
}
{
109U
139U
}
{
110U
kInvalidRva
}
{
fake_offset_begin
+
220U
220U
}
{
fake_offset_begin
+
224U
224U
}
{
fake_offset_begin
+
225U
kInvalidRva
}
}
;
for
(
auto
&
test_case
:
test_cases1
)
{
EXPECT_EQ
(
test_case
.
expect
translator
.
OffsetToRva
(
test_case
.
input
)
)
;
EXPECT_EQ
(
test_case
.
expect
offset_to_rva
.
Convert
(
test_case
.
input
)
)
;
}
RvaToOffsetTestCase
test_cases2
[
]
=
{
{
0U
kInvalidOffset
}
{
99U
kInvalidOffset
}
{
100U
70U
}
{
120U
90U
}
{
139U
109U
}
{
140U
kInvalidOffset
}
{
199U
kInvalidOffset
}
{
200U
10U
}
{
210U
20U
}
{
219U
29U
}
{
225U
kInvalidOffset
}
{
299U
kInvalidOffset
}
{
300U
40U
}
{
315U
55U
}
{
329U
69U
}
{
330U
kInvalidOffset
}
{
220U
fake_offset_begin
+
220U
}
{
224U
fake_offset_begin
+
224U
}
{
225U
kInvalidOffset
}
}
;
for
(
auto
&
test_case
:
test_cases2
)
{
EXPECT_EQ
(
test_case
.
expect
translator
.
RvaToOffset
(
test_case
.
input
)
)
;
EXPECT_EQ
(
test_case
.
expect
rva_to_offset
.
Convert
(
test_case
.
input
)
)
;
}
}
TEST
(
AddressTranslatorTest
Overflow
)
{
using
AT
=
AddressTranslator
;
static_assert
(
sizeof
(
offset_t
)
=
=
4
&
&
sizeof
(
rva_t
)
=
=
4
"
Needs
to
update
test
.
"
)
;
{
AddressTranslator
translator1
;
EXPECT_EQ
(
AT
:
:
kErrorOverflow
translator1
.
Initialize
(
{
{
0
+
0xC0000000U
0
+
0xC0000000U
}
}
)
)
;
}
{
AddressTranslator
translator2
;
EXPECT_EQ
(
AT
:
:
kErrorOverflow
translator2
.
Initialize
(
{
{
0
+
0
0
+
0xC0000000U
}
}
)
)
;
}
{
AddressTranslator
translator3
;
EXPECT_EQ
(
AT
:
:
kErrorFakeOffsetBeginTooLarge
translator3
.
Initialize
(
{
{
32
+
0
32
+
0x50000000U
}
{
0x50000000U
+
16
0
+
16
}
}
)
)
;
}
}
TEST
(
AddressTranslatorTest
AddUnitAsString
)
{
using
AT
=
AddressTranslator
;
{
TestAddressTranslator
translator1
;
EXPECT_EQ
(
AT
:
:
kSuccess
translator1
.
InitializeWithStrings
(
{
"
.
.
A
.
.
|
.
aaa
.
"
}
)
)
;
AddressTranslator
:
:
Unit
unit1
=
translator1
.
units_sorted_by_offset
(
)
[
0
]
;
EXPECT_EQ
(
2U
unit1
.
offset_begin
)
;
EXPECT_EQ
(
+
1U
unit1
.
offset_size
)
;
EXPECT_EQ
(
1U
unit1
.
rva_begin
)
;
EXPECT_EQ
(
+
3U
unit1
.
rva_size
)
;
}
{
TestAddressTranslator
translator2
;
EXPECT_EQ
(
AT
:
:
kSuccess
translator2
.
InitializeWithStrings
(
{
"
.
.
.
.
.
!
.
.
.
|
.
bbbbbb
.
.
.
"
}
)
)
;
AddressTranslator
:
:
Unit
unit2
=
translator2
.
units_sorted_by_offset
(
)
[
0
]
;
EXPECT_EQ
(
5U
unit2
.
offset_begin
)
;
EXPECT_EQ
(
+
0U
unit2
.
offset_size
)
;
EXPECT_EQ
(
1U
unit2
.
rva_begin
)
;
EXPECT_EQ
(
+
6U
unit2
.
rva_size
)
;
}
}
TEST
(
AddressTranslatorTest
OverlapFromComment
)
{
using
AT
=
AddressTranslator
;
constexpr
auto
OK
=
AT
:
:
kSuccess
;
struct
{
const
char
*
rva_str
;
const
char
*
offset_str
;
AT
:
:
Status
expected
;
}
test_cases
[
]
=
{
{
"
.
.
ssssffff
.
.
"
"
.
.
SSSSFFFF
.
.
"
OK
}
{
"
.
.
ssssffff
.
.
"
"
.
.
SSSS
.
.
FFFF
.
.
"
OK
}
{
"
.
.
ssssffff
.
.
"
"
.
.
FFFF
.
.
SSSS
.
.
"
OK
}
{
"
.
.
ssssffff
.
.
"
"
.
.
SSOOFF
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
sssooofff
.
.
"
"
.
.
SSSOOOFFF
.
.
"
OK
}
{
"
.
.
sssooofff
.
.
"
"
.
.
SSSSSOFFFFF
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
sssooofff
.
.
"
"
.
.
FFOOOOSS
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
sssooofff
.
.
"
"
.
.
SSSOOOF
.
.
"
OK
}
{
"
.
.
sssooofff
.
.
"
"
.
.
SSSOOOF
.
.
"
OK
}
{
"
.
.
sssooosss
.
.
"
"
.
.
SSSOOOS
.
.
"
OK
}
{
"
.
.
sssooofff
.
.
"
"
.
.
SSSOO
.
.
"
OK
}
{
"
.
.
sssooofff
.
.
"
"
.
.
SSSOFFF
.
.
"
AT
:
:
kErrorBadOverlapDanglingRva
}
{
"
.
.
sssooosss
.
.
"
"
.
.
SSSOOSSSS
.
.
"
AT
:
:
kErrorBadOverlapDanglingRva
}
{
"
.
.
oooooo
.
.
"
"
.
.
OOO
.
.
"
OK
}
}
;
auto
to_period
=
[
]
(
std
:
:
string
s
char
ch
)
{
std
:
:
replace
(
s
.
begin
(
)
s
.
end
(
)
ch
'
.
'
)
;
return
s
;
}
;
size_t
idx
=
0
;
for
(
const
auto
&
test_case
:
test_cases
)
{
std
:
:
string
base_str
=
std
:
:
string
(
test_case
.
offset_str
)
+
"
|
"
+
test_case
.
rva_str
;
std
:
:
string
unit_str1
=
to_period
(
to_period
(
base_str
'
S
'
)
'
s
'
)
;
std
:
:
string
unit_str2
=
to_period
(
to_period
(
base_str
'
F
'
)
'
f
'
)
;
SimpleTest
(
{
unit_str1
unit_str2
}
test_case
.
expected
base
:
:
StringPrintf
(
"
Case
#
%
"
PRIuS
idx
)
)
;
+
+
idx
;
}
}
TEST
(
AddressTranslatorTest
Overlap
)
{
using
AT
=
AddressTranslator
;
constexpr
auto
OK
=
AT
:
:
kSuccess
;
constexpr
const
char
*
unit_str1
=
"
.
.
.
.
AAA
.
.
.
.
.
.
.
|
.
.
.
.
.
aaa
.
.
.
.
.
.
"
;
std
:
:
vector
<
TwoUnitOverlapTester
:
:
TestCase
>
test_cases
=
{
{
"
.
.
.
.
BBB
.
.
.
.
.
.
.
|
.
.
.
.
.
bbb
.
.
.
.
.
.
"
OK
}
{
"
.
.
BBB
.
.
.
.
.
.
.
.
.
|
.
.
.
bbb
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
BBB
.
.
.
.
.
|
.
.
.
.
.
.
.
bbb
.
.
.
.
"
OK
}
{
"
.
.
BBBBBBBBB
.
.
.
|
.
.
.
bbb
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
BBBBBBBB
|
.
.
.
.
.
.
.
bbb
.
.
.
.
"
OK
}
{
"
.
.
.
.
BBB
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
bbb
.
.
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
BBB
.
.
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
bbb
.
.
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
.
.
.
.
.
BBB
.
.
.
.
|
.
.
.
.
.
.
.
bbb
.
.
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
.
.
BBB
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
.
.
.
bbb
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
.
.
.
.
.
.
.
.
BBB
.
|
.
.
.
.
.
.
.
bbb
.
.
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
.
.
.
.
BBB
.
.
.
.
.
|
.
.
.
.
.
bbb
.
.
.
.
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
.
.
.
.
BBB
.
.
.
.
.
|
.
.
bbb
.
.
.
.
.
.
.
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
.
.
.
.
BBB
.
.
.
.
.
|
bbb
.
.
.
.
.
.
.
.
.
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
BBB
.
.
.
.
.
.
.
.
.
.
.
|
bbb
.
.
.
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
.
.
BBB
.
.
.
|
.
.
.
.
.
.
.
.
.
bbb
.
.
"
OK
}
{
"
BBB
.
.
.
.
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
.
.
.
bbb
.
"
OK
}
{
"
.
BBB
.
.
.
.
.
.
.
.
.
.
|
.
.
bbb
.
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
.
BBB
.
.
.
.
|
.
.
.
.
.
.
.
.
bbb
.
.
.
"
OK
}
{
"
.
BBB
.
.
.
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
.
bbb
.
.
.
"
OK
}
{
"
BBBBBB
.
.
.
.
.
.
.
.
|
bbb
.
.
.
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
.
.
BBBB
.
.
|
.
.
.
.
.
.
.
.
.
bbb
.
.
"
OK
}
{
"
BBBBBB
.
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
.
.
.
bbb
.
"
OK
}
{
"
.
BBBBBB
.
.
.
.
.
.
.
|
.
.
bbb
.
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
.
BBBBB
.
.
|
.
.
.
.
.
.
.
.
bbb
.
.
.
"
OK
}
{
"
.
BBB
.
.
.
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
.
bbb
.
.
.
"
OK
}
{
"
.
.
BBB
.
.
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
.
bbb
.
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
.
BB
.
.
.
.
.
.
.
.
.
|
.
.
.
.
bb
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
BB
.
.
.
.
.
.
.
.
|
.
.
.
.
.
bb
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
.
BB
.
.
.
.
.
|
.
.
.
.
.
.
.
.
bb
.
.
.
.
"
OK
}
{
"
.
.
.
BBBBBB
.
.
.
.
.
|
.
.
.
.
bbbbbb
.
.
.
.
"
OK
}
{
"
.
.
BBBBBB
.
.
.
.
.
.
|
.
.
.
bbbbbb
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
BBBBBB
.
.
|
.
.
.
.
.
.
.
bbbbbb
.
"
OK
}
{
"
BBBBBBBBBBBBBB
|
bbbbbbbbbbbbbb
"
AT
:
:
kErrorBadOverlap
}
{
"
B
.
.
.
.
.
.
.
.
.
.
.
.
.
|
b
.
.
.
.
.
.
.
.
.
.
.
.
.
"
OK
}
{
"
B
.
.
.
.
.
.
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
.
.
.
.
.
.
b
"
OK
}
{
"
.
.
.
.
B
.
.
.
.
.
.
.
.
.
|
.
.
.
.
.
b
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
B
.
.
.
.
.
.
.
.
.
|
.
.
.
.
.
.
b
.
.
.
.
.
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
.
.
B
.
.
.
.
.
.
.
.
.
|
.
.
.
.
.
.
b
.
.
.
.
.
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
.
.
BBB
.
.
.
.
.
.
.
|
.
.
.
.
.
bb
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
BBBB
.
.
.
.
.
.
|
.
.
.
.
.
bbb
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
.
.
.
BBBBB
|
.
b
.
.
.
.
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
AAA
.
.
.
.
.
.
.
|
.
.
.
.
.
!
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
!
.
.
.
.
.
.
.
.
.
|
.
.
.
.
.
!
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
!
.
.
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
.
.
.
!
.
.
.
"
OK
}
}
;
TwoUnitOverlapTester
:
:
RunTest
(
unit_str1
test_cases
)
;
}
TEST
(
AddressTranslatorTest
OverlapOffsetMultiple
)
{
using
AT
=
AddressTranslator
;
SimpleTest
(
{
"
A
.
.
|
a
.
.
.
.
"
"
.
A
.
|
.
.
a
.
.
"
"
.
.
A
|
.
.
.
.
a
"
}
AT
:
:
kSuccess
"
Case
#
0
"
)
;
SimpleTest
(
{
"
.
.
A
|
a
.
.
.
.
"
"
.
AA
|
.
.
a
.
.
"
"
AAA
|
.
.
.
.
a
"
}
AT
:
:
kSuccess
"
Case
#
1
"
)
;
SimpleTest
(
{
"
A
.
.
|
a
.
.
.
.
"
"
.
A
.
|
.
.
a
.
.
"
"
.
A
.
|
.
.
.
.
a
"
}
AT
:
:
kErrorBadOverlap
"
Case
#
2
"
)
;
}
TEST
(
AddressTranslatorTest
OverlapDangling
)
{
using
AT
=
AddressTranslator
;
constexpr
auto
OK
=
AT
:
:
kSuccess
;
constexpr
const
char
*
unit_str1
=
"
.
.
.
.
AAA
.
.
.
.
.
.
.
|
.
.
.
.
.
aaaaaa
.
.
.
"
;
std
:
:
vector
<
TwoUnitOverlapTester
:
:
TestCase
>
test_cases
=
{
{
"
.
.
.
.
BBB
.
.
.
.
.
.
.
|
.
.
.
.
.
bbbbbb
.
.
.
"
OK
}
{
"
.
.
.
.
BBB
.
.
.
.
.
.
.
|
.
.
.
.
.
bbbbb
.
.
.
.
"
OK
}
{
"
.
.
.
.
BBB
.
.
.
.
.
.
.
|
.
.
.
.
.
bbbb
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
BBB
.
.
.
.
.
.
.
|
.
.
.
.
.
bbb
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
BBB
.
.
.
.
.
.
|
.
.
.
.
.
.
bbb
.
.
.
.
.
"
AT
:
:
kErrorBadOverlapDanglingRva
}
{
"
.
.
.
.
.
BB
.
.
.
.
.
.
.
|
.
.
.
.
.
.
bbb
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
BBB
.
.
.
.
.
.
.
|
.
.
.
.
.
bbbbbbbb
.
"
OK
}
{
"
.
.
BBBBB
.
.
.
.
.
.
.
|
.
.
.
bbbbbbbb
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
!
.
.
.
.
.
.
.
|
.
bbb
.
.
.
.
.
.
.
.
.
.
"
AT
:
:
kErrorBadOverlap
}
{
"
.
.
BBBBB
.
.
.
.
.
.
.
|
.
.
.
bbbbb
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
.
BBB
.
.
.
.
|
.
bbb
.
.
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
.
BBB
.
.
.
.
|
.
bbbb
.
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
.
!
.
.
.
.
.
.
|
.
bbbb
.
.
.
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
!
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
!
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
!
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
b
.
.
.
.
.
.
"
AT
:
:
kErrorBadOverlapDanglingRva
}
{
"
.
.
.
.
.
.
B
.
.
.
.
.
.
.
|
.
.
.
.
.
.
.
b
.
.
.
.
.
.
"
OK
}
{
"
.
.
.
.
.
.
BBBB
.
.
.
.
|
.
.
.
.
.
.
.
bbbb
.
.
.
"
AT
:
:
kErrorBadOverlapDanglingRva
}
{
"
.
.
.
.
.
.
BB
.
.
.
.
.
.
|
.
.
.
.
.
.
.
bb
.
.
.
.
.
"
AT
:
:
kErrorBadOverlapDanglingRva
}
{
"
.
.
.
.
.
.
BB
.
.
.
.
.
.
|
bb
.
.
.
.
.
.
.
.
.
.
.
.
"
AT
:
:
kErrorBadOverlap
}
}
;
TwoUnitOverlapTester
:
:
RunTest
(
unit_str1
test_cases
)
;
}
TEST
(
AddressTranslatorTest
Merge
)
{
using
AT
=
AddressTranslator
;
std
:
:
vector
<
std
:
:
string
>
test_case1
=
{
"
AAA
.
.
.
.
.
.
.
|
.
aaa
.
.
.
.
.
.
"
"
AA
.
.
.
.
.
.
.
.
|
.
aa
.
.
.
.
.
.
.
"
"
.
.
AAA
.
.
.
.
.
|
.
.
.
aaa
.
.
.
.
"
"
.
.
.
.
A
.
.
.
.
.
|
.
.
.
.
.
a
.
.
.
.
"
"
.
.
.
.
.
AAA
.
.
|
.
.
.
.
.
.
aaa
.
"
"
.
.
.
.
.
.
.
.
A
.
|
.
.
.
.
.
.
.
.
.
a
"
}
;
std
:
:
sort
(
test_case1
.
begin
(
)
test_case1
.
end
(
)
)
;
do
{
TestAddressTranslator
translator1
;
EXPECT_EQ
(
AT
:
:
kSuccess
translator1
.
InitializeWithStrings
(
test_case1
)
)
;
EXPECT_EQ
(
9U
translator1
.
fake_offset_begin
(
)
)
;
AT
:
:
Unit
expected
{
0U
+
9U
1U
+
9U
}
;
EXPECT_EQ
(
1U
translator1
.
units_sorted_by_offset
(
)
.
size
(
)
)
;
EXPECT_EQ
(
expected
translator1
.
units_sorted_by_offset
(
)
[
0
]
)
;
EXPECT_EQ
(
1U
translator1
.
units_sorted_by_rva
(
)
.
size
(
)
)
;
EXPECT_EQ
(
expected
translator1
.
units_sorted_by_rva
(
)
[
0
]
)
;
}
while
(
std
:
:
next_permutation
(
test_case1
.
begin
(
)
test_case1
.
end
(
)
)
)
;
std
:
:
vector
<
std
:
:
string
>
test_case2
=
{
"
.
.
.
.
.
A
.
.
|
.
a
.
.
.
.
.
.
"
"
.
.
.
.
.
.
A
.
|
.
.
a
.
.
.
.
.
"
"
A
.
.
.
.
.
.
.
|
.
.
.
a
.
.
.
.
"
"
.
A
.
.
.
.
.
.
|
.
.
.
.
a
.
.
.
"
"
.
.
A
.
.
.
.
.
|
.
.
.
.
.
a
.
.
"
}
;
std
:
:
sort
(
test_case2
.
begin
(
)
test_case2
.
end
(
)
)
;
do
{
TestAddressTranslator
translator2
;
EXPECT_EQ
(
AT
:
:
kSuccess
translator2
.
InitializeWithStrings
(
test_case2
)
)
;
EXPECT_EQ
(
7U
translator2
.
fake_offset_begin
(
)
)
;
AT
:
:
Unit
expected1
{
0U
+
3U
3U
+
3U
}
;
AT
:
:
Unit
expected2
{
5U
+
2U
1U
+
2U
}
;
EXPECT_EQ
(
2U
translator2
.
units_sorted_by_offset
(
)
.
size
(
)
)
;
EXPECT_EQ
(
expected1
translator2
.
units_sorted_by_offset
(
)
[
0
]
)
;
EXPECT_EQ
(
expected2
translator2
.
units_sorted_by_offset
(
)
[
1
]
)
;
EXPECT_EQ
(
2U
translator2
.
units_sorted_by_rva
(
)
.
size
(
)
)
;
EXPECT_EQ
(
expected2
translator2
.
units_sorted_by_rva
(
)
[
0
]
)
;
EXPECT_EQ
(
expected1
translator2
.
units_sorted_by_rva
(
)
[
1
]
)
;
}
while
(
std
:
:
next_permutation
(
test_case2
.
begin
(
)
test_case2
.
end
(
)
)
)
;
}
TEST
(
AddressTranslatorTest
RvaToOffsetCache_IsValid
)
{
AddressTranslator
translator
;
ASSERT_EQ
(
AddressTranslator
:
:
kSuccess
translator
.
Initialize
(
{
{
0x04
+
0x28
0x1A00
+
0x28
}
{
0x30
+
0x10
0x3A00
+
0x30
}
}
)
)
;
AddressTranslator
:
:
RvaToOffsetCache
rva_checker
(
translator
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
kInvalidRva
)
)
;
for
(
int
i
=
0
;
i
<
0x28
;
+
+
i
)
EXPECT_TRUE
(
rva_checker
.
IsValid
(
0x1A00
+
i
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0x1A00
+
0x28
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0x1A00
+
0x29
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0x1A00
-
1
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0x1A00
-
2
)
)
;
for
(
int
i
=
0
;
i
<
0x30
;
+
+
i
)
EXPECT_TRUE
(
rva_checker
.
IsValid
(
0x3A00
+
i
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0x3A00
+
0x30
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0x3A00
+
0x31
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0x3A00
-
1
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0x3A00
-
2
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0x10
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0x7FFFFFFFU
)
)
;
EXPECT_FALSE
(
rva_checker
.
IsValid
(
0xFFFFFFFFU
)
)
;
}
}
