#
include
"
components
/
zucchini
/
address_translator
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
base
/
containers
/
cxx20_erase
.
h
"
namespace
zucchini
{
AddressTranslator
:
:
OffsetToRvaCache
:
:
OffsetToRvaCache
(
const
AddressTranslator
&
translator
)
:
translator_
(
translator
)
{
}
rva_t
AddressTranslator
:
:
OffsetToRvaCache
:
:
Convert
(
offset_t
offset
)
const
{
if
(
offset
>
=
translator_
-
>
fake_offset_begin_
)
{
return
translator_
-
>
OffsetToRva
(
offset
)
;
}
if
(
cached_unit_
&
&
cached_unit_
-
>
CoversOffset
(
offset
)
)
return
cached_unit_
-
>
OffsetToRvaUnsafe
(
offset
)
;
const
AddressTranslator
:
:
Unit
*
unit
=
translator_
-
>
OffsetToUnit
(
offset
)
;
if
(
!
unit
)
return
kInvalidRva
;
cached_unit_
=
unit
;
return
unit
-
>
OffsetToRvaUnsafe
(
offset
)
;
}
AddressTranslator
:
:
RvaToOffsetCache
:
:
RvaToOffsetCache
(
const
AddressTranslator
&
translator
)
:
translator_
(
translator
)
{
}
bool
AddressTranslator
:
:
RvaToOffsetCache
:
:
IsValid
(
rva_t
rva
)
const
{
if
(
rva
=
=
kInvalidRva
)
return
false
;
if
(
!
cached_unit_
|
|
!
cached_unit_
-
>
CoversRva
(
rva
)
)
{
const
AddressTranslator
:
:
Unit
*
unit
=
translator_
-
>
RvaToUnit
(
rva
)
;
if
(
!
unit
)
return
false
;
cached_unit_
=
unit
;
}
return
true
;
}
offset_t
AddressTranslator
:
:
RvaToOffsetCache
:
:
Convert
(
rva_t
rva
)
const
{
if
(
!
cached_unit_
|
|
!
cached_unit_
-
>
CoversRva
(
rva
)
)
{
const
AddressTranslator
:
:
Unit
*
unit
=
translator_
-
>
RvaToUnit
(
rva
)
;
if
(
!
unit
)
return
kInvalidOffset
;
cached_unit_
=
unit
;
}
return
cached_unit_
-
>
RvaToOffsetUnsafe
(
rva
translator_
-
>
fake_offset_begin_
)
;
}
AddressTranslator
:
:
AddressTranslator
(
)
=
default
;
AddressTranslator
:
:
AddressTranslator
(
AddressTranslator
&
&
)
=
default
;
AddressTranslator
:
:
~
AddressTranslator
(
)
=
default
;
AddressTranslator
:
:
Status
AddressTranslator
:
:
Initialize
(
std
:
:
vector
<
Unit
>
&
&
units
)
{
for
(
Unit
&
unit
:
units
)
{
if
(
!
RangeIsBounded
<
offset_t
>
(
unit
.
offset_begin
unit
.
offset_size
kOffsetBound
)
|
|
!
RangeIsBounded
<
rva_t
>
(
unit
.
rva_begin
unit
.
rva_size
kRvaBound
)
)
{
return
kErrorOverflow
;
}
unit
.
offset_size
=
std
:
:
min
(
unit
.
offset_size
unit
.
rva_size
)
;
}
base
:
:
EraseIf
(
units
[
]
(
const
Unit
&
unit
)
{
return
unit
.
IsEmpty
(
)
;
}
)
;
std
:
:
sort
(
units
.
begin
(
)
units
.
end
(
)
[
]
(
const
Unit
&
a
const
Unit
&
b
)
{
return
std
:
:
tie
(
a
.
rva_begin
a
.
rva_size
)
<
std
:
:
tie
(
b
.
rva_begin
b
.
rva_size
)
;
}
)
;
units
.
erase
(
std
:
:
unique
(
units
.
begin
(
)
units
.
end
(
)
)
units
.
end
(
)
)
;
if
(
units
.
size
(
)
>
1
)
{
auto
slow
=
units
.
begin
(
)
;
for
(
auto
fast
=
slow
+
1
;
fast
!
=
units
.
end
(
)
;
+
+
fast
)
{
DCHECK_GE
(
fast
-
>
rva_begin
slow
-
>
rva_begin
)
;
if
(
slow
-
>
rva_end
(
)
<
fast
-
>
rva_begin
)
{
*
(
+
+
slow
)
=
*
fast
;
continue
;
}
bool
merge_is_optional
=
slow
-
>
rva_end
(
)
=
=
fast
-
>
rva_begin
;
if
(
fast
-
>
offset_begin
<
slow
-
>
offset_begin
|
|
fast
-
>
offset_begin
-
slow
-
>
offset_begin
!
=
fast
-
>
rva_begin
-
slow
-
>
rva_begin
)
{
if
(
merge_is_optional
)
{
*
(
+
+
slow
)
=
*
fast
;
continue
;
}
return
kErrorBadOverlap
;
}
if
(
(
fast
-
>
HasDanglingRva
(
)
&
&
fast
-
>
offset_end
(
)
<
slow
-
>
offset_end
(
)
)
|
|
(
slow
-
>
HasDanglingRva
(
)
&
&
slow
-
>
offset_end
(
)
<
fast
-
>
offset_end
(
)
)
)
{
if
(
merge_is_optional
)
{
*
(
+
+
slow
)
=
*
fast
;
continue
;
}
return
kErrorBadOverlapDanglingRva
;
}
slow
-
>
rva_size
=
std
:
:
max
(
slow
-
>
rva_size
fast
-
>
rva_end
(
)
-
slow
-
>
rva_begin
)
;
slow
-
>
offset_size
=
std
:
:
max
(
slow
-
>
offset_size
fast
-
>
offset_end
(
)
-
slow
-
>
offset_begin
)
;
}
+
+
slow
;
units
.
erase
(
slow
units
.
end
(
)
)
;
}
std
:
:
sort
(
units
.
begin
(
)
units
.
end
(
)
[
]
(
const
Unit
&
a
const
Unit
&
b
)
{
return
a
.
offset_begin
<
b
.
offset_begin
;
}
)
;
if
(
units
.
size
(
)
>
1
)
{
auto
previous
=
units
.
begin
(
)
;
for
(
auto
current
=
previous
+
1
;
current
!
=
units
.
end
(
)
;
+
+
current
)
{
if
(
previous
-
>
offset_end
(
)
>
current
-
>
offset_begin
)
return
kErrorBadOverlap
;
previous
=
current
;
}
}
offset_t
offset_bound
=
0
;
rva_t
rva_bound
=
0
;
for
(
const
Unit
&
unit
:
units
)
{
offset_bound
=
std
:
:
max
(
offset_bound
unit
.
offset_end
(
)
)
;
rva_bound
=
std
:
:
max
(
rva_bound
unit
.
rva_end
(
)
)
;
}
if
(
!
RangeIsBounded
(
offset_bound
rva_bound
kOffsetBound
)
)
return
kErrorFakeOffsetBeginTooLarge
;
units_sorted_by_offset_
.
assign
(
units
.
begin
(
)
units
.
end
(
)
)
;
std
:
:
sort
(
units
.
begin
(
)
units
.
end
(
)
[
]
(
const
Unit
&
a
const
Unit
&
b
)
{
return
a
.
rva_begin
<
b
.
rva_begin
;
}
)
;
units_sorted_by_rva_
=
std
:
:
move
(
units
)
;
fake_offset_begin_
=
offset_bound
;
return
kSuccess
;
}
rva_t
AddressTranslator
:
:
OffsetToRva
(
offset_t
offset
)
const
{
if
(
offset
>
=
fake_offset_begin_
)
{
rva_t
rva
=
offset
-
fake_offset_begin_
;
const
Unit
*
unit
=
RvaToUnit
(
rva
)
;
return
(
unit
&
&
unit
-
>
HasDanglingRva
(
)
&
&
unit
-
>
CoversDanglingRva
(
rva
)
)
?
rva
:
kInvalidRva
;
}
const
Unit
*
unit
=
OffsetToUnit
(
offset
)
;
return
unit
?
unit
-
>
OffsetToRvaUnsafe
(
offset
)
:
kInvalidRva
;
}
offset_t
AddressTranslator
:
:
RvaToOffset
(
rva_t
rva
)
const
{
const
Unit
*
unit
=
RvaToUnit
(
rva
)
;
return
unit
?
unit
-
>
RvaToOffsetUnsafe
(
rva
fake_offset_begin_
)
:
kInvalidOffset
;
}
const
AddressTranslator
:
:
Unit
*
AddressTranslator
:
:
OffsetToUnit
(
offset_t
offset
)
const
{
auto
it
=
std
:
:
upper_bound
(
units_sorted_by_offset_
.
begin
(
)
units_sorted_by_offset_
.
end
(
)
offset
[
]
(
offset_t
a
const
Unit
&
b
)
{
return
a
<
b
.
offset_begin
;
}
)
;
if
(
it
=
=
units_sorted_by_offset_
.
begin
(
)
)
return
nullptr
;
-
-
it
;
return
it
-
>
CoversOffset
(
offset
)
?
&
(
*
it
)
:
nullptr
;
}
const
AddressTranslator
:
:
Unit
*
AddressTranslator
:
:
RvaToUnit
(
rva_t
rva
)
const
{
auto
it
=
std
:
:
upper_bound
(
units_sorted_by_rva_
.
begin
(
)
units_sorted_by_rva_
.
end
(
)
rva
[
]
(
rva_t
a
const
Unit
&
b
)
{
return
a
<
b
.
rva_begin
;
}
)
;
if
(
it
=
=
units_sorted_by_rva_
.
begin
(
)
)
return
nullptr
;
-
-
it
;
return
it
-
>
CoversRva
(
rva
)
?
&
(
*
it
)
:
nullptr
;
}
}
