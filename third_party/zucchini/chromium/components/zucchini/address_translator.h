#
ifndef
COMPONENTS_ZUCCHINI_ADDRESS_TRANSLATOR_H_
#
define
COMPONENTS_ZUCCHINI_ADDRESS_TRANSLATOR_H_
#
include
<
stdint
.
h
>
#
include
<
tuple
>
#
include
<
vector
>
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
base
/
memory
/
raw_ref
.
h
"
#
include
"
components
/
zucchini
/
algorithm
.
h
"
#
include
"
components
/
zucchini
/
image_utils
.
h
"
namespace
zucchini
{
using
rva_t
=
uint32_t
;
constexpr
rva_t
kRvaBound
=
static_cast
<
rva_t
>
(
-
1
)
/
2
;
constexpr
rva_t
kInvalidRva
=
static_cast
<
rva_t
>
(
-
2
)
;
class
AddressTranslator
{
public
:
struct
Unit
{
offset_t
offset_end
(
)
const
{
return
offset_begin
+
offset_size
;
}
rva_t
rva_end
(
)
const
{
return
rva_begin
+
rva_size
;
}
bool
IsEmpty
(
)
const
{
return
rva_size
=
=
0
;
}
bool
CoversOffset
(
offset_t
offset
)
const
{
return
RangeCovers
(
offset_begin
offset_size
offset
)
;
}
bool
CoversRva
(
rva_t
rva
)
const
{
return
RangeCovers
(
rva_begin
rva_size
rva
)
;
}
bool
CoversDanglingRva
(
rva_t
rva
)
const
{
return
CoversRva
(
rva
)
&
&
rva
-
rva_begin
>
=
offset_size
;
}
rva_t
OffsetToRvaUnsafe
(
offset_t
offset
)
const
{
return
offset
-
offset_begin
+
rva_begin
;
}
offset_t
RvaToOffsetUnsafe
(
rva_t
rva
offset_t
fake_offset_begin
)
const
{
rva_t
delta
=
rva
-
rva_begin
;
return
delta
<
offset_size
?
delta
+
offset_begin
:
fake_offset_begin
+
rva
;
}
bool
HasDanglingRva
(
)
const
{
return
rva_size
>
offset_size
;
}
friend
bool
operator
=
=
(
const
Unit
&
a
const
Unit
&
b
)
{
return
std
:
:
tie
(
a
.
offset_begin
a
.
offset_size
a
.
rva_begin
a
.
rva_size
)
=
=
std
:
:
tie
(
b
.
offset_begin
b
.
offset_size
b
.
rva_begin
b
.
rva_size
)
;
}
offset_t
offset_begin
;
offset_t
offset_size
;
rva_t
rva_begin
;
rva_t
rva_size
;
}
;
class
OffsetToRvaCache
{
public
:
explicit
OffsetToRvaCache
(
const
AddressTranslator
&
translator
)
;
OffsetToRvaCache
(
const
OffsetToRvaCache
&
)
=
delete
;
const
OffsetToRvaCache
&
operator
=
(
const
OffsetToRvaCache
&
)
=
delete
;
rva_t
Convert
(
offset_t
offset
)
const
;
private
:
const
raw_ref
<
const
AddressTranslator
>
translator_
;
mutable
raw_ptr
<
const
AddressTranslator
:
:
Unit
>
cached_unit_
=
nullptr
;
}
;
class
RvaToOffsetCache
{
public
:
explicit
RvaToOffsetCache
(
const
AddressTranslator
&
translator
)
;
RvaToOffsetCache
(
const
RvaToOffsetCache
&
)
=
delete
;
const
RvaToOffsetCache
&
operator
=
(
const
RvaToOffsetCache
&
)
=
delete
;
bool
IsValid
(
rva_t
rva
)
const
;
offset_t
Convert
(
rva_t
rva
)
const
;
private
:
const
raw_ref
<
const
AddressTranslator
>
translator_
;
mutable
raw_ptr
<
const
AddressTranslator
:
:
Unit
>
cached_unit_
=
nullptr
;
}
;
enum
Status
{
kSuccess
=
0
kErrorOverflow
kErrorBadOverlap
kErrorBadOverlapDanglingRva
kErrorFakeOffsetBeginTooLarge
}
;
AddressTranslator
(
)
;
AddressTranslator
(
AddressTranslator
&
&
)
;
AddressTranslator
(
const
AddressTranslator
&
)
=
delete
;
const
AddressTranslator
&
operator
=
(
const
AddressTranslator
&
)
=
delete
;
~
AddressTranslator
(
)
;
Status
Initialize
(
std
:
:
vector
<
Unit
>
&
&
units
)
;
rva_t
OffsetToRva
(
offset_t
offset
)
const
;
offset_t
RvaToOffset
(
rva_t
rva
)
const
;
offset_t
fake_offset_begin
(
)
const
{
return
fake_offset_begin_
;
}
const
std
:
:
vector
<
Unit
>
&
units_sorted_by_offset
(
)
const
{
return
units_sorted_by_offset_
;
}
const
std
:
:
vector
<
Unit
>
&
units_sorted_by_rva
(
)
const
{
return
units_sorted_by_rva_
;
}
private
:
const
Unit
*
OffsetToUnit
(
offset_t
offset
)
const
;
const
Unit
*
RvaToUnit
(
rva_t
rva
)
const
;
std
:
:
vector
<
Unit
>
units_sorted_by_offset_
;
std
:
:
vector
<
Unit
>
units_sorted_by_rva_
;
offset_t
fake_offset_begin_
;
}
;
}
#
endif
