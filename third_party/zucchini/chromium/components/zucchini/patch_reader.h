#
ifndef
COMPONENTS_ZUCCHINI_PATCH_READER_H_
#
define
COMPONENTS_ZUCCHINI_PATCH_READER_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
map
>
#
include
<
vector
>
#
include
"
base
/
debug
/
stack_trace
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
numerics
/
checked_math
.
h
"
#
include
"
components
/
zucchini
/
buffer_source
.
h
"
#
include
"
components
/
zucchini
/
buffer_view
.
h
"
#
include
"
components
/
zucchini
/
image_utils
.
h
"
#
include
"
components
/
zucchini
/
patch_utils
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
types
/
optional
.
h
"
namespace
zucchini
{
namespace
patch
{
bool
ParseElementMatch
(
BufferSource
*
source
ElementMatch
*
element_match
)
;
bool
ParseBuffer
(
BufferSource
*
source
BufferSource
*
buffer
)
;
template
<
class
T
>
bool
ParseVarUInt
(
BufferSource
*
source
T
*
value
)
{
auto
bytes_read
=
DecodeVarUInt
(
source
-
>
begin
(
)
source
-
>
end
(
)
value
)
;
if
(
!
bytes_read
)
{
LOG
(
ERROR
)
<
<
"
Impossible
to
read
VarUInt
from
source
.
"
;
LOG
(
ERROR
)
<
<
base
:
:
debug
:
:
StackTrace
(
)
.
ToString
(
)
;
return
false
;
}
return
source
-
>
Skip
(
bytes_read
)
;
}
template
<
class
T
>
bool
ParseVarInt
(
BufferSource
*
source
T
*
value
)
{
auto
bytes_read
=
DecodeVarInt
(
source
-
>
begin
(
)
source
-
>
end
(
)
value
)
;
if
(
!
bytes_read
)
{
LOG
(
ERROR
)
<
<
"
Impossible
to
read
VarInt
from
source
.
"
;
LOG
(
ERROR
)
<
<
base
:
:
debug
:
:
StackTrace
(
)
.
ToString
(
)
;
return
false
;
}
return
source
-
>
Skip
(
bytes_read
)
;
}
}
class
EquivalenceSource
{
public
:
EquivalenceSource
(
)
;
EquivalenceSource
(
const
EquivalenceSource
&
)
;
~
EquivalenceSource
(
)
;
bool
Initialize
(
BufferSource
*
source
)
;
absl
:
:
optional
<
Equivalence
>
GetNext
(
)
;
bool
Done
(
)
const
{
return
src_skip_
.
empty
(
)
&
&
dst_skip_
.
empty
(
)
&
&
copy_count_
.
empty
(
)
;
}
BufferSource
src_skip
(
)
const
{
return
src_skip_
;
}
BufferSource
dst_skip
(
)
const
{
return
dst_skip_
;
}
BufferSource
copy_count
(
)
const
{
return
copy_count_
;
}
private
:
BufferSource
src_skip_
;
BufferSource
dst_skip_
;
BufferSource
copy_count_
;
base
:
:
CheckedNumeric
<
offset_t
>
previous_src_offset_
=
0
;
base
:
:
CheckedNumeric
<
offset_t
>
previous_dst_offset_
=
0
;
}
;
class
ExtraDataSource
{
public
:
ExtraDataSource
(
)
;
ExtraDataSource
(
const
ExtraDataSource
&
)
;
~
ExtraDataSource
(
)
;
bool
Initialize
(
BufferSource
*
source
)
;
absl
:
:
optional
<
ConstBufferView
>
GetNext
(
offset_t
size
)
;
bool
Done
(
)
const
{
return
extra_data_
.
empty
(
)
;
}
BufferSource
extra_data
(
)
const
{
return
extra_data_
;
}
private
:
BufferSource
extra_data_
;
}
;
class
RawDeltaSource
{
public
:
RawDeltaSource
(
)
;
RawDeltaSource
(
const
RawDeltaSource
&
)
;
~
RawDeltaSource
(
)
;
bool
Initialize
(
BufferSource
*
source
)
;
absl
:
:
optional
<
RawDeltaUnit
>
GetNext
(
)
;
bool
Done
(
)
const
{
return
raw_delta_skip_
.
empty
(
)
&
&
raw_delta_diff_
.
empty
(
)
;
}
BufferSource
raw_delta_skip
(
)
const
{
return
raw_delta_skip_
;
}
BufferSource
raw_delta_diff
(
)
const
{
return
raw_delta_diff_
;
}
private
:
BufferSource
raw_delta_skip_
;
BufferSource
raw_delta_diff_
;
base
:
:
CheckedNumeric
<
offset_t
>
copy_offset_compensation_
=
0
;
}
;
class
ReferenceDeltaSource
{
public
:
ReferenceDeltaSource
(
)
;
ReferenceDeltaSource
(
const
ReferenceDeltaSource
&
)
;
~
ReferenceDeltaSource
(
)
;
bool
Initialize
(
BufferSource
*
source
)
;
absl
:
:
optional
<
int32_t
>
GetNext
(
)
;
bool
Done
(
)
const
{
return
source_
.
empty
(
)
;
}
BufferSource
reference_delta
(
)
const
{
return
source_
;
}
private
:
BufferSource
source_
;
}
;
class
TargetSource
{
public
:
TargetSource
(
)
;
TargetSource
(
const
TargetSource
&
)
;
~
TargetSource
(
)
;
bool
Initialize
(
BufferSource
*
source
)
;
absl
:
:
optional
<
offset_t
>
GetNext
(
)
;
bool
Done
(
)
const
{
return
extra_targets_
.
empty
(
)
;
}
BufferSource
extra_targets
(
)
const
{
return
extra_targets_
;
}
private
:
BufferSource
extra_targets_
;
base
:
:
CheckedNumeric
<
offset_t
>
target_compensation_
=
0
;
}
;
class
PatchElementReader
{
public
:
PatchElementReader
(
)
;
PatchElementReader
(
PatchElementReader
&
&
)
;
~
PatchElementReader
(
)
;
bool
Initialize
(
BufferSource
*
source
)
;
const
ElementMatch
&
element_match
(
)
const
{
return
element_match_
;
}
const
Element
&
old_element
(
)
const
{
return
element_match_
.
old_element
;
}
const
Element
&
new_element
(
)
const
{
return
element_match_
.
new_element
;
}
EquivalenceSource
GetEquivalenceSource
(
)
const
{
return
equivalences_
;
}
ExtraDataSource
GetExtraDataSource
(
)
const
{
return
extra_data_
;
}
RawDeltaSource
GetRawDeltaSource
(
)
const
{
return
raw_delta_
;
}
ReferenceDeltaSource
GetReferenceDeltaSource
(
)
const
{
return
reference_delta_
;
}
TargetSource
GetExtraTargetSource
(
PoolTag
tag
)
const
{
auto
pos
=
extra_targets_
.
find
(
tag
)
;
return
pos
!
=
extra_targets_
.
end
(
)
?
pos
-
>
second
:
TargetSource
(
)
;
}
private
:
bool
ValidateEquivalencesAndExtraData
(
)
;
ElementMatch
element_match_
;
EquivalenceSource
equivalences_
;
ExtraDataSource
extra_data_
;
RawDeltaSource
raw_delta_
;
ReferenceDeltaSource
reference_delta_
;
std
:
:
map
<
PoolTag
TargetSource
>
extra_targets_
;
}
;
class
EnsemblePatchReader
{
public
:
static
absl
:
:
optional
<
EnsemblePatchReader
>
Create
(
ConstBufferView
buffer
)
;
EnsemblePatchReader
(
)
;
EnsemblePatchReader
(
EnsemblePatchReader
&
&
)
;
~
EnsemblePatchReader
(
)
;
bool
Initialize
(
BufferSource
*
source
)
;
bool
CheckOldFile
(
ConstBufferView
old_image
)
const
;
bool
CheckNewFile
(
ConstBufferView
new_image
)
const
;
const
PatchHeader
&
header
(
)
const
{
return
header_
;
}
const
std
:
:
vector
<
PatchElementReader
>
&
elements
(
)
const
{
return
elements_
;
}
private
:
PatchHeader
header_
;
std
:
:
vector
<
PatchElementReader
>
elements_
;
}
;
}
#
endif
