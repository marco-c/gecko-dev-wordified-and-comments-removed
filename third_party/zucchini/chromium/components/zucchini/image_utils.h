#
ifndef
COMPONENTS_ZUCCHINI_IMAGE_UTILS_H_
#
define
COMPONENTS_ZUCCHINI_IMAGE_UTILS_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
"
base
/
format_macros
.
h
"
#
include
"
base
/
numerics
/
safe_conversions
.
h
"
#
include
"
base
/
strings
/
stringprintf
.
h
"
#
include
"
components
/
zucchini
/
buffer_view
.
h
"
#
include
"
components
/
zucchini
/
typed_value
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
types
/
optional
.
h
"
namespace
zucchini
{
using
offset_t
=
uint32_t
;
constexpr
offset_t
kOffsetBound
=
static_cast
<
offset_t
>
(
-
1
)
/
2
;
constexpr
offset_t
kInvalidOffset
=
static_cast
<
offset_t
>
(
-
2
)
;
using
key_t
=
uint32_t
;
enum
Bitness
:
uint8_t
{
kBit32
=
4
kBit64
=
8
}
;
inline
uint32_t
WidthOf
(
Bitness
bitness
)
{
return
static_cast
<
uint32_t
>
(
bitness
)
;
}
struct
TypeTag
:
public
TypedValue
<
TypeTag
uint8_t
>
{
using
TypedValue
<
TypeTag
uint8_t
>
:
:
TypedValue
;
}
;
struct
PoolTag
:
public
TypedValue
<
PoolTag
uint8_t
>
{
using
TypedValue
<
PoolTag
uint8_t
>
:
:
TypedValue
;
}
;
constexpr
TypeTag
kNoTypeTag
(
0xFF
)
;
constexpr
PoolTag
kNoPoolTag
(
0xFF
)
;
struct
ReferenceTypeTraits
{
constexpr
ReferenceTypeTraits
(
offset_t
width_in
TypeTag
type_tag_in
PoolTag
pool_tag_in
)
:
width
(
width_in
)
type_tag
(
type_tag_in
)
pool_tag
(
pool_tag_in
)
{
}
const
offset_t
width
;
const
TypeTag
type_tag
;
const
PoolTag
pool_tag
;
}
;
struct
Reference
{
offset_t
location
;
offset_t
target
;
}
;
inline
bool
operator
=
=
(
const
Reference
&
a
const
Reference
&
b
)
{
return
a
.
location
=
=
b
.
location
&
&
a
.
target
=
=
b
.
target
;
}
class
ReferenceReader
{
public
:
virtual
~
ReferenceReader
(
)
=
default
;
virtual
absl
:
:
optional
<
Reference
>
GetNext
(
)
=
0
;
}
;
class
ReferenceWriter
{
public
:
virtual
~
ReferenceWriter
(
)
=
default
;
virtual
void
PutNext
(
Reference
reference
)
=
0
;
}
;
class
ReferenceMixer
{
public
:
virtual
~
ReferenceMixer
(
)
=
default
;
virtual
ConstBufferView
Mix
(
offset_t
old_offset
offset_t
new_offset
)
=
0
;
}
;
struct
Equivalence
{
offset_t
src_offset
;
offset_t
dst_offset
;
offset_t
length
;
offset_t
src_end
(
)
const
{
return
src_offset
+
length
;
}
offset_t
dst_end
(
)
const
{
return
dst_offset
+
length
;
}
}
;
inline
bool
operator
=
=
(
const
Equivalence
&
a
const
Equivalence
&
b
)
{
return
a
.
src_offset
=
=
b
.
src_offset
&
&
a
.
dst_offset
=
=
b
.
dst_offset
&
&
a
.
length
=
=
b
.
length
;
}
struct
EquivalenceCandidate
{
Equivalence
eq
;
double
similarity
;
}
;
template
<
size_t
N
>
inline
constexpr
uint32_t
ExeTypeToUint32
(
const
char
(
&
exe_type
)
[
N
]
)
{
static_assert
(
N
=
=
5
"
Expected
ExeType
of
length
4
+
1
null
byte
.
"
)
;
return
(
exe_type
[
3
]
<
<
24
)
|
(
exe_type
[
2
]
<
<
16
)
|
(
exe_type
[
1
]
<
<
8
)
|
exe_type
[
0
]
;
}
enum
ExecutableType
:
uint32_t
{
kExeTypeUnknown
=
UINT32_MAX
kExeTypeNoOp
=
ExeTypeToUint32
(
"
NoOp
"
)
kExeTypeWin32X86
=
ExeTypeToUint32
(
"
Px86
"
)
kExeTypeWin32X64
=
ExeTypeToUint32
(
"
Px64
"
)
kExeTypeElfX86
=
ExeTypeToUint32
(
"
Ex86
"
)
kExeTypeElfX64
=
ExeTypeToUint32
(
"
Ex64
"
)
kExeTypeElfAArch32
=
ExeTypeToUint32
(
"
EA32
"
)
kExeTypeElfAArch64
=
ExeTypeToUint32
(
"
EA64
"
)
kExeTypeDex
=
ExeTypeToUint32
(
"
DEX
"
)
kExeTypeZtf
=
ExeTypeToUint32
(
"
ZTF
"
)
}
;
constexpr
ExecutableType
CastToExecutableType
(
uint32_t
possible_exe_type
)
{
switch
(
static_cast
<
ExecutableType
>
(
possible_exe_type
)
)
{
case
kExeTypeNoOp
:
case
kExeTypeWin32X86
:
case
kExeTypeWin32X64
:
case
kExeTypeElfX86
:
case
kExeTypeElfX64
:
case
kExeTypeElfAArch32
:
case
kExeTypeElfAArch64
:
case
kExeTypeDex
:
case
kExeTypeZtf
:
case
kExeTypeUnknown
:
return
static_cast
<
ExecutableType
>
(
possible_exe_type
)
;
default
:
return
kExeTypeUnknown
;
}
}
inline
std
:
:
string
CastExecutableTypeToString
(
ExecutableType
exe_type
)
{
uint32_t
v
=
static_cast
<
uint32_t
>
(
exe_type
)
;
char
result
[
]
=
{
static_cast
<
char
>
(
v
)
static_cast
<
char
>
(
v
>
>
8
)
static_cast
<
char
>
(
v
>
>
16
)
static_cast
<
char
>
(
v
>
>
24
)
0
}
;
return
result
;
}
struct
Element
:
public
BufferRegion
{
Element
(
)
=
default
;
constexpr
Element
(
const
BufferRegion
&
region_in
ExecutableType
exe_type_in
)
:
BufferRegion
(
region_in
)
exe_type
(
exe_type_in
)
{
}
constexpr
explicit
Element
(
const
BufferRegion
&
region_in
)
:
BufferRegion
(
region_in
)
exe_type
(
kExeTypeNoOp
)
{
}
offset_t
BeginOffset
(
)
const
{
return
base
:
:
checked_cast
<
offset_t
>
(
lo
(
)
)
;
}
offset_t
EndOffset
(
)
const
{
return
base
:
:
checked_cast
<
offset_t
>
(
hi
(
)
)
;
}
BufferRegion
region
(
)
const
{
return
{
offset
size
}
;
}
friend
bool
operator
=
=
(
const
Element
&
a
const
Element
&
b
)
{
return
a
.
exe_type
=
=
b
.
exe_type
&
&
a
.
offset
=
=
b
.
offset
&
&
a
.
size
=
=
b
.
size
;
}
ExecutableType
exe_type
;
}
;
struct
ElementMatch
{
bool
IsValid
(
)
const
{
return
old_element
.
exe_type
=
=
new_element
.
exe_type
;
}
ExecutableType
exe_type
(
)
const
{
return
old_element
.
exe_type
;
}
std
:
:
string
ToString
(
)
const
{
return
base
:
:
StringPrintf
(
"
%
"
PRIuS
"
+
%
"
PRIuS
"
=
%
"
PRIuS
"
+
%
"
PRIuS
"
"
old_element
.
offset
old_element
.
size
new_element
.
offset
new_element
.
size
)
;
}
Element
old_element
;
Element
new_element
;
}
;
}
#
endif
