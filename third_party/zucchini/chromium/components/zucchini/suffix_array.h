#
ifndef
COMPONENTS_ZUCCHINI_SUFFIX_ARRAY_H_
#
define
COMPONENTS_ZUCCHINI_SUFFIX_ARRAY_H_
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
<
numeric
>
#
include
<
vector
>
#
include
"
base
/
check
.
h
"
#
include
"
base
/
containers
/
adapters
.
h
"
namespace
zucchini
{
class
NaiveSuffixSort
{
public
:
template
<
class
InputRng
class
KeyType
class
SAIt
>
void
operator
(
)
(
const
InputRng
&
str
KeyType
key_bound
SAIt
suffix_array
)
const
{
using
size_type
=
typename
SAIt
:
:
value_type
;
size_type
n
=
static_cast
<
size_type
>
(
std
:
:
end
(
str
)
-
std
:
:
begin
(
str
)
)
;
std
:
:
iota
(
suffix_array
suffix_array
+
n
0
)
;
std
:
:
sort
(
suffix_array
suffix_array
+
n
[
&
str
]
(
size_type
i
size_type
j
)
{
return
std
:
:
lexicographical_compare
(
std
:
:
begin
(
str
)
+
i
std
:
:
end
(
str
)
std
:
:
begin
(
str
)
+
j
std
:
:
end
(
str
)
)
;
}
)
;
}
}
;
class
InducedSuffixSort
{
public
:
template
<
class
InputRng
class
KeyType
class
SAIt
>
void
operator
(
)
(
const
InputRng
&
str
KeyType
key_bound
SAIt
suffix_array
)
const
{
using
value_type
=
typename
InputRng
:
:
value_type
;
using
size_type
=
typename
SAIt
:
:
value_type
;
static_assert
(
std
:
:
is_unsigned
<
value_type
>
:
:
value
"
SA
-
IS
only
supports
input
string
with
unsigned
values
"
)
;
static_assert
(
std
:
:
is_unsigned
<
KeyType
>
:
:
value
"
KeyType
must
be
unsigned
"
)
;
size_type
n
=
static_cast
<
size_type
>
(
std
:
:
end
(
str
)
-
std
:
:
begin
(
str
)
)
;
Implementation
<
size_type
KeyType
>
:
:
SuffixSort
(
std
:
:
begin
(
str
)
n
key_bound
suffix_array
)
;
}
enum
SLType
:
bool
{
SType
LType
}
;
template
<
class
SizeType
class
KeyType
>
struct
Implementation
{
static_assert
(
std
:
:
is_unsigned
<
SizeType
>
:
:
value
"
SizeType
must
be
unsigned
"
)
;
static_assert
(
std
:
:
is_unsigned
<
KeyType
>
:
:
value
"
KeyType
must
be
unsigned
"
)
;
using
size_type
=
SizeType
;
using
key_type
=
KeyType
;
using
iterator
=
typename
std
:
:
vector
<
size_type
>
:
:
iterator
;
using
const_iterator
=
typename
std
:
:
vector
<
size_type
>
:
:
const_iterator
;
template
<
class
StrIt
>
static
size_type
BuildSLPartition
(
StrIt
str
size_type
length
key_type
key_bound
std
:
:
vector
<
SLType
>
:
:
reverse_iterator
sl_partition_it
)
{
size_type
lms_count
=
0
;
SLType
previous_type
=
LType
;
key_type
previous_key
=
key_bound
;
for
(
auto
str_it
=
std
:
:
reverse_iterator
<
StrIt
>
(
str
+
length
)
;
str_it
!
=
std
:
:
reverse_iterator
<
StrIt
>
(
str
)
;
+
+
str_it
+
+
sl_partition_it
)
{
key_type
current_key
=
*
str_it
;
if
(
current_key
>
previous_key
|
|
previous_key
=
=
key_bound
)
{
if
(
previous_type
=
=
SType
)
+
+
lms_count
;
previous_type
=
LType
;
}
else
if
(
current_key
<
previous_key
)
{
previous_type
=
SType
;
}
*
sl_partition_it
=
previous_type
;
previous_key
=
current_key
;
}
return
lms_count
;
}
static
void
FindLmsSuffixes
(
const
std
:
:
vector
<
SLType
>
&
sl_partition
iterator
lms_indices
)
{
SLType
previous_type
=
SType
;
for
(
size_type
i
=
0
;
i
<
sl_partition
.
size
(
)
;
+
+
i
)
{
if
(
sl_partition
[
i
]
=
=
SType
&
&
previous_type
=
=
LType
)
*
lms_indices
+
+
=
i
;
previous_type
=
sl_partition
[
i
]
;
}
}
template
<
class
StrIt
>
static
std
:
:
vector
<
size_type
>
MakeBucketCount
(
StrIt
str
size_type
length
key_type
key_bound
)
{
std
:
:
vector
<
size_type
>
buckets
(
static_cast
<
size_type
>
(
key_bound
)
)
;
for
(
auto
it
=
str
;
it
!
=
str
+
length
;
+
+
it
)
+
+
buckets
[
*
it
]
;
return
buckets
;
}
template
<
class
StrIt
class
SAIt
>
static
void
InducedSort
(
StrIt
str
size_type
length
const
std
:
:
vector
<
SLType
>
&
sl_partition
const
std
:
:
vector
<
size_type
>
&
lms_indices
const
std
:
:
vector
<
size_type
>
&
buckets
SAIt
suffix_array
)
{
std
:
:
fill
(
suffix_array
suffix_array
+
length
length
)
;
DCHECK
(
!
buckets
.
empty
(
)
)
;
std
:
:
vector
<
size_type
>
bucket_bounds
(
buckets
.
size
(
)
)
;
std
:
:
partial_sum
(
buckets
.
begin
(
)
buckets
.
end
(
)
bucket_bounds
.
begin
(
)
)
;
for
(
size_t
lms_index
:
base
:
:
Reversed
(
lms_indices
)
)
{
key_type
key
=
str
[
lms_index
]
;
suffix_array
[
-
-
bucket_bounds
[
key
]
]
=
lms_index
;
}
bucket_bounds
[
0
]
=
0
;
std
:
:
partial_sum
(
buckets
.
begin
(
)
buckets
.
end
(
)
-
1
bucket_bounds
.
begin
(
)
+
1
)
;
if
(
sl_partition
[
length
-
1
]
=
=
LType
)
{
key_type
key
=
str
[
length
-
1
]
;
suffix_array
[
bucket_bounds
[
key
]
+
+
]
=
length
-
1
;
}
for
(
auto
it
=
suffix_array
;
it
!
=
suffix_array
+
length
;
+
+
it
)
{
size_type
suffix_index
=
*
it
;
if
(
suffix_index
!
=
length
&
&
suffix_index
>
0
&
&
sl_partition
[
-
-
suffix_index
]
=
=
LType
)
{
key_type
key
=
str
[
suffix_index
]
;
suffix_array
[
bucket_bounds
[
key
]
+
+
]
=
suffix_index
;
}
}
std
:
:
partial_sum
(
buckets
.
begin
(
)
buckets
.
end
(
)
bucket_bounds
.
begin
(
)
)
;
for
(
auto
it
=
std
:
:
reverse_iterator
<
SAIt
>
(
suffix_array
+
length
)
;
it
!
=
std
:
:
reverse_iterator
<
SAIt
>
(
suffix_array
)
;
+
+
it
)
{
size_type
suffix_index
=
*
it
;
if
(
suffix_index
!
=
length
&
&
suffix_index
>
0
&
&
sl_partition
[
-
-
suffix_index
]
=
=
SType
)
{
key_type
key
=
str
[
suffix_index
]
;
suffix_array
[
-
-
bucket_bounds
[
key
]
]
=
suffix_index
;
}
}
if
(
sl_partition
[
length
-
1
]
=
=
SType
)
{
key_type
key
=
str
[
length
-
1
]
;
suffix_array
[
-
-
bucket_bounds
[
key
]
]
=
length
-
1
;
}
}
template
<
class
StrIt
class
SAIt
>
static
size_type
LabelLmsSubstrings
(
StrIt
str
size_type
length
const
std
:
:
vector
<
SLType
>
&
sl_partition
SAIt
suffix_array
iterator
lms_indices
iterator
lms_str
)
{
size_type
label
=
0
;
size_type
previous_lms
=
0
;
for
(
auto
it
=
suffix_array
;
it
!
=
suffix_array
+
length
;
+
+
it
)
{
if
(
*
it
>
0
&
&
sl_partition
[
*
it
]
=
=
SType
&
&
sl_partition
[
*
it
-
1
]
=
=
LType
)
{
size_type
current_lms
=
*
it
;
if
(
previous_lms
!
=
0
)
{
SLType
current_lms_type
=
SType
;
SLType
previous_lms_type
=
SType
;
for
(
size_type
k
=
0
;
;
+
+
k
)
{
bool
current_lms_end
=
false
;
bool
previous_lms_end
=
false
;
if
(
current_lms
+
k
>
=
length
|
|
(
current_lms_type
=
=
LType
&
&
sl_partition
[
current_lms
+
k
]
=
=
SType
)
)
{
current_lms_end
=
true
;
}
if
(
previous_lms
+
k
>
=
length
|
|
(
previous_lms_type
=
=
LType
&
&
sl_partition
[
previous_lms
+
k
]
=
=
SType
)
)
{
previous_lms_end
=
true
;
}
if
(
current_lms_end
&
&
previous_lms_end
)
{
break
;
}
else
if
(
current_lms_end
!
=
previous_lms_end
|
|
str
[
current_lms
+
k
]
!
=
str
[
previous_lms
+
k
]
)
{
+
+
label
;
break
;
}
current_lms_type
=
sl_partition
[
current_lms
+
k
]
;
previous_lms_type
=
sl_partition
[
previous_lms
+
k
]
;
}
}
*
lms_indices
+
+
=
*
it
;
*
lms_str
+
+
=
label
;
previous_lms
=
current_lms
;
}
}
return
label
+
1
;
}
template
<
class
StrIt
class
SAIt
>
static
void
SuffixSort
(
StrIt
str
size_type
length
key_type
key_bound
SAIt
suffix_array
)
{
if
(
length
=
=
1
)
*
suffix_array
=
0
;
if
(
length
<
2
)
return
;
std
:
:
vector
<
SLType
>
sl_partition
(
length
)
;
size_type
lms_count
=
BuildSLPartition
(
str
length
key_bound
sl_partition
.
rbegin
(
)
)
;
std
:
:
vector
<
size_type
>
lms_indices
(
lms_count
)
;
FindLmsSuffixes
(
sl_partition
lms_indices
.
begin
(
)
)
;
std
:
:
vector
<
size_type
>
buckets
=
MakeBucketCount
(
str
length
key_bound
)
;
if
(
lms_indices
.
size
(
)
>
1
)
{
InducedSort
(
str
length
sl_partition
lms_indices
buckets
suffix_array
)
;
std
:
:
vector
<
size_type
>
lms_str
(
lms_indices
.
size
(
)
)
;
size_type
label_count
=
LabelLmsSubstrings
(
str
length
sl_partition
suffix_array
lms_indices
.
begin
(
)
lms_str
.
begin
(
)
)
;
if
(
label_count
<
lms_str
.
size
(
)
)
{
for
(
size_type
i
=
0
;
i
<
lms_indices
.
size
(
)
;
+
+
i
)
suffix_array
[
lms_indices
[
i
]
]
=
lms_str
[
i
]
;
SLType
previous_type
=
SType
;
for
(
size_type
i
=
0
j
=
0
;
i
<
sl_partition
.
size
(
)
;
+
+
i
)
{
if
(
sl_partition
[
i
]
=
=
SType
&
&
previous_type
=
=
LType
)
{
lms_str
[
j
]
=
suffix_array
[
i
]
;
lms_indices
[
j
+
+
]
=
i
;
}
previous_type
=
sl_partition
[
i
]
;
}
Implementation
<
size_type
size_type
>
:
:
SuffixSort
(
lms_str
.
begin
(
)
static_cast
<
size_type
>
(
lms_str
.
size
(
)
)
label_count
suffix_array
)
;
for
(
size_type
i
=
0
;
i
<
lms_indices
.
size
(
)
;
+
+
i
)
suffix_array
[
i
]
=
lms_indices
[
suffix_array
[
i
]
]
;
std
:
:
copy_n
(
suffix_array
lms_indices
.
size
(
)
lms_indices
.
begin
(
)
)
;
}
}
InducedSort
(
str
length
sl_partition
lms_indices
buckets
suffix_array
)
;
}
Implementation
(
)
=
delete
;
Implementation
(
const
Implementation
&
)
=
delete
;
const
Implementation
&
operator
=
(
const
Implementation
&
)
=
delete
;
}
;
}
;
template
<
class
Algorithm
class
StrRng
class
KeyType
>
std
:
:
vector
<
typename
StrRng
:
:
size_type
>
MakeSuffixArray
(
const
StrRng
&
str
KeyType
key_bound
)
{
Algorithm
sort
;
std
:
:
vector
<
typename
StrRng
:
:
size_type
>
suffix_array
(
str
.
end
(
)
-
str
.
begin
(
)
)
;
sort
(
str
key_bound
suffix_array
.
begin
(
)
)
;
return
suffix_array
;
}
template
<
class
SARng
class
StrIt1
class
StrIt2
>
auto
SuffixLowerBound
(
const
SARng
&
suffix_array
StrIt1
str1_first
StrIt2
str2_first
StrIt2
str2_last
)
-
>
decltype
(
std
:
:
begin
(
suffix_array
)
)
{
using
size_type
=
typename
SARng
:
:
value_type
;
size_t
n
=
std
:
:
end
(
suffix_array
)
-
std
:
:
begin
(
suffix_array
)
;
auto
it
=
std
:
:
lower_bound
(
std
:
:
begin
(
suffix_array
)
std
:
:
end
(
suffix_array
)
str2_first
[
str1_first
str2_last
n
]
(
size_type
a
StrIt2
b
)
{
return
std
:
:
lexicographical_compare
(
str1_first
+
a
str1_first
+
n
b
str2_last
)
;
}
)
;
return
it
;
}
}
#
endif
