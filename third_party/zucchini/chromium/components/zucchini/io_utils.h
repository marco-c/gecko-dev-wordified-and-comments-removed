#
ifndef
COMPONENTS_ZUCCHINI_IO_UTILS_H_
#
define
COMPONENTS_ZUCCHINI_IO_UTILS_H_
#
include
<
stdint
.
h
>
#
include
<
istream
>
#
include
<
ostream
>
#
include
<
sstream
>
#
include
<
string
>
#
include
"
base
/
memory
/
raw_ref
.
h
"
#
include
"
base
/
strings
/
string_util
.
h
"
namespace
zucchini
{
class
LimitedOutputStream
:
public
std
:
:
ostream
{
private
:
class
StreamBuf
:
public
std
:
:
stringbuf
{
public
:
StreamBuf
(
std
:
:
ostream
&
os
int
limit
)
;
~
StreamBuf
(
)
override
;
int
sync
(
)
override
;
bool
full
(
)
const
{
return
counter_
>
=
limit_
;
}
private
:
const
raw_ref
<
std
:
:
ostream
>
os_
;
const
int
limit_
;
int
counter_
=
0
;
}
;
public
:
LimitedOutputStream
(
std
:
:
ostream
&
os
int
limit
)
;
LimitedOutputStream
(
const
LimitedOutputStream
&
)
=
delete
;
const
LimitedOutputStream
&
operator
=
(
const
LimitedOutputStream
&
)
=
delete
;
bool
full
(
)
const
{
return
buf_
.
full
(
)
;
}
private
:
StreamBuf
buf_
;
}
;
template
<
int
N
typename
T
=
uint32_t
>
struct
AsHex
{
explicit
AsHex
(
T
value_in
)
:
value
(
value_in
)
{
}
T
value
;
}
;
template
<
int
N
typename
T
>
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
AsHex
<
N
T
>
&
as_hex
)
{
char
buf
[
N
+
1
]
;
buf
[
N
]
=
'
\
0
'
;
T
value
=
as_hex
.
value
;
for
(
int
i
=
N
-
1
;
i
>
=
0
;
-
-
i
value
>
>
=
4
)
buf
[
i
]
=
"
0123456789ABCDEF
"
[
static_cast
<
int
>
(
value
&
0x0F
)
]
;
if
(
value
)
os
<
<
"
.
.
.
"
;
os
<
<
buf
;
return
os
;
}
class
PrefixSep
{
public
:
explicit
PrefixSep
(
const
std
:
:
string
&
sep_str
)
:
sep_str_
(
sep_str
)
{
}
PrefixSep
(
const
PrefixSep
&
)
=
delete
;
const
PrefixSep
&
operator
=
(
const
PrefixSep
&
)
=
delete
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
ostr
PrefixSep
&
obj
)
;
private
:
std
:
:
string
sep_str_
;
bool
first_
=
true
;
}
;
class
EatChar
{
public
:
explicit
EatChar
(
char
ch
)
:
ch_
(
ch
)
{
}
EatChar
(
const
EatChar
&
)
=
delete
;
const
EatChar
&
operator
=
(
const
EatChar
&
)
=
delete
;
friend
inline
std
:
:
istream
&
operator
>
>
(
std
:
:
istream
&
istr
const
EatChar
&
obj
)
{
if
(
!
istr
.
fail
(
)
&
&
istr
.
get
(
)
!
=
obj
.
ch_
)
istr
.
setstate
(
std
:
:
ios_base
:
:
failbit
)
;
return
istr
;
}
private
:
char
ch_
;
}
;
template
<
typename
T
>
class
StrictUInt
{
public
:
explicit
StrictUInt
(
T
&
var
)
:
var_
(
var
)
{
}
StrictUInt
(
const
StrictUInt
&
)
=
default
;
friend
std
:
:
istream
&
operator
>
>
(
std
:
:
istream
&
istr
StrictUInt
<
T
>
obj
)
{
if
(
!
istr
.
fail
(
)
&
&
!
base
:
:
IsAsciiDigit
(
istr
.
peek
(
)
)
)
{
istr
.
setstate
(
std
:
:
ios_base
:
:
failbit
)
;
return
istr
;
}
return
istr
>
>
*
obj
.
var_
;
}
private
:
const
raw_ref
<
T
>
var_
;
}
;
template
<
>
struct
StrictUInt
<
uint8_t
>
{
}
;
}
#
endif
