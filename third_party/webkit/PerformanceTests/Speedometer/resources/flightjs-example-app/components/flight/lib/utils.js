"
use
strict
"
;
define
(
[
]
function
(
)
{
var
arry
=
[
]
;
var
DEFAULT_INTERVAL
=
100
;
var
utils
=
{
isDomObj
:
function
(
obj
)
{
return
!
!
(
obj
.
nodeType
|
|
(
obj
=
=
=
window
)
)
;
}
toArray
:
function
(
obj
from
)
{
return
arry
.
slice
.
call
(
obj
from
)
;
}
merge
:
function
(
)
{
var
l
=
arguments
.
length
i
=
0
args
=
new
Array
(
l
+
1
)
;
for
(
;
i
<
l
;
i
+
+
)
args
[
i
+
1
]
=
arguments
[
i
]
;
if
(
l
=
=
=
0
)
{
return
{
}
;
}
args
[
0
]
=
{
}
;
if
(
args
[
args
.
length
-
1
]
=
=
=
true
)
{
args
.
pop
(
)
;
args
.
unshift
(
true
)
;
}
return
.
extend
.
apply
(
undefined
args
)
;
}
push
:
function
(
base
extra
protect
)
{
if
(
base
)
{
Object
.
keys
(
extra
|
|
{
}
)
.
forEach
(
function
(
key
)
{
if
(
base
[
key
]
&
&
protect
)
{
throw
Error
(
"
utils
.
push
attempted
to
overwrite
'
"
+
key
+
"
'
while
running
in
protected
mode
"
)
;
}
if
(
typeof
base
[
key
]
=
=
"
object
"
&
&
typeof
extra
[
key
]
=
=
"
object
"
)
{
this
.
push
(
base
[
key
]
extra
[
key
]
)
;
}
else
{
base
[
key
]
=
extra
[
key
]
;
}
}
this
)
;
}
return
base
;
}
isEnumerable
:
function
(
obj
property
)
{
return
Object
.
keys
(
obj
)
.
indexOf
(
property
)
>
-
1
;
}
compose
:
function
(
)
{
var
funcs
=
arguments
;
return
function
(
)
{
var
args
=
arguments
;
for
(
var
i
=
funcs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
args
=
[
funcs
[
i
]
.
apply
(
this
args
)
]
;
}
return
args
[
0
]
;
}
;
}
uniqueArray
:
function
(
array
)
{
var
u
=
{
}
a
=
[
]
;
for
(
var
i
=
0
l
=
array
.
length
;
i
<
l
;
+
+
i
)
{
if
(
u
.
hasOwnProperty
(
array
[
i
]
)
)
{
continue
;
}
a
.
push
(
array
[
i
]
)
;
u
[
array
[
i
]
]
=
1
;
}
return
a
;
}
debounce
:
function
(
func
wait
immediate
)
{
if
(
typeof
wait
!
=
'
number
'
)
{
wait
=
DEFAULT_INTERVAL
;
}
var
timeout
result
;
return
function
(
)
{
var
context
=
this
args
=
arguments
;
var
later
=
function
(
)
{
timeout
=
null
;
if
(
!
immediate
)
{
result
=
func
.
apply
(
context
args
)
;
}
}
;
var
callNow
=
immediate
&
&
!
timeout
;
clearTimeout
(
timeout
)
;
timeout
=
setTimeout
(
later
wait
)
;
if
(
callNow
)
{
result
=
func
.
apply
(
context
args
)
;
}
return
result
;
}
;
}
throttle
:
function
(
func
wait
)
{
if
(
typeof
wait
!
=
'
number
'
)
{
wait
=
DEFAULT_INTERVAL
;
}
var
context
args
timeout
throttling
more
result
;
var
whenDone
=
this
.
debounce
(
function
(
)
{
more
=
throttling
=
false
;
}
wait
)
;
return
function
(
)
{
context
=
this
;
args
=
arguments
;
var
later
=
function
(
)
{
timeout
=
null
;
if
(
more
)
{
result
=
func
.
apply
(
context
args
)
;
}
whenDone
(
)
;
}
;
if
(
!
timeout
)
{
timeout
=
setTimeout
(
later
wait
)
;
}
if
(
throttling
)
{
more
=
true
;
}
else
{
throttling
=
true
;
result
=
func
.
apply
(
context
args
)
;
}
whenDone
(
)
;
return
result
;
}
;
}
countThen
:
function
(
num
base
)
{
return
function
(
)
{
if
(
!
-
-
num
)
{
return
base
.
apply
(
this
arguments
)
;
}
}
;
}
delegate
:
function
(
rules
)
{
return
function
(
e
data
)
{
var
target
=
(
e
.
target
)
parent
;
Object
.
keys
(
rules
)
.
forEach
(
function
(
selector
)
{
if
(
(
parent
=
target
.
closest
(
selector
)
)
.
length
)
{
data
=
data
|
|
{
}
;
data
.
el
=
parent
[
0
]
;
return
rules
[
selector
]
.
apply
(
this
[
e
data
]
)
;
}
}
this
)
;
}
;
}
}
;
return
utils
;
}
)
;
