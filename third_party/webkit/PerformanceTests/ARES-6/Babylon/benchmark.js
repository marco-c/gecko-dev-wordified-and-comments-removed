"
use
strict
"
;
let
currentTime
;
if
(
this
.
performance
&
&
performance
.
now
)
currentTime
=
function
(
)
{
return
performance
.
now
(
)
}
;
else
if
(
this
.
preciseTime
)
currentTime
=
function
(
)
{
return
preciseTime
(
)
*
1000
;
}
;
else
currentTime
=
function
(
)
{
return
+
new
Date
(
)
;
}
;
class
BabylonBenchmark
{
constructor
(
verbose
=
0
)
{
let
sources
=
[
]
;
const
files
=
[
[
"
.
/
Babylon
/
air
-
blob
.
js
"
{
}
]
[
"
.
/
Babylon
/
basic
-
blob
.
js
"
{
}
]
[
"
.
/
Babylon
/
inspector
-
blob
.
js
"
{
}
]
[
"
.
/
Babylon
/
babylon
-
blob
.
js
"
{
sourceType
:
"
module
"
}
]
]
;
for
(
let
[
file
options
]
of
files
)
{
function
appendSource
(
s
)
{
sources
.
push
(
[
file
s
options
]
)
;
}
let
s
;
const
isInBrowser
=
typeof
window
!
=
=
"
undefined
"
;
if
(
isInBrowser
)
{
let
request
=
new
XMLHttpRequest
(
)
;
request
.
open
(
'
GET
'
file
false
)
;
request
.
send
(
null
)
;
if
(
!
request
.
responseText
.
length
)
throw
new
Error
(
"
Expect
non
-
empty
sources
"
)
;
appendSource
(
request
.
responseText
)
;
}
else
{
appendSource
(
read
(
file
)
)
;
}
}
this
.
sources
=
sources
;
}
runIteration
(
)
{
const
Parser
=
parserIndexJS
;
const
{
plugins
}
=
parserIndexJS
;
const
{
types
:
tokTypes
}
=
tokenizerTypesJS
;
const
estreePlugin
=
pluginsEstreeJS
;
const
flowPlugin
=
pluginsFlowJS
;
const
jsxPlugin
=
pluginsJsxIndexJS
;
plugins
.
estree
=
estreePlugin
;
plugins
.
flow
=
flowPlugin
;
plugins
.
jsx
=
jsxPlugin
;
function
parse
(
input
options
)
{
return
new
Parser
(
options
input
)
.
parse
(
)
;
}
function
parseExpression
(
input
options
)
{
const
parser
=
new
Parser
(
options
input
)
;
if
(
parser
.
options
.
strictMode
)
{
parser
.
state
.
strict
=
true
;
}
return
parser
.
getExpression
(
)
;
}
for
(
let
[
fileName
source
options
]
of
this
.
sources
)
{
parse
(
source
options
)
;
}
}
}
function
runBenchmark
(
)
{
const
verbose
=
0
;
const
numIterations
=
150
;
let
before
=
currentTime
(
)
;
let
benchmark
=
new
Benchmark
(
verbose
)
;
for
(
let
iteration
=
0
;
iteration
<
numIterations
;
+
+
iteration
)
benchmark
.
runIteration
(
)
;
let
after
=
currentTime
(
)
;
return
after
-
before
;
}
