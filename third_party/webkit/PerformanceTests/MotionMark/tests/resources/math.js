SimpleKalmanEstimator
=
Utilities
.
createSubclass
(
Experiment
function
(
processError
measurementError
)
{
Experiment
.
call
(
this
false
)
;
var
error
=
.
5
*
(
Math
.
sqrt
(
processError
*
processError
+
4
*
processError
*
measurementError
)
-
processError
)
;
this
.
_gain
=
error
/
(
error
+
measurementError
)
;
}
{
sample
:
function
(
newMeasurement
)
{
if
(
!
this
.
_initialized
)
{
this
.
_initialized
=
true
;
this
.
estimate
=
newMeasurement
;
return
;
}
this
.
estimate
=
this
.
estimate
+
this
.
_gain
*
(
newMeasurement
-
this
.
estimate
)
;
}
reset
:
function
(
)
{
Experiment
.
prototype
.
reset
.
call
(
this
)
;
this
.
_initialized
=
false
;
this
.
estimate
=
0
;
}
}
)
;
PIDController
=
Utilities
.
createClass
(
function
(
ysp
)
{
this
.
_ysp
=
ysp
;
this
.
_out
=
0
;
this
.
_Kp
=
0
;
this
.
_stage
=
PIDController
.
stages
.
WARMING
;
this
.
_eold
=
0
;
this
.
_I
=
0
;
}
{
_yPosition
:
function
(
y
)
{
return
(
y
<
this
.
_ysp
)
=
=
(
this
.
_y0
<
this
.
_ysp
)
?
PIDController
.
yPositions
.
BEFORE_SETPOINT
:
PIDController
.
yPositions
.
AFTER_SETPOINT
;
}
_distanceUltimate
:
function
(
t
)
{
return
(
this
.
_ysp
-
this
.
_y0
)
*
Math
.
pow
(
t
/
1000
3
)
;
}
_distance
:
function
(
y
du
)
{
const
epsilon
=
0
.
0001
;
var
d
=
y
-
this
.
_y0
;
return
du
<
0
?
Math
.
min
(
d
-
epsilon
)
:
Math
.
max
(
d
epsilon
)
;
}
_gainIncrement
:
function
(
t
y
e
)
{
var
du
=
this
.
_distanceUltimate
(
t
)
;
var
d
=
this
.
_distance
(
y
du
)
;
return
Math
.
log
(
du
/
d
)
*
0
.
1
;
}
_updateStage
:
function
(
y
)
{
var
yPosition
=
this
.
_yPosition
(
y
)
;
switch
(
this
.
_stage
)
{
case
PIDController
.
stages
.
WARMING
:
if
(
yPosition
=
=
PIDController
.
yPositions
.
AFTER_SETPOINT
)
this
.
_stage
=
PIDController
.
stages
.
OVERSHOOT
;
break
;
case
PIDController
.
stages
.
OVERSHOOT
:
if
(
yPosition
=
=
PIDController
.
yPositions
.
BEFORE_SETPOINT
)
this
.
_stage
=
PIDController
.
stages
.
UNDERSHOOT
;
break
;
case
PIDController
.
stages
.
UNDERSHOOT
:
if
(
yPosition
=
=
PIDController
.
yPositions
.
AFTER_SETPOINT
)
this
.
_stage
=
PIDController
.
stages
.
SATURATE
;
break
;
}
}
_tuneP
:
function
(
e
)
{
return
this
.
_Kp
*
e
;
}
_tunePID
:
function
(
h
y
e
)
{
var
P
=
this
.
_Kp
*
e
;
this
.
_I
+
=
(
this
.
_Kp
/
this
.
_Ti
)
*
(
(
e
+
this
.
_eold
)
/
2
)
*
h
;
var
D
=
(
this
.
_Kp
*
this
.
_Td
)
*
(
e
-
this
.
_eold
)
/
h
;
return
P
+
this
.
_I
+
D
;
}
_tune
:
function
(
t
h
y
e
)
{
switch
(
this
.
_stage
)
{
case
PIDController
.
stages
.
WARMING
:
if
(
typeof
this
.
_y0
=
=
"
undefined
"
)
{
this
.
_y0
=
y
;
this
.
_Kp
=
-
1
/
e
;
}
else
{
this
.
_Kp
+
=
this
.
_gainIncrement
(
t
y
e
)
;
}
return
this
.
_tuneP
(
e
)
;
case
PIDController
.
stages
.
OVERSHOOT
:
if
(
typeof
this
.
_t0
=
=
"
undefined
"
)
{
this
.
_t0
=
t
;
this
.
_Kp
/
=
2
;
}
return
this
.
_tuneP
(
e
)
;
case
PIDController
.
stages
.
UNDERSHOOT
:
if
(
typeof
this
.
_Ti
=
=
"
undefined
"
)
{
var
Tu
=
t
-
this
.
_t0
;
this
.
_Ti
=
Tu
/
2
;
this
.
_Td
=
Tu
/
3
;
this
.
_Kp
=
0
.
33
*
this
.
_Kp
;
this
.
_Tt
=
Math
.
sqrt
(
this
.
_Ti
*
this
.
_Td
)
;
}
return
this
.
_tunePID
(
h
y
e
)
;
case
PIDController
.
stages
.
SATURATE
:
return
this
.
_tunePID
(
h
y
e
)
;
}
return
0
;
}
_saturate
:
function
(
v
e
)
{
var
u
=
v
;
switch
(
this
.
_stage
)
{
case
PIDController
.
stages
.
OVERSHOOT
:
case
PIDController
.
stages
.
UNDERSHOOT
:
if
(
typeof
this
.
_min
=
=
"
undefined
"
)
this
.
_min
=
this
.
_max
=
this
.
_out
;
else
{
this
.
_min
=
Math
.
min
(
this
.
_min
this
.
_out
)
;
this
.
_max
=
Math
.
max
(
this
.
_max
this
.
_out
)
;
}
break
;
case
PIDController
.
stages
.
SATURATE
:
const
limitPercentage
=
0
.
90
;
var
min
=
this
.
_min
>
0
?
Math
.
min
(
this
.
_min
this
.
_max
*
limitPercentage
)
:
this
.
_min
;
var
max
=
this
.
_max
<
0
?
Math
.
max
(
this
.
_max
this
.
_min
*
limitPercentage
)
:
this
.
_max
;
var
out
=
this
.
_out
+
u
;
out
=
Math
.
max
(
Math
.
min
(
max
out
)
min
)
;
u
=
out
-
this
.
_out
;
if
(
u
!
=
v
)
u
+
=
(
this
.
_Kp
*
this
.
_Tt
/
this
.
_Ti
)
*
e
;
break
;
}
this
.
_out
+
=
u
;
return
u
;
}
tune
:
function
(
t
h
y
)
{
this
.
_updateStage
(
y
)
;
var
e
=
this
.
_ysp
-
y
;
var
v
=
this
.
_tune
(
t
h
y
e
)
;
this
.
_eold
=
e
;
return
this
.
_saturate
(
v
e
)
;
}
}
)
;
Utilities
.
extendObject
(
PIDController
{
yPositions
:
{
BEFORE_SETPOINT
:
0
AFTER_SETPOINT
:
1
}
stages
:
{
WARMING
:
0
OVERSHOOT
:
1
UNDERSHOOT
:
2
SATURATE
:
3
}
}
)
;
