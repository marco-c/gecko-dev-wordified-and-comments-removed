load
(
"
red_black_tree
.
js
"
)
;
var
test
=
(
function
(
)
{
function
PairVector
(
)
{
this
.
_vector
=
[
]
;
}
PairVector
.
prototype
.
put
=
function
(
key
value
)
{
for
(
var
i
=
0
;
i
<
this
.
_vector
.
length
;
+
+
i
)
{
if
(
!
this
.
_vector
[
i
]
.
key
.
compareTo
(
key
)
)
{
var
result
=
this
.
_vector
[
i
]
.
value
;
this
.
_vector
[
i
]
.
value
=
value
;
return
result
;
}
}
this
.
_vector
.
push
(
{
key
:
key
value
:
value
}
)
;
return
null
;
}
;
PairVector
.
prototype
.
remove
=
function
(
key
value
)
{
for
(
var
i
=
0
;
i
<
this
.
_vector
.
length
;
+
+
i
)
{
if
(
!
this
.
_vector
[
i
]
.
key
.
compareTo
(
key
)
)
{
var
result
=
this
.
_vector
[
i
]
.
value
;
this
.
_vector
[
i
]
=
this
.
_vector
[
this
.
_vector
.
length
-
1
]
;
this
.
_vector
.
pop
(
)
;
return
result
;
}
}
return
null
;
}
;
PairVector
.
prototype
.
get
=
function
(
key
value
)
{
for
(
var
i
=
0
;
i
<
this
.
_vector
.
length
;
+
+
i
)
{
if
(
!
this
.
_vector
[
i
]
.
key
.
compareTo
(
key
)
)
return
this
.
_vector
[
i
]
.
value
;
}
return
null
;
}
;
PairVector
.
prototype
.
toString
=
function
(
)
{
var
copy
=
this
.
_vector
.
concat
(
)
;
copy
.
sort
(
function
(
a
b
)
{
return
a
.
key
.
compareTo
(
b
.
key
)
;
}
)
;
var
result
=
"
[
"
;
for
(
var
i
=
0
;
i
<
copy
.
length
;
+
+
i
)
{
if
(
i
)
result
+
=
"
"
;
result
+
=
copy
[
i
]
.
key
+
"
=
>
"
+
copy
[
i
]
.
value
;
}
return
result
+
"
]
"
;
}
;
String
.
prototype
.
compareTo
=
String
.
prototype
.
localeCompare
;
var
counter
=
0
;
return
function
(
controlString
)
{
print
(
"
Running
"
+
JSON
.
stringify
(
controlString
)
+
"
:
"
)
;
var
asVector
=
new
PairVector
(
)
;
var
asTree
=
new
RedBlackTree
(
)
;
function
fail
(
when
)
{
throw
new
Error
(
"
FAIL
:
"
+
when
+
"
tree
=
"
+
asTree
+
"
vector
=
"
+
asVector
)
;
}
for
(
var
index
=
0
;
index
<
controlString
.
length
;
index
+
=
2
)
{
var
command
=
controlString
[
index
]
;
var
key
=
controlString
[
index
+
1
]
;
var
value
=
+
+
counter
;
switch
(
command
)
{
case
"
+
"
:
var
oldVectorValue
=
asVector
.
put
(
key
value
)
;
var
oldTreeValue
=
asTree
.
put
(
key
value
)
;
if
(
oldVectorValue
!
=
=
oldTreeValue
)
{
fail
(
"
Adding
"
+
key
+
"
=
>
"
+
value
+
"
vector
got
"
+
oldVectorValue
+
"
but
tree
got
"
+
oldTreeValue
)
;
}
break
;
case
"
*
"
:
var
oldVectorValue
=
asVector
.
get
(
key
)
;
var
oldTreeValue
=
asTree
.
get
(
key
)
;
if
(
oldVectorValue
!
=
=
oldTreeValue
)
{
fail
(
"
Getting
"
+
key
+
"
vector
got
"
+
oldVectorValue
+
"
but
tree
got
"
+
oldTreeValue
)
;
}
break
;
case
"
!
"
:
var
oldVectorValue
=
asVector
.
remove
(
key
)
;
var
oldTreeValue
=
asTree
.
remove
(
key
)
;
if
(
oldVectorValue
!
=
=
oldTreeValue
)
{
fail
(
"
Removing
"
+
key
+
"
vector
got
"
+
oldVectorValue
+
"
but
tree
got
"
+
oldTreeValue
)
;
}
break
;
default
:
throw
Error
(
"
Bad
command
:
"
+
command
)
;
}
}
if
(
"
"
+
asVector
!
=
"
"
+
asTree
)
fail
(
"
Bad
result
at
end
"
)
;
print
(
"
Success
tree
is
:
"
+
asTree
)
;
}
;
}
)
(
)
;
test
(
"
"
)
;
test
(
"
+
a
"
)
;
test
(
"
*
x
!
z
"
)
;
test
(
"
+
a
*
x
!
z
"
)
;
test
(
"
+
a
*
a
!
a
"
)
;
test
(
"
+
a
+
b
"
)
;
test
(
"
+
a
+
b
+
c
"
)
;
test
(
"
+
a
+
b
+
c
+
d
"
)
;
test
(
"
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
"
)
;
test
(
"
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
e
+
f
+
g
+
h
+
i
+
j
+
k
+
l
+
m
+
n
+
o
+
p
+
q
+
r
+
s
+
t
+
u
+
v
+
x
+
y
+
z
"
)
;
test
(
"
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
a
+
b
+
c
+
d
+
e
+
f
+
g
+
h
+
i
+
j
+
k
+
l
+
m
+
n
+
o
+
p
+
q
+
r
+
s
+
t
+
u
+
v
+
x
+
y
+
z
*
a
*
b
*
c
*
d
*
e
*
f
*
g
*
h
*
i
*
j
*
k
*
l
*
m
*
n
*
o
*
p
*
q
*
r
*
s
*
t
*
u
*
v
*
w
*
x
*
y
*
z
!
a
!
b
!
c
!
d
!
e
!
f
!
g
!
h
!
i
!
j
!
k
!
l
!
m
!
n
!
o
!
p
!
q
!
r
!
s
!
t
!
u
!
v
!
w
!
x
!
y
!
z
"
)
;
