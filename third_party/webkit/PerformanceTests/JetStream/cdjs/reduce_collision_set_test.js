load
(
"
constants
.
js
"
)
;
load
(
"
util
.
js
"
)
;
load
(
"
red_black_tree
.
js
"
)
;
load
(
"
call_sign
.
js
"
)
;
load
(
"
vector_2d
.
js
"
)
;
load
(
"
vector_3d
.
js
"
)
;
load
(
"
motion
.
js
"
)
;
load
(
"
reduce_collision_set
.
js
"
)
;
var
makeMotion
=
(
function
(
)
{
var
counter
=
0
;
return
function
(
x1
y1
z1
x2
y2
z2
)
{
return
new
Motion
(
new
CallSign
(
"
foo
"
+
(
+
+
counter
)
)
new
Vector3D
(
x1
y1
z1
)
new
Vector3D
(
x2
y2
z2
)
)
;
}
}
)
(
)
;
function
drawMotion
(
motion
)
{
var
voxelMap
=
new
RedBlackTree
(
)
;
drawMotionOnVoxelMap
(
voxelMap
motion
)
;
return
voxelMap
;
}
function
keys
(
voxelMap
)
{
var
result
=
"
[
"
;
var
first
=
true
;
voxelMap
.
forEach
(
function
(
key
value
)
{
if
(
first
)
first
=
false
;
else
result
+
=
"
"
;
result
+
=
key
;
}
)
;
return
result
+
"
]
"
;
}
function
test
(
x1
y1
z1
x2
y2
z2
expected
)
{
var
motion
=
makeMotion
(
x1
y1
z1
x2
y2
z2
)
;
print
(
motion
+
"
:
"
)
;
var
actual
=
keys
(
drawMotion
(
motion
)
)
;
if
(
expected
!
=
actual
)
throw
new
Error
(
"
Wrong
voxel
map
:
"
+
actual
)
;
print
(
"
Got
:
"
+
actual
)
;
}
test
(
0
0
0
1
1
1
"
[
[
0
0
]
]
"
)
;
test
(
0
0
0
2
2
2
"
[
[
0
0
]
[
0
2
]
[
2
0
]
[
2
2
]
]
"
)
;
test
(
0
0
0
4
4
4
"
[
[
0
0
]
[
0
2
]
[
2
0
]
[
2
2
]
[
2
4
]
[
4
2
]
[
4
4
]
]
"
)
;
test
(
0
0
0
10
0
0
"
[
[
0
0
]
[
2
0
]
[
4
0
]
[
6
0
]
[
8
0
]
[
10
0
]
]
"
)
;
test
(
2
0
0
0
2
2
"
[
[
0
0
]
[
0
2
]
[
2
0
]
]
"
)
;
test
(
0
2
0
2
0
2
"
[
[
0
0
]
[
0
2
]
[
2
0
]
]
"
)
;
test
(
2
2
0
0
0
2
"
[
[
0
0
]
[
0
2
]
[
2
0
]
[
2
2
]
]
"
)
;
test
(
0
0
0
2
0
0
"
[
[
0
0
]
[
2
0
]
]
"
)
;
test
(
0
0
0
0
2
0
"
[
[
0
0
]
[
0
2
]
]
"
)
;
test
(
2
0
0
0
0
0
"
[
[
0
0
]
[
2
0
]
]
"
)
;
test
(
0
2
0
0
0
0
"
[
[
0
0
]
[
0
2
]
]
"
)
;
