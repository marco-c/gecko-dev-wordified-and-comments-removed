function
Motion
(
callsign
posOne
posTwo
)
{
this
.
callsign
=
callsign
;
this
.
posOne
=
posOne
;
this
.
posTwo
=
posTwo
;
}
Motion
.
prototype
.
toString
=
function
(
)
{
return
"
Motion
(
"
+
this
.
callsign
+
"
from
"
+
this
.
posOne
+
"
to
"
+
this
.
posTwo
+
"
)
"
;
}
;
Motion
.
prototype
.
delta
=
function
(
)
{
return
this
.
posTwo
.
minus
(
this
.
posOne
)
;
}
;
Motion
.
prototype
.
findIntersection
=
function
(
other
)
{
var
init1
=
this
.
posOne
;
var
init2
=
other
.
posOne
;
var
vec1
=
this
.
delta
(
)
;
var
vec2
=
other
.
delta
(
)
;
var
radius
=
Constants
.
PROXIMITY_RADIUS
;
var
a
=
vec2
.
minus
(
vec1
)
.
squaredMagnitude
(
)
;
if
(
a
!
=
0
)
{
var
b
=
2
*
init1
.
minus
(
init2
)
.
dot
(
vec1
.
minus
(
vec2
)
)
;
var
c
=
-
radius
*
radius
+
init2
.
minus
(
init1
)
.
squaredMagnitude
(
)
;
var
discr
=
b
*
b
-
4
*
a
*
c
;
if
(
discr
<
0
)
return
null
;
var
v1
=
(
-
b
-
Math
.
sqrt
(
discr
)
)
/
(
2
*
a
)
;
var
v2
=
(
-
b
+
Math
.
sqrt
(
discr
)
)
/
(
2
*
a
)
;
if
(
v1
<
=
v2
&
&
(
(
v1
<
=
1
&
&
1
<
=
v2
)
|
|
(
v1
<
=
0
&
&
0
<
=
v2
)
|
|
(
0
<
=
v1
&
&
v2
<
=
1
)
)
)
{
var
v
;
if
(
v1
<
=
0
)
{
v
=
0
;
}
else
{
v
=
v1
;
}
var
result1
=
init1
.
plus
(
vec1
.
times
(
v
)
)
;
var
result2
=
init2
.
plus
(
vec2
.
times
(
v
)
)
;
var
result
=
result1
.
plus
(
result2
)
.
times
(
0
.
5
)
;
if
(
result
.
x
>
=
Constants
.
MIN_X
&
&
result
.
x
<
=
Constants
.
MAX_X
&
&
result
.
y
>
=
Constants
.
MIN_Y
&
&
result
.
y
<
=
Constants
.
MAX_Y
&
&
result
.
z
>
=
Constants
.
MIN_Z
&
&
result
.
z
<
=
Constants
.
MAX_Z
)
return
result
;
}
return
null
;
}
var
dist
=
init2
.
minus
(
init1
)
.
magnitude
(
)
;
if
(
dist
<
=
radius
)
return
init1
.
plus
(
init2
)
.
times
(
0
.
5
)
;
return
null
;
}
;
