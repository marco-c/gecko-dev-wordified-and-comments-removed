import
{
LCG
}
from
"
random
-
seedable
"
;
import
{
DEFAULT_SEED_FOR_RANDOM_NUMBER_GENERATOR
MAX_GENERATED_DOM_DEPTH
MAX_NUMBER_OF_CHILDREN
PROBABILITY_OF_HAVING_CHILDREN
TARGET_SIZE
MIN_NUMBER_OF_MAX_DEPTH_BRANCHES
PERCENTAGE_OF_DISPLAY_NONE_TREEVIEW_ELEMENTS
}
from
"
.
/
.
.
/
params
"
;
const
random
=
new
LCG
(
DEFAULT_SEED_FOR_RANDOM_NUMBER_GENERATOR
)
;
const
fillSubtreeWeights
=
(
node
expandableItemWeight
nonExpandableItemWeight
)
=
>
{
if
(
node
.
type
=
=
=
"
expandableItem
"
)
node
.
subTreeWeight
=
node
.
children
.
reduce
(
(
acc
child
)
=
>
acc
+
fillSubtreeWeights
(
child
expandableItemWeight
nonExpandableItemWeight
)
expandableItemWeight
)
;
else
node
.
subTreeWeight
=
nonExpandableItemWeight
;
return
node
.
subTreeWeight
;
}
;
const
markDisplayNoneNodes
=
(
node
expandableItemWeight
nonExpandableItemWeight
)
=
>
{
let
currentSubTreesWeights
=
node
.
subTreeWeight
;
let
currentIndex
=
0
;
let
nodeQueue
=
[
node
]
;
while
(
currentSubTreesWeights
>
=
TARGET_SIZE
*
PERCENTAGE_OF_DISPLAY_NONE_TREEVIEW_ELEMENTS
)
{
const
currentNode
=
nodeQueue
[
currentIndex
]
;
nodeQueue
[
currentIndex
]
=
null
;
const
expandableChildren
=
currentNode
.
children
.
filter
(
(
child
)
=
>
child
.
type
=
=
=
"
expandableItem
"
)
;
if
(
expandableChildren
.
length
)
{
nodeQueue
.
push
(
.
.
.
expandableChildren
)
;
currentSubTreesWeights
-
=
expandableItemWeight
;
let
numberOfNonExpandableChildren
=
currentNode
.
children
.
length
-
expandableChildren
.
length
;
currentSubTreesWeights
-
=
numberOfNonExpandableChildren
*
nonExpandableItemWeight
;
}
else
{
currentSubTreesWeights
-
=
currentNode
.
subTreeWeight
;
}
currentIndex
+
+
;
}
nodeQueue
.
forEach
(
(
node
)
=
>
{
if
(
node
)
node
.
isDisplayNone
=
true
;
}
)
;
}
;
export
const
generateTreeHead
=
(
{
expandableItemWeight
nonExpandableItemWeight
}
)
=
>
{
const
treeHead
=
{
type
:
"
expandableItem
"
children
:
[
]
isDisplayNone
:
false
subTreeWeight
:
0
}
;
const
nodeWeight
=
{
expandableItem
:
expandableItemWeight
nonExpandableItem
:
nonExpandableItemWeight
}
;
let
totalNodes
=
expandableItemWeight
;
for
(
let
i
=
0
;
i
<
MIN_NUMBER_OF_MAX_DEPTH_BRANCHES
;
i
+
+
)
{
let
currentDepth
=
0
;
let
currentNode
=
treeHead
;
while
(
currentDepth
<
MAX_GENERATED_DOM_DEPTH
)
{
let
childType
=
"
expandableItem
"
;
currentNode
.
children
.
push
(
{
type
:
childType
children
:
[
]
}
)
;
currentNode
=
currentNode
.
children
[
currentNode
.
children
.
length
-
1
]
;
currentDepth
+
+
;
totalNodes
+
=
nodeWeight
[
childType
]
;
}
}
const
treeNodes
=
[
treeHead
]
;
while
(
totalNodes
<
TARGET_SIZE
)
{
let
index
=
0
;
while
(
index
<
treeNodes
.
length
&
&
totalNodes
<
TARGET_SIZE
)
{
let
currentNode
=
treeNodes
[
index
]
;
switch
(
currentNode
.
type
)
{
case
"
expandableItem
"
:
if
(
random
.
coin
(
PROBABILITY_OF_HAVING_CHILDREN
)
|
|
currentNode
.
children
.
length
)
{
const
numberOfNewChildren
=
random
.
randRange
(
1
MAX_NUMBER_OF_CHILDREN
-
currentNode
.
children
.
length
+
1
)
;
for
(
let
i
=
0
;
i
<
numberOfNewChildren
&
&
totalNodes
<
TARGET_SIZE
;
i
+
+
)
{
currentNode
.
children
.
push
(
{
type
:
"
nonExpandableItem
"
children
:
[
]
}
)
;
totalNodes
+
=
nodeWeight
[
"
nonExpandableItem
"
]
;
}
random
.
shuffle
(
currentNode
.
children
true
)
;
treeNodes
.
push
(
.
.
.
currentNode
.
children
)
;
}
break
;
case
"
nonExpandableItem
"
:
if
(
random
.
coin
(
PROBABILITY_OF_HAVING_CHILDREN
)
)
{
currentNode
.
type
=
"
expandableItem
"
;
let
childType
=
random
.
choice
(
[
"
expandableItem
"
"
nonExpandableItem
"
]
)
;
currentNode
.
children
.
push
(
{
type
:
childType
children
:
[
]
}
)
;
totalNodes
=
totalNodes
-
nodeWeight
[
"
nonExpandableItem
"
]
+
nodeWeight
[
"
expandableItem
"
]
;
totalNodes
+
=
nodeWeight
[
childType
]
;
treeNodes
.
push
(
currentNode
.
children
[
0
]
)
;
}
break
;
default
:
throw
new
Error
(
Unknown
node
type
:
{
currentNode
.
type
}
)
;
}
index
+
+
;
}
}
fillSubtreeWeights
(
treeHead
expandableItemWeight
nonExpandableItemWeight
)
;
markDisplayNoneNodes
(
treeHead
expandableItemWeight
nonExpandableItemWeight
)
;
return
treeHead
;
}
;
