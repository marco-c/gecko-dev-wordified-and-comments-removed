#
ifndef
__UTIL_H__
#
define
__UTIL_H__
#
include
<
mpi
.
h
>
#
include
<
mprio
.
h
>
#
define
MIN
(
a
b
)
(
(
a
)
<
(
b
)
?
(
a
)
:
(
b
)
)
#
define
P_CHECK
(
s
)
\
do
{
\
if
(
(
rv
=
(
s
)
)
!
=
SECSuccess
)
\
return
rv
;
\
}
while
(
0
)
;
#
define
P_CHECKA
(
s
)
\
do
{
\
if
(
(
s
)
=
=
NULL
)
{
\
rv
=
SECFailure
;
\
goto
cleanup
;
\
}
\
}
while
(
0
)
;
#
define
P_CHECKC
(
s
)
\
do
{
\
if
(
(
rv
=
(
s
)
)
!
=
SECSuccess
)
{
\
goto
cleanup
;
\
}
\
}
while
(
0
)
;
#
define
P_CHECKCB
(
s
)
\
do
{
\
if
(
!
(
s
)
)
{
\
rv
=
SECFailure
;
\
goto
cleanup
;
\
}
\
}
while
(
0
)
;
#
define
MP_CHECK
(
s
)
do
{
if
(
(
s
)
!
=
MP_OKAY
)
return
SECFailure
;
}
while
(
0
)
;
#
define
UP_CHECK
(
s
)
do
{
int
r
=
(
s
)
;
if
(
r
!
=
MSGPACK_UNPACK_SUCCESS
&
&
\
r
!
=
MSGPACK_UNPACK_EXTRA_BYTES
)
\
return
SECFailure
;
}
while
(
0
)
;
#
define
MP_CHECKC
(
s
)
\
do
{
\
if
(
(
s
)
!
=
MP_OKAY
)
{
\
rv
=
SECFailure
;
\
goto
cleanup
;
\
}
\
}
while
(
0
)
;
inline
int
next_power_of_two
(
int
val
)
{
int
i
=
val
;
int
out
=
0
;
for
(
;
i
>
0
;
i
>
>
=
1
)
{
out
+
+
;
}
int
pow
=
1
<
<
out
;
return
(
pow
>
1
&
&
pow
/
2
=
=
val
)
?
val
:
pow
;
}
inline
unsigned
char
msb_mask
(
unsigned
char
val
)
{
unsigned
char
mask
;
for
(
mask
=
0x00
;
(
val
&
mask
)
!
=
val
;
mask
=
(
mask
<
<
1
)
+
1
)
;
return
mask
;
}
#
define
UNUSED
(
x
)
(
void
)
(
x
)
#
endif
