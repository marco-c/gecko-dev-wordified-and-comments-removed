#
include
<
limits
.
h
>
#
include
<
mprio
.
h
>
#
include
<
nss
.
h
>
#
include
<
pk11pub
.
h
>
#
include
<
prinit
.
h
>
#
include
"
debug
.
h
"
#
include
"
rand
.
h
"
#
include
"
util
.
h
"
#
define
CHUNK_SIZE
8192
static
NSSInitContext
*
prioGlobalContext
=
NULL
;
SECStatus
rand_init
(
void
)
{
if
(
prioGlobalContext
)
return
SECSuccess
;
prioGlobalContext
=
NSS_InitContext
(
"
"
"
"
"
"
"
"
NULL
NSS_INIT_READONLY
|
NSS_INIT_NOCERTDB
|
NSS_INIT_NOMODDB
|
NSS_INIT_FORCEOPEN
|
NSS_INIT_NOROOTINIT
)
;
return
(
prioGlobalContext
!
=
NULL
)
?
SECSuccess
:
SECFailure
;
}
static
SECStatus
rand_bytes_internal
(
void
*
user_data
unsigned
char
*
out
size_t
n_bytes
)
{
if
(
user_data
!
=
NULL
)
return
SECFailure
;
if
(
!
NSS_IsInitialized
(
)
)
{
PRIO_DEBUG
(
"
NSS
not
initialized
.
Call
rand_init
(
)
first
.
"
)
;
return
SECFailure
;
}
SECStatus
rv
=
SECFailure
;
int
to_go
=
n_bytes
;
unsigned
char
*
cp
=
out
;
while
(
to_go
)
{
int
to_gen
=
MIN
(
CHUNK_SIZE
to_go
)
;
if
(
(
rv
=
PK11_GenerateRandom
(
cp
to_gen
)
)
!
=
SECSuccess
)
{
PRIO_DEBUG
(
"
Error
calling
PK11_GenerateRandom
"
)
;
return
SECFailure
;
}
cp
+
=
CHUNK_SIZE
;
to_go
-
=
to_gen
;
}
return
rv
;
}
SECStatus
rand_bytes
(
unsigned
char
*
out
size_t
n_bytes
)
{
return
rand_bytes_internal
(
NULL
out
n_bytes
)
;
}
SECStatus
rand_int
(
mp_int
*
out
const
mp_int
*
max
)
{
return
rand_int_rng
(
out
max
&
rand_bytes_internal
NULL
)
;
}
SECStatus
rand_int_rng
(
mp_int
*
out
const
mp_int
*
max
RandBytesFunc
rng_func
void
*
user_data
)
{
SECStatus
rv
=
SECSuccess
;
unsigned
char
*
max_bytes
=
NULL
;
unsigned
char
*
buf
=
NULL
;
if
(
mp_cmp_z
(
max
)
=
=
0
)
return
SECFailure
;
MP_CHECKC
(
mp_sub_d
(
max
1
out
)
)
;
const
int
nbytes
=
mp_unsigned_octet_size
(
out
)
;
P_CHECKA
(
max_bytes
=
calloc
(
nbytes
sizeof
(
unsigned
char
)
)
)
;
MP_CHECKC
(
mp_to_fixlen_octets
(
out
max_bytes
nbytes
)
)
;
const
unsigned
char
mask
=
msb_mask
(
max_bytes
[
0
]
)
;
P_CHECKA
(
buf
=
calloc
(
nbytes
sizeof
(
unsigned
char
)
)
)
;
do
{
P_CHECKC
(
rng_func
(
user_data
buf
nbytes
)
)
;
P_CHECKC
(
rng_func
(
user_data
&
buf
[
0
]
1
)
)
;
if
(
mask
)
buf
[
0
]
&
=
mask
;
MP_CHECKC
(
mp_read_unsigned_octets
(
out
buf
nbytes
)
)
;
}
while
(
mp_cmp
(
out
max
)
!
=
-
1
)
;
cleanup
:
if
(
max_bytes
)
free
(
max_bytes
)
;
if
(
buf
)
free
(
buf
)
;
return
rv
;
}
void
rand_clear
(
void
)
{
if
(
prioGlobalContext
)
{
NSS_ShutdownContext
(
prioGlobalContext
)
;
#
ifdef
DO_PR_CLEANUP
PR_Cleanup
(
)
;
#
endif
}
prioGlobalContext
=
NULL
;
}
