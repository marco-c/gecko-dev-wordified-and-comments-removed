#
define
_GNU_SOURCE
#
include
<
mprio
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
time
.
h
>
#
include
"
prio
/
encrypt
.
h
"
#
include
"
prio
/
util
.
h
"
static
void
init_data
(
bool
*
data
int
datalen
)
{
for
(
int
i
=
0
;
i
<
datalen
;
i
+
+
)
{
data
[
i
]
=
rand
(
)
%
2
;
}
}
static
SECStatus
read_string_from_hex
(
unsigned
char
*
*
str_out
unsigned
int
*
strLen
const
char
*
input
const
char
*
*
new_input
)
{
SECStatus
rv
=
SECSuccess
;
*
strLen
=
0
;
int
read
=
0
;
int
outCount
=
0
;
const
char
*
inp
=
input
;
while
(
true
)
{
unsigned
char
byte
=
'
\
0
'
;
const
int
retval
=
sscanf
(
inp
"
%
02hhx
%
n
"
&
byte
&
read
)
;
if
(
retval
<
1
|
|
read
!
=
3
)
{
break
;
}
inp
+
=
read
;
(
*
str_out
)
[
outCount
]
=
byte
;
outCount
+
+
;
*
strLen
=
*
strLen
+
1
;
}
if
(
new_input
)
*
new_input
=
inp
+
1
;
return
rv
;
}
static
SECStatus
read_browser_reply
(
FILE
*
infile
unsigned
char
*
*
for_server_a
unsigned
int
*
aLen
unsigned
char
*
*
for_server_b
unsigned
int
*
bLen
)
{
SECStatus
rv
=
SECFailure
;
char
*
raw_input
=
NULL
;
size_t
rawLen
=
0
;
puts
(
"
Getting
line
of
input
.
"
)
;
P_CHECKCB
(
getline
(
&
raw_input
&
rawLen
infile
)
>
0
)
;
puts
(
"
Got
line
of
input
.
"
)
;
P_CHECKA
(
*
for_server_a
=
malloc
(
rawLen
*
sizeof
(
unsigned
char
)
)
)
;
P_CHECKA
(
*
for_server_b
=
malloc
(
rawLen
*
sizeof
(
unsigned
char
)
)
)
;
*
aLen
=
0
;
*
bLen
=
0
;
P_CHECKCB
(
rawLen
>
14
)
;
const
char
*
new_input
;
puts
(
"
Reading
string
A
"
)
;
P_CHECKC
(
read_string_from_hex
(
for_server_a
aLen
raw_input
+
14
&
new_input
)
)
;
puts
(
"
Read
string
A
"
)
;
puts
(
"
Reading
string
B
"
)
;
P_CHECKC
(
read_string_from_hex
(
for_server_b
bLen
new_input
NULL
)
)
;
puts
(
"
Read
string
B
"
)
;
cleanup
:
if
(
raw_input
)
free
(
raw_input
)
;
return
rv
;
}
static
int
verify_full
(
const
char
*
path_to_xpcshell
int
pathlen
)
{
SECStatus
rv
=
SECSuccess
;
PublicKey
pkA
=
NULL
;
PublicKey
pkB
=
NULL
;
PrivateKey
skA
=
NULL
;
PrivateKey
skB
=
NULL
;
PrioConfig
cfg
=
NULL
;
PrioServer
sA
=
NULL
;
PrioServer
sB
=
NULL
;
PrioVerifier
vA
=
NULL
;
PrioVerifier
vB
=
NULL
;
PrioPacketVerify1
p1A
=
NULL
;
PrioPacketVerify1
p1B
=
NULL
;
PrioPacketVerify2
p2A
=
NULL
;
PrioPacketVerify2
p2B
=
NULL
;
PrioTotalShare
tA
=
NULL
;
PrioTotalShare
tB
=
NULL
;
FILE
*
shell
=
NULL
;
int
cmdlen
=
pathlen
+
2
*
CURVE25519_KEY_LEN_HEX
+
128
;
char
cmd
[
cmdlen
]
;
memset
(
cmd
0
cmdlen
)
;
unsigned
char
*
for_server_a
=
NULL
;
unsigned
char
*
for_server_b
=
NULL
;
const
int
seed
=
time
(
NULL
)
;
srand
(
seed
)
;
printf
(
"
Using
srand
seed
%
d
\
n
"
seed
)
;
const
int
ndata
=
3
;
unsigned
char
batch_id_str
[
32
]
;
memset
(
batch_id_str
0
sizeof
batch_id_str
)
;
snprintf
(
(
char
*
)
batch_id_str
sizeof
batch_id_str
"
%
d
"
rand
(
)
)
;
bool
data_items
[
ndata
]
;
unsigned
long
output
[
ndata
]
;
init_data
(
data_items
ndata
)
;
P_CHECKC
(
Prio_init
(
)
)
;
P_CHECKC
(
Keypair_new
(
&
skA
&
pkA
)
)
;
P_CHECKC
(
Keypair_new
(
&
skB
&
pkB
)
)
;
unsigned
char
pk_hexA
[
CURVE25519_KEY_LEN_HEX
+
1
]
;
unsigned
char
pk_hexB
[
CURVE25519_KEY_LEN_HEX
+
1
]
;
P_CHECKC
(
PublicKey_export_hex
(
pkA
pk_hexA
)
)
;
P_CHECKC
(
PublicKey_export_hex
(
pkB
pk_hexB
)
)
;
snprintf
(
cmd
cmdlen
"
%
s
%
s
%
s
%
s
%
s
%
d
%
d
%
d
"
path_to_xpcshell
"
encode
-
once
.
js
"
pk_hexA
pk_hexB
batch_id_str
data_items
[
0
]
data_items
[
1
]
data_items
[
2
]
)
;
printf
(
"
>
%
s
\
n
"
cmd
)
;
P_CHECKA
(
shell
=
popen
(
cmd
"
r
"
)
)
;
puts
(
"
Ran
command
.
"
)
;
P_CHECKA
(
cfg
=
PrioConfig_new
(
ndata
pkA
pkB
batch_id_str
strlen
(
(
char
*
)
batch_id_str
)
)
)
;
PrioPRGSeed
server_secret
;
P_CHECKC
(
PrioPRGSeed_randomize
(
&
server_secret
)
)
;
P_CHECKA
(
sA
=
PrioServer_new
(
cfg
PRIO_SERVER_A
skA
server_secret
)
)
;
P_CHECKA
(
sB
=
PrioServer_new
(
cfg
PRIO_SERVER_B
skB
server_secret
)
)
;
P_CHECKA
(
vA
=
PrioVerifier_new
(
sA
)
)
;
P_CHECKA
(
vB
=
PrioVerifier_new
(
sB
)
)
;
P_CHECKA
(
tA
=
PrioTotalShare_new
(
)
)
;
P_CHECKA
(
tB
=
PrioTotalShare_new
(
)
)
;
P_CHECKA
(
p1A
=
PrioPacketVerify1_new
(
)
)
;
P_CHECKA
(
p1B
=
PrioPacketVerify1_new
(
)
)
;
P_CHECKA
(
p2A
=
PrioPacketVerify2_new
(
)
)
;
P_CHECKA
(
p2B
=
PrioPacketVerify2_new
(
)
)
;
unsigned
int
aLen
=
0
bLen
=
0
;
puts
(
"
Reading
.
.
.
"
)
;
P_CHECKC
(
read_browser_reply
(
shell
&
for_server_a
&
aLen
&
for_server_b
&
bLen
)
)
;
printf
(
"
Read
reply
from
browser
.
LenA
:
%
u
LenB
:
%
u
\
n
"
aLen
bLen
)
;
P_CHECKC
(
PrioVerifier_set_data
(
vA
for_server_a
aLen
)
)
;
P_CHECKC
(
PrioVerifier_set_data
(
vB
for_server_b
bLen
)
)
;
puts
(
"
Imported
data
.
"
)
;
P_CHECKC
(
PrioPacketVerify1_set_data
(
p1A
vA
)
)
;
P_CHECKC
(
PrioPacketVerify1_set_data
(
p1B
vB
)
)
;
puts
(
"
Set
data
.
"
)
;
P_CHECKC
(
PrioPacketVerify2_set_data
(
p2A
vA
p1A
p1B
)
)
;
P_CHECKC
(
PrioPacketVerify2_set_data
(
p2B
vB
p1A
p1B
)
)
;
puts
(
"
Checking
validity
.
"
)
;
P_CHECKC
(
PrioVerifier_isValid
(
vA
p2A
p2B
)
)
;
P_CHECKC
(
PrioVerifier_isValid
(
vB
p2A
p2B
)
)
;
puts
(
"
Are
valid
.
"
)
;
P_CHECKC
(
PrioServer_aggregate
(
sA
vA
)
)
;
P_CHECKC
(
PrioServer_aggregate
(
sB
vB
)
)
;
P_CHECKC
(
PrioTotalShare_set_data
(
tA
sA
)
)
;
P_CHECKC
(
PrioTotalShare_set_data
(
tB
sB
)
)
;
P_CHECKC
(
PrioTotalShare_final
(
cfg
output
tA
tB
)
)
;
for
(
int
i
=
0
;
i
<
ndata
;
i
+
+
)
{
P_CHECKCB
(
output
[
i
]
=
=
data_items
[
i
]
)
;
}
puts
(
"
Success
!
"
)
;
cleanup
:
if
(
rv
!
=
SECSuccess
)
{
fprintf
(
stderr
"
Warning
:
unexpected
failure
.
\
n
"
)
;
}
if
(
for_server_a
)
free
(
for_server_a
)
;
if
(
for_server_b
)
free
(
for_server_b
)
;
PrioTotalShare_clear
(
tA
)
;
PrioTotalShare_clear
(
tB
)
;
PrioPacketVerify2_clear
(
p2A
)
;
PrioPacketVerify2_clear
(
p2B
)
;
PrioPacketVerify1_clear
(
p1A
)
;
PrioPacketVerify1_clear
(
p1B
)
;
PrioVerifier_clear
(
vA
)
;
PrioVerifier_clear
(
vB
)
;
PrioServer_clear
(
sA
)
;
PrioServer_clear
(
sB
)
;
PrioConfig_clear
(
cfg
)
;
PublicKey_clear
(
pkA
)
;
PublicKey_clear
(
pkB
)
;
PrivateKey_clear
(
skA
)
;
PrivateKey_clear
(
skB
)
;
Prio_clear
(
)
;
return
!
(
rv
=
=
SECSuccess
)
;
}
int
main
(
int
argc
char
*
*
argv
)
{
puts
(
"
=
=
Prio
browser
test
utility
.
=
=
"
)
;
puts
(
"
(
Note
:
Expects
to
be
run
in
the
same
directory
as
encode
-
once
.
js
.
)
"
)
;
if
(
argc
!
=
2
)
{
fprintf
(
stderr
"
Usage
.
/
%
s
<
path_to_xpcshell
>
\
n
"
argv
[
0
]
)
;
return
1
;
}
return
verify_full
(
argv
[
1
]
strlen
(
argv
[
1
]
)
)
;
}
