#
ifdef
HAVE_CONFIG_H
#
include
<
config
.
h
>
#
endif
#
include
<
stdio
.
h
>
#
include
"
getopt_s
.
h
"
#
include
"
rdbx
.
h
"
#
include
"
cipher_priv
.
h
"
#
ifdef
ROC_TEST
#
error
"
srtp_rdbx_t
won
'
t
work
with
ROC_TEST
-
bitmask
same
size
as
seq_median
"
#
endif
#
include
"
ut_sim
.
h
"
srtp_err_status_t
test_replay_dbx
(
int
num_trials
unsigned
long
ws
)
;
double
rdbx_check_adds_per_second
(
int
num_trials
unsigned
long
ws
)
;
void
usage
(
char
*
prog_name
)
{
printf
(
"
usage
:
%
s
[
-
t
|
-
v
]
\
n
"
prog_name
)
;
exit
(
255
)
;
}
int
main
(
int
argc
char
*
argv
[
]
)
{
double
rate
;
srtp_err_status_t
status
;
int
q
;
unsigned
do_timing_test
=
0
;
unsigned
do_validation
=
0
;
while
(
1
)
{
q
=
getopt_s
(
argc
argv
"
tv
"
)
;
if
(
q
=
=
-
1
)
break
;
switch
(
q
)
{
case
'
t
'
:
do_timing_test
=
1
;
break
;
case
'
v
'
:
do_validation
=
1
;
break
;
default
:
usage
(
argv
[
0
]
)
;
}
}
printf
(
"
rdbx
(
replay
database
w
/
extended
range
)
test
driver
\
n
"
"
David
A
.
McGrew
\
n
"
"
Cisco
Systems
Inc
.
\
n
"
)
;
if
(
!
do_validation
&
&
!
do_timing_test
)
usage
(
argv
[
0
]
)
;
if
(
do_validation
)
{
printf
(
"
testing
srtp_rdbx_t
(
ws
=
128
)
.
.
.
\
n
"
)
;
status
=
test_replay_dbx
(
1
<
<
12
128
)
;
if
(
status
)
{
printf
(
"
failed
\
n
"
)
;
exit
(
1
)
;
}
printf
(
"
passed
\
n
"
)
;
printf
(
"
testing
srtp_rdbx_t
(
ws
=
1024
)
.
.
.
\
n
"
)
;
status
=
test_replay_dbx
(
1
<
<
12
1024
)
;
if
(
status
)
{
printf
(
"
failed
\
n
"
)
;
exit
(
1
)
;
}
printf
(
"
passed
\
n
"
)
;
}
if
(
do_timing_test
)
{
rate
=
rdbx_check_adds_per_second
(
1
<
<
18
128
)
;
printf
(
"
rdbx_check
/
replay_adds
per
second
(
ws
=
128
)
:
%
e
\
n
"
rate
)
;
rate
=
rdbx_check_adds_per_second
(
1
<
<
18
1024
)
;
printf
(
"
rdbx_check
/
replay_adds
per
second
(
ws
=
1024
)
:
%
e
\
n
"
rate
)
;
}
return
0
;
}
srtp_err_status_t
rdbx_check_add
(
srtp_rdbx_t
*
rdbx
uint32_t
idx
)
{
int
delta
;
srtp_xtd_seq_num_t
est
;
delta
=
srtp_index_guess
(
&
rdbx
-
>
index
&
est
(
srtp_sequence_number_t
)
idx
)
;
if
(
srtp_rdbx_check
(
rdbx
delta
)
!
=
srtp_err_status_ok
)
{
printf
(
"
replay_check
failed
at
index
%
u
\
n
"
idx
)
;
return
srtp_err_status_algo_fail
;
}
if
(
srtp_rdbx_add_index
(
rdbx
delta
)
!
=
srtp_err_status_ok
)
{
printf
(
"
rdbx_add_index
failed
at
index
%
u
\
n
"
idx
)
;
return
srtp_err_status_algo_fail
;
}
return
srtp_err_status_ok
;
}
srtp_err_status_t
rdbx_check_expect_failure
(
srtp_rdbx_t
*
rdbx
uint32_t
idx
)
{
int
delta
;
srtp_xtd_seq_num_t
est
;
srtp_err_status_t
status
;
delta
=
srtp_index_guess
(
&
rdbx
-
>
index
&
est
(
srtp_sequence_number_t
)
idx
)
;
status
=
srtp_rdbx_check
(
rdbx
delta
)
;
if
(
status
=
=
srtp_err_status_ok
)
{
printf
(
"
delta
:
%
d
"
delta
)
;
printf
(
"
replay_check
failed
at
index
%
u
(
false
positive
)
\
n
"
idx
)
;
return
srtp_err_status_algo_fail
;
}
return
srtp_err_status_ok
;
}
srtp_err_status_t
rdbx_check_add_unordered
(
srtp_rdbx_t
*
rdbx
uint32_t
idx
)
{
int
delta
;
srtp_xtd_seq_num_t
est
;
srtp_err_status_t
rstat
;
delta
=
srtp_index_guess
(
&
rdbx
-
>
index
&
est
(
srtp_sequence_number_t
)
idx
)
;
rstat
=
srtp_rdbx_check
(
rdbx
delta
)
;
if
(
(
rstat
!
=
srtp_err_status_ok
)
&
&
(
rstat
!
=
srtp_err_status_replay_old
)
)
{
printf
(
"
replay_check_add_unordered
failed
at
index
%
u
\
n
"
idx
)
;
return
srtp_err_status_algo_fail
;
}
if
(
rstat
=
=
srtp_err_status_replay_old
)
{
return
srtp_err_status_ok
;
}
if
(
srtp_rdbx_add_index
(
rdbx
delta
)
!
=
srtp_err_status_ok
)
{
printf
(
"
rdbx_add_index
failed
at
index
%
u
\
n
"
idx
)
;
return
srtp_err_status_algo_fail
;
}
return
srtp_err_status_ok
;
}
srtp_err_status_t
test_replay_dbx
(
int
num_trials
unsigned
long
ws
)
{
srtp_rdbx_t
rdbx
;
uint32_t
idx
ircvd
;
ut_connection
utc
;
srtp_err_status_t
status
;
int
num_fp_trials
;
status
=
srtp_rdbx_init
(
&
rdbx
ws
)
;
if
(
status
)
{
printf
(
"
replay_init
failed
with
error
code
%
d
\
n
"
status
)
;
exit
(
1
)
;
}
printf
(
"
\
ttesting
sequential
insertion
.
.
.
"
)
;
for
(
idx
=
0
;
(
int
)
idx
<
num_trials
;
idx
+
+
)
{
status
=
rdbx_check_add
(
&
rdbx
idx
)
;
if
(
status
)
return
status
;
}
printf
(
"
passed
\
n
"
)
;
num_fp_trials
=
num_trials
%
0x10000
;
if
(
num_fp_trials
=
=
0
)
{
printf
(
"
warning
:
no
false
positive
tests
performed
\
n
"
)
;
}
printf
(
"
\
ttesting
for
false
positives
.
.
.
"
)
;
for
(
idx
=
0
;
(
int
)
idx
<
num_fp_trials
;
idx
+
+
)
{
status
=
rdbx_check_expect_failure
(
&
rdbx
idx
)
;
if
(
status
)
return
status
;
}
printf
(
"
passed
\
n
"
)
;
srtp_rdbx_dealloc
(
&
rdbx
)
;
if
(
srtp_rdbx_init
(
&
rdbx
ws
)
!
=
srtp_err_status_ok
)
{
printf
(
"
replay_init
failed
\
n
"
)
;
return
srtp_err_status_init_fail
;
}
ut_init
(
&
utc
)
;
printf
(
"
\
ttesting
non
-
sequential
insertion
.
.
.
"
)
;
for
(
idx
=
0
;
(
int
)
idx
<
num_trials
;
idx
+
+
)
{
ircvd
=
ut_next_index
(
&
utc
)
;
status
=
rdbx_check_add_unordered
(
&
rdbx
ircvd
)
;
if
(
status
)
return
status
;
status
=
rdbx_check_expect_failure
(
&
rdbx
ircvd
)
;
if
(
status
)
return
status
;
}
printf
(
"
passed
\
n
"
)
;
srtp_rdbx_dealloc
(
&
rdbx
)
;
if
(
srtp_rdbx_init
(
&
rdbx
ws
)
!
=
srtp_err_status_ok
)
{
printf
(
"
replay_init
failed
\
n
"
)
;
return
srtp_err_status_init_fail
;
}
printf
(
"
\
ttesting
insertion
with
large
gaps
.
.
.
"
)
;
for
(
idx
=
0
ircvd
=
0
;
(
int
)
idx
<
num_trials
;
idx
+
+
ircvd
+
=
(
1
<
<
(
srtp_cipher_rand_u32_for_tests
(
)
%
12
)
)
)
{
status
=
rdbx_check_add
(
&
rdbx
ircvd
)
;
if
(
status
)
return
status
;
status
=
rdbx_check_expect_failure
(
&
rdbx
ircvd
)
;
if
(
status
)
return
status
;
}
printf
(
"
passed
\
n
"
)
;
srtp_rdbx_dealloc
(
&
rdbx
)
;
return
srtp_err_status_ok
;
}
#
include
<
time
.
h
>
double
rdbx_check_adds_per_second
(
int
num_trials
unsigned
long
ws
)
{
uint32_t
i
;
int
delta
;
srtp_rdbx_t
rdbx
;
srtp_xtd_seq_num_t
est
;
clock_t
timer
;
int
failures
;
if
(
srtp_rdbx_init
(
&
rdbx
ws
)
!
=
srtp_err_status_ok
)
{
printf
(
"
replay_init
failed
\
n
"
)
;
exit
(
1
)
;
}
failures
=
0
;
timer
=
clock
(
)
;
for
(
i
=
0
;
(
int
)
i
<
num_trials
;
i
+
+
)
{
delta
=
srtp_index_guess
(
&
rdbx
.
index
&
est
(
srtp_sequence_number_t
)
i
)
;
if
(
srtp_rdbx_check
(
&
rdbx
delta
)
!
=
srtp_err_status_ok
)
+
+
failures
;
else
if
(
srtp_rdbx_add_index
(
&
rdbx
delta
)
!
=
srtp_err_status_ok
)
+
+
failures
;
}
timer
=
clock
(
)
-
timer
;
if
(
timer
<
1
)
{
timer
=
1
;
}
printf
(
"
number
of
failures
:
%
d
\
n
"
failures
)
;
srtp_rdbx_dealloc
(
&
rdbx
)
;
return
(
double
)
CLOCKS_PER_SEC
*
num_trials
/
timer
;
}
