#
ifdef
HAVE_CONFIG_H
#
include
<
config
.
h
>
#
endif
#
include
"
aes_gcm
.
h
"
#
include
"
alloc
.
h
"
#
include
"
err
.
h
"
#
include
"
crypto_types
.
h
"
#
include
"
cipher_types
.
h
"
#
include
"
cipher_test_cases
.
h
"
#
include
<
secerr
.
h
>
#
include
<
nspr
.
h
>
srtp_debug_module_t
srtp_mod_aes_gcm
=
{
0
"
aes
gcm
nss
"
}
;
#
define
GCM_IV_LEN
12
#
define
GCM_AUTH_TAG_LEN
16
#
define
GCM_AUTH_TAG_LEN_8
8
static
srtp_err_status_t
srtp_aes_gcm_nss_alloc
(
srtp_cipher_t
*
*
c
int
key_len
int
tlen
)
{
srtp_aes_gcm_ctx_t
*
gcm
;
NSSInitContext
*
nss
;
debug_print
(
srtp_mod_aes_gcm
"
allocating
cipher
with
key
length
%
d
"
key_len
)
;
debug_print
(
srtp_mod_aes_gcm
"
allocating
cipher
with
tag
length
%
d
"
tlen
)
;
if
(
key_len
!
=
SRTP_AES_GCM_128_KEY_LEN_WSALT
&
&
key_len
!
=
SRTP_AES_GCM_256_KEY_LEN_WSALT
)
{
return
(
srtp_err_status_bad_param
)
;
}
if
(
tlen
!
=
GCM_AUTH_TAG_LEN
&
&
tlen
!
=
GCM_AUTH_TAG_LEN_8
)
{
return
(
srtp_err_status_bad_param
)
;
}
nss
=
NSS_InitContext
(
"
"
"
"
"
"
"
"
NULL
NSS_INIT_READONLY
|
NSS_INIT_NOCERTDB
|
NSS_INIT_NOMODDB
|
NSS_INIT_FORCEOPEN
|
NSS_INIT_OPTIMIZESPACE
)
;
if
(
!
nss
)
{
return
(
srtp_err_status_cipher_fail
)
;
}
*
c
=
(
srtp_cipher_t
*
)
srtp_crypto_alloc
(
sizeof
(
srtp_cipher_t
)
)
;
if
(
*
c
=
=
NULL
)
{
NSS_ShutdownContext
(
nss
)
;
return
(
srtp_err_status_alloc_fail
)
;
}
gcm
=
(
srtp_aes_gcm_ctx_t
*
)
srtp_crypto_alloc
(
sizeof
(
srtp_aes_gcm_ctx_t
)
)
;
if
(
gcm
=
=
NULL
)
{
NSS_ShutdownContext
(
nss
)
;
srtp_crypto_free
(
*
c
)
;
*
c
=
NULL
;
return
(
srtp_err_status_alloc_fail
)
;
}
gcm
-
>
nss
=
nss
;
(
*
c
)
-
>
state
=
gcm
;
switch
(
key_len
)
{
case
SRTP_AES_GCM_128_KEY_LEN_WSALT
:
(
*
c
)
-
>
type
=
&
srtp_aes_gcm_128
;
(
*
c
)
-
>
algorithm
=
SRTP_AES_GCM_128
;
gcm
-
>
key_size
=
SRTP_AES_128_KEY_LEN
;
gcm
-
>
tag_size
=
tlen
;
gcm
-
>
params
.
ulTagBits
=
8
*
tlen
;
break
;
case
SRTP_AES_GCM_256_KEY_LEN_WSALT
:
(
*
c
)
-
>
type
=
&
srtp_aes_gcm_256
;
(
*
c
)
-
>
algorithm
=
SRTP_AES_GCM_256
;
gcm
-
>
key_size
=
SRTP_AES_256_KEY_LEN
;
gcm
-
>
tag_size
=
tlen
;
gcm
-
>
params
.
ulTagBits
=
8
*
tlen
;
break
;
default
:
return
(
srtp_err_status_bad_param
)
;
}
(
*
c
)
-
>
key_len
=
key_len
;
return
(
srtp_err_status_ok
)
;
}
static
srtp_err_status_t
srtp_aes_gcm_nss_dealloc
(
srtp_cipher_t
*
c
)
{
srtp_aes_gcm_ctx_t
*
ctx
;
ctx
=
(
srtp_aes_gcm_ctx_t
*
)
c
-
>
state
;
if
(
ctx
)
{
if
(
ctx
-
>
key
)
{
PK11_FreeSymKey
(
ctx
-
>
key
)
;
}
if
(
ctx
-
>
nss
)
{
NSS_ShutdownContext
(
ctx
-
>
nss
)
;
ctx
-
>
nss
=
NULL
;
}
octet_string_set_to_zero
(
ctx
sizeof
(
srtp_aes_gcm_ctx_t
)
)
;
srtp_crypto_free
(
ctx
)
;
}
srtp_crypto_free
(
c
)
;
return
(
srtp_err_status_ok
)
;
}
static
srtp_err_status_t
srtp_aes_gcm_nss_context_init
(
void
*
cv
const
uint8_t
*
key
)
{
srtp_aes_gcm_ctx_t
*
c
=
(
srtp_aes_gcm_ctx_t
*
)
cv
;
c
-
>
dir
=
srtp_direction_any
;
debug_print
(
srtp_mod_aes_gcm
"
key
:
%
s
"
srtp_octet_string_hex_string
(
key
c
-
>
key_size
)
)
;
if
(
c
-
>
key
)
{
PK11_FreeSymKey
(
c
-
>
key
)
;
c
-
>
key
=
NULL
;
}
PK11SlotInfo
*
slot
=
PK11_GetBestSlot
(
CKM_AES_GCM
NULL
)
;
if
(
!
slot
)
{
return
(
srtp_err_status_cipher_fail
)
;
}
SECItem
key_item
=
{
siBuffer
(
unsigned
char
*
)
key
c
-
>
key_size
}
;
c
-
>
key
=
PK11_ImportSymKey
(
slot
CKM_AES_GCM
PK11_OriginUnwrap
CKA_ENCRYPT
&
key_item
NULL
)
;
PK11_FreeSlot
(
slot
)
;
if
(
!
c
-
>
key
)
{
return
(
srtp_err_status_cipher_fail
)
;
}
return
(
srtp_err_status_ok
)
;
}
static
srtp_err_status_t
srtp_aes_gcm_nss_set_iv
(
void
*
cv
uint8_t
*
iv
srtp_cipher_direction_t
direction
)
{
srtp_aes_gcm_ctx_t
*
c
=
(
srtp_aes_gcm_ctx_t
*
)
cv
;
if
(
direction
!
=
srtp_direction_encrypt
&
&
direction
!
=
srtp_direction_decrypt
)
{
return
(
srtp_err_status_bad_param
)
;
}
c
-
>
dir
=
direction
;
debug_print
(
srtp_mod_aes_gcm
"
setting
iv
:
%
s
"
srtp_octet_string_hex_string
(
iv
GCM_IV_LEN
)
)
;
memcpy
(
c
-
>
iv
iv
GCM_IV_LEN
)
;
return
(
srtp_err_status_ok
)
;
}
static
srtp_err_status_t
srtp_aes_gcm_nss_set_aad
(
void
*
cv
const
uint8_t
*
aad
uint32_t
aad_len
)
{
srtp_aes_gcm_ctx_t
*
c
=
(
srtp_aes_gcm_ctx_t
*
)
cv
;
debug_print
(
srtp_mod_aes_gcm
"
setting
AAD
:
%
s
"
srtp_octet_string_hex_string
(
aad
aad_len
)
)
;
if
(
aad_len
+
c
-
>
aad_size
>
MAX_AD_SIZE
)
{
return
srtp_err_status_bad_param
;
}
memcpy
(
c
-
>
aad
+
c
-
>
aad_size
aad
aad_len
)
;
c
-
>
aad_size
+
=
aad_len
;
return
(
srtp_err_status_ok
)
;
}
static
srtp_err_status_t
srtp_aes_gcm_nss_do_crypto
(
void
*
cv
int
encrypt
unsigned
char
*
buf
unsigned
int
*
enc_len
)
{
srtp_aes_gcm_ctx_t
*
c
=
(
srtp_aes_gcm_ctx_t
*
)
cv
;
c
-
>
params
.
pIv
=
c
-
>
iv
;
c
-
>
params
.
ulIvLen
=
GCM_IV_LEN
;
c
-
>
params
.
pAAD
=
c
-
>
aad
;
c
-
>
params
.
ulAADLen
=
c
-
>
aad_size
;
c
-
>
aad_size
=
0
;
int
rv
;
SECItem
param
=
{
siBuffer
(
unsigned
char
*
)
&
c
-
>
params
sizeof
(
CK_GCM_PARAMS
)
}
;
if
(
encrypt
)
{
rv
=
PK11_Encrypt
(
c
-
>
key
CKM_AES_GCM
&
param
buf
enc_len
*
enc_len
+
16
buf
*
enc_len
)
;
}
else
{
rv
=
PK11_Decrypt
(
c
-
>
key
CKM_AES_GCM
&
param
buf
enc_len
*
enc_len
buf
*
enc_len
)
;
}
srtp_err_status_t
status
=
(
srtp_err_status_ok
)
;
if
(
rv
!
=
SECSuccess
)
{
status
=
(
srtp_err_status_cipher_fail
)
;
}
return
status
;
}
static
srtp_err_status_t
srtp_aes_gcm_nss_encrypt
(
void
*
cv
unsigned
char
*
buf
unsigned
int
*
enc_len
)
{
srtp_aes_gcm_ctx_t
*
c
=
(
srtp_aes_gcm_ctx_t
*
)
cv
;
unsigned
char
tagbuf
[
16
]
;
unsigned
char
*
non_null_buf
=
buf
;
if
(
!
non_null_buf
&
&
(
*
enc_len
=
=
0
)
)
{
non_null_buf
=
tagbuf
;
}
else
if
(
!
non_null_buf
)
{
return
srtp_err_status_bad_param
;
}
srtp_err_status_t
status
=
srtp_aes_gcm_nss_do_crypto
(
cv
1
non_null_buf
enc_len
)
;
if
(
status
!
=
srtp_err_status_ok
)
{
return
status
;
}
memcpy
(
c
-
>
tag
non_null_buf
+
(
*
enc_len
-
c
-
>
tag_size
)
c
-
>
tag_size
)
;
*
enc_len
-
=
c
-
>
tag_size
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_aes_gcm_nss_get_tag
(
void
*
cv
uint8_t
*
buf
uint32_t
*
len
)
{
srtp_aes_gcm_ctx_t
*
c
=
(
srtp_aes_gcm_ctx_t
*
)
cv
;
*
len
=
c
-
>
tag_size
;
memcpy
(
buf
c
-
>
tag
c
-
>
tag_size
)
;
return
(
srtp_err_status_ok
)
;
}
static
srtp_err_status_t
srtp_aes_gcm_nss_decrypt
(
void
*
cv
unsigned
char
*
buf
unsigned
int
*
enc_len
)
{
srtp_err_status_t
status
=
srtp_aes_gcm_nss_do_crypto
(
cv
0
buf
enc_len
)
;
if
(
status
!
=
srtp_err_status_ok
)
{
int
err
=
PR_GetError
(
)
;
if
(
err
=
=
SEC_ERROR_BAD_DATA
)
{
status
=
srtp_err_status_auth_fail
;
}
}
return
status
;
}
static
const
char
srtp_aes_gcm_128_nss_description
[
]
=
"
AES
-
128
GCM
using
NSS
"
;
static
const
char
srtp_aes_gcm_256_nss_description
[
]
=
"
AES
-
256
GCM
using
NSS
"
;
const
srtp_cipher_type_t
srtp_aes_gcm_128
=
{
srtp_aes_gcm_nss_alloc
srtp_aes_gcm_nss_dealloc
srtp_aes_gcm_nss_context_init
srtp_aes_gcm_nss_set_aad
srtp_aes_gcm_nss_encrypt
srtp_aes_gcm_nss_decrypt
srtp_aes_gcm_nss_set_iv
srtp_aes_gcm_nss_get_tag
srtp_aes_gcm_128_nss_description
&
srtp_aes_gcm_128_test_case_0
SRTP_AES_GCM_128
}
;
const
srtp_cipher_type_t
srtp_aes_gcm_256
=
{
srtp_aes_gcm_nss_alloc
srtp_aes_gcm_nss_dealloc
srtp_aes_gcm_nss_context_init
srtp_aes_gcm_nss_set_aad
srtp_aes_gcm_nss_encrypt
srtp_aes_gcm_nss_decrypt
srtp_aes_gcm_nss_set_iv
srtp_aes_gcm_nss_get_tag
srtp_aes_gcm_256_nss_description
&
srtp_aes_gcm_256_test_case_0
SRTP_AES_GCM_256
}
;
