#
ifdef
HAVE_CONFIG_H
#
include
<
config
.
h
>
#
endif
#
define
ALIGN_32
0
#
include
"
aes_icm
.
h
"
#
include
"
alloc
.
h
"
#
include
"
cipher_types
.
h
"
#
include
"
cipher_test_cases
.
h
"
srtp_debug_module_t
srtp_mod_aes_icm
=
{
0
"
aes
icm
"
}
;
static
srtp_err_status_t
srtp_aes_icm_alloc
(
srtp_cipher_t
*
*
c
int
key_len
int
tlen
)
{
srtp_aes_icm_ctx_t
*
icm
;
debug_print
(
srtp_mod_aes_icm
"
allocating
cipher
with
key
length
%
d
"
key_len
)
;
if
(
key_len
!
=
SRTP_AES_ICM_128_KEY_LEN_WSALT
&
&
key_len
!
=
SRTP_AES_ICM_256_KEY_LEN_WSALT
)
{
return
srtp_err_status_bad_param
;
}
*
c
=
(
srtp_cipher_t
*
)
srtp_crypto_alloc
(
sizeof
(
srtp_cipher_t
)
)
;
if
(
*
c
=
=
NULL
)
{
return
srtp_err_status_alloc_fail
;
}
icm
=
(
srtp_aes_icm_ctx_t
*
)
srtp_crypto_alloc
(
sizeof
(
srtp_aes_icm_ctx_t
)
)
;
if
(
icm
=
=
NULL
)
{
srtp_crypto_free
(
*
c
)
;
*
c
=
NULL
;
return
srtp_err_status_alloc_fail
;
}
(
*
c
)
-
>
state
=
icm
;
switch
(
key_len
)
{
case
SRTP_AES_ICM_256_KEY_LEN_WSALT
:
(
*
c
)
-
>
algorithm
=
SRTP_AES_ICM_256
;
(
*
c
)
-
>
type
=
&
srtp_aes_icm_256
;
break
;
default
:
(
*
c
)
-
>
algorithm
=
SRTP_AES_ICM_128
;
(
*
c
)
-
>
type
=
&
srtp_aes_icm_128
;
break
;
}
icm
-
>
key_size
=
key_len
;
(
*
c
)
-
>
key_len
=
key_len
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_aes_icm_dealloc
(
srtp_cipher_t
*
c
)
{
srtp_aes_icm_ctx_t
*
ctx
;
if
(
c
=
=
NULL
)
{
return
srtp_err_status_bad_param
;
}
ctx
=
(
srtp_aes_icm_ctx_t
*
)
c
-
>
state
;
if
(
ctx
)
{
octet_string_set_to_zero
(
ctx
sizeof
(
srtp_aes_icm_ctx_t
)
)
;
srtp_crypto_free
(
ctx
)
;
}
srtp_crypto_free
(
c
)
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_aes_icm_context_init
(
void
*
cv
const
uint8_t
*
key
)
{
srtp_aes_icm_ctx_t
*
c
=
(
srtp_aes_icm_ctx_t
*
)
cv
;
srtp_err_status_t
status
;
int
base_key_len
copy_len
;
if
(
c
-
>
key_size
=
=
SRTP_AES_ICM_128_KEY_LEN_WSALT
|
|
c
-
>
key_size
=
=
SRTP_AES_ICM_256_KEY_LEN_WSALT
)
{
base_key_len
=
c
-
>
key_size
-
SRTP_SALT_LEN
;
}
else
{
return
srtp_err_status_bad_param
;
}
v128_set_to_zero
(
&
c
-
>
counter
)
;
v128_set_to_zero
(
&
c
-
>
offset
)
;
copy_len
=
c
-
>
key_size
-
base_key_len
;
if
(
copy_len
>
SRTP_SALT_LEN
)
{
copy_len
=
SRTP_SALT_LEN
;
}
memcpy
(
&
c
-
>
counter
key
+
base_key_len
copy_len
)
;
memcpy
(
&
c
-
>
offset
key
+
base_key_len
copy_len
)
;
debug_print
(
srtp_mod_aes_icm
"
key
:
%
s
"
srtp_octet_string_hex_string
(
key
base_key_len
)
)
;
debug_print
(
srtp_mod_aes_icm
"
offset
:
%
s
"
v128_hex_string
(
&
c
-
>
offset
)
)
;
status
=
srtp_aes_expand_encryption_key
(
key
base_key_len
&
c
-
>
expanded_key
)
;
if
(
status
)
{
v128_set_to_zero
(
&
c
-
>
counter
)
;
v128_set_to_zero
(
&
c
-
>
offset
)
;
return
status
;
}
c
-
>
bytes_in_buffer
=
0
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_aes_icm_set_iv
(
void
*
cv
uint8_t
*
iv
srtp_cipher_direction_t
direction
)
{
srtp_aes_icm_ctx_t
*
c
=
(
srtp_aes_icm_ctx_t
*
)
cv
;
v128_t
nonce
;
v128_copy_octet_string
(
&
nonce
iv
)
;
debug_print
(
srtp_mod_aes_icm
"
setting
iv
:
%
s
"
v128_hex_string
(
&
nonce
)
)
;
v128_xor
(
&
c
-
>
counter
&
c
-
>
offset
&
nonce
)
;
debug_print
(
srtp_mod_aes_icm
"
set_counter
:
%
s
"
v128_hex_string
(
&
c
-
>
counter
)
)
;
c
-
>
bytes_in_buffer
=
0
;
return
srtp_err_status_ok
;
}
static
void
srtp_aes_icm_advance
(
srtp_aes_icm_ctx_t
*
c
)
{
v128_copy
(
&
c
-
>
keystream_buffer
&
c
-
>
counter
)
;
srtp_aes_encrypt
(
&
c
-
>
keystream_buffer
&
c
-
>
expanded_key
)
;
c
-
>
bytes_in_buffer
=
sizeof
(
v128_t
)
;
debug_print
(
srtp_mod_aes_icm
"
counter
:
%
s
"
v128_hex_string
(
&
c
-
>
counter
)
)
;
debug_print
(
srtp_mod_aes_icm
"
ciphertext
:
%
s
"
v128_hex_string
(
&
c
-
>
keystream_buffer
)
)
;
if
(
!
+
+
(
c
-
>
counter
.
v8
[
15
]
)
)
{
+
+
(
c
-
>
counter
.
v8
[
14
]
)
;
}
}
static
srtp_err_status_t
srtp_aes_icm_encrypt
(
void
*
cv
unsigned
char
*
buf
unsigned
int
*
enc_len
)
{
srtp_aes_icm_ctx_t
*
c
=
(
srtp_aes_icm_ctx_t
*
)
cv
;
unsigned
int
bytes_to_encr
=
*
enc_len
;
unsigned
int
i
;
uint32_t
*
b
;
if
(
(
bytes_to_encr
+
htons
(
c
-
>
counter
.
v16
[
7
]
)
)
>
0xffff
)
{
return
srtp_err_status_terminus
;
}
debug_print
(
srtp_mod_aes_icm
"
block
index
:
%
d
"
htons
(
c
-
>
counter
.
v16
[
7
]
)
)
;
if
(
bytes_to_encr
<
=
(
unsigned
int
)
c
-
>
bytes_in_buffer
)
{
for
(
i
=
(
sizeof
(
v128_t
)
-
c
-
>
bytes_in_buffer
)
;
i
<
(
sizeof
(
v128_t
)
-
c
-
>
bytes_in_buffer
+
bytes_to_encr
)
;
i
+
+
)
{
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
i
]
;
}
c
-
>
bytes_in_buffer
-
=
bytes_to_encr
;
return
srtp_err_status_ok
;
}
else
{
for
(
i
=
(
sizeof
(
v128_t
)
-
c
-
>
bytes_in_buffer
)
;
i
<
sizeof
(
v128_t
)
;
i
+
+
)
{
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
i
]
;
}
bytes_to_encr
-
=
c
-
>
bytes_in_buffer
;
c
-
>
bytes_in_buffer
=
0
;
}
for
(
i
=
0
;
i
<
(
bytes_to_encr
/
sizeof
(
v128_t
)
)
;
i
+
+
)
{
srtp_aes_icm_advance
(
c
)
;
#
if
ALIGN_32
b
=
(
uint32_t
*
)
buf
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
0
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
1
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
2
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
3
]
;
buf
=
(
uint8_t
*
)
b
;
#
else
if
(
(
(
(
uintptr_t
)
buf
)
&
0x03
)
!
=
0
)
{
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
0
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
1
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
2
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
3
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
4
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
5
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
6
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
7
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
8
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
9
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
10
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
11
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
12
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
13
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
14
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
15
]
;
}
else
{
b
=
(
uint32_t
*
)
buf
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
0
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
1
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
2
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
3
]
;
buf
=
(
uint8_t
*
)
b
;
}
#
endif
}
if
(
(
bytes_to_encr
&
0xf
)
!
=
0
)
{
srtp_aes_icm_advance
(
c
)
;
for
(
i
=
0
;
i
<
(
bytes_to_encr
&
0xf
)
;
i
+
+
)
{
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
i
]
;
}
c
-
>
bytes_in_buffer
=
sizeof
(
v128_t
)
-
i
;
}
else
{
c
-
>
bytes_in_buffer
=
0
;
}
return
srtp_err_status_ok
;
}
static
const
char
srtp_aes_icm_128_description
[
]
=
"
AES
-
128
integer
counter
mode
"
;
static
const
char
srtp_aes_icm_256_description
[
]
=
"
AES
-
256
integer
counter
mode
"
;
const
srtp_cipher_type_t
srtp_aes_icm_128
=
{
srtp_aes_icm_alloc
srtp_aes_icm_dealloc
srtp_aes_icm_context_init
0
srtp_aes_icm_encrypt
srtp_aes_icm_encrypt
srtp_aes_icm_set_iv
0
srtp_aes_icm_128_description
&
srtp_aes_icm_128_test_case_0
SRTP_AES_ICM_128
}
;
const
srtp_cipher_type_t
srtp_aes_icm_256
=
{
srtp_aes_icm_alloc
srtp_aes_icm_dealloc
srtp_aes_icm_context_init
0
srtp_aes_icm_encrypt
srtp_aes_icm_encrypt
srtp_aes_icm_set_iv
0
srtp_aes_icm_256_description
&
srtp_aes_icm_256_test_case_0
SRTP_AES_ICM_256
}
;
