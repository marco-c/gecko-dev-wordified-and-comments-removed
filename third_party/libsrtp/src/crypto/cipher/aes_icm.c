#
ifdef
HAVE_CONFIG_H
#
include
<
config
.
h
>
#
endif
#
define
ALIGN_32
0
#
include
"
aes_icm
.
h
"
#
include
"
alloc
.
h
"
#
include
"
cipher_types
.
h
"
srtp_debug_module_t
srtp_mod_aes_icm
=
{
0
"
aes
icm
"
}
;
static
srtp_err_status_t
srtp_aes_icm_alloc
(
srtp_cipher_t
*
*
c
int
key_len
int
tlen
)
{
srtp_aes_icm_ctx_t
*
icm
;
debug_print
(
srtp_mod_aes_icm
"
allocating
cipher
with
key
length
%
d
"
key_len
)
;
if
(
key_len
!
=
SRTP_AES_ICM_128_KEY_LEN_WSALT
&
&
key_len
!
=
SRTP_AES_ICM_256_KEY_LEN_WSALT
)
{
return
srtp_err_status_bad_param
;
}
*
c
=
(
srtp_cipher_t
*
)
srtp_crypto_alloc
(
sizeof
(
srtp_cipher_t
)
)
;
if
(
*
c
=
=
NULL
)
{
return
srtp_err_status_alloc_fail
;
}
icm
=
(
srtp_aes_icm_ctx_t
*
)
srtp_crypto_alloc
(
sizeof
(
srtp_aes_icm_ctx_t
)
)
;
if
(
icm
=
=
NULL
)
{
srtp_crypto_free
(
*
c
)
;
*
c
=
NULL
;
return
srtp_err_status_alloc_fail
;
}
(
*
c
)
-
>
state
=
icm
;
switch
(
key_len
)
{
case
SRTP_AES_ICM_256_KEY_LEN_WSALT
:
(
*
c
)
-
>
algorithm
=
SRTP_AES_ICM_256
;
(
*
c
)
-
>
type
=
&
srtp_aes_icm_256
;
break
;
default
:
(
*
c
)
-
>
algorithm
=
SRTP_AES_ICM_128
;
(
*
c
)
-
>
type
=
&
srtp_aes_icm_128
;
break
;
}
icm
-
>
key_size
=
key_len
;
(
*
c
)
-
>
key_len
=
key_len
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_aes_icm_dealloc
(
srtp_cipher_t
*
c
)
{
srtp_aes_icm_ctx_t
*
ctx
;
if
(
c
=
=
NULL
)
{
return
srtp_err_status_bad_param
;
}
ctx
=
(
srtp_aes_icm_ctx_t
*
)
c
-
>
state
;
if
(
ctx
)
{
octet_string_set_to_zero
(
ctx
sizeof
(
srtp_aes_icm_ctx_t
)
)
;
srtp_crypto_free
(
ctx
)
;
}
srtp_crypto_free
(
c
)
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_aes_icm_context_init
(
void
*
cv
const
uint8_t
*
key
)
{
srtp_aes_icm_ctx_t
*
c
=
(
srtp_aes_icm_ctx_t
*
)
cv
;
srtp_err_status_t
status
;
int
base_key_len
copy_len
;
if
(
c
-
>
key_size
=
=
SRTP_AES_ICM_128_KEY_LEN_WSALT
|
|
c
-
>
key_size
=
=
SRTP_AES_ICM_256_KEY_LEN_WSALT
)
{
base_key_len
=
c
-
>
key_size
-
SRTP_SALT_LEN
;
}
else
{
return
srtp_err_status_bad_param
;
}
v128_set_to_zero
(
&
c
-
>
counter
)
;
v128_set_to_zero
(
&
c
-
>
offset
)
;
copy_len
=
c
-
>
key_size
-
base_key_len
;
if
(
copy_len
>
SRTP_SALT_LEN
)
{
copy_len
=
SRTP_SALT_LEN
;
}
memcpy
(
&
c
-
>
counter
key
+
base_key_len
copy_len
)
;
memcpy
(
&
c
-
>
offset
key
+
base_key_len
copy_len
)
;
debug_print
(
srtp_mod_aes_icm
"
key
:
%
s
"
srtp_octet_string_hex_string
(
key
base_key_len
)
)
;
debug_print
(
srtp_mod_aes_icm
"
offset
:
%
s
"
v128_hex_string
(
&
c
-
>
offset
)
)
;
status
=
srtp_aes_expand_encryption_key
(
key
base_key_len
&
c
-
>
expanded_key
)
;
if
(
status
)
{
v128_set_to_zero
(
&
c
-
>
counter
)
;
v128_set_to_zero
(
&
c
-
>
offset
)
;
return
status
;
}
c
-
>
bytes_in_buffer
=
0
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_aes_icm_set_iv
(
void
*
cv
uint8_t
*
iv
srtp_cipher_direction_t
direction
)
{
srtp_aes_icm_ctx_t
*
c
=
(
srtp_aes_icm_ctx_t
*
)
cv
;
v128_t
nonce
;
v128_copy_octet_string
(
&
nonce
iv
)
;
debug_print
(
srtp_mod_aes_icm
"
setting
iv
:
%
s
"
v128_hex_string
(
&
nonce
)
)
;
v128_xor
(
&
c
-
>
counter
&
c
-
>
offset
&
nonce
)
;
debug_print
(
srtp_mod_aes_icm
"
set_counter
:
%
s
"
v128_hex_string
(
&
c
-
>
counter
)
)
;
c
-
>
bytes_in_buffer
=
0
;
return
srtp_err_status_ok
;
}
static
void
srtp_aes_icm_advance
(
srtp_aes_icm_ctx_t
*
c
)
{
v128_copy
(
&
c
-
>
keystream_buffer
&
c
-
>
counter
)
;
srtp_aes_encrypt
(
&
c
-
>
keystream_buffer
&
c
-
>
expanded_key
)
;
c
-
>
bytes_in_buffer
=
sizeof
(
v128_t
)
;
debug_print
(
srtp_mod_aes_icm
"
counter
:
%
s
"
v128_hex_string
(
&
c
-
>
counter
)
)
;
debug_print
(
srtp_mod_aes_icm
"
ciphertext
:
%
s
"
v128_hex_string
(
&
c
-
>
keystream_buffer
)
)
;
if
(
!
+
+
(
c
-
>
counter
.
v8
[
15
]
)
)
{
+
+
(
c
-
>
counter
.
v8
[
14
]
)
;
}
}
static
srtp_err_status_t
srtp_aes_icm_encrypt
(
void
*
cv
unsigned
char
*
buf
unsigned
int
*
enc_len
)
{
srtp_aes_icm_ctx_t
*
c
=
(
srtp_aes_icm_ctx_t
*
)
cv
;
unsigned
int
bytes_to_encr
=
*
enc_len
;
unsigned
int
i
;
uint32_t
*
b
;
if
(
(
bytes_to_encr
+
htons
(
c
-
>
counter
.
v16
[
7
]
)
)
>
0xffff
)
{
return
srtp_err_status_terminus
;
}
debug_print
(
srtp_mod_aes_icm
"
block
index
:
%
d
"
htons
(
c
-
>
counter
.
v16
[
7
]
)
)
;
if
(
bytes_to_encr
<
=
(
unsigned
int
)
c
-
>
bytes_in_buffer
)
{
for
(
i
=
(
sizeof
(
v128_t
)
-
c
-
>
bytes_in_buffer
)
;
i
<
(
sizeof
(
v128_t
)
-
c
-
>
bytes_in_buffer
+
bytes_to_encr
)
;
i
+
+
)
{
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
i
]
;
}
c
-
>
bytes_in_buffer
-
=
bytes_to_encr
;
return
srtp_err_status_ok
;
}
else
{
for
(
i
=
(
sizeof
(
v128_t
)
-
c
-
>
bytes_in_buffer
)
;
i
<
sizeof
(
v128_t
)
;
i
+
+
)
{
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
i
]
;
}
bytes_to_encr
-
=
c
-
>
bytes_in_buffer
;
c
-
>
bytes_in_buffer
=
0
;
}
for
(
i
=
0
;
i
<
(
bytes_to_encr
/
sizeof
(
v128_t
)
)
;
i
+
+
)
{
srtp_aes_icm_advance
(
c
)
;
#
if
ALIGN_32
b
=
(
uint32_t
*
)
buf
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
0
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
1
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
2
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
3
]
;
buf
=
(
uint8_t
*
)
b
;
#
else
if
(
(
(
(
uintptr_t
)
buf
)
&
0x03
)
!
=
0
)
{
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
0
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
1
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
2
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
3
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
4
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
5
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
6
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
7
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
8
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
9
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
10
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
11
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
12
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
13
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
14
]
;
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
15
]
;
}
else
{
b
=
(
uint32_t
*
)
buf
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
0
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
1
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
2
]
;
*
b
+
+
^
=
c
-
>
keystream_buffer
.
v32
[
3
]
;
buf
=
(
uint8_t
*
)
b
;
}
#
endif
}
if
(
(
bytes_to_encr
&
0xf
)
!
=
0
)
{
srtp_aes_icm_advance
(
c
)
;
for
(
i
=
0
;
i
<
(
bytes_to_encr
&
0xf
)
;
i
+
+
)
{
*
buf
+
+
^
=
c
-
>
keystream_buffer
.
v8
[
i
]
;
}
c
-
>
bytes_in_buffer
=
sizeof
(
v128_t
)
-
i
;
}
else
{
c
-
>
bytes_in_buffer
=
0
;
}
return
srtp_err_status_ok
;
}
static
const
char
srtp_aes_icm_128_description
[
]
=
"
AES
-
128
integer
counter
mode
"
;
static
const
char
srtp_aes_icm_256_description
[
]
=
"
AES
-
256
integer
counter
mode
"
;
static
const
uint8_t
srtp_aes_icm_128_test_case_0_key
[
SRTP_AES_ICM_128_KEY_LEN_WSALT
]
=
{
0x2b
0x7e
0x15
0x16
0x28
0xae
0xd2
0xa6
0xab
0xf7
0x15
0x88
0x09
0xcf
0x4f
0x3c
0xf0
0xf1
0xf2
0xf3
0xf4
0xf5
0xf6
0xf7
0xf8
0xf9
0xfa
0xfb
0xfc
0xfd
}
;
static
uint8_t
srtp_aes_icm_128_test_case_0_nonce
[
16
]
=
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
;
static
const
uint8_t
srtp_aes_icm_128_test_case_0_plaintext
[
32
]
=
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
;
static
const
uint8_t
srtp_aes_icm_128_test_case_0_ciphertext
[
32
]
=
{
0xe0
0x3e
0xad
0x09
0x35
0xc9
0x5e
0x80
0xe1
0x66
0xb1
0x6d
0xd9
0x2b
0x4e
0xb4
0xd2
0x35
0x13
0x16
0x2b
0x02
0xd0
0xf7
0x2a
0x43
0xa2
0xfe
0x4a
0x5f
0x97
0xab
}
;
static
const
srtp_cipher_test_case_t
srtp_aes_icm_128_test_case_0
=
{
SRTP_AES_ICM_128_KEY_LEN_WSALT
srtp_aes_icm_128_test_case_0_key
srtp_aes_icm_128_test_case_0_nonce
32
srtp_aes_icm_128_test_case_0_plaintext
32
srtp_aes_icm_128_test_case_0_ciphertext
0
NULL
0
NULL
}
;
static
const
uint8_t
srtp_aes_icm_256_test_case_0_key
[
SRTP_AES_ICM_256_KEY_LEN_WSALT
]
=
{
0x57
0xf8
0x2f
0xe3
0x61
0x3f
0xd1
0x70
0xa8
0x5e
0xc9
0x3c
0x40
0xb1
0xf0
0x92
0x2e
0xc4
0xcb
0x0d
0xc0
0x25
0xb5
0x82
0x72
0x14
0x7c
0xc4
0x38
0x94
0x4a
0x98
0xf0
0xf1
0xf2
0xf3
0xf4
0xf5
0xf6
0xf7
0xf8
0xf9
0xfa
0xfb
0xfc
0xfd
}
;
static
uint8_t
srtp_aes_icm_256_test_case_0_nonce
[
16
]
=
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
;
static
const
uint8_t
srtp_aes_icm_256_test_case_0_plaintext
[
32
]
=
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
;
static
const
uint8_t
srtp_aes_icm_256_test_case_0_ciphertext
[
32
]
=
{
0x92
0xbd
0xd2
0x8a
0x93
0xc3
0xf5
0x25
0x11
0xc6
0x77
0xd0
0x8b
0x55
0x15
0xa4
0x9d
0xa7
0x1b
0x23
0x78
0xa8
0x54
0xf6
0x70
0x50
0x75
0x6d
0xed
0x16
0x5b
0xac
}
;
static
const
srtp_cipher_test_case_t
srtp_aes_icm_256_test_case_0
=
{
SRTP_AES_ICM_256_KEY_LEN_WSALT
srtp_aes_icm_256_test_case_0_key
srtp_aes_icm_256_test_case_0_nonce
32
srtp_aes_icm_256_test_case_0_plaintext
32
srtp_aes_icm_256_test_case_0_ciphertext
0
NULL
0
NULL
}
;
const
srtp_cipher_type_t
srtp_aes_icm_128
=
{
srtp_aes_icm_alloc
srtp_aes_icm_dealloc
srtp_aes_icm_context_init
0
srtp_aes_icm_encrypt
srtp_aes_icm_encrypt
srtp_aes_icm_set_iv
0
srtp_aes_icm_128_description
&
srtp_aes_icm_128_test_case_0
SRTP_AES_ICM_128
}
;
const
srtp_cipher_type_t
srtp_aes_icm_256
=
{
srtp_aes_icm_alloc
srtp_aes_icm_dealloc
srtp_aes_icm_context_init
0
srtp_aes_icm_encrypt
srtp_aes_icm_encrypt
srtp_aes_icm_set_iv
0
srtp_aes_icm_256_description
&
srtp_aes_icm_256_test_case_0
SRTP_AES_ICM_256
}
;
