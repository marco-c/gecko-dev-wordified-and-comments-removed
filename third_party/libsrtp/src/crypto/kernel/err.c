#
ifdef
HAVE_CONFIG_H
#
include
<
config
.
h
>
#
endif
#
include
"
err
.
h
"
#
include
"
datatypes
.
h
"
#
include
<
string
.
h
>
static
FILE
*
srtp_err_file
=
NULL
;
srtp_err_status_t
srtp_err_reporting_init
(
)
{
#
ifdef
ERR_REPORTING_STDOUT
srtp_err_file
=
stdout
;
#
elif
defined
(
ERR_REPORTING_FILE
)
srtp_err_file
=
fopen
(
ERR_REPORTING_FILE
"
w
"
)
;
if
(
srtp_err_file
=
=
NULL
)
{
return
srtp_err_status_init_fail
;
}
#
endif
return
srtp_err_status_ok
;
}
static
srtp_err_report_handler_func_t
*
srtp_err_report_handler
=
NULL
;
srtp_err_status_t
srtp_install_err_report_handler
(
srtp_err_report_handler_func_t
func
)
{
srtp_err_report_handler
=
func
;
return
srtp_err_status_ok
;
}
void
srtp_err_report
(
srtp_err_reporting_level_t
level
const
char
*
format
.
.
.
)
{
char
msg
[
512
]
;
va_list
args
;
if
(
srtp_err_file
!
=
NULL
)
{
va_start
(
args
format
)
;
vfprintf
(
srtp_err_file
format
args
)
;
va_end
(
args
)
;
}
if
(
srtp_err_report_handler
!
=
NULL
)
{
va_start
(
args
format
)
;
if
(
vsnprintf
(
msg
sizeof
(
msg
)
format
args
)
>
0
)
{
size_t
l
=
strlen
(
msg
)
;
if
(
l
&
&
msg
[
l
-
1
]
=
=
'
\
n
'
)
{
msg
[
l
-
1
]
=
'
\
0
'
;
}
srtp_err_report_handler
(
level
msg
)
;
octet_string_set_to_zero
(
msg
sizeof
(
msg
)
)
;
}
va_end
(
args
)
;
}
}
