#
ifdef
HAVE_CONFIG_H
#
include
<
config
.
h
>
#
endif
#
include
"
hmac
.
h
"
#
include
"
alloc
.
h
"
#
include
"
cipher_types
.
h
"
#
include
"
auth_test_cases
.
h
"
srtp_debug_module_t
srtp_mod_hmac
=
{
0
"
hmac
sha
-
1
"
}
;
static
srtp_err_status_t
srtp_hmac_alloc
(
srtp_auth_t
*
*
a
int
key_len
int
out_len
)
{
extern
const
srtp_auth_type_t
srtp_hmac
;
uint8_t
*
pointer
;
debug_print
(
srtp_mod_hmac
"
allocating
auth
func
with
key
length
%
d
"
key_len
)
;
debug_print
(
srtp_mod_hmac
"
tag
length
%
d
"
out_len
)
;
if
(
key_len
>
20
)
{
return
srtp_err_status_bad_param
;
}
if
(
out_len
>
20
)
{
return
srtp_err_status_bad_param
;
}
pointer
=
(
uint8_t
*
)
srtp_crypto_alloc
(
sizeof
(
srtp_hmac_ctx_t
)
+
sizeof
(
srtp_auth_t
)
)
;
if
(
pointer
=
=
NULL
)
{
return
srtp_err_status_alloc_fail
;
}
*
a
=
(
srtp_auth_t
*
)
pointer
;
(
*
a
)
-
>
type
=
&
srtp_hmac
;
(
*
a
)
-
>
state
=
pointer
+
sizeof
(
srtp_auth_t
)
;
(
*
a
)
-
>
out_len
=
out_len
;
(
*
a
)
-
>
key_len
=
key_len
;
(
*
a
)
-
>
prefix_len
=
0
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_hmac_dealloc
(
srtp_auth_t
*
a
)
{
octet_string_set_to_zero
(
a
sizeof
(
srtp_hmac_ctx_t
)
+
sizeof
(
srtp_auth_t
)
)
;
srtp_crypto_free
(
a
)
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_hmac_init
(
void
*
statev
const
uint8_t
*
key
int
key_len
)
{
srtp_hmac_ctx_t
*
state
=
(
srtp_hmac_ctx_t
*
)
statev
;
int
i
;
uint8_t
ipad
[
64
]
;
if
(
key_len
>
20
)
{
return
srtp_err_status_bad_param
;
}
for
(
i
=
0
;
i
<
key_len
;
i
+
+
)
{
ipad
[
i
]
=
key
[
i
]
^
0x36
;
state
-
>
opad
[
i
]
=
key
[
i
]
^
0x5c
;
}
for
(
;
i
<
64
;
i
+
+
)
{
ipad
[
i
]
=
0x36
;
(
(
uint8_t
*
)
state
-
>
opad
)
[
i
]
=
0x5c
;
}
debug_print
(
srtp_mod_hmac
"
ipad
:
%
s
"
srtp_octet_string_hex_string
(
ipad
64
)
)
;
srtp_sha1_init
(
&
state
-
>
init_ctx
)
;
srtp_sha1_update
(
&
state
-
>
init_ctx
ipad
64
)
;
memcpy
(
&
state
-
>
ctx
&
state
-
>
init_ctx
sizeof
(
srtp_sha1_ctx_t
)
)
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_hmac_start
(
void
*
statev
)
{
srtp_hmac_ctx_t
*
state
=
(
srtp_hmac_ctx_t
*
)
statev
;
memcpy
(
&
state
-
>
ctx
&
state
-
>
init_ctx
sizeof
(
srtp_sha1_ctx_t
)
)
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_hmac_update
(
void
*
statev
const
uint8_t
*
message
int
msg_octets
)
{
srtp_hmac_ctx_t
*
state
=
(
srtp_hmac_ctx_t
*
)
statev
;
debug_print
(
srtp_mod_hmac
"
input
:
%
s
"
srtp_octet_string_hex_string
(
message
msg_octets
)
)
;
srtp_sha1_update
(
&
state
-
>
ctx
message
msg_octets
)
;
return
srtp_err_status_ok
;
}
static
srtp_err_status_t
srtp_hmac_compute
(
void
*
statev
const
uint8_t
*
message
int
msg_octets
int
tag_len
uint8_t
*
result
)
{
srtp_hmac_ctx_t
*
state
=
(
srtp_hmac_ctx_t
*
)
statev
;
uint32_t
hash_value
[
5
]
;
uint32_t
H
[
5
]
;
int
i
;
if
(
tag_len
>
20
)
{
return
srtp_err_status_bad_param
;
}
srtp_hmac_update
(
state
message
msg_octets
)
;
srtp_sha1_final
(
&
state
-
>
ctx
H
)
;
debug_print
(
srtp_mod_hmac
"
intermediate
state
:
%
s
"
srtp_octet_string_hex_string
(
(
uint8_t
*
)
H
20
)
)
;
srtp_sha1_init
(
&
state
-
>
ctx
)
;
srtp_sha1_update
(
&
state
-
>
ctx
(
uint8_t
*
)
state
-
>
opad
64
)
;
srtp_sha1_update
(
&
state
-
>
ctx
(
uint8_t
*
)
H
20
)
;
srtp_sha1_final
(
&
state
-
>
ctx
hash_value
)
;
for
(
i
=
0
;
i
<
tag_len
;
i
+
+
)
{
result
[
i
]
=
(
(
uint8_t
*
)
hash_value
)
[
i
]
;
}
debug_print
(
srtp_mod_hmac
"
output
:
%
s
"
srtp_octet_string_hex_string
(
(
uint8_t
*
)
hash_value
tag_len
)
)
;
return
srtp_err_status_ok
;
}
static
const
char
srtp_hmac_description
[
]
=
"
hmac
sha
-
1
authentication
function
"
;
const
srtp_auth_type_t
srtp_hmac
=
{
srtp_hmac_alloc
srtp_hmac_dealloc
srtp_hmac_init
srtp_hmac_compute
srtp_hmac_update
srtp_hmac_start
srtp_hmac_description
&
srtp_hmac_test_case_0
SRTP_HMAC_SHA1
}
;
