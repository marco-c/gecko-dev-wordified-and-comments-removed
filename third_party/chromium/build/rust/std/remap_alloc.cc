#
ifdef
UNSAFE_BUFFERS_BUILD
#
pragma
allow_unsafe_libc_calls
#
endif
#
include
<
cstddef
>
#
include
<
cstring
>
#
include
"
build
/
build_config
.
h
"
#
include
"
build
/
rust
/
std
/
alias
.
h
"
#
include
"
build
/
rust
/
std
/
buildflags
.
h
"
#
include
"
build
/
rust
/
std
/
immediate_crash
.
h
"
#
if
BUILDFLAG
(
RUST_ALLOCATOR_USES_PARTITION_ALLOC
)
#
include
"
partition_alloc
/
partition_alloc_constants
.
h
"
#
include
"
partition_alloc
/
shim
/
allocator_shim
.
h
"
#
elif
BUILDFLAG
(
IS_WIN
)
#
include
<
cstdlib
>
#
endif
extern
"
C
"
{
#
ifdef
COMPONENT_BUILD
#
if
BUILDFLAG
(
IS_WIN
)
#
define
REMAP_ALLOC_ATTRIBUTES
__declspec
(
dllexport
)
__attribute__
(
(
weak
)
)
#
else
#
define
REMAP_ALLOC_ATTRIBUTES
\
__attribute__
(
(
visibility
(
"
default
"
)
)
)
__attribute__
(
(
weak
)
)
#
endif
#
else
#
define
REMAP_ALLOC_ATTRIBUTES
__attribute__
(
(
weak
)
)
#
endif
#
if
!
BUILDFLAG
(
RUST_ALLOCATOR_USES_PARTITION_ALLOC
)
&
&
BUILDFLAG
(
IS_WIN
)
&
&
\
defined
(
ADDRESS_SANITIZER
)
#
define
USE_WIN_ALIGNED_MALLOC
1
#
else
#
define
USE_WIN_ALIGNED_MALLOC
0
#
endif
[
[
maybe_unused
]
]
__attribute__
(
(
weak
)
)
unsigned
char
__rust_no_alloc_shim_is_unstable
;
REMAP_ALLOC_ATTRIBUTES
void
*
__rust_alloc
(
size_t
size
size_t
align
)
{
#
if
BUILDFLAG
(
RUST_ALLOCATOR_USES_PARTITION_ALLOC
)
if
(
align
>
partition_alloc
:
:
internal
:
:
kMaxSupportedAlignment
)
{
return
nullptr
;
}
if
(
align
<
=
alignof
(
std
:
:
max_align_t
)
)
{
return
allocator_shim
:
:
UncheckedAlloc
(
size
)
;
}
else
{
return
allocator_shim
:
:
UncheckedAlignedAlloc
(
size
align
)
;
}
#
elif
USE_WIN_ALIGNED_MALLOC
return
_aligned_malloc
(
size
align
)
;
#
else
extern
void
*
__rdl_alloc
(
size_t
size
size_t
align
)
;
return
__rdl_alloc
(
size
align
)
;
#
endif
}
REMAP_ALLOC_ATTRIBUTES
void
__rust_dealloc
(
void
*
p
size_t
size
size_t
align
)
{
#
if
BUILDFLAG
(
RUST_ALLOCATOR_USES_PARTITION_ALLOC
)
if
(
align
<
=
alignof
(
std
:
:
max_align_t
)
)
{
allocator_shim
:
:
UncheckedFree
(
p
)
;
}
else
{
allocator_shim
:
:
UncheckedAlignedFree
(
p
)
;
}
#
elif
USE_WIN_ALIGNED_MALLOC
return
_aligned_free
(
p
)
;
#
else
extern
void
__rdl_dealloc
(
void
*
p
size_t
size
size_t
align
)
;
__rdl_dealloc
(
p
size
align
)
;
#
endif
}
REMAP_ALLOC_ATTRIBUTES
void
*
__rust_realloc
(
void
*
p
size_t
old_size
size_t
align
size_t
new_size
)
{
#
if
BUILDFLAG
(
RUST_ALLOCATOR_USES_PARTITION_ALLOC
)
if
(
align
<
=
alignof
(
std
:
:
max_align_t
)
)
{
return
allocator_shim
:
:
UncheckedRealloc
(
p
new_size
)
;
}
else
{
return
allocator_shim
:
:
UncheckedAlignedRealloc
(
p
new_size
align
)
;
}
#
elif
USE_WIN_ALIGNED_MALLOC
return
_aligned_realloc
(
p
new_size
align
)
;
#
else
extern
void
*
__rdl_realloc
(
void
*
p
size_t
old_size
size_t
align
size_t
new_size
)
;
return
__rdl_realloc
(
p
old_size
align
new_size
)
;
#
endif
}
REMAP_ALLOC_ATTRIBUTES
void
*
__rust_alloc_zeroed
(
size_t
size
size_t
align
)
{
#
if
BUILDFLAG
(
RUST_ALLOCATOR_USES_PARTITION_ALLOC
)
|
|
USE_WIN_ALIGNED_MALLOC
void
*
p
=
__rust_alloc
(
size
align
)
;
if
(
p
)
{
memset
(
p
0
size
)
;
}
return
p
;
#
else
extern
void
*
__rdl_alloc_zeroed
(
size_t
size
size_t
align
)
;
return
__rdl_alloc_zeroed
(
size
align
)
;
#
endif
}
REMAP_ALLOC_ATTRIBUTES
void
__rust_alloc_error_handler
(
size_t
size
size_t
align
)
{
NO_CODE_FOLDING
(
)
;
IMMEDIATE_CRASH
(
)
;
}
REMAP_ALLOC_ATTRIBUTES
extern
const
unsigned
char
__rust_alloc_error_handler_should_panic
=
0
;
}
