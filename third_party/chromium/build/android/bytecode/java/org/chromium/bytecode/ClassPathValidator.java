package
org
.
chromium
.
bytecode
;
import
org
.
objectweb
.
asm
.
ClassReader
;
import
java
.
io
.
PrintStream
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
import
java
.
util
.
TreeMap
;
import
java
.
util
.
TreeSet
;
import
java
.
util
.
function
.
Consumer
;
public
class
ClassPathValidator
{
private
static
final
int
MAX_MISSING_CLASS_WARNINGS
=
10
;
private
static
final
int
MAX_ERRORS_PER_JAR
=
2
;
private
final
Map
<
String
Map
<
String
Set
<
String
>
>
>
mDirectErrors
=
Collections
.
synchronizedMap
(
new
TreeMap
<
>
(
)
)
;
private
final
Map
<
String
String
>
mMissingClasses
=
Collections
.
synchronizedMap
(
new
TreeMap
<
>
(
)
)
;
static
class
ClassNotLoadedException
extends
ClassNotFoundException
{
private
final
String
mClassName
;
ClassNotLoadedException
(
String
className
Throwable
ex
)
{
super
(
"
Couldn
'
t
load
"
+
className
ex
)
;
mClassName
=
className
;
}
public
String
getClassName
(
)
{
return
mClassName
;
}
}
private
static
void
validateClass
(
ClassLoader
classLoader
String
className
)
throws
ClassNotLoadedException
{
if
(
className
.
startsWith
(
"
[
"
)
)
{
className
=
className
.
substring
(
className
.
lastIndexOf
(
'
[
'
)
+
1
)
;
if
(
className
.
charAt
(
0
)
=
=
'
L
'
&
&
className
.
endsWith
(
"
;
"
)
)
{
className
=
className
.
substring
(
1
className
.
length
(
)
-
1
)
;
}
else
{
return
;
}
}
if
(
className
.
matches
(
"
.
*
\
\
bR
(
\
\
\
\
w
+
)
?
"
)
)
{
return
;
}
if
(
className
.
matches
(
"
^
libcore
\
\
b
.
*
"
)
)
{
return
;
}
if
(
className
.
matches
(
"
^
android
\
\
b
.
*
"
)
)
{
return
;
}
try
{
classLoader
.
loadClass
(
className
.
replace
(
'
/
'
'
.
'
)
)
;
}
catch
(
ClassNotFoundException
e
)
{
throw
new
ClassNotLoadedException
(
className
e
)
;
}
catch
(
NoClassDefFoundError
e
)
{
}
}
private
static
void
validateClassPath
(
ClassReader
classReader
ClassLoader
classLoader
Consumer
<
ClassNotLoadedException
>
errorConsumer
)
{
char
[
]
charBuffer
=
new
char
[
classReader
.
getMaxStringLength
(
)
]
;
for
(
int
i
=
1
;
i
<
classReader
.
getItemCount
(
)
;
i
+
+
)
{
int
offset
=
classReader
.
getItem
(
i
)
;
if
(
offset
>
0
&
&
classReader
.
readByte
(
offset
-
1
)
=
=
7
)
{
try
{
validateClass
(
classLoader
classReader
.
readUTF8
(
offset
charBuffer
)
)
;
}
catch
(
ClassNotLoadedException
e
)
{
errorConsumer
.
accept
(
e
)
;
}
}
}
}
public
void
validateFullClassPath
(
ClassReader
classReader
ClassLoader
fullClassLoader
Set
<
String
>
missingClassAllowlist
)
{
validateClassPath
(
classReader
fullClassLoader
(
e
)
-
>
{
if
(
!
missingClassAllowlist
.
contains
(
e
.
getClassName
(
)
)
)
{
addMissingError
(
classReader
.
getClassName
(
)
e
.
getClassName
(
)
)
;
}
}
)
;
}
public
void
validateDirectClassPath
(
ClassReader
classReader
ClassLoader
directClassLoader
ClassLoader
fullClassLoader
Collection
<
String
>
jarsOnlyInFullClassPath
Set
<
String
>
missingClassAllowlist
boolean
verbose
)
{
validateClassPath
(
classReader
directClassLoader
(
e
)
-
>
{
try
{
validateClass
(
fullClassLoader
e
.
getClassName
(
)
)
;
}
catch
(
ClassNotLoadedException
d
)
{
if
(
!
missingClassAllowlist
.
contains
(
e
.
getClassName
(
)
)
)
{
addMissingError
(
classReader
.
getClassName
(
)
e
.
getClassName
(
)
)
;
}
return
;
}
if
(
verbose
)
{
System
.
err
.
println
(
"
Class
\
"
"
+
e
.
getClassName
(
)
+
"
\
"
not
found
in
direct
dependencies
"
+
"
but
found
in
indirect
dependiences
.
"
)
;
}
for
(
String
jarPath
:
jarsOnlyInFullClassPath
)
{
try
{
ClassLoader
smallLoader
=
ByteCodeProcessor
.
loadJars
(
Collections
.
singletonList
(
jarPath
)
)
;
validateClass
(
smallLoader
e
.
getClassName
(
)
)
;
addDirectError
(
jarPath
classReader
.
getClassName
(
)
e
.
getClassName
(
)
)
;
break
;
}
catch
(
ClassNotLoadedException
f
)
{
}
}
}
)
;
}
private
void
addMissingError
(
String
srcClass
String
missingClass
)
{
mMissingClasses
.
put
(
missingClass
srcClass
)
;
}
private
void
addDirectError
(
String
jarPath
String
srcClass
String
missingClass
)
{
synchronized
(
mDirectErrors
)
{
Map
<
String
Set
<
String
>
>
failedClassesByMissingClass
=
mDirectErrors
.
get
(
jarPath
)
;
if
(
failedClassesByMissingClass
=
=
null
)
{
failedClassesByMissingClass
=
new
TreeMap
<
>
(
)
;
mDirectErrors
.
put
(
jarPath
failedClassesByMissingClass
)
;
}
Set
<
String
>
failedClasses
=
failedClassesByMissingClass
.
get
(
missingClass
)
;
if
(
failedClasses
=
=
null
)
{
failedClasses
=
new
TreeSet
<
>
(
)
;
failedClassesByMissingClass
.
put
(
missingClass
failedClasses
)
;
}
failedClasses
.
add
(
srcClass
)
;
}
}
public
boolean
hasErrors
(
)
{
return
!
mDirectErrors
.
isEmpty
(
)
|
|
!
mMissingClasses
.
isEmpty
(
)
;
}
private
static
void
printValidationError
(
PrintStream
out
String
gnTarget
Map
<
String
Set
<
String
>
>
missingClasses
)
{
out
.
print
(
"
*
"
)
;
out
.
println
(
gnTarget
)
;
int
i
=
0
;
for
(
Map
.
Entry
<
String
Set
<
String
>
>
entry
:
missingClasses
.
entrySet
(
)
)
{
String
missingClass
=
entry
.
getKey
(
)
;
Set
<
String
>
filesThatNeededIt
=
entry
.
getValue
(
)
;
out
.
print
(
"
*
"
)
;
if
(
i
=
=
MAX_ERRORS_PER_JAR
)
{
out
.
print
(
String
.
format
(
"
And
%
d
more
.
.
.
"
missingClasses
.
size
(
)
-
MAX_ERRORS_PER_JAR
)
)
;
break
;
}
out
.
print
(
missingClass
.
replace
(
'
/
'
'
.
'
)
)
;
out
.
print
(
"
(
needed
by
"
)
;
out
.
print
(
filesThatNeededIt
.
iterator
(
)
.
next
(
)
.
replace
(
'
/
'
'
.
'
)
)
;
if
(
filesThatNeededIt
.
size
(
)
>
1
)
{
out
.
print
(
String
.
format
(
"
and
%
d
more
"
filesThatNeededIt
.
size
(
)
-
1
)
)
;
}
out
.
println
(
"
)
"
)
;
i
+
+
;
}
}
public
void
printAll
(
String
gnTarget
Map
<
String
String
>
jarToGnTarget
)
{
String
streamer
=
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
"
;
System
.
err
.
println
(
)
;
System
.
err
.
println
(
streamer
+
"
Dependency
Checks
Failed
"
+
streamer
)
;
System
.
err
.
println
(
"
Target
:
"
+
gnTarget
)
;
if
(
!
mMissingClasses
.
isEmpty
(
)
)
{
int
i
=
0
;
for
(
Map
.
Entry
<
String
String
>
entry
:
mMissingClasses
.
entrySet
(
)
)
{
if
(
+
+
i
>
MAX_MISSING_CLASS_WARNINGS
)
{
System
.
err
.
println
(
String
.
format
(
"
.
.
.
and
%
d
more
.
"
mMissingClasses
.
size
(
)
-
MAX_MISSING_CLASS_WARNINGS
)
)
;
break
;
}
System
.
err
.
println
(
String
.
format
(
"
Class
\
"
%
s
\
"
not
found
on
any
classpath
.
Used
by
class
\
"
%
s
\
"
"
entry
.
getKey
(
)
entry
.
getValue
(
)
)
)
;
}
System
.
err
.
println
(
)
;
}
if
(
!
mDirectErrors
.
isEmpty
(
)
)
{
System
.
err
.
println
(
"
Direct
classpath
is
incomplete
.
To
fix
add
deps
on
:
"
)
;
for
(
Map
.
Entry
<
String
Map
<
String
Set
<
String
>
>
>
entry
:
mDirectErrors
.
entrySet
(
)
)
{
printValidationError
(
System
.
err
jarToGnTarget
.
get
(
entry
.
getKey
(
)
)
entry
.
getValue
(
)
)
;
}
System
.
err
.
println
(
)
;
}
}
}
