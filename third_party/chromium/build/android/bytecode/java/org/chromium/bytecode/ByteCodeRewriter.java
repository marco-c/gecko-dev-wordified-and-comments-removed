package
org
.
chromium
.
bytecode
;
import
org
.
objectweb
.
asm
.
ClassReader
;
import
org
.
objectweb
.
asm
.
ClassVisitor
;
import
org
.
objectweb
.
asm
.
ClassWriter
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
ByteArrayInputStream
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
OutputStream
;
import
java
.
util
.
zip
.
ZipEntry
;
import
java
.
util
.
zip
.
ZipInputStream
;
import
java
.
util
.
zip
.
ZipOutputStream
;
public
abstract
class
ByteCodeRewriter
{
private
static
final
String
CLASS_FILE_SUFFIX
=
"
.
class
"
;
public
void
rewrite
(
File
inputJar
File
outputJar
)
throws
IOException
{
if
(
!
inputJar
.
exists
(
)
)
{
throw
new
FileNotFoundException
(
"
Input
jar
not
found
:
"
+
inputJar
.
getPath
(
)
)
;
}
try
(
InputStream
inputStream
=
new
BufferedInputStream
(
new
FileInputStream
(
inputJar
)
)
;
OutputStream
outputStream
=
new
FileOutputStream
(
outputJar
)
)
{
processZip
(
inputStream
outputStream
)
;
}
}
protected
abstract
boolean
shouldRewriteClass
(
String
classPath
)
;
protected
boolean
shouldRewriteClass
(
ClassReader
classReader
)
{
return
true
;
}
protected
abstract
ClassVisitor
getClassVisitorForClass
(
String
classPath
ClassVisitor
delegate
)
;
private
void
processZip
(
InputStream
inputStream
OutputStream
outputStream
)
{
try
(
ZipOutputStream
zipOutputStream
=
new
ZipOutputStream
(
outputStream
)
;
ZipInputStream
zipInputStream
=
new
ZipInputStream
(
inputStream
)
)
{
ZipEntry
entry
;
while
(
(
entry
=
zipInputStream
.
getNextEntry
(
)
)
!
=
null
)
{
byte
[
]
currentEntryBytes
=
zipInputStream
.
readAllBytes
(
)
;
ByteArrayInputStream
currentEntryInputStream
=
new
ByteArrayInputStream
(
currentEntryBytes
)
;
ByteArrayOutputStream
outputBuffer
=
new
ByteArrayOutputStream
(
)
;
boolean
handled
=
processClassEntry
(
entry
currentEntryInputStream
outputBuffer
)
;
if
(
handled
)
{
ZipEntry
newEntry
=
new
ZipEntry
(
entry
.
getName
(
)
)
;
zipOutputStream
.
putNextEntry
(
newEntry
)
;
zipOutputStream
.
write
(
outputBuffer
.
toByteArray
(
)
0
outputBuffer
.
size
(
)
)
;
zipOutputStream
.
closeEntry
(
)
;
}
else
{
ZipEntry
newEntry
=
new
ZipEntry
(
entry
.
getName
(
)
)
;
zipOutputStream
.
putNextEntry
(
newEntry
)
;
currentEntryInputStream
.
reset
(
)
;
currentEntryInputStream
.
transferTo
(
zipOutputStream
)
;
zipOutputStream
.
closeEntry
(
)
;
}
}
zipOutputStream
.
finish
(
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
private
boolean
processClassEntry
(
ZipEntry
entry
InputStream
inputStream
OutputStream
outputStream
)
{
if
(
!
entry
.
getName
(
)
.
endsWith
(
CLASS_FILE_SUFFIX
)
|
|
!
shouldRewriteClass
(
entry
.
getName
(
)
)
)
{
return
false
;
}
try
{
ClassReader
reader
=
new
ClassReader
(
inputStream
)
;
if
(
!
shouldRewriteClass
(
reader
)
)
{
return
false
;
}
ClassWriter
writer
=
new
ClassWriter
(
reader
ClassWriter
.
COMPUTE_FRAMES
)
;
ClassVisitor
classVisitor
=
getClassVisitorForClass
(
entry
.
getName
(
)
writer
)
;
reader
.
accept
(
classVisitor
ClassReader
.
EXPAND_FRAMES
)
;
writer
.
visitEnd
(
)
;
byte
[
]
classData
=
writer
.
toByteArray
(
)
;
outputStream
.
write
(
classData
0
classData
.
length
)
;
return
true
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
}
