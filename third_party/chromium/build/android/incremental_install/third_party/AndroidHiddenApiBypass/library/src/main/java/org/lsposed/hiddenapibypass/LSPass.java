package
org
.
lsposed
.
hiddenapibypass
;
import
android
.
os
.
Build
;
import
android
.
util
.
Log
;
import
android
.
util
.
Property
;
import
androidx
.
annotation
.
NonNull
;
import
androidx
.
annotation
.
Nullable
;
import
androidx
.
annotation
.
RequiresApi
;
import
java
.
lang
.
reflect
.
Constructor
;
import
java
.
lang
.
reflect
.
Field
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
lang
.
reflect
.
Modifier
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
List
;
import
stub
.
dalvik
.
system
.
VMRuntime
;
SuppressWarnings
(
"
rawtypes
"
)
RequiresApi
(
Build
.
VERSION_CODES
.
P
)
public
final
class
LSPass
{
private
static
final
String
TAG
=
"
LSPass
"
;
private
static
final
Property
<
Class
Method
[
]
>
methods
;
private
static
final
Property
<
Class
Constructor
[
]
>
constructors
;
private
static
final
Property
<
Class
Field
[
]
>
fields
;
static
{
methods
=
Property
.
of
(
Class
.
class
Method
[
]
.
class
"
DeclaredMethods
"
)
;
constructors
=
Property
.
of
(
Class
.
class
Constructor
[
]
.
class
"
DeclaredConstructors
"
)
;
fields
=
Property
.
of
(
Class
.
class
Field
[
]
.
class
"
DeclaredFields
"
)
;
}
public
static
List
<
Method
>
getDeclaredMethods
(
NonNull
Class
<
?
>
clazz
)
{
return
Arrays
.
asList
(
methods
.
get
(
clazz
)
)
;
}
public
static
List
<
Constructor
<
?
>
>
getDeclaredConstructors
(
NonNull
Class
<
?
>
clazz
)
{
return
Arrays
.
<
Constructor
<
?
>
>
asList
(
constructors
.
get
(
clazz
)
)
;
}
public
static
List
<
Field
>
getDeclaredFields
(
NonNull
Class
<
?
>
clazz
)
{
return
Arrays
.
asList
(
fields
.
get
(
clazz
)
)
;
}
NonNull
public
static
List
<
Field
>
getInstanceFields
(
NonNull
Class
<
?
>
clazz
)
{
var
list
=
new
ArrayList
<
Field
>
(
)
;
for
(
var
member
:
getDeclaredFields
(
clazz
)
)
{
if
(
!
Modifier
.
isStatic
(
member
.
getModifiers
(
)
)
)
list
.
add
(
member
)
;
}
return
list
;
}
NonNull
public
static
List
<
Field
>
getStaticFields
(
NonNull
Class
<
?
>
clazz
)
{
var
list
=
new
ArrayList
<
Field
>
(
)
;
for
(
var
member
:
getDeclaredFields
(
clazz
)
)
{
if
(
Modifier
.
isStatic
(
member
.
getModifiers
(
)
)
)
list
.
add
(
member
)
;
}
return
list
;
}
NonNull
public
static
Method
getDeclaredMethod
(
NonNull
Class
<
?
>
clazz
NonNull
String
methodName
NonNull
Class
<
?
>
.
.
.
parameterTypes
)
throws
NoSuchMethodException
{
var
methods
=
getDeclaredMethods
(
clazz
)
;
all
:
for
(
var
method
:
methods
)
{
if
(
!
method
.
getName
(
)
.
equals
(
methodName
)
)
continue
;
var
expectedTypes
=
method
.
getParameterTypes
(
)
;
if
(
expectedTypes
.
length
!
=
parameterTypes
.
length
)
continue
;
for
(
int
i
=
0
;
i
<
parameterTypes
.
length
;
+
+
i
)
{
if
(
parameterTypes
[
i
]
!
=
expectedTypes
[
i
]
)
continue
all
;
}
return
method
;
}
throw
new
NoSuchMethodException
(
"
Cannot
find
matching
method
"
)
;
}
NonNull
public
static
Constructor
<
?
>
getDeclaredConstructor
(
NonNull
Class
<
?
>
clazz
NonNull
Class
<
?
>
.
.
.
parameterTypes
)
throws
NoSuchMethodException
{
var
constructors
=
getDeclaredConstructors
(
clazz
)
;
all
:
for
(
var
constructor
:
constructors
)
{
var
expectedTypes
=
constructor
.
getParameterTypes
(
)
;
if
(
expectedTypes
.
length
!
=
parameterTypes
.
length
)
continue
;
for
(
int
i
=
0
;
i
<
parameterTypes
.
length
;
+
+
i
)
{
if
(
parameterTypes
[
i
]
!
=
expectedTypes
[
i
]
)
continue
all
;
}
return
constructor
;
}
throw
new
NoSuchMethodException
(
"
Cannot
find
matching
constructor
"
)
;
}
public
static
Object
newInstance
(
NonNull
Class
<
?
>
clazz
Object
.
.
.
initargs
)
throws
NoSuchMethodException
IllegalAccessException
InvocationTargetException
InstantiationException
{
var
constructors
=
getDeclaredConstructors
(
clazz
)
;
for
(
var
constructor
:
constructors
)
{
var
params
=
constructor
.
getParameterTypes
(
)
;
if
(
!
Helper
.
checkArgsForInvokeMethod
(
params
initargs
)
)
continue
;
constructor
.
setAccessible
(
true
)
;
return
constructor
.
newInstance
(
initargs
)
;
}
throw
new
NoSuchMethodException
(
"
Cannot
find
matching
constructor
"
)
;
}
public
static
Object
invoke
(
NonNull
Class
<
?
>
clazz
Nullable
Object
thiz
NonNull
String
methodName
Object
.
.
.
args
)
throws
NoSuchMethodException
InvocationTargetException
IllegalAccessException
{
var
methods
=
getDeclaredMethods
(
clazz
)
;
for
(
var
method
:
methods
)
{
if
(
!
method
.
getName
(
)
.
equals
(
methodName
)
)
continue
;
var
params
=
method
.
getParameterTypes
(
)
;
if
(
!
Helper
.
checkArgsForInvokeMethod
(
params
args
)
)
continue
;
method
.
setAccessible
(
true
)
;
return
method
.
invoke
(
thiz
args
)
;
}
throw
new
NoSuchMethodException
(
"
Cannot
find
matching
method
"
)
;
}
public
static
boolean
setHiddenApiExemptions
(
NonNull
String
.
.
.
signaturePrefixes
)
{
try
{
var
runtime
=
invoke
(
VMRuntime
.
class
null
"
getRuntime
"
)
;
invoke
(
VMRuntime
.
class
runtime
"
setHiddenApiExemptions
"
(
Object
)
signaturePrefixes
)
;
return
true
;
}
catch
(
ReflectiveOperationException
e
)
{
Log
.
w
(
TAG
"
setHiddenApiExemptions
"
e
)
;
return
false
;
}
}
public
static
boolean
addHiddenApiExemptions
(
String
.
.
.
signaturePrefixes
)
{
Helper
.
signaturePrefixes
.
addAll
(
Arrays
.
asList
(
signaturePrefixes
)
)
;
var
strings
=
new
String
[
Helper
.
signaturePrefixes
.
size
(
)
]
;
Helper
.
signaturePrefixes
.
toArray
(
strings
)
;
return
setHiddenApiExemptions
(
strings
)
;
}
public
static
boolean
clearHiddenApiExemptions
(
)
{
Helper
.
signaturePrefixes
.
clear
(
)
;
return
setHiddenApiExemptions
(
)
;
}
}
