package
org
.
chromium
.
incrementalinstall
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
content
.
Context
;
import
android
.
os
.
Build
;
import
android
.
os
.
Process
;
import
android
.
util
.
Log
;
import
dalvik
.
system
.
DexFile
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
final
class
ClassLoaderPatcher
{
private
static
final
String
TAG
=
"
incrementalinstall
"
;
private
final
File
mAppFilesSubDir
;
private
final
ClassLoader
mClassLoader
;
private
final
Object
mLibcoreOs
;
private
final
int
mProcessUid
;
final
boolean
mIsPrimaryProcess
;
ClassLoaderPatcher
(
Context
context
)
throws
ReflectiveOperationException
{
mAppFilesSubDir
=
new
File
(
context
.
getApplicationInfo
(
)
.
dataDir
"
incremental
-
install
-
files
"
)
;
mClassLoader
=
context
.
getClassLoader
(
)
;
mLibcoreOs
=
Reflect
.
getField
(
Class
.
forName
(
"
libcore
.
io
.
Libcore
"
)
"
os
"
)
;
mProcessUid
=
Process
.
myUid
(
)
;
mIsPrimaryProcess
=
context
.
getApplicationInfo
(
)
.
uid
=
=
mProcessUid
;
Log
.
i
(
TAG
"
uid
=
"
+
mProcessUid
+
"
(
isPrimary
=
"
+
mIsPrimaryProcess
+
"
)
"
)
;
}
SuppressLint
(
{
"
SetWorldReadable
"
"
SetWorldWritable
"
}
)
DexFile
[
]
loadDexFiles
(
File
dexDir
String
packageName
)
throws
ReflectiveOperationException
IOException
{
Log
.
i
(
TAG
"
Installing
dex
files
from
:
"
+
dexDir
)
;
File
optimizedDir
=
null
;
boolean
isAtLeastOreo
=
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
O
;
if
(
isAtLeastOreo
)
{
File
newDexDir
=
new
File
(
mAppFilesSubDir
packageName
+
"
-
dexes
"
)
;
if
(
mIsPrimaryProcess
)
{
safeCopyAllFiles
(
dexDir
newDexDir
)
;
}
dexDir
=
newDexDir
;
}
else
{
File
incrementalDexesDir
=
new
File
(
mAppFilesSubDir
"
optimized
-
dexes
"
)
;
File
isolatedDexesDir
=
new
File
(
mAppFilesSubDir
"
isolated
-
dexes
"
)
;
if
(
mIsPrimaryProcess
)
{
ensureAppFilesSubDirExists
(
)
;
incrementalDexesDir
.
mkdir
(
)
;
incrementalDexesDir
.
setReadable
(
true
false
)
;
incrementalDexesDir
.
setExecutable
(
true
false
)
;
isolatedDexesDir
.
mkdir
(
)
;
isolatedDexesDir
.
setWritable
(
true
false
)
;
isolatedDexesDir
.
setExecutable
(
true
false
)
;
optimizedDir
=
incrementalDexesDir
;
}
else
{
optimizedDir
=
new
File
(
isolatedDexesDir
"
isolated
-
"
+
mProcessUid
)
;
optimizedDir
.
mkdir
(
)
;
Log
.
i
(
TAG
"
Creating
dex
file
symlinks
for
isolated
process
"
)
;
for
(
File
f
:
optimizedDir
.
listFiles
(
)
)
{
f
.
delete
(
)
;
}
for
(
File
f
:
incrementalDexesDir
.
listFiles
(
)
)
{
String
to
=
"
.
.
/
.
.
/
"
+
incrementalDexesDir
.
getName
(
)
+
"
/
"
+
f
.
getName
(
)
;
File
from
=
new
File
(
optimizedDir
f
.
getName
(
)
)
;
createSymlink
(
to
from
)
;
}
}
Log
.
i
(
TAG
"
Code
cache
dir
:
"
+
optimizedDir
)
;
}
File
[
]
dexFilesArr
=
dexDir
.
listFiles
(
f
-
>
f
.
getName
(
)
.
endsWith
(
"
.
jar
"
)
)
;
if
(
dexFilesArr
=
=
null
)
{
throw
new
FileNotFoundException
(
"
Dex
dir
does
not
exist
:
"
+
dexDir
)
;
}
Log
.
i
(
TAG
"
Loading
"
+
dexFilesArr
.
length
+
"
dex
files
"
)
;
Object
dexPathList
=
Reflect
.
getField
(
mClassLoader
"
pathList
"
)
;
Object
[
]
dexElements
=
(
Object
[
]
)
Reflect
.
getField
(
dexPathList
"
dexElements
"
)
;
dexElements
=
addDexElements
(
dexFilesArr
optimizedDir
dexElements
)
;
Reflect
.
setField
(
dexPathList
"
dexElements
"
dexElements
)
;
DexFile
[
]
ret
=
new
DexFile
[
dexFilesArr
.
length
]
;
int
startIndex
=
dexElements
.
length
-
dexFilesArr
.
length
;
for
(
int
i
=
0
;
i
<
ret
.
length
;
+
+
i
)
{
ret
[
i
]
=
(
DexFile
)
Reflect
.
getField
(
dexElements
[
startIndex
+
i
]
"
dexFile
"
)
;
}
return
ret
;
}
SuppressLint
(
"
SetWorldReadable
"
)
void
importNativeLibs
(
File
libDir
)
throws
ReflectiveOperationException
IOException
{
Log
.
i
(
TAG
"
Importing
native
libraries
from
:
"
+
libDir
)
;
if
(
!
libDir
.
exists
(
)
)
{
Log
.
i
(
TAG
"
No
native
libs
exist
.
"
)
;
return
;
}
File
localLibsDir
=
new
File
(
mAppFilesSubDir
"
lib
"
)
;
safeCopyAllFiles
(
libDir
localLibsDir
)
;
addNativeLibrarySearchPath
(
localLibsDir
)
;
}
SuppressLint
(
"
SetWorldReadable
"
)
private
void
safeCopyAllFiles
(
File
srcDir
File
dstDir
)
throws
IOException
{
if
(
!
mIsPrimaryProcess
)
{
throw
new
RuntimeException
(
"
Incremental
install
does
not
work
on
Android
M
+
"
+
"
with
isolated
processes
.
Build
system
should
have
removed
this
.
"
+
"
Please
file
a
bug
.
"
)
;
}
ensureAppFilesSubDirExists
(
)
;
File
lockFile
=
new
File
(
mAppFilesSubDir
dstDir
.
getName
(
)
+
"
.
lock
"
)
;
LockFile
lock
=
LockFile
.
acquireRuntimeLock
(
lockFile
)
;
if
(
lock
=
=
null
)
{
LockFile
.
waitForRuntimeLock
(
lockFile
10
*
1000
)
;
}
else
{
try
{
dstDir
.
mkdir
(
)
;
dstDir
.
setReadable
(
true
false
)
;
dstDir
.
setExecutable
(
true
false
)
;
copyChangedFiles
(
srcDir
dstDir
)
;
}
finally
{
lock
.
release
(
)
;
}
}
}
SuppressWarnings
(
"
unchecked
"
)
private
void
addNativeLibrarySearchPath
(
File
nativeLibDir
)
throws
ReflectiveOperationException
{
Object
dexPathList
=
Reflect
.
getField
(
mClassLoader
"
pathList
"
)
;
Object
currentDirs
=
Reflect
.
getField
(
dexPathList
"
nativeLibraryDirectories
"
)
;
File
[
]
newDirs
=
new
File
[
]
{
nativeLibDir
}
;
if
(
currentDirs
instanceof
List
)
{
List
<
File
>
dirsAsList
=
(
List
<
File
>
)
currentDirs
;
dirsAsList
.
add
(
0
nativeLibDir
)
;
}
else
{
File
[
]
dirsAsArray
=
(
File
[
]
)
currentDirs
;
Reflect
.
setField
(
dexPathList
"
nativeLibraryDirectories
"
Reflect
.
concatArrays
(
newDirs
newDirs
dirsAsArray
)
)
;
}
Object
[
]
nativeLibraryPathElements
;
try
{
nativeLibraryPathElements
=
(
Object
[
]
)
Reflect
.
getField
(
dexPathList
"
nativeLibraryPathElements
"
)
;
}
catch
(
NoSuchFieldException
e
)
{
return
;
}
Object
[
]
additionalElements
=
makeNativePathElements
(
newDirs
)
;
Reflect
.
setField
(
dexPathList
"
nativeLibraryPathElements
"
Reflect
.
concatArrays
(
nativeLibraryPathElements
additionalElements
nativeLibraryPathElements
)
)
;
}
private
static
void
copyChangedFiles
(
File
srcDir
File
dstDir
)
throws
IOException
{
int
numUpdated
=
0
;
File
[
]
srcFiles
=
srcDir
.
listFiles
(
)
;
for
(
File
f
:
srcFiles
)
{
File
dest
=
new
File
(
dstDir
f
.
getName
(
)
)
;
if
(
copyIfModified
(
f
dest
)
)
{
numUpdated
+
+
;
}
}
int
numDeleted
=
0
;
for
(
File
f
:
dstDir
.
listFiles
(
)
)
{
File
src
=
new
File
(
srcDir
f
.
getName
(
)
)
;
if
(
!
src
.
exists
(
)
)
{
numDeleted
+
+
;
f
.
delete
(
)
;
}
}
String
msg
=
String
.
format
(
Locale
.
US
"
copyChangedFiles
:
%
d
of
%
d
updated
.
%
d
stale
files
removed
.
"
numUpdated
srcFiles
.
length
numDeleted
)
;
Log
.
i
(
TAG
msg
)
;
}
SuppressLint
(
"
SetWorldReadable
"
)
private
static
boolean
copyIfModified
(
File
src
File
dest
)
throws
IOException
{
long
lastModified
=
src
.
lastModified
(
)
;
if
(
dest
.
exists
(
)
&
&
dest
.
lastModified
(
)
=
=
lastModified
)
{
return
false
;
}
Log
.
i
(
TAG
"
Copying
"
+
src
+
"
-
>
"
+
dest
)
;
FileInputStream
istream
=
new
FileInputStream
(
src
)
;
FileOutputStream
ostream
=
new
FileOutputStream
(
dest
)
;
ostream
.
getChannel
(
)
.
transferFrom
(
istream
.
getChannel
(
)
0
istream
.
getChannel
(
)
.
size
(
)
)
;
istream
.
close
(
)
;
ostream
.
close
(
)
;
dest
.
setReadable
(
true
false
)
;
dest
.
setExecutable
(
true
false
)
;
dest
.
setLastModified
(
lastModified
)
;
return
true
;
}
private
void
ensureAppFilesSubDirExists
(
)
{
mAppFilesSubDir
.
mkdir
(
)
;
mAppFilesSubDir
.
setExecutable
(
true
false
)
;
}
private
void
createSymlink
(
String
to
File
from
)
throws
ReflectiveOperationException
{
Reflect
.
invokeMethod
(
mLibcoreOs
"
symlink
"
to
from
.
getAbsolutePath
(
)
)
;
}
private
static
Object
[
]
makeNativePathElements
(
File
[
]
paths
)
throws
ReflectiveOperationException
{
Object
[
]
entries
=
new
Object
[
paths
.
length
]
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
26
)
{
Class
<
?
>
entryClazz
=
Class
.
forName
(
"
dalvik
.
system
.
DexPathList
NativeLibraryElement
"
)
;
for
(
int
i
=
0
;
i
<
paths
.
length
;
+
+
i
)
{
entries
[
i
]
=
Reflect
.
newInstance
(
entryClazz
paths
[
i
]
)
;
}
}
else
{
Class
<
?
>
entryClazz
=
Class
.
forName
(
"
dalvik
.
system
.
DexPathList
Element
"
)
;
for
(
int
i
=
0
;
i
<
paths
.
length
;
+
+
i
)
{
entries
[
i
]
=
Reflect
.
newInstance
(
entryClazz
paths
[
i
]
true
null
null
)
;
}
}
return
entries
;
}
private
Object
[
]
addDexElements
(
File
[
]
files
File
optimizedDirectory
Object
[
]
curDexElements
)
throws
ReflectiveOperationException
{
Class
<
?
>
entryClazz
=
Class
.
forName
(
"
dalvik
.
system
.
DexPathList
Element
"
)
;
Class
<
?
>
clazz
=
Class
.
forName
(
"
dalvik
.
system
.
DexPathList
"
)
;
Object
[
]
ret
=
Reflect
.
concatArrays
(
curDexElements
curDexElements
new
Object
[
files
.
length
]
)
;
File
emptyDir
=
new
File
(
"
"
)
;
for
(
int
i
=
0
;
i
<
files
.
length
;
+
+
i
)
{
File
file
=
files
[
i
]
;
Object
dexFile
=
Reflect
.
invokeMethod
(
clazz
"
loadDexFile
"
file
optimizedDirectory
mClassLoader
ret
)
;
Object
dexElement
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
26
)
{
dexElement
=
Reflect
.
newInstance
(
entryClazz
dexFile
file
)
;
}
else
{
dexElement
=
Reflect
.
newInstance
(
entryClazz
emptyDir
false
file
dexFile
)
;
}
ret
[
curDexElements
.
length
+
i
]
=
dexElement
;
}
return
ret
;
}
}
