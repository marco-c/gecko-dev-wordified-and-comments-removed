package
org
.
chromium
.
incrementalinstall
;
import
android
.
os
.
Build
;
import
org
.
lsposed
.
hiddenapibypass
.
LSPass
;
import
java
.
lang
.
reflect
.
Array
;
import
java
.
lang
.
reflect
.
Constructor
;
import
java
.
lang
.
reflect
.
Field
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
List
;
final
class
Reflect
{
static
void
setField
(
Object
instance
String
name
Object
value
)
throws
ReflectiveOperationException
{
Field
field
=
findField
(
instance
name
)
;
field
.
setAccessible
(
true
)
;
field
.
set
(
instance
value
)
;
}
static
Object
getField
(
Object
instance
String
name
)
throws
ReflectiveOperationException
{
Field
field
=
findField
(
instance
name
)
;
field
.
setAccessible
(
true
)
;
return
field
.
get
(
instance
)
;
}
static
Object
[
]
concatArrays
(
Object
[
]
arrType
Object
[
]
left
Object
[
]
right
)
{
Object
[
]
result
=
(
Object
[
]
)
Array
.
newInstance
(
arrType
.
getClass
(
)
.
getComponentType
(
)
left
.
length
+
right
.
length
)
;
System
.
arraycopy
(
left
0
result
0
left
.
length
)
;
System
.
arraycopy
(
right
0
result
left
.
length
right
.
length
)
;
return
result
;
}
static
Object
invokeMethod
(
Object
instance
String
name
Object
.
.
.
params
)
throws
ReflectiveOperationException
{
boolean
isStatic
=
instance
instanceof
Class
;
Class
<
?
>
clazz
=
isStatic
?
(
Class
<
?
>
)
instance
:
instance
.
getClass
(
)
;
Method
method
=
findMethod
(
clazz
name
params
)
;
method
.
setAccessible
(
true
)
;
return
method
.
invoke
(
instance
params
)
;
}
static
Object
newInstance
(
Class
<
?
>
clazz
Object
.
.
.
params
)
throws
ReflectiveOperationException
{
Constructor
<
?
>
constructor
=
findConstructor
(
clazz
params
)
;
constructor
.
setAccessible
(
true
)
;
return
constructor
.
newInstance
(
params
)
;
}
private
static
Field
findField
(
Object
instance
String
name
)
throws
NoSuchFieldException
{
boolean
isStatic
=
instance
instanceof
Class
;
Class
<
?
>
clazz
=
isStatic
?
(
Class
<
?
>
)
instance
:
instance
.
getClass
(
)
;
for
(
;
clazz
!
=
null
;
clazz
=
clazz
.
getSuperclass
(
)
)
{
if
(
Build
.
VERSION
.
SDK_INT
<
Build
.
VERSION_CODES
.
P
)
{
try
{
return
clazz
.
getDeclaredField
(
name
)
;
}
catch
(
NoSuchFieldException
e
)
{
}
}
else
{
List
<
Field
>
fields
=
isStatic
?
LSPass
.
getStaticFields
(
clazz
)
:
LSPass
.
getInstanceFields
(
clazz
)
;
for
(
Field
field
:
fields
)
{
if
(
field
.
getName
(
)
.
equals
(
name
)
)
{
return
field
;
}
}
}
}
throw
new
NoSuchFieldException
(
"
Field
"
+
name
+
"
not
found
in
"
+
instance
.
getClass
(
)
)
;
}
private
static
Method
findMethod
(
Class
<
?
>
clazz
String
name
Object
.
.
.
params
)
throws
NoSuchMethodException
{
for
(
;
clazz
!
=
null
;
clazz
=
clazz
.
getSuperclass
(
)
)
{
for
(
Method
method
:
clazz
.
getDeclaredMethods
(
)
)
{
if
(
method
.
getName
(
)
.
equals
(
name
)
&
&
areParametersCompatible
(
method
.
getParameterTypes
(
)
params
)
)
{
return
method
;
}
}
}
throw
new
NoSuchMethodException
(
"
Method
"
+
name
+
"
with
parameters
"
+
Arrays
.
asList
(
params
)
+
"
not
found
in
"
+
clazz
)
;
}
private
static
Constructor
<
?
>
findConstructor
(
Class
<
?
>
clazz
Object
.
.
.
params
)
throws
NoSuchMethodException
{
for
(
Constructor
<
?
>
constructor
:
clazz
.
getDeclaredConstructors
(
)
)
{
if
(
areParametersCompatible
(
constructor
.
getParameterTypes
(
)
params
)
)
{
return
constructor
;
}
}
throw
new
NoSuchMethodException
(
"
Constructor
with
parameters
"
+
Arrays
.
asList
(
params
)
+
"
not
found
in
"
+
clazz
)
;
}
private
static
boolean
areParametersCompatible
(
Class
<
?
>
[
]
paramTypes
Object
.
.
.
params
)
{
if
(
params
.
length
!
=
paramTypes
.
length
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
params
.
length
;
i
+
+
)
{
if
(
!
isAssignableFrom
(
paramTypes
[
i
]
params
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
private
static
boolean
isAssignableFrom
(
Class
<
?
>
left
Object
right
)
{
if
(
right
=
=
null
)
{
return
!
left
.
isPrimitive
(
)
;
}
Class
<
?
>
rightClazz
=
right
.
getClass
(
)
;
if
(
left
.
isPrimitive
(
)
)
{
return
(
left
=
=
boolean
.
class
&
&
rightClazz
=
=
Boolean
.
class
)
|
|
(
left
=
=
int
.
class
&
&
rightClazz
=
=
Integer
.
class
)
;
}
return
left
.
isAssignableFrom
(
rightClazz
)
;
}
}
