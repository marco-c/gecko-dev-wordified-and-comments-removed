package
org
.
chromium
.
incrementalinstall
;
import
android
.
util
.
Log
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
nio
.
channels
.
FileLock
;
import
java
.
util
.
concurrent
.
Callable
;
final
class
LockFile
{
private
static
final
String
TAG
=
"
incrementalinstall
"
;
private
final
File
mFile
;
private
final
FileOutputStream
mOutputStream
;
private
final
FileLock
mFileLock
;
private
LockFile
(
File
file
FileOutputStream
outputStream
FileLock
fileLock
)
{
mFile
=
file
;
mOutputStream
=
outputStream
;
mFileLock
=
fileLock
;
}
static
void
clearInstallerLock
(
File
lockFile
)
throws
IOException
{
Log
.
i
(
TAG
"
Clearing
"
+
lockFile
)
;
FileOutputStream
os
=
new
FileOutputStream
(
lockFile
)
;
os
.
write
(
1
)
;
os
.
close
(
)
;
}
static
void
waitForInstallerLock
(
final
File
file
long
timeoutMs
)
{
pollingWait
(
new
Callable
<
Boolean
>
(
)
{
Override
public
Boolean
call
(
)
{
return
!
installerLockExists
(
file
)
;
}
}
file
timeoutMs
)
;
}
private
static
void
pollingWait
(
Callable
<
Boolean
>
func
File
file
long
timeoutMs
)
{
long
pollIntervalMs
=
200
;
for
(
int
i
=
0
;
i
<
timeoutMs
/
pollIntervalMs
;
i
+
+
)
{
try
{
if
(
func
.
call
(
)
)
{
if
(
i
>
0
)
{
Log
.
i
(
TAG
"
Finished
waiting
on
lock
file
:
"
+
file
)
;
}
return
;
}
else
if
(
i
=
=
0
)
{
Log
.
i
(
TAG
"
Waiting
on
lock
file
:
"
+
file
)
;
}
}
catch
(
Exception
e
)
{
throw
new
RuntimeException
(
e
)
;
}
try
{
Thread
.
sleep
(
pollIntervalMs
)
;
}
catch
(
InterruptedException
e
)
{
}
}
throw
new
RuntimeException
(
"
Timed
out
waiting
for
lock
file
:
"
+
file
)
;
}
static
boolean
installerLockExists
(
File
file
)
{
return
!
file
.
exists
(
)
|
|
file
.
length
(
)
=
=
0
;
}
static
LockFile
acquireRuntimeLock
(
File
file
)
{
try
{
FileOutputStream
outputStream
=
new
FileOutputStream
(
file
)
;
FileLock
lock
=
outputStream
.
getChannel
(
)
.
tryLock
(
)
;
if
(
lock
!
=
null
)
{
Log
.
i
(
TAG
"
Created
lock
file
:
"
+
file
)
;
return
new
LockFile
(
file
outputStream
lock
)
;
}
outputStream
.
close
(
)
;
}
catch
(
IOException
e
)
{
Log
.
w
(
TAG
"
Exception
trying
to
acquire
lock
"
+
file
e
)
;
}
return
null
;
}
static
void
waitForRuntimeLock
(
final
File
file
long
timeoutMs
)
{
pollingWait
(
new
Callable
<
Boolean
>
(
)
{
Override
public
Boolean
call
(
)
{
return
!
file
.
exists
(
)
;
}
}
file
timeoutMs
)
;
}
void
release
(
)
throws
IOException
{
Log
.
i
(
TAG
"
Deleting
lock
file
:
"
+
mFile
)
;
mFileLock
.
release
(
)
;
mOutputStream
.
close
(
)
;
if
(
!
mFile
.
delete
(
)
)
{
throw
new
IOException
(
"
Failed
to
delete
lock
file
:
"
+
mFile
)
;
}
}
}
