"
"
"
Wraps
ml
.
exe
or
ml64
.
exe
and
postprocesses
the
output
to
be
deterministic
.
Sets
timestamp
in
.
obj
file
to
0
hence
incompatible
with
link
.
exe
/
incremental
.
Use
by
prefixing
the
ml
(
64
)
.
exe
invocation
with
this
script
:
    
python
ml
.
py
ml
.
exe
[
args
.
.
.
]
"
"
"
import
array
import
collections
import
struct
import
subprocess
import
sys
class
Struct
(
object
)
:
  
"
"
"
A
thin
wrapper
around
the
struct
module
that
returns
a
namedtuple
"
"
"
  
def
__init__
(
self
name
*
args
)
:
    
"
"
"
Pass
the
name
of
the
return
type
and
then
an
interleaved
list
of
    
format
strings
as
used
by
the
struct
module
and
of
field
names
.
"
"
"
    
self
.
fmt
=
'
<
'
+
'
'
.
join
(
args
[
0
:
:
2
]
)
    
self
.
type
=
collections
.
namedtuple
(
name
args
[
1
:
:
2
]
)
  
def
pack_into
(
self
buffer
offset
data
)
:
    
return
struct
.
pack_into
(
self
.
fmt
buffer
offset
*
data
)
  
def
unpack_from
(
self
buffer
offset
=
0
)
:
    
return
self
.
type
(
*
struct
.
unpack_from
(
self
.
fmt
buffer
offset
)
)
  
def
size
(
self
)
:
    
return
struct
.
calcsize
(
self
.
fmt
)
def
Subtract
(
nt
*
*
kwargs
)
:
  
"
"
"
Subtract
(
nt
f
=
2
)
returns
a
new
namedtuple
with
2
subtracted
from
nt
.
f
"
"
"
  
return
nt
.
_replace
(
*
*
{
k
:
getattr
(
nt
k
)
-
v
for
k
v
in
kwargs
.
items
(
)
}
)
def
MakeDeterministic
(
objdata
)
:
  
objdata
=
array
.
array
(
'
b
'
objdata
)
  
COFFHEADER
=
Struct
(
'
COFFHEADER
'
'
H
'
'
Machine
'
'
H
'
'
NumberOfSections
'
                      
'
I
'
'
TimeDateStamp
'
'
I
'
'
PointerToSymbolTable
'
'
I
'
                      
'
NumberOfSymbols
'
'
H
'
'
SizeOfOptionalHeader
'
'
H
'
                      
'
Characteristics
'
)
  
coff_header
=
COFFHEADER
.
unpack_from
(
objdata
)
  
assert
coff_header
.
SizeOfOptionalHeader
=
=
0
  
SECTIONHEADER
=
Struct
(
'
SECTIONHEADER
'
'
8s
'
'
Name
'
'
I
'
'
VirtualSize
'
'
I
'
                         
'
VirtualAddress
'
'
I
'
'
SizeOfRawData
'
'
I
'
                         
'
PointerToRawData
'
'
I
'
'
PointerToRelocations
'
'
I
'
                         
'
PointerToLineNumbers
'
'
H
'
'
NumberOfRelocations
'
                         
'
H
'
'
NumberOfLineNumbers
'
'
I
'
'
Characteristics
'
)
  
section_headers
=
[
]
  
debug_section_index
=
-
1
  
for
i
in
range
(
0
coff_header
.
NumberOfSections
)
:
    
section_header
=
SECTIONHEADER
.
unpack_from
(
objdata
                                               
offset
=
COFFHEADER
.
size
(
)
+
                                               
i
*
SECTIONHEADER
.
size
(
)
)
    
assert
not
section_header
[
0
]
.
startswith
(
b
'
/
'
)
    
section_headers
.
append
(
section_header
)
    
if
section_header
.
Name
=
=
b
'
.
debug
S
'
:
      
assert
debug_section_index
=
=
-
1
      
debug_section_index
=
i
  
assert
debug_section_index
!
=
-
1
  
data_start
=
COFFHEADER
.
size
(
)
+
len
(
section_headers
)
*
SECTIONHEADER
.
size
(
)
  
assert
section_headers
[
debug_section_index
]
.
Name
=
=
b
'
.
debug
S
'
  
assert
section_headers
[
debug_section_index
]
.
VirtualSize
=
=
0
  
assert
section_headers
[
debug_section_index
]
.
VirtualAddress
=
=
0
  
debug_size
=
section_headers
[
debug_section_index
]
.
SizeOfRawData
  
debug_offset
=
section_headers
[
debug_section_index
]
.
PointerToRawData
  
assert
section_headers
[
debug_section_index
]
.
PointerToRelocations
=
=
0
  
assert
section_headers
[
debug_section_index
]
.
PointerToLineNumbers
=
=
0
  
assert
section_headers
[
debug_section_index
]
.
NumberOfRelocations
=
=
0
  
assert
section_headers
[
debug_section_index
]
.
NumberOfLineNumbers
=
=
0
  
for
header
in
section_headers
[
:
debug_section_index
]
:
    
assert
header
.
PointerToRawData
<
debug_offset
    
assert
header
.
PointerToRelocations
<
debug_offset
    
assert
header
.
PointerToLineNumbers
<
debug_offset
  
for
header
in
section_headers
[
debug_section_index
+
1
:
]
:
    
assert
header
.
PointerToRawData
>
debug_offset
    
assert
header
.
PointerToRelocations
=
=
0
    
assert
header
.
PointerToLineNumbers
=
=
0
  
for
section_header
in
section_headers
:
    
if
section_header
.
PointerToRawData
=
=
0
:
      
assert
section_header
.
PointerToRelocations
=
=
0
      
assert
section_header
.
PointerToLineNumbers
=
=
0
      
continue
    
assert
section_header
.
PointerToRawData
=
=
data_start
    
break
  
assert
(
      
coff_header
.
PointerToSymbolTable
>
=
      
section_headers
[
-
1
]
.
PointerToRawData
+
section_headers
[
-
1
]
.
SizeOfRawData
)
  
SYM
=
Struct
(
      
'
SYM
'
      
'
8s
'
      
'
Name
'
      
'
I
'
      
'
Value
'
      
'
h
'
      
'
SectionNumber
'
      
'
H
'
      
'
Type
'
      
'
B
'
      
'
StorageClass
'
      
'
B
'
      
'
NumberOfAuxSymbols
'
)
  
i
=
0
  
debug_sym
=
-
1
  
while
i
<
coff_header
.
NumberOfSymbols
:
    
sym_offset
=
coff_header
.
PointerToSymbolTable
+
i
*
SYM
.
size
(
)
    
sym
=
SYM
.
unpack_from
(
objdata
sym_offset
)
    
assert
sym
.
StorageClass
!
=
107
    
if
sym
.
SectionNumber
-
1
=
=
debug_section_index
:
      
assert
debug_sym
=
=
-
1
'
more
than
one
.
debug
S
symbol
found
'
      
debug_sym
=
i
      
assert
sym
.
Name
=
=
b
'
.
debug
S
'
      
assert
sym
.
Value
=
=
0
      
assert
sym
.
Type
=
=
0
      
assert
sym
.
StorageClass
=
=
3
      
assert
sym
.
NumberOfAuxSymbols
=
=
1
    
elif
sym
.
SectionNumber
>
debug_section_index
:
      
sym
=
Subtract
(
sym
SectionNumber
=
1
)
      
SYM
.
pack_into
(
objdata
sym_offset
sym
)
    
i
+
=
1
+
sym
.
NumberOfAuxSymbols
  
assert
debug_sym
!
=
-
1
'
.
debug
S
symbol
not
found
'
  
REL
=
Struct
(
'
REL
'
'
I
'
'
VirtualAddress
'
'
I
'
'
SymbolTableIndex
'
'
H
'
               
'
Type
'
)
  
for
header
in
section_headers
[
0
:
debug_section_index
]
:
    
for
j
in
range
(
0
header
.
NumberOfRelocations
)
:
      
rel_offset
=
header
.
PointerToRelocations
+
j
*
REL
.
size
(
)
      
rel
=
REL
.
unpack_from
(
objdata
rel_offset
)
      
assert
rel
.
SymbolTableIndex
!
=
debug_sym
      
if
rel
.
SymbolTableIndex
>
debug_sym
:
        
rel
=
Subtract
(
rel
SymbolTableIndex
=
2
)
        
REL
.
pack_into
(
objdata
rel_offset
rel
)
  
for
header
in
section_headers
:
    
assert
header
.
NumberOfLineNumbers
=
=
0
  
del
objdata
[
coff_header
.
PointerToSymbolTable
+
              
debug_sym
*
SYM
.
size
(
)
:
coff_header
.
PointerToSymbolTable
+
              
(
debug_sym
+
2
)
*
SYM
.
size
(
)
]
  
for
i
in
range
(
0
debug_section_index
)
:
    
header
=
section_headers
[
i
]
    
if
header
.
SizeOfRawData
:
      
header
=
Subtract
(
header
PointerToRawData
=
SECTIONHEADER
.
size
(
)
)
    
if
header
.
NumberOfRelocations
:
      
header
=
Subtract
(
header
PointerToRelocations
=
SECTIONHEADER
.
size
(
)
)
    
if
header
.
NumberOfLineNumbers
:
      
header
=
Subtract
(
header
PointerToLineNumbers
=
SECTIONHEADER
.
size
(
)
)
    
SECTIONHEADER
.
pack_into
(
objdata
                            
COFFHEADER
.
size
(
)
+
i
*
SECTIONHEADER
.
size
(
)
                            
header
)
  
for
i
in
range
(
debug_section_index
+
1
len
(
section_headers
)
)
:
    
header
=
section_headers
[
i
]
    
shift
=
SECTIONHEADER
.
size
(
)
+
debug_size
    
if
header
.
SizeOfRawData
:
      
header
=
Subtract
(
header
PointerToRawData
=
shift
)
    
if
header
.
NumberOfRelocations
:
      
header
=
Subtract
(
header
PointerToRelocations
=
shift
)
    
if
header
.
NumberOfLineNumbers
:
      
header
=
Subtract
(
header
PointerToLineNumbers
=
shift
)
    
SECTIONHEADER
.
pack_into
(
objdata
                            
COFFHEADER
.
size
(
)
+
i
*
SECTIONHEADER
.
size
(
)
                            
header
)
  
del
objdata
[
debug_offset
:
debug_offset
+
debug_size
]
  
coff_header
=
coff_header
.
_replace
(
TimeDateStamp
=
0
)
  
coff_header
=
Subtract
(
coff_header
                         
NumberOfSections
=
1
                         
PointerToSymbolTable
=
SECTIONHEADER
.
size
(
)
+
debug_size
                         
NumberOfSymbols
=
2
)
  
COFFHEADER
.
pack_into
(
objdata
0
coff_header
)
  
del
objdata
[
COFFHEADER
.
size
(
)
+
              
debug_section_index
*
SECTIONHEADER
.
size
(
)
:
COFFHEADER
.
size
(
)
+
              
(
debug_section_index
+
1
)
*
SECTIONHEADER
.
size
(
)
]
  
if
sys
.
version_info
.
major
=
=
2
:
    
return
objdata
.
tostring
(
)
  
else
:
    
return
objdata
.
tobytes
(
)
def
main
(
)
:
  
ml_result
=
subprocess
.
call
(
sys
.
argv
[
1
:
]
)
  
if
ml_result
!
=
0
:
    
return
ml_result
  
objfile
=
None
  
for
i
in
range
(
1
len
(
sys
.
argv
)
)
:
    
if
sys
.
argv
[
i
]
.
startswith
(
'
/
Fo
'
)
:
      
objfile
=
sys
.
argv
[
i
]
[
len
(
'
/
Fo
'
)
:
]
  
assert
objfile
'
failed
to
find
ml
output
'
  
with
open
(
objfile
'
rb
'
)
as
f
:
    
objdata
=
f
.
read
(
)
  
objdata
=
MakeDeterministic
(
objdata
)
  
with
open
(
objfile
'
wb
'
)
as
f
:
    
f
.
write
(
objdata
)
if
__name__
=
=
'
__main__
'
:
  
sys
.
exit
(
main
(
)
)
