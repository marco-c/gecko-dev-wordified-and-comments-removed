from
__future__
import
division
from
__future__
import
print_function
import
array
import
difflib
import
distutils
.
dir_util
import
filecmp
import
io
import
operator
import
os
import
posixpath
import
re
import
shutil
import
struct
import
subprocess
import
sys
import
tempfile
import
uuid
from
functools
import
reduce
def
ZapTimestamp
(
filename
)
:
  
contents
=
open
(
filename
'
rb
'
)
.
read
(
)
  
if
filename
.
endswith
(
'
.
tlb
'
)
:
    
assert
contents
[
0
:
8
]
=
=
b
'
MSFT
\
x02
\
x00
\
x01
\
x00
'
    
ntypes
=
struct
.
unpack_from
(
'
<
I
'
contents
0x20
)
    
custom_off
custom_len
=
struct
.
unpack_from
(
        
'
<
II
'
contents
0x54
+
4
*
ntypes
+
11
*
16
)
    
assert
custom_len
>
=
0x54
    
assert
contents
[
custom_off
:
custom_off
+
6
]
=
=
b
'
\
x08
\
x00
\
x3e
\
x00
\
x00
\
x00
'
    
assert
re
.
match
(
        
br
'
Created
by
MIDL
version
8
\
.
\
d
\
d
\
.
\
d
{
4
}
'
        
br
'
at
.
.
.
Jan
1
.
.
.
:
.
.
:
.
.
2038
\
n
'
        
contents
[
custom_off
+
6
:
custom_off
+
6
+
0x3e
]
)
    
assert
contents
[
custom_off
+
6
+
0x3e
:
custom_off
+
6
+
0x3e
+
8
]
=
=
\
        
b
'
\
x13
\
x00
\
xff
\
xff
\
xff
\
x7f
\
x57
\
x57
'
    
assert
contents
[
custom_off
+
6
+
0x3e
+
8
:
custom_off
+
6
+
0x3e
+
8
+
                    
2
]
=
=
b
'
\
x13
\
x00
'
    
contents
=
(
        
contents
[
0
:
custom_off
+
6
]
+
        
b
'
Created
by
MIDL
version
8
.
xx
.
xxxx
at
a
redacted
point
in
time
\
n
'
+
        
b
'
\
x13
\
x00
\
xff
\
xff
\
xff
\
x7f
\
x57
\
x57
\
x13
\
x00
\
x6e
\
x02
\
x01
\
x08
\
x57
\
x57
'
+
        
contents
[
custom_off
+
0x54
:
]
)
  
else
:
    
contents
=
re
.
sub
(
        
br
'
File
created
by
MIDL
compiler
version
8
\
.
\
d
\
d
\
.
\
d
{
4
}
\
*
/
\
r
\
n
'
        
br
'
/
\
*
at
.
.
.
Jan
1
.
.
.
:
.
.
:
.
.
2038
'
        
br
'
File
created
by
MIDL
compiler
version
8
.
xx
.
xxxx
*
/
\
r
\
n
'
        
br
'
/
*
at
a
redacted
point
in
time
'
contents
)
    
contents
=
re
.
sub
(
        
br
'
Oicf
W1
Zp8
env
=
(
.
.
.
.
.
)
\
(
32b
run
\
)
'
        
br
'
target_arch
=
(
AMD64
|
X86
)
8
\
.
\
d
\
d
\
.
\
d
{
4
}
'
        
br
'
Oicf
W1
Zp8
env
=
\
1
(
32b
run
)
target_arch
=
\
2
8
.
xx
.
xxxx
'
        
contents
)
    
contents
=
contents
.
replace
(
b
'
#
endif
!
_MIDL_USE_GUIDDEF_
'
                                
b
'
#
endif
/
/
!
_MIDL_USE_GUIDDEF_
'
)
    
contents
=
contents
.
replace
(
b
'
0x801026c
/
*
MIDL
Version
8
.
1
.
620
*
/
'
                                
b
'
0x801026e
/
*
MIDL
Version
8
.
1
.
622
*
/
'
)
  
open
(
filename
'
wb
'
)
.
write
(
contents
)
def
get_tlb_contents
(
tlb_file
)
:
  
contents
=
open
(
tlb_file
'
rb
'
)
.
read
(
)
  
assert
contents
[
0
:
8
]
=
=
b
'
MSFT
\
x02
\
x00
\
x01
\
x00
'
  
ntypes
=
struct
.
unpack_from
(
'
<
I
'
contents
0x20
)
  
type_off
type_len
=
struct
.
unpack_from
(
'
<
II
'
contents
0x54
+
4
*
ntypes
)
  
guid_off
guid_len
=
struct
.
unpack_from
(
      
'
<
II
'
contents
0x54
+
4
*
ntypes
+
5
*
16
)
  
assert
guid_len
%
24
=
=
0
  
contents
=
array
.
array
(
'
B
'
contents
)
  
return
contents
ntypes
type_off
guid_off
guid_len
def
recreate_guid_hashtable
(
contents
ntypes
guid_off
guid_len
)
:
  
hashtab
=
[
0xffffffff
]
*
(
0x80
/
/
4
)
  
for
guidind
in
range
(
guid_off
guid_off
+
guid_len
24
)
:
    
guidbytes
typeoff
nextguid
=
struct
.
unpack_from
(
        
'
<
16sII
'
contents
guidind
)
    
words
=
struct
.
unpack
(
'
<
8H
'
guidbytes
)
    
guidhash
=
reduce
(
operator
.
xor
[
w
for
w
in
words
]
)
%
(
0x80
/
/
4
)
    
nextguid
=
hashtab
[
guidhash
]
    
struct
.
pack_into
(
'
<
I
'
contents
guidind
+
0x14
nextguid
)
    
hashtab
[
guidhash
]
=
guidind
-
guid_off
  
hash_off
hash_len
=
struct
.
unpack_from
(
      
'
<
II
'
contents
0x54
+
4
*
ntypes
+
4
*
16
)
  
for
i
hashval
in
enumerate
(
hashtab
)
:
    
struct
.
pack_into
(
'
<
I
'
contents
hash_off
+
4
*
i
hashval
)
def
overwrite_guids_h
(
h_file
dynamic_guids
)
:
  
contents
=
open
(
h_file
'
rb
'
)
.
read
(
)
  
for
key
in
dynamic_guids
:
    
contents
=
re
.
sub
(
key
dynamic_guids
[
key
]
contents
flags
=
re
.
I
)
  
open
(
h_file
'
wb
'
)
.
write
(
contents
)
def
get_uuid_format
(
guid
prefix
)
:
  
formatted_uuid
=
b
'
0x
%
s
0x
%
s
0x
%
s
'
%
(
guid
[
0
:
8
]
guid
[
9
:
13
]
guid
[
14
:
18
]
)
  
formatted_uuid
+
=
b
'
%
s0x
%
s
0x
%
s
'
%
(
prefix
guid
[
19
:
21
]
guid
[
21
:
23
]
)
  
for
i
in
range
(
24
len
(
guid
)
2
)
:
    
formatted_uuid
+
=
b
'
0x
'
+
guid
[
i
:
i
+
2
]
  
return
formatted_uuid
def
get_uuid_format_iid_file
(
guid
)
:
  
return
get_uuid_format
(
guid
b
'
'
)
def
overwrite_guids_iid
(
iid_file
dynamic_guids
)
:
  
contents
=
open
(
iid_file
'
rb
'
)
.
read
(
)
  
for
key
in
dynamic_guids
:
    
contents
=
re
.
sub
(
get_uuid_format_iid_file
(
key
)
                      
get_uuid_format_iid_file
(
dynamic_guids
[
key
]
)
                      
contents
                      
flags
=
re
.
I
)
  
open
(
iid_file
'
wb
'
)
.
write
(
contents
)
def
get_uuid_format_proxy_file
(
guid
)
:
  
return
get_uuid_format
(
guid
b
'
{
'
)
def
overwrite_guids_proxy
(
proxy_file
dynamic_guids
)
:
  
contents
=
open
(
proxy_file
'
rb
'
)
.
read
(
)
  
for
key
in
dynamic_guids
:
    
contents
=
re
.
sub
(
get_uuid_format_proxy_file
(
key
)
                      
get_uuid_format_proxy_file
(
dynamic_guids
[
key
]
)
                      
contents
                      
flags
=
re
.
I
)
  
open
(
proxy_file
'
wb
'
)
.
write
(
contents
)
def
getguid
(
contents
offset
)
:
  
g0
g1
g2
g3
=
struct
.
unpack_from
(
'
<
IHH8s
'
contents
offset
)
  
g3
=
b
'
'
.
join
(
[
b
'
%
02X
'
%
g
for
g
in
bytearray
(
g3
)
]
)
  
return
b
'
%
08X
-
%
04X
-
%
04X
-
%
s
-
%
s
'
%
(
g0
g1
g2
g3
[
0
:
4
]
g3
[
4
:
]
)
def
setguid
(
contents
offset
guid
)
:
  
guid
=
uuid
.
UUID
(
guid
.
decode
(
'
utf
-
8
'
)
)
  
struct
.
pack_into
(
'
<
IHH8s
'
contents
offset
                   
*
(
guid
.
fields
[
0
:
3
]
+
(
guid
.
bytes
[
8
:
]
)
)
)
def
overwrite_guids_tlb
(
tlb_file
dynamic_guids
)
:
  
contents
ntypes
type_off
guid_off
guid_len
=
get_tlb_contents
(
tlb_file
)
  
for
i
in
range
(
0
guid_len
24
)
:
    
current_guid
=
getguid
(
contents
guid_off
+
i
)
    
for
key
in
dynamic_guids
:
      
if
key
.
lower
(
)
=
=
current_guid
.
lower
(
)
:
        
setguid
(
contents
guid_off
+
i
dynamic_guids
[
key
]
)
  
recreate_guid_hashtable
(
contents
ntypes
guid_off
guid_len
)
  
open
(
tlb_file
'
wb
'
)
.
write
(
contents
)
def
overwrite_guids
(
h_file
iid_file
proxy_file
tlb_file
dynamic_guids
)
:
  
overwrite_guids_h
(
h_file
dynamic_guids
)
  
overwrite_guids_iid
(
iid_file
dynamic_guids
)
  
overwrite_guids_proxy
(
proxy_file
dynamic_guids
)
  
if
tlb_file
:
    
overwrite_guids_tlb
(
tlb_file
dynamic_guids
)
def
generate_idl_from_template
(
idl_template
dynamic_guids
idl
)
:
  
contents
=
open
(
idl_template
'
rb
'
)
.
read
(
)
  
contents
=
re
.
sub
(
b
'
PLACEHOLDER
-
GUID
-
'
b
'
'
contents
flags
=
re
.
I
)
  
if
dynamic_guids
:
    
for
key
in
dynamic_guids
:
      
contents
=
re
.
sub
(
key
dynamic_guids
[
key
]
contents
flags
=
re
.
I
)
  
open
(
idl
'
wb
'
)
.
write
(
contents
)
def
run_midl
(
args
env_dict
)
:
  
midl_output_dir
=
tempfile
.
mkdtemp
(
)
  
delete_midl_output_dir
=
True
  
try
:
    
popen
=
subprocess
.
Popen
(
args
+
[
'
/
out
'
midl_output_dir
]
                             
shell
=
True
                             
universal_newlines
=
True
                             
env
=
env_dict
                             
stdout
=
subprocess
.
PIPE
                             
stderr
=
subprocess
.
STDOUT
)
    
out
_
=
popen
.
communicate
(
)
    
lines
=
out
.
splitlines
(
)
    
prefixes
=
(
'
Processing
'
'
64
bit
Processing
'
)
    
processing
=
set
(
        
os
.
path
.
basename
(
x
)
for
x
in
lines
if
x
.
startswith
(
prefixes
)
)
    
for
line
in
lines
:
      
if
not
line
.
startswith
(
prefixes
)
and
line
not
in
processing
:
        
print
(
line
)
    
if
popen
.
returncode
!
=
0
:
      
return
popen
.
returncode
midl_output_dir
    
for
f
in
os
.
listdir
(
midl_output_dir
)
:
      
ZapTimestamp
(
os
.
path
.
join
(
midl_output_dir
f
)
)
    
delete_midl_output_dir
=
False
  
finally
:
    
if
os
.
path
.
exists
(
midl_output_dir
)
and
delete_midl_output_dir
:
      
shutil
.
rmtree
(
midl_output_dir
)
  
return
0
midl_output_dir
def
uuid5_substitutions
(
dynamic_guids
)
:
  
for
key
value
in
dynamic_guids
.
items
(
)
:
    
if
value
.
startswith
(
'
uuid5
:
'
)
:
      
name
=
value
.
split
(
'
uuid5
:
'
1
)
[
1
]
      
assert
name
      
dynamic_guids
[
key
]
=
str
(
uuid
.
uuid5
(
uuid
.
UUID
(
key
)
name
)
)
.
upper
(
)
def
main
(
arch
gendir
outdir
dynamic_guids
tlb
h
dlldata
iid
proxy
         
clang
idl
*
flags
)
:
  
source
=
gendir
  
if
os
.
path
.
isdir
(
os
.
path
.
join
(
source
os
.
path
.
basename
(
idl
)
)
)
:
    
source
=
os
.
path
.
join
(
source
os
.
path
.
basename
(
idl
)
)
  
source
=
os
.
path
.
join
(
source
arch
.
split
(
'
.
'
)
[
1
]
)
  
source
=
os
.
path
.
normpath
(
source
)
  
source_exists
=
True
  
if
not
os
.
path
.
isdir
(
source
)
:
    
source_exists
=
False
    
if
sys
.
platform
!
=
'
win32
'
:
      
print
(
'
Directory
%
s
needs
to
be
populated
from
Windows
first
'
%
source
)
      
return
1
    
os
.
makedirs
(
source
)
  
common_files
=
[
h
iid
]
  
if
tlb
!
=
'
none
'
:
    
common_files
+
=
[
tlb
]
  
else
:
    
tlb
=
None
  
if
dlldata
!
=
'
none
'
:
    
common_files
+
=
[
dlldata
]
  
else
:
    
dlldata
=
None
  
if
proxy
!
=
'
none
'
:
    
common_files
+
=
[
proxy
]
  
else
:
    
proxy
=
None
  
for
source_file
in
common_files
:
    
file_path
=
os
.
path
.
join
(
source
source_file
)
    
if
not
os
.
path
.
isfile
(
file_path
)
:
      
source_exists
=
False
      
if
sys
.
platform
!
=
'
win32
'
:
        
print
(
'
File
%
s
needs
to
be
generated
from
Windows
first
'
%
file_path
)
        
return
1
      
open
(
file_path
'
wb
'
)
.
close
(
)
    
shutil
.
copy
(
file_path
outdir
)
  
if
dynamic_guids
!
=
'
none
'
:
    
assert
'
=
'
in
dynamic_guids
    
if
dynamic_guids
.
startswith
(
"
ignore_proxy_stub
"
)
:
      
common_files
.
remove
(
proxy
)
      
dynamic_guids
=
dynamic_guids
.
split
(
"
ignore_proxy_stub
"
1
)
[
1
]
    
dynamic_guids
=
re
.
sub
(
'
PLACEHOLDER
-
GUID
-
'
'
'
dynamic_guids
flags
=
re
.
I
)
    
dynamic_guids
=
dynamic_guids
.
split
(
'
'
)
    
dynamic_guids
=
dict
(
s
.
split
(
'
=
'
)
for
s
in
dynamic_guids
)
    
uuid5_substitutions
(
dynamic_guids
)
    
dynamic_guids_bytes
=
{
        
k
.
encode
(
'
utf
-
8
'
)
:
v
.
encode
(
'
utf
-
8
'
)
        
for
k
v
in
dynamic_guids
.
items
(
)
    
}
    
if
source_exists
:
      
overwrite_guids
(
*
(
os
.
path
.
join
(
outdir
file
)
if
file
else
None
                        
for
file
in
[
h
iid
proxy
tlb
]
)
                      
dynamic_guids
=
dynamic_guids_bytes
)
  
else
:
    
dynamic_guids
=
None
  
if
sys
.
platform
!
=
'
win32
'
:
    
return
0
  
idl_template
=
None
  
if
dynamic_guids
:
    
idl_template
=
idl
    
idl
=
posixpath
.
join
(
        
outdir
        
os
.
path
.
splitext
(
os
.
path
.
basename
(
idl_template
)
)
[
0
]
+
'
.
idl
'
)
    
generate_idl_from_template
(
idl_template
dynamic_guids_bytes
idl
)
  
env_pairs
=
open
(
arch
)
.
read
(
)
[
:
-
2
]
.
split
(
'
\
0
'
)
  
env_dict
=
dict
(
[
item
.
split
(
'
=
'
1
)
for
item
in
env_pairs
]
)
  
preprocessor_options
=
'
-
E
-
nologo
-
Wno
-
nonportable
-
include
-
path
'
  
preprocessor_options
+
=
'
'
.
join
(
      
[
'
'
+
flag
for
flag
in
flags
if
flag
.
startswith
(
'
/
D
'
)
]
)
  
args
=
[
'
midl
'
'
/
nologo
'
]
+
list
(
flags
)
+
(
[
'
/
tlb
'
tlb
]
if
tlb
else
[
]
)
+
[
      
'
/
h
'
h
  
]
+
(
[
'
/
dlldata
'
dlldata
]
if
dlldata
else
[
]
)
+
[
'
/
iid
'
iid
]
+
(
      
[
'
/
proxy
'
proxy
]
if
proxy
else
      
[
]
)
+
[
'
/
cpp_cmd
'
clang
'
/
cpp_opt
'
preprocessor_options
idl
]
  
returncode
midl_output_dir
=
run_midl
(
args
env_dict
)
  
if
returncode
!
=
0
:
    
return
returncode
  
_
mismatch
errors
=
filecmp
.
cmpfiles
(
midl_output_dir
outdir
common_files
)
  
assert
not
errors
  
if
mismatch
:
    
print
(
'
midl
.
exe
output
different
from
files
in
%
s
see
%
s
'
%
          
(
outdir
midl_output_dir
)
)
    
for
f
in
mismatch
:
      
if
f
.
endswith
(
'
.
tlb
'
)
:
continue
      
fromfile
=
os
.
path
.
join
(
outdir
f
)
      
tofile
=
os
.
path
.
join
(
midl_output_dir
f
)
      
print
(
'
'
.
join
(
          
difflib
.
unified_diff
(
              
io
.
open
(
fromfile
)
.
readlines
(
)
              
io
.
open
(
tofile
)
.
readlines
(
)
fromfile
tofile
)
)
)
    
if
dynamic_guids
:
      
generate_idl_from_template
(
idl_template
None
idl
)
      
returncode
midl_output_dir
=
run_midl
(
args
env_dict
)
      
if
returncode
!
=
0
:
        
return
returncode
    
print
(
'
To
rebaseline
:
'
)
    
print
(
r
'
copy
/
y
%
s
\
*
%
s
'
%
(
midl_output_dir
source
)
)
    
return
1
  
return
0
if
__name__
=
=
'
__main__
'
:
  
sys
.
exit
(
main
(
*
sys
.
argv
[
1
:
]
)
)
