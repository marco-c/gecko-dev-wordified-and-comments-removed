"
"
"
Utility
functions
for
Windows
builds
.
This
file
is
copied
to
the
build
directory
as
part
of
toolchain
setup
and
is
used
to
set
up
calls
to
tools
used
by
the
build
that
need
wrappers
.
"
"
"
from
__future__
import
print_function
import
os
import
re
import
shutil
import
subprocess
import
stat
import
sys
BASE_DIR
=
os
.
path
.
dirname
(
os
.
path
.
abspath
(
__file__
)
)
_LINK_EXE_OUT_ARG
=
re
.
compile
(
'
/
OUT
:
(
?
P
<
out
>
.
+
)
'
re
.
IGNORECASE
)
def
main
(
args
)
:
  
exit_code
=
WinTool
(
)
.
Dispatch
(
args
)
  
if
exit_code
is
not
None
:
    
sys
.
exit
(
exit_code
)
class
WinTool
(
object
)
:
  
"
"
"
This
class
performs
all
the
Windows
tooling
steps
.
The
methods
can
either
  
be
executed
directly
or
dispatched
from
an
argument
list
.
"
"
"
  
def
_UseSeparateMspdbsrv
(
self
env
args
)
:
    
"
"
"
Allows
to
use
a
unique
instance
of
mspdbsrv
.
exe
per
linker
instead
of
a
    
shared
one
.
"
"
"
    
if
len
(
args
)
<
1
:
      
raise
Exception
(
"
Not
enough
arguments
"
)
    
if
args
[
0
]
!
=
'
link
.
exe
'
:
      
return
    
endpoint_name
=
None
    
for
arg
in
args
:
      
m
=
_LINK_EXE_OUT_ARG
.
match
(
arg
)
      
if
m
:
        
endpoint_name
=
re
.
sub
(
r
'
\
W
+
'
'
'
            
'
%
s_
%
d
'
%
(
m
.
group
(
'
out
'
)
os
.
getpid
(
)
)
)
        
break
    
if
endpoint_name
is
None
:
      
return
    
env
[
'
_MSPDBSRV_ENDPOINT_
'
]
=
endpoint_name
  
def
Dispatch
(
self
args
)
:
    
"
"
"
Dispatches
a
string
command
to
a
method
.
"
"
"
    
if
len
(
args
)
<
1
:
      
raise
Exception
(
"
Not
enough
arguments
"
)
    
method
=
"
Exec
%
s
"
%
self
.
_CommandifyName
(
args
[
0
]
)
    
return
getattr
(
self
method
)
(
*
args
[
1
:
]
)
  
def
_CommandifyName
(
self
name_string
)
:
    
"
"
"
Transforms
a
tool
name
like
recursive
-
mirror
to
RecursiveMirror
.
"
"
"
    
return
name_string
.
title
(
)
.
replace
(
'
-
'
'
'
)
  
def
_GetEnv
(
self
arch
)
:
    
"
"
"
Gets
the
saved
environment
from
a
file
for
a
given
architecture
.
"
"
"
    
pairs
=
open
(
arch
)
.
read
(
)
[
:
-
2
]
.
split
(
'
\
0
'
)
    
kvs
=
[
item
.
split
(
'
=
'
1
)
for
item
in
pairs
]
    
return
dict
(
kvs
)
  
def
ExecDeleteFile
(
self
path
)
:
    
"
"
"
Simple
file
delete
command
.
"
"
"
    
if
os
.
path
.
exists
(
path
)
:
      
os
.
unlink
(
path
)
  
def
ExecRecursiveMirror
(
self
source
dest
)
:
    
"
"
"
Emulation
of
rm
-
rf
out
&
&
cp
-
af
in
out
.
"
"
"
    
if
os
.
path
.
exists
(
dest
)
:
      
if
os
.
path
.
isdir
(
dest
)
:
        
def
_on_error
(
fn
path
dummy_excinfo
)
:
          
if
not
os
.
access
(
path
os
.
W_OK
)
:
            
os
.
chmod
(
path
stat
.
S_IWRITE
)
          
fn
(
path
)
        
shutil
.
rmtree
(
dest
onerror
=
_on_error
)
      
else
:
        
if
not
os
.
access
(
dest
os
.
W_OK
)
:
          
os
.
chmod
(
dest
stat
.
S_IWRITE
)
        
os
.
unlink
(
dest
)
    
if
os
.
path
.
isdir
(
source
)
:
      
shutil
.
copytree
(
source
dest
)
    
else
:
      
shutil
.
copy2
(
source
dest
)
      
if
not
os
.
path
.
exists
(
dest
)
:
        
raise
Exception
(
"
Copying
of
%
s
to
%
s
failed
"
%
(
source
dest
)
)
  
def
ExecLinkWrapper
(
self
arch
use_separate_mspdbsrv
*
args
)
:
    
"
"
"
Filter
diagnostic
output
from
link
that
looks
like
:
    
'
Creating
library
ui
.
dll
.
lib
and
object
ui
.
dll
.
exp
'
    
This
happens
when
there
are
exports
from
the
dll
or
exe
.
    
"
"
"
    
env
=
self
.
_GetEnv
(
arch
)
    
if
use_separate_mspdbsrv
=
=
'
True
'
:
      
self
.
_UseSeparateMspdbsrv
(
env
args
)
    
if
sys
.
platform
=
=
'
win32
'
:
      
args
=
list
(
args
)
      
args
[
0
]
=
args
[
0
]
.
replace
(
'
/
'
'
\
\
'
)
    
pe_name
=
None
    
for
arg
in
args
:
      
m
=
_LINK_EXE_OUT_ARG
.
match
(
arg
)
      
if
m
:
        
pe_name
=
m
.
group
(
'
out
'
)
    
link
=
subprocess
.
Popen
(
args
shell
=
sys
.
platform
=
=
'
win32
'
env
=
env
                            
stdout
=
subprocess
.
PIPE
stderr
=
subprocess
.
STDOUT
)
    
for
line
in
link
.
stdout
:
      
line
=
line
.
decode
(
'
utf8
'
)
      
if
(
not
line
.
startswith
(
'
Creating
library
'
)
          
and
not
line
.
startswith
(
'
Generating
code
'
)
          
and
not
line
.
startswith
(
'
Finished
generating
code
'
)
)
:
        
print
(
line
.
rstrip
(
)
)
    
return
link
.
wait
(
)
  
def
ExecAsmWrapper
(
self
arch
*
args
)
:
    
"
"
"
Filter
logo
banner
from
invocations
of
asm
.
exe
.
"
"
"
    
env
=
self
.
_GetEnv
(
arch
)
    
if
sys
.
platform
=
=
'
win32
'
:
      
args
=
list
(
args
)
      
args
[
0
]
=
args
[
0
]
.
replace
(
'
/
'
'
\
\
'
)
    
popen
=
subprocess
.
Popen
(
args
shell
=
sys
.
platform
=
=
'
win32
'
env
=
env
                             
stdout
=
subprocess
.
PIPE
stderr
=
subprocess
.
STDOUT
)
    
out
_
=
popen
.
communicate
(
)
    
for
line
in
out
.
decode
(
'
utf8
'
)
.
splitlines
(
)
:
      
if
not
line
.
startswith
(
'
Assembling
:
'
)
:
        
print
(
line
)
    
return
popen
.
returncode
  
def
ExecRcWrapper
(
self
arch
*
args
)
:
    
"
"
"
Converts
.
rc
files
to
.
res
files
.
"
"
"
    
env
=
self
.
_GetEnv
(
arch
)
    
args
=
list
(
args
)
    
rcpy_args
=
args
[
:
]
    
rcpy_args
[
0
:
1
]
=
[
sys
.
executable
os
.
path
.
join
(
BASE_DIR
'
rc
'
'
rc
.
py
'
)
]
    
rcpy_args
.
append
(
'
/
showIncludes
'
)
    
return
subprocess
.
call
(
rcpy_args
env
=
env
)
  
def
ExecActionWrapper
(
self
arch
rspfile
*
dirname
)
:
    
"
"
"
Runs
an
action
command
line
from
a
response
file
using
the
environment
    
for
|
arch
|
.
If
|
dirname
|
is
supplied
use
that
as
the
working
directory
.
"
"
"
    
env
=
self
.
_GetEnv
(
arch
)
    
for
k
v
in
os
.
environ
.
items
(
)
:
      
if
k
not
in
env
:
        
env
[
k
]
=
v
    
args
=
open
(
rspfile
)
.
read
(
)
    
dirname
=
dirname
[
0
]
if
dirname
else
None
    
return
subprocess
.
call
(
args
shell
=
True
env
=
env
cwd
=
dirname
)
if
__name__
=
=
'
__main__
'
:
  
sys
.
exit
(
main
(
sys
.
argv
[
1
:
]
)
)
