"
"
"
usage
:
rc
.
py
[
options
]
input
.
res
A
resource
compiler
for
.
rc
files
.
options
:
-
h
-
-
help
Print
this
message
.
-
I
<
dir
>
Add
include
path
used
for
both
headers
and
resources
.
-
imsvc
<
dir
>
Add
system
include
path
used
for
preprocessing
only
.
/
winsysroot
<
d
>
Set
winsysroot
used
for
preprocessing
only
.
-
D
<
sym
>
Define
a
macro
for
the
preprocessor
.
/
fo
<
out
>
Set
path
of
output
.
res
file
.
/
nologo
Ignored
(
rc
.
py
doesn
'
t
print
a
logo
by
default
)
.
/
showIncludes
Print
referenced
header
and
resource
files
.
"
"
"
from
__future__
import
print_function
from
collections
import
namedtuple
import
codecs
import
os
import
re
import
subprocess
import
sys
import
tempfile
THIS_DIR
=
os
.
path
.
abspath
(
os
.
path
.
dirname
(
__file__
)
)
SRC_DIR
=
\
    
os
.
path
.
dirname
(
os
.
path
.
dirname
(
os
.
path
.
dirname
(
os
.
path
.
dirname
(
THIS_DIR
)
)
)
)
def
ParseFlags
(
)
:
  
"
"
"
Parses
flags
off
sys
.
argv
and
returns
the
parsed
flags
.
"
"
"
  
includes
=
[
]
  
imsvcs
=
[
]
  
winsysroot
=
[
]
  
defines
=
[
]
  
output
=
None
  
input
=
None
  
show_includes
=
False
  
for
flag
in
sys
.
argv
[
1
:
]
:
    
if
flag
=
=
'
-
h
'
or
flag
=
=
'
-
-
help
'
:
      
print
(
__doc__
)
      
sys
.
exit
(
0
)
    
if
flag
.
startswith
(
'
-
I
'
)
:
      
includes
.
append
(
flag
)
    
elif
flag
.
startswith
(
'
-
imsvc
'
)
:
      
imsvcs
.
append
(
flag
)
    
elif
flag
.
startswith
(
'
/
winsysroot
'
)
:
      
winsysroot
=
[
flag
]
    
elif
flag
.
startswith
(
'
-
D
'
)
:
      
defines
.
append
(
flag
)
    
elif
flag
.
startswith
(
'
/
fo
'
)
:
      
if
output
:
        
print
(
'
rc
.
py
:
error
:
multiple
/
fo
flags
'
'
/
fo
'
+
output
flag
              
file
=
sys
.
stderr
)
        
sys
.
exit
(
1
)
      
output
=
flag
[
3
:
]
    
elif
flag
=
=
'
/
nologo
'
:
      
pass
    
elif
flag
=
=
'
/
showIncludes
'
:
      
show_includes
=
True
    
elif
(
flag
.
startswith
(
'
-
'
)
or
          
(
flag
.
startswith
(
'
/
'
)
and
not
os
.
path
.
exists
(
flag
)
)
)
:
      
print
(
'
rc
.
py
:
error
:
unknown
flag
'
flag
file
=
sys
.
stderr
)
      
print
(
__doc__
file
=
sys
.
stderr
)
      
sys
.
exit
(
1
)
    
else
:
      
if
input
:
        
print
(
'
rc
.
py
:
error
:
multiple
inputs
:
'
input
flag
file
=
sys
.
stderr
)
        
sys
.
exit
(
1
)
      
input
=
flag
  
if
not
input
:
    
print
(
'
rc
.
py
:
error
:
no
input
file
'
file
=
sys
.
stderr
)
    
sys
.
exit
(
1
)
  
if
not
output
:
    
output
=
os
.
path
.
splitext
(
input
)
[
0
]
+
'
.
res
'
  
Flags
=
namedtuple
(
'
Flags
'
[
      
'
includes
'
'
defines
'
'
output
'
'
imsvcs
'
'
winsysroot
'
'
input
'
      
'
show_includes
'
  
]
)
  
return
Flags
(
includes
=
includes
               
defines
=
defines
               
output
=
output
               
imsvcs
=
imsvcs
               
winsysroot
=
winsysroot
               
input
=
input
               
show_includes
=
show_includes
)
def
ReadInput
(
input
)
:
  
"
"
"
"
Reads
input
and
returns
it
.
For
UTF
-
16LEBOM
input
converts
to
UTF
-
8
.
"
"
"
  
is_utf8
=
False
  
try
:
    
with
open
(
input
'
rb
'
)
as
rc_file
:
      
rc_file_data
=
rc_file
.
read
(
)
      
if
rc_file_data
.
startswith
(
codecs
.
BOM_UTF16_LE
)
:
        
rc_file_data
=
rc_file_data
[
2
:
]
.
decode
(
'
utf
-
16le
'
)
.
encode
(
'
utf
-
8
'
)
        
is_utf8
=
True
  
except
IOError
:
    
print
(
'
rc
.
py
:
failed
to
open
'
input
file
=
sys
.
stderr
)
    
sys
.
exit
(
1
)
  
except
UnicodeDecodeError
:
    
print
(
'
rc
.
py
:
failed
to
decode
UTF
-
16
despite
BOM
'
input
file
=
sys
.
stderr
)
    
sys
.
exit
(
1
)
  
return
rc_file_data
is_utf8
def
Preprocess
(
rc_file_data
flags
)
:
  
"
"
"
Runs
the
input
file
through
the
preprocessor
.
"
"
"
  
clang
=
os
.
path
.
join
(
SRC_DIR
'
third_party
'
'
llvm
-
build
'
                       
'
Release
+
Asserts
'
'
bin
'
'
clang
-
cl
'
)
  
if
sys
.
platform
=
=
'
win32
'
:
    
clang
+
=
'
.
exe
'
  
temp_handle
temp_file
=
tempfile
.
mkstemp
(
suffix
=
'
.
i
'
)
  
os
.
close
(
temp_handle
)
  
clang_cmd
=
[
clang
'
/
P
'
'
/
DRC_INVOKED
'
'
/
TC
'
'
-
'
'
/
Fi
'
+
temp_file
]
  
if
flags
.
imsvcs
:
    
clang_cmd
+
=
[
'
/
X
'
]
  
if
os
.
path
.
dirname
(
flags
.
input
)
:
    
clang_cmd
.
append
(
'
-
I
'
+
os
.
path
.
dirname
(
flags
.
input
)
)
  
if
flags
.
show_includes
:
    
clang_cmd
.
append
(
'
/
showIncludes
'
)
  
clang_cmd
+
=
flags
.
imsvcs
+
flags
.
winsysroot
+
flags
.
includes
+
flags
.
defines
  
p
=
subprocess
.
Popen
(
clang_cmd
stdin
=
subprocess
.
PIPE
)
  
p
.
communicate
(
input
=
rc_file_data
)
  
if
p
.
returncode
!
=
0
:
    
sys
.
exit
(
p
.
returncode
)
  
preprocessed_output
=
open
(
temp_file
'
rb
'
)
.
read
(
)
  
os
.
remove
(
temp_file
)
  
return
preprocessed_output
def
RunRc
(
preprocessed_output
is_utf8
flags
)
:
  
if
sys
.
platform
.
startswith
(
'
linux
'
)
:
    
rc
=
os
.
path
.
join
(
THIS_DIR
'
linux64
'
'
rc
'
)
  
elif
sys
.
platform
=
=
'
darwin
'
:
    
rc
=
os
.
path
.
join
(
THIS_DIR
'
mac
'
'
rc
'
)
  
elif
sys
.
platform
=
=
'
win32
'
:
    
rc
=
os
.
path
.
join
(
THIS_DIR
'
win
'
'
rc
.
exe
'
)
  
else
:
    
print
(
'
rc
.
py
:
error
:
unsupported
platform
'
sys
.
platform
file
=
sys
.
stderr
)
    
sys
.
exit
(
1
)
  
rc_cmd
=
[
rc
]
  
if
os
.
path
.
dirname
(
flags
.
input
)
:
    
rc_cmd
.
append
(
'
/
cd
'
+
os
.
path
.
dirname
(
flags
.
input
)
)
  
rc_cmd
.
append
(
'
/
fo
'
+
flags
.
output
)
  
if
is_utf8
:
    
rc_cmd
.
append
(
'
/
utf
-
8
'
)
  
if
flags
.
show_includes
:
    
rc_cmd
.
append
(
'
/
showIncludes
'
)
  
rc_cmd
+
=
flags
.
includes
  
p
=
subprocess
.
Popen
(
rc_cmd
stdin
=
subprocess
.
PIPE
)
  
p
.
communicate
(
input
=
preprocessed_output
)
  
if
flags
.
show_includes
and
p
.
returncode
=
=
0
:
    
TOOL_DIR
=
os
.
path
.
dirname
(
os
.
path
.
relpath
(
THIS_DIR
)
)
.
replace
(
"
\
\
"
"
/
"
)
    
print
(
'
Note
:
including
file
:
{
}
/
tool_wrapper
.
py
'
.
format
(
TOOL_DIR
)
)
    
print
(
'
Note
:
including
file
:
{
}
/
rc
/
rc
.
py
'
.
format
(
TOOL_DIR
)
)
    
print
(
        
'
Note
:
including
file
:
{
}
/
rc
/
linux64
/
rc
.
sha1
'
.
format
(
TOOL_DIR
)
)
    
print
(
'
Note
:
including
file
:
{
}
/
rc
/
mac
/
rc
.
sha1
'
.
format
(
TOOL_DIR
)
)
    
print
(
        
'
Note
:
including
file
:
{
}
/
rc
/
win
/
rc
.
exe
.
sha1
'
.
format
(
TOOL_DIR
)
)
  
return
p
.
returncode
def
CompareToMsRcOutput
(
preprocessed_output
is_utf8
flags
)
:
  
msrc_in
=
flags
.
output
+
'
.
preprocessed
.
rc
'
  
preprocessed_output
=
re
.
sub
(
br
'
^
#
.
*
'
b
'
'
preprocessed_output
flags
=
re
.
M
)
  
if
is_utf8
:
    
preprocessed_output
=
preprocessed_output
.
decode
(
'
utf
-
8
'
)
.
encode
(
'
utf
-
16le
'
)
  
with
open
(
msrc_in
'
wb
'
)
as
f
:
    
f
.
write
(
preprocessed_output
)
  
msrc_out
=
flags
.
output
+
'
_ms_rc
'
  
msrc_cmd
=
[
'
rc
'
'
/
nologo
'
'
/
x
'
'
/
fo
'
+
msrc_out
]
  
if
os
.
path
.
dirname
(
flags
.
input
)
:
    
msrc_cmd
+
=
[
'
-
I
'
+
os
.
path
.
dirname
(
flags
.
input
)
]
  
msrc_cmd
+
=
flags
.
includes
  
msrc_cmd
+
=
[
msrc_in
]
  
rc_exe_exit_code
=
subprocess
.
call
(
msrc_cmd
)
  
if
rc_exe_exit_code
=
=
0
:
    
import
filecmp
    
assert
filecmp
.
cmp
(
msrc_out
flags
.
output
)
  
return
rc_exe_exit_code
def
main
(
)
:
  
flags
=
ParseFlags
(
)
  
rc_file_data
is_utf8
=
ReadInput
(
flags
.
input
)
  
preprocessed_output
=
Preprocess
(
rc_file_data
flags
)
  
rc_exe_exit_code
=
RunRc
(
preprocessed_output
is_utf8
flags
)
  
if
sys
.
platform
=
=
'
win32
'
and
rc_exe_exit_code
=
=
0
:
    
rc_exe_exit_code
=
CompareToMsRcOutput
(
preprocessed_output
is_utf8
flags
)
  
return
rc_exe_exit_code
if
__name__
=
=
'
__main__
'
:
  
sys
.
exit
(
main
(
)
)
