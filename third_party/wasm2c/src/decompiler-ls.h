#
ifndef
WABT_DECOMPILER_LS_H_
#
define
WABT_DECOMPILER_LS_H_
#
include
"
src
/
decompiler
-
ast
.
h
"
#
include
<
map
>
namespace
wabt
{
inline
const
char
*
GetDecompTypeName
(
Type
t
)
{
switch
(
t
)
{
case
Type
:
:
I8
:
return
"
byte
"
;
case
Type
:
:
I8U
:
return
"
ubyte
"
;
case
Type
:
:
I16
:
return
"
short
"
;
case
Type
:
:
I16U
:
return
"
ushort
"
;
case
Type
:
:
I32
:
return
"
int
"
;
case
Type
:
:
I32U
:
return
"
uint
"
;
case
Type
:
:
I64
:
return
"
long
"
;
case
Type
:
:
F32
:
return
"
float
"
;
case
Type
:
:
F64
:
return
"
double
"
;
case
Type
:
:
V128
:
return
"
simd
"
;
case
Type
:
:
Func
:
return
"
func
"
;
case
Type
:
:
FuncRef
:
return
"
funcref
"
;
case
Type
:
:
ExternRef
:
return
"
externref
"
;
case
Type
:
:
Void
:
return
"
void
"
;
default
:
return
"
ILLEGAL
"
;
}
}
inline
Type
GetMemoryType
(
Type
operand_type
Opcode
opc
)
{
if
(
operand_type
=
=
Type
:
:
I32
|
|
operand_type
=
=
Type
:
:
I64
)
{
auto
name
=
string_view
(
opc
.
GetName
(
)
)
;
auto
is_unsigned
=
name
.
substr
(
name
.
size
(
)
-
2
)
=
=
"
_u
"
;
switch
(
opc
.
GetMemorySize
(
)
)
{
case
1
:
return
is_unsigned
?
Type
:
:
I8U
:
Type
:
:
I8
;
case
2
:
return
is_unsigned
?
Type
:
:
I16U
:
Type
:
:
I16
;
case
4
:
return
is_unsigned
?
Type
:
:
I32U
:
Type
:
:
I32
;
}
}
return
operand_type
;
}
struct
LoadStoreTracking
{
struct
LSAccess
{
Address
byte_size
=
0
;
Type
type
=
Type
:
:
Any
;
Address
align
=
0
;
uint32_t
idx
=
0
;
bool
is_uniform
=
true
;
}
;
struct
LSVar
{
std
:
:
map
<
uint64_t
LSAccess
>
accesses
;
bool
struct_layout
=
true
;
Type
same_type
=
Type
:
:
Any
;
Address
same_align
=
kInvalidAddress
;
Opcode
last_opc
;
}
;
void
Track
(
const
Node
&
n
)
{
for
(
auto
&
c
:
n
.
children
)
Track
(
c
)
;
switch
(
n
.
etype
)
{
case
ExprType
:
:
Load
:
{
auto
&
le
=
*
cast
<
LoadExpr
>
(
n
.
e
)
;
LoadStore
(
le
.
offset
le
.
opcode
le
.
opcode
.
GetResultType
(
)
le
.
align
n
.
children
[
0
]
)
;
break
;
}
case
ExprType
:
:
Store
:
{
auto
&
se
=
*
cast
<
StoreExpr
>
(
n
.
e
)
;
LoadStore
(
se
.
offset
se
.
opcode
se
.
opcode
.
GetParamType2
(
)
se
.
align
n
.
children
[
0
]
)
;
break
;
}
default
:
break
;
}
}
const
std
:
:
string
AddrExpName
(
const
Node
&
addr_exp
)
const
{
switch
(
addr_exp
.
etype
)
{
case
ExprType
:
:
LocalGet
:
return
cast
<
LocalGetExpr
>
(
addr_exp
.
e
)
-
>
var
.
name
(
)
;
break
;
case
ExprType
:
:
LocalTee
:
return
cast
<
LocalTeeExpr
>
(
addr_exp
.
e
)
-
>
var
.
name
(
)
;
break
;
default
:
return
"
"
;
}
}
void
LoadStore
(
uint64_t
offset
Opcode
opc
Type
type
Address
align
const
Node
&
addr_exp
)
{
auto
byte_size
=
opc
.
GetMemorySize
(
)
;
type
=
GetMemoryType
(
type
opc
)
;
auto
name
=
AddrExpName
(
addr_exp
)
;
if
(
name
.
empty
(
)
)
{
return
;
}
auto
&
var
=
vars
[
name
]
;
auto
&
access
=
var
.
accesses
[
offset
]
;
if
(
access
.
byte_size
&
&
(
(
access
.
byte_size
!
=
byte_size
)
|
|
(
access
.
type
!
=
type
)
|
|
(
access
.
align
!
=
align
)
)
)
access
.
is_uniform
=
false
;
if
(
!
opc
.
IsNaturallyAligned
(
align
)
)
access
.
is_uniform
=
false
;
access
.
byte_size
=
byte_size
;
access
.
type
=
type
;
access
.
align
=
align
;
if
(
(
var
.
same_type
=
=
type
|
|
var
.
same_type
=
=
Type
:
:
Any
)
&
&
(
var
.
same_align
=
=
align
|
|
var
.
same_align
=
=
kInvalidAddress
)
)
{
var
.
same_type
=
type
;
var
.
same_align
=
align
;
var
.
last_opc
=
opc
;
}
else
{
var
.
same_type
=
Type
:
:
Void
;
var
.
same_align
=
kInvalidAddress
;
}
}
void
CheckLayouts
(
)
{
for
(
auto
&
var
:
vars
)
{
if
(
var
.
second
.
accesses
.
size
(
)
=
=
1
)
{
var
.
second
.
struct_layout
=
false
;
continue
;
}
uint64_t
cur_offset
=
0
;
uint32_t
idx
=
0
;
for
(
auto
&
access
:
var
.
second
.
accesses
)
{
access
.
second
.
idx
=
idx
+
+
;
if
(
!
access
.
second
.
is_uniform
)
{
var
.
second
.
struct_layout
=
false
;
break
;
}
auto
mask
=
static_cast
<
uint64_t
>
(
access
.
second
.
byte_size
-
1
)
;
cur_offset
=
(
cur_offset
+
mask
)
&
~
mask
;
if
(
cur_offset
!
=
access
.
first
)
{
var
.
second
.
struct_layout
=
false
;
break
;
}
cur_offset
+
=
access
.
second
.
byte_size
;
}
}
}
std
:
:
string
IdxToName
(
uint32_t
idx
)
const
{
return
IndexToAlphaName
(
idx
)
;
}
std
:
:
string
GenAlign
(
Address
align
Opcode
opc
)
const
{
return
opc
.
IsNaturallyAligned
(
align
)
?
"
"
:
cat
(
"
"
std
:
:
to_string
(
align
)
)
;
}
std
:
:
string
GenTypeDecl
(
const
std
:
:
string
&
name
)
const
{
auto
it
=
vars
.
find
(
name
)
;
if
(
it
=
=
vars
.
end
(
)
)
{
return
"
"
;
}
if
(
it
-
>
second
.
struct_layout
)
{
std
:
:
string
s
=
"
{
"
;
for
(
auto
&
access
:
it
-
>
second
.
accesses
)
{
if
(
access
.
second
.
idx
)
s
+
=
"
"
;
s
+
=
IdxToName
(
access
.
second
.
idx
)
;
s
+
=
'
:
'
;
s
+
=
GetDecompTypeName
(
access
.
second
.
type
)
;
}
s
+
=
"
}
"
;
return
s
;
}
if
(
it
-
>
second
.
same_type
!
=
Type
:
:
Void
)
{
return
cat
(
GetDecompTypeName
(
it
-
>
second
.
same_type
)
"
_ptr
"
GenAlign
(
it
-
>
second
.
same_align
it
-
>
second
.
last_opc
)
)
;
}
return
"
"
;
}
std
:
:
string
GenAccess
(
uint64_t
offset
const
Node
&
addr_exp
)
const
{
auto
name
=
AddrExpName
(
addr_exp
)
;
if
(
name
.
empty
(
)
)
{
return
"
"
;
}
auto
it
=
vars
.
find
(
name
)
;
if
(
it
=
=
vars
.
end
(
)
)
{
return
"
"
;
}
if
(
it
-
>
second
.
struct_layout
)
{
auto
ait
=
it
-
>
second
.
accesses
.
find
(
offset
)
;
assert
(
ait
!
=
it
-
>
second
.
accesses
.
end
(
)
)
;
return
IdxToName
(
ait
-
>
second
.
idx
)
;
}
if
(
it
-
>
second
.
same_type
!
=
Type
:
:
Void
)
{
return
"
*
"
;
}
return
"
"
;
}
void
Clear
(
)
{
vars
.
clear
(
)
;
}
std
:
:
map
<
std
:
:
string
LSVar
>
vars
;
}
;
}
#
endif
