#
ifndef
WABT_DECOMPILER_AST_H_
#
define
WABT_DECOMPILER_AST_H_
#
include
"
src
/
cast
.
h
"
#
include
"
src
/
generate
-
names
.
h
"
#
include
"
src
/
ir
.
h
"
#
include
"
src
/
ir
-
util
.
h
"
#
include
<
map
>
namespace
wabt
{
enum
class
NodeType
{
Uninitialized
FlushToVars
FlushedVar
Statements
EndReturn
Decl
DeclInit
Expr
}
;
struct
Node
{
NodeType
ntype
;
ExprType
etype
;
const
Expr
*
e
;
std
:
:
vector
<
Node
>
children
;
union
{
struct
{
Index
var_start
var_count
;
}
;
const
Var
*
var
;
LabelType
lt
;
}
u
;
Node
(
)
:
ntype
(
NodeType
:
:
Uninitialized
)
etype
(
ExprType
:
:
Nop
)
e
(
nullptr
)
{
}
Node
(
NodeType
ntype
ExprType
etype
const
Expr
*
e
const
Var
*
v
)
:
ntype
(
ntype
)
etype
(
etype
)
e
(
e
)
{
u
.
var
=
v
;
}
Node
(
const
Node
&
rhs
)
=
delete
;
Node
&
operator
=
(
const
Node
&
rhs
)
=
delete
;
Node
(
Node
&
&
rhs
)
{
*
this
=
std
:
:
move
(
rhs
)
;
}
Node
&
operator
=
(
Node
&
&
rhs
)
{
ntype
=
rhs
.
ntype
;
rhs
.
ntype
=
NodeType
:
:
Uninitialized
;
etype
=
rhs
.
etype
;
rhs
.
etype
=
ExprType
:
:
Nop
;
e
=
rhs
.
e
;
std
:
:
swap
(
children
rhs
.
children
)
;
u
=
rhs
.
u
;
return
*
this
;
}
}
;
struct
AST
{
AST
(
ModuleContext
&
mc
const
Func
*
f
)
:
mc
(
mc
)
f
(
f
)
{
if
(
f
)
{
mc
.
BeginFunc
(
*
f
)
;
for
(
Index
i
=
0
;
i
<
f
-
>
GetNumParams
(
)
;
i
+
+
)
{
auto
name
=
"
"
+
IndexToAlphaName
(
i
)
;
vars_defined
.
insert
(
{
name
{
0
false
}
}
)
;
}
}
}
~
AST
(
)
{
if
(
f
)
mc
.
EndFunc
(
)
;
}
Node
&
InsertNode
(
NodeType
ntype
ExprType
etype
const
Expr
*
e
Index
nargs
)
{
assert
(
exp_stack
.
size
(
)
>
=
nargs
)
;
Node
n
{
ntype
etype
e
nullptr
}
;
n
.
children
.
reserve
(
nargs
)
;
std
:
:
move
(
exp_stack
.
end
(
)
-
nargs
exp_stack
.
end
(
)
std
:
:
back_inserter
(
n
.
children
)
)
;
exp_stack
.
erase
(
exp_stack
.
end
(
)
-
nargs
exp_stack
.
end
(
)
)
;
exp_stack
.
push_back
(
std
:
:
move
(
n
)
)
;
return
exp_stack
.
back
(
)
;
}
template
<
ExprType
T
>
void
PreDecl
(
const
VarExpr
<
T
>
&
ve
)
{
for
(
auto
&
n
:
predecls
)
{
if
(
n
.
u
.
var
-
>
name
(
)
=
=
ve
.
var
.
name
(
)
)
{
return
;
}
}
predecls
.
emplace_back
(
NodeType
:
:
Decl
ExprType
:
:
Nop
nullptr
&
ve
.
var
)
;
}
template
<
ExprType
T
>
void
Get
(
const
VarExpr
<
T
>
&
ve
bool
local
)
{
if
(
local
)
{
auto
ret
=
vars_defined
.
insert
(
{
ve
.
var
.
name
(
)
{
cur_block_id
false
}
}
)
;
if
(
ret
.
second
)
{
PreDecl
(
ve
)
;
}
else
if
(
blocks_closed
[
ret
.
first
-
>
second
.
block_id
]
)
{
PreDecl
(
ve
)
;
}
}
InsertNode
(
NodeType
:
:
Expr
T
&
ve
0
)
;
}
template
<
ExprType
T
>
void
Set
(
const
VarExpr
<
T
>
&
ve
bool
local
)
{
if
(
local
&
&
vars_defined
.
insert
(
{
ve
.
var
.
name
(
)
{
cur_block_id
false
}
}
)
.
second
)
{
if
(
value_stack_depth
=
=
1
)
{
InsertNode
(
NodeType
:
:
DeclInit
ExprType
:
:
Nop
nullptr
1
)
.
u
.
var
=
&
ve
.
var
;
return
;
}
else
{
PreDecl
(
ve
)
;
}
}
InsertNode
(
NodeType
:
:
Expr
T
&
ve
1
)
;
}
template
<
ExprType
T
>
void
Block
(
const
BlockExprBase
<
T
>
&
be
LabelType
label
)
{
mc
.
BeginBlock
(
label
be
.
block
)
;
Construct
(
be
.
block
.
exprs
be
.
block
.
decl
.
GetNumResults
(
)
be
.
block
.
decl
.
GetNumParams
(
)
false
)
;
mc
.
EndBlock
(
)
;
InsertNode
(
NodeType
:
:
Expr
T
&
be
1
)
;
}
void
Construct
(
const
Expr
&
e
)
{
auto
arity
=
mc
.
GetExprArity
(
e
)
;
switch
(
e
.
type
(
)
)
{
case
ExprType
:
:
LocalGet
:
{
Get
(
*
cast
<
LocalGetExpr
>
(
&
e
)
true
)
;
return
;
}
case
ExprType
:
:
GlobalGet
:
{
Get
(
*
cast
<
GlobalGetExpr
>
(
&
e
)
false
)
;
return
;
}
case
ExprType
:
:
LocalSet
:
{
Set
(
*
cast
<
LocalSetExpr
>
(
&
e
)
true
)
;
return
;
}
case
ExprType
:
:
GlobalSet
:
{
Set
(
*
cast
<
GlobalSetExpr
>
(
&
e
)
false
)
;
return
;
}
case
ExprType
:
:
LocalTee
:
{
auto
&
lt
=
*
cast
<
LocalTeeExpr
>
(
&
e
)
;
Set
(
lt
true
)
;
if
(
value_stack_depth
=
=
1
)
{
Get
(
lt
true
)
;
}
else
{
}
return
;
}
case
ExprType
:
:
If
:
{
auto
ife
=
cast
<
IfExpr
>
(
&
e
)
;
value_stack_depth
-
-
;
mc
.
BeginBlock
(
LabelType
:
:
Block
ife
-
>
true_
)
;
Construct
(
ife
-
>
true_
.
exprs
ife
-
>
true_
.
decl
.
GetNumResults
(
)
ife
-
>
true_
.
decl
.
GetNumParams
(
)
false
)
;
if
(
!
ife
-
>
false_
.
empty
(
)
)
{
Construct
(
ife
-
>
false_
ife
-
>
true_
.
decl
.
GetNumResults
(
)
ife
-
>
true_
.
decl
.
GetNumParams
(
)
false
)
;
}
mc
.
EndBlock
(
)
;
value_stack_depth
+
+
;
InsertNode
(
NodeType
:
:
Expr
ExprType
:
:
If
&
e
ife
-
>
false_
.
empty
(
)
?
2
:
3
)
;
return
;
}
case
ExprType
:
:
Block
:
{
Block
(
*
cast
<
BlockExpr
>
(
&
e
)
LabelType
:
:
Block
)
;
return
;
}
case
ExprType
:
:
Loop
:
{
Block
(
*
cast
<
LoopExpr
>
(
&
e
)
LabelType
:
:
Loop
)
;
return
;
}
case
ExprType
:
:
Br
:
{
InsertNode
(
NodeType
:
:
Expr
ExprType
:
:
Br
&
e
0
)
.
u
.
lt
=
mc
.
GetLabel
(
cast
<
BrExpr
>
(
&
e
)
-
>
var
)
-
>
label_type
;
return
;
}
case
ExprType
:
:
BrIf
:
{
InsertNode
(
NodeType
:
:
Expr
ExprType
:
:
BrIf
&
e
1
)
.
u
.
lt
=
mc
.
GetLabel
(
cast
<
BrIfExpr
>
(
&
e
)
-
>
var
)
-
>
label_type
;
return
;
}
default
:
{
InsertNode
(
NodeType
:
:
Expr
e
.
type
(
)
&
e
arity
.
nargs
)
;
return
;
}
}
}
void
Construct
(
const
ExprList
&
es
Index
nresults
Index
nparams
bool
is_function_body
)
{
block_stack
.
push_back
(
cur_block_id
)
;
cur_block_id
=
blocks_closed
.
size
(
)
;
blocks_closed
.
push_back
(
false
)
;
auto
start
=
exp_stack
.
size
(
)
;
int
value_stack_depth_start
=
value_stack_depth
-
nparams
;
auto
value_stack_in_variables
=
value_stack_depth
;
bool
unreachable
=
false
;
for
(
auto
&
e
:
es
)
{
Construct
(
e
)
;
auto
arity
=
mc
.
GetExprArity
(
e
)
;
value_stack_depth
-
=
arity
.
nargs
;
value_stack_in_variables
=
std
:
:
min
(
value_stack_in_variables
value_stack_depth
)
;
unreachable
=
unreachable
|
|
arity
.
unreachable
;
assert
(
unreachable
|
|
value_stack_depth
>
=
value_stack_depth_start
)
;
value_stack_depth
+
=
arity
.
nreturns
;
if
(
arity
.
nreturns
!
=
1
)
{
auto
num_vars
=
value_stack_in_variables
-
value_stack_depth_start
;
auto
num_vals
=
value_stack_depth
-
value_stack_in_variables
;
auto
GenFlushVars
=
[
&
]
(
int
nargs
)
{
auto
&
ftv
=
InsertNode
(
NodeType
:
:
FlushToVars
ExprType
:
:
Nop
nullptr
nargs
)
;
ftv
.
u
.
var_start
=
flushed_vars
;
ftv
.
u
.
var_count
=
num_vals
;
}
;
auto
MoveStatementsBelowVars
=
[
&
]
(
size_t
amount
)
{
std
:
:
rotate
(
exp_stack
.
end
(
)
-
num_vars
-
amount
exp_stack
.
end
(
)
-
amount
exp_stack
.
end
(
)
)
;
}
;
auto
GenFlushedVars
=
[
&
]
(
)
{
for
(
int
i
=
0
;
i
<
num_vals
;
i
+
+
)
{
auto
&
fv
=
InsertNode
(
NodeType
:
:
FlushedVar
ExprType
:
:
Nop
nullptr
0
)
;
fv
.
u
.
var_start
=
flushed_vars
+
+
;
fv
.
u
.
var_count
=
1
;
}
}
;
if
(
arity
.
nreturns
=
=
0
&
&
value_stack_depth
>
value_stack_depth_start
)
{
if
(
num_vals
>
0
)
{
auto
void_exp
=
std
:
:
move
(
exp_stack
.
back
(
)
)
;
exp_stack
.
pop_back
(
)
;
GenFlushVars
(
num_vals
)
;
exp_stack
.
push_back
(
std
:
:
move
(
void_exp
)
)
;
MoveStatementsBelowVars
(
2
)
;
GenFlushedVars
(
)
;
}
else
{
std
:
:
rotate
(
exp_stack
.
end
(
)
-
num_vars
-
1
exp_stack
.
end
(
)
-
1
exp_stack
.
end
(
)
)
;
}
value_stack_in_variables
=
value_stack_depth
;
}
else
if
(
arity
.
nreturns
>
1
)
{
assert
(
num_vals
>
=
static_cast
<
int
>
(
arity
.
nreturns
)
)
;
GenFlushVars
(
num_vals
-
arity
.
nreturns
+
1
)
;
MoveStatementsBelowVars
(
1
)
;
GenFlushedVars
(
)
;
value_stack_in_variables
=
value_stack_depth
;
}
}
else
{
if
(
e
.
type
(
)
=
=
ExprType
:
:
Const
&
&
value_stack_in_variables
=
=
value_stack_depth
-
1
)
{
value_stack_in_variables
+
+
;
}
}
}
assert
(
unreachable
|
|
value_stack_depth
-
value_stack_depth_start
=
=
static_cast
<
int
>
(
nresults
)
)
;
value_stack_depth
=
value_stack_depth_start
;
auto
end
=
exp_stack
.
size
(
)
;
assert
(
end
>
=
start
)
;
if
(
is_function_body
)
{
if
(
!
exp_stack
.
empty
(
)
)
{
if
(
exp_stack
.
back
(
)
.
etype
=
=
ExprType
:
:
Return
)
{
if
(
exp_stack
.
back
(
)
.
children
.
empty
(
)
)
{
exp_stack
.
pop_back
(
)
;
}
}
else
if
(
nresults
)
{
InsertNode
(
NodeType
:
:
EndReturn
ExprType
:
:
Nop
nullptr
nresults
)
;
}
}
std
:
:
move
(
predecls
.
begin
(
)
predecls
.
end
(
)
std
:
:
back_inserter
(
exp_stack
)
)
;
std
:
:
rotate
(
exp_stack
.
begin
(
)
exp_stack
.
end
(
)
-
predecls
.
size
(
)
exp_stack
.
end
(
)
)
;
predecls
.
clear
(
)
;
}
end
=
exp_stack
.
size
(
)
;
assert
(
end
>
=
start
)
;
auto
size
=
end
-
start
;
if
(
size
!
=
1
)
{
InsertNode
(
NodeType
:
:
Statements
ExprType
:
:
Nop
nullptr
size
)
;
}
blocks_closed
[
cur_block_id
]
=
true
;
cur_block_id
=
block_stack
.
back
(
)
;
block_stack
.
pop_back
(
)
;
}
ModuleContext
&
mc
;
std
:
:
vector
<
Node
>
exp_stack
;
std
:
:
vector
<
Node
>
predecls
;
const
Func
*
f
;
int
value_stack_depth
=
0
;
struct
Variable
{
size_t
block_id
;
bool
defined
;
}
;
std
:
:
map
<
std
:
:
string
Variable
>
vars_defined
;
Index
flushed_vars
=
0
;
size_t
cur_block_id
=
0
;
std
:
:
vector
<
size_t
>
block_stack
;
std
:
:
vector
<
bool
>
blocks_closed
;
}
;
}
#
endif
