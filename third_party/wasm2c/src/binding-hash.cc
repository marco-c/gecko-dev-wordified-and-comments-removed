#
include
"
src
/
binding
-
hash
.
h
"
#
include
<
algorithm
>
#
include
<
vector
>
#
include
"
src
/
ir
.
h
"
namespace
wabt
{
void
BindingHash
:
:
FindDuplicates
(
DuplicateCallback
callback
)
const
{
if
(
size
(
)
>
0
)
{
ValueTypeVector
duplicates
;
CreateDuplicatesVector
(
&
duplicates
)
;
SortDuplicatesVectorByLocation
(
&
duplicates
)
;
CallCallbacks
(
duplicates
callback
)
;
}
}
Index
BindingHash
:
:
FindIndex
(
const
Var
&
var
)
const
{
if
(
var
.
is_name
(
)
)
{
return
FindIndex
(
var
.
name
(
)
)
;
}
return
var
.
index
(
)
;
}
void
BindingHash
:
:
CreateDuplicatesVector
(
ValueTypeVector
*
out_duplicates
)
const
{
auto
first
=
begin
(
)
;
bool
is_first
=
true
;
for
(
auto
iter
=
std
:
:
next
(
first
)
;
iter
!
=
end
(
)
;
+
+
iter
)
{
if
(
first
-
>
first
=
=
iter
-
>
first
)
{
if
(
is_first
)
{
out_duplicates
-
>
push_back
(
&
*
first
)
;
}
out_duplicates
-
>
push_back
(
&
*
iter
)
;
is_first
=
false
;
}
else
{
is_first
=
true
;
first
=
iter
;
}
}
}
void
BindingHash
:
:
SortDuplicatesVectorByLocation
(
ValueTypeVector
*
duplicates
)
const
{
std
:
:
sort
(
duplicates
-
>
begin
(
)
duplicates
-
>
end
(
)
[
]
(
const
value_type
*
lhs
const
value_type
*
rhs
)
-
>
bool
{
return
lhs
-
>
second
.
loc
.
line
<
rhs
-
>
second
.
loc
.
line
|
|
(
lhs
-
>
second
.
loc
.
line
=
=
rhs
-
>
second
.
loc
.
line
&
&
lhs
-
>
second
.
loc
.
first_column
<
rhs
-
>
second
.
loc
.
first_column
)
;
}
)
;
}
void
BindingHash
:
:
CallCallbacks
(
const
ValueTypeVector
&
duplicates
DuplicateCallback
callback
)
const
{
for
(
auto
iter
=
duplicates
.
begin
(
)
end
=
duplicates
.
end
(
)
;
iter
!
=
end
;
+
+
iter
)
{
auto
first
=
std
:
:
find_if
(
duplicates
.
begin
(
)
duplicates
.
end
(
)
[
iter
]
(
const
value_type
*
x
)
-
>
bool
{
return
x
-
>
first
=
=
(
*
iter
)
-
>
first
;
}
)
;
if
(
first
=
=
iter
)
{
continue
;
}
assert
(
first
!
=
duplicates
.
end
(
)
)
;
callback
(
*
*
first
*
*
iter
)
;
}
}
}
