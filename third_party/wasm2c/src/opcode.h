#
ifndef
WABT_OPCODE_H_
#
define
WABT_OPCODE_H_
#
include
<
vector
>
#
include
"
src
/
common
.
h
"
#
include
"
src
/
opcode
-
code
-
table
.
h
"
#
include
"
src
/
leb128
.
h
"
namespace
wabt
{
class
Features
;
struct
Opcode
{
enum
Enum
:
uint32_t
{
#
define
WABT_OPCODE
(
rtype
type1
type2
type3
mem_size
prefix
code
Name
\
text
decomp
)
\
Name
#
include
"
src
/
opcode
.
def
"
#
undef
WABT_OPCODE
Invalid
}
;
#
define
WABT_OPCODE
(
rtype
type1
type2
type3
mem_size
prefix
code
Name
\
text
decomp
)
\
static
Opcode
Name
#
#
_Opcode
;
#
include
"
src
/
opcode
.
def
"
#
undef
WABT_OPCODE
Opcode
(
)
=
default
;
Opcode
(
Enum
e
)
:
enum_
(
e
)
{
}
operator
Enum
(
)
const
{
return
enum_
;
}
static
Opcode
FromCode
(
uint32_t
)
;
static
Opcode
FromCode
(
uint8_t
prefix
uint32_t
code
)
;
bool
HasPrefix
(
)
const
{
return
GetInfo
(
)
.
prefix
!
=
0
;
}
uint8_t
GetPrefix
(
)
const
{
return
GetInfo
(
)
.
prefix
;
}
uint32_t
GetCode
(
)
const
{
return
GetInfo
(
)
.
code
;
}
size_t
GetLength
(
)
const
{
return
GetBytes
(
)
.
size
(
)
;
}
const
char
*
GetName
(
)
const
{
return
GetInfo
(
)
.
name
;
}
const
char
*
GetDecomp
(
)
const
{
return
*
GetInfo
(
)
.
decomp
?
GetInfo
(
)
.
decomp
:
GetInfo
(
)
.
name
;
}
Type
GetResultType
(
)
const
{
return
GetInfo
(
)
.
result_type
;
}
Type
GetParamType1
(
)
const
{
return
GetInfo
(
)
.
param_types
[
0
]
;
}
Type
GetParamType2
(
)
const
{
return
GetInfo
(
)
.
param_types
[
1
]
;
}
Type
GetParamType3
(
)
const
{
return
GetInfo
(
)
.
param_types
[
2
]
;
}
Type
GetParamType
(
int
n
)
const
{
return
GetInfo
(
)
.
param_types
[
n
-
1
]
;
}
Address
GetMemorySize
(
)
const
{
return
GetInfo
(
)
.
memory_size
;
}
Type
GetMemoryParam
(
Type
param
const
Limits
*
limits
bool
has_address_operands
)
{
return
limits
&
&
limits
-
>
is_64
&
&
has_address_operands
?
Type
(
Type
:
:
I64
)
:
param
;
}
std
:
:
vector
<
uint8_t
>
GetBytes
(
)
const
;
uint32_t
GetSimdLaneCount
(
)
const
;
bool
IsNaturallyAligned
(
Address
alignment
)
const
;
Address
GetAlignment
(
Address
alignment
)
const
;
static
bool
IsPrefixByte
(
uint8_t
byte
)
{
return
byte
=
=
kMathPrefix
|
|
byte
=
=
kThreadsPrefix
|
|
byte
=
=
kSimdPrefix
;
}
bool
IsEnabled
(
const
Features
&
features
)
const
;
bool
IsInvalid
(
)
const
{
return
enum_
>
=
Invalid
;
}
private
:
static
const
uint32_t
kMathPrefix
=
0xfc
;
static
const
uint32_t
kThreadsPrefix
=
0xfe
;
static
const
uint32_t
kSimdPrefix
=
0xfd
;
struct
Info
{
const
char
*
name
;
const
char
*
decomp
;
Type
result_type
;
Type
param_types
[
3
]
;
Address
memory_size
;
uint8_t
prefix
;
uint32_t
code
;
uint32_t
prefix_code
;
}
;
static
uint32_t
PrefixCode
(
uint8_t
prefix
uint32_t
code
)
{
if
(
code
>
=
0x100
)
{
code
=
0xff
;
}
return
(
prefix
<
<
8
)
|
code
;
}
static
Enum
EncodeInvalidOpcode
(
uint32_t
prefix_code
)
{
Enum
result
=
static_cast
<
Enum
>
(
~
prefix_code
+
1
)
;
assert
(
result
>
=
Invalid
)
;
return
result
;
}
static
void
DecodeInvalidOpcode
(
Enum
e
uint8_t
*
out_prefix
uint32_t
*
out_code
)
{
uint32_t
prefix_code
=
~
static_cast
<
uint32_t
>
(
e
)
+
1
;
*
out_prefix
=
prefix_code
>
>
8
;
*
out_code
=
prefix_code
&
0xff
;
}
Info
GetInfo
(
)
const
;
static
Info
infos_
[
]
;
Enum
enum_
;
}
;
inline
Opcode
Opcode
:
:
FromCode
(
uint32_t
code
)
{
return
FromCode
(
0
code
)
;
}
inline
Opcode
Opcode
:
:
FromCode
(
uint8_t
prefix
uint32_t
code
)
{
uint32_t
prefix_code
=
PrefixCode
(
prefix
code
)
;
if
(
WABT_LIKELY
(
prefix_code
<
WABT_ARRAY_SIZE
(
WabtOpcodeCodeTable
)
)
)
{
uint32_t
value
=
WabtOpcodeCodeTable
[
prefix_code
]
;
if
(
WABT_LIKELY
(
value
!
=
0
|
|
code
=
=
0
)
)
{
return
Opcode
(
static_cast
<
Enum
>
(
value
)
)
;
}
}
return
Opcode
(
EncodeInvalidOpcode
(
prefix_code
)
)
;
}
}
#
endif
