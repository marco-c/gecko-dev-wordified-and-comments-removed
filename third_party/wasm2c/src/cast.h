#
ifndef
WABT_CAST_H_
#
define
WABT_CAST_H_
#
include
<
memory
>
#
include
<
type_traits
>
#
include
"
src
/
common
.
h
"
namespace
wabt
{
template
<
typename
Derived
typename
Base
>
bool
isa
(
const
Base
*
base
)
{
WABT_STATIC_ASSERT
(
(
std
:
:
is_base_of
<
Base
Derived
>
:
:
value
)
)
;
return
Derived
:
:
classof
(
base
)
;
}
template
<
typename
Derived
typename
Base
>
const
Derived
*
cast
(
const
Base
*
base
)
{
assert
(
isa
<
Derived
>
(
base
)
)
;
return
static_cast
<
const
Derived
*
>
(
base
)
;
}
;
template
<
typename
Derived
typename
Base
>
Derived
*
cast
(
Base
*
base
)
{
assert
(
isa
<
Derived
>
(
base
)
)
;
return
static_cast
<
Derived
*
>
(
base
)
;
}
;
template
<
typename
Derived
typename
Base
>
const
Derived
*
dyn_cast
(
const
Base
*
base
)
{
return
isa
<
Derived
>
(
base
)
?
static_cast
<
const
Derived
*
>
(
base
)
:
nullptr
;
}
;
template
<
typename
Derived
typename
Base
>
Derived
*
dyn_cast
(
Base
*
base
)
{
return
isa
<
Derived
>
(
base
)
?
static_cast
<
Derived
*
>
(
base
)
:
nullptr
;
}
;
template
<
typename
Derived
typename
Base
>
std
:
:
unique_ptr
<
const
Derived
>
cast
(
std
:
:
unique_ptr
<
const
Base
>
&
&
base
)
{
assert
(
isa
<
Derived
>
(
base
.
get
(
)
)
)
;
return
std
:
:
unique_ptr
<
Derived
>
(
static_cast
<
const
Derived
*
>
(
base
.
release
(
)
)
)
;
}
;
template
<
typename
Derived
typename
Base
>
std
:
:
unique_ptr
<
Derived
>
cast
(
std
:
:
unique_ptr
<
Base
>
&
&
base
)
{
assert
(
isa
<
Derived
>
(
base
.
get
(
)
)
)
;
return
std
:
:
unique_ptr
<
Derived
>
(
static_cast
<
Derived
*
>
(
base
.
release
(
)
)
)
;
}
;
}
#
endif
