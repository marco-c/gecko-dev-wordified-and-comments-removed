#
ifndef
WABT_DECOMPILER_NAMING_H_
#
define
WABT_DECOMPILER_NAMING_H_
#
include
"
src
/
decompiler
-
ast
.
h
"
#
include
<
set
>
namespace
wabt
{
inline
void
RenameToIdentifier
(
std
:
:
string
&
name
Index
i
BindingHash
&
bh
const
std
:
:
set
<
string_view
>
*
filter
)
{
std
:
:
string
s
;
size_t
nesting
=
0
;
size_t
read
=
0
;
size_t
word_start
=
0
;
for
(
auto
c
:
name
)
{
read
+
+
;
if
(
c
=
=
'
(
'
)
{
nesting
+
+
;
}
if
(
c
=
=
'
)
'
)
{
nesting
-
-
;
}
if
(
nesting
)
{
continue
;
}
if
(
!
isalnum
(
static_cast
<
unsigned
char
>
(
c
)
)
)
{
c
=
'
_
'
;
}
if
(
c
=
=
'
_
'
)
{
if
(
s
.
empty
(
)
)
{
continue
;
}
if
(
s
.
back
(
)
=
=
'
_
'
)
{
continue
;
}
}
s
+
=
c
;
if
(
filter
&
&
(
c
=
=
'
_
'
|
|
read
=
=
name
.
size
(
)
)
)
{
auto
word_end
=
s
.
size
(
)
;
if
(
c
=
=
'
_
'
)
{
word_end
-
-
;
}
assert
(
word_end
>
word_start
)
;
auto
word
=
string_view
(
s
.
c_str
(
)
+
word_start
word_end
-
word_start
)
;
if
(
filter
-
>
find
(
word
)
!
=
filter
-
>
end
(
)
)
{
s
.
resize
(
word_start
)
;
}
word_start
=
s
.
size
(
)
;
}
}
if
(
!
s
.
empty
(
)
&
&
s
.
back
(
)
=
=
'
_
'
)
{
s
.
pop_back
(
)
;
}
const
size_t
max_identifier_length
=
100
;
if
(
s
.
size
(
)
>
max_identifier_length
)
{
s
.
resize
(
max_identifier_length
)
;
}
bh
.
erase
(
name
)
;
Index
disambiguator
=
0
;
auto
base_len
=
s
.
size
(
)
;
for
(
;
;
)
{
if
(
bh
.
count
(
s
)
=
=
0
)
{
break
;
}
disambiguator
+
+
;
s
.
resize
(
base_len
)
;
s
+
=
'
_
'
;
s
+
=
std
:
:
to_string
(
disambiguator
)
;
}
name
=
s
;
bh
.
emplace
(
s
Binding
(
i
)
)
;
}
template
<
typename
T
>
void
RenameToIdentifiers
(
std
:
:
vector
<
T
*
>
&
things
BindingHash
&
bh
const
std
:
:
set
<
string_view
>
*
filter
)
{
Index
i
=
0
;
for
(
auto
thing
:
things
)
{
RenameToIdentifier
(
thing
-
>
name
i
+
+
bh
filter
)
;
}
}
enum
{
min_content_identifier_size
=
7
max_content_identifier_size
=
30
}
;
void
RenameToContents
(
std
:
:
vector
<
DataSegment
*
>
&
segs
BindingHash
&
bh
)
{
std
:
:
string
s
;
for
(
auto
seg
:
segs
)
{
if
(
seg
-
>
name
.
substr
(
0
2
)
!
=
"
d_
"
)
{
continue
;
}
s
=
"
d_
"
;
for
(
auto
c
:
seg
-
>
data
)
{
if
(
isalnum
(
c
)
|
|
c
=
=
'
_
'
)
{
s
+
=
static_cast
<
char
>
(
c
)
;
}
if
(
s
.
size
(
)
>
=
max_content_identifier_size
)
{
break
;
}
}
if
(
s
.
size
(
)
<
min_content_identifier_size
)
{
continue
;
}
if
(
bh
.
count
(
s
)
!
=
0
)
{
continue
;
}
bh
.
erase
(
seg
-
>
name
)
;
seg
-
>
name
=
s
;
bh
.
emplace
(
s
Binding
(
static_cast
<
Index
>
(
&
seg
-
&
segs
[
0
]
)
)
)
;
}
}
void
RenameAll
(
Module
&
module
)
{
std
:
:
set
<
string_view
>
filter
=
{
{
"
const
"
}
{
"
std
"
}
{
"
allocator
"
}
{
"
char
"
}
{
"
basic
"
}
{
"
traits
"
}
{
"
wchar
"
}
{
"
t
"
}
{
"
void
"
}
{
"
int
"
}
{
"
unsigned
"
}
{
"
2
"
}
{
"
cxxabiv1
"
}
{
"
short
"
}
{
"
4096ul
"
}
}
;
RenameToIdentifiers
(
module
.
funcs
module
.
func_bindings
&
filter
)
;
RenameToIdentifiers
(
module
.
globals
module
.
global_bindings
nullptr
)
;
RenameToIdentifiers
(
module
.
tables
module
.
table_bindings
nullptr
)
;
RenameToIdentifiers
(
module
.
tags
module
.
tag_bindings
nullptr
)
;
RenameToIdentifiers
(
module
.
exports
module
.
export_bindings
nullptr
)
;
RenameToIdentifiers
(
module
.
types
module
.
type_bindings
nullptr
)
;
RenameToIdentifiers
(
module
.
memories
module
.
memory_bindings
nullptr
)
;
RenameToIdentifiers
(
module
.
data_segments
module
.
data_segment_bindings
nullptr
)
;
RenameToIdentifiers
(
module
.
elem_segments
module
.
elem_segment_bindings
nullptr
)
;
RenameToContents
(
module
.
data_segments
module
.
data_segment_bindings
)
;
}
}
#
endif
