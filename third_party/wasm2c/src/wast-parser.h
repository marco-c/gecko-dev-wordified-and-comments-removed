#
ifndef
WABT_WAST_PARSER_H_
#
define
WABT_WAST_PARSER_H_
#
include
<
array
>
#
include
"
src
/
circular
-
array
.
h
"
#
include
"
src
/
error
.
h
"
#
include
"
src
/
feature
.
h
"
#
include
"
src
/
intrusive
-
list
.
h
"
#
include
"
src
/
ir
.
h
"
#
include
"
src
/
wast
-
lexer
.
h
"
namespace
wabt
{
struct
WastParseOptions
{
WastParseOptions
(
const
Features
&
features
)
:
features
(
features
)
{
}
Features
features
;
bool
debug_parsing
=
false
;
}
;
typedef
std
:
:
array
<
TokenType
2
>
TokenTypePair
;
class
WastParser
{
public
:
WastParser
(
WastLexer
*
Errors
*
WastParseOptions
*
)
;
void
WABT_PRINTF_FORMAT
(
3
4
)
Error
(
Location
const
char
*
format
.
.
.
)
;
Result
ParseModule
(
std
:
:
unique_ptr
<
Module
>
*
out_module
)
;
Result
ParseScript
(
std
:
:
unique_ptr
<
Script
>
*
out_script
)
;
std
:
:
unique_ptr
<
Script
>
ReleaseScript
(
)
;
private
:
enum
class
ConstType
{
Normal
Expectation
}
;
void
ErrorUnlessOpcodeEnabled
(
const
Token
&
)
;
Result
ErrorExpected
(
const
std
:
:
vector
<
std
:
:
string
>
&
expected
const
char
*
example
=
nullptr
)
;
Result
ErrorIfLpar
(
const
std
:
:
vector
<
std
:
:
string
>
&
expected
const
char
*
example
=
nullptr
)
;
Token
GetToken
(
)
;
Location
GetLocation
(
)
;
TokenType
Peek
(
size_t
n
=
0
)
;
TokenTypePair
PeekPair
(
)
;
bool
PeekMatch
(
TokenType
)
;
bool
PeekMatchLpar
(
TokenType
)
;
bool
PeekMatchExpr
(
)
;
bool
Match
(
TokenType
)
;
bool
MatchLpar
(
TokenType
)
;
Result
Expect
(
TokenType
)
;
Token
Consume
(
)
;
void
ConsumeIfLpar
(
)
{
Match
(
TokenType
:
:
Lpar
)
;
}
typedef
bool
SynchronizeFunc
(
TokenTypePair
pair
)
;
Result
Synchronize
(
SynchronizeFunc
)
;
bool
ParseBindVarOpt
(
std
:
:
string
*
name
)
;
Result
ParseVar
(
Var
*
out_var
)
;
bool
ParseVarOpt
(
Var
*
out_var
Var
default_var
=
Var
(
)
)
;
Result
ParseOffsetExpr
(
ExprList
*
out_expr_list
)
;
bool
ParseOffsetExprOpt
(
ExprList
*
out_expr_list
)
;
Result
ParseTextList
(
std
:
:
vector
<
uint8_t
>
*
out_data
)
;
bool
ParseTextListOpt
(
std
:
:
vector
<
uint8_t
>
*
out_data
)
;
Result
ParseVarList
(
VarVector
*
out_var_list
)
;
bool
ParseElemExprOpt
(
ElemExpr
*
out_elem_expr
)
;
bool
ParseElemExprListOpt
(
ElemExprVector
*
out_list
)
;
bool
ParseElemExprVarListOpt
(
ElemExprVector
*
out_list
)
;
Result
ParseValueType
(
Type
*
out_type
)
;
Result
ParseValueTypeList
(
TypeVector
*
out_type_list
)
;
Result
ParseRefKind
(
Type
*
out_type
)
;
Result
ParseRefType
(
Type
*
out_type
)
;
bool
ParseRefTypeOpt
(
Type
*
out_type
)
;
Result
ParseQuotedText
(
std
:
:
string
*
text
)
;
bool
ParseOffsetOpt
(
Address
*
offset
)
;
bool
ParseAlignOpt
(
Address
*
align
)
;
Result
ParseLimitsIndex
(
Limits
*
)
;
Result
ParseLimits
(
Limits
*
)
;
Result
ParseNat
(
uint64_t
*
bool
is_64
)
;
Result
ParseModuleFieldList
(
Module
*
)
;
Result
ParseModuleField
(
Module
*
)
;
Result
ParseDataModuleField
(
Module
*
)
;
Result
ParseElemModuleField
(
Module
*
)
;
Result
ParseTagModuleField
(
Module
*
)
;
Result
ParseExportModuleField
(
Module
*
)
;
Result
ParseFuncModuleField
(
Module
*
)
;
Result
ParseTypeModuleField
(
Module
*
)
;
Result
ParseGlobalModuleField
(
Module
*
)
;
Result
ParseImportModuleField
(
Module
*
)
;
Result
ParseMemoryModuleField
(
Module
*
)
;
Result
ParseStartModuleField
(
Module
*
)
;
Result
ParseTableModuleField
(
Module
*
)
;
Result
ParseExportDesc
(
Export
*
)
;
Result
ParseInlineExports
(
ModuleFieldList
*
ExternalKind
)
;
Result
ParseInlineImport
(
Import
*
)
;
Result
ParseTypeUseOpt
(
FuncDeclaration
*
)
;
Result
ParseFuncSignature
(
FuncSignature
*
BindingHash
*
param_bindings
)
;
Result
ParseUnboundFuncSignature
(
FuncSignature
*
)
;
Result
ParseBoundValueTypeList
(
TokenType
TypeVector
*
BindingHash
*
Index
binding_index_offset
=
0
)
;
Result
ParseUnboundValueTypeList
(
TokenType
TypeVector
*
)
;
Result
ParseResultList
(
TypeVector
*
)
;
Result
ParseInstrList
(
ExprList
*
)
;
Result
ParseTerminatingInstrList
(
ExprList
*
)
;
Result
ParseInstr
(
ExprList
*
)
;
Result
ParsePlainInstr
(
std
:
:
unique_ptr
<
Expr
>
*
)
;
Result
ParseF32
(
Const
*
ConstType
type
)
;
Result
ParseF64
(
Const
*
ConstType
type
)
;
Result
ParseConst
(
Const
*
ConstType
type
)
;
Result
ParseExternref
(
Const
*
)
;
Result
ParseExpectedNan
(
ExpectedNan
*
expected
)
;
Result
ParseConstList
(
ConstVector
*
ConstType
type
)
;
Result
ParseBlockInstr
(
std
:
:
unique_ptr
<
Expr
>
*
)
;
Result
ParseLabelOpt
(
std
:
:
string
*
)
;
Result
ParseEndLabelOpt
(
const
std
:
:
string
&
)
;
Result
ParseBlockDeclaration
(
BlockDeclaration
*
)
;
Result
ParseBlock
(
Block
*
)
;
Result
ParseExprList
(
ExprList
*
)
;
Result
ParseExpr
(
ExprList
*
)
;
Result
ParseCatchInstrList
(
CatchVector
*
catches
)
;
Result
ParseCatchExprList
(
CatchVector
*
catches
)
;
Result
ParseGlobalType
(
Global
*
)
;
Result
ParseField
(
Field
*
)
;
Result
ParseFieldList
(
std
:
:
vector
<
Field
>
*
)
;
template
<
typename
T
>
Result
ParsePlainInstrVar
(
Location
std
:
:
unique_ptr
<
Expr
>
*
)
;
template
<
typename
T
>
Result
ParsePlainLoadStoreInstr
(
Location
Token
std
:
:
unique_ptr
<
Expr
>
*
)
;
Result
ParseSimdLane
(
Location
uint64_t
*
)
;
Result
ParseCommandList
(
Script
*
CommandPtrVector
*
)
;
Result
ParseCommand
(
Script
*
CommandPtr
*
)
;
Result
ParseAssertExhaustionCommand
(
CommandPtr
*
)
;
Result
ParseAssertInvalidCommand
(
CommandPtr
*
)
;
Result
ParseAssertMalformedCommand
(
CommandPtr
*
)
;
Result
ParseAssertReturnCommand
(
CommandPtr
*
)
;
Result
ParseAssertReturnFuncCommand
(
CommandPtr
*
)
;
Result
ParseAssertTrapCommand
(
CommandPtr
*
)
;
Result
ParseAssertUnlinkableCommand
(
CommandPtr
*
)
;
Result
ParseActionCommand
(
CommandPtr
*
)
;
Result
ParseModuleCommand
(
Script
*
CommandPtr
*
)
;
Result
ParseRegisterCommand
(
CommandPtr
*
)
;
Result
ParseInputCommand
(
CommandPtr
*
)
;
Result
ParseOutputCommand
(
CommandPtr
*
)
;
Result
ParseAction
(
ActionPtr
*
)
;
Result
ParseScriptModule
(
std
:
:
unique_ptr
<
ScriptModule
>
*
)
;
template
<
typename
T
>
Result
ParseActionCommand
(
TokenType
CommandPtr
*
)
;
template
<
typename
T
>
Result
ParseAssertActionCommand
(
TokenType
CommandPtr
*
)
;
template
<
typename
T
>
Result
ParseAssertActionTextCommand
(
TokenType
CommandPtr
*
)
;
template
<
typename
T
>
Result
ParseAssertScriptModuleCommand
(
TokenType
CommandPtr
*
)
;
Result
ParseSimdV128Const
(
Const
*
TokenType
ConstType
)
;
void
CheckImportOrdering
(
Module
*
)
;
WastLexer
*
lexer_
;
Index
last_module_index_
=
kInvalidIndex
;
Errors
*
errors_
;
WastParseOptions
*
options_
;
CircularArray
<
Token
2
>
tokens_
;
}
;
Result
ParseWatModule
(
WastLexer
*
lexer
std
:
:
unique_ptr
<
Module
>
*
out_module
Errors
*
WastParseOptions
*
options
)
;
Result
ParseWastScript
(
WastLexer
*
lexer
std
:
:
unique_ptr
<
Script
>
*
out_script
Errors
*
WastParseOptions
*
options
)
;
}
#
endif
