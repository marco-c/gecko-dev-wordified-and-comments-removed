#
ifndef
mozInlineSpellWordUtil_h
#
define
mozInlineSpellWordUtil_h
#
include
<
utility
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
class
nsRange
;
class
nsINode
;
namespace
mozilla
{
class
TextEditor
;
namespace
dom
{
class
Document
;
}
}
struct
NodeOffset
{
nsCOMPtr
<
nsINode
>
mNode
;
int32_t
mOffset
;
NodeOffset
(
)
:
mOffset
(
0
)
{
}
NodeOffset
(
nsINode
*
aNode
int32_t
aOffset
)
:
mNode
(
aNode
)
mOffset
(
aOffset
)
{
}
bool
operator
=
=
(
const
NodeOffset
&
aOther
)
const
{
return
mNode
=
=
aOther
.
mNode
&
&
mOffset
=
=
aOther
.
mOffset
;
}
bool
operator
!
=
(
const
NodeOffset
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
nsINode
*
Node
(
)
const
{
return
mNode
.
get
(
)
;
}
int32_t
Offset
(
)
const
{
return
mOffset
;
}
}
;
class
NodeOffsetRange
{
private
:
NodeOffset
mBegin
;
NodeOffset
mEnd
;
public
:
NodeOffsetRange
(
)
{
}
NodeOffsetRange
(
NodeOffset
b
NodeOffset
e
)
:
mBegin
(
std
:
:
move
(
b
)
)
mEnd
(
std
:
:
move
(
e
)
)
{
}
const
NodeOffset
&
Begin
(
)
const
{
return
mBegin
;
}
const
NodeOffset
&
End
(
)
const
{
return
mEnd
;
}
}
;
class
MOZ_STACK_CLASS
mozInlineSpellWordUtil
{
public
:
static
mozilla
:
:
Maybe
<
mozInlineSpellWordUtil
>
Create
(
const
mozilla
:
:
TextEditor
&
aTextEditor
)
;
nsresult
SetPositionAndEnd
(
nsINode
*
aPositionNode
int32_t
aPositionOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
;
nsresult
GetRangeForWord
(
nsINode
*
aWordNode
int32_t
aWordOffset
nsRange
*
*
aRange
)
;
nsresult
MakeRange
(
NodeOffset
aBegin
NodeOffset
aEnd
nsRange
*
*
aRange
)
const
;
static
already_AddRefed
<
nsRange
>
MakeRange
(
const
NodeOffsetRange
&
aRange
)
;
struct
Word
{
nsAutoString
mText
;
NodeOffsetRange
mNodeOffsetRange
;
bool
mSkipChecking
=
false
;
}
;
bool
GetNextWord
(
Word
&
aWord
)
;
static
void
NormalizeWord
(
nsAString
&
aWord
)
;
mozilla
:
:
dom
:
:
Document
*
GetDocument
(
)
const
{
return
mDocument
;
}
const
nsINode
*
GetRootNode
(
)
const
{
return
mRootNode
;
}
private
:
struct
DOMTextMapping
{
NodeOffset
mNodeOffset
;
int32_t
mSoftTextOffset
;
int32_t
mLength
;
DOMTextMapping
(
NodeOffset
aNodeOffset
int32_t
aSoftTextOffset
int32_t
aLength
)
:
mNodeOffset
(
std
:
:
move
(
aNodeOffset
)
)
mSoftTextOffset
(
aSoftTextOffset
)
mLength
(
aLength
)
{
}
}
;
struct
SoftText
{
void
AdjustBeginAndBuildText
(
NodeOffset
aBegin
NodeOffset
aEnd
const
nsINode
*
aRootNode
)
;
void
Invalidate
(
)
{
mIsValid
=
false
;
}
const
NodeOffset
&
GetBegin
(
)
const
{
return
mBegin
;
}
const
NodeOffset
&
GetEnd
(
)
const
{
return
mEnd
;
}
const
nsTArray
<
DOMTextMapping
>
&
GetDOMMapping
(
)
const
{
return
mDOMMapping
;
}
const
nsString
&
GetValue
(
)
const
{
return
mValue
;
}
bool
mIsValid
=
false
;
private
:
NodeOffset
mBegin
=
NodeOffset
(
nullptr
0
)
;
NodeOffset
mEnd
=
NodeOffset
(
nullptr
0
)
;
nsTArray
<
DOMTextMapping
>
mDOMMapping
;
nsString
mValue
;
}
;
SoftText
mSoftText
;
mozInlineSpellWordUtil
(
mozilla
:
:
dom
:
:
Document
&
aDocument
bool
aIsContentEditableOrDesignMode
nsINode
&
aRootNode
)
:
mDocument
(
&
aDocument
)
mIsContentEditableOrDesignMode
(
aIsContentEditableOrDesignMode
)
mRootNode
(
&
aRootNode
)
mNextWordIndex
(
-
1
)
{
}
const
RefPtr
<
mozilla
:
:
dom
:
:
Document
>
mDocument
;
const
bool
mIsContentEditableOrDesignMode
;
const
nsINode
*
mRootNode
;
struct
RealWord
{
int32_t
mSoftTextOffset
;
uint32_t
mLength
:
31
;
uint32_t
mCheckableWord
:
1
;
RealWord
(
int32_t
aOffset
uint32_t
aLength
bool
aCheckable
)
:
mSoftTextOffset
(
aOffset
)
mLength
(
aLength
)
mCheckableWord
(
aCheckable
)
{
static_assert
(
sizeof
(
RealWord
)
=
=
8
"
RealWord
should
be
limited
to
8
bytes
"
)
;
MOZ_ASSERT
(
aLength
<
INT32_MAX
"
Word
length
is
too
large
to
fit
in
the
bitfield
"
)
;
}
int32_t
EndOffset
(
)
const
{
return
mSoftTextOffset
+
mLength
;
}
}
;
using
RealWords
=
nsTArray
<
RealWord
>
;
RealWords
mRealWords
;
int32_t
mNextWordIndex
;
nsresult
EnsureWords
(
NodeOffset
aSoftBegin
NodeOffset
aSoftEnd
)
;
int32_t
MapDOMPositionToSoftTextOffset
(
const
NodeOffset
&
aNodeOffset
)
const
;
enum
DOMMapHint
{
HINT_BEGIN
HINT_END
}
;
NodeOffset
MapSoftTextOffsetToDOMPosition
(
int32_t
aSoftTextOffset
DOMMapHint
aHint
)
const
;
static
void
ToString
(
DOMMapHint
aHint
nsACString
&
aResult
)
;
int32_t
FindRealWordContaining
(
int32_t
aSoftTextOffset
DOMMapHint
aHint
bool
aSearchForward
)
const
;
mozilla
:
:
Result
<
RealWords
nsresult
>
BuildRealWords
(
)
const
;
nsresult
SplitDOMWordAndAppendTo
(
int32_t
aStart
int32_t
aEnd
nsTArray
<
RealWord
>
&
aRealWords
)
const
;
nsresult
MakeRangeForWord
(
const
RealWord
&
aWord
nsRange
*
*
aRange
)
const
;
void
MakeNodeOffsetRangeForWord
(
const
RealWord
&
aWord
NodeOffsetRange
*
aNodeOffsetRange
)
;
}
;
#
endif
