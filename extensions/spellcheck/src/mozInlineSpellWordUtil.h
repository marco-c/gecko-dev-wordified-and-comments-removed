#
ifndef
mozInlineSpellWordUtil_h
#
define
mozInlineSpellWordUtil_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
class
nsRange
;
class
nsINode
;
namespace
mozilla
{
class
TextEditor
;
namespace
dom
{
class
Document
;
}
}
struct
NodeOffset
{
nsCOMPtr
<
nsINode
>
mNode
;
int32_t
mOffset
;
NodeOffset
(
)
:
mOffset
(
0
)
{
}
NodeOffset
(
nsINode
*
aNode
int32_t
aOffset
)
:
mNode
(
aNode
)
mOffset
(
aOffset
)
{
}
bool
operator
=
=
(
const
NodeOffset
&
aOther
)
const
{
return
mNode
=
=
aOther
.
mNode
&
&
mOffset
=
=
aOther
.
mOffset
;
}
bool
operator
!
=
(
const
NodeOffset
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
nsINode
*
Node
(
)
const
{
return
mNode
.
get
(
)
;
}
int32_t
Offset
(
)
const
{
return
mOffset
;
}
}
;
class
NodeOffsetRange
{
private
:
NodeOffset
mBegin
;
NodeOffset
mEnd
;
public
:
NodeOffsetRange
(
)
{
}
NodeOffsetRange
(
NodeOffset
b
NodeOffset
e
)
:
mBegin
(
b
)
mEnd
(
e
)
{
}
NodeOffset
Begin
(
)
const
{
return
mBegin
;
}
NodeOffset
End
(
)
const
{
return
mEnd
;
}
}
;
class
MOZ_STACK_CLASS
mozInlineSpellWordUtil
{
public
:
mozInlineSpellWordUtil
(
)
:
mIsContentEditableOrDesignMode
(
false
)
mRootNode
(
nullptr
)
mSoftBegin
(
nullptr
0
)
mSoftEnd
(
nullptr
0
)
mNextWordIndex
(
-
1
)
mSoftTextValid
(
false
)
{
}
nsresult
Init
(
const
mozilla
:
:
TextEditor
&
aTextEditor
)
;
nsresult
SetPositionAndEnd
(
nsINode
*
aPositionNode
int32_t
aPositionOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
;
nsresult
GetRangeForWord
(
nsINode
*
aWordNode
int32_t
aWordOffset
nsRange
*
*
aRange
)
;
nsresult
MakeRange
(
NodeOffset
aBegin
NodeOffset
aEnd
nsRange
*
*
aRange
)
;
static
already_AddRefed
<
nsRange
>
MakeRange
(
const
NodeOffsetRange
&
aRange
)
;
bool
GetNextWord
(
nsAString
&
aText
NodeOffsetRange
*
aNodeOffsetRange
bool
*
aSkipChecking
)
;
static
void
NormalizeWord
(
nsAString
&
aWord
)
;
mozilla
:
:
dom
:
:
Document
*
GetDocument
(
)
const
{
return
mDocument
;
}
nsINode
*
GetRootNode
(
)
{
return
mRootNode
;
}
private
:
RefPtr
<
mozilla
:
:
dom
:
:
Document
>
mDocument
;
bool
mIsContentEditableOrDesignMode
;
nsINode
*
mRootNode
;
NodeOffset
mSoftBegin
;
NodeOffset
mSoftEnd
;
nsString
mSoftText
;
struct
DOMTextMapping
{
NodeOffset
mNodeOffset
;
int32_t
mSoftTextOffset
;
int32_t
mLength
;
DOMTextMapping
(
NodeOffset
aNodeOffset
int32_t
aSoftTextOffset
int32_t
aLength
)
:
mNodeOffset
(
aNodeOffset
)
mSoftTextOffset
(
aSoftTextOffset
)
mLength
(
aLength
)
{
}
}
;
nsTArray
<
DOMTextMapping
>
mSoftTextDOMMapping
;
struct
RealWord
{
int32_t
mSoftTextOffset
;
uint32_t
mLength
:
31
;
uint32_t
mCheckableWord
:
1
;
RealWord
(
int32_t
aOffset
uint32_t
aLength
bool
aCheckable
)
:
mSoftTextOffset
(
aOffset
)
mLength
(
aLength
)
mCheckableWord
(
aCheckable
)
{
static_assert
(
sizeof
(
RealWord
)
=
=
8
"
RealWord
should
be
limited
to
8
bytes
"
)
;
MOZ_ASSERT
(
aLength
<
INT32_MAX
"
Word
length
is
too
large
to
fit
in
the
bitfield
"
)
;
}
int32_t
EndOffset
(
)
const
{
return
mSoftTextOffset
+
mLength
;
}
}
;
nsTArray
<
RealWord
>
mRealWords
;
int32_t
mNextWordIndex
;
bool
mSoftTextValid
;
void
InvalidateWords
(
)
{
mSoftTextValid
=
false
;
}
nsresult
EnsureWords
(
)
;
int32_t
MapDOMPositionToSoftTextOffset
(
NodeOffset
aNodeOffset
)
;
enum
DOMMapHint
{
HINT_BEGIN
HINT_END
}
;
NodeOffset
MapSoftTextOffsetToDOMPosition
(
int32_t
aSoftTextOffset
DOMMapHint
aHint
)
;
static
void
ToString
(
DOMMapHint
aHint
nsACString
&
aResult
)
;
int32_t
FindRealWordContaining
(
int32_t
aSoftTextOffset
DOMMapHint
aHint
bool
aSearchForward
)
const
;
void
BuildSoftText
(
)
;
nsresult
BuildRealWords
(
)
;
nsresult
SplitDOMWord
(
int32_t
aStart
int32_t
aEnd
)
;
nsresult
MakeRangeForWord
(
const
RealWord
&
aWord
nsRange
*
*
aRange
)
;
void
MakeNodeOffsetRangeForWord
(
const
RealWord
&
aWord
NodeOffsetRange
*
aNodeOffsetRange
)
;
}
;
#
endif
