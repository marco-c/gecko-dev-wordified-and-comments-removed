#
include
"
mozInlineSpellWordUtil
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
dom
/
CharacterDataBuffer
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIFrame
.
h
"
using
namespace
mozilla
;
static
LazyLogModule
sInlineSpellWordUtilLog
{
"
InlineSpellWordUtil
"
}
;
inline
bool
IsIgnorableCharacter
(
char
ch
)
{
return
(
ch
=
=
static_cast
<
char
>
(
0xAD
)
)
;
}
inline
bool
IsIgnorableCharacter
(
char16_t
ch
)
{
return
(
ch
=
=
0xAD
|
|
ch
=
=
0x1806
)
;
}
inline
bool
IsConditionalPunctuation
(
char
ch
)
{
return
(
ch
=
=
'
\
'
'
|
|
ch
=
=
static_cast
<
char
>
(
0xB7
)
)
;
}
inline
bool
IsConditionalPunctuation
(
char16_t
ch
)
{
return
(
ch
=
=
'
\
'
'
|
|
ch
=
=
0x2019
|
|
ch
=
=
0x00B7
)
;
}
static
bool
IsAmbiguousDOMWordSeprator
(
char16_t
ch
)
{
return
(
ch
=
=
'
'
|
|
ch
=
=
'
:
'
|
|
ch
=
=
'
.
'
|
|
ch
=
=
'
/
'
|
|
ch
=
=
'
-
'
|
|
IsConditionalPunctuation
(
ch
)
)
;
}
static
bool
IsAmbiguousDOMWordSeprator
(
char
ch
)
{
return
IsAmbiguousDOMWordSeprator
(
static_cast
<
char16_t
>
(
ch
)
)
;
}
static
bool
IsDOMWordSeparator
(
char
ch
)
{
return
(
ch
=
=
'
'
|
|
ch
=
=
'
\
t
'
|
|
ch
=
=
'
\
n
'
|
|
ch
=
=
'
\
r
'
|
|
ch
=
=
static_cast
<
char
>
(
0xA0
)
)
;
}
static
bool
IsDOMWordSeparator
(
char16_t
ch
)
{
if
(
ch
=
=
'
'
|
|
ch
=
=
'
\
t
'
|
|
ch
=
=
'
\
n
'
|
|
ch
=
=
'
\
r
'
)
return
true
;
if
(
ch
>
=
0xA0
&
&
(
ch
=
=
0x00A0
|
|
ch
=
=
0x2002
|
|
ch
=
=
0x2003
|
|
ch
=
=
0x2009
|
|
ch
=
=
0x3000
)
)
return
true
;
return
false
;
}
bool
NodeOffset
:
:
operator
=
=
(
const
mozilla
:
:
RangeBoundary
&
aRangeBoundary
)
const
{
if
(
aRangeBoundary
.
GetContainer
(
)
!
=
mNode
)
{
return
false
;
}
const
Maybe
<
uint32_t
>
rangeBoundaryOffset
=
aRangeBoundary
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
;
MOZ_ASSERT
(
mOffset
>
=
0
)
;
return
rangeBoundaryOffset
&
&
(
*
rangeBoundaryOffset
=
=
static_cast
<
uint32_t
>
(
mOffset
)
)
;
}
bool
NodeOffsetRange
:
:
operator
=
=
(
const
nsRange
&
aRange
)
const
{
return
mBegin
=
=
aRange
.
StartRef
(
)
&
&
mEnd
=
=
aRange
.
EndRef
(
)
;
}
Maybe
<
mozInlineSpellWordUtil
>
mozInlineSpellWordUtil
:
:
Create
(
const
EditorBase
&
aEditorBase
)
{
dom
:
:
Document
*
document
=
aEditorBase
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
Nothing
(
)
;
}
const
bool
isContentEditableOrDesignMode
=
aEditorBase
.
IsHTMLEditor
(
)
;
nsINode
*
rootNode
=
aEditorBase
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootNode
)
)
{
return
Nothing
(
)
;
}
mozInlineSpellWordUtil
util
{
*
document
isContentEditableOrDesignMode
*
rootNode
}
;
return
Some
(
std
:
:
move
(
util
)
)
;
}
static
inline
bool
IsSpellCheckingTextNode
(
nsINode
*
aNode
)
{
nsIContent
*
parent
=
aNode
-
>
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
script
nsGkAtoms
:
:
style
)
)
return
false
;
return
aNode
-
>
IsText
(
)
;
}
typedef
void
(
*
OnLeaveNodeFunPtr
)
(
nsINode
*
aNode
void
*
aClosure
)
;
static
nsINode
*
FindNextNode
(
nsINode
*
aNode
const
nsINode
*
aRoot
OnLeaveNodeFunPtr
aOnLeaveNode
void
*
aClosure
)
{
MOZ_ASSERT
(
aNode
"
Null
starting
node
?
"
)
;
nsINode
*
next
=
aNode
-
>
GetFirstChild
(
)
;
if
(
next
)
return
next
;
if
(
aNode
=
=
aRoot
)
return
nullptr
;
next
=
aNode
-
>
GetNextSibling
(
)
;
if
(
next
)
return
next
;
for
(
;
;
)
{
if
(
aOnLeaveNode
)
{
aOnLeaveNode
(
aNode
aClosure
)
;
}
next
=
aNode
-
>
GetParent
(
)
;
if
(
next
=
=
aRoot
|
|
!
next
)
return
nullptr
;
aNode
=
next
;
next
=
aNode
-
>
GetNextSibling
(
)
;
if
(
next
)
return
next
;
}
}
static
nsINode
*
FindNextTextNode
(
nsINode
*
aNode
int32_t
aOffset
const
nsINode
*
aRoot
)
{
MOZ_ASSERT
(
aNode
"
Null
starting
node
?
"
)
;
MOZ_ASSERT
(
!
IsSpellCheckingTextNode
(
aNode
)
"
FindNextTextNode
should
start
with
a
non
-
text
node
"
)
;
nsINode
*
checkNode
;
nsIContent
*
child
=
aNode
-
>
GetChildAt_Deprecated
(
aOffset
)
;
if
(
child
)
{
checkNode
=
child
;
}
else
{
checkNode
=
aNode
-
>
GetNextNonChildNode
(
aRoot
)
;
}
while
(
checkNode
&
&
!
IsSpellCheckingTextNode
(
checkNode
)
)
{
checkNode
=
checkNode
-
>
GetNextNode
(
aRoot
)
;
}
return
checkNode
;
}
nsresult
mozInlineSpellWordUtil
:
:
SetPositionAndEnd
(
nsINode
*
aPositionNode
int32_t
aPositionOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
{
MOZ_LOG
(
sInlineSpellWordUtilLog
LogLevel
:
:
Debug
(
"
%
s
:
pos
=
(
%
p
%
i
)
end
=
(
%
p
%
i
)
"
__FUNCTION__
aPositionNode
aPositionOffset
aEndNode
aEndOffset
)
)
;
MOZ_ASSERT
(
aPositionNode
"
Null
begin
node
?
"
)
;
MOZ_ASSERT
(
aEndNode
"
Null
end
node
?
"
)
;
MOZ_ASSERT
(
mRootNode
"
Not
initialized
"
)
;
if
(
mIsContentEditableOrDesignMode
)
{
nsINode
*
rootNode
=
aPositionNode
-
>
SubtreeRoot
(
)
;
if
(
rootNode
!
=
aEndNode
-
>
SubtreeRoot
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mozilla
:
:
dom
:
:
ShadowRoot
:
:
FromNode
(
rootNode
)
)
{
mRootNode
=
rootNode
;
}
}
mSoftText
.
Invalidate
(
)
;
if
(
!
IsSpellCheckingTextNode
(
aPositionNode
)
)
{
aPositionNode
=
FindNextTextNode
(
aPositionNode
aPositionOffset
mRootNode
)
;
aPositionOffset
=
0
;
}
NodeOffset
softBegin
=
NodeOffset
(
aPositionNode
aPositionOffset
)
;
if
(
!
IsSpellCheckingTextNode
(
aEndNode
)
)
{
aEndNode
=
FindNextTextNode
(
aEndNode
aEndOffset
mRootNode
)
;
aEndOffset
=
0
;
}
NodeOffset
softEnd
=
NodeOffset
(
aEndNode
aEndOffset
)
;
nsresult
rv
=
EnsureWords
(
std
:
:
move
(
softBegin
)
std
:
:
move
(
softEnd
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
int32_t
textOffset
=
MapDOMPositionToSoftTextOffset
(
mSoftText
.
GetBegin
(
)
)
;
if
(
textOffset
<
0
)
{
return
NS_OK
;
}
mNextWordIndex
=
FindRealWordContaining
(
textOffset
HINT_END
true
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellWordUtil
:
:
EnsureWords
(
NodeOffset
aSoftBegin
NodeOffset
aSoftEnd
)
{
if
(
mSoftText
.
mIsValid
)
return
NS_OK
;
mSoftText
.
AdjustBeginAndBuildText
(
std
:
:
move
(
aSoftBegin
)
std
:
:
move
(
aSoftEnd
)
mRootNode
)
;
mRealWords
.
Clear
(
)
;
Result
<
RealWords
nsresult
>
realWords
=
BuildRealWords
(
)
;
if
(
realWords
.
isErr
(
)
)
{
return
realWords
.
unwrapErr
(
)
;
}
mRealWords
=
realWords
.
unwrap
(
)
;
mSoftText
.
mIsValid
=
true
;
return
NS_OK
;
}
nsresult
mozInlineSpellWordUtil
:
:
MakeRangeForWord
(
const
RealWord
&
aWord
nsRange
*
*
aRange
)
const
{
NodeOffset
begin
=
MapSoftTextOffsetToDOMPosition
(
aWord
.
mSoftTextOffset
HINT_BEGIN
)
;
NodeOffset
end
=
MapSoftTextOffsetToDOMPosition
(
aWord
.
EndOffset
(
)
HINT_END
)
;
return
MakeRange
(
begin
end
aRange
)
;
}
void
mozInlineSpellWordUtil
:
:
MakeNodeOffsetRangeForWord
(
const
RealWord
&
aWord
NodeOffsetRange
*
aNodeOffsetRange
)
{
NodeOffset
begin
=
MapSoftTextOffsetToDOMPosition
(
aWord
.
mSoftTextOffset
HINT_BEGIN
)
;
NodeOffset
end
=
MapSoftTextOffsetToDOMPosition
(
aWord
.
EndOffset
(
)
HINT_END
)
;
*
aNodeOffsetRange
=
NodeOffsetRange
(
begin
end
)
;
}
nsresult
mozInlineSpellWordUtil
:
:
GetRangeForWord
(
nsINode
*
aWordNode
int32_t
aWordOffset
nsRange
*
*
aRange
)
{
NodeOffset
pt
(
aWordNode
aWordOffset
)
;
if
(
!
mSoftText
.
mIsValid
|
|
pt
!
=
mSoftText
.
GetBegin
(
)
|
|
pt
!
=
mSoftText
.
GetEnd
(
)
)
{
mSoftText
.
Invalidate
(
)
;
NodeOffset
softBegin
=
pt
;
NodeOffset
softEnd
=
pt
;
nsresult
rv
=
EnsureWords
(
std
:
:
move
(
softBegin
)
std
:
:
move
(
softEnd
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
int32_t
offset
=
MapDOMPositionToSoftTextOffset
(
pt
)
;
if
(
offset
<
0
)
return
MakeRange
(
pt
pt
aRange
)
;
int32_t
wordIndex
=
FindRealWordContaining
(
offset
HINT_BEGIN
false
)
;
if
(
wordIndex
<
0
)
return
MakeRange
(
pt
pt
aRange
)
;
return
MakeRangeForWord
(
mRealWords
[
wordIndex
]
aRange
)
;
}
static
void
NormalizeWord
(
const
nsAString
&
aInput
int32_t
aPos
int32_t
aLen
nsAString
&
aOutput
)
{
aOutput
.
Truncate
(
)
;
for
(
int32_t
i
=
0
;
i
<
aLen
;
i
+
+
)
{
char16_t
ch
=
aInput
.
CharAt
(
i
+
aPos
)
;
if
(
IsIgnorableCharacter
(
ch
)
)
continue
;
if
(
ch
=
=
0x2019
)
{
ch
=
'
\
'
'
;
}
aOutput
.
Append
(
ch
)
;
}
}
bool
mozInlineSpellWordUtil
:
:
GetNextWord
(
Word
&
aWord
)
{
MOZ_LOG
(
sInlineSpellWordUtilLog
LogLevel
:
:
Debug
(
"
%
s
:
mNextWordIndex
=
%
d
"
__FUNCTION__
mNextWordIndex
)
)
;
if
(
mNextWordIndex
<
0
|
|
mNextWordIndex
>
=
int32_t
(
mRealWords
.
Length
(
)
)
)
{
mNextWordIndex
=
-
1
;
aWord
.
mSkipChecking
=
true
;
return
false
;
}
const
RealWord
&
realWord
=
mRealWords
[
mNextWordIndex
]
;
MakeNodeOffsetRangeForWord
(
realWord
&
aWord
.
mNodeOffsetRange
)
;
+
+
mNextWordIndex
;
aWord
.
mSkipChecking
=
!
realWord
.
mCheckableWord
;
:
:
NormalizeWord
(
mSoftText
.
GetValue
(
)
realWord
.
mSoftTextOffset
realWord
.
mLength
aWord
.
mText
)
;
MOZ_LOG
(
sInlineSpellWordUtilLog
LogLevel
:
:
Debug
(
"
%
s
:
returning
:
%
s
(
skip
=
%
d
)
"
__FUNCTION__
NS_ConvertUTF16toUTF8
(
aWord
.
mText
)
.
get
(
)
aWord
.
mSkipChecking
)
)
;
return
true
;
}
nsresult
mozInlineSpellWordUtil
:
:
MakeRange
(
NodeOffset
aBegin
NodeOffset
aEnd
nsRange
*
*
aRange
)
const
{
NS_ENSURE_ARG_POINTER
(
aBegin
.
mNode
)
;
if
(
!
mDocument
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aBegin
.
mNode
aBegin
.
mOffset
aEnd
.
mNode
aEnd
.
mOffset
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
MOZ_ASSERT
(
range
)
;
range
.
forget
(
aRange
)
;
return
NS_OK
;
}
already_AddRefed
<
nsRange
>
mozInlineSpellWordUtil
:
:
MakeRange
(
const
NodeOffsetRange
&
aRange
)
{
IgnoredErrorResult
ignoredError
;
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aRange
.
Begin
(
)
.
Node
(
)
aRange
.
Begin
(
)
.
Offset
(
)
aRange
.
End
(
)
.
Node
(
)
aRange
.
End
(
)
.
Offset
(
)
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Creating
a
range
failed
"
)
;
return
range
.
forget
(
)
;
}
enum
CharClass
{
CHAR_CLASS_WORD
CHAR_CLASS_SEPARATOR
CHAR_CLASS_END_OF_INPUT
}
;
template
<
class
T
>
struct
MOZ_STACK_CLASS
WordSplitState
{
const
T
&
mDOMWordText
;
int32_t
mDOMWordOffset
;
CharClass
mCurCharClass
;
explicit
WordSplitState
(
const
T
&
aString
)
:
mDOMWordText
(
aString
)
mDOMWordOffset
(
0
)
mCurCharClass
(
CHAR_CLASS_END_OF_INPUT
)
{
}
CharClass
ClassifyCharacter
(
int32_t
aIndex
bool
aRecurse
)
const
;
void
Advance
(
)
;
void
AdvanceThroughSeparators
(
)
;
void
AdvanceThroughWord
(
)
;
bool
IsSpecialWord
(
)
const
;
bool
ShouldSkipWord
(
int32_t
aStart
int32_t
aLength
)
const
;
Maybe
<
int32_t
>
FindOffsetOfLastDOMWordSeparatorSequence
(
int32_t
aBeforeOffset
)
const
;
char16_t
GetUnicharAt
(
int32_t
aIndex
)
const
;
}
;
template
<
class
T
>
CharClass
WordSplitState
<
T
>
:
:
ClassifyCharacter
(
int32_t
aIndex
bool
aRecurse
)
const
{
MOZ_ASSERT
(
aIndex
>
=
0
&
&
aIndex
<
=
int32_t
(
mDOMWordText
.
Length
(
)
)
"
Index
out
of
range
"
)
;
if
(
aIndex
=
=
int32_t
(
mDOMWordText
.
Length
(
)
)
)
return
CHAR_CLASS_SEPARATOR
;
nsUGenCategory
charCategory
=
mozilla
:
:
unicode
:
:
GetGenCategory
(
GetUnicharAt
(
aIndex
)
)
;
if
(
charCategory
=
=
nsUGenCategory
:
:
kLetter
|
|
IsIgnorableCharacter
(
mDOMWordText
[
aIndex
]
)
|
|
mDOMWordText
[
aIndex
]
=
=
0x200C
|
|
mDOMWordText
[
aIndex
]
=
=
0x200D
)
return
CHAR_CLASS_WORD
;
if
(
IsConditionalPunctuation
(
mDOMWordText
[
aIndex
]
)
)
{
if
(
!
aRecurse
)
{
return
CHAR_CLASS_SEPARATOR
;
}
if
(
aIndex
=
=
0
)
return
CHAR_CLASS_SEPARATOR
;
if
(
ClassifyCharacter
(
aIndex
-
1
false
)
!
=
CHAR_CLASS_WORD
)
return
CHAR_CLASS_SEPARATOR
;
if
(
mDOMWordText
[
aIndex
-
1
]
=
=
'
.
'
)
return
CHAR_CLASS_SEPARATOR
;
if
(
aIndex
=
=
int32_t
(
mDOMWordText
.
Length
(
)
-
1
)
)
{
return
CHAR_CLASS_SEPARATOR
;
}
if
(
ClassifyCharacter
(
aIndex
+
1
false
)
!
=
CHAR_CLASS_WORD
)
return
CHAR_CLASS_SEPARATOR
;
if
(
mDOMWordText
[
aIndex
+
1
]
=
=
'
.
'
)
return
CHAR_CLASS_SEPARATOR
;
return
CHAR_CLASS_WORD
;
}
if
(
aIndex
>
0
&
&
mDOMWordText
[
aIndex
]
=
=
'
.
'
&
&
mDOMWordText
[
aIndex
-
1
]
!
=
'
.
'
&
&
ClassifyCharacter
(
aIndex
-
1
false
)
!
=
CHAR_CLASS_WORD
)
{
return
CHAR_CLASS_WORD
;
}
if
(
charCategory
=
=
nsUGenCategory
:
:
kSeparator
|
|
charCategory
=
=
nsUGenCategory
:
:
kOther
|
|
charCategory
=
=
nsUGenCategory
:
:
kPunctuation
|
|
charCategory
=
=
nsUGenCategory
:
:
kSymbol
)
{
if
(
aIndex
>
0
&
&
mDOMWordText
[
aIndex
]
=
=
'
-
'
&
&
mDOMWordText
[
aIndex
-
1
]
!
=
'
-
'
&
&
ClassifyCharacter
(
aIndex
-
1
false
)
=
=
CHAR_CLASS_WORD
)
{
if
(
aIndex
=
=
int32_t
(
mDOMWordText
.
Length
(
)
)
-
1
)
return
CHAR_CLASS_SEPARATOR
;
if
(
mDOMWordText
[
aIndex
+
1
]
!
=
'
.
'
&
&
ClassifyCharacter
(
aIndex
+
1
false
)
=
=
CHAR_CLASS_WORD
)
return
CHAR_CLASS_WORD
;
}
return
CHAR_CLASS_SEPARATOR
;
}
return
CHAR_CLASS_WORD
;
}
template
<
class
T
>
void
WordSplitState
<
T
>
:
:
Advance
(
)
{
MOZ_ASSERT
(
mDOMWordOffset
>
=
0
"
Negative
word
index
"
)
;
MOZ_ASSERT
(
mDOMWordOffset
<
(
int32_t
)
mDOMWordText
.
Length
(
)
"
Length
beyond
end
"
)
;
mDOMWordOffset
+
+
;
if
(
mDOMWordOffset
>
=
(
int32_t
)
mDOMWordText
.
Length
(
)
)
mCurCharClass
=
CHAR_CLASS_END_OF_INPUT
;
else
mCurCharClass
=
ClassifyCharacter
(
mDOMWordOffset
true
)
;
}
template
<
class
T
>
void
WordSplitState
<
T
>
:
:
AdvanceThroughSeparators
(
)
{
while
(
mCurCharClass
=
=
CHAR_CLASS_SEPARATOR
)
Advance
(
)
;
}
template
<
class
T
>
void
WordSplitState
<
T
>
:
:
AdvanceThroughWord
(
)
{
while
(
mCurCharClass
=
=
CHAR_CLASS_WORD
)
Advance
(
)
;
}
template
<
class
T
>
bool
WordSplitState
<
T
>
:
:
IsSpecialWord
(
)
const
{
int32_t
firstColon
=
-
1
;
for
(
int32_t
i
=
mDOMWordOffset
;
i
<
int32_t
(
mDOMWordText
.
Length
(
)
)
;
i
+
+
)
{
if
(
mDOMWordText
[
i
]
=
=
'
'
)
{
if
(
i
>
0
&
&
ClassifyCharacter
(
i
-
1
false
)
=
=
CHAR_CLASS_WORD
&
&
i
<
(
int32_t
)
mDOMWordText
.
Length
(
)
-
1
&
&
ClassifyCharacter
(
i
+
1
false
)
=
=
CHAR_CLASS_WORD
)
{
return
true
;
}
}
else
if
(
mDOMWordText
[
i
]
=
=
'
:
'
&
&
firstColon
<
0
)
{
firstColon
=
i
;
if
(
firstColon
<
(
int32_t
)
mDOMWordText
.
Length
(
)
-
1
&
&
mDOMWordText
[
firstColon
+
1
]
=
=
'
/
'
)
{
return
true
;
}
}
}
if
(
firstColon
>
mDOMWordOffset
)
{
nsString
protocol
(
Substring
(
mDOMWordText
mDOMWordOffset
firstColon
-
mDOMWordOffset
)
)
;
if
(
protocol
.
EqualsIgnoreCase
(
"
http
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
https
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
news
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
file
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
javascript
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
data
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
ftp
"
)
)
{
return
true
;
}
}
return
false
;
}
template
<
class
T
>
bool
WordSplitState
<
T
>
:
:
ShouldSkipWord
(
int32_t
aStart
int32_t
aLength
)
const
{
int32_t
last
=
aStart
+
aLength
;
for
(
int32_t
i
=
aStart
;
i
<
last
;
i
+
+
)
{
if
(
mozilla
:
:
unicode
:
:
GetGenCategory
(
GetUnicharAt
(
i
)
)
=
=
nsUGenCategory
:
:
kNumber
)
{
return
true
;
}
}
return
false
;
}
template
<
class
T
>
Maybe
<
int32_t
>
WordSplitState
<
T
>
:
:
FindOffsetOfLastDOMWordSeparatorSequence
(
const
int32_t
aBeforeOffset
)
const
{
for
(
int32_t
i
=
aBeforeOffset
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
IsDOMWordSeparator
(
mDOMWordText
[
i
]
)
|
|
(
!
IsAmbiguousDOMWordSeprator
(
mDOMWordText
[
i
]
)
&
&
ClassifyCharacter
(
i
true
)
=
=
CHAR_CLASS_SEPARATOR
)
)
{
for
(
int32_t
j
=
i
-
1
;
j
>
=
0
;
-
-
j
)
{
if
(
IsDOMWordSeparator
(
mDOMWordText
[
j
]
)
|
|
(
!
IsAmbiguousDOMWordSeprator
(
mDOMWordText
[
j
]
)
&
&
ClassifyCharacter
(
j
true
)
=
=
CHAR_CLASS_SEPARATOR
)
)
{
i
=
j
;
}
else
{
break
;
}
}
return
Some
(
i
)
;
}
}
return
Nothing
(
)
;
}
template
<
>
char16_t
WordSplitState
<
nsDependentSubstring
>
:
:
GetUnicharAt
(
int32_t
aIndex
)
const
{
return
mDOMWordText
[
aIndex
]
;
}
template
<
>
char16_t
WordSplitState
<
nsDependentCSubstring
>
:
:
GetUnicharAt
(
int32_t
aIndex
)
const
{
return
static_cast
<
char16_t
>
(
static_cast
<
uint8_t
>
(
mDOMWordText
[
aIndex
]
)
)
;
}
static
inline
bool
IsBRElement
(
nsINode
*
aNode
)
{
return
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
;
}
static
Maybe
<
int32_t
>
FindOffsetOfLastDOMWordSeparatorSequence
(
nsIContent
*
aContent
int32_t
aBeforeOffset
)
{
const
dom
:
:
CharacterDataBuffer
*
textFragment
=
aContent
-
>
GetText
(
)
;
MOZ_ASSERT
(
textFragment
"
Where
is
our
text
?
"
)
;
int32_t
end
=
std
:
:
min
(
aBeforeOffset
int32_t
(
textFragment
-
>
GetLength
(
)
)
)
;
if
(
textFragment
-
>
Is2b
(
)
)
{
nsDependentSubstring
targetText
(
textFragment
-
>
Get2b
(
)
end
)
;
WordSplitState
<
nsDependentSubstring
>
state
(
targetText
)
;
return
state
.
FindOffsetOfLastDOMWordSeparatorSequence
(
end
)
;
}
nsDependentCSubstring
targetText
(
textFragment
-
>
Get1b
(
)
end
)
;
WordSplitState
<
nsDependentCSubstring
>
state
(
targetText
)
;
return
state
.
FindOffsetOfLastDOMWordSeparatorSequence
(
end
)
;
}
static
bool
ContainsDOMWordSeparator
(
nsINode
*
aNode
int32_t
aBeforeOffset
int32_t
*
aSeparatorOffset
)
{
if
(
IsBRElement
(
aNode
)
)
{
*
aSeparatorOffset
=
0
;
return
true
;
}
if
(
!
IsSpellCheckingTextNode
(
aNode
)
)
return
false
;
const
Maybe
<
int32_t
>
separatorOffset
=
FindOffsetOfLastDOMWordSeparatorSequence
(
aNode
-
>
AsContent
(
)
aBeforeOffset
)
;
if
(
separatorOffset
)
{
*
aSeparatorOffset
=
*
separatorOffset
;
return
true
;
}
return
false
;
}
static
bool
IsBreakElement
(
nsINode
*
aNode
)
{
if
(
!
aNode
-
>
IsElement
(
)
)
{
return
false
;
}
dom
:
:
Element
*
element
=
aNode
-
>
AsElement
(
)
;
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
true
;
}
nsIFrame
*
frame
=
element
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
false
;
}
auto
*
disp
=
frame
-
>
StyleDisplay
(
)
;
return
!
disp
-
>
IsInlineFlow
(
)
|
|
disp
-
>
IsListItem
(
)
;
}
struct
CheckLeavingBreakElementClosure
{
bool
mLeftBreakElement
;
}
;
static
void
CheckLeavingBreakElement
(
nsINode
*
aNode
void
*
aClosure
)
{
CheckLeavingBreakElementClosure
*
cl
=
static_cast
<
CheckLeavingBreakElementClosure
*
>
(
aClosure
)
;
if
(
!
cl
-
>
mLeftBreakElement
&
&
IsBreakElement
(
aNode
)
)
{
cl
-
>
mLeftBreakElement
=
true
;
}
}
void
mozInlineSpellWordUtil
:
:
NormalizeWord
(
nsAString
&
aWord
)
{
nsAutoString
result
;
:
:
NormalizeWord
(
aWord
0
aWord
.
Length
(
)
result
)
;
aWord
=
result
;
}
void
mozInlineSpellWordUtil
:
:
SoftText
:
:
AdjustBeginAndBuildText
(
NodeOffset
aBegin
NodeOffset
aEnd
const
nsINode
*
aRootNode
)
{
MOZ_LOG
(
sInlineSpellWordUtilLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
mBegin
=
std
:
:
move
(
aBegin
)
;
mEnd
=
std
:
:
move
(
aEnd
)
;
nsINode
*
node
=
mBegin
.
mNode
;
int32_t
firstOffsetInNode
=
0
;
int32_t
checkBeforeOffset
=
mBegin
.
mOffset
;
while
(
node
)
{
if
(
ContainsDOMWordSeparator
(
node
checkBeforeOffset
&
firstOffsetInNode
)
)
{
if
(
node
=
=
mBegin
.
mNode
)
{
if
(
firstOffsetInNode
>
0
)
{
int32_t
newOffset
=
0
;
if
(
!
ContainsDOMWordSeparator
(
node
firstOffsetInNode
-
1
&
newOffset
)
)
{
nsIContent
*
prevNode
=
node
-
>
GetPreviousSibling
(
)
;
while
(
prevNode
&
&
IsSpellCheckingTextNode
(
prevNode
)
)
{
mBegin
.
mNode
=
prevNode
;
const
Maybe
<
int32_t
>
separatorOffset
=
FindOffsetOfLastDOMWordSeparatorSequence
(
prevNode
INT32_MAX
)
;
if
(
separatorOffset
)
{
newOffset
=
*
separatorOffset
;
break
;
}
prevNode
=
prevNode
-
>
GetPreviousSibling
(
)
;
}
}
firstOffsetInNode
=
newOffset
;
}
else
{
firstOffsetInNode
=
0
;
}
MOZ_LOG
(
sInlineSpellWordUtilLog
LogLevel
:
:
Debug
(
"
%
s
:
adjusting
mBegin
.
mOffset
from
%
i
to
%
i
.
"
__FUNCTION__
mBegin
.
mOffset
firstOffsetInNode
)
)
;
mBegin
.
mOffset
=
firstOffsetInNode
;
}
break
;
}
checkBeforeOffset
=
INT32_MAX
;
if
(
IsBreakElement
(
node
)
)
{
break
;
}
if
(
!
node
-
>
IsInclusiveDescendantOf
(
aRootNode
)
)
{
break
;
}
node
=
node
-
>
GetPrevNode
(
aRootNode
)
;
}
mValue
.
Truncate
(
)
;
mDOMMapping
.
Clear
(
)
;
bool
seenSoftEnd
=
false
;
while
(
node
)
{
if
(
node
=
=
mEnd
.
mNode
)
{
seenSoftEnd
=
true
;
}
bool
exit
=
false
;
if
(
IsSpellCheckingTextNode
(
node
)
)
{
nsIContent
*
content
=
static_cast
<
nsIContent
*
>
(
node
)
;
MOZ_ASSERT
(
content
"
Where
is
our
content
?
"
)
;
const
dom
:
:
CharacterDataBuffer
*
textFragment
=
content
-
>
GetText
(
)
;
MOZ_ASSERT
(
textFragment
"
Where
is
our
text
?
"
)
;
uint32_t
lastOffsetInNode
=
textFragment
-
>
GetLength
(
)
;
if
(
seenSoftEnd
)
{
for
(
uint32_t
i
=
node
=
=
mEnd
.
mNode
?
AssertedCast
<
uint32_t
>
(
mEnd
.
mOffset
)
:
0
;
i
<
textFragment
-
>
GetLength
(
)
;
+
+
i
)
{
if
(
IsDOMWordSeparator
(
textFragment
-
>
CharAt
(
i
)
)
)
{
exit
=
true
;
lastOffsetInNode
=
i
;
break
;
}
}
}
if
(
firstOffsetInNode
>
=
0
&
&
static_cast
<
uint32_t
>
(
firstOffsetInNode
)
<
lastOffsetInNode
)
{
const
uint32_t
len
=
lastOffsetInNode
-
firstOffsetInNode
;
mDOMMapping
.
AppendElement
(
DOMTextMapping
(
NodeOffset
(
node
firstOffsetInNode
)
mValue
.
Length
(
)
len
)
)
;
const
bool
ok
=
textFragment
-
>
AppendTo
(
mValue
static_cast
<
uint32_t
>
(
firstOffsetInNode
)
len
mozilla
:
:
fallible
)
;
if
(
!
ok
)
{
mDOMMapping
.
RemoveLastElement
(
)
;
exit
=
true
;
}
}
firstOffsetInNode
=
0
;
}
if
(
exit
)
break
;
CheckLeavingBreakElementClosure
closure
=
{
false
}
;
node
=
FindNextNode
(
node
aRootNode
CheckLeavingBreakElement
&
closure
)
;
if
(
closure
.
mLeftBreakElement
|
|
(
node
&
&
IsBreakElement
(
node
)
)
)
{
if
(
seenSoftEnd
)
break
;
mValue
.
Append
(
'
'
)
;
}
}
MOZ_LOG
(
sInlineSpellWordUtilLog
LogLevel
:
:
Debug
(
"
%
s
:
got
DOM
string
:
%
s
"
__FUNCTION__
NS_ConvertUTF16toUTF8
(
mValue
)
.
get
(
)
)
)
;
}
auto
mozInlineSpellWordUtil
:
:
BuildRealWords
(
)
const
-
>
Result
<
RealWords
nsresult
>
{
int32_t
wordStart
=
-
1
;
RealWords
realWords
;
for
(
int32_t
i
=
0
;
i
<
int32_t
(
mSoftText
.
GetValue
(
)
.
Length
(
)
)
;
+
+
i
)
{
if
(
IsDOMWordSeparator
(
mSoftText
.
GetValue
(
)
.
CharAt
(
i
)
)
)
{
if
(
wordStart
>
=
0
)
{
nsresult
rv
=
SplitDOMWordAndAppendTo
(
wordStart
i
realWords
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
wordStart
=
-
1
;
}
}
else
{
if
(
wordStart
<
0
)
{
wordStart
=
i
;
}
}
}
if
(
wordStart
>
=
0
)
{
nsresult
rv
=
SplitDOMWordAndAppendTo
(
wordStart
mSoftText
.
GetValue
(
)
.
Length
(
)
realWords
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
}
return
realWords
;
}
int32_t
mozInlineSpellWordUtil
:
:
MapDOMPositionToSoftTextOffset
(
const
NodeOffset
&
aNodeOffset
)
const
{
if
(
!
mSoftText
.
mIsValid
)
{
NS_ERROR
(
"
Soft
text
must
be
valid
if
we
'
re
to
map
into
it
"
)
;
return
-
1
;
}
for
(
int32_t
i
=
0
;
i
<
int32_t
(
mSoftText
.
GetDOMMapping
(
)
.
Length
(
)
)
;
+
+
i
)
{
const
DOMTextMapping
&
map
=
mSoftText
.
GetDOMMapping
(
)
[
i
]
;
if
(
map
.
mNodeOffset
.
mNode
=
=
aNodeOffset
.
mNode
)
{
int32_t
offsetInContributedString
=
aNodeOffset
.
mOffset
-
map
.
mNodeOffset
.
mOffset
;
if
(
offsetInContributedString
>
=
0
&
&
offsetInContributedString
<
=
map
.
mLength
)
return
map
.
mSoftTextOffset
+
offsetInContributedString
;
return
-
1
;
}
}
return
-
1
;
}
namespace
{
template
<
class
T
>
class
FirstLargerOffset
{
int32_t
mSoftTextOffset
;
public
:
explicit
FirstLargerOffset
(
int32_t
aSoftTextOffset
)
:
mSoftTextOffset
(
aSoftTextOffset
)
{
}
int
operator
(
)
(
const
T
&
t
)
const
{
return
mSoftTextOffset
<
t
.
mSoftTextOffset
?
-
1
:
1
;
}
}
;
template
<
class
T
>
bool
FindLastNongreaterOffset
(
const
nsTArray
<
T
>
&
aContainer
int32_t
aSoftTextOffset
size_t
*
aIndex
)
{
if
(
aContainer
.
Length
(
)
=
=
0
)
{
return
false
;
}
BinarySearchIf
(
aContainer
0
aContainer
.
Length
(
)
FirstLargerOffset
<
T
>
(
aSoftTextOffset
)
aIndex
)
;
if
(
*
aIndex
>
0
)
{
*
aIndex
-
=
1
;
}
else
{
MOZ_ASSERT
(
aContainer
[
*
aIndex
]
.
mSoftTextOffset
>
aSoftTextOffset
)
;
}
return
true
;
}
}
NodeOffset
mozInlineSpellWordUtil
:
:
MapSoftTextOffsetToDOMPosition
(
int32_t
aSoftTextOffset
DOMMapHint
aHint
)
const
{
MOZ_ASSERT
(
mSoftText
.
mIsValid
"
Soft
text
must
be
valid
if
we
'
re
to
map
out
of
it
"
)
;
if
(
!
mSoftText
.
mIsValid
)
return
NodeOffset
(
nullptr
-
1
)
;
size_t
index
;
bool
found
=
FindLastNongreaterOffset
(
mSoftText
.
GetDOMMapping
(
)
aSoftTextOffset
&
index
)
;
if
(
!
found
)
{
return
NodeOffset
(
nullptr
-
1
)
;
}
if
(
aHint
=
=
HINT_END
&
&
index
>
0
)
{
const
DOMTextMapping
&
map
=
mSoftText
.
GetDOMMapping
(
)
[
index
-
1
]
;
if
(
map
.
mSoftTextOffset
+
map
.
mLength
=
=
aSoftTextOffset
)
return
NodeOffset
(
map
.
mNodeOffset
.
mNode
map
.
mNodeOffset
.
mOffset
+
map
.
mLength
)
;
}
const
DOMTextMapping
&
map
=
mSoftText
.
GetDOMMapping
(
)
[
index
]
;
int32_t
offset
=
aSoftTextOffset
-
map
.
mSoftTextOffset
;
if
(
offset
>
=
0
&
&
offset
<
=
map
.
mLength
)
return
NodeOffset
(
map
.
mNodeOffset
.
mNode
map
.
mNodeOffset
.
mOffset
+
offset
)
;
return
NodeOffset
(
nullptr
-
1
)
;
}
void
mozInlineSpellWordUtil
:
:
ToString
(
const
DOMMapHint
aHint
nsACString
&
aResult
)
{
switch
(
aHint
)
{
case
HINT_BEGIN
:
aResult
.
AssignLiteral
(
"
begin
"
)
;
break
;
case
HINT_END
:
aResult
.
AssignLiteral
(
"
end
"
)
;
break
;
}
}
int32_t
mozInlineSpellWordUtil
:
:
FindRealWordContaining
(
int32_t
aSoftTextOffset
DOMMapHint
aHint
bool
aSearchForward
)
const
{
if
(
MOZ_LOG_TEST
(
sInlineSpellWordUtilLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
hint
;
mozInlineSpellWordUtil
:
:
ToString
(
aHint
hint
)
;
MOZ_LOG
(
sInlineSpellWordUtilLog
LogLevel
:
:
Debug
(
"
%
s
:
offset
=
%
i
hint
=
%
s
searchForward
=
%
i
.
"
__FUNCTION__
aSoftTextOffset
hint
.
get
(
)
static_cast
<
int32_t
>
(
aSearchForward
)
)
)
;
}
MOZ_ASSERT
(
mSoftText
.
mIsValid
"
Soft
text
must
be
valid
if
we
'
re
to
map
out
of
it
"
)
;
if
(
!
mSoftText
.
mIsValid
)
return
-
1
;
size_t
index
;
bool
found
=
FindLastNongreaterOffset
(
mRealWords
aSoftTextOffset
&
index
)
;
if
(
!
found
)
{
return
-
1
;
}
if
(
aHint
=
=
HINT_END
&
&
index
>
0
)
{
const
RealWord
&
word
=
mRealWords
[
index
-
1
]
;
if
(
word
.
EndOffset
(
)
=
=
aSoftTextOffset
)
{
return
index
-
1
;
}
}
const
RealWord
&
word
=
mRealWords
[
index
]
;
int32_t
offset
=
aSoftTextOffset
-
word
.
mSoftTextOffset
;
if
(
offset
>
=
0
&
&
offset
<
=
static_cast
<
int32_t
>
(
word
.
mLength
)
)
return
index
;
if
(
aSearchForward
)
{
if
(
mRealWords
[
0
]
.
mSoftTextOffset
>
aSoftTextOffset
)
{
return
0
;
}
if
(
index
+
1
<
mRealWords
.
Length
(
)
)
return
index
+
1
;
}
return
-
1
;
}
nsresult
mozInlineSpellWordUtil
:
:
SplitDOMWordAndAppendTo
(
int32_t
aStart
int32_t
aEnd
nsTArray
<
RealWord
>
&
aRealWords
)
const
{
nsDependentSubstring
targetText
(
mSoftText
.
GetValue
(
)
aStart
aEnd
-
aStart
)
;
WordSplitState
<
nsDependentSubstring
>
state
(
targetText
)
;
state
.
mCurCharClass
=
state
.
ClassifyCharacter
(
0
true
)
;
state
.
AdvanceThroughSeparators
(
)
;
if
(
state
.
mCurCharClass
!
=
CHAR_CLASS_END_OF_INPUT
&
&
state
.
IsSpecialWord
(
)
)
{
int32_t
specialWordLength
=
state
.
mDOMWordText
.
Length
(
)
-
state
.
mDOMWordOffset
;
if
(
!
aRealWords
.
AppendElement
(
RealWord
(
aStart
+
state
.
mDOMWordOffset
specialWordLength
false
)
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
while
(
state
.
mCurCharClass
!
=
CHAR_CLASS_END_OF_INPUT
)
{
state
.
AdvanceThroughSeparators
(
)
;
if
(
state
.
mCurCharClass
=
=
CHAR_CLASS_END_OF_INPUT
)
break
;
int32_t
wordOffset
=
state
.
mDOMWordOffset
;
state
.
AdvanceThroughWord
(
)
;
int32_t
wordLen
=
state
.
mDOMWordOffset
-
wordOffset
;
if
(
!
aRealWords
.
AppendElement
(
RealWord
(
aStart
+
wordOffset
wordLen
!
state
.
ShouldSkipWord
(
wordOffset
wordLen
)
)
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
NS_OK
;
}
