#
include
"
mozInlineSpellWordUtil
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
inline
bool
IsIgnorableCharacter
(
char16_t
ch
)
{
return
(
ch
=
=
0xAD
|
|
ch
=
=
0x1806
)
;
}
inline
bool
IsConditionalPunctuation
(
char16_t
ch
)
{
return
(
ch
=
=
'
\
'
'
|
|
ch
=
=
0x2019
|
|
ch
=
=
0x00B7
)
;
}
static
bool
IsAmbiguousDOMWordSeprator
(
char16_t
ch
)
{
return
(
ch
=
=
'
'
|
|
ch
=
=
'
:
'
|
|
ch
=
=
'
.
'
|
|
ch
=
=
'
/
'
|
|
ch
=
=
'
-
'
|
|
IsConditionalPunctuation
(
ch
)
)
;
}
static
bool
IsDOMWordSeparator
(
char16_t
ch
)
{
if
(
ch
=
=
'
'
|
|
ch
=
=
'
\
t
'
|
|
ch
=
=
'
\
n
'
|
|
ch
=
=
'
\
r
'
)
return
true
;
if
(
ch
>
=
0xA0
&
&
(
ch
=
=
0x00A0
|
|
ch
=
=
0x2002
|
|
ch
=
=
0x2003
|
|
ch
=
=
0x2009
|
|
ch
=
=
0x3000
)
)
return
true
;
return
false
;
}
nsresult
mozInlineSpellWordUtil
:
:
Init
(
TextEditor
*
aTextEditor
)
{
if
(
NS_WARN_IF
(
!
aTextEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
mDocument
=
aTextEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
mDocument
)
)
{
return
NS_ERROR_FAILURE
;
}
mIsContentEditableOrDesignMode
=
!
!
aTextEditor
-
>
AsHTMLEditor
(
)
;
mRootNode
=
aTextEditor
-
>
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
mRootNode
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
static
inline
bool
IsSpellCheckingTextNode
(
nsINode
*
aNode
)
{
nsIContent
*
parent
=
aNode
-
>
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
script
nsGkAtoms
:
:
style
)
)
return
false
;
return
aNode
-
>
IsText
(
)
;
}
typedef
void
(
*
OnLeaveNodeFunPtr
)
(
nsINode
*
aNode
void
*
aClosure
)
;
static
nsINode
*
FindNextNode
(
nsINode
*
aNode
nsINode
*
aRoot
OnLeaveNodeFunPtr
aOnLeaveNode
void
*
aClosure
)
{
MOZ_ASSERT
(
aNode
"
Null
starting
node
?
"
)
;
nsINode
*
next
=
aNode
-
>
GetFirstChild
(
)
;
if
(
next
)
return
next
;
if
(
aNode
=
=
aRoot
)
return
nullptr
;
next
=
aNode
-
>
GetNextSibling
(
)
;
if
(
next
)
return
next
;
for
(
;
;
)
{
if
(
aOnLeaveNode
)
{
aOnLeaveNode
(
aNode
aClosure
)
;
}
next
=
aNode
-
>
GetParent
(
)
;
if
(
next
=
=
aRoot
|
|
!
next
)
return
nullptr
;
aNode
=
next
;
next
=
aNode
-
>
GetNextSibling
(
)
;
if
(
next
)
return
next
;
}
}
static
nsINode
*
FindNextTextNode
(
nsINode
*
aNode
int32_t
aOffset
nsINode
*
aRoot
)
{
MOZ_ASSERT
(
aNode
"
Null
starting
node
?
"
)
;
NS_ASSERTION
(
!
IsSpellCheckingTextNode
(
aNode
)
"
FindNextTextNode
should
start
with
a
non
-
text
node
"
)
;
nsINode
*
checkNode
;
nsIContent
*
child
=
aNode
-
>
GetChildAt_Deprecated
(
aOffset
)
;
if
(
child
)
{
checkNode
=
child
;
}
else
{
checkNode
=
aNode
-
>
GetNextNonChildNode
(
aRoot
)
;
}
while
(
checkNode
&
&
!
IsSpellCheckingTextNode
(
checkNode
)
)
{
checkNode
=
checkNode
-
>
GetNextNode
(
aRoot
)
;
}
return
checkNode
;
}
nsresult
mozInlineSpellWordUtil
:
:
SetPositionAndEnd
(
nsINode
*
aPositionNode
int32_t
aPositionOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
{
MOZ_ASSERT
(
aPositionNode
"
Null
begin
node
?
"
)
;
MOZ_ASSERT
(
aEndNode
"
Null
end
node
?
"
)
;
NS_ASSERTION
(
mRootNode
"
Not
initialized
"
)
;
if
(
mIsContentEditableOrDesignMode
)
{
nsINode
*
rootNode
=
aPositionNode
-
>
SubtreeRoot
(
)
;
if
(
rootNode
!
=
aEndNode
-
>
SubtreeRoot
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
ShadowRoot
:
:
FromNode
(
rootNode
)
)
{
mRootNode
=
rootNode
;
}
}
InvalidateWords
(
)
;
if
(
!
IsSpellCheckingTextNode
(
aPositionNode
)
)
{
aPositionNode
=
FindNextTextNode
(
aPositionNode
aPositionOffset
mRootNode
)
;
aPositionOffset
=
0
;
}
mSoftBegin
=
NodeOffset
(
aPositionNode
aPositionOffset
)
;
if
(
!
IsSpellCheckingTextNode
(
aEndNode
)
)
{
aEndNode
=
FindNextTextNode
(
aEndNode
aEndOffset
mRootNode
)
;
aEndOffset
=
0
;
}
mSoftEnd
=
NodeOffset
(
aEndNode
aEndOffset
)
;
nsresult
rv
=
EnsureWords
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
int32_t
textOffset
=
MapDOMPositionToSoftTextOffset
(
mSoftBegin
)
;
if
(
textOffset
<
0
)
{
return
NS_OK
;
}
mNextWordIndex
=
FindRealWordContaining
(
textOffset
HINT_END
true
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellWordUtil
:
:
EnsureWords
(
)
{
if
(
mSoftTextValid
)
return
NS_OK
;
BuildSoftText
(
)
;
nsresult
rv
=
BuildRealWords
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mRealWords
.
Clear
(
)
;
return
rv
;
}
mSoftTextValid
=
true
;
return
NS_OK
;
}
nsresult
mozInlineSpellWordUtil
:
:
MakeRangeForWord
(
const
RealWord
&
aWord
nsRange
*
*
aRange
)
{
NodeOffset
begin
=
MapSoftTextOffsetToDOMPosition
(
aWord
.
mSoftTextOffset
HINT_BEGIN
)
;
NodeOffset
end
=
MapSoftTextOffsetToDOMPosition
(
aWord
.
EndOffset
(
)
HINT_END
)
;
return
MakeRange
(
begin
end
aRange
)
;
}
void
mozInlineSpellWordUtil
:
:
MakeNodeOffsetRangeForWord
(
const
RealWord
&
aWord
NodeOffsetRange
*
aNodeOffsetRange
)
{
NodeOffset
begin
=
MapSoftTextOffsetToDOMPosition
(
aWord
.
mSoftTextOffset
HINT_BEGIN
)
;
NodeOffset
end
=
MapSoftTextOffsetToDOMPosition
(
aWord
.
EndOffset
(
)
HINT_END
)
;
*
aNodeOffsetRange
=
NodeOffsetRange
(
begin
end
)
;
}
nsresult
mozInlineSpellWordUtil
:
:
GetRangeForWord
(
nsINode
*
aWordNode
int32_t
aWordOffset
nsRange
*
*
aRange
)
{
NodeOffset
pt
(
aWordNode
aWordOffset
)
;
if
(
!
mSoftTextValid
|
|
pt
!
=
mSoftBegin
|
|
pt
!
=
mSoftEnd
)
{
InvalidateWords
(
)
;
mSoftBegin
=
mSoftEnd
=
pt
;
nsresult
rv
=
EnsureWords
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
int32_t
offset
=
MapDOMPositionToSoftTextOffset
(
pt
)
;
if
(
offset
<
0
)
return
MakeRange
(
pt
pt
aRange
)
;
int32_t
wordIndex
=
FindRealWordContaining
(
offset
HINT_BEGIN
false
)
;
if
(
wordIndex
<
0
)
return
MakeRange
(
pt
pt
aRange
)
;
return
MakeRangeForWord
(
mRealWords
[
wordIndex
]
aRange
)
;
}
static
void
NormalizeWord
(
const
nsAString
&
aInput
int32_t
aPos
int32_t
aLen
nsAString
&
aOutput
)
{
aOutput
.
Truncate
(
)
;
for
(
int32_t
i
=
0
;
i
<
aLen
;
i
+
+
)
{
char16_t
ch
=
aInput
.
CharAt
(
i
+
aPos
)
;
if
(
IsIgnorableCharacter
(
ch
)
)
continue
;
if
(
ch
=
=
0x2019
)
{
ch
=
'
\
'
'
;
}
aOutput
.
Append
(
ch
)
;
}
}
nsresult
mozInlineSpellWordUtil
:
:
GetNextWord
(
nsAString
&
aText
NodeOffsetRange
*
aNodeOffsetRange
bool
*
aSkipChecking
)
{
#
ifdef
DEBUG_SPELLCHECK
printf
(
"
GetNextWord
called
;
mNextWordIndex
=
%
d
\
n
"
mNextWordIndex
)
;
#
endif
if
(
mNextWordIndex
<
0
|
|
mNextWordIndex
>
=
int32_t
(
mRealWords
.
Length
(
)
)
)
{
mNextWordIndex
=
-
1
;
*
aNodeOffsetRange
=
NodeOffsetRange
(
)
;
*
aSkipChecking
=
true
;
return
NS_OK
;
}
const
RealWord
&
word
=
mRealWords
[
mNextWordIndex
]
;
MakeNodeOffsetRangeForWord
(
word
aNodeOffsetRange
)
;
+
+
mNextWordIndex
;
*
aSkipChecking
=
!
word
.
mCheckableWord
;
:
:
NormalizeWord
(
mSoftText
word
.
mSoftTextOffset
word
.
mLength
aText
)
;
#
ifdef
DEBUG_SPELLCHECK
printf
(
"
GetNextWord
returning
:
%
s
(
skip
=
%
d
)
\
n
"
NS_ConvertUTF16toUTF8
(
aText
)
.
get
(
)
*
aSkipChecking
)
;
#
endif
return
NS_OK
;
}
nsresult
mozInlineSpellWordUtil
:
:
MakeRange
(
NodeOffset
aBegin
NodeOffset
aEnd
nsRange
*
*
aRange
)
{
NS_ENSURE_ARG_POINTER
(
aBegin
.
mNode
)
;
if
(
!
mDocument
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aBegin
.
mNode
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
aBegin
.
mNode
aBegin
.
mOffset
aEnd
.
mNode
aEnd
.
mOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
range
.
forget
(
aRange
)
;
return
NS_OK
;
}
already_AddRefed
<
nsRange
>
mozInlineSpellWordUtil
:
:
MakeRange
(
const
NodeOffsetRange
&
aRange
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aRange
.
Begin
(
)
.
Node
(
)
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
aRange
.
Begin
(
)
.
Node
(
)
aRange
.
Begin
(
)
.
Offset
(
)
aRange
.
End
(
)
.
Node
(
)
aRange
.
End
(
)
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
return
range
.
forget
(
)
;
}
enum
CharClass
{
CHAR_CLASS_WORD
CHAR_CLASS_SEPARATOR
CHAR_CLASS_END_OF_INPUT
}
;
template
<
class
T
>
struct
MOZ_STACK_CLASS
WordSplitState
{
const
T
&
mDOMWordText
;
int32_t
mDOMWordOffset
;
CharClass
mCurCharClass
;
explicit
WordSplitState
(
const
T
&
aString
)
:
mDOMWordText
(
aString
)
mDOMWordOffset
(
0
)
mCurCharClass
(
CHAR_CLASS_END_OF_INPUT
)
{
}
CharClass
ClassifyCharacter
(
int32_t
aIndex
bool
aRecurse
)
const
;
void
Advance
(
)
;
void
AdvanceThroughSeparators
(
)
;
void
AdvanceThroughWord
(
)
;
bool
IsSpecialWord
(
)
const
;
bool
ShouldSkipWord
(
int32_t
aStart
int32_t
aLength
)
const
;
bool
GetDOMWordSeparatorOffset
(
int32_t
aOffset
int32_t
*
aSeparatorOffset
)
const
;
}
;
template
<
class
T
>
CharClass
WordSplitState
<
T
>
:
:
ClassifyCharacter
(
int32_t
aIndex
bool
aRecurse
)
const
{
NS_ASSERTION
(
aIndex
>
=
0
&
&
aIndex
<
=
int32_t
(
mDOMWordText
.
Length
(
)
)
"
Index
out
of
range
"
)
;
if
(
aIndex
=
=
int32_t
(
mDOMWordText
.
Length
(
)
)
)
return
CHAR_CLASS_SEPARATOR
;
nsUGenCategory
charCategory
=
mozilla
:
:
unicode
:
:
GetGenCategory
(
mDOMWordText
[
aIndex
]
)
;
if
(
charCategory
=
=
nsUGenCategory
:
:
kLetter
|
|
IsIgnorableCharacter
(
mDOMWordText
[
aIndex
]
)
|
|
mDOMWordText
[
aIndex
]
=
=
0x200C
|
|
mDOMWordText
[
aIndex
]
=
=
0x200D
)
return
CHAR_CLASS_WORD
;
if
(
IsConditionalPunctuation
(
mDOMWordText
[
aIndex
]
)
)
{
if
(
!
aRecurse
)
{
return
CHAR_CLASS_SEPARATOR
;
}
if
(
aIndex
=
=
0
)
return
CHAR_CLASS_SEPARATOR
;
if
(
ClassifyCharacter
(
aIndex
-
1
false
)
!
=
CHAR_CLASS_WORD
)
return
CHAR_CLASS_SEPARATOR
;
if
(
mDOMWordText
[
aIndex
-
1
]
=
=
'
.
'
)
return
CHAR_CLASS_SEPARATOR
;
if
(
aIndex
=
=
int32_t
(
mDOMWordText
.
Length
(
)
-
1
)
)
{
return
CHAR_CLASS_SEPARATOR
;
}
if
(
ClassifyCharacter
(
aIndex
+
1
false
)
!
=
CHAR_CLASS_WORD
)
return
CHAR_CLASS_SEPARATOR
;
if
(
mDOMWordText
[
aIndex
+
1
]
=
=
'
.
'
)
return
CHAR_CLASS_SEPARATOR
;
return
CHAR_CLASS_WORD
;
}
if
(
aIndex
>
0
&
&
mDOMWordText
[
aIndex
]
=
=
'
.
'
&
&
mDOMWordText
[
aIndex
-
1
]
!
=
'
.
'
&
&
ClassifyCharacter
(
aIndex
-
1
false
)
!
=
CHAR_CLASS_WORD
)
{
return
CHAR_CLASS_WORD
;
}
if
(
charCategory
=
=
nsUGenCategory
:
:
kSeparator
|
|
charCategory
=
=
nsUGenCategory
:
:
kOther
|
|
charCategory
=
=
nsUGenCategory
:
:
kPunctuation
|
|
charCategory
=
=
nsUGenCategory
:
:
kSymbol
)
{
if
(
aIndex
>
0
&
&
mDOMWordText
[
aIndex
]
=
=
'
-
'
&
&
mDOMWordText
[
aIndex
-
1
]
!
=
'
-
'
&
&
ClassifyCharacter
(
aIndex
-
1
false
)
=
=
CHAR_CLASS_WORD
)
{
if
(
aIndex
=
=
int32_t
(
mDOMWordText
.
Length
(
)
)
-
1
)
return
CHAR_CLASS_SEPARATOR
;
if
(
mDOMWordText
[
aIndex
+
1
]
!
=
'
.
'
&
&
ClassifyCharacter
(
aIndex
+
1
false
)
=
=
CHAR_CLASS_WORD
)
return
CHAR_CLASS_WORD
;
}
return
CHAR_CLASS_SEPARATOR
;
}
return
CHAR_CLASS_WORD
;
}
template
<
class
T
>
void
WordSplitState
<
T
>
:
:
Advance
(
)
{
NS_ASSERTION
(
mDOMWordOffset
>
=
0
"
Negative
word
index
"
)
;
NS_ASSERTION
(
mDOMWordOffset
<
(
int32_t
)
mDOMWordText
.
Length
(
)
"
Length
beyond
end
"
)
;
mDOMWordOffset
+
+
;
if
(
mDOMWordOffset
>
=
(
int32_t
)
mDOMWordText
.
Length
(
)
)
mCurCharClass
=
CHAR_CLASS_END_OF_INPUT
;
else
mCurCharClass
=
ClassifyCharacter
(
mDOMWordOffset
true
)
;
}
template
<
class
T
>
void
WordSplitState
<
T
>
:
:
AdvanceThroughSeparators
(
)
{
while
(
mCurCharClass
=
=
CHAR_CLASS_SEPARATOR
)
Advance
(
)
;
}
template
<
class
T
>
void
WordSplitState
<
T
>
:
:
AdvanceThroughWord
(
)
{
while
(
mCurCharClass
=
=
CHAR_CLASS_WORD
)
Advance
(
)
;
}
template
<
class
T
>
bool
WordSplitState
<
T
>
:
:
IsSpecialWord
(
)
const
{
int32_t
firstColon
=
-
1
;
for
(
int32_t
i
=
mDOMWordOffset
;
i
<
int32_t
(
mDOMWordText
.
Length
(
)
)
;
i
+
+
)
{
if
(
mDOMWordText
[
i
]
=
=
'
'
)
{
if
(
i
>
0
&
&
ClassifyCharacter
(
i
-
1
false
)
=
=
CHAR_CLASS_WORD
&
&
i
<
(
int32_t
)
mDOMWordText
.
Length
(
)
-
1
&
&
ClassifyCharacter
(
i
+
1
false
)
=
=
CHAR_CLASS_WORD
)
{
return
true
;
}
}
else
if
(
mDOMWordText
[
i
]
=
=
'
:
'
&
&
firstColon
<
0
)
{
firstColon
=
i
;
if
(
firstColon
<
(
int32_t
)
mDOMWordText
.
Length
(
)
-
1
&
&
mDOMWordText
[
firstColon
+
1
]
=
=
'
/
'
)
{
return
true
;
}
}
}
if
(
firstColon
>
mDOMWordOffset
)
{
nsString
protocol
(
Substring
(
mDOMWordText
mDOMWordOffset
firstColon
-
mDOMWordOffset
)
)
;
if
(
protocol
.
EqualsIgnoreCase
(
"
http
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
https
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
news
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
file
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
javascript
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
data
"
)
|
|
protocol
.
EqualsIgnoreCase
(
"
ftp
"
)
)
{
return
true
;
}
}
return
false
;
}
template
<
class
T
>
bool
WordSplitState
<
T
>
:
:
ShouldSkipWord
(
int32_t
aStart
int32_t
aLength
)
const
{
int32_t
last
=
aStart
+
aLength
;
for
(
int32_t
i
=
aStart
;
i
<
last
;
i
+
+
)
{
if
(
unicode
:
:
GetGenCategory
(
mDOMWordText
[
i
]
)
=
=
nsUGenCategory
:
:
kNumber
)
{
return
true
;
}
}
return
false
;
}
template
<
class
T
>
bool
WordSplitState
<
T
>
:
:
GetDOMWordSeparatorOffset
(
int32_t
aOffset
int32_t
*
aSeparatorOffset
)
const
{
for
(
int32_t
i
=
aOffset
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
IsDOMWordSeparator
(
mDOMWordText
[
i
]
)
|
|
(
!
IsAmbiguousDOMWordSeprator
(
mDOMWordText
[
i
]
)
&
&
ClassifyCharacter
(
i
true
)
=
=
CHAR_CLASS_SEPARATOR
)
)
{
for
(
int32_t
j
=
i
-
1
;
j
>
=
0
;
-
-
j
)
{
if
(
IsDOMWordSeparator
(
mDOMWordText
[
j
]
)
|
|
(
!
IsAmbiguousDOMWordSeprator
(
mDOMWordText
[
j
]
)
&
&
ClassifyCharacter
(
j
true
)
=
=
CHAR_CLASS_SEPARATOR
)
)
{
i
=
j
;
}
else
{
break
;
}
}
*
aSeparatorOffset
=
i
;
return
true
;
}
}
return
false
;
}
static
inline
bool
IsBRElement
(
nsINode
*
aNode
)
{
return
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
;
}
static
bool
TextNodeContainsDOMWordSeparator
(
nsIContent
*
aContent
int32_t
aBeforeOffset
int32_t
*
aSeparatorOffset
)
{
const
nsTextFragment
*
textFragment
=
aContent
-
>
GetText
(
)
;
NS_ASSERTION
(
textFragment
"
Where
is
our
text
?
"
)
;
int32_t
end
=
std
:
:
min
(
aBeforeOffset
int32_t
(
textFragment
-
>
GetLength
(
)
)
)
;
if
(
textFragment
-
>
Is2b
(
)
)
{
nsDependentSubstring
targetText
(
textFragment
-
>
Get2b
(
)
end
)
;
WordSplitState
<
nsDependentSubstring
>
state
(
targetText
)
;
return
state
.
GetDOMWordSeparatorOffset
(
end
aSeparatorOffset
)
;
}
nsDependentCSubstring
targetText
(
textFragment
-
>
Get1b
(
)
end
)
;
WordSplitState
<
nsDependentCSubstring
>
state
(
targetText
)
;
return
state
.
GetDOMWordSeparatorOffset
(
end
aSeparatorOffset
)
;
}
static
bool
ContainsDOMWordSeparator
(
nsINode
*
aNode
int32_t
aBeforeOffset
int32_t
*
aSeparatorOffset
)
{
if
(
IsBRElement
(
aNode
)
)
{
*
aSeparatorOffset
=
0
;
return
true
;
}
if
(
!
IsSpellCheckingTextNode
(
aNode
)
)
return
false
;
return
TextNodeContainsDOMWordSeparator
(
aNode
-
>
AsContent
(
)
aBeforeOffset
aSeparatorOffset
)
;
}
static
bool
IsBreakElement
(
nsINode
*
aNode
)
{
if
(
!
aNode
-
>
IsElement
(
)
)
{
return
false
;
}
dom
:
:
Element
*
element
=
aNode
-
>
AsElement
(
)
;
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
return
true
;
if
(
!
element
-
>
GetPrimaryFrame
(
)
)
return
false
;
return
element
-
>
GetPrimaryFrame
(
)
-
>
StyleDisplay
(
)
-
>
mDisplay
!
=
StyleDisplay
:
:
Inline
;
}
struct
CheckLeavingBreakElementClosure
{
bool
mLeftBreakElement
;
}
;
static
void
CheckLeavingBreakElement
(
nsINode
*
aNode
void
*
aClosure
)
{
CheckLeavingBreakElementClosure
*
cl
=
static_cast
<
CheckLeavingBreakElementClosure
*
>
(
aClosure
)
;
if
(
!
cl
-
>
mLeftBreakElement
&
&
IsBreakElement
(
aNode
)
)
{
cl
-
>
mLeftBreakElement
=
true
;
}
}
void
mozInlineSpellWordUtil
:
:
NormalizeWord
(
nsAString
&
aWord
)
{
nsAutoString
result
;
:
:
NormalizeWord
(
aWord
0
aWord
.
Length
(
)
result
)
;
aWord
=
result
;
}
void
mozInlineSpellWordUtil
:
:
BuildSoftText
(
)
{
nsINode
*
node
=
mSoftBegin
.
mNode
;
int32_t
firstOffsetInNode
=
0
;
int32_t
checkBeforeOffset
=
mSoftBegin
.
mOffset
;
while
(
node
)
{
if
(
ContainsDOMWordSeparator
(
node
checkBeforeOffset
&
firstOffsetInNode
)
)
{
if
(
node
=
=
mSoftBegin
.
mNode
)
{
int32_t
newOffset
=
0
;
if
(
firstOffsetInNode
>
0
)
{
if
(
!
ContainsDOMWordSeparator
(
node
firstOffsetInNode
-
1
&
newOffset
)
)
{
nsIContent
*
prevNode
=
node
-
>
GetPreviousSibling
(
)
;
while
(
prevNode
&
&
IsSpellCheckingTextNode
(
prevNode
)
)
{
mSoftBegin
.
mNode
=
prevNode
;
if
(
TextNodeContainsDOMWordSeparator
(
prevNode
INT32_MAX
&
newOffset
)
)
{
break
;
}
prevNode
=
prevNode
-
>
GetPreviousSibling
(
)
;
}
}
}
firstOffsetInNode
=
newOffset
;
mSoftBegin
.
mOffset
=
newOffset
;
}
break
;
}
checkBeforeOffset
=
INT32_MAX
;
if
(
IsBreakElement
(
node
)
)
{
break
;
}
if
(
!
node
-
>
IsInclusiveDescendantOf
(
mRootNode
)
)
{
break
;
}
node
=
node
-
>
GetPreviousContent
(
mRootNode
)
;
}
mSoftText
.
Truncate
(
)
;
mSoftTextDOMMapping
.
Clear
(
)
;
bool
seenSoftEnd
=
false
;
while
(
node
)
{
if
(
node
=
=
mSoftEnd
.
mNode
)
{
seenSoftEnd
=
true
;
}
bool
exit
=
false
;
if
(
IsSpellCheckingTextNode
(
node
)
)
{
nsIContent
*
content
=
static_cast
<
nsIContent
*
>
(
node
)
;
NS_ASSERTION
(
content
"
Where
is
our
content
?
"
)
;
const
nsTextFragment
*
textFragment
=
content
-
>
GetText
(
)
;
NS_ASSERTION
(
textFragment
"
Where
is
our
text
?
"
)
;
int32_t
lastOffsetInNode
=
textFragment
-
>
GetLength
(
)
;
if
(
seenSoftEnd
)
{
for
(
int32_t
i
=
node
=
=
mSoftEnd
.
mNode
?
mSoftEnd
.
mOffset
:
0
;
i
<
int32_t
(
textFragment
-
>
GetLength
(
)
)
;
+
+
i
)
{
if
(
IsDOMWordSeparator
(
textFragment
-
>
CharAt
(
i
)
)
)
{
exit
=
true
;
lastOffsetInNode
=
i
;
break
;
}
}
}
if
(
firstOffsetInNode
<
lastOffsetInNode
)
{
int32_t
len
=
lastOffsetInNode
-
firstOffsetInNode
;
mSoftTextDOMMapping
.
AppendElement
(
DOMTextMapping
(
NodeOffset
(
node
firstOffsetInNode
)
mSoftText
.
Length
(
)
len
)
)
;
bool
ok
=
textFragment
-
>
AppendTo
(
mSoftText
firstOffsetInNode
len
mozilla
:
:
fallible
)
;
if
(
!
ok
)
{
mSoftTextDOMMapping
.
RemoveLastElement
(
)
;
exit
=
true
;
}
}
firstOffsetInNode
=
0
;
}
if
(
exit
)
break
;
CheckLeavingBreakElementClosure
closure
=
{
false
}
;
node
=
FindNextNode
(
node
mRootNode
CheckLeavingBreakElement
&
closure
)
;
if
(
closure
.
mLeftBreakElement
|
|
(
node
&
&
IsBreakElement
(
node
)
)
)
{
if
(
seenSoftEnd
)
break
;
mSoftText
.
Append
(
'
'
)
;
}
}
#
ifdef
DEBUG_SPELLCHECK
printf
(
"
Got
DOM
string
:
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
mSoftText
)
.
get
(
)
)
;
#
endif
}
nsresult
mozInlineSpellWordUtil
:
:
BuildRealWords
(
)
{
int32_t
wordStart
=
-
1
;
mRealWords
.
Clear
(
)
;
for
(
int32_t
i
=
0
;
i
<
int32_t
(
mSoftText
.
Length
(
)
)
;
+
+
i
)
{
if
(
IsDOMWordSeparator
(
mSoftText
.
CharAt
(
i
)
)
)
{
if
(
wordStart
>
=
0
)
{
nsresult
rv
=
SplitDOMWord
(
wordStart
i
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
wordStart
=
-
1
;
}
}
else
{
if
(
wordStart
<
0
)
{
wordStart
=
i
;
}
}
}
if
(
wordStart
>
=
0
)
{
nsresult
rv
=
SplitDOMWord
(
wordStart
mSoftText
.
Length
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
int32_t
mozInlineSpellWordUtil
:
:
MapDOMPositionToSoftTextOffset
(
NodeOffset
aNodeOffset
)
{
if
(
!
mSoftTextValid
)
{
NS_ERROR
(
"
Soft
text
must
be
valid
if
we
'
re
to
map
into
it
"
)
;
return
-
1
;
}
for
(
int32_t
i
=
0
;
i
<
int32_t
(
mSoftTextDOMMapping
.
Length
(
)
)
;
+
+
i
)
{
const
DOMTextMapping
&
map
=
mSoftTextDOMMapping
[
i
]
;
if
(
map
.
mNodeOffset
.
mNode
=
=
aNodeOffset
.
mNode
)
{
int32_t
offsetInContributedString
=
aNodeOffset
.
mOffset
-
map
.
mNodeOffset
.
mOffset
;
if
(
offsetInContributedString
>
=
0
&
&
offsetInContributedString
<
=
map
.
mLength
)
return
map
.
mSoftTextOffset
+
offsetInContributedString
;
return
-
1
;
}
}
return
-
1
;
}
namespace
{
template
<
class
T
>
class
FirstLargerOffset
{
int32_t
mSoftTextOffset
;
public
:
explicit
FirstLargerOffset
(
int32_t
aSoftTextOffset
)
:
mSoftTextOffset
(
aSoftTextOffset
)
{
}
int
operator
(
)
(
const
T
&
t
)
const
{
return
mSoftTextOffset
<
t
.
mSoftTextOffset
?
-
1
:
1
;
}
}
;
template
<
class
T
>
bool
FindLastNongreaterOffset
(
const
nsTArray
<
T
>
&
aContainer
int32_t
aSoftTextOffset
size_t
*
aIndex
)
{
if
(
aContainer
.
Length
(
)
=
=
0
)
{
return
false
;
}
BinarySearchIf
(
aContainer
0
aContainer
.
Length
(
)
FirstLargerOffset
<
T
>
(
aSoftTextOffset
)
aIndex
)
;
if
(
*
aIndex
>
0
)
{
*
aIndex
-
=
1
;
}
else
{
MOZ_ASSERT
(
aContainer
[
*
aIndex
]
.
mSoftTextOffset
>
aSoftTextOffset
)
;
}
return
true
;
}
}
NodeOffset
mozInlineSpellWordUtil
:
:
MapSoftTextOffsetToDOMPosition
(
int32_t
aSoftTextOffset
DOMMapHint
aHint
)
{
NS_ASSERTION
(
mSoftTextValid
"
Soft
text
must
be
valid
if
we
'
re
to
map
out
of
it
"
)
;
if
(
!
mSoftTextValid
)
return
NodeOffset
(
nullptr
-
1
)
;
size_t
index
;
bool
found
=
FindLastNongreaterOffset
(
mSoftTextDOMMapping
aSoftTextOffset
&
index
)
;
if
(
!
found
)
{
return
NodeOffset
(
nullptr
-
1
)
;
}
if
(
aHint
=
=
HINT_END
&
&
index
>
0
)
{
const
DOMTextMapping
&
map
=
mSoftTextDOMMapping
[
index
-
1
]
;
if
(
map
.
mSoftTextOffset
+
map
.
mLength
=
=
aSoftTextOffset
)
return
NodeOffset
(
map
.
mNodeOffset
.
mNode
map
.
mNodeOffset
.
mOffset
+
map
.
mLength
)
;
}
const
DOMTextMapping
&
map
=
mSoftTextDOMMapping
[
index
]
;
int32_t
offset
=
aSoftTextOffset
-
map
.
mSoftTextOffset
;
if
(
offset
>
=
0
&
&
offset
<
=
map
.
mLength
)
return
NodeOffset
(
map
.
mNodeOffset
.
mNode
map
.
mNodeOffset
.
mOffset
+
offset
)
;
return
NodeOffset
(
nullptr
-
1
)
;
}
int32_t
mozInlineSpellWordUtil
:
:
FindRealWordContaining
(
int32_t
aSoftTextOffset
DOMMapHint
aHint
bool
aSearchForward
)
{
NS_ASSERTION
(
mSoftTextValid
"
Soft
text
must
be
valid
if
we
'
re
to
map
out
of
it
"
)
;
if
(
!
mSoftTextValid
)
return
-
1
;
size_t
index
;
bool
found
=
FindLastNongreaterOffset
(
mRealWords
aSoftTextOffset
&
index
)
;
if
(
!
found
)
{
return
-
1
;
}
if
(
aHint
=
=
HINT_END
&
&
index
>
0
)
{
const
RealWord
&
word
=
mRealWords
[
index
-
1
]
;
if
(
word
.
mSoftTextOffset
+
word
.
mLength
=
=
aSoftTextOffset
)
return
index
-
1
;
}
const
RealWord
&
word
=
mRealWords
[
index
]
;
int32_t
offset
=
aSoftTextOffset
-
word
.
mSoftTextOffset
;
if
(
offset
>
=
0
&
&
offset
<
=
static_cast
<
int32_t
>
(
word
.
mLength
)
)
return
index
;
if
(
aSearchForward
)
{
if
(
mRealWords
[
0
]
.
mSoftTextOffset
>
aSoftTextOffset
)
{
return
0
;
}
if
(
index
+
1
<
mRealWords
.
Length
(
)
)
return
index
+
1
;
}
return
-
1
;
}
nsresult
mozInlineSpellWordUtil
:
:
SplitDOMWord
(
int32_t
aStart
int32_t
aEnd
)
{
nsDependentSubstring
targetText
(
mSoftText
aStart
aEnd
-
aStart
)
;
WordSplitState
<
nsDependentSubstring
>
state
(
targetText
)
;
state
.
mCurCharClass
=
state
.
ClassifyCharacter
(
0
true
)
;
state
.
AdvanceThroughSeparators
(
)
;
if
(
state
.
mCurCharClass
!
=
CHAR_CLASS_END_OF_INPUT
&
&
state
.
IsSpecialWord
(
)
)
{
int32_t
specialWordLength
=
state
.
mDOMWordText
.
Length
(
)
-
state
.
mDOMWordOffset
;
if
(
!
mRealWords
.
AppendElement
(
RealWord
(
aStart
+
state
.
mDOMWordOffset
specialWordLength
false
)
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
while
(
state
.
mCurCharClass
!
=
CHAR_CLASS_END_OF_INPUT
)
{
state
.
AdvanceThroughSeparators
(
)
;
if
(
state
.
mCurCharClass
=
=
CHAR_CLASS_END_OF_INPUT
)
break
;
int32_t
wordOffset
=
state
.
mDOMWordOffset
;
state
.
AdvanceThroughWord
(
)
;
int32_t
wordLen
=
state
.
mDOMWordOffset
-
wordOffset
;
if
(
!
mRealWords
.
AppendElement
(
RealWord
(
aStart
+
wordOffset
wordLen
!
state
.
ShouldSkipWord
(
wordOffset
wordLen
)
)
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
NS_OK
;
}
