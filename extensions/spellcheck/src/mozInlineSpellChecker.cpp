#
include
"
mozInlineSpellChecker
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorSpellCheck
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozInlineSpellWordUtil
.
h
"
#
include
"
mozISpellI18NManager
.
h
"
#
include
"
mozISpellI18NUtil
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISelection
.
h
"
#
include
"
nsISelectionPrivate
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsITextServicesFilter
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsITextControlElement
.
h
"
#
include
"
prtime
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
define
INLINESPELL_CHECK_TIMEOUT
1
#
define
INLINESPELL_MINIMUM_WORDS_BEFORE_TIMEOUT
5
#
define
INLINESPELL_STARTED_TOPIC
"
inlineSpellChecker
-
spellCheck
-
started
"
#
define
INLINESPELL_ENDED_TOPIC
"
inlineSpellChecker
-
spellCheck
-
ended
"
static
bool
ContentIsDescendantOf
(
nsINode
*
aPossibleDescendant
nsINode
*
aPossibleAncestor
)
;
static
const
char
kMaxSpellCheckSelectionSize
[
]
=
"
extensions
.
spellcheck
.
inline
.
max
-
misspellings
"
;
static
const
PRTime
kMaxSpellCheckTimeInUsec
=
INLINESPELL_CHECK_TIMEOUT
*
PR_USEC_PER_MSEC
;
mozInlineSpellStatus
:
:
mozInlineSpellStatus
(
mozInlineSpellChecker
*
aSpellChecker
)
:
mSpellChecker
(
aSpellChecker
)
mWordCount
(
0
)
{
}
nsresult
mozInlineSpellStatus
:
:
InitForEditorChange
(
EditAction
aAction
nsINode
*
aAnchorNode
uint32_t
aAnchorOffset
nsINode
*
aPreviousNode
uint32_t
aPreviousOffset
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
)
{
if
(
NS_WARN_IF
(
!
aAnchorNode
)
|
|
NS_WARN_IF
(
!
aPreviousNode
)
)
{
return
NS_ERROR_FAILURE
;
}
mAnchorRange
=
PositionToCollapsedRange
(
aAnchorNode
aAnchorOffset
)
;
if
(
NS_WARN_IF
(
!
mAnchorRange
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
deleted
=
aAction
=
=
EditAction
:
:
deleteSelection
;
if
(
aAction
=
=
EditAction
:
:
insertIMEText
)
{
deleted
=
!
aPreviousNode
-
>
IsInComposedDoc
(
)
;
}
if
(
deleted
)
{
mOp
=
eOpChangeDelete
;
mRange
=
nullptr
;
return
NS_OK
;
}
mOp
=
eOpChange
;
mRange
=
new
nsRange
(
aPreviousNode
)
;
ErrorResult
errorResult
;
int16_t
cmpResult
=
mAnchorRange
-
>
ComparePoint
(
*
aPreviousNode
aPreviousOffset
errorResult
)
;
if
(
NS_WARN_IF
(
errorResult
.
Failed
(
)
)
)
{
return
errorResult
.
StealNSResult
(
)
;
}
nsresult
rv
;
if
(
cmpResult
<
0
)
{
rv
=
mRange
-
>
SetStartAndEnd
(
aPreviousNode
aPreviousOffset
aAnchorNode
aAnchorOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
mRange
-
>
SetStartAndEnd
(
aAnchorNode
aAnchorOffset
aPreviousNode
aPreviousOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
aAction
=
=
EditAction
:
:
insertText
)
mCreatedRange
=
mRange
;
if
(
aStartNode
&
&
aEndNode
)
{
cmpResult
=
mRange
-
>
ComparePoint
(
*
aStartNode
aStartOffset
errorResult
)
;
if
(
NS_WARN_IF
(
errorResult
.
Failed
(
)
)
)
{
return
errorResult
.
StealNSResult
(
)
;
}
if
(
cmpResult
<
0
)
{
rv
=
mRange
-
>
SetStart
(
aStartNode
aStartOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
cmpResult
=
mRange
-
>
ComparePoint
(
*
aEndNode
aEndOffset
errorResult
)
;
if
(
NS_WARN_IF
(
errorResult
.
Failed
(
)
)
)
{
return
errorResult
.
StealNSResult
(
)
;
}
if
(
cmpResult
>
0
)
{
rv
=
mRange
-
>
SetEnd
(
aEndNode
aEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsresult
mozInlineSpellStatus
:
:
InitForNavigation
(
bool
aForceCheck
int32_t
aNewPositionOffset
nsINode
*
aOldAnchorNode
uint32_t
aOldAnchorOffset
nsINode
*
aNewAnchorNode
uint32_t
aNewAnchorOffset
bool
*
aContinue
)
{
mOp
=
eOpNavigation
;
mForceNavigationWordCheck
=
aForceCheck
;
mNewNavigationPositionOffset
=
aNewPositionOffset
;
TextEditor
*
textEditor
=
mSpellChecker
-
>
mTextEditor
;
if
(
NS_WARN_IF
(
!
textEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
Element
*
root
=
textEditor
-
>
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
root
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
root
&
&
aOldAnchorNode
&
&
!
ContentIsDescendantOf
(
aOldAnchorNode
root
)
)
{
*
aContinue
=
false
;
return
NS_OK
;
}
mOldNavigationAnchorRange
=
PositionToCollapsedRange
(
aOldAnchorNode
aOldAnchorOffset
)
;
if
(
NS_WARN_IF
(
!
mOldNavigationAnchorRange
)
)
{
return
NS_ERROR_FAILURE
;
}
mAnchorRange
=
PositionToCollapsedRange
(
aNewAnchorNode
aNewAnchorOffset
)
;
if
(
NS_WARN_IF
(
!
mAnchorRange
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aContinue
=
true
;
return
NS_OK
;
}
nsresult
mozInlineSpellStatus
:
:
InitForSelection
(
)
{
mOp
=
eOpSelection
;
return
NS_OK
;
}
nsresult
mozInlineSpellStatus
:
:
InitForRange
(
nsRange
*
aRange
)
{
mOp
=
eOpChange
;
mRange
=
aRange
;
return
NS_OK
;
}
nsresult
mozInlineSpellStatus
:
:
FinishInitOnEvent
(
mozInlineSpellWordUtil
&
aWordUtil
)
{
nsresult
rv
;
if
(
!
mRange
)
{
rv
=
mSpellChecker
-
>
MakeSpellCheckRange
(
nullptr
0
nullptr
0
getter_AddRefs
(
mRange
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
switch
(
mOp
)
{
case
eOpChange
:
if
(
mAnchorRange
)
return
FillNoCheckRangeFromAnchor
(
aWordUtil
)
;
break
;
case
eOpChangeDelete
:
if
(
mAnchorRange
)
{
rv
=
FillNoCheckRangeFromAnchor
(
aWordUtil
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mRange
=
mNoCheckRange
;
break
;
case
eOpNavigation
:
return
FinishNavigationEvent
(
aWordUtil
)
;
case
eOpSelection
:
break
;
case
eOpResume
:
break
;
default
:
NS_NOTREACHED
(
"
Bad
operation
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
return
NS_OK
;
}
nsresult
mozInlineSpellStatus
:
:
FinishNavigationEvent
(
mozInlineSpellWordUtil
&
aWordUtil
)
{
RefPtr
<
TextEditor
>
textEditor
=
mSpellChecker
-
>
mTextEditor
;
if
(
!
textEditor
)
{
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
mAnchorRange
"
No
anchor
for
navigation
!
"
)
;
ErrorResult
err
;
nsCOMPtr
<
nsINode
>
oldAnchorNode
=
mOldNavigationAnchorRange
-
>
GetStartContainer
(
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
uint32_t
oldAnchorOffset
=
mOldNavigationAnchorRange
-
>
StartOffset
(
)
;
RefPtr
<
nsRange
>
oldWord
;
nsresult
rv
=
aWordUtil
.
GetRangeForWord
(
oldAnchorNode
-
>
AsDOMNode
(
)
static_cast
<
int32_t
>
(
oldAnchorOffset
)
getter_AddRefs
(
oldWord
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mSpellChecker
-
>
mTextEditor
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
newAnchorNode
=
mAnchorRange
-
>
GetStartContainer
(
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
uint32_t
newAnchorOffset
=
mAnchorRange
-
>
StartOffset
(
)
;
bool
isInRange
=
false
;
if
(
!
mForceNavigationWordCheck
)
{
isInRange
=
oldWord
-
>
IsPointInRange
(
*
newAnchorNode
newAnchorOffset
+
mNewNavigationPositionOffset
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
}
if
(
isInRange
)
{
mRange
=
nullptr
;
}
else
{
mRange
=
oldWord
;
mSpellChecker
-
>
mNeedsCheckAfterNavigation
=
false
;
}
return
NS_OK
;
}
nsresult
mozInlineSpellStatus
:
:
FillNoCheckRangeFromAnchor
(
mozInlineSpellWordUtil
&
aWordUtil
)
{
ErrorResult
err
;
nsCOMPtr
<
nsINode
>
anchorNode
=
mAnchorRange
-
>
GetStartContainer
(
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
uint32_t
anchorOffset
=
mAnchorRange
-
>
StartOffset
(
)
;
return
aWordUtil
.
GetRangeForWord
(
anchorNode
-
>
AsDOMNode
(
)
static_cast
<
int32_t
>
(
anchorOffset
)
getter_AddRefs
(
mNoCheckRange
)
)
;
}
nsIDocument
*
mozInlineSpellStatus
:
:
GetDocument
(
)
const
{
if
(
!
mSpellChecker
-
>
mTextEditor
)
{
return
nullptr
;
}
return
mSpellChecker
-
>
mTextEditor
-
>
GetDocument
(
)
;
}
already_AddRefed
<
nsRange
>
mozInlineSpellStatus
:
:
PositionToCollapsedRange
(
nsINode
*
aNode
uint32_t
aOffset
)
{
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
document
)
;
nsresult
rv
=
range
-
>
CollapseTo
(
aNode
aOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
return
range
.
forget
(
)
;
}
class
mozInlineSpellResume
:
public
Runnable
{
public
:
mozInlineSpellResume
(
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
uint32_t
aDisabledAsyncToken
)
:
Runnable
(
"
mozInlineSpellResume
"
)
mDisabledAsyncToken
(
aDisabledAsyncToken
)
mStatus
(
Move
(
aStatus
)
)
{
}
nsresult
Post
(
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
this
)
;
return
NS_IdleDispatchToCurrentThread
(
runnable
.
forget
(
)
1000
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mDisabledAsyncToken
=
=
mStatus
-
>
mSpellChecker
-
>
mDisabledAsyncToken
)
{
mStatus
-
>
mSpellChecker
-
>
ResumeCheck
(
Move
(
mStatus
)
)
;
}
return
NS_OK
;
}
private
:
uint32_t
mDisabledAsyncToken
;
UniquePtr
<
mozInlineSpellStatus
>
mStatus
;
}
;
class
InitEditorSpellCheckCallback
final
:
public
nsIEditorSpellCheckCallback
{
~
InitEditorSpellCheckCallback
(
)
{
}
public
:
NS_DECL_ISUPPORTS
explicit
InitEditorSpellCheckCallback
(
mozInlineSpellChecker
*
aSpellChecker
)
:
mSpellChecker
(
aSpellChecker
)
{
}
NS_IMETHOD
EditorSpellCheckDone
(
)
override
{
return
mSpellChecker
?
mSpellChecker
-
>
EditorSpellCheckInited
(
)
:
NS_OK
;
}
void
Cancel
(
)
{
mSpellChecker
=
nullptr
;
}
private
:
RefPtr
<
mozInlineSpellChecker
>
mSpellChecker
;
}
;
NS_IMPL_ISUPPORTS
(
InitEditorSpellCheckCallback
nsIEditorSpellCheckCallback
)
NS_INTERFACE_MAP_BEGIN
(
mozInlineSpellChecker
)
NS_INTERFACE_MAP_ENTRY
(
nsIInlineSpellChecker
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
mozInlineSpellChecker
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
mozInlineSpellChecker
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
mozInlineSpellChecker
)
NS_IMPL_CYCLE_COLLECTION
(
mozInlineSpellChecker
mTextEditor
mSpellCheck
mCurrentSelectionAnchorNode
)
mozInlineSpellChecker
:
:
SpellCheckingState
mozInlineSpellChecker
:
:
gCanEnableSpellChecking
=
mozInlineSpellChecker
:
:
SpellCheck_Uninitialized
;
mozInlineSpellChecker
:
:
mozInlineSpellChecker
(
)
:
mNumWordsInSpellSelection
(
0
)
mMaxNumWordsInSpellSelection
(
250
)
mNumPendingSpellChecks
(
0
)
mNumPendingUpdateCurrentDictionary
(
0
)
mDisabledAsyncToken
(
0
)
mNeedsCheckAfterNavigation
(
false
)
mFullSpellCheckScheduled
(
false
)
mIsListeningToEditActions
(
false
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefs
)
prefs
-
>
GetIntPref
(
kMaxSpellCheckSelectionSize
&
mMaxNumWordsInSpellSelection
)
;
mMaxMisspellingsPerCheck
=
mMaxNumWordsInSpellSelection
*
3
/
4
;
}
mozInlineSpellChecker
:
:
~
mozInlineSpellChecker
(
)
{
}
EditorSpellCheck
*
mozInlineSpellChecker
:
:
GetEditorSpellCheck
(
)
{
return
mSpellCheck
?
mSpellCheck
:
mPendingSpellCheck
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetSpellChecker
(
nsIEditorSpellCheck
*
*
aSpellCheck
)
{
*
aSpellCheck
=
mSpellCheck
;
NS_IF_ADDREF
(
*
aSpellCheck
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
Init
(
nsIEditor
*
aEditor
)
{
mTextEditor
=
aEditor
?
aEditor
-
>
AsTextEditor
(
)
:
nullptr
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
Cleanup
(
bool
aDestroyingFrames
)
{
mNumWordsInSpellSelection
=
0
;
RefPtr
<
Selection
>
spellCheckSelection
=
GetSpellCheckSelection
(
)
;
nsresult
rv
=
NS_OK
;
if
(
!
spellCheckSelection
)
{
UnregisterEventListeners
(
)
;
rv
=
NS_ERROR_FAILURE
;
}
else
{
if
(
!
aDestroyingFrames
)
{
spellCheckSelection
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
}
rv
=
UnregisterEventListeners
(
)
;
}
RefPtr
<
TextEditor
>
textEditor
=
mTextEditor
.
forget
(
)
;
if
(
mPendingSpellCheck
)
{
mPendingSpellCheck
=
nullptr
;
mPendingInitEditorSpellCheckCallback
-
>
Cancel
(
)
;
mPendingInitEditorSpellCheckCallback
=
nullptr
;
ChangeNumPendingSpellChecks
(
-
1
textEditor
)
;
}
mDisabledAsyncToken
+
+
;
if
(
mNumPendingUpdateCurrentDictionary
>
0
)
{
ChangeNumPendingSpellChecks
(
-
mNumPendingUpdateCurrentDictionary
textEditor
)
;
mNumPendingUpdateCurrentDictionary
=
0
;
}
if
(
mNumPendingSpellChecks
>
0
)
{
ChangeNumPendingSpellChecks
(
-
mNumPendingSpellChecks
textEditor
)
;
}
mFullSpellCheckScheduled
=
false
;
return
rv
;
}
bool
mozInlineSpellChecker
:
:
CanEnableInlineSpellChecking
(
)
{
nsresult
rv
;
if
(
gCanEnableSpellChecking
=
=
SpellCheck_Uninitialized
)
{
gCanEnableSpellChecking
=
SpellCheck_NotAvailable
;
nsCOMPtr
<
nsIEditorSpellCheck
>
spellchecker
=
do_CreateInstance
(
"
mozilla
.
org
/
editor
/
editorspellchecker
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
bool
canSpellCheck
=
false
;
rv
=
spellchecker
-
>
CanSpellCheck
(
&
canSpellCheck
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
canSpellCheck
)
gCanEnableSpellChecking
=
SpellCheck_Available
;
}
return
(
gCanEnableSpellChecking
=
=
SpellCheck_Available
)
;
}
void
mozInlineSpellChecker
:
:
UpdateCanEnableInlineSpellChecking
(
)
{
gCanEnableSpellChecking
=
SpellCheck_Uninitialized
;
}
nsresult
mozInlineSpellChecker
:
:
RegisterEventListeners
(
)
{
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
StartToListenToEditActions
(
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
mTextEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
doc
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
blur
"
)
this
true
false
)
;
doc
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
click
"
)
this
false
false
)
;
doc
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
keypress
"
)
this
false
false
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
UnregisterEventListeners
(
)
{
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
EndListeningToEditActions
(
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
mTextEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
doc
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
blur
"
)
this
true
)
;
doc
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
click
"
)
this
false
)
;
doc
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
keypress
"
)
this
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetEnableRealTimeSpell
(
bool
*
aEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aEnabled
)
;
*
aEnabled
=
mSpellCheck
!
=
nullptr
|
|
mPendingSpellCheck
!
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
SetEnableRealTimeSpell
(
bool
aEnabled
)
{
if
(
!
aEnabled
)
{
mSpellCheck
=
nullptr
;
return
Cleanup
(
false
)
;
}
if
(
mSpellCheck
)
{
return
SpellCheckRange
(
nullptr
)
;
}
if
(
mPendingSpellCheck
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsITextServicesFilter
>
filter
=
do_CreateInstance
(
"
mozilla
.
org
/
editor
/
txtsrvfiltermail
;
1
"
)
;
if
(
NS_WARN_IF
(
!
filter
)
)
{
return
NS_ERROR_FAILURE
;
}
mPendingSpellCheck
=
new
EditorSpellCheck
(
)
;
mPendingSpellCheck
-
>
SetFilter
(
filter
)
;
mPendingInitEditorSpellCheckCallback
=
new
InitEditorSpellCheckCallback
(
this
)
;
nsresult
rv
=
mPendingSpellCheck
-
>
InitSpellChecker
(
mTextEditor
false
mPendingInitEditorSpellCheckCallback
)
;
if
(
NS_FAILED
(
rv
)
)
{
mPendingSpellCheck
=
nullptr
;
mPendingInitEditorSpellCheckCallback
=
nullptr
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
ChangeNumPendingSpellChecks
(
1
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
EditorSpellCheckInited
(
)
{
NS_ASSERTION
(
mPendingSpellCheck
"
Spell
check
should
be
pending
!
"
)
;
RegisterEventListeners
(
)
;
mSpellCheck
=
mPendingSpellCheck
;
mPendingSpellCheck
=
nullptr
;
mPendingInitEditorSpellCheckCallback
=
nullptr
;
ChangeNumPendingSpellChecks
(
-
1
)
;
return
SpellCheckRange
(
nullptr
)
;
}
void
mozInlineSpellChecker
:
:
ChangeNumPendingSpellChecks
(
int32_t
aDelta
TextEditor
*
aTextEditor
)
{
int8_t
oldNumPending
=
mNumPendingSpellChecks
;
mNumPendingSpellChecks
+
=
aDelta
;
NS_ASSERTION
(
mNumPendingSpellChecks
>
=
0
"
Unbalanced
ChangeNumPendingSpellChecks
calls
!
"
)
;
if
(
oldNumPending
=
=
0
&
&
mNumPendingSpellChecks
>
0
)
{
NotifyObservers
(
INLINESPELL_STARTED_TOPIC
aTextEditor
)
;
}
else
if
(
oldNumPending
>
0
&
&
mNumPendingSpellChecks
=
=
0
)
{
NotifyObservers
(
INLINESPELL_ENDED_TOPIC
aTextEditor
)
;
}
}
void
mozInlineSpellChecker
:
:
NotifyObservers
(
const
char
*
aTopic
TextEditor
*
aTextEditor
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
return
;
RefPtr
<
TextEditor
>
textEditor
=
aTextEditor
?
aTextEditor
:
mTextEditor
.
get
(
)
;
os
-
>
NotifyObservers
(
static_cast
<
nsIEditor
*
>
(
textEditor
.
get
(
)
)
aTopic
nullptr
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
SpellCheckAfterEditorChange
(
int32_t
aAction
nsISelection
*
aSelection
nsINode
*
aPreviousSelectedNode
uint32_t
aPreviousSelectedOffset
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
)
{
nsresult
rv
;
NS_ENSURE_ARG_POINTER
(
aSelection
)
;
if
(
!
mSpellCheck
)
return
NS_OK
;
mNeedsCheckAfterNavigation
=
true
;
RefPtr
<
Selection
>
selection
=
aSelection
-
>
AsSelection
(
)
;
auto
status
=
MakeUnique
<
mozInlineSpellStatus
>
(
this
)
;
rv
=
status
-
>
InitForEditorChange
(
(
EditAction
)
aAction
selection
-
>
GetAnchorNode
(
)
selection
-
>
AnchorOffset
(
)
aPreviousSelectedNode
aPreviousSelectedOffset
aStartNode
aStartOffset
aEndNode
aEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ScheduleSpellCheck
(
Move
(
status
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SaveCurrentSelectionPosition
(
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
SpellCheckRange
(
nsIDOMRange
*
aRange
)
{
if
(
!
mSpellCheck
)
{
NS_WARNING_ASSERTION
(
mPendingSpellCheck
"
Trying
to
spellcheck
but
checking
seems
to
be
disabled
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
auto
status
=
MakeUnique
<
mozInlineSpellStatus
>
(
this
)
;
nsRange
*
range
=
static_cast
<
nsRange
*
>
(
aRange
)
;
nsresult
rv
=
status
-
>
InitForRange
(
range
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
ScheduleSpellCheck
(
Move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetMisspelledWord
(
nsIDOMNode
*
aNode
int32_t
aOffset
nsIDOMRange
*
*
newword
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Selection
>
spellCheckSelection
=
GetSpellCheckSelection
(
)
;
if
(
NS_WARN_IF
(
!
spellCheckSelection
)
)
{
return
NS_ERROR_FAILURE
;
}
return
IsPointInSelection
(
spellCheckSelection
aNode
aOffset
newword
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
ReplaceWord
(
nsIDOMNode
*
aNode
int32_t
aOffset
const
nsAString
&
newword
)
{
if
(
NS_WARN_IF
(
!
mTextEditor
)
|
|
NS_WARN_IF
(
newword
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDOMRange
>
range
;
nsresult
res
=
GetMisspelledWord
(
aNode
aOffset
getter_AddRefs
(
range
)
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
range
)
{
RefPtr
<
nsRange
>
editorRange
=
static_cast
<
nsRange
*
>
(
range
.
get
(
)
)
-
>
CloneRange
(
)
;
AutoPlaceholderBatch
phb
(
mTextEditor
nullptr
)
;
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_UNEXPECTED
)
;
selection
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
selection
-
>
AddRange
(
*
editorRange
IgnoreErrors
(
)
)
;
MOZ_ASSERT
(
mTextEditor
)
;
DebugOnly
<
nsresult
>
rv
=
mTextEditor
-
>
InsertTextAsAction
(
newword
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
the
new
word
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
AddWordToDictionary
(
const
nsAString
&
word
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
mSpellCheck
-
>
AddWordToDictionary
(
word
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
auto
status
=
MakeUnique
<
mozInlineSpellStatus
>
(
this
)
;
rv
=
status
-
>
InitForSelection
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
ScheduleSpellCheck
(
Move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
RemoveWordFromDictionary
(
const
nsAString
&
word
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
mSpellCheck
-
>
RemoveWordFromDictionary
(
word
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
auto
status
=
MakeUnique
<
mozInlineSpellStatus
>
(
this
)
;
rv
=
status
-
>
InitForRange
(
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
ScheduleSpellCheck
(
Move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
IgnoreWord
(
const
nsAString
&
word
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
mSpellCheck
-
>
IgnoreWordAllOccurrences
(
word
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
auto
status
=
MakeUnique
<
mozInlineSpellStatus
>
(
this
)
;
rv
=
status
-
>
InitForSelection
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
ScheduleSpellCheck
(
Move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
IgnoreWords
(
const
char16_t
*
*
aWordsToIgnore
uint32_t
aCount
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
for
(
uint32_t
index
=
0
;
index
<
aCount
;
index
+
+
)
mSpellCheck
-
>
IgnoreWordAllOccurrences
(
nsDependentString
(
aWordsToIgnore
[
index
]
)
)
;
auto
status
=
MakeUnique
<
mozInlineSpellStatus
>
(
this
)
;
nsresult
rv
=
status
-
>
InitForSelection
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
ScheduleSpellCheck
(
Move
(
status
)
)
;
}
void
mozInlineSpellChecker
:
:
DidSplitNode
(
nsINode
*
aExistingRightNode
nsINode
*
aNewLeftNode
)
{
if
(
!
mIsListeningToEditActions
)
{
return
;
}
nsIDOMNode
*
newLeftDOMNode
=
aNewLeftNode
?
aNewLeftNode
-
>
AsDOMNode
(
)
:
nullptr
;
SpellCheckBetweenNodes
(
newLeftDOMNode
0
newLeftDOMNode
0
)
;
}
void
mozInlineSpellChecker
:
:
DidJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
if
(
!
mIsListeningToEditActions
)
{
return
;
}
SpellCheckBetweenNodes
(
aRightNode
.
AsDOMNode
(
)
0
aRightNode
.
AsDOMNode
(
)
0
)
;
}
nsresult
mozInlineSpellChecker
:
:
MakeSpellCheckRange
(
nsIDOMNode
*
aStartNode
int32_t
aStartOffset
nsIDOMNode
*
aEndNode
int32_t
aEndOffset
nsRange
*
*
aRange
)
{
nsresult
rv
;
*
aRange
=
nullptr
;
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
mTextEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
doc
)
;
if
(
!
aStartNode
|
|
!
aEndNode
)
{
nsCOMPtr
<
nsIDOMElement
>
domRootElement
=
do_QueryInterface
(
mTextEditor
-
>
GetRoot
(
)
)
;
if
(
NS_WARN_IF
(
!
domRootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
aStartNode
=
aEndNode
=
domRootElement
;
aStartOffset
=
0
;
aEndOffset
=
-
1
;
}
if
(
aEndOffset
=
=
-
1
)
{
nsCOMPtr
<
nsINode
>
endNode
=
do_QueryInterface
(
aEndNode
)
;
aEndOffset
=
endNode
-
>
ChildNodes
(
)
-
>
Length
(
)
;
}
if
(
aStartNode
=
=
aEndNode
&
&
aStartOffset
=
=
aEndOffset
)
return
NS_OK
;
nsCOMPtr
<
nsINode
>
startNode
=
do_QueryInterface
(
aStartNode
)
;
nsCOMPtr
<
nsINode
>
endNode
=
do_QueryInterface
(
aEndNode
)
;
if
(
aEndOffset
)
{
rv
=
range
-
>
SetStartAndEnd
(
startNode
aStartOffset
endNode
aEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
uint32_t
endOffset
;
endNode
=
nsRange
:
:
GetContainerAndOffsetAfter
(
endNode
&
endOffset
)
;
rv
=
range
-
>
SetStartAndEnd
(
startNode
aStartOffset
endNode
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
range
.
swap
(
*
aRange
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
SpellCheckBetweenNodes
(
nsIDOMNode
*
aStartNode
int32_t
aStartOffset
nsIDOMNode
*
aEndNode
int32_t
aEndOffset
)
{
RefPtr
<
nsRange
>
range
;
nsresult
rv
=
MakeSpellCheckRange
(
aStartNode
aStartOffset
aEndNode
aEndOffset
getter_AddRefs
(
range
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
range
)
return
NS_OK
;
auto
status
=
MakeUnique
<
mozInlineSpellStatus
>
(
this
)
;
rv
=
status
-
>
InitForRange
(
range
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
ScheduleSpellCheck
(
Move
(
status
)
)
;
}
bool
mozInlineSpellChecker
:
:
ShouldSpellCheckNode
(
TextEditor
*
aTextEditor
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
aNode
-
>
IsContent
(
)
)
return
false
;
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
if
(
aTextEditor
-
>
IsMailEditor
(
)
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
while
(
parent
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
&
&
parent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
cite
eIgnoreCase
)
)
{
return
false
;
}
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
&
&
parent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
nsGkAtoms
:
:
mozsignature
eIgnoreCase
)
)
{
return
false
;
}
parent
=
parent
-
>
GetParent
(
)
;
}
}
else
{
if
(
!
content
-
>
IsEditable
(
)
)
{
return
false
;
}
if
(
content
-
>
IsInAnonymousSubtree
(
)
)
{
nsIContent
*
node
=
content
-
>
GetParent
(
)
;
while
(
node
&
&
node
-
>
IsInNativeAnonymousSubtree
(
)
)
{
node
=
node
-
>
GetParent
(
)
;
}
nsCOMPtr
<
nsITextControlElement
>
textControl
=
do_QueryInterface
(
node
)
;
if
(
textControl
)
{
return
true
;
}
}
nsIContent
*
parent
=
content
;
while
(
!
parent
-
>
IsHTMLElement
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
true
;
}
}
return
static_cast
<
nsGenericHTMLElement
*
>
(
parent
)
-
>
Spellcheck
(
)
;
}
return
true
;
}
nsresult
mozInlineSpellChecker
:
:
ScheduleSpellCheck
(
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
)
{
if
(
mFullSpellCheckScheduled
)
{
return
NS_OK
;
}
bool
isFullSpellCheck
=
aStatus
-
>
IsFullSpellCheck
(
)
;
RefPtr
<
mozInlineSpellResume
>
resume
=
new
mozInlineSpellResume
(
Move
(
aStatus
)
mDisabledAsyncToken
)
;
NS_ENSURE_TRUE
(
resume
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
resume
-
>
Post
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
isFullSpellCheck
)
{
mFullSpellCheckScheduled
=
true
;
}
ChangeNumPendingSpellChecks
(
1
)
;
}
return
rv
;
}
nsresult
mozInlineSpellChecker
:
:
DoSpellCheckSelection
(
mozInlineSpellWordUtil
&
aWordUtil
Selection
*
aSpellCheckSelection
)
{
nsresult
rv
;
mNumWordsInSpellSelection
=
0
;
nsTArray
<
RefPtr
<
nsRange
>
>
ranges
;
int32_t
count
=
aSpellCheckSelection
-
>
RangeCount
(
)
;
for
(
int32_t
idx
=
0
;
idx
<
count
;
idx
+
+
)
{
nsRange
*
range
=
aSpellCheckSelection
-
>
GetRangeAt
(
idx
)
;
if
(
range
)
{
ranges
.
AppendElement
(
range
)
;
}
}
aSpellCheckSelection
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
auto
status
=
MakeUnique
<
mozInlineSpellStatus
>
(
this
)
;
rv
=
status
-
>
InitForRange
(
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
doneChecking
;
for
(
int32_t
idx
=
0
;
idx
<
count
;
idx
+
+
)
{
status
-
>
mRange
=
ranges
[
idx
]
;
rv
=
DoSpellCheck
(
aWordUtil
aSpellCheckSelection
status
&
doneChecking
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
doneChecking
"
We
gave
the
spellchecker
one
word
but
it
didn
'
t
finish
checking
?
!
?
!
"
)
;
status
-
>
mWordCount
=
0
;
}
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
DoSpellCheck
(
mozInlineSpellWordUtil
&
aWordUtil
Selection
*
aSpellCheckSelection
const
UniquePtr
<
mozInlineSpellStatus
>
&
aStatus
bool
*
aDoneChecking
)
{
*
aDoneChecking
=
true
;
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
RefPtr
<
TextEditor
>
textEditor
=
mTextEditor
;
if
(
!
textEditor
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aStatus
-
>
mRange
-
>
Collapsed
(
)
)
return
NS_OK
;
int32_t
originalRangeCount
=
aSpellCheckSelection
-
>
RangeCount
(
)
;
{
nsINode
*
beginNode
=
aStatus
-
>
mRange
-
>
GetStartContainer
(
)
;
int32_t
beginOffset
=
aStatus
-
>
mRange
-
>
StartOffset
(
)
;
nsINode
*
endNode
=
aStatus
-
>
mRange
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
aStatus
-
>
mRange
-
>
EndOffset
(
)
;
nsINode
*
rootNode
=
aWordUtil
.
GetRootNode
(
)
;
if
(
!
beginNode
-
>
IsInComposedDoc
(
)
|
|
!
endNode
-
>
IsInComposedDoc
(
)
|
|
!
nsContentUtils
:
:
ContentIsShadowIncludingDescendantOf
(
beginNode
rootNode
)
|
|
!
nsContentUtils
:
:
ContentIsShadowIncludingDescendantOf
(
endNode
rootNode
)
)
{
return
NS_OK
;
}
aWordUtil
.
SetEnd
(
endNode
endOffset
)
;
aWordUtil
.
SetPosition
(
beginNode
beginOffset
)
;
}
if
(
!
mTextEditor
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
wordsChecked
=
0
;
PRTime
beginTime
=
PR_Now
(
)
;
nsAutoString
wordText
;
NodeOffsetRange
wordNodeOffsetRange
;
bool
dontCheckWord
;
while
(
NS_SUCCEEDED
(
aWordUtil
.
GetNextWord
(
wordText
&
wordNodeOffsetRange
&
dontCheckWord
)
)
&
&
!
wordNodeOffsetRange
.
Empty
(
)
)
{
nsINode
*
beginNode
=
wordNodeOffsetRange
.
Begin
(
)
.
mNode
;
nsINode
*
endNode
=
wordNodeOffsetRange
.
End
(
)
.
mNode
;
int32_t
beginOffset
=
wordNodeOffsetRange
.
Begin
(
)
.
mOffset
;
int32_t
endOffset
=
wordNodeOffsetRange
.
End
(
)
.
mOffset
;
if
(
wordsChecked
>
=
INLINESPELL_MINIMUM_WORDS_BEFORE_TIMEOUT
&
&
PR_Now
(
)
>
PRTime
(
beginTime
+
kMaxSpellCheckTimeInUsec
)
)
{
#
ifdef
DEBUG_INLINESPELL
printf
(
"
We
have
run
out
of
the
time
schedule
next
round
.
"
)
;
#
endif
nsresult
rv
=
aStatus
-
>
mRange
-
>
SetStart
(
beginNode
beginOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
*
aDoneChecking
=
false
;
return
NS_OK
;
}
#
ifdef
DEBUG_INLINESPELL
printf
(
"
-
>
Got
word
\
"
%
s
\
"
"
NS_ConvertUTF16toUTF8
(
wordText
)
.
get
(
)
)
;
if
(
dontCheckWord
)
printf
(
"
(
not
checking
)
"
)
;
printf
(
"
\
n
"
)
;
#
endif
ErrorResult
erv
;
if
(
originalRangeCount
>
0
)
{
if
(
!
aStatus
-
>
mCreatedRange
|
|
!
aStatus
-
>
mCreatedRange
-
>
IsPointInRange
(
*
beginNode
beginOffset
erv
)
)
{
nsTArray
<
RefPtr
<
nsRange
>
>
ranges
;
aSpellCheckSelection
-
>
GetRangesForInterval
(
*
beginNode
beginOffset
*
endNode
endOffset
true
ranges
erv
)
;
ENSURE_SUCCESS
(
erv
erv
.
StealNSResult
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
ranges
.
Length
(
)
;
i
+
+
)
RemoveRange
(
aSpellCheckSelection
ranges
[
i
]
)
;
}
}
if
(
dontCheckWord
)
continue
;
if
(
!
ShouldSpellCheckNode
(
textEditor
beginNode
)
)
{
continue
;
}
if
(
aStatus
-
>
mNoCheckRange
&
&
aStatus
-
>
mNoCheckRange
-
>
IsPointInRange
(
*
beginNode
beginOffset
erv
)
)
{
continue
;
}
bool
isMisspelled
;
mozInlineSpellWordUtil
:
:
NormalizeWord
(
wordText
)
;
nsresult
rv
=
mSpellCheck
-
>
CheckCurrentWordNoSuggest
(
wordText
&
isMisspelled
)
;
if
(
NS_FAILED
(
rv
)
)
continue
;
wordsChecked
+
+
;
if
(
isMisspelled
)
{
RefPtr
<
nsRange
>
wordRange
;
if
(
NS_SUCCEEDED
(
aWordUtil
.
MakeRange
(
wordNodeOffsetRange
.
Begin
(
)
wordNodeOffsetRange
.
End
(
)
getter_AddRefs
(
wordRange
)
)
)
)
{
AddRange
(
aSpellCheckSelection
wordRange
)
;
aStatus
-
>
mWordCount
+
+
;
if
(
aStatus
-
>
mWordCount
>
=
mMaxMisspellingsPerCheck
|
|
SpellCheckSelectionIsFull
(
)
)
{
break
;
}
}
}
}
return
NS_OK
;
}
class
AutoChangeNumPendingSpellChecks
{
public
:
AutoChangeNumPendingSpellChecks
(
mozInlineSpellChecker
*
aSpellChecker
int32_t
aDelta
)
:
mSpellChecker
(
aSpellChecker
)
mDelta
(
aDelta
)
{
}
~
AutoChangeNumPendingSpellChecks
(
)
{
mSpellChecker
-
>
ChangeNumPendingSpellChecks
(
mDelta
)
;
}
private
:
RefPtr
<
mozInlineSpellChecker
>
mSpellChecker
;
int32_t
mDelta
;
}
;
nsresult
mozInlineSpellChecker
:
:
ResumeCheck
(
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
)
{
AutoChangeNumPendingSpellChecks
autoChangeNumPending
(
this
-
1
)
;
if
(
aStatus
-
>
IsFullSpellCheck
(
)
)
{
NS_ASSERTION
(
mFullSpellCheckScheduled
"
How
could
this
be
false
?
The
full
spell
check
is
"
"
calling
us
!
!
"
)
;
mFullSpellCheckScheduled
=
false
;
}
if
(
!
mSpellCheck
)
return
NS_OK
;
if
(
!
mTextEditor
)
{
return
NS_OK
;
}
mozInlineSpellWordUtil
wordUtil
;
nsresult
rv
=
wordUtil
.
Init
(
mTextEditor
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_OK
;
RefPtr
<
Selection
>
spellCheckSelection
=
GetSpellCheckSelection
(
)
;
if
(
NS_WARN_IF
(
!
spellCheckSelection
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
currentDictionary
;
rv
=
mSpellCheck
-
>
GetCurrentDictionary
(
currentDictionary
)
;
if
(
NS_FAILED
(
rv
)
)
{
int32_t
count
=
spellCheckSelection
-
>
RangeCount
(
)
;
for
(
int32_t
index
=
count
-
1
;
index
>
=
0
;
index
-
-
)
{
nsRange
*
checkRange
=
spellCheckSelection
-
>
GetRangeAt
(
index
)
;
if
(
checkRange
)
{
RemoveRange
(
spellCheckSelection
checkRange
)
;
}
}
return
NS_OK
;
}
CleanupRangesInSelection
(
spellCheckSelection
)
;
rv
=
aStatus
-
>
FinishInitOnEvent
(
wordUtil
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
aStatus
-
>
mRange
)
return
NS_OK
;
bool
doneChecking
=
true
;
if
(
aStatus
-
>
mOp
=
=
mozInlineSpellStatus
:
:
eOpSelection
)
rv
=
DoSpellCheckSelection
(
wordUtil
spellCheckSelection
)
;
else
rv
=
DoSpellCheck
(
wordUtil
spellCheckSelection
aStatus
&
doneChecking
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
doneChecking
)
rv
=
ScheduleSpellCheck
(
Move
(
aStatus
)
)
;
return
rv
;
}
nsresult
mozInlineSpellChecker
:
:
IsPointInSelection
(
nsISelection
*
aSelection
nsIDOMNode
*
aNode
int32_t
aOffset
nsIDOMRange
*
*
aRange
)
{
*
aRange
=
nullptr
;
nsCOMPtr
<
nsISelectionPrivate
>
privSel
(
do_QueryInterface
(
aSelection
)
)
;
nsTArray
<
nsRange
*
>
ranges
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
nsresult
rv
=
privSel
-
>
GetRangesForIntervalArray
(
node
aOffset
node
aOffset
true
&
ranges
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
ranges
.
Length
(
)
=
=
0
)
return
NS_OK
;
NS_ADDREF
(
*
aRange
=
ranges
[
0
]
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
CleanupRangesInSelection
(
Selection
*
aSelection
)
{
if
(
!
aSelection
)
return
NS_ERROR_FAILURE
;
int32_t
count
=
aSelection
-
>
RangeCount
(
)
;
for
(
int32_t
index
=
0
;
index
<
count
;
index
+
+
)
{
nsRange
*
checkRange
=
aSelection
-
>
GetRangeAt
(
index
)
;
if
(
checkRange
)
{
if
(
checkRange
-
>
Collapsed
(
)
)
{
RemoveRange
(
aSelection
checkRange
)
;
index
-
-
;
count
-
-
;
}
}
}
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
RemoveRange
(
Selection
*
aSpellCheckSelection
nsRange
*
aRange
)
{
NS_ENSURE_ARG_POINTER
(
aSpellCheckSelection
)
;
NS_ENSURE_ARG_POINTER
(
aRange
)
;
ErrorResult
rv
;
aSpellCheckSelection
-
>
RemoveRange
(
*
aRange
rv
)
;
if
(
!
rv
.
Failed
(
)
&
&
mNumWordsInSpellSelection
)
mNumWordsInSpellSelection
-
-
;
return
rv
.
StealNSResult
(
)
;
}
nsresult
mozInlineSpellChecker
:
:
AddRange
(
Selection
*
aSpellCheckSelection
nsRange
*
aRange
)
{
NS_ENSURE_ARG_POINTER
(
aSpellCheckSelection
)
;
NS_ENSURE_ARG_POINTER
(
aRange
)
;
nsresult
rv
=
NS_OK
;
if
(
!
SpellCheckSelectionIsFull
(
)
)
{
IgnoredErrorResult
err
;
aSpellCheckSelection
-
>
AddRange
(
*
aRange
err
)
;
if
(
err
.
Failed
(
)
)
{
rv
=
err
.
StealNSResult
(
)
;
}
else
{
mNumWordsInSpellSelection
+
+
;
}
}
return
rv
;
}
already_AddRefed
<
Selection
>
mozInlineSpellChecker
:
:
GetSpellCheckSelection
(
)
{
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
nullptr
;
}
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
SelectionType
:
:
eSpellCheck
)
;
if
(
!
selection
)
{
return
nullptr
;
}
return
selection
.
forget
(
)
;
}
nsresult
mozInlineSpellChecker
:
:
SaveCurrentSelectionPosition
(
)
{
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
mCurrentSelectionAnchorNode
=
selection
-
>
GetFocusNode
(
)
;
mCurrentSelectionOffset
=
selection
-
>
FocusOffset
(
)
;
return
NS_OK
;
}
bool
ContentIsDescendantOf
(
nsINode
*
aPossibleDescendant
nsINode
*
aPossibleAncestor
)
{
NS_PRECONDITION
(
aPossibleDescendant
"
The
possible
descendant
is
null
!
"
)
;
NS_PRECONDITION
(
aPossibleAncestor
"
The
possible
ancestor
is
null
!
"
)
;
do
{
if
(
aPossibleDescendant
=
=
aPossibleAncestor
)
return
true
;
aPossibleDescendant
=
aPossibleDescendant
-
>
GetParentNode
(
)
;
}
while
(
aPossibleDescendant
)
;
return
false
;
}
nsresult
mozInlineSpellChecker
:
:
HandleNavigationEvent
(
bool
aForceWordSpellCheck
int32_t
aNewPositionOffset
)
{
nsresult
rv
;
if
(
!
mNeedsCheckAfterNavigation
)
return
NS_OK
;
nsCOMPtr
<
nsINode
>
currentAnchorNode
=
mCurrentSelectionAnchorNode
;
uint32_t
currentAnchorOffset
=
mCurrentSelectionOffset
;
rv
=
SaveCurrentSelectionPosition
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
shouldPost
;
auto
status
=
MakeUnique
<
mozInlineSpellStatus
>
(
this
)
;
rv
=
status
-
>
InitForNavigation
(
aForceWordSpellCheck
aNewPositionOffset
currentAnchorNode
currentAnchorOffset
mCurrentSelectionAnchorNode
mCurrentSelectionOffset
&
shouldPost
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
shouldPost
)
{
rv
=
ScheduleSpellCheck
(
Move
(
status
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
HandleEvent
(
Event
*
aEvent
)
{
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
blur
"
)
)
{
return
OnBlur
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
click
"
)
)
{
return
OnMouseClick
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
keypress
"
)
)
{
return
OnKeyPress
(
aEvent
)
;
}
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
OnBlur
(
Event
*
aEvent
)
{
HandleNavigationEvent
(
true
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
OnMouseClick
(
Event
*
aMouseEvent
)
{
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_OK
)
;
HandleNavigationEvent
(
mouseEvent
-
>
Button
(
)
!
=
0
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
OnKeyPress
(
Event
*
aKeyEvent
)
{
RefPtr
<
KeyboardEvent
>
keyEvent
=
aKeyEvent
-
>
AsKeyboardEvent
(
)
;
NS_ENSURE_TRUE
(
keyEvent
NS_OK
)
;
uint32_t
keyCode
=
keyEvent
-
>
KeyCode
(
)
;
switch
(
keyCode
)
{
case
KeyboardEventBinding
:
:
DOM_VK_RIGHT
:
case
KeyboardEventBinding
:
:
DOM_VK_LEFT
:
HandleNavigationEvent
(
false
keyCode
=
=
KeyboardEventBinding
:
:
DOM_VK_RIGHT
?
1
:
-
1
)
;
break
;
case
KeyboardEventBinding
:
:
DOM_VK_UP
:
case
KeyboardEventBinding
:
:
DOM_VK_DOWN
:
case
KeyboardEventBinding
:
:
DOM_VK_HOME
:
case
KeyboardEventBinding
:
:
DOM_VK_END
:
case
KeyboardEventBinding
:
:
DOM_VK_PAGE_UP
:
case
KeyboardEventBinding
:
:
DOM_VK_PAGE_DOWN
:
HandleNavigationEvent
(
true
)
;
break
;
}
return
NS_OK
;
}
class
UpdateCurrentDictionaryCallback
final
:
public
nsIEditorSpellCheckCallback
{
public
:
NS_DECL_ISUPPORTS
explicit
UpdateCurrentDictionaryCallback
(
mozInlineSpellChecker
*
aSpellChecker
uint32_t
aDisabledAsyncToken
)
:
mSpellChecker
(
aSpellChecker
)
mDisabledAsyncToken
(
aDisabledAsyncToken
)
{
}
NS_IMETHOD
EditorSpellCheckDone
(
)
override
{
return
mSpellChecker
-
>
mDisabledAsyncToken
>
mDisabledAsyncToken
?
NS_OK
:
mSpellChecker
-
>
CurrentDictionaryUpdated
(
)
;
}
private
:
~
UpdateCurrentDictionaryCallback
(
)
{
}
RefPtr
<
mozInlineSpellChecker
>
mSpellChecker
;
uint32_t
mDisabledAsyncToken
;
}
;
NS_IMPL_ISUPPORTS
(
UpdateCurrentDictionaryCallback
nsIEditorSpellCheckCallback
)
NS_IMETHODIMP
mozInlineSpellChecker
:
:
UpdateCurrentDictionary
(
)
{
RefPtr
<
EditorSpellCheck
>
spellCheck
=
mSpellCheck
?
mSpellCheck
:
mPendingSpellCheck
;
if
(
!
spellCheck
)
{
return
NS_OK
;
}
RefPtr
<
UpdateCurrentDictionaryCallback
>
cb
=
new
UpdateCurrentDictionaryCallback
(
this
mDisabledAsyncToken
)
;
NS_ENSURE_STATE
(
cb
)
;
nsresult
rv
=
spellCheck
-
>
UpdateCurrentDictionary
(
cb
)
;
if
(
NS_FAILED
(
rv
)
)
{
cb
=
nullptr
;
return
rv
;
}
mNumPendingUpdateCurrentDictionary
+
+
;
ChangeNumPendingSpellChecks
(
1
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
CurrentDictionaryUpdated
(
)
{
mNumPendingUpdateCurrentDictionary
-
-
;
NS_ASSERTION
(
mNumPendingUpdateCurrentDictionary
>
=
0
"
CurrentDictionaryUpdated
called
without
corresponding
"
"
UpdateCurrentDictionary
call
!
"
)
;
ChangeNumPendingSpellChecks
(
-
1
)
;
nsresult
rv
=
SpellCheckRange
(
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetSpellCheckPending
(
bool
*
aPending
)
{
*
aPending
=
mNumPendingSpellChecks
>
0
;
return
NS_OK
;
}
