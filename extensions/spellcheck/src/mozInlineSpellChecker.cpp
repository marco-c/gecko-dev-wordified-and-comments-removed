#
include
"
mozInlineSpellChecker
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorSpellCheck
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozInlineSpellWordUtil
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
prtime
.
h
"
using
mozilla
:
:
LogLevel
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
#
define
INLINESPELL_CHECK_TIMEOUT
1
#
define
INLINESPELL_MINIMUM_WORDS_BEFORE_TIMEOUT
5
#
define
INLINESPELL_MAXIMUM_CHUNKED_WORDS_PER_TASK
25
#
define
INLINESPELL_STARTED_TOPIC
"
inlineSpellChecker
-
spellCheck
-
started
"
#
define
INLINESPELL_ENDED_TOPIC
"
inlineSpellChecker
-
spellCheck
-
ended
"
static
mozilla
:
:
LazyLogModule
sInlineSpellCheckerLog
(
"
InlineSpellChecker
"
)
;
static
const
char
kMaxSpellCheckSelectionSize
[
]
=
"
extensions
.
spellcheck
.
inline
.
max
-
misspellings
"
;
static
const
PRTime
kMaxSpellCheckTimeInUsec
=
INLINESPELL_CHECK_TIMEOUT
*
PR_USEC_PER_MSEC
;
mozInlineSpellStatus
:
:
mozInlineSpellStatus
(
mozInlineSpellChecker
*
aSpellChecker
)
:
mSpellChecker
(
aSpellChecker
)
{
}
Result
<
UniquePtr
<
mozInlineSpellStatus
>
nsresult
>
mozInlineSpellStatus
:
:
CreateForEditorChange
(
mozInlineSpellChecker
&
aSpellChecker
EditSubAction
aEditSubAction
nsINode
*
aAnchorNode
uint32_t
aAnchorOffset
nsINode
*
aPreviousNode
uint32_t
aPreviousOffset
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
)
{
if
(
NS_WARN_IF
(
!
aAnchorNode
)
|
|
NS_WARN_IF
(
!
aPreviousNode
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
UniquePtr
<
mozInlineSpellStatus
>
status
{
new
mozInlineSpellStatus
{
&
aSpellChecker
}
}
;
status
-
>
mAnchorRange
=
status
-
>
PositionToCollapsedRange
(
aAnchorNode
aAnchorOffset
)
;
if
(
NS_WARN_IF
(
!
status
-
>
mAnchorRange
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
bool
deleted
=
aEditSubAction
=
=
EditSubAction
:
:
eDeleteSelectedContent
;
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
deleted
=
!
aPreviousNode
-
>
IsInComposedDoc
(
)
;
}
if
(
deleted
)
{
status
-
>
mOp
=
eOpChangeDelete
;
status
-
>
mRange
=
nullptr
;
return
status
;
}
status
-
>
mOp
=
eOpChange
;
status
-
>
mRange
=
nsRange
:
:
Create
(
aPreviousNode
)
;
ErrorResult
errorResult
;
int16_t
cmpResult
=
status
-
>
mAnchorRange
-
>
ComparePoint
(
*
aPreviousNode
aPreviousOffset
errorResult
)
;
if
(
NS_WARN_IF
(
errorResult
.
Failed
(
)
)
)
{
return
Err
(
errorResult
.
StealNSResult
(
)
)
;
}
nsresult
rv
;
if
(
cmpResult
<
0
)
{
rv
=
status
-
>
mRange
-
>
SetStartAndEnd
(
aPreviousNode
aPreviousOffset
aAnchorNode
aAnchorOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
}
else
{
rv
=
status
-
>
mRange
-
>
SetStartAndEnd
(
aAnchorNode
aAnchorOffset
aPreviousNode
aPreviousOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
)
{
status
-
>
mCreatedRange
=
status
-
>
mRange
;
}
if
(
aStartNode
&
&
aEndNode
)
{
cmpResult
=
status
-
>
mRange
-
>
ComparePoint
(
*
aStartNode
aStartOffset
errorResult
)
;
if
(
NS_WARN_IF
(
errorResult
.
Failed
(
)
)
)
{
return
Err
(
errorResult
.
StealNSResult
(
)
)
;
}
if
(
cmpResult
<
0
)
{
rv
=
status
-
>
mRange
-
>
SetStart
(
aStartNode
aStartOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
}
cmpResult
=
status
-
>
mRange
-
>
ComparePoint
(
*
aEndNode
aEndOffset
errorResult
)
;
if
(
NS_WARN_IF
(
errorResult
.
Failed
(
)
)
)
{
return
Err
(
errorResult
.
StealNSResult
(
)
)
;
}
if
(
cmpResult
>
0
)
{
rv
=
status
-
>
mRange
-
>
SetEnd
(
aEndNode
aEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
}
}
return
status
;
}
Result
<
UniquePtr
<
mozInlineSpellStatus
>
nsresult
>
mozInlineSpellStatus
:
:
CreateForNavigation
(
mozInlineSpellChecker
&
aSpellChecker
bool
aForceCheck
int32_t
aNewPositionOffset
nsINode
*
aOldAnchorNode
uint32_t
aOldAnchorOffset
nsINode
*
aNewAnchorNode
uint32_t
aNewAnchorOffset
bool
*
aContinue
)
{
UniquePtr
<
mozInlineSpellStatus
>
status
{
new
mozInlineSpellStatus
{
&
aSpellChecker
}
}
;
status
-
>
mOp
=
eOpNavigation
;
status
-
>
mForceNavigationWordCheck
=
aForceCheck
;
status
-
>
mNewNavigationPositionOffset
=
aNewPositionOffset
;
TextEditor
*
textEditor
=
status
-
>
mSpellChecker
-
>
mTextEditor
;
if
(
NS_WARN_IF
(
!
textEditor
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
Element
*
root
=
textEditor
-
>
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
root
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
root
&
&
aOldAnchorNode
&
&
!
aOldAnchorNode
-
>
IsShadowIncludingInclusiveDescendantOf
(
root
)
)
{
*
aContinue
=
false
;
return
status
;
}
status
-
>
mOldNavigationAnchorRange
=
status
-
>
PositionToCollapsedRange
(
aOldAnchorNode
aOldAnchorOffset
)
;
if
(
NS_WARN_IF
(
!
status
-
>
mOldNavigationAnchorRange
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
status
-
>
mAnchorRange
=
status
-
>
PositionToCollapsedRange
(
aNewAnchorNode
aNewAnchorOffset
)
;
if
(
NS_WARN_IF
(
!
status
-
>
mAnchorRange
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
*
aContinue
=
true
;
return
status
;
}
UniquePtr
<
mozInlineSpellStatus
>
mozInlineSpellStatus
:
:
CreateForSelection
(
mozInlineSpellChecker
&
aSpellChecker
)
{
UniquePtr
<
mozInlineSpellStatus
>
status
{
new
mozInlineSpellStatus
{
&
aSpellChecker
}
}
;
status
-
>
mOp
=
eOpSelection
;
return
status
;
}
UniquePtr
<
mozInlineSpellStatus
>
mozInlineSpellStatus
:
:
CreateForRange
(
mozInlineSpellChecker
&
aSpellChecker
nsRange
*
aRange
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
:
range
=
%
p
"
__FUNCTION__
aRange
)
)
;
UniquePtr
<
mozInlineSpellStatus
>
status
{
new
mozInlineSpellStatus
{
&
aSpellChecker
}
}
;
status
-
>
mOp
=
eOpChange
;
status
-
>
mRange
=
aRange
;
return
status
;
}
nsresult
mozInlineSpellStatus
:
:
FinishInitOnEvent
(
mozInlineSpellWordUtil
&
aWordUtil
)
{
nsresult
rv
;
if
(
!
mRange
)
{
rv
=
mSpellChecker
-
>
MakeSpellCheckRange
(
nullptr
0
nullptr
0
getter_AddRefs
(
mRange
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
switch
(
mOp
)
{
case
eOpChange
:
if
(
mAnchorRange
)
return
FillNoCheckRangeFromAnchor
(
aWordUtil
)
;
break
;
case
eOpChangeDelete
:
if
(
mAnchorRange
)
{
rv
=
FillNoCheckRangeFromAnchor
(
aWordUtil
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mRange
=
mNoCheckRange
;
break
;
case
eOpNavigation
:
return
FinishNavigationEvent
(
aWordUtil
)
;
case
eOpSelection
:
break
;
case
eOpResume
:
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Bad
operation
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
return
NS_OK
;
}
nsresult
mozInlineSpellStatus
:
:
FinishNavigationEvent
(
mozInlineSpellWordUtil
&
aWordUtil
)
{
RefPtr
<
TextEditor
>
textEditor
=
mSpellChecker
-
>
mTextEditor
;
if
(
!
textEditor
)
{
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
mAnchorRange
"
No
anchor
for
navigation
!
"
)
;
if
(
!
mOldNavigationAnchorRange
-
>
IsPositioned
(
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsINode
>
oldAnchorNode
=
mOldNavigationAnchorRange
-
>
GetStartContainer
(
)
;
uint32_t
oldAnchorOffset
=
mOldNavigationAnchorRange
-
>
StartOffset
(
)
;
RefPtr
<
nsRange
>
oldWord
;
nsresult
rv
=
aWordUtil
.
GetRangeForWord
(
oldAnchorNode
static_cast
<
int32_t
>
(
oldAnchorOffset
)
getter_AddRefs
(
oldWord
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mSpellChecker
-
>
mTextEditor
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
newAnchorNode
=
mAnchorRange
-
>
GetStartContainer
(
)
;
uint32_t
newAnchorOffset
=
mAnchorRange
-
>
StartOffset
(
)
;
bool
isInRange
=
false
;
if
(
!
mForceNavigationWordCheck
)
{
ErrorResult
err
;
isInRange
=
oldWord
-
>
IsPointInRange
(
*
newAnchorNode
newAnchorOffset
+
mNewNavigationPositionOffset
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
}
if
(
isInRange
)
{
mRange
=
nullptr
;
}
else
{
mRange
=
oldWord
;
mSpellChecker
-
>
mNeedsCheckAfterNavigation
=
false
;
}
return
NS_OK
;
}
nsresult
mozInlineSpellStatus
:
:
FillNoCheckRangeFromAnchor
(
mozInlineSpellWordUtil
&
aWordUtil
)
{
if
(
!
mAnchorRange
-
>
IsPositioned
(
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsINode
>
anchorNode
=
mAnchorRange
-
>
GetStartContainer
(
)
;
uint32_t
anchorOffset
=
mAnchorRange
-
>
StartOffset
(
)
;
return
aWordUtil
.
GetRangeForWord
(
anchorNode
static_cast
<
int32_t
>
(
anchorOffset
)
getter_AddRefs
(
mNoCheckRange
)
)
;
}
Document
*
mozInlineSpellStatus
:
:
GetDocument
(
)
const
{
if
(
!
mSpellChecker
-
>
mTextEditor
)
{
return
nullptr
;
}
return
mSpellChecker
-
>
mTextEditor
-
>
GetDocument
(
)
;
}
already_AddRefed
<
nsRange
>
mozInlineSpellStatus
:
:
PositionToCollapsedRange
(
nsINode
*
aNode
uint32_t
aOffset
)
{
if
(
NS_WARN_IF
(
!
aNode
)
|
|
NS_WARN_IF
(
!
GetDocument
(
)
)
)
{
return
nullptr
;
}
IgnoredErrorResult
ignoredError
;
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aNode
aOffset
aNode
aOffset
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Creating
collapsed
range
failed
"
)
;
return
range
.
forget
(
)
;
}
class
mozInlineSpellResume
:
public
Runnable
{
public
:
mozInlineSpellResume
(
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
uint32_t
aDisabledAsyncToken
)
:
Runnable
(
"
mozInlineSpellResume
"
)
mDisabledAsyncToken
(
aDisabledAsyncToken
)
mStatus
(
std
:
:
move
(
aStatus
)
)
{
}
nsresult
Post
(
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
this
)
;
return
NS_DispatchToCurrentThreadQueue
(
runnable
.
forget
(
)
1000
EventQueuePriority
:
:
Idle
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mDisabledAsyncToken
=
=
mStatus
-
>
mSpellChecker
-
>
mDisabledAsyncToken
)
{
mStatus
-
>
mSpellChecker
-
>
ResumeCheck
(
std
:
:
move
(
mStatus
)
)
;
}
return
NS_OK
;
}
private
:
uint32_t
mDisabledAsyncToken
;
UniquePtr
<
mozInlineSpellStatus
>
mStatus
;
}
;
class
InitEditorSpellCheckCallback
final
:
public
nsIEditorSpellCheckCallback
{
~
InitEditorSpellCheckCallback
(
)
{
}
public
:
NS_DECL_ISUPPORTS
explicit
InitEditorSpellCheckCallback
(
mozInlineSpellChecker
*
aSpellChecker
)
:
mSpellChecker
(
aSpellChecker
)
{
}
NS_IMETHOD
EditorSpellCheckDone
(
)
override
{
return
mSpellChecker
?
mSpellChecker
-
>
EditorSpellCheckInited
(
)
:
NS_OK
;
}
void
Cancel
(
)
{
mSpellChecker
=
nullptr
;
}
private
:
RefPtr
<
mozInlineSpellChecker
>
mSpellChecker
;
}
;
NS_IMPL_ISUPPORTS
(
InitEditorSpellCheckCallback
nsIEditorSpellCheckCallback
)
NS_INTERFACE_MAP_BEGIN
(
mozInlineSpellChecker
)
NS_INTERFACE_MAP_ENTRY
(
nsIInlineSpellChecker
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
mozInlineSpellChecker
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
mozInlineSpellChecker
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
mozInlineSpellChecker
)
NS_IMPL_CYCLE_COLLECTION_WEAK
(
mozInlineSpellChecker
mTextEditor
mSpellCheck
mCurrentSelectionAnchorNode
)
mozInlineSpellChecker
:
:
SpellCheckingState
mozInlineSpellChecker
:
:
gCanEnableSpellChecking
=
mozInlineSpellChecker
:
:
SpellCheck_Uninitialized
;
mozInlineSpellChecker
:
:
mozInlineSpellChecker
(
)
:
mNumWordsInSpellSelection
(
0
)
mMaxNumWordsInSpellSelection
(
250
)
mNumPendingSpellChecks
(
0
)
mNumPendingUpdateCurrentDictionary
(
0
)
mDisabledAsyncToken
(
0
)
mNeedsCheckAfterNavigation
(
false
)
mFullSpellCheckScheduled
(
false
)
mIsListeningToEditSubActions
(
false
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefs
)
prefs
-
>
GetIntPref
(
kMaxSpellCheckSelectionSize
&
mMaxNumWordsInSpellSelection
)
;
}
mozInlineSpellChecker
:
:
~
mozInlineSpellChecker
(
)
{
}
EditorSpellCheck
*
mozInlineSpellChecker
:
:
GetEditorSpellCheck
(
)
{
return
mSpellCheck
?
mSpellCheck
:
mPendingSpellCheck
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetSpellChecker
(
nsIEditorSpellCheck
*
*
aSpellCheck
)
{
*
aSpellCheck
=
mSpellCheck
;
NS_IF_ADDREF
(
*
aSpellCheck
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
Init
(
nsIEditor
*
aEditor
)
{
mTextEditor
=
aEditor
?
aEditor
-
>
AsTextEditor
(
)
:
nullptr
;
return
NS_OK
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
mozInlineSpellChecker
:
:
Cleanup
(
bool
aDestroyingFrames
)
{
mNumWordsInSpellSelection
=
0
;
RefPtr
<
Selection
>
spellCheckSelection
=
GetSpellCheckSelection
(
)
;
nsresult
rv
=
NS_OK
;
if
(
!
spellCheckSelection
)
{
UnregisterEventListeners
(
)
;
rv
=
NS_ERROR_FAILURE
;
}
else
{
if
(
!
aDestroyingFrames
)
{
spellCheckSelection
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
}
rv
=
UnregisterEventListeners
(
)
;
}
RefPtr
<
TextEditor
>
textEditor
=
std
:
:
move
(
mTextEditor
)
;
if
(
mPendingSpellCheck
)
{
mPendingSpellCheck
=
nullptr
;
mPendingInitEditorSpellCheckCallback
-
>
Cancel
(
)
;
mPendingInitEditorSpellCheckCallback
=
nullptr
;
ChangeNumPendingSpellChecks
(
-
1
textEditor
)
;
}
mDisabledAsyncToken
+
+
;
if
(
mNumPendingUpdateCurrentDictionary
>
0
)
{
ChangeNumPendingSpellChecks
(
-
mNumPendingUpdateCurrentDictionary
textEditor
)
;
mNumPendingUpdateCurrentDictionary
=
0
;
}
if
(
mNumPendingSpellChecks
>
0
)
{
ChangeNumPendingSpellChecks
(
-
mNumPendingSpellChecks
textEditor
)
;
}
mFullSpellCheckScheduled
=
false
;
return
rv
;
}
bool
mozInlineSpellChecker
:
:
CanEnableInlineSpellChecking
(
)
{
if
(
gCanEnableSpellChecking
=
=
SpellCheck_Uninitialized
)
{
gCanEnableSpellChecking
=
SpellCheck_NotAvailable
;
nsCOMPtr
<
nsIEditorSpellCheck
>
spellchecker
=
new
EditorSpellCheck
(
)
;
bool
canSpellCheck
=
false
;
nsresult
rv
=
spellchecker
-
>
CanSpellCheck
(
&
canSpellCheck
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
canSpellCheck
)
gCanEnableSpellChecking
=
SpellCheck_Available
;
}
return
(
gCanEnableSpellChecking
=
=
SpellCheck_Available
)
;
}
void
mozInlineSpellChecker
:
:
UpdateCanEnableInlineSpellChecking
(
)
{
gCanEnableSpellChecking
=
SpellCheck_Uninitialized
;
}
nsresult
mozInlineSpellChecker
:
:
RegisterEventListeners
(
)
{
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
StartToListenToEditSubActions
(
)
;
RefPtr
<
Document
>
doc
=
mTextEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
doc
-
>
AddEventListener
(
u
"
blur
"
_ns
this
true
false
)
;
doc
-
>
AddEventListener
(
u
"
click
"
_ns
this
false
false
)
;
doc
-
>
AddEventListener
(
u
"
keypress
"
_ns
this
false
false
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
UnregisterEventListeners
(
)
{
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
EndListeningToEditSubActions
(
)
;
RefPtr
<
Document
>
doc
=
mTextEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
doc
-
>
RemoveEventListener
(
u
"
blur
"
_ns
this
true
)
;
doc
-
>
RemoveEventListener
(
u
"
click
"
_ns
this
false
)
;
doc
-
>
RemoveEventListener
(
u
"
keypress
"
_ns
this
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetEnableRealTimeSpell
(
bool
*
aEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aEnabled
)
;
*
aEnabled
=
mSpellCheck
!
=
nullptr
|
|
mPendingSpellCheck
!
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
SetEnableRealTimeSpell
(
bool
aEnabled
)
{
if
(
!
aEnabled
)
{
mSpellCheck
=
nullptr
;
return
Cleanup
(
false
)
;
}
if
(
mSpellCheck
)
{
return
SpellCheckRange
(
nullptr
)
;
}
if
(
mPendingSpellCheck
)
{
return
NS_OK
;
}
mPendingSpellCheck
=
new
EditorSpellCheck
(
)
;
mPendingSpellCheck
-
>
SetFilterType
(
nsIEditorSpellCheck
:
:
FILTERTYPE_MAIL
)
;
mPendingInitEditorSpellCheckCallback
=
new
InitEditorSpellCheckCallback
(
this
)
;
nsresult
rv
=
mPendingSpellCheck
-
>
InitSpellChecker
(
mTextEditor
false
mPendingInitEditorSpellCheckCallback
)
;
if
(
NS_FAILED
(
rv
)
)
{
mPendingSpellCheck
=
nullptr
;
mPendingInitEditorSpellCheckCallback
=
nullptr
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
ChangeNumPendingSpellChecks
(
1
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
EditorSpellCheckInited
(
)
{
NS_ASSERTION
(
mPendingSpellCheck
"
Spell
check
should
be
pending
!
"
)
;
RegisterEventListeners
(
)
;
mSpellCheck
=
mPendingSpellCheck
;
mPendingSpellCheck
=
nullptr
;
mPendingInitEditorSpellCheckCallback
=
nullptr
;
ChangeNumPendingSpellChecks
(
-
1
)
;
return
SpellCheckRange
(
nullptr
)
;
}
void
mozInlineSpellChecker
:
:
ChangeNumPendingSpellChecks
(
int32_t
aDelta
TextEditor
*
aTextEditor
)
{
int8_t
oldNumPending
=
mNumPendingSpellChecks
;
mNumPendingSpellChecks
+
=
aDelta
;
NS_ASSERTION
(
mNumPendingSpellChecks
>
=
0
"
Unbalanced
ChangeNumPendingSpellChecks
calls
!
"
)
;
if
(
oldNumPending
=
=
0
&
&
mNumPendingSpellChecks
>
0
)
{
NotifyObservers
(
INLINESPELL_STARTED_TOPIC
aTextEditor
)
;
}
else
if
(
oldNumPending
>
0
&
&
mNumPendingSpellChecks
=
=
0
)
{
NotifyObservers
(
INLINESPELL_ENDED_TOPIC
aTextEditor
)
;
}
}
void
mozInlineSpellChecker
:
:
NotifyObservers
(
const
char
*
aTopic
TextEditor
*
aTextEditor
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
return
;
RefPtr
<
TextEditor
>
textEditor
=
aTextEditor
?
aTextEditor
:
mTextEditor
.
get
(
)
;
os
-
>
NotifyObservers
(
static_cast
<
nsIEditor
*
>
(
textEditor
.
get
(
)
)
aTopic
nullptr
)
;
}
nsresult
mozInlineSpellChecker
:
:
SpellCheckAfterEditorChange
(
EditSubAction
aEditSubAction
Selection
&
aSelection
nsINode
*
aPreviousSelectedNode
uint32_t
aPreviousSelectedOffset
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
)
{
nsresult
rv
;
if
(
!
mSpellCheck
)
return
NS_OK
;
mNeedsCheckAfterNavigation
=
true
;
Result
<
UniquePtr
<
mozInlineSpellStatus
>
nsresult
>
res
=
mozInlineSpellStatus
:
:
CreateForEditorChange
(
*
this
aEditSubAction
aSelection
.
GetAnchorNode
(
)
aSelection
.
AnchorOffset
(
)
aPreviousSelectedNode
aPreviousSelectedOffset
aStartNode
aStartOffset
aEndNode
aEndOffset
)
;
if
(
NS_WARN_IF
(
res
.
isErr
(
)
)
)
{
return
res
.
unwrapErr
(
)
;
}
rv
=
ScheduleSpellCheck
(
res
.
unwrap
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SaveCurrentSelectionPosition
(
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
SpellCheckRange
(
nsRange
*
aRange
)
{
if
(
!
mSpellCheck
)
{
NS_WARNING_ASSERTION
(
mPendingSpellCheck
"
Trying
to
spellcheck
but
checking
seems
to
be
disabled
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForRange
(
*
this
aRange
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetMisspelledWord
(
nsINode
*
aNode
int32_t
aOffset
nsRange
*
*
newword
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Selection
>
spellCheckSelection
=
GetSpellCheckSelection
(
)
;
if
(
NS_WARN_IF
(
!
spellCheckSelection
)
)
{
return
NS_ERROR_FAILURE
;
}
return
IsPointInSelection
(
*
spellCheckSelection
aNode
aOffset
newword
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
ReplaceWord
(
nsINode
*
aNode
int32_t
aOffset
const
nsAString
&
aNewWord
)
{
if
(
NS_WARN_IF
(
!
mTextEditor
)
|
|
NS_WARN_IF
(
aNewWord
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsRange
>
range
;
nsresult
res
=
GetMisspelledWord
(
aNode
aOffset
getter_AddRefs
(
range
)
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
!
range
)
{
return
NS_OK
;
}
nsString
newWord
(
aNewWord
)
;
if
(
!
mTextEditor
-
>
AsHTMLEditor
(
)
)
{
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
newWord
)
;
}
RefPtr
<
TextEditor
>
textEditor
(
mTextEditor
)
;
DebugOnly
<
nsresult
>
rv
=
textEditor
-
>
ReplaceTextAsAction
(
newWord
range
TextEditor
:
:
AllowBeforeInputEventCancelable
:
:
Yes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
the
new
word
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
AddWordToDictionary
(
const
nsAString
&
word
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
mSpellCheck
-
>
AddWordToDictionary
(
word
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForSelection
(
*
this
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
RemoveWordFromDictionary
(
const
nsAString
&
word
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
mSpellCheck
-
>
RemoveWordFromDictionary
(
word
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForRange
(
*
this
nullptr
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
IgnoreWord
(
const
nsAString
&
word
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
mSpellCheck
-
>
IgnoreWordAllOccurrences
(
word
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForSelection
(
*
this
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
IgnoreWords
(
const
nsTArray
<
nsString
>
&
aWordsToIgnore
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
for
(
auto
&
word
:
aWordsToIgnore
)
{
mSpellCheck
-
>
IgnoreWordAllOccurrences
(
word
)
;
}
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForSelection
(
*
this
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
void
mozInlineSpellChecker
:
:
DidSplitNode
(
nsINode
*
aExistingRightNode
nsINode
*
aNewLeftNode
)
{
if
(
!
mIsListeningToEditSubActions
)
{
return
;
}
SpellCheckBetweenNodes
(
aNewLeftNode
0
aNewLeftNode
0
)
;
}
void
mozInlineSpellChecker
:
:
DidJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
if
(
!
mIsListeningToEditSubActions
)
{
return
;
}
SpellCheckBetweenNodes
(
&
aRightNode
0
&
aRightNode
0
)
;
}
nsresult
mozInlineSpellChecker
:
:
MakeSpellCheckRange
(
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
nsRange
*
*
aRange
)
{
nsresult
rv
;
*
aRange
=
nullptr
;
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Document
>
doc
=
mTextEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
doc
)
;
if
(
!
aStartNode
|
|
!
aEndNode
)
{
Element
*
domRootElement
=
mTextEditor
-
>
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
domRootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
aStartNode
=
aEndNode
=
domRootElement
;
aStartOffset
=
0
;
aEndOffset
=
-
1
;
}
if
(
aEndOffset
=
=
-
1
)
{
aEndOffset
=
aEndNode
-
>
ChildNodes
(
)
-
>
Length
(
)
;
}
if
(
aStartNode
=
=
aEndNode
&
&
aStartOffset
=
=
aEndOffset
)
return
NS_OK
;
if
(
aEndOffset
)
{
rv
=
range
-
>
SetStartAndEnd
(
aStartNode
aStartOffset
aEndNode
aEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
range
-
>
SetStartAndEnd
(
RawRangeBoundary
(
aStartNode
aStartOffset
)
RangeUtils
:
:
GetRawRangeBoundaryAfter
(
aEndNode
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
range
.
swap
(
*
aRange
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
SpellCheckBetweenNodes
(
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
{
RefPtr
<
nsRange
>
range
;
nsresult
rv
=
MakeSpellCheckRange
(
aStartNode
aStartOffset
aEndNode
aEndOffset
getter_AddRefs
(
range
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
range
)
return
NS_OK
;
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForRange
(
*
this
range
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
bool
mozInlineSpellChecker
:
:
ShouldSpellCheckNode
(
TextEditor
*
aTextEditor
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
aNode
-
>
IsContent
(
)
)
return
false
;
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
if
(
aTextEditor
-
>
IsMailEditor
(
)
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
while
(
parent
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
&
&
parent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
cite
eIgnoreCase
)
)
{
return
false
;
}
if
(
parent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
pre
nsGkAtoms
:
:
div
)
&
&
parent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
nsGkAtoms
:
:
mozsignature
eIgnoreCase
)
)
{
return
false
;
}
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
&
&
parent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
nsGkAtoms
:
:
mozfwcontainer
eIgnoreCase
)
)
{
return
false
;
}
parent
=
parent
-
>
GetParent
(
)
;
}
}
else
{
if
(
!
content
-
>
IsEditable
(
)
)
{
return
false
;
}
if
(
content
-
>
IsInNativeAnonymousSubtree
(
)
)
{
nsIContent
*
node
=
content
-
>
GetParent
(
)
;
while
(
node
&
&
node
-
>
IsInNativeAnonymousSubtree
(
)
)
{
node
=
node
-
>
GetParent
(
)
;
}
if
(
node
&
&
node
-
>
IsTextControlElement
(
)
)
{
return
true
;
}
}
nsIContent
*
parent
=
content
;
while
(
!
parent
-
>
IsHTMLElement
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
true
;
}
}
return
static_cast
<
nsGenericHTMLElement
*
>
(
parent
)
-
>
Spellcheck
(
)
;
}
return
true
;
}
nsresult
mozInlineSpellChecker
:
:
ScheduleSpellCheck
(
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
if
(
mFullSpellCheckScheduled
)
{
return
NS_OK
;
}
bool
isFullSpellCheck
=
aStatus
-
>
IsFullSpellCheck
(
)
;
RefPtr
<
mozInlineSpellResume
>
resume
=
new
mozInlineSpellResume
(
std
:
:
move
(
aStatus
)
mDisabledAsyncToken
)
;
NS_ENSURE_TRUE
(
resume
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
resume
-
>
Post
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
isFullSpellCheck
)
{
mFullSpellCheckScheduled
=
true
;
}
ChangeNumPendingSpellChecks
(
1
)
;
}
return
rv
;
}
nsresult
mozInlineSpellChecker
:
:
DoSpellCheckSelection
(
mozInlineSpellWordUtil
&
aWordUtil
Selection
*
aSpellCheckSelection
)
{
nsresult
rv
;
mNumWordsInSpellSelection
=
0
;
nsTArray
<
RefPtr
<
nsRange
>
>
ranges
;
int32_t
count
=
aSpellCheckSelection
-
>
RangeCount
(
)
;
for
(
int32_t
idx
=
0
;
idx
<
count
;
idx
+
+
)
{
nsRange
*
range
=
aSpellCheckSelection
-
>
GetRangeAt
(
idx
)
;
if
(
range
)
{
ranges
.
AppendElement
(
range
)
;
}
}
aSpellCheckSelection
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForRange
(
*
this
nullptr
)
;
bool
doneChecking
;
for
(
int32_t
idx
=
0
;
idx
<
count
;
idx
+
+
)
{
status
-
>
mRange
=
ranges
[
idx
]
;
rv
=
DoSpellCheck
(
aWordUtil
aSpellCheckSelection
status
&
doneChecking
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
doneChecking
"
We
gave
the
spellchecker
one
word
but
it
didn
'
t
finish
checking
?
!
?
!
"
)
;
}
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
DoSpellCheck
(
mozInlineSpellWordUtil
&
aWordUtil
Selection
*
aSpellCheckSelection
const
UniquePtr
<
mozInlineSpellStatus
>
&
aStatus
bool
*
aDoneChecking
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
*
aDoneChecking
=
true
;
if
(
NS_WARN_IF
(
!
mSpellCheck
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
SpellCheckSelectionIsFull
(
)
)
{
return
NS_OK
;
}
RefPtr
<
TextEditor
>
textEditor
=
mTextEditor
;
if
(
!
textEditor
|
|
textEditor
-
>
Destroyed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aStatus
-
>
mRange
-
>
Collapsed
(
)
)
return
NS_OK
;
int32_t
originalRangeCount
=
aSpellCheckSelection
-
>
RangeCount
(
)
;
{
nsINode
*
beginNode
=
aStatus
-
>
mRange
-
>
GetStartContainer
(
)
;
int32_t
beginOffset
=
aStatus
-
>
mRange
-
>
StartOffset
(
)
;
nsINode
*
endNode
=
aStatus
-
>
mRange
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
aStatus
-
>
mRange
-
>
EndOffset
(
)
;
const
nsINode
*
rootNode
=
aWordUtil
.
GetRootNode
(
)
;
if
(
!
beginNode
-
>
IsInComposedDoc
(
)
|
|
!
endNode
-
>
IsInComposedDoc
(
)
|
|
!
beginNode
-
>
IsShadowIncludingInclusiveDescendantOf
(
rootNode
)
|
|
!
endNode
-
>
IsShadowIncludingInclusiveDescendantOf
(
rootNode
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aWordUtil
.
SetPositionAndEnd
(
beginNode
beginOffset
endNode
endOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
}
if
(
!
mTextEditor
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
wordsChecked
=
0
;
PRTime
beginTime
=
PR_Now
(
)
;
nsTArray
<
nsString
>
words
;
nsTArray
<
NodeOffsetRange
>
checkRanges
;
nsAutoString
wordText
;
NodeOffsetRange
wordNodeOffsetRange
;
bool
dontCheckWord
;
static
const
size_t
requestChunkSize
=
INLINESPELL_MAXIMUM_CHUNKED_WORDS_PER_TASK
;
while
(
aWordUtil
.
GetNextWord
(
wordText
&
wordNodeOffsetRange
&
dontCheckWord
)
)
{
nsINode
*
beginNode
=
wordNodeOffsetRange
.
Begin
(
)
.
Node
(
)
;
nsINode
*
endNode
=
wordNodeOffsetRange
.
End
(
)
.
Node
(
)
;
int32_t
beginOffset
=
wordNodeOffsetRange
.
Begin
(
)
.
Offset
(
)
;
int32_t
endOffset
=
wordNodeOffsetRange
.
End
(
)
.
Offset
(
)
;
if
(
wordsChecked
>
=
INLINESPELL_MINIMUM_WORDS_BEFORE_TIMEOUT
&
&
PR_Now
(
)
>
PRTime
(
beginTime
+
kMaxSpellCheckTimeInUsec
)
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Verbose
(
"
%
s
:
we
have
run
out
of
time
schedule
next
round
.
"
__FUNCTION__
)
)
;
CheckCurrentWordsNoSuggest
(
aSpellCheckSelection
std
:
:
move
(
words
)
std
:
:
move
(
checkRanges
)
)
;
nsresult
rv
=
aStatus
-
>
mRange
-
>
SetStart
(
beginNode
beginOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
*
aDoneChecking
=
false
;
return
NS_OK
;
}
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
:
got
word
\
"
%
s
\
"
%
s
"
__FUNCTION__
NS_ConvertUTF16toUTF8
(
wordText
)
.
get
(
)
dontCheckWord
?
"
(
not
checking
)
"
:
"
"
)
)
;
ErrorResult
erv
;
if
(
originalRangeCount
>
0
)
{
if
(
!
aStatus
-
>
GetCreatedRange
(
)
|
|
!
aStatus
-
>
GetCreatedRange
(
)
-
>
IsPointInRange
(
*
beginNode
beginOffset
erv
)
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
:
removing
ranges
for
some
interval
.
"
__FUNCTION__
)
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
ranges
;
aSpellCheckSelection
-
>
GetRangesForInterval
(
*
beginNode
beginOffset
*
endNode
endOffset
true
ranges
erv
)
;
ENSURE_SUCCESS
(
erv
erv
.
StealNSResult
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
ranges
.
Length
(
)
;
i
+
+
)
RemoveRange
(
aSpellCheckSelection
ranges
[
i
]
)
;
}
}
if
(
dontCheckWord
)
continue
;
if
(
!
ShouldSpellCheckNode
(
textEditor
beginNode
)
)
{
continue
;
}
if
(
aStatus
-
>
GetNoCheckRange
(
)
&
&
aStatus
-
>
GetNoCheckRange
(
)
-
>
IsPointInRange
(
*
beginNode
beginOffset
erv
)
)
{
continue
;
}
mozInlineSpellWordUtil
:
:
NormalizeWord
(
wordText
)
;
words
.
AppendElement
(
wordText
)
;
checkRanges
.
AppendElement
(
wordNodeOffsetRange
)
;
wordsChecked
+
+
;
if
(
words
.
Length
(
)
>
=
requestChunkSize
)
{
CheckCurrentWordsNoSuggest
(
aSpellCheckSelection
std
:
:
move
(
words
)
std
:
:
move
(
checkRanges
)
)
;
words
=
nsTArray
<
nsString
>
(
)
;
checkRanges
=
nsTArray
<
NodeOffsetRange
>
(
)
;
}
}
CheckCurrentWordsNoSuggest
(
aSpellCheckSelection
std
:
:
move
(
words
)
std
:
:
move
(
checkRanges
)
)
;
return
NS_OK
;
}
class
MOZ_RAII
AutoChangeNumPendingSpellChecks
final
{
public
:
explicit
AutoChangeNumPendingSpellChecks
(
mozInlineSpellChecker
*
aSpellChecker
int32_t
aDelta
)
:
mSpellChecker
(
aSpellChecker
)
mDelta
(
aDelta
)
{
}
~
AutoChangeNumPendingSpellChecks
(
)
{
mSpellChecker
-
>
ChangeNumPendingSpellChecks
(
mDelta
)
;
}
private
:
RefPtr
<
mozInlineSpellChecker
>
mSpellChecker
;
int32_t
mDelta
;
}
;
void
mozInlineSpellChecker
:
:
CheckCurrentWordsNoSuggest
(
Selection
*
aSpellCheckSelection
nsTArray
<
nsString
>
&
&
aWords
nsTArray
<
NodeOffsetRange
>
&
&
aRanges
)
{
MOZ_ASSERT
(
aWords
.
Length
(
)
=
=
aRanges
.
Length
(
)
)
;
if
(
aWords
.
IsEmpty
(
)
)
{
return
;
}
ChangeNumPendingSpellChecks
(
1
)
;
RefPtr
<
mozInlineSpellChecker
>
self
=
this
;
RefPtr
<
Selection
>
spellCheckerSelection
=
aSpellCheckSelection
;
uint32_t
token
=
mDisabledAsyncToken
;
nsTArray
<
nsString
>
words
=
std
:
:
move
(
aWords
)
;
mSpellCheck
-
>
CheckCurrentWordsNoSuggest
(
words
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
spellCheckerSelection
ranges
=
std
:
:
move
(
aRanges
)
token
]
(
const
nsTArray
<
bool
>
&
aIsMisspelled
)
{
if
(
token
!
=
self
-
>
mDisabledAsyncToken
)
{
return
;
}
if
(
!
self
-
>
mTextEditor
|
|
self
-
>
mTextEditor
-
>
Destroyed
(
)
)
{
return
;
}
AutoChangeNumPendingSpellChecks
pendingChecks
(
self
-
1
)
;
if
(
self
-
>
SpellCheckSelectionIsFull
(
)
)
{
return
;
}
for
(
size_t
i
=
0
;
i
<
aIsMisspelled
.
Length
(
)
;
i
+
+
)
{
if
(
!
aIsMisspelled
[
i
]
)
{
continue
;
}
RefPtr
<
nsRange
>
wordRange
=
mozInlineSpellWordUtil
:
:
MakeRange
(
ranges
[
i
]
)
;
if
(
wordRange
)
{
self
-
>
AddRange
(
spellCheckerSelection
wordRange
)
;
}
}
}
[
self
token
]
(
nsresult
aRv
)
{
if
(
!
self
-
>
mTextEditor
|
|
self
-
>
mTextEditor
-
>
Destroyed
(
)
)
{
return
;
}
if
(
token
!
=
self
-
>
mDisabledAsyncToken
)
{
return
;
}
self
-
>
ChangeNumPendingSpellChecks
(
-
1
)
;
}
)
;
}
nsresult
mozInlineSpellChecker
:
:
ResumeCheck
(
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
AutoChangeNumPendingSpellChecks
autoChangeNumPending
(
this
-
1
)
;
if
(
aStatus
-
>
IsFullSpellCheck
(
)
)
{
NS_ASSERTION
(
mFullSpellCheckScheduled
"
How
could
this
be
false
?
The
full
spell
check
is
"
"
calling
us
!
!
"
)
;
mFullSpellCheckScheduled
=
false
;
}
if
(
!
mSpellCheck
)
return
NS_OK
;
if
(
!
mTextEditor
)
{
return
NS_OK
;
}
mozInlineSpellWordUtil
wordUtil
;
nsresult
rv
=
wordUtil
.
Init
(
*
mTextEditor
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_OK
;
RefPtr
<
Selection
>
spellCheckSelection
=
GetSpellCheckSelection
(
)
;
if
(
NS_WARN_IF
(
!
spellCheckSelection
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
currentDictionary
;
rv
=
mSpellCheck
-
>
GetCurrentDictionary
(
currentDictionary
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
:
no
active
dictionary
.
"
__FUNCTION__
)
)
;
int32_t
count
=
spellCheckSelection
-
>
RangeCount
(
)
;
for
(
int32_t
index
=
count
-
1
;
index
>
=
0
;
index
-
-
)
{
RefPtr
<
nsRange
>
checkRange
=
spellCheckSelection
-
>
GetRangeAt
(
index
)
;
if
(
checkRange
)
{
RemoveRange
(
spellCheckSelection
checkRange
)
;
}
}
return
NS_OK
;
}
CleanupRangesInSelection
(
spellCheckSelection
)
;
rv
=
aStatus
-
>
FinishInitOnEvent
(
wordUtil
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
aStatus
-
>
mRange
)
return
NS_OK
;
bool
doneChecking
=
true
;
if
(
aStatus
-
>
GetOperation
(
)
=
=
mozInlineSpellStatus
:
:
eOpSelection
)
rv
=
DoSpellCheckSelection
(
wordUtil
spellCheckSelection
)
;
else
rv
=
DoSpellCheck
(
wordUtil
spellCheckSelection
aStatus
&
doneChecking
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
doneChecking
)
rv
=
ScheduleSpellCheck
(
std
:
:
move
(
aStatus
)
)
;
return
rv
;
}
nsresult
mozInlineSpellChecker
:
:
IsPointInSelection
(
Selection
&
aSelection
nsINode
*
aNode
int32_t
aOffset
nsRange
*
*
aRange
)
{
*
aRange
=
nullptr
;
nsTArray
<
nsRange
*
>
ranges
;
nsresult
rv
=
aSelection
.
GetRangesForIntervalArray
(
aNode
aOffset
aNode
aOffset
true
&
ranges
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
ranges
.
Length
(
)
=
=
0
)
return
NS_OK
;
NS_ADDREF
(
*
aRange
=
ranges
[
0
]
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
CleanupRangesInSelection
(
Selection
*
aSelection
)
{
if
(
!
aSelection
)
return
NS_ERROR_FAILURE
;
int32_t
count
=
aSelection
-
>
RangeCount
(
)
;
for
(
int32_t
index
=
0
;
index
<
count
;
index
+
+
)
{
nsRange
*
checkRange
=
aSelection
-
>
GetRangeAt
(
index
)
;
if
(
checkRange
)
{
if
(
checkRange
-
>
Collapsed
(
)
)
{
RemoveRange
(
aSelection
checkRange
)
;
index
-
-
;
count
-
-
;
}
}
}
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
RemoveRange
(
Selection
*
aSpellCheckSelection
nsRange
*
aRange
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
NS_ENSURE_ARG_POINTER
(
aSpellCheckSelection
)
;
NS_ENSURE_ARG_POINTER
(
aRange
)
;
ErrorResult
rv
;
RefPtr
<
nsRange
>
range
{
aRange
}
;
RefPtr
<
Selection
>
selection
{
aSpellCheckSelection
}
;
selection
-
>
RemoveRangeAndUnselectFramesAndNotifyListeners
(
*
range
rv
)
;
if
(
!
rv
.
Failed
(
)
&
&
mNumWordsInSpellSelection
)
mNumWordsInSpellSelection
-
-
;
return
rv
.
StealNSResult
(
)
;
}
nsresult
mozInlineSpellChecker
:
:
AddRange
(
Selection
*
aSpellCheckSelection
nsRange
*
aRange
)
{
NS_ENSURE_ARG_POINTER
(
aSpellCheckSelection
)
;
NS_ENSURE_ARG_POINTER
(
aRange
)
;
nsresult
rv
=
NS_OK
;
if
(
!
SpellCheckSelectionIsFull
(
)
)
{
IgnoredErrorResult
err
;
aSpellCheckSelection
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
aRange
err
)
;
if
(
err
.
Failed
(
)
)
{
rv
=
err
.
StealNSResult
(
)
;
}
else
{
mNumWordsInSpellSelection
+
+
;
}
}
return
rv
;
}
already_AddRefed
<
Selection
>
mozInlineSpellChecker
:
:
GetSpellCheckSelection
(
)
{
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
nullptr
;
}
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
SelectionType
:
:
eSpellCheck
)
;
if
(
!
selection
)
{
return
nullptr
;
}
return
selection
.
forget
(
)
;
}
nsresult
mozInlineSpellChecker
:
:
SaveCurrentSelectionPosition
(
)
{
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
mCurrentSelectionAnchorNode
=
selection
-
>
GetFocusNode
(
)
;
mCurrentSelectionOffset
=
selection
-
>
FocusOffset
(
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
HandleNavigationEvent
(
bool
aForceWordSpellCheck
int32_t
aNewPositionOffset
)
{
nsresult
rv
;
if
(
!
mNeedsCheckAfterNavigation
)
return
NS_OK
;
nsCOMPtr
<
nsINode
>
currentAnchorNode
=
mCurrentSelectionAnchorNode
;
uint32_t
currentAnchorOffset
=
mCurrentSelectionOffset
;
rv
=
SaveCurrentSelectionPosition
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
shouldPost
;
Result
<
UniquePtr
<
mozInlineSpellStatus
>
nsresult
>
res
=
mozInlineSpellStatus
:
:
CreateForNavigation
(
*
this
aForceWordSpellCheck
aNewPositionOffset
currentAnchorNode
currentAnchorOffset
mCurrentSelectionAnchorNode
mCurrentSelectionOffset
&
shouldPost
)
;
if
(
NS_WARN_IF
(
res
.
isErr
(
)
)
)
{
return
res
.
unwrapErr
(
)
;
}
if
(
shouldPost
)
{
rv
=
ScheduleSpellCheck
(
res
.
unwrap
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
HandleEvent
(
Event
*
aEvent
)
{
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
blur
"
)
)
{
return
OnBlur
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
click
"
)
)
{
return
OnMouseClick
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
keypress
"
)
)
{
return
OnKeyPress
(
aEvent
)
;
}
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
OnBlur
(
Event
*
aEvent
)
{
HandleNavigationEvent
(
true
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
OnMouseClick
(
Event
*
aMouseEvent
)
{
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_OK
)
;
HandleNavigationEvent
(
mouseEvent
-
>
Button
(
)
!
=
0
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
OnKeyPress
(
Event
*
aKeyEvent
)
{
RefPtr
<
KeyboardEvent
>
keyEvent
=
aKeyEvent
-
>
AsKeyboardEvent
(
)
;
NS_ENSURE_TRUE
(
keyEvent
NS_OK
)
;
uint32_t
keyCode
=
keyEvent
-
>
KeyCode
(
)
;
switch
(
keyCode
)
{
case
KeyboardEvent_Binding
:
:
DOM_VK_RIGHT
:
case
KeyboardEvent_Binding
:
:
DOM_VK_LEFT
:
HandleNavigationEvent
(
false
keyCode
=
=
KeyboardEvent_Binding
:
:
DOM_VK_RIGHT
?
1
:
-
1
)
;
break
;
case
KeyboardEvent_Binding
:
:
DOM_VK_UP
:
case
KeyboardEvent_Binding
:
:
DOM_VK_DOWN
:
case
KeyboardEvent_Binding
:
:
DOM_VK_HOME
:
case
KeyboardEvent_Binding
:
:
DOM_VK_END
:
case
KeyboardEvent_Binding
:
:
DOM_VK_PAGE_UP
:
case
KeyboardEvent_Binding
:
:
DOM_VK_PAGE_DOWN
:
HandleNavigationEvent
(
true
)
;
break
;
}
return
NS_OK
;
}
class
UpdateCurrentDictionaryCallback
final
:
public
nsIEditorSpellCheckCallback
{
public
:
NS_DECL_ISUPPORTS
explicit
UpdateCurrentDictionaryCallback
(
mozInlineSpellChecker
*
aSpellChecker
uint32_t
aDisabledAsyncToken
)
:
mSpellChecker
(
aSpellChecker
)
mDisabledAsyncToken
(
aDisabledAsyncToken
)
{
}
NS_IMETHOD
EditorSpellCheckDone
(
)
override
{
return
mSpellChecker
-
>
mDisabledAsyncToken
>
mDisabledAsyncToken
?
NS_OK
:
mSpellChecker
-
>
CurrentDictionaryUpdated
(
)
;
}
private
:
~
UpdateCurrentDictionaryCallback
(
)
{
}
RefPtr
<
mozInlineSpellChecker
>
mSpellChecker
;
uint32_t
mDisabledAsyncToken
;
}
;
NS_IMPL_ISUPPORTS
(
UpdateCurrentDictionaryCallback
nsIEditorSpellCheckCallback
)
NS_IMETHODIMP
mozInlineSpellChecker
:
:
UpdateCurrentDictionary
(
)
{
RefPtr
<
EditorSpellCheck
>
spellCheck
=
mSpellCheck
?
mSpellCheck
:
mPendingSpellCheck
;
if
(
!
spellCheck
)
{
return
NS_OK
;
}
RefPtr
<
UpdateCurrentDictionaryCallback
>
cb
=
new
UpdateCurrentDictionaryCallback
(
this
mDisabledAsyncToken
)
;
NS_ENSURE_STATE
(
cb
)
;
nsresult
rv
=
spellCheck
-
>
UpdateCurrentDictionary
(
cb
)
;
if
(
NS_FAILED
(
rv
)
)
{
cb
=
nullptr
;
return
rv
;
}
mNumPendingUpdateCurrentDictionary
+
+
;
ChangeNumPendingSpellChecks
(
1
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
CurrentDictionaryUpdated
(
)
{
mNumPendingUpdateCurrentDictionary
-
-
;
NS_ASSERTION
(
mNumPendingUpdateCurrentDictionary
>
=
0
"
CurrentDictionaryUpdated
called
without
corresponding
"
"
UpdateCurrentDictionary
call
!
"
)
;
ChangeNumPendingSpellChecks
(
-
1
)
;
nsresult
rv
=
SpellCheckRange
(
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetSpellCheckPending
(
bool
*
aPending
)
{
*
aPending
=
mNumPendingSpellChecks
>
0
;
return
NS_OK
;
}
