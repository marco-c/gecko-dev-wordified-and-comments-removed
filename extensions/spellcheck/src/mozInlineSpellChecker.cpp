#
include
"
mozInlineSpellChecker
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorSpellCheck
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozInlineSpellWordUtil
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
prtime
.
h
"
using
mozilla
:
:
LogLevel
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
#
define
INLINESPELL_CHECK_TIMEOUT
1
#
define
INLINESPELL_MINIMUM_WORDS_BEFORE_TIMEOUT
5
#
define
INLINESPELL_MAXIMUM_CHUNKED_WORDS_PER_TASK
25
#
define
INLINESPELL_STARTED_TOPIC
"
inlineSpellChecker
-
spellCheck
-
started
"
#
define
INLINESPELL_ENDED_TOPIC
"
inlineSpellChecker
-
spellCheck
-
ended
"
static
mozilla
:
:
LazyLogModule
sInlineSpellCheckerLog
(
"
InlineSpellChecker
"
)
;
static
const
char
kMaxSpellCheckSelectionSize
[
]
=
"
extensions
.
spellcheck
.
inline
.
max
-
misspellings
"
;
static
const
PRTime
kMaxSpellCheckTimeInUsec
=
INLINESPELL_CHECK_TIMEOUT
*
PR_USEC_PER_MSEC
;
mozInlineSpellStatus
:
:
mozInlineSpellStatus
(
mozInlineSpellChecker
*
aSpellChecker
const
Operation
aOp
RefPtr
<
nsRange
>
&
&
aRange
RefPtr
<
nsRange
>
&
&
aCreatedRange
RefPtr
<
nsRange
>
&
&
aAnchorRange
const
bool
aForceNavigationWordCheck
const
int32_t
aNewNavigationPositionOffset
)
:
mSpellChecker
(
aSpellChecker
)
mRange
(
std
:
:
move
(
aRange
)
)
mOp
(
aOp
)
mCreatedRange
(
std
:
:
move
(
aCreatedRange
)
)
mAnchorRange
(
std
:
:
move
(
aAnchorRange
)
)
mForceNavigationWordCheck
(
aForceNavigationWordCheck
)
mNewNavigationPositionOffset
(
aNewNavigationPositionOffset
)
{
}
Result
<
UniquePtr
<
mozInlineSpellStatus
>
nsresult
>
mozInlineSpellStatus
:
:
CreateForEditorChange
(
mozInlineSpellChecker
&
aSpellChecker
const
EditSubAction
aEditSubAction
nsINode
*
aAnchorNode
uint32_t
aAnchorOffset
nsINode
*
aPreviousNode
uint32_t
aPreviousOffset
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Verbose
(
"
%
s
"
__FUNCTION__
)
)
;
if
(
NS_WARN_IF
(
!
aAnchorNode
)
|
|
NS_WARN_IF
(
!
aPreviousNode
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
bool
deleted
=
aEditSubAction
=
=
EditSubAction
:
:
eDeleteSelectedContent
;
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
deleted
=
!
aPreviousNode
-
>
IsInComposedDoc
(
)
;
}
RefPtr
<
nsRange
>
anchorRange
=
mozInlineSpellStatus
:
:
PositionToCollapsedRange
(
aAnchorNode
aAnchorOffset
)
;
if
(
NS_WARN_IF
(
!
anchorRange
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
nsRange
>
range
=
deleted
?
nullptr
:
nsRange
:
:
Create
(
aPreviousNode
)
;
RefPtr
<
nsRange
>
createdRange
=
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
)
?
range
:
nullptr
;
UniquePtr
<
mozInlineSpellStatus
>
status
{
new
mozInlineSpellStatus
{
&
aSpellChecker
deleted
?
eOpChangeDelete
:
eOpChange
std
:
:
move
(
range
)
std
:
:
move
(
createdRange
)
std
:
:
move
(
anchorRange
)
false
0
}
}
;
if
(
deleted
)
{
return
status
;
}
ErrorResult
errorResult
;
int16_t
cmpResult
=
status
-
>
mAnchorRange
-
>
ComparePoint
(
*
aPreviousNode
aPreviousOffset
errorResult
)
;
if
(
NS_WARN_IF
(
errorResult
.
Failed
(
)
)
)
{
return
Err
(
errorResult
.
StealNSResult
(
)
)
;
}
nsresult
rv
;
if
(
cmpResult
<
0
)
{
rv
=
status
-
>
mRange
-
>
SetStartAndEnd
(
aPreviousNode
aPreviousOffset
aAnchorNode
aAnchorOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
}
else
{
rv
=
status
-
>
mRange
-
>
SetStartAndEnd
(
aAnchorNode
aAnchorOffset
aPreviousNode
aPreviousOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
}
if
(
aStartNode
&
&
aEndNode
)
{
cmpResult
=
status
-
>
mRange
-
>
ComparePoint
(
*
aStartNode
aStartOffset
errorResult
)
;
if
(
NS_WARN_IF
(
errorResult
.
Failed
(
)
)
)
{
return
Err
(
errorResult
.
StealNSResult
(
)
)
;
}
if
(
cmpResult
<
0
)
{
rv
=
status
-
>
mRange
-
>
SetStart
(
aStartNode
aStartOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
}
cmpResult
=
status
-
>
mRange
-
>
ComparePoint
(
*
aEndNode
aEndOffset
errorResult
)
;
if
(
NS_WARN_IF
(
errorResult
.
Failed
(
)
)
)
{
return
Err
(
errorResult
.
StealNSResult
(
)
)
;
}
if
(
cmpResult
>
0
)
{
rv
=
status
-
>
mRange
-
>
SetEnd
(
aEndNode
aEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
}
}
return
status
;
}
Result
<
UniquePtr
<
mozInlineSpellStatus
>
nsresult
>
mozInlineSpellStatus
:
:
CreateForNavigation
(
mozInlineSpellChecker
&
aSpellChecker
bool
aForceCheck
int32_t
aNewPositionOffset
nsINode
*
aOldAnchorNode
uint32_t
aOldAnchorOffset
nsINode
*
aNewAnchorNode
uint32_t
aNewAnchorOffset
bool
*
aContinue
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Verbose
(
"
%
s
"
__FUNCTION__
)
)
;
RefPtr
<
nsRange
>
anchorRange
=
mozInlineSpellStatus
:
:
PositionToCollapsedRange
(
aNewAnchorNode
aNewAnchorOffset
)
;
if
(
NS_WARN_IF
(
!
anchorRange
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
UniquePtr
<
mozInlineSpellStatus
>
status
{
new
mozInlineSpellStatus
{
&
aSpellChecker
eOpNavigation
nullptr
nullptr
std
:
:
move
(
anchorRange
)
aForceCheck
aNewPositionOffset
}
}
;
EditorBase
*
editorBase
=
status
-
>
mSpellChecker
-
>
mEditorBase
;
if
(
NS_WARN_IF
(
!
editorBase
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
Element
*
root
=
editorBase
-
>
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
root
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
root
&
&
aOldAnchorNode
&
&
!
aOldAnchorNode
-
>
IsShadowIncludingInclusiveDescendantOf
(
root
)
)
{
*
aContinue
=
false
;
return
status
;
}
status
-
>
mOldNavigationAnchorRange
=
mozInlineSpellStatus
:
:
PositionToCollapsedRange
(
aOldAnchorNode
aOldAnchorOffset
)
;
if
(
NS_WARN_IF
(
!
status
-
>
mOldNavigationAnchorRange
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
*
aContinue
=
true
;
return
status
;
}
UniquePtr
<
mozInlineSpellStatus
>
mozInlineSpellStatus
:
:
CreateForSelection
(
mozInlineSpellChecker
&
aSpellChecker
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Verbose
(
"
%
s
"
__FUNCTION__
)
)
;
UniquePtr
<
mozInlineSpellStatus
>
status
{
new
mozInlineSpellStatus
{
&
aSpellChecker
eOpSelection
nullptr
nullptr
nullptr
false
0
}
}
;
return
status
;
}
UniquePtr
<
mozInlineSpellStatus
>
mozInlineSpellStatus
:
:
CreateForRange
(
mozInlineSpellChecker
&
aSpellChecker
nsRange
*
aRange
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
:
range
=
%
p
"
__FUNCTION__
aRange
)
)
;
UniquePtr
<
mozInlineSpellStatus
>
status
{
new
mozInlineSpellStatus
{
&
aSpellChecker
eOpChange
nullptr
nullptr
nullptr
false
0
}
}
;
status
-
>
mRange
=
aRange
;
return
status
;
}
nsresult
mozInlineSpellStatus
:
:
FinishInitOnEvent
(
mozInlineSpellWordUtil
&
aWordUtil
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Verbose
(
"
%
s
:
mRange
=
%
p
"
__FUNCTION__
mRange
.
get
(
)
)
)
;
nsresult
rv
;
if
(
!
mRange
)
{
rv
=
mSpellChecker
-
>
MakeSpellCheckRange
(
nullptr
0
nullptr
0
getter_AddRefs
(
mRange
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
switch
(
mOp
)
{
case
eOpChange
:
if
(
mAnchorRange
)
return
FillNoCheckRangeFromAnchor
(
aWordUtil
)
;
break
;
case
eOpChangeDelete
:
if
(
mAnchorRange
)
{
rv
=
FillNoCheckRangeFromAnchor
(
aWordUtil
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mRange
=
mNoCheckRange
;
break
;
case
eOpNavigation
:
return
FinishNavigationEvent
(
aWordUtil
)
;
case
eOpSelection
:
break
;
case
eOpResume
:
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Bad
operation
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
return
NS_OK
;
}
nsresult
mozInlineSpellStatus
:
:
FinishNavigationEvent
(
mozInlineSpellWordUtil
&
aWordUtil
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Verbose
(
"
%
s
"
__FUNCTION__
)
)
;
RefPtr
<
EditorBase
>
editorBase
=
mSpellChecker
-
>
mEditorBase
;
if
(
!
editorBase
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
mAnchorRange
"
No
anchor
for
navigation
!
"
)
;
if
(
!
mOldNavigationAnchorRange
-
>
IsPositioned
(
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsINode
>
oldAnchorNode
=
mOldNavigationAnchorRange
-
>
GetStartContainer
(
)
;
uint32_t
oldAnchorOffset
=
mOldNavigationAnchorRange
-
>
StartOffset
(
)
;
RefPtr
<
nsRange
>
oldWord
;
nsresult
rv
=
aWordUtil
.
GetRangeForWord
(
oldAnchorNode
static_cast
<
int32_t
>
(
oldAnchorOffset
)
getter_AddRefs
(
oldWord
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mSpellChecker
-
>
mEditorBase
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
newAnchorNode
=
mAnchorRange
-
>
GetStartContainer
(
)
;
uint32_t
newAnchorOffset
=
mAnchorRange
-
>
StartOffset
(
)
;
bool
isInRange
=
false
;
if
(
!
mForceNavigationWordCheck
)
{
ErrorResult
err
;
isInRange
=
oldWord
-
>
IsPointInRange
(
*
newAnchorNode
newAnchorOffset
+
mNewNavigationPositionOffset
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
}
if
(
isInRange
)
{
mRange
=
nullptr
;
}
else
{
mRange
=
oldWord
;
mSpellChecker
-
>
mNeedsCheckAfterNavigation
=
false
;
}
return
NS_OK
;
}
nsresult
mozInlineSpellStatus
:
:
FillNoCheckRangeFromAnchor
(
mozInlineSpellWordUtil
&
aWordUtil
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Verbose
(
"
%
s
"
__FUNCTION__
)
)
;
if
(
!
mAnchorRange
-
>
IsPositioned
(
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsINode
>
anchorNode
=
mAnchorRange
-
>
GetStartContainer
(
)
;
uint32_t
anchorOffset
=
mAnchorRange
-
>
StartOffset
(
)
;
return
aWordUtil
.
GetRangeForWord
(
anchorNode
static_cast
<
int32_t
>
(
anchorOffset
)
getter_AddRefs
(
mNoCheckRange
)
)
;
}
Document
*
mozInlineSpellStatus
:
:
GetDocument
(
)
const
{
if
(
!
mSpellChecker
-
>
mEditorBase
)
{
return
nullptr
;
}
return
mSpellChecker
-
>
mEditorBase
-
>
GetDocument
(
)
;
}
already_AddRefed
<
nsRange
>
mozInlineSpellStatus
:
:
PositionToCollapsedRange
(
nsINode
*
aNode
uint32_t
aOffset
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
IgnoredErrorResult
ignoredError
;
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aNode
aOffset
aNode
aOffset
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Creating
collapsed
range
failed
"
)
;
return
range
.
forget
(
)
;
}
class
mozInlineSpellResume
:
public
Runnable
{
public
:
mozInlineSpellResume
(
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
uint32_t
aDisabledAsyncToken
)
:
Runnable
(
"
mozInlineSpellResume
"
)
mDisabledAsyncToken
(
aDisabledAsyncToken
)
mStatus
(
std
:
:
move
(
aStatus
)
)
{
}
nsresult
Post
(
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
this
)
;
return
NS_DispatchToCurrentThreadQueue
(
runnable
.
forget
(
)
1000
EventQueuePriority
:
:
Idle
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mDisabledAsyncToken
=
=
mStatus
-
>
mSpellChecker
-
>
GetDisabledAsyncToken
(
)
)
{
mStatus
-
>
mSpellChecker
-
>
ResumeCheck
(
std
:
:
move
(
mStatus
)
)
;
}
return
NS_OK
;
}
private
:
uint32_t
mDisabledAsyncToken
;
UniquePtr
<
mozInlineSpellStatus
>
mStatus
;
}
;
class
InitEditorSpellCheckCallback
final
:
public
nsIEditorSpellCheckCallback
{
~
InitEditorSpellCheckCallback
(
)
{
}
public
:
NS_DECL_ISUPPORTS
explicit
InitEditorSpellCheckCallback
(
mozInlineSpellChecker
*
aSpellChecker
)
:
mSpellChecker
(
aSpellChecker
)
{
}
NS_IMETHOD
EditorSpellCheckDone
(
)
override
{
return
mSpellChecker
?
mSpellChecker
-
>
EditorSpellCheckInited
(
)
:
NS_OK
;
}
void
Cancel
(
)
{
mSpellChecker
=
nullptr
;
}
private
:
RefPtr
<
mozInlineSpellChecker
>
mSpellChecker
;
}
;
NS_IMPL_ISUPPORTS
(
InitEditorSpellCheckCallback
nsIEditorSpellCheckCallback
)
NS_INTERFACE_MAP_BEGIN
(
mozInlineSpellChecker
)
NS_INTERFACE_MAP_ENTRY
(
nsIInlineSpellChecker
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
mozInlineSpellChecker
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
mozInlineSpellChecker
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
mozInlineSpellChecker
)
NS_IMPL_CYCLE_COLLECTION_WEAK
(
mozInlineSpellChecker
mEditorBase
mSpellCheck
mCurrentSelectionAnchorNode
)
mozInlineSpellChecker
:
:
SpellCheckingState
mozInlineSpellChecker
:
:
gCanEnableSpellChecking
=
mozInlineSpellChecker
:
:
SpellCheck_Uninitialized
;
mozInlineSpellChecker
:
:
mozInlineSpellChecker
(
)
:
mNumWordsInSpellSelection
(
0
)
mMaxNumWordsInSpellSelection
(
250
)
mNumPendingSpellChecks
(
0
)
mNumPendingUpdateCurrentDictionary
(
0
)
mDisabledAsyncToken
(
0
)
mNeedsCheckAfterNavigation
(
false
)
mFullSpellCheckScheduled
(
false
)
mIsListeningToEditSubActions
(
false
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefs
)
prefs
-
>
GetIntPref
(
kMaxSpellCheckSelectionSize
&
mMaxNumWordsInSpellSelection
)
;
}
mozInlineSpellChecker
:
:
~
mozInlineSpellChecker
(
)
{
}
EditorSpellCheck
*
mozInlineSpellChecker
:
:
GetEditorSpellCheck
(
)
{
return
mSpellCheck
?
mSpellCheck
:
mPendingSpellCheck
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetSpellChecker
(
nsIEditorSpellCheck
*
*
aSpellCheck
)
{
*
aSpellCheck
=
mSpellCheck
;
NS_IF_ADDREF
(
*
aSpellCheck
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
Init
(
nsIEditor
*
aEditor
)
{
mEditorBase
=
aEditor
?
aEditor
-
>
AsEditorBase
(
)
:
nullptr
;
return
NS_OK
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
mozInlineSpellChecker
:
:
Cleanup
(
bool
aDestroyingFrames
)
{
mNumWordsInSpellSelection
=
0
;
RefPtr
<
Selection
>
spellCheckSelection
=
GetSpellCheckSelection
(
)
;
nsresult
rv
=
NS_OK
;
if
(
!
spellCheckSelection
)
{
UnregisterEventListeners
(
)
;
rv
=
NS_ERROR_FAILURE
;
}
else
{
if
(
!
aDestroyingFrames
)
{
spellCheckSelection
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
}
rv
=
UnregisterEventListeners
(
)
;
}
RefPtr
<
EditorBase
>
editorBase
=
std
:
:
move
(
mEditorBase
)
;
if
(
mPendingSpellCheck
)
{
mPendingSpellCheck
=
nullptr
;
mPendingInitEditorSpellCheckCallback
-
>
Cancel
(
)
;
mPendingInitEditorSpellCheckCallback
=
nullptr
;
ChangeNumPendingSpellChecks
(
-
1
editorBase
)
;
}
mDisabledAsyncToken
+
+
;
if
(
mNumPendingUpdateCurrentDictionary
>
0
)
{
ChangeNumPendingSpellChecks
(
-
mNumPendingUpdateCurrentDictionary
editorBase
)
;
mNumPendingUpdateCurrentDictionary
=
0
;
}
if
(
mNumPendingSpellChecks
>
0
)
{
ChangeNumPendingSpellChecks
(
-
mNumPendingSpellChecks
editorBase
)
;
}
mFullSpellCheckScheduled
=
false
;
return
rv
;
}
bool
mozInlineSpellChecker
:
:
CanEnableInlineSpellChecking
(
)
{
if
(
gCanEnableSpellChecking
=
=
SpellCheck_Uninitialized
)
{
gCanEnableSpellChecking
=
SpellCheck_NotAvailable
;
nsCOMPtr
<
nsIEditorSpellCheck
>
spellchecker
=
new
EditorSpellCheck
(
)
;
bool
canSpellCheck
=
false
;
nsresult
rv
=
spellchecker
-
>
CanSpellCheck
(
&
canSpellCheck
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
canSpellCheck
)
gCanEnableSpellChecking
=
SpellCheck_Available
;
}
return
(
gCanEnableSpellChecking
=
=
SpellCheck_Available
)
;
}
void
mozInlineSpellChecker
:
:
UpdateCanEnableInlineSpellChecking
(
)
{
gCanEnableSpellChecking
=
SpellCheck_Uninitialized
;
}
nsresult
mozInlineSpellChecker
:
:
RegisterEventListeners
(
)
{
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
mEditorBase
)
)
)
{
return
NS_ERROR_FAILURE
;
}
StartToListenToEditSubActions
(
)
;
RefPtr
<
Document
>
doc
=
mEditorBase
-
>
GetDocument
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
doc
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EventListenerManager
*
eventListenerManager
=
doc
-
>
GetOrCreateListenerManager
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
eventListenerManager
)
)
)
{
return
NS_ERROR_FAILURE
;
}
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
blur
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
click
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keydown
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
UnregisterEventListeners
(
)
{
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
mEditorBase
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EndListeningToEditSubActions
(
)
;
RefPtr
<
Document
>
doc
=
mEditorBase
-
>
GetDocument
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
doc
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EventListenerManager
*
eventListenerManager
=
doc
-
>
GetOrCreateListenerManager
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
eventListenerManager
)
)
)
{
return
NS_ERROR_FAILURE
;
}
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
blur
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
click
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keydown
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetEnableRealTimeSpell
(
bool
*
aEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aEnabled
)
;
*
aEnabled
=
mSpellCheck
!
=
nullptr
|
|
mPendingSpellCheck
!
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
SetEnableRealTimeSpell
(
bool
aEnabled
)
{
if
(
!
aEnabled
)
{
mSpellCheck
=
nullptr
;
return
Cleanup
(
false
)
;
}
if
(
mSpellCheck
)
{
return
SpellCheckRange
(
nullptr
)
;
}
if
(
mPendingSpellCheck
)
{
return
NS_OK
;
}
mPendingSpellCheck
=
new
EditorSpellCheck
(
)
;
mPendingSpellCheck
-
>
SetFilterType
(
nsIEditorSpellCheck
:
:
FILTERTYPE_MAIL
)
;
mPendingInitEditorSpellCheckCallback
=
new
InitEditorSpellCheckCallback
(
this
)
;
nsresult
rv
=
mPendingSpellCheck
-
>
InitSpellChecker
(
mEditorBase
false
mPendingInitEditorSpellCheckCallback
)
;
if
(
NS_FAILED
(
rv
)
)
{
mPendingSpellCheck
=
nullptr
;
mPendingInitEditorSpellCheckCallback
=
nullptr
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
ChangeNumPendingSpellChecks
(
1
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
EditorSpellCheckInited
(
)
{
MOZ_ASSERT
(
mPendingSpellCheck
"
Spell
check
should
be
pending
!
"
)
;
RegisterEventListeners
(
)
;
mSpellCheck
=
mPendingSpellCheck
;
mPendingSpellCheck
=
nullptr
;
mPendingInitEditorSpellCheckCallback
=
nullptr
;
ChangeNumPendingSpellChecks
(
-
1
)
;
return
SpellCheckRange
(
nullptr
)
;
}
void
mozInlineSpellChecker
:
:
ChangeNumPendingSpellChecks
(
int32_t
aDelta
EditorBase
*
aEditorBase
)
{
int8_t
oldNumPending
=
mNumPendingSpellChecks
;
mNumPendingSpellChecks
+
=
aDelta
;
MOZ_ASSERT
(
mNumPendingSpellChecks
>
=
0
"
Unbalanced
ChangeNumPendingSpellChecks
calls
!
"
)
;
if
(
oldNumPending
=
=
0
&
&
mNumPendingSpellChecks
>
0
)
{
NotifyObservers
(
INLINESPELL_STARTED_TOPIC
aEditorBase
)
;
}
else
if
(
oldNumPending
>
0
&
&
mNumPendingSpellChecks
=
=
0
)
{
NotifyObservers
(
INLINESPELL_ENDED_TOPIC
aEditorBase
)
;
}
}
void
mozInlineSpellChecker
:
:
NotifyObservers
(
const
char
*
aTopic
EditorBase
*
aEditorBase
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
return
;
RefPtr
<
EditorBase
>
editorBase
=
aEditorBase
?
aEditorBase
:
mEditorBase
.
get
(
)
;
os
-
>
NotifyObservers
(
static_cast
<
nsIEditor
*
>
(
editorBase
.
get
(
)
)
aTopic
nullptr
)
;
}
nsresult
mozInlineSpellChecker
:
:
SpellCheckAfterEditorChange
(
EditSubAction
aEditSubAction
Selection
&
aSelection
nsINode
*
aPreviousSelectedNode
uint32_t
aPreviousSelectedOffset
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
)
{
nsresult
rv
;
if
(
!
mSpellCheck
)
return
NS_OK
;
mNeedsCheckAfterNavigation
=
true
;
Result
<
UniquePtr
<
mozInlineSpellStatus
>
nsresult
>
res
=
mozInlineSpellStatus
:
:
CreateForEditorChange
(
*
this
aEditSubAction
aSelection
.
GetAnchorNode
(
)
aSelection
.
AnchorOffset
(
)
aPreviousSelectedNode
aPreviousSelectedOffset
aStartNode
aStartOffset
aEndNode
aEndOffset
)
;
if
(
NS_WARN_IF
(
res
.
isErr
(
)
)
)
{
return
res
.
unwrapErr
(
)
;
}
rv
=
ScheduleSpellCheck
(
res
.
unwrap
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SaveCurrentSelectionPosition
(
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
SpellCheckRange
(
nsRange
*
aRange
)
{
if
(
!
mSpellCheck
)
{
NS_WARNING_ASSERTION
(
mPendingSpellCheck
"
Trying
to
spellcheck
but
checking
seems
to
be
disabled
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForRange
(
*
this
aRange
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetMisspelledWord
(
nsINode
*
aNode
int32_t
aOffset
nsRange
*
*
newword
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Selection
>
spellCheckSelection
=
GetSpellCheckSelection
(
)
;
if
(
NS_WARN_IF
(
!
spellCheckSelection
)
)
{
return
NS_ERROR_FAILURE
;
}
return
IsPointInSelection
(
*
spellCheckSelection
aNode
aOffset
newword
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
ReplaceWord
(
nsINode
*
aNode
int32_t
aOffset
const
nsAString
&
aNewWord
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
|
|
NS_WARN_IF
(
aNewWord
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsRange
>
range
;
nsresult
res
=
GetMisspelledWord
(
aNode
aOffset
getter_AddRefs
(
range
)
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
!
range
)
{
return
NS_OK
;
}
nsString
newWord
(
aNewWord
)
;
if
(
mEditorBase
-
>
IsTextEditor
(
)
)
{
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
newWord
)
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
DebugOnly
<
nsresult
>
rv
=
editorBase
-
>
ReplaceTextAsAction
(
newWord
range
EditorBase
:
:
AllowBeforeInputEventCancelable
:
:
Yes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
the
new
word
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
AddWordToDictionary
(
const
nsAString
&
word
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
mSpellCheck
-
>
AddWordToDictionary
(
word
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForSelection
(
*
this
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
RemoveWordFromDictionary
(
const
nsAString
&
word
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
mSpellCheck
-
>
RemoveWordFromDictionary
(
word
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForRange
(
*
this
nullptr
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
IgnoreWord
(
const
nsAString
&
word
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
mSpellCheck
-
>
IgnoreWordAllOccurrences
(
word
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForSelection
(
*
this
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
IgnoreWords
(
const
nsTArray
<
nsString
>
&
aWordsToIgnore
)
{
NS_ENSURE_TRUE
(
mSpellCheck
NS_ERROR_NOT_INITIALIZED
)
;
for
(
auto
&
word
:
aWordsToIgnore
)
{
mSpellCheck
-
>
IgnoreWordAllOccurrences
(
word
)
;
}
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForSelection
(
*
this
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
void
mozInlineSpellChecker
:
:
DidSplitNode
(
nsINode
*
aExistingRightNode
nsINode
*
aNewLeftNode
)
{
if
(
!
mIsListeningToEditSubActions
)
{
return
;
}
SpellCheckBetweenNodes
(
aNewLeftNode
0
aNewLeftNode
0
)
;
}
void
mozInlineSpellChecker
:
:
DidJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
if
(
!
mIsListeningToEditSubActions
)
{
return
;
}
SpellCheckBetweenNodes
(
&
aRightNode
0
&
aRightNode
0
)
;
}
nsresult
mozInlineSpellChecker
:
:
MakeSpellCheckRange
(
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
nsRange
*
*
aRange
)
const
{
nsresult
rv
;
*
aRange
=
nullptr
;
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Document
>
doc
=
mEditorBase
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
doc
)
;
if
(
!
aStartNode
|
|
!
aEndNode
)
{
Element
*
domRootElement
=
mEditorBase
-
>
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
domRootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
aStartNode
=
aEndNode
=
domRootElement
;
aStartOffset
=
0
;
aEndOffset
=
-
1
;
}
if
(
aEndOffset
=
=
-
1
)
{
aEndOffset
=
aEndNode
-
>
ChildNodes
(
)
-
>
Length
(
)
;
}
if
(
aStartNode
=
=
aEndNode
&
&
aStartOffset
=
=
aEndOffset
)
return
NS_OK
;
if
(
aEndOffset
)
{
rv
=
range
-
>
SetStartAndEnd
(
aStartNode
aStartOffset
aEndNode
aEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
range
-
>
SetStartAndEnd
(
RawRangeBoundary
(
aStartNode
aStartOffset
)
RangeUtils
:
:
GetRawRangeBoundaryAfter
(
aEndNode
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
range
.
swap
(
*
aRange
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
SpellCheckBetweenNodes
(
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
{
RefPtr
<
nsRange
>
range
;
nsresult
rv
=
MakeSpellCheckRange
(
aStartNode
aStartOffset
aEndNode
aEndOffset
getter_AddRefs
(
range
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
range
)
return
NS_OK
;
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForRange
(
*
this
range
)
;
return
ScheduleSpellCheck
(
std
:
:
move
(
status
)
)
;
}
bool
mozInlineSpellChecker
:
:
ShouldSpellCheckNode
(
EditorBase
*
aEditorBase
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
aNode
-
>
IsContent
(
)
)
return
false
;
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
if
(
aEditorBase
-
>
IsMailEditor
(
)
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
while
(
parent
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
&
&
parent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
cite
eIgnoreCase
)
)
{
return
false
;
}
if
(
parent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
pre
nsGkAtoms
:
:
div
)
&
&
parent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
nsGkAtoms
:
:
mozsignature
eIgnoreCase
)
)
{
return
false
;
}
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
&
&
parent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
nsGkAtoms
:
:
mozfwcontainer
eIgnoreCase
)
)
{
return
false
;
}
parent
=
parent
-
>
GetParent
(
)
;
}
}
else
{
if
(
!
content
-
>
IsEditable
(
)
)
{
return
false
;
}
if
(
content
-
>
IsInNativeAnonymousSubtree
(
)
)
{
nsIContent
*
node
=
content
-
>
GetParent
(
)
;
while
(
node
&
&
node
-
>
IsInNativeAnonymousSubtree
(
)
)
{
node
=
node
-
>
GetParent
(
)
;
}
if
(
node
&
&
node
-
>
IsTextControlElement
(
)
)
{
return
true
;
}
}
nsIContent
*
parent
=
content
;
while
(
!
parent
-
>
IsHTMLElement
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
true
;
}
}
return
static_cast
<
nsGenericHTMLElement
*
>
(
parent
)
-
>
Spellcheck
(
)
;
}
return
true
;
}
nsresult
mozInlineSpellChecker
:
:
ScheduleSpellCheck
(
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
:
mFullSpellCheckScheduled
=
%
i
"
__FUNCTION__
mFullSpellCheckScheduled
)
)
;
if
(
mFullSpellCheckScheduled
)
{
return
NS_OK
;
}
bool
isFullSpellCheck
=
aStatus
-
>
IsFullSpellCheck
(
)
;
RefPtr
<
mozInlineSpellResume
>
resume
=
new
mozInlineSpellResume
(
std
:
:
move
(
aStatus
)
mDisabledAsyncToken
)
;
NS_ENSURE_TRUE
(
resume
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
resume
-
>
Post
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
isFullSpellCheck
)
{
mFullSpellCheckScheduled
=
true
;
}
ChangeNumPendingSpellChecks
(
1
)
;
}
return
rv
;
}
nsresult
mozInlineSpellChecker
:
:
DoSpellCheckSelection
(
mozInlineSpellWordUtil
&
aWordUtil
Selection
*
aSpellCheckSelection
)
{
nsresult
rv
;
mNumWordsInSpellSelection
=
0
;
nsTArray
<
RefPtr
<
nsRange
>
>
ranges
;
int32_t
count
=
aSpellCheckSelection
-
>
RangeCount
(
)
;
for
(
int32_t
idx
=
0
;
idx
<
count
;
idx
+
+
)
{
nsRange
*
range
=
aSpellCheckSelection
-
>
GetRangeAt
(
idx
)
;
if
(
range
)
{
ranges
.
AppendElement
(
range
)
;
}
}
aSpellCheckSelection
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
UniquePtr
<
mozInlineSpellStatus
>
status
=
mozInlineSpellStatus
:
:
CreateForRange
(
*
this
nullptr
)
;
bool
doneChecking
;
for
(
int32_t
idx
=
0
;
idx
<
count
;
idx
+
+
)
{
status
-
>
mRange
=
ranges
[
idx
]
;
rv
=
DoSpellCheck
(
aWordUtil
aSpellCheckSelection
status
&
doneChecking
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
doneChecking
"
We
gave
the
spellchecker
one
word
but
it
didn
'
t
finish
checking
?
!
?
!
"
)
;
}
return
NS_OK
;
}
class
MOZ_STACK_CLASS
mozInlineSpellChecker
:
:
SpellCheckerSlice
{
public
:
SpellCheckerSlice
(
mozInlineSpellChecker
&
aInlineSpellChecker
mozInlineSpellWordUtil
&
aWordUtil
mozilla
:
:
dom
:
:
Selection
&
aSpellCheckSelection
const
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
&
aStatus
bool
&
aDoneChecking
)
:
mInlineSpellChecker
{
aInlineSpellChecker
}
mWordUtil
{
aWordUtil
}
mSpellCheckSelection
{
aSpellCheckSelection
}
mStatus
{
aStatus
}
mDoneChecking
{
aDoneChecking
}
{
MOZ_ASSERT
(
aStatus
)
;
}
[
[
nodiscard
]
]
nsresult
Execute
(
)
;
private
:
void
CheckWordsAndUpdateRangesForMisspellings
(
const
nsTArray
<
nsString
>
&
aWords
nsTArray
<
RefPtr
<
nsRange
>
>
&
&
aOldRangesForSomeWords
nsTArray
<
NodeOffsetRange
>
&
&
aNodeOffsetRangesForWords
)
;
void
RemoveRanges
(
const
nsTArray
<
RefPtr
<
nsRange
>
>
&
aRanges
)
;
bool
ShouldSpellCheckRange
(
const
nsRange
&
aRange
)
const
;
bool
IsInNoCheckRange
(
const
nsINode
&
aNode
int32_t
aOffset
)
const
;
mozInlineSpellChecker
&
mInlineSpellChecker
;
mozInlineSpellWordUtil
&
mWordUtil
;
mozilla
:
:
dom
:
:
Selection
&
mSpellCheckSelection
;
const
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
&
mStatus
;
bool
&
mDoneChecking
;
}
;
bool
mozInlineSpellChecker
:
:
SpellCheckerSlice
:
:
ShouldSpellCheckRange
(
const
nsRange
&
aRange
)
const
{
if
(
aRange
.
Collapsed
(
)
)
{
return
false
;
}
nsINode
*
beginNode
=
aRange
.
GetStartContainer
(
)
;
nsINode
*
endNode
=
aRange
.
GetEndContainer
(
)
;
const
nsINode
*
rootNode
=
mWordUtil
.
GetRootNode
(
)
;
return
beginNode
-
>
IsInComposedDoc
(
)
&
&
endNode
-
>
IsInComposedDoc
(
)
&
&
beginNode
-
>
IsShadowIncludingInclusiveDescendantOf
(
rootNode
)
&
&
endNode
-
>
IsShadowIncludingInclusiveDescendantOf
(
rootNode
)
;
}
bool
mozInlineSpellChecker
:
:
SpellCheckerSlice
:
:
IsInNoCheckRange
(
const
nsINode
&
aNode
int32_t
aOffset
)
const
{
ErrorResult
erv
;
return
mStatus
-
>
GetNoCheckRange
(
)
&
&
mStatus
-
>
GetNoCheckRange
(
)
-
>
IsPointInRange
(
aNode
aOffset
erv
)
;
}
void
mozInlineSpellChecker
:
:
SpellCheckerSlice
:
:
RemoveRanges
(
const
nsTArray
<
RefPtr
<
nsRange
>
>
&
aRanges
)
{
for
(
uint32_t
i
=
0
;
i
<
aRanges
.
Length
(
)
;
i
+
+
)
{
mInlineSpellChecker
.
RemoveRange
(
&
mSpellCheckSelection
aRanges
[
i
]
)
;
}
}
nsresult
mozInlineSpellChecker
:
:
SpellCheckerSlice
:
:
Execute
(
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
mDoneChecking
=
true
;
if
(
NS_WARN_IF
(
!
mInlineSpellChecker
.
mSpellCheck
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
mInlineSpellChecker
.
IsSpellCheckSelectionFull
(
)
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
=
mInlineSpellChecker
.
mEditorBase
;
if
(
!
editorBase
|
|
editorBase
-
>
Destroyed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
ShouldSpellCheckRange
(
*
mStatus
-
>
mRange
)
)
{
return
NS_OK
;
}
const
int32_t
originalRangeCount
=
mSpellCheckSelection
.
RangeCount
(
)
;
if
(
nsresult
rv
=
mWordUtil
.
SetPositionAndEnd
(
mStatus
-
>
mRange
-
>
GetStartContainer
(
)
mStatus
-
>
mRange
-
>
StartOffset
(
)
mStatus
-
>
mRange
-
>
GetEndContainer
(
)
mStatus
-
>
mRange
-
>
EndOffset
(
)
)
;
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
if
(
!
mInlineSpellChecker
.
mEditorBase
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
wordsChecked
=
0
;
PRTime
beginTime
=
PR_Now
(
)
;
nsTArray
<
nsString
>
normalizedWords
;
nsTArray
<
RefPtr
<
nsRange
>
>
oldRangesToRemove
;
nsTArray
<
NodeOffsetRange
>
checkRanges
;
mozInlineSpellWordUtil
:
:
Word
word
;
static
const
size_t
requestChunkSize
=
INLINESPELL_MAXIMUM_CHUNKED_WORDS_PER_TASK
;
while
(
mWordUtil
.
GetNextWord
(
word
)
)
{
nsINode
*
const
beginNode
=
word
.
mNodeOffsetRange
.
Begin
(
)
.
Node
(
)
;
nsINode
*
const
endNode
=
word
.
mNodeOffsetRange
.
End
(
)
.
Node
(
)
;
const
int32_t
beginOffset
=
word
.
mNodeOffsetRange
.
Begin
(
)
.
Offset
(
)
;
const
int32_t
endOffset
=
word
.
mNodeOffsetRange
.
End
(
)
.
Offset
(
)
;
if
(
wordsChecked
>
=
INLINESPELL_MINIMUM_WORDS_BEFORE_TIMEOUT
&
&
PR_Now
(
)
>
PRTime
(
beginTime
+
kMaxSpellCheckTimeInUsec
)
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Verbose
(
"
%
s
:
we
have
run
out
of
time
schedule
next
round
.
"
__FUNCTION__
)
)
;
CheckWordsAndUpdateRangesForMisspellings
(
normalizedWords
std
:
:
move
(
oldRangesToRemove
)
std
:
:
move
(
checkRanges
)
)
;
nsresult
rv
=
mStatus
-
>
mRange
-
>
SetStart
(
beginNode
beginOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
mDoneChecking
=
false
;
return
NS_OK
;
}
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
:
got
word
\
"
%
s
\
"
%
s
"
__FUNCTION__
NS_ConvertUTF16toUTF8
(
word
.
mText
)
.
get
(
)
word
.
mSkipChecking
?
"
(
not
checking
)
"
:
"
"
)
)
;
if
(
originalRangeCount
>
0
)
{
ErrorResult
erv
;
if
(
!
mStatus
-
>
GetCreatedRange
(
)
|
|
!
mStatus
-
>
GetCreatedRange
(
)
-
>
IsPointInRange
(
*
beginNode
beginOffset
erv
)
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
:
removing
ranges
for
some
interval
.
"
__FUNCTION__
)
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
ranges
;
mSpellCheckSelection
.
GetRangesForInterval
(
*
beginNode
beginOffset
*
endNode
endOffset
true
ranges
erv
)
;
ENSURE_SUCCESS
(
erv
erv
.
StealNSResult
(
)
)
;
oldRangesToRemove
.
AppendElements
(
std
:
:
move
(
ranges
)
)
;
}
}
if
(
word
.
mSkipChecking
)
{
continue
;
}
if
(
!
mozInlineSpellChecker
:
:
ShouldSpellCheckNode
(
editorBase
beginNode
)
)
{
continue
;
}
if
(
IsInNoCheckRange
(
*
beginNode
beginOffset
)
)
{
continue
;
}
mozInlineSpellWordUtil
:
:
NormalizeWord
(
word
.
mText
)
;
normalizedWords
.
AppendElement
(
word
.
mText
)
;
checkRanges
.
AppendElement
(
word
.
mNodeOffsetRange
)
;
wordsChecked
+
+
;
if
(
normalizedWords
.
Length
(
)
>
=
requestChunkSize
)
{
CheckWordsAndUpdateRangesForMisspellings
(
normalizedWords
std
:
:
move
(
oldRangesToRemove
)
std
:
:
move
(
checkRanges
)
)
;
normalizedWords
.
Clear
(
)
;
oldRangesToRemove
=
{
}
;
checkRanges
=
nsTArray
<
NodeOffsetRange
>
(
)
;
}
}
CheckWordsAndUpdateRangesForMisspellings
(
normalizedWords
std
:
:
move
(
oldRangesToRemove
)
std
:
:
move
(
checkRanges
)
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
DoSpellCheck
(
mozInlineSpellWordUtil
&
aWordUtil
Selection
*
aSpellCheckSelection
const
UniquePtr
<
mozInlineSpellStatus
>
&
aStatus
bool
*
aDoneChecking
)
{
MOZ_ASSERT
(
aDoneChecking
)
;
SpellCheckerSlice
spellCheckerSlice
{
*
this
aWordUtil
*
aSpellCheckSelection
aStatus
*
aDoneChecking
}
;
return
spellCheckerSlice
.
Execute
(
)
;
}
class
MOZ_RAII
AutoChangeNumPendingSpellChecks
final
{
public
:
explicit
AutoChangeNumPendingSpellChecks
(
mozInlineSpellChecker
*
aSpellChecker
int32_t
aDelta
)
:
mSpellChecker
(
aSpellChecker
)
mDelta
(
aDelta
)
{
}
~
AutoChangeNumPendingSpellChecks
(
)
{
mSpellChecker
-
>
ChangeNumPendingSpellChecks
(
mDelta
)
;
}
private
:
RefPtr
<
mozInlineSpellChecker
>
mSpellChecker
;
int32_t
mDelta
;
}
;
void
mozInlineSpellChecker
:
:
SpellCheckerSlice
:
:
CheckWordsAndUpdateRangesForMisspellings
(
const
nsTArray
<
nsString
>
&
aWords
nsTArray
<
RefPtr
<
nsRange
>
>
&
&
aOldRangesForSomeWords
nsTArray
<
NodeOffsetRange
>
&
&
aNodeOffsetRangesForWords
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Verbose
(
"
%
s
:
aWords
.
Length
(
)
=
%
i
"
__FUNCTION__
static_cast
<
int
>
(
aWords
.
Length
(
)
)
)
)
;
MOZ_ASSERT
(
aWords
.
Length
(
)
=
=
aNodeOffsetRangesForWords
.
Length
(
)
)
;
if
(
aWords
.
IsEmpty
(
)
)
{
RemoveRanges
(
aOldRangesForSomeWords
)
;
return
;
}
mInlineSpellChecker
.
ChangeNumPendingSpellChecks
(
1
)
;
RefPtr
<
mozInlineSpellChecker
>
inlineSpellChecker
=
&
mInlineSpellChecker
;
RefPtr
<
Selection
>
spellCheckerSelection
=
&
mSpellCheckSelection
;
uint32_t
token
=
mInlineSpellChecker
.
mDisabledAsyncToken
;
mInlineSpellChecker
.
mSpellCheck
-
>
CheckCurrentWordsNoSuggest
(
aWords
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
inlineSpellChecker
spellCheckerSelection
nodeOffsetRangesForWords
=
std
:
:
move
(
aNodeOffsetRangesForWords
)
oldRangesForSomeWords
=
std
:
:
move
(
aOldRangesForSomeWords
)
token
]
(
const
nsTArray
<
bool
>
&
aIsMisspelled
)
{
if
(
token
!
=
inlineSpellChecker
-
>
GetDisabledAsyncToken
(
)
)
{
return
;
}
if
(
!
inlineSpellChecker
-
>
mEditorBase
|
|
inlineSpellChecker
-
>
mEditorBase
-
>
Destroyed
(
)
)
{
return
;
}
AutoChangeNumPendingSpellChecks
pendingChecks
(
inlineSpellChecker
-
1
)
;
if
(
inlineSpellChecker
-
>
IsSpellCheckSelectionFull
(
)
)
{
return
;
}
inlineSpellChecker
-
>
UpdateRangesForMisspelledWords
(
nodeOffsetRangesForWords
oldRangesForSomeWords
aIsMisspelled
*
spellCheckerSelection
)
;
}
[
inlineSpellChecker
token
]
(
nsresult
aRv
)
{
if
(
!
inlineSpellChecker
-
>
mEditorBase
|
|
inlineSpellChecker
-
>
mEditorBase
-
>
Destroyed
(
)
)
{
return
;
}
if
(
token
!
=
inlineSpellChecker
-
>
GetDisabledAsyncToken
(
)
)
{
return
;
}
inlineSpellChecker
-
>
ChangeNumPendingSpellChecks
(
-
1
)
;
}
)
;
}
nsresult
mozInlineSpellChecker
:
:
ResumeCheck
(
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
AutoChangeNumPendingSpellChecks
autoChangeNumPending
(
this
-
1
)
;
if
(
aStatus
-
>
IsFullSpellCheck
(
)
)
{
MOZ_ASSERT
(
mFullSpellCheckScheduled
"
How
could
this
be
false
?
The
full
spell
check
is
"
"
calling
us
!
!
"
)
;
mFullSpellCheckScheduled
=
false
;
}
if
(
!
mSpellCheck
)
return
NS_OK
;
if
(
!
mEditorBase
)
{
return
NS_OK
;
}
Maybe
<
mozInlineSpellWordUtil
>
wordUtil
{
mozInlineSpellWordUtil
:
:
Create
(
*
mEditorBase
)
}
;
if
(
!
wordUtil
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
spellCheckSelection
=
GetSpellCheckSelection
(
)
;
if
(
NS_WARN_IF
(
!
spellCheckSelection
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
currentDictionary
;
nsresult
rv
=
mSpellCheck
-
>
GetCurrentDictionary
(
currentDictionary
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
:
no
active
dictionary
.
"
__FUNCTION__
)
)
;
int32_t
count
=
spellCheckSelection
-
>
RangeCount
(
)
;
for
(
int32_t
index
=
count
-
1
;
index
>
=
0
;
index
-
-
)
{
RefPtr
<
nsRange
>
checkRange
=
spellCheckSelection
-
>
GetRangeAt
(
index
)
;
if
(
checkRange
)
{
RemoveRange
(
spellCheckSelection
checkRange
)
;
}
}
return
NS_OK
;
}
CleanupRangesInSelection
(
spellCheckSelection
)
;
rv
=
aStatus
-
>
FinishInitOnEvent
(
*
wordUtil
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
aStatus
-
>
mRange
)
return
NS_OK
;
bool
doneChecking
=
true
;
if
(
aStatus
-
>
GetOperation
(
)
=
=
mozInlineSpellStatus
:
:
eOpSelection
)
rv
=
DoSpellCheckSelection
(
*
wordUtil
spellCheckSelection
)
;
else
rv
=
DoSpellCheck
(
*
wordUtil
spellCheckSelection
aStatus
&
doneChecking
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
doneChecking
)
rv
=
ScheduleSpellCheck
(
std
:
:
move
(
aStatus
)
)
;
return
rv
;
}
nsresult
mozInlineSpellChecker
:
:
IsPointInSelection
(
Selection
&
aSelection
nsINode
*
aNode
int32_t
aOffset
nsRange
*
*
aRange
)
{
*
aRange
=
nullptr
;
nsTArray
<
nsRange
*
>
ranges
;
nsresult
rv
=
aSelection
.
GetRangesForIntervalArray
(
aNode
aOffset
aNode
aOffset
true
&
ranges
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
ranges
.
Length
(
)
=
=
0
)
return
NS_OK
;
NS_ADDREF
(
*
aRange
=
ranges
[
0
]
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
CleanupRangesInSelection
(
Selection
*
aSelection
)
{
if
(
!
aSelection
)
return
NS_ERROR_FAILURE
;
int32_t
count
=
aSelection
-
>
RangeCount
(
)
;
for
(
int32_t
index
=
0
;
index
<
count
;
index
+
+
)
{
nsRange
*
checkRange
=
aSelection
-
>
GetRangeAt
(
index
)
;
if
(
checkRange
)
{
if
(
checkRange
-
>
Collapsed
(
)
)
{
RemoveRange
(
aSelection
checkRange
)
;
index
-
-
;
count
-
-
;
}
}
}
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
RemoveRange
(
Selection
*
aSpellCheckSelection
nsRange
*
aRange
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
NS_ENSURE_ARG_POINTER
(
aSpellCheckSelection
)
;
NS_ENSURE_ARG_POINTER
(
aRange
)
;
ErrorResult
rv
;
RefPtr
<
nsRange
>
range
{
aRange
}
;
RefPtr
<
Selection
>
selection
{
aSpellCheckSelection
}
;
selection
-
>
RemoveRangeAndUnselectFramesAndNotifyListeners
(
*
range
rv
)
;
if
(
!
rv
.
Failed
(
)
&
&
mNumWordsInSpellSelection
)
mNumWordsInSpellSelection
-
-
;
return
rv
.
StealNSResult
(
)
;
}
struct
mozInlineSpellChecker
:
:
CompareRangeAndNodeOffsetRange
{
static
bool
Equals
(
const
RefPtr
<
nsRange
>
&
aRange
const
NodeOffsetRange
&
aNodeOffsetRange
)
{
return
aNodeOffsetRange
=
=
*
aRange
;
}
}
;
void
mozInlineSpellChecker
:
:
UpdateRangesForMisspelledWords
(
const
nsTArray
<
NodeOffsetRange
>
&
aNodeOffsetRangesForWords
const
nsTArray
<
RefPtr
<
nsRange
>
>
&
aOldRangesForSomeWords
const
nsTArray
<
bool
>
&
aIsMisspelled
Selection
&
aSpellCheckerSelection
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Verbose
(
"
%
s
"
__FUNCTION__
)
)
;
MOZ_ASSERT
(
aNodeOffsetRangesForWords
.
Length
(
)
=
=
aIsMisspelled
.
Length
(
)
)
;
AutoTArray
<
bool
INLINESPELL_MAXIMUM_CHUNKED_WORDS_PER_TASK
>
oldRangesMarkedForRemoval
;
for
(
size_t
i
=
0
;
i
<
aOldRangesForSomeWords
.
Length
(
)
;
+
+
i
)
{
oldRangesMarkedForRemoval
.
AppendElement
(
true
)
;
}
AutoTArray
<
bool
INLINESPELL_MAXIMUM_CHUNKED_WORDS_PER_TASK
>
nodeOffsetRangesMarkedForAdding
;
for
(
size_t
i
=
0
;
i
<
aNodeOffsetRangesForWords
.
Length
(
)
;
+
+
i
)
{
nodeOffsetRangesMarkedForAdding
.
AppendElement
(
false
)
;
}
for
(
size_t
i
=
0
;
i
<
aIsMisspelled
.
Length
(
)
;
i
+
+
)
{
if
(
!
aIsMisspelled
[
i
]
)
{
continue
;
}
const
NodeOffsetRange
&
nodeOffsetRange
=
aNodeOffsetRangesForWords
[
i
]
;
const
size_t
indexOfOldRangeToKeep
=
aOldRangesForSomeWords
.
IndexOf
(
nodeOffsetRange
0
CompareRangeAndNodeOffsetRange
{
}
)
;
if
(
indexOfOldRangeToKeep
!
=
aOldRangesForSomeWords
.
NoIndex
&
&
aOldRangesForSomeWords
[
indexOfOldRangeToKeep
]
-
>
GetSelection
(
)
=
=
&
aSpellCheckerSelection
)
{
MOZ_LOG
(
sInlineSpellCheckerLog
LogLevel
:
:
Verbose
(
"
%
s
:
reusing
old
range
.
"
__FUNCTION__
)
)
;
oldRangesMarkedForRemoval
[
indexOfOldRangeToKeep
]
=
false
;
}
else
{
nodeOffsetRangesMarkedForAdding
[
i
]
=
true
;
}
}
for
(
size_t
i
=
0
;
i
<
oldRangesMarkedForRemoval
.
Length
(
)
;
+
+
i
)
{
if
(
oldRangesMarkedForRemoval
[
i
]
)
{
RemoveRange
(
&
aSpellCheckerSelection
aOldRangesForSomeWords
[
i
]
)
;
}
}
for
(
size_t
i
=
0
;
i
<
nodeOffsetRangesMarkedForAdding
.
Length
(
)
;
+
+
i
)
{
if
(
nodeOffsetRangesMarkedForAdding
[
i
]
)
{
RefPtr
<
nsRange
>
wordRange
=
mozInlineSpellWordUtil
:
:
MakeRange
(
aNodeOffsetRangesForWords
[
i
]
)
;
if
(
wordRange
)
{
AddRange
(
&
aSpellCheckerSelection
wordRange
)
;
}
}
}
}
nsresult
mozInlineSpellChecker
:
:
AddRange
(
Selection
*
aSpellCheckSelection
nsRange
*
aRange
)
{
NS_ENSURE_ARG_POINTER
(
aSpellCheckSelection
)
;
NS_ENSURE_ARG_POINTER
(
aRange
)
;
nsresult
rv
=
NS_OK
;
if
(
!
IsSpellCheckSelectionFull
(
)
)
{
IgnoredErrorResult
err
;
aSpellCheckSelection
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
aRange
err
)
;
if
(
err
.
Failed
(
)
)
{
rv
=
err
.
StealNSResult
(
)
;
}
else
{
mNumWordsInSpellSelection
+
+
;
}
}
return
rv
;
}
already_AddRefed
<
Selection
>
mozInlineSpellChecker
:
:
GetSpellCheckSelection
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
nullptr
;
}
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
SelectionType
:
:
eSpellCheck
)
;
if
(
!
selection
)
{
return
nullptr
;
}
return
selection
.
forget
(
)
;
}
nsresult
mozInlineSpellChecker
:
:
SaveCurrentSelectionPosition
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
mCurrentSelectionAnchorNode
=
selection
-
>
GetFocusNode
(
)
;
mCurrentSelectionOffset
=
selection
-
>
FocusOffset
(
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
HandleNavigationEvent
(
bool
aForceWordSpellCheck
int32_t
aNewPositionOffset
)
{
nsresult
rv
;
if
(
!
mNeedsCheckAfterNavigation
)
return
NS_OK
;
nsCOMPtr
<
nsINode
>
currentAnchorNode
=
mCurrentSelectionAnchorNode
;
uint32_t
currentAnchorOffset
=
mCurrentSelectionOffset
;
rv
=
SaveCurrentSelectionPosition
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
shouldPost
;
Result
<
UniquePtr
<
mozInlineSpellStatus
>
nsresult
>
res
=
mozInlineSpellStatus
:
:
CreateForNavigation
(
*
this
aForceWordSpellCheck
aNewPositionOffset
currentAnchorNode
currentAnchorOffset
mCurrentSelectionAnchorNode
mCurrentSelectionOffset
&
shouldPost
)
;
if
(
NS_WARN_IF
(
res
.
isErr
(
)
)
)
{
return
res
.
unwrapErr
(
)
;
}
if
(
shouldPost
)
{
rv
=
ScheduleSpellCheck
(
res
.
unwrap
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
HandleEvent
(
Event
*
aEvent
)
{
WidgetEvent
*
widgetEvent
=
aEvent
-
>
WidgetEventPtr
(
)
;
if
(
MOZ_UNLIKELY
(
!
widgetEvent
)
)
{
return
NS_OK
;
}
switch
(
widgetEvent
-
>
mMessage
)
{
case
eBlur
:
OnBlur
(
*
aEvent
)
;
return
NS_OK
;
case
eMouseClick
:
OnMouseClick
(
*
aEvent
)
;
return
NS_OK
;
case
eKeyDown
:
OnKeyDown
(
*
aEvent
)
;
return
NS_OK
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
You
must
forgot
to
handle
new
event
type
"
)
;
return
NS_OK
;
}
}
void
mozInlineSpellChecker
:
:
OnBlur
(
Event
&
aEvent
)
{
HandleNavigationEvent
(
true
)
;
}
void
mozInlineSpellChecker
:
:
OnMouseClick
(
Event
&
aMouseEvent
)
{
MouseEvent
*
mouseEvent
=
aMouseEvent
.
AsMouseEvent
(
)
;
if
(
MOZ_UNLIKELY
(
!
mouseEvent
)
)
{
return
;
}
HandleNavigationEvent
(
mouseEvent
-
>
Button
(
)
!
=
0
)
;
}
void
mozInlineSpellChecker
:
:
OnKeyDown
(
Event
&
aKeyEvent
)
{
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aKeyEvent
.
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
MOZ_UNLIKELY
(
!
widgetKeyboardEvent
)
)
{
return
;
}
switch
(
widgetKeyboardEvent
-
>
mKeyNameIndex
)
{
case
KEY_NAME_INDEX_ArrowRight
:
HandleNavigationEvent
(
false
1
)
;
return
;
case
KEY_NAME_INDEX_ArrowLeft
:
HandleNavigationEvent
(
false
-
1
)
;
return
;
case
KEY_NAME_INDEX_ArrowUp
:
case
KEY_NAME_INDEX_ArrowDown
:
case
KEY_NAME_INDEX_Home
:
case
KEY_NAME_INDEX_End
:
case
KEY_NAME_INDEX_PageDown
:
case
KEY_NAME_INDEX_PageUp
:
HandleNavigationEvent
(
true
)
;
return
;
default
:
return
;
}
}
class
UpdateCurrentDictionaryCallback
final
:
public
nsIEditorSpellCheckCallback
{
public
:
NS_DECL_ISUPPORTS
explicit
UpdateCurrentDictionaryCallback
(
mozInlineSpellChecker
*
aSpellChecker
uint32_t
aDisabledAsyncToken
)
:
mSpellChecker
(
aSpellChecker
)
mDisabledAsyncToken
(
aDisabledAsyncToken
)
{
}
NS_IMETHOD
EditorSpellCheckDone
(
)
override
{
return
mSpellChecker
-
>
GetDisabledAsyncToken
(
)
>
mDisabledAsyncToken
?
NS_OK
:
mSpellChecker
-
>
CurrentDictionaryUpdated
(
)
;
}
private
:
~
UpdateCurrentDictionaryCallback
(
)
{
}
RefPtr
<
mozInlineSpellChecker
>
mSpellChecker
;
uint32_t
mDisabledAsyncToken
;
}
;
NS_IMPL_ISUPPORTS
(
UpdateCurrentDictionaryCallback
nsIEditorSpellCheckCallback
)
NS_IMETHODIMP
mozInlineSpellChecker
:
:
UpdateCurrentDictionary
(
)
{
RefPtr
<
EditorSpellCheck
>
spellCheck
=
mSpellCheck
?
mSpellCheck
:
mPendingSpellCheck
;
if
(
!
spellCheck
)
{
return
NS_OK
;
}
RefPtr
<
UpdateCurrentDictionaryCallback
>
cb
=
new
UpdateCurrentDictionaryCallback
(
this
mDisabledAsyncToken
)
;
NS_ENSURE_STATE
(
cb
)
;
nsresult
rv
=
spellCheck
-
>
UpdateCurrentDictionary
(
cb
)
;
if
(
NS_FAILED
(
rv
)
)
{
cb
=
nullptr
;
return
rv
;
}
mNumPendingUpdateCurrentDictionary
+
+
;
ChangeNumPendingSpellChecks
(
1
)
;
return
NS_OK
;
}
nsresult
mozInlineSpellChecker
:
:
CurrentDictionaryUpdated
(
)
{
mNumPendingUpdateCurrentDictionary
-
-
;
MOZ_ASSERT
(
mNumPendingUpdateCurrentDictionary
>
=
0
"
CurrentDictionaryUpdated
called
without
corresponding
"
"
UpdateCurrentDictionary
call
!
"
)
;
ChangeNumPendingSpellChecks
(
-
1
)
;
nsresult
rv
=
SpellCheckRange
(
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozInlineSpellChecker
:
:
GetSpellCheckPending
(
bool
*
aPending
)
{
*
aPending
=
mNumPendingSpellChecks
>
0
;
return
NS_OK
;
}
