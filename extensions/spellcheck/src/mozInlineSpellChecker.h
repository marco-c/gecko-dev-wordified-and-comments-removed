#
ifndef
mozilla_mozInlineSpellChecker_h
#
define
mozilla_mozInlineSpellChecker_h
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIEditorSpellCheck
.
h
"
#
include
"
nsIInlineSpellChecker
.
h
"
#
include
"
mozInlineSpellWordUtil
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsWeakReference
.
h
"
class
InitEditorSpellCheckCallback
;
class
mozInlineSpellChecker
;
class
mozInlineSpellResume
;
class
UpdateCurrentDictionaryCallback
;
namespace
mozilla
{
class
EditorBase
;
class
EditorSpellCheck
;
enum
class
EditSubAction
:
int32_t
;
namespace
dom
{
class
Event
;
}
}
class
mozInlineSpellStatus
{
public
:
static
mozilla
:
:
Result
<
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
nsresult
>
CreateForEditorChange
(
mozInlineSpellChecker
&
aSpellChecker
mozilla
:
:
EditSubAction
aEditSubAction
nsINode
*
aAnchorNode
uint32_t
aAnchorOffset
nsINode
*
aPreviousNode
uint32_t
aPreviousOffset
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
)
;
static
mozilla
:
:
Result
<
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
nsresult
>
CreateForNavigation
(
mozInlineSpellChecker
&
aSpellChecker
bool
aForceCheck
int32_t
aNewPositionOffset
nsINode
*
aOldAnchorNode
uint32_t
aOldAnchorOffset
nsINode
*
aNewAnchorNode
uint32_t
aNewAnchorOffset
bool
*
aContinue
)
;
static
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
CreateForSelection
(
mozInlineSpellChecker
&
aSpellChecker
)
;
static
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
CreateForRange
(
mozInlineSpellChecker
&
aSpellChecker
nsRange
*
aRange
)
;
nsresult
FinishInitOnEvent
(
mozInlineSpellWordUtil
&
aWordUtil
)
;
bool
IsFullSpellCheck
(
)
const
{
return
mOp
=
=
eOpChange
&
&
!
mRange
;
}
const
RefPtr
<
mozInlineSpellChecker
>
mSpellChecker
;
enum
Operation
{
eOpChange
eOpChangeDelete
eOpNavigation
eOpSelection
eOpResume
}
;
Operation
GetOperation
(
)
const
{
return
mOp
;
}
RefPtr
<
nsRange
>
mRange
;
const
nsRange
*
GetCreatedRange
(
)
const
{
return
mCreatedRange
;
}
const
nsRange
*
GetNoCheckRange
(
)
const
{
return
mNoCheckRange
;
}
private
:
explicit
mozInlineSpellStatus
(
mozInlineSpellChecker
*
aSpellChecker
Operation
aOp
RefPtr
<
nsRange
>
&
&
aRange
RefPtr
<
nsRange
>
&
&
aCreatedRange
RefPtr
<
nsRange
>
&
&
aAnchorRange
bool
aForceNavigationWordCheck
int32_t
aNewNavigationPositionOffset
)
;
const
Operation
mOp
;
const
RefPtr
<
const
nsRange
>
mCreatedRange
;
RefPtr
<
nsRange
>
mNoCheckRange
;
const
RefPtr
<
const
nsRange
>
mAnchorRange
;
RefPtr
<
nsRange
>
mOldNavigationAnchorRange
;
const
bool
mForceNavigationWordCheck
;
const
int32_t
mNewNavigationPositionOffset
;
nsresult
FinishNavigationEvent
(
mozInlineSpellWordUtil
&
aWordUtil
)
;
nsresult
FillNoCheckRangeFromAnchor
(
mozInlineSpellWordUtil
&
aWordUtil
)
;
mozilla
:
:
dom
:
:
Document
*
GetDocument
(
)
const
;
static
already_AddRefed
<
nsRange
>
PositionToCollapsedRange
(
nsINode
*
aNode
uint32_t
aOffset
)
;
}
;
class
mozInlineSpellChecker
final
:
public
nsIInlineSpellChecker
public
nsIDOMEventListener
public
nsSupportsWeakReference
{
private
:
friend
class
mozInlineSpellStatus
;
friend
class
InitEditorSpellCheckCallback
;
friend
class
UpdateCurrentDictionaryCallback
;
friend
class
AutoChangeNumPendingSpellChecks
;
enum
SpellCheckingState
{
SpellCheck_Uninitialized
=
-
1
SpellCheck_NotAvailable
=
0
SpellCheck_Available
=
1
}
;
static
SpellCheckingState
gCanEnableSpellChecking
;
RefPtr
<
mozilla
:
:
EditorBase
>
mEditorBase
;
RefPtr
<
mozilla
:
:
EditorSpellCheck
>
mSpellCheck
;
RefPtr
<
mozilla
:
:
EditorSpellCheck
>
mPendingSpellCheck
;
int32_t
mNumWordsInSpellSelection
;
int32_t
mMaxNumWordsInSpellSelection
;
nsCOMPtr
<
nsINode
>
mCurrentSelectionAnchorNode
;
uint32_t
mCurrentSelectionOffset
;
int32_t
mNumPendingSpellChecks
;
int32_t
mNumPendingUpdateCurrentDictionary
;
uint32_t
mDisabledAsyncToken
;
RefPtr
<
InitEditorSpellCheckCallback
>
mPendingInitEditorSpellCheckCallback
;
bool
mNeedsCheckAfterNavigation
;
bool
mFullSpellCheckScheduled
;
bool
mIsListeningToEditSubActions
;
class
SpellCheckerSlice
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSIINLINESPELLCHECKER
NS_DECL_NSIDOMEVENTLISTENER
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
mozInlineSpellChecker
nsIDOMEventListener
)
mozilla
:
:
EditorSpellCheck
*
GetEditorSpellCheck
(
)
;
uint32_t
GetDisabledAsyncToken
(
)
const
{
return
mDisabledAsyncToken
;
}
static
bool
CanEnableInlineSpellChecking
(
)
;
static
void
UpdateCanEnableInlineSpellChecking
(
)
;
mozInlineSpellChecker
(
)
;
nsresult
SpellCheckBetweenNodes
(
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
;
static
bool
ShouldSpellCheckNode
(
mozilla
:
:
EditorBase
*
aEditorBase
nsINode
*
aNode
)
;
nsresult
ScheduleSpellCheck
(
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
DoSpellCheckSelection
(
mozInlineSpellWordUtil
&
aWordUtil
mozilla
:
:
dom
:
:
Selection
*
aSpellCheckSelection
)
;
nsresult
DoSpellCheck
(
mozInlineSpellWordUtil
&
aWordUtil
mozilla
:
:
dom
:
:
Selection
*
aSpellCheckSelection
const
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
&
aStatus
bool
*
aDoneChecking
)
;
static
nsresult
IsPointInSelection
(
mozilla
:
:
dom
:
:
Selection
&
aSelection
nsINode
*
aNode
int32_t
aOffset
nsRange
*
*
aRange
)
;
nsresult
CleanupRangesInSelection
(
mozilla
:
:
dom
:
:
Selection
*
aSelection
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
RemoveRange
(
mozilla
:
:
dom
:
:
Selection
*
aSpellCheckSelection
nsRange
*
aRange
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
AddRange
(
mozilla
:
:
dom
:
:
Selection
*
aSpellCheckSelection
nsRange
*
aRange
)
;
bool
IsSpellCheckSelectionFull
(
)
const
{
return
mNumWordsInSpellSelection
>
=
mMaxNumWordsInSpellSelection
;
}
nsresult
MakeSpellCheckRange
(
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
nsRange
*
*
aRange
)
const
;
nsresult
RegisterEventListeners
(
)
;
nsresult
UnregisterEventListeners
(
)
;
nsresult
HandleNavigationEvent
(
bool
aForceWordSpellCheck
int32_t
aNewPositionOffset
=
0
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Selection
>
GetSpellCheckSelection
(
)
;
nsresult
SaveCurrentSelectionPosition
(
)
;
nsresult
ResumeCheck
(
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
)
;
void
DidSplitNode
(
nsINode
*
aExistingRightNode
nsINode
*
aNewLeftNode
)
;
void
DidJoinNodes
(
nsINode
&
aRightNode
nsINode
&
aLeftNode
)
;
nsresult
SpellCheckAfterEditorChange
(
mozilla
:
:
EditSubAction
aEditSubAction
mozilla
:
:
dom
:
:
Selection
&
aSelection
nsINode
*
aPreviousSelectedNode
uint32_t
aPreviousSelectedOffset
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
)
;
protected
:
virtual
~
mozInlineSpellChecker
(
)
;
struct
CompareRangeAndNodeOffsetRange
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
UpdateRangesForMisspelledWords
(
const
nsTArray
<
NodeOffsetRange
>
&
aNodeOffsetRangesForWords
const
nsTArray
<
RefPtr
<
nsRange
>
>
&
aOldRangesForSomeWords
const
nsTArray
<
bool
>
&
aIsMisspelled
mozilla
:
:
dom
:
:
Selection
&
aSpellCheckerSelection
)
;
nsresult
EditorSpellCheckInited
(
)
;
nsresult
CurrentDictionaryUpdated
(
)
;
void
ChangeNumPendingSpellChecks
(
int32_t
aDelta
mozilla
:
:
EditorBase
*
aEditorBase
=
nullptr
)
;
void
NotifyObservers
(
const
char
*
aTopic
mozilla
:
:
EditorBase
*
aEditorBase
)
;
void
StartToListenToEditSubActions
(
)
{
mIsListeningToEditSubActions
=
true
;
}
void
EndListeningToEditSubActions
(
)
{
mIsListeningToEditSubActions
=
false
;
}
void
OnBlur
(
mozilla
:
:
dom
:
:
Event
&
aEvent
)
;
void
OnMouseClick
(
mozilla
:
:
dom
:
:
Event
&
aMouseEvent
)
;
void
OnKeyDown
(
mozilla
:
:
dom
:
:
Event
&
aKeyEvent
)
;
}
;
#
endif
