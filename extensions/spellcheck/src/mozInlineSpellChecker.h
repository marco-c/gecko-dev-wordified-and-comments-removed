#
ifndef
mozilla_mozInlineSpellChecker_h
#
define
mozilla_mozInlineSpellChecker_h
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIEditorSpellCheck
.
h
"
#
include
"
nsIInlineSpellChecker
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsWeakReference
.
h
"
class
InitEditorSpellCheckCallback
;
class
mozInlineSpellWordUtil
;
class
mozInlineSpellChecker
;
class
mozISpellI18NUtil
;
class
mozInlineSpellResume
;
class
UpdateCurrentDictionaryCallback
;
namespace
mozilla
{
class
EditorSpellCheck
;
class
TextEditor
;
enum
class
EditAction
:
int32_t
;
namespace
dom
{
class
Event
;
}
}
class
mozInlineSpellStatus
{
public
:
explicit
mozInlineSpellStatus
(
mozInlineSpellChecker
*
aSpellChecker
)
;
nsresult
InitForEditorChange
(
mozilla
:
:
EditAction
aAction
nsINode
*
aAnchorNode
uint32_t
aAnchorOffset
nsINode
*
aPreviousNode
uint32_t
aPreviousOffset
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
)
;
nsresult
InitForNavigation
(
bool
aForceCheck
int32_t
aNewPositionOffset
nsINode
*
aOldAnchorNode
uint32_t
aOldAnchorOffset
nsINode
*
aNewAnchorNode
uint32_t
aNewAnchorOffset
bool
*
aContinue
)
;
nsresult
InitForSelection
(
)
;
nsresult
InitForRange
(
nsRange
*
aRange
)
;
nsresult
FinishInitOnEvent
(
mozInlineSpellWordUtil
&
aWordUtil
)
;
bool
IsFullSpellCheck
(
)
const
{
return
mOp
=
=
eOpChange
&
&
!
mRange
;
}
RefPtr
<
mozInlineSpellChecker
>
mSpellChecker
;
int32_t
mWordCount
;
enum
Operation
{
eOpChange
eOpChangeDelete
eOpNavigation
eOpSelection
eOpResume
}
;
Operation
mOp
;
RefPtr
<
nsRange
>
mRange
;
RefPtr
<
nsRange
>
mCreatedRange
;
RefPtr
<
nsRange
>
mNoCheckRange
;
RefPtr
<
nsRange
>
mAnchorRange
;
RefPtr
<
nsRange
>
mOldNavigationAnchorRange
;
bool
mForceNavigationWordCheck
;
int32_t
mNewNavigationPositionOffset
;
protected
:
nsresult
FinishNavigationEvent
(
mozInlineSpellWordUtil
&
aWordUtil
)
;
nsresult
FillNoCheckRangeFromAnchor
(
mozInlineSpellWordUtil
&
aWordUtil
)
;
nsIDocument
*
GetDocument
(
)
const
;
already_AddRefed
<
nsRange
>
PositionToCollapsedRange
(
nsINode
*
aNode
uint32_t
aOffset
)
;
}
;
class
mozInlineSpellChecker
final
:
public
nsIInlineSpellChecker
public
nsIDOMEventListener
public
nsSupportsWeakReference
{
private
:
friend
class
mozInlineSpellStatus
;
friend
class
InitEditorSpellCheckCallback
;
friend
class
UpdateCurrentDictionaryCallback
;
friend
class
AutoChangeNumPendingSpellChecks
;
friend
class
mozInlineSpellResume
;
enum
SpellCheckingState
{
SpellCheck_Uninitialized
=
-
1
SpellCheck_NotAvailable
=
0
SpellCheck_Available
=
1
}
;
static
SpellCheckingState
gCanEnableSpellChecking
;
RefPtr
<
mozilla
:
:
TextEditor
>
mTextEditor
;
RefPtr
<
mozilla
:
:
EditorSpellCheck
>
mSpellCheck
;
RefPtr
<
mozilla
:
:
EditorSpellCheck
>
mPendingSpellCheck
;
nsCOMPtr
<
mozISpellI18NUtil
>
mConverter
;
int32_t
mNumWordsInSpellSelection
;
int32_t
mMaxNumWordsInSpellSelection
;
int32_t
mMaxMisspellingsPerCheck
;
nsCOMPtr
<
nsINode
>
mCurrentSelectionAnchorNode
;
uint32_t
mCurrentSelectionOffset
;
int32_t
mNumPendingSpellChecks
;
int32_t
mNumPendingUpdateCurrentDictionary
;
uint32_t
mDisabledAsyncToken
;
RefPtr
<
InitEditorSpellCheckCallback
>
mPendingInitEditorSpellCheckCallback
;
bool
mNeedsCheckAfterNavigation
;
bool
mFullSpellCheckScheduled
;
bool
mIsListeningToEditActions
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSIINLINESPELLCHECKER
NS_DECL_NSIDOMEVENTLISTENER
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
mozInlineSpellChecker
nsIDOMEventListener
)
mozilla
:
:
EditorSpellCheck
*
GetEditorSpellCheck
(
)
;
static
bool
CanEnableInlineSpellChecking
(
)
;
static
void
UpdateCanEnableInlineSpellChecking
(
)
;
nsresult
OnBlur
(
mozilla
:
:
dom
:
:
Event
*
aEvent
)
;
nsresult
OnMouseClick
(
mozilla
:
:
dom
:
:
Event
*
aMouseEvent
)
;
nsresult
OnKeyPress
(
mozilla
:
:
dom
:
:
Event
*
aKeyEvent
)
;
mozInlineSpellChecker
(
)
;
nsresult
SpellCheckBetweenNodes
(
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
;
bool
ShouldSpellCheckNode
(
mozilla
:
:
TextEditor
*
aTextEditor
nsINode
*
aNode
)
;
nsresult
ScheduleSpellCheck
(
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
)
;
nsresult
DoSpellCheckSelection
(
mozInlineSpellWordUtil
&
aWordUtil
mozilla
:
:
dom
:
:
Selection
*
aSpellCheckSelection
)
;
nsresult
DoSpellCheck
(
mozInlineSpellWordUtil
&
aWordUtil
mozilla
:
:
dom
:
:
Selection
*
aSpellCheckSelection
const
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
&
aStatus
bool
*
aDoneChecking
)
;
nsresult
IsPointInSelection
(
mozilla
:
:
dom
:
:
Selection
&
aSelection
nsIDOMNode
*
aNode
int32_t
aOffset
nsRange
*
*
aRange
)
;
nsresult
CleanupRangesInSelection
(
mozilla
:
:
dom
:
:
Selection
*
aSelection
)
;
nsresult
RemoveRange
(
mozilla
:
:
dom
:
:
Selection
*
aSpellCheckSelection
nsRange
*
aRange
)
;
nsresult
AddRange
(
mozilla
:
:
dom
:
:
Selection
*
aSpellCheckSelection
nsRange
*
aRange
)
;
bool
SpellCheckSelectionIsFull
(
)
{
return
mNumWordsInSpellSelection
>
=
mMaxNumWordsInSpellSelection
;
}
nsresult
MakeSpellCheckRange
(
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
nsRange
*
*
aRange
)
;
nsresult
RegisterEventListeners
(
)
;
nsresult
UnregisterEventListeners
(
)
;
nsresult
HandleNavigationEvent
(
bool
aForceWordSpellCheck
int32_t
aNewPositionOffset
=
0
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Selection
>
GetSpellCheckSelection
(
)
;
nsresult
SaveCurrentSelectionPosition
(
)
;
nsresult
ResumeCheck
(
mozilla
:
:
UniquePtr
<
mozInlineSpellStatus
>
&
&
aStatus
)
;
void
DidSplitNode
(
nsINode
*
aExistingRightNode
nsINode
*
aNewLeftNode
)
;
void
DidJoinNodes
(
nsINode
&
aRightNode
nsINode
&
aLeftNode
)
;
nsresult
SpellCheckAfterEditorChange
(
mozilla
:
:
EditAction
aAction
mozilla
:
:
dom
:
:
Selection
&
aSelection
nsINode
*
aPreviousSelectedNode
uint32_t
aPreviousSelectedOffset
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
)
;
protected
:
virtual
~
mozInlineSpellChecker
(
)
;
nsresult
EditorSpellCheckInited
(
)
;
nsresult
CurrentDictionaryUpdated
(
)
;
void
ChangeNumPendingSpellChecks
(
int32_t
aDelta
mozilla
:
:
TextEditor
*
aTextEditor
=
nullptr
)
;
void
NotifyObservers
(
const
char
*
aTopic
mozilla
:
:
TextEditor
*
aTextEditor
)
;
void
StartToListenToEditActions
(
)
{
mIsListeningToEditActions
=
true
;
}
void
EndListeningToEditActions
(
)
{
mIsListeningToEditActions
=
false
;
}
}
;
#
endif
