#
include
"
hunspell_csutil
.
hxx
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
nsUnicharUtils
.
h
"
struct
cs_info
*
hunspell_get_current_cs
(
const
std
:
:
string
&
es
)
{
struct
cs_info
*
ccs
=
new
cs_info
[
256
]
;
for
(
int
i
=
0
;
i
<
=
0xff
;
+
+
i
)
{
ccs
[
i
]
.
ccase
=
false
;
ccs
[
i
]
.
clower
=
i
;
ccs
[
i
]
.
cupper
=
i
;
}
auto
encoding
=
mozilla
:
:
Encoding
:
:
ForLabelNoReplacement
(
es
)
;
if
(
!
encoding
)
{
return
ccs
;
}
auto
encoder
=
encoding
-
>
NewEncoder
(
)
;
auto
decoder
=
encoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
=
0xff
;
+
+
i
)
{
bool
success
=
false
;
uint8_t
lower
upper
;
do
{
if
(
i
=
=
0
)
break
;
uint8_t
source
=
uint8_t
(
i
)
;
char16_t
uni
[
2
]
;
char16_t
uniCased
;
uint8_t
destination
[
4
]
;
auto
src1
=
mozilla
:
:
Span
(
&
source
1
)
;
auto
dst1
=
mozilla
:
:
Span
(
uni
)
;
auto
src2
=
mozilla
:
:
Span
(
&
uniCased
1
)
;
auto
dst2
=
mozilla
:
:
Span
(
destination
)
;
uint32_t
result
;
size_t
read
;
size_t
written
;
mozilla
:
:
Tie
(
result
read
written
)
=
decoder
-
>
DecodeToUTF16WithoutReplacement
(
src1
dst1
true
)
;
if
(
result
!
=
mozilla
:
:
kInputEmpty
|
|
read
!
=
1
|
|
written
!
=
1
)
{
break
;
}
uniCased
=
ToLowerCase
(
uni
[
0
]
)
;
mozilla
:
:
Tie
(
result
read
written
)
=
encoder
-
>
EncodeFromUTF16WithoutReplacement
(
src2
dst2
true
)
;
if
(
result
!
=
mozilla
:
:
kInputEmpty
|
|
read
!
=
1
|
|
written
!
=
1
)
{
break
;
}
lower
=
destination
[
0
]
;
uniCased
=
ToUpperCase
(
uni
[
0
]
)
;
mozilla
:
:
Tie
(
result
read
written
)
=
encoder
-
>
EncodeFromUTF16WithoutReplacement
(
src2
dst2
true
)
;
if
(
result
!
=
mozilla
:
:
kInputEmpty
|
|
read
!
=
1
|
|
written
!
=
1
)
{
break
;
}
upper
=
destination
[
0
]
;
success
=
true
;
}
while
(
0
)
;
encoding
-
>
NewEncoderInto
(
*
encoder
)
;
encoding
-
>
NewDecoderWithoutBOMHandlingInto
(
*
decoder
)
;
if
(
success
)
{
ccs
[
i
]
.
cupper
=
upper
;
ccs
[
i
]
.
clower
=
lower
;
}
else
{
ccs
[
i
]
.
cupper
=
i
;
ccs
[
i
]
.
clower
=
i
;
}
if
(
ccs
[
i
]
.
clower
!
=
(
unsigned
char
)
i
)
ccs
[
i
]
.
ccase
=
true
;
else
ccs
[
i
]
.
ccase
=
false
;
}
return
ccs
;
}
