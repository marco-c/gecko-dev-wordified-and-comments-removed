#
include
"
mozHunspellFileMgr
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsXPCOM
.
h
"
using
namespace
mozilla
;
FileMgr
:
:
FileMgr
(
const
char
*
aFilename
const
char
*
aKey
)
{
DebugOnly
<
Result
<
Ok
nsresult
>
>
result
=
Open
(
nsDependentCString
(
aFilename
)
)
;
NS_WARNING_ASSERTION
(
result
.
value
.
isOk
(
)
"
Failed
to
open
Hunspell
file
"
)
;
}
Result
<
Ok
nsresult
>
FileMgr
:
:
Open
(
const
nsACString
&
aPath
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsCOMPtr
<
nsIFile
>
file
;
MOZ_TRY
(
NS_NewNativeLocalFile
(
aPath
false
getter_AddRefs
(
file
)
)
)
;
MOZ_TRY
(
NS_NewFileURI
(
getter_AddRefs
(
uri
)
file
)
)
;
}
nsCOMPtr
<
nsIChannel
>
channel
;
MOZ_TRY
(
NS_NewChannel
(
getter_AddRefs
(
channel
)
uri
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
nsIContentPolicy
:
:
TYPE_OTHER
)
)
;
MOZ_TRY
(
channel
-
>
Open2
(
getter_AddRefs
(
mStream
)
)
)
;
return
Ok
(
)
;
}
Result
<
Ok
nsresult
>
FileMgr
:
:
ReadLine
(
nsACString
&
aLine
)
{
if
(
!
mStream
)
{
return
Err
(
NS_ERROR_NOT_INITIALIZED
)
;
}
bool
ok
;
MOZ_TRY
(
NS_ReadLine
(
mStream
.
get
(
)
&
mLineBuffer
aLine
&
ok
)
)
;
if
(
!
ok
)
{
mStream
=
nullptr
;
}
mLineNum
+
+
;
return
Ok
(
)
;
}
bool
FileMgr
:
:
getline
(
std
:
:
string
&
aResult
)
{
nsAutoCString
line
;
auto
res
=
ReadLine
(
line
)
;
if
(
res
.
isErr
(
)
)
{
return
false
;
}
aResult
.
assign
(
line
.
BeginReading
(
)
line
.
Length
(
)
)
;
return
true
;
}
