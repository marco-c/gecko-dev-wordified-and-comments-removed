#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
stdio
.
h
>
#
include
<
limits
>
#
include
"
replist
.
hxx
"
#
include
"
csutil
.
hxx
"
RepList
:
:
RepList
(
int
n
)
{
dat
=
(
replentry
*
*
)
malloc
(
sizeof
(
replentry
*
)
*
n
)
;
if
(
dat
=
=
0
)
size
=
0
;
else
size
=
n
;
pos
=
0
;
}
RepList
:
:
~
RepList
(
)
{
for
(
int
i
=
0
;
i
<
pos
;
i
+
+
)
{
delete
dat
[
i
]
;
}
free
(
dat
)
;
}
replentry
*
RepList
:
:
item
(
int
n
)
{
return
dat
[
n
]
;
}
int
RepList
:
:
find
(
const
char
*
word
)
{
int
p1
=
0
;
int
p2
=
pos
-
1
;
while
(
p1
<
=
p2
)
{
int
m
=
(
p1
+
p2
)
/
2
;
int
c
=
strncmp
(
word
dat
[
m
]
-
>
pattern
.
c_str
(
)
dat
[
m
]
-
>
pattern
.
size
(
)
)
;
if
(
c
<
0
)
p2
=
m
-
1
;
else
if
(
c
>
0
)
p1
=
m
+
1
;
else
{
for
(
p1
=
m
-
1
;
p1
>
=
0
;
-
-
p1
)
if
(
!
strncmp
(
word
dat
[
p1
]
-
>
pattern
.
c_str
(
)
dat
[
p1
]
-
>
pattern
.
size
(
)
)
)
m
=
p1
;
else
if
(
dat
[
p1
]
-
>
pattern
.
size
(
)
<
dat
[
m
]
-
>
pattern
.
size
(
)
)
break
;
return
m
;
}
}
return
-
1
;
}
std
:
:
string
RepList
:
:
replace
(
const
char
*
word
int
ind
bool
atstart
)
{
int
type
=
atstart
?
1
:
0
;
if
(
ind
<
0
)
return
std
:
:
string
(
)
;
if
(
strlen
(
word
)
=
=
dat
[
ind
]
-
>
pattern
.
size
(
)
)
type
=
atstart
?
3
:
2
;
while
(
type
&
&
dat
[
ind
]
-
>
outstrings
[
type
]
.
empty
(
)
)
type
=
(
type
=
=
2
&
&
!
atstart
)
?
0
:
type
-
1
;
return
dat
[
ind
]
-
>
outstrings
[
type
]
;
}
int
RepList
:
:
add
(
const
std
:
:
string
&
in_pat1
const
std
:
:
string
&
pat2
)
{
if
(
pos
>
=
size
|
|
in_pat1
.
empty
(
)
|
|
pat2
.
empty
(
)
)
{
return
1
;
}
int
type
=
0
;
std
:
:
string
pat1
(
in_pat1
)
;
if
(
pat1
[
0
]
=
=
'
_
'
)
{
pat1
.
erase
(
0
1
)
;
type
=
1
;
}
if
(
!
pat1
.
empty
(
)
&
&
pat1
[
pat1
.
size
(
)
-
1
]
=
=
'
_
'
)
{
type
=
type
+
2
;
pat1
.
erase
(
pat1
.
size
(
)
-
1
)
;
}
mystrrep
(
pat1
"
_
"
"
"
)
;
int
m
=
find
(
pat1
.
c_str
(
)
)
;
if
(
m
>
=
0
&
&
dat
[
m
]
-
>
pattern
=
=
pat1
)
{
dat
[
m
]
-
>
outstrings
[
type
]
=
pat2
;
mystrrep
(
dat
[
m
]
-
>
outstrings
[
type
]
"
_
"
"
"
)
;
return
0
;
}
replentry
*
r
=
new
replentry
;
if
(
r
=
=
NULL
)
return
1
;
r
-
>
pattern
=
pat1
;
r
-
>
outstrings
[
type
]
=
pat2
;
mystrrep
(
r
-
>
outstrings
[
type
]
"
_
"
"
"
)
;
dat
[
pos
+
+
]
=
r
;
int
i
;
for
(
i
=
pos
-
1
;
i
>
0
;
i
-
-
)
{
int
c
=
strncmp
(
r
-
>
pattern
.
c_str
(
)
dat
[
i
-
1
]
-
>
pattern
.
c_str
(
)
dat
[
i
-
1
]
-
>
pattern
.
size
(
)
)
;
if
(
c
>
0
)
break
;
else
if
(
c
=
=
0
)
{
for
(
int
j
=
i
-
2
;
j
>
0
&
&
!
strncmp
(
dat
[
i
-
1
]
-
>
pattern
.
c_str
(
)
dat
[
j
]
-
>
pattern
.
c_str
(
)
dat
[
i
-
1
]
-
>
pattern
.
size
(
)
)
;
-
-
j
)
if
(
dat
[
j
]
-
>
pattern
.
size
(
)
>
r
-
>
pattern
.
size
(
)
|
|
(
dat
[
j
]
-
>
pattern
.
size
(
)
=
=
r
-
>
pattern
.
size
(
)
&
&
strncmp
(
dat
[
j
]
-
>
pattern
.
c_str
(
)
r
-
>
pattern
.
c_str
(
)
r
-
>
pattern
.
size
(
)
)
>
0
)
)
{
i
=
j
;
break
;
}
break
;
}
}
memmove
(
dat
+
i
+
1
dat
+
i
(
pos
-
i
-
1
)
*
sizeof
(
replentry
*
)
)
;
dat
[
i
]
=
r
;
return
0
;
}
bool
RepList
:
:
conv
(
const
std
:
:
string
&
in_word
std
:
:
string
&
dest
)
{
dest
.
clear
(
)
;
size_t
wordlen
=
in_word
.
size
(
)
;
const
char
*
word
=
in_word
.
c_str
(
)
;
bool
change
=
false
;
for
(
size_t
i
=
0
;
i
<
wordlen
;
+
+
i
)
{
int
n
=
find
(
word
+
i
)
;
std
:
:
string
l
=
replace
(
word
+
i
n
i
=
=
0
)
;
if
(
!
l
.
empty
(
)
)
{
dest
.
append
(
l
)
;
i
+
=
dat
[
n
]
-
>
pattern
.
size
(
)
-
1
;
change
=
true
;
}
else
{
dest
.
push_back
(
word
[
i
]
)
;
}
}
return
change
;
}
