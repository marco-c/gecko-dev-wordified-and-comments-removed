#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
stdio
.
h
>
#
include
<
ctype
.
h
>
#
include
<
time
.
h
>
#
include
<
algorithm
>
#
include
<
limits
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
affixmgr
.
hxx
"
#
include
"
affentry
.
hxx
"
#
include
"
langnum
.
hxx
"
#
include
"
csutil
.
hxx
"
AffixMgr
:
:
AffixMgr
(
const
char
*
affpath
const
std
:
:
vector
<
HashMgr
*
>
&
ptr
const
char
*
key
)
:
alldic
(
ptr
)
pHMgr
(
ptr
[
0
]
)
{
csconv
=
NULL
;
utf8
=
0
;
complexprefixes
=
0
;
parsedmaptable
=
false
;
parsedbreaktable
=
false
;
iconvtable
=
NULL
;
oconvtable
=
NULL
;
simplifiedcpd
=
0
;
parsedcheckcpd
=
false
;
parseddefcpd
=
false
;
phone
=
NULL
;
compoundflag
=
FLAG_NULL
;
compoundbegin
=
FLAG_NULL
;
compoundmiddle
=
FLAG_NULL
;
compoundend
=
FLAG_NULL
;
compoundroot
=
FLAG_NULL
;
compoundpermitflag
=
FLAG_NULL
;
compoundforbidflag
=
FLAG_NULL
;
compoundmoresuffixes
=
0
;
checkcompounddup
=
0
;
checkcompoundrep
=
0
;
checkcompoundcase
=
0
;
checkcompoundtriple
=
0
;
simplifiedtriple
=
0
;
forbiddenword
=
FORBIDDENWORD
;
nosuggest
=
FLAG_NULL
;
nongramsuggest
=
FLAG_NULL
;
langnum
=
0
;
needaffix
=
FLAG_NULL
;
cpdwordmax
=
-
1
;
cpdmin
=
-
1
;
cpdmaxsyllable
=
0
;
pfxappnd
=
NULL
;
sfxappnd
=
NULL
;
sfxextra
=
0
;
checknum
=
0
;
havecontclass
=
0
;
lemma_present
=
FLAG_NULL
;
circumfix
=
FLAG_NULL
;
onlyincompound
=
FLAG_NULL
;
maxngramsugs
=
-
1
;
maxdiff
=
-
1
;
onlymaxdiff
=
0
;
maxcpdsugs
=
-
1
;
nosplitsugs
=
0
;
sugswithdots
=
0
;
keepcase
=
0
;
forceucase
=
0
;
warn
=
0
;
forbidwarn
=
0
;
checksharps
=
0
;
substandard
=
FLAG_NULL
;
fullstrip
=
0
;
sfx
=
NULL
;
pfx
=
NULL
;
for
(
int
i
=
0
;
i
<
SETSIZE
;
i
+
+
)
{
pStart
[
i
]
=
NULL
;
sStart
[
i
]
=
NULL
;
pFlag
[
i
]
=
NULL
;
sFlag
[
i
]
=
NULL
;
}
for
(
int
j
=
0
;
j
<
CONTSIZE
;
j
+
+
)
{
contclasses
[
j
]
=
0
;
}
if
(
parse_file
(
affpath
key
)
)
{
HUNSPELL_WARNING
(
stderr
"
Failure
loading
aff
file
%
s
\
n
"
affpath
)
;
}
if
(
cpdmin
=
=
-
1
)
cpdmin
=
MINCPDLEN
;
}
AffixMgr
:
:
~
AffixMgr
(
)
{
for
(
int
i
=
0
;
i
<
SETSIZE
;
i
+
+
)
{
pFlag
[
i
]
=
NULL
;
PfxEntry
*
ptr
=
pStart
[
i
]
;
PfxEntry
*
nptr
=
NULL
;
while
(
ptr
)
{
nptr
=
ptr
-
>
getNext
(
)
;
delete
(
ptr
)
;
ptr
=
nptr
;
nptr
=
NULL
;
}
}
for
(
int
j
=
0
;
j
<
SETSIZE
;
j
+
+
)
{
sFlag
[
j
]
=
NULL
;
SfxEntry
*
ptr
=
sStart
[
j
]
;
SfxEntry
*
nptr
=
NULL
;
while
(
ptr
)
{
nptr
=
ptr
-
>
getNext
(
)
;
delete
(
ptr
)
;
ptr
=
nptr
;
nptr
=
NULL
;
}
sStart
[
j
]
=
NULL
;
}
delete
iconvtable
;
delete
oconvtable
;
delete
phone
;
FREE_FLAG
(
compoundflag
)
;
FREE_FLAG
(
compoundbegin
)
;
FREE_FLAG
(
compoundmiddle
)
;
FREE_FLAG
(
compoundend
)
;
FREE_FLAG
(
compoundpermitflag
)
;
FREE_FLAG
(
compoundforbidflag
)
;
FREE_FLAG
(
compoundroot
)
;
FREE_FLAG
(
forbiddenword
)
;
FREE_FLAG
(
nosuggest
)
;
FREE_FLAG
(
nongramsuggest
)
;
FREE_FLAG
(
needaffix
)
;
FREE_FLAG
(
lemma_present
)
;
FREE_FLAG
(
circumfix
)
;
FREE_FLAG
(
onlyincompound
)
;
cpdwordmax
=
0
;
pHMgr
=
NULL
;
cpdmin
=
0
;
cpdmaxsyllable
=
0
;
free_utf_tbl
(
)
;
checknum
=
0
;
#
ifdef
MOZILLA_CLIENT
delete
[
]
csconv
;
#
endif
}
void
AffixMgr
:
:
finishFileMgr
(
FileMgr
*
afflst
)
{
delete
afflst
;
process_pfx_tree_to_list
(
)
;
process_sfx_tree_to_list
(
)
;
}
int
AffixMgr
:
:
parse_file
(
const
char
*
affpath
const
char
*
key
)
{
char
dupflags
[
CONTSIZE
]
;
char
dupflags_ini
=
1
;
int
firstline
=
1
;
FileMgr
*
afflst
=
new
FileMgr
(
affpath
key
)
;
if
(
!
afflst
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
could
not
open
affix
description
file
%
s
\
n
"
affpath
)
;
return
1
;
}
std
:
:
string
line
;
while
(
afflst
-
>
getline
(
line
)
)
{
mychomp
(
line
)
;
if
(
firstline
)
{
firstline
=
0
;
if
(
line
.
compare
(
0
3
"
\
xEF
\
xBB
\
xBF
"
3
)
=
=
0
)
{
line
.
erase
(
0
3
)
;
}
}
if
(
line
.
compare
(
0
3
"
KEY
"
3
)
=
=
0
)
{
if
(
!
parse_string
(
line
keystring
afflst
-
>
getlinenum
(
)
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
3
"
TRY
"
3
)
=
=
0
)
{
if
(
!
parse_string
(
line
trystring
afflst
-
>
getlinenum
(
)
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
3
"
SET
"
3
)
=
=
0
)
{
if
(
!
parse_string
(
line
encoding
afflst
-
>
getlinenum
(
)
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
if
(
encoding
=
=
"
UTF
-
8
"
)
{
utf8
=
1
;
#
ifndef
OPENOFFICEORG
#
ifndef
MOZILLA_CLIENT
initialize_utf_tbl
(
)
;
#
endif
#
endif
}
}
if
(
line
.
compare
(
0
15
"
COMPLEXPREFIXES
"
15
)
=
=
0
)
complexprefixes
=
1
;
if
(
line
.
compare
(
0
12
"
COMPOUNDFLAG
"
12
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
compoundflag
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
13
"
COMPOUNDBEGIN
"
13
)
=
=
0
)
{
if
(
complexprefixes
)
{
if
(
!
parse_flag
(
line
&
compoundend
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
else
{
if
(
!
parse_flag
(
line
&
compoundbegin
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
}
if
(
line
.
compare
(
0
14
"
COMPOUNDMIDDLE
"
14
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
compoundmiddle
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
11
"
COMPOUNDEND
"
11
)
=
=
0
)
{
if
(
complexprefixes
)
{
if
(
!
parse_flag
(
line
&
compoundbegin
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
else
{
if
(
!
parse_flag
(
line
&
compoundend
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
}
if
(
line
.
compare
(
0
15
"
COMPOUNDWORDMAX
"
15
)
=
=
0
)
{
if
(
!
parse_num
(
line
&
cpdwordmax
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
12
"
COMPOUNDROOT
"
12
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
compoundroot
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
18
"
COMPOUNDPERMITFLAG
"
18
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
compoundpermitflag
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
18
"
COMPOUNDFORBIDFLAG
"
18
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
compoundforbidflag
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
20
"
COMPOUNDMORESUFFIXES
"
20
)
=
=
0
)
{
compoundmoresuffixes
=
1
;
}
if
(
line
.
compare
(
0
16
"
CHECKCOMPOUNDDUP
"
16
)
=
=
0
)
{
checkcompounddup
=
1
;
}
if
(
line
.
compare
(
0
16
"
CHECKCOMPOUNDREP
"
16
)
=
=
0
)
{
checkcompoundrep
=
1
;
}
if
(
line
.
compare
(
0
19
"
CHECKCOMPOUNDTRIPLE
"
19
)
=
=
0
)
{
checkcompoundtriple
=
1
;
}
if
(
line
.
compare
(
0
16
"
SIMPLIFIEDTRIPLE
"
16
)
=
=
0
)
{
simplifiedtriple
=
1
;
}
if
(
line
.
compare
(
0
17
"
CHECKCOMPOUNDCASE
"
17
)
=
=
0
)
{
checkcompoundcase
=
1
;
}
if
(
line
.
compare
(
0
9
"
NOSUGGEST
"
9
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
nosuggest
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
14
"
NONGRAMSUGGEST
"
14
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
nongramsuggest
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
13
"
FORBIDDENWORD
"
13
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
forbiddenword
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
13
"
LEMMA_PRESENT
"
13
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
lemma_present
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
9
"
CIRCUMFIX
"
9
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
circumfix
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
14
"
ONLYINCOMPOUND
"
14
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
onlyincompound
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
10
"
PSEUDOROOT
"
10
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
needaffix
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
9
"
NEEDAFFIX
"
9
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
needaffix
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
11
"
COMPOUNDMIN
"
11
)
=
=
0
)
{
if
(
!
parse_num
(
line
&
cpdmin
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
if
(
cpdmin
<
1
)
cpdmin
=
1
;
}
if
(
line
.
compare
(
0
16
"
COMPOUNDSYLLABLE
"
16
)
=
=
0
)
{
if
(
!
parse_cpdsyllable
(
line
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
11
"
SYLLABLENUM
"
11
)
=
=
0
)
{
if
(
!
parse_string
(
line
cpdsyllablenum
afflst
-
>
getlinenum
(
)
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
8
"
CHECKNUM
"
8
)
=
=
0
)
{
checknum
=
1
;
}
if
(
line
.
compare
(
0
9
"
WORDCHARS
"
9
)
=
=
0
)
{
if
(
!
parse_array
(
line
wordchars
wordchars_utf16
utf8
afflst
-
>
getlinenum
(
)
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
6
"
IGNORE
"
6
)
=
=
0
)
{
if
(
!
parse_array
(
line
ignorechars
ignorechars_utf16
utf8
afflst
-
>
getlinenum
(
)
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
5
"
ICONV
"
5
)
=
=
0
)
{
if
(
!
parse_convtable
(
line
afflst
&
iconvtable
"
ICONV
"
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
5
"
OCONV
"
5
)
=
=
0
)
{
if
(
!
parse_convtable
(
line
afflst
&
oconvtable
"
OCONV
"
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
5
"
PHONE
"
5
)
=
=
0
)
{
if
(
!
parse_phonetable
(
line
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
20
"
CHECKCOMPOUNDPATTERN
"
20
)
=
=
0
)
{
if
(
!
parse_checkcpdtable
(
line
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
12
"
COMPOUNDRULE
"
12
)
=
=
0
)
{
if
(
!
parse_defcpdtable
(
line
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
3
"
MAP
"
3
)
=
=
0
)
{
if
(
!
parse_maptable
(
line
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
5
"
BREAK
"
5
)
=
=
0
)
{
if
(
!
parse_breaktable
(
line
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
4
"
LANG
"
4
)
=
=
0
)
{
if
(
!
parse_string
(
line
lang
afflst
-
>
getlinenum
(
)
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
langnum
=
get_lang_num
(
lang
)
;
}
if
(
line
.
compare
(
0
7
"
VERSION
"
7
)
=
=
0
)
{
size_t
startpos
=
line
.
find_first_not_of
(
"
\
t
"
7
)
;
if
(
startpos
!
=
std
:
:
string
:
:
npos
)
{
version
=
line
.
substr
(
startpos
)
;
}
}
if
(
line
.
compare
(
0
12
"
MAXNGRAMSUGS
"
12
)
=
=
0
)
{
if
(
!
parse_num
(
line
&
maxngramsugs
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
11
"
ONLYMAXDIFF
"
11
)
=
=
0
)
onlymaxdiff
=
1
;
if
(
line
.
compare
(
0
7
"
MAXDIFF
"
7
)
=
=
0
)
{
if
(
!
parse_num
(
line
&
maxdiff
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
10
"
MAXCPDSUGS
"
10
)
=
=
0
)
{
if
(
!
parse_num
(
line
&
maxcpdsugs
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
11
"
NOSPLITSUGS
"
11
)
=
=
0
)
{
nosplitsugs
=
1
;
}
if
(
line
.
compare
(
0
9
"
FULLSTRIP
"
9
)
=
=
0
)
{
fullstrip
=
1
;
}
if
(
line
.
compare
(
0
12
"
SUGSWITHDOTS
"
12
)
=
=
0
)
{
sugswithdots
=
1
;
}
if
(
line
.
compare
(
0
8
"
KEEPCASE
"
8
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
keepcase
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
10
"
FORCEUCASE
"
10
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
forceucase
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
4
"
WARN
"
4
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
warn
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
10
"
FORBIDWARN
"
10
)
=
=
0
)
{
forbidwarn
=
1
;
}
if
(
line
.
compare
(
0
11
"
SUBSTANDARD
"
11
)
=
=
0
)
{
if
(
!
parse_flag
(
line
&
substandard
afflst
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
if
(
line
.
compare
(
0
11
"
CHECKSHARPS
"
11
)
=
=
0
)
{
checksharps
=
1
;
}
char
ft
=
'
'
;
if
(
line
.
compare
(
0
3
"
PFX
"
3
)
=
=
0
)
ft
=
complexprefixes
?
'
S
'
:
'
P
'
;
if
(
line
.
compare
(
0
3
"
SFX
"
3
)
=
=
0
)
ft
=
complexprefixes
?
'
P
'
:
'
S
'
;
if
(
ft
!
=
'
'
)
{
if
(
dupflags_ini
)
{
memset
(
dupflags
0
sizeof
(
dupflags
)
)
;
dupflags_ini
=
0
;
}
if
(
!
parse_affix
(
line
ft
afflst
dupflags
)
)
{
finishFileMgr
(
afflst
)
;
return
1
;
}
}
}
finishFileMgr
(
afflst
)
;
process_pfx_order
(
)
;
process_sfx_order
(
)
;
if
(
!
utf8
)
{
csconv
=
get_current_cs
(
get_encoding
(
)
)
;
for
(
int
i
=
0
;
i
<
=
255
;
i
+
+
)
{
if
(
(
csconv
[
i
]
.
cupper
!
=
csconv
[
i
]
.
clower
)
&
&
(
wordchars
.
find
(
(
char
)
i
)
=
=
std
:
:
string
:
:
npos
)
)
{
wordchars
.
push_back
(
(
char
)
i
)
;
}
}
}
if
(
!
parsedbreaktable
)
{
breaktable
.
push_back
(
"
-
"
)
;
breaktable
.
push_back
(
"
^
-
"
)
;
breaktable
.
push_back
(
"
-
"
)
;
parsedbreaktable
=
true
;
}
return
0
;
}
int
AffixMgr
:
:
build_pfxtree
(
PfxEntry
*
pfxptr
)
{
PfxEntry
*
ptr
;
PfxEntry
*
pptr
;
PfxEntry
*
ep
=
pfxptr
;
const
char
*
key
=
ep
-
>
getKey
(
)
;
const
unsigned
char
flg
=
(
unsigned
char
)
(
ep
-
>
getFlag
(
)
&
0x00FF
)
;
ptr
=
pFlag
[
flg
]
;
ep
-
>
setFlgNxt
(
ptr
)
;
pFlag
[
flg
]
=
ep
;
if
(
strlen
(
key
)
=
=
0
)
{
ptr
=
pStart
[
0
]
;
ep
-
>
setNext
(
ptr
)
;
pStart
[
0
]
=
ep
;
return
0
;
}
ep
-
>
setNextEQ
(
NULL
)
;
ep
-
>
setNextNE
(
NULL
)
;
unsigned
char
sp
=
*
(
(
const
unsigned
char
*
)
key
)
;
ptr
=
pStart
[
sp
]
;
if
(
!
ptr
)
{
pStart
[
sp
]
=
ep
;
return
0
;
}
pptr
=
NULL
;
for
(
;
;
)
{
pptr
=
ptr
;
if
(
strcmp
(
ep
-
>
getKey
(
)
ptr
-
>
getKey
(
)
)
<
=
0
)
{
ptr
=
ptr
-
>
getNextEQ
(
)
;
if
(
!
ptr
)
{
pptr
-
>
setNextEQ
(
ep
)
;
break
;
}
}
else
{
ptr
=
ptr
-
>
getNextNE
(
)
;
if
(
!
ptr
)
{
pptr
-
>
setNextNE
(
ep
)
;
break
;
}
}
}
return
0
;
}
int
AffixMgr
:
:
build_sfxtree
(
SfxEntry
*
sfxptr
)
{
sfxptr
-
>
initReverseWord
(
)
;
SfxEntry
*
ptr
;
SfxEntry
*
pptr
;
SfxEntry
*
ep
=
sfxptr
;
const
char
*
key
=
ep
-
>
getKey
(
)
;
const
unsigned
char
flg
=
(
unsigned
char
)
(
ep
-
>
getFlag
(
)
&
0x00FF
)
;
ptr
=
sFlag
[
flg
]
;
ep
-
>
setFlgNxt
(
ptr
)
;
sFlag
[
flg
]
=
ep
;
if
(
strlen
(
key
)
=
=
0
)
{
ptr
=
sStart
[
0
]
;
ep
-
>
setNext
(
ptr
)
;
sStart
[
0
]
=
ep
;
return
0
;
}
ep
-
>
setNextEQ
(
NULL
)
;
ep
-
>
setNextNE
(
NULL
)
;
unsigned
char
sp
=
*
(
(
const
unsigned
char
*
)
key
)
;
ptr
=
sStart
[
sp
]
;
if
(
!
ptr
)
{
sStart
[
sp
]
=
ep
;
return
0
;
}
pptr
=
NULL
;
for
(
;
;
)
{
pptr
=
ptr
;
if
(
strcmp
(
ep
-
>
getKey
(
)
ptr
-
>
getKey
(
)
)
<
=
0
)
{
ptr
=
ptr
-
>
getNextEQ
(
)
;
if
(
!
ptr
)
{
pptr
-
>
setNextEQ
(
ep
)
;
break
;
}
}
else
{
ptr
=
ptr
-
>
getNextNE
(
)
;
if
(
!
ptr
)
{
pptr
-
>
setNextNE
(
ep
)
;
break
;
}
}
}
return
0
;
}
int
AffixMgr
:
:
process_pfx_tree_to_list
(
)
{
for
(
int
i
=
1
;
i
<
SETSIZE
;
i
+
+
)
{
pStart
[
i
]
=
process_pfx_in_order
(
pStart
[
i
]
NULL
)
;
}
return
0
;
}
PfxEntry
*
AffixMgr
:
:
process_pfx_in_order
(
PfxEntry
*
ptr
PfxEntry
*
nptr
)
{
if
(
ptr
)
{
nptr
=
process_pfx_in_order
(
ptr
-
>
getNextNE
(
)
nptr
)
;
ptr
-
>
setNext
(
nptr
)
;
nptr
=
process_pfx_in_order
(
ptr
-
>
getNextEQ
(
)
ptr
)
;
}
return
nptr
;
}
int
AffixMgr
:
:
process_sfx_tree_to_list
(
)
{
for
(
int
i
=
1
;
i
<
SETSIZE
;
i
+
+
)
{
sStart
[
i
]
=
process_sfx_in_order
(
sStart
[
i
]
NULL
)
;
}
return
0
;
}
SfxEntry
*
AffixMgr
:
:
process_sfx_in_order
(
SfxEntry
*
ptr
SfxEntry
*
nptr
)
{
if
(
ptr
)
{
nptr
=
process_sfx_in_order
(
ptr
-
>
getNextNE
(
)
nptr
)
;
ptr
-
>
setNext
(
nptr
)
;
nptr
=
process_sfx_in_order
(
ptr
-
>
getNextEQ
(
)
ptr
)
;
}
return
nptr
;
}
int
AffixMgr
:
:
process_pfx_order
(
)
{
PfxEntry
*
ptr
;
for
(
int
i
=
1
;
i
<
SETSIZE
;
i
+
+
)
{
ptr
=
pStart
[
i
]
;
for
(
;
ptr
!
=
NULL
;
ptr
=
ptr
-
>
getNext
(
)
)
{
PfxEntry
*
nptr
=
ptr
-
>
getNext
(
)
;
for
(
;
nptr
!
=
NULL
;
nptr
=
nptr
-
>
getNext
(
)
)
{
if
(
!
isSubset
(
ptr
-
>
getKey
(
)
nptr
-
>
getKey
(
)
)
)
break
;
}
ptr
-
>
setNextNE
(
nptr
)
;
ptr
-
>
setNextEQ
(
NULL
)
;
if
(
(
ptr
-
>
getNext
(
)
)
&
&
isSubset
(
ptr
-
>
getKey
(
)
(
ptr
-
>
getNext
(
)
)
-
>
getKey
(
)
)
)
ptr
-
>
setNextEQ
(
ptr
-
>
getNext
(
)
)
;
}
ptr
=
pStart
[
i
]
;
for
(
;
ptr
!
=
NULL
;
ptr
=
ptr
-
>
getNext
(
)
)
{
PfxEntry
*
nptr
=
ptr
-
>
getNext
(
)
;
PfxEntry
*
mptr
=
NULL
;
for
(
;
nptr
!
=
NULL
;
nptr
=
nptr
-
>
getNext
(
)
)
{
if
(
!
isSubset
(
ptr
-
>
getKey
(
)
nptr
-
>
getKey
(
)
)
)
break
;
mptr
=
nptr
;
}
if
(
mptr
)
mptr
-
>
setNextNE
(
NULL
)
;
}
}
return
0
;
}
int
AffixMgr
:
:
process_sfx_order
(
)
{
SfxEntry
*
ptr
;
for
(
int
i
=
1
;
i
<
SETSIZE
;
i
+
+
)
{
ptr
=
sStart
[
i
]
;
for
(
;
ptr
!
=
NULL
;
ptr
=
ptr
-
>
getNext
(
)
)
{
SfxEntry
*
nptr
=
ptr
-
>
getNext
(
)
;
for
(
;
nptr
!
=
NULL
;
nptr
=
nptr
-
>
getNext
(
)
)
{
if
(
!
isSubset
(
ptr
-
>
getKey
(
)
nptr
-
>
getKey
(
)
)
)
break
;
}
ptr
-
>
setNextNE
(
nptr
)
;
ptr
-
>
setNextEQ
(
NULL
)
;
if
(
(
ptr
-
>
getNext
(
)
)
&
&
isSubset
(
ptr
-
>
getKey
(
)
(
ptr
-
>
getNext
(
)
)
-
>
getKey
(
)
)
)
ptr
-
>
setNextEQ
(
ptr
-
>
getNext
(
)
)
;
}
ptr
=
sStart
[
i
]
;
for
(
;
ptr
!
=
NULL
;
ptr
=
ptr
-
>
getNext
(
)
)
{
SfxEntry
*
nptr
=
ptr
-
>
getNext
(
)
;
SfxEntry
*
mptr
=
NULL
;
for
(
;
nptr
!
=
NULL
;
nptr
=
nptr
-
>
getNext
(
)
)
{
if
(
!
isSubset
(
ptr
-
>
getKey
(
)
nptr
-
>
getKey
(
)
)
)
break
;
mptr
=
nptr
;
}
if
(
mptr
)
mptr
-
>
setNextNE
(
NULL
)
;
}
}
return
0
;
}
std
:
:
string
&
AffixMgr
:
:
debugflag
(
std
:
:
string
&
result
unsigned
short
flag
)
{
char
*
st
=
encode_flag
(
flag
)
;
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
MORPH_FLAG
)
;
if
(
st
)
{
result
.
append
(
st
)
;
free
(
st
)
;
}
return
result
;
}
int
AffixMgr
:
:
condlen
(
const
char
*
st
)
{
int
l
=
0
;
bool
group
=
false
;
for
(
;
*
st
;
st
+
+
)
{
if
(
*
st
=
=
'
[
'
)
{
group
=
true
;
l
+
+
;
}
else
if
(
*
st
=
=
'
]
'
)
group
=
false
;
else
if
(
!
group
&
&
(
!
utf8
|
|
(
!
(
*
st
&
0x80
)
|
|
(
(
*
st
&
0xc0
)
=
=
0x80
)
)
)
)
l
+
+
;
}
return
l
;
}
int
AffixMgr
:
:
encodeit
(
AffEntry
&
entry
const
char
*
cs
)
{
if
(
strcmp
(
cs
"
.
"
)
!
=
0
)
{
entry
.
numconds
=
(
char
)
condlen
(
cs
)
;
const
size_t
cslen
=
strlen
(
cs
)
;
const
size_t
short_part
=
std
:
:
min
<
size_t
>
(
MAXCONDLEN
cslen
)
;
memcpy
(
entry
.
c
.
conds
cs
short_part
)
;
if
(
short_part
<
MAXCONDLEN
)
{
memset
(
entry
.
c
.
conds
+
short_part
0
MAXCONDLEN
-
short_part
)
;
}
else
if
(
cs
[
MAXCONDLEN
]
)
{
entry
.
opts
+
=
aeLONGCOND
;
entry
.
c
.
l
.
conds2
=
mystrdup
(
cs
+
MAXCONDLEN_1
)
;
if
(
!
entry
.
c
.
l
.
conds2
)
return
1
;
}
}
else
{
entry
.
numconds
=
0
;
entry
.
c
.
conds
[
0
]
=
'
\
0
'
;
}
return
0
;
}
inline
int
AffixMgr
:
:
isSubset
(
const
char
*
s1
const
char
*
s2
)
{
while
(
(
(
*
s1
=
=
*
s2
)
|
|
(
*
s1
=
=
'
.
'
)
)
&
&
(
*
s1
!
=
'
\
0
'
)
)
{
s1
+
+
;
s2
+
+
;
}
return
(
*
s1
=
=
'
\
0
'
)
;
}
struct
hentry
*
AffixMgr
:
:
prefix_check
(
const
char
*
word
int
len
char
in_compound
const
FLAG
needflag
)
{
struct
hentry
*
rv
=
NULL
;
pfx
=
NULL
;
pfxappnd
=
NULL
;
sfxappnd
=
NULL
;
sfxextra
=
0
;
PfxEntry
*
pe
=
pStart
[
0
]
;
while
(
pe
)
{
if
(
(
(
in_compound
!
=
IN_CPD_NOT
)
|
|
!
(
pe
-
>
getCont
(
)
&
&
(
TESTAFF
(
pe
-
>
getCont
(
)
onlyincompound
pe
-
>
getContLen
(
)
)
)
)
)
&
&
(
(
in_compound
!
=
IN_CPD_END
)
|
|
(
pe
-
>
getCont
(
)
&
&
(
TESTAFF
(
pe
-
>
getCont
(
)
compoundpermitflag
pe
-
>
getContLen
(
)
)
)
)
)
)
{
rv
=
pe
-
>
checkword
(
word
len
in_compound
needflag
)
;
if
(
rv
)
{
pfx
=
pe
;
return
rv
;
}
}
pe
=
pe
-
>
getNext
(
)
;
}
unsigned
char
sp
=
*
(
(
const
unsigned
char
*
)
word
)
;
PfxEntry
*
pptr
=
pStart
[
sp
]
;
while
(
pptr
)
{
if
(
isSubset
(
pptr
-
>
getKey
(
)
word
)
)
{
if
(
(
(
in_compound
!
=
IN_CPD_NOT
)
|
|
!
(
pptr
-
>
getCont
(
)
&
&
(
TESTAFF
(
pptr
-
>
getCont
(
)
onlyincompound
pptr
-
>
getContLen
(
)
)
)
)
)
&
&
(
(
in_compound
!
=
IN_CPD_END
)
|
|
(
pptr
-
>
getCont
(
)
&
&
(
TESTAFF
(
pptr
-
>
getCont
(
)
compoundpermitflag
pptr
-
>
getContLen
(
)
)
)
)
)
)
{
rv
=
pptr
-
>
checkword
(
word
len
in_compound
needflag
)
;
if
(
rv
)
{
pfx
=
pptr
;
return
rv
;
}
}
pptr
=
pptr
-
>
getNextEQ
(
)
;
}
else
{
pptr
=
pptr
-
>
getNextNE
(
)
;
}
}
return
NULL
;
}
struct
hentry
*
AffixMgr
:
:
prefix_check_twosfx
(
const
char
*
word
int
len
char
in_compound
const
FLAG
needflag
)
{
struct
hentry
*
rv
=
NULL
;
pfx
=
NULL
;
sfxappnd
=
NULL
;
sfxextra
=
0
;
PfxEntry
*
pe
=
pStart
[
0
]
;
while
(
pe
)
{
rv
=
pe
-
>
check_twosfx
(
word
len
in_compound
needflag
)
;
if
(
rv
)
return
rv
;
pe
=
pe
-
>
getNext
(
)
;
}
unsigned
char
sp
=
*
(
(
const
unsigned
char
*
)
word
)
;
PfxEntry
*
pptr
=
pStart
[
sp
]
;
while
(
pptr
)
{
if
(
isSubset
(
pptr
-
>
getKey
(
)
word
)
)
{
rv
=
pptr
-
>
check_twosfx
(
word
len
in_compound
needflag
)
;
if
(
rv
)
{
pfx
=
pptr
;
return
rv
;
}
pptr
=
pptr
-
>
getNextEQ
(
)
;
}
else
{
pptr
=
pptr
-
>
getNextNE
(
)
;
}
}
return
NULL
;
}
std
:
:
string
AffixMgr
:
:
prefix_check_morph
(
const
char
*
word
int
len
char
in_compound
const
FLAG
needflag
)
{
std
:
:
string
result
;
pfx
=
NULL
;
sfxappnd
=
NULL
;
sfxextra
=
0
;
PfxEntry
*
pe
=
pStart
[
0
]
;
while
(
pe
)
{
std
:
:
string
st
=
pe
-
>
check_morph
(
word
len
in_compound
needflag
)
;
if
(
!
st
.
empty
(
)
)
{
result
.
append
(
st
)
;
}
pe
=
pe
-
>
getNext
(
)
;
}
unsigned
char
sp
=
*
(
(
const
unsigned
char
*
)
word
)
;
PfxEntry
*
pptr
=
pStart
[
sp
]
;
while
(
pptr
)
{
if
(
isSubset
(
pptr
-
>
getKey
(
)
word
)
)
{
std
:
:
string
st
=
pptr
-
>
check_morph
(
word
len
in_compound
needflag
)
;
if
(
!
st
.
empty
(
)
)
{
if
(
(
in_compound
!
=
IN_CPD_NOT
)
|
|
!
(
(
pptr
-
>
getCont
(
)
&
&
(
TESTAFF
(
pptr
-
>
getCont
(
)
onlyincompound
pptr
-
>
getContLen
(
)
)
)
)
)
)
{
result
.
append
(
st
)
;
pfx
=
pptr
;
}
}
pptr
=
pptr
-
>
getNextEQ
(
)
;
}
else
{
pptr
=
pptr
-
>
getNextNE
(
)
;
}
}
return
result
;
}
std
:
:
string
AffixMgr
:
:
prefix_check_twosfx_morph
(
const
char
*
word
int
len
char
in_compound
const
FLAG
needflag
)
{
std
:
:
string
result
;
pfx
=
NULL
;
sfxappnd
=
NULL
;
sfxextra
=
0
;
PfxEntry
*
pe
=
pStart
[
0
]
;
while
(
pe
)
{
std
:
:
string
st
=
pe
-
>
check_twosfx_morph
(
word
len
in_compound
needflag
)
;
if
(
!
st
.
empty
(
)
)
{
result
.
append
(
st
)
;
}
pe
=
pe
-
>
getNext
(
)
;
}
unsigned
char
sp
=
*
(
(
const
unsigned
char
*
)
word
)
;
PfxEntry
*
pptr
=
pStart
[
sp
]
;
while
(
pptr
)
{
if
(
isSubset
(
pptr
-
>
getKey
(
)
word
)
)
{
std
:
:
string
st
=
pptr
-
>
check_twosfx_morph
(
word
len
in_compound
needflag
)
;
if
(
!
st
.
empty
(
)
)
{
result
.
append
(
st
)
;
pfx
=
pptr
;
}
pptr
=
pptr
-
>
getNextEQ
(
)
;
}
else
{
pptr
=
pptr
-
>
getNextNE
(
)
;
}
}
return
result
;
}
int
AffixMgr
:
:
cpdrep_check
(
const
char
*
word
int
wl
)
{
if
(
(
wl
<
2
)
|
|
get_reptable
(
)
.
empty
(
)
)
return
0
;
for
(
size_t
i
=
0
;
i
<
get_reptable
(
)
.
size
(
)
;
+
+
i
)
{
if
(
!
get_reptable
(
)
[
i
]
.
outstrings
[
0
]
.
empty
(
)
)
{
const
char
*
r
=
word
;
const
size_t
lenp
=
get_reptable
(
)
[
i
]
.
pattern
.
size
(
)
;
while
(
(
r
=
strstr
(
r
get_reptable
(
)
[
i
]
.
pattern
.
c_str
(
)
)
)
!
=
NULL
)
{
std
:
:
string
candidate
(
word
)
;
candidate
.
replace
(
r
-
word
lenp
get_reptable
(
)
[
i
]
.
outstrings
[
0
]
)
;
if
(
candidate_check
(
candidate
.
c_str
(
)
candidate
.
size
(
)
)
)
return
1
;
+
+
r
;
}
}
}
return
0
;
}
int
AffixMgr
:
:
cpdwordpair_check
(
const
char
*
word
int
wl
)
{
if
(
wl
>
2
)
{
std
:
:
string
candidate
(
word
)
;
for
(
size_t
i
=
1
;
i
<
candidate
.
size
(
)
;
i
+
+
)
{
if
(
utf8
&
&
(
(
word
[
i
]
&
0xc0
)
=
=
0x80
)
)
continue
;
candidate
.
insert
(
i
1
'
'
)
;
if
(
candidate_check
(
candidate
.
c_str
(
)
candidate
.
size
(
)
)
)
return
1
;
candidate
.
erase
(
i
1
)
;
}
}
return
0
;
}
int
AffixMgr
:
:
cpdpat_check
(
const
char
*
word
int
pos
hentry
*
r1
hentry
*
r2
const
char
)
{
for
(
size_t
i
=
0
;
i
<
checkcpdtable
.
size
(
)
;
+
+
i
)
{
size_t
len
;
if
(
isSubset
(
checkcpdtable
[
i
]
.
pattern2
.
c_str
(
)
word
+
pos
)
&
&
(
!
r1
|
|
!
checkcpdtable
[
i
]
.
cond
|
|
(
r1
-
>
astr
&
&
TESTAFF
(
r1
-
>
astr
checkcpdtable
[
i
]
.
cond
r1
-
>
alen
)
)
)
&
&
(
!
r2
|
|
!
checkcpdtable
[
i
]
.
cond2
|
|
(
r2
-
>
astr
&
&
TESTAFF
(
r2
-
>
astr
checkcpdtable
[
i
]
.
cond2
r2
-
>
alen
)
)
)
&
&
(
checkcpdtable
[
i
]
.
pattern
.
empty
(
)
|
|
(
(
checkcpdtable
[
i
]
.
pattern
[
0
]
=
=
'
0
'
&
&
r1
-
>
blen
<
=
pos
&
&
strncmp
(
word
+
pos
-
r1
-
>
blen
r1
-
>
word
r1
-
>
blen
)
=
=
0
)
|
|
(
checkcpdtable
[
i
]
.
pattern
[
0
]
!
=
'
0
'
&
&
(
(
len
=
checkcpdtable
[
i
]
.
pattern
.
size
(
)
)
!
=
0
)
&
&
strncmp
(
word
+
pos
-
len
checkcpdtable
[
i
]
.
pattern
.
c_str
(
)
len
)
=
=
0
)
)
)
)
{
return
1
;
}
}
return
0
;
}
int
AffixMgr
:
:
cpdcase_check
(
const
char
*
word
int
pos
)
{
if
(
utf8
)
{
const
char
*
p
;
for
(
p
=
word
+
pos
-
1
;
(
*
p
&
0xc0
)
=
=
0x80
;
p
-
-
)
;
std
:
:
string
pair
(
p
)
;
std
:
:
vector
<
w_char
>
pair_u
;
u8_u16
(
pair_u
pair
)
;
unsigned
short
a
=
pair_u
.
size
(
)
>
1
?
(
(
pair_u
[
1
]
.
h
<
<
8
)
+
pair_u
[
1
]
.
l
)
:
0
;
unsigned
short
b
=
!
pair_u
.
empty
(
)
?
(
(
pair_u
[
0
]
.
h
<
<
8
)
+
pair_u
[
0
]
.
l
)
:
0
;
if
(
(
(
unicodetoupper
(
a
langnum
)
=
=
a
)
|
|
(
unicodetoupper
(
b
langnum
)
=
=
b
)
)
&
&
(
a
!
=
'
-
'
)
&
&
(
b
!
=
'
-
'
)
)
return
1
;
}
else
{
unsigned
char
a
=
*
(
word
+
pos
-
1
)
;
unsigned
char
b
=
*
(
word
+
pos
)
;
if
(
(
csconv
[
a
]
.
ccase
|
|
csconv
[
b
]
.
ccase
)
&
&
(
a
!
=
'
-
'
)
&
&
(
b
!
=
'
-
'
)
)
return
1
;
}
return
0
;
}
struct
metachar_data
{
signed
short
btpp
;
signed
short
btwp
;
int
btnum
;
}
;
int
AffixMgr
:
:
defcpd_check
(
hentry
*
*
*
words
short
wnum
hentry
*
rv
hentry
*
*
def
char
all
)
{
int
w
=
0
;
if
(
!
*
words
)
{
w
=
1
;
*
words
=
def
;
}
if
(
!
*
words
)
{
return
0
;
}
std
:
:
vector
<
metachar_data
>
btinfo
(
1
)
;
short
bt
=
0
;
(
*
words
)
[
wnum
]
=
rv
;
if
(
rv
-
>
alen
=
=
0
)
{
(
*
words
)
[
wnum
]
=
NULL
;
if
(
w
)
*
words
=
NULL
;
return
0
;
}
int
ok
=
0
;
for
(
size_t
i
=
0
;
i
<
defcpdtable
.
size
(
)
;
+
+
i
)
{
for
(
size_t
j
=
0
;
j
<
defcpdtable
[
i
]
.
size
(
)
;
+
+
j
)
{
if
(
defcpdtable
[
i
]
[
j
]
!
=
'
*
'
&
&
defcpdtable
[
i
]
[
j
]
!
=
'
?
'
&
&
TESTAFF
(
rv
-
>
astr
defcpdtable
[
i
]
[
j
]
rv
-
>
alen
)
)
{
ok
=
1
;
break
;
}
}
}
if
(
ok
=
=
0
)
{
(
*
words
)
[
wnum
]
=
NULL
;
if
(
w
)
*
words
=
NULL
;
return
0
;
}
for
(
size_t
i
=
0
;
i
<
defcpdtable
.
size
(
)
;
+
+
i
)
{
size_t
pp
=
0
;
signed
short
wp
=
0
;
int
ok2
;
ok
=
1
;
ok2
=
1
;
do
{
while
(
(
pp
<
defcpdtable
[
i
]
.
size
(
)
)
&
&
(
wp
<
=
wnum
)
)
{
if
(
(
(
pp
+
1
)
<
defcpdtable
[
i
]
.
size
(
)
)
&
&
(
(
defcpdtable
[
i
]
[
pp
+
1
]
=
=
'
*
'
)
|
|
(
defcpdtable
[
i
]
[
pp
+
1
]
=
=
'
?
'
)
)
)
{
int
wend
=
(
defcpdtable
[
i
]
[
pp
+
1
]
=
=
'
?
'
)
?
wp
:
wnum
;
ok2
=
1
;
pp
+
=
2
;
btinfo
[
bt
]
.
btpp
=
pp
;
btinfo
[
bt
]
.
btwp
=
wp
;
while
(
wp
<
=
wend
)
{
if
(
!
(
*
words
)
[
wp
]
-
>
alen
|
|
!
TESTAFF
(
(
*
words
)
[
wp
]
-
>
astr
defcpdtable
[
i
]
[
pp
-
2
]
(
*
words
)
[
wp
]
-
>
alen
)
)
{
ok2
=
0
;
break
;
}
wp
+
+
;
}
if
(
wp
<
=
wnum
)
ok2
=
0
;
btinfo
[
bt
]
.
btnum
=
wp
-
btinfo
[
bt
]
.
btwp
;
if
(
btinfo
[
bt
]
.
btnum
>
0
)
{
+
+
bt
;
btinfo
.
resize
(
bt
+
1
)
;
}
if
(
ok2
)
break
;
}
else
{
ok2
=
1
;
if
(
!
(
*
words
)
[
wp
]
|
|
!
(
*
words
)
[
wp
]
-
>
alen
|
|
!
TESTAFF
(
(
*
words
)
[
wp
]
-
>
astr
defcpdtable
[
i
]
[
pp
]
(
*
words
)
[
wp
]
-
>
alen
)
)
{
ok
=
0
;
break
;
}
pp
+
+
;
wp
+
+
;
if
(
(
defcpdtable
[
i
]
.
size
(
)
=
=
pp
)
&
&
!
(
wp
>
wnum
)
)
ok
=
0
;
}
}
if
(
ok
&
&
ok2
)
{
size_t
r
=
pp
;
while
(
(
defcpdtable
[
i
]
.
size
(
)
>
r
)
&
&
(
(
r
+
1
)
<
defcpdtable
[
i
]
.
size
(
)
)
&
&
(
(
defcpdtable
[
i
]
[
r
+
1
]
=
=
'
*
'
)
|
|
(
defcpdtable
[
i
]
[
r
+
1
]
=
=
'
?
'
)
)
)
r
+
=
2
;
if
(
defcpdtable
[
i
]
.
size
(
)
<
=
r
)
return
1
;
}
if
(
bt
)
do
{
ok
=
1
;
btinfo
[
bt
-
1
]
.
btnum
-
-
;
pp
=
btinfo
[
bt
-
1
]
.
btpp
;
wp
=
btinfo
[
bt
-
1
]
.
btwp
+
(
signed
short
)
btinfo
[
bt
-
1
]
.
btnum
;
}
while
(
(
btinfo
[
bt
-
1
]
.
btnum
<
0
)
&
&
-
-
bt
)
;
}
while
(
bt
)
;
if
(
ok
&
&
ok2
&
&
(
!
all
|
|
(
defcpdtable
[
i
]
.
size
(
)
<
=
pp
)
)
)
return
1
;
while
(
ok
&
&
ok2
&
&
(
defcpdtable
[
i
]
.
size
(
)
>
pp
)
&
&
(
(
pp
+
1
)
<
defcpdtable
[
i
]
.
size
(
)
)
&
&
(
(
defcpdtable
[
i
]
[
pp
+
1
]
=
=
'
*
'
)
|
|
(
defcpdtable
[
i
]
[
pp
+
1
]
=
=
'
?
'
)
)
)
pp
+
=
2
;
if
(
ok
&
&
ok2
&
&
(
defcpdtable
[
i
]
.
size
(
)
<
=
pp
)
)
return
1
;
}
(
*
words
)
[
wnum
]
=
NULL
;
if
(
w
)
*
words
=
NULL
;
return
0
;
}
inline
int
AffixMgr
:
:
candidate_check
(
const
char
*
word
int
len
)
{
struct
hentry
*
rv
=
lookup
(
word
)
;
if
(
rv
)
return
1
;
rv
=
affix_check
(
word
len
)
;
if
(
rv
)
return
1
;
return
0
;
}
short
AffixMgr
:
:
get_syllable
(
const
std
:
:
string
&
word
)
{
if
(
cpdmaxsyllable
=
=
0
)
return
0
;
short
num
=
0
;
if
(
!
utf8
)
{
for
(
size_t
i
=
0
;
i
<
word
.
size
(
)
;
+
+
i
)
{
if
(
std
:
:
binary_search
(
cpdvowels
.
begin
(
)
cpdvowels
.
end
(
)
word
[
i
]
)
)
{
+
+
num
;
}
}
}
else
if
(
!
cpdvowels_utf16
.
empty
(
)
)
{
std
:
:
vector
<
w_char
>
w
;
u8_u16
(
w
word
)
;
for
(
size_t
i
=
0
;
i
<
w
.
size
(
)
;
+
+
i
)
{
if
(
std
:
:
binary_search
(
cpdvowels_utf16
.
begin
(
)
cpdvowels_utf16
.
end
(
)
w
[
i
]
)
)
{
+
+
num
;
}
}
}
return
num
;
}
void
AffixMgr
:
:
setcminmax
(
int
*
cmin
int
*
cmax
const
char
*
word
int
len
)
{
if
(
utf8
)
{
int
i
;
for
(
*
cmin
=
0
i
=
0
;
(
i
<
cpdmin
)
&
&
*
cmin
<
len
;
i
+
+
)
{
for
(
(
*
cmin
)
+
+
;
*
cmin
<
len
&
&
(
word
[
*
cmin
]
&
0xc0
)
=
=
0x80
;
(
*
cmin
)
+
+
)
;
}
for
(
*
cmax
=
len
i
=
0
;
(
i
<
(
cpdmin
-
1
)
)
&
&
*
cmax
>
=
0
;
i
+
+
)
{
for
(
(
*
cmax
)
-
-
;
*
cmax
>
=
0
&
&
(
word
[
*
cmax
]
&
0xc0
)
=
=
0x80
;
(
*
cmax
)
-
-
)
;
}
}
else
{
*
cmin
=
cpdmin
;
*
cmax
=
len
-
cpdmin
+
1
;
}
}
struct
hentry
*
AffixMgr
:
:
compound_check
(
const
std
:
:
string
&
word
short
wordnum
short
numsyllable
short
maxwordnum
short
wnum
hentry
*
*
words
=
NULL
hentry
*
*
rwords
=
NULL
char
hu_mov_rule
=
0
char
is_sug
=
0
int
*
info
=
NULL
)
{
int
i
;
short
oldnumsyllable
oldnumsyllable2
oldwordnum
oldwordnum2
;
struct
hentry
*
rv
=
NULL
;
struct
hentry
*
rv_first
;
std
:
:
string
st
;
char
ch
=
'
\
0
'
;
int
cmin
;
int
cmax
;
int
striple
=
0
;
size_t
scpd
=
0
;
int
soldi
=
0
;
int
oldcmin
=
0
;
int
oldcmax
=
0
;
int
oldlen
=
0
;
int
checkedstriple
=
0
;
char
affixed
=
0
;
hentry
*
*
oldwords
=
words
;
size_t
len
=
word
.
size
(
)
;
int
checked_prefix
;
HUNSPELL_THREAD_LOCAL
clock_t
timelimit
;
if
(
wordnum
=
=
0
)
timelimit
=
clock
(
)
;
else
if
(
timelimit
!
=
0
&
&
(
clock
(
)
>
timelimit
+
TIMELIMIT
)
)
{
timelimit
=
0
;
}
setcminmax
(
&
cmin
&
cmax
word
.
c_str
(
)
len
)
;
st
.
assign
(
word
)
;
for
(
i
=
cmin
;
i
<
cmax
;
i
+
+
)
{
if
(
utf8
)
{
for
(
;
(
st
[
i
]
&
0xc0
)
=
=
0x80
;
i
+
+
)
;
if
(
i
>
=
cmax
)
return
NULL
;
}
words
=
oldwords
;
int
onlycpdrule
=
(
words
)
?
1
:
0
;
do
{
oldnumsyllable
=
numsyllable
;
oldwordnum
=
wordnum
;
checked_prefix
=
0
;
do
{
if
(
timelimit
=
=
0
)
return
0
;
if
(
scpd
>
0
)
{
for
(
;
scpd
<
=
checkcpdtable
.
size
(
)
&
&
(
checkcpdtable
[
scpd
-
1
]
.
pattern3
.
empty
(
)
|
|
strncmp
(
word
.
c_str
(
)
+
i
checkcpdtable
[
scpd
-
1
]
.
pattern3
.
c_str
(
)
checkcpdtable
[
scpd
-
1
]
.
pattern3
.
size
(
)
)
!
=
0
)
;
scpd
+
+
)
;
if
(
scpd
>
checkcpdtable
.
size
(
)
)
break
;
st
.
replace
(
i
std
:
:
string
:
:
npos
checkcpdtable
[
scpd
-
1
]
.
pattern
)
;
soldi
=
i
;
i
+
=
checkcpdtable
[
scpd
-
1
]
.
pattern
.
size
(
)
;
st
.
replace
(
i
std
:
:
string
:
:
npos
checkcpdtable
[
scpd
-
1
]
.
pattern2
)
;
st
.
replace
(
i
+
checkcpdtable
[
scpd
-
1
]
.
pattern2
.
size
(
)
std
:
:
string
:
:
npos
word
.
substr
(
soldi
+
checkcpdtable
[
scpd
-
1
]
.
pattern3
.
size
(
)
)
)
;
oldlen
=
len
;
len
+
=
checkcpdtable
[
scpd
-
1
]
.
pattern
.
size
(
)
+
checkcpdtable
[
scpd
-
1
]
.
pattern2
.
size
(
)
-
checkcpdtable
[
scpd
-
1
]
.
pattern3
.
size
(
)
;
oldcmin
=
cmin
;
oldcmax
=
cmax
;
setcminmax
(
&
cmin
&
cmax
st
.
c_str
(
)
len
)
;
cmax
=
len
-
cpdmin
+
1
;
}
ch
=
st
[
i
]
;
st
[
i
]
=
'
\
0
'
;
sfx
=
NULL
;
pfx
=
NULL
;
affixed
=
1
;
rv
=
lookup
(
st
.
c_str
(
)
)
;
if
(
(
rv
)
&
&
compoundforbidflag
&
&
TESTAFF
(
rv
-
>
astr
compoundforbidflag
rv
-
>
alen
)
&
&
!
hu_mov_rule
)
continue
;
while
(
(
rv
)
&
&
!
hu_mov_rule
&
&
(
(
needaffix
&
&
TESTAFF
(
rv
-
>
astr
needaffix
rv
-
>
alen
)
)
|
|
!
(
(
compoundflag
&
&
!
words
&
&
!
onlycpdrule
&
&
TESTAFF
(
rv
-
>
astr
compoundflag
rv
-
>
alen
)
)
|
|
(
compoundbegin
&
&
!
wordnum
&
&
!
onlycpdrule
&
&
TESTAFF
(
rv
-
>
astr
compoundbegin
rv
-
>
alen
)
)
|
|
(
compoundmiddle
&
&
wordnum
&
&
!
words
&
&
!
onlycpdrule
&
&
TESTAFF
(
rv
-
>
astr
compoundmiddle
rv
-
>
alen
)
)
|
|
(
!
defcpdtable
.
empty
(
)
&
&
onlycpdrule
&
&
(
(
!
words
&
&
!
wordnum
&
&
defcpd_check
(
&
words
wnum
rv
rwords
0
)
)
|
|
(
words
&
&
defcpd_check
(
&
words
wnum
rv
rwords
0
)
)
)
)
)
|
|
(
scpd
!
=
0
&
&
checkcpdtable
[
scpd
-
1
]
.
cond
!
=
FLAG_NULL
&
&
!
TESTAFF
(
rv
-
>
astr
checkcpdtable
[
scpd
-
1
]
.
cond
rv
-
>
alen
)
)
)
)
{
rv
=
rv
-
>
next_homonym
;
}
if
(
rv
)
affixed
=
0
;
if
(
!
rv
)
{
if
(
onlycpdrule
)
break
;
if
(
compoundflag
&
&
!
(
rv
=
prefix_check
(
st
.
c_str
(
)
i
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
compoundflag
)
)
)
{
if
(
(
(
rv
=
suffix_check
(
st
.
c_str
(
)
i
0
NULL
FLAG_NULL
compoundflag
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
)
)
|
|
(
compoundmoresuffixes
&
&
(
rv
=
suffix_check_twosfx
(
st
.
c_str
(
)
i
0
NULL
compoundflag
)
)
)
)
&
&
!
hu_mov_rule
&
&
sfx
-
>
getCont
(
)
&
&
(
(
compoundforbidflag
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundforbidflag
sfx
-
>
getContLen
(
)
)
)
|
|
(
compoundend
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundend
sfx
-
>
getContLen
(
)
)
)
)
)
{
rv
=
NULL
;
}
}
if
(
rv
|
|
(
(
(
wordnum
=
=
0
)
&
&
compoundbegin
&
&
(
(
rv
=
suffix_check
(
st
.
c_str
(
)
i
0
NULL
FLAG_NULL
compoundbegin
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
)
)
|
|
(
compoundmoresuffixes
&
&
(
rv
=
suffix_check_twosfx
(
st
.
c_str
(
)
i
0
NULL
compoundbegin
)
)
)
|
|
(
rv
=
prefix_check
(
st
.
c_str
(
)
i
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
compoundbegin
)
)
)
)
|
|
(
(
wordnum
>
0
)
&
&
compoundmiddle
&
&
(
(
rv
=
suffix_check
(
st
.
c_str
(
)
i
0
NULL
FLAG_NULL
compoundmiddle
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
)
)
|
|
(
compoundmoresuffixes
&
&
(
rv
=
suffix_check_twosfx
(
st
.
c_str
(
)
i
0
NULL
compoundmiddle
)
)
)
|
|
(
rv
=
prefix_check
(
st
.
c_str
(
)
i
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
compoundmiddle
)
)
)
)
)
)
checked_prefix
=
1
;
}
else
if
(
rv
-
>
astr
&
&
(
TESTAFF
(
rv
-
>
astr
forbiddenword
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
needaffix
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
ONLYUPCASEFLAG
rv
-
>
alen
)
|
|
(
is_sug
&
&
nosuggest
&
&
TESTAFF
(
rv
-
>
astr
nosuggest
rv
-
>
alen
)
)
)
)
{
st
[
i
]
=
ch
;
break
;
}
if
(
(
rv
)
&
&
!
hu_mov_rule
&
&
(
(
pfx
&
&
pfx
-
>
getCont
(
)
&
&
TESTAFF
(
pfx
-
>
getCont
(
)
compoundforbidflag
pfx
-
>
getContLen
(
)
)
)
|
|
(
sfx
&
&
sfx
-
>
getCont
(
)
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundforbidflag
sfx
-
>
getContLen
(
)
)
)
)
)
{
rv
=
NULL
;
}
if
(
(
rv
)
&
&
!
checked_prefix
&
&
compoundend
&
&
!
hu_mov_rule
&
&
(
(
pfx
&
&
pfx
-
>
getCont
(
)
&
&
TESTAFF
(
pfx
-
>
getCont
(
)
compoundend
pfx
-
>
getContLen
(
)
)
)
|
|
(
sfx
&
&
sfx
-
>
getCont
(
)
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundend
sfx
-
>
getContLen
(
)
)
)
)
)
{
rv
=
NULL
;
}
if
(
(
rv
)
&
&
!
checked_prefix
&
&
(
wordnum
=
=
0
)
&
&
compoundmiddle
&
&
!
hu_mov_rule
&
&
(
(
pfx
&
&
pfx
-
>
getCont
(
)
&
&
TESTAFF
(
pfx
-
>
getCont
(
)
compoundmiddle
pfx
-
>
getContLen
(
)
)
)
|
|
(
sfx
&
&
sfx
-
>
getCont
(
)
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundmiddle
sfx
-
>
getContLen
(
)
)
)
)
)
{
rv
=
NULL
;
}
if
(
(
rv
)
&
&
(
rv
-
>
astr
)
&
&
(
TESTAFF
(
rv
-
>
astr
forbiddenword
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
ONLYUPCASEFLAG
rv
-
>
alen
)
|
|
(
is_sug
&
&
nosuggest
&
&
TESTAFF
(
rv
-
>
astr
nosuggest
rv
-
>
alen
)
)
)
)
{
return
NULL
;
}
if
(
(
rv
)
&
&
compoundroot
&
&
(
TESTAFF
(
rv
-
>
astr
compoundroot
rv
-
>
alen
)
)
)
{
wordnum
+
+
;
}
if
(
(
(
rv
)
&
&
(
checked_prefix
|
|
(
words
&
&
words
[
wnum
]
)
|
|
(
compoundflag
&
&
TESTAFF
(
rv
-
>
astr
compoundflag
rv
-
>
alen
)
)
|
|
(
(
oldwordnum
=
=
0
)
&
&
compoundbegin
&
&
TESTAFF
(
rv
-
>
astr
compoundbegin
rv
-
>
alen
)
)
|
|
(
(
oldwordnum
>
0
)
&
&
compoundmiddle
&
&
TESTAFF
(
rv
-
>
astr
compoundmiddle
rv
-
>
alen
)
)
|
|
(
(
langnum
=
=
LANG_hu
)
&
&
hu_mov_rule
&
&
(
TESTAFF
(
rv
-
>
astr
'
F
'
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
'
G
'
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
'
H
'
rv
-
>
alen
)
)
)
)
&
&
(
scpd
=
=
0
|
|
checkcpdtable
[
scpd
-
1
]
.
cond
=
=
FLAG_NULL
|
|
TESTAFF
(
rv
-
>
astr
checkcpdtable
[
scpd
-
1
]
.
cond
rv
-
>
alen
)
)
&
&
!
(
(
checkcompoundtriple
&
&
scpd
=
=
0
&
&
!
words
&
&
(
word
[
i
-
1
]
=
=
word
[
i
]
)
&
&
(
(
(
i
>
1
)
&
&
(
word
[
i
-
1
]
=
=
word
[
i
-
2
]
)
)
|
|
(
(
word
[
i
-
1
]
=
=
word
[
i
+
1
]
)
)
)
)
|
|
(
checkcompoundcase
&
&
scpd
=
=
0
&
&
!
words
&
&
cpdcase_check
(
word
.
c_str
(
)
i
)
)
)
)
|
|
(
(
!
rv
)
&
&
(
langnum
=
=
LANG_hu
)
&
&
hu_mov_rule
&
&
(
rv
=
affix_check
(
st
.
c_str
(
)
i
)
)
&
&
(
sfx
&
&
sfx
-
>
getCont
(
)
&
&
(
TESTAFF
(
sfx
-
>
getCont
(
)
(
unsigned
short
)
'
x
'
sfx
-
>
getContLen
(
)
)
|
|
TESTAFF
(
sfx
-
>
getCont
(
)
(
unsigned
short
)
'
%
'
sfx
-
>
getContLen
(
)
)
)
)
)
)
{
if
(
langnum
=
=
LANG_hu
)
{
numsyllable
+
=
get_syllable
(
st
.
substr
(
0
i
)
)
;
if
(
pfx
&
&
(
get_syllable
(
pfx
-
>
getKey
(
)
)
>
1
)
)
wordnum
+
+
;
}
rv_first
=
rv
;
st
[
i
]
=
ch
;
do
{
if
(
simplifiedtriple
)
{
if
(
striple
)
{
checkedstriple
=
1
;
i
-
-
;
}
else
if
(
i
>
2
&
&
word
[
i
-
1
]
=
=
word
[
i
-
2
]
)
striple
=
1
;
}
rv
=
lookup
(
st
.
c_str
(
)
+
i
)
;
while
(
(
rv
)
&
&
(
(
needaffix
&
&
TESTAFF
(
rv
-
>
astr
needaffix
rv
-
>
alen
)
)
|
|
!
(
(
compoundflag
&
&
!
words
&
&
TESTAFF
(
rv
-
>
astr
compoundflag
rv
-
>
alen
)
)
|
|
(
compoundend
&
&
!
words
&
&
TESTAFF
(
rv
-
>
astr
compoundend
rv
-
>
alen
)
)
|
|
(
!
defcpdtable
.
empty
(
)
&
&
words
&
&
defcpd_check
(
&
words
wnum
+
1
rv
NULL
1
)
)
)
|
|
(
scpd
!
=
0
&
&
checkcpdtable
[
scpd
-
1
]
.
cond2
!
=
FLAG_NULL
&
&
!
TESTAFF
(
rv
-
>
astr
checkcpdtable
[
scpd
-
1
]
.
cond2
rv
-
>
alen
)
)
)
)
{
rv
=
rv
-
>
next_homonym
;
}
if
(
rv
&
&
forceucase
&
&
(
rv
)
&
&
(
TESTAFF
(
rv
-
>
astr
forceucase
rv
-
>
alen
)
)
&
&
!
(
info
&
&
*
info
&
SPELL_ORIGCAP
)
)
rv
=
NULL
;
if
(
rv
&
&
words
&
&
words
[
wnum
+
1
]
)
return
rv_first
;
oldnumsyllable2
=
numsyllable
;
oldwordnum2
=
wordnum
;
if
(
(
rv
)
&
&
(
langnum
=
=
LANG_hu
)
&
&
(
TESTAFF
(
rv
-
>
astr
'
I
'
rv
-
>
alen
)
)
&
&
!
(
TESTAFF
(
rv
-
>
astr
'
J
'
rv
-
>
alen
)
)
)
{
numsyllable
-
-
;
}
if
(
(
rv
)
&
&
(
compoundroot
)
&
&
(
TESTAFF
(
rv
-
>
astr
compoundroot
rv
-
>
alen
)
)
)
{
wordnum
+
+
;
}
if
(
(
rv
)
&
&
(
rv
-
>
astr
)
&
&
(
TESTAFF
(
rv
-
>
astr
forbiddenword
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
ONLYUPCASEFLAG
rv
-
>
alen
)
|
|
(
is_sug
&
&
nosuggest
&
&
TESTAFF
(
rv
-
>
astr
nosuggest
rv
-
>
alen
)
)
)
)
return
NULL
;
if
(
(
rv
)
&
&
(
(
compoundflag
&
&
TESTAFF
(
rv
-
>
astr
compoundflag
rv
-
>
alen
)
)
|
|
(
compoundend
&
&
TESTAFF
(
rv
-
>
astr
compoundend
rv
-
>
alen
)
)
)
&
&
(
(
(
cpdwordmax
=
=
-
1
)
|
|
(
wordnum
+
1
<
cpdwordmax
)
)
|
|
(
(
cpdmaxsyllable
!
=
0
)
&
&
(
numsyllable
+
get_syllable
(
std
:
:
string
(
HENTRY_WORD
(
rv
)
rv
-
>
blen
)
)
<
=
cpdmaxsyllable
)
)
)
&
&
(
checkcpdtable
.
empty
(
)
|
|
scpd
!
=
0
|
|
!
cpdpat_check
(
word
.
c_str
(
)
i
rv_first
rv
0
)
)
&
&
(
(
!
checkcompounddup
|
|
(
rv
!
=
rv_first
)
)
)
&
&
(
scpd
=
=
0
|
|
checkcpdtable
[
scpd
-
1
]
.
cond2
=
=
FLAG_NULL
|
|
TESTAFF
(
rv
-
>
astr
checkcpdtable
[
scpd
-
1
]
.
cond2
rv
-
>
alen
)
)
)
{
if
(
(
checkcompoundrep
&
&
cpdrep_check
(
word
.
c_str
(
)
len
)
)
|
|
cpdwordpair_check
(
word
.
c_str
(
)
len
)
)
return
NULL
;
return
rv_first
;
}
numsyllable
=
oldnumsyllable2
;
wordnum
=
oldwordnum2
;
sfx
=
NULL
;
sfxflag
=
FLAG_NULL
;
rv
=
(
compoundflag
&
&
!
onlycpdrule
)
?
affix_check
(
(
word
.
c_str
(
)
+
i
)
strlen
(
word
.
c_str
(
)
+
i
)
compoundflag
IN_CPD_END
)
:
NULL
;
if
(
!
rv
&
&
compoundend
&
&
!
onlycpdrule
)
{
sfx
=
NULL
;
pfx
=
NULL
;
rv
=
affix_check
(
(
word
.
c_str
(
)
+
i
)
strlen
(
word
.
c_str
(
)
+
i
)
compoundend
IN_CPD_END
)
;
}
if
(
!
rv
&
&
!
defcpdtable
.
empty
(
)
&
&
words
)
{
rv
=
affix_check
(
(
word
.
c_str
(
)
+
i
)
strlen
(
word
.
c_str
(
)
+
i
)
0
IN_CPD_END
)
;
if
(
rv
&
&
defcpd_check
(
&
words
wnum
+
1
rv
NULL
1
)
)
return
rv_first
;
rv
=
NULL
;
}
if
(
rv
&
&
!
(
scpd
=
=
0
|
|
checkcpdtable
[
scpd
-
1
]
.
cond2
=
=
FLAG_NULL
|
|
TESTAFF
(
rv
-
>
astr
checkcpdtable
[
scpd
-
1
]
.
cond2
rv
-
>
alen
)
)
)
rv
=
NULL
;
if
(
rv
&
&
!
checkcpdtable
.
empty
(
)
&
&
scpd
=
=
0
&
&
cpdpat_check
(
word
.
c_str
(
)
i
rv_first
rv
affixed
)
)
rv
=
NULL
;
if
(
(
rv
)
&
&
(
(
pfx
&
&
pfx
-
>
getCont
(
)
&
&
TESTAFF
(
pfx
-
>
getCont
(
)
compoundforbidflag
pfx
-
>
getContLen
(
)
)
)
|
|
(
sfx
&
&
sfx
-
>
getCont
(
)
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundforbidflag
sfx
-
>
getContLen
(
)
)
)
)
)
{
rv
=
NULL
;
}
if
(
rv
&
&
forceucase
&
&
(
rv
)
&
&
(
TESTAFF
(
rv
-
>
astr
forceucase
rv
-
>
alen
)
)
&
&
!
(
info
&
&
*
info
&
SPELL_ORIGCAP
)
)
rv
=
NULL
;
if
(
(
rv
)
&
&
(
rv
-
>
astr
)
&
&
(
TESTAFF
(
rv
-
>
astr
forbiddenword
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
ONLYUPCASEFLAG
rv
-
>
alen
)
|
|
(
is_sug
&
&
nosuggest
&
&
TESTAFF
(
rv
-
>
astr
nosuggest
rv
-
>
alen
)
)
)
)
return
NULL
;
if
(
langnum
=
=
LANG_hu
)
{
numsyllable
+
=
get_syllable
(
word
.
c_str
(
)
+
i
)
;
if
(
sfxappnd
)
{
std
:
:
string
tmp
(
sfxappnd
)
;
reverseword
(
tmp
)
;
numsyllable
-
=
short
(
get_syllable
(
tmp
)
+
sfxextra
)
;
}
else
{
numsyllable
-
=
short
(
sfxextra
)
;
}
if
(
pfx
&
&
(
get_syllable
(
pfx
-
>
getKey
(
)
)
>
1
)
)
wordnum
+
+
;
if
(
!
cpdsyllablenum
.
empty
(
)
)
{
switch
(
sfxflag
)
{
case
'
c
'
:
{
numsyllable
+
=
2
;
break
;
}
case
'
J
'
:
{
numsyllable
+
=
1
;
break
;
}
case
'
I
'
:
{
if
(
rv
&
&
TESTAFF
(
rv
-
>
astr
'
J
'
rv
-
>
alen
)
)
numsyllable
+
=
1
;
break
;
}
}
}
}
if
(
(
rv
)
&
&
(
compoundroot
)
&
&
(
TESTAFF
(
rv
-
>
astr
compoundroot
rv
-
>
alen
)
)
)
{
wordnum
+
+
;
}
if
(
(
rv
)
&
&
(
(
(
cpdwordmax
=
=
-
1
)
|
|
(
wordnum
+
1
<
cpdwordmax
)
)
|
|
(
(
cpdmaxsyllable
!
=
0
)
&
&
(
numsyllable
<
=
cpdmaxsyllable
)
)
)
&
&
(
(
!
checkcompounddup
|
|
(
rv
!
=
rv_first
)
)
)
)
{
if
(
(
checkcompoundrep
&
&
cpdrep_check
(
word
.
c_str
(
)
len
)
)
|
|
cpdwordpair_check
(
word
.
c_str
(
)
len
)
)
return
NULL
;
return
rv_first
;
}
numsyllable
=
oldnumsyllable2
;
wordnum
=
oldwordnum2
;
if
(
wordnum
+
2
<
maxwordnum
)
{
rv
=
compound_check
(
st
.
substr
(
i
)
wordnum
+
1
numsyllable
maxwordnum
wnum
+
1
words
rwords
0
is_sug
info
)
;
if
(
rv
&
&
!
checkcpdtable
.
empty
(
)
&
&
(
(
scpd
=
=
0
&
&
cpdpat_check
(
word
.
c_str
(
)
i
rv_first
rv
affixed
)
)
|
|
(
scpd
!
=
0
&
&
!
cpdpat_check
(
word
.
c_str
(
)
i
rv_first
rv
affixed
)
)
)
)
rv
=
NULL
;
}
else
{
rv
=
NULL
;
}
if
(
rv
)
{
if
(
cpdwordpair_check
(
word
.
c_str
(
)
len
)
)
return
NULL
;
if
(
checkcompoundrep
|
|
forbiddenword
)
{
if
(
checkcompoundrep
&
&
cpdrep_check
(
word
.
c_str
(
)
len
)
)
return
NULL
;
if
(
strncmp
(
rv
-
>
word
word
.
c_str
(
)
+
i
rv
-
>
blen
)
=
=
0
)
{
char
r
=
st
[
i
+
rv
-
>
blen
]
;
st
[
i
+
rv
-
>
blen
]
=
'
\
0
'
;
if
(
(
checkcompoundrep
&
&
cpdrep_check
(
st
.
c_str
(
)
i
+
rv
-
>
blen
)
)
|
|
cpdwordpair_check
(
st
.
c_str
(
)
i
+
rv
-
>
blen
)
)
{
st
[
+
i
+
rv
-
>
blen
]
=
r
;
continue
;
}
if
(
forbiddenword
)
{
struct
hentry
*
rv2
=
lookup
(
word
.
c_str
(
)
)
;
if
(
!
rv2
)
rv2
=
affix_check
(
word
.
c_str
(
)
len
)
;
if
(
rv2
&
&
rv2
-
>
astr
&
&
TESTAFF
(
rv2
-
>
astr
forbiddenword
rv2
-
>
alen
)
&
&
(
strncmp
(
rv2
-
>
word
st
.
c_str
(
)
i
+
rv
-
>
blen
)
=
=
0
)
)
{
return
NULL
;
}
}
st
[
i
+
rv
-
>
blen
]
=
r
;
}
}
return
rv_first
;
}
}
while
(
striple
&
&
!
checkedstriple
)
;
if
(
checkedstriple
)
{
i
+
+
;
checkedstriple
=
0
;
striple
=
0
;
}
}
if
(
soldi
!
=
0
)
{
i
=
soldi
;
soldi
=
0
;
len
=
oldlen
;
cmin
=
oldcmin
;
cmax
=
oldcmax
;
}
scpd
+
+
;
}
while
(
!
onlycpdrule
&
&
simplifiedcpd
&
&
scpd
<
=
checkcpdtable
.
size
(
)
)
;
scpd
=
0
;
wordnum
=
oldwordnum
;
numsyllable
=
oldnumsyllable
;
if
(
soldi
!
=
0
)
{
i
=
soldi
;
st
.
assign
(
word
)
;
soldi
=
0
;
}
else
st
[
i
]
=
ch
;
}
while
(
!
defcpdtable
.
empty
(
)
&
&
oldwordnum
=
=
0
&
&
onlycpdrule
+
+
<
1
)
;
}
return
NULL
;
}
int
AffixMgr
:
:
compound_check_morph
(
const
char
*
word
int
len
short
wordnum
short
numsyllable
short
maxwordnum
short
wnum
hentry
*
*
words
hentry
*
*
rwords
char
hu_mov_rule
std
:
:
string
&
result
const
std
:
:
string
*
partresult
)
{
int
i
;
short
oldnumsyllable
oldnumsyllable2
oldwordnum
oldwordnum2
;
int
ok
=
0
;
struct
hentry
*
rv
=
NULL
;
struct
hentry
*
rv_first
;
std
:
:
string
st
;
char
ch
;
int
checked_prefix
;
std
:
:
string
presult
;
int
cmin
;
int
cmax
;
char
affixed
=
0
;
hentry
*
*
oldwords
=
words
;
HUNSPELL_THREAD_LOCAL
clock_t
timelimit
;
if
(
wordnum
=
=
0
)
timelimit
=
clock
(
)
;
else
if
(
timelimit
!
=
0
&
&
(
clock
(
)
>
timelimit
+
TIMELIMIT
)
)
{
timelimit
=
0
;
}
setcminmax
(
&
cmin
&
cmax
word
len
)
;
st
.
assign
(
word
)
;
for
(
i
=
cmin
;
i
<
cmax
;
i
+
+
)
{
if
(
utf8
)
{
for
(
;
(
st
[
i
]
&
0xc0
)
=
=
0x80
;
i
+
+
)
;
if
(
i
>
=
cmax
)
return
0
;
}
words
=
oldwords
;
int
onlycpdrule
=
(
words
)
?
1
:
0
;
do
{
if
(
timelimit
=
=
0
)
return
0
;
oldnumsyllable
=
numsyllable
;
oldwordnum
=
wordnum
;
checked_prefix
=
0
;
ch
=
st
[
i
]
;
st
[
i
]
=
'
\
0
'
;
sfx
=
NULL
;
affixed
=
1
;
presult
.
clear
(
)
;
if
(
partresult
)
presult
.
append
(
*
partresult
)
;
rv
=
lookup
(
st
.
c_str
(
)
)
;
if
(
(
rv
)
&
&
compoundforbidflag
&
&
TESTAFF
(
rv
-
>
astr
compoundforbidflag
rv
-
>
alen
)
&
&
!
hu_mov_rule
)
continue
;
while
(
(
rv
)
&
&
!
hu_mov_rule
&
&
(
(
needaffix
&
&
TESTAFF
(
rv
-
>
astr
needaffix
rv
-
>
alen
)
)
|
|
!
(
(
compoundflag
&
&
!
words
&
&
!
onlycpdrule
&
&
TESTAFF
(
rv
-
>
astr
compoundflag
rv
-
>
alen
)
)
|
|
(
compoundbegin
&
&
!
wordnum
&
&
!
onlycpdrule
&
&
TESTAFF
(
rv
-
>
astr
compoundbegin
rv
-
>
alen
)
)
|
|
(
compoundmiddle
&
&
wordnum
&
&
!
words
&
&
!
onlycpdrule
&
&
TESTAFF
(
rv
-
>
astr
compoundmiddle
rv
-
>
alen
)
)
|
|
(
!
defcpdtable
.
empty
(
)
&
&
onlycpdrule
&
&
(
(
!
words
&
&
!
wordnum
&
&
defcpd_check
(
&
words
wnum
rv
rwords
0
)
)
|
|
(
words
&
&
defcpd_check
(
&
words
wnum
rv
rwords
0
)
)
)
)
)
)
)
{
rv
=
rv
-
>
next_homonym
;
}
if
(
timelimit
=
=
0
)
return
0
;
if
(
rv
)
affixed
=
0
;
if
(
rv
)
{
presult
.
push_back
(
MSEP_FLD
)
;
presult
.
append
(
MORPH_PART
)
;
presult
.
append
(
st
.
c_str
(
)
)
;
if
(
!
HENTRY_FIND
(
rv
MORPH_STEM
)
)
{
presult
.
push_back
(
MSEP_FLD
)
;
presult
.
append
(
MORPH_STEM
)
;
presult
.
append
(
st
.
c_str
(
)
)
;
}
if
(
HENTRY_DATA
(
rv
)
)
{
presult
.
push_back
(
MSEP_FLD
)
;
presult
.
append
(
HENTRY_DATA2
(
rv
)
)
;
}
}
if
(
!
rv
)
{
if
(
compoundflag
&
&
!
(
rv
=
prefix_check
(
st
.
c_str
(
)
i
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
compoundflag
)
)
)
{
if
(
(
(
rv
=
suffix_check
(
st
.
c_str
(
)
i
0
NULL
FLAG_NULL
compoundflag
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
)
)
|
|
(
compoundmoresuffixes
&
&
(
rv
=
suffix_check_twosfx
(
st
.
c_str
(
)
i
0
NULL
compoundflag
)
)
)
)
&
&
!
hu_mov_rule
&
&
sfx
-
>
getCont
(
)
&
&
(
(
compoundforbidflag
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundforbidflag
sfx
-
>
getContLen
(
)
)
)
|
|
(
compoundend
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundend
sfx
-
>
getContLen
(
)
)
)
)
)
{
rv
=
NULL
;
}
}
if
(
rv
|
|
(
(
(
wordnum
=
=
0
)
&
&
compoundbegin
&
&
(
(
rv
=
suffix_check
(
st
.
c_str
(
)
i
0
NULL
FLAG_NULL
compoundbegin
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
)
)
|
|
(
compoundmoresuffixes
&
&
(
rv
=
suffix_check_twosfx
(
st
.
c_str
(
)
i
0
NULL
compoundbegin
)
)
)
|
|
(
rv
=
prefix_check
(
st
.
c_str
(
)
i
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
compoundbegin
)
)
)
)
|
|
(
(
wordnum
>
0
)
&
&
compoundmiddle
&
&
(
(
rv
=
suffix_check
(
st
.
c_str
(
)
i
0
NULL
FLAG_NULL
compoundmiddle
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
)
)
|
|
(
compoundmoresuffixes
&
&
(
rv
=
suffix_check_twosfx
(
st
.
c_str
(
)
i
0
NULL
compoundmiddle
)
)
)
|
|
(
rv
=
prefix_check
(
st
.
c_str
(
)
i
hu_mov_rule
?
IN_CPD_OTHER
:
IN_CPD_BEGIN
compoundmiddle
)
)
)
)
)
)
{
std
:
:
string
p
;
if
(
compoundflag
)
p
=
affix_check_morph
(
st
.
c_str
(
)
i
compoundflag
)
;
if
(
p
.
empty
(
)
)
{
if
(
(
wordnum
=
=
0
)
&
&
compoundbegin
)
{
p
=
affix_check_morph
(
st
.
c_str
(
)
i
compoundbegin
)
;
}
else
if
(
(
wordnum
>
0
)
&
&
compoundmiddle
)
{
p
=
affix_check_morph
(
st
.
c_str
(
)
i
compoundmiddle
)
;
}
}
if
(
!
p
.
empty
(
)
)
{
presult
.
push_back
(
MSEP_FLD
)
;
presult
.
append
(
MORPH_PART
)
;
presult
.
append
(
st
.
c_str
(
)
)
;
line_uniq_app
(
p
MSEP_REC
)
;
presult
.
append
(
p
)
;
}
checked_prefix
=
1
;
}
}
else
if
(
rv
-
>
astr
&
&
(
TESTAFF
(
rv
-
>
astr
forbiddenword
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
ONLYUPCASEFLAG
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
needaffix
rv
-
>
alen
)
)
)
{
st
[
i
]
=
ch
;
continue
;
}
if
(
(
rv
)
&
&
!
hu_mov_rule
&
&
(
(
pfx
&
&
pfx
-
>
getCont
(
)
&
&
TESTAFF
(
pfx
-
>
getCont
(
)
compoundforbidflag
pfx
-
>
getContLen
(
)
)
)
|
|
(
sfx
&
&
sfx
-
>
getCont
(
)
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundforbidflag
sfx
-
>
getContLen
(
)
)
)
)
)
{
continue
;
}
if
(
(
rv
)
&
&
!
checked_prefix
&
&
compoundend
&
&
!
hu_mov_rule
&
&
(
(
pfx
&
&
pfx
-
>
getCont
(
)
&
&
TESTAFF
(
pfx
-
>
getCont
(
)
compoundend
pfx
-
>
getContLen
(
)
)
)
|
|
(
sfx
&
&
sfx
-
>
getCont
(
)
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundend
sfx
-
>
getContLen
(
)
)
)
)
)
{
continue
;
}
if
(
(
rv
)
&
&
!
checked_prefix
&
&
(
wordnum
=
=
0
)
&
&
compoundmiddle
&
&
!
hu_mov_rule
&
&
(
(
pfx
&
&
pfx
-
>
getCont
(
)
&
&
TESTAFF
(
pfx
-
>
getCont
(
)
compoundmiddle
pfx
-
>
getContLen
(
)
)
)
|
|
(
sfx
&
&
sfx
-
>
getCont
(
)
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundmiddle
sfx
-
>
getContLen
(
)
)
)
)
)
{
rv
=
NULL
;
}
if
(
(
rv
)
&
&
(
rv
-
>
astr
)
&
&
(
TESTAFF
(
rv
-
>
astr
forbiddenword
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
ONLYUPCASEFLAG
rv
-
>
alen
)
)
)
continue
;
if
(
(
rv
)
&
&
(
compoundroot
)
&
&
(
TESTAFF
(
rv
-
>
astr
compoundroot
rv
-
>
alen
)
)
)
{
wordnum
+
+
;
}
if
(
(
(
rv
)
&
&
(
checked_prefix
|
|
(
words
&
&
words
[
wnum
]
)
|
|
(
compoundflag
&
&
TESTAFF
(
rv
-
>
astr
compoundflag
rv
-
>
alen
)
)
|
|
(
(
oldwordnum
=
=
0
)
&
&
compoundbegin
&
&
TESTAFF
(
rv
-
>
astr
compoundbegin
rv
-
>
alen
)
)
|
|
(
(
oldwordnum
>
0
)
&
&
compoundmiddle
&
&
TESTAFF
(
rv
-
>
astr
compoundmiddle
rv
-
>
alen
)
)
|
|
(
(
langnum
=
=
LANG_hu
)
&
&
hu_mov_rule
&
&
(
TESTAFF
(
rv
-
>
astr
'
F
'
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
'
G
'
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
'
H
'
rv
-
>
alen
)
)
)
)
&
&
!
(
(
checkcompoundtriple
&
&
!
words
&
&
(
word
[
i
-
1
]
=
=
word
[
i
]
)
&
&
(
(
(
i
>
1
)
&
&
(
word
[
i
-
1
]
=
=
word
[
i
-
2
]
)
)
|
|
(
(
word
[
i
-
1
]
=
=
word
[
i
+
1
]
)
)
)
)
|
|
(
!
checkcpdtable
.
empty
(
)
&
&
!
words
&
&
cpdpat_check
(
word
i
rv
NULL
affixed
)
)
|
|
(
checkcompoundcase
&
&
!
words
&
&
cpdcase_check
(
word
i
)
)
)
)
|
|
(
(
!
rv
)
&
&
(
langnum
=
=
LANG_hu
)
&
&
hu_mov_rule
&
&
(
rv
=
affix_check
(
st
.
c_str
(
)
i
)
)
&
&
(
sfx
&
&
sfx
-
>
getCont
(
)
&
&
(
TESTAFF
(
sfx
-
>
getCont
(
)
(
unsigned
short
)
'
x
'
sfx
-
>
getContLen
(
)
)
|
|
TESTAFF
(
sfx
-
>
getCont
(
)
(
unsigned
short
)
'
%
'
sfx
-
>
getContLen
(
)
)
)
)
)
)
{
if
(
langnum
=
=
LANG_hu
)
{
numsyllable
+
=
get_syllable
(
st
.
substr
(
0
i
)
)
;
if
(
pfx
&
&
(
get_syllable
(
pfx
-
>
getKey
(
)
)
>
1
)
)
wordnum
+
+
;
}
rv_first
=
rv
;
rv
=
lookup
(
(
word
+
i
)
)
;
while
(
(
rv
)
&
&
(
(
needaffix
&
&
TESTAFF
(
rv
-
>
astr
needaffix
rv
-
>
alen
)
)
|
|
!
(
(
compoundflag
&
&
!
words
&
&
TESTAFF
(
rv
-
>
astr
compoundflag
rv
-
>
alen
)
)
|
|
(
compoundend
&
&
!
words
&
&
TESTAFF
(
rv
-
>
astr
compoundend
rv
-
>
alen
)
)
|
|
(
!
defcpdtable
.
empty
(
)
&
&
words
&
&
defcpd_check
(
&
words
wnum
+
1
rv
NULL
1
)
)
)
)
)
{
rv
=
rv
-
>
next_homonym
;
}
if
(
rv
&
&
words
&
&
words
[
wnum
+
1
]
)
{
result
.
append
(
presult
)
;
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
MORPH_PART
)
;
result
.
append
(
word
+
i
)
;
if
(
complexprefixes
&
&
HENTRY_DATA
(
rv
)
)
result
.
append
(
HENTRY_DATA2
(
rv
)
)
;
if
(
!
HENTRY_FIND
(
rv
MORPH_STEM
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
MORPH_STEM
)
;
result
.
append
(
HENTRY_WORD
(
rv
)
)
;
}
if
(
!
complexprefixes
&
&
HENTRY_DATA
(
rv
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
HENTRY_DATA2
(
rv
)
)
;
}
result
.
push_back
(
MSEP_REC
)
;
return
0
;
}
oldnumsyllable2
=
numsyllable
;
oldwordnum2
=
wordnum
;
if
(
(
rv
)
&
&
(
langnum
=
=
LANG_hu
)
&
&
(
TESTAFF
(
rv
-
>
astr
'
I
'
rv
-
>
alen
)
)
&
&
!
(
TESTAFF
(
rv
-
>
astr
'
J
'
rv
-
>
alen
)
)
)
{
numsyllable
-
-
;
}
if
(
(
rv
)
&
&
(
compoundroot
)
&
&
(
TESTAFF
(
rv
-
>
astr
compoundroot
rv
-
>
alen
)
)
)
{
wordnum
+
+
;
}
if
(
(
rv
)
&
&
(
rv
-
>
astr
)
&
&
(
TESTAFF
(
rv
-
>
astr
forbiddenword
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
ONLYUPCASEFLAG
rv
-
>
alen
)
)
)
{
st
[
i
]
=
ch
;
continue
;
}
if
(
(
rv
)
&
&
(
(
compoundflag
&
&
TESTAFF
(
rv
-
>
astr
compoundflag
rv
-
>
alen
)
)
|
|
(
compoundend
&
&
TESTAFF
(
rv
-
>
astr
compoundend
rv
-
>
alen
)
)
)
&
&
(
(
(
cpdwordmax
=
=
-
1
)
|
|
(
wordnum
+
1
<
cpdwordmax
)
)
|
|
(
(
cpdmaxsyllable
!
=
0
)
&
&
(
numsyllable
+
get_syllable
(
std
:
:
string
(
HENTRY_WORD
(
rv
)
rv
-
>
blen
)
)
<
=
cpdmaxsyllable
)
)
)
&
&
(
(
!
checkcompounddup
|
|
(
rv
!
=
rv_first
)
)
)
)
{
result
.
append
(
presult
)
;
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
MORPH_PART
)
;
result
.
append
(
word
+
i
)
;
if
(
HENTRY_DATA
(
rv
)
)
{
if
(
complexprefixes
)
result
.
append
(
HENTRY_DATA2
(
rv
)
)
;
if
(
!
HENTRY_FIND
(
rv
MORPH_STEM
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
MORPH_STEM
)
;
result
.
append
(
HENTRY_WORD
(
rv
)
)
;
}
if
(
!
complexprefixes
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
HENTRY_DATA2
(
rv
)
)
;
}
}
result
.
push_back
(
MSEP_REC
)
;
ok
=
1
;
}
numsyllable
=
oldnumsyllable2
;
wordnum
=
oldwordnum2
;
sfx
=
NULL
;
sfxflag
=
FLAG_NULL
;
if
(
compoundflag
&
&
!
onlycpdrule
)
rv
=
affix_check
(
(
word
+
i
)
strlen
(
word
+
i
)
compoundflag
)
;
else
rv
=
NULL
;
if
(
!
rv
&
&
compoundend
&
&
!
onlycpdrule
)
{
sfx
=
NULL
;
pfx
=
NULL
;
rv
=
affix_check
(
(
word
+
i
)
strlen
(
word
+
i
)
compoundend
)
;
}
if
(
!
rv
&
&
!
defcpdtable
.
empty
(
)
&
&
words
)
{
rv
=
affix_check
(
(
word
+
i
)
strlen
(
word
+
i
)
0
IN_CPD_END
)
;
if
(
rv
&
&
words
&
&
defcpd_check
(
&
words
wnum
+
1
rv
NULL
1
)
)
{
std
:
:
string
m
;
if
(
compoundflag
)
m
=
affix_check_morph
(
(
word
+
i
)
strlen
(
word
+
i
)
compoundflag
)
;
if
(
m
.
empty
(
)
&
&
compoundend
)
{
m
=
affix_check_morph
(
(
word
+
i
)
strlen
(
word
+
i
)
compoundend
)
;
}
result
.
append
(
presult
)
;
if
(
!
m
.
empty
(
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
MORPH_PART
)
;
result
.
append
(
word
+
i
)
;
line_uniq_app
(
m
MSEP_REC
)
;
result
.
append
(
m
)
;
}
result
.
push_back
(
MSEP_REC
)
;
ok
=
1
;
}
}
if
(
(
rv
)
&
&
(
(
pfx
&
&
pfx
-
>
getCont
(
)
&
&
TESTAFF
(
pfx
-
>
getCont
(
)
compoundforbidflag
pfx
-
>
getContLen
(
)
)
)
|
|
(
sfx
&
&
sfx
-
>
getCont
(
)
&
&
TESTAFF
(
sfx
-
>
getCont
(
)
compoundforbidflag
sfx
-
>
getContLen
(
)
)
)
)
)
{
rv
=
NULL
;
}
if
(
(
rv
)
&
&
(
rv
-
>
astr
)
&
&
(
TESTAFF
(
rv
-
>
astr
forbiddenword
rv
-
>
alen
)
|
|
TESTAFF
(
rv
-
>
astr
ONLYUPCASEFLAG
rv
-
>
alen
)
)
&
&
(
!
TESTAFF
(
rv
-
>
astr
needaffix
rv
-
>
alen
)
)
)
{
st
[
i
]
=
ch
;
continue
;
}
if
(
langnum
=
=
LANG_hu
)
{
numsyllable
+
=
get_syllable
(
word
+
i
)
;
if
(
sfxappnd
)
{
std
:
:
string
tmp
(
sfxappnd
)
;
reverseword
(
tmp
)
;
numsyllable
-
=
short
(
get_syllable
(
tmp
)
+
sfxextra
)
;
}
else
{
numsyllable
-
=
short
(
sfxextra
)
;
}
if
(
pfx
&
&
(
get_syllable
(
pfx
-
>
getKey
(
)
)
>
1
)
)
wordnum
+
+
;
if
(
!
cpdsyllablenum
.
empty
(
)
)
{
switch
(
sfxflag
)
{
case
'
c
'
:
{
numsyllable
+
=
2
;
break
;
}
case
'
J
'
:
{
numsyllable
+
=
1
;
break
;
}
case
'
I
'
:
{
if
(
rv
&
&
TESTAFF
(
rv
-
>
astr
'
J
'
rv
-
>
alen
)
)
numsyllable
+
=
1
;
break
;
}
}
}
}
if
(
(
rv
)
&
&
(
compoundroot
)
&
&
(
TESTAFF
(
rv
-
>
astr
compoundroot
rv
-
>
alen
)
)
)
{
wordnum
+
+
;
}
if
(
(
rv
)
&
&
(
(
(
cpdwordmax
=
=
-
1
)
|
|
(
wordnum
+
1
<
cpdwordmax
)
)
|
|
(
(
cpdmaxsyllable
!
=
0
)
&
&
(
numsyllable
<
=
cpdmaxsyllable
)
)
)
&
&
(
(
!
checkcompounddup
|
|
(
rv
!
=
rv_first
)
)
)
)
{
std
:
:
string
m
;
if
(
compoundflag
)
m
=
affix_check_morph
(
(
word
+
i
)
strlen
(
word
+
i
)
compoundflag
)
;
if
(
m
.
empty
(
)
&
&
compoundend
)
{
m
=
affix_check_morph
(
(
word
+
i
)
strlen
(
word
+
i
)
compoundend
)
;
}
result
.
append
(
presult
)
;
if
(
!
m
.
empty
(
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
MORPH_PART
)
;
result
.
append
(
word
+
i
)
;
line_uniq_app
(
m
MSEP_REC
)
;
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
m
)
;
}
result
.
push_back
(
MSEP_REC
)
;
ok
=
1
;
}
numsyllable
=
oldnumsyllable2
;
wordnum
=
oldwordnum2
;
if
(
(
wordnum
+
2
<
maxwordnum
)
&
&
(
ok
=
=
0
)
)
{
compound_check_morph
(
(
word
+
i
)
strlen
(
word
+
i
)
wordnum
+
1
numsyllable
maxwordnum
wnum
+
1
words
rwords
0
result
&
presult
)
;
}
else
{
rv
=
NULL
;
}
}
st
[
i
]
=
ch
;
wordnum
=
oldwordnum
;
numsyllable
=
oldnumsyllable
;
}
while
(
!
defcpdtable
.
empty
(
)
&
&
oldwordnum
=
=
0
&
&
onlycpdrule
+
+
<
1
)
;
}
return
0
;
}
inline
int
AffixMgr
:
:
isRevSubset
(
const
char
*
s1
const
char
*
end_of_s2
int
len
)
{
while
(
(
len
>
0
)
&
&
(
*
s1
!
=
'
\
0
'
)
&
&
(
(
*
s1
=
=
*
end_of_s2
)
|
|
(
*
s1
=
=
'
.
'
)
)
)
{
s1
+
+
;
end_of_s2
-
-
;
len
-
-
;
}
return
(
*
s1
=
=
'
\
0
'
)
;
}
struct
hentry
*
AffixMgr
:
:
suffix_check
(
const
char
*
word
int
len
int
sfxopts
PfxEntry
*
ppfx
const
FLAG
cclass
const
FLAG
needflag
char
in_compound
)
{
struct
hentry
*
rv
=
NULL
;
PfxEntry
*
ep
=
ppfx
;
SfxEntry
*
se
=
sStart
[
0
]
;
while
(
se
)
{
if
(
!
cclass
|
|
se
-
>
getCont
(
)
)
{
if
(
(
(
(
in_compound
!
=
IN_CPD_BEGIN
)
)
|
|
(
se
-
>
getCont
(
)
&
&
compoundpermitflag
&
&
TESTAFF
(
se
-
>
getCont
(
)
compoundpermitflag
se
-
>
getContLen
(
)
)
)
)
&
&
(
!
circumfix
|
|
(
(
!
ppfx
|
|
!
(
ep
-
>
getCont
(
)
)
|
|
!
TESTAFF
(
ep
-
>
getCont
(
)
circumfix
ep
-
>
getContLen
(
)
)
)
&
&
(
!
se
-
>
getCont
(
)
|
|
!
(
TESTAFF
(
se
-
>
getCont
(
)
circumfix
se
-
>
getContLen
(
)
)
)
)
)
|
|
(
(
ppfx
&
&
(
ep
-
>
getCont
(
)
)
&
&
TESTAFF
(
ep
-
>
getCont
(
)
circumfix
ep
-
>
getContLen
(
)
)
)
&
&
(
se
-
>
getCont
(
)
&
&
(
TESTAFF
(
se
-
>
getCont
(
)
circumfix
se
-
>
getContLen
(
)
)
)
)
)
)
&
&
(
in_compound
|
|
!
(
se
-
>
getCont
(
)
&
&
(
TESTAFF
(
se
-
>
getCont
(
)
onlyincompound
se
-
>
getContLen
(
)
)
)
)
)
&
&
(
cclass
|
|
!
(
se
-
>
getCont
(
)
&
&
TESTAFF
(
se
-
>
getCont
(
)
needaffix
se
-
>
getContLen
(
)
)
)
|
|
(
ppfx
&
&
!
(
(
ep
-
>
getCont
(
)
)
&
&
TESTAFF
(
ep
-
>
getCont
(
)
needaffix
ep
-
>
getContLen
(
)
)
)
)
)
)
{
rv
=
se
-
>
checkword
(
word
len
sfxopts
ppfx
(
FLAG
)
cclass
needflag
(
in_compound
?
0
:
onlyincompound
)
)
;
if
(
rv
)
{
sfx
=
se
;
return
rv
;
}
}
}
se
=
se
-
>
getNext
(
)
;
}
if
(
len
=
=
0
)
return
NULL
;
unsigned
char
sp
=
*
(
(
const
unsigned
char
*
)
(
word
+
len
-
1
)
)
;
SfxEntry
*
sptr
=
sStart
[
sp
]
;
while
(
sptr
)
{
if
(
isRevSubset
(
sptr
-
>
getKey
(
)
word
+
len
-
1
len
)
)
{
if
(
(
(
(
in_compound
!
=
IN_CPD_BEGIN
)
)
|
|
(
sptr
-
>
getCont
(
)
&
&
compoundpermitflag
&
&
TESTAFF
(
sptr
-
>
getCont
(
)
compoundpermitflag
sptr
-
>
getContLen
(
)
)
)
)
&
&
(
!
circumfix
|
|
(
(
!
ppfx
|
|
!
(
ep
-
>
getCont
(
)
)
|
|
!
TESTAFF
(
ep
-
>
getCont
(
)
circumfix
ep
-
>
getContLen
(
)
)
)
&
&
(
!
sptr
-
>
getCont
(
)
|
|
!
(
TESTAFF
(
sptr
-
>
getCont
(
)
circumfix
sptr
-
>
getContLen
(
)
)
)
)
)
|
|
(
(
ppfx
&
&
(
ep
-
>
getCont
(
)
)
&
&
TESTAFF
(
ep
-
>
getCont
(
)
circumfix
ep
-
>
getContLen
(
)
)
)
&
&
(
sptr
-
>
getCont
(
)
&
&
(
TESTAFF
(
sptr
-
>
getCont
(
)
circumfix
sptr
-
>
getContLen
(
)
)
)
)
)
)
&
&
(
in_compound
|
|
!
(
(
sptr
-
>
getCont
(
)
&
&
(
TESTAFF
(
sptr
-
>
getCont
(
)
onlyincompound
sptr
-
>
getContLen
(
)
)
)
)
)
)
&
&
(
cclass
|
|
!
(
sptr
-
>
getCont
(
)
&
&
TESTAFF
(
sptr
-
>
getCont
(
)
needaffix
sptr
-
>
getContLen
(
)
)
)
|
|
(
ppfx
&
&
!
(
(
ep
-
>
getCont
(
)
)
&
&
TESTAFF
(
ep
-
>
getCont
(
)
needaffix
ep
-
>
getContLen
(
)
)
)
)
)
)
if
(
in_compound
!
=
IN_CPD_END
|
|
ppfx
|
|
!
(
sptr
-
>
getCont
(
)
&
&
TESTAFF
(
sptr
-
>
getCont
(
)
onlyincompound
sptr
-
>
getContLen
(
)
)
)
)
{
rv
=
sptr
-
>
checkword
(
word
len
sfxopts
ppfx
cclass
needflag
(
in_compound
?
0
:
onlyincompound
)
)
;
if
(
rv
)
{
sfx
=
sptr
;
sfxflag
=
sptr
-
>
getFlag
(
)
;
if
(
!
sptr
-
>
getCont
(
)
)
sfxappnd
=
sptr
-
>
getKey
(
)
;
else
if
(
langnum
=
=
LANG_hu
&
&
sptr
-
>
getKeyLen
(
)
&
&
sptr
-
>
getKey
(
)
[
0
]
=
=
'
i
'
&
&
sptr
-
>
getKey
(
)
[
1
]
!
=
'
y
'
&
&
sptr
-
>
getKey
(
)
[
1
]
!
=
'
t
'
)
{
sfxextra
=
1
;
}
return
rv
;
}
}
sptr
=
sptr
-
>
getNextEQ
(
)
;
}
else
{
sptr
=
sptr
-
>
getNextNE
(
)
;
}
}
return
NULL
;
}
struct
hentry
*
AffixMgr
:
:
suffix_check_twosfx
(
const
char
*
word
int
len
int
sfxopts
PfxEntry
*
ppfx
const
FLAG
needflag
)
{
struct
hentry
*
rv
=
NULL
;
SfxEntry
*
se
=
sStart
[
0
]
;
while
(
se
)
{
if
(
contclasses
[
se
-
>
getFlag
(
)
]
)
{
rv
=
se
-
>
check_twosfx
(
word
len
sfxopts
ppfx
needflag
)
;
if
(
rv
)
return
rv
;
}
se
=
se
-
>
getNext
(
)
;
}
if
(
len
=
=
0
)
return
NULL
;
unsigned
char
sp
=
*
(
(
const
unsigned
char
*
)
(
word
+
len
-
1
)
)
;
SfxEntry
*
sptr
=
sStart
[
sp
]
;
while
(
sptr
)
{
if
(
isRevSubset
(
sptr
-
>
getKey
(
)
word
+
len
-
1
len
)
)
{
if
(
contclasses
[
sptr
-
>
getFlag
(
)
]
)
{
rv
=
sptr
-
>
check_twosfx
(
word
len
sfxopts
ppfx
needflag
)
;
if
(
rv
)
{
sfxflag
=
sptr
-
>
getFlag
(
)
;
if
(
!
sptr
-
>
getCont
(
)
)
sfxappnd
=
sptr
-
>
getKey
(
)
;
return
rv
;
}
}
sptr
=
sptr
-
>
getNextEQ
(
)
;
}
else
{
sptr
=
sptr
-
>
getNextNE
(
)
;
}
}
return
NULL
;
}
std
:
:
string
AffixMgr
:
:
suffix_check_twosfx_morph
(
const
char
*
word
int
len
int
sfxopts
PfxEntry
*
ppfx
const
FLAG
needflag
)
{
std
:
:
string
result
;
std
:
:
string
result2
;
std
:
:
string
result3
;
SfxEntry
*
se
=
sStart
[
0
]
;
while
(
se
)
{
if
(
contclasses
[
se
-
>
getFlag
(
)
]
)
{
std
:
:
string
st
=
se
-
>
check_twosfx_morph
(
word
len
sfxopts
ppfx
needflag
)
;
if
(
!
st
.
empty
(
)
)
{
if
(
ppfx
)
{
if
(
ppfx
-
>
getMorph
(
)
)
{
result
.
append
(
ppfx
-
>
getMorph
(
)
)
;
result
.
push_back
(
MSEP_FLD
)
;
}
else
debugflag
(
result
ppfx
-
>
getFlag
(
)
)
;
}
result
.
append
(
st
)
;
if
(
se
-
>
getMorph
(
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
se
-
>
getMorph
(
)
)
;
}
else
debugflag
(
result
se
-
>
getFlag
(
)
)
;
result
.
push_back
(
MSEP_REC
)
;
}
}
se
=
se
-
>
getNext
(
)
;
}
if
(
len
=
=
0
)
return
std
:
:
string
(
)
;
unsigned
char
sp
=
*
(
(
const
unsigned
char
*
)
(
word
+
len
-
1
)
)
;
SfxEntry
*
sptr
=
sStart
[
sp
]
;
while
(
sptr
)
{
if
(
isRevSubset
(
sptr
-
>
getKey
(
)
word
+
len
-
1
len
)
)
{
if
(
contclasses
[
sptr
-
>
getFlag
(
)
]
)
{
std
:
:
string
st
=
sptr
-
>
check_twosfx_morph
(
word
len
sfxopts
ppfx
needflag
)
;
if
(
!
st
.
empty
(
)
)
{
sfxflag
=
sptr
-
>
getFlag
(
)
;
if
(
!
sptr
-
>
getCont
(
)
)
sfxappnd
=
sptr
-
>
getKey
(
)
;
result2
.
assign
(
st
)
;
result3
.
clear
(
)
;
if
(
sptr
-
>
getMorph
(
)
)
{
result3
.
push_back
(
MSEP_FLD
)
;
result3
.
append
(
sptr
-
>
getMorph
(
)
)
;
}
else
debugflag
(
result3
sptr
-
>
getFlag
(
)
)
;
strlinecat
(
result2
result3
)
;
result2
.
push_back
(
MSEP_REC
)
;
result
.
append
(
result2
)
;
}
}
sptr
=
sptr
-
>
getNextEQ
(
)
;
}
else
{
sptr
=
sptr
-
>
getNextNE
(
)
;
}
}
return
result
;
}
std
:
:
string
AffixMgr
:
:
suffix_check_morph
(
const
char
*
word
int
len
int
sfxopts
PfxEntry
*
ppfx
const
FLAG
cclass
const
FLAG
needflag
char
in_compound
)
{
std
:
:
string
result
;
struct
hentry
*
rv
=
NULL
;
PfxEntry
*
ep
=
ppfx
;
SfxEntry
*
se
=
sStart
[
0
]
;
while
(
se
)
{
if
(
!
cclass
|
|
se
-
>
getCont
(
)
)
{
if
(
(
(
(
(
in_compound
!
=
IN_CPD_BEGIN
)
)
|
|
(
se
-
>
getCont
(
)
&
&
compoundpermitflag
&
&
TESTAFF
(
se
-
>
getCont
(
)
compoundpermitflag
se
-
>
getContLen
(
)
)
)
)
&
&
(
!
circumfix
|
|
(
(
!
ppfx
|
|
!
(
ep
-
>
getCont
(
)
)
|
|
!
TESTAFF
(
ep
-
>
getCont
(
)
circumfix
ep
-
>
getContLen
(
)
)
)
&
&
(
!
se
-
>
getCont
(
)
|
|
!
(
TESTAFF
(
se
-
>
getCont
(
)
circumfix
se
-
>
getContLen
(
)
)
)
)
)
|
|
(
(
ppfx
&
&
(
ep
-
>
getCont
(
)
)
&
&
TESTAFF
(
ep
-
>
getCont
(
)
circumfix
ep
-
>
getContLen
(
)
)
)
&
&
(
se
-
>
getCont
(
)
&
&
(
TESTAFF
(
se
-
>
getCont
(
)
circumfix
se
-
>
getContLen
(
)
)
)
)
)
)
&
&
(
in_compound
|
|
!
(
(
se
-
>
getCont
(
)
&
&
(
TESTAFF
(
se
-
>
getCont
(
)
onlyincompound
se
-
>
getContLen
(
)
)
)
)
)
)
&
&
(
cclass
|
|
!
(
se
-
>
getCont
(
)
&
&
TESTAFF
(
se
-
>
getCont
(
)
needaffix
se
-
>
getContLen
(
)
)
)
|
|
(
ppfx
&
&
!
(
(
ep
-
>
getCont
(
)
)
&
&
TESTAFF
(
ep
-
>
getCont
(
)
needaffix
ep
-
>
getContLen
(
)
)
)
)
)
)
)
rv
=
se
-
>
checkword
(
word
len
sfxopts
ppfx
cclass
needflag
FLAG_NULL
)
;
while
(
rv
)
{
if
(
ppfx
)
{
if
(
ppfx
-
>
getMorph
(
)
)
{
result
.
append
(
ppfx
-
>
getMorph
(
)
)
;
result
.
push_back
(
MSEP_FLD
)
;
}
else
debugflag
(
result
ppfx
-
>
getFlag
(
)
)
;
}
if
(
complexprefixes
&
&
HENTRY_DATA
(
rv
)
)
result
.
append
(
HENTRY_DATA2
(
rv
)
)
;
if
(
!
HENTRY_FIND
(
rv
MORPH_STEM
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
MORPH_STEM
)
;
result
.
append
(
HENTRY_WORD
(
rv
)
)
;
}
if
(
!
complexprefixes
&
&
HENTRY_DATA
(
rv
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
HENTRY_DATA2
(
rv
)
)
;
}
if
(
se
-
>
getMorph
(
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
se
-
>
getMorph
(
)
)
;
}
else
debugflag
(
result
se
-
>
getFlag
(
)
)
;
result
.
push_back
(
MSEP_REC
)
;
rv
=
se
-
>
get_next_homonym
(
rv
sfxopts
ppfx
cclass
needflag
)
;
}
}
se
=
se
-
>
getNext
(
)
;
}
if
(
len
=
=
0
)
return
std
:
:
string
(
)
;
unsigned
char
sp
=
*
(
(
const
unsigned
char
*
)
(
word
+
len
-
1
)
)
;
SfxEntry
*
sptr
=
sStart
[
sp
]
;
while
(
sptr
)
{
if
(
isRevSubset
(
sptr
-
>
getKey
(
)
word
+
len
-
1
len
)
)
{
if
(
(
(
(
(
in_compound
!
=
IN_CPD_BEGIN
)
)
|
|
(
sptr
-
>
getCont
(
)
&
&
compoundpermitflag
&
&
TESTAFF
(
sptr
-
>
getCont
(
)
compoundpermitflag
sptr
-
>
getContLen
(
)
)
)
)
&
&
(
!
circumfix
|
|
(
(
!
ppfx
|
|
!
(
ep
-
>
getCont
(
)
)
|
|
!
TESTAFF
(
ep
-
>
getCont
(
)
circumfix
ep
-
>
getContLen
(
)
)
)
&
&
(
!
sptr
-
>
getCont
(
)
|
|
!
(
TESTAFF
(
sptr
-
>
getCont
(
)
circumfix
sptr
-
>
getContLen
(
)
)
)
)
)
|
|
(
(
ppfx
&
&
(
ep
-
>
getCont
(
)
)
&
&
TESTAFF
(
ep
-
>
getCont
(
)
circumfix
ep
-
>
getContLen
(
)
)
)
&
&
(
sptr
-
>
getCont
(
)
&
&
(
TESTAFF
(
sptr
-
>
getCont
(
)
circumfix
sptr
-
>
getContLen
(
)
)
)
)
)
)
&
&
(
in_compound
|
|
!
(
(
sptr
-
>
getCont
(
)
&
&
(
TESTAFF
(
sptr
-
>
getCont
(
)
onlyincompound
sptr
-
>
getContLen
(
)
)
)
)
)
)
&
&
(
cclass
|
|
!
(
sptr
-
>
getCont
(
)
&
&
TESTAFF
(
sptr
-
>
getCont
(
)
needaffix
sptr
-
>
getContLen
(
)
)
)
)
)
)
rv
=
sptr
-
>
checkword
(
word
len
sfxopts
ppfx
cclass
needflag
FLAG_NULL
)
;
while
(
rv
)
{
if
(
ppfx
)
{
if
(
ppfx
-
>
getMorph
(
)
)
{
result
.
append
(
ppfx
-
>
getMorph
(
)
)
;
result
.
push_back
(
MSEP_FLD
)
;
}
else
debugflag
(
result
ppfx
-
>
getFlag
(
)
)
;
}
if
(
complexprefixes
&
&
HENTRY_DATA
(
rv
)
)
result
.
append
(
HENTRY_DATA2
(
rv
)
)
;
if
(
!
HENTRY_FIND
(
rv
MORPH_STEM
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
MORPH_STEM
)
;
result
.
append
(
HENTRY_WORD
(
rv
)
)
;
}
if
(
!
complexprefixes
&
&
HENTRY_DATA
(
rv
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
HENTRY_DATA2
(
rv
)
)
;
}
if
(
sptr
-
>
getMorph
(
)
)
{
result
.
push_back
(
MSEP_FLD
)
;
result
.
append
(
sptr
-
>
getMorph
(
)
)
;
}
else
debugflag
(
result
sptr
-
>
getFlag
(
)
)
;
result
.
push_back
(
MSEP_REC
)
;
rv
=
sptr
-
>
get_next_homonym
(
rv
sfxopts
ppfx
cclass
needflag
)
;
}
sptr
=
sptr
-
>
getNextEQ
(
)
;
}
else
{
sptr
=
sptr
-
>
getNextNE
(
)
;
}
}
return
result
;
}
struct
hentry
*
AffixMgr
:
:
affix_check
(
const
char
*
word
int
len
const
FLAG
needflag
char
in_compound
)
{
struct
hentry
*
rv
=
prefix_check
(
word
len
in_compound
needflag
)
;
if
(
rv
)
return
rv
;
rv
=
suffix_check
(
word
len
0
NULL
FLAG_NULL
needflag
in_compound
)
;
if
(
havecontclass
)
{
sfx
=
NULL
;
pfx
=
NULL
;
if
(
rv
)
return
rv
;
rv
=
suffix_check_twosfx
(
word
len
0
NULL
needflag
)
;
if
(
rv
)
return
rv
;
rv
=
prefix_check_twosfx
(
word
len
IN_CPD_NOT
needflag
)
;
}
return
rv
;
}
std
:
:
string
AffixMgr
:
:
affix_check_morph
(
const
char
*
word
int
len
const
FLAG
needflag
char
in_compound
)
{
std
:
:
string
result
;
std
:
:
string
st
=
prefix_check_morph
(
word
len
in_compound
)
;
if
(
!
st
.
empty
(
)
)
{
result
.
append
(
st
)
;
}
st
=
suffix_check_morph
(
word
len
0
NULL
'
\
0
'
needflag
in_compound
)
;
if
(
!
st
.
empty
(
)
)
{
result
.
append
(
st
)
;
}
if
(
havecontclass
)
{
sfx
=
NULL
;
pfx
=
NULL
;
st
=
suffix_check_twosfx_morph
(
word
len
0
NULL
needflag
)
;
if
(
!
st
.
empty
(
)
)
{
result
.
append
(
st
)
;
}
st
=
prefix_check_twosfx_morph
(
word
len
IN_CPD_NOT
needflag
)
;
if
(
!
st
.
empty
(
)
)
{
result
.
append
(
st
)
;
}
}
return
result
;
}
static
int
morphcmp
(
const
char
*
s
const
char
*
t
)
{
int
se
=
0
;
int
te
=
0
;
const
char
*
sl
;
const
char
*
tl
;
const
char
*
olds
;
const
char
*
oldt
;
if
(
!
s
|
|
!
t
)
return
1
;
olds
=
s
;
sl
=
strchr
(
s
'
\
n
'
)
;
s
=
strstr
(
s
MORPH_DERI_SFX
)
;
if
(
!
s
|
|
(
sl
&
&
sl
<
s
)
)
s
=
strstr
(
olds
MORPH_INFL_SFX
)
;
if
(
!
s
|
|
(
sl
&
&
sl
<
s
)
)
{
s
=
strstr
(
olds
MORPH_TERM_SFX
)
;
olds
=
NULL
;
}
oldt
=
t
;
tl
=
strchr
(
t
'
\
n
'
)
;
t
=
strstr
(
t
MORPH_DERI_SFX
)
;
if
(
!
t
|
|
(
tl
&
&
tl
<
t
)
)
t
=
strstr
(
oldt
MORPH_INFL_SFX
)
;
if
(
!
t
|
|
(
tl
&
&
tl
<
t
)
)
{
t
=
strstr
(
oldt
MORPH_TERM_SFX
)
;
oldt
=
NULL
;
}
while
(
s
&
&
t
&
&
(
!
sl
|
|
sl
>
s
)
&
&
(
!
tl
|
|
tl
>
t
)
)
{
s
+
=
MORPH_TAG_LEN
;
t
+
=
MORPH_TAG_LEN
;
se
=
0
;
te
=
0
;
while
(
(
*
s
=
=
*
t
)
&
&
!
se
&
&
!
te
)
{
s
+
+
;
t
+
+
;
switch
(
*
s
)
{
case
'
'
:
case
'
\
n
'
:
case
'
\
t
'
:
case
'
\
0
'
:
se
=
1
;
}
switch
(
*
t
)
{
case
'
'
:
case
'
\
n
'
:
case
'
\
t
'
:
case
'
\
0
'
:
te
=
1
;
}
}
if
(
!
se
|
|
!
te
)
{
if
(
olds
)
return
-
1
;
return
1
;
}
olds
=
s
;
s
=
strstr
(
s
MORPH_DERI_SFX
)
;
if
(
!
s
|
|
(
sl
&
&
sl
<
s
)
)
s
=
strstr
(
olds
MORPH_INFL_SFX
)
;
if
(
!
s
|
|
(
sl
&
&
sl
<
s
)
)
{
s
=
strstr
(
olds
MORPH_TERM_SFX
)
;
olds
=
NULL
;
}
oldt
=
t
;
t
=
strstr
(
t
MORPH_DERI_SFX
)
;
if
(
!
t
|
|
(
tl
&
&
tl
<
t
)
)
t
=
strstr
(
oldt
MORPH_INFL_SFX
)
;
if
(
!
t
|
|
(
tl
&
&
tl
<
t
)
)
{
t
=
strstr
(
oldt
MORPH_TERM_SFX
)
;
oldt
=
NULL
;
}
}
if
(
!
s
&
&
!
t
&
&
se
&
&
te
)
return
0
;
return
1
;
}
std
:
:
string
AffixMgr
:
:
morphgen
(
const
char
*
ts
int
wl
const
unsigned
short
*
ap
unsigned
short
al
const
char
*
morph
const
char
*
targetmorph
int
level
)
{
if
(
!
morph
)
return
std
:
:
string
(
)
;
if
(
TESTAFF
(
ap
substandard
al
)
)
return
std
:
:
string
(
)
;
if
(
morphcmp
(
morph
targetmorph
)
=
=
0
)
return
ts
;
size_t
stemmorphcatpos
;
std
:
:
string
mymorph
;
if
(
strstr
(
morph
MORPH_INFL_SFX
)
|
|
strstr
(
morph
MORPH_DERI_SFX
)
)
{
mymorph
.
assign
(
morph
)
;
mymorph
.
push_back
(
MSEP_FLD
)
;
stemmorphcatpos
=
mymorph
.
size
(
)
;
}
else
{
stemmorphcatpos
=
std
:
:
string
:
:
npos
;
}
for
(
int
i
=
0
;
i
<
al
;
i
+
+
)
{
const
unsigned
char
c
=
(
unsigned
char
)
(
ap
[
i
]
&
0x00FF
)
;
SfxEntry
*
sptr
=
sFlag
[
c
]
;
while
(
sptr
)
{
if
(
sptr
-
>
getFlag
(
)
=
=
ap
[
i
]
&
&
sptr
-
>
getMorph
(
)
&
&
(
(
sptr
-
>
getContLen
(
)
=
=
0
)
|
|
!
TESTAFF
(
sptr
-
>
getCont
(
)
substandard
sptr
-
>
getContLen
(
)
)
)
)
{
const
char
*
stemmorph
;
if
(
stemmorphcatpos
!
=
std
:
:
string
:
:
npos
)
{
mymorph
.
replace
(
stemmorphcatpos
std
:
:
string
:
:
npos
sptr
-
>
getMorph
(
)
)
;
stemmorph
=
mymorph
.
c_str
(
)
;
}
else
{
stemmorph
=
sptr
-
>
getMorph
(
)
;
}
int
cmp
=
morphcmp
(
stemmorph
targetmorph
)
;
if
(
cmp
=
=
0
)
{
std
:
:
string
newword
=
sptr
-
>
add
(
ts
wl
)
;
if
(
!
newword
.
empty
(
)
)
{
hentry
*
check
=
pHMgr
-
>
lookup
(
newword
.
c_str
(
)
)
;
if
(
!
check
|
|
!
check
-
>
astr
|
|
!
(
TESTAFF
(
check
-
>
astr
forbiddenword
check
-
>
alen
)
|
|
TESTAFF
(
check
-
>
astr
ONLYUPCASEFLAG
check
-
>
alen
)
)
)
{
return
newword
;
}
}
}
if
(
(
level
=
=
0
)
&
&
(
cmp
=
=
1
)
&
&
(
sptr
-
>
getContLen
(
)
>
0
)
&
&
!
TESTAFF
(
sptr
-
>
getCont
(
)
substandard
sptr
-
>
getContLen
(
)
)
)
{
std
:
:
string
newword
=
sptr
-
>
add
(
ts
wl
)
;
if
(
!
newword
.
empty
(
)
)
{
std
:
:
string
newword2
=
morphgen
(
newword
.
c_str
(
)
newword
.
size
(
)
sptr
-
>
getCont
(
)
sptr
-
>
getContLen
(
)
stemmorph
targetmorph
1
)
;
if
(
!
newword2
.
empty
(
)
)
{
return
newword2
;
}
}
}
}
sptr
=
sptr
-
>
getFlgNxt
(
)
;
}
}
return
std
:
:
string
(
)
;
}
int
AffixMgr
:
:
expand_rootword
(
struct
guessword
*
wlst
int
maxn
const
char
*
ts
int
wl
const
unsigned
short
*
ap
unsigned
short
al
const
char
*
bad
int
badl
const
char
*
phon
)
{
int
nh
=
0
;
if
(
(
nh
<
maxn
)
&
&
!
(
al
&
&
(
(
needaffix
&
&
TESTAFF
(
ap
needaffix
al
)
)
|
|
(
onlyincompound
&
&
TESTAFF
(
ap
onlyincompound
al
)
)
)
)
)
{
wlst
[
nh
]
.
word
=
mystrdup
(
ts
)
;
if
(
!
wlst
[
nh
]
.
word
)
return
0
;
wlst
[
nh
]
.
allow
=
false
;
wlst
[
nh
]
.
orig
=
NULL
;
nh
+
+
;
if
(
phon
&
&
(
nh
<
maxn
)
)
{
wlst
[
nh
]
.
word
=
mystrdup
(
phon
)
;
if
(
!
wlst
[
nh
]
.
word
)
return
nh
-
1
;
wlst
[
nh
]
.
allow
=
false
;
wlst
[
nh
]
.
orig
=
mystrdup
(
ts
)
;
if
(
!
wlst
[
nh
]
.
orig
)
return
nh
-
1
;
nh
+
+
;
}
}
for
(
int
i
=
0
;
i
<
al
;
i
+
+
)
{
const
unsigned
char
c
=
(
unsigned
char
)
(
ap
[
i
]
&
0x00FF
)
;
SfxEntry
*
sptr
=
sFlag
[
c
]
;
while
(
sptr
)
{
if
(
(
sptr
-
>
getFlag
(
)
=
=
ap
[
i
]
)
&
&
(
!
sptr
-
>
getKeyLen
(
)
|
|
(
(
badl
>
sptr
-
>
getKeyLen
(
)
)
&
&
(
strcmp
(
sptr
-
>
getAffix
(
)
bad
+
badl
-
sptr
-
>
getKeyLen
(
)
)
=
=
0
)
)
)
&
&
!
(
sptr
-
>
getCont
(
)
&
&
(
(
needaffix
&
&
TESTAFF
(
sptr
-
>
getCont
(
)
needaffix
sptr
-
>
getContLen
(
)
)
)
|
|
(
circumfix
&
&
TESTAFF
(
sptr
-
>
getCont
(
)
circumfix
sptr
-
>
getContLen
(
)
)
)
|
|
(
onlyincompound
&
&
TESTAFF
(
sptr
-
>
getCont
(
)
onlyincompound
sptr
-
>
getContLen
(
)
)
)
)
)
)
{
std
:
:
string
newword
=
sptr
-
>
add
(
ts
wl
)
;
if
(
!
newword
.
empty
(
)
)
{
if
(
nh
<
maxn
)
{
wlst
[
nh
]
.
word
=
mystrdup
(
newword
.
c_str
(
)
)
;
wlst
[
nh
]
.
allow
=
sptr
-
>
allowCross
(
)
;
wlst
[
nh
]
.
orig
=
NULL
;
nh
+
+
;
if
(
phon
&
&
(
nh
<
maxn
)
)
{
std
:
:
string
prefix
(
phon
)
;
std
:
:
string
key
(
sptr
-
>
getKey
(
)
)
;
reverseword
(
key
)
;
prefix
.
append
(
key
)
;
wlst
[
nh
]
.
word
=
mystrdup
(
prefix
.
c_str
(
)
)
;
if
(
!
wlst
[
nh
]
.
word
)
return
nh
-
1
;
wlst
[
nh
]
.
allow
=
false
;
wlst
[
nh
]
.
orig
=
mystrdup
(
newword
.
c_str
(
)
)
;
if
(
!
wlst
[
nh
]
.
orig
)
return
nh
-
1
;
nh
+
+
;
}
}
}
}
sptr
=
sptr
-
>
getFlgNxt
(
)
;
}
}
int
n
=
nh
;
for
(
int
j
=
1
;
j
<
n
;
j
+
+
)
if
(
wlst
[
j
]
.
allow
)
{
for
(
int
k
=
0
;
k
<
al
;
k
+
+
)
{
const
unsigned
char
c
=
(
unsigned
char
)
(
ap
[
k
]
&
0x00FF
)
;
PfxEntry
*
cptr
=
pFlag
[
c
]
;
while
(
cptr
)
{
if
(
(
cptr
-
>
getFlag
(
)
=
=
ap
[
k
]
)
&
&
cptr
-
>
allowCross
(
)
&
&
(
!
cptr
-
>
getKeyLen
(
)
|
|
(
(
badl
>
cptr
-
>
getKeyLen
(
)
)
&
&
(
strncmp
(
cptr
-
>
getKey
(
)
bad
cptr
-
>
getKeyLen
(
)
)
=
=
0
)
)
)
)
{
int
l1
=
strlen
(
wlst
[
j
]
.
word
)
;
std
:
:
string
newword
=
cptr
-
>
add
(
wlst
[
j
]
.
word
l1
)
;
if
(
!
newword
.
empty
(
)
)
{
if
(
nh
<
maxn
)
{
wlst
[
nh
]
.
word
=
mystrdup
(
newword
.
c_str
(
)
)
;
wlst
[
nh
]
.
allow
=
cptr
-
>
allowCross
(
)
;
wlst
[
nh
]
.
orig
=
NULL
;
nh
+
+
;
}
}
}
cptr
=
cptr
-
>
getFlgNxt
(
)
;
}
}
}
for
(
int
m
=
0
;
m
<
al
;
m
+
+
)
{
const
unsigned
char
c
=
(
unsigned
char
)
(
ap
[
m
]
&
0x00FF
)
;
PfxEntry
*
ptr
=
pFlag
[
c
]
;
while
(
ptr
)
{
if
(
(
ptr
-
>
getFlag
(
)
=
=
ap
[
m
]
)
&
&
(
!
ptr
-
>
getKeyLen
(
)
|
|
(
(
badl
>
ptr
-
>
getKeyLen
(
)
)
&
&
(
strncmp
(
ptr
-
>
getKey
(
)
bad
ptr
-
>
getKeyLen
(
)
)
=
=
0
)
)
)
&
&
!
(
ptr
-
>
getCont
(
)
&
&
(
(
needaffix
&
&
TESTAFF
(
ptr
-
>
getCont
(
)
needaffix
ptr
-
>
getContLen
(
)
)
)
|
|
(
circumfix
&
&
TESTAFF
(
ptr
-
>
getCont
(
)
circumfix
ptr
-
>
getContLen
(
)
)
)
|
|
(
onlyincompound
&
&
TESTAFF
(
ptr
-
>
getCont
(
)
onlyincompound
ptr
-
>
getContLen
(
)
)
)
)
)
)
{
std
:
:
string
newword
=
ptr
-
>
add
(
ts
wl
)
;
if
(
!
newword
.
empty
(
)
)
{
if
(
nh
<
maxn
)
{
wlst
[
nh
]
.
word
=
mystrdup
(
newword
.
c_str
(
)
)
;
wlst
[
nh
]
.
allow
=
ptr
-
>
allowCross
(
)
;
wlst
[
nh
]
.
orig
=
NULL
;
nh
+
+
;
}
}
}
ptr
=
ptr
-
>
getFlgNxt
(
)
;
}
}
return
nh
;
}
const
std
:
:
vector
<
replentry
>
&
AffixMgr
:
:
get_reptable
(
)
const
{
return
pHMgr
-
>
get_reptable
(
)
;
}
RepList
*
AffixMgr
:
:
get_iconvtable
(
)
const
{
if
(
!
iconvtable
)
return
NULL
;
return
iconvtable
;
}
RepList
*
AffixMgr
:
:
get_oconvtable
(
)
const
{
if
(
!
oconvtable
)
return
NULL
;
return
oconvtable
;
}
struct
phonetable
*
AffixMgr
:
:
get_phonetable
(
)
const
{
if
(
!
phone
)
return
NULL
;
return
phone
;
}
const
std
:
:
vector
<
mapentry
>
&
AffixMgr
:
:
get_maptable
(
)
const
{
return
maptable
;
}
const
std
:
:
vector
<
std
:
:
string
>
&
AffixMgr
:
:
get_breaktable
(
)
const
{
return
breaktable
;
}
const
std
:
:
string
&
AffixMgr
:
:
get_encoding
(
)
{
if
(
encoding
.
empty
(
)
)
encoding
=
SPELL_ENCODING
;
return
encoding
;
}
int
AffixMgr
:
:
get_langnum
(
)
const
{
return
langnum
;
}
int
AffixMgr
:
:
get_complexprefixes
(
)
const
{
return
complexprefixes
;
}
int
AffixMgr
:
:
get_fullstrip
(
)
const
{
return
fullstrip
;
}
FLAG
AffixMgr
:
:
get_keepcase
(
)
const
{
return
keepcase
;
}
FLAG
AffixMgr
:
:
get_forceucase
(
)
const
{
return
forceucase
;
}
FLAG
AffixMgr
:
:
get_warn
(
)
const
{
return
warn
;
}
int
AffixMgr
:
:
get_forbidwarn
(
)
const
{
return
forbidwarn
;
}
int
AffixMgr
:
:
get_checksharps
(
)
const
{
return
checksharps
;
}
char
*
AffixMgr
:
:
encode_flag
(
unsigned
short
aflag
)
const
{
return
pHMgr
-
>
encode_flag
(
aflag
)
;
}
const
char
*
AffixMgr
:
:
get_ignore
(
)
const
{
if
(
ignorechars
.
empty
(
)
)
return
NULL
;
return
ignorechars
.
c_str
(
)
;
}
const
std
:
:
vector
<
w_char
>
&
AffixMgr
:
:
get_ignore_utf16
(
)
const
{
return
ignorechars_utf16
;
}
char
*
AffixMgr
:
:
get_key_string
(
)
{
if
(
keystring
.
empty
(
)
)
keystring
=
SPELL_KEYSTRING
;
return
mystrdup
(
keystring
.
c_str
(
)
)
;
}
char
*
AffixMgr
:
:
get_try_string
(
)
const
{
if
(
trystring
.
empty
(
)
)
return
NULL
;
return
mystrdup
(
trystring
.
c_str
(
)
)
;
}
const
std
:
:
string
&
AffixMgr
:
:
get_wordchars
(
)
const
{
return
wordchars
;
}
const
std
:
:
vector
<
w_char
>
&
AffixMgr
:
:
get_wordchars_utf16
(
)
const
{
return
wordchars_utf16
;
}
int
AffixMgr
:
:
get_compound
(
)
const
{
return
compoundflag
|
|
compoundbegin
|
|
!
defcpdtable
.
empty
(
)
;
}
FLAG
AffixMgr
:
:
get_compoundflag
(
)
const
{
return
compoundflag
;
}
FLAG
AffixMgr
:
:
get_forbiddenword
(
)
const
{
return
forbiddenword
;
}
FLAG
AffixMgr
:
:
get_nosuggest
(
)
const
{
return
nosuggest
;
}
FLAG
AffixMgr
:
:
get_nongramsuggest
(
)
const
{
return
nongramsuggest
;
}
FLAG
AffixMgr
:
:
get_substandard
(
)
const
{
return
substandard
;
}
FLAG
AffixMgr
:
:
get_needaffix
(
)
const
{
return
needaffix
;
}
FLAG
AffixMgr
:
:
get_onlyincompound
(
)
const
{
return
onlyincompound
;
}
const
std
:
:
string
&
AffixMgr
:
:
get_version
(
)
const
{
return
version
;
}
struct
hentry
*
AffixMgr
:
:
lookup
(
const
char
*
word
)
{
struct
hentry
*
he
=
NULL
;
for
(
size_t
i
=
0
;
i
<
alldic
.
size
(
)
&
&
!
he
;
+
+
i
)
{
he
=
alldic
[
i
]
-
>
lookup
(
word
)
;
}
return
he
;
}
int
AffixMgr
:
:
have_contclass
(
)
const
{
return
havecontclass
;
}
int
AffixMgr
:
:
get_utf8
(
)
const
{
return
utf8
;
}
int
AffixMgr
:
:
get_maxngramsugs
(
void
)
const
{
return
maxngramsugs
;
}
int
AffixMgr
:
:
get_maxcpdsugs
(
void
)
const
{
return
maxcpdsugs
;
}
int
AffixMgr
:
:
get_maxdiff
(
void
)
const
{
return
maxdiff
;
}
int
AffixMgr
:
:
get_onlymaxdiff
(
void
)
const
{
return
onlymaxdiff
;
}
int
AffixMgr
:
:
get_nosplitsugs
(
void
)
const
{
return
nosplitsugs
;
}
int
AffixMgr
:
:
get_sugswithdots
(
void
)
const
{
return
sugswithdots
;
}
bool
AffixMgr
:
:
parse_flag
(
const
std
:
:
string
&
line
unsigned
short
*
out
FileMgr
*
af
)
{
if
(
*
out
!
=
FLAG_NULL
&
&
!
(
*
out
>
=
DEFAULTFLAGS
)
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
multiple
definitions
of
an
affix
file
parameter
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
std
:
:
string
s
;
if
(
!
parse_string
(
line
s
af
-
>
getlinenum
(
)
)
)
return
false
;
*
out
=
pHMgr
-
>
decode_flag
(
s
.
c_str
(
)
)
;
return
true
;
}
bool
AffixMgr
:
:
parse_num
(
const
std
:
:
string
&
line
int
*
out
FileMgr
*
af
)
{
if
(
*
out
!
=
-
1
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
multiple
definitions
of
an
affix
file
parameter
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
std
:
:
string
s
;
if
(
!
parse_string
(
line
s
af
-
>
getlinenum
(
)
)
)
return
false
;
*
out
=
atoi
(
s
.
c_str
(
)
)
;
return
true
;
}
bool
AffixMgr
:
:
parse_cpdsyllable
(
const
std
:
:
string
&
line
FileMgr
*
af
)
{
int
i
=
0
;
int
np
=
0
;
std
:
:
string
:
:
const_iterator
iter
=
line
.
begin
(
)
;
std
:
:
string
:
:
const_iterator
start_piece
=
mystrsep
(
line
iter
)
;
while
(
start_piece
!
=
line
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
np
+
+
;
break
;
}
case
1
:
{
cpdmaxsyllable
=
atoi
(
std
:
:
string
(
start_piece
iter
)
.
c_str
(
)
)
;
np
+
+
;
break
;
}
case
2
:
{
if
(
!
utf8
)
{
cpdvowels
.
assign
(
start_piece
iter
)
;
std
:
:
sort
(
cpdvowels
.
begin
(
)
cpdvowels
.
end
(
)
)
;
}
else
{
std
:
:
string
piece
(
start_piece
iter
)
;
u8_u16
(
cpdvowels_utf16
piece
)
;
std
:
:
sort
(
cpdvowels_utf16
.
begin
(
)
cpdvowels_utf16
.
end
(
)
)
;
}
np
+
+
;
break
;
}
default
:
break
;
}
+
+
i
;
start_piece
=
mystrsep
(
line
iter
)
;
}
if
(
np
<
2
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
missing
compoundsyllable
information
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
if
(
np
=
=
2
)
cpdvowels
=
"
AEIOUaeiou
"
;
return
true
;
}
bool
AffixMgr
:
:
parse_convtable
(
const
std
:
:
string
&
line
FileMgr
*
af
RepList
*
*
rl
const
std
:
:
string
&
keyword
)
{
if
(
*
rl
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
multiple
table
definitions
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
int
i
=
0
;
int
np
=
0
;
int
numrl
=
0
;
std
:
:
string
:
:
const_iterator
iter
=
line
.
begin
(
)
;
std
:
:
string
:
:
const_iterator
start_piece
=
mystrsep
(
line
iter
)
;
while
(
start_piece
!
=
line
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
np
+
+
;
break
;
}
case
1
:
{
numrl
=
atoi
(
std
:
:
string
(
start_piece
iter
)
.
c_str
(
)
)
;
if
(
numrl
<
1
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
incorrect
entry
number
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
*
rl
=
new
RepList
(
numrl
)
;
if
(
!
*
rl
)
return
false
;
np
+
+
;
break
;
}
default
:
break
;
}
+
+
i
;
start_piece
=
mystrsep
(
line
iter
)
;
}
if
(
np
!
=
2
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
missing
data
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
for
(
int
j
=
0
;
j
<
numrl
;
j
+
+
)
{
std
:
:
string
nl
;
if
(
!
af
-
>
getline
(
nl
)
)
return
false
;
mychomp
(
nl
)
;
i
=
0
;
std
:
:
string
pattern
;
std
:
:
string
pattern2
;
iter
=
nl
.
begin
(
)
;
start_piece
=
mystrsep
(
nl
iter
)
;
while
(
start_piece
!
=
nl
.
end
(
)
)
{
{
switch
(
i
)
{
case
0
:
{
if
(
nl
.
compare
(
start_piece
-
nl
.
begin
(
)
keyword
.
size
(
)
keyword
0
keyword
.
size
(
)
)
!
=
0
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
table
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
)
;
delete
*
rl
;
*
rl
=
NULL
;
return
false
;
}
break
;
}
case
1
:
{
pattern
.
assign
(
start_piece
iter
)
;
break
;
}
case
2
:
{
pattern2
.
assign
(
start_piece
iter
)
;
break
;
}
default
:
break
;
}
+
+
i
;
}
start_piece
=
mystrsep
(
nl
iter
)
;
}
if
(
pattern
.
empty
(
)
|
|
pattern2
.
empty
(
)
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
table
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
(
*
rl
)
-
>
add
(
pattern
pattern2
)
;
}
return
true
;
}
bool
AffixMgr
:
:
parse_phonetable
(
const
std
:
:
string
&
line
FileMgr
*
af
)
{
if
(
phone
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
multiple
table
definitions
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
int
num
=
-
1
;
int
i
=
0
;
int
np
=
0
;
std
:
:
string
:
:
const_iterator
iter
=
line
.
begin
(
)
;
std
:
:
string
:
:
const_iterator
start_piece
=
mystrsep
(
line
iter
)
;
while
(
start_piece
!
=
line
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
np
+
+
;
break
;
}
case
1
:
{
num
=
atoi
(
std
:
:
string
(
start_piece
iter
)
.
c_str
(
)
)
;
if
(
num
<
1
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
bad
entry
number
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
phone
=
new
phonetable
;
phone
-
>
utf8
=
(
char
)
utf8
;
np
+
+
;
break
;
}
default
:
break
;
}
+
+
i
;
start_piece
=
mystrsep
(
line
iter
)
;
}
if
(
np
!
=
2
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
missing
data
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
for
(
int
j
=
0
;
j
<
num
;
+
+
j
)
{
std
:
:
string
nl
;
if
(
!
af
-
>
getline
(
nl
)
)
return
false
;
mychomp
(
nl
)
;
i
=
0
;
const
size_t
old_size
=
phone
-
>
rules
.
size
(
)
;
iter
=
nl
.
begin
(
)
;
start_piece
=
mystrsep
(
nl
iter
)
;
while
(
start_piece
!
=
nl
.
end
(
)
)
{
{
switch
(
i
)
{
case
0
:
{
if
(
nl
.
compare
(
start_piece
-
nl
.
begin
(
)
5
"
PHONE
"
5
)
!
=
0
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
table
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
break
;
}
case
1
:
{
phone
-
>
rules
.
push_back
(
std
:
:
string
(
start_piece
iter
)
)
;
break
;
}
case
2
:
{
phone
-
>
rules
.
push_back
(
std
:
:
string
(
start_piece
iter
)
)
;
mystrrep
(
phone
-
>
rules
.
back
(
)
"
_
"
"
"
)
;
break
;
}
default
:
break
;
}
+
+
i
;
}
start_piece
=
mystrsep
(
nl
iter
)
;
}
if
(
phone
-
>
rules
.
size
(
)
!
=
old_size
+
2
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
table
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
)
;
phone
-
>
rules
.
clear
(
)
;
return
false
;
}
}
phone
-
>
rules
.
push_back
(
"
"
)
;
phone
-
>
rules
.
push_back
(
"
"
)
;
init_phonet_hash
(
*
phone
)
;
return
true
;
}
bool
AffixMgr
:
:
parse_checkcpdtable
(
const
std
:
:
string
&
line
FileMgr
*
af
)
{
if
(
parsedcheckcpd
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
multiple
table
definitions
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
parsedcheckcpd
=
true
;
int
numcheckcpd
=
-
1
;
int
i
=
0
;
int
np
=
0
;
std
:
:
string
:
:
const_iterator
iter
=
line
.
begin
(
)
;
std
:
:
string
:
:
const_iterator
start_piece
=
mystrsep
(
line
iter
)
;
while
(
start_piece
!
=
line
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
np
+
+
;
break
;
}
case
1
:
{
numcheckcpd
=
atoi
(
std
:
:
string
(
start_piece
iter
)
.
c_str
(
)
)
;
if
(
numcheckcpd
<
1
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
bad
entry
number
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
checkcpdtable
.
reserve
(
numcheckcpd
)
;
np
+
+
;
break
;
}
default
:
break
;
}
+
+
i
;
start_piece
=
mystrsep
(
line
iter
)
;
}
if
(
np
!
=
2
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
missing
data
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
for
(
int
j
=
0
;
j
<
numcheckcpd
;
+
+
j
)
{
std
:
:
string
nl
;
if
(
!
af
-
>
getline
(
nl
)
)
return
false
;
mychomp
(
nl
)
;
i
=
0
;
checkcpdtable
.
push_back
(
patentry
(
)
)
;
iter
=
nl
.
begin
(
)
;
start_piece
=
mystrsep
(
nl
iter
)
;
while
(
start_piece
!
=
nl
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
if
(
nl
.
compare
(
start_piece
-
nl
.
begin
(
)
20
"
CHECKCOMPOUNDPATTERN
"
20
)
!
=
0
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
table
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
break
;
}
case
1
:
{
checkcpdtable
.
back
(
)
.
pattern
.
assign
(
start_piece
iter
)
;
size_t
slash_pos
=
checkcpdtable
.
back
(
)
.
pattern
.
find
(
'
/
'
)
;
if
(
slash_pos
!
=
std
:
:
string
:
:
npos
)
{
std
:
:
string
chunk
(
checkcpdtable
.
back
(
)
.
pattern
slash_pos
+
1
)
;
checkcpdtable
.
back
(
)
.
pattern
.
resize
(
slash_pos
)
;
checkcpdtable
.
back
(
)
.
cond
=
pHMgr
-
>
decode_flag
(
chunk
.
c_str
(
)
)
;
}
break
;
}
case
2
:
{
checkcpdtable
.
back
(
)
.
pattern2
.
assign
(
start_piece
iter
)
;
size_t
slash_pos
=
checkcpdtable
.
back
(
)
.
pattern2
.
find
(
'
/
'
)
;
if
(
slash_pos
!
=
std
:
:
string
:
:
npos
)
{
std
:
:
string
chunk
(
checkcpdtable
.
back
(
)
.
pattern2
slash_pos
+
1
)
;
checkcpdtable
.
back
(
)
.
pattern2
.
resize
(
slash_pos
)
;
checkcpdtable
.
back
(
)
.
cond2
=
pHMgr
-
>
decode_flag
(
chunk
.
c_str
(
)
)
;
}
break
;
}
case
3
:
{
checkcpdtable
.
back
(
)
.
pattern3
.
assign
(
start_piece
iter
)
;
simplifiedcpd
=
1
;
break
;
}
default
:
break
;
}
i
+
+
;
start_piece
=
mystrsep
(
nl
iter
)
;
}
}
return
true
;
}
bool
AffixMgr
:
:
parse_defcpdtable
(
const
std
:
:
string
&
line
FileMgr
*
af
)
{
if
(
parseddefcpd
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
multiple
table
definitions
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
parseddefcpd
=
true
;
int
numdefcpd
=
-
1
;
int
i
=
0
;
int
np
=
0
;
std
:
:
string
:
:
const_iterator
iter
=
line
.
begin
(
)
;
std
:
:
string
:
:
const_iterator
start_piece
=
mystrsep
(
line
iter
)
;
while
(
start_piece
!
=
line
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
np
+
+
;
break
;
}
case
1
:
{
numdefcpd
=
atoi
(
std
:
:
string
(
start_piece
iter
)
.
c_str
(
)
)
;
if
(
numdefcpd
<
1
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
bad
entry
number
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
defcpdtable
.
reserve
(
numdefcpd
)
;
np
+
+
;
break
;
}
default
:
break
;
}
+
+
i
;
start_piece
=
mystrsep
(
line
iter
)
;
}
if
(
np
!
=
2
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
missing
data
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
for
(
int
j
=
0
;
j
<
numdefcpd
;
+
+
j
)
{
std
:
:
string
nl
;
if
(
!
af
-
>
getline
(
nl
)
)
return
false
;
mychomp
(
nl
)
;
i
=
0
;
defcpdtable
.
push_back
(
flagentry
(
)
)
;
iter
=
nl
.
begin
(
)
;
start_piece
=
mystrsep
(
nl
iter
)
;
while
(
start_piece
!
=
nl
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
if
(
nl
.
compare
(
start_piece
-
nl
.
begin
(
)
12
"
COMPOUNDRULE
"
12
)
!
=
0
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
table
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
)
;
numdefcpd
=
0
;
return
false
;
}
break
;
}
case
1
:
{
if
(
std
:
:
find
(
start_piece
iter
'
(
'
)
!
=
iter
)
{
for
(
std
:
:
string
:
:
const_iterator
k
=
start_piece
;
k
!
=
iter
;
+
+
k
)
{
std
:
:
string
:
:
const_iterator
chb
=
k
;
std
:
:
string
:
:
const_iterator
che
=
k
+
1
;
if
(
*
k
=
=
'
(
'
)
{
std
:
:
string
:
:
const_iterator
parpos
=
std
:
:
find
(
k
iter
'
)
'
)
;
if
(
parpos
!
=
iter
)
{
chb
=
k
+
1
;
che
=
parpos
;
k
=
parpos
;
}
}
if
(
*
chb
=
=
'
*
'
|
|
*
chb
=
=
'
?
'
)
{
defcpdtable
.
back
(
)
.
push_back
(
(
FLAG
)
*
chb
)
;
}
else
{
pHMgr
-
>
decode_flags
(
defcpdtable
.
back
(
)
std
:
:
string
(
chb
che
)
af
)
;
}
}
}
else
{
pHMgr
-
>
decode_flags
(
defcpdtable
.
back
(
)
std
:
:
string
(
start_piece
iter
)
af
)
;
}
break
;
}
default
:
break
;
}
+
+
i
;
start_piece
=
mystrsep
(
nl
iter
)
;
}
if
(
defcpdtable
.
back
(
)
.
empty
(
)
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
table
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
}
return
true
;
}
bool
AffixMgr
:
:
parse_maptable
(
const
std
:
:
string
&
line
FileMgr
*
af
)
{
if
(
parsedmaptable
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
multiple
table
definitions
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
parsedmaptable
=
true
;
int
nummap
=
-
1
;
int
i
=
0
;
int
np
=
0
;
std
:
:
string
:
:
const_iterator
iter
=
line
.
begin
(
)
;
std
:
:
string
:
:
const_iterator
start_piece
=
mystrsep
(
line
iter
)
;
while
(
start_piece
!
=
line
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
np
+
+
;
break
;
}
case
1
:
{
nummap
=
atoi
(
std
:
:
string
(
start_piece
iter
)
.
c_str
(
)
)
;
if
(
nummap
<
1
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
bad
entry
number
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
maptable
.
reserve
(
nummap
)
;
np
+
+
;
break
;
}
default
:
break
;
}
+
+
i
;
start_piece
=
mystrsep
(
line
iter
)
;
}
if
(
np
!
=
2
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
missing
data
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
for
(
int
j
=
0
;
j
<
nummap
;
+
+
j
)
{
std
:
:
string
nl
;
if
(
!
af
-
>
getline
(
nl
)
)
return
false
;
mychomp
(
nl
)
;
i
=
0
;
maptable
.
push_back
(
mapentry
(
)
)
;
iter
=
nl
.
begin
(
)
;
start_piece
=
mystrsep
(
nl
iter
)
;
while
(
start_piece
!
=
nl
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
if
(
nl
.
compare
(
start_piece
-
nl
.
begin
(
)
3
"
MAP
"
3
)
!
=
0
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
table
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
)
;
nummap
=
0
;
return
false
;
}
break
;
}
case
1
:
{
for
(
std
:
:
string
:
:
const_iterator
k
=
start_piece
;
k
!
=
iter
;
+
+
k
)
{
std
:
:
string
:
:
const_iterator
chb
=
k
;
std
:
:
string
:
:
const_iterator
che
=
k
+
1
;
if
(
*
k
=
=
'
(
'
)
{
std
:
:
string
:
:
const_iterator
parpos
=
std
:
:
find
(
k
iter
'
)
'
)
;
if
(
parpos
!
=
iter
)
{
chb
=
k
+
1
;
che
=
parpos
;
k
=
parpos
;
}
}
else
{
if
(
utf8
&
&
(
*
k
&
0xc0
)
=
=
0xc0
)
{
+
+
k
;
while
(
k
!
=
iter
&
&
(
*
k
&
0xc0
)
=
=
0x80
)
+
+
k
;
che
=
k
;
-
-
k
;
}
}
maptable
.
back
(
)
.
push_back
(
std
:
:
string
(
chb
che
)
)
;
}
break
;
}
default
:
break
;
}
+
+
i
;
start_piece
=
mystrsep
(
nl
iter
)
;
}
if
(
maptable
.
back
(
)
.
empty
(
)
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
table
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
}
return
true
;
}
bool
AffixMgr
:
:
parse_breaktable
(
const
std
:
:
string
&
line
FileMgr
*
af
)
{
if
(
parsedbreaktable
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
multiple
table
definitions
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
parsedbreaktable
=
true
;
int
numbreak
=
-
1
;
int
i
=
0
;
int
np
=
0
;
std
:
:
string
:
:
const_iterator
iter
=
line
.
begin
(
)
;
std
:
:
string
:
:
const_iterator
start_piece
=
mystrsep
(
line
iter
)
;
while
(
start_piece
!
=
line
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
np
+
+
;
break
;
}
case
1
:
{
numbreak
=
atoi
(
std
:
:
string
(
start_piece
iter
)
.
c_str
(
)
)
;
if
(
numbreak
<
0
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
bad
entry
number
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
if
(
numbreak
=
=
0
)
return
true
;
breaktable
.
reserve
(
numbreak
)
;
np
+
+
;
break
;
}
default
:
break
;
}
+
+
i
;
start_piece
=
mystrsep
(
line
iter
)
;
}
if
(
np
!
=
2
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
missing
data
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
for
(
int
j
=
0
;
j
<
numbreak
;
+
+
j
)
{
std
:
:
string
nl
;
if
(
!
af
-
>
getline
(
nl
)
)
return
false
;
mychomp
(
nl
)
;
i
=
0
;
iter
=
nl
.
begin
(
)
;
start_piece
=
mystrsep
(
nl
iter
)
;
while
(
start_piece
!
=
nl
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
if
(
nl
.
compare
(
start_piece
-
nl
.
begin
(
)
5
"
BREAK
"
5
)
!
=
0
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
table
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
)
;
numbreak
=
0
;
return
false
;
}
break
;
}
case
1
:
{
breaktable
.
push_back
(
std
:
:
string
(
start_piece
iter
)
)
;
break
;
}
default
:
break
;
}
+
+
i
;
start_piece
=
mystrsep
(
nl
iter
)
;
}
}
if
(
breaktable
.
size
(
)
!
=
static_cast
<
size_t
>
(
numbreak
)
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
table
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
)
;
return
false
;
}
return
true
;
}
void
AffixMgr
:
:
reverse_condition
(
std
:
:
string
&
piece
)
{
if
(
piece
.
empty
(
)
)
return
;
int
neg
=
0
;
for
(
std
:
:
string
:
:
reverse_iterator
k
=
piece
.
rbegin
(
)
;
k
!
=
piece
.
rend
(
)
;
+
+
k
)
{
switch
(
*
k
)
{
case
'
[
'
:
{
if
(
neg
)
*
(
k
-
1
)
=
'
[
'
;
else
*
k
=
'
]
'
;
break
;
}
case
'
]
'
:
{
*
k
=
'
[
'
;
if
(
neg
)
*
(
k
-
1
)
=
'
^
'
;
neg
=
0
;
break
;
}
case
'
^
'
:
{
if
(
*
(
k
-
1
)
=
=
'
]
'
)
neg
=
1
;
else
*
(
k
-
1
)
=
*
k
;
break
;
}
default
:
{
if
(
neg
)
*
(
k
-
1
)
=
*
k
;
}
}
}
}
class
entries_container
{
std
:
:
vector
<
AffEntry
*
>
entries
;
AffixMgr
*
m_mgr
;
char
m_at
;
public
:
entries_container
(
char
at
AffixMgr
*
mgr
)
:
m_mgr
(
mgr
)
m_at
(
at
)
{
}
void
release
(
)
{
entries
.
clear
(
)
;
}
void
initialize
(
int
numents
char
opts
unsigned
short
aflag
)
{
entries
.
reserve
(
numents
)
;
if
(
m_at
=
=
'
P
'
)
{
entries
.
push_back
(
new
PfxEntry
(
m_mgr
)
)
;
}
else
{
entries
.
push_back
(
new
SfxEntry
(
m_mgr
)
)
;
}
entries
.
back
(
)
-
>
opts
=
opts
;
entries
.
back
(
)
-
>
aflag
=
aflag
;
}
AffEntry
*
add_entry
(
char
opts
)
{
if
(
m_at
=
=
'
P
'
)
{
entries
.
push_back
(
new
PfxEntry
(
m_mgr
)
)
;
}
else
{
entries
.
push_back
(
new
SfxEntry
(
m_mgr
)
)
;
}
AffEntry
*
ret
=
entries
.
back
(
)
;
ret
-
>
opts
=
entries
[
0
]
-
>
opts
&
opts
;
return
ret
;
}
AffEntry
*
first_entry
(
)
{
return
entries
.
empty
(
)
?
NULL
:
entries
[
0
]
;
}
~
entries_container
(
)
{
for
(
size_t
i
=
0
;
i
<
entries
.
size
(
)
;
+
+
i
)
{
delete
entries
[
i
]
;
}
}
std
:
:
vector
<
AffEntry
*
>
:
:
iterator
begin
(
)
{
return
entries
.
begin
(
)
;
}
std
:
:
vector
<
AffEntry
*
>
:
:
iterator
end
(
)
{
return
entries
.
end
(
)
;
}
}
;
bool
AffixMgr
:
:
parse_affix
(
const
std
:
:
string
&
line
const
char
at
FileMgr
*
af
char
*
dupflags
)
{
int
numents
=
0
;
unsigned
short
aflag
=
0
;
char
ff
=
0
;
entries_container
affentries
(
at
this
)
;
int
i
=
0
;
#
ifdef
DEBUG
int
basefieldnum
=
0
;
#
endif
int
np
=
0
;
std
:
:
string
:
:
const_iterator
iter
=
line
.
begin
(
)
;
std
:
:
string
:
:
const_iterator
start_piece
=
mystrsep
(
line
iter
)
;
while
(
start_piece
!
=
line
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
np
+
+
;
break
;
}
case
1
:
{
np
+
+
;
aflag
=
pHMgr
-
>
decode_flag
(
std
:
:
string
(
start_piece
iter
)
.
c_str
(
)
)
;
if
(
(
(
at
=
=
'
S
'
)
&
&
(
dupflags
[
aflag
]
&
dupSFX
)
)
|
|
(
(
at
=
=
'
P
'
)
&
&
(
dupflags
[
aflag
]
&
dupPFX
)
)
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
multiple
definitions
of
an
affix
flag
\
n
"
af
-
>
getlinenum
(
)
)
;
}
dupflags
[
aflag
]
+
=
(
char
)
(
(
at
=
=
'
S
'
)
?
dupSFX
:
dupPFX
)
;
break
;
}
case
2
:
{
np
+
+
;
if
(
*
start_piece
=
=
'
Y
'
)
ff
=
aeXPRODUCT
;
break
;
}
case
3
:
{
np
+
+
;
numents
=
atoi
(
std
:
:
string
(
start_piece
iter
)
.
c_str
(
)
)
;
if
(
(
numents
<
=
0
)
|
|
(
(
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
/
sizeof
(
AffEntry
)
)
<
static_cast
<
size_t
>
(
numents
)
)
)
{
char
*
err
=
pHMgr
-
>
encode_flag
(
aflag
)
;
if
(
err
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
bad
entry
number
\
n
"
af
-
>
getlinenum
(
)
)
;
free
(
err
)
;
}
return
false
;
}
char
opts
=
ff
;
if
(
utf8
)
opts
+
=
aeUTF8
;
if
(
pHMgr
-
>
is_aliasf
(
)
)
opts
+
=
aeALIASF
;
if
(
pHMgr
-
>
is_aliasm
(
)
)
opts
+
=
aeALIASM
;
affentries
.
initialize
(
numents
opts
aflag
)
;
}
default
:
break
;
}
+
+
i
;
start_piece
=
mystrsep
(
line
iter
)
;
}
if
(
np
!
=
4
)
{
char
*
err
=
pHMgr
-
>
encode_flag
(
aflag
)
;
if
(
err
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
missing
data
\
n
"
af
-
>
getlinenum
(
)
)
;
free
(
err
)
;
}
return
false
;
}
AffEntry
*
entry
=
affentries
.
first_entry
(
)
;
for
(
int
ent
=
0
;
ent
<
numents
;
+
+
ent
)
{
std
:
:
string
nl
;
if
(
!
af
-
>
getline
(
nl
)
)
return
false
;
mychomp
(
nl
)
;
iter
=
nl
.
begin
(
)
;
i
=
0
;
np
=
0
;
start_piece
=
mystrsep
(
nl
iter
)
;
while
(
start_piece
!
=
nl
.
end
(
)
)
{
switch
(
i
)
{
case
0
:
{
np
+
+
;
if
(
ent
!
=
0
)
entry
=
affentries
.
add_entry
(
(
char
)
(
aeXPRODUCT
+
aeUTF8
+
aeALIASF
+
aeALIASM
)
)
;
break
;
}
case
1
:
{
np
+
+
;
std
:
:
string
chunk
(
start_piece
iter
)
;
if
(
pHMgr
-
>
decode_flag
(
chunk
.
c_str
(
)
)
!
=
aflag
)
{
char
*
err
=
pHMgr
-
>
encode_flag
(
aflag
)
;
if
(
err
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
affix
%
s
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
err
)
;
free
(
err
)
;
}
return
false
;
}
if
(
ent
!
=
0
)
{
AffEntry
*
start_entry
=
affentries
.
first_entry
(
)
;
entry
-
>
aflag
=
start_entry
-
>
aflag
;
}
break
;
}
case
2
:
{
np
+
+
;
entry
-
>
strip
=
std
:
:
string
(
start_piece
iter
)
;
if
(
complexprefixes
)
{
if
(
utf8
)
reverseword_utf
(
entry
-
>
strip
)
;
else
reverseword
(
entry
-
>
strip
)
;
}
if
(
entry
-
>
strip
.
compare
(
"
0
"
)
=
=
0
)
{
entry
-
>
strip
.
clear
(
)
;
}
break
;
}
case
3
:
{
entry
-
>
morphcode
=
NULL
;
entry
-
>
contclass
=
NULL
;
entry
-
>
contclasslen
=
0
;
np
+
+
;
std
:
:
string
:
:
const_iterator
dash
=
std
:
:
find
(
start_piece
iter
'
/
'
)
;
if
(
dash
!
=
iter
)
{
entry
-
>
appnd
=
std
:
:
string
(
start_piece
dash
)
;
std
:
:
string
dash_str
(
dash
+
1
iter
)
;
if
(
!
ignorechars
.
empty
(
)
&
&
!
has_no_ignored_chars
(
entry
-
>
appnd
ignorechars
)
)
{
if
(
utf8
)
{
remove_ignored_chars_utf
(
entry
-
>
appnd
ignorechars_utf16
)
;
}
else
{
remove_ignored_chars
(
entry
-
>
appnd
ignorechars
)
;
}
}
if
(
complexprefixes
)
{
if
(
utf8
)
reverseword_utf
(
entry
-
>
appnd
)
;
else
reverseword
(
entry
-
>
appnd
)
;
}
if
(
pHMgr
-
>
is_aliasf
(
)
)
{
int
index
=
atoi
(
dash_str
.
c_str
(
)
)
;
entry
-
>
contclasslen
=
(
unsigned
short
)
pHMgr
-
>
get_aliasf
(
index
&
(
entry
-
>
contclass
)
af
)
;
if
(
!
entry
-
>
contclasslen
)
HUNSPELL_WARNING
(
stderr
"
error
:
bad
affix
flag
alias
:
\
"
%
s
\
"
\
n
"
dash_str
.
c_str
(
)
)
;
}
else
{
entry
-
>
contclasslen
=
(
unsigned
short
)
pHMgr
-
>
decode_flags
(
&
(
entry
-
>
contclass
)
dash_str
.
c_str
(
)
af
)
;
std
:
:
sort
(
entry
-
>
contclass
entry
-
>
contclass
+
entry
-
>
contclasslen
)
;
}
havecontclass
=
1
;
for
(
unsigned
short
_i
=
0
;
_i
<
entry
-
>
contclasslen
;
_i
+
+
)
{
contclasses
[
(
entry
-
>
contclass
)
[
_i
]
]
=
1
;
}
}
else
{
entry
-
>
appnd
=
std
:
:
string
(
start_piece
iter
)
;
if
(
!
ignorechars
.
empty
(
)
&
&
!
has_no_ignored_chars
(
entry
-
>
appnd
ignorechars
)
)
{
if
(
utf8
)
{
remove_ignored_chars_utf
(
entry
-
>
appnd
ignorechars_utf16
)
;
}
else
{
remove_ignored_chars
(
entry
-
>
appnd
ignorechars
)
;
}
}
if
(
complexprefixes
)
{
if
(
utf8
)
reverseword_utf
(
entry
-
>
appnd
)
;
else
reverseword
(
entry
-
>
appnd
)
;
}
}
if
(
entry
-
>
appnd
.
compare
(
"
0
"
)
=
=
0
)
{
entry
-
>
appnd
.
clear
(
)
;
}
break
;
}
case
4
:
{
std
:
:
string
chunk
(
start_piece
iter
)
;
np
+
+
;
if
(
complexprefixes
)
{
if
(
utf8
)
reverseword_utf
(
chunk
)
;
else
reverseword
(
chunk
)
;
reverse_condition
(
chunk
)
;
}
if
(
!
entry
-
>
strip
.
empty
(
)
&
&
chunk
!
=
"
.
"
&
&
redundant_condition
(
at
entry
-
>
strip
.
c_str
(
)
entry
-
>
strip
.
size
(
)
chunk
.
c_str
(
)
af
-
>
getlinenum
(
)
)
)
chunk
=
"
.
"
;
if
(
at
=
=
'
S
'
)
{
reverseword
(
chunk
)
;
reverse_condition
(
chunk
)
;
}
if
(
encodeit
(
*
entry
chunk
.
c_str
(
)
)
)
return
false
;
break
;
}
case
5
:
{
std
:
:
string
chunk
(
start_piece
iter
)
;
np
+
+
;
if
(
pHMgr
-
>
is_aliasm
(
)
)
{
int
index
=
atoi
(
chunk
.
c_str
(
)
)
;
entry
-
>
morphcode
=
pHMgr
-
>
get_aliasm
(
index
)
;
}
else
{
if
(
complexprefixes
)
{
if
(
utf8
)
reverseword_utf
(
chunk
)
;
else
reverseword
(
chunk
)
;
}
std
:
:
string
:
:
const_iterator
end
=
nl
.
end
(
)
;
if
(
iter
!
=
end
)
{
chunk
.
append
(
iter
end
)
;
}
entry
-
>
morphcode
=
mystrdup
(
chunk
.
c_str
(
)
)
;
if
(
!
entry
-
>
morphcode
)
return
false
;
}
break
;
}
default
:
break
;
}
i
+
+
;
start_piece
=
mystrsep
(
nl
iter
)
;
}
if
(
np
<
4
)
{
char
*
err
=
pHMgr
-
>
encode_flag
(
aflag
)
;
if
(
err
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
affix
%
s
is
corrupt
\
n
"
af
-
>
getlinenum
(
)
err
)
;
free
(
err
)
;
}
return
false
;
}
#
ifdef
DEBUG
if
(
basefieldnum
)
{
int
fieldnum
=
!
(
entry
-
>
morphcode
)
?
5
:
(
(
*
(
entry
-
>
morphcode
)
=
=
'
#
'
)
?
5
:
6
)
;
if
(
fieldnum
!
=
basefieldnum
)
HUNSPELL_WARNING
(
stderr
"
warning
:
line
%
d
:
bad
field
number
\
n
"
af
-
>
getlinenum
(
)
)
;
}
else
{
basefieldnum
=
!
(
entry
-
>
morphcode
)
?
5
:
(
(
*
(
entry
-
>
morphcode
)
=
=
'
#
'
)
?
5
:
6
)
;
}
#
endif
}
std
:
:
vector
<
AffEntry
*
>
:
:
iterator
start
=
affentries
.
begin
(
)
;
std
:
:
vector
<
AffEntry
*
>
:
:
iterator
end
=
affentries
.
end
(
)
;
for
(
std
:
:
vector
<
AffEntry
*
>
:
:
iterator
affentry
=
start
;
affentry
!
=
end
;
+
+
affentry
)
{
if
(
at
=
=
'
P
'
)
{
build_pfxtree
(
static_cast
<
PfxEntry
*
>
(
*
affentry
)
)
;
}
else
{
build_sfxtree
(
static_cast
<
SfxEntry
*
>
(
*
affentry
)
)
;
}
}
affentries
.
release
(
)
;
return
true
;
}
int
AffixMgr
:
:
redundant_condition
(
char
ft
const
char
*
strip
int
stripl
const
char
*
cond
int
linenum
)
{
int
condl
=
strlen
(
cond
)
;
int
i
;
int
j
;
int
neg
;
int
in
;
if
(
ft
=
=
'
P
'
)
{
if
(
strncmp
(
strip
cond
condl
)
=
=
0
)
return
1
;
if
(
utf8
)
{
}
else
{
for
(
i
=
0
j
=
0
;
(
i
<
stripl
)
&
&
(
j
<
condl
)
;
i
+
+
j
+
+
)
{
if
(
cond
[
j
]
!
=
'
[
'
)
{
if
(
cond
[
j
]
!
=
strip
[
i
]
)
{
HUNSPELL_WARNING
(
stderr
"
warning
:
line
%
d
:
incompatible
stripping
"
"
characters
and
condition
\
n
"
linenum
)
;
return
0
;
}
}
else
{
neg
=
(
cond
[
j
+
1
]
=
=
'
^
'
)
?
1
:
0
;
in
=
0
;
do
{
j
+
+
;
if
(
strip
[
i
]
=
=
cond
[
j
]
)
in
=
1
;
}
while
(
(
j
<
(
condl
-
1
)
)
&
&
(
cond
[
j
]
!
=
'
]
'
)
)
;
if
(
j
=
=
(
condl
-
1
)
&
&
(
cond
[
j
]
!
=
'
]
'
)
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
%
d
:
missing
]
in
condition
:
\
n
%
s
\
n
"
linenum
cond
)
;
return
0
;
}
if
(
(
!
neg
&
&
!
in
)
|
|
(
neg
&
&
in
)
)
{
HUNSPELL_WARNING
(
stderr
"
warning
:
line
%
d
:
incompatible
stripping
"
"
characters
and
condition
\
n
"
linenum
)
;
return
0
;
}
}
}
if
(
j
>
=
condl
)
return
1
;
}
}
else
{
if
(
(
stripl
>
=
condl
)
&
&
strcmp
(
strip
+
stripl
-
condl
cond
)
=
=
0
)
return
1
;
if
(
utf8
)
{
}
else
{
for
(
i
=
stripl
-
1
j
=
condl
-
1
;
(
i
>
=
0
)
&
&
(
j
>
=
0
)
;
i
-
-
j
-
-
)
{
if
(
cond
[
j
]
!
=
'
]
'
)
{
if
(
cond
[
j
]
!
=
strip
[
i
]
)
{
HUNSPELL_WARNING
(
stderr
"
warning
:
line
%
d
:
incompatible
stripping
"
"
characters
and
condition
\
n
"
linenum
)
;
return
0
;
}
}
else
{
in
=
0
;
do
{
j
-
-
;
if
(
strip
[
i
]
=
=
cond
[
j
]
)
in
=
1
;
}
while
(
(
j
>
0
)
&
&
(
cond
[
j
]
!
=
'
[
'
)
)
;
if
(
(
j
=
=
0
)
&
&
(
cond
[
j
]
!
=
'
[
'
)
)
{
HUNSPELL_WARNING
(
stderr
"
error
:
line
:
%
d
:
missing
]
in
condition
:
\
n
%
s
\
n
"
linenum
cond
)
;
return
0
;
}
neg
=
(
cond
[
j
+
1
]
=
=
'
^
'
)
?
1
:
0
;
if
(
(
!
neg
&
&
!
in
)
|
|
(
neg
&
&
in
)
)
{
HUNSPELL_WARNING
(
stderr
"
warning
:
line
%
d
:
incompatible
stripping
"
"
characters
and
condition
\
n
"
linenum
)
;
return
0
;
}
}
}
if
(
j
<
0
)
return
1
;
}
}
return
0
;
}
std
:
:
vector
<
std
:
:
string
>
AffixMgr
:
:
get_suffix_words
(
short
unsigned
*
suff
int
len
const
char
*
root_word
)
{
std
:
:
vector
<
std
:
:
string
>
slst
;
short
unsigned
*
start_ptr
=
suff
;
for
(
int
j
=
0
;
j
<
SETSIZE
;
j
+
+
)
{
SfxEntry
*
ptr
=
sStart
[
j
]
;
while
(
ptr
)
{
suff
=
start_ptr
;
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
(
*
suff
)
=
=
ptr
-
>
getFlag
(
)
)
{
std
:
:
string
nw
(
root_word
)
;
nw
.
append
(
ptr
-
>
getAffix
(
)
)
;
hentry
*
ht
=
ptr
-
>
checkword
(
nw
.
c_str
(
)
nw
.
size
(
)
0
NULL
0
0
0
)
;
if
(
ht
)
{
slst
.
push_back
(
nw
)
;
}
}
suff
+
+
;
}
ptr
=
ptr
-
>
getNext
(
)
;
}
}
return
slst
;
}
