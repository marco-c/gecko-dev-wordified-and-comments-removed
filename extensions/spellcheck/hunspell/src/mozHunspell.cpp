#
include
"
mozHunspell
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsXPIDLString
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIDirectoryEnumerator
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
mozISpellI18NManager
.
h
"
#
include
"
nsICharsetConverterManager
.
h
"
#
include
"
nsUnicharUtilCIID
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
mozInlineSpellChecker
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
<
stdlib
.
h
>
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIPrefBranch
.
h
"
static
NS_DEFINE_CID
(
kCharsetConverterManagerCID
NS_ICHARSETCONVERTERMANAGER_CID
)
;
static
NS_DEFINE_CID
(
kUnicharUtilCID
NS_UNICHARUTIL_CID
)
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
mozHunspell
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
mozHunspell
)
NS_INTERFACE_MAP_BEGIN
(
mozHunspell
)
NS_INTERFACE_MAP_ENTRY
(
mozISpellCheckingEngine
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
mozISpellCheckingEngine
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
mozHunspell
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_3
(
mozHunspell
mPersonalDictionary
mEncoder
mDecoder
)
class
SpellCheckReporter
MOZ_FINAL
:
public
mozilla
:
:
MemoryReporterBase
{
public
:
SpellCheckReporter
(
)
:
MemoryReporterBase
(
"
explicit
/
spell
-
check
"
KIND_HEAP
UNITS_BYTES
"
Memory
used
by
the
Hunspell
spell
checking
engine
'
s
internal
data
structures
.
"
)
{
#
ifdef
DEBUG
static
bool
hasRun
=
false
;
MOZ_ASSERT
(
!
hasRun
)
;
hasRun
=
true
;
#
endif
}
static
void
OnAlloc
(
void
*
ptr
)
{
sAmount
+
=
MallocSizeOfOnAlloc
(
ptr
)
;
}
static
void
OnFree
(
void
*
ptr
)
{
sAmount
-
=
MallocSizeOfOnFree
(
ptr
)
;
}
private
:
int64_t
Amount
(
)
MOZ_OVERRIDE
{
return
sAmount
;
}
static
int64_t
sAmount
;
}
;
int64_t
SpellCheckReporter
:
:
sAmount
=
0
;
void
HunspellReportMemoryAllocation
(
void
*
ptr
)
{
SpellCheckReporter
:
:
OnAlloc
(
ptr
)
;
}
void
HunspellReportMemoryDeallocation
(
void
*
ptr
)
{
SpellCheckReporter
:
:
OnFree
(
ptr
)
;
}
nsresult
mozHunspell
:
:
Init
(
)
{
mDictionaries
.
Init
(
)
;
LoadDictionaryList
(
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
this
"
profile
-
do
-
change
"
true
)
;
obs
-
>
AddObserver
(
this
"
profile
-
after
-
change
"
true
)
;
}
mReporter
=
new
SpellCheckReporter
(
)
;
NS_RegisterMemoryReporter
(
mReporter
)
;
return
NS_OK
;
}
mozHunspell
:
:
~
mozHunspell
(
)
{
NS_UnregisterMemoryReporter
(
mReporter
)
;
mPersonalDictionary
=
nullptr
;
delete
mHunspell
;
}
NS_IMETHODIMP
mozHunspell
:
:
GetDictionary
(
PRUnichar
*
*
aDictionary
)
{
NS_ENSURE_ARG_POINTER
(
aDictionary
)
;
*
aDictionary
=
ToNewUnicode
(
mDictionary
)
;
return
*
aDictionary
?
NS_OK
:
NS_ERROR_OUT_OF_MEMORY
;
}
NS_IMETHODIMP
mozHunspell
:
:
SetDictionary
(
const
PRUnichar
*
aDictionary
)
{
NS_ENSURE_ARG_POINTER
(
aDictionary
)
;
if
(
nsDependentString
(
aDictionary
)
.
IsEmpty
(
)
)
{
delete
mHunspell
;
mHunspell
=
nullptr
;
mDictionary
.
AssignLiteral
(
"
"
)
;
mAffixFileName
.
AssignLiteral
(
"
"
)
;
mLanguage
.
AssignLiteral
(
"
"
)
;
mDecoder
=
nullptr
;
mEncoder
=
nullptr
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
SPELLCHECK_DICTIONARY_UPDATE_NOTIFICATION
nullptr
)
;
}
return
NS_OK
;
}
nsIFile
*
affFile
=
mDictionaries
.
GetWeak
(
nsDependentString
(
aDictionary
)
)
;
if
(
!
affFile
)
return
NS_ERROR_FILE_NOT_FOUND
;
nsAutoCString
dictFileName
affFileName
;
nsresult
rv
=
affFile
-
>
GetNativePath
(
affFileName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mAffixFileName
.
Equals
(
affFileName
.
get
(
)
)
)
return
NS_OK
;
dictFileName
=
affFileName
;
int32_t
dotPos
=
dictFileName
.
RFindChar
(
'
.
'
)
;
if
(
dotPos
=
=
-
1
)
return
NS_ERROR_FAILURE
;
dictFileName
.
SetLength
(
dotPos
)
;
dictFileName
.
AppendLiteral
(
"
.
dic
"
)
;
delete
mHunspell
;
mDictionary
=
aDictionary
;
mAffixFileName
=
affFileName
;
mHunspell
=
new
Hunspell
(
affFileName
.
get
(
)
dictFileName
.
get
(
)
)
;
if
(
!
mHunspell
)
return
NS_ERROR_OUT_OF_MEMORY
;
nsCOMPtr
<
nsICharsetConverterManager
>
ccm
=
do_GetService
(
NS_CHARSETCONVERTERMANAGER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ccm
-
>
GetUnicodeDecoder
(
mHunspell
-
>
get_dic_encoding
(
)
getter_AddRefs
(
mDecoder
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ccm
-
>
GetUnicodeEncoder
(
mHunspell
-
>
get_dic_encoding
(
)
getter_AddRefs
(
mEncoder
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mEncoder
)
mEncoder
-
>
SetOutputErrorBehavior
(
mEncoder
-
>
kOnError_Signal
nullptr
'
?
'
)
;
int32_t
pos
=
mDictionary
.
FindChar
(
'
-
'
)
;
if
(
pos
=
=
-
1
)
pos
=
mDictionary
.
FindChar
(
'
_
'
)
;
if
(
pos
=
=
-
1
)
mLanguage
.
Assign
(
mDictionary
)
;
else
mLanguage
=
Substring
(
mDictionary
0
pos
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
SPELLCHECK_DICTIONARY_UPDATE_NOTIFICATION
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
mozHunspell
:
:
GetLanguage
(
PRUnichar
*
*
aLanguage
)
{
NS_ENSURE_ARG_POINTER
(
aLanguage
)
;
if
(
mDictionary
.
IsEmpty
(
)
)
return
NS_ERROR_NOT_INITIALIZED
;
*
aLanguage
=
ToNewUnicode
(
mLanguage
)
;
return
*
aLanguage
?
NS_OK
:
NS_ERROR_OUT_OF_MEMORY
;
}
NS_IMETHODIMP
mozHunspell
:
:
GetProvidesPersonalDictionary
(
bool
*
aProvidesPersonalDictionary
)
{
NS_ENSURE_ARG_POINTER
(
aProvidesPersonalDictionary
)
;
*
aProvidesPersonalDictionary
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
mozHunspell
:
:
GetProvidesWordUtils
(
bool
*
aProvidesWordUtils
)
{
NS_ENSURE_ARG_POINTER
(
aProvidesWordUtils
)
;
*
aProvidesWordUtils
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
mozHunspell
:
:
GetName
(
PRUnichar
*
*
aName
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
mozHunspell
:
:
GetCopyright
(
PRUnichar
*
*
aCopyright
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
mozHunspell
:
:
GetPersonalDictionary
(
mozIPersonalDictionary
*
*
aPersonalDictionary
)
{
*
aPersonalDictionary
=
mPersonalDictionary
;
NS_IF_ADDREF
(
*
aPersonalDictionary
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozHunspell
:
:
SetPersonalDictionary
(
mozIPersonalDictionary
*
aPersonalDictionary
)
{
mPersonalDictionary
=
aPersonalDictionary
;
return
NS_OK
;
}
struct
AppendNewStruct
{
PRUnichar
*
*
dics
;
uint32_t
count
;
bool
failed
;
}
;
static
PLDHashOperator
AppendNewString
(
const
nsAString
&
aString
nsIFile
*
aFile
void
*
aClosure
)
{
AppendNewStruct
*
ans
=
(
AppendNewStruct
*
)
aClosure
;
ans
-
>
dics
[
ans
-
>
count
]
=
ToNewUnicode
(
aString
)
;
if
(
!
ans
-
>
dics
[
ans
-
>
count
]
)
{
ans
-
>
failed
=
true
;
return
PL_DHASH_STOP
;
}
+
+
ans
-
>
count
;
return
PL_DHASH_NEXT
;
}
NS_IMETHODIMP
mozHunspell
:
:
GetDictionaryList
(
PRUnichar
*
*
*
aDictionaries
uint32_t
*
aCount
)
{
if
(
!
aDictionaries
|
|
!
aCount
)
return
NS_ERROR_NULL_POINTER
;
AppendNewStruct
ans
=
{
(
PRUnichar
*
*
)
NS_Alloc
(
sizeof
(
PRUnichar
*
)
*
mDictionaries
.
Count
(
)
)
0
false
}
;
mDictionaries
.
EnumerateRead
(
AppendNewString
&
ans
)
;
if
(
ans
.
failed
)
{
while
(
ans
.
count
)
{
-
-
ans
.
count
;
NS_Free
(
ans
.
dics
[
ans
.
count
]
)
;
}
NS_Free
(
ans
.
dics
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
*
aDictionaries
=
ans
.
dics
;
*
aCount
=
ans
.
count
;
return
NS_OK
;
}
void
mozHunspell
:
:
LoadDictionaryList
(
)
{
mDictionaries
.
Clear
(
)
;
nsresult
rv
;
nsCOMPtr
<
nsIProperties
>
dirSvc
=
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
)
;
if
(
!
dirSvc
)
return
;
nsCOMPtr
<
nsIFile
>
dictDir
;
nsCOMPtr
<
nsIPrefBranch
>
prefs
(
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
)
;
if
(
prefs
)
{
nsCString
extDictPath
;
rv
=
prefs
-
>
GetCharPref
(
"
spellchecker
.
dictionary_path
"
getter_Copies
(
extDictPath
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
NS_NewNativeLocalFile
(
extDictPath
true
getter_AddRefs
(
dictDir
)
)
;
}
}
if
(
!
dictDir
)
{
rv
=
dirSvc
-
>
Get
(
DICTIONARY_SEARCH_DIRECTORY
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
dictDir
)
)
;
}
if
(
dictDir
)
{
LoadDictionariesFromDir
(
dictDir
)
;
}
else
{
nsCOMPtr
<
nsIFile
>
greDir
;
rv
=
dirSvc
-
>
Get
(
NS_GRE_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
greDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
greDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
dictionaries
"
)
)
;
LoadDictionariesFromDir
(
greDir
)
;
}
nsCOMPtr
<
nsIFile
>
appDir
;
rv
=
dirSvc
-
>
Get
(
NS_XPCOM_CURRENT_PROCESS_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
appDir
)
)
;
bool
equals
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
NS_SUCCEEDED
(
appDir
-
>
Equals
(
greDir
&
equals
)
)
&
&
!
equals
)
{
appDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
dictionaries
"
)
)
;
LoadDictionariesFromDir
(
appDir
)
;
}
}
nsCOMPtr
<
nsISimpleEnumerator
>
dictDirs
;
rv
=
dirSvc
-
>
Get
(
DICTIONARY_SEARCH_DIRECTORY_LIST
NS_GET_IID
(
nsISimpleEnumerator
)
getter_AddRefs
(
dictDirs
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
bool
hasMore
;
while
(
NS_SUCCEEDED
(
dictDirs
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
elem
;
dictDirs
-
>
GetNext
(
getter_AddRefs
(
elem
)
)
;
dictDir
=
do_QueryInterface
(
elem
)
;
if
(
dictDir
)
LoadDictionariesFromDir
(
dictDir
)
;
}
for
(
int32_t
i
=
0
;
i
<
mDynamicDirectories
.
Count
(
)
;
i
+
+
)
{
LoadDictionariesFromDir
(
mDynamicDirectories
[
i
]
)
;
}
mozInlineSpellChecker
:
:
UpdateCanEnableInlineSpellChecking
(
)
;
if
(
!
mDictionary
.
IsEmpty
(
)
)
{
rv
=
SetDictionary
(
mDictionary
.
get
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
return
;
}
if
(
!
mDictionary
.
IsEmpty
(
)
)
{
SetDictionary
(
EmptyString
(
)
.
get
(
)
)
;
}
}
NS_IMETHODIMP
mozHunspell
:
:
LoadDictionariesFromDir
(
nsIFile
*
aDir
)
{
nsresult
rv
;
bool
check
=
false
;
rv
=
aDir
-
>
Exists
(
&
check
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
check
)
return
NS_ERROR_UNEXPECTED
;
rv
=
aDir
-
>
IsDirectory
(
&
check
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
check
)
return
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsISimpleEnumerator
>
e
;
rv
=
aDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
e
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsIDirectoryEnumerator
>
files
(
do_QueryInterface
(
e
)
)
;
if
(
!
files
)
return
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsIFile
>
file
;
while
(
NS_SUCCEEDED
(
files
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
)
&
&
file
)
{
nsAutoString
leafName
;
file
-
>
GetLeafName
(
leafName
)
;
if
(
!
StringEndsWith
(
leafName
NS_LITERAL_STRING
(
"
.
dic
"
)
)
)
continue
;
nsAutoString
dict
(
leafName
)
;
dict
.
SetLength
(
dict
.
Length
(
)
-
4
)
;
leafName
=
dict
;
leafName
.
AppendLiteral
(
"
.
aff
"
)
;
file
-
>
SetLeafName
(
leafName
)
;
rv
=
file
-
>
Exists
(
&
check
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
check
)
continue
;
#
ifdef
DEBUG_bsmedberg
printf
(
"
Adding
dictionary
:
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
dict
)
.
get
(
)
)
;
#
endif
mDictionaries
.
Put
(
dict
file
)
;
}
return
NS_OK
;
}
nsresult
mozHunspell
:
:
ConvertCharset
(
const
PRUnichar
*
aStr
char
*
*
aDst
)
{
NS_ENSURE_ARG_POINTER
(
aDst
)
;
NS_ENSURE_TRUE
(
mEncoder
NS_ERROR_NULL_POINTER
)
;
int32_t
outLength
;
int32_t
inLength
=
NS_strlen
(
aStr
)
;
nsresult
rv
=
mEncoder
-
>
GetMaxLength
(
aStr
inLength
&
outLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aDst
=
(
char
*
)
nsMemory
:
:
Alloc
(
sizeof
(
char
)
*
(
outLength
+
1
)
)
;
NS_ENSURE_TRUE
(
*
aDst
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
mEncoder
-
>
Convert
(
aStr
&
inLength
*
aDst
&
outLength
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
(
*
aDst
)
[
outLength
]
=
'
\
0
'
;
return
rv
;
}
NS_IMETHODIMP
mozHunspell
:
:
Check
(
const
PRUnichar
*
aWord
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aWord
)
;
NS_ENSURE_ARG_POINTER
(
aResult
)
;
NS_ENSURE_TRUE
(
mHunspell
NS_ERROR_FAILURE
)
;
nsXPIDLCString
charsetWord
;
nsresult
rv
=
ConvertCharset
(
aWord
getter_Copies
(
charsetWord
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aResult
=
!
!
mHunspell
-
>
spell
(
charsetWord
)
;
if
(
!
*
aResult
&
&
mPersonalDictionary
)
rv
=
mPersonalDictionary
-
>
Check
(
aWord
mLanguage
.
get
(
)
aResult
)
;
return
rv
;
}
NS_IMETHODIMP
mozHunspell
:
:
Suggest
(
const
PRUnichar
*
aWord
PRUnichar
*
*
*
aSuggestions
uint32_t
*
aSuggestionCount
)
{
NS_ENSURE_ARG_POINTER
(
aSuggestions
)
;
NS_ENSURE_ARG_POINTER
(
aSuggestionCount
)
;
NS_ENSURE_TRUE
(
mHunspell
NS_ERROR_FAILURE
)
;
nsresult
rv
;
*
aSuggestionCount
=
0
;
nsXPIDLCString
charsetWord
;
rv
=
ConvertCharset
(
aWord
getter_Copies
(
charsetWord
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
char
*
*
wlst
;
*
aSuggestionCount
=
mHunspell
-
>
suggest
(
&
wlst
charsetWord
)
;
if
(
*
aSuggestionCount
)
{
*
aSuggestions
=
(
PRUnichar
*
*
)
nsMemory
:
:
Alloc
(
*
aSuggestionCount
*
sizeof
(
PRUnichar
*
)
)
;
if
(
*
aSuggestions
)
{
uint32_t
index
=
0
;
for
(
index
=
0
;
index
<
*
aSuggestionCount
&
&
NS_SUCCEEDED
(
rv
)
;
+
+
index
)
{
int32_t
inLength
=
strlen
(
wlst
[
index
]
)
;
int32_t
outLength
;
rv
=
mDecoder
-
>
GetMaxLength
(
wlst
[
index
]
inLength
&
outLength
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
(
*
aSuggestions
)
[
index
]
=
(
PRUnichar
*
)
nsMemory
:
:
Alloc
(
sizeof
(
PRUnichar
)
*
(
outLength
+
1
)
)
;
if
(
(
*
aSuggestions
)
[
index
]
)
{
rv
=
mDecoder
-
>
Convert
(
wlst
[
index
]
&
inLength
(
*
aSuggestions
)
[
index
]
&
outLength
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
(
*
aSuggestions
)
[
index
]
[
outLength
]
=
0
;
}
else
rv
=
NS_ERROR_OUT_OF_MEMORY
;
}
}
if
(
NS_FAILED
(
rv
)
)
NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY
(
index
*
aSuggestions
)
;
}
else
rv
=
NS_ERROR_OUT_OF_MEMORY
;
}
NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY
(
*
aSuggestionCount
wlst
)
;
return
rv
;
}
NS_IMETHODIMP
mozHunspell
:
:
Observe
(
nsISupports
*
aSubj
const
char
*
aTopic
const
PRUnichar
*
aData
)
{
NS_ASSERTION
(
!
strcmp
(
aTopic
"
profile
-
do
-
change
"
)
|
|
!
strcmp
(
aTopic
"
profile
-
after
-
change
"
)
"
Unexpected
observer
topic
"
)
;
LoadDictionaryList
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozHunspell
:
:
AddDirectory
(
nsIFile
*
aDir
)
{
mDynamicDirectories
.
AppendObject
(
aDir
)
;
LoadDictionaryList
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
mozHunspell
:
:
RemoveDirectory
(
nsIFile
*
aDir
)
{
mDynamicDirectories
.
RemoveObject
(
aDir
)
;
LoadDictionaryList
(
)
;
return
NS_OK
;
}
