#
include
<
string
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
nsAuth
.
h
"
#
include
"
nsHttpNegotiateAuth
.
h
"
#
include
"
nsIHttpAuthenticableChannel
.
h
"
#
include
"
nsIAuthModule
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIProxyInfo
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
plbase64
.
h
"
#
include
"
plstr
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
prmem
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIHttpAuthenticatorCallback
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsICancelable
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
mozilla
/
net
/
HttpAuthUtils
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
using
mozilla
:
:
Base64Decode
;
static
const
char
kNegotiate
[
]
=
"
Negotiate
"
;
static
const
char
kNegotiateAuthTrustedURIs
[
]
=
"
network
.
negotiate
-
auth
.
trusted
-
uris
"
;
static
const
char
kNegotiateAuthDelegationURIs
[
]
=
"
network
.
negotiate
-
auth
.
delegation
-
uris
"
;
static
const
char
kNegotiateAuthAllowProxies
[
]
=
"
network
.
negotiate
-
auth
.
allow
-
proxies
"
;
static
const
char
kNegotiateAuthAllowNonFqdn
[
]
=
"
network
.
negotiate
-
auth
.
allow
-
non
-
fqdn
"
;
static
const
char
kNegotiateAuthSSPI
[
]
=
"
network
.
auth
.
use
-
sspi
"
;
static
const
char
kSSOinPBmode
[
]
=
"
network
.
auth
.
private
-
browsing
-
sso
"
;
mozilla
:
:
StaticRefPtr
<
nsHttpNegotiateAuth
>
nsHttpNegotiateAuth
:
:
gSingleton
;
#
define
kNegotiateLen
(
sizeof
(
kNegotiate
)
-
1
)
#
define
DEFAULT_THREAD_TIMEOUT_MS
30000
static
bool
TestNotInPBMode
(
nsIHttpAuthenticableChannel
*
authChannel
bool
proxyAuth
)
{
if
(
proxyAuth
)
{
return
true
;
}
nsCOMPtr
<
nsIChannel
>
bareChannel
=
do_QueryInterface
(
authChannel
)
;
MOZ_ASSERT
(
bareChannel
)
;
if
(
!
NS_UsePrivateBrowsing
(
bareChannel
)
)
{
return
true
;
}
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefs
)
{
bool
ssoInPb
;
if
(
NS_SUCCEEDED
(
prefs
-
>
GetBoolPref
(
kSSOinPBmode
&
ssoInPb
)
)
&
&
ssoInPb
)
{
return
true
;
}
bool
dontRememberHistory
;
if
(
NS_SUCCEEDED
(
prefs
-
>
GetBoolPref
(
"
browser
.
privatebrowsing
.
autostart
"
&
dontRememberHistory
)
)
&
&
dontRememberHistory
)
{
return
true
;
}
}
return
false
;
}
already_AddRefed
<
nsIHttpAuthenticator
>
nsHttpNegotiateAuth
:
:
GetOrCreate
(
)
{
nsCOMPtr
<
nsIHttpAuthenticator
>
authenticator
;
if
(
gSingleton
)
{
authenticator
=
gSingleton
;
}
else
{
gSingleton
=
new
nsHttpNegotiateAuth
(
)
;
mozilla
:
:
ClearOnShutdown
(
&
gSingleton
)
;
authenticator
=
gSingleton
;
}
return
authenticator
.
forget
(
)
;
}
NS_IMETHODIMP
nsHttpNegotiateAuth
:
:
GetAuthFlags
(
uint32_t
*
flags
)
{
*
flags
=
CONNECTION_BASED
|
IDENTITY_IGNORED
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpNegotiateAuth
:
:
ChallengeReceived
(
nsIHttpAuthenticableChannel
*
authChannel
const
nsACString
&
challenge
bool
isProxyAuth
nsISupports
*
*
sessionState
nsISupports
*
*
continuationState
bool
*
identityInvalid
)
{
nsIAuthModule
*
rawModule
=
(
nsIAuthModule
*
)
*
continuationState
;
*
identityInvalid
=
false
;
if
(
rawModule
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIAuthModule
>
module
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
authChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
uint32_t
req_flags
=
nsIAuthModule
:
:
REQ_DEFAULT
;
nsAutoCString
service
;
if
(
isProxyAuth
)
{
if
(
!
TestBoolPref
(
kNegotiateAuthAllowProxies
)
)
{
LOG
(
(
"
nsHttpNegotiateAuth
:
:
ChallengeReceived
proxy
auth
blocked
\
n
"
)
)
;
return
NS_ERROR_ABORT
;
}
req_flags
|
=
nsIAuthModule
:
:
REQ_PROXY_AUTH
;
nsCOMPtr
<
nsIProxyInfo
>
proxyInfo
;
authChannel
-
>
GetProxyInfo
(
getter_AddRefs
(
proxyInfo
)
)
;
NS_ENSURE_STATE
(
proxyInfo
)
;
proxyInfo
-
>
GetHost
(
service
)
;
}
else
{
bool
allowed
=
TestNotInPBMode
(
authChannel
isProxyAuth
)
&
&
(
TestNonFqdn
(
uri
)
|
|
mozilla
:
:
net
:
:
auth
:
:
URIMatchesPrefPattern
(
uri
kNegotiateAuthTrustedURIs
)
)
;
if
(
!
allowed
)
{
LOG
(
(
"
nsHttpNegotiateAuth
:
:
ChallengeReceived
URI
blocked
\
n
"
)
)
;
return
NS_ERROR_ABORT
;
}
bool
delegation
=
mozilla
:
:
net
:
:
auth
:
:
URIMatchesPrefPattern
(
uri
kNegotiateAuthDelegationURIs
)
;
if
(
delegation
)
{
LOG
(
(
"
using
REQ_DELEGATE
\
n
"
)
)
;
req_flags
|
=
nsIAuthModule
:
:
REQ_DELEGATE
;
}
rv
=
uri
-
>
GetAsciiHost
(
service
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
LOG
(
(
"
service
=
%
s
\
n
"
service
.
get
(
)
)
)
;
service
.
InsertLiteral
(
"
HTTP
"
0
)
;
const
char
*
authType
;
if
(
TestBoolPref
(
kNegotiateAuthSSPI
)
)
{
LOG
(
(
"
using
negotiate
-
sspi
\
n
"
)
)
;
authType
=
"
negotiate
-
sspi
"
;
}
else
{
LOG
(
(
"
using
negotiate
-
gss
\
n
"
)
)
;
authType
=
"
negotiate
-
gss
"
;
}
MOZ_ALWAYS_TRUE
(
module
=
nsIAuthModule
:
:
CreateInstance
(
authType
)
)
;
rv
=
module
-
>
Init
(
service
req_flags
u
"
"
_ns
u
"
"
_ns
u
"
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
module
.
forget
(
continuationState
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsHttpNegotiateAuth
nsIHttpAuthenticator
)
namespace
{
class
GetNextTokenCompleteEvent
final
:
public
nsIRunnable
public
nsICancelable
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
explicit
GetNextTokenCompleteEvent
(
nsIHttpAuthenticatorCallback
*
aCallback
)
:
mCallback
(
aCallback
)
{
}
nsresult
DispatchSuccess
(
const
nsACString
&
aCreds
uint32_t
aFlags
already_AddRefed
<
nsISupports
>
aSessionState
already_AddRefed
<
nsISupports
>
aContinuationState
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mCreds
=
aCreds
;
mFlags
=
aFlags
;
mResult
=
NS_OK
;
mSessionState
=
aSessionState
;
mContinuationState
=
aContinuationState
;
return
NS_DispatchToMainThread
(
this
NS_DISPATCH_NORMAL
)
;
}
nsresult
DispatchError
(
already_AddRefed
<
nsISupports
>
aSessionState
already_AddRefed
<
nsISupports
>
aContinuationState
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mResult
=
NS_ERROR_FAILURE
;
mSessionState
=
aSessionState
;
mContinuationState
=
aContinuationState
;
return
NS_DispatchToMainThread
(
this
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mCancelled
)
{
nsCOMPtr
<
nsIHttpAuthenticatorCallback
>
callback
;
callback
.
swap
(
mCallback
)
;
callback
-
>
OnCredsGenerated
(
mCreds
mFlags
mResult
mSessionState
mContinuationState
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
Cancel
(
nsresult
aReason
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mCancelled
=
true
;
nsCOMPtr
<
nsIHttpAuthenticatorCallback
>
callback
=
std
:
:
move
(
mCallback
)
;
if
(
callback
)
{
callback
-
>
OnCredsGenerated
(
mCreds
mFlags
aReason
nullptr
nullptr
)
;
}
return
NS_OK
;
}
private
:
virtual
~
GetNextTokenCompleteEvent
(
)
=
default
;
nsCOMPtr
<
nsIHttpAuthenticatorCallback
>
mCallback
;
nsCString
mCreds
;
uint32_t
mFlags
=
0
;
nsresult
mResult
=
NS_OK
;
bool
mCancelled
=
false
;
nsCOMPtr
<
nsISupports
>
mSessionState
;
nsCOMPtr
<
nsISupports
>
mContinuationState
;
}
;
NS_IMPL_ISUPPORTS
(
GetNextTokenCompleteEvent
nsIRunnable
nsICancelable
)
class
GetNextTokenRunnable
final
:
public
mozilla
:
:
Runnable
{
~
GetNextTokenRunnable
(
)
override
=
default
;
public
:
GetNextTokenRunnable
(
nsMainThreadPtrHandle
<
nsIHttpAuthenticableChannel
>
&
authChannel
const
nsACString
&
challenge
bool
isProxyAuth
const
nsAString
&
domain
const
nsAString
&
username
const
nsAString
&
password
nsISupports
*
sessionState
nsISupports
*
continuationState
GetNextTokenCompleteEvent
*
aCompleteEvent
)
:
mozilla
:
:
Runnable
(
"
GetNextTokenRunnable
"
)
mAuthChannel
(
authChannel
)
mChallenge
(
challenge
)
mIsProxyAuth
(
isProxyAuth
)
mDomain
(
domain
)
mUsername
(
username
)
mPassword
(
password
)
mSessionState
(
sessionState
)
mContinuationState
(
continuationState
)
mCompleteEvent
(
aCompleteEvent
)
{
}
NS_IMETHODIMP
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCString
creds
;
uint32_t
flags
;
nsresult
rv
=
ObtainCredentialsAndFlags
(
creds
&
flags
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
mCompleteEvent
-
>
DispatchError
(
mSessionState
.
forget
(
)
mContinuationState
.
forget
(
)
)
;
}
return
mCompleteEvent
-
>
DispatchSuccess
(
creds
flags
mSessionState
.
forget
(
)
mContinuationState
.
forget
(
)
)
;
}
NS_IMETHODIMP
ObtainCredentialsAndFlags
(
nsCString
&
aCreds
uint32_t
*
aFlags
)
{
nsresult
rv
;
nsCOMPtr
<
nsIHttpAuthenticator
>
authenticator
=
new
nsHttpNegotiateAuth
(
)
;
nsISupports
*
sessionState
=
mSessionState
;
nsISupports
*
continuationState
=
mContinuationState
;
rv
=
authenticator
-
>
GenerateCredentials
(
mAuthChannel
mChallenge
mIsProxyAuth
mDomain
mUsername
mPassword
&
sessionState
&
continuationState
aFlags
aCreds
)
;
if
(
mSessionState
!
=
sessionState
)
{
mSessionState
=
sessionState
;
}
if
(
mContinuationState
!
=
continuationState
)
{
mContinuationState
=
continuationState
;
}
return
rv
;
}
private
:
nsMainThreadPtrHandle
<
nsIHttpAuthenticableChannel
>
mAuthChannel
;
nsCString
mChallenge
;
bool
mIsProxyAuth
;
nsString
mDomain
;
nsString
mUsername
;
nsString
mPassword
;
nsCOMPtr
<
nsISupports
>
mSessionState
;
nsCOMPtr
<
nsISupports
>
mContinuationState
;
RefPtr
<
GetNextTokenCompleteEvent
>
mCompleteEvent
;
}
;
}
NS_IMETHODIMP
nsHttpNegotiateAuth
:
:
GenerateCredentialsAsync
(
nsIHttpAuthenticableChannel
*
authChannel
nsIHttpAuthenticatorCallback
*
aCallback
const
nsACString
&
challenge
bool
isProxyAuth
const
nsAString
&
domain
const
nsAString
&
username
const
nsAString
&
password
nsISupports
*
sessionState
nsISupports
*
continuationState
nsICancelable
*
*
aCancelable
)
{
NS_ENSURE_ARG
(
aCallback
)
;
NS_ENSURE_ARG_POINTER
(
aCancelable
)
;
RefPtr
<
GetNextTokenCompleteEvent
>
cancelEvent
=
new
GetNextTokenCompleteEvent
(
aCallback
)
;
nsMainThreadPtrHandle
<
nsIHttpAuthenticableChannel
>
handle
(
new
nsMainThreadPtrHolder
<
nsIHttpAuthenticableChannel
>
(
"
nsIHttpAuthenticableChannel
"
authChannel
false
)
)
;
nsCOMPtr
<
nsIRunnable
>
getNextTokenRunnable
=
new
GetNextTokenRunnable
(
handle
challenge
isProxyAuth
domain
username
password
sessionState
continuationState
cancelEvent
)
;
nsresult
rv
=
NS_DispatchBackgroundTask
(
getNextTokenRunnable
nsIEventTarget
:
:
DISPATCH_EVENT_MAY_BLOCK
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
cancelEvent
.
forget
(
aCancelable
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpNegotiateAuth
:
:
GenerateCredentials
(
nsIHttpAuthenticableChannel
*
authChannel
const
nsACString
&
aChallenge
bool
isProxyAuth
const
nsAString
&
domain
const
nsAString
&
username
const
nsAString
&
password
nsISupports
*
*
sessionState
nsISupports
*
*
continuationState
uint32_t
*
flags
nsACString
&
creds
)
{
nsIAuthModule
*
module
=
(
nsIAuthModule
*
)
*
continuationState
;
NS_ENSURE_TRUE
(
module
NS_ERROR_NOT_INITIALIZED
)
;
*
flags
=
USING_INTERNAL_IDENTITY
;
LOG
(
(
"
nsHttpNegotiateAuth
:
:
GenerateCredentials
(
)
[
challenge
=
%
s
]
\
n
"
aChallenge
.
BeginReading
(
)
)
)
;
#
ifdef
DEBUG
bool
isGssapiAuth
=
StringBeginsWith
(
aChallenge
"
Negotiate
"
_ns
nsCaseInsensitiveCStringComparator
)
;
NS_ASSERTION
(
isGssapiAuth
"
Unexpected
challenge
"
)
;
#
endif
nsAutoCString
inToken
;
if
(
aChallenge
.
Length
(
)
>
kNegotiateLen
)
{
nsDependentCSubstring
challenge
(
aChallenge
kNegotiateLen
)
;
uint32_t
startPos
=
0
;
while
(
startPos
<
challenge
.
Length
(
)
&
&
challenge
[
startPos
]
=
=
'
'
)
{
startPos
+
+
;
}
if
(
startPos
=
=
challenge
.
Length
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
uint32_t
len
=
challenge
.
Length
(
)
;
while
(
len
>
startPos
&
&
challenge
[
len
-
1
]
=
=
'
=
'
)
{
len
-
-
;
}
(
void
)
Base64Decode
(
nsDependentCSubstring
(
challenge
startPos
len
-
startPos
)
inToken
)
;
}
void
*
outToken
=
nullptr
;
uint32_t
outTokenLen
=
0
;
nsresult
rv
=
module
-
>
GetNextToken
(
inToken
.
get
(
)
inToken
.
Length
(
)
&
outToken
&
outTokenLen
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
outToken
)
{
free
(
outToken
)
;
}
return
rv
;
}
if
(
outTokenLen
=
=
0
)
{
LOG
(
(
"
No
output
token
to
send
exiting
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsAutoCString
encodedToken
;
rv
=
mozilla
:
:
Base64Encode
(
nsDependentCSubstring
(
(
char
*
)
outToken
outTokenLen
)
encodedToken
)
;
free
(
outToken
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
LOG
(
(
"
Sending
a
token
of
length
%
d
\
n
"
outTokenLen
)
)
;
creds
=
nsPrintfCString
(
"
%
s
%
s
"
kNegotiate
encodedToken
.
get
(
)
)
;
return
rv
;
}
bool
nsHttpNegotiateAuth
:
:
TestBoolPref
(
const
char
*
pref
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
!
prefs
)
return
false
;
bool
val
;
nsresult
rv
=
prefs
-
>
GetBoolPref
(
pref
&
val
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
return
val
;
}
bool
nsHttpNegotiateAuth
:
:
TestNonFqdn
(
nsIURI
*
uri
)
{
nsAutoCString
host
;
if
(
!
TestBoolPref
(
kNegotiateAuthAllowNonFqdn
)
)
{
return
false
;
}
if
(
NS_FAILED
(
uri
-
>
GetAsciiHost
(
host
)
)
)
{
return
false
;
}
return
!
host
.
IsEmpty
(
)
&
&
!
host
.
Contains
(
'
.
'
)
&
&
!
mozilla
:
:
net
:
:
HostIsIPLiteral
(
host
)
;
}
