#
include
<
string
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
nsAuth
.
h
"
#
include
"
nsHttpNegotiateAuth
.
h
"
#
include
"
nsIHttpAuthenticableChannel
.
h
"
#
include
"
nsIProxiedChannel
.
h
"
#
include
"
nsIAuthModule
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIProxyInfo
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
plbase64
.
h
"
#
include
"
plstr
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
prmem
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIHttpAuthenticatorCallback
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsICancelable
.
h
"
static
const
char
kNegotiate
[
]
=
"
Negotiate
"
;
static
const
char
kNegotiateAuthTrustedURIs
[
]
=
"
network
.
negotiate
-
auth
.
trusted
-
uris
"
;
static
const
char
kNegotiateAuthDelegationURIs
[
]
=
"
network
.
negotiate
-
auth
.
delegation
-
uris
"
;
static
const
char
kNegotiateAuthAllowProxies
[
]
=
"
network
.
negotiate
-
auth
.
allow
-
proxies
"
;
static
const
char
kNegotiateAuthAllowNonFqdn
[
]
=
"
network
.
negotiate
-
auth
.
allow
-
non
-
fqdn
"
;
static
const
char
kNegotiateAuthSSPI
[
]
=
"
network
.
auth
.
use
-
sspi
"
;
static
const
char
kSSOinPBmode
[
]
=
"
network
.
auth
.
private
-
browsing
-
sso
"
;
#
define
kNegotiateLen
(
sizeof
(
kNegotiate
)
-
1
)
#
define
DEFAULT_THREAD_TIMEOUT_MS
30000
static
bool
TestNotInPBMode
(
nsIHttpAuthenticableChannel
*
authChannel
bool
proxyAuth
)
{
if
(
proxyAuth
)
{
return
true
;
}
nsCOMPtr
<
nsIChannel
>
bareChannel
=
do_QueryInterface
(
authChannel
)
;
MOZ_ASSERT
(
bareChannel
)
;
if
(
!
NS_UsePrivateBrowsing
(
bareChannel
)
)
{
return
true
;
}
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefs
)
{
bool
ssoInPb
;
if
(
NS_SUCCEEDED
(
prefs
-
>
GetBoolPref
(
kSSOinPBmode
&
ssoInPb
)
)
&
&
ssoInPb
)
{
return
true
;
}
bool
dontRememberHistory
;
if
(
NS_SUCCEEDED
(
prefs
-
>
GetBoolPref
(
"
browser
.
privatebrowsing
.
autostart
"
&
dontRememberHistory
)
)
&
&
dontRememberHistory
)
{
return
true
;
}
}
return
false
;
}
NS_IMETHODIMP
nsHttpNegotiateAuth
:
:
GetAuthFlags
(
uint32_t
*
flags
)
{
*
flags
=
CONNECTION_BASED
|
IDENTITY_IGNORED
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpNegotiateAuth
:
:
ChallengeReceived
(
nsIHttpAuthenticableChannel
*
authChannel
const
char
*
challenge
bool
isProxyAuth
nsISupports
*
*
sessionState
nsISupports
*
*
continuationState
bool
*
identityInvalid
)
{
nsIAuthModule
*
module
=
(
nsIAuthModule
*
)
*
continuationState
;
*
identityInvalid
=
false
;
if
(
module
)
return
NS_OK
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
authChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
uint32_t
req_flags
=
nsIAuthModule
:
:
REQ_DEFAULT
;
nsAutoCString
service
;
if
(
isProxyAuth
)
{
if
(
!
TestBoolPref
(
kNegotiateAuthAllowProxies
)
)
{
LOG
(
(
"
nsHttpNegotiateAuth
:
:
ChallengeReceived
proxy
auth
blocked
\
n
"
)
)
;
return
NS_ERROR_ABORT
;
}
req_flags
|
=
nsIAuthModule
:
:
REQ_PROXY_AUTH
;
nsCOMPtr
<
nsIProxyInfo
>
proxyInfo
;
authChannel
-
>
GetProxyInfo
(
getter_AddRefs
(
proxyInfo
)
)
;
NS_ENSURE_STATE
(
proxyInfo
)
;
proxyInfo
-
>
GetHost
(
service
)
;
}
else
{
bool
allowed
=
TestNotInPBMode
(
authChannel
isProxyAuth
)
&
&
(
TestNonFqdn
(
uri
)
|
|
TestPref
(
uri
kNegotiateAuthTrustedURIs
)
)
;
if
(
!
allowed
)
{
LOG
(
(
"
nsHttpNegotiateAuth
:
:
ChallengeReceived
URI
blocked
\
n
"
)
)
;
return
NS_ERROR_ABORT
;
}
bool
delegation
=
TestPref
(
uri
kNegotiateAuthDelegationURIs
)
;
if
(
delegation
)
{
LOG
(
(
"
using
REQ_DELEGATE
\
n
"
)
)
;
req_flags
|
=
nsIAuthModule
:
:
REQ_DELEGATE
;
}
rv
=
uri
-
>
GetAsciiHost
(
service
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
LOG
(
(
"
service
=
%
s
\
n
"
service
.
get
(
)
)
)
;
service
.
Insert
(
"
HTTP
"
0
)
;
const
char
*
contractID
;
if
(
TestBoolPref
(
kNegotiateAuthSSPI
)
)
{
LOG
(
(
"
using
negotiate
-
sspi
\
n
"
)
)
;
contractID
=
NS_AUTH_MODULE_CONTRACTID_PREFIX
"
negotiate
-
sspi
"
;
}
else
{
LOG
(
(
"
using
negotiate
-
gss
\
n
"
)
)
;
contractID
=
NS_AUTH_MODULE_CONTRACTID_PREFIX
"
negotiate
-
gss
"
;
}
rv
=
CallCreateInstance
(
contractID
&
module
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
load
Negotiate
Module
\
n
"
)
)
;
return
rv
;
}
rv
=
module
-
>
Init
(
service
.
get
(
)
req_flags
nullptr
nullptr
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_RELEASE
(
module
)
;
return
rv
;
}
*
continuationState
=
module
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsHttpNegotiateAuth
nsIHttpAuthenticator
)
namespace
{
class
GetNextTokenCompleteEvent
final
:
public
nsIRunnable
public
nsICancelable
{
virtual
~
GetNextTokenCompleteEvent
(
)
{
if
(
mCreds
)
{
free
(
mCreds
)
;
}
}
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
explicit
GetNextTokenCompleteEvent
(
nsIHttpAuthenticatorCallback
*
aCallback
)
:
mCallback
(
aCallback
)
mCreds
(
nullptr
)
mCancelled
(
false
)
{
}
NS_IMETHODIMP
DispatchSuccess
(
char
*
aCreds
uint32_t
aFlags
already_AddRefed
<
nsISupports
>
aSessionState
already_AddRefed
<
nsISupports
>
aContinuationState
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mCreds
=
aCreds
;
mFlags
=
aFlags
;
mResult
=
NS_OK
;
mSessionState
=
aSessionState
;
mContinuationState
=
aContinuationState
;
return
NS_DispatchToMainThread
(
this
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
DispatchError
(
already_AddRefed
<
nsISupports
>
aSessionState
already_AddRefed
<
nsISupports
>
aContinuationState
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mResult
=
NS_ERROR_FAILURE
;
mSessionState
=
aSessionState
;
mContinuationState
=
aContinuationState
;
return
NS_DispatchToMainThread
(
this
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mCancelled
)
{
nsCOMPtr
<
nsIHttpAuthenticatorCallback
>
callback
;
callback
.
swap
(
mCallback
)
;
callback
-
>
OnCredsGenerated
(
mCreds
mFlags
mResult
mSessionState
mContinuationState
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
Cancel
(
nsresult
aReason
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mCancelled
=
true
;
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIHttpAuthenticatorCallback
>
mCallback
;
char
*
mCreds
;
uint32_t
mFlags
;
nsresult
mResult
;
bool
mCancelled
;
nsCOMPtr
<
nsISupports
>
mSessionState
;
nsCOMPtr
<
nsISupports
>
mContinuationState
;
}
;
NS_IMPL_ISUPPORTS
(
GetNextTokenCompleteEvent
nsIRunnable
nsICancelable
)
class
GetNextTokenRunnable
final
:
public
mozilla
:
:
Runnable
{
~
GetNextTokenRunnable
(
)
override
=
default
;
public
:
GetNextTokenRunnable
(
nsIHttpAuthenticableChannel
*
authChannel
const
char
*
challenge
bool
isProxyAuth
const
char16_t
*
domain
const
char16_t
*
username
const
char16_t
*
password
nsISupports
*
sessionState
nsISupports
*
continuationState
GetNextTokenCompleteEvent
*
aCompleteEvent
)
:
mAuthChannel
(
authChannel
)
mChallenge
(
challenge
)
mIsProxyAuth
(
isProxyAuth
)
mDomain
(
domain
)
mUsername
(
username
)
mPassword
(
password
)
mSessionState
(
sessionState
)
mContinuationState
(
continuationState
)
mCompleteEvent
(
aCompleteEvent
)
{
}
NS_IMETHODIMP
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
char
*
creds
;
uint32_t
flags
;
nsresult
rv
=
ObtainCredentialsAndFlags
(
&
creds
&
flags
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
mCompleteEvent
-
>
DispatchError
(
mSessionState
.
forget
(
)
mContinuationState
.
forget
(
)
)
;
}
return
mCompleteEvent
-
>
DispatchSuccess
(
creds
flags
mSessionState
.
forget
(
)
mContinuationState
.
forget
(
)
)
;
}
NS_IMETHODIMP
ObtainCredentialsAndFlags
(
char
*
*
aCreds
uint32_t
*
aFlags
)
{
nsresult
rv
;
nsAutoCString
contractId
;
contractId
.
Assign
(
NS_HTTP_AUTHENTICATOR_CONTRACTID_PREFIX
)
;
contractId
.
Append
(
"
negotiate
"
)
;
nsCOMPtr
<
nsIHttpAuthenticator
>
authenticator
=
do_GetService
(
contractId
.
get
(
)
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsISupports
*
sessionState
=
mSessionState
;
nsISupports
*
continuationState
=
mContinuationState
;
rv
=
authenticator
-
>
GenerateCredentials
(
mAuthChannel
mChallenge
.
get
(
)
mIsProxyAuth
mDomain
.
get
(
)
mUsername
.
get
(
)
mPassword
.
get
(
)
&
sessionState
&
continuationState
aFlags
aCreds
)
;
if
(
mSessionState
!
=
sessionState
)
{
mSessionState
=
sessionState
;
}
if
(
mContinuationState
!
=
continuationState
)
{
mContinuationState
=
continuationState
;
}
return
rv
;
}
private
:
nsCOMPtr
<
nsIHttpAuthenticableChannel
>
mAuthChannel
;
nsCString
mChallenge
;
bool
mIsProxyAuth
;
nsString
mDomain
;
nsString
mUsername
;
nsString
mPassword
;
nsCOMPtr
<
nsISupports
>
mSessionState
;
nsCOMPtr
<
nsISupports
>
mContinuationState
;
RefPtr
<
GetNextTokenCompleteEvent
>
mCompleteEvent
;
}
;
}
NS_IMETHODIMP
nsHttpNegotiateAuth
:
:
GenerateCredentialsAsync
(
nsIHttpAuthenticableChannel
*
authChannel
nsIHttpAuthenticatorCallback
*
aCallback
const
char
*
challenge
bool
isProxyAuth
const
char16_t
*
domain
const
char16_t
*
username
const
char16_t
*
password
nsISupports
*
sessionState
nsISupports
*
continuationState
nsICancelable
*
*
aCancelable
)
{
NS_ENSURE_ARG
(
aCallback
)
;
NS_ENSURE_ARG_POINTER
(
aCancelable
)
;
RefPtr
<
GetNextTokenCompleteEvent
>
cancelEvent
=
new
GetNextTokenCompleteEvent
(
aCallback
)
;
nsCOMPtr
<
nsIRunnable
>
getNextTokenRunnable
=
new
GetNextTokenRunnable
(
authChannel
challenge
isProxyAuth
domain
username
password
sessionState
continuationState
cancelEvent
)
;
cancelEvent
.
forget
(
aCancelable
)
;
nsresult
rv
;
if
(
!
mNegotiateThread
)
{
mNegotiateThread
=
new
mozilla
:
:
LazyIdleThread
(
DEFAULT_THREAD_TIMEOUT_MS
NS_LITERAL_CSTRING
(
"
NegotiateAuth
"
)
)
;
NS_ENSURE_TRUE
(
mNegotiateThread
NS_ERROR_OUT_OF_MEMORY
)
;
}
rv
=
mNegotiateThread
-
>
Dispatch
(
getNextTokenRunnable
NS_DISPATCH_NORMAL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpNegotiateAuth
:
:
GenerateCredentials
(
nsIHttpAuthenticableChannel
*
authChannel
const
char
*
challenge
bool
isProxyAuth
const
char16_t
*
domain
const
char16_t
*
username
const
char16_t
*
password
nsISupports
*
*
sessionState
nsISupports
*
*
continuationState
uint32_t
*
flags
char
*
*
creds
)
{
nsIAuthModule
*
module
=
(
nsIAuthModule
*
)
*
continuationState
;
NS_ENSURE_TRUE
(
module
NS_ERROR_NOT_INITIALIZED
)
;
*
flags
=
USING_INTERNAL_IDENTITY
;
LOG
(
(
"
nsHttpNegotiateAuth
:
:
GenerateCredentials
(
)
[
challenge
=
%
s
]
\
n
"
challenge
)
)
;
NS_ASSERTION
(
creds
"
null
param
"
)
;
#
ifdef
DEBUG
bool
isGssapiAuth
=
!
PL_strncasecmp
(
challenge
kNegotiate
kNegotiateLen
)
;
NS_ASSERTION
(
isGssapiAuth
"
Unexpected
challenge
"
)
;
#
endif
unsigned
int
len
=
strlen
(
challenge
)
;
void
*
inToken
*
outToken
;
uint32_t
inTokenLen
outTokenLen
;
if
(
len
>
kNegotiateLen
)
{
challenge
+
=
kNegotiateLen
;
while
(
*
challenge
=
=
'
'
)
challenge
+
+
;
len
=
strlen
(
challenge
)
;
while
(
challenge
[
len
-
1
]
=
=
'
=
'
)
len
-
-
;
inTokenLen
=
(
len
*
3
)
/
4
;
inToken
=
malloc
(
inTokenLen
)
;
if
(
!
inToken
)
return
(
NS_ERROR_OUT_OF_MEMORY
)
;
if
(
PL_Base64Decode
(
challenge
len
(
char
*
)
inToken
)
=
=
nullptr
)
{
free
(
inToken
)
;
return
(
NS_ERROR_UNEXPECTED
)
;
}
}
else
{
inToken
=
nullptr
;
inTokenLen
=
0
;
}
nsresult
rv
=
module
-
>
GetNextToken
(
inToken
inTokenLen
&
outToken
&
outTokenLen
)
;
free
(
inToken
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
outTokenLen
=
=
0
)
{
LOG
(
(
"
No
output
token
to
send
exiting
"
)
)
;
return
NS_ERROR_FAILURE
;
}
char
*
encoded_token
=
PL_Base64Encode
(
(
char
*
)
outToken
outTokenLen
nullptr
)
;
free
(
outToken
)
;
if
(
!
encoded_token
)
return
NS_ERROR_OUT_OF_MEMORY
;
LOG
(
(
"
Sending
a
token
of
length
%
d
\
n
"
outTokenLen
)
)
;
const
int
bufsize
=
kNegotiateLen
+
1
+
strlen
(
encoded_token
)
+
1
;
*
creds
=
(
char
*
)
moz_xmalloc
(
bufsize
)
;
if
(
MOZ_UNLIKELY
(
!
*
creds
)
)
rv
=
NS_ERROR_OUT_OF_MEMORY
;
else
snprintf
(
*
creds
bufsize
"
%
s
%
s
"
kNegotiate
encoded_token
)
;
PR_Free
(
encoded_token
)
;
return
rv
;
}
bool
nsHttpNegotiateAuth
:
:
TestBoolPref
(
const
char
*
pref
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
!
prefs
)
return
false
;
bool
val
;
nsresult
rv
=
prefs
-
>
GetBoolPref
(
pref
&
val
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
return
val
;
}
bool
nsHttpNegotiateAuth
:
:
TestNonFqdn
(
nsIURI
*
uri
)
{
nsAutoCString
host
;
PRNetAddr
addr
;
if
(
!
TestBoolPref
(
kNegotiateAuthAllowNonFqdn
)
)
return
false
;
if
(
NS_FAILED
(
uri
-
>
GetAsciiHost
(
host
)
)
)
return
false
;
return
!
host
.
IsEmpty
(
)
&
&
!
host
.
Contains
(
'
.
'
)
&
&
PR_StringToNetAddr
(
host
.
BeginReading
(
)
&
addr
)
!
=
PR_SUCCESS
;
}
bool
nsHttpNegotiateAuth
:
:
TestPref
(
nsIURI
*
uri
const
char
*
pref
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
!
prefs
)
return
false
;
nsAutoCString
scheme
host
;
int32_t
port
;
if
(
NS_FAILED
(
uri
-
>
GetScheme
(
scheme
)
)
)
return
false
;
if
(
NS_FAILED
(
uri
-
>
GetAsciiHost
(
host
)
)
)
return
false
;
if
(
NS_FAILED
(
uri
-
>
GetPort
(
&
port
)
)
)
return
false
;
char
*
hostList
;
if
(
NS_FAILED
(
prefs
-
>
GetCharPref
(
pref
&
hostList
)
)
|
|
!
hostList
)
return
false
;
char
*
start
=
hostList
*
end
;
for
(
;
;
)
{
while
(
*
start
=
=
'
'
|
|
*
start
=
=
'
\
t
'
)
+
+
start
;
end
=
strchr
(
start
'
'
)
;
if
(
!
end
)
end
=
start
+
strlen
(
start
)
;
if
(
start
=
=
end
)
break
;
if
(
MatchesBaseURI
(
scheme
host
port
start
end
)
)
return
true
;
if
(
*
end
=
=
'
\
0
'
)
break
;
start
=
end
+
1
;
}
free
(
hostList
)
;
return
false
;
}
bool
nsHttpNegotiateAuth
:
:
MatchesBaseURI
(
const
nsCSubstring
&
matchScheme
const
nsCSubstring
&
matchHost
int32_t
matchPort
const
char
*
baseStart
const
char
*
baseEnd
)
{
const
char
*
hostStart
*
schemeEnd
=
strstr
(
baseStart
"
:
/
/
"
)
;
if
(
schemeEnd
)
{
if
(
!
matchScheme
.
Equals
(
Substring
(
baseStart
schemeEnd
)
)
)
return
false
;
hostStart
=
schemeEnd
+
3
;
}
else
hostStart
=
baseStart
;
const
char
*
hostEnd
=
strchr
(
hostStart
'
:
'
)
;
if
(
hostEnd
&
&
hostEnd
<
baseEnd
)
{
int
port
=
atoi
(
hostEnd
+
1
)
;
if
(
matchPort
!
=
(
int32_t
)
port
)
return
false
;
}
else
hostEnd
=
baseEnd
;
if
(
hostStart
=
=
hostEnd
)
return
true
;
uint32_t
hostLen
=
hostEnd
-
hostStart
;
if
(
matchHost
.
Length
(
)
<
hostLen
)
return
false
;
const
char
*
end
=
matchHost
.
EndReading
(
)
;
if
(
PL_strncasecmp
(
end
-
hostLen
hostStart
hostLen
)
=
=
0
)
{
if
(
matchHost
.
Length
(
)
=
=
hostLen
|
|
*
(
end
-
hostLen
)
=
=
'
.
'
|
|
*
(
end
-
hostLen
-
1
)
=
=
'
.
'
)
return
true
;
}
return
false
;
}
