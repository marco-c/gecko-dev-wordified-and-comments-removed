#
include
"
nscore
.
h
"
#
include
"
nsUniversalDetector
.
h
"
#
include
"
nsMBCSGroupProber
.
h
"
#
include
"
nsEscCharsetProber
.
h
"
nsUniversalDetector
:
:
nsUniversalDetector
(
)
{
mDone
=
false
;
mBestGuess
=
-
1
;
mInTag
=
false
;
mMultibyteProber
=
nullptr
;
mEscCharSetProber
=
nullptr
;
mStart
=
true
;
mDetectedCharset
=
nullptr
;
mGotData
=
false
;
mInputState
=
ePureAscii
;
mLastChar
=
'
\
0
'
;
}
nsUniversalDetector
:
:
~
nsUniversalDetector
(
)
{
delete
mMultibyteProber
;
delete
mEscCharSetProber
;
}
void
nsUniversalDetector
:
:
Reset
(
)
{
mDone
=
false
;
mBestGuess
=
-
1
;
mInTag
=
false
;
mStart
=
true
;
mDetectedCharset
=
nullptr
;
mGotData
=
false
;
mInputState
=
ePureAscii
;
mLastChar
=
'
\
0
'
;
if
(
mMultibyteProber
)
{
mMultibyteProber
-
>
Reset
(
)
;
}
if
(
mEscCharSetProber
)
{
mEscCharSetProber
-
>
Reset
(
)
;
}
}
#
define
SHORTCUT_THRESHOLD
(
float
)
0
.
95
#
define
MINIMUM_THRESHOLD
(
float
)
0
.
20
nsresult
nsUniversalDetector
:
:
HandleData
(
const
char
*
aBuf
uint32_t
aLen
)
{
if
(
mDone
)
return
NS_OK
;
if
(
aLen
>
0
)
mGotData
=
true
;
if
(
mStart
)
{
mStart
=
false
;
if
(
aLen
>
=
2
)
{
switch
(
aBuf
[
0
]
)
{
case
'
\
xEF
'
:
if
(
(
aLen
>
2
)
&
&
(
'
\
xBB
'
=
=
aBuf
[
1
]
)
&
&
(
'
\
xBF
'
=
=
aBuf
[
2
]
)
)
{
mDetectedCharset
=
"
UTF
-
8
"
;
}
break
;
case
'
\
xFE
'
:
if
(
'
\
xFF
'
=
=
aBuf
[
1
]
)
{
mDetectedCharset
=
"
UTF
-
16BE
"
;
}
break
;
case
'
\
xFF
'
:
if
(
'
\
xFE
'
=
=
aBuf
[
1
]
)
{
mDetectedCharset
=
"
UTF
-
16LE
"
;
}
break
;
}
}
if
(
mDetectedCharset
)
{
mDone
=
true
;
return
NS_OK
;
}
}
uint32_t
i
;
for
(
i
=
0
;
i
<
aLen
;
i
+
+
)
{
if
(
aBuf
[
i
]
&
'
\
x80
'
&
&
aBuf
[
i
]
!
=
'
\
xA0
'
)
{
if
(
mInputState
!
=
eHighbyte
)
{
mInputState
=
eHighbyte
;
if
(
mEscCharSetProber
)
{
delete
mEscCharSetProber
;
mEscCharSetProber
=
nullptr
;
}
if
(
!
mMultibyteProber
)
{
mMultibyteProber
=
new
nsMBCSGroupProber
(
)
;
}
}
}
else
{
if
(
(
ePureAscii
=
=
mInputState
)
&
&
(
aBuf
[
i
]
=
=
'
\
033
'
)
)
{
mInputState
=
eEscAscii
;
}
mLastChar
=
aBuf
[
i
]
;
}
}
nsProbingState
st
;
switch
(
mInputState
)
{
case
eEscAscii
:
if
(
nullptr
=
=
mEscCharSetProber
)
{
mEscCharSetProber
=
new
nsEscCharSetProber
(
)
;
if
(
nullptr
=
=
mEscCharSetProber
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
st
=
mEscCharSetProber
-
>
HandleData
(
aBuf
aLen
)
;
if
(
st
=
=
eFoundIt
)
{
mDone
=
true
;
mDetectedCharset
=
mEscCharSetProber
-
>
GetCharSetName
(
)
;
}
break
;
case
eHighbyte
:
st
=
mMultibyteProber
-
>
HandleData
(
aBuf
aLen
)
;
if
(
st
=
=
eFoundIt
)
{
mDone
=
true
;
mDetectedCharset
=
mMultibyteProber
-
>
GetCharSetName
(
)
;
return
NS_OK
;
}
break
;
default
:
;
}
return
NS_OK
;
}
void
nsUniversalDetector
:
:
DataEnd
(
)
{
if
(
!
mGotData
)
{
return
;
}
if
(
mDetectedCharset
)
{
mDone
=
true
;
Report
(
mDetectedCharset
)
;
return
;
}
switch
(
mInputState
)
{
case
eHighbyte
:
{
if
(
mMultibyteProber
-
>
GetConfidence
(
)
>
MINIMUM_THRESHOLD
)
Report
(
mMultibyteProber
-
>
GetCharSetName
(
)
)
;
}
break
;
case
eEscAscii
:
break
;
default
:
;
}
}
