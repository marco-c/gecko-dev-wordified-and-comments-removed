#
ifndef
nsPermissionManager_h__
#
define
nsPermissionManager_h__
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPermission
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
namespace
mozilla
{
class
OriginAttributesPattern
;
}
class
nsIPermission
;
class
mozIStorageConnection
;
class
mozIStorageAsyncStatement
;
class
nsPermissionManager
final
:
public
nsIPermissionManager
public
nsIObserver
public
nsSupportsWeakReference
{
public
:
class
PermissionEntry
{
public
:
PermissionEntry
(
int64_t
aID
uint32_t
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
:
mID
(
aID
)
mType
(
aType
)
mPermission
(
aPermission
)
mExpireType
(
aExpireType
)
mExpireTime
(
aExpireTime
)
mModificationTime
(
aModificationTime
)
mNonSessionPermission
(
aPermission
)
mNonSessionExpireType
(
aExpireType
)
mNonSessionExpireTime
(
aExpireTime
)
{
}
int64_t
mID
;
uint32_t
mType
;
uint32_t
mPermission
;
uint32_t
mExpireType
;
int64_t
mExpireTime
;
int64_t
mModificationTime
;
uint32_t
mNonSessionPermission
;
uint32_t
mNonSessionExpireType
;
uint32_t
mNonSessionExpireTime
;
}
;
class
PermissionKey
{
public
:
static
PermissionKey
*
CreateFromPrincipal
(
nsIPrincipal
*
aPrincipal
nsresult
&
aResult
)
;
static
PermissionKey
*
CreateFromURI
(
nsIURI
*
aURI
nsresult
&
aResult
)
;
static
PermissionKey
*
CreateFromOriginNoSuffix
(
const
nsACString
&
aOriginNoSuffix
)
;
explicit
PermissionKey
(
const
nsACString
&
aOrigin
)
:
mOrigin
(
aOrigin
)
mHashCode
(
mozilla
:
:
HashString
(
aOrigin
)
)
{
}
bool
operator
=
=
(
const
PermissionKey
&
aKey
)
const
{
return
mOrigin
.
Equals
(
aKey
.
mOrigin
)
;
}
PLDHashNumber
GetHashCode
(
)
const
{
return
mHashCode
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PermissionKey
)
const
nsCString
mOrigin
;
const
PLDHashNumber
mHashCode
;
private
:
PermissionKey
(
)
=
delete
;
~
PermissionKey
(
)
{
}
;
}
;
class
PermissionHashKey
:
public
nsRefPtrHashKey
<
PermissionKey
>
{
public
:
explicit
PermissionHashKey
(
const
PermissionKey
*
aPermissionKey
)
:
nsRefPtrHashKey
<
PermissionKey
>
(
aPermissionKey
)
{
}
PermissionHashKey
(
PermissionHashKey
&
&
toCopy
)
:
nsRefPtrHashKey
<
PermissionKey
>
(
std
:
:
move
(
toCopy
)
)
mPermissions
(
std
:
:
move
(
toCopy
.
mPermissions
)
)
{
}
bool
KeyEquals
(
const
PermissionKey
*
aKey
)
const
{
return
*
aKey
=
=
*
GetKey
(
)
;
}
static
PLDHashNumber
HashKey
(
const
PermissionKey
*
aKey
)
{
return
aKey
-
>
GetHashCode
(
)
;
}
enum
{
ALLOW_MEMMOVE
=
false
}
;
inline
nsTArray
<
PermissionEntry
>
&
GetPermissions
(
)
{
return
mPermissions
;
}
inline
int32_t
GetPermissionIndex
(
uint32_t
aType
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mPermissions
.
Length
(
)
;
+
+
i
)
if
(
mPermissions
[
i
]
.
mType
=
=
aType
)
return
i
;
return
-
1
;
}
inline
PermissionEntry
GetPermission
(
uint32_t
aType
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mPermissions
.
Length
(
)
;
+
+
i
)
if
(
mPermissions
[
i
]
.
mType
=
=
aType
)
return
mPermissions
[
i
]
;
return
PermissionEntry
(
-
1
aType
nsIPermissionManager
:
:
UNKNOWN_ACTION
nsIPermissionManager
:
:
EXPIRE_NEVER
0
0
)
;
}
private
:
AutoTArray
<
PermissionEntry
1
>
mPermissions
;
}
;
NS_DECL_ISUPPORTS
NS_DECL_NSIPERMISSIONMANAGER
NS_DECL_NSIOBSERVER
nsPermissionManager
(
)
;
static
already_AddRefed
<
nsIPermissionManager
>
GetXPCOMSingleton
(
)
;
static
nsPermissionManager
*
GetInstance
(
)
;
nsresult
Init
(
)
;
enum
OperationType
{
eOperationNone
eOperationAdding
eOperationRemoving
eOperationChanging
eOperationReplacingDefault
}
;
enum
DBOperationType
{
eNoDBOperation
eWriteToDB
}
;
enum
NotifyOperationType
{
eDontNotify
eNotify
}
;
static
const
int64_t
cIDPermissionIsDefault
=
-
1
;
nsresult
AddInternal
(
nsIPrincipal
*
aPrincipal
const
nsCString
&
aType
uint32_t
aPermission
int64_t
aID
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
NotifyOperationType
aNotifyOperation
DBOperationType
aDBOperation
const
bool
aIgnoreSessionPermissions
=
false
)
;
static
void
ClearOriginDataObserverInit
(
)
;
nsresult
RemovePermissionsWithAttributes
(
mozilla
:
:
OriginAttributesPattern
&
aAttrs
)
;
static
void
GetKeyForPrincipal
(
nsIPrincipal
*
aPrincipal
nsACString
&
aPermissionKey
)
;
static
void
GetKeyForOrigin
(
const
nsACString
&
aOrigin
nsACString
&
aPermissionKey
)
;
static
void
GetKeyForPermission
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
nsACString
&
aPermissionKey
)
;
static
nsTArray
<
nsCString
>
GetAllKeysForPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
nsresult
RemoveAllFromIPC
(
)
;
private
:
virtual
~
nsPermissionManager
(
)
;
int32_t
GetTypeIndex
(
const
char
*
aType
bool
aAdd
)
{
for
(
uint32_t
i
=
0
;
i
<
mTypeArray
.
length
(
)
;
+
+
i
)
{
if
(
mTypeArray
[
i
]
.
Equals
(
aType
)
)
{
return
i
;
}
}
if
(
!
aAdd
)
{
return
-
1
;
}
if
(
!
mTypeArray
.
emplaceBack
(
aType
)
)
{
return
-
1
;
}
return
mTypeArray
.
length
(
)
-
1
;
}
PermissionHashKey
*
GetPermissionHashKey
(
nsIPrincipal
*
aPrincipal
uint32_t
aType
bool
aExactHostMatch
)
;
PermissionHashKey
*
GetPermissionHashKey
(
nsIURI
*
aURI
const
nsACString
&
aOriginNoSuffix
uint32_t
aType
bool
aExactHostMatch
)
;
enum
TestPreparationEnum
{
eContinue
eDone
}
;
struct
TestPreparationResult
{
mozilla
:
:
BasePrincipal
*
mPrincipal
;
int32_t
mTypeIndex
;
TestPreparationEnum
mShouldContinue
;
}
;
TestPreparationResult
CommonPrepareToTestPermission
(
nsIPrincipal
*
aPrincipal
int32_t
aTypeIndex
const
char
*
aType
uint32_t
*
aPermission
)
{
auto
*
basePrin
=
mozilla
:
:
BasePrincipal
:
:
Cast
(
aPrincipal
)
;
if
(
basePrin
&
&
basePrin
-
>
IsSystemPrincipal
(
)
)
{
*
aPermission
=
nsIPermissionManager
:
:
ALLOW_ACTION
;
return
{
basePrin
-
1
eDone
}
;
}
*
aPermission
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
int32_t
typeIndex
=
aTypeIndex
=
=
-
1
?
GetTypeIndex
(
aType
false
)
:
aTypeIndex
;
if
(
typeIndex
=
=
-
1
)
{
return
{
basePrin
-
1
eDone
}
;
}
return
{
basePrin
typeIndex
eContinue
}
;
}
nsresult
CommonTestPermission
(
nsIPrincipal
*
aPrincipal
int32_t
aTypeIndex
const
char
*
aType
uint32_t
*
aPermission
bool
aExactHostMatch
bool
aIncludingSession
)
{
auto
preparationResult
=
CommonPrepareToTestPermission
(
aPrincipal
aTypeIndex
aType
aPermission
)
;
if
(
preparationResult
.
mShouldContinue
=
=
eDone
)
{
return
NS_OK
;
}
return
CommonTestPermissionInternal
(
preparationResult
.
mPrincipal
nullptr
EmptyCString
(
)
preparationResult
.
mTypeIndex
aType
aPermission
aExactHostMatch
aIncludingSession
)
;
}
nsresult
CommonTestPermission
(
nsIURI
*
aURI
int32_t
aTypeIndex
const
char
*
aType
uint32_t
*
aPermission
bool
aExactHostMatch
bool
aIncludingSession
)
{
auto
preparationResult
=
CommonPrepareToTestPermission
(
nullptr
aTypeIndex
aType
aPermission
)
;
if
(
preparationResult
.
mShouldContinue
=
=
eDone
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
preparationResult
.
mPrincipal
)
;
return
CommonTestPermissionInternal
(
nullptr
aURI
EmptyCString
(
)
preparationResult
.
mTypeIndex
aType
aPermission
aExactHostMatch
aIncludingSession
)
;
}
nsresult
CommonTestPermissionInternal
(
mozilla
:
:
BasePrincipal
*
aPrincipal
nsIURI
*
aURI
const
nsACString
&
aOriginNoSuffix
int32_t
aTypeIndex
const
char
*
aType
uint32_t
*
aPermission
bool
aExactHostMatch
bool
aIncludingSession
)
;
nsresult
OpenDatabase
(
nsIFile
*
permissionsFile
)
;
nsresult
InitDB
(
bool
aRemoveFile
)
;
nsresult
CreateTable
(
)
;
nsresult
Import
(
)
;
nsresult
ImportDefaults
(
)
;
nsresult
_DoImport
(
nsIInputStream
*
inputStream
mozIStorageConnection
*
aConn
)
;
nsresult
Read
(
)
;
void
NotifyObserversWithPermission
(
nsIPrincipal
*
aPrincipal
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
const
char16_t
*
aData
)
;
void
NotifyObservers
(
nsIPermission
*
aPermission
const
char16_t
*
aData
)
;
void
CloseDB
(
bool
aRebuildOnSuccess
=
false
)
;
nsresult
RemoveAllInternal
(
bool
aNotifyObservers
)
;
nsresult
RemoveAllFromMemory
(
)
;
static
void
UpdateDB
(
OperationType
aOp
mozIStorageAsyncStatement
*
aStmt
int64_t
aID
const
nsACString
&
aOrigin
const
nsACString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
;
nsresult
RemoveAllModifiedSince
(
int64_t
aModificationTime
)
;
template
<
class
T
>
nsresult
RemovePermissionEntries
(
T
aCondition
)
;
bool
PermissionAvailable
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
)
;
nsRefPtrHashtable
<
nsCStringHashKey
mozilla
:
:
GenericPromise
:
:
Private
>
mPermissionKeyPromiseMap
;
nsCOMPtr
<
mozIStorageConnection
>
mDBConn
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
mStmtInsert
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
mStmtDelete
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
mStmtUpdate
;
bool
mMemoryOnlyDB
;
nsTHashtable
<
PermissionHashKey
>
mPermissionTable
;
int64_t
mLargestID
;
bool
mIsShuttingDown
;
nsCOMPtr
<
nsIPrefBranch
>
mDefaultPrefBranch
;
mozilla
:
:
Vector
<
nsCString
512
>
mTypeArray
;
friend
class
DeleteFromMozHostListener
;
friend
class
CloseDatabaseListener
;
}
;
#
define
NS_PERMISSIONMANAGER_CID
\
{
\
0x4f6b5e00
0xc36
0x11d5
{
\
0xa5
0x35
0x0
0x10
0xa4
0x1
0xeb
0x10
\
}
\
}
#
endif
