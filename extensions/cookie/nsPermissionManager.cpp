#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AntiTrackingCommon
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ContentPrincipal
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsPermissionManager
.
h
"
#
include
"
nsPermission
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsArrayEnumerator
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsILineInputStream
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
mozilla
/
storage
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
net
/
NeckoMessageUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsReadLine
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsINavHistoryService
.
h
"
#
include
"
nsToolkitCompsCID
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
ExpandedPrincipal
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
static
mozilla
:
:
StaticRefPtr
<
nsPermissionManager
>
gPermissionManager
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
bool
IsChildProcess
(
)
{
return
XRE_IsContentProcess
(
)
;
}
static
void
LogToConsole
(
const
nsAString
&
aMsg
)
{
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
)
)
;
if
(
!
console
)
{
NS_WARNING
(
"
Failed
to
log
message
to
console
.
"
)
;
return
;
}
nsAutoString
msg
(
aMsg
)
;
console
-
>
LogStringMessage
(
msg
.
get
(
)
)
;
}
#
define
ENSURE_NOT_CHILD_PROCESS_
(
onError
)
\
PR_BEGIN_MACRO
\
if
(
IsChildProcess
(
)
)
{
\
NS_ERROR
(
"
Cannot
perform
action
in
content
process
!
"
)
;
\
onError
\
}
\
PR_END_MACRO
#
define
ENSURE_NOT_CHILD_PROCESS
\
ENSURE_NOT_CHILD_PROCESS_
(
{
return
NS_ERROR_NOT_AVAILABLE
;
}
)
#
define
ENSURE_NOT_CHILD_PROCESS_NORET
ENSURE_NOT_CHILD_PROCESS_
(
;
)
namespace
{
static
int32_t
sPreloadPermissionCount
=
0
;
static
const
char
*
kPreloadPermissions
[
]
=
{
"
other
"
"
script
"
"
image
"
"
stylesheet
"
"
object
"
"
document
"
"
subdocument
"
"
refresh
"
"
xbl
"
"
ping
"
"
xmlhttprequest
"
"
objectsubrequest
"
"
dtd
"
"
font
"
"
media
"
"
websocket
"
"
csp_report
"
"
xslt
"
"
beacon
"
"
fetch
"
"
image
"
"
manifest
"
"
speculative
"
"
cookie
"
"
trackingprotection
"
"
trackingprotection
-
pb
"
USER_INTERACTION_PERM
}
;
static
const
char
*
kPermissionsWithDefaults
[
]
=
{
"
camera
"
"
microphone
"
"
geo
"
"
desktop
-
notification
"
"
shortcuts
"
}
;
bool
HasDefaultPref
(
const
char
*
aType
)
{
if
(
aType
)
{
for
(
const
char
*
perm
:
kPermissionsWithDefaults
)
{
if
(
!
strcmp
(
aType
perm
)
)
{
return
true
;
}
}
}
return
false
;
}
bool
IsPreloadPermission
(
const
char
*
aType
)
{
if
(
aType
)
{
for
(
uint32_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
kPreloadPermissions
)
;
+
+
i
)
{
if
(
!
strcmp
(
aType
kPreloadPermissions
[
i
]
)
)
{
return
true
;
}
}
}
return
false
;
}
nsresult
GetOriginFromPrincipal
(
nsIPrincipal
*
aPrincipal
nsACString
&
aOrigin
)
{
nsresult
rv
=
aPrincipal
-
>
GetOriginNoSuffix
(
aOrigin
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
suffix
;
rv
=
aPrincipal
-
>
GetOriginSuffix
(
suffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mozilla
:
:
OriginAttributes
attrs
;
if
(
!
attrs
.
PopulateFromSuffix
(
suffix
)
)
{
return
NS_ERROR_FAILURE
;
}
attrs
.
mPrivateBrowsingId
=
0
;
attrs
.
StripAttributes
(
mozilla
:
:
OriginAttributes
:
:
STRIP_USER_CONTEXT_ID
|
mozilla
:
:
OriginAttributes
:
:
STRIP_FIRST_PARTY_DOMAIN
)
;
attrs
.
CreateSuffix
(
suffix
)
;
aOrigin
.
Append
(
suffix
)
;
return
NS_OK
;
}
nsresult
GetPrincipalFromOrigin
(
const
nsACString
&
aOrigin
nsIPrincipal
*
*
aPrincipal
)
{
nsAutoCString
originNoSuffix
;
mozilla
:
:
OriginAttributes
attrs
;
if
(
!
attrs
.
PopulateFromOrigin
(
aOrigin
originNoSuffix
)
)
{
return
NS_ERROR_FAILURE
;
}
attrs
.
mPrivateBrowsingId
=
0
;
attrs
.
StripAttributes
(
mozilla
:
:
OriginAttributes
:
:
STRIP_USER_CONTEXT_ID
|
mozilla
:
:
OriginAttributes
:
:
STRIP_FIRST_PARTY_DOMAIN
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
originNoSuffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
mozilla
:
:
BasePrincipal
:
:
CreateCodebasePrincipal
(
uri
attrs
)
;
principal
.
forget
(
aPrincipal
)
;
return
NS_OK
;
}
nsresult
GetPrincipal
(
nsIURI
*
aURI
uint32_t
aAppId
bool
aIsInIsolatedMozBrowserElement
nsIPrincipal
*
*
aPrincipal
)
{
mozilla
:
:
OriginAttributes
attrs
(
aAppId
aIsInIsolatedMozBrowserElement
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
mozilla
:
:
BasePrincipal
:
:
CreateCodebasePrincipal
(
aURI
attrs
)
;
NS_ENSURE_TRUE
(
principal
NS_ERROR_FAILURE
)
;
principal
.
forget
(
aPrincipal
)
;
return
NS_OK
;
}
nsresult
GetPrincipal
(
nsIURI
*
aURI
nsIPrincipal
*
*
aPrincipal
)
{
mozilla
:
:
OriginAttributes
attrs
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
mozilla
:
:
BasePrincipal
:
:
CreateCodebasePrincipal
(
aURI
attrs
)
;
NS_ENSURE_TRUE
(
principal
NS_ERROR_FAILURE
)
;
principal
.
forget
(
aPrincipal
)
;
return
NS_OK
;
}
nsCString
GetNextSubDomainForHost
(
const
nsACString
&
aHost
)
{
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
if
(
!
tldService
)
{
NS_ERROR
(
"
Should
have
a
tld
service
!
"
)
;
return
EmptyCString
(
)
;
}
nsCString
subDomain
;
nsresult
rv
=
tldService
-
>
GetNextSubDomain
(
aHost
subDomain
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
EmptyCString
(
)
;
}
return
subDomain
;
}
already_AddRefed
<
nsIURI
>
GetNextSubDomainURI
(
nsIURI
*
aURI
)
{
nsAutoCString
host
;
nsresult
rv
=
aURI
-
>
GetHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
nsCString
domain
=
GetNextSubDomainForHost
(
host
)
;
if
(
domain
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_MutateURI
(
aURI
)
.
SetHost
(
domain
)
.
Finalize
(
uri
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
uri
)
{
return
nullptr
;
}
return
uri
.
forget
(
)
;
}
already_AddRefed
<
nsIPrincipal
>
GetNextSubDomainPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
uri
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
newURI
=
GetNextSubDomainURI
(
uri
)
;
if
(
!
newURI
)
{
return
nullptr
;
}
mozilla
:
:
OriginAttributes
attrs
=
aPrincipal
-
>
OriginAttributesRef
(
)
;
attrs
.
StripAttributes
(
mozilla
:
:
OriginAttributes
:
:
STRIP_USER_CONTEXT_ID
|
mozilla
:
:
OriginAttributes
:
:
STRIP_FIRST_PARTY_DOMAIN
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
mozilla
:
:
BasePrincipal
:
:
CreateCodebasePrincipal
(
newURI
attrs
)
;
return
principal
.
forget
(
)
;
}
class
ClearOriginDataObserver
final
:
public
nsIObserver
{
~
ClearOriginDataObserver
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
MOZ_ASSERT
(
!
nsCRT
:
:
strcmp
(
aTopic
"
clear
-
origin
-
attributes
-
data
"
)
)
;
nsCOMPtr
<
nsIPermissionManager
>
permManager
=
do_GetService
(
"
mozilla
.
org
/
permissionmanager
;
1
"
)
;
return
permManager
-
>
RemovePermissionsWithAttributes
(
nsDependentString
(
aData
)
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
ClearOriginDataObserver
nsIObserver
)
class
MOZ_STACK_CLASS
UpgradeHostToOriginHelper
{
public
:
virtual
nsresult
Insert
(
const
nsACString
&
aOrigin
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
=
0
;
}
;
class
MOZ_STACK_CLASS
UpgradeHostToOriginDBMigration
final
:
public
UpgradeHostToOriginHelper
{
public
:
UpgradeHostToOriginDBMigration
(
mozIStorageConnection
*
aDBConn
int64_t
*
aID
)
:
mDBConn
(
aDBConn
)
mID
(
aID
)
{
mDBConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
moz_hosts_new
"
"
(
id
origin
type
permission
expireType
"
"
expireTime
modificationTime
)
"
"
VALUES
(
?
1
?
2
?
3
?
4
?
5
?
6
?
7
)
"
)
getter_AddRefs
(
mStmt
)
)
;
}
nsresult
Insert
(
const
nsACString
&
aOrigin
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
final
{
nsresult
rv
=
mStmt
-
>
BindInt64ByIndex
(
0
*
mID
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindUTF8StringByIndex
(
1
aOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindUTF8StringByIndex
(
2
aType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindInt32ByIndex
(
3
aPermission
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindInt32ByIndex
(
4
aExpireType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindInt64ByIndex
(
5
aExpireTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindInt64ByIndex
(
6
aModificationTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
(
*
mID
)
+
+
;
rv
=
mStmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
private
:
nsCOMPtr
<
mozIStorageStatement
>
mStmt
;
nsCOMPtr
<
mozIStorageConnection
>
mDBConn
;
int64_t
*
mID
;
}
;
class
MOZ_STACK_CLASS
UpgradeHostToOriginHostfileImport
final
:
public
UpgradeHostToOriginHelper
{
public
:
UpgradeHostToOriginHostfileImport
(
nsPermissionManager
*
aPm
nsPermissionManager
:
:
DBOperationType
aOperation
int64_t
aID
)
:
mPm
(
aPm
)
mOperation
(
aOperation
)
mID
(
aID
)
{
}
nsresult
Insert
(
const
nsACString
&
aOrigin
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
final
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
aOrigin
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
mPm
-
>
AddInternal
(
principal
aType
aPermission
mID
aExpireType
aExpireTime
aModificationTime
nsPermissionManager
:
:
eDontNotify
mOperation
)
;
}
private
:
RefPtr
<
nsPermissionManager
>
mPm
;
nsPermissionManager
:
:
DBOperationType
mOperation
;
int64_t
mID
;
}
;
class
MOZ_STACK_CLASS
UpgradeIPHostToOriginDB
final
:
public
UpgradeHostToOriginHelper
{
public
:
UpgradeIPHostToOriginDB
(
mozIStorageConnection
*
aDBConn
int64_t
*
aID
)
:
mDBConn
(
aDBConn
)
mID
(
aID
)
{
mDBConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
moz_perms
"
"
(
id
origin
type
permission
expireType
"
"
expireTime
modificationTime
)
"
"
VALUES
(
?
1
?
2
?
3
?
4
?
5
?
6
?
7
)
"
)
getter_AddRefs
(
mStmt
)
)
;
mDBConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
id
FROM
moz_perms
WHERE
origin
=
?
1
AND
type
=
?
2
"
)
getter_AddRefs
(
mLookupStmt
)
)
;
}
nsresult
Insert
(
const
nsACString
&
aOrigin
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
final
{
nsresult
rv
=
mLookupStmt
-
>
Reset
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mLookupStmt
-
>
BindUTF8StringByIndex
(
0
aOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mLookupStmt
-
>
BindUTF8StringByIndex
(
1
aType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
moreStmts
=
false
;
if
(
NS_FAILED
(
mLookupStmt
-
>
ExecuteStep
(
&
moreStmts
)
)
|
|
moreStmts
)
{
mLookupStmt
-
>
Reset
(
)
;
NS_WARNING
(
"
A
permissions
entry
was
going
to
be
re
-
migrated
"
"
but
was
already
found
in
the
permissions
database
.
"
)
;
return
NS_OK
;
}
rv
=
mStmt
-
>
BindInt64ByIndex
(
0
*
mID
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindUTF8StringByIndex
(
1
aOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindUTF8StringByIndex
(
2
aType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindInt32ByIndex
(
3
aPermission
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindInt32ByIndex
(
4
aExpireType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindInt64ByIndex
(
5
aExpireTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mStmt
-
>
BindInt64ByIndex
(
6
aModificationTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
(
*
mID
)
+
+
;
rv
=
mStmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
private
:
nsCOMPtr
<
mozIStorageStatement
>
mStmt
;
nsCOMPtr
<
mozIStorageStatement
>
mLookupStmt
;
nsCOMPtr
<
mozIStorageConnection
>
mDBConn
;
int64_t
*
mID
;
}
;
nsresult
UpgradeHostToOriginAndInsert
(
const
nsACString
&
aHost
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
uint32_t
aAppId
bool
aIsInIsolatedMozBrowserElement
UpgradeHostToOriginHelper
*
aHelper
)
{
if
(
aHost
.
EqualsLiteral
(
"
<
file
>
"
)
)
{
NS_WARNING
(
"
The
magic
host
<
file
>
is
no
longer
supported
.
"
"
It
is
being
removed
from
the
permissions
database
.
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aHost
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
nullpScheme
=
false
;
if
(
NS_SUCCEEDED
(
uri
-
>
SchemeIs
(
"
moz
-
nullprincipal
"
&
nullpScheme
)
)
&
&
nullpScheme
)
{
NS_WARNING
(
"
A
moz
-
nullprincipal
:
permission
is
being
discarded
.
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
GetPrincipal
(
uri
aAppId
aIsInIsolatedMozBrowserElement
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
origin
;
rv
=
GetOriginFromPrincipal
(
principal
origin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
aHelper
-
>
Insert
(
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
return
NS_OK
;
}
bool
foundHistory
=
false
;
nsCOMPtr
<
nsINavHistoryService
>
histSrv
=
do_GetService
(
NS_NAVHISTORYSERVICE_CONTRACTID
)
;
if
(
histSrv
)
{
nsCOMPtr
<
nsINavHistoryQuery
>
histQuery
;
rv
=
histSrv
-
>
GetNewQuery
(
getter_AddRefs
(
histQuery
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
eTLD1
;
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
MOZ_ASSERT
(
tldService
)
;
if
(
tldService
)
{
rv
=
tldService
-
>
GetBaseDomainFromHost
(
aHost
0
eTLD1
)
;
}
if
(
!
tldService
|
|
NS_FAILED
(
rv
)
)
{
eTLD1
=
aHost
;
}
rv
=
histQuery
-
>
SetDomain
(
eTLD1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
histQuery
-
>
SetDomainIsHost
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINavHistoryQueryOptions
>
histQueryOpts
;
rv
=
histSrv
-
>
GetNewQueryOptions
(
getter_AddRefs
(
histQueryOpts
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
histQueryOpts
-
>
SetResultType
(
nsINavHistoryQueryOptions
:
:
RESULTS_AS_URI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
histQueryOpts
-
>
SetQueryType
(
nsINavHistoryQueryOptions
:
:
QUERY_TYPE_HISTORY
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
histQueryOpts
-
>
SetIncludeHidden
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINavHistoryResult
>
histResult
;
rv
=
histSrv
-
>
ExecuteQuery
(
histQuery
histQueryOpts
getter_AddRefs
(
histResult
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINavHistoryContainerResultNode
>
histResultContainer
;
rv
=
histResult
-
>
GetRoot
(
getter_AddRefs
(
histResultContainer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
histResultContainer
-
>
SetContainerOpen
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
childCount
=
0
;
rv
=
histResultContainer
-
>
GetChildCount
(
&
childCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsTHashtable
<
nsCStringHashKey
>
insertedOrigins
;
for
(
uint32_t
i
=
0
;
i
<
childCount
;
i
+
+
)
{
nsCOMPtr
<
nsINavHistoryResultNode
>
child
;
histResultContainer
-
>
GetChild
(
i
getter_AddRefs
(
child
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
uint32_t
type
;
rv
=
child
-
>
GetType
(
&
type
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
type
!
=
nsINavHistoryResultNode
:
:
RESULT_TYPE_URI
)
{
NS_WARNING
(
"
Unexpected
non
-
RESULT_TYPE_URI
node
in
"
"
UpgradeHostToOriginAndInsert
(
)
"
)
;
continue
;
}
nsAutoCString
uriSpec
;
rv
=
child
-
>
GetUri
(
uriSpec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
uriSpec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
rv
=
NS_MutateURI
(
uri
)
.
SetHost
(
aHost
)
.
Finalize
(
uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
GetPrincipal
(
uri
aAppId
aIsInIsolatedMozBrowserElement
getter_AddRefs
(
principal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
nsAutoCString
origin
;
rv
=
GetOriginFromPrincipal
(
principal
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
if
(
insertedOrigins
.
Contains
(
origin
)
)
{
continue
;
}
foundHistory
=
true
;
rv
=
aHelper
-
>
Insert
(
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Insert
failed
"
)
;
insertedOrigins
.
PutEntry
(
origin
)
;
}
rv
=
histResultContainer
-
>
SetContainerOpen
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
foundHistory
)
{
nsAutoCString
hostSegment
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsAutoCString
origin
;
if
(
aHost
.
FindChar
(
'
:
'
)
!
=
-
1
)
{
hostSegment
.
AssignLiteral
(
"
[
"
)
;
hostSegment
.
Append
(
aHost
)
;
hostSegment
.
AppendLiteral
(
"
]
"
)
;
}
else
{
hostSegment
.
Assign
(
aHost
)
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
NS_LITERAL_CSTRING
(
"
http
:
/
/
"
)
+
hostSegment
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetPrincipal
(
uri
aAppId
aIsInIsolatedMozBrowserElement
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetOriginFromPrincipal
(
principal
origin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aHelper
-
>
Insert
(
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
NS_LITERAL_CSTRING
(
"
https
:
/
/
"
)
+
hostSegment
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetPrincipal
(
uri
aAppId
aIsInIsolatedMozBrowserElement
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetOriginFromPrincipal
(
principal
origin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aHelper
-
>
Insert
(
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
}
return
NS_OK
;
}
static
bool
IsExpandedPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
nsCOMPtr
<
nsIExpandedPrincipal
>
ep
=
do_QueryInterface
(
aPrincipal
)
;
return
!
!
ep
;
}
static
bool
IsPersistentExpire
(
uint32_t
aExpire
)
{
return
aExpire
!
=
nsIPermissionManager
:
:
EXPIRE_SESSION
&
&
aExpire
!
=
nsIPermissionManager
:
:
EXPIRE_POLICY
;
}
static
void
UpdateAutoplayTelemetry
(
const
nsCString
&
aType
uint32_t
aOldPermission
uint32_t
aNewPermission
uint32_t
aExpireType
)
{
if
(
!
aType
.
EqualsLiteral
(
"
autoplay
-
media
"
)
)
{
return
;
}
if
(
aExpireType
!
=
nsIPermissionManager
:
:
EXPIRE_NEVER
)
{
return
;
}
if
(
aOldPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
if
(
aNewPermission
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
AccumulateCategorical
(
mozilla
:
:
Telemetry
:
:
LABELS_AUTOPLAY_SITES_SETTING_CHANGE
:
:
AddAllow
)
;
}
else
if
(
aNewPermission
=
=
nsIPermissionManager
:
:
DENY_ACTION
)
{
AccumulateCategorical
(
mozilla
:
:
Telemetry
:
:
LABELS_AUTOPLAY_SITES_SETTING_CHANGE
:
:
AddBlock
)
;
}
return
;
}
if
(
aNewPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
if
(
aOldPermission
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
AccumulateCategorical
(
mozilla
:
:
Telemetry
:
:
LABELS_AUTOPLAY_SITES_SETTING_CHANGE
:
:
RemoveAllow
)
;
}
else
if
(
aOldPermission
=
=
nsIPermissionManager
:
:
DENY_ACTION
)
{
AccumulateCategorical
(
mozilla
:
:
Telemetry
:
:
LABELS_AUTOPLAY_SITES_SETTING_CHANGE
:
:
RemoveBlock
)
;
}
return
;
}
if
(
aNewPermission
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
&
&
aOldPermission
=
=
nsIPermissionManager
:
:
DENY_ACTION
)
{
AccumulateCategorical
(
mozilla
:
:
Telemetry
:
:
LABELS_AUTOPLAY_SITES_SETTING_CHANGE
:
:
AddAllow
)
;
AccumulateCategorical
(
mozilla
:
:
Telemetry
:
:
LABELS_AUTOPLAY_SITES_SETTING_CHANGE
:
:
RemoveBlock
)
;
}
else
if
(
aNewPermission
=
=
nsIPermissionManager
:
:
DENY_ACTION
&
&
aOldPermission
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
AccumulateCategorical
(
mozilla
:
:
Telemetry
:
:
LABELS_AUTOPLAY_SITES_SETTING_CHANGE
:
:
AddBlock
)
;
AccumulateCategorical
(
mozilla
:
:
Telemetry
:
:
LABELS_AUTOPLAY_SITES_SETTING_CHANGE
:
:
RemoveAllow
)
;
}
}
}
nsPermissionManager
:
:
PermissionKey
*
nsPermissionManager
:
:
PermissionKey
:
:
CreateFromPrincipal
(
nsIPrincipal
*
aPrincipal
nsresult
&
aResult
)
{
nsAutoCString
origin
;
aResult
=
GetOriginFromPrincipal
(
aPrincipal
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aResult
)
)
)
{
return
nullptr
;
}
return
new
PermissionKey
(
origin
)
;
}
nsPermissionManager
:
:
PermissionKey
*
nsPermissionManager
:
:
PermissionKey
:
:
CreateFromURI
(
nsIURI
*
aURI
nsresult
&
aResult
)
{
nsAutoCString
origin
;
aResult
=
ContentPrincipal
:
:
GenerateOriginNoSuffixFromURI
(
aURI
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aResult
)
)
)
{
return
nullptr
;
}
return
new
PermissionKey
(
origin
)
;
}
nsPermissionManager
:
:
PermissionKey
*
nsPermissionManager
:
:
PermissionKey
:
:
CreateFromOriginNoSuffix
(
const
nsACString
&
aOriginNoSuffix
)
{
return
new
PermissionKey
(
aOriginNoSuffix
)
;
}
class
CloseDatabaseListener
final
:
public
mozIStorageCompletionCallback
{
~
CloseDatabaseListener
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGECOMPLETIONCALLBACK
CloseDatabaseListener
(
nsPermissionManager
*
aManager
bool
aRebuildOnSuccess
)
;
protected
:
RefPtr
<
nsPermissionManager
>
mManager
;
bool
mRebuildOnSuccess
;
}
;
NS_IMPL_ISUPPORTS
(
CloseDatabaseListener
mozIStorageCompletionCallback
)
CloseDatabaseListener
:
:
CloseDatabaseListener
(
nsPermissionManager
*
aManager
bool
aRebuildOnSuccess
)
:
mManager
(
aManager
)
mRebuildOnSuccess
(
aRebuildOnSuccess
)
{
}
NS_IMETHODIMP
CloseDatabaseListener
:
:
Complete
(
nsresult
nsISupports
*
)
{
RefPtr
<
nsPermissionManager
>
manager
=
mManager
.
forget
(
)
;
if
(
mRebuildOnSuccess
&
&
!
manager
-
>
mIsShuttingDown
)
{
return
manager
-
>
InitDB
(
true
)
;
}
return
NS_OK
;
}
class
DeleteFromMozHostListener
final
:
public
mozIStorageStatementCallback
{
~
DeleteFromMozHostListener
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGESTATEMENTCALLBACK
explicit
DeleteFromMozHostListener
(
nsPermissionManager
*
aManager
)
;
protected
:
RefPtr
<
nsPermissionManager
>
mManager
;
}
;
NS_IMPL_ISUPPORTS
(
DeleteFromMozHostListener
mozIStorageStatementCallback
)
DeleteFromMozHostListener
:
:
DeleteFromMozHostListener
(
nsPermissionManager
*
aManager
)
:
mManager
(
aManager
)
{
}
NS_IMETHODIMP
DeleteFromMozHostListener
:
:
HandleResult
(
mozIStorageResultSet
*
)
{
MOZ_CRASH
(
"
Should
not
get
any
results
"
)
;
}
NS_IMETHODIMP
DeleteFromMozHostListener
:
:
HandleError
(
mozIStorageError
*
)
{
return
NS_OK
;
}
NS_IMETHODIMP
DeleteFromMozHostListener
:
:
HandleCompletion
(
uint16_t
aReason
)
{
RefPtr
<
nsPermissionManager
>
manager
=
mManager
.
forget
(
)
;
if
(
aReason
=
=
REASON_ERROR
)
{
manager
-
>
CloseDB
(
true
)
;
}
return
NS_OK
;
}
void
nsPermissionManager
:
:
ClearOriginDataObserverInit
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
observerService
-
>
AddObserver
(
new
ClearOriginDataObserver
(
)
"
clear
-
origin
-
attributes
-
data
"
false
)
;
}
#
define
PERMISSIONS_FILE_NAME
"
permissions
.
sqlite
"
#
define
HOSTS_SCHEMA_VERSION
9
#
define
HOSTPERM_FILE_NAME
"
hostperm
.
1
"
static
const
char
kDefaultsUrlPrefName
[
]
=
"
permissions
.
manager
.
defaultsUrl
"
;
static
const
char
kPermissionChangeNotification
[
]
=
PERM_CHANGE_NOTIFICATION
;
NS_IMPL_ISUPPORTS
(
nsPermissionManager
nsIPermissionManager
nsIObserver
nsISupportsWeakReference
)
nsPermissionManager
:
:
nsPermissionManager
(
)
:
mMemoryOnlyDB
(
false
)
mLargestID
(
0
)
mIsShuttingDown
(
false
)
{
}
nsPermissionManager
:
:
~
nsPermissionManager
(
)
{
for
(
auto
iter
=
mPermissionKeyPromiseMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
Data
(
)
)
{
iter
.
Data
(
)
-
>
Reject
(
NS_ERROR_FAILURE
__func__
)
;
}
}
mPermissionKeyPromiseMap
.
Clear
(
)
;
RemoveAllFromMemory
(
)
;
if
(
gPermissionManager
)
{
MOZ_ASSERT
(
gPermissionManager
=
=
this
)
;
gPermissionManager
=
nullptr
;
}
}
already_AddRefed
<
nsIPermissionManager
>
nsPermissionManager
:
:
GetXPCOMSingleton
(
)
{
if
(
gPermissionManager
)
{
return
do_AddRef
(
gPermissionManager
)
;
}
auto
permManager
=
MakeRefPtr
<
nsPermissionManager
>
(
)
;
if
(
NS_SUCCEEDED
(
permManager
-
>
Init
(
)
)
)
{
gPermissionManager
=
permManager
.
get
(
)
;
ClearOnShutdown
(
&
gPermissionManager
)
;
return
permManager
.
forget
(
)
;
}
return
nullptr
;
}
nsPermissionManager
*
nsPermissionManager
:
:
GetInstance
(
)
{
if
(
!
gPermissionManager
)
{
nsCOMPtr
<
nsIPermissionManager
>
permManager
=
GetXPCOMSingleton
(
)
;
}
return
gPermissionManager
;
}
nsresult
nsPermissionManager
:
:
Init
(
)
{
mMemoryOnlyDB
=
mozilla
:
:
Preferences
:
:
GetBool
(
"
permissions
.
memory_only
"
false
)
;
nsresult
rv
;
nsCOMPtr
<
nsIPrefService
>
prefService
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
prefService
-
>
GetBranch
(
"
permissions
.
default
.
"
getter_AddRefs
(
mDefaultPrefBranch
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
IsChildProcess
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
this
"
profile
-
before
-
change
"
true
)
;
observerService
-
>
AddObserver
(
this
"
profile
-
do
-
change
"
true
)
;
}
InitDB
(
false
)
;
return
NS_OK
;
}
nsresult
nsPermissionManager
:
:
OpenDatabase
(
nsIFile
*
aPermissionsFile
)
{
nsresult
rv
;
nsCOMPtr
<
mozIStorageService
>
storage
=
do_GetService
(
MOZ_STORAGE_SERVICE_CONTRACTID
)
;
if
(
!
storage
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
mMemoryOnlyDB
)
{
rv
=
storage
-
>
OpenSpecialDatabase
(
"
memory
"
getter_AddRefs
(
mDBConn
)
)
;
}
else
{
rv
=
storage
-
>
OpenDatabase
(
aPermissionsFile
getter_AddRefs
(
mDBConn
)
)
;
}
return
rv
;
}
nsresult
nsPermissionManager
:
:
InitDB
(
bool
aRemoveFile
)
{
nsCOMPtr
<
nsIFile
>
permissionsFile
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_PERMISSION_PARENT_DIR
getter_AddRefs
(
permissionsFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
permissionsFile
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_UNEXPECTED
)
;
rv
=
permissionsFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
PERMISSIONS_FILE_NAME
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aRemoveFile
)
{
bool
exists
=
false
;
rv
=
permissionsFile
-
>
Exists
(
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
exists
)
{
rv
=
permissionsFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
rv
=
OpenDatabase
(
permissionsFile
)
;
if
(
rv
=
=
NS_ERROR_FILE_CORRUPTED
)
{
LogToConsole
(
NS_LITERAL_STRING
(
"
permissions
.
sqlite
is
corrupted
!
Try
again
!
"
)
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
PERMISSIONS_SQL_CORRUPTED
1
)
;
rv
=
permissionsFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LogToConsole
(
NS_LITERAL_STRING
(
"
Corrupted
permissions
.
sqlite
has
been
removed
.
"
)
)
;
rv
=
OpenDatabase
(
permissionsFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LogToConsole
(
NS_LITERAL_STRING
(
"
OpenDatabase
to
permissions
.
sqlite
is
successful
!
"
)
)
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
ready
;
mDBConn
-
>
GetConnectionReady
(
&
ready
)
;
if
(
!
ready
)
{
LogToConsole
(
NS_LITERAL_STRING
(
"
Fail
to
get
connection
to
permissions
.
sqlite
!
Try
again
!
"
)
)
;
rv
=
permissionsFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LogToConsole
(
NS_LITERAL_STRING
(
"
Defective
permissions
.
sqlite
has
been
removed
.
"
)
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
DEFECTIVE_PERMISSIONS_SQL_REMOVED
1
)
;
rv
=
OpenDatabase
(
permissionsFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LogToConsole
(
NS_LITERAL_STRING
(
"
OpenDatabase
to
permissions
.
sqlite
is
successful
!
"
)
)
;
mDBConn
-
>
GetConnectionReady
(
&
ready
)
;
if
(
!
ready
)
return
NS_ERROR_UNEXPECTED
;
}
bool
tableExists
=
false
;
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_perms
"
)
&
tableExists
)
;
if
(
!
tableExists
)
{
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_hosts
"
)
&
tableExists
)
;
}
if
(
!
tableExists
)
{
rv
=
CreateTable
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
int32_t
dbSchemaVersion
;
rv
=
mDBConn
-
>
GetSchemaVersion
(
&
dbSchemaVersion
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
switch
(
dbSchemaVersion
)
{
case
1
:
{
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_hosts
ADD
expireType
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_hosts
ADD
expireTime
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_FALLTHROUGH
;
case
0
:
case
2
:
{
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_hosts
ADD
appId
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_hosts
ADD
isInBrowserElement
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDBConn
-
>
SetSchemaVersion
(
3
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_FALLTHROUGH
;
case
3
:
{
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_hosts
ADD
modificationTime
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDBConn
-
>
SetSchemaVersion
(
4
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_FALLTHROUGH
;
case
5
:
if
(
dbSchemaVersion
=
=
5
)
{
bool
permsTableExists
=
false
;
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_perms
"
)
&
permsTableExists
)
;
if
(
!
permsTableExists
)
{
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_hosts
RENAME
TO
moz_perms
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
NS_WARNING
(
"
moz_hosts
was
not
renamed
to
moz_perms
"
"
as
a
moz_perms
table
already
exists
"
)
;
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_hosts
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
#
ifdef
DEBUG
bool
hostsTableExists
=
false
;
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_hosts
"
)
&
hostsTableExists
)
;
MOZ_ASSERT
(
!
hostsTableExists
)
;
#
endif
bool
v4TableExists
=
false
;
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_hosts_v4
"
)
&
v4TableExists
)
;
if
(
v4TableExists
)
{
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_hosts_v4
RENAME
TO
moz_hosts
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
mDBConn
-
>
SetSchemaVersion
(
6
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_FALLTHROUGH
;
case
4
:
case
6
:
{
bool
hostsTableExists
=
false
;
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_hosts
"
)
&
hostsTableExists
)
;
if
(
hostsTableExists
)
{
bool
migrationError
=
false
;
rv
=
mDBConn
-
>
BeginTransaction
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
tableExists
=
false
;
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_hosts_new
"
)
&
tableExists
)
;
if
(
tableExists
)
{
NS_WARNING
(
"
The
temporary
database
moz_hosts_new
already
exists
dropping
"
"
it
.
"
)
;
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_hosts_new
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
TABLE
moz_hosts_new
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
origin
TEXT
"
"
type
TEXT
"
"
permission
INTEGER
"
"
expireType
INTEGER
"
"
expireTime
INTEGER
"
"
modificationTime
INTEGER
"
"
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
mDBConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
host
type
permission
expireType
expireTime
"
"
modificationTime
appId
isInBrowserElement
FROM
moz_hosts
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int64_t
id
=
0
;
nsAutoCString
host
type
;
uint32_t
permission
;
uint32_t
expireType
;
int64_t
expireTime
;
int64_t
modificationTime
;
uint32_t
appId
;
bool
isInBrowserElement
;
bool
hasResult
;
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
rv
=
stmt
-
>
GetUTF8String
(
0
host
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
migrationError
=
true
;
continue
;
}
rv
=
stmt
-
>
GetUTF8String
(
1
type
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
migrationError
=
true
;
continue
;
}
permission
=
stmt
-
>
AsInt32
(
2
)
;
expireType
=
stmt
-
>
AsInt32
(
3
)
;
expireTime
=
stmt
-
>
AsInt64
(
4
)
;
modificationTime
=
stmt
-
>
AsInt64
(
5
)
;
if
(
NS_WARN_IF
(
stmt
-
>
AsInt64
(
6
)
<
0
)
)
{
migrationError
=
true
;
continue
;
}
appId
=
static_cast
<
uint32_t
>
(
stmt
-
>
AsInt64
(
6
)
)
;
isInBrowserElement
=
static_cast
<
bool
>
(
stmt
-
>
AsInt32
(
7
)
)
;
UpgradeHostToOriginDBMigration
upHelper
(
mDBConn
&
id
)
;
rv
=
UpgradeHostToOriginAndInsert
(
host
type
permission
expireType
expireTime
modificationTime
appId
isInBrowserElement
&
upHelper
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Unexpected
failure
when
upgrading
migrating
permission
"
"
from
host
to
origin
"
)
;
migrationError
=
true
;
}
}
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
TABLE
moz_hosts_is_backup
(
dummy
INTEGER
PRIMARY
KEY
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
permsTableExists
=
false
;
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_perms
"
)
&
permsTableExists
)
;
if
(
permsTableExists
)
{
nsCOMPtr
<
mozIStorageStatement
>
countStmt
;
rv
=
mDBConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
COUNT
(
*
)
FROM
moz_perms
"
)
getter_AddRefs
(
countStmt
)
)
;
bool
hasResult
=
false
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
NS_SUCCEEDED
(
countStmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
int32_t
permsCount
=
countStmt
-
>
AsInt32
(
0
)
;
uint32_t
telemetryValue
;
if
(
permsCount
>
id
)
{
telemetryValue
=
3
;
}
else
if
(
permsCount
=
=
id
)
{
telemetryValue
=
2
;
}
else
if
(
permsCount
=
=
0
)
{
telemetryValue
=
0
;
}
else
{
telemetryValue
=
1
;
}
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
PERMISSIONS_REMIGRATION_COMPARISON
telemetryValue
)
;
}
else
{
NS_WARNING
(
"
Could
not
count
the
rows
in
moz_perms
"
)
;
}
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_perms
RENAME
TO
moz_perms_v6
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
ALTER
TABLE
moz_hosts_new
RENAME
TO
moz_perms
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDBConn
-
>
CommitTransaction
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
PERMISSIONS_MIGRATION_7_ERROR
NS_WARN_IF
(
migrationError
)
)
;
}
else
{
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
TABLE
moz_hosts
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
host
TEXT
"
"
type
TEXT
"
"
permission
INTEGER
"
"
expireType
INTEGER
"
"
expireTime
INTEGER
"
"
modificationTime
INTEGER
"
"
appId
INTEGER
"
"
isInBrowserElement
INTEGER
"
"
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
#
ifdef
DEBUG
{
bool
hostsTableExists
=
false
;
bool
permsTableExists
=
false
;
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_hosts
"
)
&
hostsTableExists
)
;
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_perms
"
)
&
permsTableExists
)
;
MOZ_ASSERT
(
hostsTableExists
&
&
permsTableExists
)
;
}
#
endif
rv
=
mDBConn
-
>
SetSchemaVersion
(
7
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_FALLTHROUGH
;
case
7
:
{
bool
hostsIsBackupExists
=
false
;
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_hosts_is_backup
"
)
&
hostsIsBackupExists
)
;
if
(
dbSchemaVersion
=
=
7
&
&
hostsIsBackupExists
)
{
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
MOZ_ASSERT
(
tldService
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
mDBConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
host
type
permission
expireType
expireTime
"
"
modificationTime
appId
isInBrowserElement
FROM
moz_hosts
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
mozIStorageStatement
>
idStmt
;
rv
=
mDBConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
MAX
(
id
)
FROM
moz_hosts
"
)
getter_AddRefs
(
idStmt
)
)
;
int64_t
id
=
0
;
bool
hasResult
=
false
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
NS_SUCCEEDED
(
idStmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
id
=
idStmt
-
>
AsInt32
(
0
)
+
1
;
}
nsAutoCString
host
type
;
uint32_t
permission
;
uint32_t
expireType
;
int64_t
expireTime
;
int64_t
modificationTime
;
uint32_t
appId
;
bool
isInBrowserElement
;
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
rv
=
stmt
-
>
GetUTF8String
(
0
host
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
nsAutoCString
eTLD1
;
rv
=
tldService
-
>
GetBaseDomainFromHost
(
host
0
eTLD1
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
continue
;
}
rv
=
stmt
-
>
GetUTF8String
(
1
type
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
permission
=
stmt
-
>
AsInt32
(
2
)
;
expireType
=
stmt
-
>
AsInt32
(
3
)
;
expireTime
=
stmt
-
>
AsInt64
(
4
)
;
modificationTime
=
stmt
-
>
AsInt64
(
5
)
;
if
(
NS_WARN_IF
(
stmt
-
>
AsInt64
(
6
)
<
0
)
)
{
continue
;
}
appId
=
static_cast
<
uint32_t
>
(
stmt
-
>
AsInt64
(
6
)
)
;
isInBrowserElement
=
static_cast
<
bool
>
(
stmt
-
>
AsInt32
(
7
)
)
;
UpgradeIPHostToOriginDB
upHelper
(
mDBConn
&
id
)
;
rv
=
UpgradeHostToOriginAndInsert
(
host
type
permission
expireType
expireTime
modificationTime
appId
isInBrowserElement
&
upHelper
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Unexpected
failure
when
upgrading
migrating
permission
"
"
from
host
to
origin
"
)
;
}
}
}
rv
=
mDBConn
-
>
SetSchemaVersion
(
8
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_FALLTHROUGH
;
case
8
:
{
bool
hostsIsBackupExists
=
false
;
mDBConn
-
>
TableExists
(
NS_LITERAL_CSTRING
(
"
moz_hosts_is_backup
"
)
&
hostsIsBackupExists
)
;
if
(
hostsIsBackupExists
)
{
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DELETE
FROM
moz_hosts
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_hosts_is_backup
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
mDBConn
-
>
SetSchemaVersion
(
9
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_FALLTHROUGH
;
case
HOSTS_SCHEMA_VERSION
:
break
;
default
:
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
mDBConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
origin
type
permission
expireType
expireTime
"
"
modificationTime
FROM
moz_perms
"
)
getter_AddRefs
(
stmt
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
break
;
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
DROP
TABLE
moz_perms
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CreateTable
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
break
;
}
}
rv
=
mDBConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
INSERT
INTO
moz_perms
"
"
(
id
origin
type
permission
expireType
"
"
expireTime
modificationTime
)
"
"
VALUES
(
?
1
?
2
?
3
?
4
?
5
?
6
?
7
)
"
)
getter_AddRefs
(
mStmtInsert
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDBConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
DELETE
FROM
moz_perms
"
"
WHERE
id
=
?
1
"
)
getter_AddRefs
(
mStmtDelete
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDBConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
UPDATE
moz_perms
"
"
SET
permission
=
?
2
expireType
=
?
3
expireTime
=
"
"
?
4
modificationTime
=
?
5
WHERE
id
=
?
1
"
)
getter_AddRefs
(
mStmtUpdate
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ImportDefaults
(
)
;
if
(
tableExists
)
return
Read
(
)
;
return
Import
(
)
;
}
nsresult
nsPermissionManager
:
:
CreateTable
(
)
{
nsresult
rv
=
mDBConn
-
>
SetSchemaVersion
(
HOSTS_SCHEMA_VERSION
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
TABLE
moz_perms
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
origin
TEXT
"
"
type
TEXT
"
"
permission
INTEGER
"
"
expireType
INTEGER
"
"
expireTime
INTEGER
"
"
modificationTime
INTEGER
"
"
)
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
mDBConn
-
>
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
CREATE
TABLE
moz_hosts
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
host
TEXT
"
"
type
TEXT
"
"
permission
INTEGER
"
"
expireType
INTEGER
"
"
expireTime
INTEGER
"
"
modificationTime
INTEGER
"
"
appId
INTEGER
"
"
isInBrowserElement
INTEGER
"
"
)
"
)
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
Add
(
nsIURI
*
aURI
const
char
*
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipal
(
aURI
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
AddFromPrincipal
(
principal
aType
aPermission
aExpireType
aExpireTime
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
AddFromPrincipal
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
)
{
ENSURE_NOT_CHILD_PROCESS
;
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
NS_ENSURE_ARG_POINTER
(
aType
)
;
NS_ENSURE_TRUE
(
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_NEVER
|
|
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_TIME
|
|
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_SESSION
|
|
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_POLICY
NS_ERROR_INVALID_ARG
)
;
if
(
(
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_TIME
|
|
(
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_SESSION
&
&
aExpireTime
!
=
0
)
)
&
&
aExpireTime
<
=
(
PR_Now
(
)
/
1000
)
)
{
return
NS_OK
;
}
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
)
{
return
NS_OK
;
}
if
(
aPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
return
NS_OK
;
}
if
(
IsExpandedPrincipal
(
aPrincipal
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
int64_t
modificationTime
=
0
;
return
AddInternal
(
aPrincipal
nsDependentCString
(
aType
)
aPermission
0
aExpireType
aExpireTime
modificationTime
eNotify
eWriteToDB
)
;
}
nsresult
nsPermissionManager
:
:
AddInternal
(
nsIPrincipal
*
aPrincipal
const
nsCString
&
aType
uint32_t
aPermission
int64_t
aID
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
NotifyOperationType
aNotifyOperation
DBOperationType
aDBOperation
const
bool
aIgnoreSessionPermissions
)
{
nsAutoCString
origin
;
nsresult
rv
=
GetOriginFromPrincipal
(
aPrincipal
origin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
IsChildProcess
(
)
)
{
IPC
:
:
Permission
permission
(
origin
aType
aPermission
aExpireType
aExpireTime
)
;
nsAutoCString
permissionKey
;
GetKeyForPermission
(
aPrincipal
aType
.
get
(
)
permissionKey
)
;
nsTArray
<
ContentParent
*
>
cplist
;
ContentParent
:
:
GetAll
(
cplist
)
;
for
(
uint32_t
i
=
0
;
i
<
cplist
.
Length
(
)
;
+
+
i
)
{
ContentParent
*
cp
=
cplist
[
i
]
;
if
(
cp
-
>
NeedsPermissionsUpdate
(
permissionKey
)
)
Unused
<
<
cp
-
>
SendAddPermission
(
permission
)
;
}
}
MOZ_ASSERT
(
PermissionAvailable
(
aPrincipal
aType
.
get
(
)
)
)
;
int32_t
typeIndex
=
GetTypeIndex
(
aType
.
get
(
)
true
)
;
NS_ENSURE_TRUE
(
typeIndex
!
=
-
1
NS_ERROR_OUT_OF_MEMORY
)
;
RefPtr
<
PermissionKey
>
key
=
PermissionKey
:
:
CreateFromPrincipal
(
aPrincipal
rv
)
;
if
(
!
key
)
{
MOZ_ASSERT
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
PermissionHashKey
*
entry
=
mPermissionTable
.
PutEntry
(
key
)
;
if
(
!
entry
)
return
NS_ERROR_FAILURE
;
if
(
!
entry
-
>
GetKey
(
)
)
{
mPermissionTable
.
RemoveEntry
(
entry
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
OperationType
op
;
int32_t
index
=
entry
-
>
GetPermissionIndex
(
typeIndex
)
;
if
(
index
=
=
-
1
)
{
if
(
aPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
op
=
eOperationNone
;
else
op
=
eOperationAdding
;
}
else
{
PermissionEntry
oldPermissionEntry
=
entry
-
>
GetPermissions
(
)
[
index
]
;
if
(
aPermission
=
=
oldPermissionEntry
.
mPermission
&
&
aExpireType
=
=
oldPermissionEntry
.
mExpireType
&
&
(
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_NEVER
|
|
aExpireTime
=
=
oldPermissionEntry
.
mExpireTime
)
)
op
=
eOperationNone
;
else
if
(
oldPermissionEntry
.
mID
=
=
cIDPermissionIsDefault
)
op
=
eOperationReplacingDefault
;
else
if
(
aID
=
=
cIDPermissionIsDefault
)
op
=
eOperationNone
;
else
if
(
aPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
op
=
eOperationRemoving
;
else
op
=
eOperationChanging
;
}
MOZ_ASSERT
(
!
IsChildProcess
(
)
|
|
aModificationTime
=
=
0
)
;
int64_t
id
;
if
(
aModificationTime
=
=
0
)
{
aModificationTime
=
PR_Now
(
)
/
1000
;
}
switch
(
op
)
{
case
eOperationNone
:
{
return
NS_OK
;
}
case
eOperationAdding
:
{
UpdateAutoplayTelemetry
(
aType
nsIPermissionManager
:
:
UNKNOWN_ACTION
aPermission
aExpireType
)
;
if
(
aDBOperation
=
=
eWriteToDB
)
{
id
=
+
+
mLargestID
;
}
else
{
id
=
aID
;
}
entry
-
>
GetPermissions
(
)
.
AppendElement
(
PermissionEntry
(
id
typeIndex
aPermission
aExpireType
aExpireTime
aModificationTime
)
)
;
if
(
IsPreloadPermission
(
mTypeArray
[
typeIndex
]
.
get
(
)
)
)
{
sPreloadPermissionCount
+
+
;
}
if
(
aDBOperation
=
=
eWriteToDB
&
&
IsPersistentExpire
(
aExpireType
)
)
{
UpdateDB
(
op
mStmtInsert
id
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
}
if
(
aNotifyOperation
=
=
eNotify
)
{
NotifyObserversWithPermission
(
aPrincipal
mTypeArray
[
typeIndex
]
aPermission
aExpireType
aExpireTime
u
"
added
"
)
;
}
break
;
}
case
eOperationRemoving
:
{
PermissionEntry
oldPermissionEntry
=
entry
-
>
GetPermissions
(
)
[
index
]
;
id
=
oldPermissionEntry
.
mID
;
if
(
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
=
=
EXPIRE_POLICY
)
{
NS_WARNING
(
"
Attempting
to
remove
EXPIRE_POLICY
permission
"
)
;
break
;
}
UpdateAutoplayTelemetry
(
aType
oldPermissionEntry
.
mPermission
nsIPermissionManager
:
:
UNKNOWN_ACTION
aExpireType
)
;
entry
-
>
GetPermissions
(
)
.
RemoveElementAt
(
index
)
;
if
(
IsPreloadPermission
(
mTypeArray
[
typeIndex
]
.
get
(
)
)
)
{
sPreloadPermissionCount
-
-
;
}
if
(
aDBOperation
=
=
eWriteToDB
)
UpdateDB
(
op
mStmtDelete
id
EmptyCString
(
)
EmptyCString
(
)
0
nsIPermissionManager
:
:
EXPIRE_NEVER
0
0
)
;
if
(
aNotifyOperation
=
=
eNotify
)
{
NotifyObserversWithPermission
(
aPrincipal
mTypeArray
[
typeIndex
]
oldPermissionEntry
.
mPermission
oldPermissionEntry
.
mExpireType
oldPermissionEntry
.
mExpireTime
u
"
deleted
"
)
;
}
if
(
entry
-
>
GetPermissions
(
)
.
IsEmpty
(
)
)
{
mPermissionTable
.
RemoveEntry
(
entry
)
;
}
break
;
}
case
eOperationChanging
:
{
id
=
entry
-
>
GetPermissions
(
)
[
index
]
.
mID
;
if
(
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
=
=
EXPIRE_POLICY
)
{
NS_WARNING
(
"
Attempting
to
modify
EXPIRE_POLICY
permission
"
)
;
break
;
}
UpdateAutoplayTelemetry
(
aType
entry
-
>
GetPermissions
(
)
[
index
]
.
mPermission
aPermission
aExpireType
)
;
if
(
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
!
=
nsIPermissionManager
:
:
EXPIRE_SESSION
&
&
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_SESSION
)
{
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionPermission
=
entry
-
>
GetPermissions
(
)
[
index
]
.
mPermission
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionExpireType
=
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionExpireTime
=
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireTime
;
}
else
if
(
aExpireType
!
=
nsIPermissionManager
:
:
EXPIRE_SESSION
)
{
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionPermission
=
aPermission
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionExpireType
=
aExpireType
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionExpireTime
=
aExpireTime
;
}
entry
-
>
GetPermissions
(
)
[
index
]
.
mPermission
=
aPermission
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
=
aExpireType
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireTime
=
aExpireTime
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mModificationTime
=
aModificationTime
;
if
(
aDBOperation
=
=
eWriteToDB
&
&
IsPersistentExpire
(
aExpireType
)
)
UpdateDB
(
op
mStmtUpdate
id
EmptyCString
(
)
EmptyCString
(
)
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
if
(
aNotifyOperation
=
=
eNotify
)
{
NotifyObserversWithPermission
(
aPrincipal
mTypeArray
[
typeIndex
]
aPermission
aExpireType
aExpireTime
u
"
changed
"
)
;
}
break
;
}
case
eOperationReplacingDefault
:
{
id
=
+
+
mLargestID
;
NS_ENSURE_TRUE
(
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
!
=
nsIPermissionManager
:
:
EXPIRE_SESSION
NS_ERROR_UNEXPECTED
)
;
NS_ENSURE_TRUE
(
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
!
=
nsIPermissionManager
:
:
EXPIRE_POLICY
NS_ERROR_UNEXPECTED
)
;
NS_ENSURE_TRUE
(
aExpireType
=
=
EXPIRE_NEVER
NS_ERROR_UNEXPECTED
)
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mID
=
id
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mPermission
=
aPermission
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
=
aExpireType
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireTime
=
aExpireTime
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mModificationTime
=
aModificationTime
;
if
(
aDBOperation
=
=
eWriteToDB
&
&
IsPersistentExpire
(
aExpireType
)
)
{
UpdateDB
(
eOperationAdding
mStmtInsert
id
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
}
if
(
aNotifyOperation
=
=
eNotify
)
{
NotifyObserversWithPermission
(
aPrincipal
mTypeArray
[
typeIndex
]
aPermission
aExpireType
aExpireTime
u
"
changed
"
)
;
}
}
break
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
Remove
(
nsIURI
*
aURI
const
char
*
aType
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipal
(
aURI
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
RemoveFromPrincipal
(
principal
aType
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
RemoveFromPrincipal
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
)
{
ENSURE_NOT_CHILD_PROCESS
;
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
NS_ENSURE_ARG_POINTER
(
aType
)
;
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
)
{
return
NS_OK
;
}
if
(
IsExpandedPrincipal
(
aPrincipal
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
AddInternal
(
aPrincipal
nsDependentCString
(
aType
)
nsIPermissionManager
:
:
UNKNOWN_ACTION
0
nsIPermissionManager
:
:
EXPIRE_NEVER
0
0
eNotify
eWriteToDB
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
RemovePermission
(
nsIPermission
*
aPerm
)
{
if
(
!
aPerm
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
aPerm
-
>
GetPrincipal
(
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
type
;
rv
=
aPerm
-
>
GetType
(
type
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
RemoveFromPrincipal
(
principal
type
.
get
(
)
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
RemoveAll
(
)
{
ENSURE_NOT_CHILD_PROCESS
;
return
RemoveAllInternal
(
true
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
RemoveAllSince
(
int64_t
aSince
)
{
ENSURE_NOT_CHILD_PROCESS
;
return
RemoveAllModifiedSince
(
aSince
)
;
}
template
<
class
T
>
nsresult
nsPermissionManager
:
:
RemovePermissionEntries
(
T
aCondition
)
{
AutoTArray
<
Pair
<
nsCOMPtr
<
nsIPrincipal
>
nsCString
>
10
>
array
;
for
(
auto
iter
=
mPermissionTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
PermissionHashKey
*
entry
=
iter
.
Get
(
)
;
for
(
const
auto
&
permEntry
:
entry
-
>
GetPermissions
(
)
)
{
if
(
!
aCondition
(
permEntry
)
)
{
continue
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
entry
-
>
GetKey
(
)
-
>
mOrigin
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
array
.
AppendElement
(
MakePair
(
principal
mTypeArray
.
ElementAt
(
permEntry
.
mType
)
)
)
;
}
}
for
(
size_t
i
=
0
;
i
<
array
.
Length
(
)
;
+
+
i
)
{
AddInternal
(
array
[
i
]
.
first
(
)
array
[
i
]
.
second
(
)
nsIPermissionManager
:
:
UNKNOWN_ACTION
0
nsIPermissionManager
:
:
EXPIRE_NEVER
0
0
nsPermissionManager
:
:
eNotify
nsPermissionManager
:
:
eWriteToDB
)
;
}
ImportDefaults
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
RemoveByType
(
const
char
*
aType
)
{
ENSURE_NOT_CHILD_PROCESS
;
int32_t
typeIndex
=
GetTypeIndex
(
aType
false
)
;
if
(
typeIndex
=
=
-
1
)
{
return
NS_OK
;
}
return
RemovePermissionEntries
(
[
typeIndex
]
(
const
PermissionEntry
&
aPermEntry
)
{
return
static_cast
<
uint32_t
>
(
typeIndex
)
=
=
aPermEntry
.
mType
;
}
)
;
}
void
nsPermissionManager
:
:
CloseDB
(
bool
aRebuildOnSuccess
)
{
mStmtInsert
=
nullptr
;
mStmtDelete
=
nullptr
;
mStmtUpdate
=
nullptr
;
if
(
mDBConn
)
{
mozIStorageCompletionCallback
*
cb
=
new
CloseDatabaseListener
(
this
aRebuildOnSuccess
)
;
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
mDBConn
-
>
AsyncClose
(
cb
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mDBConn
=
nullptr
;
}
}
nsresult
nsPermissionManager
:
:
RemoveAllFromIPC
(
)
{
MOZ_ASSERT
(
IsChildProcess
(
)
)
;
RemoveAllFromMemory
(
)
;
return
NS_OK
;
}
nsresult
nsPermissionManager
:
:
RemoveAllInternal
(
bool
aNotifyObservers
)
{
ENSURE_NOT_CHILD_PROCESS
;
nsTArray
<
ContentParent
*
>
parents
;
ContentParent
:
:
GetAll
(
parents
)
;
for
(
ContentParent
*
parent
:
parents
)
{
Unused
<
<
parent
-
>
SendRemoveAllPermissions
(
)
;
}
RemoveAllFromMemory
(
)
;
ImportDefaults
(
)
;
if
(
aNotifyObservers
)
{
NotifyObservers
(
nullptr
u
"
cleared
"
)
;
}
if
(
mDBConn
)
{
nsCOMPtr
<
mozIStorageAsyncStatement
>
removeStmt
;
nsresult
rv
=
mDBConn
-
>
CreateAsyncStatement
(
NS_LITERAL_CSTRING
(
"
DELETE
FROM
moz_perms
"
)
getter_AddRefs
(
removeStmt
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
removeStmt
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
mozIStoragePendingStatement
>
pending
;
mozIStorageStatementCallback
*
cb
=
new
DeleteFromMozHostListener
(
this
)
;
rv
=
removeStmt
-
>
ExecuteAsync
(
cb
getter_AddRefs
(
pending
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
TestExactPermission
(
nsIURI
*
aURI
const
char
*
aType
uint32_t
*
aPermission
)
{
return
CommonTestPermission
(
aURI
aType
aPermission
true
true
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
TestExactPermissionFromPrincipal
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
uint32_t
*
aPermission
)
{
return
CommonTestPermission
(
aPrincipal
aType
aPermission
true
true
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
TestExactPermanentPermission
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
uint32_t
*
aPermission
)
{
return
CommonTestPermission
(
aPrincipal
aType
aPermission
true
false
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
TestPermission
(
nsIURI
*
aURI
const
char
*
aType
uint32_t
*
aPermission
)
{
return
CommonTestPermission
(
aURI
aType
aPermission
false
true
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
TestPermissionOriginNoSuffix
(
const
nsACString
&
aOriginNoSuffix
const
char
*
aType
uint32_t
*
aPermission
)
{
return
CommonTestPermissionInternal
(
nullptr
nullptr
aOriginNoSuffix
aType
aPermission
false
true
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
TestPermissionFromWindow
(
mozIDOMWindow
*
aWindow
const
char
*
aType
uint32_t
*
aPermission
)
{
NS_ENSURE_ARG
(
aWindow
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
nsPIDOMWindowInner
:
:
From
(
aWindow
)
;
RefPtr
<
Document
>
document
=
window
-
>
GetExtantDoc
(
)
;
NS_ENSURE_TRUE
(
document
NS_NOINTERFACE
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
document
-
>
NodePrincipal
(
)
;
return
TestPermissionFromPrincipal
(
principal
aType
aPermission
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
TestPermissionFromPrincipal
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
uint32_t
*
aPermission
)
{
return
CommonTestPermission
(
aPrincipal
aType
aPermission
false
true
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
GetPermissionObjectForURI
(
nsIURI
*
aURI
const
char
*
aType
bool
aExactHostMatch
nsIPermission
*
*
aResult
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipal
(
aURI
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
GetPermissionObject
(
principal
aType
aExactHostMatch
aResult
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
GetPermissionObject
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
bool
aExactHostMatch
nsIPermission
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
NS_ENSURE_ARG_POINTER
(
aType
)
;
*
aResult
=
nullptr
;
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
)
{
return
NS_OK
;
}
if
(
IsExpandedPrincipal
(
aPrincipal
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
MOZ_ASSERT
(
PermissionAvailable
(
aPrincipal
aType
)
)
;
int32_t
typeIndex
=
GetTypeIndex
(
aType
false
)
;
if
(
typeIndex
=
=
-
1
)
return
NS_OK
;
PermissionHashKey
*
entry
=
GetPermissionHashKey
(
aPrincipal
typeIndex
aExactHostMatch
)
;
if
(
!
entry
)
{
return
NS_OK
;
}
int32_t
idx
=
entry
-
>
GetPermissionIndex
(
typeIndex
)
;
if
(
-
1
=
=
idx
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
entry
-
>
GetKey
(
)
-
>
mOrigin
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PermissionEntry
&
perm
=
entry
-
>
GetPermissions
(
)
[
idx
]
;
nsCOMPtr
<
nsIPermission
>
r
=
nsPermission
:
:
Create
(
principal
mTypeArray
.
ElementAt
(
perm
.
mType
)
perm
.
mPermission
perm
.
mExpireType
perm
.
mExpireTime
)
;
if
(
NS_WARN_IF
(
!
r
)
)
{
return
NS_ERROR_FAILURE
;
}
r
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
nsPermissionManager
:
:
CommonTestPermissionInternal
(
nsIPrincipal
*
aPrincipal
nsIURI
*
aURI
const
nsACString
&
aOriginNoSuffix
const
char
*
aType
uint32_t
*
aPermission
bool
aExactHostMatch
bool
aIncludingSession
)
{
MOZ_ASSERT
(
aPrincipal
|
|
aURI
|
|
!
aOriginNoSuffix
.
IsEmpty
(
)
)
;
MOZ_ASSERT_IF
(
aPrincipal
!
aURI
&
&
aOriginNoSuffix
.
IsEmpty
(
)
)
;
MOZ_ASSERT_IF
(
aURI
!
aPrincipal
&
&
aOriginNoSuffix
.
IsEmpty
(
)
)
;
NS_ENSURE_ARG_POINTER
(
aPrincipal
|
|
aURI
|
|
!
aOriginNoSuffix
.
IsEmpty
(
)
)
;
NS_ENSURE_ARG_POINTER
(
aType
)
;
if
(
aPrincipal
&
&
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
)
{
*
aPermission
=
nsIPermissionManager
:
:
ALLOW_ACTION
;
return
NS_OK
;
}
*
aPermission
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
if
(
HasDefaultPref
(
aType
)
)
{
int32_t
defaultPermission
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
nsresult
rv
=
mDefaultPrefBranch
-
>
GetIntPref
(
aType
&
defaultPermission
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aPermission
=
defaultPermission
;
}
}
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
;
if
(
basePrin
&
&
basePrin
-
>
Is
<
ExpandedPrincipal
>
(
)
)
{
auto
ep
=
basePrin
-
>
As
<
ExpandedPrincipal
>
(
)
;
for
(
auto
&
prin
:
ep
-
>
AllowList
(
)
)
{
uint32_t
perm
;
nsresult
rv
=
CommonTestPermission
(
prin
aType
&
perm
aExactHostMatch
aIncludingSession
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
perm
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
*
aPermission
=
perm
;
return
NS_OK
;
}
else
if
(
perm
=
=
nsIPermissionManager
:
:
PROMPT_ACTION
)
{
*
aPermission
=
perm
;
}
}
return
NS_OK
;
}
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIPrincipal
>
prin
=
aPrincipal
;
if
(
!
prin
)
{
if
(
aURI
)
{
prin
=
mozilla
:
:
BasePrincipal
:
:
CreateCodebasePrincipal
(
aURI
OriginAttributes
(
)
)
;
}
else
if
(
!
aOriginNoSuffix
.
IsEmpty
(
)
)
{
prin
=
mozilla
:
:
BasePrincipal
:
:
CreateCodebasePrincipal
(
aOriginNoSuffix
)
;
}
}
MOZ_ASSERT
(
prin
)
;
MOZ_ASSERT
(
PermissionAvailable
(
prin
aType
)
)
;
}
#
endif
int32_t
typeIndex
=
GetTypeIndex
(
aType
false
)
;
if
(
typeIndex
=
=
-
1
)
return
NS_OK
;
PermissionHashKey
*
entry
=
aPrincipal
?
GetPermissionHashKey
(
aPrincipal
typeIndex
aExactHostMatch
)
:
GetPermissionHashKey
(
aURI
aOriginNoSuffix
typeIndex
aExactHostMatch
)
;
if
(
!
entry
|
|
(
!
aIncludingSession
&
&
entry
-
>
GetPermission
(
typeIndex
)
.
mNonSessionExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_SESSION
)
)
{
return
NS_OK
;
}
*
aPermission
=
aIncludingSession
?
entry
-
>
GetPermission
(
typeIndex
)
.
mPermission
:
entry
-
>
GetPermission
(
typeIndex
)
.
mNonSessionPermission
;
return
NS_OK
;
}
nsPermissionManager
:
:
PermissionHashKey
*
nsPermissionManager
:
:
GetPermissionHashKey
(
nsIPrincipal
*
aPrincipal
uint32_t
aType
bool
aExactHostMatch
)
{
MOZ_ASSERT
(
PermissionAvailable
(
aPrincipal
mTypeArray
[
aType
]
.
get
(
)
)
)
;
nsresult
rv
;
RefPtr
<
PermissionKey
>
key
=
PermissionKey
:
:
CreateFromPrincipal
(
aPrincipal
rv
)
;
if
(
!
key
)
{
return
nullptr
;
}
PermissionHashKey
*
entry
=
mPermissionTable
.
GetEntry
(
key
)
;
if
(
entry
)
{
PermissionEntry
permEntry
=
entry
-
>
GetPermission
(
aType
)
;
if
(
(
permEntry
.
mExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_TIME
|
|
(
permEntry
.
mExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_SESSION
&
&
permEntry
.
mExpireTime
!
=
0
)
)
&
&
permEntry
.
mExpireTime
<
=
(
PR_Now
(
)
/
1000
)
)
{
entry
=
nullptr
;
RemoveFromPrincipal
(
aPrincipal
mTypeArray
[
aType
]
.
get
(
)
)
;
}
else
if
(
permEntry
.
mPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
entry
=
nullptr
;
}
}
if
(
entry
)
{
return
entry
;
}
if
(
!
aExactHostMatch
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
GetNextSubDomainPrincipal
(
aPrincipal
)
;
if
(
principal
)
{
return
GetPermissionHashKey
(
principal
aType
aExactHostMatch
)
;
}
}
return
nullptr
;
}
nsPermissionManager
:
:
PermissionHashKey
*
nsPermissionManager
:
:
GetPermissionHashKey
(
nsIURI
*
aURI
const
nsACString
&
aOriginNoSuffix
uint32_t
aType
bool
aExactHostMatch
)
{
MOZ_ASSERT
(
aURI
|
|
!
aOriginNoSuffix
.
IsEmpty
(
)
)
;
MOZ_ASSERT_IF
(
aURI
aOriginNoSuffix
.
IsEmpty
(
)
)
;
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
NS_OK
;
if
(
aURI
)
{
rv
=
GetPrincipal
(
aURI
getter_AddRefs
(
principal
)
)
;
}
else
{
principal
=
mozilla
:
:
BasePrincipal
:
:
CreateCodebasePrincipal
(
aOriginNoSuffix
)
;
}
MOZ_ASSERT_IF
(
NS_SUCCEEDED
(
rv
)
PermissionAvailable
(
principal
mTypeArray
[
aType
]
.
get
(
)
)
)
;
}
#
endif
nsresult
rv
;
RefPtr
<
PermissionKey
>
key
=
aURI
?
PermissionKey
:
:
CreateFromURI
(
aURI
rv
)
:
PermissionKey
:
:
CreateFromOriginNoSuffix
(
aOriginNoSuffix
)
;
if
(
!
key
)
{
return
nullptr
;
}
PermissionHashKey
*
entry
=
mPermissionTable
.
GetEntry
(
key
)
;
if
(
entry
)
{
PermissionEntry
permEntry
=
entry
-
>
GetPermission
(
aType
)
;
if
(
(
permEntry
.
mExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_TIME
|
|
(
permEntry
.
mExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_SESSION
&
&
permEntry
.
mExpireTime
!
=
0
)
)
&
&
permEntry
.
mExpireTime
<
=
(
PR_Now
(
)
/
1000
)
)
{
entry
=
nullptr
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
if
(
aURI
)
{
nsresult
rv
=
GetPrincipal
(
aURI
getter_AddRefs
(
principal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
else
{
principal
=
mozilla
:
:
BasePrincipal
:
:
CreateCodebasePrincipal
(
aOriginNoSuffix
)
;
}
RemoveFromPrincipal
(
principal
mTypeArray
[
aType
]
.
get
(
)
)
;
}
else
if
(
permEntry
.
mPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
entry
=
nullptr
;
}
}
if
(
entry
)
{
return
entry
;
}
if
(
!
aExactHostMatch
)
{
nsCOMPtr
<
nsIURI
>
uri
;
if
(
aURI
)
{
uri
=
GetNextSubDomainURI
(
aURI
)
;
}
else
{
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aOriginNoSuffix
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
uri
=
GetNextSubDomainURI
(
uri
)
;
}
if
(
uri
)
{
return
GetPermissionHashKey
(
uri
EmptyCString
(
)
aType
aExactHostMatch
)
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
GetEnumerator
(
nsISimpleEnumerator
*
*
aEnum
)
{
nsTArray
<
RefPtr
<
nsIPermission
>
>
array
;
nsresult
rv
=
GetAllWithTypePrefix
(
NS_LITERAL_CSTRING
(
"
"
)
array
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMArray
<
nsIPermission
>
comArray
;
comArray
.
SetCapacity
(
array
.
Length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
array
.
Length
(
)
;
i
+
+
)
{
comArray
.
AppendElement
(
array
[
i
]
.
forget
(
)
)
;
}
return
NS_NewArrayEnumerator
(
aEnum
comArray
NS_GET_IID
(
nsIPermission
)
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
GetAllWithTypePrefix
(
const
nsACString
&
aPrefix
nsTArray
<
RefPtr
<
nsIPermission
>
>
&
aResult
)
{
aResult
.
Clear
(
)
;
if
(
XRE_IsContentProcess
(
)
)
{
NS_WARNING
(
"
nsPermissionManager
'
s
getAllWithTypePrefix
is
not
available
in
the
"
"
content
process
as
not
all
permissions
may
be
available
.
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
for
(
auto
iter
=
mPermissionTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
PermissionHashKey
*
entry
=
iter
.
Get
(
)
;
for
(
const
auto
&
permEntry
:
entry
-
>
GetPermissions
(
)
)
{
if
(
permEntry
.
mPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
continue
;
}
if
(
!
aPrefix
.
IsEmpty
(
)
&
&
!
StringBeginsWith
(
mTypeArray
.
ElementAt
(
permEntry
.
mType
)
aPrefix
)
)
{
continue
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
entry
-
>
GetKey
(
)
-
>
mOrigin
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
RefPtr
<
nsIPermission
>
permission
=
nsPermission
:
:
Create
(
principal
mTypeArray
.
ElementAt
(
permEntry
.
mType
)
permEntry
.
mPermission
permEntry
.
mExpireType
permEntry
.
mExpireTime
)
;
if
(
NS_WARN_IF
(
!
permission
)
)
{
continue
;
}
aResult
.
AppendElement
(
std
:
:
move
(
permission
)
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
GetAllForURI
(
nsIURI
*
aURI
nsISimpleEnumerator
*
*
aEnum
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipal
(
aURI
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
GetAllForPrincipal
(
principal
aEnum
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
GetAllForPrincipal
(
nsIPrincipal
*
aPrincipal
nsISimpleEnumerator
*
*
aEnum
)
{
nsCOMArray
<
nsIPermission
>
array
;
MOZ_ASSERT
(
PermissionAvailable
(
aPrincipal
nullptr
)
)
;
nsresult
rv
;
RefPtr
<
PermissionKey
>
key
=
PermissionKey
:
:
CreateFromPrincipal
(
aPrincipal
rv
)
;
if
(
!
key
)
{
MOZ_ASSERT
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
PermissionHashKey
*
entry
=
mPermissionTable
.
GetEntry
(
key
)
;
if
(
entry
)
{
for
(
const
auto
&
permEntry
:
entry
-
>
GetPermissions
(
)
)
{
if
(
permEntry
.
mPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
continue
;
}
nsCOMPtr
<
nsIPermission
>
permission
=
nsPermission
:
:
Create
(
aPrincipal
mTypeArray
.
ElementAt
(
permEntry
.
mType
)
permEntry
.
mPermission
permEntry
.
mExpireType
permEntry
.
mExpireTime
)
;
if
(
NS_WARN_IF
(
!
permission
)
)
{
continue
;
}
array
.
AppendObject
(
permission
)
;
}
}
return
NS_NewArrayEnumerator
(
aEnum
array
NS_GET_IID
(
nsIPermission
)
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
ENSURE_NOT_CHILD_PROCESS
;
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
)
{
mIsShuttingDown
=
true
;
RemoveAllFromMemory
(
)
;
CloseDB
(
false
)
;
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
profile
-
do
-
change
"
)
)
{
InitDB
(
false
)
;
}
return
NS_OK
;
}
nsresult
nsPermissionManager
:
:
RemoveAllModifiedSince
(
int64_t
aModificationTime
)
{
ENSURE_NOT_CHILD_PROCESS
;
return
RemovePermissionEntries
(
[
aModificationTime
]
(
const
PermissionEntry
&
aPermEntry
)
{
return
aModificationTime
<
=
aPermEntry
.
mModificationTime
;
}
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
RemovePermissionsWithAttributes
(
const
nsAString
&
aPattern
)
{
ENSURE_NOT_CHILD_PROCESS
;
mozilla
:
:
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
RemovePermissionsWithAttributes
(
pattern
)
;
}
nsresult
nsPermissionManager
:
:
RemovePermissionsWithAttributes
(
mozilla
:
:
OriginAttributesPattern
&
aPattern
)
{
AutoTArray
<
Pair
<
nsCOMPtr
<
nsIPrincipal
>
nsCString
>
10
>
permissions
;
for
(
auto
iter
=
mPermissionTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
PermissionHashKey
*
entry
=
iter
.
Get
(
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
entry
-
>
GetKey
(
)
-
>
mOrigin
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
if
(
!
aPattern
.
Matches
(
principal
-
>
OriginAttributesRef
(
)
)
)
{
continue
;
}
for
(
const
auto
&
permEntry
:
entry
-
>
GetPermissions
(
)
)
{
permissions
.
AppendElement
(
MakePair
(
principal
mTypeArray
.
ElementAt
(
permEntry
.
mType
)
)
)
;
}
}
for
(
size_t
i
=
0
;
i
<
permissions
.
Length
(
)
;
+
+
i
)
{
AddInternal
(
permissions
[
i
]
.
first
(
)
permissions
[
i
]
.
second
(
)
nsIPermissionManager
:
:
UNKNOWN_ACTION
0
nsIPermissionManager
:
:
EXPIRE_NEVER
0
0
nsPermissionManager
:
:
eNotify
nsPermissionManager
:
:
eWriteToDB
)
;
}
return
NS_OK
;
}
nsresult
nsPermissionManager
:
:
RemoveAllFromMemory
(
)
{
mLargestID
=
0
;
mTypeArray
.
Clear
(
)
;
mPermissionTable
.
Clear
(
)
;
return
NS_OK
;
}
int32_t
nsPermissionManager
:
:
GetTypeIndex
(
const
char
*
aType
bool
aAdd
)
{
for
(
uint32_t
i
=
0
;
i
<
mTypeArray
.
Length
(
)
;
+
+
i
)
if
(
mTypeArray
[
i
]
.
Equals
(
aType
)
)
return
i
;
if
(
!
aAdd
)
{
return
-
1
;
}
nsCString
*
elem
=
mTypeArray
.
AppendElement
(
)
;
if
(
!
elem
)
return
-
1
;
elem
-
>
Assign
(
aType
)
;
return
mTypeArray
.
Length
(
)
-
1
;
}
void
nsPermissionManager
:
:
NotifyObserversWithPermission
(
nsIPrincipal
*
aPrincipal
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
const
char16_t
*
aData
)
{
nsCOMPtr
<
nsIPermission
>
permission
=
nsPermission
:
:
Create
(
aPrincipal
aType
aPermission
aExpireType
aExpireTime
)
;
if
(
permission
)
NotifyObservers
(
permission
aData
)
;
}
void
nsPermissionManager
:
:
NotifyObservers
(
nsIPermission
*
aPermission
const
char16_t
*
aData
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
observerService
-
>
NotifyObservers
(
aPermission
kPermissionChangeNotification
aData
)
;
}
nsresult
nsPermissionManager
:
:
Read
(
)
{
ENSURE_NOT_CHILD_PROCESS
;
nsresult
rv
;
{
nsCOMPtr
<
mozIStorageStatement
>
stmtDeleteExpired
;
rv
=
mDBConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
DELETE
FROM
moz_perms
WHERE
expireType
=
?
1
AND
expireTime
<
=
?
2
"
)
getter_AddRefs
(
stmtDeleteExpired
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmtDeleteExpired
-
>
BindInt32ByIndex
(
0
nsIPermissionManager
:
:
EXPIRE_TIME
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmtDeleteExpired
-
>
BindInt64ByIndex
(
1
PR_Now
(
)
/
1000
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasResult
;
rv
=
stmtDeleteExpired
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
mDBConn
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
id
origin
type
permission
expireType
"
"
expireTime
modificationTime
"
"
FROM
moz_perms
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int64_t
id
;
nsAutoCString
origin
type
;
uint32_t
permission
;
uint32_t
expireType
;
int64_t
expireTime
;
int64_t
modificationTime
;
bool
hasResult
;
bool
readError
=
false
;
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
id
=
stmt
-
>
AsInt64
(
0
)
;
if
(
id
>
mLargestID
)
mLargestID
=
id
;
rv
=
stmt
-
>
GetUTF8String
(
1
origin
)
;
if
(
NS_FAILED
(
rv
)
)
{
readError
=
true
;
continue
;
}
rv
=
stmt
-
>
GetUTF8String
(
2
type
)
;
if
(
NS_FAILED
(
rv
)
)
{
readError
=
true
;
continue
;
}
permission
=
stmt
-
>
AsInt32
(
3
)
;
expireType
=
stmt
-
>
AsInt32
(
4
)
;
expireTime
=
stmt
-
>
AsInt64
(
5
)
;
modificationTime
=
stmt
-
>
AsInt64
(
6
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
origin
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
readError
=
true
;
continue
;
}
rv
=
AddInternal
(
principal
type
permission
id
expireType
expireTime
modificationTime
eDontNotify
eNoDBOperation
)
;
if
(
NS_FAILED
(
rv
)
)
{
readError
=
true
;
continue
;
}
}
if
(
readError
)
{
NS_ERROR
(
"
Error
occured
while
reading
the
permissions
database
!
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
static
const
char
kMatchTypeHost
[
]
=
"
host
"
;
static
const
char
kMatchTypeOrigin
[
]
=
"
origin
"
;
nsresult
nsPermissionManager
:
:
Import
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
permissionsFile
;
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
permissionsFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
permissionsFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
HOSTPERM_FILE_NAME
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
fileInputStream
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
fileInputStream
)
permissionsFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
_DoImport
(
fileInputStream
mDBConn
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
permissionsFile
-
>
Remove
(
false
)
;
return
NS_OK
;
}
nsresult
nsPermissionManager
:
:
ImportDefaults
(
)
{
nsAutoCString
defaultsURL
;
mozilla
:
:
Preferences
:
:
GetCString
(
kDefaultsUrlPrefName
defaultsURL
)
;
if
(
defaultsURL
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
defaultsURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
defaultsURI
)
defaultsURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
defaultsURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
inputStream
;
rv
=
channel
-
>
Open2
(
getter_AddRefs
(
inputStream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
_DoImport
(
inputStream
nullptr
)
;
inputStream
-
>
Close
(
)
;
return
rv
;
}
nsresult
nsPermissionManager
:
:
_DoImport
(
nsIInputStream
*
inputStream
mozIStorageConnection
*
conn
)
{
ENSURE_NOT_CHILD_PROCESS
;
nsresult
rv
;
mozStorageTransaction
transaction
(
conn
true
)
;
DBOperationType
operation
=
conn
?
eWriteToDB
:
eNoDBOperation
;
int64_t
id
=
conn
?
0
:
cIDPermissionIsDefault
;
nsLineBuffer
<
char
>
lineBuffer
;
nsCString
line
;
bool
isMore
=
true
;
do
{
rv
=
NS_ReadLine
(
inputStream
&
lineBuffer
line
&
isMore
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
line
.
IsEmpty
(
)
|
|
line
.
First
(
)
=
=
'
#
'
)
{
continue
;
}
nsTArray
<
nsCString
>
lineArray
;
ParseString
(
line
'
\
t
'
lineArray
)
;
if
(
lineArray
[
0
]
.
EqualsLiteral
(
kMatchTypeHost
)
&
&
lineArray
.
Length
(
)
=
=
4
)
{
nsresult
error
=
NS_OK
;
uint32_t
permission
=
lineArray
[
2
]
.
ToInteger
(
&
error
)
;
if
(
NS_FAILED
(
error
)
)
continue
;
int64_t
modificationTime
=
0
;
UpgradeHostToOriginHostfileImport
upHelper
(
this
operation
id
)
;
error
=
UpgradeHostToOriginAndInsert
(
lineArray
[
3
]
lineArray
[
1
]
permission
nsIPermissionManager
:
:
EXPIRE_NEVER
0
modificationTime
nsIScriptSecurityManager
:
:
NO_APP_ID
false
&
upHelper
)
;
if
(
NS_FAILED
(
error
)
)
{
NS_WARNING
(
"
There
was
a
problem
importing
a
host
permission
"
)
;
}
}
else
if
(
lineArray
[
0
]
.
EqualsLiteral
(
kMatchTypeOrigin
)
&
&
lineArray
.
Length
(
)
=
=
4
)
{
nsresult
error
=
NS_OK
;
uint32_t
permission
=
lineArray
[
2
]
.
ToInteger
(
&
error
)
;
if
(
NS_FAILED
(
error
)
)
continue
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
error
=
GetPrincipalFromOrigin
(
lineArray
[
3
]
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
error
)
)
{
NS_WARNING
(
"
Couldn
'
t
import
an
origin
permission
-
malformed
origin
"
)
;
continue
;
}
int64_t
modificationTime
=
0
;
error
=
AddInternal
(
principal
lineArray
[
1
]
permission
id
nsIPermissionManager
:
:
EXPIRE_NEVER
0
modificationTime
eDontNotify
operation
)
;
if
(
NS_FAILED
(
error
)
)
{
NS_WARNING
(
"
There
was
a
problem
importing
an
origin
permission
"
)
;
}
}
}
while
(
isMore
)
;
return
NS_OK
;
}
void
nsPermissionManager
:
:
UpdateDB
(
OperationType
aOp
mozIStorageAsyncStatement
*
aStmt
int64_t
aID
const
nsACString
&
aOrigin
const
nsACString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
{
ENSURE_NOT_CHILD_PROCESS_NORET
;
nsresult
rv
;
if
(
!
aStmt
)
return
;
switch
(
aOp
)
{
case
eOperationAdding
:
{
rv
=
aStmt
-
>
BindInt64ByIndex
(
0
aID
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
aStmt
-
>
BindUTF8StringByIndex
(
1
aOrigin
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
aStmt
-
>
BindUTF8StringByIndex
(
2
aType
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
aStmt
-
>
BindInt32ByIndex
(
3
aPermission
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
aStmt
-
>
BindInt32ByIndex
(
4
aExpireType
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
aStmt
-
>
BindInt64ByIndex
(
5
aExpireTime
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
aStmt
-
>
BindInt64ByIndex
(
6
aModificationTime
)
;
break
;
}
case
eOperationRemoving
:
{
rv
=
aStmt
-
>
BindInt64ByIndex
(
0
aID
)
;
break
;
}
case
eOperationChanging
:
{
rv
=
aStmt
-
>
BindInt64ByIndex
(
0
aID
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
aStmt
-
>
BindInt32ByIndex
(
1
aPermission
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
aStmt
-
>
BindInt32ByIndex
(
2
aExpireType
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
aStmt
-
>
BindInt64ByIndex
(
3
aExpireTime
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
aStmt
-
>
BindInt64ByIndex
(
4
aModificationTime
)
;
break
;
}
default
:
{
MOZ_ASSERT_UNREACHABLE
(
"
need
a
valid
operation
in
UpdateDB
(
)
!
"
)
;
rv
=
NS_ERROR_UNEXPECTED
;
break
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
db
change
failed
!
"
)
;
return
;
}
nsCOMPtr
<
mozIStoragePendingStatement
>
pending
;
rv
=
aStmt
-
>
ExecuteAsync
(
nullptr
getter_AddRefs
(
pending
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
UpdateExpireTime
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
bool
aExactHostMatch
uint64_t
aSessionExpireTime
uint64_t
aPersistentExpireTime
)
{
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
NS_ENSURE_ARG_POINTER
(
aType
)
;
uint64_t
nowms
=
PR_Now
(
)
/
1000
;
if
(
aSessionExpireTime
<
nowms
|
|
aPersistentExpireTime
<
nowms
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
)
{
return
NS_OK
;
}
if
(
IsExpandedPrincipal
(
aPrincipal
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
MOZ_ASSERT
(
PermissionAvailable
(
aPrincipal
aType
)
)
;
int32_t
typeIndex
=
GetTypeIndex
(
aType
false
)
;
if
(
typeIndex
=
=
-
1
)
return
NS_OK
;
PermissionHashKey
*
entry
=
GetPermissionHashKey
(
aPrincipal
typeIndex
aExactHostMatch
)
;
if
(
!
entry
)
{
return
NS_OK
;
}
int32_t
idx
=
entry
-
>
GetPermissionIndex
(
typeIndex
)
;
if
(
-
1
=
=
idx
)
{
return
NS_OK
;
}
PermissionEntry
&
perm
=
entry
-
>
GetPermissions
(
)
[
idx
]
;
if
(
perm
.
mExpireType
=
=
EXPIRE_TIME
)
{
perm
.
mExpireTime
=
aPersistentExpireTime
;
}
else
if
(
perm
.
mExpireType
=
=
EXPIRE_SESSION
&
&
perm
.
mExpireTime
!
=
0
)
{
perm
.
mExpireTime
=
aSessionExpireTime
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
GetPermissionsWithKey
(
const
nsACString
&
aPermissionKey
nsTArray
<
IPC
:
:
Permission
>
&
aPerms
)
{
aPerms
.
Clear
(
)
;
if
(
NS_WARN_IF
(
XRE_IsContentProcess
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
for
(
auto
iter
=
mPermissionTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
PermissionHashKey
*
entry
=
iter
.
Get
(
)
;
nsAutoCString
permissionKey
;
GetKeyForOrigin
(
entry
-
>
GetKey
(
)
-
>
mOrigin
permissionKey
)
;
if
(
aPermissionKey
!
=
permissionKey
&
&
!
aPermissionKey
.
IsEmpty
(
)
)
{
continue
;
}
for
(
const
auto
&
permEntry
:
entry
-
>
GetPermissions
(
)
)
{
if
(
permEntry
.
mPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
continue
;
}
bool
isPreload
=
IsPreloadPermission
(
mTypeArray
[
permEntry
.
mType
]
.
get
(
)
)
;
if
(
(
isPreload
&
&
aPermissionKey
.
IsEmpty
(
)
)
|
|
(
!
isPreload
&
&
aPermissionKey
=
=
permissionKey
)
)
{
aPerms
.
AppendElement
(
IPC
:
:
Permission
(
entry
-
>
GetKey
(
)
-
>
mOrigin
mTypeArray
.
ElementAt
(
permEntry
.
mType
)
permEntry
.
mPermission
permEntry
.
mExpireType
permEntry
.
mExpireTime
)
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
SetPermissionsWithKey
(
const
nsACString
&
aPermissionKey
nsTArray
<
IPC
:
:
Permission
>
&
aPerms
)
{
if
(
NS_WARN_IF
(
XRE_IsParentProcess
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
GenericPromise
:
:
Private
>
promise
;
bool
foundKey
=
mPermissionKeyPromiseMap
.
Get
(
aPermissionKey
getter_AddRefs
(
promise
)
)
;
if
(
promise
)
{
MOZ_ASSERT
(
foundKey
)
;
promise
-
>
Resolve
(
true
__func__
)
;
}
else
if
(
foundKey
)
{
return
NS_OK
;
}
mPermissionKeyPromiseMap
.
Put
(
aPermissionKey
nullptr
)
;
for
(
IPC
:
:
Permission
&
perm
:
aPerms
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
perm
.
origin
getter_AddRefs
(
principal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
#
ifdef
DEBUG
nsAutoCString
permissionKey
;
GetKeyForPermission
(
principal
perm
.
type
.
get
(
)
permissionKey
)
;
MOZ_ASSERT
(
permissionKey
=
=
aPermissionKey
"
The
permission
keys
which
were
sent
over
should
match
!
"
)
;
#
endif
uint64_t
modificationTime
=
0
;
AddInternal
(
principal
perm
.
type
perm
.
capability
0
perm
.
expireType
perm
.
expireTime
modificationTime
eNotify
eNoDBOperation
true
)
;
}
return
NS_OK
;
}
void
nsPermissionManager
:
:
GetKeyForOrigin
(
const
nsACString
&
aOrigin
nsACString
&
aKey
)
{
aKey
.
Truncate
(
)
;
if
(
!
StringBeginsWith
(
aOrigin
NS_LITERAL_CSTRING
(
"
http
:
"
)
)
&
&
!
StringBeginsWith
(
aOrigin
NS_LITERAL_CSTRING
(
"
https
:
"
)
)
&
&
!
StringBeginsWith
(
aOrigin
NS_LITERAL_CSTRING
(
"
ftp
:
"
)
)
)
{
return
;
}
OriginAttributes
attrs
;
if
(
!
attrs
.
PopulateFromOrigin
(
aOrigin
aKey
)
)
{
aKey
.
Truncate
(
)
;
return
;
}
attrs
.
mPrivateBrowsingId
=
0
;
attrs
.
StripAttributes
(
OriginAttributes
:
:
STRIP_USER_CONTEXT_ID
|
OriginAttributes
:
:
STRIP_FIRST_PARTY_DOMAIN
)
;
#
ifdef
DEBUG
nsCOMPtr
<
nsIPrincipal
>
dbgPrincipal
;
MOZ_ALWAYS_SUCCEEDS
(
GetPrincipalFromOrigin
(
aOrigin
getter_AddRefs
(
dbgPrincipal
)
)
)
;
nsCOMPtr
<
nsIURI
>
dbgUri
;
MOZ_ALWAYS_SUCCEEDS
(
dbgPrincipal
-
>
GetURI
(
getter_AddRefs
(
dbgUri
)
)
)
;
nsAutoCString
dbgScheme
;
MOZ_ALWAYS_SUCCEEDS
(
dbgUri
-
>
GetScheme
(
dbgScheme
)
)
;
MOZ_ASSERT
(
dbgScheme
.
EqualsLiteral
(
"
http
"
)
|
|
dbgScheme
.
EqualsLiteral
(
"
https
"
)
|
|
dbgScheme
.
EqualsLiteral
(
"
ftp
"
)
)
;
MOZ_ASSERT
(
dbgPrincipal
-
>
OriginAttributesRef
(
)
=
=
attrs
)
;
#
endif
nsAutoCString
suffix
;
attrs
.
CreateSuffix
(
suffix
)
;
aKey
.
Append
(
suffix
)
;
}
void
nsPermissionManager
:
:
GetKeyForPrincipal
(
nsIPrincipal
*
aPrincipal
nsACString
&
aKey
)
{
nsAutoCString
origin
;
nsresult
rv
=
aPrincipal
-
>
GetOrigin
(
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aKey
.
Truncate
(
)
;
return
;
}
GetKeyForOrigin
(
origin
aKey
)
;
}
void
nsPermissionManager
:
:
GetKeyForPermission
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
nsACString
&
aKey
)
{
if
(
IsPreloadPermission
(
aType
)
)
{
aKey
.
Truncate
(
)
;
return
;
}
GetKeyForPrincipal
(
aPrincipal
aKey
)
;
}
nsTArray
<
nsCString
>
nsPermissionManager
:
:
GetAllKeysForPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
aPrincipal
)
;
nsTArray
<
nsCString
>
keys
;
nsCOMPtr
<
nsIPrincipal
>
prin
=
aPrincipal
;
while
(
prin
)
{
nsCString
*
key
=
keys
.
AppendElement
(
)
;
GetKeyForPrincipal
(
prin
*
key
)
;
prin
=
GetNextSubDomainPrincipal
(
prin
)
;
}
MOZ_ASSERT
(
keys
.
Length
(
)
>
=
1
"
Every
principal
should
have
at
least
one
key
.
"
)
;
return
keys
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
BroadcastPermissionsForPrincipalToAllContentProcesses
(
nsIPrincipal
*
aPrincipal
)
{
nsTArray
<
ContentParent
*
>
cps
;
ContentParent
:
:
GetAll
(
cps
)
;
for
(
ContentParent
*
cp
:
cps
)
{
nsresult
rv
=
cp
-
>
TransmitPermissionsForPrincipal
(
aPrincipal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
bool
nsPermissionManager
:
:
PermissionAvailable
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
)
{
if
(
XRE_IsContentProcess
(
)
)
{
nsAutoCString
permissionKey
;
GetKeyForPermission
(
aPrincipal
aType
permissionKey
)
;
RefPtr
<
GenericPromise
:
:
Private
>
promise
;
if
(
!
mPermissionKeyPromiseMap
.
Get
(
permissionKey
getter_AddRefs
(
promise
)
)
|
|
promise
)
{
NS_WARNING
(
nsPrintfCString
(
"
This
content
process
hasn
'
t
received
the
"
"
permissions
for
%
s
yet
"
permissionKey
.
get
(
)
)
.
get
(
)
)
;
return
false
;
}
}
return
true
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
WhenPermissionsAvailable
(
nsIPrincipal
*
aPrincipal
nsIRunnable
*
aRunnable
)
{
MOZ_ASSERT
(
aRunnable
)
;
if
(
!
XRE_IsContentProcess
(
)
)
{
aRunnable
-
>
Run
(
)
;
return
NS_OK
;
}
nsTArray
<
RefPtr
<
GenericPromise
>
>
promises
;
for
(
auto
&
key
:
GetAllKeysForPrincipal
(
aPrincipal
)
)
{
RefPtr
<
GenericPromise
:
:
Private
>
promise
;
if
(
!
mPermissionKeyPromiseMap
.
Get
(
key
getter_AddRefs
(
promise
)
)
)
{
promise
=
new
GenericPromise
:
:
Private
(
__func__
)
;
mPermissionKeyPromiseMap
.
Put
(
key
RefPtr
<
GenericPromise
:
:
Private
>
(
promise
)
.
forget
(
)
)
;
}
if
(
promise
)
{
promises
.
AppendElement
(
std
:
:
move
(
promise
)
)
;
}
}
if
(
promises
.
IsEmpty
(
)
)
{
aRunnable
-
>
Run
(
)
;
return
NS_OK
;
}
auto
*
thread
=
SystemGroup
:
:
AbstractMainThreadFor
(
TaskCategory
:
:
Other
)
;
RefPtr
<
nsIRunnable
>
runnable
=
aRunnable
;
GenericPromise
:
:
All
(
thread
promises
)
-
>
Then
(
thread
__func__
[
runnable
]
(
)
{
runnable
-
>
Run
(
)
;
}
[
]
(
)
{
NS_WARNING
(
"
nsPermissionManager
permission
promise
rejected
.
We
'
re
"
"
probably
shutting
down
.
"
)
;
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPermissionManager
:
:
GetHasPreloadPermissions
(
bool
*
aResult
)
{
*
aResult
=
sPreloadPermissionCount
>
0
;
return
NS_OK
;
}
