#
include
"
nsContentBlocker
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
define
BEHAVIOR_ACCEPT
nsIPermissionManager
:
:
ALLOW_ACTION
#
define
BEHAVIOR_REJECT
nsIPermissionManager
:
:
DENY_ACTION
#
define
BEHAVIOR_NOFOREIGN
3
static
const
nsLiteralCString
kTypeString
[
]
=
{
NS_LITERAL_CSTRING
(
"
other
"
)
NS_LITERAL_CSTRING
(
"
script
"
)
NS_LITERAL_CSTRING
(
"
image
"
)
NS_LITERAL_CSTRING
(
"
stylesheet
"
)
NS_LITERAL_CSTRING
(
"
object
"
)
NS_LITERAL_CSTRING
(
"
document
"
)
NS_LITERAL_CSTRING
(
"
subdocument
"
)
NS_LITERAL_CSTRING
(
"
refresh
"
)
NS_LITERAL_CSTRING
(
"
xbl
"
)
NS_LITERAL_CSTRING
(
"
ping
"
)
NS_LITERAL_CSTRING
(
"
xmlhttprequest
"
)
NS_LITERAL_CSTRING
(
"
objectsubrequest
"
)
NS_LITERAL_CSTRING
(
"
dtd
"
)
NS_LITERAL_CSTRING
(
"
font
"
)
NS_LITERAL_CSTRING
(
"
media
"
)
NS_LITERAL_CSTRING
(
"
websocket
"
)
NS_LITERAL_CSTRING
(
"
csp_report
"
)
NS_LITERAL_CSTRING
(
"
xslt
"
)
NS_LITERAL_CSTRING
(
"
beacon
"
)
NS_LITERAL_CSTRING
(
"
fetch
"
)
NS_LITERAL_CSTRING
(
"
image
"
)
NS_LITERAL_CSTRING
(
"
manifest
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
saveas_download
"
)
NS_LITERAL_CSTRING
(
"
speculative
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
NS_LITERAL_CSTRING
(
"
"
)
}
;
#
define
NUMBER_OF_TYPES
MOZ_ARRAY_LENGTH
(
kTypeString
)
uint8_t
nsContentBlocker
:
:
mBehaviorPref
[
NUMBER_OF_TYPES
]
;
NS_IMPL_ISUPPORTS
(
nsContentBlocker
nsIContentPolicy
nsIObserver
nsISupportsWeakReference
)
nsContentBlocker
:
:
nsContentBlocker
(
)
{
memset
(
mBehaviorPref
BEHAVIOR_ACCEPT
NUMBER_OF_TYPES
)
;
}
nsresult
nsContentBlocker
:
:
Init
(
)
{
mPermissionManager
=
nsPermissionManager
:
:
GetInstance
(
)
;
if
(
!
mPermissionManager
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsresult
rv
;
nsCOMPtr
<
nsIPrefService
>
prefService
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
;
rv
=
prefService
-
>
GetBranch
(
"
permissions
.
default
.
"
getter_AddRefs
(
prefBranch
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrefBranch
>
oldPrefBranch
;
oldPrefBranch
=
do_QueryInterface
(
prefService
)
;
int32_t
oldPref
;
rv
=
oldPrefBranch
-
>
GetIntPref
(
"
network
.
image
.
imageBehavior
"
&
oldPref
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
oldPref
)
{
int32_t
newPref
;
switch
(
oldPref
)
{
default
:
newPref
=
BEHAVIOR_ACCEPT
;
break
;
case
1
:
newPref
=
BEHAVIOR_NOFOREIGN
;
break
;
case
2
:
newPref
=
BEHAVIOR_REJECT
;
break
;
}
prefBranch
-
>
SetIntPref
(
"
image
"
newPref
)
;
oldPrefBranch
-
>
ClearUserPref
(
"
network
.
image
.
imageBehavior
"
)
;
}
mPrefBranchInternal
=
prefBranch
;
rv
=
mPrefBranchInternal
-
>
AddObserver
(
"
"
this
true
)
;
PrefChanged
(
prefBranch
nullptr
)
;
return
rv
;
}
#
undef
LIMIT
#
define
LIMIT
(
x
low
high
default
)
\
(
(
x
)
>
=
(
low
)
&
&
(
x
)
<
=
(
high
)
?
(
x
)
:
(
default
)
)
void
nsContentBlocker
:
:
PrefChanged
(
nsIPrefBranch
*
aPrefBranch
const
char
*
aPref
)
{
int32_t
val
;
#
define
PREF_CHANGED
(
_P
)
(
!
aPref
|
|
!
strcmp
(
aPref
_P
)
)
for
(
uint32_t
i
=
0
;
i
<
NUMBER_OF_TYPES
;
+
+
i
)
{
if
(
!
kTypeString
[
i
]
.
IsEmpty
(
)
&
&
PREF_CHANGED
(
kTypeString
[
i
]
.
get
(
)
)
&
&
NS_SUCCEEDED
(
aPrefBranch
-
>
GetIntPref
(
kTypeString
[
i
]
.
get
(
)
&
val
)
)
)
{
mBehaviorPref
[
i
]
=
LIMIT
(
val
1
3
1
)
;
}
}
}
NS_IMETHODIMP
nsContentBlocker
:
:
ShouldLoad
(
nsIURI
*
aContentLocation
nsILoadInfo
*
aLoadInfo
const
nsACString
&
aMimeGuess
int16_t
*
aDecision
)
{
uint32_t
contentType
=
aLoadInfo
-
>
GetExternalContentPolicyType
(
)
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
aLoadInfo
-
>
LoadingPrincipal
(
)
;
nsCOMPtr
<
nsIURI
>
requestingLocation
;
if
(
loadingPrincipal
)
{
loadingPrincipal
-
>
GetURI
(
getter_AddRefs
(
requestingLocation
)
)
;
}
MOZ_ASSERT
(
contentType
=
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternal
(
contentType
)
"
We
should
only
see
external
content
policy
types
here
.
"
)
;
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
;
if
(
contentType
>
NUMBER_OF_TYPES
)
return
NS_OK
;
if
(
!
aContentLocation
)
return
NS_OK
;
if
(
contentType
=
=
nsIContentPolicy
:
:
TYPE_OBJECT
)
return
NS_OK
;
nsAutoCString
scheme
;
aContentLocation
-
>
GetScheme
(
scheme
)
;
if
(
!
scheme
.
LowerCaseEqualsLiteral
(
"
ftp
"
)
&
&
!
scheme
.
LowerCaseEqualsLiteral
(
"
http
"
)
&
&
!
scheme
.
LowerCaseEqualsLiteral
(
"
https
"
)
)
return
NS_OK
;
bool
shouldLoad
fromPrefs
;
rv
=
TestPermission
(
aContentLocation
requestingLocation
contentType
&
shouldLoad
&
fromPrefs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
shouldLoad
)
{
NS_SetRequestBlockingReason
(
aLoadInfo
nsILoadInfo
:
:
BLOCKING_REASON_CONTENT_POLICY_CONTENT_BLOCKED
)
;
if
(
fromPrefs
)
{
*
aDecision
=
nsIContentPolicy
:
:
REJECT_TYPE
;
}
else
{
*
aDecision
=
nsIContentPolicy
:
:
REJECT_SERVER
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsContentBlocker
:
:
ShouldProcess
(
nsIURI
*
aContentLocation
nsILoadInfo
*
aLoadInfo
const
nsACString
&
aMimeGuess
int16_t
*
aDecision
)
{
uint32_t
contentType
=
aLoadInfo
-
>
GetExternalContentPolicyType
(
)
;
nsCOMPtr
<
nsISupports
>
requestingContext
=
aLoadInfo
-
>
GetLoadingContext
(
)
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
aLoadInfo
-
>
LoadingPrincipal
(
)
;
nsCOMPtr
<
nsIURI
>
requestingLocation
;
if
(
loadingPrincipal
)
{
loadingPrincipal
-
>
GetURI
(
getter_AddRefs
(
requestingLocation
)
)
;
}
MOZ_ASSERT
(
contentType
=
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternal
(
contentType
)
"
We
should
only
see
external
content
policy
types
here
.
"
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
item
=
NS_CP_GetDocShellFromContext
(
requestingContext
)
;
if
(
item
&
&
item
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
return
NS_OK
;
}
if
(
contentType
=
=
nsIContentPolicy
:
:
TYPE_OBJECT
)
{
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
bool
shouldLoad
fromPrefs
;
nsresult
rv
=
TestPermission
(
aContentLocation
requestingLocation
contentType
&
shouldLoad
&
fromPrefs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
shouldLoad
)
{
NS_SetRequestBlockingReason
(
aLoadInfo
nsILoadInfo
:
:
BLOCKING_REASON_CONTENT_POLICY_CONTENT_BLOCKED
)
;
if
(
fromPrefs
)
{
*
aDecision
=
nsIContentPolicy
:
:
REJECT_TYPE
;
}
else
{
*
aDecision
=
nsIContentPolicy
:
:
REJECT_SERVER
;
}
}
return
NS_OK
;
}
return
ShouldLoad
(
aContentLocation
aLoadInfo
aMimeGuess
aDecision
)
;
}
nsresult
nsContentBlocker
:
:
TestPermission
(
nsIURI
*
aCurrentURI
nsIURI
*
aFirstURI
int32_t
aContentType
bool
*
aPermission
bool
*
aFromPrefs
)
{
*
aFromPrefs
=
false
;
nsresult
rv
;
if
(
kTypeString
[
aContentType
-
1
]
.
IsEmpty
(
)
)
{
*
aPermission
=
false
;
return
NS_OK
;
}
*
aPermission
=
true
;
uint32_t
permission
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
if
(
mPermissionManager
-
>
HasPreloadPermissions
(
)
)
{
rv
=
mPermissionManager
-
>
LegacyTestPermissionFromURI
(
aCurrentURI
nullptr
kTypeString
[
aContentType
-
1
]
&
permission
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
permission
)
{
permission
=
mBehaviorPref
[
aContentType
-
1
]
;
*
aFromPrefs
=
true
;
}
switch
(
permission
)
{
case
BEHAVIOR_ACCEPT
:
*
aPermission
=
true
;
break
;
case
BEHAVIOR_REJECT
:
*
aPermission
=
false
;
break
;
case
BEHAVIOR_NOFOREIGN
:
if
(
!
aFirstURI
)
return
NS_OK
;
if
(
aFirstURI
-
>
SchemeIs
(
"
chrome
"
)
|
|
aFirstURI
-
>
SchemeIs
(
"
resource
"
)
)
{
return
NS_OK
;
}
nsAutoCString
currentHost
;
rv
=
aCurrentURI
-
>
GetAsciiHost
(
currentHost
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
dot
=
currentHost
.
RFindChar
(
'
.
'
)
;
dot
=
currentHost
.
RFindChar
(
'
.
'
dot
-
1
)
;
+
+
dot
;
const
nsACString
&
tail
=
Substring
(
currentHost
dot
currentHost
.
Length
(
)
-
dot
)
;
nsAutoCString
firstHost
;
rv
=
aFirstURI
-
>
GetAsciiHost
(
firstHost
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
firstHost
.
Length
(
)
<
tail
.
Length
(
)
)
{
*
aPermission
=
false
;
return
NS_OK
;
}
const
nsACString
&
firstTail
=
Substring
(
firstHost
firstHost
.
Length
(
)
-
tail
.
Length
(
)
tail
.
Length
(
)
)
;
if
(
(
firstHost
.
Length
(
)
>
tail
.
Length
(
)
&
&
firstHost
.
CharAt
(
firstHost
.
Length
(
)
-
tail
.
Length
(
)
-
1
)
!
=
'
.
'
)
|
|
!
tail
.
Equals
(
firstTail
)
)
{
*
aPermission
=
false
;
}
break
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsContentBlocker
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
NS_ASSERTION
(
!
strcmp
(
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
aTopic
)
"
unexpected
topic
-
we
only
deal
with
pref
changes
!
"
)
;
if
(
mPrefBranchInternal
)
PrefChanged
(
mPrefBranchInternal
NS_LossyConvertUTF16toASCII
(
aData
)
.
get
(
)
)
;
return
NS_OK
;
}
