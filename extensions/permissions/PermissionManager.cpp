#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ContentPrincipal
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
ExpandedPrincipal
.
h
"
#
include
"
mozilla
/
net
/
NeckoMessageUtils
.
h
"
#
include
"
mozilla
/
Permission
.
h
"
#
include
"
mozilla
/
PermissionManager
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_permissions
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozIStorageService
.
h
"
#
include
"
mozIStorageConnection
.
h
"
#
include
"
mozIStorageStatement
.
h
"
#
include
"
mozStorageCID
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsEffectiveTLDService
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIUserIdleService
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsINavHistoryService
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsIWritablePropertyBag2
.
h
"
#
include
"
nsReadLine
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
"
nsToolkitCompsCID
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
#
define
PERMISSIONS_FILE_NAME
"
permissions
.
sqlite
"
#
define
HOSTS_SCHEMA_VERSION
12
constexpr
char
kDefaultsUrlPrefName
[
]
=
"
permissions
.
manager
.
defaultsUrl
"
;
constexpr
char
kPermissionChangeNotification
[
]
=
PERM_CHANGE_NOTIFICATION
;
constexpr
int64_t
cIDPermissionIsDefault
=
-
1
;
static
StaticRefPtr
<
PermissionManager
>
gPermissionManager
;
#
define
ENSURE_NOT_CHILD_PROCESS_
(
onError
)
\
PR_BEGIN_MACRO
\
if
(
IsChildProcess
(
)
)
{
\
NS_ERROR
(
"
Cannot
perform
action
in
content
process
!
"
)
;
\
onError
\
}
\
PR_END_MACRO
#
define
ENSURE_NOT_CHILD_PROCESS
\
ENSURE_NOT_CHILD_PROCESS_
(
{
return
NS_ERROR_NOT_AVAILABLE
;
}
)
#
define
ENSURE_NOT_CHILD_PROCESS_NORET
ENSURE_NOT_CHILD_PROCESS_
(
;
)
#
define
EXPIRY_NOW
PR_Now
(
)
/
1000
namespace
{
bool
IsChildProcess
(
)
{
return
XRE_IsContentProcess
(
)
;
}
void
LogToConsole
(
const
nsAString
&
aMsg
)
{
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
)
)
;
if
(
!
console
)
{
NS_WARNING
(
"
Failed
to
log
message
to
console
.
"
)
;
return
;
}
nsAutoString
msg
(
aMsg
)
;
console
-
>
LogStringMessage
(
msg
.
get
(
)
)
;
}
bool
HasDefaultPref
(
const
nsACString
&
aType
)
{
static
const
nsLiteralCString
kPermissionsWithDefaults
[
]
=
{
"
camera
"
_ns
"
microphone
"
_ns
"
geo
"
_ns
"
desktop
-
notification
"
_ns
"
shortcuts
"
_ns
}
;
if
(
!
aType
.
IsEmpty
(
)
)
{
for
(
const
auto
&
perm
:
kPermissionsWithDefaults
)
{
if
(
perm
.
Equals
(
aType
)
)
{
return
true
;
}
}
}
return
false
;
}
static
const
nsLiteralCString
kPreloadPermissions
[
]
=
{
"
cookie
"
_ns
}
;
bool
IsPreloadPermission
(
const
nsACString
&
aType
)
{
if
(
!
aType
.
IsEmpty
(
)
)
{
for
(
const
auto
&
perm
:
kPreloadPermissions
)
{
if
(
perm
.
Equals
(
aType
)
)
{
return
true
;
}
}
}
return
false
;
}
static
constexpr
std
:
:
array
<
nsLiteralCString
1
>
kStripOAPermissions
=
{
{
"
cookie
"
_ns
}
}
;
bool
IsOAForceStripPermission
(
const
nsACString
&
aType
)
{
if
(
aType
.
IsEmpty
(
)
)
{
return
false
;
}
for
(
const
auto
&
perm
:
kStripOAPermissions
)
{
if
(
perm
.
Equals
(
aType
)
)
{
return
true
;
}
}
return
false
;
}
static
constexpr
std
:
:
array
<
nsLiteralCString
3
>
kSiteScopedPermissions
=
{
{
"
3rdPartyStorage
^
"
_ns
"
AllowStorageAccessRequest
^
"
_ns
"
3rdPartyFrameStorage
^
"
_ns
}
}
;
bool
IsSiteScopedPermission
(
const
nsACString
&
aType
)
{
if
(
aType
.
IsEmpty
(
)
)
{
return
false
;
}
for
(
const
auto
&
perm
:
kSiteScopedPermissions
)
{
if
(
aType
.
Length
(
)
>
=
perm
.
Length
(
)
&
&
Substring
(
aType
0
perm
.
Length
(
)
)
=
=
perm
)
{
return
true
;
}
}
return
false
;
}
void
OriginAppendOASuffix
(
OriginAttributes
aOriginAttributes
bool
aForceStripOA
nsACString
&
aOrigin
)
{
PermissionManager
:
:
MaybeStripOriginAttributes
(
aForceStripOA
aOriginAttributes
)
;
nsAutoCString
oaSuffix
;
aOriginAttributes
.
CreateSuffix
(
oaSuffix
)
;
aOrigin
.
Append
(
oaSuffix
)
;
}
nsresult
GetOriginFromPrincipal
(
nsIPrincipal
*
aPrincipal
bool
aForceStripOA
nsACString
&
aOrigin
)
{
nsresult
rv
=
aPrincipal
-
>
GetOriginNoSuffix
(
aOrigin
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
suffix
;
rv
=
aPrincipal
-
>
GetOriginSuffix
(
suffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
attrs
;
NS_ENSURE_TRUE
(
attrs
.
PopulateFromSuffix
(
suffix
)
NS_ERROR_FAILURE
)
;
OriginAppendOASuffix
(
attrs
aForceStripOA
aOrigin
)
;
return
NS_OK
;
}
nsresult
GetSiteFromPrincipal
(
nsIPrincipal
*
aPrincipal
bool
aForceStripOA
nsACString
&
aSite
)
{
nsCOMPtr
<
nsIURI
>
uri
=
aPrincipal
-
>
GetURI
(
)
;
nsEffectiveTLDService
*
etld
=
nsEffectiveTLDService
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE
(
etld
NS_ERROR_FAILURE
)
;
NS_ENSURE_TRUE
(
uri
NS_ERROR_FAILURE
)
;
nsresult
rv
=
etld
-
>
GetSite
(
uri
aSite
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
aPrincipal
-
>
GetOrigin
(
aSite
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsAutoCString
suffix
;
rv
=
aPrincipal
-
>
GetOriginSuffix
(
suffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
attrs
;
NS_ENSURE_TRUE
(
attrs
.
PopulateFromSuffix
(
suffix
)
NS_ERROR_FAILURE
)
;
OriginAppendOASuffix
(
attrs
aForceStripOA
aSite
)
;
return
NS_OK
;
}
nsresult
GetOriginFromURIAndOA
(
nsIURI
*
aURI
const
OriginAttributes
*
aOriginAttributes
bool
aForceStripOA
nsACString
&
aOrigin
)
{
nsAutoCString
origin
(
aOrigin
)
;
nsresult
rv
=
ContentPrincipal
:
:
GenerateOriginNoSuffixFromURI
(
aURI
origin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAppendOASuffix
(
*
aOriginAttributes
aForceStripOA
origin
)
;
aOrigin
=
origin
;
return
NS_OK
;
}
nsresult
GetPrincipalFromOrigin
(
const
nsACString
&
aOrigin
bool
aForceStripOA
nsIPrincipal
*
*
aPrincipal
)
{
nsAutoCString
originNoSuffix
;
OriginAttributes
attrs
;
if
(
!
attrs
.
PopulateFromOrigin
(
aOrigin
originNoSuffix
)
)
{
return
NS_ERROR_FAILURE
;
}
PermissionManager
:
:
MaybeStripOriginAttributes
(
aForceStripOA
attrs
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
originNoSuffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
uri
attrs
)
;
principal
.
forget
(
aPrincipal
)
;
return
NS_OK
;
}
nsresult
GetPrincipal
(
nsIURI
*
aURI
bool
aIsInIsolatedMozBrowserElement
nsIPrincipal
*
*
aPrincipal
)
{
OriginAttributes
attrs
(
aIsInIsolatedMozBrowserElement
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
aURI
attrs
)
;
NS_ENSURE_TRUE
(
principal
NS_ERROR_FAILURE
)
;
principal
.
forget
(
aPrincipal
)
;
return
NS_OK
;
}
nsresult
GetPrincipal
(
nsIURI
*
aURI
nsIPrincipal
*
*
aPrincipal
)
{
OriginAttributes
attrs
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
aURI
attrs
)
;
NS_ENSURE_TRUE
(
principal
NS_ERROR_FAILURE
)
;
principal
.
forget
(
aPrincipal
)
;
return
NS_OK
;
}
nsCString
GetNextSubDomainForHost
(
const
nsACString
&
aHost
)
{
nsCString
subDomain
;
nsresult
rv
=
nsEffectiveTLDService
:
:
GetInstance
(
)
-
>
GetNextSubDomain
(
aHost
subDomain
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
"
"
_ns
;
}
return
subDomain
;
}
already_AddRefed
<
nsIURI
>
GetNextSubDomainURI
(
nsIURI
*
aURI
)
{
nsAutoCString
host
;
nsresult
rv
=
aURI
-
>
GetHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
nsCString
domain
=
GetNextSubDomainForHost
(
host
)
;
if
(
domain
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_MutateURI
(
aURI
)
.
SetHost
(
domain
)
.
Finalize
(
uri
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
uri
)
{
return
nullptr
;
}
return
uri
.
forget
(
)
;
}
nsresult
UpgradeHostToOriginAndInsert
(
const
nsACString
&
aHost
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
bool
aIsInIsolatedMozBrowserElement
std
:
:
function
<
nsresult
(
const
nsACString
&
aOrigin
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
>
&
&
aCallback
)
{
if
(
aHost
.
EqualsLiteral
(
"
<
file
>
"
)
)
{
NS_WARNING
(
"
The
magic
host
<
file
>
is
no
longer
supported
.
"
"
It
is
being
removed
from
the
permissions
database
.
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aHost
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
uri
-
>
SchemeIs
(
"
moz
-
nullprincipal
"
)
)
{
NS_WARNING
(
"
A
moz
-
nullprincipal
:
permission
is
being
discarded
.
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
GetPrincipal
(
uri
aIsInIsolatedMozBrowserElement
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
origin
;
rv
=
GetOriginFromPrincipal
(
principal
IsOAForceStripPermission
(
aType
)
origin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aCallback
(
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
return
NS_OK
;
}
bool
foundHistory
=
false
;
nsCOMPtr
<
nsINavHistoryService
>
histSrv
=
do_GetService
(
NS_NAVHISTORYSERVICE_CONTRACTID
)
;
if
(
histSrv
)
{
nsCOMPtr
<
nsINavHistoryQuery
>
histQuery
;
rv
=
histSrv
-
>
GetNewQuery
(
getter_AddRefs
(
histQuery
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
eTLD1
;
rv
=
nsEffectiveTLDService
:
:
GetInstance
(
)
-
>
GetBaseDomainFromHost
(
aHost
0
eTLD1
)
;
if
(
NS_FAILED
(
rv
)
)
{
eTLD1
=
aHost
;
}
rv
=
histQuery
-
>
SetDomain
(
eTLD1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
histQuery
-
>
SetDomainIsHost
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINavHistoryQueryOptions
>
histQueryOpts
;
rv
=
histSrv
-
>
GetNewQueryOptions
(
getter_AddRefs
(
histQueryOpts
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
histQueryOpts
-
>
SetResultType
(
nsINavHistoryQueryOptions
:
:
RESULTS_AS_URI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
histQueryOpts
-
>
SetQueryType
(
nsINavHistoryQueryOptions
:
:
QUERY_TYPE_HISTORY
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
histQueryOpts
-
>
SetIncludeHidden
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINavHistoryResult
>
histResult
;
rv
=
histSrv
-
>
ExecuteQuery
(
histQuery
histQueryOpts
getter_AddRefs
(
histResult
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINavHistoryContainerResultNode
>
histResultContainer
;
rv
=
histResult
-
>
GetRoot
(
getter_AddRefs
(
histResultContainer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
histResultContainer
-
>
SetContainerOpen
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
childCount
=
0
;
rv
=
histResultContainer
-
>
GetChildCount
(
&
childCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsTHashSet
<
nsCString
>
insertedOrigins
;
for
(
uint32_t
i
=
0
;
i
<
childCount
;
i
+
+
)
{
nsCOMPtr
<
nsINavHistoryResultNode
>
child
;
histResultContainer
-
>
GetChild
(
i
getter_AddRefs
(
child
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
uint32_t
type
;
rv
=
child
-
>
GetType
(
&
type
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
type
!
=
nsINavHistoryResultNode
:
:
RESULT_TYPE_URI
)
{
NS_WARNING
(
"
Unexpected
non
-
RESULT_TYPE_URI
node
in
"
"
UpgradeHostToOriginAndInsert
(
)
"
)
;
continue
;
}
nsAutoCString
uriSpec
;
rv
=
child
-
>
GetUri
(
uriSpec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
uriSpec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
rv
=
NS_MutateURI
(
uri
)
.
SetHost
(
aHost
)
.
Finalize
(
uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
GetPrincipal
(
uri
aIsInIsolatedMozBrowserElement
getter_AddRefs
(
principal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
nsAutoCString
origin
;
rv
=
GetOriginFromPrincipal
(
principal
IsOAForceStripPermission
(
aType
)
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
continue
;
if
(
insertedOrigins
.
Contains
(
origin
)
)
{
continue
;
}
foundHistory
=
true
;
rv
=
aCallback
(
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Insert
failed
"
)
;
insertedOrigins
.
Insert
(
origin
)
;
}
rv
=
histResultContainer
-
>
SetContainerOpen
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
foundHistory
)
{
nsAutoCString
hostSegment
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsAutoCString
origin
;
if
(
aHost
.
FindChar
(
'
:
'
)
!
=
-
1
)
{
hostSegment
.
AssignLiteral
(
"
[
"
)
;
hostSegment
.
Append
(
aHost
)
;
hostSegment
.
AppendLiteral
(
"
]
"
)
;
}
else
{
hostSegment
.
Assign
(
aHost
)
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
"
http
:
/
/
"
_ns
+
hostSegment
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetPrincipal
(
uri
aIsInIsolatedMozBrowserElement
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetOriginFromPrincipal
(
principal
IsOAForceStripPermission
(
aType
)
origin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aCallback
(
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
"
https
:
/
/
"
_ns
+
hostSegment
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetPrincipal
(
uri
aIsInIsolatedMozBrowserElement
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetOriginFromPrincipal
(
principal
IsOAForceStripPermission
(
aType
)
origin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aCallback
(
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
}
return
NS_OK
;
}
bool
IsExpandedPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
nsCOMPtr
<
nsIExpandedPrincipal
>
ep
=
do_QueryInterface
(
aPrincipal
)
;
return
!
!
ep
;
}
bool
IsPersistentExpire
(
uint32_t
aExpire
const
nsACString
&
aType
)
{
bool
res
=
(
aExpire
!
=
nsIPermissionManager
:
:
EXPIRE_SESSION
&
&
aExpire
!
=
nsIPermissionManager
:
:
EXPIRE_POLICY
)
;
return
res
;
}
}
PermissionManager
:
:
PermissionKey
*
PermissionManager
:
:
PermissionKey
:
:
CreateFromPrincipal
(
nsIPrincipal
*
aPrincipal
bool
aForceStripOA
bool
aScopeToSite
nsresult
&
aResult
)
{
nsAutoCString
keyString
;
if
(
aScopeToSite
)
{
aResult
=
GetSiteFromPrincipal
(
aPrincipal
aForceStripOA
keyString
)
;
}
else
{
aResult
=
GetOriginFromPrincipal
(
aPrincipal
aForceStripOA
keyString
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
aResult
)
)
)
{
return
nullptr
;
}
return
new
PermissionKey
(
keyString
)
;
}
PermissionManager
:
:
PermissionKey
*
PermissionManager
:
:
PermissionKey
:
:
CreateFromURIAndOriginAttributes
(
nsIURI
*
aURI
const
OriginAttributes
*
aOriginAttributes
bool
aForceStripOA
nsresult
&
aResult
)
{
nsAutoCString
origin
;
aResult
=
GetOriginFromURIAndOA
(
aURI
aOriginAttributes
aForceStripOA
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aResult
)
)
)
{
return
nullptr
;
}
return
new
PermissionKey
(
origin
)
;
}
PermissionManager
:
:
PermissionKey
*
PermissionManager
:
:
PermissionKey
:
:
CreateFromURI
(
nsIURI
*
aURI
nsresult
&
aResult
)
{
nsAutoCString
origin
;
aResult
=
ContentPrincipal
:
:
GenerateOriginNoSuffixFromURI
(
aURI
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aResult
)
)
)
{
return
nullptr
;
}
return
new
PermissionKey
(
origin
)
;
}
NS_IMPL_ISUPPORTS
(
PermissionManager
nsIPermissionManager
nsIObserver
nsISupportsWeakReference
nsIAsyncShutdownBlocker
)
PermissionManager
:
:
PermissionManager
(
)
:
mMonitor
(
"
PermissionManager
:
:
mMonitor
"
)
mState
(
eInitializing
)
mMemoryOnlyDB
(
false
)
mLargestID
(
0
)
{
}
PermissionManager
:
:
~
PermissionManager
(
)
{
for
(
const
auto
&
promise
:
mPermissionKeyPromiseMap
.
Values
(
)
)
{
if
(
promise
)
{
promise
-
>
Reject
(
NS_ERROR_FAILURE
__func__
)
;
}
}
mPermissionKeyPromiseMap
.
Clear
(
)
;
if
(
mThread
)
{
mThread
-
>
Shutdown
(
)
;
mThread
=
nullptr
;
}
}
StaticMutex
PermissionManager
:
:
sCreationMutex
;
already_AddRefed
<
nsIPermissionManager
>
PermissionManager
:
:
GetXPCOMSingleton
(
)
{
StaticMutexAutoLock
lock
(
sCreationMutex
)
;
if
(
gPermissionManager
)
{
return
do_AddRef
(
gPermissionManager
)
;
}
auto
permManager
=
MakeRefPtr
<
PermissionManager
>
(
)
;
if
(
NS_SUCCEEDED
(
permManager
-
>
Init
(
)
)
)
{
gPermissionManager
=
permManager
.
get
(
)
;
return
permManager
.
forget
(
)
;
}
return
nullptr
;
}
PermissionManager
*
PermissionManager
:
:
GetInstance
(
)
{
if
(
!
gPermissionManager
)
{
nsCOMPtr
<
nsIPermissionManager
>
permManager
=
GetXPCOMSingleton
(
)
;
}
return
gPermissionManager
;
}
nsresult
PermissionManager
:
:
Init
(
)
{
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
XPCOMWillShutdown
)
)
{
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
mMemoryOnlyDB
=
Preferences
:
:
GetBool
(
"
permissions
.
memory_only
"
false
)
;
nsresult
rv
;
nsCOMPtr
<
nsIPrefService
>
prefService
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
prefService
-
>
GetBranch
(
"
permissions
.
default
.
"
getter_AddRefs
(
mDefaultPrefBranch
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
IsChildProcess
(
)
)
{
mState
=
eReady
;
ClearOnShutdown
(
&
gPermissionManager
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
this
"
profile
-
do
-
change
"
true
)
;
observerService
-
>
AddObserver
(
this
"
testonly
-
reload
-
permissions
-
from
-
disk
"
true
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsIAsyncShutdownClient
>
asc
=
GetAsyncShutdownBarrier
(
)
;
if
(
!
asc
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoString
blockerName
;
MOZ_ALWAYS_SUCCEEDS
(
GetName
(
blockerName
)
)
;
nsresult
rv
=
asc
-
>
AddBlocker
(
this
NS_LITERAL_STRING_FROM_CSTRING
(
__FILE__
)
__LINE__
blockerName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
AddIdleDailyMaintenanceJob
(
)
;
MOZ_ASSERT
(
!
mThread
)
;
NS_ENSURE_SUCCESS
(
NS_NewNamedThread
(
"
Permission
"
getter_AddRefs
(
mThread
)
)
NS_ERROR_FAILURE
)
;
PRThread
*
prThread
;
MOZ_ALWAYS_SUCCEEDS
(
mThread
-
>
GetPRThread
(
&
prThread
)
)
;
MOZ_ASSERT
(
prThread
)
;
mThreadBoundData
.
Transfer
(
prThread
)
;
InitDB
(
false
)
;
return
NS_OK
;
}
nsresult
PermissionManager
:
:
OpenDatabase
(
nsIFile
*
aPermissionsFile
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
auto
data
=
mThreadBoundData
.
Access
(
)
;
nsresult
rv
;
nsCOMPtr
<
mozIStorageService
>
storage
=
do_GetService
(
MOZ_STORAGE_SERVICE_CONTRACTID
)
;
if
(
!
storage
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
mMemoryOnlyDB
)
{
rv
=
storage
-
>
OpenSpecialDatabase
(
kMozStorageMemoryStorageKey
VoidCString
(
)
mozIStorageService
:
:
CONNECTION_DEFAULT
getter_AddRefs
(
data
-
>
mDBConn
)
)
;
}
else
{
rv
=
storage
-
>
OpenDatabase
(
aPermissionsFile
mozIStorageService
:
:
CONNECTION_DEFAULT
getter_AddRefs
(
data
-
>
mDBConn
)
)
;
}
return
rv
;
}
void
PermissionManager
:
:
InitDB
(
bool
aRemoveFile
)
{
mState
=
eInitializing
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
mReadEntries
.
Clear
(
)
;
}
auto
readyIfFailed
=
MakeScopeExit
(
[
&
]
(
)
{
mState
=
eReady
;
}
)
;
if
(
!
mPermissionsFile
)
{
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_PERMISSION_PARENT_DIR
getter_AddRefs
(
mPermissionsFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
mPermissionsFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
}
rv
=
mPermissionsFile
-
>
AppendNative
(
nsLiteralCString
(
PERMISSIONS_FILE_NAME
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
nsCOMPtr
<
nsIInputStream
>
defaultsInputStream
=
GetDefaultsInputStream
(
)
;
RefPtr
<
PermissionManager
>
self
=
this
;
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
PermissionManager
:
:
InitDB
"
[
self
aRemoveFile
defaultsInputStream
]
{
nsresult
rv
=
self
-
>
TryInitDB
(
aRemoveFile
defaultsInputStream
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
PermissionManager
:
:
InitDB
-
MainThread
"
[
self
]
{
self
-
>
EnsureReadCompleted
(
)
;
}
)
)
;
self
-
>
mMonitor
.
Notify
(
)
;
}
)
)
;
readyIfFailed
.
release
(
)
;
}
nsresult
PermissionManager
:
:
TryInitDB
(
bool
aRemoveFile
nsIInputStream
*
aDefaultsInputStream
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
auto
raii
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
aDefaultsInputStream
)
{
aDefaultsInputStream
-
>
Close
(
)
;
}
mState
=
eDBInitialized
;
}
)
;
auto
data
=
mThreadBoundData
.
Access
(
)
;
auto
raiiFailure
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
data
-
>
mDBConn
)
{
DebugOnly
<
nsresult
>
rv
=
data
-
>
mDBConn
-
>
Close
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
data
-
>
mDBConn
=
nullptr
;
}
}
)
;
nsresult
rv
;
if
(
aRemoveFile
)
{
bool
exists
=
false
;
rv
=
mPermissionsFile
-
>
Exists
(
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
exists
)
{
rv
=
mPermissionsFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
rv
=
OpenDatabase
(
mPermissionsFile
)
;
if
(
rv
=
=
NS_ERROR_FILE_CORRUPTED
)
{
LogToConsole
(
u
"
permissions
.
sqlite
is
corrupted
!
Try
again
!
"
_ns
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
PERMISSIONS_SQL_CORRUPTED
1
)
;
rv
=
mPermissionsFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LogToConsole
(
u
"
Corrupted
permissions
.
sqlite
has
been
removed
.
"
_ns
)
;
rv
=
OpenDatabase
(
mPermissionsFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LogToConsole
(
u
"
OpenDatabase
to
permissions
.
sqlite
is
successful
!
"
_ns
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
ready
;
data
-
>
mDBConn
-
>
GetConnectionReady
(
&
ready
)
;
if
(
!
ready
)
{
LogToConsole
(
nsLiteralString
(
u
"
Fail
to
get
connection
to
permissions
.
sqlite
!
Try
again
!
"
)
)
;
rv
=
mPermissionsFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LogToConsole
(
u
"
Defective
permissions
.
sqlite
has
been
removed
.
"
_ns
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
DEFECTIVE_PERMISSIONS_SQL_REMOVED
1
)
;
rv
=
OpenDatabase
(
mPermissionsFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LogToConsole
(
u
"
OpenDatabase
to
permissions
.
sqlite
is
successful
!
"
_ns
)
;
data
-
>
mDBConn
-
>
GetConnectionReady
(
&
ready
)
;
if
(
!
ready
)
return
NS_ERROR_UNEXPECTED
;
}
bool
tableExists
=
false
;
data
-
>
mDBConn
-
>
TableExists
(
"
moz_perms
"
_ns
&
tableExists
)
;
if
(
!
tableExists
)
{
data
-
>
mDBConn
-
>
TableExists
(
"
moz_hosts
"
_ns
&
tableExists
)
;
}
if
(
!
tableExists
)
{
rv
=
CreateTable
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
int32_t
dbSchemaVersion
;
rv
=
data
-
>
mDBConn
-
>
GetSchemaVersion
(
&
dbSchemaVersion
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
switch
(
dbSchemaVersion
)
{
case
1
:
{
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
"
ALTER
TABLE
moz_hosts
ADD
expireType
INTEGER
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
"
ALTER
TABLE
moz_hosts
ADD
expireTime
INTEGER
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
[
[
fallthrough
]
]
;
case
0
:
case
2
:
{
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
"
ALTER
TABLE
moz_hosts
ADD
appId
INTEGER
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
moz_hosts
ADD
isInBrowserElement
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
data
-
>
mDBConn
-
>
SetSchemaVersion
(
3
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
[
[
fallthrough
]
]
;
case
3
:
{
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
moz_hosts
ADD
modificationTime
INTEGER
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
data
-
>
mDBConn
-
>
SetSchemaVersion
(
4
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
[
[
fallthrough
]
]
;
case
5
:
if
(
dbSchemaVersion
=
=
5
)
{
bool
permsTableExists
=
false
;
data
-
>
mDBConn
-
>
TableExists
(
"
moz_perms
"
_ns
&
permsTableExists
)
;
if
(
!
permsTableExists
)
{
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
"
ALTER
TABLE
moz_hosts
RENAME
TO
moz_perms
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
NS_WARNING
(
"
moz_hosts
was
not
renamed
to
moz_perms
"
"
as
a
moz_perms
table
already
exists
"
)
;
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
"
DROP
TABLE
moz_hosts
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
#
ifdef
DEBUG
bool
hostsTableExists
=
false
;
data
-
>
mDBConn
-
>
TableExists
(
"
moz_hosts
"
_ns
&
hostsTableExists
)
;
MOZ_ASSERT
(
!
hostsTableExists
)
;
#
endif
bool
v4TableExists
=
false
;
data
-
>
mDBConn
-
>
TableExists
(
"
moz_hosts_v4
"
_ns
&
v4TableExists
)
;
if
(
v4TableExists
)
{
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
moz_hosts_v4
RENAME
TO
moz_hosts
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
data
-
>
mDBConn
-
>
SetSchemaVersion
(
6
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
[
[
fallthrough
]
]
;
case
4
:
case
6
:
{
bool
hostsTableExists
=
false
;
data
-
>
mDBConn
-
>
TableExists
(
"
moz_hosts
"
_ns
&
hostsTableExists
)
;
if
(
hostsTableExists
)
{
rv
=
data
-
>
mDBConn
-
>
BeginTransaction
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
tableExists
=
false
;
data
-
>
mDBConn
-
>
TableExists
(
"
moz_hosts_new
"
_ns
&
tableExists
)
;
if
(
tableExists
)
{
NS_WARNING
(
"
The
temporary
database
moz_hosts_new
already
exists
"
"
dropping
"
"
it
.
"
)
;
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
"
DROP
TABLE
moz_hosts_new
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
CREATE
TABLE
moz_hosts_new
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
origin
TEXT
"
"
type
TEXT
"
"
permission
INTEGER
"
"
expireType
INTEGER
"
"
expireTime
INTEGER
"
"
modificationTime
INTEGER
"
"
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
SELECT
host
type
permission
expireType
"
"
expireTime
"
"
modificationTime
isInBrowserElement
FROM
moz_hosts
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int64_t
id
=
0
;
bool
hasResult
;
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
MigrationEntry
entry
;
rv
=
stmt
-
>
GetUTF8String
(
0
entry
.
mHost
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
rv
=
stmt
-
>
GetUTF8String
(
1
entry
.
mType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
entry
.
mId
=
id
+
+
;
entry
.
mPermission
=
stmt
-
>
AsInt32
(
2
)
;
entry
.
mExpireType
=
stmt
-
>
AsInt32
(
3
)
;
entry
.
mExpireTime
=
stmt
-
>
AsInt64
(
4
)
;
entry
.
mModificationTime
=
stmt
-
>
AsInt64
(
5
)
;
entry
.
mIsInBrowserElement
=
static_cast
<
bool
>
(
stmt
-
>
AsInt32
(
6
)
)
;
mMigrationEntries
.
AppendElement
(
entry
)
;
}
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
CREATE
TABLE
moz_hosts_is_backup
(
dummy
"
"
INTEGER
PRIMARY
KEY
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
permsTableExists
=
false
;
data
-
>
mDBConn
-
>
TableExists
(
"
moz_perms
"
_ns
&
permsTableExists
)
;
if
(
permsTableExists
)
{
nsCOMPtr
<
mozIStorageStatement
>
countStmt
;
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
"
SELECT
COUNT
(
*
)
FROM
moz_perms
"
_ns
getter_AddRefs
(
countStmt
)
)
;
bool
hasResult
=
false
;
if
(
NS_FAILED
(
rv
)
|
|
NS_FAILED
(
countStmt
-
>
ExecuteStep
(
&
hasResult
)
)
|
|
!
hasResult
)
{
NS_WARNING
(
"
Could
not
count
the
rows
in
moz_perms
"
)
;
}
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
moz_perms
RENAME
TO
moz_perms_v6
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
moz_hosts_new
RENAME
TO
moz_perms
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
data
-
>
mDBConn
-
>
CommitTransaction
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
CREATE
TABLE
moz_hosts
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
host
TEXT
"
"
type
TEXT
"
"
permission
INTEGER
"
"
expireType
INTEGER
"
"
expireTime
INTEGER
"
"
modificationTime
INTEGER
"
"
appId
INTEGER
"
"
isInBrowserElement
INTEGER
"
"
)
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
#
ifdef
DEBUG
{
bool
hostsTableExists
=
false
;
bool
permsTableExists
=
false
;
data
-
>
mDBConn
-
>
TableExists
(
"
moz_hosts
"
_ns
&
hostsTableExists
)
;
data
-
>
mDBConn
-
>
TableExists
(
"
moz_perms
"
_ns
&
permsTableExists
)
;
MOZ_ASSERT
(
hostsTableExists
&
&
permsTableExists
)
;
}
#
endif
rv
=
data
-
>
mDBConn
-
>
SetSchemaVersion
(
7
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
[
[
fallthrough
]
]
;
case
7
:
{
bool
hostsIsBackupExists
=
false
;
data
-
>
mDBConn
-
>
TableExists
(
"
moz_hosts_is_backup
"
_ns
&
hostsIsBackupExists
)
;
if
(
dbSchemaVersion
=
=
7
&
&
hostsIsBackupExists
)
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
SELECT
host
type
permission
expireType
"
"
expireTime
"
"
modificationTime
isInBrowserElement
FROM
moz_hosts
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
mozIStorageStatement
>
idStmt
;
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
"
SELECT
MAX
(
id
)
FROM
moz_hosts
"
_ns
getter_AddRefs
(
idStmt
)
)
;
int64_t
id
=
0
;
bool
hasResult
=
false
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
NS_SUCCEEDED
(
idStmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
id
=
idStmt
-
>
AsInt32
(
0
)
+
1
;
}
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
MigrationEntry
entry
;
rv
=
stmt
-
>
GetUTF8String
(
0
entry
.
mHost
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
nsAutoCString
eTLD1
;
rv
=
nsEffectiveTLDService
:
:
GetInstance
(
)
-
>
GetBaseDomainFromHost
(
entry
.
mHost
0
eTLD1
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
continue
;
}
rv
=
stmt
-
>
GetUTF8String
(
1
entry
.
mType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
entry
.
mId
=
id
+
+
;
entry
.
mPermission
=
stmt
-
>
AsInt32
(
2
)
;
entry
.
mExpireType
=
stmt
-
>
AsInt32
(
3
)
;
entry
.
mExpireTime
=
stmt
-
>
AsInt64
(
4
)
;
entry
.
mModificationTime
=
stmt
-
>
AsInt64
(
5
)
;
entry
.
mIsInBrowserElement
=
static_cast
<
bool
>
(
stmt
-
>
AsInt32
(
6
)
)
;
mMigrationEntries
.
AppendElement
(
entry
)
;
}
}
rv
=
data
-
>
mDBConn
-
>
SetSchemaVersion
(
8
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
[
[
fallthrough
]
]
;
case
8
:
{
bool
hostsIsBackupExists
=
false
;
data
-
>
mDBConn
-
>
TableExists
(
"
moz_hosts_is_backup
"
_ns
&
hostsIsBackupExists
)
;
if
(
hostsIsBackupExists
)
{
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
"
DELETE
FROM
moz_hosts
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
"
DROP
TABLE
moz_hosts_is_backup
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
data
-
>
mDBConn
-
>
SetSchemaVersion
(
9
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
[
[
fallthrough
]
]
;
case
9
:
{
rv
=
data
-
>
mDBConn
-
>
SetSchemaVersion
(
10
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
[
[
fallthrough
]
]
;
case
10
:
{
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
UPDATE
moz_perms
"
"
SET
type
=
SUBSTR
(
type
0
INSTR
(
SUBSTR
(
type
INSTR
(
type
"
"
'
^
'
)
+
"
"
1
)
'
^
'
)
+
INSTR
(
type
'
^
'
)
)
"
"
WHERE
INSTR
(
SUBSTR
(
type
INSTR
(
type
'
^
'
)
+
1
)
'
^
'
)
AND
"
"
SUBSTR
(
type
0
18
)
=
=
\
"
storageAccessAPI
^
\
"
;
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
data
-
>
mDBConn
-
>
SetSchemaVersion
(
11
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
[
[
fallthrough
]
]
;
case
11
:
{
rv
=
data
-
>
mDBConn
-
>
BeginTransaction
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
mozIStorageStatement
>
updateStmt
;
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
UPDATE
moz_perms
SET
origin
=
?
2
WHERE
id
=
?
1
"
)
getter_AddRefs
(
updateStmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
mozIStorageStatement
>
deleteStmt
;
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
DELETE
FROM
moz_perms
WHERE
id
=
?
1
"
)
getter_AddRefs
(
deleteStmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
mozIStorageStatement
>
selectStmt
;
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
SELECT
id
origin
type
FROM
moz_perms
WHERE
"
"
SUBSTR
(
type
0
17
)
=
=
\
"
3rdPartyStorage
^
\
"
"
)
getter_AddRefs
(
selectStmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsTHashSet
<
nsCStringHashKey
>
deduplicationSet
;
bool
hasResult
;
while
(
NS_SUCCEEDED
(
selectStmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
int64_t
id
;
rv
=
selectStmt
-
>
GetInt64
(
0
&
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCString
origin
;
rv
=
selectStmt
-
>
GetUTF8String
(
1
origin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCString
type
;
rv
=
selectStmt
-
>
GetUTF8String
(
2
type
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
origin
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
nsCString
site
;
rv
=
nsEffectiveTLDService
:
:
GetInstance
(
)
-
>
GetSite
(
uri
site
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
nsCString
deduplicationKey
=
nsPrintfCString
(
"
%
s
%
s
"
site
.
get
(
)
type
.
get
(
)
)
;
if
(
deduplicationSet
.
Contains
(
deduplicationKey
)
)
{
rv
=
deleteStmt
-
>
BindInt64ByIndex
(
0
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
deleteStmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
deduplicationSet
.
Insert
(
deduplicationKey
)
;
rv
=
updateStmt
-
>
BindInt64ByIndex
(
0
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
BindUTF8StringByIndex
(
1
site
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
updateStmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
rv
=
data
-
>
mDBConn
-
>
CommitTransaction
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
data
-
>
mDBConn
-
>
SetSchemaVersion
(
HOSTS_SCHEMA_VERSION
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
[
[
fallthrough
]
]
;
case
HOSTS_SCHEMA_VERSION
:
break
;
default
:
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
SELECT
origin
type
permission
"
"
expireType
expireTime
"
"
modificationTime
FROM
moz_perms
"
)
getter_AddRefs
(
stmt
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
break
;
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
"
DROP
TABLE
moz_perms
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CreateTable
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
break
;
}
}
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
INSERT
INTO
moz_perms
"
"
(
id
origin
type
permission
expireType
"
"
expireTime
modificationTime
)
"
"
VALUES
(
?
1
?
2
?
3
?
4
?
5
?
6
?
7
)
"
)
getter_AddRefs
(
data
-
>
mStmtInsert
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
DELETE
FROM
moz_perms
"
"
WHERE
id
=
?
1
"
)
getter_AddRefs
(
data
-
>
mStmtDelete
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
UPDATE
moz_perms
"
"
SET
permission
=
?
2
expireType
=
?
3
expireTime
=
"
"
?
4
modificationTime
=
?
5
WHERE
id
=
?
1
"
)
getter_AddRefs
(
data
-
>
mStmtUpdate
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ConsumeDefaultsInputStream
(
aDefaultsInputStream
lock
)
;
if
(
tableExists
)
{
rv
=
Read
(
lock
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
raiiFailure
.
release
(
)
;
return
NS_OK
;
}
void
PermissionManager
:
:
AddIdleDailyMaintenanceJob
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE_VOID
(
observerService
)
;
nsresult
rv
=
observerService
-
>
AddObserver
(
this
OBSERVER_TOPIC_IDLE_DAILY
false
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
void
PermissionManager
:
:
RemoveIdleDailyMaintenanceJob
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE_VOID
(
observerService
)
;
nsresult
rv
=
observerService
-
>
RemoveObserver
(
this
OBSERVER_TOPIC_IDLE_DAILY
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
void
PermissionManager
:
:
PerformIdleDailyMaintenance
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
PermissionManager
>
self
=
this
;
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
PermissionManager
:
:
PerformIdleDailyMaintenance
"
[
self
]
{
auto
data
=
self
-
>
mThreadBoundData
.
Access
(
)
;
if
(
self
-
>
mState
=
=
eClosed
|
|
!
data
-
>
mDBConn
)
{
return
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmtDeleteExpired
;
nsresult
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
DELETE
FROM
moz_perms
WHERE
expireType
=
"
"
?
1
AND
expireTime
<
=
?
2
"
)
getter_AddRefs
(
stmtDeleteExpired
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
rv
=
stmtDeleteExpired
-
>
BindInt32ByIndex
(
0
nsIPermissionManager
:
:
EXPIRE_TIME
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
rv
=
stmtDeleteExpired
-
>
BindInt64ByIndex
(
1
EXPIRY_NOW
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
rv
=
stmtDeleteExpired
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
)
)
;
}
nsresult
PermissionManager
:
:
CreateTable
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
auto
data
=
mThreadBoundData
.
Access
(
)
;
nsresult
rv
=
data
-
>
mDBConn
-
>
SetSchemaVersion
(
HOSTS_SCHEMA_VERSION
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
CREATE
TABLE
moz_perms
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
origin
TEXT
"
"
type
TEXT
"
"
permission
INTEGER
"
"
expireType
INTEGER
"
"
expireTime
INTEGER
"
"
modificationTime
INTEGER
"
"
)
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
CREATE
TABLE
moz_hosts
(
"
"
id
INTEGER
PRIMARY
KEY
"
"
host
TEXT
"
"
type
TEXT
"
"
permission
INTEGER
"
"
expireType
INTEGER
"
"
expireTime
INTEGER
"
"
modificationTime
INTEGER
"
"
isInBrowserElement
INTEGER
"
"
)
"
)
)
;
}
bool
PermissionManager
:
:
HasExpired
(
uint32_t
aExpireType
int64_t
aExpireTime
)
{
return
(
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_TIME
|
|
(
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_SESSION
&
&
aExpireTime
!
=
0
)
)
&
&
aExpireTime
<
=
EXPIRY_NOW
;
}
NS_IMETHODIMP
PermissionManager
:
:
AddFromPrincipalAndPersistInPrivateBrowsing
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
uint32_t
aPermission
)
{
ENSURE_NOT_CHILD_PROCESS
;
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
if
(
aPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
NS_OK
;
}
if
(
aPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
return
NS_OK
;
}
if
(
IsExpandedPrincipal
(
aPrincipal
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
int64_t
modificationTime
=
0
;
return
AddInternal
(
aPrincipal
aType
aPermission
0
nsIPermissionManager
:
:
EXPIRE_NEVER
0
modificationTime
eNotify
eWriteToDB
false
nullptr
true
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
AddFromPrincipal
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
)
{
ENSURE_NOT_CHILD_PROCESS
;
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
NS_ENSURE_TRUE
(
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_NEVER
|
|
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_TIME
|
|
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_SESSION
|
|
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_POLICY
NS_ERROR_INVALID_ARG
)
;
if
(
HasExpired
(
aExpireType
aExpireTime
)
)
{
return
NS_OK
;
}
if
(
aPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
NS_OK
;
}
if
(
aPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
return
NS_OK
;
}
if
(
IsExpandedPrincipal
(
aPrincipal
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
int64_t
modificationTime
=
0
;
return
AddInternal
(
aPrincipal
aType
aPermission
0
aExpireType
aExpireTime
modificationTime
eNotify
eWriteToDB
)
;
}
nsresult
PermissionManager
:
:
AddInternal
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
uint32_t
aPermission
int64_t
aID
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
NotifyOperationType
aNotifyOperation
DBOperationType
aDBOperation
const
bool
aIgnoreSessionPermissions
const
nsACString
*
aOriginString
const
bool
aAllowPersistInPrivateBrowsing
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
EnsureReadCompleted
(
)
;
nsresult
rv
=
NS_OK
;
nsAutoCString
origin
;
if
(
!
IsChildProcess
(
)
|
|
(
aDBOperation
=
=
eWriteToDB
&
&
IsPersistentExpire
(
aExpireType
aType
)
)
)
{
if
(
aOriginString
)
{
origin
=
*
aOriginString
;
}
else
{
if
(
IsSiteScopedPermission
(
aType
)
)
{
rv
=
GetSiteFromPrincipal
(
aPrincipal
IsOAForceStripPermission
(
aType
)
origin
)
;
}
else
{
rv
=
GetOriginFromPrincipal
(
aPrincipal
IsOAForceStripPermission
(
aType
)
origin
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
!
aAllowPersistInPrivateBrowsing
&
&
aID
!
=
cIDPermissionIsDefault
&
&
aPermission
!
=
UNKNOWN_ACTION
&
&
aExpireType
!
=
EXPIRE_SESSION
)
{
uint32_t
privateBrowsingId
=
nsScriptSecurityManager
:
:
DEFAULT_PRIVATE_BROWSING_ID
;
nsresult
rv
=
aPrincipal
-
>
GetPrivateBrowsingId
(
&
privateBrowsingId
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
privateBrowsingId
!
=
nsScriptSecurityManager
:
:
DEFAULT_PRIVATE_BROWSING_ID
)
{
aExpireType
=
EXPIRE_SESSION
;
}
}
if
(
!
IsChildProcess
(
)
&
&
aNotifyOperation
=
=
eNotify
)
{
IPC
:
:
Permission
permission
(
origin
aType
aPermission
aExpireType
aExpireTime
)
;
nsAutoCString
permissionKey
;
GetKeyForPermission
(
aPrincipal
aType
permissionKey
)
;
nsTArray
<
ContentParent
*
>
cplist
;
ContentParent
:
:
GetAll
(
cplist
)
;
for
(
uint32_t
i
=
0
;
i
<
cplist
.
Length
(
)
;
+
+
i
)
{
ContentParent
*
cp
=
cplist
[
i
]
;
if
(
cp
-
>
NeedsPermissionsUpdate
(
permissionKey
)
)
Unused
<
<
cp
-
>
SendAddPermission
(
permission
)
;
}
}
MOZ_ASSERT
(
PermissionAvailable
(
aPrincipal
aType
)
)
;
int32_t
typeIndex
=
GetTypeIndex
(
aType
true
)
;
NS_ENSURE_TRUE
(
typeIndex
!
=
-
1
NS_ERROR_OUT_OF_MEMORY
)
;
RefPtr
<
PermissionKey
>
key
=
PermissionKey
:
:
CreateFromPrincipal
(
aPrincipal
IsOAForceStripPermission
(
aType
)
IsSiteScopedPermission
(
aType
)
rv
)
;
if
(
!
key
)
{
MOZ_ASSERT
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
PermissionHashKey
*
entry
=
mPermissionTable
.
PutEntry
(
key
)
;
if
(
!
entry
)
return
NS_ERROR_FAILURE
;
if
(
!
entry
-
>
GetKey
(
)
)
{
mPermissionTable
.
RemoveEntry
(
entry
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
OperationType
op
;
int32_t
index
=
entry
-
>
GetPermissionIndex
(
typeIndex
)
;
if
(
index
=
=
-
1
)
{
if
(
aPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
op
=
eOperationNone
;
else
op
=
eOperationAdding
;
}
else
{
PermissionEntry
oldPermissionEntry
=
entry
-
>
GetPermissions
(
)
[
index
]
;
if
(
aPermission
=
=
oldPermissionEntry
.
mPermission
&
&
aExpireType
=
=
oldPermissionEntry
.
mExpireType
&
&
(
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_NEVER
|
|
aExpireTime
=
=
oldPermissionEntry
.
mExpireTime
)
)
op
=
eOperationNone
;
else
if
(
oldPermissionEntry
.
mID
=
=
cIDPermissionIsDefault
)
op
=
eOperationReplacingDefault
;
else
if
(
aID
=
=
cIDPermissionIsDefault
)
op
=
eOperationNone
;
else
if
(
aPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
op
=
eOperationRemoving
;
else
op
=
eOperationChanging
;
}
MOZ_ASSERT
(
!
IsChildProcess
(
)
|
|
aModificationTime
=
=
0
)
;
int64_t
id
;
if
(
aModificationTime
=
=
0
)
{
aModificationTime
=
EXPIRY_NOW
;
}
switch
(
op
)
{
case
eOperationNone
:
{
return
NS_OK
;
}
case
eOperationAdding
:
{
if
(
aDBOperation
=
=
eWriteToDB
)
{
id
=
+
+
mLargestID
;
}
else
{
id
=
aID
;
}
entry
-
>
GetPermissions
(
)
.
AppendElement
(
PermissionEntry
(
id
typeIndex
aPermission
aExpireType
aExpireTime
aModificationTime
)
)
;
if
(
aDBOperation
=
=
eWriteToDB
&
&
IsPersistentExpire
(
aExpireType
aType
)
)
{
UpdateDB
(
op
id
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
}
if
(
aNotifyOperation
=
=
eNotify
)
{
NotifyObserversWithPermission
(
aPrincipal
mTypeArray
[
typeIndex
]
aPermission
aExpireType
aExpireTime
aModificationTime
u
"
added
"
)
;
}
break
;
}
case
eOperationRemoving
:
{
PermissionEntry
oldPermissionEntry
=
entry
-
>
GetPermissions
(
)
[
index
]
;
id
=
oldPermissionEntry
.
mID
;
if
(
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
=
=
EXPIRE_POLICY
)
{
NS_WARNING
(
"
Attempting
to
remove
EXPIRE_POLICY
permission
"
)
;
break
;
}
entry
-
>
GetPermissions
(
)
.
RemoveElementAt
(
index
)
;
if
(
aDBOperation
=
=
eWriteToDB
)
UpdateDB
(
op
id
"
"
_ns
"
"
_ns
0
nsIPermissionManager
:
:
EXPIRE_NEVER
0
0
)
;
if
(
aNotifyOperation
=
=
eNotify
)
{
NotifyObserversWithPermission
(
aPrincipal
mTypeArray
[
typeIndex
]
oldPermissionEntry
.
mPermission
oldPermissionEntry
.
mExpireType
oldPermissionEntry
.
mExpireTime
oldPermissionEntry
.
mModificationTime
u
"
deleted
"
)
;
}
if
(
entry
-
>
GetPermissions
(
)
.
IsEmpty
(
)
)
{
mPermissionTable
.
RemoveEntry
(
entry
)
;
}
break
;
}
case
eOperationChanging
:
{
id
=
entry
-
>
GetPermissions
(
)
[
index
]
.
mID
;
if
(
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
=
=
EXPIRE_POLICY
)
{
NS_WARNING
(
"
Attempting
to
modify
EXPIRE_POLICY
permission
"
)
;
break
;
}
PermissionEntry
oldPermissionEntry
=
entry
-
>
GetPermissions
(
)
[
index
]
;
if
(
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
!
=
nsIPermissionManager
:
:
EXPIRE_SESSION
&
&
aExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_SESSION
)
{
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionPermission
=
entry
-
>
GetPermissions
(
)
[
index
]
.
mPermission
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionExpireType
=
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionExpireTime
=
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireTime
;
}
else
if
(
aExpireType
!
=
nsIPermissionManager
:
:
EXPIRE_SESSION
)
{
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionPermission
=
aPermission
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionExpireType
=
aExpireType
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mNonSessionExpireTime
=
aExpireTime
;
}
entry
-
>
GetPermissions
(
)
[
index
]
.
mPermission
=
aPermission
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
=
aExpireType
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireTime
=
aExpireTime
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mModificationTime
=
aModificationTime
;
if
(
aDBOperation
=
=
eWriteToDB
)
{
bool
newIsPersistentExpire
=
IsPersistentExpire
(
aExpireType
aType
)
;
bool
oldIsPersistentExpire
=
IsPersistentExpire
(
oldPermissionEntry
.
mExpireType
aType
)
;
if
(
!
newIsPersistentExpire
&
&
oldIsPersistentExpire
)
{
UpdateDB
(
eOperationRemoving
id
"
"
_ns
"
"
_ns
0
nsIPermissionManager
:
:
EXPIRE_NEVER
0
0
)
;
}
else
if
(
newIsPersistentExpire
&
&
!
oldIsPersistentExpire
)
{
UpdateDB
(
eOperationAdding
id
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
}
else
if
(
newIsPersistentExpire
)
{
UpdateDB
(
op
id
"
"
_ns
"
"
_ns
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
}
}
if
(
aNotifyOperation
=
=
eNotify
)
{
NotifyObserversWithPermission
(
aPrincipal
mTypeArray
[
typeIndex
]
aPermission
aExpireType
aExpireTime
aModificationTime
u
"
changed
"
)
;
}
break
;
}
case
eOperationReplacingDefault
:
{
id
=
+
+
mLargestID
;
NS_ENSURE_TRUE
(
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
!
=
nsIPermissionManager
:
:
EXPIRE_SESSION
NS_ERROR_UNEXPECTED
)
;
NS_ENSURE_TRUE
(
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
!
=
nsIPermissionManager
:
:
EXPIRE_POLICY
NS_ERROR_UNEXPECTED
)
;
NS_ENSURE_TRUE
(
aExpireType
=
=
EXPIRE_NEVER
NS_ERROR_UNEXPECTED
)
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mID
=
id
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mPermission
=
aPermission
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireType
=
aExpireType
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mExpireTime
=
aExpireTime
;
entry
-
>
GetPermissions
(
)
[
index
]
.
mModificationTime
=
aModificationTime
;
if
(
aDBOperation
=
=
eWriteToDB
&
&
IsPersistentExpire
(
aExpireType
aType
)
)
{
UpdateDB
(
eOperationAdding
id
origin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
}
if
(
aNotifyOperation
=
=
eNotify
)
{
NotifyObserversWithPermission
(
aPrincipal
mTypeArray
[
typeIndex
]
aPermission
aExpireType
aExpireTime
aModificationTime
u
"
changed
"
)
;
}
}
break
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PermissionManager
:
:
RemoveFromPrincipal
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
)
{
ENSURE_NOT_CHILD_PROCESS
;
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
if
(
aPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
NS_OK
;
}
if
(
IsExpandedPrincipal
(
aPrincipal
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
AddInternal
(
aPrincipal
aType
nsIPermissionManager
:
:
UNKNOWN_ACTION
0
nsIPermissionManager
:
:
EXPIRE_NEVER
0
0
eNotify
eWriteToDB
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
RemovePermission
(
nsIPermission
*
aPerm
)
{
if
(
!
aPerm
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
aPerm
-
>
GetPrincipal
(
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
type
;
rv
=
aPerm
-
>
GetType
(
type
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
RemoveFromPrincipal
(
principal
type
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
RemoveAll
(
)
{
ENSURE_NOT_CHILD_PROCESS
;
return
RemoveAllInternal
(
true
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
RemoveAllSince
(
int64_t
aSince
)
{
ENSURE_NOT_CHILD_PROCESS
;
return
RemoveAllModifiedSince
(
aSince
)
;
}
template
<
class
T
>
nsresult
PermissionManager
:
:
RemovePermissionEntries
(
T
aCondition
)
{
EnsureReadCompleted
(
)
;
Vector
<
std
:
:
tuple
<
nsCOMPtr
<
nsIPrincipal
>
nsCString
nsCString
>
10
>
array
;
for
(
const
PermissionHashKey
&
entry
:
mPermissionTable
)
{
for
(
const
auto
&
permEntry
:
entry
.
GetPermissions
(
)
)
{
if
(
!
aCondition
(
permEntry
)
)
{
continue
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
entry
.
GetKey
(
)
-
>
mOrigin
IsOAForceStripPermission
(
mTypeArray
[
permEntry
.
mType
]
)
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
if
(
!
array
.
emplaceBack
(
principal
mTypeArray
[
permEntry
.
mType
]
entry
.
GetKey
(
)
-
>
mOrigin
)
)
{
continue
;
}
}
}
for
(
auto
&
i
:
array
)
{
AddInternal
(
std
:
:
get
<
0
>
(
i
)
std
:
:
get
<
1
>
(
i
)
nsIPermissionManager
:
:
UNKNOWN_ACTION
0
nsIPermissionManager
:
:
EXPIRE_NEVER
0
0
PermissionManager
:
:
eNotify
PermissionManager
:
:
eWriteToDB
false
&
std
:
:
get
<
2
>
(
i
)
)
;
}
ImportLatestDefaults
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PermissionManager
:
:
RemoveByType
(
const
nsACString
&
aType
)
{
ENSURE_NOT_CHILD_PROCESS
;
int32_t
typeIndex
=
GetTypeIndex
(
aType
false
)
;
if
(
typeIndex
=
=
-
1
)
{
return
NS_OK
;
}
return
RemovePermissionEntries
(
[
typeIndex
]
(
const
PermissionEntry
&
aPermEntry
)
{
return
static_cast
<
uint32_t
>
(
typeIndex
)
=
=
aPermEntry
.
mType
;
}
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
RemoveByTypeSince
(
const
nsACString
&
aType
int64_t
aModificationTime
)
{
ENSURE_NOT_CHILD_PROCESS
;
int32_t
typeIndex
=
GetTypeIndex
(
aType
false
)
;
if
(
typeIndex
=
=
-
1
)
{
return
NS_OK
;
}
return
RemovePermissionEntries
(
[
typeIndex
aModificationTime
]
(
const
PermissionEntry
&
aPermEntry
)
{
return
uint32_t
(
typeIndex
)
=
=
aPermEntry
.
mType
&
&
aModificationTime
<
=
aPermEntry
.
mModificationTime
;
}
)
;
}
void
PermissionManager
:
:
CloseDB
(
CloseDBNextOp
aNextOp
)
{
EnsureReadCompleted
(
)
;
mState
=
eClosed
;
nsCOMPtr
<
nsIInputStream
>
defaultsInputStream
;
if
(
aNextOp
=
=
eRebuldOnSuccess
)
{
defaultsInputStream
=
GetDefaultsInputStream
(
)
;
}
RefPtr
<
PermissionManager
>
self
=
this
;
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
PermissionManager
:
:
CloseDB
"
[
self
aNextOp
defaultsInputStream
]
{
auto
data
=
self
-
>
mThreadBoundData
.
Access
(
)
;
data
-
>
mStmtInsert
=
nullptr
;
data
-
>
mStmtDelete
=
nullptr
;
data
-
>
mStmtUpdate
=
nullptr
;
if
(
data
-
>
mDBConn
)
{
DebugOnly
<
nsresult
>
rv
=
data
-
>
mDBConn
-
>
Close
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
data
-
>
mDBConn
=
nullptr
;
if
(
aNextOp
=
=
eRebuldOnSuccess
)
{
self
-
>
TryInitDB
(
true
defaultsInputStream
)
;
}
}
if
(
aNextOp
=
=
eShutdown
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
PermissionManager
:
:
MaybeCompleteShutdown
"
[
self
]
{
self
-
>
MaybeCompleteShutdown
(
)
;
}
)
)
;
}
}
)
)
;
}
nsresult
PermissionManager
:
:
RemoveAllFromIPC
(
)
{
MOZ_ASSERT
(
IsChildProcess
(
)
)
;
RemoveAllFromMemory
(
)
;
return
NS_OK
;
}
nsresult
PermissionManager
:
:
RemoveAllInternal
(
bool
aNotifyObservers
)
{
ENSURE_NOT_CHILD_PROCESS
;
EnsureReadCompleted
(
)
;
nsTArray
<
ContentParent
*
>
parents
;
ContentParent
:
:
GetAll
(
parents
)
;
for
(
ContentParent
*
parent
:
parents
)
{
Unused
<
<
parent
-
>
SendRemoveAllPermissions
(
)
;
}
RemoveAllFromMemory
(
)
;
ImportLatestDefaults
(
)
;
if
(
aNotifyObservers
)
{
NotifyObservers
(
nullptr
u
"
cleared
"
)
;
}
RefPtr
<
PermissionManager
>
self
=
this
;
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
PermissionManager
:
:
RemoveAllInternal
"
[
self
]
{
auto
data
=
self
-
>
mThreadBoundData
.
Access
(
)
;
if
(
self
-
>
mState
=
=
eClosed
|
|
!
data
-
>
mDBConn
)
{
return
;
}
nsresult
rv
=
data
-
>
mDBConn
-
>
ExecuteSimpleSQL
(
"
DELETE
FROM
moz_perms
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
PermissionManager
:
:
RemoveAllInternal
-
Failure
"
[
self
]
{
self
-
>
CloseDB
(
eRebuldOnSuccess
)
;
}
)
)
;
}
}
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PermissionManager
:
:
TestExactPermissionFromPrincipal
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
uint32_t
*
aPermission
)
{
return
CommonTestPermission
(
aPrincipal
-
1
aType
aPermission
nsIPermissionManager
:
:
UNKNOWN_ACTION
false
true
true
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
TestExactPermanentPermission
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
uint32_t
*
aPermission
)
{
return
CommonTestPermission
(
aPrincipal
-
1
aType
aPermission
nsIPermissionManager
:
:
UNKNOWN_ACTION
false
true
false
)
;
}
nsresult
PermissionManager
:
:
LegacyTestPermissionFromURI
(
nsIURI
*
aURI
const
OriginAttributes
*
aOriginAttributes
const
nsACString
&
aType
uint32_t
*
aPermission
)
{
return
CommonTestPermission
(
aURI
aOriginAttributes
-
1
aType
aPermission
nsIPermissionManager
:
:
UNKNOWN_ACTION
false
false
true
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
TestPermissionFromPrincipal
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
uint32_t
*
aPermission
)
{
return
CommonTestPermission
(
aPrincipal
-
1
aType
aPermission
nsIPermissionManager
:
:
UNKNOWN_ACTION
false
false
true
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
GetPermissionObject
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
bool
aExactHostMatch
nsIPermission
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
*
aResult
=
nullptr
;
EnsureReadCompleted
(
)
;
if
(
aPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
NS_OK
;
}
if
(
IsExpandedPrincipal
(
aPrincipal
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
MOZ_ASSERT
(
PermissionAvailable
(
aPrincipal
aType
)
)
;
int32_t
typeIndex
=
GetTypeIndex
(
aType
false
)
;
if
(
typeIndex
=
=
-
1
)
return
NS_OK
;
PermissionHashKey
*
entry
=
GetPermissionHashKey
(
aPrincipal
typeIndex
aExactHostMatch
)
;
if
(
!
entry
)
{
return
NS_OK
;
}
int32_t
idx
=
entry
-
>
GetPermissionIndex
(
typeIndex
)
;
if
(
-
1
=
=
idx
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
entry
-
>
GetKey
(
)
-
>
mOrigin
IsOAForceStripPermission
(
aType
)
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PermissionEntry
&
perm
=
entry
-
>
GetPermissions
(
)
[
idx
]
;
nsCOMPtr
<
nsIPermission
>
r
=
Permission
:
:
Create
(
principal
mTypeArray
[
perm
.
mType
]
perm
.
mPermission
perm
.
mExpireType
perm
.
mExpireTime
perm
.
mModificationTime
)
;
if
(
NS_WARN_IF
(
!
r
)
)
{
return
NS_ERROR_FAILURE
;
}
r
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
PermissionManager
:
:
CommonTestPermissionInternal
(
nsIPrincipal
*
aPrincipal
nsIURI
*
aURI
const
OriginAttributes
*
aOriginAttributes
int32_t
aTypeIndex
const
nsACString
&
aType
uint32_t
*
aPermission
bool
aExactHostMatch
bool
aIncludingSession
)
{
MOZ_ASSERT
(
aPrincipal
|
|
aURI
)
;
NS_ENSURE_ARG_POINTER
(
aPrincipal
|
|
aURI
)
;
MOZ_ASSERT_IF
(
aPrincipal
!
aURI
&
&
!
aOriginAttributes
)
;
MOZ_ASSERT_IF
(
aURI
|
|
aOriginAttributes
!
aPrincipal
)
;
EnsureReadCompleted
(
)
;
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIPrincipal
>
prin
=
aPrincipal
;
if
(
!
prin
)
{
if
(
aURI
)
{
prin
=
BasePrincipal
:
:
CreateContentPrincipal
(
aURI
OriginAttributes
(
)
)
;
}
}
MOZ_ASSERT
(
prin
)
;
MOZ_ASSERT
(
PermissionAvailable
(
prin
aType
)
)
;
}
#
endif
PermissionHashKey
*
entry
=
aPrincipal
?
GetPermissionHashKey
(
aPrincipal
aTypeIndex
aExactHostMatch
)
:
GetPermissionHashKey
(
aURI
aOriginAttributes
aTypeIndex
aExactHostMatch
)
;
if
(
!
entry
|
|
(
!
aIncludingSession
&
&
entry
-
>
GetPermission
(
aTypeIndex
)
.
mNonSessionExpireType
=
=
nsIPermissionManager
:
:
EXPIRE_SESSION
)
)
{
return
NS_OK
;
}
*
aPermission
=
aIncludingSession
?
entry
-
>
GetPermission
(
aTypeIndex
)
.
mPermission
:
entry
-
>
GetPermission
(
aTypeIndex
)
.
mNonSessionPermission
;
return
NS_OK
;
}
template
<
class
T
>
nsresult
PermissionManager
:
:
GetPermissionEntries
(
T
aCondition
nsTArray
<
RefPtr
<
nsIPermission
>
>
&
aResult
)
{
aResult
.
Clear
(
)
;
if
(
XRE_IsContentProcess
(
)
)
{
NS_WARNING
(
"
Iterating
over
all
permissions
is
not
available
in
the
"
"
content
process
as
not
all
permissions
may
be
available
.
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
EnsureReadCompleted
(
)
;
for
(
const
PermissionHashKey
&
entry
:
mPermissionTable
)
{
for
(
const
auto
&
permEntry
:
entry
.
GetPermissions
(
)
)
{
if
(
permEntry
.
mPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
continue
;
}
if
(
HasExpired
(
permEntry
.
mExpireType
permEntry
.
mExpireTime
)
)
{
continue
;
}
if
(
!
aCondition
(
permEntry
)
)
{
continue
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
entry
.
GetKey
(
)
-
>
mOrigin
IsOAForceStripPermission
(
mTypeArray
[
permEntry
.
mType
]
)
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
RefPtr
<
nsIPermission
>
permission
=
Permission
:
:
Create
(
principal
mTypeArray
[
permEntry
.
mType
]
permEntry
.
mPermission
permEntry
.
mExpireType
permEntry
.
mExpireTime
permEntry
.
mModificationTime
)
;
if
(
NS_WARN_IF
(
!
permission
)
)
{
continue
;
}
aResult
.
AppendElement
(
std
:
:
move
(
permission
)
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
PermissionManager
:
:
GetAll
(
nsTArray
<
RefPtr
<
nsIPermission
>
>
&
aResult
)
{
return
GetPermissionEntries
(
[
]
(
const
PermissionEntry
&
aPermEntry
)
{
return
true
;
}
aResult
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
GetAllByTypeSince
(
const
nsACString
&
aPrefix
int64_t
aSince
nsTArray
<
RefPtr
<
nsIPermission
>
>
&
aResult
)
{
if
(
aSince
>
(
PR_Now
(
)
/
PR_USEC_PER_MSEC
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
GetPermissionEntries
(
[
&
]
(
const
PermissionEntry
&
aPermEntry
)
{
return
mTypeArray
[
aPermEntry
.
mType
]
.
Equals
(
aPrefix
)
&
&
aSince
<
=
aPermEntry
.
mModificationTime
;
}
aResult
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
GetAllWithTypePrefix
(
const
nsACString
&
aPrefix
nsTArray
<
RefPtr
<
nsIPermission
>
>
&
aResult
)
{
return
GetPermissionEntries
(
[
&
]
(
const
PermissionEntry
&
aPermEntry
)
{
return
StringBeginsWith
(
mTypeArray
[
aPermEntry
.
mType
]
aPrefix
)
;
}
aResult
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
GetAllByTypes
(
const
nsTArray
<
nsCString
>
&
aTypes
nsTArray
<
RefPtr
<
nsIPermission
>
>
&
aResult
)
{
if
(
aTypes
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
return
GetPermissionEntries
(
[
&
]
(
const
PermissionEntry
&
aPermEntry
)
{
return
aTypes
.
Contains
(
mTypeArray
[
aPermEntry
.
mType
]
)
;
}
aResult
)
;
}
nsresult
PermissionManager
:
:
GetAllForPrincipalHelper
(
nsIPrincipal
*
aPrincipal
bool
aSiteScopePermissions
nsTArray
<
RefPtr
<
nsIPermission
>
>
&
aResult
)
{
nsresult
rv
;
RefPtr
<
PermissionKey
>
key
=
PermissionKey
:
:
CreateFromPrincipal
(
aPrincipal
false
aSiteScopePermissions
rv
)
;
if
(
!
key
)
{
MOZ_ASSERT
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
PermissionHashKey
*
entry
=
mPermissionTable
.
GetEntry
(
key
)
;
nsTArray
<
PermissionEntry
>
strippedPerms
;
rv
=
GetStripPermsForPrincipal
(
aPrincipal
aSiteScopePermissions
strippedPerms
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
entry
)
{
for
(
const
auto
&
permEntry
:
entry
-
>
GetPermissions
(
)
)
{
if
(
permEntry
.
mPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
continue
;
}
if
(
HasExpired
(
permEntry
.
mExpireType
permEntry
.
mExpireTime
)
)
{
continue
;
}
if
(
aSiteScopePermissions
!
=
IsSiteScopedPermission
(
mTypeArray
[
permEntry
.
mType
]
)
)
{
continue
;
}
PermissionEntry
perm
=
permEntry
;
nsTArray
<
PermissionEntry
>
:
:
index_type
index
=
0
;
for
(
const
auto
&
strippedPerm
:
strippedPerms
)
{
if
(
strippedPerm
.
mType
=
=
permEntry
.
mType
)
{
perm
=
strippedPerm
;
strippedPerms
.
RemoveElementAt
(
index
)
;
break
;
}
index
+
+
;
}
RefPtr
<
nsIPermission
>
permission
=
Permission
:
:
Create
(
aPrincipal
mTypeArray
[
perm
.
mType
]
perm
.
mPermission
perm
.
mExpireType
perm
.
mExpireTime
perm
.
mModificationTime
)
;
if
(
NS_WARN_IF
(
!
permission
)
)
{
continue
;
}
aResult
.
AppendElement
(
permission
)
;
}
}
for
(
const
auto
&
perm
:
strippedPerms
)
{
RefPtr
<
nsIPermission
>
permission
=
Permission
:
:
Create
(
aPrincipal
mTypeArray
[
perm
.
mType
]
perm
.
mPermission
perm
.
mExpireType
perm
.
mExpireTime
perm
.
mModificationTime
)
;
if
(
NS_WARN_IF
(
!
permission
)
)
{
continue
;
}
aResult
.
AppendElement
(
permission
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PermissionManager
:
:
GetAllForPrincipal
(
nsIPrincipal
*
aPrincipal
nsTArray
<
RefPtr
<
nsIPermission
>
>
&
aResult
)
{
nsresult
rv
;
aResult
.
Clear
(
)
;
EnsureReadCompleted
(
)
;
MOZ_ASSERT
(
PermissionAvailable
(
aPrincipal
"
"
_ns
)
)
;
rv
=
GetAllForPrincipalHelper
(
aPrincipal
false
aResult
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
GetAllForPrincipalHelper
(
aPrincipal
true
aResult
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
ENSURE_NOT_CHILD_PROCESS
;
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
profile
-
do
-
change
"
)
&
&
!
mPermissionsFile
)
{
InitDB
(
false
)
;
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
testonly
-
reload
-
permissions
-
from
-
disk
"
)
)
{
RemoveAllFromMemory
(
)
;
CloseDB
(
eNone
)
;
InitDB
(
false
)
;
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
OBSERVER_TOPIC_IDLE_DAILY
)
)
{
PerformIdleDailyMaintenance
(
)
;
}
return
NS_OK
;
}
nsresult
PermissionManager
:
:
RemoveAllModifiedSince
(
int64_t
aModificationTime
)
{
ENSURE_NOT_CHILD_PROCESS
;
return
RemovePermissionEntries
(
[
aModificationTime
]
(
const
PermissionEntry
&
aPermEntry
)
{
return
aModificationTime
<
=
aPermEntry
.
mModificationTime
&
&
aPermEntry
.
mID
!
=
cIDPermissionIsDefault
;
}
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
RemovePermissionsWithAttributes
(
const
nsAString
&
aPattern
)
{
ENSURE_NOT_CHILD_PROCESS
;
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
RemovePermissionsWithAttributes
(
pattern
)
;
}
nsresult
PermissionManager
:
:
RemovePermissionsWithAttributes
(
OriginAttributesPattern
&
aPattern
)
{
EnsureReadCompleted
(
)
;
Vector
<
std
:
:
tuple
<
nsCOMPtr
<
nsIPrincipal
>
nsCString
nsCString
>
10
>
permissions
;
for
(
const
PermissionHashKey
&
entry
:
mPermissionTable
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
entry
.
GetKey
(
)
-
>
mOrigin
false
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
if
(
!
aPattern
.
Matches
(
principal
-
>
OriginAttributesRef
(
)
)
)
{
continue
;
}
for
(
const
auto
&
permEntry
:
entry
.
GetPermissions
(
)
)
{
if
(
!
permissions
.
emplaceBack
(
principal
mTypeArray
[
permEntry
.
mType
]
entry
.
GetKey
(
)
-
>
mOrigin
)
)
{
continue
;
}
}
}
for
(
auto
&
i
:
permissions
)
{
AddInternal
(
std
:
:
get
<
0
>
(
i
)
std
:
:
get
<
1
>
(
i
)
nsIPermissionManager
:
:
UNKNOWN_ACTION
0
nsIPermissionManager
:
:
EXPIRE_NEVER
0
0
PermissionManager
:
:
eNotify
PermissionManager
:
:
eWriteToDB
false
&
std
:
:
get
<
2
>
(
i
)
)
;
}
return
NS_OK
;
}
nsresult
PermissionManager
:
:
GetStripPermsForPrincipal
(
nsIPrincipal
*
aPrincipal
bool
aSiteScopePermissions
nsTArray
<
PermissionEntry
>
&
aResult
)
{
aResult
.
Clear
(
)
;
aResult
.
SetCapacity
(
kStripOAPermissions
.
size
(
)
)
;
#
ifdef
__clang__
#
pragma
clang
diagnostic
push
#
pragma
clang
diagnostic
ignored
"
-
Wunreachable
-
code
-
return
"
#
endif
if
(
kStripOAPermissions
.
empty
(
)
)
{
return
NS_OK
;
}
#
ifdef
__clang__
#
pragma
clang
diagnostic
pop
#
endif
nsresult
rv
;
RefPtr
<
PermissionKey
>
key
=
PermissionKey
:
:
CreateFromPrincipal
(
aPrincipal
true
aSiteScopePermissions
rv
)
;
if
(
!
key
)
{
MOZ_ASSERT
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
PermissionHashKey
*
hashKey
=
mPermissionTable
.
GetEntry
(
key
)
;
if
(
!
hashKey
)
{
return
NS_OK
;
}
for
(
const
auto
&
permType
:
kStripOAPermissions
)
{
if
(
aSiteScopePermissions
!
=
IsSiteScopedPermission
(
permType
)
)
{
continue
;
}
int32_t
index
=
GetTypeIndex
(
permType
false
)
;
if
(
index
=
=
-
1
)
{
continue
;
}
PermissionEntry
perm
=
hashKey
-
>
GetPermission
(
index
)
;
if
(
perm
.
mPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
continue
;
}
aResult
.
AppendElement
(
perm
)
;
}
return
NS_OK
;
}
int32_t
PermissionManager
:
:
GetTypeIndex
(
const
nsACString
&
aType
bool
aAdd
)
{
for
(
uint32_t
i
=
0
;
i
<
mTypeArray
.
length
(
)
;
+
+
i
)
{
if
(
mTypeArray
[
i
]
.
Equals
(
aType
)
)
{
return
i
;
}
}
if
(
!
aAdd
)
{
return
-
1
;
}
if
(
!
mTypeArray
.
emplaceBack
(
aType
)
)
{
return
-
1
;
}
return
mTypeArray
.
length
(
)
-
1
;
}
PermissionManager
:
:
PermissionHashKey
*
PermissionManager
:
:
GetPermissionHashKey
(
nsIPrincipal
*
aPrincipal
uint32_t
aType
bool
aExactHostMatch
)
{
EnsureReadCompleted
(
)
;
MOZ_ASSERT
(
PermissionAvailable
(
aPrincipal
mTypeArray
[
aType
]
)
)
;
nsresult
rv
;
RefPtr
<
PermissionKey
>
key
=
PermissionKey
:
:
CreateFromPrincipal
(
aPrincipal
IsOAForceStripPermission
(
mTypeArray
[
aType
]
)
IsSiteScopedPermission
(
mTypeArray
[
aType
]
)
rv
)
;
if
(
!
key
)
{
return
nullptr
;
}
PermissionHashKey
*
entry
=
mPermissionTable
.
GetEntry
(
key
)
;
if
(
entry
)
{
PermissionEntry
permEntry
=
entry
-
>
GetPermission
(
aType
)
;
if
(
HasExpired
(
permEntry
.
mExpireType
permEntry
.
mExpireTime
)
)
{
entry
=
nullptr
;
RemoveFromPrincipal
(
aPrincipal
mTypeArray
[
aType
]
)
;
}
else
if
(
permEntry
.
mPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
entry
=
nullptr
;
}
}
if
(
entry
)
{
return
entry
;
}
if
(
!
aExactHostMatch
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
aPrincipal
-
>
GetNextSubDomainPrincipal
(
)
;
if
(
principal
)
{
return
GetPermissionHashKey
(
principal
aType
aExactHostMatch
)
;
}
}
return
nullptr
;
}
PermissionManager
:
:
PermissionHashKey
*
PermissionManager
:
:
GetPermissionHashKey
(
nsIURI
*
aURI
const
OriginAttributes
*
aOriginAttributes
uint32_t
aType
bool
aExactHostMatch
)
{
MOZ_ASSERT
(
aURI
)
;
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
NS_OK
;
if
(
aURI
)
{
rv
=
GetPrincipal
(
aURI
getter_AddRefs
(
principal
)
)
;
}
MOZ_ASSERT_IF
(
NS_SUCCEEDED
(
rv
)
PermissionAvailable
(
principal
mTypeArray
[
aType
]
)
)
;
}
#
endif
nsresult
rv
;
RefPtr
<
PermissionKey
>
key
;
if
(
aOriginAttributes
)
{
key
=
PermissionKey
:
:
CreateFromURIAndOriginAttributes
(
aURI
aOriginAttributes
IsOAForceStripPermission
(
mTypeArray
[
aType
]
)
rv
)
;
}
else
{
key
=
PermissionKey
:
:
CreateFromURI
(
aURI
rv
)
;
}
if
(
!
key
)
{
return
nullptr
;
}
PermissionHashKey
*
entry
=
mPermissionTable
.
GetEntry
(
key
)
;
if
(
entry
)
{
PermissionEntry
permEntry
=
entry
-
>
GetPermission
(
aType
)
;
if
(
HasExpired
(
permEntry
.
mExpireType
permEntry
.
mExpireTime
)
)
{
entry
=
nullptr
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
if
(
aURI
)
{
nsresult
rv
=
GetPrincipal
(
aURI
getter_AddRefs
(
principal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
RemoveFromPrincipal
(
principal
mTypeArray
[
aType
]
)
;
}
else
if
(
permEntry
.
mPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
entry
=
nullptr
;
}
}
if
(
entry
)
{
return
entry
;
}
if
(
!
aExactHostMatch
)
{
nsCOMPtr
<
nsIURI
>
uri
;
if
(
aURI
)
{
uri
=
GetNextSubDomainURI
(
aURI
)
;
}
if
(
uri
)
{
return
GetPermissionHashKey
(
uri
aOriginAttributes
aType
aExactHostMatch
)
;
}
}
return
nullptr
;
}
nsresult
PermissionManager
:
:
RemoveAllFromMemory
(
)
{
mLargestID
=
0
;
mTypeArray
.
clear
(
)
;
mPermissionTable
.
Clear
(
)
;
return
NS_OK
;
}
void
PermissionManager
:
:
NotifyObserversWithPermission
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
const
char16_t
*
aData
)
{
nsCOMPtr
<
nsIPermission
>
permission
=
Permission
:
:
Create
(
aPrincipal
aType
aPermission
aExpireType
aExpireTime
aModificationTime
)
;
if
(
permission
)
NotifyObservers
(
permission
aData
)
;
}
void
PermissionManager
:
:
NotifyObservers
(
nsIPermission
*
aPermission
const
char16_t
*
aData
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
observerService
-
>
NotifyObservers
(
aPermission
kPermissionChangeNotification
aData
)
;
}
nsresult
PermissionManager
:
:
Read
(
const
MonitorAutoLock
&
aProofOfLock
)
{
ENSURE_NOT_CHILD_PROCESS
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
auto
data
=
mThreadBoundData
.
Access
(
)
;
nsresult
rv
;
bool
hasResult
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
SELECT
MAX
(
id
)
FROM
moz_perms
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
int64_t
id
=
stmt
-
>
AsInt64
(
0
)
;
mLargestID
=
id
;
}
rv
=
data
-
>
mDBConn
-
>
CreateStatement
(
nsLiteralCString
(
"
SELECT
id
origin
type
permission
expireType
"
"
expireTime
modificationTime
"
"
FROM
moz_perms
WHERE
expireType
!
=
?
1
OR
expireTime
>
?
2
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByIndex
(
0
nsIPermissionManager
:
:
EXPIRE_TIME
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt64ByIndex
(
1
EXPIRY_NOW
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
readError
=
false
;
while
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
ReadEntry
entry
;
entry
.
mId
=
stmt
-
>
AsInt64
(
0
)
;
MOZ_ASSERT
(
entry
.
mId
<
=
mLargestID
)
;
rv
=
stmt
-
>
GetUTF8String
(
1
entry
.
mOrigin
)
;
if
(
NS_FAILED
(
rv
)
)
{
readError
=
true
;
continue
;
}
rv
=
stmt
-
>
GetUTF8String
(
2
entry
.
mType
)
;
if
(
NS_FAILED
(
rv
)
)
{
readError
=
true
;
continue
;
}
entry
.
mPermission
=
stmt
-
>
AsInt32
(
3
)
;
entry
.
mExpireType
=
stmt
-
>
AsInt32
(
4
)
;
entry
.
mExpireTime
=
stmt
-
>
AsInt64
(
5
)
;
entry
.
mModificationTime
=
stmt
-
>
AsInt64
(
6
)
;
entry
.
mFromMigration
=
false
;
mReadEntries
.
AppendElement
(
entry
)
;
}
if
(
readError
)
{
NS_ERROR
(
"
Error
occured
while
reading
the
permissions
database
!
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
PermissionManager
:
:
CompleteMigrations
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mState
=
=
eReady
)
;
nsresult
rv
;
nsTArray
<
MigrationEntry
>
entries
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
entries
=
std
:
:
move
(
mMigrationEntries
)
;
}
for
(
const
MigrationEntry
&
entry
:
entries
)
{
rv
=
UpgradeHostToOriginAndInsert
(
entry
.
mHost
entry
.
mType
entry
.
mPermission
entry
.
mExpireType
entry
.
mExpireTime
entry
.
mModificationTime
entry
.
mIsInBrowserElement
[
&
]
(
const
nsACString
&
aOrigin
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
{
MaybeAddReadEntryFromMigration
(
aOrigin
aType
aPermission
aExpireType
aExpireTime
aModificationTime
entry
.
mId
)
;
return
NS_OK
;
}
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
}
void
PermissionManager
:
:
CompleteRead
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mState
=
=
eReady
)
;
nsresult
rv
;
nsTArray
<
ReadEntry
>
entries
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
entries
=
std
:
:
move
(
mReadEntries
)
;
}
for
(
const
ReadEntry
&
entry
:
entries
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
GetPrincipalFromOrigin
(
entry
.
mOrigin
IsOAForceStripPermission
(
entry
.
mType
)
getter_AddRefs
(
principal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
DBOperationType
op
=
entry
.
mFromMigration
?
eWriteToDB
:
eNoDBOperation
;
rv
=
AddInternal
(
principal
entry
.
mType
entry
.
mPermission
entry
.
mId
entry
.
mExpireType
entry
.
mExpireTime
entry
.
mModificationTime
eDontNotify
op
false
&
entry
.
mOrigin
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
}
void
PermissionManager
:
:
MaybeAddReadEntryFromMigration
(
const
nsACString
&
aOrigin
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
int64_t
aId
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
for
(
const
ReadEntry
&
entry
:
mReadEntries
)
{
if
(
entry
.
mOrigin
=
=
aOrigin
&
&
entry
.
mType
=
=
aType
)
{
return
;
}
}
ReadEntry
entry
;
entry
.
mId
=
aId
;
entry
.
mOrigin
=
aOrigin
;
entry
.
mType
=
aType
;
entry
.
mPermission
=
aPermission
;
entry
.
mExpireType
=
aExpireType
;
entry
.
mExpireTime
=
aExpireTime
;
entry
.
mModificationTime
=
aModificationTime
;
entry
.
mFromMigration
=
true
;
mReadEntries
.
AppendElement
(
entry
)
;
}
void
PermissionManager
:
:
UpdateDB
(
OperationType
aOp
int64_t
aID
const
nsACString
&
aOrigin
const
nsACString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
{
ENSURE_NOT_CHILD_PROCESS_NORET
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
EnsureReadCompleted
(
)
;
nsCString
origin
(
aOrigin
)
;
nsCString
type
(
aType
)
;
RefPtr
<
PermissionManager
>
self
=
this
;
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
PermissionManager
:
:
UpdateDB
"
[
self
aOp
aID
origin
type
aPermission
aExpireType
aExpireTime
aModificationTime
]
{
nsresult
rv
;
auto
data
=
self
-
>
mThreadBoundData
.
Access
(
)
;
if
(
self
-
>
mState
=
=
eClosed
|
|
!
data
-
>
mDBConn
)
{
return
;
}
mozIStorageStatement
*
stmt
=
nullptr
;
switch
(
aOp
)
{
case
eOperationAdding
:
{
stmt
=
data
-
>
mStmtInsert
;
rv
=
stmt
-
>
BindInt64ByIndex
(
0
aID
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
stmt
-
>
BindUTF8StringByIndex
(
1
origin
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
stmt
-
>
BindUTF8StringByIndex
(
2
type
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
stmt
-
>
BindInt32ByIndex
(
3
aPermission
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
stmt
-
>
BindInt32ByIndex
(
4
aExpireType
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
stmt
-
>
BindInt64ByIndex
(
5
aExpireTime
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
stmt
-
>
BindInt64ByIndex
(
6
aModificationTime
)
;
break
;
}
case
eOperationRemoving
:
{
stmt
=
data
-
>
mStmtDelete
;
rv
=
stmt
-
>
BindInt64ByIndex
(
0
aID
)
;
break
;
}
case
eOperationChanging
:
{
stmt
=
data
-
>
mStmtUpdate
;
rv
=
stmt
-
>
BindInt64ByIndex
(
0
aID
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
stmt
-
>
BindInt32ByIndex
(
1
aPermission
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
stmt
-
>
BindInt32ByIndex
(
2
aExpireType
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
stmt
-
>
BindInt64ByIndex
(
3
aExpireTime
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
rv
=
stmt
-
>
BindInt64ByIndex
(
4
aModificationTime
)
;
break
;
}
default
:
{
MOZ_ASSERT_UNREACHABLE
(
"
need
a
valid
operation
in
UpdateDB
(
)
!
"
)
;
rv
=
NS_ERROR_UNEXPECTED
;
break
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
db
change
failed
!
"
)
;
return
;
}
rv
=
stmt
-
>
Execute
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
)
)
;
}
bool
PermissionManager
:
:
GetPermissionsFromOriginOrKey
(
const
nsACString
&
aOrigin
const
nsACString
&
aKey
nsTArray
<
IPC
:
:
Permission
>
&
aPerms
)
{
EnsureReadCompleted
(
)
;
aPerms
.
Clear
(
)
;
if
(
NS_WARN_IF
(
XRE_IsContentProcess
(
)
)
)
{
return
false
;
}
for
(
const
PermissionHashKey
&
entry
:
mPermissionTable
)
{
nsAutoCString
permissionKey
;
if
(
aOrigin
.
IsEmpty
(
)
)
{
GetKeyForOrigin
(
entry
.
GetKey
(
)
-
>
mOrigin
false
false
permissionKey
)
;
if
(
aKey
!
=
permissionKey
&
&
!
aKey
.
IsEmpty
(
)
)
{
continue
;
}
}
else
if
(
aOrigin
!
=
entry
.
GetKey
(
)
-
>
mOrigin
)
{
continue
;
}
for
(
const
auto
&
permEntry
:
entry
.
GetPermissions
(
)
)
{
if
(
permEntry
.
mPermission
=
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
continue
;
}
bool
isPreload
=
IsPreloadPermission
(
mTypeArray
[
permEntry
.
mType
]
)
;
bool
shouldAppend
;
if
(
aOrigin
.
IsEmpty
(
)
)
{
shouldAppend
=
(
isPreload
&
&
aKey
.
IsEmpty
(
)
)
|
|
(
!
isPreload
&
&
aKey
=
=
permissionKey
)
;
}
else
{
shouldAppend
=
(
!
isPreload
&
&
aOrigin
=
=
entry
.
GetKey
(
)
-
>
mOrigin
)
;
}
if
(
shouldAppend
)
{
aPerms
.
AppendElement
(
IPC
:
:
Permission
(
entry
.
GetKey
(
)
-
>
mOrigin
mTypeArray
[
permEntry
.
mType
]
permEntry
.
mPermission
permEntry
.
mExpireType
permEntry
.
mExpireTime
)
)
;
}
}
}
return
true
;
}
void
PermissionManager
:
:
SetPermissionsWithKey
(
const
nsACString
&
aPermissionKey
nsTArray
<
IPC
:
:
Permission
>
&
aPerms
)
{
if
(
NS_WARN_IF
(
XRE_IsParentProcess
(
)
)
)
{
return
;
}
RefPtr
<
GenericNonExclusivePromise
:
:
Private
>
promise
;
bool
foundKey
=
mPermissionKeyPromiseMap
.
Get
(
aPermissionKey
getter_AddRefs
(
promise
)
)
;
if
(
promise
)
{
MOZ_ASSERT
(
foundKey
)
;
promise
-
>
Resolve
(
true
__func__
)
;
}
else
if
(
foundKey
)
{
return
;
}
mPermissionKeyPromiseMap
.
InsertOrUpdate
(
aPermissionKey
RefPtr
<
GenericNonExclusivePromise
:
:
Private
>
{
}
)
;
for
(
IPC
:
:
Permission
&
perm
:
aPerms
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
perm
.
origin
IsOAForceStripPermission
(
perm
.
type
)
getter_AddRefs
(
principal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
#
ifdef
DEBUG
nsAutoCString
permissionKey
;
GetKeyForPermission
(
principal
perm
.
type
permissionKey
)
;
MOZ_ASSERT
(
permissionKey
=
=
aPermissionKey
"
The
permission
keys
which
were
sent
over
should
match
!
"
)
;
#
endif
uint64_t
modificationTime
=
0
;
AddInternal
(
principal
perm
.
type
perm
.
capability
0
perm
.
expireType
perm
.
expireTime
modificationTime
eNotify
eNoDBOperation
true
)
;
}
}
nsresult
PermissionManager
:
:
GetKeyForOrigin
(
const
nsACString
&
aOrigin
bool
aForceStripOA
bool
aSiteScopePermissions
nsACString
&
aKey
)
{
aKey
.
Truncate
(
)
;
if
(
!
StringBeginsWith
(
aOrigin
"
http
:
"
_ns
)
&
&
!
StringBeginsWith
(
aOrigin
"
https
:
"
_ns
)
&
&
!
StringBeginsWith
(
aOrigin
"
ftp
:
"
_ns
)
)
{
return
NS_OK
;
}
OriginAttributes
attrs
;
if
(
!
attrs
.
PopulateFromOrigin
(
aOrigin
aKey
)
)
{
aKey
.
Truncate
(
)
;
return
NS_OK
;
}
MaybeStripOriginAttributes
(
aForceStripOA
attrs
)
;
#
ifdef
DEBUG
nsCOMPtr
<
nsIPrincipal
>
dbgPrincipal
;
MOZ_ALWAYS_SUCCEEDS
(
GetPrincipalFromOrigin
(
aOrigin
aForceStripOA
getter_AddRefs
(
dbgPrincipal
)
)
)
;
MOZ_ASSERT
(
dbgPrincipal
-
>
SchemeIs
(
"
http
"
)
|
|
dbgPrincipal
-
>
SchemeIs
(
"
https
"
)
|
|
dbgPrincipal
-
>
SchemeIs
(
"
ftp
"
)
)
;
MOZ_ASSERT
(
dbgPrincipal
-
>
OriginAttributesRef
(
)
=
=
attrs
)
;
#
endif
if
(
aSiteScopePermissions
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aKey
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
nsCString
site
;
rv
=
nsEffectiveTLDService
:
:
GetInstance
(
)
-
>
GetSite
(
uri
site
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aKey
=
site
;
}
}
}
nsAutoCString
suffix
;
attrs
.
CreateSuffix
(
suffix
)
;
aKey
.
Append
(
suffix
)
;
return
NS_OK
;
}
nsresult
PermissionManager
:
:
GetKeyForPrincipal
(
nsIPrincipal
*
aPrincipal
bool
aForceStripOA
bool
aSiteScopePermissions
nsACString
&
aKey
)
{
nsAutoCString
origin
;
nsresult
rv
=
aPrincipal
-
>
GetOrigin
(
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aKey
.
Truncate
(
)
;
return
rv
;
}
return
GetKeyForOrigin
(
origin
aForceStripOA
aSiteScopePermissions
aKey
)
;
}
nsresult
PermissionManager
:
:
GetKeyForPermission
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
nsACString
&
aKey
)
{
if
(
IsPreloadPermission
(
aType
)
)
{
aKey
.
Truncate
(
)
;
return
NS_OK
;
}
return
GetKeyForPrincipal
(
aPrincipal
IsOAForceStripPermission
(
aType
)
IsSiteScopedPermission
(
aType
)
aKey
)
;
}
nsTArray
<
std
:
:
pair
<
nsCString
nsCString
>
>
PermissionManager
:
:
GetAllKeysForPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
aPrincipal
)
;
nsTArray
<
std
:
:
pair
<
nsCString
nsCString
>
>
pairs
;
nsCOMPtr
<
nsIPrincipal
>
prin
=
aPrincipal
;
while
(
prin
)
{
std
:
:
pair
<
nsCString
nsCString
>
*
pair
=
pairs
.
AppendElement
(
std
:
:
make_pair
(
"
"
_ns
"
"
_ns
)
)
;
GetKeyForPrincipal
(
prin
false
false
pair
-
>
first
)
;
if
(
pair
-
>
first
.
IsEmpty
(
)
)
{
break
;
}
Unused
<
<
GetOriginFromPrincipal
(
prin
false
pair
-
>
second
)
;
prin
=
prin
-
>
GetNextSubDomainPrincipal
(
)
;
}
MOZ_ASSERT
(
pairs
.
Length
(
)
>
=
1
"
Every
principal
should
have
at
least
one
pair
item
.
"
)
;
return
pairs
;
}
bool
PermissionManager
:
:
PermissionAvailable
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
)
{
EnsureReadCompleted
(
)
;
if
(
XRE_IsContentProcess
(
)
)
{
nsAutoCString
permissionKey
;
GetKeyForPermission
(
aPrincipal
aType
permissionKey
)
;
RefPtr
<
GenericNonExclusivePromise
:
:
Private
>
promise
;
if
(
!
mPermissionKeyPromiseMap
.
Get
(
permissionKey
getter_AddRefs
(
promise
)
)
|
|
promise
)
{
NS_WARNING
(
nsPrintfCString
(
"
This
content
process
hasn
'
t
received
the
"
"
permissions
for
%
s
yet
"
permissionKey
.
get
(
)
)
.
get
(
)
)
;
return
false
;
}
}
return
true
;
}
void
PermissionManager
:
:
WhenPermissionsAvailable
(
nsIPrincipal
*
aPrincipal
nsIRunnable
*
aRunnable
)
{
MOZ_ASSERT
(
aRunnable
)
;
if
(
!
XRE_IsContentProcess
(
)
)
{
aRunnable
-
>
Run
(
)
;
return
;
}
nsTArray
<
RefPtr
<
GenericNonExclusivePromise
>
>
promises
;
for
(
auto
&
pair
:
GetAllKeysForPrincipal
(
aPrincipal
)
)
{
RefPtr
<
GenericNonExclusivePromise
:
:
Private
>
promise
;
if
(
!
mPermissionKeyPromiseMap
.
Get
(
pair
.
first
getter_AddRefs
(
promise
)
)
)
{
promise
=
new
GenericNonExclusivePromise
:
:
Private
(
__func__
)
;
mPermissionKeyPromiseMap
.
InsertOrUpdate
(
pair
.
first
RefPtr
{
promise
}
)
;
}
if
(
promise
)
{
promises
.
AppendElement
(
std
:
:
move
(
promise
)
)
;
}
}
if
(
promises
.
IsEmpty
(
)
)
{
aRunnable
-
>
Run
(
)
;
return
;
}
auto
*
thread
=
AbstractThread
:
:
MainThread
(
)
;
RefPtr
<
nsIRunnable
>
runnable
=
aRunnable
;
GenericNonExclusivePromise
:
:
All
(
thread
promises
)
-
>
Then
(
thread
__func__
[
runnable
]
(
)
{
runnable
-
>
Run
(
)
;
}
[
]
(
)
{
NS_WARNING
(
"
PermissionManager
permission
promise
rejected
.
We
'
re
"
"
probably
shutting
down
.
"
)
;
}
)
;
}
void
PermissionManager
:
:
EnsureReadCompleted
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mState
=
=
eInitializing
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
mState
=
=
eInitializing
)
{
mMonitor
.
Wait
(
)
;
}
}
switch
(
mState
)
{
case
eInitializing
:
MOZ_CRASH
(
"
This
state
is
impossible
!
"
)
;
case
eDBInitialized
:
mState
=
eReady
;
CompleteMigrations
(
)
;
ImportLatestDefaults
(
)
;
CompleteRead
(
)
;
[
[
fallthrough
]
]
;
case
eReady
:
[
[
fallthrough
]
]
;
case
eClosed
:
return
;
default
:
MOZ_CRASH
(
"
Invalid
state
"
)
;
}
}
already_AddRefed
<
nsIInputStream
>
PermissionManager
:
:
GetDefaultsInputStream
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsAutoCString
defaultsURL
;
Preferences
:
:
GetCString
(
kDefaultsUrlPrefName
defaultsURL
)
;
if
(
defaultsURL
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
defaultsURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
defaultsURI
)
defaultsURL
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
defaultsURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
nsCOMPtr
<
nsIInputStream
>
inputStream
;
rv
=
channel
-
>
Open
(
getter_AddRefs
(
inputStream
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
inputStream
.
forget
(
)
;
}
void
PermissionManager
:
:
ConsumeDefaultsInputStream
(
nsIInputStream
*
aInputStream
const
MonitorAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
constexpr
char
kMatchTypeHost
[
]
=
"
host
"
;
constexpr
char
kMatchTypeOrigin
[
]
=
"
origin
"
;
mDefaultEntries
.
Clear
(
)
;
if
(
!
aInputStream
)
{
return
;
}
nsresult
rv
;
nsLineBuffer
<
char
>
lineBuffer
;
nsCString
line
;
bool
isMore
=
true
;
do
{
rv
=
NS_ReadLine
(
aInputStream
&
lineBuffer
line
&
isMore
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
line
.
IsEmpty
(
)
|
|
line
.
First
(
)
=
=
'
#
'
)
{
continue
;
}
nsTArray
<
nsCString
>
lineArray
;
ParseString
(
line
'
\
t
'
lineArray
)
;
if
(
lineArray
.
Length
(
)
!
=
4
)
{
continue
;
}
nsresult
error
=
NS_OK
;
uint32_t
permission
=
lineArray
[
2
]
.
ToInteger
(
&
error
)
;
if
(
NS_FAILED
(
error
)
)
{
continue
;
}
DefaultEntry
:
:
Op
op
;
if
(
lineArray
[
0
]
.
EqualsLiteral
(
kMatchTypeHost
)
)
{
op
=
DefaultEntry
:
:
eImportMatchTypeHost
;
}
else
if
(
lineArray
[
0
]
.
EqualsLiteral
(
kMatchTypeOrigin
)
)
{
op
=
DefaultEntry
:
:
eImportMatchTypeOrigin
;
}
else
{
continue
;
}
DefaultEntry
*
entry
=
mDefaultEntries
.
AppendElement
(
)
;
MOZ_ASSERT
(
entry
)
;
entry
-
>
mOp
=
op
;
entry
-
>
mPermission
=
permission
;
entry
-
>
mHostOrOrigin
=
lineArray
[
3
]
;
entry
-
>
mType
=
lineArray
[
1
]
;
}
while
(
isMore
)
;
}
nsresult
PermissionManager
:
:
ImportLatestDefaults
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mState
=
=
eReady
)
;
nsresult
rv
;
MonitorAutoLock
lock
(
mMonitor
)
;
for
(
const
DefaultEntry
&
entry
:
mDefaultEntries
)
{
if
(
entry
.
mOp
=
=
DefaultEntry
:
:
eImportMatchTypeHost
)
{
int64_t
modificationTime
=
0
;
rv
=
UpgradeHostToOriginAndInsert
(
entry
.
mHostOrOrigin
entry
.
mType
entry
.
mPermission
nsIPermissionManager
:
:
EXPIRE_NEVER
0
modificationTime
false
[
&
]
(
const
nsACString
&
aOrigin
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
GetPrincipalFromOrigin
(
aOrigin
IsOAForceStripPermission
(
aType
)
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
AddInternal
(
principal
aType
aPermission
cIDPermissionIsDefault
aExpireType
aExpireTime
aModificationTime
PermissionManager
:
:
eDontNotify
PermissionManager
:
:
eNoDBOperation
false
&
aOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
StaticPrefs
:
:
permissions_isolateBy_privateBrowsing
(
)
)
{
OriginAttributes
attrs
=
OriginAttributes
(
principal
-
>
OriginAttributesRef
(
)
)
;
attrs
.
mPrivateBrowsingId
=
1
;
nsCOMPtr
<
nsIPrincipal
>
pbPrincipal
=
BasePrincipal
:
:
Cast
(
principal
)
-
>
CloneForcingOriginAttributes
(
attrs
)
;
rv
=
AddInternal
(
pbPrincipal
aType
aPermission
cIDPermissionIsDefault
aExpireType
aExpireTime
aModificationTime
PermissionManager
:
:
eDontNotify
PermissionManager
:
:
eNoDBOperation
false
&
aOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
There
was
a
problem
importing
a
host
permission
"
)
;
}
continue
;
}
MOZ_ASSERT
(
entry
.
mOp
=
=
DefaultEntry
:
:
eImportMatchTypeOrigin
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
GetPrincipalFromOrigin
(
entry
.
mHostOrOrigin
IsOAForceStripPermission
(
entry
.
mType
)
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Couldn
'
t
import
an
origin
permission
-
malformed
origin
"
)
;
continue
;
}
int64_t
modificationTime
=
0
;
rv
=
AddInternal
(
principal
entry
.
mType
entry
.
mPermission
cIDPermissionIsDefault
nsIPermissionManager
:
:
EXPIRE_NEVER
0
modificationTime
eDontNotify
eNoDBOperation
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
There
was
a
problem
importing
an
origin
permission
"
)
;
}
if
(
StaticPrefs
:
:
permissions_isolateBy_privateBrowsing
(
)
)
{
OriginAttributes
attrs
=
OriginAttributes
(
principal
-
>
OriginAttributesRef
(
)
)
;
attrs
.
mPrivateBrowsingId
=
1
;
nsCOMPtr
<
nsIPrincipal
>
pbPrincipal
=
BasePrincipal
:
:
Cast
(
principal
)
-
>
CloneForcingOriginAttributes
(
attrs
)
;
NS_ENSURE_TRUE
(
pbPrincipal
NS_ERROR_FAILURE
)
;
rv
=
AddInternal
(
pbPrincipal
entry
.
mType
entry
.
mPermission
cIDPermissionIsDefault
nsIPermissionManager
:
:
EXPIRE_NEVER
0
modificationTime
eDontNotify
eNoDBOperation
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
There
was
a
problem
importing
an
origin
permission
for
private
"
"
browsing
"
)
;
}
}
}
return
NS_OK
;
}
PermissionManager
:
:
TestPreparationResult
PermissionManager
:
:
CommonPrepareToTestPermission
(
nsIPrincipal
*
aPrincipal
int32_t
aTypeIndex
const
nsACString
&
aType
uint32_t
*
aPermission
uint32_t
aDefaultPermission
bool
aDefaultPermissionIsValid
bool
aExactHostMatch
bool
aIncludingSession
)
{
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
;
if
(
basePrin
&
&
basePrin
-
>
IsSystemPrincipal
(
)
)
{
*
aPermission
=
ALLOW_ACTION
;
return
AsVariant
(
NS_OK
)
;
}
EnsureReadCompleted
(
)
;
int32_t
defaultPermission
=
aDefaultPermissionIsValid
?
aDefaultPermission
:
UNKNOWN_ACTION
;
if
(
!
aDefaultPermissionIsValid
&
&
HasDefaultPref
(
aType
)
)
{
Unused
<
<
mDefaultPrefBranch
-
>
GetIntPref
(
PromiseFlatCString
(
aType
)
.
get
(
)
&
defaultPermission
)
;
}
*
aPermission
=
defaultPermission
;
int32_t
typeIndex
=
aTypeIndex
=
=
-
1
?
GetTypeIndex
(
aType
false
)
:
aTypeIndex
;
if
(
basePrin
&
&
basePrin
-
>
Is
<
ExpandedPrincipal
>
(
)
)
{
auto
ep
=
basePrin
-
>
As
<
ExpandedPrincipal
>
(
)
;
for
(
auto
&
prin
:
ep
-
>
AllowList
(
)
)
{
uint32_t
perm
;
nsresult
rv
=
CommonTestPermission
(
prin
typeIndex
aType
&
perm
defaultPermission
true
aExactHostMatch
aIncludingSession
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
AsVariant
(
rv
)
;
}
if
(
perm
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
*
aPermission
=
perm
;
return
AsVariant
(
NS_OK
)
;
}
if
(
perm
=
=
nsIPermissionManager
:
:
PROMPT_ACTION
)
{
*
aPermission
=
perm
;
}
}
return
AsVariant
(
NS_OK
)
;
}
if
(
typeIndex
=
=
-
1
)
{
return
AsVariant
(
NS_OK
)
;
}
return
AsVariant
(
typeIndex
)
;
}
nsresult
PermissionManager
:
:
CommonTestPermission
(
nsIPrincipal
*
aPrincipal
int32_t
aTypeIndex
const
nsACString
&
aType
uint32_t
*
aPermission
uint32_t
aDefaultPermission
bool
aDefaultPermissionIsValid
bool
aExactHostMatch
bool
aIncludingSession
)
{
auto
preparationResult
=
CommonPrepareToTestPermission
(
aPrincipal
aTypeIndex
aType
aPermission
aDefaultPermission
aDefaultPermissionIsValid
aExactHostMatch
aIncludingSession
)
;
if
(
preparationResult
.
is
<
nsresult
>
(
)
)
{
return
preparationResult
.
as
<
nsresult
>
(
)
;
}
return
CommonTestPermissionInternal
(
aPrincipal
nullptr
nullptr
preparationResult
.
as
<
int32_t
>
(
)
aType
aPermission
aExactHostMatch
aIncludingSession
)
;
}
nsresult
PermissionManager
:
:
CommonTestPermission
(
nsIURI
*
aURI
int32_t
aTypeIndex
const
nsACString
&
aType
uint32_t
*
aPermission
uint32_t
aDefaultPermission
bool
aDefaultPermissionIsValid
bool
aExactHostMatch
bool
aIncludingSession
)
{
auto
preparationResult
=
CommonPrepareToTestPermission
(
nullptr
aTypeIndex
aType
aPermission
aDefaultPermission
aDefaultPermissionIsValid
aExactHostMatch
aIncludingSession
)
;
if
(
preparationResult
.
is
<
nsresult
>
(
)
)
{
return
preparationResult
.
as
<
nsresult
>
(
)
;
}
return
CommonTestPermissionInternal
(
nullptr
aURI
nullptr
preparationResult
.
as
<
int32_t
>
(
)
aType
aPermission
aExactHostMatch
aIncludingSession
)
;
}
nsresult
PermissionManager
:
:
CommonTestPermission
(
nsIURI
*
aURI
const
OriginAttributes
*
aOriginAttributes
int32_t
aTypeIndex
const
nsACString
&
aType
uint32_t
*
aPermission
uint32_t
aDefaultPermission
bool
aDefaultPermissionIsValid
bool
aExactHostMatch
bool
aIncludingSession
)
{
auto
preparationResult
=
CommonPrepareToTestPermission
(
nullptr
aTypeIndex
aType
aPermission
aDefaultPermission
aDefaultPermissionIsValid
aExactHostMatch
aIncludingSession
)
;
if
(
preparationResult
.
is
<
nsresult
>
(
)
)
{
return
preparationResult
.
as
<
nsresult
>
(
)
;
}
return
CommonTestPermissionInternal
(
nullptr
aURI
aOriginAttributes
preparationResult
.
as
<
int32_t
>
(
)
aType
aPermission
aExactHostMatch
aIncludingSession
)
;
}
nsresult
PermissionManager
:
:
TestPermissionWithoutDefaultsFromPrincipal
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
uint32_t
*
aPermission
)
{
MOZ_ASSERT
(
!
HasDefaultPref
(
aType
)
)
;
return
CommonTestPermission
(
aPrincipal
-
1
aType
aPermission
nsIPermissionManager
:
:
UNKNOWN_ACTION
true
false
true
)
;
}
void
PermissionManager
:
:
MaybeCompleteShutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
asc
=
GetAsyncShutdownBarrier
(
)
;
MOZ_ASSERT
(
asc
)
;
DebugOnly
<
nsresult
>
rv
=
asc
-
>
RemoveBlocker
(
this
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
NS_IMETHODIMP
PermissionManager
:
:
GetName
(
nsAString
&
aName
)
{
aName
=
u
"
PermissionManager
:
Flushing
data
"
_ns
;
return
NS_OK
;
}
NS_IMETHODIMP
PermissionManager
:
:
BlockShutdown
(
nsIAsyncShutdownClient
*
aClient
)
{
RemoveIdleDailyMaintenanceJob
(
)
;
RemoveAllFromMemory
(
)
;
CloseDB
(
eShutdown
)
;
gPermissionManager
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
PermissionManager
:
:
GetState
(
nsIPropertyBag
*
*
aBagOut
)
{
nsCOMPtr
<
nsIWritablePropertyBag2
>
propertyBag
=
do_CreateInstance
(
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
)
;
nsresult
rv
=
propertyBag
-
>
SetPropertyAsInt32
(
u
"
state
"
_ns
mState
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
propertyBag
.
forget
(
aBagOut
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIAsyncShutdownClient
>
PermissionManager
:
:
GetAsyncShutdownBarrier
(
)
const
{
nsresult
rv
;
nsCOMPtr
<
nsIAsyncShutdownService
>
svc
=
do_GetService
(
"
mozilla
.
org
/
async
-
shutdown
-
service
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIAsyncShutdownClient
>
client
;
rv
=
svc
-
>
GetXpcomWillShutdown
(
getter_AddRefs
(
client
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
client
;
}
void
PermissionManager
:
:
MaybeStripOriginAttributes
(
bool
aForceStrip
OriginAttributes
&
aOriginAttributes
)
{
uint32_t
flags
=
0
;
if
(
aForceStrip
|
|
!
StaticPrefs
:
:
permissions_isolateBy_privateBrowsing
(
)
)
{
flags
|
=
OriginAttributes
:
:
STRIP_PRIVATE_BROWSING_ID
;
}
if
(
aForceStrip
|
|
!
StaticPrefs
:
:
permissions_isolateBy_userContext
(
)
)
{
flags
|
=
OriginAttributes
:
:
STRIP_USER_CONTEXT_ID
;
}
if
(
flags
!
=
0
)
{
aOriginAttributes
.
StripAttributes
(
flags
)
;
}
}
}
