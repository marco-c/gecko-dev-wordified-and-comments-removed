#
ifndef
nsPermissionManager_h__
#
define
nsPermissionManager_h__
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ExpandedPrincipal
.
h
"
#
include
"
mozilla
/
Permission
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ThreadBound
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
utility
>
namespace
IPC
{
struct
Permission
;
}
namespace
mozilla
{
class
OriginAttributesPattern
;
namespace
dom
{
class
ContentChild
;
}
}
class
nsIPermission
;
class
mozIStorageConnection
;
class
mozIStorageStatement
;
class
nsPermissionManager
final
:
public
nsIPermissionManager
public
nsIObserver
public
nsSupportsWeakReference
{
friend
class
mozilla
:
:
dom
:
:
ContentChild
;
public
:
class
PermissionEntry
{
public
:
PermissionEntry
(
int64_t
aID
uint32_t
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
:
mID
(
aID
)
mExpireTime
(
aExpireTime
)
mModificationTime
(
aModificationTime
)
mType
(
aType
)
mPermission
(
aPermission
)
mExpireType
(
aExpireType
)
mNonSessionPermission
(
aPermission
)
mNonSessionExpireType
(
aExpireType
)
mNonSessionExpireTime
(
aExpireTime
)
{
}
int64_t
mID
;
int64_t
mExpireTime
;
int64_t
mModificationTime
;
uint32_t
mType
;
uint32_t
mPermission
;
uint32_t
mExpireType
;
uint32_t
mNonSessionPermission
;
uint32_t
mNonSessionExpireType
;
uint32_t
mNonSessionExpireTime
;
}
;
class
PermissionKey
{
public
:
static
PermissionKey
*
CreateFromPrincipal
(
nsIPrincipal
*
aPrincipal
bool
aForceStripOA
nsresult
&
aResult
)
;
static
PermissionKey
*
CreateFromURI
(
nsIURI
*
aURI
nsresult
&
aResult
)
;
static
PermissionKey
*
CreateFromURIAndOriginAttributes
(
nsIURI
*
aURI
const
mozilla
:
:
OriginAttributes
*
aOriginAttributes
bool
aForceStripOA
nsresult
&
aResult
)
;
explicit
PermissionKey
(
const
nsACString
&
aOrigin
)
:
mOrigin
(
aOrigin
)
mHashCode
(
mozilla
:
:
HashString
(
aOrigin
)
)
{
}
bool
operator
=
=
(
const
PermissionKey
&
aKey
)
const
{
return
mOrigin
.
Equals
(
aKey
.
mOrigin
)
;
}
PLDHashNumber
GetHashCode
(
)
const
{
return
mHashCode
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PermissionKey
)
const
nsCString
mOrigin
;
const
PLDHashNumber
mHashCode
;
private
:
PermissionKey
(
)
=
delete
;
~
PermissionKey
(
)
{
}
;
}
;
class
PermissionHashKey
:
public
nsRefPtrHashKey
<
PermissionKey
>
{
public
:
explicit
PermissionHashKey
(
const
PermissionKey
*
aPermissionKey
)
:
nsRefPtrHashKey
<
PermissionKey
>
(
aPermissionKey
)
{
}
PermissionHashKey
(
PermissionHashKey
&
&
toCopy
)
:
nsRefPtrHashKey
<
PermissionKey
>
(
std
:
:
move
(
toCopy
)
)
mPermissions
(
std
:
:
move
(
toCopy
.
mPermissions
)
)
{
}
bool
KeyEquals
(
const
PermissionKey
*
aKey
)
const
{
return
*
aKey
=
=
*
GetKey
(
)
;
}
static
PLDHashNumber
HashKey
(
const
PermissionKey
*
aKey
)
{
return
aKey
-
>
GetHashCode
(
)
;
}
enum
{
ALLOW_MEMMOVE
=
false
}
;
inline
nsTArray
<
PermissionEntry
>
&
GetPermissions
(
)
{
return
mPermissions
;
}
inline
int32_t
GetPermissionIndex
(
uint32_t
aType
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mPermissions
.
Length
(
)
;
+
+
i
)
if
(
mPermissions
[
i
]
.
mType
=
=
aType
)
return
i
;
return
-
1
;
}
inline
PermissionEntry
GetPermission
(
uint32_t
aType
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mPermissions
.
Length
(
)
;
+
+
i
)
if
(
mPermissions
[
i
]
.
mType
=
=
aType
)
return
mPermissions
[
i
]
;
return
PermissionEntry
(
-
1
aType
nsIPermissionManager
:
:
UNKNOWN_ACTION
nsIPermissionManager
:
:
EXPIRE_NEVER
0
0
)
;
}
private
:
AutoTArray
<
PermissionEntry
1
>
mPermissions
;
}
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIPERMISSIONMANAGER
NS_DECL_NSIOBSERVER
nsPermissionManager
(
)
;
static
already_AddRefed
<
nsIPermissionManager
>
GetXPCOMSingleton
(
)
;
static
nsPermissionManager
*
GetInstance
(
)
;
nsresult
Init
(
)
;
enum
OperationType
{
eOperationNone
eOperationAdding
eOperationRemoving
eOperationChanging
eOperationReplacingDefault
}
;
enum
DBOperationType
{
eNoDBOperation
eWriteToDB
}
;
enum
NotifyOperationType
{
eDontNotify
eNotify
}
;
static
const
int64_t
cIDPermissionIsDefault
=
-
1
;
nsresult
TestPermissionWithoutDefaultsFromPrincipal
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
uint32_t
*
aPermission
)
{
MOZ_ASSERT
(
!
HasDefaultPref
(
aType
)
)
;
return
CommonTestPermission
(
aPrincipal
-
1
aType
aPermission
nsIPermissionManager
:
:
UNKNOWN_ACTION
true
false
true
)
;
}
nsresult
LegacyTestPermissionFromURI
(
nsIURI
*
aURI
const
mozilla
:
:
OriginAttributes
*
aOriginAttributes
const
nsACString
&
aType
uint32_t
*
aPermission
)
;
static
void
Startup
(
)
;
nsresult
RemovePermissionsWithAttributes
(
mozilla
:
:
OriginAttributesPattern
&
aAttrs
)
;
static
void
GetKeyForPrincipal
(
nsIPrincipal
*
aPrincipal
bool
aForceStripOA
nsACString
&
aKey
)
;
static
void
GetKeyForOrigin
(
const
nsACString
&
aOrigin
bool
aForceStripOA
nsACString
&
aKey
)
;
static
void
GetKeyForPermission
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
nsACString
&
aKey
)
;
static
nsTArray
<
std
:
:
pair
<
nsCString
nsCString
>
>
GetAllKeysForPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
nsresult
RemoveAllFromIPC
(
)
;
bool
PermissionAvailable
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
)
;
bool
GetPermissionsFromOriginOrKey
(
const
nsACString
&
aOrigin
const
nsACString
&
aKey
nsTArray
<
IPC
:
:
Permission
>
&
aPerms
)
;
void
SetPermissionsWithKey
(
const
nsACString
&
aPermissionKey
nsTArray
<
IPC
:
:
Permission
>
&
aPerms
)
;
void
WhenPermissionsAvailable
(
nsIPrincipal
*
aPrincipal
nsIRunnable
*
aRunnable
)
;
private
:
virtual
~
nsPermissionManager
(
)
;
nsresult
GetStripPermsForPrincipal
(
nsIPrincipal
*
aPrincipal
nsTArray
<
PermissionEntry
>
&
aResult
)
;
static
bool
HasDefaultPref
(
const
nsACString
&
aType
)
{
static
const
nsLiteralCString
kPermissionsWithDefaults
[
]
=
{
NS_LITERAL_CSTRING
(
"
camera
"
)
NS_LITERAL_CSTRING
(
"
microphone
"
)
NS_LITERAL_CSTRING
(
"
geo
"
)
NS_LITERAL_CSTRING
(
"
desktop
-
notification
"
)
NS_LITERAL_CSTRING
(
"
shortcuts
"
)
}
;
if
(
!
aType
.
IsEmpty
(
)
)
{
for
(
const
auto
&
perm
:
kPermissionsWithDefaults
)
{
if
(
perm
.
Equals
(
aType
)
)
{
return
true
;
}
}
}
return
false
;
}
int32_t
GetTypeIndex
(
const
nsACString
&
aType
bool
aAdd
)
{
for
(
uint32_t
i
=
0
;
i
<
mTypeArray
.
length
(
)
;
+
+
i
)
{
if
(
mTypeArray
[
i
]
.
Equals
(
aType
)
)
{
return
i
;
}
}
if
(
!
aAdd
)
{
return
-
1
;
}
if
(
!
mTypeArray
.
emplaceBack
(
aType
)
)
{
return
-
1
;
}
return
mTypeArray
.
length
(
)
-
1
;
}
PermissionHashKey
*
GetPermissionHashKey
(
nsIPrincipal
*
aPrincipal
uint32_t
aType
bool
aExactHostMatch
)
;
PermissionHashKey
*
GetPermissionHashKey
(
nsIURI
*
aURI
const
mozilla
:
:
OriginAttributes
*
aOriginAttributes
uint32_t
aType
bool
aExactHostMatch
)
;
typedef
mozilla
:
:
Variant
<
int32_t
nsresult
>
TestPreparationResult
;
TestPreparationResult
CommonPrepareToTestPermission
(
nsIPrincipal
*
aPrincipal
int32_t
aTypeIndex
const
nsACString
&
aType
uint32_t
*
aPermission
uint32_t
aDefaultPermission
bool
aDefaultPermissionIsValid
bool
aExactHostMatch
bool
aIncludingSession
)
;
nsresult
CommonTestPermission
(
nsIPrincipal
*
aPrincipal
int32_t
aTypeIndex
const
nsACString
&
aType
uint32_t
*
aPermission
uint32_t
aDefaultPermission
bool
aDefaultPermissionIsValid
bool
aExactHostMatch
bool
aIncludingSession
)
{
auto
preparationResult
=
CommonPrepareToTestPermission
(
aPrincipal
aTypeIndex
aType
aPermission
aDefaultPermission
aDefaultPermissionIsValid
aExactHostMatch
aIncludingSession
)
;
if
(
preparationResult
.
is
<
nsresult
>
(
)
)
{
return
preparationResult
.
as
<
nsresult
>
(
)
;
}
return
CommonTestPermissionInternal
(
aPrincipal
nullptr
nullptr
preparationResult
.
as
<
int32_t
>
(
)
aType
aPermission
aExactHostMatch
aIncludingSession
)
;
}
nsresult
CommonTestPermission
(
nsIURI
*
aURI
int32_t
aTypeIndex
const
nsACString
&
aType
uint32_t
*
aPermission
uint32_t
aDefaultPermission
bool
aDefaultPermissionIsValid
bool
aExactHostMatch
bool
aIncludingSession
)
{
auto
preparationResult
=
CommonPrepareToTestPermission
(
nullptr
aTypeIndex
aType
aPermission
aDefaultPermission
aDefaultPermissionIsValid
aExactHostMatch
aIncludingSession
)
;
if
(
preparationResult
.
is
<
nsresult
>
(
)
)
{
return
preparationResult
.
as
<
nsresult
>
(
)
;
}
return
CommonTestPermissionInternal
(
nullptr
aURI
nullptr
preparationResult
.
as
<
int32_t
>
(
)
aType
aPermission
aExactHostMatch
aIncludingSession
)
;
}
nsresult
CommonTestPermission
(
nsIURI
*
aURI
const
mozilla
:
:
OriginAttributes
*
aOriginAttributes
int32_t
aTypeIndex
const
nsACString
&
aType
uint32_t
*
aPermission
uint32_t
aDefaultPermission
bool
aDefaultPermissionIsValid
bool
aExactHostMatch
bool
aIncludingSession
)
{
auto
preparationResult
=
CommonPrepareToTestPermission
(
nullptr
aTypeIndex
aType
aPermission
aDefaultPermission
aDefaultPermissionIsValid
aExactHostMatch
aIncludingSession
)
;
if
(
preparationResult
.
is
<
nsresult
>
(
)
)
{
return
preparationResult
.
as
<
nsresult
>
(
)
;
}
return
CommonTestPermissionInternal
(
nullptr
aURI
aOriginAttributes
preparationResult
.
as
<
int32_t
>
(
)
aType
aPermission
aExactHostMatch
aIncludingSession
)
;
}
nsresult
CommonTestPermissionInternal
(
nsIPrincipal
*
aPrincipal
nsIURI
*
aURI
const
mozilla
:
:
OriginAttributes
*
aOriginAttributes
int32_t
aTypeIndex
const
nsACString
&
aType
uint32_t
*
aPermission
bool
aExactHostMatch
bool
aIncludingSession
)
;
nsresult
OpenDatabase
(
nsIFile
*
permissionsFile
)
;
void
InitDB
(
bool
aRemoveFile
)
;
nsresult
TryInitDB
(
bool
aRemoveFile
nsIInputStream
*
aDefaultsInputStream
)
;
void
AddIdleDailyMaintenanceJob
(
)
;
void
RemoveIdleDailyMaintenanceJob
(
)
;
void
PerformIdleDailyMaintenance
(
)
;
nsresult
ImportLatestDefaults
(
)
;
already_AddRefed
<
nsIInputStream
>
GetDefaultsInputStream
(
)
;
void
ConsumeDefaultsInputStream
(
nsIInputStream
*
aDefaultsInputStream
const
mozilla
:
:
MonitorAutoLock
&
aProofOfLock
)
;
nsresult
CreateTable
(
)
;
void
NotifyObserversWithPermission
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
const
char16_t
*
aData
)
;
void
NotifyObservers
(
nsIPermission
*
aPermission
const
char16_t
*
aData
)
;
void
CloseDB
(
bool
aRebuildOnSuccess
=
false
)
;
nsresult
RemoveAllInternal
(
bool
aNotifyObservers
)
;
nsresult
RemoveAllFromMemory
(
)
;
void
UpdateDB
(
OperationType
aOp
int64_t
aID
const
nsACString
&
aOrigin
const
nsACString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
)
;
nsresult
RemoveAllModifiedSince
(
int64_t
aModificationTime
)
;
template
<
class
T
>
nsresult
RemovePermissionEntries
(
T
aCondition
)
;
void
EnsureReadCompleted
(
)
;
nsresult
AddInternal
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
uint32_t
aPermission
int64_t
aID
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
NotifyOperationType
aNotifyOperation
DBOperationType
aDBOperation
const
bool
aIgnoreSessionPermissions
=
false
const
nsACString
*
aOriginString
=
nullptr
)
;
void
MaybeAddReadEntryFromMigration
(
const
nsACString
&
aOrigin
const
nsCString
&
aType
uint32_t
aPermission
uint32_t
aExpireType
int64_t
aExpireTime
int64_t
aModificationTime
int64_t
aId
)
;
nsRefPtrHashtable
<
nsCStringHashKey
mozilla
:
:
GenericNonExclusivePromise
:
:
Private
>
mPermissionKeyPromiseMap
;
nsCOMPtr
<
nsIFile
>
mPermissionsFile
;
mozilla
:
:
Monitor
mMonitor
;
enum
State
{
eInitializing
eDBInitialized
eReady
eClosed
}
;
mozilla
:
:
Atomic
<
State
>
mState
;
struct
ReadEntry
{
ReadEntry
(
)
:
mId
(
0
)
mPermission
(
0
)
mExpireType
(
0
)
mExpireTime
(
0
)
mModificationTime
(
0
)
{
}
nsCString
mOrigin
;
nsCString
mType
;
int64_t
mId
;
uint32_t
mPermission
;
uint32_t
mExpireType
;
int64_t
mExpireTime
;
int64_t
mModificationTime
;
bool
mFromMigration
;
}
;
nsTArray
<
ReadEntry
>
mReadEntries
;
struct
MigrationEntry
{
MigrationEntry
(
)
:
mId
(
0
)
mPermission
(
0
)
mExpireType
(
0
)
mExpireTime
(
0
)
mModificationTime
(
0
)
mIsInBrowserElement
(
false
)
{
}
nsCString
mHost
;
nsCString
mType
;
int64_t
mId
;
uint32_t
mPermission
;
uint32_t
mExpireType
;
int64_t
mExpireTime
;
int64_t
mModificationTime
;
bool
mIsInBrowserElement
;
}
;
nsTArray
<
MigrationEntry
>
mMigrationEntries
;
struct
DefaultEntry
{
DefaultEntry
(
)
:
mOp
(
eImportMatchTypeHost
)
mPermission
(
0
)
{
}
enum
Op
{
eImportMatchTypeHost
eImportMatchTypeOrigin
}
;
Op
mOp
;
nsCString
mHostOrOrigin
;
nsCString
mType
;
uint32_t
mPermission
;
}
;
nsTArray
<
DefaultEntry
>
mDefaultEntries
;
nsresult
Read
(
const
mozilla
:
:
MonitorAutoLock
&
aProofOfLock
)
;
void
CompleteRead
(
)
;
void
CompleteMigrations
(
)
;
bool
mMemoryOnlyDB
;
nsTHashtable
<
PermissionHashKey
>
mPermissionTable
;
int64_t
mLargestID
;
nsCOMPtr
<
nsIPrefBranch
>
mDefaultPrefBranch
;
mozilla
:
:
Vector
<
nsCString
512
>
mTypeArray
;
nsCOMPtr
<
nsIThread
>
mThread
;
struct
ThreadBoundData
{
nsCOMPtr
<
mozIStorageConnection
>
mDBConn
;
nsCOMPtr
<
mozIStorageStatement
>
mStmtInsert
;
nsCOMPtr
<
mozIStorageStatement
>
mStmtDelete
;
nsCOMPtr
<
mozIStorageStatement
>
mStmtUpdate
;
}
;
mozilla
:
:
ThreadBound
<
ThreadBoundData
>
mThreadBoundData
;
friend
class
DeleteFromMozHostListener
;
friend
class
CloseDatabaseListener
;
}
;
#
define
NS_PERMISSIONMANAGER_CID
\
{
\
0x4f6b5e00
0xc36
0x11d5
{
\
0xa5
0x35
0x0
0x10
0xa4
0x1
0xeb
0x10
\
}
\
}
#
endif
