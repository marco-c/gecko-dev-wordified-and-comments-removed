#
include
"
mozilla
/
PermissionDelegateHandler
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsContentPermissionHelper
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
StaticPrefs_permissions
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicyUtils
.
h
"
#
include
"
mozilla
/
dom
/
WindowContext
.
h
"
#
include
"
mozilla
/
PermissionManager
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
typedef
PermissionDelegateHandler
:
:
PermissionDelegatePolicy
DelegatePolicy
;
typedef
PermissionDelegateHandler
:
:
PermissionDelegateInfo
DelegateInfo
;
static
const
DelegateInfo
sPermissionsMap
[
]
=
{
{
"
geo
"
u
"
geolocation
"
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
}
{
"
geolocation
"
u
"
geolocation
"
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
}
{
"
desktop
-
notification
"
nullptr
DelegatePolicy
:
:
ePersistDeniedCrossOrigin
}
{
"
persistent
-
storage
"
nullptr
DelegatePolicy
:
:
ePersistDeniedCrossOrigin
}
{
"
vibration
"
nullptr
DelegatePolicy
:
:
ePersistDeniedCrossOrigin
}
{
"
midi
"
nullptr
DelegatePolicy
:
:
eDelegateUseIframeOrigin
}
{
"
midi
-
sysex
"
nullptr
DelegatePolicy
:
:
eDelegateUseIframeOrigin
}
{
"
storage
-
access
"
nullptr
DelegatePolicy
:
:
eDelegateUseIframeOrigin
}
{
"
camera
"
u
"
camera
"
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
}
{
"
microphone
"
u
"
microphone
"
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
}
{
"
screen
"
u
"
display
-
capture
"
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
}
{
"
xr
"
u
"
xr
-
spatial
-
tracking
"
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
}
{
"
localhost
"
u
"
localhost
"
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
}
{
"
local
-
network
"
u
"
local
-
network
"
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
}
{
"
screen
-
wake
-
lock
"
u
"
screen
-
wake
-
lock
"
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
}
}
;
static_assert
(
PermissionDelegateHandler
:
:
DELEGATED_PERMISSION_COUNT
=
=
(
sizeof
(
sPermissionsMap
)
/
sizeof
(
DelegateInfo
)
)
"
The
PermissionDelegateHandler
:
:
DELEGATED_PERMISSION_COUNT
must
"
"
match
to
the
"
"
length
of
sPermissionsMap
.
Please
update
it
.
"
)
;
NS_IMPL_CYCLE_COLLECTION
(
PermissionDelegateHandler
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
PermissionDelegateHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
PermissionDelegateHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PermissionDelegateHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsIPermissionDelegateHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
PermissionDelegateHandler
:
:
PermissionDelegateHandler
(
dom
:
:
Document
*
aDocument
)
:
mDocument
(
aDocument
)
{
MOZ_ASSERT
(
aDocument
)
;
}
const
DelegateInfo
*
PermissionDelegateHandler
:
:
GetPermissionDelegateInfo
(
const
nsAString
&
aPermissionName
)
{
nsAutoString
lowerContent
(
aPermissionName
)
;
ToLowerCase
(
lowerContent
)
;
for
(
const
auto
&
perm
:
sPermissionsMap
)
{
if
(
lowerContent
.
EqualsASCII
(
perm
.
mPermissionName
)
)
{
return
&
perm
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
PermissionDelegateHandler
:
:
MaybeUnsafePermissionDelegate
(
const
nsTArray
<
nsCString
>
&
aTypes
bool
*
aMaybeUnsafe
)
{
*
aMaybeUnsafe
=
false
;
for
(
auto
&
type
:
aTypes
)
{
const
DelegateInfo
*
info
=
GetPermissionDelegateInfo
(
NS_ConvertUTF8toUTF16
(
type
)
)
;
if
(
!
info
)
{
continue
;
}
nsAutoString
featureName
(
info
-
>
mFeatureName
)
;
if
(
FeaturePolicyUtils
:
:
IsFeatureUnsafeAllowedAll
(
mDocument
featureName
)
)
{
*
aMaybeUnsafe
=
true
;
return
NS_OK
;
}
}
return
NS_OK
;
}
nsresult
PermissionDelegateHandler
:
:
GetDelegatePrincipal
(
const
nsACString
&
aType
nsIContentPermissionRequest
*
aRequest
nsIPrincipal
*
*
aResult
)
{
MOZ_ASSERT
(
aRequest
)
;
const
DelegateInfo
*
info
=
GetPermissionDelegateInfo
(
NS_ConvertUTF8toUTF16
(
aType
)
)
;
if
(
!
info
)
{
*
aResult
=
nullptr
;
return
NS_OK
;
}
if
(
info
-
>
mPolicy
=
=
DelegatePolicy
:
:
eDelegateUseTopOrigin
|
|
info
-
>
mPolicy
=
=
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
)
{
return
aRequest
-
>
GetTopLevelPrincipal
(
aResult
)
;
}
return
aRequest
-
>
GetPrincipal
(
aResult
)
;
}
bool
PermissionDelegateHandler
:
:
Initialize
(
)
{
MOZ_ASSERT
(
mDocument
)
;
mPermissionManager
=
PermissionManager
:
:
GetInstance
(
)
;
if
(
!
mPermissionManager
)
{
return
false
;
}
mPrincipal
=
mDocument
-
>
NodePrincipal
(
)
;
return
true
;
}
static
bool
IsCrossOriginContentToTop
(
Document
*
aDocument
)
{
MOZ_ASSERT
(
aDocument
)
;
RefPtr
<
BrowsingContext
>
bc
=
aDocument
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
true
;
}
RefPtr
<
BrowsingContext
>
topBC
=
bc
-
>
Top
(
)
;
if
(
!
topBC
-
>
IsInProcess
(
)
)
{
return
true
;
}
RefPtr
<
Document
>
topDoc
=
topBC
-
>
GetDocument
(
)
;
if
(
!
topDoc
)
{
return
true
;
}
nsCOMPtr
<
nsIPrincipal
>
topLevelPrincipal
=
topDoc
-
>
NodePrincipal
(
)
;
return
!
aDocument
-
>
NodePrincipal
(
)
-
>
Subsumes
(
topLevelPrincipal
)
;
}
bool
PermissionDelegateHandler
:
:
HasFeaturePolicyAllowed
(
const
DelegateInfo
*
info
)
const
{
if
(
info
-
>
mPolicy
!
=
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
|
|
!
info
-
>
mFeatureName
)
{
return
true
;
}
nsAutoString
featureName
(
info
-
>
mFeatureName
)
;
return
FeaturePolicyUtils
:
:
IsFeatureAllowed
(
mDocument
featureName
)
;
}
bool
PermissionDelegateHandler
:
:
HasPermissionDelegated
(
const
nsACString
&
aType
)
const
{
MOZ_ASSERT
(
mDocument
)
;
if
(
mPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
true
;
}
const
DelegateInfo
*
info
=
GetPermissionDelegateInfo
(
NS_ConvertUTF8toUTF16
(
aType
)
)
;
if
(
!
info
|
|
!
HasFeaturePolicyAllowed
(
info
)
)
{
return
false
;
}
if
(
info
-
>
mPolicy
=
=
DelegatePolicy
:
:
ePersistDeniedCrossOrigin
&
&
!
mDocument
-
>
IsTopLevelContentDocument
(
)
&
&
IsCrossOriginContentToTop
(
mDocument
)
)
{
return
false
;
}
return
true
;
}
nsresult
PermissionDelegateHandler
:
:
GetPermission
(
const
nsACString
&
aType
uint32_t
*
aPermission
bool
aExactHostMatch
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mPrincipal
)
;
if
(
mPrincipal
-
>
IsSystemPrincipal
(
)
)
{
*
aPermission
=
nsIPermissionManager
:
:
ALLOW_ACTION
;
return
NS_OK
;
}
const
DelegateInfo
*
info
=
GetPermissionDelegateInfo
(
NS_ConvertUTF8toUTF16
(
aType
)
)
;
if
(
!
info
|
|
!
HasFeaturePolicyAllowed
(
info
)
)
{
*
aPermission
=
nsIPermissionManager
:
:
DENY_ACTION
;
return
NS_OK
;
}
nsresult
(
NS_STDCALL
nsIPermissionManager
:
:
*
testPermission
)
(
nsIPrincipal
*
const
nsACString
&
uint32_t
*
)
=
aExactHostMatch
?
&
nsIPermissionManager
:
:
TestExactPermissionFromPrincipal
:
&
nsIPermissionManager
:
:
TestPermissionFromPrincipal
;
if
(
info
-
>
mPolicy
=
=
DelegatePolicy
:
:
ePersistDeniedCrossOrigin
&
&
!
mDocument
-
>
IsTopLevelContentDocument
(
)
&
&
IsCrossOriginContentToTop
(
mDocument
)
)
{
*
aPermission
=
nsIPermissionManager
:
:
DENY_ACTION
;
return
NS_OK
;
}
nsIPrincipal
*
principal
=
mPrincipal
;
RefPtr
<
BrowsingContext
>
bc
=
mDocument
-
>
GetBrowsingContext
(
)
;
if
(
(
info
-
>
mPolicy
=
=
DelegatePolicy
:
:
eDelegateUseTopOrigin
|
|
info
-
>
mPolicy
=
=
DelegatePolicy
:
:
eDelegateUseFeaturePolicy
)
&
&
bc
)
{
RefPtr
<
WindowContext
>
topWC
=
bc
-
>
GetTopWindowContext
(
)
;
if
(
topWC
&
&
topWC
-
>
IsInProcess
(
)
)
{
RefPtr
<
Document
>
topDoc
=
topWC
-
>
GetBrowsingContext
(
)
-
>
GetDocument
(
)
;
if
(
topDoc
)
{
principal
=
topDoc
-
>
NodePrincipal
(
)
;
}
}
else
if
(
topWC
)
{
DelegatedPermissionList
list
=
aExactHostMatch
?
topWC
-
>
GetDelegatedExactHostMatchPermissions
(
)
:
topWC
-
>
GetDelegatedPermissions
(
)
;
size_t
idx
=
std
:
:
distance
(
sPermissionsMap
info
)
;
*
aPermission
=
list
.
mPermissions
[
idx
]
;
return
NS_OK
;
}
}
return
(
mPermissionManager
-
>
*
testPermission
)
(
principal
aType
aPermission
)
;
}
nsresult
PermissionDelegateHandler
:
:
GetPermissionForPermissionsAPI
(
const
nsACString
&
aType
uint32_t
*
aPermission
)
{
return
GetPermission
(
aType
aPermission
false
)
;
}
void
PermissionDelegateHandler
:
:
PopulateAllDelegatedPermissions
(
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mPermissionManager
)
;
if
(
!
mDocument
-
>
IsTopLevelContentDocument
(
)
)
{
return
;
}
RefPtr
<
WindowContext
>
wc
=
mDocument
-
>
GetWindowContext
(
)
;
NS_ENSURE_TRUE_VOID
(
wc
&
&
!
wc
-
>
IsDiscarded
(
)
)
;
DelegatedPermissionList
list
;
DelegatedPermissionList
exactHostMatchList
;
for
(
const
auto
&
perm
:
sPermissionsMap
)
{
size_t
idx
=
std
:
:
distance
(
sPermissionsMap
&
perm
)
;
nsDependentCString
type
(
perm
.
mPermissionName
)
;
uint32_t
permission
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
Unused
<
<
mPermissionManager
-
>
TestPermissionFromPrincipal
(
mPrincipal
type
&
permission
)
;
list
.
mPermissions
[
idx
]
=
permission
;
permission
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
Unused
<
<
mPermissionManager
-
>
TestExactPermissionFromPrincipal
(
mPrincipal
type
&
permission
)
;
exactHostMatchList
.
mPermissions
[
idx
]
=
permission
;
}
WindowContext
:
:
Transaction
txn
;
txn
.
SetDelegatedPermissions
(
list
)
;
txn
.
SetDelegatedExactHostMatchPermissions
(
exactHostMatchList
)
;
MOZ_ALWAYS_SUCCEEDS
(
txn
.
Commit
(
wc
)
)
;
}
void
PermissionDelegateHandler
:
:
UpdateDelegatedPermission
(
const
nsACString
&
aType
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mPermissionManager
)
;
if
(
!
mDocument
-
>
IsTopLevelContentDocument
(
)
)
{
return
;
}
RefPtr
<
WindowContext
>
wc
=
mDocument
-
>
GetWindowContext
(
)
;
NS_ENSURE_TRUE_VOID
(
wc
)
;
const
DelegateInfo
*
info
=
GetPermissionDelegateInfo
(
NS_ConvertUTF8toUTF16
(
aType
)
)
;
if
(
!
info
)
{
return
;
}
size_t
idx
=
std
:
:
distance
(
sPermissionsMap
info
)
;
WindowContext
:
:
Transaction
txn
;
bool
changed
=
false
;
DelegatedPermissionList
list
=
wc
-
>
GetDelegatedPermissions
(
)
;
if
(
UpdateDelegatePermissionInternal
(
list
aType
idx
&
nsIPermissionManager
:
:
TestPermissionFromPrincipal
)
)
{
txn
.
SetDelegatedPermissions
(
list
)
;
changed
=
true
;
}
DelegatedPermissionList
exactHostMatchList
=
wc
-
>
GetDelegatedExactHostMatchPermissions
(
)
;
if
(
UpdateDelegatePermissionInternal
(
exactHostMatchList
aType
idx
&
nsIPermissionManager
:
:
TestExactPermissionFromPrincipal
)
)
{
txn
.
SetDelegatedExactHostMatchPermissions
(
exactHostMatchList
)
;
changed
=
true
;
}
if
(
changed
)
{
MOZ_ALWAYS_SUCCEEDS
(
txn
.
Commit
(
wc
)
)
;
}
}
bool
PermissionDelegateHandler
:
:
UpdateDelegatePermissionInternal
(
PermissionDelegateHandler
:
:
DelegatedPermissionList
&
aList
const
nsACString
&
aType
size_t
aIdx
nsresult
(
NS_STDCALL
nsIPermissionManager
:
:
*
aTestFunc
)
(
nsIPrincipal
*
const
nsACString
&
uint32_t
*
)
)
{
MOZ_ASSERT
(
aTestFunc
)
;
MOZ_ASSERT
(
mPermissionManager
)
;
MOZ_ASSERT
(
mPrincipal
)
;
uint32_t
permission
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
Unused
<
<
(
mPermissionManager
-
>
*
aTestFunc
)
(
mPrincipal
aType
&
permission
)
;
if
(
aList
.
mPermissions
[
aIdx
]
!
=
permission
)
{
aList
.
mPermissions
[
aIdx
]
=
permission
;
return
true
;
}
return
false
;
}
}
