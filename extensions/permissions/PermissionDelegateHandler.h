#
ifndef
PermissionDelegateHandler_h__
#
define
PermissionDelegateHandler_h__
#
include
"
nsISupports
.
h
"
#
include
"
nsIPermissionDelegateHandler
.
h
"
class
nsIPrincipal
;
class
nsIContentPermissionRequest
;
namespace
mozilla
{
namespace
dom
{
class
Document
;
}
}
class
PermissionDelegateHandler
final
:
public
nsIPermissionDelegateHandler
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
PermissionDelegateHandler
)
NS_DECL_NSIPERMISSIONDELEGATEHANDLER
explicit
PermissionDelegateHandler
(
)
=
default
;
explicit
PermissionDelegateHandler
(
mozilla
:
:
dom
:
:
Document
*
aDocument
)
;
bool
Initialize
(
)
;
bool
HasPermissionDelegated
(
const
nsACString
&
aType
)
;
nsresult
GetPermission
(
const
nsACString
&
aType
uint32_t
*
aPermission
bool
aExactHostMatch
)
;
nsresult
GetPermissionForPermissionsAPI
(
const
nsACString
&
aType
uint32_t
*
aPermission
)
;
enum
PermissionDelegatePolicy
{
eDelegateUseTopOrigin
eDelegateUseFeaturePolicy
ePersistDeniedCrossOrigin
eDelegateUseIframeOrigin
}
;
typedef
struct
{
const
char
*
mPermissionName
;
const
char16_t
*
mFeatureName
;
PermissionDelegatePolicy
mPolicy
;
}
PermissionDelegateInfo
;
void
DropDocumentReference
(
)
{
mDocument
=
nullptr
;
}
static
const
PermissionDelegateInfo
*
GetPermissionDelegateInfo
(
const
nsAString
&
aPermissionName
)
;
static
nsresult
GetDelegatePrincipal
(
const
nsACString
&
aType
nsIContentPermissionRequest
*
aRequest
nsIPrincipal
*
*
aResult
)
;
private
:
~
PermissionDelegateHandler
(
)
=
default
;
bool
HasFeaturePolicyAllowed
(
const
PermissionDelegateInfo
*
info
)
const
;
mozilla
:
:
dom
:
:
Document
*
mDocument
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCOMPtr
<
nsIPrincipal
>
mTopLevelPrincipal
;
RefPtr
<
nsIPermissionManager
>
mPermissionManager
;
}
;
#
endif
