#
ifndef
PreloaderBase_h__
#
define
PreloaderBase_h__
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PreloadHashKey
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIRedirectResultListener
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsWeakReference
.
h
"
class
nsIChannel
;
class
nsINode
;
class
nsIRequest
;
class
nsIStreamListener
;
namespace
mozilla
{
namespace
dom
{
class
Document
;
}
class
PreloaderBase
:
public
SupportsWeakPtr
<
PreloaderBase
>
public
nsISupports
{
public
:
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
PreloaderBase
)
PreloaderBase
(
)
=
default
;
void
NotifyOpen
(
const
PreloadHashKey
&
aKey
dom
:
:
Document
*
aDocument
bool
aIsPreload
)
;
void
NotifyOpen
(
const
PreloadHashKey
&
aKey
nsIChannel
*
aChannel
dom
:
:
Document
*
aDocument
bool
aIsPreload
)
;
void
NotifyRestart
(
dom
:
:
Document
*
aDocument
PreloaderBase
*
aNewPreloader
=
nullptr
)
;
void
NotifyStart
(
nsIRequest
*
aRequest
)
;
void
NotifyStop
(
nsIRequest
*
aRequest
nsresult
aStatus
)
;
void
NotifyStop
(
nsresult
aStatus
)
;
void
NotifyValidating
(
)
;
void
NotifyValidated
(
nsresult
aStatus
)
;
enum
class
LoadBackground
{
Keep
Drop
}
;
void
NotifyUsage
(
LoadBackground
aLoadBackground
=
LoadBackground
:
:
Drop
)
;
bool
IsUsed
(
)
const
{
return
mIsUsed
;
}
void
RemoveSelf
(
dom
:
:
Document
*
aDocument
)
;
virtual
nsresult
AsyncConsume
(
nsIStreamListener
*
aListener
)
;
nsIChannel
*
Channel
(
)
const
{
return
mChannel
;
}
virtual
void
PrioritizeAsPreload
(
)
=
0
;
static
void
AddLoadBackgroundFlag
(
nsIChannel
*
aChannel
)
;
void
AddLinkPreloadNode
(
nsINode
*
aNode
)
;
void
RemoveLinkPreloadNode
(
nsINode
*
aNode
)
;
class
RedirectRecord
{
public
:
RedirectRecord
(
uint32_t
aFlags
already_AddRefed
<
nsIURI
>
aURI
)
:
mFlags
(
aFlags
)
mURI
(
aURI
)
{
}
uint32_t
Flags
(
)
const
{
return
mFlags
;
}
nsCString
Spec
(
)
const
;
nsCString
Fragment
(
)
const
;
private
:
uint32_t
mFlags
;
nsCOMPtr
<
nsIURI
>
mURI
;
}
;
const
nsTArray
<
RedirectRecord
>
&
Redirects
(
)
{
return
mRedirectRecords
;
}
protected
:
virtual
~
PreloaderBase
(
)
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
private
:
void
NotifyNodeEvent
(
nsINode
*
aNode
)
;
void
CancelUsageTimer
(
)
;
class
RedirectSink
final
:
public
nsIInterfaceRequestor
public
nsIChannelEventSink
public
nsIRedirectResultListener
{
RedirectSink
(
)
=
delete
;
virtual
~
RedirectSink
(
)
=
default
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIREDIRECTRESULTLISTENER
RedirectSink
(
PreloaderBase
*
aPreloader
nsIInterfaceRequestor
*
aCallbacks
)
;
private
:
nsMainThreadPtrHandle
<
PreloaderBase
>
mPreloader
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
nsCOMPtr
<
nsIChannel
>
mRedirectChannel
;
}
;
class
UsageTimer
final
:
public
nsITimerCallback
{
NS_DECL_ISUPPORTS
NS_DECL_NSITIMERCALLBACK
UsageTimer
(
PreloaderBase
*
aPreload
dom
:
:
Document
*
aDocument
)
;
private
:
~
UsageTimer
(
)
=
default
;
WeakPtr
<
dom
:
:
Document
>
mDocument
;
WeakPtr
<
PreloaderBase
>
mPreload
;
}
;
private
:
nsTArray
<
nsWeakPtr
>
mNodes
;
nsTArray
<
RedirectRecord
>
mRedirectRecords
;
nsCOMPtr
<
nsITimer
>
mUsageTimer
;
PreloadHashKey
mKey
;
bool
mShouldFireLoadEvent
=
false
;
bool
mIsUsed
=
false
;
Maybe
<
nsresult
>
mOnStopStatus
;
}
;
}
#
endif
