#
ifndef
FetchPreloader_h_
#
define
FetchPreloader_h_
#
include
"
mozilla
/
PreloaderBase
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsIStreamListener
.
h
"
class
nsIChannel
;
class
nsILoadGroup
;
class
nsIInterfaceRequestor
;
namespace
mozilla
{
class
FetchPreloader
:
public
PreloaderBase
public
nsIStreamListener
{
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
FetchPreloader
(
)
;
nsresult
OpenChannel
(
const
PreloadHashKey
&
aKey
nsIURI
*
aURI
const
CORSMode
aCORSMode
const
dom
:
:
ReferrerPolicy
&
aReferrerPolicy
dom
:
:
Document
*
aDocument
)
;
nsresult
AsyncConsume
(
nsIStreamListener
*
aListener
)
override
;
static
void
PrioritizeAsPreload
(
nsIChannel
*
aChannel
)
;
void
PrioritizeAsPreload
(
)
override
;
protected
:
explicit
FetchPreloader
(
nsContentPolicyType
aContentPolicyType
)
;
virtual
~
FetchPreloader
(
)
=
default
;
virtual
nsresult
CreateChannel
(
nsIChannel
*
*
aChannel
nsIURI
*
aURI
const
CORSMode
aCORSMode
const
dom
:
:
ReferrerPolicy
&
aReferrerPolicy
dom
:
:
Document
*
aDocument
nsILoadGroup
*
aLoadGroup
nsIInterfaceRequestor
*
aCallbacks
)
;
private
:
nsresult
CheckContentPolicy
(
nsIURI
*
aURI
dom
:
:
Document
*
aDocument
)
;
class
Cache
final
:
public
nsIStreamListener
{
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
void
AsyncConsume
(
nsIStreamListener
*
aListener
)
;
void
Consume
(
nsCOMPtr
<
nsIStreamListener
>
aListener
)
;
private
:
virtual
~
Cache
(
)
=
default
;
struct
StartRequest
{
}
;
struct
DataAvailable
{
nsCString
mData
;
}
;
struct
StopRequest
{
nsresult
mStatus
;
}
;
typedef
Variant
<
StartRequest
DataAvailable
StopRequest
>
Call
;
nsCOMPtr
<
nsIRequest
>
mRequest
;
nsCOMPtr
<
nsIStreamListener
>
mFinalListener
;
nsTArray
<
Call
>
mCalls
;
}
;
nsCOMPtr
<
nsIStreamListener
>
mConsumeListener
;
nsresult
mAsyncConsumeResult
=
NS_ERROR_NOT_AVAILABLE
;
nsContentPolicyType
mContentPolicyType
;
}
;
}
#
endif
