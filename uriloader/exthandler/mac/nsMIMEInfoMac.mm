#
import
<
ApplicationServices
/
ApplicationServices
.
h
>
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsMIMEInfoMac
.
h
"
#
include
"
nsILocalFileMac
.
h
"
NS_IMETHODIMP
nsMIMEInfoMac
:
:
GetDefaultDescription
(
nsAString
&
aDefaultDescription
)
{
if
(
mDefaultApplication
)
{
nsCOMPtr
<
nsILocalFileMac
>
macFile
=
do_QueryInterface
(
mDefaultApplication
)
;
if
(
macFile
)
{
bool
isPackage
;
(
void
)
macFile
-
>
IsPackage
(
&
isPackage
)
;
if
(
isPackage
)
return
macFile
-
>
GetBundleDisplayName
(
aDefaultDescription
)
;
}
}
return
nsMIMEInfoImpl
:
:
GetDefaultDescription
(
aDefaultDescription
)
;
}
NS_IMETHODIMP
nsMIMEInfoMac
:
:
LaunchWithFile
(
nsIFile
*
aFile
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsCOMPtr
<
nsIFile
>
application
;
nsresult
rv
;
NS_ASSERTION
(
mClass
=
=
eMIMEInfo
"
only
MIME
infos
are
currently
allowed
"
"
to
pass
content
by
value
"
)
;
if
(
AutomationOnlyCheckIfLaunchStubbed
(
aFile
)
)
{
return
NS_OK
;
}
if
(
mPreferredAction
=
=
useHelperApp
)
{
nsCOMPtr
<
nsILocalHandlerApp
>
localHandlerApp
=
do_QueryInterface
(
mPreferredApplication
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
localHandlerApp
-
>
GetExecutable
(
getter_AddRefs
(
application
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
mPreferredAction
=
=
useSystemDefault
)
{
application
=
mDefaultApplication
;
}
else
return
NS_ERROR_INVALID_ARG
;
nsCOMPtr
<
nsILocalFileMac
>
app
;
if
(
application
)
{
app
=
do_QueryInterface
(
application
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
else
{
nsCOMPtr
<
nsILocalFileMac
>
tempFile
=
do_QueryInterface
(
aFile
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
FSRef
tempFileRef
;
tempFile
-
>
GetFSRef
(
&
tempFileRef
)
;
FSRef
appFSRef
;
if
(
:
:
LSGetApplicationForItem
(
&
tempFileRef
kLSRolesAll
&
appFSRef
nullptr
)
=
=
noErr
)
{
app
=
(
do_CreateInstance
(
"
mozilla
.
org
/
file
/
local
;
1
"
)
)
;
if
(
!
app
)
return
NS_ERROR_FAILURE
;
app
-
>
InitWithFSRef
(
&
appFSRef
)
;
}
else
{
return
NS_ERROR_FAILURE
;
}
}
return
app
-
>
LaunchWithDoc
(
aFile
false
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsMIMEInfoMac
:
:
LoadUriInternal
(
nsIURI
*
aURI
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
nsAutoCString
uri
;
aURI
-
>
GetSpec
(
uri
)
;
if
(
!
uri
.
IsEmpty
(
)
)
{
CFURLRef
myURLRef
=
:
:
CFURLCreateWithBytes
(
kCFAllocatorDefault
(
const
UInt8
*
)
uri
.
get
(
)
strlen
(
uri
.
get
(
)
)
kCFStringEncodingUTF8
NULL
)
;
if
(
myURLRef
)
{
OSStatus
status
=
:
:
LSOpenCFURLRef
(
myURLRef
NULL
)
;
if
(
status
=
=
noErr
)
rv
=
NS_OK
;
:
:
CFRelease
(
myURLRef
)
;
}
}
return
rv
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
