#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
"
mozilla
/
net
/
NeckoCommon
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsOSHelperAppService
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsILocalFileMac
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsMIMEInfoMac
.
h
"
#
include
"
nsEmbedCID
.
h
"
#
import
<
CoreFoundation
/
CoreFoundation
.
h
>
#
import
<
ApplicationServices
/
ApplicationServices
.
h
>
#
define
HELPERAPPLAUNCHER_BUNDLE_URL
"
chrome
:
/
/
global
/
locale
/
helperAppLauncher
.
properties
"
#
define
BRAND_BUNDLE_URL
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
nsresult
GetDefaultBundleURL
(
const
nsACString
&
aScheme
CFURLRef
*
aBundleURL
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsresult
rv
=
NS_ERROR_NOT_AVAILABLE
;
CFStringRef
schemeCFString
=
:
:
CFStringCreateWithBytes
(
kCFAllocatorDefault
(
const
UInt8
*
)
PromiseFlatCString
(
aScheme
)
.
get
(
)
aScheme
.
Length
(
)
kCFStringEncodingUTF8
false
)
;
if
(
schemeCFString
)
{
CFStringRef
lookupCFString
=
:
:
CFStringCreateWithFormat
(
NULL
NULL
CFSTR
(
"
%
:
"
)
schemeCFString
)
;
if
(
lookupCFString
)
{
CFURLRef
lookupCFURL
=
:
:
CFURLCreateWithString
(
NULL
lookupCFString
NULL
)
;
if
(
lookupCFURL
)
{
if
(
available
(
macOS
10
.
10
*
)
)
{
*
aBundleURL
=
:
:
LSCopyDefaultApplicationURLForURL
(
lookupCFURL
kLSRolesAll
NULL
)
;
if
(
*
aBundleURL
)
{
rv
=
NS_OK
;
}
}
else
{
OSStatus
theErr
=
:
:
LSGetApplicationForURL
(
lookupCFURL
kLSRolesAll
NULL
aBundleURL
)
;
if
(
theErr
=
=
noErr
&
&
*
aBundleURL
)
{
rv
=
NS_OK
;
}
}
:
:
CFRelease
(
lookupCFURL
)
;
}
:
:
CFRelease
(
lookupCFString
)
;
}
:
:
CFRelease
(
schemeCFString
)
;
}
return
rv
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
using
mozilla
:
:
LogLevel
;
class
NSURLFileTypeMappingsInternal
;
interface
NSURLFileTypeMappings
:
NSObject
{
NSURLFileTypeMappingsInternal
*
_internal
;
}
+
(
NSURLFileTypeMappings
*
)
sharedMappings
;
-
(
NSString
*
)
MIMETypeForExtension
:
(
NSString
*
)
aString
;
-
(
NSString
*
)
preferredExtensionForMIMEType
:
(
NSString
*
)
aString
;
-
(
NSArray
*
)
extensionsForMIMEType
:
(
NSString
*
)
aString
;
end
nsOSHelperAppService
:
:
~
nsOSHelperAppService
(
)
{
}
nsresult
nsOSHelperAppService
:
:
OSProtocolHandlerExists
(
const
char
*
aProtocolScheme
bool
*
aHandlerExists
)
{
CFStringRef
schemeString
=
:
:
CFStringCreateWithBytes
(
kCFAllocatorDefault
(
const
UInt8
*
)
aProtocolScheme
strlen
(
aProtocolScheme
)
kCFStringEncodingUTF8
false
)
;
if
(
schemeString
)
{
CFArrayRef
handlerArray
=
:
:
LSCopyAllHandlersForURLScheme
(
schemeString
)
;
*
aHandlerExists
=
!
!
handlerArray
;
if
(
handlerArray
)
:
:
CFRelease
(
handlerArray
)
;
:
:
CFRelease
(
schemeString
)
;
}
else
{
*
aHandlerExists
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsOSHelperAppService
:
:
GetApplicationDescription
(
const
nsACString
&
aScheme
nsAString
&
_retval
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsresult
rv
=
NS_ERROR_NOT_AVAILABLE
;
CFURLRef
handlerBundleURL
;
rv
=
GetDefaultBundleURL
(
aScheme
&
handlerBundleURL
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
handlerBundleURL
)
{
CFBundleRef
handlerBundle
=
CFBundleCreate
(
NULL
handlerBundleURL
)
;
if
(
!
handlerBundle
)
{
:
:
CFRelease
(
handlerBundleURL
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
CFStringRef
bundleName
=
(
CFStringRef
)
:
:
CFBundleGetValueForInfoDictionaryKey
(
handlerBundle
kCFBundleNameKey
)
;
if
(
bundleName
)
{
AutoTArray
<
UniChar
255
>
buffer
;
CFIndex
bundleNameLength
=
:
:
CFStringGetLength
(
bundleName
)
;
buffer
.
SetLength
(
bundleNameLength
)
;
:
:
CFStringGetCharacters
(
bundleName
CFRangeMake
(
0
bundleNameLength
)
buffer
.
Elements
(
)
)
;
_retval
.
Assign
(
reinterpret_cast
<
char16_t
*
>
(
buffer
.
Elements
(
)
)
bundleNameLength
)
;
rv
=
NS_OK
;
}
:
:
CFRelease
(
handlerBundle
)
;
:
:
CFRelease
(
handlerBundleURL
)
;
}
return
rv
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
NS_IMETHODIMP
nsOSHelperAppService
:
:
IsCurrentAppOSDefaultForProtocol
(
const
nsACString
&
aScheme
bool
*
_retval
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsresult
rv
=
NS_ERROR_NOT_AVAILABLE
;
CFURLRef
handlerBundleURL
;
rv
=
GetDefaultBundleURL
(
aScheme
&
handlerBundleURL
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
handlerBundleURL
)
{
rv
=
NS_ERROR_NOT_AVAILABLE
;
CFBundleRef
appBundle
=
:
:
CFBundleGetMainBundle
(
)
;
if
(
appBundle
)
{
CFURLRef
selfURL
=
:
:
CFBundleCopyBundleURL
(
appBundle
)
;
*
_retval
=
:
:
CFEqual
(
selfURL
handlerBundleURL
)
;
rv
=
NS_OK
;
:
:
CFRelease
(
selfURL
)
;
}
:
:
CFRelease
(
handlerBundleURL
)
;
}
return
rv
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsOSHelperAppService
:
:
GetFileTokenForPath
(
const
char16_t
*
aPlatformAppPath
nsIFile
*
*
aFile
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsresult
rv
;
nsCOMPtr
<
nsILocalFileMac
>
localFile
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CFURLRef
pathAsCFURL
;
CFStringRef
pathAsCFString
=
:
:
CFStringCreateWithCharacters
(
NULL
reinterpret_cast
<
const
UniChar
*
>
(
aPlatformAppPath
)
NS_strlen
(
aPlatformAppPath
)
)
;
if
(
!
pathAsCFString
)
return
NS_ERROR_OUT_OF_MEMORY
;
if
(
:
:
CFStringGetCharacterAtIndex
(
pathAsCFString
0
)
=
=
'
/
'
)
{
pathAsCFURL
=
:
:
CFURLCreateWithFileSystemPath
(
nullptr
pathAsCFString
kCFURLPOSIXPathStyle
false
)
;
if
(
!
pathAsCFURL
)
{
:
:
CFRelease
(
pathAsCFString
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
{
if
(
:
:
CFStringGetLength
(
pathAsCFString
)
=
=
0
|
|
:
:
CFStringGetCharacterAtIndex
(
pathAsCFString
0
)
=
=
'
:
'
)
{
:
:
CFRelease
(
pathAsCFString
)
;
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
pathAsCFURL
=
:
:
CFURLCreateWithFileSystemPath
(
nullptr
pathAsCFString
kCFURLHFSPathStyle
false
)
;
if
(
!
pathAsCFURL
)
{
:
:
CFRelease
(
pathAsCFString
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
rv
=
localFile
-
>
InitWithCFURL
(
pathAsCFURL
)
;
:
:
CFRelease
(
pathAsCFString
)
;
:
:
CFRelease
(
pathAsCFURL
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
*
aFile
=
localFile
;
NS_IF_ADDREF
(
*
aFile
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
static
CFArrayRef
GetMIMETypesHandledByApp
(
FSRef
*
aAppRef
)
{
CFURLRef
appURL
=
:
:
CFURLCreateFromFSRef
(
kCFAllocatorDefault
aAppRef
)
;
if
(
!
appURL
)
{
return
NULL
;
}
CFDictionaryRef
infoDict
=
:
:
CFBundleCopyInfoDictionaryForURL
(
appURL
)
;
:
:
CFRelease
(
appURL
)
;
if
(
!
infoDict
)
{
return
NULL
;
}
CFTypeRef
cfObject
=
:
:
CFDictionaryGetValue
(
infoDict
CFSTR
(
"
CFBundleDocumentTypes
"
)
)
;
if
(
!
cfObject
|
|
(
:
:
CFGetTypeID
(
cfObject
)
!
=
:
:
CFArrayGetTypeID
(
)
)
)
{
:
:
CFRelease
(
infoDict
)
;
return
NULL
;
}
CFArrayRef
docTypes
=
static_cast
<
CFArrayRef
>
(
cfObject
)
;
CFIndex
docTypesCount
=
:
:
CFArrayGetCount
(
docTypes
)
;
if
(
docTypesCount
=
=
0
)
{
:
:
CFRelease
(
infoDict
)
;
return
NULL
;
}
CFMutableArrayRef
mimeTypes
=
:
:
CFArrayCreateMutable
(
kCFAllocatorDefault
0
&
kCFTypeArrayCallBacks
)
;
for
(
CFIndex
i
=
0
;
i
<
docTypesCount
;
+
+
i
)
{
cfObject
=
:
:
CFArrayGetValueAtIndex
(
docTypes
i
)
;
if
(
!
cfObject
|
|
(
:
:
CFGetTypeID
(
cfObject
)
!
=
:
:
CFDictionaryGetTypeID
(
)
)
)
{
continue
;
}
CFDictionaryRef
typeDict
=
static_cast
<
CFDictionaryRef
>
(
cfObject
)
;
cfObject
=
:
:
CFDictionaryGetValue
(
typeDict
CFSTR
(
"
LSItemContentTypes
"
)
)
;
if
(
cfObject
&
&
(
:
:
CFGetTypeID
(
cfObject
)
=
=
:
:
CFArrayGetTypeID
(
)
)
)
{
continue
;
}
cfObject
=
:
:
CFDictionaryGetValue
(
typeDict
CFSTR
(
"
CFBundleTypeMIMETypes
"
)
)
;
if
(
!
cfObject
|
|
(
:
:
CFGetTypeID
(
cfObject
)
!
=
:
:
CFArrayGetTypeID
(
)
)
)
{
continue
;
}
CFArrayRef
mimeTypeHolder
=
static_cast
<
CFArrayRef
>
(
cfObject
)
;
CFArrayAppendArray
(
mimeTypes
mimeTypeHolder
:
:
CFRangeMake
(
0
:
:
CFArrayGetCount
(
mimeTypeHolder
)
)
)
;
}
:
:
CFRelease
(
infoDict
)
;
if
(
!
:
:
CFArrayGetCount
(
mimeTypes
)
)
{
:
:
CFRelease
(
mimeTypes
)
;
mimeTypes
=
NULL
;
}
return
mimeTypes
;
}
nsresult
nsOSHelperAppService
:
:
GetMIMEInfoFromOS
(
const
nsACString
&
aMIMEType
const
nsACString
&
aFileExt
bool
*
aFound
nsIMIMEInfo
*
*
aMIMEInfo
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
*
aFound
=
false
;
const
nsCString
&
flatType
=
PromiseFlatCString
(
aMIMEType
)
;
const
nsCString
&
flatExt
=
PromiseFlatCString
(
aFileExt
)
;
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
Mac
:
HelperAppService
lookup
for
type
'
%
s
'
ext
'
%
s
'
\
n
"
flatType
.
get
(
)
flatExt
.
get
(
)
)
)
;
RefPtr
<
nsMIMEInfoMac
>
mimeInfoMac
=
new
nsMIMEInfoMac
(
aMIMEType
)
;
NSAutoreleasePool
*
localPool
=
[
[
NSAutoreleasePool
alloc
]
init
]
;
OSStatus
err
;
bool
haveAppForType
=
false
;
bool
haveAppForExt
=
false
;
bool
typeIsOctetStream
=
false
;
bool
typeAppIsDefault
=
false
;
bool
extAppIsDefault
=
false
;
FSRef
typeAppFSRef
;
FSRef
extAppFSRef
;
CFStringRef
cfMIMEType
=
NULL
;
if
(
!
aMIMEType
.
IsEmpty
(
)
)
{
typeIsOctetStream
=
aMIMEType
.
LowerCaseEqualsLiteral
(
APPLICATION_OCTET_STREAM
)
;
CFURLRef
appURL
=
NULL
;
cfMIMEType
=
:
:
CFStringCreateWithCString
(
NULL
flatType
.
get
(
)
kCFStringEncodingUTF8
)
;
if
(
cfMIMEType
)
{
err
=
:
:
LSCopyApplicationForMIMEType
(
cfMIMEType
kLSRolesAll
&
appURL
)
;
if
(
(
err
=
=
noErr
)
&
&
appURL
&
&
:
:
CFURLGetFSRef
(
appURL
&
typeAppFSRef
)
)
{
haveAppForType
=
true
;
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
LSCopyApplicationForMIMEType
found
a
default
application
\
n
"
)
)
;
}
if
(
appURL
)
{
:
:
CFRelease
(
appURL
)
;
}
}
}
if
(
!
aFileExt
.
IsEmpty
(
)
)
{
CFStringRef
cfExt
=
:
:
CFStringCreateWithCString
(
NULL
flatExt
.
get
(
)
kCFStringEncodingUTF8
)
;
if
(
cfExt
)
{
err
=
:
:
LSGetApplicationForInfo
(
kLSUnknownType
kLSUnknownCreator
cfExt
kLSRolesAll
&
extAppFSRef
nullptr
)
;
if
(
err
=
=
noErr
)
{
haveAppForExt
=
true
;
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
LSGetApplicationForInfo
found
a
default
application
\
n
"
)
)
;
}
:
:
CFRelease
(
cfExt
)
;
}
}
if
(
haveAppForType
&
&
haveAppForExt
)
{
if
(
:
:
FSCompareFSRefs
(
(
const
FSRef
*
)
&
typeAppFSRef
(
const
FSRef
*
)
&
extAppFSRef
)
=
=
noErr
)
{
typeAppIsDefault
=
true
;
*
aFound
=
true
;
}
}
else
if
(
haveAppForType
)
{
if
(
aFileExt
.
IsEmpty
(
)
)
{
typeAppIsDefault
=
true
;
*
aFound
=
true
;
}
}
if
(
(
!
haveAppForType
|
|
(
!
*
aFound
&
&
typeIsOctetStream
)
)
&
&
haveAppForExt
)
{
if
(
aMIMEType
.
IsEmpty
(
)
|
|
typeIsOctetStream
)
{
extAppIsDefault
=
true
;
*
aFound
=
true
;
}
else
{
CFArrayRef
extAppMIMETypes
=
GetMIMETypesHandledByApp
(
&
extAppFSRef
)
;
if
(
extAppMIMETypes
)
{
if
(
cfMIMEType
)
{
if
(
:
:
CFArrayContainsValue
(
extAppMIMETypes
:
:
CFRangeMake
(
0
:
:
CFArrayGetCount
(
extAppMIMETypes
)
)
cfMIMEType
)
)
{
extAppIsDefault
=
true
;
*
aFound
=
true
;
}
}
:
:
CFRelease
(
extAppMIMETypes
)
;
}
else
{
extAppIsDefault
=
true
;
*
aFound
=
true
;
}
}
}
if
(
cfMIMEType
)
{
:
:
CFRelease
(
cfMIMEType
)
;
}
if
(
aMIMEType
.
IsEmpty
(
)
)
{
if
(
haveAppForExt
)
{
NSURLFileTypeMappings
*
map
=
[
NSURLFileTypeMappings
sharedMappings
]
;
NSString
*
extStr
=
[
NSString
stringWithCString
:
flatExt
.
get
(
)
encoding
:
NSASCIIStringEncoding
]
;
NSString
*
typeStr
=
map
?
[
map
MIMETypeForExtension
:
extStr
]
:
NULL
;
if
(
typeStr
)
{
nsAutoCString
mimeType
;
mimeType
.
Assign
(
(
char
*
)
[
typeStr
cStringUsingEncoding
:
NSASCIIStringEncoding
]
)
;
mimeInfoMac
-
>
SetMIMEType
(
mimeType
)
;
haveAppForType
=
true
;
}
else
{
haveAppForExt
=
false
;
extAppIsDefault
=
false
;
*
aFound
=
false
;
}
}
else
{
mimeInfoMac
-
>
SetMIMEType
(
nsLiteralCString
(
APPLICATION_OCTET_STREAM
)
)
;
}
}
if
(
typeAppIsDefault
|
|
extAppIsDefault
)
{
if
(
haveAppForExt
)
mimeInfoMac
-
>
AppendExtension
(
aFileExt
)
;
nsresult
rv
;
nsCOMPtr
<
nsILocalFileMac
>
app
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
[
localPool
release
]
;
return
rv
;
}
CFStringRef
cfAppName
=
NULL
;
if
(
typeAppIsDefault
)
{
app
-
>
InitWithFSRef
(
&
typeAppFSRef
)
;
:
:
LSCopyItemAttribute
(
(
const
FSRef
*
)
&
typeAppFSRef
kLSRolesAll
kLSItemDisplayName
(
CFTypeRef
*
)
&
cfAppName
)
;
}
else
{
app
-
>
InitWithFSRef
(
&
extAppFSRef
)
;
:
:
LSCopyItemAttribute
(
(
const
FSRef
*
)
&
extAppFSRef
kLSRolesAll
kLSItemDisplayName
(
CFTypeRef
*
)
&
cfAppName
)
;
}
if
(
cfAppName
)
{
AutoTArray
<
UniChar
255
>
buffer
;
CFIndex
appNameLength
=
:
:
CFStringGetLength
(
cfAppName
)
;
buffer
.
SetLength
(
appNameLength
)
;
:
:
CFStringGetCharacters
(
cfAppName
CFRangeMake
(
0
appNameLength
)
buffer
.
Elements
(
)
)
;
nsAutoString
appName
;
appName
.
Assign
(
reinterpret_cast
<
char16_t
*
>
(
buffer
.
Elements
(
)
)
appNameLength
)
;
mimeInfoMac
-
>
SetDefaultDescription
(
appName
)
;
:
:
CFRelease
(
cfAppName
)
;
}
mimeInfoMac
-
>
SetDefaultApplication
(
app
)
;
mozilla
:
:
StaticPrefs
:
:
browser_download_improvements_to_download_panel
(
)
?
mimeInfoMac
-
>
SetPreferredAction
(
nsIMIMEInfo
:
:
saveToDisk
)
:
mimeInfoMac
-
>
SetPreferredAction
(
nsIMIMEInfo
:
:
useSystemDefault
)
;
}
else
{
mimeInfoMac
-
>
SetPreferredAction
(
nsIMIMEInfo
:
:
saveToDisk
)
;
}
nsAutoCString
mimeType
;
mimeInfoMac
-
>
GetMIMEType
(
mimeType
)
;
if
(
*
aFound
&
&
!
mimeType
.
IsEmpty
(
)
)
{
NSURLFileTypeMappings
*
map
=
[
NSURLFileTypeMappings
sharedMappings
]
;
NSString
*
typeStr
=
[
NSString
stringWithCString
:
mimeType
.
get
(
)
encoding
:
NSASCIIStringEncoding
]
;
NSArray
*
extensionsList
=
map
?
[
map
extensionsForMIMEType
:
typeStr
]
:
NULL
;
if
(
extensionsList
)
{
for
(
NSString
*
extension
in
extensionsList
)
{
nsAutoCString
ext
;
ext
.
Assign
(
(
char
*
)
[
extension
cStringUsingEncoding
:
NSASCIIStringEncoding
]
)
;
mimeInfoMac
-
>
AppendExtension
(
ext
)
;
}
}
if
(
CFStringRef
cfType
=
:
:
CFStringCreateWithCString
(
NULL
mimeType
.
get
(
)
kCFStringEncodingUTF8
)
)
{
if
(
CFStringRef
cfTypeDesc
=
:
:
UTTypeCopyDescription
(
cfType
)
)
{
AutoTArray
<
UniChar
255
>
buffer
;
CFIndex
typeDescLength
=
:
:
CFStringGetLength
(
cfTypeDesc
)
;
buffer
.
SetLength
(
typeDescLength
)
;
:
:
CFStringGetCharacters
(
cfTypeDesc
CFRangeMake
(
0
typeDescLength
)
buffer
.
Elements
(
)
)
;
nsAutoString
typeDesc
;
typeDesc
.
Assign
(
reinterpret_cast
<
char16_t
*
>
(
buffer
.
Elements
(
)
)
typeDescLength
)
;
mimeInfoMac
-
>
SetDescription
(
typeDesc
)
;
:
:
CFRelease
(
cfTypeDesc
)
;
}
:
:
CFRelease
(
cfType
)
;
}
}
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
OS
gave
us
:
type
'
%
s
'
found
'
%
i
'
\
n
"
mimeType
.
get
(
)
*
aFound
)
)
;
[
localPool
release
]
;
mimeInfoMac
.
forget
(
aMIMEInfo
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
NS_IMETHODIMP
nsOSHelperAppService
:
:
GetProtocolHandlerInfoFromOS
(
const
nsACString
&
aScheme
bool
*
found
nsIHandlerInfo
*
*
_retval
)
{
NS_ASSERTION
(
!
aScheme
.
IsEmpty
(
)
"
No
scheme
was
specified
!
"
)
;
nsresult
rv
=
OSProtocolHandlerExists
(
nsPromiseFlatCString
(
aScheme
)
.
get
(
)
found
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsMIMEInfoMac
*
handlerInfo
=
new
nsMIMEInfoMac
(
aScheme
nsMIMEInfoBase
:
:
eProtocolInfo
)
;
NS_ENSURE_TRUE
(
handlerInfo
NS_ERROR_OUT_OF_MEMORY
)
;
NS_ADDREF
(
*
_retval
=
handlerInfo
)
;
if
(
!
*
found
)
{
return
NS_OK
;
}
if
(
!
mozilla
:
:
net
:
:
IsNeckoChild
(
)
)
{
nsAutoString
desc
;
rv
=
GetApplicationDescription
(
aScheme
desc
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
GetApplicationDescription
failed
"
)
;
handlerInfo
-
>
SetDefaultDescription
(
desc
)
;
}
return
NS_OK
;
}
