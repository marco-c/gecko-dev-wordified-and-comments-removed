const
{
ComponentUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ComponentUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
TOPIC_PDFJS_HANDLER_CHANGED
=
"
pdfjs
:
handlerChanged
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gExternalProtocolService
"
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
"
nsIExternalProtocolService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gMIMEService
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
function
HandlerService
(
)
{
Services
.
obs
.
addObserver
(
this
"
handlersvc
-
json
-
replace
"
true
)
;
}
HandlerService
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
220cc253
-
b60f
-
41f6
-
b9cf
-
fdcb325f970f
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsISupportsWeakReference
"
"
nsIHandlerService
"
"
nsIObserver
"
]
)
__store
:
null
get
_store
(
)
{
if
(
!
this
.
__store
)
{
this
.
__store
=
new
JSONFile
(
{
path
:
PathUtils
.
join
(
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
.
path
"
handlers
.
json
"
)
dataPostProcessor
:
this
.
_dataPostProcessor
.
bind
(
this
)
}
)
;
}
this
.
_ensureStoreInitialized
(
)
;
return
this
.
__store
;
}
__storeInitialized
:
false
_ensureStoreInitialized
(
)
{
if
(
!
this
.
__storeInitialized
)
{
this
.
__storeInitialized
=
true
;
this
.
__store
.
ensureDataReady
(
)
;
this
.
_injectDefaultProtocolHandlersIfNeeded
(
)
;
this
.
_migrateProtocolHandlersIfNeeded
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
handlersvc
-
store
-
initialized
"
)
;
}
}
_dataPostProcessor
(
data
)
{
return
data
.
defaultHandlersVersion
?
data
:
{
defaultHandlersVersion
:
{
}
mimeTypes
:
{
}
schemes
:
{
}
}
;
}
_injectDefaultProtocolHandlersIfNeeded
(
)
{
let
prefsDefaultHandlersVersion
;
try
{
prefsDefaultHandlersVersion
=
Services
.
prefs
.
getComplexValue
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
Ci
.
nsIPrefLocalizedString
)
;
}
catch
(
ex
)
{
if
(
ex
instanceof
Components
.
Exception
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_UNEXPECTED
)
{
return
;
}
throw
ex
;
}
try
{
prefsDefaultHandlersVersion
=
Number
(
prefsDefaultHandlersVersion
.
data
)
;
let
locale
=
Services
.
locale
.
appLocaleAsBCP47
;
let
defaultHandlersVersion
=
this
.
_store
.
data
.
defaultHandlersVersion
[
locale
]
|
|
0
;
if
(
defaultHandlersVersion
<
prefsDefaultHandlersVersion
)
{
this
.
_injectDefaultProtocolHandlers
(
)
;
this
.
_store
.
data
.
defaultHandlersVersion
[
locale
]
=
prefsDefaultHandlersVersion
;
this
.
_store
.
saveSoon
(
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
_injectDefaultProtocolHandlers
(
)
{
let
schemesPrefBranch
=
Services
.
prefs
.
getBranch
(
"
gecko
.
handlerService
.
schemes
.
"
)
;
let
schemePrefList
=
schemesPrefBranch
.
getChildList
(
"
"
)
;
let
schemes
=
{
}
;
for
(
let
schemePrefName
of
schemePrefList
)
{
let
[
scheme
handlerNumber
attribute
]
=
schemePrefName
.
split
(
"
.
"
)
;
try
{
let
attrData
=
schemesPrefBranch
.
getComplexValue
(
schemePrefName
Ci
.
nsIPrefLocalizedString
)
.
data
;
if
(
!
(
scheme
in
schemes
)
)
{
schemes
[
scheme
]
=
{
}
;
}
if
(
!
(
handlerNumber
in
schemes
[
scheme
]
)
)
{
schemes
[
scheme
]
[
handlerNumber
]
=
{
}
;
}
schemes
[
scheme
]
[
handlerNumber
]
[
attribute
]
=
attrData
;
}
catch
(
ex
)
{
}
}
for
(
let
[
scheme
handlerObject
]
of
Array
.
from
(
Object
.
entries
(
schemes
)
)
)
{
let
handlers
=
Array
.
from
(
Object
.
entries
(
handlerObject
)
)
;
let
validHandlers
=
0
;
for
(
let
[
key
obj
]
of
handlers
)
{
if
(
!
obj
.
uriTemplate
|
|
!
obj
.
uriTemplate
.
startsWith
(
"
https
:
/
/
"
)
|
|
!
obj
.
uriTemplate
.
toLowerCase
(
)
.
includes
(
"
%
s
"
)
)
{
delete
handlerObject
[
key
]
;
}
else
{
validHandlers
+
+
;
}
}
if
(
!
validHandlers
)
{
delete
schemes
[
scheme
]
;
}
}
for
(
let
scheme
of
Object
.
keys
(
schemes
)
)
{
let
existingSchemeInfo
=
this
.
_store
.
data
.
schemes
[
scheme
]
;
if
(
!
existingSchemeInfo
)
{
existingSchemeInfo
=
{
stubEntry
:
true
handlers
:
[
null
]
}
;
this
.
_store
.
data
.
schemes
[
scheme
]
=
existingSchemeInfo
;
}
let
{
handlers
}
=
existingSchemeInfo
;
for
(
let
handlerNumber
of
Object
.
keys
(
schemes
[
scheme
]
)
)
{
let
newHandler
=
schemes
[
scheme
]
[
handlerNumber
]
;
let
matchingTemplate
=
handler
=
>
handler
&
&
handler
.
uriTemplate
=
=
newHandler
.
uriTemplate
;
if
(
!
handlers
.
some
(
matchingTemplate
)
)
{
handlers
.
push
(
newHandler
)
;
}
}
}
}
_migrateProtocolHandlersIfNeeded
(
)
{
const
kMigrations
=
{
"
30boxes
"
:
(
)
=
>
{
const
k30BoxesRegex
=
/
^
https
?
:
\
/
\
/
(
?
:
www
\
.
)
?
30boxes
.
com
\
/
external
\
/
widget
/
i
;
let
webcalHandler
=
gExternalProtocolService
.
getProtocolHandlerInfo
(
"
webcal
"
)
;
if
(
this
.
exists
(
webcalHandler
)
)
{
this
.
fillHandlerInfo
(
webcalHandler
"
"
)
;
let
shouldStore
=
false
;
let
handlers
=
webcalHandler
.
possibleApplicationHandlers
;
for
(
let
i
=
handlers
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
app
=
handlers
.
queryElementAt
(
i
Ci
.
nsIHandlerApp
)
;
if
(
app
instanceof
Ci
.
nsIWebHandlerApp
&
&
k30BoxesRegex
.
test
(
app
.
uriTemplate
)
)
{
shouldStore
=
true
;
handlers
.
removeElementAt
(
i
)
;
}
}
if
(
webcalHandler
.
preferredApplicationHandler
)
{
let
app
=
webcalHandler
.
preferredApplicationHandler
;
if
(
app
instanceof
Ci
.
nsIWebHandlerApp
&
&
k30BoxesRegex
.
test
(
app
.
uriTemplate
)
)
{
webcalHandler
.
preferredApplicationHandler
=
null
;
shouldStore
=
true
;
}
}
if
(
shouldStore
)
{
this
.
store
(
webcalHandler
)
;
}
}
}
"
secure
-
mail
"
:
(
)
=
>
{
const
kSubstitutions
=
new
Map
(
[
[
"
http
:
/
/
compose
.
mail
.
yahoo
.
co
.
jp
/
ym
/
Compose
?
To
=
%
s
"
"
https
:
/
/
mail
.
yahoo
.
co
.
jp
/
compose
/
?
To
=
%
s
"
]
[
"
http
:
/
/
www
.
inbox
.
lv
/
rfc2368
/
?
value
=
%
s
"
"
https
:
/
/
mail
.
inbox
.
lv
/
compose
?
to
=
%
s
"
]
[
"
http
:
/
/
poczta
.
interia
.
pl
/
mh
/
?
mailto
=
%
s
"
"
https
:
/
/
poczta
.
interia
.
pl
/
mh
/
?
mailto
=
%
s
"
]
[
"
http
:
/
/
win
.
mail
.
ru
/
cgi
-
bin
/
sentmsg
?
mailto
=
%
s
"
"
https
:
/
/
e
.
mail
.
ru
/
cgi
-
bin
/
sentmsg
?
mailto
=
%
s
"
]
]
)
;
function
maybeReplaceURL
(
app
)
{
if
(
app
instanceof
Ci
.
nsIWebHandlerApp
)
{
let
{
uriTemplate
}
=
app
;
let
sub
=
kSubstitutions
.
get
(
uriTemplate
)
;
if
(
sub
)
{
app
.
uriTemplate
=
sub
;
return
true
;
}
}
return
false
;
}
let
mailHandler
=
gExternalProtocolService
.
getProtocolHandlerInfo
(
"
mailto
"
)
;
if
(
this
.
exists
(
mailHandler
)
)
{
this
.
fillHandlerInfo
(
mailHandler
"
"
)
;
let
handlers
=
mailHandler
.
possibleApplicationHandlers
;
let
shouldStore
=
false
;
for
(
let
i
=
handlers
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
app
=
handlers
.
queryElementAt
(
i
Ci
.
nsIHandlerApp
)
;
shouldStore
|
=
maybeReplaceURL
(
app
)
;
}
if
(
mailHandler
.
preferredApplicationHandler
)
{
shouldStore
|
=
maybeReplaceURL
(
mailHandler
.
preferredApplicationHandler
)
;
}
if
(
shouldStore
)
{
this
.
store
(
mailHandler
)
;
}
}
}
}
;
let
migrationsToRun
=
Services
.
prefs
.
getCharPref
(
"
browser
.
handlers
.
migrations
"
"
"
)
;
migrationsToRun
=
migrationsToRun
?
migrationsToRun
.
split
(
"
"
)
:
[
]
;
for
(
let
migration
of
migrationsToRun
)
{
migration
.
trim
(
)
;
try
{
kMigrations
[
migration
]
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
if
(
migrationsToRun
.
length
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
handlers
.
migrations
"
)
;
}
}
_onDBChange
(
)
{
return
(
async
(
)
=
>
{
if
(
this
.
__store
)
{
await
this
.
__store
.
finalize
(
)
;
}
this
.
__store
=
null
;
this
.
__storeInitialized
=
false
;
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
!
=
"
handlersvc
-
json
-
replace
"
)
{
return
;
}
let
promise
=
this
.
_onDBChange
(
)
;
promise
.
then
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
handlersvc
-
json
-
replace
-
complete
"
)
;
}
)
;
}
asyncInit
(
)
{
if
(
!
this
.
__store
)
{
this
.
__store
=
new
JSONFile
(
{
path
:
PathUtils
.
join
(
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
.
path
"
handlers
.
json
"
)
dataPostProcessor
:
this
.
_dataPostProcessor
.
bind
(
this
)
}
)
;
this
.
__store
.
load
(
)
.
then
(
(
)
=
>
{
if
(
this
.
__store
)
{
this
.
_ensureStoreInitialized
(
)
;
}
}
)
.
catch
(
Cu
.
reportError
)
;
}
}
enumerate
(
)
{
let
handlers
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
type
of
Object
.
keys
(
this
.
_store
.
data
.
mimeTypes
)
)
{
let
handler
=
gMIMEService
.
getFromTypeAndExtension
(
type
null
)
;
handlers
.
appendElement
(
handler
)
;
}
for
(
let
type
of
Object
.
keys
(
this
.
_store
.
data
.
schemes
)
)
{
let
handler
=
new
Proxy
(
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIHandlerInfo
"
]
)
type
get
_handlerInfo
(
)
{
delete
this
.
_handlerInfo
;
return
(
this
.
_handlerInfo
=
gExternalProtocolService
.
getProtocolHandlerInfo
(
type
)
)
;
}
}
{
get
(
target
name
)
{
return
target
[
name
]
|
|
target
.
_handlerInfo
[
name
]
;
}
set
(
target
name
value
)
{
target
.
_handlerInfo
[
name
]
=
value
;
}
}
)
;
handlers
.
appendElement
(
handler
)
;
}
return
handlers
.
enumerate
(
Ci
.
nsIHandlerInfo
)
;
}
store
(
handlerInfo
)
{
let
handlerList
=
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
;
let
storedHandlerInfo
=
handlerList
[
handlerInfo
.
type
]
;
if
(
!
storedHandlerInfo
)
{
storedHandlerInfo
=
{
}
;
handlerList
[
handlerInfo
.
type
]
=
storedHandlerInfo
;
}
if
(
handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
saveToDisk
|
|
handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useSystemDefault
|
|
handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
handleInternally
|
|
(
handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
alwaysAsk
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
download
.
improvements_to_download_panel
"
)
)
)
{
storedHandlerInfo
.
action
=
handlerInfo
.
preferredAction
;
}
else
{
storedHandlerInfo
.
action
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
}
if
(
handlerInfo
.
alwaysAskBeforeHandling
)
{
storedHandlerInfo
.
ask
=
true
;
}
else
{
delete
storedHandlerInfo
.
ask
;
}
let
handlers
=
[
]
;
if
(
handlerInfo
.
preferredApplicationHandler
)
{
handlers
.
push
(
handlerInfo
.
preferredApplicationHandler
)
;
}
for
(
let
handler
of
handlerInfo
.
possibleApplicationHandlers
.
enumerate
(
Ci
.
nsIHandlerApp
)
)
{
if
(
!
handlers
.
some
(
h
=
>
h
.
equals
(
handler
)
)
)
{
handlers
.
push
(
handler
)
;
}
}
let
serializableHandlers
=
handlers
.
map
(
h
=
>
this
.
handlerAppToSerializable
(
h
)
)
.
filter
(
h
=
>
h
)
;
if
(
serializableHandlers
.
length
)
{
if
(
!
handlerInfo
.
preferredApplicationHandler
)
{
serializableHandlers
.
unshift
(
null
)
;
}
storedHandlerInfo
.
handlers
=
serializableHandlers
;
}
else
{
delete
storedHandlerInfo
.
handlers
;
}
if
(
this
.
_isMIMEInfo
(
handlerInfo
)
)
{
let
extensions
=
storedHandlerInfo
.
extensions
|
|
[
]
;
for
(
let
extension
of
handlerInfo
.
getFileExtensions
(
)
)
{
extension
=
extension
.
toLowerCase
(
)
;
if
(
!
extensions
.
includes
(
extension
)
)
{
extensions
.
push
(
extension
)
;
}
}
if
(
extensions
.
length
)
{
storedHandlerInfo
.
extensions
=
extensions
;
}
else
{
delete
storedHandlerInfo
.
extensions
;
}
}
delete
storedHandlerInfo
.
stubEntry
;
this
.
_store
.
saveSoon
(
)
;
if
(
handlerInfo
.
type
=
=
"
application
/
pdf
"
)
{
Services
.
obs
.
notifyObservers
(
null
TOPIC_PDFJS_HANDLER_CHANGED
)
;
}
}
fillHandlerInfo
(
handlerInfo
overrideType
)
{
let
type
=
overrideType
|
|
handlerInfo
.
type
;
let
storedHandlerInfo
=
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
[
type
]
;
if
(
!
storedHandlerInfo
)
{
throw
new
Components
.
Exception
(
"
handlerSvc
fillHandlerInfo
:
don
'
t
know
this
type
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
let
isStub
=
!
!
storedHandlerInfo
.
stubEntry
;
if
(
!
isStub
)
{
handlerInfo
.
preferredAction
=
storedHandlerInfo
.
action
;
handlerInfo
.
alwaysAskBeforeHandling
=
!
!
storedHandlerInfo
.
ask
;
}
else
{
gExternalProtocolService
.
setProtocolHandlerDefaults
(
handlerInfo
handlerInfo
.
hasDefaultHandler
)
;
if
(
handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
alwaysAsk
&
&
handlerInfo
.
alwaysAskBeforeHandling
)
{
handlerInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
}
}
this
.
_appendStoredHandlers
(
handlerInfo
storedHandlerInfo
.
handlers
isStub
)
;
if
(
this
.
_isMIMEInfo
(
handlerInfo
)
&
&
storedHandlerInfo
.
extensions
)
{
for
(
let
extension
of
storedHandlerInfo
.
extensions
)
{
handlerInfo
.
appendExtension
(
extension
)
;
}
}
else
if
(
this
.
_mockedHandler
)
{
this
.
_insertMockedHandler
(
handlerInfo
)
;
}
}
_appendStoredHandlers
(
handlerInfo
storedHandlers
keepPreferredApp
)
{
let
isFirstItem
=
true
;
for
(
let
handler
of
storedHandlers
|
|
[
null
]
)
{
let
handlerApp
=
this
.
handlerAppFromSerializable
(
handler
|
|
{
}
)
;
if
(
isFirstItem
)
{
isFirstItem
=
false
;
if
(
!
keepPreferredApp
)
{
handlerInfo
.
preferredApplicationHandler
=
handlerApp
;
}
}
if
(
handlerApp
)
{
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
handlerApp
)
;
}
}
}
handlerAppToSerializable
(
handler
)
{
if
(
handler
instanceof
Ci
.
nsILocalHandlerApp
)
{
return
{
name
:
handler
.
name
path
:
handler
.
executable
.
path
}
;
}
else
if
(
handler
instanceof
Ci
.
nsIWebHandlerApp
)
{
return
{
name
:
handler
.
name
uriTemplate
:
handler
.
uriTemplate
}
;
}
else
if
(
handler
instanceof
Ci
.
nsIDBusHandlerApp
)
{
return
{
name
:
handler
.
name
service
:
handler
.
service
method
:
handler
.
method
objectPath
:
handler
.
objectPath
dBusInterface
:
handler
.
dBusInterface
}
;
}
else
if
(
handler
instanceof
Ci
.
nsIGIOMimeApp
)
{
return
{
name
:
handler
.
name
command
:
handler
.
command
}
;
}
return
null
;
}
handlerAppFromSerializable
(
handlerObj
)
{
let
handlerApp
;
if
(
"
path
"
in
handlerObj
)
{
try
{
let
file
=
new
FileUtils
.
File
(
handlerObj
.
path
)
;
if
(
!
file
.
exists
(
)
)
{
return
null
;
}
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
handlerApp
.
executable
=
file
;
}
catch
(
ex
)
{
return
null
;
}
}
else
if
(
"
uriTemplate
"
in
handlerObj
)
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
handlerApp
.
uriTemplate
=
handlerObj
.
uriTemplate
;
}
else
if
(
"
service
"
in
handlerObj
)
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
dbus
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIDBusHandlerApp
)
;
handlerApp
.
service
=
handlerObj
.
service
;
handlerApp
.
method
=
handlerObj
.
method
;
handlerApp
.
objectPath
=
handlerObj
.
objectPath
;
handlerApp
.
dBusInterface
=
handlerObj
.
dBusInterface
;
}
else
if
(
"
command
"
in
handlerObj
&
&
"
mozilla
.
org
/
gio
-
service
;
1
"
in
Cc
)
{
try
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
gio
-
service
;
1
"
]
.
getService
(
Ci
.
nsIGIOService
)
.
createAppFromCommand
(
handlerObj
.
command
handlerObj
.
name
)
;
}
catch
(
ex
)
{
return
null
;
}
}
else
{
return
null
;
}
handlerApp
.
name
=
handlerObj
.
name
;
return
handlerApp
;
}
_getHandlerListByHandlerInfoType
(
handlerInfo
)
{
return
this
.
_isMIMEInfo
(
handlerInfo
)
?
this
.
_store
.
data
.
mimeTypes
:
this
.
_store
.
data
.
schemes
;
}
_isMIMEInfo
(
handlerInfo
)
{
return
(
handlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
handlerInfo
.
type
.
includes
(
"
/
"
)
)
;
}
exists
(
handlerInfo
)
{
return
(
handlerInfo
.
type
in
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
)
;
}
remove
(
handlerInfo
)
{
delete
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
[
handlerInfo
.
type
]
;
this
.
_store
.
saveSoon
(
)
;
}
getTypeFromExtension
(
fileExtension
)
{
let
extension
=
fileExtension
.
toLowerCase
(
)
;
let
mimeTypes
=
this
.
_store
.
data
.
mimeTypes
;
for
(
let
type
of
Object
.
keys
(
mimeTypes
)
)
{
if
(
mimeTypes
[
type
]
.
extensions
&
&
mimeTypes
[
type
]
.
extensions
.
includes
(
extension
)
)
{
return
type
;
}
}
return
"
"
;
}
_mockedHandler
:
null
_mockedProtocol
:
null
_insertMockedHandler
(
handlerInfo
)
{
if
(
handlerInfo
.
type
=
=
this
.
_mockedProtocol
)
{
handlerInfo
.
preferredApplicationHandler
=
this
.
_mockedHandler
;
handlerInfo
.
possibleApplicationHandlers
.
insertElementAt
(
this
.
_mockedHandler
0
)
;
}
}
mockProtocolHandler
(
protocol
)
{
if
(
!
protocol
)
{
this
.
_mockedProtocol
=
null
;
this
.
_mockedHandler
=
null
;
return
;
}
this
.
_mockedProtocol
=
protocol
;
this
.
_mockedHandler
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsILocalHandlerApp
]
)
launchWithURI
(
uri
context
)
{
Services
.
obs
.
notifyObservers
(
uri
"
mocked
-
protocol
-
handler
"
)
;
}
name
:
"
Mocked
handler
"
detailedDescription
:
"
Mocked
handler
for
tests
"
equals
(
x
)
{
return
x
=
=
this
;
}
get
executable
(
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
f
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
f
.
initWithPath
(
"
/
Applications
/
Safari
.
app
"
)
;
return
f
;
}
return
Services
.
dirsvc
.
get
(
"
XCurProcD
"
Ci
.
nsIFile
)
;
}
parameterCount
:
0
clearParameters
(
)
{
}
appendParameter
(
)
{
}
getParameter
(
)
{
}
parameterExists
(
)
{
return
false
;
}
}
;
}
}
;
this
.
NSGetFactory
=
ComponentUtils
.
generateNSGetFactory
(
[
HandlerService
]
)
;
