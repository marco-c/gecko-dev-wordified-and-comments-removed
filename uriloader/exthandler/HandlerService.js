const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gExternalProtocolService
"
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
"
nsIExternalProtocolService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gMIMEService
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
function
HandlerService
(
)
{
Services
.
obs
.
addObserver
(
this
"
handlersvc
-
json
-
replace
"
true
)
;
}
HandlerService
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
220cc253
-
b60f
-
41f6
-
b9cf
-
fdcb325f970f
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsISupportsWeakReference
Ci
.
nsIHandlerService
Ci
.
nsIObserver
]
)
__store
:
null
get
_store
(
)
{
if
(
!
this
.
__store
)
{
this
.
__store
=
new
JSONFile
(
{
path
:
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
handlers
.
json
"
)
dataPostProcessor
:
this
.
_dataPostProcessor
.
bind
(
this
)
}
)
;
}
this
.
_ensureStoreInitialized
(
)
;
return
this
.
__store
;
}
__storeInitialized
:
false
_ensureStoreInitialized
(
)
{
if
(
!
this
.
__storeInitialized
)
{
this
.
__storeInitialized
=
true
;
this
.
__store
.
ensureDataReady
(
)
;
this
.
_injectDefaultProtocolHandlersIfNeeded
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
handlersvc
-
store
-
initialized
"
)
;
}
}
_dataPostProcessor
(
data
)
{
return
data
.
defaultHandlersVersion
?
data
:
{
defaultHandlersVersion
:
{
}
mimeTypes
:
{
}
schemes
:
{
}
}
;
}
_injectDefaultProtocolHandlersIfNeeded
(
)
{
let
prefsDefaultHandlersVersion
;
try
{
prefsDefaultHandlersVersion
=
Services
.
prefs
.
getComplexValue
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
Ci
.
nsIPrefLocalizedString
)
;
}
catch
(
ex
)
{
if
(
ex
instanceof
Components
.
Exception
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_UNEXPECTED
)
{
return
;
}
throw
ex
;
}
try
{
prefsDefaultHandlersVersion
=
Number
(
prefsDefaultHandlersVersion
.
data
)
;
let
locale
=
Services
.
locale
.
appLocaleAsLangTag
;
let
defaultHandlersVersion
=
this
.
_store
.
data
.
defaultHandlersVersion
[
locale
]
|
|
0
;
if
(
defaultHandlersVersion
<
prefsDefaultHandlersVersion
)
{
this
.
_injectDefaultProtocolHandlers
(
)
;
this
.
_store
.
data
.
defaultHandlersVersion
[
locale
]
=
prefsDefaultHandlersVersion
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
_injectDefaultProtocolHandlers
(
)
{
let
schemesPrefBranch
=
Services
.
prefs
.
getBranch
(
"
gecko
.
handlerService
.
schemes
.
"
)
;
let
schemePrefList
=
schemesPrefBranch
.
getChildList
(
"
"
)
;
let
schemes
=
{
}
;
for
(
let
schemePrefName
of
schemePrefList
)
{
let
[
scheme
handlerNumber
attribute
]
=
schemePrefName
.
split
(
"
.
"
)
;
try
{
let
attrData
=
schemesPrefBranch
.
getComplexValue
(
schemePrefName
Ci
.
nsIPrefLocalizedString
)
.
data
;
if
(
!
(
scheme
in
schemes
)
)
{
schemes
[
scheme
]
=
{
}
;
}
if
(
!
(
handlerNumber
in
schemes
[
scheme
]
)
)
{
schemes
[
scheme
]
[
handlerNumber
]
=
{
}
;
}
schemes
[
scheme
]
[
handlerNumber
]
[
attribute
]
=
attrData
;
}
catch
(
ex
)
{
}
}
for
(
let
scheme
of
Object
.
keys
(
schemes
)
)
{
let
protoInfo
=
gExternalProtocolService
.
getProtocolHandlerInfo
(
scheme
)
;
let
possibleHandlers
=
protoInfo
.
possibleApplicationHandlers
;
for
(
let
handlerNumber
of
Object
.
keys
(
schemes
[
scheme
]
)
)
{
let
handlerApp
=
this
.
handlerAppFromSerializable
(
schemes
[
scheme
]
[
handlerNumber
]
)
;
possibleHandlers
.
appendElement
(
handlerApp
false
)
;
}
this
.
store
(
protoInfo
)
;
}
}
_onDBChange
(
)
{
return
(
async
(
)
=
>
{
if
(
this
.
__store
)
{
await
this
.
__store
.
finalize
(
)
;
}
this
.
__store
=
null
;
this
.
__storeInitialized
=
false
;
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
!
=
"
handlersvc
-
json
-
replace
"
)
{
return
;
}
let
promise
=
this
.
_onDBChange
(
)
;
promise
.
then
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
handlersvc
-
json
-
replace
-
complete
"
)
;
}
)
;
}
asyncInit
(
)
{
if
(
!
this
.
__store
)
{
this
.
__store
=
new
JSONFile
(
{
path
:
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
handlers
.
json
"
)
dataPostProcessor
:
this
.
_dataPostProcessor
.
bind
(
this
)
}
)
;
this
.
__store
.
load
(
)
.
then
(
(
)
=
>
{
if
(
this
.
__store
)
{
this
.
_ensureStoreInitialized
(
)
;
}
}
)
.
catch
(
Cu
.
reportError
)
;
}
}
enumerate
(
)
{
let
handlers
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
type
of
Object
.
keys
(
this
.
_store
.
data
.
mimeTypes
)
)
{
let
handler
=
gMIMEService
.
getFromTypeAndExtension
(
type
null
)
;
handlers
.
appendElement
(
handler
)
;
}
for
(
let
type
of
Object
.
keys
(
this
.
_store
.
data
.
schemes
)
)
{
let
handler
=
new
Proxy
(
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIHandlerInfo
]
)
type
:
type
get
_handlerInfo
(
)
{
delete
this
.
_handlerInfo
;
return
this
.
_handlerInfo
=
gExternalProtocolService
.
getProtocolHandlerInfo
(
type
)
;
}
}
{
get
:
function
(
target
name
)
{
return
target
[
name
]
|
|
target
.
_handlerInfo
[
name
]
;
}
set
:
function
(
target
name
value
)
{
target
.
_handlerInfo
[
name
]
=
value
;
}
}
)
;
handlers
.
appendElement
(
handler
)
;
}
return
handlers
.
enumerate
(
Ci
.
nsIHandlerInfo
)
;
}
store
(
handlerInfo
)
{
let
handlerList
=
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
;
let
storedHandlerInfo
=
handlerList
[
handlerInfo
.
type
]
;
if
(
!
storedHandlerInfo
)
{
storedHandlerInfo
=
{
}
;
handlerList
[
handlerInfo
.
type
]
=
storedHandlerInfo
;
}
if
(
handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
saveToDisk
|
|
handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useSystemDefault
|
|
handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
handleInternally
)
{
storedHandlerInfo
.
action
=
handlerInfo
.
preferredAction
;
}
else
{
storedHandlerInfo
.
action
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
}
if
(
handlerInfo
.
alwaysAskBeforeHandling
)
{
storedHandlerInfo
.
ask
=
true
;
}
else
{
delete
storedHandlerInfo
.
ask
;
}
let
handlers
=
[
]
;
if
(
handlerInfo
.
preferredApplicationHandler
)
{
handlers
.
push
(
handlerInfo
.
preferredApplicationHandler
)
;
}
for
(
let
handler
of
handlerInfo
.
possibleApplicationHandlers
.
enumerate
(
Ci
.
nsIHandlerApp
)
)
{
if
(
!
handlers
.
some
(
h
=
>
h
.
equals
(
handler
)
)
)
{
handlers
.
push
(
handler
)
;
}
}
let
serializableHandlers
=
handlers
.
map
(
h
=
>
this
.
handlerAppToSerializable
(
h
)
)
.
filter
(
h
=
>
h
)
;
if
(
serializableHandlers
.
length
)
{
if
(
!
handlerInfo
.
preferredApplicationHandler
)
{
serializableHandlers
.
unshift
(
null
)
;
}
storedHandlerInfo
.
handlers
=
serializableHandlers
;
}
else
{
delete
storedHandlerInfo
.
handlers
;
}
if
(
this
.
_isMIMEInfo
(
handlerInfo
)
)
{
let
extensions
=
storedHandlerInfo
.
extensions
|
|
[
]
;
for
(
let
extension
of
handlerInfo
.
getFileExtensions
(
)
)
{
extension
=
extension
.
toLowerCase
(
)
;
if
(
!
extensions
.
includes
(
extension
)
)
{
extensions
.
push
(
extension
)
;
}
}
if
(
extensions
.
length
)
{
storedHandlerInfo
.
extensions
=
extensions
;
}
else
{
delete
storedHandlerInfo
.
extensions
;
}
}
this
.
_store
.
saveSoon
(
)
;
}
fillHandlerInfo
(
handlerInfo
overrideType
)
{
let
type
=
overrideType
|
|
handlerInfo
.
type
;
let
storedHandlerInfo
=
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
[
type
]
;
if
(
!
storedHandlerInfo
)
{
throw
new
Components
.
Exception
(
"
handlerSvc
fillHandlerInfo
:
don
'
t
know
this
type
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
handlerInfo
.
preferredAction
=
storedHandlerInfo
.
action
;
handlerInfo
.
alwaysAskBeforeHandling
=
!
!
storedHandlerInfo
.
ask
;
let
isFirstItem
=
true
;
for
(
let
handler
of
storedHandlerInfo
.
handlers
|
|
[
null
]
)
{
let
handlerApp
=
this
.
handlerAppFromSerializable
(
handler
|
|
{
}
)
;
if
(
isFirstItem
)
{
isFirstItem
=
false
;
handlerInfo
.
preferredApplicationHandler
=
handlerApp
;
}
if
(
handlerApp
)
{
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
handlerApp
)
;
}
}
if
(
this
.
_isMIMEInfo
(
handlerInfo
)
&
&
storedHandlerInfo
.
extensions
)
{
for
(
let
extension
of
storedHandlerInfo
.
extensions
)
{
handlerInfo
.
appendExtension
(
extension
)
;
}
}
}
handlerAppToSerializable
(
handler
)
{
if
(
handler
instanceof
Ci
.
nsILocalHandlerApp
)
{
return
{
name
:
handler
.
name
path
:
handler
.
executable
.
path
}
;
}
else
if
(
handler
instanceof
Ci
.
nsIWebHandlerApp
)
{
return
{
name
:
handler
.
name
uriTemplate
:
handler
.
uriTemplate
}
;
}
else
if
(
handler
instanceof
Ci
.
nsIDBusHandlerApp
)
{
return
{
name
:
handler
.
name
service
:
handler
.
service
method
:
handler
.
method
objectPath
:
handler
.
objectPath
dBusInterface
:
handler
.
dBusInterface
}
;
}
else
if
(
handler
instanceof
Ci
.
nsIGIOMimeApp
)
{
return
{
name
:
handler
.
name
command
:
handler
.
command
}
;
}
return
null
;
}
handlerAppFromSerializable
(
handlerObj
)
{
let
handlerApp
;
if
(
"
path
"
in
handlerObj
)
{
try
{
let
file
=
new
FileUtils
.
File
(
handlerObj
.
path
)
;
if
(
!
file
.
exists
(
)
)
{
return
null
;
}
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
handlerApp
.
executable
=
file
;
}
catch
(
ex
)
{
return
null
;
}
}
else
if
(
"
uriTemplate
"
in
handlerObj
)
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
handlerApp
.
uriTemplate
=
handlerObj
.
uriTemplate
;
}
else
if
(
"
service
"
in
handlerObj
)
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
dbus
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIDBusHandlerApp
)
;
handlerApp
.
service
=
handlerObj
.
service
;
handlerApp
.
method
=
handlerObj
.
method
;
handlerApp
.
objectPath
=
handlerObj
.
objectPath
;
handlerApp
.
dBusInterface
=
handlerObj
.
dBusInterface
;
}
else
if
(
"
command
"
in
handlerObj
&
&
"
mozilla
.
org
/
gio
-
service
;
1
"
in
Cc
)
{
try
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
gio
-
service
;
1
"
]
.
getService
(
Ci
.
nsIGIOService
)
.
createAppFromCommand
(
handlerObj
.
command
handlerObj
.
name
)
;
}
catch
(
ex
)
{
return
null
;
}
}
else
{
return
null
;
}
handlerApp
.
name
=
handlerObj
.
name
;
return
handlerApp
;
}
_getHandlerListByHandlerInfoType
(
handlerInfo
)
{
return
this
.
_isMIMEInfo
(
handlerInfo
)
?
this
.
_store
.
data
.
mimeTypes
:
this
.
_store
.
data
.
schemes
;
}
_isMIMEInfo
(
handlerInfo
)
{
return
handlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
handlerInfo
.
type
.
includes
(
"
/
"
)
;
}
exists
(
handlerInfo
)
{
return
handlerInfo
.
type
in
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
;
}
remove
(
handlerInfo
)
{
delete
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
[
handlerInfo
.
type
]
;
this
.
_store
.
saveSoon
(
)
;
}
getTypeFromExtension
(
fileExtension
)
{
let
extension
=
fileExtension
.
toLowerCase
(
)
;
let
mimeTypes
=
this
.
_store
.
data
.
mimeTypes
;
for
(
let
type
of
Object
.
keys
(
mimeTypes
)
)
{
if
(
mimeTypes
[
type
]
.
extensions
&
&
mimeTypes
[
type
]
.
extensions
.
includes
(
extension
)
)
{
return
type
;
}
}
return
"
"
;
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
HandlerService
]
)
;
