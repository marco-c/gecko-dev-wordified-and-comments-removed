#
include
"
nsOSHelperAppService
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIMIMEInfo
.
h
"
#
include
"
nsMIMEInfoWin
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsIProcess
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nsLocalFile
.
h
"
#
include
"
nsIWindowsRegKey
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
<
shellapi
.
h
>
#
include
<
shlwapi
.
h
>
#
define
LOG
(
args
)
MOZ_LOG
(
mLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
static
nsresult
GetExtensionFromWindowsMimeDatabase
(
const
nsACString
&
aMimeType
nsString
&
aFileExtension
)
;
nsOSHelperAppService
:
:
nsOSHelperAppService
(
)
:
nsExternalHelperAppService
(
)
mAppAssoc
(
nullptr
)
{
CoInitialize
(
nullptr
)
;
CoCreateInstance
(
CLSID_ApplicationAssociationRegistration
nullptr
CLSCTX_INPROC
IID_IApplicationAssociationRegistration
(
void
*
*
)
&
mAppAssoc
)
;
}
nsOSHelperAppService
:
:
~
nsOSHelperAppService
(
)
{
if
(
mAppAssoc
)
mAppAssoc
-
>
Release
(
)
;
mAppAssoc
=
nullptr
;
CoUninitialize
(
)
;
}
static
nsresult
GetExtensionFromWindowsMimeDatabase
(
const
nsACString
&
aMimeType
nsString
&
aFileExtension
)
{
nsAutoString
mimeDatabaseKey
;
mimeDatabaseKey
.
AssignLiteral
(
"
MIME
\
\
Database
\
\
Content
Type
\
\
"
)
;
AppendASCIItoUTF16
(
aMimeType
mimeDatabaseKey
)
;
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
regKey
)
return
NS_ERROR_NOT_AVAILABLE
;
nsresult
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
mimeDatabaseKey
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
regKey
-
>
ReadStringValue
(
NS_LITERAL_STRING
(
"
Extension
"
)
aFileExtension
)
;
return
NS_OK
;
}
nsresult
nsOSHelperAppService
:
:
OSProtocolHandlerExists
(
const
char
*
aProtocolScheme
bool
*
aHandlerExists
)
{
*
aHandlerExists
=
false
;
if
(
aProtocolScheme
&
&
*
aProtocolScheme
)
{
NS_ENSURE_TRUE
(
mAppAssoc
NS_ERROR_NOT_AVAILABLE
)
;
wchar_t
*
pResult
=
nullptr
;
NS_ConvertASCIItoUTF16
scheme
(
aProtocolScheme
)
;
HRESULT
hr
=
mAppAssoc
-
>
QueryCurrentDefault
(
scheme
.
get
(
)
AT_URLPROTOCOL
AL_EFFECTIVE
&
pResult
)
;
if
(
SUCCEEDED
(
hr
)
)
{
CoTaskMemFree
(
pResult
)
;
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
regKey
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
nsDependentString
(
scheme
.
get
(
)
)
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
bool
hasValue
;
rv
=
regKey
-
>
HasValue
(
NS_LITERAL_STRING
(
"
URL
Protocol
"
)
&
hasValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
hasValue
)
{
return
NS_OK
;
}
*
aHandlerExists
=
true
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsOSHelperAppService
:
:
GetApplicationDescription
(
const
nsACString
&
aScheme
nsAString
&
_retval
)
{
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
regKey
)
return
NS_ERROR_NOT_AVAILABLE
;
NS_ConvertASCIItoUTF16
buf
(
aScheme
)
;
if
(
mozilla
:
:
IsWin8OrLater
(
)
)
{
wchar_t
result
[
1024
]
;
DWORD
resultSize
=
1024
;
HRESULT
hr
=
AssocQueryString
(
0x1000
ASSOCSTR_FRIENDLYAPPNAME
buf
.
get
(
)
NULL
result
&
resultSize
)
;
if
(
SUCCEEDED
(
hr
)
)
{
_retval
=
result
;
return
NS_OK
;
}
}
NS_ENSURE_TRUE
(
mAppAssoc
NS_ERROR_NOT_AVAILABLE
)
;
wchar_t
*
pResult
=
nullptr
;
HRESULT
hr
=
mAppAssoc
-
>
QueryCurrentDefault
(
buf
.
get
(
)
AT_URLPROTOCOL
AL_EFFECTIVE
&
pResult
)
;
if
(
SUCCEEDED
(
hr
)
)
{
nsCOMPtr
<
nsIFile
>
app
;
nsAutoString
appInfo
(
pResult
)
;
CoTaskMemFree
(
pResult
)
;
if
(
NS_SUCCEEDED
(
GetDefaultAppInfo
(
appInfo
_retval
getter_AddRefs
(
app
)
)
)
)
return
NS_OK
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
nsOSHelperAppService
:
:
GetMIMEInfoFromRegistry
(
const
nsString
&
fileType
nsIMIMEInfo
*
pInfo
)
{
nsresult
rv
=
NS_OK
;
NS_ENSURE_ARG
(
pInfo
)
;
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
regKey
)
return
NS_ERROR_NOT_AVAILABLE
;
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
fileType
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_ERROR_FAILURE
;
nsAutoString
description
;
rv
=
regKey
-
>
ReadStringValue
(
EmptyString
(
)
description
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
pInfo
-
>
SetDescription
(
description
)
;
return
NS_OK
;
}
bool
nsOSHelperAppService
:
:
typeFromExtEquals
(
const
char16_t
*
aExt
const
char
*
aType
)
{
if
(
!
aType
)
return
false
;
nsAutoString
fileExtToUse
;
if
(
aExt
[
0
]
!
=
char16_t
(
'
.
'
)
)
fileExtToUse
=
char16_t
(
'
.
'
)
;
fileExtToUse
.
Append
(
aExt
)
;
bool
eq
=
false
;
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
regKey
)
return
eq
;
nsresult
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
fileExtToUse
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
return
eq
;
nsAutoString
type
;
rv
=
regKey
-
>
ReadStringValue
(
NS_LITERAL_STRING
(
"
Content
Type
"
)
type
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
eq
=
type
.
EqualsASCII
(
aType
)
;
return
eq
;
}
nsresult
nsOSHelperAppService
:
:
GetDefaultAppInfo
(
const
nsAString
&
aAppInfo
nsAString
&
aDefaultDescription
nsIFile
*
*
aDefaultApplication
)
{
nsAutoString
handlerCommand
;
aDefaultDescription
=
aAppInfo
;
*
aDefaultApplication
=
nullptr
;
if
(
aAppInfo
.
IsEmpty
(
)
)
return
NS_ERROR_FAILURE
;
nsAutoString
handlerKeyName
(
aAppInfo
)
;
nsCOMPtr
<
nsIWindowsRegKey
>
chkKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
chkKey
)
return
NS_ERROR_FAILURE
;
nsresult
rv
=
chkKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
handlerKeyName
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
{
handlerCommand
.
Assign
(
aAppInfo
)
;
}
else
{
handlerKeyName
.
AppendLiteral
(
"
\
\
shell
\
\
open
\
\
command
"
)
;
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
regKey
)
return
NS_ERROR_FAILURE
;
nsresult
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
handlerKeyName
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
return
NS_ERROR_FAILURE
;
rv
=
regKey
-
>
ReadStringValue
(
EmptyString
(
)
handlerCommand
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsAutoString
delegateExecute
;
rv
=
regKey
-
>
ReadStringValue
(
NS_LITERAL_STRING
(
"
DelegateExecute
"
)
delegateExecute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
delegateExecuteRegPath
;
delegateExecuteRegPath
.
AssignLiteral
(
"
CLSID
\
\
"
)
;
delegateExecuteRegPath
.
Append
(
delegateExecute
)
;
delegateExecuteRegPath
.
AppendLiteral
(
"
\
\
InProcServer32
"
)
;
rv
=
chkKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
delegateExecuteRegPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
chkKey
-
>
ReadStringValue
(
EmptyString
(
)
handlerCommand
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
delegateExecuteRegPath
.
AssignLiteral
(
"
CLSID
\
\
"
)
;
delegateExecuteRegPath
.
Append
(
delegateExecute
)
;
delegateExecuteRegPath
.
AppendLiteral
(
"
\
\
LocalServer32
"
)
;
rv
=
chkKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
delegateExecuteRegPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
chkKey
-
>
ReadStringValue
(
EmptyString
(
)
handlerCommand
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
nsCOMPtr
<
nsILocalFileWin
>
lf
=
new
nsLocalFile
(
)
;
rv
=
lf
-
>
InitWithCommandLine
(
handlerCommand
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
lf
.
forget
(
aDefaultApplication
)
;
wchar_t
friendlyName
[
1024
]
;
DWORD
friendlyNameSize
=
1024
;
HRESULT
hr
=
AssocQueryString
(
ASSOCF_NONE
ASSOCSTR_FRIENDLYAPPNAME
PromiseFlatString
(
aAppInfo
)
.
get
(
)
NULL
friendlyName
&
friendlyNameSize
)
;
if
(
SUCCEEDED
(
hr
)
)
{
aDefaultDescription
.
Assign
(
friendlyName
)
;
}
return
NS_OK
;
}
already_AddRefed
<
nsMIMEInfoWin
>
nsOSHelperAppService
:
:
GetByExtension
(
const
nsString
&
aFileExt
const
char
*
aTypeHint
)
{
if
(
aFileExt
.
IsEmpty
(
)
)
return
nullptr
;
nsAutoCString
typeToUse
;
if
(
aTypeHint
&
&
*
aTypeHint
)
{
typeToUse
.
Assign
(
aTypeHint
)
;
}
else
if
(
!
GetMIMETypeFromOSForExtension
(
NS_ConvertUTF16toUTF8
(
aFileExt
)
typeToUse
)
)
{
return
nullptr
;
}
RefPtr
<
nsMIMEInfoWin
>
mimeInfo
=
new
nsMIMEInfoWin
(
typeToUse
)
;
nsAutoString
fileExtToUse
;
if
(
aFileExt
.
First
(
)
!
=
char16_t
(
'
.
'
)
)
fileExtToUse
=
char16_t
(
'
.
'
)
;
fileExtToUse
.
Append
(
aFileExt
)
;
mimeInfo
-
>
AppendExtension
(
NS_ConvertUTF16toUTF8
(
Substring
(
fileExtToUse
1
)
)
)
;
mimeInfo
-
>
SetPreferredAction
(
nsIMIMEInfo
:
:
useSystemDefault
)
;
nsAutoString
appInfo
;
bool
found
;
NS_ENSURE_TRUE
(
mAppAssoc
nullptr
)
;
nsString
assocType
(
fileExtToUse
)
;
wchar_t
*
pResult
=
nullptr
;
HRESULT
hr
=
mAppAssoc
-
>
QueryCurrentDefault
(
assocType
.
get
(
)
AT_FILEEXTENSION
AL_EFFECTIVE
&
pResult
)
;
if
(
SUCCEEDED
(
hr
)
)
{
found
=
true
;
appInfo
.
Assign
(
pResult
)
;
CoTaskMemFree
(
pResult
)
;
}
else
{
found
=
false
;
}
if
(
appInfo
.
EqualsLiteral
(
"
XPSViewer
.
Document
"
)
)
found
=
false
;
if
(
!
found
)
{
return
nullptr
;
}
nsAutoString
defaultDescription
;
nsCOMPtr
<
nsIFile
>
defaultApplication
;
if
(
NS_FAILED
(
GetDefaultAppInfo
(
appInfo
defaultDescription
getter_AddRefs
(
defaultApplication
)
)
)
)
{
return
nullptr
;
}
mimeInfo
-
>
SetDefaultDescription
(
defaultDescription
)
;
mimeInfo
-
>
SetDefaultApplicationHandler
(
defaultApplication
)
;
GetMIMEInfoFromRegistry
(
appInfo
mimeInfo
)
;
return
mimeInfo
.
forget
(
)
;
}
NS_IMETHODIMP
nsOSHelperAppService
:
:
GetMIMEInfoFromOS
(
const
nsACString
&
aMIMEType
const
nsACString
&
aFileExt
bool
*
aFound
nsIMIMEInfo
*
*
aMIMEInfo
)
{
*
aFound
=
true
;
const
nsCString
&
flatType
=
PromiseFlatCString
(
aMIMEType
)
;
const
nsCString
&
flatExt
=
PromiseFlatCString
(
aFileExt
)
;
nsAutoString
fileExtension
;
if
(
!
aMIMEType
.
IsEmpty
(
)
&
&
!
aMIMEType
.
LowerCaseEqualsLiteral
(
APPLICATION_OCTET_STREAM
)
)
{
GetExtensionFromWindowsMimeDatabase
(
aMIMEType
fileExtension
)
;
LOG
(
(
"
Windows
mime
database
:
extension
'
%
s
'
\
n
"
fileExtension
.
get
(
)
)
)
;
}
RefPtr
<
nsMIMEInfoWin
>
mi
;
if
(
!
fileExtension
.
IsEmpty
(
)
)
mi
=
GetByExtension
(
fileExtension
flatType
.
get
(
)
)
;
LOG
(
(
"
Extension
lookup
on
'
%
s
'
found
:
0x
%
p
\
n
"
fileExtension
.
get
(
)
mi
.
get
(
)
)
)
;
bool
hasDefault
=
false
;
if
(
mi
)
{
mi
-
>
GetHasDefaultHandler
(
&
hasDefault
)
;
if
(
!
aFileExt
.
IsEmpty
(
)
&
&
typeFromExtEquals
(
NS_ConvertUTF8toUTF16
(
flatExt
)
.
get
(
)
flatType
.
get
(
)
)
)
{
LOG
(
(
"
Appending
extension
'
%
s
'
to
mimeinfo
because
its
mimetype
is
"
"
'
%
s
'
\
n
"
flatExt
.
get
(
)
flatType
.
get
(
)
)
)
;
bool
extExist
=
false
;
mi
-
>
ExtensionExists
(
aFileExt
&
extExist
)
;
if
(
!
extExist
)
mi
-
>
AppendExtension
(
aFileExt
)
;
}
}
if
(
!
mi
|
|
!
hasDefault
)
{
RefPtr
<
nsMIMEInfoWin
>
miByExt
=
GetByExtension
(
NS_ConvertUTF8toUTF16
(
aFileExt
)
flatType
.
get
(
)
)
;
LOG
(
(
"
Ext
.
lookup
for
'
%
s
'
found
0x
%
p
\
n
"
flatExt
.
get
(
)
miByExt
.
get
(
)
)
)
;
if
(
!
miByExt
&
&
mi
)
{
mi
.
forget
(
aMIMEInfo
)
;
return
NS_OK
;
}
if
(
miByExt
&
&
!
mi
)
{
miByExt
.
forget
(
aMIMEInfo
)
;
return
NS_OK
;
}
if
(
!
miByExt
&
&
!
mi
)
{
*
aFound
=
false
;
mi
=
new
nsMIMEInfoWin
(
flatType
)
;
if
(
!
aFileExt
.
IsEmpty
(
)
)
{
mi
-
>
AppendExtension
(
aFileExt
)
;
}
mi
.
forget
(
aMIMEInfo
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
defaultApp
;
nsAutoString
desc
;
miByExt
-
>
GetDefaultDescription
(
desc
)
;
mi
-
>
SetDefaultDescription
(
desc
)
;
}
mi
.
forget
(
aMIMEInfo
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsOSHelperAppService
:
:
GetProtocolHandlerInfoFromOS
(
const
nsACString
&
aScheme
bool
*
found
nsIHandlerInfo
*
*
_retval
)
{
NS_ASSERTION
(
!
aScheme
.
IsEmpty
(
)
"
No
scheme
was
specified
!
"
)
;
nsresult
rv
=
OSProtocolHandlerExists
(
nsPromiseFlatCString
(
aScheme
)
.
get
(
)
found
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsMIMEInfoWin
*
handlerInfo
=
new
nsMIMEInfoWin
(
aScheme
nsMIMEInfoBase
:
:
eProtocolInfo
)
;
NS_ENSURE_TRUE
(
handlerInfo
NS_ERROR_OUT_OF_MEMORY
)
;
NS_ADDREF
(
*
_retval
=
handlerInfo
)
;
if
(
!
*
found
)
{
return
NS_OK
;
}
nsAutoString
desc
;
GetApplicationDescription
(
aScheme
desc
)
;
handlerInfo
-
>
SetDefaultDescription
(
desc
)
;
return
NS_OK
;
}
bool
nsOSHelperAppService
:
:
GetMIMETypeFromOSForExtension
(
const
nsACString
&
aExtension
nsACString
&
aMIMEType
)
{
if
(
aExtension
.
IsEmpty
(
)
)
return
false
;
nsAutoString
fileExtToUse
;
if
(
aExtension
.
First
(
)
!
=
'
.
'
)
fileExtToUse
=
char16_t
(
'
.
'
)
;
AppendUTF8toUTF16
(
aExtension
fileExtToUse
)
;
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
regKey
)
return
false
;
nsresult
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
fileExtToUse
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
nsAutoString
mimeType
;
if
(
NS_FAILED
(
regKey
-
>
ReadStringValue
(
NS_LITERAL_STRING
(
"
Content
Type
"
)
mimeType
)
)
|
|
mimeType
.
IsEmpty
(
)
)
{
return
false
;
}
aMIMEType
.
Truncate
(
)
;
LossyAppendUTF16toASCII
(
mimeType
aMIMEType
)
;
return
true
;
}
