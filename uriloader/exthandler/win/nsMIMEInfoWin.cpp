#
include
"
nsArrayEnumerator
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsLocalFile
.
h
"
#
include
"
nsMIMEInfoWin
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
<
windows
.
h
>
#
include
<
shellapi
.
h
>
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
shlobj
.
h
"
#
include
"
windows
.
h
"
#
include
"
nsIWindowsRegKey
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsITextToSubURI
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
mozilla
/
CmdLineAndEnvUtils
.
h
"
#
include
"
mozilla
/
ShellHeaderOnlyUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
UrlmonHeaderOnlyUtils
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
define
RUNDLL32_EXE
L
"
\
\
rundll32
.
exe
"
NS_IMPL_ISUPPORTS_INHERITED
(
nsMIMEInfoWin
nsMIMEInfoBase
nsIPropertyBag
)
nsMIMEInfoWin
:
:
~
nsMIMEInfoWin
(
)
{
}
nsresult
nsMIMEInfoWin
:
:
LaunchDefaultWithFile
(
nsIFile
*
aFile
)
{
bool
executable
=
true
;
aFile
-
>
IsExecutable
(
&
executable
)
;
if
(
executable
)
return
NS_ERROR_FAILURE
;
return
aFile
-
>
Launch
(
)
;
}
nsresult
nsMIMEInfoWin
:
:
ShellExecuteWithIFile
(
nsIFile
*
aExecutable
int
aArgc
const
wchar_t
*
*
aArgv
)
{
nsresult
rv
;
NS_ASSERTION
(
aArgc
>
=
1
"
aArgc
must
be
at
least
1
"
)
;
nsAutoString
execPath
;
rv
=
aExecutable
-
>
GetTarget
(
execPath
)
;
if
(
NS_FAILED
(
rv
)
|
|
execPath
.
IsEmpty
(
)
)
{
rv
=
aExecutable
-
>
GetPath
(
execPath
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
auto
assembledArgs
=
mozilla
:
:
MakeCommandLine
(
aArgc
aArgv
)
;
if
(
!
assembledArgs
)
{
return
NS_ERROR_FILE_EXECUTION_FAILED
;
}
_bstr_t
execPathBStr
(
execPath
.
get
(
)
)
;
_variant_t
verbDefault
(
DISP_E_PARAMNOTFOUND
VT_ERROR
)
;
_variant_t
workingDir
;
_variant_t
showCmd
(
SW_SHOWNORMAL
)
;
mozilla
:
:
LauncherVoidResult
shellExecuteOk
=
mozilla
:
:
ShellExecuteByExplorer
(
execPathBStr
assembledArgs
.
get
(
)
verbDefault
workingDir
showCmd
)
;
if
(
shellExecuteOk
.
isErr
(
)
)
{
return
LaunchWithIProcess
(
aExecutable
aArgc
reinterpret_cast
<
const
char16_t
*
*
>
(
aArgv
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsMIMEInfoWin
:
:
LaunchWithFile
(
nsIFile
*
aFile
)
{
nsresult
rv
;
NS_ASSERTION
(
mClass
=
=
eMIMEInfo
"
nsMIMEInfoBase
should
have
mClass
=
=
eMIMEInfo
"
)
;
if
(
mPreferredAction
=
=
useSystemDefault
)
{
if
(
mDefaultApplication
&
&
StaticPrefs
:
:
browser_pdf_launchDefaultEdgeAsApp
(
)
)
{
nsAutoCString
defaultAppExecutable
;
rv
=
mDefaultApplication
-
>
GetNativeLeafName
(
defaultAppExecutable
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
defaultAppExecutable
.
LowerCaseEqualsLiteral
(
"
msedge
.
exe
"
)
)
{
nsAutoString
path
;
rv
=
aFile
-
>
GetPath
(
path
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoString
appArg
;
appArg
.
AppendLiteral
(
"
-
-
app
=
"
)
;
appArg
.
Append
(
path
)
;
const
wchar_t
*
argv
[
]
=
{
appArg
.
get
(
)
path
.
get
(
)
}
;
return
ShellExecuteWithIFile
(
mDefaultApplication
mozilla
:
:
ArrayLength
(
argv
)
argv
)
;
}
}
}
return
LaunchDefaultWithFile
(
aFile
)
;
}
if
(
mPreferredAction
=
=
useHelperApp
)
{
if
(
!
mPreferredApplication
)
return
NS_ERROR_FILE_NOT_FOUND
;
nsCOMPtr
<
nsILocalHandlerApp
>
localHandler
=
do_QueryInterface
(
mPreferredApplication
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
executable
;
rv
=
localHandler
-
>
GetExecutable
(
getter_AddRefs
(
executable
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCString
filename
;
executable
-
>
GetNativeLeafName
(
filename
)
;
if
(
filename
.
Length
(
)
>
4
)
{
nsCString
extension
(
Substring
(
filename
filename
.
Length
(
)
-
4
4
)
)
;
if
(
extension
.
LowerCaseEqualsLiteral
(
"
.
dll
"
)
)
{
nsAutoString
args
;
if
(
!
GetDllLaunchInfo
(
executable
aFile
args
false
)
)
return
NS_ERROR_INVALID_ARG
;
WCHAR
rundll32Path
[
MAX_PATH
+
sizeof
(
RUNDLL32_EXE
)
/
sizeof
(
WCHAR
)
+
1
]
=
{
L
'
\
0
'
}
;
if
(
!
GetSystemDirectoryW
(
rundll32Path
MAX_PATH
)
)
{
return
NS_ERROR_FILE_NOT_FOUND
;
}
lstrcatW
(
rundll32Path
RUNDLL32_EXE
)
;
SHELLEXECUTEINFOW
seinfo
;
memset
(
&
seinfo
0
sizeof
(
seinfo
)
)
;
seinfo
.
cbSize
=
sizeof
(
SHELLEXECUTEINFOW
)
;
seinfo
.
fMask
=
0
;
seinfo
.
hwnd
=
nullptr
;
seinfo
.
lpVerb
=
nullptr
;
seinfo
.
lpFile
=
rundll32Path
;
seinfo
.
lpParameters
=
args
.
get
(
)
;
seinfo
.
lpDirectory
=
nullptr
;
seinfo
.
nShow
=
SW_SHOWNORMAL
;
if
(
ShellExecuteExW
(
&
seinfo
)
)
return
NS_OK
;
switch
(
(
LONG_PTR
)
seinfo
.
hInstApp
)
{
case
0
:
case
SE_ERR_OOM
:
return
NS_ERROR_OUT_OF_MEMORY
;
case
SE_ERR_ACCESSDENIED
:
return
NS_ERROR_FILE_ACCESS_DENIED
;
case
SE_ERR_ASSOCINCOMPLETE
:
case
SE_ERR_NOASSOC
:
return
NS_ERROR_UNEXPECTED
;
case
SE_ERR_DDEBUSY
:
case
SE_ERR_DDEFAIL
:
case
SE_ERR_DDETIMEOUT
:
return
NS_ERROR_NOT_AVAILABLE
;
case
SE_ERR_DLLNOTFOUND
:
return
NS_ERROR_FAILURE
;
case
SE_ERR_SHARE
:
return
NS_ERROR_FILE_IS_LOCKED
;
default
:
switch
(
GetLastError
(
)
)
{
case
ERROR_FILE_NOT_FOUND
:
return
NS_ERROR_FILE_NOT_FOUND
;
case
ERROR_PATH_NOT_FOUND
:
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
case
ERROR_BAD_FORMAT
:
return
NS_ERROR_FILE_CORRUPTED
;
}
}
return
NS_ERROR_FILE_EXECUTION_FAILED
;
}
}
nsAutoString
path
;
aFile
-
>
GetPath
(
path
)
;
const
wchar_t
*
argv
[
]
=
{
path
.
get
(
)
}
;
return
ShellExecuteWithIFile
(
executable
mozilla
:
:
ArrayLength
(
argv
)
argv
)
;
}
return
NS_ERROR_INVALID_ARG
;
}
NS_IMETHODIMP
nsMIMEInfoWin
:
:
GetHasDefaultHandler
(
bool
*
_retval
)
{
*
_retval
=
!
mDefaultAppDescription
.
IsEmpty
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsMIMEInfoWin
:
:
GetEnumerator
(
nsISimpleEnumerator
*
*
_retval
)
{
nsCOMArray
<
nsIVariant
>
properties
;
nsCOMPtr
<
nsIVariant
>
variant
;
GetProperty
(
u
"
defaultApplicationIconURL
"
_ns
getter_AddRefs
(
variant
)
)
;
if
(
variant
)
properties
.
AppendObject
(
variant
)
;
GetProperty
(
u
"
customApplicationIconURL
"
_ns
getter_AddRefs
(
variant
)
)
;
if
(
variant
)
properties
.
AppendObject
(
variant
)
;
return
NS_NewArrayEnumerator
(
_retval
properties
NS_GET_IID
(
nsIVariant
)
)
;
}
static
nsresult
GetIconURLVariant
(
nsIFile
*
aApplication
nsIVariant
*
*
_retval
)
{
nsAutoCString
fileURLSpec
;
NS_GetURLSpecFromFile
(
aApplication
fileURLSpec
)
;
nsAutoCString
iconURLSpec
;
iconURLSpec
.
AssignLiteral
(
"
moz
-
icon
:
/
/
"
)
;
iconURLSpec
+
=
fileURLSpec
;
RefPtr
<
nsVariant
>
writable
(
new
nsVariant
(
)
)
;
writable
-
>
SetAsAUTF8String
(
iconURLSpec
)
;
writable
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsMIMEInfoWin
:
:
GetProperty
(
const
nsAString
&
aName
nsIVariant
*
*
_retval
)
{
nsresult
rv
;
if
(
mDefaultApplication
&
&
aName
.
EqualsLiteral
(
PROPERTY_DEFAULT_APP_ICON_URL
)
)
{
rv
=
GetIconURLVariant
(
mDefaultApplication
_retval
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
mPreferredApplication
&
&
aName
.
EqualsLiteral
(
PROPERTY_CUSTOM_APP_ICON_URL
)
)
{
nsCOMPtr
<
nsILocalHandlerApp
>
localHandler
=
do_QueryInterface
(
mPreferredApplication
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
executable
;
rv
=
localHandler
-
>
GetExecutable
(
getter_AddRefs
(
executable
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetIconURLVariant
(
executable
_retval
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
nsMIMEInfoWin
:
:
LoadUriInternal
(
nsIURI
*
aURL
)
{
nsresult
rv
=
NS_OK
;
if
(
aURL
)
{
nsAutoCString
urlSpec
;
aURL
-
>
GetAsciiSpec
(
urlSpec
)
;
nsAutoString
utf16Spec
;
nsCOMPtr
<
nsITextToSubURI
>
textToSubURI
=
do_GetService
(
NS_ITEXTTOSUBURI_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
NS_FAILED
(
textToSubURI
-
>
UnEscapeNonAsciiURI
(
"
UTF
-
8
"
_ns
urlSpec
utf16Spec
)
)
)
{
CopyASCIItoUTF16
(
urlSpec
utf16Spec
)
;
}
LauncherResult
<
_bstr_t
>
validatedUri
=
UrlmonValidateUri
(
utf16Spec
.
get
(
)
)
;
if
(
validatedUri
.
isErr
(
)
)
{
return
NS_ERROR_FAILURE
;
}
_variant_t
args
;
_variant_t
verb
(
L
"
open
"
)
;
_variant_t
workingDir
;
_variant_t
showCmd
(
SW_SHOWNORMAL
)
;
#
ifndef
MOZ_THUNDERBIRD
mozilla
:
:
LauncherVoidResult
shellExecuteOk
=
mozilla
:
:
ShellExecuteByExplorer
(
validatedUri
.
inspect
(
)
args
verb
workingDir
showCmd
)
;
if
(
shellExecuteOk
.
isOk
(
)
)
{
return
NS_OK
;
}
#
endif
SHELLEXECUTEINFOW
sinfo
=
{
sizeof
(
sinfo
)
}
;
sinfo
.
fMask
=
SEE_MASK_NOASYNC
;
sinfo
.
lpVerb
=
V_BSTR
(
&
verb
)
;
sinfo
.
nShow
=
showCmd
;
sinfo
.
lpFile
=
validatedUri
.
inspect
(
)
;
BOOL
result
=
ShellExecuteExW
(
&
sinfo
)
;
if
(
!
result
|
|
reinterpret_cast
<
LONG_PTR
>
(
sinfo
.
hInstApp
)
<
32
)
{
rv
=
NS_ERROR_FAILURE
;
}
}
return
rv
;
}
bool
nsMIMEInfoWin
:
:
GetLocalHandlerApp
(
const
nsAString
&
aCommandHandler
nsCOMPtr
<
nsILocalHandlerApp
>
&
aApp
)
{
nsCOMPtr
<
nsIFile
>
locfile
;
nsresult
rv
=
NS_NewLocalFile
(
aCommandHandler
true
getter_AddRefs
(
locfile
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
aApp
=
do_CreateInstance
(
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
)
;
if
(
!
aApp
)
return
false
;
aApp
-
>
SetExecutable
(
locfile
)
;
return
true
;
}
bool
nsMIMEInfoWin
:
:
GetAppsVerbCommandHandler
(
const
nsAString
&
appExeName
nsAString
&
applicationPath
bool
edit
)
{
nsCOMPtr
<
nsIWindowsRegKey
>
appKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
appKey
)
return
false
;
nsAutoString
applicationsPath
;
applicationsPath
.
AppendLiteral
(
"
Applications
\
\
"
)
;
applicationsPath
.
Append
(
appExeName
)
;
nsresult
rv
=
appKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
applicationsPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
uint32_t
value
;
if
(
NS_SUCCEEDED
(
appKey
-
>
ReadIntValue
(
u
"
NoOpenWith
"
_ns
&
value
)
)
&
&
value
=
=
1
)
return
false
;
nsAutoString
dummy
;
if
(
NS_SUCCEEDED
(
appKey
-
>
ReadStringValue
(
u
"
NoOpenWith
"
_ns
dummy
)
)
)
return
false
;
appKey
-
>
Close
(
)
;
applicationsPath
.
AssignLiteral
(
"
Applications
\
\
"
)
;
applicationsPath
.
Append
(
appExeName
)
;
if
(
!
edit
)
applicationsPath
.
AppendLiteral
(
"
\
\
shell
\
\
open
\
\
command
"
)
;
else
applicationsPath
.
AppendLiteral
(
"
\
\
shell
\
\
edit
\
\
command
"
)
;
rv
=
appKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
applicationsPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
nsAutoString
appFilesystemCommand
;
if
(
NS_SUCCEEDED
(
appKey
-
>
ReadStringValue
(
EmptyString
(
)
appFilesystemCommand
)
)
)
{
if
(
!
nsLocalFile
:
:
CleanupCmdHandlerPath
(
appFilesystemCommand
)
)
return
false
;
applicationPath
=
appFilesystemCommand
;
return
true
;
}
return
false
;
}
bool
nsMIMEInfoWin
:
:
GetDllLaunchInfo
(
nsIFile
*
aDll
nsIFile
*
aFile
nsAString
&
args
bool
edit
)
{
if
(
!
aDll
|
|
!
aFile
)
return
false
;
nsString
appExeName
;
aDll
-
>
GetLeafName
(
appExeName
)
;
nsCOMPtr
<
nsIWindowsRegKey
>
appKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
appKey
)
return
false
;
nsAutoString
applicationsPath
;
applicationsPath
.
AppendLiteral
(
"
Applications
\
\
"
)
;
applicationsPath
.
Append
(
appExeName
)
;
nsresult
rv
=
appKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
applicationsPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
uint32_t
value
;
rv
=
appKey
-
>
ReadIntValue
(
u
"
NoOpenWith
"
_ns
&
value
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
value
=
=
1
)
return
false
;
nsAutoString
dummy
;
if
(
NS_SUCCEEDED
(
appKey
-
>
ReadStringValue
(
u
"
NoOpenWith
"
_ns
dummy
)
)
)
return
false
;
appKey
-
>
Close
(
)
;
applicationsPath
.
AssignLiteral
(
"
Applications
\
\
"
)
;
applicationsPath
.
Append
(
appExeName
)
;
if
(
!
edit
)
applicationsPath
.
AppendLiteral
(
"
\
\
shell
\
\
open
\
\
command
"
)
;
else
applicationsPath
.
AppendLiteral
(
"
\
\
shell
\
\
edit
\
\
command
"
)
;
rv
=
appKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
applicationsPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
nsAutoString
appFilesystemCommand
;
if
(
NS_SUCCEEDED
(
appKey
-
>
ReadStringValue
(
EmptyString
(
)
appFilesystemCommand
)
)
)
{
uint32_t
bufLength
=
:
:
ExpandEnvironmentStringsW
(
appFilesystemCommand
.
get
(
)
nullptr
0
)
;
if
(
bufLength
=
=
0
)
return
false
;
auto
destination
=
mozilla
:
:
MakeUniqueFallible
<
wchar_t
[
]
>
(
bufLength
)
;
if
(
!
destination
)
return
false
;
if
(
!
:
:
ExpandEnvironmentStringsW
(
appFilesystemCommand
.
get
(
)
destination
.
get
(
)
bufLength
)
)
return
false
;
appFilesystemCommand
.
Assign
(
destination
.
get
(
)
)
;
nsAutoString
params
;
constexpr
auto
rundllSegment
=
u
"
rundll32
.
exe
"
_ns
;
int32_t
index
=
appFilesystemCommand
.
Find
(
rundllSegment
)
;
if
(
index
>
kNotFound
)
{
params
.
Append
(
Substring
(
appFilesystemCommand
index
+
rundllSegment
.
Length
(
)
)
)
;
}
else
{
params
.
Append
(
appFilesystemCommand
)
;
}
constexpr
auto
percentOneParam
=
u
"
%
1
"
_ns
;
index
=
params
.
Find
(
percentOneParam
)
;
if
(
index
=
=
kNotFound
)
return
false
;
nsString
target
;
aFile
-
>
GetTarget
(
target
)
;
params
.
Replace
(
index
2
target
)
;
args
=
params
;
return
true
;
}
return
false
;
}
bool
nsMIMEInfoWin
:
:
GetProgIDVerbCommandHandler
(
const
nsAString
&
appProgIDName
nsAString
&
applicationPath
bool
edit
)
{
nsCOMPtr
<
nsIWindowsRegKey
>
appKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
appKey
)
return
false
;
nsAutoString
appProgId
(
appProgIDName
)
;
if
(
!
edit
)
appProgId
.
AppendLiteral
(
"
\
\
shell
\
\
open
\
\
command
"
)
;
else
appProgId
.
AppendLiteral
(
"
\
\
shell
\
\
edit
\
\
command
"
)
;
nsresult
rv
=
appKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
appProgId
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
nsAutoString
appFilesystemCommand
;
if
(
NS_SUCCEEDED
(
appKey
-
>
ReadStringValue
(
EmptyString
(
)
appFilesystemCommand
)
)
)
{
if
(
!
nsLocalFile
:
:
CleanupCmdHandlerPath
(
appFilesystemCommand
)
)
return
false
;
applicationPath
=
appFilesystemCommand
;
return
true
;
}
return
false
;
}
void
nsMIMEInfoWin
:
:
ProcessPath
(
nsCOMPtr
<
nsIMutableArray
>
&
appList
nsTArray
<
nsString
>
&
trackList
const
nsAString
&
appFilesystemCommand
)
{
nsAutoString
lower
(
appFilesystemCommand
)
;
ToLowerCase
(
lower
)
;
WCHAR
exe
[
MAX_PATH
+
1
]
;
uint32_t
len
=
GetModuleFileNameW
(
nullptr
exe
MAX_PATH
)
;
if
(
len
<
MAX_PATH
&
&
len
!
=
0
)
{
int32_t
index
=
lower
.
Find
(
exe
)
;
if
(
index
!
=
-
1
)
return
;
}
nsCOMPtr
<
nsILocalHandlerApp
>
aApp
;
if
(
!
GetLocalHandlerApp
(
appFilesystemCommand
aApp
)
)
return
;
appList
-
>
AppendElement
(
aApp
)
;
trackList
.
AppendElement
(
lower
)
;
}
static
bool
IsPathInList
(
nsAString
&
appPath
nsTArray
<
nsString
>
&
trackList
)
{
nsAutoString
tmp
(
appPath
)
;
ToLowerCase
(
tmp
)
;
for
(
uint32_t
i
=
0
;
i
<
trackList
.
Length
(
)
;
i
+
+
)
{
if
(
tmp
.
Equals
(
trackList
[
i
]
)
)
return
true
;
}
return
false
;
}
NS_IMETHODIMP
nsMIMEInfoWin
:
:
GetPossibleLocalHandlers
(
nsIArray
*
*
_retval
)
{
nsresult
rv
;
*
_retval
=
nullptr
;
nsCOMPtr
<
nsIMutableArray
>
appList
=
do_CreateInstance
(
"
mozilla
.
org
/
array
;
1
"
)
;
if
(
!
appList
)
return
NS_ERROR_FAILURE
;
nsTArray
<
nsString
>
trackList
;
nsAutoCString
fileExt
;
GetPrimaryExtension
(
fileExt
)
;
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
regKey
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIWindowsRegKey
>
appKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
appKey
)
return
NS_ERROR_FAILURE
;
nsAutoString
workingRegistryPath
;
bool
extKnown
=
false
;
if
(
fileExt
.
IsEmpty
(
)
)
{
extKnown
=
true
;
nsAutoCString
mimeType
;
GetMIMEType
(
mimeType
)
;
if
(
!
mimeType
.
IsEmpty
(
)
)
{
workingRegistryPath
.
AppendLiteral
(
"
MIME
\
\
Database
\
\
Content
Type
\
\
"
)
;
workingRegistryPath
.
Append
(
NS_ConvertASCIItoUTF16
(
mimeType
)
)
;
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
workingRegistryPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoString
mimeFileExt
;
if
(
NS_SUCCEEDED
(
regKey
-
>
ReadStringValue
(
EmptyString
(
)
mimeFileExt
)
)
)
{
CopyUTF16toUTF8
(
mimeFileExt
fileExt
)
;
extKnown
=
false
;
}
}
}
}
nsAutoString
fileExtToUse
;
if
(
!
fileExt
.
IsEmpty
(
)
&
&
fileExt
.
First
(
)
!
=
'
.
'
)
{
fileExtToUse
=
char16_t
(
'
.
'
)
;
}
fileExtToUse
.
Append
(
NS_ConvertUTF8toUTF16
(
fileExt
)
)
;
if
(
!
extKnown
)
{
workingRegistryPath
=
fileExtToUse
;
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
workingRegistryPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoString
appProgId
;
if
(
NS_SUCCEEDED
(
regKey
-
>
ReadStringValue
(
EmptyString
(
)
appProgId
)
)
)
{
if
(
appProgId
!
=
u
"
XPSViewer
.
Document
"
_ns
)
{
nsAutoString
appFilesystemCommand
;
if
(
GetProgIDVerbCommandHandler
(
appProgId
appFilesystemCommand
false
)
&
&
!
IsPathInList
(
appFilesystemCommand
trackList
)
)
{
ProcessPath
(
appList
trackList
appFilesystemCommand
)
;
}
}
}
regKey
-
>
Close
(
)
;
}
workingRegistryPath
=
fileExtToUse
;
workingRegistryPath
.
AppendLiteral
(
"
\
\
OpenWithList
"
)
;
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
workingRegistryPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uint32_t
count
=
0
;
if
(
NS_SUCCEEDED
(
regKey
-
>
GetValueCount
(
&
count
)
)
&
&
count
>
0
)
{
for
(
uint32_t
index
=
0
;
index
<
count
;
index
+
+
)
{
nsAutoString
appName
;
if
(
NS_FAILED
(
regKey
-
>
GetValueName
(
index
appName
)
)
)
continue
;
nsAutoString
appFilesystemCommand
;
if
(
!
GetAppsVerbCommandHandler
(
appName
appFilesystemCommand
false
)
|
|
IsPathInList
(
appFilesystemCommand
trackList
)
)
continue
;
ProcessPath
(
appList
trackList
appFilesystemCommand
)
;
}
}
regKey
-
>
Close
(
)
;
}
workingRegistryPath
=
fileExtToUse
;
workingRegistryPath
.
AppendLiteral
(
"
\
\
OpenWithProgids
"
)
;
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
workingRegistryPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uint32_t
count
=
0
;
if
(
NS_SUCCEEDED
(
regKey
-
>
GetValueCount
(
&
count
)
)
&
&
count
>
0
)
{
for
(
uint32_t
index
=
0
;
index
<
count
;
index
+
+
)
{
nsAutoString
appProgId
;
if
(
NS_FAILED
(
regKey
-
>
GetValueName
(
index
appProgId
)
)
)
continue
;
nsAutoString
appFilesystemCommand
;
if
(
!
GetProgIDVerbCommandHandler
(
appProgId
appFilesystemCommand
false
)
|
|
IsPathInList
(
appFilesystemCommand
trackList
)
)
continue
;
ProcessPath
(
appList
trackList
appFilesystemCommand
)
;
}
}
regKey
-
>
Close
(
)
;
}
workingRegistryPath
=
nsLiteralString
(
u
"
Software
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Explorer
\
\
FileExts
\
\
"
)
;
workingRegistryPath
+
=
fileExtToUse
;
workingRegistryPath
.
AppendLiteral
(
"
\
\
OpenWithList
"
)
;
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CURRENT_USER
workingRegistryPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uint32_t
count
=
0
;
if
(
NS_SUCCEEDED
(
regKey
-
>
GetValueCount
(
&
count
)
)
&
&
count
>
0
)
{
for
(
uint32_t
index
=
0
;
index
<
count
;
index
+
+
)
{
nsAutoString
appName
appValue
;
if
(
NS_FAILED
(
regKey
-
>
GetValueName
(
index
appName
)
)
)
continue
;
if
(
appName
.
EqualsLiteral
(
"
MRUList
"
)
)
continue
;
if
(
NS_FAILED
(
regKey
-
>
ReadStringValue
(
appName
appValue
)
)
)
continue
;
nsAutoString
appFilesystemCommand
;
if
(
!
GetAppsVerbCommandHandler
(
appValue
appFilesystemCommand
false
)
|
|
IsPathInList
(
appFilesystemCommand
trackList
)
)
continue
;
ProcessPath
(
appList
trackList
appFilesystemCommand
)
;
}
}
}
workingRegistryPath
=
nsLiteralString
(
u
"
Software
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Explorer
\
\
FileExts
\
\
"
)
;
workingRegistryPath
+
=
fileExtToUse
;
workingRegistryPath
.
AppendLiteral
(
"
\
\
OpenWithProgids
"
)
;
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CURRENT_USER
workingRegistryPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uint32_t
count
=
0
;
if
(
NS_SUCCEEDED
(
regKey
-
>
GetValueCount
(
&
count
)
)
&
&
count
>
0
)
{
for
(
uint32_t
index
=
0
;
index
<
count
;
index
+
+
)
{
nsAutoString
appIndex
appProgId
;
if
(
NS_FAILED
(
regKey
-
>
GetValueName
(
index
appProgId
)
)
)
continue
;
nsAutoString
appFilesystemCommand
;
if
(
!
GetProgIDVerbCommandHandler
(
appProgId
appFilesystemCommand
false
)
|
|
IsPathInList
(
appFilesystemCommand
trackList
)
)
continue
;
ProcessPath
(
appList
trackList
appFilesystemCommand
)
;
}
}
regKey
-
>
Close
(
)
;
}
workingRegistryPath
=
fileExtToUse
;
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
workingRegistryPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoString
perceivedType
;
rv
=
regKey
-
>
ReadStringValue
(
u
"
PerceivedType
"
_ns
perceivedType
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoString
openWithListPath
(
u
"
SystemFileAssociations
\
\
"
_ns
)
;
openWithListPath
.
Append
(
perceivedType
)
;
openWithListPath
.
AppendLiteral
(
"
\
\
OpenWithList
"
)
;
nsresult
rv
=
appKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
openWithListPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uint32_t
count
=
0
;
if
(
NS_SUCCEEDED
(
regKey
-
>
GetValueCount
(
&
count
)
)
&
&
count
>
0
)
{
for
(
uint32_t
index
=
0
;
index
<
count
;
index
+
+
)
{
nsAutoString
appName
;
if
(
NS_FAILED
(
regKey
-
>
GetValueName
(
index
appName
)
)
)
continue
;
nsAutoString
appFilesystemCommand
;
if
(
!
GetAppsVerbCommandHandler
(
appName
appFilesystemCommand
false
)
|
|
IsPathInList
(
appFilesystemCommand
trackList
)
)
continue
;
ProcessPath
(
appList
trackList
appFilesystemCommand
)
;
}
}
}
}
}
}
workingRegistryPath
=
u
"
*
\
\
OpenWithList
"
_ns
;
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
workingRegistryPath
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uint32_t
count
=
0
;
if
(
NS_SUCCEEDED
(
regKey
-
>
GetValueCount
(
&
count
)
)
&
&
count
>
0
)
{
for
(
uint32_t
index
=
0
;
index
<
count
;
index
+
+
)
{
nsAutoString
appName
;
if
(
NS_FAILED
(
regKey
-
>
GetValueName
(
index
appName
)
)
)
continue
;
nsAutoString
appFilesystemCommand
;
if
(
!
GetAppsVerbCommandHandler
(
appName
appFilesystemCommand
false
)
|
|
IsPathInList
(
appFilesystemCommand
trackList
)
)
continue
;
ProcessPath
(
appList
trackList
appFilesystemCommand
)
;
}
}
regKey
-
>
Close
(
)
;
}
workingRegistryPath
=
u
"
Applications
"
_ns
;
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CLASSES_ROOT
workingRegistryPath
nsIWindowsRegKey
:
:
ACCESS_ENUMERATE_SUB_KEYS
|
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uint32_t
count
=
0
;
if
(
NS_SUCCEEDED
(
regKey
-
>
GetChildCount
(
&
count
)
)
&
&
count
>
0
)
{
for
(
uint32_t
index
=
0
;
index
<
count
;
index
+
+
)
{
nsAutoString
appName
;
if
(
NS_FAILED
(
regKey
-
>
GetChildName
(
index
appName
)
)
)
continue
;
nsAutoString
appFilesystemCommand
;
if
(
!
GetAppsVerbCommandHandler
(
appName
appFilesystemCommand
false
)
|
|
IsPathInList
(
appFilesystemCommand
trackList
)
)
continue
;
ProcessPath
(
appList
trackList
appFilesystemCommand
)
;
}
}
}
*
_retval
=
appList
;
NS_ADDREF
(
*
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsMIMEInfoWin
:
:
IsCurrentAppOSDefault
(
bool
*
_retval
)
{
*
_retval
=
false
;
if
(
mDefaultApplication
)
{
nsCOMPtr
<
nsIFile
>
ourBinary
;
XRE_GetBinaryPath
(
getter_AddRefs
(
ourBinary
)
)
;
bool
isSame
=
false
;
nsresult
rv
=
mDefaultApplication
-
>
Equals
(
ourBinary
&
isSame
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
_retval
=
isSame
;
}
return
NS_OK
;
}
