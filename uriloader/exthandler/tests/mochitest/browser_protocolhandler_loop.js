"
use
strict
"
;
add_task
(
async
function
test_helperapp
(
)
{
const
kProt
=
"
foopydoopydoo
"
;
const
extProtocolSvc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
const
handlerSvc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
let
handlerInfo
=
extProtocolSvc
.
getProtocolHandlerInfo
(
kProt
)
;
if
(
handlerSvc
.
exists
(
handlerInfo
)
)
{
handlerSvc
.
fillHandlerInfo
(
handlerInfo
"
"
)
;
}
handlerInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
handlerInfo
.
alwaysAskBeforeHandling
=
false
;
let
selfFile
=
Services
.
dirsvc
.
get
(
"
XREExeF
"
Ci
.
nsIFile
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
while
(
!
selfFile
.
leafName
.
endsWith
(
"
.
app
"
)
&
&
!
selfFile
.
leafName
.
endsWith
(
"
.
app
/
"
)
)
{
selfFile
=
selfFile
.
parent
;
}
}
let
selfHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
selfHandlerApp
.
executable
=
selfFile
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
selfHandlerApp
)
;
handlerInfo
.
preferredApplicationHandler
=
selfHandlerApp
;
handlerSvc
.
store
(
handlerInfo
)
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
browser
=
>
{
let
oldAddTab
=
gBrowser
.
addTab
;
registerCleanupFunction
(
(
)
=
>
(
gBrowser
.
addTab
=
gBrowser
.
loadOneTab
=
oldAddTab
)
)
;
let
wrongThingHappenedPromise
=
new
Promise
(
resolve
=
>
{
gBrowser
.
addTab
=
gBrowser
.
loadOneTab
=
function
(
aURI
)
{
ok
(
false
"
Tried
to
open
unexpected
URL
in
a
tab
:
"
+
aURI
)
;
resolve
(
null
)
;
return
{
}
;
}
;
}
)
;
let
askedUserPromise
=
new
Promise
(
r
=
>
{
let
obs
=
(
)
=
>
{
r
(
"
yes
"
)
;
Services
.
obs
.
removeObserver
(
obs
"
domwindowopened
"
)
;
}
;
Services
.
obs
.
addObserver
(
obs
"
domwindowopened
"
)
;
}
)
;
BrowserTestUtils
.
loadURI
(
browser
kProt
+
"
:
test
"
)
;
let
win
=
await
Promise
.
race
(
[
wrongThingHappenedPromise
askedUserPromise
]
)
;
ok
(
win
"
Should
have
gotten
a
window
"
)
;
for
(
let
openWin
of
Services
.
wm
.
getEnumerator
(
"
"
)
)
{
if
(
!
openWin
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
)
{
openWin
.
close
(
)
;
}
}
askedUserPromise
=
null
;
}
)
;
}
)
;
