"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
HandlerServiceTestUtils
.
jsm
"
this
)
;
let
gHandlerService
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
const
TEST_PATH
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
com
"
)
;
const
CONTENT_HANDLING_URL
=
"
chrome
:
/
/
mozapps
/
content
/
handling
/
dialog
.
xhtml
"
;
let
gOldMailHandlers
=
[
]
;
add_task
(
async
function
setup
(
)
{
let
mailHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
mailto
"
)
;
let
handlers
=
mailHandlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
handlers
.
Count
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
try
{
let
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
gOldMailHandlers
.
push
(
handler
)
;
handlers
.
removeElementAt
(
i
)
;
}
catch
(
ex
)
{
}
}
let
previousHandling
=
mailHandlerInfo
.
alwaysAskBeforeHandling
;
mailHandlerInfo
.
alwaysAskBeforeHandling
=
true
;
let
dummy
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
dummy
.
name
=
"
Handler
1
"
;
dummy
.
uriTemplate
=
"
https
:
/
/
example
.
com
/
first
/
%
s
"
;
mailHandlerInfo
.
possibleApplicationHandlers
.
appendElement
(
dummy
)
;
gHandlerService
.
store
(
mailHandlerInfo
)
;
registerCleanupFunction
(
(
)
=
>
{
let
mailHandlers
=
mailHandlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
handlers
.
Count
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
try
{
mailHandlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
mailHandlers
.
removeElementAt
(
i
)
;
}
catch
(
ex
)
{
}
}
for
(
let
h
of
gOldMailHandlers
)
{
mailHandlers
.
appendElement
(
h
)
;
}
mailHandlerInfo
.
alwaysAskBeforeHandling
=
previousHandling
;
gHandlerService
.
store
(
mailHandlerInfo
)
;
}
)
;
}
)
;
add_task
(
async
function
test_closed_by_tab_closure
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PATH
+
"
file_nested_protocol_request
.
html
"
)
;
let
dialogWindowPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
true
)
;
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
a
:
link
"
{
}
tab
.
linkedBrowser
.
browsingContext
.
children
[
0
]
)
;
let
dialog
=
await
dialogWindowPromise
;
is
(
dialog
.
_frame
.
contentDocument
.
location
.
href
CONTENT_HANDLING_URL
"
Dialog
URL
is
as
expected
"
)
;
let
dialogClosedPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
false
)
;
info
(
"
Removing
tab
to
close
the
dialog
.
"
)
;
gBrowser
.
removeTab
(
tab
)
;
await
dialogClosedPromise
;
ok
(
!
dialog
.
_frame
.
contentWindow
"
The
dialog
should
have
been
closed
.
"
)
;
}
)
;
add_task
(
async
function
test_closed_by_tab_navigation
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PATH
+
"
file_nested_protocol_request
.
html
"
)
;
let
dialogWindowPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
true
)
;
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
a
:
link
"
{
}
tab
.
linkedBrowser
.
browsingContext
.
children
[
0
]
)
;
let
dialog
=
await
dialogWindowPromise
;
is
(
dialog
.
_frame
.
contentDocument
.
location
.
href
CONTENT_HANDLING_URL
"
Dialog
URL
is
as
expected
"
)
;
let
dialogClosedPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
false
)
;
info
(
"
Set
up
unload
handler
to
ensure
we
don
'
t
break
when
the
window
global
gets
cleared
"
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
function
(
)
{
content
.
addEventListener
(
"
unload
"
function
(
)
{
}
)
;
}
)
;
info
(
"
Navigating
tab
to
a
different
but
same
origin
page
.
"
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
TEST_PATH
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
TEST_PATH
)
;
ok
(
dialog
.
_frame
.
contentWindow
"
Dialog
should
stay
open
.
"
)
;
let
numCycles
=
3
;
for
(
let
i
=
0
;
i
<
numCycles
;
i
+
+
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
}
info
(
"
Now
navigate
to
a
cross
-
origin
page
.
"
)
;
const
CROSS_ORIGIN_TEST_PATH
=
TEST_PATH
.
replace
(
"
.
com
"
"
.
org
"
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
CROSS_ORIGIN_TEST_PATH
)
;
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
CROSS_ORIGIN_TEST_PATH
)
;
await
dialogClosedPromise
;
ok
(
!
dialog
.
_frame
.
contentWindow
"
The
dialog
should
have
been
closed
.
"
)
;
await
loadPromise
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
test_multiple_dialogs
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PATH
+
"
file_nested_protocol_request
.
html
"
)
;
let
dialogWindowPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
true
)
;
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
a
:
link
"
{
}
tab
.
linkedBrowser
.
browsingContext
.
children
[
0
]
)
;
let
dialog
=
await
dialogWindowPromise
;
is
(
dialog
.
_frame
.
contentDocument
.
location
.
href
CONTENT_HANDLING_URL
"
Dialog
URL
is
as
expected
"
)
;
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
[
]
(
)
=
>
content
.
eval
(
"
location
.
href
=
'
mailto
:
help
example
.
com
'
"
)
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
100
)
)
;
let
tabDialogBox
=
gBrowser
.
getTabDialogBox
(
tab
.
linkedBrowser
)
;
let
dialogs
=
tabDialogBox
.
_dialogManager
.
_dialogs
.
filter
(
d
=
>
d
.
_openedURL
=
=
CONTENT_HANDLING_URL
)
;
is
(
dialogs
.
length
1
"
Should
only
have
1
dialog
open
"
)
;
let
dialogClosedPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
false
)
;
dialog
.
close
(
)
;
dialog
=
await
dialogClosedPromise
;
ok
(
!
dialog
.
_openedURL
"
The
dialog
should
have
been
closed
.
"
)
;
dialogWindowPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
true
)
;
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
a
:
link
"
{
}
tab
.
linkedBrowser
.
browsingContext
.
children
[
0
]
)
;
dialog
=
await
dialogWindowPromise
;
is
(
dialog
.
_frame
.
contentDocument
.
location
.
href
CONTENT_HANDLING_URL
"
Second
dialog
URL
is
as
expected
"
)
;
dialogClosedPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
false
)
;
info
(
"
Removing
tab
to
close
the
dialog
.
"
)
;
gBrowser
.
removeTab
(
tab
)
;
await
dialogClosedPromise
;
ok
(
!
dialog
.
_frame
.
contentWindow
"
The
dialog
should
have
been
closed
again
.
"
)
;
}
)
;
add_task
(
async
function
invisible_iframes
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
https
:
/
/
example
.
com
/
"
)
;
let
dialogWindowPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
true
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
function
(
)
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
frame
.
style
.
display
=
"
none
"
;
frame
.
src
=
"
mailto
:
help
example
.
com
"
;
content
.
document
.
body
.
append
(
frame
)
;
}
)
;
let
dialog
=
await
dialogWindowPromise
;
is
(
dialog
.
_frame
.
contentDocument
.
location
.
href
CONTENT_HANDLING_URL
"
Dialog
opens
as
expected
for
invisible
iframe
"
)
;
let
dialogClosedPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
false
)
;
dialog
.
close
(
)
;
await
dialogClosedPromise
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
nested_iframes
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
https
:
/
/
example
.
com
/
"
)
;
let
dialogWindowPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
true
)
;
let
innerLoaded
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
true
"
https
:
/
/
example
.
org
/
"
)
;
info
(
"
Constructing
top
frame
"
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
function
(
)
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
frame
.
src
=
"
https
:
/
/
example
.
org
/
"
;
content
.
document
.
body
.
prepend
(
frame
)
;
content
.
eval
(
window
.
addEventListener
(
"
message
"
e
=
>
e
.
source
.
location
=
"
mailto
:
help
example
.
com
"
)
;
)
;
}
)
;
await
innerLoaded
;
let
parentBC
=
tab
.
linkedBrowser
.
browsingContext
;
info
(
"
Creating
innermost
frame
"
)
;
await
SpecialPowers
.
spawn
(
parentBC
.
children
[
0
]
[
]
async
function
(
)
{
let
innerFrame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
let
frameLoaded
=
ContentTaskUtils
.
waitForEvent
(
innerFrame
"
load
"
true
)
;
content
.
document
.
body
.
prepend
(
innerFrame
)
;
await
frameLoaded
;
}
)
;
info
(
"
Posting
event
from
innermost
frame
"
)
;
await
SpecialPowers
.
spawn
(
parentBC
.
children
[
0
]
.
children
[
0
]
[
]
async
function
(
)
{
content
.
eval
(
"
top
.
postMessage
(
'
hello
'
'
*
'
)
"
)
;
}
)
;
let
dialog
=
await
dialogWindowPromise
;
is
(
dialog
.
_frame
.
contentDocument
.
location
.
href
CONTENT_HANDLING_URL
"
Dialog
opens
as
expected
for
deeply
nested
cross
-
origin
iframe
"
)
;
let
dialogClosedPromise
=
waitForProtocolAskDialog
(
tab
.
linkedBrowser
false
)
;
dialog
.
close
(
)
;
await
dialogClosedPromise
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
