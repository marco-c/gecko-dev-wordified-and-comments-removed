"
use
strict
"
;
let
gHandlerService
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
requestLongerTimeout
(
3
)
;
const
DIALOG_URL_APP_CHOOSER
=
"
chrome
:
/
/
mozapps
/
content
/
handling
/
appChooser
.
xhtml
"
;
const
DIALOG_URL_PERMISSION
=
"
chrome
:
/
/
mozapps
/
content
/
handling
/
permissionDialog
.
xhtml
"
;
const
PROTOCOL_HANDLER_OPEN_PERM_KEY
=
"
open
-
protocol
-
handler
"
;
const
PERMISSION_KEY_DELIMITER
=
"
^
"
;
const
TEST_PROTOS
=
[
"
foo
"
"
bar
"
]
;
let
testDir
=
getChromeDir
(
getResolvedURI
(
gTestPath
)
)
;
const
ORIGIN1
=
"
https
:
/
/
example
.
com
"
;
const
ORIGIN2
=
"
https
:
/
/
example
.
org
"
;
const
ORIGIN3
=
Services
.
io
.
newFileURI
(
testDir
)
.
spec
;
const
PRINCIPAL1
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
ORIGIN1
)
;
const
PRINCIPAL2
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
ORIGIN2
)
;
const
PRINCIPAL3
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
ORIGIN3
)
;
let
testExtension
;
function
getSkipProtoDialogPermissionKey
(
aProtocolScheme
)
{
return
(
PROTOCOL_HANDLER_OPEN_PERM_KEY
+
PERMISSION_KEY_DELIMITER
+
aProtocolScheme
)
;
}
function
initTestHandlers
(
)
{
TEST_PROTOS
.
forEach
(
scheme
=
>
{
let
webHandler
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
webHandler
.
name
=
scheme
+
"
Handler
"
;
webHandler
.
uriTemplate
=
ORIGIN1
+
"
/
?
url
=
%
s
"
;
let
handlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
scheme
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
webHandler
)
;
handlerInfo
.
preferredApplicationHandler
=
webHandler
;
gHandlerService
.
store
(
handlerInfo
)
;
}
)
;
}
function
updateAlwaysAsk
(
scheme
ask
)
{
let
handlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
scheme
)
;
handlerInfo
.
alwaysAskBeforeHandling
=
ask
;
gHandlerService
.
store
(
handlerInfo
)
;
}
function
testAlwaysAsk
(
scheme
ask
)
{
is
(
HandlerServiceTestUtils
.
getHandlerInfo
(
scheme
)
.
alwaysAskBeforeHandling
ask
"
Should
have
correct
alwaysAsk
state
.
"
)
;
}
async
function
triggerOpenProto
(
browser
scheme
{
triggeringPrincipal
=
browser
.
contentPrincipal
useNullPrincipal
=
false
useExtensionPrincipal
=
false
omitTriggeringPrincipal
=
false
}
=
{
}
)
{
let
uri
=
{
scheme
}
:
/
/
test
;
if
(
useNullPrincipal
)
{
ContentTask
.
spawn
(
browser
{
uri
}
args
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
frame
.
src
=
data
:
text
/
html
<
script
>
location
.
href
=
"
{
args
.
uri
}
"
<
/
script
>
;
content
.
document
.
body
.
appendChild
(
frame
)
;
}
)
;
return
;
}
if
(
useExtensionPrincipal
)
{
const
EXTENSION_DATA
=
{
manifest
:
{
content_scripts
:
[
{
matches
:
[
browser
.
currentURI
.
spec
]
js
:
[
"
navigate
.
js
"
]
}
]
}
files
:
{
"
navigate
.
js
"
:
window
.
location
.
href
=
"
{
uri
}
"
;
}
}
;
testExtension
=
ExtensionTestUtils
.
loadExtension
(
EXTENSION_DATA
)
;
await
testExtension
.
startup
(
)
;
return
;
}
if
(
omitTriggeringPrincipal
)
{
let
contentDispatchChooser
=
Cc
[
"
mozilla
.
org
/
content
-
dispatch
-
chooser
;
1
"
]
.
createInstance
(
Ci
.
nsIContentDispatchChooser
)
;
let
handler
=
HandlerServiceTestUtils
.
getHandlerInfo
(
scheme
)
;
contentDispatchChooser
.
handleURI
(
handler
Services
.
io
.
newURI
(
uri
)
null
browser
.
browsingContext
)
;
return
;
}
info
(
"
Loading
uri
:
"
+
uri
)
;
browser
.
loadURI
(
uri
{
triggeringPrincipal
}
)
;
}
async
function
testOpenProto
(
browser
scheme
{
permDialogOptions
chooserDialogOptions
loadOptions
}
=
{
}
)
{
let
permDialogOpenPromise
;
let
chooserDialogOpenPromise
;
if
(
permDialogOptions
)
{
info
(
"
Should
see
permission
dialog
"
)
;
permDialogOpenPromise
=
waitForProtocolPermissionDialog
(
browser
true
)
;
}
if
(
chooserDialogOptions
)
{
info
(
"
Should
see
chooser
dialog
"
)
;
chooserDialogOpenPromise
=
waitForProtocolAppChooserDialog
(
browser
true
)
;
}
await
triggerOpenProto
(
browser
scheme
loadOptions
)
;
let
webHandlerLoadedPromise
;
let
webHandlerShouldOpen
=
(
!
permDialogOptions
&
&
!
chooserDialogOptions
)
|
|
(
(
permDialogOptions
?
.
actionConfirm
|
|
permDialogOptions
?
.
actionChangeApp
)
&
&
chooserDialogOptions
?
.
actionConfirm
)
;
if
(
webHandlerShouldOpen
)
{
webHandlerLoadedPromise
=
waitForHandlerURL
(
browser
scheme
)
;
}
if
(
permDialogOpenPromise
)
{
let
dialog
=
await
permDialogOpenPromise
;
let
dialogEl
=
getDialogElementFromSubDialog
(
dialog
)
;
let
dialogType
=
getDialogType
(
dialog
)
;
let
{
hasCheckbox
hasChangeApp
chooserIsNext
actionCheckbox
actionConfirm
actionChangeApp
}
=
permDialogOptions
;
if
(
actionChangeApp
)
{
actionConfirm
=
false
;
}
await
testCheckbox
(
dialogEl
dialogType
{
hasCheckbox
actionCheckbox
}
)
;
let
acceptBtnLabel
=
dialogEl
.
getButton
(
"
accept
"
)
?
.
label
;
if
(
chooserIsNext
)
{
is
(
acceptBtnLabel
"
Choose
Application
"
"
Accept
button
has
choose
app
label
"
)
;
}
else
{
is
(
acceptBtnLabel
"
Open
Link
"
"
Accept
button
has
open
link
label
"
)
;
}
let
changeAppLink
=
dialogEl
.
ownerDocument
.
getElementById
(
"
change
-
app
"
)
;
if
(
typeof
hasChangeApp
=
=
"
boolean
"
)
{
ok
(
changeAppLink
"
Permission
dialog
should
have
changeApp
link
label
"
)
;
is
(
!
changeAppLink
.
hidden
hasChangeApp
"
Permission
dialog
change
app
link
label
"
)
;
}
if
(
actionChangeApp
)
{
let
dialogClosedPromise
=
waitForProtocolPermissionDialog
(
browser
false
)
;
changeAppLink
.
click
(
)
;
await
dialogClosedPromise
;
}
else
{
await
closeDialog
(
browser
dialog
actionConfirm
scheme
)
;
}
}
if
(
chooserDialogOpenPromise
)
{
let
dialog
=
await
chooserDialogOpenPromise
;
let
dialogEl
=
getDialogElementFromSubDialog
(
dialog
)
;
let
dialogType
=
getDialogType
(
dialog
)
;
let
{
hasCheckbox
actionCheckbox
actionConfirm
}
=
chooserDialogOptions
;
await
testCheckbox
(
dialogEl
dialogType
{
hasCheckbox
actionCheckbox
}
)
;
await
closeDialog
(
browser
dialog
actionConfirm
scheme
)
;
}
if
(
webHandlerShouldOpen
)
{
info
(
"
Waiting
for
web
handler
to
open
"
)
;
await
webHandlerLoadedPromise
;
}
else
{
info
(
"
Web
handler
open
canceled
"
)
;
}
await
testExtension
?
.
unload
(
)
;
}
async
function
testCheckbox
(
dialogEl
dialogType
{
hasCheckbox
hasCheckboxState
=
false
actionCheckbox
}
)
{
let
checkbox
=
dialogEl
.
ownerDocument
.
getElementById
(
"
remember
"
)
;
if
(
typeof
hasCheckbox
=
=
"
boolean
"
)
{
is
(
checkbox
&
&
BrowserTestUtils
.
is_visible
(
checkbox
)
hasCheckbox
"
Dialog
checkbox
has
correct
visibility
.
"
)
;
}
if
(
typeof
hasCheckboxState
=
=
"
boolean
"
)
{
is
(
checkbox
.
checked
hasCheckboxState
"
Dialog
checkbox
has
correct
state
"
)
;
}
if
(
typeof
actionCheckbox
=
=
"
boolean
"
)
{
checkbox
.
click
(
)
;
}
}
function
getDialogElementFromSubDialog
(
subDialog
)
{
let
dialogEl
=
subDialog
.
_frame
.
contentDocument
.
querySelector
(
"
dialog
"
)
;
ok
(
dialogEl
"
SubDialog
should
have
dialog
element
"
)
;
return
dialogEl
;
}
function
waitForHandlerURL
(
browser
scheme
)
{
return
BrowserTestUtils
.
browserLoaded
(
browser
false
url
=
>
url
=
=
{
ORIGIN1
}
/
?
url
=
{
scheme
}
%
3A
%
2F
%
2Ftest
)
;
}
function
testPermission
(
principal
scheme
hasPerm
)
{
let
permKey
=
getSkipProtoDialogPermissionKey
(
scheme
)
;
let
result
=
Services
.
perms
.
testPermissionFromPrincipal
(
principal
permKey
)
;
let
message
=
{
permKey
}
{
hasPerm
?
"
is
"
:
"
is
not
"
}
set
for
{
principal
.
origin
}
.
;
is
(
result
=
=
Services
.
perms
.
ALLOW_ACTION
hasPerm
message
)
;
}
function
getDialogCheckbox
(
dialog
dialogType
)
{
let
id
;
if
(
dialogType
=
=
"
permission
"
)
{
id
=
"
remember
-
permission
"
;
}
else
{
id
=
"
remember
"
;
}
return
dialog
.
_frame
.
contentDocument
.
getElementById
(
id
)
;
}
function
getDialogType
(
dialog
)
{
let
url
=
dialog
.
_frame
.
currentURI
.
spec
;
if
(
url
=
=
=
DIALOG_URL_PERMISSION
)
{
return
"
permission
"
;
}
if
(
url
=
=
=
DIALOG_URL_APP_CHOOSER
)
{
return
"
chooser
"
;
}
throw
new
Error
(
"
Dialog
with
unexpected
url
"
)
;
}
async
function
closeDialog
(
browser
dialog
confirm
scheme
)
{
let
dialogClosedPromise
=
waitForSubDialog
(
browser
dialog
.
_openedURL
false
)
;
let
dialogEl
=
getDialogElementFromSubDialog
(
dialog
)
;
if
(
confirm
)
{
if
(
getDialogType
(
dialog
)
=
=
"
chooser
"
)
{
let
listItem
=
dialogEl
.
ownerDocument
.
querySelector
(
richlistitem
[
name
=
"
{
scheme
}
Handler
"
]
)
;
listItem
.
click
(
)
;
}
dialogEl
.
setAttribute
(
"
buttondisabledaccept
"
false
)
;
dialogEl
.
acceptDialog
(
)
;
}
else
{
dialogEl
.
cancelDialog
(
)
;
}
return
dialogClosedPromise
;
}
registerCleanupFunction
(
function
(
)
{
TEST_PROTOS
.
forEach
(
scheme
=
>
{
let
handlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
scheme
)
;
gHandlerService
.
remove
(
handlerInfo
)
;
}
)
;
Services
.
perms
.
removeAll
(
)
;
}
)
;
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
security
.
external_protocol_requires_permission
"
true
]
]
}
)
;
initTestHandlers
(
)
;
}
)
;
add_task
(
async
function
test_permission_allow_once
(
)
{
for
(
let
scheme
of
TEST_PROTOS
)
{
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
false
chooserIsNext
:
true
actionConfirm
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
true
}
}
)
;
}
)
;
testPermission
(
PRINCIPAL1
scheme
false
)
;
testPermission
(
PRINCIPAL2
scheme
false
)
;
testAlwaysAsk
(
scheme
true
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
false
chooserIsNext
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
}
)
;
add_task
(
async
function
test_permission_allow_persist
(
)
{
for
(
let
[
origin
principal
]
of
[
[
ORIGIN1
PRINCIPAL1
]
[
ORIGIN3
PRINCIPAL3
]
]
)
{
for
(
let
scheme
of
TEST_PROTOS
)
{
info
(
"
Testing
with
origin
"
+
origin
)
;
info
(
"
testing
with
principal
of
origin
"
+
principal
.
origin
)
;
info
(
"
testing
with
protocol
"
+
scheme
)
;
Services
.
perms
.
addFromPrincipal
(
principal
getSkipProtoDialogPermissionKey
(
"
foobar
"
)
Services
.
perms
.
ALLOW_ACTION
)
;
await
BrowserTestUtils
.
withNewTab
(
origin
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
false
chooserIsNext
:
true
actionCheckbox
:
true
actionConfirm
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
true
}
}
)
;
}
)
;
testPermission
(
principal
scheme
true
)
;
testPermission
(
PRINCIPAL2
scheme
false
)
;
testAlwaysAsk
(
scheme
true
)
;
await
BrowserTestUtils
.
withNewTab
(
origin
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN2
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
false
chooserIsNext
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
Services
.
perms
.
removeAll
(
)
;
}
}
}
)
;
add_task
(
async
function
test_permission_application_set
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
updateAlwaysAsk
(
scheme
false
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
true
chooserIsNext
:
false
actionChangeApp
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
true
}
}
)
;
}
)
;
updateAlwaysAsk
(
scheme
true
)
;
}
)
;
add_task
(
async
function
test_permission_system_principal
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
loadOptions
:
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_permission_disabled
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
security
.
external_protocol_requires_permission
"
false
]
]
}
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
true
}
}
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
test_app_and_permission_set
(
)
{
let
scheme
=
TEST_PROTOS
[
1
]
;
updateAlwaysAsk
(
scheme
false
)
;
Services
.
perms
.
addFromPrincipal
(
PRINCIPAL2
getSkipProtoDialogPermissionKey
(
scheme
)
Services
.
perms
.
ALLOW_ACTION
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN2
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
)
;
}
)
;
Services
.
perms
.
removeAll
(
)
;
updateAlwaysAsk
(
scheme
true
)
;
}
)
;
add_task
(
async
function
test_change_app_checkbox_cancel
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
chooserIsNext
:
true
hasChangeApp
:
false
actionConfirm
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
testAlwaysAsk
(
scheme
true
)
;
}
)
;
add_task
(
async
function
test_null_principal
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
loadOptions
:
{
useNullPrincipal
:
true
}
permDialogOptions
:
{
hasCheckbox
:
false
chooserIsNext
:
true
hasChangeApp
:
false
actionConfirm
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_no_principal
(
)
{
let
scheme
=
TEST_PROTOS
[
1
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
loadOptions
:
{
omitTriggeringPrincipal
:
true
}
permDialogOptions
:
{
hasCheckbox
:
false
chooserIsNext
:
true
hasChangeApp
:
false
actionConfirm
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_extension_principal
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
loadOptions
:
{
useExtensionPrincipal
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
)
;
