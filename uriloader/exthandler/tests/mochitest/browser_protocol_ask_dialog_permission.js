"
use
strict
"
;
var
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
{
ExtensionPermissions
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ExtensionPermissions
.
sys
.
mjs
"
)
;
let
gHandlerService
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
const
ROOT_PATH
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
"
)
;
requestLongerTimeout
(
7
)
;
const
DIALOG_URL_APP_CHOOSER
=
"
chrome
:
/
/
mozapps
/
content
/
handling
/
appChooser
.
xhtml
"
;
const
DIALOG_URL_PERMISSION
=
"
chrome
:
/
/
mozapps
/
content
/
handling
/
permissionDialog
.
xhtml
"
;
const
PROTOCOL_HANDLER_OPEN_PERM_KEY
=
"
open
-
protocol
-
handler
"
;
const
PERMISSION_KEY_DELIMITER
=
"
^
"
;
const
TEST_PROTOS
=
[
"
foo
"
"
bar
"
]
;
const
WALLET_PROTO
=
"
moz
-
test
-
wallet
"
;
let
testDir
=
getChromeDir
(
getResolvedURI
(
gTestPath
)
)
;
const
ORIGIN1
=
"
https
:
/
/
example
.
com
"
;
const
ORIGIN2
=
"
https
:
/
/
example
.
org
"
;
const
ORIGIN3
=
Services
.
io
.
newFileURI
(
testDir
)
.
spec
;
const
PRINCIPAL1
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
ORIGIN1
)
;
const
PRINCIPAL2
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
ORIGIN2
)
;
const
PRINCIPAL3
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
ORIGIN3
)
;
const
NULL_PRINCIPAL_SCHEME
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
.
scheme
.
toLowerCase
(
)
;
function
getSkipProtoDialogPermissionKey
(
aProtocolScheme
)
{
return
(
PROTOCOL_HANDLER_OPEN_PERM_KEY
+
PERMISSION_KEY_DELIMITER
+
aProtocolScheme
)
;
}
function
initTestHandlers
(
)
{
const
allProtos
=
structuredClone
(
TEST_PROTOS
)
;
allProtos
.
push
(
WALLET_PROTO
)
;
allProtos
.
forEach
(
scheme
=
>
{
let
webHandler
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
webHandler
.
name
=
scheme
+
"
Handler
"
;
webHandler
.
uriTemplate
=
ORIGIN1
+
"
/
?
url
=
%
s
"
;
let
handlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
scheme
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
webHandler
)
;
handlerInfo
.
preferredApplicationHandler
=
webHandler
;
gHandlerService
.
store
(
handlerInfo
)
;
}
)
;
}
function
updateAlwaysAsk
(
scheme
ask
)
{
let
handlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
scheme
)
;
handlerInfo
.
alwaysAskBeforeHandling
=
ask
;
gHandlerService
.
store
(
handlerInfo
)
;
}
function
testAlwaysAsk
(
scheme
ask
)
{
is
(
HandlerServiceTestUtils
.
getHandlerInfo
(
scheme
)
.
alwaysAskBeforeHandling
ask
"
Should
have
correct
alwaysAsk
state
.
"
)
;
}
function
useServerRedirect
(
serverRedirect
)
{
return
async
(
browser
scheme
)
=
>
{
let
uri
=
{
scheme
}
:
/
/
test
;
let
innerParams
=
new
URLSearchParams
(
)
;
innerParams
.
set
(
"
uri
"
uri
)
;
innerParams
.
set
(
"
redirectType
"
serverRedirect
)
;
let
params
=
new
URLSearchParams
(
)
;
params
.
set
(
"
uri
"
"
https
:
/
/
example
.
com
/
"
+
ROOT_PATH
+
"
redirect_helper
.
sjs
?
"
+
innerParams
.
toString
(
)
)
;
uri
=
"
https
:
/
/
example
.
org
/
"
+
ROOT_PATH
+
"
redirect_helper
.
sjs
?
"
+
params
.
toString
(
)
;
BrowserTestUtils
.
startLoadingURIString
(
browser
uri
)
;
}
;
}
function
useTriggeringPrincipal
(
principal
=
undefined
)
{
return
async
(
browser
scheme
)
=
>
{
let
uri
=
{
scheme
}
:
/
/
test
;
let
triggeringPrincipal
=
principal
?
?
browser
.
contentPrincipal
;
info
(
"
Loading
uri
:
"
+
uri
)
;
browser
.
loadURI
(
Services
.
io
.
newURI
(
uri
)
{
triggeringPrincipal
}
)
;
}
;
}
async
function
testOpenProto
(
browser
scheme
{
permDialogOptions
chooserDialogOptions
triggerLoad
=
useTriggeringPrincipal
(
)
}
=
{
}
)
{
let
permDialogOpenPromise
;
let
chooserDialogOpenPromise
;
if
(
permDialogOptions
)
{
info
(
"
Should
see
permission
dialog
"
)
;
permDialogOpenPromise
=
waitForProtocolPermissionDialog
(
browser
true
)
;
}
if
(
chooserDialogOptions
)
{
info
(
"
Should
see
chooser
dialog
"
)
;
chooserDialogOpenPromise
=
waitForProtocolAppChooserDialog
(
browser
true
)
;
}
await
triggerLoad
(
browser
scheme
)
;
let
webHandlerLoadedPromise
;
let
webHandlerShouldOpen
=
(
!
permDialogOptions
&
&
!
chooserDialogOptions
)
|
|
(
(
permDialogOptions
?
.
actionConfirm
|
|
permDialogOptions
?
.
actionChangeApp
)
&
&
chooserDialogOptions
?
.
actionConfirm
)
;
if
(
webHandlerShouldOpen
)
{
webHandlerLoadedPromise
=
waitForHandlerURL
(
browser
scheme
)
;
}
if
(
permDialogOpenPromise
)
{
let
dialog
=
await
permDialogOpenPromise
;
let
dialogEl
=
getDialogElementFromSubDialog
(
dialog
)
;
let
dialogType
=
getDialogType
(
dialog
)
;
let
{
hasCheckbox
checkboxOrigin
hasChangeApp
chooserIsNext
actionCheckbox
actionConfirm
actionChangeApp
checkContents
hasWalletWarning
=
false
}
=
permDialogOptions
;
if
(
actionChangeApp
)
{
actionConfirm
=
false
;
}
let
descriptionEl
=
dialogEl
.
querySelector
(
"
#
description
"
)
;
let
warningEl
=
dialogEl
.
querySelector
(
"
#
warning
-
bar
"
)
;
if
(
hasWalletWarning
)
{
ok
(
descriptionEl
&
&
!
BrowserTestUtils
.
isVisible
(
descriptionEl
)
"
Has
an
invisible
description
element
.
"
)
;
ok
(
warningEl
&
&
BrowserTestUtils
.
isVisible
(
warningEl
)
"
Has
a
visible
warning
element
.
"
)
;
ok
(
!
warningEl
.
innerHTML
.
toLowerCase
(
)
.
includes
(
NULL_PRINCIPAL_SCHEME
)
"
Warning
does
not
include
NullPrincipal
scheme
.
"
)
;
}
else
{
ok
(
descriptionEl
&
&
BrowserTestUtils
.
isVisible
(
descriptionEl
)
"
Has
a
visible
description
element
.
"
)
;
ok
(
!
descriptionEl
.
innerHTML
.
toLowerCase
(
)
.
includes
(
NULL_PRINCIPAL_SCHEME
)
"
Description
does
not
include
NullPrincipal
scheme
.
"
)
;
ok
(
warningEl
&
&
!
BrowserTestUtils
.
isVisible
(
warningEl
)
"
Has
an
invisible
warning
element
.
"
)
;
}
await
testCheckbox
(
dialogEl
dialogType
{
hasCheckbox
actionCheckbox
checkboxOrigin
}
)
;
let
acceptBtnLabel
=
dialogEl
.
getButton
(
"
accept
"
)
?
.
label
;
if
(
chooserIsNext
)
{
is
(
acceptBtnLabel
"
Choose
Application
"
"
Accept
button
has
choose
app
label
"
)
;
}
else
{
is
(
acceptBtnLabel
"
Open
Link
"
"
Accept
button
has
open
link
label
"
)
;
}
let
changeAppLink
=
dialogEl
.
ownerDocument
.
getElementById
(
"
change
-
app
"
)
;
if
(
typeof
hasChangeApp
=
=
"
boolean
"
)
{
ok
(
changeAppLink
"
Permission
dialog
should
have
changeApp
link
label
"
)
;
is
(
!
changeAppLink
.
hidden
hasChangeApp
"
Permission
dialog
change
app
link
label
"
)
;
}
if
(
checkContents
)
{
checkContents
(
dialogEl
)
;
}
if
(
actionChangeApp
)
{
let
dialogClosedPromise
=
waitForProtocolPermissionDialog
(
browser
false
)
;
changeAppLink
.
click
(
)
;
await
dialogClosedPromise
;
}
else
{
await
closeDialog
(
browser
dialog
actionConfirm
scheme
)
;
}
}
if
(
chooserDialogOpenPromise
)
{
let
dialog
=
await
chooserDialogOpenPromise
;
let
dialogEl
=
getDialogElementFromSubDialog
(
dialog
)
;
let
dialogType
=
getDialogType
(
dialog
)
;
let
{
hasCheckbox
actionCheckbox
actionConfirm
}
=
chooserDialogOptions
;
await
testCheckbox
(
dialogEl
dialogType
{
hasCheckbox
actionCheckbox
}
)
;
await
closeDialog
(
browser
dialog
actionConfirm
scheme
)
;
}
if
(
webHandlerShouldOpen
)
{
info
(
"
Waiting
for
web
handler
to
open
"
)
;
await
webHandlerLoadedPromise
;
}
else
{
info
(
"
Web
handler
open
canceled
"
)
;
}
}
async
function
testCheckbox
(
dialogEl
dialogType
{
hasCheckbox
hasCheckboxState
=
false
actionCheckbox
checkboxOrigin
}
)
{
let
checkbox
=
dialogEl
.
ownerDocument
.
getElementById
(
"
remember
"
)
;
if
(
typeof
hasCheckbox
=
=
"
boolean
"
)
{
is
(
checkbox
&
&
BrowserTestUtils
.
isVisible
(
checkbox
)
hasCheckbox
"
Dialog
checkbox
has
correct
visibility
.
"
)
;
let
checkboxLabel
=
dialogEl
.
ownerDocument
.
getElementById
(
"
remember
-
label
"
)
;
is
(
checkbox
&
&
BrowserTestUtils
.
isVisible
(
checkboxLabel
)
hasCheckbox
"
Dialog
checkbox
label
has
correct
visibility
.
"
)
;
if
(
hasCheckbox
)
{
ok
(
!
checkboxLabel
.
innerHTML
.
toLowerCase
(
)
.
includes
(
NULL_PRINCIPAL_SCHEME
)
"
Dialog
checkbox
label
does
not
include
NullPrincipal
scheme
.
"
)
;
}
}
if
(
typeof
hasCheckboxState
=
=
"
boolean
"
)
{
is
(
checkbox
.
checked
hasCheckboxState
"
Dialog
checkbox
has
correct
state
"
)
;
}
if
(
checkboxOrigin
)
{
let
doc
=
dialogEl
.
ownerDocument
;
let
hostFromLabel
=
doc
.
l10n
.
getAttributes
(
doc
.
getElementById
(
"
remember
-
label
"
)
)
.
args
.
host
;
is
(
hostFromLabel
checkboxOrigin
"
Checkbox
should
be
for
correct
domain
.
"
)
;
}
if
(
typeof
actionCheckbox
=
=
"
boolean
"
)
{
checkbox
.
click
(
)
;
}
}
function
waitForHandlerURL
(
browser
scheme
)
{
return
BrowserTestUtils
.
browserLoaded
(
browser
false
url
=
>
url
=
=
{
ORIGIN1
}
/
?
url
=
{
scheme
}
%
3A
%
2F
%
2Ftest
)
;
}
function
testPermission
(
principal
scheme
hasPerm
)
{
let
permKey
=
getSkipProtoDialogPermissionKey
(
scheme
)
;
let
result
=
Services
.
perms
.
testPermissionFromPrincipal
(
principal
permKey
)
;
let
message
=
{
permKey
}
{
hasPerm
?
"
is
"
:
"
is
not
"
}
set
for
{
principal
.
origin
}
.
;
is
(
result
=
=
Services
.
perms
.
ALLOW_ACTION
hasPerm
message
)
;
}
function
getDialogCheckbox
(
dialog
dialogType
)
{
let
id
;
if
(
dialogType
=
=
"
permission
"
)
{
id
=
"
remember
-
permission
"
;
}
else
{
id
=
"
remember
"
;
}
return
dialog
.
_frame
.
contentDocument
.
getElementById
(
id
)
;
}
function
getDialogType
(
dialog
)
{
let
url
=
dialog
.
_frame
.
currentURI
.
spec
;
if
(
url
=
=
=
DIALOG_URL_PERMISSION
)
{
return
"
permission
"
;
}
if
(
url
=
=
=
DIALOG_URL_APP_CHOOSER
)
{
return
"
chooser
"
;
}
throw
new
Error
(
"
Dialog
with
unexpected
url
"
)
;
}
async
function
closeDialog
(
browser
dialog
confirm
scheme
)
{
let
dialogClosedPromise
=
waitForSubDialog
(
browser
dialog
.
_openedURL
false
)
;
let
dialogEl
=
getDialogElementFromSubDialog
(
dialog
)
;
if
(
confirm
)
{
if
(
getDialogType
(
dialog
)
=
=
"
chooser
"
)
{
let
listItem
=
dialogEl
.
ownerDocument
.
querySelector
(
richlistitem
[
name
=
"
{
scheme
}
Handler
"
]
)
;
listItem
.
click
(
)
;
}
dialogEl
.
removeAttribute
(
"
buttondisabledaccept
"
)
;
dialogEl
.
acceptDialog
(
)
;
}
else
{
dialogEl
.
cancelDialog
(
)
;
}
return
dialogClosedPromise
;
}
registerCleanupFunction
(
function
(
)
{
TEST_PROTOS
.
forEach
(
scheme
=
>
{
let
handlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
scheme
)
;
gHandlerService
.
remove
(
handlerInfo
)
;
}
)
;
Services
.
perms
.
removeAll
(
)
;
}
)
;
add_setup
(
async
function
(
)
{
initTestHandlers
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
wallet_schemes
"
WALLET_PROTO
]
]
}
)
;
}
)
;
add_task
(
async
function
test_permission_allow_once
(
)
{
for
(
let
scheme
of
TEST_PROTOS
)
{
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
false
chooserIsNext
:
true
actionConfirm
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
true
}
}
)
;
}
)
;
testPermission
(
PRINCIPAL1
scheme
false
)
;
testPermission
(
PRINCIPAL2
scheme
false
)
;
testAlwaysAsk
(
scheme
true
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
false
chooserIsNext
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
}
)
;
add_task
(
async
function
test_permission_allow_persist
(
)
{
for
(
let
[
origin
principal
]
of
[
[
ORIGIN1
PRINCIPAL1
]
[
ORIGIN3
PRINCIPAL3
]
]
)
{
for
(
let
scheme
of
TEST_PROTOS
)
{
info
(
"
Testing
with
origin
"
+
origin
)
;
info
(
"
testing
with
principal
of
origin
"
+
principal
.
origin
)
;
info
(
"
testing
with
protocol
"
+
scheme
)
;
Services
.
perms
.
addFromPrincipal
(
principal
getSkipProtoDialogPermissionKey
(
"
foobar
"
)
Services
.
perms
.
ALLOW_ACTION
)
;
await
BrowserTestUtils
.
withNewTab
(
origin
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
false
chooserIsNext
:
true
actionCheckbox
:
true
actionConfirm
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
true
}
}
)
;
}
)
;
testPermission
(
principal
scheme
true
)
;
testPermission
(
PRINCIPAL2
scheme
false
)
;
testAlwaysAsk
(
scheme
true
)
;
await
BrowserTestUtils
.
withNewTab
(
origin
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN2
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
false
chooserIsNext
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
Services
.
perms
.
removeAll
(
)
;
}
}
}
)
;
add_task
(
async
function
test_permission_application_set
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
updateAlwaysAsk
(
scheme
false
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
true
chooserIsNext
:
false
actionChangeApp
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
true
}
}
)
;
}
)
;
updateAlwaysAsk
(
scheme
true
)
;
}
)
;
add_task
(
async
function
test_permission_system_principal
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
false
hasChangeApp
:
false
chooserIsNext
:
true
actionChangeApp
:
false
}
triggerLoad
:
useTriggeringPrincipal
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_permission_system_principal_have_default
(
)
{
let
scheme
=
getSystemProtocol
(
)
;
if
(
!
scheme
)
{
return
;
}
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
false
hasChangeApp
:
false
chooserIsNext
:
false
actionChangeApp
:
false
}
triggerLoad
:
useTriggeringPrincipal
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_app_and_permission_set
(
)
{
let
scheme
=
TEST_PROTOS
[
1
]
;
updateAlwaysAsk
(
scheme
false
)
;
Services
.
perms
.
addFromPrincipal
(
PRINCIPAL2
getSkipProtoDialogPermissionKey
(
scheme
)
Services
.
perms
.
ALLOW_ACTION
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN2
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
)
;
}
)
;
Services
.
perms
.
removeAll
(
)
;
updateAlwaysAsk
(
scheme
true
)
;
}
)
;
add_task
(
async
function
test_change_app_checkbox_cancel
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
chooserIsNext
:
true
hasChangeApp
:
false
actionConfirm
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
testAlwaysAsk
(
scheme
true
)
;
}
)
;
add_task
(
async
function
test_null_principal
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
(
)
=
>
{
let
uri
=
{
scheme
}
:
/
/
test
;
ContentTask
.
spawn
(
browser
{
uri
}
args
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
frame
.
src
=
data
:
text
/
html
<
script
>
location
.
href
=
"
{
args
.
uri
}
"
<
/
script
>
;
content
.
document
.
body
.
appendChild
(
frame
)
;
}
)
;
}
permDialogOptions
:
{
hasCheckbox
:
false
chooserIsNext
:
true
hasChangeApp
:
false
actionConfirm
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_no_principal
(
)
{
let
scheme
=
TEST_PROTOS
[
1
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
(
)
=
>
{
let
uri
=
{
scheme
}
:
/
/
test
;
let
contentDispatchChooser
=
Cc
[
"
mozilla
.
org
/
content
-
dispatch
-
chooser
;
1
"
]
.
createInstance
(
Ci
.
nsIContentDispatchChooser
)
;
let
handler
=
HandlerServiceTestUtils
.
getHandlerInfo
(
scheme
)
;
contentDispatchChooser
.
handleURI
(
handler
Services
.
io
.
newURI
(
uri
)
null
browser
.
browsingContext
)
;
}
permDialogOptions
:
{
hasCheckbox
:
false
chooserIsNext
:
true
hasChangeApp
:
false
actionConfirm
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_non_standard_protocol
(
)
{
let
scheme
=
getSystemProtocol
(
)
;
if
(
!
scheme
)
{
return
;
}
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
true
chooserIsNext
:
false
actionChangeApp
:
false
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_extension_content_script_permission
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
let
testExtension
;
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
async
(
)
=
>
{
let
uri
=
{
scheme
}
:
/
/
test
;
const
EXTENSION_DATA
=
{
manifest
:
{
content_scripts
:
[
{
matches
:
[
browser
.
currentURI
.
spec
]
js
:
[
"
navigate
.
js
"
]
}
]
browser_specific_settings
:
{
gecko
:
{
id
:
"
allowed
mochi
.
test
"
}
}
}
files
:
{
"
navigate
.
js
"
:
window
.
location
.
href
=
"
{
uri
}
"
;
}
useAddonManager
:
"
permanent
"
}
;
testExtension
=
ExtensionTestUtils
.
loadExtension
(
EXTENSION_DATA
)
;
await
testExtension
.
startup
(
)
;
}
permDialogOptions
:
{
hasCheckbox
:
true
chooserIsNext
:
true
hasChangeApp
:
false
actionCheckbox
:
true
actionConfirm
:
true
checkContents
:
dialogEl
=
>
{
let
description
=
dialogEl
.
querySelector
(
"
#
description
"
)
;
let
{
id
args
}
=
description
.
ownerDocument
.
l10n
.
getAttributes
(
description
)
;
is
(
id
"
permission
-
dialog
-
description
-
extension
"
"
Should
be
using
the
correct
string
.
"
)
;
is
(
args
.
extension
"
Generated
extension
"
"
Should
have
the
correct
extension
name
.
"
)
;
}
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
let
extensionPrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
Services
.
io
.
newURI
(
moz
-
extension
:
/
/
{
testExtension
.
uuid
}
/
)
{
}
)
;
let
extensionPrivatePrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
Services
.
io
.
newURI
(
moz
-
extension
:
/
/
{
testExtension
.
uuid
}
/
)
{
privateBrowsingId
:
1
}
)
;
let
key
=
getSkipProtoDialogPermissionKey
(
scheme
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
extensionPrincipal
key
)
Services
.
perms
.
ALLOW_ACTION
"
Should
have
permanently
allowed
the
extension
"
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
extensionPrivatePrincipal
key
)
Services
.
perms
.
UNKNOWN_ACTION
"
Should
not
have
changed
the
private
principal
permission
"
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
PRINCIPAL1
key
)
Services
.
perms
.
UNKNOWN_ACTION
"
Should
not
have
allowed
the
page
"
)
;
await
testExtension
.
unload
(
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
extensionPrincipal
key
)
Services
.
perms
.
UNKNOWN_ACTION
"
Should
have
cleared
the
extension
'
s
normal
principal
permission
"
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
extensionPrivatePrincipal
key
)
Services
.
perms
.
UNKNOWN_ACTION
"
Should
have
cleared
the
private
browsing
principal
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_extension_private_content_script_permission
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
win
.
gBrowser
url
:
ORIGIN1
}
async
browser
=
>
{
let
testExtension
;
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
async
(
)
=
>
{
let
uri
=
{
scheme
}
:
/
/
test
;
const
EXTENSION_DATA
=
{
manifest
:
{
content_scripts
:
[
{
matches
:
[
browser
.
currentURI
.
spec
]
js
:
[
"
navigate
.
js
"
]
}
]
browser_specific_settings
:
{
gecko
:
{
id
:
"
allowed
mochi
.
test
"
}
}
}
files
:
{
"
navigate
.
js
"
:
window
.
location
.
href
=
"
{
uri
}
"
;
}
useAddonManager
:
"
permanent
"
}
;
testExtension
=
ExtensionTestUtils
.
loadExtension
(
EXTENSION_DATA
)
;
await
testExtension
.
startup
(
)
;
let
perms
=
{
permissions
:
[
"
internal
:
privateBrowsingAllowed
"
]
origins
:
[
]
}
;
await
ExtensionPermissions
.
add
(
"
allowed
mochi
.
test
"
perms
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
"
allowed
mochi
.
test
"
)
;
await
addon
.
reload
(
)
;
}
permDialogOptions
:
{
hasCheckbox
:
true
chooserIsNext
:
true
hasChangeApp
:
false
actionCheckbox
:
true
actionConfirm
:
true
checkContents
:
dialogEl
=
>
{
let
description
=
dialogEl
.
querySelector
(
"
#
description
"
)
;
let
{
id
args
}
=
description
.
ownerDocument
.
l10n
.
getAttributes
(
description
)
;
is
(
id
"
permission
-
dialog
-
description
-
extension
"
"
Should
be
using
the
correct
string
.
"
)
;
is
(
args
.
extension
"
Generated
extension
"
"
Should
have
the
correct
extension
name
.
"
)
;
}
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
let
extensionPrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
Services
.
io
.
newURI
(
moz
-
extension
:
/
/
{
testExtension
.
uuid
}
/
)
{
}
)
;
let
extensionPrivatePrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
Services
.
io
.
newURI
(
moz
-
extension
:
/
/
{
testExtension
.
uuid
}
/
)
{
privateBrowsingId
:
1
}
)
;
let
key
=
getSkipProtoDialogPermissionKey
(
scheme
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
extensionPrincipal
key
)
Services
.
perms
.
UNKNOWN_ACTION
"
Should
not
have
changed
the
extension
'
s
normal
principal
permission
"
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
extensionPrivatePrincipal
key
)
Services
.
perms
.
ALLOW_ACTION
"
Should
have
allowed
the
private
browsing
principal
"
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
PRINCIPAL1
key
)
Services
.
perms
.
UNKNOWN_ACTION
"
Should
not
have
allowed
the
page
"
)
;
await
testExtension
.
unload
(
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
extensionPrincipal
key
)
Services
.
perms
.
UNKNOWN_ACTION
"
Should
have
cleared
the
extension
'
s
normal
principal
permission
"
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
extensionPrivatePrincipal
key
)
Services
.
perms
.
UNKNOWN_ACTION
"
Should
have
cleared
the
private
browsing
principal
"
)
;
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_extension_allowed_content
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
let
testExtension
;
let
key
=
getSkipProtoDialogPermissionKey
(
scheme
)
;
Services
.
perms
.
addFromPrincipal
(
PRINCIPAL1
key
Services
.
perms
.
ALLOW_ACTION
Services
.
perms
.
EXPIRE_NEVER
)
;
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
async
(
)
=
>
{
let
uri
=
{
scheme
}
:
/
/
test
;
const
EXTENSION_DATA
=
{
manifest
:
{
content_scripts
:
[
{
matches
:
[
browser
.
currentURI
.
spec
]
js
:
[
"
navigate
.
js
"
]
}
]
}
files
:
{
"
navigate
.
js
"
:
window
.
location
.
href
=
"
{
uri
}
"
;
}
}
;
testExtension
=
ExtensionTestUtils
.
loadExtension
(
EXTENSION_DATA
)
;
await
testExtension
.
startup
(
)
;
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
let
extensionPrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
Services
.
io
.
newURI
(
moz
-
extension
:
/
/
{
testExtension
.
uuid
}
/
)
{
}
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
extensionPrincipal
key
)
Services
.
perms
.
UNKNOWN_ACTION
"
Should
not
have
permanently
allowed
the
extension
"
)
;
await
testExtension
.
unload
(
)
;
Services
.
perms
.
removeFromPrincipal
(
PRINCIPAL1
key
)
;
}
)
;
}
)
;
add_task
(
async
function
test_extension_allowed_extension
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
let
testExtension
;
let
key
=
getSkipProtoDialogPermissionKey
(
scheme
)
;
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
async
(
)
=
>
{
const
EXTENSION_DATA
=
{
manifest
:
{
permissions
:
[
{
ORIGIN1
}
/
*
]
}
background
(
)
{
browser
.
test
.
onMessage
.
addListener
(
async
(
msg
uri
)
=
>
{
switch
(
msg
)
{
case
"
engage
"
:
browser
.
tabs
.
executeScript
(
{
code
:
window
.
location
.
href
=
"
{
uri
}
"
;
}
)
;
break
;
default
:
browser
.
test
.
fail
(
Unexpected
message
received
:
{
msg
}
)
;
}
}
)
;
}
}
;
testExtension
=
ExtensionTestUtils
.
loadExtension
(
EXTENSION_DATA
)
;
await
testExtension
.
startup
(
)
;
let
extensionPrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
Services
.
io
.
newURI
(
moz
-
extension
:
/
/
{
testExtension
.
uuid
}
/
)
{
}
)
;
Services
.
perms
.
addFromPrincipal
(
extensionPrincipal
key
Services
.
perms
.
ALLOW_ACTION
Services
.
perms
.
EXPIRE_NEVER
)
;
testExtension
.
sendMessage
(
"
engage
"
{
scheme
}
:
/
/
test
)
;
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
await
testExtension
.
unload
(
)
;
Services
.
perms
.
removeFromPrincipal
(
PRINCIPAL1
key
)
;
}
)
;
}
)
;
add_task
(
async
function
test_extension_principal
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
let
testExtension
;
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
async
(
)
=
>
{
const
EXTENSION_DATA
=
{
background
(
)
{
browser
.
test
.
onMessage
.
addListener
(
async
(
msg
url
)
=
>
{
switch
(
msg
)
{
case
"
engage
"
:
browser
.
tabs
.
update
(
{
url
}
)
;
break
;
default
:
browser
.
test
.
fail
(
Unexpected
message
received
:
{
msg
}
)
;
}
}
)
;
}
}
;
testExtension
=
ExtensionTestUtils
.
loadExtension
(
EXTENSION_DATA
)
;
await
testExtension
.
startup
(
)
;
testExtension
.
sendMessage
(
"
engage
"
{
scheme
}
:
/
/
test
)
;
}
permDialogOptions
:
{
hasCheckbox
:
true
chooserIsNext
:
true
hasChangeApp
:
false
actionCheckbox
:
true
actionConfirm
:
true
checkContents
:
dialogEl
=
>
{
let
description
=
dialogEl
.
querySelector
(
"
#
description
"
)
;
let
{
id
args
}
=
description
.
ownerDocument
.
l10n
.
getAttributes
(
description
)
;
is
(
id
"
permission
-
dialog
-
description
-
extension
"
"
Should
be
using
the
correct
string
.
"
)
;
is
(
args
.
extension
"
Generated
extension
"
"
Should
have
the
correct
extension
name
.
"
)
;
}
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
let
extensionPrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
Services
.
io
.
newURI
(
moz
-
extension
:
/
/
{
testExtension
.
uuid
}
/
)
{
}
)
;
let
key
=
getSkipProtoDialogPermissionKey
(
scheme
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
extensionPrincipal
key
)
Services
.
perms
.
ALLOW_ACTION
"
Should
have
permanently
allowed
the
extension
"
)
;
is
(
Services
.
perms
.
testPermissionFromPrincipal
(
PRINCIPAL1
key
)
Services
.
perms
.
UNKNOWN_ACTION
"
Should
not
have
allowed
the
page
"
)
;
await
testExtension
.
unload
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_redirect_principal
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
useServerRedirect
(
"
location
"
)
permDialogOptions
:
{
checkboxOrigin
:
ORIGIN1
chooserIsNext
:
true
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_redirect_principal_refresh_header
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
useServerRedirect
(
"
refresh
"
)
permDialogOptions
:
{
checkboxOrigin
:
ORIGIN1
chooserIsNext
:
true
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_redirect_principal_meta
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
useServerRedirect
(
"
meta
-
refresh
"
)
permDialogOptions
:
{
checkboxOrigin
:
ORIGIN1
chooserIsNext
:
true
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_redirect_principal_js
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
(
)
=
>
{
let
uri
=
{
scheme
}
:
/
/
test
;
let
innerParams
=
new
URLSearchParams
(
)
;
innerParams
.
set
(
"
uri
"
uri
)
;
let
params
=
new
URLSearchParams
(
)
;
params
.
set
(
"
uri
"
"
https
:
/
/
example
.
com
/
"
+
ROOT_PATH
+
"
script_redirect
.
html
?
"
+
innerParams
.
toString
(
)
)
;
uri
=
"
https
:
/
/
example
.
org
/
"
+
ROOT_PATH
+
"
script_redirect
.
html
?
"
+
params
.
toString
(
)
;
BrowserTestUtils
.
startLoadingURIString
(
browser
uri
)
;
}
permDialogOptions
:
{
checkboxOrigin
:
ORIGIN1
chooserIsNext
:
true
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_redirect_principal_links
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
triggerLoad
:
async
(
)
=
>
{
let
uri
=
{
scheme
}
:
/
/
test
;
let
params
=
new
URLSearchParams
(
)
;
params
.
set
(
"
uri
"
uri
)
;
uri
=
"
https
:
/
/
example
.
com
/
"
+
ROOT_PATH
+
"
redirect_helper
.
sjs
?
"
+
params
.
toString
(
)
;
await
ContentTask
.
spawn
(
browser
{
uri
}
args
=
>
{
let
textLink
=
content
.
document
.
createElement
(
"
a
"
)
;
textLink
.
href
=
args
.
uri
;
textLink
.
textContent
=
"
click
me
"
;
content
.
document
.
body
.
appendChild
(
textLink
)
;
textLink
.
click
(
)
;
}
)
;
}
permDialogOptions
:
{
checkboxOrigin
:
ORIGIN1
chooserIsNext
:
true
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_unloaded_iframe
(
)
{
let
scheme
=
TEST_PROTOS
[
0
]
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
scheme
{
triggerLoad
(
)
{
let
uri
=
{
scheme
}
:
/
/
test
;
return
ContentTask
.
spawn
(
browser
{
uri
}
args
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
frame
.
setAttribute
(
"
loading
"
"
lazy
"
)
;
frame
.
setAttribute
(
"
src
"
"
about
:
blank
"
)
;
frame
.
setAttribute
(
"
style
"
"
margin
-
top
:
10000px
;
"
)
;
frame
.
setAttribute
(
"
name
"
"
yo
"
)
;
content
.
document
.
body
.
append
(
frame
)
;
content
.
open
(
args
.
uri
"
yo
"
)
;
frame
.
remove
(
)
;
}
)
;
}
permDialogOptions
:
{
checkboxOrigin
:
ORIGIN1
chooserIsNext
:
true
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_prompt_warning_for_wallet_scheme
(
)
{
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
WALLET_PROTO
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
false
chooserIsNext
:
true
actionConfirm
:
true
hasWalletWarning
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
true
}
}
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
WALLET_PROTO
{
triggerLoad
:
(
)
=
>
{
let
uri
=
{
WALLET_PROTO
}
:
/
/
test
;
ContentTask
.
spawn
(
browser
{
uri
}
args
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
frame
.
src
=
data
:
text
/
html
<
script
>
location
.
href
=
"
{
args
.
uri
}
"
<
/
script
>
;
content
.
document
.
body
.
appendChild
(
frame
)
;
}
)
;
}
permDialogOptions
:
{
hasCheckbox
:
false
chooserIsNext
:
true
hasChangeApp
:
false
actionConfirm
:
true
hasWalletWarning
:
true
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
false
}
}
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
WALLET_PROTO
{
permDialogOptions
:
{
hasCheckbox
:
false
hasChangeApp
:
false
chooserIsNext
:
true
actionChangeApp
:
false
hasWalletWarning
:
true
}
triggerLoad
:
useTriggeringPrincipal
(
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
}
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
ORIGIN1
async
browser
=
>
{
await
testOpenProto
(
browser
TEST_PROTOS
[
0
]
{
permDialogOptions
:
{
hasCheckbox
:
true
hasChangeApp
:
false
chooserIsNext
:
true
actionConfirm
:
true
hasWalletWarning
:
false
}
chooserDialogOptions
:
{
hasCheckbox
:
true
actionConfirm
:
true
}
}
)
;
}
)
;
}
)
;
