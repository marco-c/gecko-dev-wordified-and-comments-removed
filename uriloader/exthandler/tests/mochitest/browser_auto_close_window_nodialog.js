const
{
ComponentUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ComponentUtils
.
sys
.
mjs
"
)
;
const
ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
com
"
)
;
const
PAGE_URL
=
ROOT
+
"
download_page
.
html
"
;
const
SJS_URL
=
ROOT
+
"
download
.
sjs
"
;
const
HELPERAPP_DIALOG_CONTRACT_ID
=
"
mozilla
.
org
/
helperapplauncherdialog
;
1
"
;
const
HELPERAPP_DIALOG_CID
=
Components
.
ID
(
Cc
[
HELPERAPP_DIALOG_CONTRACT_ID
]
.
number
)
;
const
MOCK_HELPERAPP_DIALOG_CID
=
Components
.
ID
(
"
{
2f372b6f
-
56c9
-
46d5
-
af0d
-
9f09bb69860c
}
"
)
;
let
registrar
=
Components
.
manager
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
let
curSaveResolve
=
null
;
function
HelperAppLauncherDialog
(
)
{
}
HelperAppLauncherDialog
.
prototype
=
{
show
(
aLauncher
)
{
ok
(
false
"
Shouldn
'
t
be
showing
the
helper
app
dialog
"
)
;
executeSoon
(
(
)
=
>
{
aLauncher
.
cancel
(
Cr
.
NS_ERROR_ABORT
)
;
}
)
;
}
promptForSaveToFileAsync
(
aLauncher
aWindowContext
)
{
ok
(
true
"
Shouldn
'
t
be
showing
the
helper
app
dialog
"
)
;
curSaveResolve
(
aWindowContext
)
;
executeSoon
(
(
)
=
>
{
aLauncher
.
cancel
(
Cr
.
NS_ERROR_ABORT
)
;
}
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIHelperAppLauncherDialog
"
]
)
}
;
function
promiseSave
(
)
{
return
new
Promise
(
resolve
=
>
{
curSaveResolve
=
resolve
;
}
)
;
}
let
mockHelperAppService
;
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
test
.
wait300msAfterTabSwitch
"
true
]
]
}
)
;
mockHelperAppService
=
ComponentUtils
.
generateSingletonFactory
(
HelperAppLauncherDialog
)
;
registrar
.
registerFactory
(
MOCK_HELPERAPP_DIALOG_CID
"
"
HELPERAPP_DIALOG_CONTRACT_ID
mockHelperAppService
)
;
const
HandlerService
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
const
MIMEService
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
;
const
mimeInfo
=
MIMEService
.
getFromTypeAndExtension
(
"
application
/
octet
-
stream
"
"
bin
"
)
;
mimeInfo
.
alwaysAskBeforeHandling
=
false
;
mimeInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
saveToDisk
;
HandlerService
.
store
(
mimeInfo
)
;
registerCleanupFunction
(
(
)
=
>
{
HandlerService
.
remove
(
mimeInfo
)
;
}
)
;
}
)
;
add_task
(
async
function
simple_navigation
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
PAGE_URL
}
async
function
(
browser
)
{
let
saveHappened
=
promiseSave
(
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
regular_load
"
{
}
browser
)
;
let
windowContext
=
await
saveHappened
;
is
(
windowContext
browser
.
ownerGlobal
"
got
the
right
windowContext
"
)
;
}
)
;
}
)
;
async
function
testNewTab
(
browser
)
{
let
saveHappened
=
promiseSave
(
)
;
let
tabOpened
=
BrowserTestUtils
.
waitForEvent
(
gBrowser
.
tabContainer
"
TabOpen
"
)
.
then
(
event
=
>
{
return
[
event
.
target
BrowserTestUtils
.
waitForTabClosing
(
event
.
target
)
]
;
}
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
target_blank
"
{
}
browser
)
;
let
windowContext
=
await
saveHappened
;
is
(
windowContext
browser
.
ownerGlobal
"
got
the
right
windowContext
"
)
;
let
[
tab
closingPromise
]
=
await
tabOpened
;
await
closingPromise
;
is
(
tab
.
linkedBrowser
null
"
tab
was
opened
and
closed
"
)
;
}
add_task
(
async
function
target_blank
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
PAGE_URL
}
async
function
(
browser
)
{
await
testNewTab
(
browser
)
;
}
)
;
}
)
;
add_task
(
async
function
target_blank_no_opener
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
PAGE_URL
}
async
function
(
browser
)
{
let
saveHappened
=
promiseSave
(
)
;
let
tabOpened
=
BrowserTestUtils
.
waitForEvent
(
gBrowser
.
tabContainer
"
TabOpen
"
)
.
then
(
event
=
>
{
return
[
event
.
target
BrowserTestUtils
.
waitForTabClosing
(
event
.
target
)
]
;
}
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
target_blank_no_opener
"
{
}
browser
)
;
let
windowContext
=
await
saveHappened
;
is
(
windowContext
browser
.
ownerGlobal
"
got
the
right
windowContext
"
)
;
let
[
tab
closingPromise
]
=
await
tabOpened
;
await
closingPromise
;
is
(
tab
.
linkedBrowser
null
"
tab
was
opened
and
closed
"
)
;
}
)
;
}
)
;
add_task
(
async
function
open_in_new_tab_no_opener
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
PAGE_URL
}
async
function
(
browser
)
{
let
saveHappened
=
promiseSave
(
)
;
let
tabOpened
=
BrowserTestUtils
.
waitForEvent
(
gBrowser
.
tabContainer
"
TabOpen
"
)
.
then
(
event
=
>
{
return
[
event
.
target
BrowserTestUtils
.
waitForTabClosing
(
event
.
target
)
]
;
}
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
open_in_new_tab_no_opener
"
{
}
browser
)
;
let
windowContext
=
await
saveHappened
;
is
(
windowContext
browser
.
ownerGlobal
"
got
the
right
windowContext
"
)
;
let
[
tab
closingPromise
]
=
await
tabOpened
;
await
closingPromise
;
is
(
tab
.
linkedBrowser
null
"
tab
was
opened
and
closed
"
)
;
}
)
;
}
)
;
add_task
(
async
function
new_window
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
PAGE_URL
}
async
function
(
browser
)
{
let
saveHappened
=
promiseSave
(
)
;
let
windowOpened
=
BrowserTestUtils
.
waitForNewWindow
(
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
new_window
"
{
}
browser
)
;
let
win
=
await
windowOpened
;
fetch
(
SJS_URL
+
"
?
finish
"
)
;
let
windowContext
=
await
saveHappened
;
is
(
windowContext
browser
.
ownerGlobal
"
got
the
right
windowContext
"
)
;
await
BrowserTestUtils
.
domWindowClosed
(
win
)
;
ok
(
win
.
closed
"
window
was
opened
and
closed
"
)
;
is
(
await
fetch
(
SJS_URL
+
"
?
reset
"
)
.
then
(
r
=
>
r
.
text
(
)
)
"
OK
"
"
Test
reseted
"
)
;
}
)
;
}
)
;
add_task
(
async
function
new_window_no_opener
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
PAGE_URL
}
async
function
(
browser
)
{
let
saveHappened
=
promiseSave
(
)
;
let
windowOpened
=
BrowserTestUtils
.
waitForNewWindow
(
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
new_window_no_opener
"
{
}
browser
)
;
let
win
=
await
windowOpened
;
fetch
(
SJS_URL
+
"
?
finish
"
)
;
await
saveHappened
;
await
BrowserTestUtils
.
domWindowClosed
(
win
)
;
ok
(
win
.
closed
"
window
was
opened
and
closed
"
)
;
is
(
await
fetch
(
SJS_URL
+
"
?
reset
"
)
.
then
(
r
=
>
r
.
text
(
)
)
"
OK
"
"
Test
reseted
"
)
;
}
)
;
}
)
;
add_task
(
async
function
nested_window_opens
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
PAGE_URL
}
async
function
(
outerBrowser
)
{
let
secondTabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
{
PAGE_URL
}
?
newwin
true
)
;
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
open_in_new_tab
"
{
}
outerBrowser
)
;
let
secondTab
=
await
secondTabPromise
;
let
nestedBrowser
=
secondTab
.
linkedBrowser
;
await
SpecialPowers
.
spawn
(
nestedBrowser
[
]
function
(
)
{
ok
(
content
.
opener
"
this
window
has
an
opener
"
)
;
}
)
;
await
testNewTab
(
nestedBrowser
)
;
isnot
(
secondTab
.
linkedBrowser
null
"
the
page
that
triggered
the
download
is
still
open
"
)
;
BrowserTestUtils
.
removeTab
(
secondTab
)
;
}
)
;
}
)
;
add_task
(
async
function
cleanup
(
)
{
registrar
.
unregisterFactory
(
MOCK_HELPERAPP_DIALOG_CID
mockHelperAppService
)
;
registrar
.
registerFactory
(
HELPERAPP_DIALOG_CID
"
"
HELPERAPP_DIALOG_CONTRACT_ID
null
)
;
}
)
;
