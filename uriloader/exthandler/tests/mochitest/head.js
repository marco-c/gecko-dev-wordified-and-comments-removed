var
{
FileUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
var
{
HandlerServiceTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
HandlerServiceTestUtils
.
jsm
"
)
;
var
gMimeSvc
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
;
var
gHandlerSvc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
function
createMockedHandlerApp
(
)
{
let
mockedExecutable
=
FileUtils
.
getFile
(
"
TmpD
"
[
"
mockedExecutable
"
]
)
;
if
(
!
mockedExecutable
.
exists
(
)
)
{
mockedExecutable
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0o755
)
;
}
let
mockedHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
mockedHandlerApp
.
executable
=
mockedExecutable
;
mockedHandlerApp
.
detailedDescription
=
"
Mocked
handler
app
"
;
registerCleanupFunction
(
function
(
)
{
if
(
mockedExecutable
.
exists
(
)
)
{
mockedExecutable
.
remove
(
true
)
;
}
}
)
;
return
mockedHandlerApp
;
}
function
createMockedObjects
(
createHandlerApp
)
{
let
internalMockedMIME
=
gMimeSvc
.
getFromTypeAndExtension
(
"
text
/
x
-
test
-
handler
"
null
)
;
internalMockedMIME
.
alwaysAskBeforeHandling
=
true
;
internalMockedMIME
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
internalMockedMIME
.
appendExtension
(
"
abc
"
)
;
if
(
createHandlerApp
)
{
let
mockedHandlerApp
=
createMockedHandlerApp
(
)
;
internalMockedMIME
.
description
=
mockedHandlerApp
.
detailedDescription
;
internalMockedMIME
.
possibleApplicationHandlers
.
appendElement
(
mockedHandlerApp
)
;
internalMockedMIME
.
preferredApplicationHandler
=
mockedHandlerApp
;
}
let
mockedMIME
=
new
Proxy
(
internalMockedMIME
{
get
(
target
property
)
{
switch
(
property
)
{
case
"
hasDefaultHandler
"
:
return
true
;
case
"
defaultDescription
"
:
return
"
Default
description
"
;
default
:
return
target
[
property
]
;
}
}
}
)
;
let
mockedLauncher
=
{
MIMEInfo
:
mockedMIME
source
:
Services
.
io
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
"
)
suggestedFileName
:
"
test_download_dialog
.
abc
"
targetFileIsExecutable
:
false
saveToDisk
(
)
{
}
cancel
(
)
{
}
setDownloadToLaunch
(
)
{
}
setWebProgressListener
(
)
{
}
saveDestinationAvailable
(
)
{
}
contentLength
:
42
targetFile
:
null
timeDownloadStarted
:
Date
.
now
(
)
*
1000
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICancelable
"
"
nsIHelperAppLauncher
"
]
)
}
;
registerCleanupFunction
(
function
(
)
{
let
mockHandlerInfo
=
gMimeSvc
.
getFromTypeAndExtension
(
"
text
/
x
-
test
-
handler
"
null
)
;
if
(
gHandlerSvc
.
exists
(
mockHandlerInfo
)
)
{
gHandlerSvc
.
remove
(
mockHandlerInfo
)
;
}
}
)
;
return
mockedLauncher
;
}
function
createTemporarySaveDirectory
(
)
{
var
saveDir
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
saveDir
.
append
(
"
testsavedir
"
)
;
if
(
!
saveDir
.
exists
(
)
)
{
saveDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
return
saveDir
;
}
async
function
openHelperAppDialog
(
launcher
)
{
let
helperAppDialog
=
Cc
[
"
mozilla
.
org
/
helperapplauncherdialog
;
1
"
]
.
createInstance
(
Ci
.
nsIHelperAppLauncherDialog
)
;
let
helperAppDialogShownPromise
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
)
;
try
{
helperAppDialog
.
show
(
launcher
window
"
foopy
"
)
;
}
catch
(
ex
)
{
ok
(
false
"
Trying
to
show
unknownContentType
.
xhtml
failed
with
exception
:
"
+
ex
)
;
Cu
.
reportError
(
ex
)
;
}
let
dlg
=
await
helperAppDialogShownPromise
;
is
(
dlg
.
location
.
href
"
chrome
:
/
/
mozapps
/
content
/
downloads
/
unknownContentType
.
xhtml
"
"
Got
correct
dialog
"
)
;
return
dlg
;
}
async
function
waitForSubDialog
(
browser
url
state
)
{
let
eventStr
=
state
?
"
dialogopen
"
:
"
dialogclose
"
;
let
eventTarget
;
if
(
browser
.
tabContainer
)
{
eventTarget
=
browser
.
tabContainer
.
ownerDocument
.
documentElement
;
}
else
{
let
tabDialogBox
=
browser
.
ownerGlobal
.
gBrowser
.
getTabDialogBox
(
browser
)
;
eventTarget
=
tabDialogBox
.
getTabDialogManager
(
)
.
_dialogStack
;
}
let
checkFn
;
if
(
state
)
{
checkFn
=
dialogEvent
=
>
dialogEvent
.
detail
.
dialog
?
.
_openedURL
=
=
url
;
}
let
event
=
await
BrowserTestUtils
.
waitForEvent
(
eventTarget
eventStr
true
checkFn
)
;
let
{
dialog
}
=
event
.
detail
;
if
(
!
state
)
{
await
dialog
.
_closingPromise
;
}
return
event
.
detail
.
dialog
;
}
async
function
waitForProtocolPermissionDialog
(
browser
state
)
{
return
waitForSubDialog
(
browser
"
chrome
:
/
/
mozapps
/
content
/
handling
/
permissionDialog
.
xhtml
"
state
)
;
}
async
function
waitForProtocolAppChooserDialog
(
browser
state
)
{
return
waitForSubDialog
(
browser
"
chrome
:
/
/
mozapps
/
content
/
handling
/
appChooser
.
xhtml
"
state
)
;
}
async
function
promiseDownloadFinished
(
list
stopFromOpening
)
{
return
new
Promise
(
resolve
=
>
{
list
.
addView
(
{
onDownloadChanged
(
download
)
{
if
(
stopFromOpening
)
{
download
.
launchWhenSucceeded
=
false
;
}
info
(
"
Download
changed
!
"
)
;
if
(
download
.
succeeded
|
|
download
.
error
)
{
info
(
"
Download
succeeded
or
errored
"
)
;
list
.
removeView
(
this
)
;
resolve
(
download
)
;
}
}
}
)
;
}
)
;
}
function
setupMailHandler
(
)
{
let
mailHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
mailto
"
)
;
let
gOldMailHandlers
=
[
]
;
let
handlers
=
mailHandlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
handlers
.
Count
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
try
{
let
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
gOldMailHandlers
.
push
(
handler
)
;
handlers
.
removeElementAt
(
i
)
;
}
catch
(
ex
)
{
}
}
let
previousHandling
=
mailHandlerInfo
.
alwaysAskBeforeHandling
;
mailHandlerInfo
.
alwaysAskBeforeHandling
=
true
;
let
dummy
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
dummy
.
name
=
"
Handler
1
"
;
dummy
.
uriTemplate
=
"
https
:
/
/
example
.
com
/
first
/
%
s
"
;
mailHandlerInfo
.
possibleApplicationHandlers
.
appendElement
(
dummy
)
;
gHandlerSvc
.
store
(
mailHandlerInfo
)
;
registerCleanupFunction
(
(
)
=
>
{
let
mailHandlers
=
mailHandlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
handlers
.
Count
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
try
{
mailHandlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
mailHandlers
.
removeElementAt
(
i
)
;
}
catch
(
ex
)
{
}
}
for
(
let
h
of
gOldMailHandlers
)
{
mailHandlers
.
appendElement
(
h
)
;
}
mailHandlerInfo
.
alwaysAskBeforeHandling
=
previousHandling
;
gHandlerSvc
.
store
(
mailHandlerInfo
)
;
}
)
;
}
let
gDownloadDir
;
async
function
setDownloadDir
(
)
{
let
tmpDir
=
PathUtils
.
join
(
PathUtils
.
tempDir
"
testsavedir
"
+
Math
.
floor
(
Math
.
random
(
)
*
2
*
*
32
)
)
;
await
IOUtils
.
makeDirectory
(
tmpDir
)
;
registerCleanupFunction
(
async
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
download
.
folderList
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
download
.
dir
"
)
;
try
{
await
IOUtils
.
remove
(
tmpDir
{
recursive
:
true
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
download
.
folderList
"
2
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
download
.
dir
"
tmpDir
)
;
return
tmpDir
;
}
add_setup
(
async
function
test_common_initialize
(
)
{
gDownloadDir
=
await
setDownloadDir
(
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
download
.
loglevel
"
"
Debug
"
)
;
registerCleanupFunction
(
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
download
.
loglevel
"
)
;
}
)
;
}
)
;
async
function
removeAllDownloads
(
)
{
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
downloads
=
await
publicList
.
getAll
(
)
;
for
(
let
download
of
downloads
)
{
await
publicList
.
remove
(
download
)
;
if
(
await
IOUtils
.
exists
(
download
.
target
.
path
)
)
{
await
download
.
finalize
(
true
)
;
}
}
}
