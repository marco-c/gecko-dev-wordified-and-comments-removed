var
{
FileUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
)
;
var
{
HandlerServiceTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
HandlerServiceTestUtils
.
sys
.
mjs
"
)
;
var
gMimeSvc
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
;
var
gHandlerSvc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
function
createMockedHandlerApp
(
)
{
let
mockedExecutable
=
new
FileUtils
.
File
(
PathUtils
.
join
(
PathUtils
.
tempDir
"
mockedExecutable
"
)
)
;
if
(
!
mockedExecutable
.
exists
(
)
)
{
mockedExecutable
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0o755
)
;
}
let
mockedHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
mockedHandlerApp
.
executable
=
mockedExecutable
;
mockedHandlerApp
.
detailedDescription
=
"
Mocked
handler
app
"
;
registerCleanupFunction
(
function
(
)
{
if
(
mockedExecutable
.
exists
(
)
)
{
mockedExecutable
.
remove
(
true
)
;
}
}
)
;
return
mockedHandlerApp
;
}
function
createMockedObjects
(
createHandlerApp
)
{
let
internalMockedMIME
=
gMimeSvc
.
getFromTypeAndExtension
(
"
text
/
x
-
test
-
handler
"
null
)
;
internalMockedMIME
.
alwaysAskBeforeHandling
=
true
;
internalMockedMIME
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
internalMockedMIME
.
appendExtension
(
"
abc
"
)
;
if
(
createHandlerApp
)
{
let
mockedHandlerApp
=
createMockedHandlerApp
(
)
;
internalMockedMIME
.
description
=
mockedHandlerApp
.
detailedDescription
;
internalMockedMIME
.
possibleApplicationHandlers
.
appendElement
(
mockedHandlerApp
)
;
internalMockedMIME
.
preferredApplicationHandler
=
mockedHandlerApp
;
}
let
mockedMIME
=
new
Proxy
(
internalMockedMIME
{
get
(
target
property
)
{
switch
(
property
)
{
case
"
hasDefaultHandler
"
:
return
true
;
case
"
defaultDescription
"
:
return
"
Default
description
"
;
default
:
return
target
[
property
]
;
}
}
}
)
;
let
mockedLauncher
=
{
MIMEInfo
:
mockedMIME
source
:
Services
.
io
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
"
)
suggestedFileName
:
"
test_download_dialog
.
abc
"
targetFileIsExecutable
:
false
saveToDisk
(
)
{
}
cancel
(
)
{
}
setDownloadToLaunch
(
)
{
}
setWebProgressListener
(
)
{
}
saveDestinationAvailable
(
)
{
}
contentLength
:
42
targetFile
:
null
timeDownloadStarted
:
Date
.
now
(
)
*
1000
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICancelable
"
"
nsIHelperAppLauncher
"
]
)
}
;
registerCleanupFunction
(
function
(
)
{
let
mockHandlerInfo
=
gMimeSvc
.
getFromTypeAndExtension
(
"
text
/
x
-
test
-
handler
"
null
)
;
if
(
gHandlerSvc
.
exists
(
mockHandlerInfo
)
)
{
gHandlerSvc
.
remove
(
mockHandlerInfo
)
;
}
}
)
;
return
mockedLauncher
;
}
function
createTemporarySaveDirectory
(
)
{
var
saveDir
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
saveDir
.
append
(
"
testsavedir
"
)
;
if
(
!
saveDir
.
exists
(
)
)
{
saveDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
return
saveDir
;
}
async
function
openHelperAppDialog
(
launcher
)
{
let
helperAppDialog
=
Cc
[
"
mozilla
.
org
/
helperapplauncherdialog
;
1
"
]
.
createInstance
(
Ci
.
nsIHelperAppLauncherDialog
)
;
let
helperAppDialogShownPromise
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
)
;
try
{
helperAppDialog
.
show
(
launcher
window
"
foopy
"
)
;
}
catch
(
ex
)
{
ok
(
false
"
Trying
to
show
unknownContentType
.
xhtml
failed
with
exception
:
"
+
ex
)
;
console
.
error
(
ex
)
;
}
let
dlg
=
await
helperAppDialogShownPromise
;
is
(
dlg
.
location
.
href
"
chrome
:
/
/
mozapps
/
content
/
downloads
/
unknownContentType
.
xhtml
"
"
Got
correct
dialog
"
)
;
return
dlg
;
}
async
function
waitForSubDialog
(
browser
url
state
)
{
let
eventStr
=
state
?
"
dialogopen
"
:
"
dialogclose
"
;
let
eventTarget
;
if
(
browser
.
tabContainer
)
{
eventTarget
=
browser
.
tabContainer
.
ownerDocument
.
documentElement
;
}
else
{
let
tabDialogBox
=
browser
.
ownerGlobal
.
gBrowser
.
getTabDialogBox
(
browser
)
;
eventTarget
=
tabDialogBox
.
getTabDialogManager
(
)
.
_dialogStack
;
}
let
checkFn
;
if
(
state
)
{
checkFn
=
dialogEvent
=
>
dialogEvent
.
detail
.
dialog
?
.
_openedURL
=
=
url
;
}
let
event
=
await
BrowserTestUtils
.
waitForEvent
(
eventTarget
eventStr
true
checkFn
)
;
let
{
dialog
}
=
event
.
detail
;
if
(
!
state
)
{
await
dialog
.
_closingPromise
;
}
return
event
.
detail
.
dialog
;
}
async
function
waitForProtocolPermissionDialog
(
browser
state
)
{
return
waitForSubDialog
(
browser
"
chrome
:
/
/
mozapps
/
content
/
handling
/
permissionDialog
.
xhtml
"
state
)
;
}
function
getDialogElementFromSubDialog
(
subDialog
)
{
let
dialogEl
=
subDialog
.
_frame
.
contentDocument
.
querySelector
(
"
dialog
"
)
;
ok
(
dialogEl
"
SubDialog
should
have
dialog
element
"
)
;
return
dialogEl
;
}
async
function
acceptNextProtocolPermissionDialog
(
browser
)
{
let
dialog
=
await
waitForProtocolPermissionDialog
(
browser
true
)
;
let
dialogWindowClosePromise
=
waitForProtocolPermissionDialog
(
browser
false
)
;
let
dialogEl
=
getDialogElementFromSubDialog
(
dialog
)
;
dialogEl
.
removeAttribute
(
"
buttondisabledaccept
"
)
;
dialogEl
.
acceptDialog
(
)
;
await
dialogWindowClosePromise
;
}
async
function
waitForProtocolAppChooserDialog
(
browser
state
)
{
return
waitForSubDialog
(
browser
"
chrome
:
/
/
mozapps
/
content
/
handling
/
appChooser
.
xhtml
"
state
)
;
}
async
function
promiseDownloadFinished
(
list
stopFromOpening
)
{
return
new
Promise
(
resolve
=
>
{
list
.
addView
(
{
onDownloadChanged
(
download
)
{
if
(
stopFromOpening
)
{
download
.
launchWhenSucceeded
=
false
;
}
info
(
"
Download
changed
!
"
)
;
if
(
download
.
succeeded
|
|
download
.
error
)
{
info
(
"
Download
succeeded
or
errored
"
)
;
list
.
removeView
(
this
)
;
resolve
(
download
)
;
}
}
}
)
;
}
)
;
}
function
setupMailHandler
(
)
{
let
mailHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
mailto
"
)
;
let
gOldMailHandlers
=
[
]
;
let
handlers
=
mailHandlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
handlers
.
Count
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
try
{
let
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
gOldMailHandlers
.
push
(
handler
)
;
handlers
.
removeElementAt
(
i
)
;
}
catch
(
ex
)
{
}
}
let
previousHandling
=
mailHandlerInfo
.
alwaysAskBeforeHandling
;
mailHandlerInfo
.
alwaysAskBeforeHandling
=
true
;
let
dummy
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
dummy
.
name
=
"
Handler
1
"
;
dummy
.
uriTemplate
=
"
https
:
/
/
example
.
com
/
first
/
%
s
"
;
mailHandlerInfo
.
possibleApplicationHandlers
.
appendElement
(
dummy
)
;
gHandlerSvc
.
store
(
mailHandlerInfo
)
;
registerCleanupFunction
(
(
)
=
>
{
let
mailHandlers
=
mailHandlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
handlers
.
Count
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
try
{
mailHandlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
mailHandlers
.
removeElementAt
(
i
)
;
}
catch
(
ex
)
{
}
}
for
(
let
h
of
gOldMailHandlers
)
{
mailHandlers
.
appendElement
(
h
)
;
}
mailHandlerInfo
.
alwaysAskBeforeHandling
=
previousHandling
;
gHandlerSvc
.
store
(
mailHandlerInfo
)
;
}
)
;
}
let
gDownloadDir
;
async
function
setDownloadDir
(
)
{
let
tmpDir
=
PathUtils
.
join
(
PathUtils
.
tempDir
"
testsavedir
"
+
Math
.
floor
(
Math
.
random
(
)
*
2
*
*
32
)
)
;
await
IOUtils
.
makeDirectory
(
tmpDir
)
;
registerCleanupFunction
(
async
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
download
.
folderList
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
download
.
dir
"
)
;
try
{
await
IOUtils
.
remove
(
tmpDir
{
recursive
:
true
}
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
download
.
folderList
"
2
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
download
.
dir
"
tmpDir
)
;
return
tmpDir
;
}
add_setup
(
async
function
test_common_initialize
(
)
{
gDownloadDir
=
await
setDownloadDir
(
)
;
Services
.
prefs
.
setCharPref
(
"
toolkit
.
download
.
loglevel
"
"
Debug
"
)
;
registerCleanupFunction
(
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
toolkit
.
download
.
loglevel
"
)
;
}
)
;
}
)
;
async
function
removeAllDownloads
(
)
{
let
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
downloads
=
await
publicList
.
getAll
(
)
;
for
(
let
download
of
downloads
)
{
await
publicList
.
remove
(
download
)
;
if
(
await
IOUtils
.
exists
(
download
.
target
.
path
)
)
{
await
download
.
finalize
(
true
)
;
}
}
}
const
EXT_PROTO_URI_MAILTO
=
"
mailto
:
test
example
.
com
"
;
async
function
navigateExternalProtoFromIframe
(
browser
sandboxAttr
useCSPSandbox
=
false
triggerMethod
=
"
trustedClick
"
)
{
if
(
!
[
"
trustedClick
"
"
untrustedClick
"
"
trustedLocationAPI
"
"
untrustedLocationAPI
"
"
frameSrc
"
"
frameSrcRedirect
"
]
.
includes
(
triggerMethod
)
)
{
throw
new
Error
(
"
Invalid
trigger
method
"
+
triggerMethod
)
;
}
let
testPath
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
com
"
)
;
let
frameSrc
=
testPath
+
"
/
protocol_custom_sandbox_helper
.
sjs
"
;
if
(
triggerMethod
=
=
"
frameSrc
"
)
{
frameSrc
=
EXT_PROTO_URI_MAILTO
;
}
else
if
(
triggerMethod
=
=
"
frameSrcRedirect
"
)
{
let
url
=
new
URL
(
frameSrc
)
;
url
.
searchParams
.
set
(
"
redirectCustomProtocol
"
"
true
"
)
;
frameSrc
=
url
.
href
;
}
if
(
useCSPSandbox
)
{
let
url
=
new
URL
(
frameSrc
)
;
url
.
searchParams
.
set
(
"
cspSandbox
"
sandboxAttr
)
;
frameSrc
=
url
.
href
;
sandboxAttr
=
null
;
}
await
SpecialPowers
.
spawn
(
browser
[
sandboxAttr
frameSrc
EXT_PROTO_URI_MAILTO
triggerMethod
]
async
(
sandbox
src
extProtoURI
trigger
)
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
if
(
sandbox
!
=
null
)
{
frame
.
sandbox
=
sandbox
;
}
frame
.
src
=
src
;
let
useFrameSrc
=
trigger
=
=
"
frameSrc
"
|
|
trigger
=
=
"
frameSrcRedirect
"
;
let
frameLoadPromise
;
if
(
!
useFrameSrc
)
{
frameLoadPromise
=
ContentTaskUtils
.
waitForEvent
(
frame
"
load
"
false
)
;
}
content
.
document
.
body
.
appendChild
(
frame
)
;
await
frameLoadPromise
;
if
(
!
useFrameSrc
)
{
await
SpecialPowers
.
spawn
(
frame
[
extProtoURI
trigger
]
async
(
uri
trigger2
)
=
>
{
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
innerText
=
"
CLICK
ME
"
;
link
.
id
=
"
extProtoLink
"
;
content
.
document
.
body
.
appendChild
(
link
)
;
if
(
trigger2
=
=
"
trustedClick
"
|
|
trigger2
=
=
"
untrustedClick
"
)
{
link
.
href
=
uri
;
}
else
if
(
trigger2
=
=
"
trustedLocationAPI
"
|
|
trigger2
=
=
"
untrustedLocationAPI
"
)
{
link
.
setAttribute
(
"
onclick
"
location
.
href
=
'
{
uri
}
'
)
;
}
if
(
trigger2
=
=
"
untrustedClick
"
|
|
trigger2
=
=
"
untrustedLocationAPI
"
)
{
link
.
click
(
)
;
}
else
if
(
trigger2
=
=
"
trustedClick
"
|
|
trigger2
=
=
"
trustedLocationAPI
"
)
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
link
"
wait
for
link
to
be
present
"
)
;
await
EventUtils
.
synthesizeMouseAtCenter
(
link
{
}
content
)
;
}
}
)
;
}
}
)
;
}
function
waitForExtProtocolSandboxError
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
console
.
registerListener
(
function
onMessage
(
msg
)
{
let
{
message
logLevel
}
=
msg
;
if
(
logLevel
!
=
Ci
.
nsIConsoleMessage
.
error
)
{
return
;
}
if
(
!
message
.
includes
(
Blocked
navigation
to
custom
protocol
{
EXT_PROTO_URI_MAILTO
}
from
a
sandboxed
context
.
)
)
{
return
;
}
Services
.
console
.
unregisterListener
(
onMessage
)
;
resolve
(
)
;
}
)
;
}
)
;
}
function
runExtProtocolSandboxTest
(
options
)
{
let
{
blocked
sandbox
useCSPSandbox
=
false
triggerMethod
}
=
options
;
let
testPath
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
com
"
)
;
info
(
"
runSandboxTest
options
:
"
+
JSON
.
stringify
(
options
)
)
;
return
BrowserTestUtils
.
withNewTab
(
testPath
+
"
/
protocol_custom_sandbox_helper
.
sjs
"
async
browser
=
>
{
if
(
blocked
)
{
let
errorPromise
=
waitForExtProtocolSandboxError
(
)
;
await
navigateExternalProtoFromIframe
(
browser
sandbox
useCSPSandbox
triggerMethod
)
;
await
errorPromise
;
ok
(
errorPromise
"
Should
not
show
the
dialog
for
iframe
with
sandbox
"
+
sandbox
)
;
}
else
{
let
dialogWindowOpenPromise
=
waitForProtocolAppChooserDialog
(
browser
true
)
;
await
navigateExternalProtoFromIframe
(
browser
sandbox
useCSPSandbox
triggerMethod
)
;
let
dialog
=
await
dialogWindowOpenPromise
;
ok
(
dialog
"
Should
show
the
dialog
for
sandbox
"
+
sandbox
)
;
let
dialogWindowClosePromise
=
waitForProtocolAppChooserDialog
(
browser
false
)
;
dialog
.
close
(
)
;
await
dialogWindowClosePromise
;
}
}
)
;
}
function
getSystemProtocol
(
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
return
"
itunes
"
;
}
else
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
return
"
ms
-
settings
"
;
}
info
(
"
Skipping
this
test
since
there
isn
'
t
a
suitable
default
protocol
on
this
platform
"
)
;
return
null
;
}
