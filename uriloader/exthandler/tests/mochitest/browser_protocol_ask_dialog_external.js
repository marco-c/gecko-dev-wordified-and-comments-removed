"
use
strict
"
;
let
gHandlerService
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
const
TEST_PATH
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
com
"
)
;
function
initTestHandlers
(
)
{
let
handlerInfoThatAsks
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
local
-
app
-
test
"
)
;
let
appHandler
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
appHandler
.
executable
=
Services
.
dirsvc
.
get
(
"
XCurProcD
"
Ci
.
nsIFile
)
;
handlerInfoThatAsks
.
possibleApplicationHandlers
.
appendElement
(
appHandler
)
;
handlerInfoThatAsks
.
preferredApplicationHandler
=
appHandler
;
handlerInfoThatAsks
.
preferredAction
=
handlerInfoThatAsks
.
useHelperApp
;
handlerInfoThatAsks
.
alwaysAskBeforeHandling
=
false
;
gHandlerService
.
store
(
handlerInfoThatAsks
)
;
let
webHandlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
web
+
somesite
"
)
;
let
webHandler
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
webHandler
.
name
=
"
Somesite
"
;
webHandler
.
uriTemplate
=
"
https
:
/
/
example
.
com
/
handle_url
?
u
=
%
s
"
;
webHandlerInfo
.
possibleApplicationHandlers
.
appendElement
(
webHandler
)
;
webHandlerInfo
.
preferredApplicationHandler
=
webHandler
;
webHandlerInfo
.
preferredAction
=
webHandlerInfo
.
useHelperApp
;
webHandlerInfo
.
alwaysAskBeforeHandling
=
false
;
gHandlerService
.
store
(
webHandlerInfo
)
;
registerCleanupFunction
(
(
)
=
>
{
gHandlerService
.
remove
(
webHandlerInfo
)
;
gHandlerService
.
remove
(
handlerInfoThatAsks
)
;
}
)
;
}
function
makeCmdLineHelper
(
url
)
{
return
{
length
:
1
_arg
:
url
getArgument
(
aIndex
)
{
if
(
aIndex
=
=
0
)
{
return
this
.
_arg
;
}
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
findFlag
(
)
{
return
-
1
;
}
handleFlagWithParam
(
)
{
if
(
this
.
_argCount
)
{
this
.
_argCount
=
0
;
return
this
.
_arg
;
}
return
"
"
;
}
state
:
2
STATE_INITIAL_LAUNCH
:
0
STATE_REMOTE_AUTO
:
1
STATE_REMOTE_EXPLICIT
:
2
preventDefault
:
false
resolveURI
(
)
{
return
Services
.
io
.
newURI
(
this
.
_arg
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICommandLine
"
]
)
}
;
}
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
network
.
protocol
-
handler
.
prompt
-
from
-
external
"
true
]
]
}
)
;
initTestHandlers
(
)
;
}
)
;
add_task
(
async
function
test_external_asks_anyway
(
)
{
let
cmdLineHandler
=
Cc
[
"
mozilla
.
org
/
browser
/
final
-
clh
;
1
"
]
.
getService
(
Ci
.
nsICommandLineHandler
)
;
let
chooserDialogOpenPromise
=
waitForProtocolAppChooserDialog
(
gBrowser
true
)
;
let
fakeCmdLine
=
makeCmdLineHelper
(
"
local
-
app
-
test
:
dummy
"
)
;
cmdLineHandler
.
handle
(
fakeCmdLine
)
;
let
dialog
=
await
chooserDialogOpenPromise
;
ok
(
dialog
"
Should
have
prompted
.
"
)
;
let
dialogClosedPromise
=
waitForProtocolAppChooserDialog
(
gBrowser
.
selectedBrowser
false
)
;
let
dialogEl
=
dialog
.
_frame
.
contentDocument
.
querySelector
(
"
dialog
"
)
;
dialogEl
.
cancelDialog
(
)
;
await
dialogClosedPromise
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
)
;
add_task
(
async
function
test_web_app_doesnt_ask
(
)
{
let
dialogOpenListener
=
(
)
=
>
ok
(
false
"
Shouldn
'
t
have
opened
a
dialog
!
"
)
;
document
.
documentElement
.
addEventListener
(
"
dialogopen
"
dialogOpenListener
)
;
registerCleanupFunction
(
(
)
=
>
document
.
documentElement
.
removeEventListener
(
"
dialogopen
"
dialogOpenListener
)
)
;
const
kURL
=
"
web
+
somesite
:
dummy
"
;
const
kLoadedURL
=
"
https
:
/
/
example
.
com
/
handle_url
?
u
=
"
+
encodeURIComponent
(
kURL
)
;
let
tabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
kLoadedURL
)
;
let
cmdLineHandler
=
Cc
[
"
mozilla
.
org
/
browser
/
final
-
clh
;
1
"
]
.
getService
(
Ci
.
nsICommandLineHandler
)
;
let
fakeCmdLine
=
makeCmdLineHelper
(
kURL
)
;
cmdLineHandler
.
handle
(
fakeCmdLine
)
;
let
tab
=
await
tabPromise
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
kLoadedURL
"
Should
have
opened
the
right
URL
.
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
document
.
documentElement
.
removeEventListener
(
"
dialogopen
"
dialogOpenListener
)
;
}
)
;
add_task
(
async
function
external_https_redirect_doesnt_ask
(
)
{
Services
.
perms
.
addFromPrincipal
(
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
"
https
:
/
/
example
.
com
"
)
"
open
-
protocol
-
handler
^
local
-
app
-
test
"
Services
.
perms
.
ALLOW_ACTION
)
;
let
dialogOpenListener
=
(
)
=
>
ok
(
false
"
Shouldn
'
t
have
opened
a
dialog
!
"
)
;
document
.
documentElement
.
addEventListener
(
"
dialogopen
"
dialogOpenListener
)
;
registerCleanupFunction
(
(
)
=
>
{
document
.
documentElement
.
removeEventListener
(
"
dialogopen
"
dialogOpenListener
)
;
Services
.
perms
.
removeAll
(
)
;
}
)
;
let
initialTab
=
gBrowser
.
selectedTab
;
gHandlerService
.
wrappedJSObject
.
mockProtocolHandler
(
"
local
-
app
-
test
"
)
;
registerCleanupFunction
(
(
)
=
>
gHandlerService
.
wrappedJSObject
.
mockProtocolHandler
(
)
)
;
let
loadPromise
=
TestUtils
.
topicObserved
(
"
mocked
-
protocol
-
handler
"
)
;
const
kURL
=
"
local
-
app
-
test
:
redirect
"
;
let
cmdLineHandler
=
Cc
[
"
mozilla
.
org
/
browser
/
final
-
clh
;
1
"
]
.
getService
(
Ci
.
nsICommandLineHandler
)
;
let
fakeCmdLine
=
makeCmdLineHelper
(
TEST_PATH
+
"
redirect_helper
.
sjs
?
uri
=
"
+
encodeURIComponent
(
kURL
)
)
;
cmdLineHandler
.
handle
(
fakeCmdLine
)
;
let
[
uri
]
=
await
loadPromise
;
is
(
uri
.
spec
"
local
-
app
-
test
:
redirect
"
"
Should
have
seen
correct
URI
.
"
)
;
if
(
gBrowser
.
selectedTab
!
=
initialTab
)
{
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
document
.
documentElement
.
removeEventListener
(
"
dialogopen
"
dialogOpenListener
)
;
gHandlerService
.
wrappedJSObject
.
mockProtocolHandler
(
)
;
}
)
;
