"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
HandlerServiceTestUtils
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Assert
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gExternalProtocolService
"
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
"
nsIExternalProtocolService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gMIMEService
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gHandlerService
"
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
"
nsIHandlerService
"
)
;
var
HandlerServiceTestUtils
=
{
getAllHandlerInfoTypes
(
)
{
return
Array
.
from
(
gHandlerService
.
enumerate
(
)
info
=
>
info
.
type
)
.
sort
(
)
;
}
getAllHandlerInfos
(
)
{
return
this
.
getAllHandlerInfoTypes
(
)
.
map
(
type
=
>
this
.
getHandlerInfo
(
type
)
)
;
}
getHandlerInfo
(
type
)
{
if
(
type
.
includes
(
"
/
"
)
)
{
let
handlerInfo
=
gMIMEService
.
getFromTypeAndExtension
(
type
null
)
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
while
(
handlerInfo
.
possibleApplicationHandlers
.
length
>
1
)
{
handlerInfo
.
possibleApplicationHandlers
.
removeElementAt
(
1
)
;
}
}
else
{
handlerInfo
.
possibleApplicationHandlers
.
clear
(
)
;
}
handlerInfo
.
setFileExtensions
(
"
"
)
;
if
(
gHandlerService
.
exists
(
handlerInfo
)
)
{
gHandlerService
.
fillHandlerInfo
(
handlerInfo
"
"
)
;
}
return
handlerInfo
;
}
let
osDefaultHandlerFound
=
{
}
;
let
handlerInfo
=
gExternalProtocolService
.
getProtocolHandlerInfoFromOS
(
type
osDefaultHandlerFound
)
;
if
(
gHandlerService
.
exists
(
handlerInfo
)
)
{
gHandlerService
.
fillHandlerInfo
(
handlerInfo
"
"
)
;
}
else
{
gExternalProtocolService
.
setProtocolHandlerDefaults
(
handlerInfo
osDefaultHandlerFound
.
value
)
;
}
return
handlerInfo
;
}
getBlankHandlerInfo
(
type
)
{
let
handlerInfo
=
this
.
getHandlerInfo
(
type
)
;
let
preferredAction
preferredApplicationHandler
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
preferredAction
=
type
.
includes
(
"
/
"
)
?
Ci
.
nsIHandlerInfo
.
useHelperApp
:
Ci
.
nsIHandlerInfo
.
useSystemDefault
;
preferredApplicationHandler
=
{
name
:
"
Android
chooser
"
}
;
}
else
{
preferredAction
=
type
.
includes
(
"
/
"
)
?
Ci
.
nsIHandlerInfo
.
saveToDisk
:
Ci
.
nsIHandlerInfo
.
alwaysAsk
;
preferredApplicationHandler
=
null
;
}
this
.
assertHandlerInfoMatches
(
handlerInfo
{
type
preferredAction
alwaysAskBeforeHandling
:
true
preferredApplicationHandler
}
)
;
return
handlerInfo
;
}
assertHandlerInfoMatches
(
handlerInfo
expected
)
{
let
expectedInterface
=
expected
.
type
.
includes
(
"
/
"
)
?
Ci
.
nsIMIMEInfo
:
Ci
.
nsIHandlerInfo
;
Assert
.
ok
(
handlerInfo
instanceof
expectedInterface
)
;
Assert
.
equal
(
handlerInfo
.
type
expected
.
type
)
;
if
(
!
expected
.
preferredActionOSDependent
)
{
Assert
.
equal
(
handlerInfo
.
preferredAction
expected
.
preferredAction
)
;
Assert
.
equal
(
handlerInfo
.
alwaysAskBeforeHandling
expected
.
alwaysAskBeforeHandling
)
;
}
if
(
expectedInterface
=
=
Ci
.
nsIMIMEInfo
)
{
let
fileExtensionsEnumerator
=
handlerInfo
.
getFileExtensions
(
)
;
for
(
let
expectedFileExtension
of
expected
.
fileExtensions
|
|
[
]
)
{
Assert
.
equal
(
fileExtensionsEnumerator
.
getNext
(
)
expectedFileExtension
)
;
}
Assert
.
ok
(
!
fileExtensionsEnumerator
.
hasMore
(
)
)
;
}
if
(
expected
.
preferredApplicationHandler
)
{
this
.
assertHandlerAppMatches
(
handlerInfo
.
preferredApplicationHandler
expected
.
preferredApplicationHandler
)
;
}
else
{
Assert
.
equal
(
handlerInfo
.
preferredApplicationHandler
null
)
;
}
let
handlerAppsArrayEnumerator
=
handlerInfo
.
possibleApplicationHandlers
.
enumerate
(
)
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
this
.
assertHandlerAppMatches
(
handlerAppsArrayEnumerator
.
getNext
(
)
{
name
:
"
Android
chooser
"
}
)
;
}
for
(
let
expectedHandlerApp
of
expected
.
possibleApplicationHandlers
|
|
[
]
)
{
this
.
assertHandlerAppMatches
(
handlerAppsArrayEnumerator
.
getNext
(
)
expectedHandlerApp
)
;
}
Assert
.
ok
(
!
handlerAppsArrayEnumerator
.
hasMoreElements
(
)
)
;
}
assertHandlerAppMatches
(
handlerApp
expected
)
{
Assert
.
ok
(
handlerApp
instanceof
Ci
.
nsIHandlerApp
)
;
Assert
.
equal
(
handlerApp
.
name
expected
.
name
)
;
if
(
expected
.
executable
)
{
Assert
.
ok
(
handlerApp
instanceof
Ci
.
nsILocalHandlerApp
)
;
Assert
.
ok
(
expected
.
executable
.
equals
(
handlerApp
.
executable
)
)
;
}
else
if
(
expected
.
uriTemplate
)
{
Assert
.
ok
(
handlerApp
instanceof
Ci
.
nsIWebHandlerApp
)
;
Assert
.
equal
(
handlerApp
.
uriTemplate
expected
.
uriTemplate
)
;
}
else
if
(
expected
.
service
)
{
Assert
.
ok
(
handlerApp
instanceof
Ci
.
nsIDBusHandlerApp
)
;
Assert
.
equal
(
handlerApp
.
service
expected
.
service
)
;
Assert
.
equal
(
handlerApp
.
method
expected
.
method
)
;
Assert
.
equal
(
handlerApp
.
dBusInterface
expected
.
dBusInterface
)
;
Assert
.
equal
(
handlerApp
.
objectPath
expected
.
objectPath
)
;
}
}
}
;
