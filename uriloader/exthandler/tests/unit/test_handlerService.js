function
run_test
(
)
{
const
handlerSvc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
const
mimeSvc
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
;
const
protoSvc
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
const
prefSvc
=
Cc
[
"
mozilla
.
org
/
preferences
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrefService
)
;
const
ioService
=
Cc
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIOService
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
rootPrefBranch
=
prefSvc
.
getBranch
(
"
"
)
;
let
noMailto
=
false
;
if
(
mozinfo
.
os
=
=
"
win
"
)
{
let
regSvc
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
try
{
regSvc
.
open
(
regSvc
.
ROOT_KEY_CLASSES_ROOT
"
mailto
"
regSvc
.
ACCESS_READ
)
;
noMailto
=
false
;
}
catch
(
ex
)
{
noMailto
=
true
;
}
regSvc
.
close
(
)
;
}
if
(
mozinfo
.
os
=
=
"
linux
"
)
{
let
gIOSvc
=
Cc
[
"
mozilla
.
org
/
gio
-
service
;
1
"
]
.
createInstance
(
Ci
.
nsIGIOService
)
;
try
{
gIOSvc
.
getAppForURIScheme
(
"
mailto
"
)
;
noMailto
=
false
;
}
catch
(
ex
)
{
noMailto
=
true
;
}
}
var
executable
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
var
localHandler
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
localHandler
.
name
=
"
Local
Handler
"
;
localHandler
.
executable
=
executable
;
var
webHandler
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
webHandler
.
name
=
"
Web
Handler
"
;
webHandler
.
uriTemplate
=
"
http
:
/
/
www
.
example
.
com
/
?
%
s
"
;
var
handlerInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
type
"
null
)
;
Assert
.
ok
(
handlerInfo
instanceof
Ci
.
nsIHandlerInfo
)
;
Assert
.
equal
(
handlerInfo
.
type
"
nonexistent
/
type
"
)
;
Assert
.
equal
(
handlerInfo
.
MIMEType
"
nonexistent
/
type
"
)
;
Assert
.
equal
(
handlerInfo
.
preferredAction
Ci
.
nsIHandlerInfo
.
saveToDisk
)
;
Assert
.
equal
(
handlerInfo
.
preferredApplicationHandler
null
)
;
Assert
.
equal
(
handlerInfo
.
possibleApplicationHandlers
.
length
0
)
;
Assert
.
ok
(
handlerInfo
.
alwaysAskBeforeHandling
)
;
Assert
.
equal
(
handlerInfo
.
description
"
"
)
;
Assert
.
equal
(
handlerInfo
.
hasDefaultHandler
false
)
;
Assert
.
equal
(
handlerInfo
.
defaultDescription
"
"
)
;
var
haveDefaultHandlersVersion
=
false
;
try
{
rootPrefBranch
.
getCharPref
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
)
;
haveDefaultHandlersVersion
=
true
;
}
catch
(
ex
)
{
}
const
kExternalWarningDefault
=
"
network
.
protocol
-
handler
.
warn
-
external
-
default
"
;
prefSvc
.
setBoolPref
(
kExternalWarningDefault
true
)
;
var
protoInfo
=
protoSvc
.
getProtocolHandlerInfo
(
"
x
-
moz
-
rheet
"
)
;
Assert
.
equal
(
protoInfo
.
preferredAction
protoInfo
.
alwaysAsk
)
;
Assert
.
ok
(
protoInfo
.
alwaysAskBeforeHandling
)
;
const
kExternalWarningPrefPrefix
=
"
network
.
protocol
-
handler
.
warn
-
external
.
"
;
prefSvc
.
setBoolPref
(
kExternalWarningPrefPrefix
+
"
http
"
false
)
;
protoInfo
=
protoSvc
.
getProtocolHandlerInfo
(
"
http
"
)
;
Assert
.
equal
(
0
protoInfo
.
possibleApplicationHandlers
.
length
)
;
Assert
.
ok
(
!
protoInfo
.
alwaysAskBeforeHandling
)
;
prefSvc
.
setBoolPref
(
kExternalWarningPrefPrefix
+
"
http
"
true
)
;
protoInfo
=
protoSvc
.
getProtocolHandlerInfo
(
"
http
"
)
;
Assert
.
equal
(
0
protoInfo
.
possibleApplicationHandlers
.
length
)
;
Assert
.
ok
(
protoInfo
.
alwaysAskBeforeHandling
)
;
prefSvc
.
setBoolPref
(
kExternalWarningPrefPrefix
+
"
mailto
"
false
)
;
protoInfo
=
protoSvc
.
getProtocolHandlerInfo
(
"
mailto
"
)
;
if
(
haveDefaultHandlersVersion
)
Assert
.
equal
(
2
protoInfo
.
possibleApplicationHandlers
.
length
)
;
else
Assert
.
equal
(
0
protoInfo
.
possibleApplicationHandlers
.
length
)
;
if
(
noMailto
)
Assert
.
ok
(
protoInfo
.
alwaysAskBeforeHandling
)
;
else
Assert
.
ok
(
!
protoInfo
.
alwaysAskBeforeHandling
)
;
prefSvc
.
setBoolPref
(
kExternalWarningPrefPrefix
+
"
mailto
"
true
)
;
protoInfo
=
protoSvc
.
getProtocolHandlerInfo
(
"
mailto
"
)
;
if
(
haveDefaultHandlersVersion
)
{
Assert
.
equal
(
2
protoInfo
.
possibleApplicationHandlers
.
length
)
;
if
(
noMailto
)
Assert
.
ok
(
protoInfo
.
alwaysAskBeforeHandling
)
;
else
Assert
.
ok
(
!
protoInfo
.
alwaysAskBeforeHandling
)
;
}
else
{
Assert
.
equal
(
0
protoInfo
.
possibleApplicationHandlers
.
length
)
;
Assert
.
ok
(
protoInfo
.
alwaysAskBeforeHandling
)
;
}
if
(
haveDefaultHandlersVersion
)
{
prefSvc
.
setBoolPref
(
kExternalWarningPrefPrefix
+
"
mailto
"
false
)
;
protoInfo
.
alwaysAskBeforeHandling
=
true
;
handlerSvc
.
store
(
protoInfo
)
;
protoInfo
=
protoSvc
.
getProtocolHandlerInfo
(
"
mailto
"
)
;
Assert
.
equal
(
2
protoInfo
.
possibleApplicationHandlers
.
length
)
;
Assert
.
ok
(
protoInfo
.
alwaysAskBeforeHandling
)
;
}
handlerInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
handlerInfo
.
preferredApplicationHandler
=
localHandler
;
handlerInfo
.
alwaysAskBeforeHandling
=
false
;
handlerSvc
.
store
(
handlerInfo
)
;
handlerInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
type
"
null
)
;
Assert
.
equal
(
handlerInfo
.
preferredAction
Ci
.
nsIHandlerInfo
.
useHelperApp
)
;
Assert
.
notEqual
(
handlerInfo
.
preferredApplicationHandler
null
)
;
var
preferredHandler
=
handlerInfo
.
preferredApplicationHandler
;
Assert
.
equal
(
typeof
preferredHandler
"
object
"
)
;
Assert
.
equal
(
preferredHandler
.
name
"
Local
Handler
"
)
;
Assert
.
ok
(
preferredHandler
instanceof
Ci
.
nsILocalHandlerApp
)
;
preferredHandler
.
QueryInterface
(
Ci
.
nsILocalHandlerApp
)
;
Assert
.
equal
(
preferredHandler
.
executable
.
path
localHandler
.
executable
.
path
)
;
Assert
.
ok
(
!
handlerInfo
.
alwaysAskBeforeHandling
)
;
var
handlerInfo2
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
type2
"
null
)
;
handlerSvc
.
store
(
handlerInfo2
)
;
var
handlerTypes
=
[
"
nonexistent
/
type
"
"
nonexistent
/
type2
"
]
;
if
(
haveDefaultHandlersVersion
)
{
handlerTypes
.
push
(
"
mailto
"
)
;
handlerTypes
.
push
(
"
irc
"
)
;
handlerTypes
.
push
(
"
ircs
"
)
;
}
for
(
let
handler
of
handlerSvc
.
enumerate
(
)
)
{
Assert
.
notEqual
(
handlerTypes
.
indexOf
(
handler
.
type
)
-
1
)
;
handlerTypes
.
splice
(
handlerTypes
.
indexOf
(
handler
.
type
)
1
)
;
}
Assert
.
equal
(
handlerTypes
.
length
0
)
;
handlerSvc
.
remove
(
handlerInfo2
)
;
handlers
=
handlerSvc
.
enumerate
(
)
;
while
(
handlers
.
hasMoreElements
(
)
)
Assert
.
notEqual
(
handlers
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIHandlerInfo
)
.
type
handlerInfo2
.
type
)
;
var
noPreferredHandlerInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
no
-
preferred
-
handler
"
null
)
;
handlerSvc
.
store
(
noPreferredHandlerInfo
)
;
noPreferredHandlerInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
no
-
preferred
-
handler
"
null
)
;
Assert
.
equal
(
noPreferredHandlerInfo
.
preferredApplicationHandler
null
)
;
var
removePreferredHandlerInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
rem
-
preferred
-
handler
"
null
)
;
removePreferredHandlerInfo
.
preferredApplicationHandler
=
localHandler
;
handlerSvc
.
store
(
removePreferredHandlerInfo
)
;
removePreferredHandlerInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
rem
-
preferred
-
handler
"
null
)
;
removePreferredHandlerInfo
.
preferredApplicationHandler
=
null
;
handlerSvc
.
store
(
removePreferredHandlerInfo
)
;
removePreferredHandlerInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
rem
-
preferred
-
handler
"
null
)
;
Assert
.
equal
(
removePreferredHandlerInfo
.
preferredApplicationHandler
null
)
;
var
possibleHandlersInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
possible
-
handlers
"
null
)
;
Assert
.
equal
(
possibleHandlersInfo
.
possibleApplicationHandlers
.
length
0
)
;
handlerSvc
.
store
(
possibleHandlersInfo
)
;
possibleHandlersInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
possible
-
handlers
"
null
)
;
Assert
.
equal
(
possibleHandlersInfo
.
possibleApplicationHandlers
.
length
0
)
;
possibleHandlersInfo
.
possibleApplicationHandlers
.
appendElement
(
localHandler
)
;
possibleHandlersInfo
.
possibleApplicationHandlers
.
appendElement
(
webHandler
)
;
handlerSvc
.
store
(
possibleHandlersInfo
)
;
possibleHandlersInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
possible
-
handlers
"
null
)
;
Assert
.
equal
(
possibleHandlersInfo
.
possibleApplicationHandlers
.
length
2
)
;
var
handler1
=
possibleHandlersInfo
.
possibleApplicationHandlers
.
queryElementAt
(
0
Ci
.
nsIHandlerApp
)
;
var
handler2
=
possibleHandlersInfo
.
possibleApplicationHandlers
.
queryElementAt
(
1
Ci
.
nsIHandlerApp
)
;
var
localPossibleHandler
webPossibleHandler
localIndex
;
if
(
handler1
instanceof
Ci
.
nsILocalHandlerApp
)
[
localPossibleHandler
webPossibleHandler
localIndex
]
=
[
handler1
handler2
0
]
;
else
[
localPossibleHandler
webPossibleHandler
localIndex
]
=
[
handler2
handler1
1
]
;
localPossibleHandler
.
QueryInterface
(
Ci
.
nsILocalHandlerApp
)
;
webPossibleHandler
.
QueryInterface
(
Ci
.
nsIWebHandlerApp
)
;
Assert
.
equal
(
localPossibleHandler
.
name
localHandler
.
name
)
;
Assert
.
ok
(
localPossibleHandler
.
equals
(
localHandler
)
)
;
Assert
.
equal
(
webPossibleHandler
.
name
webHandler
.
name
)
;
Assert
.
ok
(
webPossibleHandler
.
equals
(
webHandler
)
)
;
possibleHandlersInfo
.
possibleApplicationHandlers
.
removeElementAt
(
localIndex
)
;
handlerSvc
.
store
(
possibleHandlersInfo
)
;
possibleHandlersInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
nonexistent
/
possible
-
handlers
"
null
)
;
Assert
.
equal
(
possibleHandlersInfo
.
possibleApplicationHandlers
.
length
1
)
;
webPossibleHandler
=
possibleHandlersInfo
.
possibleApplicationHandlers
.
queryElementAt
(
0
Ci
.
nsIWebHandlerApp
)
;
Assert
.
equal
(
webPossibleHandler
.
name
webHandler
.
name
)
;
Assert
.
ok
(
webPossibleHandler
.
equals
(
webHandler
)
)
;
var
localApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
var
handlerApp
=
localApp
.
QueryInterface
(
Ci
.
nsIHandlerApp
)
;
Assert
.
ok
(
handlerApp
.
equals
(
localApp
)
)
;
localApp
.
executable
=
executable
;
Assert
.
equal
(
0
localApp
.
parameterCount
)
;
localApp
.
appendParameter
(
"
-
test1
"
)
;
Assert
.
equal
(
1
localApp
.
parameterCount
)
;
localApp
.
appendParameter
(
"
-
test2
"
)
;
Assert
.
equal
(
2
localApp
.
parameterCount
)
;
Assert
.
ok
(
localApp
.
parameterExists
(
"
-
test1
"
)
)
;
Assert
.
ok
(
localApp
.
parameterExists
(
"
-
test2
"
)
)
;
Assert
.
ok
(
!
localApp
.
parameterExists
(
"
-
false
"
)
)
;
localApp
.
clearParameters
(
)
;
Assert
.
equal
(
0
localApp
.
parameterCount
)
;
var
localApp2
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
localApp2
.
executable
=
executable
;
localApp
.
clearParameters
(
)
;
Assert
.
ok
(
localApp
.
equals
(
localApp2
)
)
;
localApp
.
appendParameter
(
"
-
test1
"
)
;
localApp
.
appendParameter
(
"
-
test2
"
)
;
localApp
.
appendParameter
(
"
-
test3
"
)
;
localApp2
.
appendParameter
(
"
-
test1
"
)
;
localApp2
.
appendParameter
(
"
-
test2
"
)
;
localApp2
.
appendParameter
(
"
-
test3
"
)
;
Assert
.
ok
(
localApp
.
equals
(
localApp2
)
)
;
localApp
.
clearParameters
(
)
;
localApp2
.
clearParameters
(
)
;
localApp
.
appendParameter
(
"
-
test1
"
)
;
localApp
.
appendParameter
(
"
-
test2
"
)
;
localApp
.
appendParameter
(
"
-
test3
"
)
;
localApp2
.
appendParameter
(
"
-
test2
"
)
;
localApp2
.
appendParameter
(
"
-
test1
"
)
;
localApp2
.
appendParameter
(
"
-
test3
"
)
;
Assert
.
ok
(
!
localApp2
.
equals
(
localApp
)
)
;
var
str
;
str
=
localApp
.
getParameter
(
0
)
Assert
.
equal
(
str
"
-
test1
"
)
;
str
=
localApp
.
getParameter
(
1
)
Assert
.
equal
(
str
"
-
test2
"
)
;
str
=
localApp
.
getParameter
(
2
)
Assert
.
equal
(
str
"
-
test3
"
)
;
var
lolType
=
handlerSvc
.
getTypeFromExtension
(
"
lolcat
"
)
;
Assert
.
equal
(
lolType
"
"
)
;
var
lolHandler
=
mimeSvc
.
getFromTypeAndExtension
(
"
application
/
lolcat
"
null
)
;
Assert
.
ok
(
!
lolHandler
.
extensionExists
(
"
lolcat
"
)
)
;
lolHandler
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
lolHandler
.
preferredApplicationHandler
=
localHandler
;
lolHandler
.
alwaysAskBeforeHandling
=
false
;
lolHandler
.
appendExtension
(
"
lolcat
"
)
;
Assert
.
ok
(
!
handlerSvc
.
exists
(
lolHandler
)
)
;
handlerSvc
.
store
(
lolHandler
)
;
Assert
.
ok
(
handlerSvc
.
exists
(
lolHandler
)
)
;
lolType
=
handlerSvc
.
getTypeFromExtension
(
"
lolcat
"
)
;
Assert
.
equal
(
lolType
"
application
/
lolcat
"
)
;
if
(
mozinfo
.
os
!
=
"
win
"
&
&
mozinfo
.
os
!
=
"
mac
"
)
{
env
.
set
(
'
PERSONAL_MAILCAP
'
do_get_file
(
'
mailcap
'
)
.
path
)
;
handlerInfo
=
mimeSvc
.
getFromTypeAndExtension
(
"
text
/
plain
"
null
)
;
Assert
.
equal
(
handlerInfo
.
preferredAction
Ci
.
nsIHandlerInfo
.
useSystemDefault
)
;
Assert
.
equal
(
handlerInfo
.
defaultDescription
"
sed
"
)
;
}
}
