let
webHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
webHandlerApp
.
name
=
"
Web
Handler
"
;
webHandlerApp
.
uriTemplate
=
"
https
:
/
/
www
.
example
.
com
/
?
url
=
%
s
"
;
let
expectedWebHandlerApp
=
{
name
:
webHandlerApp
.
name
uriTemplate
:
webHandlerApp
.
uriTemplate
}
;
let
localHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
localHandlerApp
.
name
=
"
Local
Handler
"
;
localHandlerApp
.
executable
=
FileUtils
.
getFile
(
"
TmpD
"
[
]
)
;
let
expectedLocalHandlerApp
=
{
name
:
localHandlerApp
.
name
executable
:
localHandlerApp
.
executable
}
;
function
getKnownHandlerInfo
(
type
)
{
let
handlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
type
)
;
handlerInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
saveToDisk
;
handlerInfo
.
alwaysAskBeforeHandling
=
false
;
return
handlerInfo
;
}
function
assertAllHandlerInfosMatchTestData
(
)
{
let
handlerInfos
=
HandlerServiceTestUtils
.
getAllHandlerInfos
(
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
example
/
type
.
handleinternally
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
handleInternally
alwaysAskBeforeHandling
:
false
fileExtensions
:
[
"
example_one
"
]
}
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
example
/
type
.
savetodisk
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
true
preferredApplicationHandler
:
{
name
:
"
Example
Default
Handler
"
uriTemplate
:
"
https
:
/
/
www
.
example
.
com
/
?
url
=
%
s
"
}
possibleApplicationHandlers
:
[
{
name
:
"
Example
Default
Handler
"
uriTemplate
:
"
https
:
/
/
www
.
example
.
com
/
?
url
=
%
s
"
}
]
fileExtensions
:
[
"
example_two
"
"
example_three
"
]
}
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
example
/
type
.
usehelperapp
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useHelperApp
alwaysAskBeforeHandling
:
true
preferredApplicationHandler
:
{
name
:
"
Example
Default
Handler
"
uriTemplate
:
"
https
:
/
/
www
.
example
.
com
/
?
url
=
%
s
"
}
possibleApplicationHandlers
:
[
{
name
:
"
Example
Default
Handler
"
uriTemplate
:
"
https
:
/
/
www
.
example
.
com
/
?
url
=
%
s
"
}
{
name
:
"
Example
Possible
Handler
One
"
uriTemplate
:
"
http
:
/
/
www
.
example
.
com
/
?
id
=
1
&
url
=
%
s
"
}
{
name
:
"
Example
Possible
Handler
Two
"
uriTemplate
:
"
http
:
/
/
www
.
example
.
com
/
?
id
=
2
&
url
=
%
s
"
}
]
fileExtensions
:
[
"
example_two
"
"
example_three
"
]
}
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
example
/
type
.
usesystemdefault
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useSystemDefault
alwaysAskBeforeHandling
:
false
possibleApplicationHandlers
:
[
{
name
:
"
Example
Possible
Handler
"
uriTemplate
:
"
http
:
/
/
www
.
example
.
com
/
?
url
=
%
s
"
}
]
}
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
examplescheme
.
usehelperapp
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useHelperApp
alwaysAskBeforeHandling
:
true
preferredApplicationHandler
:
{
name
:
"
Example
Default
Handler
"
uriTemplate
:
"
https
:
/
/
www
.
example
.
com
/
?
url
=
%
s
"
}
possibleApplicationHandlers
:
[
{
name
:
"
Example
Default
Handler
"
uriTemplate
:
"
https
:
/
/
www
.
example
.
com
/
?
url
=
%
s
"
}
{
name
:
"
Example
Possible
Handler
One
"
uriTemplate
:
"
http
:
/
/
www
.
example
.
com
/
?
id
=
1
&
url
=
%
s
"
}
{
name
:
"
Example
Possible
Handler
Two
"
uriTemplate
:
"
http
:
/
/
www
.
example
.
com
/
?
id
=
2
&
url
=
%
s
"
}
]
}
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
examplescheme
.
usesystemdefault
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useSystemDefault
alwaysAskBeforeHandling
:
false
possibleApplicationHandlers
:
[
{
name
:
"
Example
Possible
Handler
"
uriTemplate
:
"
http
:
/
/
www
.
example
.
com
/
?
url
=
%
s
"
}
]
}
)
;
Assert
.
equal
(
handlerInfos
.
length
0
)
;
}
add_task
(
async
function
test_store_fillHandlerInfo_predefined
(
)
{
await
copyTestDataToHandlerStore
(
)
;
await
assertAllHandlerInfosMatchTestData
(
)
;
let
testHandlerInfos
=
HandlerServiceTestUtils
.
getAllHandlerInfos
(
)
;
await
deleteHandlerStore
(
)
;
for
(
let
handlerInfo
of
HandlerServiceTestUtils
.
getAllHandlerInfos
(
)
)
{
gHandlerService
.
remove
(
handlerInfo
)
;
}
for
(
let
handlerInfo
of
testHandlerInfos
)
{
gHandlerService
.
store
(
handlerInfo
)
;
}
await
unloadHandlerStore
(
)
;
await
assertAllHandlerInfosMatchTestData
(
)
;
}
)
;
add_task
(
async
function
test_store_remove_exists
(
)
{
for
(
let
type
of
[
"
example
/
type
.
usehelperapp
"
"
examplescheme
.
usehelperapp
"
]
)
{
await
deleteHandlerStore
(
)
;
let
handlerInfoPresent
=
HandlerServiceTestUtils
.
getHandlerInfo
(
type
)
;
let
handlerInfoAbsent
=
HandlerServiceTestUtils
.
getHandlerInfo
(
type
+
"
2
"
)
;
handlerInfoAbsent
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
saveToDisk
;
handlerInfoAbsent
.
alwaysAskBeforeHandling
=
false
;
await
copyTestDataToHandlerStore
(
)
;
Assert
.
ok
(
gHandlerService
.
exists
(
handlerInfoPresent
)
)
;
Assert
.
ok
(
!
gHandlerService
.
exists
(
handlerInfoAbsent
)
)
;
gHandlerService
.
store
(
handlerInfoAbsent
)
;
gHandlerService
.
remove
(
handlerInfoPresent
)
;
await
unloadHandlerStore
(
)
;
Assert
.
ok
(
!
gHandlerService
.
exists
(
handlerInfoPresent
)
)
;
Assert
.
ok
(
gHandlerService
.
exists
(
handlerInfoAbsent
)
)
;
Assert
.
throws
(
(
)
=
>
gHandlerService
.
fillHandlerInfo
(
handlerInfoPresent
"
"
)
ex
=
>
ex
.
result
=
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
let
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
type
+
"
2
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
type
+
"
2
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
}
)
;
}
}
)
;
add_task
(
async
function
test_store_preferredAction
(
)
{
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
getKnownHandlerInfo
(
"
example
/
new
"
)
;
for
(
let
preferredAction
of
[
Ci
.
nsIHandlerInfo
.
alwaysAsk
999
]
)
{
handlerInfo
.
preferredAction
=
preferredAction
;
gHandlerService
.
store
(
handlerInfo
)
;
gHandlerService
.
fillHandlerInfo
(
handlerInfo
"
"
)
;
Assert
.
equal
(
handlerInfo
.
preferredAction
Ci
.
nsIHandlerInfo
.
useHelperApp
)
;
}
}
)
;
add_task
(
async
function
test_store_localHandlerApp_missing
(
)
{
if
(
!
(
"
mozilla
.
org
/
uriloader
/
dbus
-
handler
-
app
;
1
"
in
Cc
)
)
{
info
(
"
Skipping
test
because
it
does
not
apply
to
this
platform
.
"
)
;
return
;
}
let
missingHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
missingHandlerApp
.
name
=
"
Non
-
existing
Handler
"
;
missingHandlerApp
.
executable
=
FileUtils
.
getFile
(
"
TmpD
"
[
"
nonexisting
"
]
)
;
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
getKnownHandlerInfo
(
"
example
/
new
"
)
;
handlerInfo
.
preferredApplicationHandler
=
missingHandlerApp
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
missingHandlerApp
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
webHandlerApp
)
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
let
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
new
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
new
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
possibleApplicationHandlers
:
[
expectedWebHandlerApp
]
}
)
;
}
)
;
add_task
(
async
function
test_store_dBusHandlerApp
(
)
{
if
(
!
(
"
mozilla
.
org
/
uriloader
/
dbus
-
handler
-
app
;
1
"
in
Cc
)
)
{
info
(
"
Skipping
test
because
it
does
not
apply
to
this
platform
.
"
)
;
return
;
}
let
dBusHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
dbus
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIDBusHandlerApp
)
;
dBusHandlerApp
.
name
=
"
DBus
Handler
"
;
dBusHandlerApp
.
service
=
"
test
.
method
.
server
"
;
dBusHandlerApp
.
method
=
"
Method
"
;
dBusHandlerApp
.
dBusInterface
=
"
test
.
method
.
Type
"
;
dBusHandlerApp
.
objectPath
=
"
/
test
/
method
/
Object
"
;
let
expectedDBusHandlerApp
=
{
name
:
dBusHandlerApp
.
name
service
:
dBusHandlerApp
.
service
method
:
dBusHandlerApp
.
method
dBusInterface
:
dBusHandlerApp
.
dBusInterface
objectPath
:
dBusHandlerApp
.
objectPath
}
;
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
getKnownHandlerInfo
(
"
example
/
new
"
)
;
handlerInfo
.
preferredApplicationHandler
=
dBusHandlerApp
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
dBusHandlerApp
)
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
let
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
new
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
new
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
expectedDBusHandlerApp
possibleApplicationHandlers
:
[
expectedDBusHandlerApp
]
}
)
;
}
)
;
add_task
(
async
function
test_store_possibleApplicationHandlers_includes_preferred
(
)
{
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
getKnownHandlerInfo
(
"
example
/
new
"
)
;
handlerInfo
.
preferredApplicationHandler
=
localHandlerApp
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
let
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
new
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
new
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
expectedLocalHandlerApp
possibleApplicationHandlers
:
[
expectedLocalHandlerApp
]
}
)
;
}
)
;
add_task
(
async
function
test_store_possibleApplicationHandlers_preferred_first
(
)
{
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
getKnownHandlerInfo
(
"
example
/
new
"
)
;
handlerInfo
.
preferredApplicationHandler
=
webHandlerApp
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
localHandlerApp
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
webHandlerApp
)
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
let
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
new
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
new
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
expectedWebHandlerApp
possibleApplicationHandlers
:
[
expectedWebHandlerApp
expectedLocalHandlerApp
]
}
)
;
}
)
;
add_task
(
async
function
test_store_fileExtensions_lowercase
(
)
{
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
getKnownHandlerInfo
(
"
example
/
new
"
)
;
handlerInfo
.
appendExtension
(
"
extension_test1
"
)
;
handlerInfo
.
appendExtension
(
"
EXTENSION_test2
"
)
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
let
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
new
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
new
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
fileExtensions
:
[
"
extension_test1
"
"
extension_test2
"
]
}
)
;
}
)
;
add_task
(
async
function
test_store_no_duplicates
(
)
{
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
getKnownHandlerInfo
(
"
example
/
new
"
)
;
handlerInfo
.
preferredApplicationHandler
=
webHandlerApp
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
webHandlerApp
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
localHandlerApp
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
localHandlerApp
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
webHandlerApp
)
;
handlerInfo
.
appendExtension
(
"
extension_test1
"
)
;
handlerInfo
.
appendExtension
(
"
extension_test2
"
)
;
handlerInfo
.
appendExtension
(
"
extension_test1
"
)
;
handlerInfo
.
appendExtension
(
"
EXTENSION_test1
"
)
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
let
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
new
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
new
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
expectedWebHandlerApp
possibleApplicationHandlers
:
[
expectedWebHandlerApp
expectedLocalHandlerApp
]
fileExtensions
:
[
"
extension_test1
"
"
extension_test2
"
]
}
)
;
}
)
;
add_task
(
async
function
test_store_deletes_properties_except_extensions
(
)
{
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
example
/
type
.
savetodisk
"
)
;
handlerInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
saveToDisk
;
handlerInfo
.
alwaysAskBeforeHandling
=
false
;
await
copyTestDataToHandlerStore
(
)
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
let
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
type
.
savetodisk
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
type
.
savetodisk
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
fileExtensions
:
[
"
example_two
"
"
example_three
"
]
}
)
;
}
)
;
add_task
(
async
function
test_fillHandlerInfo_overrideType
(
)
{
for
(
let
type
of
[
"
example
/
type
.
usesystemdefault
"
"
examplescheme
.
usesystemdefault
"
]
)
{
await
deleteHandlerStore
(
)
;
let
handlerInfoAbsent
=
HandlerServiceTestUtils
.
getHandlerInfo
(
type
+
"
2
"
)
;
await
copyTestDataToHandlerStore
(
)
;
gHandlerService
.
fillHandlerInfo
(
handlerInfoAbsent
type
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfoAbsent
{
type
:
type
+
"
2
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useSystemDefault
alwaysAskBeforeHandling
:
false
possibleApplicationHandlers
:
[
{
name
:
"
Example
Possible
Handler
"
uriTemplate
:
"
http
:
/
/
www
.
example
.
com
/
?
url
=
%
s
"
}
]
}
)
;
}
}
)
;
add_task
(
async
function
test_getTypeFromExtension
(
)
{
await
copyTestDataToHandlerStore
(
)
;
Assert
.
equal
(
gHandlerService
.
getTypeFromExtension
(
"
"
)
"
"
)
;
Assert
.
equal
(
gHandlerService
.
getTypeFromExtension
(
"
example_unknown
"
)
"
"
)
;
Assert
.
equal
(
gHandlerService
.
getTypeFromExtension
(
"
example_one
"
)
"
example
/
type
.
handleinternally
"
)
;
Assert
.
equal
(
gHandlerService
.
getTypeFromExtension
(
"
EXAMPLE_one
"
)
"
example
/
type
.
handleinternally
"
)
;
}
)
;
function
assertAllHandlerInfosMatchDefaultHandlers
(
)
{
let
handlerInfos
=
HandlerServiceTestUtils
.
getAllHandlerInfos
(
)
;
for
(
let
type
of
[
"
irc
"
"
ircs
"
]
)
{
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
preferredActionOSDependent
:
true
possibleApplicationHandlers
:
[
{
name
:
"
Mibbit
"
uriTemplate
:
"
https
:
/
/
www
.
mibbit
.
com
/
?
url
=
%
s
"
}
]
}
)
;
}
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
mailto
"
preferredActionOSDependent
:
true
possibleApplicationHandlers
:
[
{
name
:
"
Yahoo
!
Mail
"
uriTemplate
:
"
https
:
/
/
compose
.
mail
.
yahoo
.
com
/
?
To
=
%
s
"
}
{
name
:
"
Gmail
"
uriTemplate
:
"
https
:
/
/
mail
.
google
.
com
/
mail
/
?
extsrc
=
mailto
&
url
=
%
s
"
}
]
}
)
;
Assert
.
equal
(
handlerInfos
.
length
0
)
;
}
add_task
(
async
function
test_default_protocol_handlers
(
)
{
if
(
!
Services
.
prefs
.
getPrefType
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
)
)
{
info
(
"
This
platform
or
locale
does
not
have
default
handlers
.
"
)
;
return
;
}
await
deleteHandlerStore
(
)
;
await
assertAllHandlerInfosMatchDefaultHandlers
(
)
;
}
)
;
add_task
(
async
function
test_default_protocol_handlers_no_duplicates
(
)
{
if
(
!
Services
.
prefs
.
getPrefType
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
)
)
{
info
(
"
This
platform
or
locale
does
not
have
default
handlers
.
"
)
;
return
;
}
await
deleteHandlerStore
(
)
;
let
ircHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
irc
"
)
;
gHandlerService
.
remove
(
ircHandlerInfo
)
;
let
originalDefaultHandlersVersion
=
Services
.
prefs
.
getComplexValue
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
Ci
.
nsIPrefLocalizedString
)
;
Services
.
prefs
.
setStringPref
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
"
999
"
)
;
await
unloadHandlerStore
(
)
;
Assert
.
ok
(
gHandlerService
.
exists
(
ircHandlerInfo
)
)
;
await
assertAllHandlerInfosMatchDefaultHandlers
(
)
;
Services
.
prefs
.
setStringPref
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
originalDefaultHandlersVersion
)
;
}
)
;
add_task
(
async
function
test_store_keeps_unknown_properties
(
)
{
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
type
.
handleinternally
"
)
;
await
copyTestDataToHandlerStore
(
)
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
let
data
=
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
await
OS
.
File
.
read
(
jsonPath
)
)
)
;
Assert
.
equal
(
data
.
mimeTypes
[
"
example
/
type
.
handleinternally
"
]
.
unknownProperty
"
preserved
"
)
;
}
)
;
add_task
(
async
function
test_async_init
(
)
{
await
deleteHandlerStore
(
)
;
await
copyTestDataToHandlerStore
(
)
;
gHandlerService
.
asyncInit
(
)
;
await
TestUtils
.
topicObserved
(
"
handlersvc
-
store
-
initialized
"
)
;
await
assertAllHandlerInfosMatchTestData
(
)
;
await
unloadHandlerStore
(
)
;
}
)
;
add_task
(
async
function
test_race_async_init
(
)
{
await
deleteHandlerStore
(
)
;
await
copyTestDataToHandlerStore
(
)
;
let
storeInitialized
=
false
;
TestUtils
.
topicObserved
(
"
handlersvc
-
store
-
initialized
"
(
)
=
>
{
storeInitialized
=
true
;
return
true
;
}
)
;
gHandlerService
.
asyncInit
(
)
;
Assert
.
ok
(
!
storeInitialized
)
;
gHandlerService
.
enumerate
(
)
;
Assert
.
ok
(
storeInitialized
)
;
await
assertAllHandlerInfosMatchTestData
(
)
;
await
unloadHandlerStore
(
)
;
}
)
;
add_task
(
async
function
test_store_gioHandlerApp
(
)
{
if
(
!
(
"
mozilla
.
org
/
gio
-
service
;
1
"
in
Cc
)
)
{
info
(
"
Skipping
test
because
it
does
not
apply
to
this
platform
.
"
)
;
return
;
}
let
dummyHandlerFile
=
FileUtils
.
getFile
(
"
TmpD
"
[
"
dummyHandler
"
]
)
;
dummyHandlerFile
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
parseInt
(
"
777
"
8
)
)
;
let
handlerApp
=
Cc
[
"
mozilla
.
org
/
gio
-
service
;
1
"
]
.
getService
(
Ci
.
nsIGIOService
)
.
createAppFromCommand
(
dummyHandlerFile
.
path
"
Dummy
GIO
handler
"
)
;
let
expectedGIOMimeHandlerApp
=
{
name
:
handlerApp
.
name
command
:
handlerApp
.
command
}
;
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
getKnownHandlerInfo
(
"
example
/
new
"
)
;
handlerInfo
.
preferredApplicationHandler
=
handlerApp
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
handlerApp
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
webHandlerApp
)
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
let
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
new
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
new
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
expectedGIOMimeHandlerApp
possibleApplicationHandlers
:
[
expectedGIOMimeHandlerApp
webHandlerApp
]
}
)
;
await
OS
.
File
.
remove
(
dummyHandlerFile
.
path
)
;
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
new
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
new
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
null
possibleApplicationHandlers
:
[
webHandlerApp
]
}
)
;
}
)
;
