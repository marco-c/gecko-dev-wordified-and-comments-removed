HandlerServiceTestUtils
.
handlerService
=
gHandlerService
;
const
pdfHandlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type
"
)
;
const
gzipHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
application
/
x
-
gzip
"
)
;
const
ircHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
irc
"
)
;
let
executable
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
let
localHandler
=
{
name
:
"
Local
Handler
"
executable
:
executable
interfaces
:
[
Ci
.
nsIHandlerApp
Ci
.
nsILocalHandlerApp
Ci
.
nsISupports
]
QueryInterface
:
function
(
iid
)
{
if
(
!
this
.
interfaces
.
some
(
function
(
v
)
{
return
iid
.
equals
(
v
)
}
)
)
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
return
this
;
}
}
;
let
webHandler
=
{
name
:
"
Web
Handler
"
uriTemplate
:
"
https
:
/
/
www
.
webhandler
.
com
/
?
url
=
%
s
"
interfaces
:
[
Ci
.
nsIHandlerApp
Ci
.
nsIWebHandlerApp
Ci
.
nsISupports
]
QueryInterface
:
function
(
iid
)
{
if
(
!
this
.
interfaces
.
some
(
function
(
v
)
{
return
iid
.
equals
(
v
)
}
)
)
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
return
this
;
}
}
;
let
dBusHandler
=
{
name
:
"
DBus
Handler
"
service
:
"
DBus
Service
"
method
:
"
DBus
method
"
objectPath
:
"
/
tmp
/
PATH
/
DBus
"
dBusInterface
:
"
DBusInterface
"
interfaces
:
[
Ci
.
nsIHandlerApp
Ci
.
nsIDBusHandlerApp
Ci
.
nsISupports
]
QueryInterface
:
function
(
iid
)
{
if
(
!
this
.
interfaces
.
some
(
function
(
v
)
{
return
iid
.
equals
(
v
)
}
)
)
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
return
this
;
}
}
;
add_task
(
function
*
testLoadPredefined
(
)
{
yield
prepareImportDB
(
)
;
let
handlerInfos
=
HandlerServiceTestUtils
.
getAllHandlerInfos
(
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
irc
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useHelperApp
alwaysAskBeforeHandling
:
true
possibleApplicationHandlers
:
[
{
name
:
"
Mibbit
"
uriTemplate
:
"
https
:
/
/
www
.
mibbit
.
com
/
?
url
=
%
s
"
}
]
}
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
ircs
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useHelperApp
alwaysAskBeforeHandling
:
true
possibleApplicationHandlers
:
[
{
name
:
"
Mibbit
"
uriTemplate
:
"
https
:
/
/
www
.
mibbit
.
com
/
?
url
=
%
s
"
}
]
}
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
mailto
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useSystemDefault
alwaysAskBeforeHandling
:
false
possibleApplicationHandlers
:
[
{
name
:
"
Yahoo
!
Mail
"
uriTemplate
:
"
https
:
/
/
compose
.
mail
.
yahoo
.
com
/
?
To
=
%
s
"
}
{
name
:
"
Gmail
"
uriTemplate
:
"
https
:
/
/
mail
.
google
.
com
/
mail
/
?
extsrc
=
mailto
&
url
=
%
s
"
}
]
}
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
nonexistent
/
type
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
handleInternally
alwaysAskBeforeHandling
:
false
fileExtensions
:
[
"
pdf
"
]
}
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfos
.
shift
(
)
{
type
:
"
webcal
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useHelperApp
alwaysAskBeforeHandling
:
true
preferredApplicationHandler
:
{
name
:
"
30
Boxes
"
uriTemplate
:
"
http
:
/
/
30boxes
.
com
/
external
/
widget
?
refer
=
ff
&
url
=
%
s
"
}
possibleApplicationHandlers
:
[
{
name
:
"
30
Boxes
"
uriTemplate
:
"
http
:
/
/
30boxes
.
com
/
external
/
widget
?
refer
=
ff
&
url
=
%
s
"
}
{
name
:
"
30
Boxes
"
uriTemplate
:
"
https
:
/
/
30boxes
.
com
/
external
/
widget
?
refer
=
ff
&
url
=
%
s
"
}
]
}
)
;
do_check_eq
(
handlerInfos
.
length
0
)
;
}
)
;
add_task
(
function
*
testImportAndReload
(
)
{
yield
prepareImportDB
(
)
;
Assert
.
deepEqual
(
HandlerServiceTestUtils
.
getAllHandlerInfoTypes
(
)
[
"
irc
"
"
ircs
"
"
mailto
"
"
nonexistent
/
type
"
"
webcal
"
]
)
;
gHandlerService
.
store
(
gzipHandlerInfo
)
;
gHandlerService
.
remove
(
pdfHandlerInfo
)
;
yield
reloadData
(
)
;
Assert
.
deepEqual
(
HandlerServiceTestUtils
.
getAllHandlerInfoTypes
(
)
[
"
application
/
x
-
gzip
"
"
irc
"
"
ircs
"
"
mailto
"
"
webcal
"
]
)
;
}
)
;
add_task
(
function
*
testReloadWithoutDB
(
)
{
yield
removeImportDB
(
)
;
if
(
Services
.
prefs
.
getPrefType
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
)
)
{
Assert
.
deepEqual
(
HandlerServiceTestUtils
.
getAllHandlerInfoTypes
(
)
[
"
irc
"
"
ircs
"
"
mailto
"
"
webcal
"
]
)
;
}
}
)
;
add_task
(
function
*
testExists
(
)
{
yield
prepareImportDB
(
)
;
do_check_true
(
gHandlerService
.
exists
(
pdfHandlerInfo
)
)
;
do_check_false
(
gHandlerService
.
exists
(
gzipHandlerInfo
)
)
;
let
handler
=
ircHandlerInfo
;
gHandlerService
.
remove
(
handler
)
;
do_check_false
(
gHandlerService
.
exists
(
handler
)
)
;
gHandlerService
.
store
(
handler
)
;
do_check_true
(
gHandlerService
.
exists
(
handler
)
)
;
}
)
;
add_task
(
function
*
testGetTypeFromExtension
(
)
{
yield
prepareImportDB
(
)
;
let
type
=
gHandlerService
.
getTypeFromExtension
(
"
doc
"
)
;
do_check_eq
(
type
"
"
)
;
type
=
gHandlerService
.
getTypeFromExtension
(
"
pdf
"
)
;
do_check_eq
(
type
"
nonexistent
/
type
"
)
;
gHandlerService
.
fillHandlerInfo
(
pdfHandlerInfo
"
"
)
;
gHandlerService
.
remove
(
pdfHandlerInfo
)
;
do_check_false
(
gHandlerService
.
exists
(
pdfHandlerInfo
)
)
;
type
=
gHandlerService
.
getTypeFromExtension
(
"
pdf
"
)
;
do_check_eq
(
type
"
"
)
;
gHandlerService
.
store
(
pdfHandlerInfo
)
;
do_check_true
(
gHandlerService
.
exists
(
pdfHandlerInfo
)
)
;
type
=
gHandlerService
.
getTypeFromExtension
(
"
pdf
"
)
;
do_check_eq
(
type
"
nonexistent
/
type
"
)
;
}
)
;
add_task
(
function
*
testStoreAndFillHandlerInfo
(
)
{
yield
removeImportDB
(
)
;
let
handlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type
"
)
;
let
handlerInfo2
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type2
"
)
;
handlerInfo2
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useSystemDefault
;
handlerInfo2
.
preferredApplicationHandler
=
localHandler
;
handlerInfo2
.
alwaysAskBeforeHandling
=
false
;
handlerInfo2
.
appendExtension
(
"
type2
"
)
;
gHandlerService
.
store
(
handlerInfo2
)
;
gHandlerService
.
fillHandlerInfo
(
handlerInfo
"
nonexistent
/
type2
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfo
{
type
:
"
nonexistent
/
type
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useSystemDefault
alwaysAskBeforeHandling
:
false
fileExtensions
:
[
"
type2
"
]
preferredApplicationHandler
:
{
name
:
"
Local
Handler
"
executable
}
possibleApplicationHandlers
:
[
{
name
:
"
Local
Handler
"
executable
}
]
}
)
;
}
)
;
add_task
(
function
*
testFillHandlerInfoWithError
(
)
{
yield
removeImportDB
(
)
;
let
handlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type
"
)
;
Assert
.
throws
(
(
)
=
>
gHandlerService
.
fillHandlerInfo
(
handlerInfo
"
nonexistent
/
type2
"
)
ex
=
>
ex
.
result
=
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
)
;
add_task
(
function
*
testPreferHandlerIsTheFirstOrder
(
)
{
yield
removeImportDB
(
)
;
let
handlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type
"
)
;
let
handlerInfo2
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type2
"
)
;
handlerInfo2
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
handlerInfo2
.
preferredApplicationHandler
=
webHandler
;
handlerInfo2
.
possibleApplicationHandlers
.
appendElement
(
localHandler
)
;
handlerInfo2
.
possibleApplicationHandlers
.
appendElement
(
webHandler
)
;
handlerInfo2
.
alwaysAskBeforeHandling
=
false
;
gHandlerService
.
store
(
handlerInfo2
)
;
gHandlerService
.
fillHandlerInfo
(
handlerInfo
"
nonexistent
/
type2
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfo
{
type
:
"
nonexistent
/
type
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useHelperApp
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
{
name
:
webHandler
.
name
uriTemplate
:
webHandler
.
uriTemplate
}
possibleApplicationHandlers
:
[
{
name
:
webHandler
.
name
uriTemplate
:
webHandler
.
uriTemplate
}
{
name
:
"
Local
Handler
"
executable
}
]
}
)
;
}
)
;
add_task
(
function
*
testStoreForWebHandler
(
)
{
yield
removeImportDB
(
)
;
let
handlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type
"
)
;
let
handlerInfo2
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type2
"
)
;
handlerInfo2
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
handlerInfo2
.
preferredApplicationHandler
=
webHandler
;
handlerInfo2
.
alwaysAskBeforeHandling
=
false
;
gHandlerService
.
store
(
handlerInfo2
)
;
gHandlerService
.
fillHandlerInfo
(
handlerInfo
"
nonexistent
/
type2
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfo
{
type
:
"
nonexistent
/
type
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useHelperApp
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
{
name
:
webHandler
.
name
uriTemplate
:
webHandler
.
uriTemplate
}
possibleApplicationHandlers
:
[
{
name
:
webHandler
.
name
uriTemplate
:
webHandler
.
uriTemplate
}
]
}
)
;
}
)
;
add_task
(
function
*
testStoreForDBusHandler
(
)
{
if
(
!
(
"
mozilla
.
org
/
uriloader
/
dbus
-
handler
-
app
;
1
"
in
Cc
)
)
{
do_print
(
"
Skipping
test
because
it
does
not
apply
to
this
platform
.
"
)
;
return
;
}
yield
removeImportDB
(
)
;
let
handlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type
"
)
;
let
handlerInfo2
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type2
"
)
;
handlerInfo2
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
handlerInfo2
.
preferredApplicationHandler
=
dBusHandler
;
handlerInfo2
.
alwaysAskBeforeHandling
=
false
;
gHandlerService
.
store
(
handlerInfo2
)
;
gHandlerService
.
fillHandlerInfo
(
handlerInfo
"
nonexistent
/
type2
"
)
;
let
expectedHandler
=
{
name
:
dBusHandler
.
name
service
:
dBusHandler
.
service
method
:
dBusHandler
.
method
dBusInterface
:
dBusHandler
.
dBusInterface
objectPath
:
dBusHandler
.
objectPath
}
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
handlerInfo
{
type
:
"
nonexistent
/
type
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useHelperApp
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
expectedHandler
possibleApplicationHandlers
:
[
expectedHandler
]
}
)
;
}
)
;
add_task
(
function
*
testIsInHandlerArray
(
)
{
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
do_print
(
"
Skipping
test
because
it
does
not
apply
to
this
platform
.
"
)
;
return
;
}
if
(
!
Services
.
prefs
.
getPrefType
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
)
)
{
do_print
(
"
Skipping
test
:
No
pref
gecko
.
handlerService
.
defaultHandlersVersion
.
"
)
;
return
;
}
yield
removeImportDB
(
)
;
let
protoInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
"
)
;
do_check_eq
(
protoInfo
.
possibleApplicationHandlers
.
length
0
)
;
gHandlerService
.
fillHandlerInfo
(
protoInfo
"
ircs
"
)
;
do_check_eq
(
protoInfo
.
possibleApplicationHandlers
.
length
1
)
;
let
ircInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
irc
"
)
;
gHandlerService
.
remove
(
ircInfo
)
;
do_check_false
(
gHandlerService
.
exists
(
ircInfo
)
)
;
let
origPrefs
=
Services
.
prefs
.
getComplexValue
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
Ci
.
nsIPrefLocalizedString
)
;
let
string
=
Cc
[
"
mozilla
.
org
/
pref
-
localizedstring
;
1
"
]
.
createInstance
(
Ci
.
nsIPrefLocalizedString
)
;
string
.
data
=
"
999
"
;
Services
.
prefs
.
setComplexValue
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
Ci
.
nsIPrefLocalizedString
string
)
;
yield
reloadData
(
)
;
do_check_true
(
gHandlerService
.
exists
(
ircInfo
)
)
;
protoInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
"
)
;
do_check_false
(
gHandlerService
.
exists
(
protoInfo
)
)
;
gHandlerService
.
fillHandlerInfo
(
protoInfo
"
ircs
"
)
;
do_check_eq
(
protoInfo
.
possibleApplicationHandlers
.
length
1
)
;
Services
.
prefs
.
setComplexValue
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
Ci
.
nsIPrefLocalizedString
origPrefs
)
;
}
)
;
add_task
(
function
*
testFillHandlerInfoForProtocol
(
)
{
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
do_print
(
"
Skipping
test
because
it
does
not
apply
to
this
platform
.
"
)
;
return
;
}
if
(
!
Services
.
prefs
.
getPrefType
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
)
)
{
do_print
(
"
Skipping
test
:
No
pref
gecko
.
handlerService
.
defaultHandlersVersion
.
"
)
;
return
;
}
yield
removeImportDB
(
)
;
let
protoInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
"
)
;
let
ircInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
irc
"
)
;
do_check_true
(
gHandlerService
.
exists
(
ircInfo
)
)
;
gHandlerService
.
fillHandlerInfo
(
protoInfo
"
irc
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
protoInfo
{
type
:
"
nonexistent
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useHelperApp
alwaysAskBeforeHandling
:
true
possibleApplicationHandlers
:
[
{
name
:
"
Mibbit
"
uriTemplate
:
"
https
:
/
/
www
.
mibbit
.
com
/
?
url
=
%
s
"
}
]
}
)
;
}
)
;
add_task
(
function
*
testStoreForProtocol
(
)
{
yield
removeImportDB
(
)
;
let
protoInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
"
)
;
let
protoInfo2
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent2
"
)
;
protoInfo2
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
protoInfo2
.
alwaysAskBeforeHandling
=
false
;
protoInfo2
.
preferredApplicationHandler
=
webHandler
;
gHandlerService
.
store
(
protoInfo2
)
;
yield
reloadData
(
)
;
do_check_true
(
gHandlerService
.
exists
(
protoInfo2
)
)
;
gHandlerService
.
fillHandlerInfo
(
protoInfo
"
nonexistent2
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
protoInfo
{
type
:
"
nonexistent
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
useHelperApp
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
{
name
:
webHandler
.
name
uriTemplate
:
webHandler
.
uriTemplate
}
possibleApplicationHandlers
:
[
{
name
:
webHandler
.
name
uriTemplate
:
webHandler
.
uriTemplate
}
]
}
)
;
}
)
;
add_task
(
function
*
testFillHandlerInfoWithoutOverrideType
(
)
{
yield
removeImportDB
(
)
;
let
mimeInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type
"
)
;
let
storedHandlerInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
/
type
"
)
;
storedHandlerInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useSystemDefault
;
storedHandlerInfo
.
preferredApplicationHandler
=
webHandler
;
storedHandlerInfo
.
alwaysAskBeforeHandling
=
false
;
gHandlerService
.
store
(
storedHandlerInfo
)
;
let
protoInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
"
)
;
let
storedProtoInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
"
)
;
storedProtoInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
storedProtoInfo
.
alwaysAskBeforeHandling
=
false
;
storedProtoInfo
.
preferredApplicationHandler
=
webHandler
;
gHandlerService
.
store
(
storedProtoInfo
)
;
for
(
let
handlerInfo
of
[
mimeInfo
protoInfo
]
)
{
let
handlerInfo2
=
storedProtoInfo
;
if
(
handlerInfo
.
type
=
=
"
nonexistent
/
type
"
)
{
handlerInfo2
=
storedHandlerInfo
;
}
gHandlerService
.
fillHandlerInfo
(
handlerInfo
null
)
;
do_check_eq
(
handlerInfo
.
preferredAction
handlerInfo2
.
preferredAction
)
;
do_check_eq
(
handlerInfo
.
alwaysAskBeforeHandling
handlerInfo2
.
alwaysAskBeforeHandling
)
;
do_check_eq
(
handlerInfo
.
preferredApplicationHandler
.
name
handlerInfo2
.
preferredApplicationHandler
.
name
)
;
let
apps
=
handlerInfo
.
possibleApplicationHandlers
.
enumerate
(
)
;
let
app
;
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
app
=
apps
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIHandlerApp
)
;
do_check_eq
(
app
.
name
"
Android
chooser
"
)
;
}
app
=
apps
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIWebHandlerApp
)
;
do_check_eq
(
app
.
name
webHandler
.
name
)
;
do_check_eq
(
app
.
uriTemplate
webHandler
.
uriTemplate
)
;
}
}
)
;
add_task
(
function
*
testPreferredActionHandling
(
)
{
yield
removeImportDB
(
)
;
let
protoInfo
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent
"
)
;
let
protoInfo2
=
HandlerServiceTestUtils
.
getBlankHandlerInfo
(
"
nonexistent2
"
)
;
for
(
let
preferredAction
of
[
Ci
.
nsIHandlerInfo
.
saveToDisk
Ci
.
nsIHandlerInfo
.
useHelperApp
Ci
.
nsIHandlerInfo
.
handleInternally
Ci
.
nsIHandlerInfo
.
useSystemDefault
]
)
{
protoInfo2
.
preferredAction
=
preferredAction
;
gHandlerService
.
store
(
protoInfo2
)
;
gHandlerService
.
fillHandlerInfo
(
protoInfo
"
nonexistent2
"
)
;
do_check_eq
(
protoInfo
.
preferredAction
preferredAction
)
;
}
for
(
let
preferredAction
of
[
Ci
.
nsIHandlerInfo
.
alwaysAsk
999
]
)
{
protoInfo2
.
preferredAction
=
preferredAction
;
gHandlerService
.
store
(
protoInfo2
)
;
gHandlerService
.
fillHandlerInfo
(
protoInfo
"
nonexistent2
"
)
;
do_check_eq
(
protoInfo
.
preferredAction
Ci
.
nsIHandlerInfo
.
useHelperApp
)
;
}
}
)
;
