let
gHandlerService
=
gHandlerServiceJSON
;
let
unloadHandlerStore
=
unloadHandlerStoreJSON
;
let
deleteHandlerStore
=
deleteHandlerStoreJSON
;
let
copyTestDataToHandlerStore
=
copyTestDataToHandlerStoreJSON
;
var
scriptFile
=
do_get_file
(
"
common_test_handlerService
.
js
"
)
;
Services
.
scriptloader
.
loadSubScript
(
NetUtil
.
newURI
(
scriptFile
)
.
spec
)
;
add_task
(
async
function
test_store_keeps_unknown_properties
(
)
{
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
type
.
handleinternally
"
)
;
await
copyTestDataToHandlerStore
(
)
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
let
data
=
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
await
OS
.
File
.
read
(
jsonPath
)
)
)
;
Assert
.
equal
(
data
.
mimeTypes
[
"
example
/
type
.
handleinternally
"
]
.
unknownProperty
"
preserved
"
)
;
}
)
;
add_task
(
async
function
test_async_init
(
)
{
await
deleteHandlerStore
(
)
;
await
copyTestDataToHandlerStore
(
)
;
gHandlerService
.
asyncInit
(
)
;
await
TestUtils
.
topicObserved
(
"
handlersvc
-
store
-
initialized
"
)
;
await
assertAllHandlerInfosMatchTestData
(
)
;
await
unloadHandlerStore
(
)
;
}
)
;
add_task
(
async
function
test_race_async_init
(
)
{
await
deleteHandlerStore
(
)
;
await
copyTestDataToHandlerStore
(
)
;
let
storeInitialized
=
false
;
TestUtils
.
topicObserved
(
"
handlersvc
-
store
-
initialized
"
(
)
=
>
{
storeInitialized
=
true
;
return
true
;
}
)
;
gHandlerService
.
asyncInit
(
)
;
Assert
.
ok
(
!
storeInitialized
)
;
gHandlerService
.
enumerate
(
)
;
Assert
.
ok
(
storeInitialized
)
;
await
assertAllHandlerInfosMatchTestData
(
)
;
await
unloadHandlerStore
(
)
;
}
)
;
add_task
(
async
function
test_migration_rdf_present
(
)
{
await
deleteHandlerStore
(
)
;
await
copyTestDataToHandlerStoreRDF
(
)
;
Services
.
prefs
.
setBoolPref
(
"
gecko
.
handlerService
.
migrated
"
false
)
;
await
assertAllHandlerInfosMatchTestData
(
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
"
gecko
.
handlerService
.
migrated
"
)
)
;
await
unloadHandlerStore
(
)
;
await
unloadHandlerStoreRDF
(
)
;
Services
.
prefs
.
setBoolPref
(
"
gecko
.
handlerService
.
migrated
"
false
)
;
await
assertAllHandlerInfosMatchTestData
(
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
"
gecko
.
handlerService
.
migrated
"
)
)
;
}
)
;
add_task
(
async
function
test_migration_rdf_present_keeps_new_data
(
)
{
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
getKnownHandlerInfo
(
"
example
/
new
"
)
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
await
copyTestDataToHandlerStoreRDF
(
)
;
Services
.
prefs
.
setBoolPref
(
"
gecko
.
handlerService
.
migrated
"
false
)
;
let
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
new
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
new
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
}
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
"
gecko
.
handlerService
.
migrated
"
)
)
;
}
)
;
add_task
(
async
function
test_migration_rdf_absent
(
)
{
if
(
!
Services
.
prefs
.
getPrefType
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
)
)
{
info
(
"
This
platform
or
locale
does
not
have
default
handlers
.
"
)
;
return
;
}
await
deleteHandlerStore
(
)
;
await
deleteHandlerStoreRDF
(
)
;
Services
.
prefs
.
setBoolPref
(
"
gecko
.
handlerService
.
migrated
"
false
)
;
await
assertAllHandlerInfosMatchDefaultHandlers
(
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
"
gecko
.
handlerService
.
migrated
"
)
)
;
await
unloadHandlerStore
(
)
;
await
unloadHandlerStoreRDF
(
)
;
Services
.
prefs
.
setBoolPref
(
"
gecko
.
handlerService
.
migrated
"
false
)
;
await
assertAllHandlerInfosMatchDefaultHandlers
(
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
"
gecko
.
handlerService
.
migrated
"
)
)
;
}
)
;
add_task
(
async
function
test_store_gioHandlerApp
(
)
{
if
(
!
(
"
mozilla
.
org
/
gio
-
service
;
1
"
in
Cc
)
)
{
info
(
"
Skipping
test
because
it
does
not
apply
to
this
platform
.
"
)
;
return
;
}
let
dummyHandlerFile
=
FileUtils
.
getFile
(
"
TmpD
"
[
"
dummyHandler
"
]
)
;
dummyHandlerFile
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
parseInt
(
"
777
"
8
)
)
;
let
handlerApp
=
Cc
[
"
mozilla
.
org
/
gio
-
service
;
1
"
]
.
getService
(
Ci
.
nsIGIOService
)
.
createAppFromCommand
(
dummyHandlerFile
.
path
"
Dummy
GIO
handler
"
)
;
let
expectedGIOMimeHandlerApp
=
{
name
:
handlerApp
.
name
command
:
handlerApp
.
command
}
;
await
deleteHandlerStore
(
)
;
let
handlerInfo
=
getKnownHandlerInfo
(
"
example
/
new
"
)
;
handlerInfo
.
preferredApplicationHandler
=
handlerApp
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
handlerApp
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
webHandlerApp
)
;
gHandlerService
.
store
(
handlerInfo
)
;
await
unloadHandlerStore
(
)
;
let
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
new
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
new
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
expectedGIOMimeHandlerApp
possibleApplicationHandlers
:
[
expectedGIOMimeHandlerApp
webHandlerApp
]
}
)
;
await
OS
.
File
.
remove
(
dummyHandlerFile
.
path
)
;
actualHandlerInfo
=
HandlerServiceTestUtils
.
getHandlerInfo
(
"
example
/
new
"
)
;
HandlerServiceTestUtils
.
assertHandlerInfoMatches
(
actualHandlerInfo
{
type
:
"
example
/
new
"
preferredAction
:
Ci
.
nsIHandlerInfo
.
saveToDisk
alwaysAskBeforeHandling
:
false
preferredApplicationHandler
:
null
possibleApplicationHandlers
:
[
webHandlerApp
]
}
)
;
}
)
;
