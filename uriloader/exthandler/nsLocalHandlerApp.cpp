#
include
"
nsLocalHandlerApp
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIProcess
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsProxyRelease
.
h
"
NS_IMPL_ISUPPORTS
(
nsLocalHandlerApp
nsILocalHandlerApp
nsIHandlerApp
)
NS_IMETHODIMP
nsLocalHandlerApp
:
:
GetName
(
nsAString
&
aName
)
{
if
(
mName
.
IsEmpty
(
)
&
&
mExecutable
)
{
mExecutable
-
>
GetLeafName
(
aName
)
;
}
else
{
aName
.
Assign
(
mName
)
;
}
return
NS_OK
;
}
std
:
:
function
<
nsresult
(
nsString
&
)
>
nsLocalHandlerApp
:
:
GetPrettyNameOnNonMainThreadCallback
(
)
{
nsString
name
;
auto
result
=
GetName
(
name
)
;
return
[
name
result
]
(
nsString
&
aName
)
{
aName
=
name
;
return
result
;
}
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
PrettyNameAsync
(
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
NS_ENSURE_ARG_POINTER
(
aPromise
)
;
*
aPromise
=
nullptr
;
if
(
!
mExecutable
)
{
return
NS_ERROR_FAILURE
;
}
nsIGlobalObject
*
global
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
err
;
RefPtr
<
dom
:
:
Promise
>
outer
=
dom
:
:
Promise
:
:
Create
(
global
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
outer
.
forget
(
aPromise
)
;
nsAutoString
executablePath
;
nsresult
result
=
mExecutable
-
>
GetPath
(
executablePath
)
;
if
(
NS_FAILED
(
result
)
|
|
executablePath
.
IsEmpty
(
)
)
{
(
*
aPromise
)
-
>
MaybeReject
(
result
)
;
return
NS_OK
;
}
nsMainThreadPtrHandle
<
dom
:
:
Promise
>
promiseHolder
(
new
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
(
"
nsLocalHandlerApp
:
:
prettyExecutableName
Promise
"
*
aPromise
)
)
;
auto
prettyNameGetter
=
GetPrettyNameOnNonMainThreadCallback
(
)
;
result
=
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
__func__
[
promiseHolder
prettyNameGetter
=
std
:
:
move
(
prettyNameGetter
)
]
(
)
mutable
-
>
void
{
nsAutoString
prettyExecutableName
;
nsresult
result
=
prettyNameGetter
(
prettyExecutableName
)
;
DebugOnly
<
nsresult
>
rv
=
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
promiseHolder
=
std
:
:
move
(
promiseHolder
)
prettyExecutableName
=
std
:
:
move
(
prettyExecutableName
)
result
]
(
)
{
if
(
NS_FAILED
(
result
)
)
{
promiseHolder
.
get
(
)
-
>
MaybeReject
(
result
)
;
}
else
{
promiseHolder
.
get
(
)
-
>
MaybeResolve
(
prettyExecutableName
)
;
}
}
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
NS_DispatchToMainThread
failed
"
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
if
(
NS_FAILED
(
result
)
)
{
promiseHolder
.
get
(
)
-
>
MaybeReject
(
result
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
SetName
(
const
nsAString
&
aName
)
{
mName
.
Assign
(
aName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
SetDetailedDescription
(
const
nsAString
&
aDescription
)
{
mDetailedDescription
.
Assign
(
aDescription
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
GetDetailedDescription
(
nsAString
&
aDescription
)
{
aDescription
.
Assign
(
mDetailedDescription
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
Equals
(
nsIHandlerApp
*
aHandlerApp
bool
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
aHandlerApp
)
;
*
_retval
=
false
;
nsCOMPtr
<
nsILocalHandlerApp
>
localHandlerApp
=
do_QueryInterface
(
aHandlerApp
)
;
if
(
!
localHandlerApp
)
return
NS_OK
;
nsCOMPtr
<
nsIFile
>
executable
;
nsresult
rv
=
localHandlerApp
-
>
GetExecutable
(
getter_AddRefs
(
executable
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
!
executable
&
&
!
mExecutable
)
{
*
_retval
=
true
;
return
NS_OK
;
}
if
(
!
mExecutable
|
|
!
executable
)
return
NS_OK
;
uint32_t
len
;
localHandlerApp
-
>
GetParameterCount
(
&
len
)
;
if
(
mParameters
.
Length
(
)
!
=
len
)
return
NS_OK
;
for
(
uint32_t
idx
=
0
;
idx
<
mParameters
.
Length
(
)
;
idx
+
+
)
{
nsAutoString
param
;
if
(
NS_FAILED
(
localHandlerApp
-
>
GetParameter
(
idx
param
)
)
|
|
!
param
.
Equals
(
mParameters
[
idx
]
)
)
return
NS_OK
;
}
return
executable
-
>
Equals
(
mExecutable
_retval
)
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
LaunchWithURI
(
nsIURI
*
aURI
mozilla
:
:
dom
:
:
BrowsingContext
*
aBrowsingContext
)
{
nsAutoCString
spec
;
aURI
-
>
GetAsciiSpec
(
spec
)
;
return
LaunchWithIProcess
(
spec
)
;
}
nsresult
nsLocalHandlerApp
:
:
LaunchWithIProcess
(
const
nsCString
&
aArg
)
{
nsresult
rv
;
nsCOMPtr
<
nsIProcess
>
process
=
do_CreateInstance
(
NS_PROCESS_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
NS_FAILED
(
rv
=
process
-
>
Init
(
mExecutable
)
)
)
return
rv
;
const
char
*
string
=
aArg
.
get
(
)
;
return
process
-
>
Run
(
false
&
string
1
)
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
GetExecutable
(
nsIFile
*
*
aExecutable
)
{
NS_IF_ADDREF
(
*
aExecutable
=
mExecutable
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
SetExecutable
(
nsIFile
*
aExecutable
)
{
mExecutable
=
aExecutable
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
GetParameterCount
(
uint32_t
*
aParameterCount
)
{
*
aParameterCount
=
mParameters
.
Length
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
ClearParameters
(
)
{
mParameters
.
Clear
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
AppendParameter
(
const
nsAString
&
aParam
)
{
mParameters
.
AppendElement
(
aParam
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
GetParameter
(
uint32_t
parameterIndex
nsAString
&
_retval
)
{
if
(
mParameters
.
Length
(
)
<
=
parameterIndex
)
return
NS_ERROR_INVALID_ARG
;
_retval
.
Assign
(
mParameters
[
parameterIndex
]
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalHandlerApp
:
:
ParameterExists
(
const
nsAString
&
aParam
bool
*
_retval
)
{
*
_retval
=
mParameters
.
Contains
(
aParam
)
;
return
NS_OK
;
}
