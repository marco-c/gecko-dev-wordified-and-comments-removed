const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gExternalProtocolService
"
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
"
nsIExternalProtocolService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gHandlerServiceRDF
"
"
mozilla
.
org
/
uriloader
/
handler
-
service
-
rdf
;
1
"
"
nsIHandlerService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gMIMEService
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
function
HandlerService
(
)
{
Services
.
obs
.
addObserver
(
this
"
handlersvc
-
json
-
replace
"
true
)
;
}
HandlerService
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
220cc253
-
b60f
-
41f6
-
b9cf
-
fdcb325f970f
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISupportsWeakReference
Ci
.
nsIHandlerService
Ci
.
nsIObserver
]
)
__store
:
null
get
_store
(
)
{
if
(
!
this
.
__store
)
{
this
.
__store
=
new
JSONFile
(
{
path
:
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
handlers
.
json
"
)
dataPostProcessor
:
this
.
_dataPostProcessor
.
bind
(
this
)
}
)
;
this
.
__store
.
ensureDataReady
(
)
;
let
alreadyInjected
=
this
.
_migrateFromRDFIfNeeded
(
)
;
this
.
_injectDefaultProtocolHandlersIfNeeded
(
alreadyInjected
)
;
}
return
this
.
__store
;
}
_dataPostProcessor
(
data
)
{
return
data
.
defaultHandlersVersion
?
data
:
{
defaultHandlersVersion
:
{
}
mimeTypes
:
{
}
schemes
:
{
}
}
;
}
_migrateFromRDFIfNeeded
(
)
{
try
{
if
(
Services
.
prefs
.
getBoolPref
(
"
gecko
.
handlerService
.
migrated
"
)
)
{
return
false
;
}
}
catch
(
ex
)
{
}
try
{
let
rdfFile
=
FileUtils
.
getFile
(
"
ProfD
"
[
"
mimeTypes
.
rdf
"
]
)
;
if
(
rdfFile
.
exists
(
)
)
{
this
.
_migrateFromRDF
(
)
;
return
true
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
finally
{
Services
.
prefs
.
setBoolPref
(
"
gecko
.
handlerService
.
migrated
"
true
)
;
}
return
false
;
}
_migrateFromRDF
(
)
{
let
handlerInfoEnumerator
=
gHandlerServiceRDF
.
enumerate
(
)
;
while
(
handlerInfoEnumerator
.
hasMoreElements
(
)
)
{
let
handlerInfo
=
handlerInfoEnumerator
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIHandlerInfo
)
;
try
{
gHandlerServiceRDF
.
fillHandlerInfo
(
handlerInfo
"
"
)
;
this
.
store
(
handlerInfo
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
_injectDefaultProtocolHandlersIfNeeded
(
alreadyInjected
)
{
let
prefsDefaultHandlersVersion
;
try
{
prefsDefaultHandlersVersion
=
Services
.
prefs
.
getComplexValue
(
"
gecko
.
handlerService
.
defaultHandlersVersion
"
Ci
.
nsIPrefLocalizedString
)
;
}
catch
(
ex
)
{
if
(
ex
instanceof
Components
.
Exception
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_UNEXPECTED
)
{
return
;
}
throw
ex
;
}
try
{
prefsDefaultHandlersVersion
=
Number
(
prefsDefaultHandlersVersion
.
data
)
;
let
locale
=
Services
.
locale
.
getAppLocaleAsLangTag
(
)
;
let
defaultHandlersVersion
=
this
.
_store
.
data
.
defaultHandlersVersion
[
locale
]
|
|
0
;
if
(
defaultHandlersVersion
<
prefsDefaultHandlersVersion
)
{
if
(
!
alreadyInjected
)
{
this
.
_injectDefaultProtocolHandlers
(
)
;
}
this
.
_store
.
data
.
defaultHandlersVersion
[
locale
]
=
prefsDefaultHandlersVersion
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
_injectDefaultProtocolHandlers
(
)
{
let
schemesPrefBranch
=
Services
.
prefs
.
getBranch
(
"
gecko
.
handlerService
.
schemes
.
"
)
;
let
schemePrefList
=
schemesPrefBranch
.
getChildList
(
"
"
)
;
let
schemes
=
{
}
;
for
(
let
schemePrefName
of
schemePrefList
)
{
let
[
scheme
handlerNumber
attribute
]
=
schemePrefName
.
split
(
"
.
"
)
;
try
{
let
attrData
=
schemesPrefBranch
.
getComplexValue
(
schemePrefName
Ci
.
nsIPrefLocalizedString
)
.
data
;
if
(
!
(
scheme
in
schemes
)
)
{
schemes
[
scheme
]
=
{
}
;
}
if
(
!
(
handlerNumber
in
schemes
[
scheme
]
)
)
{
schemes
[
scheme
]
[
handlerNumber
]
=
{
}
;
}
schemes
[
scheme
]
[
handlerNumber
]
[
attribute
]
=
attrData
;
}
catch
(
ex
)
{
}
}
for
(
let
scheme
of
Object
.
keys
(
schemes
)
)
{
let
osDefaultHandlerFound
=
{
}
;
let
protoInfo
=
gExternalProtocolService
.
getProtocolHandlerInfoFromOS
(
scheme
osDefaultHandlerFound
)
;
if
(
this
.
exists
(
protoInfo
)
)
{
this
.
fillHandlerInfo
(
protoInfo
null
)
;
}
else
{
gExternalProtocolService
.
setProtocolHandlerDefaults
(
protoInfo
osDefaultHandlerFound
.
value
)
;
}
let
possibleHandlers
=
protoInfo
.
possibleApplicationHandlers
;
for
(
let
handlerNumber
of
Object
.
keys
(
schemes
[
scheme
]
)
)
{
let
handlerApp
=
this
.
handlerAppFromSerializable
(
schemes
[
scheme
]
[
handlerNumber
]
)
;
possibleHandlers
.
appendElement
(
handlerApp
false
)
;
}
this
.
store
(
protoInfo
)
;
}
}
_onDBChange
(
)
{
return
Task
.
spawn
(
function
*
(
)
{
if
(
this
.
__store
)
{
yield
this
.
__store
.
finalize
(
)
;
}
this
.
__store
=
null
;
}
.
bind
(
this
)
)
.
catch
(
Cu
.
reportError
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
!
=
"
handlersvc
-
json
-
replace
"
)
{
return
;
}
let
promise
=
this
.
_onDBChange
(
)
;
promise
.
then
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
handlersvc
-
json
-
replace
-
complete
"
)
;
}
)
;
}
enumerate
(
)
{
let
handlers
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
type
of
Object
.
keys
(
this
.
_store
.
data
.
mimeTypes
)
)
{
let
handler
=
gMIMEService
.
getFromTypeAndExtension
(
type
null
)
;
handlers
.
appendElement
(
handler
)
;
}
for
(
let
type
of
Object
.
keys
(
this
.
_store
.
data
.
schemes
)
)
{
let
handler
=
gExternalProtocolService
.
getProtocolHandlerInfo
(
type
)
;
handlers
.
appendElement
(
handler
)
;
}
return
handlers
.
enumerate
(
)
;
}
store
(
handlerInfo
)
{
let
handlerList
=
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
;
let
storedHandlerInfo
=
handlerList
[
handlerInfo
.
type
]
;
if
(
!
storedHandlerInfo
)
{
storedHandlerInfo
=
{
}
;
handlerList
[
handlerInfo
.
type
]
=
storedHandlerInfo
;
}
if
(
handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
saveToDisk
|
|
handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useSystemDefault
|
|
handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
handleInternally
)
{
storedHandlerInfo
.
action
=
handlerInfo
.
preferredAction
;
}
else
{
storedHandlerInfo
.
action
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
}
if
(
handlerInfo
.
alwaysAskBeforeHandling
)
{
storedHandlerInfo
.
ask
=
true
;
}
else
{
delete
storedHandlerInfo
.
ask
;
}
let
handlers
=
[
]
;
if
(
handlerInfo
.
preferredApplicationHandler
)
{
handlers
.
push
(
handlerInfo
.
preferredApplicationHandler
)
;
}
let
enumerator
=
handlerInfo
.
possibleApplicationHandlers
.
enumerate
(
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
handler
=
enumerator
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIHandlerApp
)
;
if
(
!
handlers
.
some
(
h
=
>
h
.
equals
(
handler
)
)
)
{
handlers
.
push
(
handler
)
;
}
}
let
serializableHandlers
=
handlers
.
map
(
h
=
>
this
.
handlerAppToSerializable
(
h
)
)
.
filter
(
h
=
>
h
)
;
if
(
serializableHandlers
.
length
)
{
if
(
!
handlerInfo
.
preferredApplicationHandler
)
{
serializableHandlers
.
unshift
(
null
)
;
}
storedHandlerInfo
.
handlers
=
serializableHandlers
;
}
else
{
delete
storedHandlerInfo
.
handlers
;
}
if
(
this
.
_isMIMEInfo
(
handlerInfo
)
)
{
let
extEnumerator
=
handlerInfo
.
getFileExtensions
(
)
;
let
extensions
=
storedHandlerInfo
.
extensions
|
|
[
]
;
while
(
extEnumerator
.
hasMore
(
)
)
{
let
extension
=
extEnumerator
.
getNext
(
)
.
toLowerCase
(
)
;
if
(
!
extensions
.
includes
(
extension
)
)
{
extensions
.
push
(
extension
)
;
}
}
if
(
extensions
.
length
)
{
storedHandlerInfo
.
extensions
=
extensions
;
}
else
{
delete
storedHandlerInfo
.
extensions
;
}
}
this
.
_store
.
saveSoon
(
)
;
}
fillHandlerInfo
(
handlerInfo
overrideType
)
{
let
type
=
overrideType
|
|
handlerInfo
.
type
;
let
storedHandlerInfo
=
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
[
type
]
;
if
(
!
storedHandlerInfo
)
{
throw
new
Components
.
Exception
(
"
handlerSvc
fillHandlerInfo
:
don
'
t
know
this
type
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
handlerInfo
.
preferredAction
=
storedHandlerInfo
.
action
;
handlerInfo
.
alwaysAskBeforeHandling
=
!
!
storedHandlerInfo
.
ask
;
let
isFirstItem
=
true
;
for
(
let
handler
of
storedHandlerInfo
.
handlers
|
|
[
null
]
)
{
let
handlerApp
=
this
.
handlerAppFromSerializable
(
handler
|
|
{
}
)
;
if
(
isFirstItem
)
{
isFirstItem
=
false
;
handlerInfo
.
preferredApplicationHandler
=
handlerApp
;
}
if
(
handlerApp
)
{
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
handlerApp
)
;
}
}
if
(
this
.
_isMIMEInfo
(
handlerInfo
)
&
&
storedHandlerInfo
.
extensions
)
{
for
(
let
extension
of
storedHandlerInfo
.
extensions
)
{
handlerInfo
.
appendExtension
(
extension
)
;
}
}
}
handlerAppToSerializable
(
handler
)
{
if
(
handler
instanceof
Ci
.
nsILocalHandlerApp
)
{
return
{
name
:
handler
.
name
path
:
handler
.
executable
.
path
}
;
}
else
if
(
handler
instanceof
Ci
.
nsIWebHandlerApp
)
{
return
{
name
:
handler
.
name
uriTemplate
:
handler
.
uriTemplate
}
;
}
else
if
(
handler
instanceof
Ci
.
nsIDBusHandlerApp
)
{
return
{
name
:
handler
.
name
service
:
handler
.
service
method
:
handler
.
method
objectPath
:
handler
.
objectPath
dBusInterface
:
handler
.
dBusInterface
}
;
}
return
null
;
}
handlerAppFromSerializable
(
handlerObj
)
{
let
handlerApp
;
if
(
"
path
"
in
handlerObj
)
{
try
{
let
file
=
new
FileUtils
.
File
(
handlerObj
.
path
)
;
if
(
!
file
.
exists
(
)
)
{
return
null
;
}
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
handlerApp
.
executable
=
file
;
}
catch
(
ex
)
{
return
null
;
}
}
else
if
(
"
uriTemplate
"
in
handlerObj
)
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
handlerApp
.
uriTemplate
=
handlerObj
.
uriTemplate
;
}
else
if
(
"
service
"
in
handlerObj
)
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
dbus
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIDBusHandlerApp
)
;
handlerApp
.
service
=
handlerObj
.
service
;
handlerApp
.
method
=
handlerObj
.
method
;
handlerApp
.
objectPath
=
handlerObj
.
objectPath
;
handlerApp
.
dBusInterface
=
handlerObj
.
dBusInterface
;
}
else
{
return
null
;
}
handlerApp
.
name
=
handlerObj
.
name
;
return
handlerApp
;
}
_getHandlerListByHandlerInfoType
(
handlerInfo
)
{
return
this
.
_isMIMEInfo
(
handlerInfo
)
?
this
.
_store
.
data
.
mimeTypes
:
this
.
_store
.
data
.
schemes
;
}
_isMIMEInfo
(
handlerInfo
)
{
return
handlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
handlerInfo
.
type
.
includes
(
"
/
"
)
;
}
exists
(
handlerInfo
)
{
return
handlerInfo
.
type
in
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
;
}
remove
(
handlerInfo
)
{
delete
this
.
_getHandlerListByHandlerInfoType
(
handlerInfo
)
[
handlerInfo
.
type
]
;
this
.
_store
.
saveSoon
(
)
;
}
getTypeFromExtension
(
fileExtension
)
{
let
extension
=
fileExtension
.
toLowerCase
(
)
;
let
mimeTypes
=
this
.
_store
.
data
.
mimeTypes
;
for
(
let
type
of
Object
.
keys
(
mimeTypes
)
)
{
if
(
mimeTypes
[
type
]
.
extensions
&
&
mimeTypes
[
type
]
.
extensions
.
includes
(
extension
)
)
{
return
type
;
}
}
return
"
"
;
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
HandlerService
]
)
;
