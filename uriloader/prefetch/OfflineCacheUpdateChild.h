#
ifndef
nsOfflineCacheUpdateChild_h
#
define
nsOfflineCacheUpdateChild_h
#
include
"
mozilla
/
docshell
/
POfflineCacheUpdateChild
.
h
"
#
include
"
nsIOfflineCacheUpdate
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsWeakReference
.
h
"
class
nsPIDOMWindowInner
;
namespace
mozilla
{
namespace
docshell
{
class
OfflineCacheUpdateChild
:
public
nsIOfflineCacheUpdate
public
POfflineCacheUpdateChild
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOFFLINECACHEUPDATE
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvNotifyStateEvent
(
const
uint32_t
&
stateEvent
const
uint64_t
&
byteProgress
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvAssociateDocuments
(
const
nsCString
&
cacheGroupId
const
nsCString
&
cacheClientId
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvFinish
(
const
bool
&
succeeded
const
bool
&
isUpgrade
)
override
;
explicit
OfflineCacheUpdateChild
(
nsPIDOMWindowInner
*
aWindow
)
;
void
SetDocument
(
nsIDocument
*
aDocument
)
;
private
:
~
OfflineCacheUpdateChild
(
)
;
nsresult
AssociateDocument
(
nsIDocument
*
aDocument
nsIApplicationCache
*
aApplicationCache
)
;
void
GatherObservers
(
nsCOMArray
<
nsIOfflineCacheUpdateObserver
>
&
aObservers
)
;
nsresult
Finish
(
)
;
enum
{
STATE_UNINITIALIZED
STATE_INITIALIZED
STATE_CHECKING
STATE_DOWNLOADING
STATE_CANCELLED
STATE_FINISHED
}
mState
;
bool
mIsUpgrade
;
bool
mSucceeded
;
nsCString
mUpdateDomain
;
nsCOMPtr
<
nsIURI
>
mManifestURI
;
nsCOMPtr
<
nsIURI
>
mDocumentURI
;
nsCOMPtr
<
nsIPrincipal
>
mLoadingPrincipal
;
nsCOMPtr
<
nsIObserverService
>
mObserverService
;
nsCOMArray
<
nsIWeakReference
>
mWeakObservers
;
nsCOMArray
<
nsIOfflineCacheUpdateObserver
>
mObservers
;
nsCOMPtr
<
nsIDocument
>
mDocument
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
uint64_t
mByteProgress
;
}
;
}
}
#
endif
