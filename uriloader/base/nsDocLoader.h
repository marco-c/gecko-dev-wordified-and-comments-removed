#
ifndef
nsDocLoader_h__
#
define
nsDocLoader_h__
#
include
"
nsIDocumentLoader
.
h
"
#
include
"
nsIWebProgress
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsIRequestObserver
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIProgressEventSink
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
namespace
dom
{
class
BrowserBridgeChild
;
}
}
#
define
NS_THIS_DOCLOADER_IMPL_CID
\
{
/
*
b4ec8387
-
98aa
-
4c08
-
93b6
-
6d23069c06f2
*
/
\
0xb4ec8387
0x98aa
0x4c08
{
\
0x93
0xb6
0x6d
0x23
0x06
0x9c
0x06
0xf2
\
}
\
}
class
nsDocLoader
:
public
nsIDocumentLoader
public
nsIRequestObserver
public
nsSupportsWeakReference
public
nsIProgressEventSink
public
nsIWebProgress
public
nsIInterfaceRequestor
public
nsIChannelEventSink
public
nsISupportsPriority
{
public
:
using
BrowserBridgeChild
=
mozilla
:
:
dom
:
:
BrowserBridgeChild
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_THIS_DOCLOADER_IMPL_CID
)
nsDocLoader
(
)
;
[
[
nodiscard
]
]
virtual
nsresult
Init
(
)
;
static
already_AddRefed
<
nsDocLoader
>
GetAsDocLoader
(
nsISupports
*
aSupports
)
;
static
nsISupports
*
GetAsSupports
(
nsDocLoader
*
aDocLoader
)
{
return
static_cast
<
nsIDocumentLoader
*
>
(
aDocLoader
)
;
}
[
[
nodiscard
]
]
static
nsresult
AddDocLoaderAsChildOfRoot
(
nsDocLoader
*
aDocLoader
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
nsDocLoader
nsIDocumentLoader
)
NS_DECL_NSIDOCUMENTLOADER
NS_DECL_NSIPROGRESSEVENTSINK
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSIWEBPROGRESS
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSISUPPORTSPRIORITY
;
[
[
nodiscard
]
]
nsresult
RemoveChildLoader
(
nsDocLoader
*
aChild
)
;
[
[
nodiscard
]
]
nsresult
AddChildLoader
(
nsDocLoader
*
aChild
)
;
nsDocLoader
*
GetParent
(
)
const
{
return
mParent
;
}
struct
nsListenerInfo
{
nsListenerInfo
(
nsIWeakReference
*
aListener
unsigned
long
aNotifyMask
)
:
mWeakListener
(
aListener
)
mNotifyMask
(
aNotifyMask
)
{
}
nsWeakPtr
mWeakListener
;
unsigned
long
mNotifyMask
;
}
;
void
OnSecurityChange
(
nsISupports
*
aContext
uint32_t
aState
)
;
void
SetDocumentOpenedButNotLoaded
(
)
{
mDocumentOpenedButNotLoaded
=
true
;
}
bool
TreatAsBackgroundLoad
(
)
;
void
SetFakeOnLoadDispatched
(
)
{
mHasFakeOnLoadDispatched
=
true
;
}
;
bool
HasFakeOnLoadDispatched
(
)
{
return
mHasFakeOnLoadDispatched
;
}
;
void
ResetToFirstLoad
(
)
{
mHasFakeOnLoadDispatched
=
false
;
mIsReadyToHandlePostMessage
=
false
;
mTreatAsBackgroundLoad
=
false
;
}
;
void
OOPChildLoadStarted
(
BrowserBridgeChild
*
aChild
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mOOPChildrenLoading
.
Contains
(
aChild
)
)
;
mOOPChildrenLoading
.
AppendElement
(
aChild
)
;
}
void
OOPChildLoadDone
(
BrowserBridgeChild
*
aChild
)
{
if
(
mOOPChildrenLoading
.
RemoveElement
(
aChild
)
)
{
DocLoaderIsEmpty
(
true
)
;
}
}
uint32_t
ChildCount
(
)
const
{
return
mChildList
.
Length
(
)
;
}
protected
:
virtual
~
nsDocLoader
(
)
;
[
[
nodiscard
]
]
virtual
nsresult
SetDocLoaderParent
(
nsDocLoader
*
aLoader
)
;
bool
IsBusy
(
)
;
void
SetBackgroundLoadIframe
(
)
;
void
Destroy
(
)
;
virtual
void
DestroyChildren
(
)
;
nsIDocumentLoader
*
ChildAt
(
int32_t
i
)
{
return
mChildList
.
SafeElementAt
(
i
nullptr
)
;
}
void
FireOnProgressChange
(
nsDocLoader
*
aLoadInitiator
nsIRequest
*
request
int64_t
aProgress
int64_t
aProgressMax
int64_t
aProgressDelta
int64_t
aTotalProgress
int64_t
aMaxTotalProgress
)
;
typedef
AutoTArray
<
RefPtr
<
nsDocLoader
>
8
>
WebProgressList
;
void
GatherAncestorWebProgresses
(
WebProgressList
&
aList
)
;
void
FireOnStateChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
request
int32_t
aStateFlags
nsresult
aStatus
)
;
void
DoFireOnStateChange
(
nsIWebProgress
*
const
aProgress
nsIRequest
*
const
request
int32_t
&
aStateFlags
const
nsresult
aStatus
)
;
void
FireOnStatusChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsresult
aStatus
const
char16_t
*
aMessage
)
;
void
FireOnLocationChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsIURI
*
aUri
uint32_t
aFlags
)
;
[
[
nodiscard
]
]
bool
RefreshAttempted
(
nsIWebProgress
*
aWebProgress
nsIURI
*
aURI
int32_t
aDelay
bool
aSameURI
)
;
virtual
void
OnRedirectStateChange
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aRedirectFlags
uint32_t
aStateFlags
)
{
}
void
doStartDocumentLoad
(
)
;
void
doStartURLLoad
(
nsIRequest
*
request
int32_t
aExtraFlags
)
;
void
doStopURLLoad
(
nsIRequest
*
request
nsresult
aStatus
)
;
void
doStopDocumentLoad
(
nsIRequest
*
request
nsresult
aStatus
)
;
void
NotifyDoneWithOnload
(
nsDocLoader
*
aParent
)
;
[
[
nodiscard
]
]
bool
ChildEnteringOnload
(
nsIDocumentLoader
*
aChild
)
{
return
mChildrenInOnload
.
AppendObject
(
aChild
)
;
}
void
ChildDoneWithOnload
(
nsIDocumentLoader
*
aChild
)
{
mChildrenInOnload
.
RemoveObject
(
aChild
)
;
DocLoaderIsEmpty
(
true
)
;
}
void
DocLoaderIsEmpty
(
bool
aFlushLayout
const
Maybe
<
nsresult
>
&
aOverrideStatus
=
mozilla
:
:
Nothing
(
)
)
;
protected
:
struct
nsStatusInfo
:
public
mozilla
:
:
LinkedListElement
<
nsStatusInfo
>
{
nsString
mStatusMessage
;
nsresult
mStatusCode
;
nsIRequest
*
const
mRequest
;
explicit
nsStatusInfo
(
nsIRequest
*
aRequest
)
:
mStatusCode
(
NS_ERROR_NOT_INITIALIZED
)
mRequest
(
aRequest
)
{
MOZ_COUNT_CTOR
(
nsStatusInfo
)
;
}
MOZ_COUNTED_DTOR
(
nsStatusInfo
)
}
;
struct
nsRequestInfo
:
public
PLDHashEntryHdr
{
explicit
nsRequestInfo
(
const
void
*
key
)
:
mKey
(
key
)
mCurrentProgress
(
0
)
mMaxProgress
(
0
)
mUploading
(
false
)
mLastStatus
(
nullptr
)
{
MOZ_COUNT_CTOR
(
nsRequestInfo
)
;
}
MOZ_COUNTED_DTOR
(
nsRequestInfo
)
nsIRequest
*
Request
(
)
{
return
static_cast
<
nsIRequest
*
>
(
const_cast
<
void
*
>
(
mKey
)
)
;
}
const
void
*
mKey
;
int64_t
mCurrentProgress
;
int64_t
mMaxProgress
;
bool
mUploading
;
mozilla
:
:
UniquePtr
<
nsStatusInfo
>
mLastStatus
;
}
;
static
void
RequestInfoHashInitEntry
(
PLDHashEntryHdr
*
entry
const
void
*
key
)
;
static
void
RequestInfoHashClearEntry
(
PLDHashTable
*
table
PLDHashEntryHdr
*
entry
)
;
nsCOMPtr
<
nsIRequest
>
mDocumentRequest
;
nsDocLoader
*
mParent
;
typedef
nsAutoTObserverArray
<
nsListenerInfo
8
>
ListenerArray
;
ListenerArray
mListenerInfoList
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
nsTObserverArray
<
nsDocLoader
*
>
mChildList
;
int32_t
mProgressStateFlags
;
int64_t
mCurrentSelfProgress
;
int64_t
mMaxSelfProgress
;
int64_t
mCurrentTotalProgress
;
int64_t
mMaxTotalProgress
;
PLDHashTable
mRequestInfoHash
;
int64_t
mCompletedTotalProgress
;
mozilla
:
:
LinkedList
<
nsStatusInfo
>
mStatusInfoList
;
bool
mIsLoadingDocument
;
bool
mIsRestoringDocument
;
bool
mDontFlushLayout
;
bool
mIsFlushingLayout
;
bool
mTreatAsBackgroundLoad
;
private
:
bool
mHasFakeOnLoadDispatched
;
bool
mIsReadyToHandlePostMessage
;
bool
mDocumentOpenedButNotLoaded
;
static
const
PLDHashTableOps
sRequestInfoHashOps
;
nsCOMArray
<
nsIDocumentLoader
>
mChildrenInOnload
;
nsTArray
<
const
BrowserBridgeChild
*
>
mOOPChildrenLoading
;
int64_t
GetMaxTotalProgress
(
)
;
nsresult
AddRequestInfo
(
nsIRequest
*
aRequest
)
;
void
RemoveRequestInfo
(
nsIRequest
*
aRequest
)
;
nsRequestInfo
*
GetRequestInfo
(
nsIRequest
*
aRequest
)
const
;
void
ClearRequestInfoHash
(
)
;
int64_t
CalculateMaxProgress
(
)
;
void
ClearInternalProgress
(
)
;
bool
IsBlockingLoadEvent
(
)
const
{
return
mIsLoadingDocument
|
|
mDocumentOpenedButNotLoaded
;
}
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsDocLoader
NS_THIS_DOCLOADER_IMPL_CID
)
static
inline
nsISupports
*
ToSupports
(
nsDocLoader
*
aDocLoader
)
{
return
static_cast
<
nsIDocumentLoader
*
>
(
aDocLoader
)
;
}
#
endif
