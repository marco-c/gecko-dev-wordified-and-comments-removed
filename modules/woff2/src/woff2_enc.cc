#
include
<
woff2
/
encode
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
complex
>
#
include
<
cstring
>
#
include
<
limits
>
#
include
<
string
>
#
include
<
vector
>
#
include
<
brotli
/
encode
.
h
>
#
include
"
.
/
buffer
.
h
"
#
include
"
.
/
font
.
h
"
#
include
"
.
/
normalize
.
h
"
#
include
"
.
/
round
.
h
"
#
include
"
.
/
store_bytes
.
h
"
#
include
"
.
/
table_tags
.
h
"
#
include
"
.
/
transform
.
h
"
#
include
"
.
/
variable_length
.
h
"
#
include
"
.
/
woff2_common
.
h
"
namespace
woff2
{
namespace
{
const
size_t
kWoff2HeaderSize
=
48
;
const
size_t
kWoff2EntrySize
=
20
;
bool
Compress
(
const
uint8_t
*
data
const
size_t
len
uint8_t
*
result
uint32_t
*
result_len
BrotliEncoderMode
mode
int
quality
)
{
size_t
compressed_len
=
*
result_len
;
if
(
BrotliEncoderCompress
(
quality
BROTLI_DEFAULT_WINDOW
mode
len
data
&
compressed_len
result
)
=
=
0
)
{
return
false
;
}
*
result_len
=
compressed_len
;
return
true
;
}
bool
Woff2Compress
(
const
uint8_t
*
data
const
size_t
len
uint8_t
*
result
uint32_t
*
result_len
int
quality
)
{
return
Compress
(
data
len
result
result_len
BROTLI_MODE_FONT
quality
)
;
}
bool
TextCompress
(
const
uint8_t
*
data
const
size_t
len
uint8_t
*
result
uint32_t
*
result_len
int
quality
)
{
return
Compress
(
data
len
result
result_len
BROTLI_MODE_TEXT
quality
)
;
}
int
KnownTableIndex
(
uint32_t
tag
)
{
for
(
int
i
=
0
;
i
<
63
;
+
+
i
)
{
if
(
tag
=
=
kKnownTags
[
i
]
)
return
i
;
}
return
63
;
}
void
StoreTableEntry
(
const
Table
&
table
size_t
*
offset
uint8_t
*
dst
)
{
uint8_t
flag_byte
=
(
table
.
flags
&
0xC0
)
|
KnownTableIndex
(
table
.
tag
)
;
dst
[
(
*
offset
)
+
+
]
=
flag_byte
;
if
(
(
flag_byte
&
0x3f
)
=
=
0x3f
)
{
StoreU32
(
table
.
tag
offset
dst
)
;
}
StoreBase128
(
table
.
src_length
offset
dst
)
;
if
(
(
table
.
flags
&
kWoff2FlagsTransform
)
!
=
0
)
{
StoreBase128
(
table
.
transform_length
offset
dst
)
;
}
}
size_t
TableEntrySize
(
const
Table
&
table
)
{
uint8_t
flag_byte
=
KnownTableIndex
(
table
.
tag
)
;
size_t
size
=
(
(
flag_byte
&
0x3f
)
!
=
0x3f
)
?
1
:
5
;
size
+
=
Base128Size
(
table
.
src_length
)
;
if
(
(
table
.
flags
&
kWoff2FlagsTransform
)
!
=
0
)
{
size
+
=
Base128Size
(
table
.
transform_length
)
;
}
return
size
;
}
size_t
ComputeWoff2Length
(
const
FontCollection
&
font_collection
const
std
:
:
vector
<
Table
>
&
tables
std
:
:
map
<
std
:
:
pair
<
uint32_t
uint32_t
>
uint16_t
>
index_by_tag_offset
size_t
compressed_data_length
size_t
extended_metadata_length
)
{
size_t
size
=
kWoff2HeaderSize
;
for
(
const
auto
&
table
:
tables
)
{
size
+
=
TableEntrySize
(
table
)
;
}
if
(
font_collection
.
flavor
=
=
kTtcFontFlavor
)
{
size
+
=
4
;
size
+
=
Size255UShort
(
font_collection
.
fonts
.
size
(
)
)
;
size
+
=
4
*
font_collection
.
fonts
.
size
(
)
;
for
(
const
auto
&
font
:
font_collection
.
fonts
)
{
size
+
=
Size255UShort
(
font
.
tables
.
size
(
)
)
;
for
(
const
auto
&
entry
:
font
.
tables
)
{
const
Font
:
:
Table
&
table
=
entry
.
second
;
if
(
table
.
tag
&
0x80808080
)
continue
;
std
:
:
pair
<
uint32_t
uint32_t
>
tag_offset
(
table
.
tag
table
.
offset
)
;
uint16_t
table_index
=
index_by_tag_offset
[
tag_offset
]
;
size
+
=
Size255UShort
(
table_index
)
;
}
}
}
size
+
=
compressed_data_length
;
size
=
Round4
(
size
)
;
size
+
=
extended_metadata_length
;
return
size
;
}
size_t
ComputeUncompressedLength
(
const
Font
&
font
)
{
size_t
size
=
12
+
16
*
font
.
num_tables
;
for
(
const
auto
&
entry
:
font
.
tables
)
{
const
Font
:
:
Table
&
table
=
entry
.
second
;
if
(
table
.
tag
&
0x80808080
)
continue
;
if
(
table
.
IsReused
(
)
)
continue
;
size
+
=
Round4
(
table
.
length
)
;
}
return
size
;
}
size_t
ComputeUncompressedLength
(
const
FontCollection
&
font_collection
)
{
if
(
font_collection
.
flavor
!
=
kTtcFontFlavor
)
{
return
ComputeUncompressedLength
(
font_collection
.
fonts
[
0
]
)
;
}
size_t
size
=
CollectionHeaderSize
(
font_collection
.
header_version
font_collection
.
fonts
.
size
(
)
)
;
for
(
const
auto
&
font
:
font_collection
.
fonts
)
{
size
+
=
ComputeUncompressedLength
(
font
)
;
}
return
size
;
}
size_t
ComputeTotalTransformLength
(
const
Font
&
font
)
{
size_t
total
=
0
;
for
(
const
auto
&
i
:
font
.
tables
)
{
const
Font
:
:
Table
&
table
=
i
.
second
;
if
(
table
.
IsReused
(
)
)
{
continue
;
}
if
(
table
.
tag
&
0x80808080
|
|
!
font
.
FindTable
(
table
.
tag
^
0x80808080
)
)
{
total
+
=
table
.
length
;
}
}
return
total
;
}
}
size_t
MaxWOFF2CompressedSize
(
const
uint8_t
*
data
size_t
length
)
{
return
MaxWOFF2CompressedSize
(
data
length
"
"
)
;
}
size_t
MaxWOFF2CompressedSize
(
const
uint8_t
*
data
size_t
length
const
std
:
:
string
&
extended_metadata
)
{
return
length
+
1024
+
extended_metadata
.
length
(
)
;
}
uint32_t
CompressedBufferSize
(
uint32_t
original_size
)
{
return
1
.
2
*
original_size
+
10240
;
}
bool
TransformFontCollection
(
FontCollection
*
font_collection
)
{
for
(
auto
&
font
:
font_collection
-
>
fonts
)
{
if
(
!
TransformGlyfAndLocaTables
(
&
font
)
)
{
#
ifdef
FONT_COMPRESSION_BIN
fprintf
(
stderr
"
glyf
/
loca
transformation
failed
.
\
n
"
)
;
#
endif
return
FONT_COMPRESSION_FAILURE
(
)
;
}
}
return
true
;
}
bool
ConvertTTFToWOFF2
(
const
uint8_t
*
data
size_t
length
uint8_t
*
result
size_t
*
result_length
)
{
WOFF2Params
params
;
return
ConvertTTFToWOFF2
(
data
length
result
result_length
params
)
;
}
bool
ConvertTTFToWOFF2
(
const
uint8_t
*
data
size_t
length
uint8_t
*
result
size_t
*
result_length
const
WOFF2Params
&
params
)
{
FontCollection
font_collection
;
if
(
!
ReadFontCollection
(
data
length
&
font_collection
)
)
{
#
ifdef
FONT_COMPRESSION_BIN
fprintf
(
stderr
"
Parsing
of
the
input
font
failed
.
\
n
"
)
;
#
endif
return
FONT_COMPRESSION_FAILURE
(
)
;
}
if
(
!
NormalizeFontCollection
(
&
font_collection
)
)
{
return
FONT_COMPRESSION_FAILURE
(
)
;
}
if
(
params
.
allow_transforms
&
&
!
TransformFontCollection
(
&
font_collection
)
)
{
return
FONT_COMPRESSION_FAILURE
(
)
;
}
else
{
for
(
auto
&
font
:
font_collection
.
fonts
)
{
Font
:
:
Table
*
glyf_table
=
font
.
FindTable
(
kGlyfTableTag
)
;
Font
:
:
Table
*
loca_table
=
font
.
FindTable
(
kLocaTableTag
)
;
if
(
glyf_table
)
{
glyf_table
-
>
flag_byte
|
=
0xc0
;
}
if
(
loca_table
)
{
loca_table
-
>
flag_byte
|
=
0xc0
;
}
}
}
size_t
total_transform_length
=
0
;
for
(
const
auto
&
font
:
font_collection
.
fonts
)
{
total_transform_length
+
=
ComputeTotalTransformLength
(
font
)
;
}
size_t
compression_buffer_size
=
CompressedBufferSize
(
total_transform_length
)
;
std
:
:
vector
<
uint8_t
>
compression_buf
(
compression_buffer_size
)
;
uint32_t
total_compressed_length
=
compression_buffer_size
;
std
:
:
vector
<
uint8_t
>
transform_buf
(
total_transform_length
)
;
size_t
transform_offset
=
0
;
for
(
const
auto
&
font
:
font_collection
.
fonts
)
{
for
(
const
auto
tag
:
font
.
OutputOrderedTags
(
)
)
{
const
Font
:
:
Table
&
original
=
font
.
tables
.
at
(
tag
)
;
if
(
original
.
IsReused
(
)
)
continue
;
if
(
tag
&
0x80808080
)
continue
;
const
Font
:
:
Table
*
table_to_store
=
font
.
FindTable
(
tag
^
0x80808080
)
;
if
(
table_to_store
=
=
NULL
)
table_to_store
=
&
original
;
StoreBytes
(
table_to_store
-
>
data
table_to_store
-
>
length
&
transform_offset
&
transform_buf
[
0
]
)
;
}
}
if
(
!
Woff2Compress
(
transform_buf
.
data
(
)
total_transform_length
&
compression_buf
[
0
]
&
total_compressed_length
params
.
brotli_quality
)
)
{
#
ifdef
FONT_COMPRESSION_BIN
fprintf
(
stderr
"
Compression
of
combined
table
failed
.
\
n
"
)
;
#
endif
return
FONT_COMPRESSION_FAILURE
(
)
;
}
#
ifdef
FONT_COMPRESSION_BIN
fprintf
(
stderr
"
Compressed
%
zu
to
%
u
.
\
n
"
total_transform_length
total_compressed_length
)
;
#
endif
uint32_t
compressed_metadata_buf_length
=
CompressedBufferSize
(
params
.
extended_metadata
.
length
(
)
)
;
std
:
:
vector
<
uint8_t
>
compressed_metadata_buf
(
compressed_metadata_buf_length
)
;
if
(
params
.
extended_metadata
.
length
(
)
>
0
)
{
if
(
!
TextCompress
(
(
const
uint8_t
*
)
params
.
extended_metadata
.
data
(
)
params
.
extended_metadata
.
length
(
)
compressed_metadata_buf
.
data
(
)
&
compressed_metadata_buf_length
params
.
brotli_quality
)
)
{
#
ifdef
FONT_COMPRESSION_BIN
fprintf
(
stderr
"
Compression
of
extended
metadata
failed
.
\
n
"
)
;
#
endif
return
FONT_COMPRESSION_FAILURE
(
)
;
}
}
else
{
compressed_metadata_buf_length
=
0
;
}
std
:
:
vector
<
Table
>
tables
;
std
:
:
map
<
std
:
:
pair
<
uint32_t
uint32_t
>
uint16_t
>
index_by_tag_offset
;
for
(
const
auto
&
font
:
font_collection
.
fonts
)
{
for
(
const
auto
tag
:
font
.
OutputOrderedTags
(
)
)
{
const
Font
:
:
Table
&
src_table
=
font
.
tables
.
at
(
tag
)
;
if
(
src_table
.
IsReused
(
)
)
{
continue
;
}
std
:
:
pair
<
uint32_t
uint32_t
>
tag_offset
(
src_table
.
tag
src_table
.
offset
)
;
if
(
index_by_tag_offset
.
find
(
tag_offset
)
=
=
index_by_tag_offset
.
end
(
)
)
{
index_by_tag_offset
[
tag_offset
]
=
tables
.
size
(
)
;
}
else
{
return
false
;
}
Table
table
;
table
.
tag
=
src_table
.
tag
;
table
.
flags
=
src_table
.
flag_byte
;
table
.
src_length
=
src_table
.
length
;
table
.
transform_length
=
src_table
.
length
;
const
uint8_t
*
transformed_data
=
src_table
.
data
;
const
Font
:
:
Table
*
transformed_table
=
font
.
FindTable
(
src_table
.
tag
^
0x80808080
)
;
if
(
transformed_table
!
=
NULL
)
{
table
.
flags
=
transformed_table
-
>
flag_byte
;
table
.
flags
|
=
kWoff2FlagsTransform
;
table
.
transform_length
=
transformed_table
-
>
length
;
transformed_data
=
transformed_table
-
>
data
;
}
tables
.
push_back
(
table
)
;
}
}
size_t
woff2_length
=
ComputeWoff2Length
(
font_collection
tables
index_by_tag_offset
total_compressed_length
compressed_metadata_buf_length
)
;
if
(
woff2_length
>
*
result_length
)
{
#
ifdef
FONT_COMPRESSION_BIN
fprintf
(
stderr
"
Result
allocation
was
too
small
(
%
zd
vs
%
zd
bytes
)
.
\
n
"
*
result_length
woff2_length
)
;
#
endif
return
FONT_COMPRESSION_FAILURE
(
)
;
}
*
result_length
=
woff2_length
;
size_t
offset
=
0
;
StoreU32
(
kWoff2Signature
&
offset
result
)
;
if
(
font_collection
.
flavor
!
=
kTtcFontFlavor
)
{
StoreU32
(
font_collection
.
fonts
[
0
]
.
flavor
&
offset
result
)
;
}
else
{
StoreU32
(
kTtcFontFlavor
&
offset
result
)
;
}
StoreU32
(
woff2_length
&
offset
result
)
;
Store16
(
tables
.
size
(
)
&
offset
result
)
;
Store16
(
0
&
offset
result
)
;
StoreU32
(
ComputeUncompressedLength
(
font_collection
)
&
offset
result
)
;
StoreU32
(
total_compressed_length
&
offset
result
)
;
Store16
(
1
&
offset
result
)
;
Store16
(
0
&
offset
result
)
;
if
(
compressed_metadata_buf_length
>
0
)
{
StoreU32
(
woff2_length
-
compressed_metadata_buf_length
&
offset
result
)
;
StoreU32
(
compressed_metadata_buf_length
&
offset
result
)
;
StoreU32
(
params
.
extended_metadata
.
length
(
)
&
offset
result
)
;
}
else
{
StoreU32
(
0
&
offset
result
)
;
StoreU32
(
0
&
offset
result
)
;
StoreU32
(
0
&
offset
result
)
;
}
StoreU32
(
0
&
offset
result
)
;
StoreU32
(
0
&
offset
result
)
;
for
(
const
auto
&
table
:
tables
)
{
StoreTableEntry
(
table
&
offset
result
)
;
}
if
(
font_collection
.
flavor
=
=
kTtcFontFlavor
)
{
StoreU32
(
font_collection
.
header_version
&
offset
result
)
;
Store255UShort
(
font_collection
.
fonts
.
size
(
)
&
offset
result
)
;
for
(
const
Font
&
font
:
font_collection
.
fonts
)
{
uint16_t
num_tables
=
0
;
for
(
const
auto
&
entry
:
font
.
tables
)
{
const
Font
:
:
Table
&
table
=
entry
.
second
;
if
(
table
.
tag
&
0x80808080
)
continue
;
num_tables
+
+
;
}
Store255UShort
(
num_tables
&
offset
result
)
;
StoreU32
(
font
.
flavor
&
offset
result
)
;
for
(
const
auto
&
entry
:
font
.
tables
)
{
const
Font
:
:
Table
&
table
=
entry
.
second
;
if
(
table
.
tag
&
0x80808080
)
continue
;
uint32_t
table_offset
=
table
.
IsReused
(
)
?
table
.
reuse_of
-
>
offset
:
table
.
offset
;
uint32_t
table_length
=
table
.
IsReused
(
)
?
table
.
reuse_of
-
>
length
:
table
.
length
;
std
:
:
pair
<
uint32_t
uint32_t
>
tag_offset
(
table
.
tag
table_offset
)
;
if
(
index_by_tag_offset
.
find
(
tag_offset
)
=
=
index_by_tag_offset
.
end
(
)
)
{
#
ifdef
FONT_COMPRESSION_BIN
fprintf
(
stderr
"
Missing
table
index
for
offset
0x
%
08x
\
n
"
table_offset
)
;
#
endif
return
FONT_COMPRESSION_FAILURE
(
)
;
}
uint16_t
index
=
index_by_tag_offset
[
tag_offset
]
;
Store255UShort
(
index
&
offset
result
)
;
}
}
}
StoreBytes
(
&
compression_buf
[
0
]
total_compressed_length
&
offset
result
)
;
offset
=
Round4
(
offset
)
;
StoreBytes
(
compressed_metadata_buf
.
data
(
)
compressed_metadata_buf_length
&
offset
result
)
;
if
(
*
result_length
!
=
offset
)
{
#
ifdef
FONT_COMPRESSION_BIN
fprintf
(
stderr
"
Mismatch
between
computed
and
actual
length
"
"
(
%
zd
vs
%
zd
)
\
n
"
*
result_length
offset
)
;
#
endif
return
FONT_COMPRESSION_FAILURE
(
)
;
}
return
true
;
}
}
