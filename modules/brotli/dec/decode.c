#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
"
.
/
bit_reader
.
h
"
#
include
"
.
/
context
.
h
"
#
include
"
.
/
decode
.
h
"
#
include
"
.
/
dictionary
.
h
"
#
include
"
.
/
port
.
h
"
#
include
"
.
/
transform
.
h
"
#
include
"
.
/
huffman
.
h
"
#
include
"
.
/
prefix
.
h
"
#
ifdef
__ARM_NEON__
#
include
<
arm_neon
.
h
>
#
endif
#
if
defined
(
__cplusplus
)
|
|
defined
(
c_plusplus
)
extern
"
C
"
{
#
endif
#
ifdef
BROTLI_DECODE_DEBUG
#
define
BROTLI_LOG_UINT
(
name
)
\
printf
(
"
[
%
s
]
%
s
=
%
lu
\
n
"
__func__
#
name
(
unsigned
long
)
(
name
)
)
#
define
BROTLI_LOG_ARRAY_INDEX
(
array_name
idx
)
\
printf
(
"
[
%
s
]
%
s
[
%
lu
]
=
%
lu
\
n
"
__func__
#
array_name
\
(
unsigned
long
)
(
idx
)
(
unsigned
long
)
array_name
[
idx
]
)
#
define
BROTLI_LOG
(
x
)
printf
x
#
else
#
define
BROTLI_LOG_UINT
(
name
)
#
define
BROTLI_LOG_ARRAY_INDEX
(
array_name
idx
)
#
define
BROTLI_LOG
(
x
)
#
endif
static
const
uint8_t
kDefaultCodeLength
=
8
;
static
const
uint8_t
kCodeLengthRepeatCode
=
16
;
static
const
int
kNumLiteralCodes
=
256
;
static
const
int
kNumInsertAndCopyCodes
=
704
;
static
const
int
kNumBlockLengthCodes
=
26
;
static
const
int
kLiteralContextBits
=
6
;
static
const
int
kDistanceContextBits
=
2
;
#
define
HUFFMAN_TABLE_BITS
8
#
define
HUFFMAN_TABLE_MASK
0xff
#
define
CODE_LENGTH_CODES
18
static
const
uint8_t
kCodeLengthCodeOrder
[
CODE_LENGTH_CODES
]
=
{
1
2
3
4
0
5
17
6
16
7
8
9
10
11
12
13
14
15
}
;
static
const
uint8_t
kCodeLengthPrefixLength
[
16
]
=
{
2
2
2
3
2
2
2
4
2
2
2
3
2
2
2
4
}
;
static
const
uint8_t
kCodeLengthPrefixValue
[
16
]
=
{
0
4
3
2
0
4
3
1
0
4
3
2
0
4
3
5
}
;
#
define
NUM_DISTANCE_SHORT_CODES
16
static
uint32_t
DecodeWindowBits
(
BrotliBitReader
*
br
)
{
uint32_t
n
;
BrotliTakeBits
(
br
1
&
n
)
;
if
(
n
=
=
0
)
{
return
16
;
}
BrotliTakeBits
(
br
3
&
n
)
;
if
(
n
!
=
0
)
{
return
17
+
n
;
}
BrotliTakeBits
(
br
3
&
n
)
;
if
(
n
!
=
0
)
{
return
8
+
n
;
}
return
17
;
}
static
BROTLI_INLINE
BROTLI_NO_ASAN
void
memmove16
(
uint8_t
*
dst
uint8_t
*
src
)
{
#
if
BROTLI_SAFE_MEMMOVE
uint32_t
buffer
[
4
]
;
memcpy
(
buffer
src
16
)
;
memcpy
(
dst
buffer
16
)
;
#
elif
defined
(
__ARM_NEON__
)
vst1q_u8
(
dst
vld1q_u8
(
src
)
)
;
#
else
memcpy
(
dst
src
16
)
;
#
endif
}
static
BROTLI_NOINLINE
BrotliResult
DecodeVarLenUint8
(
BrotliState
*
s
BrotliBitReader
*
br
int
*
value
)
{
uint32_t
bits
;
switch
(
s
-
>
substate_decode_uint8
)
{
case
BROTLI_STATE_DECODE_UINT8_NONE
:
if
(
PREDICT_FALSE
(
!
BrotliSafeReadBits
(
br
1
&
bits
)
)
)
{
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
if
(
bits
=
=
0
)
{
*
value
=
0
;
return
BROTLI_RESULT_SUCCESS
;
}
case
BROTLI_STATE_DECODE_UINT8_SHORT
:
if
(
PREDICT_FALSE
(
!
BrotliSafeReadBits
(
br
3
&
bits
)
)
)
{
s
-
>
substate_decode_uint8
=
BROTLI_STATE_DECODE_UINT8_SHORT
;
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
if
(
bits
=
=
0
)
{
*
value
=
1
;
s
-
>
substate_decode_uint8
=
BROTLI_STATE_DECODE_UINT8_NONE
;
return
BROTLI_RESULT_SUCCESS
;
}
*
value
=
(
int
)
bits
;
case
BROTLI_STATE_DECODE_UINT8_LONG
:
if
(
PREDICT_FALSE
(
!
BrotliSafeReadBits
(
br
*
value
&
bits
)
)
)
{
s
-
>
substate_decode_uint8
=
BROTLI_STATE_DECODE_UINT8_LONG
;
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
*
value
=
(
1
<
<
*
value
)
+
(
int
)
bits
;
s
-
>
substate_decode_uint8
=
BROTLI_STATE_DECODE_UINT8_NONE
;
return
BROTLI_RESULT_SUCCESS
;
default
:
return
BROTLI_FAILURE
(
)
;
}
}
static
BrotliResult
BROTLI_NOINLINE
DecodeMetaBlockLength
(
BrotliState
*
s
BrotliBitReader
*
br
)
{
uint32_t
bits
;
int
i
;
for
(
;
;
)
{
switch
(
s
-
>
substate_metablock_header
)
{
case
BROTLI_STATE_METABLOCK_HEADER_NONE
:
if
(
!
BrotliSafeReadBits
(
br
1
&
bits
)
)
{
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
s
-
>
is_last_metablock
=
(
uint8_t
)
bits
;
s
-
>
meta_block_remaining_len
=
0
;
s
-
>
is_uncompressed
=
0
;
s
-
>
is_metadata
=
0
;
if
(
!
s
-
>
is_last_metablock
)
{
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_NIBBLES
;
break
;
}
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_EMPTY
;
case
BROTLI_STATE_METABLOCK_HEADER_EMPTY
:
if
(
!
BrotliSafeReadBits
(
br
1
&
bits
)
)
{
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
if
(
bits
)
{
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_NONE
;
return
BROTLI_RESULT_SUCCESS
;
}
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_NIBBLES
;
case
BROTLI_STATE_METABLOCK_HEADER_NIBBLES
:
if
(
!
BrotliSafeReadBits
(
br
2
&
bits
)
)
{
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
s
-
>
size_nibbles
=
(
uint8_t
)
(
bits
+
4
)
;
s
-
>
loop_counter
=
0
;
if
(
bits
=
=
3
)
{
s
-
>
is_metadata
=
1
;
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_RESERVED
;
break
;
}
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_SIZE
;
case
BROTLI_STATE_METABLOCK_HEADER_SIZE
:
i
=
s
-
>
loop_counter
;
for
(
;
i
<
s
-
>
size_nibbles
;
+
+
i
)
{
if
(
!
BrotliSafeReadBits
(
br
4
&
bits
)
)
{
s
-
>
loop_counter
=
i
;
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
if
(
i
+
1
=
=
s
-
>
size_nibbles
&
&
s
-
>
size_nibbles
>
4
&
&
bits
=
=
0
)
{
return
BROTLI_FAILURE
(
)
;
}
s
-
>
meta_block_remaining_len
|
=
(
int
)
(
bits
<
<
(
i
*
4
)
)
;
}
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_UNCOMPRESSED
;
case
BROTLI_STATE_METABLOCK_HEADER_UNCOMPRESSED
:
if
(
!
s
-
>
is_last_metablock
&
&
!
s
-
>
is_metadata
)
{
if
(
!
BrotliSafeReadBits
(
br
1
&
bits
)
)
{
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
s
-
>
is_uncompressed
=
(
uint8_t
)
bits
;
}
+
+
s
-
>
meta_block_remaining_len
;
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_NONE
;
return
BROTLI_RESULT_SUCCESS
;
case
BROTLI_STATE_METABLOCK_HEADER_RESERVED
:
if
(
!
BrotliSafeReadBits
(
br
1
&
bits
)
)
{
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
if
(
bits
!
=
0
)
{
return
BROTLI_FAILURE
(
)
;
}
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_BYTES
;
case
BROTLI_STATE_METABLOCK_HEADER_BYTES
:
if
(
!
BrotliSafeReadBits
(
br
2
&
bits
)
)
{
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
if
(
bits
=
=
0
)
{
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_NONE
;
return
BROTLI_RESULT_SUCCESS
;
}
s
-
>
size_nibbles
=
(
uint8_t
)
bits
;
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_METADATA
;
case
BROTLI_STATE_METABLOCK_HEADER_METADATA
:
i
=
s
-
>
loop_counter
;
for
(
;
i
<
s
-
>
size_nibbles
;
+
+
i
)
{
if
(
!
BrotliSafeReadBits
(
br
8
&
bits
)
)
{
s
-
>
loop_counter
=
i
;
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
if
(
i
+
1
=
=
s
-
>
size_nibbles
&
&
s
-
>
size_nibbles
>
1
&
&
bits
=
=
0
)
{
return
BROTLI_FAILURE
(
)
;
}
s
-
>
meta_block_remaining_len
|
=
(
int
)
(
bits
<
<
(
i
*
8
)
)
;
}
s
-
>
substate_metablock_header
=
BROTLI_STATE_METABLOCK_HEADER_UNCOMPRESSED
;
break
;
default
:
return
BROTLI_FAILURE
(
)
;
}
}
}
static
BROTLI_INLINE
int
ReadSymbol
(
const
HuffmanCode
*
table
BrotliBitReader
*
br
)
{
uint32_t
val
=
BrotliGetBitsUnmasked
(
br
15
)
;
table
+
=
val
&
HUFFMAN_TABLE_MASK
;
if
(
table
-
>
bits
>
HUFFMAN_TABLE_BITS
)
{
int
nbits
=
table
-
>
bits
-
HUFFMAN_TABLE_BITS
;
BrotliDropBits
(
br
HUFFMAN_TABLE_BITS
)
;
table
+
=
table
-
>
value
;
table
+
=
(
int
)
(
val
>
>
HUFFMAN_TABLE_BITS
)
&
(
int
)
BitMask
(
nbits
)
;
}
BrotliDropBits
(
br
table
-
>
bits
)
;
return
table
-
>
value
;
}
static
BROTLI_INLINE
void
PreloadSymbol
(
const
HuffmanCode
*
table
BrotliBitReader
*
br
unsigned
*
bits
unsigned
*
value
)
{
table
+
=
BrotliGetBits
(
br
HUFFMAN_TABLE_BITS
)
;
*
bits
=
table
-
>
bits
;
*
value
=
table
-
>
value
;
}
static
BROTLI_INLINE
unsigned
ReadPreloadedSymbol
(
const
HuffmanCode
*
table
BrotliBitReader
*
br
unsigned
*
bits
unsigned
*
value
)
{
unsigned
result
=
*
value
;
if
(
PREDICT_FALSE
(
*
bits
>
HUFFMAN_TABLE_BITS
)
)
{
uint32_t
val
=
BrotliGetBitsUnmasked
(
br
15
)
;
const
HuffmanCode
*
ext
=
table
+
(
val
&
HUFFMAN_TABLE_MASK
)
+
*
value
;
int
mask
=
(
int
)
BitMask
(
(
int
)
(
*
bits
-
HUFFMAN_TABLE_BITS
)
)
;
BrotliDropBits
(
br
HUFFMAN_TABLE_BITS
)
;
ext
+
=
(
int
)
(
val
>
>
HUFFMAN_TABLE_BITS
)
&
mask
;
BrotliDropBits
(
br
ext
-
>
bits
)
;
result
=
ext
-
>
value
;
}
else
{
BrotliDropBits
(
br
(
int
)
*
bits
)
;
}
PreloadSymbol
(
table
br
bits
value
)
;
return
result
;
}
static
BROTLI_INLINE
int
Log2Floor
(
int
x
)
{
int
result
=
0
;
while
(
x
)
{
x
>
>
=
1
;
+
+
result
;
}
return
result
;
}
static
BrotliResult
ReadHuffmanCode
(
int
alphabet_size
HuffmanCode
*
table
int
*
opt_table_size
BrotliState
*
s
)
{
BrotliBitReader
*
br
=
&
s
-
>
br
;
int
i
;
alphabet_size
&
=
0x3ff
;
switch
(
s
-
>
substate_huffman
)
{
case
BROTLI_STATE_HUFFMAN_NONE
:
if
(
!
BrotliCheckInputAmount
(
br
32
)
)
{
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
i
=
(
int
)
BrotliReadBits
(
br
2
)
;
BROTLI_LOG_UINT
(
(
unsigned
)
i
)
;
if
(
i
=
=
1
)
{
int
max_bits
=
Log2Floor
(
alphabet_size
-
1
)
;
uint32_t
num_symbols
=
BrotliReadBits
(
br
2
)
;
for
(
i
=
0
;
i
<
4
;
+
+
i
)
{
s
-
>
symbols_lists_array
[
i
]
=
0
;
}
i
=
0
;
do
{
uint32_t
v
=
BrotliReadBits
(
br
max_bits
)
;
if
(
v
>
=
alphabet_size
)
{
return
BROTLI_FAILURE
(
)
;
}
s
-
>
symbols_lists_array
[
i
]
=
(
uint16_t
)
v
;
BROTLI_LOG_UINT
(
s
-
>
symbols_lists_array
[
i
]
)
;
}
while
(
+
+
i
<
=
num_symbols
)
;
for
(
i
=
0
;
i
<
num_symbols
;
+
+
i
)
{
int
k
=
i
+
1
;
for
(
;
k
<
=
num_symbols
;
+
+
k
)
{
if
(
s
-
>
symbols_lists_array
[
i
]
=
=
s
-
>
symbols_lists_array
[
k
]
)
{
return
BROTLI_FAILURE
(
)
;
}
}
}
if
(
num_symbols
=
=
3
)
{
num_symbols
+
=
BrotliReadBits
(
br
1
)
;
}
BROTLI_LOG_UINT
(
num_symbols
)
;
i
=
BrotliBuildSimpleHuffmanTable
(
table
HUFFMAN_TABLE_BITS
s
-
>
symbols_lists_array
num_symbols
)
;
if
(
opt_table_size
)
{
*
opt_table_size
=
i
;
}
s
-
>
substate_huffman
=
BROTLI_STATE_HUFFMAN_NONE
;
return
BROTLI_RESULT_SUCCESS
;
}
else
{
int8_t
num_codes
=
0
;
unsigned
space
=
32
;
memset
(
&
s
-
>
code_length_histo
[
0
]
0
sizeof
(
s
-
>
code_length_histo
[
0
]
)
*
(
BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH
+
1
)
)
;
memset
(
&
s
-
>
code_length_code_lengths
[
0
]
0
sizeof
(
s
-
>
code_length_code_lengths
)
)
;
for
(
;
i
<
CODE_LENGTH_CODES
;
+
+
i
)
{
const
uint8_t
code_len_idx
=
kCodeLengthCodeOrder
[
i
]
;
uint8_t
ix
=
(
uint8_t
)
BrotliGetBits
(
br
4
)
;
uint8_t
v
=
kCodeLengthPrefixValue
[
ix
]
;
BrotliDropBits
(
br
kCodeLengthPrefixLength
[
ix
]
)
;
s
-
>
code_length_code_lengths
[
code_len_idx
]
=
v
;
BROTLI_LOG_ARRAY_INDEX
(
s
-
>
code_length_code_lengths
code_len_idx
)
;
if
(
v
!
=
0
)
{
space
=
space
-
(
32U
>
>
v
)
;
+
+
num_codes
;
+
+
s
-
>
code_length_histo
[
v
]
;
if
(
space
-
1U
>
=
32U
)
{
break
;
}
}
}
if
(
!
(
num_codes
=
=
1
|
|
space
=
=
0
)
)
{
return
BROTLI_FAILURE
(
)
;
}
}
BrotliBuildCodeLengthsHuffmanTable
(
s
-
>
table
s
-
>
code_length_code_lengths
s
-
>
code_length_histo
)
;
memset
(
&
s
-
>
code_length_histo
[
0
]
0
sizeof
(
s
-
>
code_length_histo
)
)
;
for
(
i
=
0
;
i
<
=
BROTLI_HUFFMAN_MAX_CODE_LENGTH
;
+
+
i
)
{
s
-
>
next_symbol
[
i
]
=
i
-
(
BROTLI_HUFFMAN_MAX_CODE_LENGTH
+
1
)
;
s
-
>
symbol_lists
[
i
-
(
BROTLI_HUFFMAN_MAX_CODE_LENGTH
+
1
)
]
=
0xFFFF
;
}
s
-
>
symbol
=
0
;
s
-
>
prev_code_len
=
kDefaultCodeLength
;
s
-
>
repeat
=
0
;
s
-
>
repeat_code_len
=
0
;
s
-
>
space
=
32768
;
s
-
>
substate_huffman
=
BROTLI_STATE_HUFFMAN_LENGTH_SYMBOLS
;
case
BROTLI_STATE_HUFFMAN_LENGTH_SYMBOLS
:
{
uint32_t
symbol
=
s
-
>
symbol
;
uint32_t
repeat
=
s
-
>
repeat
;
uint32_t
space
=
s
-
>
space
;
uint8_t
prev_code_len
=
s
-
>
prev_code_len
;
uint8_t
repeat_code_len
=
s
-
>
repeat_code_len
;
uint16_t
*
symbol_lists
=
s
-
>
symbol_lists
;
uint16_t
*
code_length_histo
=
s
-
>
code_length_histo
;
int
*
next_symbol
=
s
-
>
next_symbol
;
while
(
symbol
<
alphabet_size
&
&
space
>
0
)
{
const
HuffmanCode
*
p
=
s
-
>
table
;
uint8_t
code_len
;
if
(
!
BrotliCheckInputAmount
(
br
8
)
)
{
s
-
>
symbol
=
symbol
;
s
-
>
repeat
=
repeat
;
s
-
>
prev_code_len
=
prev_code_len
;
s
-
>
repeat_code_len
=
repeat_code_len
;
s
-
>
space
=
space
;
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
p
+
=
BrotliGetBits
(
br
BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH
)
;
BrotliDropBits
(
br
p
-
>
bits
)
;
code_len
=
(
uint8_t
)
p
-
>
value
;
if
(
code_len
<
kCodeLengthRepeatCode
)
{
repeat
=
0
;
if
(
code_len
!
=
0
)
{
symbol_lists
[
next_symbol
[
code_len
]
]
=
(
uint16_t
)
symbol
;
next_symbol
[
code_len
]
=
(
int
)
symbol
;
prev_code_len
=
code_len
;
space
-
=
32768U
>
>
code_len
;
code_length_histo
[
code_len
]
+
+
;
}
symbol
+
+
;
}
else
{
uint32_t
repeat_delta
=
BrotliReadBits
(
br
code_len
-
14
)
;
uint32_t
old_repeat
;
uint8_t
new_len
=
0
;
if
(
code_len
=
=
kCodeLengthRepeatCode
)
{
new_len
=
prev_code_len
;
}
if
(
repeat_code_len
!
=
new_len
)
{
repeat
=
0
;
repeat_code_len
=
new_len
;
}
old_repeat
=
repeat
;
if
(
repeat
>
0
)
{
repeat
-
=
2
;
repeat
<
<
=
code_len
-
14
;
}
repeat
+
=
repeat_delta
+
3
;
repeat_delta
=
repeat
-
old_repeat
;
if
(
symbol
+
repeat_delta
>
alphabet_size
)
{
return
BROTLI_FAILURE
(
)
;
}
if
(
repeat_code_len
!
=
0
)
{
unsigned
last
=
symbol
+
repeat_delta
;
i
=
next_symbol
[
repeat_code_len
]
;
do
{
symbol_lists
[
i
]
=
(
uint16_t
)
symbol
;
i
=
(
int
)
symbol
;
}
while
(
+
+
symbol
!
=
last
)
;
next_symbol
[
repeat_code_len
]
=
i
;
space
-
=
repeat_delta
<
<
(
15
-
repeat_code_len
)
;
code_length_histo
[
repeat_code_len
]
=
(
uint16_t
)
(
code_length_histo
[
repeat_code_len
]
+
repeat_delta
)
;
}
else
{
symbol
+
=
repeat_delta
;
}
}
}
if
(
space
!
=
0
)
{
BROTLI_LOG
(
(
"
[
ReadHuffmanCode
]
space
=
%
d
\
n
"
space
)
)
;
return
BROTLI_FAILURE
(
)
;
}
{
int
table_size
=
BrotliBuildHuffmanTable
(
table
HUFFMAN_TABLE_BITS
symbol_lists
s
-
>
code_length_histo
)
;
if
(
opt_table_size
)
{
*
opt_table_size
=
table_size
;
}
}
s
-
>
substate_huffman
=
BROTLI_STATE_HUFFMAN_NONE
;
return
BROTLI_RESULT_SUCCESS
;
}
default
:
return
BROTLI_FAILURE
(
)
;
}
}
static
BROTLI_INLINE
int
ReadBlockLength
(
const
HuffmanCode
*
table
BrotliBitReader
*
br
)
{
int
code
;
int
nbits
;
code
=
ReadSymbol
(
table
br
)
;
nbits
=
kBlockLengthPrefixCode
[
code
]
.
nbits
;
return
kBlockLengthPrefixCode
[
code
]
.
offset
+
(
int
)
BrotliReadBits
(
br
nbits
)
;
}
static
BROTLI_NOINLINE
void
InverseMoveToFrontTransform
(
uint8_t
*
v
int
v_len
BrotliState
*
state
)
{
int
i
=
4
;
int
upper_bound
=
state
-
>
mtf_upper_bound
;
uint8_t
*
mtf
=
state
-
>
mtf
;
const
uint8_t
b0123
[
4
]
=
{
0
1
2
3
}
;
uint32_t
pattern
;
memcpy
(
&
pattern
&
b0123
4
)
;
*
(
uint32_t
*
)
mtf
=
pattern
;
do
{
pattern
+
=
0x04040404
;
*
(
uint32_t
*
)
(
mtf
+
i
)
=
pattern
;
i
+
=
4
;
}
while
(
i
<
=
upper_bound
)
;
upper_bound
=
0
;
for
(
i
=
0
;
i
<
v_len
;
+
+
i
)
{
int
index
=
v
[
i
]
;
uint8_t
value
=
mtf
[
index
]
;
v
[
i
]
=
value
;
upper_bound
|
=
index
;
do
{
index
-
-
;
mtf
[
index
+
1
]
=
mtf
[
index
]
;
}
while
(
index
>
0
)
;
mtf
[
0
]
=
value
;
}
state
-
>
mtf_upper_bound
=
upper_bound
;
}
void
InverseMoveToFrontTransformForTesting
(
uint8_t
*
v
int
l
BrotliState
*
s
)
{
InverseMoveToFrontTransform
(
v
l
s
)
;
}
static
BrotliResult
HuffmanTreeGroupDecode
(
HuffmanTreeGroup
*
group
BrotliState
*
s
)
{
if
(
s
-
>
substate_tree_group
!
=
BROTLI_STATE_TREE_GROUP_LOOP
)
{
s
-
>
next
=
group
-
>
codes
;
s
-
>
htree_index
=
0
;
s
-
>
substate_tree_group
=
BROTLI_STATE_TREE_GROUP_LOOP
;
}
while
(
s
-
>
htree_index
<
group
-
>
num_htrees
)
{
int
table_size
;
BrotliResult
result
=
ReadHuffmanCode
(
group
-
>
alphabet_size
s
-
>
next
&
table_size
s
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
return
result
;
group
-
>
htrees
[
s
-
>
htree_index
]
=
s
-
>
next
;
s
-
>
next
+
=
table_size
;
+
+
s
-
>
htree_index
;
}
s
-
>
substate_tree_group
=
BROTLI_STATE_TREE_GROUP_NONE
;
return
BROTLI_RESULT_SUCCESS
;
}
static
BrotliResult
DecodeContextMap
(
int
context_map_size
int
*
num_htrees
uint8_t
*
*
context_map_arg
BrotliState
*
s
)
{
BrotliBitReader
*
br
=
&
s
-
>
br
;
BrotliResult
result
=
BROTLI_RESULT_SUCCESS
;
int
use_rle_for_zeros
;
switch
(
(
int
)
s
-
>
substate_context_map
)
{
case
BROTLI_STATE_CONTEXT_MAP_NONE
:
result
=
DecodeVarLenUint8
(
s
br
num_htrees
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
{
return
result
;
}
(
*
num_htrees
)
+
+
;
s
-
>
context_index
=
0
;
BROTLI_LOG_UINT
(
context_map_size
)
;
BROTLI_LOG_UINT
(
*
num_htrees
)
;
*
context_map_arg
=
(
uint8_t
*
)
malloc
(
(
size_t
)
context_map_size
)
;
if
(
*
context_map_arg
=
=
0
)
{
return
BROTLI_FAILURE
(
)
;
}
if
(
*
num_htrees
<
=
1
)
{
memset
(
*
context_map_arg
0
(
size_t
)
context_map_size
)
;
return
BROTLI_RESULT_SUCCESS
;
}
s
-
>
substate_context_map
=
BROTLI_STATE_CONTEXT_MAP_READ_PREFIX
;
case
BROTLI_STATE_CONTEXT_MAP_READ_PREFIX
:
if
(
!
BrotliWarmupBitReader
(
br
)
|
|
!
BrotliCheckInputAmount
(
br
8
)
)
{
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
use_rle_for_zeros
=
(
int
)
BrotliReadBits
(
br
1
)
;
if
(
use_rle_for_zeros
)
{
s
-
>
max_run_length_prefix
=
(
int
)
BrotliReadBits
(
br
4
)
+
1
;
}
else
{
s
-
>
max_run_length_prefix
=
0
;
}
BROTLI_LOG_UINT
(
s
-
>
max_run_length_prefix
)
;
s
-
>
substate_context_map
=
BROTLI_STATE_CONTEXT_MAP_HUFFMAN
;
case
BROTLI_STATE_CONTEXT_MAP_HUFFMAN
:
result
=
ReadHuffmanCode
(
*
num_htrees
+
s
-
>
max_run_length_prefix
s
-
>
context_map_table
NULL
s
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
return
result
;
s
-
>
substate_context_map
=
BROTLI_STATE_CONTEXT_MAP_DECODE
;
case
BROTLI_STATE_CONTEXT_MAP_DECODE
:
{
int
context_index
=
s
-
>
context_index
;
int
max_run_length_prefix
=
s
-
>
max_run_length_prefix
;
uint8_t
*
context_map
=
*
context_map_arg
;
int
code
;
while
(
context_index
<
context_map_size
)
{
if
(
!
BrotliCheckInputAmount
(
br
32
)
)
{
s
-
>
context_index
=
context_index
;
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
code
=
ReadSymbol
(
s
-
>
context_map_table
br
)
;
BROTLI_LOG_UINT
(
code
)
;
if
(
code
=
=
0
)
{
context_map
[
context_index
+
+
]
=
0
;
}
else
if
(
code
-
max_run_length_prefix
<
=
0
)
{
int
reps
=
(
1
<
<
code
)
+
(
int
)
BrotliReadBits
(
br
code
)
;
BROTLI_LOG_UINT
(
reps
)
;
if
(
context_index
+
reps
>
context_map_size
)
{
return
BROTLI_FAILURE
(
)
;
}
do
{
context_map
[
context_index
+
+
]
=
0
;
}
while
(
-
-
reps
)
;
}
else
{
context_map
[
context_index
+
+
]
=
(
uint8_t
)
(
code
-
max_run_length_prefix
)
;
}
}
if
(
BrotliReadBits
(
br
1
)
)
{
InverseMoveToFrontTransform
(
context_map
context_map_size
s
)
;
}
s
-
>
substate_context_map
=
BROTLI_STATE_CONTEXT_MAP_NONE
;
return
BROTLI_RESULT_SUCCESS
;
}
}
return
BROTLI_FAILURE
(
)
;
}
static
void
DecodeBlockType
(
const
int
max_block_type
const
HuffmanCode
*
trees
int
tree_type
int
*
ringbuffers
BrotliBitReader
*
br
)
{
int
*
ringbuffer
=
ringbuffers
+
tree_type
*
2
;
int
block_type
=
ReadSymbol
(
&
trees
[
tree_type
*
BROTLI_HUFFMAN_MAX_TABLE_SIZE
]
br
)
-
2
;
if
(
block_type
=
=
-
1
)
{
block_type
=
ringbuffer
[
1
]
+
1
;
}
else
if
(
block_type
=
=
-
2
)
{
block_type
=
ringbuffer
[
0
]
;
}
if
(
block_type
>
=
max_block_type
)
{
block_type
-
=
max_block_type
;
}
ringbuffer
[
0
]
=
ringbuffer
[
1
]
;
ringbuffer
[
1
]
=
block_type
;
}
static
void
DecodeBlockTypeWithContext
(
BrotliState
*
s
BrotliBitReader
*
br
)
{
uint8_t
context_mode
;
int
context_offset
;
DecodeBlockType
(
s
-
>
num_block_types
[
0
]
s
-
>
block_type_trees
0
s
-
>
block_type_rb
br
)
;
s
-
>
block_length
[
0
]
=
ReadBlockLength
(
s
-
>
block_len_trees
br
)
;
context_offset
=
s
-
>
block_type_rb
[
1
]
<
<
kLiteralContextBits
;
s
-
>
context_map_slice
=
s
-
>
context_map
+
context_offset
;
s
-
>
literal_htree_index
=
s
-
>
context_map_slice
[
0
]
;
s
-
>
literal_htree
=
s
-
>
literal_hgroup
.
htrees
[
s
-
>
literal_htree_index
]
;
context_mode
=
s
-
>
context_modes
[
s
-
>
block_type_rb
[
1
]
]
;
s
-
>
context_lookup1
=
&
kContextLookup
[
kContextLookupOffsets
[
context_mode
]
]
;
s
-
>
context_lookup2
=
&
kContextLookup
[
kContextLookupOffsets
[
context_mode
+
1
]
]
;
}
BrotliResult
WriteRingBuffer
(
BrotliOutput
output
BrotliState
*
s
)
{
int
num_written
;
if
(
s
-
>
meta_block_remaining_len
<
0
)
{
return
BROTLI_FAILURE
(
)
;
}
num_written
=
BrotliWrite
(
output
s
-
>
ringbuffer
+
s
-
>
partially_written
(
size_t
)
(
s
-
>
to_write
-
s
-
>
partially_written
)
)
;
BROTLI_LOG_UINT
(
s
-
>
partially_written
)
;
BROTLI_LOG_UINT
(
s
-
>
to_write
)
;
BROTLI_LOG_UINT
(
num_written
)
;
if
(
num_written
<
0
)
{
return
BROTLI_FAILURE
(
)
;
}
s
-
>
partially_written
+
=
num_written
;
if
(
s
-
>
partially_written
<
s
-
>
to_write
)
{
return
BROTLI_RESULT_NEEDS_MORE_OUTPUT
;
}
return
BROTLI_RESULT_SUCCESS
;
}
BrotliResult
BROTLI_NOINLINE
CopyUncompressedBlockToOutput
(
BrotliOutput
output
int
pos
BrotliState
*
s
)
{
BrotliResult
result
;
int
num_read
;
int
nbytes
;
for
(
;
;
)
{
switch
(
(
int
)
s
-
>
substate_uncompressed
)
{
case
BROTLI_STATE_UNCOMPRESSED_NONE
:
if
(
s
-
>
meta_block_remaining_len
<
8
|
|
s
-
>
meta_block_remaining_len
<
BrotliGetRemainingBytes
(
&
s
-
>
br
)
)
{
s
-
>
substate_uncompressed
=
BROTLI_STATE_UNCOMPRESSED_SHORT
;
break
;
}
nbytes
=
(
int
)
BrotliGetRemainingBytes
(
&
s
-
>
br
)
;
BrotliCopyBytes
(
&
s
-
>
ringbuffer
[
pos
]
&
s
-
>
br
(
size_t
)
nbytes
)
;
pos
+
=
nbytes
;
s
-
>
meta_block_remaining_len
-
=
nbytes
;
if
(
pos
>
=
s
-
>
ringbuffer_size
)
{
s
-
>
to_write
=
s
-
>
ringbuffer_size
;
s
-
>
partially_written
=
0
;
s
-
>
substate_uncompressed
=
BROTLI_STATE_UNCOMPRESSED_WRITE
;
break
;
}
s
-
>
substate_uncompressed
=
BROTLI_STATE_UNCOMPRESSED_COPY
;
break
;
case
BROTLI_STATE_UNCOMPRESSED_SHORT
:
if
(
!
BrotliWarmupBitReader
(
&
s
-
>
br
)
)
{
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
while
(
s
-
>
meta_block_remaining_len
>
0
)
{
if
(
!
BrotliCheckInputAmount
(
&
s
-
>
br
8
)
)
{
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
s
-
>
ringbuffer
[
pos
+
+
]
=
(
uint8_t
)
BrotliReadBits
(
&
s
-
>
br
8
)
;
s
-
>
meta_block_remaining_len
-
-
;
}
if
(
pos
>
=
s
-
>
ringbuffer_size
)
{
s
-
>
to_write
=
s
-
>
ringbuffer_size
;
s
-
>
partially_written
=
0
;
s
-
>
substate_uncompressed
=
BROTLI_STATE_UNCOMPRESSED_WRITE
;
}
else
{
s
-
>
substate_uncompressed
=
BROTLI_STATE_UNCOMPRESSED_NONE
;
return
BROTLI_RESULT_SUCCESS
;
}
case
BROTLI_STATE_UNCOMPRESSED_WRITE
:
result
=
WriteRingBuffer
(
output
s
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
{
return
result
;
}
pos
&
=
s
-
>
ringbuffer_mask
;
s
-
>
max_distance
=
s
-
>
max_backward_distance
;
memcpy
(
s
-
>
ringbuffer
s
-
>
ringbuffer_end
(
size_t
)
pos
)
;
s
-
>
substate_uncompressed
=
BROTLI_STATE_UNCOMPRESSED_COPY
;
case
BROTLI_STATE_UNCOMPRESSED_COPY
:
nbytes
=
s
-
>
meta_block_remaining_len
;
if
(
pos
+
nbytes
>
s
-
>
ringbuffer_size
)
{
nbytes
=
s
-
>
ringbuffer_size
-
pos
;
}
num_read
=
BrotliRead
(
s
-
>
br
.
input_
&
s
-
>
ringbuffer
[
pos
]
(
size_t
)
nbytes
)
;
pos
+
=
num_read
;
s
-
>
meta_block_remaining_len
-
=
num_read
;
if
(
num_read
<
nbytes
)
{
if
(
num_read
<
0
)
return
BROTLI_FAILURE
(
)
;
return
BROTLI_RESULT_NEEDS_MORE_INPUT
;
}
if
(
pos
=
=
s
-
>
ringbuffer_size
)
{
s
-
>
to_write
=
s
-
>
ringbuffer_size
;
s
-
>
partially_written
=
0
;
s
-
>
substate_uncompressed
=
BROTLI_STATE_UNCOMPRESSED_WRITE
;
break
;
}
s
-
>
substate_uncompressed
=
BROTLI_STATE_UNCOMPRESSED_NONE
;
return
BROTLI_RESULT_SUCCESS
;
}
}
return
BROTLI_FAILURE
(
)
;
}
int
BrotliDecompressedSize
(
size_t
encoded_size
const
uint8_t
*
encoded_buffer
size_t
*
decoded_size
)
{
BrotliMemInput
memin
;
BrotliInput
in
=
BrotliInitMemInput
(
encoded_buffer
encoded_size
&
memin
)
;
BrotliBitReader
br
;
BrotliState
s
;
int
next_block_header
;
int
offset
;
BrotliStateInit
(
&
s
)
;
BrotliInitBitReader
(
&
br
in
)
;
if
(
!
BrotliReadInput
(
&
br
1
)
|
|
!
BrotliWarmupBitReader
(
&
br
)
)
{
return
0
;
}
DecodeWindowBits
(
&
br
)
;
if
(
DecodeMetaBlockLength
(
&
s
&
br
)
!
=
BROTLI_RESULT_SUCCESS
)
{
return
0
;
}
*
decoded_size
=
(
size_t
)
s
.
meta_block_remaining_len
;
if
(
s
.
is_last_metablock
)
{
return
1
;
}
if
(
!
s
.
is_uncompressed
|
|
!
BrotliJumpToByteBoundary
(
&
br
)
)
{
return
0
;
}
next_block_header
=
BrotliPeekByte
(
&
br
s
.
meta_block_remaining_len
)
;
if
(
next_block_header
!
=
-
1
)
{
return
(
next_block_header
&
3
)
=
=
3
;
}
offset
=
BROTLI_READ_SIZE
-
(
int
)
BrotliGetRemainingBytes
(
&
br
)
;
offset
+
=
s
.
meta_block_remaining_len
;
return
(
offset
<
encoded_size
)
&
&
(
(
encoded_buffer
[
offset
]
&
3
)
=
=
3
)
;
}
int
BROTLI_NOINLINE
BrotliAllocateRingBuffer
(
BrotliState
*
s
BrotliBitReader
*
br
)
{
static
const
int
kRingBufferWriteAheadSlack
=
BROTLI_READ_SIZE
;
int
is_last
=
s
-
>
is_last_metablock
;
s
-
>
ringbuffer_size
=
1
<
<
s
-
>
window_bits
;
if
(
s
-
>
is_uncompressed
)
{
int
next_block_header
=
BrotliPeekByte
(
br
s
-
>
meta_block_remaining_len
)
;
if
(
next_block_header
!
=
-
1
)
{
if
(
(
next_block_header
&
3
)
=
=
3
)
{
is_last
=
1
;
}
}
}
if
(
is_last
)
{
while
(
s
-
>
ringbuffer_size
>
=
s
-
>
meta_block_remaining_len
*
2
&
&
s
-
>
ringbuffer_size
>
32
)
{
s
-
>
ringbuffer_size
>
>
=
1
;
}
}
while
(
s
-
>
ringbuffer_size
<
s
-
>
custom_dict_size
)
{
s
-
>
ringbuffer_size
<
<
=
1
;
}
s
-
>
ringbuffer_mask
=
s
-
>
ringbuffer_size
-
1
;
s
-
>
ringbuffer
=
(
uint8_t
*
)
malloc
(
(
size_t
)
(
s
-
>
ringbuffer_size
+
kRingBufferWriteAheadSlack
+
kBrotliMaxDictionaryWordLength
)
)
;
if
(
!
s
-
>
ringbuffer
)
{
return
0
;
}
s
-
>
ringbuffer_end
=
s
-
>
ringbuffer
+
s
-
>
ringbuffer_size
;
s
-
>
ringbuffer
[
s
-
>
ringbuffer_size
-
2
]
=
0
;
s
-
>
ringbuffer
[
s
-
>
ringbuffer_size
-
1
]
=
0
;
if
(
s
-
>
custom_dict
)
{
memcpy
(
&
s
-
>
ringbuffer
[
(
-
s
-
>
custom_dict_size
)
&
s
-
>
ringbuffer_mask
]
s
-
>
custom_dict
(
size_t
)
s
-
>
custom_dict_size
)
;
}
return
1
;
}
BrotliResult
BrotliDecompressBuffer
(
size_t
encoded_size
const
uint8_t
*
encoded_buffer
size_t
*
decoded_size
uint8_t
*
decoded_buffer
)
{
BrotliMemInput
memin
;
BrotliInput
in
=
BrotliInitMemInput
(
encoded_buffer
encoded_size
&
memin
)
;
BrotliMemOutput
mout
;
BrotliOutput
out
=
BrotliInitMemOutput
(
decoded_buffer
*
decoded_size
&
mout
)
;
BrotliResult
success
=
BrotliDecompress
(
in
out
)
;
*
decoded_size
=
mout
.
pos
;
return
success
;
}
BrotliResult
BrotliDecompress
(
BrotliInput
input
BrotliOutput
output
)
{
BrotliState
s
;
BrotliResult
result
;
BrotliStateInit
(
&
s
)
;
result
=
BrotliDecompressStreaming
(
input
output
1
&
s
)
;
if
(
result
=
=
BROTLI_RESULT_NEEDS_MORE_INPUT
)
{
result
=
BROTLI_FAILURE
(
)
;
}
BrotliStateCleanup
(
&
s
)
;
return
result
;
}
BrotliResult
BrotliDecompressBufferStreaming
(
size_t
*
available_in
const
uint8_t
*
*
next_in
int
finish
size_t
*
available_out
uint8_t
*
*
next_out
size_t
*
total_out
BrotliState
*
s
)
{
BrotliMemInput
memin
;
BrotliInput
in
=
BrotliInitMemInput
(
*
next_in
*
available_in
&
memin
)
;
BrotliMemOutput
memout
;
BrotliOutput
out
=
BrotliInitMemOutput
(
*
next_out
*
available_out
&
memout
)
;
BrotliResult
result
=
BrotliDecompressStreaming
(
in
out
finish
s
)
;
*
next_in
+
=
memin
.
pos
;
*
available_in
-
=
memin
.
pos
;
*
next_out
+
=
memout
.
pos
;
*
available_out
-
=
memout
.
pos
;
*
total_out
+
=
memout
.
pos
;
return
result
;
}
BrotliResult
BrotliDecompressStreaming
(
BrotliInput
input
BrotliOutput
output
int
finish
BrotliState
*
s
)
{
uint8_t
context
;
int
pos
=
s
-
>
pos
;
int
i
=
s
-
>
loop_counter
;
BrotliResult
result
=
BROTLI_RESULT_SUCCESS
;
BrotliBitReader
*
br
=
&
s
-
>
br
;
int
initial_remaining_len
;
int
bytes_copied
;
uint8_t
*
copy_src
;
uint8_t
*
copy_dst
;
s
-
>
br
.
input_
=
input
;
for
(
;
;
)
{
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
{
if
(
result
=
=
BROTLI_RESULT_NEEDS_MORE_INPUT
)
{
if
(
BrotliReadInput
(
br
finish
)
)
{
result
=
BROTLI_RESULT_SUCCESS
;
continue
;
}
if
(
finish
)
{
BROTLI_LOG
(
(
"
Unexpected
end
of
input
.
State
:
%
d
\
n
"
s
-
>
state
)
)
;
result
=
BROTLI_FAILURE
(
)
;
}
}
break
;
}
switch
(
s
-
>
state
)
{
case
BROTLI_STATE_UNINITED
:
pos
=
0
;
BrotliInitBitReader
(
br
input
)
;
s
-
>
state
=
BROTLI_STATE_BITREADER_WARMUP
;
case
BROTLI_STATE_BITREADER_WARMUP
:
if
(
!
BrotliWarmupBitReader
(
br
)
)
{
result
=
BROTLI_RESULT_NEEDS_MORE_INPUT
;
break
;
}
s
-
>
window_bits
=
DecodeWindowBits
(
br
)
;
BROTLI_LOG_UINT
(
s
-
>
window_bits
)
;
if
(
s
-
>
window_bits
=
=
9
)
{
result
=
BROTLI_FAILURE
(
)
;
break
;
}
s
-
>
max_backward_distance
=
(
1
<
<
s
-
>
window_bits
)
-
16
;
s
-
>
max_backward_distance_minus_custom_dict_size
=
s
-
>
max_backward_distance
-
s
-
>
custom_dict_size
;
s
-
>
block_type_trees
=
(
HuffmanCode
*
)
malloc
(
6
*
BROTLI_HUFFMAN_MAX_TABLE_SIZE
*
sizeof
(
HuffmanCode
)
)
;
if
(
s
-
>
block_type_trees
=
=
NULL
)
{
result
=
BROTLI_FAILURE
(
)
;
break
;
}
s
-
>
block_len_trees
=
s
-
>
block_type_trees
+
3
*
BROTLI_HUFFMAN_MAX_TABLE_SIZE
;
s
-
>
state
=
BROTLI_STATE_METABLOCK_BEGIN
;
case
BROTLI_STATE_METABLOCK_BEGIN
:
BrotliStateMetablockBegin
(
s
)
;
BROTLI_LOG_UINT
(
pos
)
;
s
-
>
state
=
BROTLI_STATE_METABLOCK_HEADER
;
case
BROTLI_STATE_METABLOCK_HEADER
:
result
=
DecodeMetaBlockLength
(
s
br
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
{
i
=
s
-
>
loop_counter
;
break
;
}
BROTLI_LOG_UINT
(
s
-
>
is_last_metablock
)
;
BROTLI_LOG_UINT
(
s
-
>
meta_block_remaining_len
)
;
BROTLI_LOG_UINT
(
s
-
>
is_metadata
)
;
BROTLI_LOG_UINT
(
s
-
>
is_uncompressed
)
;
if
(
s
-
>
is_metadata
|
|
s
-
>
is_uncompressed
)
{
if
(
!
BrotliJumpToByteBoundary
(
br
)
)
{
result
=
BROTLI_FAILURE
(
)
;
break
;
}
}
if
(
s
-
>
is_metadata
)
{
s
-
>
state
=
BROTLI_STATE_METADATA
;
break
;
}
if
(
s
-
>
meta_block_remaining_len
=
=
0
)
{
s
-
>
state
=
BROTLI_STATE_METABLOCK_DONE
;
break
;
}
if
(
!
s
-
>
ringbuffer
)
{
if
(
!
BrotliAllocateRingBuffer
(
s
br
)
)
{
result
=
BROTLI_FAILURE
(
)
;
break
;
}
}
if
(
s
-
>
is_uncompressed
)
{
s
-
>
state
=
BROTLI_STATE_UNCOMPRESSED
;
break
;
}
i
=
0
;
s
-
>
state
=
BROTLI_STATE_HUFFMAN_CODE_0
;
break
;
case
BROTLI_STATE_UNCOMPRESSED
:
initial_remaining_len
=
s
-
>
meta_block_remaining_len
;
result
=
CopyUncompressedBlockToOutput
(
output
pos
s
)
;
bytes_copied
=
initial_remaining_len
-
s
-
>
meta_block_remaining_len
;
pos
=
(
pos
+
bytes_copied
)
&
s
-
>
ringbuffer_mask
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
{
break
;
}
s
-
>
state
=
BROTLI_STATE_METABLOCK_DONE
;
break
;
case
BROTLI_STATE_METADATA
:
for
(
;
s
-
>
meta_block_remaining_len
>
0
;
-
-
s
-
>
meta_block_remaining_len
)
{
uint32_t
bits
;
if
(
!
BrotliSafeReadBits
(
br
8
&
bits
)
)
{
result
=
BROTLI_RESULT_NEEDS_MORE_INPUT
;
break
;
}
}
if
(
result
=
=
BROTLI_RESULT_SUCCESS
)
{
s
-
>
state
=
BROTLI_STATE_METABLOCK_DONE
;
}
break
;
case
BROTLI_STATE_HUFFMAN_CODE_0
:
if
(
i
>
=
3
)
{
s
-
>
state
=
BROTLI_STATE_CONTEXT_MODES
;
break
;
}
result
=
DecodeVarLenUint8
(
s
br
&
s
-
>
num_block_types
[
i
]
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
{
break
;
}
s
-
>
num_block_types
[
i
]
+
+
;
BROTLI_LOG_UINT
(
s
-
>
num_block_types
[
i
]
)
;
s
-
>
state
=
BROTLI_STATE_HUFFMAN_CODE_1
;
case
BROTLI_STATE_HUFFMAN_CODE_1
:
if
(
!
BrotliWarmupBitReader
(
br
)
)
{
result
=
BROTLI_RESULT_NEEDS_MORE_INPUT
;
break
;
}
if
(
s
-
>
num_block_types
[
i
]
>
=
2
)
{
result
=
ReadHuffmanCode
(
s
-
>
num_block_types
[
i
]
+
2
&
s
-
>
block_type_trees
[
i
*
BROTLI_HUFFMAN_MAX_TABLE_SIZE
]
NULL
s
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
break
;
s
-
>
state
=
BROTLI_STATE_HUFFMAN_CODE_2
;
}
else
{
i
+
+
;
s
-
>
state
=
BROTLI_STATE_HUFFMAN_CODE_0
;
break
;
}
case
BROTLI_STATE_HUFFMAN_CODE_2
:
result
=
ReadHuffmanCode
(
kNumBlockLengthCodes
&
s
-
>
block_len_trees
[
i
*
BROTLI_HUFFMAN_MAX_TABLE_SIZE
]
NULL
s
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
break
;
s
-
>
state
=
BROTLI_STATE_HUFFMAN_CODE_3
;
case
BROTLI_STATE_HUFFMAN_CODE_3
:
if
(
!
BrotliCheckInputAmount
(
br
8
)
)
{
result
=
BROTLI_RESULT_NEEDS_MORE_INPUT
;
break
;
}
s
-
>
block_length
[
i
]
=
ReadBlockLength
(
&
s
-
>
block_len_trees
[
i
*
BROTLI_HUFFMAN_MAX_TABLE_SIZE
]
br
)
;
BROTLI_LOG_UINT
(
s
-
>
block_length
[
i
]
)
;
i
+
+
;
s
-
>
state
=
BROTLI_STATE_HUFFMAN_CODE_0
;
break
;
case
BROTLI_STATE_CONTEXT_MODES
:
if
(
!
BrotliCheckInputAmount
(
br
128
)
)
{
result
=
BROTLI_RESULT_NEEDS_MORE_INPUT
;
break
;
}
s
-
>
distance_postfix_bits
=
(
int
)
BrotliReadBits
(
br
2
)
;
s
-
>
num_direct_distance_codes
=
NUM_DISTANCE_SHORT_CODES
+
(
(
int
)
BrotliReadBits
(
br
4
)
<
<
s
-
>
distance_postfix_bits
)
;
BROTLI_LOG_UINT
(
s
-
>
num_direct_distance_codes
)
;
BROTLI_LOG_UINT
(
s
-
>
distance_postfix_bits
)
;
s
-
>
distance_postfix_mask
=
(
int
)
BitMask
(
s
-
>
distance_postfix_bits
)
;
s
-
>
context_modes
=
(
uint8_t
*
)
malloc
(
(
size_t
)
s
-
>
num_block_types
[
0
]
)
;
if
(
s
-
>
context_modes
=
=
0
)
{
result
=
BROTLI_FAILURE
(
)
;
break
;
}
for
(
i
=
0
;
i
<
s
-
>
num_block_types
[
0
]
;
+
+
i
)
{
s
-
>
context_modes
[
i
]
=
(
uint8_t
)
(
BrotliReadBits
(
br
2
)
<
<
1
)
;
BROTLI_LOG_ARRAY_INDEX
(
s
-
>
context_modes
i
)
;
}
s
-
>
state
=
BROTLI_STATE_CONTEXT_MAP_1
;
case
BROTLI_STATE_CONTEXT_MAP_1
:
result
=
DecodeContextMap
(
s
-
>
num_block_types
[
0
]
<
<
kLiteralContextBits
&
s
-
>
num_literal_htrees
&
s
-
>
context_map
s
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
{
break
;
}
s
-
>
trivial_literal_context
=
1
;
for
(
i
=
0
;
i
<
s
-
>
num_block_types
[
0
]
<
<
kLiteralContextBits
;
i
+
+
)
{
if
(
s
-
>
context_map
[
i
]
!
=
i
>
>
kLiteralContextBits
)
{
s
-
>
trivial_literal_context
=
0
;
break
;
}
}
s
-
>
state
=
BROTLI_STATE_CONTEXT_MAP_2
;
case
BROTLI_STATE_CONTEXT_MAP_2
:
{
int
num_distance_codes
=
s
-
>
num_direct_distance_codes
+
(
48
<
<
s
-
>
distance_postfix_bits
)
;
result
=
DecodeContextMap
(
s
-
>
num_block_types
[
2
]
<
<
kDistanceContextBits
&
s
-
>
num_dist_htrees
&
s
-
>
dist_context_map
s
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
{
break
;
}
BrotliHuffmanTreeGroupInit
(
&
s
-
>
literal_hgroup
kNumLiteralCodes
s
-
>
num_literal_htrees
)
;
BrotliHuffmanTreeGroupInit
(
&
s
-
>
insert_copy_hgroup
kNumInsertAndCopyCodes
s
-
>
num_block_types
[
1
]
)
;
BrotliHuffmanTreeGroupInit
(
&
s
-
>
distance_hgroup
num_distance_codes
s
-
>
num_dist_htrees
)
;
}
i
=
0
;
s
-
>
state
=
BROTLI_STATE_TREE_GROUP
;
case
BROTLI_STATE_TREE_GROUP
:
{
HuffmanTreeGroup
*
hgroup
=
NULL
;
switch
(
i
)
{
case
0
:
hgroup
=
&
s
-
>
literal_hgroup
;
break
;
case
1
:
hgroup
=
&
s
-
>
insert_copy_hgroup
;
break
;
case
2
:
hgroup
=
&
s
-
>
distance_hgroup
;
break
;
}
result
=
HuffmanTreeGroupDecode
(
hgroup
s
)
;
}
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
break
;
i
+
+
;
if
(
i
>
=
3
)
{
uint8_t
context_mode
=
s
-
>
context_modes
[
s
-
>
block_type_rb
[
1
]
]
;
s
-
>
context_map_slice
=
s
-
>
context_map
;
s
-
>
dist_context_map_slice
=
s
-
>
dist_context_map
;
s
-
>
context_lookup1
=
&
kContextLookup
[
kContextLookupOffsets
[
context_mode
]
]
;
s
-
>
context_lookup2
=
&
kContextLookup
[
kContextLookupOffsets
[
context_mode
+
1
]
]
;
s
-
>
htree_command
=
s
-
>
insert_copy_hgroup
.
htrees
[
0
]
;
s
-
>
literal_htree
=
s
-
>
literal_hgroup
.
htrees
[
s
-
>
literal_htree_index
]
;
s
-
>
state
=
BROTLI_STATE_COMMAND_BEGIN
;
}
break
;
case
BROTLI_STATE_COMMAND_BEGIN
:
if
(
s
-
>
meta_block_remaining_len
<
=
0
)
{
s
-
>
state
=
BROTLI_STATE_METABLOCK_DONE
;
break
;
}
CommandBegin
:
if
(
!
BrotliCheckInputAmount
(
br
32
)
)
{
s
-
>
state
=
BROTLI_STATE_COMMAND_BEGIN
;
result
=
BROTLI_RESULT_NEEDS_MORE_INPUT
;
break
;
}
if
(
s
-
>
block_length
[
1
]
=
=
0
)
{
DecodeBlockType
(
s
-
>
num_block_types
[
1
]
s
-
>
block_type_trees
1
s
-
>
block_type_rb
br
)
;
s
-
>
htree_command
=
s
-
>
insert_copy_hgroup
.
htrees
[
s
-
>
block_type_rb
[
3
]
]
;
s
-
>
block_length
[
1
]
=
ReadBlockLength
(
&
s
-
>
block_len_trees
[
BROTLI_HUFFMAN_MAX_TABLE_SIZE
]
br
)
;
}
{
int
cmd_code
=
ReadSymbol
(
s
-
>
htree_command
br
)
;
int
insert_len_extra
=
0
;
CmdLutElement
v
;
-
-
s
-
>
block_length
[
1
]
;
v
=
kCmdLut
[
cmd_code
]
;
s
-
>
distance_code
=
v
.
distance_code
;
s
-
>
distance_context
=
v
.
context
;
s
-
>
dist_htree_index
=
s
-
>
dist_context_map_slice
[
s
-
>
distance_context
]
;
i
=
v
.
insert_len_offset
;
if
(
PREDICT_FALSE
(
v
.
insert_len_extra_bits
!
=
0
)
)
{
insert_len_extra
=
(
int
)
BrotliReadBits
(
br
v
.
insert_len_extra_bits
)
;
}
s
-
>
copy_length
=
(
int
)
BrotliReadBits
(
br
v
.
copy_len_extra_bits
)
+
v
.
copy_len_offset
;
i
+
=
insert_len_extra
;
}
BROTLI_LOG_UINT
(
i
)
;
BROTLI_LOG_UINT
(
s
-
>
copy_length
)
;
BROTLI_LOG_UINT
(
s
-
>
distance_code
)
;
if
(
i
=
=
0
)
{
goto
postDecodeLiterals
;
}
s
-
>
meta_block_remaining_len
-
=
i
;
case
BROTLI_STATE_COMMAND_INNER
:
if
(
s
-
>
trivial_literal_context
)
{
unsigned
bits
;
unsigned
value
;
PreloadSymbol
(
s
-
>
literal_htree
br
&
bits
&
value
)
;
do
{
if
(
!
BrotliCheckInputAmount
(
br
64
)
)
{
s
-
>
state
=
BROTLI_STATE_COMMAND_INNER
;
result
=
BROTLI_RESULT_NEEDS_MORE_INPUT
;
break
;
}
if
(
PREDICT_FALSE
(
s
-
>
block_length
[
0
]
=
=
0
)
)
{
DecodeBlockTypeWithContext
(
s
br
)
;
PreloadSymbol
(
s
-
>
literal_htree
br
&
bits
&
value
)
;
}
s
-
>
ringbuffer
[
pos
]
=
(
uint8_t
)
ReadPreloadedSymbol
(
s
-
>
literal_htree
br
&
bits
&
value
)
;
-
-
s
-
>
block_length
[
0
]
;
BROTLI_LOG_UINT
(
s
-
>
literal_htree_index
)
;
BROTLI_LOG_ARRAY_INDEX
(
s
-
>
ringbuffer
pos
)
;
+
+
pos
;
if
(
PREDICT_FALSE
(
pos
=
=
s
-
>
ringbuffer_size
)
)
{
s
-
>
to_write
=
s
-
>
ringbuffer_size
;
s
-
>
partially_written
=
0
;
s
-
>
state
=
BROTLI_STATE_COMMAND_INNER_WRITE
;
-
-
i
;
goto
innerWrite
;
}
}
while
(
-
-
i
!
=
0
)
;
}
else
{
uint8_t
p1
=
s
-
>
ringbuffer
[
(
pos
-
1
)
&
s
-
>
ringbuffer_mask
]
;
uint8_t
p2
=
s
-
>
ringbuffer
[
(
pos
-
2
)
&
s
-
>
ringbuffer_mask
]
;
do
{
const
HuffmanCode
*
hc
;
if
(
!
BrotliCheckInputAmount
(
br
64
)
)
{
s
-
>
state
=
BROTLI_STATE_COMMAND_INNER
;
result
=
BROTLI_RESULT_NEEDS_MORE_INPUT
;
break
;
}
if
(
PREDICT_FALSE
(
s
-
>
block_length
[
0
]
=
=
0
)
)
{
DecodeBlockTypeWithContext
(
s
br
)
;
}
context
=
s
-
>
context_lookup1
[
p1
]
|
s
-
>
context_lookup2
[
p2
]
;
BROTLI_LOG_UINT
(
context
)
;
hc
=
s
-
>
literal_hgroup
.
htrees
[
s
-
>
context_map_slice
[
context
]
]
;
-
-
s
-
>
block_length
[
0
]
;
p2
=
p1
;
p1
=
(
uint8_t
)
ReadSymbol
(
hc
br
)
;
s
-
>
ringbuffer
[
pos
]
=
p1
;
BROTLI_LOG_UINT
(
s
-
>
context_map_slice
[
context
]
)
;
BROTLI_LOG_ARRAY_INDEX
(
s
-
>
ringbuffer
pos
&
s
-
>
ringbuffer_mask
)
;
+
+
pos
;
if
(
PREDICT_FALSE
(
pos
=
=
s
-
>
ringbuffer_size
)
)
{
s
-
>
to_write
=
s
-
>
ringbuffer_size
;
s
-
>
partially_written
=
0
;
s
-
>
state
=
BROTLI_STATE_COMMAND_INNER_WRITE
;
-
-
i
;
goto
innerWrite
;
}
}
while
(
-
-
i
!
=
0
)
;
}
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
break
;
if
(
s
-
>
meta_block_remaining_len
<
=
0
)
{
s
-
>
state
=
BROTLI_STATE_METABLOCK_DONE
;
break
;
}
postDecodeLiterals
:
if
(
s
-
>
distance_code
>
=
0
)
{
-
-
s
-
>
dist_rb_idx
;
s
-
>
distance_code
=
s
-
>
dist_rb
[
s
-
>
dist_rb_idx
&
3
]
;
goto
postReadDistance
;
}
BROTLI_DCHECK
(
s
-
>
distance_code
<
0
)
;
if
(
s
-
>
block_length
[
2
]
=
=
0
)
{
int
dist_context_offset
;
DecodeBlockType
(
s
-
>
num_block_types
[
2
]
s
-
>
block_type_trees
2
s
-
>
block_type_rb
br
)
;
s
-
>
block_length
[
2
]
=
ReadBlockLength
(
&
s
-
>
block_len_trees
[
2
*
BROTLI_HUFFMAN_MAX_TABLE_SIZE
]
br
)
;
dist_context_offset
=
s
-
>
block_type_rb
[
5
]
<
<
kDistanceContextBits
;
s
-
>
dist_context_map_slice
=
s
-
>
dist_context_map
+
dist_context_offset
;
s
-
>
dist_htree_index
=
s
-
>
dist_context_map_slice
[
s
-
>
distance_context
]
;
}
-
-
s
-
>
block_length
[
2
]
;
s
-
>
distance_code
=
ReadSymbol
(
s
-
>
distance_hgroup
.
htrees
[
s
-
>
dist_htree_index
]
br
)
;
if
(
(
s
-
>
distance_code
&
~
0xf
)
=
=
0
)
{
if
(
s
-
>
distance_code
=
=
0
)
{
-
-
s
-
>
dist_rb_idx
;
s
-
>
distance_code
=
s
-
>
dist_rb
[
s
-
>
dist_rb_idx
&
3
]
;
}
else
{
int
distance_code
=
s
-
>
distance_code
<
<
1
;
const
uint32_t
kDistanceShortCodeIndexOffset
=
0xaaafff1b
;
const
uint32_t
kDistanceShortCodeValueOffset
=
0xfa5fa500
;
int
v
=
(
s
-
>
dist_rb_idx
+
(
int
)
(
kDistanceShortCodeIndexOffset
>
>
distance_code
)
)
&
0x3
;
s
-
>
distance_code
=
s
-
>
dist_rb
[
v
]
;
v
=
(
int
)
(
kDistanceShortCodeValueOffset
>
>
distance_code
)
&
0x3
;
if
(
(
distance_code
&
0x3
)
!
=
0
)
{
s
-
>
distance_code
+
=
v
;
}
else
{
s
-
>
distance_code
-
=
v
;
if
(
s
-
>
distance_code
<
=
0
)
{
s
-
>
distance_code
=
0x0fffffff
;
}
}
}
}
else
{
int
distval
=
s
-
>
distance_code
-
s
-
>
num_direct_distance_codes
;
if
(
distval
>
=
0
)
{
int
nbits
;
int
postfix
;
int
offset
;
if
(
s
-
>
distance_postfix_bits
=
=
0
)
{
nbits
=
(
distval
>
>
1
)
+
1
;
offset
=
(
(
2
+
(
distval
&
1
)
)
<
<
nbits
)
-
4
;
s
-
>
distance_code
=
s
-
>
num_direct_distance_codes
+
offset
+
(
int
)
BrotliReadBits
(
br
nbits
)
;
}
else
{
postfix
=
distval
&
s
-
>
distance_postfix_mask
;
distval
>
>
=
s
-
>
distance_postfix_bits
;
nbits
=
(
distval
>
>
1
)
+
1
;
offset
=
(
(
2
+
(
distval
&
1
)
)
<
<
nbits
)
-
4
;
s
-
>
distance_code
=
s
-
>
num_direct_distance_codes
+
(
(
offset
+
(
int
)
BrotliReadBits
(
br
nbits
)
)
<
<
s
-
>
distance_postfix_bits
)
+
postfix
;
}
}
s
-
>
distance_code
=
s
-
>
distance_code
-
NUM_DISTANCE_SHORT_CODES
+
1
;
}
postReadDistance
:
BROTLI_LOG_UINT
(
s
-
>
distance_code
)
;
if
(
s
-
>
max_distance
!
=
s
-
>
max_backward_distance
)
{
if
(
pos
<
s
-
>
max_backward_distance_minus_custom_dict_size
)
{
s
-
>
max_distance
=
pos
+
s
-
>
custom_dict_size
;
}
else
{
s
-
>
max_distance
=
s
-
>
max_backward_distance
;
}
}
i
=
s
-
>
copy_length
;
if
(
s
-
>
distance_code
>
s
-
>
max_distance
)
{
if
(
i
>
=
kBrotliMinDictionaryWordLength
&
&
i
<
=
kBrotliMaxDictionaryWordLength
)
{
int
offset
=
kBrotliDictionaryOffsetsByLength
[
i
]
;
int
word_id
=
s
-
>
distance_code
-
s
-
>
max_distance
-
1
;
int
shift
=
kBrotliDictionarySizeBitsByLength
[
i
]
;
int
mask
=
(
int
)
BitMask
(
shift
)
;
int
word_idx
=
word_id
&
mask
;
int
transform_idx
=
word_id
>
>
shift
;
offset
+
=
word_idx
*
i
;
if
(
transform_idx
<
kNumTransforms
)
{
const
uint8_t
*
word
=
&
kBrotliDictionary
[
offset
]
;
int
len
=
i
;
if
(
transform_idx
=
=
0
)
{
memcpy
(
&
s
-
>
ringbuffer
[
pos
]
word
(
size_t
)
len
)
;
}
else
{
len
=
TransformDictionaryWord
(
&
s
-
>
ringbuffer
[
pos
]
word
len
transform_idx
)
;
}
pos
+
=
len
;
s
-
>
meta_block_remaining_len
-
=
len
;
if
(
pos
>
=
s
-
>
ringbuffer_size
)
{
s
-
>
to_write
=
s
-
>
ringbuffer_size
;
s
-
>
partially_written
=
0
;
s
-
>
state
=
BROTLI_STATE_COMMAND_POST_WRITE_1
;
break
;
}
}
else
{
BROTLI_LOG
(
(
"
Invalid
backward
reference
.
pos
:
%
d
distance
:
%
d
"
"
len
:
%
d
bytes
left
:
%
d
\
n
"
pos
s
-
>
distance_code
i
s
-
>
meta_block_remaining_len
)
)
;
result
=
BROTLI_FAILURE
(
)
;
break
;
}
}
else
{
BROTLI_LOG
(
(
"
Invalid
backward
reference
.
pos
:
%
d
distance
:
%
d
"
"
len
:
%
d
bytes
left
:
%
d
\
n
"
pos
s
-
>
distance_code
i
s
-
>
meta_block_remaining_len
)
)
;
result
=
BROTLI_FAILURE
(
)
;
break
;
}
}
else
{
const
uint8_t
*
ringbuffer_end_minus_copy_length
=
s
-
>
ringbuffer_end
-
i
;
copy_src
=
&
s
-
>
ringbuffer
[
(
pos
-
s
-
>
distance_code
)
&
s
-
>
ringbuffer_mask
]
;
copy_dst
=
&
s
-
>
ringbuffer
[
pos
]
;
s
-
>
dist_rb
[
s
-
>
dist_rb_idx
&
3
]
=
s
-
>
distance_code
;
+
+
s
-
>
dist_rb_idx
;
s
-
>
meta_block_remaining_len
-
=
i
;
if
(
PREDICT_FALSE
(
s
-
>
meta_block_remaining_len
<
0
)
)
{
BROTLI_LOG
(
(
"
Invalid
backward
reference
.
pos
:
%
d
distance
:
%
d
"
"
len
:
%
d
bytes
left
:
%
d
\
n
"
pos
s
-
>
distance_code
i
s
-
>
meta_block_remaining_len
)
)
;
result
=
BROTLI_FAILURE
(
)
;
break
;
}
memmove16
(
copy_dst
copy_src
)
;
if
(
copy_src
<
copy_dst
)
{
if
(
copy_dst
>
=
ringbuffer_end_minus_copy_length
)
{
goto
postWrapCopy
;
}
if
(
copy_src
+
i
>
copy_dst
)
{
goto
postSelfintersecting
;
}
}
else
{
if
(
copy_src
>
=
ringbuffer_end_minus_copy_length
)
{
goto
postWrapCopy
;
}
if
(
copy_dst
+
i
>
copy_src
)
{
goto
postSelfintersecting
;
}
}
pos
+
=
i
;
if
(
i
>
16
)
{
if
(
i
>
32
)
{
memcpy
(
copy_dst
+
16
copy_src
+
16
(
size_t
)
(
i
-
16
)
)
;
}
else
{
memmove16
(
copy_dst
+
16
copy_src
+
16
)
;
}
}
}
if
(
s
-
>
meta_block_remaining_len
<
=
0
)
{
s
-
>
state
=
BROTLI_STATE_METABLOCK_DONE
;
break
;
}
else
{
goto
CommandBegin
;
}
postSelfintersecting
:
while
(
-
-
i
>
=
0
)
{
s
-
>
ringbuffer
[
pos
]
=
s
-
>
ringbuffer
[
(
pos
-
s
-
>
distance_code
)
&
s
-
>
ringbuffer_mask
]
;
+
+
pos
;
}
if
(
s
-
>
meta_block_remaining_len
<
=
0
)
{
s
-
>
state
=
BROTLI_STATE_METABLOCK_DONE
;
break
;
}
else
{
goto
CommandBegin
;
}
postWrapCopy
:
s
-
>
state
=
BROTLI_STATE_COMMAND_POST_WRAP_COPY
;
case
BROTLI_STATE_COMMAND_POST_WRAP_COPY
:
while
(
-
-
i
>
=
0
)
{
s
-
>
ringbuffer
[
pos
]
=
s
-
>
ringbuffer
[
(
pos
-
s
-
>
distance_code
)
&
s
-
>
ringbuffer_mask
]
;
+
+
pos
;
if
(
pos
=
=
s
-
>
ringbuffer_size
)
{
s
-
>
to_write
=
s
-
>
ringbuffer_size
;
s
-
>
partially_written
=
0
;
s
-
>
state
=
BROTLI_STATE_COMMAND_POST_WRITE_2
;
break
;
}
}
if
(
s
-
>
state
=
=
BROTLI_STATE_COMMAND_POST_WRAP_COPY
)
{
if
(
s
-
>
meta_block_remaining_len
<
=
0
)
{
s
-
>
state
=
BROTLI_STATE_METABLOCK_DONE
;
break
;
}
else
{
goto
CommandBegin
;
}
}
break
;
case
BROTLI_STATE_COMMAND_INNER_WRITE
:
case
BROTLI_STATE_COMMAND_POST_WRITE_1
:
case
BROTLI_STATE_COMMAND_POST_WRITE_2
:
innerWrite
:
result
=
WriteRingBuffer
(
output
s
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
{
break
;
}
pos
-
=
s
-
>
ringbuffer_size
;
s
-
>
max_distance
=
s
-
>
max_backward_distance
;
if
(
s
-
>
state
=
=
BROTLI_STATE_COMMAND_POST_WRITE_1
)
{
memcpy
(
s
-
>
ringbuffer
s
-
>
ringbuffer_end
(
size_t
)
pos
)
;
if
(
s
-
>
meta_block_remaining_len
<
=
0
)
{
s
-
>
state
=
BROTLI_STATE_METABLOCK_DONE
;
break
;
}
else
{
goto
CommandBegin
;
}
}
else
if
(
s
-
>
state
=
=
BROTLI_STATE_COMMAND_POST_WRITE_2
)
{
s
-
>
state
=
BROTLI_STATE_COMMAND_POST_WRAP_COPY
;
}
else
{
if
(
i
=
=
0
)
{
if
(
s
-
>
meta_block_remaining_len
<
=
0
)
{
s
-
>
state
=
BROTLI_STATE_METABLOCK_DONE
;
break
;
}
goto
postDecodeLiterals
;
}
s
-
>
state
=
BROTLI_STATE_COMMAND_INNER
;
}
break
;
case
BROTLI_STATE_METABLOCK_DONE
:
BrotliStateCleanupAfterMetablock
(
s
)
;
if
(
!
s
-
>
is_last_metablock
)
{
s
-
>
state
=
BROTLI_STATE_METABLOCK_BEGIN
;
break
;
}
s
-
>
to_write
=
pos
;
s
-
>
partially_written
=
0
;
s
-
>
state
=
BROTLI_STATE_DONE
;
case
BROTLI_STATE_DONE
:
if
(
s
-
>
ringbuffer
!
=
0
)
{
result
=
WriteRingBuffer
(
output
s
)
;
if
(
result
!
=
BROTLI_RESULT_SUCCESS
)
{
break
;
}
}
if
(
!
BrotliJumpToByteBoundary
(
br
)
)
{
result
=
BROTLI_FAILURE
(
)
;
}
if
(
!
BrotliIsBitReaderOK
(
br
)
)
{
result
=
BROTLI_FAILURE
(
)
;
}
return
result
;
}
}
s
-
>
pos
=
pos
;
s
-
>
loop_counter
=
i
;
return
result
;
}
void
BrotliSetCustomDictionary
(
size_t
size
const
uint8_t
*
dict
BrotliState
*
s
)
{
s
-
>
custom_dict
=
dict
;
s
-
>
custom_dict_size
=
(
int
)
size
;
}
#
if
defined
(
__cplusplus
)
|
|
defined
(
c_plusplus
)
}
#
endif
