#
ifndef
BROTLI_DEC_BIT_READER_H_
#
define
BROTLI_DEC_BIT_READER_H_
#
include
<
string
.
h
>
#
include
"
.
/
port
.
h
"
#
include
"
.
/
streams
.
h
"
#
include
"
.
/
types
.
h
"
#
if
defined
(
__cplusplus
)
|
|
defined
(
c_plusplus
)
extern
"
C
"
{
#
endif
#
define
BROTLI_READ_SIZE
1024
#
define
BROTLI_IMPLICIT_ZEROES
136
#
define
BROTLI_IBUF_SIZE
(
BROTLI_READ_SIZE
+
BROTLI_IMPLICIT_ZEROES
)
#
define
BROTLI_IBUF_MASK
(
BROTLI_READ_SIZE
-
1
)
static
BROTLI_INLINE
uint32_t
BitMask
(
int
n
)
{
return
~
(
(
0xffffffff
)
<
<
n
)
;
}
typedef
struct
{
#
if
(
BROTLI_64_BITS_LITTLE_ENDIAN
)
uint64_t
val_
;
#
else
uint32_t
val_
;
#
endif
uint32_t
bit_pos_
;
uint8_t
*
next_in
;
uint32_t
avail_in
;
int
eos_
;
BrotliInput
input_
;
uint8_t
buf_
[
BROTLI_IBUF_SIZE
]
;
}
BrotliBitReader
;
void
BrotliInitBitReader
(
BrotliBitReader
*
const
br
BrotliInput
input
)
;
int
BrotliWarmupBitReader
(
BrotliBitReader
*
const
br
)
;
static
BROTLI_INLINE
int
BrotliReadInput
(
BrotliBitReader
*
const
br
int
finish
)
{
if
(
PREDICT_FALSE
(
br
-
>
eos_
)
)
{
return
0
;
}
else
{
size_t
i
;
int
bytes_read
;
if
(
br
-
>
next_in
!
=
br
-
>
buf_
)
{
for
(
i
=
0
;
i
<
br
-
>
avail_in
;
i
+
+
)
{
br
-
>
buf_
[
i
]
=
br
-
>
next_in
[
i
]
;
}
br
-
>
next_in
=
br
-
>
buf_
;
}
bytes_read
=
BrotliRead
(
br
-
>
input_
br
-
>
next_in
+
br
-
>
avail_in
(
size_t
)
(
BROTLI_READ_SIZE
-
br
-
>
avail_in
)
)
;
if
(
bytes_read
<
0
)
{
return
0
;
}
br
-
>
avail_in
+
=
(
uint32_t
)
bytes_read
;
if
(
br
-
>
avail_in
<
BROTLI_READ_SIZE
)
{
if
(
!
finish
)
{
return
0
;
}
br
-
>
eos_
=
1
;
memset
(
br
-
>
next_in
+
br
-
>
avail_in
0
BROTLI_IMPLICIT_ZEROES
)
;
br
-
>
avail_in
+
=
BROTLI_IMPLICIT_ZEROES
;
}
return
1
;
}
}
static
BROTLI_INLINE
size_t
BrotliGetRemainingBytes
(
BrotliBitReader
*
br
)
{
size_t
result
=
br
-
>
avail_in
+
sizeof
(
br
-
>
val_
)
-
(
br
-
>
bit_pos_
>
>
3
)
;
if
(
!
br
-
>
eos_
)
{
return
result
;
}
if
(
result
<
=
BROTLI_IMPLICIT_ZEROES
)
{
return
0
;
}
return
result
-
BROTLI_IMPLICIT_ZEROES
;
}
static
BROTLI_INLINE
int
BrotliCheckInputAmount
(
BrotliBitReader
*
const
br
size_t
num
)
{
return
br
-
>
avail_in
>
=
num
;
}
static
BROTLI_INLINE
void
BrotliFillBitWindow
(
BrotliBitReader
*
const
br
int
n_bits
)
{
#
if
(
BROTLI_64_BITS_LITTLE_ENDIAN
)
if
(
!
BROTLI_ALIGNED_READ
&
&
IS_CONSTANT
(
n_bits
)
&
&
(
n_bits
<
=
8
)
)
{
if
(
br
-
>
bit_pos_
>
=
56
)
{
br
-
>
val_
>
>
=
56
;
br
-
>
bit_pos_
^
=
56
;
br
-
>
val_
|
=
(
*
(
const
uint64_t
*
)
(
br
-
>
next_in
)
)
<
<
8
;
br
-
>
avail_in
-
=
7
;
br
-
>
next_in
+
=
7
;
}
}
else
if
(
!
BROTLI_ALIGNED_READ
&
&
IS_CONSTANT
(
n_bits
)
&
&
(
n_bits
<
=
16
)
)
{
if
(
br
-
>
bit_pos_
>
=
48
)
{
br
-
>
val_
>
>
=
48
;
br
-
>
bit_pos_
^
=
48
;
br
-
>
val_
|
=
(
*
(
const
uint64_t
*
)
(
br
-
>
next_in
)
)
<
<
16
;
br
-
>
avail_in
-
=
6
;
br
-
>
next_in
+
=
6
;
}
}
else
{
if
(
br
-
>
bit_pos_
>
=
32
)
{
br
-
>
val_
>
>
=
32
;
br
-
>
bit_pos_
^
=
32
;
br
-
>
val_
|
=
(
(
uint64_t
)
(
*
(
const
uint32_t
*
)
(
br
-
>
next_in
)
)
)
<
<
32
;
br
-
>
avail_in
-
=
4
;
br
-
>
next_in
+
=
4
;
}
}
#
elif
(
BROTLI_LITTLE_ENDIAN
)
if
(
!
BROTLI_ALIGNED_READ
&
&
IS_CONSTANT
(
n_bits
)
&
&
(
n_bits
<
=
8
)
)
{
if
(
br
-
>
bit_pos_
>
=
24
)
{
br
-
>
val_
>
>
=
24
;
br
-
>
bit_pos_
^
=
24
;
br
-
>
val_
|
=
(
*
(
const
uint32_t
*
)
(
br
-
>
next_in
)
)
<
<
8
;
br
-
>
avail_in
-
=
3
;
br
-
>
next_in
+
=
3
;
}
}
else
{
if
(
br
-
>
bit_pos_
>
=
16
)
{
br
-
>
val_
>
>
=
16
;
br
-
>
bit_pos_
^
=
16
;
br
-
>
val_
|
=
(
(
uint32_t
)
(
*
(
const
uint16_t
*
)
(
br
-
>
next_in
)
)
)
<
<
16
;
br
-
>
avail_in
-
=
2
;
br
-
>
next_in
+
=
2
;
}
}
#
else
while
(
br
-
>
bit_pos_
>
=
16
)
{
BrotliPullByte
(
br
)
;
}
#
endif
}
static
BROTLI_INLINE
void
BrotliPullByte
(
BrotliBitReader
*
const
br
)
{
br
-
>
val_
>
>
=
8
;
#
if
(
BROTLI_64_BITS_LITTLE_ENDIAN
)
br
-
>
val_
|
=
(
(
uint64_t
)
*
br
-
>
next_in
)
<
<
56
;
#
else
br
-
>
val_
|
=
(
(
uint32_t
)
*
br
-
>
next_in
)
<
<
24
;
#
endif
br
-
>
bit_pos_
-
=
8
;
-
-
br
-
>
avail_in
;
+
+
br
-
>
next_in
;
}
static
BROTLI_INLINE
uint32_t
BrotliGetBitsUnmasked
(
BrotliBitReader
*
const
br
int
n_bits
)
{
BrotliFillBitWindow
(
br
n_bits
)
;
return
(
uint32_t
)
(
br
-
>
val_
>
>
br
-
>
bit_pos_
)
;
}
static
BROTLI_INLINE
uint32_t
BrotliGetBits
(
BrotliBitReader
*
const
br
int
n_bits
)
{
BrotliFillBitWindow
(
br
n_bits
)
;
return
(
uint32_t
)
(
br
-
>
val_
>
>
br
-
>
bit_pos_
)
&
BitMask
(
n_bits
)
;
}
static
BROTLI_INLINE
void
BrotliDropBits
(
BrotliBitReader
*
const
br
int
n_bits
)
{
br
-
>
bit_pos_
+
=
(
uint32_t
)
n_bits
;
}
static
BROTLI_INLINE
void
BrotliTakeBits
(
BrotliBitReader
*
const
br
int
n_bits
uint32_t
*
val
)
{
*
val
=
(
uint32_t
)
(
br
-
>
val_
>
>
br
-
>
bit_pos_
)
&
BitMask
(
n_bits
)
;
#
ifdef
BROTLI_DECODE_DEBUG
printf
(
"
[
BrotliReadBits
]
%
d
%
d
%
d
val
:
%
6x
\
n
"
(
int
)
br
-
>
avail_in
(
int
)
br
-
>
bit_pos_
n_bits
(
int
)
*
val
)
;
#
endif
br
-
>
bit_pos_
+
=
(
uint32_t
)
n_bits
;
}
static
BROTLI_INLINE
uint32_t
BrotliReadBits
(
BrotliBitReader
*
const
br
int
n_bits
)
{
if
(
BROTLI_64_BITS_LITTLE_ENDIAN
|
|
(
n_bits
<
=
16
)
)
{
uint32_t
val
;
BrotliFillBitWindow
(
br
n_bits
)
;
BrotliTakeBits
(
br
n_bits
&
val
)
;
return
val
;
}
else
{
uint32_t
low_val
;
uint32_t
high_val
;
BrotliFillBitWindow
(
br
16
)
;
BrotliTakeBits
(
br
16
&
low_val
)
;
BrotliFillBitWindow
(
br
8
)
;
BrotliTakeBits
(
br
n_bits
-
16
&
high_val
)
;
return
low_val
|
(
high_val
<
<
16
)
;
}
}
static
BROTLI_INLINE
int
BrotliSafeReadBits
(
BrotliBitReader
*
const
br
int
n_bits
uint32_t
*
val
)
{
while
(
br
-
>
bit_pos_
+
(
uint32_t
)
n_bits
>
(
sizeof
(
br
-
>
val_
)
<
<
3
)
)
{
if
(
br
-
>
avail_in
=
=
0
)
{
return
0
;
}
BrotliPullByte
(
br
)
;
}
BrotliTakeBits
(
br
n_bits
val
)
;
return
1
;
}
static
BROTLI_INLINE
int
BrotliJumpToByteBoundary
(
BrotliBitReader
*
br
)
{
int
pad_bits_count
=
(
64
-
(
int
)
br
-
>
bit_pos_
)
&
0x7
;
uint32_t
pad_bits
=
0
;
if
(
pad_bits_count
!
=
0
)
{
BrotliTakeBits
(
br
pad_bits_count
&
pad_bits
)
;
}
return
pad_bits
=
=
0
;
}
static
BROTLI_INLINE
int
BrotliPeekByte
(
BrotliBitReader
*
br
int
offset
)
{
int
bytes_left
=
(
int
)
(
sizeof
(
br
-
>
val_
)
-
(
br
-
>
bit_pos_
>
>
3
)
)
;
if
(
br
-
>
bit_pos_
&
7
)
{
return
-
1
;
}
if
(
offset
<
bytes_left
)
{
return
(
br
-
>
val_
>
>
(
br
-
>
bit_pos_
+
(
unsigned
)
(
offset
<
<
3
)
)
)
&
0xFF
;
}
offset
-
=
bytes_left
;
if
(
offset
<
br
-
>
avail_in
)
{
return
br
-
>
next_in
[
offset
]
;
}
return
-
1
;
}
static
BROTLI_INLINE
void
BrotliCopyBytes
(
uint8_t
*
dest
BrotliBitReader
*
br
size_t
num
)
{
while
(
br
-
>
bit_pos_
+
8
<
=
(
BROTLI_64_BITS_LITTLE_ENDIAN
?
64
:
32
)
&
&
num
>
0
)
{
*
dest
=
(
uint8_t
)
(
br
-
>
val_
>
>
br
-
>
bit_pos_
)
;
br
-
>
bit_pos_
+
=
8
;
+
+
dest
;
-
-
num
;
}
memcpy
(
dest
br
-
>
next_in
num
)
;
br
-
>
avail_in
-
=
(
uint32_t
)
num
;
br
-
>
next_in
+
=
num
;
}
static
BROTLI_INLINE
int
BrotliIsBitReaderOK
(
BrotliBitReader
*
br
)
{
size_t
remaining_bytes
=
br
-
>
avail_in
+
sizeof
(
br
-
>
val_
)
-
(
br
-
>
bit_pos_
>
>
3
)
;
return
!
br
-
>
eos_
|
|
(
remaining_bytes
>
=
BROTLI_IMPLICIT_ZEROES
)
;
}
#
undef
BROTLI_IMPLICIT_ZEROES
#
undef
BROTLI_IBUF_SIZE
#
undef
BROTLI_IBUF_MASK
#
if
defined
(
__cplusplus
)
|
|
defined
(
c_plusplus
)
}
#
endif
#
endif
