#
ifndef
BROTLI_ENC_WRITE_BITS_H_
#
define
BROTLI_ENC_WRITE_BITS_H_
#
include
<
assert
.
h
>
#
include
<
stdio
.
h
>
#
include
"
.
/
port
.
h
"
#
include
"
.
/
types
.
h
"
namespace
brotli
{
inline
void
WriteBits
(
size_t
n_bits
uint64_t
bits
size_t
*
__restrict
pos
uint8_t
*
__restrict
array
)
{
#
ifdef
BIT_WRITER_DEBUG
printf
(
"
WriteBits
%
2d
0x
%
016llx
%
10d
\
n
"
n_bits
bits
*
pos
)
;
#
endif
assert
(
(
bits
>
>
n_bits
)
=
=
0
)
;
assert
(
n_bits
<
=
56
)
;
#
ifdef
IS_LITTLE_ENDIAN
uint8_t
*
p
=
&
array
[
*
pos
>
>
3
]
;
uint64_t
v
=
*
p
;
v
|
=
bits
<
<
(
*
pos
&
7
)
;
BROTLI_UNALIGNED_STORE64
(
p
v
)
;
*
pos
+
=
n_bits
;
#
else
uint8_t
*
array_pos
=
&
array
[
*
pos
>
>
3
]
;
const
size_t
bits_reserved_in_first_byte
=
(
*
pos
&
7
)
;
bits
<
<
=
bits_reserved_in_first_byte
;
*
array_pos
+
+
|
=
static_cast
<
uint8_t
>
(
bits
)
;
for
(
size_t
bits_left_to_write
=
n_bits
+
bits_reserved_in_first_byte
;
bits_left_to_write
>
=
9
;
bits_left_to_write
-
=
8
)
{
bits
>
>
=
8
;
*
array_pos
+
+
=
static_cast
<
uint8_t
>
(
bits
)
;
}
*
array_pos
=
0
;
*
pos
+
=
n_bits
;
#
endif
}
inline
void
WriteBitsPrepareStorage
(
size_t
pos
uint8_t
*
array
)
{
#
ifdef
BIT_WRITER_DEBUG
printf
(
"
WriteBitsPrepareStorage
%
10d
\
n
"
pos
)
;
#
endif
assert
(
(
pos
&
7
)
=
=
0
)
;
array
[
pos
>
>
3
]
=
0
;
}
}
#
endif
