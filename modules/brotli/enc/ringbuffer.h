#
ifndef
BROTLI_ENC_RINGBUFFER_H_
#
define
BROTLI_ENC_RINGBUFFER_H_
#
include
<
cstdlib
>
#
include
"
.
/
port
.
h
"
#
include
"
.
/
types
.
h
"
namespace
brotli
{
class
RingBuffer
{
public
:
RingBuffer
(
int
window_bits
int
tail_bits
)
:
size_
(
1u
<
<
window_bits
)
mask_
(
(
1u
<
<
window_bits
)
-
1
)
tail_size_
(
1u
<
<
tail_bits
)
total_size_
(
size_
+
tail_size_
)
cur_size_
(
0
)
pos_
(
0
)
data_
(
0
)
buffer_
(
0
)
{
}
~
RingBuffer
(
void
)
{
free
(
data_
)
;
}
inline
void
InitBuffer
(
const
uint32_t
buflen
)
{
static
const
size_t
kSlackForEightByteHashingEverywhere
=
7
;
cur_size_
=
buflen
;
data_
=
static_cast
<
uint8_t
*
>
(
realloc
(
data_
2
+
buflen
+
kSlackForEightByteHashingEverywhere
)
)
;
buffer_
=
data_
+
2
;
buffer_
[
-
2
]
=
buffer_
[
-
1
]
=
0
;
for
(
size_t
i
=
0
;
i
<
kSlackForEightByteHashingEverywhere
;
+
+
i
)
{
buffer_
[
cur_size_
+
i
]
=
0
;
}
}
void
Write
(
const
uint8_t
*
bytes
size_t
n
)
{
if
(
pos_
=
=
0
&
&
n
<
tail_size_
)
{
pos_
=
static_cast
<
uint32_t
>
(
n
)
;
InitBuffer
(
pos_
)
;
memcpy
(
buffer_
bytes
n
)
;
return
;
}
if
(
cur_size_
<
total_size_
)
{
InitBuffer
(
total_size_
)
;
buffer_
[
size_
-
2
]
=
0
;
buffer_
[
size_
-
1
]
=
0
;
}
const
size_t
masked_pos
=
pos_
&
mask_
;
WriteTail
(
bytes
n
)
;
if
(
PREDICT_TRUE
(
masked_pos
+
n
<
=
size_
)
)
{
memcpy
(
&
buffer_
[
masked_pos
]
bytes
n
)
;
}
else
{
memcpy
(
&
buffer_
[
masked_pos
]
bytes
std
:
:
min
(
n
total_size_
-
masked_pos
)
)
;
memcpy
(
&
buffer_
[
0
]
bytes
+
(
size_
-
masked_pos
)
n
-
(
size_
-
masked_pos
)
)
;
}
buffer_
[
-
2
]
=
buffer_
[
size_
-
2
]
;
buffer_
[
-
1
]
=
buffer_
[
size_
-
1
]
;
pos_
+
=
static_cast
<
uint32_t
>
(
n
)
;
if
(
pos_
>
(
1u
<
<
30
)
)
{
pos_
=
(
pos_
&
(
(
1u
<
<
30
)
-
1
)
)
|
(
1u
<
<
30
)
;
}
}
void
Reset
(
void
)
{
pos_
=
0
;
}
uint32_t
position
(
void
)
const
{
return
pos_
;
}
uint32_t
mask
(
void
)
const
{
return
mask_
;
}
uint8_t
*
start
(
void
)
{
return
&
buffer_
[
0
]
;
}
const
uint8_t
*
start
(
void
)
const
{
return
&
buffer_
[
0
]
;
}
private
:
void
WriteTail
(
const
uint8_t
*
bytes
size_t
n
)
{
const
size_t
masked_pos
=
pos_
&
mask_
;
if
(
PREDICT_FALSE
(
masked_pos
<
tail_size_
)
)
{
const
size_t
p
=
size_
+
masked_pos
;
memcpy
(
&
buffer_
[
p
]
bytes
std
:
:
min
(
n
tail_size_
-
masked_pos
)
)
;
}
}
const
uint32_t
size_
;
const
uint32_t
mask_
;
const
uint32_t
tail_size_
;
const
uint32_t
total_size_
;
uint32_t
cur_size_
;
uint32_t
pos_
;
uint8_t
*
data_
;
uint8_t
*
buffer_
;
}
;
}
#
endif
