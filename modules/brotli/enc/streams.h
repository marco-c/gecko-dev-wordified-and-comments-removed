#
ifndef
BROTLI_ENC_STREAMS_H_
#
define
BROTLI_ENC_STREAMS_H_
#
include
<
stdio
.
h
>
#
include
<
string
>
#
include
"
.
/
port
.
h
"
#
include
"
.
/
types
.
h
"
namespace
brotli
{
class
BrotliIn
{
public
:
virtual
~
BrotliIn
(
void
)
{
}
virtual
const
void
*
Read
(
size_t
n
size_t
*
nread
)
=
0
;
}
;
class
BrotliOut
{
public
:
virtual
~
BrotliOut
(
void
)
{
}
virtual
bool
Write
(
const
void
*
buf
size_t
n
)
=
0
;
}
;
class
BrotliMemIn
:
public
BrotliIn
{
public
:
BrotliMemIn
(
const
void
*
buf
size_t
len
)
;
void
Reset
(
const
void
*
buf
size_t
len
)
;
size_t
position
(
void
)
const
{
return
pos_
;
}
const
void
*
Read
(
size_t
n
size_t
*
OUTPUT
)
;
private
:
const
void
*
buf_
;
size_t
len_
;
size_t
pos_
;
}
;
class
BrotliMemOut
:
public
BrotliOut
{
public
:
BrotliMemOut
(
void
*
buf
size_t
len
)
;
void
Reset
(
void
*
buf
size_t
len
)
;
size_t
position
(
void
)
const
{
return
pos_
;
}
bool
Write
(
const
void
*
buf
size_t
n
)
;
private
:
void
*
buf_
;
size_t
len_
;
size_t
pos_
;
}
;
class
BrotliStringOut
:
public
BrotliOut
{
public
:
BrotliStringOut
(
std
:
:
string
*
buf
size_t
max_size
)
;
void
Reset
(
std
:
:
string
*
buf
size_t
max_len
)
;
bool
Write
(
const
void
*
buf
size_t
n
)
;
private
:
std
:
:
string
*
buf_
;
size_t
max_size_
;
}
;
class
BrotliFileIn
:
public
BrotliIn
{
public
:
BrotliFileIn
(
FILE
*
f
size_t
max_read_size
)
;
~
BrotliFileIn
(
void
)
;
const
void
*
Read
(
size_t
n
size_t
*
bytes_read
)
;
private
:
FILE
*
f_
;
char
*
buf_
;
size_t
buf_size_
;
}
;
class
BrotliFileOut
:
public
BrotliOut
{
public
:
explicit
BrotliFileOut
(
FILE
*
f
)
;
bool
Write
(
const
void
*
buf
size_t
n
)
;
private
:
FILE
*
f_
;
}
;
}
#
endif
