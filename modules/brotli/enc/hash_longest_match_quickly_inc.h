#
define
HashLongestMatchQuickly
HASHER
(
)
#
define
BUCKET_SIZE
(
1
<
<
BUCKET_BITS
)
#
define
HASH_MAP_SIZE
(
4
<
<
BUCKET_BITS
)
static
BROTLI_INLINE
size_t
FN
(
HashTypeLength
)
(
void
)
{
return
8
;
}
static
BROTLI_INLINE
size_t
FN
(
StoreLookahead
)
(
void
)
{
return
8
;
}
static
uint32_t
FN
(
HashBytes
)
(
const
uint8_t
*
data
)
{
const
uint64_t
h
=
(
(
BROTLI_UNALIGNED_LOAD64LE
(
data
)
<
<
(
64
-
8
*
HASH_LEN
)
)
*
kHashMul64
)
;
return
(
uint32_t
)
(
h
>
>
(
64
-
BUCKET_BITS
)
)
;
}
typedef
struct
HashLongestMatchQuickly
{
uint32_t
buckets_
[
BUCKET_SIZE
+
BUCKET_SWEEP
]
;
}
HashLongestMatchQuickly
;
static
BROTLI_INLINE
HashLongestMatchQuickly
*
FN
(
Self
)
(
HasherHandle
handle
)
{
return
(
HashLongestMatchQuickly
*
)
&
(
GetHasherCommon
(
handle
)
[
1
]
)
;
}
static
void
FN
(
Initialize
)
(
HasherHandle
handle
const
BrotliEncoderParams
*
params
)
{
BROTLI_UNUSED
(
handle
)
;
BROTLI_UNUSED
(
params
)
;
}
static
void
FN
(
Prepare
)
(
HasherHandle
handle
BROTLI_BOOL
one_shot
size_t
input_size
const
uint8_t
*
data
)
{
HashLongestMatchQuickly
*
self
=
FN
(
Self
)
(
handle
)
;
size_t
partial_prepare_threshold
=
HASH_MAP_SIZE
>
>
7
;
if
(
one_shot
&
&
input_size
<
=
partial_prepare_threshold
)
{
size_t
i
;
for
(
i
=
0
;
i
<
input_size
;
+
+
i
)
{
const
uint32_t
key
=
FN
(
HashBytes
)
(
&
data
[
i
]
)
;
memset
(
&
self
-
>
buckets_
[
key
]
0
BUCKET_SWEEP
*
sizeof
(
self
-
>
buckets_
[
0
]
)
)
;
}
}
else
{
memset
(
&
self
-
>
buckets_
[
0
]
0
sizeof
(
self
-
>
buckets_
)
)
;
}
}
static
BROTLI_INLINE
size_t
FN
(
HashMemAllocInBytes
)
(
const
BrotliEncoderParams
*
params
BROTLI_BOOL
one_shot
size_t
input_size
)
{
BROTLI_UNUSED
(
params
)
;
BROTLI_UNUSED
(
one_shot
)
;
BROTLI_UNUSED
(
input_size
)
;
return
sizeof
(
HashLongestMatchQuickly
)
;
}
static
BROTLI_INLINE
void
FN
(
Store
)
(
HasherHandle
handle
const
uint8_t
*
data
const
size_t
mask
const
size_t
ix
)
{
const
uint32_t
key
=
FN
(
HashBytes
)
(
&
data
[
ix
&
mask
]
)
;
const
uint32_t
off
=
(
ix
>
>
3
)
%
BUCKET_SWEEP
;
FN
(
Self
)
(
handle
)
-
>
buckets_
[
key
+
off
]
=
(
uint32_t
)
ix
;
}
static
BROTLI_INLINE
void
FN
(
StoreRange
)
(
HasherHandle
handle
const
uint8_t
*
data
const
size_t
mask
const
size_t
ix_start
const
size_t
ix_end
)
{
size_t
i
;
for
(
i
=
ix_start
;
i
<
ix_end
;
+
+
i
)
{
FN
(
Store
)
(
handle
data
mask
i
)
;
}
}
static
BROTLI_INLINE
void
FN
(
StitchToPreviousBlock
)
(
HasherHandle
handle
size_t
num_bytes
size_t
position
const
uint8_t
*
ringbuffer
size_t
ringbuffer_mask
)
{
if
(
num_bytes
>
=
FN
(
HashTypeLength
)
(
)
-
1
&
&
position
>
=
3
)
{
FN
(
Store
)
(
handle
ringbuffer
ringbuffer_mask
position
-
3
)
;
FN
(
Store
)
(
handle
ringbuffer
ringbuffer_mask
position
-
2
)
;
FN
(
Store
)
(
handle
ringbuffer
ringbuffer_mask
position
-
1
)
;
}
}
static
BROTLI_INLINE
void
FN
(
PrepareDistanceCache
)
(
HasherHandle
handle
int
*
BROTLI_RESTRICT
distance_cache
)
{
BROTLI_UNUSED
(
handle
)
;
BROTLI_UNUSED
(
distance_cache
)
;
}
static
BROTLI_INLINE
void
FN
(
FindLongestMatch
)
(
HasherHandle
handle
const
BrotliDictionary
*
dictionary
const
uint16_t
*
dictionary_hash
const
uint8_t
*
BROTLI_RESTRICT
data
const
size_t
ring_buffer_mask
const
int
*
BROTLI_RESTRICT
distance_cache
const
size_t
cur_ix
const
size_t
max_length
const
size_t
max_backward
const
size_t
gap
HasherSearchResult
*
BROTLI_RESTRICT
out
)
{
HashLongestMatchQuickly
*
self
=
FN
(
Self
)
(
handle
)
;
const
size_t
best_len_in
=
out
-
>
len
;
const
size_t
cur_ix_masked
=
cur_ix
&
ring_buffer_mask
;
const
uint32_t
key
=
FN
(
HashBytes
)
(
&
data
[
cur_ix_masked
]
)
;
int
compare_char
=
data
[
cur_ix_masked
+
best_len_in
]
;
score_t
min_score
=
out
-
>
score
;
score_t
best_score
=
out
-
>
score
;
size_t
best_len
=
best_len_in
;
size_t
cached_backward
=
(
size_t
)
distance_cache
[
0
]
;
size_t
prev_ix
=
cur_ix
-
cached_backward
;
out
-
>
len_code_delta
=
0
;
if
(
prev_ix
<
cur_ix
)
{
prev_ix
&
=
(
uint32_t
)
ring_buffer_mask
;
if
(
compare_char
=
=
data
[
prev_ix
+
best_len
]
)
{
size_t
len
=
FindMatchLengthWithLimit
(
&
data
[
prev_ix
]
&
data
[
cur_ix_masked
]
max_length
)
;
if
(
len
>
=
4
)
{
const
score_t
score
=
BackwardReferenceScoreUsingLastDistance
(
len
)
;
if
(
best_score
<
score
)
{
best_score
=
score
;
best_len
=
len
;
out
-
>
len
=
len
;
out
-
>
distance
=
cached_backward
;
out
-
>
score
=
best_score
;
compare_char
=
data
[
cur_ix_masked
+
best_len
]
;
if
(
BUCKET_SWEEP
=
=
1
)
{
self
-
>
buckets_
[
key
]
=
(
uint32_t
)
cur_ix
;
return
;
}
}
}
}
}
if
(
BUCKET_SWEEP
=
=
1
)
{
size_t
backward
;
size_t
len
;
prev_ix
=
self
-
>
buckets_
[
key
]
;
self
-
>
buckets_
[
key
]
=
(
uint32_t
)
cur_ix
;
backward
=
cur_ix
-
prev_ix
;
prev_ix
&
=
(
uint32_t
)
ring_buffer_mask
;
if
(
compare_char
!
=
data
[
prev_ix
+
best_len_in
]
)
{
return
;
}
if
(
BROTLI_PREDICT_FALSE
(
backward
=
=
0
|
|
backward
>
max_backward
)
)
{
return
;
}
len
=
FindMatchLengthWithLimit
(
&
data
[
prev_ix
]
&
data
[
cur_ix_masked
]
max_length
)
;
if
(
len
>
=
4
)
{
const
score_t
score
=
BackwardReferenceScore
(
len
backward
)
;
if
(
best_score
<
score
)
{
out
-
>
len
=
len
;
out
-
>
distance
=
backward
;
out
-
>
score
=
score
;
return
;
}
}
}
else
{
uint32_t
*
bucket
=
self
-
>
buckets_
+
key
;
int
i
;
prev_ix
=
*
bucket
+
+
;
for
(
i
=
0
;
i
<
BUCKET_SWEEP
;
+
+
i
prev_ix
=
*
bucket
+
+
)
{
const
size_t
backward
=
cur_ix
-
prev_ix
;
size_t
len
;
prev_ix
&
=
(
uint32_t
)
ring_buffer_mask
;
if
(
compare_char
!
=
data
[
prev_ix
+
best_len
]
)
{
continue
;
}
if
(
BROTLI_PREDICT_FALSE
(
backward
=
=
0
|
|
backward
>
max_backward
)
)
{
continue
;
}
len
=
FindMatchLengthWithLimit
(
&
data
[
prev_ix
]
&
data
[
cur_ix_masked
]
max_length
)
;
if
(
len
>
=
4
)
{
const
score_t
score
=
BackwardReferenceScore
(
len
backward
)
;
if
(
best_score
<
score
)
{
best_score
=
score
;
best_len
=
len
;
out
-
>
len
=
best_len
;
out
-
>
distance
=
backward
;
out
-
>
score
=
score
;
compare_char
=
data
[
cur_ix_masked
+
best_len
]
;
}
}
}
}
if
(
USE_DICTIONARY
&
&
min_score
=
=
out
-
>
score
)
{
SearchInStaticDictionary
(
dictionary
dictionary_hash
handle
&
data
[
cur_ix_masked
]
max_length
max_backward
+
gap
out
BROTLI_TRUE
)
;
}
self
-
>
buckets_
[
key
+
(
(
cur_ix
>
>
3
)
%
BUCKET_SWEEP
)
]
=
(
uint32_t
)
cur_ix
;
}
#
undef
HASH_MAP_SIZE
#
undef
BUCKET_SIZE
#
undef
HashLongestMatchQuickly
