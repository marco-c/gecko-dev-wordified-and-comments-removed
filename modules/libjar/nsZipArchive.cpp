#
define
READTYPE
int32_t
#
include
"
zlib
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
mozilla
/
MmapFaultHandler
.
h
"
#
include
"
prio
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MemUtils
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
stdlib
.
h
"
#
include
"
nsDirectoryService
.
h
"
#
include
"
nsWildCard
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsZipArchive
.
h
"
#
include
"
nsString
.
h
"
#
include
"
prenv
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
endif
#
include
<
new
>
#
define
ZIP_ARENABLOCKSIZE
(
1
*
1024
)
#
ifdef
XP_UNIX
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
limits
.
h
>
#
include
<
unistd
.
h
>
#
elif
defined
(
XP_WIN
)
#
include
<
io
.
h
>
#
endif
#
ifdef
__SYMBIAN32__
#
include
<
sys
/
syslimits
.
h
>
#
endif
#
ifndef
XP_UNIX
#
ifndef
S_IFMT
#
define
S_IFMT
0170000
#
endif
#
ifndef
S_IFLNK
#
define
S_IFLNK
0120000
#
endif
#
ifndef
PATH_MAX
#
define
PATH_MAX
1024
#
endif
#
endif
#
ifdef
XP_WIN
#
include
"
private
/
pprio
.
h
"
#
endif
using
namespace
mozilla
;
static
LazyLogModule
gZipLog
(
"
nsZipArchive
"
)
;
#
ifdef
LOG
#
undef
LOG
#
endif
#
ifdef
LOG_ENABLED
#
undef
LOG_ENABLED
#
endif
#
define
LOG
(
args
)
MOZ_LOG
(
gZipLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
gZipLog
mozilla
:
:
LogLevel
:
:
Debug
)
static
const
uint32_t
kMaxNameLength
=
PATH_MAX
;
static
const
uint16_t
kSyntheticTime
=
0
;
static
const
uint16_t
kSyntheticDate
=
(
1
+
(
1
<
<
5
)
+
(
0
<
<
9
)
)
;
static
uint16_t
xtoint
(
const
uint8_t
*
ii
)
;
static
uint32_t
xtolong
(
const
uint8_t
*
ll
)
;
static
uint32_t
HashName
(
const
char
*
aName
uint16_t
nameLen
)
;
class
ZipArchiveLogger
{
public
:
void
Init
(
const
char
*
env
)
{
StaticMutexAutoLock
lock
(
sLock
)
;
MOZ_ASSERT
(
mRefCnt
>
=
0
)
;
+
+
mRefCnt
;
if
(
!
mFd
)
{
nsCOMPtr
<
nsIFile
>
logFile
;
nsresult
rv
=
NS_NewLocalFile
(
NS_ConvertUTF8toUTF16
(
env
)
false
getter_AddRefs
(
logFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
rv
=
logFile
-
>
Create
(
nsIFile
:
:
NORMAL_FILE_TYPE
0644
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
PRFileDesc
*
file
;
#
ifdef
XP_WIN
nsAutoString
path
;
logFile
-
>
GetPath
(
path
)
;
if
(
path
.
IsEmpty
(
)
)
return
;
HANDLE
handle
=
CreateFileW
(
path
.
get
(
)
FILE_APPEND_DATA
FILE_SHARE_WRITE
nullptr
OPEN_ALWAYS
0
nullptr
)
;
if
(
handle
=
=
INVALID_HANDLE_VALUE
)
return
;
file
=
PR_ImportFile
(
(
PROsfd
)
handle
)
;
if
(
!
file
)
return
;
#
else
rv
=
logFile
-
>
OpenNSPRFileDesc
(
PR_WRONLY
|
PR_CREATE_FILE
|
PR_APPEND
|
PR_SYNC
0644
&
file
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
#
endif
mFd
=
file
;
}
}
void
Write
(
const
nsACString
&
zip
const
char
*
entry
)
{
StaticMutexAutoLock
lock
(
sLock
)
;
if
(
mFd
)
{
nsCString
buf
(
zip
)
;
buf
.
Append
(
'
'
)
;
buf
.
Append
(
entry
)
;
buf
.
Append
(
'
\
n
'
)
;
PR_Write
(
mFd
buf
.
get
(
)
buf
.
Length
(
)
)
;
}
}
void
Release
(
)
{
StaticMutexAutoLock
lock
(
sLock
)
;
MOZ_ASSERT
(
mRefCnt
>
0
)
;
if
(
(
0
=
=
-
-
mRefCnt
)
&
&
mFd
)
{
PR_Close
(
mFd
)
;
mFd
=
nullptr
;
}
}
private
:
static
StaticMutex
sLock
;
int
mRefCnt
MOZ_GUARDED_BY
(
sLock
)
;
PRFileDesc
*
mFd
MOZ_GUARDED_BY
(
sLock
)
;
}
;
StaticMutex
ZipArchiveLogger
:
:
sLock
;
static
ZipArchiveLogger
zipLog
;
nsresult
gZlibInit
(
z_stream
*
zs
)
{
memset
(
zs
0
sizeof
(
z_stream
)
)
;
int
zerr
=
inflateInit2
(
zs
-
MAX_WBITS
)
;
if
(
zerr
!
=
Z_OK
)
return
NS_ERROR_OUT_OF_MEMORY
;
return
NS_OK
;
}
nsZipHandle
:
:
nsZipHandle
(
)
:
mFileData
(
nullptr
)
mLen
(
0
)
mMap
(
nullptr
)
mRefCnt
(
0
)
mFileStart
(
nullptr
)
mTotalLen
(
0
)
{
}
NS_IMPL_ADDREF
(
nsZipHandle
)
NS_IMPL_RELEASE
(
nsZipHandle
)
nsresult
nsZipHandle
:
:
Init
(
nsIFile
*
file
nsZipHandle
*
*
ret
PRFileDesc
*
*
aFd
)
{
mozilla
:
:
AutoFDClose
fd
;
int32_t
flags
=
PR_RDONLY
;
#
if
defined
(
XP_WIN
)
flags
|
=
nsIFile
:
:
OS_READAHEAD
;
#
endif
LOG
(
(
"
ZipHandle
:
:
Init
%
s
"
file
-
>
HumanReadablePath
(
)
.
get
(
)
)
)
;
nsresult
rv
=
file
-
>
OpenNSPRFileDesc
(
flags
0000
&
fd
.
rwget
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
int64_t
size
=
PR_Available64
(
fd
)
;
if
(
size
>
=
INT32_MAX
)
return
NS_ERROR_FILE_TOO_BIG
;
PRFileMap
*
map
=
PR_CreateFileMap
(
fd
size
PR_PROT_READONLY
)
;
if
(
!
map
)
return
NS_ERROR_FAILURE
;
uint8_t
*
buf
=
(
uint8_t
*
)
PR_MemMap
(
map
0
(
uint32_t
)
size
)
;
if
(
!
buf
)
{
PR_CloseFileMap
(
map
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsZipHandle
>
handle
=
new
nsZipHandle
(
)
;
if
(
!
handle
)
{
PR_MemUnmap
(
buf
(
uint32_t
)
size
)
;
PR_CloseFileMap
(
map
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
#
if
defined
(
XP_WIN
)
if
(
aFd
)
{
*
aFd
=
fd
.
forget
(
)
;
}
#
else
handle
-
>
mNSPRFileDesc
=
fd
.
forget
(
)
;
#
endif
handle
-
>
mFile
.
Init
(
file
)
;
handle
-
>
mTotalLen
=
(
uint32_t
)
size
;
handle
-
>
mFileStart
=
buf
;
rv
=
handle
-
>
findDataStart
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
PR_MemUnmap
(
buf
(
uint32_t
)
size
)
;
handle
-
>
mFileStart
=
nullptr
;
PR_CloseFileMap
(
map
)
;
return
rv
;
}
handle
-
>
mMap
=
map
;
handle
.
forget
(
ret
)
;
return
NS_OK
;
}
nsresult
nsZipHandle
:
:
Init
(
nsZipArchive
*
zip
const
char
*
entry
nsZipHandle
*
*
ret
)
{
RefPtr
<
nsZipHandle
>
handle
=
new
nsZipHandle
(
)
;
if
(
!
handle
)
return
NS_ERROR_OUT_OF_MEMORY
;
LOG
(
(
"
ZipHandle
:
:
Init
entry
%
s
"
entry
)
)
;
handle
-
>
mBuf
=
MakeUnique
<
nsZipItemPtr
<
uint8_t
>
>
(
zip
entry
)
;
if
(
!
handle
-
>
mBuf
)
return
NS_ERROR_OUT_OF_MEMORY
;
if
(
!
handle
-
>
mBuf
-
>
Buffer
(
)
)
return
NS_ERROR_UNEXPECTED
;
handle
-
>
mMap
=
nullptr
;
handle
-
>
mFile
.
Init
(
zip
entry
)
;
handle
-
>
mTotalLen
=
handle
-
>
mBuf
-
>
Length
(
)
;
handle
-
>
mFileStart
=
handle
-
>
mBuf
-
>
Buffer
(
)
;
nsresult
rv
=
handle
-
>
findDataStart
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
handle
.
forget
(
ret
)
;
return
NS_OK
;
}
nsresult
nsZipHandle
:
:
Init
(
const
uint8_t
*
aData
uint32_t
aLen
nsZipHandle
*
*
aRet
)
{
RefPtr
<
nsZipHandle
>
handle
=
new
nsZipHandle
(
)
;
handle
-
>
mFileStart
=
aData
;
handle
-
>
mTotalLen
=
aLen
;
nsresult
rv
=
handle
-
>
findDataStart
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
handle
.
forget
(
aRet
)
;
return
NS_OK
;
}
nsresult
nsZipHandle
:
:
findDataStart
(
)
{
const
uint32_t
CRXIntSize
=
4
;
MMAP_FAULT_HANDLER_BEGIN_HANDLE
(
this
)
if
(
mTotalLen
>
CRXIntSize
*
4
&
&
xtolong
(
mFileStart
)
=
=
kCRXMagic
)
{
const
uint8_t
*
headerData
=
mFileStart
;
headerData
+
=
CRXIntSize
*
2
;
uint32_t
pubKeyLength
=
xtolong
(
headerData
)
;
headerData
+
=
CRXIntSize
;
uint32_t
sigLength
=
xtolong
(
headerData
)
;
uint32_t
headerSize
=
CRXIntSize
*
4
+
pubKeyLength
+
sigLength
;
if
(
mTotalLen
>
headerSize
)
{
mLen
=
mTotalLen
-
headerSize
;
mFileData
=
mFileStart
+
headerSize
;
return
NS_OK
;
}
}
mLen
=
mTotalLen
;
mFileData
=
mFileStart
;
MMAP_FAULT_HANDLER_CATCH
(
NS_ERROR_FAILURE
)
return
NS_OK
;
}
int64_t
nsZipHandle
:
:
SizeOfMapping
(
)
{
return
mTotalLen
;
}
nsresult
nsZipHandle
:
:
GetNSPRFileDesc
(
PRFileDesc
*
*
aNSPRFileDesc
)
{
if
(
!
aNSPRFileDesc
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
*
aNSPRFileDesc
=
mNSPRFileDesc
;
if
(
!
mNSPRFileDesc
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
NS_OK
;
}
nsZipHandle
:
:
~
nsZipHandle
(
)
{
if
(
mMap
)
{
PR_MemUnmap
(
(
void
*
)
mFileStart
mTotalLen
)
;
PR_CloseFileMap
(
mMap
)
;
}
mFileStart
=
nullptr
;
mFileData
=
nullptr
;
mMap
=
nullptr
;
mBuf
=
nullptr
;
}
already_AddRefed
<
nsZipArchive
>
nsZipArchive
:
:
OpenArchive
(
nsZipHandle
*
aZipHandle
PRFileDesc
*
aFd
)
{
nsresult
rv
;
RefPtr
<
nsZipArchive
>
self
(
new
nsZipArchive
(
aZipHandle
aFd
rv
)
)
;
LOG
(
(
"
ZipHandle
:
:
OpenArchive
[
%
p
]
"
self
.
get
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
self
=
nullptr
;
}
return
self
.
forget
(
)
;
}
already_AddRefed
<
nsZipArchive
>
nsZipArchive
:
:
OpenArchive
(
nsIFile
*
aFile
)
{
RefPtr
<
nsZipHandle
>
handle
;
#
if
defined
(
XP_WIN
)
mozilla
:
:
AutoFDClose
fd
;
nsresult
rv
=
nsZipHandle
:
:
Init
(
aFile
getter_AddRefs
(
handle
)
&
fd
.
rwget
(
)
)
;
#
else
nsresult
rv
=
nsZipHandle
:
:
Init
(
aFile
getter_AddRefs
(
handle
)
)
;
#
endif
if
(
NS_FAILED
(
rv
)
)
return
nullptr
;
#
if
defined
(
XP_WIN
)
return
OpenArchive
(
handle
fd
.
get
(
)
)
;
#
else
return
OpenArchive
(
handle
)
;
#
endif
}
nsresult
nsZipArchive
:
:
Test
(
const
char
*
aEntryName
)
{
nsZipItem
*
currItem
;
if
(
aEntryName
)
{
currItem
=
GetItem
(
aEntryName
)
;
if
(
!
currItem
)
return
NS_ERROR_FILE_NOT_FOUND
;
if
(
currItem
-
>
IsDirectory
(
)
)
return
NS_OK
;
return
ExtractFile
(
currItem
0
0
)
;
}
for
(
auto
*
item
:
mFiles
)
{
for
(
currItem
=
item
;
currItem
;
currItem
=
currItem
-
>
next
)
{
if
(
currItem
-
>
IsDirectory
(
)
)
continue
;
nsresult
rv
=
ExtractFile
(
currItem
0
0
)
;
if
(
rv
!
=
NS_OK
)
return
rv
;
}
}
return
NS_OK
;
}
nsZipItem
*
nsZipArchive
:
:
GetItem
(
const
char
*
aEntryName
)
{
MutexAutoLock
lock
(
mLock
)
;
LOG
(
(
"
ZipHandle
:
:
GetItem
[
%
p
]
%
s
"
this
aEntryName
)
)
;
if
(
aEntryName
)
{
uint32_t
len
=
strlen
(
aEntryName
)
;
if
(
!
mBuiltSynthetics
)
{
if
(
(
len
>
0
)
&
&
(
aEntryName
[
len
-
1
]
=
=
'
/
'
)
)
{
if
(
BuildSynthetics
(
)
!
=
NS_OK
)
return
0
;
}
}
MMAP_FAULT_HANDLER_BEGIN_HANDLE
(
mFd
)
nsZipItem
*
item
=
mFiles
[
HashName
(
aEntryName
len
)
]
;
while
(
item
)
{
if
(
(
len
=
=
item
-
>
nameLength
)
&
&
(
!
memcmp
(
aEntryName
item
-
>
Name
(
)
len
)
)
)
{
if
(
mUseZipLog
&
&
mURI
.
Length
(
)
)
{
zipLog
.
Write
(
mURI
aEntryName
)
;
}
return
item
;
}
item
=
item
-
>
next
;
}
MMAP_FAULT_HANDLER_CATCH
(
nullptr
)
}
return
nullptr
;
}
nsresult
nsZipArchive
:
:
ExtractFile
(
nsZipItem
*
item
nsIFile
*
outFile
PRFileDesc
*
aFd
)
{
MutexAutoLock
lock
(
mLock
)
;
LOG
(
(
"
ZipHandle
:
:
ExtractFile
[
%
p
]
"
this
)
)
;
if
(
!
item
)
return
NS_ERROR_ILLEGAL_VALUE
;
if
(
!
mFd
)
return
NS_ERROR_FAILURE
;
MOZ_ASSERT
(
!
item
-
>
IsDirectory
(
)
)
;
Bytef
outbuf
[
ZIP_BUFLEN
]
;
nsZipCursor
cursor
(
item
this
outbuf
ZIP_BUFLEN
true
)
;
nsresult
rv
=
NS_OK
;
while
(
true
)
{
uint32_t
count
=
0
;
uint8_t
*
buf
=
cursor
.
Read
(
&
count
)
;
if
(
!
buf
)
{
rv
=
NS_ERROR_FILE_CORRUPTED
;
break
;
}
if
(
count
=
=
0
)
{
break
;
}
if
(
aFd
&
&
PR_Write
(
aFd
buf
count
)
<
(
READTYPE
)
count
)
{
rv
=
NS_ERROR_FILE_NO_DEVICE_SPACE
;
break
;
}
}
if
(
aFd
)
{
PR_Close
(
aFd
)
;
if
(
NS_FAILED
(
rv
)
&
&
outFile
)
{
outFile
-
>
Remove
(
false
)
;
}
}
return
rv
;
}
nsresult
nsZipArchive
:
:
FindInit
(
const
char
*
aPattern
nsZipFind
*
*
aFind
)
{
if
(
!
aFind
)
return
NS_ERROR_ILLEGAL_VALUE
;
MutexAutoLock
lock
(
mLock
)
;
LOG
(
(
"
ZipHandle
:
:
FindInit
[
%
p
]
"
this
)
)
;
*
aFind
=
nullptr
;
bool
regExp
=
false
;
char
*
pattern
=
0
;
nsresult
rv
=
BuildSynthetics
(
)
;
if
(
rv
!
=
NS_OK
)
return
rv
;
if
(
aPattern
)
{
switch
(
NS_WildCardValid
(
(
char
*
)
aPattern
)
)
{
case
INVALID_SXP
:
return
NS_ERROR_ILLEGAL_VALUE
;
case
NON_SXP
:
regExp
=
false
;
break
;
case
VALID_SXP
:
regExp
=
true
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
pattern
=
strdup
(
aPattern
)
;
if
(
!
pattern
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
*
aFind
=
new
nsZipFind
(
this
pattern
regExp
)
;
if
(
!
*
aFind
)
{
free
(
pattern
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
nsresult
nsZipFind
:
:
FindNext
(
const
char
*
*
aResult
uint16_t
*
aNameLen
)
{
if
(
!
mArchive
|
|
!
aResult
|
|
!
aNameLen
)
return
NS_ERROR_ILLEGAL_VALUE
;
MutexAutoLock
lock
(
mArchive
-
>
mLock
)
;
*
aResult
=
0
;
*
aNameLen
=
0
;
MMAP_FAULT_HANDLER_BEGIN_HANDLE
(
mArchive
-
>
GetFD
(
)
)
while
(
mSlot
<
ZIP_TABSIZE
)
{
mItem
=
mItem
?
mItem
-
>
next
:
mArchive
-
>
mFiles
[
mSlot
]
;
bool
found
=
false
;
if
(
!
mItem
)
+
+
mSlot
;
else
if
(
!
mPattern
)
found
=
true
;
else
if
(
mRegExp
)
{
char
buf
[
kMaxNameLength
+
1
]
;
memcpy
(
buf
mItem
-
>
Name
(
)
mItem
-
>
nameLength
)
;
buf
[
mItem
-
>
nameLength
]
=
'
\
0
'
;
found
=
(
NS_WildCardMatch
(
buf
mPattern
false
)
=
=
MATCH
)
;
}
else
found
=
(
(
mItem
-
>
nameLength
=
=
strlen
(
mPattern
)
)
&
&
(
memcmp
(
mItem
-
>
Name
(
)
mPattern
mItem
-
>
nameLength
)
=
=
0
)
)
;
if
(
found
)
{
*
aResult
=
mItem
-
>
Name
(
)
;
*
aNameLen
=
mItem
-
>
nameLength
;
LOG
(
(
"
ZipHandle
:
:
FindNext
[
%
p
]
%
s
"
this
*
aResult
)
)
;
return
NS_OK
;
}
}
MMAP_FAULT_HANDLER_CATCH
(
NS_ERROR_FAILURE
)
LOG
(
(
"
ZipHandle
:
:
FindNext
[
%
p
]
not
found
%
s
"
this
mPattern
)
)
;
return
NS_ERROR_FILE_NOT_FOUND
;
}
nsZipItem
*
nsZipArchive
:
:
CreateZipItem
(
)
{
return
(
nsZipItem
*
)
mArena
.
Allocate
(
sizeof
(
nsZipItem
)
mozilla
:
:
fallible
)
;
}
nsresult
nsZipArchive
:
:
BuildFileList
(
PRFileDesc
*
aFd
)
MOZ_NO_THREAD_SAFETY_ANALYSIS
{
const
uint8_t
*
buf
;
const
uint8_t
*
startp
=
mFd
-
>
mFileData
;
const
uint8_t
*
endp
=
startp
+
mFd
-
>
mLen
;
MMAP_FAULT_HANDLER_BEGIN_HANDLE
(
mFd
)
uint32_t
centralOffset
=
4
;
LOG
(
(
"
ZipHandle
:
:
BuildFileList
[
%
p
]
"
this
)
)
;
if
(
XRE_IsParentProcess
(
)
&
&
mFd
-
>
mLen
>
ZIPCENTRAL_SIZE
&
&
xtolong
(
startp
+
centralOffset
)
=
=
CENTRALSIG
)
{
uint32_t
readaheadLength
=
xtolong
(
startp
)
;
mozilla
:
:
PrefetchMemory
(
const_cast
<
uint8_t
*
>
(
startp
)
readaheadLength
)
;
}
else
{
for
(
buf
=
endp
-
ZIPEND_SIZE
;
buf
>
startp
;
buf
-
-
)
{
if
(
xtolong
(
buf
)
=
=
ENDSIG
)
{
centralOffset
=
xtolong
(
(
(
ZipEnd
*
)
buf
)
-
>
offset_central_dir
)
;
break
;
}
}
}
if
(
!
centralOffset
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
buf
=
startp
+
centralOffset
;
if
(
buf
<
startp
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
uint32_t
sig
=
0
;
while
(
(
buf
+
int32_t
(
sizeof
(
uint32_t
)
)
>
buf
)
&
&
(
buf
+
int32_t
(
sizeof
(
uint32_t
)
)
<
=
endp
)
&
&
(
(
sig
=
xtolong
(
buf
)
)
=
=
CENTRALSIG
)
)
{
if
(
(
buf
>
endp
)
|
|
(
endp
-
buf
<
ZIPCENTRAL_SIZE
)
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
ZipCentral
*
central
=
(
ZipCentral
*
)
buf
;
uint16_t
namelen
=
xtoint
(
central
-
>
filename_len
)
;
uint16_t
extralen
=
xtoint
(
central
-
>
extrafield_len
)
;
uint16_t
commentlen
=
xtoint
(
central
-
>
commentfield_len
)
;
uint32_t
diff
=
ZIPCENTRAL_SIZE
+
namelen
+
extralen
+
commentlen
;
if
(
namelen
<
1
|
|
namelen
>
kMaxNameLength
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
if
(
buf
>
=
buf
+
diff
|
|
buf
>
=
endp
-
diff
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
buf
+
=
diff
;
nsZipItem
*
item
=
CreateZipItem
(
)
;
if
(
!
item
)
return
NS_ERROR_OUT_OF_MEMORY
;
item
-
>
central
=
central
;
item
-
>
nameLength
=
namelen
;
item
-
>
isSynthetic
=
false
;
#
ifdef
DEBUG
nsDependentCSubstring
name
(
item
-
>
Name
(
)
namelen
)
;
LOG
(
(
"
%
s
"
PromiseFlatCString
(
name
)
.
get
(
)
)
)
;
#
endif
uint32_t
hash
=
HashName
(
item
-
>
Name
(
)
namelen
)
;
item
-
>
next
=
mFiles
[
hash
]
;
mFiles
[
hash
]
=
item
;
sig
=
0
;
}
if
(
sig
!
=
ENDSIG
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
MMAP_FAULT_HANDLER_CATCH
(
NS_ERROR_FAILURE
)
return
NS_OK
;
}
nsresult
nsZipArchive
:
:
BuildSynthetics
(
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
mBuiltSynthetics
)
return
NS_OK
;
mBuiltSynthetics
=
true
;
MMAP_FAULT_HANDLER_BEGIN_HANDLE
(
mFd
)
for
(
auto
*
item
:
mFiles
)
{
for
(
;
item
!
=
nullptr
;
item
=
item
-
>
next
)
{
if
(
item
-
>
isSynthetic
)
continue
;
uint16_t
namelen
=
item
-
>
nameLength
;
MOZ_ASSERT
(
namelen
>
0
"
Attempt
to
build
synthetic
for
zero
-
length
entry
name
!
"
)
;
const
char
*
name
=
item
-
>
Name
(
)
;
for
(
uint16_t
dirlen
=
namelen
-
1
;
dirlen
>
0
;
dirlen
-
-
)
{
if
(
name
[
dirlen
-
1
]
!
=
'
/
'
)
continue
;
if
(
name
[
dirlen
]
=
=
'
/
'
)
continue
;
uint32_t
hash
=
HashName
(
item
-
>
Name
(
)
dirlen
)
;
bool
found
=
false
;
for
(
nsZipItem
*
zi
=
mFiles
[
hash
]
;
zi
!
=
nullptr
;
zi
=
zi
-
>
next
)
{
if
(
(
dirlen
=
=
zi
-
>
nameLength
)
&
&
(
0
=
=
memcmp
(
item
-
>
Name
(
)
zi
-
>
Name
(
)
dirlen
)
)
)
{
found
=
true
;
break
;
}
}
if
(
found
)
break
;
nsZipItem
*
diritem
=
CreateZipItem
(
)
;
if
(
!
diritem
)
return
NS_ERROR_OUT_OF_MEMORY
;
diritem
-
>
central
=
item
-
>
central
;
diritem
-
>
nameLength
=
dirlen
;
diritem
-
>
isSynthetic
=
true
;
diritem
-
>
next
=
mFiles
[
hash
]
;
mFiles
[
hash
]
=
diritem
;
}
}
}
MMAP_FAULT_HANDLER_CATCH
(
NS_ERROR_FAILURE
)
return
NS_OK
;
}
nsZipHandle
*
nsZipArchive
:
:
GetFD
(
)
const
{
return
mFd
.
get
(
)
;
}
uint32_t
nsZipArchive
:
:
GetDataOffset
(
nsZipItem
*
aItem
)
{
MOZ_ASSERT
(
aItem
)
;
uint32_t
offset
;
MMAP_FAULT_HANDLER_BEGIN_HANDLE
(
mFd
)
uint32_t
len
=
mFd
-
>
mLen
;
const
uint8_t
*
data
=
mFd
-
>
mFileData
;
offset
=
aItem
-
>
LocalOffset
(
)
;
if
(
len
<
ZIPLOCAL_SIZE
|
|
offset
>
len
-
ZIPLOCAL_SIZE
)
return
0
;
ZipLocal
*
Local
=
(
ZipLocal
*
)
(
data
+
offset
)
;
if
(
(
xtolong
(
Local
-
>
signature
)
!
=
LOCALSIG
)
)
return
0
;
offset
+
=
ZIPLOCAL_SIZE
+
xtoint
(
Local
-
>
filename_len
)
+
xtoint
(
Local
-
>
extrafield_len
)
;
MMAP_FAULT_HANDLER_CATCH
(
0
)
return
offset
;
}
const
uint8_t
*
nsZipArchive
:
:
GetData
(
nsZipItem
*
aItem
)
{
MOZ_ASSERT
(
aItem
)
;
uint32_t
offset
=
GetDataOffset
(
aItem
)
;
MMAP_FAULT_HANDLER_BEGIN_HANDLE
(
mFd
)
if
(
!
offset
|
|
mFd
-
>
mLen
<
aItem
-
>
Size
(
)
|
|
offset
>
mFd
-
>
mLen
-
aItem
-
>
Size
(
)
|
|
(
aItem
-
>
Compression
(
)
=
=
STORED
&
&
aItem
-
>
Size
(
)
!
=
aItem
-
>
RealSize
(
)
)
)
{
return
nullptr
;
}
MMAP_FAULT_HANDLER_CATCH
(
nullptr
)
return
mFd
-
>
mFileData
+
offset
;
}
int64_t
nsZipArchive
:
:
SizeOfMapping
(
)
{
return
mFd
?
mFd
-
>
SizeOfMapping
(
)
:
0
;
}
nsZipArchive
:
:
nsZipArchive
(
nsZipHandle
*
aZipHandle
PRFileDesc
*
aFd
nsresult
&
aRv
)
:
mRefCnt
(
0
)
mFd
(
aZipHandle
)
mUseZipLog
(
false
)
mBuiltSynthetics
(
false
)
{
memset
(
mFiles
0
sizeof
(
mFiles
)
)
;
aRv
=
BuildFileList
(
aFd
)
;
if
(
NS_FAILED
(
aRv
)
)
{
return
;
}
if
(
aZipHandle
-
>
mFile
&
&
XRE_IsParentProcess
(
)
)
{
static
char
*
env
=
PR_GetEnv
(
"
MOZ_JAR_LOG_FILE
"
)
;
if
(
env
)
{
mUseZipLog
=
true
;
zipLog
.
Init
(
env
)
;
if
(
aZipHandle
-
>
mFile
.
IsZip
(
)
)
{
aZipHandle
-
>
mFile
.
GetPath
(
mURI
)
;
}
else
if
(
nsDirectoryService
:
:
gService
)
{
nsCOMPtr
<
nsIFile
>
dir
=
aZipHandle
-
>
mFile
.
GetBaseFile
(
)
;
nsCOMPtr
<
nsIFile
>
gre_dir
;
nsAutoCString
path
;
if
(
NS_SUCCEEDED
(
nsDirectoryService
:
:
gService
-
>
Get
(
NS_GRE_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
gre_dir
)
)
)
)
{
nsAutoCString
leaf
;
nsCOMPtr
<
nsIFile
>
parent
;
while
(
NS_SUCCEEDED
(
dir
-
>
GetNativeLeafName
(
leaf
)
)
&
&
NS_SUCCEEDED
(
dir
-
>
GetParent
(
getter_AddRefs
(
parent
)
)
)
)
{
if
(
!
parent
)
{
break
;
}
dir
=
parent
;
if
(
path
.
Length
(
)
)
{
path
.
Insert
(
'
/
'
0
)
;
}
path
.
Insert
(
leaf
0
)
;
bool
equals
;
if
(
NS_SUCCEEDED
(
dir
-
>
Equals
(
gre_dir
&
equals
)
)
&
&
equals
)
{
mURI
.
Assign
(
path
)
;
break
;
}
}
}
}
}
}
}
NS_IMPL_ADDREF
(
nsZipArchive
)
NS_IMPL_RELEASE
(
nsZipArchive
)
nsZipArchive
:
:
~
nsZipArchive
(
)
{
LOG
(
(
"
Closing
nsZipArchive
[
%
p
]
"
this
)
)
;
if
(
mUseZipLog
)
{
zipLog
.
Release
(
)
;
}
}
nsZipFind
:
:
nsZipFind
(
nsZipArchive
*
aZip
char
*
aPattern
bool
aRegExp
)
:
mArchive
(
aZip
)
mPattern
(
aPattern
)
mItem
(
nullptr
)
mSlot
(
0
)
mRegExp
(
aRegExp
)
{
MOZ_COUNT_CTOR
(
nsZipFind
)
;
}
nsZipFind
:
:
~
nsZipFind
(
)
{
free
(
mPattern
)
;
MOZ_COUNT_DTOR
(
nsZipFind
)
;
}
MOZ_NO_SANITIZE_UNSIGNED_OVERFLOW
static
uint32_t
HashName
(
const
char
*
aName
uint16_t
len
)
{
MOZ_ASSERT
(
aName
!
=
0
)
;
const
uint8_t
*
p
=
(
const
uint8_t
*
)
aName
;
const
uint8_t
*
endp
=
p
+
len
;
uint32_t
val
=
0
;
while
(
p
!
=
endp
)
{
val
=
val
*
37
+
*
p
+
+
;
}
return
(
val
%
ZIP_TABSIZE
)
;
}
static
uint16_t
xtoint
(
const
uint8_t
*
ii
)
{
return
(
uint16_t
)
(
(
ii
[
0
]
)
|
(
ii
[
1
]
<
<
8
)
)
;
}
static
uint32_t
xtolong
(
const
uint8_t
*
ll
)
{
return
(
uint32_t
)
(
(
ll
[
0
]
<
<
0
)
|
(
ll
[
1
]
<
<
8
)
|
(
ll
[
2
]
<
<
16
)
|
(
ll
[
3
]
<
<
24
)
)
;
}
static
PRTime
GetModTime
(
uint16_t
aDate
uint16_t
aTime
)
{
PRExplodedTime
time
;
time
.
tm_usec
=
0
;
time
.
tm_hour
=
(
aTime
>
>
11
)
&
0x1F
;
time
.
tm_min
=
(
aTime
>
>
5
)
&
0x3F
;
time
.
tm_sec
=
(
aTime
&
0x1F
)
*
2
;
time
.
tm_year
=
(
aDate
>
>
9
)
+
1980
;
time
.
tm_month
=
(
(
aDate
>
>
5
)
&
0x0F
)
-
1
;
time
.
tm_mday
=
aDate
&
0x1F
;
time
.
tm_params
.
tp_gmt_offset
=
0
;
time
.
tm_params
.
tp_dst_offset
=
0
;
PR_NormalizeTime
(
&
time
PR_GMTParameters
)
;
time
.
tm_params
.
tp_gmt_offset
=
PR_LocalTimeParameters
(
&
time
)
.
tp_gmt_offset
;
PR_NormalizeTime
(
&
time
PR_GMTParameters
)
;
time
.
tm_params
.
tp_dst_offset
=
PR_LocalTimeParameters
(
&
time
)
.
tp_dst_offset
;
return
PR_ImplodeTime
(
&
time
)
;
}
nsZipItem
:
:
nsZipItem
(
)
:
next
(
nullptr
)
central
(
nullptr
)
nameLength
(
0
)
isSynthetic
(
false
)
{
}
uint32_t
nsZipItem
:
:
LocalOffset
(
)
{
return
xtolong
(
central
-
>
localhdr_offset
)
;
}
uint32_t
nsZipItem
:
:
Size
(
)
{
return
isSynthetic
?
0
:
xtolong
(
central
-
>
size
)
;
}
uint32_t
nsZipItem
:
:
RealSize
(
)
{
return
isSynthetic
?
0
:
xtolong
(
central
-
>
orglen
)
;
}
uint32_t
nsZipItem
:
:
CRC32
(
)
{
return
isSynthetic
?
0
:
xtolong
(
central
-
>
crc32
)
;
}
uint16_t
nsZipItem
:
:
Date
(
)
{
return
isSynthetic
?
kSyntheticDate
:
xtoint
(
central
-
>
date
)
;
}
uint16_t
nsZipItem
:
:
Time
(
)
{
return
isSynthetic
?
kSyntheticTime
:
xtoint
(
central
-
>
time
)
;
}
uint16_t
nsZipItem
:
:
Compression
(
)
{
return
isSynthetic
?
STORED
:
xtoint
(
central
-
>
method
)
;
}
bool
nsZipItem
:
:
IsDirectory
(
)
{
return
isSynthetic
|
|
(
(
nameLength
>
0
)
&
&
(
'
/
'
=
=
Name
(
)
[
nameLength
-
1
]
)
)
;
}
uint16_t
nsZipItem
:
:
Mode
(
)
{
if
(
isSynthetic
)
return
0755
;
return
(
(
uint16_t
)
(
central
-
>
external_attributes
[
2
]
)
|
0x100
)
;
}
const
uint8_t
*
nsZipItem
:
:
GetExtraField
(
uint16_t
aTag
uint16_t
*
aBlockSize
)
{
if
(
isSynthetic
)
return
nullptr
;
const
unsigned
char
*
buf
=
(
(
const
unsigned
char
*
)
central
)
+
ZIPCENTRAL_SIZE
+
nameLength
;
uint32_t
buflen
;
MMAP_FAULT_HANDLER_BEGIN_BUFFER
(
central
ZIPCENTRAL_SIZE
+
nameLength
)
buflen
=
(
uint32_t
)
xtoint
(
central
-
>
extrafield_len
)
;
MMAP_FAULT_HANDLER_CATCH
(
nullptr
)
uint32_t
pos
=
0
;
uint16_t
tag
blocksize
;
MMAP_FAULT_HANDLER_BEGIN_BUFFER
(
buf
buflen
)
while
(
buf
&
&
(
pos
+
4
)
<
=
buflen
)
{
tag
=
xtoint
(
buf
+
pos
)
;
blocksize
=
xtoint
(
buf
+
pos
+
2
)
;
if
(
aTag
=
=
tag
&
&
(
pos
+
4
+
blocksize
)
<
=
buflen
)
{
*
aBlockSize
=
blocksize
;
return
buf
+
pos
;
}
pos
+
=
blocksize
+
4
;
}
MMAP_FAULT_HANDLER_CATCH
(
nullptr
)
return
nullptr
;
}
PRTime
nsZipItem
:
:
LastModTime
(
)
{
if
(
isSynthetic
)
return
GetModTime
(
kSyntheticDate
kSyntheticTime
)
;
uint16_t
blocksize
;
const
uint8_t
*
tsField
=
GetExtraField
(
EXTENDED_TIMESTAMP_FIELD
&
blocksize
)
;
if
(
tsField
&
&
blocksize
>
=
5
&
&
tsField
[
4
]
&
EXTENDED_TIMESTAMP_MODTIME
)
{
return
(
PRTime
)
(
xtolong
(
tsField
+
5
)
)
*
PR_USEC_PER_SEC
;
}
return
GetModTime
(
Date
(
)
Time
(
)
)
;
}
nsZipCursor
:
:
nsZipCursor
(
nsZipItem
*
item
nsZipArchive
*
aZip
uint8_t
*
aBuf
uint32_t
aBufSize
bool
doCRC
)
:
mItem
(
item
)
mBuf
(
aBuf
)
mBufSize
(
aBufSize
)
mZs
(
)
mCRC
(
0
)
mDoCRC
(
doCRC
)
{
if
(
mItem
-
>
Compression
(
)
=
=
DEFLATED
)
{
#
ifdef
DEBUG
nsresult
status
=
#
endif
gZlibInit
(
&
mZs
)
;
NS_ASSERTION
(
status
=
=
NS_OK
"
Zlib
failed
to
initialize
"
)
;
NS_ASSERTION
(
aBuf
"
Must
pass
in
a
buffer
for
DEFLATED
nsZipItem
"
)
;
}
mZs
.
avail_in
=
item
-
>
Size
(
)
;
mZs
.
next_in
=
(
Bytef
*
)
aZip
-
>
GetData
(
item
)
;
if
(
doCRC
)
mCRC
=
crc32
(
0L
Z_NULL
0
)
;
}
nsZipCursor
:
:
~
nsZipCursor
(
)
{
if
(
mItem
-
>
Compression
(
)
=
=
DEFLATED
)
{
inflateEnd
(
&
mZs
)
;
}
}
uint8_t
*
nsZipCursor
:
:
ReadOrCopy
(
uint32_t
*
aBytesRead
bool
aCopy
)
{
int
zerr
;
uint8_t
*
buf
=
nullptr
;
bool
verifyCRC
=
true
;
if
(
!
mZs
.
next_in
)
return
nullptr
;
MMAP_FAULT_HANDLER_BEGIN_BUFFER
(
mZs
.
next_in
mZs
.
avail_in
)
switch
(
mItem
-
>
Compression
(
)
)
{
case
STORED
:
if
(
!
aCopy
)
{
*
aBytesRead
=
mZs
.
avail_in
;
buf
=
mZs
.
next_in
;
mZs
.
next_in
+
=
mZs
.
avail_in
;
mZs
.
avail_in
=
0
;
}
else
{
*
aBytesRead
=
mZs
.
avail_in
>
mBufSize
?
mBufSize
:
mZs
.
avail_in
;
memcpy
(
mBuf
mZs
.
next_in
*
aBytesRead
)
;
mZs
.
avail_in
-
=
*
aBytesRead
;
mZs
.
next_in
+
=
*
aBytesRead
;
}
break
;
case
DEFLATED
:
buf
=
mBuf
;
mZs
.
next_out
=
buf
;
mZs
.
avail_out
=
mBufSize
;
zerr
=
inflate
(
&
mZs
Z_PARTIAL_FLUSH
)
;
if
(
zerr
!
=
Z_OK
&
&
zerr
!
=
Z_STREAM_END
)
return
nullptr
;
*
aBytesRead
=
mZs
.
next_out
-
buf
;
verifyCRC
=
(
zerr
=
=
Z_STREAM_END
)
;
break
;
default
:
return
nullptr
;
}
if
(
mDoCRC
)
{
mCRC
=
crc32
(
mCRC
(
const
unsigned
char
*
)
buf
*
aBytesRead
)
;
if
(
verifyCRC
&
&
mCRC
!
=
mItem
-
>
CRC32
(
)
)
return
nullptr
;
}
MMAP_FAULT_HANDLER_CATCH
(
nullptr
)
return
buf
;
}
nsZipItemPtr_base
:
:
nsZipItemPtr_base
(
nsZipArchive
*
aZip
const
char
*
aEntryName
bool
doCRC
)
:
mReturnBuf
(
nullptr
)
mReadlen
(
0
)
{
mZipHandle
=
aZip
-
>
GetFD
(
)
;
nsZipItem
*
item
=
aZip
-
>
GetItem
(
aEntryName
)
;
if
(
!
item
)
return
;
uint32_t
size
=
0
;
bool
compressed
=
(
item
-
>
Compression
(
)
=
=
DEFLATED
)
;
if
(
compressed
)
{
size
=
item
-
>
RealSize
(
)
;
mAutoBuf
=
MakeUniqueFallible
<
uint8_t
[
]
>
(
size
)
;
if
(
!
mAutoBuf
)
{
return
;
}
}
nsZipCursor
cursor
(
item
aZip
mAutoBuf
.
get
(
)
size
doCRC
)
;
mReturnBuf
=
cursor
.
Read
(
&
mReadlen
)
;
if
(
!
mReturnBuf
)
{
return
;
}
if
(
mReadlen
!
=
item
-
>
RealSize
(
)
)
{
NS_ASSERTION
(
mReadlen
=
=
item
-
>
RealSize
(
)
"
nsZipCursor
underflow
"
)
;
mReturnBuf
=
nullptr
;
return
;
}
}
