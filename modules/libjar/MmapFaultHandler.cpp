#
include
"
MmapFaultHandler
.
h
"
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_DARWIN
)
#
include
"
nsZipArchive
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
<
signal
.
h
>
static
MOZ_THREAD_LOCAL
(
MmapAccessScope
*
)
sMmapAccessScope
;
static
struct
sigaction
sPrevSIGBUSHandler
;
static
void
MmapSIGBUSHandler
(
int
signum
siginfo_t
*
info
void
*
context
)
{
MOZ_RELEASE_ASSERT
(
signum
=
=
SIGBUS
)
;
MmapAccessScope
*
mas
=
sMmapAccessScope
.
get
(
)
;
if
(
mas
&
&
mas
-
>
IsInsideBuffer
(
info
-
>
si_addr
)
)
{
mas
-
>
CrashWithInfo
(
info
-
>
si_addr
)
;
siglongjmp
(
mas
-
>
mJmpBuf
signum
)
;
return
;
}
if
(
sPrevSIGBUSHandler
.
sa_flags
&
SA_SIGINFO
)
{
sPrevSIGBUSHandler
.
sa_sigaction
(
signum
info
context
)
;
}
else
if
(
sPrevSIGBUSHandler
.
sa_handler
=
=
SIG_DFL
|
|
sPrevSIGBUSHandler
.
sa_handler
=
=
SIG_IGN
)
{
sigaction
(
signum
&
sPrevSIGBUSHandler
nullptr
)
;
}
else
{
sPrevSIGBUSHandler
.
sa_handler
(
signum
)
;
}
}
mozilla
:
:
Atomic
<
bool
>
gSIGBUSHandlerInstalled
(
false
)
;
mozilla
:
:
StaticMutex
gSIGBUSHandlerMutex
;
void
InstallMmapFaultHandler
(
)
{
if
(
gSIGBUSHandlerInstalled
)
{
return
;
}
mozilla
:
:
StaticMutexAutoLock
lock
(
gSIGBUSHandlerMutex
)
;
if
(
gSIGBUSHandlerInstalled
)
{
return
;
}
sMmapAccessScope
.
infallibleInit
(
)
;
struct
sigaction
busHandler
;
busHandler
.
sa_flags
=
SA_SIGINFO
|
SA_NODEFER
|
SA_ONSTACK
;
busHandler
.
sa_sigaction
=
MmapSIGBUSHandler
;
sigemptyset
(
&
busHandler
.
sa_mask
)
;
if
(
sigaction
(
SIGBUS
&
busHandler
&
sPrevSIGBUSHandler
)
)
{
MOZ_CRASH
(
"
Unable
to
install
SIGBUS
handler
"
)
;
}
gSIGBUSHandlerInstalled
=
true
;
}
MmapAccessScope
:
:
MmapAccessScope
(
void
*
aBuf
uint32_t
aBufLen
)
{
InstallMmapFaultHandler
(
)
;
mBuf
=
aBuf
;
mBufLen
=
aBufLen
;
SetThreadLocalScope
(
)
;
}
MmapAccessScope
:
:
MmapAccessScope
(
nsZipHandle
*
aZipHandle
)
:
mBuf
(
nullptr
)
mBufLen
(
0
)
{
InstallMmapFaultHandler
(
)
;
if
(
aZipHandle
&
&
aZipHandle
-
>
mMap
)
{
mZipHandle
=
aZipHandle
;
}
SetThreadLocalScope
(
)
;
}
MmapAccessScope
:
:
~
MmapAccessScope
(
)
{
MOZ_RELEASE_ASSERT
(
sMmapAccessScope
.
get
(
)
=
=
this
)
;
sMmapAccessScope
.
set
(
mPreviousScope
)
;
}
void
MmapAccessScope
:
:
SetThreadLocalScope
(
)
{
memset
(
mJmpBuf
0
sizeof
(
sigjmp_buf
)
)
;
mPreviousScope
=
sMmapAccessScope
.
get
(
)
;
sMmapAccessScope
.
set
(
this
)
;
}
bool
MmapAccessScope
:
:
IsInsideBuffer
(
void
*
aPtr
)
{
bool
isIn
;
if
(
mZipHandle
)
{
isIn
=
aPtr
>
=
mZipHandle
-
>
mFileStart
&
&
aPtr
<
(
void
*
)
(
(
char
*
)
mZipHandle
-
>
mFileStart
+
mZipHandle
-
>
mTotalLen
)
;
}
else
{
isIn
=
aPtr
>
=
mBuf
&
&
aPtr
<
(
void
*
)
(
(
char
*
)
mBuf
+
mBufLen
)
;
}
return
isIn
;
}
void
MmapAccessScope
:
:
CrashWithInfo
(
void
*
aPtr
)
{
if
(
!
mZipHandle
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
SIGBUS
received
when
accessing
mmaped
zip
file
[
buffer
=
%
p
"
"
buflen
=
%
"
PRIu32
"
address
=
%
p
]
"
mBuf
mBufLen
aPtr
)
;
}
nsCOMPtr
<
nsIFile
>
file
=
mZipHandle
-
>
mFile
.
GetBaseFile
(
)
;
nsCString
fileName
;
file
-
>
GetNativeLeafName
(
fileName
)
;
int
fileSize
=
-
1
;
if
(
PR_Seek64
(
mZipHandle
-
>
mNSPRFileDesc
0
PR_SEEK_SET
)
!
=
-
1
)
{
fileSize
=
PR_Available64
(
mZipHandle
-
>
mNSPRFileDesc
)
;
}
fileName
.
Append
(
"
filesize
=
"
)
;
fileName
.
AppendInt
(
fileSize
)
;
MOZ_CRASH_UNSAFE_PRINTF
(
"
SIGBUS
received
when
accessing
mmaped
zip
file
[
file
=
%
s
buffer
=
%
p
"
"
buflen
=
%
"
PRIu32
"
address
=
%
p
]
"
fileName
.
get
(
)
(
char
*
)
mZipHandle
-
>
mFileStart
mZipHandle
-
>
mTotalLen
aPtr
)
;
}
#
endif
