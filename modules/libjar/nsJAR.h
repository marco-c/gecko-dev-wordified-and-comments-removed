#
ifndef
nsJAR_h_
#
define
nsJAR_h_
#
include
"
nscore
.
h
"
#
include
"
prio
.
h
"
#
include
"
plstr
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsStringEnumerator
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsIZipReader
.
h
"
#
include
"
nsZipArchive
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
class
nsZipReaderCache
;
class
nsJAR
final
:
public
nsIZipReader
{
friend
class
nsJARInputStream
;
friend
class
nsZipReaderCache
;
private
:
virtual
~
nsJAR
(
)
;
public
:
nsJAR
(
)
;
NS_DEFINE_STATIC_CID_ACCESSOR
(
NS_ZIPREADER_CID
)
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIZIPREADER
nsresult
GetJarPath
(
nsACString
&
aResult
)
;
PRIntervalTime
GetReleaseTime
(
)
{
return
mReleaseTime
;
}
bool
IsReleased
(
)
{
return
mReleaseTime
!
=
PR_INTERVAL_NO_TIMEOUT
;
}
void
SetReleaseTime
(
)
{
mReleaseTime
=
PR_IntervalNow
(
)
;
}
void
ClearReleaseTime
(
)
{
mReleaseTime
=
PR_INTERVAL_NO_TIMEOUT
;
}
void
SetZipReaderCache
(
nsZipReaderCache
*
aCache
)
{
mozilla
:
:
MutexAutoLock
lock
(
mLock
)
;
mCache
=
aCache
;
}
nsresult
GetNSPRFileDesc
(
PRFileDesc
*
*
aNSPRFileDesc
)
;
protected
:
nsCOMPtr
<
nsIFile
>
mZipFile
;
nsCString
mOuterZipEntry
;
RefPtr
<
nsZipArchive
>
mZip
;
PRIntervalTime
mReleaseTime
;
nsZipReaderCache
*
mCache
;
mozilla
:
:
Mutex
mLock
;
int64_t
mMtime
;
bool
mOpened
;
bool
mSkipArchiveClosing
;
nsresult
LoadEntry
(
const
nsACString
&
aFilename
nsCString
&
aBuf
)
;
int32_t
ReadLine
(
const
char
*
*
src
)
;
}
;
class
nsJARItem
:
public
nsIZipEntry
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIZIPENTRY
explicit
nsJARItem
(
nsZipItem
*
aZipItem
)
;
private
:
virtual
~
nsJARItem
(
)
{
}
uint32_t
mSize
;
uint32_t
mRealsize
;
uint32_t
mCrc32
;
PRTime
mLastModTime
;
uint16_t
mCompression
;
uint32_t
mPermissions
;
bool
mIsDirectory
;
bool
mIsSynthetic
;
}
;
class
nsJAREnumerator
final
:
public
nsStringEnumeratorBase
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIUTF8STRINGENUMERATOR
using
nsStringEnumeratorBase
:
:
GetNext
;
explicit
nsJAREnumerator
(
nsZipFind
*
aFind
)
:
mFind
(
aFind
)
mName
(
nullptr
)
mNameLen
(
0
)
{
NS_ASSERTION
(
mFind
"
nsJAREnumerator
:
Missing
zipFind
.
"
)
;
}
private
:
nsZipFind
*
mFind
;
const
char
*
mName
;
uint16_t
mNameLen
;
~
nsJAREnumerator
(
)
{
delete
mFind
;
}
}
;
#
if
defined
(
DEBUG_warren
)
|
|
defined
(
DEBUG_jband
)
#
define
ZIP_CACHE_HIT_RATE
#
endif
class
nsZipReaderCache
:
public
nsIZipReaderCache
public
nsIObserver
public
nsSupportsWeakReference
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIZIPREADERCACHE
NS_DECL_NSIOBSERVER
nsZipReaderCache
(
)
;
nsresult
ReleaseZip
(
nsJAR
*
reader
)
;
typedef
nsRefPtrHashtable
<
nsCStringHashKey
nsJAR
>
ZipsHashtable
;
protected
:
virtual
~
nsZipReaderCache
(
)
;
mozilla
:
:
Mutex
mLock
;
uint32_t
mCacheSize
;
ZipsHashtable
mZips
;
#
ifdef
ZIP_CACHE_HIT_RATE
uint32_t
mZipCacheLookups
;
uint32_t
mZipCacheHits
;
uint32_t
mZipCacheFlushes
;
uint32_t
mZipSyncMisses
;
#
endif
private
:
nsresult
GetZip
(
nsIFile
*
zipFile
nsIZipReader
*
*
result
bool
failOnMiss
)
;
}
;
#
endif
