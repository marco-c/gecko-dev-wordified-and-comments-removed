from
__future__
import
print_function
import
buildconfig
import
os
import
sys
import
yaml
from
collections
import
defaultdict
from
io
import
BytesIO
from
mozbuild
.
preprocessor
import
Preprocessor
from
mozbuild
.
util
import
ensureParentDir
FileAvoidWrite
VALID_KEYS
=
{
    
'
name
'
    
'
type
'
    
'
value
'
    
'
mirror
'
    
'
do_not_use_directly
'
    
'
include
'
}
VALID_BOOL_TYPES
=
{
    
'
bool
'
    
'
RelaxedAtomicBool
'
    
'
ReleaseAcquireAtomicBool
'
    
'
SequentiallyConsistentAtomicBool
'
}
VALID_TYPES
=
VALID_BOOL_TYPES
.
union
(
{
    
'
int32_t
'
    
'
uint32_t
'
    
'
float
'
    
'
String
'
    
'
RelaxedAtomicInt32
'
    
'
RelaxedAtomicUint32
'
    
'
ReleaseAcquireAtomicInt32
'
    
'
ReleaseAcquireAtomicUint32
'
    
'
SequentiallyConsistentAtomicInt32
'
    
'
SequentiallyConsistentAtomicUint32
'
    
'
AtomicFloat
'
}
)
FIRST_LINE
=
'
'
'
\
/
/
This
file
was
generated
by
generate_static_pref_list
.
py
.
DO
NOT
EDIT
.
'
'
'
MIRROR_TEMPLATES
=
{
    
'
never
'
:
'
'
'
\
NEVER_PREF
(
"
{
name
}
"
{
typ
}
{
value
}
)
'
'
'
    
'
once
'
:
'
'
'
\
ONCE_PREF
(
  
"
{
name
}
"
   
{
base_id
}
   
{
full_id
}
  
{
typ
}
{
value
}
)
'
'
'
    
'
always
'
:
'
'
'
\
ALWAYS_PREF
(
  
"
{
name
}
"
   
{
base_id
}
   
{
full_id
}
  
{
typ
}
{
value
}
)
'
'
'
}
PREFS_FILE_TEMPLATE1
=
'
'
'
\
/
/
Include
it
to
gain
access
to
StaticPrefs
:
:
{
group
}
_
*
.
#
ifndef
mozilla_StaticPrefs_
{
group
}
_h
#
define
mozilla_StaticPrefs_
{
group
}
_h
'
'
'
PREFS_FILE_TEMPLATE2
=
'
'
'
\
#
include
"
mozilla
/
StaticPrefListBegin
.
h
"
#
include
"
mozilla
/
StaticPrefList_
{
group
}
.
h
"
#
include
"
mozilla
/
StaticPrefListEnd
.
h
"
#
endif
/
/
mozilla_StaticPrefs_
{
group
}
_h
'
'
'
def
error
(
msg
)
:
    
raise
ValueError
(
msg
)
def
mk_id
(
name
)
:
    
"
Replace
'
.
'
and
'
-
'
with
'
_
'
e
.
g
.
'
foo
.
bar
-
baz
'
becomes
'
foo_bar_baz
'
.
"
    
return
name
.
replace
(
'
.
'
'
_
'
)
.
replace
(
'
-
'
'
_
'
)
def
pref_ids
(
pref
)
:
    
if
pref
[
'
mirror
'
]
=
=
'
never
'
:
        
if
pref
.
get
(
'
do_not_use_directly
'
)
:
            
error
(
'
do_not_use_directly
uselessly
set
with
mirror
value
'
                  
'
never
for
pref
{
}
'
.
format
(
pref
[
'
name
'
]
)
)
        
return
(
None
None
)
    
base_id
=
mk_id
(
pref
[
'
name
'
]
)
    
full_id
=
base_id
    
if
pref
[
'
mirror
'
]
=
=
'
once
'
:
        
full_id
+
=
'
_AtStartup
'
    
if
pref
.
get
(
'
do_not_use_directly
'
)
:
        
full_id
+
=
'
_DoNotUseDirectly
'
    
return
(
base_id
full_id
)
def
generate_headers
(
pref_list
)
:
    
code
=
defaultdict
(
list
)
    
includes
=
defaultdict
(
set
)
    
seen_names
=
set
(
)
    
prev_pref
=
None
    
for
pref
in
pref_list
:
        
for
key
in
pref
:
            
if
key
not
in
VALID_KEYS
:
                
error
(
'
invalid
key
{
}
'
.
format
(
key
)
)
        
if
'
name
'
not
in
pref
:
            
error
(
'
missing
name
key
'
)
        
name
=
pref
[
'
name
'
]
        
if
type
(
name
)
!
=
str
:
            
error
(
'
non
-
string
name
value
{
}
'
.
format
(
name
)
)
        
if
name
in
seen_names
:
            
error
(
'
{
}
pref
is
defined
more
than
once
'
.
format
(
name
)
)
        
seen_names
.
add
(
name
)
        
segs
=
name
.
split
(
'
.
'
1
)
        
if
len
(
segs
)
!
=
2
:
            
error
(
'
name
value
{
}
lacks
a
\
'
.
\
'
'
.
format
(
name
)
)
        
group
=
mk_id
(
segs
[
0
]
)
        
if
prev_pref
:
            
prev_pref_group
=
prev_pref
[
'
name
'
]
.
split
(
'
.
'
1
)
[
0
]
            
if
prev_pref_group
>
group
:
                
error
(
'
{
}
pref
must
come
before
{
}
pref
'
                      
.
format
(
name
prev_pref
[
'
name
'
]
)
)
        
if
'
type
'
not
in
pref
:
            
error
(
'
missing
type
key
for
pref
{
}
'
.
format
(
name
)
)
        
typ
=
pref
[
'
type
'
]
        
if
typ
not
in
VALID_TYPES
:
            
error
(
'
invalid
type
value
{
}
for
pref
{
}
'
.
format
(
typ
name
)
)
        
if
'
value
'
not
in
pref
:
            
error
(
'
missing
value
key
for
pref
{
}
'
.
format
(
name
)
)
        
value
=
pref
[
'
value
'
]
        
if
typ
=
=
'
String
'
:
            
if
type
(
value
)
!
=
str
:
                
error
(
'
non
-
string
value
value
{
}
for
String
pref
{
}
;
'
                      
'
add
double
quotes
'
                      
.
format
(
value
name
)
)
            
value
=
'
"
{
}
"
'
.
format
(
value
.
replace
(
'
"
'
'
\
\
"
'
)
)
        
elif
typ
in
VALID_BOOL_TYPES
:
            
if
value
is
True
:
                
value
=
'
true
'
            
elif
value
is
False
:
                
value
=
'
false
'
            
else
:
                
error
(
'
invalid
boolean
value
{
}
for
pref
{
}
'
                      
.
format
(
value
name
)
)
        
if
'
mirror
'
not
in
pref
:
            
error
(
'
missing
mirror
key
for
pref
{
}
'
.
format
(
name
)
)
        
mirror
=
pref
[
'
mirror
'
]
        
if
mirror
not
in
MIRROR_TEMPLATES
:
            
error
(
'
invalid
mirror
value
{
}
for
pref
{
}
'
                  
.
format
(
mirror
name
)
)
        
if
'
do_not_use_directly
'
in
pref
:
            
do_not_use_directly
=
pref
[
'
do_not_use_directly
'
]
            
if
type
(
do_not_use_directly
)
!
=
bool
:
                
error
(
'
non
-
boolean
do_not_use_directly
value
{
}
for
pref
'
                      
'
{
}
'
.
format
(
do_not_use_directly
name
)
)
        
if
'
include
'
in
pref
:
            
include
=
pref
[
'
include
'
]
            
if
type
(
include
)
!
=
str
:
                
error
(
'
non
-
string
include
value
{
}
for
pref
{
}
'
                      
.
format
(
include
name
)
)
            
if
include
.
startswith
(
'
<
'
)
:
                
if
not
include
.
endswith
(
'
>
'
)
:
                    
error
(
'
include
value
{
}
starts
with
<
but
does
not
'
                          
'
end
with
>
for
pref
{
}
'
.
format
(
include
name
)
)
            
else
:
                
include
=
'
"
{
}
"
'
.
format
(
include
)
            
includes
[
group
]
.
add
(
include
)
        
ids
=
pref_ids
(
pref
)
        
code
[
group
]
.
append
(
MIRROR_TEMPLATES
[
mirror
]
.
format
(
            
name
=
name
            
base_id
=
ids
[
0
]
            
full_id
=
ids
[
1
]
            
typ
=
typ
            
value
=
value
        
)
)
        
prev_pref
=
pref
    
return
(
code
includes
)
def
emit_header
(
fd
pref_list_filename
)
:
    
pp
=
Preprocessor
(
)
    
pp
.
context
.
update
(
buildconfig
.
defines
[
'
ALLDEFINES
'
]
)
    
if
buildconfig
.
substs
.
get
(
'
MOZ_DEBUG
'
)
:
        
pp
.
context
[
'
DEBUG
'
]
=
'
1
'
    
pp
.
out
=
BytesIO
(
)
    
pp
.
do_filter
(
'
substitution
'
)
    
pp
.
do_include
(
pref_list_filename
)
    
try
:
        
pref_list
=
yaml
.
safe_load
(
pp
.
out
.
getvalue
(
)
)
        
(
code
includes
)
=
generate_headers
(
pref_list
)
    
except
(
IOError
ValueError
)
as
e
:
        
print
(
'
{
}
:
error
:
\
n
{
}
\
n
'
              
.
format
(
pref_list_filename
e
)
)
        
sys
.
exit
(
1
)
    
fd
.
write
(
FIRST_LINE
)
    
fd
.
write
(
'
\
n
'
)
    
for
group
in
sorted
(
code
)
:
        
fd
.
write
(
'
#
include
"
mozilla
/
StaticPrefList_
{
}
.
h
"
\
n
'
.
format
(
group
)
)
    
ensureParentDir
(
fd
.
name
)
    
init_dirname
=
os
.
path
.
dirname
(
fd
.
name
)
    
base_dirname
=
os
.
path
.
dirname
(
init_dirname
)
    
with
FileAvoidWrite
(
os
.
path
.
join
(
base_dirname
'
StaticPrefsAll
.
h
'
)
)
as
fd
:
        
fd
.
write
(
FIRST_LINE
)
        
fd
.
write
(
'
\
n
'
)
        
for
group
in
sorted
(
code
)
:
            
fd
.
write
(
'
#
include
"
mozilla
/
StaticPrefs_
{
}
.
h
"
\
n
'
.
format
(
group
)
)
    
for
group
lines
in
sorted
(
code
.
items
(
)
)
:
        
filename
=
'
StaticPrefList_
{
}
.
h
'
.
format
(
group
)
        
with
FileAvoidWrite
(
os
.
path
.
join
(
init_dirname
filename
)
)
as
fd
:
            
fd
.
write
(
FIRST_LINE
)
            
fd
.
write
(
'
\
n
'
)
            
fd
.
write
(
'
\
n
'
.
join
(
lines
)
)
        
filename
=
'
StaticPrefs_
{
}
.
h
'
.
format
(
group
)
        
with
FileAvoidWrite
(
filename
)
as
fd
:
            
fd
.
write
(
FIRST_LINE
)
            
fd
.
write
(
PREFS_FILE_TEMPLATE1
.
format
(
group
=
group
)
)
            
if
group
in
includes
:
                
for
include
in
sorted
(
includes
[
group
]
)
:
                    
fd
.
write
(
'
#
include
{
}
\
n
'
.
format
(
include
)
)
                
fd
.
write
(
'
\
n
'
)
            
fd
.
write
(
PREFS_FILE_TEMPLATE2
.
format
(
group
=
group
)
)
