#
ifndef
mozilla_StaticPrefsBase_h
#
define
mozilla_StaticPrefsBase_h
#
include
"
mozilla
/
Atomics
.
h
"
namespace
mozilla
{
class
SharedPrefMapBuilder
;
typedef
const
char
*
String
;
typedef
Atomic
<
bool
Relaxed
recordreplay
:
:
Behavior
:
:
DontPreserve
>
RelaxedAtomicBool
;
typedef
Atomic
<
bool
ReleaseAcquire
recordreplay
:
:
Behavior
:
:
DontPreserve
>
ReleaseAcquireAtomicBool
;
typedef
Atomic
<
bool
SequentiallyConsistent
recordreplay
:
:
Behavior
:
:
DontPreserve
>
SequentiallyConsistentAtomicBool
;
typedef
Atomic
<
int32_t
Relaxed
recordreplay
:
:
Behavior
:
:
DontPreserve
>
RelaxedAtomicInt32
;
typedef
Atomic
<
int32_t
ReleaseAcquire
recordreplay
:
:
Behavior
:
:
DontPreserve
>
ReleaseAcquireAtomicInt32
;
typedef
Atomic
<
int32_t
SequentiallyConsistent
recordreplay
:
:
Behavior
:
:
DontPreserve
>
SequentiallyConsistentAtomicInt32
;
typedef
Atomic
<
uint32_t
Relaxed
recordreplay
:
:
Behavior
:
:
DontPreserve
>
RelaxedAtomicUint32
;
typedef
Atomic
<
uint32_t
ReleaseAcquire
recordreplay
:
:
Behavior
:
:
DontPreserve
>
ReleaseAcquireAtomicUint32
;
typedef
Atomic
<
uint32_t
SequentiallyConsistent
recordreplay
:
:
Behavior
:
:
DontPreserve
>
SequentiallyConsistentAtomicUint32
;
typedef
std
:
:
atomic
<
float
>
AtomicFloat
;
template
<
typename
T
>
struct
StripAtomicImpl
{
typedef
T
Type
;
}
;
template
<
typename
T
MemoryOrdering
Order
recordreplay
:
:
Behavior
Recording
>
struct
StripAtomicImpl
<
Atomic
<
T
Order
Recording
>
>
{
typedef
T
Type
;
}
;
template
<
typename
T
>
struct
StripAtomicImpl
<
std
:
:
atomic
<
T
>
>
{
typedef
T
Type
;
}
;
template
<
typename
T
>
using
StripAtomic
=
typename
StripAtomicImpl
<
T
>
:
:
Type
;
template
<
typename
T
>
struct
IsAtomic
:
FalseType
{
}
;
template
<
typename
T
MemoryOrdering
Order
recordreplay
:
:
Behavior
Recording
>
struct
IsAtomic
<
Atomic
<
T
Order
Recording
>
>
:
TrueType
{
}
;
template
<
typename
T
>
struct
IsAtomic
<
std
:
:
atomic
<
T
>
>
:
TrueType
{
}
;
namespace
StaticPrefs
{
void
MaybeInitOncePrefs
(
)
;
}
}
#
endif
