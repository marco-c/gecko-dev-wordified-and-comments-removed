#
include
<
string
>
#
include
<
vector
>
#
include
"
base
/
basictypes
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
ArenaAllocatorExtensions
.
h
"
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
dom
/
ContentPrefs
.
h
"
#
include
"
mozilla
/
dom
/
PContent
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsQuickSort
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
plbase64
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
plstr
.
h
"
#
include
"
prefapi
.
h
"
#
include
"
prefapi_private_data
.
h
"
#
include
"
prefread
.
h
"
#
include
"
prlink
.
h
"
#
ifdef
_WIN32
#
include
"
windows
.
h
"
#
endif
using
namespace
mozilla
;
static
void
ClearPrefEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
{
auto
pref
=
static_cast
<
PrefHashEntry
*
>
(
aEntry
)
;
if
(
pref
-
>
mPrefFlags
.
IsTypeString
(
)
)
{
if
(
pref
-
>
mDefaultPref
.
mStringVal
)
{
PL_strfree
(
pref
-
>
mDefaultPref
.
mStringVal
)
;
}
if
(
pref
-
>
mUserPref
.
mStringVal
)
{
PL_strfree
(
pref
-
>
mUserPref
.
mStringVal
)
;
}
}
pref
-
>
mKey
=
nullptr
;
memset
(
aEntry
0
aTable
-
>
EntrySize
(
)
)
;
}
static
bool
MatchPrefEntry
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
auto
prefEntry
=
static_cast
<
const
PrefHashEntry
*
>
(
aEntry
)
;
if
(
prefEntry
-
>
mKey
=
=
aKey
)
{
return
true
;
}
if
(
!
prefEntry
-
>
mKey
|
|
!
aKey
)
{
return
false
;
}
auto
otherKey
=
static_cast
<
const
char
*
>
(
aKey
)
;
return
(
strcmp
(
prefEntry
-
>
mKey
otherKey
)
=
=
0
)
;
}
struct
CallbackNode
{
char
*
mDomain
;
PrefChangedFunc
mFunc
;
void
*
mData
;
CallbackNode
*
mNext
;
}
;
PLDHashTable
*
gHashTable
;
static
ArenaAllocator
<
8192
4
>
gPrefNameArena
;
static
CallbackNode
*
gFirstCallback
=
nullptr
;
static
CallbackNode
*
gLastPriorityNode
=
nullptr
;
static
bool
gIsAnyPrefLocked
=
false
;
static
bool
gCallbacksInProgress
=
false
;
static
bool
gShouldCleanupDeadNodes
=
false
;
static
PLDHashTableOps
pref_HashTableOps
=
{
PLDHashTable
:
:
HashStringKey
MatchPrefEntry
PLDHashTable
:
:
MoveEntryStub
ClearPrefEntry
nullptr
}
;
#
ifndef
PR_ALIGN_OF_WORD
#
define
PR_ALIGN_OF_WORD
PR_ALIGN_OF_POINTER
#
endif
#
define
WORD_ALIGN_MASK
(
PR_ALIGN_OF_WORD
-
1
)
#
if
(
PR_ALIGN_OF_WORD
&
WORD_ALIGN_MASK
)
!
=
0
#
error
"
PR_ALIGN_OF_WORD
must
be
a
power
of
2
!
"
#
endif
static
PrefsDirtyFunc
gDirtyCallback
=
nullptr
;
inline
void
MakeDirtyCallback
(
)
{
MOZ_ASSERT
(
gDirtyCallback
)
;
if
(
gDirtyCallback
)
{
gDirtyCallback
(
)
;
}
}
void
PREF_SetDirtyCallback
(
PrefsDirtyFunc
aFunc
)
{
gDirtyCallback
=
aFunc
;
}
static
bool
pref_ValueChanged
(
PrefValue
aOldValue
PrefValue
aNewValue
PrefType
aType
)
;
static
nsresult
pref_DoCallback
(
const
char
*
aChangedPref
)
;
enum
{
kPrefSetDefault
=
1
kPrefForceSet
=
2
kPrefStickyDefault
=
4
}
;
static
nsresult
pref_HashPref
(
const
char
*
aKey
PrefValue
aValue
PrefType
aType
uint32_t
aFlags
)
;
#
define
PREF_HASHTABLE_INITIAL_LENGTH
1024
void
PREF_Init
(
)
{
if
(
!
gHashTable
)
{
gHashTable
=
new
PLDHashTable
(
&
pref_HashTableOps
sizeof
(
PrefHashEntry
)
PREF_HASHTABLE_INITIAL_LENGTH
)
;
}
}
void
PREF_Cleanup
(
)
{
NS_ASSERTION
(
!
gCallbacksInProgress
"
PREF_Cleanup
was
called
while
gCallbacksInProgress
is
true
!
"
)
;
CallbackNode
*
node
=
gFirstCallback
;
CallbackNode
*
next_node
;
while
(
node
)
{
next_node
=
node
-
>
mNext
;
PL_strfree
(
node
-
>
mDomain
)
;
free
(
node
)
;
node
=
next_node
;
}
gLastPriorityNode
=
gFirstCallback
=
nullptr
;
PREF_CleanupPrefs
(
)
;
}
void
PREF_CleanupPrefs
(
)
{
if
(
gHashTable
)
{
delete
gHashTable
;
gHashTable
=
nullptr
;
gPrefNameArena
.
Clear
(
)
;
}
}
static
void
StrEscape
(
const
char
*
aOriginal
nsCString
&
aResult
)
{
const
char
*
p
;
if
(
aOriginal
=
=
nullptr
)
{
return
;
}
for
(
p
=
aOriginal
;
*
p
;
+
+
p
)
{
switch
(
*
p
)
{
case
'
\
n
'
:
aResult
.
AppendLiteral
(
"
\
\
n
"
)
;
break
;
case
'
\
r
'
:
aResult
.
AppendLiteral
(
"
\
\
r
"
)
;
break
;
case
'
\
\
'
:
aResult
.
AppendLiteral
(
"
\
\
\
\
"
)
;
break
;
case
'
\
"
'
:
aResult
.
AppendLiteral
(
"
\
\
\
"
"
)
;
break
;
default
:
aResult
.
Append
(
*
p
)
;
break
;
}
}
}
nsresult
PREF_SetCharPref
(
const
char
*
aPrefName
const
char
*
aValue
bool
aSetDefault
)
{
if
(
strlen
(
aValue
)
>
MAX_PREF_LENGTH
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
PrefValue
pref
;
pref
.
mStringVal
=
const_cast
<
char
*
>
(
aValue
)
;
return
pref_HashPref
(
aPrefName
pref
PrefType
:
:
String
aSetDefault
?
kPrefSetDefault
:
0
)
;
}
nsresult
PREF_SetIntPref
(
const
char
*
aPrefName
int32_t
aValue
bool
aSetDefault
)
{
PrefValue
pref
;
pref
.
mIntVal
=
aValue
;
return
pref_HashPref
(
aPrefName
pref
PrefType
:
:
Int
aSetDefault
?
kPrefSetDefault
:
0
)
;
}
nsresult
PREF_SetBoolPref
(
const
char
*
aPrefName
bool
aValue
bool
aSetDefault
)
{
PrefValue
pref
;
pref
.
mBoolVal
=
aValue
;
return
pref_HashPref
(
aPrefName
pref
PrefType
:
:
Bool
aSetDefault
?
kPrefSetDefault
:
0
)
;
}
enum
WhichValue
{
DEFAULT_VALUE
USER_VALUE
}
;
static
nsresult
SetPrefValue
(
const
char
*
aPrefName
const
dom
:
:
PrefValue
&
aValue
WhichValue
aWhich
)
{
bool
setDefault
=
(
aWhich
=
=
DEFAULT_VALUE
)
;
switch
(
aValue
.
type
(
)
)
{
case
dom
:
:
PrefValue
:
:
TnsCString
:
return
PREF_SetCharPref
(
aPrefName
aValue
.
get_nsCString
(
)
.
get
(
)
setDefault
)
;
case
dom
:
:
PrefValue
:
:
Tint32_t
:
return
PREF_SetIntPref
(
aPrefName
aValue
.
get_int32_t
(
)
setDefault
)
;
case
dom
:
:
PrefValue
:
:
Tbool
:
return
PREF_SetBoolPref
(
aPrefName
aValue
.
get_bool
(
)
setDefault
)
;
default
:
MOZ_CRASH
(
)
;
}
}
nsresult
pref_SetPref
(
const
dom
:
:
PrefSetting
&
aPref
)
{
const
char
*
prefName
=
aPref
.
name
(
)
.
get
(
)
;
const
dom
:
:
MaybePrefValue
&
defaultValue
=
aPref
.
defaultValue
(
)
;
const
dom
:
:
MaybePrefValue
&
userValue
=
aPref
.
userValue
(
)
;
nsresult
rv
;
if
(
defaultValue
.
type
(
)
=
=
dom
:
:
MaybePrefValue
:
:
TPrefValue
)
{
rv
=
SetPrefValue
(
prefName
defaultValue
.
get_PrefValue
(
)
DEFAULT_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
userValue
.
type
(
)
=
=
dom
:
:
MaybePrefValue
:
:
TPrefValue
)
{
rv
=
SetPrefValue
(
prefName
userValue
.
get_PrefValue
(
)
USER_VALUE
)
;
}
else
{
rv
=
PREF_ClearUserPref
(
prefName
)
;
}
return
rv
;
}
PrefSaveData
pref_savePrefs
(
PLDHashTable
*
aTable
)
{
PrefSaveData
savedPrefs
(
aTable
-
>
EntryCount
(
)
)
;
for
(
auto
iter
=
aTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
pref
=
static_cast
<
PrefHashEntry
*
>
(
iter
.
Get
(
)
)
;
nsAutoCString
prefValue
;
nsAutoCString
prefPrefix
;
prefPrefix
.
AssignLiteral
(
"
user_pref
(
\
"
"
)
;
PrefValue
*
sourcePref
;
if
(
pref
-
>
mPrefFlags
.
HasUserValue
(
)
&
&
(
pref_ValueChanged
(
pref
-
>
mDefaultPref
pref
-
>
mUserPref
pref
-
>
mPrefFlags
.
GetPrefType
(
)
)
|
|
!
pref
-
>
mPrefFlags
.
HasDefault
(
)
|
|
pref
-
>
mPrefFlags
.
HasStickyDefault
(
)
)
)
{
sourcePref
=
&
pref
-
>
mUserPref
;
}
else
{
continue
;
}
if
(
pref
-
>
mPrefFlags
.
IsTypeString
(
)
)
{
prefValue
=
'
\
"
'
;
StrEscape
(
sourcePref
-
>
mStringVal
prefValue
)
;
prefValue
+
=
'
\
"
'
;
}
else
if
(
pref
-
>
mPrefFlags
.
IsTypeInt
(
)
)
{
prefValue
.
AppendInt
(
sourcePref
-
>
mIntVal
)
;
}
else
if
(
pref
-
>
mPrefFlags
.
IsTypeBool
(
)
)
{
prefValue
=
(
sourcePref
-
>
mBoolVal
)
?
"
true
"
:
"
false
"
;
}
nsAutoCString
prefName
;
StrEscape
(
pref
-
>
mKey
prefName
)
;
savedPrefs
.
AppendElement
(
)
-
>
reset
(
ToNewCString
(
prefPrefix
+
prefName
+
NS_LITERAL_CSTRING
(
"
\
"
"
)
+
prefValue
+
NS_LITERAL_CSTRING
(
"
)
;
"
)
)
)
;
}
return
savedPrefs
;
}
bool
pref_EntryHasAdvisablySizedValues
(
PrefHashEntry
*
aHashEntry
)
{
if
(
aHashEntry
-
>
mPrefFlags
.
GetPrefType
(
)
!
=
PrefType
:
:
String
)
{
return
true
;
}
char
*
stringVal
;
if
(
aHashEntry
-
>
mPrefFlags
.
HasDefault
(
)
)
{
stringVal
=
aHashEntry
-
>
mDefaultPref
.
mStringVal
;
if
(
strlen
(
stringVal
)
>
MAX_ADVISABLE_PREF_LENGTH
)
{
return
false
;
}
}
if
(
aHashEntry
-
>
mPrefFlags
.
HasUserValue
(
)
)
{
stringVal
=
aHashEntry
-
>
mUserPref
.
mStringVal
;
if
(
strlen
(
stringVal
)
>
MAX_ADVISABLE_PREF_LENGTH
)
{
return
false
;
}
}
return
true
;
}
static
void
GetPrefValueFromEntry
(
PrefHashEntry
*
aHashEntry
dom
:
:
PrefSetting
*
aPref
WhichValue
aWhich
)
{
PrefValue
*
value
;
dom
:
:
PrefValue
*
settingValue
;
if
(
aWhich
=
=
USER_VALUE
)
{
value
=
&
aHashEntry
-
>
mUserPref
;
aPref
-
>
userValue
(
)
=
dom
:
:
PrefValue
(
)
;
settingValue
=
&
aPref
-
>
userValue
(
)
.
get_PrefValue
(
)
;
}
else
{
value
=
&
aHashEntry
-
>
mDefaultPref
;
aPref
-
>
defaultValue
(
)
=
dom
:
:
PrefValue
(
)
;
settingValue
=
&
aPref
-
>
defaultValue
(
)
.
get_PrefValue
(
)
;
}
switch
(
aHashEntry
-
>
mPrefFlags
.
GetPrefType
(
)
)
{
case
PrefType
:
:
String
:
*
settingValue
=
nsDependentCString
(
value
-
>
mStringVal
)
;
return
;
case
PrefType
:
:
Int
:
*
settingValue
=
value
-
>
mIntVal
;
return
;
case
PrefType
:
:
Bool
:
*
settingValue
=
!
!
value
-
>
mBoolVal
;
return
;
default
:
MOZ_CRASH
(
)
;
}
}
void
pref_GetPrefFromEntry
(
PrefHashEntry
*
aHashEntry
dom
:
:
PrefSetting
*
aPref
)
{
aPref
-
>
name
(
)
=
aHashEntry
-
>
mKey
;
if
(
aHashEntry
-
>
mPrefFlags
.
HasDefault
(
)
)
{
GetPrefValueFromEntry
(
aHashEntry
aPref
DEFAULT_VALUE
)
;
}
else
{
aPref
-
>
defaultValue
(
)
=
null_t
(
)
;
}
if
(
aHashEntry
-
>
mPrefFlags
.
HasUserValue
(
)
)
{
GetPrefValueFromEntry
(
aHashEntry
aPref
USER_VALUE
)
;
}
else
{
aPref
-
>
userValue
(
)
=
null_t
(
)
;
}
MOZ_ASSERT
(
aPref
-
>
defaultValue
(
)
.
type
(
)
=
=
dom
:
:
MaybePrefValue
:
:
Tnull_t
|
|
aPref
-
>
userValue
(
)
.
type
(
)
=
=
dom
:
:
MaybePrefValue
:
:
Tnull_t
|
|
(
aPref
-
>
defaultValue
(
)
.
get_PrefValue
(
)
.
type
(
)
=
=
aPref
-
>
userValue
(
)
.
get_PrefValue
(
)
.
type
(
)
)
)
;
}
bool
PREF_HasUserPref
(
const
char
*
aPrefName
)
{
if
(
!
gHashTable
)
{
return
false
;
}
PrefHashEntry
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
return
pref
&
&
pref
-
>
mPrefFlags
.
HasUserValue
(
)
;
}
nsresult
PREF_CopyCharPref
(
const
char
*
aPrefName
char
*
*
aValueOut
bool
aGetDefault
)
{
if
(
!
gHashTable
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
NS_ERROR_UNEXPECTED
;
char
*
stringVal
;
PrefHashEntry
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
if
(
pref
&
&
pref
-
>
mPrefFlags
.
IsTypeString
(
)
)
{
if
(
aGetDefault
|
|
pref
-
>
mPrefFlags
.
IsLocked
(
)
|
|
!
pref
-
>
mPrefFlags
.
HasUserValue
(
)
)
{
stringVal
=
pref
-
>
mDefaultPref
.
mStringVal
;
}
else
{
stringVal
=
pref
-
>
mUserPref
.
mStringVal
;
}
if
(
stringVal
)
{
*
aValueOut
=
NS_strdup
(
stringVal
)
;
rv
=
NS_OK
;
}
}
return
rv
;
}
nsresult
PREF_GetIntPref
(
const
char
*
aPrefName
int32_t
*
aValueOut
bool
aGetDefault
)
{
if
(
!
gHashTable
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
NS_ERROR_UNEXPECTED
;
PrefHashEntry
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
if
(
pref
&
&
pref
-
>
mPrefFlags
.
IsTypeInt
(
)
)
{
if
(
aGetDefault
|
|
pref
-
>
mPrefFlags
.
IsLocked
(
)
|
|
!
pref
-
>
mPrefFlags
.
HasUserValue
(
)
)
{
int32_t
tempInt
=
pref
-
>
mDefaultPref
.
mIntVal
;
if
(
!
pref
-
>
mPrefFlags
.
HasDefault
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
aValueOut
=
tempInt
;
}
else
{
*
aValueOut
=
pref
-
>
mUserPref
.
mIntVal
;
}
rv
=
NS_OK
;
}
return
rv
;
}
nsresult
PREF_GetBoolPref
(
const
char
*
aPrefName
bool
*
aValueOut
bool
aGetDefault
)
{
if
(
!
gHashTable
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
NS_ERROR_UNEXPECTED
;
PrefHashEntry
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
if
(
pref
&
&
pref
-
>
mPrefFlags
.
IsTypeBool
(
)
)
{
if
(
aGetDefault
|
|
pref
-
>
mPrefFlags
.
IsLocked
(
)
|
|
!
pref
-
>
mPrefFlags
.
HasUserValue
(
)
)
{
bool
tempBool
=
pref
-
>
mDefaultPref
.
mBoolVal
;
if
(
pref
-
>
mPrefFlags
.
HasDefault
(
)
)
{
*
aValueOut
=
tempBool
;
rv
=
NS_OK
;
}
}
else
{
*
aValueOut
=
pref
-
>
mUserPref
.
mBoolVal
;
rv
=
NS_OK
;
}
}
return
rv
;
}
nsresult
PREF_DeleteBranch
(
const
char
*
aBranchName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
size_t
len
=
strlen
(
aBranchName
)
;
if
(
!
gHashTable
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsAutoCString
branch_dot
(
aBranchName
)
;
if
(
len
>
1
&
&
aBranchName
[
len
-
1
]
!
=
'
.
'
)
{
branch_dot
+
=
'
.
'
;
}
const
char
*
to_delete
=
branch_dot
.
get
(
)
;
MOZ_ASSERT
(
to_delete
)
;
len
=
strlen
(
to_delete
)
;
for
(
auto
iter
=
gHashTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
PrefHashEntry
*
>
(
iter
.
Get
(
)
)
;
if
(
PL_strncmp
(
entry
-
>
mKey
to_delete
len
)
=
=
0
|
|
(
len
-
1
=
=
strlen
(
entry
-
>
mKey
)
&
&
PL_strncmp
(
entry
-
>
mKey
to_delete
len
-
1
)
=
=
0
)
)
{
iter
.
Remove
(
)
;
}
}
MakeDirtyCallback
(
)
;
return
NS_OK
;
}
nsresult
PREF_ClearUserPref
(
const
char
*
aPrefName
)
{
if
(
!
gHashTable
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
PrefHashEntry
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
if
(
pref
&
&
pref
-
>
mPrefFlags
.
HasUserValue
(
)
)
{
pref
-
>
mPrefFlags
.
SetHasUserValue
(
false
)
;
if
(
!
pref
-
>
mPrefFlags
.
HasDefault
(
)
)
{
gHashTable
-
>
RemoveEntry
(
pref
)
;
}
pref_DoCallback
(
aPrefName
)
;
MakeDirtyCallback
(
)
;
}
return
NS_OK
;
}
nsresult
PREF_ClearAllUserPrefs
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gHashTable
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
std
:
:
vector
<
std
:
:
string
>
prefStrings
;
for
(
auto
iter
=
gHashTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
pref
=
static_cast
<
PrefHashEntry
*
>
(
iter
.
Get
(
)
)
;
if
(
pref
-
>
mPrefFlags
.
HasUserValue
(
)
)
{
prefStrings
.
push_back
(
std
:
:
string
(
pref
-
>
mKey
)
)
;
pref
-
>
mPrefFlags
.
SetHasUserValue
(
false
)
;
if
(
!
pref
-
>
mPrefFlags
.
HasDefault
(
)
)
{
iter
.
Remove
(
)
;
}
}
}
for
(
std
:
:
string
&
prefString
:
prefStrings
)
{
pref_DoCallback
(
prefString
.
c_str
(
)
)
;
}
MakeDirtyCallback
(
)
;
return
NS_OK
;
}
nsresult
PREF_LockPref
(
const
char
*
aKey
bool
aLockIt
)
{
if
(
!
gHashTable
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
PrefHashEntry
*
pref
=
pref_HashTableLookup
(
aKey
)
;
if
(
!
pref
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
aLockIt
)
{
if
(
!
pref
-
>
mPrefFlags
.
IsLocked
(
)
)
{
pref
-
>
mPrefFlags
.
SetLocked
(
true
)
;
gIsAnyPrefLocked
=
true
;
pref_DoCallback
(
aKey
)
;
}
}
else
if
(
pref
-
>
mPrefFlags
.
IsLocked
(
)
)
{
pref
-
>
mPrefFlags
.
SetLocked
(
false
)
;
pref_DoCallback
(
aKey
)
;
}
return
NS_OK
;
}
static
bool
pref_ValueChanged
(
PrefValue
aOldValue
PrefValue
aNewValue
PrefType
aType
)
{
bool
changed
=
true
;
switch
(
aType
)
{
case
PrefType
:
:
String
:
if
(
aOldValue
.
mStringVal
&
&
aNewValue
.
mStringVal
)
{
changed
=
(
strcmp
(
aOldValue
.
mStringVal
aNewValue
.
mStringVal
)
!
=
0
)
;
}
break
;
case
PrefType
:
:
Int
:
changed
=
aOldValue
.
mIntVal
!
=
aNewValue
.
mIntVal
;
break
;
case
PrefType
:
:
Bool
:
changed
=
aOldValue
.
mBoolVal
!
=
aNewValue
.
mBoolVal
;
break
;
case
PrefType
:
:
Invalid
:
default
:
changed
=
false
;
break
;
}
return
changed
;
}
static
PrefTypeFlags
pref_SetValue
(
PrefValue
*
aExistingValue
PrefTypeFlags
aFlags
PrefValue
aNewValue
PrefType
aNewType
)
{
if
(
aFlags
.
IsTypeString
(
)
&
&
aExistingValue
-
>
mStringVal
)
{
PL_strfree
(
aExistingValue
-
>
mStringVal
)
;
}
aFlags
.
SetPrefType
(
aNewType
)
;
if
(
aFlags
.
IsTypeString
(
)
)
{
MOZ_ASSERT
(
aNewValue
.
mStringVal
)
;
aExistingValue
-
>
mStringVal
=
aNewValue
.
mStringVal
?
PL_strdup
(
aNewValue
.
mStringVal
)
:
nullptr
;
}
else
{
*
aExistingValue
=
aNewValue
;
}
return
aFlags
;
}
#
ifdef
DEBUG
static
pref_initPhase
gPhase
=
START
;
static
bool
gWatchingPref
=
false
;
void
pref_SetInitPhase
(
pref_initPhase
aPhase
)
{
gPhase
=
aPhase
;
}
pref_initPhase
pref_GetInitPhase
(
)
{
return
gPhase
;
}
void
pref_SetWatchingPref
(
bool
aWatching
)
{
gWatchingPref
=
aWatching
;
}
struct
StringComparator
{
const
char
*
mKey
;
explicit
StringComparator
(
const
char
*
aKey
)
:
mKey
(
aKey
)
{
}
int
operator
(
)
(
const
char
*
aString
)
const
{
return
strcmp
(
mKey
aString
)
;
}
}
;
bool
InInitArray
(
const
char
*
aKey
)
{
size_t
prefsLen
;
size_t
found
;
const
char
*
*
list
=
mozilla
:
:
dom
:
:
ContentPrefs
:
:
GetContentPrefs
(
&
prefsLen
)
;
return
BinarySearchIf
(
list
0
prefsLen
StringComparator
(
aKey
)
&
found
)
;
}
#
endif
PrefHashEntry
*
pref_HashTableLookup
(
const
char
*
aKey
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
|
|
mozilla
:
:
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
MOZ_ASSERT
(
(
!
XRE_IsContentProcess
(
)
|
|
gPhase
!
=
START
)
"
pref
access
before
commandline
prefs
set
"
)
;
#
ifdef
DEBUG
if
(
XRE_IsContentProcess
(
)
&
&
gPhase
<
=
END_INIT_PREFS
&
&
!
gWatchingPref
&
&
!
InInitArray
(
aKey
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
accessing
non
-
init
pref
%
s
before
the
rest
of
the
prefs
are
sent
"
aKey
)
;
}
#
endif
return
static_cast
<
PrefHashEntry
*
>
(
gHashTable
-
>
Search
(
aKey
)
)
;
}
nsresult
pref_HashPref
(
const
char
*
aKey
PrefValue
aValue
PrefType
aType
uint32_t
aFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gHashTable
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
auto
pref
=
static_cast
<
PrefHashEntry
*
>
(
gHashTable
-
>
Add
(
aKey
fallible
)
)
;
if
(
!
pref
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
!
pref
-
>
mKey
)
{
pref
-
>
mPrefFlags
.
Reset
(
)
.
SetPrefType
(
aType
)
;
pref
-
>
mKey
=
ArenaStrdup
(
aKey
gPrefNameArena
)
;
memset
(
&
pref
-
>
mDefaultPref
0
sizeof
(
pref
-
>
mDefaultPref
)
)
;
memset
(
&
pref
-
>
mUserPref
0
sizeof
(
pref
-
>
mUserPref
)
)
;
}
else
if
(
pref
-
>
mPrefFlags
.
HasDefault
(
)
&
&
!
pref
-
>
mPrefFlags
.
IsPrefType
(
aType
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
Trying
to
overwrite
value
of
default
pref
%
s
with
the
wrong
type
!
"
aKey
)
.
get
(
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
bool
valueChanged
=
false
;
if
(
aFlags
&
kPrefSetDefault
)
{
if
(
!
pref
-
>
mPrefFlags
.
IsLocked
(
)
)
{
if
(
pref_ValueChanged
(
pref
-
>
mDefaultPref
aValue
aType
)
|
|
!
pref
-
>
mPrefFlags
.
HasDefault
(
)
)
{
pref
-
>
mPrefFlags
=
pref_SetValue
(
&
pref
-
>
mDefaultPref
pref
-
>
mPrefFlags
aValue
aType
)
.
SetHasDefault
(
true
)
;
if
(
aFlags
&
kPrefStickyDefault
)
{
pref
-
>
mPrefFlags
.
SetHasStickyDefault
(
true
)
;
}
if
(
!
pref
-
>
mPrefFlags
.
HasUserValue
(
)
)
{
valueChanged
=
true
;
}
}
}
}
else
{
if
(
(
pref
-
>
mPrefFlags
.
HasDefault
(
)
)
&
&
!
(
pref
-
>
mPrefFlags
.
HasStickyDefault
(
)
)
&
&
!
pref_ValueChanged
(
pref
-
>
mDefaultPref
aValue
aType
)
&
&
!
(
aFlags
&
kPrefForceSet
)
)
{
if
(
pref
-
>
mPrefFlags
.
HasUserValue
(
)
)
{
pref
-
>
mPrefFlags
.
SetHasUserValue
(
false
)
;
if
(
!
pref
-
>
mPrefFlags
.
IsLocked
(
)
)
{
MakeDirtyCallback
(
)
;
valueChanged
=
true
;
}
}
}
else
if
(
!
pref
-
>
mPrefFlags
.
HasUserValue
(
)
|
|
!
pref
-
>
mPrefFlags
.
IsPrefType
(
aType
)
|
|
pref_ValueChanged
(
pref
-
>
mUserPref
aValue
aType
)
)
{
pref
-
>
mPrefFlags
=
pref_SetValue
(
&
pref
-
>
mUserPref
pref
-
>
mPrefFlags
aValue
aType
)
.
SetHasUserValue
(
true
)
;
if
(
!
pref
-
>
mPrefFlags
.
IsLocked
(
)
)
{
MakeDirtyCallback
(
)
;
valueChanged
=
true
;
}
}
}
if
(
valueChanged
)
{
return
pref_DoCallback
(
aKey
)
;
}
return
NS_OK
;
}
size_t
pref_SizeOfPrivateData
(
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
gPrefNameArena
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
CallbackNode
*
node
=
gFirstCallback
;
node
;
node
=
node
-
>
mNext
)
{
n
+
=
aMallocSizeOf
(
node
)
;
n
+
=
aMallocSizeOf
(
node
-
>
mDomain
)
;
}
return
n
;
}
PrefType
PREF_GetPrefType
(
const
char
*
aPrefName
)
{
if
(
gHashTable
)
{
PrefHashEntry
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
if
(
pref
)
{
return
pref
-
>
mPrefFlags
.
GetPrefType
(
)
;
}
}
return
PrefType
:
:
Invalid
;
}
bool
PREF_PrefIsLocked
(
const
char
*
aPrefName
)
{
bool
result
=
false
;
if
(
gIsAnyPrefLocked
&
&
gHashTable
)
{
PrefHashEntry
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
if
(
pref
&
&
pref
-
>
mPrefFlags
.
IsLocked
(
)
)
{
result
=
true
;
}
}
return
result
;
}
void
PREF_RegisterPriorityCallback
(
const
char
*
aPrefNode
PrefChangedFunc
aCallback
void
*
aData
)
{
NS_PRECONDITION
(
aPrefNode
"
aPrefNode
must
not
be
nullptr
"
)
;
NS_PRECONDITION
(
aCallback
"
aCallback
must
not
be
nullptr
"
)
;
auto
node
=
(
CallbackNode
*
)
malloc
(
sizeof
(
struct
CallbackNode
)
)
;
if
(
node
)
{
node
-
>
mDomain
=
PL_strdup
(
aPrefNode
)
;
node
-
>
mFunc
=
aCallback
;
node
-
>
mData
=
aData
;
node
-
>
mNext
=
gFirstCallback
;
gFirstCallback
=
node
;
if
(
!
gLastPriorityNode
)
{
gLastPriorityNode
=
node
;
}
}
}
void
PREF_RegisterCallback
(
const
char
*
aPrefNode
PrefChangedFunc
aCallback
void
*
aData
)
{
NS_PRECONDITION
(
aPrefNode
"
aPrefNode
must
not
be
nullptr
"
)
;
NS_PRECONDITION
(
aCallback
"
aCallback
must
not
be
nullptr
"
)
;
auto
node
=
(
CallbackNode
*
)
malloc
(
sizeof
(
struct
CallbackNode
)
)
;
if
(
node
)
{
node
-
>
mDomain
=
PL_strdup
(
aPrefNode
)
;
node
-
>
mFunc
=
aCallback
;
node
-
>
mData
=
aData
;
if
(
gLastPriorityNode
)
{
node
-
>
mNext
=
gLastPriorityNode
-
>
mNext
;
gLastPriorityNode
-
>
mNext
=
node
;
}
else
{
node
-
>
mNext
=
gFirstCallback
;
gFirstCallback
=
node
;
}
}
}
CallbackNode
*
pref_RemoveCallbackNode
(
CallbackNode
*
aNode
CallbackNode
*
aPrevNode
)
{
NS_PRECONDITION
(
!
aPrevNode
|
|
aPrevNode
-
>
mNext
=
=
aNode
"
invalid
params
"
)
;
NS_PRECONDITION
(
aPrevNode
|
|
gFirstCallback
=
=
aNode
"
invalid
params
"
)
;
NS_ASSERTION
(
!
gCallbacksInProgress
"
modifying
the
callback
list
while
gCallbacksInProgress
is
true
"
)
;
CallbackNode
*
next_node
=
aNode
-
>
mNext
;
if
(
aPrevNode
)
{
aPrevNode
-
>
mNext
=
next_node
;
}
else
{
gFirstCallback
=
next_node
;
}
if
(
gLastPriorityNode
=
=
aNode
)
{
gLastPriorityNode
=
aPrevNode
;
}
PL_strfree
(
aNode
-
>
mDomain
)
;
free
(
aNode
)
;
return
next_node
;
}
nsresult
PREF_UnregisterCallback
(
const
char
*
aPrefNode
PrefChangedFunc
aCallback
void
*
aData
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
CallbackNode
*
node
=
gFirstCallback
;
CallbackNode
*
prev_node
=
nullptr
;
while
(
node
!
=
nullptr
)
{
if
(
node
-
>
mFunc
=
=
aCallback
&
&
node
-
>
mData
=
=
aData
&
&
strcmp
(
node
-
>
mDomain
aPrefNode
)
=
=
0
)
{
if
(
gCallbacksInProgress
)
{
node
-
>
mFunc
=
nullptr
;
gShouldCleanupDeadNodes
=
true
;
prev_node
=
node
;
node
=
node
-
>
mNext
;
}
else
{
node
=
pref_RemoveCallbackNode
(
node
prev_node
)
;
}
rv
=
NS_OK
;
}
else
{
prev_node
=
node
;
node
=
node
-
>
mNext
;
}
}
return
rv
;
}
static
nsresult
pref_DoCallback
(
const
char
*
aChangedPref
)
{
nsresult
rv
=
NS_OK
;
CallbackNode
*
node
;
bool
reentered
=
gCallbacksInProgress
;
gCallbacksInProgress
=
true
;
for
(
node
=
gFirstCallback
;
node
!
=
nullptr
;
node
=
node
-
>
mNext
)
{
if
(
node
-
>
mFunc
&
&
PL_strncmp
(
aChangedPref
node
-
>
mDomain
strlen
(
node
-
>
mDomain
)
)
=
=
0
)
{
(
*
node
-
>
mFunc
)
(
aChangedPref
node
-
>
mData
)
;
}
}
gCallbacksInProgress
=
reentered
;
if
(
gShouldCleanupDeadNodes
&
&
!
gCallbacksInProgress
)
{
CallbackNode
*
prev_node
=
nullptr
;
node
=
gFirstCallback
;
while
(
node
!
=
nullptr
)
{
if
(
!
node
-
>
mFunc
)
{
node
=
pref_RemoveCallbackNode
(
node
prev_node
)
;
}
else
{
prev_node
=
node
;
node
=
node
-
>
mNext
;
}
}
gShouldCleanupDeadNodes
=
false
;
}
return
rv
;
}
void
PREF_ReaderCallback
(
void
*
aClosure
const
char
*
aPref
PrefValue
aValue
PrefType
aType
bool
aIsDefault
bool
aIsStickyDefault
)
{
uint32_t
flags
=
0
;
if
(
aIsDefault
)
{
flags
|
=
kPrefSetDefault
;
if
(
aIsStickyDefault
)
{
flags
|
=
kPrefStickyDefault
;
}
}
else
{
flags
|
=
kPrefForceSet
;
}
pref_HashPref
(
aPref
aValue
aType
flags
)
;
}
