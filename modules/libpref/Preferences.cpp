#
include
<
ctype
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
"
base
/
basictypes
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
ArenaAllocatorExtensions
.
h
"
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
ContentPrefs
.
h
"
#
include
"
mozilla
/
dom
/
PContent
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ModuleUtils
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
URLPreloader
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCategoryManagerUtils
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIDirectoryService
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefLocalizedString
.
h
"
#
include
"
nsIRelativeFilePref
.
h
"
#
include
"
nsISafeOutputStream
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIStringEnumerator
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIZipReader
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsQuickSort
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsXPCOMCID
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsZipArchive
.
h
"
#
include
"
plbase64
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
plstr
.
h
"
#
include
"
prlink
.
h
"
#
ifdef
XP_WIN
#
include
"
windows
.
h
"
#
endif
using
namespace
mozilla
;
#
ifdef
DEBUG
#
define
ENSURE_PARENT_PROCESS
(
func
pref
)
\
do
{
\
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
\
nsPrintfCString
msg
(
\
"
ENSURE_PARENT_PROCESS
:
called
%
s
on
%
s
in
a
non
-
parent
process
"
\
func
\
pref
)
;
\
NS_ERROR
(
msg
.
get
(
)
)
;
\
return
NS_ERROR_NOT_AVAILABLE
;
\
}
\
}
while
(
0
)
#
else
#
define
ENSURE_PARENT_PROCESS
(
func
pref
)
\
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
\
return
NS_ERROR_NOT_AVAILABLE
;
\
}
#
endif
typedef
nsTArray
<
nsCString
>
PrefSaveData
;
static
const
uint32_t
MAX_PREF_LENGTH
=
1
*
1024
*
1024
;
static
const
uint32_t
MAX_ADVISABLE_PREF_LENGTH
=
4
*
1024
;
enum
class
PrefType
:
uint8_t
{
None
=
0
String
=
1
Int
=
2
Bool
=
3
}
;
union
PrefValue
{
const
char
*
mStringVal
;
int32_t
mIntVal
;
bool
mBoolVal
;
bool
Equals
(
PrefType
aType
PrefValue
aValue
)
{
switch
(
aType
)
{
case
PrefType
:
:
String
:
{
if
(
mStringVal
&
&
aValue
.
mStringVal
)
{
return
strcmp
(
mStringVal
aValue
.
mStringVal
)
=
=
0
;
}
if
(
!
mStringVal
&
&
!
aValue
.
mStringVal
)
{
return
true
;
}
return
false
;
}
case
PrefType
:
:
Int
:
return
mIntVal
=
=
aValue
.
mIntVal
;
case
PrefType
:
:
Bool
:
return
mBoolVal
=
=
aValue
.
mBoolVal
;
default
:
MOZ_CRASH
(
"
Unhandled
enum
value
"
)
;
}
}
void
Init
(
PrefType
aNewType
PrefValue
aNewValue
)
{
if
(
aNewType
=
=
PrefType
:
:
String
)
{
MOZ_ASSERT
(
aNewValue
.
mStringVal
)
;
aNewValue
.
mStringVal
=
moz_xstrdup
(
aNewValue
.
mStringVal
)
;
}
*
this
=
aNewValue
;
}
void
Clear
(
PrefType
aType
)
{
if
(
aType
=
=
PrefType
:
:
String
)
{
free
(
const_cast
<
char
*
>
(
mStringVal
)
)
;
mStringVal
=
nullptr
;
}
}
void
Replace
(
PrefType
aOldType
PrefType
aNewType
PrefValue
aNewValue
)
{
Clear
(
aOldType
)
;
Init
(
aNewType
aNewValue
)
;
}
void
ToDomPrefValue
(
PrefType
aType
dom
:
:
PrefValue
*
aDomValue
)
{
switch
(
aType
)
{
case
PrefType
:
:
String
:
*
aDomValue
=
nsDependentCString
(
mStringVal
)
;
return
;
case
PrefType
:
:
Int
:
*
aDomValue
=
mIntVal
;
return
;
case
PrefType
:
:
Bool
:
*
aDomValue
=
mBoolVal
;
return
;
default
:
MOZ_CRASH
(
)
;
}
}
PrefType
FromDomPrefValue
(
const
dom
:
:
PrefValue
&
aDomValue
)
{
switch
(
aDomValue
.
type
(
)
)
{
case
dom
:
:
PrefValue
:
:
TnsCString
:
mStringVal
=
aDomValue
.
get_nsCString
(
)
.
get
(
)
;
return
PrefType
:
:
String
;
case
dom
:
:
PrefValue
:
:
Tint32_t
:
mIntVal
=
aDomValue
.
get_int32_t
(
)
;
return
PrefType
:
:
Int
;
case
dom
:
:
PrefValue
:
:
Tbool
:
mBoolVal
=
aDomValue
.
get_bool
(
)
;
return
PrefType
:
:
Bool
;
default
:
MOZ_CRASH
(
)
;
}
}
}
;
#
ifdef
DEBUG
const
char
*
PrefTypeToString
(
PrefType
aType
)
{
switch
(
aType
)
{
case
PrefType
:
:
String
:
return
"
string
"
;
case
PrefType
:
:
Int
:
return
"
int
"
;
case
PrefType
:
:
Bool
:
return
"
bool
"
;
default
:
MOZ_CRASH
(
"
Unhandled
enum
value
"
)
;
}
}
#
endif
static
void
StrEscape
(
const
char
*
aOriginal
nsCString
&
aResult
)
{
if
(
aOriginal
=
=
nullptr
)
{
aResult
.
AssignLiteral
(
"
\
"
\
"
"
)
;
return
;
}
const
char
*
p
;
aResult
.
Assign
(
'
"
'
)
;
for
(
p
=
aOriginal
;
*
p
;
+
+
p
)
{
switch
(
*
p
)
{
case
'
\
n
'
:
aResult
.
AppendLiteral
(
"
\
\
n
"
)
;
break
;
case
'
\
r
'
:
aResult
.
AppendLiteral
(
"
\
\
r
"
)
;
break
;
case
'
\
\
'
:
aResult
.
AppendLiteral
(
"
\
\
\
\
"
)
;
break
;
case
'
\
"
'
:
aResult
.
AppendLiteral
(
"
\
\
\
"
"
)
;
break
;
default
:
aResult
.
Append
(
*
p
)
;
break
;
}
}
aResult
.
Append
(
'
"
'
)
;
}
static
ArenaAllocator
<
8192
1
>
gPrefNameArena
;
class
Pref
:
public
PLDHashEntryHdr
{
public
:
explicit
Pref
(
const
char
*
aName
)
{
mName
=
ArenaStrdup
(
aName
gPrefNameArena
)
;
}
~
Pref
(
)
{
mDefaultValue
.
Clear
(
Type
(
)
)
;
mUserValue
.
Clear
(
Type
(
)
)
;
}
const
char
*
Name
(
)
{
return
mName
;
}
PrefType
Type
(
)
const
{
return
static_cast
<
PrefType
>
(
mType
)
;
}
void
SetType
(
PrefType
aType
)
{
mType
=
static_cast
<
uint32_t
>
(
aType
)
;
}
bool
IsType
(
PrefType
aType
)
const
{
return
Type
(
)
=
=
aType
;
}
bool
IsTypeString
(
)
const
{
return
IsType
(
PrefType
:
:
String
)
;
}
bool
IsTypeInt
(
)
const
{
return
IsType
(
PrefType
:
:
Int
)
;
}
bool
IsTypeBool
(
)
const
{
return
IsType
(
PrefType
:
:
Bool
)
;
}
bool
IsLocked
(
)
const
{
return
mIsLocked
;
}
void
SetIsLocked
(
bool
aValue
)
{
mIsLocked
=
aValue
;
}
bool
HasDefaultValue
(
)
const
{
return
mHasDefaultValue
;
}
bool
HasUserValue
(
)
const
{
return
mHasUserValue
;
}
static
bool
MatchEntry
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
auto
pref
=
static_cast
<
const
Pref
*
>
(
aEntry
)
;
auto
key
=
static_cast
<
const
char
*
>
(
aKey
)
;
if
(
pref
-
>
mName
=
=
aKey
)
{
return
true
;
}
if
(
!
pref
-
>
mName
|
|
!
aKey
)
{
return
false
;
}
return
strcmp
(
pref
-
>
mName
key
)
=
=
0
;
}
static
void
ClearEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
{
auto
pref
=
static_cast
<
Pref
*
>
(
aEntry
)
;
pref
-
>
~
Pref
(
)
;
memset
(
pref
0
sizeof
(
Pref
)
)
;
}
nsresult
GetBoolValue
(
PrefValueKind
aKind
bool
*
aResult
)
{
if
(
!
IsTypeBool
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
aKind
=
=
PrefValueKind
:
:
Default
|
|
IsLocked
(
)
|
|
!
mHasUserValue
)
{
if
(
!
mHasDefaultValue
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
aResult
=
mDefaultValue
.
mBoolVal
;
}
else
{
*
aResult
=
mUserValue
.
mBoolVal
;
}
return
NS_OK
;
}
nsresult
GetIntValue
(
PrefValueKind
aKind
int32_t
*
aResult
)
{
if
(
!
IsTypeInt
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
aKind
=
=
PrefValueKind
:
:
Default
|
|
IsLocked
(
)
|
|
!
mHasUserValue
)
{
if
(
!
mHasDefaultValue
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
aResult
=
mDefaultValue
.
mIntVal
;
}
else
{
*
aResult
=
mUserValue
.
mIntVal
;
}
return
NS_OK
;
}
nsresult
GetCStringValue
(
PrefValueKind
aKind
nsACString
&
aResult
)
{
if
(
!
IsTypeString
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
aKind
=
=
PrefValueKind
:
:
Default
|
|
IsLocked
(
)
|
|
!
mHasUserValue
)
{
if
(
!
mHasDefaultValue
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
mDefaultValue
.
mStringVal
)
;
aResult
=
mDefaultValue
.
mStringVal
;
}
else
{
MOZ_ASSERT
(
mUserValue
.
mStringVal
)
;
aResult
=
mUserValue
.
mStringVal
;
}
return
NS_OK
;
}
void
ToDomPref
(
dom
:
:
Pref
*
aDomPref
)
{
aDomPref
-
>
name
(
)
=
mName
;
aDomPref
-
>
isLocked
(
)
=
mIsLocked
;
if
(
mHasDefaultValue
)
{
aDomPref
-
>
defaultValue
(
)
=
dom
:
:
PrefValue
(
)
;
mDefaultValue
.
ToDomPrefValue
(
Type
(
)
&
aDomPref
-
>
defaultValue
(
)
.
get_PrefValue
(
)
)
;
}
else
{
aDomPref
-
>
defaultValue
(
)
=
null_t
(
)
;
}
if
(
mHasUserValue
)
{
aDomPref
-
>
userValue
(
)
=
dom
:
:
PrefValue
(
)
;
mUserValue
.
ToDomPrefValue
(
Type
(
)
&
aDomPref
-
>
userValue
(
)
.
get_PrefValue
(
)
)
;
}
else
{
aDomPref
-
>
userValue
(
)
=
null_t
(
)
;
}
MOZ_ASSERT
(
aDomPref
-
>
defaultValue
(
)
.
type
(
)
=
=
dom
:
:
MaybePrefValue
:
:
Tnull_t
|
|
aDomPref
-
>
userValue
(
)
.
type
(
)
=
=
dom
:
:
MaybePrefValue
:
:
Tnull_t
|
|
(
aDomPref
-
>
defaultValue
(
)
.
get_PrefValue
(
)
.
type
(
)
=
=
aDomPref
-
>
userValue
(
)
.
get_PrefValue
(
)
.
type
(
)
)
)
;
}
void
FromDomPref
(
const
dom
:
:
Pref
&
aDomPref
bool
*
aValueChanged
)
{
MOZ_ASSERT
(
strcmp
(
mName
aDomPref
.
name
(
)
.
get
(
)
)
=
=
0
)
;
mIsLocked
=
aDomPref
.
isLocked
(
)
;
const
dom
:
:
MaybePrefValue
&
defaultValue
=
aDomPref
.
defaultValue
(
)
;
bool
defaultValueChanged
=
false
;
if
(
defaultValue
.
type
(
)
=
=
dom
:
:
MaybePrefValue
:
:
TPrefValue
)
{
PrefValue
value
;
PrefType
type
=
value
.
FromDomPrefValue
(
defaultValue
.
get_PrefValue
(
)
)
;
if
(
!
ValueMatches
(
PrefValueKind
:
:
Default
type
value
)
)
{
mDefaultValue
.
Replace
(
Type
(
)
type
value
)
;
SetType
(
type
)
;
mHasDefaultValue
=
true
;
defaultValueChanged
=
true
;
}
}
const
dom
:
:
MaybePrefValue
&
userValue
=
aDomPref
.
userValue
(
)
;
bool
userValueChanged
=
false
;
if
(
userValue
.
type
(
)
=
=
dom
:
:
MaybePrefValue
:
:
TPrefValue
)
{
PrefValue
value
;
PrefType
type
=
value
.
FromDomPrefValue
(
userValue
.
get_PrefValue
(
)
)
;
if
(
!
ValueMatches
(
PrefValueKind
:
:
User
type
value
)
)
{
mUserValue
.
Replace
(
Type
(
)
type
value
)
;
SetType
(
type
)
;
mHasUserValue
=
true
;
userValueChanged
=
true
;
}
}
else
if
(
mHasUserValue
)
{
ClearUserValue
(
)
;
userValueChanged
=
true
;
}
if
(
userValueChanged
|
|
(
defaultValueChanged
&
&
!
mHasUserValue
)
)
{
*
aValueChanged
=
true
;
}
}
bool
HasAdvisablySizedValues
(
)
{
if
(
!
IsTypeString
(
)
)
{
return
true
;
}
const
char
*
stringVal
;
if
(
mHasDefaultValue
)
{
stringVal
=
mDefaultValue
.
mStringVal
;
if
(
strlen
(
stringVal
)
>
MAX_ADVISABLE_PREF_LENGTH
)
{
return
false
;
}
}
if
(
mHasUserValue
)
{
stringVal
=
mUserValue
.
mStringVal
;
if
(
strlen
(
stringVal
)
>
MAX_ADVISABLE_PREF_LENGTH
)
{
return
false
;
}
}
return
true
;
}
private
:
bool
ValueMatches
(
PrefValueKind
aKind
PrefType
aType
PrefValue
aValue
)
{
return
IsType
(
aType
)
&
&
(
aKind
=
=
PrefValueKind
:
:
Default
?
mHasDefaultValue
&
&
mDefaultValue
.
Equals
(
aType
aValue
)
:
mHasUserValue
&
&
mUserValue
.
Equals
(
aType
aValue
)
)
;
}
public
:
void
ClearUserValue
(
)
{
if
(
Type
(
)
=
=
PrefType
:
:
String
)
{
free
(
const_cast
<
char
*
>
(
mUserValue
.
mStringVal
)
)
;
mUserValue
.
mStringVal
=
nullptr
;
}
mHasUserValue
=
false
;
}
nsresult
SetDefaultValue
(
PrefType
aType
PrefValue
aValue
bool
aIsSticky
bool
*
aValueChanged
)
{
if
(
!
IsType
(
aType
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
IsLocked
(
)
&
&
!
ValueMatches
(
PrefValueKind
:
:
Default
aType
aValue
)
)
{
mDefaultValue
.
Replace
(
Type
(
)
aType
aValue
)
;
mHasDefaultValue
=
true
;
if
(
aIsSticky
)
{
mIsSticky
=
true
;
}
if
(
!
mHasUserValue
)
{
*
aValueChanged
=
true
;
}
}
return
NS_OK
;
}
nsresult
SetUserValue
(
PrefType
aType
PrefValue
aValue
bool
aFromFile
bool
*
aValueChanged
)
{
if
(
mHasDefaultValue
&
&
!
IsType
(
aType
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
ValueMatches
(
PrefValueKind
:
:
Default
aType
aValue
)
&
&
!
mIsSticky
&
&
!
aFromFile
)
{
if
(
mHasUserValue
)
{
ClearUserValue
(
)
;
if
(
!
IsLocked
(
)
)
{
*
aValueChanged
=
true
;
}
}
}
else
if
(
!
ValueMatches
(
PrefValueKind
:
:
User
aType
aValue
)
)
{
mUserValue
.
Replace
(
Type
(
)
aType
aValue
)
;
SetType
(
aType
)
;
mHasUserValue
=
true
;
if
(
!
IsLocked
(
)
)
{
*
aValueChanged
=
true
;
}
}
return
NS_OK
;
}
bool
UserValueToStringForSaving
(
nsCString
&
aStr
)
{
if
(
mHasUserValue
&
&
(
!
ValueMatches
(
PrefValueKind
:
:
Default
Type
(
)
mUserValue
)
|
|
mIsSticky
)
)
{
if
(
IsTypeString
(
)
)
{
StrEscape
(
mUserValue
.
mStringVal
aStr
)
;
}
else
if
(
IsTypeInt
(
)
)
{
aStr
.
AppendInt
(
mUserValue
.
mIntVal
)
;
}
else
if
(
IsTypeBool
(
)
)
{
aStr
=
mUserValue
.
mBoolVal
?
"
true
"
:
"
false
"
;
}
return
true
;
}
return
false
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
0
;
if
(
IsTypeString
(
)
)
{
if
(
mHasDefaultValue
)
{
n
+
=
aMallocSizeOf
(
mDefaultValue
.
mStringVal
)
;
}
if
(
mHasUserValue
)
{
n
+
=
aMallocSizeOf
(
mUserValue
.
mStringVal
)
;
}
}
return
n
;
}
private
:
uint32_t
mType
:
2
;
uint32_t
mIsSticky
:
1
;
uint32_t
mIsLocked
:
1
;
uint32_t
mHasUserValue
:
1
;
uint32_t
mHasDefaultValue
:
1
;
const
char
*
mName
;
PrefValue
mDefaultValue
;
PrefValue
mUserValue
;
}
;
struct
CallbackNode
{
CallbackNode
(
const
char
*
aDomain
PrefChangedFunc
aFunc
void
*
aData
Preferences
:
:
MatchKind
aMatchKind
)
:
mDomain
(
moz_xstrdup
(
aDomain
)
)
mFunc
(
aFunc
)
mData
(
aData
)
mMatchKind
(
aMatchKind
)
mNext
(
nullptr
)
{
}
UniqueFreePtr
<
const
char
>
mDomain
;
PrefChangedFunc
mFunc
;
void
*
mData
;
Preferences
:
:
MatchKind
mMatchKind
;
CallbackNode
*
mNext
;
}
;
static
PLDHashTable
*
gHashTable
;
static
CallbackNode
*
gFirstCallback
=
nullptr
;
static
CallbackNode
*
gLastPriorityNode
=
nullptr
;
static
bool
gIsAnyPrefLocked
=
false
;
static
bool
gCallbacksInProgress
=
false
;
static
bool
gShouldCleanupDeadNodes
=
false
;
static
PLDHashTableOps
pref_HashTableOps
=
{
PLDHashTable
:
:
HashStringKey
Pref
:
:
MatchEntry
PLDHashTable
:
:
MoveEntryStub
Pref
:
:
ClearEntry
nullptr
}
;
static
Pref
*
pref_HashTableLookup
(
const
char
*
aPrefName
)
;
static
void
NotifyCallbacks
(
const
char
*
aPrefName
)
;
#
define
PREF_HASHTABLE_INITIAL_LENGTH
1024
static
PrefSaveData
pref_savePrefs
(
)
{
PrefSaveData
savedPrefs
(
gHashTable
-
>
EntryCount
(
)
)
;
for
(
auto
iter
=
gHashTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
pref
=
static_cast
<
Pref
*
>
(
iter
.
Get
(
)
)
;
nsAutoCString
prefValueStr
;
if
(
!
pref
-
>
UserValueToStringForSaving
(
prefValueStr
)
)
{
continue
;
}
nsAutoCString
prefNameStr
;
StrEscape
(
pref
-
>
Name
(
)
prefNameStr
)
;
nsPrintfCString
str
(
"
user_pref
(
%
s
%
s
)
;
"
prefNameStr
.
get
(
)
prefValueStr
.
get
(
)
)
;
savedPrefs
.
AppendElement
(
str
)
;
}
return
savedPrefs
;
}
#
ifdef
DEBUG
enum
class
ContentProcessPhase
{
eNoPrefsSet
eEarlyPrefsSet
eEarlyAndLatePrefsSet
}
;
static
ContentProcessPhase
gPhase
=
ContentProcessPhase
:
:
eNoPrefsSet
;
struct
StringComparator
{
const
char
*
mPrefName
;
explicit
StringComparator
(
const
char
*
aPrefName
)
:
mPrefName
(
aPrefName
)
{
}
int
operator
(
)
(
const
char
*
aPrefName
)
const
{
return
strcmp
(
mPrefName
aPrefName
)
;
}
}
;
static
bool
IsEarlyPref
(
const
char
*
aPrefName
)
{
size_t
prefsLen
;
size_t
found
;
const
char
*
*
list
=
mozilla
:
:
dom
:
:
ContentPrefs
:
:
GetEarlyPrefs
(
&
prefsLen
)
;
return
BinarySearchIf
(
list
0
prefsLen
StringComparator
(
aPrefName
)
&
found
)
;
}
#
endif
static
Pref
*
pref_HashTableLookup
(
const
char
*
aPrefName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
|
|
mozilla
:
:
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
#
ifdef
DEBUG
if
(
!
XRE_IsParentProcess
(
)
)
{
if
(
gPhase
=
=
ContentProcessPhase
:
:
eNoPrefsSet
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
accessing
pref
%
s
before
early
prefs
are
set
"
aPrefName
)
;
}
if
(
gPhase
=
=
ContentProcessPhase
:
:
eEarlyPrefsSet
&
&
!
IsEarlyPref
(
aPrefName
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
accessing
non
-
early
pref
%
s
before
late
prefs
are
set
"
aPrefName
)
;
}
}
#
endif
return
static_cast
<
Pref
*
>
(
gHashTable
-
>
Search
(
aPrefName
)
)
;
}
static
nsresult
pref_SetPref
(
const
char
*
aPrefName
PrefType
aType
PrefValueKind
aKind
PrefValue
aValue
bool
aIsSticky
bool
aFromFile
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gHashTable
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
auto
pref
=
static_cast
<
Pref
*
>
(
gHashTable
-
>
Add
(
aPrefName
fallible
)
)
;
if
(
!
pref
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
!
pref
-
>
Name
(
)
)
{
new
(
pref
)
Pref
(
aPrefName
)
;
pref
-
>
SetType
(
aType
)
;
}
bool
valueChanged
=
false
;
nsresult
rv
;
if
(
aKind
=
=
PrefValueKind
:
:
Default
)
{
rv
=
pref
-
>
SetDefaultValue
(
aType
aValue
aIsSticky
&
valueChanged
)
;
}
else
{
rv
=
pref
-
>
SetUserValue
(
aType
aValue
aFromFile
&
valueChanged
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
Rejected
attempt
to
change
type
of
pref
%
s
'
s
%
s
value
from
%
s
to
%
s
"
aPrefName
(
aKind
=
=
PrefValueKind
:
:
Default
)
?
"
default
"
:
"
user
"
PrefTypeToString
(
pref
-
>
Type
(
)
)
PrefTypeToString
(
aType
)
)
.
get
(
)
)
;
return
rv
;
}
if
(
valueChanged
)
{
if
(
aKind
=
=
PrefValueKind
:
:
User
&
&
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
HandleDirty
(
)
;
}
NotifyCallbacks
(
aPrefName
)
;
}
return
NS_OK
;
}
static
CallbackNode
*
pref_RemoveCallbackNode
(
CallbackNode
*
aNode
CallbackNode
*
aPrevNode
)
{
NS_PRECONDITION
(
!
aPrevNode
|
|
aPrevNode
-
>
mNext
=
=
aNode
"
invalid
params
"
)
;
NS_PRECONDITION
(
aPrevNode
|
|
gFirstCallback
=
=
aNode
"
invalid
params
"
)
;
NS_ASSERTION
(
!
gCallbacksInProgress
"
modifying
the
callback
list
while
gCallbacksInProgress
is
true
"
)
;
CallbackNode
*
next_node
=
aNode
-
>
mNext
;
if
(
aPrevNode
)
{
aPrevNode
-
>
mNext
=
next_node
;
}
else
{
gFirstCallback
=
next_node
;
}
if
(
gLastPriorityNode
=
=
aNode
)
{
gLastPriorityNode
=
aPrevNode
;
}
delete
aNode
;
return
next_node
;
}
static
void
NotifyCallbacks
(
const
char
*
aPrefName
)
{
bool
reentered
=
gCallbacksInProgress
;
gCallbacksInProgress
=
true
;
for
(
CallbackNode
*
node
=
gFirstCallback
;
node
;
node
=
node
-
>
mNext
)
{
if
(
node
-
>
mFunc
)
{
bool
matches
=
node
-
>
mMatchKind
=
=
Preferences
:
:
ExactMatch
?
strcmp
(
node
-
>
mDomain
.
get
(
)
aPrefName
)
=
=
0
:
strncmp
(
node
-
>
mDomain
.
get
(
)
aPrefName
strlen
(
node
-
>
mDomain
.
get
(
)
)
)
=
=
0
;
if
(
matches
)
{
(
node
-
>
mFunc
)
(
aPrefName
node
-
>
mData
)
;
}
}
}
gCallbacksInProgress
=
reentered
;
if
(
gShouldCleanupDeadNodes
&
&
!
gCallbacksInProgress
)
{
CallbackNode
*
prev_node
=
nullptr
;
CallbackNode
*
node
=
gFirstCallback
;
while
(
node
)
{
if
(
!
node
-
>
mFunc
)
{
node
=
pref_RemoveCallbackNode
(
node
prev_node
)
;
}
else
{
prev_node
=
node
;
node
=
node
-
>
mNext
;
}
}
gShouldCleanupDeadNodes
=
false
;
}
}
struct
TelemetryLoadData
{
uint32_t
mFileLoadSize_B
;
uint32_t
mFileLoadNumPrefs
;
uint32_t
mFileLoadTime_us
;
}
;
static
nsDataHashtable
<
nsCStringHashKey
TelemetryLoadData
>
*
gTelemetryLoadData
;
extern
"
C
"
{
typedef
void
(
*
PrefsParserPrefFn
)
(
const
char
*
aPrefName
PrefType
aType
PrefValueKind
aKind
PrefValue
aValue
bool
aIsSticky
)
;
typedef
void
(
*
PrefsParserErrorFn
)
(
const
char
*
aMsg
)
;
bool
prefs_parser_parse
(
const
char
*
aPath
const
char
*
aBuf
size_t
aLen
PrefsParserPrefFn
aPrefFn
PrefsParserErrorFn
aErrorFn
)
;
}
class
Parser
{
public
:
Parser
(
)
=
default
;
~
Parser
(
)
=
default
;
bool
Parse
(
const
nsCString
&
aName
const
char
*
aPath
const
TimeStamp
&
aStartTime
const
nsCString
&
aBuf
)
{
sNumPrefs
=
0
;
bool
ok
=
prefs_parser_parse
(
aPath
aBuf
.
get
(
)
aBuf
.
Length
(
)
HandlePref
HandleError
)
;
if
(
!
ok
)
{
return
false
;
}
uint32_t
loadTime_us
=
(
TimeStamp
:
:
Now
(
)
-
aStartTime
)
.
ToMicroseconds
(
)
;
TelemetryLoadData
loadData
=
{
uint32_t
(
aBuf
.
Length
(
)
)
sNumPrefs
loadTime_us
}
;
gTelemetryLoadData
-
>
Put
(
aName
loadData
)
;
return
true
;
}
private
:
static
void
HandlePref
(
const
char
*
aPrefName
PrefType
aType
PrefValueKind
aKind
PrefValue
aValue
bool
aIsSticky
)
{
sNumPrefs
+
+
;
pref_SetPref
(
aPrefName
aType
aKind
aValue
aIsSticky
true
)
;
}
static
void
HandleError
(
const
char
*
aMsg
)
{
nsresult
rv
;
nsCOMPtr
<
nsIConsoleService
>
console
=
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
console
-
>
LogStringMessage
(
NS_ConvertUTF8toUTF16
(
aMsg
)
.
get
(
)
)
;
}
else
{
printf_stderr
(
"
%
s
\
n
"
aMsg
)
;
}
NS_WARNING
(
aMsg
)
;
}
static
uint32_t
sNumPrefs
;
}
;
uint32_t
Parser
:
:
sNumPrefs
=
0
;
static
void
TestParseErrorHandlePref
(
const
char
*
aPrefName
PrefType
aType
PrefValueKind
aKind
PrefValue
aValue
bool
aIsSticky
)
{
}
static
char
*
gTestParseErrorMsg
;
static
void
TestParseErrorHandleError
(
const
char
*
aMsg
)
{
gTestParseErrorMsg
=
moz_xstrdup
(
aMsg
)
;
}
void
TestParseError
(
const
char
*
aText
nsCString
&
aErrorMsg
)
{
prefs_parser_parse
(
"
test
"
aText
strlen
(
aText
)
TestParseErrorHandlePref
TestParseErrorHandleError
)
;
aErrorMsg
.
Assign
(
gTestParseErrorMsg
)
;
free
(
gTestParseErrorMsg
)
;
gTestParseErrorMsg
=
nullptr
;
}
void
SendTelemetryLoadData
(
)
{
for
(
auto
iter
=
gTelemetryLoadData
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsCString
&
filename
=
PromiseFlatCString
(
iter
.
Key
(
)
)
;
const
TelemetryLoadData
&
data
=
iter
.
Data
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
PREFERENCES_FILE_LOAD_SIZE_B
filename
data
.
mFileLoadSize_B
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
PREFERENCES_FILE_LOAD_NUM_PREFS
filename
data
.
mFileLoadNumPrefs
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
PREFERENCES_FILE_LOAD_TIME_US
filename
data
.
mFileLoadTime_us
)
;
}
gTelemetryLoadData
-
>
Clear
(
)
;
}
namespace
mozilla
{
class
PreferenceServiceReporter
;
}
class
PrefCallback
:
public
PLDHashEntryHdr
{
friend
class
mozilla
:
:
PreferenceServiceReporter
;
public
:
typedef
PrefCallback
*
KeyType
;
typedef
const
PrefCallback
*
KeyTypePointer
;
static
const
PrefCallback
*
KeyToPointer
(
PrefCallback
*
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
const
PrefCallback
*
aKey
)
{
uint32_t
hash
=
mozilla
:
:
HashString
(
aKey
-
>
mDomain
)
;
return
mozilla
:
:
AddToHash
(
hash
aKey
-
>
mCanonical
)
;
}
public
:
PrefCallback
(
const
char
*
aDomain
nsIObserver
*
aObserver
nsPrefBranch
*
aBranch
)
:
mDomain
(
aDomain
)
mBranch
(
aBranch
)
mWeakRef
(
nullptr
)
mStrongRef
(
aObserver
)
{
MOZ_COUNT_CTOR
(
PrefCallback
)
;
nsCOMPtr
<
nsISupports
>
canonical
=
do_QueryInterface
(
aObserver
)
;
mCanonical
=
canonical
;
}
PrefCallback
(
const
char
*
aDomain
nsISupportsWeakReference
*
aObserver
nsPrefBranch
*
aBranch
)
:
mDomain
(
aDomain
)
mBranch
(
aBranch
)
mWeakRef
(
do_GetWeakReference
(
aObserver
)
)
mStrongRef
(
nullptr
)
{
MOZ_COUNT_CTOR
(
PrefCallback
)
;
nsCOMPtr
<
nsISupports
>
canonical
=
do_QueryInterface
(
aObserver
)
;
mCanonical
=
canonical
;
}
explicit
PrefCallback
(
const
PrefCallback
*
&
aCopy
)
:
mDomain
(
aCopy
-
>
mDomain
)
mBranch
(
aCopy
-
>
mBranch
)
mWeakRef
(
aCopy
-
>
mWeakRef
)
mStrongRef
(
aCopy
-
>
mStrongRef
)
mCanonical
(
aCopy
-
>
mCanonical
)
{
MOZ_COUNT_CTOR
(
PrefCallback
)
;
}
~
PrefCallback
(
)
{
MOZ_COUNT_DTOR
(
PrefCallback
)
;
}
bool
KeyEquals
(
const
PrefCallback
*
aKey
)
const
{
if
(
IsExpired
(
)
|
|
aKey
-
>
IsExpired
(
)
)
{
return
this
=
=
aKey
;
}
if
(
mCanonical
!
=
aKey
-
>
mCanonical
)
{
return
false
;
}
return
mDomain
.
Equals
(
aKey
-
>
mDomain
)
;
}
PrefCallback
*
GetKey
(
)
const
{
return
const_cast
<
PrefCallback
*
>
(
this
)
;
}
already_AddRefed
<
nsIObserver
>
GetObserver
(
)
const
{
if
(
!
IsWeak
(
)
)
{
nsCOMPtr
<
nsIObserver
>
copy
=
mStrongRef
;
return
copy
.
forget
(
)
;
}
nsCOMPtr
<
nsIObserver
>
observer
=
do_QueryReferent
(
mWeakRef
)
;
return
observer
.
forget
(
)
;
}
const
nsCString
&
GetDomain
(
)
const
{
return
mDomain
;
}
nsPrefBranch
*
GetPrefBranch
(
)
const
{
return
mBranch
;
}
bool
IsExpired
(
)
const
{
if
(
!
IsWeak
(
)
)
return
false
;
nsCOMPtr
<
nsIObserver
>
observer
(
do_QueryReferent
(
mWeakRef
)
)
;
return
!
observer
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mDomain
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
return
n
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
nsCString
mDomain
;
nsPrefBranch
*
mBranch
;
nsWeakPtr
mWeakRef
;
nsCOMPtr
<
nsIObserver
>
mStrongRef
;
nsISupports
*
mCanonical
;
bool
IsWeak
(
)
const
{
return
!
!
mWeakRef
;
}
}
;
class
nsPrefBranch
final
:
public
nsIPrefBranch
public
nsIObserver
public
nsSupportsWeakReference
{
friend
class
mozilla
:
:
PreferenceServiceReporter
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPREFBRANCH
NS_DECL_NSIOBSERVER
nsPrefBranch
(
const
char
*
aPrefRoot
PrefValueKind
aKind
)
;
nsPrefBranch
(
)
=
delete
;
static
void
NotifyObserver
(
const
char
*
aNewpref
void
*
aData
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
typedef
mozilla
:
:
Variant
<
const
char
*
const
nsCString
>
PrefNameBase
;
class
PrefName
:
public
PrefNameBase
{
public
:
explicit
PrefName
(
const
char
*
aName
)
:
PrefNameBase
(
aName
)
{
}
explicit
PrefName
(
const
nsCString
&
aName
)
:
PrefNameBase
(
aName
)
{
}
PrefName
(
PrefName
&
&
aOther
)
=
default
;
PrefName
&
operator
=
(
PrefName
&
&
aOther
)
=
default
;
PrefName
(
const
PrefName
&
)
=
delete
;
PrefName
&
operator
=
(
const
PrefName
&
)
=
delete
;
struct
PtrMatcher
{
static
const
char
*
match
(
const
char
*
aVal
)
{
return
aVal
;
}
static
const
char
*
match
(
const
nsCString
&
aVal
)
{
return
aVal
.
get
(
)
;
}
}
;
struct
LenMatcher
{
static
size_t
match
(
const
char
*
aVal
)
{
return
strlen
(
aVal
)
;
}
static
size_t
match
(
const
nsCString
&
aVal
)
{
return
aVal
.
Length
(
)
;
}
}
;
const
char
*
get
(
)
const
{
static
PtrMatcher
m
;
return
match
(
m
)
;
}
size_t
Length
(
)
const
{
static
LenMatcher
m
;
return
match
(
m
)
;
}
}
;
virtual
~
nsPrefBranch
(
)
;
int32_t
GetRootLength
(
)
const
{
return
mPrefRoot
.
Length
(
)
;
}
nsresult
GetDefaultFromPropertiesFile
(
const
char
*
aPrefName
nsAString
&
aReturn
)
;
nsresult
SetCharPrefNoLengthCheck
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
;
nsresult
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
nsAString
&
aValue
)
;
nsresult
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
;
nsresult
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
uint32_t
aLength
)
;
void
RemoveExpiredCallback
(
PrefCallback
*
aCallback
)
;
PrefName
GetPrefName
(
const
char
*
aPrefName
)
const
;
void
FreeObserverList
(
void
)
;
const
nsCString
mPrefRoot
;
PrefValueKind
mKind
;
bool
mFreeingObserverList
;
nsClassHashtable
<
PrefCallback
PrefCallback
>
mObservers
;
}
;
class
nsPrefLocalizedString
final
:
public
nsIPrefLocalizedString
{
public
:
nsPrefLocalizedString
(
)
;
NS_DECL_ISUPPORTS
NS_FORWARD_NSISUPPORTSPRIMITIVE
(
mUnicodeString
-
>
)
NS_FORWARD_NSISUPPORTSSTRING
(
mUnicodeString
-
>
)
nsresult
Init
(
)
;
private
:
virtual
~
nsPrefLocalizedString
(
)
;
nsCOMPtr
<
nsISupportsString
>
mUnicodeString
;
}
;
class
nsRelativeFilePref
:
public
nsIRelativeFilePref
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIRELATIVEFILEPREF
nsRelativeFilePref
(
)
;
private
:
virtual
~
nsRelativeFilePref
(
)
;
nsCOMPtr
<
nsIFile
>
mFile
;
nsCString
mRelativeToKey
;
}
;
nsPrefBranch
:
:
nsPrefBranch
(
const
char
*
aPrefRoot
PrefValueKind
aKind
)
:
mPrefRoot
(
aPrefRoot
)
mKind
(
aKind
)
mFreeingObserverList
(
false
)
mObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
+
+
mRefCnt
;
observerService
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
true
)
;
-
-
mRefCnt
;
}
}
nsPrefBranch
:
:
~
nsPrefBranch
(
)
{
FreeObserverList
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
}
}
NS_IMPL_ADDREF
(
nsPrefBranch
)
NS_IMPL_RELEASE
(
nsPrefBranch
)
NS_INTERFACE_MAP_BEGIN
(
nsPrefBranch
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIPrefBranch
)
NS_INTERFACE_MAP_ENTRY
(
nsIPrefBranch
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END
NS_IMETHODIMP
nsPrefBranch
:
:
GetRoot
(
nsACString
&
aRoot
)
{
aRoot
=
mPrefRoot
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetPrefType
(
const
char
*
aPrefName
int32_t
*
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
prefName
=
GetPrefName
(
aPrefName
)
;
Pref
*
pref
;
if
(
gHashTable
&
&
(
pref
=
pref_HashTableLookup
(
prefName
.
get
(
)
)
)
)
{
switch
(
pref
-
>
Type
(
)
)
{
case
PrefType
:
:
String
:
*
aRetVal
=
PREF_STRING
;
break
;
case
PrefType
:
:
Int
:
*
aRetVal
=
PREF_INT
;
break
;
case
PrefType
:
:
Bool
:
*
aRetVal
=
PREF_BOOL
;
break
;
default
:
MOZ_CRASH
(
)
;
}
}
else
{
*
aRetVal
=
PREF_INVALID
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetBoolPrefWithDefault
(
const
char
*
aPrefName
bool
aDefaultValue
uint8_t
aArgc
bool
*
aRetVal
)
{
nsresult
rv
=
GetBoolPref
(
aPrefName
aRetVal
)
;
if
(
NS_FAILED
(
rv
)
&
&
aArgc
=
=
1
)
{
*
aRetVal
=
aDefaultValue
;
return
NS_OK
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetBoolPref
(
const
char
*
aPrefName
bool
*
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
GetBool
(
pref
.
get
(
)
aRetVal
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
SetBoolPref
(
const
char
*
aPrefName
bool
aValue
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
SetBool
(
pref
.
get
(
)
aValue
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetFloatPrefWithDefault
(
const
char
*
aPrefName
float
aDefaultValue
uint8_t
aArgc
float
*
aRetVal
)
{
nsresult
rv
=
GetFloatPref
(
aPrefName
aRetVal
)
;
if
(
NS_FAILED
(
rv
)
&
&
aArgc
=
=
1
)
{
*
aRetVal
=
aDefaultValue
;
return
NS_OK
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetFloatPref
(
const
char
*
aPrefName
float
*
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
nsAutoCString
stringVal
;
nsresult
rv
=
GetCharPref
(
aPrefName
stringVal
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aRetVal
=
stringVal
.
ToFloat
(
&
rv
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetCharPrefWithDefault
(
const
char
*
aPrefName
const
nsACString
&
aDefaultValue
uint8_t
aArgc
nsACString
&
aRetVal
)
{
nsresult
rv
=
GetCharPref
(
aPrefName
aRetVal
)
;
if
(
NS_FAILED
(
rv
)
&
&
aArgc
=
=
1
)
{
aRetVal
=
aDefaultValue
;
return
NS_OK
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetCharPref
(
const
char
*
aPrefName
nsACString
&
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
GetCString
(
pref
.
get
(
)
aRetVal
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
SetCharPref
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
{
nsresult
rv
=
CheckSanityOfStringLength
(
aPrefName
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
SetCharPrefNoLengthCheck
(
aPrefName
aValue
)
;
}
nsresult
nsPrefBranch
:
:
SetCharPrefNoLengthCheck
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
SetCString
(
pref
.
get
(
)
aValue
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetStringPref
(
const
char
*
aPrefName
const
nsACString
&
aDefaultValue
uint8_t
aArgc
nsACString
&
aRetVal
)
{
nsCString
utf8String
;
nsresult
rv
=
GetCharPref
(
aPrefName
utf8String
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aRetVal
=
utf8String
;
return
rv
;
}
if
(
aArgc
=
=
1
)
{
aRetVal
=
aDefaultValue
;
return
NS_OK
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
SetStringPref
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
{
nsresult
rv
=
CheckSanityOfStringLength
(
aPrefName
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
SetCharPrefNoLengthCheck
(
aPrefName
aValue
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetIntPrefWithDefault
(
const
char
*
aPrefName
int32_t
aDefaultValue
uint8_t
aArgc
int32_t
*
aRetVal
)
{
nsresult
rv
=
GetIntPref
(
aPrefName
aRetVal
)
;
if
(
NS_FAILED
(
rv
)
&
&
aArgc
=
=
1
)
{
*
aRetVal
=
aDefaultValue
;
return
NS_OK
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetIntPref
(
const
char
*
aPrefName
int32_t
*
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
GetInt
(
pref
.
get
(
)
aRetVal
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
SetIntPref
(
const
char
*
aPrefName
int32_t
aValue
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
SetInt
(
pref
.
get
(
)
aValue
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetComplexValue
(
const
char
*
aPrefName
const
nsIID
&
aType
void
*
*
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
nsresult
rv
;
nsAutoCString
utf8String
;
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIPrefLocalizedString
)
)
)
{
nsCOMPtr
<
nsIPrefLocalizedString
>
theString
(
do_CreateInstance
(
NS_PREFLOCALIZEDSTRING_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
bool
bNeedDefault
=
false
;
if
(
mKind
=
=
PrefValueKind
:
:
Default
)
{
bNeedDefault
=
true
;
}
else
{
if
(
!
Preferences
:
:
HasUserValue
(
pref
.
get
(
)
)
&
&
!
Preferences
:
:
IsLocked
(
pref
.
get
(
)
)
)
{
bNeedDefault
=
true
;
}
}
if
(
bNeedDefault
)
{
nsAutoString
utf16String
;
rv
=
GetDefaultFromPropertiesFile
(
pref
.
get
(
)
utf16String
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
theString
-
>
SetData
(
utf16String
)
;
}
}
else
{
rv
=
GetCharPref
(
aPrefName
utf8String
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
theString
-
>
SetData
(
NS_ConvertUTF8toUTF16
(
utf8String
)
)
;
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
theString
.
forget
(
reinterpret_cast
<
nsIPrefLocalizedString
*
*
>
(
aRetVal
)
)
;
}
return
rv
;
}
rv
=
GetCharPref
(
aPrefName
utf8String
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIFile
)
)
)
{
ENSURE_PARENT_PROCESS
(
"
GetComplexValue
(
nsIFile
)
"
aPrefName
)
;
nsCOMPtr
<
nsIFile
>
file
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
file
-
>
SetPersistentDescriptor
(
utf8String
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
file
.
forget
(
reinterpret_cast
<
nsIFile
*
*
>
(
aRetVal
)
)
;
return
NS_OK
;
}
}
return
rv
;
}
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIRelativeFilePref
)
)
)
{
ENSURE_PARENT_PROCESS
(
"
GetComplexValue
(
nsIRelativeFilePref
)
"
aPrefName
)
;
nsACString
:
:
const_iterator
keyBegin
strEnd
;
utf8String
.
BeginReading
(
keyBegin
)
;
utf8String
.
EndReading
(
strEnd
)
;
if
(
*
keyBegin
+
+
!
=
'
[
'
)
{
return
NS_ERROR_FAILURE
;
}
nsACString
:
:
const_iterator
keyEnd
(
keyBegin
)
;
if
(
!
FindCharInReadable
(
'
]
'
keyEnd
strEnd
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
key
(
Substring
(
keyBegin
keyEnd
)
)
;
nsCOMPtr
<
nsIFile
>
fromFile
;
nsCOMPtr
<
nsIProperties
>
directoryService
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
directoryService
-
>
Get
(
key
.
get
(
)
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
fromFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
theFile
;
rv
=
NS_NewNativeLocalFile
(
EmptyCString
(
)
true
getter_AddRefs
(
theFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
theFile
-
>
SetRelativeDescriptor
(
fromFile
Substring
(
+
+
keyEnd
strEnd
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIRelativeFilePref
>
relativePref
;
rv
=
NS_NewRelativeFilePref
(
theFile
key
getter_AddRefs
(
relativePref
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
relativePref
.
forget
(
reinterpret_cast
<
nsIRelativeFilePref
*
*
>
(
aRetVal
)
)
;
return
NS_OK
;
}
NS_WARNING
(
"
nsPrefBranch
:
:
GetComplexValue
-
Unsupported
interface
type
"
)
;
return
NS_NOINTERFACE
;
}
nsresult
nsPrefBranch
:
:
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
nsAString
&
aValue
)
{
return
CheckSanityOfStringLength
(
aPrefName
aValue
.
Length
(
)
)
;
}
nsresult
nsPrefBranch
:
:
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
{
return
CheckSanityOfStringLength
(
aPrefName
aValue
.
Length
(
)
)
;
}
nsresult
nsPrefBranch
:
:
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
uint32_t
aLength
)
{
if
(
aLength
>
MAX_PREF_LENGTH
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
aLength
<
=
MAX_ADVISABLE_PREF_LENGTH
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIConsoleService
>
console
=
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
message
(
nsPrintfCString
(
"
Warning
:
attempting
to
write
%
d
bytes
to
preference
%
s
.
This
is
bad
"
"
for
general
performance
and
memory
usage
.
Such
an
amount
of
data
"
"
should
rather
be
written
to
an
external
file
.
This
preference
will
"
"
not
be
sent
to
any
content
processes
.
"
aLength
GetPrefName
(
aPrefName
)
.
get
(
)
)
)
;
rv
=
console
-
>
LogStringMessage
(
NS_ConvertUTF8toUTF16
(
message
)
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
SetComplexValue
(
const
char
*
aPrefName
const
nsIID
&
aType
nsISupports
*
aValue
)
{
ENSURE_PARENT_PROCESS
(
"
SetComplexValue
"
aPrefName
)
;
NS_ENSURE_ARG
(
aPrefName
)
;
nsresult
rv
=
NS_NOINTERFACE
;
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIFile
)
)
)
{
nsCOMPtr
<
nsIFile
>
file
=
do_QueryInterface
(
aValue
)
;
if
(
!
file
)
{
return
NS_NOINTERFACE
;
}
nsAutoCString
descriptorString
;
rv
=
file
-
>
GetPersistentDescriptor
(
descriptorString
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
SetCharPrefNoLengthCheck
(
aPrefName
descriptorString
)
;
}
return
rv
;
}
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIRelativeFilePref
)
)
)
{
nsCOMPtr
<
nsIRelativeFilePref
>
relFilePref
=
do_QueryInterface
(
aValue
)
;
if
(
!
relFilePref
)
{
return
NS_NOINTERFACE
;
}
nsCOMPtr
<
nsIFile
>
file
;
relFilePref
-
>
GetFile
(
getter_AddRefs
(
file
)
)
;
if
(
!
file
)
{
return
NS_NOINTERFACE
;
}
nsAutoCString
relativeToKey
;
(
void
)
relFilePref
-
>
GetRelativeToKey
(
relativeToKey
)
;
nsCOMPtr
<
nsIFile
>
relativeToFile
;
nsCOMPtr
<
nsIProperties
>
directoryService
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
directoryService
-
>
Get
(
relativeToKey
.
get
(
)
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
relativeToFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
relDescriptor
;
rv
=
file
-
>
GetRelativeDescriptor
(
relativeToFile
relDescriptor
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
descriptorString
;
descriptorString
.
Append
(
'
[
'
)
;
descriptorString
.
Append
(
relativeToKey
)
;
descriptorString
.
Append
(
'
]
'
)
;
descriptorString
.
Append
(
relDescriptor
)
;
return
SetCharPrefNoLengthCheck
(
aPrefName
descriptorString
)
;
}
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIPrefLocalizedString
)
)
)
{
nsCOMPtr
<
nsISupportsString
>
theString
=
do_QueryInterface
(
aValue
)
;
if
(
theString
)
{
nsString
wideString
;
rv
=
theString
-
>
GetData
(
wideString
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
CheckSanityOfStringLength
(
aPrefName
wideString
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
SetCharPrefNoLengthCheck
(
aPrefName
NS_ConvertUTF16toUTF8
(
wideString
)
)
;
}
}
return
rv
;
}
NS_WARNING
(
"
nsPrefBranch
:
:
SetComplexValue
-
Unsupported
interface
type
"
)
;
return
NS_NOINTERFACE
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
ClearUserPref
(
const
char
*
aPrefName
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
ClearUser
(
pref
.
get
(
)
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
PrefHasUserValue
(
const
char
*
aPrefName
bool
*
aRetVal
)
{
NS_ENSURE_ARG_POINTER
(
aRetVal
)
;
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
*
aRetVal
=
Preferences
:
:
HasUserValue
(
pref
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
LockPref
(
const
char
*
aPrefName
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
Lock
(
pref
.
get
(
)
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
PrefIsLocked
(
const
char
*
aPrefName
bool
*
aRetVal
)
{
NS_ENSURE_ARG_POINTER
(
aRetVal
)
;
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
*
aRetVal
=
Preferences
:
:
IsLocked
(
pref
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
UnlockPref
(
const
char
*
aPrefName
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
Unlock
(
pref
.
get
(
)
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
ResetBranch
(
const
char
*
aStartingAt
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
DeleteBranch
(
const
char
*
aStartingAt
)
{
ENSURE_PARENT_PROCESS
(
"
DeleteBranch
"
aStartingAt
)
;
NS_ENSURE_ARG
(
aStartingAt
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gHashTable
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
const
PrefName
&
pref
=
GetPrefName
(
aStartingAt
)
;
nsAutoCString
branchName
(
pref
.
get
(
)
)
;
if
(
branchName
.
Length
(
)
>
1
&
&
!
StringEndsWith
(
branchName
NS_LITERAL_CSTRING
(
"
.
"
)
)
)
{
branchName
+
=
'
.
'
;
}
const
nsACString
&
branchNameNoDot
=
Substring
(
branchName
0
branchName
.
Length
(
)
-
1
)
;
for
(
auto
iter
=
gHashTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
pref
=
static_cast
<
Pref
*
>
(
iter
.
Get
(
)
)
;
nsDependentCString
name
(
pref
-
>
Name
(
)
)
;
if
(
StringBeginsWith
(
name
branchName
)
|
|
name
.
Equals
(
branchNameNoDot
)
)
{
iter
.
Remove
(
)
;
}
}
Preferences
:
:
HandleDirty
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetChildList
(
const
char
*
aStartingAt
uint32_t
*
aCount
char
*
*
*
aChildArray
)
{
char
*
*
outArray
;
int32_t
numPrefs
;
int32_t
dwIndex
;
AutoTArray
<
nsCString
32
>
prefArray
;
NS_ENSURE_ARG
(
aStartingAt
)
;
NS_ENSURE_ARG_POINTER
(
aCount
)
;
NS_ENSURE_ARG_POINTER
(
aChildArray
)
;
*
aChildArray
=
nullptr
;
*
aCount
=
0
;
const
PrefName
&
parent
=
GetPrefName
(
aStartingAt
)
;
size_t
parentLen
=
parent
.
Length
(
)
;
for
(
auto
iter
=
gHashTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
pref
=
static_cast
<
Pref
*
>
(
iter
.
Get
(
)
)
;
if
(
strncmp
(
pref
-
>
Name
(
)
parent
.
get
(
)
parentLen
)
=
=
0
)
{
prefArray
.
AppendElement
(
pref
-
>
Name
(
)
)
;
}
}
numPrefs
=
prefArray
.
Length
(
)
;
if
(
numPrefs
)
{
outArray
=
(
char
*
*
)
moz_xmalloc
(
numPrefs
*
sizeof
(
char
*
)
)
;
for
(
dwIndex
=
0
;
dwIndex
<
numPrefs
;
+
+
dwIndex
)
{
const
nsCString
&
element
=
prefArray
[
dwIndex
]
;
outArray
[
dwIndex
]
=
(
char
*
)
nsMemory
:
:
Clone
(
element
.
get
(
)
+
mPrefRoot
.
Length
(
)
element
.
Length
(
)
-
mPrefRoot
.
Length
(
)
+
1
)
;
if
(
!
outArray
[
dwIndex
]
)
{
NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY
(
dwIndex
outArray
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
*
aChildArray
=
outArray
;
}
*
aCount
=
numPrefs
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
AddObserver
(
const
char
*
aDomain
nsIObserver
*
aObserver
bool
aHoldWeak
)
{
PrefCallback
*
pCallback
;
NS_ENSURE_ARG
(
aDomain
)
;
NS_ENSURE_ARG
(
aObserver
)
;
if
(
aHoldWeak
)
{
nsCOMPtr
<
nsISupportsWeakReference
>
weakRefFactory
=
do_QueryInterface
(
aObserver
)
;
if
(
!
weakRefFactory
)
{
return
NS_ERROR_INVALID_ARG
;
}
pCallback
=
new
PrefCallback
(
aDomain
weakRefFactory
this
)
;
}
else
{
pCallback
=
new
PrefCallback
(
aDomain
aObserver
this
)
;
}
auto
p
=
mObservers
.
LookupForAdd
(
pCallback
)
;
if
(
p
)
{
NS_WARNING
(
"
Ignoring
duplicate
observer
.
"
)
;
delete
pCallback
;
return
NS_OK
;
}
p
.
OrInsert
(
[
&
pCallback
]
(
)
{
return
pCallback
;
}
)
;
const
PrefName
&
pref
=
GetPrefName
(
aDomain
)
;
Preferences
:
:
RegisterCallback
(
NotifyObserver
pref
.
get
(
)
pCallback
Preferences
:
:
PrefixMatch
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
RemoveObserver
(
const
char
*
aDomain
nsIObserver
*
aObserver
)
{
NS_ENSURE_ARG
(
aDomain
)
;
NS_ENSURE_ARG
(
aObserver
)
;
nsresult
rv
=
NS_OK
;
if
(
mFreeingObserverList
)
{
return
NS_OK
;
}
PrefCallback
key
(
aDomain
aObserver
this
)
;
nsAutoPtr
<
PrefCallback
>
pCallback
;
mObservers
.
Remove
(
&
key
&
pCallback
)
;
if
(
pCallback
)
{
const
PrefName
&
pref
=
GetPrefName
(
aDomain
)
;
rv
=
Preferences
:
:
UnregisterCallback
(
NotifyObserver
pref
.
get
(
)
pCallback
Preferences
:
:
PrefixMatch
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
FreeObserverList
(
)
;
}
return
NS_OK
;
}
void
nsPrefBranch
:
:
NotifyObserver
(
const
char
*
aNewPref
void
*
aData
)
{
PrefCallback
*
pCallback
=
(
PrefCallback
*
)
aData
;
nsCOMPtr
<
nsIObserver
>
observer
=
pCallback
-
>
GetObserver
(
)
;
if
(
!
observer
)
{
pCallback
-
>
GetPrefBranch
(
)
-
>
RemoveExpiredCallback
(
pCallback
)
;
return
;
}
uint32_t
len
=
pCallback
-
>
GetPrefBranch
(
)
-
>
GetRootLength
(
)
;
nsAutoCString
suffix
(
aNewPref
+
len
)
;
observer
-
>
Observe
(
static_cast
<
nsIPrefBranch
*
>
(
pCallback
-
>
GetPrefBranch
(
)
)
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
NS_ConvertASCIItoUTF16
(
suffix
)
.
get
(
)
)
;
}
size_t
nsPrefBranch
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mPrefRoot
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
n
+
=
mObservers
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mObservers
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
PrefCallback
*
data
=
iter
.
UserData
(
)
;
n
+
=
data
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
void
nsPrefBranch
:
:
FreeObserverList
(
)
{
mFreeingObserverList
=
true
;
for
(
auto
iter
=
mObservers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
PrefCallback
>
&
callback
=
iter
.
Data
(
)
;
nsPrefBranch
*
prefBranch
=
callback
-
>
GetPrefBranch
(
)
;
const
PrefName
&
pref
=
prefBranch
-
>
GetPrefName
(
callback
-
>
GetDomain
(
)
.
get
(
)
)
;
Preferences
:
:
UnregisterCallback
(
nsPrefBranch
:
:
NotifyObserver
pref
.
get
(
)
callback
Preferences
:
:
PrefixMatch
)
;
iter
.
Remove
(
)
;
}
mFreeingObserverList
=
false
;
}
void
nsPrefBranch
:
:
RemoveExpiredCallback
(
PrefCallback
*
aCallback
)
{
NS_PRECONDITION
(
aCallback
-
>
IsExpired
(
)
"
Callback
should
be
expired
.
"
)
;
mObservers
.
Remove
(
aCallback
)
;
}
nsresult
nsPrefBranch
:
:
GetDefaultFromPropertiesFile
(
const
char
*
aPrefName
nsAString
&
aReturn
)
{
nsAutoCString
propertyFileURL
;
nsresult
rv
=
Preferences
:
:
GetCString
(
aPrefName
propertyFileURL
PrefValueKind
:
:
Default
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIStringBundleService
>
bundleService
=
mozilla
:
:
services
:
:
GetStringBundleService
(
)
;
if
(
!
bundleService
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIStringBundle
>
bundle
;
rv
=
bundleService
-
>
CreateBundle
(
propertyFileURL
.
get
(
)
getter_AddRefs
(
bundle
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
bundle
-
>
GetStringFromName
(
aPrefName
aReturn
)
;
}
nsPrefBranch
:
:
PrefName
nsPrefBranch
:
:
GetPrefName
(
const
char
*
aPrefName
)
const
{
NS_ASSERTION
(
aPrefName
"
null
pref
name
!
"
)
;
if
(
mPrefRoot
.
IsEmpty
(
)
)
{
return
PrefName
(
aPrefName
)
;
}
return
PrefName
(
mPrefRoot
+
nsDependentCString
(
aPrefName
)
)
;
}
nsPrefLocalizedString
:
:
nsPrefLocalizedString
(
)
=
default
;
nsPrefLocalizedString
:
:
~
nsPrefLocalizedString
(
)
=
default
;
NS_IMPL_ADDREF
(
nsPrefLocalizedString
)
NS_IMPL_RELEASE
(
nsPrefLocalizedString
)
NS_INTERFACE_MAP_BEGIN
(
nsPrefLocalizedString
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIPrefLocalizedString
)
NS_INTERFACE_MAP_ENTRY
(
nsIPrefLocalizedString
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsString
)
NS_INTERFACE_MAP_END
nsresult
nsPrefLocalizedString
:
:
Init
(
)
{
nsresult
rv
;
mUnicodeString
=
do_CreateInstance
(
NS_SUPPORTS_STRING_CONTRACTID
&
rv
)
;
return
rv
;
}
NS_IMPL_ISUPPORTS
(
nsRelativeFilePref
nsIRelativeFilePref
)
nsRelativeFilePref
:
:
nsRelativeFilePref
(
)
=
default
;
nsRelativeFilePref
:
:
~
nsRelativeFilePref
(
)
=
default
;
NS_IMETHODIMP
nsRelativeFilePref
:
:
GetFile
(
nsIFile
*
*
aFile
)
{
NS_ENSURE_ARG_POINTER
(
aFile
)
;
*
aFile
=
mFile
;
NS_IF_ADDREF
(
*
aFile
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsRelativeFilePref
:
:
SetFile
(
nsIFile
*
aFile
)
{
mFile
=
aFile
;
return
NS_OK
;
}
NS_IMETHODIMP
nsRelativeFilePref
:
:
GetRelativeToKey
(
nsACString
&
aRelativeToKey
)
{
aRelativeToKey
.
Assign
(
mRelativeToKey
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsRelativeFilePref
:
:
SetRelativeToKey
(
const
nsACString
&
aRelativeToKey
)
{
mRelativeToKey
.
Assign
(
aRelativeToKey
)
;
return
NS_OK
;
}
namespace
mozilla
{
#
define
INITIAL_PREF_FILES
10
static
NS_DEFINE_CID
(
kZipReaderCID
NS_ZIPREADER_CID
)
;
void
Preferences
:
:
HandleDirty
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
gHashTable
|
|
!
sPreferences
)
{
return
;
}
if
(
sPreferences
-
>
mProfileShutdown
)
{
NS_WARNING
(
"
Setting
user
pref
after
profile
shutdown
.
"
)
;
return
;
}
if
(
!
sPreferences
-
>
mDirty
)
{
sPreferences
-
>
mDirty
=
true
;
if
(
sPreferences
-
>
mCurrentFile
&
&
sPreferences
-
>
AllowOffMainThreadSave
(
)
&
&
!
sPreferences
-
>
mSavePending
)
{
sPreferences
-
>
mSavePending
=
true
;
static
const
int
PREF_DELAY_MS
=
500
;
NS_DelayedDispatchToCurrentThread
(
mozilla
:
:
NewRunnableMethod
(
"
Preferences
:
:
SavePrefFileAsynchronous
"
sPreferences
.
get
(
)
&
Preferences
:
:
SavePrefFileAsynchronous
)
PREF_DELAY_MS
)
;
}
}
}
static
nsresult
openPrefFile
(
nsIFile
*
aFile
)
;
static
const
char
kTelemetryPref
[
]
=
"
toolkit
.
telemetry
.
enabled
"
;
static
const
char
kChannelPref
[
]
=
"
app
.
update
.
channel
"
;
static
const
char
kPrefFileHeader
[
]
=
"
#
Mozilla
User
Preferences
"
NS_LINEBREAK
NS_LINEBREAK
"
/
*
Do
not
edit
this
file
.
"
NS_LINEBREAK
"
*
"
NS_LINEBREAK
"
*
If
you
make
changes
to
this
file
while
the
application
is
running
"
NS_LINEBREAK
"
*
the
changes
will
be
overwritten
when
the
application
exits
.
"
NS_LINEBREAK
"
*
"
NS_LINEBREAK
"
*
To
make
a
manual
change
to
preferences
you
can
visit
the
URL
"
"
about
:
config
"
NS_LINEBREAK
"
*
/
"
NS_LINEBREAK
NS_LINEBREAK
;
StaticRefPtr
<
Preferences
>
Preferences
:
:
sPreferences
;
bool
Preferences
:
:
sShutdown
=
false
;
static
int32_t
sAllowOMTPrefWrite
=
-
1
;
class
PreferencesWriter
final
{
public
:
PreferencesWriter
(
)
=
default
;
static
nsresult
Write
(
nsIFile
*
aFile
PrefSaveData
&
aPrefs
)
{
nsCOMPtr
<
nsIOutputStream
>
outStreamSink
;
nsCOMPtr
<
nsIOutputStream
>
outStream
;
uint32_t
writeAmount
;
nsresult
rv
;
rv
=
NS_NewSafeLocalFileOutputStream
(
getter_AddRefs
(
outStreamSink
)
aFile
-
1
0600
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
NS_NewBufferedOutputStream
(
getter_AddRefs
(
outStream
)
outStreamSink
.
forget
(
)
4096
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
struct
CharComparator
{
bool
LessThan
(
const
nsCString
&
aA
const
nsCString
&
aB
)
const
{
return
aA
<
aB
;
}
bool
Equals
(
const
nsCString
&
aA
const
nsCString
&
aB
)
const
{
return
aA
=
=
aB
;
}
}
;
aPrefs
.
Sort
(
CharComparator
(
)
)
;
outStream
-
>
Write
(
kPrefFileHeader
sizeof
(
kPrefFileHeader
)
-
1
&
writeAmount
)
;
for
(
nsCString
&
pref
:
aPrefs
)
{
outStream
-
>
Write
(
pref
.
get
(
)
pref
.
Length
(
)
&
writeAmount
)
;
outStream
-
>
Write
(
NS_LINEBREAK
NS_LINEBREAK_LEN
&
writeAmount
)
;
}
nsCOMPtr
<
nsISafeOutputStream
>
safeStream
=
do_QueryInterface
(
outStream
)
;
NS_ASSERTION
(
safeStream
"
expected
a
safe
output
stream
!
"
)
;
if
(
safeStream
)
{
rv
=
safeStream
-
>
Finish
(
)
;
}
#
ifdef
DEBUG
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
save
prefs
file
!
possible
data
loss
"
)
;
}
#
endif
return
rv
;
}
static
void
Flush
(
)
{
if
(
!
sPendingWriteData
.
compareExchange
(
nullptr
nullptr
)
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
target
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
Preferences_dummy
"
[
]
{
}
)
nsIEventTarget
:
:
DISPATCH_SYNC
)
;
}
}
}
static
Atomic
<
PrefSaveData
*
>
sPendingWriteData
;
}
;
Atomic
<
PrefSaveData
*
>
PreferencesWriter
:
:
sPendingWriteData
(
nullptr
)
;
class
PWRunnable
:
public
Runnable
{
public
:
explicit
PWRunnable
(
nsIFile
*
aFile
)
:
Runnable
(
"
PWRunnable
"
)
mFile
(
aFile
)
{
}
NS_IMETHOD
Run
(
)
override
{
mozilla
:
:
UniquePtr
<
PrefSaveData
>
prefs
(
PreferencesWriter
:
:
sPendingWriteData
.
exchange
(
nullptr
)
)
;
nsresult
rv
=
NS_OK
;
if
(
prefs
)
{
rv
=
PreferencesWriter
:
:
Write
(
mFile
*
prefs
)
;
nsresult
rvCopy
=
rv
;
nsCOMPtr
<
nsIFile
>
fileCopy
(
mFile
)
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
NS_NewRunnableFunction
(
"
Preferences
:
:
WriterRunnable
"
[
fileCopy
rvCopy
]
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
rvCopy
)
)
{
Preferences
:
:
HandleDirty
(
)
;
}
}
)
)
;
}
return
rv
;
}
protected
:
nsCOMPtr
<
nsIFile
>
mFile
;
}
;
struct
CacheData
{
void
*
mCacheLocation
;
union
{
bool
mDefaultValueBool
;
int32_t
mDefaultValueInt
;
uint32_t
mDefaultValueUint
;
float
mDefaultValueFloat
;
}
;
}
;
static
const
char
*
gCacheDataDesc
=
"
untouched
"
;
static
nsTArray
<
nsAutoPtr
<
CacheData
>
>
*
gCacheData
=
nullptr
;
#
ifdef
DEBUG
static
bool
HaveExistingCacheFor
(
void
*
aPtr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
gCacheData
)
{
for
(
size_t
i
=
0
count
=
gCacheData
-
>
Length
(
)
;
i
<
count
;
+
+
i
)
{
if
(
(
*
gCacheData
)
[
i
]
-
>
mCacheLocation
=
=
aPtr
)
{
return
true
;
}
}
}
return
false
;
}
static
void
AssertNotAlreadyCached
(
const
char
*
aPrefType
const
char
*
aPref
void
*
aPtr
)
{
if
(
HaveExistingCacheFor
(
aPtr
)
)
{
fprintf_stderr
(
stderr
"
Attempt
to
add
a
%
s
pref
cache
for
preference
'
%
s
'
at
address
'
%
p
'
"
"
was
made
.
However
a
pref
was
already
cached
at
this
address
.
\
n
"
aPrefType
aPref
aPtr
)
;
MOZ_ASSERT
(
false
"
Should
not
have
an
existing
pref
cache
for
this
address
"
)
;
}
}
#
endif
struct
PrefsSizes
{
PrefsSizes
(
)
:
mHashTable
(
0
)
mStringValues
(
0
)
mCacheData
(
0
)
mRootBranches
(
0
)
mPrefNameArena
(
0
)
mCallbacks
(
0
)
mMisc
(
0
)
{
}
size_t
mHashTable
;
size_t
mStringValues
;
size_t
mCacheData
;
size_t
mRootBranches
;
size_t
mPrefNameArena
;
size_t
mCallbacks
;
size_t
mMisc
;
}
;
void
Preferences
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
PrefsSizes
&
aSizes
)
{
if
(
!
sPreferences
)
{
return
;
}
aSizes
.
mMisc
+
=
aMallocSizeOf
(
sPreferences
.
get
(
)
)
;
aSizes
.
mRootBranches
+
=
static_cast
<
nsPrefBranch
*
>
(
sPreferences
-
>
mRootBranch
.
get
(
)
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
+
static_cast
<
nsPrefBranch
*
>
(
sPreferences
-
>
mDefaultRootBranch
.
get
(
)
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
class
PreferenceServiceReporter
final
:
public
nsIMemoryReporter
{
~
PreferenceServiceReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
protected
:
static
const
uint32_t
kSuspectReferentCount
=
1000
;
}
;
NS_IMPL_ISUPPORTS
(
PreferenceServiceReporter
nsIMemoryReporter
)
MOZ_DEFINE_MALLOC_SIZE_OF
(
PreferenceServiceMallocSizeOf
)
NS_IMETHODIMP
PreferenceServiceReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MallocSizeOf
mallocSizeOf
=
PreferenceServiceMallocSizeOf
;
PrefsSizes
sizes
;
Preferences
:
:
AddSizeOfIncludingThis
(
mallocSizeOf
sizes
)
;
if
(
gHashTable
)
{
sizes
.
mHashTable
+
=
gHashTable
-
>
ShallowSizeOfIncludingThis
(
mallocSizeOf
)
;
for
(
auto
iter
=
gHashTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
pref
=
static_cast
<
Pref
*
>
(
iter
.
Get
(
)
)
;
sizes
.
mStringValues
+
=
pref
-
>
SizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
if
(
gCacheData
)
{
sizes
.
mCacheData
+
=
gCacheData
-
>
ShallowSizeOfIncludingThis
(
mallocSizeOf
)
;
for
(
uint32_t
i
=
0
count
=
gCacheData
-
>
Length
(
)
;
i
<
count
;
+
+
i
)
{
sizes
.
mCacheData
+
=
mallocSizeOf
(
(
*
gCacheData
)
[
i
]
)
;
}
}
sizes
.
mPrefNameArena
+
=
gPrefNameArena
.
SizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
CallbackNode
*
node
=
gFirstCallback
;
node
;
node
=
node
-
>
mNext
)
{
sizes
.
mCallbacks
+
=
mallocSizeOf
(
node
)
;
sizes
.
mCallbacks
+
=
mallocSizeOf
(
node
-
>
mDomain
.
get
(
)
)
;
}
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
hash
-
table
"
KIND_HEAP
UNITS_BYTES
sizes
.
mHashTable
"
Memory
used
by
libpref
'
s
hash
table
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
string
-
values
"
KIND_HEAP
UNITS_BYTES
sizes
.
mStringValues
"
Memory
used
by
libpref
'
s
string
pref
values
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
cache
-
data
"
KIND_HEAP
UNITS_BYTES
sizes
.
mCacheData
"
Memory
used
by
libpref
'
s
VarCaches
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
root
-
branches
"
KIND_HEAP
UNITS_BYTES
sizes
.
mRootBranches
"
Memory
used
by
libpref
'
s
root
branches
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
pref
-
name
-
arena
"
KIND_HEAP
UNITS_BYTES
sizes
.
mPrefNameArena
"
Memory
used
by
libpref
'
s
arena
for
pref
names
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
callbacks
"
KIND_HEAP
UNITS_BYTES
sizes
.
mCallbacks
"
Memory
used
by
libpref
'
s
callbacks
list
including
"
"
pref
names
and
prefixes
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
misc
"
KIND_HEAP
UNITS_BYTES
sizes
.
mMisc
"
Miscellaneous
memory
used
by
libpref
.
"
)
;
nsPrefBranch
*
rootBranch
=
static_cast
<
nsPrefBranch
*
>
(
Preferences
:
:
GetRootBranch
(
)
)
;
if
(
!
rootBranch
)
{
return
NS_OK
;
}
size_t
numStrong
=
0
;
size_t
numWeakAlive
=
0
;
size_t
numWeakDead
=
0
;
nsTArray
<
nsCString
>
suspectPreferences
;
nsDataHashtable
<
nsCStringHashKey
uint32_t
>
prefCounter
;
for
(
auto
iter
=
rootBranch
-
>
mObservers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
PrefCallback
>
&
callback
=
iter
.
Data
(
)
;
nsPrefBranch
*
prefBranch
=
callback
-
>
GetPrefBranch
(
)
;
const
auto
&
pref
=
prefBranch
-
>
GetPrefName
(
callback
-
>
GetDomain
(
)
.
get
(
)
)
;
if
(
callback
-
>
IsWeak
(
)
)
{
nsCOMPtr
<
nsIObserver
>
callbackRef
=
do_QueryReferent
(
callback
-
>
mWeakRef
)
;
if
(
callbackRef
)
{
numWeakAlive
+
+
;
}
else
{
numWeakDead
+
+
;
}
}
else
{
numStrong
+
+
;
}
nsDependentCString
prefString
(
pref
.
get
(
)
)
;
uint32_t
oldCount
=
0
;
prefCounter
.
Get
(
prefString
&
oldCount
)
;
uint32_t
currentCount
=
oldCount
+
1
;
prefCounter
.
Put
(
prefString
currentCount
)
;
if
(
currentCount
=
=
kSuspectReferentCount
)
{
suspectPreferences
.
AppendElement
(
prefString
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
suspectPreferences
.
Length
(
)
;
i
+
+
)
{
nsCString
&
suspect
=
suspectPreferences
[
i
]
;
uint32_t
totalReferentCount
=
0
;
prefCounter
.
Get
(
suspect
&
totalReferentCount
)
;
nsPrintfCString
suspectPath
(
"
preference
-
service
-
suspect
/
"
"
referent
(
pref
=
%
s
)
"
suspect
.
get
(
)
)
;
aHandleReport
-
>
Callback
(
EmptyCString
(
)
suspectPath
KIND_OTHER
UNITS_COUNT
totalReferentCount
NS_LITERAL_CSTRING
(
"
A
preference
with
a
suspiciously
large
number
referents
(
symptom
of
a
"
"
leak
)
.
"
)
aData
)
;
}
MOZ_COLLECT_REPORT
(
"
preference
-
service
/
referent
/
strong
"
KIND_OTHER
UNITS_COUNT
numStrong
"
The
number
of
strong
referents
held
by
the
preference
service
.
"
)
;
MOZ_COLLECT_REPORT
(
"
preference
-
service
/
referent
/
weak
/
alive
"
KIND_OTHER
UNITS_COUNT
numWeakAlive
"
The
number
of
weak
referents
held
by
the
preference
service
that
are
"
"
still
alive
.
"
)
;
MOZ_COLLECT_REPORT
(
"
preference
-
service
/
referent
/
weak
/
dead
"
KIND_OTHER
UNITS_COUNT
numWeakDead
"
The
number
of
weak
referents
held
by
the
preference
service
that
are
"
"
dead
.
"
)
;
return
NS_OK
;
}
namespace
{
class
AddPreferencesMemoryReporterRunnable
:
public
Runnable
{
public
:
AddPreferencesMemoryReporterRunnable
(
)
:
Runnable
(
"
AddPreferencesMemoryReporterRunnable
"
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
RegisterStrongMemoryReporter
(
new
PreferenceServiceReporter
(
)
)
;
}
}
;
}
static
InfallibleTArray
<
dom
:
:
Pref
>
*
gEarlyDomPrefs
;
already_AddRefed
<
Preferences
>
Preferences
:
:
GetInstanceForService
(
)
{
if
(
sPreferences
)
{
return
do_AddRef
(
sPreferences
)
;
}
if
(
sShutdown
)
{
gCacheDataDesc
=
"
shutting
down
in
GetInstanceForService
(
)
"
;
return
nullptr
;
}
sPreferences
=
new
Preferences
(
)
;
MOZ_ASSERT
(
!
gHashTable
)
;
gHashTable
=
new
PLDHashTable
(
&
pref_HashTableOps
sizeof
(
Pref
)
PREF_HASHTABLE_INITIAL_LENGTH
)
;
gTelemetryLoadData
=
new
nsDataHashtable
<
nsCStringHashKey
TelemetryLoadData
>
(
)
;
Result
<
Ok
const
char
*
>
res
=
InitInitialObjects
(
)
;
if
(
res
.
isErr
(
)
)
{
sPreferences
=
nullptr
;
gCacheDataDesc
=
res
.
unwrapErr
(
)
;
return
nullptr
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
MOZ_ASSERT
(
gEarlyDomPrefs
)
;
for
(
unsigned
int
i
=
0
;
i
<
gEarlyDomPrefs
-
>
Length
(
)
;
i
+
+
)
{
Preferences
:
:
SetPreference
(
gEarlyDomPrefs
-
>
ElementAt
(
i
)
)
;
}
delete
gEarlyDomPrefs
;
gEarlyDomPrefs
=
nullptr
;
}
else
{
nsAutoCString
lockFileName
;
nsresult
rv
=
Preferences
:
:
GetCString
(
"
general
.
config
.
filename
"
lockFileName
PrefValueKind
:
:
User
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_CreateServicesFromCategory
(
"
pref
-
config
-
startup
"
static_cast
<
nsISupports
*
>
(
static_cast
<
void
*
>
(
sPreferences
)
)
"
pref
-
config
-
startup
"
)
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
{
sPreferences
=
nullptr
;
gCacheDataDesc
=
"
GetObserverService
(
)
failed
(
1
)
"
;
return
nullptr
;
}
observerService
-
>
AddObserver
(
sPreferences
"
profile
-
before
-
change
-
telemetry
"
true
)
;
rv
=
observerService
-
>
AddObserver
(
sPreferences
"
profile
-
before
-
change
"
true
)
;
observerService
-
>
AddObserver
(
sPreferences
"
suspend_process_notification
"
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
sPreferences
=
nullptr
;
gCacheDataDesc
=
"
AddObserver
(
\
"
profile
-
before
-
change
\
"
)
failed
"
;
return
nullptr
;
}
}
gCacheData
=
new
nsTArray
<
nsAutoPtr
<
CacheData
>
>
(
)
;
gCacheDataDesc
=
"
set
by
GetInstanceForService
(
)
"
;
RefPtr
<
AddPreferencesMemoryReporterRunnable
>
runnable
=
new
AddPreferencesMemoryReporterRunnable
(
)
;
NS_DispatchToMainThread
(
runnable
)
;
return
do_AddRef
(
sPreferences
)
;
}
bool
Preferences
:
:
IsServiceAvailable
(
)
{
return
!
!
sPreferences
;
}
bool
Preferences
:
:
InitStaticMembers
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
|
|
mozilla
:
:
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
if
(
MOZ_LIKELY
(
sPreferences
)
)
{
return
true
;
}
if
(
!
sShutdown
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIPrefService
>
prefService
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
}
return
sPreferences
!
=
nullptr
;
}
void
Preferences
:
:
Shutdown
(
)
{
if
(
!
sShutdown
)
{
sShutdown
=
true
;
sPreferences
=
nullptr
;
}
}
Preferences
:
:
Preferences
(
)
:
mRootBranch
(
new
nsPrefBranch
(
"
"
PrefValueKind
:
:
User
)
)
mDefaultRootBranch
(
new
nsPrefBranch
(
"
"
PrefValueKind
:
:
Default
)
)
{
}
Preferences
:
:
~
Preferences
(
)
{
MOZ_ASSERT
(
!
sPreferences
)
;
delete
gCacheData
;
gCacheData
=
nullptr
;
NS_ASSERTION
(
!
gCallbacksInProgress
"
~
Preferences
was
called
while
gCallbacksInProgress
is
true
!
"
)
;
CallbackNode
*
node
=
gFirstCallback
;
while
(
node
)
{
CallbackNode
*
next_node
=
node
-
>
mNext
;
delete
node
;
node
=
next_node
;
}
gLastPriorityNode
=
gFirstCallback
=
nullptr
;
delete
gHashTable
;
gHashTable
=
nullptr
;
delete
gTelemetryLoadData
;
gTelemetryLoadData
=
nullptr
;
gPrefNameArena
.
Clear
(
)
;
}
NS_IMPL_ADDREF
(
Preferences
)
NS_IMPL_RELEASE
(
Preferences
)
NS_INTERFACE_MAP_BEGIN
(
Preferences
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIPrefService
)
NS_INTERFACE_MAP_ENTRY
(
nsIPrefService
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIPrefBranch
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END
void
Preferences
:
:
SetEarlyPreferences
(
const
nsTArray
<
dom
:
:
Pref
>
*
aDomPrefs
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
gEarlyDomPrefs
=
new
InfallibleTArray
<
dom
:
:
Pref
>
(
mozilla
:
:
Move
(
*
aDomPrefs
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
gPhase
=
=
ContentProcessPhase
:
:
eNoPrefsSet
)
;
gPhase
=
ContentProcessPhase
:
:
eEarlyPrefsSet
;
#
endif
}
void
Preferences
:
:
SetLatePreferences
(
const
nsTArray
<
dom
:
:
Pref
>
*
aDomPrefs
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
for
(
unsigned
int
i
=
0
;
i
<
aDomPrefs
-
>
Length
(
)
;
i
+
+
)
{
Preferences
:
:
SetPreference
(
aDomPrefs
-
>
ElementAt
(
i
)
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
gPhase
=
=
ContentProcessPhase
:
:
eEarlyPrefsSet
)
;
gPhase
=
ContentProcessPhase
:
:
eEarlyAndLatePrefsSet
;
#
endif
}
void
Preferences
:
:
InitializeUserPrefs
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
sPreferences
-
>
mCurrentFile
"
Should
only
initialize
prefs
once
"
)
;
sPreferences
-
>
ResetUserPrefs
(
)
;
nsCOMPtr
<
nsIFile
>
prefsFile
=
sPreferences
-
>
ReadSavedPrefs
(
)
;
sPreferences
-
>
ReadUserOverridePrefs
(
)
;
sPreferences
-
>
mDirty
=
false
;
sPreferences
-
>
mCurrentFile
=
prefsFile
.
forget
(
)
;
sPreferences
-
>
NotifyServiceObservers
(
NS_PREFSERVICE_READ_TOPIC_ID
)
;
SendTelemetryLoadData
(
)
;
}
NS_IMETHODIMP
Preferences
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
NS_OK
;
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
)
{
if
(
AllowOffMainThreadSave
(
)
)
{
SavePrefFile
(
nullptr
)
;
}
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
profile
-
before
-
change
-
telemetry
"
)
)
{
SavePrefFileBlocking
(
)
;
MOZ_ASSERT
(
!
mDirty
"
Preferences
should
not
be
dirty
"
)
;
mProfileShutdown
=
true
;
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
reload
-
default
-
prefs
"
)
)
{
Unused
<
<
InitInitialObjects
(
)
;
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
suspend_process_notification
"
)
)
{
rv
=
SavePrefFileBlocking
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
Preferences
:
:
ReadUserPrefsFromFile
(
nsIFile
*
aFile
)
{
ENSURE_PARENT_PROCESS
(
"
Preferences
:
:
ReadUserPrefsFromFile
"
"
all
prefs
"
)
;
if
(
!
aFile
)
{
NS_ERROR
(
"
ReadUserPrefsFromFile
requires
a
parameter
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
return
openPrefFile
(
aFile
)
;
}
NS_IMETHODIMP
Preferences
:
:
ResetPrefs
(
)
{
ENSURE_PARENT_PROCESS
(
"
Preferences
:
:
ResetPrefs
"
"
all
prefs
"
)
;
NotifyServiceObservers
(
NS_PREFSERVICE_RESET_TOPIC_ID
)
;
gHashTable
-
>
ClearAndPrepareForLength
(
PREF_HASHTABLE_INITIAL_LENGTH
)
;
gPrefNameArena
.
Clear
(
)
;
return
InitInitialObjects
(
)
.
isOk
(
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
Preferences
:
:
ResetUserPrefs
(
)
{
ENSURE_PARENT_PROCESS
(
"
Preferences
:
:
ResetUserPrefs
"
"
all
prefs
"
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Vector
<
const
char
*
>
prefNames
;
for
(
auto
iter
=
gHashTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
pref
=
static_cast
<
Pref
*
>
(
iter
.
Get
(
)
)
;
if
(
pref
-
>
HasUserValue
(
)
)
{
if
(
!
prefNames
.
append
(
pref
-
>
Name
(
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
pref
-
>
ClearUserValue
(
)
;
if
(
!
pref
-
>
HasDefaultValue
(
)
)
{
iter
.
Remove
(
)
;
}
}
}
for
(
const
char
*
prefName
:
prefNames
)
{
NotifyCallbacks
(
prefName
)
;
}
Preferences
:
:
HandleDirty
(
)
;
return
NS_OK
;
}
bool
Preferences
:
:
AllowOffMainThreadSave
(
)
{
if
(
sAllowOMTPrefWrite
<
0
)
{
bool
value
=
false
;
Preferences
:
:
GetBool
(
"
preferences
.
allow
.
omt
-
write
"
&
value
)
;
sAllowOMTPrefWrite
=
value
?
1
:
0
;
}
return
!
!
sAllowOMTPrefWrite
;
}
nsresult
Preferences
:
:
SavePrefFileBlocking
(
)
{
if
(
mDirty
)
{
return
SavePrefFileInternal
(
nullptr
SaveMethod
:
:
Blocking
)
;
}
if
(
AllowOffMainThreadSave
(
)
)
{
PreferencesWriter
:
:
Flush
(
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
SavePrefFileAsynchronous
(
)
{
return
SavePrefFileInternal
(
nullptr
SaveMethod
:
:
Asynchronous
)
;
}
NS_IMETHODIMP
Preferences
:
:
SavePrefFile
(
nsIFile
*
aFile
)
{
return
SavePrefFileInternal
(
aFile
SaveMethod
:
:
Asynchronous
)
;
}
void
Preferences
:
:
SetPreference
(
const
dom
:
:
Pref
&
aDomPref
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
(
void
)
0
)
;
const
char
*
prefName
=
aDomPref
.
name
(
)
.
get
(
)
;
auto
pref
=
static_cast
<
Pref
*
>
(
gHashTable
-
>
Add
(
prefName
fallible
)
)
;
if
(
!
pref
)
{
return
;
}
if
(
!
pref
-
>
Name
(
)
)
{
new
(
pref
)
Pref
(
prefName
)
;
}
bool
valueChanged
=
false
;
pref
-
>
FromDomPref
(
aDomPref
&
valueChanged
)
;
if
(
!
pref
-
>
HasDefaultValue
(
)
&
&
!
pref
-
>
HasUserValue
(
)
)
{
gHashTable
-
>
RemoveEntry
(
pref
)
;
}
if
(
valueChanged
)
{
NotifyCallbacks
(
prefName
)
;
}
}
void
Preferences
:
:
GetPreference
(
dom
:
:
Pref
*
aDomPref
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
Pref
*
pref
=
pref_HashTableLookup
(
aDomPref
-
>
name
(
)
.
get
(
)
)
;
if
(
pref
&
&
pref
-
>
HasAdvisablySizedValues
(
)
)
{
pref
-
>
ToDomPref
(
aDomPref
)
;
}
}
void
Preferences
:
:
GetPreferences
(
InfallibleTArray
<
dom
:
:
Pref
>
*
aDomPrefs
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
aDomPrefs
-
>
SetCapacity
(
gHashTable
-
>
EntryCount
(
)
)
;
for
(
auto
iter
=
gHashTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
pref
=
static_cast
<
Pref
*
>
(
iter
.
Get
(
)
)
;
if
(
pref
-
>
HasAdvisablySizedValues
(
)
)
{
dom
:
:
Pref
*
setting
=
aDomPrefs
-
>
AppendElement
(
)
;
pref
-
>
ToDomPref
(
setting
)
;
}
}
}
#
ifdef
DEBUG
bool
Preferences
:
:
AreAllPrefsSetInContentProcess
(
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
return
gPhase
=
=
ContentProcessPhase
:
:
eEarlyAndLatePrefsSet
;
}
#
endif
NS_IMETHODIMP
Preferences
:
:
GetBranch
(
const
char
*
aPrefRoot
nsIPrefBranch
*
*
aRetVal
)
{
if
(
(
nullptr
!
=
aPrefRoot
)
&
&
(
*
aPrefRoot
!
=
'
\
0
'
)
)
{
RefPtr
<
nsPrefBranch
>
prefBranch
=
new
nsPrefBranch
(
aPrefRoot
PrefValueKind
:
:
User
)
;
prefBranch
.
forget
(
aRetVal
)
;
}
else
{
nsCOMPtr
<
nsIPrefBranch
>
root
(
sPreferences
-
>
mRootBranch
)
;
root
.
forget
(
aRetVal
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
Preferences
:
:
GetDefaultBranch
(
const
char
*
aPrefRoot
nsIPrefBranch
*
*
aRetVal
)
{
if
(
!
aPrefRoot
|
|
!
aPrefRoot
[
0
]
)
{
nsCOMPtr
<
nsIPrefBranch
>
root
(
sPreferences
-
>
mDefaultRootBranch
)
;
root
.
forget
(
aRetVal
)
;
return
NS_OK
;
}
RefPtr
<
nsPrefBranch
>
prefBranch
=
new
nsPrefBranch
(
aPrefRoot
PrefValueKind
:
:
Default
)
;
if
(
!
prefBranch
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
prefBranch
.
forget
(
aRetVal
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Preferences
:
:
GetDirty
(
bool
*
aRetVal
)
{
*
aRetVal
=
mDirty
;
return
NS_OK
;
}
nsresult
Preferences
:
:
NotifyServiceObservers
(
const
char
*
aTopic
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
{
return
NS_ERROR_FAILURE
;
}
auto
subject
=
static_cast
<
nsIPrefService
*
>
(
this
)
;
observerService
-
>
NotifyObservers
(
subject
aTopic
nullptr
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIFile
>
Preferences
:
:
ReadSavedPrefs
(
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_PREFS_50_FILE
getter_AddRefs
(
file
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
rv
=
openPrefFile
(
file
)
;
if
(
rv
=
=
NS_ERROR_FILE_NOT_FOUND
)
{
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
PREFERENCES_CREATED_NEW_USER_PREFS_FILE
true
)
;
rv
=
NS_OK
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
PREFERENCES_PREFS_FILE_WAS_INVALID
true
)
;
MakeBackupPrefFile
(
file
)
;
}
return
file
.
forget
(
)
;
}
void
Preferences
:
:
ReadUserOverridePrefs
(
)
{
nsCOMPtr
<
nsIFile
>
aFile
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_PREFS_50_DIR
getter_AddRefs
(
aFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
aFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
user
.
js
"
)
)
;
rv
=
openPrefFile
(
aFile
)
;
if
(
rv
!
=
NS_ERROR_FILE_NOT_FOUND
)
{
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
PREFERENCES_READ_USER_JS
true
)
;
}
}
nsresult
Preferences
:
:
MakeBackupPrefFile
(
nsIFile
*
aFile
)
{
nsAutoString
newFilename
;
nsresult
rv
=
aFile
-
>
GetLeafName
(
newFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
newFilename
.
InsertLiteral
(
u
"
Invalid
"
0
)
;
nsCOMPtr
<
nsIFile
>
newFile
;
rv
=
aFile
-
>
GetParent
(
getter_AddRefs
(
newFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
newFile
-
>
Append
(
newFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
exists
=
false
;
newFile
-
>
Exists
(
&
exists
)
;
if
(
exists
)
{
rv
=
newFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
aFile
-
>
CopyTo
(
nullptr
newFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
nsresult
Preferences
:
:
SavePrefFileInternal
(
nsIFile
*
aFile
SaveMethod
aSaveMethod
)
{
ENSURE_PARENT_PROCESS
(
"
Preferences
:
:
SavePrefFileInternal
"
"
all
prefs
"
)
;
if
(
nullptr
=
=
aFile
)
{
mSavePending
=
false
;
if
(
!
AllowOffMainThreadSave
(
)
)
{
aSaveMethod
=
SaveMethod
:
:
Blocking
;
}
if
(
!
mDirty
)
{
return
NS_OK
;
}
if
(
mProfileShutdown
)
{
NS_WARNING
(
"
Cannot
save
pref
file
after
profile
shutdown
.
"
)
;
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
nsresult
rv
=
NS_OK
;
if
(
mCurrentFile
)
{
rv
=
WritePrefFile
(
mCurrentFile
aSaveMethod
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
mDirty
=
false
;
}
return
rv
;
}
else
{
return
WritePrefFile
(
aFile
SaveMethod
:
:
Blocking
)
;
}
}
nsresult
Preferences
:
:
WritePrefFile
(
nsIFile
*
aFile
SaveMethod
aSaveMethod
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
gHashTable
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AUTO_PROFILER_LABEL
(
"
Preferences
:
:
WritePrefFile
"
OTHER
)
;
if
(
AllowOffMainThreadSave
(
)
)
{
nsresult
rv
=
NS_OK
;
mozilla
:
:
UniquePtr
<
PrefSaveData
>
prefs
=
MakeUnique
<
PrefSaveData
>
(
pref_savePrefs
(
)
)
;
prefs
.
reset
(
PreferencesWriter
:
:
sPendingWriteData
.
exchange
(
prefs
.
release
(
)
)
)
;
if
(
prefs
)
{
return
rv
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
async
=
aSaveMethod
=
=
SaveMethod
:
:
Asynchronous
;
if
(
async
)
{
rv
=
target
-
>
Dispatch
(
new
PWRunnable
(
aFile
)
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
}
else
{
SyncRunnable
:
:
DispatchToThread
(
target
new
PWRunnable
(
aFile
)
true
)
;
}
return
rv
;
}
MOZ_ASSERT
(
false
"
failed
to
get
the
target
thread
for
OMT
pref
write
"
)
;
}
PrefSaveData
prefsData
=
pref_savePrefs
(
)
;
return
PreferencesWriter
:
:
Write
(
aFile
prefsData
)
;
}
static
nsresult
openPrefFile
(
nsIFile
*
aFile
)
{
TimeStamp
startTime
=
TimeStamp
:
:
Now
(
)
;
nsCString
data
;
MOZ_TRY_VAR
(
data
URLPreloader
:
:
ReadFile
(
aFile
)
)
;
nsAutoString
filenameUtf16
;
aFile
-
>
GetLeafName
(
filenameUtf16
)
;
NS_ConvertUTF16toUTF8
filename
(
filenameUtf16
)
;
nsAutoString
path
;
aFile
-
>
GetPath
(
path
)
;
Parser
parser
;
if
(
!
parser
.
Parse
(
filename
NS_ConvertUTF16toUTF8
(
path
)
.
get
(
)
startTime
data
)
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
return
NS_OK
;
}
static
int
pref_CompareFileNames
(
nsIFile
*
aFile1
nsIFile
*
aFile2
void
*
)
{
nsAutoCString
filename1
filename2
;
aFile1
-
>
GetNativeLeafName
(
filename1
)
;
aFile2
-
>
GetNativeLeafName
(
filename2
)
;
return
Compare
(
filename2
filename1
)
;
}
static
nsresult
pref_LoadPrefsInDir
(
nsIFile
*
aDir
char
const
*
const
*
aSpecialFiles
uint32_t
aSpecialFilesCount
)
{
nsresult
rv
rv2
;
bool
hasMoreElements
;
nsCOMPtr
<
nsISimpleEnumerator
>
dirIterator
;
rv
=
aDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
dirIterator
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_FILE_NOT_FOUND
|
|
rv
=
=
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
)
{
rv
=
NS_OK
;
}
return
rv
;
}
rv
=
dirIterator
-
>
HasMoreElements
(
&
hasMoreElements
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMArray
<
nsIFile
>
prefFiles
(
INITIAL_PREF_FILES
)
;
nsCOMArray
<
nsIFile
>
specialFiles
(
aSpecialFilesCount
)
;
nsCOMPtr
<
nsIFile
>
prefFile
;
while
(
hasMoreElements
&
&
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsISupports
>
supports
;
rv
=
dirIterator
-
>
GetNext
(
getter_AddRefs
(
supports
)
)
;
prefFile
=
do_QueryInterface
(
supports
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
nsAutoCString
leafName
;
prefFile
-
>
GetNativeLeafName
(
leafName
)
;
NS_ASSERTION
(
!
leafName
.
IsEmpty
(
)
"
Failure
in
default
prefs
:
directory
enumerator
returned
empty
file
?
"
)
;
if
(
StringEndsWith
(
leafName
NS_LITERAL_CSTRING
(
"
.
js
"
)
nsCaseInsensitiveCStringComparator
(
)
)
)
{
bool
shouldParse
=
true
;
for
(
uint32_t
i
=
0
;
i
<
aSpecialFilesCount
;
+
+
i
)
{
if
(
leafName
.
Equals
(
nsDependentCString
(
aSpecialFiles
[
i
]
)
)
)
{
shouldParse
=
false
;
specialFiles
.
ReplaceObjectAt
(
prefFile
i
)
;
}
}
if
(
shouldParse
)
{
prefFiles
.
AppendObject
(
prefFile
)
;
}
}
rv
=
dirIterator
-
>
HasMoreElements
(
&
hasMoreElements
)
;
}
if
(
prefFiles
.
Count
(
)
+
specialFiles
.
Count
(
)
=
=
0
)
{
NS_WARNING
(
"
No
default
pref
files
found
.
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
NS_SUCCESS_FILE_DIRECTORY_EMPTY
;
}
return
rv
;
}
prefFiles
.
Sort
(
pref_CompareFileNames
nullptr
)
;
uint32_t
arrayCount
=
prefFiles
.
Count
(
)
;
uint32_t
i
;
for
(
i
=
0
;
i
<
arrayCount
;
+
+
i
)
{
rv2
=
openPrefFile
(
prefFiles
[
i
]
)
;
if
(
NS_FAILED
(
rv2
)
)
{
NS_ERROR
(
"
Default
pref
file
not
parsed
successfully
.
"
)
;
rv
=
rv2
;
}
}
arrayCount
=
specialFiles
.
Count
(
)
;
for
(
i
=
0
;
i
<
arrayCount
;
+
+
i
)
{
nsIFile
*
file
=
specialFiles
[
i
]
;
if
(
file
)
{
rv2
=
openPrefFile
(
file
)
;
if
(
NS_FAILED
(
rv2
)
)
{
NS_ERROR
(
"
Special
default
pref
file
not
parsed
successfully
.
"
)
;
rv
=
rv2
;
}
}
}
return
rv
;
}
static
nsresult
pref_ReadPrefFromJar
(
nsZipArchive
*
aJarReader
const
char
*
aName
)
{
TimeStamp
startTime
=
TimeStamp
:
:
Now
(
)
;
nsCString
manifest
;
MOZ_TRY_VAR
(
manifest
URLPreloader
:
:
ReadZip
(
aJarReader
nsDependentCString
(
aName
)
)
)
;
Parser
parser
;
if
(
!
parser
.
Parse
(
nsDependentCString
(
aName
)
aName
startTime
manifest
)
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
return
NS_OK
;
}
Result
<
Ok
const
char
*
>
Preferences
:
:
InitInitialObjects
(
)
{
nsresult
rv
;
nsZipFind
*
findPtr
;
nsAutoPtr
<
nsZipFind
>
find
;
nsTArray
<
nsCString
>
prefEntries
;
const
char
*
entryName
;
uint16_t
entryNameLen
;
RefPtr
<
nsZipArchive
>
jarReader
=
mozilla
:
:
Omnijar
:
:
GetReader
(
mozilla
:
:
Omnijar
:
:
GRE
)
;
if
(
jarReader
)
{
rv
=
pref_ReadPrefFromJar
(
jarReader
"
greprefs
.
js
"
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
"
pref_ReadPrefFromJar
(
)
failed
"
)
)
;
rv
=
jarReader
-
>
FindInit
(
"
defaults
/
pref
/
*
.
js
"
&
findPtr
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
"
jarReader
-
>
FindInit
(
)
failed
"
)
)
;
find
=
findPtr
;
while
(
NS_SUCCEEDED
(
find
-
>
FindNext
(
&
entryName
&
entryNameLen
)
)
)
{
prefEntries
.
AppendElement
(
Substring
(
entryName
entryNameLen
)
)
;
}
prefEntries
.
Sort
(
)
;
for
(
uint32_t
i
=
prefEntries
.
Length
(
)
;
i
-
-
;
)
{
rv
=
pref_ReadPrefFromJar
(
jarReader
prefEntries
[
i
]
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Error
parsing
preferences
.
"
)
;
}
}
}
else
{
nsCOMPtr
<
nsIFile
>
greprefsFile
;
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
greprefsFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
"
NS_GetSpecialDirectory
(
NS_GRE_DIR
)
failed
"
)
)
;
rv
=
greprefsFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
greprefs
.
js
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
"
greprefsFile
-
>
AppendNative
(
)
failed
"
)
)
;
rv
=
openPrefFile
(
greprefsFile
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Error
parsing
GRE
default
preferences
.
Is
this
an
old
-
style
"
"
embedding
app
?
"
)
;
}
}
nsCOMPtr
<
nsIFile
>
defaultPrefDir
;
rv
=
NS_GetSpecialDirectory
(
NS_APP_PREF_DEFAULTS_50_DIR
getter_AddRefs
(
defaultPrefDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
"
NS_GetSpecialDirectory
(
NS_APP_PREF_DEFAULTS_50_DIR
)
failed
"
)
)
;
static
const
char
*
specialFiles
[
]
=
{
#
if
defined
(
XP_MACOSX
)
"
macprefs
.
js
"
#
elif
defined
(
XP_WIN
)
"
winpref
.
js
"
#
elif
defined
(
XP_UNIX
)
"
unix
.
js
"
#
if
defined
(
_AIX
)
"
aix
.
js
"
#
endif
#
elif
defined
(
XP_BEOS
)
"
beos
.
js
"
#
endif
}
;
rv
=
pref_LoadPrefsInDir
(
defaultPrefDir
specialFiles
ArrayLength
(
specialFiles
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Error
parsing
application
default
preferences
.
"
)
;
}
RefPtr
<
nsZipArchive
>
appJarReader
=
mozilla
:
:
Omnijar
:
:
GetReader
(
mozilla
:
:
Omnijar
:
:
APP
)
;
if
(
!
appJarReader
)
{
appJarReader
=
mozilla
:
:
Omnijar
:
:
GetReader
(
mozilla
:
:
Omnijar
:
:
GRE
)
;
}
if
(
appJarReader
)
{
rv
=
appJarReader
-
>
FindInit
(
"
defaults
/
preferences
/
*
.
js
"
&
findPtr
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
"
appJarReader
-
>
FindInit
(
)
failed
"
)
)
;
find
=
findPtr
;
prefEntries
.
Clear
(
)
;
while
(
NS_SUCCEEDED
(
find
-
>
FindNext
(
&
entryName
&
entryNameLen
)
)
)
{
prefEntries
.
AppendElement
(
Substring
(
entryName
entryNameLen
)
)
;
}
prefEntries
.
Sort
(
)
;
for
(
uint32_t
i
=
prefEntries
.
Length
(
)
;
i
-
-
;
)
{
rv
=
pref_ReadPrefFromJar
(
appJarReader
prefEntries
[
i
]
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Error
parsing
preferences
.
"
)
;
}
}
}
nsCOMPtr
<
nsIProperties
>
dirSvc
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
"
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
)
failed
"
)
)
;
nsCOMPtr
<
nsISimpleEnumerator
>
list
;
dirSvc
-
>
Get
(
NS_APP_PREFS_DEFAULTS_DIR_LIST
NS_GET_IID
(
nsISimpleEnumerator
)
getter_AddRefs
(
list
)
)
;
if
(
list
)
{
bool
hasMore
;
while
(
NS_SUCCEEDED
(
list
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
elem
;
list
-
>
GetNext
(
getter_AddRefs
(
elem
)
)
;
if
(
!
elem
)
{
continue
;
}
nsCOMPtr
<
nsIFile
>
path
=
do_QueryInterface
(
elem
)
;
if
(
!
path
)
{
continue
;
}
pref_LoadPrefsInDir
(
path
nullptr
0
)
;
}
}
#
ifdef
MOZ_WIDGET_ANDROID
if
(
Preferences
:
:
GetType
(
kTelemetryPref
PrefValueKind
:
:
Default
)
=
=
nsIPrefBranch
:
:
PREF_INVALID
)
{
bool
prerelease
=
false
;
#
ifdef
MOZ_TELEMETRY_ON_BY_DEFAULT
prerelease
=
true
;
#
else
nsAutoCString
prefValue
;
Preferences
:
:
GetCString
(
kChannelPref
prefValue
PrefValueKind
:
:
Default
)
;
if
(
prefValue
.
EqualsLiteral
(
"
beta
"
)
)
{
prerelease
=
true
;
}
#
endif
Preferences
:
:
SetBoolInAnyProcess
(
kTelemetryPref
prerelease
PrefValueKind
:
:
Default
)
;
}
#
else
bool
developerBuild
=
false
;
#
ifndef
MOZILLA_OFFICIAL
developerBuild
=
!
strcmp
(
NS_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
"
default
"
)
;
#
endif
if
(
!
strcmp
(
NS_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
"
nightly
"
)
|
|
!
strcmp
(
NS_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
"
aurora
"
)
|
|
!
strcmp
(
NS_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
"
beta
"
)
|
|
developerBuild
)
{
Preferences
:
:
SetBoolInAnyProcess
(
kTelemetryPref
true
PrefValueKind
:
:
Default
)
;
}
else
{
Preferences
:
:
SetBoolInAnyProcess
(
kTelemetryPref
false
PrefValueKind
:
:
Default
)
;
}
Preferences
:
:
LockInAnyProcess
(
kTelemetryPref
)
;
#
endif
NS_CreateServicesFromCategory
(
NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID
nullptr
NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
"
GetObserverService
(
)
failed
(
2
)
"
)
)
;
observerService
-
>
NotifyObservers
(
nullptr
NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID
nullptr
)
;
return
Ok
(
)
;
}
nsresult
Preferences
:
:
GetBool
(
const
char
*
aPrefName
bool
*
aResult
PrefValueKind
aKind
)
{
NS_PRECONDITION
(
aResult
"
aResult
must
not
be
NULL
"
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
Pref
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
return
pref
?
pref
-
>
GetBoolValue
(
aKind
aResult
)
:
NS_ERROR_UNEXPECTED
;
}
nsresult
Preferences
:
:
GetInt
(
const
char
*
aPrefName
int32_t
*
aResult
PrefValueKind
aKind
)
{
NS_PRECONDITION
(
aResult
"
aResult
must
not
be
NULL
"
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
Pref
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
return
pref
?
pref
-
>
GetIntValue
(
aKind
aResult
)
:
NS_ERROR_UNEXPECTED
;
}
nsresult
Preferences
:
:
GetFloat
(
const
char
*
aPrefName
float
*
aResult
PrefValueKind
aKind
)
{
NS_PRECONDITION
(
aResult
"
aResult
must
not
be
NULL
"
)
;
nsAutoCString
result
;
nsresult
rv
=
Preferences
:
:
GetCString
(
aPrefName
result
aKind
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aResult
=
result
.
ToFloat
(
&
rv
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetCString
(
const
char
*
aPrefName
nsACString
&
aResult
PrefValueKind
aKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
aResult
.
SetIsVoid
(
true
)
;
Pref
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
return
pref
?
pref
-
>
GetCStringValue
(
aKind
aResult
)
:
NS_ERROR_UNEXPECTED
;
}
nsresult
Preferences
:
:
GetString
(
const
char
*
aPrefName
nsAString
&
aResult
PrefValueKind
aKind
)
{
nsAutoCString
result
;
nsresult
rv
=
Preferences
:
:
GetCString
(
aPrefName
result
aKind
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF8toUTF16
(
result
aResult
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetLocalizedCString
(
const
char
*
aPrefName
nsACString
&
aResult
PrefValueKind
aKind
)
{
nsAutoString
result
;
nsresult
rv
=
GetLocalizedString
(
aPrefName
result
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF16toUTF8
(
result
aResult
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetLocalizedString
(
const
char
*
aPrefName
nsAString
&
aResult
PrefValueKind
aKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsIPrefLocalizedString
>
prefLocalString
;
nsresult
rv
=
GetRootBranch
(
aKind
)
-
>
GetComplexValue
(
aPrefName
NS_GET_IID
(
nsIPrefLocalizedString
)
getter_AddRefs
(
prefLocalString
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_ASSERTION
(
prefLocalString
"
Succeeded
but
the
result
is
NULL
"
)
;
prefLocalString
-
>
GetData
(
aResult
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetComplex
(
const
char
*
aPrefName
const
nsIID
&
aType
void
*
*
aResult
PrefValueKind
aKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
GetRootBranch
(
aKind
)
-
>
GetComplexValue
(
aPrefName
aType
aResult
)
;
}
nsresult
Preferences
:
:
SetCStringInAnyProcess
(
const
char
*
aPrefName
const
nsACString
&
aValue
PrefValueKind
aKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
if
(
aValue
.
Length
(
)
>
MAX_PREF_LENGTH
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
PrefValue
prefValue
;
const
nsCString
&
flat
=
PromiseFlatCString
(
aValue
)
;
prefValue
.
mStringVal
=
flat
.
get
(
)
;
return
pref_SetPref
(
aPrefName
PrefType
:
:
String
aKind
prefValue
false
false
)
;
}
nsresult
Preferences
:
:
SetCString
(
const
char
*
aPrefName
const
nsACString
&
aValue
PrefValueKind
aKind
)
{
ENSURE_PARENT_PROCESS
(
"
SetCString
"
aPrefName
)
;
return
SetCStringInAnyProcess
(
aPrefName
aValue
aKind
)
;
}
nsresult
Preferences
:
:
SetBoolInAnyProcess
(
const
char
*
aPrefName
bool
aValue
PrefValueKind
aKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
PrefValue
prefValue
;
prefValue
.
mBoolVal
=
aValue
;
return
pref_SetPref
(
aPrefName
PrefType
:
:
Bool
aKind
prefValue
false
false
)
;
}
nsresult
Preferences
:
:
SetBool
(
const
char
*
aPrefName
bool
aValue
PrefValueKind
aKind
)
{
ENSURE_PARENT_PROCESS
(
"
SetBool
"
aPrefName
)
;
return
SetBoolInAnyProcess
(
aPrefName
aValue
aKind
)
;
}
nsresult
Preferences
:
:
SetIntInAnyProcess
(
const
char
*
aPrefName
int32_t
aValue
PrefValueKind
aKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
PrefValue
prefValue
;
prefValue
.
mIntVal
=
aValue
;
return
pref_SetPref
(
aPrefName
PrefType
:
:
Int
aKind
prefValue
false
false
)
;
}
nsresult
Preferences
:
:
SetInt
(
const
char
*
aPrefName
int32_t
aValue
PrefValueKind
aKind
)
{
ENSURE_PARENT_PROCESS
(
"
SetInt
"
aPrefName
)
;
return
SetIntInAnyProcess
(
aPrefName
aValue
aKind
)
;
}
nsresult
Preferences
:
:
SetComplex
(
const
char
*
aPrefName
const
nsIID
&
aType
nsISupports
*
aValue
PrefValueKind
aKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
GetRootBranch
(
aKind
)
-
>
SetComplexValue
(
aPrefName
aType
aValue
)
;
}
nsresult
Preferences
:
:
LockInAnyProcess
(
const
char
*
aPrefName
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
Pref
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
if
(
!
pref
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
pref
-
>
IsLocked
(
)
)
{
pref
-
>
SetIsLocked
(
true
)
;
gIsAnyPrefLocked
=
true
;
NotifyCallbacks
(
aPrefName
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
Lock
(
const
char
*
aPrefName
)
{
ENSURE_PARENT_PROCESS
(
"
Lock
"
aPrefName
)
;
return
Preferences
:
:
LockInAnyProcess
(
aPrefName
)
;
}
nsresult
Preferences
:
:
Unlock
(
const
char
*
aPrefName
)
{
ENSURE_PARENT_PROCESS
(
"
Unlock
"
aPrefName
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
Pref
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
if
(
!
pref
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
pref
-
>
IsLocked
(
)
)
{
pref
-
>
SetIsLocked
(
false
)
;
NotifyCallbacks
(
aPrefName
)
;
}
return
NS_OK
;
}
bool
Preferences
:
:
IsLocked
(
const
char
*
aPrefName
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
false
)
;
if
(
gIsAnyPrefLocked
)
{
Pref
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
if
(
pref
&
&
pref
-
>
IsLocked
(
)
)
{
return
true
;
}
}
return
false
;
}
nsresult
Preferences
:
:
ClearUserInAnyProcess
(
const
char
*
aPrefName
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
Pref
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
if
(
pref
&
&
pref
-
>
HasUserValue
(
)
)
{
pref
-
>
ClearUserValue
(
)
;
if
(
!
pref
-
>
HasDefaultValue
(
)
)
{
gHashTable
-
>
RemoveEntry
(
pref
)
;
}
NotifyCallbacks
(
aPrefName
)
;
Preferences
:
:
HandleDirty
(
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
ClearUser
(
const
char
*
aPrefName
)
{
ENSURE_PARENT_PROCESS
(
"
ClearUser
"
aPrefName
)
;
return
ClearUserInAnyProcess
(
aPrefName
)
;
}
bool
Preferences
:
:
HasUserValue
(
const
char
*
aPrefName
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
false
)
;
Pref
*
pref
=
pref_HashTableLookup
(
aPrefName
)
;
return
pref
&
&
pref
-
>
HasUserValue
(
)
;
}
int32_t
Preferences
:
:
GetType
(
const
char
*
aPrefName
PrefValueKind
aKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
nsIPrefBranch
:
:
PREF_INVALID
)
;
int32_t
result
;
return
NS_SUCCEEDED
(
GetRootBranch
(
aKind
)
-
>
GetPrefType
(
aPrefName
&
result
)
)
?
result
:
nsIPrefBranch
:
:
PREF_INVALID
;
}
nsresult
Preferences
:
:
AddStrongObserver
(
nsIObserver
*
aObserver
const
char
*
aPref
)
{
MOZ_ASSERT
(
aObserver
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
sPreferences
-
>
mRootBranch
-
>
AddObserver
(
aPref
aObserver
false
)
;
}
nsresult
Preferences
:
:
AddWeakObserver
(
nsIObserver
*
aObserver
const
char
*
aPref
)
{
MOZ_ASSERT
(
aObserver
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
sPreferences
-
>
mRootBranch
-
>
AddObserver
(
aPref
aObserver
true
)
;
}
nsresult
Preferences
:
:
RemoveObserver
(
nsIObserver
*
aObserver
const
char
*
aPref
)
{
MOZ_ASSERT
(
aObserver
)
;
if
(
sShutdown
)
{
MOZ_ASSERT
(
!
sPreferences
)
;
return
NS_OK
;
}
NS_ENSURE_TRUE
(
sPreferences
NS_ERROR_NOT_AVAILABLE
)
;
return
sPreferences
-
>
mRootBranch
-
>
RemoveObserver
(
aPref
aObserver
)
;
}
nsresult
Preferences
:
:
AddStrongObservers
(
nsIObserver
*
aObserver
const
char
*
*
aPrefs
)
{
MOZ_ASSERT
(
aObserver
)
;
for
(
uint32_t
i
=
0
;
aPrefs
[
i
]
;
i
+
+
)
{
nsresult
rv
=
AddStrongObserver
(
aObserver
aPrefs
[
i
]
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
AddWeakObservers
(
nsIObserver
*
aObserver
const
char
*
*
aPrefs
)
{
MOZ_ASSERT
(
aObserver
)
;
for
(
uint32_t
i
=
0
;
aPrefs
[
i
]
;
i
+
+
)
{
nsresult
rv
=
AddWeakObserver
(
aObserver
aPrefs
[
i
]
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
RemoveObservers
(
nsIObserver
*
aObserver
const
char
*
*
aPrefs
)
{
MOZ_ASSERT
(
aObserver
)
;
if
(
sShutdown
)
{
MOZ_ASSERT
(
!
sPreferences
)
;
return
NS_OK
;
}
NS_ENSURE_TRUE
(
sPreferences
NS_ERROR_NOT_AVAILABLE
)
;
for
(
uint32_t
i
=
0
;
aPrefs
[
i
]
;
i
+
+
)
{
nsresult
rv
=
RemoveObserver
(
aObserver
aPrefs
[
i
]
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
RegisterCallback
(
PrefChangedFunc
aCallback
const
char
*
aPrefNode
void
*
aData
MatchKind
aMatchKind
bool
aIsPriority
)
{
NS_ENSURE_ARG
(
aPrefNode
)
;
NS_ENSURE_ARG
(
aCallback
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
auto
node
=
new
CallbackNode
(
aPrefNode
aCallback
aData
aMatchKind
)
;
if
(
aIsPriority
)
{
node
-
>
mNext
=
gFirstCallback
;
gFirstCallback
=
node
;
if
(
!
gLastPriorityNode
)
{
gLastPriorityNode
=
node
;
}
}
else
{
if
(
gLastPriorityNode
)
{
node
-
>
mNext
=
gLastPriorityNode
-
>
mNext
;
gLastPriorityNode
-
>
mNext
=
node
;
}
else
{
node
-
>
mNext
=
gFirstCallback
;
gFirstCallback
=
node
;
}
}
return
NS_OK
;
}
nsresult
Preferences
:
:
RegisterCallbackAndCall
(
PrefChangedFunc
aCallback
const
char
*
aPref
void
*
aClosure
MatchKind
aMatchKind
)
{
MOZ_ASSERT
(
aCallback
)
;
nsresult
rv
=
RegisterCallback
(
aCallback
aPref
aClosure
aMatchKind
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
(
*
aCallback
)
(
aPref
aClosure
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
UnregisterCallback
(
PrefChangedFunc
aCallback
const
char
*
aPrefNode
void
*
aData
MatchKind
aMatchKind
)
{
MOZ_ASSERT
(
aCallback
)
;
if
(
sShutdown
)
{
MOZ_ASSERT
(
!
sPreferences
)
;
return
NS_OK
;
}
NS_ENSURE_TRUE
(
sPreferences
NS_ERROR_NOT_AVAILABLE
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
CallbackNode
*
node
=
gFirstCallback
;
CallbackNode
*
prev_node
=
nullptr
;
while
(
node
)
{
if
(
node
-
>
mFunc
=
=
aCallback
&
&
node
-
>
mData
=
=
aData
&
&
node
-
>
mMatchKind
=
=
aMatchKind
&
&
strcmp
(
node
-
>
mDomain
.
get
(
)
aPrefNode
)
=
=
0
)
{
if
(
gCallbacksInProgress
)
{
node
-
>
mFunc
=
nullptr
;
gShouldCleanupDeadNodes
=
true
;
prev_node
=
node
;
node
=
node
-
>
mNext
;
}
else
{
node
=
pref_RemoveCallbackNode
(
node
prev_node
)
;
}
rv
=
NS_OK
;
}
else
{
prev_node
=
node
;
node
=
node
-
>
mNext
;
}
}
return
rv
;
}
static
void
CacheDataAppendElement
(
CacheData
*
aData
)
{
if
(
!
gCacheData
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
!
gCacheData
:
%
s
"
gCacheDataDesc
)
;
}
gCacheData
-
>
AppendElement
(
aData
)
;
}
static
void
BoolVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
static_cast
<
bool
*
>
(
cache
-
>
mCacheLocation
)
=
Preferences
:
:
GetBool
(
aPref
cache
-
>
mDefaultValueBool
)
;
}
nsresult
Preferences
:
:
AddBoolVarCache
(
bool
*
aCache
const
char
*
aPref
bool
aDefault
)
{
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
bool
"
aPref
aCache
)
;
#
endif
*
aCache
=
GetBool
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
mCacheLocation
=
aCache
;
data
-
>
mDefaultValueBool
=
aDefault
;
CacheDataAppendElement
(
data
)
;
Preferences
:
:
RegisterCallback
(
BoolVarChanged
aPref
data
Preferences
:
:
ExactMatch
true
)
;
return
NS_OK
;
}
template
<
MemoryOrdering
Order
>
static
void
AtomicBoolVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
static_cast
<
Atomic
<
bool
Order
>
*
>
(
cache
-
>
mCacheLocation
)
=
Preferences
:
:
GetBool
(
aPref
cache
-
>
mDefaultValueBool
)
;
}
template
<
MemoryOrdering
Order
>
nsresult
Preferences
:
:
AddAtomicBoolVarCache
(
Atomic
<
bool
Order
>
*
aCache
const
char
*
aPref
bool
aDefault
)
{
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
bool
"
aPref
aCache
)
;
#
endif
*
aCache
=
Preferences
:
:
GetBool
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
mCacheLocation
=
aCache
;
data
-
>
mDefaultValueBool
=
aDefault
;
CacheDataAppendElement
(
data
)
;
Preferences
:
:
RegisterCallback
(
AtomicBoolVarChanged
<
Order
>
aPref
data
Preferences
:
:
ExactMatch
true
)
;
return
NS_OK
;
}
static
void
IntVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
static_cast
<
int32_t
*
>
(
cache
-
>
mCacheLocation
)
=
Preferences
:
:
GetInt
(
aPref
cache
-
>
mDefaultValueInt
)
;
}
nsresult
Preferences
:
:
AddIntVarCache
(
int32_t
*
aCache
const
char
*
aPref
int32_t
aDefault
)
{
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
int
"
aPref
aCache
)
;
#
endif
*
aCache
=
Preferences
:
:
GetInt
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
mCacheLocation
=
aCache
;
data
-
>
mDefaultValueInt
=
aDefault
;
CacheDataAppendElement
(
data
)
;
Preferences
:
:
RegisterCallback
(
IntVarChanged
aPref
data
Preferences
:
:
ExactMatch
true
)
;
return
NS_OK
;
}
template
<
MemoryOrdering
Order
>
static
void
AtomicIntVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
static_cast
<
Atomic
<
int32_t
Order
>
*
>
(
cache
-
>
mCacheLocation
)
=
Preferences
:
:
GetInt
(
aPref
cache
-
>
mDefaultValueUint
)
;
}
template
<
MemoryOrdering
Order
>
nsresult
Preferences
:
:
AddAtomicIntVarCache
(
Atomic
<
int32_t
Order
>
*
aCache
const
char
*
aPref
int32_t
aDefault
)
{
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
int
"
aPref
aCache
)
;
#
endif
*
aCache
=
Preferences
:
:
GetInt
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
mCacheLocation
=
aCache
;
data
-
>
mDefaultValueUint
=
aDefault
;
CacheDataAppendElement
(
data
)
;
Preferences
:
:
RegisterCallback
(
AtomicIntVarChanged
<
Order
>
aPref
data
Preferences
:
:
ExactMatch
true
)
;
return
NS_OK
;
}
static
void
UintVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
static_cast
<
uint32_t
*
>
(
cache
-
>
mCacheLocation
)
=
Preferences
:
:
GetUint
(
aPref
cache
-
>
mDefaultValueUint
)
;
}
nsresult
Preferences
:
:
AddUintVarCache
(
uint32_t
*
aCache
const
char
*
aPref
uint32_t
aDefault
)
{
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
uint
"
aPref
aCache
)
;
#
endif
*
aCache
=
Preferences
:
:
GetUint
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
mCacheLocation
=
aCache
;
data
-
>
mDefaultValueUint
=
aDefault
;
CacheDataAppendElement
(
data
)
;
Preferences
:
:
RegisterCallback
(
UintVarChanged
aPref
data
Preferences
:
:
ExactMatch
true
)
;
return
NS_OK
;
}
template
<
MemoryOrdering
Order
>
static
void
AtomicUintVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
static_cast
<
Atomic
<
uint32_t
Order
>
*
>
(
cache
-
>
mCacheLocation
)
=
Preferences
:
:
GetUint
(
aPref
cache
-
>
mDefaultValueUint
)
;
}
template
<
MemoryOrdering
Order
>
nsresult
Preferences
:
:
AddAtomicUintVarCache
(
Atomic
<
uint32_t
Order
>
*
aCache
const
char
*
aPref
uint32_t
aDefault
)
{
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
uint
"
aPref
aCache
)
;
#
endif
*
aCache
=
Preferences
:
:
GetUint
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
mCacheLocation
=
aCache
;
data
-
>
mDefaultValueUint
=
aDefault
;
CacheDataAppendElement
(
data
)
;
Preferences
:
:
RegisterCallback
(
AtomicUintVarChanged
<
Order
>
aPref
data
Preferences
:
:
ExactMatch
true
)
;
return
NS_OK
;
}
template
nsresult
Preferences
:
:
AddAtomicBoolVarCache
(
Atomic
<
bool
Relaxed
>
*
const
char
*
bool
)
;
template
nsresult
Preferences
:
:
AddAtomicBoolVarCache
(
Atomic
<
bool
ReleaseAcquire
>
*
const
char
*
bool
)
;
template
nsresult
Preferences
:
:
AddAtomicBoolVarCache
(
Atomic
<
bool
SequentiallyConsistent
>
*
const
char
*
bool
)
;
template
nsresult
Preferences
:
:
AddAtomicIntVarCache
(
Atomic
<
int32_t
Relaxed
>
*
const
char
*
int32_t
)
;
template
nsresult
Preferences
:
:
AddAtomicUintVarCache
(
Atomic
<
uint32_t
Relaxed
>
*
const
char
*
uint32_t
)
;
template
nsresult
Preferences
:
:
AddAtomicUintVarCache
(
Atomic
<
uint32_t
ReleaseAcquire
>
*
const
char
*
uint32_t
)
;
static
void
FloatVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
static_cast
<
float
*
>
(
cache
-
>
mCacheLocation
)
=
Preferences
:
:
GetFloat
(
aPref
cache
-
>
mDefaultValueFloat
)
;
}
nsresult
Preferences
:
:
AddFloatVarCache
(
float
*
aCache
const
char
*
aPref
float
aDefault
)
{
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
float
"
aPref
aCache
)
;
#
endif
*
aCache
=
Preferences
:
:
GetFloat
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
mCacheLocation
=
aCache
;
data
-
>
mDefaultValueFloat
=
aDefault
;
CacheDataAppendElement
(
data
)
;
Preferences
:
:
RegisterCallback
(
FloatVarChanged
aPref
data
Preferences
:
:
ExactMatch
true
)
;
return
NS_OK
;
}
}
#
undef
ENSURE_PARENT_PROCESS
NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR
(
Preferences
Preferences
:
:
GetInstanceForService
)
NS_GENERIC_FACTORY_CONSTRUCTOR_INIT
(
nsPrefLocalizedString
Init
)
NS_GENERIC_FACTORY_CONSTRUCTOR
(
nsRelativeFilePref
)
static
NS_DEFINE_CID
(
kPrefServiceCID
NS_PREFSERVICE_CID
)
;
static
NS_DEFINE_CID
(
kPrefLocalizedStringCID
NS_PREFLOCALIZEDSTRING_CID
)
;
static
NS_DEFINE_CID
(
kRelativeFilePrefCID
NS_RELATIVEFILEPREF_CID
)
;
static
mozilla
:
:
Module
:
:
CIDEntry
kPrefCIDs
[
]
=
{
{
&
kPrefServiceCID
true
nullptr
PreferencesConstructor
}
{
&
kPrefLocalizedStringCID
false
nullptr
nsPrefLocalizedStringConstructor
}
{
&
kRelativeFilePrefCID
false
nullptr
nsRelativeFilePrefConstructor
}
{
nullptr
}
}
;
static
mozilla
:
:
Module
:
:
ContractIDEntry
kPrefContracts
[
]
=
{
{
NS_PREFSERVICE_CONTRACTID
&
kPrefServiceCID
}
{
NS_PREFLOCALIZEDSTRING_CONTRACTID
&
kPrefLocalizedStringCID
}
{
NS_RELATIVEFILEPREF_CONTRACTID
&
kRelativeFilePrefCID
}
{
nullptr
}
}
;
static
void
UnloadPrefsModule
(
)
{
Preferences
:
:
Shutdown
(
)
;
}
static
const
mozilla
:
:
Module
kPrefModule
=
{
mozilla
:
:
Module
:
:
kVersion
kPrefCIDs
kPrefContracts
nullptr
nullptr
nullptr
UnloadPrefsModule
}
;
NSMODULE_DEFN
(
nsPrefModule
)
=
&
kPrefModule
;
