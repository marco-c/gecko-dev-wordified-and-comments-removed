#
include
<
ctype
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
"
SharedPrefMap
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
ArenaAllocatorExtensions
.
h
"
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
dom
/
PContent
.
h
"
#
include
"
mozilla
/
dom
/
RemoteType
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPrefsAll
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
URLPreloader
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsCategoryManagerUtils
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefLocalizedString
.
h
"
#
include
"
nsIRelativeFilePref
.
h
"
#
include
"
nsISafeOutputStream
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIZipReader
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsQuickSort
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsRelativeFilePref
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsXPCOMCID
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsZipArchive
.
h
"
#
include
"
plbase64
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
plstr
.
h
"
#
include
"
prlink
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
ifdef
MOZ_BACKGROUNDTASKS
#
include
"
mozilla
/
BackgroundTasks
.
h
"
#
endif
#
ifdef
DEBUG
#
include
<
map
>
#
endif
#
ifdef
MOZ_MEMORY
#
include
"
mozmemory
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
windows
.
h
"
#
endif
using
namespace
mozilla
;
using
ipc
:
:
FileDescriptor
;
#
ifdef
DEBUG
#
define
ENSURE_PARENT_PROCESS
(
func
pref
)
\
do
{
\
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
\
nsPrintfCString
msg
(
\
"
ENSURE_PARENT_PROCESS
:
called
%
s
on
%
s
in
a
non
-
parent
process
"
\
func
pref
)
;
\
NS_ERROR
(
msg
.
get
(
)
)
;
\
return
NS_ERROR_NOT_AVAILABLE
;
\
}
\
}
while
(
0
)
#
else
#
define
ENSURE_PARENT_PROCESS
(
func
pref
)
\
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
\
return
NS_ERROR_NOT_AVAILABLE
;
\
}
#
endif
namespace
mozilla
:
:
StaticPrefs
{
static
void
InitAll
(
)
;
static
void
StartObservingAlwaysPrefs
(
)
;
static
void
InitOncePrefs
(
)
;
static
void
InitStaticPrefsFromShared
(
)
;
static
void
RegisterOncePrefs
(
SharedPrefMapBuilder
&
aBuilder
)
;
static
void
ShutdownAlwaysPrefs
(
)
;
}
typedef
nsTArray
<
nsCString
>
PrefSaveData
;
static
const
uint32_t
MAX_PREF_LENGTH
=
1
*
1024
*
1024
;
static
const
uint32_t
MAX_ADVISABLE_PREF_LENGTH
=
4
*
1024
;
static
void
SerializeAndAppendString
(
const
nsCString
&
aChars
nsCString
&
aStr
)
{
aStr
.
AppendInt
(
uint64_t
(
aChars
.
Length
(
)
)
)
;
aStr
.
Append
(
'
/
'
)
;
aStr
.
Append
(
aChars
)
;
}
static
char
*
DeserializeString
(
char
*
aChars
nsCString
&
aStr
)
{
char
*
p
=
aChars
;
uint32_t
length
=
strtol
(
p
&
p
10
)
;
MOZ_ASSERT
(
p
[
0
]
=
=
'
/
'
)
;
p
+
+
;
aStr
.
Assign
(
p
length
)
;
p
+
=
length
;
return
p
;
}
union
PrefValue
{
const
char
*
mStringVal
;
int32_t
mIntVal
;
bool
mBoolVal
;
PrefValue
(
)
=
default
;
explicit
PrefValue
(
bool
aVal
)
:
mBoolVal
(
aVal
)
{
}
explicit
PrefValue
(
int32_t
aVal
)
:
mIntVal
(
aVal
)
{
}
explicit
PrefValue
(
const
char
*
aVal
)
:
mStringVal
(
aVal
)
{
}
bool
Equals
(
PrefType
aType
PrefValue
aValue
)
{
switch
(
aType
)
{
case
PrefType
:
:
String
:
{
if
(
mStringVal
&
&
aValue
.
mStringVal
)
{
return
strcmp
(
mStringVal
aValue
.
mStringVal
)
=
=
0
;
}
if
(
!
mStringVal
&
&
!
aValue
.
mStringVal
)
{
return
true
;
}
return
false
;
}
case
PrefType
:
:
Int
:
return
mIntVal
=
=
aValue
.
mIntVal
;
case
PrefType
:
:
Bool
:
return
mBoolVal
=
=
aValue
.
mBoolVal
;
default
:
MOZ_CRASH
(
"
Unhandled
enum
value
"
)
;
}
}
template
<
typename
T
>
T
Get
(
)
const
;
void
Init
(
PrefType
aNewType
PrefValue
aNewValue
)
{
if
(
aNewType
=
=
PrefType
:
:
String
)
{
MOZ_ASSERT
(
aNewValue
.
mStringVal
)
;
aNewValue
.
mStringVal
=
moz_xstrdup
(
aNewValue
.
mStringVal
)
;
}
*
this
=
aNewValue
;
}
void
Clear
(
PrefType
aType
)
{
if
(
aType
=
=
PrefType
:
:
String
)
{
free
(
const_cast
<
char
*
>
(
mStringVal
)
)
;
}
mStringVal
=
nullptr
;
}
void
Replace
(
bool
aHasValue
PrefType
aOldType
PrefType
aNewType
PrefValue
aNewValue
)
{
if
(
aHasValue
)
{
Clear
(
aOldType
)
;
}
Init
(
aNewType
aNewValue
)
;
}
void
ToDomPrefValue
(
PrefType
aType
dom
:
:
PrefValue
*
aDomValue
)
{
switch
(
aType
)
{
case
PrefType
:
:
String
:
*
aDomValue
=
nsDependentCString
(
mStringVal
)
;
return
;
case
PrefType
:
:
Int
:
*
aDomValue
=
mIntVal
;
return
;
case
PrefType
:
:
Bool
:
*
aDomValue
=
mBoolVal
;
return
;
default
:
MOZ_CRASH
(
)
;
}
}
PrefType
FromDomPrefValue
(
const
dom
:
:
PrefValue
&
aDomValue
)
{
switch
(
aDomValue
.
type
(
)
)
{
case
dom
:
:
PrefValue
:
:
TnsCString
:
mStringVal
=
aDomValue
.
get_nsCString
(
)
.
get
(
)
;
return
PrefType
:
:
String
;
case
dom
:
:
PrefValue
:
:
Tint32_t
:
mIntVal
=
aDomValue
.
get_int32_t
(
)
;
return
PrefType
:
:
Int
;
case
dom
:
:
PrefValue
:
:
Tbool
:
mBoolVal
=
aDomValue
.
get_bool
(
)
;
return
PrefType
:
:
Bool
;
default
:
MOZ_CRASH
(
)
;
}
}
void
SerializeAndAppend
(
PrefType
aType
nsCString
&
aStr
)
{
switch
(
aType
)
{
case
PrefType
:
:
Bool
:
aStr
.
Append
(
mBoolVal
?
'
T
'
:
'
F
'
)
;
break
;
case
PrefType
:
:
Int
:
aStr
.
AppendInt
(
mIntVal
)
;
break
;
case
PrefType
:
:
String
:
{
SerializeAndAppendString
(
nsDependentCString
(
mStringVal
)
aStr
)
;
break
;
}
case
PrefType
:
:
None
:
default
:
MOZ_CRASH
(
)
;
}
}
static
char
*
Deserialize
(
PrefType
aType
char
*
aStr
Maybe
<
dom
:
:
PrefValue
>
*
aDomValue
)
{
char
*
p
=
aStr
;
switch
(
aType
)
{
case
PrefType
:
:
Bool
:
if
(
*
p
=
=
'
T
'
)
{
*
aDomValue
=
Some
(
true
)
;
}
else
if
(
*
p
=
=
'
F
'
)
{
*
aDomValue
=
Some
(
false
)
;
}
else
{
*
aDomValue
=
Some
(
false
)
;
NS_ERROR
(
"
bad
bool
pref
value
"
)
;
}
p
+
+
;
return
p
;
case
PrefType
:
:
Int
:
{
*
aDomValue
=
Some
(
int32_t
(
strtol
(
p
&
p
10
)
)
)
;
return
p
;
}
case
PrefType
:
:
String
:
{
nsCString
str
;
p
=
DeserializeString
(
p
str
)
;
*
aDomValue
=
Some
(
str
)
;
return
p
;
}
default
:
MOZ_CRASH
(
)
;
}
}
}
;
template
<
>
bool
PrefValue
:
:
Get
(
)
const
{
return
mBoolVal
;
}
template
<
>
int32_t
PrefValue
:
:
Get
(
)
const
{
return
mIntVal
;
}
template
<
>
nsDependentCString
PrefValue
:
:
Get
(
)
const
{
return
nsDependentCString
(
mStringVal
)
;
}
#
ifdef
DEBUG
const
char
*
PrefTypeToString
(
PrefType
aType
)
{
switch
(
aType
)
{
case
PrefType
:
:
None
:
return
"
none
"
;
case
PrefType
:
:
String
:
return
"
string
"
;
case
PrefType
:
:
Int
:
return
"
int
"
;
case
PrefType
:
:
Bool
:
return
"
bool
"
;
default
:
MOZ_CRASH
(
"
Unhandled
enum
value
"
)
;
}
}
#
endif
static
void
StrEscape
(
const
char
*
aOriginal
nsCString
&
aResult
)
{
if
(
aOriginal
=
=
nullptr
)
{
aResult
.
AssignLiteral
(
"
\
"
\
"
"
)
;
return
;
}
const
char
*
p
;
aResult
.
Assign
(
'
"
'
)
;
for
(
p
=
aOriginal
;
*
p
;
+
+
p
)
{
switch
(
*
p
)
{
case
'
\
n
'
:
aResult
.
AppendLiteral
(
"
\
\
n
"
)
;
break
;
case
'
\
r
'
:
aResult
.
AppendLiteral
(
"
\
\
r
"
)
;
break
;
case
'
\
\
'
:
aResult
.
AppendLiteral
(
"
\
\
\
\
"
)
;
break
;
case
'
\
"
'
:
aResult
.
AppendLiteral
(
"
\
\
\
"
"
)
;
break
;
default
:
aResult
.
Append
(
*
p
)
;
break
;
}
}
aResult
.
Append
(
'
"
'
)
;
}
namespace
mozilla
{
struct
PrefsSizes
{
PrefsSizes
(
)
:
mHashTable
(
0
)
mPrefValues
(
0
)
mStringValues
(
0
)
mRootBranches
(
0
)
mPrefNameArena
(
0
)
mCallbacksObjects
(
0
)
mCallbacksDomains
(
0
)
mMisc
(
0
)
{
}
size_t
mHashTable
;
size_t
mPrefValues
;
size_t
mStringValues
;
size_t
mRootBranches
;
size_t
mPrefNameArena
;
size_t
mCallbacksObjects
;
size_t
mCallbacksDomains
;
size_t
mMisc
;
}
;
}
static
StaticRefPtr
<
SharedPrefMap
>
gSharedMap
;
typedef
ArenaAllocator
<
4096
1
>
NameArena
;
static
NameArena
*
sPrefNameArena
;
static
inline
NameArena
&
PrefNameArena
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sPrefNameArena
)
{
sPrefNameArena
=
new
NameArena
(
)
;
}
return
*
sPrefNameArena
;
}
class
PrefWrapper
;
class
Pref
;
static
bool
ShouldSanitizePreference
(
const
Pref
*
const
aPref
bool
aIsWebContentProcess
=
true
)
;
static
bool
gContentProcessPrefsAreInited
=
false
;
class
Pref
{
public
:
explicit
Pref
(
const
nsACString
&
aName
)
:
mName
(
ArenaStrdup
(
aName
PrefNameArena
(
)
)
aName
.
Length
(
)
)
mType
(
static_cast
<
uint32_t
>
(
PrefType
:
:
None
)
)
mIsSticky
(
false
)
mIsLocked
(
false
)
mIsSanitized
(
false
)
mHasDefaultValue
(
false
)
mHasUserValue
(
false
)
mIsSkippedByIteration
(
false
)
mDefaultValue
(
)
mUserValue
(
)
{
}
~
Pref
(
)
{
mDefaultValue
.
Clear
(
Type
(
)
)
;
mUserValue
.
Clear
(
Type
(
)
)
;
}
const
char
*
Name
(
)
const
{
return
mName
.
get
(
)
;
}
const
nsDependentCString
&
NameString
(
)
const
{
return
mName
;
}
PrefType
Type
(
)
const
{
return
static_cast
<
PrefType
>
(
mType
)
;
}
void
SetType
(
PrefType
aType
)
{
mType
=
static_cast
<
uint32_t
>
(
aType
)
;
}
bool
IsType
(
PrefType
aType
)
const
{
return
Type
(
)
=
=
aType
;
}
bool
IsTypeNone
(
)
const
{
return
IsType
(
PrefType
:
:
None
)
;
}
bool
IsTypeString
(
)
const
{
return
IsType
(
PrefType
:
:
String
)
;
}
bool
IsTypeInt
(
)
const
{
return
IsType
(
PrefType
:
:
Int
)
;
}
bool
IsTypeBool
(
)
const
{
return
IsType
(
PrefType
:
:
Bool
)
;
}
bool
IsLocked
(
)
const
{
return
mIsLocked
;
}
void
SetIsLocked
(
bool
aValue
)
{
mIsLocked
=
aValue
;
}
bool
IsSkippedByIteration
(
)
const
{
return
mIsSkippedByIteration
;
}
void
SetIsSkippedByIteration
(
bool
aValue
)
{
mIsSkippedByIteration
=
aValue
;
}
bool
IsSticky
(
)
const
{
return
mIsSticky
;
}
bool
IsSanitized
(
)
const
{
return
mIsSanitized
;
}
bool
HasDefaultValue
(
)
const
{
return
mHasDefaultValue
;
}
bool
HasUserValue
(
)
const
{
return
mHasUserValue
;
}
template
<
typename
T
>
void
AddToMap
(
SharedPrefMapBuilder
&
aMap
)
{
MOZ_ASSERT
(
!
ShouldSanitizePreference
(
this
true
)
)
;
aMap
.
Add
(
NameString
(
)
{
HasDefaultValue
(
)
HasUserValue
(
)
IsSticky
(
)
IsLocked
(
)
false
IsSkippedByIteration
(
)
}
HasDefaultValue
(
)
?
mDefaultValue
.
Get
<
T
>
(
)
:
T
(
)
HasUserValue
(
)
?
mUserValue
.
Get
<
T
>
(
)
:
T
(
)
)
;
}
void
AddToMap
(
SharedPrefMapBuilder
&
aMap
)
{
if
(
IsTypeBool
(
)
)
{
AddToMap
<
bool
>
(
aMap
)
;
}
else
if
(
IsTypeInt
(
)
)
{
AddToMap
<
int32_t
>
(
aMap
)
;
}
else
if
(
IsTypeString
(
)
)
{
AddToMap
<
nsDependentCString
>
(
aMap
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
preference
type
"
)
;
}
}
bool
GetBoolValue
(
PrefValueKind
aKind
=
PrefValueKind
:
:
User
)
const
{
MOZ_ASSERT
(
IsTypeBool
(
)
)
;
MOZ_ASSERT
(
aKind
=
=
PrefValueKind
:
:
Default
?
HasDefaultValue
(
)
:
HasUserValue
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
&
&
sCrashOnBlocklistedPref
&
&
gContentProcessPrefsAreInited
&
&
ShouldSanitizePreference
(
this
XRE_IsContentProcess
(
)
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Should
not
access
the
preference
'
%
s
'
in
the
Content
Processes
"
Name
(
)
)
;
}
return
aKind
=
=
PrefValueKind
:
:
Default
?
mDefaultValue
.
mBoolVal
:
mUserValue
.
mBoolVal
;
}
int32_t
GetIntValue
(
PrefValueKind
aKind
=
PrefValueKind
:
:
User
)
const
{
MOZ_ASSERT
(
IsTypeInt
(
)
)
;
MOZ_ASSERT
(
aKind
=
=
PrefValueKind
:
:
Default
?
HasDefaultValue
(
)
:
HasUserValue
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
&
&
sCrashOnBlocklistedPref
&
&
gContentProcessPrefsAreInited
&
&
ShouldSanitizePreference
(
this
XRE_IsContentProcess
(
)
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Should
not
access
the
preference
'
%
s
'
in
the
Content
Processes
"
Name
(
)
)
;
}
return
aKind
=
=
PrefValueKind
:
:
Default
?
mDefaultValue
.
mIntVal
:
mUserValue
.
mIntVal
;
}
const
char
*
GetBareStringValue
(
PrefValueKind
aKind
=
PrefValueKind
:
:
User
)
const
{
MOZ_ASSERT
(
IsTypeString
(
)
)
;
MOZ_ASSERT
(
aKind
=
=
PrefValueKind
:
:
Default
?
HasDefaultValue
(
)
:
HasUserValue
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
&
&
sCrashOnBlocklistedPref
&
&
gContentProcessPrefsAreInited
&
&
ShouldSanitizePreference
(
this
XRE_IsContentProcess
(
)
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Should
not
access
the
preference
'
%
s
'
in
the
Content
Processes
"
Name
(
)
)
;
}
return
aKind
=
=
PrefValueKind
:
:
Default
?
mDefaultValue
.
mStringVal
:
mUserValue
.
mStringVal
;
}
nsDependentCString
GetStringValue
(
PrefValueKind
aKind
=
PrefValueKind
:
:
User
)
const
{
return
nsDependentCString
(
GetBareStringValue
(
aKind
)
)
;
}
void
ToDomPref
(
dom
:
:
Pref
*
aDomPref
bool
aIsDestinationContentProcess
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
aDomPref
-
>
name
(
)
=
mName
;
aDomPref
-
>
isLocked
(
)
=
mIsLocked
;
aDomPref
-
>
isSanitized
(
)
=
ShouldSanitizePreference
(
this
aIsDestinationContentProcess
)
;
if
(
mHasDefaultValue
)
{
aDomPref
-
>
defaultValue
(
)
=
Some
(
dom
:
:
PrefValue
(
)
)
;
mDefaultValue
.
ToDomPrefValue
(
Type
(
)
&
aDomPref
-
>
defaultValue
(
)
.
ref
(
)
)
;
}
else
{
aDomPref
-
>
defaultValue
(
)
=
Nothing
(
)
;
}
if
(
mHasUserValue
&
&
!
(
aDomPref
-
>
isSanitized
(
)
&
&
sOmitBlocklistedPrefValues
)
)
{
aDomPref
-
>
userValue
(
)
=
Some
(
dom
:
:
PrefValue
(
)
)
;
mUserValue
.
ToDomPrefValue
(
Type
(
)
&
aDomPref
-
>
userValue
(
)
.
ref
(
)
)
;
}
else
{
aDomPref
-
>
userValue
(
)
=
Nothing
(
)
;
}
MOZ_ASSERT
(
aDomPref
-
>
defaultValue
(
)
.
isNothing
(
)
|
|
aDomPref
-
>
userValue
(
)
.
isNothing
(
)
|
|
(
mIsSanitized
&
&
sOmitBlocklistedPrefValues
)
|
|
(
aDomPref
-
>
defaultValue
(
)
.
ref
(
)
.
type
(
)
=
=
aDomPref
-
>
userValue
(
)
.
ref
(
)
.
type
(
)
)
)
;
}
void
FromDomPref
(
const
dom
:
:
Pref
&
aDomPref
bool
*
aValueChanged
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
mName
=
=
aDomPref
.
name
(
)
)
;
mIsLocked
=
aDomPref
.
isLocked
(
)
;
mIsSanitized
=
aDomPref
.
isSanitized
(
)
;
const
Maybe
<
dom
:
:
PrefValue
>
&
defaultValue
=
aDomPref
.
defaultValue
(
)
;
bool
defaultValueChanged
=
false
;
if
(
defaultValue
.
isSome
(
)
)
{
PrefValue
value
;
PrefType
type
=
value
.
FromDomPrefValue
(
defaultValue
.
ref
(
)
)
;
if
(
!
ValueMatches
(
PrefValueKind
:
:
Default
type
value
)
)
{
mDefaultValue
.
Replace
(
mHasDefaultValue
Type
(
)
type
value
)
;
SetType
(
type
)
;
mHasDefaultValue
=
true
;
defaultValueChanged
=
true
;
}
}
const
Maybe
<
dom
:
:
PrefValue
>
&
userValue
=
aDomPref
.
userValue
(
)
;
bool
userValueChanged
=
false
;
if
(
userValue
.
isSome
(
)
)
{
PrefValue
value
;
PrefType
type
=
value
.
FromDomPrefValue
(
userValue
.
ref
(
)
)
;
if
(
!
ValueMatches
(
PrefValueKind
:
:
User
type
value
)
)
{
mUserValue
.
Replace
(
mHasUserValue
Type
(
)
type
value
)
;
SetType
(
type
)
;
mHasUserValue
=
true
;
userValueChanged
=
true
;
}
}
else
if
(
mHasUserValue
)
{
ClearUserValue
(
)
;
userValueChanged
=
true
;
}
if
(
userValueChanged
|
|
(
defaultValueChanged
&
&
!
mHasUserValue
)
)
{
*
aValueChanged
=
true
;
}
}
void
FromWrapper
(
PrefWrapper
&
aWrapper
)
;
bool
HasAdvisablySizedValues
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
IsTypeString
(
)
)
{
return
true
;
}
if
(
mHasDefaultValue
&
&
strlen
(
mDefaultValue
.
mStringVal
)
>
MAX_ADVISABLE_PREF_LENGTH
)
{
return
false
;
}
if
(
mHasUserValue
&
&
strlen
(
mUserValue
.
mStringVal
)
>
MAX_ADVISABLE_PREF_LENGTH
)
{
return
false
;
}
return
true
;
}
private
:
bool
ValueMatches
(
PrefValueKind
aKind
PrefType
aType
PrefValue
aValue
)
{
return
IsType
(
aType
)
&
&
(
aKind
=
=
PrefValueKind
:
:
Default
?
mHasDefaultValue
&
&
mDefaultValue
.
Equals
(
aType
aValue
)
:
mHasUserValue
&
&
mUserValue
.
Equals
(
aType
aValue
)
)
;
}
public
:
void
ClearUserValue
(
)
{
mUserValue
.
Clear
(
Type
(
)
)
;
mHasUserValue
=
false
;
}
nsresult
SetDefaultValue
(
PrefType
aType
PrefValue
aValue
bool
aIsSticky
bool
aIsLocked
bool
*
aValueChanged
)
{
if
(
!
IsType
(
aType
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
IsLocked
(
)
)
{
if
(
aIsLocked
)
{
SetIsLocked
(
true
)
;
}
if
(
!
ValueMatches
(
PrefValueKind
:
:
Default
aType
aValue
)
)
{
mDefaultValue
.
Replace
(
mHasDefaultValue
Type
(
)
aType
aValue
)
;
mHasDefaultValue
=
true
;
if
(
aIsSticky
)
{
mIsSticky
=
true
;
}
if
(
!
mHasUserValue
)
{
*
aValueChanged
=
true
;
}
}
}
return
NS_OK
;
}
nsresult
SetUserValue
(
PrefType
aType
PrefValue
aValue
bool
aFromInit
bool
*
aValueChanged
)
{
if
(
mHasDefaultValue
&
&
!
IsType
(
aType
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
ValueMatches
(
PrefValueKind
:
:
Default
aType
aValue
)
&
&
!
mIsSticky
&
&
!
aFromInit
)
{
if
(
mHasUserValue
)
{
ClearUserValue
(
)
;
if
(
!
IsLocked
(
)
)
{
*
aValueChanged
=
true
;
}
}
}
else
if
(
!
ValueMatches
(
PrefValueKind
:
:
User
aType
aValue
)
)
{
mUserValue
.
Replace
(
mHasUserValue
Type
(
)
aType
aValue
)
;
SetType
(
aType
)
;
mHasUserValue
=
true
;
if
(
!
IsLocked
(
)
)
{
*
aValueChanged
=
true
;
}
}
return
NS_OK
;
}
void
SerializeAndAppend
(
nsCString
&
aStr
bool
aSanitizeUserValue
)
{
switch
(
Type
(
)
)
{
case
PrefType
:
:
Bool
:
aStr
.
Append
(
'
B
'
)
;
break
;
case
PrefType
:
:
Int
:
aStr
.
Append
(
'
I
'
)
;
break
;
case
PrefType
:
:
String
:
{
aStr
.
Append
(
'
S
'
)
;
break
;
}
case
PrefType
:
:
None
:
default
:
MOZ_CRASH
(
)
;
}
aStr
.
Append
(
mIsLocked
?
'
L
'
:
'
-
'
)
;
aStr
.
Append
(
aSanitizeUserValue
?
'
S
'
:
'
-
'
)
;
aStr
.
Append
(
'
:
'
)
;
SerializeAndAppendString
(
mName
aStr
)
;
aStr
.
Append
(
'
:
'
)
;
if
(
mHasDefaultValue
)
{
mDefaultValue
.
SerializeAndAppend
(
Type
(
)
aStr
)
;
}
aStr
.
Append
(
'
:
'
)
;
if
(
mHasUserValue
&
&
!
(
aSanitizeUserValue
&
&
sOmitBlocklistedPrefValues
)
)
{
mUserValue
.
SerializeAndAppend
(
Type
(
)
aStr
)
;
}
aStr
.
Append
(
'
\
n
'
)
;
}
static
char
*
Deserialize
(
char
*
aStr
dom
:
:
Pref
*
aDomPref
)
{
char
*
p
=
aStr
;
PrefType
type
;
if
(
*
p
=
=
'
B
'
)
{
type
=
PrefType
:
:
Bool
;
}
else
if
(
*
p
=
=
'
I
'
)
{
type
=
PrefType
:
:
Int
;
}
else
if
(
*
p
=
=
'
S
'
)
{
type
=
PrefType
:
:
String
;
}
else
{
NS_ERROR
(
"
bad
pref
type
"
)
;
type
=
PrefType
:
:
None
;
}
p
+
+
;
bool
isLocked
;
if
(
*
p
=
=
'
L
'
)
{
isLocked
=
true
;
}
else
if
(
*
p
=
=
'
-
'
)
{
isLocked
=
false
;
}
else
{
NS_ERROR
(
"
bad
pref
locked
status
"
)
;
isLocked
=
false
;
}
p
+
+
;
bool
isSanitized
;
if
(
*
p
=
=
'
S
'
)
{
isSanitized
=
true
;
}
else
if
(
*
p
=
=
'
-
'
)
{
isSanitized
=
false
;
}
else
{
NS_ERROR
(
"
bad
pref
sanitized
status
"
)
;
isSanitized
=
false
;
}
p
+
+
;
MOZ_ASSERT
(
*
p
=
=
'
:
'
)
;
p
+
+
;
nsCString
name
;
p
=
DeserializeString
(
p
name
)
;
MOZ_ASSERT
(
*
p
=
=
'
:
'
)
;
p
+
+
;
Maybe
<
dom
:
:
PrefValue
>
maybeDefaultValue
;
if
(
*
p
!
=
'
:
'
)
{
dom
:
:
PrefValue
defaultValue
;
p
=
PrefValue
:
:
Deserialize
(
type
p
&
maybeDefaultValue
)
;
}
MOZ_ASSERT
(
*
p
=
=
'
:
'
)
;
p
+
+
;
Maybe
<
dom
:
:
PrefValue
>
maybeUserValue
;
if
(
*
p
!
=
'
\
n
'
)
{
dom
:
:
PrefValue
userValue
;
p
=
PrefValue
:
:
Deserialize
(
type
p
&
maybeUserValue
)
;
}
MOZ_ASSERT
(
*
p
=
=
'
\
n
'
)
;
p
+
+
;
*
aDomPref
=
dom
:
:
Pref
(
name
isLocked
isSanitized
maybeDefaultValue
maybeUserValue
)
;
return
p
;
}
void
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
PrefsSizes
&
aSizes
)
{
aSizes
.
mPrefValues
+
=
aMallocSizeOf
(
this
)
;
if
(
IsTypeString
(
)
)
{
if
(
mHasDefaultValue
)
{
aSizes
.
mStringValues
+
=
aMallocSizeOf
(
mDefaultValue
.
mStringVal
)
;
}
if
(
mHasUserValue
)
{
aSizes
.
mStringValues
+
=
aMallocSizeOf
(
mUserValue
.
mStringVal
)
;
}
}
}
void
RelocateName
(
NameArena
*
aArena
)
{
mName
.
Rebind
(
ArenaStrdup
(
mName
.
get
(
)
*
aArena
)
mName
.
Length
(
)
)
;
}
private
:
nsDependentCString
mName
;
uint32_t
mType
:
2
;
uint32_t
mIsSticky
:
1
;
uint32_t
mIsLocked
:
1
;
uint32_t
mIsSanitized
:
1
;
uint32_t
mHasDefaultValue
:
1
;
uint32_t
mHasUserValue
:
1
;
uint32_t
mIsSkippedByIteration
:
1
;
PrefValue
mDefaultValue
;
PrefValue
mUserValue
;
}
;
struct
PrefHasher
{
using
Key
=
UniquePtr
<
Pref
>
;
using
Lookup
=
const
char
*
;
static
HashNumber
hash
(
const
Lookup
aLookup
)
{
return
HashString
(
aLookup
)
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
aLookup
)
{
if
(
!
aLookup
|
|
!
aKey
-
>
Name
(
)
)
{
return
false
;
}
return
strcmp
(
aLookup
aKey
-
>
Name
(
)
)
=
=
0
;
}
}
;
using
PrefWrapperBase
=
Variant
<
Pref
*
SharedPrefMap
:
:
Pref
>
;
class
MOZ_STACK_CLASS
PrefWrapper
:
public
PrefWrapperBase
{
using
SharedPref
=
const
SharedPrefMap
:
:
Pref
;
public
:
MOZ_IMPLICIT
PrefWrapper
(
Pref
*
aPref
)
:
PrefWrapperBase
(
AsVariant
(
aPref
)
)
{
}
MOZ_IMPLICIT
PrefWrapper
(
const
SharedPrefMap
:
:
Pref
&
aPref
)
:
PrefWrapperBase
(
AsVariant
(
aPref
)
)
{
}
bool
IsType
(
PrefType
aType
)
const
{
return
Type
(
)
=
=
aType
;
}
bool
IsTypeNone
(
)
const
{
return
IsType
(
PrefType
:
:
None
)
;
}
bool
IsTypeString
(
)
const
{
return
IsType
(
PrefType
:
:
String
)
;
}
bool
IsTypeInt
(
)
const
{
return
IsType
(
PrefType
:
:
Int
)
;
}
bool
IsTypeBool
(
)
const
{
return
IsType
(
PrefType
:
:
Bool
)
;
}
#
define
FORWARD
(
retType
method
)
\
retType
method
(
)
const
{
\
struct
Matcher
{
\
retType
operator
(
)
(
const
Pref
*
aPref
)
{
return
aPref
-
>
method
(
)
;
}
\
retType
operator
(
)
(
SharedPref
&
aPref
)
{
return
aPref
.
method
(
)
;
}
\
}
;
\
return
match
(
Matcher
(
)
)
;
\
}
FORWARD
(
bool
IsLocked
)
FORWARD
(
bool
IsSanitized
)
FORWARD
(
bool
IsSticky
)
FORWARD
(
bool
HasDefaultValue
)
FORWARD
(
bool
HasUserValue
)
FORWARD
(
const
char
*
Name
)
FORWARD
(
nsCString
NameString
)
FORWARD
(
PrefType
Type
)
#
undef
FORWARD
#
define
FORWARD
(
retType
method
)
\
retType
method
(
PrefValueKind
aKind
=
PrefValueKind
:
:
User
)
const
{
\
struct
Matcher
{
\
PrefValueKind
mKind
;
\
\
retType
operator
(
)
(
const
Pref
*
aPref
)
{
return
aPref
-
>
method
(
mKind
)
;
}
\
retType
operator
(
)
(
SharedPref
&
aPref
)
{
return
aPref
.
method
(
mKind
)
;
}
\
}
;
\
return
match
(
Matcher
{
aKind
}
)
;
\
}
FORWARD
(
bool
GetBoolValue
)
FORWARD
(
int32_t
GetIntValue
)
FORWARD
(
nsCString
GetStringValue
)
FORWARD
(
const
char
*
GetBareStringValue
)
#
undef
FORWARD
PrefValue
GetValue
(
PrefValueKind
aKind
=
PrefValueKind
:
:
User
)
const
{
switch
(
Type
(
)
)
{
case
PrefType
:
:
Bool
:
return
PrefValue
{
GetBoolValue
(
aKind
)
}
;
case
PrefType
:
:
Int
:
return
PrefValue
{
GetIntValue
(
aKind
)
}
;
case
PrefType
:
:
String
:
return
PrefValue
{
GetBareStringValue
(
aKind
)
}
;
case
PrefType
:
:
None
:
if
(
!
XRE_IsParentProcess
(
)
&
&
sCrashOnBlocklistedPref
&
&
gContentProcessPrefsAreInited
&
&
ShouldSanitizePreference
(
Name
(
)
XRE_IsContentProcess
(
)
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Should
not
access
the
preference
'
%
s
'
in
the
Content
Processes
"
Name
(
)
)
;
}
[
[
fallthrough
]
]
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
pref
type
"
)
;
return
PrefValue
{
}
;
}
}
Result
<
PrefValueKind
nsresult
>
WantValueKind
(
PrefType
aType
PrefValueKind
aKind
)
const
{
if
(
this
-
>
is
<
Pref
*
>
(
)
&
&
!
XRE_IsParentProcess
(
)
&
&
sCrashOnBlocklistedPref
&
&
gContentProcessPrefsAreInited
&
&
ShouldSanitizePreference
(
this
-
>
as
<
Pref
*
>
(
)
XRE_IsContentProcess
(
)
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Should
not
access
the
preference
'
%
s
'
in
the
Content
Processes
"
Name
(
)
)
;
}
else
if
(
!
this
-
>
is
<
Pref
*
>
(
)
)
{
MOZ_ASSERT
(
!
(
!
XRE_IsParentProcess
(
)
&
&
gContentProcessPrefsAreInited
&
&
ShouldSanitizePreference
(
Name
(
)
XRE_IsContentProcess
(
)
)
)
"
We
should
never
have
a
sanitized
SharedPrefMap
:
:
Pref
.
"
)
;
}
if
(
Type
(
)
!
=
aType
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
aKind
=
=
PrefValueKind
:
:
Default
|
|
IsLocked
(
)
|
|
!
HasUserValue
(
)
)
{
if
(
!
HasDefaultValue
(
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
return
PrefValueKind
:
:
Default
;
}
return
PrefValueKind
:
:
User
;
}
nsresult
GetValue
(
PrefValueKind
aKind
bool
*
aResult
)
const
{
PrefValueKind
kind
;
MOZ_TRY_VAR
(
kind
WantValueKind
(
PrefType
:
:
Bool
aKind
)
)
;
*
aResult
=
GetBoolValue
(
kind
)
;
return
NS_OK
;
}
nsresult
GetValue
(
PrefValueKind
aKind
int32_t
*
aResult
)
const
{
PrefValueKind
kind
;
MOZ_TRY_VAR
(
kind
WantValueKind
(
PrefType
:
:
Int
aKind
)
)
;
*
aResult
=
GetIntValue
(
kind
)
;
return
NS_OK
;
}
nsresult
GetValue
(
PrefValueKind
aKind
uint32_t
*
aResult
)
const
{
return
GetValue
(
aKind
reinterpret_cast
<
int32_t
*
>
(
aResult
)
)
;
}
nsresult
GetValue
(
PrefValueKind
aKind
float
*
aResult
)
const
{
nsAutoCString
result
;
nsresult
rv
=
GetValue
(
aKind
result
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aResult
=
result
.
ToFloat
(
&
rv
)
;
}
return
rv
;
}
nsresult
GetValue
(
PrefValueKind
aKind
nsACString
&
aResult
)
const
{
PrefValueKind
kind
;
MOZ_TRY_VAR
(
kind
WantValueKind
(
PrefType
:
:
String
aKind
)
)
;
aResult
=
GetStringValue
(
kind
)
;
return
NS_OK
;
}
nsresult
GetValue
(
PrefValueKind
aKind
nsACString
*
aResult
)
const
{
return
GetValue
(
aKind
*
aResult
)
;
}
bool
UserValueToStringForSaving
(
nsCString
&
aStr
)
{
if
(
HasUserValue
(
)
&
&
(
!
ValueMatches
(
PrefValueKind
:
:
Default
Type
(
)
GetValue
(
)
)
|
|
IsSticky
(
)
)
)
{
if
(
IsTypeString
(
)
)
{
StrEscape
(
GetStringValue
(
)
.
get
(
)
aStr
)
;
}
else
if
(
IsTypeInt
(
)
)
{
aStr
.
AppendInt
(
GetIntValue
(
)
)
;
}
else
if
(
IsTypeBool
(
)
)
{
aStr
=
GetBoolValue
(
)
?
"
true
"
:
"
false
"
;
}
return
true
;
}
return
false
;
}
bool
Matches
(
PrefType
aType
PrefValueKind
aKind
PrefValue
&
aValue
bool
aIsSticky
bool
aIsLocked
)
const
{
return
(
ValueMatches
(
aKind
aType
aValue
)
&
&
aIsSticky
=
=
IsSticky
(
)
&
&
aIsLocked
=
=
IsLocked
(
)
)
;
}
bool
ValueMatches
(
PrefValueKind
aKind
PrefType
aType
const
PrefValue
&
aValue
)
const
{
if
(
!
IsType
(
aType
)
)
{
return
false
;
}
if
(
!
(
aKind
=
=
PrefValueKind
:
:
Default
?
HasDefaultValue
(
)
:
HasUserValue
(
)
)
)
{
return
false
;
}
switch
(
aType
)
{
case
PrefType
:
:
Bool
:
return
GetBoolValue
(
aKind
)
=
=
aValue
.
mBoolVal
;
case
PrefType
:
:
Int
:
return
GetIntValue
(
aKind
)
=
=
aValue
.
mIntVal
;
case
PrefType
:
:
String
:
return
strcmp
(
GetBareStringValue
(
aKind
)
aValue
.
mStringVal
)
=
=
0
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
preference
type
"
)
;
return
false
;
}
}
}
;
void
Pref
:
:
FromWrapper
(
PrefWrapper
&
aWrapper
)
{
MOZ_ASSERT
(
aWrapper
.
is
<
SharedPrefMap
:
:
Pref
>
(
)
)
;
auto
pref
=
aWrapper
.
as
<
SharedPrefMap
:
:
Pref
>
(
)
;
MOZ_ASSERT
(
IsTypeNone
(
)
)
;
MOZ_ASSERT
(
mName
=
=
pref
.
NameString
(
)
)
;
mType
=
uint32_t
(
pref
.
Type
(
)
)
;
mIsLocked
=
pref
.
IsLocked
(
)
;
mIsSanitized
=
pref
.
IsSanitized
(
)
;
mIsSticky
=
pref
.
IsSticky
(
)
;
mHasDefaultValue
=
pref
.
HasDefaultValue
(
)
;
mHasUserValue
=
pref
.
HasUserValue
(
)
;
if
(
mHasDefaultValue
)
{
mDefaultValue
.
Init
(
Type
(
)
aWrapper
.
GetValue
(
PrefValueKind
:
:
Default
)
)
;
}
if
(
mHasUserValue
)
{
mUserValue
.
Init
(
Type
(
)
aWrapper
.
GetValue
(
PrefValueKind
:
:
User
)
)
;
}
}
class
CallbackNode
{
public
:
CallbackNode
(
const
nsACString
&
aDomain
PrefChangedFunc
aFunc
void
*
aData
Preferences
:
:
MatchKind
aMatchKind
)
:
mDomain
(
AsVariant
(
nsCString
(
aDomain
)
)
)
mFunc
(
aFunc
)
mData
(
aData
)
mNextAndMatchKind
(
aMatchKind
)
{
}
CallbackNode
(
const
char
*
*
aDomains
PrefChangedFunc
aFunc
void
*
aData
Preferences
:
:
MatchKind
aMatchKind
)
:
mDomain
(
AsVariant
(
aDomains
)
)
mFunc
(
aFunc
)
mData
(
aData
)
mNextAndMatchKind
(
aMatchKind
)
{
}
const
Variant
<
nsCString
const
char
*
*
>
&
Domain
(
)
const
{
return
mDomain
;
}
PrefChangedFunc
Func
(
)
const
{
return
mFunc
;
}
void
ClearFunc
(
)
{
mFunc
=
nullptr
;
}
void
*
Data
(
)
const
{
return
mData
;
}
Preferences
:
:
MatchKind
MatchKind
(
)
const
{
return
static_cast
<
Preferences
:
:
MatchKind
>
(
mNextAndMatchKind
&
kMatchKindMask
)
;
}
bool
DomainIs
(
const
nsACString
&
aDomain
)
const
{
return
mDomain
.
is
<
nsCString
>
(
)
&
&
mDomain
.
as
<
nsCString
>
(
)
=
=
aDomain
;
}
bool
DomainIs
(
const
char
*
*
aPrefs
)
const
{
return
mDomain
=
=
AsVariant
(
aPrefs
)
;
}
bool
Matches
(
const
nsACString
&
aPrefName
)
const
{
auto
match
=
[
&
]
(
const
nsACString
&
aStr
)
{
return
MatchKind
(
)
=
=
Preferences
:
:
ExactMatch
?
aPrefName
=
=
aStr
:
StringBeginsWith
(
aPrefName
aStr
)
;
}
;
if
(
mDomain
.
is
<
nsCString
>
(
)
)
{
return
match
(
mDomain
.
as
<
nsCString
>
(
)
)
;
}
for
(
const
char
*
*
ptr
=
mDomain
.
as
<
const
char
*
*
>
(
)
;
*
ptr
;
ptr
+
+
)
{
if
(
match
(
nsDependentCString
(
*
ptr
)
)
)
{
return
true
;
}
}
return
false
;
}
CallbackNode
*
Next
(
)
const
{
return
reinterpret_cast
<
CallbackNode
*
>
(
mNextAndMatchKind
&
kNextMask
)
;
}
void
SetNext
(
CallbackNode
*
aNext
)
{
uintptr_t
matchKind
=
mNextAndMatchKind
&
kMatchKindMask
;
mNextAndMatchKind
=
reinterpret_cast
<
uintptr_t
>
(
aNext
)
;
MOZ_ASSERT
(
(
mNextAndMatchKind
&
kMatchKindMask
)
=
=
0
)
;
mNextAndMatchKind
|
=
matchKind
;
}
void
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
PrefsSizes
&
aSizes
)
{
aSizes
.
mCallbacksObjects
+
=
aMallocSizeOf
(
this
)
;
if
(
mDomain
.
is
<
nsCString
>
(
)
)
{
aSizes
.
mCallbacksDomains
+
=
mDomain
.
as
<
nsCString
>
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
}
private
:
static
const
uintptr_t
kMatchKindMask
=
uintptr_t
(
0x1
)
;
static
const
uintptr_t
kNextMask
=
~
kMatchKindMask
;
Variant
<
nsCString
const
char
*
*
>
mDomain
;
PrefChangedFunc
mFunc
;
void
*
mData
;
uintptr_t
mNextAndMatchKind
;
}
;
using
PrefsHashTable
=
HashSet
<
UniquePtr
<
Pref
>
PrefHasher
>
;
static
inline
PrefsHashTable
*
&
HashTable
(
bool
aOffMainThread
=
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
|
|
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
static
PrefsHashTable
*
sHashTable
=
nullptr
;
return
sHashTable
;
}
#
ifdef
DEBUG
typedef
std
:
:
function
<
void
(
)
>
AntiFootgunCallback
;
struct
CompareStr
{
bool
operator
(
)
(
char
const
*
a
char
const
*
b
)
const
{
return
std
:
:
strcmp
(
a
b
)
<
0
;
}
}
;
typedef
std
:
:
map
<
const
char
*
AntiFootgunCallback
CompareStr
>
AntiFootgunMap
;
static
AntiFootgunMap
*
gOnceStaticPrefsAntiFootgun
;
#
endif
static
CallbackNode
*
gFirstCallback
=
nullptr
;
static
CallbackNode
*
gLastPriorityNode
=
nullptr
;
#
ifdef
DEBUG
#
define
ACCESS_COUNTS
#
endif
#
ifdef
ACCESS_COUNTS
using
AccessCountsHashTable
=
nsTHashMap
<
nsCStringHashKey
uint32_t
>
;
static
AccessCountsHashTable
*
gAccessCounts
=
nullptr
;
static
void
AddAccessCount
(
const
nsACString
&
aPrefName
)
{
if
(
NS_IsMainThread
(
)
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
uint32_t
&
count
=
gAccessCounts
-
>
LookupOrInsert
(
aPrefName
)
;
count
+
+
;
}
}
static
void
AddAccessCount
(
const
char
*
aPrefName
)
{
AddAccessCount
(
nsDependentCString
(
aPrefName
)
)
;
}
#
else
static
void
MOZ_MAYBE_UNUSED
AddAccessCount
(
const
nsACString
&
aPrefName
)
{
}
static
void
AddAccessCount
(
const
char
*
aPrefName
)
{
}
#
endif
static
bool
gCallbacksInProgress
=
false
;
static
bool
gShouldCleanupDeadNodes
=
false
;
class
PrefsHashIter
{
using
Iterator
=
decltype
(
HashTable
(
)
-
>
modIter
(
)
)
;
using
ElemType
=
Pref
*
;
Iterator
mIter
;
public
:
explicit
PrefsHashIter
(
PrefsHashTable
*
aTable
)
:
mIter
(
aTable
-
>
modIter
(
)
)
{
}
class
Elem
{
friend
class
PrefsHashIter
;
PrefsHashIter
&
mParent
;
bool
mDone
;
Elem
(
PrefsHashIter
&
aIter
bool
aDone
)
:
mParent
(
aIter
)
mDone
(
aDone
)
{
}
Iterator
&
Iter
(
)
{
return
mParent
.
mIter
;
}
public
:
Elem
&
operator
*
(
)
{
return
*
this
;
}
ElemType
get
(
)
{
if
(
mDone
)
{
return
nullptr
;
}
return
Iter
(
)
.
get
(
)
.
get
(
)
;
}
ElemType
get
(
)
const
{
return
const_cast
<
Elem
*
>
(
this
)
-
>
get
(
)
;
}
ElemType
operator
-
>
(
)
{
return
get
(
)
;
}
ElemType
operator
-
>
(
)
const
{
return
get
(
)
;
}
operator
ElemType
(
)
{
return
get
(
)
;
}
void
Remove
(
)
{
Iter
(
)
.
remove
(
)
;
}
Elem
&
operator
+
+
(
)
{
MOZ_ASSERT
(
!
mDone
)
;
Iter
(
)
.
next
(
)
;
mDone
=
Iter
(
)
.
done
(
)
;
return
*
this
;
}
bool
operator
!
=
(
Elem
&
other
)
{
return
mDone
!
=
other
.
mDone
|
|
this
-
>
get
(
)
!
=
other
.
get
(
)
;
}
}
;
Elem
begin
(
)
{
return
Elem
(
*
this
mIter
.
done
(
)
)
;
}
Elem
end
(
)
{
return
Elem
(
*
this
true
)
;
}
}
;
class
PrefsIter
{
using
Iterator
=
decltype
(
HashTable
(
)
-
>
iter
(
)
)
;
using
ElemType
=
PrefWrapper
;
using
HashElem
=
PrefsHashIter
:
:
Elem
;
using
SharedElem
=
SharedPrefMap
:
:
Pref
;
using
ElemTypeVariant
=
Variant
<
HashElem
SharedElem
>
;
SharedPrefMap
*
mSharedMap
;
PrefsHashTable
*
mHashTable
;
PrefsHashIter
mIter
;
ElemTypeVariant
mPos
;
ElemTypeVariant
mEnd
;
Maybe
<
PrefWrapper
>
mEntry
;
public
:
PrefsIter
(
PrefsHashTable
*
aHashTable
SharedPrefMap
*
aSharedMap
)
:
mSharedMap
(
aSharedMap
)
mHashTable
(
aHashTable
)
mIter
(
aHashTable
)
mPos
(
AsVariant
(
mIter
.
begin
(
)
)
)
mEnd
(
AsVariant
(
mIter
.
end
(
)
)
)
{
if
(
Done
(
)
)
{
NextIterator
(
)
;
}
}
private
:
#
define
MATCH
(
type
.
.
.
)
\
do
{
\
struct
Matcher
{
\
PrefsIter
&
mIter
;
\
type
operator
(
)
(
HashElem
&
pos
)
{
\
HashElem
&
end
MOZ_MAYBE_UNUSED
=
mIter
.
mEnd
.
as
<
HashElem
>
(
)
;
\
__VA_ARGS__
;
\
}
\
type
operator
(
)
(
SharedElem
&
pos
)
{
\
SharedElem
&
end
MOZ_MAYBE_UNUSED
=
mIter
.
mEnd
.
as
<
SharedElem
>
(
)
;
\
__VA_ARGS__
;
\
}
\
}
;
\
return
mPos
.
match
(
Matcher
{
*
this
}
)
;
\
}
while
(
0
)
;
bool
Done
(
)
{
MATCH
(
bool
return
pos
=
=
end
)
;
}
PrefWrapper
MakeEntry
(
)
{
MATCH
(
PrefWrapper
return
PrefWrapper
(
pos
)
)
;
}
void
NextEntry
(
)
{
mEntry
.
reset
(
)
;
MATCH
(
void
+
+
pos
)
;
}
#
undef
MATCH
bool
Next
(
)
{
NextEntry
(
)
;
return
!
Done
(
)
|
|
NextIterator
(
)
;
}
bool
NextIterator
(
)
{
if
(
mPos
.
is
<
HashElem
>
(
)
&
&
mSharedMap
)
{
mPos
=
AsVariant
(
mSharedMap
-
>
begin
(
)
)
;
mEnd
=
AsVariant
(
mSharedMap
-
>
end
(
)
)
;
return
!
Done
(
)
;
}
return
false
;
}
bool
IteratingBase
(
)
{
return
mPos
.
is
<
SharedElem
>
(
)
;
}
PrefWrapper
&
Entry
(
)
{
MOZ_ASSERT
(
!
Done
(
)
)
;
if
(
!
mEntry
.
isSome
(
)
)
{
mEntry
.
emplace
(
MakeEntry
(
)
)
;
}
return
mEntry
.
ref
(
)
;
}
public
:
class
Elem
{
friend
class
PrefsIter
;
PrefsIter
&
mParent
;
bool
mDone
;
Elem
(
PrefsIter
&
aIter
bool
aDone
)
:
mParent
(
aIter
)
mDone
(
aDone
)
{
SkipDuplicates
(
)
;
}
void
Next
(
)
{
mDone
=
!
mParent
.
Next
(
)
;
}
void
SkipDuplicates
(
)
{
while
(
!
mDone
&
&
(
mParent
.
IteratingBase
(
)
?
mParent
.
mHashTable
-
>
has
(
ref
(
)
.
Name
(
)
)
:
ref
(
)
.
IsTypeNone
(
)
)
)
{
Next
(
)
;
}
}
public
:
Elem
&
operator
*
(
)
{
return
*
this
;
}
ElemType
&
ref
(
)
{
return
mParent
.
Entry
(
)
;
}
const
ElemType
&
ref
(
)
const
{
return
const_cast
<
Elem
*
>
(
this
)
-
>
ref
(
)
;
}
ElemType
*
operator
-
>
(
)
{
return
&
ref
(
)
;
}
const
ElemType
*
operator
-
>
(
)
const
{
return
&
ref
(
)
;
}
operator
ElemType
(
)
{
return
ref
(
)
;
}
Elem
&
operator
+
+
(
)
{
MOZ_ASSERT
(
!
mDone
)
;
Next
(
)
;
SkipDuplicates
(
)
;
return
*
this
;
}
bool
operator
!
=
(
Elem
&
other
)
{
if
(
mDone
!
=
other
.
mDone
)
{
return
true
;
}
if
(
mDone
)
{
return
false
;
}
return
&
this
-
>
ref
(
)
!
=
&
other
.
ref
(
)
;
}
}
;
Elem
begin
(
)
{
return
{
*
this
Done
(
)
}
;
}
Elem
end
(
)
{
return
{
*
this
true
}
;
}
}
;
static
Pref
*
pref_HashTableLookup
(
const
char
*
aPrefName
)
;
static
void
NotifyCallbacks
(
const
nsCString
&
aPrefName
const
PrefWrapper
*
aPref
=
nullptr
)
;
static
void
NotifyCallbacks
(
const
nsCString
&
aPrefName
const
PrefWrapper
&
aPref
)
{
NotifyCallbacks
(
aPrefName
&
aPref
)
;
}
constexpr
size_t
kHashTableInitialLengthParent
=
3000
;
constexpr
size_t
kHashTableInitialLengthContent
=
64
;
static
PrefSaveData
pref_savePrefs
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
PrefSaveData
savedPrefs
(
HashTable
(
)
-
>
count
(
)
)
;
for
(
auto
&
pref
:
PrefsIter
(
HashTable
(
)
gSharedMap
)
)
{
nsAutoCString
prefValueStr
;
if
(
!
pref
-
>
UserValueToStringForSaving
(
prefValueStr
)
)
{
continue
;
}
nsAutoCString
prefNameStr
;
StrEscape
(
pref
-
>
Name
(
)
prefNameStr
)
;
nsPrintfCString
str
(
"
user_pref
(
%
s
%
s
)
;
"
prefNameStr
.
get
(
)
prefValueStr
.
get
(
)
)
;
savedPrefs
.
AppendElement
(
str
)
;
}
return
savedPrefs
;
}
static
Pref
*
pref_HashTableLookup
(
const
char
*
aPrefName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
|
|
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
MOZ_ASSERT_IF
(
!
XRE_IsParentProcess
(
)
gContentProcessPrefsAreInited
)
;
auto
p
=
HashTable
(
)
-
>
readonlyThreadsafeLookup
(
aPrefName
)
;
return
p
?
p
-
>
get
(
)
:
nullptr
;
}
static
const
PrefWrapper
*
gCallbackPref
;
Maybe
<
PrefWrapper
>
pref_SharedLookup
(
const
char
*
aPrefName
)
{
MOZ_DIAGNOSTIC_ASSERT
(
gSharedMap
"
gSharedMap
must
be
initialized
"
)
;
if
(
Maybe
<
SharedPrefMap
:
:
Pref
>
pref
=
gSharedMap
-
>
Get
(
aPrefName
)
)
{
return
Some
(
*
pref
)
;
}
return
Nothing
(
)
;
}
Maybe
<
PrefWrapper
>
pref_Lookup
(
const
char
*
aPrefName
bool
aIncludeTypeNone
=
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
|
|
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
AddAccessCount
(
aPrefName
)
;
if
(
gCallbackPref
&
&
strcmp
(
aPrefName
gCallbackPref
-
>
Name
(
)
)
=
=
0
)
{
return
Some
(
*
gCallbackPref
)
;
}
if
(
Pref
*
pref
=
pref_HashTableLookup
(
aPrefName
)
)
{
if
(
aIncludeTypeNone
|
|
!
pref
-
>
IsTypeNone
(
)
|
|
pref
-
>
IsSanitized
(
)
)
{
return
Some
(
pref
)
;
}
}
else
if
(
gSharedMap
)
{
return
pref_SharedLookup
(
aPrefName
)
;
}
return
Nothing
(
)
;
}
static
Result
<
Pref
*
nsresult
>
pref_LookupForModify
(
const
nsCString
&
aPrefName
const
std
:
:
function
<
bool
(
const
PrefWrapper
&
)
>
&
aCheckFn
)
{
Maybe
<
PrefWrapper
>
wrapper
=
pref_Lookup
(
aPrefName
.
get
(
)
true
)
;
if
(
wrapper
.
isNothing
(
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aCheckFn
(
*
wrapper
)
)
{
return
nullptr
;
}
if
(
wrapper
-
>
is
<
Pref
*
>
(
)
)
{
return
wrapper
-
>
as
<
Pref
*
>
(
)
;
}
Pref
*
pref
=
new
Pref
(
aPrefName
)
;
if
(
!
HashTable
(
)
-
>
putNew
(
aPrefName
.
get
(
)
pref
)
)
{
delete
pref
;
return
Err
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
pref
-
>
FromWrapper
(
*
wrapper
)
;
return
pref
;
}
static
nsresult
pref_SetPref
(
const
nsCString
&
aPrefName
PrefType
aType
PrefValueKind
aKind
PrefValue
aValue
bool
aIsSticky
bool
aIsLocked
bool
aFromInit
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
XPCOMShutdownThreads
)
)
{
printf
(
"
pref_SetPref
:
Attempt
to
write
pref
%
s
after
XPCOMShutdownThreads
"
"
started
.
\
n
"
aPrefName
.
get
(
)
)
;
if
(
nsContentUtils
:
:
IsInitialized
(
)
)
{
xpc_DumpJSStack
(
true
true
false
)
;
}
MOZ_ASSERT
(
false
"
Late
preference
writes
should
be
avoided
.
"
)
;
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
if
(
!
HashTable
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
Pref
*
pref
=
nullptr
;
if
(
gSharedMap
)
{
auto
result
=
pref_LookupForModify
(
aPrefName
[
&
]
(
const
PrefWrapper
&
aWrapper
)
{
return
!
aWrapper
.
Matches
(
aType
aKind
aValue
aIsSticky
aIsLocked
)
;
}
)
;
if
(
result
.
isOk
(
)
&
&
!
(
pref
=
result
.
unwrap
(
)
)
)
{
return
NS_OK
;
}
}
if
(
!
pref
)
{
auto
p
=
HashTable
(
)
-
>
lookupForAdd
(
aPrefName
.
get
(
)
)
;
if
(
!
p
)
{
pref
=
new
Pref
(
aPrefName
)
;
pref
-
>
SetType
(
aType
)
;
if
(
!
HashTable
(
)
-
>
add
(
p
pref
)
)
{
delete
pref
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
{
pref
=
p
-
>
get
(
)
;
}
}
bool
valueChanged
=
false
;
nsresult
rv
;
if
(
aKind
=
=
PrefValueKind
:
:
Default
)
{
rv
=
pref
-
>
SetDefaultValue
(
aType
aValue
aIsSticky
aIsLocked
&
valueChanged
)
;
}
else
{
MOZ_ASSERT
(
!
aIsLocked
)
;
rv
=
pref
-
>
SetUserValue
(
aType
aValue
aFromInit
&
valueChanged
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
Rejected
attempt
to
change
type
of
pref
%
s
'
s
%
s
value
"
"
from
%
s
to
%
s
"
aPrefName
.
get
(
)
(
aKind
=
=
PrefValueKind
:
:
Default
)
?
"
default
"
:
"
user
"
PrefTypeToString
(
pref
-
>
Type
(
)
)
PrefTypeToString
(
aType
)
)
.
get
(
)
)
;
return
rv
;
}
if
(
valueChanged
)
{
if
(
aKind
=
=
PrefValueKind
:
:
User
)
{
Preferences
:
:
HandleDirty
(
)
;
}
NotifyCallbacks
(
aPrefName
PrefWrapper
(
pref
)
)
;
}
return
NS_OK
;
}
static
CallbackNode
*
pref_RemoveCallbackNode
(
CallbackNode
*
aNode
CallbackNode
*
aPrevNode
)
{
MOZ_ASSERT
(
!
aPrevNode
|
|
aPrevNode
-
>
Next
(
)
=
=
aNode
)
;
MOZ_ASSERT
(
aPrevNode
|
|
gFirstCallback
=
=
aNode
)
;
MOZ_ASSERT
(
!
gCallbacksInProgress
)
;
CallbackNode
*
next_node
=
aNode
-
>
Next
(
)
;
if
(
aPrevNode
)
{
aPrevNode
-
>
SetNext
(
next_node
)
;
}
else
{
gFirstCallback
=
next_node
;
}
if
(
gLastPriorityNode
=
=
aNode
)
{
gLastPriorityNode
=
aPrevNode
;
}
delete
aNode
;
return
next_node
;
}
static
void
NotifyCallbacks
(
const
nsCString
&
aPrefName
const
PrefWrapper
*
aPref
)
{
bool
reentered
=
gCallbacksInProgress
;
gCallbackPref
=
aPref
;
auto
cleanup
=
MakeScopeExit
(
[
]
(
)
{
gCallbackPref
=
nullptr
;
}
)
;
gCallbacksInProgress
=
true
;
for
(
CallbackNode
*
node
=
gFirstCallback
;
node
;
node
=
node
-
>
Next
(
)
)
{
if
(
node
-
>
Func
(
)
)
{
if
(
node
-
>
Matches
(
aPrefName
)
)
{
(
node
-
>
Func
(
)
)
(
aPrefName
.
get
(
)
node
-
>
Data
(
)
)
;
}
}
}
gCallbacksInProgress
=
reentered
;
if
(
gShouldCleanupDeadNodes
&
&
!
gCallbacksInProgress
)
{
CallbackNode
*
prev_node
=
nullptr
;
CallbackNode
*
node
=
gFirstCallback
;
while
(
node
)
{
if
(
!
node
-
>
Func
(
)
)
{
node
=
pref_RemoveCallbackNode
(
node
prev_node
)
;
}
else
{
prev_node
=
node
;
node
=
node
-
>
Next
(
)
;
}
}
gShouldCleanupDeadNodes
=
false
;
}
#
ifdef
DEBUG
if
(
XRE_IsParentProcess
(
)
&
&
!
StaticPrefs
:
:
preferences_force_disable_check_once_policy
(
)
&
&
(
StaticPrefs
:
:
preferences_check_once_policy
(
)
|
|
xpc
:
:
IsInAutomation
(
)
)
)
{
MOZ_ASSERT
(
gOnceStaticPrefsAntiFootgun
)
;
auto
search
=
gOnceStaticPrefsAntiFootgun
-
>
find
(
aPrefName
.
get
(
)
)
;
if
(
search
!
=
gOnceStaticPrefsAntiFootgun
-
>
end
(
)
)
{
(
search
-
>
second
)
(
)
;
}
}
#
endif
}
extern
"
C
"
{
typedef
void
(
*
PrefsParserPrefFn
)
(
const
char
*
aPrefName
PrefType
aType
PrefValueKind
aKind
PrefValue
aValue
bool
aIsSticky
bool
aIsLocked
)
;
typedef
void
(
*
PrefsParserErrorFn
)
(
const
char
*
aMsg
)
;
bool
prefs_parser_parse
(
const
char
*
aPath
PrefValueKind
aKind
const
char
*
aBuf
size_t
aLen
PrefsParserPrefFn
aPrefFn
PrefsParserErrorFn
aErrorFn
)
;
}
class
Parser
{
public
:
Parser
(
)
=
default
;
~
Parser
(
)
=
default
;
bool
Parse
(
PrefValueKind
aKind
const
char
*
aPath
const
nsCString
&
aBuf
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
prefs_parser_parse
(
aPath
aKind
aBuf
.
get
(
)
aBuf
.
Length
(
)
HandlePref
HandleError
)
;
}
private
:
static
void
HandlePref
(
const
char
*
aPrefName
PrefType
aType
PrefValueKind
aKind
PrefValue
aValue
bool
aIsSticky
bool
aIsLocked
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
pref_SetPref
(
nsDependentCString
(
aPrefName
)
aType
aKind
aValue
aIsSticky
aIsLocked
true
)
;
}
static
void
HandleError
(
const
char
*
aMsg
)
{
nsresult
rv
;
nsCOMPtr
<
nsIConsoleService
>
console
=
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
console
-
>
LogStringMessage
(
NS_ConvertUTF8toUTF16
(
aMsg
)
.
get
(
)
)
;
}
#
ifdef
DEBUG
NS_ERROR
(
aMsg
)
;
#
else
printf_stderr
(
"
%
s
\
n
"
aMsg
)
;
#
endif
}
}
;
static
void
TestParseErrorHandlePref
(
const
char
*
aPrefName
PrefType
aType
PrefValueKind
aKind
PrefValue
aValue
bool
aIsSticky
bool
aIsLocked
)
{
}
static
nsCString
gTestParseErrorMsgs
;
static
void
TestParseErrorHandleError
(
const
char
*
aMsg
)
{
gTestParseErrorMsgs
.
Append
(
aMsg
)
;
gTestParseErrorMsgs
.
Append
(
'
\
n
'
)
;
}
void
TestParseError
(
PrefValueKind
aKind
const
char
*
aText
nsCString
&
aErrorMsg
)
{
prefs_parser_parse
(
"
test
"
aKind
aText
strlen
(
aText
)
TestParseErrorHandlePref
TestParseErrorHandleError
)
;
aErrorMsg
.
Assign
(
gTestParseErrorMsgs
)
;
gTestParseErrorMsgs
.
Truncate
(
)
;
}
namespace
mozilla
{
class
PreferenceServiceReporter
;
}
class
PrefCallback
:
public
PLDHashEntryHdr
{
friend
class
mozilla
:
:
PreferenceServiceReporter
;
public
:
typedef
PrefCallback
*
KeyType
;
typedef
const
PrefCallback
*
KeyTypePointer
;
static
const
PrefCallback
*
KeyToPointer
(
PrefCallback
*
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
const
PrefCallback
*
aKey
)
{
uint32_t
hash
=
HashString
(
aKey
-
>
mDomain
)
;
return
AddToHash
(
hash
aKey
-
>
mCanonical
)
;
}
public
:
PrefCallback
(
const
nsACString
&
aDomain
nsIObserver
*
aObserver
nsPrefBranch
*
aBranch
)
:
mDomain
(
aDomain
)
mBranch
(
aBranch
)
mWeakRef
(
nullptr
)
mStrongRef
(
aObserver
)
{
MOZ_COUNT_CTOR
(
PrefCallback
)
;
nsCOMPtr
<
nsISupports
>
canonical
=
do_QueryInterface
(
aObserver
)
;
mCanonical
=
canonical
;
}
PrefCallback
(
const
nsACString
&
aDomain
nsISupportsWeakReference
*
aObserver
nsPrefBranch
*
aBranch
)
:
mDomain
(
aDomain
)
mBranch
(
aBranch
)
mWeakRef
(
do_GetWeakReference
(
aObserver
)
)
mStrongRef
(
nullptr
)
{
MOZ_COUNT_CTOR
(
PrefCallback
)
;
nsCOMPtr
<
nsISupports
>
canonical
=
do_QueryInterface
(
aObserver
)
;
mCanonical
=
canonical
;
}
explicit
PrefCallback
(
const
PrefCallback
*
&
aCopy
)
:
mDomain
(
aCopy
-
>
mDomain
)
mBranch
(
aCopy
-
>
mBranch
)
mWeakRef
(
aCopy
-
>
mWeakRef
)
mStrongRef
(
aCopy
-
>
mStrongRef
)
mCanonical
(
aCopy
-
>
mCanonical
)
{
MOZ_COUNT_CTOR
(
PrefCallback
)
;
}
PrefCallback
(
const
PrefCallback
&
)
=
delete
;
PrefCallback
(
PrefCallback
&
&
)
=
default
;
MOZ_COUNTED_DTOR
(
PrefCallback
)
bool
KeyEquals
(
const
PrefCallback
*
aKey
)
const
{
if
(
IsExpired
(
)
|
|
aKey
-
>
IsExpired
(
)
)
{
return
this
=
=
aKey
;
}
if
(
mCanonical
!
=
aKey
-
>
mCanonical
)
{
return
false
;
}
return
mDomain
.
Equals
(
aKey
-
>
mDomain
)
;
}
PrefCallback
*
GetKey
(
)
const
{
return
const_cast
<
PrefCallback
*
>
(
this
)
;
}
already_AddRefed
<
nsIObserver
>
GetObserver
(
)
const
{
if
(
!
IsWeak
(
)
)
{
nsCOMPtr
<
nsIObserver
>
copy
=
mStrongRef
;
return
copy
.
forget
(
)
;
}
nsCOMPtr
<
nsIObserver
>
observer
=
do_QueryReferent
(
mWeakRef
)
;
return
observer
.
forget
(
)
;
}
const
nsCString
&
GetDomain
(
)
const
{
return
mDomain
;
}
nsPrefBranch
*
GetPrefBranch
(
)
const
{
return
mBranch
;
}
bool
IsExpired
(
)
const
{
if
(
!
IsWeak
(
)
)
return
false
;
nsCOMPtr
<
nsIObserver
>
observer
(
do_QueryReferent
(
mWeakRef
)
)
;
return
!
observer
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mDomain
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
return
n
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
nsCString
mDomain
;
nsPrefBranch
*
mBranch
;
nsWeakPtr
mWeakRef
;
nsCOMPtr
<
nsIObserver
>
mStrongRef
;
nsISupports
*
mCanonical
;
bool
IsWeak
(
)
const
{
return
!
!
mWeakRef
;
}
}
;
class
nsPrefBranch
final
:
public
nsIPrefBranch
public
nsIObserver
public
nsSupportsWeakReference
{
friend
class
mozilla
:
:
PreferenceServiceReporter
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPREFBRANCH
NS_DECL_NSIOBSERVER
nsPrefBranch
(
const
char
*
aPrefRoot
PrefValueKind
aKind
)
;
nsPrefBranch
(
)
=
delete
;
static
void
NotifyObserver
(
const
char
*
aNewpref
void
*
aData
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
using
PrefName
=
nsCString
;
virtual
~
nsPrefBranch
(
)
;
int32_t
GetRootLength
(
)
const
{
return
mPrefRoot
.
Length
(
)
;
}
nsresult
GetDefaultFromPropertiesFile
(
const
char
*
aPrefName
nsAString
&
aReturn
)
;
nsresult
SetCharPrefNoLengthCheck
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
;
nsresult
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
nsAString
&
aValue
)
;
nsresult
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
;
nsresult
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
uint32_t
aLength
)
;
void
RemoveExpiredCallback
(
PrefCallback
*
aCallback
)
;
PrefName
GetPrefName
(
const
char
*
aPrefName
)
const
{
return
GetPrefName
(
nsDependentCString
(
aPrefName
)
)
;
}
PrefName
GetPrefName
(
const
nsACString
&
aPrefName
)
const
;
void
FreeObserverList
(
void
)
;
const
nsCString
mPrefRoot
;
PrefValueKind
mKind
;
bool
mFreeingObserverList
;
nsClassHashtable
<
PrefCallback
PrefCallback
>
mObservers
;
}
;
class
nsPrefLocalizedString
final
:
public
nsIPrefLocalizedString
{
public
:
nsPrefLocalizedString
(
)
;
NS_DECL_ISUPPORTS
NS_FORWARD_NSISUPPORTSPRIMITIVE
(
mUnicodeString
-
>
)
NS_FORWARD_NSISUPPORTSSTRING
(
mUnicodeString
-
>
)
nsresult
Init
(
)
;
private
:
virtual
~
nsPrefLocalizedString
(
)
;
nsCOMPtr
<
nsISupportsString
>
mUnicodeString
;
}
;
nsPrefBranch
:
:
nsPrefBranch
(
const
char
*
aPrefRoot
PrefValueKind
aKind
)
:
mPrefRoot
(
aPrefRoot
)
mKind
(
aKind
)
mFreeingObserverList
(
false
)
mObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
+
+
mRefCnt
;
observerService
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
true
)
;
-
-
mRefCnt
;
}
}
nsPrefBranch
:
:
~
nsPrefBranch
(
)
{
FreeObserverList
(
)
;
}
NS_IMPL_ISUPPORTS
(
nsPrefBranch
nsIPrefBranch
nsIObserver
nsISupportsWeakReference
)
NS_IMETHODIMP
nsPrefBranch
:
:
GetRoot
(
nsACString
&
aRoot
)
{
aRoot
=
mPrefRoot
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetPrefType
(
const
char
*
aPrefName
int32_t
*
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
prefName
=
GetPrefName
(
aPrefName
)
;
*
aRetVal
=
Preferences
:
:
GetType
(
prefName
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetBoolPrefWithDefault
(
const
char
*
aPrefName
bool
aDefaultValue
uint8_t
aArgc
bool
*
aRetVal
)
{
nsresult
rv
=
GetBoolPref
(
aPrefName
aRetVal
)
;
if
(
NS_FAILED
(
rv
)
&
&
aArgc
=
=
1
)
{
*
aRetVal
=
aDefaultValue
;
return
NS_OK
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetBoolPref
(
const
char
*
aPrefName
bool
*
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
GetBool
(
pref
.
get
(
)
aRetVal
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
SetBoolPref
(
const
char
*
aPrefName
bool
aValue
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
SetBool
(
pref
.
get
(
)
aValue
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetFloatPrefWithDefault
(
const
char
*
aPrefName
float
aDefaultValue
uint8_t
aArgc
float
*
aRetVal
)
{
nsresult
rv
=
GetFloatPref
(
aPrefName
aRetVal
)
;
if
(
NS_FAILED
(
rv
)
&
&
aArgc
=
=
1
)
{
*
aRetVal
=
aDefaultValue
;
return
NS_OK
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetFloatPref
(
const
char
*
aPrefName
float
*
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
nsAutoCString
stringVal
;
nsresult
rv
=
GetCharPref
(
aPrefName
stringVal
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aRetVal
=
stringVal
.
ToFloat
(
&
rv
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetCharPrefWithDefault
(
const
char
*
aPrefName
const
nsACString
&
aDefaultValue
uint8_t
aArgc
nsACString
&
aRetVal
)
{
nsresult
rv
=
GetCharPref
(
aPrefName
aRetVal
)
;
if
(
NS_FAILED
(
rv
)
&
&
aArgc
=
=
1
)
{
aRetVal
=
aDefaultValue
;
return
NS_OK
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetCharPref
(
const
char
*
aPrefName
nsACString
&
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
GetCString
(
pref
.
get
(
)
aRetVal
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
SetCharPref
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
{
nsresult
rv
=
CheckSanityOfStringLength
(
aPrefName
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
SetCharPrefNoLengthCheck
(
aPrefName
aValue
)
;
}
nsresult
nsPrefBranch
:
:
SetCharPrefNoLengthCheck
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
SetCString
(
pref
.
get
(
)
aValue
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetStringPref
(
const
char
*
aPrefName
const
nsACString
&
aDefaultValue
uint8_t
aArgc
nsACString
&
aRetVal
)
{
nsCString
utf8String
;
nsresult
rv
=
GetCharPref
(
aPrefName
utf8String
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aRetVal
=
utf8String
;
return
rv
;
}
if
(
aArgc
=
=
1
)
{
aRetVal
=
aDefaultValue
;
return
NS_OK
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
SetStringPref
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
{
nsresult
rv
=
CheckSanityOfStringLength
(
aPrefName
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
SetCharPrefNoLengthCheck
(
aPrefName
aValue
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetIntPrefWithDefault
(
const
char
*
aPrefName
int32_t
aDefaultValue
uint8_t
aArgc
int32_t
*
aRetVal
)
{
nsresult
rv
=
GetIntPref
(
aPrefName
aRetVal
)
;
if
(
NS_FAILED
(
rv
)
&
&
aArgc
=
=
1
)
{
*
aRetVal
=
aDefaultValue
;
return
NS_OK
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetIntPref
(
const
char
*
aPrefName
int32_t
*
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
GetInt
(
pref
.
get
(
)
aRetVal
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
SetIntPref
(
const
char
*
aPrefName
int32_t
aValue
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
SetInt
(
pref
.
get
(
)
aValue
mKind
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetComplexValue
(
const
char
*
aPrefName
const
nsIID
&
aType
void
*
*
aRetVal
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
nsresult
rv
;
nsAutoCString
utf8String
;
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIPrefLocalizedString
)
)
)
{
nsCOMPtr
<
nsIPrefLocalizedString
>
theString
(
do_CreateInstance
(
NS_PREFLOCALIZEDSTRING_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
bool
bNeedDefault
=
false
;
if
(
mKind
=
=
PrefValueKind
:
:
Default
)
{
bNeedDefault
=
true
;
}
else
{
if
(
!
Preferences
:
:
HasUserValue
(
pref
.
get
(
)
)
&
&
!
Preferences
:
:
IsLocked
(
pref
.
get
(
)
)
)
{
bNeedDefault
=
true
;
}
}
if
(
bNeedDefault
)
{
nsAutoString
utf16String
;
rv
=
GetDefaultFromPropertiesFile
(
pref
.
get
(
)
utf16String
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
theString
-
>
SetData
(
utf16String
)
;
}
}
else
{
rv
=
GetCharPref
(
aPrefName
utf8String
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
theString
-
>
SetData
(
NS_ConvertUTF8toUTF16
(
utf8String
)
)
;
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
theString
.
forget
(
reinterpret_cast
<
nsIPrefLocalizedString
*
*
>
(
aRetVal
)
)
;
}
return
rv
;
}
rv
=
GetCharPref
(
aPrefName
utf8String
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIFile
)
)
)
{
ENSURE_PARENT_PROCESS
(
"
GetComplexValue
(
nsIFile
)
"
aPrefName
)
;
nsCOMPtr
<
nsIFile
>
file
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
file
-
>
SetPersistentDescriptor
(
utf8String
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
file
.
forget
(
reinterpret_cast
<
nsIFile
*
*
>
(
aRetVal
)
)
;
return
NS_OK
;
}
}
return
rv
;
}
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIRelativeFilePref
)
)
)
{
ENSURE_PARENT_PROCESS
(
"
GetComplexValue
(
nsIRelativeFilePref
)
"
aPrefName
)
;
nsACString
:
:
const_iterator
keyBegin
strEnd
;
utf8String
.
BeginReading
(
keyBegin
)
;
utf8String
.
EndReading
(
strEnd
)
;
if
(
*
keyBegin
+
+
!
=
'
[
'
)
{
return
NS_ERROR_FAILURE
;
}
nsACString
:
:
const_iterator
keyEnd
(
keyBegin
)
;
if
(
!
FindCharInReadable
(
'
]
'
keyEnd
strEnd
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
key
(
Substring
(
keyBegin
keyEnd
)
)
;
nsCOMPtr
<
nsIFile
>
fromFile
;
nsCOMPtr
<
nsIProperties
>
directoryService
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
directoryService
-
>
Get
(
key
.
get
(
)
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
fromFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
theFile
;
rv
=
NS_NewNativeLocalFile
(
"
"
_ns
true
getter_AddRefs
(
theFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
theFile
-
>
SetRelativeDescriptor
(
fromFile
Substring
(
+
+
keyEnd
strEnd
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIRelativeFilePref
>
relativePref
=
new
nsRelativeFilePref
(
)
;
Unused
<
<
relativePref
-
>
SetFile
(
theFile
)
;
Unused
<
<
relativePref
-
>
SetRelativeToKey
(
key
)
;
relativePref
.
forget
(
reinterpret_cast
<
nsIRelativeFilePref
*
*
>
(
aRetVal
)
)
;
return
NS_OK
;
}
NS_WARNING
(
"
nsPrefBranch
:
:
GetComplexValue
-
Unsupported
interface
type
"
)
;
return
NS_NOINTERFACE
;
}
nsresult
nsPrefBranch
:
:
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
nsAString
&
aValue
)
{
return
CheckSanityOfStringLength
(
aPrefName
aValue
.
Length
(
)
)
;
}
nsresult
nsPrefBranch
:
:
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
nsACString
&
aValue
)
{
return
CheckSanityOfStringLength
(
aPrefName
aValue
.
Length
(
)
)
;
}
nsresult
nsPrefBranch
:
:
CheckSanityOfStringLength
(
const
char
*
aPrefName
const
uint32_t
aLength
)
{
if
(
aLength
>
MAX_PREF_LENGTH
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
aLength
<
=
MAX_ADVISABLE_PREF_LENGTH
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIConsoleService
>
console
=
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
message
(
nsPrintfCString
(
"
Warning
:
attempting
to
write
%
d
bytes
to
preference
%
s
.
This
is
bad
"
"
for
general
performance
and
memory
usage
.
Such
an
amount
of
data
"
"
should
rather
be
written
to
an
external
file
.
This
preference
will
"
"
not
be
sent
to
any
content
processes
.
"
aLength
GetPrefName
(
aPrefName
)
.
get
(
)
)
)
;
rv
=
console
-
>
LogStringMessage
(
NS_ConvertUTF8toUTF16
(
message
)
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
SetComplexValue
(
const
char
*
aPrefName
const
nsIID
&
aType
nsISupports
*
aValue
)
{
ENSURE_PARENT_PROCESS
(
"
SetComplexValue
"
aPrefName
)
;
NS_ENSURE_ARG
(
aPrefName
)
;
nsresult
rv
=
NS_NOINTERFACE
;
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIFile
)
)
)
{
nsCOMPtr
<
nsIFile
>
file
=
do_QueryInterface
(
aValue
)
;
if
(
!
file
)
{
return
NS_NOINTERFACE
;
}
nsAutoCString
descriptorString
;
rv
=
file
-
>
GetPersistentDescriptor
(
descriptorString
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
SetCharPrefNoLengthCheck
(
aPrefName
descriptorString
)
;
}
return
rv
;
}
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIRelativeFilePref
)
)
)
{
nsCOMPtr
<
nsIRelativeFilePref
>
relFilePref
=
do_QueryInterface
(
aValue
)
;
if
(
!
relFilePref
)
{
return
NS_NOINTERFACE
;
}
nsCOMPtr
<
nsIFile
>
file
;
relFilePref
-
>
GetFile
(
getter_AddRefs
(
file
)
)
;
if
(
!
file
)
{
return
NS_NOINTERFACE
;
}
nsAutoCString
relativeToKey
;
(
void
)
relFilePref
-
>
GetRelativeToKey
(
relativeToKey
)
;
nsCOMPtr
<
nsIFile
>
relativeToFile
;
nsCOMPtr
<
nsIProperties
>
directoryService
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
directoryService
-
>
Get
(
relativeToKey
.
get
(
)
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
relativeToFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
relDescriptor
;
rv
=
file
-
>
GetRelativeDescriptor
(
relativeToFile
relDescriptor
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
descriptorString
;
descriptorString
.
Append
(
'
[
'
)
;
descriptorString
.
Append
(
relativeToKey
)
;
descriptorString
.
Append
(
'
]
'
)
;
descriptorString
.
Append
(
relDescriptor
)
;
return
SetCharPrefNoLengthCheck
(
aPrefName
descriptorString
)
;
}
if
(
aType
.
Equals
(
NS_GET_IID
(
nsIPrefLocalizedString
)
)
)
{
nsCOMPtr
<
nsISupportsString
>
theString
=
do_QueryInterface
(
aValue
)
;
if
(
theString
)
{
nsString
wideString
;
rv
=
theString
-
>
GetData
(
wideString
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
CheckSanityOfStringLength
(
aPrefName
wideString
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
SetCharPrefNoLengthCheck
(
aPrefName
NS_ConvertUTF16toUTF8
(
wideString
)
)
;
}
}
return
rv
;
}
NS_WARNING
(
"
nsPrefBranch
:
:
SetComplexValue
-
Unsupported
interface
type
"
)
;
return
NS_NOINTERFACE
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
ClearUserPref
(
const
char
*
aPrefName
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
ClearUser
(
pref
.
get
(
)
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
PrefHasUserValue
(
const
char
*
aPrefName
bool
*
aRetVal
)
{
NS_ENSURE_ARG_POINTER
(
aRetVal
)
;
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
*
aRetVal
=
Preferences
:
:
HasUserValue
(
pref
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
PrefHasDefaultValue
(
const
char
*
aPrefName
bool
*
aRetVal
)
{
NS_ENSURE_ARG_POINTER
(
aRetVal
)
;
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
*
aRetVal
=
Preferences
:
:
HasDefaultValue
(
pref
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
LockPref
(
const
char
*
aPrefName
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
Lock
(
pref
.
get
(
)
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
PrefIsLocked
(
const
char
*
aPrefName
bool
*
aRetVal
)
{
NS_ENSURE_ARG_POINTER
(
aRetVal
)
;
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
*
aRetVal
=
Preferences
:
:
IsLocked
(
pref
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
PrefIsSanitized
(
const
char
*
aPrefName
bool
*
aRetVal
)
{
NS_ENSURE_ARG_POINTER
(
aRetVal
)
;
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
*
aRetVal
=
Preferences
:
:
IsSanitized
(
pref
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
UnlockPref
(
const
char
*
aPrefName
)
{
NS_ENSURE_ARG
(
aPrefName
)
;
const
PrefName
&
pref
=
GetPrefName
(
aPrefName
)
;
return
Preferences
:
:
Unlock
(
pref
.
get
(
)
)
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
ResetBranch
(
const
char
*
aStartingAt
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
DeleteBranch
(
const
char
*
aStartingAt
)
{
ENSURE_PARENT_PROCESS
(
"
DeleteBranch
"
aStartingAt
)
;
NS_ENSURE_ARG
(
aStartingAt
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
HashTable
(
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
const
PrefName
&
pref
=
GetPrefName
(
aStartingAt
)
;
nsAutoCString
branchName
(
pref
.
get
(
)
)
;
if
(
branchName
.
Length
(
)
>
1
&
&
!
StringEndsWith
(
branchName
"
.
"
_ns
)
)
{
branchName
+
=
'
.
'
;
}
const
nsACString
&
branchNameNoDot
=
Substring
(
branchName
0
branchName
.
Length
(
)
-
1
)
;
for
(
auto
iter
=
HashTable
(
)
-
>
modIter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
nsDependentCString
name
(
iter
.
get
(
)
-
>
Name
(
)
)
;
if
(
StringBeginsWith
(
name
branchName
)
|
|
name
.
Equals
(
branchNameNoDot
)
)
{
iter
.
remove
(
)
;
gCallbackPref
=
nullptr
;
}
}
Preferences
:
:
HandleDirty
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
GetChildList
(
const
char
*
aStartingAt
nsTArray
<
nsCString
>
&
aChildArray
)
{
NS_ENSURE_ARG
(
aStartingAt
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AutoTArray
<
nsCString
32
>
prefArray
;
const
PrefName
&
parent
=
GetPrefName
(
aStartingAt
)
;
size_t
parentLen
=
parent
.
Length
(
)
;
for
(
auto
&
pref
:
PrefsIter
(
HashTable
(
)
gSharedMap
)
)
{
if
(
strncmp
(
pref
-
>
Name
(
)
parent
.
get
(
)
parentLen
)
=
=
0
)
{
prefArray
.
AppendElement
(
pref
-
>
NameString
(
)
)
;
}
}
aChildArray
.
SetCapacity
(
prefArray
.
Length
(
)
)
;
for
(
auto
&
element
:
prefArray
)
{
aChildArray
.
AppendElement
(
Substring
(
element
mPrefRoot
.
Length
(
)
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
AddObserverImpl
(
const
nsACString
&
aDomain
nsIObserver
*
aObserver
bool
aHoldWeak
)
{
UniquePtr
<
PrefCallback
>
pCallback
;
NS_ENSURE_ARG
(
aObserver
)
;
const
nsCString
&
prefName
=
GetPrefName
(
aDomain
)
;
if
(
aHoldWeak
)
{
nsCOMPtr
<
nsISupportsWeakReference
>
weakRefFactory
=
do_QueryInterface
(
aObserver
)
;
if
(
!
weakRefFactory
)
{
return
NS_ERROR_INVALID_ARG
;
}
pCallback
=
MakeUnique
<
PrefCallback
>
(
prefName
weakRefFactory
this
)
;
}
else
{
pCallback
=
MakeUnique
<
PrefCallback
>
(
prefName
aObserver
this
)
;
}
mObservers
.
WithEntryHandle
(
pCallback
.
get
(
)
[
&
]
(
auto
&
&
p
)
{
if
(
p
)
{
NS_WARNING
(
"
Ignoring
duplicate
observer
.
"
)
;
}
else
{
Preferences
:
:
RegisterCallback
(
NotifyObserver
prefName
pCallback
.
get
(
)
Preferences
:
:
PrefixMatch
false
)
;
p
.
Insert
(
std
:
:
move
(
pCallback
)
)
;
}
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
RemoveObserverImpl
(
const
nsACString
&
aDomain
nsIObserver
*
aObserver
)
{
NS_ENSURE_ARG
(
aObserver
)
;
nsresult
rv
=
NS_OK
;
if
(
mFreeingObserverList
)
{
return
NS_OK
;
}
const
nsCString
&
prefName
=
GetPrefName
(
aDomain
)
;
PrefCallback
key
(
prefName
aObserver
this
)
;
mozilla
:
:
UniquePtr
<
PrefCallback
>
pCallback
;
mObservers
.
Remove
(
&
key
&
pCallback
)
;
if
(
pCallback
)
{
rv
=
Preferences
:
:
UnregisterCallback
(
NotifyObserver
prefName
pCallback
.
get
(
)
Preferences
:
:
PrefixMatch
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsPrefBranch
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
FreeObserverList
(
)
;
}
return
NS_OK
;
}
void
nsPrefBranch
:
:
NotifyObserver
(
const
char
*
aNewPref
void
*
aData
)
{
PrefCallback
*
pCallback
=
(
PrefCallback
*
)
aData
;
nsCOMPtr
<
nsIObserver
>
observer
=
pCallback
-
>
GetObserver
(
)
;
if
(
!
observer
)
{
pCallback
-
>
GetPrefBranch
(
)
-
>
RemoveExpiredCallback
(
pCallback
)
;
return
;
}
uint32_t
len
=
pCallback
-
>
GetPrefBranch
(
)
-
>
GetRootLength
(
)
;
nsDependentCString
suffix
(
aNewPref
+
len
)
;
observer
-
>
Observe
(
static_cast
<
nsIPrefBranch
*
>
(
pCallback
-
>
GetPrefBranch
(
)
)
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
NS_ConvertASCIItoUTF16
(
suffix
)
.
get
(
)
)
;
}
size_t
nsPrefBranch
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mPrefRoot
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
n
+
=
mObservers
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
entry
:
mObservers
)
{
const
PrefCallback
*
data
=
entry
.
GetWeak
(
)
;
n
+
=
data
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
void
nsPrefBranch
:
:
FreeObserverList
(
)
{
mFreeingObserverList
=
true
;
for
(
auto
iter
=
mObservers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
callback
=
iter
.
UserData
(
)
;
Preferences
:
:
UnregisterCallback
(
nsPrefBranch
:
:
NotifyObserver
callback
-
>
GetDomain
(
)
callback
Preferences
:
:
PrefixMatch
)
;
iter
.
Remove
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
}
mFreeingObserverList
=
false
;
}
void
nsPrefBranch
:
:
RemoveExpiredCallback
(
PrefCallback
*
aCallback
)
{
MOZ_ASSERT
(
aCallback
-
>
IsExpired
(
)
)
;
mObservers
.
Remove
(
aCallback
)
;
}
nsresult
nsPrefBranch
:
:
GetDefaultFromPropertiesFile
(
const
char
*
aPrefName
nsAString
&
aReturn
)
{
nsAutoCString
propertyFileURL
;
nsresult
rv
=
Preferences
:
:
GetCString
(
aPrefName
propertyFileURL
PrefValueKind
:
:
Default
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIStringBundleService
>
bundleService
=
components
:
:
StringBundle
:
:
Service
(
)
;
if
(
!
bundleService
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIStringBundle
>
bundle
;
rv
=
bundleService
-
>
CreateBundle
(
propertyFileURL
.
get
(
)
getter_AddRefs
(
bundle
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
bundle
-
>
GetStringFromName
(
aPrefName
aReturn
)
;
}
nsPrefBranch
:
:
PrefName
nsPrefBranch
:
:
GetPrefName
(
const
nsACString
&
aPrefName
)
const
{
if
(
mPrefRoot
.
IsEmpty
(
)
)
{
return
PrefName
(
PromiseFlatCString
(
aPrefName
)
)
;
}
return
PrefName
(
mPrefRoot
+
aPrefName
)
;
}
nsPrefLocalizedString
:
:
nsPrefLocalizedString
(
)
=
default
;
nsPrefLocalizedString
:
:
~
nsPrefLocalizedString
(
)
=
default
;
NS_IMPL_ISUPPORTS
(
nsPrefLocalizedString
nsIPrefLocalizedString
nsISupportsString
)
nsresult
nsPrefLocalizedString
:
:
Init
(
)
{
nsresult
rv
;
mUnicodeString
=
do_CreateInstance
(
NS_SUPPORTS_STRING_CONTRACTID
&
rv
)
;
return
rv
;
}
NS_IMPL_ISUPPORTS
(
nsRelativeFilePref
nsIRelativeFilePref
)
nsRelativeFilePref
:
:
nsRelativeFilePref
(
)
=
default
;
nsRelativeFilePref
:
:
~
nsRelativeFilePref
(
)
=
default
;
NS_IMETHODIMP
nsRelativeFilePref
:
:
GetFile
(
nsIFile
*
*
aFile
)
{
NS_ENSURE_ARG_POINTER
(
aFile
)
;
*
aFile
=
mFile
;
NS_IF_ADDREF
(
*
aFile
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsRelativeFilePref
:
:
SetFile
(
nsIFile
*
aFile
)
{
mFile
=
aFile
;
return
NS_OK
;
}
NS_IMETHODIMP
nsRelativeFilePref
:
:
GetRelativeToKey
(
nsACString
&
aRelativeToKey
)
{
aRelativeToKey
.
Assign
(
mRelativeToKey
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsRelativeFilePref
:
:
SetRelativeToKey
(
const
nsACString
&
aRelativeToKey
)
{
mRelativeToKey
.
Assign
(
aRelativeToKey
)
;
return
NS_OK
;
}
namespace
mozilla
{
#
define
INITIAL_PREF_FILES
10
static
NS_DEFINE_CID
(
kZipReaderCID
NS_ZIPREADER_CID
)
;
void
Preferences
:
:
HandleDirty
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
HashTable
(
)
|
|
!
sPreferences
)
{
return
;
}
if
(
sPreferences
-
>
mProfileShutdown
)
{
NS_WARNING
(
"
Setting
user
pref
after
profile
shutdown
.
"
)
;
return
;
}
if
(
!
sPreferences
-
>
mDirty
)
{
sPreferences
-
>
mDirty
=
true
;
if
(
sPreferences
-
>
mCurrentFile
&
&
sPreferences
-
>
AllowOffMainThreadSave
(
)
&
&
!
sPreferences
-
>
mSavePending
)
{
sPreferences
-
>
mSavePending
=
true
;
static
const
int
PREF_DELAY_MS
=
500
;
NS_DelayedDispatchToCurrentThread
(
NewRunnableMethod
(
"
Preferences
:
:
SavePrefFileAsynchronous
"
sPreferences
.
get
(
)
&
Preferences
:
:
SavePrefFileAsynchronous
)
PREF_DELAY_MS
)
;
}
}
}
static
nsresult
openPrefFile
(
nsIFile
*
aFile
PrefValueKind
aKind
)
;
static
nsresult
parsePrefData
(
const
nsCString
&
aData
PrefValueKind
aKind
)
;
static
const
char
kPrefFileHeader
[
]
=
"
/
/
Mozilla
User
Preferences
"
NS_LINEBREAK
NS_LINEBREAK
"
/
/
DO
NOT
EDIT
THIS
FILE
.
"
NS_LINEBREAK
"
/
/
"
NS_LINEBREAK
"
/
/
If
you
make
changes
to
this
file
while
the
application
is
running
"
NS_LINEBREAK
"
/
/
the
changes
will
be
overwritten
when
the
application
exits
.
"
NS_LINEBREAK
"
/
/
"
NS_LINEBREAK
"
/
/
To
change
a
preference
value
you
can
either
:
"
NS_LINEBREAK
"
/
/
-
modify
it
via
the
UI
(
e
.
g
.
via
about
:
config
in
the
browser
)
;
or
"
NS_LINEBREAK
"
/
/
-
set
it
within
a
user
.
js
file
in
your
profile
.
"
NS_LINEBREAK
NS_LINEBREAK
;
StaticRefPtr
<
Preferences
>
Preferences
:
:
sPreferences
;
bool
Preferences
:
:
sShutdown
=
false
;
static
int32_t
sAllowOMTPrefWrite
=
-
1
;
class
PreferencesWriter
final
{
public
:
PreferencesWriter
(
)
=
default
;
static
nsresult
Write
(
nsIFile
*
aFile
PrefSaveData
&
aPrefs
)
{
nsCOMPtr
<
nsIOutputStream
>
outStreamSink
;
nsCOMPtr
<
nsIOutputStream
>
outStream
;
uint32_t
writeAmount
;
nsresult
rv
;
rv
=
NS_NewSafeLocalFileOutputStream
(
getter_AddRefs
(
outStreamSink
)
aFile
-
1
0600
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
NS_NewBufferedOutputStream
(
getter_AddRefs
(
outStream
)
outStreamSink
.
forget
(
)
4096
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
struct
CharComparator
{
bool
LessThan
(
const
nsCString
&
aA
const
nsCString
&
aB
)
const
{
return
aA
<
aB
;
}
bool
Equals
(
const
nsCString
&
aA
const
nsCString
&
aB
)
const
{
return
aA
=
=
aB
;
}
}
;
aPrefs
.
Sort
(
CharComparator
(
)
)
;
outStream
-
>
Write
(
kPrefFileHeader
sizeof
(
kPrefFileHeader
)
-
1
&
writeAmount
)
;
for
(
nsCString
&
pref
:
aPrefs
)
{
outStream
-
>
Write
(
pref
.
get
(
)
pref
.
Length
(
)
&
writeAmount
)
;
outStream
-
>
Write
(
NS_LINEBREAK
NS_LINEBREAK_LEN
&
writeAmount
)
;
}
nsCOMPtr
<
nsISafeOutputStream
>
safeStream
=
do_QueryInterface
(
outStream
)
;
MOZ_ASSERT
(
safeStream
"
expected
a
safe
output
stream
!
"
)
;
if
(
safeStream
)
{
rv
=
safeStream
-
>
Finish
(
)
;
}
#
ifdef
DEBUG
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
save
prefs
file
!
possible
data
loss
"
)
;
}
#
endif
return
rv
;
}
static
void
Flush
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sPendingWriteCount
>
=
0
)
;
mozilla
:
:
SpinEventLoopUntil
(
"
PreferencesWriter
:
:
Flush
"
_ns
[
]
(
)
{
return
sPendingWriteCount
<
=
0
;
}
)
;
}
static
Atomic
<
PrefSaveData
*
>
sPendingWriteData
;
static
Atomic
<
int
>
sPendingWriteCount
;
static
StaticMutex
sWritingToFile
MOZ_UNANNOTATED
;
}
;
Atomic
<
PrefSaveData
*
>
PreferencesWriter
:
:
sPendingWriteData
(
nullptr
)
;
Atomic
<
int
>
PreferencesWriter
:
:
sPendingWriteCount
(
0
)
;
StaticMutex
PreferencesWriter
:
:
sWritingToFile
;
class
PWRunnable
:
public
Runnable
{
public
:
explicit
PWRunnable
(
nsIFile
*
aFile
)
:
Runnable
(
"
PWRunnable
"
)
mFile
(
aFile
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsresult
rv
=
NS_OK
;
if
(
PreferencesWriter
:
:
sPendingWriteData
)
{
StaticMutexAutoLock
lock
(
PreferencesWriter
:
:
sWritingToFile
)
;
UniquePtr
<
PrefSaveData
>
prefs
(
PreferencesWriter
:
:
sPendingWriteData
.
exchange
(
nullptr
)
)
;
if
(
prefs
)
{
rv
=
PreferencesWriter
:
:
Write
(
mFile
*
prefs
)
;
nsresult
rvCopy
=
rv
;
nsCOMPtr
<
nsIFile
>
fileCopy
(
mFile
)
;
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
NS_NewRunnableFunction
(
"
Preferences
:
:
WriterRunnable
"
[
fileCopy
rvCopy
]
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
rvCopy
)
)
{
Preferences
:
:
HandleDirty
(
)
;
}
}
)
)
;
}
}
PreferencesWriter
:
:
sPendingWriteCount
-
-
;
return
rv
;
}
protected
:
nsCOMPtr
<
nsIFile
>
mFile
;
}
;
void
Preferences
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
PrefsSizes
&
aSizes
)
{
if
(
!
sPreferences
)
{
return
;
}
aSizes
.
mMisc
+
=
aMallocSizeOf
(
sPreferences
.
get
(
)
)
;
aSizes
.
mRootBranches
+
=
static_cast
<
nsPrefBranch
*
>
(
sPreferences
-
>
mRootBranch
.
get
(
)
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
+
static_cast
<
nsPrefBranch
*
>
(
sPreferences
-
>
mDefaultRootBranch
.
get
(
)
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
class
PreferenceServiceReporter
final
:
public
nsIMemoryReporter
{
~
PreferenceServiceReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
protected
:
static
const
uint32_t
kSuspectReferentCount
=
1000
;
}
;
NS_IMPL_ISUPPORTS
(
PreferenceServiceReporter
nsIMemoryReporter
)
MOZ_DEFINE_MALLOC_SIZE_OF
(
PreferenceServiceMallocSizeOf
)
NS_IMETHODIMP
PreferenceServiceReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MallocSizeOf
mallocSizeOf
=
PreferenceServiceMallocSizeOf
;
PrefsSizes
sizes
;
Preferences
:
:
AddSizeOfIncludingThis
(
mallocSizeOf
sizes
)
;
if
(
HashTable
(
)
)
{
sizes
.
mHashTable
+
=
HashTable
(
)
-
>
shallowSizeOfIncludingThis
(
mallocSizeOf
)
;
for
(
auto
iter
=
HashTable
(
)
-
>
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
iter
.
get
(
)
-
>
AddSizeOfIncludingThis
(
mallocSizeOf
sizes
)
;
}
}
sizes
.
mPrefNameArena
+
=
PrefNameArena
(
)
.
SizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
CallbackNode
*
node
=
gFirstCallback
;
node
;
node
=
node
-
>
Next
(
)
)
{
node
-
>
AddSizeOfIncludingThis
(
mallocSizeOf
sizes
)
;
}
if
(
gSharedMap
)
{
sizes
.
mMisc
+
=
mallocSizeOf
(
gSharedMap
)
;
}
#
ifdef
ACCESS_COUNTS
if
(
gAccessCounts
)
{
sizes
.
mMisc
+
=
gAccessCounts
-
>
ShallowSizeOfIncludingThis
(
mallocSizeOf
)
;
}
#
endif
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
hash
-
table
"
KIND_HEAP
UNITS_BYTES
sizes
.
mHashTable
"
Memory
used
by
libpref
'
s
hash
table
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
pref
-
values
"
KIND_HEAP
UNITS_BYTES
sizes
.
mPrefValues
"
Memory
used
by
PrefValues
hanging
off
the
hash
table
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
string
-
values
"
KIND_HEAP
UNITS_BYTES
sizes
.
mStringValues
"
Memory
used
by
libpref
'
s
string
pref
values
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
root
-
branches
"
KIND_HEAP
UNITS_BYTES
sizes
.
mRootBranches
"
Memory
used
by
libpref
'
s
root
branches
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
pref
-
name
-
arena
"
KIND_HEAP
UNITS_BYTES
sizes
.
mPrefNameArena
"
Memory
used
by
libpref
'
s
arena
for
pref
names
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
callbacks
/
objects
"
KIND_HEAP
UNITS_BYTES
sizes
.
mCallbacksObjects
"
Memory
used
by
pref
callback
objects
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
callbacks
/
domains
"
KIND_HEAP
UNITS_BYTES
sizes
.
mCallbacksDomains
"
Memory
used
by
pref
callback
domains
(
pref
names
and
"
"
prefixes
)
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
misc
"
KIND_HEAP
UNITS_BYTES
sizes
.
mMisc
"
Miscellaneous
memory
used
by
libpref
.
"
)
;
if
(
gSharedMap
)
{
if
(
XRE_IsParentProcess
(
)
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
/
shared
-
memory
-
map
"
KIND_NONHEAP
UNITS_BYTES
gSharedMap
-
>
MapSize
(
)
"
The
shared
memory
mapping
used
to
share
a
"
"
snapshot
of
preference
values
across
processes
.
"
)
;
}
}
nsPrefBranch
*
rootBranch
=
static_cast
<
nsPrefBranch
*
>
(
Preferences
:
:
GetRootBranch
(
)
)
;
if
(
!
rootBranch
)
{
return
NS_OK
;
}
size_t
numStrong
=
0
;
size_t
numWeakAlive
=
0
;
size_t
numWeakDead
=
0
;
nsTArray
<
nsCString
>
suspectPreferences
;
nsTHashMap
<
nsCStringHashKey
uint32_t
>
prefCounter
;
for
(
const
auto
&
entry
:
rootBranch
-
>
mObservers
)
{
auto
*
callback
=
entry
.
GetWeak
(
)
;
if
(
callback
-
>
IsWeak
(
)
)
{
nsCOMPtr
<
nsIObserver
>
callbackRef
=
do_QueryReferent
(
callback
-
>
mWeakRef
)
;
if
(
callbackRef
)
{
numWeakAlive
+
+
;
}
else
{
numWeakDead
+
+
;
}
}
else
{
numStrong
+
+
;
}
const
uint32_t
currentCount
=
prefCounter
.
Get
(
callback
-
>
GetDomain
(
)
)
+
1
;
prefCounter
.
InsertOrUpdate
(
callback
-
>
GetDomain
(
)
currentCount
)
;
if
(
currentCount
=
=
kSuspectReferentCount
)
{
suspectPreferences
.
AppendElement
(
callback
-
>
GetDomain
(
)
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
suspectPreferences
.
Length
(
)
;
i
+
+
)
{
nsCString
&
suspect
=
suspectPreferences
[
i
]
;
const
uint32_t
totalReferentCount
=
prefCounter
.
Get
(
suspect
)
;
nsPrintfCString
suspectPath
(
"
preference
-
service
-
suspect
/
"
"
referent
(
pref
=
%
s
)
"
suspect
.
get
(
)
)
;
aHandleReport
-
>
Callback
(
"
"
_ns
suspectPath
KIND_OTHER
UNITS_COUNT
totalReferentCount
"
A
preference
with
a
suspiciously
large
number
"
"
referents
(
symptom
of
a
leak
)
.
"
_ns
aData
)
;
}
MOZ_COLLECT_REPORT
(
"
preference
-
service
/
referent
/
strong
"
KIND_OTHER
UNITS_COUNT
numStrong
"
The
number
of
strong
referents
held
by
the
preference
service
.
"
)
;
MOZ_COLLECT_REPORT
(
"
preference
-
service
/
referent
/
weak
/
alive
"
KIND_OTHER
UNITS_COUNT
numWeakAlive
"
The
number
of
weak
referents
held
by
the
preference
service
that
are
"
"
still
alive
.
"
)
;
MOZ_COLLECT_REPORT
(
"
preference
-
service
/
referent
/
weak
/
dead
"
KIND_OTHER
UNITS_COUNT
numWeakDead
"
The
number
of
weak
referents
held
by
the
preference
service
that
are
"
"
dead
.
"
)
;
return
NS_OK
;
}
namespace
{
class
AddPreferencesMemoryReporterRunnable
:
public
Runnable
{
public
:
AddPreferencesMemoryReporterRunnable
(
)
:
Runnable
(
"
AddPreferencesMemoryReporterRunnable
"
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
RegisterStrongMemoryReporter
(
new
PreferenceServiceReporter
(
)
)
;
}
}
;
}
static
nsTArray
<
dom
:
:
Pref
>
*
gChangedDomPrefs
;
static
const
char
kTelemetryPref
[
]
=
"
toolkit
.
telemetry
.
enabled
"
;
static
const
char
kChannelPref
[
]
=
"
app
.
update
.
channel
"
;
#
ifdef
MOZ_WIDGET_ANDROID
static
Maybe
<
bool
>
TelemetryPrefValue
(
)
{
if
(
Preferences
:
:
GetType
(
kTelemetryPref
)
!
=
nsIPrefBranch
:
:
PREF_INVALID
)
{
return
Nothing
(
)
;
}
#
ifdef
MOZ_TELEMETRY_ON_BY_DEFAULT
return
Some
(
true
)
;
#
else
nsAutoCString
channelPrefValue
;
Unused
<
<
Preferences
:
:
GetCString
(
kChannelPref
channelPrefValue
PrefValueKind
:
:
Default
)
;
return
Some
(
channelPrefValue
.
EqualsLiteral
(
"
beta
"
)
)
;
#
endif
}
void
Preferences
:
:
SetupTelemetryPref
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
Maybe
<
bool
>
telemetryPrefValue
=
TelemetryPrefValue
(
)
;
if
(
telemetryPrefValue
.
isSome
(
)
)
{
Preferences
:
:
SetBool
(
kTelemetryPref
*
telemetryPrefValue
PrefValueKind
:
:
Default
)
;
}
}
#
else
static
bool
TelemetryPrefValue
(
)
{
constexpr
auto
channel
=
MOZ_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
"
"
_ns
;
if
(
channel
.
EqualsLiteral
(
"
nightly
"
)
|
|
channel
.
EqualsLiteral
(
"
aurora
"
)
|
|
channel
.
EqualsLiteral
(
"
beta
"
)
)
{
return
true
;
}
#
ifndef
MOZILLA_OFFICIAL
if
(
channel
.
EqualsLiteral
(
"
default
"
)
)
{
return
true
;
}
#
endif
if
(
channel
.
EqualsLiteral
(
"
release
"
)
)
{
nsAutoCString
channelPrefValue
;
Unused
<
<
Preferences
:
:
GetCString
(
kChannelPref
channelPrefValue
PrefValueKind
:
:
Default
)
;
if
(
channelPrefValue
.
EqualsLiteral
(
"
beta
"
)
)
{
return
true
;
}
}
return
false
;
}
void
Preferences
:
:
SetupTelemetryPref
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
Preferences
:
:
SetBool
(
kTelemetryPref
TelemetryPrefValue
(
)
PrefValueKind
:
:
Default
)
;
Preferences
:
:
Lock
(
kTelemetryPref
)
;
}
static
void
CheckTelemetryPref
(
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
DebugOnly
<
bool
>
value
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
Preferences
:
:
GetBool
(
kTelemetryPref
&
value
)
)
&
&
value
=
=
TelemetryPrefValue
(
)
)
;
MOZ_ASSERT
(
Preferences
:
:
IsLocked
(
kTelemetryPref
)
)
;
}
#
endif
already_AddRefed
<
Preferences
>
Preferences
:
:
GetInstanceForService
(
)
{
if
(
sPreferences
)
{
return
do_AddRef
(
sPreferences
)
;
}
if
(
sShutdown
)
{
return
nullptr
;
}
sPreferences
=
new
Preferences
(
)
;
MOZ_ASSERT
(
!
HashTable
(
)
)
;
HashTable
(
)
=
new
PrefsHashTable
(
XRE_IsParentProcess
(
)
?
kHashTableInitialLengthParent
:
kHashTableInitialLengthContent
)
;
#
ifdef
DEBUG
gOnceStaticPrefsAntiFootgun
=
new
AntiFootgunMap
(
)
;
#
endif
#
ifdef
ACCESS_COUNTS
MOZ_ASSERT
(
!
gAccessCounts
)
;
gAccessCounts
=
new
AccessCountsHashTable
(
)
;
#
endif
nsresult
rv
=
InitInitialObjects
(
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
sPreferences
=
nullptr
;
return
nullptr
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
MOZ_ASSERT
(
gChangedDomPrefs
)
;
for
(
unsigned
int
i
=
0
;
i
<
gChangedDomPrefs
-
>
Length
(
)
;
i
+
+
)
{
Preferences
:
:
SetPreference
(
gChangedDomPrefs
-
>
ElementAt
(
i
)
)
;
}
delete
gChangedDomPrefs
;
gChangedDomPrefs
=
nullptr
;
#
ifndef
MOZ_WIDGET_ANDROID
CheckTelemetryPref
(
)
;
#
endif
}
else
{
nsAutoCString
lockFileName
;
nsresult
rv
=
Preferences
:
:
GetCString
(
"
general
.
config
.
filename
"
lockFileName
PrefValueKind
:
:
User
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_CreateServicesFromCategory
(
"
pref
-
config
-
startup
"
static_cast
<
nsISupports
*
>
(
static_cast
<
void
*
>
(
sPreferences
)
)
"
pref
-
config
-
startup
"
)
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
{
sPreferences
=
nullptr
;
return
nullptr
;
}
observerService
-
>
AddObserver
(
sPreferences
"
profile
-
before
-
change
-
telemetry
"
true
)
;
rv
=
observerService
-
>
AddObserver
(
sPreferences
"
profile
-
before
-
change
"
true
)
;
observerService
-
>
AddObserver
(
sPreferences
"
suspend_process_notification
"
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
sPreferences
=
nullptr
;
return
nullptr
;
}
}
const
char
*
defaultPrefs
=
getenv
(
"
MOZ_DEFAULT_PREFS
"
)
;
if
(
defaultPrefs
)
{
parsePrefData
(
nsCString
(
defaultPrefs
)
PrefValueKind
:
:
Default
)
;
}
RefPtr
<
AddPreferencesMemoryReporterRunnable
>
runnable
=
new
AddPreferencesMemoryReporterRunnable
(
)
;
NS_DispatchToMainThread
(
runnable
)
;
return
do_AddRef
(
sPreferences
)
;
}
bool
Preferences
:
:
IsServiceAvailable
(
)
{
return
!
!
sPreferences
;
}
bool
Preferences
:
:
InitStaticMembers
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
|
|
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
if
(
MOZ_LIKELY
(
sPreferences
)
)
{
return
true
;
}
if
(
!
sShutdown
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIPrefService
>
prefService
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
}
return
sPreferences
!
=
nullptr
;
}
void
Preferences
:
:
Shutdown
(
)
{
if
(
!
sShutdown
)
{
sShutdown
=
true
;
sPreferences
=
nullptr
;
StaticPrefs
:
:
ShutdownAlwaysPrefs
(
)
;
}
}
Preferences
:
:
Preferences
(
)
:
mRootBranch
(
new
nsPrefBranch
(
"
"
PrefValueKind
:
:
User
)
)
mDefaultRootBranch
(
new
nsPrefBranch
(
"
"
PrefValueKind
:
:
Default
)
)
{
}
Preferences
:
:
~
Preferences
(
)
{
MOZ_ASSERT
(
!
sPreferences
)
;
MOZ_ASSERT
(
!
gCallbacksInProgress
)
;
CallbackNode
*
node
=
gFirstCallback
;
while
(
node
)
{
CallbackNode
*
next_node
=
node
-
>
Next
(
)
;
delete
node
;
node
=
next_node
;
}
gLastPriorityNode
=
gFirstCallback
=
nullptr
;
delete
HashTable
(
)
;
HashTable
(
)
=
nullptr
;
#
ifdef
DEBUG
delete
gOnceStaticPrefsAntiFootgun
;
gOnceStaticPrefsAntiFootgun
=
nullptr
;
#
endif
#
ifdef
ACCESS_COUNTS
delete
gAccessCounts
;
#
endif
gSharedMap
=
nullptr
;
PrefNameArena
(
)
.
Clear
(
)
;
}
NS_IMPL_ISUPPORTS
(
Preferences
nsIPrefService
nsIObserver
nsIPrefBranch
nsISupportsWeakReference
)
void
Preferences
:
:
SerializePreferences
(
nsCString
&
aStr
bool
aIsDestinationWebContentProcess
)
{
MOZ_RELEASE_ASSERT
(
InitStaticMembers
(
)
)
;
aStr
.
Truncate
(
)
;
for
(
auto
iter
=
HashTable
(
)
-
>
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
Pref
*
pref
=
iter
.
get
(
)
.
get
(
)
;
if
(
!
pref
-
>
IsTypeNone
(
)
&
&
pref
-
>
HasAdvisablySizedValues
(
)
)
{
pref
-
>
SerializeAndAppend
(
aStr
ShouldSanitizePreference
(
pref
aIsDestinationWebContentProcess
)
)
;
}
}
aStr
.
Append
(
'
\
0
'
)
;
}
void
Preferences
:
:
DeserializePreferences
(
char
*
aStr
size_t
aPrefsLen
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
gChangedDomPrefs
)
;
gChangedDomPrefs
=
new
nsTArray
<
dom
:
:
Pref
>
(
)
;
char
*
p
=
aStr
;
while
(
*
p
!
=
'
\
0
'
)
{
dom
:
:
Pref
pref
;
p
=
Pref
:
:
Deserialize
(
p
&
pref
)
;
gChangedDomPrefs
-
>
AppendElement
(
pref
)
;
}
MOZ_ASSERT
(
p
=
=
aStr
+
aPrefsLen
-
1
)
;
MOZ_ASSERT
(
!
gContentProcessPrefsAreInited
)
;
gContentProcessPrefsAreInited
=
true
;
}
FileDescriptor
Preferences
:
:
EnsureSnapshot
(
size_t
*
aSize
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gSharedMap
)
{
SharedPrefMapBuilder
builder
;
nsTArray
<
Pref
*
>
toRepopulate
;
NameArena
*
newPrefNameArena
=
new
NameArena
(
)
;
for
(
auto
iter
=
HashTable
(
)
-
>
modIter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
if
(
!
ShouldSanitizePreference
(
iter
.
get
(
)
.
get
(
)
true
)
)
{
iter
.
get
(
)
-
>
AddToMap
(
builder
)
;
}
else
{
Pref
*
pref
=
iter
.
getMutable
(
)
.
release
(
)
;
pref
-
>
RelocateName
(
newPrefNameArena
)
;
toRepopulate
.
AppendElement
(
pref
)
;
}
}
StaticPrefs
:
:
RegisterOncePrefs
(
builder
)
;
gSharedMap
=
new
SharedPrefMap
(
std
:
:
move
(
builder
)
)
;
HashTable
(
)
-
>
clearAndCompact
(
)
;
Unused
<
<
HashTable
(
)
-
>
reserve
(
kHashTableInitialLengthContent
)
;
delete
sPrefNameArena
;
sPrefNameArena
=
newPrefNameArena
;
gCallbackPref
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
toRepopulate
.
Length
(
)
;
i
+
+
)
{
auto
pref
=
toRepopulate
[
i
]
;
auto
p
=
HashTable
(
)
-
>
lookupForAdd
(
pref
-
>
Name
(
)
)
;
MOZ_ASSERT
(
!
p
.
found
(
)
)
;
Unused
<
<
HashTable
(
)
-
>
add
(
p
pref
)
;
}
}
*
aSize
=
gSharedMap
-
>
MapSize
(
)
;
return
gSharedMap
-
>
CloneFileDescriptor
(
)
;
}
void
Preferences
:
:
InitSnapshot
(
const
FileDescriptor
&
aHandle
size_t
aSize
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
gSharedMap
)
;
gSharedMap
=
new
SharedPrefMap
(
aHandle
aSize
)
;
StaticPrefs
:
:
InitStaticPrefsFromShared
(
)
;
}
void
Preferences
:
:
InitializeUserPrefs
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
sPreferences
-
>
mCurrentFile
"
Should
only
initialize
prefs
once
"
)
;
sPreferences
-
>
ResetUserPrefs
(
)
;
nsCOMPtr
<
nsIFile
>
prefsFile
=
sPreferences
-
>
ReadSavedPrefs
(
)
;
sPreferences
-
>
ReadUserOverridePrefs
(
)
;
sPreferences
-
>
mDirty
=
false
;
sPreferences
-
>
mCurrentFile
=
std
:
:
move
(
prefsFile
)
;
}
void
Preferences
:
:
FinishInitializingUserPrefs
(
)
{
sPreferences
-
>
NotifyServiceObservers
(
NS_PREFSERVICE_READ_TOPIC_ID
)
;
}
NS_IMETHODIMP
Preferences
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
NS_OK
;
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
)
{
if
(
AllowOffMainThreadSave
(
)
)
{
SavePrefFile
(
nullptr
)
;
}
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
profile
-
before
-
change
-
telemetry
"
)
)
{
SavePrefFileBlocking
(
)
;
MOZ_ASSERT
(
!
mDirty
"
Preferences
should
not
be
dirty
"
)
;
mProfileShutdown
=
true
;
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
reload
-
default
-
prefs
"
)
)
{
Unused
<
<
InitInitialObjects
(
false
)
;
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
suspend_process_notification
"
)
)
{
rv
=
SavePrefFileBlocking
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
Preferences
:
:
ReadDefaultPrefsFromFile
(
nsIFile
*
aFile
)
{
ENSURE_PARENT_PROCESS
(
"
Preferences
:
:
ReadDefaultPrefsFromFile
"
"
all
prefs
"
)
;
if
(
!
aFile
)
{
NS_ERROR
(
"
ReadDefaultPrefsFromFile
requires
a
parameter
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
return
openPrefFile
(
aFile
PrefValueKind
:
:
Default
)
;
}
NS_IMETHODIMP
Preferences
:
:
ReadUserPrefsFromFile
(
nsIFile
*
aFile
)
{
ENSURE_PARENT_PROCESS
(
"
Preferences
:
:
ReadUserPrefsFromFile
"
"
all
prefs
"
)
;
if
(
!
aFile
)
{
NS_ERROR
(
"
ReadUserPrefsFromFile
requires
a
parameter
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
return
openPrefFile
(
aFile
PrefValueKind
:
:
User
)
;
}
NS_IMETHODIMP
Preferences
:
:
ResetPrefs
(
)
{
ENSURE_PARENT_PROCESS
(
"
Preferences
:
:
ResetPrefs
"
"
all
prefs
"
)
;
if
(
gSharedMap
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
HashTable
(
)
-
>
clearAndCompact
(
)
;
Unused
<
<
HashTable
(
)
-
>
reserve
(
kHashTableInitialLengthParent
)
;
PrefNameArena
(
)
.
Clear
(
)
;
return
InitInitialObjects
(
false
)
;
}
nsresult
Preferences
:
:
ResetUserPrefs
(
)
{
ENSURE_PARENT_PROCESS
(
"
Preferences
:
:
ResetUserPrefs
"
"
all
prefs
"
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Vector
<
const
char
*
>
prefNames
;
for
(
auto
iter
=
HashTable
(
)
-
>
modIter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
Pref
*
pref
=
iter
.
get
(
)
.
get
(
)
;
if
(
pref
-
>
HasUserValue
(
)
)
{
if
(
!
prefNames
.
append
(
pref
-
>
Name
(
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
pref
-
>
ClearUserValue
(
)
;
if
(
!
pref
-
>
HasDefaultValue
(
)
)
{
iter
.
remove
(
)
;
}
}
}
for
(
const
char
*
prefName
:
prefNames
)
{
NotifyCallbacks
(
nsDependentCString
(
prefName
)
)
;
}
Preferences
:
:
HandleDirty
(
)
;
return
NS_OK
;
}
bool
Preferences
:
:
AllowOffMainThreadSave
(
)
{
if
(
sAllowOMTPrefWrite
<
0
)
{
bool
value
=
false
;
Preferences
:
:
GetBool
(
"
preferences
.
allow
.
omt
-
write
"
&
value
)
;
sAllowOMTPrefWrite
=
value
?
1
:
0
;
}
return
!
!
sAllowOMTPrefWrite
;
}
nsresult
Preferences
:
:
SavePrefFileBlocking
(
)
{
if
(
mDirty
)
{
return
SavePrefFileInternal
(
nullptr
SaveMethod
:
:
Blocking
)
;
}
if
(
AllowOffMainThreadSave
(
)
)
{
PreferencesWriter
:
:
Flush
(
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
SavePrefFileAsynchronous
(
)
{
return
SavePrefFileInternal
(
nullptr
SaveMethod
:
:
Asynchronous
)
;
}
NS_IMETHODIMP
Preferences
:
:
SavePrefFile
(
nsIFile
*
aFile
)
{
return
SavePrefFileInternal
(
aFile
SaveMethod
:
:
Asynchronous
)
;
}
void
Preferences
:
:
SetPreference
(
const
dom
:
:
Pref
&
aDomPref
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
(
void
)
0
)
;
const
nsCString
&
prefName
=
aDomPref
.
name
(
)
;
Pref
*
pref
;
auto
p
=
HashTable
(
)
-
>
lookupForAdd
(
prefName
.
get
(
)
)
;
if
(
!
p
)
{
pref
=
new
Pref
(
prefName
)
;
if
(
!
HashTable
(
)
-
>
add
(
p
pref
)
)
{
delete
pref
;
return
;
}
}
else
{
pref
=
p
-
>
get
(
)
;
}
bool
valueChanged
=
false
;
pref
-
>
FromDomPref
(
aDomPref
&
valueChanged
)
;
if
(
!
pref
-
>
HasDefaultValue
(
)
&
&
!
pref
-
>
HasUserValue
(
)
&
&
!
pref
-
>
IsSanitized
(
)
)
{
if
(
gSharedMap
-
>
Has
(
pref
-
>
Name
(
)
)
)
{
pref
-
>
SetType
(
PrefType
:
:
None
)
;
}
else
{
HashTable
(
)
-
>
remove
(
prefName
.
get
(
)
)
;
}
pref
=
nullptr
;
}
if
(
valueChanged
)
{
if
(
pref
)
{
NotifyCallbacks
(
prefName
PrefWrapper
(
pref
)
)
;
}
else
{
NotifyCallbacks
(
prefName
)
;
}
}
}
void
Preferences
:
:
GetPreference
(
dom
:
:
Pref
*
aDomPref
const
GeckoProcessType
aDestinationProcessType
const
nsACString
&
aDestinationRemoteType
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
bool
destIsWebContent
=
aDestinationProcessType
=
=
GeckoProcessType_Content
&
&
(
StringBeginsWith
(
aDestinationRemoteType
WEB_REMOTE_TYPE
)
|
|
StringBeginsWith
(
aDestinationRemoteType
PREALLOC_REMOTE_TYPE
)
)
;
Pref
*
pref
=
pref_HashTableLookup
(
aDomPref
-
>
name
(
)
.
get
(
)
)
;
if
(
pref
&
&
pref
-
>
HasAdvisablySizedValues
(
)
)
{
pref
-
>
ToDomPref
(
aDomPref
destIsWebContent
)
;
}
}
#
ifdef
DEBUG
bool
Preferences
:
:
ArePrefsInitedInContentProcess
(
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
return
gContentProcessPrefsAreInited
;
}
#
endif
NS_IMETHODIMP
Preferences
:
:
GetBranch
(
const
char
*
aPrefRoot
nsIPrefBranch
*
*
aRetVal
)
{
if
(
(
nullptr
!
=
aPrefRoot
)
&
&
(
*
aPrefRoot
!
=
'
\
0
'
)
)
{
RefPtr
<
nsPrefBranch
>
prefBranch
=
new
nsPrefBranch
(
aPrefRoot
PrefValueKind
:
:
User
)
;
prefBranch
.
forget
(
aRetVal
)
;
}
else
{
nsCOMPtr
<
nsIPrefBranch
>
root
(
sPreferences
-
>
mRootBranch
)
;
root
.
forget
(
aRetVal
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
Preferences
:
:
GetDefaultBranch
(
const
char
*
aPrefRoot
nsIPrefBranch
*
*
aRetVal
)
{
if
(
!
aPrefRoot
|
|
!
aPrefRoot
[
0
]
)
{
nsCOMPtr
<
nsIPrefBranch
>
root
(
sPreferences
-
>
mDefaultRootBranch
)
;
root
.
forget
(
aRetVal
)
;
return
NS_OK
;
}
RefPtr
<
nsPrefBranch
>
prefBranch
=
new
nsPrefBranch
(
aPrefRoot
PrefValueKind
:
:
Default
)
;
if
(
!
prefBranch
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
prefBranch
.
forget
(
aRetVal
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Preferences
:
:
ReadStats
(
nsIPrefStatsCallback
*
aCallback
)
{
#
ifdef
ACCESS_COUNTS
for
(
const
auto
&
entry
:
*
gAccessCounts
)
{
aCallback
-
>
Visit
(
entry
.
GetKey
(
)
entry
.
GetData
(
)
)
;
}
return
NS_OK
;
#
else
return
NS_ERROR_NOT_IMPLEMENTED
;
#
endif
}
NS_IMETHODIMP
Preferences
:
:
ResetStats
(
)
{
#
ifdef
ACCESS_COUNTS
gAccessCounts
-
>
Clear
(
)
;
return
NS_OK
;
#
else
return
NS_ERROR_NOT_IMPLEMENTED
;
#
endif
}
nsIPrefObserver
*
PrefObserver
=
nullptr
;
void
HandlePref
(
const
char
*
aPrefName
PrefType
aType
PrefValueKind
aKind
PrefValue
aValue
bool
aIsSticky
bool
aIsLocked
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
PrefObserver
)
{
return
;
}
const
char
*
kind
=
aKind
=
=
PrefValueKind
:
:
Default
?
"
Default
"
:
"
User
"
;
switch
(
aType
)
{
case
PrefType
:
:
String
:
PrefObserver
-
>
OnStringPref
(
kind
aPrefName
aValue
.
mStringVal
aIsSticky
aIsLocked
)
;
break
;
case
PrefType
:
:
Int
:
PrefObserver
-
>
OnIntPref
(
kind
aPrefName
aValue
.
mIntVal
aIsSticky
aIsLocked
)
;
break
;
case
PrefType
:
:
Bool
:
PrefObserver
-
>
OnBoolPref
(
kind
aPrefName
aValue
.
mBoolVal
aIsSticky
aIsLocked
)
;
break
;
default
:
PrefObserver
-
>
OnError
(
"
Unexpected
pref
type
.
"
)
;
}
}
void
HandleError
(
const
char
*
aMsg
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
PrefObserver
)
{
return
;
}
PrefObserver
-
>
OnError
(
aMsg
)
;
}
NS_IMETHODIMP
Preferences
:
:
ParsePrefsFromBuffer
(
const
nsTArray
<
uint8_t
>
&
aBytes
nsIPrefObserver
*
aObserver
const
char
*
aPathLabel
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
uint8_t
>
data
=
aBytes
.
Clone
(
)
;
data
.
AppendElement
(
0
)
;
PrefObserver
=
aObserver
;
prefs_parser_parse
(
aPathLabel
?
aPathLabel
:
"
<
ParsePrefsFromBuffer
data
>
"
PrefValueKind
:
:
Default
(
const
char
*
)
data
.
Elements
(
)
data
.
Length
(
)
-
1
HandlePref
HandleError
)
;
PrefObserver
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
Preferences
:
:
GetDirty
(
bool
*
aRetVal
)
{
*
aRetVal
=
mDirty
;
return
NS_OK
;
}
nsresult
Preferences
:
:
NotifyServiceObservers
(
const
char
*
aTopic
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
{
return
NS_ERROR_FAILURE
;
}
auto
subject
=
static_cast
<
nsIPrefService
*
>
(
this
)
;
observerService
-
>
NotifyObservers
(
subject
aTopic
nullptr
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIFile
>
Preferences
:
:
ReadSavedPrefs
(
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_PREFS_50_FILE
getter_AddRefs
(
file
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
rv
=
openPrefFile
(
file
PrefValueKind
:
:
User
)
;
if
(
rv
=
=
NS_ERROR_FILE_NOT_FOUND
)
{
rv
=
NS_OK
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
PREFERENCES_PREFS_FILE_WAS_INVALID
true
)
;
MakeBackupPrefFile
(
file
)
;
}
return
file
.
forget
(
)
;
}
void
Preferences
:
:
ReadUserOverridePrefs
(
)
{
nsCOMPtr
<
nsIFile
>
aFile
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_PREFS_50_DIR
getter_AddRefs
(
aFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
aFile
-
>
AppendNative
(
"
user
.
js
"
_ns
)
;
rv
=
openPrefFile
(
aFile
PrefValueKind
:
:
User
)
;
}
nsresult
Preferences
:
:
MakeBackupPrefFile
(
nsIFile
*
aFile
)
{
nsAutoString
newFilename
;
nsresult
rv
=
aFile
-
>
GetLeafName
(
newFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
newFilename
.
InsertLiteral
(
u
"
Invalid
"
0
)
;
nsCOMPtr
<
nsIFile
>
newFile
;
rv
=
aFile
-
>
GetParent
(
getter_AddRefs
(
newFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
newFile
-
>
Append
(
newFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
exists
=
false
;
newFile
-
>
Exists
(
&
exists
)
;
if
(
exists
)
{
rv
=
newFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
aFile
-
>
CopyTo
(
nullptr
newFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
nsresult
Preferences
:
:
SavePrefFileInternal
(
nsIFile
*
aFile
SaveMethod
aSaveMethod
)
{
ENSURE_PARENT_PROCESS
(
"
Preferences
:
:
SavePrefFileInternal
"
"
all
prefs
"
)
;
if
(
nullptr
=
=
aFile
)
{
mSavePending
=
false
;
if
(
!
AllowOffMainThreadSave
(
)
)
{
aSaveMethod
=
SaveMethod
:
:
Blocking
;
}
if
(
!
mDirty
)
{
return
NS_OK
;
}
if
(
mProfileShutdown
)
{
NS_WARNING
(
"
Cannot
save
pref
file
after
profile
shutdown
.
"
)
;
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
nsresult
rv
=
NS_OK
;
if
(
mCurrentFile
)
{
rv
=
WritePrefFile
(
mCurrentFile
aSaveMethod
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
mDirty
=
false
;
}
return
rv
;
}
else
{
return
WritePrefFile
(
aFile
SaveMethod
:
:
Blocking
)
;
}
}
nsresult
Preferences
:
:
WritePrefFile
(
nsIFile
*
aFile
SaveMethod
aSaveMethod
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
HashTable
(
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AUTO_PROFILER_LABEL
(
"
Preferences
:
:
WritePrefFile
"
OTHER
)
;
if
(
AllowOffMainThreadSave
(
)
)
{
nsresult
rv
=
NS_OK
;
UniquePtr
<
PrefSaveData
>
prefs
=
MakeUnique
<
PrefSaveData
>
(
pref_savePrefs
(
)
)
;
prefs
.
reset
(
PreferencesWriter
:
:
sPendingWriteData
.
exchange
(
prefs
.
release
(
)
)
)
;
if
(
prefs
)
{
return
rv
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
async
=
aSaveMethod
=
=
SaveMethod
:
:
Asynchronous
;
PreferencesWriter
:
:
sPendingWriteCount
+
+
;
if
(
async
)
{
rv
=
target
-
>
Dispatch
(
new
PWRunnable
(
aFile
)
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
}
else
{
rv
=
SyncRunnable
:
:
DispatchToThread
(
target
new
PWRunnable
(
aFile
)
true
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
PreferencesWriter
:
:
sPendingWriteCount
-
-
;
}
return
rv
;
}
MOZ_ASSERT
(
false
"
failed
to
get
the
target
thread
for
OMT
pref
write
"
)
;
}
PrefSaveData
prefsData
=
pref_savePrefs
(
)
;
return
PreferencesWriter
:
:
Write
(
aFile
prefsData
)
;
}
static
nsresult
openPrefFile
(
nsIFile
*
aFile
PrefValueKind
aKind
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCString
data
;
MOZ_TRY_VAR
(
data
URLPreloader
:
:
ReadFile
(
aFile
)
)
;
nsAutoString
filenameUtf16
;
aFile
-
>
GetLeafName
(
filenameUtf16
)
;
NS_ConvertUTF16toUTF8
filename
(
filenameUtf16
)
;
nsAutoString
path
;
aFile
-
>
GetPath
(
path
)
;
Parser
parser
;
if
(
!
parser
.
Parse
(
aKind
NS_ConvertUTF16toUTF8
(
path
)
.
get
(
)
data
)
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
return
NS_OK
;
}
static
nsresult
parsePrefData
(
const
nsCString
&
aData
PrefValueKind
aKind
)
{
const
nsCString
path
=
"
MOZ_DEFAULT_PREFS
"
_ns
;
Parser
parser
;
if
(
!
parser
.
Parse
(
aKind
path
.
get
(
)
aData
)
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
return
NS_OK
;
}
static
int
pref_CompareFileNames
(
nsIFile
*
aFile1
nsIFile
*
aFile2
void
*
)
{
nsAutoCString
filename1
filename2
;
aFile1
-
>
GetNativeLeafName
(
filename1
)
;
aFile2
-
>
GetNativeLeafName
(
filename2
)
;
return
Compare
(
filename2
filename1
)
;
}
static
nsresult
pref_LoadPrefsInDir
(
nsIFile
*
aDir
char
const
*
const
*
aSpecialFiles
uint32_t
aSpecialFilesCount
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsresult
rv
rv2
;
nsCOMPtr
<
nsIDirectoryEnumerator
>
dirIterator
;
rv
=
aDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
dirIterator
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_FILE_NOT_FOUND
)
{
rv
=
NS_OK
;
}
return
rv
;
}
nsCOMArray
<
nsIFile
>
prefFiles
(
INITIAL_PREF_FILES
)
;
nsCOMArray
<
nsIFile
>
specialFiles
(
aSpecialFilesCount
)
;
nsCOMPtr
<
nsIFile
>
prefFile
;
while
(
NS_SUCCEEDED
(
dirIterator
-
>
GetNextFile
(
getter_AddRefs
(
prefFile
)
)
)
&
&
prefFile
)
{
nsAutoCString
leafName
;
prefFile
-
>
GetNativeLeafName
(
leafName
)
;
MOZ_ASSERT
(
!
leafName
.
IsEmpty
(
)
"
Failure
in
default
prefs
:
directory
enumerator
returned
empty
file
?
"
)
;
if
(
StringEndsWith
(
leafName
"
.
js
"
_ns
nsCaseInsensitiveCStringComparator
)
)
{
bool
shouldParse
=
true
;
for
(
uint32_t
i
=
0
;
i
<
aSpecialFilesCount
;
+
+
i
)
{
if
(
leafName
.
Equals
(
nsDependentCString
(
aSpecialFiles
[
i
]
)
)
)
{
shouldParse
=
false
;
specialFiles
.
ReplaceObjectAt
(
prefFile
i
)
;
}
}
if
(
shouldParse
)
{
prefFiles
.
AppendObject
(
prefFile
)
;
}
}
}
if
(
prefFiles
.
Count
(
)
+
specialFiles
.
Count
(
)
=
=
0
)
{
NS_WARNING
(
"
No
default
pref
files
found
.
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
NS_SUCCESS_FILE_DIRECTORY_EMPTY
;
}
return
rv
;
}
prefFiles
.
Sort
(
pref_CompareFileNames
nullptr
)
;
uint32_t
arrayCount
=
prefFiles
.
Count
(
)
;
uint32_t
i
;
for
(
i
=
0
;
i
<
arrayCount
;
+
+
i
)
{
rv2
=
openPrefFile
(
prefFiles
[
i
]
PrefValueKind
:
:
Default
)
;
if
(
NS_FAILED
(
rv2
)
)
{
NS_ERROR
(
"
Default
pref
file
not
parsed
successfully
.
"
)
;
rv
=
rv2
;
}
}
arrayCount
=
specialFiles
.
Count
(
)
;
for
(
i
=
0
;
i
<
arrayCount
;
+
+
i
)
{
nsIFile
*
file
=
specialFiles
[
i
]
;
if
(
file
)
{
rv2
=
openPrefFile
(
file
PrefValueKind
:
:
Default
)
;
if
(
NS_FAILED
(
rv2
)
)
{
NS_ERROR
(
"
Special
default
pref
file
not
parsed
successfully
.
"
)
;
rv
=
rv2
;
}
}
}
return
rv
;
}
static
nsresult
pref_ReadPrefFromJar
(
nsZipArchive
*
aJarReader
const
char
*
aName
)
{
nsCString
manifest
;
MOZ_TRY_VAR
(
manifest
URLPreloader
:
:
ReadZip
(
aJarReader
nsDependentCString
(
aName
)
)
)
;
Parser
parser
;
if
(
!
parser
.
Parse
(
PrefValueKind
:
:
Default
aName
manifest
)
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
return
NS_OK
;
}
static
nsresult
pref_ReadDefaultPrefs
(
const
RefPtr
<
nsZipArchive
>
jarReader
const
char
*
path
)
{
UniquePtr
<
nsZipFind
>
find
;
nsTArray
<
nsCString
>
prefEntries
;
const
char
*
entryName
;
uint16_t
entryNameLen
;
nsresult
rv
=
jarReader
-
>
FindInit
(
path
getter_Transfers
(
find
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
NS_SUCCEEDED
(
find
-
>
FindNext
(
&
entryName
&
entryNameLen
)
)
)
{
prefEntries
.
AppendElement
(
Substring
(
entryName
entryNameLen
)
)
;
}
prefEntries
.
Sort
(
)
;
for
(
uint32_t
i
=
prefEntries
.
Length
(
)
;
i
-
-
;
)
{
rv
=
pref_ReadPrefFromJar
(
jarReader
prefEntries
[
i
]
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Error
parsing
preferences
.
"
)
;
}
}
return
NS_OK
;
}
static
nsCString
PrefValueToString
(
const
bool
*
b
)
{
return
nsCString
(
*
b
?
"
true
"
:
"
false
"
)
;
}
static
nsCString
PrefValueToString
(
const
int
*
i
)
{
return
nsPrintfCString
(
"
%
d
"
*
i
)
;
}
static
nsCString
PrefValueToString
(
const
uint32_t
*
u
)
{
return
nsPrintfCString
(
"
%
d
"
*
u
)
;
}
static
nsCString
PrefValueToString
(
const
float
*
f
)
{
return
nsPrintfCString
(
"
%
f
"
*
f
)
;
}
static
nsCString
PrefValueToString
(
const
nsACString
*
s
)
{
return
nsCString
(
*
s
)
;
}
static
nsCString
PrefValueToString
(
const
nsACString
&
s
)
{
return
nsCString
(
s
)
;
}
struct
Internals
{
struct
PreferenceReadMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
PreferenceRead
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
ProfilerString8View
&
aPrefName
const
Maybe
<
PrefValueKind
>
&
aPrefKind
PrefType
aPrefType
const
ProfilerString8View
&
aPrefValue
)
{
aWriter
.
StringProperty
(
"
prefName
"
aPrefName
)
;
aWriter
.
StringProperty
(
"
prefKind
"
PrefValueKindToString
(
aPrefKind
)
)
;
aWriter
.
StringProperty
(
"
prefType
"
PrefTypeToString
(
aPrefType
)
)
;
aWriter
.
StringProperty
(
"
prefValue
"
aPrefValue
)
;
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyLabelFormat
(
"
prefName
"
"
Name
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyLabelFormat
(
"
prefKind
"
"
Kind
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyLabelFormat
(
"
prefType
"
"
Type
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyLabelFormat
(
"
prefValue
"
"
Value
"
MS
:
:
Format
:
:
String
)
;
return
schema
;
}
private
:
static
Span
<
const
char
>
PrefValueKindToString
(
const
Maybe
<
PrefValueKind
>
&
aKind
)
{
if
(
aKind
)
{
return
*
aKind
=
=
PrefValueKind
:
:
Default
?
MakeStringSpan
(
"
Default
"
)
:
MakeStringSpan
(
"
User
"
)
;
}
return
"
Shared
"
;
}
static
Span
<
const
char
>
PrefTypeToString
(
PrefType
type
)
{
switch
(
type
)
{
case
PrefType
:
:
None
:
return
"
None
"
;
case
PrefType
:
:
Int
:
return
"
Int
"
;
case
PrefType
:
:
Bool
:
return
"
Bool
"
;
case
PrefType
:
:
String
:
return
"
String
"
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
preference
type
.
"
)
;
return
"
Unknown
"
;
}
}
}
;
template
<
typename
T
>
static
nsresult
GetPrefValue
(
const
char
*
aPrefName
T
&
&
aResult
PrefValueKind
aKind
)
{
nsresult
rv
=
NS_ERROR_UNEXPECTED
;
NS_ENSURE_TRUE
(
Preferences
:
:
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
if
(
Maybe
<
PrefWrapper
>
pref
=
pref_Lookup
(
aPrefName
)
)
{
rv
=
pref
-
>
GetValue
(
aKind
std
:
:
forward
<
T
>
(
aResult
)
)
;
if
(
profiler_feature_active
(
ProfilerFeature
:
:
PreferenceReads
)
)
{
profiler_add_marker
(
"
PreferenceRead
"
baseprofiler
:
:
category
:
:
OTHER_PreferenceRead
{
}
PreferenceReadMarker
{
}
ProfilerString8View
:
:
WrapNullTerminatedString
(
aPrefName
)
Some
(
aKind
)
pref
-
>
Type
(
)
PrefValueToString
(
aResult
)
)
;
}
}
return
rv
;
}
template
<
typename
T
>
static
nsresult
GetSharedPrefValue
(
const
char
*
aName
T
*
aResult
)
{
nsresult
rv
=
NS_ERROR_UNEXPECTED
;
if
(
Maybe
<
PrefWrapper
>
pref
=
pref_SharedLookup
(
aName
)
)
{
rv
=
pref
-
>
GetValue
(
PrefValueKind
:
:
User
aResult
)
;
if
(
profiler_feature_active
(
ProfilerFeature
:
:
PreferenceReads
)
)
{
profiler_add_marker
(
"
PreferenceRead
"
baseprofiler
:
:
category
:
:
OTHER_PreferenceRead
{
}
PreferenceReadMarker
{
}
ProfilerString8View
:
:
WrapNullTerminatedString
(
aName
)
Nothing
(
)
pref
-
>
Type
(
)
PrefValueToString
(
aResult
)
)
;
}
}
return
rv
;
}
template
<
typename
T
>
static
T
GetPref
(
const
char
*
aPrefName
T
aFallback
PrefValueKind
aKind
=
PrefValueKind
:
:
User
)
{
T
result
=
aFallback
;
GetPrefValue
(
aPrefName
&
result
aKind
)
;
return
result
;
}
template
<
typename
T
typename
V
>
static
void
MOZ_NEVER_INLINE
AssignMirror
(
T
&
aMirror
V
aValue
)
{
aMirror
=
aValue
;
}
static
void
MOZ_NEVER_INLINE
AssignMirror
(
DataMutexString
&
aMirror
nsCString
&
&
aValue
)
{
auto
lock
=
aMirror
.
Lock
(
)
;
lock
-
>
Assign
(
std
:
:
move
(
aValue
)
)
;
}
static
void
MOZ_NEVER_INLINE
AssignMirror
(
DataMutexString
&
aMirror
const
nsLiteralCString
&
aValue
)
{
auto
lock
=
aMirror
.
Lock
(
)
;
lock
-
>
Assign
(
aValue
)
;
}
static
void
ClearMirror
(
DataMutexString
&
aMirror
)
{
auto
lock
=
aMirror
.
Lock
(
)
;
lock
-
>
Assign
(
nsCString
(
)
)
;
}
template
<
typename
T
>
static
void
UpdateMirror
(
const
char
*
aPref
void
*
aMirror
)
{
StripAtomic
<
T
>
value
;
nsresult
rv
=
GetPrefValue
(
aPref
&
value
PrefValueKind
:
:
User
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
AssignMirror
(
*
static_cast
<
T
*
>
(
aMirror
)
std
:
:
forward
<
StripAtomic
<
T
>
>
(
value
)
)
;
}
else
{
NS_WARNING
(
nsPrintfCString
(
"
Pref
changed
failure
:
%
s
\
n
"
aPref
)
.
get
(
)
)
;
MOZ_ASSERT
(
false
)
;
}
}
template
<
typename
T
>
static
nsresult
RegisterCallback
(
void
*
aMirror
const
nsACString
&
aPref
)
{
return
Preferences
:
:
RegisterCallback
(
UpdateMirror
<
T
>
aPref
aMirror
Preferences
:
:
ExactMatch
true
)
;
}
}
;
nsresult
Preferences
:
:
InitInitialObjects
(
bool
aIsStartup
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
gSharedMap
)
;
if
(
aIsStartup
)
{
StaticPrefs
:
:
StartObservingAlwaysPrefs
(
)
;
}
return
NS_OK
;
}
StaticPrefs
:
:
InitAll
(
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
UniquePtr
<
nsZipFind
>
find
;
nsTArray
<
nsCString
>
prefEntries
;
const
char
*
entryName
;
uint16_t
entryNameLen
;
RefPtr
<
nsZipArchive
>
jarReader
=
Omnijar
:
:
GetReader
(
Omnijar
:
:
GRE
)
;
if
(
jarReader
)
{
#
ifdef
MOZ_WIDGET_ANDROID
const
char
*
abi
=
getenv
(
"
MOZ_ANDROID_CPU_ABI
"
)
;
if
(
abi
)
{
nsAutoCString
path
;
path
.
AppendPrintf
(
"
%
s
/
greprefs
.
js
"
abi
)
;
rv
=
pref_ReadPrefFromJar
(
jarReader
path
.
get
(
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
rv
=
pref_ReadPrefFromJar
(
jarReader
"
greprefs
.
js
"
)
;
}
#
else
rv
=
pref_ReadPrefFromJar
(
jarReader
"
greprefs
.
js
"
)
;
#
endif
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
pref_ReadDefaultPrefs
(
jarReader
"
defaults
/
pref
/
*
.
js
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
ifdef
MOZ_BACKGROUNDTASKS
if
(
BackgroundTasks
:
:
IsBackgroundTaskMode
(
)
)
{
rv
=
pref_ReadDefaultPrefs
(
jarReader
"
defaults
/
backgroundtasks
/
*
.
js
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
nsAutoCString
path
;
path
.
AppendPrintf
(
"
jar
:
gre
/
omni
.
jar
!
/
defaults
/
pref
/
%
s
/
*
.
js
"
abi
)
;
pref_ReadDefaultPrefs
(
jarReader
path
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
endif
}
else
{
nsCOMPtr
<
nsIFile
>
greprefsFile
;
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
greprefsFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
greprefsFile
-
>
AppendNative
(
"
greprefs
.
js
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
openPrefFile
(
greprefsFile
PrefValueKind
:
:
Default
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Error
parsing
GRE
default
preferences
.
Is
this
an
old
-
style
"
"
embedding
app
?
"
)
;
}
}
nsCOMPtr
<
nsIFile
>
defaultPrefDir
;
rv
=
NS_GetSpecialDirectory
(
NS_APP_PREF_DEFAULTS_50_DIR
getter_AddRefs
(
defaultPrefDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
static
const
char
*
specialFiles
[
]
=
{
#
if
defined
(
XP_MACOSX
)
"
macprefs
.
js
"
#
elif
defined
(
XP_WIN
)
"
winpref
.
js
"
#
elif
defined
(
XP_UNIX
)
"
unix
.
js
"
#
if
defined
(
_AIX
)
"
aix
.
js
"
#
endif
#
endif
}
;
rv
=
pref_LoadPrefsInDir
(
defaultPrefDir
specialFiles
ArrayLength
(
specialFiles
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Error
parsing
application
default
preferences
.
"
)
;
}
RefPtr
<
nsZipArchive
>
appJarReader
=
Omnijar
:
:
GetReader
(
Omnijar
:
:
APP
)
;
if
(
!
appJarReader
)
{
appJarReader
=
Omnijar
:
:
GetReader
(
Omnijar
:
:
GRE
)
;
}
if
(
appJarReader
)
{
rv
=
appJarReader
-
>
FindInit
(
"
defaults
/
preferences
/
*
.
js
"
getter_Transfers
(
find
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
prefEntries
.
Clear
(
)
;
while
(
NS_SUCCEEDED
(
find
-
>
FindNext
(
&
entryName
&
entryNameLen
)
)
)
{
prefEntries
.
AppendElement
(
Substring
(
entryName
entryNameLen
)
)
;
}
prefEntries
.
Sort
(
)
;
for
(
uint32_t
i
=
prefEntries
.
Length
(
)
;
i
-
-
;
)
{
rv
=
pref_ReadPrefFromJar
(
appJarReader
prefEntries
[
i
]
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Error
parsing
preferences
.
"
)
;
}
}
#
ifdef
MOZ_BACKGROUNDTASKS
if
(
BackgroundTasks
:
:
IsBackgroundTaskMode
(
)
)
{
rv
=
appJarReader
-
>
FindInit
(
"
defaults
/
backgroundtasks
/
*
.
js
"
getter_Transfers
(
find
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
prefEntries
.
Clear
(
)
;
while
(
NS_SUCCEEDED
(
find
-
>
FindNext
(
&
entryName
&
entryNameLen
)
)
)
{
prefEntries
.
AppendElement
(
Substring
(
entryName
entryNameLen
)
)
;
}
prefEntries
.
Sort
(
)
;
for
(
uint32_t
i
=
prefEntries
.
Length
(
)
;
i
-
-
;
)
{
rv
=
pref_ReadPrefFromJar
(
appJarReader
prefEntries
[
i
]
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Error
parsing
preferences
.
"
)
;
}
}
}
#
endif
}
nsCOMPtr
<
nsIProperties
>
dirSvc
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISimpleEnumerator
>
list
;
dirSvc
-
>
Get
(
NS_APP_PREFS_DEFAULTS_DIR_LIST
NS_GET_IID
(
nsISimpleEnumerator
)
getter_AddRefs
(
list
)
)
;
if
(
list
)
{
bool
hasMore
;
while
(
NS_SUCCEEDED
(
list
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
elem
;
list
-
>
GetNext
(
getter_AddRefs
(
elem
)
)
;
if
(
!
elem
)
{
continue
;
}
nsCOMPtr
<
nsIFile
>
path
=
do_QueryInterface
(
elem
)
;
if
(
!
path
)
{
continue
;
}
pref_LoadPrefsInDir
(
path
nullptr
0
)
;
}
}
if
(
XRE_IsParentProcess
(
)
)
{
SetupTelemetryPref
(
)
;
}
if
(
aIsStartup
)
{
StaticPrefs
:
:
StartObservingAlwaysPrefs
(
)
;
}
NS_CreateServicesFromCategory
(
NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID
nullptr
NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
observerService
-
>
NotifyObservers
(
nullptr
NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID
nullptr
)
;
return
NS_OK
;
}
nsresult
Preferences
:
:
GetBool
(
const
char
*
aPrefName
bool
*
aResult
PrefValueKind
aKind
)
{
MOZ_ASSERT
(
aResult
)
;
return
Internals
:
:
GetPrefValue
(
aPrefName
aResult
aKind
)
;
}
nsresult
Preferences
:
:
GetInt
(
const
char
*
aPrefName
int32_t
*
aResult
PrefValueKind
aKind
)
{
MOZ_ASSERT
(
aResult
)
;
return
Internals
:
:
GetPrefValue
(
aPrefName
aResult
aKind
)
;
}
nsresult
Preferences
:
:
GetFloat
(
const
char
*
aPrefName
float
*
aResult
PrefValueKind
aKind
)
{
MOZ_ASSERT
(
aResult
)
;
return
Internals
:
:
GetPrefValue
(
aPrefName
aResult
aKind
)
;
}
nsresult
Preferences
:
:
GetCString
(
const
char
*
aPrefName
nsACString
&
aResult
PrefValueKind
aKind
)
{
aResult
.
SetIsVoid
(
true
)
;
return
Internals
:
:
GetPrefValue
(
aPrefName
aResult
aKind
)
;
}
nsresult
Preferences
:
:
GetString
(
const
char
*
aPrefName
nsAString
&
aResult
PrefValueKind
aKind
)
{
nsAutoCString
result
;
nsresult
rv
=
Preferences
:
:
GetCString
(
aPrefName
result
aKind
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF8toUTF16
(
result
aResult
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetLocalizedCString
(
const
char
*
aPrefName
nsACString
&
aResult
PrefValueKind
aKind
)
{
nsAutoString
result
;
nsresult
rv
=
GetLocalizedString
(
aPrefName
result
aKind
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF16toUTF8
(
result
aResult
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetLocalizedString
(
const
char
*
aPrefName
nsAString
&
aResult
PrefValueKind
aKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsIPrefLocalizedString
>
prefLocalString
;
nsresult
rv
=
GetRootBranch
(
aKind
)
-
>
GetComplexValue
(
aPrefName
NS_GET_IID
(
nsIPrefLocalizedString
)
getter_AddRefs
(
prefLocalString
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_ASSERT
(
prefLocalString
"
Succeeded
but
the
result
is
NULL
"
)
;
prefLocalString
-
>
GetData
(
aResult
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetComplex
(
const
char
*
aPrefName
const
nsIID
&
aType
void
*
*
aResult
PrefValueKind
aKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
GetRootBranch
(
aKind
)
-
>
GetComplexValue
(
aPrefName
aType
aResult
)
;
}
bool
Preferences
:
:
GetBool
(
const
char
*
aPrefName
bool
aFallback
PrefValueKind
aKind
)
{
return
Internals
:
:
GetPref
(
aPrefName
aFallback
aKind
)
;
}
int32_t
Preferences
:
:
GetInt
(
const
char
*
aPrefName
int32_t
aFallback
PrefValueKind
aKind
)
{
return
Internals
:
:
GetPref
(
aPrefName
aFallback
aKind
)
;
}
uint32_t
Preferences
:
:
GetUint
(
const
char
*
aPrefName
uint32_t
aFallback
PrefValueKind
aKind
)
{
return
Internals
:
:
GetPref
(
aPrefName
aFallback
aKind
)
;
}
float
Preferences
:
:
GetFloat
(
const
char
*
aPrefName
float
aFallback
PrefValueKind
aKind
)
{
return
Internals
:
:
GetPref
(
aPrefName
aFallback
aKind
)
;
}
nsresult
Preferences
:
:
SetCString
(
const
char
*
aPrefName
const
nsACString
&
aValue
PrefValueKind
aKind
)
{
ENSURE_PARENT_PROCESS
(
"
SetCString
"
aPrefName
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
if
(
aValue
.
Length
(
)
>
MAX_PREF_LENGTH
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
PrefValue
prefValue
;
const
nsCString
&
flat
=
PromiseFlatCString
(
aValue
)
;
prefValue
.
mStringVal
=
flat
.
get
(
)
;
return
pref_SetPref
(
nsDependentCString
(
aPrefName
)
PrefType
:
:
String
aKind
prefValue
false
false
false
)
;
}
nsresult
Preferences
:
:
SetBool
(
const
char
*
aPrefName
bool
aValue
PrefValueKind
aKind
)
{
ENSURE_PARENT_PROCESS
(
"
SetBool
"
aPrefName
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
PrefValue
prefValue
;
prefValue
.
mBoolVal
=
aValue
;
return
pref_SetPref
(
nsDependentCString
(
aPrefName
)
PrefType
:
:
Bool
aKind
prefValue
false
false
false
)
;
}
nsresult
Preferences
:
:
SetInt
(
const
char
*
aPrefName
int32_t
aValue
PrefValueKind
aKind
)
{
ENSURE_PARENT_PROCESS
(
"
SetInt
"
aPrefName
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
PrefValue
prefValue
;
prefValue
.
mIntVal
=
aValue
;
return
pref_SetPref
(
nsDependentCString
(
aPrefName
)
PrefType
:
:
Int
aKind
prefValue
false
false
false
)
;
}
nsresult
Preferences
:
:
SetComplex
(
const
char
*
aPrefName
const
nsIID
&
aType
nsISupports
*
aValue
PrefValueKind
aKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
GetRootBranch
(
aKind
)
-
>
SetComplexValue
(
aPrefName
aType
aValue
)
;
}
nsresult
Preferences
:
:
Lock
(
const
char
*
aPrefName
)
{
ENSURE_PARENT_PROCESS
(
"
Lock
"
aPrefName
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
const
auto
&
prefName
=
nsDependentCString
(
aPrefName
)
;
Pref
*
pref
;
MOZ_TRY_VAR
(
pref
pref_LookupForModify
(
prefName
[
]
(
const
PrefWrapper
&
aPref
)
{
return
!
aPref
.
IsLocked
(
)
;
}
)
)
;
if
(
pref
)
{
pref
-
>
SetIsLocked
(
true
)
;
NotifyCallbacks
(
prefName
PrefWrapper
(
pref
)
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
Unlock
(
const
char
*
aPrefName
)
{
ENSURE_PARENT_PROCESS
(
"
Unlock
"
aPrefName
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
const
auto
&
prefName
=
nsDependentCString
(
aPrefName
)
;
Pref
*
pref
;
MOZ_TRY_VAR
(
pref
pref_LookupForModify
(
prefName
[
]
(
const
PrefWrapper
&
aPref
)
{
return
aPref
.
IsLocked
(
)
;
}
)
)
;
if
(
pref
)
{
pref
-
>
SetIsLocked
(
false
)
;
NotifyCallbacks
(
prefName
PrefWrapper
(
pref
)
)
;
}
return
NS_OK
;
}
bool
Preferences
:
:
IsLocked
(
const
char
*
aPrefName
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
false
)
;
Maybe
<
PrefWrapper
>
pref
=
pref_Lookup
(
aPrefName
)
;
return
pref
.
isSome
(
)
&
&
pref
-
>
IsLocked
(
)
;
}
bool
Preferences
:
:
IsSanitized
(
const
char
*
aPrefName
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
false
)
;
Maybe
<
PrefWrapper
>
pref
=
pref_Lookup
(
aPrefName
)
;
return
pref
.
isSome
(
)
&
&
pref
-
>
IsSanitized
(
)
;
}
nsresult
Preferences
:
:
ClearUser
(
const
char
*
aPrefName
)
{
ENSURE_PARENT_PROCESS
(
"
ClearUser
"
aPrefName
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
const
auto
&
prefName
=
nsDependentCString
{
aPrefName
}
;
auto
result
=
pref_LookupForModify
(
prefName
[
]
(
const
PrefWrapper
&
aPref
)
{
return
aPref
.
HasUserValue
(
)
;
}
)
;
if
(
result
.
isErr
(
)
)
{
return
NS_OK
;
}
if
(
Pref
*
pref
=
result
.
unwrap
(
)
)
{
pref
-
>
ClearUserValue
(
)
;
if
(
!
pref
-
>
HasDefaultValue
(
)
)
{
MOZ_ASSERT
(
!
gSharedMap
|
|
!
pref
-
>
IsSanitized
(
)
|
|
!
gSharedMap
-
>
Has
(
pref
-
>
Name
(
)
)
"
A
sanitized
pref
should
never
be
in
the
shared
pref
map
.
"
)
;
if
(
!
pref
-
>
IsSanitized
(
)
&
&
(
!
gSharedMap
|
|
!
gSharedMap
-
>
Has
(
pref
-
>
Name
(
)
)
)
)
{
HashTable
(
)
-
>
remove
(
aPrefName
)
;
}
else
{
pref
-
>
SetType
(
PrefType
:
:
None
)
;
}
NotifyCallbacks
(
prefName
)
;
}
else
{
NotifyCallbacks
(
prefName
PrefWrapper
(
pref
)
)
;
}
Preferences
:
:
HandleDirty
(
)
;
}
return
NS_OK
;
}
bool
Preferences
:
:
HasUserValue
(
const
char
*
aPrefName
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
false
)
;
Maybe
<
PrefWrapper
>
pref
=
pref_Lookup
(
aPrefName
)
;
return
pref
.
isSome
(
)
&
&
pref
-
>
HasUserValue
(
)
;
}
bool
Preferences
:
:
HasDefaultValue
(
const
char
*
aPrefName
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
false
)
;
Maybe
<
PrefWrapper
>
pref
=
pref_Lookup
(
aPrefName
)
;
return
pref
.
isSome
(
)
&
&
pref
-
>
HasDefaultValue
(
)
;
}
int32_t
Preferences
:
:
GetType
(
const
char
*
aPrefName
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
nsIPrefBranch
:
:
PREF_INVALID
)
;
if
(
!
HashTable
(
)
)
{
return
PREF_INVALID
;
}
Maybe
<
PrefWrapper
>
pref
=
pref_Lookup
(
aPrefName
)
;
if
(
!
pref
.
isSome
(
)
)
{
return
PREF_INVALID
;
}
switch
(
pref
-
>
Type
(
)
)
{
case
PrefType
:
:
String
:
return
PREF_STRING
;
case
PrefType
:
:
Int
:
return
PREF_INT
;
case
PrefType
:
:
Bool
:
return
PREF_BOOL
;
case
PrefType
:
:
None
:
if
(
!
XRE_IsParentProcess
(
)
&
&
sCrashOnBlocklistedPref
&
&
gContentProcessPrefsAreInited
&
&
ShouldSanitizePreference
(
aPrefName
XRE_IsContentProcess
(
)
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Should
not
access
the
preference
'
%
s
'
in
the
Content
Processes
"
aPrefName
)
;
}
[
[
fallthrough
]
]
;
default
:
MOZ_CRASH
(
)
;
}
}
nsresult
Preferences
:
:
AddStrongObserver
(
nsIObserver
*
aObserver
const
nsACString
&
aPref
)
{
MOZ_ASSERT
(
aObserver
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
sPreferences
-
>
mRootBranch
-
>
AddObserver
(
aPref
aObserver
false
)
;
}
nsresult
Preferences
:
:
AddWeakObserver
(
nsIObserver
*
aObserver
const
nsACString
&
aPref
)
{
MOZ_ASSERT
(
aObserver
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
sPreferences
-
>
mRootBranch
-
>
AddObserver
(
aPref
aObserver
true
)
;
}
nsresult
Preferences
:
:
RemoveObserver
(
nsIObserver
*
aObserver
const
nsACString
&
aPref
)
{
MOZ_ASSERT
(
aObserver
)
;
if
(
sShutdown
)
{
MOZ_ASSERT
(
!
sPreferences
)
;
return
NS_OK
;
}
NS_ENSURE_TRUE
(
sPreferences
NS_ERROR_NOT_AVAILABLE
)
;
return
sPreferences
-
>
mRootBranch
-
>
RemoveObserver
(
aPref
aObserver
)
;
}
template
<
typename
T
>
static
void
AssertNotMallocAllocated
(
T
*
aPtr
)
{
#
if
defined
(
DEBUG
)
&
&
defined
(
MOZ_MEMORY
)
jemalloc_ptr_info_t
info
;
jemalloc_ptr_info
(
(
void
*
)
aPtr
&
info
)
;
MOZ_ASSERT
(
info
.
tag
=
=
TagUnknown
)
;
#
endif
}
nsresult
Preferences
:
:
AddStrongObservers
(
nsIObserver
*
aObserver
const
char
*
*
aPrefs
)
{
MOZ_ASSERT
(
aObserver
)
;
for
(
uint32_t
i
=
0
;
aPrefs
[
i
]
;
i
+
+
)
{
AssertNotMallocAllocated
(
aPrefs
[
i
]
)
;
nsCString
pref
;
pref
.
AssignLiteral
(
aPrefs
[
i
]
strlen
(
aPrefs
[
i
]
)
)
;
nsresult
rv
=
AddStrongObserver
(
aObserver
pref
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
AddWeakObservers
(
nsIObserver
*
aObserver
const
char
*
*
aPrefs
)
{
MOZ_ASSERT
(
aObserver
)
;
for
(
uint32_t
i
=
0
;
aPrefs
[
i
]
;
i
+
+
)
{
AssertNotMallocAllocated
(
aPrefs
[
i
]
)
;
nsCString
pref
;
pref
.
AssignLiteral
(
aPrefs
[
i
]
strlen
(
aPrefs
[
i
]
)
)
;
nsresult
rv
=
AddWeakObserver
(
aObserver
pref
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
RemoveObservers
(
nsIObserver
*
aObserver
const
char
*
*
aPrefs
)
{
MOZ_ASSERT
(
aObserver
)
;
if
(
sShutdown
)
{
MOZ_ASSERT
(
!
sPreferences
)
;
return
NS_OK
;
}
NS_ENSURE_TRUE
(
sPreferences
NS_ERROR_NOT_AVAILABLE
)
;
for
(
uint32_t
i
=
0
;
aPrefs
[
i
]
;
i
+
+
)
{
nsresult
rv
=
RemoveObserver
(
aObserver
nsDependentCString
(
aPrefs
[
i
]
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
template
<
typename
T
>
nsresult
Preferences
:
:
RegisterCallbackImpl
(
PrefChangedFunc
aCallback
T
&
aPrefNode
void
*
aData
MatchKind
aMatchKind
bool
aIsPriority
)
{
NS_ENSURE_ARG
(
aCallback
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
auto
node
=
new
CallbackNode
(
aPrefNode
aCallback
aData
aMatchKind
)
;
if
(
aIsPriority
)
{
node
-
>
SetNext
(
gFirstCallback
)
;
gFirstCallback
=
node
;
if
(
!
gLastPriorityNode
)
{
gLastPriorityNode
=
node
;
}
}
else
{
if
(
gLastPriorityNode
)
{
node
-
>
SetNext
(
gLastPriorityNode
-
>
Next
(
)
)
;
gLastPriorityNode
-
>
SetNext
(
node
)
;
}
else
{
node
-
>
SetNext
(
gFirstCallback
)
;
gFirstCallback
=
node
;
}
}
return
NS_OK
;
}
nsresult
Preferences
:
:
RegisterCallback
(
PrefChangedFunc
aCallback
const
nsACString
&
aPrefNode
void
*
aData
MatchKind
aMatchKind
bool
aIsPriority
)
{
return
RegisterCallbackImpl
(
aCallback
aPrefNode
aData
aMatchKind
aIsPriority
)
;
}
nsresult
Preferences
:
:
RegisterCallbacks
(
PrefChangedFunc
aCallback
const
char
*
*
aPrefs
void
*
aData
MatchKind
aMatchKind
)
{
return
RegisterCallbackImpl
(
aCallback
aPrefs
aData
aMatchKind
)
;
}
nsresult
Preferences
:
:
RegisterCallbackAndCall
(
PrefChangedFunc
aCallback
const
nsACString
&
aPref
void
*
aClosure
MatchKind
aMatchKind
)
{
MOZ_ASSERT
(
aCallback
)
;
nsresult
rv
=
RegisterCallback
(
aCallback
aPref
aClosure
aMatchKind
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
(
*
aCallback
)
(
PromiseFlatCString
(
aPref
)
.
get
(
)
aClosure
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
RegisterCallbacksAndCall
(
PrefChangedFunc
aCallback
const
char
*
*
aPrefs
void
*
aClosure
)
{
MOZ_ASSERT
(
aCallback
)
;
nsresult
rv
=
RegisterCallbacks
(
aCallback
aPrefs
aClosure
MatchKind
:
:
ExactMatch
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
const
char
*
*
ptr
=
aPrefs
;
*
ptr
;
ptr
+
+
)
{
(
*
aCallback
)
(
*
ptr
aClosure
)
;
}
}
return
rv
;
}
template
<
typename
T
>
nsresult
Preferences
:
:
UnregisterCallbackImpl
(
PrefChangedFunc
aCallback
T
&
aPrefNode
void
*
aData
MatchKind
aMatchKind
)
{
MOZ_ASSERT
(
aCallback
)
;
if
(
sShutdown
)
{
MOZ_ASSERT
(
!
sPreferences
)
;
return
NS_OK
;
}
NS_ENSURE_TRUE
(
sPreferences
NS_ERROR_NOT_AVAILABLE
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
CallbackNode
*
node
=
gFirstCallback
;
CallbackNode
*
prev_node
=
nullptr
;
while
(
node
)
{
if
(
node
-
>
Func
(
)
=
=
aCallback
&
&
node
-
>
Data
(
)
=
=
aData
&
&
node
-
>
MatchKind
(
)
=
=
aMatchKind
&
&
node
-
>
DomainIs
(
aPrefNode
)
)
{
if
(
gCallbacksInProgress
)
{
node
-
>
ClearFunc
(
)
;
gShouldCleanupDeadNodes
=
true
;
prev_node
=
node
;
node
=
node
-
>
Next
(
)
;
}
else
{
node
=
pref_RemoveCallbackNode
(
node
prev_node
)
;
}
rv
=
NS_OK
;
}
else
{
prev_node
=
node
;
node
=
node
-
>
Next
(
)
;
}
}
return
rv
;
}
nsresult
Preferences
:
:
UnregisterCallback
(
PrefChangedFunc
aCallback
const
nsACString
&
aPrefNode
void
*
aData
MatchKind
aMatchKind
)
{
return
UnregisterCallbackImpl
<
const
nsACString
&
>
(
aCallback
aPrefNode
aData
aMatchKind
)
;
}
nsresult
Preferences
:
:
UnregisterCallbacks
(
PrefChangedFunc
aCallback
const
char
*
*
aPrefs
void
*
aData
MatchKind
aMatchKind
)
{
return
UnregisterCallbackImpl
(
aCallback
aPrefs
aData
aMatchKind
)
;
}
template
<
typename
T
>
static
void
AddMirrorCallback
(
T
*
aMirror
const
nsACString
&
aPref
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Internals
:
:
RegisterCallback
<
T
>
(
aMirror
aPref
)
;
}
template
<
typename
T
>
static
MOZ_NEVER_INLINE
void
AddMirror
(
T
*
aMirror
const
nsACString
&
aPref
StripAtomic
<
T
>
aDefault
)
{
*
aMirror
=
Internals
:
:
GetPref
(
PromiseFlatCString
(
aPref
)
.
get
(
)
aDefault
)
;
AddMirrorCallback
(
aMirror
aPref
)
;
}
static
MOZ_NEVER_INLINE
void
AddMirror
(
DataMutexString
&
aMirror
const
nsACString
&
aPref
)
{
auto
lock
=
aMirror
.
Lock
(
)
;
nsCString
result
(
*
lock
)
;
Internals
:
:
GetPrefValue
(
PromiseFlatCString
(
aPref
)
.
get
(
)
result
PrefValueKind
:
:
User
)
;
lock
-
>
Assign
(
std
:
:
move
(
result
)
)
;
AddMirrorCallback
(
&
aMirror
aPref
)
;
}
static
void
InitPref_bool
(
const
nsCString
&
aName
bool
aDefaultValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
PrefValue
value
;
value
.
mBoolVal
=
aDefaultValue
;
pref_SetPref
(
aName
PrefType
:
:
Bool
PrefValueKind
:
:
Default
value
false
false
true
)
;
}
static
void
InitPref_int32_t
(
const
nsCString
&
aName
int32_t
aDefaultValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
PrefValue
value
;
value
.
mIntVal
=
aDefaultValue
;
pref_SetPref
(
aName
PrefType
:
:
Int
PrefValueKind
:
:
Default
value
false
false
true
)
;
}
static
void
InitPref_uint32_t
(
const
nsCString
&
aName
uint32_t
aDefaultValue
)
{
InitPref_int32_t
(
aName
int32_t
(
aDefaultValue
)
)
;
}
static
void
InitPref_float
(
const
nsCString
&
aName
float
aDefaultValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
PrefValue
value
;
nsAutoCString
defaultValue
;
defaultValue
.
AppendFloat
(
aDefaultValue
)
;
if
(
!
defaultValue
.
Contains
(
'
.
'
)
&
&
!
defaultValue
.
Contains
(
'
e
'
)
)
{
defaultValue
.
AppendLiteral
(
"
.
0
"
)
;
}
value
.
mStringVal
=
defaultValue
.
get
(
)
;
pref_SetPref
(
aName
PrefType
:
:
String
PrefValueKind
:
:
Default
value
false
false
true
)
;
}
static
void
InitPref_String
(
const
nsCString
&
aName
const
char
*
aDefaultValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
PrefValue
value
;
value
.
mStringVal
=
aDefaultValue
;
pref_SetPref
(
aName
PrefType
:
:
String
PrefValueKind
:
:
Default
value
false
false
true
)
;
}
static
void
InitPref
(
const
nsCString
&
aName
bool
aDefaultValue
)
{
InitPref_bool
(
aName
aDefaultValue
)
;
}
static
void
InitPref
(
const
nsCString
&
aName
int32_t
aDefaultValue
)
{
InitPref_int32_t
(
aName
aDefaultValue
)
;
}
static
void
InitPref
(
const
nsCString
&
aName
uint32_t
aDefaultValue
)
{
InitPref_uint32_t
(
aName
aDefaultValue
)
;
}
static
void
InitPref
(
const
nsCString
&
aName
float
aDefaultValue
)
{
InitPref_float
(
aName
aDefaultValue
)
;
}
template
<
typename
T
>
static
void
InitAlwaysPref
(
const
nsCString
&
aName
T
*
aCache
StripAtomic
<
T
>
aDefaultValue
)
{
InitPref
(
aName
aDefaultValue
)
;
*
aCache
=
aDefaultValue
;
}
static
void
InitAlwaysPref
(
const
nsCString
&
aName
DataMutexString
&
aCache
const
nsLiteralCString
&
aDefaultValue
)
{
InitPref_String
(
aName
aDefaultValue
.
get
(
)
)
;
Internals
:
:
AssignMirror
(
aCache
aDefaultValue
)
;
}
static
Atomic
<
bool
>
sOncePrefRead
(
false
)
;
static
StaticMutex
sOncePrefMutex
MOZ_UNANNOTATED
;
namespace
StaticPrefs
{
void
MaybeInitOncePrefs
(
)
{
if
(
MOZ_LIKELY
(
sOncePrefRead
)
)
{
return
;
}
StaticMutexAutoLock
lock
(
sOncePrefMutex
)
;
if
(
NS_IsMainThread
(
)
)
{
InitOncePrefs
(
)
;
}
else
{
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
Preferences
:
:
MaybeInitOncePrefs
"
[
&
]
(
)
{
InitOncePrefs
(
)
;
}
)
;
SyncRunnable
:
:
DispatchToThread
(
GetMainThreadSerialEventTarget
(
)
runnable
)
;
}
sOncePrefRead
=
true
;
}
#
define
NEVER_PREF
(
name
cpp_type
value
)
#
define
ALWAYS_PREF
(
name
base_id
full_id
cpp_type
default_value
)
\
cpp_type
sMirror_
#
#
full_id
(
default_value
)
;
#
define
ALWAYS_DATAMUTEX_PREF
(
name
base_id
full_id
cpp_type
default_value
)
\
cpp_type
sMirror_
#
#
full_id
(
"
DataMutexString
"
)
;
#
define
ONCE_PREF
(
name
base_id
full_id
cpp_type
default_value
)
\
cpp_type
sMirror_
#
#
full_id
(
default_value
)
;
#
include
"
mozilla
/
StaticPrefListAll
.
h
"
#
undef
NEVER_PREF
#
undef
ALWAYS_PREF
#
undef
ALWAYS_DATAMUTEX_PREF
#
undef
ONCE_PREF
static
void
InitAll
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
#
define
NEVER_PREF
(
name
cpp_type
value
)
\
InitPref_
#
#
cpp_type
(
name
"
"
_ns
value
)
;
#
define
ALWAYS_PREF
(
name
base_id
full_id
cpp_type
value
)
\
InitAlwaysPref
(
name
"
"
_ns
&
sMirror_
#
#
full_id
value
)
;
#
define
ALWAYS_DATAMUTEX_PREF
(
name
base_id
full_id
cpp_type
value
)
\
InitAlwaysPref
(
name
"
"
_ns
sMirror_
#
#
full_id
value
)
;
#
define
ONCE_PREF
(
name
base_id
full_id
cpp_type
value
)
\
InitPref_
#
#
cpp_type
(
name
"
"
_ns
value
)
;
#
include
"
mozilla
/
StaticPrefListAll
.
h
"
#
undef
NEVER_PREF
#
undef
ALWAYS_PREF
#
undef
ALWAYS_DATAMUTEX_PREF
#
undef
ONCE_PREF
}
static
void
StartObservingAlwaysPrefs
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
define
NEVER_PREF
(
name
cpp_type
value
)
#
define
ALWAYS_PREF
(
name
base_id
full_id
cpp_type
value
)
\
AddMirror
(
&
sMirror_
#
#
full_id
name
"
"
_ns
sMirror_
#
#
full_id
)
;
#
define
ALWAYS_DATAMUTEX_PREF
(
name
base_id
full_id
cpp_type
value
)
\
AddMirror
(
sMirror_
#
#
full_id
name
"
"
_ns
)
;
#
define
ONCE_PREF
(
name
base_id
full_id
cpp_type
value
)
#
include
"
mozilla
/
StaticPrefListAll
.
h
"
#
undef
NEVER_PREF
#
undef
ALWAYS_PREF
#
undef
ALWAYS_DATAMUTEX_PREF
#
undef
ONCE_PREF
}
static
void
InitOncePrefs
(
)
{
#
define
NEVER_PREF
(
name
cpp_type
value
)
#
define
ALWAYS_PREF
(
name
base_id
full_id
cpp_type
value
)
#
define
ALWAYS_DATAMUTEX_PREF
(
name
base_id
full_id
cpp_type
value
)
#
ifdef
DEBUG
#
define
ONCE_PREF
(
name
base_id
full_id
cpp_type
value
)
\
{
\
MOZ_ASSERT
(
gOnceStaticPrefsAntiFootgun
)
;
\
sMirror_
#
#
full_id
=
Internals
:
:
GetPref
(
name
cpp_type
(
value
)
)
;
\
auto
checkPref
=
[
&
]
(
)
{
\
MOZ_ASSERT
(
sOncePrefRead
)
;
\
cpp_type
staticPrefValue
=
full_id
(
)
;
\
cpp_type
preferenceValue
=
\
Internals
:
:
GetPref
(
GetPrefName_
#
#
base_id
(
)
cpp_type
(
value
)
)
;
\
MOZ_ASSERT
(
staticPrefValue
=
=
preferenceValue
\
"
Preference
'
"
name
\
"
'
got
modified
since
StaticPrefs
:
:
"
#
full_id
\
"
was
initialized
.
Consider
using
an
always
mirror
kind
"
\
"
instead
"
)
;
\
}
;
\
gOnceStaticPrefsAntiFootgun
-
>
insert
(
\
std
:
:
pair
<
const
char
*
AntiFootgunCallback
>
(
GetPrefName_
#
#
base_id
(
)
\
std
:
:
move
(
checkPref
)
)
)
;
\
}
#
else
#
define
ONCE_PREF
(
name
base_id
full_id
cpp_type
value
)
\
sMirror_
#
#
full_id
=
Internals
:
:
GetPref
(
name
cpp_type
(
value
)
)
;
#
endif
#
include
"
mozilla
/
StaticPrefListAll
.
h
"
#
undef
NEVER_PREF
#
undef
ALWAYS_PREF
#
undef
ALWAYS_DATAMUTEX_PREF
#
undef
ONCE_PREF
}
static
void
ShutdownAlwaysPrefs
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
define
NEVER_PREF
(
name
cpp_type
value
)
#
define
ALWAYS_PREF
(
name
base_id
full_id
cpp_type
value
)
#
define
ALWAYS_DATAMUTEX_PREF
(
name
base_id
full_id
cpp_type
value
)
\
Internals
:
:
ClearMirror
(
sMirror_
#
#
full_id
)
;
#
define
ONCE_PREF
(
name
base_id
full_id
cpp_type
value
)
#
include
"
mozilla
/
StaticPrefListAll
.
h
"
#
undef
NEVER_PREF
#
undef
ALWAYS_PREF
#
undef
ALWAYS_DATAMUTEX_PREF
#
undef
ONCE_PREF
}
}
static
MOZ_MAYBE_UNUSED
void
SaveOncePrefToSharedMap
(
SharedPrefMapBuilder
&
aBuilder
const
nsACString
&
aName
bool
aValue
)
{
auto
oncePref
=
MakeUnique
<
Pref
>
(
aName
)
;
oncePref
-
>
SetType
(
PrefType
:
:
Bool
)
;
oncePref
-
>
SetIsSkippedByIteration
(
true
)
;
bool
valueChanged
=
false
;
MOZ_ALWAYS_SUCCEEDS
(
oncePref
-
>
SetDefaultValue
(
PrefType
:
:
Bool
PrefValue
(
aValue
)
true
true
&
valueChanged
)
)
;
oncePref
-
>
AddToMap
(
aBuilder
)
;
}
static
MOZ_MAYBE_UNUSED
void
SaveOncePrefToSharedMap
(
SharedPrefMapBuilder
&
aBuilder
const
nsACString
&
aName
int32_t
aValue
)
{
auto
oncePref
=
MakeUnique
<
Pref
>
(
aName
)
;
oncePref
-
>
SetType
(
PrefType
:
:
Int
)
;
oncePref
-
>
SetIsSkippedByIteration
(
true
)
;
bool
valueChanged
=
false
;
MOZ_ALWAYS_SUCCEEDS
(
oncePref
-
>
SetDefaultValue
(
PrefType
:
:
Int
PrefValue
(
aValue
)
true
true
&
valueChanged
)
)
;
oncePref
-
>
AddToMap
(
aBuilder
)
;
}
static
MOZ_MAYBE_UNUSED
void
SaveOncePrefToSharedMap
(
SharedPrefMapBuilder
&
aBuilder
const
nsACString
&
aName
uint32_t
aValue
)
{
SaveOncePrefToSharedMap
(
aBuilder
aName
int32_t
(
aValue
)
)
;
}
static
MOZ_MAYBE_UNUSED
void
SaveOncePrefToSharedMap
(
SharedPrefMapBuilder
&
aBuilder
const
nsACString
&
aName
float
aValue
)
{
auto
oncePref
=
MakeUnique
<
Pref
>
(
aName
)
;
oncePref
-
>
SetType
(
PrefType
:
:
String
)
;
oncePref
-
>
SetIsSkippedByIteration
(
true
)
;
nsAutoCString
value
;
value
.
AppendFloat
(
aValue
)
;
bool
valueChanged
=
false
;
const
nsCString
&
flat
=
PromiseFlatCString
(
value
)
;
MOZ_ALWAYS_SUCCEEDS
(
oncePref
-
>
SetDefaultValue
(
PrefType
:
:
String
PrefValue
(
flat
.
get
(
)
)
true
true
&
valueChanged
)
)
;
oncePref
-
>
AddToMap
(
aBuilder
)
;
}
#
define
ONCE_PREF_NAME
(
name
)
"
"
name
"
"
namespace
StaticPrefs
{
static
void
RegisterOncePrefs
(
SharedPrefMapBuilder
&
aBuilder
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
gSharedMap
"
Must
be
called
before
gSharedMap
has
been
created
"
)
;
MaybeInitOncePrefs
(
)
;
#
define
NEVER_PREF
(
name
cpp_type
value
)
#
define
ALWAYS_PREF
(
name
base_id
full_id
cpp_type
value
)
#
define
ALWAYS_DATAMUTEX_PREF
(
name
base_id
full_id
cpp_type
value
)
#
define
ONCE_PREF
(
name
base_id
full_id
cpp_type
value
)
\
SaveOncePrefToSharedMap
(
aBuilder
ONCE_PREF_NAME
(
name
)
"
"
_ns
\
cpp_type
(
sMirror_
#
#
full_id
)
)
;
#
include
"
mozilla
/
StaticPrefListAll
.
h
"
#
undef
NEVER_PREF
#
undef
ALWAYS_PREF
#
undef
ALWAYS_DATAMUTEX_PREF
#
undef
ONCE_PREF
}
static
void
InitStaticPrefsFromShared
(
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
gSharedMap
"
Must
be
called
once
gSharedMap
has
been
created
"
)
;
#
define
NEVER_PREF
(
name
cpp_type
default_value
)
#
define
ALWAYS_PREF
(
name
base_id
full_id
cpp_type
default_value
)
\
{
\
StripAtomic
<
cpp_type
>
val
;
\
if
(
!
XRE_IsParentProcess
(
)
&
&
IsString
<
cpp_type
>
:
:
value
&
&
\
gContentProcessPrefsAreInited
&
&
sCrashOnBlocklistedPref
)
{
\
MOZ_DIAGNOSTIC_ASSERT
(
\
!
ShouldSanitizePreference
(
name
XRE_IsContentProcess
(
)
)
\
"
Should
not
access
the
preference
'
"
name
"
'
in
Content
Processes
"
)
;
\
}
\
DebugOnly
<
nsresult
>
rv
=
Internals
:
:
GetSharedPrefValue
(
name
&
val
)
;
\
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Failed
accessing
"
name
)
;
\
StaticPrefs
:
:
sMirror_
#
#
full_id
=
val
;
\
}
#
define
ALWAYS_DATAMUTEX_PREF
(
name
base_id
full_id
cpp_type
default_value
)
\
{
\
StripAtomic
<
cpp_type
>
val
;
\
if
(
!
XRE_IsParentProcess
(
)
&
&
IsString
<
cpp_type
>
:
:
value
&
&
\
gContentProcessPrefsAreInited
&
&
sCrashOnBlocklistedPref
)
{
\
MOZ_DIAGNOSTIC_ASSERT
(
\
!
ShouldSanitizePreference
(
name
XRE_IsContentProcess
(
)
)
\
"
Should
not
access
the
preference
'
"
name
"
'
in
Content
Processes
"
)
;
\
}
\
DebugOnly
<
nsresult
>
rv
=
Internals
:
:
GetSharedPrefValue
(
name
&
val
)
;
\
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Failed
accessing
"
name
)
;
\
Internals
:
:
AssignMirror
(
StaticPrefs
:
:
sMirror_
#
#
full_id
\
std
:
:
forward
<
StripAtomic
<
cpp_type
>
>
(
val
)
)
;
\
}
#
define
ONCE_PREF
(
name
base_id
full_id
cpp_type
default_value
)
\
{
\
cpp_type
val
;
\
if
(
!
XRE_IsParentProcess
(
)
&
&
IsString
<
cpp_type
>
:
:
value
&
&
\
gContentProcessPrefsAreInited
&
&
sCrashOnBlocklistedPref
)
{
\
MOZ_DIAGNOSTIC_ASSERT
(
\
!
ShouldSanitizePreference
(
name
XRE_IsContentProcess
(
)
)
\
"
Should
not
access
the
preference
'
"
name
"
'
in
Content
Processes
"
)
;
\
}
\
DebugOnly
<
nsresult
>
rv
=
\
Internals
:
:
GetSharedPrefValue
(
ONCE_PREF_NAME
(
name
)
&
val
)
;
\
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Failed
accessing
"
name
)
;
\
StaticPrefs
:
:
sMirror_
#
#
full_id
=
val
;
\
}
#
include
"
mozilla
/
StaticPrefListAll
.
h
"
#
undef
NEVER_PREF
#
undef
ALWAYS_PREF
#
undef
ALWAYS_DATAMUTEX_PREF
#
undef
ONCE_PREF
sOncePrefRead
=
true
;
}
}
}
#
undef
ENSURE_PARENT_PROCESS
NS_IMPL_COMPONENT_FACTORY
(
nsPrefLocalizedString
)
{
auto
str
=
MakeRefPtr
<
nsPrefLocalizedString
>
(
)
;
if
(
NS_SUCCEEDED
(
str
-
>
Init
(
)
)
)
{
return
str
.
forget
(
)
.
downcast
<
nsISupports
>
(
)
;
}
return
nullptr
;
}
namespace
mozilla
{
void
UnloadPrefsModule
(
)
{
Preferences
:
:
Shutdown
(
)
;
}
}
#
define
PREF_LIST_ENTRY
(
s
)
\
{
s
(
sizeof
(
s
)
/
sizeof
(
char
)
)
-
1
}
struct
PrefListEntry
{
const
char
*
mPrefBranch
;
size_t
mLen
;
}
;
static
const
PrefListEntry
sParentOnlyPrefBranchList
[
]
=
{
PREF_LIST_ENTRY
(
"
datareporting
.
policy
.
"
)
PREF_LIST_ENTRY
(
"
browser
.
download
.
lastDir
"
)
PREF_LIST_ENTRY
(
"
browser
.
newtabpage
.
pinned
"
)
PREF_LIST_ENTRY
(
"
browser
.
uiCustomization
.
state
"
)
PREF_LIST_ENTRY
(
"
browser
.
urlbar
"
)
PREF_LIST_ENTRY
(
"
browser
.
urlbar
.
resultGroups
"
)
PREF_LIST_ENTRY
(
"
devtools
.
debugger
.
pending
-
selected
-
location
"
)
PREF_LIST_ENTRY
(
"
identity
.
fxaccounts
.
account
.
device
.
name
"
)
PREF_LIST_ENTRY
(
"
identity
.
fxaccounts
.
account
.
telemetry
.
sanitized_uid
"
)
PREF_LIST_ENTRY
(
"
identity
.
fxaccounts
.
lastSignedInUserHash
"
)
PREF_LIST_ENTRY
(
"
print_printer
"
)
PREF_LIST_ENTRY
(
"
services
.
"
)
PREF_LIST_ENTRY
(
"
app
.
normandy
.
user_id
"
)
PREF_LIST_ENTRY
(
"
browser
.
newtabpage
.
activity
-
stream
.
impressionId
"
)
PREF_LIST_ENTRY
(
"
browser
.
pageActions
.
persistedActions
"
)
PREF_LIST_ENTRY
(
"
browser
.
startup
.
lastColdStartupCheck
"
)
PREF_LIST_ENTRY
(
"
dom
.
push
.
userAgentID
"
)
PREF_LIST_ENTRY
(
"
extensions
.
webextensions
.
uuids
"
)
PREF_LIST_ENTRY
(
"
privacy
.
userContext
.
extension
"
)
PREF_LIST_ENTRY
(
"
toolkit
.
telemetry
.
cachedClientID
"
)
PREF_LIST_ENTRY
(
"
app
.
update
.
lastUpdateTime
.
"
)
PREF_LIST_ENTRY
(
"
browser
.
contentblocking
.
cfr
-
milestone
.
milestone
-
shown
-
time
"
)
PREF_LIST_ENTRY
(
"
browser
.
contextual
-
services
.
contextId
"
)
PREF_LIST_ENTRY
(
"
browser
.
laterrun
.
bookkeeping
.
profileCreationTime
"
)
PREF_LIST_ENTRY
(
"
browser
.
newtabpage
.
activity
-
stream
.
discoverystream
.
"
)
PREF_LIST_ENTRY
(
"
browser
.
sessionstore
.
upgradeBackup
.
latestBuildID
"
)
PREF_LIST_ENTRY
(
"
browser
.
shell
.
mostRecentDateSetAsDefault
"
)
PREF_LIST_ENTRY
(
"
fission
.
experiment
.
max
-
origins
.
last
-
"
)
PREF_LIST_ENTRY
(
"
idle
.
lastDailyNotification
"
)
PREF_LIST_ENTRY
(
"
media
.
gmp
-
gmpopenh264
.
lastUpdate
"
)
PREF_LIST_ENTRY
(
"
media
.
gmp
-
manager
.
lastCheck
"
)
PREF_LIST_ENTRY
(
"
places
.
database
.
lastMaintenance
"
)
PREF_LIST_ENTRY
(
"
privacy
.
purge_trackers
.
last_purge
"
)
PREF_LIST_ENTRY
(
"
security
.
sandbox
.
content
.
tempDirSuffix
"
)
PREF_LIST_ENTRY
(
"
storage
.
vacuum
.
last
.
places
.
sqlite
"
)
PREF_LIST_ENTRY
(
"
toolkit
.
startup
.
last_success
"
)
PREF_LIST_ENTRY
(
"
browser
.
startup
.
homepage_override
.
buildID
"
)
PREF_LIST_ENTRY
(
"
extensions
.
lastAppBuildId
"
)
PREF_LIST_ENTRY
(
"
media
.
gmp
-
manager
.
buildID
"
)
PREF_LIST_ENTRY
(
"
toolkit
.
telemetry
.
previousBuildID
"
)
}
;
static
const
PrefListEntry
sDynamicPrefOverrideList
[
]
{
PREF_LIST_ENTRY
(
"
autoadmin
.
global_config_url
"
)
PREF_LIST_ENTRY
(
"
browser
.
contentblocking
.
category
"
)
PREF_LIST_ENTRY
(
"
browser
.
search
.
region
"
)
PREF_LIST_ENTRY
(
"
browser
.
tabs
.
remote
.
testOnly
.
failPBrowserCreation
.
browsingContext
"
)
PREF_LIST_ENTRY
(
"
browser
.
translation
.
bing
.
authURL
"
)
PREF_LIST_ENTRY
(
"
browser
.
translation
.
bing
.
clientIdOverride
"
)
PREF_LIST_ENTRY
(
"
browser
.
translation
.
bing
.
translateArrayURL
"
)
PREF_LIST_ENTRY
(
"
browser
.
translation
.
bing
.
apiKeyOverride
"
)
PREF_LIST_ENTRY
(
"
browser
.
translation
.
yandex
.
apiKeyOverride
"
)
PREF_LIST_ENTRY
(
"
browser
.
translation
.
yandex
.
translateURLOverride
"
)
PREF_LIST_ENTRY
(
"
browser
.
uitour
.
testingOrigins
"
)
PREF_LIST_ENTRY
(
"
browser
.
urlbar
.
loglevel
"
)
PREF_LIST_ENTRY
(
"
browser
.
urlbar
.
opencompanionsearch
.
enabled
"
)
PREF_LIST_ENTRY
(
"
capability
.
policy
.
policynames
"
)
PREF_LIST_ENTRY
(
"
dom
.
securecontext
.
allowlist
"
)
PREF_LIST_ENTRY
(
"
extensions
.
foobaz
"
)
PREF_LIST_ENTRY
(
"
general
.
appname
.
override
"
)
PREF_LIST_ENTRY
(
"
general
.
appversion
.
override
"
)
PREF_LIST_ENTRY
(
"
general
.
buildID
.
override
"
)
PREF_LIST_ENTRY
(
"
general
.
oscpu
.
override
"
)
PREF_LIST_ENTRY
(
"
general
.
useragent
.
override
"
)
PREF_LIST_ENTRY
(
"
general
.
platform
.
override
"
)
PREF_LIST_ENTRY
(
"
gfx
.
blacklist
.
"
)
PREF_LIST_ENTRY
(
"
font
.
system
.
whitelist
"
)
PREF_LIST_ENTRY
(
"
marionette
.
log
.
level
"
)
PREF_LIST_ENTRY
(
"
media
.
audio_loopback_dev
"
)
PREF_LIST_ENTRY
(
"
media
.
decoder
-
doctor
.
"
)
PREF_LIST_ENTRY
(
"
media
.
getusermedia
.
fake
-
camera
-
name
"
)
PREF_LIST_ENTRY
(
"
media
.
hls
.
server
.
url
"
)
PREF_LIST_ENTRY
(
"
media
.
peerconnection
.
nat_simulator
.
filtering_type
"
)
PREF_LIST_ENTRY
(
"
media
.
peerconnection
.
nat_simulator
.
mapping_type
"
)
PREF_LIST_ENTRY
(
"
media
.
peerconnection
.
nat_simulator
.
redirect_address
"
)
PREF_LIST_ENTRY
(
"
media
.
peerconnection
.
nat_simulator
.
redirect_targets
"
)
PREF_LIST_ENTRY
(
"
media
.
video_loopback_dev
"
)
PREF_LIST_ENTRY
(
"
media
.
webspeech
.
service
.
endpoint
"
)
PREF_LIST_ENTRY
(
"
network
.
gio
.
supported
-
protocols
"
)
PREF_LIST_ENTRY
(
"
pdfjs
.
"
)
PREF_LIST_ENTRY
(
"
print
.
printer_
"
)
PREF_LIST_ENTRY
(
"
print_printer
"
)
PREF_LIST_ENTRY
(
"
places
.
interactions
.
customBlocklist
"
)
PREF_LIST_ENTRY
(
"
services
.
settings
.
preview_enabled
"
)
PREF_LIST_ENTRY
(
"
spellchecker
.
dictionary
"
)
PREF_LIST_ENTRY
(
"
test
.
char
"
)
PREF_LIST_ENTRY
(
"
Test
.
IPC
.
"
)
PREF_LIST_ENTRY
(
"
exists
.
thenDoesNot
"
)
PREF_LIST_ENTRY
(
"
type
.
String
.
"
)
PREF_LIST_ENTRY
(
"
toolkit
.
mozprotocol
.
url
"
)
PREF_LIST_ENTRY
(
"
toolkit
.
telemetry
.
log
.
level
"
)
PREF_LIST_ENTRY
(
"
ui
.
"
)
}
;
#
undef
PREF_LIST_ENTRY
template
<
class
T
>
static
bool
ShouldSanitizePreference_Impl
(
const
T
&
aPref
bool
aIsDestWebContentProcess
)
;
static
bool
ShouldSanitizePreference
(
const
Pref
*
const
aPref
bool
aIsDestWebContentProcess
)
{
return
ShouldSanitizePreference_Impl
(
*
aPref
aIsDestWebContentProcess
)
;
}
static
bool
ShouldSanitizePreference
(
const
PrefWrapper
&
aPref
bool
aIsDestWebContentProcess
)
{
return
ShouldSanitizePreference_Impl
(
aPref
aIsDestWebContentProcess
)
;
}
template
<
class
T
>
static
bool
ShouldSanitizePreference_Impl
(
const
T
&
aPref
bool
aIsDestWebContentProcess
)
{
if
(
XRE_IsParentProcess
(
)
)
{
const
char
*
prefName
=
aPref
.
Name
(
)
;
if
(
strncmp
(
prefName
"
"
3
)
=
=
0
)
{
return
false
;
}
for
(
const
auto
&
entry
:
sParentOnlyPrefBranchList
)
{
if
(
strncmp
(
entry
.
mPrefBranch
prefName
entry
.
mLen
)
=
=
0
)
{
auto
p
=
prefName
;
if
(
strncmp
(
"
services
.
settings
.
clock_skew_seconds
"
p
36
)
=
=
0
|
|
strncmp
(
"
services
.
settings
.
last_update_seconds
"
p
37
)
=
=
0
|
|
strncmp
(
"
services
.
settings
.
server
"
p
24
)
=
=
0
)
{
return
false
;
}
else
{
return
true
;
}
}
}
if
(
!
aIsDestWebContentProcess
)
{
return
false
;
}
if
(
aPref
.
Type
(
)
=
=
PrefType
:
:
String
&
&
!
aPref
.
HasDefaultValue
(
)
)
{
for
(
const
auto
&
entry
:
sDynamicPrefOverrideList
)
{
if
(
strncmp
(
entry
.
mPrefBranch
prefName
entry
.
mLen
)
=
=
0
)
{
return
false
;
}
}
return
true
;
}
return
false
;
}
return
aPref
.
IsSanitized
(
)
;
}
namespace
mozilla
{
bool
ShouldSanitizePreference
(
const
char
*
aPrefName
bool
aIsDestWebContentProcess
)
{
if
(
!
aIsDestWebContentProcess
)
{
return
false
;
}
if
(
strncmp
(
aPrefName
"
"
3
)
=
=
0
)
{
return
false
;
}
if
(
Maybe
<
PrefWrapper
>
pref
=
pref_Lookup
(
aPrefName
)
)
{
if
(
pref
.
isNothing
(
)
)
{
return
true
;
}
return
ShouldSanitizePreference
(
pref
.
value
(
)
aIsDestWebContentProcess
)
;
}
return
true
;
}
Atomic
<
bool
Relaxed
>
sOmitBlocklistedPrefValues
(
false
)
;
Atomic
<
bool
Relaxed
>
sCrashOnBlocklistedPref
(
false
)
;
void
OnFissionBlocklistPrefChange
(
const
char
*
aPref
void
*
aData
)
{
if
(
strcmp
(
aPref
kFissionEnforceBlockList
)
=
=
0
)
{
sCrashOnBlocklistedPref
=
StaticPrefs
:
:
fission_enforceBlocklistedPrefsInSubprocesses
(
)
;
}
else
if
(
strcmp
(
aPref
kFissionOmitBlockListValues
)
=
=
0
)
{
sOmitBlocklistedPrefValues
=
StaticPrefs
:
:
fission_omitBlocklistedPrefsInSubprocesses
(
)
;
}
else
{
MOZ_CRASH
(
"
Unknown
pref
passed
to
callback
"
)
;
}
}
}
#
include
"
init
/
StaticPrefsCGetters
.
cpp
"
