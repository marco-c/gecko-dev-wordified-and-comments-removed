#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
PContent
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsCategoryManagerUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsISafeOutputStream
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIStringEnumerator
.
h
"
#
include
"
nsIZipReader
.
h
"
#
include
"
nsPrefBranch
.
h
"
#
include
"
nsXPIDLString
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsXPCOMCID
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsQuickSort
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
prefapi
.
h
"
#
include
"
prefread
.
h
"
#
include
"
prefapi_private_data
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
nsZipArchive
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
GeckoProfiler
.
h
"
using
namespace
mozilla
;
#
ifdef
DEBUG
#
define
ENSURE_MAIN_PROCESS
(
message
pref
)
do
{
\
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
\
nsPrintfCString
msg
(
"
ENSURE_MAIN_PROCESS
failed
.
%
s
%
s
"
message
pref
)
;
\
NS_WARNING
(
msg
.
get
(
)
)
;
\
return
NS_ERROR_NOT_AVAILABLE
;
\
}
\
}
while
(
0
)
;
class
WatchinPrefRAII
{
public
:
WatchinPrefRAII
(
)
{
pref_SetWatchingPref
(
true
)
;
}
~
WatchinPrefRAII
(
)
{
pref_SetWatchingPref
(
false
)
;
}
}
;
#
define
WATCHING_PREF_RAII
(
)
WatchinPrefRAII
watchingPrefRAII
#
else
#
define
ENSURE_MAIN_PROCESS
(
message
pref
)
\
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
\
return
NS_ERROR_NOT_AVAILABLE
;
\
}
#
define
WATCHING_PREF_RAII
(
)
#
endif
class
PrefCallback
;
namespace
mozilla
{
#
define
INITIAL_PREF_FILES
10
static
NS_DEFINE_CID
(
kZipReaderCID
NS_ZIPREADER_CID
)
;
void
Preferences
:
:
DirtyCallback
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
if
(
!
gHashTable
|
|
!
sPreferences
)
{
return
;
}
if
(
sPreferences
-
>
mProfileShutdown
)
{
NS_WARNING
(
"
Setting
user
pref
after
profile
shutdown
.
"
)
;
return
;
}
if
(
!
sPreferences
-
>
mDirty
)
{
sPreferences
-
>
mDirty
=
true
;
if
(
sPreferences
-
>
mCurrentFile
&
&
sPreferences
-
>
AllowOffMainThreadSave
(
)
&
&
!
sPreferences
-
>
mSavePending
)
{
sPreferences
-
>
mSavePending
=
true
;
static
const
int
PREF_DELAY_MS
=
500
;
NS_DelayedDispatchToCurrentThread
(
mozilla
:
:
NewRunnableMethod
(
"
Preferences
:
:
SavePrefFileAsynchronous
"
sPreferences
&
Preferences
:
:
SavePrefFileAsynchronous
)
PREF_DELAY_MS
)
;
}
}
}
static
nsresult
openPrefFile
(
nsIFile
*
aFile
)
;
static
nsresult
pref_InitInitialObjects
(
void
)
;
static
nsresult
pref_LoadPrefsInDirList
(
const
char
*
listId
)
;
static
nsresult
ReadExtensionPrefs
(
nsIFile
*
aFile
)
;
static
const
char
kTelemetryPref
[
]
=
"
toolkit
.
telemetry
.
enabled
"
;
static
const
char
kOldTelemetryPref
[
]
=
"
toolkit
.
telemetry
.
enabledPreRelease
"
;
static
const
char
kChannelPref
[
]
=
"
app
.
update
.
channel
"
;
static
const
char
kPrefFileHeader
[
]
=
"
#
Mozilla
User
Preferences
"
NS_LINEBREAK
NS_LINEBREAK
"
/
*
Do
not
edit
this
file
.
"
NS_LINEBREAK
"
*
"
NS_LINEBREAK
"
*
If
you
make
changes
to
this
file
while
the
application
is
running
"
NS_LINEBREAK
"
*
the
changes
will
be
overwritten
when
the
application
exits
.
"
NS_LINEBREAK
"
*
"
NS_LINEBREAK
"
*
To
make
a
manual
change
to
preferences
you
can
visit
the
URL
about
:
config
"
NS_LINEBREAK
"
*
/
"
NS_LINEBREAK
NS_LINEBREAK
;
Preferences
*
Preferences
:
:
sPreferences
=
nullptr
;
nsIPrefBranch
*
Preferences
:
:
sRootBranch
=
nullptr
;
nsIPrefBranch
*
Preferences
:
:
sDefaultRootBranch
=
nullptr
;
bool
Preferences
:
:
sShutdown
=
false
;
static
int32_t
sAllowOMTPrefWrite
=
-
1
;
class
ValueObserverHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
ValueObserverHashKey
*
KeyType
;
typedef
const
ValueObserverHashKey
*
KeyTypePointer
;
static
const
ValueObserverHashKey
*
KeyToPointer
(
ValueObserverHashKey
*
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
const
ValueObserverHashKey
*
aKey
)
{
PLDHashNumber
hash
=
HashString
(
aKey
-
>
mPrefName
)
;
hash
=
AddToHash
(
hash
aKey
-
>
mMatchKind
)
;
return
AddToHash
(
hash
aKey
-
>
mCallback
)
;
}
ValueObserverHashKey
(
const
char
*
aPref
PrefChangedFunc
aCallback
Preferences
:
:
MatchKind
aMatchKind
)
:
mPrefName
(
aPref
)
mCallback
(
aCallback
)
mMatchKind
(
aMatchKind
)
{
}
explicit
ValueObserverHashKey
(
const
ValueObserverHashKey
*
aOther
)
:
mPrefName
(
aOther
-
>
mPrefName
)
mCallback
(
aOther
-
>
mCallback
)
mMatchKind
(
aOther
-
>
mMatchKind
)
{
}
bool
KeyEquals
(
const
ValueObserverHashKey
*
aOther
)
const
{
return
mCallback
=
=
aOther
-
>
mCallback
&
&
mPrefName
=
=
aOther
-
>
mPrefName
&
&
mMatchKind
=
=
aOther
-
>
mMatchKind
;
}
ValueObserverHashKey
*
GetKey
(
)
const
{
return
const_cast
<
ValueObserverHashKey
*
>
(
this
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
nsCString
mPrefName
;
PrefChangedFunc
mCallback
;
Preferences
:
:
MatchKind
mMatchKind
;
}
;
class
ValueObserver
final
:
public
nsIObserver
public
ValueObserverHashKey
{
~
ValueObserver
(
)
{
Preferences
:
:
RemoveObserver
(
this
mPrefName
.
get
(
)
)
;
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
ValueObserver
(
const
char
*
aPref
PrefChangedFunc
aCallback
Preferences
:
:
MatchKind
aMatchKind
)
:
ValueObserverHashKey
(
aPref
aCallback
aMatchKind
)
{
}
void
AppendClosure
(
void
*
aClosure
)
{
mClosures
.
AppendElement
(
aClosure
)
;
}
void
RemoveClosure
(
void
*
aClosure
)
{
mClosures
.
RemoveElement
(
aClosure
)
;
}
bool
HasNoClosures
(
)
{
return
mClosures
.
Length
(
)
=
=
0
;
}
nsTArray
<
void
*
>
mClosures
;
}
;
NS_IMPL_ISUPPORTS
(
ValueObserver
nsIObserver
)
NS_IMETHODIMP
ValueObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
NS_ASSERTION
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
"
invalid
topic
"
)
;
NS_ConvertUTF16toUTF8
data
(
aData
)
;
if
(
mMatchKind
=
=
Preferences
:
:
ExactMatch
&
&
!
mPrefName
.
EqualsASCII
(
data
.
get
(
)
)
)
{
return
NS_OK
;
}
for
(
uint32_t
i
=
0
;
i
<
mClosures
.
Length
(
)
;
i
+
+
)
{
mCallback
(
data
.
get
(
)
mClosures
.
ElementAt
(
i
)
)
;
}
return
NS_OK
;
}
class
PreferencesWriter
final
{
public
:
PreferencesWriter
(
)
{
}
static
nsresult
Write
(
nsIFile
*
aFile
PrefSaveData
&
aPrefs
)
{
nsCOMPtr
<
nsIOutputStream
>
outStreamSink
;
nsCOMPtr
<
nsIOutputStream
>
outStream
;
uint32_t
writeAmount
;
nsresult
rv
;
rv
=
NS_NewSafeLocalFileOutputStream
(
getter_AddRefs
(
outStreamSink
)
aFile
-
1
0600
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
NS_NewBufferedOutputStream
(
getter_AddRefs
(
outStream
)
outStreamSink
4096
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
struct
CharComparator
{
bool
LessThan
(
const
mozilla
:
:
UniqueFreePtr
<
char
>
&
a
const
mozilla
:
:
UniqueFreePtr
<
char
>
&
b
)
const
{
return
strcmp
(
a
.
get
(
)
b
.
get
(
)
)
<
0
;
}
bool
Equals
(
const
mozilla
:
:
UniqueFreePtr
<
char
>
&
a
const
mozilla
:
:
UniqueFreePtr
<
char
>
&
b
)
const
{
return
strcmp
(
a
.
get
(
)
b
.
get
(
)
)
=
=
0
;
}
}
;
aPrefs
.
Sort
(
CharComparator
(
)
)
;
outStream
-
>
Write
(
kPrefFileHeader
sizeof
(
kPrefFileHeader
)
-
1
&
writeAmount
)
;
for
(
auto
&
prefptr
:
aPrefs
)
{
char
*
pref
=
prefptr
.
get
(
)
;
MOZ_ASSERT
(
pref
)
;
outStream
-
>
Write
(
pref
strlen
(
pref
)
&
writeAmount
)
;
outStream
-
>
Write
(
NS_LINEBREAK
NS_LINEBREAK_LEN
&
writeAmount
)
;
}
nsCOMPtr
<
nsISafeOutputStream
>
safeStream
=
do_QueryInterface
(
outStream
)
;
NS_ASSERTION
(
safeStream
"
expected
a
safe
output
stream
!
"
)
;
if
(
safeStream
)
{
rv
=
safeStream
-
>
Finish
(
)
;
}
#
ifdef
DEBUG
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
save
prefs
file
!
possible
data
loss
"
)
;
}
#
endif
return
rv
;
}
static
void
Flush
(
)
{
if
(
!
sPendingWriteData
.
compareExchange
(
nullptr
nullptr
)
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
target
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
Preferences_dummy
"
[
]
{
}
)
nsIEventTarget
:
:
DISPATCH_SYNC
)
;
}
}
}
static
Atomic
<
PrefSaveData
*
>
sPendingWriteData
;
}
;
Atomic
<
PrefSaveData
*
>
PreferencesWriter
:
:
sPendingWriteData
(
nullptr
)
;
class
PWRunnable
:
public
Runnable
{
public
:
explicit
PWRunnable
(
nsIFile
*
aFile
)
:
Runnable
(
"
PWRunnable
"
)
mFile
(
aFile
)
{
}
NS_IMETHOD
Run
(
)
override
{
mozilla
:
:
UniquePtr
<
PrefSaveData
>
prefs
(
PreferencesWriter
:
:
sPendingWriteData
.
exchange
(
nullptr
)
)
;
nsresult
rv
=
NS_OK
;
if
(
prefs
)
{
rv
=
PreferencesWriter
:
:
Write
(
mFile
*
prefs
)
;
nsresult
rvCopy
=
rv
;
nsCOMPtr
<
nsIFile
>
fileCopy
(
mFile
)
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
NS_NewRunnableFunction
(
"
Preferences
:
:
WriterRunnable
"
[
fileCopy
rvCopy
]
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
rvCopy
)
)
{
Preferences
:
:
DirtyCallback
(
)
;
}
}
)
)
;
}
return
rv
;
}
protected
:
nsCOMPtr
<
nsIFile
>
mFile
;
}
;
struct
CacheData
{
void
*
cacheLocation
;
union
{
bool
defaultValueBool
;
int32_t
defaultValueInt
;
uint32_t
defaultValueUint
;
float
defaultValueFloat
;
}
;
}
;
static
nsTArray
<
nsAutoPtr
<
CacheData
>
>
*
gCacheData
=
nullptr
;
static
nsRefPtrHashtable
<
ValueObserverHashKey
ValueObserver
>
*
gObserverTable
=
nullptr
;
#
ifdef
DEBUG
static
bool
HaveExistingCacheFor
(
void
*
aPtr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
gCacheData
)
{
for
(
size_t
i
=
0
count
=
gCacheData
-
>
Length
(
)
;
i
<
count
;
+
+
i
)
{
if
(
(
*
gCacheData
)
[
i
]
-
>
cacheLocation
=
=
aPtr
)
{
return
true
;
}
}
}
return
false
;
}
static
void
AssertNotAlreadyCached
(
const
char
*
aPrefType
const
char
*
aPref
void
*
aPtr
)
{
if
(
HaveExistingCacheFor
(
aPtr
)
)
{
fprintf_stderr
(
stderr
"
Attempt
to
add
a
%
s
pref
cache
for
preference
'
%
s
'
at
address
'
%
p
'
"
"
was
made
.
However
a
pref
was
already
cached
at
this
address
.
\
n
"
aPrefType
aPref
aPtr
)
;
MOZ_ASSERT
(
false
"
Should
not
have
an
existing
pref
cache
for
this
address
"
)
;
}
}
#
endif
static
void
ReportToConsole
(
const
char
*
aMessage
int
aLine
bool
aError
)
{
nsPrintfCString
message
(
"
*
*
Preference
parsing
%
s
(
line
%
d
)
=
%
s
*
*
\
n
"
(
aError
?
"
error
"
:
"
warning
"
)
aLine
aMessage
)
;
nsPrefBranch
:
:
ReportToConsole
(
NS_ConvertUTF8toUTF16
(
message
.
get
(
)
)
)
;
}
int64_t
Preferences
:
:
SizeOfIncludingThisAndOtherStuff
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
0
)
;
size_t
n
=
aMallocSizeOf
(
sPreferences
)
;
if
(
gHashTable
)
{
n
+
=
gHashTable
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
gCacheData
)
{
n
+
=
gCacheData
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
;
for
(
uint32_t
i
=
0
count
=
gCacheData
-
>
Length
(
)
;
i
<
count
;
+
+
i
)
{
n
+
=
aMallocSizeOf
(
(
*
gCacheData
)
[
i
]
)
;
}
}
if
(
gObserverTable
)
{
n
+
=
gObserverTable
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
gObserverTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
iter
.
Key
(
)
-
>
mPrefName
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
n
+
=
iter
.
Data
(
)
-
>
mClosures
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
if
(
sRootBranch
)
{
n
+
=
reinterpret_cast
<
nsPrefBranch
*
>
(
sRootBranch
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
sDefaultRootBranch
)
{
n
+
=
reinterpret_cast
<
nsPrefBranch
*
>
(
sDefaultRootBranch
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
n
+
=
pref_SizeOfPrivateData
(
aMallocSizeOf
)
;
return
n
;
}
class
PreferenceServiceReporter
final
:
public
nsIMemoryReporter
{
~
PreferenceServiceReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
protected
:
static
const
uint32_t
kSuspectReferentCount
=
1000
;
}
;
NS_IMPL_ISUPPORTS
(
PreferenceServiceReporter
nsIMemoryReporter
)
MOZ_DEFINE_MALLOC_SIZE_OF
(
PreferenceServiceMallocSizeOf
)
NS_IMETHODIMP
PreferenceServiceReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
preferences
"
KIND_HEAP
UNITS_BYTES
Preferences
:
:
SizeOfIncludingThisAndOtherStuff
(
PreferenceServiceMallocSizeOf
)
"
Memory
used
by
the
preferences
system
.
"
)
;
nsPrefBranch
*
rootBranch
=
static_cast
<
nsPrefBranch
*
>
(
Preferences
:
:
GetRootBranch
(
)
)
;
if
(
!
rootBranch
)
{
return
NS_OK
;
}
size_t
numStrong
=
0
;
size_t
numWeakAlive
=
0
;
size_t
numWeakDead
=
0
;
nsTArray
<
nsCString
>
suspectPreferences
;
nsDataHashtable
<
nsCStringHashKey
uint32_t
>
prefCounter
;
for
(
auto
iter
=
rootBranch
-
>
mObservers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
PrefCallback
>
&
callback
=
iter
.
Data
(
)
;
nsPrefBranch
*
prefBranch
=
callback
-
>
GetPrefBranch
(
)
;
const
auto
&
pref
=
prefBranch
-
>
getPrefName
(
callback
-
>
GetDomain
(
)
.
get
(
)
)
;
if
(
callback
-
>
IsWeak
(
)
)
{
nsCOMPtr
<
nsIObserver
>
callbackRef
=
do_QueryReferent
(
callback
-
>
mWeakRef
)
;
if
(
callbackRef
)
{
numWeakAlive
+
+
;
}
else
{
numWeakDead
+
+
;
}
}
else
{
numStrong
+
+
;
}
nsDependentCString
prefString
(
pref
.
get
(
)
)
;
uint32_t
oldCount
=
0
;
prefCounter
.
Get
(
prefString
&
oldCount
)
;
uint32_t
currentCount
=
oldCount
+
1
;
prefCounter
.
Put
(
prefString
currentCount
)
;
if
(
currentCount
=
=
kSuspectReferentCount
)
{
suspectPreferences
.
AppendElement
(
prefString
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
suspectPreferences
.
Length
(
)
;
i
+
+
)
{
nsCString
&
suspect
=
suspectPreferences
[
i
]
;
uint32_t
totalReferentCount
=
0
;
prefCounter
.
Get
(
suspect
&
totalReferentCount
)
;
nsPrintfCString
suspectPath
(
"
preference
-
service
-
suspect
/
"
"
referent
(
pref
=
%
s
)
"
suspect
.
get
(
)
)
;
aHandleReport
-
>
Callback
(
EmptyCString
(
)
suspectPath
KIND_OTHER
UNITS_COUNT
totalReferentCount
NS_LITERAL_CSTRING
(
"
A
preference
with
a
suspiciously
large
number
referents
(
symptom
of
a
"
"
leak
)
.
"
)
aData
)
;
}
MOZ_COLLECT_REPORT
(
"
preference
-
service
/
referent
/
strong
"
KIND_OTHER
UNITS_COUNT
numStrong
"
The
number
of
strong
referents
held
by
the
preference
service
.
"
)
;
MOZ_COLLECT_REPORT
(
"
preference
-
service
/
referent
/
weak
/
alive
"
KIND_OTHER
UNITS_COUNT
numWeakAlive
"
The
number
of
weak
referents
held
by
the
preference
service
that
are
"
"
still
alive
.
"
)
;
MOZ_COLLECT_REPORT
(
"
preference
-
service
/
referent
/
weak
/
dead
"
KIND_OTHER
UNITS_COUNT
numWeakDead
"
The
number
of
weak
referents
held
by
the
preference
service
that
are
"
"
dead
.
"
)
;
return
NS_OK
;
}
namespace
{
class
AddPreferencesMemoryReporterRunnable
:
public
Runnable
{
public
:
AddPreferencesMemoryReporterRunnable
(
)
:
Runnable
(
"
AddPreferencesMemoryReporterRunnable
"
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
RegisterStrongMemoryReporter
(
new
PreferenceServiceReporter
(
)
)
;
}
}
;
}
Preferences
*
Preferences
:
:
GetInstanceForService
(
)
{
if
(
sPreferences
)
{
NS_ADDREF
(
sPreferences
)
;
return
sPreferences
;
}
NS_ENSURE_TRUE
(
!
sShutdown
nullptr
)
;
sRootBranch
=
new
nsPrefBranch
(
"
"
false
)
;
NS_ADDREF
(
sRootBranch
)
;
sDefaultRootBranch
=
new
nsPrefBranch
(
"
"
true
)
;
NS_ADDREF
(
sDefaultRootBranch
)
;
sPreferences
=
new
Preferences
(
)
;
NS_ADDREF
(
sPreferences
)
;
if
(
NS_FAILED
(
sPreferences
-
>
Init
(
)
)
)
{
NS_RELEASE
(
sPreferences
)
;
return
nullptr
;
}
gCacheData
=
new
nsTArray
<
nsAutoPtr
<
CacheData
>
>
(
)
;
gObserverTable
=
new
nsRefPtrHashtable
<
ValueObserverHashKey
ValueObserver
>
(
)
;
RefPtr
<
AddPreferencesMemoryReporterRunnable
>
runnable
=
new
AddPreferencesMemoryReporterRunnable
(
)
;
NS_DispatchToMainThread
(
runnable
)
;
NS_ADDREF
(
sPreferences
)
;
return
sPreferences
;
}
bool
Preferences
:
:
IsServiceAvailable
(
)
{
return
!
!
sPreferences
;
}
bool
Preferences
:
:
InitStaticMembers
(
)
{
#
ifndef
MOZ_B2G
MOZ_ASSERT
(
NS_IsMainThread
(
)
|
|
mozilla
:
:
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
#
endif
if
(
!
sShutdown
&
&
!
sPreferences
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIPrefService
>
prefService
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
}
return
sPreferences
!
=
nullptr
;
}
void
Preferences
:
:
Shutdown
(
)
{
if
(
!
sShutdown
)
{
sShutdown
=
true
;
if
(
sPreferences
)
{
sPreferences
-
>
Release
(
)
;
}
}
}
Preferences
:
:
Preferences
(
)
{
}
Preferences
:
:
~
Preferences
(
)
{
NS_ASSERTION
(
sPreferences
=
=
this
"
Isn
'
t
this
the
singleton
instance
?
"
)
;
delete
gObserverTable
;
gObserverTable
=
nullptr
;
delete
gCacheData
;
gCacheData
=
nullptr
;
NS_RELEASE
(
sRootBranch
)
;
NS_RELEASE
(
sDefaultRootBranch
)
;
sPreferences
=
nullptr
;
PREF_Cleanup
(
)
;
}
NS_IMPL_ADDREF
(
Preferences
)
NS_IMPL_RELEASE
(
Preferences
)
NS_INTERFACE_MAP_BEGIN
(
Preferences
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIPrefService
)
NS_INTERFACE_MAP_ENTRY
(
nsIPrefService
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIPrefBranch
)
NS_INTERFACE_MAP_ENTRY
(
nsIPrefBranch2
)
NS_INTERFACE_MAP_ENTRY
(
nsIPrefBranchInternal
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END
InfallibleTArray
<
Preferences
:
:
PrefSetting
>
*
gInitPrefs
;
void
Preferences
:
:
SetInitPreferences
(
nsTArray
<
PrefSetting
>
*
aPrefs
)
{
gInitPrefs
=
new
InfallibleTArray
<
PrefSetting
>
(
mozilla
:
:
Move
(
*
aPrefs
)
)
;
}
nsresult
Preferences
:
:
Init
(
)
{
nsresult
rv
;
PREF_SetDirtyCallback
(
&
DirtyCallback
)
;
PREF_Init
(
)
;
rv
=
pref_InitInitialObjects
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
XRE_IsContentProcess
(
)
)
{
MOZ_ASSERT
(
gInitPrefs
)
;
for
(
unsigned
int
i
=
0
;
i
<
gInitPrefs
-
>
Length
(
)
;
i
+
+
)
{
Preferences
:
:
SetPreference
(
gInitPrefs
-
>
ElementAt
(
i
)
)
;
}
delete
gInitPrefs
;
gInitPrefs
=
nullptr
;
return
NS_OK
;
}
nsXPIDLCString
lockFileName
;
rv
=
PREF_CopyCharPref
(
"
general
.
config
.
filename
"
getter_Copies
(
lockFileName
)
false
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
NS_CreateServicesFromCategory
(
"
pref
-
config
-
startup
"
static_cast
<
nsISupports
*
>
(
static_cast
<
void
*
>
(
this
)
)
"
pref
-
config
-
startup
"
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
return
NS_ERROR_FAILURE
;
observerService
-
>
AddObserver
(
this
"
profile
-
before
-
change
-
telemetry
"
true
)
;
rv
=
observerService
-
>
AddObserver
(
this
"
profile
-
before
-
change
"
true
)
;
observerService
-
>
AddObserver
(
this
"
load
-
extension
-
defaults
"
true
)
;
observerService
-
>
AddObserver
(
this
"
suspend_process_notification
"
true
)
;
return
(
rv
)
;
}
void
Preferences
:
:
InitializeUserPrefs
(
)
{
MOZ_ASSERT
(
!
sPreferences
-
>
mCurrentFile
"
Should
only
initialize
prefs
once
"
)
;
sPreferences
-
>
ResetUserPrefs
(
)
;
nsCOMPtr
<
nsIFile
>
prefsFile
=
sPreferences
-
>
ReadSavedPrefs
(
)
;
sPreferences
-
>
ReadUserOverridePrefs
(
)
;
sPreferences
-
>
mDirty
=
false
;
sPreferences
-
>
mCurrentFile
=
prefsFile
.
forget
(
)
;
if
(
!
Preferences
:
:
GetBool
(
kOldTelemetryPref
true
)
)
{
Preferences
:
:
SetBool
(
kTelemetryPref
false
)
;
Preferences
:
:
ClearUser
(
kOldTelemetryPref
)
;
}
sPreferences
-
>
NotifyServiceObservers
(
NS_PREFSERVICE_READ_TOPIC_ID
)
;
}
NS_IMETHODIMP
Preferences
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
NS_OK
;
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
)
{
if
(
AllowOffMainThreadSave
(
)
)
{
SavePrefFile
(
nullptr
)
;
}
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
profile
-
before
-
change
-
telemetry
"
)
)
{
SavePrefFileBlocking
(
)
;
MOZ_ASSERT
(
!
mDirty
"
Preferences
should
not
be
dirty
"
)
;
mProfileShutdown
=
true
;
}
else
if
(
!
strcmp
(
aTopic
"
load
-
extension
-
defaults
"
)
)
{
pref_LoadPrefsInDirList
(
NS_EXT_PREFS_DEFAULTS_DIR_LIST
)
;
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
reload
-
default
-
prefs
"
)
)
{
pref_InitInitialObjects
(
)
;
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
suspend_process_notification
"
)
)
{
rv
=
SavePrefFileBlocking
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
Preferences
:
:
ReadUserPrefsFromFile
(
nsIFile
*
aFile
)
{
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
NS_ERROR
(
"
must
load
prefs
from
parent
process
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
aFile
)
{
NS_ERROR
(
"
ReadUserPrefsFromFile
requires
a
parameter
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
return
openPrefFile
(
aFile
)
;
}
NS_IMETHODIMP
Preferences
:
:
ResetPrefs
(
)
{
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
NS_ERROR
(
"
must
reset
prefs
from
parent
process
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
NotifyServiceObservers
(
NS_PREFSERVICE_RESET_TOPIC_ID
)
;
PREF_CleanupPrefs
(
)
;
PREF_Init
(
)
;
return
pref_InitInitialObjects
(
)
;
}
NS_IMETHODIMP
Preferences
:
:
ResetUserPrefs
(
)
{
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
NS_ERROR
(
"
must
reset
user
prefs
from
parent
process
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
PREF_ClearAllUserPrefs
(
)
;
return
NS_OK
;
}
bool
Preferences
:
:
AllowOffMainThreadSave
(
)
{
if
(
sAllowOMTPrefWrite
<
0
)
{
bool
value
=
false
;
Preferences
:
:
GetBool
(
"
preferences
.
allow
.
omt
-
write
"
&
value
)
;
sAllowOMTPrefWrite
=
value
?
1
:
0
;
}
return
!
!
sAllowOMTPrefWrite
;
}
nsresult
Preferences
:
:
SavePrefFileBlocking
(
)
{
if
(
mDirty
)
{
return
SavePrefFileInternal
(
nullptr
SaveMethod
:
:
Blocking
)
;
}
if
(
AllowOffMainThreadSave
(
)
)
{
PreferencesWriter
:
:
Flush
(
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
SavePrefFileAsynchronous
(
)
{
return
SavePrefFileInternal
(
nullptr
SaveMethod
:
:
Asynchronous
)
;
}
NS_IMETHODIMP
Preferences
:
:
SavePrefFile
(
nsIFile
*
aFile
)
{
return
SavePrefFileInternal
(
aFile
SaveMethod
:
:
Asynchronous
)
;
}
static
nsresult
ReadExtensionPrefs
(
nsIFile
*
aFile
)
{
nsresult
rv
;
nsCOMPtr
<
nsIZipReader
>
reader
=
do_CreateInstance
(
kZipReaderCID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
reader
-
>
Open
(
aFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIUTF8StringEnumerator
>
files
;
rv
=
reader
-
>
FindEntries
(
nsDependentCString
(
"
defaults
/
preferences
/
*
.
(
J
|
j
)
(
S
|
s
)
"
)
getter_AddRefs
(
files
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
char
buffer
[
4096
]
;
bool
more
;
while
(
NS_SUCCEEDED
(
rv
=
files
-
>
HasMore
(
&
more
)
)
&
&
more
)
{
nsAutoCString
entry
;
rv
=
files
-
>
GetNext
(
entry
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
reader
-
>
GetInputStream
(
entry
getter_AddRefs
(
stream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint64_t
avail
;
uint32_t
read
;
PrefParseState
ps
;
PREF_InitParseState
(
&
ps
PREF_ReaderCallback
ReportToConsole
nullptr
)
;
while
(
NS_SUCCEEDED
(
rv
=
stream
-
>
Available
(
&
avail
)
)
&
&
avail
)
{
rv
=
stream
-
>
Read
(
buffer
4096
&
read
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Pref
stream
read
failed
"
)
;
break
;
}
PREF_ParseBuf
(
&
ps
buffer
read
)
;
}
PREF_FinalizeParseState
(
&
ps
)
;
}
return
rv
;
}
void
Preferences
:
:
SetPreference
(
const
PrefSetting
&
aPref
)
{
pref_SetPref
(
aPref
)
;
}
void
Preferences
:
:
GetPreference
(
PrefSetting
*
aPref
)
{
PrefHashEntry
*
entry
=
pref_HashTableLookup
(
aPref
-
>
name
(
)
.
get
(
)
)
;
if
(
!
entry
)
return
;
if
(
pref_EntryHasAdvisablySizedValues
(
entry
)
)
{
pref_GetPrefFromEntry
(
entry
aPref
)
;
}
}
void
Preferences
:
:
GetPreferences
(
InfallibleTArray
<
PrefSetting
>
*
aPrefs
)
{
aPrefs
-
>
SetCapacity
(
gHashTable
-
>
Capacity
(
)
)
;
for
(
auto
iter
=
gHashTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
PrefHashEntry
*
>
(
iter
.
Get
(
)
)
;
if
(
!
pref_EntryHasAdvisablySizedValues
(
entry
)
)
{
continue
;
}
dom
:
:
PrefSetting
*
pref
=
aPrefs
-
>
AppendElement
(
)
;
pref_GetPrefFromEntry
(
entry
pref
)
;
}
}
#
ifdef
DEBUG
void
Preferences
:
:
SetInitPhase
(
pref_initPhase
phase
)
{
pref_SetInitPhase
(
phase
)
;
}
pref_initPhase
Preferences
:
:
InitPhase
(
)
{
return
pref_GetInitPhase
(
)
;
}
#
endif
NS_IMETHODIMP
Preferences
:
:
GetBranch
(
const
char
*
aPrefRoot
nsIPrefBranch
*
*
_retval
)
{
nsresult
rv
;
if
(
(
nullptr
!
=
aPrefRoot
)
&
&
(
*
aPrefRoot
!
=
'
\
0
'
)
)
{
RefPtr
<
nsPrefBranch
>
prefBranch
=
new
nsPrefBranch
(
aPrefRoot
false
)
;
prefBranch
.
forget
(
_retval
)
;
rv
=
NS_OK
;
}
else
{
nsCOMPtr
<
nsIPrefBranch
>
root
(
sRootBranch
)
;
root
.
forget
(
_retval
)
;
rv
=
NS_OK
;
}
return
rv
;
}
NS_IMETHODIMP
Preferences
:
:
GetDefaultBranch
(
const
char
*
aPrefRoot
nsIPrefBranch
*
*
_retval
)
{
if
(
!
aPrefRoot
|
|
!
aPrefRoot
[
0
]
)
{
nsCOMPtr
<
nsIPrefBranch
>
root
(
sDefaultRootBranch
)
;
root
.
forget
(
_retval
)
;
return
NS_OK
;
}
RefPtr
<
nsPrefBranch
>
prefBranch
=
new
nsPrefBranch
(
aPrefRoot
true
)
;
if
(
!
prefBranch
)
return
NS_ERROR_OUT_OF_MEMORY
;
prefBranch
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Preferences
:
:
GetDirty
(
bool
*
_retval
)
{
*
_retval
=
mDirty
;
return
NS_OK
;
}
nsresult
Preferences
:
:
NotifyServiceObservers
(
const
char
*
aTopic
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
return
NS_ERROR_FAILURE
;
nsISupports
*
subject
=
(
nsISupports
*
)
(
(
nsIPrefService
*
)
this
)
;
observerService
-
>
NotifyObservers
(
subject
aTopic
nullptr
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIFile
>
Preferences
:
:
ReadSavedPrefs
(
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_PREFS_50_FILE
getter_AddRefs
(
file
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
rv
=
openPrefFile
(
file
)
;
if
(
rv
=
=
NS_ERROR_FILE_NOT_FOUND
)
{
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
PREFERENCES_CREATED_NEW_USER_PREFS_FILE
true
)
;
rv
=
NS_OK
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
PREFERENCES_PREFS_FILE_WAS_INVALID
true
)
;
MakeBackupPrefFile
(
file
)
;
}
return
file
.
forget
(
)
;
}
void
Preferences
:
:
ReadUserOverridePrefs
(
)
{
nsCOMPtr
<
nsIFile
>
aFile
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_PREFS_50_DIR
getter_AddRefs
(
aFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
aFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
user
.
js
"
)
)
;
rv
=
openPrefFile
(
aFile
)
;
if
(
rv
!
=
NS_ERROR_FILE_NOT_FOUND
)
{
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
PREFERENCES_READ_USER_JS
true
)
;
}
}
nsresult
Preferences
:
:
MakeBackupPrefFile
(
nsIFile
*
aFile
)
{
nsAutoString
newFilename
;
nsresult
rv
=
aFile
-
>
GetLeafName
(
newFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
newFilename
.
Insert
(
NS_LITERAL_STRING
(
"
Invalid
"
)
0
)
;
nsCOMPtr
<
nsIFile
>
newFile
;
rv
=
aFile
-
>
GetParent
(
getter_AddRefs
(
newFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
newFile
-
>
Append
(
newFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
exists
=
false
;
newFile
-
>
Exists
(
&
exists
)
;
if
(
exists
)
{
rv
=
newFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
aFile
-
>
CopyTo
(
nullptr
newFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
nsresult
Preferences
:
:
SavePrefFileInternal
(
nsIFile
*
aFile
SaveMethod
aSaveMethod
)
{
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
NS_ERROR
(
"
must
save
pref
file
from
parent
process
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
nullptr
=
=
aFile
)
{
mSavePending
=
false
;
if
(
!
AllowOffMainThreadSave
(
)
)
{
aSaveMethod
=
SaveMethod
:
:
Blocking
;
}
if
(
!
mDirty
)
{
return
NS_OK
;
}
if
(
mProfileShutdown
)
{
NS_WARNING
(
"
Cannot
save
pref
file
after
profile
shutdown
.
"
)
;
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
nsresult
rv
=
NS_OK
;
if
(
mCurrentFile
)
{
rv
=
WritePrefFile
(
mCurrentFile
aSaveMethod
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
mDirty
=
false
;
}
return
rv
;
}
else
{
return
WritePrefFile
(
aFile
SaveMethod
:
:
Blocking
)
;
}
}
nsresult
Preferences
:
:
WritePrefFile
(
nsIFile
*
aFile
SaveMethod
aSaveMethod
)
{
if
(
!
gHashTable
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AUTO_PROFILER_LABEL
(
"
Preferences
:
:
WritePrefFile
"
OTHER
)
;
if
(
AllowOffMainThreadSave
(
)
)
{
nsresult
rv
=
NS_OK
;
mozilla
:
:
UniquePtr
<
PrefSaveData
>
prefs
=
MakeUnique
<
PrefSaveData
>
(
pref_savePrefs
(
gHashTable
)
)
;
prefs
.
reset
(
PreferencesWriter
:
:
sPendingWriteData
.
exchange
(
prefs
.
release
(
)
)
)
;
if
(
prefs
)
{
return
rv
;
}
else
{
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
async
=
aSaveMethod
=
=
SaveMethod
:
:
Asynchronous
;
rv
=
target
-
>
Dispatch
(
new
PWRunnable
(
aFile
)
async
?
nsIEventTarget
:
:
DISPATCH_NORMAL
:
nsIEventTarget
:
:
DISPATCH_SYNC
)
;
return
rv
;
}
}
MOZ_ASSERT
(
false
"
failed
to
get
the
target
thread
for
OMT
pref
write
"
)
;
}
PrefSaveData
prefsData
=
pref_savePrefs
(
gHashTable
)
;
return
PreferencesWriter
:
:
Write
(
aFile
prefsData
)
;
}
static
nsresult
openPrefFile
(
nsIFile
*
aFile
)
{
nsCOMPtr
<
nsIInputStream
>
inStr
;
nsresult
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
inStr
)
aFile
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
int64_t
fileSize64
;
rv
=
aFile
-
>
GetFileSize
(
&
fileSize64
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
NS_ENSURE_TRUE
(
fileSize64
<
=
UINT32_MAX
NS_ERROR_FILE_TOO_BIG
)
;
uint32_t
fileSize
=
(
uint32_t
)
fileSize64
;
auto
fileBuffer
=
MakeUniqueFallible
<
char
[
]
>
(
fileSize
)
;
if
(
fileBuffer
=
=
nullptr
)
return
NS_ERROR_OUT_OF_MEMORY
;
PrefParseState
ps
;
PREF_InitParseState
(
&
ps
PREF_ReaderCallback
ReportToConsole
nullptr
)
;
nsresult
rv2
=
NS_OK
;
uint32_t
offset
=
0
;
for
(
;
;
)
{
uint32_t
amtRead
=
0
;
rv
=
inStr
-
>
Read
(
fileBuffer
.
get
(
)
fileSize
&
amtRead
)
;
if
(
NS_FAILED
(
rv
)
|
|
amtRead
=
=
0
)
break
;
if
(
!
PREF_ParseBuf
(
&
ps
fileBuffer
.
get
(
)
amtRead
)
)
rv2
=
NS_ERROR_FILE_CORRUPTED
;
offset
+
=
amtRead
;
if
(
offset
=
=
fileSize
)
{
break
;
}
}
PREF_FinalizeParseState
(
&
ps
)
;
return
NS_FAILED
(
rv
)
?
rv
:
rv2
;
}
static
int
pref_CompareFileNames
(
nsIFile
*
aFile1
nsIFile
*
aFile2
void
*
)
{
nsAutoCString
filename1
filename2
;
aFile1
-
>
GetNativeLeafName
(
filename1
)
;
aFile2
-
>
GetNativeLeafName
(
filename2
)
;
return
Compare
(
filename2
filename1
)
;
}
static
nsresult
pref_LoadPrefsInDir
(
nsIFile
*
aDir
char
const
*
const
*
aSpecialFiles
uint32_t
aSpecialFilesCount
)
{
nsresult
rv
rv2
;
bool
hasMoreElements
;
nsCOMPtr
<
nsISimpleEnumerator
>
dirIterator
;
rv
=
aDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
dirIterator
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_FILE_NOT_FOUND
|
|
rv
=
=
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
)
rv
=
NS_OK
;
return
rv
;
}
rv
=
dirIterator
-
>
HasMoreElements
(
&
hasMoreElements
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMArray
<
nsIFile
>
prefFiles
(
INITIAL_PREF_FILES
)
;
nsCOMArray
<
nsIFile
>
specialFiles
(
aSpecialFilesCount
)
;
nsCOMPtr
<
nsIFile
>
prefFile
;
while
(
hasMoreElements
&
&
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
leafName
;
nsCOMPtr
<
nsISupports
>
supports
;
rv
=
dirIterator
-
>
GetNext
(
getter_AddRefs
(
supports
)
)
;
prefFile
=
do_QueryInterface
(
supports
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
prefFile
-
>
GetNativeLeafName
(
leafName
)
;
NS_ASSERTION
(
!
leafName
.
IsEmpty
(
)
"
Failure
in
default
prefs
:
directory
enumerator
returned
empty
file
?
"
)
;
if
(
StringEndsWith
(
leafName
NS_LITERAL_CSTRING
(
"
.
js
"
)
nsCaseInsensitiveCStringComparator
(
)
)
)
{
bool
shouldParse
=
true
;
for
(
uint32_t
i
=
0
;
i
<
aSpecialFilesCount
;
+
+
i
)
{
if
(
leafName
.
Equals
(
nsDependentCString
(
aSpecialFiles
[
i
]
)
)
)
{
shouldParse
=
false
;
specialFiles
.
ReplaceObjectAt
(
prefFile
i
)
;
}
}
if
(
shouldParse
)
{
prefFiles
.
AppendObject
(
prefFile
)
;
}
}
rv
=
dirIterator
-
>
HasMoreElements
(
&
hasMoreElements
)
;
}
if
(
prefFiles
.
Count
(
)
+
specialFiles
.
Count
(
)
=
=
0
)
{
NS_WARNING
(
"
No
default
pref
files
found
.
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
NS_SUCCESS_FILE_DIRECTORY_EMPTY
;
}
return
rv
;
}
prefFiles
.
Sort
(
pref_CompareFileNames
nullptr
)
;
uint32_t
arrayCount
=
prefFiles
.
Count
(
)
;
uint32_t
i
;
for
(
i
=
0
;
i
<
arrayCount
;
+
+
i
)
{
rv2
=
openPrefFile
(
prefFiles
[
i
]
)
;
if
(
NS_FAILED
(
rv2
)
)
{
NS_ERROR
(
"
Default
pref
file
not
parsed
successfully
.
"
)
;
rv
=
rv2
;
}
}
arrayCount
=
specialFiles
.
Count
(
)
;
for
(
i
=
0
;
i
<
arrayCount
;
+
+
i
)
{
nsIFile
*
file
=
specialFiles
[
i
]
;
if
(
file
)
{
rv2
=
openPrefFile
(
file
)
;
if
(
NS_FAILED
(
rv2
)
)
{
NS_ERROR
(
"
Special
default
pref
file
not
parsed
successfully
.
"
)
;
rv
=
rv2
;
}
}
}
return
rv
;
}
static
nsresult
pref_LoadPrefsInDirList
(
const
char
*
listId
)
{
nsresult
rv
;
nsCOMPtr
<
nsIProperties
>
dirSvc
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsISimpleEnumerator
>
list
;
dirSvc
-
>
Get
(
listId
NS_GET_IID
(
nsISimpleEnumerator
)
getter_AddRefs
(
list
)
)
;
if
(
!
list
)
return
NS_OK
;
bool
hasMore
;
while
(
NS_SUCCEEDED
(
list
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
elem
;
list
-
>
GetNext
(
getter_AddRefs
(
elem
)
)
;
if
(
!
elem
)
continue
;
nsCOMPtr
<
nsIFile
>
path
=
do_QueryInterface
(
elem
)
;
if
(
!
path
)
continue
;
nsAutoCString
leaf
;
path
-
>
GetNativeLeafName
(
leaf
)
;
if
(
Substring
(
leaf
leaf
.
Length
(
)
-
4
)
.
EqualsLiteral
(
"
.
xpi
"
)
)
ReadExtensionPrefs
(
path
)
;
else
pref_LoadPrefsInDir
(
path
nullptr
0
)
;
}
return
NS_OK
;
}
static
nsresult
pref_ReadPrefFromJar
(
nsZipArchive
*
jarReader
const
char
*
name
)
{
nsZipItemPtr
<
char
>
manifest
(
jarReader
name
true
)
;
NS_ENSURE_TRUE
(
manifest
.
Buffer
(
)
NS_ERROR_NOT_AVAILABLE
)
;
PrefParseState
ps
;
PREF_InitParseState
(
&
ps
PREF_ReaderCallback
ReportToConsole
nullptr
)
;
PREF_ParseBuf
(
&
ps
manifest
manifest
.
Length
(
)
)
;
PREF_FinalizeParseState
(
&
ps
)
;
return
NS_OK
;
}
static
nsresult
pref_InitInitialObjects
(
)
{
nsresult
rv
;
nsZipFind
*
findPtr
;
nsAutoPtr
<
nsZipFind
>
find
;
nsTArray
<
nsCString
>
prefEntries
;
const
char
*
entryName
;
uint16_t
entryNameLen
;
RefPtr
<
nsZipArchive
>
jarReader
=
mozilla
:
:
Omnijar
:
:
GetReader
(
mozilla
:
:
Omnijar
:
:
GRE
)
;
if
(
jarReader
)
{
rv
=
pref_ReadPrefFromJar
(
jarReader
"
greprefs
.
js
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
jarReader
-
>
FindInit
(
"
defaults
/
pref
/
*
.
js
"
&
findPtr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
find
=
findPtr
;
while
(
NS_SUCCEEDED
(
find
-
>
FindNext
(
&
entryName
&
entryNameLen
)
)
)
{
prefEntries
.
AppendElement
(
Substring
(
entryName
entryNameLen
)
)
;
}
prefEntries
.
Sort
(
)
;
for
(
uint32_t
i
=
prefEntries
.
Length
(
)
;
i
-
-
;
)
{
rv
=
pref_ReadPrefFromJar
(
jarReader
prefEntries
[
i
]
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
NS_WARNING
(
"
Error
parsing
preferences
.
"
)
;
}
}
else
{
nsCOMPtr
<
nsIFile
>
greprefsFile
;
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
greprefsFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
greprefsFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
greprefs
.
js
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
openPrefFile
(
greprefsFile
)
;
if
(
NS_FAILED
(
rv
)
)
NS_WARNING
(
"
Error
parsing
GRE
default
preferences
.
Is
this
an
old
-
style
embedding
app
?
"
)
;
}
nsCOMPtr
<
nsIFile
>
defaultPrefDir
;
rv
=
NS_GetSpecialDirectory
(
NS_APP_PREF_DEFAULTS_50_DIR
getter_AddRefs
(
defaultPrefDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
static
const
char
*
specialFiles
[
]
=
{
#
if
defined
(
XP_MACOSX
)
"
macprefs
.
js
"
#
elif
defined
(
XP_WIN
)
"
winpref
.
js
"
#
elif
defined
(
XP_UNIX
)
"
unix
.
js
"
#
if
defined
(
_AIX
)
"
aix
.
js
"
#
endif
#
elif
defined
(
XP_BEOS
)
"
beos
.
js
"
#
endif
}
;
rv
=
pref_LoadPrefsInDir
(
defaultPrefDir
specialFiles
ArrayLength
(
specialFiles
)
)
;
if
(
NS_FAILED
(
rv
)
)
NS_WARNING
(
"
Error
parsing
application
default
preferences
.
"
)
;
RefPtr
<
nsZipArchive
>
appJarReader
=
mozilla
:
:
Omnijar
:
:
GetReader
(
mozilla
:
:
Omnijar
:
:
APP
)
;
if
(
!
appJarReader
)
appJarReader
=
mozilla
:
:
Omnijar
:
:
GetReader
(
mozilla
:
:
Omnijar
:
:
GRE
)
;
if
(
appJarReader
)
{
rv
=
appJarReader
-
>
FindInit
(
"
defaults
/
preferences
/
*
.
js
"
&
findPtr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
find
=
findPtr
;
prefEntries
.
Clear
(
)
;
while
(
NS_SUCCEEDED
(
find
-
>
FindNext
(
&
entryName
&
entryNameLen
)
)
)
{
prefEntries
.
AppendElement
(
Substring
(
entryName
entryNameLen
)
)
;
}
prefEntries
.
Sort
(
)
;
for
(
uint32_t
i
=
prefEntries
.
Length
(
)
;
i
-
-
;
)
{
rv
=
pref_ReadPrefFromJar
(
appJarReader
prefEntries
[
i
]
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
NS_WARNING
(
"
Error
parsing
preferences
.
"
)
;
}
}
rv
=
pref_LoadPrefsInDirList
(
NS_APP_PREFS_DEFAULTS_DIR_LIST
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
Preferences
:
:
GetDefaultType
(
kTelemetryPref
)
=
=
nsIPrefBranch
:
:
PREF_INVALID
)
{
bool
prerelease
=
false
;
#
ifdef
MOZ_TELEMETRY_ON_BY_DEFAULT
prerelease
=
true
;
#
else
nsAutoCString
prefValue
;
Preferences
:
:
GetDefaultCString
(
kChannelPref
prefValue
)
;
if
(
prefValue
.
EqualsLiteral
(
"
beta
"
)
)
{
prerelease
=
true
;
}
#
endif
PREF_SetBoolPref
(
kTelemetryPref
prerelease
true
)
;
}
NS_CreateServicesFromCategory
(
NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID
nullptr
NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
return
NS_ERROR_FAILURE
;
observerService
-
>
NotifyObservers
(
nullptr
NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID
nullptr
)
;
return
pref_LoadPrefsInDirList
(
NS_EXT_PREFS_DEFAULTS_DIR_LIST
)
;
}
nsresult
Preferences
:
:
GetBool
(
const
char
*
aPref
bool
*
aResult
)
{
NS_PRECONDITION
(
aResult
"
aResult
must
not
be
NULL
"
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
PREF_GetBoolPref
(
aPref
aResult
false
)
;
}
nsresult
Preferences
:
:
GetInt
(
const
char
*
aPref
int32_t
*
aResult
)
{
NS_PRECONDITION
(
aResult
"
aResult
must
not
be
NULL
"
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
PREF_GetIntPref
(
aPref
aResult
false
)
;
}
nsresult
Preferences
:
:
GetFloat
(
const
char
*
aPref
float
*
aResult
)
{
NS_PRECONDITION
(
aResult
"
aResult
must
not
be
NULL
"
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
nsAutoCString
result
;
nsresult
rv
=
PREF_CopyCharPref
(
aPref
getter_Copies
(
result
)
false
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aResult
=
result
.
ToFloat
(
&
rv
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetCString
(
const
char
*
aPref
nsACString
&
aResult
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
char
*
result
;
nsresult
rv
=
PREF_CopyCharPref
(
aPref
&
result
false
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aResult
.
Adopt
(
result
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetString
(
const
char
*
aPref
nsAString
&
aResult
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
nsAutoCString
result
;
nsresult
rv
=
PREF_CopyCharPref
(
aPref
getter_Copies
(
result
)
false
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF8toUTF16
(
result
aResult
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetLocalizedCString
(
const
char
*
aPref
nsACString
&
aResult
)
{
nsAutoString
result
;
nsresult
rv
=
GetLocalizedString
(
aPref
result
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF16toUTF8
(
result
aResult
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetLocalizedString
(
const
char
*
aPref
nsAString
&
aResult
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsIPrefLocalizedString
>
prefLocalString
;
nsresult
rv
=
sRootBranch
-
>
GetComplexValue
(
aPref
NS_GET_IID
(
nsIPrefLocalizedString
)
getter_AddRefs
(
prefLocalString
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_ASSERTION
(
prefLocalString
"
Succeeded
but
the
result
is
NULL
"
)
;
prefLocalString
-
>
GetData
(
getter_Copies
(
aResult
)
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetComplex
(
const
char
*
aPref
const
nsIID
&
aType
void
*
*
aResult
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
sRootBranch
-
>
GetComplexValue
(
aPref
aType
aResult
)
;
}
nsresult
Preferences
:
:
SetCString
(
const
char
*
aPref
const
char
*
aValue
)
{
ENSURE_MAIN_PROCESS
(
"
Cannot
SetCString
from
content
process
:
"
aPref
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
PREF_SetCharPref
(
aPref
aValue
false
)
;
}
nsresult
Preferences
:
:
SetCString
(
const
char
*
aPref
const
nsACString
&
aValue
)
{
ENSURE_MAIN_PROCESS
(
"
Cannot
SetCString
from
content
process
:
"
aPref
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
PREF_SetCharPref
(
aPref
PromiseFlatCString
(
aValue
)
.
get
(
)
false
)
;
}
nsresult
Preferences
:
:
SetString
(
const
char
*
aPref
const
char16ptr_t
aValue
)
{
ENSURE_MAIN_PROCESS
(
"
Cannot
SetString
from
content
process
:
"
aPref
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
PREF_SetCharPref
(
aPref
NS_ConvertUTF16toUTF8
(
aValue
)
.
get
(
)
false
)
;
}
nsresult
Preferences
:
:
SetString
(
const
char
*
aPref
const
nsAString
&
aValue
)
{
ENSURE_MAIN_PROCESS
(
"
Cannot
SetString
from
content
process
:
"
aPref
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
PREF_SetCharPref
(
aPref
NS_ConvertUTF16toUTF8
(
aValue
)
.
get
(
)
false
)
;
}
nsresult
Preferences
:
:
SetBool
(
const
char
*
aPref
bool
aValue
)
{
ENSURE_MAIN_PROCESS
(
"
Cannot
SetBool
from
content
process
:
"
aPref
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
PREF_SetBoolPref
(
aPref
aValue
false
)
;
}
nsresult
Preferences
:
:
SetInt
(
const
char
*
aPref
int32_t
aValue
)
{
ENSURE_MAIN_PROCESS
(
"
Cannot
SetInt
from
content
process
:
"
aPref
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
PREF_SetIntPref
(
aPref
aValue
false
)
;
}
nsresult
Preferences
:
:
SetFloat
(
const
char
*
aPref
float
aValue
)
{
return
SetCString
(
aPref
nsPrintfCString
(
"
%
f
"
aValue
)
.
get
(
)
)
;
}
nsresult
Preferences
:
:
SetComplex
(
const
char
*
aPref
const
nsIID
&
aType
nsISupports
*
aValue
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
sRootBranch
-
>
SetComplexValue
(
aPref
aType
aValue
)
;
}
nsresult
Preferences
:
:
ClearUser
(
const
char
*
aPref
)
{
ENSURE_MAIN_PROCESS
(
"
Cannot
ClearUser
from
content
process
:
"
aPref
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
PREF_ClearUserPref
(
aPref
)
;
}
bool
Preferences
:
:
HasUserValue
(
const
char
*
aPref
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
false
)
;
return
PREF_HasUserPref
(
aPref
)
;
}
int32_t
Preferences
:
:
GetType
(
const
char
*
aPref
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
nsIPrefBranch
:
:
PREF_INVALID
)
;
int32_t
result
;
return
NS_SUCCEEDED
(
sRootBranch
-
>
GetPrefType
(
aPref
&
result
)
)
?
result
:
nsIPrefBranch
:
:
PREF_INVALID
;
}
nsresult
Preferences
:
:
AddStrongObserver
(
nsIObserver
*
aObserver
const
char
*
aPref
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
sRootBranch
-
>
AddObserver
(
aPref
aObserver
false
)
;
}
nsresult
Preferences
:
:
AddWeakObserver
(
nsIObserver
*
aObserver
const
char
*
aPref
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
sRootBranch
-
>
AddObserver
(
aPref
aObserver
true
)
;
}
nsresult
Preferences
:
:
RemoveObserver
(
nsIObserver
*
aObserver
const
char
*
aPref
)
{
if
(
!
sPreferences
&
&
sShutdown
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
sPreferences
NS_ERROR_NOT_AVAILABLE
)
;
return
sRootBranch
-
>
RemoveObserver
(
aPref
aObserver
)
;
}
nsresult
Preferences
:
:
AddStrongObservers
(
nsIObserver
*
aObserver
const
char
*
*
aPrefs
)
{
for
(
uint32_t
i
=
0
;
aPrefs
[
i
]
;
i
+
+
)
{
nsresult
rv
=
AddStrongObserver
(
aObserver
aPrefs
[
i
]
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
AddWeakObservers
(
nsIObserver
*
aObserver
const
char
*
*
aPrefs
)
{
for
(
uint32_t
i
=
0
;
aPrefs
[
i
]
;
i
+
+
)
{
nsresult
rv
=
AddWeakObserver
(
aObserver
aPrefs
[
i
]
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
Preferences
:
:
RemoveObservers
(
nsIObserver
*
aObserver
const
char
*
*
aPrefs
)
{
if
(
!
sPreferences
&
&
sShutdown
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
sPreferences
NS_ERROR_NOT_AVAILABLE
)
;
for
(
uint32_t
i
=
0
;
aPrefs
[
i
]
;
i
+
+
)
{
nsresult
rv
=
RemoveObserver
(
aObserver
aPrefs
[
i
]
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
static
void
NotifyObserver
(
const
char
*
aPref
void
*
aClosure
)
{
nsCOMPtr
<
nsIObserver
>
observer
=
static_cast
<
nsIObserver
*
>
(
aClosure
)
;
observer
-
>
Observe
(
nullptr
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
NS_ConvertASCIItoUTF16
(
aPref
)
.
get
(
)
)
;
}
static
void
RegisterPriorityCallback
(
PrefChangedFunc
aCallback
const
char
*
aPref
void
*
aClosure
)
{
MOZ_ASSERT
(
Preferences
:
:
IsServiceAvailable
(
)
)
;
ValueObserverHashKey
hashKey
(
aPref
aCallback
Preferences
:
:
ExactMatch
)
;
RefPtr
<
ValueObserver
>
observer
;
gObserverTable
-
>
Get
(
&
hashKey
getter_AddRefs
(
observer
)
)
;
if
(
observer
)
{
observer
-
>
AppendClosure
(
aClosure
)
;
return
;
}
observer
=
new
ValueObserver
(
aPref
aCallback
Preferences
:
:
ExactMatch
)
;
observer
-
>
AppendClosure
(
aClosure
)
;
PREF_RegisterPriorityCallback
(
aPref
NotifyObserver
static_cast
<
nsIObserver
*
>
(
observer
)
)
;
gObserverTable
-
>
Put
(
observer
observer
)
;
}
nsresult
Preferences
:
:
RegisterCallback
(
PrefChangedFunc
aCallback
const
char
*
aPref
void
*
aClosure
MatchKind
aMatchKind
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
ValueObserverHashKey
hashKey
(
aPref
aCallback
aMatchKind
)
;
RefPtr
<
ValueObserver
>
observer
;
gObserverTable
-
>
Get
(
&
hashKey
getter_AddRefs
(
observer
)
)
;
if
(
observer
)
{
observer
-
>
AppendClosure
(
aClosure
)
;
return
NS_OK
;
}
observer
=
new
ValueObserver
(
aPref
aCallback
aMatchKind
)
;
observer
-
>
AppendClosure
(
aClosure
)
;
nsresult
rv
=
AddStrongObserver
(
observer
aPref
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
gObserverTable
-
>
Put
(
observer
observer
)
;
return
NS_OK
;
}
nsresult
Preferences
:
:
RegisterCallbackAndCall
(
PrefChangedFunc
aCallback
const
char
*
aPref
void
*
aClosure
MatchKind
aMatchKind
)
{
WATCHING_PREF_RAII
(
)
;
nsresult
rv
=
RegisterCallback
(
aCallback
aPref
aClosure
aMatchKind
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
(
*
aCallback
)
(
aPref
aClosure
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
UnregisterCallback
(
PrefChangedFunc
aCallback
const
char
*
aPref
void
*
aClosure
MatchKind
aMatchKind
)
{
if
(
!
sPreferences
&
&
sShutdown
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
sPreferences
NS_ERROR_NOT_AVAILABLE
)
;
ValueObserverHashKey
hashKey
(
aPref
aCallback
aMatchKind
)
;
RefPtr
<
ValueObserver
>
observer
;
gObserverTable
-
>
Get
(
&
hashKey
getter_AddRefs
(
observer
)
)
;
if
(
!
observer
)
{
return
NS_OK
;
}
observer
-
>
RemoveClosure
(
aClosure
)
;
if
(
observer
-
>
HasNoClosures
(
)
)
{
gObserverTable
-
>
Remove
(
observer
)
;
}
return
NS_OK
;
}
static
void
BoolVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
(
(
bool
*
)
cache
-
>
cacheLocation
)
=
Preferences
:
:
GetBool
(
aPref
cache
-
>
defaultValueBool
)
;
}
nsresult
Preferences
:
:
AddBoolVarCache
(
bool
*
aCache
const
char
*
aPref
bool
aDefault
)
{
WATCHING_PREF_RAII
(
)
;
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
bool
"
aPref
aCache
)
;
#
endif
*
aCache
=
GetBool
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
cacheLocation
=
aCache
;
data
-
>
defaultValueBool
=
aDefault
;
gCacheData
-
>
AppendElement
(
data
)
;
RegisterPriorityCallback
(
BoolVarChanged
aPref
data
)
;
return
NS_OK
;
}
static
void
IntVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
(
(
int32_t
*
)
cache
-
>
cacheLocation
)
=
Preferences
:
:
GetInt
(
aPref
cache
-
>
defaultValueInt
)
;
}
nsresult
Preferences
:
:
AddIntVarCache
(
int32_t
*
aCache
const
char
*
aPref
int32_t
aDefault
)
{
WATCHING_PREF_RAII
(
)
;
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
int
"
aPref
aCache
)
;
#
endif
*
aCache
=
Preferences
:
:
GetInt
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
cacheLocation
=
aCache
;
data
-
>
defaultValueInt
=
aDefault
;
gCacheData
-
>
AppendElement
(
data
)
;
RegisterPriorityCallback
(
IntVarChanged
aPref
data
)
;
return
NS_OK
;
}
static
void
UintVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
(
(
uint32_t
*
)
cache
-
>
cacheLocation
)
=
Preferences
:
:
GetUint
(
aPref
cache
-
>
defaultValueUint
)
;
}
nsresult
Preferences
:
:
AddUintVarCache
(
uint32_t
*
aCache
const
char
*
aPref
uint32_t
aDefault
)
{
WATCHING_PREF_RAII
(
)
;
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
uint
"
aPref
aCache
)
;
#
endif
*
aCache
=
Preferences
:
:
GetUint
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
cacheLocation
=
aCache
;
data
-
>
defaultValueUint
=
aDefault
;
gCacheData
-
>
AppendElement
(
data
)
;
RegisterPriorityCallback
(
UintVarChanged
aPref
data
)
;
return
NS_OK
;
}
template
<
MemoryOrdering
Order
>
static
void
AtomicUintVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
(
(
Atomic
<
uint32_t
Order
>
*
)
cache
-
>
cacheLocation
)
=
Preferences
:
:
GetUint
(
aPref
cache
-
>
defaultValueUint
)
;
}
template
<
MemoryOrdering
Order
>
nsresult
Preferences
:
:
AddAtomicUintVarCache
(
Atomic
<
uint32_t
Order
>
*
aCache
const
char
*
aPref
uint32_t
aDefault
)
{
WATCHING_PREF_RAII
(
)
;
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
uint
"
aPref
aCache
)
;
#
endif
*
aCache
=
Preferences
:
:
GetUint
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
cacheLocation
=
aCache
;
data
-
>
defaultValueUint
=
aDefault
;
gCacheData
-
>
AppendElement
(
data
)
;
RegisterPriorityCallback
(
AtomicUintVarChanged
<
Order
>
aPref
data
)
;
return
NS_OK
;
}
template
nsresult
Preferences
:
:
AddAtomicUintVarCache
(
Atomic
<
uint32_t
Relaxed
>
*
const
char
*
uint32_t
)
;
static
void
FloatVarChanged
(
const
char
*
aPref
void
*
aClosure
)
{
CacheData
*
cache
=
static_cast
<
CacheData
*
>
(
aClosure
)
;
*
(
(
float
*
)
cache
-
>
cacheLocation
)
=
Preferences
:
:
GetFloat
(
aPref
cache
-
>
defaultValueFloat
)
;
}
nsresult
Preferences
:
:
AddFloatVarCache
(
float
*
aCache
const
char
*
aPref
float
aDefault
)
{
WATCHING_PREF_RAII
(
)
;
NS_ASSERTION
(
aCache
"
aCache
must
not
be
NULL
"
)
;
#
ifdef
DEBUG
AssertNotAlreadyCached
(
"
float
"
aPref
aCache
)
;
#
endif
*
aCache
=
Preferences
:
:
GetFloat
(
aPref
aDefault
)
;
CacheData
*
data
=
new
CacheData
(
)
;
data
-
>
cacheLocation
=
aCache
;
data
-
>
defaultValueFloat
=
aDefault
;
gCacheData
-
>
AppendElement
(
data
)
;
RegisterPriorityCallback
(
FloatVarChanged
aPref
data
)
;
return
NS_OK
;
}
nsresult
Preferences
:
:
GetDefaultBool
(
const
char
*
aPref
bool
*
aResult
)
{
NS_PRECONDITION
(
aResult
"
aResult
must
not
be
NULL
"
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
PREF_GetBoolPref
(
aPref
aResult
true
)
;
}
nsresult
Preferences
:
:
GetDefaultInt
(
const
char
*
aPref
int32_t
*
aResult
)
{
NS_PRECONDITION
(
aResult
"
aResult
must
not
be
NULL
"
)
;
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
PREF_GetIntPref
(
aPref
aResult
true
)
;
}
nsresult
Preferences
:
:
GetDefaultCString
(
const
char
*
aPref
nsACString
&
aResult
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
char
*
result
;
nsresult
rv
=
PREF_CopyCharPref
(
aPref
&
result
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aResult
.
Adopt
(
result
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetDefaultString
(
const
char
*
aPref
nsAString
&
aResult
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
nsAutoCString
result
;
nsresult
rv
=
PREF_CopyCharPref
(
aPref
getter_Copies
(
result
)
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF8toUTF16
(
result
aResult
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetDefaultLocalizedCString
(
const
char
*
aPref
nsACString
&
aResult
)
{
nsAutoString
result
;
nsresult
rv
=
GetDefaultLocalizedString
(
aPref
result
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF16toUTF8
(
result
aResult
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetDefaultLocalizedString
(
const
char
*
aPref
nsAString
&
aResult
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsIPrefLocalizedString
>
prefLocalString
;
nsresult
rv
=
sDefaultRootBranch
-
>
GetComplexValue
(
aPref
NS_GET_IID
(
nsIPrefLocalizedString
)
getter_AddRefs
(
prefLocalString
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_ASSERTION
(
prefLocalString
"
Succeeded
but
the
result
is
NULL
"
)
;
prefLocalString
-
>
GetData
(
getter_Copies
(
aResult
)
)
;
}
return
rv
;
}
nsresult
Preferences
:
:
GetDefaultComplex
(
const
char
*
aPref
const
nsIID
&
aType
void
*
*
aResult
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
NS_ERROR_NOT_AVAILABLE
)
;
return
sDefaultRootBranch
-
>
GetComplexValue
(
aPref
aType
aResult
)
;
}
int32_t
Preferences
:
:
GetDefaultType
(
const
char
*
aPref
)
{
NS_ENSURE_TRUE
(
InitStaticMembers
(
)
nsIPrefBranch
:
:
PREF_INVALID
)
;
int32_t
result
;
return
NS_SUCCEEDED
(
sDefaultRootBranch
-
>
GetPrefType
(
aPref
&
result
)
)
?
result
:
nsIPrefBranch
:
:
PREF_INVALID
;
}
}
#
undef
ENSURE_MAIN_PROCESS
