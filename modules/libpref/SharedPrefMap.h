#
ifndef
dom_ipc_SharedPrefMap_h
#
define
dom_ipc_SharedPrefMap_h
#
include
"
mozilla
/
AutoMemMap
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
StringTable
.
h
"
#
include
"
nsDataHashtable
.
h
"
namespace
mozilla
{
constexpr
size_t
kExpectedPrefCount
=
4000
;
class
SharedPrefMapBuilder
;
class
SharedPrefMap
{
using
FileDescriptor
=
mozilla
:
:
ipc
:
:
FileDescriptor
;
friend
class
SharedPrefMapBuilder
;
struct
DataBlock
{
size_t
mOffset
;
size_t
mSize
;
}
;
struct
Header
{
uint32_t
mEntryCount
;
DataBlock
mKeyStrings
;
DataBlock
mUserIntValues
;
DataBlock
mDefaultIntValues
;
DataBlock
mUserStringValues
;
DataBlock
mDefaultStringValues
;
DataBlock
mValueStrings
;
}
;
using
StringTableEntry
=
mozilla
:
:
dom
:
:
ipc
:
:
StringTableEntry
;
union
Value
{
Value
(
bool
aDefaultValue
bool
aUserValue
)
:
mDefaultBool
(
aDefaultValue
)
mUserBool
(
aUserValue
)
{
}
MOZ_IMPLICIT
Value
(
uint16_t
aIndex
)
:
mIndex
(
aIndex
)
{
}
uint16_t
mIndex
;
struct
{
bool
mDefaultBool
;
bool
mUserBool
;
}
;
}
;
struct
Entry
{
StringTableEntry
mKey
;
Value
mValue
;
uint8_t
mType
:
2
;
uint8_t
mHasDefaultValue
:
1
;
uint8_t
mHasUserValue
:
1
;
uint8_t
mIsSticky
:
1
;
uint8_t
mIsLocked
:
1
;
uint8_t
mDefaultChanged
:
1
;
}
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
SharedPrefMap
)
class
MOZ_STACK_CLASS
Pref
final
{
public
:
const
char
*
Name
(
)
const
{
return
mMap
-
>
KeyTable
(
)
.
GetBare
(
mEntry
-
>
mKey
)
;
}
nsCString
NameString
(
)
const
{
return
mMap
-
>
KeyTable
(
)
.
Get
(
mEntry
-
>
mKey
)
;
}
PrefType
Type
(
)
const
{
MOZ_ASSERT
(
PrefType
(
mEntry
-
>
mType
)
!
=
PrefType
:
:
None
)
;
return
PrefType
(
mEntry
-
>
mType
)
;
}
bool
DefaultChanged
(
)
const
{
return
mEntry
-
>
mDefaultChanged
;
}
bool
HasDefaultValue
(
)
const
{
return
mEntry
-
>
mHasDefaultValue
;
}
bool
HasUserValue
(
)
const
{
return
mEntry
-
>
mHasUserValue
;
}
bool
IsLocked
(
)
const
{
return
mEntry
-
>
mIsLocked
;
}
bool
IsSticky
(
)
const
{
return
mEntry
-
>
mIsSticky
;
}
bool
GetBoolValue
(
PrefValueKind
aKind
=
PrefValueKind
:
:
User
)
const
{
MOZ_ASSERT
(
Type
(
)
=
=
PrefType
:
:
Bool
)
;
MOZ_ASSERT
(
aKind
=
=
PrefValueKind
:
:
Default
?
HasDefaultValue
(
)
:
HasUserValue
(
)
)
;
return
aKind
=
=
PrefValueKind
:
:
Default
?
mEntry
-
>
mValue
.
mDefaultBool
:
mEntry
-
>
mValue
.
mUserBool
;
}
int32_t
GetIntValue
(
PrefValueKind
aKind
=
PrefValueKind
:
:
User
)
const
{
MOZ_ASSERT
(
Type
(
)
=
=
PrefType
:
:
Int
)
;
MOZ_ASSERT
(
aKind
=
=
PrefValueKind
:
:
Default
?
HasDefaultValue
(
)
:
HasUserValue
(
)
)
;
return
aKind
=
=
PrefValueKind
:
:
Default
?
mMap
-
>
DefaultIntValues
(
)
[
mEntry
-
>
mValue
.
mIndex
]
:
mMap
-
>
UserIntValues
(
)
[
mEntry
-
>
mValue
.
mIndex
]
;
}
private
:
const
StringTableEntry
&
GetStringEntry
(
PrefValueKind
aKind
)
const
{
MOZ_ASSERT
(
Type
(
)
=
=
PrefType
:
:
String
)
;
MOZ_ASSERT
(
aKind
=
=
PrefValueKind
:
:
Default
?
HasDefaultValue
(
)
:
HasUserValue
(
)
)
;
return
aKind
=
=
PrefValueKind
:
:
Default
?
mMap
-
>
DefaultStringValues
(
)
[
mEntry
-
>
mValue
.
mIndex
]
:
mMap
-
>
UserStringValues
(
)
[
mEntry
-
>
mValue
.
mIndex
]
;
}
public
:
nsCString
GetStringValue
(
PrefValueKind
aKind
=
PrefValueKind
:
:
User
)
const
{
return
mMap
-
>
ValueTable
(
)
.
Get
(
GetStringEntry
(
aKind
)
)
;
}
const
char
*
GetBareStringValue
(
PrefValueKind
aKind
=
PrefValueKind
:
:
User
)
const
{
return
mMap
-
>
ValueTable
(
)
.
GetBare
(
GetStringEntry
(
aKind
)
)
;
}
size_t
Index
(
)
const
{
return
mEntry
-
mMap
-
>
Entries
(
)
.
get
(
)
;
}
bool
operator
=
=
(
const
Pref
&
aPref
)
const
{
return
mEntry
=
=
aPref
.
mEntry
;
}
bool
operator
!
=
(
const
Pref
&
aPref
)
const
{
return
!
(
*
this
=
=
aPref
)
;
}
Pref
&
operator
*
(
)
{
return
*
this
;
}
Pref
&
operator
+
+
(
)
{
mEntry
+
+
;
return
*
this
;
}
Pref
(
const
Pref
&
aPref
)
=
default
;
protected
:
friend
class
SharedPrefMap
;
Pref
(
const
SharedPrefMap
*
aPrefMap
const
Entry
*
aEntry
)
:
mMap
(
aPrefMap
)
mEntry
(
aEntry
)
{
}
private
:
const
SharedPrefMap
*
const
mMap
;
const
Entry
*
mEntry
;
}
;
SharedPrefMap
(
const
FileDescriptor
&
size_t
)
;
explicit
SharedPrefMap
(
SharedPrefMapBuilder
&
&
)
;
bool
Has
(
const
char
*
aKey
)
const
;
bool
Has
(
const
nsCString
&
aKey
)
const
{
return
Has
(
aKey
.
get
(
)
)
;
}
Maybe
<
const
Pref
>
Get
(
const
char
*
aKey
)
const
;
Maybe
<
const
Pref
>
Get
(
const
nsCString
&
aKey
)
const
{
return
Get
(
aKey
.
get
(
)
)
;
}
private
:
bool
Find
(
const
char
*
aKey
size_t
*
aIndex
)
const
;
public
:
uint32_t
Count
(
)
const
{
return
EntryCount
(
)
;
}
nsCString
GetKeyAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
Count
(
)
)
;
return
KeyTable
(
)
.
Get
(
Entries
(
)
[
aIndex
]
.
mKey
)
;
}
const
Pref
GetValueAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
Count
(
)
)
;
return
UncheckedGetValueAt
(
aIndex
)
;
}
private
:
Pref
UncheckedGetValueAt
(
uint32_t
aIndex
)
const
{
return
{
this
(
Entries
(
)
+
aIndex
)
.
get
(
)
}
;
}
public
:
Pref
begin
(
)
const
{
return
UncheckedGetValueAt
(
0
)
;
}
Pref
end
(
)
const
{
return
UncheckedGetValueAt
(
Count
(
)
)
;
}
const
SharedPrefMap
&
Iter
(
)
const
{
return
*
this
;
}
FileDescriptor
CloneFileDescriptor
(
)
const
;
size_t
MapSize
(
)
const
{
return
mMap
.
size
(
)
;
}
protected
:
~
SharedPrefMap
(
)
=
default
;
private
:
template
<
typename
T
>
using
StringTable
=
mozilla
:
:
dom
:
:
ipc
:
:
StringTable
<
T
>
;
const
Header
&
GetHeader
(
)
const
{
return
mMap
.
get
<
Header
>
(
)
[
0
]
;
}
RangedPtr
<
const
Entry
>
Entries
(
)
const
{
return
{
reinterpret_cast
<
const
Entry
*
>
(
&
GetHeader
(
)
+
1
)
EntryCount
(
)
}
;
}
uint32_t
EntryCount
(
)
const
{
return
GetHeader
(
)
.
mEntryCount
;
}
template
<
typename
T
>
RangedPtr
<
const
T
>
GetBlock
(
const
DataBlock
&
aBlock
)
const
{
return
RangedPtr
<
uint8_t
>
(
&
mMap
.
get
<
uint8_t
>
(
)
[
aBlock
.
mOffset
]
aBlock
.
mSize
)
.
ReinterpretCast
<
const
T
>
(
)
;
}
RangedPtr
<
const
int32_t
>
DefaultIntValues
(
)
const
{
return
GetBlock
<
int32_t
>
(
GetHeader
(
)
.
mDefaultIntValues
)
;
}
RangedPtr
<
const
int32_t
>
UserIntValues
(
)
const
{
return
GetBlock
<
int32_t
>
(
GetHeader
(
)
.
mUserIntValues
)
;
}
RangedPtr
<
const
StringTableEntry
>
DefaultStringValues
(
)
const
{
return
GetBlock
<
StringTableEntry
>
(
GetHeader
(
)
.
mDefaultStringValues
)
;
}
RangedPtr
<
const
StringTableEntry
>
UserStringValues
(
)
const
{
return
GetBlock
<
StringTableEntry
>
(
GetHeader
(
)
.
mUserStringValues
)
;
}
StringTable
<
nsCString
>
KeyTable
(
)
const
{
auto
&
block
=
GetHeader
(
)
.
mKeyStrings
;
return
{
{
&
mMap
.
get
<
uint8_t
>
(
)
[
block
.
mOffset
]
block
.
mSize
}
}
;
}
StringTable
<
nsCString
>
ValueTable
(
)
const
{
auto
&
block
=
GetHeader
(
)
.
mValueStrings
;
return
{
{
&
mMap
.
get
<
uint8_t
>
(
)
[
block
.
mOffset
]
block
.
mSize
}
}
;
}
loader
:
:
AutoMemMap
mMap
;
}
;
class
MOZ_RAII
SharedPrefMapBuilder
{
public
:
SharedPrefMapBuilder
(
)
=
default
;
struct
Flags
{
uint8_t
mHasDefaultValue
:
1
;
uint8_t
mHasUserValue
:
1
;
uint8_t
mIsSticky
:
1
;
uint8_t
mIsLocked
:
1
;
uint8_t
mDefaultChanged
:
1
;
}
;
void
Add
(
const
char
*
aKey
const
Flags
&
aFlags
bool
aDefaultValue
bool
aUserValue
)
;
void
Add
(
const
char
*
aKey
const
Flags
&
aFlags
int32_t
aDefaultValue
int32_t
aUserValue
)
;
void
Add
(
const
char
*
aKey
const
Flags
&
aFlags
const
nsCString
&
aDefaultValue
const
nsCString
&
aUserValue
)
;
Result
<
Ok
nsresult
>
Finalize
(
loader
:
:
AutoMemMap
&
aMap
)
;
private
:
using
StringTableEntry
=
mozilla
:
:
dom
:
:
ipc
:
:
StringTableEntry
;
template
<
typename
T
typename
U
>
using
StringTableBuilder
=
mozilla
:
:
dom
:
:
ipc
:
:
StringTableBuilder
<
T
U
>
;
struct
ValueIdx
{
uint16_t
mIndex
;
bool
mHasUserValue
;
}
;
template
<
typename
HashKey
typename
ValueType_
>
class
ValueTableBuilder
{
public
:
using
ValueType
=
ValueType_
;
ValueIdx
Add
(
const
ValueType
&
aDefaultValue
)
{
auto
index
=
uint16_t
(
mDefaultEntries
.
Count
(
)
)
;
auto
entry
=
mDefaultEntries
.
LookupForAdd
(
aDefaultValue
)
.
OrInsert
(
[
&
]
(
)
{
return
Entry
{
index
false
aDefaultValue
}
;
}
)
;
return
{
entry
.
mIndex
false
}
;
}
ValueIdx
Add
(
const
ValueType
&
aDefaultValue
const
ValueType
&
aUserValue
)
{
auto
index
=
uint16_t
(
mUserEntries
.
Length
(
)
)
;
mUserEntries
.
AppendElement
(
Entry
{
index
true
aDefaultValue
aUserValue
}
)
;
return
{
index
true
}
;
}
uint16_t
GetIndex
(
const
ValueIdx
&
aIndex
)
const
{
uint16_t
base
=
aIndex
.
mHasUserValue
?
0
:
UserCount
(
)
;
return
base
+
aIndex
.
mIndex
;
}
void
WriteDefaultValues
(
const
RangedPtr
<
uint8_t
>
&
aBuffer
)
const
{
auto
buffer
=
aBuffer
.
ReinterpretCast
<
ValueType
>
(
)
;
for
(
const
auto
&
entry
:
mUserEntries
)
{
buffer
[
entry
.
mIndex
]
=
entry
.
mDefaultValue
;
}
size_t
defaultsOffset
=
UserCount
(
)
;
for
(
auto
iter
=
mDefaultEntries
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
auto
&
entry
=
iter
.
Data
(
)
;
buffer
[
defaultsOffset
+
entry
.
mIndex
]
=
entry
.
mDefaultValue
;
}
}
void
WriteUserValues
(
const
RangedPtr
<
uint8_t
>
&
aBuffer
)
const
{
auto
buffer
=
aBuffer
.
ReinterpretCast
<
ValueType
>
(
)
;
for
(
const
auto
&
entry
:
mUserEntries
)
{
buffer
[
entry
.
mIndex
]
=
entry
.
mUserValue
;
}
}
uint32_t
DefaultCount
(
)
const
{
return
UserCount
(
)
+
mDefaultEntries
.
Count
(
)
;
}
uint32_t
UserCount
(
)
const
{
return
mUserEntries
.
Length
(
)
;
}
uint32_t
DefaultSize
(
)
const
{
return
DefaultCount
(
)
*
sizeof
(
ValueType
)
;
}
uint32_t
UserSize
(
)
const
{
return
UserCount
(
)
*
sizeof
(
ValueType
)
;
}
void
Clear
(
)
{
mUserEntries
.
Clear
(
)
;
mDefaultEntries
.
Clear
(
)
;
}
static
constexpr
size_t
Alignment
(
)
{
return
alignof
(
ValueType
)
;
}
private
:
struct
Entry
{
uint16_t
mIndex
;
bool
mHasUserValue
;
ValueType
mDefaultValue
;
ValueType
mUserValue
{
}
;
}
;
AutoTArray
<
Entry
256
>
mUserEntries
;
nsDataHashtable
<
HashKey
Entry
>
mDefaultEntries
;
}
;
template
<
typename
CharType
>
class
UniqueStringTableBuilder
{
public
:
using
ElemType
=
CharType
;
explicit
UniqueStringTableBuilder
(
size_t
aCapacity
)
:
mEntries
(
aCapacity
)
{
}
StringTableEntry
Add
(
const
CharType
*
aKey
)
{
auto
entry
=
mEntries
.
AppendElement
(
Entry
{
mSize
uint32_t
(
strlen
(
aKey
)
)
aKey
}
)
;
mSize
+
=
entry
-
>
mLength
+
1
;
return
{
entry
-
>
mOffset
entry
-
>
mLength
}
;
}
void
Write
(
const
RangedPtr
<
uint8_t
>
&
aBuffer
)
{
auto
buffer
=
aBuffer
.
ReinterpretCast
<
ElemType
>
(
)
;
for
(
auto
&
entry
:
mEntries
)
{
memcpy
(
&
buffer
[
entry
.
mOffset
]
entry
.
mValue
sizeof
(
ElemType
)
*
(
entry
.
mLength
+
1
)
)
;
}
}
uint32_t
Count
(
)
const
{
return
mEntries
.
Length
(
)
;
}
uint32_t
Size
(
)
const
{
return
mSize
*
sizeof
(
ElemType
)
;
}
void
Clear
(
)
{
mEntries
.
Clear
(
)
;
}
static
constexpr
size_t
Alignment
(
)
{
return
alignof
(
ElemType
)
;
}
private
:
struct
Entry
{
uint32_t
mOffset
;
uint32_t
mLength
;
const
CharType
*
mValue
;
}
;
nsTArray
<
Entry
>
mEntries
;
uint32_t
mSize
=
0
;
}
;
union
Value
{
Value
(
bool
aDefaultValue
bool
aUserValue
)
:
mDefaultBool
(
aDefaultValue
)
mUserBool
(
aUserValue
)
{
}
MOZ_IMPLICIT
Value
(
const
ValueIdx
&
aIndex
)
:
mIndex
(
aIndex
)
{
}
struct
{
bool
mDefaultBool
;
bool
mUserBool
;
}
;
ValueIdx
mIndex
;
}
;
struct
Entry
{
const
char
*
mKeyString
;
StringTableEntry
mKey
;
Value
mValue
;
uint8_t
mType
:
2
;
uint8_t
mHasDefaultValue
:
1
;
uint8_t
mHasUserValue
:
1
;
uint8_t
mIsSticky
:
1
;
uint8_t
mIsLocked
:
1
;
uint8_t
mDefaultChanged
:
1
;
}
;
SharedPrefMap
:
:
Value
GetValue
(
const
Entry
&
aEntry
)
const
{
switch
(
PrefType
(
aEntry
.
mType
)
)
{
case
PrefType
:
:
Bool
:
return
{
aEntry
.
mValue
.
mDefaultBool
aEntry
.
mValue
.
mUserBool
}
;
case
PrefType
:
:
Int
:
return
{
mIntValueTable
.
GetIndex
(
aEntry
.
mValue
.
mIndex
)
}
;
case
PrefType
:
:
String
:
return
{
mStringValueTable
.
GetIndex
(
aEntry
.
mValue
.
mIndex
)
}
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
pref
type
"
)
;
return
{
false
false
}
;
}
}
UniqueStringTableBuilder
<
char
>
mKeyTable
{
kExpectedPrefCount
}
;
StringTableBuilder
<
nsCStringHashKey
nsCString
>
mValueStringTable
;
ValueTableBuilder
<
nsUint32HashKey
uint32_t
>
mIntValueTable
;
ValueTableBuilder
<
nsGenericHashKey
<
StringTableEntry
>
StringTableEntry
>
mStringValueTable
;
nsTArray
<
Entry
>
mEntries
{
kExpectedPrefCount
}
;
}
;
}
#
endif
