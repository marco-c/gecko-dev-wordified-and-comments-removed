#
include
<
ctype
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
"
nsString
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
prefread
.
h
"
#
ifdef
TEST_PREFREAD
#
include
<
stdio
.
h
>
#
define
NS_WARNING
(
_s
)
printf
(
"
>
>
>
"
_s
"
!
\
n
"
)
#
define
NS_NOTREACHED
(
_s
)
NS_WARNING
(
_s
)
#
else
#
include
"
nsDebug
.
h
"
#
endif
enum
{
PREF_PARSE_INIT
PREF_PARSE_MATCH_STRING
PREF_PARSE_UNTIL_NAME
PREF_PARSE_QUOTED_STRING
PREF_PARSE_UNTIL_COMMA
PREF_PARSE_UNTIL_VALUE
PREF_PARSE_INT_VALUE
PREF_PARSE_COMMENT_MAYBE_START
PREF_PARSE_COMMENT_BLOCK
PREF_PARSE_COMMENT_BLOCK_MAYBE_END
PREF_PARSE_ESC_SEQUENCE
PREF_PARSE_HEX_ESCAPE
PREF_PARSE_UTF16_LOW_SURROGATE
PREF_PARSE_UNTIL_OPEN_PAREN
PREF_PARSE_UNTIL_CLOSE_PAREN
PREF_PARSE_UNTIL_SEMICOLON
PREF_PARSE_UNTIL_EOL
}
;
#
define
UTF16_ESC_NUM_DIGITS
4
#
define
HEX_ESC_NUM_DIGITS
2
#
define
BITS_PER_HEX_DIGIT
4
static
const
char
kUserPref
[
]
=
"
user_pref
"
;
static
const
char
kPref
[
]
=
"
pref
"
;
static
const
char
kPrefSticky
[
]
=
"
sticky_pref
"
;
static
const
char
kTrue
[
]
=
"
true
"
;
static
const
char
kFalse
[
]
=
"
false
"
;
static
bool
pref_GrowBuf
(
PrefParseState
*
aPS
)
{
int
bufLen
curPos
valPos
;
bufLen
=
aPS
-
>
lbend
-
aPS
-
>
lb
;
curPos
=
aPS
-
>
lbcur
-
aPS
-
>
lb
;
valPos
=
aPS
-
>
vb
-
aPS
-
>
lb
;
if
(
bufLen
=
=
0
)
{
bufLen
=
128
;
}
else
{
bufLen
<
<
=
1
;
}
#
ifdef
TEST_PREFREAD
fprintf
(
stderr
"
>
>
>
realloc
(
%
d
)
\
n
"
bufLen
)
;
#
endif
aPS
-
>
lb
=
(
char
*
)
realloc
(
aPS
-
>
lb
bufLen
)
;
if
(
!
aPS
-
>
lb
)
{
return
false
;
}
aPS
-
>
lbcur
=
aPS
-
>
lb
+
curPos
;
aPS
-
>
lbend
=
aPS
-
>
lb
+
bufLen
;
aPS
-
>
vb
=
aPS
-
>
lb
+
valPos
;
return
true
;
}
static
void
pref_ReportParseProblem
(
PrefParseState
&
aPS
const
char
*
aMessage
int
aLine
bool
aError
)
{
if
(
aPS
.
reporter
)
{
aPS
.
reporter
(
aMessage
aLine
aError
)
;
}
else
{
printf_stderr
(
"
*
*
*
*
Preference
parsing
%
s
(
line
%
d
)
=
%
s
*
*
\
n
"
(
aError
?
"
error
"
:
"
warning
"
)
aLine
aMessage
)
;
}
}
static
bool
pref_DoCallback
(
PrefParseState
*
aPS
)
{
PrefValue
value
;
switch
(
aPS
-
>
vtype
)
{
case
PrefType
:
:
String
:
value
.
stringVal
=
aPS
-
>
vb
;
break
;
case
PrefType
:
:
Int
:
if
(
(
aPS
-
>
vb
[
0
]
=
=
'
-
'
|
|
aPS
-
>
vb
[
0
]
=
=
'
+
'
)
&
&
aPS
-
>
vb
[
1
]
=
=
'
\
0
'
)
{
pref_ReportParseProblem
(
*
aPS
"
invalid
integer
value
"
0
true
)
;
NS_WARNING
(
"
malformed
integer
value
"
)
;
return
false
;
}
value
.
intVal
=
atoi
(
aPS
-
>
vb
)
;
break
;
case
PrefType
:
:
Bool
:
value
.
boolVal
=
(
aPS
-
>
vb
=
=
kTrue
)
;
break
;
default
:
break
;
}
(
*
aPS
-
>
reader
)
(
aPS
-
>
closure
aPS
-
>
lb
value
aPS
-
>
vtype
aPS
-
>
fdefault
aPS
-
>
fstickydefault
)
;
return
true
;
}
void
PREF_InitParseState
(
PrefParseState
*
aPS
PrefReader
aReader
PrefParseErrorReporter
aReporter
void
*
aClosure
)
{
memset
(
aPS
0
sizeof
(
*
aPS
)
)
;
aPS
-
>
reader
=
aReader
;
aPS
-
>
closure
=
aClosure
;
aPS
-
>
reporter
=
aReporter
;
}
void
PREF_FinalizeParseState
(
PrefParseState
*
aPS
)
{
if
(
aPS
-
>
lb
)
{
free
(
aPS
-
>
lb
)
;
}
}
bool
PREF_ParseBuf
(
PrefParseState
*
aPS
const
char
*
aBuf
int
aBufLen
)
{
const
char
*
end
;
char
c
;
char
udigit
;
int
state
;
int
lineNum
=
0
;
state
=
aPS
-
>
state
;
for
(
end
=
aBuf
+
aBufLen
;
aBuf
!
=
end
;
+
+
aBuf
)
{
c
=
*
aBuf
;
if
(
c
=
=
'
\
r
'
|
|
c
=
=
'
\
n
'
|
|
c
=
=
0x1A
)
{
lineNum
+
+
;
}
switch
(
state
)
{
case
PREF_PARSE_INIT
:
if
(
aPS
-
>
lbcur
!
=
aPS
-
>
lb
)
{
aPS
-
>
lbcur
=
aPS
-
>
lb
;
aPS
-
>
vb
=
nullptr
;
aPS
-
>
vtype
=
PrefType
:
:
Invalid
;
aPS
-
>
fdefault
=
false
;
aPS
-
>
fstickydefault
=
false
;
}
switch
(
c
)
{
case
'
/
'
:
state
=
PREF_PARSE_COMMENT_MAYBE_START
;
break
;
case
'
#
'
:
state
=
PREF_PARSE_UNTIL_EOL
;
break
;
case
'
u
'
:
case
'
s
'
:
case
'
p
'
:
if
(
c
=
=
'
u
'
)
{
aPS
-
>
smatch
=
kUserPref
;
}
else
if
(
c
=
=
'
s
'
)
{
aPS
-
>
smatch
=
kPrefSticky
;
}
else
{
aPS
-
>
smatch
=
kPref
;
}
aPS
-
>
sindex
=
1
;
aPS
-
>
nextstate
=
PREF_PARSE_UNTIL_OPEN_PAREN
;
state
=
PREF_PARSE_MATCH_STRING
;
break
;
}
break
;
case
PREF_PARSE_MATCH_STRING
:
if
(
c
=
=
aPS
-
>
smatch
[
aPS
-
>
sindex
+
+
]
)
{
if
(
aPS
-
>
smatch
[
aPS
-
>
sindex
]
=
=
'
\
0
'
)
{
state
=
aPS
-
>
nextstate
;
aPS
-
>
nextstate
=
PREF_PARSE_INIT
;
}
}
else
{
pref_ReportParseProblem
(
*
aPS
"
non
-
matching
string
"
lineNum
true
)
;
NS_WARNING
(
"
malformed
pref
file
"
)
;
return
false
;
}
break
;
case
PREF_PARSE_QUOTED_STRING
:
if
(
aPS
-
>
lbcur
=
=
aPS
-
>
lbend
&
&
!
pref_GrowBuf
(
aPS
)
)
{
return
false
;
}
if
(
c
=
=
'
\
\
'
)
{
state
=
PREF_PARSE_ESC_SEQUENCE
;
}
else
if
(
c
=
=
aPS
-
>
quotechar
)
{
*
aPS
-
>
lbcur
+
+
=
'
\
0
'
;
state
=
aPS
-
>
nextstate
;
aPS
-
>
nextstate
=
PREF_PARSE_INIT
;
}
else
{
*
aPS
-
>
lbcur
+
+
=
c
;
}
break
;
case
PREF_PARSE_UNTIL_NAME
:
if
(
c
=
=
'
\
"
'
|
|
c
=
=
'
\
'
'
)
{
aPS
-
>
fdefault
=
(
aPS
-
>
smatch
=
=
kPref
|
|
aPS
-
>
smatch
=
=
kPrefSticky
)
;
aPS
-
>
fstickydefault
=
(
aPS
-
>
smatch
=
=
kPrefSticky
)
;
aPS
-
>
quotechar
=
c
;
aPS
-
>
nextstate
=
PREF_PARSE_UNTIL_COMMA
;
state
=
PREF_PARSE_QUOTED_STRING
;
}
else
if
(
c
=
=
'
/
'
)
{
aPS
-
>
nextstate
=
state
;
state
=
PREF_PARSE_COMMENT_MAYBE_START
;
}
else
if
(
!
isspace
(
c
)
)
{
pref_ReportParseProblem
(
*
aPS
"
need
space
comment
or
quote
"
lineNum
true
)
;
NS_WARNING
(
"
malformed
pref
file
"
)
;
return
false
;
}
break
;
case
PREF_PARSE_UNTIL_COMMA
:
if
(
c
=
=
'
'
)
{
aPS
-
>
vb
=
aPS
-
>
lbcur
;
state
=
PREF_PARSE_UNTIL_VALUE
;
}
else
if
(
c
=
=
'
/
'
)
{
aPS
-
>
nextstate
=
state
;
state
=
PREF_PARSE_COMMENT_MAYBE_START
;
}
else
if
(
!
isspace
(
c
)
)
{
pref_ReportParseProblem
(
*
aPS
"
need
space
comment
or
comma
"
lineNum
true
)
;
NS_WARNING
(
"
malformed
pref
file
"
)
;
return
false
;
}
break
;
case
PREF_PARSE_UNTIL_VALUE
:
if
(
c
=
=
'
\
"
'
|
|
c
=
=
'
\
'
'
)
{
aPS
-
>
vtype
=
PrefType
:
:
String
;
aPS
-
>
quotechar
=
c
;
aPS
-
>
nextstate
=
PREF_PARSE_UNTIL_CLOSE_PAREN
;
state
=
PREF_PARSE_QUOTED_STRING
;
}
else
if
(
c
=
=
'
t
'
|
|
c
=
=
'
f
'
)
{
aPS
-
>
vb
=
(
char
*
)
(
c
=
=
'
t
'
?
kTrue
:
kFalse
)
;
aPS
-
>
vtype
=
PrefType
:
:
Bool
;
aPS
-
>
smatch
=
aPS
-
>
vb
;
aPS
-
>
sindex
=
1
;
aPS
-
>
nextstate
=
PREF_PARSE_UNTIL_CLOSE_PAREN
;
state
=
PREF_PARSE_MATCH_STRING
;
}
else
if
(
isdigit
(
c
)
|
|
(
c
=
=
'
-
'
)
|
|
(
c
=
=
'
+
'
)
)
{
aPS
-
>
vtype
=
PrefType
:
:
Int
;
if
(
aPS
-
>
lbcur
=
=
aPS
-
>
lbend
&
&
!
pref_GrowBuf
(
aPS
)
)
{
return
false
;
}
*
aPS
-
>
lbcur
+
+
=
c
;
state
=
PREF_PARSE_INT_VALUE
;
}
else
if
(
c
=
=
'
/
'
)
{
aPS
-
>
nextstate
=
state
;
state
=
PREF_PARSE_COMMENT_MAYBE_START
;
}
else
if
(
!
isspace
(
c
)
)
{
pref_ReportParseProblem
(
*
aPS
"
need
value
comment
or
space
"
lineNum
true
)
;
NS_WARNING
(
"
malformed
pref
file
"
)
;
return
false
;
}
break
;
case
PREF_PARSE_INT_VALUE
:
if
(
aPS
-
>
lbcur
=
=
aPS
-
>
lbend
&
&
!
pref_GrowBuf
(
aPS
)
)
{
return
false
;
}
if
(
isdigit
(
c
)
)
{
*
aPS
-
>
lbcur
+
+
=
c
;
}
else
{
*
aPS
-
>
lbcur
+
+
=
'
\
0
'
;
if
(
c
=
=
'
)
'
)
{
state
=
PREF_PARSE_UNTIL_SEMICOLON
;
}
else
if
(
c
=
=
'
/
'
)
{
aPS
-
>
nextstate
=
PREF_PARSE_UNTIL_CLOSE_PAREN
;
state
=
PREF_PARSE_COMMENT_MAYBE_START
;
}
else
if
(
isspace
(
c
)
)
{
state
=
PREF_PARSE_UNTIL_CLOSE_PAREN
;
}
else
{
pref_ReportParseProblem
(
*
aPS
"
while
parsing
integer
"
lineNum
true
)
;
NS_WARNING
(
"
malformed
pref
file
"
)
;
return
false
;
}
}
break
;
case
PREF_PARSE_COMMENT_MAYBE_START
:
switch
(
c
)
{
case
'
*
'
:
state
=
PREF_PARSE_COMMENT_BLOCK
;
break
;
case
'
/
'
:
state
=
PREF_PARSE_UNTIL_EOL
;
break
;
default
:
pref_ReportParseProblem
(
*
aPS
"
while
parsing
comment
"
lineNum
true
)
;
NS_WARNING
(
"
malformed
pref
file
"
)
;
return
false
;
}
break
;
case
PREF_PARSE_COMMENT_BLOCK
:
if
(
c
=
=
'
*
'
)
{
state
=
PREF_PARSE_COMMENT_BLOCK_MAYBE_END
;
}
break
;
case
PREF_PARSE_COMMENT_BLOCK_MAYBE_END
:
switch
(
c
)
{
case
'
/
'
:
state
=
aPS
-
>
nextstate
;
aPS
-
>
nextstate
=
PREF_PARSE_INIT
;
break
;
case
'
*
'
:
break
;
default
:
state
=
PREF_PARSE_COMMENT_BLOCK
;
break
;
}
break
;
case
PREF_PARSE_ESC_SEQUENCE
:
switch
(
c
)
{
case
'
\
"
'
:
case
'
\
'
'
:
case
'
\
\
'
:
break
;
case
'
r
'
:
c
=
'
\
r
'
;
break
;
case
'
n
'
:
c
=
'
\
n
'
;
break
;
case
'
x
'
:
case
'
u
'
:
aPS
-
>
esctmp
[
0
]
=
c
;
aPS
-
>
esclen
=
1
;
aPS
-
>
utf16
[
0
]
=
aPS
-
>
utf16
[
1
]
=
0
;
aPS
-
>
sindex
=
(
c
=
=
'
x
'
)
?
HEX_ESC_NUM_DIGITS
:
UTF16_ESC_NUM_DIGITS
;
state
=
PREF_PARSE_HEX_ESCAPE
;
continue
;
default
:
pref_ReportParseProblem
(
*
aPS
"
preserving
unexpected
JS
escape
sequence
"
lineNum
false
)
;
NS_WARNING
(
"
preserving
unexpected
JS
escape
sequence
"
)
;
if
(
(
aPS
-
>
lbcur
+
1
)
=
=
aPS
-
>
lbend
&
&
!
pref_GrowBuf
(
aPS
)
)
{
return
false
;
}
*
aPS
-
>
lbcur
+
+
=
'
\
\
'
;
break
;
}
*
aPS
-
>
lbcur
+
+
=
c
;
state
=
PREF_PARSE_QUOTED_STRING
;
break
;
case
PREF_PARSE_HEX_ESCAPE
:
if
(
c
>
=
'
0
'
&
&
c
<
=
'
9
'
)
{
udigit
=
(
c
-
'
0
'
)
;
}
else
if
(
c
>
=
'
A
'
&
&
c
<
=
'
F
'
)
{
udigit
=
(
c
-
'
A
'
)
+
10
;
}
else
if
(
c
>
=
'
a
'
&
&
c
<
=
'
f
'
)
{
udigit
=
(
c
-
'
a
'
)
+
10
;
}
else
{
pref_ReportParseProblem
(
*
aPS
"
preserving
invalid
or
incomplete
hex
escape
"
lineNum
false
)
;
NS_WARNING
(
"
preserving
invalid
or
incomplete
hex
escape
"
)
;
*
aPS
-
>
lbcur
+
+
=
'
\
\
'
;
if
(
(
aPS
-
>
lbcur
+
aPS
-
>
esclen
)
>
=
aPS
-
>
lbend
&
&
!
pref_GrowBuf
(
aPS
)
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
aPS
-
>
esclen
;
+
+
i
)
{
*
aPS
-
>
lbcur
+
+
=
aPS
-
>
esctmp
[
i
]
;
}
-
-
aBuf
;
state
=
PREF_PARSE_QUOTED_STRING
;
continue
;
}
aPS
-
>
esctmp
[
aPS
-
>
esclen
+
+
]
=
c
;
aPS
-
>
utf16
[
1
]
<
<
=
BITS_PER_HEX_DIGIT
;
aPS
-
>
utf16
[
1
]
|
=
udigit
;
aPS
-
>
sindex
-
-
;
if
(
aPS
-
>
sindex
=
=
0
)
{
int
utf16len
=
0
;
if
(
aPS
-
>
utf16
[
0
]
)
{
utf16len
=
2
;
}
else
if
(
0xD800
=
=
(
0xFC00
&
aPS
-
>
utf16
[
1
]
)
)
{
aPS
-
>
utf16
[
0
]
=
aPS
-
>
utf16
[
1
]
;
aPS
-
>
utf16
[
1
]
=
0
;
state
=
PREF_PARSE_UTF16_LOW_SURROGATE
;
break
;
}
else
{
aPS
-
>
utf16
[
0
]
=
aPS
-
>
utf16
[
1
]
;
utf16len
=
1
;
}
if
(
aPS
-
>
lbcur
+
6
>
=
aPS
-
>
lbend
&
&
!
pref_GrowBuf
(
aPS
)
)
{
return
false
;
}
ConvertUTF16toUTF8
converter
(
aPS
-
>
lbcur
)
;
converter
.
write
(
aPS
-
>
utf16
utf16len
)
;
aPS
-
>
lbcur
+
=
converter
.
Size
(
)
;
state
=
PREF_PARSE_QUOTED_STRING
;
}
break
;
case
PREF_PARSE_UTF16_LOW_SURROGATE
:
if
(
aPS
-
>
sindex
=
=
0
&
&
c
=
=
'
\
\
'
)
{
+
+
aPS
-
>
sindex
;
}
else
if
(
aPS
-
>
sindex
=
=
1
&
&
c
=
=
'
u
'
)
{
aPS
-
>
sindex
=
UTF16_ESC_NUM_DIGITS
;
aPS
-
>
esctmp
[
0
]
=
'
u
'
;
aPS
-
>
esclen
=
1
;
state
=
PREF_PARSE_HEX_ESCAPE
;
}
else
{
-
-
aBuf
;
if
(
aPS
-
>
sindex
=
=
1
)
{
state
=
PREF_PARSE_ESC_SEQUENCE
;
}
else
{
state
=
PREF_PARSE_QUOTED_STRING
;
}
continue
;
}
break
;
case
PREF_PARSE_UNTIL_OPEN_PAREN
:
if
(
c
=
=
'
(
'
)
{
state
=
PREF_PARSE_UNTIL_NAME
;
}
else
if
(
c
=
=
'
/
'
)
{
aPS
-
>
nextstate
=
state
;
state
=
PREF_PARSE_COMMENT_MAYBE_START
;
}
else
if
(
!
isspace
(
c
)
)
{
pref_ReportParseProblem
(
*
aPS
"
need
space
comment
or
open
parentheses
"
lineNum
true
)
;
NS_WARNING
(
"
malformed
pref
file
"
)
;
return
false
;
}
break
;
case
PREF_PARSE_UNTIL_CLOSE_PAREN
:
if
(
c
=
=
'
)
'
)
{
state
=
PREF_PARSE_UNTIL_SEMICOLON
;
}
else
if
(
c
=
=
'
/
'
)
{
aPS
-
>
nextstate
=
state
;
state
=
PREF_PARSE_COMMENT_MAYBE_START
;
}
else
if
(
!
isspace
(
c
)
)
{
pref_ReportParseProblem
(
*
aPS
"
need
space
comment
or
closing
parentheses
"
lineNum
true
)
;
NS_WARNING
(
"
malformed
pref
file
"
)
;
return
false
;
}
break
;
case
PREF_PARSE_UNTIL_SEMICOLON
:
if
(
c
=
=
'
;
'
)
{
if
(
!
pref_DoCallback
(
aPS
)
)
{
return
false
;
}
state
=
PREF_PARSE_INIT
;
}
else
if
(
c
=
=
'
/
'
)
{
aPS
-
>
nextstate
=
state
;
state
=
PREF_PARSE_COMMENT_MAYBE_START
;
}
else
if
(
!
isspace
(
c
)
)
{
pref_ReportParseProblem
(
*
aPS
"
need
space
comment
or
semicolon
"
lineNum
true
)
;
NS_WARNING
(
"
malformed
pref
file
"
)
;
return
false
;
}
break
;
case
PREF_PARSE_UNTIL_EOL
:
if
(
c
=
=
'
\
r
'
|
|
c
=
=
'
\
n
'
|
|
c
=
=
0x1A
)
{
state
=
aPS
-
>
nextstate
;
aPS
-
>
nextstate
=
PREF_PARSE_INIT
;
}
break
;
}
}
aPS
-
>
state
=
state
;
return
true
;
}
#
ifdef
TEST_PREFREAD
static
void
pref_reader
(
void
*
aClosure
const
char
*
aPref
PrefValue
aVal
PrefType
aType
bool
aDefPref
)
{
printf
(
"
%
spref
(
\
"
%
s
\
"
"
aDefPref
?
"
"
:
"
user_
"
aPref
)
;
switch
(
aType
)
{
case
PREF_STRING
:
printf
(
"
\
"
%
s
\
"
)
;
\
n
"
aVal
.
stringVal
)
;
break
;
case
PREF_INT
:
printf
(
"
%
i
)
;
\
n
"
aVal
.
intVal
)
;
break
;
case
PREF_BOOL
:
printf
(
"
%
s
)
;
\
n
"
aVal
.
boolVal
=
=
false
?
"
false
"
:
"
true
"
)
;
break
;
}
}
int
main
(
int
aArgc
char
*
*
aArgv
)
{
PrefParseState
aPS
;
char
buf
[
4096
]
;
FILE
*
fp
;
int
n
;
if
(
aArgc
=
=
1
)
{
printf
(
"
usage
:
prefread
file
.
js
\
n
"
)
;
return
-
1
;
}
fp
=
fopen
(
aArgv
[
1
]
"
r
"
)
;
if
(
!
fp
)
{
printf
(
"
failed
to
open
file
\
n
"
)
;
return
-
1
;
}
PREF_InitParseState
(
&
aPS
pref_reader
nullptr
nullptr
)
;
while
(
(
n
=
fread
(
buf
1
sizeof
(
buf
)
fp
)
)
>
0
)
{
PREF_ParseBuf
(
&
aPS
buf
n
)
;
}
PREF_FinalizeParseState
(
&
aPS
)
;
fclose
(
fp
)
;
return
0
;
}
#
endif
