function
run_test
(
)
{
function
signMAR
(
inMAR
outMAR
certs
wantSuccess
useShortHandCmdLine
)
{
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
let
signmarBin
=
do_get_file
(
"
signmar
"
+
BIN_SUFFIX
)
;
do_check_true
(
signmarBin
.
exists
(
)
)
;
do_check_true
(
signmarBin
.
isExecutable
(
)
)
;
let
NSSConfigDir
=
do_get_file
(
"
data
"
)
;
let
args
=
[
"
-
d
"
NSSConfigDir
.
path
]
;
if
(
certs
.
length
=
=
1
&
&
useShortHandCmdLine
)
{
args
.
push
(
"
-
n
"
certs
[
0
]
)
;
}
else
{
for
(
let
i
=
0
;
i
<
certs
.
length
;
i
+
+
)
{
args
.
push
(
"
-
n
"
+
i
certs
[
i
]
)
;
}
}
args
.
push
(
"
-
s
"
inMAR
.
path
outMAR
.
path
)
;
let
exitValue
;
process
.
init
(
signmarBin
)
;
try
{
process
.
run
(
true
args
args
.
length
)
;
exitValue
=
process
.
exitValue
;
}
catch
(
e
)
{
exitValue
=
-
1
;
}
if
(
wantSuccess
)
{
do_check_eq
(
exitValue
0
)
;
}
else
{
do_check_neq
(
exitValue
0
)
;
}
}
function
extractMARSignature
(
inMAR
sigIndex
extractedSig
wantSuccess
)
{
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
let
signmarBin
=
do_get_file
(
"
signmar
"
+
BIN_SUFFIX
)
;
do_check_true
(
signmarBin
.
exists
(
)
)
;
do_check_true
(
signmarBin
.
isExecutable
(
)
)
;
let
args
=
[
"
-
n
"
+
sigIndex
"
-
X
"
inMAR
.
path
extractedSig
.
path
]
;
let
exitValue
;
process
.
init
(
signmarBin
)
;
try
{
process
.
run
(
true
args
args
.
length
)
;
exitValue
=
process
.
exitValue
;
}
catch
(
e
)
{
exitValue
=
-
1
;
}
if
(
wantSuccess
)
{
do_check_eq
(
exitValue
0
)
;
}
else
{
do_check_neq
(
exitValue
0
)
;
}
}
function
importMARSignature
(
inMAR
sigIndex
sigFile
outMAR
wantSuccess
)
{
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
let
signmarBin
=
do_get_file
(
"
signmar
"
+
BIN_SUFFIX
)
;
do_check_true
(
signmarBin
.
exists
(
)
)
;
do_check_true
(
signmarBin
.
isExecutable
(
)
)
;
let
args
=
[
"
-
n
"
+
sigIndex
"
-
I
"
inMAR
.
path
sigFile
.
path
outMAR
.
path
]
;
let
exitValue
;
process
.
init
(
signmarBin
)
;
try
{
process
.
run
(
true
args
args
.
length
)
;
exitValue
=
process
.
exitValue
;
}
catch
(
e
)
{
exitValue
=
-
1
;
}
if
(
wantSuccess
)
{
do_check_eq
(
exitValue
0
)
;
}
else
{
do_check_neq
(
exitValue
0
)
;
}
}
function
verifyMAR
(
signedMAR
wantSuccess
certs
useShortHandCmdLine
)
{
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
let
signmarBin
=
do_get_file
(
"
signmar
"
+
BIN_SUFFIX
)
;
do_check_true
(
signmarBin
.
exists
(
)
)
;
do_check_true
(
signmarBin
.
isExecutable
(
)
)
;
let
args
=
[
]
;
if
(
mozinfo
.
os
=
=
"
win
"
|
|
mozinfo
.
os
=
=
"
mac
"
)
{
if
(
certs
.
length
=
=
1
&
&
useShortHandCmdLine
)
{
args
.
push
(
"
-
D
"
"
data
/
"
+
certs
[
0
]
+
"
.
der
"
)
;
}
else
{
for
(
let
i
=
0
;
i
<
certs
.
length
;
i
+
+
)
{
args
.
push
(
"
-
D
"
+
i
"
data
/
"
+
certs
[
i
]
+
"
.
der
"
)
;
}
}
}
else
{
let
NSSConfigDir
=
do_get_file
(
"
data
"
)
;
args
=
[
"
-
d
"
NSSConfigDir
.
path
]
;
if
(
certs
.
length
=
=
1
&
&
useShortHandCmdLine
)
{
args
.
push
(
"
-
n
"
certs
[
0
]
)
;
}
else
{
for
(
let
i
=
0
;
i
<
certs
.
length
;
i
+
+
)
{
args
.
push
(
"
-
n
"
+
i
certs
[
i
]
)
;
}
}
}
args
.
push
(
"
-
v
"
signedMAR
.
path
)
;
let
exitValue
;
process
.
init
(
signmarBin
)
;
try
{
process
.
run
(
true
args
args
.
length
)
;
exitValue
=
process
.
exitValue
;
}
catch
(
e
)
{
exitValue
=
-
1
;
}
if
(
wantSuccess
)
{
do_check_eq
(
exitValue
0
)
;
}
else
{
do_check_neq
(
exitValue
0
)
;
}
}
function
stripMARSignature
(
signedMAR
outMAR
wantSuccess
)
{
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
let
signmarBin
=
do_get_file
(
"
signmar
"
+
BIN_SUFFIX
)
;
do_check_true
(
signmarBin
.
exists
(
)
)
;
do_check_true
(
signmarBin
.
isExecutable
(
)
)
;
let
args
=
[
"
-
r
"
signedMAR
.
path
outMAR
.
path
]
;
let
exitValue
;
process
.
init
(
signmarBin
)
;
try
{
process
.
run
(
true
args
args
.
length
)
;
exitValue
=
process
.
exitValue
;
}
catch
(
e
)
{
exitValue
=
-
1
;
}
if
(
wantSuccess
)
{
do_check_eq
(
exitValue
0
)
;
}
else
{
do_check_neq
(
exitValue
0
)
;
}
}
function
cleanup
(
)
{
let
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
signed_out
.
mar
"
)
;
if
(
outMAR
.
exists
(
)
)
{
outMAR
.
remove
(
false
)
;
}
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
multiple_signed_out
.
mar
"
)
;
if
(
outMAR
.
exists
(
)
)
{
outMAR
.
remove
(
false
)
;
}
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
out
.
mar
"
)
;
if
(
outMAR
.
exists
(
)
)
{
outMAR
.
remove
(
false
)
;
}
let
outDir
=
tempDir
.
clone
(
)
;
outDir
.
append
(
"
out
"
)
;
if
(
outDir
.
exists
(
)
)
{
outDir
.
remove
(
true
)
;
}
}
const
wantFailure
=
false
;
const
wantSuccess
=
true
;
let
tests
=
{
test_sign_single
:
function
_test_sign_single
(
)
{
let
inMAR
=
do_get_file
(
"
data
/
binary_data
.
mar
"
)
;
let
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
signed_out
.
mar
"
)
;
if
(
outMAR
.
exists
(
)
)
{
outMAR
.
remove
(
false
)
;
}
signMAR
(
inMAR
outMAR
[
"
mycert
"
]
wantSuccess
true
)
;
do_check_true
(
outMAR
.
exists
(
)
)
;
let
outMARData
=
getBinaryFileData
(
outMAR
)
;
let
refMAR
=
do_get_file
(
"
data
/
signed_pib
.
mar
"
)
;
let
refMARData
=
getBinaryFileData
(
refMAR
)
;
compareBinaryData
(
outMARData
refMARData
)
;
}
test_sign_multiple
:
function
_test_sign_multiple
(
)
{
let
inMAR
=
do_get_file
(
"
data
/
binary_data
.
mar
"
)
;
let
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
multiple_signed_out
.
mar
"
)
;
if
(
outMAR
.
exists
(
)
)
{
outMAR
.
remove
(
false
)
;
}
do_check_false
(
outMAR
.
exists
(
)
)
;
signMAR
(
inMAR
outMAR
[
"
mycert
"
"
mycert2
"
"
mycert3
"
]
wantSuccess
true
)
;
do_check_true
(
outMAR
.
exists
(
)
)
;
let
outMARData
=
getBinaryFileData
(
outMAR
)
;
let
refMAR
=
do_get_file
(
"
data
/
multiple_signed_pib
.
mar
"
)
;
let
refMARData
=
getBinaryFileData
(
refMAR
)
;
compareBinaryData
(
outMARData
refMARData
)
;
}
test_verify_single
:
function
_test_verify_single
(
)
{
let
signedMAR
=
do_get_file
(
"
data
/
signed_pib
.
mar
"
)
;
verifyMAR
(
signedMAR
wantSuccess
[
"
mycert
"
]
true
)
;
verifyMAR
(
signedMAR
wantSuccess
[
"
mycert
"
]
false
)
;
}
test_verify_single_too_many_certs
:
function
_test_verify_single_too_many_certs
(
)
{
let
signedMAR
=
do_get_file
(
"
data
/
signed_pib
.
mar
"
)
;
verifyMAR
(
signedMAR
wantFailure
[
"
mycert
"
"
mycert
"
]
true
)
;
verifyMAR
(
signedMAR
wantFailure
[
"
mycert
"
"
mycert
"
]
false
)
;
}
test_verify_single_wrong_cert
:
function
_test_verify_single_wrong_cert
(
)
{
let
signedMAR
=
do_get_file
(
"
data
/
signed_pib
.
mar
"
)
;
verifyMAR
(
signedMAR
wantFailure
[
"
mycert2
"
]
true
)
;
verifyMAR
(
signedMAR
wantFailure
[
"
mycert2
"
]
false
)
;
}
test_verify_multiple
:
function
_test_verify_multiple
(
)
{
let
signedMAR
=
do_get_file
(
"
data
/
multiple_signed_pib
.
mar
"
)
;
verifyMAR
(
signedMAR
wantSuccess
[
"
mycert
"
"
mycert2
"
"
mycert3
"
]
)
;
}
test_verify_unsigned_mar_file_fails
:
function
_test_verify_unsigned_mar_file_fails
(
)
{
let
unsignedMAR
=
do_get_file
(
"
data
/
binary_data
.
mar
"
)
;
verifyMAR
(
unsignedMAR
wantFailure
[
"
mycert
"
"
mycert2
"
"
mycert3
"
]
)
;
}
test_verify_multiple_same_cert
:
function
_test_verify_multiple_same_cert
(
)
{
let
signedMAR
=
do_get_file
(
"
data
/
multiple_signed_pib
.
mar
"
)
;
verifyMAR
(
signedMAR
wantFailure
[
"
mycert
"
"
mycert
"
"
mycert
"
]
)
;
}
test_verify_multiple_wrong_order
:
function
_test_verify_multiple_wrong_order
(
)
{
let
signedMAR
=
do_get_file
(
"
data
/
multiple_signed_pib
.
mar
"
)
;
verifyMAR
(
signedMAR
wantSuccess
[
"
mycert
"
"
mycert2
"
"
mycert3
"
]
)
;
verifyMAR
(
signedMAR
wantFailure
[
"
mycert
"
"
mycert3
"
"
mycert2
"
]
)
;
verifyMAR
(
signedMAR
wantFailure
[
"
mycert2
"
"
mycert
"
"
mycert3
"
]
)
;
verifyMAR
(
signedMAR
wantFailure
[
"
mycert2
"
"
mycert3
"
"
mycert
"
]
)
;
verifyMAR
(
signedMAR
wantFailure
[
"
mycert3
"
"
mycert
"
"
mycert2
"
]
)
;
verifyMAR
(
signedMAR
wantFailure
[
"
mycert3
"
"
mycert2
"
"
mycert
"
]
)
;
}
test_verify_no_pib
:
function
_test_verify_no_pib
(
)
{
let
signedMAR
=
do_get_file
(
"
data
/
signed_no_pib
.
mar
"
)
;
verifyMAR
(
signedMAR
wantSuccess
[
"
mycert
"
]
true
)
;
verifyMAR
(
signedMAR
wantSuccess
[
"
mycert
"
]
false
)
;
}
test_verify_no_pib_multiple
:
function
_test_verify_no_pib_multiple
(
)
{
let
signedMAR
=
do_get_file
(
"
data
/
multiple_signed_no_pib
.
mar
"
)
;
verifyMAR
(
signedMAR
wantSuccess
[
"
mycert
"
"
mycert2
"
"
mycert3
"
]
)
;
}
test_crafted_mar
:
function
_test_crafted_mar
(
)
{
let
signedBadMAR
=
do_get_file
(
"
data
/
manipulated_signed
.
mar
"
)
;
verifyMAR
(
signedBadMAR
wantFailure
[
"
mycert
"
]
true
)
;
verifyMAR
(
signedBadMAR
wantFailure
[
"
mycert
"
]
false
)
;
}
test_bad_path_verify_fails
:
function
_test_bad_path_verify_fails
(
)
{
let
noMAR
=
do_get_file
(
"
data
/
does_not_exist
.
mar
"
true
)
;
do_check_false
(
noMAR
.
exists
(
)
)
;
verifyMAR
(
noMAR
wantFailure
[
"
mycert
"
]
true
)
;
}
test_strip_signature
:
function
_test_strip_signature
(
)
{
let
originalMAR
=
do_get_file
(
"
data
/
binary_data
.
mar
"
)
;
let
signedMAR
=
tempDir
.
clone
(
)
;
signedMAR
.
append
(
"
signed_out
.
mar
"
)
;
let
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
out
.
mar
"
true
)
;
stripMARSignature
(
signedMAR
outMAR
wantSuccess
)
;
let
outMARData
=
getBinaryFileData
(
outMAR
)
;
let
originalMARData
=
getBinaryFileData
(
originalMAR
)
;
compareBinaryData
(
outMARData
originalMARData
)
;
}
test_strip_multiple_signatures
:
function
_test_strip_multiple_signatures
(
)
{
let
originalMAR
=
do_get_file
(
"
data
/
binary_data
.
mar
"
)
;
let
signedMAR
=
tempDir
.
clone
(
)
;
signedMAR
.
append
(
"
multiple_signed_out
.
mar
"
)
;
let
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
out
.
mar
"
)
;
stripMARSignature
(
signedMAR
outMAR
wantSuccess
)
;
let
outMARData
=
getBinaryFileData
(
outMAR
)
;
let
originalMARData
=
getBinaryFileData
(
originalMAR
)
;
compareBinaryData
(
outMARData
originalMARData
)
;
}
test_extract_sig_single
:
function
_test_extract_sig_single
(
)
{
let
inMAR
=
do_get_file
(
"
data
/
signed_pib
.
mar
"
)
;
let
extractedSig
=
do_get_file
(
"
extracted_signature
"
true
)
;
if
(
extractedSig
.
exists
(
)
)
{
extractedSig
.
remove
(
false
)
;
}
extractMARSignature
(
inMAR
0
extractedSig
wantSuccess
)
;
do_check_true
(
extractedSig
.
exists
(
)
)
;
let
referenceSig
=
do_get_file
(
"
data
/
signed_pib_mar
.
signature
.
0
"
)
;
compareBinaryData
(
extractedSig
referenceSig
)
;
}
test_extract_sig_multi
:
function
_test_extract_sig_multi
(
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
let
inMAR
=
do_get_file
(
"
data
/
multiple_signed_pib
.
mar
"
)
;
let
extractedSig
=
do_get_file
(
"
extracted_signature
"
true
)
;
if
(
extractedSig
.
exists
(
)
)
{
extractedSig
.
remove
(
false
)
;
}
extractMARSignature
(
inMAR
i
extractedSig
wantSuccess
)
;
do_check_true
(
extractedSig
.
exists
(
)
)
;
let
referenceSig
=
do_get_file
(
"
data
/
multiple_signed_pib_mar
.
sig
.
"
+
i
)
;
compareBinaryData
(
extractedSig
referenceSig
)
;
}
}
test_extract_sig_out_of_range
:
function
_test_extract_sig_out_of_range
(
)
{
let
inMAR
=
do_get_file
(
"
data
/
signed_pib
.
mar
"
)
;
let
extractedSig
=
do_get_file
(
"
extracted_signature
"
true
)
;
if
(
extractedSig
.
exists
(
)
)
{
extractedSig
.
remove
(
false
)
;
}
const
outOfBoundsIndex
=
5
;
extractMARSignature
(
inMAR
outOfBoundsIndex
extractedSig
wantFailure
)
;
do_check_false
(
extractedSig
.
exists
(
)
)
;
}
test_bad_path_sign_fails
:
function
_test_bad_path_sign_fails
(
)
{
let
inMAR
=
do_get_file
(
"
data
/
does_not_exist
.
mar
"
true
)
;
let
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
signed_out
.
mar
"
)
;
do_check_false
(
inMAR
.
exists
(
)
)
;
signMAR
(
inMAR
outMAR
[
"
mycert
"
]
wantFailure
true
)
;
do_check_false
(
outMAR
.
exists
(
)
)
;
}
test_verify_multiple_subset
:
function
_test_verify_multiple_subset
(
)
{
let
signedMAR
=
do_get_file
(
"
data
/
multiple_signed_pib
.
mar
"
)
;
verifyMAR
(
signedMAR
wantFailure
[
"
mycert
"
"
mycert2
"
]
)
;
}
test_import_sig_single
:
function
_test_import_sig_single
(
)
{
let
inMAR
=
do_get_file
(
"
data
/
signed_pib
.
mar
"
)
;
verifyMAR
(
inMAR
wantSuccess
[
"
mycert
"
]
false
)
;
verifyMAR
(
inMAR
wantFailure
[
"
mycert2
"
]
false
)
;
verifyMAR
(
inMAR
wantFailure
[
"
mycert3
"
]
false
)
;
let
sigFile
=
do_get_file
(
"
data
/
signed_pib_mar
.
signature
.
mycert2
"
)
;
do_check_true
(
sigFile
.
exists
(
)
)
;
let
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
sigchanged_signed_pib
.
mar
"
)
;
if
(
outMAR
.
exists
(
)
)
{
outMAR
.
remove
(
false
)
;
}
importMARSignature
(
inMAR
0
sigFile
outMAR
wantSuccess
)
;
do_check_true
(
outMAR
.
exists
(
)
)
;
verifyMAR
(
outMAR
wantFailure
[
"
mycert
"
]
false
)
;
verifyMAR
(
outMAR
wantSuccess
[
"
mycert2
"
]
false
)
;
verifyMAR
(
outMAR
wantFailure
[
"
mycert3
"
]
false
)
;
let
refMAR
=
do_get_file
(
"
data
/
signed_pib_with_mycert2
.
mar
"
)
;
do_check_true
(
refMAR
.
exists
(
)
)
;
let
refMARData
=
getBinaryFileData
(
refMAR
)
;
let
outMARData
=
getBinaryFileData
(
outMAR
)
;
compareBinaryData
(
outMARData
refMARData
)
;
}
test_import_wrong_sig
:
function
_test_import_wrong_sig
(
)
{
let
inMAR
=
do_get_file
(
"
data
/
signed_pib
.
mar
"
)
;
verifyMAR
(
inMAR
wantSuccess
[
"
mycert
"
]
false
)
;
verifyMAR
(
inMAR
wantFailure
[
"
mycert2
"
]
false
)
;
verifyMAR
(
inMAR
wantFailure
[
"
mycert3
"
]
false
)
;
let
sigFile
=
do_get_file
(
"
data
/
multiple_signed_pib_mar
.
sig
.
0
"
)
;
do_check_true
(
sigFile
.
exists
(
)
)
;
let
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
sigchanged_signed_pib
.
mar
"
)
;
if
(
outMAR
.
exists
(
)
)
{
outMAR
.
remove
(
false
)
;
}
importMARSignature
(
inMAR
0
sigFile
outMAR
wantSuccess
)
;
do_check_true
(
outMAR
.
exists
(
)
)
;
verifyMAR
(
outMAR
wantFailure
[
"
mycert
"
]
false
)
;
verifyMAR
(
outMAR
wantFailure
[
"
mycert2
"
]
false
)
;
verifyMAR
(
outMAR
wantFailure
[
"
mycert3
"
]
false
)
;
}
test_import_sig_multiple
:
function
_test_import_sig_multiple
(
)
{
let
inMAR
=
do_get_file
(
"
data
/
multiple_signed_pib
.
mar
"
)
;
verifyMAR
(
inMAR
wantSuccess
[
"
mycert
"
"
mycert2
"
"
mycert3
"
]
false
)
;
verifyMAR
(
inMAR
wantFailure
[
"
mycert
"
"
mycert
"
"
mycert3
"
]
false
)
;
let
sigFile
=
do_get_file
(
"
data
/
multiple_signed_pib_mar
.
sig
.
0
"
)
;
do_check_true
(
sigFile
.
exists
(
)
)
;
let
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
sigchanged_signed_pib
.
mar
"
)
;
if
(
outMAR
.
exists
(
)
)
{
outMAR
.
remove
(
false
)
;
}
const
secondSigPos
=
1
;
importMARSignature
(
inMAR
secondSigPos
sigFile
outMAR
wantSuccess
)
;
do_check_true
(
outMAR
.
exists
(
)
)
;
verifyMAR
(
outMAR
wantSuccess
[
"
mycert
"
"
mycert
"
"
mycert3
"
]
false
)
;
verifyMAR
(
outMAR
wantFailure
[
"
mycert
"
"
mycert2
"
"
mycert3
"
]
false
)
;
let
refMAR
=
do_get_file
(
"
data
/
multiple_signed_pib_2
.
mar
"
)
;
do_check_true
(
refMAR
.
exists
(
)
)
;
let
refMARData
=
getBinaryFileData
(
refMAR
)
;
let
outMARData
=
getBinaryFileData
(
outMAR
)
;
compareBinaryData
(
outMARData
refMARData
)
;
}
test_bad_path_strip_fails
:
function
_test_bad_path_strip_fails
(
)
{
let
noMAR
=
do_get_file
(
"
data
/
does_not_exist
.
mar
"
true
)
;
do_check_false
(
noMAR
.
exists
(
)
)
;
let
outMAR
=
tempDir
.
clone
(
)
;
outMAR
.
append
(
"
out
.
mar
"
)
;
stripMARSignature
(
noMAR
outMAR
wantFailure
)
;
}
test_extract_bad_path
:
function
_test_extract_bad_path
(
)
{
let
noMAR
=
do_get_file
(
"
data
/
does_not_exist
.
mar
"
true
)
;
let
extractedSig
=
do_get_file
(
"
extracted_signature
"
true
)
;
do_check_false
(
noMAR
.
exists
(
)
)
;
if
(
extractedSig
.
exists
(
)
)
{
extractedSig
.
remove
(
false
)
;
}
extractMARSignature
(
noMAR
0
extractedSig
wantFailure
)
;
do_check_false
(
extractedSig
.
exists
(
)
)
;
}
cleanup_per_test
:
function
_cleanup_per_test
(
)
{
}
}
;
cleanup
(
)
;
do_check_eq
(
run_tests
(
tests
)
Object
.
keys
(
tests
)
.
length
-
1
)
;
do_register_cleanup
(
cleanup
)
;
}
