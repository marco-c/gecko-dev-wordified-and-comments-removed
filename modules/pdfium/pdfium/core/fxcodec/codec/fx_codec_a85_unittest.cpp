#
include
<
stdint
.
h
>
#
include
<
limits
>
#
include
"
core
/
fxcodec
/
codec
/
ccodec_basicmodule
.
h
"
#
include
"
core
/
fxcodec
/
fx_codec
.
h
"
#
include
"
testing
/
fx_string_testhelpers
.
h
"
#
include
"
testing
/
gtest
/
include
/
gtest
/
gtest
.
h
"
TEST
(
fxcodec
A85TestBadInputs
)
{
const
uint8_t
src_buf
[
]
=
{
1
2
3
4
}
;
uint8_t
*
dest_buf
=
nullptr
;
uint32_t
src_size
=
4
;
uint32_t
dest_size
=
0
;
CCodec_BasicModule
*
pEncoders
=
CCodec_ModuleMgr
(
)
.
GetBasicModule
(
)
;
EXPECT_TRUE
(
pEncoders
)
;
EXPECT_FALSE
(
pEncoders
-
>
A85Encode
(
src_buf
src_size
&
dest_buf
nullptr
)
)
;
EXPECT_FALSE
(
pEncoders
-
>
A85Encode
(
src_buf
src_size
nullptr
&
dest_size
)
)
;
EXPECT_FALSE
(
pEncoders
-
>
A85Encode
(
src_buf
0
&
dest_buf
&
dest_size
)
)
;
EXPECT_FALSE
(
pEncoders
-
>
A85Encode
(
nullptr
src_size
&
dest_buf
&
dest_size
)
)
;
}
TEST
(
fxcodec
A85TestBasic
)
{
const
uint8_t
src_buf
[
]
=
{
1
2
3
4
255
255
255
255
}
;
uint8_t
*
dest_buf
=
nullptr
;
uint32_t
src_size
=
8
;
uint32_t
dest_size
=
0
;
CCodec_BasicModule
*
pEncoders
=
CCodec_ModuleMgr
(
)
.
GetBasicModule
(
)
;
EXPECT_TRUE
(
pEncoders
)
;
EXPECT_TRUE
(
pEncoders
-
>
A85Encode
(
src_buf
src_size
&
dest_buf
&
dest_size
)
)
;
ASSERT_EQ
(
12u
dest_size
)
;
const
uint8_t
expected_out
[
]
=
{
33
60
78
63
43
115
56
87
45
33
126
62
}
;
for
(
uint32_t
i
=
0
;
i
<
12
;
i
+
+
)
EXPECT_EQ
(
expected_out
[
i
]
dest_buf
[
i
]
)
<
<
"
at
"
<
<
i
;
FX_Free
(
dest_buf
)
;
}
TEST
(
fxcodec
A85TestLeftoverBytes
)
{
const
uint8_t
src_buf_1leftover
[
]
=
{
1
2
3
4
255
}
;
uint8_t
*
dest_buf
=
nullptr
;
uint32_t
src_size
=
5
;
uint32_t
dest_size
=
0
;
CCodec_BasicModule
*
pEncoders
=
CCodec_ModuleMgr
(
)
.
GetBasicModule
(
)
;
EXPECT_TRUE
(
pEncoders
)
;
EXPECT_TRUE
(
pEncoders
-
>
A85Encode
(
src_buf_1leftover
src_size
&
dest_buf
&
dest_size
)
)
;
ASSERT_EQ
(
9u
dest_size
)
;
uint8_t
expected_out_1leftover
[
]
=
{
33
60
78
63
43
114
114
126
62
}
;
for
(
uint32_t
i
=
0
;
i
<
9
;
i
+
+
)
EXPECT_EQ
(
expected_out_1leftover
[
i
]
dest_buf
[
i
]
)
<
<
"
at
"
<
<
i
;
FX_Free
(
dest_buf
)
;
src_size
+
+
;
dest_buf
=
nullptr
;
dest_size
=
0
;
const
uint8_t
src_buf_2leftover
[
]
=
{
1
2
3
4
255
254
}
;
EXPECT_TRUE
(
pEncoders
-
>
A85Encode
(
src_buf_2leftover
src_size
&
dest_buf
&
dest_size
)
)
;
ASSERT_EQ
(
10u
dest_size
)
;
const
uint8_t
expected_out_2leftover
[
]
=
{
33
60
78
63
43
115
56
68
126
62
}
;
for
(
uint32_t
i
=
0
;
i
<
10
;
i
+
+
)
EXPECT_EQ
(
expected_out_2leftover
[
i
]
dest_buf
[
i
]
)
<
<
"
at
"
<
<
i
;
FX_Free
(
dest_buf
)
;
src_size
+
+
;
dest_buf
=
nullptr
;
dest_size
=
0
;
const
uint8_t
src_buf_3leftover
[
]
=
{
1
2
3
4
255
254
253
}
;
EXPECT_TRUE
(
pEncoders
-
>
A85Encode
(
src_buf_3leftover
src_size
&
dest_buf
&
dest_size
)
)
;
ASSERT_EQ
(
11u
dest_size
)
;
const
uint8_t
expected_out_3leftover
[
]
=
{
33
60
78
63
43
115
56
77
114
126
62
}
;
for
(
uint32_t
i
=
0
;
i
<
11
;
i
+
+
)
EXPECT_EQ
(
expected_out_3leftover
[
i
]
dest_buf
[
i
]
)
<
<
"
at
"
<
<
i
;
FX_Free
(
dest_buf
)
;
}
TEST
(
fxcodec
A85TestZeros
)
{
const
uint8_t
src_buf
[
]
=
{
1
2
3
4
0
0
0
0
}
;
uint8_t
*
dest_buf
=
nullptr
;
uint32_t
src_size
=
8
;
uint32_t
dest_size
=
0
;
CCodec_BasicModule
*
pEncoders
=
CCodec_ModuleMgr
(
)
.
GetBasicModule
(
)
;
EXPECT_TRUE
(
pEncoders
)
;
EXPECT_TRUE
(
pEncoders
-
>
A85Encode
(
src_buf
src_size
&
dest_buf
&
dest_size
)
)
;
ASSERT_EQ
(
8u
dest_size
)
;
const
uint8_t
expected_out
[
]
=
{
33
60
78
63
43
122
126
62
}
;
for
(
uint32_t
i
=
0
;
i
<
8
;
i
+
+
)
EXPECT_EQ
(
expected_out
[
i
]
dest_buf
[
i
]
)
<
<
"
at
"
<
<
i
;
FX_Free
(
dest_buf
)
;
dest_buf
=
nullptr
;
dest_size
=
0
;
const
uint8_t
src_buf_2
[
]
=
{
0
0
0
0
1
2
3
4
}
;
EXPECT_TRUE
(
pEncoders
-
>
A85Encode
(
src_buf_2
src_size
&
dest_buf
&
dest_size
)
)
;
ASSERT_EQ
(
8u
dest_size
)
;
const
uint8_t
expected_out_2
[
]
=
{
122
33
60
78
63
43
126
62
}
;
for
(
uint32_t
i
=
0
;
i
<
8
;
i
+
+
)
EXPECT_EQ
(
expected_out_2
[
i
]
dest_buf
[
i
]
)
<
<
"
at
"
<
<
i
;
FX_Free
(
dest_buf
)
;
src_size
=
6
;
dest_buf
=
nullptr
;
dest_size
=
0
;
EXPECT_TRUE
(
pEncoders
-
>
A85Encode
(
src_buf
src_size
&
dest_buf
&
dest_size
)
)
;
ASSERT_EQ
(
10u
dest_size
)
;
const
uint8_t
expected_out_leftover
[
]
=
{
33
60
78
63
43
33
33
33
126
62
}
;
for
(
uint32_t
i
=
0
;
i
<
10
;
i
+
+
)
EXPECT_EQ
(
expected_out_leftover
[
i
]
dest_buf
[
i
]
)
<
<
"
at
"
<
<
i
;
FX_Free
(
dest_buf
)
;
}
TEST
(
fxcodec
A85TestLineBreaks
)
{
uint8_t
src_buf
[
131
]
=
{
0
}
;
for
(
int
k
=
0
;
k
<
116
;
k
+
=
4
)
{
src_buf
[
k
]
=
1
;
src_buf
[
k
+
1
]
=
2
;
src_buf
[
k
+
2
]
=
3
;
src_buf
[
k
+
3
]
=
4
;
}
for
(
int
k
=
120
;
k
<
128
;
k
+
+
)
{
src_buf
[
k
]
=
1
;
src_buf
[
k
+
1
]
=
2
;
src_buf
[
k
+
2
]
=
3
;
src_buf
[
k
+
3
]
=
4
;
}
uint8_t
*
dest_buf
=
nullptr
;
uint32_t
src_size
=
131
;
uint32_t
dest_size
=
0
;
CCodec_BasicModule
*
pEncoders
=
CCodec_ModuleMgr
(
)
.
GetBasicModule
(
)
;
EXPECT_TRUE
(
pEncoders
)
;
EXPECT_TRUE
(
pEncoders
-
>
A85Encode
(
src_buf
src_size
&
dest_buf
&
dest_size
)
)
;
ASSERT_EQ
(
166u
dest_size
)
;
EXPECT_EQ
(
13
dest_buf
[
75
]
)
;
EXPECT_EQ
(
10
dest_buf
[
76
]
)
;
EXPECT_EQ
(
13
dest_buf
[
153
]
)
;
EXPECT_EQ
(
10
dest_buf
[
154
]
)
;
FX_Free
(
dest_buf
)
;
}
