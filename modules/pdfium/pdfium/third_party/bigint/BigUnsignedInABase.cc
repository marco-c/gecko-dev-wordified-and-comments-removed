#
include
"
BigUnsignedInABase
.
hh
"
BigUnsignedInABase
:
:
BigUnsignedInABase
(
const
Digit
*
d
Index
l
Base
base
)
:
NumberlikeArray
<
Digit
>
(
d
l
)
base
(
base
)
{
if
(
base
<
2
)
abort
(
)
;
for
(
Index
i
=
0
;
i
<
l
;
i
+
+
)
if
(
blk
[
i
]
>
=
base
)
abort
(
)
;
zapLeadingZeros
(
)
;
}
namespace
{
unsigned
int
bitLen
(
unsigned
int
x
)
{
unsigned
int
len
=
0
;
while
(
x
>
0
)
{
x
>
>
=
1
;
len
+
+
;
}
return
len
;
}
unsigned
int
ceilingDiv
(
unsigned
int
a
unsigned
int
b
)
{
return
(
a
+
b
-
1
)
/
b
;
}
}
BigUnsignedInABase
:
:
BigUnsignedInABase
(
const
BigUnsigned
&
x
Base
base
)
{
if
(
base
<
2
)
abort
(
)
;
this
-
>
base
=
base
;
int
maxBitLenOfX
=
x
.
getLength
(
)
*
BigUnsigned
:
:
N
;
int
minBitsPerDigit
=
bitLen
(
base
)
-
1
;
int
maxDigitLenOfX
=
ceilingDiv
(
maxBitLenOfX
minBitsPerDigit
)
;
len
=
maxDigitLenOfX
;
allocate
(
len
)
;
BigUnsigned
x2
(
x
)
buBase
(
base
)
;
Index
digitNum
=
0
;
while
(
!
x2
.
isZero
(
)
)
{
BigUnsigned
lastDigit
(
x2
)
;
lastDigit
.
divideWithRemainder
(
buBase
x2
)
;
blk
[
digitNum
]
=
lastDigit
.
toUnsignedShort
(
)
;
digitNum
+
+
;
}
len
=
digitNum
;
}
BigUnsignedInABase
:
:
operator
BigUnsigned
(
)
const
{
BigUnsigned
ans
(
0
)
buBase
(
base
)
temp
;
Index
digitNum
=
len
;
while
(
digitNum
>
0
)
{
digitNum
-
-
;
temp
.
multiply
(
ans
buBase
)
;
ans
.
add
(
temp
BigUnsigned
(
blk
[
digitNum
]
)
)
;
}
return
ans
;
}
BigUnsignedInABase
:
:
BigUnsignedInABase
(
const
std
:
:
string
&
s
Base
base
)
{
if
(
base
>
36
)
abort
(
)
;
this
-
>
base
=
base
;
len
=
Index
(
s
.
length
(
)
)
;
allocate
(
len
)
;
Index
digitNum
symbolNumInString
;
for
(
digitNum
=
0
;
digitNum
<
len
;
digitNum
+
+
)
{
symbolNumInString
=
len
-
1
-
digitNum
;
char
theSymbol
=
s
[
symbolNumInString
]
;
if
(
theSymbol
>
=
'
0
'
&
&
theSymbol
<
=
'
9
'
)
blk
[
digitNum
]
=
theSymbol
-
'
0
'
;
else
if
(
theSymbol
>
=
'
A
'
&
&
theSymbol
<
=
'
Z
'
)
blk
[
digitNum
]
=
theSymbol
-
'
A
'
+
10
;
else
if
(
theSymbol
>
=
'
a
'
&
&
theSymbol
<
=
'
z
'
)
blk
[
digitNum
]
=
theSymbol
-
'
a
'
+
10
;
else
abort
(
)
;
if
(
blk
[
digitNum
]
>
=
base
)
abort
(
)
;
}
zapLeadingZeros
(
)
;
}
BigUnsignedInABase
:
:
operator
std
:
:
string
(
)
const
{
if
(
base
>
36
)
abort
(
)
;
if
(
len
=
=
0
)
return
std
:
:
string
(
"
0
"
)
;
char
*
s
=
new
char
[
len
+
1
]
;
s
[
len
]
=
'
\
0
'
;
Index
digitNum
symbolNumInString
;
for
(
symbolNumInString
=
0
;
symbolNumInString
<
len
;
symbolNumInString
+
+
)
{
digitNum
=
len
-
1
-
symbolNumInString
;
Digit
theDigit
=
blk
[
digitNum
]
;
if
(
theDigit
<
10
)
s
[
symbolNumInString
]
=
char
(
'
0
'
+
theDigit
)
;
else
s
[
symbolNumInString
]
=
char
(
'
A
'
+
theDigit
-
10
)
;
}
std
:
:
string
s2
(
s
)
;
delete
[
]
s
;
return
s2
;
}
