#
include
"
BigUnsigned
.
hh
"
BigUnsigned
:
:
BigUnsigned
(
unsigned
long
x
)
{
initFromPrimitive
(
x
)
;
}
BigUnsigned
:
:
BigUnsigned
(
unsigned
int
x
)
{
initFromPrimitive
(
x
)
;
}
BigUnsigned
:
:
BigUnsigned
(
unsigned
short
x
)
{
initFromPrimitive
(
x
)
;
}
BigUnsigned
:
:
BigUnsigned
(
long
x
)
{
initFromSignedPrimitive
(
x
)
;
}
BigUnsigned
:
:
BigUnsigned
(
int
x
)
{
initFromSignedPrimitive
(
x
)
;
}
BigUnsigned
:
:
BigUnsigned
(
short
x
)
{
initFromSignedPrimitive
(
x
)
;
}
unsigned
long
BigUnsigned
:
:
toUnsignedLong
(
)
const
{
return
convertToPrimitive
<
unsigned
long
>
(
)
;
}
unsigned
int
BigUnsigned
:
:
toUnsignedInt
(
)
const
{
return
convertToPrimitive
<
unsigned
int
>
(
)
;
}
unsigned
short
BigUnsigned
:
:
toUnsignedShort
(
)
const
{
return
convertToPrimitive
<
unsigned
short
>
(
)
;
}
long
BigUnsigned
:
:
toLong
(
)
const
{
return
convertToSignedPrimitive
<
long
>
(
)
;
}
int
BigUnsigned
:
:
toInt
(
)
const
{
return
convertToSignedPrimitive
<
int
>
(
)
;
}
short
BigUnsigned
:
:
toShort
(
)
const
{
return
convertToSignedPrimitive
<
short
>
(
)
;
}
void
BigUnsigned
:
:
setBlock
(
Index
i
Blk
newBlock
)
{
if
(
newBlock
=
=
0
)
{
if
(
i
<
len
)
{
blk
[
i
]
=
0
;
zapLeadingZeros
(
)
;
}
}
else
{
if
(
i
>
=
len
)
{
allocateAndCopy
(
i
+
1
)
;
for
(
Index
j
=
len
;
j
<
i
;
j
+
+
)
blk
[
j
]
=
0
;
len
=
i
+
1
;
}
blk
[
i
]
=
newBlock
;
}
}
BigUnsigned
:
:
Index
BigUnsigned
:
:
bitLength
(
)
const
{
if
(
isZero
(
)
)
return
0
;
else
{
Blk
leftmostBlock
=
getBlock
(
len
-
1
)
;
Index
leftmostBlockLen
=
0
;
while
(
leftmostBlock
!
=
0
)
{
leftmostBlock
>
>
=
1
;
leftmostBlockLen
+
+
;
}
return
leftmostBlockLen
+
(
len
-
1
)
*
N
;
}
}
void
BigUnsigned
:
:
setBit
(
Index
bi
bool
newBit
)
{
Index
blockI
=
bi
/
N
;
Blk
block
=
getBlock
(
blockI
)
mask
=
Blk
(
1
)
<
<
(
bi
%
N
)
;
block
=
newBit
?
(
block
|
mask
)
:
(
block
&
~
mask
)
;
setBlock
(
blockI
block
)
;
}
BigUnsigned
:
:
CmpRes
BigUnsigned
:
:
compareTo
(
const
BigUnsigned
&
x
)
const
{
if
(
len
<
x
.
len
)
return
less
;
else
if
(
len
>
x
.
len
)
return
greater
;
else
{
Index
i
=
len
;
while
(
i
>
0
)
{
i
-
-
;
if
(
blk
[
i
]
=
=
x
.
blk
[
i
]
)
continue
;
else
if
(
blk
[
i
]
>
x
.
blk
[
i
]
)
return
greater
;
else
return
less
;
}
return
equal
;
}
}
#
define
DTRT_ALIASED
(
cond
op
)
\
if
(
cond
)
{
\
BigUnsigned
tmpThis
;
\
tmpThis
.
op
;
\
*
this
=
tmpThis
;
\
return
;
\
}
void
BigUnsigned
:
:
add
(
const
BigUnsigned
&
a
const
BigUnsigned
&
b
)
{
DTRT_ALIASED
(
this
=
=
&
a
|
|
this
=
=
&
b
add
(
a
b
)
)
;
if
(
a
.
len
=
=
0
)
{
operator
=
(
b
)
;
return
;
}
else
if
(
b
.
len
=
=
0
)
{
operator
=
(
a
)
;
return
;
}
bool
carryIn
carryOut
;
Blk
temp
;
Index
i
;
const
BigUnsigned
*
a2
*
b2
;
if
(
a
.
len
>
=
b
.
len
)
{
a2
=
&
a
;
b2
=
&
b
;
}
else
{
a2
=
&
b
;
b2
=
&
a
;
}
len
=
a2
-
>
len
+
1
;
allocate
(
len
)
;
for
(
i
=
0
carryIn
=
false
;
i
<
b2
-
>
len
;
i
+
+
)
{
temp
=
a2
-
>
blk
[
i
]
+
b2
-
>
blk
[
i
]
;
carryOut
=
(
temp
<
a2
-
>
blk
[
i
]
)
;
if
(
carryIn
)
{
temp
+
+
;
carryOut
|
=
(
temp
=
=
0
)
;
}
blk
[
i
]
=
temp
;
carryIn
=
carryOut
;
}
for
(
;
i
<
a2
-
>
len
&
&
carryIn
;
i
+
+
)
{
temp
=
a2
-
>
blk
[
i
]
+
1
;
carryIn
=
(
temp
=
=
0
)
;
blk
[
i
]
=
temp
;
}
for
(
;
i
<
a2
-
>
len
;
i
+
+
)
blk
[
i
]
=
a2
-
>
blk
[
i
]
;
if
(
carryIn
)
blk
[
i
]
=
1
;
else
len
-
-
;
}
void
BigUnsigned
:
:
subtract
(
const
BigUnsigned
&
a
const
BigUnsigned
&
b
)
{
DTRT_ALIASED
(
this
=
=
&
a
|
|
this
=
=
&
b
subtract
(
a
b
)
)
;
if
(
b
.
len
=
=
0
)
{
operator
=
(
a
)
;
return
;
}
else
if
(
a
.
len
<
b
.
len
)
abort
(
)
;
bool
borrowIn
borrowOut
;
Blk
temp
;
Index
i
;
len
=
a
.
len
;
allocate
(
len
)
;
for
(
i
=
0
borrowIn
=
false
;
i
<
b
.
len
;
i
+
+
)
{
temp
=
a
.
blk
[
i
]
-
b
.
blk
[
i
]
;
borrowOut
=
(
temp
>
a
.
blk
[
i
]
)
;
if
(
borrowIn
)
{
borrowOut
|
=
(
temp
=
=
0
)
;
temp
-
-
;
}
blk
[
i
]
=
temp
;
borrowIn
=
borrowOut
;
}
for
(
;
i
<
a
.
len
&
&
borrowIn
;
i
+
+
)
{
borrowIn
=
(
a
.
blk
[
i
]
=
=
0
)
;
blk
[
i
]
=
a
.
blk
[
i
]
-
1
;
}
if
(
borrowIn
)
{
len
=
0
;
abort
(
)
;
}
else
for
(
;
i
<
a
.
len
;
i
+
+
)
blk
[
i
]
=
a
.
blk
[
i
]
;
zapLeadingZeros
(
)
;
}
inline
BigUnsigned
:
:
Blk
getShiftedBlock
(
const
BigUnsigned
&
num
BigUnsigned
:
:
Index
x
unsigned
int
y
)
{
BigUnsigned
:
:
Blk
part1
=
(
x
=
=
0
|
|
y
=
=
0
)
?
0
:
(
num
.
blk
[
x
-
1
]
>
>
(
BigUnsigned
:
:
N
-
y
)
)
;
BigUnsigned
:
:
Blk
part2
=
(
x
=
=
num
.
len
)
?
0
:
(
num
.
blk
[
x
]
<
<
y
)
;
return
part1
|
part2
;
}
void
BigUnsigned
:
:
multiply
(
const
BigUnsigned
&
a
const
BigUnsigned
&
b
)
{
DTRT_ALIASED
(
this
=
=
&
a
|
|
this
=
=
&
b
multiply
(
a
b
)
)
;
if
(
a
.
len
=
=
0
|
|
b
.
len
=
=
0
)
{
len
=
0
;
return
;
}
Index
i
j
k
;
unsigned
int
i2
;
Blk
temp
;
bool
carryIn
carryOut
;
len
=
a
.
len
+
b
.
len
;
allocate
(
len
)
;
for
(
i
=
0
;
i
<
len
;
i
+
+
)
blk
[
i
]
=
0
;
for
(
i
=
0
;
i
<
a
.
len
;
i
+
+
)
{
for
(
i2
=
0
;
i2
<
N
;
i2
+
+
)
{
if
(
(
a
.
blk
[
i
]
&
(
Blk
(
1
)
<
<
i2
)
)
=
=
0
)
continue
;
for
(
j
=
0
k
=
i
carryIn
=
false
;
j
<
=
b
.
len
;
j
+
+
k
+
+
)
{
temp
=
blk
[
k
]
+
getShiftedBlock
(
b
j
i2
)
;
carryOut
=
(
temp
<
blk
[
k
]
)
;
if
(
carryIn
)
{
temp
+
+
;
carryOut
|
=
(
temp
=
=
0
)
;
}
blk
[
k
]
=
temp
;
carryIn
=
carryOut
;
}
for
(
;
carryIn
;
k
+
+
)
{
blk
[
k
]
+
+
;
carryIn
=
(
blk
[
k
]
=
=
0
)
;
}
}
}
if
(
blk
[
len
-
1
]
=
=
0
)
len
-
-
;
}
void
BigUnsigned
:
:
divideWithRemainder
(
const
BigUnsigned
&
b
BigUnsigned
&
q
)
{
if
(
this
=
=
&
q
)
abort
(
)
;
if
(
this
=
=
&
b
|
|
&
q
=
=
&
b
)
{
BigUnsigned
tmpB
(
b
)
;
divideWithRemainder
(
tmpB
q
)
;
return
;
}
if
(
b
.
len
=
=
0
)
{
q
.
len
=
0
;
return
;
}
if
(
len
<
b
.
len
)
{
q
.
len
=
0
;
return
;
}
Index
i
j
k
;
unsigned
int
i2
;
Blk
temp
;
bool
borrowIn
borrowOut
;
Index
origLen
=
len
;
allocateAndCopy
(
len
+
1
)
;
len
+
+
;
blk
[
origLen
]
=
0
;
Blk
*
subtractBuf
=
new
Blk
[
len
]
;
q
.
len
=
origLen
-
b
.
len
+
1
;
q
.
allocate
(
q
.
len
)
;
for
(
i
=
0
;
i
<
q
.
len
;
i
+
+
)
q
.
blk
[
i
]
=
0
;
i
=
q
.
len
;
while
(
i
>
0
)
{
i
-
-
;
q
.
blk
[
i
]
=
0
;
i2
=
N
;
while
(
i2
>
0
)
{
i2
-
-
;
for
(
j
=
0
k
=
i
borrowIn
=
false
;
j
<
=
b
.
len
;
j
+
+
k
+
+
)
{
temp
=
blk
[
k
]
-
getShiftedBlock
(
b
j
i2
)
;
borrowOut
=
(
temp
>
blk
[
k
]
)
;
if
(
borrowIn
)
{
borrowOut
|
=
(
temp
=
=
0
)
;
temp
-
-
;
}
subtractBuf
[
k
]
=
temp
;
borrowIn
=
borrowOut
;
}
for
(
;
k
<
origLen
&
&
borrowIn
;
k
+
+
)
{
borrowIn
=
(
blk
[
k
]
=
=
0
)
;
subtractBuf
[
k
]
=
blk
[
k
]
-
1
;
}
if
(
!
borrowIn
)
{
q
.
blk
[
i
]
|
=
(
Blk
(
1
)
<
<
i2
)
;
while
(
k
>
i
)
{
k
-
-
;
blk
[
k
]
=
subtractBuf
[
k
]
;
}
}
}
}
if
(
q
.
blk
[
q
.
len
-
1
]
=
=
0
)
q
.
len
-
-
;
zapLeadingZeros
(
)
;
delete
[
]
subtractBuf
;
}
void
BigUnsigned
:
:
bitAnd
(
const
BigUnsigned
&
a
const
BigUnsigned
&
b
)
{
DTRT_ALIASED
(
this
=
=
&
a
|
|
this
=
=
&
b
bitAnd
(
a
b
)
)
;
len
=
(
a
.
len
>
=
b
.
len
)
?
b
.
len
:
a
.
len
;
allocate
(
len
)
;
Index
i
;
for
(
i
=
0
;
i
<
len
;
i
+
+
)
blk
[
i
]
=
a
.
blk
[
i
]
&
b
.
blk
[
i
]
;
zapLeadingZeros
(
)
;
}
void
BigUnsigned
:
:
bitOr
(
const
BigUnsigned
&
a
const
BigUnsigned
&
b
)
{
DTRT_ALIASED
(
this
=
=
&
a
|
|
this
=
=
&
b
bitOr
(
a
b
)
)
;
Index
i
;
const
BigUnsigned
*
a2
*
b2
;
if
(
a
.
len
>
=
b
.
len
)
{
a2
=
&
a
;
b2
=
&
b
;
}
else
{
a2
=
&
b
;
b2
=
&
a
;
}
allocate
(
a2
-
>
len
)
;
for
(
i
=
0
;
i
<
b2
-
>
len
;
i
+
+
)
blk
[
i
]
=
a2
-
>
blk
[
i
]
|
b2
-
>
blk
[
i
]
;
for
(
;
i
<
a2
-
>
len
;
i
+
+
)
blk
[
i
]
=
a2
-
>
blk
[
i
]
;
len
=
a2
-
>
len
;
}
void
BigUnsigned
:
:
bitXor
(
const
BigUnsigned
&
a
const
BigUnsigned
&
b
)
{
DTRT_ALIASED
(
this
=
=
&
a
|
|
this
=
=
&
b
bitXor
(
a
b
)
)
;
Index
i
;
const
BigUnsigned
*
a2
*
b2
;
if
(
a
.
len
>
=
b
.
len
)
{
a2
=
&
a
;
b2
=
&
b
;
}
else
{
a2
=
&
b
;
b2
=
&
a
;
}
allocate
(
a2
-
>
len
)
;
for
(
i
=
0
;
i
<
b2
-
>
len
;
i
+
+
)
blk
[
i
]
=
a2
-
>
blk
[
i
]
^
b2
-
>
blk
[
i
]
;
for
(
;
i
<
a2
-
>
len
;
i
+
+
)
blk
[
i
]
=
a2
-
>
blk
[
i
]
;
len
=
a2
-
>
len
;
zapLeadingZeros
(
)
;
}
void
BigUnsigned
:
:
bitShiftLeft
(
const
BigUnsigned
&
a
int
b
)
{
DTRT_ALIASED
(
this
=
=
&
a
bitShiftLeft
(
a
b
)
)
;
if
(
b
<
0
)
{
if
(
b
<
<
1
=
=
0
)
abort
(
)
;
else
{
bitShiftRight
(
a
-
b
)
;
return
;
}
}
Index
shiftBlocks
=
b
/
N
;
unsigned
int
shiftBits
=
b
%
N
;
len
=
a
.
len
+
shiftBlocks
+
1
;
allocate
(
len
)
;
Index
i
j
;
for
(
i
=
0
;
i
<
shiftBlocks
;
i
+
+
)
blk
[
i
]
=
0
;
for
(
j
=
0
i
=
shiftBlocks
;
j
<
=
a
.
len
;
j
+
+
i
+
+
)
blk
[
i
]
=
getShiftedBlock
(
a
j
shiftBits
)
;
if
(
blk
[
len
-
1
]
=
=
0
)
len
-
-
;
}
void
BigUnsigned
:
:
bitShiftRight
(
const
BigUnsigned
&
a
int
b
)
{
DTRT_ALIASED
(
this
=
=
&
a
bitShiftRight
(
a
b
)
)
;
if
(
b
<
0
)
{
if
(
b
<
<
1
=
=
0
)
abort
(
)
;
else
{
bitShiftLeft
(
a
-
b
)
;
return
;
}
}
Index
rightShiftBlocks
=
(
b
+
N
-
1
)
/
N
;
unsigned
int
leftShiftBits
=
N
*
rightShiftBlocks
-
b
;
if
(
rightShiftBlocks
>
=
a
.
len
+
1
)
{
len
=
0
;
return
;
}
len
=
a
.
len
+
1
-
rightShiftBlocks
;
allocate
(
len
)
;
Index
i
j
;
for
(
j
=
rightShiftBlocks
i
=
0
;
j
<
=
a
.
len
;
j
+
+
i
+
+
)
blk
[
i
]
=
getShiftedBlock
(
a
j
leftShiftBits
)
;
if
(
blk
[
len
-
1
]
=
=
0
)
len
-
-
;
}
void
BigUnsigned
:
:
operator
+
+
(
)
{
Index
i
;
bool
carry
=
true
;
for
(
i
=
0
;
i
<
len
&
&
carry
;
i
+
+
)
{
blk
[
i
]
+
+
;
carry
=
(
blk
[
i
]
=
=
0
)
;
}
if
(
carry
)
{
allocateAndCopy
(
len
+
1
)
;
len
+
+
;
blk
[
i
]
=
1
;
}
}
void
BigUnsigned
:
:
operator
+
+
(
int
)
{
operator
+
+
(
)
;
}
void
BigUnsigned
:
:
operator
-
-
(
)
{
if
(
len
=
=
0
)
abort
(
)
;
Index
i
;
bool
borrow
=
true
;
for
(
i
=
0
;
borrow
;
i
+
+
)
{
borrow
=
(
blk
[
i
]
=
=
0
)
;
blk
[
i
]
-
-
;
}
if
(
blk
[
len
-
1
]
=
=
0
)
len
-
-
;
}
void
BigUnsigned
:
:
operator
-
-
(
int
)
{
operator
-
-
(
)
;
}
