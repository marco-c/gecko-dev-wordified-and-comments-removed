#
include
"
BigInteger
.
hh
"
void
BigInteger
:
:
operator
=
(
const
BigInteger
&
x
)
{
if
(
this
=
=
&
x
)
return
;
sign
=
x
.
sign
;
mag
=
x
.
mag
;
}
BigInteger
:
:
BigInteger
(
const
Blk
*
b
Index
blen
Sign
s
)
:
mag
(
b
blen
)
{
switch
(
s
)
{
case
zero
:
if
(
!
mag
.
isZero
(
)
)
abort
(
)
;
sign
=
zero
;
break
;
case
positive
:
case
negative
:
sign
=
mag
.
isZero
(
)
?
zero
:
s
;
break
;
default
:
abort
(
)
;
}
}
BigInteger
:
:
BigInteger
(
const
BigUnsigned
&
x
Sign
s
)
:
mag
(
x
)
{
switch
(
s
)
{
case
zero
:
if
(
!
mag
.
isZero
(
)
)
abort
(
)
;
sign
=
zero
;
break
;
case
positive
:
case
negative
:
sign
=
mag
.
isZero
(
)
?
zero
:
s
;
break
;
default
:
abort
(
)
;
}
}
BigInteger
:
:
BigInteger
(
unsigned
long
x
)
:
mag
(
x
)
{
sign
=
mag
.
isZero
(
)
?
zero
:
positive
;
}
BigInteger
:
:
BigInteger
(
unsigned
int
x
)
:
mag
(
x
)
{
sign
=
mag
.
isZero
(
)
?
zero
:
positive
;
}
BigInteger
:
:
BigInteger
(
unsigned
short
x
)
:
mag
(
x
)
{
sign
=
mag
.
isZero
(
)
?
zero
:
positive
;
}
namespace
{
template
<
class
X
class
UX
>
BigInteger
:
:
Blk
magOf
(
X
x
)
{
return
BigInteger
:
:
Blk
(
x
<
0
?
UX
(
-
x
)
:
x
)
;
}
template
<
class
X
>
BigInteger
:
:
Sign
signOf
(
X
x
)
{
return
(
x
=
=
0
)
?
BigInteger
:
:
zero
:
(
x
>
0
)
?
BigInteger
:
:
positive
:
BigInteger
:
:
negative
;
}
}
BigInteger
:
:
BigInteger
(
long
x
)
:
sign
(
signOf
(
x
)
)
mag
(
magOf
<
long
unsigned
long
>
(
x
)
)
{
}
BigInteger
:
:
BigInteger
(
int
x
)
:
sign
(
signOf
(
x
)
)
mag
(
magOf
<
int
unsigned
int
>
(
x
)
)
{
}
BigInteger
:
:
BigInteger
(
short
x
)
:
sign
(
signOf
(
x
)
)
mag
(
magOf
<
short
unsigned
short
>
(
x
)
)
{
}
template
<
class
X
>
inline
X
convertBigUnsignedToPrimitiveAccess
(
const
BigUnsigned
&
a
)
{
return
a
.
convertToPrimitive
<
X
>
(
)
;
}
template
<
class
X
>
X
BigInteger
:
:
convertToUnsignedPrimitive
(
)
const
{
if
(
sign
=
=
negative
)
abort
(
)
;
else
return
convertBigUnsignedToPrimitiveAccess
<
X
>
(
mag
)
;
}
template
<
class
X
class
UX
>
X
BigInteger
:
:
convertToSignedPrimitive
(
)
const
{
if
(
sign
=
=
zero
)
return
0
;
else
if
(
mag
.
getLength
(
)
=
=
1
)
{
Blk
b
=
mag
.
getBlock
(
0
)
;
if
(
sign
=
=
positive
)
{
X
x
=
X
(
b
)
;
if
(
x
>
=
0
&
&
Blk
(
x
)
=
=
b
)
return
x
;
}
else
{
X
x
=
-
X
(
b
)
;
if
(
x
<
0
&
&
Blk
(
UX
(
-
x
)
)
=
=
b
)
return
x
;
}
}
abort
(
)
;
}
unsigned
long
BigInteger
:
:
toUnsignedLong
(
)
const
{
return
convertToUnsignedPrimitive
<
unsigned
long
>
(
)
;
}
unsigned
int
BigInteger
:
:
toUnsignedInt
(
)
const
{
return
convertToUnsignedPrimitive
<
unsigned
int
>
(
)
;
}
unsigned
short
BigInteger
:
:
toUnsignedShort
(
)
const
{
return
convertToUnsignedPrimitive
<
unsigned
short
>
(
)
;
}
long
BigInteger
:
:
toLong
(
)
const
{
return
convertToSignedPrimitive
<
long
unsigned
long
>
(
)
;
}
int
BigInteger
:
:
toInt
(
)
const
{
return
convertToSignedPrimitive
<
int
unsigned
int
>
(
)
;
}
short
BigInteger
:
:
toShort
(
)
const
{
return
convertToSignedPrimitive
<
short
unsigned
short
>
(
)
;
}
BigInteger
:
:
CmpRes
BigInteger
:
:
compareTo
(
const
BigInteger
&
x
)
const
{
if
(
sign
<
x
.
sign
)
return
less
;
else
if
(
sign
>
x
.
sign
)
return
greater
;
else
switch
(
sign
)
{
case
zero
:
return
equal
;
case
positive
:
return
mag
.
compareTo
(
x
.
mag
)
;
case
negative
:
return
CmpRes
(
-
mag
.
compareTo
(
x
.
mag
)
)
;
default
:
abort
(
)
;
}
}
#
define
DTRT_ALIASED
(
cond
op
)
\
if
(
cond
)
{
\
BigInteger
tmpThis
;
\
tmpThis
.
op
;
\
*
this
=
tmpThis
;
\
return
;
\
}
void
BigInteger
:
:
add
(
const
BigInteger
&
a
const
BigInteger
&
b
)
{
DTRT_ALIASED
(
this
=
=
&
a
|
|
this
=
=
&
b
add
(
a
b
)
)
;
if
(
a
.
sign
=
=
zero
)
operator
=
(
b
)
;
else
if
(
b
.
sign
=
=
zero
)
operator
=
(
a
)
;
else
if
(
a
.
sign
=
=
b
.
sign
)
{
sign
=
a
.
sign
;
mag
.
add
(
a
.
mag
b
.
mag
)
;
}
else
{
switch
(
a
.
mag
.
compareTo
(
b
.
mag
)
)
{
case
equal
:
mag
=
0
;
sign
=
zero
;
break
;
case
greater
:
sign
=
a
.
sign
;
mag
.
subtract
(
a
.
mag
b
.
mag
)
;
break
;
case
less
:
sign
=
b
.
sign
;
mag
.
subtract
(
b
.
mag
a
.
mag
)
;
break
;
}
}
}
void
BigInteger
:
:
subtract
(
const
BigInteger
&
a
const
BigInteger
&
b
)
{
DTRT_ALIASED
(
this
=
=
&
a
|
|
this
=
=
&
b
subtract
(
a
b
)
)
;
if
(
a
.
sign
=
=
zero
)
{
mag
=
b
.
mag
;
sign
=
Sign
(
-
b
.
sign
)
;
}
else
if
(
b
.
sign
=
=
zero
)
operator
=
(
a
)
;
else
if
(
a
.
sign
!
=
b
.
sign
)
{
sign
=
a
.
sign
;
mag
.
add
(
a
.
mag
b
.
mag
)
;
}
else
{
switch
(
a
.
mag
.
compareTo
(
b
.
mag
)
)
{
case
equal
:
mag
=
0
;
sign
=
zero
;
break
;
case
greater
:
sign
=
a
.
sign
;
mag
.
subtract
(
a
.
mag
b
.
mag
)
;
break
;
case
less
:
sign
=
Sign
(
-
b
.
sign
)
;
mag
.
subtract
(
b
.
mag
a
.
mag
)
;
break
;
}
}
}
void
BigInteger
:
:
multiply
(
const
BigInteger
&
a
const
BigInteger
&
b
)
{
DTRT_ALIASED
(
this
=
=
&
a
|
|
this
=
=
&
b
multiply
(
a
b
)
)
;
if
(
a
.
sign
=
=
zero
|
|
b
.
sign
=
=
zero
)
{
sign
=
zero
;
mag
=
0
;
return
;
}
sign
=
(
a
.
sign
=
=
b
.
sign
)
?
positive
:
negative
;
mag
.
multiply
(
a
.
mag
b
.
mag
)
;
}
void
BigInteger
:
:
divideWithRemainder
(
const
BigInteger
&
b
BigInteger
&
q
)
{
if
(
this
=
=
&
q
)
abort
(
)
;
if
(
this
=
=
&
b
|
|
&
q
=
=
&
b
)
{
BigInteger
tmpB
(
b
)
;
divideWithRemainder
(
tmpB
q
)
;
return
;
}
if
(
b
.
sign
=
=
zero
)
{
q
.
mag
=
0
;
q
.
sign
=
zero
;
return
;
}
if
(
sign
=
=
zero
)
{
q
.
mag
=
0
;
q
.
sign
=
zero
;
return
;
}
if
(
sign
=
=
b
.
sign
)
{
q
.
sign
=
positive
;
}
else
{
q
.
sign
=
negative
;
mag
-
-
;
}
mag
.
divideWithRemainder
(
b
.
mag
q
.
mag
)
;
if
(
sign
!
=
b
.
sign
)
{
q
.
mag
+
+
;
mag
.
subtract
(
b
.
mag
mag
)
;
mag
-
-
;
}
sign
=
b
.
sign
;
if
(
mag
.
isZero
(
)
)
sign
=
zero
;
if
(
q
.
mag
.
isZero
(
)
)
q
.
sign
=
zero
;
}
void
BigInteger
:
:
negate
(
const
BigInteger
&
a
)
{
DTRT_ALIASED
(
this
=
=
&
a
negate
(
a
)
)
;
mag
=
a
.
mag
;
sign
=
Sign
(
-
a
.
sign
)
;
}
void
BigInteger
:
:
operator
+
+
(
)
{
if
(
sign
=
=
negative
)
{
mag
-
-
;
if
(
mag
=
=
0
)
sign
=
zero
;
}
else
{
mag
+
+
;
sign
=
positive
;
}
}
void
BigInteger
:
:
operator
+
+
(
int
)
{
operator
+
+
(
)
;
}
void
BigInteger
:
:
operator
-
-
(
)
{
if
(
sign
=
=
positive
)
{
mag
-
-
;
if
(
mag
=
=
0
)
sign
=
zero
;
}
else
{
mag
+
+
;
sign
=
negative
;
}
}
void
BigInteger
:
:
operator
-
-
(
int
)
{
operator
-
-
(
)
;
}
