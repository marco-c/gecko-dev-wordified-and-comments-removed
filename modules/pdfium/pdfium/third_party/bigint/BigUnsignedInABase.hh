#
ifndef
BIGUNSIGNEDINABASE_H
#
define
BIGUNSIGNEDINABASE_H
#
include
"
NumberlikeArray
.
hh
"
#
include
"
BigUnsigned
.
hh
"
#
include
<
string
>
class
BigUnsignedInABase
:
protected
NumberlikeArray
<
unsigned
short
>
{
public
:
typedef
unsigned
short
Digit
;
typedef
Digit
Base
;
protected
:
Base
base
;
BigUnsignedInABase
(
int
Index
c
)
:
NumberlikeArray
<
Digit
>
(
0
c
)
{
}
void
zapLeadingZeros
(
)
{
while
(
len
>
0
&
&
blk
[
len
-
1
]
=
=
0
)
len
-
-
;
}
public
:
BigUnsignedInABase
(
)
:
NumberlikeArray
<
Digit
>
(
)
base
(
2
)
{
}
BigUnsignedInABase
(
const
BigUnsignedInABase
&
x
)
:
NumberlikeArray
<
Digit
>
(
x
)
base
(
x
.
base
)
{
}
void
operator
=
(
const
BigUnsignedInABase
&
x
)
{
NumberlikeArray
<
Digit
>
:
:
operator
=
(
x
)
;
base
=
x
.
base
;
}
BigUnsignedInABase
(
const
Digit
*
d
Index
l
Base
base
)
;
~
BigUnsignedInABase
(
)
{
}
BigUnsignedInABase
(
const
BigUnsigned
&
x
Base
base
)
;
operator
BigUnsigned
(
)
const
;
operator
std
:
:
string
(
)
const
;
BigUnsignedInABase
(
const
std
:
:
string
&
s
Base
base
)
;
public
:
Base
getBase
(
)
const
{
return
base
;
}
using
NumberlikeArray
<
Digit
>
:
:
getCapacity
;
using
NumberlikeArray
<
Digit
>
:
:
getLength
;
Digit
getDigit
(
Index
i
)
const
{
return
i
>
=
len
?
0
:
blk
[
i
]
;
}
bool
isZero
(
)
const
{
return
NumberlikeArray
<
Digit
>
:
:
isEmpty
(
)
;
}
bool
operator
=
=
(
const
BigUnsignedInABase
&
x
)
const
{
return
base
=
=
x
.
base
&
&
NumberlikeArray
<
Digit
>
:
:
operator
=
=
(
x
)
;
}
bool
operator
!
=
(
const
BigUnsignedInABase
&
x
)
const
{
return
!
operator
=
=
(
x
)
;
}
}
;
#
endif
