#
include
"
lcms2_internal
.
h
"
cmsHTRANSFORM
_cmsChain2Lab
(
cmsContext
ContextID
cmsUInt32Number
nProfiles
cmsUInt32Number
InputFormat
cmsUInt32Number
OutputFormat
const
cmsUInt32Number
Intents
[
]
const
cmsHPROFILE
hProfiles
[
]
const
cmsBool
BPC
[
]
const
cmsFloat64Number
AdaptationStates
[
]
cmsUInt32Number
dwFlags
)
{
cmsHTRANSFORM
xform
;
cmsHPROFILE
hLab
;
cmsHPROFILE
ProfileList
[
256
]
;
cmsBool
BPCList
[
256
]
;
cmsFloat64Number
AdaptationList
[
256
]
;
cmsUInt32Number
IntentList
[
256
]
;
cmsUInt32Number
i
;
if
(
nProfiles
>
254
)
return
NULL
;
hLab
=
cmsCreateLab4ProfileTHR
(
ContextID
NULL
)
;
if
(
hLab
=
=
NULL
)
return
NULL
;
for
(
i
=
0
;
i
<
nProfiles
;
i
+
+
)
{
ProfileList
[
i
]
=
hProfiles
[
i
]
;
BPCList
[
i
]
=
BPC
[
i
]
;
AdaptationList
[
i
]
=
AdaptationStates
[
i
]
;
IntentList
[
i
]
=
Intents
[
i
]
;
}
ProfileList
[
nProfiles
]
=
hLab
;
BPCList
[
nProfiles
]
=
0
;
AdaptationList
[
nProfiles
]
=
1
.
0
;
IntentList
[
nProfiles
]
=
INTENT_RELATIVE_COLORIMETRIC
;
xform
=
cmsCreateExtendedTransform
(
ContextID
nProfiles
+
1
ProfileList
BPCList
IntentList
AdaptationList
NULL
0
InputFormat
OutputFormat
dwFlags
)
;
cmsCloseProfile
(
hLab
)
;
return
xform
;
}
static
cmsToneCurve
*
ComputeKToLstar
(
cmsContext
ContextID
cmsUInt32Number
nPoints
cmsUInt32Number
nProfiles
const
cmsUInt32Number
Intents
[
]
const
cmsHPROFILE
hProfiles
[
]
const
cmsBool
BPC
[
]
const
cmsFloat64Number
AdaptationStates
[
]
cmsUInt32Number
dwFlags
)
{
cmsToneCurve
*
out
=
NULL
;
cmsUInt32Number
i
;
cmsHTRANSFORM
xform
;
cmsCIELab
Lab
;
cmsFloat32Number
cmyk
[
4
]
;
cmsFloat32Number
*
SampledPoints
;
xform
=
_cmsChain2Lab
(
ContextID
nProfiles
TYPE_CMYK_FLT
TYPE_Lab_DBL
Intents
hProfiles
BPC
AdaptationStates
dwFlags
)
;
if
(
xform
=
=
NULL
)
return
NULL
;
SampledPoints
=
(
cmsFloat32Number
*
)
_cmsCalloc
(
ContextID
nPoints
sizeof
(
cmsFloat32Number
)
)
;
if
(
SampledPoints
=
=
NULL
)
goto
Error
;
for
(
i
=
0
;
i
<
nPoints
;
i
+
+
)
{
cmyk
[
0
]
=
0
;
cmyk
[
1
]
=
0
;
cmyk
[
2
]
=
0
;
cmyk
[
3
]
=
(
cmsFloat32Number
)
(
(
i
*
100
.
0
)
/
(
nPoints
-
1
)
)
;
cmsDoTransform
(
xform
cmyk
&
Lab
1
)
;
SampledPoints
[
i
]
=
(
cmsFloat32Number
)
(
1
.
0
-
Lab
.
L
/
100
.
0
)
;
}
out
=
cmsBuildTabulatedToneCurveFloat
(
ContextID
nPoints
SampledPoints
)
;
Error
:
cmsDeleteTransform
(
xform
)
;
if
(
SampledPoints
)
_cmsFree
(
ContextID
SampledPoints
)
;
return
out
;
}
cmsToneCurve
*
_cmsBuildKToneCurve
(
cmsContext
ContextID
cmsUInt32Number
nPoints
cmsUInt32Number
nProfiles
const
cmsUInt32Number
Intents
[
]
const
cmsHPROFILE
hProfiles
[
]
const
cmsBool
BPC
[
]
const
cmsFloat64Number
AdaptationStates
[
]
cmsUInt32Number
dwFlags
)
{
cmsToneCurve
*
in
*
out
*
KTone
;
if
(
cmsGetColorSpace
(
hProfiles
[
0
]
)
!
=
cmsSigCmykData
|
|
cmsGetColorSpace
(
hProfiles
[
nProfiles
-
1
]
)
!
=
cmsSigCmykData
)
return
NULL
;
if
(
cmsGetDeviceClass
(
hProfiles
[
nProfiles
-
1
]
)
!
=
cmsSigOutputClass
)
return
NULL
;
in
=
ComputeKToLstar
(
ContextID
nPoints
nProfiles
-
1
Intents
hProfiles
BPC
AdaptationStates
dwFlags
)
;
if
(
in
=
=
NULL
)
return
NULL
;
out
=
ComputeKToLstar
(
ContextID
nPoints
1
Intents
+
(
nProfiles
-
1
)
&
hProfiles
[
nProfiles
-
1
]
BPC
+
(
nProfiles
-
1
)
AdaptationStates
+
(
nProfiles
-
1
)
dwFlags
)
;
if
(
out
=
=
NULL
)
{
cmsFreeToneCurve
(
in
)
;
return
NULL
;
}
KTone
=
cmsJoinToneCurve
(
ContextID
in
out
nPoints
)
;
cmsFreeToneCurve
(
in
)
;
cmsFreeToneCurve
(
out
)
;
if
(
KTone
=
=
NULL
)
return
NULL
;
if
(
!
cmsIsToneCurveMonotonic
(
KTone
)
)
{
cmsFreeToneCurve
(
KTone
)
;
return
NULL
;
}
return
KTone
;
}
typedef
struct
{
cmsHTRANSFORM
hInput
;
cmsHTRANSFORM
hForward
hReverse
;
cmsFloat64Number
Thereshold
;
}
GAMUTCHAIN
;
#
define
ERR_THERESHOLD
5
static
int
GamutSampler
(
register
const
cmsUInt16Number
In
[
]
register
cmsUInt16Number
Out
[
]
register
void
*
Cargo
)
{
GAMUTCHAIN
*
t
=
(
GAMUTCHAIN
*
)
Cargo
;
cmsCIELab
LabIn1
LabOut1
;
cmsCIELab
LabIn2
LabOut2
;
cmsUInt16Number
Proof
[
cmsMAXCHANNELS
]
Proof2
[
cmsMAXCHANNELS
]
;
cmsFloat64Number
dE1
dE2
ErrorRatio
;
ErrorRatio
=
1
.
0
;
cmsDoTransform
(
t
-
>
hInput
In
&
LabIn1
1
)
;
cmsDoTransform
(
t
-
>
hForward
&
LabIn1
Proof
1
)
;
cmsDoTransform
(
t
-
>
hReverse
Proof
&
LabOut1
1
)
;
memmove
(
&
LabIn2
&
LabOut1
sizeof
(
cmsCIELab
)
)
;
cmsDoTransform
(
t
-
>
hForward
&
LabOut1
Proof2
1
)
;
cmsDoTransform
(
t
-
>
hReverse
Proof2
&
LabOut2
1
)
;
dE1
=
cmsDeltaE
(
&
LabIn1
&
LabOut1
)
;
dE2
=
cmsDeltaE
(
&
LabIn2
&
LabOut2
)
;
if
(
dE1
<
t
-
>
Thereshold
&
&
dE2
<
t
-
>
Thereshold
)
Out
[
0
]
=
0
;
else
{
if
(
dE1
<
t
-
>
Thereshold
&
&
dE2
>
t
-
>
Thereshold
)
Out
[
0
]
=
0
;
else
if
(
dE1
>
t
-
>
Thereshold
&
&
dE2
<
t
-
>
Thereshold
)
Out
[
0
]
=
(
cmsUInt16Number
)
_cmsQuickFloor
(
(
dE1
-
t
-
>
Thereshold
)
+
.
5
)
;
else
{
if
(
dE2
=
=
0
.
0
)
ErrorRatio
=
dE1
;
else
ErrorRatio
=
dE1
/
dE2
;
if
(
ErrorRatio
>
t
-
>
Thereshold
)
Out
[
0
]
=
(
cmsUInt16Number
)
_cmsQuickFloor
(
(
ErrorRatio
-
t
-
>
Thereshold
)
+
.
5
)
;
else
Out
[
0
]
=
0
;
}
}
return
TRUE
;
}
cmsPipeline
*
_cmsCreateGamutCheckPipeline
(
cmsContext
ContextID
cmsHPROFILE
hProfiles
[
]
cmsBool
BPC
[
]
cmsUInt32Number
Intents
[
]
cmsFloat64Number
AdaptationStates
[
]
cmsUInt32Number
nGamutPCSposition
cmsHPROFILE
hGamut
)
{
cmsHPROFILE
hLab
;
cmsPipeline
*
Gamut
;
cmsStage
*
CLUT
;
cmsUInt32Number
dwFormat
;
GAMUTCHAIN
Chain
;
int
nChannels
nGridpoints
;
cmsColorSpaceSignature
ColorSpace
;
cmsUInt32Number
i
;
cmsHPROFILE
ProfileList
[
256
]
;
cmsBool
BPCList
[
256
]
;
cmsFloat64Number
AdaptationList
[
256
]
;
cmsUInt32Number
IntentList
[
256
]
;
memset
(
&
Chain
0
sizeof
(
GAMUTCHAIN
)
)
;
if
(
nGamutPCSposition
<
=
0
|
|
nGamutPCSposition
>
255
)
{
cmsSignalError
(
ContextID
cmsERROR_RANGE
"
Wrong
position
of
PCS
.
1
.
.
255
expected
%
d
found
.
"
nGamutPCSposition
)
;
return
NULL
;
}
hLab
=
cmsCreateLab4ProfileTHR
(
ContextID
NULL
)
;
if
(
hLab
=
=
NULL
)
return
NULL
;
if
(
cmsIsMatrixShaper
(
hGamut
)
)
{
Chain
.
Thereshold
=
1
.
0
;
}
else
{
Chain
.
Thereshold
=
ERR_THERESHOLD
;
}
for
(
i
=
0
;
i
<
nGamutPCSposition
;
i
+
+
)
{
ProfileList
[
i
]
=
hProfiles
[
i
]
;
BPCList
[
i
]
=
BPC
[
i
]
;
AdaptationList
[
i
]
=
AdaptationStates
[
i
]
;
IntentList
[
i
]
=
Intents
[
i
]
;
}
ProfileList
[
nGamutPCSposition
]
=
hLab
;
BPCList
[
nGamutPCSposition
]
=
0
;
AdaptationList
[
nGamutPCSposition
]
=
1
.
0
;
IntentList
[
nGamutPCSposition
]
=
INTENT_RELATIVE_COLORIMETRIC
;
ColorSpace
=
cmsGetColorSpace
(
hGamut
)
;
nChannels
=
cmsChannelsOf
(
ColorSpace
)
;
nGridpoints
=
_cmsReasonableGridpointsByColorspace
(
ColorSpace
cmsFLAGS_HIGHRESPRECALC
)
;
dwFormat
=
(
CHANNELS_SH
(
nChannels
)
|
BYTES_SH
(
2
)
)
;
Chain
.
hInput
=
cmsCreateExtendedTransform
(
ContextID
nGamutPCSposition
+
1
ProfileList
BPCList
IntentList
AdaptationList
NULL
0
dwFormat
TYPE_Lab_DBL
cmsFLAGS_NOCACHE
)
;
dwFormat
=
(
CHANNELS_SH
(
nChannels
)
|
BYTES_SH
(
2
)
)
;
Chain
.
hForward
=
cmsCreateTransformTHR
(
ContextID
hLab
TYPE_Lab_DBL
hGamut
dwFormat
INTENT_RELATIVE_COLORIMETRIC
cmsFLAGS_NOCACHE
)
;
Chain
.
hReverse
=
cmsCreateTransformTHR
(
ContextID
hGamut
dwFormat
hLab
TYPE_Lab_DBL
INTENT_RELATIVE_COLORIMETRIC
cmsFLAGS_NOCACHE
)
;
if
(
Chain
.
hInput
&
&
Chain
.
hForward
&
&
Chain
.
hReverse
)
{
Gamut
=
cmsPipelineAlloc
(
ContextID
3
1
)
;
if
(
Gamut
!
=
NULL
)
{
CLUT
=
cmsStageAllocCLut16bit
(
ContextID
nGridpoints
nChannels
1
NULL
)
;
if
(
!
cmsPipelineInsertStage
(
Gamut
cmsAT_BEGIN
CLUT
)
)
{
cmsPipelineFree
(
Gamut
)
;
Gamut
=
NULL
;
}
else
{
cmsStageSampleCLut16bit
(
CLUT
GamutSampler
(
void
*
)
&
Chain
0
)
;
}
}
}
else
Gamut
=
NULL
;
if
(
Chain
.
hInput
)
cmsDeleteTransform
(
Chain
.
hInput
)
;
if
(
Chain
.
hForward
)
cmsDeleteTransform
(
Chain
.
hForward
)
;
if
(
Chain
.
hReverse
)
cmsDeleteTransform
(
Chain
.
hReverse
)
;
if
(
hLab
)
cmsCloseProfile
(
hLab
)
;
return
Gamut
;
}
typedef
struct
{
cmsUInt32Number
nOutputChans
;
cmsHTRANSFORM
hRoundTrip
;
cmsFloat32Number
MaxTAC
;
cmsFloat32Number
MaxInput
[
cmsMAXCHANNELS
]
;
}
cmsTACestimator
;
static
int
EstimateTAC
(
register
const
cmsUInt16Number
In
[
]
register
cmsUInt16Number
Out
[
]
register
void
*
Cargo
)
{
cmsTACestimator
*
bp
=
(
cmsTACestimator
*
)
Cargo
;
cmsFloat32Number
RoundTrip
[
cmsMAXCHANNELS
]
;
cmsUInt32Number
i
;
cmsFloat32Number
Sum
;
cmsDoTransform
(
bp
-
>
hRoundTrip
In
RoundTrip
1
)
;
for
(
Sum
=
0
i
=
0
;
i
<
bp
-
>
nOutputChans
;
i
+
+
)
Sum
+
=
RoundTrip
[
i
]
;
if
(
Sum
>
bp
-
>
MaxTAC
)
{
bp
-
>
MaxTAC
=
Sum
;
for
(
i
=
0
;
i
<
bp
-
>
nOutputChans
;
i
+
+
)
{
bp
-
>
MaxInput
[
i
]
=
In
[
i
]
;
}
}
return
TRUE
;
cmsUNUSED_PARAMETER
(
Out
)
;
}
cmsFloat64Number
CMSEXPORT
cmsDetectTAC
(
cmsHPROFILE
hProfile
)
{
cmsTACestimator
bp
;
cmsUInt32Number
dwFormatter
;
cmsUInt32Number
GridPoints
[
MAX_INPUT_DIMENSIONS
]
;
cmsHPROFILE
hLab
;
cmsContext
ContextID
=
cmsGetProfileContextID
(
hProfile
)
;
if
(
cmsGetDeviceClass
(
hProfile
)
!
=
cmsSigOutputClass
)
{
return
0
;
}
dwFormatter
=
cmsFormatterForColorspaceOfProfile
(
hProfile
4
TRUE
)
;
bp
.
nOutputChans
=
T_CHANNELS
(
dwFormatter
)
;
bp
.
MaxTAC
=
0
;
if
(
bp
.
nOutputChans
>
=
cmsMAXCHANNELS
)
return
0
;
hLab
=
cmsCreateLab4ProfileTHR
(
ContextID
NULL
)
;
if
(
hLab
=
=
NULL
)
return
0
;
bp
.
hRoundTrip
=
cmsCreateTransformTHR
(
ContextID
hLab
TYPE_Lab_16
hProfile
dwFormatter
INTENT_PERCEPTUAL
cmsFLAGS_NOOPTIMIZE
|
cmsFLAGS_NOCACHE
)
;
cmsCloseProfile
(
hLab
)
;
if
(
bp
.
hRoundTrip
=
=
NULL
)
return
0
;
GridPoints
[
0
]
=
6
;
GridPoints
[
1
]
=
74
;
GridPoints
[
2
]
=
74
;
if
(
!
cmsSliceSpace16
(
3
GridPoints
EstimateTAC
&
bp
)
)
{
bp
.
MaxTAC
=
0
;
}
cmsDeleteTransform
(
bp
.
hRoundTrip
)
;
return
bp
.
MaxTAC
;
}
cmsBool
CMSEXPORT
cmsDesaturateLab
(
cmsCIELab
*
Lab
double
amax
double
amin
double
bmax
double
bmin
)
{
if
(
Lab
-
>
L
<
0
)
{
Lab
-
>
L
=
Lab
-
>
a
=
Lab
-
>
b
=
0
.
0
;
return
FALSE
;
}
if
(
Lab
-
>
L
>
100
)
Lab
-
>
L
=
100
;
if
(
Lab
-
>
a
<
amin
|
|
Lab
-
>
a
>
amax
|
|
Lab
-
>
b
<
bmin
|
|
Lab
-
>
b
>
bmax
)
{
cmsCIELCh
LCh
;
double
h
slope
;
if
(
Lab
-
>
a
=
=
0
.
0
)
{
Lab
-
>
b
=
Lab
-
>
b
<
0
?
bmin
:
bmax
;
return
TRUE
;
}
cmsLab2LCh
(
&
LCh
Lab
)
;
slope
=
Lab
-
>
b
/
Lab
-
>
a
;
h
=
LCh
.
h
;
if
(
(
h
>
=
0
.
&
&
h
<
45
.
)
|
|
(
h
>
=
315
&
&
h
<
=
360
.
)
)
{
Lab
-
>
a
=
amax
;
Lab
-
>
b
=
amax
*
slope
;
}
else
if
(
h
>
=
45
.
&
&
h
<
135
.
)
{
Lab
-
>
b
=
bmax
;
Lab
-
>
a
=
bmax
/
slope
;
}
else
if
(
h
>
=
135
.
&
&
h
<
225
.
)
{
Lab
-
>
a
=
amin
;
Lab
-
>
b
=
amin
*
slope
;
}
else
if
(
h
>
=
225
.
&
&
h
<
315
.
)
{
Lab
-
>
b
=
bmin
;
Lab
-
>
a
=
bmin
/
slope
;
}
else
{
cmsSignalError
(
0
cmsERROR_RANGE
"
Invalid
angle
"
)
;
return
FALSE
;
}
}
return
TRUE
;
}
