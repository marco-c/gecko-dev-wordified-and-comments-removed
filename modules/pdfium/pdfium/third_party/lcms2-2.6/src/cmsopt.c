#
include
"
lcms2_internal
.
h
"
typedef
struct
{
cmsContext
ContextID
;
const
cmsInterpParams
*
p
;
cmsUInt16Number
rx
[
256
]
ry
[
256
]
rz
[
256
]
;
cmsUInt32Number
X0
[
256
]
Y0
[
256
]
Z0
[
256
]
;
}
Prelin8Data
;
typedef
struct
{
cmsContext
ContextID
;
int
nInputs
;
int
nOutputs
;
_cmsInterpFn16
EvalCurveIn16
[
MAX_INPUT_DIMENSIONS
]
;
cmsInterpParams
*
ParamsCurveIn16
[
MAX_INPUT_DIMENSIONS
]
;
_cmsInterpFn16
EvalCLUT
;
const
cmsInterpParams
*
CLUTparams
;
_cmsInterpFn16
*
EvalCurveOut16
;
cmsInterpParams
*
*
ParamsCurveOut16
;
}
Prelin16Data
;
typedef
cmsInt32Number
cmsS1Fixed14Number
;
#
define
DOUBLE_TO_1FIXED14
(
x
)
(
(
cmsS1Fixed14Number
)
floor
(
(
x
)
*
16384
.
0
+
0
.
5
)
)
typedef
struct
{
cmsContext
ContextID
;
cmsS1Fixed14Number
Shaper1R
[
256
]
;
cmsS1Fixed14Number
Shaper1G
[
256
]
;
cmsS1Fixed14Number
Shaper1B
[
256
]
;
cmsS1Fixed14Number
Mat
[
3
]
[
3
]
;
cmsS1Fixed14Number
Off
[
3
]
;
cmsUInt16Number
Shaper2R
[
16385
]
;
cmsUInt16Number
Shaper2G
[
16385
]
;
cmsUInt16Number
Shaper2B
[
16385
]
;
}
MatShaper8Data
;
typedef
struct
{
cmsContext
ContextID
;
int
nCurves
;
int
nElements
;
cmsUInt16Number
*
*
Curves
;
}
Curves16Data
;
static
void
_RemoveElement
(
cmsStage
*
*
head
)
{
cmsStage
*
mpe
=
*
head
;
cmsStage
*
next
=
mpe
-
>
Next
;
*
head
=
next
;
cmsStageFree
(
mpe
)
;
}
static
cmsBool
_Remove1Op
(
cmsPipeline
*
Lut
cmsStageSignature
UnaryOp
)
{
cmsStage
*
*
pt
=
&
Lut
-
>
Elements
;
cmsBool
AnyOpt
=
FALSE
;
while
(
*
pt
!
=
NULL
)
{
if
(
(
*
pt
)
-
>
Implements
=
=
UnaryOp
)
{
_RemoveElement
(
pt
)
;
AnyOpt
=
TRUE
;
}
else
pt
=
&
(
(
*
pt
)
-
>
Next
)
;
}
return
AnyOpt
;
}
static
cmsBool
_Remove2Op
(
cmsPipeline
*
Lut
cmsStageSignature
Op1
cmsStageSignature
Op2
)
{
cmsStage
*
*
pt1
;
cmsStage
*
*
pt2
;
cmsBool
AnyOpt
=
FALSE
;
pt1
=
&
Lut
-
>
Elements
;
if
(
*
pt1
=
=
NULL
)
return
AnyOpt
;
while
(
*
pt1
!
=
NULL
)
{
pt2
=
&
(
(
*
pt1
)
-
>
Next
)
;
if
(
*
pt2
=
=
NULL
)
return
AnyOpt
;
if
(
(
*
pt1
)
-
>
Implements
=
=
Op1
&
&
(
*
pt2
)
-
>
Implements
=
=
Op2
)
{
_RemoveElement
(
pt2
)
;
_RemoveElement
(
pt1
)
;
AnyOpt
=
TRUE
;
}
else
pt1
=
&
(
(
*
pt1
)
-
>
Next
)
;
}
return
AnyOpt
;
}
static
cmsBool
PreOptimize
(
cmsPipeline
*
Lut
)
{
cmsBool
AnyOpt
=
FALSE
Opt
;
do
{
Opt
=
FALSE
;
Opt
|
=
_Remove1Op
(
Lut
cmsSigIdentityElemType
)
;
Opt
|
=
_Remove2Op
(
Lut
cmsSigXYZ2LabElemType
cmsSigLab2XYZElemType
)
;
Opt
|
=
_Remove2Op
(
Lut
cmsSigLab2XYZElemType
cmsSigXYZ2LabElemType
)
;
Opt
|
=
_Remove2Op
(
Lut
cmsSigLabV4toV2
cmsSigLabV2toV4
)
;
Opt
|
=
_Remove2Op
(
Lut
cmsSigLabV2toV4
cmsSigLabV4toV2
)
;
Opt
|
=
_Remove2Op
(
Lut
cmsSigLab2FloatPCS
cmsSigFloatPCS2Lab
)
;
Opt
|
=
_Remove2Op
(
Lut
cmsSigXYZ2FloatPCS
cmsSigFloatPCS2XYZ
)
;
if
(
Opt
)
AnyOpt
=
TRUE
;
}
while
(
Opt
)
;
return
AnyOpt
;
}
static
void
Eval16nop1D
(
register
const
cmsUInt16Number
Input
[
]
register
cmsUInt16Number
Output
[
]
register
const
struct
_cms_interp_struc
*
p
)
{
Output
[
0
]
=
Input
[
0
]
;
cmsUNUSED_PARAMETER
(
p
)
;
}
static
void
PrelinEval16
(
register
const
cmsUInt16Number
Input
[
]
register
cmsUInt16Number
Output
[
]
register
const
void
*
D
)
{
Prelin16Data
*
p16
=
(
Prelin16Data
*
)
D
;
cmsUInt16Number
StageABC
[
MAX_INPUT_DIMENSIONS
]
;
cmsUInt16Number
StageDEF
[
cmsMAXCHANNELS
]
;
int
i
;
for
(
i
=
0
;
i
<
p16
-
>
nInputs
;
i
+
+
)
{
p16
-
>
EvalCurveIn16
[
i
]
(
&
Input
[
i
]
&
StageABC
[
i
]
p16
-
>
ParamsCurveIn16
[
i
]
)
;
}
p16
-
>
EvalCLUT
(
StageABC
StageDEF
p16
-
>
CLUTparams
)
;
for
(
i
=
0
;
i
<
p16
-
>
nOutputs
;
i
+
+
)
{
p16
-
>
EvalCurveOut16
[
i
]
(
&
StageDEF
[
i
]
&
Output
[
i
]
p16
-
>
ParamsCurveOut16
[
i
]
)
;
}
}
static
void
PrelinOpt16free
(
cmsContext
ContextID
void
*
ptr
)
{
Prelin16Data
*
p16
=
(
Prelin16Data
*
)
ptr
;
_cmsFree
(
ContextID
p16
-
>
EvalCurveOut16
)
;
_cmsFree
(
ContextID
p16
-
>
ParamsCurveOut16
)
;
_cmsFree
(
ContextID
p16
)
;
}
static
void
*
Prelin16dup
(
cmsContext
ContextID
const
void
*
ptr
)
{
Prelin16Data
*
p16
=
(
Prelin16Data
*
)
ptr
;
Prelin16Data
*
Duped
=
_cmsDupMem
(
ContextID
p16
sizeof
(
Prelin16Data
)
)
;
if
(
Duped
=
=
NULL
)
return
NULL
;
Duped
-
>
EvalCurveOut16
=
(
_cmsInterpFn16
*
)
_cmsDupMem
(
ContextID
p16
-
>
EvalCurveOut16
p16
-
>
nOutputs
*
sizeof
(
_cmsInterpFn16
)
)
;
Duped
-
>
ParamsCurveOut16
=
(
cmsInterpParams
*
*
)
_cmsDupMem
(
ContextID
p16
-
>
ParamsCurveOut16
p16
-
>
nOutputs
*
sizeof
(
cmsInterpParams
*
)
)
;
return
Duped
;
}
static
Prelin16Data
*
PrelinOpt16alloc
(
cmsContext
ContextID
const
cmsInterpParams
*
ColorMap
int
nInputs
cmsToneCurve
*
*
In
int
nOutputs
cmsToneCurve
*
*
Out
)
{
int
i
;
Prelin16Data
*
p16
=
_cmsMallocZero
(
ContextID
sizeof
(
Prelin16Data
)
)
;
if
(
p16
=
=
NULL
)
return
NULL
;
p16
-
>
nInputs
=
nInputs
;
p16
-
>
nOutputs
=
nOutputs
;
for
(
i
=
0
;
i
<
nInputs
;
i
+
+
)
{
if
(
In
=
=
NULL
)
{
p16
-
>
ParamsCurveIn16
[
i
]
=
NULL
;
p16
-
>
EvalCurveIn16
[
i
]
=
Eval16nop1D
;
}
else
{
p16
-
>
ParamsCurveIn16
[
i
]
=
In
[
i
]
-
>
InterpParams
;
p16
-
>
EvalCurveIn16
[
i
]
=
p16
-
>
ParamsCurveIn16
[
i
]
-
>
Interpolation
.
Lerp16
;
}
}
p16
-
>
CLUTparams
=
ColorMap
;
p16
-
>
EvalCLUT
=
ColorMap
-
>
Interpolation
.
Lerp16
;
p16
-
>
EvalCurveOut16
=
(
_cmsInterpFn16
*
)
_cmsCalloc
(
ContextID
nOutputs
sizeof
(
_cmsInterpFn16
)
)
;
p16
-
>
ParamsCurveOut16
=
(
cmsInterpParams
*
*
)
_cmsCalloc
(
ContextID
nOutputs
sizeof
(
cmsInterpParams
*
)
)
;
for
(
i
=
0
;
i
<
nOutputs
;
i
+
+
)
{
if
(
Out
=
=
NULL
)
{
p16
-
>
ParamsCurveOut16
[
i
]
=
NULL
;
p16
-
>
EvalCurveOut16
[
i
]
=
Eval16nop1D
;
}
else
{
p16
-
>
ParamsCurveOut16
[
i
]
=
Out
[
i
]
-
>
InterpParams
;
p16
-
>
EvalCurveOut16
[
i
]
=
p16
-
>
ParamsCurveOut16
[
i
]
-
>
Interpolation
.
Lerp16
;
}
}
return
p16
;
}
#
define
PRELINEARIZATION_POINTS
4096
static
int
XFormSampler16
(
register
const
cmsUInt16Number
In
[
]
register
cmsUInt16Number
Out
[
]
register
void
*
Cargo
)
{
cmsPipeline
*
Lut
=
(
cmsPipeline
*
)
Cargo
;
cmsFloat32Number
InFloat
[
cmsMAXCHANNELS
]
OutFloat
[
cmsMAXCHANNELS
]
;
cmsUInt32Number
i
;
_cmsAssert
(
Lut
-
>
InputChannels
<
cmsMAXCHANNELS
)
;
_cmsAssert
(
Lut
-
>
OutputChannels
<
cmsMAXCHANNELS
)
;
for
(
i
=
0
;
i
<
Lut
-
>
InputChannels
;
i
+
+
)
InFloat
[
i
]
=
(
cmsFloat32Number
)
(
In
[
i
]
/
65535
.
0
)
;
cmsPipelineEvalFloat
(
InFloat
OutFloat
Lut
)
;
for
(
i
=
0
;
i
<
Lut
-
>
OutputChannels
;
i
+
+
)
Out
[
i
]
=
_cmsQuickSaturateWord
(
OutFloat
[
i
]
*
65535
.
0
)
;
return
TRUE
;
}
static
cmsBool
AllCurvesAreLinear
(
cmsStage
*
mpe
)
{
cmsToneCurve
*
*
Curves
;
cmsUInt32Number
i
n
;
Curves
=
_cmsStageGetPtrToCurveSet
(
mpe
)
;
if
(
Curves
=
=
NULL
)
return
FALSE
;
n
=
cmsStageOutputChannels
(
mpe
)
;
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
if
(
!
cmsIsToneCurveLinear
(
Curves
[
i
]
)
)
return
FALSE
;
}
return
TRUE
;
}
static
cmsBool
PatchLUT
(
cmsStage
*
CLUT
cmsUInt16Number
At
[
]
cmsUInt16Number
Value
[
]
int
nChannelsOut
int
nChannelsIn
)
{
_cmsStageCLutData
*
Grid
=
(
_cmsStageCLutData
*
)
CLUT
-
>
Data
;
cmsInterpParams
*
p16
=
Grid
-
>
Params
;
cmsFloat64Number
px
py
pz
pw
;
int
x0
y0
z0
w0
;
int
i
index
;
if
(
CLUT
-
>
Type
!
=
cmsSigCLutElemType
)
{
cmsSignalError
(
CLUT
-
>
ContextID
cmsERROR_INTERNAL
"
(
internal
)
Attempt
to
PatchLUT
on
non
-
lut
stage
"
)
;
return
FALSE
;
}
if
(
nChannelsIn
!
=
1
&
&
nChannelsIn
!
=
3
&
&
nChannelsIn
!
=
4
)
{
cmsSignalError
(
CLUT
-
>
ContextID
cmsERROR_INTERNAL
"
(
internal
)
%
d
Channels
are
not
supported
on
PatchLUT
"
nChannelsIn
)
;
return
FALSE
;
}
if
(
nChannelsIn
=
=
4
)
{
px
=
(
(
cmsFloat64Number
)
At
[
0
]
*
(
p16
-
>
Domain
[
0
]
)
)
/
65535
.
0
;
py
=
(
(
cmsFloat64Number
)
At
[
1
]
*
(
p16
-
>
Domain
[
1
]
)
)
/
65535
.
0
;
pz
=
(
(
cmsFloat64Number
)
At
[
2
]
*
(
p16
-
>
Domain
[
2
]
)
)
/
65535
.
0
;
pw
=
(
(
cmsFloat64Number
)
At
[
3
]
*
(
p16
-
>
Domain
[
3
]
)
)
/
65535
.
0
;
x0
=
(
int
)
floor
(
px
)
;
y0
=
(
int
)
floor
(
py
)
;
z0
=
(
int
)
floor
(
pz
)
;
w0
=
(
int
)
floor
(
pw
)
;
if
(
(
(
px
-
x0
)
!
=
0
)
|
|
(
(
py
-
y0
)
!
=
0
)
|
|
(
(
pz
-
z0
)
!
=
0
)
|
|
(
(
pw
-
w0
)
!
=
0
)
)
return
FALSE
;
index
=
p16
-
>
opta
[
3
]
*
x0
+
p16
-
>
opta
[
2
]
*
y0
+
p16
-
>
opta
[
1
]
*
z0
+
p16
-
>
opta
[
0
]
*
w0
;
}
else
if
(
nChannelsIn
=
=
3
)
{
px
=
(
(
cmsFloat64Number
)
At
[
0
]
*
(
p16
-
>
Domain
[
0
]
)
)
/
65535
.
0
;
py
=
(
(
cmsFloat64Number
)
At
[
1
]
*
(
p16
-
>
Domain
[
1
]
)
)
/
65535
.
0
;
pz
=
(
(
cmsFloat64Number
)
At
[
2
]
*
(
p16
-
>
Domain
[
2
]
)
)
/
65535
.
0
;
x0
=
(
int
)
floor
(
px
)
;
y0
=
(
int
)
floor
(
py
)
;
z0
=
(
int
)
floor
(
pz
)
;
if
(
(
(
px
-
x0
)
!
=
0
)
|
|
(
(
py
-
y0
)
!
=
0
)
|
|
(
(
pz
-
z0
)
!
=
0
)
)
return
FALSE
;
index
=
p16
-
>
opta
[
2
]
*
x0
+
p16
-
>
opta
[
1
]
*
y0
+
p16
-
>
opta
[
0
]
*
z0
;
}
else
if
(
nChannelsIn
=
=
1
)
{
px
=
(
(
cmsFloat64Number
)
At
[
0
]
*
(
p16
-
>
Domain
[
0
]
)
)
/
65535
.
0
;
x0
=
(
int
)
floor
(
px
)
;
if
(
(
(
px
-
x0
)
!
=
0
)
)
return
FALSE
;
index
=
p16
-
>
opta
[
0
]
*
x0
;
}
else
{
cmsSignalError
(
CLUT
-
>
ContextID
cmsERROR_INTERNAL
"
(
internal
)
%
d
Channels
are
not
supported
on
PatchLUT
"
nChannelsIn
)
;
return
FALSE
;
}
for
(
i
=
0
;
i
<
nChannelsOut
;
i
+
+
)
Grid
-
>
Tab
.
T
[
index
+
i
]
=
Value
[
i
]
;
return
TRUE
;
}
static
cmsBool
WhitesAreEqual
(
int
n
cmsUInt16Number
White1
[
]
cmsUInt16Number
White2
[
]
)
{
int
i
;
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
if
(
abs
(
White1
[
i
]
-
White2
[
i
]
)
>
0xf000
)
return
TRUE
;
if
(
White1
[
i
]
!
=
White2
[
i
]
)
return
FALSE
;
}
return
TRUE
;
}
static
cmsBool
FixWhiteMisalignment
(
cmsPipeline
*
Lut
cmsColorSpaceSignature
EntryColorSpace
cmsColorSpaceSignature
ExitColorSpace
)
{
cmsUInt16Number
*
WhitePointIn
*
WhitePointOut
;
cmsUInt16Number
WhiteIn
[
cmsMAXCHANNELS
]
WhiteOut
[
cmsMAXCHANNELS
]
ObtainedOut
[
cmsMAXCHANNELS
]
;
cmsUInt32Number
i
nOuts
nIns
;
cmsStage
*
PreLin
=
NULL
*
CLUT
=
NULL
*
PostLin
=
NULL
;
if
(
!
_cmsEndPointsBySpace
(
EntryColorSpace
&
WhitePointIn
NULL
&
nIns
)
)
return
FALSE
;
if
(
!
_cmsEndPointsBySpace
(
ExitColorSpace
&
WhitePointOut
NULL
&
nOuts
)
)
return
FALSE
;
if
(
Lut
-
>
InputChannels
!
=
nIns
)
return
FALSE
;
if
(
Lut
-
>
OutputChannels
!
=
nOuts
)
return
FALSE
;
cmsPipelineEval16
(
WhitePointIn
ObtainedOut
Lut
)
;
if
(
WhitesAreEqual
(
nOuts
WhitePointOut
ObtainedOut
)
)
return
TRUE
;
if
(
!
cmsPipelineCheckAndRetreiveStages
(
Lut
3
cmsSigCurveSetElemType
cmsSigCLutElemType
cmsSigCurveSetElemType
&
PreLin
&
CLUT
&
PostLin
)
)
if
(
!
cmsPipelineCheckAndRetreiveStages
(
Lut
2
cmsSigCurveSetElemType
cmsSigCLutElemType
&
PreLin
&
CLUT
)
)
if
(
!
cmsPipelineCheckAndRetreiveStages
(
Lut
2
cmsSigCLutElemType
cmsSigCurveSetElemType
&
CLUT
&
PostLin
)
)
if
(
!
cmsPipelineCheckAndRetreiveStages
(
Lut
1
cmsSigCLutElemType
&
CLUT
)
)
return
FALSE
;
if
(
PreLin
)
{
cmsToneCurve
*
*
Curves
=
_cmsStageGetPtrToCurveSet
(
PreLin
)
;
for
(
i
=
0
;
i
<
nIns
;
i
+
+
)
{
WhiteIn
[
i
]
=
cmsEvalToneCurve16
(
Curves
[
i
]
WhitePointIn
[
i
]
)
;
}
}
else
{
for
(
i
=
0
;
i
<
nIns
;
i
+
+
)
WhiteIn
[
i
]
=
WhitePointIn
[
i
]
;
}
if
(
PostLin
)
{
cmsToneCurve
*
*
Curves
=
_cmsStageGetPtrToCurveSet
(
PostLin
)
;
for
(
i
=
0
;
i
<
nOuts
;
i
+
+
)
{
cmsToneCurve
*
InversePostLin
=
cmsReverseToneCurve
(
Curves
[
i
]
)
;
if
(
InversePostLin
=
=
NULL
)
{
WhiteOut
[
i
]
=
WhitePointOut
[
i
]
;
}
else
{
WhiteOut
[
i
]
=
cmsEvalToneCurve16
(
InversePostLin
WhitePointOut
[
i
]
)
;
cmsFreeToneCurve
(
InversePostLin
)
;
}
}
}
else
{
for
(
i
=
0
;
i
<
nOuts
;
i
+
+
)
WhiteOut
[
i
]
=
WhitePointOut
[
i
]
;
}
PatchLUT
(
CLUT
WhiteIn
WhiteOut
nOuts
nIns
)
;
return
TRUE
;
}
static
cmsBool
OptimizeByResampling
(
cmsPipeline
*
*
Lut
cmsUInt32Number
Intent
cmsUInt32Number
*
InputFormat
cmsUInt32Number
*
OutputFormat
cmsUInt32Number
*
dwFlags
)
{
cmsPipeline
*
Src
=
NULL
;
cmsPipeline
*
Dest
=
NULL
;
cmsStage
*
mpe
;
cmsStage
*
CLUT
;
cmsStage
*
KeepPreLin
=
NULL
*
KeepPostLin
=
NULL
;
int
nGridPoints
;
cmsColorSpaceSignature
ColorSpace
OutputColorSpace
;
cmsStage
*
NewPreLin
=
NULL
;
cmsStage
*
NewPostLin
=
NULL
;
_cmsStageCLutData
*
DataCLUT
;
cmsToneCurve
*
*
DataSetIn
;
cmsToneCurve
*
*
DataSetOut
;
Prelin16Data
*
p16
;
if
(
_cmsFormatterIsFloat
(
*
InputFormat
)
|
|
_cmsFormatterIsFloat
(
*
OutputFormat
)
)
return
FALSE
;
ColorSpace
=
_cmsICCcolorSpace
(
T_COLORSPACE
(
*
InputFormat
)
)
;
OutputColorSpace
=
_cmsICCcolorSpace
(
T_COLORSPACE
(
*
OutputFormat
)
)
;
nGridPoints
=
_cmsReasonableGridpointsByColorspace
(
ColorSpace
*
dwFlags
)
;
if
(
cmsPipelineStageCount
(
*
Lut
)
=
=
0
)
nGridPoints
=
2
;
Src
=
*
Lut
;
for
(
mpe
=
cmsPipelineGetPtrToFirstStage
(
Src
)
;
mpe
!
=
NULL
;
mpe
=
cmsStageNext
(
mpe
)
)
{
if
(
cmsStageType
(
mpe
)
=
=
cmsSigNamedColorElemType
)
return
FALSE
;
}
Dest
=
cmsPipelineAlloc
(
Src
-
>
ContextID
Src
-
>
InputChannels
Src
-
>
OutputChannels
)
;
if
(
!
Dest
)
return
FALSE
;
if
(
*
dwFlags
&
cmsFLAGS_CLUT_PRE_LINEARIZATION
)
{
cmsStage
*
PreLin
=
cmsPipelineGetPtrToFirstStage
(
Src
)
;
if
(
PreLin
-
>
Type
=
=
cmsSigCurveSetElemType
)
{
if
(
!
AllCurvesAreLinear
(
PreLin
)
)
{
NewPreLin
=
cmsStageDup
(
PreLin
)
;
if
(
!
cmsPipelineInsertStage
(
Dest
cmsAT_BEGIN
NewPreLin
)
)
goto
Error
;
cmsPipelineUnlinkStage
(
Src
cmsAT_BEGIN
&
KeepPreLin
)
;
}
}
}
CLUT
=
cmsStageAllocCLut16bit
(
Src
-
>
ContextID
nGridPoints
Src
-
>
InputChannels
Src
-
>
OutputChannels
NULL
)
;
if
(
CLUT
=
=
NULL
)
goto
Error
;
if
(
!
cmsPipelineInsertStage
(
Dest
cmsAT_END
CLUT
)
)
{
goto
Error
;
}
if
(
*
dwFlags
&
cmsFLAGS_CLUT_POST_LINEARIZATION
)
{
cmsStage
*
PostLin
=
cmsPipelineGetPtrToLastStage
(
Src
)
;
if
(
cmsStageType
(
PostLin
)
=
=
cmsSigCurveSetElemType
)
{
if
(
!
AllCurvesAreLinear
(
PostLin
)
)
{
NewPostLin
=
cmsStageDup
(
PostLin
)
;
if
(
!
cmsPipelineInsertStage
(
Dest
cmsAT_END
NewPostLin
)
)
goto
Error
;
cmsPipelineUnlinkStage
(
Src
cmsAT_END
&
KeepPostLin
)
;
}
}
}
if
(
!
cmsStageSampleCLut16bit
(
CLUT
XFormSampler16
(
void
*
)
Src
0
)
)
{
Error
:
if
(
KeepPreLin
!
=
NULL
)
{
if
(
!
cmsPipelineInsertStage
(
Src
cmsAT_BEGIN
KeepPreLin
)
)
{
_cmsAssert
(
0
)
;
}
}
if
(
KeepPostLin
!
=
NULL
)
{
if
(
!
cmsPipelineInsertStage
(
Src
cmsAT_END
KeepPostLin
)
)
{
_cmsAssert
(
0
)
;
}
}
cmsPipelineFree
(
Dest
)
;
return
FALSE
;
}
if
(
KeepPreLin
!
=
NULL
)
cmsStageFree
(
KeepPreLin
)
;
if
(
KeepPostLin
!
=
NULL
)
cmsStageFree
(
KeepPostLin
)
;
cmsPipelineFree
(
Src
)
;
DataCLUT
=
(
_cmsStageCLutData
*
)
CLUT
-
>
Data
;
if
(
NewPreLin
=
=
NULL
)
DataSetIn
=
NULL
;
else
DataSetIn
=
(
(
_cmsStageToneCurvesData
*
)
NewPreLin
-
>
Data
)
-
>
TheCurves
;
if
(
NewPostLin
=
=
NULL
)
DataSetOut
=
NULL
;
else
DataSetOut
=
(
(
_cmsStageToneCurvesData
*
)
NewPostLin
-
>
Data
)
-
>
TheCurves
;
if
(
DataSetIn
=
=
NULL
&
&
DataSetOut
=
=
NULL
)
{
_cmsPipelineSetOptimizationParameters
(
Dest
(
_cmsOPTeval16Fn
)
DataCLUT
-
>
Params
-
>
Interpolation
.
Lerp16
DataCLUT
-
>
Params
NULL
NULL
)
;
}
else
{
p16
=
PrelinOpt16alloc
(
Dest
-
>
ContextID
DataCLUT
-
>
Params
Dest
-
>
InputChannels
DataSetIn
Dest
-
>
OutputChannels
DataSetOut
)
;
_cmsPipelineSetOptimizationParameters
(
Dest
PrelinEval16
(
void
*
)
p16
PrelinOpt16free
Prelin16dup
)
;
}
if
(
Intent
=
=
INTENT_ABSOLUTE_COLORIMETRIC
)
*
dwFlags
|
=
cmsFLAGS_NOWHITEONWHITEFIXUP
;
if
(
!
(
*
dwFlags
&
cmsFLAGS_NOWHITEONWHITEFIXUP
)
)
{
FixWhiteMisalignment
(
Dest
ColorSpace
OutputColorSpace
)
;
}
*
Lut
=
Dest
;
return
TRUE
;
cmsUNUSED_PARAMETER
(
Intent
)
;
}
static
void
SlopeLimiting
(
cmsToneCurve
*
g
)
{
int
BeginVal
EndVal
;
int
AtBegin
=
(
int
)
floor
(
(
cmsFloat64Number
)
g
-
>
nEntries
*
0
.
02
+
0
.
5
)
;
int
AtEnd
=
g
-
>
nEntries
-
AtBegin
-
1
;
cmsFloat64Number
Val
Slope
beta
;
int
i
;
if
(
cmsIsToneCurveDescending
(
g
)
)
{
BeginVal
=
0xffff
;
EndVal
=
0
;
}
else
{
BeginVal
=
0
;
EndVal
=
0xffff
;
}
Val
=
g
-
>
Table16
[
AtBegin
]
;
Slope
=
(
Val
-
BeginVal
)
/
AtBegin
;
beta
=
Val
-
Slope
*
AtBegin
;
for
(
i
=
0
;
i
<
AtBegin
;
i
+
+
)
g
-
>
Table16
[
i
]
=
_cmsQuickSaturateWord
(
i
*
Slope
+
beta
)
;
Val
=
g
-
>
Table16
[
AtEnd
]
;
Slope
=
(
EndVal
-
Val
)
/
AtBegin
;
beta
=
Val
-
Slope
*
AtEnd
;
for
(
i
=
AtEnd
;
i
<
(
int
)
g
-
>
nEntries
;
i
+
+
)
g
-
>
Table16
[
i
]
=
_cmsQuickSaturateWord
(
i
*
Slope
+
beta
)
;
}
static
Prelin8Data
*
PrelinOpt8alloc
(
cmsContext
ContextID
const
cmsInterpParams
*
p
cmsToneCurve
*
G
[
3
]
)
{
int
i
;
cmsUInt16Number
Input
[
3
]
;
cmsS15Fixed16Number
v1
v2
v3
;
Prelin8Data
*
p8
;
p8
=
(
Prelin8Data
*
)
_cmsMallocZero
(
ContextID
sizeof
(
Prelin8Data
)
)
;
if
(
p8
=
=
NULL
)
return
NULL
;
for
(
i
=
0
;
i
<
256
;
i
+
+
)
{
if
(
G
!
=
NULL
)
{
Input
[
0
]
=
cmsEvalToneCurve16
(
G
[
0
]
FROM_8_TO_16
(
i
)
)
;
Input
[
1
]
=
cmsEvalToneCurve16
(
G
[
1
]
FROM_8_TO_16
(
i
)
)
;
Input
[
2
]
=
cmsEvalToneCurve16
(
G
[
2
]
FROM_8_TO_16
(
i
)
)
;
}
else
{
Input
[
0
]
=
FROM_8_TO_16
(
i
)
;
Input
[
1
]
=
FROM_8_TO_16
(
i
)
;
Input
[
2
]
=
FROM_8_TO_16
(
i
)
;
}
v1
=
_cmsToFixedDomain
(
Input
[
0
]
*
p
-
>
Domain
[
0
]
)
;
v2
=
_cmsToFixedDomain
(
Input
[
1
]
*
p
-
>
Domain
[
1
]
)
;
v3
=
_cmsToFixedDomain
(
Input
[
2
]
*
p
-
>
Domain
[
2
]
)
;
p8
-
>
X0
[
i
]
=
(
p
-
>
opta
[
2
]
*
FIXED_TO_INT
(
v1
)
)
;
p8
-
>
Y0
[
i
]
=
(
p
-
>
opta
[
1
]
*
FIXED_TO_INT
(
v2
)
)
;
p8
-
>
Z0
[
i
]
=
(
p
-
>
opta
[
0
]
*
FIXED_TO_INT
(
v3
)
)
;
p8
-
>
rx
[
i
]
=
(
cmsUInt16Number
)
FIXED_REST_TO_INT
(
v1
)
;
p8
-
>
ry
[
i
]
=
(
cmsUInt16Number
)
FIXED_REST_TO_INT
(
v2
)
;
p8
-
>
rz
[
i
]
=
(
cmsUInt16Number
)
FIXED_REST_TO_INT
(
v3
)
;
}
p8
-
>
ContextID
=
ContextID
;
p8
-
>
p
=
p
;
return
p8
;
}
static
void
Prelin8free
(
cmsContext
ContextID
void
*
ptr
)
{
_cmsFree
(
ContextID
ptr
)
;
}
static
void
*
Prelin8dup
(
cmsContext
ContextID
const
void
*
ptr
)
{
return
_cmsDupMem
(
ContextID
ptr
sizeof
(
Prelin8Data
)
)
;
}
#
define
DENS
(
i
j
k
)
(
LutTable
[
(
i
)
+
(
j
)
+
(
k
)
+
OutChan
]
)
static
void
PrelinEval8
(
register
const
cmsUInt16Number
Input
[
]
register
cmsUInt16Number
Output
[
]
register
const
void
*
D
)
{
cmsUInt8Number
r
g
b
;
cmsS15Fixed16Number
rx
ry
rz
;
cmsS15Fixed16Number
c0
c1
c2
c3
Rest
;
int
OutChan
;
register
cmsS15Fixed16Number
X0
X1
Y0
Y1
Z0
Z1
;
Prelin8Data
*
p8
=
(
Prelin8Data
*
)
D
;
register
const
cmsInterpParams
*
p
=
p8
-
>
p
;
int
TotalOut
=
p
-
>
nOutputs
;
const
cmsUInt16Number
*
LutTable
=
(
const
cmsUInt16Number
*
)
p
-
>
Table
;
r
=
Input
[
0
]
>
>
8
;
g
=
Input
[
1
]
>
>
8
;
b
=
Input
[
2
]
>
>
8
;
X0
=
X1
=
p8
-
>
X0
[
r
]
;
Y0
=
Y1
=
p8
-
>
Y0
[
g
]
;
Z0
=
Z1
=
p8
-
>
Z0
[
b
]
;
rx
=
p8
-
>
rx
[
r
]
;
ry
=
p8
-
>
ry
[
g
]
;
rz
=
p8
-
>
rz
[
b
]
;
X1
=
X0
+
(
(
rx
=
=
0
)
?
0
:
p
-
>
opta
[
2
]
)
;
Y1
=
Y0
+
(
(
ry
=
=
0
)
?
0
:
p
-
>
opta
[
1
]
)
;
Z1
=
Z0
+
(
(
rz
=
=
0
)
?
0
:
p
-
>
opta
[
0
]
)
;
for
(
OutChan
=
0
;
OutChan
<
TotalOut
;
OutChan
+
+
)
{
c0
=
DENS
(
X0
Y0
Z0
)
;
if
(
rx
>
=
ry
&
&
ry
>
=
rz
)
{
c1
=
DENS
(
X1
Y0
Z0
)
-
c0
;
c2
=
DENS
(
X1
Y1
Z0
)
-
DENS
(
X1
Y0
Z0
)
;
c3
=
DENS
(
X1
Y1
Z1
)
-
DENS
(
X1
Y1
Z0
)
;
}
else
if
(
rx
>
=
rz
&
&
rz
>
=
ry
)
{
c1
=
DENS
(
X1
Y0
Z0
)
-
c0
;
c2
=
DENS
(
X1
Y1
Z1
)
-
DENS
(
X1
Y0
Z1
)
;
c3
=
DENS
(
X1
Y0
Z1
)
-
DENS
(
X1
Y0
Z0
)
;
}
else
if
(
rz
>
=
rx
&
&
rx
>
=
ry
)
{
c1
=
DENS
(
X1
Y0
Z1
)
-
DENS
(
X0
Y0
Z1
)
;
c2
=
DENS
(
X1
Y1
Z1
)
-
DENS
(
X1
Y0
Z1
)
;
c3
=
DENS
(
X0
Y0
Z1
)
-
c0
;
}
else
if
(
ry
>
=
rx
&
&
rx
>
=
rz
)
{
c1
=
DENS
(
X1
Y1
Z0
)
-
DENS
(
X0
Y1
Z0
)
;
c2
=
DENS
(
X0
Y1
Z0
)
-
c0
;
c3
=
DENS
(
X1
Y1
Z1
)
-
DENS
(
X1
Y1
Z0
)
;
}
else
if
(
ry
>
=
rz
&
&
rz
>
=
rx
)
{
c1
=
DENS
(
X1
Y1
Z1
)
-
DENS
(
X0
Y1
Z1
)
;
c2
=
DENS
(
X0
Y1
Z0
)
-
c0
;
c3
=
DENS
(
X0
Y1
Z1
)
-
DENS
(
X0
Y1
Z0
)
;
}
else
if
(
rz
>
=
ry
&
&
ry
>
=
rx
)
{
c1
=
DENS
(
X1
Y1
Z1
)
-
DENS
(
X0
Y1
Z1
)
;
c2
=
DENS
(
X0
Y1
Z1
)
-
DENS
(
X0
Y0
Z1
)
;
c3
=
DENS
(
X0
Y0
Z1
)
-
c0
;
}
else
{
c1
=
c2
=
c3
=
0
;
}
Rest
=
c1
*
rx
+
c2
*
ry
+
c3
*
rz
+
0x8001
;
Output
[
OutChan
]
=
(
cmsUInt16Number
)
c0
+
(
(
Rest
+
(
Rest
>
>
16
)
)
>
>
16
)
;
}
}
#
undef
DENS
static
cmsBool
IsDegenerated
(
const
cmsToneCurve
*
g
)
{
int
i
Zeros
=
0
Poles
=
0
;
int
nEntries
=
g
-
>
nEntries
;
for
(
i
=
0
;
i
<
nEntries
;
i
+
+
)
{
if
(
g
-
>
Table16
[
i
]
=
=
0x0000
)
Zeros
+
+
;
if
(
g
-
>
Table16
[
i
]
=
=
0xffff
)
Poles
+
+
;
}
if
(
Zeros
=
=
1
&
&
Poles
=
=
1
)
return
FALSE
;
if
(
Zeros
>
(
nEntries
/
4
)
)
return
TRUE
;
if
(
Poles
>
(
nEntries
/
4
)
)
return
TRUE
;
return
FALSE
;
}
static
cmsBool
OptimizeByComputingLinearization
(
cmsPipeline
*
*
Lut
cmsUInt32Number
Intent
cmsUInt32Number
*
InputFormat
cmsUInt32Number
*
OutputFormat
cmsUInt32Number
*
dwFlags
)
{
cmsPipeline
*
OriginalLut
;
int
nGridPoints
;
cmsToneCurve
*
Trans
[
cmsMAXCHANNELS
]
*
TransReverse
[
cmsMAXCHANNELS
]
;
cmsUInt32Number
t
i
;
cmsFloat32Number
v
In
[
cmsMAXCHANNELS
]
Out
[
cmsMAXCHANNELS
]
;
cmsBool
lIsSuitable
lIsLinear
;
cmsPipeline
*
OptimizedLUT
=
NULL
*
LutPlusCurves
=
NULL
;
cmsStage
*
OptimizedCLUTmpe
;
cmsColorSpaceSignature
ColorSpace
OutputColorSpace
;
cmsStage
*
OptimizedPrelinMpe
;
cmsStage
*
mpe
;
cmsToneCurve
*
*
OptimizedPrelinCurves
;
_cmsStageCLutData
*
OptimizedPrelinCLUT
;
if
(
_cmsFormatterIsFloat
(
*
InputFormat
)
|
|
_cmsFormatterIsFloat
(
*
OutputFormat
)
)
return
FALSE
;
if
(
T_COLORSPACE
(
*
InputFormat
)
!
=
PT_RGB
)
return
FALSE
;
if
(
T_COLORSPACE
(
*
OutputFormat
)
!
=
PT_RGB
)
return
FALSE
;
if
(
!
_cmsFormatterIs8bit
(
*
InputFormat
)
)
{
if
(
!
(
*
dwFlags
&
cmsFLAGS_CLUT_PRE_LINEARIZATION
)
)
return
FALSE
;
}
OriginalLut
=
*
Lut
;
for
(
mpe
=
cmsPipelineGetPtrToFirstStage
(
OriginalLut
)
;
mpe
!
=
NULL
;
mpe
=
cmsStageNext
(
mpe
)
)
{
if
(
cmsStageType
(
mpe
)
=
=
cmsSigNamedColorElemType
)
return
FALSE
;
}
ColorSpace
=
_cmsICCcolorSpace
(
T_COLORSPACE
(
*
InputFormat
)
)
;
OutputColorSpace
=
_cmsICCcolorSpace
(
T_COLORSPACE
(
*
OutputFormat
)
)
;
nGridPoints
=
_cmsReasonableGridpointsByColorspace
(
ColorSpace
*
dwFlags
)
;
memset
(
Trans
0
sizeof
(
Trans
)
)
;
memset
(
TransReverse
0
sizeof
(
TransReverse
)
)
;
for
(
t
=
0
;
t
<
OriginalLut
-
>
InputChannels
;
t
+
+
)
{
Trans
[
t
]
=
cmsBuildTabulatedToneCurve16
(
OriginalLut
-
>
ContextID
PRELINEARIZATION_POINTS
NULL
)
;
if
(
Trans
[
t
]
=
=
NULL
)
goto
Error
;
}
for
(
i
=
0
;
i
<
PRELINEARIZATION_POINTS
;
i
+
+
)
{
v
=
(
cmsFloat32Number
)
(
(
cmsFloat64Number
)
i
/
(
PRELINEARIZATION_POINTS
-
1
)
)
;
for
(
t
=
0
;
t
<
OriginalLut
-
>
InputChannels
;
t
+
+
)
In
[
t
]
=
v
;
cmsPipelineEvalFloat
(
In
Out
OriginalLut
)
;
for
(
t
=
0
;
t
<
OriginalLut
-
>
InputChannels
;
t
+
+
)
Trans
[
t
]
-
>
Table16
[
i
]
=
_cmsQuickSaturateWord
(
Out
[
t
]
*
65535
.
0
)
;
}
for
(
t
=
0
;
t
<
OriginalLut
-
>
InputChannels
;
t
+
+
)
SlopeLimiting
(
Trans
[
t
]
)
;
lIsSuitable
=
TRUE
;
lIsLinear
=
TRUE
;
for
(
t
=
0
;
(
lIsSuitable
&
&
(
t
<
OriginalLut
-
>
InputChannels
)
)
;
t
+
+
)
{
if
(
!
cmsIsToneCurveLinear
(
Trans
[
t
]
)
)
lIsLinear
=
FALSE
;
if
(
!
cmsIsToneCurveMonotonic
(
Trans
[
t
]
)
)
lIsSuitable
=
FALSE
;
if
(
IsDegenerated
(
Trans
[
t
]
)
)
lIsSuitable
=
FALSE
;
}
if
(
!
lIsSuitable
)
goto
Error
;
for
(
t
=
0
;
t
<
OriginalLut
-
>
InputChannels
;
t
+
+
)
{
TransReverse
[
t
]
=
cmsReverseToneCurveEx
(
PRELINEARIZATION_POINTS
Trans
[
t
]
)
;
if
(
TransReverse
[
t
]
=
=
NULL
)
goto
Error
;
}
LutPlusCurves
=
cmsPipelineDup
(
OriginalLut
)
;
if
(
LutPlusCurves
=
=
NULL
)
goto
Error
;
if
(
!
cmsPipelineInsertStage
(
LutPlusCurves
cmsAT_BEGIN
cmsStageAllocToneCurves
(
OriginalLut
-
>
ContextID
OriginalLut
-
>
InputChannels
TransReverse
)
)
)
goto
Error
;
OptimizedLUT
=
cmsPipelineAlloc
(
OriginalLut
-
>
ContextID
OriginalLut
-
>
InputChannels
OriginalLut
-
>
OutputChannels
)
;
if
(
OptimizedLUT
=
=
NULL
)
goto
Error
;
OptimizedPrelinMpe
=
cmsStageAllocToneCurves
(
OriginalLut
-
>
ContextID
OriginalLut
-
>
InputChannels
Trans
)
;
if
(
!
cmsPipelineInsertStage
(
OptimizedLUT
cmsAT_BEGIN
OptimizedPrelinMpe
)
)
goto
Error
;
OptimizedCLUTmpe
=
cmsStageAllocCLut16bit
(
OriginalLut
-
>
ContextID
nGridPoints
OriginalLut
-
>
InputChannels
OriginalLut
-
>
OutputChannels
NULL
)
;
if
(
!
cmsPipelineInsertStage
(
OptimizedLUT
cmsAT_END
OptimizedCLUTmpe
)
)
goto
Error
;
if
(
!
cmsStageSampleCLut16bit
(
OptimizedCLUTmpe
XFormSampler16
(
void
*
)
LutPlusCurves
0
)
)
goto
Error
;
for
(
t
=
0
;
t
<
OriginalLut
-
>
InputChannels
;
t
+
+
)
{
if
(
Trans
[
t
]
)
cmsFreeToneCurve
(
Trans
[
t
]
)
;
if
(
TransReverse
[
t
]
)
cmsFreeToneCurve
(
TransReverse
[
t
]
)
;
}
cmsPipelineFree
(
LutPlusCurves
)
;
OptimizedPrelinCurves
=
_cmsStageGetPtrToCurveSet
(
OptimizedPrelinMpe
)
;
OptimizedPrelinCLUT
=
(
_cmsStageCLutData
*
)
OptimizedCLUTmpe
-
>
Data
;
if
(
_cmsFormatterIs8bit
(
*
InputFormat
)
)
{
Prelin8Data
*
p8
=
PrelinOpt8alloc
(
OptimizedLUT
-
>
ContextID
OptimizedPrelinCLUT
-
>
Params
OptimizedPrelinCurves
)
;
if
(
p8
=
=
NULL
)
return
FALSE
;
_cmsPipelineSetOptimizationParameters
(
OptimizedLUT
PrelinEval8
(
void
*
)
p8
Prelin8free
Prelin8dup
)
;
}
else
{
Prelin16Data
*
p16
=
PrelinOpt16alloc
(
OptimizedLUT
-
>
ContextID
OptimizedPrelinCLUT
-
>
Params
3
OptimizedPrelinCurves
3
NULL
)
;
if
(
p16
=
=
NULL
)
return
FALSE
;
_cmsPipelineSetOptimizationParameters
(
OptimizedLUT
PrelinEval16
(
void
*
)
p16
PrelinOpt16free
Prelin16dup
)
;
}
if
(
Intent
=
=
INTENT_ABSOLUTE_COLORIMETRIC
)
*
dwFlags
|
=
cmsFLAGS_NOWHITEONWHITEFIXUP
;
if
(
!
(
*
dwFlags
&
cmsFLAGS_NOWHITEONWHITEFIXUP
)
)
{
if
(
!
FixWhiteMisalignment
(
OptimizedLUT
ColorSpace
OutputColorSpace
)
)
{
return
FALSE
;
}
}
cmsPipelineFree
(
OriginalLut
)
;
*
Lut
=
OptimizedLUT
;
return
TRUE
;
Error
:
for
(
t
=
0
;
t
<
OriginalLut
-
>
InputChannels
;
t
+
+
)
{
if
(
Trans
[
t
]
)
cmsFreeToneCurve
(
Trans
[
t
]
)
;
if
(
TransReverse
[
t
]
)
cmsFreeToneCurve
(
TransReverse
[
t
]
)
;
}
if
(
LutPlusCurves
!
=
NULL
)
cmsPipelineFree
(
LutPlusCurves
)
;
if
(
OptimizedLUT
!
=
NULL
)
cmsPipelineFree
(
OptimizedLUT
)
;
return
FALSE
;
cmsUNUSED_PARAMETER
(
Intent
)
;
}
static
void
CurvesFree
(
cmsContext
ContextID
void
*
ptr
)
{
Curves16Data
*
Data
=
(
Curves16Data
*
)
ptr
;
int
i
;
for
(
i
=
0
;
i
<
Data
-
>
nCurves
;
i
+
+
)
{
_cmsFree
(
ContextID
Data
-
>
Curves
[
i
]
)
;
}
_cmsFree
(
ContextID
Data
-
>
Curves
)
;
_cmsFree
(
ContextID
ptr
)
;
}
static
void
*
CurvesDup
(
cmsContext
ContextID
const
void
*
ptr
)
{
Curves16Data
*
Data
=
(
Curves16Data
*
)
_cmsDupMem
(
ContextID
ptr
sizeof
(
Curves16Data
)
)
;
int
i
;
if
(
Data
=
=
NULL
)
return
NULL
;
Data
-
>
Curves
=
(
cmsUInt16Number
*
*
)
_cmsDupMem
(
ContextID
Data
-
>
Curves
Data
-
>
nCurves
*
sizeof
(
cmsUInt16Number
*
)
)
;
for
(
i
=
0
;
i
<
Data
-
>
nCurves
;
i
+
+
)
{
Data
-
>
Curves
[
i
]
=
(
cmsUInt16Number
*
)
_cmsDupMem
(
ContextID
Data
-
>
Curves
[
i
]
Data
-
>
nElements
*
sizeof
(
cmsUInt16Number
)
)
;
}
return
(
void
*
)
Data
;
}
static
Curves16Data
*
CurvesAlloc
(
cmsContext
ContextID
int
nCurves
int
nElements
cmsToneCurve
*
*
G
)
{
int
i
j
;
Curves16Data
*
c16
;
c16
=
(
Curves16Data
*
)
_cmsMallocZero
(
ContextID
sizeof
(
Curves16Data
)
)
;
if
(
c16
=
=
NULL
)
return
NULL
;
c16
-
>
nCurves
=
nCurves
;
c16
-
>
nElements
=
nElements
;
c16
-
>
Curves
=
(
cmsUInt16Number
*
*
)
_cmsCalloc
(
ContextID
nCurves
sizeof
(
cmsUInt16Number
*
)
)
;
if
(
c16
-
>
Curves
=
=
NULL
)
return
NULL
;
for
(
i
=
0
;
i
<
nCurves
;
i
+
+
)
{
c16
-
>
Curves
[
i
]
=
(
cmsUInt16Number
*
)
_cmsCalloc
(
ContextID
nElements
sizeof
(
cmsUInt16Number
)
)
;
if
(
c16
-
>
Curves
[
i
]
=
=
NULL
)
{
for
(
j
=
0
;
j
<
i
;
j
+
+
)
{
_cmsFree
(
ContextID
c16
-
>
Curves
[
j
]
)
;
}
_cmsFree
(
ContextID
c16
-
>
Curves
)
;
_cmsFree
(
ContextID
c16
)
;
return
NULL
;
}
if
(
nElements
=
=
256
)
{
for
(
j
=
0
;
j
<
nElements
;
j
+
+
)
{
c16
-
>
Curves
[
i
]
[
j
]
=
cmsEvalToneCurve16
(
G
[
i
]
FROM_8_TO_16
(
j
)
)
;
}
}
else
{
for
(
j
=
0
;
j
<
nElements
;
j
+
+
)
{
c16
-
>
Curves
[
i
]
[
j
]
=
cmsEvalToneCurve16
(
G
[
i
]
(
cmsUInt16Number
)
j
)
;
}
}
}
return
c16
;
}
static
void
FastEvaluateCurves8
(
register
const
cmsUInt16Number
In
[
]
register
cmsUInt16Number
Out
[
]
register
const
void
*
D
)
{
Curves16Data
*
Data
=
(
Curves16Data
*
)
D
;
cmsUInt8Number
x
;
int
i
;
for
(
i
=
0
;
i
<
Data
-
>
nCurves
;
i
+
+
)
{
x
=
(
In
[
i
]
>
>
8
)
;
Out
[
i
]
=
Data
-
>
Curves
[
i
]
[
x
]
;
}
}
static
void
FastEvaluateCurves16
(
register
const
cmsUInt16Number
In
[
]
register
cmsUInt16Number
Out
[
]
register
const
void
*
D
)
{
Curves16Data
*
Data
=
(
Curves16Data
*
)
D
;
int
i
;
for
(
i
=
0
;
i
<
Data
-
>
nCurves
;
i
+
+
)
{
Out
[
i
]
=
Data
-
>
Curves
[
i
]
[
In
[
i
]
]
;
}
}
static
void
FastIdentity16
(
register
const
cmsUInt16Number
In
[
]
register
cmsUInt16Number
Out
[
]
register
const
void
*
D
)
{
cmsPipeline
*
Lut
=
(
cmsPipeline
*
)
D
;
cmsUInt32Number
i
;
for
(
i
=
0
;
i
<
Lut
-
>
InputChannels
;
i
+
+
)
{
Out
[
i
]
=
In
[
i
]
;
}
}
static
cmsBool
OptimizeByJoiningCurves
(
cmsPipeline
*
*
Lut
cmsUInt32Number
Intent
cmsUInt32Number
*
InputFormat
cmsUInt32Number
*
OutputFormat
cmsUInt32Number
*
dwFlags
)
{
cmsToneCurve
*
*
GammaTables
=
NULL
;
cmsFloat32Number
InFloat
[
cmsMAXCHANNELS
]
OutFloat
[
cmsMAXCHANNELS
]
;
cmsUInt32Number
i
j
;
cmsPipeline
*
Src
=
*
Lut
;
cmsPipeline
*
Dest
=
NULL
;
cmsStage
*
mpe
;
cmsStage
*
ObtainedCurves
=
NULL
;
if
(
_cmsFormatterIsFloat
(
*
InputFormat
)
|
|
_cmsFormatterIsFloat
(
*
OutputFormat
)
)
return
FALSE
;
for
(
mpe
=
cmsPipelineGetPtrToFirstStage
(
Src
)
;
mpe
!
=
NULL
;
mpe
=
cmsStageNext
(
mpe
)
)
{
if
(
cmsStageType
(
mpe
)
!
=
cmsSigCurveSetElemType
)
return
FALSE
;
}
Dest
=
cmsPipelineAlloc
(
Src
-
>
ContextID
Src
-
>
InputChannels
Src
-
>
OutputChannels
)
;
if
(
Dest
=
=
NULL
)
return
FALSE
;
GammaTables
=
(
cmsToneCurve
*
*
)
_cmsCalloc
(
Src
-
>
ContextID
Src
-
>
InputChannels
sizeof
(
cmsToneCurve
*
)
)
;
if
(
GammaTables
=
=
NULL
)
goto
Error
;
for
(
i
=
0
;
i
<
Src
-
>
InputChannels
;
i
+
+
)
{
GammaTables
[
i
]
=
cmsBuildTabulatedToneCurve16
(
Src
-
>
ContextID
PRELINEARIZATION_POINTS
NULL
)
;
if
(
GammaTables
[
i
]
=
=
NULL
)
goto
Error
;
}
for
(
i
=
0
;
i
<
PRELINEARIZATION_POINTS
;
i
+
+
)
{
for
(
j
=
0
;
j
<
Src
-
>
InputChannels
;
j
+
+
)
InFloat
[
j
]
=
(
cmsFloat32Number
)
(
(
cmsFloat64Number
)
i
/
(
PRELINEARIZATION_POINTS
-
1
)
)
;
cmsPipelineEvalFloat
(
InFloat
OutFloat
Src
)
;
for
(
j
=
0
;
j
<
Src
-
>
InputChannels
;
j
+
+
)
GammaTables
[
j
]
-
>
Table16
[
i
]
=
_cmsQuickSaturateWord
(
OutFloat
[
j
]
*
65535
.
0
)
;
}
ObtainedCurves
=
cmsStageAllocToneCurves
(
Src
-
>
ContextID
Src
-
>
InputChannels
GammaTables
)
;
if
(
ObtainedCurves
=
=
NULL
)
goto
Error
;
for
(
i
=
0
;
i
<
Src
-
>
InputChannels
;
i
+
+
)
{
cmsFreeToneCurve
(
GammaTables
[
i
]
)
;
GammaTables
[
i
]
=
NULL
;
}
if
(
GammaTables
!
=
NULL
)
_cmsFree
(
Src
-
>
ContextID
GammaTables
)
;
if
(
!
AllCurvesAreLinear
(
ObtainedCurves
)
)
{
if
(
!
cmsPipelineInsertStage
(
Dest
cmsAT_BEGIN
ObtainedCurves
)
)
goto
Error
;
if
(
_cmsFormatterIs8bit
(
*
InputFormat
)
)
{
_cmsStageToneCurvesData
*
Data
=
(
_cmsStageToneCurvesData
*
)
ObtainedCurves
-
>
Data
;
Curves16Data
*
c16
=
CurvesAlloc
(
Dest
-
>
ContextID
Data
-
>
nCurves
256
Data
-
>
TheCurves
)
;
if
(
c16
=
=
NULL
)
goto
Error
;
*
dwFlags
|
=
cmsFLAGS_NOCACHE
;
_cmsPipelineSetOptimizationParameters
(
Dest
FastEvaluateCurves8
c16
CurvesFree
CurvesDup
)
;
}
else
{
_cmsStageToneCurvesData
*
Data
=
(
_cmsStageToneCurvesData
*
)
cmsStageData
(
ObtainedCurves
)
;
Curves16Data
*
c16
=
CurvesAlloc
(
Dest
-
>
ContextID
Data
-
>
nCurves
65536
Data
-
>
TheCurves
)
;
if
(
c16
=
=
NULL
)
goto
Error
;
*
dwFlags
|
=
cmsFLAGS_NOCACHE
;
_cmsPipelineSetOptimizationParameters
(
Dest
FastEvaluateCurves16
c16
CurvesFree
CurvesDup
)
;
}
}
else
{
cmsStageFree
(
ObtainedCurves
)
;
if
(
!
cmsPipelineInsertStage
(
Dest
cmsAT_BEGIN
cmsStageAllocIdentity
(
Dest
-
>
ContextID
Src
-
>
InputChannels
)
)
)
goto
Error
;
*
dwFlags
|
=
cmsFLAGS_NOCACHE
;
_cmsPipelineSetOptimizationParameters
(
Dest
FastIdentity16
(
void
*
)
Dest
NULL
NULL
)
;
}
cmsPipelineFree
(
Src
)
;
*
Lut
=
Dest
;
return
TRUE
;
Error
:
if
(
ObtainedCurves
!
=
NULL
)
cmsStageFree
(
ObtainedCurves
)
;
if
(
GammaTables
!
=
NULL
)
{
for
(
i
=
0
;
i
<
Src
-
>
InputChannels
;
i
+
+
)
{
if
(
GammaTables
[
i
]
!
=
NULL
)
cmsFreeToneCurve
(
GammaTables
[
i
]
)
;
}
_cmsFree
(
Src
-
>
ContextID
GammaTables
)
;
}
if
(
Dest
!
=
NULL
)
cmsPipelineFree
(
Dest
)
;
return
FALSE
;
cmsUNUSED_PARAMETER
(
Intent
)
;
cmsUNUSED_PARAMETER
(
InputFormat
)
;
cmsUNUSED_PARAMETER
(
OutputFormat
)
;
cmsUNUSED_PARAMETER
(
dwFlags
)
;
}
static
void
FreeMatShaper
(
cmsContext
ContextID
void
*
Data
)
{
if
(
Data
!
=
NULL
)
_cmsFree
(
ContextID
Data
)
;
}
static
void
*
DupMatShaper
(
cmsContext
ContextID
const
void
*
Data
)
{
return
_cmsDupMem
(
ContextID
Data
sizeof
(
MatShaper8Data
)
)
;
}
static
void
MatShaperEval16
(
register
const
cmsUInt16Number
In
[
]
register
cmsUInt16Number
Out
[
]
register
const
void
*
D
)
{
MatShaper8Data
*
p
=
(
MatShaper8Data
*
)
D
;
cmsS1Fixed14Number
l1
l2
l3
r
g
b
;
cmsUInt32Number
ri
gi
bi
;
ri
=
In
[
0
]
&
0xFF
;
gi
=
In
[
1
]
&
0xFF
;
bi
=
In
[
2
]
&
0xFF
;
r
=
p
-
>
Shaper1R
[
ri
]
;
g
=
p
-
>
Shaper1G
[
gi
]
;
b
=
p
-
>
Shaper1B
[
bi
]
;
l1
=
(
p
-
>
Mat
[
0
]
[
0
]
*
r
+
p
-
>
Mat
[
0
]
[
1
]
*
g
+
p
-
>
Mat
[
0
]
[
2
]
*
b
+
p
-
>
Off
[
0
]
+
0x2000
)
>
>
14
;
l2
=
(
p
-
>
Mat
[
1
]
[
0
]
*
r
+
p
-
>
Mat
[
1
]
[
1
]
*
g
+
p
-
>
Mat
[
1
]
[
2
]
*
b
+
p
-
>
Off
[
1
]
+
0x2000
)
>
>
14
;
l3
=
(
p
-
>
Mat
[
2
]
[
0
]
*
r
+
p
-
>
Mat
[
2
]
[
1
]
*
g
+
p
-
>
Mat
[
2
]
[
2
]
*
b
+
p
-
>
Off
[
2
]
+
0x2000
)
>
>
14
;
ri
=
(
l1
<
0
)
?
0
:
(
(
l1
>
16384
)
?
16384
:
l1
)
;
gi
=
(
l2
<
0
)
?
0
:
(
(
l2
>
16384
)
?
16384
:
l2
)
;
bi
=
(
l3
<
0
)
?
0
:
(
(
l3
>
16384
)
?
16384
:
l3
)
;
Out
[
0
]
=
p
-
>
Shaper2R
[
ri
]
;
Out
[
1
]
=
p
-
>
Shaper2G
[
gi
]
;
Out
[
2
]
=
p
-
>
Shaper2B
[
bi
]
;
}
static
cmsBool
FillFirstShaper
(
cmsS1Fixed14Number
*
Table
cmsToneCurve
*
Curve
)
{
int
i
;
cmsFloat32Number
R
y
;
for
(
i
=
0
;
i
<
256
;
i
+
+
)
{
R
=
(
cmsFloat32Number
)
(
i
/
255
.
0
)
;
y
=
cmsEvalToneCurveFloat
(
Curve
R
)
;
if
(
isinf
(
y
)
)
return
FALSE
;
Table
[
i
]
=
DOUBLE_TO_1FIXED14
(
y
)
;
}
return
TRUE
;
}
static
cmsBool
FillSecondShaper
(
cmsUInt16Number
*
Table
cmsToneCurve
*
Curve
cmsBool
Is8BitsOutput
)
{
int
i
;
cmsFloat32Number
R
Val
;
for
(
i
=
0
;
i
<
16385
;
i
+
+
)
{
R
=
(
cmsFloat32Number
)
(
i
/
16384
.
0
)
;
Val
=
cmsEvalToneCurveFloat
(
Curve
R
)
;
if
(
isinf
(
Val
)
)
return
FALSE
;
if
(
Is8BitsOutput
)
{
cmsUInt16Number
w
=
_cmsQuickSaturateWord
(
Val
*
65535
.
0
)
;
cmsUInt8Number
b
=
FROM_16_TO_8
(
w
)
;
Table
[
i
]
=
FROM_8_TO_16
(
b
)
;
}
else
Table
[
i
]
=
_cmsQuickSaturateWord
(
Val
*
65535
.
0
)
;
}
return
TRUE
;
}
static
cmsBool
SetMatShaper
(
cmsPipeline
*
Dest
cmsToneCurve
*
Curve1
[
3
]
cmsMAT3
*
Mat
cmsVEC3
*
Off
cmsToneCurve
*
Curve2
[
3
]
cmsUInt32Number
*
OutputFormat
)
{
MatShaper8Data
*
p
;
int
i
j
;
cmsBool
Is8Bits
=
_cmsFormatterIs8bit
(
*
OutputFormat
)
;
p
=
(
MatShaper8Data
*
)
_cmsMalloc
(
Dest
-
>
ContextID
sizeof
(
MatShaper8Data
)
)
;
if
(
p
=
=
NULL
)
return
FALSE
;
p
-
>
ContextID
=
Dest
-
>
ContextID
;
if
(
!
FillFirstShaper
(
p
-
>
Shaper1R
Curve1
[
0
]
)
)
goto
Error
;
if
(
!
FillFirstShaper
(
p
-
>
Shaper1G
Curve1
[
1
]
)
)
goto
Error
;
if
(
!
FillFirstShaper
(
p
-
>
Shaper1B
Curve1
[
2
]
)
)
goto
Error
;
if
(
!
FillSecondShaper
(
p
-
>
Shaper2R
Curve2
[
0
]
Is8Bits
)
)
goto
Error
;
if
(
!
FillSecondShaper
(
p
-
>
Shaper2G
Curve2
[
1
]
Is8Bits
)
)
goto
Error
;
if
(
!
FillSecondShaper
(
p
-
>
Shaper2B
Curve2
[
2
]
Is8Bits
)
)
goto
Error
;
for
(
i
=
0
;
i
<
3
;
i
+
+
)
{
for
(
j
=
0
;
j
<
3
;
j
+
+
)
{
p
-
>
Mat
[
i
]
[
j
]
=
DOUBLE_TO_1FIXED14
(
Mat
-
>
v
[
i
]
.
n
[
j
]
)
;
}
}
for
(
i
=
0
;
i
<
3
;
i
+
+
)
{
if
(
Off
=
=
NULL
)
{
p
-
>
Off
[
i
]
=
0
;
}
else
{
p
-
>
Off
[
i
]
=
DOUBLE_TO_1FIXED14
(
Off
-
>
n
[
i
]
)
;
}
}
if
(
Is8Bits
)
*
OutputFormat
|
=
OPTIMIZED_SH
(
1
)
;
_cmsPipelineSetOptimizationParameters
(
Dest
MatShaperEval16
(
void
*
)
p
FreeMatShaper
DupMatShaper
)
;
return
TRUE
;
Error
:
_cmsFree
(
Dest
-
>
ContextID
p
)
;
return
FALSE
;
}
static
cmsBool
OptimizeMatrixShaper
(
cmsPipeline
*
*
Lut
cmsUInt32Number
Intent
cmsUInt32Number
*
InputFormat
cmsUInt32Number
*
OutputFormat
cmsUInt32Number
*
dwFlags
)
{
cmsStage
*
Curve1
*
Curve2
;
cmsStage
*
Matrix1
*
Matrix2
;
_cmsStageMatrixData
*
Data1
;
_cmsStageMatrixData
*
Data2
;
cmsMAT3
res
;
cmsBool
IdentityMat
;
cmsPipeline
*
Dest
*
Src
;
if
(
T_CHANNELS
(
*
InputFormat
)
!
=
3
|
|
T_CHANNELS
(
*
OutputFormat
)
!
=
3
)
return
FALSE
;
if
(
!
_cmsFormatterIs8bit
(
*
InputFormat
)
)
return
FALSE
;
Src
=
*
Lut
;
if
(
!
cmsPipelineCheckAndRetreiveStages
(
Src
4
cmsSigCurveSetElemType
cmsSigMatrixElemType
cmsSigMatrixElemType
cmsSigCurveSetElemType
&
Curve1
&
Matrix1
&
Matrix2
&
Curve2
)
)
return
FALSE
;
Data1
=
(
_cmsStageMatrixData
*
)
cmsStageData
(
Matrix1
)
;
Data2
=
(
_cmsStageMatrixData
*
)
cmsStageData
(
Matrix2
)
;
if
(
Data1
-
>
Offset
!
=
NULL
)
return
FALSE
;
_cmsMAT3per
(
&
res
(
cmsMAT3
*
)
Data2
-
>
Double
(
cmsMAT3
*
)
Data1
-
>
Double
)
;
IdentityMat
=
FALSE
;
if
(
_cmsMAT3isIdentity
(
&
res
)
&
&
Data2
-
>
Offset
=
=
NULL
)
{
IdentityMat
=
TRUE
;
}
Dest
=
cmsPipelineAlloc
(
Src
-
>
ContextID
Src
-
>
InputChannels
Src
-
>
OutputChannels
)
;
if
(
!
Dest
)
return
FALSE
;
if
(
!
cmsPipelineInsertStage
(
Dest
cmsAT_BEGIN
cmsStageDup
(
Curve1
)
)
)
goto
Error
;
if
(
!
IdentityMat
)
if
(
!
cmsPipelineInsertStage
(
Dest
cmsAT_END
cmsStageAllocMatrix
(
Dest
-
>
ContextID
3
3
(
const
cmsFloat64Number
*
)
&
res
Data2
-
>
Offset
)
)
)
goto
Error
;
if
(
!
cmsPipelineInsertStage
(
Dest
cmsAT_END
cmsStageDup
(
Curve2
)
)
)
goto
Error
;
if
(
IdentityMat
)
{
OptimizeByJoiningCurves
(
&
Dest
Intent
InputFormat
OutputFormat
dwFlags
)
;
}
else
{
_cmsStageToneCurvesData
*
mpeC1
=
(
_cmsStageToneCurvesData
*
)
cmsStageData
(
Curve1
)
;
_cmsStageToneCurvesData
*
mpeC2
=
(
_cmsStageToneCurvesData
*
)
cmsStageData
(
Curve2
)
;
*
dwFlags
|
=
cmsFLAGS_NOCACHE
;
if
(
!
SetMatShaper
(
Dest
mpeC1
-
>
TheCurves
&
res
(
cmsVEC3
*
)
Data2
-
>
Offset
mpeC2
-
>
TheCurves
OutputFormat
)
)
goto
Error
;
}
cmsPipelineFree
(
Src
)
;
*
Lut
=
Dest
;
return
TRUE
;
Error
:
cmsPipelineFree
(
Dest
)
;
return
FALSE
;
}
typedef
struct
_cmsOptimizationCollection_st
{
_cmsOPToptimizeFn
OptimizePtr
;
struct
_cmsOptimizationCollection_st
*
Next
;
}
_cmsOptimizationCollection
;
static
_cmsOptimizationCollection
DefaultOptimization
[
]
=
{
{
OptimizeByJoiningCurves
&
DefaultOptimization
[
1
]
}
{
OptimizeMatrixShaper
&
DefaultOptimization
[
2
]
}
{
OptimizeByComputingLinearization
&
DefaultOptimization
[
3
]
}
{
OptimizeByResampling
NULL
}
}
;
_cmsOptimizationPluginChunkType
_cmsOptimizationPluginChunk
=
{
NULL
}
;
static
void
DupPluginOptimizationList
(
struct
_cmsContext_struct
*
ctx
const
struct
_cmsContext_struct
*
src
)
{
_cmsOptimizationPluginChunkType
newHead
=
{
NULL
}
;
_cmsOptimizationCollection
*
entry
;
_cmsOptimizationCollection
*
Anterior
=
NULL
;
_cmsOptimizationPluginChunkType
*
head
=
(
_cmsOptimizationPluginChunkType
*
)
src
-
>
chunks
[
OptimizationPlugin
]
;
_cmsAssert
(
ctx
!
=
NULL
)
;
_cmsAssert
(
head
!
=
NULL
)
;
for
(
entry
=
head
-
>
OptimizationCollection
;
entry
!
=
NULL
;
entry
=
entry
-
>
Next
)
{
_cmsOptimizationCollection
*
newEntry
=
(
_cmsOptimizationCollection
*
)
_cmsSubAllocDup
(
ctx
-
>
MemPool
entry
sizeof
(
_cmsOptimizationCollection
)
)
;
if
(
newEntry
=
=
NULL
)
return
;
newEntry
-
>
Next
=
NULL
;
if
(
Anterior
)
Anterior
-
>
Next
=
newEntry
;
Anterior
=
newEntry
;
if
(
newHead
.
OptimizationCollection
=
=
NULL
)
newHead
.
OptimizationCollection
=
newEntry
;
}
ctx
-
>
chunks
[
OptimizationPlugin
]
=
_cmsSubAllocDup
(
ctx
-
>
MemPool
&
newHead
sizeof
(
_cmsOptimizationPluginChunkType
)
)
;
}
void
_cmsAllocOptimizationPluginChunk
(
struct
_cmsContext_struct
*
ctx
const
struct
_cmsContext_struct
*
src
)
{
if
(
src
!
=
NULL
)
{
DupPluginOptimizationList
(
ctx
src
)
;
}
else
{
static
_cmsOptimizationPluginChunkType
OptimizationPluginChunkType
=
{
NULL
}
;
ctx
-
>
chunks
[
OptimizationPlugin
]
=
_cmsSubAllocDup
(
ctx
-
>
MemPool
&
OptimizationPluginChunkType
sizeof
(
_cmsOptimizationPluginChunkType
)
)
;
}
}
cmsBool
_cmsRegisterOptimizationPlugin
(
cmsContext
ContextID
cmsPluginBase
*
Data
)
{
cmsPluginOptimization
*
Plugin
=
(
cmsPluginOptimization
*
)
Data
;
_cmsOptimizationPluginChunkType
*
ctx
=
(
_cmsOptimizationPluginChunkType
*
)
_cmsContextGetClientChunk
(
ContextID
OptimizationPlugin
)
;
_cmsOptimizationCollection
*
fl
;
if
(
Data
=
=
NULL
)
{
ctx
-
>
OptimizationCollection
=
NULL
;
return
TRUE
;
}
if
(
Plugin
-
>
OptimizePtr
=
=
NULL
)
return
FALSE
;
fl
=
(
_cmsOptimizationCollection
*
)
_cmsPluginMalloc
(
ContextID
sizeof
(
_cmsOptimizationCollection
)
)
;
if
(
fl
=
=
NULL
)
return
FALSE
;
fl
-
>
OptimizePtr
=
Plugin
-
>
OptimizePtr
;
fl
-
>
Next
=
ctx
-
>
OptimizationCollection
;
ctx
-
>
OptimizationCollection
=
fl
;
return
TRUE
;
}
cmsBool
_cmsOptimizePipeline
(
cmsContext
ContextID
cmsPipeline
*
*
PtrLut
int
Intent
cmsUInt32Number
*
InputFormat
cmsUInt32Number
*
OutputFormat
cmsUInt32Number
*
dwFlags
)
{
_cmsOptimizationPluginChunkType
*
ctx
=
(
_cmsOptimizationPluginChunkType
*
)
_cmsContextGetClientChunk
(
ContextID
OptimizationPlugin
)
;
_cmsOptimizationCollection
*
Opts
;
cmsBool
AnySuccess
=
FALSE
;
if
(
*
dwFlags
&
cmsFLAGS_FORCE_CLUT
)
{
PreOptimize
(
*
PtrLut
)
;
return
OptimizeByResampling
(
PtrLut
Intent
InputFormat
OutputFormat
dwFlags
)
;
}
if
(
(
*
PtrLut
)
-
>
Elements
=
=
NULL
)
{
_cmsPipelineSetOptimizationParameters
(
*
PtrLut
FastIdentity16
(
void
*
)
*
PtrLut
NULL
NULL
)
;
return
TRUE
;
}
AnySuccess
=
PreOptimize
(
*
PtrLut
)
;
if
(
(
*
PtrLut
)
-
>
Elements
=
=
NULL
)
{
_cmsPipelineSetOptimizationParameters
(
*
PtrLut
FastIdentity16
(
void
*
)
*
PtrLut
NULL
NULL
)
;
return
TRUE
;
}
if
(
*
dwFlags
&
cmsFLAGS_NOOPTIMIZE
)
return
FALSE
;
for
(
Opts
=
ctx
-
>
OptimizationCollection
;
Opts
!
=
NULL
;
Opts
=
Opts
-
>
Next
)
{
if
(
Opts
-
>
OptimizePtr
(
PtrLut
Intent
InputFormat
OutputFormat
dwFlags
)
)
{
return
TRUE
;
}
}
for
(
Opts
=
DefaultOptimization
;
Opts
!
=
NULL
;
Opts
=
Opts
-
>
Next
)
{
if
(
Opts
-
>
OptimizePtr
(
PtrLut
Intent
InputFormat
OutputFormat
dwFlags
)
)
{
return
TRUE
;
}
}
return
AnySuccess
;
}
