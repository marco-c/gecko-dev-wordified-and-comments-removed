#
ifndef
PDFIUM_THIRD_PARTY_BASE_NUMERICS_SAFE_CONVERSIONS_H_
#
define
PDFIUM_THIRD_PARTY_BASE_NUMERICS_SAFE_CONVERSIONS_H_
#
include
<
stddef
.
h
>
#
include
<
limits
>
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
"
third_party
/
base
/
numerics
/
safe_conversions_impl
.
h
"
namespace
pdfium
{
namespace
base
{
template
<
typename
Dst
typename
Src
>
constexpr
bool
IsValueInRangeForNumericType
(
Src
value
)
{
return
internal
:
:
DstRangeRelationToSrcRange
<
Dst
>
(
value
)
.
IsValid
(
)
;
}
struct
CheckOnFailure
{
template
<
typename
T
>
static
T
HandleFailure
(
)
{
#
if
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
__builtin_trap
(
)
;
#
else
(
(
void
)
(
*
(
volatile
char
*
)
0
=
0
)
)
;
#
endif
return
T
(
)
;
}
}
;
template
<
typename
Dst
class
CheckHandler
=
CheckOnFailure
typename
Src
>
constexpr
Dst
checked_cast
(
Src
value
)
{
using
SrcType
=
typename
internal
:
:
UnderlyingType
<
Src
>
:
:
type
;
return
IsValueInRangeForNumericType
<
Dst
SrcType
>
(
value
)
?
static_cast
<
Dst
>
(
static_cast
<
SrcType
>
(
value
)
)
:
CheckHandler
:
:
template
HandleFailure
<
Dst
>
(
)
;
}
template
<
typename
T
>
struct
SaturationDefaultHandler
{
static
constexpr
T
NaN
(
)
{
return
std
:
:
numeric_limits
<
T
>
:
:
has_quiet_NaN
?
std
:
:
numeric_limits
<
T
>
:
:
quiet_NaN
(
)
:
T
(
)
;
}
static
constexpr
T
max
(
)
{
return
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
;
}
static
constexpr
T
Overflow
(
)
{
return
std
:
:
numeric_limits
<
T
>
:
:
has_infinity
?
std
:
:
numeric_limits
<
T
>
:
:
infinity
(
)
:
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
;
}
static
constexpr
T
lowest
(
)
{
return
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
;
}
static
constexpr
T
Underflow
(
)
{
return
std
:
:
numeric_limits
<
T
>
:
:
has_infinity
?
std
:
:
numeric_limits
<
T
>
:
:
infinity
(
)
*
-
1
:
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
;
}
}
;
namespace
internal
{
template
<
typename
Dst
template
<
typename
>
class
S
typename
Src
>
constexpr
Dst
saturated_cast_impl
(
Src
value
RangeCheck
constraint
)
{
return
!
constraint
.
IsOverflowFlagSet
(
)
?
(
!
constraint
.
IsUnderflowFlagSet
(
)
?
static_cast
<
Dst
>
(
value
)
:
S
<
Dst
>
:
:
Underflow
(
)
)
:
(
std
:
:
is_integral
<
Src
>
:
:
value
|
|
!
constraint
.
IsUnderflowFlagSet
(
)
?
S
<
Dst
>
:
:
Overflow
(
)
:
S
<
Dst
>
:
:
NaN
(
)
)
;
}
template
<
typename
Dst
template
<
typename
>
class
SaturationHandler
=
SaturationDefaultHandler
typename
Src
>
constexpr
Dst
saturated_cast
(
Src
value
)
{
using
SrcType
=
typename
UnderlyingType
<
Src
>
:
:
type
;
return
saturated_cast_impl
<
Dst
SaturationHandler
SrcType
>
(
value
DstRangeRelationToSrcRange
<
Dst
SaturationHandler
SrcType
>
(
value
)
)
;
}
template
<
typename
Dst
typename
Src
>
constexpr
Dst
strict_cast
(
Src
value
)
{
using
SrcType
=
typename
UnderlyingType
<
Src
>
:
:
type
;
static_assert
(
UnderlyingType
<
Src
>
:
:
is_numeric
"
Argument
must
be
numeric
.
"
)
;
static_assert
(
std
:
:
is_arithmetic
<
Dst
>
:
:
value
"
Result
must
be
numeric
.
"
)
;
static_assert
(
StaticDstRangeRelationToSrcRange
<
Dst
SrcType
>
:
:
value
=
=
NUMERIC_RANGE_CONTAINED
"
The
source
type
is
out
of
range
for
the
destination
type
.
"
"
Please
see
strict_cast
<
>
comments
for
more
information
.
"
)
;
return
static_cast
<
Dst
>
(
static_cast
<
SrcType
>
(
value
)
)
;
}
template
<
typename
Dst
typename
Src
class
Enable
=
void
>
struct
IsNumericRangeContained
{
static
const
bool
value
=
false
;
}
;
template
<
typename
Dst
typename
Src
>
struct
IsNumericRangeContained
<
Dst
Src
typename
std
:
:
enable_if
<
ArithmeticOrUnderlyingEnum
<
Dst
>
:
:
value
&
&
ArithmeticOrUnderlyingEnum
<
Src
>
:
:
value
>
:
:
type
>
{
static
const
bool
value
=
StaticDstRangeRelationToSrcRange
<
Dst
Src
>
:
:
value
=
=
NUMERIC_RANGE_CONTAINED
;
}
;
template
<
typename
T
>
class
StrictNumeric
{
public
:
using
type
=
T
;
constexpr
StrictNumeric
(
)
:
value_
(
0
)
{
}
template
<
typename
Src
>
constexpr
StrictNumeric
(
const
StrictNumeric
<
Src
>
&
rhs
)
:
value_
(
strict_cast
<
T
>
(
rhs
.
value_
)
)
{
}
template
<
typename
Src
>
constexpr
StrictNumeric
(
Src
value
)
:
value_
(
strict_cast
<
T
>
(
value
)
)
{
}
template
<
typename
Dst
typename
std
:
:
enable_if
<
IsNumericRangeContained
<
Dst
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
constexpr
operator
Dst
(
)
const
{
return
static_cast
<
typename
ArithmeticOrUnderlyingEnum
<
Dst
>
:
:
type
>
(
value_
)
;
}
private
:
const
T
value_
;
}
;
template
<
typename
T
>
constexpr
StrictNumeric
<
typename
UnderlyingType
<
T
>
:
:
type
>
MakeStrictNum
(
const
T
value
)
{
return
value
;
}
template
<
typename
T
>
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
StrictNumeric
<
T
>
&
value
)
{
os
<
<
static_cast
<
T
>
(
value
)
;
return
os
;
}
#
define
STRICT_COMPARISON_OP
(
NAME
OP
)
\
template
<
typename
L
typename
R
\
typename
std
:
:
enable_if
<
\
internal
:
:
IsStrictOp
<
L
R
>
:
:
value
>
:
:
type
*
=
nullptr
>
\
constexpr
bool
operator
OP
(
const
L
lhs
const
R
rhs
)
{
\
return
SafeCompare
<
NAME
typename
UnderlyingType
<
L
>
:
:
type
\
typename
UnderlyingType
<
R
>
:
:
type
>
(
lhs
rhs
)
;
\
}
STRICT_COMPARISON_OP
(
IsLess
<
)
;
STRICT_COMPARISON_OP
(
IsLessOrEqual
<
=
)
;
STRICT_COMPARISON_OP
(
IsGreater
>
)
;
STRICT_COMPARISON_OP
(
IsGreaterOrEqual
>
=
)
;
STRICT_COMPARISON_OP
(
IsEqual
=
=
)
;
STRICT_COMPARISON_OP
(
IsNotEqual
!
=
)
;
#
undef
STRICT_COMPARISON_OP
}
;
using
internal
:
:
strict_cast
;
using
internal
:
:
saturated_cast
;
using
internal
:
:
SafeUnsignedAbs
;
using
internal
:
:
StrictNumeric
;
using
internal
:
:
MakeStrictNum
;
using
internal
:
:
IsValueNegative
;
using
SizeT
=
StrictNumeric
<
size_t
>
;
}
}
#
endif
