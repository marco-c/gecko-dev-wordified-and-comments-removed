#
ifndef
PDFIUM_THIRD_PARTY_BASE_NUMERICS_SAFE_MATH_H_
#
define
PDFIUM_THIRD_PARTY_BASE_NUMERICS_SAFE_MATH_H_
#
include
<
stddef
.
h
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
third_party
/
base
/
numerics
/
safe_math_impl
.
h
"
namespace
pdfium
{
namespace
base
{
namespace
internal
{
template
<
typename
T
>
class
CheckedNumeric
{
static_assert
(
std
:
:
is_arithmetic
<
T
>
:
:
value
"
CheckedNumeric
<
T
>
:
T
must
be
a
numeric
type
.
"
)
;
public
:
using
type
=
T
;
constexpr
CheckedNumeric
(
)
{
}
template
<
typename
Src
>
constexpr
CheckedNumeric
(
const
CheckedNumeric
<
Src
>
&
rhs
)
:
state_
(
rhs
.
state_
.
value
(
)
rhs
.
IsValid
(
)
)
{
}
template
<
typename
Src
>
friend
class
CheckedNumeric
;
template
<
typename
Src
>
constexpr
CheckedNumeric
(
Src
value
)
:
state_
(
value
)
{
static_assert
(
std
:
:
is_arithmetic
<
Src
>
:
:
value
"
Argument
must
be
numeric
.
"
)
;
}
template
<
typename
Src
>
constexpr
CheckedNumeric
(
StrictNumeric
<
Src
>
value
)
:
state_
(
static_cast
<
Src
>
(
value
)
)
{
}
template
<
typename
Dst
=
T
>
constexpr
bool
IsValid
(
)
const
{
return
state_
.
is_valid
(
)
&
&
IsValueInRangeForNumericType
<
Dst
>
(
state_
.
value
(
)
)
;
}
template
<
typename
Dst
>
constexpr
bool
AssignIfValid
(
Dst
*
result
)
const
{
return
IsValid
<
Dst
>
(
)
?
(
(
*
result
=
static_cast
<
Dst
>
(
state_
.
value
(
)
)
)
true
)
:
false
;
}
template
<
typename
Dst
=
T
class
CheckHandler
=
CheckOnFailure
>
constexpr
StrictNumeric
<
Dst
>
ValueOrDie
(
)
const
{
return
IsValid
<
Dst
>
(
)
?
static_cast
<
Dst
>
(
state_
.
value
(
)
)
:
CheckHandler
:
:
template
HandleFailure
<
Dst
>
(
)
;
}
template
<
typename
Dst
=
T
typename
Src
>
constexpr
StrictNumeric
<
Dst
>
ValueOrDefault
(
const
Src
default_value
)
const
{
return
IsValid
<
Dst
>
(
)
?
static_cast
<
Dst
>
(
state_
.
value
(
)
)
:
checked_cast
<
Dst
>
(
default_value
)
;
}
template
<
typename
Dst
>
constexpr
CheckedNumeric
<
typename
UnderlyingType
<
Dst
>
:
:
type
>
Cast
(
)
const
{
return
*
this
;
}
template
<
typename
U
>
friend
U
GetNumericValueForTest
(
const
CheckedNumeric
<
U
>
&
src
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
+
=
(
const
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
-
=
(
const
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
*
=
(
const
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
/
=
(
const
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
%
=
(
const
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
<
<
=
(
const
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
>
>
=
(
const
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
&
=
(
const
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
|
=
(
const
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
^
=
(
const
Src
rhs
)
;
constexpr
CheckedNumeric
operator
-
(
)
const
{
return
CheckedNumeric
<
T
>
(
NegateWrapper
(
state_
.
value
(
)
)
IsValid
(
)
&
&
(
!
std
:
:
is_signed
<
T
>
:
:
value
|
|
std
:
:
is_floating_point
<
T
>
:
:
value
|
|
NegateWrapper
(
state_
.
value
(
)
)
!
=
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
)
)
;
}
constexpr
CheckedNumeric
operator
~
(
)
const
{
return
CheckedNumeric
<
decltype
(
InvertWrapper
(
T
(
)
)
)
>
(
InvertWrapper
(
state_
.
value
(
)
)
IsValid
(
)
)
;
}
constexpr
CheckedNumeric
Abs
(
)
const
{
return
CheckedNumeric
<
T
>
(
AbsWrapper
(
state_
.
value
(
)
)
IsValid
(
)
&
&
(
!
std
:
:
is_signed
<
T
>
:
:
value
|
|
std
:
:
is_floating_point
<
T
>
:
:
value
|
|
AbsWrapper
(
state_
.
value
(
)
)
!
=
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
)
)
;
}
template
<
typename
U
>
constexpr
CheckedNumeric
<
typename
MathWrapper
<
CheckedMaxOp
T
U
>
:
:
type
>
Max
(
const
U
rhs
)
const
{
using
R
=
typename
UnderlyingType
<
U
>
:
:
type
;
using
result_type
=
typename
MathWrapper
<
CheckedMaxOp
T
U
>
:
:
type
;
return
CheckedNumeric
<
result_type
>
(
static_cast
<
result_type
>
(
IsGreater
<
T
R
>
:
:
Test
(
state_
.
value
(
)
Wrapper
<
U
>
:
:
value
(
rhs
)
)
?
state_
.
value
(
)
:
Wrapper
<
U
>
:
:
value
(
rhs
)
)
state_
.
is_valid
(
)
&
&
Wrapper
<
U
>
:
:
is_valid
(
rhs
)
)
;
}
template
<
typename
U
>
constexpr
CheckedNumeric
<
typename
MathWrapper
<
CheckedMinOp
T
U
>
:
:
type
>
Min
(
const
U
rhs
)
const
{
using
R
=
typename
UnderlyingType
<
U
>
:
:
type
;
using
result_type
=
typename
MathWrapper
<
CheckedMinOp
T
U
>
:
:
type
;
return
CheckedNumeric
<
result_type
>
(
static_cast
<
result_type
>
(
IsLess
<
T
R
>
:
:
Test
(
state_
.
value
(
)
Wrapper
<
U
>
:
:
value
(
rhs
)
)
?
state_
.
value
(
)
:
Wrapper
<
U
>
:
:
value
(
rhs
)
)
state_
.
is_valid
(
)
&
&
Wrapper
<
U
>
:
:
is_valid
(
rhs
)
)
;
}
constexpr
CheckedNumeric
<
typename
UnsignedOrFloatForSize
<
T
>
:
:
type
>
UnsignedAbs
(
)
const
{
return
CheckedNumeric
<
typename
UnsignedOrFloatForSize
<
T
>
:
:
type
>
(
SafeUnsignedAbs
(
state_
.
value
(
)
)
state_
.
is_valid
(
)
)
;
}
CheckedNumeric
&
operator
+
+
(
)
{
*
this
+
=
1
;
return
*
this
;
}
CheckedNumeric
operator
+
+
(
int
)
{
CheckedNumeric
value
=
*
this
;
*
this
+
=
1
;
return
value
;
}
CheckedNumeric
&
operator
-
-
(
)
{
*
this
-
=
1
;
return
*
this
;
}
CheckedNumeric
operator
-
-
(
int
)
{
CheckedNumeric
value
=
*
this
;
*
this
-
=
1
;
return
value
;
}
template
<
template
<
typename
typename
typename
>
class
M
typename
L
typename
R
>
static
CheckedNumeric
MathOp
(
const
L
lhs
const
R
rhs
)
{
using
Math
=
typename
MathWrapper
<
M
L
R
>
:
:
math
;
T
result
=
0
;
bool
is_valid
=
Wrapper
<
L
>
:
:
is_valid
(
lhs
)
&
&
Wrapper
<
R
>
:
:
is_valid
(
rhs
)
&
&
Math
:
:
Do
(
Wrapper
<
L
>
:
:
value
(
lhs
)
Wrapper
<
R
>
:
:
value
(
rhs
)
&
result
)
;
return
CheckedNumeric
<
T
>
(
result
is_valid
)
;
}
;
template
<
template
<
typename
typename
typename
>
class
M
typename
R
>
CheckedNumeric
&
MathOp
(
const
R
rhs
)
{
using
Math
=
typename
MathWrapper
<
M
T
R
>
:
:
math
;
T
result
=
0
;
bool
is_valid
=
state_
.
is_valid
(
)
&
&
Wrapper
<
R
>
:
:
is_valid
(
rhs
)
&
&
Math
:
:
Do
(
state_
.
value
(
)
Wrapper
<
R
>
:
:
value
(
rhs
)
&
result
)
;
*
this
=
CheckedNumeric
<
T
>
(
result
is_valid
)
;
return
*
this
;
}
;
private
:
CheckedNumericState
<
T
>
state_
;
template
<
typename
Src
>
constexpr
CheckedNumeric
(
Src
value
bool
is_valid
)
:
state_
(
value
is_valid
)
{
}
template
<
typename
Src
>
struct
Wrapper
{
static
constexpr
bool
is_valid
(
Src
)
{
return
true
;
}
static
constexpr
Src
value
(
Src
value
)
{
return
value
;
}
}
;
template
<
typename
Src
>
struct
Wrapper
<
CheckedNumeric
<
Src
>
>
{
static
constexpr
bool
is_valid
(
const
CheckedNumeric
<
Src
>
v
)
{
return
v
.
IsValid
(
)
;
}
static
constexpr
Src
value
(
const
CheckedNumeric
<
Src
>
v
)
{
return
v
.
state_
.
value
(
)
;
}
}
;
template
<
typename
Src
>
struct
Wrapper
<
StrictNumeric
<
Src
>
>
{
static
constexpr
bool
is_valid
(
const
StrictNumeric
<
Src
>
)
{
return
true
;
}
static
constexpr
Src
value
(
const
StrictNumeric
<
Src
>
v
)
{
return
static_cast
<
Src
>
(
v
)
;
}
}
;
}
;
template
<
typename
Dst
typename
Src
>
constexpr
bool
IsValidForType
(
const
CheckedNumeric
<
Src
>
value
)
{
return
value
.
template
IsValid
<
Dst
>
(
)
;
}
template
<
typename
Dst
typename
Src
>
constexpr
StrictNumeric
<
Dst
>
ValueOrDieForType
(
const
CheckedNumeric
<
Src
>
value
)
{
return
value
.
template
ValueOrDie
<
Dst
>
(
)
;
}
template
<
typename
Dst
typename
Src
typename
Default
>
constexpr
StrictNumeric
<
Dst
>
ValueOrDefaultForType
(
const
CheckedNumeric
<
Src
>
value
const
Default
default_value
)
{
return
value
.
template
ValueOrDefault
<
Dst
>
(
default_value
)
;
}
template
<
template
<
typename
typename
typename
>
class
M
typename
L
typename
R
typename
.
.
.
Args
>
struct
ResultType
;
template
<
template
<
typename
typename
typename
>
class
M
typename
L
typename
R
>
struct
ResultType
<
M
L
R
>
{
using
type
=
typename
MathWrapper
<
M
L
R
>
:
:
type
;
}
;
template
<
template
<
typename
typename
typename
>
class
M
typename
L
typename
R
typename
.
.
.
Args
>
struct
ResultType
{
using
type
=
typename
ResultType
<
M
typename
ResultType
<
M
L
R
>
:
:
type
Args
.
.
.
>
:
:
type
;
}
;
template
<
typename
T
>
constexpr
CheckedNumeric
<
typename
UnderlyingType
<
T
>
:
:
type
>
MakeCheckedNum
(
const
T
value
)
{
return
value
;
}
template
<
template
<
typename
typename
typename
>
class
M
typename
L
typename
R
>
CheckedNumeric
<
typename
MathWrapper
<
M
L
R
>
:
:
type
>
ChkMathOp
(
const
L
lhs
const
R
rhs
)
{
using
Math
=
typename
MathWrapper
<
M
L
R
>
:
:
math
;
return
CheckedNumeric
<
typename
Math
:
:
result_type
>
:
:
template
MathOp
<
M
>
(
lhs
rhs
)
;
}
template
<
template
<
typename
typename
typename
>
class
M
typename
L
typename
R
typename
.
.
.
Args
>
CheckedNumeric
<
typename
ResultType
<
M
L
R
Args
.
.
.
>
:
:
type
>
ChkMathOp
(
const
L
lhs
const
R
rhs
const
Args
.
.
.
args
)
{
auto
tmp
=
ChkMathOp
<
M
>
(
lhs
rhs
)
;
return
tmp
.
IsValid
(
)
?
ChkMathOp
<
M
>
(
tmp
args
.
.
.
)
:
decltype
(
ChkMathOp
<
M
>
(
tmp
args
.
.
.
)
)
(
tmp
)
;
}
;
#
define
BASE_NUMERIC_ARITHMETIC_VARIADIC
(
NAME
)
\
template
<
typename
L
typename
R
typename
.
.
.
Args
>
\
CheckedNumeric
<
typename
ResultType
<
Checked
#
#
NAME
#
#
Op
L
R
Args
.
.
.
>
:
:
type
>
\
Check
#
#
NAME
(
const
L
lhs
const
R
rhs
const
Args
.
.
.
args
)
{
\
return
ChkMathOp
<
Checked
#
#
NAME
#
#
Op
L
R
Args
.
.
.
>
(
lhs
rhs
args
.
.
.
)
;
\
}
#
define
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
NAME
OP
COMPOUND_OP
)
\
template
<
typename
L
typename
R
\
typename
std
:
:
enable_if
<
IsCheckedOp
<
L
R
>
:
:
value
>
:
:
type
*
=
\
nullptr
>
\
CheckedNumeric
<
typename
MathWrapper
<
Checked
#
#
NAME
#
#
Op
L
R
>
:
:
type
>
\
operator
OP
(
const
L
lhs
const
R
rhs
)
{
\
return
decltype
(
lhs
OP
rhs
)
:
:
template
MathOp
<
Checked
#
#
NAME
#
#
Op
>
(
lhs
rhs
)
;
\
}
\
/
*
Assignment
arithmetic
operator
implementation
from
CheckedNumeric
.
*
/
\
template
<
typename
L
>
\
template
<
typename
R
>
\
CheckedNumeric
<
L
>
&
CheckedNumeric
<
L
>
:
:
operator
COMPOUND_OP
(
const
R
rhs
)
{
\
return
MathOp
<
Checked
#
#
NAME
#
#
Op
>
(
rhs
)
;
\
}
\
/
*
Variadic
arithmetic
functions
that
return
CheckedNumeric
.
*
/
\
BASE_NUMERIC_ARITHMETIC_VARIADIC
(
NAME
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Add
+
+
=
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Sub
-
-
=
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Mul
*
*
=
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Div
/
/
=
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Mod
%
%
=
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Lsh
<
<
<
<
=
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Rsh
>
>
>
>
=
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
And
&
&
=
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Or
|
|
=
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Xor
^
^
=
)
BASE_NUMERIC_ARITHMETIC_VARIADIC
(
Max
)
BASE_NUMERIC_ARITHMETIC_VARIADIC
(
Min
)
#
undef
BASE_NUMERIC_ARITHMETIC_VARIADIC
#
undef
BASE_NUMERIC_ARITHMETIC_OPERATORS
template
<
typename
L
typename
R
>
L
*
operator
+
(
L
*
lhs
const
StrictNumeric
<
R
>
rhs
)
{
uintptr_t
result
=
CheckAdd
(
reinterpret_cast
<
uintptr_t
>
(
lhs
)
CheckMul
(
sizeof
(
L
)
static_cast
<
R
>
(
rhs
)
)
)
.
template
ValueOrDie
<
uintptr_t
>
(
)
;
return
reinterpret_cast
<
L
*
>
(
result
)
;
}
template
<
typename
L
typename
R
>
L
*
operator
-
(
L
*
lhs
const
StrictNumeric
<
R
>
rhs
)
{
uintptr_t
result
=
CheckSub
(
reinterpret_cast
<
uintptr_t
>
(
lhs
)
CheckMul
(
sizeof
(
L
)
static_cast
<
R
>
(
rhs
)
)
)
.
template
ValueOrDie
<
uintptr_t
>
(
)
;
return
reinterpret_cast
<
L
*
>
(
result
)
;
}
}
using
internal
:
:
CheckedNumeric
;
using
internal
:
:
IsValidForType
;
using
internal
:
:
ValueOrDieForType
;
using
internal
:
:
ValueOrDefaultForType
;
using
internal
:
:
MakeCheckedNum
;
using
internal
:
:
CheckMax
;
using
internal
:
:
CheckMin
;
using
internal
:
:
CheckAdd
;
using
internal
:
:
CheckSub
;
using
internal
:
:
CheckMul
;
using
internal
:
:
CheckDiv
;
using
internal
:
:
CheckMod
;
using
internal
:
:
CheckLsh
;
using
internal
:
:
CheckRsh
;
using
internal
:
:
CheckAnd
;
using
internal
:
:
CheckOr
;
using
internal
:
:
CheckXor
;
}
}
#
endif
