#
ifndef
PDFIUM_THIRD_PARTY_BASE_NUMERICS_SAFE_MATH_IMPL_H_
#
define
PDFIUM_THIRD_PARTY_BASE_NUMERICS_SAFE_MATH_IMPL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
climits
>
#
include
<
cmath
>
#
include
<
cstdlib
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
third_party
/
base
/
numerics
/
safe_conversions
.
h
"
namespace
pdfium
{
namespace
base
{
namespace
internal
{
template
<
typename
Numeric
bool
IsInteger
=
std
:
:
is_integral
<
Numeric
>
:
:
value
bool
IsFloat
=
std
:
:
is_floating_point
<
Numeric
>
:
:
value
>
struct
UnsignedOrFloatForSize
;
template
<
typename
Numeric
>
struct
UnsignedOrFloatForSize
<
Numeric
true
false
>
{
using
type
=
typename
std
:
:
make_unsigned
<
Numeric
>
:
:
type
;
}
;
template
<
typename
Numeric
>
struct
UnsignedOrFloatForSize
<
Numeric
false
true
>
{
using
type
=
Numeric
;
}
;
#
if
defined
(
__has_builtin
)
#
define
USE_OVERFLOW_BUILTINS
(
__has_builtin
(
__builtin_add_overflow
)
)
#
elif
defined
(
__GNUC__
)
#
define
USE_OVERFLOW_BUILTINS
(
__GNUC__
>
=
5
)
#
else
#
define
USE_OVERFLOW_BUILTINS
(
0
)
#
endif
template
<
typename
T
>
bool
CheckedAddImpl
(
T
x
T
y
T
*
result
)
{
static_assert
(
std
:
:
is_integral
<
T
>
:
:
value
"
Type
must
be
integral
"
)
;
using
UnsignedDst
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
using
SignedDst
=
typename
std
:
:
make_signed
<
T
>
:
:
type
;
UnsignedDst
ux
=
static_cast
<
UnsignedDst
>
(
x
)
;
UnsignedDst
uy
=
static_cast
<
UnsignedDst
>
(
y
)
;
UnsignedDst
uresult
=
static_cast
<
UnsignedDst
>
(
ux
+
uy
)
;
*
result
=
static_cast
<
T
>
(
uresult
)
;
return
(
std
:
:
is_signed
<
T
>
:
:
value
)
?
static_cast
<
SignedDst
>
(
(
uresult
^
ux
)
&
(
uresult
^
uy
)
)
>
=
0
:
uresult
>
=
uy
;
}
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedAddOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedAddOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_integral
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
bool
Do
(
T
x
U
y
V
*
result
)
{
#
if
USE_OVERFLOW_BUILTINS
return
!
__builtin_add_overflow
(
x
y
result
)
;
#
else
using
Promotion
=
typename
BigEnoughPromotion
<
T
U
>
:
:
type
;
Promotion
presult
;
bool
is_valid
=
IsValueInRangeForNumericType
<
Promotion
>
(
x
)
&
&
IsValueInRangeForNumericType
<
Promotion
>
(
y
)
;
if
(
IsIntegerArithmeticSafe
<
Promotion
T
U
>
:
:
value
)
{
presult
=
static_cast
<
Promotion
>
(
x
)
+
static_cast
<
Promotion
>
(
y
)
;
}
else
{
is_valid
&
=
CheckedAddImpl
(
static_cast
<
Promotion
>
(
x
)
static_cast
<
Promotion
>
(
y
)
&
presult
)
;
}
*
result
=
static_cast
<
V
>
(
presult
)
;
return
is_valid
&
&
IsValueInRangeForNumericType
<
V
>
(
presult
)
;
#
endif
}
}
;
template
<
typename
T
>
bool
CheckedSubImpl
(
T
x
T
y
T
*
result
)
{
static_assert
(
std
:
:
is_integral
<
T
>
:
:
value
"
Type
must
be
integral
"
)
;
using
UnsignedDst
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
using
SignedDst
=
typename
std
:
:
make_signed
<
T
>
:
:
type
;
UnsignedDst
ux
=
static_cast
<
UnsignedDst
>
(
x
)
;
UnsignedDst
uy
=
static_cast
<
UnsignedDst
>
(
y
)
;
UnsignedDst
uresult
=
static_cast
<
UnsignedDst
>
(
ux
-
uy
)
;
*
result
=
static_cast
<
T
>
(
uresult
)
;
return
(
std
:
:
is_signed
<
T
>
:
:
value
)
?
static_cast
<
SignedDst
>
(
(
uresult
^
ux
)
&
(
ux
^
uy
)
)
>
=
0
:
x
>
=
y
;
}
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedSubOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedSubOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_integral
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
bool
Do
(
T
x
U
y
V
*
result
)
{
#
if
USE_OVERFLOW_BUILTINS
return
!
__builtin_sub_overflow
(
x
y
result
)
;
#
else
using
Promotion
=
typename
BigEnoughPromotion
<
T
U
>
:
:
type
;
Promotion
presult
;
bool
is_valid
=
IsValueInRangeForNumericType
<
Promotion
>
(
x
)
&
&
IsValueInRangeForNumericType
<
Promotion
>
(
y
)
;
if
(
IsIntegerArithmeticSafe
<
Promotion
T
U
>
:
:
value
)
{
presult
=
static_cast
<
Promotion
>
(
x
)
-
static_cast
<
Promotion
>
(
y
)
;
}
else
{
is_valid
&
=
CheckedSubImpl
(
static_cast
<
Promotion
>
(
x
)
static_cast
<
Promotion
>
(
y
)
&
presult
)
;
}
*
result
=
static_cast
<
V
>
(
presult
)
;
return
is_valid
&
&
IsValueInRangeForNumericType
<
V
>
(
presult
)
;
#
endif
}
}
;
template
<
typename
T
>
bool
CheckedMulImpl
(
T
x
T
y
T
*
result
)
{
static_assert
(
std
:
:
is_integral
<
T
>
:
:
value
"
Type
must
be
integral
"
)
;
using
UnsignedDst
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
using
SignedDst
=
typename
std
:
:
make_signed
<
T
>
:
:
type
;
const
UnsignedDst
ux
=
SafeUnsignedAbs
(
x
)
;
const
UnsignedDst
uy
=
SafeUnsignedAbs
(
y
)
;
UnsignedDst
uresult
=
static_cast
<
UnsignedDst
>
(
ux
*
uy
)
;
const
bool
is_negative
=
std
:
:
is_signed
<
T
>
:
:
value
&
&
static_cast
<
SignedDst
>
(
x
^
y
)
<
0
;
*
result
=
is_negative
?
0
-
uresult
:
uresult
;
return
uy
<
=
UnsignedDst
(
!
std
:
:
is_signed
<
T
>
:
:
value
|
|
is_negative
)
|
|
ux
<
=
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
+
UnsignedDst
(
is_negative
)
)
/
uy
;
}
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedMulOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedMulOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_integral
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
bool
Do
(
T
x
U
y
V
*
result
)
{
#
if
USE_OVERFLOW_BUILTINS
#
if
defined
(
__clang__
)
static
const
bool
kUseMaxInt
=
std
:
:
numeric_limits
<
__typeof__
(
x
*
y
)
>
:
:
digits
<
std
:
:
numeric_limits
<
intptr_t
>
:
:
digits
|
|
(
IntegerBitsPlusSign
<
__typeof__
(
x
*
y
)
>
:
:
value
=
=
IntegerBitsPlusSign
<
intptr_t
>
:
:
value
&
&
std
:
:
is_signed
<
T
>
:
:
value
=
=
std
:
:
is_signed
<
U
>
:
:
value
)
;
#
else
static
const
bool
kUseMaxInt
=
true
;
#
endif
if
(
kUseMaxInt
)
return
!
__builtin_mul_overflow
(
x
y
result
)
;
#
endif
using
Promotion
=
typename
FastIntegerArithmeticPromotion
<
T
U
>
:
:
type
;
Promotion
presult
;
bool
is_valid
=
IsValueInRangeForNumericType
<
Promotion
>
(
x
)
&
&
IsValueInRangeForNumericType
<
Promotion
>
(
y
)
;
if
(
IsIntegerArithmeticSafe
<
Promotion
T
U
>
:
:
value
)
{
presult
=
static_cast
<
Promotion
>
(
x
)
*
static_cast
<
Promotion
>
(
y
)
;
}
else
{
is_valid
&
=
CheckedMulImpl
(
static_cast
<
Promotion
>
(
x
)
static_cast
<
Promotion
>
(
y
)
&
presult
)
;
}
*
result
=
static_cast
<
V
>
(
presult
)
;
return
is_valid
&
&
IsValueInRangeForNumericType
<
V
>
(
presult
)
;
}
}
;
#
undef
USE_OVERFLOW_BUILTINS
template
<
typename
T
>
bool
CheckedDivImpl
(
T
x
T
y
T
*
result
)
{
static_assert
(
std
:
:
is_integral
<
T
>
:
:
value
"
Type
must
be
integral
"
)
;
if
(
y
&
&
(
!
std
:
:
is_signed
<
T
>
:
:
value
|
|
x
!
=
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
|
|
y
!
=
static_cast
<
T
>
(
-
1
)
)
)
{
*
result
=
x
/
y
;
return
true
;
}
return
false
;
}
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedDivOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedDivOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_integral
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
bool
Do
(
T
x
U
y
V
*
result
)
{
using
Promotion
=
typename
BigEnoughPromotion
<
T
U
>
:
:
type
;
Promotion
presult
;
bool
is_valid
=
IsValueInRangeForNumericType
<
Promotion
>
(
x
)
&
&
IsValueInRangeForNumericType
<
Promotion
>
(
y
)
;
is_valid
&
=
CheckedDivImpl
(
static_cast
<
Promotion
>
(
x
)
static_cast
<
Promotion
>
(
y
)
&
presult
)
;
*
result
=
static_cast
<
V
>
(
presult
)
;
return
is_valid
&
&
IsValueInRangeForNumericType
<
V
>
(
presult
)
;
}
}
;
template
<
typename
T
>
bool
CheckedModImpl
(
T
x
T
y
T
*
result
)
{
static_assert
(
std
:
:
is_integral
<
T
>
:
:
value
"
Type
must
be
integral
"
)
;
if
(
y
>
0
)
{
*
result
=
static_cast
<
T
>
(
x
%
y
)
;
return
true
;
}
return
false
;
}
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedModOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedModOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_integral
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
bool
Do
(
T
x
U
y
V
*
result
)
{
using
Promotion
=
typename
BigEnoughPromotion
<
T
U
>
:
:
type
;
Promotion
presult
;
bool
is_valid
=
CheckedModImpl
(
static_cast
<
Promotion
>
(
x
)
static_cast
<
Promotion
>
(
y
)
&
presult
)
;
*
result
=
static_cast
<
V
>
(
presult
)
;
return
is_valid
&
&
IsValueInRangeForNumericType
<
V
>
(
presult
)
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedLshOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedLshOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_integral
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
T
;
template
<
typename
V
>
static
bool
Do
(
T
x
U
shift
V
*
result
)
{
using
ShiftType
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
static
const
ShiftType
kBitWidth
=
IntegerBitsPlusSign
<
T
>
:
:
value
;
const
ShiftType
real_shift
=
static_cast
<
ShiftType
>
(
shift
)
;
if
(
!
IsValueNegative
(
x
)
&
&
real_shift
<
kBitWidth
)
{
if
(
!
std
:
:
is_signed
<
T
>
:
:
value
|
|
real_shift
!
=
kBitWidth
-
1
)
return
CheckedMulOp
<
T
T
>
:
:
Do
(
x
static_cast
<
T
>
(
1
)
<
<
shift
result
)
;
return
!
x
;
}
return
false
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedRshOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedRshOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_integral
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
T
;
template
<
typename
V
=
result_type
>
static
bool
Do
(
T
x
U
shift
V
*
result
)
{
using
ShiftType
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
if
(
static_cast
<
ShiftType
>
(
shift
)
<
IntegerBitsPlusSign
<
T
>
:
:
value
)
{
T
tmp
=
x
>
>
shift
;
*
result
=
static_cast
<
V
>
(
tmp
)
;
return
IsValueInRangeForNumericType
<
V
>
(
tmp
)
;
}
return
false
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedAndOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedAndOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_integral
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
typename
std
:
:
make_unsigned
<
typename
MaxExponentPromotion
<
T
U
>
:
:
type
>
:
:
type
;
template
<
typename
V
=
result_type
>
static
bool
Do
(
T
x
U
y
V
*
result
)
{
result_type
tmp
=
static_cast
<
result_type
>
(
x
)
&
static_cast
<
result_type
>
(
y
)
;
*
result
=
static_cast
<
V
>
(
tmp
)
;
return
IsValueInRangeForNumericType
<
V
>
(
tmp
)
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedOrOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedOrOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_integral
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
typename
std
:
:
make_unsigned
<
typename
MaxExponentPromotion
<
T
U
>
:
:
type
>
:
:
type
;
template
<
typename
V
=
result_type
>
static
bool
Do
(
T
x
U
y
V
*
result
)
{
result_type
tmp
=
static_cast
<
result_type
>
(
x
)
|
static_cast
<
result_type
>
(
y
)
;
*
result
=
static_cast
<
V
>
(
tmp
)
;
return
IsValueInRangeForNumericType
<
V
>
(
tmp
)
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedXorOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedXorOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_integral
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
typename
std
:
:
make_unsigned
<
typename
MaxExponentPromotion
<
T
U
>
:
:
type
>
:
:
type
;
template
<
typename
V
=
result_type
>
static
bool
Do
(
T
x
U
y
V
*
result
)
{
result_type
tmp
=
static_cast
<
result_type
>
(
x
)
^
static_cast
<
result_type
>
(
y
)
;
*
result
=
static_cast
<
V
>
(
tmp
)
;
return
IsValueInRangeForNumericType
<
V
>
(
tmp
)
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedMaxOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedMaxOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_arithmetic
<
T
>
:
:
value
&
&
std
:
:
is_arithmetic
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
=
result_type
>
static
bool
Do
(
T
x
U
y
V
*
result
)
{
*
result
=
IsGreater
<
T
U
>
:
:
Test
(
x
y
)
?
static_cast
<
result_type
>
(
x
)
:
static_cast
<
result_type
>
(
y
)
;
return
true
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedMinOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedMinOp
<
T
U
typename
std
:
:
enable_if
<
std
:
:
is_arithmetic
<
T
>
:
:
value
&
&
std
:
:
is_arithmetic
<
U
>
:
:
value
>
:
:
type
>
{
using
result_type
=
typename
LowestValuePromotion
<
T
U
>
:
:
type
;
template
<
typename
V
=
result_type
>
static
bool
Do
(
T
x
U
y
V
*
result
)
{
*
result
=
IsLess
<
T
U
>
:
:
Test
(
x
y
)
?
static_cast
<
result_type
>
(
x
)
:
static_cast
<
result_type
>
(
y
)
;
return
true
;
}
}
;
#
define
BASE_FLOAT_ARITHMETIC_OPS
(
NAME
OP
)
\
template
<
typename
T
typename
U
>
\
struct
Checked
#
#
NAME
#
#
Op
<
\
T
U
typename
std
:
:
enable_if
<
std
:
:
is_floating_point
<
T
>
:
:
value
|
|
\
std
:
:
is_floating_point
<
U
>
:
:
value
>
:
:
type
>
{
\
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
\
template
<
typename
V
>
\
static
bool
Do
(
T
x
U
y
V
*
result
)
{
\
using
Promotion
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
\
Promotion
presult
=
x
OP
y
;
\
*
result
=
static_cast
<
V
>
(
presult
)
;
\
return
IsValueInRangeForNumericType
<
V
>
(
presult
)
;
\
}
\
}
;
BASE_FLOAT_ARITHMETIC_OPS
(
Add
+
)
BASE_FLOAT_ARITHMETIC_OPS
(
Sub
-
)
BASE_FLOAT_ARITHMETIC_OPS
(
Mul
*
)
BASE_FLOAT_ARITHMETIC_OPS
(
Div
/
)
#
undef
BASE_FLOAT_ARITHMETIC_OPS
template
<
typename
T
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
constexpr
T
NegateWrapper
(
T
value
)
{
using
UnsignedT
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
return
static_cast
<
T
>
(
UnsignedT
(
0
)
-
static_cast
<
UnsignedT
>
(
value
)
)
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
std
:
:
is_floating_point
<
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
constexpr
T
NegateWrapper
(
T
value
)
{
return
-
value
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
constexpr
typename
std
:
:
make_unsigned
<
T
>
:
:
type
InvertWrapper
(
T
value
)
{
return
~
value
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
constexpr
T
AbsWrapper
(
T
value
)
{
return
static_cast
<
T
>
(
SafeUnsignedAbs
(
value
)
)
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
std
:
:
is_floating_point
<
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
constexpr
T
AbsWrapper
(
T
value
)
{
return
value
<
0
?
-
value
:
value
;
}
enum
NumericRepresentation
{
NUMERIC_INTEGER
NUMERIC_FLOATING
NUMERIC_UNKNOWN
}
;
template
<
typename
NumericType
>
struct
GetNumericRepresentation
{
static
const
NumericRepresentation
value
=
std
:
:
is_integral
<
NumericType
>
:
:
value
?
NUMERIC_INTEGER
:
(
std
:
:
is_floating_point
<
NumericType
>
:
:
value
?
NUMERIC_FLOATING
:
NUMERIC_UNKNOWN
)
;
}
;
template
<
typename
T
NumericRepresentation
type
=
GetNumericRepresentation
<
T
>
:
:
value
>
class
CheckedNumericState
{
}
;
template
<
typename
T
>
class
CheckedNumericState
<
T
NUMERIC_INTEGER
>
{
private
:
bool
is_valid_
;
T
value_
;
template
<
typename
Src
>
static
constexpr
T
WellDefinedConversionOrZero
(
const
Src
value
const
bool
is_valid
)
{
using
SrcType
=
typename
internal
:
:
UnderlyingType
<
Src
>
:
:
type
;
return
(
std
:
:
is_integral
<
SrcType
>
:
:
value
|
|
is_valid
)
?
static_cast
<
T
>
(
value
)
:
static_cast
<
T
>
(
0
)
;
}
public
:
template
<
typename
Src
NumericRepresentation
type
>
friend
class
CheckedNumericState
;
constexpr
CheckedNumericState
(
)
:
is_valid_
(
true
)
value_
(
0
)
{
}
template
<
typename
Src
>
constexpr
CheckedNumericState
(
Src
value
bool
is_valid
)
:
is_valid_
(
is_valid
&
&
IsValueInRangeForNumericType
<
T
>
(
value
)
)
value_
(
WellDefinedConversionOrZero
(
value
is_valid_
)
)
{
static_assert
(
std
:
:
is_arithmetic
<
Src
>
:
:
value
"
Argument
must
be
numeric
.
"
)
;
}
template
<
typename
Src
>
constexpr
CheckedNumericState
(
const
CheckedNumericState
<
Src
>
&
rhs
)
:
is_valid_
(
rhs
.
IsValid
(
)
)
value_
(
WellDefinedConversionOrZero
(
rhs
.
value
(
)
is_valid_
)
)
{
}
template
<
typename
Src
>
constexpr
explicit
CheckedNumericState
(
Src
value
)
:
is_valid_
(
IsValueInRangeForNumericType
<
T
>
(
value
)
)
value_
(
WellDefinedConversionOrZero
(
value
is_valid_
)
)
{
}
constexpr
bool
is_valid
(
)
const
{
return
is_valid_
;
}
constexpr
T
value
(
)
const
{
return
value_
;
}
}
;
template
<
typename
T
>
class
CheckedNumericState
<
T
NUMERIC_FLOATING
>
{
private
:
T
value_
;
template
<
typename
Src
>
static
constexpr
T
WellDefinedConversionOrNaN
(
const
Src
value
const
bool
is_valid
)
{
using
SrcType
=
typename
internal
:
:
UnderlyingType
<
Src
>
:
:
type
;
return
(
StaticDstRangeRelationToSrcRange
<
T
SrcType
>
:
:
value
=
=
NUMERIC_RANGE_CONTAINED
|
|
is_valid
)
?
static_cast
<
T
>
(
value
)
:
std
:
:
numeric_limits
<
T
>
:
:
quiet_NaN
(
)
;
}
public
:
template
<
typename
Src
NumericRepresentation
type
>
friend
class
CheckedNumericState
;
constexpr
CheckedNumericState
(
)
:
value_
(
0
.
0
)
{
}
template
<
typename
Src
>
constexpr
CheckedNumericState
(
Src
value
bool
is_valid
)
:
value_
(
WellDefinedConversionOrNaN
(
value
is_valid
)
)
{
}
template
<
typename
Src
>
constexpr
explicit
CheckedNumericState
(
Src
value
)
:
value_
(
WellDefinedConversionOrNaN
(
value
IsValueInRangeForNumericType
<
T
>
(
value
)
)
)
{
}
template
<
typename
Src
>
constexpr
CheckedNumericState
(
const
CheckedNumericState
<
Src
>
&
rhs
)
:
value_
(
WellDefinedConversionOrNaN
(
rhs
.
value
(
)
rhs
.
is_valid
(
)
&
&
IsValueInRangeForNumericType
<
T
>
(
rhs
.
value
(
)
)
)
)
{
}
constexpr
bool
is_valid
(
)
const
{
return
value_
<
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
&
&
value_
>
=
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
;
}
constexpr
T
value
(
)
const
{
return
value_
;
}
}
;
template
<
template
<
typename
typename
typename
>
class
M
typename
L
typename
R
>
struct
MathWrapper
{
using
math
=
M
<
typename
UnderlyingType
<
L
>
:
:
type
typename
UnderlyingType
<
R
>
:
:
type
void
>
;
using
type
=
typename
math
:
:
result_type
;
}
;
}
}
}
#
endif
