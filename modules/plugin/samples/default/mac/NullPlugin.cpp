#
include
"
npapi
.
h
"
#
include
<
Carbon
/
Carbon
.
h
>
#
include
<
CoreFoundation
/
CoreFoundation
.
h
>
#
include
<
string
.
h
>
#
include
<
ctype
.
h
>
#
include
<
stdio
.
h
>
#
define
PLUGINFINDER_COMMAND_BEGINNING
"
javascript
:
window
.
open
(
\
"
"
#
define
PLUGINFINDER_COMMAND_END
"
\
"
\
"
plugin
\
"
\
"
toolbar
=
no
status
=
no
resizable
=
no
scrollbars
=
no
height
=
252
width
=
626
\
"
)
;
"
#
define
PLUGINFINDER_COMMAND_END2
"
\
"
\
"
plugin
\
"
\
"
toolbar
=
no
status
=
no
resizable
=
yes
scrollbars
=
yes
height
=
252
width
=
626
\
"
)
;
"
class
CPlugin
{
public
:
enum
HiliteState
{
kUnhilited
=
0
kHilited
=
1
}
;
static
NPError
Initialize
(
)
;
static
void
Shutdown
(
)
;
void
Constructor
(
NPP
instance
NPMIMEType
type
uint16
mode
int16
argc
char
*
argn
[
]
char
*
argv
[
]
)
;
void
Destructor
(
)
;
void
SetWindow
(
NPWindow
*
window
)
;
void
Print
(
NPPrint
*
printInfo
)
;
Boolean
HandleEvent
(
EventRecord
*
)
;
protected
:
void
Draw
(
HiliteState
hilite
)
;
void
DrawString
(
const
unsigned
char
*
text
short
width
short
height
short
centerX
Rect
drawRect
)
;
void
MouseDown
(
)
;
Boolean
FocusDraw
(
)
;
void
RestoreDraw
(
)
;
void
DetermineURL
(
int16
argc
char
*
argn
[
]
char
*
argv
[
]
)
;
char
*
MakeDefaultURL
(
void
)
;
void
AddMimeTypeToList
(
StringPtr
cTypeString
)
;
Boolean
CheckMimeTypes
(
)
;
void
AskAndLoadURL
(
)
;
void
RefreshPluginPage
(
)
;
Ptr
New
(
UInt32
size
)
;
void
Delete
(
Ptr
ptr
)
;
Boolean
IsPluginHidden
(
int16
argc
char
*
argn
[
]
char
*
argv
[
]
)
;
private
:
static
CIconHandle
sIconHandle
;
static
CursHandle
sHandCursor
;
static
char
*
sAltText
;
static
char
*
sInstallCommand
;
static
char
*
sDefaultPage
;
static
char
*
sRefreshText
;
static
char
*
sJavaScriptPage
;
static
FSSpec
sDataFileSpec
;
static
Boolean
sRunningOnOSX
;
NPP
fInstance
;
NPWindow
*
fWindow
;
uint16
fMode
;
NPMIMEType
fType
;
char
*
fPageURL
;
char
*
fFileURL
;
NPBool
m_bOffline
;
NPBool
m_bJavaScript
;
GrafPtr
fSavePort
;
RgnHandle
fSaveClip
;
Rect
fRevealedRect
;
short
fSavePortTop
;
short
fSavePortLeft
;
Boolean
fUserInstalledPlugin
;
Boolean
fHiddenPlugin
;
Boolean
fAskedLoadURL
;
}
;
CIconHandle
CPlugin
:
:
sIconHandle
=
NULL
;
CursHandle
CPlugin
:
:
sHandCursor
=
NULL
;
char
*
CPlugin
:
:
sAltText
=
NULL
;
char
*
CPlugin
:
:
sInstallCommand
=
NULL
;
char
*
CPlugin
:
:
sDefaultPage
=
NULL
;
char
*
CPlugin
:
:
sRefreshText
=
NULL
;
char
*
CPlugin
:
:
sJavaScriptPage
=
NULL
;
FSSpec
CPlugin
:
:
sDataFileSpec
;
Boolean
CPlugin
:
:
sRunningOnOSX
=
false
;
extern
short
gResFile
;
const
short
rBrokenPluginIcon
=
326
;
const
short
rHandCursor
=
128
;
const
short
rDefaultPluginURL
=
128
;
const
short
rAltTextString
=
129
;
const
short
rJavaScriptInstallCommand
=
130
;
const
short
rRefreshTextString
=
131
;
const
short
rJavaScriptPageURL
=
132
;
const
short
rTypeListStrings
=
129
;
static
const
char
szPluginFinderCommandBeginning
[
]
=
PLUGINFINDER_COMMAND_BEGINNING
;
static
const
char
szPluginFinderCommandEnd
[
]
=
PLUGINFINDER_COMMAND_END
;
NPError
NPP_Initialize
(
void
)
{
return
CPlugin
:
:
Initialize
(
)
;
}
void
NPP_Shutdown
(
void
)
{
CPlugin
:
:
Shutdown
(
)
;
}
NPError
NPP_New
(
NPMIMEType
type
NPP
instance
uint16
mode
int16
argc
char
*
argn
[
]
char
*
argv
[
]
NPSavedData
*
)
{
if
(
instance
=
=
NULL
)
return
NPERR_INVALID_INSTANCE_ERROR
;
CPlugin
*
This
=
(
CPlugin
*
)
(
char
*
)
NPN_MemAlloc
(
sizeof
(
CPlugin
)
)
;
instance
-
>
pdata
=
This
;
if
(
This
!
=
NULL
)
{
This
-
>
Constructor
(
instance
type
mode
argc
argn
argv
)
;
return
NPERR_NO_ERROR
;
}
else
return
NPERR_OUT_OF_MEMORY_ERROR
;
}
NPError
NP_LOADDS
NPP_Destroy
(
NPP
instance
NPSavedData
*
*
)
{
if
(
instance
=
=
NULL
)
return
NPERR_INVALID_INSTANCE_ERROR
;
CPlugin
*
This
=
(
CPlugin
*
)
instance
-
>
pdata
;
if
(
This
!
=
NULL
)
{
This
-
>
Destructor
(
)
;
NPN_MemFree
(
This
)
;
instance
-
>
pdata
=
NULL
;
}
return
NPERR_NO_ERROR
;
}
NPError
NPP_SetWindow
(
NPP
instance
NPWindow
*
window
)
{
if
(
instance
=
=
NULL
)
return
NPERR_INVALID_INSTANCE_ERROR
;
CPlugin
*
This
=
(
CPlugin
*
)
instance
-
>
pdata
;
if
(
This
!
=
NULL
)
This
-
>
SetWindow
(
window
)
;
return
NPERR_NO_ERROR
;
}
NPError
NP_LOADDS
NPP_NewStream
(
NPP
instance
NPMIMEType
NPStream
*
NPBool
uint16
*
)
{
if
(
instance
=
=
NULL
)
return
NPERR_INVALID_INSTANCE_ERROR
;
return
NPERR_NO_ERROR
;
}
int32
STREAMBUFSIZE
=
0X0FFFFFFF
;
int32
NP_LOADDS
NPP_WriteReady
(
NPP
NPStream
*
)
{
return
STREAMBUFSIZE
;
}
int32
NP_LOADDS
NPP_Write
(
NPP
NPStream
*
int32
int32
len
void
*
)
{
return
len
;
}
NPError
NP_LOADDS
NPP_DestroyStream
(
NPP
instance
NPStream
*
NPError
)
{
if
(
instance
=
=
NULL
)
return
NPERR_INVALID_INSTANCE_ERROR
;
return
NPERR_NO_ERROR
;
}
void
NP_LOADDS
NPP_StreamAsFile
(
NPP
NPStream
*
const
char
*
)
{
}
void
NP_LOADDS
NPP_Print
(
NPP
instance
NPPrint
*
printInfo
)
{
if
(
printInfo
=
=
NULL
)
return
;
if
(
instance
!
=
NULL
)
{
if
(
printInfo
-
>
mode
=
=
NP_FULL
)
printInfo
-
>
print
.
fullPrint
.
pluginPrinted
=
FALSE
;
else
{
CPlugin
*
This
=
(
CPlugin
*
)
instance
-
>
pdata
;
if
(
This
!
=
NULL
)
This
-
>
Print
(
printInfo
)
;
}
}
}
int16
NPP_HandleEvent
(
NPP
instance
void
*
event
)
{
if
(
instance
!
=
NULL
)
{
CPlugin
*
This
=
(
CPlugin
*
)
instance
-
>
pdata
;
if
(
This
!
=
NULL
&
&
event
!
=
NULL
)
return
This
-
>
HandleEvent
(
(
EventRecord
*
)
event
)
;
}
return
FALSE
;
}
void
NPP_URLNotify
(
NPP
const
char
*
NPReason
void
*
)
{
}
#
ifdef
OJI
jref
NPP_GetJavaClass
(
void
)
{
return
NULL
;
}
#
endif
#
pragma
mark
-
NPError
CPlugin
:
:
Initialize
(
)
{
Handle
string
;
short
saveResFile
=
CurResFile
(
)
;
UseResFile
(
gResFile
)
;
long
systemVersion
;
OSErr
err
=
:
:
Gestalt
(
gestaltSystemVersion
&
systemVersion
)
;
sRunningOnOSX
=
(
err
=
=
noErr
)
&
&
(
systemVersion
>
=
0x00001000
)
;
CPlugin
:
:
sIconHandle
=
GetCIcon
(
rBrokenPluginIcon
)
;
CPlugin
:
:
sHandCursor
=
GetCursor
(
rHandCursor
)
;
string
=
Get1Resource
(
'
STR
'
rAltTextString
)
;
if
(
string
&
&
*
string
)
{
short
stringLen
=
(
*
string
)
[
0
]
;
CPlugin
:
:
sAltText
=
(
char
*
)
NPN_MemAlloc
(
stringLen
+
1
)
;
if
(
CPlugin
:
:
sAltText
!
=
NULL
)
{
short
src
=
1
;
short
dest
=
0
;
while
(
src
<
=
stringLen
)
CPlugin
:
:
sAltText
[
dest
+
+
]
=
(
*
string
)
[
src
+
+
]
;
CPlugin
:
:
sAltText
[
dest
+
+
]
=
0
;
}
}
ReleaseResource
(
string
)
;
string
=
Get1Resource
(
'
STR
'
rRefreshTextString
)
;
if
(
string
&
&
*
string
)
{
short
stringLen
=
(
*
string
)
[
0
]
;
CPlugin
:
:
sRefreshText
=
(
char
*
)
NPN_MemAlloc
(
stringLen
+
1
)
;
if
(
CPlugin
:
:
sRefreshText
!
=
NULL
)
{
short
src
=
1
;
short
dest
=
0
;
while
(
src
<
=
stringLen
)
CPlugin
:
:
sRefreshText
[
dest
+
+
]
=
(
*
string
)
[
src
+
+
]
;
CPlugin
:
:
sRefreshText
[
dest
+
+
]
=
0
;
}
}
ReleaseResource
(
string
)
;
string
=
Get1Resource
(
'
STR
'
rJavaScriptInstallCommand
)
;
if
(
string
&
&
*
string
)
{
short
stringLen
=
(
*
string
)
[
0
]
;
CPlugin
:
:
sInstallCommand
=
(
char
*
)
NPN_MemAlloc
(
stringLen
+
1
)
;
if
(
CPlugin
:
:
sInstallCommand
!
=
NULL
)
{
short
src
=
1
;
short
dest
=
0
;
while
(
src
<
=
stringLen
)
CPlugin
:
:
sInstallCommand
[
dest
+
+
]
=
(
*
string
)
[
src
+
+
]
;
CPlugin
:
:
sInstallCommand
[
dest
+
+
]
=
0
;
}
}
ReleaseResource
(
string
)
;
string
=
Get1Resource
(
'
STR
'
rDefaultPluginURL
)
;
if
(
string
&
&
*
string
)
{
short
stringLen
=
(
*
string
)
[
0
]
;
CPlugin
:
:
sDefaultPage
=
(
char
*
)
NPN_MemAlloc
(
stringLen
+
1
)
;
if
(
CPlugin
:
:
sDefaultPage
!
=
NULL
)
{
short
src
=
1
;
short
dest
=
0
;
while
(
src
<
=
stringLen
)
CPlugin
:
:
sDefaultPage
[
dest
+
+
]
=
(
*
string
)
[
src
+
+
]
;
CPlugin
:
:
sDefaultPage
[
dest
+
+
]
=
0
;
}
}
ReleaseResource
(
string
)
;
string
=
Get1Resource
(
'
STR
'
rJavaScriptPageURL
)
;
if
(
string
&
&
*
string
)
{
short
stringLen
=
(
*
string
)
[
0
]
;
CPlugin
:
:
sJavaScriptPage
=
(
char
*
)
NPN_MemAlloc
(
stringLen
+
1
)
;
if
(
CPlugin
:
:
sJavaScriptPage
!
=
NULL
)
{
short
src
=
1
;
short
dest
=
0
;
while
(
src
<
=
stringLen
)
CPlugin
:
:
sJavaScriptPage
[
dest
+
+
]
=
(
*
string
)
[
src
+
+
]
;
CPlugin
:
:
sJavaScriptPage
[
dest
+
+
]
=
0
;
}
}
ReleaseResource
(
string
)
;
UseResFile
(
saveResFile
)
;
if
(
!
sRunningOnOSX
)
{
ProcessSerialNumber
psn
;
ProcessInfoRec
info
;
FSSpec
fsTheApp
;
SInt16
wResFile
;
OSErr
wErr
;
psn
.
highLongOfPSN
=
0
;
psn
.
lowLongOfPSN
=
kCurrentProcess
;
info
.
processInfoLength
=
sizeof
(
ProcessInfoRec
)
;
info
.
processName
=
nil
;
info
.
processAppSpec
=
&
fsTheApp
;
wErr
=
:
:
GetProcessInformation
(
&
psn
&
info
)
;
if
(
wErr
=
=
noErr
)
{
wErr
=
FSMakeFSSpec
(
fsTheApp
.
vRefNum
fsTheApp
.
parID
"
\
p
:
Plug
-
ins
:
Default
Plug
-
in
Data
"
&
sDataFileSpec
)
;
if
(
wErr
=
=
fnfErr
)
{
FSpCreateResFile
(
&
sDataFileSpec
'
MOSS
'
'
BINA
'
smSystemScript
)
;
wResFile
=
FSpOpenResFile
(
&
CPlugin
:
:
sDataFileSpec
fsRdWrPerm
)
;
if
(
wResFile
!
=
-
1
)
{
string
=
NewHandleClear
(
sizeof
(
SInt16
)
)
;
AddResource
(
string
'
STR
#
'
rTypeListStrings
"
\
p
"
)
;
UpdateResFile
(
wResFile
)
;
ReleaseResource
(
string
)
;
}
FSClose
(
wResFile
)
;
}
}
}
return
NPERR_NO_ERROR
;
}
void
CPlugin
:
:
Shutdown
(
)
{
if
(
CPlugin
:
:
sIconHandle
!
=
NULL
)
:
:
ReleaseResource
(
(
Handle
)
CPlugin
:
:
sIconHandle
)
;
if
(
CPlugin
:
:
sHandCursor
!
=
NULL
)
:
:
ReleaseResource
(
(
Handle
)
CPlugin
:
:
sHandCursor
)
;
if
(
CPlugin
:
:
sAltText
!
=
NULL
)
NPN_MemFree
(
CPlugin
:
:
sAltText
)
;
if
(
CPlugin
:
:
sInstallCommand
!
=
NULL
)
NPN_MemFree
(
CPlugin
:
:
sInstallCommand
)
;
if
(
CPlugin
:
:
sDefaultPage
!
=
NULL
)
NPN_MemFree
(
CPlugin
:
:
sDefaultPage
)
;
if
(
CPlugin
:
:
sRefreshText
!
=
NULL
)
NPN_MemFree
(
CPlugin
:
:
sRefreshText
)
;
}
void
CPlugin
:
:
Constructor
(
NPP
instance
NPMIMEType
type
uint16
mode
int16
argc
char
*
argn
[
]
char
*
argv
[
]
)
{
fWindow
=
NULL
;
fPageURL
=
NULL
;
fFileURL
=
NULL
;
fInstance
=
instance
;
fMode
=
mode
;
fAskedLoadURL
=
false
;
fUserInstalledPlugin
=
false
;
short
typeLength
=
strlen
(
type
)
;
fType
=
(
char
*
)
NPN_MemAlloc
(
typeLength
+
1
)
;
if
(
fType
!
=
NULL
)
strcpy
(
fType
type
)
;
fSaveClip
=
NewRgn
(
)
;
if
(
IsPluginHidden
(
argc
argn
argv
)
)
fHiddenPlugin
=
true
;
else
fHiddenPlugin
=
false
;
NPN_GetValue
(
fInstance
NPNVisOfflineBool
(
void
*
)
&
m_bOffline
)
;
NPN_GetValue
(
fInstance
NPNVjavascriptEnabledBool
(
void
*
)
&
m_bJavaScript
)
;
DetermineURL
(
argc
argn
argv
)
;
}
void
CPlugin
:
:
Destructor
(
)
{
if
(
fSaveClip
!
=
NULL
)
DisposeRgn
(
fSaveClip
)
;
if
(
fType
!
=
NULL
)
NPN_MemFree
(
fType
)
;
if
(
fFileURL
!
=
NULL
)
NPN_MemFree
(
fFileURL
)
;
if
(
fPageURL
!
=
NULL
)
NPN_MemFree
(
fPageURL
)
;
}
void
CPlugin
:
:
SetWindow
(
NPWindow
*
window
)
{
fWindow
=
window
;
}
void
CPlugin
:
:
Print
(
NPPrint
*
printInfo
)
{
NPWindow
*
printWindow
=
&
(
printInfo
-
>
print
.
embedPrint
.
window
)
;
NPWindow
*
oldWindow
=
fWindow
;
fWindow
=
printWindow
;
if
(
FocusDraw
(
)
)
{
Draw
(
kUnhilited
)
;
RestoreDraw
(
)
;
}
fWindow
=
oldWindow
;
}
Boolean
CPlugin
:
:
HandleEvent
(
EventRecord
*
ev
)
{
Boolean
eventHandled
=
false
;
switch
(
ev
-
>
what
)
{
case
mouseDown
:
MouseDown
(
)
;
eventHandled
=
true
;
break
;
case
updateEvt
:
if
(
FocusDraw
(
)
)
{
Draw
(
kUnhilited
)
;
RestoreDraw
(
)
;
}
eventHandled
=
true
;
break
;
case
NPEventType_AdjustCursorEvent
:
if
(
CPlugin
:
:
sHandCursor
!
=
NULL
)
SetCursor
(
*
CPlugin
:
:
sHandCursor
)
;
if
(
fUserInstalledPlugin
)
{
if
(
CPlugin
:
:
sRefreshText
!
=
NULL
)
NPN_Status
(
fInstance
CPlugin
:
:
sRefreshText
)
;
}
else
{
if
(
CPlugin
:
:
sAltText
!
=
NULL
)
NPN_Status
(
fInstance
CPlugin
:
:
sAltText
)
;
}
eventHandled
=
true
;
break
;
case
nullEvent
:
if
(
!
fAskedLoadURL
)
{
if
(
CheckMimeTypes
(
)
)
AskAndLoadURL
(
)
;
fAskedLoadURL
=
true
;
}
break
;
default
:
break
;
}
return
eventHandled
;
}
void
CPlugin
:
:
Draw
(
HiliteState
hilite
)
{
UInt8
*
pTheText
;
SInt32
height
=
fWindow
-
>
height
;
SInt32
width
=
fWindow
-
>
width
;
SInt32
centerX
=
(
width
)
>
>
1
;
SInt32
centerY
=
(
height
)
>
>
1
;
Rect
drawRect
;
RGBColor
black
=
{
0x0000
0x0000
0x0000
}
;
RGBColor
white
=
{
0xFFFF
0xFFFF
0xFFFF
}
;
RGBColor
hiliteColor
=
{
0x0000
0x0000
0x0000
}
;
short
transform
;
drawRect
.
top
=
0
;
drawRect
.
left
=
0
;
drawRect
.
bottom
=
height
;
drawRect
.
right
=
width
;
if
(
height
<
4
&
&
width
<
4
)
return
;
PenNormal
(
)
;
RGBForeColor
(
&
black
)
;
RGBBackColor
(
&
white
)
;
Pattern
qdWhite
;
FillRect
(
&
drawRect
GetQDGlobalsWhite
(
&
qdWhite
)
)
;
if
(
hilite
=
=
kHilited
)
{
hiliteColor
.
red
=
0xFFFF
;
transform
=
ttSelected
;
}
else
{
hiliteColor
.
blue
=
0xFFFF
;
transform
=
ttNone
;
}
RGBForeColor
(
&
hiliteColor
)
;
FrameRect
(
&
drawRect
)
;
if
(
height
>
32
&
&
width
>
32
&
&
CPlugin
:
:
sIconHandle
!
=
NULL
)
{
drawRect
.
top
=
centerY
-
16
;
drawRect
.
bottom
=
centerY
+
16
;
drawRect
.
left
=
centerX
-
16
;
drawRect
.
right
=
centerX
+
16
;
PlotCIconHandle
(
&
drawRect
atAbsoluteCenter
transform
CPlugin
:
:
sIconHandle
)
;
}
if
(
fUserInstalledPlugin
)
{
pTheText
=
(
unsigned
char
*
)
CPlugin
:
:
sRefreshText
;
}
else
{
pTheText
=
(
unsigned
char
*
)
CPlugin
:
:
sAltText
;
}
DrawString
(
pTheText
width
height
centerX
drawRect
)
;
}
void
CPlugin
:
:
MouseDown
(
)
{
if
(
FocusDraw
(
)
)
{
Draw
(
kHilited
)
;
Boolean
inside
=
true
;
while
(
StillDown
(
)
)
{
Point
localMouse
;
GetMouse
(
&
localMouse
)
;
Boolean
insideNow
=
:
:
PtInRect
(
localMouse
&
fRevealedRect
)
;
if
(
insideNow
!
=
inside
)
{
Draw
(
insideNow
?
kHilited
:
kUnhilited
)
;
inside
=
insideNow
;
}
}
if
(
inside
)
{
Draw
(
kUnhilited
)
;
if
(
!
fUserInstalledPlugin
)
AskAndLoadURL
(
)
;
else
RefreshPluginPage
(
)
;
}
RestoreDraw
(
)
;
}
}
Boolean
CPlugin
:
:
FocusDraw
(
)
{
if
(
fWindow
=
=
NULL
)
return
false
;
NP_Port
*
npport
=
(
NP_Port
*
)
fWindow
-
>
window
;
CGrafPtr
ourPort
=
npport
-
>
port
;
if
(
fWindow
-
>
clipRect
.
left
<
fWindow
-
>
clipRect
.
right
)
{
GetPort
(
&
fSavePort
)
;
SetPort
(
(
GrafPtr
)
ourPort
)
;
Rect
portRect
;
GetPortBounds
(
ourPort
&
portRect
)
;
fSavePortTop
=
portRect
.
top
;
fSavePortLeft
=
portRect
.
left
;
GetClip
(
fSaveClip
)
;
fRevealedRect
.
top
=
fWindow
-
>
clipRect
.
top
+
npport
-
>
porty
;
fRevealedRect
.
left
=
fWindow
-
>
clipRect
.
left
+
npport
-
>
portx
;
fRevealedRect
.
bottom
=
fWindow
-
>
clipRect
.
bottom
+
npport
-
>
porty
;
fRevealedRect
.
right
=
fWindow
-
>
clipRect
.
right
+
npport
-
>
portx
;
SetOrigin
(
npport
-
>
portx
npport
-
>
porty
)
;
ClipRect
(
&
fRevealedRect
)
;
return
true
;
}
else
return
false
;
}
void
CPlugin
:
:
RestoreDraw
(
)
{
SetOrigin
(
fSavePortLeft
fSavePortTop
)
;
SetClip
(
fSaveClip
)
;
SetPort
(
fSavePort
)
;
}
void
CPlugin
:
:
DetermineURL
(
int16
argc
char
*
argn
[
]
char
*
argv
[
]
)
{
char
*
url
;
SInt32
additionalLength
=
0
;
SInt32
i
;
if
(
fType
!
=
NULL
)
additionalLength
+
=
(
strlen
(
fType
)
+
1
)
;
for
(
i
=
0
;
i
<
argc
;
i
+
+
)
{
if
(
(
strcasecmp
(
argn
[
i
]
"
PLUGINSPAGE
"
)
=
=
0
)
|
|
(
strcasecmp
(
argn
[
i
]
"
CODEBASE
"
)
=
=
0
)
)
{
url
=
argv
[
i
]
;
fPageURL
=
(
char
*
)
NPN_MemAlloc
(
strlen
(
url
)
+
1
+
additionalLength
)
;
if
(
fPageURL
!
=
NULL
)
{
if
(
additionalLength
>
0
)
{
sprintf
(
fPageURL
"
%
s
?
%
s
"
url
fType
)
;
}
else
{
strcpy
(
fPageURL
url
)
;
}
}
break
;
}
else
if
(
(
strcasecmp
(
argn
[
i
]
"
PLUGINURL
"
)
=
=
0
)
|
|
(
strcasecmp
(
argn
[
i
]
"
CLASSID
"
)
=
=
0
)
)
{
url
=
argv
[
i
]
;
if
(
CPlugin
:
:
sInstallCommand
!
=
NULL
)
{
fFileURL
=
(
char
*
)
NPN_MemAlloc
(
strlen
(
CPlugin
:
:
sInstallCommand
)
+
1
+
strlen
(
url
)
)
;
if
(
fFileURL
!
=
NULL
)
sprintf
(
fFileURL
CPlugin
:
:
sInstallCommand
url
)
;
}
break
;
}
}
}
char
*
CPlugin
:
:
MakeDefaultURL
(
void
)
{
char
*
pDefURL
=
NULL
;
SInt32
additionalLength
=
0
;
if
(
fType
!
=
NULL
)
additionalLength
+
=
(
strlen
(
fType
)
+
1
)
;
if
(
!
m_bJavaScript
)
{
if
(
CPlugin
:
:
sDefaultPage
!
=
NULL
)
{
pDefURL
=
(
char
*
)
NPN_MemAlloc
(
strlen
(
CPlugin
:
:
sDefaultPage
)
+
1
+
additionalLength
)
;
if
(
pDefURL
!
=
NULL
)
{
if
(
additionalLength
>
0
)
{
sprintf
(
pDefURL
"
%
s
?
%
s
"
CPlugin
:
:
sDefaultPage
fType
)
;
}
else
{
strcpy
(
pDefURL
CPlugin
:
:
sDefaultPage
)
;
}
}
}
}
else
{
if
(
CPlugin
:
:
sJavaScriptPage
!
=
NULL
)
{
pDefURL
=
(
char
*
)
NPN_MemAlloc
(
strlen
(
szPluginFinderCommandBeginning
)
+
strlen
(
CPlugin
:
:
sJavaScriptPage
)
+
additionalLength
+
strlen
(
szPluginFinderCommandEnd
)
+
1
)
;
if
(
pDefURL
!
=
NULL
)
{
sprintf
(
pDefURL
"
%
s
%
s
%
s
%
s
"
szPluginFinderCommandBeginning
CPlugin
:
:
sJavaScriptPage
fType
szPluginFinderCommandEnd
)
;
}
}
}
return
(
pDefURL
)
;
}
void
CPlugin
:
:
AddMimeTypeToList
(
StringPtr
cTypeString
)
{
if
(
sRunningOnOSX
)
{
CFStringRef
pluginKey
=
CFSTR
(
"
DefaultPluginSeenTypes
"
)
;
CFStringRef
mimeType
=
:
:
CFStringCreateWithPascalString
(
kCFAllocatorDefault
cTypeString
kCFStringEncodingASCII
)
;
CFArrayRef
prefsList
=
(
CFArrayRef
)
:
:
CFPreferencesCopyAppValue
(
pluginKey
kCFPreferencesCurrentApplication
)
;
Boolean
foundType
=
false
;
if
(
prefsList
=
=
NULL
)
{
CFStringRef
stringArray
[
1
]
;
stringArray
[
0
]
=
mimeType
;
prefsList
=
:
:
CFArrayCreate
(
kCFAllocatorDefault
(
const
void
*
*
)
stringArray
1
&
kCFTypeArrayCallBacks
)
;
if
(
prefsList
)
{
:
:
CFPreferencesSetAppValue
(
pluginKey
prefsList
kCFPreferencesCurrentApplication
)
;
:
:
CFRelease
(
prefsList
)
;
}
}
else
{
if
(
:
:
CFGetTypeID
(
prefsList
)
=
=
:
:
CFArrayGetTypeID
(
)
)
{
CFIndex
count
=
:
:
CFArrayGetCount
(
prefsList
)
;
for
(
CFIndex
i
=
0
;
i
<
count
;
i
+
+
)
{
CFStringRef
item
=
(
CFStringRef
)
:
:
CFArrayGetValueAtIndex
(
prefsList
i
)
;
if
(
item
&
&
(
:
:
CFGetTypeID
(
item
)
=
=
:
:
CFStringGetTypeID
(
)
)
&
&
(
:
:
CFStringCompareWithOptions
(
item
mimeType
CFRangeMake
(
0
:
:
CFStringGetLength
(
item
)
)
kCFCompareCaseInsensitive
)
=
=
kCFCompareEqualTo
)
)
{
foundType
=
true
;
break
;
}
}
if
(
!
foundType
&
&
!
fHiddenPlugin
)
{
CFMutableArrayRef
typesArray
=
:
:
CFArrayCreateMutableCopy
(
kCFAllocatorDefault
0
(
CFArrayRef
)
prefsList
)
;
if
(
typesArray
)
{
:
:
CFArrayAppendValue
(
typesArray
mimeType
)
;
:
:
CFPreferencesSetAppValue
(
pluginKey
typesArray
kCFPreferencesCurrentApplication
)
;
}
}
}
:
:
CFRelease
(
prefsList
)
;
}
:
:
CFRelease
(
mimeType
)
;
}
else
{
Handle
hTypeList
;
SInt32
dwCount
;
SInt32
index
;
Str255
oldType
;
SInt16
wResFile
;
Boolean
failedToFind
=
true
;
wResFile
=
FSpOpenResFile
(
&
CPlugin
:
:
sDataFileSpec
fsRdWrPerm
)
;
if
(
wResFile
!
=
-
1
)
{
hTypeList
=
Get1Resource
(
'
STR
#
'
rTypeListStrings
)
;
if
(
hTypeList
!
=
NULL
)
{
dwCount
=
*
*
(
(
short
*
*
)
hTypeList
)
;
for
(
index
=
1
;
index
<
=
dwCount
;
index
+
+
)
{
GetIndString
(
oldType
rTypeListStrings
index
)
;
if
(
EqualString
(
cTypeString
oldType
true
true
)
&
&
!
fHiddenPlugin
)
{
failedToFind
=
false
;
break
;
}
}
if
(
failedToFind
)
{
Size
itsSize
=
GetHandleSize
(
hTypeList
)
;
Size
typeSize
=
cTypeString
[
0
]
+
1
;
SetHandleSize
(
hTypeList
itsSize
+
typeSize
)
;
(
*
*
(
(
short
*
*
)
hTypeList
)
)
=
(
short
)
(
+
+
dwCount
)
;
long
dwCount
=
Munger
(
hTypeList
itsSize
NULL
typeSize
cTypeString
typeSize
)
;
if
(
dwCount
>
0
)
{
ChangedResource
(
hTypeList
)
;
UpdateResFile
(
wResFile
)
;
}
}
ReleaseResource
(
hTypeList
)
;
}
FSClose
(
wResFile
)
;
}
}
}
Boolean
CPlugin
:
:
CheckMimeTypes
(
)
{
Boolean
failedToFind
=
true
;
if
(
sRunningOnOSX
)
{
CFStringRef
pluginKey
=
CFSTR
(
"
DefaultPluginSeenTypes
"
)
;
CFStringRef
mimeType
=
:
:
CFStringCreateWithCString
(
kCFAllocatorDefault
fType
kCFStringEncodingASCII
)
;
CFArrayRef
prefsList
=
(
CFArrayRef
)
:
:
CFPreferencesCopyAppValue
(
pluginKey
kCFPreferencesCurrentApplication
)
;
if
(
prefsList
)
{
if
(
:
:
CFGetTypeID
(
prefsList
)
=
=
:
:
CFArrayGetTypeID
(
)
)
{
CFIndex
count
=
:
:
CFArrayGetCount
(
prefsList
)
;
for
(
CFIndex
i
=
0
;
i
<
count
;
i
+
+
)
{
CFStringRef
item
=
(
CFStringRef
)
:
:
CFArrayGetValueAtIndex
(
prefsList
i
)
;
if
(
item
&
&
(
:
:
CFGetTypeID
(
item
)
=
=
:
:
CFStringGetTypeID
(
)
)
&
&
(
:
:
CFStringCompareWithOptions
(
item
mimeType
CFRangeMake
(
0
:
:
CFStringGetLength
(
item
)
)
kCFCompareCaseInsensitive
)
=
=
kCFCompareEqualTo
)
)
{
failedToFind
=
false
;
break
;
}
}
}
:
:
CFRelease
(
prefsList
)
;
}
:
:
CFRelease
(
mimeType
)
;
}
else
{
Handle
hTypeList
;
SInt32
index
;
Str255
oldType
;
Str255
ourType
;
SInt16
wResFile
;
wResFile
=
FSpOpenResFile
(
&
CPlugin
:
:
sDataFileSpec
fsRdPerm
)
;
if
(
wResFile
!
=
-
1
)
{
hTypeList
=
Get1Resource
(
'
STR
#
'
rTypeListStrings
)
;
if
(
hTypeList
!
=
NULL
)
{
index
=
strlen
(
fType
)
;
if
(
index
>
255
)
{
index
=
255
;
}
BlockMoveData
(
fType
&
ourType
[
1
]
index
)
;
ourType
[
0
]
=
index
;
short
count
=
*
*
(
(
short
*
*
)
hTypeList
)
;
for
(
index
=
1
;
index
<
=
count
;
index
+
+
)
{
GetIndString
(
oldType
rTypeListStrings
index
)
;
if
(
EqualString
(
ourType
oldType
true
true
)
&
&
!
fHiddenPlugin
)
{
failedToFind
=
false
;
break
;
}
}
ReleaseResource
(
hTypeList
)
;
}
FSClose
(
wResFile
)
;
}
}
return
(
failedToFind
)
;
}
void
CPlugin
:
:
AskAndLoadURL
(
)
{
char
*
pTheURL
;
SInt32
dwLen
;
Str255
ourType
;
if
(
!
m_bOffline
)
{
dwLen
=
strlen
(
fType
)
;
if
(
dwLen
>
255
)
{
dwLen
=
255
;
}
BlockMoveData
(
fType
&
ourType
[
1
]
dwLen
)
;
ourType
[
0
]
=
dwLen
;
Cursor
qdArrow
;
SetCursor
(
GetQDGlobalsArrow
(
&
qdArrow
)
)
;
AddMimeTypeToList
(
ourType
)
;
NPN_PushPopupsEnabledState
(
fInstance
true
)
;
if
(
fFileURL
!
=
NULL
)
{
(
void
)
NPN_GetURL
(
fInstance
fFileURL
"
_current
"
)
;
}
else
if
(
fPageURL
!
=
NULL
)
{
NPN_GetURL
(
fInstance
fPageURL
"
_blank
"
)
;
}
else
{
pTheURL
=
MakeDefaultURL
(
)
;
if
(
!
m_bJavaScript
)
{
NPN_GetURL
(
fInstance
pTheURL
"
_blank
"
)
;
}
else
{
NPN_GetURL
(
fInstance
pTheURL
NULL
)
;
}
NPN_MemFree
(
pTheURL
)
;
}
NPN_PopPopupsEnabledState
(
fInstance
)
;
fUserInstalledPlugin
=
true
;
if
(
FocusDraw
(
)
)
{
Draw
(
kUnhilited
)
;
RestoreDraw
(
)
;
}
}
}
void
CPlugin
:
:
RefreshPluginPage
(
)
{
(
void
)
NPN_GetURL
(
fInstance
"
javascript
:
navigator
.
plugins
.
refresh
(
true
)
;
"
"
_self
"
)
;
}
void
CPlugin
:
:
DrawString
(
const
unsigned
char
*
text
short
width
short
height
short
centerX
Rect
drawRect
)
{
short
length
textHeight
textWidth
;
if
(
text
=
=
NULL
)
return
;
length
=
strlen
(
(
char
*
)
text
)
;
TextFont
(
20
)
;
TextFace
(
underline
)
;
TextMode
(
srcCopy
)
;
TextSize
(
10
)
;
FontInfo
fontInfo
;
GetFontInfo
(
&
fontInfo
)
;
textHeight
=
fontInfo
.
ascent
+
fontInfo
.
descent
+
fontInfo
.
leading
;
textWidth
=
TextWidth
(
text
0
length
)
;
if
(
width
>
textWidth
&
&
height
>
textHeight
+
32
)
{
MoveTo
(
centerX
-
(
textWidth
>
>
1
)
drawRect
.
bottom
+
textHeight
)
;
DrawText
(
text
0
length
)
;
}
}
Boolean
CPlugin
:
:
IsPluginHidden
(
int16
argc
char
*
argn
[
]
char
*
argv
[
]
)
{
int
i
;
for
(
i
=
0
;
i
<
argc
;
i
+
+
)
{
if
(
!
strcasecmp
(
argn
[
i
]
"
HIDDEN
"
)
)
if
(
!
strcasecmp
(
argv
[
i
]
"
TRUE
"
)
)
return
true
;
}
return
false
;
}
