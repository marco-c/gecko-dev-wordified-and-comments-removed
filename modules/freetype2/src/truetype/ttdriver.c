#
include
<
freetype
/
internal
/
ftdebug
.
h
>
#
include
<
freetype
/
internal
/
ftstream
.
h
>
#
include
<
freetype
/
internal
/
sfnt
.
h
>
#
include
<
freetype
/
internal
/
services
/
svfntfmt
.
h
>
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
#
include
<
freetype
/
ftmm
.
h
>
#
include
<
freetype
/
internal
/
services
/
svmm
.
h
>
#
include
<
freetype
/
internal
/
services
/
svmetric
.
h
>
#
endif
#
include
<
freetype
/
internal
/
services
/
svtteng
.
h
>
#
include
<
freetype
/
internal
/
services
/
svttglyf
.
h
>
#
include
<
freetype
/
internal
/
services
/
svprop
.
h
>
#
include
<
freetype
/
ftdriver
.
h
>
#
include
"
ttdriver
.
h
"
#
include
"
ttgload
.
h
"
#
include
"
ttpload
.
h
"
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
#
include
"
ttgxvar
.
h
"
#
endif
#
include
"
tterrors
.
h
"
#
undef
FT_COMPONENT
#
define
FT_COMPONENT
ttdriver
FT_CALLBACK_DEF
(
FT_Error
)
tt_property_set
(
FT_Module
module
const
char
*
property_name
const
void
*
value
FT_Bool
value_is_string
)
{
FT_Error
error
=
FT_Err_Ok
;
TT_Driver
driver
=
(
TT_Driver
)
module
;
#
ifndef
FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
FT_UNUSED
(
value_is_string
)
;
#
endif
if
(
!
ft_strcmp
(
property_name
"
interpreter
-
version
"
)
)
{
FT_UInt
interpreter_version
;
#
ifdef
FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
if
(
value_is_string
)
{
const
char
*
s
=
(
const
char
*
)
value
;
interpreter_version
=
(
FT_UInt
)
ft_strtol
(
s
NULL
10
)
;
}
else
#
endif
{
FT_UInt
*
iv
=
(
FT_UInt
*
)
value
;
interpreter_version
=
*
iv
;
}
switch
(
interpreter_version
)
{
case
TT_INTERPRETER_VERSION_35
:
driver
-
>
interpreter_version
=
TT_INTERPRETER_VERSION_35
;
break
;
case
TT_INTERPRETER_VERSION_38
:
case
TT_INTERPRETER_VERSION_40
:
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
driver
-
>
interpreter_version
=
TT_INTERPRETER_VERSION_40
;
break
;
#
endif
default
:
error
=
FT_ERR
(
Unimplemented_Feature
)
;
}
return
error
;
}
FT_TRACE2
(
(
"
tt_property_set
:
missing
property
%
s
'
\
n
"
property_name
)
)
;
return
FT_THROW
(
Missing_Property
)
;
}
FT_CALLBACK_DEF
(
FT_Error
)
tt_property_get
(
FT_Module
module
const
char
*
property_name
void
*
value
)
{
FT_Error
error
=
FT_Err_Ok
;
TT_Driver
driver
=
(
TT_Driver
)
module
;
FT_UInt
interpreter_version
=
driver
-
>
interpreter_version
;
if
(
!
ft_strcmp
(
property_name
"
interpreter
-
version
"
)
)
{
FT_UInt
*
val
=
(
FT_UInt
*
)
value
;
*
val
=
interpreter_version
;
return
error
;
}
FT_TRACE2
(
(
"
tt_property_get
:
missing
property
%
s
'
\
n
"
property_name
)
)
;
return
FT_THROW
(
Missing_Property
)
;
}
FT_DEFINE_SERVICE_PROPERTIESREC
(
tt_service_properties
tt_property_set
tt_property_get
)
FT_CALLBACK_DEF
(
FT_Error
)
tt_get_kerning
(
FT_Face
face
FT_UInt
left_glyph
FT_UInt
right_glyph
FT_Vector
*
kerning
)
{
TT_Face
ttface
=
(
TT_Face
)
face
;
SFNT_Service
sfnt
=
(
SFNT_Service
)
ttface
-
>
sfnt
;
kerning
-
>
x
=
0
;
kerning
-
>
y
=
0
;
if
(
sfnt
)
kerning
-
>
x
=
sfnt
-
>
get_kerning
(
ttface
left_glyph
right_glyph
)
;
return
0
;
}
FT_CALLBACK_DEF
(
FT_Error
)
tt_get_advances
(
FT_Face
face
FT_UInt
start
FT_UInt
count
FT_Int32
flags
FT_Fixed
*
advances
)
{
FT_UInt
nn
;
TT_Face
ttface
=
(
TT_Face
)
face
;
if
(
flags
&
FT_LOAD_VERTICAL_LAYOUT
)
{
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
if
(
(
FT_IS_NAMED_INSTANCE
(
face
)
|
|
FT_IS_VARIATION
(
face
)
)
&
&
!
(
ttface
-
>
variation_support
&
TT_FACE_FLAG_VAR_VADVANCE
)
)
return
FT_THROW
(
Unimplemented_Feature
)
;
#
endif
for
(
nn
=
0
;
nn
<
count
;
nn
+
+
)
{
FT_Short
tsb
;
FT_UShort
ah
;
TT_Get_VMetrics
(
ttface
start
+
nn
0
&
tsb
&
ah
)
;
advances
[
nn
]
=
ah
;
}
}
else
{
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
if
(
(
FT_IS_NAMED_INSTANCE
(
face
)
|
|
FT_IS_VARIATION
(
face
)
)
&
&
!
(
ttface
-
>
variation_support
&
TT_FACE_FLAG_VAR_HADVANCE
)
)
return
FT_THROW
(
Unimplemented_Feature
)
;
#
endif
for
(
nn
=
0
;
nn
<
count
;
nn
+
+
)
{
FT_Short
lsb
;
FT_UShort
aw
;
TT_Get_HMetrics
(
ttface
start
+
nn
&
lsb
&
aw
)
;
advances
[
nn
]
=
aw
;
}
}
return
FT_Err_Ok
;
}
#
ifdef
TT_CONFIG_OPTION_EMBEDDED_BITMAPS
FT_CALLBACK_DEF
(
FT_Error
)
tt_size_select
(
FT_Size
size
FT_ULong
strike_index
)
{
TT_Face
ttface
=
(
TT_Face
)
size
-
>
face
;
TT_Size
ttsize
=
(
TT_Size
)
size
;
FT_Error
error
=
FT_Err_Ok
;
ttsize
-
>
strike_index
=
strike_index
;
if
(
FT_IS_SCALABLE
(
size
-
>
face
)
)
{
FT_Select_Metrics
(
size
-
>
face
strike_index
)
;
tt_size_reset
(
ttsize
)
;
}
else
{
SFNT_Service
sfnt
=
(
SFNT_Service
)
ttface
-
>
sfnt
;
FT_Size_Metrics
*
size_metrics
=
&
size
-
>
metrics
;
error
=
sfnt
-
>
load_strike_metrics
(
ttface
strike_index
size_metrics
)
;
if
(
error
)
ttsize
-
>
strike_index
=
0xFFFFFFFFUL
;
}
return
error
;
}
#
endif
FT_CALLBACK_DEF
(
FT_Error
)
tt_size_request
(
FT_Size
size
FT_Size_Request
req
)
{
TT_Size
ttsize
=
(
TT_Size
)
size
;
FT_Error
error
=
FT_Err_Ok
;
#
ifdef
TT_CONFIG_OPTION_EMBEDDED_BITMAPS
if
(
FT_HAS_FIXED_SIZES
(
size
-
>
face
)
)
{
TT_Face
ttface
=
(
TT_Face
)
size
-
>
face
;
SFNT_Service
sfnt
=
(
SFNT_Service
)
ttface
-
>
sfnt
;
FT_ULong
strike_index
;
error
=
sfnt
-
>
set_sbit_strike
(
ttface
req
&
strike_index
)
;
if
(
error
)
ttsize
-
>
strike_index
=
0xFFFFFFFFUL
;
else
return
tt_size_select
(
size
strike_index
)
;
}
#
endif
{
FT_Error
err
=
FT_Request_Metrics
(
size
-
>
face
req
)
;
if
(
err
)
{
error
=
err
;
goto
Exit
;
}
}
if
(
FT_IS_SCALABLE
(
size
-
>
face
)
)
{
error
=
tt_size_reset
(
ttsize
)
;
#
ifdef
TT_USE_BYTECODE_INTERPRETER
if
(
!
error
)
{
FT_UInt
resolution
=
ttsize
-
>
metrics
-
>
x_ppem
>
ttsize
-
>
metrics
-
>
y_ppem
?
req
-
>
horiResolution
:
req
-
>
vertResolution
;
if
(
req
-
>
type
=
=
FT_SIZE_REQUEST_TYPE_SCALES
|
|
!
resolution
)
resolution
=
72
;
ttsize
-
>
point_size
=
FT_MulDiv
(
ttsize
-
>
ttmetrics
.
ppem
64
*
72
resolution
)
;
}
#
endif
}
Exit
:
return
error
;
}
FT_CALLBACK_DEF
(
FT_Error
)
tt_glyph_load
(
FT_GlyphSlot
slot
FT_Size
size
FT_UInt
glyph_index
FT_Int32
load_flags
)
{
TT_GlyphSlot
ttslot
=
(
TT_GlyphSlot
)
slot
;
TT_Size
ttsize
=
(
TT_Size
)
size
;
FT_Face
face
=
ttslot
-
>
face
;
FT_Error
error
;
if
(
!
slot
)
return
FT_THROW
(
Invalid_Slot_Handle
)
;
if
(
!
size
)
return
FT_THROW
(
Invalid_Size_Handle
)
;
if
(
!
face
)
return
FT_THROW
(
Invalid_Face_Handle
)
;
#
ifdef
FT_CONFIG_OPTION_INCREMENTAL
if
(
glyph_index
>
=
(
FT_UInt
)
face
-
>
num_glyphs
&
&
!
face
-
>
internal
-
>
incremental_interface
)
#
else
if
(
glyph_index
>
=
(
FT_UInt
)
face
-
>
num_glyphs
)
#
endif
return
FT_THROW
(
Invalid_Argument
)
;
if
(
load_flags
&
FT_LOAD_NO_HINTING
)
{
if
(
FT_IS_TRICKY
(
face
)
)
load_flags
&
=
~
FT_LOAD_NO_HINTING
;
if
(
load_flags
&
FT_LOAD_NO_AUTOHINT
)
load_flags
|
=
FT_LOAD_NO_HINTING
;
}
if
(
load_flags
&
(
FT_LOAD_NO_RECURSE
|
FT_LOAD_NO_SCALE
)
)
{
load_flags
|
=
FT_LOAD_NO_BITMAP
|
FT_LOAD_NO_SCALE
;
if
(
!
FT_IS_TRICKY
(
face
)
)
load_flags
|
=
FT_LOAD_NO_HINTING
;
}
ttsize
-
>
metrics
=
(
load_flags
&
FT_LOAD_NO_HINTING
)
?
&
size
-
>
metrics
:
&
ttsize
-
>
hinted_metrics
;
error
=
TT_Load_Glyph
(
ttsize
ttslot
glyph_index
load_flags
)
;
return
error
;
}
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
FT_DEFINE_SERVICE_MULTIMASTERSREC
(
tt_service_gx_multi_masters
NULL
NULL
TT_Set_MM_Blend
TT_Get_MM_Blend
TT_Get_MM_Var
TT_Set_Var_Design
TT_Get_Var_Design
TT_Set_Named_Instance
TT_Get_Default_Named_Instance
NULL
NULL
tt_construct_ps_name
tt_var_load_delta_set_index_mapping
tt_var_load_item_variation_store
tt_var_get_item_delta
tt_var_done_item_variation_store
tt_var_done_delta_set_index_map
tt_get_var_blend
tt_done_blend
)
FT_DEFINE_SERVICE_METRICSVARIATIONSREC
(
tt_service_metrics_variations
tt_hadvance_adjust
NULL
NULL
tt_vadvance_adjust
NULL
NULL
NULL
tt_apply_mvar
tt_size_reset_height
)
#
endif
static
const
FT_Service_TrueTypeEngineRec
tt_service_truetype_engine
=
{
#
ifdef
TT_USE_BYTECODE_INTERPRETER
FT_TRUETYPE_ENGINE_TYPE_PATENTED
#
else
FT_TRUETYPE_ENGINE_TYPE_NONE
#
endif
}
;
FT_DEFINE_SERVICE_TTGLYFREC
(
tt_service_truetype_glyf
(
TT_Glyf_GetLocationFunc
)
tt_face_get_location
)
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
FT_DEFINE_SERVICEDESCREC6
(
tt_services
FT_SERVICE_ID_FONT_FORMAT
FT_FONT_FORMAT_TRUETYPE
FT_SERVICE_ID_MULTI_MASTERS
&
tt_service_gx_multi_masters
FT_SERVICE_ID_METRICS_VARIATIONS
&
tt_service_metrics_variations
FT_SERVICE_ID_TRUETYPE_ENGINE
&
tt_service_truetype_engine
FT_SERVICE_ID_TT_GLYF
&
tt_service_truetype_glyf
FT_SERVICE_ID_PROPERTIES
&
tt_service_properties
)
#
else
FT_DEFINE_SERVICEDESCREC4
(
tt_services
FT_SERVICE_ID_FONT_FORMAT
FT_FONT_FORMAT_TRUETYPE
FT_SERVICE_ID_TRUETYPE_ENGINE
&
tt_service_truetype_engine
FT_SERVICE_ID_TT_GLYF
&
tt_service_truetype_glyf
FT_SERVICE_ID_PROPERTIES
&
tt_service_properties
)
#
endif
FT_CALLBACK_DEF
(
FT_Module_Interface
)
tt_get_interface
(
FT_Module
driver
const
char
*
tt_interface
)
{
FT_Library
library
;
FT_Module_Interface
result
;
FT_Module
sfntd
;
SFNT_Service
sfnt
;
result
=
ft_service_list_lookup
(
tt_services
tt_interface
)
;
if
(
result
)
return
result
;
if
(
!
driver
)
return
NULL
;
library
=
driver
-
>
library
;
if
(
!
library
)
return
NULL
;
sfntd
=
FT_Get_Module
(
library
"
sfnt
"
)
;
if
(
sfntd
)
{
sfnt
=
(
SFNT_Service
)
(
sfntd
-
>
clazz
-
>
module_interface
)
;
if
(
sfnt
)
return
sfnt
-
>
get_interface
(
driver
tt_interface
)
;
}
return
0
;
}
#
ifdef
TT_USE_BYTECODE_INTERPRETER
#
define
TT_HINTER_FLAG
FT_MODULE_DRIVER_HAS_HINTER
#
else
#
define
TT_HINTER_FLAG
0
#
endif
#
ifdef
TT_CONFIG_OPTION_EMBEDDED_BITMAPS
#
define
TT_SIZE_SELECT
tt_size_select
#
else
#
define
TT_SIZE_SELECT
0
#
endif
FT_DEFINE_DRIVER
(
tt_driver_class
FT_MODULE_FONT_DRIVER
|
FT_MODULE_DRIVER_SCALABLE
|
TT_HINTER_FLAG
sizeof
(
TT_DriverRec
)
"
truetype
"
0x10000L
0x20000L
NULL
tt_driver_init
tt_driver_done
tt_get_interface
sizeof
(
TT_FaceRec
)
sizeof
(
TT_SizeRec
)
sizeof
(
FT_GlyphSlotRec
)
tt_face_init
tt_face_done
tt_size_init
tt_size_done
tt_slot_init
NULL
tt_glyph_load
tt_get_kerning
NULL
tt_get_advances
tt_size_request
TT_SIZE_SELECT
)
