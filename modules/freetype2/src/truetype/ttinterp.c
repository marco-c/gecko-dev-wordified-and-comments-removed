#
include
<
ft2build
.
h
>
#
include
FT_INTERNAL_DEBUG_H
#
include
FT_INTERNAL_CALC_H
#
include
FT_TRIGONOMETRY_H
#
include
FT_SYSTEM_H
#
include
FT_DRIVER_H
#
include
FT_MULTIPLE_MASTERS_H
#
include
"
ttinterp
.
h
"
#
include
"
tterrors
.
h
"
#
include
"
ttsubpix
.
h
"
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
#
include
"
ttgxvar
.
h
"
#
endif
#
ifdef
TT_USE_BYTECODE_INTERPRETER
#
undef
FT_COMPONENT
#
define
FT_COMPONENT
ttinterp
#
define
NO_SUBPIXEL_HINTING
\
(
(
(
TT_Driver
)
FT_FACE_DRIVER
(
exc
-
>
face
)
)
-
>
interpreter_version
=
=
\
TT_INTERPRETER_VERSION_35
)
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
#
define
SUBPIXEL_HINTING_INFINALITY
\
(
(
(
TT_Driver
)
FT_FACE_DRIVER
(
exc
-
>
face
)
)
-
>
interpreter_version
=
=
\
TT_INTERPRETER_VERSION_38
)
#
endif
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
#
define
SUBPIXEL_HINTING_MINIMAL
\
(
(
(
TT_Driver
)
FT_FACE_DRIVER
(
exc
-
>
face
)
)
-
>
interpreter_version
=
=
\
TT_INTERPRETER_VERSION_40
)
#
endif
#
define
PROJECT
(
v1
v2
)
\
exc
-
>
func_project
(
exc
\
SUB_LONG
(
(
v1
)
-
>
x
(
v2
)
-
>
x
)
\
SUB_LONG
(
(
v1
)
-
>
y
(
v2
)
-
>
y
)
)
#
define
DUALPROJ
(
v1
v2
)
\
exc
-
>
func_dualproj
(
exc
\
SUB_LONG
(
(
v1
)
-
>
x
(
v2
)
-
>
x
)
\
SUB_LONG
(
(
v1
)
-
>
y
(
v2
)
-
>
y
)
)
#
define
FAST_PROJECT
(
v
)
\
exc
-
>
func_project
(
exc
(
v
)
-
>
x
(
v
)
-
>
y
)
#
define
FAST_DUALPROJ
(
v
)
\
exc
-
>
func_dualproj
(
exc
(
v
)
-
>
x
(
v
)
-
>
y
)
#
define
BOUNDS
(
x
n
)
(
(
FT_UInt
)
(
x
)
>
=
(
FT_UInt
)
(
n
)
)
#
define
BOUNDSL
(
x
n
)
(
(
FT_ULong
)
(
x
)
>
=
(
FT_ULong
)
(
n
)
)
#
undef
SUCCESS
#
define
SUCCESS
0
#
undef
FAILURE
#
define
FAILURE
1
FT_LOCAL_DEF
(
void
)
TT_Goto_CodeRange
(
TT_ExecContext
exec
FT_Int
range
FT_Long
IP
)
{
TT_CodeRange
*
coderange
;
FT_ASSERT
(
range
>
=
1
&
&
range
<
=
3
)
;
coderange
=
&
exec
-
>
codeRangeTable
[
range
-
1
]
;
FT_ASSERT
(
coderange
-
>
base
)
;
FT_ASSERT
(
IP
<
=
coderange
-
>
size
)
;
exec
-
>
code
=
coderange
-
>
base
;
exec
-
>
codeSize
=
coderange
-
>
size
;
exec
-
>
IP
=
IP
;
exec
-
>
curRange
=
range
;
}
FT_LOCAL_DEF
(
void
)
TT_Set_CodeRange
(
TT_ExecContext
exec
FT_Int
range
void
*
base
FT_Long
length
)
{
FT_ASSERT
(
range
>
=
1
&
&
range
<
=
3
)
;
exec
-
>
codeRangeTable
[
range
-
1
]
.
base
=
(
FT_Byte
*
)
base
;
exec
-
>
codeRangeTable
[
range
-
1
]
.
size
=
length
;
}
FT_LOCAL_DEF
(
void
)
TT_Clear_CodeRange
(
TT_ExecContext
exec
FT_Int
range
)
{
FT_ASSERT
(
range
>
=
1
&
&
range
<
=
3
)
;
exec
-
>
codeRangeTable
[
range
-
1
]
.
base
=
NULL
;
exec
-
>
codeRangeTable
[
range
-
1
]
.
size
=
0
;
}
FT_LOCAL_DEF
(
void
)
TT_Done_Context
(
TT_ExecContext
exec
)
{
FT_Memory
memory
=
exec
-
>
memory
;
exec
-
>
maxPoints
=
0
;
exec
-
>
maxContours
=
0
;
FT_FREE
(
exec
-
>
stack
)
;
exec
-
>
stackSize
=
0
;
FT_FREE
(
exec
-
>
callStack
)
;
exec
-
>
callSize
=
0
;
exec
-
>
callTop
=
0
;
FT_FREE
(
exec
-
>
glyphIns
)
;
exec
-
>
glyphSize
=
0
;
exec
-
>
size
=
NULL
;
exec
-
>
face
=
NULL
;
FT_FREE
(
exec
)
;
}
static
FT_Error
Init_Context
(
TT_ExecContext
exec
FT_Memory
memory
)
{
FT_Error
error
;
FT_TRACE1
(
(
"
Init_Context
:
new
object
at
0x
%
08p
\
n
"
exec
)
)
;
exec
-
>
memory
=
memory
;
exec
-
>
callSize
=
32
;
if
(
FT_NEW_ARRAY
(
exec
-
>
callStack
exec
-
>
callSize
)
)
goto
Fail_Memory
;
exec
-
>
maxPoints
=
0
;
exec
-
>
maxContours
=
0
;
exec
-
>
stackSize
=
0
;
exec
-
>
glyphSize
=
0
;
exec
-
>
stack
=
NULL
;
exec
-
>
glyphIns
=
NULL
;
exec
-
>
face
=
NULL
;
exec
-
>
size
=
NULL
;
return
FT_Err_Ok
;
Fail_Memory
:
FT_ERROR
(
(
"
Init_Context
:
not
enough
memory
for
%
p
\
n
"
exec
)
)
;
TT_Done_Context
(
exec
)
;
return
error
;
}
FT_LOCAL_DEF
(
FT_Error
)
Update_Max
(
FT_Memory
memory
FT_ULong
*
size
FT_ULong
multiplier
void
*
_pbuff
FT_ULong
new_max
)
{
FT_Error
error
;
void
*
*
pbuff
=
(
void
*
*
)
_pbuff
;
if
(
*
size
<
new_max
)
{
if
(
FT_REALLOC
(
*
pbuff
*
size
*
multiplier
new_max
*
multiplier
)
)
return
error
;
*
size
=
new_max
;
}
return
FT_Err_Ok
;
}
FT_LOCAL_DEF
(
FT_Error
)
TT_Load_Context
(
TT_ExecContext
exec
TT_Face
face
TT_Size
size
)
{
FT_Int
i
;
FT_ULong
tmp
;
TT_MaxProfile
*
maxp
;
FT_Error
error
;
exec
-
>
face
=
face
;
maxp
=
&
face
-
>
max_profile
;
exec
-
>
size
=
size
;
if
(
size
)
{
exec
-
>
numFDefs
=
size
-
>
num_function_defs
;
exec
-
>
maxFDefs
=
size
-
>
max_function_defs
;
exec
-
>
numIDefs
=
size
-
>
num_instruction_defs
;
exec
-
>
maxIDefs
=
size
-
>
max_instruction_defs
;
exec
-
>
FDefs
=
size
-
>
function_defs
;
exec
-
>
IDefs
=
size
-
>
instruction_defs
;
exec
-
>
pointSize
=
size
-
>
point_size
;
exec
-
>
tt_metrics
=
size
-
>
ttmetrics
;
exec
-
>
metrics
=
*
size
-
>
metrics
;
exec
-
>
maxFunc
=
size
-
>
max_func
;
exec
-
>
maxIns
=
size
-
>
max_ins
;
for
(
i
=
0
;
i
<
TT_MAX_CODE_RANGES
;
i
+
+
)
exec
-
>
codeRangeTable
[
i
]
=
size
-
>
codeRangeTable
[
i
]
;
exec
-
>
GS
=
size
-
>
GS
;
exec
-
>
cvtSize
=
size
-
>
cvt_size
;
exec
-
>
cvt
=
size
-
>
cvt
;
exec
-
>
storeSize
=
size
-
>
storage_size
;
exec
-
>
storage
=
size
-
>
storage
;
exec
-
>
twilight
=
size
-
>
twilight
;
FT_ZERO
(
&
exec
-
>
zp0
)
;
exec
-
>
zp1
=
exec
-
>
zp0
;
exec
-
>
zp2
=
exec
-
>
zp0
;
}
tmp
=
(
FT_ULong
)
exec
-
>
stackSize
;
error
=
Update_Max
(
exec
-
>
memory
&
tmp
sizeof
(
FT_F26Dot6
)
(
void
*
)
&
exec
-
>
stack
maxp
-
>
maxStackElements
+
32
)
;
exec
-
>
stackSize
=
(
FT_Long
)
tmp
;
if
(
error
)
return
error
;
tmp
=
exec
-
>
glyphSize
;
error
=
Update_Max
(
exec
-
>
memory
&
tmp
sizeof
(
FT_Byte
)
(
void
*
)
&
exec
-
>
glyphIns
maxp
-
>
maxSizeOfInstructions
)
;
exec
-
>
glyphSize
=
(
FT_UShort
)
tmp
;
if
(
error
)
return
error
;
exec
-
>
pts
.
n_points
=
0
;
exec
-
>
pts
.
n_contours
=
0
;
exec
-
>
zp1
=
exec
-
>
pts
;
exec
-
>
zp2
=
exec
-
>
pts
;
exec
-
>
zp0
=
exec
-
>
pts
;
exec
-
>
instruction_trap
=
FALSE
;
return
FT_Err_Ok
;
}
FT_LOCAL_DEF
(
void
)
TT_Save_Context
(
TT_ExecContext
exec
TT_Size
size
)
{
FT_Int
i
;
size
-
>
num_function_defs
=
exec
-
>
numFDefs
;
size
-
>
num_instruction_defs
=
exec
-
>
numIDefs
;
size
-
>
max_func
=
exec
-
>
maxFunc
;
size
-
>
max_ins
=
exec
-
>
maxIns
;
for
(
i
=
0
;
i
<
TT_MAX_CODE_RANGES
;
i
+
+
)
size
-
>
codeRangeTable
[
i
]
=
exec
-
>
codeRangeTable
[
i
]
;
}
FT_LOCAL_DEF
(
FT_Error
)
TT_Run_Context
(
TT_ExecContext
exec
)
{
TT_Goto_CodeRange
(
exec
tt_coderange_glyph
0
)
;
exec
-
>
zp0
=
exec
-
>
pts
;
exec
-
>
zp1
=
exec
-
>
pts
;
exec
-
>
zp2
=
exec
-
>
pts
;
exec
-
>
GS
.
gep0
=
1
;
exec
-
>
GS
.
gep1
=
1
;
exec
-
>
GS
.
gep2
=
1
;
exec
-
>
GS
.
projVector
.
x
=
0x4000
;
exec
-
>
GS
.
projVector
.
y
=
0x0000
;
exec
-
>
GS
.
freeVector
=
exec
-
>
GS
.
projVector
;
exec
-
>
GS
.
dualVector
=
exec
-
>
GS
.
projVector
;
exec
-
>
GS
.
round_state
=
1
;
exec
-
>
GS
.
loop
=
1
;
exec
-
>
top
=
0
;
exec
-
>
callTop
=
0
;
return
exec
-
>
face
-
>
interpreter
(
exec
)
;
}
const
TT_GraphicsState
tt_default_graphics_state
=
{
0
0
0
{
0x4000
0
}
{
0x4000
0
}
{
0x4000
0
}
1
64
1
TRUE
68
0
0
9
3
0
FALSE
0
1
1
1
}
;
FT_EXPORT_DEF
(
TT_ExecContext
)
TT_New_Context
(
TT_Driver
driver
)
{
FT_Memory
memory
;
FT_Error
error
;
TT_ExecContext
exec
=
NULL
;
if
(
!
driver
)
goto
Fail
;
memory
=
driver
-
>
root
.
root
.
memory
;
if
(
FT_NEW
(
exec
)
)
goto
Fail
;
error
=
Init_Context
(
exec
memory
)
;
if
(
error
)
goto
Fail
;
return
exec
;
Fail
:
return
NULL
;
}
#
undef
PACK
#
define
PACK
(
x
y
)
(
(
x
<
<
4
)
|
y
)
static
const
FT_Byte
Pop_Push_Count
[
256
]
=
{
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
0
2
)
PACK
(
0
2
)
PACK
(
0
0
)
PACK
(
5
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
1
0
)
PACK
(
0
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
2
)
PACK
(
1
0
)
PACK
(
0
0
)
PACK
(
2
2
)
PACK
(
0
1
)
PACK
(
1
1
)
PACK
(
1
0
)
PACK
(
2
0
)
PACK
(
0
0
)
PACK
(
1
0
)
PACK
(
2
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
0
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
0
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
2
0
)
PACK
(
1
1
)
PACK
(
2
0
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
2
0
)
PACK
(
2
1
)
PACK
(
2
1
)
PACK
(
0
1
)
PACK
(
0
1
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
1
0
)
PACK
(
2
1
)
PACK
(
2
1
)
PACK
(
2
1
)
PACK
(
2
1
)
PACK
(
2
1
)
PACK
(
2
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
0
)
PACK
(
0
0
)
PACK
(
2
1
)
PACK
(
2
1
)
PACK
(
1
1
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
2
1
)
PACK
(
2
1
)
PACK
(
2
1
)
PACK
(
2
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
1
1
)
PACK
(
2
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
0
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
1
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
1
1
)
PACK
(
1
0
)
PACK
(
3
3
)
PACK
(
2
1
)
PACK
(
2
1
)
PACK
(
1
0
)
PACK
(
2
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
1
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
0
)
PACK
(
0
1
)
PACK
(
0
2
)
PACK
(
0
3
)
PACK
(
0
4
)
PACK
(
0
5
)
PACK
(
0
6
)
PACK
(
0
7
)
PACK
(
0
8
)
PACK
(
0
1
)
PACK
(
0
2
)
PACK
(
0
3
)
PACK
(
0
4
)
PACK
(
0
5
)
PACK
(
0
6
)
PACK
(
0
7
)
PACK
(
0
8
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
1
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
PACK
(
2
0
)
}
;
#
ifdef
FT_DEBUG_LEVEL_TRACE
static
const
char
*
const
opcode_name
[
256
]
=
{
"
8
SVTCA
[
y
]
"
"
8
SVTCA
[
x
]
"
"
9
SPVTCA
[
y
]
"
"
9
SPVTCA
[
x
]
"
"
9
SFVTCA
[
y
]
"
"
9
SFVTCA
[
x
]
"
"
9
SPVTL
[
|
|
]
"
"
8
SPVTL
[
+
]
"
"
9
SFVTL
[
|
|
]
"
"
8
SFVTL
[
+
]
"
"
5
SPVFS
"
"
5
SFVFS
"
"
3
GPV
"
"
3
GFV
"
"
6
SFVTPV
"
"
5
ISECT
"
"
4
SRP0
"
"
4
SRP1
"
"
4
SRP2
"
"
4
SZP0
"
"
4
SZP1
"
"
4
SZP2
"
"
4
SZPS
"
"
5
SLOOP
"
"
3
RTG
"
"
4
RTHG
"
"
3
SMD
"
"
4
ELSE
"
"
4
JMPR
"
"
6
SCVTCI
"
"
5
SSWCI
"
"
3
SSW
"
"
3
DUP
"
"
3
POP
"
"
5
CLEAR
"
"
4
SWAP
"
"
5
DEPTH
"
"
6
CINDEX
"
"
6
MINDEX
"
"
8
ALIGNPTS
"
"
7
INS_
28
"
"
3
UTP
"
"
8
LOOPCALL
"
"
4
CALL
"
"
4
FDEF
"
"
4
ENDF
"
"
6
MDAP
[
]
"
"
9
MDAP
[
rnd
]
"
"
6
IUP
[
y
]
"
"
6
IUP
[
x
]
"
"
8
SHP
[
rp2
]
"
"
8
SHP
[
rp1
]
"
"
8
SHC
[
rp2
]
"
"
8
SHC
[
rp1
]
"
"
8
SHZ
[
rp2
]
"
"
8
SHZ
[
rp1
]
"
"
5
SHPIX
"
"
2
IP
"
"
7
MSIRP
[
]
"
"
A
MSIRP
[
rp0
]
"
"
7
ALIGNRP
"
"
4
RTDG
"
"
6
MIAP
[
]
"
"
9
MIAP
[
rnd
]
"
"
6
NPUSHB
"
"
6
NPUSHW
"
"
2
WS
"
"
2
RS
"
"
5
WCVTP
"
"
4
RCVT
"
"
8
GC
[
curr
]
"
"
8
GC
[
orig
]
"
"
4
SCFS
"
"
8
MD
[
curr
]
"
"
8
MD
[
orig
]
"
"
5
MPPEM
"
"
3
MPS
"
"
6
FLIPON
"
"
7
FLIPOFF
"
"
5
DEBUG
"
"
2
LT
"
"
4
LTEQ
"
"
2
GT
"
"
4
GTEQ
"
"
2
EQ
"
"
3
NEQ
"
"
3
ODD
"
"
4
EVEN
"
"
2
IF
"
"
3
EIF
"
"
3
AND
"
"
2
OR
"
"
3
NOT
"
"
7
DELTAP1
"
"
3
SDB
"
"
3
SDS
"
"
3
ADD
"
"
3
SUB
"
"
3
DIV
"
"
3
MUL
"
"
3
ABS
"
"
3
NEG
"
"
5
FLOOR
"
"
7
CEILING
"
"
8
ROUND
[
G
]
"
"
8
ROUND
[
B
]
"
"
8
ROUND
[
W
]
"
"
7
ROUND
[
]
"
"
9
NROUND
[
G
]
"
"
9
NROUND
[
B
]
"
"
9
NROUND
[
W
]
"
"
8
NROUND
[
]
"
"
5
WCVTF
"
"
7
DELTAP2
"
"
7
DELTAP3
"
"
7
DELTAC1
"
"
7
DELTAC2
"
"
7
DELTAC3
"
"
6
SROUND
"
"
8
S45ROUND
"
"
4
JROT
"
"
4
JROF
"
"
4
ROFF
"
"
7
INS_
7B
"
"
4
RUTG
"
"
4
RDTG
"
"
5
SANGW
"
"
2
AA
"
"
6
FLIPPT
"
"
8
FLIPRGON
"
"
9
FLIPRGOFF
"
"
7
INS_
83
"
"
7
INS_
84
"
"
8
SCANCTRL
"
"
A
SDPVTL
[
|
|
]
"
"
9
SDPVTL
[
+
]
"
"
7
GETINFO
"
"
4
IDEF
"
"
4
ROLL
"
"
3
MAX
"
"
3
MIN
"
"
8
SCANTYPE
"
"
8
INSTCTRL
"
"
7
INS_
8F
"
"
7
INS_
90
"
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
"
C
GETVARIATION
"
"
7
GETDATA
"
#
else
"
7
INS_
91
"
"
7
INS_
92
"
#
endif
"
7
INS_
93
"
"
7
INS_
94
"
"
7
INS_
95
"
"
7
INS_
96
"
"
7
INS_
97
"
"
7
INS_
98
"
"
7
INS_
99
"
"
7
INS_
9A
"
"
7
INS_
9B
"
"
7
INS_
9C
"
"
7
INS_
9D
"
"
7
INS_
9E
"
"
7
INS_
9F
"
"
7
INS_
A0
"
"
7
INS_
A1
"
"
7
INS_
A2
"
"
7
INS_
A3
"
"
7
INS_
A4
"
"
7
INS_
A5
"
"
7
INS_
A6
"
"
7
INS_
A7
"
"
7
INS_
A8
"
"
7
INS_
A9
"
"
7
INS_
AA
"
"
7
INS_
AB
"
"
7
INS_
AC
"
"
7
INS_
AD
"
"
7
INS_
AE
"
"
7
INS_
AF
"
"
8
PUSHB
[
0
]
"
"
8
PUSHB
[
1
]
"
"
8
PUSHB
[
2
]
"
"
8
PUSHB
[
3
]
"
"
8
PUSHB
[
4
]
"
"
8
PUSHB
[
5
]
"
"
8
PUSHB
[
6
]
"
"
8
PUSHB
[
7
]
"
"
8
PUSHW
[
0
]
"
"
8
PUSHW
[
1
]
"
"
8
PUSHW
[
2
]
"
"
8
PUSHW
[
3
]
"
"
8
PUSHW
[
4
]
"
"
8
PUSHW
[
5
]
"
"
8
PUSHW
[
6
]
"
"
8
PUSHW
[
7
]
"
"
7
MDRP
[
G
]
"
"
7
MDRP
[
B
]
"
"
7
MDRP
[
W
]
"
"
6
MDRP
[
]
"
"
8
MDRP
[
rG
]
"
"
8
MDRP
[
rB
]
"
"
8
MDRP
[
rW
]
"
"
7
MDRP
[
r
]
"
"
8
MDRP
[
mG
]
"
"
8
MDRP
[
mB
]
"
"
8
MDRP
[
mW
]
"
"
7
MDRP
[
m
]
"
"
9
MDRP
[
mrG
]
"
"
9
MDRP
[
mrB
]
"
"
9
MDRP
[
mrW
]
"
"
8
MDRP
[
mr
]
"
"
8
MDRP
[
pG
]
"
"
8
MDRP
[
pB
]
"
"
8
MDRP
[
pW
]
"
"
7
MDRP
[
p
]
"
"
9
MDRP
[
prG
]
"
"
9
MDRP
[
prB
]
"
"
9
MDRP
[
prW
]
"
"
8
MDRP
[
pr
]
"
"
9
MDRP
[
pmG
]
"
"
9
MDRP
[
pmB
]
"
"
9
MDRP
[
pmW
]
"
"
8
MDRP
[
pm
]
"
"
A
MDRP
[
pmrG
]
"
"
A
MDRP
[
pmrB
]
"
"
A
MDRP
[
pmrW
]
"
"
9
MDRP
[
pmr
]
"
"
7
MIRP
[
G
]
"
"
7
MIRP
[
B
]
"
"
7
MIRP
[
W
]
"
"
6
MIRP
[
]
"
"
8
MIRP
[
rG
]
"
"
8
MIRP
[
rB
]
"
"
8
MIRP
[
rW
]
"
"
7
MIRP
[
r
]
"
"
8
MIRP
[
mG
]
"
"
8
MIRP
[
mB
]
"
"
8
MIRP
[
mW
]
"
"
7
MIRP
[
m
]
"
"
9
MIRP
[
mrG
]
"
"
9
MIRP
[
mrB
]
"
"
9
MIRP
[
mrW
]
"
"
8
MIRP
[
mr
]
"
"
8
MIRP
[
pG
]
"
"
8
MIRP
[
pB
]
"
"
8
MIRP
[
pW
]
"
"
7
MIRP
[
p
]
"
"
9
MIRP
[
prG
]
"
"
9
MIRP
[
prB
]
"
"
9
MIRP
[
prW
]
"
"
8
MIRP
[
pr
]
"
"
9
MIRP
[
pmG
]
"
"
9
MIRP
[
pmB
]
"
"
9
MIRP
[
pmW
]
"
"
8
MIRP
[
pm
]
"
"
A
MIRP
[
pmrG
]
"
"
A
MIRP
[
pmrB
]
"
"
A
MIRP
[
pmrW
]
"
"
9
MIRP
[
pmr
]
"
}
;
#
endif
static
const
FT_Char
opcode_length
[
256
]
=
{
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
-
1
-
2
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
2
3
4
5
6
7
8
9
3
5
7
9
11
13
15
17
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
}
;
#
undef
PACK
#
ifndef
FT_CONFIG_OPTION_NO_ASSEMBLER
#
if
defined
(
__arm__
)
&
&
\
(
defined
(
__thumb2__
)
|
|
!
defined
(
__thumb__
)
)
#
define
TT_MulFix14
TT_MulFix14_arm
static
FT_Int32
TT_MulFix14_arm
(
FT_Int32
a
FT_Int
b
)
{
FT_Int32
t
t2
;
#
if
defined
(
__CC_ARM
)
|
|
defined
(
__ARMCC__
)
__asm
{
smull
t2
t
b
a
mov
a
t
asr
#
31
add
a
a
#
0x2000
adds
t2
t2
a
adc
t
t
#
0
mov
a
t2
lsr
#
14
orr
a
a
t
lsl
#
18
}
#
elif
defined
(
__GNUC__
)
__asm__
__volatile__
(
"
smull
%
1
%
2
%
4
%
3
\
n
\
t
"
"
mov
%
0
%
2
asr
#
31
\
n
\
t
"
#
if
defined
(
__clang__
)
&
&
defined
(
__thumb2__
)
"
add
.
w
%
0
%
0
#
0x2000
\
n
\
t
"
#
else
"
add
%
0
%
0
#
0x2000
\
n
\
t
"
#
endif
"
adds
%
1
%
1
%
0
\
n
\
t
"
"
adc
%
2
%
2
#
0
\
n
\
t
"
"
mov
%
0
%
1
lsr
#
14
\
n
\
t
"
"
orr
%
0
%
0
%
2
lsl
#
18
\
n
\
t
"
:
"
=
r
"
(
a
)
"
=
&
r
"
(
t2
)
"
=
&
r
"
(
t
)
:
"
r
"
(
a
)
"
r
"
(
b
)
:
"
cc
"
)
;
#
endif
return
a
;
}
#
endif
#
endif
#
if
defined
(
__GNUC__
)
&
&
\
(
defined
(
__i386__
)
|
|
defined
(
__x86_64__
)
)
#
define
TT_MulFix14
TT_MulFix14_long_long
#
if
(
__GNUC__
*
100
+
__GNUC_MINOR__
)
>
=
406
#
pragma
GCC
diagnostic
push
#
endif
#
pragma
GCC
diagnostic
ignored
"
-
Wlong
-
long
"
static
__attribute__
(
(
noinline
)
)
__attribute__
(
(
pure
)
)
FT_Int32
TT_MulFix14_long_long
(
FT_Int32
a
FT_Int
b
)
{
long
long
ret
=
(
long
long
)
a
*
b
;
long
long
tmp
=
ret
>
>
63
;
ret
+
=
0x2000
+
tmp
;
return
(
FT_Int32
)
(
ret
>
>
14
)
;
}
#
if
(
__GNUC__
*
100
+
__GNUC_MINOR__
)
>
=
406
#
pragma
GCC
diagnostic
pop
#
endif
#
endif
#
ifndef
TT_MulFix14
static
FT_Int32
TT_MulFix14
(
FT_Int32
a
FT_Int
b
)
{
FT_Int32
sign
;
FT_UInt32
ah
al
mid
lo
hi
;
sign
=
a
^
b
;
if
(
a
<
0
)
a
=
-
a
;
if
(
b
<
0
)
b
=
-
b
;
ah
=
(
FT_UInt32
)
(
(
a
>
>
16
)
&
0xFFFFU
)
;
al
=
(
FT_UInt32
)
(
a
&
0xFFFFU
)
;
lo
=
al
*
b
;
mid
=
ah
*
b
;
hi
=
mid
>
>
16
;
mid
=
(
mid
<
<
16
)
+
(
1
<
<
13
)
;
lo
+
=
mid
;
if
(
lo
<
mid
)
hi
+
=
1
;
mid
=
(
lo
>
>
14
)
|
(
hi
<
<
18
)
;
return
sign
>
=
0
?
(
FT_Int32
)
mid
:
-
(
FT_Int32
)
mid
;
}
#
endif
#
if
defined
(
__GNUC__
)
&
&
\
(
defined
(
__i386__
)
|
|
\
defined
(
__x86_64__
)
|
|
\
defined
(
__arm__
)
)
#
define
TT_DotFix14
TT_DotFix14_long_long
#
if
(
__GNUC__
*
100
+
__GNUC_MINOR__
)
>
=
406
#
pragma
GCC
diagnostic
push
#
endif
#
pragma
GCC
diagnostic
ignored
"
-
Wlong
-
long
"
static
__attribute__
(
(
pure
)
)
FT_Int32
TT_DotFix14_long_long
(
FT_Int32
ax
FT_Int32
ay
FT_Int
bx
FT_Int
by
)
{
long
long
temp1
=
(
long
long
)
ax
*
bx
;
long
long
temp2
=
(
long
long
)
ay
*
by
;
temp1
+
=
temp2
;
temp2
=
temp1
>
>
63
;
temp1
+
=
0x2000
+
temp2
;
return
(
FT_Int32
)
(
temp1
>
>
14
)
;
}
#
if
(
__GNUC__
*
100
+
__GNUC_MINOR__
)
>
=
406
#
pragma
GCC
diagnostic
pop
#
endif
#
endif
#
ifndef
TT_DotFix14
static
FT_Int32
TT_DotFix14
(
FT_Int32
ax
FT_Int32
ay
FT_Int
bx
FT_Int
by
)
{
FT_Int32
m
s
hi1
hi2
hi
;
FT_UInt32
l
lo1
lo2
lo
;
l
=
(
FT_UInt32
)
(
(
ax
&
0xFFFFU
)
*
bx
)
;
m
=
(
ax
>
>
16
)
*
bx
;
lo1
=
l
+
(
(
FT_UInt32
)
m
<
<
16
)
;
hi1
=
(
m
>
>
16
)
+
(
(
FT_Int32
)
l
>
>
31
)
+
(
lo1
<
l
)
;
l
=
(
FT_UInt32
)
(
(
ay
&
0xFFFFU
)
*
by
)
;
m
=
(
ay
>
>
16
)
*
by
;
lo2
=
l
+
(
(
FT_UInt32
)
m
<
<
16
)
;
hi2
=
(
m
>
>
16
)
+
(
(
FT_Int32
)
l
>
>
31
)
+
(
lo2
<
l
)
;
lo
=
lo1
+
lo2
;
hi
=
hi1
+
hi2
+
(
lo
<
lo1
)
;
s
=
hi
>
>
31
;
l
=
lo
+
(
FT_UInt32
)
s
;
hi
+
=
s
+
(
l
<
lo
)
;
lo
=
l
;
l
=
lo
+
0x2000U
;
hi
+
=
(
l
<
lo
)
;
return
(
FT_Int32
)
(
(
(
FT_UInt32
)
hi
<
<
18
)
|
(
l
>
>
14
)
)
;
}
#
endif
static
FT_Long
Current_Ratio
(
TT_ExecContext
exc
)
{
if
(
!
exc
-
>
tt_metrics
.
ratio
)
{
if
(
exc
-
>
GS
.
projVector
.
y
=
=
0
)
exc
-
>
tt_metrics
.
ratio
=
exc
-
>
tt_metrics
.
x_ratio
;
else
if
(
exc
-
>
GS
.
projVector
.
x
=
=
0
)
exc
-
>
tt_metrics
.
ratio
=
exc
-
>
tt_metrics
.
y_ratio
;
else
{
FT_F26Dot6
x
y
;
x
=
TT_MulFix14
(
exc
-
>
tt_metrics
.
x_ratio
exc
-
>
GS
.
projVector
.
x
)
;
y
=
TT_MulFix14
(
exc
-
>
tt_metrics
.
y_ratio
exc
-
>
GS
.
projVector
.
y
)
;
exc
-
>
tt_metrics
.
ratio
=
FT_Hypot
(
x
y
)
;
}
}
return
exc
-
>
tt_metrics
.
ratio
;
}
FT_CALLBACK_DEF
(
FT_Long
)
Current_Ppem
(
TT_ExecContext
exc
)
{
return
exc
-
>
tt_metrics
.
ppem
;
}
FT_CALLBACK_DEF
(
FT_Long
)
Current_Ppem_Stretched
(
TT_ExecContext
exc
)
{
return
FT_MulFix
(
exc
-
>
tt_metrics
.
ppem
Current_Ratio
(
exc
)
)
;
}
FT_CALLBACK_DEF
(
FT_F26Dot6
)
Read_CVT
(
TT_ExecContext
exc
FT_ULong
idx
)
{
return
exc
-
>
cvt
[
idx
]
;
}
FT_CALLBACK_DEF
(
FT_F26Dot6
)
Read_CVT_Stretched
(
TT_ExecContext
exc
FT_ULong
idx
)
{
return
FT_MulFix
(
exc
-
>
cvt
[
idx
]
Current_Ratio
(
exc
)
)
;
}
FT_CALLBACK_DEF
(
void
)
Write_CVT
(
TT_ExecContext
exc
FT_ULong
idx
FT_F26Dot6
value
)
{
exc
-
>
cvt
[
idx
]
=
value
;
}
FT_CALLBACK_DEF
(
void
)
Write_CVT_Stretched
(
TT_ExecContext
exc
FT_ULong
idx
FT_F26Dot6
value
)
{
exc
-
>
cvt
[
idx
]
=
FT_DivFix
(
value
Current_Ratio
(
exc
)
)
;
}
FT_CALLBACK_DEF
(
void
)
Move_CVT
(
TT_ExecContext
exc
FT_ULong
idx
FT_F26Dot6
value
)
{
exc
-
>
cvt
[
idx
]
=
ADD_LONG
(
exc
-
>
cvt
[
idx
]
value
)
;
}
FT_CALLBACK_DEF
(
void
)
Move_CVT_Stretched
(
TT_ExecContext
exc
FT_ULong
idx
FT_F26Dot6
value
)
{
exc
-
>
cvt
[
idx
]
=
ADD_LONG
(
exc
-
>
cvt
[
idx
]
FT_DivFix
(
value
Current_Ratio
(
exc
)
)
)
;
}
static
FT_Short
GetShortIns
(
TT_ExecContext
exc
)
{
exc
-
>
IP
+
=
2
;
return
(
FT_Short
)
(
(
exc
-
>
code
[
exc
-
>
IP
-
2
]
<
<
8
)
+
exc
-
>
code
[
exc
-
>
IP
-
1
]
)
;
}
static
FT_Bool
Ins_Goto_CodeRange
(
TT_ExecContext
exc
FT_Int
aRange
FT_Long
aIP
)
{
TT_CodeRange
*
range
;
if
(
aRange
<
1
|
|
aRange
>
3
)
{
exc
-
>
error
=
FT_THROW
(
Bad_Argument
)
;
return
FAILURE
;
}
range
=
&
exc
-
>
codeRangeTable
[
aRange
-
1
]
;
if
(
!
range
-
>
base
)
{
exc
-
>
error
=
FT_THROW
(
Invalid_CodeRange
)
;
return
FAILURE
;
}
if
(
aIP
>
range
-
>
size
)
{
exc
-
>
error
=
FT_THROW
(
Code_Overflow
)
;
return
FAILURE
;
}
exc
-
>
code
=
range
-
>
base
;
exc
-
>
codeSize
=
range
-
>
size
;
exc
-
>
IP
=
aIP
;
exc
-
>
curRange
=
aRange
;
return
SUCCESS
;
}
static
void
Direct_Move
(
TT_ExecContext
exc
TT_GlyphZone
zone
FT_UShort
point
FT_F26Dot6
distance
)
{
FT_F26Dot6
v
;
v
=
exc
-
>
GS
.
freeVector
.
x
;
if
(
v
!
=
0
)
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
(
!
exc
-
>
ignore_x_mode
|
|
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_ALLOW_X_DMOVE
)
)
)
zone
-
>
cur
[
point
]
.
x
=
ADD_LONG
(
zone
-
>
cur
[
point
]
.
x
FT_MulDiv
(
distance
v
exc
-
>
F_dot_P
)
)
;
else
#
endif
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
SUBPIXEL_HINTING_MINIMAL
&
&
!
exc
-
>
backward_compatibility
)
zone
-
>
cur
[
point
]
.
x
=
ADD_LONG
(
zone
-
>
cur
[
point
]
.
x
FT_MulDiv
(
distance
v
exc
-
>
F_dot_P
)
)
;
else
#
endif
if
(
NO_SUBPIXEL_HINTING
)
zone
-
>
cur
[
point
]
.
x
=
ADD_LONG
(
zone
-
>
cur
[
point
]
.
x
FT_MulDiv
(
distance
v
exc
-
>
F_dot_P
)
)
;
zone
-
>
tags
[
point
]
|
=
FT_CURVE_TAG_TOUCH_X
;
}
v
=
exc
-
>
GS
.
freeVector
.
y
;
if
(
v
!
=
0
)
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
!
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
backward_compatibility
&
&
exc
-
>
iupx_called
&
&
exc
-
>
iupy_called
)
)
#
endif
zone
-
>
cur
[
point
]
.
y
=
ADD_LONG
(
zone
-
>
cur
[
point
]
.
y
FT_MulDiv
(
distance
v
exc
-
>
F_dot_P
)
)
;
zone
-
>
tags
[
point
]
|
=
FT_CURVE_TAG_TOUCH_Y
;
}
}
static
void
Direct_Move_Orig
(
TT_ExecContext
exc
TT_GlyphZone
zone
FT_UShort
point
FT_F26Dot6
distance
)
{
FT_F26Dot6
v
;
v
=
exc
-
>
GS
.
freeVector
.
x
;
if
(
v
!
=
0
)
zone
-
>
org
[
point
]
.
x
=
ADD_LONG
(
zone
-
>
org
[
point
]
.
x
FT_MulDiv
(
distance
v
exc
-
>
F_dot_P
)
)
;
v
=
exc
-
>
GS
.
freeVector
.
y
;
if
(
v
!
=
0
)
zone
-
>
org
[
point
]
.
y
=
ADD_LONG
(
zone
-
>
org
[
point
]
.
y
FT_MulDiv
(
distance
v
exc
-
>
F_dot_P
)
)
;
}
static
void
Direct_Move_X
(
TT_ExecContext
exc
TT_GlyphZone
zone
FT_UShort
point
FT_F26Dot6
distance
)
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
!
exc
-
>
ignore_x_mode
)
zone
-
>
cur
[
point
]
.
x
=
ADD_LONG
(
zone
-
>
cur
[
point
]
.
x
distance
)
;
else
#
endif
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
SUBPIXEL_HINTING_MINIMAL
&
&
!
exc
-
>
backward_compatibility
)
zone
-
>
cur
[
point
]
.
x
=
ADD_LONG
(
zone
-
>
cur
[
point
]
.
x
distance
)
;
else
#
endif
if
(
NO_SUBPIXEL_HINTING
)
zone
-
>
cur
[
point
]
.
x
=
ADD_LONG
(
zone
-
>
cur
[
point
]
.
x
distance
)
;
zone
-
>
tags
[
point
]
|
=
FT_CURVE_TAG_TOUCH_X
;
}
static
void
Direct_Move_Y
(
TT_ExecContext
exc
TT_GlyphZone
zone
FT_UShort
point
FT_F26Dot6
distance
)
{
FT_UNUSED
(
exc
)
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
!
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
backward_compatibility
&
&
exc
-
>
iupx_called
&
&
exc
-
>
iupy_called
)
)
#
endif
zone
-
>
cur
[
point
]
.
y
=
ADD_LONG
(
zone
-
>
cur
[
point
]
.
y
distance
)
;
zone
-
>
tags
[
point
]
|
=
FT_CURVE_TAG_TOUCH_Y
;
}
static
void
Direct_Move_Orig_X
(
TT_ExecContext
exc
TT_GlyphZone
zone
FT_UShort
point
FT_F26Dot6
distance
)
{
FT_UNUSED
(
exc
)
;
zone
-
>
org
[
point
]
.
x
=
ADD_LONG
(
zone
-
>
org
[
point
]
.
x
distance
)
;
}
static
void
Direct_Move_Orig_Y
(
TT_ExecContext
exc
TT_GlyphZone
zone
FT_UShort
point
FT_F26Dot6
distance
)
{
FT_UNUSED
(
exc
)
;
zone
-
>
org
[
point
]
.
y
=
ADD_LONG
(
zone
-
>
org
[
point
]
.
y
distance
)
;
}
static
FT_F26Dot6
Round_None
(
TT_ExecContext
exc
FT_F26Dot6
distance
FT_F26Dot6
compensation
)
{
FT_F26Dot6
val
;
FT_UNUSED
(
exc
)
;
if
(
distance
>
=
0
)
{
val
=
ADD_LONG
(
distance
compensation
)
;
if
(
val
<
0
)
val
=
0
;
}
else
{
val
=
SUB_LONG
(
distance
compensation
)
;
if
(
val
>
0
)
val
=
0
;
}
return
val
;
}
static
FT_F26Dot6
Round_To_Grid
(
TT_ExecContext
exc
FT_F26Dot6
distance
FT_F26Dot6
compensation
)
{
FT_F26Dot6
val
;
FT_UNUSED
(
exc
)
;
if
(
distance
>
=
0
)
{
val
=
FT_PIX_ROUND_LONG
(
ADD_LONG
(
distance
compensation
)
)
;
if
(
val
<
0
)
val
=
0
;
}
else
{
val
=
NEG_LONG
(
FT_PIX_ROUND_LONG
(
SUB_LONG
(
compensation
distance
)
)
)
;
if
(
val
>
0
)
val
=
0
;
}
return
val
;
}
static
FT_F26Dot6
Round_To_Half_Grid
(
TT_ExecContext
exc
FT_F26Dot6
distance
FT_F26Dot6
compensation
)
{
FT_F26Dot6
val
;
FT_UNUSED
(
exc
)
;
if
(
distance
>
=
0
)
{
val
=
ADD_LONG
(
FT_PIX_FLOOR
(
ADD_LONG
(
distance
compensation
)
)
32
)
;
if
(
val
<
0
)
val
=
32
;
}
else
{
val
=
NEG_LONG
(
ADD_LONG
(
FT_PIX_FLOOR
(
SUB_LONG
(
compensation
distance
)
)
32
)
)
;
if
(
val
>
0
)
val
=
-
32
;
}
return
val
;
}
static
FT_F26Dot6
Round_Down_To_Grid
(
TT_ExecContext
exc
FT_F26Dot6
distance
FT_F26Dot6
compensation
)
{
FT_F26Dot6
val
;
FT_UNUSED
(
exc
)
;
if
(
distance
>
=
0
)
{
val
=
FT_PIX_FLOOR
(
ADD_LONG
(
distance
compensation
)
)
;
if
(
val
<
0
)
val
=
0
;
}
else
{
val
=
NEG_LONG
(
FT_PIX_FLOOR
(
SUB_LONG
(
compensation
distance
)
)
)
;
if
(
val
>
0
)
val
=
0
;
}
return
val
;
}
static
FT_F26Dot6
Round_Up_To_Grid
(
TT_ExecContext
exc
FT_F26Dot6
distance
FT_F26Dot6
compensation
)
{
FT_F26Dot6
val
;
FT_UNUSED
(
exc
)
;
if
(
distance
>
=
0
)
{
val
=
FT_PIX_CEIL_LONG
(
ADD_LONG
(
distance
compensation
)
)
;
if
(
val
<
0
)
val
=
0
;
}
else
{
val
=
NEG_LONG
(
FT_PIX_CEIL_LONG
(
SUB_LONG
(
compensation
distance
)
)
)
;
if
(
val
>
0
)
val
=
0
;
}
return
val
;
}
static
FT_F26Dot6
Round_To_Double_Grid
(
TT_ExecContext
exc
FT_F26Dot6
distance
FT_F26Dot6
compensation
)
{
FT_F26Dot6
val
;
FT_UNUSED
(
exc
)
;
if
(
distance
>
=
0
)
{
val
=
FT_PAD_ROUND_LONG
(
ADD_LONG
(
distance
compensation
)
32
)
;
if
(
val
<
0
)
val
=
0
;
}
else
{
val
=
NEG_LONG
(
FT_PAD_ROUND_LONG
(
SUB_LONG
(
compensation
distance
)
32
)
)
;
if
(
val
>
0
)
val
=
0
;
}
return
val
;
}
static
FT_F26Dot6
Round_Super
(
TT_ExecContext
exc
FT_F26Dot6
distance
FT_F26Dot6
compensation
)
{
FT_F26Dot6
val
;
if
(
distance
>
=
0
)
{
val
=
ADD_LONG
(
distance
exc
-
>
threshold
-
exc
-
>
phase
+
compensation
)
&
-
exc
-
>
period
;
val
=
ADD_LONG
(
val
exc
-
>
phase
)
;
if
(
val
<
0
)
val
=
exc
-
>
phase
;
}
else
{
val
=
NEG_LONG
(
SUB_LONG
(
exc
-
>
threshold
-
exc
-
>
phase
+
compensation
distance
)
&
-
exc
-
>
period
)
;
val
=
SUB_LONG
(
val
exc
-
>
phase
)
;
if
(
val
>
0
)
val
=
-
exc
-
>
phase
;
}
return
val
;
}
static
FT_F26Dot6
Round_Super_45
(
TT_ExecContext
exc
FT_F26Dot6
distance
FT_F26Dot6
compensation
)
{
FT_F26Dot6
val
;
if
(
distance
>
=
0
)
{
val
=
(
ADD_LONG
(
distance
exc
-
>
threshold
-
exc
-
>
phase
+
compensation
)
/
exc
-
>
period
)
*
exc
-
>
period
;
val
=
ADD_LONG
(
val
exc
-
>
phase
)
;
if
(
val
<
0
)
val
=
exc
-
>
phase
;
}
else
{
val
=
NEG_LONG
(
(
SUB_LONG
(
exc
-
>
threshold
-
exc
-
>
phase
+
compensation
distance
)
/
exc
-
>
period
)
*
exc
-
>
period
)
;
val
=
SUB_LONG
(
val
exc
-
>
phase
)
;
if
(
val
>
0
)
val
=
-
exc
-
>
phase
;
}
return
val
;
}
static
void
Compute_Round
(
TT_ExecContext
exc
FT_Byte
round_mode
)
{
switch
(
round_mode
)
{
case
TT_Round_Off
:
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_None
;
break
;
case
TT_Round_To_Grid
:
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_To_Grid
;
break
;
case
TT_Round_Up_To_Grid
:
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_Up_To_Grid
;
break
;
case
TT_Round_Down_To_Grid
:
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_Down_To_Grid
;
break
;
case
TT_Round_To_Half_Grid
:
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_To_Half_Grid
;
break
;
case
TT_Round_To_Double_Grid
:
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_To_Double_Grid
;
break
;
case
TT_Round_Super
:
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_Super
;
break
;
case
TT_Round_Super_45
:
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_Super_45
;
break
;
}
}
static
void
SetSuperRound
(
TT_ExecContext
exc
FT_F2Dot14
GridPeriod
FT_Long
selector
)
{
switch
(
(
FT_Int
)
(
selector
&
0xC0
)
)
{
case
0
:
exc
-
>
period
=
GridPeriod
/
2
;
break
;
case
0x40
:
exc
-
>
period
=
GridPeriod
;
break
;
case
0x80
:
exc
-
>
period
=
GridPeriod
*
2
;
break
;
case
0xC0
:
exc
-
>
period
=
GridPeriod
;
break
;
}
switch
(
(
FT_Int
)
(
selector
&
0x30
)
)
{
case
0
:
exc
-
>
phase
=
0
;
break
;
case
0x10
:
exc
-
>
phase
=
exc
-
>
period
/
4
;
break
;
case
0x20
:
exc
-
>
phase
=
exc
-
>
period
/
2
;
break
;
case
0x30
:
exc
-
>
phase
=
exc
-
>
period
*
3
/
4
;
break
;
}
if
(
(
selector
&
0x0F
)
=
=
0
)
exc
-
>
threshold
=
exc
-
>
period
-
1
;
else
exc
-
>
threshold
=
(
(
FT_Int
)
(
selector
&
0x0F
)
-
4
)
*
exc
-
>
period
/
8
;
exc
-
>
period
>
>
=
8
;
exc
-
>
phase
>
>
=
8
;
exc
-
>
threshold
>
>
=
8
;
}
static
FT_F26Dot6
Project
(
TT_ExecContext
exc
FT_Pos
dx
FT_Pos
dy
)
{
return
TT_DotFix14
(
dx
dy
exc
-
>
GS
.
projVector
.
x
exc
-
>
GS
.
projVector
.
y
)
;
}
static
FT_F26Dot6
Dual_Project
(
TT_ExecContext
exc
FT_Pos
dx
FT_Pos
dy
)
{
return
TT_DotFix14
(
dx
dy
exc
-
>
GS
.
dualVector
.
x
exc
-
>
GS
.
dualVector
.
y
)
;
}
static
FT_F26Dot6
Project_x
(
TT_ExecContext
exc
FT_Pos
dx
FT_Pos
dy
)
{
FT_UNUSED
(
exc
)
;
FT_UNUSED
(
dy
)
;
return
dx
;
}
static
FT_F26Dot6
Project_y
(
TT_ExecContext
exc
FT_Pos
dx
FT_Pos
dy
)
{
FT_UNUSED
(
exc
)
;
FT_UNUSED
(
dx
)
;
return
dy
;
}
static
void
Compute_Funcs
(
TT_ExecContext
exc
)
{
if
(
exc
-
>
GS
.
freeVector
.
x
=
=
0x4000
)
exc
-
>
F_dot_P
=
exc
-
>
GS
.
projVector
.
x
;
else
if
(
exc
-
>
GS
.
freeVector
.
y
=
=
0x4000
)
exc
-
>
F_dot_P
=
exc
-
>
GS
.
projVector
.
y
;
else
exc
-
>
F_dot_P
=
(
(
FT_Long
)
exc
-
>
GS
.
projVector
.
x
*
exc
-
>
GS
.
freeVector
.
x
+
(
FT_Long
)
exc
-
>
GS
.
projVector
.
y
*
exc
-
>
GS
.
freeVector
.
y
)
>
>
14
;
if
(
exc
-
>
GS
.
projVector
.
x
=
=
0x4000
)
exc
-
>
func_project
=
(
TT_Project_Func
)
Project_x
;
else
if
(
exc
-
>
GS
.
projVector
.
y
=
=
0x4000
)
exc
-
>
func_project
=
(
TT_Project_Func
)
Project_y
;
else
exc
-
>
func_project
=
(
TT_Project_Func
)
Project
;
if
(
exc
-
>
GS
.
dualVector
.
x
=
=
0x4000
)
exc
-
>
func_dualproj
=
(
TT_Project_Func
)
Project_x
;
else
if
(
exc
-
>
GS
.
dualVector
.
y
=
=
0x4000
)
exc
-
>
func_dualproj
=
(
TT_Project_Func
)
Project_y
;
else
exc
-
>
func_dualproj
=
(
TT_Project_Func
)
Dual_Project
;
exc
-
>
func_move
=
(
TT_Move_Func
)
Direct_Move
;
exc
-
>
func_move_orig
=
(
TT_Move_Func
)
Direct_Move_Orig
;
if
(
exc
-
>
F_dot_P
=
=
0x4000L
)
{
if
(
exc
-
>
GS
.
freeVector
.
x
=
=
0x4000
)
{
exc
-
>
func_move
=
(
TT_Move_Func
)
Direct_Move_X
;
exc
-
>
func_move_orig
=
(
TT_Move_Func
)
Direct_Move_Orig_X
;
}
else
if
(
exc
-
>
GS
.
freeVector
.
y
=
=
0x4000
)
{
exc
-
>
func_move
=
(
TT_Move_Func
)
Direct_Move_Y
;
exc
-
>
func_move_orig
=
(
TT_Move_Func
)
Direct_Move_Orig_Y
;
}
}
if
(
FT_ABS
(
exc
-
>
F_dot_P
)
<
0x400L
)
exc
-
>
F_dot_P
=
0x4000L
;
exc
-
>
tt_metrics
.
ratio
=
0
;
}
static
FT_Bool
Normalize
(
FT_F26Dot6
Vx
FT_F26Dot6
Vy
FT_UnitVector
*
R
)
{
FT_Vector
V
;
if
(
Vx
=
=
0
&
&
Vy
=
=
0
)
{
return
SUCCESS
;
}
V
.
x
=
Vx
;
V
.
y
=
Vy
;
FT_Vector_NormLen
(
&
V
)
;
R
-
>
x
=
(
FT_F2Dot14
)
(
V
.
x
/
4
)
;
R
-
>
y
=
(
FT_F2Dot14
)
(
V
.
y
/
4
)
;
return
SUCCESS
;
}
#
define
ARRAY_BOUND_ERROR
\
do
\
{
\
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
\
return
;
\
}
while
(
0
)
static
void
Ins_MPPEM
(
TT_ExecContext
exc
FT_Long
*
args
)
{
args
[
0
]
=
exc
-
>
func_cur_ppem
(
exc
)
;
}
static
void
Ins_MPS
(
TT_ExecContext
exc
FT_Long
*
args
)
{
if
(
NO_SUBPIXEL_HINTING
)
{
args
[
0
]
=
exc
-
>
func_cur_ppem
(
exc
)
;
}
else
{
args
[
0
]
=
exc
-
>
pointSize
;
}
}
static
void
Ins_DUP
(
FT_Long
*
args
)
{
args
[
1
]
=
args
[
0
]
;
}
static
void
Ins_POP
(
void
)
{
}
static
void
Ins_CLEAR
(
TT_ExecContext
exc
)
{
exc
-
>
new_top
=
0
;
}
static
void
Ins_SWAP
(
FT_Long
*
args
)
{
FT_Long
L
;
L
=
args
[
0
]
;
args
[
0
]
=
args
[
1
]
;
args
[
1
]
=
L
;
}
static
void
Ins_DEPTH
(
TT_ExecContext
exc
FT_Long
*
args
)
{
args
[
0
]
=
exc
-
>
top
;
}
static
void
Ins_LT
(
FT_Long
*
args
)
{
args
[
0
]
=
(
args
[
0
]
<
args
[
1
]
)
;
}
static
void
Ins_LTEQ
(
FT_Long
*
args
)
{
args
[
0
]
=
(
args
[
0
]
<
=
args
[
1
]
)
;
}
static
void
Ins_GT
(
FT_Long
*
args
)
{
args
[
0
]
=
(
args
[
0
]
>
args
[
1
]
)
;
}
static
void
Ins_GTEQ
(
FT_Long
*
args
)
{
args
[
0
]
=
(
args
[
0
]
>
=
args
[
1
]
)
;
}
static
void
Ins_EQ
(
FT_Long
*
args
)
{
args
[
0
]
=
(
args
[
0
]
=
=
args
[
1
]
)
;
}
static
void
Ins_NEQ
(
FT_Long
*
args
)
{
args
[
0
]
=
(
args
[
0
]
!
=
args
[
1
]
)
;
}
static
void
Ins_ODD
(
TT_ExecContext
exc
FT_Long
*
args
)
{
args
[
0
]
=
(
(
exc
-
>
func_round
(
exc
args
[
0
]
0
)
&
127
)
=
=
64
)
;
}
static
void
Ins_EVEN
(
TT_ExecContext
exc
FT_Long
*
args
)
{
args
[
0
]
=
(
(
exc
-
>
func_round
(
exc
args
[
0
]
0
)
&
127
)
=
=
0
)
;
}
static
void
Ins_AND
(
FT_Long
*
args
)
{
args
[
0
]
=
(
args
[
0
]
&
&
args
[
1
]
)
;
}
static
void
Ins_OR
(
FT_Long
*
args
)
{
args
[
0
]
=
(
args
[
0
]
|
|
args
[
1
]
)
;
}
static
void
Ins_NOT
(
FT_Long
*
args
)
{
args
[
0
]
=
!
args
[
0
]
;
}
static
void
Ins_ADD
(
FT_Long
*
args
)
{
args
[
0
]
=
ADD_LONG
(
args
[
0
]
args
[
1
]
)
;
}
static
void
Ins_SUB
(
FT_Long
*
args
)
{
args
[
0
]
=
SUB_LONG
(
args
[
0
]
args
[
1
]
)
;
}
static
void
Ins_DIV
(
TT_ExecContext
exc
FT_Long
*
args
)
{
if
(
args
[
1
]
=
=
0
)
exc
-
>
error
=
FT_THROW
(
Divide_By_Zero
)
;
else
args
[
0
]
=
FT_MulDiv_No_Round
(
args
[
0
]
64L
args
[
1
]
)
;
}
static
void
Ins_MUL
(
FT_Long
*
args
)
{
args
[
0
]
=
FT_MulDiv
(
args
[
0
]
args
[
1
]
64L
)
;
}
static
void
Ins_ABS
(
FT_Long
*
args
)
{
if
(
args
[
0
]
<
0
)
args
[
0
]
=
NEG_LONG
(
args
[
0
]
)
;
}
static
void
Ins_NEG
(
FT_Long
*
args
)
{
args
[
0
]
=
NEG_LONG
(
args
[
0
]
)
;
}
static
void
Ins_FLOOR
(
FT_Long
*
args
)
{
args
[
0
]
=
FT_PIX_FLOOR
(
args
[
0
]
)
;
}
static
void
Ins_CEILING
(
FT_Long
*
args
)
{
args
[
0
]
=
FT_PIX_CEIL_LONG
(
args
[
0
]
)
;
}
static
void
Ins_RS
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
I
=
(
FT_ULong
)
args
[
0
]
;
if
(
BOUNDSL
(
I
exc
-
>
storeSize
)
)
{
if
(
exc
-
>
pedantic_hinting
)
ARRAY_BOUND_ERROR
;
else
args
[
0
]
=
0
;
}
else
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
(
(
I
=
=
24
&
&
(
exc
-
>
face
-
>
sph_found_func_flags
&
(
SPH_FDEF_SPACING_1
|
SPH_FDEF_SPACING_2
)
)
)
|
|
(
I
=
=
22
&
&
(
exc
-
>
sph_in_func_flags
&
SPH_FDEF_TYPEMAN_STROKES
)
)
|
|
(
I
=
=
8
&
&
(
exc
-
>
face
-
>
sph_found_func_flags
&
SPH_FDEF_VACUFORM_ROUND_1
)
&
&
exc
-
>
iup_called
)
)
)
args
[
0
]
=
0
;
else
#
endif
args
[
0
]
=
exc
-
>
storage
[
I
]
;
}
}
static
void
Ins_WS
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
I
=
(
FT_ULong
)
args
[
0
]
;
if
(
BOUNDSL
(
I
exc
-
>
storeSize
)
)
{
if
(
exc
-
>
pedantic_hinting
)
ARRAY_BOUND_ERROR
;
}
else
exc
-
>
storage
[
I
]
=
args
[
1
]
;
}
static
void
Ins_WCVTP
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
I
=
(
FT_ULong
)
args
[
0
]
;
if
(
BOUNDSL
(
I
exc
-
>
cvtSize
)
)
{
if
(
exc
-
>
pedantic_hinting
)
ARRAY_BOUND_ERROR
;
}
else
exc
-
>
func_write_cvt
(
exc
I
args
[
1
]
)
;
}
static
void
Ins_WCVTF
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
I
=
(
FT_ULong
)
args
[
0
]
;
if
(
BOUNDSL
(
I
exc
-
>
cvtSize
)
)
{
if
(
exc
-
>
pedantic_hinting
)
ARRAY_BOUND_ERROR
;
}
else
exc
-
>
cvt
[
I
]
=
FT_MulFix
(
args
[
1
]
exc
-
>
tt_metrics
.
scale
)
;
}
static
void
Ins_RCVT
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
I
=
(
FT_ULong
)
args
[
0
]
;
if
(
BOUNDSL
(
I
exc
-
>
cvtSize
)
)
{
if
(
exc
-
>
pedantic_hinting
)
ARRAY_BOUND_ERROR
;
else
args
[
0
]
=
0
;
}
else
args
[
0
]
=
exc
-
>
func_read_cvt
(
exc
I
)
;
}
static
void
Ins_AA
(
void
)
{
}
static
void
Ins_DEBUG
(
TT_ExecContext
exc
)
{
exc
-
>
error
=
FT_THROW
(
Debug_OpCode
)
;
}
static
void
Ins_ROUND
(
TT_ExecContext
exc
FT_Long
*
args
)
{
args
[
0
]
=
exc
-
>
func_round
(
exc
args
[
0
]
exc
-
>
tt_metrics
.
compensations
[
exc
-
>
opcode
-
0x68
]
)
;
}
static
void
Ins_NROUND
(
TT_ExecContext
exc
FT_Long
*
args
)
{
args
[
0
]
=
Round_None
(
exc
args
[
0
]
exc
-
>
tt_metrics
.
compensations
[
exc
-
>
opcode
-
0x6C
]
)
;
}
static
void
Ins_MAX
(
FT_Long
*
args
)
{
if
(
args
[
1
]
>
args
[
0
]
)
args
[
0
]
=
args
[
1
]
;
}
static
void
Ins_MIN
(
FT_Long
*
args
)
{
if
(
args
[
1
]
<
args
[
0
]
)
args
[
0
]
=
args
[
1
]
;
}
static
void
Ins_MINDEX
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_Long
L
K
;
L
=
args
[
0
]
;
if
(
L
<
=
0
|
|
L
>
exc
-
>
args
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
}
else
{
K
=
exc
-
>
stack
[
exc
-
>
args
-
L
]
;
FT_ARRAY_MOVE
(
&
exc
-
>
stack
[
exc
-
>
args
-
L
]
&
exc
-
>
stack
[
exc
-
>
args
-
L
+
1
]
(
L
-
1
)
)
;
exc
-
>
stack
[
exc
-
>
args
-
1
]
=
K
;
}
}
static
void
Ins_CINDEX
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_Long
L
;
L
=
args
[
0
]
;
if
(
L
<
=
0
|
|
L
>
exc
-
>
args
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
args
[
0
]
=
0
;
}
else
args
[
0
]
=
exc
-
>
stack
[
exc
-
>
args
-
L
]
;
}
static
void
Ins_ROLL
(
FT_Long
*
args
)
{
FT_Long
A
B
C
;
A
=
args
[
2
]
;
B
=
args
[
1
]
;
C
=
args
[
0
]
;
args
[
2
]
=
C
;
args
[
1
]
=
A
;
args
[
0
]
=
B
;
}
static
void
Ins_SLOOP
(
TT_ExecContext
exc
FT_Long
*
args
)
{
if
(
args
[
0
]
<
0
)
exc
-
>
error
=
FT_THROW
(
Bad_Argument
)
;
else
{
exc
-
>
GS
.
loop
=
args
[
0
]
>
0xFFFFL
?
0xFFFFL
:
args
[
0
]
;
}
}
static
FT_Bool
SkipCode
(
TT_ExecContext
exc
)
{
exc
-
>
IP
+
=
exc
-
>
length
;
if
(
exc
-
>
IP
<
exc
-
>
codeSize
)
{
exc
-
>
opcode
=
exc
-
>
code
[
exc
-
>
IP
]
;
exc
-
>
length
=
opcode_length
[
exc
-
>
opcode
]
;
if
(
exc
-
>
length
<
0
)
{
if
(
exc
-
>
IP
+
1
>
=
exc
-
>
codeSize
)
goto
Fail_Overflow
;
exc
-
>
length
=
2
-
exc
-
>
length
*
exc
-
>
code
[
exc
-
>
IP
+
1
]
;
}
if
(
exc
-
>
IP
+
exc
-
>
length
<
=
exc
-
>
codeSize
)
return
SUCCESS
;
}
Fail_Overflow
:
exc
-
>
error
=
FT_THROW
(
Code_Overflow
)
;
return
FAILURE
;
}
static
void
Ins_IF
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_Int
nIfs
;
FT_Bool
Out
;
if
(
args
[
0
]
!
=
0
)
return
;
nIfs
=
1
;
Out
=
0
;
do
{
if
(
SkipCode
(
exc
)
=
=
FAILURE
)
return
;
switch
(
exc
-
>
opcode
)
{
case
0x58
:
nIfs
+
+
;
break
;
case
0x1B
:
Out
=
FT_BOOL
(
nIfs
=
=
1
)
;
break
;
case
0x59
:
nIfs
-
-
;
Out
=
FT_BOOL
(
nIfs
=
=
0
)
;
break
;
}
}
while
(
Out
=
=
0
)
;
}
static
void
Ins_ELSE
(
TT_ExecContext
exc
)
{
FT_Int
nIfs
;
nIfs
=
1
;
do
{
if
(
SkipCode
(
exc
)
=
=
FAILURE
)
return
;
switch
(
exc
-
>
opcode
)
{
case
0x58
:
nIfs
+
+
;
break
;
case
0x59
:
nIfs
-
-
;
break
;
}
}
while
(
nIfs
!
=
0
)
;
}
static
void
Ins_EIF
(
void
)
{
}
static
void
Ins_JMPR
(
TT_ExecContext
exc
FT_Long
*
args
)
{
if
(
args
[
0
]
=
=
0
&
&
exc
-
>
args
=
=
0
)
{
exc
-
>
error
=
FT_THROW
(
Bad_Argument
)
;
return
;
}
exc
-
>
IP
+
=
args
[
0
]
;
if
(
exc
-
>
IP
<
0
|
|
(
exc
-
>
callTop
>
0
&
&
exc
-
>
IP
>
exc
-
>
callStack
[
exc
-
>
callTop
-
1
]
.
Def
-
>
end
)
)
{
exc
-
>
error
=
FT_THROW
(
Bad_Argument
)
;
return
;
}
exc
-
>
step_ins
=
FALSE
;
if
(
args
[
0
]
<
0
)
{
if
(
+
+
exc
-
>
neg_jump_counter
>
exc
-
>
neg_jump_counter_max
)
exc
-
>
error
=
FT_THROW
(
Execution_Too_Long
)
;
}
}
static
void
Ins_JROT
(
TT_ExecContext
exc
FT_Long
*
args
)
{
if
(
args
[
1
]
!
=
0
)
Ins_JMPR
(
exc
args
)
;
}
static
void
Ins_JROF
(
TT_ExecContext
exc
FT_Long
*
args
)
{
if
(
args
[
1
]
=
=
0
)
Ins_JMPR
(
exc
args
)
;
}
static
void
Ins_FDEF
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
n
;
TT_DefRecord
*
rec
;
TT_DefRecord
*
limit
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
FT_Byte
opcode_pattern
[
9
]
[
12
]
=
{
{
0x4B
0x53
0x23
0x4B
0x51
0x5A
0x58
0x38
0x1B
0x21
0x21
0x59
}
{
0x4B
0x54
0x58
0x38
0x1B
0x21
0x21
0x59
}
{
0x20
0x20
0xB0
0x60
0x46
0xB0
0x23
0x42
}
{
0x45
0x23
0x46
0x60
0x20
0xB0
}
{
0x20
0x64
0xB0
0x60
0x66
0x23
0xB0
}
{
0x01
0xB0
0x43
0x58
}
{
0x01
0x18
0xB0
0x43
0x58
}
{
0x01
0x20
0xB0
0x25
}
{
0x06
0x7D
}
}
;
FT_UShort
opcode_patterns
=
9
;
FT_UShort
opcode_pointer
[
9
]
=
{
0
0
0
0
0
0
0
0
0
}
;
FT_UShort
opcode_size
[
9
]
=
{
12
8
8
6
7
4
5
4
2
}
;
FT_UShort
i
;
#
endif
if
(
exc
-
>
curRange
=
=
tt_coderange_glyph
)
{
exc
-
>
error
=
FT_THROW
(
DEF_In_Glyf_Bytecode
)
;
return
;
}
rec
=
exc
-
>
FDefs
;
limit
=
rec
+
exc
-
>
numFDefs
;
n
=
(
FT_ULong
)
args
[
0
]
;
for
(
;
rec
<
limit
;
rec
+
+
)
{
if
(
rec
-
>
opc
=
=
n
)
break
;
}
if
(
rec
=
=
limit
)
{
if
(
exc
-
>
numFDefs
>
=
exc
-
>
maxFDefs
)
{
exc
-
>
error
=
FT_THROW
(
Too_Many_Function_Defs
)
;
return
;
}
exc
-
>
numFDefs
+
+
;
}
if
(
n
>
0xFFFFU
)
{
exc
-
>
error
=
FT_THROW
(
Too_Many_Function_Defs
)
;
return
;
}
rec
-
>
range
=
exc
-
>
curRange
;
rec
-
>
opc
=
(
FT_UInt16
)
n
;
rec
-
>
start
=
exc
-
>
IP
+
1
;
rec
-
>
active
=
TRUE
;
rec
-
>
inline_delta
=
FALSE
;
rec
-
>
sph_fdef_flags
=
0x0000
;
if
(
n
>
exc
-
>
maxFunc
)
exc
-
>
maxFunc
=
(
FT_UInt16
)
n
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
n
>
=
64
&
&
n
<
=
66
)
rec
-
>
sph_fdef_flags
|
=
SPH_FDEF_TYPEMAN_STROKES
;
#
endif
while
(
SkipCode
(
exc
)
=
=
SUCCESS
)
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
)
{
for
(
i
=
0
;
i
<
opcode_patterns
;
i
+
+
)
{
if
(
opcode_pointer
[
i
]
<
opcode_size
[
i
]
&
&
exc
-
>
opcode
=
=
opcode_pattern
[
i
]
[
opcode_pointer
[
i
]
]
)
{
opcode_pointer
[
i
]
+
=
1
;
if
(
opcode_pointer
[
i
]
=
=
opcode_size
[
i
]
)
{
FT_TRACE6
(
(
"
sph
:
Function
%
d
opcode
ptrn
:
%
d
%
s
%
s
\
n
"
i
n
exc
-
>
face
-
>
root
.
family_name
exc
-
>
face
-
>
root
.
style_name
)
)
;
switch
(
i
)
{
case
0
:
rec
-
>
sph_fdef_flags
|
=
SPH_FDEF_INLINE_DELTA_1
;
exc
-
>
face
-
>
sph_found_func_flags
|
=
SPH_FDEF_INLINE_DELTA_1
;
break
;
case
1
:
rec
-
>
sph_fdef_flags
|
=
SPH_FDEF_INLINE_DELTA_2
;
exc
-
>
face
-
>
sph_found_func_flags
|
=
SPH_FDEF_INLINE_DELTA_2
;
break
;
case
2
:
switch
(
n
)
{
case
58
:
rec
-
>
sph_fdef_flags
|
=
SPH_FDEF_DIAGONAL_STROKE
;
exc
-
>
face
-
>
sph_found_func_flags
|
=
SPH_FDEF_DIAGONAL_STROKE
;
}
break
;
case
3
:
switch
(
n
)
{
case
0
:
rec
-
>
sph_fdef_flags
|
=
SPH_FDEF_VACUFORM_ROUND_1
;
exc
-
>
face
-
>
sph_found_func_flags
|
=
SPH_FDEF_VACUFORM_ROUND_1
;
}
break
;
case
4
:
rec
-
>
sph_fdef_flags
|
=
SPH_FDEF_TTFAUTOHINT_1
;
exc
-
>
face
-
>
sph_found_func_flags
|
=
SPH_FDEF_TTFAUTOHINT_1
;
break
;
case
5
:
switch
(
n
)
{
case
0
:
case
1
:
case
2
:
case
4
:
case
7
:
case
8
:
rec
-
>
sph_fdef_flags
|
=
SPH_FDEF_SPACING_1
;
exc
-
>
face
-
>
sph_found_func_flags
|
=
SPH_FDEF_SPACING_1
;
}
break
;
case
6
:
switch
(
n
)
{
case
0
:
case
1
:
case
2
:
case
4
:
case
7
:
case
8
:
rec
-
>
sph_fdef_flags
|
=
SPH_FDEF_SPACING_2
;
exc
-
>
face
-
>
sph_found_func_flags
|
=
SPH_FDEF_SPACING_2
;
}
break
;
case
7
:
rec
-
>
sph_fdef_flags
|
=
SPH_FDEF_TYPEMAN_DIAGENDCTRL
;
exc
-
>
face
-
>
sph_found_func_flags
|
=
SPH_FDEF_TYPEMAN_DIAGENDCTRL
;
break
;
case
8
:
#
if
0
rec
-
>
sph_fdef_flags
|
=
SPH_FDEF_TYPEMAN_DIAGENDCTRL
;
exc
-
>
face
-
>
sph_found_func_flags
|
=
SPH_FDEF_TYPEMAN_DIAGENDCTRL
;
#
endif
break
;
}
opcode_pointer
[
i
]
=
0
;
}
}
else
opcode_pointer
[
i
]
=
0
;
}
exc
-
>
face
-
>
sph_compatibility_mode
=
(
(
exc
-
>
face
-
>
sph_found_func_flags
&
SPH_FDEF_INLINE_DELTA_1
)
|
(
exc
-
>
face
-
>
sph_found_func_flags
&
SPH_FDEF_INLINE_DELTA_2
)
)
;
}
#
endif
switch
(
exc
-
>
opcode
)
{
case
0x89
:
case
0x2C
:
exc
-
>
error
=
FT_THROW
(
Nested_DEFS
)
;
return
;
case
0x2D
:
rec
-
>
end
=
exc
-
>
IP
;
return
;
}
}
}
static
void
Ins_ENDF
(
TT_ExecContext
exc
)
{
TT_CallRec
*
pRec
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
exc
-
>
sph_in_func_flags
=
0x0000
;
#
endif
if
(
exc
-
>
callTop
<
=
0
)
{
exc
-
>
error
=
FT_THROW
(
ENDF_In_Exec_Stream
)
;
return
;
}
exc
-
>
callTop
-
-
;
pRec
=
&
exc
-
>
callStack
[
exc
-
>
callTop
]
;
pRec
-
>
Cur_Count
-
-
;
exc
-
>
step_ins
=
FALSE
;
if
(
pRec
-
>
Cur_Count
>
0
)
{
exc
-
>
callTop
+
+
;
exc
-
>
IP
=
pRec
-
>
Def
-
>
start
;
}
else
Ins_Goto_CodeRange
(
exc
pRec
-
>
Caller_Range
pRec
-
>
Caller_IP
)
;
}
static
void
Ins_CALL
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
F
;
TT_CallRec
*
pCrec
;
TT_DefRecord
*
def
;
F
=
(
FT_ULong
)
args
[
0
]
;
if
(
BOUNDSL
(
F
exc
-
>
maxFunc
+
1
)
)
goto
Fail
;
def
=
exc
-
>
FDefs
+
F
;
if
(
exc
-
>
maxFunc
+
1
!
=
exc
-
>
numFDefs
|
|
def
-
>
opc
!
=
F
)
{
TT_DefRecord
*
limit
;
def
=
exc
-
>
FDefs
;
limit
=
def
+
exc
-
>
numFDefs
;
while
(
def
<
limit
&
&
def
-
>
opc
!
=
F
)
def
+
+
;
if
(
def
=
=
limit
)
goto
Fail
;
}
if
(
!
def
-
>
active
)
goto
Fail
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
(
(
exc
-
>
iup_called
&
&
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_NO_CALL_AFTER_IUP
)
)
|
|
(
def
-
>
sph_fdef_flags
&
SPH_FDEF_VACUFORM_ROUND_1
)
)
)
goto
Fail
;
else
exc
-
>
sph_in_func_flags
=
def
-
>
sph_fdef_flags
;
#
endif
if
(
exc
-
>
callTop
>
=
exc
-
>
callSize
)
{
exc
-
>
error
=
FT_THROW
(
Stack_Overflow
)
;
return
;
}
pCrec
=
exc
-
>
callStack
+
exc
-
>
callTop
;
pCrec
-
>
Caller_Range
=
exc
-
>
curRange
;
pCrec
-
>
Caller_IP
=
exc
-
>
IP
+
1
;
pCrec
-
>
Cur_Count
=
1
;
pCrec
-
>
Def
=
def
;
exc
-
>
callTop
+
+
;
Ins_Goto_CodeRange
(
exc
def
-
>
range
def
-
>
start
)
;
exc
-
>
step_ins
=
FALSE
;
return
;
Fail
:
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
}
static
void
Ins_LOOPCALL
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
F
;
TT_CallRec
*
pCrec
;
TT_DefRecord
*
def
;
F
=
(
FT_ULong
)
args
[
1
]
;
if
(
BOUNDSL
(
F
exc
-
>
maxFunc
+
1
)
)
goto
Fail
;
def
=
exc
-
>
FDefs
+
F
;
if
(
exc
-
>
maxFunc
+
1
!
=
exc
-
>
numFDefs
|
|
def
-
>
opc
!
=
F
)
{
TT_DefRecord
*
limit
;
def
=
exc
-
>
FDefs
;
limit
=
def
+
exc
-
>
numFDefs
;
while
(
def
<
limit
&
&
def
-
>
opc
!
=
F
)
def
+
+
;
if
(
def
=
=
limit
)
goto
Fail
;
}
if
(
!
def
-
>
active
)
goto
Fail
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
(
def
-
>
sph_fdef_flags
&
SPH_FDEF_VACUFORM_ROUND_1
)
)
goto
Fail
;
else
exc
-
>
sph_in_func_flags
=
def
-
>
sph_fdef_flags
;
#
endif
if
(
exc
-
>
callTop
>
=
exc
-
>
callSize
)
{
exc
-
>
error
=
FT_THROW
(
Stack_Overflow
)
;
return
;
}
if
(
args
[
0
]
>
0
)
{
pCrec
=
exc
-
>
callStack
+
exc
-
>
callTop
;
pCrec
-
>
Caller_Range
=
exc
-
>
curRange
;
pCrec
-
>
Caller_IP
=
exc
-
>
IP
+
1
;
pCrec
-
>
Cur_Count
=
(
FT_Int
)
args
[
0
]
;
pCrec
-
>
Def
=
def
;
exc
-
>
callTop
+
+
;
Ins_Goto_CodeRange
(
exc
def
-
>
range
def
-
>
start
)
;
exc
-
>
step_ins
=
FALSE
;
exc
-
>
loopcall_counter
+
=
(
FT_ULong
)
args
[
0
]
;
if
(
exc
-
>
loopcall_counter
>
exc
-
>
loopcall_counter_max
)
exc
-
>
error
=
FT_THROW
(
Execution_Too_Long
)
;
}
return
;
Fail
:
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
}
static
void
Ins_IDEF
(
TT_ExecContext
exc
FT_Long
*
args
)
{
TT_DefRecord
*
def
;
TT_DefRecord
*
limit
;
if
(
exc
-
>
curRange
=
=
tt_coderange_glyph
)
{
exc
-
>
error
=
FT_THROW
(
DEF_In_Glyf_Bytecode
)
;
return
;
}
def
=
exc
-
>
IDefs
;
limit
=
def
+
exc
-
>
numIDefs
;
for
(
;
def
<
limit
;
def
+
+
)
if
(
def
-
>
opc
=
=
(
FT_ULong
)
args
[
0
]
)
break
;
if
(
def
=
=
limit
)
{
if
(
exc
-
>
numIDefs
>
=
exc
-
>
maxIDefs
)
{
exc
-
>
error
=
FT_THROW
(
Too_Many_Instruction_Defs
)
;
return
;
}
exc
-
>
numIDefs
+
+
;
}
if
(
0
>
args
[
0
]
|
|
args
[
0
]
>
0x00FF
)
{
exc
-
>
error
=
FT_THROW
(
Too_Many_Instruction_Defs
)
;
return
;
}
def
-
>
opc
=
(
FT_Byte
)
args
[
0
]
;
def
-
>
start
=
exc
-
>
IP
+
1
;
def
-
>
range
=
exc
-
>
curRange
;
def
-
>
active
=
TRUE
;
if
(
(
FT_ULong
)
args
[
0
]
>
exc
-
>
maxIns
)
exc
-
>
maxIns
=
(
FT_Byte
)
args
[
0
]
;
while
(
SkipCode
(
exc
)
=
=
SUCCESS
)
{
switch
(
exc
-
>
opcode
)
{
case
0x89
:
case
0x2C
:
exc
-
>
error
=
FT_THROW
(
Nested_DEFS
)
;
return
;
case
0x2D
:
def
-
>
end
=
exc
-
>
IP
;
return
;
}
}
}
static
void
Ins_NPUSHB
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
L
K
;
L
=
(
FT_UShort
)
exc
-
>
code
[
exc
-
>
IP
+
1
]
;
if
(
BOUNDS
(
L
exc
-
>
stackSize
+
1
-
exc
-
>
top
)
)
{
exc
-
>
error
=
FT_THROW
(
Stack_Overflow
)
;
return
;
}
for
(
K
=
1
;
K
<
=
L
;
K
+
+
)
args
[
K
-
1
]
=
exc
-
>
code
[
exc
-
>
IP
+
K
+
1
]
;
exc
-
>
new_top
+
=
L
;
}
static
void
Ins_NPUSHW
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
L
K
;
L
=
(
FT_UShort
)
exc
-
>
code
[
exc
-
>
IP
+
1
]
;
if
(
BOUNDS
(
L
exc
-
>
stackSize
+
1
-
exc
-
>
top
)
)
{
exc
-
>
error
=
FT_THROW
(
Stack_Overflow
)
;
return
;
}
exc
-
>
IP
+
=
2
;
for
(
K
=
0
;
K
<
L
;
K
+
+
)
args
[
K
]
=
GetShortIns
(
exc
)
;
exc
-
>
step_ins
=
FALSE
;
exc
-
>
new_top
+
=
L
;
}
static
void
Ins_PUSHB
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
L
K
;
L
=
(
FT_UShort
)
(
exc
-
>
opcode
-
0xB0
+
1
)
;
if
(
BOUNDS
(
L
exc
-
>
stackSize
+
1
-
exc
-
>
top
)
)
{
exc
-
>
error
=
FT_THROW
(
Stack_Overflow
)
;
return
;
}
for
(
K
=
1
;
K
<
=
L
;
K
+
+
)
args
[
K
-
1
]
=
exc
-
>
code
[
exc
-
>
IP
+
K
]
;
}
static
void
Ins_PUSHW
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
L
K
;
L
=
(
FT_UShort
)
(
exc
-
>
opcode
-
0xB8
+
1
)
;
if
(
BOUNDS
(
L
exc
-
>
stackSize
+
1
-
exc
-
>
top
)
)
{
exc
-
>
error
=
FT_THROW
(
Stack_Overflow
)
;
return
;
}
exc
-
>
IP
+
+
;
for
(
K
=
0
;
K
<
L
;
K
+
+
)
args
[
K
]
=
GetShortIns
(
exc
)
;
exc
-
>
step_ins
=
FALSE
;
}
static
FT_Bool
Ins_SxVTL
(
TT_ExecContext
exc
FT_UShort
aIdx1
FT_UShort
aIdx2
FT_UnitVector
*
Vec
)
{
FT_Long
A
B
C
;
FT_Vector
*
p1
;
FT_Vector
*
p2
;
FT_Byte
opcode
=
exc
-
>
opcode
;
if
(
BOUNDS
(
aIdx1
exc
-
>
zp2
.
n_points
)
|
|
BOUNDS
(
aIdx2
exc
-
>
zp1
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
FAILURE
;
}
p1
=
exc
-
>
zp1
.
cur
+
aIdx2
;
p2
=
exc
-
>
zp2
.
cur
+
aIdx1
;
A
=
SUB_LONG
(
p1
-
>
x
p2
-
>
x
)
;
B
=
SUB_LONG
(
p1
-
>
y
p2
-
>
y
)
;
if
(
A
=
=
0
&
&
B
=
=
0
)
{
A
=
0x4000
;
opcode
=
0
;
}
if
(
(
opcode
&
1
)
!
=
0
)
{
C
=
B
;
B
=
A
;
A
=
NEG_LONG
(
C
)
;
}
Normalize
(
A
B
Vec
)
;
return
SUCCESS
;
}
static
void
Ins_SxyTCA
(
TT_ExecContext
exc
)
{
FT_Short
AA
BB
;
FT_Byte
opcode
=
exc
-
>
opcode
;
AA
=
(
FT_Short
)
(
(
opcode
&
1
)
<
<
14
)
;
BB
=
(
FT_Short
)
(
AA
^
0x4000
)
;
if
(
opcode
<
4
)
{
exc
-
>
GS
.
projVector
.
x
=
AA
;
exc
-
>
GS
.
projVector
.
y
=
BB
;
exc
-
>
GS
.
dualVector
.
x
=
AA
;
exc
-
>
GS
.
dualVector
.
y
=
BB
;
}
if
(
(
opcode
&
2
)
=
=
0
)
{
exc
-
>
GS
.
freeVector
.
x
=
AA
;
exc
-
>
GS
.
freeVector
.
y
=
BB
;
}
Compute_Funcs
(
exc
)
;
}
static
void
Ins_SPVTL
(
TT_ExecContext
exc
FT_Long
*
args
)
{
if
(
Ins_SxVTL
(
exc
(
FT_UShort
)
args
[
1
]
(
FT_UShort
)
args
[
0
]
&
exc
-
>
GS
.
projVector
)
=
=
SUCCESS
)
{
exc
-
>
GS
.
dualVector
=
exc
-
>
GS
.
projVector
;
Compute_Funcs
(
exc
)
;
}
}
static
void
Ins_SFVTL
(
TT_ExecContext
exc
FT_Long
*
args
)
{
if
(
Ins_SxVTL
(
exc
(
FT_UShort
)
args
[
1
]
(
FT_UShort
)
args
[
0
]
&
exc
-
>
GS
.
freeVector
)
=
=
SUCCESS
)
{
Compute_Funcs
(
exc
)
;
}
}
static
void
Ins_SFVTPV
(
TT_ExecContext
exc
)
{
exc
-
>
GS
.
freeVector
=
exc
-
>
GS
.
projVector
;
Compute_Funcs
(
exc
)
;
}
static
void
Ins_SPVFS
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_Short
S
;
FT_Long
X
Y
;
S
=
(
FT_Short
)
args
[
1
]
;
Y
=
(
FT_Long
)
S
;
S
=
(
FT_Short
)
args
[
0
]
;
X
=
(
FT_Long
)
S
;
Normalize
(
X
Y
&
exc
-
>
GS
.
projVector
)
;
exc
-
>
GS
.
dualVector
=
exc
-
>
GS
.
projVector
;
Compute_Funcs
(
exc
)
;
}
static
void
Ins_SFVFS
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_Short
S
;
FT_Long
X
Y
;
S
=
(
FT_Short
)
args
[
1
]
;
Y
=
(
FT_Long
)
S
;
S
=
(
FT_Short
)
args
[
0
]
;
X
=
S
;
Normalize
(
X
Y
&
exc
-
>
GS
.
freeVector
)
;
Compute_Funcs
(
exc
)
;
}
static
void
Ins_GPV
(
TT_ExecContext
exc
FT_Long
*
args
)
{
args
[
0
]
=
exc
-
>
GS
.
projVector
.
x
;
args
[
1
]
=
exc
-
>
GS
.
projVector
.
y
;
}
static
void
Ins_GFV
(
TT_ExecContext
exc
FT_Long
*
args
)
{
args
[
0
]
=
exc
-
>
GS
.
freeVector
.
x
;
args
[
1
]
=
exc
-
>
GS
.
freeVector
.
y
;
}
static
void
Ins_SRP0
(
TT_ExecContext
exc
FT_Long
*
args
)
{
exc
-
>
GS
.
rp0
=
(
FT_UShort
)
args
[
0
]
;
}
static
void
Ins_SRP1
(
TT_ExecContext
exc
FT_Long
*
args
)
{
exc
-
>
GS
.
rp1
=
(
FT_UShort
)
args
[
0
]
;
}
static
void
Ins_SRP2
(
TT_ExecContext
exc
FT_Long
*
args
)
{
exc
-
>
GS
.
rp2
=
(
FT_UShort
)
args
[
0
]
;
}
static
void
Ins_SMD
(
TT_ExecContext
exc
FT_Long
*
args
)
{
exc
-
>
GS
.
minimum_distance
=
args
[
0
]
;
}
static
void
Ins_SCVTCI
(
TT_ExecContext
exc
FT_Long
*
args
)
{
exc
-
>
GS
.
control_value_cutin
=
(
FT_F26Dot6
)
args
[
0
]
;
}
static
void
Ins_SSWCI
(
TT_ExecContext
exc
FT_Long
*
args
)
{
exc
-
>
GS
.
single_width_cutin
=
(
FT_F26Dot6
)
args
[
0
]
;
}
static
void
Ins_SSW
(
TT_ExecContext
exc
FT_Long
*
args
)
{
exc
-
>
GS
.
single_width_value
=
FT_MulFix
(
args
[
0
]
exc
-
>
tt_metrics
.
scale
)
;
}
static
void
Ins_FLIPON
(
TT_ExecContext
exc
)
{
exc
-
>
GS
.
auto_flip
=
TRUE
;
}
static
void
Ins_FLIPOFF
(
TT_ExecContext
exc
)
{
exc
-
>
GS
.
auto_flip
=
FALSE
;
}
static
void
Ins_SANGW
(
void
)
{
}
static
void
Ins_SDB
(
TT_ExecContext
exc
FT_Long
*
args
)
{
exc
-
>
GS
.
delta_base
=
(
FT_UShort
)
args
[
0
]
;
}
static
void
Ins_SDS
(
TT_ExecContext
exc
FT_Long
*
args
)
{
if
(
(
FT_ULong
)
args
[
0
]
>
6UL
)
exc
-
>
error
=
FT_THROW
(
Bad_Argument
)
;
else
exc
-
>
GS
.
delta_shift
=
(
FT_UShort
)
args
[
0
]
;
}
static
void
Ins_RTHG
(
TT_ExecContext
exc
)
{
exc
-
>
GS
.
round_state
=
TT_Round_To_Half_Grid
;
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_To_Half_Grid
;
}
static
void
Ins_RTG
(
TT_ExecContext
exc
)
{
exc
-
>
GS
.
round_state
=
TT_Round_To_Grid
;
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_To_Grid
;
}
static
void
Ins_RTDG
(
TT_ExecContext
exc
)
{
exc
-
>
GS
.
round_state
=
TT_Round_To_Double_Grid
;
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_To_Double_Grid
;
}
static
void
Ins_RUTG
(
TT_ExecContext
exc
)
{
exc
-
>
GS
.
round_state
=
TT_Round_Up_To_Grid
;
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_Up_To_Grid
;
}
static
void
Ins_RDTG
(
TT_ExecContext
exc
)
{
exc
-
>
GS
.
round_state
=
TT_Round_Down_To_Grid
;
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_Down_To_Grid
;
}
static
void
Ins_ROFF
(
TT_ExecContext
exc
)
{
exc
-
>
GS
.
round_state
=
TT_Round_Off
;
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_None
;
}
static
void
Ins_SROUND
(
TT_ExecContext
exc
FT_Long
*
args
)
{
SetSuperRound
(
exc
0x4000
args
[
0
]
)
;
exc
-
>
GS
.
round_state
=
TT_Round_Super
;
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_Super
;
}
static
void
Ins_S45ROUND
(
TT_ExecContext
exc
FT_Long
*
args
)
{
SetSuperRound
(
exc
0x2D41
args
[
0
]
)
;
exc
-
>
GS
.
round_state
=
TT_Round_Super_45
;
exc
-
>
func_round
=
(
TT_Round_Func
)
Round_Super_45
;
}
static
void
Ins_GC
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
L
;
FT_F26Dot6
R
;
L
=
(
FT_ULong
)
args
[
0
]
;
if
(
BOUNDSL
(
L
exc
-
>
zp2
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
R
=
0
;
}
else
{
if
(
exc
-
>
opcode
&
1
)
R
=
FAST_DUALPROJ
(
&
exc
-
>
zp2
.
org
[
L
]
)
;
else
R
=
FAST_PROJECT
(
&
exc
-
>
zp2
.
cur
[
L
]
)
;
}
args
[
0
]
=
R
;
}
static
void
Ins_SCFS
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_Long
K
;
FT_UShort
L
;
L
=
(
FT_UShort
)
args
[
0
]
;
if
(
BOUNDS
(
L
exc
-
>
zp2
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
K
=
FAST_PROJECT
(
&
exc
-
>
zp2
.
cur
[
L
]
)
;
exc
-
>
func_move
(
exc
&
exc
-
>
zp2
L
SUB_LONG
(
args
[
1
]
K
)
)
;
if
(
exc
-
>
GS
.
gep2
=
=
0
)
exc
-
>
zp2
.
org
[
L
]
=
exc
-
>
zp2
.
cur
[
L
]
;
}
static
void
Ins_MD
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
K
L
;
FT_F26Dot6
D
;
K
=
(
FT_UShort
)
args
[
1
]
;
L
=
(
FT_UShort
)
args
[
0
]
;
if
(
BOUNDS
(
L
exc
-
>
zp0
.
n_points
)
|
|
BOUNDS
(
K
exc
-
>
zp1
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
D
=
0
;
}
else
{
if
(
exc
-
>
opcode
&
1
)
D
=
PROJECT
(
exc
-
>
zp0
.
cur
+
L
exc
-
>
zp1
.
cur
+
K
)
;
else
{
if
(
exc
-
>
GS
.
gep0
=
=
0
|
|
exc
-
>
GS
.
gep1
=
=
0
)
{
FT_Vector
*
vec1
=
exc
-
>
zp0
.
org
+
L
;
FT_Vector
*
vec2
=
exc
-
>
zp1
.
org
+
K
;
D
=
DUALPROJ
(
vec1
vec2
)
;
}
else
{
FT_Vector
*
vec1
=
exc
-
>
zp0
.
orus
+
L
;
FT_Vector
*
vec2
=
exc
-
>
zp1
.
orus
+
K
;
if
(
exc
-
>
metrics
.
x_scale
=
=
exc
-
>
metrics
.
y_scale
)
{
D
=
DUALPROJ
(
vec1
vec2
)
;
D
=
FT_MulFix
(
D
exc
-
>
metrics
.
x_scale
)
;
}
else
{
FT_Vector
vec
;
vec
.
x
=
FT_MulFix
(
vec1
-
>
x
-
vec2
-
>
x
exc
-
>
metrics
.
x_scale
)
;
vec
.
y
=
FT_MulFix
(
vec1
-
>
y
-
vec2
-
>
y
exc
-
>
metrics
.
y_scale
)
;
D
=
FAST_DUALPROJ
(
&
vec
)
;
}
}
}
}
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
FT_ABS
(
D
)
=
=
64
)
D
+
=
1
;
#
endif
args
[
0
]
=
D
;
}
static
void
Ins_SDPVTL
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_Long
A
B
C
;
FT_UShort
p1
p2
;
FT_Byte
opcode
=
exc
-
>
opcode
;
p1
=
(
FT_UShort
)
args
[
1
]
;
p2
=
(
FT_UShort
)
args
[
0
]
;
if
(
BOUNDS
(
p2
exc
-
>
zp1
.
n_points
)
|
|
BOUNDS
(
p1
exc
-
>
zp2
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
{
FT_Vector
*
v1
=
exc
-
>
zp1
.
org
+
p2
;
FT_Vector
*
v2
=
exc
-
>
zp2
.
org
+
p1
;
A
=
SUB_LONG
(
v1
-
>
x
v2
-
>
x
)
;
B
=
SUB_LONG
(
v1
-
>
y
v2
-
>
y
)
;
if
(
A
=
=
0
&
&
B
=
=
0
)
{
A
=
0x4000
;
opcode
=
0
;
}
}
if
(
(
opcode
&
1
)
!
=
0
)
{
C
=
B
;
B
=
A
;
A
=
NEG_LONG
(
C
)
;
}
Normalize
(
A
B
&
exc
-
>
GS
.
dualVector
)
;
{
FT_Vector
*
v1
=
exc
-
>
zp1
.
cur
+
p2
;
FT_Vector
*
v2
=
exc
-
>
zp2
.
cur
+
p1
;
A
=
SUB_LONG
(
v1
-
>
x
v2
-
>
x
)
;
B
=
SUB_LONG
(
v1
-
>
y
v2
-
>
y
)
;
if
(
A
=
=
0
&
&
B
=
=
0
)
{
A
=
0x4000
;
opcode
=
0
;
}
}
if
(
(
opcode
&
1
)
!
=
0
)
{
C
=
B
;
B
=
A
;
A
=
NEG_LONG
(
C
)
;
}
Normalize
(
A
B
&
exc
-
>
GS
.
projVector
)
;
Compute_Funcs
(
exc
)
;
}
static
void
Ins_SZP0
(
TT_ExecContext
exc
FT_Long
*
args
)
{
switch
(
(
FT_Int
)
args
[
0
]
)
{
case
0
:
exc
-
>
zp0
=
exc
-
>
twilight
;
break
;
case
1
:
exc
-
>
zp0
=
exc
-
>
pts
;
break
;
default
:
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
exc
-
>
GS
.
gep0
=
(
FT_UShort
)
args
[
0
]
;
}
static
void
Ins_SZP1
(
TT_ExecContext
exc
FT_Long
*
args
)
{
switch
(
(
FT_Int
)
args
[
0
]
)
{
case
0
:
exc
-
>
zp1
=
exc
-
>
twilight
;
break
;
case
1
:
exc
-
>
zp1
=
exc
-
>
pts
;
break
;
default
:
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
exc
-
>
GS
.
gep1
=
(
FT_UShort
)
args
[
0
]
;
}
static
void
Ins_SZP2
(
TT_ExecContext
exc
FT_Long
*
args
)
{
switch
(
(
FT_Int
)
args
[
0
]
)
{
case
0
:
exc
-
>
zp2
=
exc
-
>
twilight
;
break
;
case
1
:
exc
-
>
zp2
=
exc
-
>
pts
;
break
;
default
:
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
exc
-
>
GS
.
gep2
=
(
FT_UShort
)
args
[
0
]
;
}
static
void
Ins_SZPS
(
TT_ExecContext
exc
FT_Long
*
args
)
{
switch
(
(
FT_Int
)
args
[
0
]
)
{
case
0
:
exc
-
>
zp0
=
exc
-
>
twilight
;
break
;
case
1
:
exc
-
>
zp0
=
exc
-
>
pts
;
break
;
default
:
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
exc
-
>
zp1
=
exc
-
>
zp0
;
exc
-
>
zp2
=
exc
-
>
zp0
;
exc
-
>
GS
.
gep0
=
(
FT_UShort
)
args
[
0
]
;
exc
-
>
GS
.
gep1
=
(
FT_UShort
)
args
[
0
]
;
exc
-
>
GS
.
gep2
=
(
FT_UShort
)
args
[
0
]
;
}
static
void
Ins_INSTCTRL
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
K
L
Kf
;
K
=
(
FT_ULong
)
args
[
1
]
;
L
=
(
FT_ULong
)
args
[
0
]
;
if
(
K
<
1
|
|
K
>
3
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
Kf
=
1
<
<
(
K
-
1
)
;
if
(
L
!
=
0
)
{
if
(
L
!
=
Kf
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
}
exc
-
>
GS
.
instruct_control
&
=
~
(
FT_Byte
)
Kf
;
exc
-
>
GS
.
instruct_control
|
=
(
FT_Byte
)
L
;
if
(
K
=
=
3
)
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
)
exc
-
>
ignore_x_mode
=
FT_BOOL
(
L
=
=
4
)
;
#
endif
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
SUBPIXEL_HINTING_MINIMAL
)
exc
-
>
backward_compatibility
=
!
FT_BOOL
(
L
=
=
4
)
;
#
endif
}
}
static
void
Ins_SCANCTRL
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_Int
A
;
A
=
(
FT_Int
)
(
args
[
0
]
&
0xFF
)
;
if
(
A
=
=
0xFF
)
{
exc
-
>
GS
.
scan_control
=
TRUE
;
return
;
}
else
if
(
A
=
=
0
)
{
exc
-
>
GS
.
scan_control
=
FALSE
;
return
;
}
if
(
(
args
[
0
]
&
0x100
)
!
=
0
&
&
exc
-
>
tt_metrics
.
ppem
<
=
A
)
exc
-
>
GS
.
scan_control
=
TRUE
;
if
(
(
args
[
0
]
&
0x200
)
!
=
0
&
&
exc
-
>
tt_metrics
.
rotated
)
exc
-
>
GS
.
scan_control
=
TRUE
;
if
(
(
args
[
0
]
&
0x400
)
!
=
0
&
&
exc
-
>
tt_metrics
.
stretched
)
exc
-
>
GS
.
scan_control
=
TRUE
;
if
(
(
args
[
0
]
&
0x800
)
!
=
0
&
&
exc
-
>
tt_metrics
.
ppem
>
A
)
exc
-
>
GS
.
scan_control
=
FALSE
;
if
(
(
args
[
0
]
&
0x1000
)
!
=
0
&
&
exc
-
>
tt_metrics
.
rotated
)
exc
-
>
GS
.
scan_control
=
FALSE
;
if
(
(
args
[
0
]
&
0x2000
)
!
=
0
&
&
exc
-
>
tt_metrics
.
stretched
)
exc
-
>
GS
.
scan_control
=
FALSE
;
}
static
void
Ins_SCANTYPE
(
TT_ExecContext
exc
FT_Long
*
args
)
{
if
(
args
[
0
]
>
=
0
)
exc
-
>
GS
.
scan_type
=
(
FT_Int
)
args
[
0
]
&
0xFFFF
;
}
static
void
Ins_FLIPPT
(
TT_ExecContext
exc
)
{
FT_UShort
point
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
backward_compatibility
&
&
exc
-
>
iupx_called
&
&
exc
-
>
iupy_called
)
goto
Fail
;
#
endif
if
(
exc
-
>
top
<
exc
-
>
GS
.
loop
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Too_Few_Arguments
)
;
goto
Fail
;
}
while
(
exc
-
>
GS
.
loop
>
0
)
{
exc
-
>
args
-
-
;
point
=
(
FT_UShort
)
exc
-
>
stack
[
exc
-
>
args
]
;
if
(
BOUNDS
(
point
exc
-
>
pts
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
{
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
}
else
exc
-
>
pts
.
tags
[
point
]
^
=
FT_CURVE_TAG_ON
;
exc
-
>
GS
.
loop
-
-
;
}
Fail
:
exc
-
>
GS
.
loop
=
1
;
exc
-
>
new_top
=
exc
-
>
args
;
}
static
void
Ins_FLIPRGON
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
I
K
L
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
backward_compatibility
&
&
exc
-
>
iupx_called
&
&
exc
-
>
iupy_called
)
return
;
#
endif
K
=
(
FT_UShort
)
args
[
1
]
;
L
=
(
FT_UShort
)
args
[
0
]
;
if
(
BOUNDS
(
K
exc
-
>
pts
.
n_points
)
|
|
BOUNDS
(
L
exc
-
>
pts
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
for
(
I
=
L
;
I
<
=
K
;
I
+
+
)
exc
-
>
pts
.
tags
[
I
]
|
=
FT_CURVE_TAG_ON
;
}
static
void
Ins_FLIPRGOFF
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
I
K
L
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
backward_compatibility
&
&
exc
-
>
iupx_called
&
&
exc
-
>
iupy_called
)
return
;
#
endif
K
=
(
FT_UShort
)
args
[
1
]
;
L
=
(
FT_UShort
)
args
[
0
]
;
if
(
BOUNDS
(
K
exc
-
>
pts
.
n_points
)
|
|
BOUNDS
(
L
exc
-
>
pts
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
for
(
I
=
L
;
I
<
=
K
;
I
+
+
)
exc
-
>
pts
.
tags
[
I
]
&
=
~
FT_CURVE_TAG_ON
;
}
static
FT_Bool
Compute_Point_Displacement
(
TT_ExecContext
exc
FT_F26Dot6
*
x
FT_F26Dot6
*
y
TT_GlyphZone
zone
FT_UShort
*
refp
)
{
TT_GlyphZoneRec
zp
;
FT_UShort
p
;
FT_F26Dot6
d
;
if
(
exc
-
>
opcode
&
1
)
{
zp
=
exc
-
>
zp0
;
p
=
exc
-
>
GS
.
rp1
;
}
else
{
zp
=
exc
-
>
zp1
;
p
=
exc
-
>
GS
.
rp2
;
}
if
(
BOUNDS
(
p
zp
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
*
refp
=
0
;
return
FAILURE
;
}
*
zone
=
zp
;
*
refp
=
p
;
d
=
PROJECT
(
zp
.
cur
+
p
zp
.
org
+
p
)
;
*
x
=
FT_MulDiv
(
d
(
FT_Long
)
exc
-
>
GS
.
freeVector
.
x
exc
-
>
F_dot_P
)
;
*
y
=
FT_MulDiv
(
d
(
FT_Long
)
exc
-
>
GS
.
freeVector
.
y
exc
-
>
F_dot_P
)
;
return
SUCCESS
;
}
static
void
Move_Zp2_Point
(
TT_ExecContext
exc
FT_UShort
point
FT_F26Dot6
dx
FT_F26Dot6
dy
FT_Bool
touch
)
{
if
(
exc
-
>
GS
.
freeVector
.
x
!
=
0
)
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
!
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
backward_compatibility
)
)
#
endif
exc
-
>
zp2
.
cur
[
point
]
.
x
=
ADD_LONG
(
exc
-
>
zp2
.
cur
[
point
]
.
x
dx
)
;
if
(
touch
)
exc
-
>
zp2
.
tags
[
point
]
|
=
FT_CURVE_TAG_TOUCH_X
;
}
if
(
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
!
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
backward_compatibility
&
&
exc
-
>
iupx_called
&
&
exc
-
>
iupy_called
)
)
#
endif
exc
-
>
zp2
.
cur
[
point
]
.
y
=
ADD_LONG
(
exc
-
>
zp2
.
cur
[
point
]
.
y
dy
)
;
if
(
touch
)
exc
-
>
zp2
.
tags
[
point
]
|
=
FT_CURVE_TAG_TOUCH_Y
;
}
}
static
void
Ins_SHP
(
TT_ExecContext
exc
)
{
TT_GlyphZoneRec
zp
;
FT_UShort
refp
;
FT_F26Dot6
dx
dy
;
FT_UShort
point
;
if
(
exc
-
>
top
<
exc
-
>
GS
.
loop
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
goto
Fail
;
}
if
(
Compute_Point_Displacement
(
exc
&
dx
&
dy
&
zp
&
refp
)
)
return
;
while
(
exc
-
>
GS
.
loop
>
0
)
{
exc
-
>
args
-
-
;
point
=
(
FT_UShort
)
exc
-
>
stack
[
exc
-
>
args
]
;
if
(
BOUNDS
(
point
exc
-
>
zp2
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
{
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
}
else
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
)
Move_Zp2_Point
(
exc
point
0
dy
TRUE
)
;
else
#
endif
Move_Zp2_Point
(
exc
point
dx
dy
TRUE
)
;
exc
-
>
GS
.
loop
-
-
;
}
Fail
:
exc
-
>
GS
.
loop
=
1
;
exc
-
>
new_top
=
exc
-
>
args
;
}
static
void
Ins_SHC
(
TT_ExecContext
exc
FT_Long
*
args
)
{
TT_GlyphZoneRec
zp
;
FT_UShort
refp
;
FT_F26Dot6
dx
dy
;
FT_Short
contour
bounds
;
FT_UShort
start
limit
i
;
contour
=
(
FT_Short
)
args
[
0
]
;
bounds
=
(
exc
-
>
GS
.
gep2
=
=
0
)
?
1
:
exc
-
>
zp2
.
n_contours
;
if
(
BOUNDS
(
contour
bounds
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
if
(
Compute_Point_Displacement
(
exc
&
dx
&
dy
&
zp
&
refp
)
)
return
;
if
(
contour
=
=
0
)
start
=
0
;
else
start
=
(
FT_UShort
)
(
exc
-
>
zp2
.
contours
[
contour
-
1
]
+
1
-
exc
-
>
zp2
.
first_point
)
;
if
(
exc
-
>
GS
.
gep2
=
=
0
)
limit
=
exc
-
>
zp2
.
n_points
;
else
limit
=
(
FT_UShort
)
(
exc
-
>
zp2
.
contours
[
contour
]
-
exc
-
>
zp2
.
first_point
+
1
)
;
for
(
i
=
start
;
i
<
limit
;
i
+
+
)
{
if
(
zp
.
cur
!
=
exc
-
>
zp2
.
cur
|
|
refp
!
=
i
)
Move_Zp2_Point
(
exc
i
dx
dy
TRUE
)
;
}
}
static
void
Ins_SHZ
(
TT_ExecContext
exc
FT_Long
*
args
)
{
TT_GlyphZoneRec
zp
;
FT_UShort
refp
;
FT_F26Dot6
dx
dy
;
FT_UShort
limit
i
;
if
(
BOUNDS
(
args
[
0
]
2
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
if
(
Compute_Point_Displacement
(
exc
&
dx
&
dy
&
zp
&
refp
)
)
return
;
if
(
exc
-
>
GS
.
gep2
=
=
0
)
limit
=
(
FT_UShort
)
exc
-
>
zp2
.
n_points
;
else
if
(
exc
-
>
GS
.
gep2
=
=
1
&
&
exc
-
>
zp2
.
n_contours
>
0
)
limit
=
(
FT_UShort
)
(
exc
-
>
zp2
.
contours
[
exc
-
>
zp2
.
n_contours
-
1
]
+
1
)
;
else
limit
=
0
;
for
(
i
=
0
;
i
<
limit
;
i
+
+
)
{
if
(
zp
.
cur
!
=
exc
-
>
zp2
.
cur
|
|
refp
!
=
i
)
Move_Zp2_Point
(
exc
i
dx
dy
FALSE
)
;
}
}
static
void
Ins_SHPIX
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_F26Dot6
dx
dy
;
FT_UShort
point
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
FT_Int
B1
B2
;
#
endif
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
FT_Bool
in_twilight
=
FT_BOOL
(
exc
-
>
GS
.
gep0
=
=
0
|
|
exc
-
>
GS
.
gep1
=
=
0
|
|
exc
-
>
GS
.
gep2
=
=
0
)
;
#
endif
if
(
exc
-
>
top
<
exc
-
>
GS
.
loop
+
1
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
goto
Fail
;
}
dx
=
TT_MulFix14
(
args
[
0
]
exc
-
>
GS
.
freeVector
.
x
)
;
dy
=
TT_MulFix14
(
args
[
0
]
exc
-
>
GS
.
freeVector
.
y
)
;
while
(
exc
-
>
GS
.
loop
>
0
)
{
exc
-
>
args
-
-
;
point
=
(
FT_UShort
)
exc
-
>
stack
[
exc
-
>
args
]
;
if
(
BOUNDS
(
point
exc
-
>
zp2
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
{
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
}
else
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
)
{
if
(
exc
-
>
ignore_x_mode
)
{
if
(
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
B1
=
exc
-
>
zp2
.
cur
[
point
]
.
y
;
else
B1
=
exc
-
>
zp2
.
cur
[
point
]
.
x
;
if
(
!
exc
-
>
face
-
>
sph_compatibility_mode
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
{
Move_Zp2_Point
(
exc
point
dx
dy
TRUE
)
;
if
(
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
{
B2
=
exc
-
>
zp2
.
cur
[
point
]
.
y
;
if
(
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES
)
&
&
(
B1
&
63
)
!
=
0
&
&
(
B2
&
63
)
!
=
0
&
&
B1
!
=
B2
)
Move_Zp2_Point
(
exc
point
NEG_LONG
(
dx
)
NEG_LONG
(
dy
)
TRUE
)
;
}
}
else
if
(
exc
-
>
face
-
>
sph_compatibility_mode
)
{
if
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES
)
{
dx
=
FT_PIX_ROUND
(
B1
+
dx
)
-
B1
;
dy
=
FT_PIX_ROUND
(
B1
+
dy
)
-
B1
;
}
if
(
exc
-
>
iup_called
&
&
(
(
exc
-
>
sph_in_func_flags
&
SPH_FDEF_INLINE_DELTA_1
)
|
|
(
exc
-
>
sph_in_func_flags
&
SPH_FDEF_INLINE_DELTA_2
)
)
)
goto
Skip
;
if
(
!
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_ALWAYS_SKIP_DELTAP
)
&
&
(
(
exc
-
>
is_composite
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
|
|
(
exc
-
>
zp2
.
tags
[
point
]
&
FT_CURVE_TAG_TOUCH_Y
)
|
|
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_DO_SHPIX
)
)
)
Move_Zp2_Point
(
exc
point
0
dy
TRUE
)
;
if
(
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
{
B2
=
exc
-
>
zp2
.
cur
[
point
]
.
y
;
if
(
(
B1
&
63
)
=
=
0
&
&
(
B2
&
63
)
!
=
0
&
&
B1
!
=
B2
)
Move_Zp2_Point
(
exc
point
0
NEG_LONG
(
dy
)
TRUE
)
;
}
}
else
if
(
exc
-
>
sph_in_func_flags
&
SPH_FDEF_TYPEMAN_DIAGENDCTRL
)
Move_Zp2_Point
(
exc
point
dx
dy
TRUE
)
;
}
else
Move_Zp2_Point
(
exc
point
dx
dy
TRUE
)
;
}
else
#
endif
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
backward_compatibility
)
{
if
(
in_twilight
|
|
(
!
(
exc
-
>
iupx_called
&
&
exc
-
>
iupy_called
)
&
&
(
(
exc
-
>
is_composite
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
|
|
(
exc
-
>
zp2
.
tags
[
point
]
&
FT_CURVE_TAG_TOUCH_Y
)
)
)
)
Move_Zp2_Point
(
exc
point
0
dy
TRUE
)
;
}
else
#
endif
Move_Zp2_Point
(
exc
point
dx
dy
TRUE
)
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
Skip
:
#
endif
exc
-
>
GS
.
loop
-
-
;
}
Fail
:
exc
-
>
GS
.
loop
=
1
;
exc
-
>
new_top
=
exc
-
>
args
;
}
static
void
Ins_MSIRP
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
point
=
0
;
FT_F26Dot6
distance
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
FT_F26Dot6
control_value_cutin
=
0
;
FT_F26Dot6
delta
;
if
(
SUBPIXEL_HINTING_INFINALITY
)
{
control_value_cutin
=
exc
-
>
GS
.
control_value_cutin
;
if
(
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
x
!
=
0
&
&
!
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_NORMAL_ROUND
)
)
control_value_cutin
=
0
;
}
#
endif
point
=
(
FT_UShort
)
args
[
0
]
;
if
(
BOUNDS
(
point
exc
-
>
zp1
.
n_points
)
|
|
BOUNDS
(
exc
-
>
GS
.
rp0
exc
-
>
zp0
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
if
(
exc
-
>
GS
.
gep1
=
=
0
)
{
exc
-
>
zp1
.
org
[
point
]
=
exc
-
>
zp0
.
org
[
exc
-
>
GS
.
rp0
]
;
exc
-
>
func_move_orig
(
exc
&
exc
-
>
zp1
point
args
[
1
]
)
;
exc
-
>
zp1
.
cur
[
point
]
=
exc
-
>
zp1
.
org
[
point
]
;
}
distance
=
PROJECT
(
exc
-
>
zp1
.
cur
+
point
exc
-
>
zp0
.
cur
+
exc
-
>
GS
.
rp0
)
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
delta
=
SUB_LONG
(
distance
args
[
1
]
)
;
if
(
delta
<
0
)
delta
=
NEG_LONG
(
delta
)
;
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
x
!
=
0
&
&
delta
>
=
control_value_cutin
)
distance
=
args
[
1
]
;
#
endif
exc
-
>
func_move
(
exc
&
exc
-
>
zp1
point
SUB_LONG
(
args
[
1
]
distance
)
)
;
exc
-
>
GS
.
rp1
=
exc
-
>
GS
.
rp0
;
exc
-
>
GS
.
rp2
=
point
;
if
(
(
exc
-
>
opcode
&
1
)
!
=
0
)
exc
-
>
GS
.
rp0
=
point
;
}
static
void
Ins_MDAP
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
point
;
FT_F26Dot6
cur_dist
;
FT_F26Dot6
distance
;
point
=
(
FT_UShort
)
args
[
0
]
;
if
(
BOUNDS
(
point
exc
-
>
zp0
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
if
(
(
exc
-
>
opcode
&
1
)
!
=
0
)
{
cur_dist
=
FAST_PROJECT
(
&
exc
-
>
zp0
.
cur
[
point
]
)
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
x
!
=
0
)
distance
=
SUB_LONG
(
Round_None
(
exc
cur_dist
exc
-
>
tt_metrics
.
compensations
[
0
]
)
cur_dist
)
;
else
#
endif
distance
=
SUB_LONG
(
exc
-
>
func_round
(
exc
cur_dist
exc
-
>
tt_metrics
.
compensations
[
0
]
)
cur_dist
)
;
}
else
distance
=
0
;
exc
-
>
func_move
(
exc
&
exc
-
>
zp0
point
distance
)
;
exc
-
>
GS
.
rp0
=
point
;
exc
-
>
GS
.
rp1
=
point
;
}
static
void
Ins_MIAP
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
cvtEntry
;
FT_UShort
point
;
FT_F26Dot6
distance
;
FT_F26Dot6
org_dist
;
FT_F26Dot6
control_value_cutin
;
control_value_cutin
=
exc
-
>
GS
.
control_value_cutin
;
cvtEntry
=
(
FT_ULong
)
args
[
1
]
;
point
=
(
FT_UShort
)
args
[
0
]
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
x
!
=
0
&
&
exc
-
>
GS
.
freeVector
.
y
=
=
0
&
&
!
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_NORMAL_ROUND
)
)
control_value_cutin
=
0
;
#
endif
if
(
BOUNDS
(
point
exc
-
>
zp0
.
n_points
)
|
|
BOUNDSL
(
cvtEntry
exc
-
>
cvtSize
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
goto
Fail
;
}
distance
=
exc
-
>
func_read_cvt
(
exc
cvtEntry
)
;
if
(
exc
-
>
GS
.
gep0
=
=
0
)
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
!
(
SUBPIXEL_HINTING_INFINALITY
&
&
(
exc
-
>
ignore_x_mode
&
&
exc
-
>
face
-
>
sph_compatibility_mode
)
)
)
#
endif
exc
-
>
zp0
.
org
[
point
]
.
x
=
TT_MulFix14
(
distance
exc
-
>
GS
.
freeVector
.
x
)
;
exc
-
>
zp0
.
org
[
point
]
.
y
=
TT_MulFix14
(
distance
exc
-
>
GS
.
freeVector
.
y
)
exc
-
>
zp0
.
cur
[
point
]
=
exc
-
>
zp0
.
org
[
point
]
;
}
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_MIAP_HACK
)
&
&
distance
>
0
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
distance
=
0
;
#
endif
org_dist
=
FAST_PROJECT
(
&
exc
-
>
zp0
.
cur
[
point
]
)
;
if
(
(
exc
-
>
opcode
&
1
)
!
=
0
)
{
FT_F26Dot6
delta
;
delta
=
SUB_LONG
(
distance
org_dist
)
;
if
(
delta
<
0
)
delta
=
NEG_LONG
(
delta
)
;
if
(
delta
>
control_value_cutin
)
distance
=
org_dist
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
x
!
=
0
)
distance
=
Round_None
(
exc
distance
exc
-
>
tt_metrics
.
compensations
[
0
]
)
;
else
#
endif
distance
=
exc
-
>
func_round
(
exc
distance
exc
-
>
tt_metrics
.
compensations
[
0
]
)
;
}
exc
-
>
func_move
(
exc
&
exc
-
>
zp0
point
SUB_LONG
(
distance
org_dist
)
)
;
Fail
:
exc
-
>
GS
.
rp0
=
point
;
exc
-
>
GS
.
rp1
=
point
;
}
static
void
Ins_MDRP
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
point
=
0
;
FT_F26Dot6
org_dist
distance
minimum_distance
;
minimum_distance
=
exc
-
>
GS
.
minimum_distance
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
x
!
=
0
&
&
!
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_NORMAL_ROUND
)
)
minimum_distance
=
0
;
#
endif
point
=
(
FT_UShort
)
args
[
0
]
;
if
(
BOUNDS
(
point
exc
-
>
zp1
.
n_points
)
|
|
BOUNDS
(
exc
-
>
GS
.
rp0
exc
-
>
zp0
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
goto
Fail
;
}
if
(
exc
-
>
GS
.
gep0
=
=
0
|
|
exc
-
>
GS
.
gep1
=
=
0
)
{
FT_Vector
*
vec1
=
&
exc
-
>
zp1
.
org
[
point
]
;
FT_Vector
*
vec2
=
&
exc
-
>
zp0
.
org
[
exc
-
>
GS
.
rp0
]
;
org_dist
=
DUALPROJ
(
vec1
vec2
)
;
}
else
{
FT_Vector
*
vec1
=
&
exc
-
>
zp1
.
orus
[
point
]
;
FT_Vector
*
vec2
=
&
exc
-
>
zp0
.
orus
[
exc
-
>
GS
.
rp0
]
;
if
(
exc
-
>
metrics
.
x_scale
=
=
exc
-
>
metrics
.
y_scale
)
{
org_dist
=
DUALPROJ
(
vec1
vec2
)
;
org_dist
=
FT_MulFix
(
org_dist
exc
-
>
metrics
.
x_scale
)
;
}
else
{
FT_Vector
vec
;
vec
.
x
=
FT_MulFix
(
SUB_LONG
(
vec1
-
>
x
vec2
-
>
x
)
exc
-
>
metrics
.
x_scale
)
;
vec
.
y
=
FT_MulFix
(
SUB_LONG
(
vec1
-
>
y
vec2
-
>
y
)
exc
-
>
metrics
.
y_scale
)
;
org_dist
=
FAST_DUALPROJ
(
&
vec
)
;
}
}
if
(
exc
-
>
GS
.
single_width_cutin
>
0
&
&
org_dist
<
exc
-
>
GS
.
single_width_value
+
exc
-
>
GS
.
single_width_cutin
&
&
org_dist
>
exc
-
>
GS
.
single_width_value
-
exc
-
>
GS
.
single_width_cutin
)
{
if
(
org_dist
>
=
0
)
org_dist
=
exc
-
>
GS
.
single_width_value
;
else
org_dist
=
-
exc
-
>
GS
.
single_width_value
;
}
if
(
(
exc
-
>
opcode
&
4
)
!
=
0
)
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
x
!
=
0
)
distance
=
Round_None
(
exc
org_dist
exc
-
>
tt_metrics
.
compensations
[
exc
-
>
opcode
&
3
]
)
;
else
#
endif
distance
=
exc
-
>
func_round
(
exc
org_dist
exc
-
>
tt_metrics
.
compensations
[
exc
-
>
opcode
&
3
]
)
;
}
else
distance
=
Round_None
(
exc
org_dist
exc
-
>
tt_metrics
.
compensations
[
exc
-
>
opcode
&
3
]
)
;
if
(
(
exc
-
>
opcode
&
8
)
!
=
0
)
{
if
(
org_dist
>
=
0
)
{
if
(
distance
<
minimum_distance
)
distance
=
minimum_distance
;
}
else
{
if
(
distance
>
NEG_LONG
(
minimum_distance
)
)
distance
=
NEG_LONG
(
minimum_distance
)
;
}
}
org_dist
=
PROJECT
(
exc
-
>
zp1
.
cur
+
point
exc
-
>
zp0
.
cur
+
exc
-
>
GS
.
rp0
)
;
exc
-
>
func_move
(
exc
&
exc
-
>
zp1
point
SUB_LONG
(
distance
org_dist
)
)
;
Fail
:
exc
-
>
GS
.
rp1
=
exc
-
>
GS
.
rp0
;
exc
-
>
GS
.
rp2
=
point
;
if
(
(
exc
-
>
opcode
&
16
)
!
=
0
)
exc
-
>
GS
.
rp0
=
point
;
}
static
void
Ins_MIRP
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
point
;
FT_ULong
cvtEntry
;
FT_F26Dot6
cvt_dist
distance
cur_dist
org_dist
control_value_cutin
minimum_distance
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
FT_Int
B1
=
0
;
FT_Int
B2
=
0
;
FT_Bool
reverse_move
=
FALSE
;
#
endif
FT_F26Dot6
delta
;
minimum_distance
=
exc
-
>
GS
.
minimum_distance
;
control_value_cutin
=
exc
-
>
GS
.
control_value_cutin
;
point
=
(
FT_UShort
)
args
[
0
]
;
cvtEntry
=
(
FT_ULong
)
(
ADD_LONG
(
args
[
1
]
1
)
)
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
x
!
=
0
&
&
!
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_NORMAL_ROUND
)
)
control_value_cutin
=
minimum_distance
=
0
;
#
endif
if
(
BOUNDS
(
point
exc
-
>
zp1
.
n_points
)
|
|
BOUNDSL
(
cvtEntry
exc
-
>
cvtSize
+
1
)
|
|
BOUNDS
(
exc
-
>
GS
.
rp0
exc
-
>
zp0
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
goto
Fail
;
}
if
(
!
cvtEntry
)
cvt_dist
=
0
;
else
cvt_dist
=
exc
-
>
func_read_cvt
(
exc
cvtEntry
-
1
)
;
delta
=
SUB_LONG
(
cvt_dist
exc
-
>
GS
.
single_width_value
)
;
if
(
delta
<
0
)
delta
=
NEG_LONG
(
delta
)
;
if
(
delta
<
exc
-
>
GS
.
single_width_cutin
)
{
if
(
cvt_dist
>
=
0
)
cvt_dist
=
exc
-
>
GS
.
single_width_value
;
else
cvt_dist
=
-
exc
-
>
GS
.
single_width_value
;
}
if
(
exc
-
>
GS
.
gep1
=
=
0
)
{
exc
-
>
zp1
.
org
[
point
]
.
x
=
exc
-
>
zp0
.
org
[
exc
-
>
GS
.
rp0
]
.
x
+
TT_MulFix14
(
cvt_dist
exc
-
>
GS
.
freeVector
.
x
)
;
exc
-
>
zp1
.
org
[
point
]
.
y
=
exc
-
>
zp0
.
org
[
exc
-
>
GS
.
rp0
]
.
y
+
TT_MulFix14
(
cvt_dist
exc
-
>
GS
.
freeVector
.
y
)
;
exc
-
>
zp1
.
cur
[
point
]
=
exc
-
>
zp1
.
org
[
point
]
;
}
org_dist
=
DUALPROJ
(
&
exc
-
>
zp1
.
org
[
point
]
&
exc
-
>
zp0
.
org
[
exc
-
>
GS
.
rp0
]
)
;
cur_dist
=
PROJECT
(
&
exc
-
>
zp1
.
cur
[
point
]
&
exc
-
>
zp0
.
cur
[
exc
-
>
GS
.
rp0
]
)
;
if
(
exc
-
>
GS
.
auto_flip
)
{
if
(
(
org_dist
^
cvt_dist
)
<
0
)
cvt_dist
=
NEG_LONG
(
cvt_dist
)
;
}
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
&
&
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_TIMES_NEW_ROMAN_HACK
)
)
{
if
(
cur_dist
<
-
64
)
cvt_dist
-
=
16
;
else
if
(
cur_dist
>
64
&
&
cur_dist
<
84
)
cvt_dist
+
=
32
;
}
#
endif
if
(
(
exc
-
>
opcode
&
4
)
!
=
0
)
{
if
(
exc
-
>
GS
.
gep0
=
=
exc
-
>
GS
.
gep1
)
{
delta
=
SUB_LONG
(
cvt_dist
org_dist
)
;
if
(
delta
<
0
)
delta
=
NEG_LONG
(
delta
)
;
if
(
delta
>
control_value_cutin
)
cvt_dist
=
org_dist
;
}
distance
=
exc
-
>
func_round
(
exc
cvt_dist
exc
-
>
tt_metrics
.
compensations
[
exc
-
>
opcode
&
3
]
)
;
}
else
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
gep0
=
=
exc
-
>
GS
.
gep1
)
{
delta
=
SUB_LONG
(
cvt_dist
org_dist
)
;
if
(
delta
<
0
)
delta
=
NEG_LONG
(
delta
)
;
if
(
delta
>
control_value_cutin
)
cvt_dist
=
org_dist
;
}
#
endif
distance
=
Round_None
(
exc
cvt_dist
exc
-
>
tt_metrics
.
compensations
[
exc
-
>
opcode
&
3
]
)
;
}
if
(
(
exc
-
>
opcode
&
8
)
!
=
0
)
{
if
(
org_dist
>
=
0
)
{
if
(
distance
<
minimum_distance
)
distance
=
minimum_distance
;
}
else
{
if
(
distance
>
NEG_LONG
(
minimum_distance
)
)
distance
=
NEG_LONG
(
minimum_distance
)
;
}
}
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
)
{
B1
=
exc
-
>
zp1
.
cur
[
point
]
.
y
;
if
(
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
&
&
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES
)
)
distance
=
FT_PIX_ROUND
(
B1
+
distance
-
cur_dist
)
-
B1
+
cur_dist
;
if
(
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
&
&
(
exc
-
>
opcode
&
16
)
=
=
0
&
&
(
exc
-
>
opcode
&
8
)
=
=
0
&
&
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_COURIER_NEW_2_HACK
)
)
distance
+
=
64
;
}
#
endif
exc
-
>
func_move
(
exc
&
exc
-
>
zp1
point
SUB_LONG
(
distance
cur_dist
)
)
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
)
{
B2
=
exc
-
>
zp1
.
cur
[
point
]
.
y
;
if
(
exc
-
>
ignore_x_mode
)
{
if
(
exc
-
>
face
-
>
sph_compatibility_mode
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
&
&
(
B1
&
63
)
=
=
0
&
&
(
B2
&
63
)
!
=
0
)
reverse_move
=
TRUE
;
if
(
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES
)
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
&
&
(
B2
&
63
)
!
=
0
&
&
(
B1
&
63
)
!
=
0
)
reverse_move
=
TRUE
;
}
if
(
reverse_move
)
exc
-
>
func_move
(
exc
&
exc
-
>
zp1
point
SUB_LONG
(
cur_dist
distance
)
)
;
}
#
endif
Fail
:
exc
-
>
GS
.
rp1
=
exc
-
>
GS
.
rp0
;
if
(
(
exc
-
>
opcode
&
16
)
!
=
0
)
exc
-
>
GS
.
rp0
=
point
;
exc
-
>
GS
.
rp2
=
point
;
}
static
void
Ins_ALIGNRP
(
TT_ExecContext
exc
)
{
FT_UShort
point
;
FT_F26Dot6
distance
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
exc
-
>
iup_called
&
&
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_NO_ALIGNRP_AFTER_IUP
)
)
{
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
goto
Fail
;
}
#
endif
if
(
exc
-
>
top
<
exc
-
>
GS
.
loop
|
|
BOUNDS
(
exc
-
>
GS
.
rp0
exc
-
>
zp0
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
goto
Fail
;
}
while
(
exc
-
>
GS
.
loop
>
0
)
{
exc
-
>
args
-
-
;
point
=
(
FT_UShort
)
exc
-
>
stack
[
exc
-
>
args
]
;
if
(
BOUNDS
(
point
exc
-
>
zp1
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
{
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
}
else
{
distance
=
PROJECT
(
exc
-
>
zp1
.
cur
+
point
exc
-
>
zp0
.
cur
+
exc
-
>
GS
.
rp0
)
;
exc
-
>
func_move
(
exc
&
exc
-
>
zp1
point
NEG_LONG
(
distance
)
)
;
}
exc
-
>
GS
.
loop
-
-
;
}
Fail
:
exc
-
>
GS
.
loop
=
1
;
exc
-
>
new_top
=
exc
-
>
args
;
}
static
void
Ins_ISECT
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
point
a0
a1
b0
b1
;
FT_F26Dot6
discriminant
dotproduct
;
FT_F26Dot6
dx
dy
dax
day
dbx
dby
;
FT_F26Dot6
val
;
FT_Vector
R
;
point
=
(
FT_UShort
)
args
[
0
]
;
a0
=
(
FT_UShort
)
args
[
1
]
;
a1
=
(
FT_UShort
)
args
[
2
]
;
b0
=
(
FT_UShort
)
args
[
3
]
;
b1
=
(
FT_UShort
)
args
[
4
]
;
if
(
BOUNDS
(
b0
exc
-
>
zp0
.
n_points
)
|
|
BOUNDS
(
b1
exc
-
>
zp0
.
n_points
)
|
|
BOUNDS
(
a0
exc
-
>
zp1
.
n_points
)
|
|
BOUNDS
(
a1
exc
-
>
zp1
.
n_points
)
|
|
BOUNDS
(
point
exc
-
>
zp2
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
dbx
=
SUB_LONG
(
exc
-
>
zp0
.
cur
[
b1
]
.
x
exc
-
>
zp0
.
cur
[
b0
]
.
x
)
;
dby
=
SUB_LONG
(
exc
-
>
zp0
.
cur
[
b1
]
.
y
exc
-
>
zp0
.
cur
[
b0
]
.
y
)
;
dax
=
SUB_LONG
(
exc
-
>
zp1
.
cur
[
a1
]
.
x
exc
-
>
zp1
.
cur
[
a0
]
.
x
)
;
day
=
SUB_LONG
(
exc
-
>
zp1
.
cur
[
a1
]
.
y
exc
-
>
zp1
.
cur
[
a0
]
.
y
)
;
dx
=
SUB_LONG
(
exc
-
>
zp0
.
cur
[
b0
]
.
x
exc
-
>
zp1
.
cur
[
a0
]
.
x
)
;
dy
=
SUB_LONG
(
exc
-
>
zp0
.
cur
[
b0
]
.
y
exc
-
>
zp1
.
cur
[
a0
]
.
y
)
;
discriminant
=
ADD_LONG
(
FT_MulDiv
(
dax
NEG_LONG
(
dby
)
0x40
)
FT_MulDiv
(
day
dbx
0x40
)
)
;
dotproduct
=
ADD_LONG
(
FT_MulDiv
(
dax
dbx
0x40
)
FT_MulDiv
(
day
dby
0x40
)
)
;
if
(
MUL_LONG
(
19
FT_ABS
(
discriminant
)
)
>
FT_ABS
(
dotproduct
)
)
{
val
=
ADD_LONG
(
FT_MulDiv
(
dx
NEG_LONG
(
dby
)
0x40
)
FT_MulDiv
(
dy
dbx
0x40
)
)
;
R
.
x
=
FT_MulDiv
(
val
dax
discriminant
)
;
R
.
y
=
FT_MulDiv
(
val
day
discriminant
)
;
exc
-
>
zp2
.
cur
[
point
]
.
x
=
ADD_LONG
(
exc
-
>
zp1
.
cur
[
a0
]
.
x
R
.
x
)
;
exc
-
>
zp2
.
cur
[
point
]
.
y
=
ADD_LONG
(
exc
-
>
zp1
.
cur
[
a0
]
.
y
R
.
y
)
;
}
else
{
exc
-
>
zp2
.
cur
[
point
]
.
x
=
ADD_LONG
(
ADD_LONG
(
exc
-
>
zp1
.
cur
[
a0
]
.
x
exc
-
>
zp1
.
cur
[
a1
]
.
x
)
ADD_LONG
(
exc
-
>
zp0
.
cur
[
b0
]
.
x
exc
-
>
zp0
.
cur
[
b1
]
.
x
)
)
/
4
;
exc
-
>
zp2
.
cur
[
point
]
.
y
=
ADD_LONG
(
ADD_LONG
(
exc
-
>
zp1
.
cur
[
a0
]
.
y
exc
-
>
zp1
.
cur
[
a1
]
.
y
)
ADD_LONG
(
exc
-
>
zp0
.
cur
[
b0
]
.
y
exc
-
>
zp0
.
cur
[
b1
]
.
y
)
)
/
4
;
}
exc
-
>
zp2
.
tags
[
point
]
|
=
FT_CURVE_TAG_TOUCH_BOTH
;
}
static
void
Ins_ALIGNPTS
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
p1
p2
;
FT_F26Dot6
distance
;
p1
=
(
FT_UShort
)
args
[
0
]
;
p2
=
(
FT_UShort
)
args
[
1
]
;
if
(
BOUNDS
(
p1
exc
-
>
zp1
.
n_points
)
|
|
BOUNDS
(
p2
exc
-
>
zp0
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
distance
=
PROJECT
(
exc
-
>
zp0
.
cur
+
p2
exc
-
>
zp1
.
cur
+
p1
)
/
2
;
exc
-
>
func_move
(
exc
&
exc
-
>
zp1
p1
distance
)
;
exc
-
>
func_move
(
exc
&
exc
-
>
zp0
p2
NEG_LONG
(
distance
)
)
;
}
static
void
Ins_IP
(
TT_ExecContext
exc
)
{
FT_F26Dot6
old_range
cur_range
;
FT_Vector
*
orus_base
;
FT_Vector
*
cur_base
;
FT_Int
twilight
;
if
(
exc
-
>
top
<
exc
-
>
GS
.
loop
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
goto
Fail
;
}
twilight
=
(
exc
-
>
GS
.
gep0
=
=
0
|
|
exc
-
>
GS
.
gep1
=
=
0
|
|
exc
-
>
GS
.
gep2
=
=
0
)
;
if
(
BOUNDS
(
exc
-
>
GS
.
rp1
exc
-
>
zp0
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
goto
Fail
;
}
if
(
twilight
)
orus_base
=
&
exc
-
>
zp0
.
org
[
exc
-
>
GS
.
rp1
]
;
else
orus_base
=
&
exc
-
>
zp0
.
orus
[
exc
-
>
GS
.
rp1
]
;
cur_base
=
&
exc
-
>
zp0
.
cur
[
exc
-
>
GS
.
rp1
]
;
if
(
BOUNDS
(
exc
-
>
GS
.
rp1
exc
-
>
zp0
.
n_points
)
|
|
BOUNDS
(
exc
-
>
GS
.
rp2
exc
-
>
zp1
.
n_points
)
)
{
old_range
=
0
;
cur_range
=
0
;
}
else
{
if
(
twilight
)
old_range
=
DUALPROJ
(
&
exc
-
>
zp1
.
org
[
exc
-
>
GS
.
rp2
]
orus_base
)
;
else
if
(
exc
-
>
metrics
.
x_scale
=
=
exc
-
>
metrics
.
y_scale
)
old_range
=
DUALPROJ
(
&
exc
-
>
zp1
.
orus
[
exc
-
>
GS
.
rp2
]
orus_base
)
;
else
{
FT_Vector
vec
;
vec
.
x
=
FT_MulFix
(
SUB_LONG
(
exc
-
>
zp1
.
orus
[
exc
-
>
GS
.
rp2
]
.
x
orus_base
-
>
x
)
exc
-
>
metrics
.
x_scale
)
;
vec
.
y
=
FT_MulFix
(
SUB_LONG
(
exc
-
>
zp1
.
orus
[
exc
-
>
GS
.
rp2
]
.
y
orus_base
-
>
y
)
exc
-
>
metrics
.
y_scale
)
;
old_range
=
FAST_DUALPROJ
(
&
vec
)
;
}
cur_range
=
PROJECT
(
&
exc
-
>
zp1
.
cur
[
exc
-
>
GS
.
rp2
]
cur_base
)
;
}
for
(
;
exc
-
>
GS
.
loop
>
0
;
exc
-
>
GS
.
loop
-
-
)
{
FT_UInt
point
=
(
FT_UInt
)
exc
-
>
stack
[
-
-
exc
-
>
args
]
;
FT_F26Dot6
org_dist
cur_dist
new_dist
;
if
(
BOUNDS
(
point
exc
-
>
zp2
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
{
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
continue
;
}
if
(
twilight
)
org_dist
=
DUALPROJ
(
&
exc
-
>
zp2
.
org
[
point
]
orus_base
)
;
else
if
(
exc
-
>
metrics
.
x_scale
=
=
exc
-
>
metrics
.
y_scale
)
org_dist
=
DUALPROJ
(
&
exc
-
>
zp2
.
orus
[
point
]
orus_base
)
;
else
{
FT_Vector
vec
;
vec
.
x
=
FT_MulFix
(
SUB_LONG
(
exc
-
>
zp2
.
orus
[
point
]
.
x
orus_base
-
>
x
)
exc
-
>
metrics
.
x_scale
)
;
vec
.
y
=
FT_MulFix
(
SUB_LONG
(
exc
-
>
zp2
.
orus
[
point
]
.
y
orus_base
-
>
y
)
exc
-
>
metrics
.
y_scale
)
;
org_dist
=
FAST_DUALPROJ
(
&
vec
)
;
}
cur_dist
=
PROJECT
(
&
exc
-
>
zp2
.
cur
[
point
]
cur_base
)
;
if
(
org_dist
)
{
if
(
old_range
)
new_dist
=
FT_MulDiv
(
org_dist
cur_range
old_range
)
;
else
{
new_dist
=
org_dist
;
}
}
else
new_dist
=
0
;
exc
-
>
func_move
(
exc
&
exc
-
>
zp2
(
FT_UShort
)
point
SUB_LONG
(
new_dist
cur_dist
)
)
;
}
Fail
:
exc
-
>
GS
.
loop
=
1
;
exc
-
>
new_top
=
exc
-
>
args
;
}
static
void
Ins_UTP
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UShort
point
;
FT_Byte
mask
;
point
=
(
FT_UShort
)
args
[
0
]
;
if
(
BOUNDS
(
point
exc
-
>
zp0
.
n_points
)
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
mask
=
0xFF
;
if
(
exc
-
>
GS
.
freeVector
.
x
!
=
0
)
mask
&
=
~
FT_CURVE_TAG_TOUCH_X
;
if
(
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
mask
&
=
~
FT_CURVE_TAG_TOUCH_Y
;
exc
-
>
zp0
.
tags
[
point
]
&
=
mask
;
}
typedef
struct
IUP_WorkerRec_
{
FT_Vector
*
orgs
;
FT_Vector
*
curs
;
FT_Vector
*
orus
;
FT_UInt
max_points
;
}
IUP_WorkerRec
*
IUP_Worker
;
static
void
_iup_worker_shift
(
IUP_Worker
worker
FT_UInt
p1
FT_UInt
p2
FT_UInt
p
)
{
FT_UInt
i
;
FT_F26Dot6
dx
;
dx
=
SUB_LONG
(
worker
-
>
curs
[
p
]
.
x
worker
-
>
orgs
[
p
]
.
x
)
;
if
(
dx
!
=
0
)
{
for
(
i
=
p1
;
i
<
p
;
i
+
+
)
worker
-
>
curs
[
i
]
.
x
=
ADD_LONG
(
worker
-
>
curs
[
i
]
.
x
dx
)
;
for
(
i
=
p
+
1
;
i
<
=
p2
;
i
+
+
)
worker
-
>
curs
[
i
]
.
x
=
ADD_LONG
(
worker
-
>
curs
[
i
]
.
x
dx
)
;
}
}
static
void
_iup_worker_interpolate
(
IUP_Worker
worker
FT_UInt
p1
FT_UInt
p2
FT_UInt
ref1
FT_UInt
ref2
)
{
FT_UInt
i
;
FT_F26Dot6
orus1
orus2
org1
org2
cur1
cur2
delta1
delta2
;
if
(
p1
>
p2
)
return
;
if
(
BOUNDS
(
ref1
worker
-
>
max_points
)
|
|
BOUNDS
(
ref2
worker
-
>
max_points
)
)
return
;
orus1
=
worker
-
>
orus
[
ref1
]
.
x
;
orus2
=
worker
-
>
orus
[
ref2
]
.
x
;
if
(
orus1
>
orus2
)
{
FT_F26Dot6
tmp_o
;
FT_UInt
tmp_r
;
tmp_o
=
orus1
;
orus1
=
orus2
;
orus2
=
tmp_o
;
tmp_r
=
ref1
;
ref1
=
ref2
;
ref2
=
tmp_r
;
}
org1
=
worker
-
>
orgs
[
ref1
]
.
x
;
org2
=
worker
-
>
orgs
[
ref2
]
.
x
;
cur1
=
worker
-
>
curs
[
ref1
]
.
x
;
cur2
=
worker
-
>
curs
[
ref2
]
.
x
;
delta1
=
SUB_LONG
(
cur1
org1
)
;
delta2
=
SUB_LONG
(
cur2
org2
)
;
if
(
cur1
=
=
cur2
|
|
orus1
=
=
orus2
)
{
for
(
i
=
p1
;
i
<
=
p2
;
i
+
+
)
{
FT_F26Dot6
x
=
worker
-
>
orgs
[
i
]
.
x
;
if
(
x
<
=
org1
)
x
=
ADD_LONG
(
x
delta1
)
;
else
if
(
x
>
=
org2
)
x
=
ADD_LONG
(
x
delta2
)
;
else
x
=
cur1
;
worker
-
>
curs
[
i
]
.
x
=
x
;
}
}
else
{
FT_Fixed
scale
=
0
;
FT_Bool
scale_valid
=
0
;
for
(
i
=
p1
;
i
<
=
p2
;
i
+
+
)
{
FT_F26Dot6
x
=
worker
-
>
orgs
[
i
]
.
x
;
if
(
x
<
=
org1
)
x
=
ADD_LONG
(
x
delta1
)
;
else
if
(
x
>
=
org2
)
x
=
ADD_LONG
(
x
delta2
)
;
else
{
if
(
!
scale_valid
)
{
scale_valid
=
1
;
scale
=
FT_DivFix
(
SUB_LONG
(
cur2
cur1
)
SUB_LONG
(
orus2
orus1
)
)
;
}
x
=
ADD_LONG
(
cur1
FT_MulFix
(
SUB_LONG
(
worker
-
>
orus
[
i
]
.
x
orus1
)
scale
)
)
;
}
worker
-
>
curs
[
i
]
.
x
=
x
;
}
}
}
static
void
Ins_IUP
(
TT_ExecContext
exc
)
{
IUP_WorkerRec
V
;
FT_Byte
mask
;
FT_UInt
first_point
;
FT_UInt
end_point
;
FT_UInt
first_touched
;
FT_UInt
cur_touched
;
FT_UInt
point
;
FT_Short
contour
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
backward_compatibility
)
{
if
(
exc
-
>
iupx_called
&
&
exc
-
>
iupy_called
)
return
;
if
(
exc
-
>
opcode
&
1
)
exc
-
>
iupx_called
=
TRUE
;
else
exc
-
>
iupy_called
=
TRUE
;
}
#
endif
if
(
exc
-
>
pts
.
n_contours
=
=
0
)
return
;
if
(
exc
-
>
opcode
&
1
)
{
mask
=
FT_CURVE_TAG_TOUCH_X
;
V
.
orgs
=
exc
-
>
pts
.
org
;
V
.
curs
=
exc
-
>
pts
.
cur
;
V
.
orus
=
exc
-
>
pts
.
orus
;
}
else
{
mask
=
FT_CURVE_TAG_TOUCH_Y
;
V
.
orgs
=
(
FT_Vector
*
)
(
(
FT_Pos
*
)
exc
-
>
pts
.
org
+
1
)
;
V
.
curs
=
(
FT_Vector
*
)
(
(
FT_Pos
*
)
exc
-
>
pts
.
cur
+
1
)
;
V
.
orus
=
(
FT_Vector
*
)
(
(
FT_Pos
*
)
exc
-
>
pts
.
orus
+
1
)
;
}
V
.
max_points
=
exc
-
>
pts
.
n_points
;
contour
=
0
;
point
=
0
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
)
{
exc
-
>
iup_called
=
TRUE
;
if
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_SKIP_IUP
)
return
;
}
#
endif
do
{
end_point
=
exc
-
>
pts
.
contours
[
contour
]
-
exc
-
>
pts
.
first_point
;
first_point
=
point
;
if
(
BOUNDS
(
end_point
exc
-
>
pts
.
n_points
)
)
end_point
=
exc
-
>
pts
.
n_points
-
1
;
while
(
point
<
=
end_point
&
&
(
exc
-
>
pts
.
tags
[
point
]
&
mask
)
=
=
0
)
point
+
+
;
if
(
point
<
=
end_point
)
{
first_touched
=
point
;
cur_touched
=
point
;
point
+
+
;
while
(
point
<
=
end_point
)
{
if
(
(
exc
-
>
pts
.
tags
[
point
]
&
mask
)
!
=
0
)
{
_iup_worker_interpolate
(
&
V
cur_touched
+
1
point
-
1
cur_touched
point
)
;
cur_touched
=
point
;
}
point
+
+
;
}
if
(
cur_touched
=
=
first_touched
)
_iup_worker_shift
(
&
V
first_point
end_point
cur_touched
)
;
else
{
_iup_worker_interpolate
(
&
V
(
FT_UShort
)
(
cur_touched
+
1
)
end_point
cur_touched
first_touched
)
;
if
(
first_touched
>
0
)
_iup_worker_interpolate
(
&
V
first_point
first_touched
-
1
cur_touched
first_touched
)
;
}
}
contour
+
+
;
}
while
(
contour
<
exc
-
>
pts
.
n_contours
)
;
}
static
void
Ins_DELTAP
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
nump
k
;
FT_UShort
A
;
FT_ULong
C
P
;
FT_Long
B
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
FT_UShort
B1
B2
;
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
ignore_x_mode
&
&
exc
-
>
iup_called
&
&
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_NO_DELTAP_AFTER_IUP
)
)
goto
Fail
;
#
endif
P
=
(
FT_ULong
)
exc
-
>
func_cur_ppem
(
exc
)
;
nump
=
(
FT_ULong
)
args
[
0
]
;
for
(
k
=
1
;
k
<
=
nump
;
k
+
+
)
{
if
(
exc
-
>
args
<
2
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Too_Few_Arguments
)
;
exc
-
>
args
=
0
;
goto
Fail
;
}
exc
-
>
args
-
=
2
;
A
=
(
FT_UShort
)
exc
-
>
stack
[
exc
-
>
args
+
1
]
;
B
=
exc
-
>
stack
[
exc
-
>
args
]
;
if
(
!
BOUNDS
(
A
exc
-
>
zp0
.
n_points
)
)
{
C
=
(
(
FT_ULong
)
B
&
0xF0
)
>
>
4
;
switch
(
exc
-
>
opcode
)
{
case
0x5D
:
break
;
case
0x71
:
C
+
=
16
;
break
;
case
0x72
:
C
+
=
32
;
break
;
}
C
+
=
exc
-
>
GS
.
delta_base
;
if
(
P
=
=
C
)
{
B
=
(
(
FT_ULong
)
B
&
0xF
)
-
8
;
if
(
B
>
=
0
)
B
+
+
;
B
*
=
1L
<
<
(
6
-
exc
-
>
GS
.
delta_shift
)
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
)
{
if
(
!
exc
-
>
ignore_x_mode
|
|
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_ALWAYS_DO_DELTAP
)
|
|
(
exc
-
>
is_composite
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
)
exc
-
>
func_move
(
exc
&
exc
-
>
zp0
A
B
)
;
else
if
(
exc
-
>
ignore_x_mode
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
{
B1
=
(
FT_UShort
)
exc
-
>
zp0
.
cur
[
A
]
.
y
;
if
(
!
exc
-
>
face
-
>
sph_compatibility_mode
&
&
(
exc
-
>
zp0
.
tags
[
A
]
&
FT_CURVE_TAG_TOUCH_Y
)
)
exc
-
>
func_move
(
exc
&
exc
-
>
zp0
A
B
)
;
else
if
(
exc
-
>
face
-
>
sph_compatibility_mode
&
&
!
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_ALWAYS_SKIP_DELTAP
)
)
{
if
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES
)
B
=
FT_PIX_ROUND
(
B1
+
B
)
-
B1
;
if
(
!
exc
-
>
iup_called
&
&
(
exc
-
>
zp0
.
tags
[
A
]
&
FT_CURVE_TAG_TOUCH_Y
)
)
exc
-
>
func_move
(
exc
&
exc
-
>
zp0
A
B
)
;
}
B2
=
(
FT_UShort
)
exc
-
>
zp0
.
cur
[
A
]
.
y
;
if
(
exc
-
>
GS
.
freeVector
.
y
!
=
0
&
&
(
(
exc
-
>
face
-
>
sph_compatibility_mode
&
&
(
B1
&
63
)
=
=
0
&
&
(
B2
&
63
)
!
=
0
)
|
|
(
(
exc
-
>
sph_tweak_flags
&
SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES_DELTAP
)
&
&
(
B1
&
63
)
!
=
0
&
&
(
B2
&
63
)
!
=
0
)
)
)
exc
-
>
func_move
(
exc
&
exc
-
>
zp0
A
NEG_LONG
(
B
)
)
;
}
}
else
#
endif
{
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
backward_compatibility
)
{
if
(
!
(
exc
-
>
iupx_called
&
&
exc
-
>
iupy_called
)
&
&
(
(
exc
-
>
is_composite
&
&
exc
-
>
GS
.
freeVector
.
y
!
=
0
)
|
|
(
exc
-
>
zp0
.
tags
[
A
]
&
FT_CURVE_TAG_TOUCH_Y
)
)
)
exc
-
>
func_move
(
exc
&
exc
-
>
zp0
A
B
)
;
}
else
#
endif
exc
-
>
func_move
(
exc
&
exc
-
>
zp0
A
B
)
;
}
}
}
else
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
}
Fail
:
exc
-
>
new_top
=
exc
-
>
args
;
}
static
void
Ins_DELTAC
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_ULong
nump
k
;
FT_ULong
A
C
P
;
FT_Long
B
;
P
=
(
FT_ULong
)
exc
-
>
func_cur_ppem
(
exc
)
;
nump
=
(
FT_ULong
)
args
[
0
]
;
for
(
k
=
1
;
k
<
=
nump
;
k
+
+
)
{
if
(
exc
-
>
args
<
2
)
{
if
(
exc
-
>
pedantic_hinting
)
exc
-
>
error
=
FT_THROW
(
Too_Few_Arguments
)
;
exc
-
>
args
=
0
;
goto
Fail
;
}
exc
-
>
args
-
=
2
;
A
=
(
FT_ULong
)
exc
-
>
stack
[
exc
-
>
args
+
1
]
;
B
=
exc
-
>
stack
[
exc
-
>
args
]
;
if
(
BOUNDSL
(
A
exc
-
>
cvtSize
)
)
{
if
(
exc
-
>
pedantic_hinting
)
{
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
return
;
}
}
else
{
C
=
(
(
FT_ULong
)
B
&
0xF0
)
>
>
4
;
switch
(
exc
-
>
opcode
)
{
case
0x73
:
break
;
case
0x74
:
C
+
=
16
;
break
;
case
0x75
:
C
+
=
32
;
break
;
}
C
+
=
exc
-
>
GS
.
delta_base
;
if
(
P
=
=
C
)
{
B
=
(
(
FT_ULong
)
B
&
0xF
)
-
8
;
if
(
B
>
=
0
)
B
+
+
;
B
*
=
1L
<
<
(
6
-
exc
-
>
GS
.
delta_shift
)
;
exc
-
>
func_move_cvt
(
exc
A
B
)
;
}
}
}
Fail
:
exc
-
>
new_top
=
exc
-
>
args
;
}
static
void
Ins_GETINFO
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_Long
K
;
TT_Driver
driver
=
(
TT_Driver
)
FT_FACE_DRIVER
(
exc
-
>
face
)
;
K
=
0
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
(
args
[
0
]
&
1
)
!
=
0
&
&
exc
-
>
subpixel_hinting
)
{
if
(
exc
-
>
ignore_x_mode
)
{
K
=
exc
-
>
rasterizer_version
;
FT_TRACE6
(
(
"
Setting
rasterizer
version
%
d
\
n
"
exc
-
>
rasterizer_version
)
)
;
}
else
K
=
TT_INTERPRETER_VERSION_38
;
}
else
#
endif
if
(
(
args
[
0
]
&
1
)
!
=
0
)
K
=
driver
-
>
interpreter_version
;
if
(
(
args
[
0
]
&
2
)
!
=
0
&
&
exc
-
>
tt_metrics
.
rotated
)
K
|
=
1
<
<
8
;
if
(
(
args
[
0
]
&
4
)
!
=
0
&
&
exc
-
>
tt_metrics
.
stretched
)
K
|
=
1
<
<
9
;
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
if
(
(
args
[
0
]
&
8
)
!
=
0
&
&
exc
-
>
face
-
>
blend
)
K
|
=
1
<
<
10
;
#
endif
if
(
(
args
[
0
]
&
32
)
!
=
0
&
&
exc
-
>
grayscale
)
K
|
=
1
<
<
12
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
subpixel_hinting_lean
)
{
if
(
(
args
[
0
]
&
64
)
!
=
0
)
K
|
=
1
<
<
13
;
if
(
(
args
[
0
]
&
256
)
!
=
0
&
&
exc
-
>
vertical_lcd_lean
)
K
|
=
1
<
<
15
;
if
(
(
args
[
0
]
&
1024
)
!
=
0
)
K
|
=
1
<
<
17
;
if
(
(
args
[
0
]
&
2048
)
!
=
0
&
&
exc
-
>
subpixel_hinting_lean
)
K
|
=
1
<
<
18
;
if
(
(
args
[
0
]
&
4096
)
!
=
0
&
&
exc
-
>
grayscale_cleartype
)
K
|
=
1
<
<
19
;
}
#
endif
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
&
&
exc
-
>
rasterizer_version
>
=
TT_INTERPRETER_VERSION_35
)
{
if
(
exc
-
>
rasterizer_version
>
=
37
)
{
if
(
(
args
[
0
]
&
64
)
!
=
0
&
&
exc
-
>
subpixel_hinting
)
K
|
=
1
<
<
13
;
if
(
(
args
[
0
]
&
128
)
!
=
0
&
&
exc
-
>
compatible_widths
)
K
|
=
1
<
<
14
;
if
(
(
args
[
0
]
&
256
)
!
=
0
&
&
exc
-
>
vertical_lcd
)
K
|
=
1
<
<
15
;
if
(
(
args
[
0
]
&
512
)
!
=
0
&
&
exc
-
>
bgr
)
K
|
=
1
<
<
16
;
if
(
exc
-
>
rasterizer_version
>
=
38
)
{
if
(
(
args
[
0
]
&
1024
)
!
=
0
&
&
exc
-
>
subpixel_positioned
)
K
|
=
1
<
<
17
;
if
(
(
args
[
0
]
&
2048
)
!
=
0
&
&
exc
-
>
symmetrical_smoothing
)
K
|
=
1
<
<
18
;
if
(
(
args
[
0
]
&
4096
)
!
=
0
&
&
exc
-
>
gray_cleartype
)
K
|
=
1
<
<
19
;
}
}
}
#
endif
args
[
0
]
=
K
;
}
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
static
void
Ins_GETVARIATION
(
TT_ExecContext
exc
FT_Long
*
args
)
{
FT_UInt
num_axes
=
exc
-
>
face
-
>
blend
-
>
num_axis
;
FT_Fixed
*
coords
=
exc
-
>
face
-
>
blend
-
>
normalizedcoords
;
FT_UInt
i
;
if
(
BOUNDS
(
num_axes
exc
-
>
stackSize
+
1
-
exc
-
>
top
)
)
{
exc
-
>
error
=
FT_THROW
(
Stack_Overflow
)
;
return
;
}
if
(
coords
)
{
for
(
i
=
0
;
i
<
num_axes
;
i
+
+
)
args
[
i
]
=
coords
[
i
]
>
>
2
;
}
else
{
for
(
i
=
0
;
i
<
num_axes
;
i
+
+
)
args
[
i
]
=
0
;
}
}
static
void
Ins_GETDATA
(
FT_Long
*
args
)
{
args
[
0
]
=
17
;
}
#
endif
static
void
Ins_UNKNOWN
(
TT_ExecContext
exc
)
{
TT_DefRecord
*
def
=
exc
-
>
IDefs
;
TT_DefRecord
*
limit
=
def
+
exc
-
>
numIDefs
;
for
(
;
def
<
limit
;
def
+
+
)
{
if
(
(
FT_Byte
)
def
-
>
opc
=
=
exc
-
>
opcode
&
&
def
-
>
active
)
{
TT_CallRec
*
call
;
if
(
exc
-
>
callTop
>
=
exc
-
>
callSize
)
{
exc
-
>
error
=
FT_THROW
(
Stack_Overflow
)
;
return
;
}
call
=
exc
-
>
callStack
+
exc
-
>
callTop
+
+
;
call
-
>
Caller_Range
=
exc
-
>
curRange
;
call
-
>
Caller_IP
=
exc
-
>
IP
+
1
;
call
-
>
Cur_Count
=
1
;
call
-
>
Def
=
def
;
Ins_Goto_CodeRange
(
exc
def
-
>
range
def
-
>
start
)
;
exc
-
>
step_ins
=
FALSE
;
return
;
}
}
exc
-
>
error
=
FT_THROW
(
Invalid_Opcode
)
;
}
FT_EXPORT_DEF
(
FT_Error
)
TT_RunIns
(
TT_ExecContext
exc
)
{
FT_ULong
ins_counter
=
0
;
FT_ULong
num_twilight_points
;
FT_UShort
i
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
FT_Byte
opcode_pattern
[
1
]
[
2
]
=
{
{
0x06
0x7D
}
}
;
FT_UShort
opcode_patterns
=
1
;
FT_UShort
opcode_pointer
[
1
]
=
{
0
}
;
FT_UShort
opcode_size
[
1
]
=
{
1
}
;
#
endif
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
exc
-
>
iup_called
=
FALSE
;
#
endif
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
if
(
SUBPIXEL_HINTING_MINIMAL
&
&
exc
-
>
subpixel_hinting_lean
&
&
!
FT_IS_TRICKY
(
&
exc
-
>
face
-
>
root
)
)
exc
-
>
backward_compatibility
=
!
(
exc
-
>
GS
.
instruct_control
&
4
)
;
else
exc
-
>
backward_compatibility
=
FALSE
;
exc
-
>
iupx_called
=
FALSE
;
exc
-
>
iupy_called
=
FALSE
;
#
endif
num_twilight_points
=
FT_MAX
(
30
2
*
(
exc
-
>
pts
.
n_points
+
exc
-
>
cvtSize
)
)
;
if
(
exc
-
>
twilight
.
n_points
>
num_twilight_points
)
{
if
(
num_twilight_points
>
0xFFFFU
)
num_twilight_points
=
0xFFFFU
;
FT_TRACE5
(
(
"
TT_RunIns
:
Resetting
number
of
twilight
points
\
n
"
"
from
%
d
to
the
more
reasonable
value
%
d
\
n
"
exc
-
>
twilight
.
n_points
num_twilight_points
)
)
;
exc
-
>
twilight
.
n_points
=
(
FT_UShort
)
num_twilight_points
;
}
exc
-
>
loopcall_counter
=
0
;
exc
-
>
neg_jump_counter
=
0
;
if
(
exc
-
>
pts
.
n_points
)
exc
-
>
loopcall_counter_max
=
FT_MAX
(
50
10
*
exc
-
>
pts
.
n_points
)
+
FT_MAX
(
50
exc
-
>
cvtSize
/
10
)
;
else
exc
-
>
loopcall_counter_max
=
300
+
8
*
exc
-
>
cvtSize
;
if
(
exc
-
>
loopcall_counter_max
>
100
*
(
FT_ULong
)
exc
-
>
face
-
>
root
.
num_glyphs
)
exc
-
>
loopcall_counter_max
=
100
*
(
FT_ULong
)
exc
-
>
face
-
>
root
.
num_glyphs
;
FT_TRACE5
(
(
"
TT_RunIns
:
Limiting
total
number
of
loops
in
LOOPCALL
"
"
to
%
d
\
n
"
exc
-
>
loopcall_counter_max
)
)
;
exc
-
>
neg_jump_counter_max
=
exc
-
>
loopcall_counter_max
;
FT_TRACE5
(
(
"
TT_RunIns
:
Limiting
total
number
of
backward
jumps
"
"
to
%
d
\
n
"
exc
-
>
neg_jump_counter_max
)
)
;
exc
-
>
tt_metrics
.
ratio
=
0
;
if
(
exc
-
>
metrics
.
x_ppem
!
=
exc
-
>
metrics
.
y_ppem
)
{
exc
-
>
func_cur_ppem
=
Current_Ppem_Stretched
;
exc
-
>
func_read_cvt
=
Read_CVT_Stretched
;
exc
-
>
func_write_cvt
=
Write_CVT_Stretched
;
exc
-
>
func_move_cvt
=
Move_CVT_Stretched
;
}
else
{
exc
-
>
func_cur_ppem
=
Current_Ppem
;
exc
-
>
func_read_cvt
=
Read_CVT
;
exc
-
>
func_write_cvt
=
Write_CVT
;
exc
-
>
func_move_cvt
=
Move_CVT
;
}
Compute_Funcs
(
exc
)
;
Compute_Round
(
exc
(
FT_Byte
)
exc
-
>
GS
.
round_state
)
;
do
{
exc
-
>
opcode
=
exc
-
>
code
[
exc
-
>
IP
]
;
#
ifdef
FT_DEBUG_LEVEL_TRACE
{
FT_Long
cnt
=
FT_MIN
(
8
exc
-
>
top
)
;
FT_Long
n
;
FT_TRACE6
(
(
"
"
)
)
;
FT_TRACE7
(
(
"
%
06d
"
exc
-
>
IP
)
)
;
FT_TRACE6
(
(
"
%
s
"
opcode_name
[
exc
-
>
opcode
]
+
2
)
)
;
FT_TRACE7
(
(
"
%
*
s
"
*
opcode_name
[
exc
-
>
opcode
]
=
=
'
A
'
?
2
:
12
-
(
*
opcode_name
[
exc
-
>
opcode
]
-
'
0
'
)
"
#
"
)
)
;
for
(
n
=
1
;
n
<
=
cnt
;
n
+
+
)
FT_TRACE7
(
(
"
%
d
"
exc
-
>
stack
[
exc
-
>
top
-
n
]
)
)
;
FT_TRACE6
(
(
"
\
n
"
)
)
;
}
#
endif
if
(
(
exc
-
>
length
=
opcode_length
[
exc
-
>
opcode
]
)
<
0
)
{
if
(
exc
-
>
IP
+
1
>
=
exc
-
>
codeSize
)
goto
LErrorCodeOverflow_
;
exc
-
>
length
=
2
-
exc
-
>
length
*
exc
-
>
code
[
exc
-
>
IP
+
1
]
;
}
if
(
exc
-
>
IP
+
exc
-
>
length
>
exc
-
>
codeSize
)
goto
LErrorCodeOverflow_
;
exc
-
>
args
=
exc
-
>
top
-
(
Pop_Push_Count
[
exc
-
>
opcode
]
>
>
4
)
;
if
(
exc
-
>
args
<
0
)
{
if
(
exc
-
>
pedantic_hinting
)
{
exc
-
>
error
=
FT_THROW
(
Too_Few_Arguments
)
;
goto
LErrorLabel_
;
}
for
(
i
=
0
;
i
<
Pop_Push_Count
[
exc
-
>
opcode
]
>
>
4
;
i
+
+
)
exc
-
>
stack
[
i
]
=
0
;
exc
-
>
args
=
0
;
}
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
if
(
exc
-
>
opcode
=
=
0x91
)
{
if
(
exc
-
>
face
-
>
blend
)
exc
-
>
new_top
=
exc
-
>
args
+
exc
-
>
face
-
>
blend
-
>
num_axis
;
}
else
#
endif
exc
-
>
new_top
=
exc
-
>
args
+
(
Pop_Push_Count
[
exc
-
>
opcode
]
&
15
)
;
if
(
exc
-
>
new_top
>
exc
-
>
stackSize
)
{
exc
-
>
error
=
FT_THROW
(
Stack_Overflow
)
;
goto
LErrorLabel_
;
}
exc
-
>
step_ins
=
TRUE
;
exc
-
>
error
=
FT_Err_Ok
;
#
ifdef
TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
if
(
SUBPIXEL_HINTING_INFINALITY
)
{
for
(
i
=
0
;
i
<
opcode_patterns
;
i
+
+
)
{
if
(
opcode_pointer
[
i
]
<
opcode_size
[
i
]
&
&
exc
-
>
opcode
=
=
opcode_pattern
[
i
]
[
opcode_pointer
[
i
]
]
)
{
opcode_pointer
[
i
]
+
=
1
;
if
(
opcode_pointer
[
i
]
=
=
opcode_size
[
i
]
)
{
FT_TRACE6
(
(
"
sph
:
opcode
ptrn
:
%
d
%
s
%
s
\
n
"
i
exc
-
>
face
-
>
root
.
family_name
exc
-
>
face
-
>
root
.
style_name
)
)
;
switch
(
i
)
{
case
0
:
break
;
}
opcode_pointer
[
i
]
=
0
;
}
}
else
opcode_pointer
[
i
]
=
0
;
}
}
#
endif
{
FT_Long
*
args
=
exc
-
>
stack
+
exc
-
>
args
;
FT_Byte
opcode
=
exc
-
>
opcode
;
switch
(
opcode
)
{
case
0x00
:
case
0x01
:
case
0x02
:
case
0x03
:
case
0x04
:
case
0x05
:
Ins_SxyTCA
(
exc
)
;
break
;
case
0x06
:
case
0x07
:
Ins_SPVTL
(
exc
args
)
;
break
;
case
0x08
:
case
0x09
:
Ins_SFVTL
(
exc
args
)
;
break
;
case
0x0A
:
Ins_SPVFS
(
exc
args
)
;
break
;
case
0x0B
:
Ins_SFVFS
(
exc
args
)
;
break
;
case
0x0C
:
Ins_GPV
(
exc
args
)
;
break
;
case
0x0D
:
Ins_GFV
(
exc
args
)
;
break
;
case
0x0E
:
Ins_SFVTPV
(
exc
)
;
break
;
case
0x0F
:
Ins_ISECT
(
exc
args
)
;
break
;
case
0x10
:
Ins_SRP0
(
exc
args
)
;
break
;
case
0x11
:
Ins_SRP1
(
exc
args
)
;
break
;
case
0x12
:
Ins_SRP2
(
exc
args
)
;
break
;
case
0x13
:
Ins_SZP0
(
exc
args
)
;
break
;
case
0x14
:
Ins_SZP1
(
exc
args
)
;
break
;
case
0x15
:
Ins_SZP2
(
exc
args
)
;
break
;
case
0x16
:
Ins_SZPS
(
exc
args
)
;
break
;
case
0x17
:
Ins_SLOOP
(
exc
args
)
;
break
;
case
0x18
:
Ins_RTG
(
exc
)
;
break
;
case
0x19
:
Ins_RTHG
(
exc
)
;
break
;
case
0x1A
:
Ins_SMD
(
exc
args
)
;
break
;
case
0x1B
:
Ins_ELSE
(
exc
)
;
break
;
case
0x1C
:
Ins_JMPR
(
exc
args
)
;
break
;
case
0x1D
:
Ins_SCVTCI
(
exc
args
)
;
break
;
case
0x1E
:
Ins_SSWCI
(
exc
args
)
;
break
;
case
0x1F
:
Ins_SSW
(
exc
args
)
;
break
;
case
0x20
:
Ins_DUP
(
args
)
;
break
;
case
0x21
:
Ins_POP
(
)
;
break
;
case
0x22
:
Ins_CLEAR
(
exc
)
;
break
;
case
0x23
:
Ins_SWAP
(
args
)
;
break
;
case
0x24
:
Ins_DEPTH
(
exc
args
)
;
break
;
case
0x25
:
Ins_CINDEX
(
exc
args
)
;
break
;
case
0x26
:
Ins_MINDEX
(
exc
args
)
;
break
;
case
0x27
:
Ins_ALIGNPTS
(
exc
args
)
;
break
;
case
0x28
:
Ins_UNKNOWN
(
exc
)
;
break
;
case
0x29
:
Ins_UTP
(
exc
args
)
;
break
;
case
0x2A
:
Ins_LOOPCALL
(
exc
args
)
;
break
;
case
0x2B
:
Ins_CALL
(
exc
args
)
;
break
;
case
0x2C
:
Ins_FDEF
(
exc
args
)
;
break
;
case
0x2D
:
Ins_ENDF
(
exc
)
;
break
;
case
0x2E
:
case
0x2F
:
Ins_MDAP
(
exc
args
)
;
break
;
case
0x30
:
case
0x31
:
Ins_IUP
(
exc
)
;
break
;
case
0x32
:
case
0x33
:
Ins_SHP
(
exc
)
;
break
;
case
0x34
:
case
0x35
:
Ins_SHC
(
exc
args
)
;
break
;
case
0x36
:
case
0x37
:
Ins_SHZ
(
exc
args
)
;
break
;
case
0x38
:
Ins_SHPIX
(
exc
args
)
;
break
;
case
0x39
:
Ins_IP
(
exc
)
;
break
;
case
0x3A
:
case
0x3B
:
Ins_MSIRP
(
exc
args
)
;
break
;
case
0x3C
:
Ins_ALIGNRP
(
exc
)
;
break
;
case
0x3D
:
Ins_RTDG
(
exc
)
;
break
;
case
0x3E
:
case
0x3F
:
Ins_MIAP
(
exc
args
)
;
break
;
case
0x40
:
Ins_NPUSHB
(
exc
args
)
;
break
;
case
0x41
:
Ins_NPUSHW
(
exc
args
)
;
break
;
case
0x42
:
Ins_WS
(
exc
args
)
;
break
;
case
0x43
:
Ins_RS
(
exc
args
)
;
break
;
case
0x44
:
Ins_WCVTP
(
exc
args
)
;
break
;
case
0x45
:
Ins_RCVT
(
exc
args
)
;
break
;
case
0x46
:
case
0x47
:
Ins_GC
(
exc
args
)
;
break
;
case
0x48
:
Ins_SCFS
(
exc
args
)
;
break
;
case
0x49
:
case
0x4A
:
Ins_MD
(
exc
args
)
;
break
;
case
0x4B
:
Ins_MPPEM
(
exc
args
)
;
break
;
case
0x4C
:
Ins_MPS
(
exc
args
)
;
break
;
case
0x4D
:
Ins_FLIPON
(
exc
)
;
break
;
case
0x4E
:
Ins_FLIPOFF
(
exc
)
;
break
;
case
0x4F
:
Ins_DEBUG
(
exc
)
;
break
;
case
0x50
:
Ins_LT
(
args
)
;
break
;
case
0x51
:
Ins_LTEQ
(
args
)
;
break
;
case
0x52
:
Ins_GT
(
args
)
;
break
;
case
0x53
:
Ins_GTEQ
(
args
)
;
break
;
case
0x54
:
Ins_EQ
(
args
)
;
break
;
case
0x55
:
Ins_NEQ
(
args
)
;
break
;
case
0x56
:
Ins_ODD
(
exc
args
)
;
break
;
case
0x57
:
Ins_EVEN
(
exc
args
)
;
break
;
case
0x58
:
Ins_IF
(
exc
args
)
;
break
;
case
0x59
:
Ins_EIF
(
)
;
break
;
case
0x5A
:
Ins_AND
(
args
)
;
break
;
case
0x5B
:
Ins_OR
(
args
)
;
break
;
case
0x5C
:
Ins_NOT
(
args
)
;
break
;
case
0x5D
:
Ins_DELTAP
(
exc
args
)
;
break
;
case
0x5E
:
Ins_SDB
(
exc
args
)
;
break
;
case
0x5F
:
Ins_SDS
(
exc
args
)
;
break
;
case
0x60
:
Ins_ADD
(
args
)
;
break
;
case
0x61
:
Ins_SUB
(
args
)
;
break
;
case
0x62
:
Ins_DIV
(
exc
args
)
;
break
;
case
0x63
:
Ins_MUL
(
args
)
;
break
;
case
0x64
:
Ins_ABS
(
args
)
;
break
;
case
0x65
:
Ins_NEG
(
args
)
;
break
;
case
0x66
:
Ins_FLOOR
(
args
)
;
break
;
case
0x67
:
Ins_CEILING
(
args
)
;
break
;
case
0x68
:
case
0x69
:
case
0x6A
:
case
0x6B
:
Ins_ROUND
(
exc
args
)
;
break
;
case
0x6C
:
case
0x6D
:
case
0x6E
:
case
0x6F
:
Ins_NROUND
(
exc
args
)
;
break
;
case
0x70
:
Ins_WCVTF
(
exc
args
)
;
break
;
case
0x71
:
case
0x72
:
Ins_DELTAP
(
exc
args
)
;
break
;
case
0x73
:
case
0x74
:
case
0x75
:
Ins_DELTAC
(
exc
args
)
;
break
;
case
0x76
:
Ins_SROUND
(
exc
args
)
;
break
;
case
0x77
:
Ins_S45ROUND
(
exc
args
)
;
break
;
case
0x78
:
Ins_JROT
(
exc
args
)
;
break
;
case
0x79
:
Ins_JROF
(
exc
args
)
;
break
;
case
0x7A
:
Ins_ROFF
(
exc
)
;
break
;
case
0x7B
:
Ins_UNKNOWN
(
exc
)
;
break
;
case
0x7C
:
Ins_RUTG
(
exc
)
;
break
;
case
0x7D
:
Ins_RDTG
(
exc
)
;
break
;
case
0x7E
:
Ins_SANGW
(
)
;
break
;
case
0x7F
:
Ins_AA
(
)
;
break
;
case
0x80
:
Ins_FLIPPT
(
exc
)
;
break
;
case
0x81
:
Ins_FLIPRGON
(
exc
args
)
;
break
;
case
0x82
:
Ins_FLIPRGOFF
(
exc
args
)
;
break
;
case
0x83
:
case
0x84
:
Ins_UNKNOWN
(
exc
)
;
break
;
case
0x85
:
Ins_SCANCTRL
(
exc
args
)
;
break
;
case
0x86
:
case
0x87
:
Ins_SDPVTL
(
exc
args
)
;
break
;
case
0x88
:
Ins_GETINFO
(
exc
args
)
;
break
;
case
0x89
:
Ins_IDEF
(
exc
args
)
;
break
;
case
0x8A
:
Ins_ROLL
(
args
)
;
break
;
case
0x8B
:
Ins_MAX
(
args
)
;
break
;
case
0x8C
:
Ins_MIN
(
args
)
;
break
;
case
0x8D
:
Ins_SCANTYPE
(
exc
args
)
;
break
;
case
0x8E
:
Ins_INSTCTRL
(
exc
args
)
;
break
;
case
0x8F
:
case
0x90
:
Ins_UNKNOWN
(
exc
)
;
break
;
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
case
0x91
:
if
(
exc
-
>
face
-
>
blend
)
Ins_GETVARIATION
(
exc
args
)
;
else
Ins_UNKNOWN
(
exc
)
;
break
;
case
0x92
:
if
(
exc
-
>
face
-
>
blend
)
Ins_GETDATA
(
args
)
;
else
Ins_UNKNOWN
(
exc
)
;
break
;
#
endif
default
:
if
(
opcode
>
=
0xE0
)
Ins_MIRP
(
exc
args
)
;
else
if
(
opcode
>
=
0xC0
)
Ins_MDRP
(
exc
args
)
;
else
if
(
opcode
>
=
0xB8
)
Ins_PUSHW
(
exc
args
)
;
else
if
(
opcode
>
=
0xB0
)
Ins_PUSHB
(
exc
args
)
;
else
Ins_UNKNOWN
(
exc
)
;
}
}
if
(
exc
-
>
error
)
{
switch
(
exc
-
>
error
)
{
case
FT_ERR
(
Invalid_Opcode
)
:
{
TT_DefRecord
*
def
=
exc
-
>
IDefs
;
TT_DefRecord
*
limit
=
def
+
exc
-
>
numIDefs
;
for
(
;
def
<
limit
;
def
+
+
)
{
if
(
def
-
>
active
&
&
exc
-
>
opcode
=
=
(
FT_Byte
)
def
-
>
opc
)
{
TT_CallRec
*
callrec
;
if
(
exc
-
>
callTop
>
=
exc
-
>
callSize
)
{
exc
-
>
error
=
FT_THROW
(
Invalid_Reference
)
;
goto
LErrorLabel_
;
}
callrec
=
&
exc
-
>
callStack
[
exc
-
>
callTop
]
;
callrec
-
>
Caller_Range
=
exc
-
>
curRange
;
callrec
-
>
Caller_IP
=
exc
-
>
IP
+
1
;
callrec
-
>
Cur_Count
=
1
;
callrec
-
>
Def
=
def
;
if
(
Ins_Goto_CodeRange
(
exc
def
-
>
range
def
-
>
start
)
=
=
FAILURE
)
goto
LErrorLabel_
;
goto
LSuiteLabel_
;
}
}
}
exc
-
>
error
=
FT_THROW
(
Invalid_Opcode
)
;
goto
LErrorLabel_
;
#
if
0
break
;
#
endif
default
:
goto
LErrorLabel_
;
#
if
0
break
;
#
endif
}
}
exc
-
>
top
=
exc
-
>
new_top
;
if
(
exc
-
>
step_ins
)
exc
-
>
IP
+
=
exc
-
>
length
;
if
(
+
+
ins_counter
>
TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES
)
return
FT_THROW
(
Execution_Too_Long
)
;
LSuiteLabel_
:
if
(
exc
-
>
IP
>
=
exc
-
>
codeSize
)
{
if
(
exc
-
>
callTop
>
0
)
{
exc
-
>
error
=
FT_THROW
(
Code_Overflow
)
;
goto
LErrorLabel_
;
}
else
goto
LNo_Error_
;
}
}
while
(
!
exc
-
>
instruction_trap
)
;
LNo_Error_
:
FT_TRACE4
(
(
"
%
d
instruction
%
s
executed
\
n
"
ins_counter
ins_counter
=
=
1
?
"
"
:
"
s
"
)
)
;
return
FT_Err_Ok
;
LErrorCodeOverflow_
:
exc
-
>
error
=
FT_THROW
(
Code_Overflow
)
;
LErrorLabel_
:
if
(
exc
-
>
error
&
&
!
exc
-
>
instruction_trap
)
FT_TRACE1
(
(
"
The
interpreter
returned
error
0x
%
x
\
n
"
exc
-
>
error
)
)
;
return
exc
-
>
error
;
}
#
else
typedef
int
_tt_interp_dummy
;
#
endif
