#
include
<
ft2build
.
h
>
#
include
FT_FREETYPE_H
#
include
FT_ADVANCES_H
#
include
"
afglobal
.
h
"
#
include
"
aftypes
.
h
"
#
include
"
afshaper
.
h
"
#
ifdef
FT_CONFIG_OPTION_USE_HARFBUZZ
#
undef
FT_COMPONENT
#
define
FT_COMPONENT
trace_afshaper
#
undef
COVERAGE
#
define
COVERAGE
(
name
NAME
description
\
tag1
tag2
tag3
tag4
)
\
static
const
hb_tag_t
name
#
#
_coverage
[
]
=
\
{
\
HB_TAG
(
tag1
tag2
tag3
tag4
)
\
HB_TAG_NONE
\
}
;
#
include
"
afcover
.
h
"
#
undef
COVERAGE
#
define
COVERAGE
(
name
NAME
description
\
tag1
tag2
tag3
tag4
)
\
name
#
#
_coverage
static
const
hb_tag_t
*
coverages
[
]
=
{
#
include
"
afcover
.
h
"
NULL
}
;
#
undef
SCRIPT
#
define
SCRIPT
(
s
S
d
h
H
ss
)
h
static
const
hb_script_t
scripts
[
]
=
{
#
include
"
afscript
.
h
"
}
;
FT_Error
af_shaper_get_coverage
(
AF_FaceGlobals
globals
AF_StyleClass
style_class
FT_UShort
*
gstyles
FT_Bool
default_script
)
{
hb_face_t
*
face
;
hb_set_t
*
gsub_lookups
=
NULL
;
hb_set_t
*
gsub_glyphs
=
NULL
;
hb_set_t
*
gpos_lookups
=
NULL
;
hb_set_t
*
gpos_glyphs
=
NULL
;
hb_script_t
script
;
const
hb_tag_t
*
coverage_tags
;
hb_tag_t
script_tags
[
]
=
{
HB_TAG_NONE
HB_TAG_NONE
HB_TAG_NONE
HB_TAG_NONE
}
;
hb_codepoint_t
idx
;
#
ifdef
FT_DEBUG_LEVEL_TRACE
int
count
;
#
endif
if
(
!
globals
|
|
!
style_class
|
|
!
gstyles
)
return
FT_THROW
(
Invalid_Argument
)
;
face
=
hb_font_get_face
(
globals
-
>
hb_font
)
;
coverage_tags
=
coverages
[
style_class
-
>
coverage
]
;
script
=
scripts
[
style_class
-
>
script
]
;
hb_ot_tags_from_script
(
script
&
script_tags
[
0
]
&
script_tags
[
1
]
)
;
if
(
default_script
)
{
if
(
script_tags
[
0
]
=
=
HB_TAG_NONE
)
script_tags
[
0
]
=
HB_OT_TAG_DEFAULT_SCRIPT
;
else
{
if
(
script_tags
[
1
]
=
=
HB_TAG_NONE
)
script_tags
[
1
]
=
HB_OT_TAG_DEFAULT_SCRIPT
;
else
if
(
script_tags
[
1
]
!
=
HB_OT_TAG_DEFAULT_SCRIPT
)
script_tags
[
2
]
=
HB_OT_TAG_DEFAULT_SCRIPT
;
}
}
else
{
if
(
script_tags
[
0
]
=
=
HB_OT_TAG_DEFAULT_SCRIPT
)
goto
Exit
;
if
(
script_tags
[
1
]
=
=
HB_OT_TAG_DEFAULT_SCRIPT
)
script_tags
[
1
]
=
HB_TAG_NONE
;
}
gsub_lookups
=
hb_set_create
(
)
;
hb_ot_layout_collect_lookups
(
face
HB_OT_TAG_GSUB
script_tags
NULL
coverage_tags
gsub_lookups
)
;
if
(
hb_set_is_empty
(
gsub_lookups
)
)
goto
Exit
;
FT_TRACE4
(
(
"
GSUB
lookups
(
style
%
s
'
)
:
\
n
"
"
"
af_style_names
[
style_class
-
>
style
]
)
)
;
#
ifdef
FT_DEBUG_LEVEL_TRACE
count
=
0
;
#
endif
gsub_glyphs
=
hb_set_create
(
)
;
for
(
idx
=
HB_SET_VALUE_INVALID
;
hb_set_next
(
gsub_lookups
&
idx
)
;
)
{
#
ifdef
FT_DEBUG_LEVEL_TRACE
FT_TRACE4
(
(
"
%
d
"
idx
)
)
;
count
+
+
;
#
endif
hb_ot_layout_lookup_collect_glyphs
(
face
HB_OT_TAG_GSUB
idx
NULL
NULL
NULL
gsub_glyphs
)
;
}
#
ifdef
FT_DEBUG_LEVEL_TRACE
if
(
!
count
)
FT_TRACE4
(
(
"
(
none
)
"
)
)
;
FT_TRACE4
(
(
"
\
n
\
n
"
)
)
;
#
endif
FT_TRACE4
(
(
"
GPOS
lookups
(
style
%
s
'
)
:
\
n
"
"
"
af_style_names
[
style_class
-
>
style
]
)
)
;
gpos_lookups
=
hb_set_create
(
)
;
hb_ot_layout_collect_lookups
(
face
HB_OT_TAG_GPOS
script_tags
NULL
coverage_tags
gpos_lookups
)
;
#
ifdef
FT_DEBUG_LEVEL_TRACE
count
=
0
;
#
endif
gpos_glyphs
=
hb_set_create
(
)
;
for
(
idx
=
HB_SET_VALUE_INVALID
;
hb_set_next
(
gpos_lookups
&
idx
)
;
)
{
#
ifdef
FT_DEBUG_LEVEL_TRACE
FT_TRACE4
(
(
"
%
d
"
idx
)
)
;
count
+
+
;
#
endif
hb_ot_layout_lookup_collect_glyphs
(
face
HB_OT_TAG_GPOS
idx
NULL
gpos_glyphs
NULL
NULL
)
;
}
#
ifdef
FT_DEBUG_LEVEL_TRACE
if
(
!
count
)
FT_TRACE4
(
(
"
(
none
)
"
)
)
;
FT_TRACE4
(
(
"
\
n
\
n
"
)
)
;
#
endif
if
(
style_class
-
>
coverage
!
=
AF_COVERAGE_DEFAULT
)
{
AF_Blue_Stringset
bss
=
style_class
-
>
blue_stringset
;
const
AF_Blue_StringRec
*
bs
=
&
af_blue_stringsets
[
bss
]
;
FT_Bool
found
=
0
;
for
(
;
bs
-
>
string
!
=
AF_BLUE_STRING_MAX
;
bs
+
+
)
{
const
char
*
p
=
&
af_blue_strings
[
bs
-
>
string
]
;
while
(
*
p
)
{
hb_codepoint_t
ch
;
GET_UTF8_CHAR
(
ch
p
)
;
for
(
idx
=
HB_SET_VALUE_INVALID
;
hb_set_next
(
gsub_lookups
&
idx
)
;
)
{
hb_codepoint_t
gidx
=
FT_Get_Char_Index
(
globals
-
>
face
ch
)
;
if
(
hb_ot_layout_lookup_would_substitute
(
face
idx
&
gidx
1
1
)
)
{
found
=
1
;
break
;
}
}
}
}
if
(
!
found
)
{
FT_TRACE4
(
(
"
no
blue
characters
found
;
style
skipped
\
n
"
)
)
;
goto
Exit
;
}
}
if
(
style_class
-
>
coverage
!
=
AF_COVERAGE_DEFAULT
)
hb_set_subtract
(
gsub_glyphs
gpos_glyphs
)
;
#
ifdef
FT_DEBUG_LEVEL_TRACE
FT_TRACE4
(
(
"
glyphs
without
GPOS
data
(
*
'
means
already
assigned
)
"
)
)
;
count
=
0
;
#
endif
for
(
idx
=
HB_SET_VALUE_INVALID
;
hb_set_next
(
gsub_glyphs
&
idx
)
;
)
{
#
ifdef
FT_DEBUG_LEVEL_TRACE
if
(
!
(
count
%
10
)
)
FT_TRACE4
(
(
"
\
n
"
"
"
)
)
;
FT_TRACE4
(
(
"
%
d
"
idx
)
)
;
count
+
+
;
#
endif
if
(
idx
>
=
(
hb_codepoint_t
)
globals
-
>
glyph_count
)
continue
;
if
(
gstyles
[
idx
]
=
=
AF_STYLE_UNASSIGNED
)
gstyles
[
idx
]
=
(
FT_UShort
)
style_class
-
>
style
;
#
ifdef
FT_DEBUG_LEVEL_TRACE
else
FT_TRACE4
(
(
"
*
"
)
)
;
#
endif
}
#
ifdef
FT_DEBUG_LEVEL_TRACE
if
(
!
count
)
FT_TRACE4
(
(
"
\
n
"
"
(
none
)
"
)
)
;
FT_TRACE4
(
(
"
\
n
\
n
"
)
)
;
#
endif
Exit
:
hb_set_destroy
(
gsub_lookups
)
;
hb_set_destroy
(
gsub_glyphs
)
;
hb_set_destroy
(
gpos_lookups
)
;
hb_set_destroy
(
gpos_glyphs
)
;
return
FT_Err_Ok
;
}
#
undef
COVERAGE
#
define
COVERAGE
(
name
NAME
description
\
tag1
tag2
tag3
tag4
)
\
static
const
hb_feature_t
name
#
#
_feature
[
]
=
\
{
\
{
\
HB_TAG
(
tag1
tag2
tag3
tag4
)
\
1
0
(
unsigned
int
)
-
1
\
}
\
}
;
#
include
"
afcover
.
h
"
#
undef
COVERAGE
#
define
COVERAGE
(
name
NAME
description
\
tag1
tag2
tag3
tag4
)
\
name
#
#
_feature
static
const
hb_feature_t
*
features
[
]
=
{
#
include
"
afcover
.
h
"
NULL
}
;
void
*
af_shaper_buf_create
(
FT_Face
face
)
{
FT_UNUSED
(
face
)
;
return
(
void
*
)
hb_buffer_create
(
)
;
}
void
af_shaper_buf_destroy
(
FT_Face
face
void
*
buf
)
{
FT_UNUSED
(
face
)
;
hb_buffer_destroy
(
(
hb_buffer_t
*
)
buf
)
;
}
const
char
*
af_shaper_get_cluster
(
const
char
*
p
AF_StyleMetrics
metrics
void
*
buf_
unsigned
int
*
count
)
{
AF_StyleClass
style_class
;
const
hb_feature_t
*
feature
;
FT_Int
upem
;
const
char
*
q
;
int
len
;
hb_buffer_t
*
buf
=
(
hb_buffer_t
*
)
buf_
;
hb_font_t
*
font
;
hb_codepoint_t
dummy
;
upem
=
(
FT_Int
)
metrics
-
>
globals
-
>
face
-
>
units_per_EM
;
style_class
=
metrics
-
>
style_class
;
feature
=
features
[
style_class
-
>
coverage
]
;
font
=
metrics
-
>
globals
-
>
hb_font
;
hb_font_set_scale
(
font
upem
upem
)
;
while
(
*
p
=
=
'
'
)
p
+
+
;
q
=
p
;
while
(
!
(
*
q
=
=
'
'
|
|
*
q
=
=
'
\
0
'
)
)
GET_UTF8_CHAR
(
dummy
q
)
;
len
=
(
int
)
(
q
-
p
)
;
hb_buffer_clear_contents
(
buf
)
;
hb_buffer_add_utf8
(
buf
p
len
0
len
)
;
hb_buffer_guess_segment_properties
(
buf
)
;
hb_shape
(
font
buf
feature
feature
?
1
:
0
)
;
if
(
feature
)
{
hb_buffer_t
*
hb_buf
=
metrics
-
>
globals
-
>
hb_buf
;
unsigned
int
gcount
;
hb_glyph_info_t
*
ginfo
;
unsigned
int
hb_gcount
;
hb_glyph_info_t
*
hb_ginfo
;
hb_buffer_clear_contents
(
hb_buf
)
;
hb_buffer_add_utf8
(
hb_buf
p
len
0
len
)
;
hb_buffer_guess_segment_properties
(
hb_buf
)
;
hb_shape
(
font
hb_buf
NULL
0
)
;
ginfo
=
hb_buffer_get_glyph_infos
(
buf
&
gcount
)
;
hb_ginfo
=
hb_buffer_get_glyph_infos
(
hb_buf
&
hb_gcount
)
;
if
(
gcount
=
=
hb_gcount
)
{
unsigned
int
i
;
for
(
i
=
0
;
i
<
gcount
;
i
+
+
)
if
(
ginfo
[
i
]
.
codepoint
!
=
hb_ginfo
[
i
]
.
codepoint
)
break
;
if
(
i
=
=
gcount
)
{
hb_buffer_clear_contents
(
buf
)
;
}
}
}
*
count
=
hb_buffer_get_length
(
buf
)
;
#
ifdef
FT_DEBUG_LEVEL_TRACE
if
(
feature
&
&
*
count
>
1
)
FT_TRACE1
(
(
"
af_shaper_get_cluster
:
"
"
input
character
mapped
to
multiple
glyphs
\
n
"
)
)
;
#
endif
return
q
;
}
FT_ULong
af_shaper_get_elem
(
AF_StyleMetrics
metrics
void
*
buf_
unsigned
int
idx
FT_Long
*
advance
FT_Long
*
y_offset
)
{
hb_buffer_t
*
buf
=
(
hb_buffer_t
*
)
buf_
;
hb_glyph_info_t
*
ginfo
;
hb_glyph_position_t
*
gpos
;
unsigned
int
gcount
;
FT_UNUSED
(
metrics
)
;
ginfo
=
hb_buffer_get_glyph_infos
(
buf
&
gcount
)
;
gpos
=
hb_buffer_get_glyph_positions
(
buf
&
gcount
)
;
if
(
idx
>
=
gcount
)
return
0
;
if
(
advance
)
*
advance
=
gpos
[
idx
]
.
x_advance
;
if
(
y_offset
)
*
y_offset
=
gpos
[
idx
]
.
y_offset
;
return
ginfo
[
idx
]
.
codepoint
;
}
#
else
FT_Error
af_shaper_get_coverage
(
AF_FaceGlobals
globals
AF_StyleClass
style_class
FT_UShort
*
gstyles
FT_Bool
default_script
)
{
FT_UNUSED
(
globals
)
;
FT_UNUSED
(
style_class
)
;
FT_UNUSED
(
gstyles
)
;
FT_UNUSED
(
default_script
)
;
return
FT_Err_Ok
;
}
void
*
af_shaper_buf_create
(
FT_Face
face
)
{
FT_Error
error
;
FT_Memory
memory
=
face
-
>
memory
;
FT_ULong
*
buf
;
FT_MEM_ALLOC
(
buf
sizeof
(
FT_ULong
)
)
;
return
(
void
*
)
buf
;
}
void
af_shaper_buf_destroy
(
FT_Face
face
void
*
buf
)
{
FT_Memory
memory
=
face
-
>
memory
;
FT_FREE
(
buf
)
;
}
const
char
*
af_shaper_get_cluster
(
const
char
*
p
AF_StyleMetrics
metrics
void
*
buf_
unsigned
int
*
count
)
{
FT_Face
face
=
metrics
-
>
globals
-
>
face
;
FT_ULong
ch
dummy
=
0
;
FT_ULong
*
buf
=
(
FT_ULong
*
)
buf_
;
while
(
*
p
=
=
'
'
)
p
+
+
;
GET_UTF8_CHAR
(
ch
p
)
;
while
(
!
(
*
p
=
=
'
'
|
|
*
p
=
=
'
\
0
'
)
)
GET_UTF8_CHAR
(
dummy
p
)
;
if
(
dummy
)
{
*
buf
=
0
;
*
count
=
0
;
}
else
{
*
buf
=
FT_Get_Char_Index
(
face
ch
)
;
*
count
=
1
;
}
return
p
;
}
FT_ULong
af_shaper_get_elem
(
AF_StyleMetrics
metrics
void
*
buf_
unsigned
int
idx
FT_Long
*
advance
FT_Long
*
y_offset
)
{
FT_Face
face
=
metrics
-
>
globals
-
>
face
;
FT_ULong
glyph_index
=
*
(
FT_ULong
*
)
buf_
;
FT_UNUSED
(
idx
)
;
if
(
advance
)
FT_Get_Advance
(
face
glyph_index
FT_LOAD_NO_SCALE
|
FT_LOAD_NO_HINTING
|
FT_LOAD_IGNORE_TRANSFORM
advance
)
;
if
(
y_offset
)
*
y_offset
=
0
;
return
glyph_index
;
}
#
endif
