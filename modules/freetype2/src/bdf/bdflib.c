#
include
<
freetype
/
freetype
.
h
>
#
include
<
freetype
/
internal
/
ftdebug
.
h
>
#
include
<
freetype
/
internal
/
ftstream
.
h
>
#
include
<
freetype
/
internal
/
ftobjs
.
h
>
#
include
"
bdf
.
h
"
#
include
"
bdferror
.
h
"
#
undef
FT_COMPONENT
#
define
FT_COMPONENT
bdflib
#
define
BUFSIZE
128
static
const
bdf_options_t
bdf_opts_
=
{
1
1
0
BDF_PROPORTIONAL
}
;
static
const
bdf_property_t
bdf_properties_
[
]
=
{
{
"
ADD_STYLE_NAME
"
BDF_ATOM
1
{
0
}
}
{
"
AVERAGE_WIDTH
"
BDF_INTEGER
1
{
0
}
}
{
"
AVG_CAPITAL_WIDTH
"
BDF_INTEGER
1
{
0
}
}
{
"
AVG_LOWERCASE_WIDTH
"
BDF_INTEGER
1
{
0
}
}
{
"
CAP_HEIGHT
"
BDF_INTEGER
1
{
0
}
}
{
"
CHARSET_COLLECTIONS
"
BDF_ATOM
1
{
0
}
}
{
"
CHARSET_ENCODING
"
BDF_ATOM
1
{
0
}
}
{
"
CHARSET_REGISTRY
"
BDF_ATOM
1
{
0
}
}
{
"
COMMENT
"
BDF_ATOM
1
{
0
}
}
{
"
COPYRIGHT
"
BDF_ATOM
1
{
0
}
}
{
"
DEFAULT_CHAR
"
BDF_CARDINAL
1
{
0
}
}
{
"
DESTINATION
"
BDF_CARDINAL
1
{
0
}
}
{
"
DEVICE_FONT_NAME
"
BDF_ATOM
1
{
0
}
}
{
"
END_SPACE
"
BDF_INTEGER
1
{
0
}
}
{
"
FACE_NAME
"
BDF_ATOM
1
{
0
}
}
{
"
FAMILY_NAME
"
BDF_ATOM
1
{
0
}
}
{
"
FIGURE_WIDTH
"
BDF_INTEGER
1
{
0
}
}
{
"
FONT
"
BDF_ATOM
1
{
0
}
}
{
"
FONTNAME_REGISTRY
"
BDF_ATOM
1
{
0
}
}
{
"
FONT_ASCENT
"
BDF_INTEGER
1
{
0
}
}
{
"
FONT_DESCENT
"
BDF_INTEGER
1
{
0
}
}
{
"
FOUNDRY
"
BDF_ATOM
1
{
0
}
}
{
"
FULL_NAME
"
BDF_ATOM
1
{
0
}
}
{
"
ITALIC_ANGLE
"
BDF_INTEGER
1
{
0
}
}
{
"
MAX_SPACE
"
BDF_INTEGER
1
{
0
}
}
{
"
MIN_SPACE
"
BDF_INTEGER
1
{
0
}
}
{
"
NORM_SPACE
"
BDF_INTEGER
1
{
0
}
}
{
"
NOTICE
"
BDF_ATOM
1
{
0
}
}
{
"
PIXEL_SIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
POINT_SIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
QUAD_WIDTH
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_ASCENT
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_AVERAGE_WIDTH
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_AVG_CAPITAL_WIDTH
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_AVG_LOWERCASE_WIDTH
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_CAP_HEIGHT
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_DESCENT
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_END_SPACE
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_FIGURE_WIDTH
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_MAX_SPACE
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_MIN_SPACE
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_NORM_SPACE
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_PIXEL_SIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_POINT_SIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_PIXELSIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_POINTSIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_QUAD_WIDTH
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_SMALL_CAP_SIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_STRIKEOUT_ASCENT
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_STRIKEOUT_DESCENT
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_SUBSCRIPT_SIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_SUBSCRIPT_X
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_SUBSCRIPT_Y
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_SUPERSCRIPT_SIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_SUPERSCRIPT_X
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_SUPERSCRIPT_Y
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_UNDERLINE_POSITION
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_UNDERLINE_THICKNESS
"
BDF_INTEGER
1
{
0
}
}
{
"
RAW_X_HEIGHT
"
BDF_INTEGER
1
{
0
}
}
{
"
RELATIVE_SETWIDTH
"
BDF_CARDINAL
1
{
0
}
}
{
"
RELATIVE_WEIGHT
"
BDF_CARDINAL
1
{
0
}
}
{
"
RESOLUTION
"
BDF_INTEGER
1
{
0
}
}
{
"
RESOLUTION_X
"
BDF_CARDINAL
1
{
0
}
}
{
"
RESOLUTION_Y
"
BDF_CARDINAL
1
{
0
}
}
{
"
SETWIDTH_NAME
"
BDF_ATOM
1
{
0
}
}
{
"
SLANT
"
BDF_ATOM
1
{
0
}
}
{
"
SMALL_CAP_SIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
SPACING
"
BDF_ATOM
1
{
0
}
}
{
"
STRIKEOUT_ASCENT
"
BDF_INTEGER
1
{
0
}
}
{
"
STRIKEOUT_DESCENT
"
BDF_INTEGER
1
{
0
}
}
{
"
SUBSCRIPT_SIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
SUBSCRIPT_X
"
BDF_INTEGER
1
{
0
}
}
{
"
SUBSCRIPT_Y
"
BDF_INTEGER
1
{
0
}
}
{
"
SUPERSCRIPT_SIZE
"
BDF_INTEGER
1
{
0
}
}
{
"
SUPERSCRIPT_X
"
BDF_INTEGER
1
{
0
}
}
{
"
SUPERSCRIPT_Y
"
BDF_INTEGER
1
{
0
}
}
{
"
UNDERLINE_POSITION
"
BDF_INTEGER
1
{
0
}
}
{
"
UNDERLINE_THICKNESS
"
BDF_INTEGER
1
{
0
}
}
{
"
WEIGHT
"
BDF_CARDINAL
1
{
0
}
}
{
"
WEIGHT_NAME
"
BDF_ATOM
1
{
0
}
}
{
"
X_HEIGHT
"
BDF_INTEGER
1
{
0
}
}
{
"
_MULE_BASELINE_OFFSET
"
BDF_INTEGER
1
{
0
}
}
{
"
_MULE_RELATIVE_COMPOSE
"
BDF_INTEGER
1
{
0
}
}
}
;
static
const
unsigned
long
num_bdf_properties_
=
sizeof
(
bdf_properties_
)
/
sizeof
(
bdf_properties_
[
0
]
)
;
#
define
_bdf_strncmp
(
name
property
n
)
\
(
ft_strncmp
(
name
property
n
)
|
|
\
!
(
name
[
n
]
=
=
'
'
|
|
\
name
[
n
]
=
=
'
\
0
'
|
|
\
name
[
n
]
=
=
'
\
n
'
|
|
\
name
[
n
]
=
=
'
\
r
'
|
|
\
name
[
n
]
=
=
'
\
t
'
)
)
#
define
ACMSG1
"
FONT_ASCENT
property
missing
.
"
\
"
Added
FONT_ASCENT
%
hd
'
.
\
n
"
#
define
ACMSG2
"
FONT_DESCENT
property
missing
.
"
\
"
Added
FONT_DESCENT
%
hd
'
.
\
n
"
#
define
ACMSG3
"
Font
width
!
=
actual
width
.
Old
:
%
d
New
:
%
d
.
\
n
"
#
define
ACMSG4
"
Font
left
bearing
!
=
actual
left
bearing
.
"
\
"
Old
:
%
hd
New
:
%
hd
.
\
n
"
#
define
ACMSG5
"
Font
ascent
!
=
actual
ascent
.
Old
:
%
hd
New
:
%
hd
.
\
n
"
#
define
ACMSG6
"
Font
descent
!
=
actual
descent
.
Old
:
%
d
New
:
%
d
.
\
n
"
#
define
ACMSG7
"
Font
height
!
=
actual
height
.
Old
:
%
d
New
:
%
d
.
\
n
"
#
define
ACMSG8
"
Glyph
scalable
width
(
SWIDTH
)
adjustments
made
.
\
n
"
#
define
ACMSG9
"
SWIDTH
field
missing
at
line
%
ld
.
Set
automatically
.
\
n
"
#
define
ACMSG10
"
DWIDTH
field
missing
at
line
%
ld
.
Set
to
glyph
width
.
\
n
"
#
define
ACMSG11
"
SIZE
bits
per
pixel
field
adjusted
to
%
hd
.
\
n
"
#
define
ACMSG13
"
Glyph
%
lu
extra
rows
removed
.
\
n
"
#
define
ACMSG14
"
Glyph
%
lu
extra
columns
removed
.
\
n
"
#
define
ACMSG15
"
Incorrect
glyph
count
:
%
ld
indicated
but
%
ld
found
.
\
n
"
#
define
ACMSG16
"
Glyph
%
lu
missing
columns
padded
with
zero
bits
.
\
n
"
#
define
ACMSG17
"
Adjusting
number
of
glyphs
to
%
ld
.
\
n
"
#
define
ERRMSG1
"
[
line
%
ld
]
Missing
%
s
'
line
.
\
n
"
#
define
ERRMSG2
"
[
line
%
ld
]
Font
header
corrupted
or
missing
fields
.
\
n
"
#
define
ERRMSG3
"
[
line
%
ld
]
Font
glyphs
corrupted
or
missing
fields
.
\
n
"
#
define
ERRMSG4
"
[
line
%
ld
]
BBX
too
big
.
\
n
"
#
define
ERRMSG5
"
[
line
%
ld
]
%
s
'
value
too
big
.
\
n
"
#
define
ERRMSG6
"
[
line
%
ld
]
Input
line
too
long
.
\
n
"
#
define
ERRMSG7
"
[
line
%
ld
]
Font
name
too
long
.
\
n
"
#
define
ERRMSG8
"
[
line
%
ld
]
Invalid
%
s
'
value
.
\
n
"
#
define
ERRMSG9
"
[
line
%
ld
]
Invalid
keyword
.
\
n
"
#
define
DBGMSG1
"
[
%
6ld
]
%
s
"
/
*
no
\
n
*
/
#
define
DBGMSG2
"
(
0x
%
lX
)
\
n
"
typedef
FT_Error
(
*
bdf_line_func_t_
)
(
char
*
line
unsigned
long
linelen
unsigned
long
lineno
void
*
call_data
void
*
client_data
)
;
typedef
struct
bdf_list_t__
{
char
*
*
field
;
unsigned
long
size
;
unsigned
long
used
;
FT_Memory
memory
;
}
bdf_list_t_
;
typedef
struct
bdf_parse_t__
{
unsigned
long
flags
;
unsigned
long
cnt
;
unsigned
long
row
;
short
minlb
;
short
maxlb
;
short
maxrb
;
short
maxas
;
short
maxds
;
short
rbearing
;
char
*
glyph_name
;
long
glyph_enc
;
bdf_font_t
*
font
;
bdf_options_t
*
opts
;
bdf_list_t_
list
;
FT_Memory
memory
;
unsigned
long
size
;
}
bdf_parse_t_
;
#
define
setsbit
(
m
cc
)
\
(
m
[
(
FT_Byte
)
(
cc
)
>
>
3
]
|
=
(
FT_Byte
)
(
1
<
<
(
(
cc
)
&
7
)
)
)
#
define
sbitset
(
m
cc
)
\
(
m
[
(
FT_Byte
)
(
cc
)
>
>
3
]
&
(
1
<
<
(
(
cc
)
&
7
)
)
)
static
void
bdf_list_init_
(
bdf_list_t_
*
list
FT_Memory
memory
)
{
FT_ZERO
(
list
)
;
list
-
>
memory
=
memory
;
}
static
void
bdf_list_done_
(
bdf_list_t_
*
list
)
{
FT_Memory
memory
=
list
-
>
memory
;
if
(
memory
)
{
FT_FREE
(
list
-
>
field
)
;
FT_ZERO
(
list
)
;
}
}
static
FT_Error
bdf_list_ensure_
(
bdf_list_t_
*
list
unsigned
long
num_items
)
{
FT_Error
error
=
FT_Err_Ok
;
if
(
num_items
>
list
-
>
size
)
{
unsigned
long
oldsize
=
list
-
>
size
;
unsigned
long
newsize
=
oldsize
+
(
oldsize
>
>
1
)
+
5
;
unsigned
long
bigsize
=
(
unsigned
long
)
(
FT_INT_MAX
/
sizeof
(
char
*
)
)
;
FT_Memory
memory
=
list
-
>
memory
;
if
(
oldsize
=
=
bigsize
)
{
error
=
FT_THROW
(
Out_Of_Memory
)
;
goto
Exit
;
}
else
if
(
newsize
<
oldsize
|
|
newsize
>
bigsize
)
newsize
=
bigsize
;
if
(
FT_QRENEW_ARRAY
(
list
-
>
field
oldsize
newsize
)
)
goto
Exit
;
list
-
>
size
=
newsize
;
}
Exit
:
return
error
;
}
static
void
bdf_list_shift_
(
bdf_list_t_
*
list
unsigned
long
n
)
{
unsigned
long
i
u
;
if
(
list
=
=
NULL
|
|
list
-
>
used
=
=
0
|
|
n
=
=
0
)
return
;
if
(
n
>
=
list
-
>
used
)
{
list
-
>
used
=
0
;
return
;
}
for
(
u
=
n
i
=
0
;
u
<
list
-
>
used
;
i
+
+
u
+
+
)
list
-
>
field
[
i
]
=
list
-
>
field
[
u
]
;
list
-
>
used
-
=
n
;
}
static
const
char
empty
[
]
=
"
"
;
static
char
*
bdf_list_join_
(
bdf_list_t_
*
list
int
c
unsigned
long
*
alen
)
{
unsigned
long
i
j
;
char
*
dp
;
*
alen
=
0
;
if
(
list
=
=
NULL
|
|
list
-
>
used
=
=
0
)
return
NULL
;
dp
=
list
-
>
field
[
0
]
;
for
(
i
=
j
=
0
;
i
<
list
-
>
used
;
i
+
+
)
{
char
*
fp
=
list
-
>
field
[
i
]
;
while
(
*
fp
)
dp
[
j
+
+
]
=
*
fp
+
+
;
if
(
i
+
1
<
list
-
>
used
)
dp
[
j
+
+
]
=
(
char
)
c
;
}
if
(
dp
!
=
empty
)
dp
[
j
]
=
0
;
*
alen
=
j
;
return
dp
;
}
static
FT_Error
bdf_list_split_
(
bdf_list_t_
*
list
const
char
*
separators
char
*
line
unsigned
long
linelen
)
{
unsigned
long
final_empty
;
int
mult
;
const
char
*
sp
*
end
;
char
*
ep
;
char
seps
[
32
]
;
FT_Error
error
=
FT_Err_Ok
;
list
-
>
used
=
0
;
if
(
list
-
>
size
)
{
list
-
>
field
[
0
]
=
(
char
*
)
empty
;
list
-
>
field
[
1
]
=
(
char
*
)
empty
;
list
-
>
field
[
2
]
=
(
char
*
)
empty
;
list
-
>
field
[
3
]
=
(
char
*
)
empty
;
list
-
>
field
[
4
]
=
(
char
*
)
empty
;
}
if
(
linelen
=
=
0
|
|
line
[
0
]
=
=
0
)
goto
Exit
;
if
(
separators
=
=
NULL
|
|
*
separators
=
=
0
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
FT_MEM_ZERO
(
seps
32
)
;
for
(
mult
=
0
sp
=
separators
;
sp
&
&
*
sp
;
sp
+
+
)
{
if
(
*
sp
=
=
'
+
'
&
&
*
(
sp
+
1
)
=
=
0
)
mult
=
1
;
else
setsbit
(
seps
*
sp
)
;
}
for
(
final_empty
=
0
sp
=
ep
=
line
end
=
sp
+
linelen
;
sp
<
end
&
&
*
sp
;
)
{
for
(
;
*
ep
&
&
!
sbitset
(
seps
*
ep
)
;
ep
+
+
)
;
if
(
list
-
>
used
=
=
list
-
>
size
)
{
error
=
bdf_list_ensure_
(
list
list
-
>
used
+
1
)
;
if
(
error
)
goto
Exit
;
}
list
-
>
field
[
list
-
>
used
+
+
]
=
(
ep
>
sp
)
?
(
char
*
)
sp
:
(
char
*
)
empty
;
sp
=
ep
;
if
(
mult
)
{
for
(
;
*
ep
&
&
sbitset
(
seps
*
ep
)
;
ep
+
+
)
*
ep
=
0
;
}
else
if
(
*
ep
!
=
0
)
*
ep
+
+
=
0
;
final_empty
=
(
ep
>
sp
&
&
*
ep
=
=
0
)
;
sp
=
ep
;
}
if
(
list
-
>
used
+
final_empty
>
=
list
-
>
size
)
{
error
=
bdf_list_ensure_
(
list
list
-
>
used
+
final_empty
+
1
)
;
if
(
error
)
goto
Exit
;
}
if
(
final_empty
)
list
-
>
field
[
list
-
>
used
+
+
]
=
(
char
*
)
empty
;
list
-
>
field
[
list
-
>
used
]
=
NULL
;
Exit
:
return
error
;
}
#
define
NO_SKIP
256
/
*
this
value
cannot
be
stored
in
a
'
char
'
*
/
static
FT_Error
bdf_readstream_
(
FT_Stream
stream
bdf_line_func_t_
callback
void
*
client_data
unsigned
long
*
lno
)
{
bdf_line_func_t_
cb
;
unsigned
long
lineno
buf_size
;
int
refill
hold
to_skip
;
ptrdiff_t
bytes
start
end
cursor
avail
;
char
*
buf
=
NULL
;
FT_Memory
memory
=
stream
-
>
memory
;
FT_Error
error
=
FT_Err_Ok
;
if
(
callback
=
=
NULL
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
buf_size
=
1024
;
if
(
FT_QALLOC
(
buf
buf_size
)
)
goto
Exit
;
cb
=
callback
;
lineno
=
1
;
buf
[
0
]
=
0
;
start
=
0
;
avail
=
0
;
cursor
=
0
;
refill
=
1
;
to_skip
=
NO_SKIP
;
bytes
=
0
;
for
(
;
;
)
{
if
(
refill
)
{
bytes
=
(
ptrdiff_t
)
FT_Stream_TryRead
(
stream
(
FT_Byte
*
)
buf
+
cursor
buf_size
-
(
unsigned
long
)
cursor
)
;
avail
=
cursor
+
bytes
;
cursor
=
0
;
refill
=
0
;
}
end
=
start
;
if
(
start
<
avail
&
&
buf
[
start
]
=
=
to_skip
)
{
start
+
=
1
;
to_skip
=
NO_SKIP
;
continue
;
}
while
(
end
<
avail
&
&
buf
[
end
]
!
=
'
\
n
'
&
&
buf
[
end
]
!
=
'
\
r
'
)
end
+
+
;
if
(
end
>
=
avail
)
{
if
(
bytes
=
=
0
)
{
if
(
lineno
=
=
1
)
error
=
FT_THROW
(
Missing_Startfont_Field
)
;
break
;
}
if
(
start
=
=
0
)
{
FT_ULong
new_size
;
if
(
buf_size
>
=
65536UL
)
{
if
(
lineno
=
=
1
)
error
=
FT_THROW
(
Missing_Startfont_Field
)
;
else
{
FT_ERROR
(
(
"
bdf_readstream_
:
"
ERRMSG6
lineno
)
)
;
error
=
FT_THROW
(
Invalid_Argument
)
;
}
goto
Exit
;
}
new_size
=
buf_size
*
2
;
if
(
FT_QREALLOC
(
buf
buf_size
new_size
)
)
goto
Exit
;
cursor
=
avail
;
buf_size
=
new_size
;
}
else
{
bytes
=
avail
-
start
;
FT_MEM_MOVE
(
buf
buf
+
start
bytes
)
;
cursor
=
bytes
;
start
=
0
;
}
refill
=
1
;
continue
;
}
hold
=
buf
[
end
]
;
buf
[
end
]
=
0
;
if
(
buf
[
start
]
!
=
'
#
'
&
&
buf
[
start
]
!
=
0x1A
&
&
end
>
start
)
{
error
=
(
*
cb
)
(
buf
+
start
(
unsigned
long
)
(
end
-
start
)
lineno
(
void
*
)
&
cb
client_data
)
;
if
(
error
=
=
-
1
)
error
=
(
*
cb
)
(
buf
+
start
(
unsigned
long
)
(
end
-
start
)
lineno
(
void
*
)
&
cb
client_data
)
;
if
(
error
)
break
;
}
lineno
+
=
1
;
buf
[
end
]
=
(
char
)
hold
;
start
=
end
+
1
;
if
(
hold
=
=
'
\
n
'
)
to_skip
=
'
\
r
'
;
else
if
(
hold
=
=
'
\
r
'
)
to_skip
=
'
\
n
'
;
else
to_skip
=
NO_SKIP
;
}
*
lno
=
lineno
;
Exit
:
FT_FREE
(
buf
)
;
return
error
;
}
static
const
unsigned
char
a2i
[
128
]
=
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
;
static
const
unsigned
char
ddigits
[
32
]
=
{
0x00
0x00
0x00
0x00
0x00
0x00
0xFF
0x03
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
;
static
const
unsigned
char
hdigits
[
32
]
=
{
0x00
0x00
0x00
0x00
0x00
0x00
0xFF
0x03
0x7E
0x00
0x00
0x00
0x7E
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
;
static
unsigned
long
bdf_atoul_
(
const
char
*
s
)
{
unsigned
long
v
;
if
(
s
=
=
NULL
|
|
*
s
=
=
0
)
return
0
;
for
(
v
=
0
;
sbitset
(
ddigits
*
s
)
;
s
+
+
)
{
if
(
v
<
(
FT_ULONG_MAX
-
9
)
/
10
)
v
=
v
*
10
+
a2i
[
(
int
)
*
s
]
;
else
{
v
=
FT_ULONG_MAX
;
break
;
}
}
return
v
;
}
static
long
bdf_atol_
(
const
char
*
s
)
{
long
v
neg
;
if
(
s
=
=
NULL
|
|
*
s
=
=
0
)
return
0
;
neg
=
0
;
if
(
*
s
=
=
'
-
'
)
{
s
+
+
;
neg
=
1
;
}
for
(
v
=
0
;
sbitset
(
ddigits
*
s
)
;
s
+
+
)
{
if
(
v
<
(
FT_LONG_MAX
-
9
)
/
10
)
v
=
v
*
10
+
a2i
[
(
int
)
*
s
]
;
else
{
v
=
FT_LONG_MAX
;
break
;
}
}
return
(
!
neg
)
?
v
:
-
v
;
}
static
unsigned
short
bdf_atous_
(
const
char
*
s
)
{
unsigned
short
v
;
if
(
s
=
=
NULL
|
|
*
s
=
=
0
)
return
0
;
for
(
v
=
0
;
sbitset
(
ddigits
*
s
)
;
s
+
+
)
{
if
(
v
<
(
FT_USHORT_MAX
-
9
)
/
10
)
v
=
(
unsigned
short
)
(
v
*
10
+
a2i
[
(
int
)
*
s
]
)
;
else
{
v
=
FT_USHORT_MAX
;
break
;
}
}
return
v
;
}
static
short
bdf_atos_
(
const
char
*
s
)
{
short
v
neg
;
if
(
s
=
=
NULL
|
|
*
s
=
=
0
)
return
0
;
neg
=
0
;
if
(
*
s
=
=
'
-
'
)
{
s
+
+
;
neg
=
1
;
}
for
(
v
=
0
;
sbitset
(
ddigits
*
s
)
;
s
+
+
)
{
if
(
v
<
(
SHRT_MAX
-
9
)
/
10
)
v
=
(
short
)
(
v
*
10
+
a2i
[
(
int
)
*
s
]
)
;
else
{
v
=
SHRT_MAX
;
break
;
}
}
return
(
short
)
(
(
!
neg
)
?
v
:
-
v
)
;
}
FT_COMPARE_DEF
(
int
)
by_encoding
(
const
void
*
a
const
void
*
b
)
{
bdf_glyph_t
*
c1
*
c2
;
c1
=
(
bdf_glyph_t
*
)
a
;
c2
=
(
bdf_glyph_t
*
)
b
;
if
(
c1
-
>
encoding
<
c2
-
>
encoding
)
return
-
1
;
if
(
c1
-
>
encoding
>
c2
-
>
encoding
)
return
1
;
return
0
;
}
static
FT_Error
bdf_create_property
(
const
char
*
name
int
format
bdf_font_t
*
font
)
{
size_t
n
;
bdf_property_t
*
p
;
FT_Memory
memory
=
font
-
>
memory
;
FT_Error
error
=
FT_Err_Ok
;
if
(
ft_hash_str_lookup
(
name
&
(
font
-
>
proptbl
)
)
)
goto
Exit
;
if
(
FT_QRENEW_ARRAY
(
font
-
>
user_props
font
-
>
nuser_props
font
-
>
nuser_props
+
1
)
)
goto
Exit
;
p
=
font
-
>
user_props
+
font
-
>
nuser_props
;
if
(
FT_STRDUP
(
p
-
>
name
name
)
)
goto
Exit
;
p
-
>
format
=
format
;
p
-
>
builtin
=
0
;
p
-
>
value
.
atom
=
NULL
;
n
=
num_bdf_properties_
+
font
-
>
nuser_props
;
error
=
ft_hash_str_insert
(
p
-
>
name
n
&
(
font
-
>
proptbl
)
memory
)
;
if
(
error
)
goto
Exit
;
font
-
>
nuser_props
+
+
;
Exit
:
return
error
;
}
static
bdf_property_t
*
bdf_get_property
(
const
char
*
name
bdf_font_t
*
font
)
{
size_t
*
propid
;
if
(
name
=
=
NULL
|
|
*
name
=
=
0
)
return
NULL
;
if
(
(
propid
=
ft_hash_str_lookup
(
name
&
(
font
-
>
proptbl
)
)
)
=
=
NULL
)
return
NULL
;
if
(
*
propid
>
=
num_bdf_properties_
)
return
font
-
>
user_props
+
(
*
propid
-
num_bdf_properties_
)
;
return
(
bdf_property_t
*
)
bdf_properties_
+
*
propid
;
}
#
define
BDF_START_
0x0001U
#
define
BDF_FONT_NAME_
0x0002U
#
define
BDF_SIZE_
0x0004U
#
define
BDF_FONT_BBX_
0x0008U
#
define
BDF_PROPS_
0x0010U
#
define
BDF_GLYPHS_
0x0020U
#
define
BDF_GLYPH_
0x0040U
#
define
BDF_ENCODING_
0x0080U
#
define
BDF_SWIDTH_
0x0100U
#
define
BDF_DWIDTH_
0x0200U
#
define
BDF_BBX_
0x0400U
#
define
BDF_BITMAP_
0x0800U
#
define
BDF_SWIDTH_ADJ_
0x1000U
#
define
BDF_GLYPH_BITS_
(
BDF_GLYPH_
|
\
BDF_ENCODING_
|
\
BDF_SWIDTH_
|
\
BDF_DWIDTH_
|
\
BDF_BBX_
|
\
BDF_BITMAP_
)
#
define
BDF_GLYPH_WIDTH_CHECK_
0x40000000UL
#
define
BDF_GLYPH_HEIGHT_CHECK_
0x80000000UL
static
FT_Error
bdf_add_comment_
(
bdf_font_t
*
font
const
char
*
comment
unsigned
long
len
)
{
char
*
cp
;
FT_Memory
memory
=
font
-
>
memory
;
FT_Error
error
=
FT_Err_Ok
;
if
(
FT_QRENEW_ARRAY
(
font
-
>
comments
font
-
>
comments_len
font
-
>
comments_len
+
len
+
1
)
)
goto
Exit
;
cp
=
font
-
>
comments
+
font
-
>
comments_len
;
FT_MEM_COPY
(
cp
comment
len
)
;
cp
[
len
]
=
'
\
0
'
;
font
-
>
comments_len
+
=
len
+
1
;
Exit
:
return
error
;
}
static
FT_Error
bdf_set_default_spacing_
(
bdf_font_t
*
font
bdf_options_t
*
opts
unsigned
long
lineno
)
{
size_t
len
;
char
name
[
256
]
;
bdf_list_t_
list
;
FT_Memory
memory
;
FT_Error
error
=
FT_Err_Ok
;
FT_UNUSED
(
lineno
)
;
if
(
font
=
=
NULL
|
|
font
-
>
name
=
=
NULL
|
|
font
-
>
name
[
0
]
=
=
0
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
memory
=
font
-
>
memory
;
bdf_list_init_
(
&
list
memory
)
;
font
-
>
spacing
=
opts
-
>
font_spacing
;
len
=
ft_strlen
(
font
-
>
name
)
+
1
;
if
(
len
>
=
256
)
{
FT_ERROR
(
(
"
bdf_set_default_spacing_
:
"
ERRMSG7
lineno
)
)
;
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
FT_MEM_COPY
(
name
font
-
>
name
len
)
;
error
=
bdf_list_split_
(
&
list
"
-
"
name
(
unsigned
long
)
len
)
;
if
(
error
)
goto
Fail
;
if
(
list
.
used
=
=
15
)
{
switch
(
list
.
field
[
11
]
[
0
]
)
{
case
'
C
'
:
case
'
c
'
:
font
-
>
spacing
=
BDF_CHARCELL
;
break
;
case
'
M
'
:
case
'
m
'
:
font
-
>
spacing
=
BDF_MONOWIDTH
;
break
;
case
'
P
'
:
case
'
p
'
:
font
-
>
spacing
=
BDF_PROPORTIONAL
;
break
;
}
}
Fail
:
bdf_list_done_
(
&
list
)
;
Exit
:
return
error
;
}
static
int
bdf_is_atom_
(
char
*
line
unsigned
long
linelen
char
*
*
name
char
*
*
value
bdf_font_t
*
font
)
{
int
hold
;
char
*
sp
*
ep
;
bdf_property_t
*
p
;
sp
=
ep
=
line
;
while
(
*
ep
&
&
*
ep
!
=
'
'
&
&
*
ep
!
=
'
\
t
'
)
ep
+
+
;
hold
=
*
ep
;
*
ep
=
'
\
0
'
;
p
=
bdf_get_property
(
sp
font
)
;
if
(
p
&
&
p
-
>
format
!
=
BDF_ATOM
)
{
*
ep
=
(
char
)
hold
;
return
0
;
}
*
name
=
sp
;
sp
=
ep
;
ep
=
line
+
linelen
;
if
(
sp
<
ep
)
do
sp
+
+
;
while
(
*
sp
=
=
'
'
|
|
*
sp
=
=
'
\
t
'
)
;
if
(
*
sp
=
=
'
"
'
)
sp
+
+
;
*
value
=
sp
;
if
(
sp
<
ep
)
do
*
ep
-
-
=
'
\
0
'
;
while
(
*
ep
=
=
'
'
|
|
*
ep
=
=
'
\
t
'
)
;
if
(
*
ep
=
=
'
"
'
)
*
ep
=
'
\
0
'
;
return
1
;
}
static
FT_Error
bdf_add_property_
(
bdf_font_t
*
font
const
char
*
name
char
*
value
unsigned
long
lineno
)
{
size_t
*
propid
;
bdf_property_t
*
prop
*
fp
;
FT_Memory
memory
=
font
-
>
memory
;
FT_Error
error
=
FT_Err_Ok
;
FT_UNUSED
(
lineno
)
;
if
(
(
propid
=
ft_hash_str_lookup
(
name
(
FT_Hash
)
font
-
>
internal
)
)
!
=
NULL
)
{
fp
=
font
-
>
props
+
*
propid
;
switch
(
fp
-
>
format
)
{
case
BDF_ATOM
:
FT_FREE
(
fp
-
>
value
.
atom
)
;
if
(
value
&
&
value
[
0
]
!
=
0
)
{
if
(
FT_STRDUP
(
fp
-
>
value
.
atom
value
)
)
goto
Exit
;
}
break
;
case
BDF_INTEGER
:
fp
-
>
value
.
l
=
bdf_atol_
(
value
)
;
break
;
case
BDF_CARDINAL
:
fp
-
>
value
.
ul
=
bdf_atoul_
(
value
)
;
break
;
default
:
;
}
goto
Exit
;
}
propid
=
ft_hash_str_lookup
(
name
&
(
font
-
>
proptbl
)
)
;
if
(
!
propid
)
{
error
=
bdf_create_property
(
name
BDF_ATOM
font
)
;
if
(
error
)
goto
Exit
;
propid
=
ft_hash_str_lookup
(
name
&
(
font
-
>
proptbl
)
)
;
}
if
(
font
-
>
props_used
=
=
font
-
>
props_size
)
{
if
(
FT_QRENEW_ARRAY
(
font
-
>
props
font
-
>
props_size
font
-
>
props_size
+
1
)
)
goto
Exit
;
font
-
>
props_size
+
+
;
}
if
(
*
propid
>
=
num_bdf_properties_
)
prop
=
font
-
>
user_props
+
(
*
propid
-
num_bdf_properties_
)
;
else
prop
=
(
bdf_property_t
*
)
bdf_properties_
+
*
propid
;
fp
=
font
-
>
props
+
font
-
>
props_used
;
fp
-
>
name
=
prop
-
>
name
;
fp
-
>
format
=
prop
-
>
format
;
fp
-
>
builtin
=
prop
-
>
builtin
;
switch
(
prop
-
>
format
)
{
case
BDF_ATOM
:
fp
-
>
value
.
atom
=
NULL
;
if
(
value
&
&
value
[
0
]
)
{
if
(
FT_STRDUP
(
fp
-
>
value
.
atom
value
)
)
goto
Exit
;
}
break
;
case
BDF_INTEGER
:
fp
-
>
value
.
l
=
bdf_atol_
(
value
)
;
break
;
case
BDF_CARDINAL
:
fp
-
>
value
.
ul
=
bdf_atoul_
(
value
)
;
break
;
}
if
(
_bdf_strncmp
(
name
"
COMMENT
"
7
)
!
=
0
)
{
error
=
ft_hash_str_insert
(
fp
-
>
name
font
-
>
props_used
(
FT_Hash
)
font
-
>
internal
memory
)
;
if
(
error
)
goto
Exit
;
}
font
-
>
props_used
+
+
;
if
(
_bdf_strncmp
(
name
"
DEFAULT_CHAR
"
12
)
=
=
0
)
font
-
>
default_char
=
fp
-
>
value
.
ul
;
else
if
(
_bdf_strncmp
(
name
"
FONT_ASCENT
"
11
)
=
=
0
)
font
-
>
font_ascent
=
fp
-
>
value
.
l
;
else
if
(
_bdf_strncmp
(
name
"
FONT_DESCENT
"
12
)
=
=
0
)
font
-
>
font_descent
=
fp
-
>
value
.
l
;
else
if
(
_bdf_strncmp
(
name
"
SPACING
"
7
)
=
=
0
)
{
if
(
!
fp
-
>
value
.
atom
)
{
FT_ERROR
(
(
"
bdf_add_property_
:
"
ERRMSG8
lineno
"
SPACING
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
if
(
fp
-
>
value
.
atom
[
0
]
=
=
'
p
'
|
|
fp
-
>
value
.
atom
[
0
]
=
=
'
P
'
)
font
-
>
spacing
=
BDF_PROPORTIONAL
;
else
if
(
fp
-
>
value
.
atom
[
0
]
=
=
'
m
'
|
|
fp
-
>
value
.
atom
[
0
]
=
=
'
M
'
)
font
-
>
spacing
=
BDF_MONOWIDTH
;
else
if
(
fp
-
>
value
.
atom
[
0
]
=
=
'
c
'
|
|
fp
-
>
value
.
atom
[
0
]
=
=
'
C
'
)
font
-
>
spacing
=
BDF_CHARCELL
;
}
Exit
:
return
error
;
}
static
const
unsigned
char
nibble_mask
[
8
]
=
{
0xFF
0x80
0xC0
0xE0
0xF0
0xF8
0xFC
0xFE
}
;
static
FT_Error
bdf_parse_end_
(
char
*
line
unsigned
long
linelen
unsigned
long
lineno
void
*
call_data
void
*
client_data
)
{
FT_UNUSED
(
line
)
;
FT_UNUSED
(
linelen
)
;
FT_UNUSED
(
lineno
)
;
FT_UNUSED
(
call_data
)
;
FT_UNUSED
(
client_data
)
;
return
FT_Err_Ok
;
}
static
FT_Error
bdf_parse_glyphs_
(
char
*
line
unsigned
long
linelen
unsigned
long
lineno
void
*
call_data
void
*
client_data
)
{
int
c
mask_index
;
char
*
s
;
unsigned
char
*
bp
;
unsigned
long
i
slen
nibbles
;
bdf_line_func_t_
*
next
;
bdf_parse_t_
*
p
;
bdf_glyph_t
*
glyph
;
bdf_font_t
*
font
;
FT_Memory
memory
;
FT_Error
error
=
FT_Err_Ok
;
FT_UNUSED
(
lineno
)
;
next
=
(
bdf_line_func_t_
*
)
call_data
;
p
=
(
bdf_parse_t_
*
)
client_data
;
font
=
p
-
>
font
;
memory
=
font
-
>
memory
;
if
(
_bdf_strncmp
(
line
"
COMMENT
"
7
)
=
=
0
)
{
if
(
p
-
>
opts
-
>
keep_comments
)
{
linelen
-
=
7
;
s
=
line
+
7
;
if
(
*
s
!
=
0
)
{
s
+
+
;
linelen
-
-
;
}
error
=
bdf_add_comment_
(
p
-
>
font
s
linelen
)
;
}
goto
Exit
;
}
if
(
!
(
p
-
>
flags
&
BDF_GLYPHS_
)
)
{
if
(
_bdf_strncmp
(
line
"
CHARS
"
5
)
!
=
0
)
{
FT_ERROR
(
(
"
bdf_parse_glyphs_
:
"
ERRMSG1
lineno
"
CHARS
"
)
)
;
error
=
FT_THROW
(
Missing_Chars_Field
)
;
goto
Exit
;
}
error
=
bdf_list_split_
(
&
p
-
>
list
"
+
"
line
linelen
)
;
if
(
error
)
goto
Exit
;
p
-
>
cnt
=
font
-
>
glyphs_size
=
bdf_atoul_
(
p
-
>
list
.
field
[
1
]
)
;
if
(
p
-
>
cnt
>
p
-
>
size
/
20
)
{
p
-
>
cnt
=
font
-
>
glyphs_size
=
p
-
>
size
/
20
;
FT_TRACE2
(
(
"
bdf_parse_glyphs_
:
"
ACMSG17
p
-
>
cnt
)
)
;
}
if
(
p
-
>
cnt
=
=
0
)
font
-
>
glyphs_size
=
64
;
if
(
p
-
>
cnt
>
=
0x110000UL
)
{
FT_ERROR
(
(
"
bdf_parse_glyphs_
:
"
ERRMSG5
lineno
"
CHARS
"
)
)
;
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
FT_NEW_ARRAY
(
font
-
>
glyphs
font
-
>
glyphs_size
)
)
goto
Exit
;
p
-
>
flags
|
=
BDF_GLYPHS_
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
ENDFONT
"
7
)
=
=
0
)
{
if
(
p
-
>
flags
&
BDF_GLYPH_BITS_
)
{
FT_ERROR
(
(
"
bdf_parse_glyphs_
:
"
ERRMSG1
lineno
"
ENDCHAR
"
)
)
;
error
=
FT_THROW
(
Corrupted_Font_Glyphs
)
;
goto
Exit
;
}
ft_qsort
(
(
char
*
)
font
-
>
glyphs
font
-
>
glyphs_used
sizeof
(
bdf_glyph_t
)
by_encoding
)
;
p
-
>
flags
&
=
~
BDF_START_
;
*
next
=
bdf_parse_end_
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
ENDCHAR
"
7
)
=
=
0
)
{
p
-
>
glyph_enc
=
0
;
p
-
>
flags
&
=
~
BDF_GLYPH_BITS_
;
goto
Exit
;
}
if
(
(
p
-
>
flags
&
BDF_GLYPH_
)
&
&
p
-
>
glyph_enc
=
=
-
1
&
&
p
-
>
opts
-
>
keep_unencoded
=
=
0
)
goto
Exit
;
if
(
_bdf_strncmp
(
line
"
STARTCHAR
"
9
)
=
=
0
)
{
if
(
p
-
>
flags
&
BDF_GLYPH_BITS_
)
{
FT_ERROR
(
(
"
bdf_parse_glyphs_
:
"
ERRMSG1
lineno
"
ENDCHAR
"
)
)
;
error
=
FT_THROW
(
Missing_Startchar_Field
)
;
goto
Exit
;
}
FT_FREE
(
p
-
>
glyph_name
)
;
error
=
bdf_list_split_
(
&
p
-
>
list
"
+
"
line
linelen
)
;
if
(
error
)
goto
Exit
;
bdf_list_shift_
(
&
p
-
>
list
1
)
;
s
=
bdf_list_join_
(
&
p
-
>
list
'
'
&
slen
)
;
if
(
!
s
)
{
FT_ERROR
(
(
"
bdf_parse_glyphs_
:
"
ERRMSG8
lineno
"
STARTCHAR
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
if
(
FT_DUP
(
p
-
>
glyph_name
s
slen
+
1
)
)
goto
Exit
;
p
-
>
flags
|
=
BDF_GLYPH_
;
FT_TRACE4
(
(
DBGMSG1
lineno
s
)
)
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
ENCODING
"
8
)
=
=
0
)
{
if
(
!
(
p
-
>
flags
&
BDF_GLYPH_
)
)
{
FT_ERROR
(
(
"
bdf_parse_glyphs_
:
"
ERRMSG1
lineno
"
STARTCHAR
"
)
)
;
error
=
FT_THROW
(
Missing_Startchar_Field
)
;
goto
Exit
;
}
error
=
bdf_list_split_
(
&
p
-
>
list
"
+
"
line
linelen
)
;
if
(
error
)
goto
Exit
;
p
-
>
glyph_enc
=
bdf_atol_
(
p
-
>
list
.
field
[
1
]
)
;
if
(
p
-
>
glyph_enc
<
-
1
)
p
-
>
glyph_enc
=
-
1
;
if
(
p
-
>
glyph_enc
=
=
-
1
&
&
p
-
>
list
.
used
>
2
)
p
-
>
glyph_enc
=
bdf_atol_
(
p
-
>
list
.
field
[
2
]
)
;
if
(
p
-
>
glyph_enc
<
-
1
|
|
p
-
>
glyph_enc
>
=
0x110000L
)
p
-
>
glyph_enc
=
-
1
;
FT_TRACE4
(
(
DBGMSG2
p
-
>
glyph_enc
)
)
;
if
(
p
-
>
glyph_enc
>
=
0
)
{
if
(
font
-
>
glyphs_used
=
=
font
-
>
glyphs_size
)
{
if
(
FT_RENEW_ARRAY
(
font
-
>
glyphs
font
-
>
glyphs_size
font
-
>
glyphs_size
+
64
)
)
goto
Exit
;
font
-
>
glyphs_size
+
=
64
;
}
glyph
=
font
-
>
glyphs
+
font
-
>
glyphs_used
+
+
;
glyph
-
>
name
=
p
-
>
glyph_name
;
glyph
-
>
encoding
=
(
unsigned
long
)
p
-
>
glyph_enc
;
p
-
>
glyph_name
=
NULL
;
}
else
{
if
(
p
-
>
opts
-
>
keep_unencoded
)
{
if
(
font
-
>
unencoded_used
=
=
font
-
>
unencoded_size
)
{
if
(
FT_RENEW_ARRAY
(
font
-
>
unencoded
font
-
>
unencoded_size
font
-
>
unencoded_size
+
4
)
)
goto
Exit
;
font
-
>
unencoded_size
+
=
4
;
}
glyph
=
font
-
>
unencoded
+
font
-
>
unencoded_used
;
glyph
-
>
name
=
p
-
>
glyph_name
;
glyph
-
>
encoding
=
font
-
>
unencoded_used
+
+
;
p
-
>
glyph_name
=
NULL
;
}
else
{
FT_FREE
(
p
-
>
glyph_name
)
;
}
}
p
-
>
flags
&
=
~
(
BDF_GLYPH_WIDTH_CHECK_
|
BDF_GLYPH_HEIGHT_CHECK_
)
;
p
-
>
flags
|
=
BDF_ENCODING_
;
goto
Exit
;
}
if
(
!
(
p
-
>
flags
&
BDF_ENCODING_
)
)
goto
Missing_Encoding
;
if
(
p
-
>
glyph_enc
=
=
-
1
)
glyph
=
font
-
>
unencoded
+
(
font
-
>
unencoded_used
-
1
)
;
else
glyph
=
font
-
>
glyphs
+
(
font
-
>
glyphs_used
-
1
)
;
if
(
p
-
>
flags
&
BDF_BITMAP_
)
{
if
(
p
-
>
row
>
=
(
unsigned
long
)
glyph
-
>
bbx
.
height
)
{
if
(
!
(
p
-
>
flags
&
BDF_GLYPH_HEIGHT_CHECK_
)
)
{
FT_TRACE2
(
(
"
bdf_parse_glyphs_
:
"
ACMSG13
glyph
-
>
encoding
)
)
;
p
-
>
flags
|
=
BDF_GLYPH_HEIGHT_CHECK_
;
}
goto
Exit
;
}
nibbles
=
glyph
-
>
bpr
<
<
1
;
bp
=
glyph
-
>
bitmap
+
p
-
>
row
*
glyph
-
>
bpr
;
for
(
i
=
0
;
i
<
nibbles
;
i
+
+
)
{
c
=
line
[
i
]
;
if
(
!
sbitset
(
hdigits
c
)
)
break
;
*
bp
=
(
FT_Byte
)
(
(
*
bp
<
<
4
)
+
a2i
[
c
]
)
;
if
(
i
+
1
<
nibbles
&
&
(
i
&
1
)
)
*
+
+
bp
=
0
;
}
if
(
i
<
nibbles
&
&
!
(
p
-
>
flags
&
BDF_GLYPH_WIDTH_CHECK_
)
)
{
FT_TRACE2
(
(
"
bdf_parse_glyphs_
:
"
ACMSG16
glyph
-
>
encoding
)
)
;
p
-
>
flags
|
=
BDF_GLYPH_WIDTH_CHECK_
;
}
mask_index
=
(
glyph
-
>
bbx
.
width
*
p
-
>
font
-
>
bpp
)
&
7
;
if
(
glyph
-
>
bbx
.
width
)
*
bp
&
=
nibble_mask
[
mask_index
]
;
if
(
i
=
=
nibbles
&
&
sbitset
(
hdigits
line
[
nibbles
]
)
&
&
!
(
p
-
>
flags
&
BDF_GLYPH_WIDTH_CHECK_
)
)
{
FT_TRACE2
(
(
"
bdf_parse_glyphs_
:
"
ACMSG14
glyph
-
>
encoding
)
)
;
p
-
>
flags
|
=
BDF_GLYPH_WIDTH_CHECK_
;
}
p
-
>
row
+
+
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
SWIDTH
"
6
)
=
=
0
)
{
error
=
bdf_list_split_
(
&
p
-
>
list
"
+
"
line
linelen
)
;
if
(
error
)
goto
Exit
;
glyph
-
>
swidth
=
bdf_atous_
(
p
-
>
list
.
field
[
1
]
)
;
p
-
>
flags
|
=
BDF_SWIDTH_
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
DWIDTH
"
6
)
=
=
0
)
{
error
=
bdf_list_split_
(
&
p
-
>
list
"
+
"
line
linelen
)
;
if
(
error
)
goto
Exit
;
glyph
-
>
dwidth
=
bdf_atous_
(
p
-
>
list
.
field
[
1
]
)
;
if
(
!
(
p
-
>
flags
&
BDF_SWIDTH_
)
)
{
FT_TRACE2
(
(
"
bdf_parse_glyphs_
:
"
ACMSG9
lineno
)
)
;
glyph
-
>
swidth
=
(
unsigned
short
)
FT_MulDiv
(
glyph
-
>
dwidth
72000L
(
FT_Long
)
(
font
-
>
point_size
*
font
-
>
resolution_x
)
)
;
}
p
-
>
flags
|
=
BDF_DWIDTH_
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
BBX
"
3
)
=
=
0
)
{
error
=
bdf_list_split_
(
&
p
-
>
list
"
+
"
line
linelen
)
;
if
(
error
)
goto
Exit
;
glyph
-
>
bbx
.
width
=
bdf_atous_
(
p
-
>
list
.
field
[
1
]
)
;
glyph
-
>
bbx
.
height
=
bdf_atous_
(
p
-
>
list
.
field
[
2
]
)
;
glyph
-
>
bbx
.
x_offset
=
bdf_atos_
(
p
-
>
list
.
field
[
3
]
)
;
glyph
-
>
bbx
.
y_offset
=
bdf_atos_
(
p
-
>
list
.
field
[
4
]
)
;
glyph
-
>
bbx
.
ascent
=
(
short
)
(
glyph
-
>
bbx
.
height
+
glyph
-
>
bbx
.
y_offset
)
;
glyph
-
>
bbx
.
descent
=
(
short
)
(
-
glyph
-
>
bbx
.
y_offset
)
;
p
-
>
maxas
=
(
short
)
FT_MAX
(
glyph
-
>
bbx
.
ascent
p
-
>
maxas
)
;
p
-
>
maxds
=
(
short
)
FT_MAX
(
glyph
-
>
bbx
.
descent
p
-
>
maxds
)
;
p
-
>
rbearing
=
(
short
)
(
glyph
-
>
bbx
.
width
+
glyph
-
>
bbx
.
x_offset
)
;
p
-
>
maxrb
=
(
short
)
FT_MAX
(
p
-
>
rbearing
p
-
>
maxrb
)
;
p
-
>
minlb
=
(
short
)
FT_MIN
(
glyph
-
>
bbx
.
x_offset
p
-
>
minlb
)
;
p
-
>
maxlb
=
(
short
)
FT_MAX
(
glyph
-
>
bbx
.
x_offset
p
-
>
maxlb
)
;
if
(
!
(
p
-
>
flags
&
BDF_DWIDTH_
)
)
{
FT_TRACE2
(
(
"
bdf_parse_glyphs_
:
"
ACMSG10
lineno
)
)
;
glyph
-
>
dwidth
=
glyph
-
>
bbx
.
width
;
}
if
(
p
-
>
opts
-
>
correct_metrics
)
{
unsigned
short
sw
=
(
unsigned
short
)
FT_MulDiv
(
glyph
-
>
dwidth
72000L
(
FT_Long
)
(
font
-
>
point_size
*
font
-
>
resolution_x
)
)
;
if
(
sw
!
=
glyph
-
>
swidth
)
{
glyph
-
>
swidth
=
sw
;
p
-
>
flags
|
=
BDF_SWIDTH_ADJ_
;
}
}
p
-
>
flags
|
=
BDF_BBX_
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
BITMAP
"
6
)
=
=
0
)
{
unsigned
long
bitmap_size
;
if
(
!
(
p
-
>
flags
&
BDF_BBX_
)
)
{
FT_ERROR
(
(
"
bdf_parse_glyphs_
:
"
ERRMSG1
lineno
"
BBX
"
)
)
;
error
=
FT_THROW
(
Missing_Bbx_Field
)
;
goto
Exit
;
}
glyph
-
>
bpr
=
(
glyph
-
>
bbx
.
width
*
p
-
>
font
-
>
bpp
+
7
)
>
>
3
;
bitmap_size
=
glyph
-
>
bpr
*
glyph
-
>
bbx
.
height
;
if
(
glyph
-
>
bpr
>
0xFFFFU
|
|
bitmap_size
>
0xFFFFU
)
{
FT_ERROR
(
(
"
bdf_parse_glyphs_
:
"
ERRMSG4
lineno
)
)
;
error
=
FT_THROW
(
Bbx_Too_Big
)
;
goto
Exit
;
}
else
glyph
-
>
bytes
=
(
unsigned
short
)
bitmap_size
;
if
(
FT_ALLOC
(
glyph
-
>
bitmap
glyph
-
>
bytes
)
)
goto
Exit
;
p
-
>
row
=
0
;
p
-
>
flags
|
=
BDF_BITMAP_
;
goto
Exit
;
}
FT_ERROR
(
(
"
bdf_parse_glyphs_
:
"
ERRMSG9
lineno
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
Missing_Encoding
:
FT_ERROR
(
(
"
bdf_parse_glyphs_
:
"
ERRMSG1
lineno
"
ENCODING
"
)
)
;
error
=
FT_THROW
(
Missing_Encoding_Field
)
;
Exit
:
if
(
error
&
&
(
p
-
>
flags
&
BDF_GLYPH_
)
)
FT_FREE
(
p
-
>
glyph_name
)
;
return
error
;
}
static
FT_Error
bdf_parse_properties_
(
char
*
line
unsigned
long
linelen
unsigned
long
lineno
void
*
call_data
void
*
client_data
)
{
unsigned
long
vlen
;
bdf_line_func_t_
*
next
;
bdf_parse_t_
*
p
;
char
*
name
;
char
*
value
;
char
nbuf
[
BUFSIZE
]
;
FT_Error
error
=
FT_Err_Ok
;
FT_UNUSED
(
lineno
)
;
next
=
(
bdf_line_func_t_
*
)
call_data
;
p
=
(
bdf_parse_t_
*
)
client_data
;
if
(
_bdf_strncmp
(
line
"
ENDPROPERTIES
"
13
)
=
=
0
)
{
if
(
bdf_get_font_property
(
p
-
>
font
"
FONT_ASCENT
"
)
=
=
0
)
{
p
-
>
font
-
>
font_ascent
=
p
-
>
font
-
>
bbx
.
ascent
;
ft_snprintf
(
nbuf
BUFSIZE
"
%
hd
"
p
-
>
font
-
>
bbx
.
ascent
)
;
error
=
bdf_add_property_
(
p
-
>
font
"
FONT_ASCENT
"
nbuf
lineno
)
;
if
(
error
)
goto
Exit
;
FT_TRACE2
(
(
"
bdf_parse_properties_
:
"
ACMSG1
p
-
>
font
-
>
bbx
.
ascent
)
)
;
}
if
(
bdf_get_font_property
(
p
-
>
font
"
FONT_DESCENT
"
)
=
=
0
)
{
p
-
>
font
-
>
font_descent
=
p
-
>
font
-
>
bbx
.
descent
;
ft_snprintf
(
nbuf
BUFSIZE
"
%
hd
"
p
-
>
font
-
>
bbx
.
descent
)
;
error
=
bdf_add_property_
(
p
-
>
font
"
FONT_DESCENT
"
nbuf
lineno
)
;
if
(
error
)
goto
Exit
;
FT_TRACE2
(
(
"
bdf_parse_properties_
:
"
ACMSG2
p
-
>
font
-
>
bbx
.
descent
)
)
;
}
p
-
>
flags
&
=
~
BDF_PROPS_
;
*
next
=
bdf_parse_glyphs_
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
_XFREE86_GLYPH_RANGES
"
21
)
=
=
0
)
goto
Exit
;
if
(
_bdf_strncmp
(
line
"
COMMENT
"
7
)
=
=
0
)
{
name
=
value
=
line
;
value
+
=
7
;
if
(
*
value
)
*
value
+
+
=
0
;
error
=
bdf_add_property_
(
p
-
>
font
name
value
lineno
)
;
if
(
error
)
goto
Exit
;
}
else
if
(
bdf_is_atom_
(
line
linelen
&
name
&
value
p
-
>
font
)
)
{
error
=
bdf_add_property_
(
p
-
>
font
name
value
lineno
)
;
if
(
error
)
goto
Exit
;
}
else
{
error
=
bdf_list_split_
(
&
p
-
>
list
"
+
"
line
linelen
)
;
if
(
error
)
goto
Exit
;
name
=
p
-
>
list
.
field
[
0
]
;
bdf_list_shift_
(
&
p
-
>
list
1
)
;
value
=
bdf_list_join_
(
&
p
-
>
list
'
'
&
vlen
)
;
error
=
bdf_add_property_
(
p
-
>
font
name
value
lineno
)
;
if
(
error
)
goto
Exit
;
}
Exit
:
return
error
;
}
static
FT_Error
bdf_parse_start_
(
char
*
line
unsigned
long
linelen
unsigned
long
lineno
void
*
call_data
void
*
client_data
)
{
unsigned
long
slen
;
bdf_line_func_t_
*
next
;
bdf_parse_t_
*
p
;
bdf_font_t
*
font
;
char
*
s
;
FT_Memory
memory
=
NULL
;
FT_Error
error
=
FT_Err_Ok
;
FT_UNUSED
(
lineno
)
;
next
=
(
bdf_line_func_t_
*
)
call_data
;
p
=
(
bdf_parse_t_
*
)
client_data
;
if
(
p
-
>
font
)
memory
=
p
-
>
font
-
>
memory
;
if
(
_bdf_strncmp
(
line
"
COMMENT
"
7
)
=
=
0
)
{
if
(
p
-
>
opts
-
>
keep_comments
&
&
p
-
>
font
)
{
linelen
-
=
7
;
s
=
line
+
7
;
if
(
*
s
!
=
0
)
{
s
+
+
;
linelen
-
-
;
}
error
=
bdf_add_comment_
(
p
-
>
font
s
linelen
)
;
}
goto
Exit
;
}
if
(
!
(
p
-
>
flags
&
BDF_START_
)
)
{
memory
=
p
-
>
memory
;
if
(
_bdf_strncmp
(
line
"
STARTFONT
"
9
)
!
=
0
)
{
error
=
FT_THROW
(
Missing_Startfont_Field
)
;
goto
Exit
;
}
p
-
>
flags
=
BDF_START_
;
font
=
p
-
>
font
=
NULL
;
if
(
FT_NEW
(
font
)
)
goto
Exit
;
p
-
>
font
=
font
;
font
-
>
memory
=
p
-
>
memory
;
{
size_t
i
;
bdf_property_t
*
prop
;
error
=
ft_hash_str_init
(
&
(
font
-
>
proptbl
)
memory
)
;
if
(
error
)
goto
Exit
;
for
(
i
=
0
prop
=
(
bdf_property_t
*
)
bdf_properties_
;
i
<
num_bdf_properties_
;
i
+
+
prop
+
+
)
{
error
=
ft_hash_str_insert
(
prop
-
>
name
i
&
(
font
-
>
proptbl
)
memory
)
;
if
(
error
)
goto
Exit
;
}
}
if
(
FT_QALLOC
(
p
-
>
font
-
>
internal
sizeof
(
FT_HashRec
)
)
)
goto
Exit
;
error
=
ft_hash_str_init
(
(
FT_Hash
)
p
-
>
font
-
>
internal
memory
)
;
if
(
error
)
goto
Exit
;
p
-
>
font
-
>
spacing
=
p
-
>
opts
-
>
font_spacing
;
p
-
>
font
-
>
default_char
=
~
0UL
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
STARTPROPERTIES
"
15
)
=
=
0
)
{
if
(
!
(
p
-
>
flags
&
BDF_FONT_BBX_
)
)
{
FT_ERROR
(
(
"
bdf_parse_start_
:
"
ERRMSG1
lineno
"
FONTBOUNDINGBOX
"
)
)
;
error
=
FT_THROW
(
Missing_Fontboundingbox_Field
)
;
goto
Exit
;
}
error
=
bdf_list_split_
(
&
p
-
>
list
"
+
"
line
linelen
)
;
if
(
error
)
goto
Exit
;
p
-
>
cnt
=
p
-
>
font
-
>
props_size
=
bdf_atoul_
(
p
-
>
list
.
field
[
1
]
)
;
if
(
p
-
>
cnt
>
p
-
>
size
/
4
)
{
p
-
>
font
-
>
props_size
=
0
;
FT_ERROR
(
(
"
bdf_parse_glyphs_
:
"
ERRMSG5
lineno
"
STARTPROPERTIES
"
)
)
;
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
FT_NEW_ARRAY
(
p
-
>
font
-
>
props
p
-
>
cnt
)
)
{
p
-
>
font
-
>
props_size
=
0
;
goto
Exit
;
}
p
-
>
flags
|
=
BDF_PROPS_
;
*
next
=
bdf_parse_properties_
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
FONTBOUNDINGBOX
"
15
)
=
=
0
)
{
if
(
!
(
p
-
>
flags
&
BDF_SIZE_
)
)
{
FT_ERROR
(
(
"
bdf_parse_start_
:
"
ERRMSG1
lineno
"
SIZE
"
)
)
;
error
=
FT_THROW
(
Missing_Size_Field
)
;
goto
Exit
;
}
error
=
bdf_list_split_
(
&
p
-
>
list
"
+
"
line
linelen
)
;
if
(
error
)
goto
Exit
;
p
-
>
font
-
>
bbx
.
width
=
bdf_atous_
(
p
-
>
list
.
field
[
1
]
)
;
p
-
>
font
-
>
bbx
.
height
=
bdf_atous_
(
p
-
>
list
.
field
[
2
]
)
;
p
-
>
font
-
>
bbx
.
x_offset
=
bdf_atos_
(
p
-
>
list
.
field
[
3
]
)
;
p
-
>
font
-
>
bbx
.
y_offset
=
bdf_atos_
(
p
-
>
list
.
field
[
4
]
)
;
p
-
>
font
-
>
bbx
.
ascent
=
(
short
)
(
p
-
>
font
-
>
bbx
.
height
+
p
-
>
font
-
>
bbx
.
y_offset
)
;
p
-
>
font
-
>
bbx
.
descent
=
(
short
)
(
-
p
-
>
font
-
>
bbx
.
y_offset
)
;
p
-
>
flags
|
=
BDF_FONT_BBX_
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
FONT
"
4
)
=
=
0
)
{
error
=
bdf_list_split_
(
&
p
-
>
list
"
+
"
line
linelen
)
;
if
(
error
)
goto
Exit
;
bdf_list_shift_
(
&
p
-
>
list
1
)
;
s
=
bdf_list_join_
(
&
p
-
>
list
'
'
&
slen
)
;
if
(
!
s
)
{
FT_ERROR
(
(
"
bdf_parse_start_
:
"
ERRMSG8
lineno
"
FONT
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
FT_FREE
(
p
-
>
font
-
>
name
)
;
if
(
FT_DUP
(
p
-
>
font
-
>
name
s
slen
+
1
)
)
goto
Exit
;
error
=
bdf_set_default_spacing_
(
p
-
>
font
p
-
>
opts
lineno
)
;
if
(
error
)
goto
Exit
;
p
-
>
flags
|
=
BDF_FONT_NAME_
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
SIZE
"
4
)
=
=
0
)
{
if
(
!
(
p
-
>
flags
&
BDF_FONT_NAME_
)
)
{
FT_ERROR
(
(
"
bdf_parse_start_
:
"
ERRMSG1
lineno
"
FONT
"
)
)
;
error
=
FT_THROW
(
Missing_Font_Field
)
;
goto
Exit
;
}
error
=
bdf_list_split_
(
&
p
-
>
list
"
+
"
line
linelen
)
;
if
(
error
)
goto
Exit
;
p
-
>
font
-
>
point_size
=
bdf_atoul_
(
p
-
>
list
.
field
[
1
]
)
;
p
-
>
font
-
>
resolution_x
=
bdf_atoul_
(
p
-
>
list
.
field
[
2
]
)
;
p
-
>
font
-
>
resolution_y
=
bdf_atoul_
(
p
-
>
list
.
field
[
3
]
)
;
if
(
p
-
>
list
.
used
=
=
5
)
{
unsigned
short
bpp
;
bpp
=
bdf_atous_
(
p
-
>
list
.
field
[
4
]
)
;
if
(
bpp
>
4
)
p
-
>
font
-
>
bpp
=
8
;
else
if
(
bpp
>
2
)
p
-
>
font
-
>
bpp
=
4
;
else
if
(
bpp
>
1
)
p
-
>
font
-
>
bpp
=
2
;
else
p
-
>
font
-
>
bpp
=
1
;
if
(
p
-
>
font
-
>
bpp
!
=
bpp
)
FT_TRACE2
(
(
"
bdf_parse_start_
:
"
ACMSG11
p
-
>
font
-
>
bpp
)
)
;
}
else
p
-
>
font
-
>
bpp
=
1
;
p
-
>
flags
|
=
BDF_SIZE_
;
goto
Exit
;
}
if
(
_bdf_strncmp
(
line
"
CHARS
"
5
)
=
=
0
)
{
char
nbuf
[
BUFSIZE
]
;
if
(
!
(
p
-
>
flags
&
BDF_FONT_BBX_
)
)
{
FT_ERROR
(
(
"
bdf_parse_start_
:
"
ERRMSG1
lineno
"
FONTBOUNDINGBOX
"
)
)
;
error
=
FT_THROW
(
Missing_Fontboundingbox_Field
)
;
goto
Exit
;
}
p
-
>
font
-
>
font_ascent
=
p
-
>
font
-
>
bbx
.
ascent
;
ft_snprintf
(
nbuf
BUFSIZE
"
%
hd
"
p
-
>
font
-
>
bbx
.
ascent
)
;
error
=
bdf_add_property_
(
p
-
>
font
"
FONT_ASCENT
"
nbuf
lineno
)
;
if
(
error
)
goto
Exit
;
FT_TRACE2
(
(
"
bdf_parse_properties_
:
"
ACMSG1
p
-
>
font
-
>
bbx
.
ascent
)
)
;
p
-
>
font
-
>
font_descent
=
p
-
>
font
-
>
bbx
.
descent
;
ft_snprintf
(
nbuf
BUFSIZE
"
%
hd
"
p
-
>
font
-
>
bbx
.
descent
)
;
error
=
bdf_add_property_
(
p
-
>
font
"
FONT_DESCENT
"
nbuf
lineno
)
;
if
(
error
)
goto
Exit
;
FT_TRACE2
(
(
"
bdf_parse_properties_
:
"
ACMSG2
p
-
>
font
-
>
bbx
.
descent
)
)
;
*
next
=
bdf_parse_glyphs_
;
error
=
-
1
;
goto
Exit
;
}
FT_ERROR
(
(
"
bdf_parse_start_
:
"
ERRMSG9
lineno
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
Exit
:
return
error
;
}
FT_LOCAL_DEF
(
FT_Error
)
bdf_load_font
(
FT_Stream
stream
FT_Memory
memory
bdf_options_t
*
opts
bdf_font_t
*
*
font
)
{
unsigned
long
lineno
=
0
;
bdf_parse_t_
*
p
=
NULL
;
FT_Error
error
=
FT_Err_Ok
;
if
(
FT_NEW
(
p
)
)
goto
Exit
;
p
-
>
opts
=
(
bdf_options_t
*
)
(
opts
?
opts
:
&
bdf_opts_
)
;
p
-
>
minlb
=
32767
;
p
-
>
size
=
stream
-
>
size
;
p
-
>
memory
=
memory
;
bdf_list_init_
(
&
p
-
>
list
memory
)
;
error
=
bdf_readstream_
(
stream
bdf_parse_start_
(
void
*
)
p
&
lineno
)
;
if
(
error
)
goto
Fail
;
if
(
p
-
>
font
)
{
if
(
p
-
>
font
-
>
spacing
!
=
BDF_PROPORTIONAL
)
p
-
>
font
-
>
monowidth
=
p
-
>
font
-
>
bbx
.
width
;
if
(
p
-
>
cnt
!
=
p
-
>
font
-
>
glyphs_used
+
p
-
>
font
-
>
unencoded_used
)
{
FT_TRACE2
(
(
"
bdf_load_font
:
"
ACMSG15
p
-
>
cnt
p
-
>
font
-
>
glyphs_used
+
p
-
>
font
-
>
unencoded_used
)
)
;
}
if
(
p
-
>
opts
-
>
correct_metrics
!
=
0
&
&
(
p
-
>
font
-
>
glyphs_used
>
0
|
|
p
-
>
font
-
>
unencoded_used
>
0
)
)
{
if
(
p
-
>
maxrb
-
p
-
>
minlb
!
=
p
-
>
font
-
>
bbx
.
width
)
{
FT_TRACE2
(
(
"
bdf_load_font
:
"
ACMSG3
p
-
>
font
-
>
bbx
.
width
p
-
>
maxrb
-
p
-
>
minlb
)
)
;
p
-
>
font
-
>
bbx
.
width
=
(
unsigned
short
)
(
p
-
>
maxrb
-
p
-
>
minlb
)
;
}
if
(
p
-
>
font
-
>
bbx
.
x_offset
!
=
p
-
>
minlb
)
{
FT_TRACE2
(
(
"
bdf_load_font
:
"
ACMSG4
p
-
>
font
-
>
bbx
.
x_offset
p
-
>
minlb
)
)
;
p
-
>
font
-
>
bbx
.
x_offset
=
p
-
>
minlb
;
}
if
(
p
-
>
font
-
>
bbx
.
ascent
!
=
p
-
>
maxas
)
{
FT_TRACE2
(
(
"
bdf_load_font
:
"
ACMSG5
p
-
>
font
-
>
bbx
.
ascent
p
-
>
maxas
)
)
;
p
-
>
font
-
>
bbx
.
ascent
=
p
-
>
maxas
;
}
if
(
p
-
>
font
-
>
bbx
.
descent
!
=
p
-
>
maxds
)
{
FT_TRACE2
(
(
"
bdf_load_font
:
"
ACMSG6
p
-
>
font
-
>
bbx
.
descent
p
-
>
maxds
)
)
;
p
-
>
font
-
>
bbx
.
descent
=
p
-
>
maxds
;
p
-
>
font
-
>
bbx
.
y_offset
=
(
short
)
(
-
p
-
>
maxds
)
;
}
if
(
p
-
>
maxas
+
p
-
>
maxds
!
=
p
-
>
font
-
>
bbx
.
height
)
{
FT_TRACE2
(
(
"
bdf_load_font
:
"
ACMSG7
p
-
>
font
-
>
bbx
.
height
p
-
>
maxas
+
p
-
>
maxds
)
)
;
p
-
>
font
-
>
bbx
.
height
=
(
unsigned
short
)
(
p
-
>
maxas
+
p
-
>
maxds
)
;
}
if
(
p
-
>
flags
&
BDF_SWIDTH_ADJ_
)
FT_TRACE2
(
(
"
bdf_load_font
:
"
ACMSG8
)
)
;
}
}
if
(
p
-
>
flags
&
BDF_START_
)
{
if
(
!
(
p
-
>
flags
&
BDF_GLYPHS_
)
)
{
FT_ERROR
(
(
"
bdf_load_font
:
"
ERRMSG2
lineno
)
)
;
error
=
FT_THROW
(
Corrupted_Font_Header
)
;
goto
Fail
;
}
else
{
FT_ERROR
(
(
"
bdf_load_font
:
"
ERRMSG3
lineno
)
)
;
error
=
FT_THROW
(
Corrupted_Font_Glyphs
)
;
goto
Fail
;
}
}
if
(
!
p
-
>
font
&
&
!
error
)
error
=
FT_THROW
(
Invalid_File_Format
)
;
*
font
=
p
-
>
font
;
Exit
:
if
(
p
)
{
bdf_list_done_
(
&
p
-
>
list
)
;
FT_FREE
(
p
-
>
glyph_name
)
;
FT_FREE
(
p
)
;
}
return
error
;
Fail
:
bdf_free_font
(
p
-
>
font
)
;
FT_FREE
(
p
-
>
font
)
;
goto
Exit
;
}
FT_LOCAL_DEF
(
void
)
bdf_free_font
(
bdf_font_t
*
font
)
{
bdf_property_t
*
prop
;
unsigned
long
i
;
bdf_glyph_t
*
glyphs
;
FT_Memory
memory
;
if
(
font
=
=
NULL
)
return
;
memory
=
font
-
>
memory
;
FT_FREE
(
font
-
>
name
)
;
if
(
font
-
>
internal
)
{
ft_hash_str_free
(
(
FT_Hash
)
font
-
>
internal
memory
)
;
FT_FREE
(
font
-
>
internal
)
;
}
FT_FREE
(
font
-
>
comments
)
;
for
(
i
=
0
;
i
<
font
-
>
props_size
;
i
+
+
)
{
if
(
font
-
>
props
[
i
]
.
format
=
=
BDF_ATOM
)
FT_FREE
(
font
-
>
props
[
i
]
.
value
.
atom
)
;
}
FT_FREE
(
font
-
>
props
)
;
for
(
i
=
0
glyphs
=
font
-
>
glyphs
;
i
<
font
-
>
glyphs_used
;
i
+
+
glyphs
+
+
)
{
FT_FREE
(
glyphs
-
>
name
)
;
FT_FREE
(
glyphs
-
>
bitmap
)
;
}
for
(
i
=
0
glyphs
=
font
-
>
unencoded
;
i
<
font
-
>
unencoded_used
;
i
+
+
glyphs
+
+
)
{
FT_FREE
(
glyphs
-
>
name
)
;
FT_FREE
(
glyphs
-
>
bitmap
)
;
}
FT_FREE
(
font
-
>
glyphs
)
;
FT_FREE
(
font
-
>
unencoded
)
;
ft_hash_str_free
(
&
(
font
-
>
proptbl
)
memory
)
;
for
(
prop
=
font
-
>
user_props
i
=
0
;
i
<
font
-
>
nuser_props
;
i
+
+
prop
+
+
)
FT_FREE
(
prop
-
>
name
)
;
FT_FREE
(
font
-
>
user_props
)
;
}
FT_LOCAL_DEF
(
bdf_property_t
*
)
bdf_get_font_property
(
bdf_font_t
*
font
const
char
*
name
)
{
size_t
*
propid
;
if
(
font
=
=
NULL
|
|
font
-
>
props_size
=
=
0
|
|
name
=
=
NULL
|
|
*
name
=
=
0
)
return
0
;
propid
=
ft_hash_str_lookup
(
name
(
FT_Hash
)
font
-
>
internal
)
;
return
propid
?
(
font
-
>
props
+
*
propid
)
:
0
;
}
