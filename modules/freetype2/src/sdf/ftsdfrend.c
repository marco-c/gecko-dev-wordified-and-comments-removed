#
include
<
freetype
/
internal
/
ftdebug
.
h
>
#
include
<
freetype
/
internal
/
ftobjs
.
h
>
#
include
<
freetype
/
internal
/
services
/
svprop
.
h
>
#
include
<
freetype
/
ftoutln
.
h
>
#
include
<
freetype
/
ftbitmap
.
h
>
#
include
"
ftsdfrend
.
h
"
#
include
"
ftsdf
.
h
"
#
include
"
ftsdferrs
.
h
"
#
undef
FT_COMPONENT
#
define
FT_COMPONENT
sdf
#
define
SDF_RENDERER
(
rend
)
(
(
SDF_Renderer
)
rend
)
static
FT_Error
sdf_property_set
(
FT_Module
module
const
char
*
property_name
const
void
*
value
FT_Bool
value_is_string
)
{
FT_Error
error
=
FT_Err_Ok
;
SDF_Renderer
render
=
SDF_RENDERER
(
FT_RENDERER
(
module
)
)
;
FT_UNUSED
(
value_is_string
)
;
if
(
ft_strcmp
(
property_name
"
spread
"
)
=
=
0
)
{
FT_Int
val
=
*
(
const
FT_Int
*
)
value
;
if
(
val
>
MAX_SPREAD
|
|
val
<
MIN_SPREAD
)
{
FT_TRACE0
(
(
"
[
sdf
]
sdf_property_set
:
"
"
the
spread
'
property
can
have
a
value
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
within
range
[
%
d
%
d
]
(
value
provided
:
%
d
)
\
n
"
MIN_SPREAD
MAX_SPREAD
val
)
)
;
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
render
-
>
spread
=
(
FT_UInt
)
val
;
FT_TRACE7
(
(
"
[
sdf
]
sdf_property_set
:
"
"
updated
property
spread
'
to
%
d
\
n
"
val
)
)
;
}
else
if
(
ft_strcmp
(
property_name
"
flip_sign
"
)
=
=
0
)
{
FT_Int
val
=
*
(
const
FT_Int
*
)
value
;
render
-
>
flip_sign
=
val
?
1
:
0
;
FT_TRACE7
(
(
"
[
sdf
]
sdf_property_set
:
"
"
updated
property
flip_sign
'
to
%
d
\
n
"
val
)
)
;
}
else
if
(
ft_strcmp
(
property_name
"
flip_y
"
)
=
=
0
)
{
FT_Int
val
=
*
(
const
FT_Int
*
)
value
;
render
-
>
flip_y
=
val
?
1
:
0
;
FT_TRACE7
(
(
"
[
sdf
]
sdf_property_set
:
"
"
updated
property
flip_y
'
to
%
d
\
n
"
val
)
)
;
}
else
if
(
ft_strcmp
(
property_name
"
overlaps
"
)
=
=
0
)
{
FT_Bool
val
=
*
(
const
FT_Bool
*
)
value
;
render
-
>
overlaps
=
val
;
FT_TRACE7
(
(
"
[
sdf
]
sdf_property_set
:
"
"
updated
property
overlaps
'
to
%
d
\
n
"
val
)
)
;
}
else
{
FT_TRACE0
(
(
"
[
sdf
]
sdf_property_set
:
"
"
missing
property
%
s
'
\
n
"
property_name
)
)
;
error
=
FT_THROW
(
Missing_Property
)
;
}
Exit
:
return
error
;
}
static
FT_Error
sdf_property_get
(
FT_Module
module
const
char
*
property_name
void
*
value
)
{
FT_Error
error
=
FT_Err_Ok
;
SDF_Renderer
render
=
SDF_RENDERER
(
FT_RENDERER
(
module
)
)
;
if
(
ft_strcmp
(
property_name
"
spread
"
)
=
=
0
)
{
FT_UInt
*
val
=
(
FT_UInt
*
)
value
;
*
val
=
render
-
>
spread
;
}
else
if
(
ft_strcmp
(
property_name
"
flip_sign
"
)
=
=
0
)
{
FT_Int
*
val
=
(
FT_Int
*
)
value
;
*
val
=
render
-
>
flip_sign
;
}
else
if
(
ft_strcmp
(
property_name
"
flip_y
"
)
=
=
0
)
{
FT_Int
*
val
=
(
FT_Int
*
)
value
;
*
val
=
render
-
>
flip_y
;
}
else
if
(
ft_strcmp
(
property_name
"
overlaps
"
)
=
=
0
)
{
FT_Int
*
val
=
(
FT_Int
*
)
value
;
*
val
=
render
-
>
overlaps
;
}
else
{
FT_TRACE0
(
(
"
[
sdf
]
sdf_property_get
:
"
"
missing
property
%
s
'
\
n
"
property_name
)
)
;
error
=
FT_THROW
(
Missing_Property
)
;
}
return
error
;
}
FT_DEFINE_SERVICE_PROPERTIESREC
(
sdf_service_properties
(
FT_Properties_SetFunc
)
sdf_property_set
(
FT_Properties_GetFunc
)
sdf_property_get
)
FT_DEFINE_SERVICEDESCREC1
(
sdf_services
FT_SERVICE_ID_PROPERTIES
&
sdf_service_properties
)
static
FT_Module_Interface
ft_sdf_requester
(
FT_Module
module
const
char
*
module_interface
)
{
FT_UNUSED
(
module
)
;
return
ft_service_list_lookup
(
sdf_services
module_interface
)
;
}
static
FT_Error
ft_sdf_init
(
FT_Module
module
)
{
SDF_Renderer
sdf_render
=
SDF_RENDERER
(
module
)
;
sdf_render
-
>
spread
=
DEFAULT_SPREAD
;
sdf_render
-
>
flip_sign
=
0
;
sdf_render
-
>
flip_y
=
0
;
sdf_render
-
>
overlaps
=
0
;
return
FT_Err_Ok
;
}
static
void
ft_sdf_done
(
FT_Module
module
)
{
FT_UNUSED
(
module
)
;
}
static
FT_Error
ft_sdf_render
(
FT_Renderer
module
FT_GlyphSlot
slot
FT_Render_Mode
mode
const
FT_Vector
*
origin
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Outline
*
outline
=
&
slot
-
>
outline
;
FT_Bitmap
*
bitmap
=
&
slot
-
>
bitmap
;
FT_Memory
memory
=
NULL
;
FT_Renderer
render
=
NULL
;
FT_Pos
x_shift
=
0
;
FT_Pos
y_shift
=
0
;
FT_Pos
x_pad
=
0
;
FT_Pos
y_pad
=
0
;
SDF_Raster_Params
params
;
SDF_Renderer
sdf_module
=
SDF_RENDERER
(
module
)
;
render
=
&
sdf_module
-
>
root
;
memory
=
render
-
>
root
.
memory
;
if
(
slot
-
>
format
!
=
render
-
>
glyph_format
)
{
error
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
Exit
;
}
if
(
mode
!
=
FT_RENDER_MODE_SDF
)
{
error
=
FT_THROW
(
Cannot_Render_Glyph
)
;
goto
Exit
;
}
if
(
slot
-
>
internal
-
>
flags
&
FT_GLYPH_OWN_BITMAP
)
{
FT_FREE
(
bitmap
-
>
buffer
)
;
slot
-
>
internal
-
>
flags
&
=
~
FT_GLYPH_OWN_BITMAP
;
}
if
(
ft_glyphslot_preset_bitmap
(
slot
FT_RENDER_MODE_NORMAL
origin
)
)
{
error
=
FT_THROW
(
Raster_Overflow
)
;
goto
Exit
;
}
if
(
!
bitmap
-
>
rows
|
|
!
bitmap
-
>
pitch
)
goto
Exit
;
x_pad
=
sdf_module
-
>
spread
;
y_pad
=
sdf_module
-
>
spread
;
bitmap
-
>
rows
+
=
y_pad
*
2
;
bitmap
-
>
width
+
=
x_pad
*
2
;
bitmap
-
>
pixel_mode
=
FT_PIXEL_MODE_GRAY
;
bitmap
-
>
pitch
=
(
int
)
(
bitmap
-
>
width
)
;
bitmap
-
>
num_grays
=
255
;
if
(
FT_ALLOC_MULT
(
bitmap
-
>
buffer
bitmap
-
>
rows
bitmap
-
>
pitch
)
)
goto
Exit
;
slot
-
>
internal
-
>
flags
|
=
FT_GLYPH_OWN_BITMAP
;
slot
-
>
bitmap_top
+
=
y_pad
;
slot
-
>
bitmap_left
-
=
x_pad
;
x_shift
=
64
*
-
slot
-
>
bitmap_left
;
y_shift
=
64
*
-
slot
-
>
bitmap_top
;
y_shift
+
=
64
*
(
FT_Int
)
bitmap
-
>
rows
;
if
(
origin
)
{
x_shift
+
=
origin
-
>
x
;
y_shift
+
=
origin
-
>
y
;
}
if
(
x_shift
|
|
y_shift
)
FT_Outline_Translate
(
outline
x_shift
y_shift
)
;
params
.
root
.
target
=
bitmap
;
params
.
root
.
source
=
outline
;
params
.
root
.
flags
=
FT_RASTER_FLAG_SDF
;
params
.
spread
=
sdf_module
-
>
spread
;
params
.
flip_sign
=
sdf_module
-
>
flip_sign
;
params
.
flip_y
=
sdf_module
-
>
flip_y
;
params
.
overlaps
=
sdf_module
-
>
overlaps
;
error
=
render
-
>
raster_render
(
render
-
>
raster
(
const
FT_Raster_Params
*
)
&
params
)
;
if
(
x_shift
|
|
y_shift
)
FT_Outline_Translate
(
outline
-
x_shift
-
y_shift
)
;
Exit
:
if
(
!
error
)
{
slot
-
>
format
=
FT_GLYPH_FORMAT_BITMAP
;
}
else
if
(
slot
-
>
internal
-
>
flags
&
FT_GLYPH_OWN_BITMAP
)
{
FT_FREE
(
bitmap
-
>
buffer
)
;
slot
-
>
internal
-
>
flags
&
=
~
FT_GLYPH_OWN_BITMAP
;
}
return
error
;
}
static
FT_Error
ft_sdf_transform
(
FT_Renderer
render
FT_GlyphSlot
slot
const
FT_Matrix
*
matrix
const
FT_Vector
*
delta
)
{
FT_Error
error
=
FT_Err_Ok
;
if
(
slot
-
>
format
!
=
render
-
>
glyph_format
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
matrix
)
FT_Outline_Transform
(
&
slot
-
>
outline
matrix
)
;
if
(
delta
)
FT_Outline_Translate
(
&
slot
-
>
outline
delta
-
>
x
delta
-
>
y
)
;
Exit
:
return
error
;
}
static
void
ft_sdf_get_cbox
(
FT_Renderer
render
FT_GlyphSlot
slot
FT_BBox
*
cbox
)
{
FT_ZERO
(
cbox
)
;
if
(
slot
-
>
format
=
=
render
-
>
glyph_format
)
FT_Outline_Get_CBox
(
&
slot
-
>
outline
cbox
)
;
}
static
FT_Error
ft_sdf_set_mode
(
FT_Renderer
render
FT_ULong
mode_tag
FT_Pointer
data
)
{
return
render
-
>
clazz
-
>
raster_class
-
>
raster_set_mode
(
render
-
>
raster
mode_tag
data
)
;
}
FT_DEFINE_RENDERER
(
ft_sdf_renderer_class
FT_MODULE_RENDERER
sizeof
(
SDF_Renderer_Module
)
"
sdf
"
0x10000L
0x20000L
NULL
(
FT_Module_Constructor
)
ft_sdf_init
(
FT_Module_Destructor
)
ft_sdf_done
(
FT_Module_Requester
)
ft_sdf_requester
FT_GLYPH_FORMAT_OUTLINE
(
FT_Renderer_RenderFunc
)
ft_sdf_render
(
FT_Renderer_TransformFunc
)
ft_sdf_transform
(
FT_Renderer_GetCBoxFunc
)
ft_sdf_get_cbox
(
FT_Renderer_SetModeFunc
)
ft_sdf_set_mode
(
FT_Raster_Funcs
*
)
&
ft_sdf_raster
)
static
FT_Error
ft_bsdf_render
(
FT_Renderer
module
FT_GlyphSlot
slot
FT_Render_Mode
mode
const
FT_Vector
*
origin
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Memory
memory
=
NULL
;
FT_Bitmap
*
bitmap
=
&
slot
-
>
bitmap
;
FT_Renderer
render
=
NULL
;
FT_Bitmap
target
;
FT_Pos
x_pad
=
0
;
FT_Pos
y_pad
=
0
;
SDF_Raster_Params
params
;
SDF_Renderer
sdf_module
=
SDF_RENDERER
(
module
)
;
FT_Bitmap_Init
(
&
target
)
;
render
=
&
sdf_module
-
>
root
;
memory
=
render
-
>
root
.
memory
;
if
(
slot
-
>
format
!
=
render
-
>
glyph_format
)
{
error
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
Exit
;
}
if
(
mode
!
=
FT_RENDER_MODE_SDF
)
{
error
=
FT_THROW
(
Cannot_Render_Glyph
)
;
goto
Exit
;
}
if
(
origin
)
{
FT_ERROR
(
(
"
ft_bsdf_render
:
can
'
t
translate
the
bitmap
\
n
"
)
)
;
error
=
FT_THROW
(
Unimplemented_Feature
)
;
goto
Exit
;
}
if
(
!
bitmap
-
>
rows
|
|
!
bitmap
-
>
pitch
)
goto
Exit
;
if
(
!
(
slot
-
>
internal
-
>
flags
&
FT_GLYPH_OWN_BITMAP
)
)
{
FT_ERROR
(
(
"
ft_bsdf_render
:
can
'
t
generate
SDF
from
"
"
unowned
source
bitmap
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
FT_Bitmap_New
(
&
target
)
;
x_pad
=
sdf_module
-
>
spread
;
y_pad
=
sdf_module
-
>
spread
;
target
.
rows
=
bitmap
-
>
rows
+
y_pad
*
2
;
target
.
width
=
bitmap
-
>
width
+
x_pad
*
2
;
target
.
pixel_mode
=
FT_PIXEL_MODE_GRAY
;
target
.
pitch
=
(
int
)
(
target
.
width
)
;
target
.
num_grays
=
255
;
if
(
FT_ALLOC_MULT
(
target
.
buffer
target
.
rows
target
.
pitch
)
)
goto
Exit
;
params
.
root
.
target
=
&
target
;
params
.
root
.
source
=
bitmap
;
params
.
root
.
flags
=
FT_RASTER_FLAG_SDF
;
params
.
spread
=
sdf_module
-
>
spread
;
params
.
flip_sign
=
sdf_module
-
>
flip_sign
;
params
.
flip_y
=
sdf_module
-
>
flip_y
;
error
=
render
-
>
raster_render
(
render
-
>
raster
(
const
FT_Raster_Params
*
)
&
params
)
;
Exit
:
if
(
!
error
)
{
if
(
slot
-
>
internal
-
>
flags
&
FT_GLYPH_OWN_BITMAP
)
FT_FREE
(
bitmap
-
>
buffer
)
;
slot
-
>
bitmap
=
target
;
slot
-
>
bitmap_top
+
=
y_pad
;
slot
-
>
bitmap_left
-
=
x_pad
;
if
(
target
.
buffer
)
slot
-
>
internal
-
>
flags
|
=
FT_GLYPH_OWN_BITMAP
;
}
else
if
(
target
.
buffer
)
FT_FREE
(
target
.
buffer
)
;
return
error
;
}
FT_DEFINE_RENDERER
(
ft_bitmap_sdf_renderer_class
FT_MODULE_RENDERER
sizeof
(
SDF_Renderer_Module
)
"
bsdf
"
0x10000L
0x20000L
NULL
(
FT_Module_Constructor
)
ft_sdf_init
(
FT_Module_Destructor
)
ft_sdf_done
(
FT_Module_Requester
)
ft_sdf_requester
FT_GLYPH_FORMAT_BITMAP
(
FT_Renderer_RenderFunc
)
ft_bsdf_render
(
FT_Renderer_TransformFunc
)
ft_sdf_transform
(
FT_Renderer_GetCBoxFunc
)
ft_sdf_get_cbox
(
FT_Renderer_SetModeFunc
)
ft_sdf_set_mode
(
FT_Raster_Funcs
*
)
&
ft_bitmap_sdf_raster
)
