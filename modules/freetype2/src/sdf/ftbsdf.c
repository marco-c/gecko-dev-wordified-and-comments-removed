#
include
<
freetype
/
internal
/
ftobjs
.
h
>
#
include
<
freetype
/
internal
/
ftdebug
.
h
>
#
include
<
freetype
/
internal
/
ftmemory
.
h
>
#
include
<
freetype
/
fttrigon
.
h
>
#
include
"
ftsdf
.
h
"
#
include
"
ftsdferrs
.
h
"
#
include
"
ftsdfcommon
.
h
"
#
undef
FT_COMPONENT
#
define
FT_COMPONENT
bsdf
#
define
ONE
65536
/
*
1
in
16
.
16
*
/
typedef
struct
BSDF_TRaster_
{
FT_Memory
memory
;
}
BSDF_TRaster
*
BSDF_PRaster
;
typedef
struct
ED_
{
FT_16D16
dist
;
FT_16D16_Vec
prox
;
FT_Byte
alpha
;
}
ED
;
typedef
struct
BSDF_Worker_
{
ED
*
distance_map
;
FT_Int
width
;
FT_Int
rows
;
SDF_Raster_Params
params
;
}
BSDF_Worker
;
static
const
ED
zero_ed
=
{
0
{
0
0
}
0
}
;
#
ifdef
CHECK_NEIGHBOR
#
undef
CHECK_NEIGHBOR
#
endif
#
define
CHECK_NEIGHBOR
(
x_offset
y_offset
)
\
do
\
{
\
if
(
x
+
x_offset
>
=
0
&
&
x
+
x_offset
<
w
&
&
\
y
+
y_offset
>
=
0
&
&
y
+
y_offset
<
r
)
\
{
\
num_neighbors
+
+
;
\
\
to_check
=
dm
+
y_offset
*
w
+
x_offset
;
\
if
(
to_check
-
>
alpha
=
=
0
)
\
{
\
is_edge
=
1
;
\
goto
Done
;
\
}
\
}
\
}
while
(
0
)
static
FT_Bool
bsdf_is_edge
(
ED
*
dm
FT_Int
x
FT_Int
y
FT_Int
w
FT_Int
r
)
{
FT_Bool
is_edge
=
0
;
ED
*
to_check
=
NULL
;
FT_Int
num_neighbors
=
0
;
if
(
dm
-
>
alpha
=
=
0
)
goto
Done
;
if
(
dm
-
>
alpha
>
0
&
&
dm
-
>
alpha
<
255
)
{
is_edge
=
1
;
goto
Done
;
}
CHECK_NEIGHBOR
(
0
-
1
)
;
CHECK_NEIGHBOR
(
0
1
)
;
CHECK_NEIGHBOR
(
-
1
0
)
;
CHECK_NEIGHBOR
(
1
0
)
;
CHECK_NEIGHBOR
(
-
1
-
1
)
;
CHECK_NEIGHBOR
(
1
-
1
)
;
CHECK_NEIGHBOR
(
-
1
1
)
;
CHECK_NEIGHBOR
(
1
1
)
;
if
(
num_neighbors
!
=
8
)
is_edge
=
1
;
Done
:
return
is_edge
;
}
#
undef
CHECK_NEIGHBOR
static
FT_16D16_Vec
compute_edge_distance
(
ED
*
current
FT_Int
x
FT_Int
y
FT_Int
w
FT_Int
r
)
{
FT_16D16_Vec
g
=
{
0
0
}
;
FT_16D16
dist
current_alpha
;
FT_16D16
a1
temp
;
FT_16D16
gx
gy
;
FT_16D16
alphas
[
9
]
;
if
(
x
<
=
0
|
|
x
>
=
w
-
1
|
|
y
<
=
0
|
|
y
>
=
r
-
1
)
return
g
;
alphas
[
0
]
=
256
*
(
FT_16D16
)
current
[
-
w
-
1
]
.
alpha
;
alphas
[
1
]
=
256
*
(
FT_16D16
)
current
[
-
w
]
.
alpha
;
alphas
[
2
]
=
256
*
(
FT_16D16
)
current
[
-
w
+
1
]
.
alpha
;
alphas
[
3
]
=
256
*
(
FT_16D16
)
current
[
-
1
]
.
alpha
;
alphas
[
4
]
=
256
*
(
FT_16D16
)
current
[
0
]
.
alpha
;
alphas
[
5
]
=
256
*
(
FT_16D16
)
current
[
1
]
.
alpha
;
alphas
[
6
]
=
256
*
(
FT_16D16
)
current
[
w
-
1
]
.
alpha
;
alphas
[
7
]
=
256
*
(
FT_16D16
)
current
[
w
]
.
alpha
;
alphas
[
8
]
=
256
*
(
FT_16D16
)
current
[
w
+
1
]
.
alpha
;
current_alpha
=
alphas
[
4
]
;
g
.
x
=
-
alphas
[
0
]
-
FT_MulFix
(
alphas
[
3
]
92681
)
-
alphas
[
6
]
+
alphas
[
2
]
+
FT_MulFix
(
alphas
[
5
]
92681
)
+
alphas
[
8
]
;
g
.
y
=
-
alphas
[
0
]
-
FT_MulFix
(
alphas
[
1
]
92681
)
-
alphas
[
2
]
+
alphas
[
6
]
+
FT_MulFix
(
alphas
[
7
]
92681
)
+
alphas
[
8
]
;
FT_Vector_NormLen
(
&
g
)
;
if
(
g
.
x
=
=
0
|
|
g
.
y
=
=
0
)
dist
=
ONE
/
2
-
alphas
[
4
]
;
else
{
gx
=
g
.
x
;
gy
=
g
.
y
;
gx
=
FT_ABS
(
gx
)
;
gy
=
FT_ABS
(
gy
)
;
if
(
gx
<
gy
)
{
temp
=
gx
;
gx
=
gy
;
gy
=
temp
;
}
a1
=
FT_DivFix
(
gy
gx
)
/
2
;
if
(
current_alpha
<
a1
)
dist
=
(
gx
+
gy
)
/
2
-
square_root
(
2
*
FT_MulFix
(
gx
FT_MulFix
(
gy
current_alpha
)
)
)
;
else
if
(
current_alpha
<
(
ONE
-
a1
)
)
dist
=
FT_MulFix
(
ONE
/
2
-
current_alpha
gx
)
;
else
dist
=
-
(
gx
+
gy
)
/
2
+
square_root
(
2
*
FT_MulFix
(
gx
FT_MulFix
(
gy
ONE
-
current_alpha
)
)
)
;
}
g
.
x
=
FT_MulFix
(
g
.
x
dist
)
;
g
.
y
=
FT_MulFix
(
g
.
y
dist
)
;
return
g
;
}
static
FT_Error
bsdf_approximate_edge
(
BSDF_Worker
*
worker
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Int
i
j
;
FT_Int
index
;
ED
*
ed
;
if
(
!
worker
|
|
!
worker
-
>
distance_map
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
ed
=
worker
-
>
distance_map
;
for
(
j
=
0
;
j
<
worker
-
>
rows
;
j
+
+
)
{
for
(
i
=
0
;
i
<
worker
-
>
width
;
i
+
+
)
{
index
=
j
*
worker
-
>
width
+
i
;
if
(
bsdf_is_edge
(
worker
-
>
distance_map
+
index
i
j
worker
-
>
width
worker
-
>
rows
)
)
{
ed
[
index
]
.
prox
=
compute_edge_distance
(
ed
+
index
i
j
worker
-
>
width
worker
-
>
rows
)
;
ed
[
index
]
.
dist
=
VECTOR_LENGTH_16D16
(
ed
[
index
]
.
prox
)
;
}
else
{
ed
[
index
]
.
dist
=
400
*
ONE
;
ed
[
index
]
.
prox
.
x
=
200
*
ONE
;
ed
[
index
]
.
prox
.
y
=
200
*
ONE
;
}
}
}
Exit
:
return
error
;
}
static
FT_Error
bsdf_init_distance_map
(
const
FT_Bitmap
*
source
BSDF_Worker
*
worker
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Int
x_diff
y_diff
;
FT_Int
t_i
t_j
s_i
s_j
;
FT_Byte
*
s
;
ED
*
t
;
if
(
!
source
|
|
!
worker
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
worker
-
>
width
<
(
FT_Int
)
source
-
>
width
|
|
worker
-
>
rows
<
(
FT_Int
)
source
-
>
rows
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
source
-
>
pixel_mode
=
=
FT_PIXEL_MODE_NONE
)
{
FT_ERROR
(
(
"
bsdf_copy_source_to_target
:
"
"
Invalid
pixel
mode
of
source
bitmap
"
)
)
;
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
#
ifdef
FT_DEBUG_LEVEL_TRACE
if
(
source
-
>
pixel_mode
=
=
FT_PIXEL_MODE_MONO
)
{
FT_TRACE0
(
(
"
bsdf_copy_source_to_target
:
"
"
The
bsdf
'
renderer
can
convert
monochrome
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
bitmaps
to
SDF
but
the
results
are
not
perfect
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
because
there
is
no
way
to
approximate
actual
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
outlines
from
monochrome
bitmaps
.
Consider
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
using
an
anti
-
aliased
bitmap
instead
.
\
n
"
)
)
;
}
#
endif
x_diff
=
worker
-
>
width
-
(
int
)
source
-
>
width
;
y_diff
=
worker
-
>
rows
-
(
int
)
source
-
>
rows
;
x_diff
/
=
2
;
y_diff
/
=
2
;
t
=
(
ED
*
)
worker
-
>
distance_map
;
s
=
source
-
>
buffer
;
switch
(
source
-
>
pixel_mode
)
{
case
FT_PIXEL_MODE_MONO
:
{
FT_Int
t_width
=
worker
-
>
width
;
FT_Int
t_rows
=
worker
-
>
rows
;
FT_Int
s_width
=
(
int
)
source
-
>
width
;
FT_Int
s_rows
=
(
int
)
source
-
>
rows
;
for
(
t_j
=
0
;
t_j
<
t_rows
;
t_j
+
+
)
{
for
(
t_i
=
0
;
t_i
<
t_width
;
t_i
+
+
)
{
FT_Int
t_index
=
t_j
*
t_width
+
t_i
;
FT_Int
s_index
;
FT_Int
div
mod
;
FT_Byte
pixel
byte
;
t
[
t_index
]
=
zero_ed
;
s_i
=
t_i
-
x_diff
;
s_j
=
t_j
-
y_diff
;
if
(
s_i
<
0
|
|
s_i
>
=
s_width
|
|
s_j
<
0
|
|
s_j
>
=
s_rows
)
continue
;
if
(
worker
-
>
params
.
flip_y
)
s_index
=
(
s_rows
-
s_j
-
1
)
*
source
-
>
pitch
;
else
s_index
=
s_j
*
source
-
>
pitch
;
div
=
s_index
+
s_i
/
8
;
mod
=
7
-
s_i
%
8
;
pixel
=
s
[
div
]
;
byte
=
(
FT_Byte
)
(
1
<
<
mod
)
;
t
[
t_index
]
.
alpha
=
pixel
&
byte
?
255
:
0
;
}
}
}
break
;
case
FT_PIXEL_MODE_GRAY
:
{
FT_Int
t_width
=
worker
-
>
width
;
FT_Int
t_rows
=
worker
-
>
rows
;
FT_Int
s_width
=
(
int
)
source
-
>
width
;
FT_Int
s_rows
=
(
int
)
source
-
>
rows
;
for
(
t_j
=
0
;
t_j
<
t_rows
;
t_j
+
+
)
{
for
(
t_i
=
0
;
t_i
<
t_width
;
t_i
+
+
)
{
FT_Int
t_index
=
t_j
*
t_width
+
t_i
;
FT_Int
s_index
;
t
[
t_index
]
=
zero_ed
;
s_i
=
t_i
-
x_diff
;
s_j
=
t_j
-
y_diff
;
if
(
s_i
<
0
|
|
s_i
>
=
s_width
|
|
s_j
<
0
|
|
s_j
>
=
s_rows
)
continue
;
if
(
worker
-
>
params
.
flip_y
)
s_index
=
(
s_rows
-
s_j
-
1
)
*
s_width
+
s_i
;
else
s_index
=
s_j
*
s_width
+
s_i
;
t
[
t_index
]
.
alpha
=
s
[
s_index
]
;
}
}
}
break
;
default
:
FT_ERROR
(
(
"
bsdf_copy_source_to_target
:
"
"
unsopported
pixel
mode
of
source
bitmap
\
n
"
)
)
;
error
=
FT_THROW
(
Unimplemented_Feature
)
;
break
;
}
Exit
:
return
error
;
}
static
void
compare_neighbor
(
ED
*
current
FT_Int
x_offset
FT_Int
y_offset
FT_Int
width
)
{
#
if
USE_SQUARED_DISTANCES
FT_16D16
edge_threshold
=
ONE
/
4
;
#
else
FT_16D16
edge_threshold
=
ONE
/
2
;
#
endif
ED
*
to_check
;
FT_16D16
dist
;
FT_16D16_Vec
dist_vec
;
if
(
current
-
>
dist
<
=
edge_threshold
)
return
;
to_check
=
current
+
(
y_offset
*
width
)
+
x_offset
;
dist
=
to_check
-
>
dist
-
ONE
;
if
(
dist
<
current
-
>
dist
)
{
dist_vec
=
to_check
-
>
prox
;
dist_vec
.
x
+
=
x_offset
*
ONE
;
dist_vec
.
y
+
=
y_offset
*
ONE
;
dist
=
VECTOR_LENGTH_16D16
(
dist_vec
)
;
if
(
dist
<
current
-
>
dist
)
{
current
-
>
dist
=
dist
;
current
-
>
prox
=
dist_vec
;
}
}
}
static
void
first_pass
(
BSDF_Worker
*
worker
)
{
FT_Int
i
j
;
FT_Int
w
r
;
ED
*
dm
;
dm
=
worker
-
>
distance_map
;
w
=
worker
-
>
width
;
r
=
worker
-
>
rows
;
for
(
j
=
1
;
j
<
r
;
j
+
+
)
{
FT_Int
index
;
ED
*
current
;
for
(
i
=
1
;
i
<
w
-
1
;
i
+
+
)
{
index
=
j
*
w
+
i
;
current
=
dm
+
index
;
compare_neighbor
(
current
-
1
-
1
w
)
;
compare_neighbor
(
current
0
-
1
w
)
;
compare_neighbor
(
current
1
-
1
w
)
;
compare_neighbor
(
current
-
1
0
w
)
;
}
for
(
i
=
w
-
2
;
i
>
=
0
;
i
-
-
)
{
index
=
j
*
w
+
i
;
current
=
dm
+
index
;
compare_neighbor
(
current
1
0
w
)
;
}
}
}
static
void
second_pass
(
BSDF_Worker
*
worker
)
{
FT_Int
i
j
;
FT_Int
w
r
;
ED
*
dm
;
dm
=
worker
-
>
distance_map
;
w
=
worker
-
>
width
;
r
=
worker
-
>
rows
;
for
(
j
=
r
-
2
;
j
>
=
0
;
j
-
-
)
{
FT_Int
index
;
ED
*
current
;
for
(
i
=
1
;
i
<
w
-
1
;
i
+
+
)
{
index
=
j
*
w
+
i
;
current
=
dm
+
index
;
compare_neighbor
(
current
-
1
1
w
)
;
compare_neighbor
(
current
0
1
w
)
;
compare_neighbor
(
current
1
1
w
)
;
compare_neighbor
(
current
-
1
0
w
)
;
}
for
(
i
=
w
-
2
;
i
>
=
0
;
i
-
-
)
{
index
=
j
*
w
+
i
;
current
=
dm
+
index
;
compare_neighbor
(
current
1
0
w
)
;
}
}
}
static
FT_Error
edt8
(
BSDF_Worker
*
worker
)
{
FT_Error
error
=
FT_Err_Ok
;
if
(
!
worker
|
|
!
worker
-
>
distance_map
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
first_pass
(
worker
)
;
second_pass
(
worker
)
;
Exit
:
return
error
;
}
static
FT_Error
finalize_sdf
(
BSDF_Worker
*
worker
const
FT_Bitmap
*
target
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Int
w
r
;
FT_Int
i
j
;
FT_SDFFormat
*
t_buffer
;
FT_16D16
sp_sq
spread
;
if
(
!
worker
|
|
!
target
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
w
=
(
int
)
target
-
>
width
;
r
=
(
int
)
target
-
>
rows
;
t_buffer
=
(
FT_SDFFormat
*
)
target
-
>
buffer
;
if
(
w
!
=
worker
-
>
width
|
|
r
!
=
worker
-
>
rows
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
spread
=
(
FT_16D16
)
FT_INT_16D16
(
worker
-
>
params
.
spread
)
;
#
if
USE_SQUARED_DISTANCES
sp_sq
=
(
FT_16D16
)
FT_INT_16D16
(
worker
-
>
params
.
spread
*
worker
-
>
params
.
spread
)
;
#
else
sp_sq
=
(
FT_16D16
)
FT_INT_16D16
(
worker
-
>
params
.
spread
)
;
#
endif
for
(
j
=
0
;
j
<
r
;
j
+
+
)
{
for
(
i
=
0
;
i
<
w
;
i
+
+
)
{
FT_Int
index
;
FT_16D16
dist
;
FT_SDFFormat
final_dist
;
FT_Char
sign
;
index
=
j
*
w
+
i
;
dist
=
worker
-
>
distance_map
[
index
]
.
dist
;
if
(
dist
<
0
|
|
dist
>
sp_sq
)
dist
=
sp_sq
;
#
if
USE_SQUARED_DISTANCES
dist
=
square_root
(
dist
)
;
#
endif
sign
=
worker
-
>
distance_map
[
index
]
.
alpha
<
127
?
-
1
:
1
;
if
(
worker
-
>
params
.
flip_sign
)
sign
=
-
sign
;
final_dist
=
map_fixed_to_sdf
(
dist
*
sign
spread
)
;
t_buffer
[
index
]
=
final_dist
;
}
}
Exit
:
return
error
;
}
static
FT_Error
bsdf_raster_new
(
void
*
memory_
FT_Raster
*
araster_
)
{
FT_Memory
memory
=
(
FT_Memory
)
memory_
;
BSDF_PRaster
*
araster
=
(
BSDF_PRaster
*
)
araster_
;
FT_Error
error
;
BSDF_PRaster
raster
=
NULL
;
if
(
!
FT_NEW
(
raster
)
)
raster
-
>
memory
=
memory
;
*
araster
=
raster
;
return
error
;
}
static
void
bsdf_raster_reset
(
FT_Raster
raster
unsigned
char
*
pool_base
unsigned
long
pool_size
)
{
FT_UNUSED
(
raster
)
;
FT_UNUSED
(
pool_base
)
;
FT_UNUSED
(
pool_size
)
;
}
static
FT_Error
bsdf_raster_set_mode
(
FT_Raster
raster
unsigned
long
mode
void
*
args
)
{
FT_UNUSED
(
raster
)
;
FT_UNUSED
(
mode
)
;
FT_UNUSED
(
args
)
;
return
FT_Err_Ok
;
}
static
FT_Error
bsdf_raster_render
(
FT_Raster
raster
const
FT_Raster_Params
*
params
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Memory
memory
=
NULL
;
const
FT_Bitmap
*
source
=
NULL
;
const
FT_Bitmap
*
target
=
NULL
;
BSDF_TRaster
*
bsdf_raster
=
(
BSDF_TRaster
*
)
raster
;
BSDF_Worker
worker
;
const
SDF_Raster_Params
*
sdf_params
=
(
const
SDF_Raster_Params
*
)
params
;
worker
.
distance_map
=
NULL
;
if
(
!
raster
|
|
!
params
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
sdf_params
-
>
root
.
flags
!
=
FT_RASTER_FLAG_SDF
)
{
error
=
FT_THROW
(
Raster_Corrupted
)
;
goto
Exit
;
}
source
=
(
const
FT_Bitmap
*
)
sdf_params
-
>
root
.
source
;
target
=
(
const
FT_Bitmap
*
)
sdf_params
-
>
root
.
target
;
if
(
!
source
|
|
!
target
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
memory
=
bsdf_raster
-
>
memory
;
if
(
!
memory
)
{
FT_TRACE0
(
(
"
bsdf_raster_render
:
Raster
not
set
up
properly
\
n
"
)
)
;
FT_TRACE0
(
(
"
unable
to
find
memory
handle
.
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_Handle
)
;
goto
Exit
;
}
if
(
sdf_params
-
>
spread
>
MAX_SPREAD
|
|
sdf_params
-
>
spread
<
MIN_SPREAD
)
{
FT_TRACE0
(
(
"
bsdf_raster_render
:
"
"
The
spread
'
field
of
SDF_Raster_Params
'
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
is
invalid
;
the
value
of
this
field
must
be
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
within
[
%
d
%
d
]
.
\
n
"
MIN_SPREAD
MAX_SPREAD
)
)
;
FT_TRACE0
(
(
"
"
"
Also
you
must
pass
SDF_Raster_Params
'
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
instead
of
the
default
FT_Raster_Params
'
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
while
calling
this
function
and
set
the
fields
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
accordingly
.
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
FT_QALLOC_MULT
(
worker
.
distance_map
target
-
>
rows
target
-
>
width
*
sizeof
(
*
worker
.
distance_map
)
)
)
goto
Exit
;
worker
.
width
=
(
int
)
target
-
>
width
;
worker
.
rows
=
(
int
)
target
-
>
rows
;
worker
.
params
=
*
sdf_params
;
FT_CALL
(
bsdf_init_distance_map
(
source
&
worker
)
)
;
FT_CALL
(
bsdf_approximate_edge
(
&
worker
)
)
;
FT_CALL
(
edt8
(
&
worker
)
)
;
FT_CALL
(
finalize_sdf
(
&
worker
target
)
)
;
FT_TRACE0
(
(
"
bsdf_raster_render
:
Total
memory
used
=
%
ld
\
n
"
worker
.
width
*
worker
.
rows
*
(
long
)
sizeof
(
*
worker
.
distance_map
)
)
)
;
Exit
:
if
(
worker
.
distance_map
)
FT_FREE
(
worker
.
distance_map
)
;
return
error
;
}
static
void
bsdf_raster_done
(
FT_Raster
raster
)
{
FT_Memory
memory
=
(
FT_Memory
)
(
(
BSDF_TRaster
*
)
raster
)
-
>
memory
;
FT_FREE
(
raster
)
;
}
FT_DEFINE_RASTER_FUNCS
(
ft_bitmap_sdf_raster
FT_GLYPH_FORMAT_BITMAP
(
FT_Raster_New_Func
)
bsdf_raster_new
(
FT_Raster_Reset_Func
)
bsdf_raster_reset
(
FT_Raster_Set_Mode_Func
)
bsdf_raster_set_mode
(
FT_Raster_Render_Func
)
bsdf_raster_render
(
FT_Raster_Done_Func
)
bsdf_raster_done
)
