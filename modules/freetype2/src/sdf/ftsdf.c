#
include
<
freetype
/
internal
/
ftobjs
.
h
>
#
include
<
freetype
/
internal
/
ftdebug
.
h
>
#
include
<
freetype
/
ftoutln
.
h
>
#
include
<
freetype
/
fttrigon
.
h
>
#
include
<
freetype
/
ftbitmap
.
h
>
#
include
"
ftsdf
.
h
"
#
include
"
ftsdferrs
.
h
"
#
undef
FT_COMPONENT
#
define
FT_COMPONENT
sdf
#
ifndef
USE_NEWTON_FOR_CONIC
#
define
USE_NEWTON_FOR_CONIC
1
#
endif
#
define
MAX_NEWTON_DIVISIONS
4
#
define
MAX_NEWTON_STEPS
4
#
define
CORNER_CHECK_EPSILON
32
#
if
0
#
define
CG_DIMEN
8
#
endif
#
define
MUL_26D6
(
a
b
)
(
(
(
a
)
*
(
b
)
)
/
64
)
#
define
VEC_26D6_DOT
(
p
q
)
(
MUL_26D6
(
p
.
x
q
.
x
)
+
\
MUL_26D6
(
p
.
y
q
.
y
)
)
typedef
struct
SDF_TRaster_
{
FT_Memory
memory
;
}
SDF_TRaster
*
SDF_PRaster
;
typedef
enum
SDF_Edge_Type_
{
SDF_EDGE_UNDEFINED
=
0
SDF_EDGE_LINE
=
1
SDF_EDGE_CONIC
=
2
SDF_EDGE_CUBIC
=
3
}
SDF_Edge_Type
;
typedef
enum
SDF_Contour_Orientation_
{
SDF_ORIENTATION_NONE
=
0
SDF_ORIENTATION_CW
=
1
SDF_ORIENTATION_CCW
=
2
}
SDF_Contour_Orientation
;
typedef
struct
SDF_Edge_
{
FT_26D6_Vec
start_pos
;
FT_26D6_Vec
end_pos
;
FT_26D6_Vec
control_a
;
FT_26D6_Vec
control_b
;
SDF_Edge_Type
edge_type
;
struct
SDF_Edge_
*
next
;
}
SDF_Edge
;
typedef
struct
SDF_Contour_
{
FT_26D6_Vec
last_pos
;
SDF_Edge
*
edges
;
struct
SDF_Contour_
*
next
;
}
SDF_Contour
;
typedef
struct
SDF_Shape_
{
FT_Memory
memory
;
SDF_Contour
*
contours
;
}
SDF_Shape
;
typedef
struct
SDF_Signed_Distance_
{
FT_16D16
distance
;
FT_16D16
cross
;
FT_Char
sign
;
}
SDF_Signed_Distance
;
typedef
struct
SDF_Params_
{
FT_Orientation
orientation
;
FT_Bool
flip_sign
;
FT_Bool
flip_y
;
FT_Int
overload_sign
;
}
SDF_Params
;
static
const
FT_Vector
zero_vector
=
{
0
0
}
;
static
const
SDF_Edge
null_edge
=
{
{
0
0
}
{
0
0
}
{
0
0
}
{
0
0
}
SDF_EDGE_UNDEFINED
NULL
}
;
static
const
SDF_Contour
null_contour
=
{
{
0
0
}
NULL
NULL
}
;
static
const
SDF_Shape
null_shape
=
{
NULL
NULL
}
;
static
const
SDF_Signed_Distance
max_sdf
=
{
INT_MAX
0
0
}
;
static
FT_Error
sdf_edge_new
(
FT_Memory
memory
SDF_Edge
*
*
edge
)
{
FT_Error
error
=
FT_Err_Ok
;
SDF_Edge
*
ptr
=
NULL
;
if
(
!
memory
|
|
!
edge
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
!
FT_QNEW
(
ptr
)
)
{
*
ptr
=
null_edge
;
*
edge
=
ptr
;
}
Exit
:
return
error
;
}
static
void
sdf_edge_done
(
FT_Memory
memory
SDF_Edge
*
*
edge
)
{
if
(
!
memory
|
|
!
edge
|
|
!
*
edge
)
return
;
FT_FREE
(
*
edge
)
;
}
static
FT_Error
sdf_contour_new
(
FT_Memory
memory
SDF_Contour
*
*
contour
)
{
FT_Error
error
=
FT_Err_Ok
;
SDF_Contour
*
ptr
=
NULL
;
if
(
!
memory
|
|
!
contour
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
!
FT_QNEW
(
ptr
)
)
{
*
ptr
=
null_contour
;
*
contour
=
ptr
;
}
Exit
:
return
error
;
}
static
void
sdf_contour_done
(
FT_Memory
memory
SDF_Contour
*
*
contour
)
{
SDF_Edge
*
edges
;
SDF_Edge
*
temp
;
if
(
!
memory
|
|
!
contour
|
|
!
*
contour
)
return
;
edges
=
(
*
contour
)
-
>
edges
;
while
(
edges
)
{
temp
=
edges
;
edges
=
edges
-
>
next
;
sdf_edge_done
(
memory
&
temp
)
;
}
FT_FREE
(
*
contour
)
;
}
static
FT_Error
sdf_shape_new
(
FT_Memory
memory
SDF_Shape
*
*
shape
)
{
FT_Error
error
=
FT_Err_Ok
;
SDF_Shape
*
ptr
=
NULL
;
if
(
!
memory
|
|
!
shape
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
!
FT_QNEW
(
ptr
)
)
{
*
ptr
=
null_shape
;
ptr
-
>
memory
=
memory
;
*
shape
=
ptr
;
}
Exit
:
return
error
;
}
static
void
sdf_shape_done
(
SDF_Shape
*
*
shape
)
{
FT_Memory
memory
;
SDF_Contour
*
contours
;
SDF_Contour
*
temp
;
if
(
!
shape
|
|
!
*
shape
)
return
;
memory
=
(
*
shape
)
-
>
memory
;
contours
=
(
*
shape
)
-
>
contours
;
if
(
!
memory
)
return
;
while
(
contours
)
{
temp
=
contours
;
contours
=
contours
-
>
next
;
sdf_contour_done
(
memory
&
temp
)
;
}
FT_FREE
(
*
shape
)
;
}
static
FT_Error
sdf_move_to
(
const
FT_26D6_Vec
*
to
void
*
user
)
{
SDF_Shape
*
shape
=
(
SDF_Shape
*
)
user
;
SDF_Contour
*
contour
=
NULL
;
FT_Error
error
=
FT_Err_Ok
;
FT_Memory
memory
=
shape
-
>
memory
;
if
(
!
to
|
|
!
user
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
FT_CALL
(
sdf_contour_new
(
memory
&
contour
)
)
;
contour
-
>
last_pos
=
*
to
;
contour
-
>
next
=
shape
-
>
contours
;
shape
-
>
contours
=
contour
;
Exit
:
return
error
;
}
static
FT_Error
sdf_line_to
(
const
FT_26D6_Vec
*
to
void
*
user
)
{
SDF_Shape
*
shape
=
(
SDF_Shape
*
)
user
;
SDF_Edge
*
edge
=
NULL
;
SDF_Contour
*
contour
=
NULL
;
FT_Error
error
=
FT_Err_Ok
;
FT_Memory
memory
=
shape
-
>
memory
;
if
(
!
to
|
|
!
user
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
contour
=
shape
-
>
contours
;
if
(
contour
-
>
last_pos
.
x
=
=
to
-
>
x
&
&
contour
-
>
last_pos
.
y
=
=
to
-
>
y
)
goto
Exit
;
FT_CALL
(
sdf_edge_new
(
memory
&
edge
)
)
;
edge
-
>
edge_type
=
SDF_EDGE_LINE
;
edge
-
>
start_pos
=
contour
-
>
last_pos
;
edge
-
>
end_pos
=
*
to
;
edge
-
>
next
=
contour
-
>
edges
;
contour
-
>
edges
=
edge
;
contour
-
>
last_pos
=
*
to
;
Exit
:
return
error
;
}
static
FT_Error
sdf_conic_to
(
const
FT_26D6_Vec
*
control_1
const
FT_26D6_Vec
*
to
void
*
user
)
{
SDF_Shape
*
shape
=
(
SDF_Shape
*
)
user
;
SDF_Edge
*
edge
=
NULL
;
SDF_Contour
*
contour
=
NULL
;
FT_Error
error
=
FT_Err_Ok
;
FT_Memory
memory
=
shape
-
>
memory
;
if
(
!
control_1
|
|
!
to
|
|
!
user
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
contour
=
shape
-
>
contours
;
if
(
(
contour
-
>
last_pos
.
x
=
=
control_1
-
>
x
&
&
contour
-
>
last_pos
.
y
=
=
control_1
-
>
y
)
|
|
(
control_1
-
>
x
=
=
to
-
>
x
&
&
control_1
-
>
y
=
=
to
-
>
y
)
)
{
sdf_line_to
(
to
user
)
;
goto
Exit
;
}
FT_CALL
(
sdf_edge_new
(
memory
&
edge
)
)
;
edge
-
>
edge_type
=
SDF_EDGE_CONIC
;
edge
-
>
start_pos
=
contour
-
>
last_pos
;
edge
-
>
control_a
=
*
control_1
;
edge
-
>
end_pos
=
*
to
;
edge
-
>
next
=
contour
-
>
edges
;
contour
-
>
edges
=
edge
;
contour
-
>
last_pos
=
*
to
;
Exit
:
return
error
;
}
static
FT_Error
sdf_cubic_to
(
const
FT_26D6_Vec
*
control_1
const
FT_26D6_Vec
*
control_2
const
FT_26D6_Vec
*
to
void
*
user
)
{
SDF_Shape
*
shape
=
(
SDF_Shape
*
)
user
;
SDF_Edge
*
edge
=
NULL
;
SDF_Contour
*
contour
=
NULL
;
FT_Error
error
=
FT_Err_Ok
;
FT_Memory
memory
=
shape
-
>
memory
;
if
(
!
control_2
|
|
!
control_1
|
|
!
to
|
|
!
user
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
contour
=
shape
-
>
contours
;
FT_CALL
(
sdf_edge_new
(
memory
&
edge
)
)
;
edge
-
>
edge_type
=
SDF_EDGE_CUBIC
;
edge
-
>
start_pos
=
contour
-
>
last_pos
;
edge
-
>
control_a
=
*
control_1
;
edge
-
>
control_b
=
*
control_2
;
edge
-
>
end_pos
=
*
to
;
edge
-
>
next
=
contour
-
>
edges
;
contour
-
>
edges
=
edge
;
contour
-
>
last_pos
=
*
to
;
Exit
:
return
error
;
}
FT_DEFINE_OUTLINE_FUNCS
(
sdf_decompose_funcs
(
FT_Outline_MoveTo_Func
)
sdf_move_to
(
FT_Outline_LineTo_Func
)
sdf_line_to
(
FT_Outline_ConicTo_Func
)
sdf_conic_to
(
FT_Outline_CubicTo_Func
)
sdf_cubic_to
0
0
)
static
FT_Error
sdf_outline_decompose
(
FT_Outline
*
outline
SDF_Shape
*
shape
)
{
FT_Error
error
=
FT_Err_Ok
;
if
(
!
outline
|
|
!
shape
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
error
=
FT_Outline_Decompose
(
outline
&
sdf_decompose_funcs
(
void
*
)
shape
)
;
Exit
:
return
error
;
}
static
FT_CBox
get_control_box
(
SDF_Edge
edge
)
{
FT_CBox
cbox
=
{
0
0
0
0
}
;
FT_Bool
is_set
=
0
;
switch
(
edge
.
edge_type
)
{
case
SDF_EDGE_CUBIC
:
cbox
.
xMin
=
edge
.
control_b
.
x
;
cbox
.
xMax
=
edge
.
control_b
.
x
;
cbox
.
yMin
=
edge
.
control_b
.
y
;
cbox
.
yMax
=
edge
.
control_b
.
y
;
is_set
=
1
;
FALL_THROUGH
;
case
SDF_EDGE_CONIC
:
if
(
is_set
)
{
cbox
.
xMin
=
edge
.
control_a
.
x
<
cbox
.
xMin
?
edge
.
control_a
.
x
:
cbox
.
xMin
;
cbox
.
xMax
=
edge
.
control_a
.
x
>
cbox
.
xMax
?
edge
.
control_a
.
x
:
cbox
.
xMax
;
cbox
.
yMin
=
edge
.
control_a
.
y
<
cbox
.
yMin
?
edge
.
control_a
.
y
:
cbox
.
yMin
;
cbox
.
yMax
=
edge
.
control_a
.
y
>
cbox
.
yMax
?
edge
.
control_a
.
y
:
cbox
.
yMax
;
}
else
{
cbox
.
xMin
=
edge
.
control_a
.
x
;
cbox
.
xMax
=
edge
.
control_a
.
x
;
cbox
.
yMin
=
edge
.
control_a
.
y
;
cbox
.
yMax
=
edge
.
control_a
.
y
;
is_set
=
1
;
}
FALL_THROUGH
;
case
SDF_EDGE_LINE
:
if
(
is_set
)
{
cbox
.
xMin
=
edge
.
start_pos
.
x
<
cbox
.
xMin
?
edge
.
start_pos
.
x
:
cbox
.
xMin
;
cbox
.
xMax
=
edge
.
start_pos
.
x
>
cbox
.
xMax
?
edge
.
start_pos
.
x
:
cbox
.
xMax
;
cbox
.
yMin
=
edge
.
start_pos
.
y
<
cbox
.
yMin
?
edge
.
start_pos
.
y
:
cbox
.
yMin
;
cbox
.
yMax
=
edge
.
start_pos
.
y
>
cbox
.
yMax
?
edge
.
start_pos
.
y
:
cbox
.
yMax
;
}
else
{
cbox
.
xMin
=
edge
.
start_pos
.
x
;
cbox
.
xMax
=
edge
.
start_pos
.
x
;
cbox
.
yMin
=
edge
.
start_pos
.
y
;
cbox
.
yMax
=
edge
.
start_pos
.
y
;
}
cbox
.
xMin
=
edge
.
end_pos
.
x
<
cbox
.
xMin
?
edge
.
end_pos
.
x
:
cbox
.
xMin
;
cbox
.
xMax
=
edge
.
end_pos
.
x
>
cbox
.
xMax
?
edge
.
end_pos
.
x
:
cbox
.
xMax
;
cbox
.
yMin
=
edge
.
end_pos
.
y
<
cbox
.
yMin
?
edge
.
end_pos
.
y
:
cbox
.
yMin
;
cbox
.
yMax
=
edge
.
end_pos
.
y
>
cbox
.
yMax
?
edge
.
end_pos
.
y
:
cbox
.
yMax
;
break
;
default
:
break
;
}
return
cbox
;
}
static
SDF_Contour_Orientation
get_contour_orientation
(
SDF_Contour
*
contour
)
{
SDF_Edge
*
head
=
NULL
;
FT_26D6
area
=
0
;
if
(
!
contour
|
|
!
contour
-
>
edges
)
return
SDF_ORIENTATION_NONE
;
head
=
contour
-
>
edges
;
while
(
head
)
{
switch
(
head
-
>
edge_type
)
{
case
SDF_EDGE_LINE
:
area
+
=
MUL_26D6
(
(
head
-
>
end_pos
.
x
-
head
-
>
start_pos
.
x
)
(
head
-
>
end_pos
.
y
+
head
-
>
start_pos
.
y
)
)
;
break
;
case
SDF_EDGE_CONIC
:
area
+
=
MUL_26D6
(
head
-
>
control_a
.
x
-
head
-
>
start_pos
.
x
head
-
>
control_a
.
y
+
head
-
>
start_pos
.
y
)
;
area
+
=
MUL_26D6
(
head
-
>
end_pos
.
x
-
head
-
>
control_a
.
x
head
-
>
end_pos
.
y
+
head
-
>
control_a
.
y
)
;
break
;
case
SDF_EDGE_CUBIC
:
area
+
=
MUL_26D6
(
head
-
>
control_a
.
x
-
head
-
>
start_pos
.
x
head
-
>
control_a
.
y
+
head
-
>
start_pos
.
y
)
;
area
+
=
MUL_26D6
(
head
-
>
control_b
.
x
-
head
-
>
control_a
.
x
head
-
>
control_b
.
y
+
head
-
>
control_a
.
y
)
;
area
+
=
MUL_26D6
(
head
-
>
end_pos
.
x
-
head
-
>
control_b
.
x
head
-
>
end_pos
.
y
+
head
-
>
control_b
.
y
)
;
break
;
default
:
return
SDF_ORIENTATION_NONE
;
}
head
=
head
-
>
next
;
}
if
(
area
>
0
)
return
SDF_ORIENTATION_CW
;
else
return
SDF_ORIENTATION_CCW
;
}
static
void
split_conic
(
FT_26D6_Vec
*
base
)
{
FT_26D6
a
b
;
base
[
4
]
.
x
=
base
[
2
]
.
x
;
a
=
base
[
0
]
.
x
+
base
[
1
]
.
x
;
b
=
base
[
1
]
.
x
+
base
[
2
]
.
x
;
base
[
3
]
.
x
=
b
/
2
;
base
[
2
]
.
x
=
(
a
+
b
)
/
4
;
base
[
1
]
.
x
=
a
/
2
;
base
[
4
]
.
y
=
base
[
2
]
.
y
;
a
=
base
[
0
]
.
y
+
base
[
1
]
.
y
;
b
=
base
[
1
]
.
y
+
base
[
2
]
.
y
;
base
[
3
]
.
y
=
b
/
2
;
base
[
2
]
.
y
=
(
a
+
b
)
/
4
;
base
[
1
]
.
y
=
a
/
2
;
}
static
void
split_cubic
(
FT_26D6_Vec
*
base
)
{
FT_26D6
a
b
c
;
base
[
6
]
.
x
=
base
[
3
]
.
x
;
a
=
base
[
0
]
.
x
+
base
[
1
]
.
x
;
b
=
base
[
1
]
.
x
+
base
[
2
]
.
x
;
c
=
base
[
2
]
.
x
+
base
[
3
]
.
x
;
base
[
5
]
.
x
=
c
/
2
;
c
+
=
b
;
base
[
4
]
.
x
=
c
/
4
;
base
[
1
]
.
x
=
a
/
2
;
a
+
=
b
;
base
[
2
]
.
x
=
a
/
4
;
base
[
3
]
.
x
=
(
a
+
c
)
/
8
;
base
[
6
]
.
y
=
base
[
3
]
.
y
;
a
=
base
[
0
]
.
y
+
base
[
1
]
.
y
;
b
=
base
[
1
]
.
y
+
base
[
2
]
.
y
;
c
=
base
[
2
]
.
y
+
base
[
3
]
.
y
;
base
[
5
]
.
y
=
c
/
2
;
c
+
=
b
;
base
[
4
]
.
y
=
c
/
4
;
base
[
1
]
.
y
=
a
/
2
;
a
+
=
b
;
base
[
2
]
.
y
=
a
/
4
;
base
[
3
]
.
y
=
(
a
+
c
)
/
8
;
}
static
FT_Error
split_sdf_conic
(
FT_Memory
memory
FT_26D6_Vec
*
control_points
FT_UInt
max_splits
SDF_Edge
*
*
out
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_26D6_Vec
cpos
[
5
]
;
SDF_Edge
*
left
*
right
;
if
(
!
memory
|
|
!
out
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
cpos
[
0
]
=
control_points
[
0
]
;
cpos
[
1
]
=
control_points
[
1
]
;
cpos
[
2
]
=
control_points
[
2
]
;
split_conic
(
cpos
)
;
if
(
max_splits
<
=
2
)
goto
Append
;
FT_CALL
(
split_sdf_conic
(
memory
&
cpos
[
0
]
max_splits
/
2
out
)
)
;
FT_CALL
(
split_sdf_conic
(
memory
&
cpos
[
2
]
max_splits
/
2
out
)
)
;
goto
Exit
;
Append
:
FT_CALL
(
sdf_edge_new
(
memory
&
left
)
)
;
FT_CALL
(
sdf_edge_new
(
memory
&
right
)
)
;
left
-
>
start_pos
=
cpos
[
0
]
;
left
-
>
end_pos
=
cpos
[
2
]
;
left
-
>
edge_type
=
SDF_EDGE_LINE
;
right
-
>
start_pos
=
cpos
[
2
]
;
right
-
>
end_pos
=
cpos
[
4
]
;
right
-
>
edge_type
=
SDF_EDGE_LINE
;
left
-
>
next
=
right
;
right
-
>
next
=
(
*
out
)
;
*
out
=
left
;
Exit
:
return
error
;
}
static
FT_Error
split_sdf_cubic
(
FT_Memory
memory
FT_26D6_Vec
*
control_points
FT_UInt
max_splits
SDF_Edge
*
*
out
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_26D6_Vec
cpos
[
7
]
;
SDF_Edge
*
left
*
right
;
const
FT_26D6
threshold
=
ONE_PIXEL
/
4
;
if
(
!
memory
|
|
!
out
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
cpos
[
0
]
=
control_points
[
0
]
;
cpos
[
1
]
=
control_points
[
1
]
;
cpos
[
2
]
=
control_points
[
2
]
;
cpos
[
3
]
=
control_points
[
3
]
;
if
(
FT_ABS
(
2
*
cpos
[
0
]
.
x
-
3
*
cpos
[
1
]
.
x
+
cpos
[
3
]
.
x
)
<
threshold
&
&
FT_ABS
(
2
*
cpos
[
0
]
.
y
-
3
*
cpos
[
1
]
.
y
+
cpos
[
3
]
.
y
)
<
threshold
&
&
FT_ABS
(
cpos
[
0
]
.
x
-
3
*
cpos
[
2
]
.
x
+
2
*
cpos
[
3
]
.
x
)
<
threshold
&
&
FT_ABS
(
cpos
[
0
]
.
y
-
3
*
cpos
[
2
]
.
y
+
2
*
cpos
[
3
]
.
y
)
<
threshold
)
{
split_cubic
(
cpos
)
;
goto
Append
;
}
split_cubic
(
cpos
)
;
if
(
max_splits
<
=
2
)
goto
Append
;
FT_CALL
(
split_sdf_cubic
(
memory
&
cpos
[
0
]
max_splits
/
2
out
)
)
;
FT_CALL
(
split_sdf_cubic
(
memory
&
cpos
[
3
]
max_splits
/
2
out
)
)
;
goto
Exit
;
Append
:
FT_CALL
(
sdf_edge_new
(
memory
&
left
)
)
;
FT_CALL
(
sdf_edge_new
(
memory
&
right
)
)
;
left
-
>
start_pos
=
cpos
[
0
]
;
left
-
>
end_pos
=
cpos
[
3
]
;
left
-
>
edge_type
=
SDF_EDGE_LINE
;
right
-
>
start_pos
=
cpos
[
3
]
;
right
-
>
end_pos
=
cpos
[
6
]
;
right
-
>
edge_type
=
SDF_EDGE_LINE
;
left
-
>
next
=
right
;
right
-
>
next
=
(
*
out
)
;
*
out
=
left
;
Exit
:
return
error
;
}
static
FT_Error
split_sdf_shape
(
SDF_Shape
*
shape
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Memory
memory
;
SDF_Contour
*
contours
;
SDF_Contour
*
new_contours
=
NULL
;
if
(
!
shape
|
|
!
shape
-
>
memory
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
contours
=
shape
-
>
contours
;
memory
=
shape
-
>
memory
;
while
(
contours
)
{
SDF_Edge
*
edges
=
contours
-
>
edges
;
SDF_Edge
*
new_edges
=
NULL
;
SDF_Contour
*
tempc
;
while
(
edges
)
{
SDF_Edge
*
edge
=
edges
;
SDF_Edge
*
temp
;
switch
(
edge
-
>
edge_type
)
{
case
SDF_EDGE_LINE
:
FT_CALL
(
sdf_edge_new
(
memory
&
temp
)
)
;
ft_memcpy
(
temp
edge
sizeof
(
*
edge
)
)
;
temp
-
>
next
=
new_edges
;
new_edges
=
temp
;
break
;
case
SDF_EDGE_CONIC
:
{
FT_26D6_Vec
ctrls
[
3
]
;
FT_26D6
dx
dy
;
FT_UInt
num_splits
;
ctrls
[
0
]
=
edge
-
>
start_pos
;
ctrls
[
1
]
=
edge
-
>
control_a
;
ctrls
[
2
]
=
edge
-
>
end_pos
;
dx
=
FT_ABS
(
ctrls
[
2
]
.
x
+
ctrls
[
0
]
.
x
-
2
*
ctrls
[
1
]
.
x
)
;
dy
=
FT_ABS
(
ctrls
[
2
]
.
y
+
ctrls
[
0
]
.
y
-
2
*
ctrls
[
1
]
.
y
)
;
if
(
dx
<
dy
)
dx
=
dy
;
num_splits
=
1
;
while
(
dx
>
ONE_PIXEL
/
8
)
{
dx
>
>
=
2
;
num_splits
<
<
=
1
;
}
error
=
split_sdf_conic
(
memory
ctrls
num_splits
&
new_edges
)
;
}
break
;
case
SDF_EDGE_CUBIC
:
{
FT_26D6_Vec
ctrls
[
4
]
;
ctrls
[
0
]
=
edge
-
>
start_pos
;
ctrls
[
1
]
=
edge
-
>
control_a
;
ctrls
[
2
]
=
edge
-
>
control_b
;
ctrls
[
3
]
=
edge
-
>
end_pos
;
error
=
split_sdf_cubic
(
memory
ctrls
32
&
new_edges
)
;
}
break
;
default
:
error
=
FT_THROW
(
Invalid_Argument
)
;
}
if
(
error
!
=
FT_Err_Ok
)
goto
Exit
;
edges
=
edges
-
>
next
;
}
FT_CALL
(
sdf_contour_new
(
memory
&
tempc
)
)
;
tempc
-
>
next
=
new_contours
;
tempc
-
>
edges
=
new_edges
;
new_contours
=
tempc
;
new_edges
=
NULL
;
tempc
=
contours
;
contours
=
contours
-
>
next
;
sdf_contour_done
(
memory
&
tempc
)
;
}
shape
-
>
contours
=
new_contours
;
Exit
:
return
error
;
}
#
ifdef
FT_DEBUG_LEVEL_TRACE
static
void
sdf_shape_dump
(
SDF_Shape
*
shape
)
{
FT_UInt
num_contours
=
0
;
FT_UInt
total_edges
=
0
;
FT_UInt
total_lines
=
0
;
FT_UInt
total_conic
=
0
;
FT_UInt
total_cubic
=
0
;
SDF_Contour
*
contour_list
;
if
(
!
shape
)
{
FT_TRACE5
(
(
"
sdf_shape_dump
:
null
shape
\
n
"
)
)
;
return
;
}
contour_list
=
shape
-
>
contours
;
FT_TRACE5
(
(
"
sdf_shape_dump
(
values
are
in
26
.
6
format
)
:
\
n
"
)
)
;
while
(
contour_list
)
{
FT_UInt
num_edges
=
0
;
SDF_Edge
*
edge_list
;
SDF_Contour
*
contour
=
contour_list
;
FT_TRACE5
(
(
"
Contour
%
u
\
n
"
num_contours
)
)
;
edge_list
=
contour
-
>
edges
;
while
(
edge_list
)
{
SDF_Edge
*
edge
=
edge_list
;
FT_TRACE5
(
(
"
%
3u
:
"
num_edges
)
)
;
switch
(
edge
-
>
edge_type
)
{
case
SDF_EDGE_LINE
:
FT_TRACE5
(
(
"
Line
:
(
%
ld
%
ld
)
-
-
(
%
ld
%
ld
)
\
n
"
edge
-
>
start_pos
.
x
edge
-
>
start_pos
.
y
edge
-
>
end_pos
.
x
edge
-
>
end_pos
.
y
)
)
;
total_lines
+
+
;
break
;
case
SDF_EDGE_CONIC
:
FT_TRACE5
(
(
"
Conic
:
(
%
ld
%
ld
)
.
.
(
%
ld
%
ld
)
.
.
(
%
ld
%
ld
)
\
n
"
edge
-
>
start_pos
.
x
edge
-
>
start_pos
.
y
edge
-
>
control_a
.
x
edge
-
>
control_a
.
y
edge
-
>
end_pos
.
x
edge
-
>
end_pos
.
y
)
)
;
total_conic
+
+
;
break
;
case
SDF_EDGE_CUBIC
:
FT_TRACE5
(
(
"
Cubic
:
(
%
ld
%
ld
)
.
.
(
%
ld
%
ld
)
"
"
.
.
(
%
ld
%
ld
)
.
.
(
%
ld
%
ld
)
\
n
"
edge
-
>
start_pos
.
x
edge
-
>
start_pos
.
y
edge
-
>
control_a
.
x
edge
-
>
control_a
.
y
edge
-
>
control_b
.
x
edge
-
>
control_b
.
y
edge
-
>
end_pos
.
x
edge
-
>
end_pos
.
y
)
)
;
total_cubic
+
+
;
break
;
default
:
break
;
}
num_edges
+
+
;
total_edges
+
+
;
edge_list
=
edge_list
-
>
next
;
}
num_contours
+
+
;
contour_list
=
contour_list
-
>
next
;
}
FT_TRACE5
(
(
"
\
n
"
)
)
;
FT_TRACE5
(
(
"
total
number
of
contours
=
%
u
\
n
"
num_contours
)
)
;
FT_TRACE5
(
(
"
total
number
of
edges
=
%
u
\
n
"
total_edges
)
)
;
FT_TRACE5
(
(
"
|
__lines
=
%
u
\
n
"
total_lines
)
)
;
FT_TRACE5
(
(
"
|
__conic
=
%
u
\
n
"
total_conic
)
)
;
FT_TRACE5
(
(
"
|
__cubic
=
%
u
\
n
"
total_cubic
)
)
;
}
#
endif
#
if
!
USE_NEWTON_FOR_CONIC
static
FT_16D16
cube_root
(
FT_16D16
val
)
{
FT_Int
v
g
c
;
if
(
val
=
=
0
|
|
val
=
=
-
FT_INT_16D16
(
1
)
|
|
val
=
=
FT_INT_16D16
(
1
)
)
return
val
;
v
=
val
<
0
?
-
val
:
val
;
g
=
square_root
(
v
)
;
c
=
0
;
while
(
1
)
{
c
=
FT_MulFix
(
FT_MulFix
(
g
g
)
g
)
-
v
;
c
=
FT_DivFix
(
c
3
*
FT_MulFix
(
g
g
)
)
;
g
-
=
c
;
if
(
(
c
<
0
?
-
c
:
c
)
<
30
)
break
;
}
return
val
<
0
?
-
g
:
g
;
}
static
FT_16D16
arc_cos
(
FT_16D16
val
)
{
FT_16D16
p
;
FT_16D16
b
=
val
;
FT_16D16
one
=
FT_INT_16D16
(
1
)
;
if
(
b
>
one
)
b
=
one
;
if
(
b
<
-
one
)
b
=
-
one
;
p
=
one
-
FT_MulFix
(
b
b
)
;
p
=
square_root
(
p
)
;
return
FT_Atan2
(
b
p
)
;
}
static
FT_UShort
solve_quadratic_equation
(
FT_26D6
a
FT_26D6
b
FT_26D6
c
FT_16D16
out
[
2
]
)
{
FT_16D16
discriminant
=
0
;
a
=
FT_26D6_16D16
(
a
)
;
b
=
FT_26D6_16D16
(
b
)
;
c
=
FT_26D6_16D16
(
c
)
;
if
(
a
=
=
0
)
{
if
(
b
=
=
0
)
return
0
;
else
{
out
[
0
]
=
FT_DivFix
(
-
c
b
)
;
return
1
;
}
}
discriminant
=
FT_MulFix
(
b
b
)
-
4
*
FT_MulFix
(
a
c
)
;
if
(
discriminant
<
0
)
return
0
;
else
if
(
discriminant
=
=
0
)
{
out
[
0
]
=
FT_DivFix
(
-
b
2
*
a
)
;
return
1
;
}
else
{
discriminant
=
square_root
(
discriminant
)
;
out
[
0
]
=
FT_DivFix
(
-
b
+
discriminant
2
*
a
)
;
out
[
1
]
=
FT_DivFix
(
-
b
-
discriminant
2
*
a
)
;
return
2
;
}
}
static
FT_UShort
solve_cubic_equation
(
FT_26D6
a
FT_26D6
b
FT_26D6
c
FT_26D6
d
FT_16D16
out
[
3
]
)
{
FT_16D16
q
=
0
;
FT_16D16
r
=
0
;
FT_16D16
a2
=
b
;
FT_16D16
a1
=
c
;
FT_16D16
a0
=
d
;
FT_16D16
q3
=
0
;
FT_16D16
r2
=
0
;
FT_16D16
a23
=
0
;
FT_16D16
a22
=
0
;
FT_16D16
a1x2
=
0
;
if
(
a
=
=
0
|
|
FT_ABS
(
a
)
<
16
)
return
solve_quadratic_equation
(
b
c
d
out
)
;
if
(
d
=
=
0
)
{
out
[
0
]
=
0
;
return
solve_quadratic_equation
(
a
b
c
out
+
1
)
+
1
;
}
a2
=
FT_DivFix
(
a2
a
)
;
a1
=
FT_DivFix
(
a1
a
)
;
a0
=
FT_DivFix
(
a0
a
)
;
a1x2
=
FT_MulFix
(
a1
a2
)
;
a22
=
FT_MulFix
(
a2
a2
)
;
a23
=
FT_MulFix
(
a22
a2
)
;
q
=
(
3
*
a1
-
a22
)
/
9
;
r
=
(
9
*
a1x2
-
27
*
a0
-
2
*
a23
)
/
54
;
q3
=
FT_MulFix
(
q
q
)
;
q3
=
FT_MulFix
(
q3
q
)
;
r2
=
FT_MulFix
(
r
r
)
;
if
(
q3
<
0
&
&
r2
<
-
q3
)
{
FT_16D16
t
=
0
;
q3
=
square_root
(
-
q3
)
;
t
=
FT_DivFix
(
r
q3
)
;
if
(
t
>
(
1
<
<
16
)
)
t
=
(
1
<
<
16
)
;
if
(
t
<
-
(
1
<
<
16
)
)
t
=
-
(
1
<
<
16
)
;
t
=
arc_cos
(
t
)
;
a2
/
=
3
;
q
=
2
*
square_root
(
-
q
)
;
out
[
0
]
=
FT_MulFix
(
q
FT_Cos
(
t
/
3
)
)
-
a2
;
out
[
1
]
=
FT_MulFix
(
q
FT_Cos
(
(
t
+
FT_ANGLE_PI
*
2
)
/
3
)
)
-
a2
;
out
[
2
]
=
FT_MulFix
(
q
FT_Cos
(
(
t
+
FT_ANGLE_PI
*
4
)
/
3
)
)
-
a2
;
return
3
;
}
else
if
(
r2
=
=
-
q3
)
{
FT_16D16
s
=
0
;
s
=
cube_root
(
r
)
;
a2
/
=
-
3
;
out
[
0
]
=
a2
+
(
2
*
s
)
;
out
[
1
]
=
a2
-
s
;
return
2
;
}
else
{
FT_16D16
s
=
0
;
FT_16D16
t
=
0
;
FT_16D16
dis
=
0
;
if
(
q3
=
=
0
)
dis
=
FT_ABS
(
r
)
;
else
dis
=
square_root
(
q3
+
r2
)
;
s
=
cube_root
(
r
+
dis
)
;
t
=
cube_root
(
r
-
dis
)
;
a2
/
=
-
3
;
out
[
0
]
=
(
a2
+
(
s
+
t
)
)
;
return
1
;
}
}
#
endif
static
SDF_Signed_Distance
resolve_corner
(
SDF_Signed_Distance
sdf1
SDF_Signed_Distance
sdf2
)
{
return
FT_ABS
(
sdf1
.
cross
)
>
FT_ABS
(
sdf2
.
cross
)
?
sdf1
:
sdf2
;
}
static
FT_Error
get_min_distance_line
(
SDF_Edge
*
line
FT_26D6_Vec
point
SDF_Signed_Distance
*
out
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Vector
a
;
FT_Vector
b
;
FT_Vector
p
;
FT_26D6_Vec
line_segment
;
FT_26D6_Vec
p_sub_a
;
FT_26D6
sq_line_length
;
FT_16D16
factor
;
FT_26D6
cross
;
FT_16D16_Vec
nearest_point
;
FT_16D16_Vec
nearest_vector
;
if
(
!
line
|
|
!
out
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
line
-
>
edge_type
!
=
SDF_EDGE_LINE
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
a
=
line
-
>
start_pos
;
b
=
line
-
>
end_pos
;
p
=
point
;
line_segment
.
x
=
b
.
x
-
a
.
x
;
line_segment
.
y
=
b
.
y
-
a
.
y
;
p_sub_a
.
x
=
p
.
x
-
a
.
x
;
p_sub_a
.
y
=
p
.
y
-
a
.
y
;
sq_line_length
=
(
line_segment
.
x
*
line_segment
.
x
)
/
64
+
(
line_segment
.
y
*
line_segment
.
y
)
/
64
;
factor
=
(
p_sub_a
.
x
*
line_segment
.
x
)
/
64
+
(
p_sub_a
.
y
*
line_segment
.
y
)
/
64
;
factor
=
FT_DivFix
(
factor
sq_line_length
)
;
if
(
factor
>
FT_INT_16D16
(
1
)
)
factor
=
FT_INT_16D16
(
1
)
;
if
(
factor
<
0
)
factor
=
0
;
nearest_point
.
x
=
FT_MulFix
(
FT_26D6_16D16
(
line_segment
.
x
)
factor
)
;
nearest_point
.
y
=
FT_MulFix
(
FT_26D6_16D16
(
line_segment
.
y
)
factor
)
;
nearest_point
.
x
=
FT_26D6_16D16
(
a
.
x
)
+
nearest_point
.
x
;
nearest_point
.
y
=
FT_26D6_16D16
(
a
.
y
)
+
nearest_point
.
y
;
nearest_vector
.
x
=
nearest_point
.
x
-
FT_26D6_16D16
(
p
.
x
)
;
nearest_vector
.
y
=
nearest_point
.
y
-
FT_26D6_16D16
(
p
.
y
)
;
cross
=
FT_MulFix
(
nearest_vector
.
x
line_segment
.
y
)
-
FT_MulFix
(
nearest_vector
.
y
line_segment
.
x
)
;
out
-
>
sign
=
cross
<
0
?
1
:
-
1
;
out
-
>
distance
=
VECTOR_LENGTH_16D16
(
nearest_vector
)
;
if
(
factor
!
=
0
&
&
factor
!
=
FT_INT_16D16
(
1
)
)
out
-
>
cross
=
FT_INT_16D16
(
1
)
;
else
{
FT_Vector_NormLen
(
&
line_segment
)
;
FT_Vector_NormLen
(
&
nearest_vector
)
;
out
-
>
cross
=
FT_MulFix
(
line_segment
.
x
nearest_vector
.
y
)
-
FT_MulFix
(
line_segment
.
y
nearest_vector
.
x
)
;
}
Exit
:
return
error
;
}
#
if
!
USE_NEWTON_FOR_CONIC
static
FT_Error
get_min_distance_conic
(
SDF_Edge
*
conic
FT_26D6_Vec
point
SDF_Signed_Distance
*
out
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_26D6_Vec
aA
bB
;
FT_26D6_Vec
nearest_point
=
{
0
0
}
;
FT_26D6_Vec
direction
;
FT_26D6_Vec
p0
p1
p2
;
FT_26D6_Vec
p
;
FT_26D6
a
b
c
d
;
FT_16D16
roots
[
3
]
=
{
0
0
0
}
;
FT_16D16
min_factor
;
FT_16D16
cross
;
FT_16D16
min
=
FT_INT_MAX
;
FT_UShort
num_roots
;
FT_UShort
i
;
if
(
!
conic
|
|
!
out
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
conic
-
>
edge_type
!
=
SDF_EDGE_CONIC
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
p0
=
conic
-
>
start_pos
;
p1
=
conic
-
>
control_a
;
p2
=
conic
-
>
end_pos
;
p
=
point
;
aA
.
x
=
p0
.
x
-
2
*
p1
.
x
+
p2
.
x
;
aA
.
y
=
p0
.
y
-
2
*
p1
.
y
+
p2
.
y
;
bB
.
x
=
p1
.
x
-
p0
.
x
;
bB
.
y
=
p1
.
y
-
p0
.
y
;
a
=
VEC_26D6_DOT
(
aA
aA
)
;
b
=
3
*
VEC_26D6_DOT
(
aA
bB
)
;
c
=
2
*
VEC_26D6_DOT
(
bB
bB
)
+
VEC_26D6_DOT
(
aA
p0
)
-
VEC_26D6_DOT
(
aA
p
)
;
d
=
VEC_26D6_DOT
(
p0
bB
)
-
VEC_26D6_DOT
(
p
bB
)
;
num_roots
=
solve_cubic_equation
(
a
b
c
d
roots
)
;
if
(
num_roots
=
=
0
)
{
roots
[
0
]
=
0
;
roots
[
1
]
=
FT_INT_16D16
(
1
)
;
num_roots
=
2
;
}
aA
.
x
=
FT_26D6_16D16
(
aA
.
x
)
;
aA
.
y
=
FT_26D6_16D16
(
aA
.
y
)
;
bB
.
x
=
FT_26D6_16D16
(
bB
.
x
)
;
bB
.
y
=
FT_26D6_16D16
(
bB
.
y
)
;
p0
.
x
=
FT_26D6_16D16
(
p0
.
x
)
;
p0
.
y
=
FT_26D6_16D16
(
p0
.
y
)
;
p
.
x
=
FT_26D6_16D16
(
p
.
x
)
;
p
.
y
=
FT_26D6_16D16
(
p
.
y
)
;
for
(
i
=
0
;
i
<
num_roots
;
i
+
+
)
{
FT_16D16
t
=
roots
[
i
]
;
FT_16D16
t2
=
0
;
FT_16D16
dist
=
0
;
FT_16D16_Vec
curve_point
;
FT_16D16_Vec
dist_vector
;
if
(
t
<
0
)
t
=
0
;
if
(
t
>
FT_INT_16D16
(
1
)
)
t
=
FT_INT_16D16
(
1
)
;
t2
=
FT_MulFix
(
t
t
)
;
curve_point
.
x
=
FT_MulFix
(
aA
.
x
t2
)
+
2
*
FT_MulFix
(
bB
.
x
t
)
+
p0
.
x
;
curve_point
.
y
=
FT_MulFix
(
aA
.
y
t2
)
+
2
*
FT_MulFix
(
bB
.
y
t
)
+
p0
.
y
;
dist_vector
.
x
=
curve_point
.
x
-
p
.
x
;
dist_vector
.
y
=
curve_point
.
y
-
p
.
y
;
dist
=
VECTOR_LENGTH_16D16
(
dist_vector
)
;
if
(
dist
<
min
)
{
min
=
dist
;
nearest_point
=
curve_point
;
min_factor
=
t
;
}
}
direction
.
x
=
2
*
FT_MulFix
(
aA
.
x
min_factor
)
+
2
*
bB
.
x
;
direction
.
y
=
2
*
FT_MulFix
(
aA
.
y
min_factor
)
+
2
*
bB
.
y
;
cross
=
FT_MulFix
(
nearest_point
.
x
-
p
.
x
direction
.
y
)
-
FT_MulFix
(
nearest_point
.
y
-
p
.
y
direction
.
x
)
;
out
-
>
distance
=
min
;
out
-
>
sign
=
cross
<
0
?
1
:
-
1
;
if
(
min_factor
!
=
0
&
&
min_factor
!
=
FT_INT_16D16
(
1
)
)
out
-
>
cross
=
FT_INT_16D16
(
1
)
;
else
{
nearest_point
.
x
-
=
FT_26D6_16D16
(
p
.
x
)
;
nearest_point
.
y
-
=
FT_26D6_16D16
(
p
.
y
)
;
FT_Vector_NormLen
(
&
direction
)
;
FT_Vector_NormLen
(
&
nearest_point
)
;
out
-
>
cross
=
FT_MulFix
(
direction
.
x
nearest_point
.
y
)
-
FT_MulFix
(
direction
.
y
nearest_point
.
x
)
;
}
Exit
:
return
error
;
}
#
else
static
FT_Error
get_min_distance_conic
(
SDF_Edge
*
conic
FT_26D6_Vec
point
SDF_Signed_Distance
*
out
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_26D6_Vec
aA
bB
cC
;
FT_26D6_Vec
nearest_point
=
{
0
0
}
;
FT_26D6_Vec
direction
;
FT_26D6_Vec
p0
p1
p2
;
FT_26D6_Vec
p
;
FT_16D16
min_factor
=
0
;
FT_16D16
cross
;
FT_16D16
min
=
FT_INT_MAX
;
FT_UShort
iterations
;
FT_UShort
steps
;
if
(
!
conic
|
|
!
out
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
conic
-
>
edge_type
!
=
SDF_EDGE_CONIC
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
p0
=
conic
-
>
start_pos
;
p1
=
conic
-
>
control_a
;
p2
=
conic
-
>
end_pos
;
p
=
point
;
aA
.
x
=
p0
.
x
-
2
*
p1
.
x
+
p2
.
x
;
aA
.
y
=
p0
.
y
-
2
*
p1
.
y
+
p2
.
y
;
bB
.
x
=
2
*
(
p1
.
x
-
p0
.
x
)
;
bB
.
y
=
2
*
(
p1
.
y
-
p0
.
y
)
;
cC
.
x
=
p0
.
x
;
cC
.
y
=
p0
.
y
;
for
(
iterations
=
0
;
iterations
<
=
MAX_NEWTON_DIVISIONS
;
iterations
+
+
)
{
FT_16D16
factor
=
FT_INT_16D16
(
iterations
)
/
MAX_NEWTON_DIVISIONS
;
FT_16D16
factor2
;
FT_16D16
length
;
FT_16D16_Vec
curve_point
;
FT_16D16_Vec
dist_vector
;
FT_26D6_Vec
d1
;
FT_26D6_Vec
d2
;
FT_16D16
temp1
;
FT_16D16
temp2
;
for
(
steps
=
0
;
steps
<
MAX_NEWTON_STEPS
;
steps
+
+
)
{
factor2
=
FT_MulFix
(
factor
factor
)
;
curve_point
.
x
=
FT_MulFix
(
aA
.
x
factor2
)
+
FT_MulFix
(
bB
.
x
factor
)
+
cC
.
x
;
curve_point
.
y
=
FT_MulFix
(
aA
.
y
factor2
)
+
FT_MulFix
(
bB
.
y
factor
)
+
cC
.
y
;
curve_point
.
x
=
FT_26D6_16D16
(
curve_point
.
x
)
;
curve_point
.
y
=
FT_26D6_16D16
(
curve_point
.
y
)
;
dist_vector
.
x
=
curve_point
.
x
-
FT_26D6_16D16
(
p
.
x
)
;
dist_vector
.
y
=
curve_point
.
y
-
FT_26D6_16D16
(
p
.
y
)
;
length
=
VECTOR_LENGTH_16D16
(
dist_vector
)
;
if
(
length
<
min
)
{
min
=
length
;
min_factor
=
factor
;
nearest_point
=
curve_point
;
}
d1
.
x
=
FT_MulFix
(
aA
.
x
2
*
factor
)
+
bB
.
x
;
d1
.
y
=
FT_MulFix
(
aA
.
y
2
*
factor
)
+
bB
.
y
;
d2
.
x
=
2
*
aA
.
x
;
d2
.
y
=
2
*
aA
.
y
;
dist_vector
.
x
/
=
1024
;
dist_vector
.
y
/
=
1024
;
temp1
=
VEC_26D6_DOT
(
dist_vector
d1
)
;
temp2
=
VEC_26D6_DOT
(
d1
d1
)
+
VEC_26D6_DOT
(
dist_vector
d2
)
;
factor
-
=
FT_DivFix
(
temp1
temp2
)
;
if
(
factor
<
0
|
|
factor
>
FT_INT_16D16
(
1
)
)
break
;
}
}
direction
.
x
=
2
*
FT_MulFix
(
aA
.
x
min_factor
)
+
bB
.
x
;
direction
.
y
=
2
*
FT_MulFix
(
aA
.
y
min_factor
)
+
bB
.
y
;
cross
=
FT_MulFix
(
nearest_point
.
x
-
FT_26D6_16D16
(
p
.
x
)
direction
.
y
)
-
FT_MulFix
(
nearest_point
.
y
-
FT_26D6_16D16
(
p
.
y
)
direction
.
x
)
;
out
-
>
distance
=
min
;
out
-
>
sign
=
cross
<
0
?
1
:
-
1
;
if
(
min_factor
!
=
0
&
&
min_factor
!
=
FT_INT_16D16
(
1
)
)
out
-
>
cross
=
FT_INT_16D16
(
1
)
;
else
{
nearest_point
.
x
-
=
FT_26D6_16D16
(
p
.
x
)
;
nearest_point
.
y
-
=
FT_26D6_16D16
(
p
.
y
)
;
FT_Vector_NormLen
(
&
direction
)
;
FT_Vector_NormLen
(
&
nearest_point
)
;
out
-
>
cross
=
FT_MulFix
(
direction
.
x
nearest_point
.
y
)
-
FT_MulFix
(
direction
.
y
nearest_point
.
x
)
;
}
Exit
:
return
error
;
}
#
endif
static
FT_Error
get_min_distance_cubic
(
SDF_Edge
*
cubic
FT_26D6_Vec
point
SDF_Signed_Distance
*
out
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_26D6_Vec
aA
bB
cC
dD
;
FT_16D16_Vec
nearest_point
=
{
0
0
}
;
FT_16D16_Vec
direction
;
FT_26D6_Vec
p0
p1
p2
p3
;
FT_26D6_Vec
p
;
FT_16D16
min_factor
=
0
;
FT_16D16
min_factor_sq
=
0
;
FT_16D16
cross
;
FT_16D16
min
=
FT_INT_MAX
;
FT_UShort
iterations
;
FT_UShort
steps
;
if
(
!
cubic
|
|
!
out
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
cubic
-
>
edge_type
!
=
SDF_EDGE_CUBIC
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
p0
=
cubic
-
>
start_pos
;
p1
=
cubic
-
>
control_a
;
p2
=
cubic
-
>
control_b
;
p3
=
cubic
-
>
end_pos
;
p
=
point
;
aA
.
x
=
-
p0
.
x
+
3
*
(
p1
.
x
-
p2
.
x
)
+
p3
.
x
;
aA
.
y
=
-
p0
.
y
+
3
*
(
p1
.
y
-
p2
.
y
)
+
p3
.
y
;
bB
.
x
=
3
*
(
p0
.
x
-
2
*
p1
.
x
+
p2
.
x
)
;
bB
.
y
=
3
*
(
p0
.
y
-
2
*
p1
.
y
+
p2
.
y
)
;
cC
.
x
=
3
*
(
p1
.
x
-
p0
.
x
)
;
cC
.
y
=
3
*
(
p1
.
y
-
p0
.
y
)
;
dD
.
x
=
p0
.
x
;
dD
.
y
=
p0
.
y
;
for
(
iterations
=
0
;
iterations
<
=
MAX_NEWTON_DIVISIONS
;
iterations
+
+
)
{
FT_16D16
factor
=
FT_INT_16D16
(
iterations
)
/
MAX_NEWTON_DIVISIONS
;
FT_16D16
factor2
;
FT_16D16
factor3
;
FT_16D16
length
;
FT_16D16_Vec
curve_point
;
FT_16D16_Vec
dist_vector
;
FT_26D6_Vec
d1
;
FT_26D6_Vec
d2
;
FT_16D16
temp1
;
FT_16D16
temp2
;
for
(
steps
=
0
;
steps
<
MAX_NEWTON_STEPS
;
steps
+
+
)
{
factor2
=
FT_MulFix
(
factor
factor
)
;
factor3
=
FT_MulFix
(
factor2
factor
)
;
curve_point
.
x
=
FT_MulFix
(
aA
.
x
factor3
)
+
FT_MulFix
(
bB
.
x
factor2
)
+
FT_MulFix
(
cC
.
x
factor
)
+
dD
.
x
;
curve_point
.
y
=
FT_MulFix
(
aA
.
y
factor3
)
+
FT_MulFix
(
bB
.
y
factor2
)
+
FT_MulFix
(
cC
.
y
factor
)
+
dD
.
y
;
curve_point
.
x
=
FT_26D6_16D16
(
curve_point
.
x
)
;
curve_point
.
y
=
FT_26D6_16D16
(
curve_point
.
y
)
;
dist_vector
.
x
=
curve_point
.
x
-
FT_26D6_16D16
(
p
.
x
)
;
dist_vector
.
y
=
curve_point
.
y
-
FT_26D6_16D16
(
p
.
y
)
;
length
=
VECTOR_LENGTH_16D16
(
dist_vector
)
;
if
(
length
<
min
)
{
min
=
length
;
min_factor
=
factor
;
min_factor_sq
=
factor2
;
nearest_point
=
curve_point
;
}
d1
.
x
=
FT_MulFix
(
aA
.
x
3
*
factor2
)
+
FT_MulFix
(
bB
.
x
2
*
factor
)
+
cC
.
x
;
d1
.
y
=
FT_MulFix
(
aA
.
y
3
*
factor2
)
+
FT_MulFix
(
bB
.
y
2
*
factor
)
+
cC
.
y
;
d2
.
x
=
FT_MulFix
(
aA
.
x
6
*
factor
)
+
2
*
bB
.
x
;
d2
.
y
=
FT_MulFix
(
aA
.
y
6
*
factor
)
+
2
*
bB
.
y
;
dist_vector
.
x
/
=
1024
;
dist_vector
.
y
/
=
1024
;
temp1
=
VEC_26D6_DOT
(
dist_vector
d1
)
;
temp2
=
VEC_26D6_DOT
(
d1
d1
)
+
VEC_26D6_DOT
(
dist_vector
d2
)
;
factor
-
=
FT_DivFix
(
temp1
temp2
)
;
if
(
factor
<
0
|
|
factor
>
FT_INT_16D16
(
1
)
)
break
;
}
}
direction
.
x
=
FT_MulFix
(
aA
.
x
3
*
min_factor_sq
)
+
FT_MulFix
(
bB
.
x
2
*
min_factor
)
+
cC
.
x
;
direction
.
y
=
FT_MulFix
(
aA
.
y
3
*
min_factor_sq
)
+
FT_MulFix
(
bB
.
y
2
*
min_factor
)
+
cC
.
y
;
cross
=
FT_MulFix
(
nearest_point
.
x
-
FT_26D6_16D16
(
p
.
x
)
direction
.
y
)
-
FT_MulFix
(
nearest_point
.
y
-
FT_26D6_16D16
(
p
.
y
)
direction
.
x
)
;
out
-
>
distance
=
min
;
out
-
>
sign
=
cross
<
0
?
1
:
-
1
;
if
(
min_factor
!
=
0
&
&
min_factor
!
=
FT_INT_16D16
(
1
)
)
out
-
>
cross
=
FT_INT_16D16
(
1
)
;
else
{
nearest_point
.
x
-
=
FT_26D6_16D16
(
p
.
x
)
;
nearest_point
.
y
-
=
FT_26D6_16D16
(
p
.
y
)
;
FT_Vector_NormLen
(
&
direction
)
;
FT_Vector_NormLen
(
&
nearest_point
)
;
out
-
>
cross
=
FT_MulFix
(
direction
.
x
nearest_point
.
y
)
-
FT_MulFix
(
direction
.
y
nearest_point
.
x
)
;
}
Exit
:
return
error
;
}
static
FT_Error
sdf_edge_get_min_distance
(
SDF_Edge
*
edge
FT_26D6_Vec
point
SDF_Signed_Distance
*
out
)
{
FT_Error
error
=
FT_Err_Ok
;
if
(
!
edge
|
|
!
out
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
switch
(
edge
-
>
edge_type
)
{
case
SDF_EDGE_LINE
:
get_min_distance_line
(
edge
point
out
)
;
break
;
case
SDF_EDGE_CONIC
:
get_min_distance_conic
(
edge
point
out
)
;
break
;
case
SDF_EDGE_CUBIC
:
get_min_distance_cubic
(
edge
point
out
)
;
break
;
default
:
error
=
FT_THROW
(
Invalid_Argument
)
;
}
Exit
:
return
error
;
}
#
if
0
#
error
"
DO
NOT
USE
THIS
!
"
#
error
"
The
function
still
outputs
16
-
bit
data
which
might
cause
memory
"
#
error
"
corruption
.
If
required
I
will
add
this
later
.
"
static
FT_Error
sdf_contour_get_min_distance
(
SDF_Contour
*
contour
FT_26D6_Vec
point
SDF_Signed_Distance
*
out
)
{
FT_Error
error
=
FT_Err_Ok
;
SDF_Signed_Distance
min_dist
=
max_sdf
;
SDF_Edge
*
edge_list
;
if
(
!
contour
|
|
!
out
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
edge_list
=
contour
-
>
edges
;
while
(
edge_list
)
{
SDF_Signed_Distance
current_dist
=
max_sdf
;
FT_16D16
diff
;
FT_CALL
(
sdf_edge_get_min_distance
(
edge_list
point
&
current_dist
)
)
;
if
(
current_dist
.
distance
>
=
0
)
{
diff
=
current_dist
.
distance
-
min_dist
.
distance
;
if
(
FT_ABS
(
diff
)
<
CORNER_CHECK_EPSILON
)
min_dist
=
resolve_corner
(
min_dist
current_dist
)
;
else
if
(
diff
<
0
)
min_dist
=
current_dist
;
}
else
FT_TRACE0
(
(
"
sdf_contour_get_min_distance
:
Overflow
.
\
n
"
)
)
;
edge_list
=
edge_list
-
>
next
;
}
*
out
=
min_dist
;
Exit
:
return
error
;
}
static
FT_Error
sdf_generate
(
const
SDF_Params
internal_params
const
SDF_Shape
*
shape
FT_UInt
spread
const
FT_Bitmap
*
bitmap
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_UInt
width
=
0
;
FT_UInt
rows
=
0
;
FT_UInt
x
=
0
;
FT_UInt
y
=
0
;
FT_UInt
sp_sq
=
0
;
FT_Short
*
buffer
;
if
(
!
shape
|
|
!
bitmap
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
spread
<
MIN_SPREAD
|
|
spread
>
MAX_SPREAD
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
width
=
bitmap
-
>
width
;
rows
=
bitmap
-
>
rows
;
buffer
=
(
FT_Short
*
)
bitmap
-
>
buffer
;
if
(
USE_SQUARED_DISTANCES
)
sp_sq
=
FT_INT_16D16
(
spread
*
spread
)
;
else
sp_sq
=
FT_INT_16D16
(
spread
)
;
if
(
width
=
=
0
|
|
rows
=
=
0
)
{
FT_TRACE0
(
(
"
sdf_generate
:
"
"
Cannot
render
glyph
with
width
/
height
=
=
0
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
(
width
height
provided
[
%
d
%
d
]
)
\
n
"
width
rows
)
)
;
error
=
FT_THROW
(
Cannot_Render_Glyph
)
;
goto
Exit
;
}
for
(
y
=
0
;
y
<
rows
;
y
+
+
)
{
for
(
x
=
0
;
x
<
width
;
x
+
+
)
{
FT_26D6_Vec
grid_point
=
zero_vector
;
SDF_Signed_Distance
min_dist
=
max_sdf
;
SDF_Contour
*
contour_list
;
FT_UInt
index
;
FT_Short
value
;
grid_point
.
x
=
FT_INT_26D6
(
x
)
;
grid_point
.
y
=
FT_INT_26D6
(
y
)
;
grid_point
.
x
+
=
FT_INT_26D6
(
1
)
/
2
;
grid_point
.
y
+
=
FT_INT_26D6
(
1
)
/
2
;
contour_list
=
shape
-
>
contours
;
while
(
contour_list
)
{
SDF_Signed_Distance
current_dist
=
max_sdf
;
FT_CALL
(
sdf_contour_get_min_distance
(
contour_list
grid_point
&
current_dist
)
)
;
if
(
current_dist
.
distance
<
min_dist
.
distance
)
min_dist
=
current_dist
;
contour_list
=
contour_list
-
>
next
;
}
if
(
min_dist
.
distance
>
sp_sq
)
min_dist
.
distance
=
sp_sq
;
if
(
USE_SQUARED_DISTANCES
)
min_dist
.
distance
=
square_root
(
min_dist
.
distance
)
;
if
(
internal_params
.
orientation
=
=
FT_ORIENTATION_FILL_LEFT
)
min_dist
.
sign
=
-
min_dist
.
sign
;
if
(
internal_params
.
flip_sign
)
min_dist
.
sign
=
-
min_dist
.
sign
;
min_dist
.
distance
/
=
64
;
value
=
min_dist
.
distance
&
0x0000FFFF
;
value
*
=
min_dist
.
sign
;
if
(
internal_params
.
flip_y
)
index
=
y
*
width
+
x
;
else
index
=
(
rows
-
y
-
1
)
*
width
+
x
;
buffer
[
index
]
=
value
;
}
}
Exit
:
return
error
;
}
#
endif
static
FT_Error
sdf_generate_bounding_box
(
const
SDF_Params
internal_params
const
SDF_Shape
*
shape
FT_UInt
spread
const
FT_Bitmap
*
bitmap
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Memory
memory
=
NULL
;
FT_Int
width
rows
i
j
;
FT_Int
sp_sq
;
SDF_Contour
*
contours
;
FT_SDFFormat
*
buffer
;
SDF_Signed_Distance
*
dists
=
NULL
;
const
FT_16D16
fixed_spread
=
(
FT_16D16
)
FT_INT_16D16
(
spread
)
;
if
(
!
shape
|
|
!
bitmap
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
spread
<
MIN_SPREAD
|
|
spread
>
MAX_SPREAD
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
memory
=
shape
-
>
memory
;
if
(
!
memory
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
if
(
FT_ALLOC
(
dists
bitmap
-
>
width
*
bitmap
-
>
rows
*
sizeof
(
*
dists
)
)
)
goto
Exit
;
contours
=
shape
-
>
contours
;
width
=
(
FT_Int
)
bitmap
-
>
width
;
rows
=
(
FT_Int
)
bitmap
-
>
rows
;
buffer
=
(
FT_SDFFormat
*
)
bitmap
-
>
buffer
;
if
(
USE_SQUARED_DISTANCES
)
sp_sq
=
FT_INT_16D16
(
(
FT_Int
)
(
spread
*
spread
)
)
;
else
sp_sq
=
fixed_spread
;
if
(
width
=
=
0
|
|
rows
=
=
0
)
{
FT_TRACE0
(
(
"
sdf_generate
:
"
"
Cannot
render
glyph
with
width
/
height
=
=
0
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
(
width
height
provided
[
%
d
%
d
]
)
"
width
rows
)
)
;
error
=
FT_THROW
(
Cannot_Render_Glyph
)
;
goto
Exit
;
}
while
(
contours
)
{
SDF_Edge
*
edges
=
contours
-
>
edges
;
while
(
edges
)
{
FT_CBox
cbox
;
FT_Int
x
y
;
cbox
=
get_control_box
(
*
edges
)
;
cbox
.
xMin
=
(
cbox
.
xMin
-
63
)
/
64
-
(
FT_Pos
)
spread
;
cbox
.
xMax
=
(
cbox
.
xMax
+
63
)
/
64
+
(
FT_Pos
)
spread
;
cbox
.
yMin
=
(
cbox
.
yMin
-
63
)
/
64
-
(
FT_Pos
)
spread
;
cbox
.
yMax
=
(
cbox
.
yMax
+
63
)
/
64
+
(
FT_Pos
)
spread
;
for
(
y
=
cbox
.
yMin
;
y
<
cbox
.
yMax
;
y
+
+
)
{
for
(
x
=
cbox
.
xMin
;
x
<
cbox
.
xMax
;
x
+
+
)
{
FT_26D6_Vec
grid_point
=
zero_vector
;
SDF_Signed_Distance
dist
=
max_sdf
;
FT_UInt
index
=
0
;
FT_16D16
diff
=
0
;
if
(
x
<
0
|
|
x
>
=
width
)
continue
;
if
(
y
<
0
|
|
y
>
=
rows
)
continue
;
grid_point
.
x
=
FT_INT_26D6
(
x
)
;
grid_point
.
y
=
FT_INT_26D6
(
y
)
;
grid_point
.
x
+
=
FT_INT_26D6
(
1
)
/
2
;
grid_point
.
y
+
=
FT_INT_26D6
(
1
)
/
2
;
FT_CALL
(
sdf_edge_get_min_distance
(
edges
grid_point
&
dist
)
)
;
if
(
internal_params
.
orientation
=
=
FT_ORIENTATION_FILL_LEFT
)
dist
.
sign
=
-
dist
.
sign
;
if
(
dist
.
distance
>
sp_sq
)
continue
;
if
(
USE_SQUARED_DISTANCES
)
dist
.
distance
=
square_root
(
dist
.
distance
)
;
if
(
internal_params
.
flip_y
)
index
=
(
FT_UInt
)
(
y
*
width
+
x
)
;
else
index
=
(
FT_UInt
)
(
(
rows
-
y
-
1
)
*
width
+
x
)
;
if
(
dists
[
index
]
.
sign
=
=
0
)
dists
[
index
]
=
dist
;
else
{
diff
=
FT_ABS
(
dists
[
index
]
.
distance
-
dist
.
distance
)
;
if
(
diff
<
=
CORNER_CHECK_EPSILON
)
dists
[
index
]
=
resolve_corner
(
dists
[
index
]
dist
)
;
else
if
(
dists
[
index
]
.
distance
>
dist
.
distance
)
dists
[
index
]
=
dist
;
}
}
}
edges
=
edges
-
>
next
;
}
contours
=
contours
-
>
next
;
}
for
(
j
=
0
;
j
<
rows
;
j
+
+
)
{
FT_Char
current_sign
=
-
1
;
FT_UInt
index
;
if
(
internal_params
.
overload_sign
!
=
0
)
current_sign
=
internal_params
.
overload_sign
<
0
?
-
1
:
1
;
for
(
i
=
0
;
i
<
width
;
i
+
+
)
{
index
=
(
FT_UInt
)
(
j
*
width
+
i
)
;
if
(
dists
[
index
]
.
sign
=
=
0
)
dists
[
index
]
.
distance
=
fixed_spread
;
else
current_sign
=
dists
[
index
]
.
sign
;
if
(
dists
[
index
]
.
distance
>
fixed_spread
)
dists
[
index
]
.
distance
=
fixed_spread
;
dists
[
index
]
.
distance
*
=
internal_params
.
flip_sign
?
-
current_sign
:
current_sign
;
buffer
[
index
]
=
map_fixed_to_sdf
(
dists
[
index
]
.
distance
fixed_spread
)
;
}
}
Exit
:
FT_FREE
(
dists
)
;
return
error
;
}
static
FT_Error
sdf_generate_subdivision
(
const
SDF_Params
internal_params
SDF_Shape
*
shape
FT_UInt
spread
const
FT_Bitmap
*
bitmap
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_CALL
(
split_sdf_shape
(
shape
)
)
;
FT_CALL
(
sdf_generate_bounding_box
(
internal_params
shape
spread
bitmap
)
)
;
Exit
:
return
error
;
}
static
FT_Error
sdf_generate_with_overlaps
(
SDF_Params
internal_params
SDF_Shape
*
shape
FT_UInt
spread
const
FT_Bitmap
*
bitmap
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Int
num_contours
;
FT_Int
i
j
;
FT_Int
width
rows
;
FT_Bitmap
*
bitmaps
;
SDF_Contour
*
contour
;
SDF_Contour
*
temp_contour
;
SDF_Contour
*
head
;
SDF_Shape
temp_shape
;
FT_Memory
memory
;
FT_SDFFormat
*
t
;
FT_Bool
flip_sign
;
SDF_Contour_Orientation
*
orientations
;
bitmaps
=
NULL
;
orientations
=
NULL
;
head
=
NULL
;
if
(
!
shape
|
|
!
bitmap
|
|
!
shape
-
>
memory
)
return
FT_THROW
(
Invalid_Argument
)
;
flip_sign
=
internal_params
.
flip_sign
;
internal_params
.
flip_sign
=
0
;
contour
=
shape
-
>
contours
;
memory
=
shape
-
>
memory
;
temp_shape
.
memory
=
memory
;
width
=
(
FT_Int
)
bitmap
-
>
width
;
rows
=
(
FT_Int
)
bitmap
-
>
rows
;
num_contours
=
0
;
while
(
contour
)
{
num_contours
+
+
;
contour
=
contour
-
>
next
;
}
if
(
FT_ALLOC
(
bitmaps
(
FT_UInt
)
num_contours
*
sizeof
(
*
bitmaps
)
)
)
goto
Exit
;
if
(
FT_ALLOC
(
orientations
(
FT_UInt
)
num_contours
*
sizeof
(
*
orientations
)
)
)
goto
Exit
;
contour
=
shape
-
>
contours
;
for
(
i
=
0
;
i
<
num_contours
;
i
+
+
)
{
FT_Bitmap_Init
(
&
bitmaps
[
i
]
)
;
bitmaps
[
i
]
.
width
=
bitmap
-
>
width
;
bitmaps
[
i
]
.
rows
=
bitmap
-
>
rows
;
bitmaps
[
i
]
.
pitch
=
bitmap
-
>
pitch
;
bitmaps
[
i
]
.
num_grays
=
bitmap
-
>
num_grays
;
bitmaps
[
i
]
.
pixel_mode
=
bitmap
-
>
pixel_mode
;
if
(
FT_ALLOC
(
bitmaps
[
i
]
.
buffer
bitmap
-
>
rows
*
(
FT_UInt
)
bitmap
-
>
pitch
)
)
goto
Exit
;
orientations
[
i
]
=
get_contour_orientation
(
contour
)
;
if
(
orientations
[
i
]
=
=
SDF_ORIENTATION_CCW
&
&
internal_params
.
orientation
=
=
FT_ORIENTATION_FILL_RIGHT
)
internal_params
.
overload_sign
=
1
;
else
if
(
orientations
[
i
]
=
=
SDF_ORIENTATION_CW
&
&
internal_params
.
orientation
=
=
FT_ORIENTATION_FILL_LEFT
)
internal_params
.
overload_sign
=
1
;
else
internal_params
.
overload_sign
=
0
;
temp_contour
=
contour
-
>
next
;
contour
-
>
next
=
NULL
;
temp_shape
.
contours
=
contour
;
FT_CALL
(
sdf_generate_subdivision
(
internal_params
&
temp_shape
spread
&
bitmaps
[
i
]
)
)
;
contour
-
>
next
=
temp_contour
;
temp_shape
.
contours
-
>
next
=
head
;
head
=
temp_shape
.
contours
;
if
(
internal_params
.
orientation
=
=
FT_ORIENTATION_FILL_LEFT
)
{
if
(
orientations
[
i
]
=
=
SDF_ORIENTATION_CW
)
orientations
[
i
]
=
SDF_ORIENTATION_CCW
;
else
if
(
orientations
[
i
]
=
=
SDF_ORIENTATION_CCW
)
orientations
[
i
]
=
SDF_ORIENTATION_CW
;
}
contour
=
contour
-
>
next
;
}
shape
-
>
contours
=
head
;
t
=
(
FT_SDFFormat
*
)
bitmap
-
>
buffer
;
for
(
j
=
0
;
j
<
rows
;
j
+
+
)
{
for
(
i
=
0
;
i
<
width
;
i
+
+
)
{
FT_Int
id
=
j
*
width
+
i
;
FT_Int
c
;
FT_SDFFormat
val_c
=
0
;
FT_SDFFormat
val_ac
=
UCHAR_MAX
;
for
(
c
=
0
;
c
<
num_contours
;
c
+
+
)
{
FT_SDFFormat
temp
=
(
(
FT_SDFFormat
*
)
bitmaps
[
c
]
.
buffer
)
[
id
]
;
if
(
orientations
[
c
]
=
=
SDF_ORIENTATION_CW
)
val_c
=
FT_MAX
(
val_c
temp
)
;
else
val_ac
=
FT_MIN
(
val_ac
temp
)
;
}
t
[
id
]
=
FT_MIN
(
val_c
val_ac
)
;
if
(
flip_sign
)
t
[
id
]
=
invert_sign
(
t
[
id
]
)
;
}
}
Exit
:
if
(
orientations
)
FT_FREE
(
orientations
)
;
if
(
bitmaps
)
{
if
(
num_contours
=
=
0
)
error
=
FT_THROW
(
Raster_Corrupted
)
;
else
{
for
(
i
=
0
;
i
<
num_contours
;
i
+
+
)
FT_FREE
(
bitmaps
[
i
]
.
buffer
)
;
FT_FREE
(
bitmaps
)
;
}
}
internal_params
.
flip_sign
=
flip_sign
;
return
error
;
}
static
FT_Error
sdf_raster_new
(
void
*
memory_
FT_Raster
*
araster_
)
{
FT_Memory
memory
=
(
FT_Memory
)
memory_
;
SDF_PRaster
*
araster
=
(
SDF_PRaster
*
)
araster_
;
FT_Error
error
;
SDF_PRaster
raster
=
NULL
;
if
(
!
FT_NEW
(
raster
)
)
raster
-
>
memory
=
memory
;
*
araster
=
raster
;
return
error
;
}
static
void
sdf_raster_reset
(
FT_Raster
raster
unsigned
char
*
pool_base
unsigned
long
pool_size
)
{
FT_UNUSED
(
raster
)
;
FT_UNUSED
(
pool_base
)
;
FT_UNUSED
(
pool_size
)
;
}
static
FT_Error
sdf_raster_set_mode
(
FT_Raster
raster
unsigned
long
mode
void
*
args
)
{
FT_UNUSED
(
raster
)
;
FT_UNUSED
(
mode
)
;
FT_UNUSED
(
args
)
;
return
FT_Err_Ok
;
}
static
FT_Error
sdf_raster_render
(
FT_Raster
raster
const
FT_Raster_Params
*
params
)
{
FT_Error
error
=
FT_Err_Ok
;
SDF_TRaster
*
sdf_raster
=
(
SDF_TRaster
*
)
raster
;
FT_Outline
*
outline
=
NULL
;
const
SDF_Raster_Params
*
sdf_params
=
(
const
SDF_Raster_Params
*
)
params
;
FT_Memory
memory
=
NULL
;
SDF_Shape
*
shape
=
NULL
;
SDF_Params
internal_params
;
if
(
!
sdf_raster
|
|
!
sdf_params
)
{
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
outline
=
(
FT_Outline
*
)
sdf_params
-
>
root
.
source
;
if
(
!
outline
)
{
error
=
FT_THROW
(
Invalid_Outline
)
;
goto
Exit
;
}
if
(
outline
-
>
n_points
=
=
0
|
|
outline
-
>
n_contours
=
=
0
)
goto
Exit
;
if
(
!
outline
-
>
contours
|
|
!
outline
-
>
points
)
{
error
=
FT_THROW
(
Invalid_Outline
)
;
goto
Exit
;
}
if
(
sdf_params
-
>
spread
>
MAX_SPREAD
|
|
sdf_params
-
>
spread
<
MIN_SPREAD
)
{
FT_TRACE0
(
(
"
sdf_raster_render
:
"
"
The
spread
'
field
of
SDF_Raster_Params
'
is
invalid
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
the
value
of
this
field
must
be
within
[
%
d
%
d
]
.
\
n
"
MIN_SPREAD
MAX_SPREAD
)
)
;
FT_TRACE0
(
(
"
"
"
Also
you
must
pass
SDF_Raster_Params
'
instead
of
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
the
default
FT_Raster_Params
'
while
calling
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
this
function
and
set
the
fields
properly
.
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
memory
=
sdf_raster
-
>
memory
;
if
(
!
memory
)
{
FT_TRACE0
(
(
"
sdf_raster_render
:
"
"
Raster
not
setup
properly
\
n
"
)
)
;
FT_TRACE0
(
(
"
"
"
unable
to
find
memory
handle
.
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_Handle
)
;
goto
Exit
;
}
internal_params
.
orientation
=
FT_Outline_Get_Orientation
(
outline
)
;
internal_params
.
flip_sign
=
sdf_params
-
>
flip_sign
;
internal_params
.
flip_y
=
sdf_params
-
>
flip_y
;
internal_params
.
overload_sign
=
0
;
FT_CALL
(
sdf_shape_new
(
memory
&
shape
)
)
;
FT_CALL
(
sdf_outline_decompose
(
outline
shape
)
)
;
if
(
sdf_params
-
>
overlaps
)
FT_CALL
(
sdf_generate_with_overlaps
(
internal_params
shape
sdf_params
-
>
spread
sdf_params
-
>
root
.
target
)
)
;
else
FT_CALL
(
sdf_generate_subdivision
(
internal_params
shape
sdf_params
-
>
spread
sdf_params
-
>
root
.
target
)
)
;
if
(
shape
)
sdf_shape_done
(
&
shape
)
;
Exit
:
return
error
;
}
static
void
sdf_raster_done
(
FT_Raster
raster
)
{
FT_Memory
memory
=
(
FT_Memory
)
(
(
SDF_TRaster
*
)
raster
)
-
>
memory
;
FT_FREE
(
raster
)
;
}
FT_DEFINE_RASTER_FUNCS
(
ft_sdf_raster
FT_GLYPH_FORMAT_OUTLINE
(
FT_Raster_New_Func
)
sdf_raster_new
(
FT_Raster_Reset_Func
)
sdf_raster_reset
(
FT_Raster_Set_Mode_Func
)
sdf_raster_set_mode
(
FT_Raster_Render_Func
)
sdf_raster_render
(
FT_Raster_Done_Func
)
sdf_raster_done
)
