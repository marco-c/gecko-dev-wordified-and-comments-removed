#
include
"
psft
.
h
"
#
include
FT_INTERNAL_DEBUG_H
#
include
FT_SERVICE_CFF_TABLE_LOAD_H
#
include
"
psglue
.
h
"
#
include
"
psfont
.
h
"
#
include
"
psstack
.
h
"
#
include
"
pshints
.
h
"
#
include
"
psintrp
.
h
"
#
include
"
pserror
.
h
"
#
include
"
psobjs
.
h
"
#
include
"
t1decode
.
h
"
#
undef
FT_COMPONENT
#
define
FT_COMPONENT
trace_cf2interp
FT_LOCAL_DEF
(
void
)
cf2_hintmask_init
(
CF2_HintMask
hintmask
FT_Error
*
error
)
{
FT_ZERO
(
hintmask
)
;
hintmask
-
>
error
=
error
;
}
FT_LOCAL_DEF
(
FT_Bool
)
cf2_hintmask_isValid
(
const
CF2_HintMask
hintmask
)
{
return
hintmask
-
>
isValid
;
}
FT_LOCAL_DEF
(
FT_Bool
)
cf2_hintmask_isNew
(
const
CF2_HintMask
hintmask
)
{
return
hintmask
-
>
isNew
;
}
FT_LOCAL_DEF
(
void
)
cf2_hintmask_setNew
(
CF2_HintMask
hintmask
FT_Bool
val
)
{
hintmask
-
>
isNew
=
val
;
}
FT_LOCAL_DEF
(
FT_Byte
*
)
cf2_hintmask_getMaskPtr
(
CF2_HintMask
hintmask
)
{
return
hintmask
-
>
mask
;
}
static
size_t
cf2_hintmask_setCounts
(
CF2_HintMask
hintmask
size_t
bitCount
)
{
if
(
bitCount
>
CF2_MAX_HINTS
)
{
CF2_SET_ERROR
(
hintmask
-
>
error
Invalid_Glyph_Format
)
;
return
0
;
}
hintmask
-
>
bitCount
=
bitCount
;
hintmask
-
>
byteCount
=
(
hintmask
-
>
bitCount
+
7
)
/
8
;
hintmask
-
>
isValid
=
TRUE
;
hintmask
-
>
isNew
=
TRUE
;
return
bitCount
;
}
static
void
cf2_hintmask_read
(
CF2_HintMask
hintmask
CF2_Buffer
charstring
size_t
bitCount
)
{
size_t
i
;
#
ifndef
CF2_NDEBUG
CF2_UInt
mask
=
(
1
<
<
(
-
(
CF2_Int
)
bitCount
&
7
)
)
-
1
;
#
endif
if
(
cf2_hintmask_setCounts
(
hintmask
bitCount
)
=
=
0
)
return
;
FT_ASSERT
(
hintmask
-
>
byteCount
>
0
)
;
FT_TRACE4
(
(
"
(
maskbytes
:
"
)
)
;
for
(
i
=
0
;
i
<
hintmask
-
>
byteCount
;
i
+
+
)
{
hintmask
-
>
mask
[
i
]
=
(
FT_Byte
)
cf2_buf_readByte
(
charstring
)
;
FT_TRACE4
(
(
"
0x
%
02X
"
hintmask
-
>
mask
[
i
]
)
)
;
}
FT_TRACE4
(
(
"
)
\
n
"
)
)
;
#
ifndef
CF2_NDEBUG
FT_ASSERT
(
(
hintmask
-
>
mask
[
hintmask
-
>
byteCount
-
1
]
&
mask
)
=
=
0
|
|
*
hintmask
-
>
error
)
;
#
endif
}
FT_LOCAL_DEF
(
void
)
cf2_hintmask_setAll
(
CF2_HintMask
hintmask
size_t
bitCount
)
{
size_t
i
;
CF2_UInt
mask
=
(
1
<
<
(
-
(
CF2_Int
)
bitCount
&
7
)
)
-
1
;
if
(
cf2_hintmask_setCounts
(
hintmask
bitCount
)
=
=
0
)
return
;
FT_ASSERT
(
hintmask
-
>
byteCount
>
0
)
;
FT_ASSERT
(
hintmask
-
>
byteCount
<
=
sizeof
(
hintmask
-
>
mask
)
/
sizeof
(
hintmask
-
>
mask
[
0
]
)
)
;
for
(
i
=
0
;
i
<
hintmask
-
>
byteCount
;
i
+
+
)
hintmask
-
>
mask
[
i
]
=
0xFF
;
hintmask
-
>
mask
[
hintmask
-
>
byteCount
-
1
]
&
=
~
mask
;
}
enum
{
cf2_cmdRESERVED_0
cf2_cmdHSTEM
cf2_cmdRESERVED_2
cf2_cmdVSTEM
cf2_cmdVMOVETO
cf2_cmdRLINETO
cf2_cmdHLINETO
cf2_cmdVLINETO
cf2_cmdRRCURVETO
cf2_cmdCLOSEPATH
cf2_cmdCALLSUBR
cf2_cmdRETURN
cf2_cmdESC
cf2_cmdHSBW
cf2_cmdENDCHAR
cf2_cmdVSINDEX
cf2_cmdBLEND
cf2_cmdRESERVED_17
cf2_cmdHSTEMHM
cf2_cmdHINTMASK
cf2_cmdCNTRMASK
cf2_cmdRMOVETO
cf2_cmdHMOVETO
cf2_cmdVSTEMHM
cf2_cmdRCURVELINE
cf2_cmdRLINECURVE
cf2_cmdVVCURVETO
cf2_cmdHHCURVETO
cf2_cmdEXTENDEDNMBR
cf2_cmdCALLGSUBR
cf2_cmdVHCURVETO
cf2_cmdHVCURVETO
}
;
enum
{
cf2_escDOTSECTION
cf2_escVSTEM3
cf2_escHSTEM3
cf2_escAND
cf2_escOR
cf2_escNOT
cf2_escSEAC
cf2_escSBW
cf2_escRESERVED_8
cf2_escABS
cf2_escADD
cf2_escSUB
cf2_escDIV
cf2_escRESERVED_13
cf2_escNEG
cf2_escEQ
cf2_escCALLOTHERSUBR
cf2_escPOP
cf2_escDROP
cf2_escRESERVED_19
cf2_escPUT
cf2_escGET
cf2_escIFELSE
cf2_escRANDOM
cf2_escMUL
cf2_escRESERVED_25
cf2_escSQRT
cf2_escDUP
cf2_escEXCH
cf2_escINDEX
cf2_escROLL
cf2_escRESERVED_31
cf2_escRESERVED_32
cf2_escSETCURRENTPT
cf2_escHFLEX
cf2_escFLEX
cf2_escHFLEX1
cf2_escFLEX1
cf2_escRESERVED_38
}
;
static
void
cf2_doStems
(
const
CF2_Font
font
CF2_Stack
opStack
CF2_ArrStack
stemHintArray
CF2_Fixed
*
width
FT_Bool
*
haveWidth
CF2_Fixed
hintOffset
)
{
CF2_UInt
i
;
CF2_UInt
count
=
cf2_stack_count
(
opStack
)
;
FT_Bool
hasWidthArg
=
(
FT_Bool
)
(
count
&
1
)
;
CF2_Fixed
position
=
hintOffset
;
if
(
font
-
>
isT1
&
&
!
font
-
>
decoder
-
>
flex_state
&
&
!
*
haveWidth
)
FT_ERROR
(
(
"
cf2_doStems
(
Type
1
mode
)
:
"
"
No
width
.
Use
hsbw
/
sbw
as
first
op
\
n
"
)
)
;
if
(
!
font
-
>
isT1
&
&
hasWidthArg
&
&
!
*
haveWidth
)
*
width
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
0
)
cf2_getNominalWidthX
(
font
-
>
decoder
)
)
;
if
(
font
-
>
decoder
-
>
width_only
)
goto
exit
;
for
(
i
=
hasWidthArg
?
1
:
0
;
i
<
count
;
i
+
=
2
)
{
CF2_StemHintRec
stemhint
;
stemhint
.
min
=
position
=
ADD_INT32
(
position
cf2_stack_getReal
(
opStack
i
)
)
;
stemhint
.
max
=
position
=
ADD_INT32
(
position
cf2_stack_getReal
(
opStack
i
+
1
)
)
;
stemhint
.
used
=
FALSE
;
stemhint
.
maxDS
=
stemhint
.
minDS
=
0
;
cf2_arrstack_push
(
stemHintArray
&
stemhint
)
;
}
cf2_stack_clear
(
opStack
)
;
exit
:
*
haveWidth
=
TRUE
;
}
static
void
cf2_doFlex
(
CF2_Stack
opStack
CF2_Fixed
*
curX
CF2_Fixed
*
curY
CF2_GlyphPath
glyphPath
const
FT_Bool
*
readFromStack
FT_Bool
doConditionalLastRead
)
{
CF2_Fixed
vals
[
14
]
;
CF2_UInt
idx
;
FT_Bool
isHFlex
;
CF2_Int
top
i
j
;
vals
[
0
]
=
*
curX
;
vals
[
1
]
=
*
curY
;
idx
=
0
;
isHFlex
=
FT_BOOL
(
readFromStack
[
9
]
=
=
FALSE
)
;
top
=
isHFlex
?
9
:
10
;
for
(
i
=
0
;
i
<
top
;
i
+
+
)
{
vals
[
i
+
2
]
=
vals
[
i
]
;
if
(
readFromStack
[
i
]
)
vals
[
i
+
2
]
=
ADD_INT32
(
vals
[
i
+
2
]
cf2_stack_getReal
(
opStack
idx
+
+
)
)
;
}
if
(
isHFlex
)
vals
[
9
+
2
]
=
*
curY
;
if
(
doConditionalLastRead
)
{
FT_Bool
lastIsX
=
(
FT_Bool
)
(
cf2_fixedAbs
(
SUB_INT32
(
vals
[
10
]
*
curX
)
)
>
cf2_fixedAbs
(
SUB_INT32
(
vals
[
11
]
*
curY
)
)
)
;
CF2_Fixed
lastVal
=
cf2_stack_getReal
(
opStack
idx
)
;
if
(
lastIsX
)
{
vals
[
12
]
=
ADD_INT32
(
vals
[
10
]
lastVal
)
;
vals
[
13
]
=
*
curY
;
}
else
{
vals
[
12
]
=
*
curX
;
vals
[
13
]
=
ADD_INT32
(
vals
[
11
]
lastVal
)
;
}
}
else
{
if
(
readFromStack
[
10
]
)
vals
[
12
]
=
ADD_INT32
(
vals
[
10
]
cf2_stack_getReal
(
opStack
idx
+
+
)
)
;
else
vals
[
12
]
=
*
curX
;
if
(
readFromStack
[
11
]
)
vals
[
13
]
=
ADD_INT32
(
vals
[
11
]
cf2_stack_getReal
(
opStack
idx
)
)
;
else
vals
[
13
]
=
*
curY
;
}
for
(
j
=
0
;
j
<
2
;
j
+
+
)
cf2_glyphpath_curveTo
(
glyphPath
vals
[
j
*
6
+
2
]
vals
[
j
*
6
+
3
]
vals
[
j
*
6
+
4
]
vals
[
j
*
6
+
5
]
vals
[
j
*
6
+
6
]
vals
[
j
*
6
+
7
]
)
;
cf2_stack_clear
(
opStack
)
;
*
curX
=
vals
[
12
]
;
*
curY
=
vals
[
13
]
;
}
static
void
cf2_doBlend
(
const
CFF_Blend
blend
CF2_Stack
opStack
CF2_UInt
numBlends
)
{
CF2_UInt
delta
;
CF2_UInt
base
;
CF2_UInt
i
j
;
CF2_UInt
numOperands
=
(
CF2_UInt
)
(
numBlends
*
blend
-
>
lenBV
)
;
base
=
cf2_stack_count
(
opStack
)
-
numOperands
;
delta
=
base
+
numBlends
;
for
(
i
=
0
;
i
<
numBlends
;
i
+
+
)
{
const
CF2_Fixed
*
weight
=
&
blend
-
>
BV
[
1
]
;
CF2_Fixed
sum
=
cf2_stack_getReal
(
opStack
i
+
base
)
;
for
(
j
=
1
;
j
<
blend
-
>
lenBV
;
j
+
+
)
sum
=
ADD_INT32
(
sum
FT_MulFix
(
*
weight
+
+
cf2_stack_getReal
(
opStack
delta
+
+
)
)
)
;
cf2_stack_setReal
(
opStack
i
+
base
sum
)
;
}
cf2_stack_pop
(
opStack
numOperands
-
numBlends
)
;
}
FT_LOCAL_DEF
(
void
)
cf2_interpT2CharString
(
CF2_Font
font
CF2_Buffer
buf
CF2_OutlineCallbacks
callbacks
const
FT_Vector
*
translation
FT_Bool
doingSeac
CF2_Fixed
curX
CF2_Fixed
curY
CF2_Fixed
*
width
)
{
FT_Error
lastError
=
FT_Err_Ok
;
PS_Decoder
*
decoder
=
font
-
>
decoder
;
FT_Error
*
error
=
&
font
-
>
error
;
FT_Memory
memory
=
font
-
>
memory
;
CF2_Fixed
scaleY
=
font
-
>
innerTransform
.
d
;
CF2_Fixed
nominalWidthX
=
cf2_getNominalWidthX
(
decoder
)
;
FT_Int
known_othersubr_result_cnt
=
0
;
FT_Bool
large_int
=
FALSE
;
FT_Bool
initial_map_ready
=
FALSE
;
#
define
PS_STORAGE_SIZE
3
CF2_F16Dot16
results
[
PS_STORAGE_SIZE
]
;
FT_Int
result_cnt
=
0
;
CF2_Fixed
hintOriginY
=
curY
;
CF2_Stack
opStack
=
NULL
;
FT_UInt
stackSize
;
FT_Byte
op1
;
CF2_F16Dot16
storage
[
CF2_STORAGE_SIZE
]
;
CF2_F16Dot16
flexStore
[
6
]
;
FT_UInt32
instructionLimit
=
20000000UL
;
CF2_ArrStackRec
subrStack
;
FT_Bool
haveWidth
;
CF2_Buffer
charstring
=
NULL
;
CF2_Int
charstringIndex
=
-
1
;
CF2_ArrStackRec
hStemHintArray
;
CF2_ArrStackRec
vStemHintArray
;
CF2_HintMaskRec
hintMask
;
CF2_GlyphPathRec
glyphPath
;
FT_ZERO
(
&
storage
)
;
FT_ZERO
(
&
results
)
;
FT_ZERO
(
&
flexStore
)
;
cf2_arrstack_init
(
&
subrStack
memory
error
sizeof
(
CF2_BufferRec
)
)
;
cf2_arrstack_init
(
&
hStemHintArray
memory
error
sizeof
(
CF2_StemHintRec
)
)
;
cf2_arrstack_init
(
&
vStemHintArray
memory
error
sizeof
(
CF2_StemHintRec
)
)
;
cf2_hintmask_init
(
&
hintMask
error
)
;
cf2_glyphpath_init
(
&
glyphPath
font
callbacks
scaleY
&
hStemHintArray
&
vStemHintArray
&
hintMask
hintOriginY
&
font
-
>
blues
translation
)
;
haveWidth
=
font
-
>
isCFF2
?
TRUE
:
FALSE
;
*
width
=
cf2_getDefaultWidthX
(
decoder
)
;
stackSize
=
font
-
>
isCFF2
?
cf2_getMaxstack
(
decoder
)
:
CF2_OPERAND_STACK_SIZE
;
opStack
=
cf2_stack_init
(
memory
error
stackSize
)
;
if
(
!
opStack
)
{
lastError
=
FT_THROW
(
Out_Of_Memory
)
;
goto
exit
;
}
cf2_arrstack_setCount
(
&
subrStack
CF2_MAX_SUBR
+
1
)
;
charstring
=
(
CF2_Buffer
)
cf2_arrstack_getBuffer
(
&
subrStack
)
;
*
charstring
=
*
buf
;
charstringIndex
=
0
;
if
(
*
error
)
goto
exit
;
while
(
1
)
{
if
(
font
-
>
isT1
)
FT_ASSERT
(
known_othersubr_result_cnt
=
=
0
|
|
result_cnt
=
=
0
)
;
if
(
cf2_buf_isEnd
(
charstring
)
)
{
if
(
charstringIndex
)
op1
=
cf2_cmdRETURN
;
else
op1
=
cf2_cmdENDCHAR
;
}
else
{
op1
=
(
FT_Byte
)
cf2_buf_readByte
(
charstring
)
;
if
(
(
op1
=
=
cf2_cmdRETURN
|
|
op1
=
=
cf2_cmdENDCHAR
)
&
&
font
-
>
isCFF2
)
op1
=
cf2_cmdRESERVED_0
;
}
if
(
font
-
>
isT1
)
{
if
(
!
initial_map_ready
&
&
!
(
op1
=
=
cf2_cmdHSTEM
|
|
op1
=
=
cf2_cmdVSTEM
|
|
op1
=
=
cf2_cmdHSBW
|
|
op1
=
=
cf2_cmdCALLSUBR
|
|
op1
=
=
cf2_cmdRETURN
|
|
op1
=
=
cf2_cmdESC
|
|
op1
=
=
cf2_cmdENDCHAR
|
|
op1
>
=
32
)
)
{
cf2_stack_clear
(
opStack
)
;
continue
;
}
if
(
result_cnt
>
0
&
&
!
(
op1
=
=
cf2_cmdCALLSUBR
|
|
op1
=
=
cf2_cmdRETURN
|
|
op1
=
=
cf2_cmdESC
|
|
op1
>
=
32
)
)
{
result_cnt
=
0
;
}
if
(
large_int
&
&
!
(
op1
>
=
32
|
|
op1
=
=
cf2_escDIV
)
)
{
FT_ERROR
(
(
"
cf2_interpT2CharString
(
Type
1
mode
)
:
"
"
no
div
'
after
large
integer
\
n
"
)
)
;
large_int
=
FALSE
;
}
}
if
(
*
error
)
goto
exit
;
instructionLimit
-
-
;
if
(
instructionLimit
=
=
0
)
{
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
switch
(
op1
)
{
case
cf2_cmdRESERVED_0
:
case
cf2_cmdRESERVED_2
:
case
cf2_cmdRESERVED_17
:
FT_TRACE4
(
(
"
unknown
op
(
%
d
)
\
n
"
op1
)
)
;
break
;
case
cf2_cmdVSINDEX
:
FT_TRACE4
(
(
"
vsindex
\
n
"
)
)
;
if
(
!
font
-
>
isCFF2
)
break
;
if
(
font
-
>
blend
.
usedBV
)
{
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
{
FT_Int
temp
=
cf2_stack_popInt
(
opStack
)
;
if
(
temp
>
=
0
)
font
-
>
vsindex
=
(
FT_UInt
)
temp
;
}
break
;
case
cf2_cmdBLEND
:
{
FT_UInt
numBlends
;
FT_TRACE4
(
(
"
blend
\
n
"
)
)
;
if
(
!
font
-
>
isCFF2
)
break
;
if
(
!
font
-
>
blend
.
font
)
{
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
if
(
font
-
>
cffload
-
>
blend_check_vector
(
&
font
-
>
blend
font
-
>
vsindex
font
-
>
lenNDV
font
-
>
NDV
)
)
{
lastError
=
font
-
>
cffload
-
>
blend_build_vector
(
&
font
-
>
blend
font
-
>
vsindex
font
-
>
lenNDV
font
-
>
NDV
)
;
if
(
lastError
)
goto
exit
;
}
numBlends
=
(
FT_UInt
)
cf2_stack_popInt
(
opStack
)
;
if
(
numBlends
>
stackSize
)
{
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
cf2_doBlend
(
&
font
-
>
blend
opStack
numBlends
)
;
font
-
>
blend
.
usedBV
=
TRUE
;
}
continue
;
case
cf2_cmdHSTEMHM
:
case
cf2_cmdHSTEM
:
FT_TRACE4
(
(
op1
=
=
cf2_cmdHSTEMHM
?
"
hstemhm
\
n
"
:
"
hstem
\
n
"
)
)
;
if
(
!
font
-
>
isT1
)
{
if
(
cf2_hintmask_isValid
(
&
hintMask
)
)
{
FT_TRACE4
(
(
"
cf2_interpT2CharString
:
"
"
invalid
horizontal
hint
mask
\
n
"
)
)
;
break
;
}
}
cf2_doStems
(
font
opStack
&
hStemHintArray
width
&
haveWidth
font
-
>
isT1
?
decoder
-
>
builder
.
left_bearing
-
>
y
:
0
)
;
if
(
decoder
-
>
width_only
)
goto
exit
;
break
;
case
cf2_cmdVSTEMHM
:
case
cf2_cmdVSTEM
:
FT_TRACE4
(
(
op1
=
=
cf2_cmdVSTEMHM
?
"
vstemhm
\
n
"
:
"
vstem
\
n
"
)
)
;
if
(
!
font
-
>
isT1
)
{
if
(
cf2_hintmask_isValid
(
&
hintMask
)
)
{
FT_TRACE4
(
(
"
cf2_interpT2CharString
:
"
"
invalid
vertical
hint
mask
\
n
"
)
)
;
break
;
}
}
cf2_doStems
(
font
opStack
&
vStemHintArray
width
&
haveWidth
font
-
>
isT1
?
decoder
-
>
builder
.
left_bearing
-
>
x
:
0
)
;
if
(
decoder
-
>
width_only
)
goto
exit
;
break
;
case
cf2_cmdVMOVETO
:
FT_TRACE4
(
(
"
vmoveto
\
n
"
)
)
;
if
(
font
-
>
isT1
&
&
!
decoder
-
>
flex_state
&
&
!
haveWidth
)
FT_ERROR
(
(
"
cf2_interpT2CharString
(
Type
1
mode
)
:
"
"
No
width
.
Use
hsbw
/
sbw
as
first
op
\
n
"
)
)
;
if
(
cf2_stack_count
(
opStack
)
>
1
&
&
!
haveWidth
)
*
width
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
0
)
nominalWidthX
)
;
haveWidth
=
TRUE
;
if
(
decoder
-
>
width_only
)
goto
exit
;
curY
=
ADD_INT32
(
curY
cf2_stack_popFixed
(
opStack
)
)
;
cf2_glyphpath_moveTo
(
&
glyphPath
curX
curY
)
;
break
;
case
cf2_cmdRLINETO
:
{
CF2_UInt
idx
;
CF2_UInt
count
=
cf2_stack_count
(
opStack
)
;
FT_TRACE4
(
(
"
rlineto
\
n
"
)
)
;
for
(
idx
=
0
;
idx
<
count
;
idx
+
=
2
)
{
curX
=
ADD_INT32
(
curX
cf2_stack_getReal
(
opStack
idx
+
0
)
)
;
curY
=
ADD_INT32
(
curY
cf2_stack_getReal
(
opStack
idx
+
1
)
)
;
cf2_glyphpath_lineTo
(
&
glyphPath
curX
curY
)
;
}
cf2_stack_clear
(
opStack
)
;
}
continue
;
case
cf2_cmdHLINETO
:
case
cf2_cmdVLINETO
:
{
CF2_UInt
idx
;
CF2_UInt
count
=
cf2_stack_count
(
opStack
)
;
FT_Bool
isX
=
FT_BOOL
(
op1
=
=
cf2_cmdHLINETO
)
;
FT_TRACE4
(
(
isX
?
"
hlineto
\
n
"
:
"
vlineto
\
n
"
)
)
;
for
(
idx
=
0
;
idx
<
count
;
idx
+
+
)
{
CF2_Fixed
v
=
cf2_stack_getReal
(
opStack
idx
)
;
if
(
isX
)
curX
=
ADD_INT32
(
curX
v
)
;
else
curY
=
ADD_INT32
(
curY
v
)
;
isX
=
!
isX
;
cf2_glyphpath_lineTo
(
&
glyphPath
curX
curY
)
;
}
cf2_stack_clear
(
opStack
)
;
}
continue
;
case
cf2_cmdRCURVELINE
:
case
cf2_cmdRRCURVETO
:
{
CF2_UInt
count
=
cf2_stack_count
(
opStack
)
;
CF2_UInt
idx
=
0
;
FT_TRACE4
(
(
op1
=
=
cf2_cmdRCURVELINE
?
"
rcurveline
\
n
"
:
"
rrcurveto
\
n
"
)
)
;
while
(
idx
+
6
<
=
count
)
{
CF2_Fixed
x1
y1
x2
y2
x3
y3
;
x1
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
0
)
curX
)
;
y1
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
1
)
curY
)
;
x2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
2
)
x1
)
;
y2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
3
)
y1
)
;
x3
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
4
)
x2
)
;
y3
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
5
)
y2
)
;
cf2_glyphpath_curveTo
(
&
glyphPath
x1
y1
x2
y2
x3
y3
)
;
curX
=
x3
;
curY
=
y3
;
idx
+
=
6
;
}
if
(
op1
=
=
cf2_cmdRCURVELINE
)
{
curX
=
ADD_INT32
(
curX
cf2_stack_getReal
(
opStack
idx
+
0
)
)
;
curY
=
ADD_INT32
(
curY
cf2_stack_getReal
(
opStack
idx
+
1
)
)
;
cf2_glyphpath_lineTo
(
&
glyphPath
curX
curY
)
;
}
cf2_stack_clear
(
opStack
)
;
}
continue
;
case
cf2_cmdCLOSEPATH
:
if
(
!
font
-
>
isT1
)
FT_TRACE4
(
(
"
unknown
op
(
%
d
)
\
n
"
op1
)
)
;
else
{
FT_TRACE4
(
(
"
closepath
"
)
)
;
ps_builder_close_contour
(
&
decoder
-
>
builder
)
;
haveWidth
=
TRUE
;
}
break
;
case
cf2_cmdCALLGSUBR
:
case
cf2_cmdCALLSUBR
:
{
CF2_Int
subrNum
;
FT_TRACE4
(
(
op1
=
=
cf2_cmdCALLGSUBR
?
"
callgsubr
"
:
"
callsubr
"
)
)
;
if
(
(
!
font
-
>
isT1
&
&
charstringIndex
>
CF2_MAX_SUBR
)
|
|
(
font
-
>
isT1
&
&
charstringIndex
>
T1_MAX_SUBRS_CALLS
)
)
{
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
charstring
=
(
CF2_Buffer
)
cf2_arrstack_getPointer
(
&
subrStack
(
size_t
)
charstringIndex
+
1
)
;
subrNum
=
cf2_stack_popInt
(
opStack
)
;
if
(
font
-
>
isT1
&
&
decoder
-
>
locals_hash
)
{
size_t
*
val
=
ft_hash_num_lookup
(
subrNum
decoder
-
>
locals_hash
)
;
if
(
val
)
subrNum
=
*
val
;
else
subrNum
=
-
1
;
}
switch
(
op1
)
{
case
cf2_cmdCALLGSUBR
:
FT_TRACE4
(
(
"
(
idx
%
d
entering
level
%
d
)
\
n
"
subrNum
+
decoder
-
>
globals_bias
charstringIndex
+
1
)
)
;
if
(
cf2_initGlobalRegionBuffer
(
decoder
subrNum
charstring
)
)
{
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
break
;
default
:
FT_TRACE4
(
(
"
(
idx
%
d
entering
level
%
d
)
\
n
"
subrNum
+
decoder
-
>
locals_bias
charstringIndex
+
1
)
)
;
if
(
cf2_initLocalRegionBuffer
(
decoder
subrNum
charstring
)
)
{
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
}
charstringIndex
+
=
1
;
}
continue
;
case
cf2_cmdRETURN
:
FT_TRACE4
(
(
"
return
(
leaving
level
%
d
)
\
n
"
charstringIndex
)
)
;
if
(
charstringIndex
<
1
)
{
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
charstring
=
(
CF2_Buffer
)
cf2_arrstack_getPointer
(
&
subrStack
(
CF2_UInt
)
-
-
charstringIndex
)
;
continue
;
case
cf2_cmdESC
:
{
FT_Byte
op2
=
(
FT_Byte
)
cf2_buf_readByte
(
charstring
)
;
switch
(
op2
)
{
case
cf2_escHFLEX
:
{
static
const
FT_Bool
readFromStack
[
12
]
=
{
TRUE
FALSE
TRUE
TRUE
TRUE
FALSE
TRUE
FALSE
TRUE
FALSE
TRUE
FALSE
}
;
FT_TRACE4
(
(
"
hflex
\
n
"
)
)
;
cf2_doFlex
(
opStack
&
curX
&
curY
&
glyphPath
readFromStack
FALSE
)
;
}
continue
;
case
cf2_escFLEX
:
{
static
const
FT_Bool
readFromStack
[
12
]
=
{
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
}
;
FT_TRACE4
(
(
"
flex
\
n
"
)
)
;
cf2_doFlex
(
opStack
&
curX
&
curY
&
glyphPath
readFromStack
FALSE
)
;
}
break
;
case
cf2_escHFLEX1
:
{
static
const
FT_Bool
readFromStack
[
12
]
=
{
TRUE
TRUE
TRUE
TRUE
TRUE
FALSE
TRUE
FALSE
TRUE
TRUE
TRUE
FALSE
}
;
FT_TRACE4
(
(
"
hflex1
\
n
"
)
)
;
cf2_doFlex
(
opStack
&
curX
&
curY
&
glyphPath
readFromStack
FALSE
)
;
}
continue
;
case
cf2_escFLEX1
:
{
static
const
FT_Bool
readFromStack
[
12
]
=
{
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
TRUE
FALSE
FALSE
}
;
FT_TRACE4
(
(
"
flex1
\
n
"
)
)
;
cf2_doFlex
(
opStack
&
curX
&
curY
&
glyphPath
readFromStack
TRUE
)
;
}
continue
;
case
cf2_escRESERVED_8
:
case
cf2_escRESERVED_13
:
case
cf2_escRESERVED_19
:
case
cf2_escRESERVED_25
:
case
cf2_escRESERVED_31
:
case
cf2_escRESERVED_32
:
FT_TRACE4
(
(
"
unknown
op
(
12
%
d
)
\
n
"
op2
)
)
;
break
;
default
:
{
if
(
font
-
>
isCFF2
|
|
op2
>
=
cf2_escRESERVED_38
)
FT_TRACE4
(
(
"
unknown
op
(
12
%
d
)
\
n
"
op2
)
)
;
else
if
(
font
-
>
isT1
&
&
result_cnt
>
0
&
&
op2
!
=
cf2_escPOP
)
{
result_cnt
=
0
;
}
else
{
switch
(
op2
)
{
case
cf2_escDOTSECTION
:
FT_TRACE4
(
(
"
dotsection
\
n
"
)
)
;
break
;
case
cf2_escVSTEM3
:
case
cf2_escHSTEM3
:
{
if
(
!
font
-
>
isT1
)
FT_TRACE4
(
(
"
unknown
op
(
12
%
d
)
\
n
"
op2
)
)
;
else
{
CF2_F16Dot16
v0
v1
v2
;
FT_Bool
isV
=
FT_BOOL
(
op2
=
=
cf2_escVSTEM3
)
;
FT_TRACE4
(
(
isV
?
"
vstem3
\
n
"
:
"
hstem3
\
n
"
)
)
;
FT_ASSERT
(
cf2_stack_count
(
opStack
)
=
=
6
)
;
v0
=
cf2_stack_getReal
(
opStack
0
)
;
v1
=
cf2_stack_getReal
(
opStack
2
)
;
v2
=
cf2_stack_getReal
(
opStack
4
)
;
cf2_stack_setReal
(
opStack
2
SUB_INT32
(
SUB_INT32
(
v1
v0
)
cf2_stack_getReal
(
opStack
1
)
)
)
;
cf2_stack_setReal
(
opStack
4
SUB_INT32
(
SUB_INT32
(
v2
v1
)
cf2_stack_getReal
(
opStack
3
)
)
)
;
cf2_doStems
(
font
opStack
isV
?
&
vStemHintArray
:
&
hStemHintArray
width
&
haveWidth
isV
?
decoder
-
>
builder
.
left_bearing
-
>
x
:
decoder
-
>
builder
.
left_bearing
-
>
y
)
;
if
(
decoder
-
>
width_only
)
goto
exit
;
}
}
break
;
case
cf2_escAND
:
{
CF2_F16Dot16
arg1
;
CF2_F16Dot16
arg2
;
FT_TRACE4
(
(
"
and
\
n
"
)
)
;
arg2
=
cf2_stack_popFixed
(
opStack
)
;
arg1
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushInt
(
opStack
arg1
&
&
arg2
)
;
}
continue
;
case
cf2_escOR
:
{
CF2_F16Dot16
arg1
;
CF2_F16Dot16
arg2
;
FT_TRACE4
(
(
"
or
\
n
"
)
)
;
arg2
=
cf2_stack_popFixed
(
opStack
)
;
arg1
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushInt
(
opStack
arg1
|
|
arg2
)
;
}
continue
;
case
cf2_escNOT
:
{
CF2_F16Dot16
arg
;
FT_TRACE4
(
(
"
not
\
n
"
)
)
;
arg
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushInt
(
opStack
!
arg
)
;
}
continue
;
case
cf2_escSEAC
:
if
(
!
font
-
>
isT1
)
FT_TRACE4
(
(
"
unknown
op
(
12
%
d
)
\
n
"
op2
)
)
;
else
{
FT_Error
error2
;
CF2_Int
bchar_index
achar_index
;
FT_Vector
left_bearing
advance
;
#
ifdef
FT_CONFIG_OPTION_INCREMENTAL
T1_Face
face
=
(
T1_Face
)
decoder
-
>
builder
.
face
;
#
endif
CF2_BufferRec
component
;
CF2_Fixed
dummyWidth
;
CF2_Int
achar
=
cf2_stack_popInt
(
opStack
)
;
CF2_Int
bchar
=
cf2_stack_popInt
(
opStack
)
;
FT_Pos
ady
=
cf2_stack_popFixed
(
opStack
)
;
FT_Pos
adx
=
cf2_stack_popFixed
(
opStack
)
;
FT_Pos
asb
=
cf2_stack_popFixed
(
opStack
)
;
FT_TRACE4
(
(
"
seac
\
n
"
)
)
;
if
(
doingSeac
)
{
FT_ERROR
(
(
"
nested
seac
\
n
"
)
)
;
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
if
(
decoder
-
>
builder
.
metrics_only
)
{
FT_ERROR
(
(
"
unexpected
seac
\
n
"
)
)
;
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
#
ifdef
FT_CONFIG_OPTION_INCREMENTAL
if
(
decoder
-
>
glyph_names
=
=
0
&
&
!
face
-
>
root
.
internal
-
>
incremental_interface
)
#
else
if
(
decoder
-
>
glyph_names
=
=
0
)
#
endif
{
FT_ERROR
(
(
"
cf2_interpT2CharString
:
(
Type
1
seac
)
"
"
glyph
names
table
not
available
in
this
font
\
n
"
)
)
;
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
adx
+
=
decoder
-
>
builder
.
left_bearing
-
>
x
;
#
ifdef
FT_CONFIG_OPTION_INCREMENTAL
if
(
face
-
>
root
.
internal
-
>
incremental_interface
)
{
bchar_index
=
bchar
;
achar_index
=
achar
;
}
else
#
endif
{
bchar_index
=
t1_lookup_glyph_by_stdcharcode_ps
(
decoder
bchar
)
;
achar_index
=
t1_lookup_glyph_by_stdcharcode_ps
(
decoder
achar
)
;
}
if
(
bchar_index
<
0
|
|
achar_index
<
0
)
{
FT_ERROR
(
(
"
cf2_interpT2CharString
:
(
Type
1
seac
)
"
"
invalid
seac
character
code
arguments
\
n
"
)
)
;
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
if
(
decoder
-
>
builder
.
no_recurse
)
{
FT_GlyphSlot
glyph
=
(
FT_GlyphSlot
)
decoder
-
>
builder
.
glyph
;
FT_GlyphLoader
loader
=
glyph
-
>
internal
-
>
loader
;
FT_SubGlyph
subg
;
error2
=
FT_GlyphLoader_CheckSubGlyphs
(
loader
2
)
;
if
(
error2
)
{
lastError
=
error2
;
goto
exit
;
}
subg
=
loader
-
>
current
.
subglyphs
;
subg
-
>
index
=
bchar_index
;
subg
-
>
flags
=
FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES
|
FT_SUBGLYPH_FLAG_USE_MY_METRICS
;
subg
-
>
arg1
=
0
;
subg
-
>
arg2
=
0
;
subg
+
+
;
subg
-
>
index
=
achar_index
;
subg
-
>
flags
=
FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES
;
subg
-
>
arg1
=
(
FT_Int
)
FIXED_TO_INT
(
adx
-
asb
)
;
subg
-
>
arg2
=
(
FT_Int
)
FIXED_TO_INT
(
ady
)
;
glyph
-
>
num_subglyphs
=
2
;
glyph
-
>
subglyphs
=
loader
-
>
base
.
subglyphs
;
glyph
-
>
format
=
FT_GLYPH_FORMAT_COMPOSITE
;
loader
-
>
current
.
num_subglyphs
=
2
;
goto
exit
;
}
FT_GlyphLoader_Prepare
(
decoder
-
>
builder
.
loader
)
;
error2
=
cf2_getT1SeacComponent
(
decoder
(
FT_UInt
)
bchar_index
&
component
)
;
if
(
error2
)
{
lastError
=
error2
;
goto
exit
;
}
cf2_interpT2CharString
(
font
&
component
callbacks
translation
TRUE
0
0
&
dummyWidth
)
;
cf2_freeT1SeacComponent
(
decoder
&
component
)
;
left_bearing
=
*
decoder
-
>
builder
.
left_bearing
;
advance
=
*
decoder
-
>
builder
.
advance
;
decoder
-
>
builder
.
left_bearing
-
>
x
=
0
;
decoder
-
>
builder
.
left_bearing
-
>
y
=
0
;
error2
=
cf2_getT1SeacComponent
(
decoder
(
FT_UInt
)
achar_index
&
component
)
;
if
(
error2
)
{
lastError
=
error2
;
goto
exit
;
}
cf2_interpT2CharString
(
font
&
component
callbacks
translation
TRUE
adx
-
asb
ady
&
dummyWidth
)
;
cf2_freeT1SeacComponent
(
decoder
&
component
)
;
*
decoder
-
>
builder
.
left_bearing
=
left_bearing
;
*
decoder
-
>
builder
.
advance
=
advance
;
goto
exit
;
}
break
;
case
cf2_escSBW
:
if
(
!
font
-
>
isT1
)
FT_TRACE4
(
(
"
unknown
op
(
12
%
d
)
\
n
"
op2
)
)
;
else
{
CF2_Fixed
lsb_x
lsb_y
;
PS_Builder
*
builder
;
FT_TRACE4
(
(
"
sbw
"
)
)
;
builder
=
&
decoder
-
>
builder
;
builder
-
>
advance
-
>
y
=
cf2_stack_popFixed
(
opStack
)
;
builder
-
>
advance
-
>
x
=
cf2_stack_popFixed
(
opStack
)
;
lsb_y
=
cf2_stack_popFixed
(
opStack
)
;
lsb_x
=
cf2_stack_popFixed
(
opStack
)
;
builder
-
>
left_bearing
-
>
x
=
ADD_INT32
(
builder
-
>
left_bearing
-
>
x
lsb_x
)
;
builder
-
>
left_bearing
-
>
y
=
ADD_INT32
(
builder
-
>
left_bearing
-
>
y
lsb_y
)
;
haveWidth
=
TRUE
;
if
(
builder
-
>
metrics_only
)
goto
exit
;
if
(
initial_map_ready
)
{
curX
=
ADD_INT32
(
curX
lsb_x
)
;
curY
=
ADD_INT32
(
curY
lsb_y
)
;
}
}
break
;
case
cf2_escABS
:
{
CF2_F16Dot16
arg
;
FT_TRACE4
(
(
"
abs
\
n
"
)
)
;
arg
=
cf2_stack_popFixed
(
opStack
)
;
if
(
arg
<
-
CF2_FIXED_MAX
)
cf2_stack_pushFixed
(
opStack
CF2_FIXED_MAX
)
;
else
cf2_stack_pushFixed
(
opStack
FT_ABS
(
arg
)
)
;
}
continue
;
case
cf2_escADD
:
{
CF2_F16Dot16
summand1
;
CF2_F16Dot16
summand2
;
FT_TRACE4
(
(
"
add
\
n
"
)
)
;
summand2
=
cf2_stack_popFixed
(
opStack
)
;
summand1
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushFixed
(
opStack
ADD_INT32
(
summand1
summand2
)
)
;
}
continue
;
case
cf2_escSUB
:
{
CF2_F16Dot16
minuend
;
CF2_F16Dot16
subtrahend
;
FT_TRACE4
(
(
"
sub
\
n
"
)
)
;
subtrahend
=
cf2_stack_popFixed
(
opStack
)
;
minuend
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushFixed
(
opStack
SUB_INT32
(
minuend
subtrahend
)
)
;
}
continue
;
case
cf2_escDIV
:
{
CF2_F16Dot16
dividend
;
CF2_F16Dot16
divisor
;
FT_TRACE4
(
(
"
div
\
n
"
)
)
;
if
(
font
-
>
isT1
&
&
large_int
)
{
divisor
=
(
CF2_F16Dot16
)
cf2_stack_popInt
(
opStack
)
;
dividend
=
(
CF2_F16Dot16
)
cf2_stack_popInt
(
opStack
)
;
large_int
=
FALSE
;
}
else
{
divisor
=
cf2_stack_popFixed
(
opStack
)
;
dividend
=
cf2_stack_popFixed
(
opStack
)
;
}
cf2_stack_pushFixed
(
opStack
FT_DivFix
(
dividend
divisor
)
)
;
}
continue
;
case
cf2_escNEG
:
{
CF2_F16Dot16
arg
;
FT_TRACE4
(
(
"
neg
\
n
"
)
)
;
arg
=
cf2_stack_popFixed
(
opStack
)
;
if
(
arg
<
-
CF2_FIXED_MAX
)
cf2_stack_pushFixed
(
opStack
CF2_FIXED_MAX
)
;
else
cf2_stack_pushFixed
(
opStack
-
arg
)
;
}
continue
;
case
cf2_escEQ
:
{
CF2_F16Dot16
arg1
;
CF2_F16Dot16
arg2
;
FT_TRACE4
(
(
"
eq
\
n
"
)
)
;
arg2
=
cf2_stack_popFixed
(
opStack
)
;
arg1
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushInt
(
opStack
arg1
=
=
arg2
)
;
}
continue
;
case
cf2_escCALLOTHERSUBR
:
if
(
!
font
-
>
isT1
)
FT_TRACE4
(
(
"
unknown
op
(
12
%
d
)
\
n
"
op2
)
)
;
else
{
CF2_Int
subr_no
;
CF2_Int
arg_cnt
;
CF2_UInt
count
;
CF2_UInt
opIdx
=
0
;
FT_TRACE4
(
(
"
callothersubr
\
n
"
)
)
;
subr_no
=
cf2_stack_popInt
(
opStack
)
;
arg_cnt
=
cf2_stack_popInt
(
opStack
)
;
count
=
cf2_stack_count
(
opStack
)
;
FT_ASSERT
(
(
CF2_UInt
)
arg_cnt
<
=
count
)
;
opIdx
+
=
count
-
(
CF2_UInt
)
arg_cnt
;
known_othersubr_result_cnt
=
0
;
result_cnt
=
0
;
switch
(
subr_no
)
{
case
0
:
if
(
arg_cnt
!
=
3
)
goto
Unexpected_OtherSubr
;
if
(
initial_map_ready
&
&
(
!
decoder
-
>
flex_state
|
|
decoder
-
>
num_flex_vectors
!
=
7
)
)
{
FT_ERROR
(
(
"
cf2_interpT2CharString
(
Type
1
mode
)
:
"
"
unexpected
flex
end
\
n
"
)
)
;
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
cf2_stack_pushFixed
(
opStack
curX
)
;
cf2_stack_pushFixed
(
opStack
curY
)
;
known_othersubr_result_cnt
=
2
;
break
;
case
1
:
if
(
arg_cnt
!
=
0
)
goto
Unexpected_OtherSubr
;
if
(
!
initial_map_ready
)
break
;
if
(
ps_builder_check_points
(
&
decoder
-
>
builder
6
)
)
goto
exit
;
decoder
-
>
flex_state
=
1
;
decoder
-
>
num_flex_vectors
=
0
;
break
;
case
2
:
{
FT_Int
idx
;
FT_Int
idx2
;
if
(
arg_cnt
!
=
0
)
goto
Unexpected_OtherSubr
;
if
(
!
initial_map_ready
)
break
;
if
(
!
decoder
-
>
flex_state
)
{
FT_ERROR
(
(
"
cf2_interpT2CharString
(
Type
1
mode
)
:
"
"
missing
flex
start
\
n
"
)
)
;
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
idx
=
decoder
-
>
num_flex_vectors
+
+
;
if
(
idx
>
0
&
&
idx
<
7
)
{
if
(
ps_builder_check_points
(
&
decoder
-
>
builder
1
)
)
{
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
idx2
=
(
idx
>
3
?
idx
-
3
:
idx
)
*
2
;
flexStore
[
idx2
-
2
]
=
curX
;
flexStore
[
idx2
-
1
]
=
curY
;
if
(
idx
=
=
3
|
|
idx
=
=
6
)
cf2_glyphpath_curveTo
(
&
glyphPath
flexStore
[
0
]
flexStore
[
1
]
flexStore
[
2
]
flexStore
[
3
]
flexStore
[
4
]
flexStore
[
5
]
)
;
}
}
break
;
case
3
:
if
(
arg_cnt
!
=
1
)
goto
Unexpected_OtherSubr
;
if
(
initial_map_ready
)
{
cf2_arrstack_clear
(
&
vStemHintArray
)
;
cf2_arrstack_clear
(
&
hStemHintArray
)
;
cf2_hintmask_init
(
&
hintMask
error
)
;
hintMask
.
isValid
=
FALSE
;
hintMask
.
isNew
=
TRUE
;
}
known_othersubr_result_cnt
=
1
;
break
;
case
12
:
case
13
:
cf2_stack_clear
(
opStack
)
;
break
;
case
14
:
case
15
:
case
16
:
case
17
:
case
18
:
{
PS_Blend
blend
=
decoder
-
>
blend
;
FT_UInt
num_points
nn
mm
;
CF2_UInt
delta
;
CF2_UInt
values
;
if
(
!
blend
)
{
FT_ERROR
(
(
"
cf2_interpT2CharString
:
"
"
unexpected
multiple
masters
operator
\
n
"
)
)
;
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
num_points
=
(
FT_UInt
)
subr_no
-
13
+
(
subr_no
=
=
18
)
;
if
(
arg_cnt
!
=
(
FT_Int
)
(
num_points
*
blend
-
>
num_designs
)
)
{
FT_ERROR
(
(
"
cf2_interpT2CharString
:
"
"
incorrect
number
of
multiple
masters
arguments
\
n
"
)
)
;
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
delta
=
opIdx
+
num_points
;
values
=
opIdx
;
for
(
nn
=
0
;
nn
<
num_points
;
nn
+
+
)
{
CF2_Fixed
tmp
=
cf2_stack_getReal
(
opStack
values
)
;
for
(
mm
=
1
;
mm
<
blend
-
>
num_designs
;
mm
+
+
)
tmp
=
ADD_INT32
(
tmp
FT_MulFix
(
cf2_stack_getReal
(
opStack
delta
+
+
)
blend
-
>
weight_vector
[
mm
]
)
)
;
cf2_stack_setReal
(
opStack
values
+
+
tmp
)
;
}
cf2_stack_pop
(
opStack
(
CF2_UInt
)
arg_cnt
-
num_points
)
;
known_othersubr_result_cnt
=
(
FT_Int
)
num_points
;
break
;
}
case
19
:
{
FT_Int
idx
;
PS_Blend
blend
=
decoder
-
>
blend
;
if
(
arg_cnt
!
=
1
|
|
!
blend
)
goto
Unexpected_OtherSubr
;
idx
=
cf2_stack_popInt
(
opStack
)
;
if
(
idx
<
0
|
|
(
FT_UInt
)
idx
+
blend
-
>
num_designs
>
decoder
-
>
len_buildchar
)
goto
Unexpected_OtherSubr
;
ft_memcpy
(
&
decoder
-
>
buildchar
[
idx
]
blend
-
>
weight_vector
blend
-
>
num_designs
*
sizeof
(
blend
-
>
weight_vector
[
0
]
)
)
;
}
break
;
case
20
:
{
CF2_F16Dot16
summand1
;
CF2_F16Dot16
summand2
;
if
(
arg_cnt
!
=
2
)
goto
Unexpected_OtherSubr
;
summand2
=
cf2_stack_popFixed
(
opStack
)
;
summand1
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushFixed
(
opStack
ADD_INT32
(
summand1
summand2
)
)
;
known_othersubr_result_cnt
=
1
;
}
break
;
case
21
:
{
CF2_F16Dot16
minuend
;
CF2_F16Dot16
subtrahend
;
if
(
arg_cnt
!
=
2
)
goto
Unexpected_OtherSubr
;
subtrahend
=
cf2_stack_popFixed
(
opStack
)
;
minuend
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushFixed
(
opStack
SUB_INT32
(
minuend
subtrahend
)
)
;
known_othersubr_result_cnt
=
1
;
}
break
;
case
22
:
{
CF2_F16Dot16
factor1
;
CF2_F16Dot16
factor2
;
if
(
arg_cnt
!
=
2
)
goto
Unexpected_OtherSubr
;
factor2
=
cf2_stack_popFixed
(
opStack
)
;
factor1
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushFixed
(
opStack
FT_MulFix
(
factor1
factor2
)
)
;
known_othersubr_result_cnt
=
1
;
}
break
;
case
23
:
{
CF2_F16Dot16
dividend
;
CF2_F16Dot16
divisor
;
if
(
arg_cnt
!
=
2
)
goto
Unexpected_OtherSubr
;
divisor
=
cf2_stack_popFixed
(
opStack
)
;
dividend
=
cf2_stack_popFixed
(
opStack
)
;
if
(
divisor
=
=
0
)
goto
Unexpected_OtherSubr
;
cf2_stack_pushFixed
(
opStack
FT_DivFix
(
dividend
divisor
)
)
;
known_othersubr_result_cnt
=
1
;
}
break
;
case
24
:
{
CF2_Int
idx
;
PS_Blend
blend
=
decoder
-
>
blend
;
if
(
arg_cnt
!
=
2
|
|
!
blend
)
goto
Unexpected_OtherSubr
;
idx
=
cf2_stack_popInt
(
opStack
)
;
if
(
idx
<
0
|
|
(
FT_UInt
)
idx
>
=
decoder
-
>
len_buildchar
)
goto
Unexpected_OtherSubr
;
decoder
-
>
buildchar
[
idx
]
=
cf2_stack_popFixed
(
opStack
)
;
}
break
;
case
25
:
{
CF2_Int
idx
;
PS_Blend
blend
=
decoder
-
>
blend
;
if
(
arg_cnt
!
=
1
|
|
!
blend
)
goto
Unexpected_OtherSubr
;
idx
=
cf2_stack_popInt
(
opStack
)
;
if
(
idx
<
0
|
|
(
FT_UInt
)
idx
>
=
decoder
-
>
len_buildchar
)
goto
Unexpected_OtherSubr
;
cf2_stack_pushFixed
(
opStack
decoder
-
>
buildchar
[
idx
]
)
;
known_othersubr_result_cnt
=
1
;
}
break
;
#
if
0
case
26
:
XXX
which
routine
has
left
its
mark
on
the
XXX
(
PostScript
)
stack
?
;
break
;
#
endif
case
27
:
{
CF2_F16Dot16
arg1
;
CF2_F16Dot16
arg2
;
CF2_F16Dot16
cond1
;
CF2_F16Dot16
cond2
;
if
(
arg_cnt
!
=
4
)
goto
Unexpected_OtherSubr
;
cond2
=
cf2_stack_popFixed
(
opStack
)
;
cond1
=
cf2_stack_popFixed
(
opStack
)
;
arg2
=
cf2_stack_popFixed
(
opStack
)
;
arg1
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushFixed
(
opStack
cond1
<
=
cond2
?
arg1
:
arg2
)
;
known_othersubr_result_cnt
=
1
;
}
break
;
case
28
:
{
CF2_F16Dot16
r
;
if
(
arg_cnt
!
=
0
)
goto
Unexpected_OtherSubr
;
r
=
(
CF2_F16Dot16
)
(
(
decoder
-
>
current_subfont
-
>
random
&
0xFFFF
)
+
1
)
;
decoder
-
>
current_subfont
-
>
random
=
cff_random
(
decoder
-
>
current_subfont
-
>
random
)
;
cf2_stack_pushFixed
(
opStack
r
)
;
known_othersubr_result_cnt
=
1
;
}
break
;
default
:
if
(
arg_cnt
>
=
0
&
&
subr_no
>
=
0
)
{
FT_Int
i
;
FT_ERROR
(
(
"
cf2_interpT2CharString
(
Type
1
mode
)
:
"
"
unknown
othersubr
[
%
d
%
d
]
wish
me
luck
\
n
"
arg_cnt
subr_no
)
)
;
if
(
arg_cnt
>
PS_STORAGE_SIZE
)
arg_cnt
=
PS_STORAGE_SIZE
;
result_cnt
=
arg_cnt
;
for
(
i
=
1
;
i
<
=
arg_cnt
;
i
+
+
)
results
[
result_cnt
-
i
]
=
cf2_stack_popFixed
(
opStack
)
;
break
;
}
Unexpected_OtherSubr
:
FT_ERROR
(
(
"
cf2_interpT2CharString
(
Type
1
mode
)
:
"
"
invalid
othersubr
[
%
d
%
d
]
\
n
"
arg_cnt
subr_no
)
)
;
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
}
continue
;
case
cf2_escPOP
:
if
(
!
font
-
>
isT1
)
FT_TRACE4
(
(
"
unknown
op
(
12
%
d
)
\
n
"
op2
)
)
;
else
{
FT_TRACE4
(
(
"
pop
"
)
)
;
if
(
known_othersubr_result_cnt
>
0
)
{
known_othersubr_result_cnt
-
-
;
continue
;
}
if
(
result_cnt
=
=
0
)
{
FT_ERROR
(
(
"
cf2_interpT2CharString
(
Type
1
mode
)
:
"
"
no
more
operands
for
othersubr
\
n
"
)
)
;
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
result_cnt
-
-
;
cf2_stack_pushFixed
(
opStack
results
[
result_cnt
]
)
;
}
continue
;
case
cf2_escDROP
:
FT_TRACE4
(
(
"
drop
\
n
"
)
)
;
(
void
)
cf2_stack_popFixed
(
opStack
)
;
continue
;
case
cf2_escPUT
:
{
CF2_F16Dot16
val
;
CF2_Int
idx
;
FT_TRACE4
(
(
"
put
\
n
"
)
)
;
idx
=
cf2_stack_popInt
(
opStack
)
;
val
=
cf2_stack_popFixed
(
opStack
)
;
if
(
idx
>
=
0
&
&
idx
<
CF2_STORAGE_SIZE
)
storage
[
idx
]
=
val
;
}
continue
;
case
cf2_escGET
:
{
CF2_Int
idx
;
FT_TRACE4
(
(
"
get
\
n
"
)
)
;
idx
=
cf2_stack_popInt
(
opStack
)
;
if
(
idx
>
=
0
&
&
idx
<
CF2_STORAGE_SIZE
)
cf2_stack_pushFixed
(
opStack
storage
[
idx
]
)
;
}
continue
;
case
cf2_escIFELSE
:
{
CF2_F16Dot16
arg1
;
CF2_F16Dot16
arg2
;
CF2_F16Dot16
cond1
;
CF2_F16Dot16
cond2
;
FT_TRACE4
(
(
"
ifelse
\
n
"
)
)
;
cond2
=
cf2_stack_popFixed
(
opStack
)
;
cond1
=
cf2_stack_popFixed
(
opStack
)
;
arg2
=
cf2_stack_popFixed
(
opStack
)
;
arg1
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushFixed
(
opStack
cond1
<
=
cond2
?
arg1
:
arg2
)
;
}
continue
;
case
cf2_escRANDOM
:
{
CF2_F16Dot16
r
;
FT_TRACE4
(
(
"
random
\
n
"
)
)
;
r
=
(
CF2_F16Dot16
)
(
(
decoder
-
>
current_subfont
-
>
random
&
0xFFFF
)
+
1
)
;
decoder
-
>
current_subfont
-
>
random
=
cff_random
(
decoder
-
>
current_subfont
-
>
random
)
;
cf2_stack_pushFixed
(
opStack
r
)
;
}
continue
;
case
cf2_escMUL
:
{
CF2_F16Dot16
factor1
;
CF2_F16Dot16
factor2
;
FT_TRACE4
(
(
"
mul
\
n
"
)
)
;
factor2
=
cf2_stack_popFixed
(
opStack
)
;
factor1
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushFixed
(
opStack
FT_MulFix
(
factor1
factor2
)
)
;
}
continue
;
case
cf2_escSQRT
:
{
CF2_F16Dot16
arg
;
FT_TRACE4
(
(
"
sqrt
\
n
"
)
)
;
arg
=
cf2_stack_popFixed
(
opStack
)
;
if
(
arg
>
0
)
{
FT_Fixed
root
=
arg
<
10
?
arg
:
arg
>
>
1
;
FT_Fixed
new_root
;
for
(
;
;
)
{
new_root
=
(
root
+
FT_DivFix
(
arg
root
)
+
1
)
>
>
1
;
if
(
new_root
=
=
root
)
break
;
root
=
new_root
;
}
arg
=
new_root
;
}
else
arg
=
0
;
cf2_stack_pushFixed
(
opStack
arg
)
;
}
continue
;
case
cf2_escDUP
:
{
CF2_F16Dot16
arg
;
FT_TRACE4
(
(
"
dup
\
n
"
)
)
;
arg
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushFixed
(
opStack
arg
)
;
cf2_stack_pushFixed
(
opStack
arg
)
;
}
continue
;
case
cf2_escEXCH
:
{
CF2_F16Dot16
arg1
;
CF2_F16Dot16
arg2
;
FT_TRACE4
(
(
"
exch
\
n
"
)
)
;
arg2
=
cf2_stack_popFixed
(
opStack
)
;
arg1
=
cf2_stack_popFixed
(
opStack
)
;
cf2_stack_pushFixed
(
opStack
arg2
)
;
cf2_stack_pushFixed
(
opStack
arg1
)
;
}
continue
;
case
cf2_escINDEX
:
{
CF2_Int
idx
;
CF2_UInt
size
;
FT_TRACE4
(
(
"
index
\
n
"
)
)
;
idx
=
cf2_stack_popInt
(
opStack
)
;
size
=
cf2_stack_count
(
opStack
)
;
if
(
size
>
0
)
{
CF2_UInt
gr_idx
;
if
(
idx
<
0
)
gr_idx
=
size
-
1
;
else
if
(
(
CF2_UInt
)
idx
>
=
size
)
gr_idx
=
0
;
else
gr_idx
=
size
-
1
-
(
CF2_UInt
)
idx
;
cf2_stack_pushFixed
(
opStack
cf2_stack_getReal
(
opStack
gr_idx
)
)
;
}
}
continue
;
case
cf2_escROLL
:
{
CF2_Int
idx
;
CF2_Int
count
;
FT_TRACE4
(
(
"
roll
\
n
"
)
)
;
idx
=
cf2_stack_popInt
(
opStack
)
;
count
=
cf2_stack_popInt
(
opStack
)
;
cf2_stack_roll
(
opStack
count
idx
)
;
}
continue
;
case
cf2_escSETCURRENTPT
:
if
(
!
font
-
>
isT1
)
FT_TRACE4
(
(
"
unknown
op
(
12
%
d
)
\
n
"
op2
)
)
;
else
{
FT_TRACE4
(
(
"
setcurrentpoint
"
)
)
;
if
(
!
initial_map_ready
)
break
;
#
if
0
if
(
decoder
-
>
flex_state
!
=
1
)
{
FT_ERROR
(
(
"
cf2_interpT2CharString
:
"
"
unexpected
setcurrentpoint
'
\
n
"
)
)
;
goto
Syntax_Error
;
}
else
.
.
.
#
endif
curY
=
cf2_stack_popFixed
(
opStack
)
;
curX
=
cf2_stack_popFixed
(
opStack
)
;
decoder
-
>
flex_state
=
0
;
}
break
;
}
}
}
}
}
break
;
case
cf2_cmdHSBW
:
if
(
!
font
-
>
isT1
)
FT_TRACE4
(
(
"
unknown
op
(
%
d
)
\
n
"
op1
)
)
;
else
{
CF2_Fixed
lsb_x
;
PS_Builder
*
builder
;
FT_TRACE4
(
(
"
hsbw
"
)
)
;
builder
=
&
decoder
-
>
builder
;
builder
-
>
advance
-
>
x
=
cf2_stack_popFixed
(
opStack
)
;
builder
-
>
advance
-
>
y
=
0
;
lsb_x
=
cf2_stack_popFixed
(
opStack
)
;
builder
-
>
left_bearing
-
>
x
=
ADD_INT32
(
builder
-
>
left_bearing
-
>
x
lsb_x
)
;
haveWidth
=
TRUE
;
if
(
builder
-
>
metrics_only
)
goto
exit
;
if
(
initial_map_ready
)
curX
=
ADD_INT32
(
curX
lsb_x
)
;
}
break
;
case
cf2_cmdENDCHAR
:
FT_TRACE4
(
(
"
endchar
\
n
"
)
)
;
if
(
font
-
>
isT1
&
&
!
initial_map_ready
)
{
FT_TRACE5
(
(
"
cf2_interpT2CharString
(
Type
1
mode
)
:
"
"
Build
initial
hintmap
rewinding
.
.
.
\
n
"
)
)
;
cf2_glyphpath_moveTo
(
&
glyphPath
curX
curY
)
;
initial_map_ready
=
TRUE
;
cf2_arrstack_clear
(
&
vStemHintArray
)
;
cf2_arrstack_clear
(
&
hStemHintArray
)
;
cf2_hintmask_init
(
&
hintMask
error
)
;
hintMask
.
isValid
=
FALSE
;
hintMask
.
isNew
=
TRUE
;
while
(
charstringIndex
>
0
)
{
FT_TRACE4
(
(
"
return
(
leaving
level
%
d
)
\
n
"
charstringIndex
)
)
;
charstring
=
(
CF2_Buffer
)
cf2_arrstack_getPointer
(
&
subrStack
(
CF2_UInt
)
-
-
charstringIndex
)
;
}
charstring
-
>
ptr
=
charstring
-
>
start
;
break
;
}
if
(
cf2_stack_count
(
opStack
)
=
=
1
|
|
cf2_stack_count
(
opStack
)
=
=
5
)
{
if
(
!
haveWidth
)
*
width
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
0
)
nominalWidthX
)
;
}
haveWidth
=
TRUE
;
if
(
decoder
-
>
width_only
)
goto
exit
;
cf2_glyphpath_closeOpenPath
(
&
glyphPath
)
;
if
(
!
font
-
>
isCFF2
&
&
!
font
-
>
isT1
&
&
cf2_stack_count
(
opStack
)
>
1
)
{
CF2_Int
achar
;
CF2_Int
bchar
;
CF2_BufferRec
component
;
CF2_Fixed
dummyWidth
;
FT_Error
error2
;
if
(
doingSeac
)
{
lastError
=
FT_THROW
(
Invalid_Glyph_Format
)
;
goto
exit
;
}
achar
=
cf2_stack_popInt
(
opStack
)
;
bchar
=
cf2_stack_popInt
(
opStack
)
;
curY
=
cf2_stack_popFixed
(
opStack
)
;
curX
=
cf2_stack_popFixed
(
opStack
)
;
error2
=
cf2_getSeacComponent
(
decoder
achar
&
component
)
;
if
(
error2
)
{
lastError
=
error2
;
goto
exit
;
}
cf2_interpT2CharString
(
font
&
component
callbacks
translation
TRUE
curX
curY
&
dummyWidth
)
;
cf2_freeSeacComponent
(
decoder
&
component
)
;
error2
=
cf2_getSeacComponent
(
decoder
bchar
&
component
)
;
if
(
error2
)
{
lastError
=
error2
;
goto
exit
;
}
cf2_interpT2CharString
(
font
&
component
callbacks
translation
TRUE
0
0
&
dummyWidth
)
;
cf2_freeSeacComponent
(
decoder
&
component
)
;
}
goto
exit
;
case
cf2_cmdCNTRMASK
:
case
cf2_cmdHINTMASK
:
FT_TRACE4
(
(
op1
=
=
cf2_cmdCNTRMASK
?
"
cntrmask
"
:
"
hintmask
"
)
)
;
if
(
cf2_stack_count
(
opStack
)
>
1
&
&
cf2_hintmask_isValid
(
&
hintMask
)
)
{
FT_TRACE4
(
(
"
cf2_interpT2CharString
:
invalid
hint
mask
\
n
"
)
)
;
break
;
}
cf2_doStems
(
font
opStack
&
vStemHintArray
width
&
haveWidth
0
)
;
if
(
decoder
-
>
width_only
)
goto
exit
;
if
(
op1
=
=
cf2_cmdHINTMASK
)
{
cf2_hintmask_read
(
&
hintMask
charstring
cf2_arrstack_size
(
&
hStemHintArray
)
+
cf2_arrstack_size
(
&
vStemHintArray
)
)
;
}
else
{
CF2_HintMapRec
counterHintMap
;
CF2_HintMaskRec
counterMask
;
cf2_hintmap_init
(
&
counterHintMap
font
&
glyphPath
.
initialHintMap
&
glyphPath
.
hintMoves
scaleY
)
;
cf2_hintmask_init
(
&
counterMask
error
)
;
cf2_hintmask_read
(
&
counterMask
charstring
cf2_arrstack_size
(
&
hStemHintArray
)
+
cf2_arrstack_size
(
&
vStemHintArray
)
)
;
cf2_hintmap_build
(
&
counterHintMap
&
hStemHintArray
&
vStemHintArray
&
counterMask
0
FALSE
)
;
}
break
;
case
cf2_cmdRMOVETO
:
FT_TRACE4
(
(
"
rmoveto
\
n
"
)
)
;
if
(
font
-
>
isT1
&
&
!
decoder
-
>
flex_state
&
&
!
haveWidth
)
FT_ERROR
(
(
"
cf2_interpT2CharString
(
Type
1
mode
)
:
"
"
No
width
.
Use
hsbw
/
sbw
as
first
op
\
n
"
)
)
;
if
(
cf2_stack_count
(
opStack
)
>
2
&
&
!
haveWidth
)
*
width
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
0
)
nominalWidthX
)
;
haveWidth
=
TRUE
;
if
(
decoder
-
>
width_only
)
goto
exit
;
curY
=
ADD_INT32
(
curY
cf2_stack_popFixed
(
opStack
)
)
;
curX
=
ADD_INT32
(
curX
cf2_stack_popFixed
(
opStack
)
)
;
if
(
!
decoder
-
>
flex_state
)
cf2_glyphpath_moveTo
(
&
glyphPath
curX
curY
)
;
break
;
case
cf2_cmdHMOVETO
:
FT_TRACE4
(
(
"
hmoveto
\
n
"
)
)
;
if
(
font
-
>
isT1
&
&
!
decoder
-
>
flex_state
&
&
!
haveWidth
)
FT_ERROR
(
(
"
cf2_interpT2CharString
(
Type
1
mode
)
:
"
"
No
width
.
Use
hsbw
/
sbw
as
first
op
\
n
"
)
)
;
if
(
cf2_stack_count
(
opStack
)
>
1
&
&
!
haveWidth
)
*
width
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
0
)
nominalWidthX
)
;
haveWidth
=
TRUE
;
if
(
decoder
-
>
width_only
)
goto
exit
;
curX
=
ADD_INT32
(
curX
cf2_stack_popFixed
(
opStack
)
)
;
cf2_glyphpath_moveTo
(
&
glyphPath
curX
curY
)
;
break
;
case
cf2_cmdRLINECURVE
:
{
CF2_UInt
count
=
cf2_stack_count
(
opStack
)
;
CF2_UInt
idx
=
0
;
FT_TRACE4
(
(
"
rlinecurve
\
n
"
)
)
;
while
(
idx
+
6
<
count
)
{
curX
=
ADD_INT32
(
curX
cf2_stack_getReal
(
opStack
idx
+
0
)
)
;
curY
=
ADD_INT32
(
curY
cf2_stack_getReal
(
opStack
idx
+
1
)
)
;
cf2_glyphpath_lineTo
(
&
glyphPath
curX
curY
)
;
idx
+
=
2
;
}
while
(
idx
<
count
)
{
CF2_Fixed
x1
y1
x2
y2
x3
y3
;
x1
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
0
)
curX
)
;
y1
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
1
)
curY
)
;
x2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
2
)
x1
)
;
y2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
3
)
y1
)
;
x3
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
4
)
x2
)
;
y3
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
5
)
y2
)
;
cf2_glyphpath_curveTo
(
&
glyphPath
x1
y1
x2
y2
x3
y3
)
;
curX
=
x3
;
curY
=
y3
;
idx
+
=
6
;
}
cf2_stack_clear
(
opStack
)
;
}
continue
;
case
cf2_cmdVVCURVETO
:
{
CF2_UInt
count
count1
=
cf2_stack_count
(
opStack
)
;
CF2_UInt
idx
=
0
;
count
=
count1
&
~
2U
;
idx
+
=
count1
-
count
;
FT_TRACE4
(
(
"
vvcurveto
\
n
"
)
)
;
while
(
idx
<
count
)
{
CF2_Fixed
x1
y1
x2
y2
x3
y3
;
if
(
(
count
-
idx
)
&
1
)
{
x1
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
)
curX
)
;
idx
+
+
;
}
else
x1
=
curX
;
y1
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
0
)
curY
)
;
x2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
1
)
x1
)
;
y2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
2
)
y1
)
;
x3
=
x2
;
y3
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
3
)
y2
)
;
cf2_glyphpath_curveTo
(
&
glyphPath
x1
y1
x2
y2
x3
y3
)
;
curX
=
x3
;
curY
=
y3
;
idx
+
=
4
;
}
cf2_stack_clear
(
opStack
)
;
}
continue
;
case
cf2_cmdHHCURVETO
:
{
CF2_UInt
count
count1
=
cf2_stack_count
(
opStack
)
;
CF2_UInt
idx
=
0
;
count
=
count1
&
~
2U
;
idx
+
=
count1
-
count
;
FT_TRACE4
(
(
"
hhcurveto
\
n
"
)
)
;
while
(
idx
<
count
)
{
CF2_Fixed
x1
y1
x2
y2
x3
y3
;
if
(
(
count
-
idx
)
&
1
)
{
y1
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
)
curY
)
;
idx
+
+
;
}
else
y1
=
curY
;
x1
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
0
)
curX
)
;
x2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
1
)
x1
)
;
y2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
2
)
y1
)
;
x3
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
3
)
x2
)
;
y3
=
y2
;
cf2_glyphpath_curveTo
(
&
glyphPath
x1
y1
x2
y2
x3
y3
)
;
curX
=
x3
;
curY
=
y3
;
idx
+
=
4
;
}
cf2_stack_clear
(
opStack
)
;
}
continue
;
case
cf2_cmdVHCURVETO
:
case
cf2_cmdHVCURVETO
:
{
CF2_UInt
count
count1
=
cf2_stack_count
(
opStack
)
;
CF2_UInt
idx
=
0
;
FT_Bool
alternate
=
FT_BOOL
(
op1
=
=
cf2_cmdHVCURVETO
)
;
count
=
count1
&
~
2U
;
idx
+
=
count1
-
count
;
FT_TRACE4
(
(
alternate
?
"
hvcurveto
\
n
"
:
"
vhcurveto
\
n
"
)
)
;
while
(
idx
<
count
)
{
CF2_Fixed
x1
x2
x3
y1
y2
y3
;
if
(
alternate
)
{
x1
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
0
)
curX
)
;
y1
=
curY
;
x2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
1
)
x1
)
;
y2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
2
)
y1
)
;
y3
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
3
)
y2
)
;
if
(
count
-
idx
=
=
5
)
{
x3
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
4
)
x2
)
;
idx
+
+
;
}
else
x3
=
x2
;
alternate
=
FALSE
;
}
else
{
x1
=
curX
;
y1
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
0
)
curY
)
;
x2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
1
)
x1
)
;
y2
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
2
)
y1
)
;
x3
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
3
)
x2
)
;
if
(
count
-
idx
=
=
5
)
{
y3
=
ADD_INT32
(
cf2_stack_getReal
(
opStack
idx
+
4
)
y2
)
;
idx
+
+
;
}
else
y3
=
y2
;
alternate
=
TRUE
;
}
cf2_glyphpath_curveTo
(
&
glyphPath
x1
y1
x2
y2
x3
y3
)
;
curX
=
x3
;
curY
=
y3
;
idx
+
=
4
;
}
cf2_stack_clear
(
opStack
)
;
}
continue
;
case
cf2_cmdEXTENDEDNMBR
:
{
CF2_Int
v
;
CF2_Int
byte1
=
cf2_buf_readByte
(
charstring
)
;
CF2_Int
byte2
=
cf2_buf_readByte
(
charstring
)
;
v
=
(
FT_Short
)
(
(
byte1
<
<
8
)
|
byte2
)
;
FT_TRACE4
(
(
"
%
d
"
v
)
)
;
cf2_stack_pushInt
(
opStack
v
)
;
}
continue
;
default
:
{
if
(
op1
<
=
246
)
{
CF2_Int
v
;
v
=
op1
-
139
;
FT_TRACE4
(
(
"
%
d
"
v
)
)
;
cf2_stack_pushInt
(
opStack
v
)
;
}
else
if
(
op1
<
=
250
)
{
CF2_Int
v
;
v
=
op1
;
v
-
=
247
;
v
*
=
256
;
v
+
=
cf2_buf_readByte
(
charstring
)
;
v
+
=
108
;
FT_TRACE4
(
(
"
%
d
"
v
)
)
;
cf2_stack_pushInt
(
opStack
v
)
;
}
else
if
(
op1
<
=
254
)
{
CF2_Int
v
;
v
=
op1
;
v
-
=
251
;
v
*
=
256
;
v
+
=
cf2_buf_readByte
(
charstring
)
;
v
=
-
v
-
108
;
FT_TRACE4
(
(
"
%
d
"
v
)
)
;
cf2_stack_pushInt
(
opStack
v
)
;
}
else
{
CF2_Fixed
v
;
FT_UInt32
byte1
=
(
FT_UInt32
)
cf2_buf_readByte
(
charstring
)
;
FT_UInt32
byte2
=
(
FT_UInt32
)
cf2_buf_readByte
(
charstring
)
;
FT_UInt32
byte3
=
(
FT_UInt32
)
cf2_buf_readByte
(
charstring
)
;
FT_UInt32
byte4
=
(
FT_UInt32
)
cf2_buf_readByte
(
charstring
)
;
v
=
(
CF2_Fixed
)
(
(
byte1
<
<
24
)
|
(
byte2
<
<
16
)
|
(
byte3
<
<
8
)
|
byte4
)
;
if
(
font
-
>
isT1
)
{
if
(
v
>
32000
|
|
v
<
-
32000
)
{
if
(
large_int
)
FT_ERROR
(
(
"
cf2_interpT2CharString
(
Type
1
mode
)
:
"
"
no
div
'
after
large
integer
\
n
"
)
)
;
else
large_int
=
TRUE
;
}
FT_TRACE4
(
(
"
%
d
"
v
)
)
;
cf2_stack_pushInt
(
opStack
(
CF2_Int
)
v
)
;
}
else
{
FT_TRACE4
(
(
"
%
.
5fF
"
v
/
65536
.
0
)
)
;
cf2_stack_pushFixed
(
opStack
v
)
;
}
}
}
continue
;
}
cf2_stack_clear
(
opStack
)
;
}
FT_TRACE4
(
(
"
cf2_interpT2CharString
:
"
"
charstring
ends
without
ENDCHAR
\
n
"
)
)
;
exit
:
cf2_setError
(
error
lastError
)
;
if
(
*
error
)
FT_TRACE4
(
(
"
charstring
error
%
d
\
n
"
*
error
)
)
;
cf2_glyphpath_finalize
(
&
glyphPath
)
;
cf2_arrstack_finalize
(
&
vStemHintArray
)
;
cf2_arrstack_finalize
(
&
hStemHintArray
)
;
cf2_arrstack_finalize
(
&
subrStack
)
;
cf2_stack_free
(
opStack
)
;
FT_TRACE4
(
(
"
\
n
"
)
)
;
return
;
}
