#
include
"
psft
.
h
"
#
include
FT_INTERNAL_DEBUG_H
#
include
"
psfont
.
h
"
#
include
"
pserror
.
h
"
#
include
"
psobjs
.
h
"
#
include
"
cffdecode
.
h
"
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
#
include
FT_MULTIPLE_MASTERS_H
#
include
FT_SERVICE_MULTIPLE_MASTERS_H
#
endif
#
include
FT_SERVICE_CFF_TABLE_LOAD_H
#
define
CF2_MAX_SIZE
cf2_intToFixed
(
2000
)
/
*
max
ppem
*
/
static
FT_Error
cf2_checkTransform
(
const
CF2_Matrix
*
transform
CF2_Int
unitsPerEm
)
{
CF2_Fixed
maxScale
;
FT_ASSERT
(
unitsPerEm
>
0
)
;
if
(
transform
-
>
a
<
=
0
|
|
transform
-
>
d
<
=
0
)
return
FT_THROW
(
Invalid_Size_Handle
)
;
FT_ASSERT
(
transform
-
>
b
=
=
0
&
&
transform
-
>
c
=
=
0
)
;
FT_ASSERT
(
transform
-
>
tx
=
=
0
&
&
transform
-
>
ty
=
=
0
)
;
if
(
unitsPerEm
>
0x7FFF
)
return
FT_THROW
(
Glyph_Too_Big
)
;
maxScale
=
FT_DivFix
(
CF2_MAX_SIZE
cf2_intToFixed
(
unitsPerEm
)
)
;
if
(
transform
-
>
a
>
maxScale
|
|
transform
-
>
d
>
maxScale
)
return
FT_THROW
(
Glyph_Too_Big
)
;
return
FT_Err_Ok
;
}
static
void
cf2_setGlyphWidth
(
CF2_Outline
outline
CF2_Fixed
width
)
{
PS_Decoder
*
decoder
=
outline
-
>
decoder
;
FT_ASSERT
(
decoder
)
;
if
(
!
decoder
-
>
builder
.
is_t1
)
*
decoder
-
>
glyph_width
=
cf2_fixedToInt
(
width
)
;
}
static
void
cf2_free_instance
(
void
*
ptr
)
{
CF2_Font
font
=
(
CF2_Font
)
ptr
;
if
(
font
)
{
FT_Memory
memory
=
font
-
>
memory
;
FT_FREE
(
font
-
>
blend
.
lastNDV
)
;
FT_FREE
(
font
-
>
blend
.
BV
)
;
}
}
static
void
cf2_builder_moveTo
(
CF2_OutlineCallbacks
callbacks
const
CF2_CallbackParams
params
)
{
CF2_Outline
outline
=
(
CF2_Outline
)
callbacks
;
PS_Builder
*
builder
;
(
void
)
params
;
FT_ASSERT
(
outline
&
&
outline
-
>
decoder
)
;
FT_ASSERT
(
params
-
>
op
=
=
CF2_PathOpMoveTo
)
;
builder
=
&
outline
-
>
decoder
-
>
builder
;
ps_builder_close_contour
(
builder
)
;
builder
-
>
path_begun
=
0
;
}
static
void
cf2_builder_lineTo
(
CF2_OutlineCallbacks
callbacks
const
CF2_CallbackParams
params
)
{
FT_Error
error
;
CF2_Outline
outline
=
(
CF2_Outline
)
callbacks
;
PS_Builder
*
builder
;
FT_ASSERT
(
outline
&
&
outline
-
>
decoder
)
;
FT_ASSERT
(
params
-
>
op
=
=
CF2_PathOpLineTo
)
;
builder
=
&
outline
-
>
decoder
-
>
builder
;
if
(
!
builder
-
>
path_begun
)
{
error
=
ps_builder_start_point
(
builder
params
-
>
pt0
.
x
params
-
>
pt0
.
y
)
;
if
(
error
)
{
if
(
!
*
callbacks
-
>
error
)
*
callbacks
-
>
error
=
error
;
return
;
}
}
error
=
ps_builder_add_point1
(
builder
params
-
>
pt1
.
x
params
-
>
pt1
.
y
)
;
if
(
error
)
{
if
(
!
*
callbacks
-
>
error
)
*
callbacks
-
>
error
=
error
;
return
;
}
}
static
void
cf2_builder_cubeTo
(
CF2_OutlineCallbacks
callbacks
const
CF2_CallbackParams
params
)
{
FT_Error
error
;
CF2_Outline
outline
=
(
CF2_Outline
)
callbacks
;
PS_Builder
*
builder
;
FT_ASSERT
(
outline
&
&
outline
-
>
decoder
)
;
FT_ASSERT
(
params
-
>
op
=
=
CF2_PathOpCubeTo
)
;
builder
=
&
outline
-
>
decoder
-
>
builder
;
if
(
!
builder
-
>
path_begun
)
{
error
=
ps_builder_start_point
(
builder
params
-
>
pt0
.
x
params
-
>
pt0
.
y
)
;
if
(
error
)
{
if
(
!
*
callbacks
-
>
error
)
*
callbacks
-
>
error
=
error
;
return
;
}
}
error
=
ps_builder_check_points
(
builder
3
)
;
if
(
error
)
{
if
(
!
*
callbacks
-
>
error
)
*
callbacks
-
>
error
=
error
;
return
;
}
ps_builder_add_point
(
builder
params
-
>
pt1
.
x
params
-
>
pt1
.
y
0
)
;
ps_builder_add_point
(
builder
params
-
>
pt2
.
x
params
-
>
pt2
.
y
0
)
;
ps_builder_add_point
(
builder
params
-
>
pt3
.
x
params
-
>
pt3
.
y
1
)
;
}
static
void
cf2_outline_init
(
CF2_Outline
outline
FT_Memory
memory
FT_Error
*
error
)
{
FT_ZERO
(
outline
)
;
outline
-
>
root
.
memory
=
memory
;
outline
-
>
root
.
error
=
error
;
outline
-
>
root
.
moveTo
=
cf2_builder_moveTo
;
outline
-
>
root
.
lineTo
=
cf2_builder_lineTo
;
outline
-
>
root
.
cubeTo
=
cf2_builder_cubeTo
;
}
static
void
cf2_getScaleAndHintFlag
(
PS_Decoder
*
decoder
CF2_Fixed
*
x_scale
CF2_Fixed
*
y_scale
FT_Bool
*
hinted
FT_Bool
*
scaled
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
builder
.
glyph
)
;
*
hinted
=
decoder
-
>
builder
.
glyph
-
>
hint
;
*
scaled
=
decoder
-
>
builder
.
glyph
-
>
scaled
;
if
(
*
hinted
)
{
*
x_scale
=
ADD_INT32
(
decoder
-
>
builder
.
glyph
-
>
x_scale
32
)
/
64
;
*
y_scale
=
ADD_INT32
(
decoder
-
>
builder
.
glyph
-
>
y_scale
32
)
/
64
;
}
else
{
*
x_scale
=
0x0400
;
*
y_scale
=
0x0400
;
}
}
static
FT_UShort
cf2_getUnitsPerEm
(
PS_Decoder
*
decoder
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
builder
.
face
)
;
FT_ASSERT
(
decoder
-
>
builder
.
face
-
>
units_per_EM
)
;
return
decoder
-
>
builder
.
face
-
>
units_per_EM
;
}
FT_LOCAL_DEF
(
FT_Error
)
cf2_decoder_parse_charstrings
(
PS_Decoder
*
decoder
FT_Byte
*
charstring_base
FT_ULong
charstring_len
)
{
FT_Memory
memory
;
FT_Error
error
=
FT_Err_Ok
;
CF2_Font
font
;
FT_Bool
is_t1
=
decoder
-
>
builder
.
is_t1
;
FT_ASSERT
(
decoder
&
&
(
is_t1
|
|
decoder
-
>
cff
)
)
;
if
(
is_t1
&
&
!
decoder
-
>
current_subfont
)
{
FT_ERROR
(
(
"
cf2_decoder_parse_charstrings
(
Type
1
)
:
"
"
SubFont
missing
.
Use
t1_make_subfont
'
first
\
n
"
)
)
;
return
FT_THROW
(
Invalid_Table
)
;
}
memory
=
decoder
-
>
builder
.
memory
;
font
=
(
CF2_Font
)
decoder
-
>
cf2_instance
-
>
data
;
if
(
!
decoder
-
>
cf2_instance
-
>
data
)
{
decoder
-
>
cf2_instance
-
>
finalizer
=
(
FT_Generic_Finalizer
)
cf2_free_instance
;
if
(
FT_ALLOC
(
decoder
-
>
cf2_instance
-
>
data
sizeof
(
CF2_FontRec
)
)
)
return
FT_THROW
(
Out_Of_Memory
)
;
font
=
(
CF2_Font
)
decoder
-
>
cf2_instance
-
>
data
;
font
-
>
memory
=
memory
;
if
(
!
is_t1
)
font
-
>
cffload
=
(
FT_Service_CFFLoad
)
decoder
-
>
cff
-
>
cffload
;
cf2_outline_init
(
&
font
-
>
outline
font
-
>
memory
&
font
-
>
error
)
;
}
font
-
>
decoder
=
decoder
;
font
-
>
outline
.
decoder
=
decoder
;
{
PS_Builder
*
builder
=
&
decoder
-
>
builder
;
PS_Driver
driver
=
(
PS_Driver
)
FT_FACE_DRIVER
(
builder
-
>
face
)
;
FT_Bool
no_stem_darkening_driver
=
driver
-
>
no_stem_darkening
;
FT_Char
no_stem_darkening_font
=
builder
-
>
face
-
>
internal
-
>
no_stem_darkening
;
FT_Error
error2
=
FT_Err_Ok
;
CF2_BufferRec
buf
;
CF2_Matrix
transform
;
CF2_F16Dot16
glyphWidth
;
FT_Bool
hinted
;
FT_Bool
scaled
;
FT_ASSERT
(
charstring_base
+
charstring_len
>
=
charstring_base
)
;
FT_ZERO
(
&
buf
)
;
buf
.
start
=
buf
.
ptr
=
charstring_base
;
buf
.
end
=
FT_OFFSET
(
charstring_base
charstring_len
)
;
FT_ZERO
(
&
transform
)
;
cf2_getScaleAndHintFlag
(
decoder
&
transform
.
a
&
transform
.
d
&
hinted
&
scaled
)
;
if
(
is_t1
)
font
-
>
isCFF2
=
FALSE
;
else
{
font
-
>
isCFF2
=
(
(
TT_Face
)
builder
-
>
face
)
-
>
is_cff2
;
}
font
-
>
isT1
=
is_t1
;
font
-
>
renderingFlags
=
0
;
if
(
hinted
)
font
-
>
renderingFlags
|
=
CF2_FlagsHinted
;
if
(
scaled
&
&
(
!
no_stem_darkening_font
|
|
(
no_stem_darkening_font
<
0
&
&
!
no_stem_darkening_driver
)
)
)
font
-
>
renderingFlags
|
=
CF2_FlagsDarkened
;
font
-
>
darkenParams
[
0
]
=
driver
-
>
darken_params
[
0
]
;
font
-
>
darkenParams
[
1
]
=
driver
-
>
darken_params
[
1
]
;
font
-
>
darkenParams
[
2
]
=
driver
-
>
darken_params
[
2
]
;
font
-
>
darkenParams
[
3
]
=
driver
-
>
darken_params
[
3
]
;
font
-
>
darkenParams
[
4
]
=
driver
-
>
darken_params
[
4
]
;
font
-
>
darkenParams
[
5
]
=
driver
-
>
darken_params
[
5
]
;
font
-
>
darkenParams
[
6
]
=
driver
-
>
darken_params
[
6
]
;
font
-
>
darkenParams
[
7
]
=
driver
-
>
darken_params
[
7
]
;
font
-
>
unitsPerEm
=
(
CF2_Int
)
cf2_getUnitsPerEm
(
decoder
)
;
if
(
scaled
)
{
error2
=
cf2_checkTransform
(
&
transform
font
-
>
unitsPerEm
)
;
if
(
error2
)
return
error2
;
}
error2
=
cf2_getGlyphOutline
(
font
&
buf
&
transform
&
glyphWidth
)
;
if
(
error2
)
return
FT_ERR
(
Invalid_File_Format
)
;
cf2_setGlyphWidth
(
&
font
-
>
outline
glyphWidth
)
;
return
FT_Err_Ok
;
}
}
FT_LOCAL_DEF
(
CFF_SubFont
)
cf2_getSubfont
(
PS_Decoder
*
decoder
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
current_subfont
)
;
return
decoder
-
>
current_subfont
;
}
FT_LOCAL_DEF
(
CFF_VStore
)
cf2_getVStore
(
PS_Decoder
*
decoder
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
cff
)
;
return
&
decoder
-
>
cff
-
>
vstore
;
}
FT_LOCAL_DEF
(
FT_UInt
)
cf2_getMaxstack
(
PS_Decoder
*
decoder
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
cff
)
;
return
decoder
-
>
cff
-
>
top_font
.
font_dict
.
maxstack
;
}
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
FT_LOCAL_DEF
(
FT_Error
)
cf2_getNormalizedVector
(
PS_Decoder
*
decoder
CF2_UInt
*
len
FT_Fixed
*
*
vec
)
{
TT_Face
face
;
FT_Service_MultiMasters
mm
;
FT_ASSERT
(
decoder
&
&
decoder
-
>
builder
.
face
)
;
FT_ASSERT
(
vec
&
&
len
)
;
FT_ASSERT
(
!
decoder
-
>
builder
.
is_t1
)
;
face
=
(
TT_Face
)
decoder
-
>
builder
.
face
;
mm
=
(
FT_Service_MultiMasters
)
face
-
>
mm
;
return
mm
-
>
get_var_blend
(
FT_FACE
(
face
)
len
NULL
vec
NULL
)
;
}
#
endif
FT_LOCAL_DEF
(
CF2_Fixed
)
cf2_getPpemY
(
PS_Decoder
*
decoder
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
builder
.
face
&
&
decoder
-
>
builder
.
face
-
>
size
)
;
return
cf2_intToFixed
(
decoder
-
>
builder
.
face
-
>
size
-
>
metrics
.
y_ppem
)
;
}
FT_LOCAL_DEF
(
CF2_Fixed
)
cf2_getStdVW
(
PS_Decoder
*
decoder
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
current_subfont
)
;
return
cf2_intToFixed
(
decoder
-
>
current_subfont
-
>
private_dict
.
standard_height
)
;
}
FT_LOCAL_DEF
(
CF2_Fixed
)
cf2_getStdHW
(
PS_Decoder
*
decoder
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
current_subfont
)
;
return
cf2_intToFixed
(
decoder
-
>
current_subfont
-
>
private_dict
.
standard_width
)
;
}
FT_LOCAL_DEF
(
void
)
cf2_getBlueMetrics
(
PS_Decoder
*
decoder
CF2_Fixed
*
blueScale
CF2_Fixed
*
blueShift
CF2_Fixed
*
blueFuzz
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
current_subfont
)
;
*
blueScale
=
FT_DivFix
(
decoder
-
>
current_subfont
-
>
private_dict
.
blue_scale
cf2_intToFixed
(
1000
)
)
;
*
blueShift
=
cf2_intToFixed
(
decoder
-
>
current_subfont
-
>
private_dict
.
blue_shift
)
;
*
blueFuzz
=
cf2_intToFixed
(
decoder
-
>
current_subfont
-
>
private_dict
.
blue_fuzz
)
;
}
FT_LOCAL_DEF
(
void
)
cf2_getBlueValues
(
PS_Decoder
*
decoder
size_t
*
count
FT_Pos
*
*
data
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
current_subfont
)
;
*
count
=
decoder
-
>
current_subfont
-
>
private_dict
.
num_blue_values
;
*
data
=
(
FT_Pos
*
)
&
decoder
-
>
current_subfont
-
>
private_dict
.
blue_values
;
}
FT_LOCAL_DEF
(
void
)
cf2_getOtherBlues
(
PS_Decoder
*
decoder
size_t
*
count
FT_Pos
*
*
data
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
current_subfont
)
;
*
count
=
decoder
-
>
current_subfont
-
>
private_dict
.
num_other_blues
;
*
data
=
(
FT_Pos
*
)
&
decoder
-
>
current_subfont
-
>
private_dict
.
other_blues
;
}
FT_LOCAL_DEF
(
void
)
cf2_getFamilyBlues
(
PS_Decoder
*
decoder
size_t
*
count
FT_Pos
*
*
data
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
current_subfont
)
;
*
count
=
decoder
-
>
current_subfont
-
>
private_dict
.
num_family_blues
;
*
data
=
(
FT_Pos
*
)
&
decoder
-
>
current_subfont
-
>
private_dict
.
family_blues
;
}
FT_LOCAL_DEF
(
void
)
cf2_getFamilyOtherBlues
(
PS_Decoder
*
decoder
size_t
*
count
FT_Pos
*
*
data
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
current_subfont
)
;
*
count
=
decoder
-
>
current_subfont
-
>
private_dict
.
num_family_other_blues
;
*
data
=
(
FT_Pos
*
)
&
decoder
-
>
current_subfont
-
>
private_dict
.
family_other_blues
;
}
FT_LOCAL_DEF
(
CF2_Int
)
cf2_getLanguageGroup
(
PS_Decoder
*
decoder
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
current_subfont
)
;
return
decoder
-
>
current_subfont
-
>
private_dict
.
language_group
;
}
FT_LOCAL_DEF
(
CF2_Int
)
cf2_initGlobalRegionBuffer
(
PS_Decoder
*
decoder
CF2_Int
subrNum
CF2_Buffer
buf
)
{
CF2_UInt
idx
;
FT_ASSERT
(
decoder
)
;
FT_ZERO
(
buf
)
;
idx
=
(
CF2_UInt
)
(
subrNum
+
decoder
-
>
globals_bias
)
;
if
(
idx
>
=
decoder
-
>
num_globals
)
return
TRUE
;
FT_ASSERT
(
decoder
-
>
globals
)
;
buf
-
>
start
=
buf
-
>
ptr
=
decoder
-
>
globals
[
idx
]
;
buf
-
>
end
=
decoder
-
>
globals
[
idx
+
1
]
;
return
FALSE
;
}
FT_LOCAL_DEF
(
FT_Error
)
cf2_getSeacComponent
(
PS_Decoder
*
decoder
CF2_Int
code
CF2_Buffer
buf
)
{
CF2_Int
gid
;
FT_Byte
*
charstring
;
FT_ULong
len
;
FT_Error
error
;
FT_ASSERT
(
decoder
)
;
FT_ASSERT
(
!
decoder
-
>
builder
.
is_t1
)
;
FT_ZERO
(
buf
)
;
#
ifdef
FT_CONFIG_OPTION_INCREMENTAL
if
(
decoder
-
>
builder
.
face
-
>
internal
-
>
incremental_interface
)
gid
=
code
;
else
#
endif
{
gid
=
cff_lookup_glyph_by_stdcharcode
(
decoder
-
>
cff
code
)
;
if
(
gid
<
0
)
return
FT_THROW
(
Invalid_Glyph_Format
)
;
}
error
=
decoder
-
>
get_glyph_callback
(
(
TT_Face
)
decoder
-
>
builder
.
face
(
CF2_UInt
)
gid
&
charstring
&
len
)
;
if
(
error
)
return
error
;
FT_ASSERT
(
charstring
+
len
>
=
charstring
)
;
buf
-
>
start
=
charstring
;
buf
-
>
end
=
FT_OFFSET
(
charstring
len
)
;
buf
-
>
ptr
=
buf
-
>
start
;
return
FT_Err_Ok
;
}
FT_LOCAL_DEF
(
void
)
cf2_freeSeacComponent
(
PS_Decoder
*
decoder
CF2_Buffer
buf
)
{
FT_ASSERT
(
decoder
)
;
FT_ASSERT
(
!
decoder
-
>
builder
.
is_t1
)
;
decoder
-
>
free_glyph_callback
(
(
TT_Face
)
decoder
-
>
builder
.
face
(
FT_Byte
*
*
)
&
buf
-
>
start
(
FT_ULong
)
(
buf
-
>
end
-
buf
-
>
start
)
)
;
}
FT_LOCAL_DEF
(
FT_Error
)
cf2_getT1SeacComponent
(
PS_Decoder
*
decoder
FT_UInt
glyph_index
CF2_Buffer
buf
)
{
FT_Data
glyph_data
;
FT_Error
error
=
FT_Err_Ok
;
T1_Face
face
=
(
T1_Face
)
decoder
-
>
builder
.
face
;
T1_Font
type1
=
&
face
-
>
type1
;
#
ifdef
FT_CONFIG_OPTION_INCREMENTAL
FT_Incremental_InterfaceRec
*
inc
=
face
-
>
root
.
internal
-
>
incremental_interface
;
if
(
inc
)
error
=
inc
-
>
funcs
-
>
get_glyph_data
(
inc
-
>
object
glyph_index
&
glyph_data
)
;
else
#
endif
{
glyph_data
.
pointer
=
type1
-
>
charstrings
[
glyph_index
]
;
glyph_data
.
length
=
(
FT_Int
)
type1
-
>
charstrings_len
[
glyph_index
]
;
}
if
(
!
error
)
{
FT_Byte
*
charstring_base
=
(
FT_Byte
*
)
glyph_data
.
pointer
;
FT_ULong
charstring_len
=
(
FT_ULong
)
glyph_data
.
length
;
FT_ASSERT
(
charstring_base
+
charstring_len
>
=
charstring_base
)
;
FT_ZERO
(
buf
)
;
buf
-
>
start
=
buf
-
>
ptr
=
charstring_base
;
buf
-
>
end
=
charstring_base
+
charstring_len
;
}
return
error
;
}
FT_LOCAL_DEF
(
void
)
cf2_freeT1SeacComponent
(
PS_Decoder
*
decoder
CF2_Buffer
buf
)
{
#
ifdef
FT_CONFIG_OPTION_INCREMENTAL
T1_Face
face
;
FT_Data
data
;
FT_ASSERT
(
decoder
)
;
face
=
(
T1_Face
)
decoder
-
>
builder
.
face
;
data
.
pointer
=
buf
-
>
start
;
data
.
length
=
(
FT_Int
)
(
buf
-
>
end
-
buf
-
>
start
)
;
if
(
face
-
>
root
.
internal
-
>
incremental_interface
)
face
-
>
root
.
internal
-
>
incremental_interface
-
>
funcs
-
>
free_glyph_data
(
face
-
>
root
.
internal
-
>
incremental_interface
-
>
object
&
data
)
;
#
else
FT_UNUSED
(
decoder
)
;
FT_UNUSED
(
buf
)
;
#
endif
}
FT_LOCAL_DEF
(
CF2_Int
)
cf2_initLocalRegionBuffer
(
PS_Decoder
*
decoder
CF2_Int
subrNum
CF2_Buffer
buf
)
{
CF2_UInt
idx
;
FT_ASSERT
(
decoder
)
;
FT_ZERO
(
buf
)
;
idx
=
(
CF2_UInt
)
(
subrNum
+
decoder
-
>
locals_bias
)
;
if
(
idx
>
=
decoder
-
>
num_locals
)
return
TRUE
;
FT_ASSERT
(
decoder
-
>
locals
)
;
buf
-
>
start
=
decoder
-
>
locals
[
idx
]
;
if
(
decoder
-
>
builder
.
is_t1
)
{
if
(
decoder
-
>
locals_len
)
buf
-
>
end
=
FT_OFFSET
(
buf
-
>
start
decoder
-
>
locals_len
[
idx
]
)
;
else
{
buf
-
>
start
+
=
(
decoder
-
>
lenIV
>
=
0
?
decoder
-
>
lenIV
:
0
)
;
buf
-
>
end
=
decoder
-
>
locals
[
idx
+
1
]
;
}
if
(
!
buf
-
>
start
)
{
FT_ERROR
(
(
"
cf2_initLocalRegionBuffer
(
Type
1
mode
)
:
"
"
invoking
empty
subrs
\
n
"
)
)
;
}
}
else
{
buf
-
>
end
=
decoder
-
>
locals
[
idx
+
1
]
;
}
buf
-
>
ptr
=
buf
-
>
start
;
return
FALSE
;
}
FT_LOCAL_DEF
(
CF2_Fixed
)
cf2_getDefaultWidthX
(
PS_Decoder
*
decoder
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
current_subfont
)
;
return
cf2_intToFixed
(
decoder
-
>
current_subfont
-
>
private_dict
.
default_width
)
;
}
FT_LOCAL_DEF
(
CF2_Fixed
)
cf2_getNominalWidthX
(
PS_Decoder
*
decoder
)
{
FT_ASSERT
(
decoder
&
&
decoder
-
>
current_subfont
)
;
return
cf2_intToFixed
(
decoder
-
>
current_subfont
-
>
private_dict
.
nominal_width
)
;
}
FT_LOCAL_DEF
(
void
)
cf2_outline_reset
(
CF2_Outline
outline
)
{
PS_Decoder
*
decoder
=
outline
-
>
decoder
;
FT_ASSERT
(
decoder
)
;
outline
-
>
root
.
windingMomentum
=
0
;
FT_GlyphLoader_Rewind
(
decoder
-
>
builder
.
loader
)
;
}
FT_LOCAL_DEF
(
void
)
cf2_outline_close
(
CF2_Outline
outline
)
{
PS_Decoder
*
decoder
=
outline
-
>
decoder
;
FT_ASSERT
(
decoder
)
;
ps_builder_close_contour
(
&
decoder
-
>
builder
)
;
FT_GlyphLoader_Add
(
decoder
-
>
builder
.
loader
)
;
}
