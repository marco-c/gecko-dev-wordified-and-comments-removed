#
if
__cplusplus
<
201103L
#
error
"
a
C
+
+
11
compiler
is
needed
"
#
endif
#
include
<
archive
.
h
>
#
include
<
archive_entry
.
h
>
#
include
<
assert
.
h
>
#
include
<
stdint
.
h
>
#
include
<
memory
>
#
include
<
vector
>
using
namespace
std
;
#
include
<
ft2build
.
h
>
#
include
FT_FREETYPE_H
#
include
FT_GLYPH_H
#
include
FT_CACHE_H
#
include
FT_CACHE_CHARMAP_H
#
include
FT_CACHE_IMAGE_H
#
include
FT_CACHE_SMALL_BITMAPS_H
#
include
FT_SYNTHESIS_H
#
include
FT_ADVANCES_H
#
include
FT_OUTLINE_H
#
include
FT_BBOX_H
#
include
FT_MODULE_H
#
include
FT_CFF_DRIVER_H
#
include
FT_TRUETYPE_DRIVER_H
#
include
FT_MULTIPLE_MASTERS_H
static
FT_Library
library
;
static
int
InitResult
;
struct
FT_Global
{
FT_Global
(
)
{
InitResult
=
FT_Init_FreeType
(
&
library
)
;
if
(
InitResult
)
return
;
unsigned
int
cff_hinting_engine
=
FT_CFF_HINTING_ADOBE
;
FT_Property_Set
(
library
"
cff
"
"
hinting
-
engine
"
&
cff_hinting_engine
)
;
}
~
FT_Global
(
)
{
FT_Done_FreeType
(
library
)
;
}
}
;
FT_Global
global_ft
;
struct
Random
{
int
n
;
int
N
;
int
t
;
int
m
;
uint32_t
r
;
Random
(
int
n_
int
N_
)
:
n
(
n_
)
N
(
N_
)
{
t
=
0
;
m
=
0
;
r
=
12345
;
}
int
get
(
)
{
if
(
m
>
=
n
)
return
-
1
;
Redo
:
r
^
=
r
<
<
13
;
r
^
=
r
>
>
17
;
r
^
=
r
<
<
5
;
double
U
=
double
(
r
)
/
UINT32_MAX
;
if
(
(
N
-
t
)
*
U
>
=
(
n
-
m
)
)
{
t
+
+
;
goto
Redo
;
}
t
+
+
;
m
+
+
;
return
t
;
}
}
;
static
int
archive_read_entry_data
(
struct
archive
*
ar
vector
<
FT_Byte
>
*
vw
)
{
int
r
;
const
FT_Byte
*
buff
;
size_t
size
;
int64_t
offset
;
for
(
;
;
)
{
r
=
archive_read_data_block
(
ar
reinterpret_cast
<
const
void
*
*
>
(
&
buff
)
&
size
&
offset
)
;
if
(
r
=
=
ARCHIVE_EOF
)
return
ARCHIVE_OK
;
if
(
r
!
=
ARCHIVE_OK
)
return
r
;
vw
-
>
insert
(
vw
-
>
end
(
)
buff
buff
+
size
)
;
}
}
static
vector
<
vector
<
FT_Byte
>
>
parse_data
(
const
uint8_t
*
data
size_t
size
)
{
struct
archive_entry
*
entry
;
int
r
;
vector
<
vector
<
FT_Byte
>
>
files
;
unique_ptr
<
struct
archive
decltype
(
archive_read_free
)
*
>
a
(
archive_read_new
(
)
archive_read_free
)
;
archive_read_support_format_tar
(
a
.
get
(
)
)
;
if
(
!
(
r
=
archive_read_open_memory
(
a
.
get
(
)
const_cast
<
void
*
>
(
static_cast
<
const
void
*
>
(
data
)
)
size
)
)
)
{
unique_ptr
<
struct
archive
decltype
(
archive_read_close
)
*
>
a_open
(
a
.
get
(
)
archive_read_close
)
;
for
(
;
;
)
{
r
=
archive_read_next_header
(
a_open
.
get
(
)
&
entry
)
;
if
(
r
=
=
ARCHIVE_EOF
)
break
;
if
(
r
!
=
ARCHIVE_OK
)
break
;
vector
<
FT_Byte
>
entry_data
;
r
=
archive_read_entry_data
(
a
.
get
(
)
&
entry_data
)
;
if
(
r
!
=
ARCHIVE_OK
)
break
;
files
.
push_back
(
move
(
entry_data
)
)
;
}
}
if
(
files
.
size
(
)
=
=
0
)
files
.
emplace_back
(
data
data
+
size
)
;
return
files
;
}
static
void
setIntermediateAxis
(
FT_Face
face
)
{
if
(
!
FT_HAS_MULTIPLE_MASTERS
(
face
)
)
return
;
FT_MM_Var
*
variations_ptr
=
nullptr
;
if
(
FT_Get_MM_Var
(
face
&
variations_ptr
)
)
return
;
unique_ptr
<
FT_MM_Var
decltype
(
free
)
*
>
variations
(
variations_ptr
free
)
;
vector
<
FT_Fixed
>
coords
(
variations
-
>
num_axis
)
;
for
(
unsigned
int
i
=
0
;
i
<
variations
-
>
num_axis
;
i
+
+
)
coords
[
i
]
=
(
variations
-
>
axis
[
i
]
.
minimum
+
variations
-
>
axis
[
i
]
.
def
)
/
2
;
if
(
FT_Set_Var_Design_Coordinates
(
face
FT_UInt
(
coords
.
size
(
)
)
coords
.
data
(
)
)
)
return
;
}
extern
"
C
"
int
LLVMFuzzerTestOneInput
(
const
uint8_t
*
data
size_t
size_
)
{
assert
(
!
InitResult
)
;
if
(
size_
<
1
)
return
0
;
const
vector
<
vector
<
FT_Byte
>
>
&
files
=
parse_data
(
data
size_
)
;
FT_Face
face
;
FT_Int32
load_flags
=
FT_LOAD_DEFAULT
;
#
if
0
FT_Render_Mode
render_mode
=
FT_RENDER_MODE_NORMAL
;
#
endif
if
(
FT_New_Memory_Face
(
library
files
[
0
]
.
data
(
)
(
FT_Long
)
files
[
0
]
.
size
(
)
-
1
&
face
)
)
return
0
;
long
num_faces
=
face
-
>
num_faces
;
FT_Done_Face
(
face
)
;
long
max_face_cnt
=
num_faces
<
20
?
num_faces
:
20
;
Random
faces_pool
(
(
int
)
max_face_cnt
(
int
)
num_faces
)
;
for
(
long
face_cnt
=
0
;
face_cnt
<
max_face_cnt
;
face_cnt
+
+
)
{
long
face_index
=
faces_pool
.
get
(
)
-
1
;
if
(
FT_New_Memory_Face
(
library
files
[
0
]
.
data
(
)
(
FT_Long
)
files
[
0
]
.
size
(
)
-
(
face_index
+
1
)
&
face
)
)
continue
;
long
num_instances
=
face
-
>
style_flags
>
>
16
;
FT_Done_Face
(
face
)
;
long
max_instance_cnt
=
num_instances
<
20
?
num_instances
:
20
;
Random
instances_pool
(
(
int
)
max_instance_cnt
(
int
)
num_instances
)
;
for
(
long
instance_cnt
=
0
;
instance_cnt
<
=
max_instance_cnt
;
instance_cnt
+
+
)
{
long
instance_index
=
0
;
if
(
!
instance_cnt
)
{
if
(
FT_New_Memory_Face
(
library
files
[
0
]
.
data
(
)
(
FT_Long
)
files
[
0
]
.
size
(
)
face_index
&
face
)
)
continue
;
}
else
{
instance_index
=
instances_pool
.
get
(
)
;
if
(
FT_New_Memory_Face
(
library
files
[
0
]
.
data
(
)
(
FT_Long
)
files
[
0
]
.
size
(
)
(
instance_index
<
<
16
)
+
face_index
&
face
)
)
continue
;
}
for
(
size_t
files_index
=
1
;
files_index
<
files
.
size
(
)
;
files_index
+
+
)
{
FT_Open_Args
open_args
=
{
}
;
open_args
.
flags
=
FT_OPEN_MEMORY
;
open_args
.
memory_base
=
files
[
files_index
]
.
data
(
)
;
open_args
.
memory_size
=
(
FT_Long
)
files
[
files_index
]
.
size
(
)
;
FT_Attach_Stream
(
face
&
open_args
)
;
}
int
max_size_cnt
=
face
-
>
num_fixed_sizes
<
10
?
face
-
>
num_fixed_sizes
:
10
;
Random
sizes_pool
(
max_size_cnt
face
-
>
num_fixed_sizes
)
;
for
(
int
size_cnt
=
0
;
size_cnt
<
=
max_size_cnt
;
size_cnt
+
+
)
{
FT_Int32
flags
=
load_flags
;
int
size_index
=
0
;
if
(
!
size_cnt
)
{
if
(
FT_Set_Char_Size
(
face
20
*
64
20
*
64
72
72
)
)
continue
;
flags
|
=
FT_LOAD_NO_BITMAP
;
}
else
{
if
(
instance_index
)
continue
;
size_index
=
sizes_pool
.
get
(
)
-
1
;
if
(
FT_Select_Size
(
face
size_index
)
)
continue
;
flags
|
=
FT_LOAD_COLOR
;
}
if
(
!
instance_index
&
&
!
size_cnt
)
setIntermediateAxis
(
face
)
;
for
(
unsigned
int
glyph_index
=
0
;
glyph_index
<
(
unsigned
int
)
face
-
>
num_glyphs
;
glyph_index
+
+
)
{
if
(
FT_Load_Glyph
(
face
glyph_index
flags
)
)
continue
;
#
if
0
FT_Glyph
glyph
;
if
(
!
FT_Get_Glyph
(
face
-
>
glyph
&
glyph
)
)
FT_Done_Glyph
(
glyph
)
;
FT_Outline
*
outline
=
&
face
-
>
glyph
-
>
outline
;
FT_Matrix
rot30
=
{
0xDDB4
-
0x8000
0x8000
0xDDB4
}
;
FT_Outline_Transform
(
outline
&
rot30
)
;
FT_BBox
bbox
;
FT_Outline_Get_BBox
(
outline
&
bbox
)
;
#
endif
}
}
FT_Done_Face
(
face
)
;
}
}
return
0
;
}
