#
include
<
ft2build
.
h
>
#
include
FT_INTERNAL_DEBUG_H
#
include
FT_INTERNAL_OBJECTS_H
#
include
FT_INTERNAL_STREAM_H
#
include
FT_TRUETYPE_TAGS_H
#
include
FT_TYPE1_TABLES_H
#
include
FT_INTERNAL_POSTSCRIPT_AUX_H
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
#
include
FT_MULTIPLE_MASTERS_H
#
include
FT_SERVICE_MULTIPLE_MASTERS_H
#
endif
#
include
"
cffload
.
h
"
#
include
"
cffparse
.
h
"
#
include
"
cfferrs
.
h
"
#
define
FT_FIXED_ONE
(
(
FT_Fixed
)
0x10000
)
#
if
1
static
const
FT_UShort
cff_isoadobe_charset
[
229
]
=
{
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
}
;
static
const
FT_UShort
cff_expert_charset
[
166
]
=
{
0
1
229
230
231
232
233
234
235
236
237
238
13
14
15
99
239
240
241
242
243
244
245
246
247
248
27
28
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
109
110
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
158
155
163
319
320
321
322
323
324
325
326
150
164
169
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
}
;
static
const
FT_UShort
cff_expertsubset_charset
[
87
]
=
{
0
1
231
232
235
236
237
238
13
14
15
99
239
240
241
242
243
244
245
246
247
248
27
28
249
250
251
253
254
255
256
257
258
259
260
261
262
263
264
265
266
109
110
267
268
269
270
272
300
301
302
305
314
315
158
155
163
320
321
322
323
324
325
326
150
164
169
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
}
;
static
const
FT_UShort
cff_standard_encoding
[
256
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
0
111
112
113
114
0
115
116
117
118
119
120
121
122
0
123
0
124
125
126
127
128
129
130
131
0
132
133
0
134
135
136
137
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
138
0
139
0
0
0
0
140
141
142
143
0
0
0
0
0
144
0
0
0
145
0
0
146
147
148
149
0
0
0
0
}
;
static
const
FT_UShort
cff_expert_encoding
[
256
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
229
230
0
231
232
233
234
235
236
237
238
13
14
15
99
239
240
241
242
243
244
245
246
247
248
27
28
249
250
251
252
0
253
254
255
256
257
0
0
0
258
0
0
259
260
261
262
0
0
263
264
265
0
266
109
110
267
268
269
0
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
304
305
306
0
0
307
308
309
310
311
0
312
0
0
312
0
0
314
315
0
0
316
317
318
0
0
0
158
155
163
319
320
321
322
323
324
325
0
0
326
150
164
169
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
}
;
#
endif
FT_LOCAL_DEF
(
FT_UShort
)
cff_get_standard_encoding
(
FT_UInt
charcode
)
{
return
(
FT_UShort
)
(
charcode
<
256
?
cff_standard_encoding
[
charcode
]
:
0
)
;
}
#
undef
FT_COMPONENT
#
define
FT_COMPONENT
trace_cffload
static
FT_ULong
cff_index_read_offset
(
CFF_Index
idx
FT_Error
*
errorp
)
{
FT_Error
error
;
FT_Stream
stream
=
idx
-
>
stream
;
FT_Byte
tmp
[
4
]
;
FT_ULong
result
=
0
;
if
(
!
FT_STREAM_READ
(
tmp
idx
-
>
off_size
)
)
{
FT_Int
nn
;
for
(
nn
=
0
;
nn
<
idx
-
>
off_size
;
nn
+
+
)
result
=
(
result
<
<
8
)
|
tmp
[
nn
]
;
}
*
errorp
=
error
;
return
result
;
}
static
FT_Error
cff_index_init
(
CFF_Index
idx
FT_Stream
stream
FT_Bool
load
FT_Bool
cff2
)
{
FT_Error
error
;
FT_Memory
memory
=
stream
-
>
memory
;
FT_UInt
count
;
FT_ZERO
(
idx
)
;
idx
-
>
stream
=
stream
;
idx
-
>
start
=
FT_STREAM_POS
(
)
;
if
(
cff2
)
{
if
(
FT_READ_ULONG
(
count
)
)
goto
Exit
;
idx
-
>
hdr_size
=
5
;
}
else
{
if
(
FT_READ_USHORT
(
count
)
)
goto
Exit
;
idx
-
>
hdr_size
=
3
;
}
if
(
count
>
0
)
{
FT_Byte
offsize
;
FT_ULong
size
;
if
(
FT_READ_BYTE
(
offsize
)
)
goto
Exit
;
if
(
offsize
<
1
|
|
offsize
>
4
)
{
error
=
FT_THROW
(
Invalid_Table
)
;
goto
Exit
;
}
idx
-
>
count
=
count
;
idx
-
>
off_size
=
offsize
;
size
=
(
FT_ULong
)
(
count
+
1
)
*
offsize
;
idx
-
>
data_offset
=
idx
-
>
start
+
idx
-
>
hdr_size
+
size
;
if
(
FT_STREAM_SKIP
(
size
-
offsize
)
)
goto
Exit
;
size
=
cff_index_read_offset
(
idx
&
error
)
;
if
(
error
)
goto
Exit
;
if
(
size
=
=
0
)
{
error
=
FT_THROW
(
Invalid_Table
)
;
goto
Exit
;
}
idx
-
>
data_size
=
-
-
size
;
if
(
load
)
{
if
(
FT_FRAME_EXTRACT
(
size
idx
-
>
bytes
)
)
goto
Exit
;
}
else
{
if
(
FT_STREAM_SKIP
(
size
)
)
goto
Exit
;
}
}
Exit
:
if
(
error
)
FT_FREE
(
idx
-
>
offsets
)
;
return
error
;
}
static
void
cff_index_done
(
CFF_Index
idx
)
{
if
(
idx
-
>
stream
)
{
FT_Stream
stream
=
idx
-
>
stream
;
FT_Memory
memory
=
stream
-
>
memory
;
if
(
idx
-
>
bytes
)
FT_FRAME_RELEASE
(
idx
-
>
bytes
)
;
FT_FREE
(
idx
-
>
offsets
)
;
FT_ZERO
(
idx
)
;
}
}
static
FT_Error
cff_index_load_offsets
(
CFF_Index
idx
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Stream
stream
=
idx
-
>
stream
;
FT_Memory
memory
=
stream
-
>
memory
;
if
(
idx
-
>
count
>
0
&
&
!
idx
-
>
offsets
)
{
FT_Byte
offsize
=
idx
-
>
off_size
;
FT_ULong
data_size
;
FT_Byte
*
p
;
FT_Byte
*
p_end
;
FT_ULong
*
poff
;
data_size
=
(
FT_ULong
)
(
idx
-
>
count
+
1
)
*
offsize
;
if
(
FT_NEW_ARRAY
(
idx
-
>
offsets
idx
-
>
count
+
1
)
|
|
FT_STREAM_SEEK
(
idx
-
>
start
+
idx
-
>
hdr_size
)
|
|
FT_FRAME_ENTER
(
data_size
)
)
goto
Exit
;
poff
=
idx
-
>
offsets
;
p
=
(
FT_Byte
*
)
stream
-
>
cursor
;
p_end
=
p
+
data_size
;
switch
(
offsize
)
{
case
1
:
for
(
;
p
<
p_end
;
p
+
+
poff
+
+
)
poff
[
0
]
=
p
[
0
]
;
break
;
case
2
:
for
(
;
p
<
p_end
;
p
+
=
2
poff
+
+
)
poff
[
0
]
=
FT_PEEK_USHORT
(
p
)
;
break
;
case
3
:
for
(
;
p
<
p_end
;
p
+
=
3
poff
+
+
)
poff
[
0
]
=
FT_PEEK_UOFF3
(
p
)
;
break
;
default
:
for
(
;
p
<
p_end
;
p
+
=
4
poff
+
+
)
poff
[
0
]
=
FT_PEEK_ULONG
(
p
)
;
}
FT_FRAME_EXIT
(
)
;
}
Exit
:
if
(
error
)
FT_FREE
(
idx
-
>
offsets
)
;
return
error
;
}
static
FT_Error
cff_index_get_pointers
(
CFF_Index
idx
FT_Byte
*
*
*
table
FT_Byte
*
*
pool
FT_ULong
*
pool_size
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Memory
memory
=
idx
-
>
stream
-
>
memory
;
FT_Byte
*
*
t
=
NULL
;
FT_Byte
*
new_bytes
=
NULL
;
FT_ULong
new_size
;
*
table
=
NULL
;
if
(
!
idx
-
>
offsets
)
{
error
=
cff_index_load_offsets
(
idx
)
;
if
(
error
)
goto
Exit
;
}
new_size
=
idx
-
>
data_size
+
idx
-
>
count
;
if
(
idx
-
>
count
>
0
&
&
!
FT_NEW_ARRAY
(
t
idx
-
>
count
+
1
)
&
&
(
!
pool
|
|
!
FT_ALLOC
(
new_bytes
new_size
)
)
)
{
FT_ULong
n
cur_offset
;
FT_ULong
extra
=
0
;
FT_Byte
*
org_bytes
=
idx
-
>
bytes
;
cur_offset
=
idx
-
>
offsets
[
0
]
-
1
;
if
(
cur_offset
!
=
0
)
{
FT_TRACE0
(
(
"
cff_index_get_pointers
:
"
"
invalid
first
offset
value
%
d
set
to
zero
\
n
"
cur_offset
)
)
;
cur_offset
=
0
;
}
if
(
!
pool
)
t
[
0
]
=
org_bytes
+
cur_offset
;
else
t
[
0
]
=
new_bytes
+
cur_offset
;
for
(
n
=
1
;
n
<
=
idx
-
>
count
;
n
+
+
)
{
FT_ULong
next_offset
=
idx
-
>
offsets
[
n
]
-
1
;
if
(
next_offset
<
cur_offset
)
next_offset
=
cur_offset
;
else
if
(
next_offset
>
idx
-
>
data_size
)
next_offset
=
idx
-
>
data_size
;
if
(
!
pool
)
t
[
n
]
=
org_bytes
+
next_offset
;
else
{
t
[
n
]
=
new_bytes
+
next_offset
+
extra
;
if
(
next_offset
!
=
cur_offset
)
{
FT_MEM_COPY
(
t
[
n
-
1
]
org_bytes
+
cur_offset
t
[
n
]
-
t
[
n
-
1
]
)
;
t
[
n
]
[
0
]
=
'
\
0
'
;
t
[
n
]
+
=
1
;
extra
+
+
;
}
}
cur_offset
=
next_offset
;
}
*
table
=
t
;
if
(
pool
)
*
pool
=
new_bytes
;
if
(
pool_size
)
*
pool_size
=
new_size
;
}
Exit
:
return
error
;
}
FT_LOCAL_DEF
(
FT_Error
)
cff_index_access_element
(
CFF_Index
idx
FT_UInt
element
FT_Byte
*
*
pbytes
FT_ULong
*
pbyte_len
)
{
FT_Error
error
=
FT_Err_Ok
;
if
(
idx
&
&
idx
-
>
count
>
element
)
{
FT_Stream
stream
=
idx
-
>
stream
;
FT_ULong
off1
off2
=
0
;
if
(
!
idx
-
>
offsets
)
{
FT_ULong
pos
=
element
*
idx
-
>
off_size
;
if
(
FT_STREAM_SEEK
(
idx
-
>
start
+
idx
-
>
hdr_size
+
pos
)
)
goto
Exit
;
off1
=
cff_index_read_offset
(
idx
&
error
)
;
if
(
error
)
goto
Exit
;
if
(
off1
!
=
0
)
{
do
{
element
+
+
;
off2
=
cff_index_read_offset
(
idx
&
error
)
;
}
while
(
off2
=
=
0
&
&
element
<
idx
-
>
count
)
;
}
}
else
{
off1
=
idx
-
>
offsets
[
element
]
;
if
(
off1
)
{
do
{
element
+
+
;
off2
=
idx
-
>
offsets
[
element
]
;
}
while
(
off2
=
=
0
&
&
element
<
idx
-
>
count
)
;
}
}
if
(
off2
>
stream
-
>
size
+
1
|
|
idx
-
>
data_offset
>
stream
-
>
size
-
off2
+
1
)
{
FT_ERROR
(
(
"
cff_index_access_element
:
"
"
offset
to
next
entry
(
%
d
)
"
"
exceeds
the
end
of
stream
(
%
d
)
\
n
"
off2
stream
-
>
size
-
idx
-
>
data_offset
+
1
)
)
;
off2
=
stream
-
>
size
-
idx
-
>
data_offset
+
1
;
}
if
(
off1
&
&
off2
>
off1
)
{
*
pbyte_len
=
off2
-
off1
;
if
(
idx
-
>
bytes
)
{
*
pbytes
=
idx
-
>
bytes
+
off1
-
1
;
}
else
{
if
(
FT_STREAM_SEEK
(
idx
-
>
data_offset
+
off1
-
1
)
|
|
FT_FRAME_EXTRACT
(
off2
-
off1
*
pbytes
)
)
goto
Exit
;
}
}
else
{
*
pbytes
=
0
;
*
pbyte_len
=
0
;
}
}
else
error
=
FT_THROW
(
Invalid_Argument
)
;
Exit
:
return
error
;
}
FT_LOCAL_DEF
(
void
)
cff_index_forget_element
(
CFF_Index
idx
FT_Byte
*
*
pbytes
)
{
if
(
idx
-
>
bytes
=
=
0
)
{
FT_Stream
stream
=
idx
-
>
stream
;
FT_FRAME_RELEASE
(
*
pbytes
)
;
}
}
FT_LOCAL_DEF
(
FT_String
*
)
cff_index_get_name
(
CFF_Font
font
FT_UInt
element
)
{
CFF_Index
idx
=
&
font
-
>
name_index
;
FT_Memory
memory
;
FT_Byte
*
bytes
;
FT_ULong
byte_len
;
FT_Error
error
;
FT_String
*
name
=
0
;
if
(
!
idx
-
>
stream
)
goto
Exit
;
memory
=
idx
-
>
stream
-
>
memory
;
error
=
cff_index_access_element
(
idx
element
&
bytes
&
byte_len
)
;
if
(
error
)
goto
Exit
;
if
(
!
FT_ALLOC
(
name
byte_len
+
1
)
)
{
if
(
byte_len
)
FT_MEM_COPY
(
name
bytes
byte_len
)
;
name
[
byte_len
]
=
0
;
}
cff_index_forget_element
(
idx
&
bytes
)
;
Exit
:
return
name
;
}
FT_LOCAL_DEF
(
FT_String
*
)
cff_index_get_string
(
CFF_Font
font
FT_UInt
element
)
{
return
(
element
<
font
-
>
num_strings
)
?
(
FT_String
*
)
font
-
>
strings
[
element
]
:
NULL
;
}
FT_LOCAL_DEF
(
FT_String
*
)
cff_index_get_sid_string
(
CFF_Font
font
FT_UInt
sid
)
{
if
(
sid
=
=
0xFFFFU
)
return
NULL
;
if
(
sid
>
390
)
return
cff_index_get_string
(
font
sid
-
391
)
;
if
(
!
font
-
>
psnames
)
return
NULL
;
return
(
FT_String
*
)
font
-
>
psnames
-
>
adobe_std_strings
(
sid
)
;
}
static
void
CFF_Done_FD_Select
(
CFF_FDSelect
fdselect
FT_Stream
stream
)
{
if
(
fdselect
-
>
data
)
FT_FRAME_RELEASE
(
fdselect
-
>
data
)
;
fdselect
-
>
data_size
=
0
;
fdselect
-
>
format
=
0
;
fdselect
-
>
range_count
=
0
;
}
static
FT_Error
CFF_Load_FD_Select
(
CFF_FDSelect
fdselect
FT_UInt
num_glyphs
FT_Stream
stream
FT_ULong
offset
)
{
FT_Error
error
;
FT_Byte
format
;
FT_UInt
num_ranges
;
if
(
FT_STREAM_SEEK
(
offset
)
|
|
FT_READ_BYTE
(
format
)
)
goto
Exit
;
fdselect
-
>
format
=
format
;
fdselect
-
>
cache_count
=
0
;
switch
(
format
)
{
case
0
:
fdselect
-
>
data_size
=
num_glyphs
;
goto
Load_Data
;
case
3
:
if
(
FT_READ_USHORT
(
num_ranges
)
)
goto
Exit
;
if
(
!
num_ranges
)
{
FT_TRACE0
(
(
"
CFF_Load_FD_Select
:
empty
FDSelect
array
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
fdselect
-
>
data_size
=
num_ranges
*
3
+
2
;
Load_Data
:
if
(
FT_FRAME_EXTRACT
(
fdselect
-
>
data_size
fdselect
-
>
data
)
)
goto
Exit
;
break
;
default
:
error
=
FT_THROW
(
Invalid_File_Format
)
;
}
Exit
:
return
error
;
}
FT_LOCAL_DEF
(
FT_Byte
)
cff_fd_select_get
(
CFF_FDSelect
fdselect
FT_UInt
glyph_index
)
{
FT_Byte
fd
=
0
;
if
(
!
fdselect
-
>
data
)
goto
Exit
;
switch
(
fdselect
-
>
format
)
{
case
0
:
fd
=
fdselect
-
>
data
[
glyph_index
]
;
break
;
case
3
:
if
(
(
FT_UInt
)
(
glyph_index
-
fdselect
-
>
cache_first
)
<
fdselect
-
>
cache_count
)
{
fd
=
fdselect
-
>
cache_fd
;
break
;
}
{
FT_Byte
*
p
=
fdselect
-
>
data
;
FT_Byte
*
p_limit
=
p
+
fdselect
-
>
data_size
;
FT_Byte
fd2
;
FT_UInt
first
limit
;
first
=
FT_NEXT_USHORT
(
p
)
;
do
{
if
(
glyph_index
<
first
)
break
;
fd2
=
*
p
+
+
;
limit
=
FT_NEXT_USHORT
(
p
)
;
if
(
glyph_index
<
limit
)
{
fd
=
fd2
;
fdselect
-
>
cache_first
=
first
;
fdselect
-
>
cache_count
=
limit
-
first
;
fdselect
-
>
cache_fd
=
fd2
;
break
;
}
first
=
limit
;
}
while
(
p
<
p_limit
)
;
}
break
;
default
:
;
}
Exit
:
return
fd
;
}
static
FT_Error
cff_charset_compute_cids
(
CFF_Charset
charset
FT_UInt
num_glyphs
FT_Memory
memory
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_UInt
i
;
FT_Long
j
;
FT_UShort
max_cid
=
0
;
if
(
charset
-
>
max_cid
>
0
)
goto
Exit
;
for
(
i
=
0
;
i
<
num_glyphs
;
i
+
+
)
{
if
(
charset
-
>
sids
[
i
]
>
max_cid
)
max_cid
=
charset
-
>
sids
[
i
]
;
}
if
(
FT_NEW_ARRAY
(
charset
-
>
cids
(
FT_ULong
)
max_cid
+
1
)
)
goto
Exit
;
for
(
j
=
(
FT_Long
)
num_glyphs
-
1
;
j
>
=
0
;
j
-
-
)
charset
-
>
cids
[
charset
-
>
sids
[
j
]
]
=
(
FT_UShort
)
j
;
charset
-
>
max_cid
=
max_cid
;
charset
-
>
num_glyphs
=
num_glyphs
;
Exit
:
return
error
;
}
FT_LOCAL_DEF
(
FT_UInt
)
cff_charset_cid_to_gindex
(
CFF_Charset
charset
FT_UInt
cid
)
{
FT_UInt
result
=
0
;
if
(
cid
<
=
charset
-
>
max_cid
)
result
=
charset
-
>
cids
[
cid
]
;
return
result
;
}
static
void
cff_charset_free_cids
(
CFF_Charset
charset
FT_Memory
memory
)
{
FT_FREE
(
charset
-
>
cids
)
;
charset
-
>
max_cid
=
0
;
}
static
void
cff_charset_done
(
CFF_Charset
charset
FT_Stream
stream
)
{
FT_Memory
memory
=
stream
-
>
memory
;
cff_charset_free_cids
(
charset
memory
)
;
FT_FREE
(
charset
-
>
sids
)
;
charset
-
>
format
=
0
;
charset
-
>
offset
=
0
;
}
static
FT_Error
cff_charset_load
(
CFF_Charset
charset
FT_UInt
num_glyphs
FT_Stream
stream
FT_ULong
base_offset
FT_ULong
offset
FT_Bool
invert
)
{
FT_Memory
memory
=
stream
-
>
memory
;
FT_Error
error
=
FT_Err_Ok
;
FT_UShort
glyph_sid
;
if
(
offset
>
2
)
{
FT_UInt
j
;
charset
-
>
offset
=
base_offset
+
offset
;
if
(
FT_STREAM_SEEK
(
charset
-
>
offset
)
|
|
FT_READ_BYTE
(
charset
-
>
format
)
)
goto
Exit
;
if
(
FT_NEW_ARRAY
(
charset
-
>
sids
num_glyphs
)
)
goto
Exit
;
charset
-
>
sids
[
0
]
=
0
;
switch
(
charset
-
>
format
)
{
case
0
:
if
(
num_glyphs
>
0
)
{
if
(
FT_FRAME_ENTER
(
(
num_glyphs
-
1
)
*
2
)
)
goto
Exit
;
for
(
j
=
1
;
j
<
num_glyphs
;
j
+
+
)
charset
-
>
sids
[
j
]
=
FT_GET_USHORT
(
)
;
FT_FRAME_EXIT
(
)
;
}
break
;
case
1
:
case
2
:
{
FT_UInt
nleft
;
FT_UInt
i
;
j
=
1
;
while
(
j
<
num_glyphs
)
{
if
(
FT_READ_USHORT
(
glyph_sid
)
)
goto
Exit
;
if
(
charset
-
>
format
=
=
2
)
{
if
(
FT_READ_USHORT
(
nleft
)
)
goto
Exit
;
}
else
{
if
(
FT_READ_BYTE
(
nleft
)
)
goto
Exit
;
}
if
(
glyph_sid
>
0xFFFFL
-
nleft
)
{
FT_ERROR
(
(
"
cff_charset_load
:
invalid
SID
range
trimmed
"
"
nleft
=
%
d
-
>
%
d
\
n
"
nleft
0xFFFFL
-
glyph_sid
)
)
;
nleft
=
(
FT_UInt
)
(
0xFFFFL
-
glyph_sid
)
;
}
for
(
i
=
0
;
j
<
num_glyphs
&
&
i
<
=
nleft
;
i
+
+
j
+
+
glyph_sid
+
+
)
charset
-
>
sids
[
j
]
=
glyph_sid
;
}
}
break
;
default
:
FT_ERROR
(
(
"
cff_charset_load
:
invalid
table
format
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
}
else
{
charset
-
>
offset
=
offset
;
switch
(
(
FT_UInt
)
offset
)
{
case
0
:
if
(
num_glyphs
>
229
)
{
FT_ERROR
(
(
"
cff_charset_load
:
implicit
charset
larger
than
\
n
"
"
predefined
charset
(
Adobe
ISO
-
Latin
)
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
if
(
FT_NEW_ARRAY
(
charset
-
>
sids
num_glyphs
)
)
goto
Exit
;
FT_ARRAY_COPY
(
charset
-
>
sids
cff_isoadobe_charset
num_glyphs
)
;
break
;
case
1
:
if
(
num_glyphs
>
166
)
{
FT_ERROR
(
(
"
cff_charset_load
:
implicit
charset
larger
than
\
n
"
"
predefined
charset
(
Adobe
Expert
)
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
if
(
FT_NEW_ARRAY
(
charset
-
>
sids
num_glyphs
)
)
goto
Exit
;
FT_ARRAY_COPY
(
charset
-
>
sids
cff_expert_charset
num_glyphs
)
;
break
;
case
2
:
if
(
num_glyphs
>
87
)
{
FT_ERROR
(
(
"
cff_charset_load
:
implicit
charset
larger
than
\
n
"
"
predefined
charset
(
Adobe
Expert
Subset
)
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
if
(
FT_NEW_ARRAY
(
charset
-
>
sids
num_glyphs
)
)
goto
Exit
;
FT_ARRAY_COPY
(
charset
-
>
sids
cff_expertsubset_charset
num_glyphs
)
;
break
;
default
:
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
}
if
(
invert
)
error
=
cff_charset_compute_cids
(
charset
num_glyphs
memory
)
;
Exit
:
if
(
error
)
{
FT_FREE
(
charset
-
>
sids
)
;
FT_FREE
(
charset
-
>
cids
)
;
charset
-
>
format
=
0
;
charset
-
>
offset
=
0
;
charset
-
>
sids
=
0
;
}
return
error
;
}
static
void
cff_vstore_done
(
CFF_VStoreRec
*
vstore
FT_Memory
memory
)
{
FT_UInt
i
;
if
(
vstore
-
>
varRegionList
)
{
for
(
i
=
0
;
i
<
vstore
-
>
regionCount
;
i
+
+
)
FT_FREE
(
vstore
-
>
varRegionList
[
i
]
.
axisList
)
;
}
FT_FREE
(
vstore
-
>
varRegionList
)
;
if
(
vstore
-
>
varData
)
{
for
(
i
=
0
;
i
<
vstore
-
>
dataCount
;
i
+
+
)
FT_FREE
(
vstore
-
>
varData
[
i
]
.
regionIndices
)
;
}
FT_FREE
(
vstore
-
>
varData
)
;
}
#
define
FT_fdot14ToFixed
(
x
)
(
(
FT_Fixed
)
(
(
FT_ULong
)
(
x
)
<
<
2
)
)
static
FT_Error
cff_vstore_load
(
CFF_VStoreRec
*
vstore
FT_Stream
stream
FT_ULong
base_offset
FT_ULong
offset
)
{
FT_Memory
memory
=
stream
-
>
memory
;
FT_Error
error
=
FT_ERR
(
Invalid_File_Format
)
;
FT_ULong
*
dataOffsetArray
=
NULL
;
FT_UInt
i
j
;
if
(
offset
)
{
FT_UInt
vsOffset
;
FT_UInt
format
;
FT_ULong
regionListOffset
;
if
(
FT_STREAM_SEEK
(
base_offset
+
offset
)
|
|
FT_STREAM_SKIP
(
2
)
)
goto
Exit
;
vsOffset
=
FT_STREAM_POS
(
)
;
if
(
FT_READ_USHORT
(
format
)
)
goto
Exit
;
if
(
format
!
=
1
)
{
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
if
(
FT_READ_ULONG
(
regionListOffset
)
|
|
FT_READ_USHORT
(
vstore
-
>
dataCount
)
)
goto
Exit
;
if
(
FT_NEW_ARRAY
(
dataOffsetArray
vstore
-
>
dataCount
)
)
goto
Exit
;
for
(
i
=
0
;
i
<
vstore
-
>
dataCount
;
i
+
+
)
{
if
(
FT_READ_ULONG
(
dataOffsetArray
[
i
]
)
)
goto
Exit
;
}
if
(
FT_STREAM_SEEK
(
vsOffset
+
regionListOffset
)
|
|
FT_READ_USHORT
(
vstore
-
>
axisCount
)
|
|
FT_READ_USHORT
(
vstore
-
>
regionCount
)
)
goto
Exit
;
if
(
FT_NEW_ARRAY
(
vstore
-
>
varRegionList
vstore
-
>
regionCount
)
)
goto
Exit
;
for
(
i
=
0
;
i
<
vstore
-
>
regionCount
;
i
+
+
)
{
CFF_VarRegion
*
region
=
&
vstore
-
>
varRegionList
[
i
]
;
if
(
FT_NEW_ARRAY
(
region
-
>
axisList
vstore
-
>
axisCount
)
)
goto
Exit
;
for
(
j
=
0
;
j
<
vstore
-
>
axisCount
;
j
+
+
)
{
CFF_AxisCoords
*
axis
=
&
region
-
>
axisList
[
j
]
;
FT_Int16
start14
peak14
end14
;
if
(
FT_READ_SHORT
(
start14
)
|
|
FT_READ_SHORT
(
peak14
)
|
|
FT_READ_SHORT
(
end14
)
)
goto
Exit
;
axis
-
>
startCoord
=
FT_fdot14ToFixed
(
start14
)
;
axis
-
>
peakCoord
=
FT_fdot14ToFixed
(
peak14
)
;
axis
-
>
endCoord
=
FT_fdot14ToFixed
(
end14
)
;
}
}
if
(
FT_NEW_ARRAY
(
vstore
-
>
varData
vstore
-
>
dataCount
)
)
goto
Exit
;
for
(
i
=
0
;
i
<
vstore
-
>
dataCount
;
i
+
+
)
{
CFF_VarData
*
data
=
&
vstore
-
>
varData
[
i
]
;
if
(
FT_STREAM_SEEK
(
vsOffset
+
dataOffsetArray
[
i
]
)
)
goto
Exit
;
if
(
FT_STREAM_SKIP
(
4
)
)
goto
Exit
;
if
(
FT_READ_USHORT
(
data
-
>
regionIdxCount
)
)
goto
Exit
;
if
(
FT_NEW_ARRAY
(
data
-
>
regionIndices
data
-
>
regionIdxCount
)
)
goto
Exit
;
for
(
j
=
0
;
j
<
data
-
>
regionIdxCount
;
j
+
+
)
{
if
(
FT_READ_USHORT
(
data
-
>
regionIndices
[
j
]
)
)
goto
Exit
;
}
}
}
error
=
FT_Err_Ok
;
Exit
:
FT_FREE
(
dataOffsetArray
)
;
if
(
error
)
cff_vstore_done
(
vstore
memory
)
;
return
error
;
}
FT_LOCAL_DEF
(
void
)
cff_blend_clear
(
CFF_SubFont
subFont
)
{
subFont
-
>
blend_top
=
subFont
-
>
blend_stack
;
subFont
-
>
blend_used
=
0
;
}
FT_LOCAL_DEF
(
FT_Error
)
cff_blend_doBlend
(
CFF_SubFont
subFont
CFF_Parser
parser
FT_UInt
numBlends
)
{
FT_UInt
delta
;
FT_UInt
base
;
FT_UInt
i
j
;
FT_UInt
size
;
CFF_Blend
blend
=
&
subFont
-
>
blend
;
FT_Memory
memory
=
subFont
-
>
blend
.
font
-
>
memory
;
FT_Error
error
=
FT_Err_Ok
;
FT_UInt
numOperands
=
(
FT_UInt
)
(
numBlends
*
blend
-
>
lenBV
)
;
FT_UInt
count
=
(
FT_UInt
)
(
parser
-
>
top
-
1
-
parser
-
>
stack
)
;
if
(
numOperands
>
count
)
{
FT_TRACE4
(
(
"
cff_blend_doBlend
:
Stack
underflow
%
d
argument
%
s
\
n
"
count
count
=
=
1
?
"
"
:
"
s
"
)
)
;
error
=
FT_THROW
(
Stack_Underflow
)
;
goto
Exit
;
}
size
=
5
*
numBlends
;
if
(
subFont
-
>
blend_used
+
size
>
subFont
-
>
blend_alloc
)
{
FT_Byte
*
blend_stack_old
=
subFont
-
>
blend_stack
;
FT_Byte
*
blend_top_old
=
subFont
-
>
blend_top
;
if
(
FT_REALLOC
(
subFont
-
>
blend_stack
subFont
-
>
blend_alloc
subFont
-
>
blend_alloc
+
size
)
)
goto
Exit
;
subFont
-
>
blend_top
=
subFont
-
>
blend_stack
+
subFont
-
>
blend_used
;
subFont
-
>
blend_alloc
+
=
size
;
if
(
blend_stack_old
&
&
subFont
-
>
blend_stack
!
=
blend_stack_old
)
{
FT_PtrDist
offset
=
subFont
-
>
blend_stack
-
blend_stack_old
;
FT_Byte
*
*
p
;
for
(
p
=
parser
-
>
stack
;
p
<
parser
-
>
top
;
p
+
+
)
{
if
(
*
p
>
=
blend_stack_old
&
&
*
p
<
blend_top_old
)
*
p
+
=
offset
;
}
}
}
subFont
-
>
blend_used
+
=
size
;
base
=
count
-
numOperands
;
delta
=
base
+
numBlends
;
for
(
i
=
0
;
i
<
numBlends
;
i
+
+
)
{
const
FT_Int32
*
weight
=
&
blend
-
>
BV
[
1
]
;
FT_UInt32
sum
;
sum
=
cff_parse_num
(
parser
&
parser
-
>
stack
[
i
+
base
]
)
*
0x10000
;
for
(
j
=
1
;
j
<
blend
-
>
lenBV
;
j
+
+
)
sum
+
=
cff_parse_num
(
parser
&
parser
-
>
stack
[
delta
+
+
]
)
*
*
weight
+
+
;
parser
-
>
stack
[
i
+
base
]
=
subFont
-
>
blend_top
;
*
subFont
-
>
blend_top
+
+
=
255
;
*
subFont
-
>
blend_top
+
+
=
(
FT_Byte
)
(
sum
>
>
24
)
;
*
subFont
-
>
blend_top
+
+
=
(
FT_Byte
)
(
sum
>
>
16
)
;
*
subFont
-
>
blend_top
+
+
=
(
FT_Byte
)
(
sum
>
>
8
)
;
*
subFont
-
>
blend_top
+
+
=
(
FT_Byte
)
sum
;
}
parser
-
>
top
=
&
parser
-
>
stack
[
base
+
numBlends
]
;
Exit
:
return
error
;
}
FT_LOCAL_DEF
(
FT_Error
)
cff_blend_build_vector
(
CFF_Blend
blend
FT_UInt
vsindex
FT_UInt
lenNDV
FT_Fixed
*
NDV
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_Memory
memory
=
blend
-
>
font
-
>
memory
;
FT_UInt
len
;
CFF_VStore
vs
;
CFF_VarData
*
varData
;
FT_UInt
master
;
FT_ASSERT
(
lenNDV
=
=
0
|
|
NDV
)
;
blend
-
>
builtBV
=
FALSE
;
vs
=
&
blend
-
>
font
-
>
vstore
;
if
(
lenNDV
!
=
0
&
&
lenNDV
!
=
vs
-
>
axisCount
)
{
FT_TRACE4
(
(
"
cff_blend_build_vector
:
Axis
count
mismatch
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
if
(
vsindex
>
=
vs
-
>
dataCount
)
{
FT_TRACE4
(
(
"
cff_blend_build_vector
:
vsindex
out
of
range
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
varData
=
&
vs
-
>
varData
[
vsindex
]
;
len
=
varData
-
>
regionIdxCount
+
1
;
if
(
FT_REALLOC
(
blend
-
>
BV
blend
-
>
lenBV
*
sizeof
(
*
blend
-
>
BV
)
len
*
sizeof
(
*
blend
-
>
BV
)
)
)
goto
Exit
;
blend
-
>
lenBV
=
len
;
for
(
master
=
0
;
master
<
len
;
master
+
+
)
{
FT_UInt
j
;
FT_UInt
idx
;
CFF_VarRegion
*
varRegion
;
if
(
master
=
=
0
)
{
blend
-
>
BV
[
master
]
=
FT_FIXED_ONE
;
FT_TRACE4
(
(
"
build
blend
vector
len
%
d
\
n
"
"
[
%
f
"
len
blend
-
>
BV
[
master
]
/
65536
.
0
)
)
;
continue
;
}
idx
=
varData
-
>
regionIndices
[
master
-
1
]
;
varRegion
=
&
vs
-
>
varRegionList
[
idx
]
;
if
(
idx
>
=
vs
-
>
regionCount
)
{
FT_TRACE4
(
(
"
cff_blend_build_vector
:
"
"
region
index
out
of
range
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
if
(
!
lenNDV
)
{
blend
-
>
BV
[
master
]
=
0
;
continue
;
}
blend
-
>
BV
[
master
]
=
FT_FIXED_ONE
;
for
(
j
=
0
;
j
<
lenNDV
;
j
+
+
)
{
CFF_AxisCoords
*
axis
=
&
varRegion
-
>
axisList
[
j
]
;
FT_Fixed
axisScalar
;
if
(
axis
-
>
startCoord
>
axis
-
>
peakCoord
|
|
axis
-
>
peakCoord
>
axis
-
>
endCoord
)
axisScalar
=
FT_FIXED_ONE
;
else
if
(
axis
-
>
startCoord
<
0
&
&
axis
-
>
endCoord
>
0
&
&
axis
-
>
peakCoord
!
=
0
)
axisScalar
=
FT_FIXED_ONE
;
else
if
(
axis
-
>
peakCoord
=
=
0
)
axisScalar
=
FT_FIXED_ONE
;
else
if
(
NDV
[
j
]
<
axis
-
>
startCoord
|
|
NDV
[
j
]
>
axis
-
>
endCoord
)
axisScalar
=
0
;
else
{
if
(
NDV
[
j
]
=
=
axis
-
>
peakCoord
)
axisScalar
=
FT_FIXED_ONE
;
else
if
(
NDV
[
j
]
<
axis
-
>
peakCoord
)
axisScalar
=
FT_DivFix
(
NDV
[
j
]
-
axis
-
>
startCoord
axis
-
>
peakCoord
-
axis
-
>
startCoord
)
;
else
axisScalar
=
FT_DivFix
(
axis
-
>
endCoord
-
NDV
[
j
]
axis
-
>
endCoord
-
axis
-
>
peakCoord
)
;
}
blend
-
>
BV
[
master
]
=
FT_MulFix
(
blend
-
>
BV
[
master
]
axisScalar
)
;
}
FT_TRACE4
(
(
"
%
f
"
blend
-
>
BV
[
master
]
/
65536
.
0
)
)
;
}
FT_TRACE4
(
(
"
]
\
n
"
)
)
;
blend
-
>
lastVsindex
=
vsindex
;
if
(
lenNDV
!
=
0
)
{
if
(
FT_REALLOC
(
blend
-
>
lastNDV
blend
-
>
lenNDV
*
sizeof
(
*
NDV
)
lenNDV
*
sizeof
(
*
NDV
)
)
)
goto
Exit
;
FT_MEM_COPY
(
blend
-
>
lastNDV
NDV
lenNDV
*
sizeof
(
*
NDV
)
)
;
}
blend
-
>
lenNDV
=
lenNDV
;
blend
-
>
builtBV
=
TRUE
;
Exit
:
return
error
;
}
FT_LOCAL_DEF
(
FT_Bool
)
cff_blend_check_vector
(
CFF_Blend
blend
FT_UInt
vsindex
FT_UInt
lenNDV
FT_Fixed
*
NDV
)
{
if
(
!
blend
-
>
builtBV
|
|
blend
-
>
lastVsindex
!
=
vsindex
|
|
blend
-
>
lenNDV
!
=
lenNDV
|
|
(
lenNDV
&
&
ft_memcmp
(
NDV
blend
-
>
lastNDV
lenNDV
*
sizeof
(
*
NDV
)
)
!
=
0
)
)
{
return
TRUE
;
}
return
FALSE
;
}
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
FT_LOCAL_DEF
(
FT_Error
)
cff_get_var_blend
(
CFF_Face
face
FT_UInt
*
num_coords
FT_Fixed
*
*
coords
FT_Fixed
*
*
normalizedcoords
FT_MM_Var
*
*
mm_var
)
{
FT_Service_MultiMasters
mm
=
(
FT_Service_MultiMasters
)
face
-
>
mm
;
return
mm
-
>
get_var_blend
(
FT_FACE
(
face
)
num_coords
coords
normalizedcoords
mm_var
)
;
}
FT_LOCAL_DEF
(
void
)
cff_done_blend
(
CFF_Face
face
)
{
FT_Service_MultiMasters
mm
=
(
FT_Service_MultiMasters
)
face
-
>
mm
;
if
(
mm
)
mm
-
>
done_blend
(
FT_FACE
(
face
)
)
;
}
#
endif
static
void
cff_encoding_done
(
CFF_Encoding
encoding
)
{
encoding
-
>
format
=
0
;
encoding
-
>
offset
=
0
;
encoding
-
>
count
=
0
;
}
static
FT_Error
cff_encoding_load
(
CFF_Encoding
encoding
CFF_Charset
charset
FT_UInt
num_glyphs
FT_Stream
stream
FT_ULong
base_offset
FT_ULong
offset
)
{
FT_Error
error
=
FT_Err_Ok
;
FT_UInt
count
;
FT_UInt
j
;
FT_UShort
glyph_sid
;
FT_UInt
glyph_code
;
if
(
!
charset
-
>
sids
)
{
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
for
(
j
=
0
;
j
<
256
;
j
+
+
)
{
encoding
-
>
sids
[
j
]
=
0
;
encoding
-
>
codes
[
j
]
=
0
;
}
if
(
offset
>
1
)
{
encoding
-
>
offset
=
base_offset
+
offset
;
if
(
FT_STREAM_SEEK
(
encoding
-
>
offset
)
|
|
FT_READ_BYTE
(
encoding
-
>
format
)
|
|
FT_READ_BYTE
(
count
)
)
goto
Exit
;
switch
(
encoding
-
>
format
&
0x7F
)
{
case
0
:
{
FT_Byte
*
p
;
encoding
-
>
count
=
count
+
1
;
if
(
FT_FRAME_ENTER
(
count
)
)
goto
Exit
;
p
=
(
FT_Byte
*
)
stream
-
>
cursor
;
for
(
j
=
1
;
j
<
=
count
;
j
+
+
)
{
glyph_code
=
*
p
+
+
;
if
(
j
<
num_glyphs
)
{
encoding
-
>
codes
[
glyph_code
]
=
(
FT_UShort
)
j
;
encoding
-
>
sids
[
glyph_code
]
=
charset
-
>
sids
[
j
]
;
}
}
FT_FRAME_EXIT
(
)
;
}
break
;
case
1
:
{
FT_UInt
nleft
;
FT_UInt
i
=
1
;
FT_UInt
k
;
encoding
-
>
count
=
0
;
for
(
j
=
0
;
j
<
count
;
j
+
+
i
+
=
nleft
)
{
if
(
FT_READ_BYTE
(
glyph_code
)
)
goto
Exit
;
if
(
FT_READ_BYTE
(
nleft
)
)
goto
Exit
;
nleft
+
+
;
if
(
(
FT_UInt
)
nleft
>
encoding
-
>
count
)
encoding
-
>
count
=
nleft
;
for
(
k
=
i
;
k
<
nleft
+
i
;
k
+
+
glyph_code
+
+
)
{
if
(
k
<
num_glyphs
&
&
glyph_code
<
256
)
{
encoding
-
>
codes
[
glyph_code
]
=
(
FT_UShort
)
k
;
encoding
-
>
sids
[
glyph_code
]
=
charset
-
>
sids
[
k
]
;
}
}
}
if
(
encoding
-
>
count
>
256
)
encoding
-
>
count
=
256
;
}
break
;
default
:
FT_ERROR
(
(
"
cff_encoding_load
:
invalid
table
format
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
if
(
encoding
-
>
format
&
0x80
)
{
FT_UInt
gindex
;
if
(
FT_READ_BYTE
(
count
)
)
goto
Exit
;
for
(
j
=
0
;
j
<
count
;
j
+
+
)
{
if
(
FT_READ_BYTE
(
glyph_code
)
)
goto
Exit
;
if
(
FT_READ_USHORT
(
glyph_sid
)
)
goto
Exit
;
encoding
-
>
sids
[
glyph_code
]
=
glyph_sid
;
for
(
gindex
=
0
;
gindex
<
num_glyphs
;
gindex
+
+
)
{
if
(
charset
-
>
sids
[
gindex
]
=
=
glyph_sid
)
{
encoding
-
>
codes
[
glyph_code
]
=
(
FT_UShort
)
gindex
;
break
;
}
}
}
}
}
else
{
switch
(
(
FT_UInt
)
offset
)
{
case
0
:
FT_ARRAY_COPY
(
encoding
-
>
sids
cff_standard_encoding
256
)
;
goto
Populate
;
case
1
:
FT_ARRAY_COPY
(
encoding
-
>
sids
cff_expert_encoding
256
)
;
Populate
:
encoding
-
>
count
=
0
;
error
=
cff_charset_compute_cids
(
charset
num_glyphs
stream
-
>
memory
)
;
if
(
error
)
goto
Exit
;
for
(
j
=
0
;
j
<
256
;
j
+
+
)
{
FT_UInt
sid
=
encoding
-
>
sids
[
j
]
;
FT_UInt
gid
=
0
;
if
(
sid
)
gid
=
cff_charset_cid_to_gindex
(
charset
sid
)
;
if
(
gid
!
=
0
)
{
encoding
-
>
codes
[
j
]
=
(
FT_UShort
)
gid
;
encoding
-
>
count
=
j
+
1
;
}
else
{
encoding
-
>
codes
[
j
]
=
0
;
encoding
-
>
sids
[
j
]
=
0
;
}
}
break
;
default
:
FT_ERROR
(
(
"
cff_encoding_load
:
invalid
table
format
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
}
Exit
:
return
error
;
}
FT_LOCAL_DEF
(
FT_Error
)
cff_load_private_dict
(
CFF_Font
font
CFF_SubFont
subfont
FT_UInt
lenNDV
FT_Fixed
*
NDV
)
{
FT_Error
error
=
FT_Err_Ok
;
CFF_ParserRec
parser
;
CFF_FontRecDict
top
=
&
subfont
-
>
font_dict
;
CFF_Private
priv
=
&
subfont
-
>
private_dict
;
FT_Stream
stream
=
font
-
>
stream
;
FT_UInt
stackSize
;
subfont
-
>
blend
.
font
=
font
;
subfont
-
>
blend
.
usedBV
=
FALSE
;
if
(
!
top
-
>
private_offset
|
|
!
top
-
>
private_size
)
goto
Exit2
;
FT_ZERO
(
priv
)
;
priv
-
>
blue_shift
=
7
;
priv
-
>
blue_fuzz
=
1
;
priv
-
>
lenIV
=
-
1
;
priv
-
>
expansion_factor
=
(
FT_Fixed
)
(
0
.
06
*
0x10000L
)
;
priv
-
>
blue_scale
=
(
FT_Fixed
)
(
0
.
039625
*
0x10000L
*
1000
)
;
priv
-
>
subfont
=
subfont
;
subfont
-
>
lenNDV
=
lenNDV
;
subfont
-
>
NDV
=
NDV
;
stackSize
=
font
-
>
cff2
?
font
-
>
top_font
.
font_dict
.
maxstack
+
1
:
CFF_MAX_STACK_DEPTH
+
1
;
if
(
cff_parser_init
(
&
parser
font
-
>
cff2
?
CFF2_CODE_PRIVATE
:
CFF_CODE_PRIVATE
priv
font
-
>
library
stackSize
top
-
>
num_designs
top
-
>
num_axes
)
)
goto
Exit
;
if
(
FT_STREAM_SEEK
(
font
-
>
base_offset
+
top
-
>
private_offset
)
|
|
FT_FRAME_ENTER
(
top
-
>
private_size
)
)
goto
Exit
;
FT_TRACE4
(
(
"
private
dictionary
:
\
n
"
)
)
;
error
=
cff_parser_run
(
&
parser
(
FT_Byte
*
)
stream
-
>
cursor
(
FT_Byte
*
)
stream
-
>
limit
)
;
FT_FRAME_EXIT
(
)
;
if
(
error
)
goto
Exit
;
priv
-
>
num_blue_values
&
=
~
1
;
if
(
priv
-
>
initial_random_seed
<
0
)
priv
-
>
initial_random_seed
=
-
priv
-
>
initial_random_seed
;
else
if
(
priv
-
>
initial_random_seed
=
=
0
)
priv
-
>
initial_random_seed
=
987654321
;
Exit
:
cff_blend_clear
(
subfont
)
;
cff_parser_done
(
&
parser
)
;
Exit2
:
return
error
;
}
static
FT_Error
cff_subfont_load
(
CFF_SubFont
subfont
CFF_Index
idx
FT_UInt
font_index
FT_Stream
stream
FT_ULong
base_offset
FT_UInt
code
CFF_Font
font
CFF_Face
face
)
{
FT_Error
error
;
CFF_ParserRec
parser
;
FT_Byte
*
dict
=
NULL
;
FT_ULong
dict_len
;
CFF_FontRecDict
top
=
&
subfont
-
>
font_dict
;
CFF_Private
priv
=
&
subfont
-
>
private_dict
;
PSAux_Service
psaux
=
(
PSAux_Service
)
face
-
>
psaux
;
FT_Bool
cff2
=
FT_BOOL
(
code
=
=
CFF2_CODE_TOPDICT
|
|
code
=
=
CFF2_CODE_FONTDICT
)
;
FT_UInt
stackSize
=
cff2
?
CFF2_DEFAULT_STACK
:
CFF_MAX_STACK_DEPTH
;
error
=
cff_parser_init
(
&
parser
code
&
subfont
-
>
font_dict
font
-
>
library
stackSize
0
0
)
;
if
(
error
)
goto
Exit
;
FT_ZERO
(
top
)
;
top
-
>
underline_position
=
-
(
100L
<
<
16
)
;
top
-
>
underline_thickness
=
50L
<
<
16
;
top
-
>
charstring_type
=
2
;
top
-
>
font_matrix
.
xx
=
0x10000L
;
top
-
>
font_matrix
.
yy
=
0x10000L
;
top
-
>
cid_count
=
8720
;
top
-
>
version
=
0xFFFFU
;
top
-
>
notice
=
0xFFFFU
;
top
-
>
copyright
=
0xFFFFU
;
top
-
>
full_name
=
0xFFFFU
;
top
-
>
family_name
=
0xFFFFU
;
top
-
>
weight
=
0xFFFFU
;
top
-
>
embedded_postscript
=
0xFFFFU
;
top
-
>
cid_registry
=
0xFFFFU
;
top
-
>
cid_ordering
=
0xFFFFU
;
top
-
>
cid_font_name
=
0xFFFFU
;
top
-
>
maxstack
=
cff2
?
CFF2_DEFAULT_STACK
:
48
;
if
(
idx
-
>
count
)
error
=
cff_index_access_element
(
idx
font_index
&
dict
&
dict_len
)
;
else
{
if
(
FT_STREAM_SEEK
(
idx
-
>
data_offset
)
|
|
FT_FRAME_EXTRACT
(
idx
-
>
data_size
dict
)
)
goto
Exit
;
dict_len
=
idx
-
>
data_size
;
}
if
(
!
error
)
{
FT_TRACE4
(
(
"
top
dictionary
:
\
n
"
)
)
;
error
=
cff_parser_run
(
&
parser
dict
dict
+
dict_len
)
;
}
if
(
idx
-
>
count
)
cff_index_forget_element
(
idx
&
dict
)
;
else
FT_FRAME_RELEASE
(
dict
)
;
if
(
error
)
goto
Exit
;
if
(
top
-
>
cid_registry
!
=
0xFFFFU
)
goto
Exit
;
error
=
cff_load_private_dict
(
font
subfont
0
0
)
;
if
(
error
)
goto
Exit
;
if
(
!
cff2
)
{
if
(
face
-
>
root
.
internal
-
>
random_seed
=
=
-
1
)
{
PS_Driver
driver
=
(
PS_Driver
)
FT_FACE_DRIVER
(
face
)
;
subfont
-
>
random
=
(
FT_UInt32
)
driver
-
>
random_seed
;
if
(
driver
-
>
random_seed
)
{
do
{
driver
-
>
random_seed
=
(
FT_Int32
)
psaux
-
>
cff_random
(
(
FT_UInt32
)
driver
-
>
random_seed
)
;
}
while
(
driver
-
>
random_seed
<
0
)
;
}
}
else
{
subfont
-
>
random
=
(
FT_UInt32
)
face
-
>
root
.
internal
-
>
random_seed
;
if
(
face
-
>
root
.
internal
-
>
random_seed
)
{
do
{
face
-
>
root
.
internal
-
>
random_seed
=
(
FT_Int32
)
psaux
-
>
cff_random
(
(
FT_UInt32
)
face
-
>
root
.
internal
-
>
random_seed
)
;
}
while
(
face
-
>
root
.
internal
-
>
random_seed
<
0
)
;
}
}
if
(
!
subfont
-
>
random
)
subfont
-
>
random
=
(
FT_UInt32
)
priv
-
>
initial_random_seed
;
}
if
(
priv
-
>
local_subrs_offset
)
{
if
(
FT_STREAM_SEEK
(
base_offset
+
top
-
>
private_offset
+
priv
-
>
local_subrs_offset
)
)
goto
Exit
;
error
=
cff_index_init
(
&
subfont
-
>
local_subrs_index
stream
1
cff2
)
;
if
(
error
)
goto
Exit
;
error
=
cff_index_get_pointers
(
&
subfont
-
>
local_subrs_index
&
subfont
-
>
local_subrs
NULL
NULL
)
;
if
(
error
)
goto
Exit
;
}
Exit
:
cff_parser_done
(
&
parser
)
;
return
error
;
}
static
void
cff_subfont_done
(
FT_Memory
memory
CFF_SubFont
subfont
)
{
if
(
subfont
)
{
cff_index_done
(
&
subfont
-
>
local_subrs_index
)
;
FT_FREE
(
subfont
-
>
local_subrs
)
;
FT_FREE
(
subfont
-
>
blend
.
lastNDV
)
;
FT_FREE
(
subfont
-
>
blend
.
BV
)
;
FT_FREE
(
subfont
-
>
blend_stack
)
;
}
}
FT_LOCAL_DEF
(
FT_Error
)
cff_font_load
(
FT_Library
library
FT_Stream
stream
FT_Int
face_index
CFF_Font
font
CFF_Face
face
FT_Bool
pure_cff
FT_Bool
cff2
)
{
static
const
FT_Frame_Field
cff_header_fields
[
]
=
{
#
undef
FT_STRUCTURE
#
define
FT_STRUCTURE
CFF_FontRec
FT_FRAME_START
(
3
)
FT_FRAME_BYTE
(
version_major
)
FT_FRAME_BYTE
(
version_minor
)
FT_FRAME_BYTE
(
header_size
)
FT_FRAME_END
}
;
FT_Error
error
;
FT_Memory
memory
=
stream
-
>
memory
;
FT_ULong
base_offset
;
CFF_FontRecDict
dict
;
CFF_IndexRec
string_index
;
FT_UInt
subfont_index
;
FT_ZERO
(
font
)
;
FT_ZERO
(
&
string_index
)
;
dict
=
&
font
-
>
top_font
.
font_dict
;
base_offset
=
FT_STREAM_POS
(
)
;
font
-
>
library
=
library
;
font
-
>
stream
=
stream
;
font
-
>
memory
=
memory
;
font
-
>
cff2
=
cff2
;
font
-
>
base_offset
=
base_offset
;
if
(
FT_STREAM_READ_FIELDS
(
cff_header_fields
font
)
)
goto
Exit
;
if
(
cff2
)
{
if
(
font
-
>
version_major
!
=
2
|
|
font
-
>
header_size
<
5
)
{
FT_TRACE2
(
(
"
not
a
CFF2
font
header
\
n
"
)
)
;
error
=
FT_THROW
(
Unknown_File_Format
)
;
goto
Exit
;
}
if
(
FT_READ_USHORT
(
font
-
>
top_dict_length
)
)
goto
Exit
;
}
else
{
FT_Byte
absolute_offset
;
if
(
FT_READ_BYTE
(
absolute_offset
)
)
goto
Exit
;
if
(
font
-
>
version_major
!
=
1
|
|
font
-
>
header_size
<
4
|
|
absolute_offset
>
4
)
{
FT_TRACE2
(
(
"
not
a
CFF
font
header
\
n
"
)
)
;
error
=
FT_THROW
(
Unknown_File_Format
)
;
goto
Exit
;
}
}
if
(
FT_STREAM_SEEK
(
base_offset
+
font
-
>
header_size
)
)
{
if
(
pure_cff
)
{
FT_TRACE2
(
(
"
not
a
CFF
file
\
n
"
)
)
;
error
=
FT_THROW
(
Unknown_File_Format
)
;
}
goto
Exit
;
}
if
(
cff2
)
{
FT_ZERO
(
&
font
-
>
font_dict_index
)
;
font
-
>
font_dict_index
.
data_offset
=
FT_STREAM_POS
(
)
;
font
-
>
font_dict_index
.
data_size
=
font
-
>
top_dict_length
;
if
(
FT_STREAM_SKIP
(
font
-
>
top_dict_length
)
)
goto
Exit
;
if
(
FT_SET_ERROR
(
cff_index_init
(
&
font
-
>
global_subrs_index
stream
1
cff2
)
)
)
goto
Exit
;
}
else
{
if
(
FT_SET_ERROR
(
cff_index_init
(
&
font
-
>
name_index
stream
0
cff2
)
)
)
{
if
(
pure_cff
)
{
FT_TRACE2
(
(
"
not
a
CFF
file
\
n
"
)
)
;
error
=
FT_THROW
(
Unknown_File_Format
)
;
}
goto
Exit
;
}
if
(
font
-
>
name_index
.
count
>
1
&
&
font
-
>
name_index
.
data_size
<
font
-
>
name_index
.
count
)
{
error
=
pure_cff
?
FT_THROW
(
Unknown_File_Format
)
:
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
if
(
FT_SET_ERROR
(
cff_index_init
(
&
font
-
>
font_dict_index
stream
0
cff2
)
)
|
|
FT_SET_ERROR
(
cff_index_init
(
&
string_index
stream
1
cff2
)
)
|
|
FT_SET_ERROR
(
cff_index_init
(
&
font
-
>
global_subrs_index
stream
1
cff2
)
)
|
|
FT_SET_ERROR
(
cff_index_get_pointers
(
&
string_index
&
font
-
>
strings
&
font
-
>
string_pool
&
font
-
>
string_pool_size
)
)
)
goto
Exit
;
if
(
font
-
>
name_index
.
count
>
font
-
>
font_dict_index
.
count
)
{
FT_ERROR
(
(
"
cff_font_load
:
"
"
not
enough
entries
in
Top
DICT
index
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
}
font
-
>
num_strings
=
string_index
.
count
;
if
(
pure_cff
)
{
subfont_index
=
(
FT_UInt
)
(
face_index
&
0xFFFF
)
;
if
(
face_index
>
0
&
&
subfont_index
>
=
font
-
>
name_index
.
count
)
{
FT_ERROR
(
(
"
cff_font_load
:
"
"
invalid
subfont
index
for
pure
CFF
font
(
%
d
)
\
n
"
subfont_index
)
)
;
error
=
FT_THROW
(
Invalid_Argument
)
;
goto
Exit
;
}
font
-
>
num_faces
=
font
-
>
name_index
.
count
;
}
else
{
subfont_index
=
0
;
if
(
font
-
>
name_index
.
count
>
1
)
{
FT_ERROR
(
(
"
cff_font_load
:
"
"
invalid
CFF
font
with
multiple
subfonts
\
n
"
"
"
"
in
SFNT
wrapper
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
}
if
(
face_index
<
0
)
goto
Exit
;
FT_TRACE4
(
(
"
parsing
top
-
level
\
n
"
)
)
;
error
=
cff_subfont_load
(
&
font
-
>
top_font
&
font
-
>
font_dict_index
subfont_index
stream
base_offset
cff2
?
CFF2_CODE_TOPDICT
:
CFF_CODE_TOPDICT
font
face
)
;
if
(
error
)
goto
Exit
;
if
(
FT_STREAM_SEEK
(
base_offset
+
dict
-
>
charstrings_offset
)
)
goto
Exit
;
error
=
cff_index_init
(
&
font
-
>
charstrings_index
stream
0
cff2
)
;
if
(
error
)
goto
Exit
;
if
(
dict
-
>
cid_registry
!
=
0xFFFFU
|
|
cff2
)
{
CFF_IndexRec
fd_index
;
CFF_SubFont
sub
=
NULL
;
FT_UInt
idx
;
error
=
cff_vstore_load
(
&
font
-
>
vstore
stream
base_offset
dict
-
>
vstore_offset
)
;
if
(
error
)
goto
Exit
;
if
(
FT_STREAM_SEEK
(
base_offset
+
dict
-
>
cid_fd_array_offset
)
)
goto
Exit
;
error
=
cff_index_init
(
&
fd_index
stream
0
cff2
)
;
if
(
error
)
goto
Exit
;
if
(
fd_index
.
count
>
CFF_MAX_CID_FONTS
)
{
FT_TRACE0
(
(
"
cff_font_load
:
FD
array
too
large
in
CID
font
\
n
"
)
)
;
goto
Fail_CID
;
}
font
-
>
num_subfonts
=
fd_index
.
count
;
if
(
FT_NEW_ARRAY
(
sub
fd_index
.
count
)
)
goto
Fail_CID
;
for
(
idx
=
0
;
idx
<
fd_index
.
count
;
idx
+
+
)
font
-
>
subfonts
[
idx
]
=
sub
+
idx
;
for
(
idx
=
0
;
idx
<
fd_index
.
count
;
idx
+
+
)
{
sub
=
font
-
>
subfonts
[
idx
]
;
FT_TRACE4
(
(
"
parsing
subfont
%
u
\
n
"
idx
)
)
;
error
=
cff_subfont_load
(
sub
&
fd_index
idx
stream
base_offset
cff2
?
CFF2_CODE_FONTDICT
:
CFF_CODE_TOPDICT
font
face
)
;
if
(
error
)
goto
Fail_CID
;
}
if
(
!
cff2
|
|
fd_index
.
count
>
1
)
error
=
CFF_Load_FD_Select
(
&
font
-
>
fd_select
font
-
>
charstrings_index
.
count
stream
base_offset
+
dict
-
>
cid_fd_select_offset
)
;
Fail_CID
:
cff_index_done
(
&
fd_index
)
;
if
(
error
)
goto
Exit
;
}
else
font
-
>
num_subfonts
=
0
;
if
(
dict
-
>
charstrings_offset
=
=
0
)
{
FT_ERROR
(
(
"
cff_font_load
:
no
charstrings
offset
\
n
"
)
)
;
error
=
FT_THROW
(
Invalid_File_Format
)
;
goto
Exit
;
}
font
-
>
num_glyphs
=
font
-
>
charstrings_index
.
count
;
error
=
cff_index_get_pointers
(
&
font
-
>
global_subrs_index
&
font
-
>
global_subrs
NULL
NULL
)
;
if
(
error
)
goto
Exit
;
if
(
!
cff2
&
&
font
-
>
num_glyphs
>
0
)
{
FT_Bool
invert
=
FT_BOOL
(
dict
-
>
cid_registry
!
=
0xFFFFU
&
&
pure_cff
)
;
error
=
cff_charset_load
(
&
font
-
>
charset
font
-
>
num_glyphs
stream
base_offset
dict
-
>
charset_offset
invert
)
;
if
(
error
)
goto
Exit
;
if
(
dict
-
>
cid_registry
=
=
0xFFFFU
)
{
error
=
cff_encoding_load
(
&
font
-
>
encoding
&
font
-
>
charset
font
-
>
num_glyphs
stream
base_offset
dict
-
>
encoding_offset
)
;
if
(
error
)
goto
Exit
;
}
}
font
-
>
font_name
=
cff_index_get_name
(
font
subfont_index
)
;
Exit
:
cff_index_done
(
&
string_index
)
;
return
error
;
}
FT_LOCAL_DEF
(
void
)
cff_font_done
(
CFF_Font
font
)
{
FT_Memory
memory
=
font
-
>
memory
;
FT_UInt
idx
;
cff_index_done
(
&
font
-
>
global_subrs_index
)
;
cff_index_done
(
&
font
-
>
font_dict_index
)
;
cff_index_done
(
&
font
-
>
name_index
)
;
cff_index_done
(
&
font
-
>
charstrings_index
)
;
if
(
font
-
>
num_subfonts
>
0
)
{
for
(
idx
=
0
;
idx
<
font
-
>
num_subfonts
;
idx
+
+
)
cff_subfont_done
(
memory
font
-
>
subfonts
[
idx
]
)
;
FT_FREE
(
font
-
>
subfonts
[
0
]
)
;
}
cff_encoding_done
(
&
font
-
>
encoding
)
;
cff_charset_done
(
&
font
-
>
charset
font
-
>
stream
)
;
cff_vstore_done
(
&
font
-
>
vstore
memory
)
;
cff_subfont_done
(
memory
&
font
-
>
top_font
)
;
CFF_Done_FD_Select
(
&
font
-
>
fd_select
font
-
>
stream
)
;
FT_FREE
(
font
-
>
font_info
)
;
FT_FREE
(
font
-
>
font_name
)
;
FT_FREE
(
font
-
>
global_subrs
)
;
FT_FREE
(
font
-
>
strings
)
;
FT_FREE
(
font
-
>
string_pool
)
;
if
(
font
-
>
cf2_instance
.
finalizer
)
{
font
-
>
cf2_instance
.
finalizer
(
font
-
>
cf2_instance
.
data
)
;
FT_FREE
(
font
-
>
cf2_instance
.
data
)
;
}
FT_FREE
(
font
-
>
font_extra
)
;
}
