#
include
<
freetype
/
internal
/
ftdebug
.
h
>
#
include
<
freetype
/
internal
/
ftcalc
.
h
>
#
include
<
freetype
/
internal
/
ftstream
.
h
>
#
include
<
freetype
/
fterrors
.
h
>
#
include
<
freetype
/
ttnameid
.
h
>
#
include
<
freetype
/
tttags
.
h
>
#
include
<
freetype
/
internal
/
sfnt
.
h
>
#
include
<
freetype
/
ftdriver
.
h
>
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
#
include
<
freetype
/
ftmm
.
h
>
#
include
<
freetype
/
internal
/
services
/
svmm
.
h
>
#
include
<
freetype
/
internal
/
services
/
svmetric
.
h
>
#
endif
#
include
<
freetype
/
internal
/
cffotypes
.
h
>
#
include
"
cffobjs
.
h
"
#
include
"
cffload
.
h
"
#
include
"
cffcmap
.
h
"
#
include
"
cfferrs
.
h
"
#
include
<
freetype
/
internal
/
psaux
.
h
>
#
include
<
freetype
/
internal
/
services
/
svcfftl
.
h
>
#
define
CFF_fixedToInt
(
x
)
\
(
(
FT_Short
)
(
(
(
x
)
+
0x8000U
)
>
>
16
)
)
#
undef
FT_COMPONENT
#
define
FT_COMPONENT
cffobjs
static
PSH_Globals_Funcs
cff_size_get_globals_funcs
(
CFF_Size
size
)
{
CFF_Face
face
=
(
CFF_Face
)
size
-
>
root
.
face
;
CFF_Font
font
=
(
CFF_Font
)
face
-
>
extra
.
data
;
PSHinter_Service
pshinter
=
font
-
>
pshinter
;
FT_Module
module
;
module
=
FT_Get_Module
(
font
-
>
library
"
pshinter
"
)
;
return
(
module
&
&
pshinter
&
&
pshinter
-
>
get_globals_funcs
)
?
pshinter
-
>
get_globals_funcs
(
module
)
:
0
;
}
FT_LOCAL_DEF
(
void
)
cff_size_done
(
FT_Size
cffsize
)
{
FT_Memory
memory
=
cffsize
-
>
face
-
>
memory
;
CFF_Size
size
=
(
CFF_Size
)
cffsize
;
CFF_Face
face
=
(
CFF_Face
)
size
-
>
root
.
face
;
CFF_Font
font
=
(
CFF_Font
)
face
-
>
extra
.
data
;
CFF_Internal
internal
=
(
CFF_Internal
)
cffsize
-
>
internal
-
>
module_data
;
if
(
internal
)
{
PSH_Globals_Funcs
funcs
;
funcs
=
cff_size_get_globals_funcs
(
size
)
;
if
(
funcs
)
{
FT_UInt
i
;
funcs
-
>
destroy
(
internal
-
>
topfont
)
;
for
(
i
=
font
-
>
num_subfonts
;
i
>
0
;
i
-
-
)
funcs
-
>
destroy
(
internal
-
>
subfonts
[
i
-
1
]
)
;
}
FT_FREE
(
internal
)
;
}
}
static
void
cff_make_private_dict
(
CFF_SubFont
subfont
PS_Private
priv
)
{
CFF_Private
cpriv
=
&
subfont
-
>
private_dict
;
FT_UInt
n
count
;
FT_ZERO
(
priv
)
;
count
=
priv
-
>
num_blue_values
=
cpriv
-
>
num_blue_values
;
for
(
n
=
0
;
n
<
count
;
n
+
+
)
priv
-
>
blue_values
[
n
]
=
CFF_fixedToInt
(
cpriv
-
>
blue_values
[
n
]
)
;
count
=
priv
-
>
num_other_blues
=
cpriv
-
>
num_other_blues
;
for
(
n
=
0
;
n
<
count
;
n
+
+
)
priv
-
>
other_blues
[
n
]
=
CFF_fixedToInt
(
cpriv
-
>
other_blues
[
n
]
)
;
count
=
priv
-
>
num_family_blues
=
cpriv
-
>
num_family_blues
;
for
(
n
=
0
;
n
<
count
;
n
+
+
)
priv
-
>
family_blues
[
n
]
=
CFF_fixedToInt
(
cpriv
-
>
family_blues
[
n
]
)
;
count
=
priv
-
>
num_family_other_blues
=
cpriv
-
>
num_family_other_blues
;
for
(
n
=
0
;
n
<
count
;
n
+
+
)
priv
-
>
family_other_blues
[
n
]
=
CFF_fixedToInt
(
cpriv
-
>
family_other_blues
[
n
]
)
;
priv
-
>
blue_scale
=
cpriv
-
>
blue_scale
;
priv
-
>
blue_shift
=
(
FT_Int
)
cpriv
-
>
blue_shift
;
priv
-
>
blue_fuzz
=
(
FT_Int
)
cpriv
-
>
blue_fuzz
;
priv
-
>
standard_width
[
0
]
=
(
FT_UShort
)
cpriv
-
>
standard_width
;
priv
-
>
standard_height
[
0
]
=
(
FT_UShort
)
cpriv
-
>
standard_height
;
count
=
priv
-
>
num_snap_widths
=
cpriv
-
>
num_snap_widths
;
for
(
n
=
0
;
n
<
count
;
n
+
+
)
priv
-
>
snap_widths
[
n
]
=
(
FT_Short
)
cpriv
-
>
snap_widths
[
n
]
;
count
=
priv
-
>
num_snap_heights
=
cpriv
-
>
num_snap_heights
;
for
(
n
=
0
;
n
<
count
;
n
+
+
)
priv
-
>
snap_heights
[
n
]
=
(
FT_Short
)
cpriv
-
>
snap_heights
[
n
]
;
priv
-
>
force_bold
=
cpriv
-
>
force_bold
;
priv
-
>
language_group
=
cpriv
-
>
language_group
;
priv
-
>
lenIV
=
cpriv
-
>
lenIV
;
}
FT_LOCAL_DEF
(
FT_Error
)
cff_size_init
(
FT_Size
cffsize
)
{
CFF_Size
size
=
(
CFF_Size
)
cffsize
;
FT_Error
error
=
FT_Err_Ok
;
PSH_Globals_Funcs
funcs
=
cff_size_get_globals_funcs
(
size
)
;
FT_Memory
memory
=
cffsize
-
>
face
-
>
memory
;
CFF_Internal
internal
=
NULL
;
CFF_Face
face
=
(
CFF_Face
)
cffsize
-
>
face
;
CFF_Font
font
=
(
CFF_Font
)
face
-
>
extra
.
data
;
PS_PrivateRec
priv
;
FT_UInt
i
;
if
(
!
funcs
)
goto
Exit
;
if
(
FT_NEW
(
internal
)
)
goto
Exit
;
cff_make_private_dict
(
&
font
-
>
top_font
&
priv
)
;
error
=
funcs
-
>
create
(
memory
&
priv
&
internal
-
>
topfont
)
;
if
(
error
)
goto
Exit
;
for
(
i
=
font
-
>
num_subfonts
;
i
>
0
;
i
-
-
)
{
CFF_SubFont
sub
=
font
-
>
subfonts
[
i
-
1
]
;
cff_make_private_dict
(
sub
&
priv
)
;
error
=
funcs
-
>
create
(
memory
&
priv
&
internal
-
>
subfonts
[
i
-
1
]
)
;
if
(
error
)
goto
Exit
;
}
cffsize
-
>
internal
-
>
module_data
=
internal
;
size
-
>
strike_index
=
0xFFFFFFFFUL
;
Exit
:
if
(
error
)
{
if
(
internal
)
{
for
(
i
=
font
-
>
num_subfonts
;
i
>
0
;
i
-
-
)
FT_FREE
(
internal
-
>
subfonts
[
i
-
1
]
)
;
FT_FREE
(
internal
-
>
topfont
)
;
}
FT_FREE
(
internal
)
;
}
return
error
;
}
#
ifdef
TT_CONFIG_OPTION_EMBEDDED_BITMAPS
FT_LOCAL_DEF
(
FT_Error
)
cff_size_select
(
FT_Size
size
FT_ULong
strike_index
)
{
CFF_Size
cffsize
=
(
CFF_Size
)
size
;
PSH_Globals_Funcs
funcs
;
cffsize
-
>
strike_index
=
strike_index
;
FT_Select_Metrics
(
size
-
>
face
strike_index
)
;
funcs
=
cff_size_get_globals_funcs
(
cffsize
)
;
if
(
funcs
)
{
CFF_Face
face
=
(
CFF_Face
)
size
-
>
face
;
CFF_Font
font
=
(
CFF_Font
)
face
-
>
extra
.
data
;
CFF_Internal
internal
=
(
CFF_Internal
)
size
-
>
internal
-
>
module_data
;
FT_Long
top_upm
=
(
FT_Long
)
font
-
>
top_font
.
font_dict
.
units_per_em
;
FT_UInt
i
;
funcs
-
>
set_scale
(
internal
-
>
topfont
size
-
>
metrics
.
x_scale
size
-
>
metrics
.
y_scale
0
0
)
;
for
(
i
=
font
-
>
num_subfonts
;
i
>
0
;
i
-
-
)
{
CFF_SubFont
sub
=
font
-
>
subfonts
[
i
-
1
]
;
FT_Long
sub_upm
=
(
FT_Long
)
sub
-
>
font_dict
.
units_per_em
;
FT_Pos
x_scale
y_scale
;
if
(
top_upm
!
=
sub_upm
)
{
x_scale
=
FT_MulDiv
(
size
-
>
metrics
.
x_scale
top_upm
sub_upm
)
;
y_scale
=
FT_MulDiv
(
size
-
>
metrics
.
y_scale
top_upm
sub_upm
)
;
}
else
{
x_scale
=
size
-
>
metrics
.
x_scale
;
y_scale
=
size
-
>
metrics
.
y_scale
;
}
funcs
-
>
set_scale
(
internal
-
>
subfonts
[
i
-
1
]
x_scale
y_scale
0
0
)
;
}
}
return
FT_Err_Ok
;
}
#
endif
FT_LOCAL_DEF
(
FT_Error
)
cff_size_request
(
FT_Size
size
FT_Size_Request
req
)
{
FT_Error
error
;
CFF_Size
cffsize
=
(
CFF_Size
)
size
;
PSH_Globals_Funcs
funcs
;
#
ifdef
TT_CONFIG_OPTION_EMBEDDED_BITMAPS
if
(
FT_HAS_FIXED_SIZES
(
size
-
>
face
)
)
{
CFF_Face
cffface
=
(
CFF_Face
)
size
-
>
face
;
SFNT_Service
sfnt
=
(
SFNT_Service
)
cffface
-
>
sfnt
;
FT_ULong
strike_index
;
if
(
sfnt
-
>
set_sbit_strike
(
cffface
req
&
strike_index
)
)
cffsize
-
>
strike_index
=
0xFFFFFFFFUL
;
else
return
cff_size_select
(
size
strike_index
)
;
}
#
endif
error
=
FT_Request_Metrics
(
size
-
>
face
req
)
;
if
(
error
)
goto
Exit
;
funcs
=
cff_size_get_globals_funcs
(
cffsize
)
;
if
(
funcs
)
{
CFF_Face
cffface
=
(
CFF_Face
)
size
-
>
face
;
CFF_Font
font
=
(
CFF_Font
)
cffface
-
>
extra
.
data
;
CFF_Internal
internal
=
(
CFF_Internal
)
size
-
>
internal
-
>
module_data
;
FT_Long
top_upm
=
(
FT_Long
)
font
-
>
top_font
.
font_dict
.
units_per_em
;
FT_UInt
i
;
funcs
-
>
set_scale
(
internal
-
>
topfont
size
-
>
metrics
.
x_scale
size
-
>
metrics
.
y_scale
0
0
)
;
for
(
i
=
font
-
>
num_subfonts
;
i
>
0
;
i
-
-
)
{
CFF_SubFont
sub
=
font
-
>
subfonts
[
i
-
1
]
;
FT_Long
sub_upm
=
(
FT_Long
)
sub
-
>
font_dict
.
units_per_em
;
FT_Pos
x_scale
y_scale
;
if
(
top_upm
!
=
sub_upm
)
{
x_scale
=
FT_MulDiv
(
size
-
>
metrics
.
x_scale
top_upm
sub_upm
)
;
y_scale
=
FT_MulDiv
(
size
-
>
metrics
.
y_scale
top_upm
sub_upm
)
;
}
else
{
x_scale
=
size
-
>
metrics
.
x_scale
;
y_scale
=
size
-
>
metrics
.
y_scale
;
}
funcs
-
>
set_scale
(
internal
-
>
subfonts
[
i
-
1
]
x_scale
y_scale
0
0
)
;
}
}
Exit
:
return
error
;
}
FT_LOCAL_DEF
(
void
)
cff_slot_done
(
FT_GlyphSlot
slot
)
{
if
(
slot
-
>
internal
)
slot
-
>
internal
-
>
glyph_hints
=
NULL
;
}
FT_LOCAL_DEF
(
FT_Error
)
cff_slot_init
(
FT_GlyphSlot
slot
)
{
CFF_Face
face
=
(
CFF_Face
)
slot
-
>
face
;
CFF_Font
font
=
(
CFF_Font
)
face
-
>
extra
.
data
;
PSHinter_Service
pshinter
=
font
-
>
pshinter
;
if
(
pshinter
)
{
FT_Module
module
;
module
=
FT_Get_Module
(
slot
-
>
library
"
pshinter
"
)
;
if
(
module
)
{
T2_Hints_Funcs
funcs
;
funcs
=
pshinter
-
>
get_t2_funcs
(
module
)
;
slot
-
>
internal
-
>
glyph_hints
=
(
void
*
)
funcs
;
}
}
return
FT_Err_Ok
;
}
static
FT_String
*
cff_strcpy
(
FT_Memory
memory
const
FT_String
*
source
)
{
FT_Error
error
;
FT_String
*
result
;
FT_MEM_STRDUP
(
result
source
)
;
return
result
;
}
static
void
remove_subset_prefix
(
FT_String
*
name
)
{
FT_UInt32
i
=
0
idx
=
0
;
while
(
'
A
'
<
=
name
[
i
]
&
&
name
[
i
+
+
]
<
=
'
Z
'
&
&
'
A
'
<
=
name
[
i
]
&
&
name
[
i
+
+
]
<
=
'
Z
'
&
&
'
A
'
<
=
name
[
i
]
&
&
name
[
i
+
+
]
<
=
'
Z
'
&
&
'
A
'
<
=
name
[
i
]
&
&
name
[
i
+
+
]
<
=
'
Z
'
&
&
'
A
'
<
=
name
[
i
]
&
&
name
[
i
+
+
]
<
=
'
Z
'
&
&
'
A
'
<
=
name
[
i
]
&
&
name
[
i
+
+
]
<
=
'
Z
'
&
&
name
[
i
+
+
]
=
=
'
+
'
)
{
idx
=
i
;
}
if
(
idx
)
FT_MEM_MOVE
(
name
name
+
idx
ft_strlen
(
name
+
idx
)
+
1
)
;
}
static
void
remove_style
(
FT_String
*
family_name
const
FT_String
*
style_name
)
{
FT_String
*
f
=
family_name
+
ft_strlen
(
family_name
)
;
const
FT_String
*
s
=
style_name
+
ft_strlen
(
style_name
)
;
while
(
s
>
style_name
)
if
(
f
=
=
family_name
|
|
*
-
-
s
!
=
*
-
-
f
)
return
;
do
*
f
=
'
\
0
'
;
while
(
f
-
-
>
family_name
&
&
(
*
f
=
=
'
-
'
|
|
*
f
=
=
'
'
|
|
*
f
=
=
'
_
'
|
|
*
f
=
=
'
+
'
)
)
;
}
FT_LOCAL_DEF
(
FT_Error
)
cff_face_init
(
FT_Stream
stream
FT_Face
cffface
FT_Int
face_index
FT_Int
num_params
FT_Parameter
*
params
)
{
CFF_Face
face
=
(
CFF_Face
)
cffface
;
FT_Error
error
;
SFNT_Service
sfnt
;
FT_Service_PsCMaps
psnames
;
PSHinter_Service
pshinter
;
PSAux_Service
psaux
;
FT_Service_CFFLoad
cffload
;
FT_Bool
pure_cff
=
1
;
FT_Bool
cff2
=
0
;
FT_Bool
sfnt_format
=
0
;
FT_Library
library
=
cffface
-
>
driver
-
>
root
.
library
;
sfnt
=
(
SFNT_Service
)
FT_Get_Module_Interface
(
library
"
sfnt
"
)
;
if
(
!
sfnt
)
{
FT_ERROR
(
(
"
cff_face_init
:
cannot
access
sfnt
'
module
\
n
"
)
)
;
error
=
FT_THROW
(
Missing_Module
)
;
goto
Exit
;
}
FT_FACE_FIND_GLOBAL_SERVICE
(
face
psnames
POSTSCRIPT_CMAPS
)
;
pshinter
=
(
PSHinter_Service
)
FT_Get_Module_Interface
(
library
"
pshinter
"
)
;
psaux
=
(
PSAux_Service
)
FT_Get_Module_Interface
(
library
"
psaux
"
)
;
if
(
!
psaux
)
{
FT_ERROR
(
(
"
cff_face_init
:
cannot
access
psaux
'
module
\
n
"
)
)
;
error
=
FT_THROW
(
Missing_Module
)
;
goto
Exit
;
}
face
-
>
psaux
=
psaux
;
FT_FACE_FIND_GLOBAL_SERVICE
(
face
cffload
CFF_LOAD
)
;
FT_TRACE2
(
(
"
CFF
driver
\
n
"
)
)
;
if
(
FT_STREAM_SEEK
(
0
)
)
goto
Exit
;
FT_TRACE2
(
(
"
"
)
)
;
error
=
sfnt
-
>
init_face
(
stream
face
face_index
num_params
params
)
;
if
(
!
error
)
{
if
(
face
-
>
format_tag
!
=
TTAG_OTTO
)
{
FT_TRACE2
(
(
"
not
an
OpenType
/
CFF
font
\
n
"
)
)
;
error
=
FT_THROW
(
Unknown_File_Format
)
;
goto
Exit
;
}
if
(
face_index
<
0
)
return
FT_Err_Ok
;
sfnt_format
=
1
;
error
=
face
-
>
goto_table
(
face
TTAG_head
stream
0
)
;
if
(
!
error
)
{
pure_cff
=
0
;
error
=
sfnt
-
>
load_face
(
stream
face
face_index
num_params
params
)
;
if
(
error
)
goto
Exit
;
}
else
{
error
=
sfnt
-
>
load_cmap
(
face
stream
)
;
if
(
FT_ERR_NEQ
(
error
Table_Missing
)
&
&
FT_ERR_NEQ
(
error
Ok
)
)
goto
Exit
;
}
error
=
face
-
>
goto_table
(
face
TTAG_CFF2
stream
0
)
;
if
(
!
error
)
{
cff2
=
1
;
face
-
>
is_cff2
=
cff2
;
}
if
(
FT_ERR_EQ
(
error
Table_Missing
)
)
error
=
face
-
>
goto_table
(
face
TTAG_CFF
stream
0
)
;
if
(
error
)
goto
Exit
;
}
else
{
if
(
FT_STREAM_SEEK
(
0
)
)
goto
Exit
;
error
=
FT_Err_Ok
;
}
{
CFF_Font
cff
=
NULL
;
CFF_FontRecDict
dict
;
FT_Memory
memory
=
cffface
-
>
memory
;
FT_Int32
flags
;
FT_UInt
i
;
if
(
FT_NEW
(
cff
)
)
goto
Exit
;
face
-
>
extra
.
data
=
cff
;
error
=
cff_font_load
(
library
stream
face_index
cff
face
pure_cff
cff2
)
;
if
(
error
)
goto
Exit
;
if
(
face_index
<
0
)
{
cffface
-
>
num_faces
=
(
FT_Long
)
cff
-
>
num_faces
;
return
FT_Err_Ok
;
}
cff
-
>
pshinter
=
pshinter
;
cff
-
>
psnames
=
psnames
;
cff
-
>
cffload
=
cffload
;
cffface
-
>
face_index
=
face_index
&
0xFFFF
;
cffface
-
>
num_glyphs
=
(
FT_Long
)
cff
-
>
num_glyphs
;
dict
=
&
cff
-
>
top_font
.
font_dict
;
if
(
dict
-
>
cid_registry
=
=
0xFFFFU
&
&
!
psnames
)
{
FT_ERROR
(
(
"
cff_face_init
:
"
"
cannot
open
CFF
&
CEF
fonts
\
n
"
)
)
;
FT_ERROR
(
(
"
"
"
without
the
psnames
'
module
\
n
"
)
)
;
error
=
FT_THROW
(
Missing_Module
)
;
goto
Exit
;
}
#
ifdef
FT_DEBUG_LEVEL_TRACE
{
FT_UInt
idx
;
FT_String
*
s
;
FT_TRACE4
(
(
"
SIDs
\
n
"
)
)
;
for
(
idx
=
0
;
idx
<
=
390
;
idx
+
+
)
{
s
=
cff_index_get_sid_string
(
cff
idx
)
;
if
(
s
)
FT_TRACE4
(
(
"
%
5u
%
s
\
n
"
idx
s
)
)
;
}
for
(
idx
=
1
;
idx
<
cff
-
>
num_strings
;
idx
+
+
)
{
FT_Byte
*
s1
=
cff
-
>
strings
[
idx
-
1
]
;
FT_Byte
*
s2
=
cff
-
>
strings
[
idx
]
;
FT_PtrDist
s1len
=
s2
-
s1
-
1
;
FT_PtrDist
l
;
FT_TRACE4
(
(
"
%
5u
"
idx
+
390
)
)
;
for
(
l
=
0
;
l
<
s1len
;
l
+
+
)
FT_TRACE4
(
(
"
%
c
"
s1
[
l
]
)
)
;
FT_TRACE4
(
(
"
\
n
"
)
)
;
}
if
(
cff
-
>
num_strings
)
{
FT_Byte
*
s1
=
cff
-
>
strings
[
cff
-
>
num_strings
-
1
]
;
FT_Byte
*
s2
=
cff
-
>
string_pool
+
cff
-
>
string_pool_size
;
FT_PtrDist
s1len
=
s2
-
s1
-
1
;
FT_PtrDist
l
;
FT_TRACE4
(
(
"
%
5u
"
cff
-
>
num_strings
+
390
)
)
;
for
(
l
=
0
;
l
<
s1len
;
l
+
+
)
FT_TRACE4
(
(
"
%
c
"
s1
[
l
]
)
)
;
FT_TRACE4
(
(
"
\
n
"
)
)
;
}
}
#
endif
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
{
FT_UInt
instance_index
=
(
FT_UInt
)
face_index
>
>
16
;
if
(
FT_HAS_MULTIPLE_MASTERS
(
cffface
)
)
{
error
=
FT_Set_Named_Instance
(
cffface
instance_index
)
;
if
(
error
)
goto
Exit
;
}
}
#
endif
if
(
!
dict
-
>
has_font_matrix
)
dict
-
>
units_per_em
=
pure_cff
?
1000
:
face
-
>
root
.
units_per_EM
;
{
FT_Matrix
*
matrix
=
&
dict
-
>
font_matrix
;
FT_Vector
*
offset
=
&
dict
-
>
font_offset
;
FT_ULong
*
upm
=
&
dict
-
>
units_per_em
;
FT_Fixed
temp
;
temp
=
matrix
-
>
yy
?
FT_ABS
(
matrix
-
>
yy
)
:
FT_ABS
(
matrix
-
>
yx
)
;
if
(
temp
!
=
0x10000L
)
{
*
upm
=
(
FT_ULong
)
FT_DivFix
(
(
FT_Long
)
*
upm
temp
)
;
matrix
-
>
xx
=
FT_DivFix
(
matrix
-
>
xx
temp
)
;
matrix
-
>
yx
=
FT_DivFix
(
matrix
-
>
yx
temp
)
;
matrix
-
>
xy
=
FT_DivFix
(
matrix
-
>
xy
temp
)
;
matrix
-
>
yy
=
FT_DivFix
(
matrix
-
>
yy
temp
)
;
offset
-
>
x
=
FT_DivFix
(
offset
-
>
x
temp
)
;
offset
-
>
y
=
FT_DivFix
(
offset
-
>
y
temp
)
;
}
offset
-
>
x
>
>
=
16
;
offset
-
>
y
>
>
=
16
;
}
for
(
i
=
cff
-
>
num_subfonts
;
i
>
0
;
i
-
-
)
{
CFF_FontRecDict
sub
=
&
cff
-
>
subfonts
[
i
-
1
]
-
>
font_dict
;
CFF_FontRecDict
top
=
&
cff
-
>
top_font
.
font_dict
;
FT_Matrix
*
matrix
;
FT_Vector
*
offset
;
FT_ULong
*
upm
;
FT_Fixed
temp
;
if
(
sub
-
>
has_font_matrix
)
{
FT_Long
scaling
;
if
(
top
-
>
has_font_matrix
)
{
if
(
top
-
>
units_per_em
>
1
&
&
sub
-
>
units_per_em
>
1
)
scaling
=
(
FT_Long
)
FT_MIN
(
top
-
>
units_per_em
sub
-
>
units_per_em
)
;
else
scaling
=
1
;
FT_Matrix_Multiply_Scaled
(
&
top
-
>
font_matrix
&
sub
-
>
font_matrix
scaling
)
;
FT_Vector_Transform_Scaled
(
&
sub
-
>
font_offset
&
top
-
>
font_matrix
scaling
)
;
sub
-
>
units_per_em
=
(
FT_ULong
)
FT_MulDiv
(
(
FT_Long
)
sub
-
>
units_per_em
(
FT_Long
)
top
-
>
units_per_em
scaling
)
;
}
}
else
{
sub
-
>
font_matrix
=
top
-
>
font_matrix
;
sub
-
>
font_offset
=
top
-
>
font_offset
;
sub
-
>
units_per_em
=
top
-
>
units_per_em
;
}
matrix
=
&
sub
-
>
font_matrix
;
offset
=
&
sub
-
>
font_offset
;
upm
=
&
sub
-
>
units_per_em
;
temp
=
matrix
-
>
yy
?
FT_ABS
(
matrix
-
>
yy
)
:
FT_ABS
(
matrix
-
>
yx
)
;
if
(
temp
!
=
0x10000L
)
{
*
upm
=
(
FT_ULong
)
FT_DivFix
(
(
FT_Long
)
*
upm
temp
)
;
matrix
-
>
xx
=
FT_DivFix
(
matrix
-
>
xx
temp
)
;
matrix
-
>
yx
=
FT_DivFix
(
matrix
-
>
yx
temp
)
;
matrix
-
>
xy
=
FT_DivFix
(
matrix
-
>
xy
temp
)
;
matrix
-
>
yy
=
FT_DivFix
(
matrix
-
>
yy
temp
)
;
offset
-
>
x
=
FT_DivFix
(
offset
-
>
x
temp
)
;
offset
-
>
y
=
FT_DivFix
(
offset
-
>
y
temp
)
;
}
offset
-
>
x
>
>
=
16
;
offset
-
>
y
>
>
=
16
;
}
if
(
pure_cff
)
{
char
*
style_name
=
NULL
;
cffface
-
>
num_faces
=
(
FT_Long
)
cff
-
>
num_faces
;
if
(
dict
-
>
cid_registry
!
=
0xFFFFU
)
cffface
-
>
num_glyphs
=
(
FT_Long
)
(
cff
-
>
charset
.
max_cid
+
1
)
;
else
cffface
-
>
num_glyphs
=
(
FT_Long
)
cff
-
>
charstrings_index
.
count
;
cffface
-
>
bbox
.
xMin
=
dict
-
>
font_bbox
.
xMin
>
>
16
;
cffface
-
>
bbox
.
yMin
=
dict
-
>
font_bbox
.
yMin
>
>
16
;
cffface
-
>
bbox
.
xMax
=
(
dict
-
>
font_bbox
.
xMax
+
0xFFFF
)
>
>
16
;
cffface
-
>
bbox
.
yMax
=
(
dict
-
>
font_bbox
.
yMax
+
0xFFFF
)
>
>
16
;
cffface
-
>
units_per_EM
=
(
FT_UShort
)
(
dict
-
>
units_per_em
)
;
cffface
-
>
ascender
=
(
FT_Short
)
(
cffface
-
>
bbox
.
yMax
)
;
cffface
-
>
descender
=
(
FT_Short
)
(
cffface
-
>
bbox
.
yMin
)
;
cffface
-
>
height
=
(
FT_Short
)
(
(
cffface
-
>
units_per_EM
*
12
)
/
10
)
;
if
(
cffface
-
>
height
<
cffface
-
>
ascender
-
cffface
-
>
descender
)
cffface
-
>
height
=
(
FT_Short
)
(
cffface
-
>
ascender
-
cffface
-
>
descender
)
;
cffface
-
>
underline_position
=
(
FT_Short
)
(
dict
-
>
underline_position
>
>
16
)
;
cffface
-
>
underline_thickness
=
(
FT_Short
)
(
dict
-
>
underline_thickness
>
>
16
)
;
if
(
dict
-
>
family_name
)
{
char
*
family_name
;
family_name
=
cff_index_get_sid_string
(
cff
dict
-
>
family_name
)
;
if
(
family_name
)
cffface
-
>
family_name
=
cff_strcpy
(
memory
family_name
)
;
}
if
(
!
cffface
-
>
family_name
)
{
cffface
-
>
family_name
=
cff_index_get_name
(
cff
(
FT_UInt
)
(
face_index
&
0xFFFF
)
)
;
if
(
cffface
-
>
family_name
)
remove_subset_prefix
(
cffface
-
>
family_name
)
;
}
if
(
cffface
-
>
family_name
)
{
char
*
full
=
cff_index_get_sid_string
(
cff
dict
-
>
full_name
)
;
char
*
fullp
=
full
;
char
*
family
=
cffface
-
>
family_name
;
if
(
full
&
&
family
)
{
while
(
*
fullp
)
{
if
(
*
fullp
=
=
*
family
)
{
family
+
+
;
fullp
+
+
;
continue
;
}
if
(
*
fullp
=
=
'
'
|
|
*
fullp
=
=
'
-
'
)
{
fullp
+
+
;
continue
;
}
if
(
*
family
=
=
'
'
|
|
*
family
=
=
'
-
'
)
{
family
+
+
;
continue
;
}
if
(
!
*
family
&
&
*
fullp
)
{
style_name
=
cff_strcpy
(
memory
fullp
)
;
if
(
style_name
)
remove_style
(
cffface
-
>
family_name
style_name
)
;
}
break
;
}
}
}
else
{
char
*
cid_font_name
=
cff_index_get_sid_string
(
cff
dict
-
>
cid_font_name
)
;
if
(
cid_font_name
)
cffface
-
>
family_name
=
cff_strcpy
(
memory
cid_font_name
)
;
}
if
(
style_name
)
cffface
-
>
style_name
=
style_name
;
else
cffface
-
>
style_name
=
cff_strcpy
(
memory
"
Regular
"
)
;
flags
=
FT_FACE_FLAG_SCALABLE
|
FT_FACE_FLAG_HORIZONTAL
|
FT_FACE_FLAG_HINTER
;
if
(
sfnt_format
)
flags
|
=
FT_FACE_FLAG_SFNT
;
if
(
dict
-
>
is_fixed_pitch
)
flags
|
=
FT_FACE_FLAG_FIXED_WIDTH
;
#
if
0
if
(
face
-
>
kern_pairs
)
flags
|
=
FT_FACE_FLAG_KERNING
;
#
endif
cffface
-
>
face_flags
|
=
flags
;
flags
=
0
;
if
(
dict
-
>
italic_angle
)
flags
|
=
FT_STYLE_FLAG_ITALIC
;
{
char
*
weight
=
cff_index_get_sid_string
(
cff
dict
-
>
weight
)
;
if
(
weight
)
if
(
!
ft_strcmp
(
weight
"
Bold
"
)
|
|
!
ft_strcmp
(
weight
"
Black
"
)
)
flags
|
=
FT_STYLE_FLAG_BOLD
;
}
if
(
!
(
flags
&
FT_STYLE_FLAG_BOLD
)
&
&
cffface
-
>
style_name
)
if
(
!
ft_strncmp
(
cffface
-
>
style_name
"
Bold
"
4
)
|
|
!
ft_strncmp
(
cffface
-
>
style_name
"
Black
"
5
)
)
flags
|
=
FT_STYLE_FLAG_BOLD
;
cffface
-
>
style_flags
=
flags
;
}
if
(
dict
-
>
cid_registry
=
=
0xFFFFU
&
&
!
cff2
)
cffface
-
>
face_flags
|
=
FT_FACE_FLAG_GLYPH_NAMES
;
if
(
dict
-
>
cid_registry
!
=
0xFFFFU
&
&
pure_cff
)
cffface
-
>
face_flags
|
=
FT_FACE_FLAG_CID_KEYED
;
{
FT_CharMapRec
cmaprec
;
FT_CharMap
cmap
;
FT_Int
nn
;
CFF_Encoding
encoding
=
&
cff
-
>
encoding
;
for
(
nn
=
0
;
nn
<
cffface
-
>
num_charmaps
;
nn
+
+
)
{
cmap
=
cffface
-
>
charmaps
[
nn
]
;
if
(
cmap
-
>
platform_id
=
=
TT_PLATFORM_MICROSOFT
&
&
cmap
-
>
encoding_id
=
=
TT_MS_ID_UNICODE_CS
)
goto
Skip_Unicode
;
if
(
cmap
-
>
platform_id
=
=
TT_PLATFORM_APPLE_UNICODE
)
goto
Skip_Unicode
;
}
if
(
pure_cff
&
&
cff
-
>
top_font
.
font_dict
.
cid_registry
!
=
0xFFFFU
)
goto
Exit
;
cmaprec
.
face
=
cffface
;
cmaprec
.
platform_id
=
TT_PLATFORM_MICROSOFT
;
cmaprec
.
encoding_id
=
TT_MS_ID_UNICODE_CS
;
cmaprec
.
encoding
=
FT_ENCODING_UNICODE
;
nn
=
cffface
-
>
num_charmaps
;
error
=
FT_CMap_New
(
&
cff_cmap_unicode_class_rec
NULL
&
cmaprec
NULL
)
;
if
(
error
&
&
FT_ERR_NEQ
(
error
No_Unicode_Glyph_Name
)
&
&
FT_ERR_NEQ
(
error
Unimplemented_Feature
)
)
goto
Exit
;
error
=
FT_Err_Ok
;
if
(
!
cffface
-
>
charmap
&
&
nn
!
=
cffface
-
>
num_charmaps
)
cffface
-
>
charmap
=
cffface
-
>
charmaps
[
nn
]
;
Skip_Unicode
:
if
(
encoding
-
>
count
>
0
)
{
FT_CMap_Class
clazz
;
cmaprec
.
face
=
cffface
;
cmaprec
.
platform_id
=
TT_PLATFORM_ADOBE
;
if
(
encoding
-
>
offset
=
=
0
)
{
cmaprec
.
encoding_id
=
TT_ADOBE_ID_STANDARD
;
cmaprec
.
encoding
=
FT_ENCODING_ADOBE_STANDARD
;
clazz
=
&
cff_cmap_encoding_class_rec
;
}
else
if
(
encoding
-
>
offset
=
=
1
)
{
cmaprec
.
encoding_id
=
TT_ADOBE_ID_EXPERT
;
cmaprec
.
encoding
=
FT_ENCODING_ADOBE_EXPERT
;
clazz
=
&
cff_cmap_encoding_class_rec
;
}
else
{
cmaprec
.
encoding_id
=
TT_ADOBE_ID_CUSTOM
;
cmaprec
.
encoding
=
FT_ENCODING_ADOBE_CUSTOM
;
clazz
=
&
cff_cmap_encoding_class_rec
;
}
error
=
FT_CMap_New
(
clazz
NULL
&
cmaprec
NULL
)
;
}
}
}
Exit
:
return
error
;
}
FT_LOCAL_DEF
(
void
)
cff_face_done
(
FT_Face
cffface
)
{
CFF_Face
face
=
(
CFF_Face
)
cffface
;
FT_Memory
memory
;
SFNT_Service
sfnt
;
if
(
!
face
)
return
;
memory
=
cffface
-
>
memory
;
sfnt
=
(
SFNT_Service
)
face
-
>
sfnt
;
if
(
sfnt
)
sfnt
-
>
done_face
(
face
)
;
{
CFF_Font
cff
=
(
CFF_Font
)
face
-
>
extra
.
data
;
if
(
cff
)
{
cff_font_done
(
cff
)
;
FT_FREE
(
face
-
>
extra
.
data
)
;
}
}
#
ifdef
TT_CONFIG_OPTION_GX_VAR_SUPPORT
cff_done_blend
(
cffface
)
;
face
-
>
blend
=
NULL
;
#
endif
}
FT_LOCAL_DEF
(
FT_Error
)
cff_driver_init
(
FT_Module
module
)
{
PS_Driver
driver
=
(
PS_Driver
)
module
;
FT_UInt32
seed
;
driver
-
>
hinting_engine
=
FT_HINTING_ADOBE
;
driver
-
>
no_stem_darkening
=
TRUE
;
driver
-
>
darken_params
[
0
]
=
CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1
;
driver
-
>
darken_params
[
1
]
=
CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1
;
driver
-
>
darken_params
[
2
]
=
CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2
;
driver
-
>
darken_params
[
3
]
=
CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2
;
driver
-
>
darken_params
[
4
]
=
CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3
;
driver
-
>
darken_params
[
5
]
=
CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3
;
driver
-
>
darken_params
[
6
]
=
CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4
;
driver
-
>
darken_params
[
7
]
=
CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4
;
seed
=
(
FT_UInt32
)
(
(
FT_Offset
)
(
char
*
)
&
seed
^
(
FT_Offset
)
(
char
*
)
&
module
^
(
FT_Offset
)
(
char
*
)
module
-
>
memory
)
;
seed
=
seed
^
(
seed
>
>
10
)
^
(
seed
>
>
20
)
;
driver
-
>
random_seed
=
(
FT_Int32
)
seed
;
if
(
driver
-
>
random_seed
<
0
)
driver
-
>
random_seed
=
-
driver
-
>
random_seed
;
else
if
(
driver
-
>
random_seed
=
=
0
)
driver
-
>
random_seed
=
123456789
;
return
FT_Err_Ok
;
}
FT_LOCAL_DEF
(
void
)
cff_driver_done
(
FT_Module
module
)
{
FT_UNUSED
(
module
)
;
}
