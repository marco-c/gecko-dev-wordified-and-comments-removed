#
include
"
nsFTPChannel
.
h
"
#
include
"
nsFtpConnectionThread
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
net
;
extern
LazyLogModule
gFTPLog
;
NS_IMPL_ISUPPORTS_INHERITED
(
nsFtpChannel
nsBaseChannel
nsIUploadChannel
nsIResumableChannel
nsIFTPChannel
nsIProxiedChannel
nsIForcePendingChannel
nsISupportsWeakReference
nsIChannelWithDivertableParentListener
)
NS_IMETHODIMP
nsFtpChannel
:
:
SetUploadStream
(
nsIInputStream
*
stream
const
nsACString
&
contentType
int64_t
contentLength
)
{
NS_ENSURE_TRUE
(
!
Pending
(
)
NS_ERROR_IN_PROGRESS
)
;
mUploadStream
=
stream
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
GetUploadStream
(
nsIInputStream
*
*
aStream
)
{
NS_ENSURE_ARG_POINTER
(
aStream
)
;
nsCOMPtr
<
nsIInputStream
>
stream
=
mUploadStream
;
stream
.
forget
(
aStream
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
ResumeAt
(
uint64_t
aStartPos
const
nsACString
&
aEntityID
)
{
NS_ENSURE_TRUE
(
!
Pending
(
)
NS_ERROR_IN_PROGRESS
)
;
mEntityID
=
aEntityID
;
mStartPos
=
aStartPos
;
mResumeRequested
=
(
mStartPos
|
|
!
mEntityID
.
IsEmpty
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
GetEntityID
(
nsACString
&
entityID
)
{
if
(
mEntityID
.
IsEmpty
(
)
)
return
NS_ERROR_NOT_RESUMABLE
;
entityID
=
mEntityID
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
GetProxyInfo
(
nsIProxyInfo
*
*
aProxyInfo
)
{
nsCOMPtr
<
nsIProxyInfo
>
info
=
ProxyInfo
(
)
;
info
.
forget
(
aProxyInfo
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
GetHttpProxyConnectResponseCode
(
int32_t
*
aResponseCode
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
nsFtpChannel
:
:
OpenContentStream
(
bool
async
nsIInputStream
*
*
result
nsIChannel
*
*
channel
)
{
if
(
!
async
)
return
NS_ERROR_NOT_IMPLEMENTED
;
SetContentType
(
NS_LITERAL_CSTRING
(
APPLICATION_OCTET_STREAM
)
)
;
RefPtr
<
nsFtpState
>
state
=
new
nsFtpState
(
)
;
nsresult
rv
=
state
-
>
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
state
.
forget
(
result
)
;
return
NS_OK
;
}
bool
nsFtpChannel
:
:
GetStatusArg
(
nsresult
status
nsString
&
statusArg
)
{
nsAutoCString
host
;
URI
(
)
-
>
GetHost
(
host
)
;
CopyUTF8toUTF16
(
host
statusArg
)
;
return
true
;
}
void
nsFtpChannel
:
:
OnCallbacksChanged
(
)
{
mFTPEventSink
=
nullptr
;
}
namespace
{
class
FTPEventSinkProxy
final
:
public
nsIFTPEventSink
{
~
FTPEventSinkProxy
(
)
=
default
;
public
:
explicit
FTPEventSinkProxy
(
nsIFTPEventSink
*
aTarget
)
:
mTarget
(
aTarget
)
mEventTarget
(
GetCurrentThreadEventTarget
(
)
)
{
}
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIFTPEVENTSINK
class
OnFTPControlLogRunnable
:
public
Runnable
{
public
:
OnFTPControlLogRunnable
(
nsIFTPEventSink
*
aTarget
bool
aServer
const
char
*
aMessage
)
:
mozilla
:
:
Runnable
(
"
FTPEventSinkProxy
:
:
OnFTPControlLogRunnable
"
)
mTarget
(
aTarget
)
mServer
(
aServer
)
mMessage
(
aMessage
)
{
}
NS_DECL_NSIRUNNABLE
private
:
nsCOMPtr
<
nsIFTPEventSink
>
mTarget
;
bool
mServer
;
nsCString
mMessage
;
}
;
private
:
nsCOMPtr
<
nsIFTPEventSink
>
mTarget
;
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
}
;
NS_IMPL_ISUPPORTS
(
FTPEventSinkProxy
nsIFTPEventSink
)
NS_IMETHODIMP
FTPEventSinkProxy
:
:
OnFTPControlLog
(
bool
aServer
const
char
*
aMsg
)
{
RefPtr
<
OnFTPControlLogRunnable
>
r
=
new
OnFTPControlLogRunnable
(
mTarget
aServer
aMsg
)
;
return
mEventTarget
-
>
Dispatch
(
r
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
FTPEventSinkProxy
:
:
OnFTPControlLogRunnable
:
:
Run
(
)
{
mTarget
-
>
OnFTPControlLog
(
mServer
mMessage
.
get
(
)
)
;
return
NS_OK
;
}
}
void
nsFtpChannel
:
:
GetFTPEventSink
(
nsCOMPtr
<
nsIFTPEventSink
>
&
aResult
)
{
if
(
!
mFTPEventSink
)
{
nsCOMPtr
<
nsIFTPEventSink
>
ftpSink
;
GetCallback
(
ftpSink
)
;
if
(
ftpSink
)
{
mFTPEventSink
=
new
FTPEventSinkProxy
(
ftpSink
)
;
}
}
aResult
=
mFTPEventSink
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
ForcePending
(
bool
aForcePending
)
{
mForcePending
=
aForcePending
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
IsPending
(
bool
*
result
)
{
*
result
=
Pending
(
)
;
return
NS_OK
;
}
bool
nsFtpChannel
:
:
Pending
(
)
const
{
return
nsBaseChannel
:
:
Pending
(
)
|
|
mForcePending
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
Suspend
(
)
{
LOG
(
(
"
nsFtpChannel
:
:
Suspend
[
this
=
%
p
]
\
n
"
this
)
)
;
nsresult
rv
=
SuspendInternal
(
)
;
nsresult
rvParentChannel
=
NS_OK
;
if
(
mParentChannel
)
{
rvParentChannel
=
mParentChannel
-
>
SuspendMessageDiversion
(
)
;
}
return
NS_FAILED
(
rv
)
?
rv
:
rvParentChannel
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
Resume
(
)
{
LOG
(
(
"
nsFtpChannel
:
:
Resume
[
this
=
%
p
]
\
n
"
this
)
)
;
nsresult
rv
=
ResumeInternal
(
)
;
nsresult
rvParentChannel
=
NS_OK
;
if
(
mParentChannel
)
{
rvParentChannel
=
mParentChannel
-
>
ResumeMessageDiversion
(
)
;
}
return
NS_FAILED
(
rv
)
?
rv
:
rvParentChannel
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
MessageDiversionStarted
(
ADivertableParentChannel
*
aParentChannel
)
{
MOZ_ASSERT
(
!
mParentChannel
)
;
mParentChannel
=
aParentChannel
;
uint32_t
suspendCount
=
mSuspendCount
;
while
(
suspendCount
-
-
)
{
mParentChannel
-
>
SuspendMessageDiversion
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
MessageDiversionStop
(
)
{
LOG
(
(
"
nsFtpChannel
:
:
MessageDiversionStop
[
this
=
%
p
]
"
this
)
)
;
MOZ_ASSERT
(
mParentChannel
)
;
mParentChannel
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
SuspendInternal
(
)
{
LOG
(
(
"
nsFtpChannel
:
:
SuspendInternal
[
this
=
%
p
]
\
n
"
this
)
)
;
NS_ENSURE_TRUE
(
Pending
(
)
NS_ERROR_NOT_AVAILABLE
)
;
+
+
mSuspendCount
;
return
nsBaseChannel
:
:
Suspend
(
)
;
}
NS_IMETHODIMP
nsFtpChannel
:
:
ResumeInternal
(
)
{
LOG
(
(
"
nsFtpChannel
:
:
ResumeInternal
[
this
=
%
p
]
\
n
"
this
)
)
;
NS_ENSURE_TRUE
(
mSuspendCount
>
0
NS_ERROR_UNEXPECTED
)
;
-
-
mSuspendCount
;
return
nsBaseChannel
:
:
Resume
(
)
;
}
