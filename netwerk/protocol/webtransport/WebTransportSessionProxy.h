#
ifndef
mozilla_net_WebTransportProxy_h
#
define
mozilla_net_WebTransportProxy_h
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIRedirectResultListener
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIWebTransport
.
h
"
namespace
mozilla
:
:
net
{
class
WebTransportStreamCallbackWrapper
;
class
WebTransportSessionProxy
final
:
public
nsIWebTransport
public
WebTransportSessionEventListener
public
nsIStreamListener
public
nsIChannelEventSink
public
nsIRedirectResultListener
public
nsIInterfaceRequestor
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIWEBTRANSPORT
NS_DECL_WEBTRANSPORTSESSIONEVENTLISTENER
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIREDIRECTRESULTLISTENER
NS_DECL_NSIINTERFACEREQUESTOR
WebTransportSessionProxy
(
)
;
private
:
~
WebTransportSessionProxy
(
)
;
void
CloseSessionInternal
(
)
;
void
CallOnSessionClosed
(
)
;
enum
WebTransportSessionProxyState
{
INIT
NEGOTIATING
NEGOTIATING_SUCCEEDED
ACTIVE
CLOSE_CALLBACK_PENDING
SESSION_CLOSE_PENDING
DONE
}
;
mozilla
:
:
Mutex
mMutex
;
WebTransportSessionProxyState
mState
MOZ_GUARDED_BY
(
mMutex
)
=
WebTransportSessionProxyState
:
:
INIT
;
void
ChangeState
(
WebTransportSessionProxyState
newState
)
;
void
CreateStreamInternal
(
WebTransportStreamCallbackWrapper
*
aCallback
bool
aBidi
)
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsIChannel
>
mRedirectChannel
;
nsCOMPtr
<
WebTransportSessionEventListener
>
mListener
;
RefPtr
<
Http3WebTransportSession
>
mWebTransportSession
;
uint64_t
mSessionId
MOZ_GUARDED_BY
(
mMutex
)
=
UINT64_MAX
;
uint32_t
mCloseStatus
MOZ_GUARDED_BY
(
mMutex
)
=
0
;
nsCString
mReason
MOZ_GUARDED_BY
(
mMutex
)
;
}
;
}
#
endif
