#
include
"
HttpLog
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
#
include
"
ConnectionEntry
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
ChaosMode
.
h
"
namespace
mozilla
{
namespace
net
{
ConnectionEntry
:
:
~
ConnectionEntry
(
)
{
LOG
(
(
"
ConnectionEntry
:
:
~
ConnectionEntry
this
=
%
p
"
this
)
)
;
MOZ_ASSERT
(
!
mIdleConns
.
Length
(
)
)
;
MOZ_ASSERT
(
!
mActiveConns
.
Length
(
)
)
;
MOZ_ASSERT
(
!
mHalfOpens
.
Length
(
)
)
;
MOZ_ASSERT
(
!
PendingQueueLength
(
)
)
;
MOZ_ASSERT
(
!
UrgentStartQueueLength
(
)
)
;
MOZ_ASSERT
(
!
mHalfOpenFastOpenBackups
.
Length
(
)
)
;
MOZ_ASSERT
(
!
mDoNotDestroy
)
;
}
ConnectionEntry
:
:
ConnectionEntry
(
nsHttpConnectionInfo
*
ci
)
:
mConnInfo
(
ci
)
mUsingSpdy
(
false
)
mCanUseSpdy
(
true
)
mPreferIPv4
(
false
)
mPreferIPv6
(
false
)
mUsedForConnection
(
false
)
mDoNotDestroy
(
false
)
{
if
(
mConnInfo
-
>
FirstHopSSL
(
)
&
&
!
mConnInfo
-
>
IsHttp3
(
)
)
{
mUseFastOpen
=
gHttpHandler
-
>
UseFastOpen
(
)
;
}
else
{
mUseFastOpen
=
false
;
}
LOG
(
(
"
ConnectionEntry
:
:
ConnectionEntry
this
=
%
p
key
=
%
s
"
this
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
}
bool
ConnectionEntry
:
:
AvailableForDispatchNow
(
)
{
if
(
mIdleConns
.
Length
(
)
&
&
mIdleConns
[
0
]
-
>
CanReuse
(
)
)
{
return
true
;
}
return
gHttpHandler
-
>
ConnMgr
(
)
-
>
GetH2orH3ActiveConn
(
this
false
)
?
true
:
false
;
}
uint32_t
ConnectionEntry
:
:
UnconnectedHalfOpens
(
)
const
{
uint32_t
unconnectedHalfOpens
=
0
;
for
(
uint32_t
i
=
0
;
i
<
mHalfOpens
.
Length
(
)
;
+
+
i
)
{
if
(
!
mHalfOpens
[
i
]
-
>
HasConnected
(
)
)
{
+
+
unconnectedHalfOpens
;
}
}
return
unconnectedHalfOpens
;
}
void
ConnectionEntry
:
:
RemoveHalfOpen
(
HalfOpenSocket
*
halfOpen
)
{
if
(
mHalfOpens
.
RemoveElement
(
halfOpen
)
)
{
if
(
halfOpen
-
>
IsSpeculative
(
)
)
{
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
HTTPCONNMGR_UNUSED_SPECULATIVE_CONN
>
unusedSpeculativeConn
;
+
+
unusedSpeculativeConn
;
if
(
halfOpen
-
>
IsFromPredictor
(
)
)
{
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
PREDICTOR_TOTAL_PRECONNECTS_UNUSED
>
totalPreconnectsUnused
;
+
+
totalPreconnectsUnused
;
}
}
gHttpHandler
-
>
ConnMgr
(
)
-
>
DecreaseNumHalfOpenConns
(
)
;
}
else
{
mHalfOpenFastOpenBackups
.
RemoveElement
(
halfOpen
)
;
}
if
(
!
UnconnectedHalfOpens
(
)
)
{
nsresult
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
ProcessPendingQ
(
mConnInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ConnectionEntry
:
:
RemoveHalfOpen
\
n
"
"
failed
to
process
pending
queue
\
n
"
)
)
;
}
}
}
void
ConnectionEntry
:
:
DisallowHttp2
(
)
{
mCanUseSpdy
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mActiveConns
.
Length
(
)
;
+
+
i
)
{
if
(
mActiveConns
[
i
]
-
>
UsingSpdy
(
)
)
{
mActiveConns
[
i
]
-
>
DontReuse
(
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
mIdleConns
.
Length
(
)
;
+
+
i
)
{
if
(
mIdleConns
[
i
]
-
>
UsingSpdy
(
)
)
{
mIdleConns
[
i
]
-
>
DontReuse
(
)
;
}
}
mCoalescingKeys
.
Clear
(
)
;
}
void
ConnectionEntry
:
:
DontReuseHttp3Conn
(
)
{
MOZ_ASSERT
(
mConnInfo
-
>
IsHttp3
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mActiveConns
.
Length
(
)
;
+
+
i
)
{
mActiveConns
[
i
]
-
>
DontReuse
(
)
;
}
mCoalescingKeys
.
Clear
(
)
;
}
void
ConnectionEntry
:
:
RecordIPFamilyPreference
(
uint16_t
family
)
{
LOG
(
(
"
ConnectionEntry
:
:
RecordIPFamilyPreference
%
p
af
=
%
u
"
this
family
)
)
;
if
(
family
=
=
PR_AF_INET
&
&
!
mPreferIPv6
)
{
mPreferIPv4
=
true
;
}
if
(
family
=
=
PR_AF_INET6
&
&
!
mPreferIPv4
)
{
mPreferIPv6
=
true
;
}
LOG
(
(
"
%
p
prefer
ipv4
=
%
d
ipv6
=
%
d
"
this
(
bool
)
mPreferIPv4
(
bool
)
mPreferIPv6
)
)
;
}
void
ConnectionEntry
:
:
ResetIPFamilyPreference
(
)
{
LOG
(
(
"
ConnectionEntry
:
:
ResetIPFamilyPreference
%
p
"
this
)
)
;
mPreferIPv4
=
false
;
mPreferIPv6
=
false
;
}
bool
net
:
:
ConnectionEntry
:
:
PreferenceKnown
(
)
const
{
return
(
bool
)
mPreferIPv4
|
|
(
bool
)
mPreferIPv6
;
}
size_t
ConnectionEntry
:
:
PendingQueueLength
(
)
const
{
return
mPendingQ
.
PendingQueueLength
(
)
;
}
size_t
ConnectionEntry
:
:
PendingQueueLengthForWindow
(
uint64_t
windowId
)
const
{
return
mPendingQ
.
PendingQueueLengthForWindow
(
windowId
)
;
}
void
ConnectionEntry
:
:
AppendPendingUrgentStartQ
(
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
&
result
)
{
mPendingQ
.
AppendPendingUrgentStartQ
(
result
)
;
}
void
ConnectionEntry
:
:
AppendPendingQForFocusedWindow
(
uint64_t
windowId
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
&
result
uint32_t
maxCount
)
{
mPendingQ
.
AppendPendingQForFocusedWindow
(
windowId
result
maxCount
)
;
LOG
(
(
"
ConnectionEntry
:
:
AppendPendingQForFocusedWindow
[
ci
=
%
s
]
"
"
pendingQ
count
=
%
zu
for
focused
window
(
id
=
%
"
PRIu64
"
)
\
n
"
mConnInfo
-
>
HashKey
(
)
.
get
(
)
result
.
Length
(
)
windowId
)
)
;
}
void
ConnectionEntry
:
:
AppendPendingQForNonFocusedWindows
(
uint64_t
windowId
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
&
result
uint32_t
maxCount
)
{
mPendingQ
.
AppendPendingQForNonFocusedWindows
(
windowId
result
maxCount
)
;
LOG
(
(
"
ConnectionEntry
:
:
AppendPendingQForNonFocusedWindows
[
ci
=
%
s
]
"
"
pendingQ
count
=
%
zu
for
non
focused
window
\
n
"
mConnInfo
-
>
HashKey
(
)
.
get
(
)
result
.
Length
(
)
)
)
;
}
void
ConnectionEntry
:
:
RemoveEmptyPendingQ
(
)
{
mPendingQ
.
RemoveEmptyPendingQ
(
)
;
}
void
ConnectionEntry
:
:
InsertTransactionSorted
(
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
&
pendingQ
PendingTransactionInfo
*
pendingTransInfo
bool
aInsertAsFirstForTheSamePriority
)
{
mPendingQ
.
InsertTransactionSorted
(
pendingQ
pendingTransInfo
aInsertAsFirstForTheSamePriority
)
;
}
void
ConnectionEntry
:
:
ReschedTransaction
(
nsHttpTransaction
*
aTrans
)
{
mPendingQ
.
ReschedTransaction
(
aTrans
)
;
}
void
ConnectionEntry
:
:
InsertTransaction
(
PendingTransactionInfo
*
pendingTransInfo
bool
aInsertAsFirstForTheSamePriority
)
{
mPendingQ
.
InsertTransaction
(
pendingTransInfo
aInsertAsFirstForTheSamePriority
)
;
}
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
*
ConnectionEntry
:
:
GetTransactionPendingQHelper
(
nsAHttpTransaction
*
trans
)
{
return
mPendingQ
.
GetTransactionPendingQHelper
(
trans
)
;
}
bool
ConnectionEntry
:
:
RestrictConnections
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
AvailableForDispatchNow
(
)
)
{
LOG
(
(
"
ConnectionEntry
:
:
RestrictConnections
%
p
%
s
restricted
due
to
"
"
active
>
=
h2
\
n
"
this
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
return
true
;
}
bool
doRestrict
=
mConnInfo
-
>
FirstHopSSL
(
)
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
&
&
mUsingSpdy
&
&
(
mHalfOpens
.
Length
(
)
|
|
mActiveConns
.
Length
(
)
)
;
if
(
!
doRestrict
)
{
return
false
;
}
if
(
UnconnectedHalfOpens
(
)
)
{
return
true
;
}
if
(
mUsingSpdy
&
&
mActiveConns
.
Length
(
)
)
{
bool
confirmedRestrict
=
false
;
for
(
uint32_t
index
=
0
;
index
<
mActiveConns
.
Length
(
)
;
+
+
index
)
{
HttpConnectionBase
*
conn
=
mActiveConns
[
index
]
;
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
if
(
(
connTCP
&
&
!
connTCP
-
>
ReportedNPN
(
)
)
|
|
conn
-
>
CanDirectlyActivate
(
)
)
{
confirmedRestrict
=
true
;
break
;
}
}
doRestrict
=
confirmedRestrict
;
if
(
!
confirmedRestrict
)
{
LOG
(
(
"
nsHttpConnectionMgr
spdy
connection
restriction
to
"
"
%
s
bypassed
.
\
n
"
mConnInfo
-
>
Origin
(
)
)
)
;
}
}
return
doRestrict
;
}
uint32_t
ConnectionEntry
:
:
TotalActiveConnections
(
)
const
{
return
mActiveConns
.
Length
(
)
+
UnconnectedHalfOpens
(
)
;
}
size_t
ConnectionEntry
:
:
UrgentStartQueueLength
(
)
{
return
mPendingQ
.
UrgentStartQueueLength
(
)
;
}
void
ConnectionEntry
:
:
PrintPendingQ
(
)
{
mPendingQ
.
PrintPendingQ
(
)
;
}
void
ConnectionEntry
:
:
Compact
(
)
{
mIdleConns
.
Compact
(
)
;
mActiveConns
.
Compact
(
)
;
mPendingQ
.
Compact
(
)
;
}
void
ConnectionEntry
:
:
CancelAllTransactions
(
nsresult
reason
)
{
mPendingQ
.
CancelAllTransactions
(
reason
)
;
}
}
}
