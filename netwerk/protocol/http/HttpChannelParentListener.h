#
ifndef
mozilla_net_HttpChannelCallbackWrapper_h
#
define
mozilla_net_HttpChannelCallbackWrapper_h
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIRedirectResultListener
.
h
"
#
include
"
nsINetworkInterceptController
.
h
"
#
include
"
nsIStreamListener
.
h
"
namespace
mozilla
{
namespace
net
{
class
HttpChannelParent
;
#
define
HTTP_CHANNEL_PARENT_LISTENER_IID
\
{
0xe409da52
0xda76
0x4eb7
\
{
0xa7
0xf4
0x03
0x3d
0x88
0xac
0x87
0x6d
}
}
class
HttpChannelParentListener
final
:
public
nsIInterfaceRequestor
public
nsIChannelEventSink
public
nsIRedirectResultListener
public
nsIStreamListener
public
nsINetworkInterceptController
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIREDIRECTRESULTLISTENER
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSINETWORKINTERCEPTCONTROLLER
NS_DECLARE_STATIC_IID_ACCESSOR
(
HTTP_CHANNEL_PARENT_LISTENER_IID
)
explicit
HttpChannelParentListener
(
HttpChannelParent
*
aInitialChannel
)
;
MOZ_MUST_USE
nsresult
DivertTo
(
nsIStreamListener
*
aListener
)
;
MOZ_MUST_USE
nsresult
SuspendForDiversion
(
)
;
void
SetupInterception
(
const
nsHttpResponseHead
&
aResponseHead
)
;
void
SetupInterceptionAfterRedirect
(
bool
aShouldIntercept
)
;
void
ClearInterceptedChannel
(
nsIStreamListener
*
aListener
)
;
private
:
virtual
~
HttpChannelParentListener
(
)
=
default
;
MOZ_MUST_USE
nsresult
ResumeForDiversion
(
)
;
nsCOMPtr
<
nsIStreamListener
>
mNextListener
;
uint32_t
mRedirectChannelId
;
bool
mSuspendedForDiversion
;
bool
mShouldIntercept
;
bool
mShouldSuspendIntercept
;
bool
mInterceptCanceled
;
nsAutoPtr
<
nsHttpResponseHead
>
mSynthesizedResponseHead
;
nsCOMPtr
<
nsIInterceptedChannel
>
mInterceptedChannel
;
nsCOMPtr
<
nsINetworkInterceptController
>
mInterceptController
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
HttpChannelParentListener
HTTP_CHANNEL_PARENT_LISTENER_IID
)
}
}
#
endif
