#
include
"
HttpLog
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
#
define
TLS_EARLY_DATA_NOT_AVAILABLE
0
#
define
TLS_EARLY_DATA_AVAILABLE_BUT_NOT_USED
1
#
define
TLS_EARLY_DATA_AVAILABLE_AND_USED
2
#
include
"
mozilla
/
glean
/
NetwerkProtocolHttpMetrics
.
h
"
#
include
"
HttpConnectionBase
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsISocketTransport
.
h
"
#
include
"
ConnectionEntry
.
h
"
namespace
mozilla
{
namespace
net
{
HttpConnectionBase
:
:
HttpConnectionBase
(
)
{
LOG
(
(
"
Creating
HttpConnectionBase
%
p
\
n
"
this
)
)
;
}
void
HttpConnectionBase
:
:
BootstrapTimings
(
TimingStruct
times
)
{
mBootstrappedTimingsSet
=
true
;
mBootstrappedTimings
=
times
;
}
void
HttpConnectionBase
:
:
SetSecurityCallbacks
(
nsIInterfaceRequestor
*
aCallbacks
)
{
MutexAutoLock
lock
(
mCallbacksLock
)
;
mCallbacks
=
new
nsMainThreadPtrHolder
<
nsIInterfaceRequestor
>
(
"
nsHttpConnection
:
:
mCallbacks
"
aCallbacks
false
)
;
}
void
HttpConnectionBase
:
:
SetTrafficCategory
(
HttpTrafficCategory
aCategory
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
aCategory
=
=
HttpTrafficCategory
:
:
eInvalid
|
|
mTrafficCategory
.
Contains
(
aCategory
)
)
{
return
;
}
Unused
<
<
mTrafficCategory
.
AppendElement
(
aCategory
)
;
}
void
HttpConnectionBase
:
:
ChangeConnectionState
(
ConnectionState
aState
)
{
LOG
(
(
"
HttpConnectionBase
:
:
ChangeConnectionState
this
=
%
p
(
%
d
-
>
%
d
)
"
this
static_cast
<
uint32_t
>
(
mConnectionState
)
static_cast
<
uint32_t
>
(
aState
)
)
)
;
if
(
aState
<
=
mConnectionState
)
{
return
;
}
mConnectionState
=
aState
;
}
void
HttpConnectionBase
:
:
RecordConnectionCloseTelemetry
(
nsresult
aReason
)
{
auto
key
=
nsPrintfCString
(
"
%
d_
%
d_
%
d_
%
d_
%
d
"
static_cast
<
uint32_t
>
(
Version
(
)
)
mConnInfo
-
>
EndToEndSSL
(
)
mConnInfo
-
>
GetIsTrrServiceChannel
(
)
static_cast
<
uint32_t
>
(
mExperienceState
)
static_cast
<
uint32_t
>
(
mConnectionState
)
)
;
SetCloseReason
(
ToCloseReason
(
aReason
)
)
;
LOG
(
(
"
RecordConnectionCloseTelemetry
key
=
%
s
reason
=
%
d
\
n
"
key
.
get
(
)
static_cast
<
uint32_t
>
(
mCloseReason
)
)
)
;
glean
:
:
http
:
:
connection_close_reason
.
Get
(
key
)
.
AccumulateSingleSample
(
static_cast
<
uint32_t
>
(
mCloseReason
)
)
;
}
void
HttpConnectionBase
:
:
RecordConnectionAddressType
(
)
{
if
(
mAddressTypeReported
)
{
return
;
}
NetAddr
addr
;
GetPeerAddr
(
&
addr
)
;
if
(
addr
.
GetIpAddressSpace
(
)
!
=
nsILoadInfo
:
:
IPAddressSpace
:
:
Public
)
{
return
;
}
if
(
mConnInfo
-
>
UsingProxy
(
)
)
{
return
;
}
nsAutoCString
key
(
HttpVersionToTelemetryLabel
(
Version
(
)
)
)
;
if
(
addr
.
IsIPAddrV4
(
)
)
{
key
.
Append
(
"
_ipv4
"
)
;
}
else
{
key
.
Append
(
"
_ipv6
"
)
;
}
mozilla
:
:
glean
:
:
networking
:
:
connection_address_type
.
Get
(
key
)
.
Add
(
1
)
;
mAddressTypeReported
=
true
;
}
void
HttpConnectionBase
:
:
ChangeState
(
HttpConnectionState
newState
)
{
LOG
(
(
"
HttpConnectionBase
:
:
ChangeState
%
d
-
>
%
d
[
this
=
%
p
]
"
mState
newState
this
)
)
;
mState
=
newState
;
}
nsresult
HttpConnectionBase
:
:
CheckTunnelIsNeeded
(
nsAHttpTransaction
*
aTransaction
)
{
switch
(
mState
)
{
case
HttpConnectionState
:
:
UNINITIALIZED
:
{
if
(
!
aTransaction
-
>
ConnectionInfo
(
)
-
>
UsingConnect
(
)
)
{
ChangeState
(
HttpConnectionState
:
:
REQUEST
)
;
return
NS_OK
;
}
ChangeState
(
HttpConnectionState
:
:
SETTING_UP_TUNNEL
)
;
}
[
[
fallthrough
]
]
;
case
HttpConnectionState
:
:
SETTING_UP_TUNNEL
:
{
nsresult
rv
=
SetupProxyConnectStream
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
ChangeState
(
HttpConnectionState
:
:
UNINITIALIZED
)
;
}
return
rv
;
}
case
HttpConnectionState
:
:
REQUEST
:
return
NS_OK
;
}
return
NS_OK
;
}
void
HttpConnectionBase
:
:
SetOwner
(
ConnectionEntry
*
aEntry
)
{
mOwnerEntry
=
aEntry
;
}
ConnectionEntry
*
HttpConnectionBase
:
:
OwnerEntry
(
)
const
{
return
mOwnerEntry
.
get
(
)
;
}
}
}
