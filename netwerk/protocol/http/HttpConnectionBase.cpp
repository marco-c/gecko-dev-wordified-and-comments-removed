#
include
"
HttpLog
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
#
define
TLS_EARLY_DATA_NOT_AVAILABLE
0
#
define
TLS_EARLY_DATA_AVAILABLE_BUT_NOT_USED
1
#
define
TLS_EARLY_DATA_AVAILABLE_AND_USED
2
#
include
"
mozilla
/
glean
/
NetwerkProtocolHttpMetrics
.
h
"
#
include
"
HttpConnectionBase
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsISocketTransport
.
h
"
namespace
mozilla
{
namespace
net
{
HttpConnectionBase
:
:
HttpConnectionBase
(
)
{
LOG
(
(
"
Creating
HttpConnectionBase
%
p
\
n
"
this
)
)
;
}
void
HttpConnectionBase
:
:
BootstrapTimings
(
TimingStruct
times
)
{
mBootstrappedTimingsSet
=
true
;
mBootstrappedTimings
=
times
;
}
void
HttpConnectionBase
:
:
SetSecurityCallbacks
(
nsIInterfaceRequestor
*
aCallbacks
)
{
MutexAutoLock
lock
(
mCallbacksLock
)
;
mCallbacks
=
new
nsMainThreadPtrHolder
<
nsIInterfaceRequestor
>
(
"
nsHttpConnection
:
:
mCallbacks
"
aCallbacks
false
)
;
}
void
HttpConnectionBase
:
:
SetTrafficCategory
(
HttpTrafficCategory
aCategory
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
aCategory
=
=
HttpTrafficCategory
:
:
eInvalid
|
|
mTrafficCategory
.
Contains
(
aCategory
)
)
{
return
;
}
Unused
<
<
mTrafficCategory
.
AppendElement
(
aCategory
)
;
}
void
HttpConnectionBase
:
:
ChangeConnectionState
(
ConnectionState
aState
)
{
LOG
(
(
"
HttpConnectionBase
:
:
ChangeConnectionState
this
=
%
p
(
%
d
-
>
%
d
)
"
this
static_cast
<
uint32_t
>
(
mConnectionState
)
static_cast
<
uint32_t
>
(
aState
)
)
)
;
if
(
aState
<
=
mConnectionState
)
{
return
;
}
mConnectionState
=
aState
;
}
void
HttpConnectionBase
:
:
RecordConnectionCloseTelemetry
(
nsresult
aReason
)
{
auto
key
=
nsPrintfCString
(
"
%
d_
%
d_
%
d_
%
d_
%
d
"
static_cast
<
uint32_t
>
(
Version
(
)
)
mConnInfo
-
>
EndToEndSSL
(
)
mConnInfo
-
>
GetIsTrrServiceChannel
(
)
static_cast
<
uint32_t
>
(
mExperienceState
)
static_cast
<
uint32_t
>
(
mConnectionState
)
)
;
SetCloseReason
(
ToCloseReason
(
aReason
)
)
;
LOG
(
(
"
RecordConnectionCloseTelemetry
key
=
%
s
reason
=
%
d
\
n
"
key
.
get
(
)
static_cast
<
uint32_t
>
(
mCloseReason
)
)
)
;
glean
:
:
http
:
:
connection_close_reason
.
Get
(
key
)
.
AccumulateSingleSample
(
static_cast
<
uint32_t
>
(
mCloseReason
)
)
;
}
}
}
