#
ifndef
nsHttpResponseHead_h__
#
define
nsHttpResponseHead_h__
#
include
"
nsHttpHeaderArray
.
h
"
#
include
"
nsHttp
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
#
ifdef
Status
typedef
Status
__StatusTmp
;
#
undef
Status
typedef
__StatusTmp
Status
;
#
endif
class
nsIHttpHeaderVisitor
;
namespace
IPC
{
template
<
typename
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
net
{
class
nsHttpResponseHead
{
public
:
nsHttpResponseHead
(
)
=
default
;
nsHttpResponseHead
(
const
nsHttpResponseHead
&
aOther
)
;
nsHttpResponseHead
&
operator
=
(
const
nsHttpResponseHead
&
aOther
)
;
PUSH_IGNORE_THREAD_SAFETY
void
Enter
(
)
const
{
mRecursiveMutex
.
Lock
(
)
;
}
void
Exit
(
)
const
{
mRecursiveMutex
.
Unlock
(
)
;
}
POP_THREAD_SAFETY
HttpVersion
Version
(
)
;
uint16_t
Status
(
)
const
;
void
StatusText
(
nsACString
&
aStatusText
)
;
int64_t
ContentLength
(
)
;
void
ContentType
(
nsACString
&
aContentType
)
const
;
void
ContentCharset
(
nsACString
&
aContentCharset
)
;
bool
Public
(
)
;
bool
Private
(
)
;
bool
NoStore
(
)
;
bool
NoCache
(
)
;
bool
Immutable
(
)
;
int64_t
TotalEntitySize
(
)
;
[
[
nodiscard
]
]
nsresult
SetHeader
(
const
nsACString
&
h
const
nsACString
&
v
bool
m
=
false
)
;
[
[
nodiscard
]
]
nsresult
SetHeader
(
const
nsHttpAtom
&
h
const
nsACString
&
v
bool
m
=
false
)
;
[
[
nodiscard
]
]
nsresult
GetHeader
(
const
nsHttpAtom
&
h
nsACString
&
v
)
const
;
void
ClearHeader
(
const
nsHttpAtom
&
h
)
;
void
ClearHeaders
(
)
;
bool
HasHeaderValue
(
const
nsHttpAtom
&
h
const
char
*
v
)
;
bool
HasHeader
(
const
nsHttpAtom
&
h
)
const
;
void
SetContentType
(
const
nsACString
&
s
)
;
void
SetContentCharset
(
const
nsACString
&
s
)
;
void
SetContentLength
(
int64_t
)
;
void
Flatten
(
nsACString
&
bool
pruneTransients
)
;
void
FlattenNetworkOriginalHeaders
(
nsACString
&
buf
)
;
[
[
nodiscard
]
]
nsresult
ParseCachedHead
(
const
char
*
block
)
;
[
[
nodiscard
]
]
nsresult
ParseCachedOriginalHeaders
(
char
*
block
)
;
void
ParseStatusLine
(
const
nsACString
&
line
)
;
[
[
nodiscard
]
]
nsresult
ParseHeaderLine
(
const
nsACString
&
line
)
;
[
[
nodiscard
]
]
nsresult
ComputeFreshnessLifetime
(
uint32_t
*
)
;
[
[
nodiscard
]
]
nsresult
ComputeCurrentAge
(
uint32_t
now
uint32_t
requestTime
uint32_t
*
result
)
;
bool
MustValidate
(
)
;
bool
MustValidateIfExpired
(
)
;
bool
StaleWhileRevalidate
(
uint32_t
now
uint32_t
expiration
)
;
bool
IsResumable
(
)
;
bool
ExpiresInPast
(
)
;
void
UpdateHeaders
(
nsHttpResponseHead
*
aOther
)
;
void
Reset
(
)
;
[
[
nodiscard
]
]
nsresult
GetLastModifiedValue
(
uint32_t
*
result
)
;
bool
operator
=
=
(
const
nsHttpResponseHead
&
aOther
)
const
;
[
[
nodiscard
]
]
nsresult
VisitHeaders
(
nsIHttpHeaderVisitor
*
visitor
nsHttpHeaderArray
:
:
VisitorFilter
filter
)
;
[
[
nodiscard
]
]
nsresult
GetOriginalHeader
(
const
nsHttpAtom
&
aHeader
nsIHttpHeaderVisitor
*
aVisitor
)
;
bool
HasContentType
(
)
const
;
bool
HasContentCharset
(
)
;
bool
GetContentTypeOptionsHeader
(
nsACString
&
aOutput
)
const
;
private
:
[
[
nodiscard
]
]
nsresult
SetHeader_locked
(
const
nsHttpAtom
&
atom
const
nsACString
&
h
const
nsACString
&
v
bool
m
=
false
)
;
void
AssignDefaultStatusText
(
)
;
void
ParseVersion
(
const
char
*
)
;
void
ParseCacheControl
(
const
char
*
)
;
void
ParsePragma
(
const
char
*
)
;
void
ParseStatusLine_locked
(
const
nsACString
&
line
)
;
[
[
nodiscard
]
]
nsresult
ParseHeaderLine_locked
(
const
nsACString
&
line
bool
originalFromNetHeaders
)
;
[
[
nodiscard
]
]
nsresult
ParseDateHeader
(
const
nsHttpAtom
&
header
uint32_t
*
result
)
const
;
[
[
nodiscard
]
]
nsresult
GetAgeValue
(
uint32_t
*
result
)
;
[
[
nodiscard
]
]
nsresult
GetMaxAgeValue
(
uint32_t
*
result
)
;
[
[
nodiscard
]
]
nsresult
GetStaleWhileRevalidateValue
(
uint32_t
*
result
)
;
[
[
nodiscard
]
]
nsresult
GetDateValue
(
uint32_t
*
result
)
;
[
[
nodiscard
]
]
nsresult
GetExpiresValue
(
uint32_t
*
result
)
;
bool
ExpiresInPast_locked
(
)
const
;
[
[
nodiscard
]
]
nsresult
GetAgeValue_locked
(
uint32_t
*
result
)
const
;
[
[
nodiscard
]
]
nsresult
GetExpiresValue_locked
(
uint32_t
*
result
)
const
;
[
[
nodiscard
]
]
nsresult
GetMaxAgeValue_locked
(
uint32_t
*
result
)
const
;
[
[
nodiscard
]
]
nsresult
GetStaleWhileRevalidateValue_locked
(
uint32_t
*
result
)
const
;
[
[
nodiscard
]
]
nsresult
GetDateValue_locked
(
uint32_t
*
result
)
const
{
return
ParseDateHeader
(
nsHttp
:
:
Date
result
)
;
}
[
[
nodiscard
]
]
nsresult
GetLastModifiedValue_locked
(
uint32_t
*
result
)
const
{
return
ParseDateHeader
(
nsHttp
:
:
Last_Modified
result
)
;
}
bool
NoCache_locked
(
)
const
{
MOZ_ASSERT_IF
(
mCacheControlNoCache
mHasCacheControl
)
;
return
mHasCacheControl
?
mCacheControlNoCache
:
mPragmaNoCache
;
}
private
:
nsHttpHeaderArray
mHeaders
;
HttpVersion
mVersion
{
HttpVersion
:
:
v1_1
}
;
uint16_t
mStatus
{
200
}
;
nsCString
mStatusText
;
int64_t
mContentLength
{
-
1
}
;
nsCString
mContentType
;
nsCString
mContentCharset
;
bool
mHasCacheControl
{
false
}
;
bool
mCacheControlPublic
{
false
}
;
bool
mCacheControlPrivate
{
false
}
;
bool
mCacheControlNoStore
{
false
}
;
bool
mCacheControlNoCache
{
false
}
;
bool
mCacheControlImmutable
{
false
}
;
bool
mCacheControlStaleWhileRevalidateSet
{
false
}
;
uint32_t
mCacheControlStaleWhileRevalidate
{
0
}
;
bool
mCacheControlMaxAgeSet
{
false
}
;
uint32_t
mCacheControlMaxAge
{
0
}
;
bool
mPragmaNoCache
{
false
}
;
mutable
RecursiveMutex
mRecursiveMutex
MOZ_UNANNOTATED
{
"
nsHttpResponseHead
.
mRecursiveMutex
"
}
;
bool
mInVisitHeaders
{
false
}
;
friend
struct
IPC
:
:
ParamTraits
<
nsHttpResponseHead
>
;
}
;
}
}
#
endif
