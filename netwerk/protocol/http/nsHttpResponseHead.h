#
ifndef
nsHttpResponseHead_h__
#
define
nsHttpResponseHead_h__
#
include
"
nsHttpHeaderArray
.
h
"
#
include
"
nsHttp
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
#
ifdef
Status
typedef
Status
__StatusTmp
;
#
undef
Status
typedef
__StatusTmp
Status
;
#
endif
class
nsIHttpHeaderVisitor
;
namespace
IPC
{
template
<
typename
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
net
{
class
nsHttpResponseHead
{
public
:
nsHttpResponseHead
(
)
:
mVersion
(
HttpVersion
:
:
v1_1
)
mStatus
(
200
)
mContentLength
(
-
1
)
mHasCacheControl
(
false
)
mCacheControlPublic
(
false
)
mCacheControlPrivate
(
false
)
mCacheControlNoStore
(
false
)
mCacheControlNoCache
(
false
)
mCacheControlImmutable
(
false
)
mCacheControlStaleWhileRevalidateSet
(
false
)
mCacheControlStaleWhileRevalidate
(
0
)
mCacheControlMaxAgeSet
(
false
)
mCacheControlMaxAge
(
0
)
mPragmaNoCache
(
false
)
mRecursiveMutex
(
"
nsHttpResponseHead
.
mRecursiveMutex
"
)
mInVisitHeaders
(
false
)
{
}
nsHttpResponseHead
(
const
nsHttpResponseHead
&
aOther
)
;
nsHttpResponseHead
&
operator
=
(
const
nsHttpResponseHead
&
aOther
)
;
void
Enter
(
)
{
mRecursiveMutex
.
Lock
(
)
;
}
void
Exit
(
)
{
mRecursiveMutex
.
Unlock
(
)
;
}
HttpVersion
Version
(
)
;
uint16_t
Status
(
)
const
;
void
StatusText
(
nsACString
&
aStatusText
)
;
int64_t
ContentLength
(
)
;
void
ContentType
(
nsACString
&
aContentType
)
const
;
void
ContentCharset
(
nsACString
&
aContentCharset
)
;
bool
Public
(
)
;
bool
Private
(
)
;
bool
NoStore
(
)
;
bool
NoCache
(
)
;
bool
Immutable
(
)
;
int64_t
TotalEntitySize
(
)
;
[
[
nodiscard
]
]
nsresult
SetHeader
(
const
nsACString
&
h
const
nsACString
&
v
bool
m
=
false
)
;
[
[
nodiscard
]
]
nsresult
SetHeader
(
nsHttpAtom
h
const
nsACString
&
v
bool
m
=
false
)
;
[
[
nodiscard
]
]
nsresult
GetHeader
(
nsHttpAtom
h
nsACString
&
v
)
;
void
ClearHeader
(
nsHttpAtom
h
)
;
void
ClearHeaders
(
)
;
bool
HasHeaderValue
(
nsHttpAtom
h
const
char
*
v
)
;
bool
HasHeader
(
nsHttpAtom
h
)
const
;
void
SetContentType
(
const
nsACString
&
s
)
;
void
SetContentCharset
(
const
nsACString
&
s
)
;
void
SetContentLength
(
int64_t
)
;
void
Flatten
(
nsACString
&
bool
pruneTransients
)
;
void
FlattenNetworkOriginalHeaders
(
nsACString
&
buf
)
;
[
[
nodiscard
]
]
nsresult
ParseCachedHead
(
const
char
*
block
)
;
[
[
nodiscard
]
]
nsresult
ParseCachedOriginalHeaders
(
char
*
block
)
;
void
ParseStatusLine
(
const
nsACString
&
line
)
;
[
[
nodiscard
]
]
nsresult
ParseHeaderLine
(
const
nsACString
&
line
)
;
[
[
nodiscard
]
]
nsresult
ComputeFreshnessLifetime
(
uint32_t
*
)
;
[
[
nodiscard
]
]
nsresult
ComputeCurrentAge
(
uint32_t
now
uint32_t
requestTime
uint32_t
*
result
)
;
bool
MustValidate
(
)
;
bool
MustValidateIfExpired
(
)
;
bool
StaleWhileRevalidate
(
uint32_t
now
uint32_t
expiration
)
;
bool
IsResumable
(
)
;
bool
ExpiresInPast
(
)
;
void
UpdateHeaders
(
nsHttpResponseHead
*
headers
)
;
void
Reset
(
)
;
[
[
nodiscard
]
]
nsresult
GetAgeValue
(
uint32_t
*
result
)
;
[
[
nodiscard
]
]
nsresult
GetMaxAgeValue
(
uint32_t
*
result
)
;
[
[
nodiscard
]
]
nsresult
GetStaleWhileRevalidateValue
(
uint32_t
*
result
)
;
[
[
nodiscard
]
]
nsresult
GetDateValue
(
uint32_t
*
result
)
;
[
[
nodiscard
]
]
nsresult
GetExpiresValue
(
uint32_t
*
result
)
;
[
[
nodiscard
]
]
nsresult
GetLastModifiedValue
(
uint32_t
*
result
)
;
bool
operator
=
=
(
const
nsHttpResponseHead
&
aOther
)
const
;
[
[
nodiscard
]
]
nsresult
VisitHeaders
(
nsIHttpHeaderVisitor
*
visitor
nsHttpHeaderArray
:
:
VisitorFilter
filter
)
;
[
[
nodiscard
]
]
nsresult
GetOriginalHeader
(
nsHttpAtom
aHeader
nsIHttpHeaderVisitor
*
aVisitor
)
;
bool
HasContentType
(
)
const
;
bool
HasContentCharset
(
)
;
bool
GetContentTypeOptionsHeader
(
nsACString
&
aOutput
)
;
private
:
[
[
nodiscard
]
]
nsresult
SetHeader_locked
(
nsHttpAtom
atom
const
nsACString
&
h
const
nsACString
&
v
bool
m
=
false
)
;
void
AssignDefaultStatusText
(
)
;
void
ParseVersion
(
const
char
*
)
;
void
ParseCacheControl
(
const
char
*
)
;
void
ParsePragma
(
const
char
*
)
;
void
ParseStatusLine_locked
(
const
nsACString
&
line
)
;
[
[
nodiscard
]
]
nsresult
ParseHeaderLine_locked
(
const
nsACString
&
line
bool
originalFromNetHeaders
)
;
[
[
nodiscard
]
]
nsresult
ParseDateHeader
(
nsHttpAtom
header
uint32_t
*
result
)
const
;
bool
ExpiresInPast_locked
(
)
const
;
[
[
nodiscard
]
]
nsresult
GetAgeValue_locked
(
uint32_t
*
result
)
const
;
[
[
nodiscard
]
]
nsresult
GetExpiresValue_locked
(
uint32_t
*
result
)
const
;
[
[
nodiscard
]
]
nsresult
GetMaxAgeValue_locked
(
uint32_t
*
result
)
const
;
[
[
nodiscard
]
]
nsresult
GetStaleWhileRevalidateValue_locked
(
uint32_t
*
result
)
const
;
[
[
nodiscard
]
]
nsresult
GetDateValue_locked
(
uint32_t
*
result
)
const
{
return
ParseDateHeader
(
nsHttp
:
:
Date
result
)
;
}
[
[
nodiscard
]
]
nsresult
GetLastModifiedValue_locked
(
uint32_t
*
result
)
const
{
return
ParseDateHeader
(
nsHttp
:
:
Last_Modified
result
)
;
}
bool
NoCache_locked
(
)
const
{
MOZ_ASSERT_IF
(
mCacheControlNoCache
mHasCacheControl
)
;
return
mHasCacheControl
?
mCacheControlNoCache
:
mPragmaNoCache
;
}
private
:
nsHttpHeaderArray
mHeaders
;
HttpVersion
mVersion
;
uint16_t
mStatus
;
nsCString
mStatusText
;
int64_t
mContentLength
;
nsCString
mContentType
;
nsCString
mContentCharset
;
bool
mHasCacheControl
;
bool
mCacheControlPublic
;
bool
mCacheControlPrivate
;
bool
mCacheControlNoStore
;
bool
mCacheControlNoCache
;
bool
mCacheControlImmutable
;
bool
mCacheControlStaleWhileRevalidateSet
;
uint32_t
mCacheControlStaleWhileRevalidate
;
bool
mCacheControlMaxAgeSet
;
uint32_t
mCacheControlMaxAge
;
bool
mPragmaNoCache
;
mutable
RecursiveMutex
mRecursiveMutex
;
bool
mInVisitHeaders
;
friend
struct
IPC
:
:
ParamTraits
<
nsHttpResponseHead
>
;
}
;
}
}
#
endif
