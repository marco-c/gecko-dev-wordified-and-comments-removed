#
include
"
HttpLog
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
NullHttpTransaction
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
mozilla
/
net
/
DashboardTypes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsHttpConnectionMgr
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIDNSByTypeRecord
.
h
"
#
include
"
nsIDNSRecord
.
h
"
#
include
"
nsIDNSListener
.
h
"
#
include
"
nsIDNSService
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIRequestContext
.
h
"
#
include
"
nsISocketTransport
.
h
"
#
include
"
nsISocketTransportService
.
h
"
#
include
"
nsITransport
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsInterfaceRequestorAgg
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
ConnectionHandle
.
h
"
#
include
"
HttpConnectionUDP
.
h
"
#
include
"
SpeculativeTransaction
.
h
"
#
include
"
TCPFastOpenLayer
.
h
"
namespace
mozilla
{
namespace
net
{
NS_IMPL_ISUPPORTS
(
nsHttpConnectionMgr
nsIObserver
)
nsHttpConnectionMgr
:
:
nsHttpConnectionMgr
(
)
:
mReentrantMonitor
(
"
nsHttpConnectionMgr
.
mReentrantMonitor
"
)
mMaxUrgentExcessiveConns
(
0
)
mMaxConns
(
0
)
mMaxPersistConnsPerHost
(
0
)
mMaxPersistConnsPerProxy
(
0
)
mMaxRequestDelay
(
0
)
mThrottleEnabled
(
false
)
mThrottleVersion
(
2
)
mThrottleSuspendFor
(
0
)
mThrottleResumeFor
(
0
)
mThrottleReadLimit
(
0
)
mThrottleReadInterval
(
0
)
mThrottleHoldTime
(
0
)
mThrottleMaxTime
(
0
)
mBeConservativeForProxy
(
true
)
mIsShuttingDown
(
false
)
mNumActiveConns
(
0
)
mNumIdleConns
(
0
)
mNumSpdyHttp3ActiveConns
(
0
)
mNumHalfOpenConns
(
0
)
mTimeOfNextWakeUp
(
UINT64_MAX
)
mPruningNoTraffic
(
false
)
mTimeoutTickArmed
(
false
)
mTimeoutTickNext
(
1
)
mCurrentTopLevelOuterContentWindowId
(
0
)
mThrottlingInhibitsReading
(
false
)
mActiveTabTransactionsExist
(
false
)
mActiveTabUnthrottledTransactionsExist
(
false
)
{
LOG
(
(
"
Creating
nsHttpConnectionMgr
%
p
\
n
"
this
)
)
;
}
nsHttpConnectionMgr
:
:
~
nsHttpConnectionMgr
(
)
{
LOG
(
(
"
Destroying
nsHttpConnectionMgr
%
p
\
n
"
this
)
)
;
MOZ_ASSERT
(
mCoalescingHash
.
Count
(
)
=
=
0
)
;
if
(
mTimeoutTick
)
mTimeoutTick
-
>
Cancel
(
)
;
}
nsresult
nsHttpConnectionMgr
:
:
EnsureSocketThreadTarget
(
)
{
nsCOMPtr
<
nsIEventTarget
>
sts
;
nsCOMPtr
<
nsIIOService
>
ioService
=
services
:
:
GetIOService
(
)
;
if
(
ioService
)
{
nsCOMPtr
<
nsISocketTransportService
>
realSTS
=
services
:
:
GetSocketTransportService
(
)
;
sts
=
do_QueryInterface
(
realSTS
)
;
}
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
if
(
mSocketThreadTarget
|
|
mIsShuttingDown
)
return
NS_OK
;
mSocketThreadTarget
=
sts
;
return
sts
?
NS_OK
:
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
nsHttpConnectionMgr
:
:
Init
(
uint16_t
maxUrgentExcessiveConns
uint16_t
maxConns
uint16_t
maxPersistConnsPerHost
uint16_t
maxPersistConnsPerProxy
uint16_t
maxRequestDelay
bool
throttleEnabled
uint32_t
throttleVersion
uint32_t
throttleSuspendFor
uint32_t
throttleResumeFor
uint32_t
throttleReadLimit
uint32_t
throttleReadInterval
uint32_t
throttleHoldTime
uint32_t
throttleMaxTime
bool
beConservativeForProxy
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
Init
\
n
"
)
)
;
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
mMaxUrgentExcessiveConns
=
maxUrgentExcessiveConns
;
mMaxConns
=
maxConns
;
mMaxPersistConnsPerHost
=
maxPersistConnsPerHost
;
mMaxPersistConnsPerProxy
=
maxPersistConnsPerProxy
;
mMaxRequestDelay
=
maxRequestDelay
;
mThrottleEnabled
=
throttleEnabled
;
mThrottleVersion
=
throttleVersion
;
mThrottleSuspendFor
=
throttleSuspendFor
;
mThrottleResumeFor
=
throttleResumeFor
;
mThrottleReadLimit
=
throttleReadLimit
;
mThrottleReadInterval
=
throttleReadInterval
;
mThrottleHoldTime
=
throttleHoldTime
;
mThrottleMaxTime
=
TimeDuration
:
:
FromMilliseconds
(
throttleMaxTime
)
;
mBeConservativeForProxy
=
beConservativeForProxy
;
mIsShuttingDown
=
false
;
}
return
EnsureSocketThreadTarget
(
)
;
}
class
BoolWrapper
:
public
ARefBase
{
public
:
BoolWrapper
(
)
:
mBool
(
false
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
BoolWrapper
override
)
public
:
bool
mBool
;
private
:
virtual
~
BoolWrapper
(
)
=
default
;
}
;
nsresult
nsHttpConnectionMgr
:
:
Shutdown
(
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
Shutdown
\
n
"
)
)
;
RefPtr
<
BoolWrapper
>
shutdownWrapper
=
new
BoolWrapper
(
)
;
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
if
(
!
mSocketThreadTarget
)
return
NS_OK
;
nsresult
rv
=
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgShutdown
0
shutdownWrapper
)
;
mIsShuttingDown
=
true
;
mSocketThreadTarget
=
nullptr
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
unable
to
post
SHUTDOWN
message
"
)
;
return
rv
;
}
}
SpinEventLoopUntil
(
[
&
shutdownWrapper
]
(
)
{
return
shutdownWrapper
-
>
mBool
;
}
)
;
return
NS_OK
;
}
class
ConnEvent
:
public
Runnable
{
public
:
ConnEvent
(
nsHttpConnectionMgr
*
mgr
nsConnEventHandler
handler
int32_t
iparam
ARefBase
*
vparam
)
:
Runnable
(
"
net
:
:
ConnEvent
"
)
mMgr
(
mgr
)
mHandler
(
handler
)
mIParam
(
iparam
)
mVParam
(
vparam
)
{
}
NS_IMETHOD
Run
(
)
override
{
(
mMgr
-
>
*
mHandler
)
(
mIParam
mVParam
)
;
return
NS_OK
;
}
private
:
virtual
~
ConnEvent
(
)
=
default
;
RefPtr
<
nsHttpConnectionMgr
>
mMgr
;
nsConnEventHandler
mHandler
;
int32_t
mIParam
;
RefPtr
<
ARefBase
>
mVParam
;
}
;
nsresult
nsHttpConnectionMgr
:
:
PostEvent
(
nsConnEventHandler
handler
int32_t
iparam
ARefBase
*
vparam
)
{
Unused
<
<
EnsureSocketThreadTarget
(
)
;
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
nsresult
rv
;
if
(
!
mSocketThreadTarget
)
{
NS_WARNING
(
"
cannot
post
event
if
not
initialized
"
)
;
rv
=
NS_ERROR_NOT_INITIALIZED
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
ConnEvent
(
this
handler
iparam
vparam
)
;
rv
=
mSocketThreadTarget
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
return
rv
;
}
void
nsHttpConnectionMgr
:
:
PruneDeadConnectionsAfter
(
uint32_t
timeInSeconds
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
PruneDeadConnectionsAfter
\
n
"
)
)
;
if
(
!
mTimer
)
mTimer
=
NS_NewTimer
(
)
;
if
(
mTimer
)
{
mTimeOfNextWakeUp
=
timeInSeconds
+
NowInSeconds
(
)
;
mTimer
-
>
Init
(
this
timeInSeconds
*
1000
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
else
{
NS_WARNING
(
"
failed
to
create
:
timer
for
pruning
the
dead
connections
!
"
)
;
}
}
void
nsHttpConnectionMgr
:
:
ConditionallyStopPruneDeadConnectionsTimer
(
)
{
if
(
mNumIdleConns
|
|
(
mNumActiveConns
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
)
)
return
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
StopPruneDeadConnectionsTimer
\
n
"
)
)
;
mTimeOfNextWakeUp
=
UINT64_MAX
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
}
void
nsHttpConnectionMgr
:
:
ConditionallyStopTimeoutTick
(
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ConditionallyStopTimeoutTick
"
"
armed
=
%
d
active
=
%
d
\
n
"
mTimeoutTickArmed
mNumActiveConns
)
)
;
if
(
!
mTimeoutTickArmed
)
return
;
if
(
mNumActiveConns
)
return
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
ConditionallyStopTimeoutTick
stop
=
=
true
\
n
"
)
)
;
mTimeoutTick
-
>
Cancel
(
)
;
mTimeoutTickArmed
=
false
;
}
NS_IMETHODIMP
nsHttpConnectionMgr
:
:
Observe
(
nsISupports
*
subject
const
char
*
topic
const
char16_t
*
data
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
Observe
[
topic
=
\
"
%
s
\
"
]
\
n
"
topic
)
)
;
if
(
0
=
=
strcmp
(
topic
NS_TIMER_CALLBACK_TOPIC
)
)
{
nsCOMPtr
<
nsITimer
>
timer
=
do_QueryInterface
(
subject
)
;
if
(
timer
=
=
mTimer
)
{
Unused
<
<
PruneDeadConnections
(
)
;
}
else
if
(
timer
=
=
mTimeoutTick
)
{
TimeoutTick
(
)
;
}
else
if
(
timer
=
=
mTrafficTimer
)
{
Unused
<
<
PruneNoTraffic
(
)
;
}
else
if
(
timer
=
=
mThrottleTicker
)
{
ThrottlerTick
(
)
;
}
else
if
(
timer
=
=
mDelayedResumeReadTimer
)
{
ResumeBackgroundThrottledTransactions
(
)
;
}
else
{
MOZ_ASSERT
(
false
"
unexpected
timer
-
callback
"
)
;
LOG
(
(
"
Unexpected
timer
object
\
n
"
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
return
NS_OK
;
}
nsresult
nsHttpConnectionMgr
:
:
AddTransaction
(
HttpTransactionShell
*
trans
int32_t
priority
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
AddTransaction
[
trans
=
%
p
%
d
]
\
n
"
trans
priority
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgNewTransaction
priority
trans
-
>
AsHttpTransaction
(
)
)
;
}
class
NewTransactionData
:
public
ARefBase
{
public
:
NewTransactionData
(
nsHttpTransaction
*
trans
int32_t
priority
nsHttpTransaction
*
transWithStickyConn
)
:
mTrans
(
trans
)
mPriority
(
priority
)
mTransWithStickyConn
(
transWithStickyConn
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
NewTransactionData
override
)
RefPtr
<
nsHttpTransaction
>
mTrans
;
int32_t
mPriority
;
RefPtr
<
nsHttpTransaction
>
mTransWithStickyConn
;
private
:
virtual
~
NewTransactionData
(
)
=
default
;
}
;
nsresult
nsHttpConnectionMgr
:
:
AddTransactionWithStickyConn
(
HttpTransactionShell
*
trans
int32_t
priority
HttpTransactionShell
*
transWithStickyConn
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
AddTransactionWithStickyConn
"
"
[
trans
=
%
p
%
d
transWithStickyConn
=
%
p
]
\
n
"
trans
priority
transWithStickyConn
)
)
;
RefPtr
<
NewTransactionData
>
data
=
new
NewTransactionData
(
trans
-
>
AsHttpTransaction
(
)
priority
transWithStickyConn
-
>
AsHttpTransaction
(
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgNewTransactionWithStickyConn
0
data
)
;
}
nsresult
nsHttpConnectionMgr
:
:
RescheduleTransaction
(
HttpTransactionShell
*
trans
int32_t
priority
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
RescheduleTransaction
[
trans
=
%
p
%
d
]
\
n
"
trans
priority
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgReschedTransaction
priority
trans
-
>
AsHttpTransaction
(
)
)
;
}
void
nsHttpConnectionMgr
:
:
UpdateClassOfServiceOnTransaction
(
HttpTransactionShell
*
trans
uint32_t
classOfService
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
UpdateClassOfServiceOnTransaction
[
trans
=
%
p
"
"
classOfService
=
%
"
PRIu32
"
]
\
n
"
trans
static_cast
<
uint32_t
>
(
classOfService
)
)
)
;
Unused
<
<
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgUpdateClassOfServiceOnTransaction
static_cast
<
int32_t
>
(
classOfService
)
trans
-
>
AsHttpTransaction
(
)
)
;
}
nsresult
nsHttpConnectionMgr
:
:
CancelTransaction
(
HttpTransactionShell
*
trans
nsresult
reason
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
CancelTransaction
[
trans
=
%
p
reason
=
%
"
PRIx32
"
]
\
n
"
trans
static_cast
<
uint32_t
>
(
reason
)
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgCancelTransaction
static_cast
<
int32_t
>
(
reason
)
trans
-
>
AsHttpTransaction
(
)
)
;
}
nsresult
nsHttpConnectionMgr
:
:
PruneDeadConnections
(
)
{
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgPruneDeadConnections
)
;
}
nsresult
nsHttpConnectionMgr
:
:
PruneNoTraffic
(
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
PruneNoTraffic
\
n
"
)
)
;
mPruningNoTraffic
=
true
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgPruneNoTraffic
)
;
}
nsresult
nsHttpConnectionMgr
:
:
VerifyTraffic
(
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
VerifyTraffic
\
n
"
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgVerifyTraffic
)
;
}
nsresult
nsHttpConnectionMgr
:
:
DoShiftReloadConnectionCleanup
(
)
{
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgDoShiftReloadConnectionCleanup
0
nullptr
)
;
}
nsresult
nsHttpConnectionMgr
:
:
DoShiftReloadConnectionCleanupWithConnInfo
(
nsHttpConnectionInfo
*
aCI
)
{
if
(
!
aCI
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsHttpConnectionInfo
>
ci
=
aCI
-
>
Clone
(
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgDoShiftReloadConnectionCleanup
0
ci
)
;
}
class
SpeculativeConnectArgs
:
public
ARefBase
{
public
:
SpeculativeConnectArgs
(
)
:
mFetchHTTPSRR
(
false
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SpeculativeConnectArgs
override
)
public
:
RefPtr
<
SpeculativeTransaction
>
mTrans
;
bool
mFetchHTTPSRR
;
private
:
virtual
~
SpeculativeConnectArgs
(
)
=
default
;
NS_DECL_OWNINGTHREAD
}
;
nsresult
nsHttpConnectionMgr
:
:
SpeculativeConnect
(
nsHttpConnectionInfo
*
ci
nsIInterfaceRequestor
*
callbacks
uint32_t
caps
SpeculativeTransaction
*
aTransaction
bool
aFetchHTTPSRR
)
{
if
(
!
IsNeckoChild
(
)
&
&
NS_IsMainThread
(
)
)
{
net_EnsurePSMInit
(
)
;
}
LOG
(
(
"
nsHttpConnectionMgr
:
:
SpeculativeConnect
[
ci
=
%
s
]
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
nsCOMPtr
<
nsISpeculativeConnectionOverrider
>
overrider
=
do_GetInterface
(
callbacks
)
;
bool
allow1918
=
overrider
?
overrider
-
>
GetAllow1918
(
)
:
false
;
if
(
(
!
allow1918
)
&
&
ci
&
&
ci
-
>
HostIsLocalIPLiteral
(
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
SpeculativeConnect
skipping
RFC1918
"
"
address
[
%
s
]
"
ci
-
>
Origin
(
)
)
)
;
return
NS_OK
;
}
RefPtr
<
SpeculativeConnectArgs
>
args
=
new
SpeculativeConnectArgs
(
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
wrappedCallbacks
;
NS_NewInterfaceRequestorAggregation
(
callbacks
nullptr
getter_AddRefs
(
wrappedCallbacks
)
)
;
caps
|
=
ci
-
>
GetAnonymous
(
)
?
NS_HTTP_LOAD_ANONYMOUS
:
0
;
caps
|
=
NS_HTTP_ERROR_SOFTLY
;
args
-
>
mTrans
=
aTransaction
?
aTransaction
:
new
SpeculativeTransaction
(
ci
wrappedCallbacks
caps
)
;
args
-
>
mFetchHTTPSRR
=
aFetchHTTPSRR
;
if
(
overrider
)
{
args
-
>
mTrans
-
>
SetParallelSpeculativeConnectLimit
(
overrider
-
>
GetParallelSpeculativeConnectLimit
(
)
)
;
args
-
>
mTrans
-
>
SetIgnoreIdle
(
overrider
-
>
GetIgnoreIdle
(
)
)
;
args
-
>
mTrans
-
>
SetIsFromPredictor
(
overrider
-
>
GetIsFromPredictor
(
)
)
;
args
-
>
mTrans
-
>
SetAllow1918
(
overrider
-
>
GetAllow1918
(
)
)
;
}
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgSpeculativeConnect
0
args
)
;
}
nsresult
nsHttpConnectionMgr
:
:
GetSocketThreadTarget
(
nsIEventTarget
*
*
target
)
{
Unused
<
<
EnsureSocketThreadTarget
(
)
;
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
nsCOMPtr
<
nsIEventTarget
>
temp
(
mSocketThreadTarget
)
;
temp
.
forget
(
target
)
;
return
NS_OK
;
}
nsresult
nsHttpConnectionMgr
:
:
ReclaimConnection
(
HttpConnectionBase
*
conn
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ReclaimConnection
[
conn
=
%
p
]
\
n
"
conn
)
)
;
Unused
<
<
EnsureSocketThreadTarget
(
)
;
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
if
(
!
mSocketThreadTarget
)
{
NS_WARNING
(
"
cannot
post
event
if
not
initialized
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
HttpConnectionBase
>
connRef
(
conn
)
;
RefPtr
<
nsHttpConnectionMgr
>
self
(
this
)
;
return
mSocketThreadTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
nsHttpConnectionMgr
:
:
CallReclaimConnection
"
[
conn
{
std
:
:
move
(
connRef
)
}
self
{
std
:
:
move
(
self
)
}
]
(
)
{
self
-
>
OnMsgReclaimConnection
(
conn
)
;
}
)
)
;
}
class
nsCompleteUpgradeData
:
public
ARefBase
{
public
:
nsCompleteUpgradeData
(
nsHttpTransaction
*
aTrans
nsIHttpUpgradeListener
*
aListener
bool
aJsWrapped
)
:
mTrans
(
aTrans
)
mUpgradeListener
(
aListener
)
mJsWrapped
(
aJsWrapped
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsCompleteUpgradeData
override
)
RefPtr
<
nsHttpTransaction
>
mTrans
;
nsCOMPtr
<
nsIHttpUpgradeListener
>
mUpgradeListener
;
nsCOMPtr
<
nsISocketTransport
>
mSocketTransport
;
nsCOMPtr
<
nsIAsyncInputStream
>
mSocketIn
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mSocketOut
;
bool
mJsWrapped
;
private
:
virtual
~
nsCompleteUpgradeData
(
)
{
NS_ReleaseOnMainThread
(
"
nsCompleteUpgradeData
.
mUpgradeListener
"
mUpgradeListener
.
forget
(
)
)
;
}
}
;
nsresult
nsHttpConnectionMgr
:
:
CompleteUpgrade
(
HttpTransactionShell
*
aTrans
nsIHttpUpgradeListener
*
aUpgradeListener
)
{
nsCOMPtr
<
nsIXPConnectWrappedJS
>
wrapper
=
do_QueryInterface
(
aUpgradeListener
)
;
bool
wrapped
=
!
!
wrapper
;
RefPtr
<
nsCompleteUpgradeData
>
data
=
new
nsCompleteUpgradeData
(
aTrans
-
>
AsHttpTransaction
(
)
aUpgradeListener
wrapped
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgCompleteUpgrade
0
data
)
;
}
nsresult
nsHttpConnectionMgr
:
:
UpdateParam
(
nsParamName
name
uint16_t
value
)
{
uint32_t
param
=
(
uint32_t
(
name
)
<
<
16
)
|
uint32_t
(
value
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgUpdateParam
static_cast
<
int32_t
>
(
param
)
nullptr
)
;
}
nsresult
nsHttpConnectionMgr
:
:
ProcessPendingQ
(
nsHttpConnectionInfo
*
aCI
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ProcessPendingQ
[
ci
=
%
s
]
\
n
"
aCI
-
>
HashKey
(
)
.
get
(
)
)
)
;
RefPtr
<
nsHttpConnectionInfo
>
ci
;
if
(
aCI
)
{
ci
=
aCI
-
>
Clone
(
)
;
}
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgProcessPendingQ
0
ci
)
;
}
nsresult
nsHttpConnectionMgr
:
:
ProcessPendingQ
(
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ProcessPendingQ
[
All
CI
]
\
n
"
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgProcessPendingQ
0
nullptr
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgUpdateRequestTokenBucket
(
int32_t
ARefBase
*
param
)
{
EventTokenBucket
*
tokenBucket
=
static_cast
<
EventTokenBucket
*
>
(
param
)
;
gHttpHandler
-
>
SetRequestTokenBucket
(
tokenBucket
)
;
}
nsresult
nsHttpConnectionMgr
:
:
UpdateRequestTokenBucket
(
EventTokenBucket
*
aBucket
)
{
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgUpdateRequestTokenBucket
0
aBucket
)
;
}
nsresult
nsHttpConnectionMgr
:
:
ClearConnectionHistory
(
)
{
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgClearConnectionHistory
0
nullptr
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgClearConnectionHistory
(
int32_t
ARefBase
*
param
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgClearConnectionHistory
"
)
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
ConnectionEntry
>
ent
=
iter
.
Data
(
)
;
if
(
ent
-
>
IdleConnectionsLength
(
)
=
=
0
&
&
ent
-
>
ActiveConnsLength
(
)
=
=
0
&
&
ent
-
>
HalfOpensLength
(
)
=
=
0
&
&
ent
-
>
UrgentStartQueueLength
(
)
=
=
0
&
&
ent
-
>
PendingQueueLength
(
)
=
=
0
&
&
ent
-
>
HalfOpenFastOpenBackupsLength
(
)
=
=
0
&
&
!
ent
-
>
mDoNotDestroy
)
{
iter
.
Remove
(
)
;
}
}
}
nsresult
nsHttpConnectionMgr
:
:
CloseIdleConnection
(
nsHttpConnection
*
conn
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
CloseIdleConnection
%
p
conn
=
%
p
"
this
conn
)
)
;
if
(
!
conn
-
>
ConnectionInfo
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
conn
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
)
;
if
(
!
ent
|
|
NS_FAILED
(
ent
-
>
CloseIdleConnection
(
conn
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
nsresult
nsHttpConnectionMgr
:
:
RemoveIdleConnection
(
nsHttpConnection
*
conn
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
RemoveIdleConnection
%
p
conn
=
%
p
"
this
conn
)
)
;
if
(
!
conn
-
>
ConnectionInfo
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
conn
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
)
;
if
(
!
ent
|
|
NS_FAILED
(
ent
-
>
RemoveIdleConnection
(
conn
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
HttpConnectionBase
*
nsHttpConnectionMgr
:
:
FindCoalescableConnectionByHashKey
(
ConnectionEntry
*
ent
const
nsCString
&
key
bool
justKidding
bool
aNoHttp3
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
ent
-
>
mConnInfo
)
;
nsHttpConnectionInfo
*
ci
=
ent
-
>
mConnInfo
;
nsTArray
<
nsWeakPtr
>
*
listOfWeakConns
=
mCoalescingHash
.
Get
(
key
)
;
if
(
!
listOfWeakConns
)
{
return
nullptr
;
}
uint32_t
listLen
=
listOfWeakConns
-
>
Length
(
)
;
for
(
uint32_t
j
=
0
;
j
<
listLen
;
)
{
RefPtr
<
HttpConnectionBase
>
potentialMatch
=
do_QueryReferent
(
listOfWeakConns
-
>
ElementAt
(
j
)
)
;
if
(
!
potentialMatch
)
{
LOG
(
(
"
FindCoalescableConnectionByHashKey
(
)
found
old
conn
%
p
that
has
"
"
null
weak
ptr
-
removing
\
n
"
listOfWeakConns
-
>
ElementAt
(
j
)
.
get
(
)
)
)
;
if
(
j
!
=
listLen
-
1
)
{
listOfWeakConns
-
>
Elements
(
)
[
j
]
=
listOfWeakConns
-
>
Elements
(
)
[
listLen
-
1
]
;
}
listOfWeakConns
-
>
RemoveLastElement
(
)
;
MOZ_ASSERT
(
listOfWeakConns
-
>
Length
(
)
=
=
listLen
-
1
)
;
listLen
-
-
;
continue
;
}
if
(
aNoHttp3
&
&
potentialMatch
-
>
UsingHttp3
(
)
)
{
j
+
+
;
continue
;
}
bool
couldJoin
;
if
(
justKidding
)
{
couldJoin
=
potentialMatch
-
>
TestJoinConnection
(
ci
-
>
GetOrigin
(
)
ci
-
>
OriginPort
(
)
)
;
}
else
{
couldJoin
=
potentialMatch
-
>
JoinConnection
(
ci
-
>
GetOrigin
(
)
ci
-
>
OriginPort
(
)
)
;
}
if
(
couldJoin
)
{
LOG
(
(
"
FindCoalescableConnectionByHashKey
(
)
found
match
conn
=
%
p
key
=
%
s
"
"
newCI
=
%
s
matchedCI
=
%
s
join
ok
\
n
"
potentialMatch
.
get
(
)
key
.
get
(
)
ci
-
>
HashKey
(
)
.
get
(
)
potentialMatch
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
.
get
(
)
)
)
;
return
potentialMatch
.
get
(
)
;
}
LOG
(
(
"
FindCoalescableConnectionByHashKey
(
)
found
match
conn
=
%
p
key
=
%
s
"
"
newCI
=
%
s
matchedCI
=
%
s
join
failed
\
n
"
potentialMatch
.
get
(
)
key
.
get
(
)
ci
-
>
HashKey
(
)
.
get
(
)
potentialMatch
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
.
get
(
)
)
)
;
+
+
j
;
}
if
(
!
listLen
)
{
LOG
(
(
"
FindCoalescableConnectionByHashKey
(
)
removing
empty
list
element
\
n
"
)
)
;
mCoalescingHash
.
Remove
(
key
)
;
}
return
nullptr
;
}
static
void
BuildOriginFrameHashKey
(
nsACString
&
newKey
nsHttpConnectionInfo
*
ci
const
nsACString
&
host
int32_t
port
)
{
newKey
.
Assign
(
host
)
;
if
(
ci
-
>
GetAnonymous
(
)
)
{
newKey
.
AppendLiteral
(
"
~
A
:
"
)
;
}
else
{
newKey
.
AppendLiteral
(
"
~
.
:
"
)
;
}
newKey
.
AppendInt
(
port
)
;
newKey
.
AppendLiteral
(
"
/
[
"
)
;
nsAutoCString
suffix
;
ci
-
>
GetOriginAttributes
(
)
.
CreateSuffix
(
suffix
)
;
newKey
.
Append
(
suffix
)
;
newKey
.
AppendLiteral
(
"
]
viaORIGIN
.
FRAME
"
)
;
}
HttpConnectionBase
*
nsHttpConnectionMgr
:
:
FindCoalescableConnection
(
ConnectionEntry
*
ent
bool
justKidding
bool
aNoHttp3
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
ent
-
>
mConnInfo
)
;
nsHttpConnectionInfo
*
ci
=
ent
-
>
mConnInfo
;
LOG
(
(
"
FindCoalescableConnection
%
s
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
nsCString
newKey
;
BuildOriginFrameHashKey
(
newKey
ci
ci
-
>
GetOrigin
(
)
ci
-
>
OriginPort
(
)
)
;
HttpConnectionBase
*
conn
=
FindCoalescableConnectionByHashKey
(
ent
newKey
justKidding
aNoHttp3
)
;
if
(
conn
)
{
LOG
(
(
"
FindCoalescableConnection
(
%
s
)
match
conn
%
p
on
frame
key
%
s
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
conn
newKey
.
get
(
)
)
)
;
return
conn
;
}
uint32_t
keyLen
=
ent
-
>
mCoalescingKeys
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
keyLen
;
+
+
i
)
{
conn
=
FindCoalescableConnectionByHashKey
(
ent
ent
-
>
mCoalescingKeys
[
i
]
justKidding
aNoHttp3
)
;
if
(
conn
)
{
LOG
(
(
"
FindCoalescableConnection
(
%
s
)
match
conn
%
p
on
dns
key
%
s
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
conn
ent
-
>
mCoalescingKeys
[
i
]
.
get
(
)
)
)
;
return
conn
;
}
}
LOG
(
(
"
FindCoalescableConnection
(
%
s
)
no
matching
conn
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
return
nullptr
;
}
void
nsHttpConnectionMgr
:
:
UpdateCoalescingForNewConn
(
HttpConnectionBase
*
newConn
ConnectionEntry
*
ent
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
newConn
)
;
MOZ_ASSERT
(
newConn
-
>
ConnectionInfo
(
)
)
;
MOZ_ASSERT
(
ent
)
;
MOZ_ASSERT
(
mCT
.
GetWeak
(
newConn
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
)
=
=
ent
)
;
HttpConnectionBase
*
existingConn
=
FindCoalescableConnection
(
ent
true
false
)
;
if
(
existingConn
)
{
if
(
newConn
-
>
UsingHttp3
(
)
&
&
existingConn
-
>
UsingSpdy
(
)
)
{
LOG
(
(
"
UpdateCoalescingForNewConn
(
)
found
existing
active
H2
conn
that
"
"
could
have
served
newConn
but
new
connection
is
H3
therefore
"
"
close
the
H2
conncetion
"
)
)
;
existingConn
-
>
DontReuse
(
)
;
}
else
{
LOG
(
(
"
UpdateCoalescingForNewConn
(
)
found
existing
active
conn
that
could
"
"
have
served
newConn
"
"
graceful
close
of
newConn
=
%
p
to
migrate
to
existingConn
%
p
\
n
"
newConn
existingConn
)
)
;
newConn
-
>
DontReuse
(
)
;
return
;
}
}
if
(
!
newConn
-
>
CanDirectlyActivate
(
)
)
{
return
;
}
uint32_t
keyLen
=
ent
-
>
mCoalescingKeys
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
keyLen
;
+
+
i
)
{
LOG
(
(
"
UpdateCoalescingForNewConn
(
)
registering
newConn
%
p
%
s
under
key
%
s
\
n
"
newConn
newConn
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
.
get
(
)
ent
-
>
mCoalescingKeys
[
i
]
.
get
(
)
)
)
;
nsTArray
<
nsWeakPtr
>
*
listOfWeakConns
=
mCoalescingHash
.
Get
(
ent
-
>
mCoalescingKeys
[
i
]
)
;
if
(
!
listOfWeakConns
)
{
LOG
(
(
"
UpdateCoalescingForNewConn
(
)
need
new
list
element
\
n
"
)
)
;
listOfWeakConns
=
new
nsTArray
<
nsWeakPtr
>
(
1
)
;
mCoalescingHash
.
Put
(
ent
-
>
mCoalescingKeys
[
i
]
listOfWeakConns
)
;
}
listOfWeakConns
-
>
AppendElement
(
do_GetWeakReference
(
static_cast
<
nsISupportsWeakReference
*
>
(
newConn
)
)
)
;
}
ent
-
>
MakeAllDontReuseExcept
(
newConn
)
;
}
void
nsHttpConnectionMgr
:
:
ReportSpdyConnection
(
nsHttpConnection
*
conn
bool
usingSpdy
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
!
conn
-
>
ConnectionInfo
(
)
)
{
return
;
}
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
conn
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
)
;
if
(
!
ent
|
|
!
usingSpdy
)
{
return
;
}
ent
-
>
mUsingSpdy
=
true
;
mNumSpdyHttp3ActiveConns
+
+
;
uint32_t
ttl
=
conn
-
>
TimeToLive
(
)
;
uint64_t
timeOfExpire
=
NowInSeconds
(
)
+
ttl
;
if
(
!
mTimer
|
|
timeOfExpire
<
mTimeOfNextWakeUp
)
{
PruneDeadConnectionsAfter
(
ttl
)
;
}
UpdateCoalescingForNewConn
(
conn
ent
)
;
nsresult
rv
=
ProcessPendingQ
(
ent
-
>
mConnInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ReportSpdyConnection
conn
=
%
p
ent
=
%
p
"
"
failed
to
process
pending
queue
(
%
08x
)
\
n
"
conn
ent
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
rv
=
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgProcessAllSpdyPendingQ
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ReportSpdyConnection
conn
=
%
p
ent
=
%
p
"
"
failed
to
post
event
(
%
08x
)
\
n
"
conn
ent
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
void
nsHttpConnectionMgr
:
:
ReportHttp3Connection
(
HttpConnectionBase
*
conn
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
!
conn
-
>
ConnectionInfo
(
)
)
{
return
;
}
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
conn
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
)
;
if
(
!
ent
)
{
return
;
}
mNumSpdyHttp3ActiveConns
+
+
;
UpdateCoalescingForNewConn
(
conn
ent
)
;
nsresult
rv
=
ProcessPendingQ
(
ent
-
>
mConnInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ReportHttp3Connection
conn
=
%
p
ent
=
%
p
"
"
failed
to
process
pending
queue
(
%
08x
)
\
n
"
conn
ent
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
rv
=
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgProcessAllSpdyPendingQ
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ReportHttp3Connection
conn
=
%
p
ent
=
%
p
"
"
failed
to
post
event
(
%
08x
)
\
n
"
conn
ent
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
bool
nsHttpConnectionMgr
:
:
DispatchPendingQ
(
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
&
pendingQ
ConnectionEntry
*
ent
bool
considerAll
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
PendingTransactionInfo
*
pendingTransInfo
=
nullptr
;
nsresult
rv
;
bool
dispatchedSuccessfully
=
false
;
for
(
uint32_t
i
=
0
;
i
<
pendingQ
.
Length
(
)
;
)
{
pendingTransInfo
=
pendingQ
[
i
]
;
bool
alreadyHalfOpenOrWaitingForTLS
=
pendingTransInfo
-
>
IsAlreadyClaimedInitializingConn
(
)
;
rv
=
TryDispatchTransaction
(
ent
alreadyHalfOpenOrWaitingForTLS
|
|
!
!
pendingTransInfo
-
>
Transaction
(
)
-
>
TunnelProvider
(
)
pendingTransInfo
)
;
if
(
NS_SUCCEEDED
(
rv
)
|
|
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
dispatching
pending
transaction
.
.
.
\
n
"
)
)
;
}
else
{
LOG
(
(
"
removing
pending
transaction
based
on
"
"
TryDispatchTransaction
returning
hard
error
%
"
PRIx32
"
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
if
(
pendingQ
.
RemoveElement
(
pendingTransInfo
)
)
{
dispatchedSuccessfully
=
true
;
continue
;
}
LOG
(
(
"
transaction
not
found
in
pending
queue
\
n
"
)
)
;
}
if
(
dispatchedSuccessfully
&
&
!
considerAll
)
break
;
+
+
i
;
}
return
dispatchedSuccessfully
;
}
uint32_t
nsHttpConnectionMgr
:
:
MaxPersistConnections
(
ConnectionEntry
*
ent
)
const
{
if
(
ent
-
>
mConnInfo
-
>
UsingHttpProxy
(
)
&
&
!
ent
-
>
mConnInfo
-
>
UsingConnect
(
)
)
{
return
static_cast
<
uint32_t
>
(
mMaxPersistConnsPerProxy
)
;
}
return
static_cast
<
uint32_t
>
(
mMaxPersistConnsPerHost
)
;
}
void
nsHttpConnectionMgr
:
:
PreparePendingQForDispatching
(
ConnectionEntry
*
ent
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
&
pendingQ
bool
considerAll
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
pendingQ
.
Clear
(
)
;
uint32_t
totalCount
=
ent
-
>
TotalActiveConnections
(
)
;
uint32_t
maxPersistConns
=
MaxPersistConnections
(
ent
)
;
uint32_t
availableConnections
=
maxPersistConns
>
totalCount
?
maxPersistConns
-
totalCount
:
0
;
if
(
!
availableConnections
)
{
return
;
}
if
(
!
gHttpHandler
-
>
ActiveTabPriority
(
)
)
{
ent
-
>
AppendPendingQForFocusedWindow
(
0
pendingQ
availableConnections
)
;
return
;
}
uint32_t
maxFocusedWindowConnections
=
availableConnections
*
gHttpHandler
-
>
FocusedWindowTransactionRatio
(
)
;
MOZ_ASSERT
(
maxFocusedWindowConnections
<
availableConnections
)
;
if
(
!
maxFocusedWindowConnections
)
{
maxFocusedWindowConnections
=
1
;
}
if
(
!
considerAll
)
{
ent
-
>
AppendPendingQForFocusedWindow
(
mCurrentTopLevelOuterContentWindowId
pendingQ
maxFocusedWindowConnections
)
;
if
(
pendingQ
.
IsEmpty
(
)
)
{
ent
-
>
AppendPendingQForNonFocusedWindows
(
mCurrentTopLevelOuterContentWindowId
pendingQ
availableConnections
)
;
}
return
;
}
uint32_t
maxNonFocusedWindowConnections
=
availableConnections
-
maxFocusedWindowConnections
;
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
remainingPendingQ
;
ent
-
>
AppendPendingQForFocusedWindow
(
mCurrentTopLevelOuterContentWindowId
pendingQ
maxFocusedWindowConnections
)
;
if
(
maxNonFocusedWindowConnections
)
{
ent
-
>
AppendPendingQForNonFocusedWindows
(
mCurrentTopLevelOuterContentWindowId
remainingPendingQ
maxNonFocusedWindowConnections
)
;
}
if
(
remainingPendingQ
.
Length
(
)
<
maxNonFocusedWindowConnections
)
{
ent
-
>
AppendPendingQForFocusedWindow
(
mCurrentTopLevelOuterContentWindowId
pendingQ
maxNonFocusedWindowConnections
-
remainingPendingQ
.
Length
(
)
)
;
}
else
if
(
pendingQ
.
Length
(
)
<
maxFocusedWindowConnections
)
{
ent
-
>
AppendPendingQForNonFocusedWindows
(
mCurrentTopLevelOuterContentWindowId
remainingPendingQ
maxFocusedWindowConnections
-
pendingQ
.
Length
(
)
)
;
}
MOZ_ASSERT
(
pendingQ
.
Length
(
)
+
remainingPendingQ
.
Length
(
)
<
=
availableConnections
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
PreparePendingQForDispatching
"
"
focused
window
pendingQ
.
Length
(
)
=
%
zu
"
"
remainingPendingQ
.
Length
(
)
=
%
zu
\
n
"
pendingQ
.
Length
(
)
remainingPendingQ
.
Length
(
)
)
)
;
pendingQ
.
AppendElements
(
std
:
:
move
(
remainingPendingQ
)
)
;
}
bool
nsHttpConnectionMgr
:
:
ProcessPendingQForEntry
(
ConnectionEntry
*
ent
bool
considerAll
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
ProcessPendingQForEntry
"
"
[
ci
=
%
s
ent
=
%
p
active
=
%
zu
idle
=
%
zu
urgent
-
start
-
queue
=
%
zu
"
"
queued
=
%
zu
]
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
ent
ent
-
>
ActiveConnsLength
(
)
ent
-
>
IdleConnectionsLength
(
)
ent
-
>
UrgentStartQueueLength
(
)
ent
-
>
PendingQueueLength
(
)
)
)
;
if
(
LOG_ENABLED
(
)
)
{
ent
-
>
PrintPendingQ
(
)
;
ent
-
>
LogConnections
(
)
;
}
if
(
!
ent
-
>
PendingQueueLength
(
)
&
&
!
ent
-
>
UrgentStartQueueLength
(
)
)
{
return
false
;
}
ProcessSpdyPendingQ
(
ent
)
;
bool
dispatchedSuccessfully
=
false
;
if
(
ent
-
>
UrgentStartQueueLength
(
)
)
{
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
pendingQ
;
ent
-
>
AppendPendingUrgentStartQ
(
pendingQ
)
;
dispatchedSuccessfully
=
DispatchPendingQ
(
pendingQ
ent
considerAll
)
;
for
(
const
auto
&
transactionInfo
:
Reversed
(
pendingQ
)
)
{
ent
-
>
InsertTransaction
(
transactionInfo
)
;
}
}
if
(
dispatchedSuccessfully
&
&
!
considerAll
)
{
return
dispatchedSuccessfully
;
}
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
pendingQ
;
PreparePendingQForDispatching
(
ent
pendingQ
considerAll
)
;
if
(
pendingQ
.
IsEmpty
(
)
)
{
return
dispatchedSuccessfully
;
}
dispatchedSuccessfully
|
=
DispatchPendingQ
(
pendingQ
ent
considerAll
)
;
for
(
const
auto
&
transactionInfo
:
Reversed
(
pendingQ
)
)
{
ent
-
>
InsertTransaction
(
transactionInfo
true
)
;
}
if
(
considerAll
)
{
ent
-
>
RemoveEmptyPendingQ
(
)
;
}
return
dispatchedSuccessfully
;
}
bool
nsHttpConnectionMgr
:
:
ProcessPendingQForEntry
(
nsHttpConnectionInfo
*
ci
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
ci
-
>
HashKey
(
)
)
;
if
(
ent
)
return
ProcessPendingQForEntry
(
ent
false
)
;
return
false
;
}
bool
nsHttpConnectionMgr
:
:
AtActiveConnectionLimit
(
ConnectionEntry
*
ent
uint32_t
caps
)
{
nsHttpConnectionInfo
*
ci
=
ent
-
>
mConnInfo
;
uint32_t
totalCount
=
ent
-
>
TotalActiveConnections
(
)
;
if
(
ci
-
>
IsHttp3
(
)
)
{
return
totalCount
>
0
;
}
uint32_t
maxPersistConns
=
MaxPersistConnections
(
ent
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
AtActiveConnectionLimit
[
ci
=
%
s
caps
=
%
x
"
"
totalCount
=
%
u
maxPersistConns
=
%
u
]
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
caps
totalCount
maxPersistConns
)
)
;
if
(
caps
&
NS_HTTP_URGENT_START
)
{
if
(
totalCount
>
=
(
mMaxUrgentExcessiveConns
+
maxPersistConns
)
)
{
LOG
(
(
"
The
number
of
total
connections
are
greater
than
or
equal
to
sum
of
"
"
max
urgent
-
start
queue
length
and
the
number
of
max
persistent
"
"
connections
.
\
n
"
)
)
;
return
true
;
}
return
false
;
}
uint32_t
maxSocketCount
=
gHttpHandler
-
>
MaxSocketCount
(
)
;
if
(
mMaxConns
>
maxSocketCount
)
{
mMaxConns
=
maxSocketCount
;
LOG
(
(
"
nsHttpConnectionMgr
%
p
mMaxConns
dynamically
reduced
to
%
u
"
this
mMaxConns
)
)
;
}
if
(
mNumActiveConns
>
=
mMaxConns
)
{
LOG
(
(
"
num
active
conns
=
=
max
conns
\
n
"
)
)
;
return
true
;
}
bool
result
=
(
totalCount
>
=
maxPersistConns
)
;
LOG
(
(
"
AtActiveConnectionLimit
result
:
%
s
"
result
?
"
true
"
:
"
false
"
)
)
;
return
result
;
}
nsresult
nsHttpConnectionMgr
:
:
MakeNewConnection
(
ConnectionEntry
*
ent
PendingTransactionInfo
*
pendingTransInfo
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeNewConnection
%
p
ent
=
%
p
trans
=
%
p
"
this
ent
pendingTransInfo
-
>
Transaction
(
)
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
ent
-
>
FindConnToClaim
(
pendingTransInfo
)
)
{
return
NS_OK
;
}
nsHttpTransaction
*
trans
=
pendingTransInfo
-
>
Transaction
(
)
;
if
(
!
(
trans
-
>
Caps
(
)
&
NS_HTTP_DISALLOW_SPDY
)
&
&
(
trans
-
>
Caps
(
)
&
NS_HTTP_ALLOW_KEEPALIVE
)
&
&
ent
-
>
RestrictConnections
(
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeNewConnection
[
ci
=
%
s
]
"
"
Not
Available
Due
to
RestrictConnections
(
)
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
(
mNumIdleConns
+
mNumActiveConns
+
1
>
=
mMaxConns
)
&
&
mNumIdleConns
)
{
auto
iter
=
mCT
.
Iter
(
)
;
while
(
mNumIdleConns
+
mNumActiveConns
+
1
>
=
mMaxConns
&
&
!
iter
.
Done
(
)
)
{
RefPtr
<
ConnectionEntry
>
entry
=
iter
.
Data
(
)
;
entry
-
>
CloseIdleConnections
(
(
mNumIdleConns
+
mNumActiveConns
+
1
)
-
mMaxConns
)
;
iter
.
Next
(
)
;
}
}
if
(
(
mNumIdleConns
+
mNumActiveConns
+
1
>
=
mMaxConns
)
&
&
mNumActiveConns
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
)
{
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
ConnectionEntry
>
entry
=
iter
.
Data
(
)
;
while
(
entry
-
>
MakeFirstActiveSpdyConnDontReuse
(
)
)
{
if
(
mNumIdleConns
+
mNumActiveConns
+
1
<
=
mMaxConns
)
{
goto
outerLoopEnd
;
}
}
}
outerLoopEnd
:
;
}
if
(
AtActiveConnectionLimit
(
ent
trans
-
>
Caps
(
)
)
)
return
NS_ERROR_NOT_AVAILABLE
;
nsresult
rv
=
CreateTransport
(
ent
trans
trans
-
>
Caps
(
)
false
false
trans
-
>
ClassOfService
(
)
&
nsIClassOfService
:
:
UrgentStart
true
pendingTransInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeNewConnection
[
ci
=
%
s
trans
=
%
p
]
"
"
CreateTransport
(
)
hard
failure
.
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
trans
)
)
;
trans
-
>
Close
(
rv
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
rv
=
NS_ERROR_FAILURE
;
return
rv
;
}
return
NS_OK
;
}
nsresult
nsHttpConnectionMgr
:
:
TryDispatchTransaction
(
ConnectionEntry
*
ent
bool
onlyReusedConnection
PendingTransactionInfo
*
pendingTransInfo
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
nsHttpTransaction
*
trans
=
pendingTransInfo
-
>
Transaction
(
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
TryDispatchTransaction
without
conn
"
"
[
trans
=
%
p
ci
=
%
p
ci
=
%
s
caps
=
%
x
tunnelprovider
=
%
p
"
"
onlyreused
=
%
d
active
=
%
zu
idle
=
%
zu
]
\
n
"
trans
ent
-
>
mConnInfo
.
get
(
)
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
uint32_t
(
trans
-
>
Caps
(
)
)
trans
-
>
TunnelProvider
(
)
onlyReusedConnection
ent
-
>
ActiveConnsLength
(
)
ent
-
>
IdleConnectionsLength
(
)
)
)
;
uint32_t
caps
=
trans
-
>
Caps
(
)
;
RefPtr
<
HttpConnectionBase
>
unusedSpdyPersistentConnection
;
if
(
!
(
caps
&
NS_HTTP_DISALLOW_SPDY
)
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
)
{
RefPtr
<
HttpConnectionBase
>
conn
=
GetH2orH3ActiveConn
(
ent
(
!
gHttpHandler
-
>
IsHttp3Enabled
(
)
|
|
(
caps
&
NS_HTTP_DISALLOW_HTTP3
)
)
)
;
if
(
conn
)
{
if
(
trans
-
>
IsWebsocketUpgrade
(
)
&
&
!
conn
-
>
CanAcceptWebsocket
(
)
)
{
trans
-
>
DisableSpdy
(
)
;
caps
&
=
NS_HTTP_DISALLOW_SPDY
;
}
else
{
if
(
(
caps
&
NS_HTTP_ALLOW_KEEPALIVE
)
|
|
(
caps
&
NS_HTTP_ALLOW_SPDY_WITHOUT_KEEPALIVE
)
|
|
!
conn
-
>
IsExperienced
(
)
)
{
LOG
(
(
"
dispatch
to
spdy
:
[
conn
=
%
p
]
\
n
"
conn
.
get
(
)
)
)
;
trans
-
>
RemoveDispatchedAsBlocking
(
)
;
nsresult
rv
=
DispatchTransaction
(
ent
trans
conn
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
unusedSpdyPersistentConnection
=
conn
;
}
}
}
if
(
!
(
caps
&
NS_HTTP_LOAD_AS_BLOCKING
)
)
{
if
(
!
(
caps
&
NS_HTTP_LOAD_UNBLOCKED
)
)
{
nsIRequestContext
*
requestContext
=
trans
-
>
RequestContext
(
)
;
if
(
requestContext
)
{
uint32_t
blockers
=
0
;
if
(
NS_SUCCEEDED
(
requestContext
-
>
GetBlockingTransactionCount
(
&
blockers
)
)
&
&
blockers
)
{
LOG
(
(
"
blocked
by
request
context
:
[
rc
=
%
p
trans
=
%
p
blockers
=
%
d
]
\
n
"
requestContext
trans
blockers
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
}
}
}
else
{
trans
-
>
DispatchedAsBlocking
(
)
;
}
if
(
gHttpHandler
-
>
UseRequestTokenBucket
(
)
)
{
bool
runNow
=
trans
-
>
TryToRunPacedRequest
(
)
;
if
(
!
runNow
)
{
if
(
(
mNumActiveConns
-
mNumSpdyHttp3ActiveConns
)
<
=
gHttpHandler
-
>
RequestTokenBucketMinParallelism
(
)
)
{
runNow
=
true
;
}
else
if
(
caps
&
(
NS_HTTP_LOAD_AS_BLOCKING
|
NS_HTTP_LOAD_UNBLOCKED
)
)
{
runNow
=
true
;
}
}
if
(
!
runNow
)
{
LOG
(
(
"
blocked
due
to
rate
pacing
trans
=
%
p
\
n
"
trans
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
}
bool
idleConnsAllUrgent
=
false
;
if
(
caps
&
NS_HTTP_ALLOW_KEEPALIVE
)
{
nsresult
rv
=
TryDispatchTransactionOnIdleConn
(
ent
pendingTransInfo
true
&
idleConnsAllUrgent
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
dispatched
step
2
(
idle
)
trans
=
%
p
\
n
"
trans
)
)
;
return
NS_OK
;
}
}
if
(
caps
&
NS_HTTP_WAIT_HTTPSSVC_RESULT
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
onlyReusedConnection
)
{
nsresult
rv
=
MakeNewConnection
(
ent
pendingTransInfo
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
dispatched
step
4
(
async
new
conn
)
trans
=
%
p
\
n
"
trans
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
{
LOG
(
(
"
failed
step
4
(
%
"
PRIx32
"
)
trans
=
%
p
\
n
"
static_cast
<
uint32_t
>
(
rv
)
trans
)
)
;
return
rv
;
}
if
(
!
(
trans
-
>
ClassOfService
(
)
&
nsIClassOfService
:
:
UrgentStart
)
&
&
idleConnsAllUrgent
&
&
ent
-
>
ActiveConnsLength
(
)
<
MaxPersistConnections
(
ent
)
)
{
rv
=
TryDispatchTransactionOnIdleConn
(
ent
pendingTransInfo
false
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
dispatched
step
2a
(
idle
reuse
urgent
)
trans
=
%
p
\
n
"
trans
)
)
;
return
NS_OK
;
}
}
}
else
if
(
trans
-
>
TunnelProvider
(
)
&
&
trans
-
>
TunnelProvider
(
)
-
>
MaybeReTunnel
(
trans
)
)
{
LOG
(
(
"
sort
of
dispatched
step
4a
tunnel
requeue
trans
=
%
p
\
n
"
trans
)
)
;
return
NS_OK
;
}
if
(
unusedSpdyPersistentConnection
)
{
unusedSpdyPersistentConnection
-
>
DontReuse
(
)
;
}
LOG
(
(
"
not
dispatched
(
queued
)
trans
=
%
p
\
n
"
trans
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
nsHttpConnectionMgr
:
:
TryDispatchTransactionOnIdleConn
(
ConnectionEntry
*
ent
PendingTransactionInfo
*
pendingTransInfo
bool
respectUrgency
bool
*
allUrgent
)
{
bool
onlyUrgent
=
!
!
ent
-
>
IdleConnectionsLength
(
)
;
nsHttpTransaction
*
trans
=
pendingTransInfo
-
>
Transaction
(
)
;
bool
urgentTrans
=
trans
-
>
ClassOfService
(
)
&
nsIClassOfService
:
:
UrgentStart
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
TryDispatchTransactionOnIdleConn
ent
=
%
p
"
"
trans
=
%
p
urgent
=
%
d
"
ent
trans
urgentTrans
)
)
;
RefPtr
<
nsHttpConnection
>
conn
=
ent
-
>
GetIdleConnection
(
respectUrgency
urgentTrans
&
onlyUrgent
)
;
if
(
allUrgent
)
{
*
allUrgent
=
onlyUrgent
;
}
if
(
conn
)
{
ent
-
>
InsertIntoActiveConns
(
conn
)
;
nsresult
rv
=
DispatchTransaction
(
ent
trans
conn
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
nsHttpConnectionMgr
:
:
DispatchTransaction
(
ConnectionEntry
*
ent
nsHttpTransaction
*
trans
HttpConnectionBase
*
conn
)
{
uint32_t
caps
=
trans
-
>
Caps
(
)
;
int32_t
priority
=
trans
-
>
Priority
(
)
;
nsresult
rv
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
DispatchTransaction
"
"
[
ent
-
ci
=
%
s
%
p
trans
=
%
p
caps
=
%
x
conn
=
%
p
priority
=
%
d
isHttp2
=
%
d
"
"
isHttp3
=
%
d
]
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
ent
trans
caps
conn
priority
conn
-
>
UsingSpdy
(
)
conn
-
>
UsingHttp3
(
)
)
)
;
trans
-
>
CancelPacing
(
NS_OK
)
;
if
(
conn
-
>
UsingSpdy
(
)
|
|
conn
-
>
UsingHttp3
(
)
)
{
LOG
(
(
"
Spdy
Dispatch
Transaction
via
Activate
(
)
.
Transaction
host
=
%
s
"
"
Connection
host
=
%
s
\
n
"
trans
-
>
ConnectionInfo
(
)
-
>
Origin
(
)
conn
-
>
ConnectionInfo
(
)
-
>
Origin
(
)
)
)
;
rv
=
conn
-
>
Activate
(
trans
caps
priority
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
SPDY
Cannot
Fail
Dispatch
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
trans
-
>
GetPendingTime
(
)
.
IsNull
(
)
)
{
if
(
conn
-
>
UsingSpdy
(
)
)
{
AccumulateTimeDelta
(
Telemetry
:
:
TRANSACTION_WAIT_TIME_SPDY
trans
-
>
GetPendingTime
(
)
TimeStamp
:
:
Now
(
)
)
;
}
else
{
AccumulateTimeDelta
(
Telemetry
:
:
TRANSACTION_WAIT_TIME_HTTP3
trans
-
>
GetPendingTime
(
)
TimeStamp
:
:
Now
(
)
)
;
}
trans
-
>
SetPendingTime
(
false
)
;
}
return
rv
;
}
MOZ_ASSERT
(
conn
&
&
!
conn
-
>
Transaction
(
)
"
DispatchTranaction
(
)
on
non
spdy
active
connection
"
)
;
rv
=
DispatchAbstractTransaction
(
ent
trans
caps
conn
priority
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
trans
-
>
GetPendingTime
(
)
.
IsNull
(
)
)
{
AccumulateTimeDelta
(
Telemetry
:
:
TRANSACTION_WAIT_TIME_HTTP
trans
-
>
GetPendingTime
(
)
TimeStamp
:
:
Now
(
)
)
;
trans
-
>
SetPendingTime
(
false
)
;
}
return
rv
;
}
nsAHttpConnection
*
nsHttpConnectionMgr
:
:
MakeConnectionHandle
(
HttpConnectionBase
*
aWrapped
)
{
return
new
ConnectionHandle
(
aWrapped
)
;
}
nsresult
nsHttpConnectionMgr
:
:
DispatchAbstractTransaction
(
ConnectionEntry
*
ent
nsAHttpTransaction
*
aTrans
uint32_t
caps
HttpConnectionBase
*
conn
int32_t
priority
)
{
MOZ_ASSERT
(
ent
)
;
nsresult
rv
;
MOZ_ASSERT
(
!
conn
-
>
UsingSpdy
(
)
"
Spdy
Must
Not
Use
DispatchAbstractTransaction
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
DispatchAbstractTransaction
"
"
[
ci
=
%
s
trans
=
%
p
caps
=
%
x
conn
=
%
p
]
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
aTrans
caps
conn
)
)
;
RefPtr
<
nsAHttpTransaction
>
transaction
(
aTrans
)
;
RefPtr
<
ConnectionHandle
>
handle
=
new
ConnectionHandle
(
conn
)
;
transaction
-
>
SetConnection
(
handle
)
;
rv
=
conn
-
>
Activate
(
transaction
caps
priority
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
conn
-
>
Activate
failed
[
rv
=
%
"
PRIx32
"
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
DebugOnly
<
nsresult
>
rv_remove
=
ent
-
>
RemoveActiveConnection
(
conn
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv_remove
)
)
;
transaction
-
>
SetConnection
(
nullptr
)
;
handle
-
>
Reset
(
)
;
}
return
rv
;
}
void
nsHttpConnectionMgr
:
:
ReportProxyTelemetry
(
ConnectionEntry
*
ent
)
{
enum
{
PROXY_NONE
=
1
PROXY_HTTP
=
2
PROXY_SOCKS
=
3
PROXY_HTTPS
=
4
}
;
if
(
!
ent
-
>
mConnInfo
-
>
UsingProxy
(
)
)
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_PROXY_TYPE
PROXY_NONE
)
;
else
if
(
ent
-
>
mConnInfo
-
>
UsingHttpsProxy
(
)
)
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_PROXY_TYPE
PROXY_HTTPS
)
;
else
if
(
ent
-
>
mConnInfo
-
>
UsingHttpProxy
(
)
)
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_PROXY_TYPE
PROXY_HTTP
)
;
else
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_PROXY_TYPE
PROXY_SOCKS
)
;
}
nsresult
nsHttpConnectionMgr
:
:
ProcessNewTransaction
(
nsHttpTransaction
*
trans
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
NS_FAILED
(
trans
-
>
Status
(
)
)
)
{
LOG
(
(
"
transaction
was
canceled
.
.
.
dropping
event
!
\
n
"
)
)
;
return
NS_OK
;
}
trans
-
>
SetPendingTime
(
)
;
RefPtr
<
Http2PushedStreamWrapper
>
pushedStreamWrapper
=
trans
-
>
GetPushedStream
(
)
;
if
(
pushedStreamWrapper
)
{
Http2PushedStream
*
pushedStream
=
pushedStreamWrapper
-
>
GetStream
(
)
;
if
(
pushedStream
)
{
LOG
(
(
"
ProcessNewTransaction
%
p
tied
to
h2
session
push
%
p
\
n
"
trans
pushedStream
-
>
Session
(
)
)
)
;
return
pushedStream
-
>
Session
(
)
-
>
AddStream
(
trans
trans
-
>
Priority
(
)
false
false
nullptr
)
?
NS_OK
:
NS_ERROR_UNEXPECTED
;
}
}
nsresult
rv
=
NS_OK
;
nsHttpConnectionInfo
*
ci
=
trans
-
>
ConnectionInfo
(
)
;
MOZ_ASSERT
(
ci
)
;
ConnectionEntry
*
ent
=
GetOrCreateConnectionEntry
(
ci
!
!
trans
-
>
TunnelProvider
(
)
trans
-
>
Caps
(
)
&
NS_HTTP_DISALLOW_HTTP3
)
;
MOZ_ASSERT
(
ent
)
;
ReportProxyTelemetry
(
ent
)
;
nsAHttpConnection
*
wrappedConnection
=
trans
-
>
Connection
(
)
;
RefPtr
<
HttpConnectionBase
>
conn
;
RefPtr
<
PendingTransactionInfo
>
pendingTransInfo
;
if
(
wrappedConnection
)
conn
=
wrappedConnection
-
>
TakeHttpConnection
(
)
;
if
(
conn
)
{
MOZ_ASSERT
(
trans
-
>
Caps
(
)
&
NS_HTTP_STICKY_CONNECTION
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
ProcessNewTransaction
trans
=
%
p
"
"
sticky
connection
=
%
p
\
n
"
trans
conn
.
get
(
)
)
)
;
if
(
!
ent
-
>
IsInActiveConns
(
conn
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ProcessNewTransaction
trans
=
%
p
"
"
sticky
connection
=
%
p
needs
to
go
on
the
active
list
\
n
"
trans
conn
.
get
(
)
)
)
;
MOZ_ASSERT
(
!
ent
-
>
IsInIdleConnections
(
conn
)
)
;
MOZ_ASSERT
(
!
conn
-
>
IsExperienced
(
)
)
;
ent
-
>
InsertIntoActiveConns
(
conn
)
;
}
trans
-
>
SetConnection
(
nullptr
)
;
rv
=
DispatchTransaction
(
ent
trans
conn
)
;
}
else
{
if
(
!
ent
-
>
AllowHttp2
(
)
)
{
trans
-
>
DisableSpdy
(
)
;
}
pendingTransInfo
=
new
PendingTransactionInfo
(
trans
)
;
rv
=
TryDispatchTransaction
(
ent
!
!
trans
-
>
TunnelProvider
(
)
pendingTransInfo
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
ProcessNewTransaction
Dispatch
Immediately
trans
=
%
p
\
n
"
trans
)
)
;
return
rv
;
}
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
if
(
!
pendingTransInfo
)
{
pendingTransInfo
=
new
PendingTransactionInfo
(
trans
)
;
}
ent
-
>
InsertTransaction
(
pendingTransInfo
)
;
return
NS_OK
;
}
LOG
(
(
"
ProcessNewTransaction
Hard
Error
trans
=
%
p
rv
=
%
"
PRIx32
"
\
n
"
trans
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
rv
;
}
void
nsHttpConnectionMgr
:
:
IncrementActiveConnCount
(
)
{
mNumActiveConns
+
+
;
ActivateTimeoutTick
(
)
;
}
void
nsHttpConnectionMgr
:
:
DecrementActiveConnCount
(
HttpConnectionBase
*
conn
)
{
mNumActiveConns
-
-
;
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
if
(
!
connTCP
|
|
connTCP
-
>
EverUsedSpdy
(
)
)
mNumSpdyHttp3ActiveConns
-
-
;
ConditionallyStopTimeoutTick
(
)
;
}
void
nsHttpConnectionMgr
:
:
StartedConnect
(
)
{
mNumActiveConns
+
+
;
ActivateTimeoutTick
(
)
;
}
void
nsHttpConnectionMgr
:
:
RecvdConnect
(
)
{
mNumActiveConns
-
-
;
ConditionallyStopTimeoutTick
(
)
;
}
nsresult
nsHttpConnectionMgr
:
:
CreateTransport
(
ConnectionEntry
*
ent
nsAHttpTransaction
*
trans
uint32_t
caps
bool
speculative
bool
isFromPredictor
bool
urgentStart
bool
allow1918
PendingTransactionInfo
*
pendingTransInfo
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
(
speculative
&
&
!
pendingTransInfo
)
|
|
(
!
speculative
&
&
pendingTransInfo
)
)
;
RefPtr
<
HalfOpenSocket
>
sock
=
new
HalfOpenSocket
(
ent
trans
caps
speculative
isFromPredictor
urgentStart
)
;
if
(
speculative
)
{
sock
-
>
SetAllow1918
(
allow1918
)
;
}
nsresult
rv
=
sock
-
>
SetupPrimaryStreams
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
pendingTransInfo
)
{
DebugOnly
<
bool
>
claimed
=
pendingTransInfo
-
>
TryClaimingHalfOpen
(
sock
)
;
MOZ_ASSERT
(
claimed
)
;
}
ent
-
>
InsertIntoHalfOpens
(
sock
)
;
return
NS_OK
;
}
void
nsHttpConnectionMgr
:
:
DispatchSpdyPendingQ
(
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
&
pendingQ
ConnectionEntry
*
ent
HttpConnectionBase
*
conn
)
{
if
(
pendingQ
.
Length
(
)
=
=
0
)
{
return
;
}
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
leftovers
;
uint32_t
index
;
for
(
index
=
0
;
index
<
pendingQ
.
Length
(
)
&
&
conn
-
>
CanDirectlyActivate
(
)
;
+
+
index
)
{
PendingTransactionInfo
*
pendingTransInfo
=
pendingQ
[
index
]
;
if
(
!
(
pendingTransInfo
-
>
Transaction
(
)
-
>
Caps
(
)
&
NS_HTTP_ALLOW_KEEPALIVE
)
|
|
pendingTransInfo
-
>
Transaction
(
)
-
>
Caps
(
)
&
NS_HTTP_DISALLOW_SPDY
)
{
leftovers
.
AppendElement
(
pendingTransInfo
)
;
continue
;
}
nsresult
rv
=
DispatchTransaction
(
ent
pendingTransInfo
-
>
Transaction
(
)
conn
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
false
"
Dispatch
SPDY
Transaction
"
)
;
LOG
(
(
"
ProcessSpdyPendingQ
Dispatch
Transaction
failed
trans
=
%
p
\
n
"
pendingTransInfo
-
>
Transaction
(
)
)
)
;
pendingTransInfo
-
>
Transaction
(
)
-
>
Close
(
rv
)
;
}
}
for
(
;
index
<
pendingQ
.
Length
(
)
;
+
+
index
)
{
PendingTransactionInfo
*
pendingTransInfo
=
pendingQ
[
index
]
;
leftovers
.
AppendElement
(
pendingTransInfo
)
;
}
pendingQ
=
std
:
:
move
(
leftovers
)
;
}
void
nsHttpConnectionMgr
:
:
ProcessSpdyPendingQ
(
ConnectionEntry
*
ent
)
{
HttpConnectionBase
*
conn
=
GetH2orH3ActiveConn
(
ent
false
)
;
if
(
!
conn
|
|
!
conn
-
>
CanDirectlyActivate
(
)
)
{
return
;
}
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
urgentQ
;
ent
-
>
AppendPendingUrgentStartQ
(
urgentQ
)
;
DispatchSpdyPendingQ
(
urgentQ
ent
conn
)
;
for
(
const
auto
&
transactionInfo
:
Reversed
(
urgentQ
)
)
{
ent
-
>
InsertTransaction
(
transactionInfo
)
;
}
if
(
!
conn
-
>
CanDirectlyActivate
(
)
)
{
return
;
}
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
pendingQ
;
ent
-
>
AppendPendingQForNonFocusedWindows
(
0
pendingQ
)
;
DispatchSpdyPendingQ
(
pendingQ
ent
conn
)
;
for
(
const
auto
&
transactionInfo
:
pendingQ
)
{
ent
-
>
InsertTransaction
(
transactionInfo
)
;
}
}
void
nsHttpConnectionMgr
:
:
OnMsgProcessAllSpdyPendingQ
(
int32_t
ARefBase
*
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgProcessAllSpdyPendingQ
\
n
"
)
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ProcessSpdyPendingQ
(
iter
.
Data
(
)
.
get
(
)
)
;
}
}
HttpConnectionBase
*
nsHttpConnectionMgr
:
:
GetH2orH3ActiveConn
(
ConnectionEntry
*
ent
bool
aNoHttp3
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
ent
)
;
HttpConnectionBase
*
conn
=
ent
-
>
GetH2orH3ActiveConn
(
aNoHttp3
)
;
if
(
conn
)
{
return
conn
;
}
nsHttpConnectionInfo
*
ci
=
ent
-
>
mConnInfo
;
HttpConnectionBase
*
existingConn
=
FindCoalescableConnection
(
ent
false
aNoHttp3
)
;
if
(
existingConn
)
{
LOG
(
(
"
GetH2orH3ActiveConn
(
)
request
for
ent
%
p
%
s
"
"
found
an
active
connection
%
p
in
the
coalescing
hashtable
\
n
"
ent
ci
-
>
HashKey
(
)
.
get
(
)
existingConn
)
)
;
return
existingConn
;
}
LOG
(
(
"
GetH2orH3ActiveConn
(
)
request
for
ent
%
p
%
s
"
"
did
not
find
an
active
connection
\
n
"
ent
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
return
nullptr
;
}
void
nsHttpConnectionMgr
:
:
AbortAndCloseAllConnections
(
int32_t
ARefBase
*
)
{
if
(
!
OnSocketThread
(
)
)
{
Unused
<
<
PostEvent
(
&
nsHttpConnectionMgr
:
:
AbortAndCloseAllConnections
)
;
return
;
}
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
AbortAndCloseAllConnections
\
n
"
)
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
ConnectionEntry
>
ent
=
iter
.
Data
(
)
;
ent
-
>
CloseActiveConnections
(
)
;
ent
-
>
CloseIdleConnections
(
)
;
ent
-
>
CancelAllTransactions
(
NS_ERROR_ABORT
)
;
ent
-
>
CloseAllHalfOpens
(
)
;
MOZ_ASSERT
(
ent
-
>
HalfOpenFastOpenBackupsLength
(
)
=
=
0
&
&
!
ent
-
>
mDoNotDestroy
)
;
iter
.
Remove
(
)
;
}
mActiveTransactions
[
false
]
.
Clear
(
)
;
mActiveTransactions
[
true
]
.
Clear
(
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgShutdown
(
int32_t
ARefBase
*
param
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgShutdown
\
n
"
)
)
;
gHttpHandler
-
>
StopRequestTokenBucket
(
)
;
AbortAndCloseAllConnections
(
0
nullptr
)
;
ConditionallyStopPruneDeadConnectionsTimer
(
)
;
if
(
mTimeoutTick
)
{
mTimeoutTick
-
>
Cancel
(
)
;
mTimeoutTick
=
nullptr
;
mTimeoutTickArmed
=
false
;
}
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
if
(
mTrafficTimer
)
{
mTrafficTimer
-
>
Cancel
(
)
;
mTrafficTimer
=
nullptr
;
}
DestroyThrottleTicker
(
)
;
mCoalescingHash
.
Clear
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
ConnEvent
(
this
&
nsHttpConnectionMgr
:
:
OnMsgShutdownConfirm
0
param
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgShutdownConfirm
(
int32_t
priority
ARefBase
*
param
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgShutdownConfirm
\
n
"
)
)
;
BoolWrapper
*
shutdown
=
static_cast
<
BoolWrapper
*
>
(
param
)
;
shutdown
-
>
mBool
=
true
;
}
void
nsHttpConnectionMgr
:
:
OnMsgNewTransaction
(
int32_t
priority
ARefBase
*
param
)
{
nsHttpTransaction
*
trans
=
static_cast
<
nsHttpTransaction
*
>
(
param
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgNewTransaction
[
trans
=
%
p
]
\
n
"
trans
)
)
;
trans
-
>
SetPriority
(
priority
)
;
nsresult
rv
=
ProcessNewTransaction
(
trans
)
;
if
(
NS_FAILED
(
rv
)
)
trans
-
>
Close
(
rv
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgNewTransactionWithStickyConn
(
int32_t
priority
ARefBase
*
param
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
NewTransactionData
*
data
=
static_cast
<
NewTransactionData
*
>
(
param
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgNewTransactionWithStickyConn
"
"
[
trans
=
%
p
transWithStickyConn
=
%
p
conn
=
%
p
]
\
n
"
data
-
>
mTrans
.
get
(
)
data
-
>
mTransWithStickyConn
.
get
(
)
data
-
>
mTransWithStickyConn
-
>
Connection
(
)
)
)
;
MOZ_ASSERT
(
data
-
>
mTransWithStickyConn
&
&
data
-
>
mTransWithStickyConn
-
>
Caps
(
)
&
NS_HTTP_STICKY_CONNECTION
)
;
data
-
>
mTrans
-
>
SetPriority
(
data
-
>
mPriority
)
;
RefPtr
<
nsAHttpConnection
>
conn
=
data
-
>
mTransWithStickyConn
-
>
Connection
(
)
;
if
(
conn
&
&
conn
-
>
IsPersistent
(
)
)
{
LOG
(
(
"
Reuse
connection
[
%
p
]
for
transaction
[
%
p
]
"
conn
.
get
(
)
data
-
>
mTrans
.
get
(
)
)
)
;
data
-
>
mTrans
-
>
SetConnection
(
conn
)
;
}
nsresult
rv
=
ProcessNewTransaction
(
data
-
>
mTrans
)
;
if
(
NS_FAILED
(
rv
)
)
{
data
-
>
mTrans
-
>
Close
(
rv
)
;
}
}
void
nsHttpConnectionMgr
:
:
OnMsgReschedTransaction
(
int32_t
priority
ARefBase
*
param
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgReschedTransaction
[
trans
=
%
p
]
\
n
"
param
)
)
;
RefPtr
<
nsHttpTransaction
>
trans
=
static_cast
<
nsHttpTransaction
*
>
(
param
)
;
trans
-
>
SetPriority
(
priority
)
;
if
(
!
trans
-
>
ConnectionInfo
(
)
)
{
return
;
}
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
trans
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
)
;
if
(
ent
)
{
ent
-
>
ReschedTransaction
(
trans
)
;
}
}
void
nsHttpConnectionMgr
:
:
OnMsgUpdateClassOfServiceOnTransaction
(
int32_t
arg
ARefBase
*
param
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgUpdateClassOfServiceOnTransaction
"
"
[
trans
=
%
p
]
\
n
"
param
)
)
;
uint32_t
cos
=
static_cast
<
uint32_t
>
(
arg
)
;
nsHttpTransaction
*
trans
=
static_cast
<
nsHttpTransaction
*
>
(
param
)
;
uint32_t
previous
=
trans
-
>
ClassOfService
(
)
;
trans
-
>
SetClassOfService
(
cos
)
;
if
(
(
previous
^
cos
)
&
(
NS_HTTP_LOAD_AS_BLOCKING
|
NS_HTTP_LOAD_UNBLOCKED
)
)
{
Unused
<
<
RescheduleTransaction
(
trans
trans
-
>
Priority
(
)
)
;
}
}
void
nsHttpConnectionMgr
:
:
OnMsgCancelTransaction
(
int32_t
reason
ARefBase
*
param
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCancelTransaction
[
trans
=
%
p
]
\
n
"
param
)
)
;
nsresult
closeCode
=
static_cast
<
nsresult
>
(
reason
)
;
nsHttpTransaction
*
trans
=
static_cast
<
nsHttpTransaction
*
>
(
param
)
;
RefPtr
<
nsAHttpConnection
>
conn
(
trans
-
>
Connection
(
)
)
;
if
(
conn
&
&
!
trans
-
>
IsDone
(
)
)
{
conn
-
>
CloseTransaction
(
trans
closeCode
)
;
}
else
{
ConnectionEntry
*
ent
=
nullptr
;
if
(
trans
-
>
ConnectionInfo
(
)
)
{
ent
=
mCT
.
GetWeak
(
trans
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
)
;
}
if
(
ent
)
{
int32_t
transIndex
;
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
*
infoArray
=
ent
-
>
GetTransactionPendingQHelper
(
trans
)
;
RefPtr
<
PendingTransactionInfo
>
pendingTransInfo
;
transIndex
=
infoArray
?
infoArray
-
>
IndexOf
(
trans
0
PendingComparator
(
)
)
:
-
1
;
if
(
transIndex
>
=
0
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCancelTransaction
[
trans
=
%
p
]
"
"
found
in
urgentStart
queue
\
n
"
trans
)
)
;
pendingTransInfo
=
(
*
infoArray
)
[
transIndex
]
;
infoArray
-
>
RemoveElementAt
(
transIndex
)
;
}
if
(
pendingTransInfo
)
{
pendingTransInfo
-
>
AbandonHalfOpenAndForgetActiveConn
(
)
;
}
}
trans
-
>
Close
(
closeCode
)
;
if
(
ent
)
{
ent
-
>
CloseAllActiveConnsWithNullTransactcion
(
closeCode
)
;
}
}
}
void
nsHttpConnectionMgr
:
:
OnMsgProcessPendingQ
(
int32_t
ARefBase
*
param
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
nsHttpConnectionInfo
*
ci
=
static_cast
<
nsHttpConnectionInfo
*
>
(
param
)
;
if
(
!
ci
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgProcessPendingQ
[
ci
=
nullptr
]
\
n
"
)
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Unused
<
<
ProcessPendingQForEntry
(
iter
.
Data
(
)
.
get
(
)
true
)
;
}
return
;
}
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgProcessPendingQ
[
ci
=
%
s
]
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
ci
-
>
HashKey
(
)
)
;
if
(
!
(
ent
&
&
ProcessPendingQForEntry
(
ent
false
)
)
)
{
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
ProcessPendingQForEntry
(
iter
.
Data
(
)
.
get
(
)
false
)
)
{
break
;
}
}
}
}
nsresult
nsHttpConnectionMgr
:
:
CancelTransactions
(
nsHttpConnectionInfo
*
ci
nsresult
code
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
CancelTransactions
%
s
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
int32_t
intReason
=
static_cast
<
int32_t
>
(
code
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgCancelTransactions
intReason
ci
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgCancelTransactions
(
int32_t
code
ARefBase
*
param
)
{
nsresult
reason
=
static_cast
<
nsresult
>
(
code
)
;
nsHttpConnectionInfo
*
ci
=
static_cast
<
nsHttpConnectionInfo
*
>
(
param
)
;
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
ci
-
>
HashKey
(
)
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCancelTransactions
%
s
%
p
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
ent
)
)
;
if
(
ent
)
{
ent
-
>
CancelAllTransactions
(
reason
)
;
}
}
void
nsHttpConnectionMgr
:
:
OnMsgPruneDeadConnections
(
int32_t
ARefBase
*
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgPruneDeadConnections
\
n
"
)
)
;
mTimeOfNextWakeUp
=
UINT64_MAX
;
if
(
mNumIdleConns
|
|
(
mNumActiveConns
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
)
)
{
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
ConnectionEntry
>
ent
=
iter
.
Data
(
)
;
LOG
(
(
"
pruning
[
ci
=
%
s
]
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
uint32_t
timeToNextExpire
=
ent
-
>
PruneDeadConnections
(
)
;
if
(
timeToNextExpire
!
=
UINT32_MAX
)
{
uint32_t
now
=
NowInSeconds
(
)
;
uint64_t
timeOfNextExpire
=
now
+
timeToNextExpire
;
if
(
!
mTimer
|
|
timeOfNextExpire
<
mTimeOfNextWakeUp
)
{
PruneDeadConnectionsAfter
(
timeToNextExpire
)
;
}
}
else
{
ConditionallyStopPruneDeadConnectionsTimer
(
)
;
}
ent
-
>
RemoveEmptyPendingQ
(
)
;
if
(
mCT
.
Count
(
)
>
125
&
&
ent
-
>
IdleConnectionsLength
(
)
=
=
0
&
&
ent
-
>
ActiveConnsLength
(
)
=
=
0
&
&
ent
-
>
HalfOpensLength
(
)
=
=
0
&
&
ent
-
>
PendingQueueLength
(
)
=
=
0
&
&
ent
-
>
UrgentStartQueueLength
(
)
=
=
0
&
&
ent
-
>
HalfOpenFastOpenBackupsLength
(
)
=
=
0
&
&
!
ent
-
>
mDoNotDestroy
&
&
(
!
ent
-
>
mUsingSpdy
|
|
mCT
.
Count
(
)
>
300
)
)
{
LOG
(
(
"
removing
empty
connection
entry
\
n
"
)
)
;
iter
.
Remove
(
)
;
continue
;
}
ent
-
>
Compact
(
)
;
}
}
}
void
nsHttpConnectionMgr
:
:
OnMsgPruneNoTraffic
(
int32_t
ARefBase
*
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgPruneNoTraffic
\
n
"
)
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
ConnectionEntry
>
ent
=
iter
.
Data
(
)
;
ent
-
>
PruneNoTraffic
(
)
;
}
mPruningNoTraffic
=
false
;
}
void
nsHttpConnectionMgr
:
:
OnMsgVerifyTraffic
(
int32_t
ARefBase
*
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgVerifyTraffic
\
n
"
)
)
;
if
(
mPruningNoTraffic
)
{
return
;
}
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Data
(
)
-
>
VerifyTraffic
(
)
;
}
if
(
!
mTrafficTimer
)
{
mTrafficTimer
=
NS_NewTimer
(
)
;
}
if
(
mTrafficTimer
)
{
mTrafficTimer
-
>
Init
(
this
gHttpHandler
-
>
NetworkChangedTimeout
(
)
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
else
{
NS_WARNING
(
"
failed
to
create
timer
for
VerifyTraffic
!
"
)
;
}
}
void
nsHttpConnectionMgr
:
:
OnMsgDoShiftReloadConnectionCleanup
(
int32_t
ARefBase
*
param
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgDoShiftReloadConnectionCleanup
\
n
"
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
nsHttpConnectionInfo
*
ci
=
static_cast
<
nsHttpConnectionInfo
*
>
(
param
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Data
(
)
-
>
ClosePersistentConnections
(
)
;
}
if
(
ci
)
ResetIPFamilyPreference
(
ci
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgReclaimConnection
(
HttpConnectionBase
*
conn
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
conn
)
;
ConnectionEntry
*
ent
=
conn
-
>
ConnectionInfo
(
)
?
mCT
.
GetWeak
(
conn
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
)
:
nullptr
;
if
(
!
ent
)
{
ent
=
GetOrCreateConnectionEntry
(
conn
-
>
ConnectionInfo
(
)
true
false
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgReclaimConnection
conn
%
p
"
"
forced
new
hash
entry
%
s
\
n
"
conn
conn
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
.
get
(
)
)
)
;
}
MOZ_ASSERT
(
ent
)
;
RefPtr
<
nsHttpConnectionInfo
>
ci
(
ent
-
>
mConnInfo
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgReclaimConnection
[
ent
=
%
p
conn
=
%
p
]
\
n
"
ent
conn
)
)
;
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
if
(
!
connTCP
|
|
connTCP
-
>
EverUsedSpdy
(
)
)
{
conn
-
>
DontReuse
(
)
;
}
if
(
conn
-
>
Transaction
(
)
)
{
conn
-
>
DontReuse
(
)
;
}
if
(
NS_SUCCEEDED
(
ent
-
>
RemoveActiveConnection
(
conn
)
)
)
{
}
else
if
(
!
connTCP
|
|
connTCP
-
>
EverUsedSpdy
(
)
)
{
LOG
(
(
"
HttpConnectionBase
%
p
not
found
in
its
connection
entry
try
^
anon
"
conn
)
)
;
RefPtr
<
nsHttpConnectionInfo
>
anonInvertedCI
(
ci
-
>
Clone
(
)
)
;
anonInvertedCI
-
>
SetAnonymous
(
!
ci
-
>
GetAnonymous
(
)
)
;
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
anonInvertedCI
-
>
HashKey
(
)
)
;
if
(
ent
)
{
if
(
NS_SUCCEEDED
(
ent
-
>
RemoveActiveConnection
(
conn
)
)
)
{
}
else
{
LOG
(
(
"
HttpConnectionBase
%
p
could
not
be
removed
from
its
entry
'
s
"
"
active
list
"
conn
)
)
;
}
}
}
if
(
connTCP
&
&
connTCP
-
>
CanReuse
(
)
)
{
LOG
(
(
"
adding
connection
to
idle
list
\
n
"
)
)
;
ent
-
>
InsertIntoIdleConnections
(
connTCP
)
;
}
else
{
LOG
(
(
"
connection
cannot
be
reused
;
closing
connection
\
n
"
)
)
;
conn
-
>
Close
(
NS_ERROR_ABORT
)
;
}
OnMsgProcessPendingQ
(
0
ci
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgCompleteUpgrade
(
int32_t
ARefBase
*
param
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
nsresult
rv
=
NS_OK
;
nsCompleteUpgradeData
*
data
=
static_cast
<
nsCompleteUpgradeData
*
>
(
param
)
;
MOZ_ASSERT
(
data
-
>
mTrans
&
&
data
-
>
mTrans
-
>
Caps
(
)
&
NS_HTTP_STICKY_CONNECTION
)
;
RefPtr
<
nsAHttpConnection
>
conn
(
data
-
>
mTrans
-
>
Connection
(
)
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCompleteUpgrade
"
"
conn
=
%
p
listener
=
%
p
wrapped
=
%
d
\
n
"
conn
.
get
(
)
data
-
>
mUpgradeListener
.
get
(
)
data
-
>
mJsWrapped
)
)
;
if
(
!
conn
)
{
rv
=
NS_ERROR_UNEXPECTED
;
}
else
{
MOZ_ASSERT
(
!
data
-
>
mSocketTransport
)
;
rv
=
conn
-
>
TakeTransport
(
getter_AddRefs
(
data
-
>
mSocketTransport
)
getter_AddRefs
(
data
-
>
mSocketIn
)
getter_AddRefs
(
data
-
>
mSocketOut
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
conn
-
>
TakeTransport
failed
with
%
"
PRIx32
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
RefPtr
<
nsCompleteUpgradeData
>
upgradeData
(
data
)
;
auto
transportAvailableFunc
=
[
upgradeData
{
std
:
:
move
(
upgradeData
)
}
aRv
(
rv
)
]
(
)
{
nsresult
rv
=
aRv
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
upgradeData
-
>
mUpgradeListener
-
>
OnUpgradeFailed
(
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCompleteUpgrade
OnUpgradeFailed
failed
.
"
"
listener
=
%
p
\
n
"
upgradeData
-
>
mUpgradeListener
.
get
(
)
)
)
;
}
return
;
}
rv
=
upgradeData
-
>
mUpgradeListener
-
>
OnTransportAvailable
(
upgradeData
-
>
mSocketTransport
upgradeData
-
>
mSocketIn
upgradeData
-
>
mSocketOut
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCompleteUpgrade
OnTransportAvailable
"
"
failed
.
listener
=
%
p
\
n
"
upgradeData
-
>
mUpgradeListener
.
get
(
)
)
)
;
}
}
;
if
(
data
-
>
mJsWrapped
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCompleteUpgrade
"
"
conn
=
%
p
listener
=
%
p
wrapped
=
%
d
pass
to
main
thread
\
n
"
conn
.
get
(
)
data
-
>
mUpgradeListener
.
get
(
)
data
-
>
mJsWrapped
)
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
net
:
:
nsHttpConnectionMgr
:
:
OnMsgCompleteUpgrade
"
transportAvailableFunc
)
)
;
}
else
{
transportAvailableFunc
(
)
;
}
}
void
nsHttpConnectionMgr
:
:
OnMsgUpdateParam
(
int32_t
inParam
ARefBase
*
)
{
uint32_t
param
=
static_cast
<
uint32_t
>
(
inParam
)
;
uint16_t
name
=
(
(
param
)
&
0xFFFF0000
)
>
>
16
;
uint16_t
value
=
param
&
0x0000FFFF
;
switch
(
name
)
{
case
MAX_CONNECTIONS
:
mMaxConns
=
value
;
break
;
case
MAX_URGENT_START_Q
:
mMaxUrgentExcessiveConns
=
value
;
break
;
case
MAX_PERSISTENT_CONNECTIONS_PER_HOST
:
mMaxPersistConnsPerHost
=
value
;
break
;
case
MAX_PERSISTENT_CONNECTIONS_PER_PROXY
:
mMaxPersistConnsPerProxy
=
value
;
break
;
case
MAX_REQUEST_DELAY
:
mMaxRequestDelay
=
value
;
break
;
case
THROTTLING_ENABLED
:
SetThrottlingEnabled
(
!
!
value
)
;
break
;
case
THROTTLING_SUSPEND_FOR
:
mThrottleSuspendFor
=
value
;
break
;
case
THROTTLING_RESUME_FOR
:
mThrottleResumeFor
=
value
;
break
;
case
THROTTLING_READ_LIMIT
:
mThrottleReadLimit
=
value
;
break
;
case
THROTTLING_READ_INTERVAL
:
mThrottleReadInterval
=
value
;
break
;
case
THROTTLING_HOLD_TIME
:
mThrottleHoldTime
=
value
;
break
;
case
THROTTLING_MAX_TIME
:
mThrottleMaxTime
=
TimeDuration
:
:
FromMilliseconds
(
value
)
;
break
;
case
PROXY_BE_CONSERVATIVE
:
mBeConservativeForProxy
=
!
!
value
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
parameter
name
"
)
;
}
}
void
nsHttpConnectionMgr
:
:
ActivateTimeoutTick
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
ActivateTimeoutTick
(
)
"
"
this
=
%
p
mTimeoutTick
=
%
p
\
n
"
this
mTimeoutTick
.
get
(
)
)
)
;
if
(
mTimeoutTick
&
&
mTimeoutTickArmed
)
{
if
(
mTimeoutTickNext
>
1
)
{
mTimeoutTickNext
=
1
;
mTimeoutTick
-
>
SetDelay
(
1000
)
;
}
return
;
}
if
(
!
mTimeoutTick
)
{
mTimeoutTick
=
NS_NewTimer
(
)
;
if
(
!
mTimeoutTick
)
{
NS_WARNING
(
"
failed
to
create
timer
for
http
timeout
management
"
)
;
return
;
}
mTimeoutTick
-
>
SetTarget
(
mSocketThreadTarget
)
;
}
MOZ_ASSERT
(
!
mTimeoutTickArmed
"
timer
tick
armed
"
)
;
mTimeoutTickArmed
=
true
;
mTimeoutTick
-
>
Init
(
this
1000
nsITimer
:
:
TYPE_REPEATING_SLACK
)
;
}
class
UINT64Wrapper
:
public
ARefBase
{
public
:
explicit
UINT64Wrapper
(
uint64_t
aUint64
)
:
mUint64
(
aUint64
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
UINT64Wrapper
override
)
uint64_t
GetValue
(
)
{
return
mUint64
;
}
private
:
uint64_t
mUint64
;
virtual
~
UINT64Wrapper
(
)
=
default
;
}
;
nsresult
nsHttpConnectionMgr
:
:
UpdateCurrentTopLevelOuterContentWindowId
(
uint64_t
aWindowId
)
{
RefPtr
<
UINT64Wrapper
>
windowIdWrapper
=
new
UINT64Wrapper
(
aWindowId
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgUpdateCurrentTopLevelOuterContentWindowId
0
windowIdWrapper
)
;
}
void
nsHttpConnectionMgr
:
:
SetThrottlingEnabled
(
bool
aEnable
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
SetThrottlingEnabled
enable
=
%
d
"
aEnable
)
)
;
mThrottleEnabled
=
aEnable
;
if
(
mThrottleEnabled
)
{
EnsureThrottleTickerIfNeeded
(
)
;
}
else
{
DestroyThrottleTicker
(
)
;
ResumeReadOf
(
mActiveTransactions
[
false
]
)
;
ResumeReadOf
(
mActiveTransactions
[
true
]
)
;
}
}
bool
nsHttpConnectionMgr
:
:
InThrottlingTimeWindow
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
mThrottlingWindowEndsAt
.
IsNull
(
)
)
{
return
true
;
}
return
TimeStamp
:
:
NowLoRes
(
)
<
=
mThrottlingWindowEndsAt
;
}
void
nsHttpConnectionMgr
:
:
TouchThrottlingTimeWindow
(
bool
aEnsureTicker
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
TouchThrottlingTimeWindow
"
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
mThrottlingWindowEndsAt
=
TimeStamp
:
:
NowLoRes
(
)
+
mThrottleMaxTime
;
if
(
!
mThrottleTicker
&
&
MOZ_LIKELY
(
aEnsureTicker
)
&
&
MOZ_LIKELY
(
mThrottleEnabled
)
)
{
EnsureThrottleTickerIfNeeded
(
)
;
}
}
void
nsHttpConnectionMgr
:
:
LogActiveTransactions
(
char
operation
)
{
if
(
!
LOG_ENABLED
(
)
)
{
return
;
}
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
*
trs
=
nullptr
;
uint32_t
au
at
bu
=
0
bt
=
0
;
trs
=
mActiveTransactions
[
false
]
.
Get
(
mCurrentTopLevelOuterContentWindowId
)
;
au
=
trs
?
trs
-
>
Length
(
)
:
0
;
trs
=
mActiveTransactions
[
true
]
.
Get
(
mCurrentTopLevelOuterContentWindowId
)
;
at
=
trs
?
trs
-
>
Length
(
)
:
0
;
for
(
auto
iter
=
mActiveTransactions
[
false
]
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
bu
+
=
iter
.
UserData
(
)
-
>
Length
(
)
;
}
bu
-
=
au
;
for
(
auto
iter
=
mActiveTransactions
[
true
]
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
bt
+
=
iter
.
UserData
(
)
-
>
Length
(
)
;
}
bt
-
=
at
;
LOG
(
(
"
Active
transactions
%
c
[
%
u
%
u
%
u
%
u
]
"
operation
au
at
bu
bt
)
)
;
}
void
nsHttpConnectionMgr
:
:
AddActiveTransaction
(
nsHttpTransaction
*
aTrans
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
uint64_t
tabId
=
aTrans
-
>
TopLevelOuterContentWindowId
(
)
;
bool
throttled
=
aTrans
-
>
EligibleForThrottling
(
)
;
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
*
transactions
=
mActiveTransactions
[
throttled
]
.
LookupOrAdd
(
tabId
)
;
MOZ_ASSERT
(
!
transactions
-
>
Contains
(
aTrans
)
)
;
transactions
-
>
AppendElement
(
aTrans
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
AddActiveTransaction
t
=
%
p
tabid
=
%
"
PRIx64
"
(
%
d
)
thr
=
%
d
"
aTrans
tabId
tabId
=
=
mCurrentTopLevelOuterContentWindowId
throttled
)
)
;
LogActiveTransactions
(
'
+
'
)
;
if
(
tabId
=
=
mCurrentTopLevelOuterContentWindowId
)
{
mActiveTabTransactionsExist
=
true
;
if
(
!
throttled
)
{
mActiveTabUnthrottledTransactionsExist
=
true
;
}
}
TouchThrottlingTimeWindow
(
false
)
;
if
(
!
mThrottleEnabled
)
{
return
;
}
EnsureThrottleTickerIfNeeded
(
)
;
}
void
nsHttpConnectionMgr
:
:
RemoveActiveTransaction
(
nsHttpTransaction
*
aTrans
Maybe
<
bool
>
const
&
aOverride
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
uint64_t
tabId
=
aTrans
-
>
TopLevelOuterContentWindowId
(
)
;
bool
forActiveTab
=
tabId
=
=
mCurrentTopLevelOuterContentWindowId
;
bool
throttled
=
aOverride
.
valueOr
(
aTrans
-
>
EligibleForThrottling
(
)
)
;
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
*
transactions
=
mActiveTransactions
[
throttled
]
.
Get
(
tabId
)
;
if
(
!
transactions
|
|
!
transactions
-
>
RemoveElement
(
aTrans
)
)
{
return
;
}
LOG
(
(
"
nsHttpConnectionMgr
:
:
RemoveActiveTransaction
t
=
%
p
tabid
=
%
"
PRIx64
"
(
%
d
)
thr
=
%
d
"
aTrans
tabId
forActiveTab
throttled
)
)
;
if
(
!
transactions
-
>
IsEmpty
(
)
)
{
LogActiveTransactions
(
'
-
'
)
;
return
;
}
mActiveTransactions
[
throttled
]
.
Remove
(
tabId
)
;
LogActiveTransactions
(
'
-
'
)
;
if
(
forActiveTab
)
{
if
(
!
throttled
)
{
mActiveTabUnthrottledTransactionsExist
=
false
;
}
if
(
mActiveTabTransactionsExist
)
{
mActiveTabTransactionsExist
=
mActiveTransactions
[
!
throttled
]
.
Contains
(
tabId
)
;
}
}
if
(
!
mThrottleEnabled
)
{
return
;
}
bool
unthrottledExist
=
!
mActiveTransactions
[
false
]
.
IsEmpty
(
)
;
bool
throttledExist
=
!
mActiveTransactions
[
true
]
.
IsEmpty
(
)
;
if
(
!
unthrottledExist
&
&
!
throttledExist
)
{
MOZ_ASSERT
(
!
mActiveTabUnthrottledTransactionsExist
)
;
MOZ_ASSERT
(
!
mActiveTabTransactionsExist
)
;
DestroyThrottleTicker
(
)
;
return
;
}
if
(
mThrottleVersion
=
=
1
)
{
if
(
!
mThrottlingInhibitsReading
)
{
LOG
(
(
"
reading
not
currently
inhibited
"
)
)
;
return
;
}
}
if
(
mActiveTabUnthrottledTransactionsExist
)
{
LOG
(
(
"
there
are
unthrottled
for
the
active
tab
"
)
)
;
return
;
}
if
(
mActiveTabTransactionsExist
)
{
if
(
forActiveTab
&
&
!
throttled
)
{
LOG
(
(
"
resuming
throttled
for
active
tab
"
)
)
;
ResumeReadOf
(
mActiveTransactions
[
true
]
.
Get
(
mCurrentTopLevelOuterContentWindowId
)
)
;
}
return
;
}
if
(
!
unthrottledExist
)
{
LOG
(
(
"
delay
resuming
throttled
for
background
tabs
"
)
)
;
DelayedResumeBackgroundThrottledTransactions
(
)
;
return
;
}
if
(
forActiveTab
)
{
LOG
(
(
"
delay
resuming
unthrottled
for
background
tabs
"
)
)
;
DelayedResumeBackgroundThrottledTransactions
(
)
;
return
;
}
LOG
(
(
"
not
resuming
anything
"
)
)
;
}
void
nsHttpConnectionMgr
:
:
UpdateActiveTransaction
(
nsHttpTransaction
*
aTrans
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
UpdateActiveTransaction
ENTER
t
=
%
p
"
aTrans
)
)
;
Maybe
<
bool
>
reversed
;
reversed
.
emplace
(
!
aTrans
-
>
EligibleForThrottling
(
)
)
;
RemoveActiveTransaction
(
aTrans
reversed
)
;
AddActiveTransaction
(
aTrans
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
UpdateActiveTransaction
EXIT
t
=
%
p
"
aTrans
)
)
;
}
bool
nsHttpConnectionMgr
:
:
ShouldThrottle
(
nsHttpTransaction
*
aTrans
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
ShouldThrottle
trans
=
%
p
"
aTrans
)
)
;
if
(
mThrottleVersion
=
=
1
)
{
if
(
!
mThrottlingInhibitsReading
|
|
!
mThrottleEnabled
)
{
return
false
;
}
}
else
{
if
(
!
mThrottleEnabled
)
{
return
false
;
}
}
uint64_t
tabId
=
aTrans
-
>
TopLevelOuterContentWindowId
(
)
;
bool
forActiveTab
=
tabId
=
=
mCurrentTopLevelOuterContentWindowId
;
bool
throttled
=
aTrans
-
>
EligibleForThrottling
(
)
;
bool
stop
=
[
=
]
(
)
{
if
(
mActiveTabTransactionsExist
)
{
if
(
!
tabId
)
{
LOG
(
(
"
active
tab
loads
trans
is
tab
-
less
throttled
=
%
d
"
throttled
)
)
;
return
throttled
;
}
if
(
!
forActiveTab
)
{
LOG
(
(
"
active
tab
loads
trans
not
of
the
active
tab
"
)
)
;
return
true
;
}
if
(
mActiveTabUnthrottledTransactionsExist
)
{
LOG
(
(
"
active
tab
loads
unthrottled
trans
throttled
=
%
d
"
throttled
)
)
;
return
throttled
;
}
LOG
(
(
"
trans
for
active
tab
don
'
t
throttle
"
)
)
;
return
false
;
}
MOZ_ASSERT
(
!
forActiveTab
)
;
if
(
!
mActiveTransactions
[
false
]
.
IsEmpty
(
)
)
{
LOG
(
(
"
backround
tab
(
s
)
load
unthrottled
trans
throttled
=
%
d
"
throttled
)
)
;
return
throttled
;
}
LOG
(
(
"
backround
tab
(
s
)
load
throttled
don
'
t
throttle
"
)
)
;
return
false
;
}
(
)
;
if
(
forActiveTab
&
&
!
stop
)
{
TouchThrottlingTimeWindow
(
)
;
return
false
;
}
bool
inWindow
=
InThrottlingTimeWindow
(
)
;
LOG
(
(
"
stop
=
%
d
in
-
window
=
%
d
delayed
-
bck
-
timer
=
%
d
"
stop
inWindow
!
!
mDelayedResumeReadTimer
)
)
;
if
(
!
forActiveTab
)
{
inWindow
=
inWindow
|
|
mDelayedResumeReadTimer
;
}
return
stop
&
&
inWindow
;
}
bool
nsHttpConnectionMgr
:
:
IsConnEntryUnderPressure
(
nsHttpConnectionInfo
*
connInfo
)
{
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
connInfo
-
>
HashKey
(
)
)
;
if
(
!
ent
)
{
return
false
;
}
return
ent
-
>
PendingQueueLengthForWindow
(
mCurrentTopLevelOuterContentWindowId
)
>
0
;
}
bool
nsHttpConnectionMgr
:
:
IsThrottleTickerNeeded
(
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
IsThrottleTickerNeeded
"
)
)
;
if
(
mActiveTabUnthrottledTransactionsExist
&
&
mActiveTransactions
[
false
]
.
Count
(
)
>
1
)
{
LOG
(
(
"
there
are
unthrottled
transactions
for
both
active
and
bck
"
)
)
;
return
true
;
}
if
(
mActiveTabTransactionsExist
&
&
mActiveTransactions
[
true
]
.
Count
(
)
>
1
)
{
LOG
(
(
"
there
are
throttled
transactions
for
both
active
and
bck
"
)
)
;
return
true
;
}
if
(
!
mActiveTransactions
[
true
]
.
IsEmpty
(
)
&
&
!
mActiveTransactions
[
false
]
.
IsEmpty
(
)
)
{
LOG
(
(
"
there
are
both
throttled
and
unthrottled
transactions
"
)
)
;
return
true
;
}
LOG
(
(
"
nothing
to
throttle
"
)
)
;
return
false
;
}
void
nsHttpConnectionMgr
:
:
EnsureThrottleTickerIfNeeded
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
EnsureThrottleTickerIfNeeded
"
)
)
;
if
(
!
IsThrottleTickerNeeded
(
)
)
{
return
;
}
CancelDelayedResumeBackgroundThrottledTransactions
(
)
;
if
(
mThrottleTicker
)
{
return
;
}
mThrottleTicker
=
NS_NewTimer
(
)
;
if
(
mThrottleTicker
)
{
if
(
mThrottleVersion
=
=
1
)
{
MOZ_ASSERT
(
!
mThrottlingInhibitsReading
)
;
mThrottleTicker
-
>
Init
(
this
mThrottleSuspendFor
nsITimer
:
:
TYPE_ONE_SHOT
)
;
mThrottlingInhibitsReading
=
true
;
}
else
{
mThrottleTicker
-
>
Init
(
this
mThrottleReadInterval
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
}
LogActiveTransactions
(
'
^
'
)
;
}
void
nsHttpConnectionMgr
:
:
DestroyThrottleTicker
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
CancelDelayedResumeBackgroundThrottledTransactions
(
)
;
MOZ_ASSERT
(
!
mThrottleEnabled
|
|
!
IsThrottleTickerNeeded
(
)
)
;
if
(
!
mThrottleTicker
)
{
return
;
}
LOG
(
(
"
nsHttpConnectionMgr
:
:
DestroyThrottleTicker
"
)
)
;
mThrottleTicker
-
>
Cancel
(
)
;
mThrottleTicker
=
nullptr
;
if
(
mThrottleVersion
=
=
1
)
{
mThrottlingInhibitsReading
=
false
;
}
LogActiveTransactions
(
'
v
'
)
;
}
void
nsHttpConnectionMgr
:
:
ThrottlerTick
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
mThrottleVersion
=
=
1
)
{
mThrottlingInhibitsReading
=
!
mThrottlingInhibitsReading
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
ThrottlerTick
inhibit
=
%
d
"
mThrottlingInhibitsReading
)
)
;
if
(
!
mThrottlingInhibitsReading
&
&
!
mDelayedResumeReadTimer
&
&
(
!
IsThrottleTickerNeeded
(
)
|
|
!
InThrottlingTimeWindow
(
)
)
)
{
LOG
(
(
"
last
tick
"
)
)
;
mThrottleTicker
=
nullptr
;
}
if
(
mThrottlingInhibitsReading
)
{
if
(
mThrottleTicker
)
{
mThrottleTicker
-
>
Init
(
this
mThrottleSuspendFor
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
}
else
{
if
(
mThrottleTicker
)
{
mThrottleTicker
-
>
Init
(
this
mThrottleResumeFor
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
ResumeReadOf
(
mActiveTransactions
[
false
]
true
)
;
ResumeReadOf
(
mActiveTransactions
[
true
]
)
;
}
}
else
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ThrottlerTick
"
)
)
;
if
(
!
mDelayedResumeReadTimer
&
&
(
!
IsThrottleTickerNeeded
(
)
|
|
!
InThrottlingTimeWindow
(
)
)
)
{
LOG
(
(
"
last
tick
"
)
)
;
mThrottleTicker
=
nullptr
;
}
if
(
mThrottleTicker
)
{
mThrottleTicker
-
>
Init
(
this
mThrottleReadInterval
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
ResumeReadOf
(
mActiveTransactions
[
false
]
true
)
;
ResumeReadOf
(
mActiveTransactions
[
true
]
)
;
}
}
void
nsHttpConnectionMgr
:
:
DelayedResumeBackgroundThrottledTransactions
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
mThrottleVersion
=
=
1
)
{
if
(
mDelayedResumeReadTimer
)
{
return
;
}
}
else
{
if
(
mDelayedResumeReadTimer
|
|
!
mThrottleTicker
)
{
return
;
}
}
LOG
(
(
"
nsHttpConnectionMgr
:
:
DelayedResumeBackgroundThrottledTransactions
"
)
)
;
NS_NewTimerWithObserver
(
getter_AddRefs
(
mDelayedResumeReadTimer
)
this
mThrottleHoldTime
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
void
nsHttpConnectionMgr
:
:
CancelDelayedResumeBackgroundThrottledTransactions
(
)
{
if
(
!
mDelayedResumeReadTimer
)
{
return
;
}
LOG
(
(
"
nsHttpConnectionMgr
:
:
"
"
CancelDelayedResumeBackgroundThrottledTransactions
"
)
)
;
mDelayedResumeReadTimer
-
>
Cancel
(
)
;
mDelayedResumeReadTimer
=
nullptr
;
}
void
nsHttpConnectionMgr
:
:
ResumeBackgroundThrottledTransactions
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
ResumeBackgroundThrottledTransactions
"
)
)
;
mDelayedResumeReadTimer
=
nullptr
;
if
(
!
IsThrottleTickerNeeded
(
)
)
{
DestroyThrottleTicker
(
)
;
}
if
(
!
mActiveTransactions
[
false
]
.
IsEmpty
(
)
)
{
ResumeReadOf
(
mActiveTransactions
[
false
]
true
)
;
}
else
{
ResumeReadOf
(
mActiveTransactions
[
true
]
true
)
;
}
}
void
nsHttpConnectionMgr
:
:
ResumeReadOf
(
nsClassHashtable
<
nsUint64HashKey
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
>
&
hashtable
bool
excludeForActiveTab
)
{
for
(
auto
iter
=
hashtable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
excludeForActiveTab
&
&
iter
.
Key
(
)
=
=
mCurrentTopLevelOuterContentWindowId
)
{
continue
;
}
ResumeReadOf
(
iter
.
UserData
(
)
)
;
}
}
void
nsHttpConnectionMgr
:
:
ResumeReadOf
(
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
*
transactions
)
{
MOZ_ASSERT
(
transactions
)
;
for
(
const
auto
&
trans
:
*
transactions
)
{
trans
-
>
ResumeReading
(
)
;
}
}
void
nsHttpConnectionMgr
:
:
NotifyConnectionOfWindowIdChange
(
uint64_t
previousWindowId
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
*
transactions
=
nullptr
;
nsTArray
<
RefPtr
<
nsAHttpConnection
>
>
connections
;
auto
addConnectionHelper
=
[
&
connections
]
(
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
*
trans
)
{
if
(
!
trans
)
{
return
;
}
for
(
const
auto
&
t
:
*
trans
)
{
RefPtr
<
nsAHttpConnection
>
conn
=
t
-
>
Connection
(
)
;
if
(
conn
&
&
!
connections
.
Contains
(
conn
)
)
{
connections
.
AppendElement
(
conn
)
;
}
}
}
;
transactions
=
mActiveTransactions
[
false
]
.
Get
(
previousWindowId
)
;
addConnectionHelper
(
transactions
)
;
transactions
=
mActiveTransactions
[
false
]
.
Get
(
mCurrentTopLevelOuterContentWindowId
)
;
addConnectionHelper
(
transactions
)
;
transactions
=
mActiveTransactions
[
true
]
.
Get
(
previousWindowId
)
;
addConnectionHelper
(
transactions
)
;
transactions
=
mActiveTransactions
[
true
]
.
Get
(
mCurrentTopLevelOuterContentWindowId
)
;
addConnectionHelper
(
transactions
)
;
for
(
const
auto
&
conn
:
connections
)
{
conn
-
>
TopLevelOuterContentWindowIdChanged
(
mCurrentTopLevelOuterContentWindowId
)
;
}
}
void
nsHttpConnectionMgr
:
:
OnMsgUpdateCurrentTopLevelOuterContentWindowId
(
int32_t
aLoading
ARefBase
*
param
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
uint64_t
winId
=
static_cast
<
UINT64Wrapper
*
>
(
param
)
-
>
GetValue
(
)
;
if
(
mCurrentTopLevelOuterContentWindowId
=
=
winId
)
{
return
;
}
bool
activeTabWasLoading
=
mActiveTabTransactionsExist
;
uint64_t
previousWindowId
=
mCurrentTopLevelOuterContentWindowId
;
mCurrentTopLevelOuterContentWindowId
=
winId
;
if
(
gHttpHandler
-
>
ActiveTabPriority
(
)
)
{
NotifyConnectionOfWindowIdChange
(
previousWindowId
)
;
}
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgUpdateCurrentTopLevelOuterContentWindowId
"
"
id
=
%
"
PRIx64
"
\
n
"
mCurrentTopLevelOuterContentWindowId
)
)
;
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
*
transactions
=
nullptr
;
transactions
=
mActiveTransactions
[
false
]
.
Get
(
mCurrentTopLevelOuterContentWindowId
)
;
mActiveTabUnthrottledTransactionsExist
=
!
!
transactions
;
if
(
!
mActiveTabUnthrottledTransactionsExist
)
{
transactions
=
mActiveTransactions
[
true
]
.
Get
(
mCurrentTopLevelOuterContentWindowId
)
;
}
mActiveTabTransactionsExist
=
!
!
transactions
;
if
(
transactions
)
{
LOG
(
(
"
resuming
newly
activated
tab
transactions
"
)
)
;
ResumeReadOf
(
transactions
)
;
return
;
}
if
(
!
activeTabWasLoading
)
{
return
;
}
if
(
!
mActiveTransactions
[
false
]
.
IsEmpty
(
)
)
{
LOG
(
(
"
resuming
unthrottled
background
transactions
"
)
)
;
ResumeReadOf
(
mActiveTransactions
[
false
]
)
;
return
;
}
if
(
!
mActiveTransactions
[
true
]
.
IsEmpty
(
)
)
{
LOG
(
(
"
resuming
throttled
background
transactions
"
)
)
;
ResumeReadOf
(
mActiveTransactions
[
true
]
)
;
return
;
}
DestroyThrottleTicker
(
)
;
}
void
nsHttpConnectionMgr
:
:
TimeoutTick
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mTimeoutTick
"
no
readtimeout
tick
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
TimeoutTick
active
=
%
d
\
n
"
mNumActiveConns
)
)
;
mTimeoutTickNext
=
3600
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
ConnectionEntry
>
ent
=
iter
.
Data
(
)
;
uint32_t
timeoutTickNext
=
ent
-
>
TimeoutTick
(
)
;
mTimeoutTickNext
=
std
:
:
min
(
mTimeoutTickNext
timeoutTickNext
)
;
}
if
(
mTimeoutTick
)
{
mTimeoutTickNext
=
std
:
:
max
(
mTimeoutTickNext
1U
)
;
mTimeoutTick
-
>
SetDelay
(
mTimeoutTickNext
*
1000
)
;
}
}
ConnectionEntry
*
nsHttpConnectionMgr
:
:
GetOrCreateConnectionEntry
(
nsHttpConnectionInfo
*
specificCI
bool
prohibitWildCard
bool
aNoHttp3
)
{
ConnectionEntry
*
specificEnt
=
mCT
.
GetWeak
(
specificCI
-
>
HashKey
(
)
)
;
if
(
specificEnt
&
&
specificEnt
-
>
AvailableForDispatchNow
(
)
)
{
return
specificEnt
;
}
RefPtr
<
nsHttpConnectionInfo
>
anonInvertedCI
(
specificCI
-
>
Clone
(
)
)
;
anonInvertedCI
-
>
SetAnonymous
(
!
specificCI
-
>
GetAnonymous
(
)
)
;
ConnectionEntry
*
invertedEnt
=
mCT
.
GetWeak
(
anonInvertedCI
-
>
HashKey
(
)
)
;
if
(
invertedEnt
)
{
HttpConnectionBase
*
h2orh3conn
=
GetH2orH3ActiveConn
(
invertedEnt
aNoHttp3
)
;
if
(
h2orh3conn
&
&
h2orh3conn
-
>
IsExperienced
(
)
&
&
h2orh3conn
-
>
NoClientCertAuth
(
)
)
{
MOZ_ASSERT
(
h2orh3conn
-
>
UsingSpdy
(
)
|
|
h2orh3conn
-
>
UsingHttp3
(
)
)
;
LOG
(
(
"
GetOrCreateConnectionEntry
is
coalescing
h2
/
3
an
/
onymous
"
"
connections
ent
=
%
p
"
invertedEnt
)
)
;
return
invertedEnt
;
}
}
if
(
!
specificCI
-
>
UsingHttpsProxy
(
)
)
{
prohibitWildCard
=
true
;
}
if
(
!
prohibitWildCard
&
&
!
aNoHttp3
)
{
RefPtr
<
nsHttpConnectionInfo
>
wildCardProxyCI
;
DebugOnly
<
nsresult
>
rv
=
specificCI
-
>
CreateWildCard
(
getter_AddRefs
(
wildCardProxyCI
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
ConnectionEntry
*
wildCardEnt
=
mCT
.
GetWeak
(
wildCardProxyCI
-
>
HashKey
(
)
)
;
if
(
wildCardEnt
&
&
wildCardEnt
-
>
AvailableForDispatchNow
(
)
)
{
return
wildCardEnt
;
}
}
if
(
!
specificEnt
)
{
RefPtr
<
nsHttpConnectionInfo
>
clone
(
specificCI
-
>
Clone
(
)
)
;
specificEnt
=
new
ConnectionEntry
(
clone
)
;
mCT
.
Put
(
clone
-
>
HashKey
(
)
RefPtr
{
specificEnt
}
)
;
}
return
specificEnt
;
}
void
nsHttpConnectionMgr
:
:
DoSpeculativeConnection
(
SpeculativeTransaction
*
aTrans
bool
aFetchHTTPSRR
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
aTrans
)
;
ConnectionEntry
*
ent
=
GetOrCreateConnectionEntry
(
aTrans
-
>
ConnectionInfo
(
)
false
aTrans
-
>
Caps
(
)
&
NS_HTTP_DISALLOW_HTTP3
)
;
uint32_t
parallelSpeculativeConnectLimit
=
aTrans
-
>
ParallelSpeculativeConnectLimit
(
)
?
*
aTrans
-
>
ParallelSpeculativeConnectLimit
(
)
:
gHttpHandler
-
>
ParallelSpeculativeConnectLimit
(
)
;
bool
ignoreIdle
=
aTrans
-
>
IgnoreIdle
(
)
?
*
aTrans
-
>
IgnoreIdle
(
)
:
false
;
bool
isFromPredictor
=
aTrans
-
>
IsFromPredictor
(
)
?
*
aTrans
-
>
IsFromPredictor
(
)
:
false
;
bool
allow1918
=
aTrans
-
>
Allow1918
(
)
?
*
aTrans
-
>
Allow1918
(
)
:
false
;
bool
keepAlive
=
aTrans
-
>
Caps
(
)
&
NS_HTTP_ALLOW_KEEPALIVE
;
if
(
mNumHalfOpenConns
<
parallelSpeculativeConnectLimit
&
&
(
(
ignoreIdle
&
&
(
ent
-
>
IdleConnectionsLength
(
)
<
parallelSpeculativeConnectLimit
)
)
|
|
!
ent
-
>
IdleConnectionsLength
(
)
)
&
&
!
(
keepAlive
&
&
ent
-
>
RestrictConnections
(
)
)
&
&
!
AtActiveConnectionLimit
(
ent
aTrans
-
>
Caps
(
)
)
)
{
if
(
aFetchHTTPSRR
)
{
Unused
<
<
aTrans
-
>
FetchHTTPSRR
(
)
;
}
DebugOnly
<
nsresult
>
rv
=
CreateTransport
(
ent
aTrans
aTrans
-
>
Caps
(
)
true
isFromPredictor
false
allow1918
nullptr
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
else
{
LOG
(
(
"
OnMsgSpeculativeConnect
Transport
"
"
not
created
due
to
existing
connection
count
\
n
"
)
)
;
}
}
void
nsHttpConnectionMgr
:
:
OnMsgSpeculativeConnect
(
int32_t
ARefBase
*
param
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
SpeculativeConnectArgs
*
args
=
static_cast
<
SpeculativeConnectArgs
*
>
(
param
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgSpeculativeConnect
[
ci
=
%
s
"
"
mFetchHTTPSRR
=
%
d
]
\
n
"
args
-
>
mTrans
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
.
get
(
)
args
-
>
mFetchHTTPSRR
)
)
;
DoSpeculativeConnection
(
args
-
>
mTrans
args
-
>
mFetchHTTPSRR
)
;
}
bool
nsHttpConnectionMgr
:
:
BeConservativeIfProxied
(
nsIProxyInfo
*
proxy
)
{
if
(
mBeConservativeForProxy
)
{
return
true
;
}
if
(
!
proxy
)
{
return
true
;
}
nsAutoCString
proxyHost
;
proxy
-
>
GetHost
(
proxyHost
)
;
return
proxyHost
.
IsEmpty
(
)
;
}
void
nsHttpConnectionMgr
:
:
RegisterOriginCoalescingKey
(
HttpConnectionBase
*
conn
const
nsACString
&
host
int32_t
port
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
nsHttpConnectionInfo
*
ci
=
conn
?
conn
-
>
ConnectionInfo
(
)
:
nullptr
;
if
(
!
ci
|
|
!
conn
-
>
CanDirectlyActivate
(
)
)
{
return
;
}
nsCString
newKey
;
BuildOriginFrameHashKey
(
newKey
ci
host
port
)
;
nsTArray
<
nsWeakPtr
>
*
listOfWeakConns
=
mCoalescingHash
.
Get
(
newKey
)
;
if
(
!
listOfWeakConns
)
{
listOfWeakConns
=
new
nsTArray
<
nsWeakPtr
>
(
1
)
;
mCoalescingHash
.
Put
(
newKey
listOfWeakConns
)
;
}
listOfWeakConns
-
>
AppendElement
(
do_GetWeakReference
(
static_cast
<
nsISupportsWeakReference
*
>
(
conn
)
)
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
RegisterOriginCoalescingKey
"
"
Established
New
Coalescing
Key
%
s
to
%
p
%
s
\
n
"
newKey
.
get
(
)
conn
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
}
bool
nsHttpConnectionMgr
:
:
GetConnectionData
(
nsTArray
<
HttpRetParams
>
*
aArg
)
{
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
ConnectionEntry
>
ent
=
iter
.
Data
(
)
;
if
(
ent
-
>
mConnInfo
-
>
GetPrivate
(
)
)
{
continue
;
}
aArg
-
>
AppendElement
(
ent
-
>
GetConnectionData
(
)
)
;
}
return
true
;
}
void
nsHttpConnectionMgr
:
:
ResetIPFamilyPreference
(
nsHttpConnectionInfo
*
ci
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
ci
-
>
HashKey
(
)
)
;
if
(
ent
)
{
ent
-
>
ResetIPFamilyPreference
(
)
;
}
}
void
nsHttpConnectionMgr
:
:
ExcludeHttp2
(
const
nsHttpConnectionInfo
*
ci
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ExcludeHttp2
excluding
ci
%
s
"
ci
-
>
HashKey
(
)
.
BeginReading
(
)
)
)
;
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
ci
-
>
HashKey
(
)
)
;
if
(
!
ent
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ExcludeHttp2
no
entry
found
?
!
"
)
)
;
return
;
}
ent
-
>
DisallowHttp2
(
)
;
}
void
nsHttpConnectionMgr
:
:
ExcludeHttp3
(
const
nsHttpConnectionInfo
*
ci
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ExcludeHttp3
exclude
ci
%
s
"
ci
-
>
HashKey
(
)
.
BeginReading
(
)
)
)
;
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
ci
-
>
HashKey
(
)
)
;
if
(
!
ent
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ExcludeHttp3
no
entry
found
?
!
"
)
)
;
return
;
}
ent
-
>
DontReuseHttp3Conn
(
)
;
}
void
nsHttpConnectionMgr
:
:
MoveToWildCardConnEntry
(
nsHttpConnectionInfo
*
specificCI
nsHttpConnectionInfo
*
wildCardCI
HttpConnectionBase
*
proxyConn
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
specificCI
-
>
UsingHttpsProxy
(
)
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeConnEntryWildCard
conn
%
p
has
requested
to
"
"
change
CI
from
%
s
to
%
s
\
n
"
proxyConn
specificCI
-
>
HashKey
(
)
.
get
(
)
wildCardCI
-
>
HashKey
(
)
.
get
(
)
)
)
;
ConnectionEntry
*
ent
=
mCT
.
GetWeak
(
specificCI
-
>
HashKey
(
)
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeConnEntryWildCard
conn
%
p
using
ent
%
p
(
spdy
"
"
%
d
)
\
n
"
proxyConn
ent
ent
?
ent
-
>
mUsingSpdy
:
0
)
)
;
if
(
!
ent
|
|
!
ent
-
>
mUsingSpdy
)
{
return
;
}
ConnectionEntry
*
wcEnt
=
GetOrCreateConnectionEntry
(
wildCardCI
true
false
)
;
if
(
wcEnt
=
=
ent
)
{
return
;
}
wcEnt
-
>
mUsingSpdy
=
true
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeConnEntryWildCard
ent
%
p
"
"
idle
=
%
zu
active
=
%
zu
half
=
%
zu
pending
=
%
zu
\
n
"
ent
ent
-
>
IdleConnectionsLength
(
)
ent
-
>
ActiveConnsLength
(
)
ent
-
>
HalfOpensLength
(
)
ent
-
>
PendingQueueLength
(
)
)
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeConnEntryWildCard
wc
-
ent
%
p
"
"
idle
=
%
zu
active
=
%
zu
half
=
%
zu
pending
=
%
zu
\
n
"
wcEnt
wcEnt
-
>
IdleConnectionsLength
(
)
wcEnt
-
>
ActiveConnsLength
(
)
wcEnt
-
>
HalfOpensLength
(
)
wcEnt
-
>
PendingQueueLength
(
)
)
)
;
ent
-
>
MoveConnection
(
proxyConn
wcEnt
)
;
}
bool
nsHttpConnectionMgr
:
:
MoveTransToHTTPSSVCConnEntry
(
nsHttpTransaction
*
aTrans
nsHttpConnectionInfo
*
aNewCI
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
MoveTransToHTTPSSVCConnEntry
:
trans
=
%
p
aNewCI
=
%
s
"
aTrans
aNewCI
-
>
HashKey
(
)
.
get
(
)
)
)
;
bool
prohibitWildCard
=
!
!
aTrans
-
>
TunnelProvider
(
)
;
bool
noHttp3
=
aTrans
-
>
Caps
(
)
&
NS_HTTP_DISALLOW_HTTP3
;
ConnectionEntry
*
oldEntry
=
GetOrCreateConnectionEntry
(
aTrans
-
>
ConnectionInfo
(
)
prohibitWildCard
noHttp3
)
;
ConnectionEntry
*
newEntry
=
GetOrCreateConnectionEntry
(
aNewCI
prohibitWildCard
noHttp3
)
;
if
(
oldEntry
=
=
newEntry
)
{
return
true
;
}
int32_t
transIndex
;
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
*
infoArray
=
oldEntry
-
>
GetTransactionPendingQHelper
(
aTrans
)
;
RefPtr
<
PendingTransactionInfo
>
pendingTransInfo
;
transIndex
=
infoArray
?
infoArray
-
>
IndexOf
(
aTrans
0
PendingComparator
(
)
)
:
-
1
;
if
(
transIndex
>
=
0
)
{
pendingTransInfo
=
(
*
infoArray
)
[
transIndex
]
;
infoArray
-
>
RemoveElementAt
(
transIndex
)
;
}
if
(
!
pendingTransInfo
)
{
return
false
;
}
MOZ_ASSERT
(
pendingTransInfo
-
>
Transaction
(
)
=
=
aTrans
)
;
pendingTransInfo
-
>
AbandonHalfOpenAndForgetActiveConn
(
)
;
aTrans
-
>
UpdateConnectionInfo
(
aNewCI
)
;
Unused
<
<
ProcessNewTransaction
(
aTrans
)
;
return
true
;
}
void
nsHttpConnectionMgr
:
:
IncreaseNumHalfOpenConns
(
)
{
mNumHalfOpenConns
+
+
;
}
void
nsHttpConnectionMgr
:
:
DecreaseNumHalfOpenConns
(
)
{
MOZ_ASSERT
(
mNumHalfOpenConns
)
;
if
(
mNumHalfOpenConns
)
{
mNumHalfOpenConns
-
-
;
}
}
already_AddRefed
<
PendingTransactionInfo
>
nsHttpConnectionMgr
:
:
FindTransactionHelper
(
bool
removeWhenFound
ConnectionEntry
*
aEnt
nsAHttpTransaction
*
aTrans
)
{
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
*
pendingQ
=
aEnt
-
>
GetTransactionPendingQHelper
(
aTrans
)
;
int32_t
index
=
pendingQ
?
pendingQ
-
>
IndexOf
(
aTrans
0
PendingComparator
(
)
)
:
-
1
;
RefPtr
<
PendingTransactionInfo
>
info
;
if
(
index
!
=
-
1
)
{
info
=
(
*
pendingQ
)
[
index
]
;
if
(
removeWhenFound
)
{
pendingQ
-
>
RemoveElementAt
(
index
)
;
}
}
return
info
.
forget
(
)
;
}
nsHttpConnectionMgr
*
nsHttpConnectionMgr
:
:
AsHttpConnectionMgr
(
)
{
return
this
;
}
HttpConnectionMgrParent
*
nsHttpConnectionMgr
:
:
AsHttpConnectionMgrParent
(
)
{
return
nullptr
;
}
void
nsHttpConnectionMgr
:
:
NewIdleConnectionAdded
(
uint32_t
timeToLive
)
{
mNumIdleConns
+
+
;
if
(
!
mTimer
|
|
NowInSeconds
(
)
+
timeToLive
<
mTimeOfNextWakeUp
)
PruneDeadConnectionsAfter
(
timeToLive
)
;
}
void
nsHttpConnectionMgr
:
:
DecrementNumIdleConns
(
)
{
MOZ_ASSERT
(
mNumIdleConns
)
;
mNumIdleConns
-
-
;
ConditionallyStopPruneDeadConnectionsTimer
(
)
;
}
}
}
