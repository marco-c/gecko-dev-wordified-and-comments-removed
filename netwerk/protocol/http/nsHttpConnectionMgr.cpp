#
include
"
HttpLog
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
#
include
"
nsHttpConnectionMgr
.
h
"
#
include
"
nsHttpConnection
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
nsISocketTransport
.
h
"
#
include
"
nsISSLSocketControl
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
net
/
DashboardTypes
.
h
"
#
include
"
NullHttpTransaction
.
h
"
#
include
"
nsIDNSRecord
.
h
"
#
include
"
nsITransport
.
h
"
#
include
"
nsInterfaceRequestorAgg
.
h
"
#
include
"
nsIRequestContext
.
h
"
#
include
"
nsISocketTransportService
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ChaosMode
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
namespace
mozilla
{
namespace
net
{
NS_IMPL_ISUPPORTS
(
nsHttpConnectionMgr
nsIObserver
)
static
void
InsertTransactionSorted
(
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
&
pendingQ
nsHttpTransaction
*
trans
)
{
for
(
int32_t
i
=
pendingQ
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
nsHttpTransaction
*
t
=
pendingQ
[
i
]
;
if
(
trans
-
>
Priority
(
)
>
=
t
-
>
Priority
(
)
)
{
if
(
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
NetworkScheduling
)
)
{
int32_t
samePriorityCount
;
for
(
samePriorityCount
=
0
;
i
-
samePriorityCount
>
=
0
;
+
+
samePriorityCount
)
{
if
(
pendingQ
[
i
-
samePriorityCount
]
-
>
Priority
(
)
!
=
trans
-
>
Priority
(
)
)
{
break
;
}
}
i
-
=
ChaosMode
:
:
randomUint32LessThan
(
samePriorityCount
+
1
)
;
}
pendingQ
.
InsertElementAt
(
i
+
1
trans
)
;
return
;
}
}
pendingQ
.
InsertElementAt
(
0
trans
)
;
}
nsHttpConnectionMgr
:
:
nsHttpConnectionMgr
(
)
:
mReentrantMonitor
(
"
nsHttpConnectionMgr
.
mReentrantMonitor
"
)
mMaxConns
(
0
)
mMaxPersistConnsPerHost
(
0
)
mMaxPersistConnsPerProxy
(
0
)
mIsShuttingDown
(
false
)
mNumActiveConns
(
0
)
mNumIdleConns
(
0
)
mNumSpdyActiveConns
(
0
)
mNumHalfOpenConns
(
0
)
mTimeOfNextWakeUp
(
UINT64_MAX
)
mPruningNoTraffic
(
false
)
mTimeoutTickArmed
(
false
)
mTimeoutTickNext
(
1
)
mCurrentTopLevelOuterContentWindowId
(
0
)
{
LOG
(
(
"
Creating
nsHttpConnectionMgr
%
p
\
n
"
this
)
)
;
}
nsHttpConnectionMgr
:
:
~
nsHttpConnectionMgr
(
)
{
LOG
(
(
"
Destroying
nsHttpConnectionMgr
%
p
\
n
"
this
)
)
;
if
(
mTimeoutTick
)
mTimeoutTick
-
>
Cancel
(
)
;
}
nsresult
nsHttpConnectionMgr
:
:
EnsureSocketThreadTarget
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIEventTarget
>
sts
;
nsCOMPtr
<
nsIIOService
>
ioService
=
do_GetIOService
(
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
sts
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
if
(
mSocketThreadTarget
|
|
mIsShuttingDown
)
return
NS_OK
;
mSocketThreadTarget
=
sts
;
return
rv
;
}
nsresult
nsHttpConnectionMgr
:
:
Init
(
uint16_t
maxConns
uint16_t
maxPersistConnsPerHost
uint16_t
maxPersistConnsPerProxy
uint16_t
maxRequestDelay
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
Init
\
n
"
)
)
;
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
mMaxConns
=
maxConns
;
mMaxPersistConnsPerHost
=
maxPersistConnsPerHost
;
mMaxPersistConnsPerProxy
=
maxPersistConnsPerProxy
;
mMaxRequestDelay
=
maxRequestDelay
;
mIsShuttingDown
=
false
;
}
return
EnsureSocketThreadTarget
(
)
;
}
class
BoolWrapper
:
public
ARefBase
{
public
:
BoolWrapper
(
)
:
mBool
(
false
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
BoolWrapper
)
public
:
bool
mBool
;
private
:
virtual
~
BoolWrapper
(
)
{
}
}
;
nsresult
nsHttpConnectionMgr
:
:
Shutdown
(
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
Shutdown
\
n
"
)
)
;
RefPtr
<
BoolWrapper
>
shutdownWrapper
=
new
BoolWrapper
(
)
;
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
if
(
!
mSocketThreadTarget
)
return
NS_OK
;
nsresult
rv
=
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgShutdown
0
shutdownWrapper
)
;
mIsShuttingDown
=
true
;
mSocketThreadTarget
=
nullptr
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
unable
to
post
SHUTDOWN
message
"
)
;
return
rv
;
}
}
while
(
!
shutdownWrapper
-
>
mBool
)
{
NS_ProcessNextEvent
(
NS_GetCurrentThread
(
)
)
;
}
return
NS_OK
;
}
class
ConnEvent
:
public
Runnable
{
public
:
ConnEvent
(
nsHttpConnectionMgr
*
mgr
nsConnEventHandler
handler
int32_t
iparam
ARefBase
*
vparam
)
:
mMgr
(
mgr
)
mHandler
(
handler
)
mIParam
(
iparam
)
mVParam
(
vparam
)
{
}
NS_IMETHOD
Run
(
)
override
{
(
mMgr
-
>
*
mHandler
)
(
mIParam
mVParam
)
;
return
NS_OK
;
}
private
:
virtual
~
ConnEvent
(
)
{
}
RefPtr
<
nsHttpConnectionMgr
>
mMgr
;
nsConnEventHandler
mHandler
;
int32_t
mIParam
;
RefPtr
<
ARefBase
>
mVParam
;
}
;
nsresult
nsHttpConnectionMgr
:
:
PostEvent
(
nsConnEventHandler
handler
int32_t
iparam
ARefBase
*
vparam
)
{
Unused
<
<
EnsureSocketThreadTarget
(
)
;
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
nsresult
rv
;
if
(
!
mSocketThreadTarget
)
{
NS_WARNING
(
"
cannot
post
event
if
not
initialized
"
)
;
rv
=
NS_ERROR_NOT_INITIALIZED
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
ConnEvent
(
this
handler
iparam
vparam
)
;
rv
=
mSocketThreadTarget
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
return
rv
;
}
void
nsHttpConnectionMgr
:
:
PruneDeadConnectionsAfter
(
uint32_t
timeInSeconds
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
PruneDeadConnectionsAfter
\
n
"
)
)
;
if
(
!
mTimer
)
mTimer
=
do_CreateInstance
(
"
mozilla
.
org
/
timer
;
1
"
)
;
if
(
mTimer
)
{
mTimeOfNextWakeUp
=
timeInSeconds
+
NowInSeconds
(
)
;
mTimer
-
>
Init
(
this
timeInSeconds
*
1000
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
else
{
NS_WARNING
(
"
failed
to
create
:
timer
for
pruning
the
dead
connections
!
"
)
;
}
}
void
nsHttpConnectionMgr
:
:
ConditionallyStopPruneDeadConnectionsTimer
(
)
{
if
(
mNumIdleConns
|
|
(
mNumActiveConns
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
)
)
return
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
StopPruneDeadConnectionsTimer
\
n
"
)
)
;
mTimeOfNextWakeUp
=
UINT64_MAX
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
}
void
nsHttpConnectionMgr
:
:
ConditionallyStopTimeoutTick
(
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ConditionallyStopTimeoutTick
"
"
armed
=
%
d
active
=
%
d
\
n
"
mTimeoutTickArmed
mNumActiveConns
)
)
;
if
(
!
mTimeoutTickArmed
)
return
;
if
(
mNumActiveConns
)
return
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
ConditionallyStopTimeoutTick
stop
=
=
true
\
n
"
)
)
;
mTimeoutTick
-
>
Cancel
(
)
;
mTimeoutTickArmed
=
false
;
}
NS_IMETHODIMP
nsHttpConnectionMgr
:
:
Observe
(
nsISupports
*
subject
const
char
*
topic
const
char16_t
*
data
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
Observe
[
topic
=
\
"
%
s
\
"
]
\
n
"
topic
)
)
;
if
(
0
=
=
strcmp
(
topic
NS_TIMER_CALLBACK_TOPIC
)
)
{
nsCOMPtr
<
nsITimer
>
timer
=
do_QueryInterface
(
subject
)
;
if
(
timer
=
=
mTimer
)
{
Unused
<
<
PruneDeadConnections
(
)
;
}
else
if
(
timer
=
=
mTimeoutTick
)
{
TimeoutTick
(
)
;
}
else
if
(
timer
=
=
mTrafficTimer
)
{
Unused
<
<
PruneNoTraffic
(
)
;
}
else
{
MOZ_ASSERT
(
false
"
unexpected
timer
-
callback
"
)
;
LOG
(
(
"
Unexpected
timer
object
\
n
"
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
return
NS_OK
;
}
nsresult
nsHttpConnectionMgr
:
:
AddTransaction
(
nsHttpTransaction
*
trans
int32_t
priority
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
AddTransaction
[
trans
=
%
p
%
d
]
\
n
"
trans
priority
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgNewTransaction
priority
trans
)
;
}
nsresult
nsHttpConnectionMgr
:
:
RescheduleTransaction
(
nsHttpTransaction
*
trans
int32_t
priority
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
RescheduleTransaction
[
trans
=
%
p
%
d
]
\
n
"
trans
priority
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgReschedTransaction
priority
trans
)
;
}
nsresult
nsHttpConnectionMgr
:
:
CancelTransaction
(
nsHttpTransaction
*
trans
nsresult
reason
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
CancelTransaction
[
trans
=
%
p
reason
=
%
"
PRIx32
"
]
\
n
"
trans
static_cast
<
uint32_t
>
(
reason
)
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgCancelTransaction
static_cast
<
int32_t
>
(
reason
)
trans
)
;
}
nsresult
nsHttpConnectionMgr
:
:
PruneDeadConnections
(
)
{
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgPruneDeadConnections
)
;
}
nsresult
nsHttpConnectionMgr
:
:
PruneNoTraffic
(
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
PruneNoTraffic
\
n
"
)
)
;
mPruningNoTraffic
=
true
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgPruneNoTraffic
)
;
}
nsresult
nsHttpConnectionMgr
:
:
VerifyTraffic
(
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
VerifyTraffic
\
n
"
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgVerifyTraffic
)
;
}
nsresult
nsHttpConnectionMgr
:
:
DoShiftReloadConnectionCleanup
(
nsHttpConnectionInfo
*
aCI
)
{
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgDoShiftReloadConnectionCleanup
0
aCI
)
;
}
class
SpeculativeConnectArgs
:
public
ARefBase
{
public
:
SpeculativeConnectArgs
(
)
{
mOverridesOK
=
false
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SpeculativeConnectArgs
)
public
:
RefPtr
<
NullHttpTransaction
>
mTrans
;
bool
mOverridesOK
;
uint32_t
mParallelSpeculativeConnectLimit
;
bool
mIgnoreIdle
;
bool
mIsFromPredictor
;
bool
mAllow1918
;
private
:
virtual
~
SpeculativeConnectArgs
(
)
{
}
NS_DECL_OWNINGTHREAD
}
;
nsresult
nsHttpConnectionMgr
:
:
SpeculativeConnect
(
nsHttpConnectionInfo
*
ci
nsIInterfaceRequestor
*
callbacks
uint32_t
caps
NullHttpTransaction
*
nullTransaction
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
nsHttpConnectionMgr
:
:
SpeculativeConnect
called
off
main
thread
!
"
)
;
if
(
!
IsNeckoChild
(
)
)
{
net_EnsurePSMInit
(
)
;
}
LOG
(
(
"
nsHttpConnectionMgr
:
:
SpeculativeConnect
[
ci
=
%
s
]
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
nsCOMPtr
<
nsISpeculativeConnectionOverrider
>
overrider
=
do_GetInterface
(
callbacks
)
;
bool
allow1918
=
overrider
?
overrider
-
>
GetAllow1918
(
)
:
false
;
if
(
(
!
allow1918
)
&
&
ci
&
&
ci
-
>
HostIsLocalIPLiteral
(
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
SpeculativeConnect
skipping
RFC1918
"
"
address
[
%
s
]
"
ci
-
>
Origin
(
)
)
)
;
return
NS_OK
;
}
RefPtr
<
SpeculativeConnectArgs
>
args
=
new
SpeculativeConnectArgs
(
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
wrappedCallbacks
;
NS_NewInterfaceRequestorAggregation
(
callbacks
nullptr
getter_AddRefs
(
wrappedCallbacks
)
)
;
caps
|
=
ci
-
>
GetAnonymous
(
)
?
NS_HTTP_LOAD_ANONYMOUS
:
0
;
caps
|
=
NS_HTTP_ERROR_SOFTLY
;
args
-
>
mTrans
=
nullTransaction
?
nullTransaction
:
new
NullHttpTransaction
(
ci
wrappedCallbacks
caps
)
;
if
(
overrider
)
{
args
-
>
mOverridesOK
=
true
;
args
-
>
mParallelSpeculativeConnectLimit
=
overrider
-
>
GetParallelSpeculativeConnectLimit
(
)
;
args
-
>
mIgnoreIdle
=
overrider
-
>
GetIgnoreIdle
(
)
;
args
-
>
mIsFromPredictor
=
overrider
-
>
GetIsFromPredictor
(
)
;
args
-
>
mAllow1918
=
overrider
-
>
GetAllow1918
(
)
;
}
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgSpeculativeConnect
0
args
)
;
}
nsresult
nsHttpConnectionMgr
:
:
GetSocketThreadTarget
(
nsIEventTarget
*
*
target
)
{
Unused
<
<
EnsureSocketThreadTarget
(
)
;
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
nsCOMPtr
<
nsIEventTarget
>
temp
(
mSocketThreadTarget
)
;
temp
.
forget
(
target
)
;
return
NS_OK
;
}
nsresult
nsHttpConnectionMgr
:
:
ReclaimConnection
(
nsHttpConnection
*
conn
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ReclaimConnection
[
conn
=
%
p
]
\
n
"
conn
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgReclaimConnection
0
conn
)
;
}
class
nsCompleteUpgradeData
:
public
ARefBase
{
public
:
nsCompleteUpgradeData
(
nsAHttpConnection
*
aConn
nsIHttpUpgradeListener
*
aListener
)
:
mConn
(
aConn
)
mUpgradeListener
(
aListener
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsCompleteUpgradeData
)
RefPtr
<
nsAHttpConnection
>
mConn
;
nsCOMPtr
<
nsIHttpUpgradeListener
>
mUpgradeListener
;
private
:
virtual
~
nsCompleteUpgradeData
(
)
{
}
}
;
nsresult
nsHttpConnectionMgr
:
:
CompleteUpgrade
(
nsAHttpConnection
*
aConn
nsIHttpUpgradeListener
*
aUpgradeListener
)
{
RefPtr
<
nsCompleteUpgradeData
>
data
=
new
nsCompleteUpgradeData
(
aConn
aUpgradeListener
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgCompleteUpgrade
0
data
)
;
}
nsresult
nsHttpConnectionMgr
:
:
UpdateParam
(
nsParamName
name
uint16_t
value
)
{
uint32_t
param
=
(
uint32_t
(
name
)
<
<
16
)
|
uint32_t
(
value
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgUpdateParam
static_cast
<
int32_t
>
(
param
)
nullptr
)
;
}
nsresult
nsHttpConnectionMgr
:
:
ProcessPendingQ
(
nsHttpConnectionInfo
*
ci
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ProcessPendingQ
[
ci
=
%
s
]
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgProcessPendingQ
0
ci
)
;
}
nsresult
nsHttpConnectionMgr
:
:
ProcessPendingQ
(
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ProcessPendingQ
[
All
CI
]
\
n
"
)
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgProcessPendingQ
0
nullptr
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgUpdateRequestTokenBucket
(
int32_t
ARefBase
*
param
)
{
EventTokenBucket
*
tokenBucket
=
static_cast
<
EventTokenBucket
*
>
(
param
)
;
gHttpHandler
-
>
SetRequestTokenBucket
(
tokenBucket
)
;
}
nsresult
nsHttpConnectionMgr
:
:
UpdateRequestTokenBucket
(
EventTokenBucket
*
aBucket
)
{
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgUpdateRequestTokenBucket
0
aBucket
)
;
}
nsresult
nsHttpConnectionMgr
:
:
ClearConnectionHistory
(
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
nsConnectionEntry
>
&
ent
=
iter
.
Data
(
)
;
if
(
ent
-
>
mIdleConns
.
Length
(
)
=
=
0
&
&
ent
-
>
mActiveConns
.
Length
(
)
=
=
0
&
&
ent
-
>
mHalfOpens
.
Length
(
)
=
=
0
&
&
ent
-
>
mPendingQ
.
Length
(
)
=
=
0
)
{
iter
.
Remove
(
)
;
}
}
return
NS_OK
;
}
nsHttpConnectionMgr
:
:
nsConnectionEntry
*
nsHttpConnectionMgr
:
:
LookupPreferredHash
(
nsHttpConnectionMgr
:
:
nsConnectionEntry
*
ent
)
{
nsConnectionEntry
*
preferred
=
nullptr
;
uint32_t
len
=
ent
-
>
mCoalescingKeys
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
!
preferred
&
&
(
i
<
len
)
;
+
+
i
)
{
preferred
=
mSpdyPreferredHash
.
Get
(
ent
-
>
mCoalescingKeys
[
i
]
)
;
}
return
preferred
;
}
void
nsHttpConnectionMgr
:
:
StorePreferredHash
(
nsHttpConnectionMgr
:
:
nsConnectionEntry
*
ent
)
{
if
(
ent
-
>
mCoalescingKeys
.
IsEmpty
(
)
)
{
return
;
}
ent
-
>
mInPreferredHash
=
true
;
uint32_t
len
=
ent
-
>
mCoalescingKeys
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
mSpdyPreferredHash
.
Put
(
ent
-
>
mCoalescingKeys
[
i
]
ent
)
;
}
}
void
nsHttpConnectionMgr
:
:
RemovePreferredHash
(
nsHttpConnectionMgr
:
:
nsConnectionEntry
*
ent
)
{
if
(
!
ent
-
>
mInPreferredHash
|
|
ent
-
>
mCoalescingKeys
.
IsEmpty
(
)
)
{
return
;
}
ent
-
>
mInPreferredHash
=
false
;
uint32_t
len
=
ent
-
>
mCoalescingKeys
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
mSpdyPreferredHash
.
Remove
(
ent
-
>
mCoalescingKeys
[
i
]
)
;
}
}
nsHttpConnectionMgr
:
:
nsConnectionEntry
*
nsHttpConnectionMgr
:
:
LookupConnectionEntry
(
nsHttpConnectionInfo
*
ci
nsHttpConnection
*
conn
nsHttpTransaction
*
trans
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
if
(
!
ci
)
return
nullptr
;
nsConnectionEntry
*
ent
=
mCT
.
Get
(
ci
-
>
HashKey
(
)
)
;
if
(
!
ent
|
|
!
ent
-
>
mUsingSpdy
|
|
ent
-
>
mCoalescingKeys
.
IsEmpty
(
)
)
return
ent
;
nsConnectionEntry
*
preferred
=
LookupPreferredHash
(
ent
)
;
if
(
!
preferred
|
|
(
preferred
=
=
ent
)
)
return
ent
;
if
(
conn
)
{
if
(
preferred
-
>
mActiveConns
.
Contains
(
conn
)
)
return
preferred
;
if
(
preferred
-
>
mIdleConns
.
Contains
(
conn
)
)
return
preferred
;
}
if
(
trans
&
&
preferred
-
>
mPendingQ
.
Contains
(
trans
)
)
return
preferred
;
return
ent
;
}
nsresult
nsHttpConnectionMgr
:
:
CloseIdleConnection
(
nsHttpConnection
*
conn
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
CloseIdleConnection
%
p
conn
=
%
p
"
this
conn
)
)
;
if
(
!
conn
-
>
ConnectionInfo
(
)
)
return
NS_ERROR_UNEXPECTED
;
nsConnectionEntry
*
ent
=
LookupConnectionEntry
(
conn
-
>
ConnectionInfo
(
)
conn
nullptr
)
;
RefPtr
<
nsHttpConnection
>
deleteProtector
(
conn
)
;
if
(
!
ent
|
|
!
ent
-
>
mIdleConns
.
RemoveElement
(
conn
)
)
return
NS_ERROR_UNEXPECTED
;
conn
-
>
Close
(
NS_ERROR_ABORT
)
;
mNumIdleConns
-
-
;
ConditionallyStopPruneDeadConnectionsTimer
(
)
;
return
NS_OK
;
}
void
nsHttpConnectionMgr
:
:
ReportSpdyConnection
(
nsHttpConnection
*
conn
bool
usingSpdy
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
nsConnectionEntry
*
ent
=
LookupConnectionEntry
(
conn
-
>
ConnectionInfo
(
)
conn
nullptr
)
;
if
(
!
ent
)
return
;
if
(
!
usingSpdy
)
return
;
ent
-
>
mUsingSpdy
=
true
;
mNumSpdyActiveConns
+
+
;
uint32_t
ttl
=
conn
-
>
TimeToLive
(
)
;
uint64_t
timeOfExpire
=
NowInSeconds
(
)
+
ttl
;
if
(
!
mTimer
|
|
timeOfExpire
<
mTimeOfNextWakeUp
)
PruneDeadConnectionsAfter
(
ttl
)
;
nsConnectionEntry
*
joinedConnection
;
nsConnectionEntry
*
preferred
=
LookupPreferredHash
(
ent
)
;
LOG
(
(
"
ReportSpdyConnection
%
p
%
s
conn
%
p
prefers
%
p
%
s
\
n
"
ent
ent
-
>
mConnInfo
-
>
Origin
(
)
conn
preferred
preferred
?
preferred
-
>
mConnInfo
-
>
Origin
(
)
:
"
"
)
)
;
if
(
!
preferred
)
{
StorePreferredHash
(
ent
)
;
preferred
=
ent
;
}
else
if
(
(
preferred
!
=
ent
)
&
&
(
joinedConnection
=
GetSpdyPreferredEnt
(
ent
)
)
&
&
(
joinedConnection
!
=
ent
)
)
{
LOG
(
(
"
ReportSpdyConnection
graceful
close
of
conn
=
%
p
ent
=
%
p
to
"
"
migrate
to
preferred
(
desharding
)
\
n
"
conn
ent
)
)
;
conn
-
>
DontReuse
(
)
;
}
else
if
(
preferred
!
=
ent
)
{
LOG
(
(
"
ReportSpdyConnection
preferred
host
may
be
in
false
start
or
"
"
may
have
insufficient
cert
.
Leave
mapping
in
place
but
do
not
"
"
abandon
this
connection
yet
.
"
)
)
;
}
if
(
(
preferred
=
=
ent
)
&
&
conn
-
>
CanDirectlyActivate
(
)
)
{
for
(
int32_t
index
=
ent
-
>
mHalfOpens
.
Length
(
)
-
1
;
index
>
=
0
;
-
-
index
)
{
LOG
(
(
"
ReportSpdyConnection
forcing
halfopen
abandon
%
p
\
n
"
ent
-
>
mHalfOpens
[
index
]
)
)
;
ent
-
>
mHalfOpens
[
index
]
-
>
Abandon
(
)
;
}
if
(
ent
-
>
mActiveConns
.
Length
(
)
>
1
)
{
for
(
uint32_t
index
=
0
;
index
<
ent
-
>
mActiveConns
.
Length
(
)
;
+
+
index
)
{
nsHttpConnection
*
otherConn
=
ent
-
>
mActiveConns
[
index
]
;
if
(
otherConn
!
=
conn
)
{
LOG
(
(
"
ReportSpdyConnection
shutting
down
connection
(
%
p
)
because
new
"
"
spdy
connection
(
%
p
)
takes
precedence
\
n
"
otherConn
conn
)
)
;
otherConn
-
>
DontReuse
(
)
;
}
}
}
}
nsresult
rv
=
ProcessPendingQ
(
ent
-
>
mConnInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ReportSpdyConnection
conn
=
%
p
ent
=
%
p
"
"
failed
to
process
pending
queue
(
%
08x
)
\
n
"
conn
ent
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
rv
=
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgProcessAllSpdyPendingQ
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ReportSpdyConnection
conn
=
%
p
ent
=
%
p
"
"
failed
to
post
event
(
%
08x
)
\
n
"
conn
ent
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
nsHttpConnectionMgr
:
:
nsConnectionEntry
*
nsHttpConnectionMgr
:
:
GetSpdyPreferredEnt
(
nsConnectionEntry
*
aOriginalEntry
)
{
if
(
!
gHttpHandler
-
>
IsSpdyEnabled
(
)
|
|
!
gHttpHandler
-
>
CoalesceSpdy
(
)
|
|
aOriginalEntry
-
>
mConnInfo
-
>
GetNoSpdy
(
)
|
|
aOriginalEntry
-
>
mCoalescingKeys
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsConnectionEntry
*
preferred
=
LookupPreferredHash
(
aOriginalEntry
)
;
if
(
preferred
=
=
aOriginalEntry
)
return
aOriginalEntry
;
if
(
!
preferred
|
|
!
preferred
-
>
mUsingSpdy
)
return
nullptr
;
nsHttpConnection
*
activeSpdy
=
nullptr
;
for
(
uint32_t
index
=
0
;
index
<
preferred
-
>
mActiveConns
.
Length
(
)
;
+
+
index
)
{
if
(
preferred
-
>
mActiveConns
[
index
]
-
>
CanDirectlyActivate
(
)
)
{
activeSpdy
=
preferred
-
>
mActiveConns
[
index
]
;
break
;
}
}
if
(
!
activeSpdy
)
{
RemovePreferredHash
(
preferred
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
GetSpdyPreferredEnt
"
"
preferred
host
mapping
%
s
to
%
s
removed
due
to
inactivity
.
\
n
"
aOriginalEntry
-
>
mConnInfo
-
>
Origin
(
)
preferred
-
>
mConnInfo
-
>
Origin
(
)
)
)
;
return
nullptr
;
}
nsresult
rv
;
bool
isJoined
=
false
;
nsCOMPtr
<
nsISupports
>
securityInfo
;
nsCOMPtr
<
nsISSLSocketControl
>
sslSocketControl
;
nsAutoCString
negotiatedNPN
;
activeSpdy
-
>
GetSecurityInfo
(
getter_AddRefs
(
securityInfo
)
)
;
if
(
!
securityInfo
)
{
NS_WARNING
(
"
cannot
obtain
spdy
security
info
"
)
;
return
nullptr
;
}
sslSocketControl
=
do_QueryInterface
(
securityInfo
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
sslSocketControl
QI
Failed
"
)
;
return
nullptr
;
}
const
SpdyInformation
*
info
=
gHttpHandler
-
>
SpdyInfo
(
)
;
for
(
uint32_t
index
=
SpdyInformation
:
:
kCount
;
NS_SUCCEEDED
(
rv
)
&
&
index
>
0
;
-
-
index
)
{
if
(
info
-
>
ProtocolEnabled
(
index
-
1
)
)
{
rv
=
sslSocketControl
-
>
JoinConnection
(
info
-
>
VersionString
[
index
-
1
]
aOriginalEntry
-
>
mConnInfo
-
>
GetOrigin
(
)
aOriginalEntry
-
>
mConnInfo
-
>
OriginPort
(
)
&
isJoined
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isJoined
)
{
break
;
}
}
}
if
(
NS_FAILED
(
rv
)
|
|
!
isJoined
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
GetSpdyPreferredEnt
"
"
Host
%
s
cannot
be
confirmed
to
be
joined
"
"
with
%
s
connections
.
rv
=
%
"
PRIx32
"
isJoined
=
%
d
"
preferred
-
>
mConnInfo
-
>
Origin
(
)
aOriginalEntry
-
>
mConnInfo
-
>
Origin
(
)
static_cast
<
uint32_t
>
(
rv
)
isJoined
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_NPN_JOIN
false
)
;
return
nullptr
;
}
LOG
(
(
"
nsHttpConnectionMgr
:
:
GetSpdyPreferredEnt
"
"
Host
%
s
has
cert
valid
for
%
s
connections
"
"
so
%
s
will
be
coalesced
with
%
s
"
preferred
-
>
mConnInfo
-
>
Origin
(
)
aOriginalEntry
-
>
mConnInfo
-
>
Origin
(
)
aOriginalEntry
-
>
mConnInfo
-
>
Origin
(
)
preferred
-
>
mConnInfo
-
>
Origin
(
)
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_NPN_JOIN
true
)
;
return
preferred
;
}
bool
nsHttpConnectionMgr
:
:
ProcessPendingQForEntry
(
nsConnectionEntry
*
ent
bool
considerAll
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
ProcessPendingQForEntry
"
"
[
ci
=
%
s
ent
=
%
p
active
=
%
"
PRIuSIZE
"
idle
=
%
"
PRIuSIZE
"
queued
=
%
"
PRIuSIZE
"
]
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
ent
ent
-
>
mActiveConns
.
Length
(
)
ent
-
>
mIdleConns
.
Length
(
)
ent
-
>
mPendingQ
.
Length
(
)
)
)
;
ProcessSpdyPendingQ
(
ent
)
;
nsHttpTransaction
*
trans
;
nsresult
rv
;
bool
dispatchedSuccessfully
=
false
;
for
(
uint32_t
i
=
0
;
i
<
ent
-
>
mPendingQ
.
Length
(
)
;
)
{
trans
=
ent
-
>
mPendingQ
[
i
]
;
bool
alreadyHalfOpen
=
false
;
for
(
int32_t
j
=
0
;
j
<
(
(
int32_t
)
ent
-
>
mHalfOpens
.
Length
(
)
)
;
+
+
j
)
{
if
(
ent
-
>
mHalfOpens
[
j
]
-
>
Transaction
(
)
=
=
trans
)
{
alreadyHalfOpen
=
true
;
break
;
}
}
rv
=
TryDispatchTransaction
(
ent
alreadyHalfOpen
|
|
!
!
trans
-
>
TunnelProvider
(
)
trans
)
;
if
(
NS_SUCCEEDED
(
rv
)
|
|
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
LOG
(
(
"
dispatching
pending
transaction
.
.
.
\
n
"
)
)
;
else
LOG
(
(
"
removing
pending
transaction
based
on
"
"
TryDispatchTransaction
returning
hard
error
%
"
PRIx32
"
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
ent
-
>
mPendingQ
.
RemoveElement
(
trans
)
)
{
dispatchedSuccessfully
=
true
;
continue
;
}
LOG
(
(
"
transaction
not
found
in
pending
queue
\
n
"
)
)
;
}
if
(
dispatchedSuccessfully
&
&
!
considerAll
)
break
;
+
+
i
;
}
return
dispatchedSuccessfully
;
}
bool
nsHttpConnectionMgr
:
:
ProcessPendingQForEntry
(
nsHttpConnectionInfo
*
ci
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
nsConnectionEntry
*
ent
=
mCT
.
Get
(
ci
-
>
HashKey
(
)
)
;
if
(
ent
)
return
ProcessPendingQForEntry
(
ent
false
)
;
return
false
;
}
bool
nsHttpConnectionMgr
:
:
AtActiveConnectionLimit
(
nsConnectionEntry
*
ent
uint32_t
caps
)
{
nsHttpConnectionInfo
*
ci
=
ent
-
>
mConnInfo
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
AtActiveConnectionLimit
[
ci
=
%
s
caps
=
%
x
]
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
caps
)
)
;
uint32_t
maxSocketCount
=
gHttpHandler
-
>
MaxSocketCount
(
)
;
if
(
mMaxConns
>
maxSocketCount
)
{
mMaxConns
=
maxSocketCount
;
LOG
(
(
"
nsHttpConnectionMgr
%
p
mMaxConns
dynamically
reduced
to
%
u
"
this
mMaxConns
)
)
;
}
if
(
mNumActiveConns
>
=
mMaxConns
)
{
LOG
(
(
"
num
active
conns
=
=
max
conns
\
n
"
)
)
;
return
true
;
}
uint32_t
totalCount
=
ent
-
>
mActiveConns
.
Length
(
)
+
ent
-
>
UnconnectedHalfOpens
(
)
;
uint16_t
maxPersistConns
;
if
(
ci
-
>
UsingHttpProxy
(
)
&
&
!
ci
-
>
UsingConnect
(
)
)
maxPersistConns
=
mMaxPersistConnsPerProxy
;
else
maxPersistConns
=
mMaxPersistConnsPerHost
;
LOG
(
(
"
connection
count
=
%
d
limit
%
d
\
n
"
totalCount
maxPersistConns
)
)
;
bool
result
=
(
totalCount
>
=
maxPersistConns
)
;
LOG
(
(
"
result
:
%
s
"
result
?
"
true
"
:
"
false
"
)
)
;
return
result
;
}
void
nsHttpConnectionMgr
:
:
ClosePersistentConnections
(
nsConnectionEntry
*
ent
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ClosePersistentConnections
[
ci
=
%
s
]
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
while
(
ent
-
>
mIdleConns
.
Length
(
)
)
{
RefPtr
<
nsHttpConnection
>
conn
(
ent
-
>
mIdleConns
[
0
]
)
;
ent
-
>
mIdleConns
.
RemoveElementAt
(
0
)
;
mNumIdleConns
-
-
;
conn
-
>
Close
(
NS_ERROR_ABORT
)
;
}
int32_t
activeCount
=
ent
-
>
mActiveConns
.
Length
(
)
;
for
(
int32_t
i
=
0
;
i
<
activeCount
;
i
+
+
)
ent
-
>
mActiveConns
[
i
]
-
>
DontReuse
(
)
;
}
bool
nsHttpConnectionMgr
:
:
RestrictConnections
(
nsConnectionEntry
*
ent
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
bool
doRestrict
=
ent
-
>
mConnInfo
-
>
FirstHopSSL
(
)
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
&
&
ent
-
>
mUsingSpdy
&
&
(
ent
-
>
mHalfOpens
.
Length
(
)
|
|
ent
-
>
mActiveConns
.
Length
(
)
)
;
if
(
!
doRestrict
)
return
false
;
if
(
ent
-
>
UnconnectedHalfOpens
(
)
)
{
return
true
;
}
if
(
ent
-
>
mUsingSpdy
&
&
ent
-
>
mActiveConns
.
Length
(
)
)
{
bool
confirmedRestrict
=
false
;
for
(
uint32_t
index
=
0
;
index
<
ent
-
>
mActiveConns
.
Length
(
)
;
+
+
index
)
{
nsHttpConnection
*
conn
=
ent
-
>
mActiveConns
[
index
]
;
if
(
!
conn
-
>
ReportedNPN
(
)
|
|
conn
-
>
CanDirectlyActivate
(
)
)
{
confirmedRestrict
=
true
;
break
;
}
}
doRestrict
=
confirmedRestrict
;
if
(
!
confirmedRestrict
)
{
LOG
(
(
"
nsHttpConnectionMgr
spdy
connection
restriction
to
"
"
%
s
bypassed
.
\
n
"
ent
-
>
mConnInfo
-
>
Origin
(
)
)
)
;
}
}
return
doRestrict
;
}
nsresult
nsHttpConnectionMgr
:
:
MakeNewConnection
(
nsConnectionEntry
*
ent
nsHttpTransaction
*
trans
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeNewConnection
%
p
ent
=
%
p
trans
=
%
p
"
this
ent
trans
)
)
;
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
uint32_t
halfOpenLength
=
ent
-
>
mHalfOpens
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
halfOpenLength
;
i
+
+
)
{
if
(
ent
-
>
mHalfOpens
[
i
]
-
>
IsSpeculative
(
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeNewConnection
[
ci
=
%
s
]
\
n
"
"
Found
a
speculative
half
open
connection
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
uint32_t
flags
;
ent
-
>
mHalfOpens
[
i
]
-
>
SetSpeculative
(
false
)
;
nsISocketTransport
*
transport
=
ent
-
>
mHalfOpens
[
i
]
-
>
SocketTransport
(
)
;
if
(
transport
&
&
NS_SUCCEEDED
(
transport
-
>
GetConnectionFlags
(
&
flags
)
)
)
{
flags
&
=
~
nsISocketTransport
:
:
DISABLE_RFC1918
;
transport
-
>
SetConnectionFlags
(
flags
)
;
}
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
HTTPCONNMGR_USED_SPECULATIVE_CONN
>
usedSpeculativeConn
;
+
+
usedSpeculativeConn
;
if
(
ent
-
>
mHalfOpens
[
i
]
-
>
IsFromPredictor
(
)
)
{
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
PREDICTOR_TOTAL_PRECONNECTS_USED
>
totalPreconnectsUsed
;
+
+
totalPreconnectsUsed
;
}
return
NS_OK
;
}
}
if
(
trans
-
>
Caps
(
)
&
NS_HTTP_ALLOW_KEEPALIVE
)
{
uint32_t
activeLength
=
ent
-
>
mActiveConns
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
activeLength
;
i
+
+
)
{
nsAHttpTransaction
*
activeTrans
=
ent
-
>
mActiveConns
[
i
]
-
>
Transaction
(
)
;
NullHttpTransaction
*
nullTrans
=
activeTrans
?
activeTrans
-
>
QueryNullTransaction
(
)
:
nullptr
;
if
(
nullTrans
&
&
nullTrans
-
>
Claim
(
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeNewConnection
[
ci
=
%
s
]
"
"
Claiming
a
null
transaction
for
later
use
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
return
NS_OK
;
}
}
}
if
(
!
(
trans
-
>
Caps
(
)
&
NS_HTTP_DISALLOW_SPDY
)
&
&
(
trans
-
>
Caps
(
)
&
NS_HTTP_ALLOW_KEEPALIVE
)
&
&
RestrictConnections
(
ent
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeNewConnection
[
ci
=
%
s
]
"
"
Not
Available
Due
to
RestrictConnections
(
)
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
(
mNumIdleConns
+
mNumActiveConns
+
1
>
=
mMaxConns
)
&
&
mNumIdleConns
)
{
auto
iter
=
mCT
.
Iter
(
)
;
while
(
mNumIdleConns
+
mNumActiveConns
+
1
>
=
mMaxConns
&
&
!
iter
.
Done
(
)
)
{
nsAutoPtr
<
nsConnectionEntry
>
&
entry
=
iter
.
Data
(
)
;
if
(
!
entry
-
>
mIdleConns
.
Length
(
)
)
{
iter
.
Next
(
)
;
continue
;
}
RefPtr
<
nsHttpConnection
>
conn
(
entry
-
>
mIdleConns
[
0
]
)
;
entry
-
>
mIdleConns
.
RemoveElementAt
(
0
)
;
conn
-
>
Close
(
NS_ERROR_ABORT
)
;
mNumIdleConns
-
-
;
ConditionallyStopPruneDeadConnectionsTimer
(
)
;
}
}
if
(
(
mNumIdleConns
+
mNumActiveConns
+
1
>
=
mMaxConns
)
&
&
mNumActiveConns
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
)
{
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
nsConnectionEntry
>
&
entry
=
iter
.
Data
(
)
;
if
(
!
entry
-
>
mUsingSpdy
)
{
continue
;
}
for
(
uint32_t
index
=
0
;
index
<
entry
-
>
mActiveConns
.
Length
(
)
;
+
+
index
)
{
nsHttpConnection
*
conn
=
entry
-
>
mActiveConns
[
index
]
;
if
(
conn
-
>
UsingSpdy
(
)
&
&
conn
-
>
CanReuse
(
)
)
{
conn
-
>
DontReuse
(
)
;
if
(
mNumIdleConns
+
mNumActiveConns
+
1
<
=
mMaxConns
)
{
goto
outerLoopEnd
;
}
}
}
}
outerLoopEnd
:
;
}
if
(
AtActiveConnectionLimit
(
ent
trans
-
>
Caps
(
)
)
)
return
NS_ERROR_NOT_AVAILABLE
;
nsresult
rv
=
CreateTransport
(
ent
trans
trans
-
>
Caps
(
)
false
false
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeNewConnection
[
ci
=
%
s
trans
=
%
p
]
"
"
CreateTransport
(
)
hard
failure
.
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
trans
)
)
;
trans
-
>
Close
(
rv
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
rv
=
NS_ERROR_FAILURE
;
return
rv
;
}
return
NS_OK
;
}
nsresult
nsHttpConnectionMgr
:
:
TryDispatchTransaction
(
nsConnectionEntry
*
ent
bool
onlyReusedConnection
nsHttpTransaction
*
trans
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
TryDispatchTransaction
without
conn
"
"
[
trans
=
%
p
ci
=
%
p
ci
=
%
s
caps
=
%
x
tunnelprovider
=
%
p
onlyreused
=
%
d
"
"
active
=
%
"
PRIuSIZE
"
idle
=
%
"
PRIuSIZE
"
]
\
n
"
trans
ent
-
>
mConnInfo
.
get
(
)
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
uint32_t
(
trans
-
>
Caps
(
)
)
trans
-
>
TunnelProvider
(
)
onlyReusedConnection
ent
-
>
mActiveConns
.
Length
(
)
ent
-
>
mIdleConns
.
Length
(
)
)
)
;
uint32_t
caps
=
trans
-
>
Caps
(
)
;
RefPtr
<
nsHttpConnection
>
unusedSpdyPersistentConnection
;
if
(
!
(
caps
&
NS_HTTP_DISALLOW_SPDY
)
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
)
{
RefPtr
<
nsHttpConnection
>
conn
=
GetSpdyPreferredConn
(
ent
)
;
if
(
conn
)
{
if
(
(
caps
&
NS_HTTP_ALLOW_KEEPALIVE
)
|
|
!
conn
-
>
IsExperienced
(
)
)
{
LOG
(
(
"
dispatch
to
spdy
:
[
conn
=
%
p
]
\
n
"
conn
.
get
(
)
)
)
;
trans
-
>
RemoveDispatchedAsBlocking
(
)
;
nsresult
rv
=
DispatchTransaction
(
ent
trans
conn
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
unusedSpdyPersistentConnection
=
conn
;
}
}
if
(
!
(
caps
&
NS_HTTP_LOAD_AS_BLOCKING
)
)
{
if
(
!
(
caps
&
NS_HTTP_LOAD_UNBLOCKED
)
)
{
nsIRequestContext
*
requestContext
=
trans
-
>
RequestContext
(
)
;
if
(
requestContext
)
{
uint32_t
blockers
=
0
;
if
(
NS_SUCCEEDED
(
requestContext
-
>
GetBlockingTransactionCount
(
&
blockers
)
)
&
&
blockers
)
{
LOG
(
(
"
blocked
by
request
context
:
[
rc
=
%
p
trans
=
%
p
blockers
=
%
d
]
\
n
"
requestContext
trans
blockers
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
}
}
}
else
{
trans
-
>
DispatchedAsBlocking
(
)
;
}
if
(
gHttpHandler
-
>
UseRequestTokenBucket
(
)
)
{
bool
runNow
=
trans
-
>
TryToRunPacedRequest
(
)
;
if
(
!
runNow
)
{
if
(
(
mNumActiveConns
-
mNumSpdyActiveConns
)
<
=
gHttpHandler
-
>
RequestTokenBucketMinParallelism
(
)
)
{
runNow
=
true
;
}
else
if
(
caps
&
(
NS_HTTP_LOAD_AS_BLOCKING
|
NS_HTTP_LOAD_UNBLOCKED
)
)
{
runNow
=
true
;
}
}
if
(
!
runNow
)
{
LOG
(
(
"
blocked
due
to
rate
pacing
trans
=
%
p
\
n
"
trans
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
}
if
(
caps
&
NS_HTTP_ALLOW_KEEPALIVE
)
{
RefPtr
<
nsHttpConnection
>
conn
;
while
(
!
conn
&
&
(
ent
-
>
mIdleConns
.
Length
(
)
>
0
)
)
{
conn
=
ent
-
>
mIdleConns
[
0
]
;
ent
-
>
mIdleConns
.
RemoveElementAt
(
0
)
;
mNumIdleConns
-
-
;
if
(
!
conn
-
>
CanReuse
(
)
)
{
LOG
(
(
"
dropping
stale
connection
:
[
conn
=
%
p
]
\
n
"
conn
.
get
(
)
)
)
;
conn
-
>
Close
(
NS_ERROR_ABORT
)
;
conn
=
nullptr
;
}
else
{
LOG
(
(
"
reusing
connection
[
conn
=
%
p
]
\
n
"
conn
.
get
(
)
)
)
;
conn
-
>
EndIdleMonitoring
(
)
;
}
ConditionallyStopPruneDeadConnectionsTimer
(
)
;
}
if
(
conn
)
{
AddActiveConn
(
conn
ent
)
;
nsresult
rv
=
DispatchTransaction
(
ent
trans
conn
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
dispatched
step
2
(
idle
)
trans
=
%
p
\
n
"
trans
)
)
;
return
NS_OK
;
}
}
if
(
!
onlyReusedConnection
)
{
nsresult
rv
=
MakeNewConnection
(
ent
trans
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
dispatched
step
4
(
async
new
conn
)
trans
=
%
p
\
n
"
trans
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
{
LOG
(
(
"
failed
step
4
(
%
"
PRIx32
"
)
trans
=
%
p
\
n
"
static_cast
<
uint32_t
>
(
rv
)
trans
)
)
;
return
rv
;
}
}
else
if
(
trans
-
>
TunnelProvider
(
)
&
&
trans
-
>
TunnelProvider
(
)
-
>
MaybeReTunnel
(
trans
)
)
{
LOG
(
(
"
sort
of
dispatched
step
4a
tunnel
requeue
trans
=
%
p
\
n
"
trans
)
)
;
return
NS_OK
;
}
if
(
unusedSpdyPersistentConnection
)
{
unusedSpdyPersistentConnection
-
>
DontReuse
(
)
;
}
LOG
(
(
"
not
dispatched
(
queued
)
trans
=
%
p
\
n
"
trans
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
nsHttpConnectionMgr
:
:
DispatchTransaction
(
nsConnectionEntry
*
ent
nsHttpTransaction
*
trans
nsHttpConnection
*
conn
)
{
uint32_t
caps
=
trans
-
>
Caps
(
)
;
int32_t
priority
=
trans
-
>
Priority
(
)
;
nsresult
rv
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
DispatchTransaction
"
"
[
ent
-
ci
=
%
s
%
p
trans
=
%
p
caps
=
%
x
conn
=
%
p
priority
=
%
d
]
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
ent
trans
caps
conn
priority
)
)
;
trans
-
>
CancelPacing
(
NS_OK
)
;
if
(
conn
-
>
UsingSpdy
(
)
)
{
LOG
(
(
"
Spdy
Dispatch
Transaction
via
Activate
(
)
.
Transaction
host
=
%
s
"
"
Connection
host
=
%
s
\
n
"
trans
-
>
ConnectionInfo
(
)
-
>
Origin
(
)
conn
-
>
ConnectionInfo
(
)
-
>
Origin
(
)
)
)
;
rv
=
conn
-
>
Activate
(
trans
caps
priority
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
SPDY
Cannot
Fail
Dispatch
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
trans
-
>
GetPendingTime
(
)
.
IsNull
(
)
)
{
AccumulateTimeDelta
(
Telemetry
:
:
TRANSACTION_WAIT_TIME_SPDY
trans
-
>
GetPendingTime
(
)
TimeStamp
:
:
Now
(
)
)
;
trans
-
>
SetPendingTime
(
false
)
;
}
return
rv
;
}
MOZ_ASSERT
(
conn
&
&
!
conn
-
>
Transaction
(
)
"
DispatchTranaction
(
)
on
non
spdy
active
connection
"
)
;
rv
=
DispatchAbstractTransaction
(
ent
trans
caps
conn
priority
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
trans
-
>
GetPendingTime
(
)
.
IsNull
(
)
)
{
AccumulateTimeDelta
(
Telemetry
:
:
TRANSACTION_WAIT_TIME_HTTP
trans
-
>
GetPendingTime
(
)
TimeStamp
:
:
Now
(
)
)
;
trans
-
>
SetPendingTime
(
false
)
;
}
return
rv
;
}
class
ConnectionHandle
:
public
nsAHttpConnection
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSAHTTPCONNECTION
(
mConn
)
explicit
ConnectionHandle
(
nsHttpConnection
*
conn
)
:
mConn
(
conn
)
{
}
void
Reset
(
)
{
mConn
=
nullptr
;
}
private
:
virtual
~
ConnectionHandle
(
)
;
RefPtr
<
nsHttpConnection
>
mConn
;
}
;
nsAHttpConnection
*
nsHttpConnectionMgr
:
:
MakeConnectionHandle
(
nsHttpConnection
*
aWrapped
)
{
return
new
ConnectionHandle
(
aWrapped
)
;
}
ConnectionHandle
:
:
~
ConnectionHandle
(
)
{
if
(
mConn
)
{
nsresult
rv
=
gHttpHandler
-
>
ReclaimConnection
(
mConn
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ConnectionHandle
:
:
~
ConnectionHandle
\
n
"
"
failed
to
reclaim
connection
\
n
"
)
)
;
}
}
}
NS_IMPL_ISUPPORTS0
(
ConnectionHandle
)
nsresult
nsHttpConnectionMgr
:
:
DispatchAbstractTransaction
(
nsConnectionEntry
*
ent
nsAHttpTransaction
*
aTrans
uint32_t
caps
nsHttpConnection
*
conn
int32_t
priority
)
{
nsresult
rv
;
MOZ_ASSERT
(
!
conn
-
>
UsingSpdy
(
)
"
Spdy
Must
Not
Use
DispatchAbstractTransaction
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
DispatchAbstractTransaction
"
"
[
ci
=
%
s
trans
=
%
p
caps
=
%
x
conn
=
%
p
]
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
aTrans
caps
conn
)
)
;
RefPtr
<
nsAHttpTransaction
>
transaction
(
aTrans
)
;
RefPtr
<
ConnectionHandle
>
handle
=
new
ConnectionHandle
(
conn
)
;
transaction
-
>
SetConnection
(
handle
)
;
rv
=
conn
-
>
Activate
(
transaction
caps
priority
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
conn
-
>
Activate
failed
[
rv
=
%
"
PRIx32
"
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
ent
-
>
mActiveConns
.
RemoveElement
(
conn
)
;
DecrementActiveConnCount
(
conn
)
;
ConditionallyStopTimeoutTick
(
)
;
transaction
-
>
SetConnection
(
nullptr
)
;
handle
-
>
Reset
(
)
;
}
return
rv
;
}
void
nsHttpConnectionMgr
:
:
ReportProxyTelemetry
(
nsConnectionEntry
*
ent
)
{
enum
{
PROXY_NONE
=
1
PROXY_HTTP
=
2
PROXY_SOCKS
=
3
PROXY_HTTPS
=
4
}
;
if
(
!
ent
-
>
mConnInfo
-
>
UsingProxy
(
)
)
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_PROXY_TYPE
PROXY_NONE
)
;
else
if
(
ent
-
>
mConnInfo
-
>
UsingHttpsProxy
(
)
)
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_PROXY_TYPE
PROXY_HTTPS
)
;
else
if
(
ent
-
>
mConnInfo
-
>
UsingHttpProxy
(
)
)
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_PROXY_TYPE
PROXY_HTTP
)
;
else
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_PROXY_TYPE
PROXY_SOCKS
)
;
}
nsresult
nsHttpConnectionMgr
:
:
ProcessNewTransaction
(
nsHttpTransaction
*
trans
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
if
(
NS_FAILED
(
trans
-
>
Status
(
)
)
)
{
LOG
(
(
"
transaction
was
canceled
.
.
.
dropping
event
!
\
n
"
)
)
;
return
NS_OK
;
}
trans
-
>
SetPendingTime
(
)
;
Http2PushedStream
*
pushedStream
=
trans
-
>
GetPushedStream
(
)
;
if
(
pushedStream
)
{
LOG
(
(
"
ProcessNewTransaction
%
p
tied
to
h2
session
push
%
p
\
n
"
trans
pushedStream
-
>
Session
(
)
)
)
;
return
pushedStream
-
>
Session
(
)
-
>
AddStream
(
trans
trans
-
>
Priority
(
)
false
nullptr
)
?
NS_OK
:
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
NS_OK
;
nsHttpConnectionInfo
*
ci
=
trans
-
>
ConnectionInfo
(
)
;
MOZ_ASSERT
(
ci
)
;
nsConnectionEntry
*
ent
=
GetOrCreateConnectionEntry
(
ci
!
!
trans
-
>
TunnelProvider
(
)
)
;
nsConnectionEntry
*
preferredEntry
=
GetSpdyPreferredEnt
(
ent
)
;
if
(
preferredEntry
&
&
(
preferredEntry
!
=
ent
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ProcessNewTransaction
trans
=
%
p
"
"
redirected
via
coalescing
from
%
s
to
%
s
\
n
"
trans
ent
-
>
mConnInfo
-
>
Origin
(
)
preferredEntry
-
>
mConnInfo
-
>
Origin
(
)
)
)
;
ent
=
preferredEntry
;
}
ReportProxyTelemetry
(
ent
)
;
nsAHttpConnection
*
wrappedConnection
=
trans
-
>
Connection
(
)
;
RefPtr
<
nsHttpConnection
>
conn
;
if
(
wrappedConnection
)
conn
=
wrappedConnection
-
>
TakeHttpConnection
(
)
;
if
(
conn
)
{
MOZ_ASSERT
(
trans
-
>
Caps
(
)
&
NS_HTTP_STICKY_CONNECTION
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
ProcessNewTransaction
trans
=
%
p
"
"
sticky
connection
=
%
p
\
n
"
trans
conn
.
get
(
)
)
)
;
if
(
static_cast
<
int32_t
>
(
ent
-
>
mActiveConns
.
IndexOf
(
conn
)
)
=
=
-
1
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
ProcessNewTransaction
trans
=
%
p
"
"
sticky
connection
=
%
p
needs
to
go
on
the
active
list
\
n
"
trans
conn
.
get
(
)
)
)
;
MOZ_ASSERT
(
static_cast
<
int32_t
>
(
ent
-
>
mIdleConns
.
IndexOf
(
conn
)
)
=
=
-
1
)
;
MOZ_ASSERT
(
!
conn
-
>
IsExperienced
(
)
)
;
AddActiveConn
(
conn
ent
)
;
}
trans
-
>
SetConnection
(
nullptr
)
;
rv
=
DispatchTransaction
(
ent
trans
conn
)
;
}
else
{
rv
=
TryDispatchTransaction
(
ent
!
!
trans
-
>
TunnelProvider
(
)
trans
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
ProcessNewTransaction
Dispatch
Immediately
trans
=
%
p
\
n
"
trans
)
)
;
return
rv
;
}
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
LOG
(
(
"
adding
transaction
to
pending
queue
"
"
[
trans
=
%
p
pending
-
count
=
%
"
PRIuSIZE
"
]
\
n
"
trans
ent
-
>
mPendingQ
.
Length
(
)
+
1
)
)
;
InsertTransactionSorted
(
ent
-
>
mPendingQ
trans
)
;
return
NS_OK
;
}
LOG
(
(
"
ProcessNewTransaction
Hard
Error
trans
=
%
p
rv
=
%
"
PRIx32
"
\
n
"
trans
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
rv
;
}
void
nsHttpConnectionMgr
:
:
AddActiveConn
(
nsHttpConnection
*
conn
nsConnectionEntry
*
ent
)
{
ent
-
>
mActiveConns
.
AppendElement
(
conn
)
;
mNumActiveConns
+
+
;
ActivateTimeoutTick
(
)
;
}
void
nsHttpConnectionMgr
:
:
DecrementActiveConnCount
(
nsHttpConnection
*
conn
)
{
mNumActiveConns
-
-
;
if
(
conn
-
>
EverUsedSpdy
(
)
)
mNumSpdyActiveConns
-
-
;
}
void
nsHttpConnectionMgr
:
:
StartedConnect
(
)
{
mNumActiveConns
+
+
;
ActivateTimeoutTick
(
)
;
}
void
nsHttpConnectionMgr
:
:
RecvdConnect
(
)
{
mNumActiveConns
-
-
;
ConditionallyStopTimeoutTick
(
)
;
}
nsresult
nsHttpConnectionMgr
:
:
CreateTransport
(
nsConnectionEntry
*
ent
nsAHttpTransaction
*
trans
uint32_t
caps
bool
speculative
bool
isFromPredictor
bool
allow1918
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
RefPtr
<
nsHalfOpenSocket
>
sock
=
new
nsHalfOpenSocket
(
ent
trans
caps
)
;
if
(
speculative
)
{
sock
-
>
SetSpeculative
(
true
)
;
sock
-
>
SetAllow1918
(
allow1918
)
;
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
HTTPCONNMGR_TOTAL_SPECULATIVE_CONN
>
totalSpeculativeConn
;
+
+
totalSpeculativeConn
;
if
(
isFromPredictor
)
{
sock
-
>
SetIsFromPredictor
(
true
)
;
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
PREDICTOR_TOTAL_PRECONNECTS_CREATED
>
totalPreconnectsCreated
;
+
+
totalPreconnectsCreated
;
}
}
nsresult
rv
=
sock
-
>
SetupPrimaryStreams
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ent
-
>
mHalfOpens
.
AppendElement
(
sock
)
;
mNumHalfOpenConns
+
+
;
return
NS_OK
;
}
void
nsHttpConnectionMgr
:
:
ProcessSpdyPendingQ
(
nsConnectionEntry
*
ent
)
{
nsHttpConnection
*
conn
=
GetSpdyPreferredConn
(
ent
)
;
if
(
!
conn
|
|
!
conn
-
>
CanDirectlyActivate
(
)
)
return
;
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
leftovers
;
uint32_t
index
;
for
(
index
=
0
;
index
<
ent
-
>
mPendingQ
.
Length
(
)
&
&
conn
-
>
CanDirectlyActivate
(
)
;
+
+
index
)
{
nsHttpTransaction
*
trans
=
ent
-
>
mPendingQ
[
index
]
;
if
(
!
(
trans
-
>
Caps
(
)
&
NS_HTTP_ALLOW_KEEPALIVE
)
|
|
trans
-
>
Caps
(
)
&
NS_HTTP_DISALLOW_SPDY
)
{
leftovers
.
AppendElement
(
trans
)
;
continue
;
}
nsresult
rv
=
DispatchTransaction
(
ent
trans
conn
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
false
"
Dispatch
SPDY
Transaction
"
)
;
LOG
(
(
"
ProcessSpdyPendingQ
Dispatch
Transaction
failed
trans
=
%
p
\
n
"
trans
)
)
;
trans
-
>
Close
(
rv
)
;
}
}
for
(
;
index
<
ent
-
>
mPendingQ
.
Length
(
)
;
+
+
index
)
{
nsHttpTransaction
*
trans
=
ent
-
>
mPendingQ
[
index
]
;
leftovers
.
AppendElement
(
trans
)
;
}
leftovers
.
SwapElements
(
ent
-
>
mPendingQ
)
;
leftovers
.
Clear
(
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgProcessAllSpdyPendingQ
(
int32_t
ARefBase
*
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgProcessAllSpdyPendingQ
\
n
"
)
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ProcessSpdyPendingQ
(
iter
.
Data
(
)
)
;
}
}
nsHttpConnection
*
nsHttpConnectionMgr
:
:
GetSpdyPreferredConn
(
nsConnectionEntry
*
ent
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
MOZ_ASSERT
(
ent
)
;
nsConnectionEntry
*
preferred
=
GetSpdyPreferredEnt
(
ent
)
;
if
(
preferred
)
{
ent
-
>
mUsingSpdy
=
true
;
}
else
{
preferred
=
ent
;
}
if
(
!
preferred
-
>
mUsingSpdy
)
{
return
nullptr
;
}
nsHttpConnection
*
rv
=
nullptr
;
uint32_t
activeLen
=
preferred
-
>
mActiveConns
.
Length
(
)
;
uint32_t
index
;
for
(
index
=
0
;
index
<
activeLen
;
+
+
index
)
{
nsHttpConnection
*
tmp
=
preferred
-
>
mActiveConns
[
index
]
;
if
(
tmp
-
>
CanDirectlyActivate
(
)
&
&
tmp
-
>
IsExperienced
(
)
)
{
rv
=
tmp
;
break
;
}
}
if
(
rv
)
{
for
(
index
=
0
;
index
<
activeLen
;
+
+
index
)
{
nsHttpConnection
*
tmp
=
preferred
-
>
mActiveConns
[
index
]
;
if
(
tmp
!
=
rv
)
{
tmp
-
>
DontReuse
(
)
;
}
}
return
rv
;
}
for
(
index
=
0
;
index
<
activeLen
;
+
+
index
)
{
nsHttpConnection
*
tmp
=
preferred
-
>
mActiveConns
[
index
]
;
if
(
tmp
-
>
CanDirectlyActivate
(
)
)
{
rv
=
tmp
;
break
;
}
}
return
rv
;
}
void
nsHttpConnectionMgr
:
:
OnMsgShutdown
(
int32_t
ARefBase
*
param
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgShutdown
\
n
"
)
)
;
gHttpHandler
-
>
StopRequestTokenBucket
(
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
nsConnectionEntry
>
&
ent
=
iter
.
Data
(
)
;
while
(
ent
-
>
mActiveConns
.
Length
(
)
)
{
RefPtr
<
nsHttpConnection
>
conn
(
ent
-
>
mActiveConns
[
0
]
)
;
ent
-
>
mActiveConns
.
RemoveElementAt
(
0
)
;
DecrementActiveConnCount
(
conn
)
;
conn
-
>
CloseTransaction
(
conn
-
>
Transaction
(
)
NS_ERROR_ABORT
true
)
;
}
while
(
ent
-
>
mIdleConns
.
Length
(
)
)
{
RefPtr
<
nsHttpConnection
>
conn
(
ent
-
>
mIdleConns
[
0
]
)
;
ent
-
>
mIdleConns
.
RemoveElementAt
(
0
)
;
mNumIdleConns
-
-
;
conn
-
>
Close
(
NS_ERROR_ABORT
)
;
}
ConditionallyStopPruneDeadConnectionsTimer
(
)
;
while
(
ent
-
>
mPendingQ
.
Length
(
)
)
{
nsHttpTransaction
*
trans
=
ent
-
>
mPendingQ
[
0
]
;
trans
-
>
Close
(
NS_ERROR_ABORT
)
;
ent
-
>
mPendingQ
.
RemoveElementAt
(
0
)
;
}
for
(
int32_t
i
=
int32_t
(
ent
-
>
mHalfOpens
.
Length
(
)
)
-
1
;
i
>
=
0
;
i
-
-
)
{
ent
-
>
mHalfOpens
[
i
]
-
>
Abandon
(
)
;
}
iter
.
Remove
(
)
;
}
if
(
mTimeoutTick
)
{
mTimeoutTick
-
>
Cancel
(
)
;
mTimeoutTick
=
nullptr
;
mTimeoutTickArmed
=
false
;
}
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
if
(
mTrafficTimer
)
{
mTrafficTimer
-
>
Cancel
(
)
;
mTrafficTimer
=
nullptr
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
ConnEvent
(
this
&
nsHttpConnectionMgr
:
:
OnMsgShutdownConfirm
0
param
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgShutdownConfirm
(
int32_t
priority
ARefBase
*
param
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgShutdownConfirm
\
n
"
)
)
;
BoolWrapper
*
shutdown
=
static_cast
<
BoolWrapper
*
>
(
param
)
;
shutdown
-
>
mBool
=
true
;
}
void
nsHttpConnectionMgr
:
:
OnMsgNewTransaction
(
int32_t
priority
ARefBase
*
param
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgNewTransaction
[
trans
=
%
p
]
\
n
"
param
)
)
;
nsHttpTransaction
*
trans
=
static_cast
<
nsHttpTransaction
*
>
(
param
)
;
trans
-
>
SetPriority
(
priority
)
;
nsresult
rv
=
ProcessNewTransaction
(
trans
)
;
if
(
NS_FAILED
(
rv
)
)
trans
-
>
Close
(
rv
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgReschedTransaction
(
int32_t
priority
ARefBase
*
param
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgReschedTransaction
[
trans
=
%
p
]
\
n
"
param
)
)
;
RefPtr
<
nsHttpTransaction
>
trans
=
static_cast
<
nsHttpTransaction
*
>
(
param
)
;
trans
-
>
SetPriority
(
priority
)
;
nsConnectionEntry
*
ent
=
LookupConnectionEntry
(
trans
-
>
ConnectionInfo
(
)
nullptr
trans
)
;
if
(
ent
)
{
int32_t
index
=
ent
-
>
mPendingQ
.
IndexOf
(
trans
)
;
if
(
index
>
=
0
)
{
ent
-
>
mPendingQ
.
RemoveElementAt
(
index
)
;
InsertTransactionSorted
(
ent
-
>
mPendingQ
trans
)
;
}
}
}
void
nsHttpConnectionMgr
:
:
OnMsgCancelTransaction
(
int32_t
reason
ARefBase
*
param
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCancelTransaction
[
trans
=
%
p
]
\
n
"
param
)
)
;
nsresult
closeCode
=
static_cast
<
nsresult
>
(
reason
)
;
nsHttpTransaction
*
trans
=
static_cast
<
nsHttpTransaction
*
>
(
param
)
;
RefPtr
<
nsAHttpConnection
>
conn
(
trans
-
>
Connection
(
)
)
;
if
(
conn
&
&
!
trans
-
>
IsDone
(
)
)
{
conn
-
>
CloseTransaction
(
trans
closeCode
)
;
}
else
{
nsConnectionEntry
*
ent
=
LookupConnectionEntry
(
trans
-
>
ConnectionInfo
(
)
nullptr
trans
)
;
if
(
ent
)
{
int32_t
transIndex
=
ent
-
>
mPendingQ
.
IndexOf
(
trans
)
;
if
(
transIndex
>
=
0
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCancelTransaction
[
trans
=
%
p
]
"
"
found
in
pending
queue
\
n
"
trans
)
)
;
ent
-
>
mPendingQ
.
RemoveElementAt
(
transIndex
)
;
}
for
(
uint32_t
index
=
0
;
index
<
ent
-
>
mHalfOpens
.
Length
(
)
;
+
+
index
)
{
nsHalfOpenSocket
*
half
=
ent
-
>
mHalfOpens
[
index
]
;
if
(
trans
=
=
half
-
>
Transaction
(
)
)
{
half
-
>
Abandon
(
)
;
break
;
}
}
}
trans
-
>
Close
(
closeCode
)
;
for
(
uint32_t
index
=
0
;
ent
&
&
(
index
<
ent
-
>
mActiveConns
.
Length
(
)
)
;
+
+
index
)
{
nsHttpConnection
*
activeConn
=
ent
-
>
mActiveConns
[
index
]
;
nsAHttpTransaction
*
liveTransaction
=
activeConn
-
>
Transaction
(
)
;
if
(
liveTransaction
&
&
liveTransaction
-
>
IsNullTransaction
(
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCancelTransaction
[
trans
=
%
p
]
"
"
also
canceling
Null
Transaction
%
p
on
conn
%
p
\
n
"
trans
liveTransaction
activeConn
)
)
;
activeConn
-
>
CloseTransaction
(
liveTransaction
closeCode
)
;
}
}
}
}
void
nsHttpConnectionMgr
:
:
OnMsgProcessPendingQ
(
int32_t
ARefBase
*
param
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
nsHttpConnectionInfo
*
ci
=
static_cast
<
nsHttpConnectionInfo
*
>
(
param
)
;
if
(
!
ci
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgProcessPendingQ
[
ci
=
nullptr
]
\
n
"
)
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Unused
<
<
ProcessPendingQForEntry
(
iter
.
Data
(
)
true
)
;
}
return
;
}
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgProcessPendingQ
[
ci
=
%
s
]
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
nsConnectionEntry
*
ent
=
mCT
.
Get
(
ci
-
>
HashKey
(
)
)
;
if
(
!
(
ent
&
&
ProcessPendingQForEntry
(
ent
false
)
)
)
{
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
ProcessPendingQForEntry
(
iter
.
Data
(
)
false
)
)
{
break
;
}
}
}
}
nsresult
nsHttpConnectionMgr
:
:
CancelTransactions
(
nsHttpConnectionInfo
*
ci
nsresult
code
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
CancelTransactions
%
s
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
)
)
;
int32_t
intReason
=
static_cast
<
int32_t
>
(
code
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgCancelTransactions
intReason
ci
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgCancelTransactions
(
int32_t
code
ARefBase
*
param
)
{
nsresult
reason
=
static_cast
<
nsresult
>
(
code
)
;
nsHttpConnectionInfo
*
ci
=
static_cast
<
nsHttpConnectionInfo
*
>
(
param
)
;
nsConnectionEntry
*
ent
=
mCT
.
Get
(
ci
-
>
HashKey
(
)
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCancelTransactions
%
s
%
p
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
ent
)
)
;
if
(
!
ent
)
{
return
;
}
for
(
int32_t
i
=
ent
-
>
mPendingQ
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
nsHttpTransaction
*
trans
=
ent
-
>
mPendingQ
[
i
]
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCancelTransactions
%
s
%
p
%
p
\
n
"
ci
-
>
HashKey
(
)
.
get
(
)
ent
trans
)
)
;
trans
-
>
Close
(
reason
)
;
ent
-
>
mPendingQ
.
RemoveElementAt
(
i
)
;
}
}
void
nsHttpConnectionMgr
:
:
OnMsgPruneDeadConnections
(
int32_t
ARefBase
*
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgPruneDeadConnections
\
n
"
)
)
;
mTimeOfNextWakeUp
=
UINT64_MAX
;
if
(
mNumIdleConns
|
|
(
mNumActiveConns
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
)
)
{
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
nsConnectionEntry
>
&
ent
=
iter
.
Data
(
)
;
LOG
(
(
"
pruning
[
ci
=
%
s
]
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
uint32_t
timeToNextExpire
=
UINT32_MAX
;
int32_t
count
=
ent
-
>
mIdleConns
.
Length
(
)
;
if
(
count
>
0
)
{
for
(
int32_t
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
RefPtr
<
nsHttpConnection
>
conn
(
ent
-
>
mIdleConns
[
i
]
)
;
if
(
!
conn
-
>
CanReuse
(
)
)
{
ent
-
>
mIdleConns
.
RemoveElementAt
(
i
)
;
conn
-
>
Close
(
NS_ERROR_ABORT
)
;
mNumIdleConns
-
-
;
}
else
{
timeToNextExpire
=
std
:
:
min
(
timeToNextExpire
conn
-
>
TimeToLive
(
)
)
;
}
}
}
if
(
ent
-
>
mUsingSpdy
)
{
for
(
uint32_t
i
=
0
;
i
<
ent
-
>
mActiveConns
.
Length
(
)
;
+
+
i
)
{
nsHttpConnection
*
conn
=
ent
-
>
mActiveConns
[
i
]
;
if
(
conn
-
>
UsingSpdy
(
)
)
{
if
(
!
conn
-
>
CanReuse
(
)
)
{
conn
-
>
DontReuse
(
)
;
}
else
{
timeToNextExpire
=
std
:
:
min
(
timeToNextExpire
conn
-
>
TimeToLive
(
)
)
;
}
}
}
}
if
(
timeToNextExpire
!
=
UINT32_MAX
)
{
uint32_t
now
=
NowInSeconds
(
)
;
uint64_t
timeOfNextExpire
=
now
+
timeToNextExpire
;
if
(
!
mTimer
|
|
timeOfNextExpire
<
mTimeOfNextWakeUp
)
{
PruneDeadConnectionsAfter
(
timeToNextExpire
)
;
}
}
else
{
ConditionallyStopPruneDeadConnectionsTimer
(
)
;
}
if
(
mCT
.
Count
(
)
>
125
&
&
ent
-
>
mIdleConns
.
Length
(
)
=
=
0
&
&
ent
-
>
mActiveConns
.
Length
(
)
=
=
0
&
&
ent
-
>
mHalfOpens
.
Length
(
)
=
=
0
&
&
ent
-
>
mPendingQ
.
Length
(
)
=
=
0
&
&
(
!
ent
-
>
mUsingSpdy
|
|
mCT
.
Count
(
)
>
300
)
)
{
LOG
(
(
"
removing
empty
connection
entry
\
n
"
)
)
;
iter
.
Remove
(
)
;
continue
;
}
ent
-
>
mIdleConns
.
Compact
(
)
;
ent
-
>
mActiveConns
.
Compact
(
)
;
ent
-
>
mPendingQ
.
Compact
(
)
;
}
}
}
void
nsHttpConnectionMgr
:
:
OnMsgPruneNoTraffic
(
int32_t
ARefBase
*
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgPruneNoTraffic
\
n
"
)
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
nsConnectionEntry
>
&
ent
=
iter
.
Data
(
)
;
LOG
(
(
"
pruning
no
traffic
[
ci
=
%
s
]
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
uint32_t
numConns
=
ent
-
>
mActiveConns
.
Length
(
)
;
if
(
numConns
)
{
for
(
int
index
=
numConns
-
1
;
index
>
=
0
;
index
-
-
)
{
if
(
ent
-
>
mActiveConns
[
index
]
-
>
NoTraffic
(
)
)
{
RefPtr
<
nsHttpConnection
>
conn
=
ent
-
>
mActiveConns
[
index
]
;
ent
-
>
mActiveConns
.
RemoveElementAt
(
index
)
;
DecrementActiveConnCount
(
conn
)
;
conn
-
>
Close
(
NS_ERROR_ABORT
)
;
LOG
(
(
"
closed
active
connection
due
to
no
traffic
"
"
[
conn
=
%
p
]
\
n
"
conn
.
get
(
)
)
)
;
}
}
}
}
mPruningNoTraffic
=
false
;
}
void
nsHttpConnectionMgr
:
:
OnMsgVerifyTraffic
(
int32_t
ARefBase
*
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgVerifyTraffic
\
n
"
)
)
;
if
(
mPruningNoTraffic
)
{
return
;
}
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
nsConnectionEntry
>
&
ent
=
iter
.
Data
(
)
;
for
(
uint32_t
index
=
0
;
index
<
ent
-
>
mActiveConns
.
Length
(
)
;
+
+
index
)
{
ent
-
>
mActiveConns
[
index
]
-
>
CheckForTraffic
(
true
)
;
}
for
(
uint32_t
index
=
0
;
index
<
ent
-
>
mIdleConns
.
Length
(
)
;
+
+
index
)
{
ent
-
>
mIdleConns
[
index
]
-
>
CheckForTraffic
(
false
)
;
}
}
if
(
!
mTrafficTimer
)
{
mTrafficTimer
=
do_CreateInstance
(
"
mozilla
.
org
/
timer
;
1
"
)
;
}
if
(
mTrafficTimer
)
{
mTrafficTimer
-
>
Init
(
this
gHttpHandler
-
>
NetworkChangedTimeout
(
)
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
else
{
NS_WARNING
(
"
failed
to
create
timer
for
VerifyTraffic
!
"
)
;
}
}
void
nsHttpConnectionMgr
:
:
OnMsgDoShiftReloadConnectionCleanup
(
int32_t
ARefBase
*
param
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgDoShiftReloadConnectionCleanup
\
n
"
)
)
;
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
nsHttpConnectionInfo
*
ci
=
static_cast
<
nsHttpConnectionInfo
*
>
(
param
)
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ClosePersistentConnections
(
iter
.
Data
(
)
)
;
}
if
(
ci
)
ResetIPFamilyPreference
(
ci
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgReclaimConnection
(
int32_t
ARefBase
*
param
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgReclaimConnection
[
conn
=
%
p
]
\
n
"
param
)
)
;
nsHttpConnection
*
conn
=
static_cast
<
nsHttpConnection
*
>
(
param
)
;
nsConnectionEntry
*
ent
=
LookupConnectionEntry
(
conn
-
>
ConnectionInfo
(
)
conn
nullptr
)
;
if
(
!
ent
)
{
ent
=
GetOrCreateConnectionEntry
(
conn
-
>
ConnectionInfo
(
)
true
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgReclaimConnection
conn
%
p
"
"
forced
new
hash
entry
%
s
\
n
"
conn
conn
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
.
get
(
)
)
)
;
}
MOZ_ASSERT
(
ent
)
;
RefPtr
<
nsHttpConnectionInfo
>
ci
(
ent
-
>
mConnInfo
)
;
if
(
conn
-
>
EverUsedSpdy
(
)
)
{
conn
-
>
DontReuse
(
)
;
}
if
(
conn
-
>
Transaction
(
)
)
{
conn
-
>
DontReuse
(
)
;
}
if
(
ent
-
>
mActiveConns
.
RemoveElement
(
conn
)
)
{
DecrementActiveConnCount
(
conn
)
;
ConditionallyStopTimeoutTick
(
)
;
}
if
(
conn
-
>
CanReuse
(
)
)
{
LOG
(
(
"
adding
connection
to
idle
list
\
n
"
)
)
;
uint32_t
idx
;
for
(
idx
=
0
;
idx
<
ent
-
>
mIdleConns
.
Length
(
)
;
idx
+
+
)
{
nsHttpConnection
*
idleConn
=
ent
-
>
mIdleConns
[
idx
]
;
if
(
idleConn
-
>
MaxBytesRead
(
)
<
conn
-
>
MaxBytesRead
(
)
)
break
;
}
ent
-
>
mIdleConns
.
InsertElementAt
(
idx
conn
)
;
mNumIdleConns
+
+
;
conn
-
>
BeginIdleMonitoring
(
)
;
uint32_t
timeToLive
=
conn
-
>
TimeToLive
(
)
;
if
(
!
mTimer
|
|
NowInSeconds
(
)
+
timeToLive
<
mTimeOfNextWakeUp
)
PruneDeadConnectionsAfter
(
timeToLive
)
;
}
else
{
LOG
(
(
"
connection
cannot
be
reused
;
closing
connection
\
n
"
)
)
;
conn
-
>
Close
(
NS_ERROR_ABORT
)
;
}
OnMsgProcessPendingQ
(
0
ci
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgCompleteUpgrade
(
int32_t
ARefBase
*
param
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
nsCompleteUpgradeData
*
data
=
static_cast
<
nsCompleteUpgradeData
*
>
(
param
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCompleteUpgrade
"
"
this
=
%
p
conn
=
%
p
listener
=
%
p
\
n
"
this
data
-
>
mConn
.
get
(
)
data
-
>
mUpgradeListener
.
get
(
)
)
)
;
nsCOMPtr
<
nsISocketTransport
>
socketTransport
;
nsCOMPtr
<
nsIAsyncInputStream
>
socketIn
;
nsCOMPtr
<
nsIAsyncOutputStream
>
socketOut
;
nsresult
rv
;
rv
=
data
-
>
mConn
-
>
TakeTransport
(
getter_AddRefs
(
socketTransport
)
getter_AddRefs
(
socketIn
)
getter_AddRefs
(
socketOut
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
data
-
>
mUpgradeListener
-
>
OnTransportAvailable
(
socketTransport
socketIn
socketOut
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgCompleteUpgrade
"
"
this
=
%
p
conn
=
%
p
listener
=
%
p
\
n
"
this
data
-
>
mConn
.
get
(
)
data
-
>
mUpgradeListener
.
get
(
)
)
)
;
}
}
}
void
nsHttpConnectionMgr
:
:
OnMsgUpdateParam
(
int32_t
inParam
ARefBase
*
)
{
uint32_t
param
=
static_cast
<
uint32_t
>
(
inParam
)
;
uint16_t
name
=
(
(
param
)
&
0xFFFF0000
)
>
>
16
;
uint16_t
value
=
param
&
0x0000FFFF
;
switch
(
name
)
{
case
MAX_CONNECTIONS
:
mMaxConns
=
value
;
break
;
case
MAX_PERSISTENT_CONNECTIONS_PER_HOST
:
mMaxPersistConnsPerHost
=
value
;
break
;
case
MAX_PERSISTENT_CONNECTIONS_PER_PROXY
:
mMaxPersistConnsPerProxy
=
value
;
break
;
case
MAX_REQUEST_DELAY
:
mMaxRequestDelay
=
value
;
break
;
default
:
NS_NOTREACHED
(
"
unexpected
parameter
name
"
)
;
}
}
nsHttpConnectionMgr
:
:
nsConnectionEntry
:
:
~
nsConnectionEntry
(
)
{
MOZ_COUNT_DTOR
(
nsConnectionEntry
)
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
RemovePreferredHash
(
this
)
;
}
void
nsHttpConnectionMgr
:
:
ActivateTimeoutTick
(
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
ActivateTimeoutTick
(
)
"
"
this
=
%
p
mTimeoutTick
=
%
p
\
n
"
this
mTimeoutTick
.
get
(
)
)
)
;
if
(
mTimeoutTick
&
&
mTimeoutTickArmed
)
{
if
(
mTimeoutTickNext
>
1
)
{
mTimeoutTickNext
=
1
;
mTimeoutTick
-
>
SetDelay
(
1000
)
;
}
return
;
}
if
(
!
mTimeoutTick
)
{
mTimeoutTick
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
;
if
(
!
mTimeoutTick
)
{
NS_WARNING
(
"
failed
to
create
timer
for
http
timeout
management
"
)
;
return
;
}
mTimeoutTick
-
>
SetTarget
(
mSocketThreadTarget
)
;
}
MOZ_ASSERT
(
!
mTimeoutTickArmed
"
timer
tick
armed
"
)
;
mTimeoutTickArmed
=
true
;
mTimeoutTick
-
>
Init
(
this
1000
nsITimer
:
:
TYPE_REPEATING_SLACK
)
;
}
class
UINT64Wrapper
:
public
ARefBase
{
public
:
explicit
UINT64Wrapper
(
uint64_t
aUint64
)
:
mUint64
(
aUint64
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
UINT64Wrapper
)
uint64_t
GetValue
(
)
{
return
mUint64
;
}
private
:
uint64_t
mUint64
;
virtual
~
UINT64Wrapper
(
)
=
default
;
}
;
nsresult
nsHttpConnectionMgr
:
:
UpdateCurrentTopLevelOuterContentWindowId
(
uint64_t
aWindowId
)
{
RefPtr
<
UINT64Wrapper
>
windowIdWrapper
=
new
UINT64Wrapper
(
aWindowId
)
;
return
PostEvent
(
&
nsHttpConnectionMgr
:
:
OnMsgUpdateCurrentTopLevelOuterContentWindowId
0
windowIdWrapper
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgUpdateCurrentTopLevelOuterContentWindowId
(
int32_t
ARefBase
*
param
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
mCurrentTopLevelOuterContentWindowId
=
static_cast
<
UINT64Wrapper
*
>
(
param
)
-
>
GetValue
(
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgUpdateCurrentTopLevelOuterContentWindowId
"
"
id
=
%
"
PRIu64
"
\
n
"
mCurrentTopLevelOuterContentWindowId
)
)
;
}
void
nsHttpConnectionMgr
:
:
TimeoutTick
(
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
MOZ_ASSERT
(
mTimeoutTick
"
no
readtimeout
tick
"
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
TimeoutTick
active
=
%
d
\
n
"
mNumActiveConns
)
)
;
mTimeoutTickNext
=
3600
;
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
nsConnectionEntry
>
&
ent
=
iter
.
Data
(
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
TimeoutTick
(
)
this
=
%
p
host
=
%
s
"
"
idle
=
%
"
PRIuSIZE
"
active
=
%
"
PRIuSIZE
"
half
-
len
=
%
"
PRIuSIZE
"
pending
=
%
"
PRIuSIZE
"
\
n
"
this
ent
-
>
mConnInfo
-
>
Origin
(
)
ent
-
>
mIdleConns
.
Length
(
)
ent
-
>
mActiveConns
.
Length
(
)
ent
-
>
mHalfOpens
.
Length
(
)
ent
-
>
mPendingQ
.
Length
(
)
)
)
;
PRIntervalTime
tickTime
=
PR_IntervalNow
(
)
;
for
(
uint32_t
index
=
0
;
index
<
ent
-
>
mActiveConns
.
Length
(
)
;
+
+
index
)
{
uint32_t
connNextTimeout
=
ent
-
>
mActiveConns
[
index
]
-
>
ReadTimeoutTick
(
tickTime
)
;
mTimeoutTickNext
=
std
:
:
min
(
mTimeoutTickNext
connNextTimeout
)
;
}
if
(
ent
-
>
mHalfOpens
.
Length
(
)
)
{
TimeStamp
currentTime
=
TimeStamp
:
:
Now
(
)
;
double
maxConnectTime_ms
=
gHttpHandler
-
>
ConnectTimeout
(
)
;
for
(
uint32_t
index
=
ent
-
>
mHalfOpens
.
Length
(
)
;
index
>
0
;
)
{
index
-
-
;
nsHalfOpenSocket
*
half
=
ent
-
>
mHalfOpens
[
index
]
;
double
delta
=
half
-
>
Duration
(
currentTime
)
;
if
(
delta
>
maxConnectTime_ms
)
{
LOG
(
(
"
Force
timeout
of
half
open
to
%
s
after
%
.
2fms
.
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
delta
)
)
;
if
(
half
-
>
SocketTransport
(
)
)
{
half
-
>
SocketTransport
(
)
-
>
Close
(
NS_ERROR_ABORT
)
;
}
if
(
half
-
>
BackupTransport
(
)
)
{
half
-
>
BackupTransport
(
)
-
>
Close
(
NS_ERROR_ABORT
)
;
}
}
if
(
delta
>
maxConnectTime_ms
+
5000
)
{
LOG
(
(
"
Abandon
half
open
to
%
s
after
%
.
2fms
.
\
n
"
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
delta
)
)
;
half
-
>
Abandon
(
)
;
}
}
}
if
(
ent
-
>
mHalfOpens
.
Length
(
)
)
{
mTimeoutTickNext
=
1
;
}
}
if
(
mTimeoutTick
)
{
mTimeoutTickNext
=
std
:
:
max
(
mTimeoutTickNext
1U
)
;
mTimeoutTick
-
>
SetDelay
(
mTimeoutTickNext
*
1000
)
;
}
}
nsHttpConnectionMgr
:
:
nsConnectionEntry
*
nsHttpConnectionMgr
:
:
GetOrCreateConnectionEntry
(
nsHttpConnectionInfo
*
specificCI
bool
prohibitWildCard
)
{
nsConnectionEntry
*
specificEnt
=
mCT
.
Get
(
specificCI
-
>
HashKey
(
)
)
;
if
(
specificEnt
&
&
specificEnt
-
>
AvailableForDispatchNow
(
)
)
{
return
specificEnt
;
}
if
(
!
specificCI
-
>
UsingHttpsProxy
(
)
)
{
prohibitWildCard
=
true
;
}
if
(
!
prohibitWildCard
)
{
RefPtr
<
nsHttpConnectionInfo
>
wildCardProxyCI
;
DebugOnly
<
nsresult
>
rv
=
specificCI
-
>
CreateWildCard
(
getter_AddRefs
(
wildCardProxyCI
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsConnectionEntry
*
wildCardEnt
=
mCT
.
Get
(
wildCardProxyCI
-
>
HashKey
(
)
)
;
if
(
wildCardEnt
&
&
wildCardEnt
-
>
AvailableForDispatchNow
(
)
)
{
return
wildCardEnt
;
}
}
if
(
!
specificEnt
)
{
RefPtr
<
nsHttpConnectionInfo
>
clone
(
specificCI
-
>
Clone
(
)
)
;
specificEnt
=
new
nsConnectionEntry
(
clone
)
;
mCT
.
Put
(
clone
-
>
HashKey
(
)
specificEnt
)
;
}
return
specificEnt
;
}
nsresult
ConnectionHandle
:
:
OnHeadersAvailable
(
nsAHttpTransaction
*
trans
nsHttpRequestHead
*
req
nsHttpResponseHead
*
resp
bool
*
reset
)
{
return
mConn
-
>
OnHeadersAvailable
(
trans
req
resp
reset
)
;
}
void
ConnectionHandle
:
:
CloseTransaction
(
nsAHttpTransaction
*
trans
nsresult
reason
)
{
mConn
-
>
CloseTransaction
(
trans
reason
)
;
}
nsresult
ConnectionHandle
:
:
TakeTransport
(
nsISocketTransport
*
*
aTransport
nsIAsyncInputStream
*
*
aInputStream
nsIAsyncOutputStream
*
*
aOutputStream
)
{
return
mConn
-
>
TakeTransport
(
aTransport
aInputStream
aOutputStream
)
;
}
void
nsHttpConnectionMgr
:
:
OnMsgSpeculativeConnect
(
int32_t
ARefBase
*
param
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
SpeculativeConnectArgs
*
args
=
static_cast
<
SpeculativeConnectArgs
*
>
(
param
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
OnMsgSpeculativeConnect
[
ci
=
%
s
]
\
n
"
args
-
>
mTrans
-
>
ConnectionInfo
(
)
-
>
HashKey
(
)
.
get
(
)
)
)
;
nsConnectionEntry
*
ent
=
GetOrCreateConnectionEntry
(
args
-
>
mTrans
-
>
ConnectionInfo
(
)
false
)
;
nsConnectionEntry
*
preferredEntry
=
GetSpdyPreferredEnt
(
ent
)
;
if
(
preferredEntry
)
ent
=
preferredEntry
;
uint32_t
parallelSpeculativeConnectLimit
=
gHttpHandler
-
>
ParallelSpeculativeConnectLimit
(
)
;
bool
ignoreIdle
=
false
;
bool
isFromPredictor
=
false
;
bool
allow1918
=
false
;
if
(
args
-
>
mOverridesOK
)
{
parallelSpeculativeConnectLimit
=
args
-
>
mParallelSpeculativeConnectLimit
;
ignoreIdle
=
args
-
>
mIgnoreIdle
;
isFromPredictor
=
args
-
>
mIsFromPredictor
;
allow1918
=
args
-
>
mAllow1918
;
}
bool
keepAlive
=
args
-
>
mTrans
-
>
Caps
(
)
&
NS_HTTP_ALLOW_KEEPALIVE
;
if
(
mNumHalfOpenConns
<
parallelSpeculativeConnectLimit
&
&
(
(
ignoreIdle
&
&
(
ent
-
>
mIdleConns
.
Length
(
)
<
parallelSpeculativeConnectLimit
)
)
|
|
!
ent
-
>
mIdleConns
.
Length
(
)
)
&
&
!
(
keepAlive
&
&
RestrictConnections
(
ent
)
)
&
&
!
AtActiveConnectionLimit
(
ent
args
-
>
mTrans
-
>
Caps
(
)
)
)
{
DebugOnly
<
nsresult
>
rv
=
CreateTransport
(
ent
args
-
>
mTrans
args
-
>
mTrans
-
>
Caps
(
)
true
isFromPredictor
allow1918
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
else
{
LOG
(
(
"
OnMsgSpeculativeConnect
Transport
"
"
not
created
due
to
existing
connection
count
\
n
"
)
)
;
}
}
bool
ConnectionHandle
:
:
IsPersistent
(
)
{
return
mConn
-
>
IsPersistent
(
)
;
}
bool
ConnectionHandle
:
:
IsReused
(
)
{
return
mConn
-
>
IsReused
(
)
;
}
void
ConnectionHandle
:
:
DontReuse
(
)
{
mConn
-
>
DontReuse
(
)
;
}
nsresult
ConnectionHandle
:
:
PushBack
(
const
char
*
buf
uint32_t
bufLen
)
{
return
mConn
-
>
PushBack
(
buf
bufLen
)
;
}
NS_IMPL_ISUPPORTS
(
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
nsIOutputStreamCallback
nsITransportEventSink
nsIInterfaceRequestor
nsITimerCallback
)
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
nsHalfOpenSocket
(
nsConnectionEntry
*
ent
nsAHttpTransaction
*
trans
uint32_t
caps
)
:
mEnt
(
ent
)
mTransaction
(
trans
)
mDispatchedMTransaction
(
false
)
mCaps
(
caps
)
mSpeculative
(
false
)
mIsFromPredictor
(
false
)
mAllow1918
(
true
)
mHasConnected
(
false
)
mPrimaryConnectedOK
(
false
)
mBackupConnectedOK
(
false
)
{
MOZ_ASSERT
(
ent
&
&
trans
"
constructor
with
null
arguments
"
)
;
LOG
(
(
"
Creating
nsHalfOpenSocket
[
this
=
%
p
trans
=
%
p
ent
=
%
s
key
=
%
s
]
\
n
"
this
trans
ent
-
>
mConnInfo
-
>
Origin
(
)
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
}
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
~
nsHalfOpenSocket
(
)
{
MOZ_ASSERT
(
!
mStreamOut
)
;
MOZ_ASSERT
(
!
mBackupStreamOut
)
;
MOZ_ASSERT
(
!
mSynTimer
)
;
LOG
(
(
"
Destroying
nsHalfOpenSocket
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mEnt
)
mEnt
-
>
RemoveHalfOpen
(
this
)
;
}
nsresult
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
SetupStreams
(
nsISocketTransport
*
*
transport
nsIAsyncInputStream
*
*
instream
nsIAsyncOutputStream
*
*
outstream
bool
isBackup
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
nsresult
rv
;
const
char
*
socketTypes
[
1
]
;
uint32_t
typeCount
=
0
;
const
nsHttpConnectionInfo
*
ci
=
mEnt
-
>
mConnInfo
;
if
(
ci
-
>
FirstHopSSL
(
)
)
{
socketTypes
[
typeCount
+
+
]
=
"
ssl
"
;
}
else
{
socketTypes
[
typeCount
]
=
gHttpHandler
-
>
DefaultSocketType
(
)
;
if
(
socketTypes
[
typeCount
]
)
{
typeCount
+
+
;
}
}
nsCOMPtr
<
nsISocketTransport
>
socketTransport
;
nsCOMPtr
<
nsISocketTransportService
>
sts
;
sts
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
nsHalfOpenSocket
:
:
SetupStreams
[
this
=
%
p
ent
=
%
s
]
"
"
setup
routed
transport
to
origin
%
s
:
%
d
via
%
s
:
%
d
\
n
"
this
ci
-
>
HashKey
(
)
.
get
(
)
ci
-
>
Origin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
RoutedHost
(
)
ci
-
>
RoutedPort
(
)
)
)
;
nsCOMPtr
<
nsIRoutedSocketTransportService
>
routedSTS
(
do_QueryInterface
(
sts
)
)
;
if
(
routedSTS
)
{
rv
=
routedSTS
-
>
CreateRoutedTransport
(
socketTypes
typeCount
ci
-
>
GetOrigin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
GetRoutedHost
(
)
ci
-
>
RoutedPort
(
)
ci
-
>
ProxyInfo
(
)
getter_AddRefs
(
socketTransport
)
)
;
}
else
{
if
(
!
ci
-
>
GetRoutedHost
(
)
.
IsEmpty
(
)
)
{
LOG
(
(
"
nsHalfOpenSocket
this
=
%
p
using
legacy
nsISocketTransportService
"
"
means
explicit
route
%
s
:
%
d
will
be
ignored
.
\
n
"
this
ci
-
>
RoutedHost
(
)
ci
-
>
RoutedPort
(
)
)
)
;
}
rv
=
sts
-
>
CreateTransport
(
socketTypes
typeCount
ci
-
>
GetOrigin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
ProxyInfo
(
)
getter_AddRefs
(
socketTransport
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
tmpFlags
=
0
;
if
(
mCaps
&
NS_HTTP_REFRESH_DNS
)
tmpFlags
=
nsISocketTransport
:
:
BYPASS_CACHE
;
if
(
mCaps
&
NS_HTTP_LOAD_ANONYMOUS
)
tmpFlags
|
=
nsISocketTransport
:
:
ANONYMOUS_CONNECT
;
if
(
ci
-
>
GetPrivate
(
)
)
tmpFlags
|
=
nsISocketTransport
:
:
NO_PERMANENT_STORAGE
;
if
(
(
mCaps
&
NS_HTTP_BE_CONSERVATIVE
)
|
|
ci
-
>
GetBeConservative
(
)
)
{
LOG
(
(
"
Setting
Socket
to
BE_CONSERVATIVE
"
)
)
;
tmpFlags
|
=
nsISocketTransport
:
:
BE_CONSERVATIVE
;
}
if
(
mEnt
-
>
mPreferIPv6
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV4
;
}
else
if
(
mEnt
-
>
mPreferIPv4
|
|
(
isBackup
&
&
gHttpHandler
-
>
FastFallbackToIPv4
(
)
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV6
;
}
if
(
!
Allow1918
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_RFC1918
;
}
socketTransport
-
>
SetConnectionFlags
(
tmpFlags
)
;
const
OriginAttributes
&
originAttributes
=
mEnt
-
>
mConnInfo
-
>
GetOriginAttributes
(
)
;
if
(
originAttributes
!
=
OriginAttributes
(
)
)
{
socketTransport
-
>
SetOriginAttributes
(
originAttributes
)
;
}
socketTransport
-
>
SetQoSBits
(
gHttpHandler
-
>
GetQoSBits
(
)
)
;
if
(
!
ci
-
>
GetNetworkInterfaceId
(
)
.
IsEmpty
(
)
)
{
socketTransport
-
>
SetNetworkInterfaceId
(
ci
-
>
GetNetworkInterfaceId
(
)
)
;
}
rv
=
socketTransport
-
>
SetEventSink
(
this
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
socketTransport
-
>
SetSecurityCallbacks
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_CONNECTION_ENTRY_CACHE_HIT_1
mEnt
-
>
mUsedForConnection
)
;
mEnt
-
>
mUsedForConnection
=
true
;
nsCOMPtr
<
nsIOutputStream
>
sout
;
rv
=
socketTransport
-
>
OpenOutputStream
(
nsITransport
:
:
OPEN_UNBUFFERED
0
0
getter_AddRefs
(
sout
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
sin
;
rv
=
socketTransport
-
>
OpenInputStream
(
nsITransport
:
:
OPEN_UNBUFFERED
0
0
getter_AddRefs
(
sin
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
socketTransport
.
forget
(
transport
)
;
CallQueryInterface
(
sin
instream
)
;
CallQueryInterface
(
sout
outstream
)
;
rv
=
(
*
outstream
)
-
>
AsyncWait
(
this
0
0
nullptr
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
gHttpHandler
-
>
ConnMgr
(
)
-
>
StartedConnect
(
)
;
return
rv
;
}
nsresult
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
SetupPrimaryStreams
(
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
nsresult
rv
;
mPrimarySynStarted
=
TimeStamp
:
:
Now
(
)
;
rv
=
SetupStreams
(
getter_AddRefs
(
mSocketTransport
)
getter_AddRefs
(
mStreamIn
)
getter_AddRefs
(
mStreamOut
)
false
)
;
LOG
(
(
"
nsHalfOpenSocket
:
:
SetupPrimaryStream
[
this
=
%
p
ent
=
%
s
rv
=
%
"
PRIx32
"
]
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mStreamOut
)
mStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mStreamOut
=
nullptr
;
mStreamIn
=
nullptr
;
mSocketTransport
=
nullptr
;
}
return
rv
;
}
nsresult
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
SetupBackupStreams
(
)
{
MOZ_ASSERT
(
mTransaction
)
;
MOZ_ASSERT
(
!
mTransaction
-
>
IsNullTransaction
(
)
"
null
transactions
dont
have
backup
streams
"
)
;
mBackupSynStarted
=
TimeStamp
:
:
Now
(
)
;
nsresult
rv
=
SetupStreams
(
getter_AddRefs
(
mBackupTransport
)
getter_AddRefs
(
mBackupStreamIn
)
getter_AddRefs
(
mBackupStreamOut
)
true
)
;
LOG
(
(
"
nsHalfOpenSocket
:
:
SetupBackupStream
[
this
=
%
p
ent
=
%
s
rv
=
%
"
PRIx32
"
]
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mBackupStreamOut
)
mBackupStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mBackupStreamOut
=
nullptr
;
mBackupStreamIn
=
nullptr
;
mBackupTransport
=
nullptr
;
}
return
rv
;
}
void
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
SetupBackupTimer
(
)
{
uint16_t
timeout
=
gHttpHandler
-
>
GetIdleSynTimeout
(
)
;
MOZ_ASSERT
(
!
mSynTimer
"
timer
already
initd
"
)
;
if
(
timeout
&
&
!
mTransaction
-
>
IsDone
(
)
&
&
!
mTransaction
-
>
IsNullTransaction
(
)
)
{
nsresult
rv
;
mSynTimer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mSynTimer
-
>
InitWithCallback
(
this
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
LOG
(
(
"
nsHalfOpenSocket
:
:
SetupBackupTimer
(
)
[
this
=
%
p
]
"
this
)
)
;
}
}
else
if
(
timeout
)
{
LOG
(
(
"
nsHalfOpenSocket
:
:
SetupBackupTimer
(
)
[
this
=
%
p
]
did
not
arm
\
n
"
this
)
)
;
}
}
void
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
CancelBackupTimer
(
)
{
if
(
!
mSynTimer
)
return
;
LOG
(
(
"
nsHalfOpenSocket
:
:
CancelBackupTimer
(
)
"
)
)
;
mSynTimer
-
>
Cancel
(
)
;
mSynTimer
=
nullptr
;
}
void
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
Abandon
(
)
{
LOG
(
(
"
nsHalfOpenSocket
:
:
Abandon
[
this
=
%
p
ent
=
%
s
]
%
p
%
p
%
p
%
p
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
mSocketTransport
.
get
(
)
mBackupTransport
.
get
(
)
mStreamOut
.
get
(
)
mBackupStreamOut
.
get
(
)
)
)
;
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
RefPtr
<
nsHalfOpenSocket
>
deleteProtector
(
this
)
;
if
(
mSocketTransport
)
{
mSocketTransport
-
>
SetEventSink
(
nullptr
nullptr
)
;
mSocketTransport
-
>
SetSecurityCallbacks
(
nullptr
)
;
mSocketTransport
=
nullptr
;
}
if
(
mBackupTransport
)
{
mBackupTransport
-
>
SetEventSink
(
nullptr
nullptr
)
;
mBackupTransport
-
>
SetSecurityCallbacks
(
nullptr
)
;
mBackupTransport
=
nullptr
;
}
if
(
mStreamOut
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
RecvdConnect
(
)
;
mStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mStreamOut
=
nullptr
;
}
if
(
mBackupStreamOut
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
RecvdConnect
(
)
;
mBackupStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mBackupStreamOut
=
nullptr
;
}
mStreamIn
=
mBackupStreamIn
=
nullptr
;
CancelBackupTimer
(
)
;
if
(
mEnt
)
mEnt
-
>
RemoveHalfOpen
(
this
)
;
mEnt
=
nullptr
;
}
double
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
Duration
(
TimeStamp
epoch
)
{
if
(
mPrimarySynStarted
.
IsNull
(
)
)
return
0
;
return
(
epoch
-
mPrimarySynStarted
)
.
ToMilliseconds
(
)
;
}
NS_IMETHODIMP
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
Notify
(
nsITimer
*
timer
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
MOZ_ASSERT
(
timer
=
=
mSynTimer
"
wrong
timer
"
)
;
MOZ_ASSERT
(
mTransaction
&
&
!
mTransaction
-
>
IsNullTransaction
(
)
"
null
transactions
dont
have
backup
streams
"
)
;
DebugOnly
<
nsresult
>
rv
=
SetupBackupStreams
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mSynTimer
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
OnOutputStreamReady
(
nsIAsyncOutputStream
*
out
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
MOZ_ASSERT
(
out
=
=
mStreamOut
|
|
out
=
=
mBackupStreamOut
"
stream
mismatch
"
)
;
LOG
(
(
"
nsHalfOpenSocket
:
:
OnOutputStreamReady
[
this
=
%
p
ent
=
%
s
%
s
]
\
n
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
out
=
=
mStreamOut
?
"
primary
"
:
"
backup
"
)
)
;
int32_t
index
;
nsresult
rv
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
RecvdConnect
(
)
;
CancelBackupTimer
(
)
;
RefPtr
<
nsHttpConnection
>
conn
=
new
nsHttpConnection
(
)
;
LOG
(
(
"
nsHalfOpenSocket
:
:
OnOutputStreamReady
"
"
Created
new
nshttpconnection
%
p
\
n
"
conn
.
get
(
)
)
)
;
conn
-
>
SetTransactionCaps
(
mTransaction
-
>
Caps
(
)
)
;
NetAddr
peeraddr
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
mTransaction
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
out
=
=
mStreamOut
)
{
TimeDuration
rtt
=
TimeStamp
:
:
Now
(
)
-
mPrimarySynStarted
;
rv
=
conn
-
>
Init
(
mEnt
-
>
mConnInfo
gHttpHandler
-
>
ConnMgr
(
)
-
>
mMaxRequestDelay
mSocketTransport
mStreamIn
mStreamOut
mPrimaryConnectedOK
callbacks
PR_MillisecondsToInterval
(
static_cast
<
uint32_t
>
(
rtt
.
ToMilliseconds
(
)
)
)
)
;
if
(
NS_SUCCEEDED
(
mSocketTransport
-
>
GetPeerAddr
(
&
peeraddr
)
)
)
mEnt
-
>
RecordIPFamilyPreference
(
peeraddr
.
raw
.
family
)
;
mStreamOut
=
nullptr
;
mStreamIn
=
nullptr
;
mSocketTransport
=
nullptr
;
}
else
if
(
out
=
=
mBackupStreamOut
)
{
MOZ_ASSERT
(
!
mTransaction
-
>
IsNullTransaction
(
)
"
null
transactions
dont
have
backup
streams
"
)
;
TimeDuration
rtt
=
TimeStamp
:
:
Now
(
)
-
mBackupSynStarted
;
rv
=
conn
-
>
Init
(
mEnt
-
>
mConnInfo
gHttpHandler
-
>
ConnMgr
(
)
-
>
mMaxRequestDelay
mBackupTransport
mBackupStreamIn
mBackupStreamOut
mBackupConnectedOK
callbacks
PR_MillisecondsToInterval
(
static_cast
<
uint32_t
>
(
rtt
.
ToMilliseconds
(
)
)
)
)
;
if
(
NS_SUCCEEDED
(
mBackupTransport
-
>
GetPeerAddr
(
&
peeraddr
)
)
)
mEnt
-
>
RecordIPFamilyPreference
(
peeraddr
.
raw
.
family
)
;
mBackupStreamOut
=
nullptr
;
mBackupStreamIn
=
nullptr
;
mBackupTransport
=
nullptr
;
}
else
{
MOZ_ASSERT
(
false
"
unexpected
stream
"
)
;
rv
=
NS_ERROR_UNEXPECTED
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHalfOpenSocket
:
:
OnOutputStreamReady
"
"
conn
-
>
init
(
%
p
)
failed
%
"
PRIx32
"
\
n
"
conn
.
get
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
rv
;
}
mHasConnected
=
true
;
index
=
mEnt
-
>
mPendingQ
.
IndexOf
(
mTransaction
)
;
if
(
index
!
=
-
1
)
{
MOZ_ASSERT
(
!
mSpeculative
"
Speculative
Half
Open
found
mTransaction
"
)
;
RefPtr
<
nsHttpTransaction
>
temp
=
mEnt
-
>
mPendingQ
[
index
]
;
mEnt
-
>
mPendingQ
.
RemoveElementAt
(
index
)
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
AddActiveConn
(
conn
mEnt
)
;
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchTransaction
(
mEnt
temp
conn
)
;
}
else
{
conn
-
>
SetIsReusedAfter
(
950
)
;
if
(
mEnt
-
>
mConnInfo
-
>
FirstHopSSL
(
)
&
&
!
mEnt
-
>
mPendingQ
.
Length
(
)
&
&
!
mEnt
-
>
mConnInfo
-
>
UsingConnect
(
)
)
{
LOG
(
(
"
nsHalfOpenSocket
:
:
OnOutputStreamReady
null
transaction
will
"
"
be
used
to
finish
SSL
handshake
on
conn
%
p
\
n
"
conn
.
get
(
)
)
)
;
RefPtr
<
nsAHttpTransaction
>
trans
;
if
(
mTransaction
-
>
IsNullTransaction
(
)
&
&
!
mDispatchedMTransaction
)
{
mDispatchedMTransaction
=
true
;
trans
=
mTransaction
;
}
else
{
trans
=
new
NullHttpTransaction
(
mEnt
-
>
mConnInfo
callbacks
mCaps
)
;
}
gHttpHandler
-
>
ConnMgr
(
)
-
>
AddActiveConn
(
conn
mEnt
)
;
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchAbstractTransaction
(
mEnt
trans
mCaps
conn
0
)
;
}
else
{
LOG
(
(
"
nsHalfOpenSocket
:
:
OnOutputStreamReady
no
transaction
match
"
"
returning
conn
%
p
to
pool
\
n
"
conn
.
get
(
)
)
)
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
OnMsgReclaimConnection
(
0
conn
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
OnTransportStatus
(
nsITransport
*
trans
nsresult
status
int64_t
progress
int64_t
progressMax
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
if
(
mTransaction
)
mTransaction
-
>
OnTransportStatus
(
trans
status
progress
)
;
MOZ_ASSERT
(
trans
=
=
mSocketTransport
|
|
trans
=
=
mBackupTransport
)
;
if
(
status
=
=
NS_NET_STATUS_CONNECTED_TO
)
{
if
(
trans
=
=
mSocketTransport
)
{
mPrimaryConnectedOK
=
true
;
}
else
{
mBackupConnectedOK
=
true
;
}
}
if
(
trans
!
=
mSocketTransport
)
{
return
NS_OK
;
}
if
(
status
=
=
NS_NET_STATUS_CONNECTING_TO
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
&
&
gHttpHandler
-
>
CoalesceSpdy
(
)
&
&
mEnt
&
&
mEnt
-
>
mConnInfo
&
&
mEnt
-
>
mConnInfo
-
>
EndToEndSSL
(
)
&
&
!
mEnt
-
>
mConnInfo
-
>
UsingProxy
(
)
&
&
mEnt
-
>
mCoalescingKeys
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIDNSRecord
>
dnsRecord
(
do_GetInterface
(
mSocketTransport
)
)
;
nsTArray
<
NetAddr
>
addressSet
;
nsresult
rv
=
NS_ERROR_NOT_AVAILABLE
;
if
(
dnsRecord
)
{
rv
=
dnsRecord
-
>
GetAddresses
(
addressSet
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
addressSet
.
IsEmpty
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
addressSet
.
Length
(
)
;
+
+
i
)
{
nsCString
*
newKey
=
mEnt
-
>
mCoalescingKeys
.
AppendElement
(
nsCString
(
)
)
;
newKey
-
>
SetCapacity
(
kIPv6CStrBufSize
+
26
)
;
NetAddrToString
(
&
addressSet
[
i
]
newKey
-
>
BeginWriting
(
)
kIPv6CStrBufSize
)
;
newKey
-
>
SetLength
(
strlen
(
newKey
-
>
BeginReading
(
)
)
)
;
if
(
mEnt
-
>
mConnInfo
-
>
GetAnonymous
(
)
)
{
newKey
-
>
AppendLiteral
(
"
~
A
:
"
)
;
}
else
{
newKey
-
>
AppendLiteral
(
"
~
.
:
"
)
;
}
newKey
-
>
AppendInt
(
mEnt
-
>
mConnInfo
-
>
OriginPort
(
)
)
;
newKey
-
>
AppendLiteral
(
"
/
[
"
)
;
nsAutoCString
suffix
;
mEnt
-
>
mConnInfo
-
>
GetOriginAttributes
(
)
.
CreateSuffix
(
suffix
)
;
newKey
-
>
Append
(
suffix
)
;
newKey
-
>
Append
(
'
]
'
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
OnTransportStatus
"
"
STATUS_CONNECTING_TO
Established
New
Coalescing
Key
#
%
d
for
host
"
"
%
s
[
%
s
]
"
i
mEnt
-
>
mConnInfo
-
>
Origin
(
)
newKey
-
>
get
(
)
)
)
;
}
gHttpHandler
-
>
ConnMgr
(
)
-
>
ProcessSpdyPendingQ
(
mEnt
)
;
}
}
switch
(
status
)
{
case
NS_NET_STATUS_CONNECTING_TO
:
if
(
mEnt
&
&
!
mBackupTransport
&
&
!
mSynTimer
)
SetupBackupTimer
(
)
;
break
;
case
NS_NET_STATUS_CONNECTED_TO
:
CancelBackupTimer
(
)
;
break
;
default
:
break
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpConnectionMgr
:
:
nsHalfOpenSocket
:
:
GetInterface
(
const
nsIID
&
iid
void
*
*
result
)
{
if
(
mTransaction
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
mTransaction
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
callbacks
)
return
callbacks
-
>
GetInterface
(
iid
result
)
;
}
return
NS_ERROR_NO_INTERFACE
;
}
already_AddRefed
<
nsHttpConnection
>
ConnectionHandle
:
:
TakeHttpConnection
(
)
{
MOZ_ASSERT
(
mConn
)
;
return
mConn
.
forget
(
)
;
}
nsHttpConnectionMgr
:
:
nsConnectionEntry
:
:
nsConnectionEntry
(
nsHttpConnectionInfo
*
ci
)
:
mConnInfo
(
ci
)
mUsingSpdy
(
false
)
mInPreferredHash
(
false
)
mPreferIPv4
(
false
)
mPreferIPv6
(
false
)
mUsedForConnection
(
false
)
{
MOZ_COUNT_CTOR
(
nsConnectionEntry
)
;
}
bool
nsHttpConnectionMgr
:
:
nsConnectionEntry
:
:
AvailableForDispatchNow
(
)
{
if
(
mIdleConns
.
Length
(
)
&
&
mIdleConns
[
0
]
-
>
CanReuse
(
)
)
{
return
true
;
}
return
gHttpHandler
-
>
ConnMgr
(
)
-
>
GetSpdyPreferredConn
(
this
)
?
true
:
false
;
}
bool
nsHttpConnectionMgr
:
:
GetConnectionData
(
nsTArray
<
HttpRetParams
>
*
aArg
)
{
for
(
auto
iter
=
mCT
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
nsConnectionEntry
>
&
ent
=
iter
.
Data
(
)
;
if
(
ent
-
>
mConnInfo
-
>
GetPrivate
(
)
)
{
continue
;
}
HttpRetParams
data
;
data
.
host
=
ent
-
>
mConnInfo
-
>
Origin
(
)
;
data
.
port
=
ent
-
>
mConnInfo
-
>
OriginPort
(
)
;
for
(
uint32_t
i
=
0
;
i
<
ent
-
>
mActiveConns
.
Length
(
)
;
i
+
+
)
{
HttpConnInfo
info
;
info
.
ttl
=
ent
-
>
mActiveConns
[
i
]
-
>
TimeToLive
(
)
;
info
.
rtt
=
ent
-
>
mActiveConns
[
i
]
-
>
Rtt
(
)
;
if
(
ent
-
>
mActiveConns
[
i
]
-
>
UsingSpdy
(
)
)
{
info
.
SetHTTP2ProtocolVersion
(
ent
-
>
mActiveConns
[
i
]
-
>
GetSpdyVersion
(
)
)
;
}
else
{
info
.
SetHTTP1ProtocolVersion
(
ent
-
>
mActiveConns
[
i
]
-
>
GetLastHttpResponseVersion
(
)
)
;
}
data
.
active
.
AppendElement
(
info
)
;
}
for
(
uint32_t
i
=
0
;
i
<
ent
-
>
mIdleConns
.
Length
(
)
;
i
+
+
)
{
HttpConnInfo
info
;
info
.
ttl
=
ent
-
>
mIdleConns
[
i
]
-
>
TimeToLive
(
)
;
info
.
rtt
=
ent
-
>
mIdleConns
[
i
]
-
>
Rtt
(
)
;
info
.
SetHTTP1ProtocolVersion
(
ent
-
>
mIdleConns
[
i
]
-
>
GetLastHttpResponseVersion
(
)
)
;
data
.
idle
.
AppendElement
(
info
)
;
}
for
(
uint32_t
i
=
0
;
i
<
ent
-
>
mHalfOpens
.
Length
(
)
;
i
+
+
)
{
HalfOpenSockets
hSocket
;
hSocket
.
speculative
=
ent
-
>
mHalfOpens
[
i
]
-
>
IsSpeculative
(
)
;
data
.
halfOpens
.
AppendElement
(
hSocket
)
;
}
data
.
spdy
=
ent
-
>
mUsingSpdy
;
data
.
ssl
=
ent
-
>
mConnInfo
-
>
EndToEndSSL
(
)
;
aArg
-
>
AppendElement
(
data
)
;
}
return
true
;
}
void
nsHttpConnectionMgr
:
:
ResetIPFamilyPreference
(
nsHttpConnectionInfo
*
ci
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
nsConnectionEntry
*
ent
=
LookupConnectionEntry
(
ci
nullptr
nullptr
)
;
if
(
ent
)
ent
-
>
ResetIPFamilyPreference
(
)
;
}
uint32_t
nsHttpConnectionMgr
:
:
nsConnectionEntry
:
:
UnconnectedHalfOpens
(
)
{
uint32_t
unconnectedHalfOpens
=
0
;
for
(
uint32_t
i
=
0
;
i
<
mHalfOpens
.
Length
(
)
;
+
+
i
)
{
if
(
!
mHalfOpens
[
i
]
-
>
HasConnected
(
)
)
+
+
unconnectedHalfOpens
;
}
return
unconnectedHalfOpens
;
}
void
nsHttpConnectionMgr
:
:
nsConnectionEntry
:
:
RemoveHalfOpen
(
nsHalfOpenSocket
*
halfOpen
)
{
if
(
mHalfOpens
.
RemoveElement
(
halfOpen
)
)
{
if
(
halfOpen
-
>
IsSpeculative
(
)
)
{
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
HTTPCONNMGR_UNUSED_SPECULATIVE_CONN
>
unusedSpeculativeConn
;
+
+
unusedSpeculativeConn
;
if
(
halfOpen
-
>
IsFromPredictor
(
)
)
{
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
PREDICTOR_TOTAL_PRECONNECTS_UNUSED
>
totalPreconnectsUnused
;
+
+
totalPreconnectsUnused
;
}
}
MOZ_ASSERT
(
gHttpHandler
-
>
ConnMgr
(
)
-
>
mNumHalfOpenConns
)
;
if
(
gHttpHandler
-
>
ConnMgr
(
)
-
>
mNumHalfOpenConns
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
mNumHalfOpenConns
-
-
;
}
}
if
(
!
UnconnectedHalfOpens
(
)
)
{
nsresult
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
ProcessPendingQ
(
mConnInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpConnectionMgr
:
:
nsConnectionEntry
:
:
RemoveHalfOpen
\
n
"
"
failed
to
process
pending
queue
\
n
"
)
)
;
}
}
}
void
nsHttpConnectionMgr
:
:
nsConnectionEntry
:
:
RecordIPFamilyPreference
(
uint16_t
family
)
{
if
(
family
=
=
PR_AF_INET
&
&
!
mPreferIPv6
)
mPreferIPv4
=
true
;
if
(
family
=
=
PR_AF_INET6
&
&
!
mPreferIPv4
)
mPreferIPv6
=
true
;
}
void
nsHttpConnectionMgr
:
:
nsConnectionEntry
:
:
ResetIPFamilyPreference
(
)
{
mPreferIPv4
=
false
;
mPreferIPv6
=
false
;
}
void
nsHttpConnectionMgr
:
:
MoveToWildCardConnEntry
(
nsHttpConnectionInfo
*
specificCI
nsHttpConnectionInfo
*
wildCardCI
nsHttpConnection
*
proxyConn
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
gSocketThread
)
;
MOZ_ASSERT
(
specificCI
-
>
UsingHttpsProxy
(
)
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeConnEntryWildCard
conn
%
p
has
requested
to
"
"
change
CI
from
%
s
to
%
s
\
n
"
proxyConn
specificCI
-
>
HashKey
(
)
.
get
(
)
wildCardCI
-
>
HashKey
(
)
.
get
(
)
)
)
;
nsConnectionEntry
*
ent
=
LookupConnectionEntry
(
specificCI
proxyConn
nullptr
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeConnEntryWildCard
conn
%
p
using
ent
%
p
(
spdy
%
d
)
\
n
"
proxyConn
ent
ent
?
ent
-
>
mUsingSpdy
:
0
)
)
;
if
(
!
ent
|
|
!
ent
-
>
mUsingSpdy
)
{
return
;
}
nsConnectionEntry
*
wcEnt
=
GetOrCreateConnectionEntry
(
wildCardCI
true
)
;
if
(
wcEnt
=
=
ent
)
{
return
;
}
wcEnt
-
>
mUsingSpdy
=
true
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeConnEntryWildCard
ent
%
p
"
"
idle
=
%
"
PRIuSIZE
"
active
=
%
"
PRIuSIZE
"
half
=
%
"
PRIuSIZE
"
pending
=
%
"
PRIuSIZE
"
\
n
"
ent
ent
-
>
mIdleConns
.
Length
(
)
ent
-
>
mActiveConns
.
Length
(
)
ent
-
>
mHalfOpens
.
Length
(
)
ent
-
>
mPendingQ
.
Length
(
)
)
)
;
LOG
(
(
"
nsHttpConnectionMgr
:
:
MakeConnEntryWildCard
wc
-
ent
%
p
"
"
idle
=
%
"
PRIuSIZE
"
active
=
%
"
PRIuSIZE
"
half
=
%
"
PRIuSIZE
"
pending
=
%
"
PRIuSIZE
"
\
n
"
wcEnt
wcEnt
-
>
mIdleConns
.
Length
(
)
wcEnt
-
>
mActiveConns
.
Length
(
)
wcEnt
-
>
mHalfOpens
.
Length
(
)
wcEnt
-
>
mPendingQ
.
Length
(
)
)
)
;
int32_t
count
=
ent
-
>
mActiveConns
.
Length
(
)
;
RefPtr
<
nsHttpConnection
>
deleteProtector
(
proxyConn
)
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
ent
-
>
mActiveConns
[
i
]
=
=
proxyConn
)
{
ent
-
>
mActiveConns
.
RemoveElementAt
(
i
)
;
wcEnt
-
>
mActiveConns
.
InsertElementAt
(
0
proxyConn
)
;
return
;
}
}
count
=
ent
-
>
mIdleConns
.
Length
(
)
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
ent
-
>
mIdleConns
[
i
]
=
=
proxyConn
)
{
ent
-
>
mIdleConns
.
RemoveElementAt
(
i
)
;
wcEnt
-
>
mIdleConns
.
InsertElementAt
(
0
proxyConn
)
;
return
;
}
}
}
}
}
