#
ifndef
nsHttpTransaction_h__
#
define
nsHttpTransaction_h__
#
include
"
nsHttp
.
h
"
#
include
"
nsAHttpTransaction
.
h
"
#
include
"
HttpTransactionShell
.
h
"
#
include
"
nsAHttpConnection
.
h
"
#
include
"
EventTokenBucket
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
TimingStruct
.
h
"
#
include
"
Http2Push
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
mozilla
/
net
/
NeckoChannelParams
.
h
"
#
include
"
ARefBase
.
h
"
class
nsIHttpActivityObserver
;
class
nsIDNSHTTPSSVCRecord
;
class
nsIEventTarget
;
class
nsIInputStream
;
class
nsIOutputStream
;
class
nsIRequestContext
;
class
nsISVCBRecord
;
namespace
mozilla
{
namespace
net
{
class
HTTPSRecordResolver
;
class
nsHttpChunkedDecoder
;
class
nsHttpHeaderArray
;
class
nsHttpRequestHead
;
class
nsHttpResponseHead
;
class
NullHttpTransaction
;
class
SpdyConnectTransaction
;
class
nsHttpTransaction
final
:
public
nsAHttpTransaction
public
HttpTransactionShell
public
ATokenBucketEvent
public
nsIInputStreamCallback
public
nsIOutputStreamCallback
public
ARefBase
public
nsITimerCallback
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSAHTTPTRANSACTION
NS_DECL_HTTPTRANSACTIONSHELL
NS_DECL_NSIINPUTSTREAMCALLBACK
NS_DECL_NSIOUTPUTSTREAMCALLBACK
NS_DECL_NSITIMERCALLBACK
nsHttpTransaction
(
)
;
void
OnActivated
(
)
override
;
nsHttpResponseHead
*
ResponseHead
(
)
{
return
mHaveAllHeaders
?
mResponseHead
:
nullptr
;
}
nsIEventTarget
*
ConsumerTarget
(
)
{
return
mConsumerTarget
;
}
void
SetResponseIsComplete
(
)
{
mResponseIsComplete
=
true
;
}
void
EnableKeepAlive
(
)
{
mCaps
|
=
NS_HTTP_ALLOW_KEEPALIVE
;
}
void
MakeSticky
(
)
{
mCaps
|
=
NS_HTTP_STICKY_CONNECTION
;
}
void
MakeNonSticky
(
)
override
{
mCaps
&
=
~
NS_HTTP_STICKY_CONNECTION
;
}
void
MakeDontWaitHTTPSSVC
(
)
{
mCaps
&
=
~
NS_HTTP_WAIT_HTTPSSVC_RESULT
;
}
void
SetPriority
(
int32_t
priority
)
{
mPriority
=
priority
;
}
int32_t
Priority
(
)
{
return
mPriority
;
}
void
PrintDiagnostics
(
nsCString
&
log
)
;
void
SetPendingTime
(
bool
now
=
true
)
{
if
(
!
now
&
&
!
mPendingTime
.
IsNull
(
)
)
{
mPendingDurationTime
=
TimeStamp
:
:
Now
(
)
-
mPendingTime
;
}
mPendingTime
=
now
?
TimeStamp
:
:
Now
(
)
:
TimeStamp
(
)
;
}
const
TimeStamp
GetPendingTime
(
)
{
return
mPendingTime
;
}
nsIRequestContext
*
RequestContext
(
)
override
{
return
mRequestContext
.
get
(
)
;
}
void
DispatchedAsBlocking
(
)
;
void
RemoveDispatchedAsBlocking
(
)
;
void
DisableSpdy
(
)
override
;
void
DisableHttp3
(
)
override
;
nsHttpTransaction
*
QueryHttpTransaction
(
)
override
{
return
this
;
}
already_AddRefed
<
Http2PushedStreamWrapper
>
GetPushedStream
(
)
{
return
do_AddRef
(
mPushedStream
)
;
}
already_AddRefed
<
Http2PushedStreamWrapper
>
TakePushedStream
(
)
{
return
mPushedStream
.
forget
(
)
;
}
uint32_t
InitialRwin
(
)
const
{
return
mInitialRwin
;
}
;
bool
ChannelPipeFull
(
)
{
return
mWaitingOnPipeOut
;
}
void
BootstrapTimings
(
TimingStruct
times
)
;
void
SetConnectStart
(
mozilla
:
:
TimeStamp
timeStamp
bool
onlyIfNull
=
false
)
;
void
SetConnectEnd
(
mozilla
:
:
TimeStamp
timeStamp
bool
onlyIfNull
=
false
)
;
void
SetRequestStart
(
mozilla
:
:
TimeStamp
timeStamp
bool
onlyIfNull
=
false
)
;
void
SetResponseStart
(
mozilla
:
:
TimeStamp
timeStamp
bool
onlyIfNull
=
false
)
;
void
SetResponseEnd
(
mozilla
:
:
TimeStamp
timeStamp
bool
onlyIfNull
=
false
)
;
[
[
nodiscard
]
]
bool
Do0RTT
(
)
override
;
[
[
nodiscard
]
]
nsresult
Finish0RTT
(
bool
aRestart
bool
aAlpnChanged
)
override
;
void
Refused0RTT
(
)
;
[
[
nodiscard
]
]
bool
CanDo0RTT
(
)
override
;
[
[
nodiscard
]
]
nsresult
RestartOnFastOpenError
(
)
override
;
uint64_t
TopLevelOuterContentWindowId
(
)
override
{
return
mTopLevelOuterContentWindowId
;
}
void
SetFastOpenStatus
(
uint8_t
aStatus
)
override
;
void
SetHttpTrailers
(
nsCString
&
aTrailers
)
;
bool
IsWebsocketUpgrade
(
)
;
void
SetH2WSTransaction
(
SpdyConnectTransaction
*
)
;
void
OnProxyConnectComplete
(
int32_t
aResponseCode
)
override
;
void
SetFlat407Headers
(
const
nsACString
&
aHeaders
)
;
void
OnPush
(
Http2PushedStreamWrapper
*
aStream
)
;
void
UpdateConnectionInfo
(
nsHttpConnectionInfo
*
aConnInfo
)
;
void
SetClassOfService
(
uint32_t
cos
)
;
virtual
nsresult
OnHTTPSRRAvailable
(
nsIDNSHTTPSSVCRecord
*
aHTTPSSVCRecord
nsISVCBRecord
*
aHighestPriorityRecord
)
override
;
private
:
friend
class
DeleteHttpTransaction
;
virtual
~
nsHttpTransaction
(
)
;
[
[
nodiscard
]
]
nsresult
Restart
(
)
;
char
*
LocateHttpStart
(
char
*
buf
uint32_t
len
bool
aAllowPartialMatch
)
;
[
[
nodiscard
]
]
nsresult
ParseLine
(
nsACString
&
line
)
;
[
[
nodiscard
]
]
nsresult
ParseLineSegment
(
char
*
seg
uint32_t
len
)
;
[
[
nodiscard
]
]
nsresult
ParseHead
(
char
*
uint32_t
count
uint32_t
*
countRead
)
;
[
[
nodiscard
]
]
nsresult
HandleContentStart
(
)
;
[
[
nodiscard
]
]
nsresult
HandleContent
(
char
*
uint32_t
count
uint32_t
*
contentRead
uint32_t
*
contentRemaining
)
;
[
[
nodiscard
]
]
nsresult
ProcessData
(
char
*
uint32_t
uint32_t
*
)
;
void
DeleteSelfOnConsumerThread
(
)
;
void
ReleaseBlockingTransaction
(
)
;
[
[
nodiscard
]
]
static
nsresult
ReadRequestSegment
(
nsIInputStream
*
void
*
const
char
*
uint32_t
uint32_t
uint32_t
*
)
;
[
[
nodiscard
]
]
static
nsresult
WritePipeSegment
(
nsIOutputStream
*
void
*
char
*
uint32_t
uint32_t
uint32_t
*
)
;
bool
TimingEnabled
(
)
const
{
return
mCaps
&
NS_HTTP_TIMING_ENABLED
;
}
bool
ResponseTimeoutEnabled
(
)
const
final
;
void
ReuseConnectionOnRestartOK
(
bool
reuseOk
)
override
{
mReuseOnRestart
=
reuseOk
;
}
void
CheckForStickyAuthScheme
(
)
;
void
CheckForStickyAuthSchemeAt
(
nsHttpAtom
const
&
header
)
;
bool
IsStickyAuthSchemeAt
(
nsACString
const
&
auth
)
;
bool
ShouldThrottle
(
)
;
void
NotifyTransactionObserver
(
nsresult
reason
)
;
bool
PrepareSVCBRecordsForRetry
(
const
nsACString
&
aFailedDomainName
bool
&
aAllRecordsHaveEchConfig
)
;
void
PrepareConnInfoForRetry
(
nsresult
aReason
)
;
already_AddRefed
<
nsHttpConnectionInfo
>
PrepareFastFallbackConnInfo
(
bool
aEchConfigUsed
)
;
already_AddRefed
<
Http2PushedStreamWrapper
>
TakePushedStreamById
(
uint32_t
aStreamId
)
;
enum
HTTPSSVC_CONNECTION_FAILED_REASON
:
uint32_t
{
HTTPSSVC_CONNECTION_OK
=
0
HTTPSSVC_CONNECTION_UNKNOWN_HOST
=
1
HTTPSSVC_CONNECTION_UNREACHABLE
=
2
HTTPSSVC_CONNECTION_421_RECEIVED
=
3
HTTPSSVC_CONNECTION_SECURITY_ERROR
=
4
HTTPSSVC_CONNECTION_NO_USABLE_RECORD
=
5
HTTPSSVC_CONNECTION_ALL_RECORDS_EXCLUDED
=
6
HTTPSSVC_CONNECTION_OTHERS
=
7
}
;
HTTPSSVC_CONNECTION_FAILED_REASON
ErrorCodeToFailedReason
(
nsresult
aErrorCode
)
;
void
OnHttp3BackupTimer
(
)
;
void
OnBackupConnectionReady
(
)
;
void
OnFastFallbackTimer
(
)
;
void
HandleFallback
(
nsHttpConnectionInfo
*
aFallbackConnInfo
)
;
void
MaybeCancelFallbackTimer
(
)
;
private
:
class
UpdateSecurityCallbacks
:
public
Runnable
{
public
:
UpdateSecurityCallbacks
(
nsHttpTransaction
*
aTrans
nsIInterfaceRequestor
*
aCallbacks
)
:
Runnable
(
"
net
:
:
nsHttpTransaction
:
:
UpdateSecurityCallbacks
"
)
mTrans
(
aTrans
)
mCallbacks
(
aCallbacks
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mTrans
-
>
mConnection
)
mTrans
-
>
mConnection
-
>
SetSecurityCallbacks
(
mCallbacks
)
;
return
NS_OK
;
}
private
:
RefPtr
<
nsHttpTransaction
>
mTrans
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
}
;
Mutex
mLock
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
nsCOMPtr
<
nsITransportEventSink
>
mTransportSink
;
nsCOMPtr
<
nsIEventTarget
>
mConsumerTarget
;
nsCOMPtr
<
nsISupports
>
mSecurityInfo
;
nsCOMPtr
<
nsIAsyncInputStream
>
mPipeIn
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mPipeOut
;
nsCOMPtr
<
nsIRequestContext
>
mRequestContext
;
uint64_t
mChannelId
;
nsCOMPtr
<
nsIHttpActivityObserver
>
mActivityDistributor
;
nsCString
mReqHeaderBuf
;
nsCOMPtr
<
nsIInputStream
>
mRequestStream
;
int64_t
mRequestSize
;
RefPtr
<
nsAHttpConnection
>
mConnection
;
RefPtr
<
nsHttpConnectionInfo
>
mConnInfo
;
RefPtr
<
nsHttpConnectionInfo
>
mOrigConnInfo
;
nsHttpRequestHead
*
mRequestHead
;
nsHttpResponseHead
*
mResponseHead
;
nsAHttpSegmentReader
*
mReader
;
nsAHttpSegmentWriter
*
mWriter
;
nsCString
mLineBuf
;
int64_t
mContentLength
;
int64_t
mContentRead
;
Atomic
<
int64_t
ReleaseAcquire
>
mTransferSize
;
uint32_t
mInvalidResponseBytesRead
;
RefPtr
<
Http2PushedStreamWrapper
>
mPushedStream
;
uint32_t
mInitialRwin
;
nsHttpChunkedDecoder
*
mChunkedDecoder
;
TimingStruct
mTimings
;
nsresult
mStatus
;
int16_t
mPriority
;
uint16_t
mRestartCount
;
uint32_t
mCaps
;
HttpVersion
mHttpVersion
;
uint16_t
mHttpResponseCode
;
nsCString
mFlat407Headers
;
uint32_t
mCurrentHttpResponseHeaderSize
;
int32_t
const
THROTTLE_NO_LIMIT
=
-
1
;
int32_t
mThrottlingReadAllowance
;
Atomic
<
uint32_t
>
mCapsToClear
;
Atomic
<
bool
ReleaseAcquire
>
mResponseIsComplete
;
Atomic
<
bool
ReleaseAcquire
>
mClosed
;
bool
mReadingStopped
;
bool
mConnected
;
bool
mActivated
;
bool
mHaveStatusLine
;
bool
mHaveAllHeaders
;
bool
mTransactionDone
;
bool
mDidContentStart
;
bool
mNoContent
;
bool
mSentData
;
bool
mReceivedData
;
bool
mStatusEventPending
;
bool
mHasRequestBody
;
bool
mProxyConnectFailed
;
bool
mHttpResponseMatched
;
bool
mPreserveStream
;
bool
mDispatchedAsBlocking
;
bool
mResponseTimeoutEnabled
;
bool
mForceRestart
;
bool
mReuseOnRestart
;
bool
mContentDecoding
;
bool
mContentDecodingCheck
;
bool
mDeferredSendProgress
;
bool
mWaitingOnPipeOut
;
bool
mDoNotRemoveAltSvc
;
bool
mReportedStart
;
bool
mReportedResponseHeader
;
bool
mResponseHeadTaken
;
UniquePtr
<
nsHttpHeaderArray
>
mForTakeResponseTrailers
;
bool
mResponseTrailersTaken
;
Atomic
<
bool
>
mRestarted
;
TimeStamp
mPendingTime
;
TimeDuration
mPendingDurationTime
;
uint64_t
mTopLevelOuterContentWindowId
;
public
:
bool
TryToRunPacedRequest
(
)
;
void
OnTokenBucketAdmitted
(
)
override
;
void
CancelPacing
(
nsresult
reason
)
;
void
ResumeReading
(
)
;
bool
EligibleForThrottling
(
)
const
;
private
:
bool
mSubmittedRatePacing
;
bool
mPassedRatePacing
;
bool
mSynchronousRatePaceRequest
;
nsCOMPtr
<
nsICancelable
>
mTokenBucketCancel
;
public
:
uint32_t
ClassOfService
(
)
{
return
mClassOfService
;
}
private
:
Atomic
<
uint32_t
Relaxed
>
mClassOfService
;
public
:
void
SetTunnelProvider
(
ASpdySession
*
provider
)
{
mTunnelProvider
=
provider
;
}
ASpdySession
*
TunnelProvider
(
)
{
return
mTunnelProvider
;
}
nsIInterfaceRequestor
*
SecurityCallbacks
(
)
{
return
mCallbacks
;
}
void
OnPendingQueueInserted
(
)
;
private
:
RefPtr
<
ASpdySession
>
mTunnelProvider
;
TransactionObserverFunc
mTransactionObserver
;
NetAddr
mSelfAddr
;
NetAddr
mPeerAddr
;
bool
mResolvedByTRR
;
bool
m0RTTInProgress
;
bool
mDoNotTryEarlyData
;
enum
{
EARLY_NONE
EARLY_SENT
EARLY_ACCEPTED
EARLY_425
}
mEarlyDataDisposition
;
uint8_t
mFastOpenStatus
;
RefPtr
<
SpdyConnectTransaction
>
mH2WSTransaction
;
HttpTrafficCategory
mTrafficCategory
;
bool
mThroughCaptivePortal
;
int32_t
mProxyConnectResponseCode
;
OnPushCallback
mOnPushCallback
;
nsDataHashtable
<
nsUint32HashKey
RefPtr
<
Http2PushedStreamWrapper
>
>
mIDToStreamMap
;
nsCOMPtr
<
nsICancelable
>
mDNSRequest
;
Maybe
<
uint32_t
>
mHTTPSSVCReceivedStage
;
bool
m421Received
=
false
;
nsCOMPtr
<
nsIDNSHTTPSSVCRecord
>
mHTTPSSVCRecord
;
nsTArray
<
RefPtr
<
nsISVCBRecord
>
>
mRecordsForRetry
;
bool
mDontRetryWithDirectRoute
=
false
;
bool
mFastFallbackTriggered
=
false
;
bool
mAllRecordsInH3ExcludedListBefore
=
false
;
bool
mHttp3BackupTimerCreated
=
false
;
nsCOMPtr
<
nsITimer
>
mFastFallbackTimer
;
nsCOMPtr
<
nsITimer
>
mHttp3BackupTimer
;
RefPtr
<
nsHttpConnectionInfo
>
mBackupConnInfo
;
RefPtr
<
HTTPSRecordResolver
>
mResolver
;
enum
TRANSACTION_RESTART_REASON
:
uint32_t
{
TRANSACTION_RESTART_NONE
=
0
TRANSACTION_RESTART_FORCED
=
1
TRANSACTION_RESTART_HTTPSSVC_INVOLVED
=
2
TRANSACTION_RESTART_NO_DATA_SENT
=
3
TRANSACTION_RESTART_DOWNGRADE_WITH_EARLY_DATA
=
4
TRANSACTION_RESTART_OTHERS
=
5
}
;
nsDataHashtable
<
nsUint32HashKey
uint32_t
>
mEchRetryCounterMap
;
bool
mSupportsHTTP3
=
false
;
}
;
}
}
#
endif
