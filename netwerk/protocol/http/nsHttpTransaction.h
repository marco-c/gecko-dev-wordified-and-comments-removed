#
ifndef
nsHttpTransaction_h__
#
define
nsHttpTransaction_h__
#
include
"
nsHttp
.
h
"
#
include
"
nsAHttpTransaction
.
h
"
#
include
"
HttpTransactionShell
.
h
"
#
include
"
nsAHttpConnection
.
h
"
#
include
"
EventTokenBucket
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIEarlyHintObserver
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
TimingStruct
.
h
"
#
include
"
Http2Push
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
mozilla
/
net
/
NeckoChannelParams
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
ARefBase
.
h
"
class
nsIDNSHTTPSSVCRecord
;
class
nsIEventTarget
;
class
nsIInputStream
;
class
nsIOutputStream
;
class
nsIRequestContext
;
class
nsISVCBRecord
;
namespace
mozilla
:
:
net
{
class
HTTPSRecordResolver
;
class
nsHttpChunkedDecoder
;
class
nsHttpHeaderArray
;
class
nsHttpRequestHead
;
class
nsHttpResponseHead
;
class
NullHttpTransaction
;
class
Http2ConnectTransaction
;
class
nsHttpTransaction
final
:
public
nsAHttpTransaction
public
HttpTransactionShell
public
ATokenBucketEvent
public
nsIInputStreamCallback
public
nsIOutputStreamCallback
public
ARefBase
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSAHTTPTRANSACTION
NS_DECL_HTTPTRANSACTIONSHELL
NS_DECL_NSIINPUTSTREAMCALLBACK
NS_DECL_NSIOUTPUTSTREAMCALLBACK
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
nsHttpTransaction
(
)
;
void
OnActivated
(
)
override
;
nsHttpResponseHead
*
ResponseHead
(
)
{
return
mHaveAllHeaders
?
mResponseHead
:
nullptr
;
}
nsIEventTarget
*
ConsumerTarget
(
)
{
return
mConsumerTarget
;
}
void
SetResponseIsComplete
(
)
{
mResponseIsComplete
=
true
;
}
void
EnableKeepAlive
(
)
{
mCaps
|
=
NS_HTTP_ALLOW_KEEPALIVE
;
}
void
MakeSticky
(
)
{
mCaps
|
=
NS_HTTP_STICKY_CONNECTION
;
}
void
MakeNonSticky
(
)
override
{
mCaps
&
=
~
NS_HTTP_STICKY_CONNECTION
;
}
bool
WaitingForHTTPSRR
(
)
const
{
return
mCaps
&
NS_HTTP_FORCE_WAIT_HTTP_RR
;
}
void
MakeDontWaitHTTPSRR
(
)
{
mCaps
&
=
~
NS_HTTP_FORCE_WAIT_HTTP_RR
;
}
void
SetPriority
(
int32_t
priority
)
{
mPriority
=
priority
;
}
int32_t
Priority
(
)
{
return
mPriority
;
}
void
PrintDiagnostics
(
nsCString
&
log
)
;
void
SetPendingTime
(
bool
now
=
true
)
{
if
(
!
now
&
&
!
mPendingTime
.
IsNull
(
)
)
{
mPendingDurationTime
=
TimeStamp
:
:
Now
(
)
-
mPendingTime
;
}
if
(
mPendingTime
.
IsNull
(
)
)
{
mPendingTime
=
now
?
TimeStamp
:
:
Now
(
)
:
TimeStamp
(
)
;
}
}
TimeStamp
GetPendingTime
(
)
{
return
mPendingTime
;
}
nsIRequestContext
*
RequestContext
(
)
override
{
return
mRequestContext
.
get
(
)
;
}
void
DispatchedAsBlocking
(
)
;
void
RemoveDispatchedAsBlocking
(
)
;
void
DisableSpdy
(
)
override
;
void
DoNotRemoveAltSvc
(
)
override
{
mDoNotRemoveAltSvc
=
true
;
}
void
DisableHttp3
(
bool
aAllowRetryHTTPSRR
)
override
;
nsHttpTransaction
*
QueryHttpTransaction
(
)
override
{
return
this
;
}
already_AddRefed
<
Http2PushedStreamWrapper
>
GetPushedStream
(
)
{
return
do_AddRef
(
mPushedStream
)
;
}
already_AddRefed
<
Http2PushedStreamWrapper
>
TakePushedStream
(
)
{
return
mPushedStream
.
forget
(
)
;
}
uint32_t
InitialRwin
(
)
const
{
return
mInitialRwin
;
}
;
bool
ChannelPipeFull
(
)
{
return
mWaitingOnPipeOut
;
}
void
BootstrapTimings
(
TimingStruct
times
)
;
void
SetConnectStart
(
mozilla
:
:
TimeStamp
timeStamp
bool
onlyIfNull
=
false
)
;
void
SetConnectEnd
(
mozilla
:
:
TimeStamp
timeStamp
bool
onlyIfNull
=
false
)
;
void
SetRequestStart
(
mozilla
:
:
TimeStamp
timeStamp
bool
onlyIfNull
=
false
)
;
void
SetResponseStart
(
mozilla
:
:
TimeStamp
timeStamp
bool
onlyIfNull
=
false
)
;
void
SetResponseEnd
(
mozilla
:
:
TimeStamp
timeStamp
bool
onlyIfNull
=
false
)
;
[
[
nodiscard
]
]
bool
Do0RTT
(
)
override
;
[
[
nodiscard
]
]
nsresult
Finish0RTT
(
bool
aRestart
bool
aAlpnChanged
)
override
;
void
Refused0RTT
(
)
;
uint64_t
TopBrowsingContextId
(
)
override
{
return
mTopBrowsingContextId
;
}
void
SetHttpTrailers
(
nsCString
&
aTrailers
)
;
bool
IsWebsocketUpgrade
(
)
;
void
SetH2WSTransaction
(
Http2ConnectTransaction
*
)
;
void
OnProxyConnectComplete
(
int32_t
aResponseCode
)
override
;
void
SetFlat407Headers
(
const
nsACString
&
aHeaders
)
;
void
OnPush
(
Http2PushedStreamWrapper
*
aStream
)
;
void
UpdateConnectionInfo
(
nsHttpConnectionInfo
*
aConnInfo
)
;
void
SetClassOfService
(
ClassOfService
cos
)
;
virtual
nsresult
OnHTTPSRRAvailable
(
nsIDNSHTTPSSVCRecord
*
aHTTPSSVCRecord
nsISVCBRecord
*
aHighestPriorityRecord
)
override
;
void
GetHashKeyOfConnectionEntry
(
nsACString
&
aResult
)
;
private
:
friend
class
DeleteHttpTransaction
;
virtual
~
nsHttpTransaction
(
)
;
[
[
nodiscard
]
]
nsresult
Restart
(
)
;
char
*
LocateHttpStart
(
char
*
buf
uint32_t
len
bool
aAllowPartialMatch
)
;
[
[
nodiscard
]
]
nsresult
ParseLine
(
nsACString
&
line
)
;
[
[
nodiscard
]
]
nsresult
ParseLineSegment
(
char
*
seg
uint32_t
len
)
;
[
[
nodiscard
]
]
nsresult
ParseHead
(
char
*
uint32_t
count
uint32_t
*
countRead
)
;
[
[
nodiscard
]
]
nsresult
HandleContentStart
(
)
;
[
[
nodiscard
]
]
nsresult
HandleContent
(
char
*
uint32_t
count
uint32_t
*
contentRead
uint32_t
*
contentRemaining
)
;
[
[
nodiscard
]
]
nsresult
ProcessData
(
char
*
uint32_t
uint32_t
*
)
;
void
DeleteSelfOnConsumerThread
(
)
;
void
ReleaseBlockingTransaction
(
)
;
[
[
nodiscard
]
]
static
nsresult
ReadRequestSegment
(
nsIInputStream
*
void
*
const
char
*
uint32_t
uint32_t
uint32_t
*
)
;
[
[
nodiscard
]
]
static
nsresult
WritePipeSegment
(
nsIOutputStream
*
void
*
char
*
uint32_t
uint32_t
uint32_t
*
)
;
bool
TimingEnabled
(
)
const
{
return
mCaps
&
NS_HTTP_TIMING_ENABLED
;
}
bool
ResponseTimeoutEnabled
(
)
const
final
;
void
ReuseConnectionOnRestartOK
(
bool
reuseOk
)
override
{
mReuseOnRestart
=
reuseOk
;
}
void
CheckForStickyAuthScheme
(
)
;
void
CheckForStickyAuthSchemeAt
(
nsHttpAtom
const
&
header
)
;
bool
IsStickyAuthSchemeAt
(
nsACString
const
&
auth
)
;
bool
ShouldThrottle
(
)
;
void
NotifyTransactionObserver
(
nsresult
reason
)
;
bool
PrepareSVCBRecordsForRetry
(
const
nsACString
&
aFailedDomainName
bool
&
aAllRecordsHaveEchConfig
)
;
void
PrepareConnInfoForRetry
(
nsresult
aReason
)
;
already_AddRefed
<
nsHttpConnectionInfo
>
PrepareFastFallbackConnInfo
(
bool
aEchConfigUsed
)
;
void
MaybeReportFailedSVCDomain
(
nsresult
aReason
nsHttpConnectionInfo
*
aFailedConnInfo
)
;
already_AddRefed
<
Http2PushedStreamWrapper
>
TakePushedStreamById
(
uint32_t
aStreamId
)
;
enum
HTTPSSVC_CONNECTION_FAILED_REASON
:
uint32_t
{
HTTPSSVC_CONNECTION_OK
=
0
HTTPSSVC_CONNECTION_UNKNOWN_HOST
=
1
HTTPSSVC_CONNECTION_UNREACHABLE
=
2
HTTPSSVC_CONNECTION_421_RECEIVED
=
3
HTTPSSVC_CONNECTION_SECURITY_ERROR
=
4
HTTPSSVC_CONNECTION_NO_USABLE_RECORD
=
5
HTTPSSVC_CONNECTION_ALL_RECORDS_EXCLUDED
=
6
HTTPSSVC_CONNECTION_OTHERS
=
7
}
;
HTTPSSVC_CONNECTION_FAILED_REASON
ErrorCodeToFailedReason
(
nsresult
aErrorCode
)
;
void
OnHttp3BackupTimer
(
)
;
void
OnBackupConnectionReady
(
bool
aTriggeredByHTTPSRR
)
;
void
OnFastFallbackTimer
(
)
;
void
HandleFallback
(
nsHttpConnectionInfo
*
aFallbackConnInfo
)
;
void
MaybeCancelFallbackTimer
(
)
;
enum
TRANSACTION_RESTART_REASON
:
uint32_t
{
TRANSACTION_RESTART_NONE
=
0
TRANSACTION_RESTART_FORCED
TRANSACTION_RESTART_NO_DATA_SENT
TRANSACTION_RESTART_DOWNGRADE_WITH_EARLY_DATA
TRANSACTION_RESTART_HTTPS_RR_NET_RESET
TRANSACTION_RESTART_HTTPS_RR_CONNECTION_REFUSED
TRANSACTION_RESTART_HTTPS_RR_UNKNOWN_HOST
TRANSACTION_RESTART_HTTPS_RR_NET_TIMEOUT
TRANSACTION_RESTART_HTTPS_RR_SEC_ERROR
TRANSACTION_RESTART_HTTPS_RR_FAST_FALLBACK
TRANSACTION_RESTART_HTTP3_FAST_FALLBACK
TRANSACTION_RESTART_OTHERS
TRANSACTION_RESTART_PROTOCOL_VERSION_ALERT
}
;
void
SetRestartReason
(
TRANSACTION_RESTART_REASON
aReason
)
;
private
:
class
UpdateSecurityCallbacks
:
public
Runnable
{
public
:
UpdateSecurityCallbacks
(
nsHttpTransaction
*
aTrans
nsIInterfaceRequestor
*
aCallbacks
)
:
Runnable
(
"
net
:
:
nsHttpTransaction
:
:
UpdateSecurityCallbacks
"
)
mTrans
(
aTrans
)
mCallbacks
(
aCallbacks
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mTrans
-
>
mConnection
)
{
mTrans
-
>
mConnection
-
>
SetSecurityCallbacks
(
mCallbacks
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
nsHttpTransaction
>
mTrans
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
}
;
Mutex
mLock
MOZ_UNANNOTATED
{
"
transaction
lock
"
}
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
nsCOMPtr
<
nsITransportEventSink
>
mTransportSink
;
nsCOMPtr
<
nsIEventTarget
>
mConsumerTarget
;
nsCOMPtr
<
nsISupports
>
mSecurityInfo
;
nsCOMPtr
<
nsIAsyncInputStream
>
mPipeIn
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mPipeOut
;
nsCOMPtr
<
nsIRequestContext
>
mRequestContext
;
uint64_t
mChannelId
{
0
}
;
nsCString
mReqHeaderBuf
;
nsCOMPtr
<
nsIInputStream
>
mRequestStream
;
int64_t
mRequestSize
{
0
}
;
RefPtr
<
nsAHttpConnection
>
mConnection
;
RefPtr
<
nsHttpConnectionInfo
>
mConnInfo
;
RefPtr
<
nsHttpConnectionInfo
>
mOrigConnInfo
;
nsHttpRequestHead
*
mRequestHead
{
nullptr
}
;
nsHttpResponseHead
*
mResponseHead
{
nullptr
}
;
nsAHttpSegmentReader
*
mReader
{
nullptr
}
;
nsAHttpSegmentWriter
*
mWriter
{
nullptr
}
;
nsCString
mLineBuf
;
int64_t
mContentLength
{
-
1
}
;
int64_t
mContentRead
{
0
}
;
Atomic
<
int64_t
ReleaseAcquire
>
mTransferSize
{
0
}
;
uint32_t
mInvalidResponseBytesRead
{
0
}
;
RefPtr
<
Http2PushedStreamWrapper
>
mPushedStream
;
uint32_t
mInitialRwin
{
0
}
;
nsHttpChunkedDecoder
*
mChunkedDecoder
{
nullptr
}
;
TimingStruct
mTimings
;
nsresult
mStatus
{
NS_OK
}
;
int16_t
mPriority
{
0
}
;
uint16_t
mRestartCount
{
0
}
;
uint32_t
mCaps
{
0
}
;
HttpVersion
mHttpVersion
{
HttpVersion
:
:
UNKNOWN
}
;
uint16_t
mHttpResponseCode
{
0
}
;
nsCString
mFlat407Headers
;
uint32_t
mCurrentHttpResponseHeaderSize
{
0
}
;
int32_t
const
THROTTLE_NO_LIMIT
=
-
1
;
int32_t
mThrottlingReadAllowance
{
THROTTLE_NO_LIMIT
}
;
Atomic
<
uint32_t
>
mCapsToClear
{
0
}
;
Atomic
<
bool
ReleaseAcquire
>
mResponseIsComplete
{
false
}
;
Atomic
<
bool
ReleaseAcquire
>
mClosed
{
false
}
;
Atomic
<
bool
Relaxed
>
mIsHttp3Used
{
false
}
;
bool
mReadingStopped
{
false
}
;
bool
mConnected
{
false
}
;
bool
mActivated
{
false
}
;
bool
mHaveStatusLine
{
false
}
;
bool
mHaveAllHeaders
{
false
}
;
bool
mTransactionDone
{
false
}
;
bool
mDidContentStart
{
false
}
;
bool
mNoContent
{
false
}
;
bool
mSentData
{
false
}
;
bool
mReceivedData
{
false
}
;
bool
mStatusEventPending
{
false
}
;
bool
mHasRequestBody
{
false
}
;
bool
mProxyConnectFailed
{
false
}
;
bool
mHttpResponseMatched
{
false
}
;
bool
mPreserveStream
{
false
}
;
bool
mDispatchedAsBlocking
{
false
}
;
bool
mResponseTimeoutEnabled
{
true
}
;
bool
mForceRestart
{
false
}
;
bool
mReuseOnRestart
{
false
}
;
bool
mContentDecoding
{
false
}
;
bool
mContentDecodingCheck
{
false
}
;
bool
mDeferredSendProgress
{
false
}
;
bool
mWaitingOnPipeOut
{
false
}
;
bool
mDoNotRemoveAltSvc
{
false
}
;
bool
mReportedStart
{
false
}
;
bool
mReportedResponseHeader
{
false
}
;
bool
mResponseHeadTaken
{
false
}
;
UniquePtr
<
nsHttpHeaderArray
>
mForTakeResponseTrailers
;
bool
mResponseTrailersTaken
{
false
}
;
Atomic
<
bool
>
mRestarted
{
false
}
;
TimeStamp
mPendingTime
;
TimeDuration
mPendingDurationTime
;
uint64_t
mTopBrowsingContextId
{
0
}
;
public
:
bool
TryToRunPacedRequest
(
)
;
void
OnTokenBucketAdmitted
(
)
override
;
void
CancelPacing
(
nsresult
reason
)
;
void
ResumeReading
(
)
;
bool
EligibleForThrottling
(
)
const
;
private
:
bool
mSubmittedRatePacing
{
false
}
;
bool
mPassedRatePacing
{
false
}
;
bool
mSynchronousRatePaceRequest
{
false
}
;
nsCOMPtr
<
nsICancelable
>
mTokenBucketCancel
;
void
CollectTelemetryForUploads
(
)
;
public
:
ClassOfService
GetClassOfService
(
)
{
return
{
mClassOfServiceFlags
mClassOfServiceIncremental
}
;
}
private
:
Atomic
<
uint32_t
Relaxed
>
mClassOfServiceFlags
{
0
}
;
Atomic
<
bool
Relaxed
>
mClassOfServiceIncremental
{
false
}
;
public
:
nsIInterfaceRequestor
*
SecurityCallbacks
(
)
{
return
mCallbacks
;
}
void
OnPendingQueueInserted
(
const
nsACString
&
aConnectionHashKey
)
;
private
:
TransactionObserverFunc
mTransactionObserver
;
NetAddr
mSelfAddr
;
NetAddr
mPeerAddr
;
bool
mResolvedByTRR
{
false
}
;
bool
mEchConfigUsed
=
false
;
bool
m0RTTInProgress
{
false
}
;
bool
mDoNotTryEarlyData
{
false
}
;
enum
{
EARLY_NONE
EARLY_SENT
EARLY_ACCEPTED
EARLY_425
}
mEarlyDataDisposition
{
EARLY_NONE
}
;
RefPtr
<
Http2ConnectTransaction
>
mH2WSTransaction
;
HttpTrafficCategory
mTrafficCategory
{
HttpTrafficCategory
:
:
eInvalid
}
;
bool
mThroughCaptivePortal
;
Atomic
<
int32_t
>
mProxyConnectResponseCode
{
0
}
;
OnPushCallback
mOnPushCallback
;
nsTHashMap
<
uint32_t
RefPtr
<
Http2PushedStreamWrapper
>
>
mIDToStreamMap
;
nsCOMPtr
<
nsICancelable
>
mDNSRequest
;
Atomic
<
uint32_t
Relaxed
>
mHTTPSSVCReceivedStage
{
HTTPSSVC_NOT_USED
}
;
bool
m421Received
=
false
;
nsCOMPtr
<
nsIDNSHTTPSSVCRecord
>
mHTTPSSVCRecord
;
nsTArray
<
RefPtr
<
nsISVCBRecord
>
>
mRecordsForRetry
;
bool
mDontRetryWithDirectRoute
=
false
;
bool
mFastFallbackTriggered
=
false
;
bool
mAllRecordsInH3ExcludedListBefore
=
false
;
bool
mHttp3BackupTimerCreated
=
false
;
nsCOMPtr
<
nsITimer
>
mFastFallbackTimer
;
nsCOMPtr
<
nsITimer
>
mHttp3BackupTimer
;
RefPtr
<
nsHttpConnectionInfo
>
mBackupConnInfo
;
RefPtr
<
HTTPSRecordResolver
>
mResolver
;
TRANSACTION_RESTART_REASON
mRestartReason
=
TRANSACTION_RESTART_NONE
;
nsTHashMap
<
nsUint32HashKey
uint32_t
>
mEchRetryCounterMap
;
bool
mSupportsHTTP3
=
false
;
bool
mEarlyDataWasAvailable
=
false
;
bool
ShouldRestartOn0RttError
(
nsresult
reason
)
;
nsCOMPtr
<
nsIEarlyHintObserver
>
mEarlyHintObserver
;
nsCString
mHashKeyOfConnectionEntry
;
}
;
}
#
endif
