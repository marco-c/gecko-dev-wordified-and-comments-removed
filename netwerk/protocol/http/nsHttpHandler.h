#
ifndef
nsHttpHandler_h__
#
define
nsHttpHandler_h__
#
include
<
functional
>
#
include
"
nsHttp
.
h
"
#
include
"
nsHttpAuthCache
.
h
"
#
include
"
nsHttpConnectionMgr
.
h
"
#
include
"
AlternateServices
.
h
"
#
include
"
ASpdySession
.
h
"
#
include
"
HttpTrafficAnalyzer
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISpeculativeConnect
.
h
"
class
nsIHttpChannel
;
class
nsIPrefBranch
;
class
nsICancelable
;
class
nsICookieService
;
class
nsIProcessSwitchRequestor
;
class
nsIIOService
;
class
nsIRequestContextService
;
class
nsISiteSecurityService
;
class
nsIStreamConverterService
;
namespace
mozilla
{
namespace
net
{
bool
OnSocketThread
(
)
;
class
ATokenBucketEvent
;
class
EventTokenBucket
;
class
Tickler
;
class
nsHttpConnection
;
class
nsHttpConnectionInfo
;
class
HttpTransactionShell
;
class
AltSvcMapping
;
enum
FrameCheckLevel
{
FRAMECHECK_LAX
FRAMECHECK_BARELY
FRAMECHECK_STRICT_CHUNKED
FRAMECHECK_STRICT
}
;
class
nsHttpHandler
final
:
public
nsIHttpProtocolHandler
public
nsIObserver
public
nsSupportsWeakReference
public
nsISpeculativeConnect
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIPROTOCOLHANDLER
NS_DECL_NSIPROXIEDPROTOCOLHANDLER
NS_DECL_NSIHTTPPROTOCOLHANDLER
NS_DECL_NSIOBSERVER
NS_DECL_NSISPECULATIVECONNECT
static
already_AddRefed
<
nsHttpHandler
>
GetInstance
(
)
;
MOZ_MUST_USE
nsresult
AddStandardRequestHeaders
(
nsHttpRequestHead
*
bool
isSecure
nsContentPolicyType
aContentPolicyType
)
;
MOZ_MUST_USE
nsresult
AddConnectionHeader
(
nsHttpRequestHead
*
uint32_t
capabilities
)
;
bool
IsAcceptableEncoding
(
const
char
*
encoding
bool
isSecure
)
;
const
nsCString
&
UserAgent
(
)
;
enum
HttpVersion
HttpVersion
(
)
{
return
mHttpVersion
;
}
enum
HttpVersion
ProxyHttpVersion
(
)
{
return
mProxyHttpVersion
;
}
uint8_t
RedirectionLimit
(
)
{
return
mRedirectionLimit
;
}
PRIntervalTime
IdleTimeout
(
)
{
return
mIdleTimeout
;
}
PRIntervalTime
SpdyTimeout
(
)
{
return
mSpdyTimeout
;
}
PRIntervalTime
ResponseTimeout
(
)
{
return
mResponseTimeoutEnabled
?
mResponseTimeout
:
0
;
}
PRIntervalTime
ResponseTimeoutEnabled
(
)
{
return
mResponseTimeoutEnabled
;
}
uint32_t
NetworkChangedTimeout
(
)
{
return
mNetworkChangedTimeout
;
}
uint16_t
MaxRequestAttempts
(
)
{
return
mMaxRequestAttempts
;
}
const
nsCString
&
DefaultSocketType
(
)
{
return
mDefaultSocketType
;
}
uint32_t
PhishyUserPassLength
(
)
{
return
mPhishyUserPassLength
;
}
uint8_t
GetQoSBits
(
)
{
return
mQoSBits
;
}
uint16_t
GetIdleSynTimeout
(
)
{
return
mIdleSynTimeout
;
}
uint16_t
GetFallbackSynTimeout
(
)
{
return
mFallbackSynTimeout
;
}
bool
FastFallbackToIPv4
(
)
{
return
mFastFallbackToIPv4
;
}
uint32_t
MaxSocketCount
(
)
;
bool
EnforceAssocReq
(
)
{
return
mEnforceAssocReq
;
}
bool
IsPersistentHttpsCachingEnabled
(
)
{
return
mEnablePersistentHttpsCaching
;
}
bool
IsSpdyEnabled
(
)
{
return
mEnableSpdy
;
}
bool
IsHttp2Enabled
(
)
{
return
mHttp2Enabled
;
}
bool
EnforceHttp2TlsProfile
(
)
{
return
mEnforceHttp2TlsProfile
;
}
bool
CoalesceSpdy
(
)
{
return
mCoalesceSpdy
;
}
bool
UseSpdyPersistentSettings
(
)
{
return
mSpdyPersistentSettings
;
}
uint32_t
SpdySendingChunkSize
(
)
{
return
mSpdySendingChunkSize
;
}
uint32_t
SpdySendBufferSize
(
)
{
return
mSpdySendBufferSize
;
}
uint32_t
SpdyPushAllowance
(
)
{
return
mSpdyPushAllowance
;
}
uint32_t
SpdyPullAllowance
(
)
{
return
mSpdyPullAllowance
;
}
uint32_t
DefaultSpdyConcurrent
(
)
{
return
mDefaultSpdyConcurrent
;
}
PRIntervalTime
SpdyPingThreshold
(
)
{
return
mSpdyPingThreshold
;
}
PRIntervalTime
SpdyPingTimeout
(
)
{
return
mSpdyPingTimeout
;
}
bool
AllowPush
(
)
{
return
mAllowPush
;
}
bool
AllowAltSvc
(
)
{
return
mEnableAltSvc
;
}
bool
AllowAltSvcOE
(
)
{
return
mEnableAltSvcOE
;
}
bool
AllowOriginExtension
(
)
{
return
mEnableOriginExtension
;
}
uint32_t
ConnectTimeout
(
)
{
return
mConnectTimeout
;
}
uint32_t
TLSHandshakeTimeout
(
)
{
return
mTLSHandshakeTimeout
;
}
uint32_t
ParallelSpeculativeConnectLimit
(
)
{
return
mParallelSpeculativeConnectLimit
;
}
bool
CriticalRequestPrioritization
(
)
{
return
mCriticalRequestPrioritization
;
}
bool
IsDocumentNosniffEnabled
(
)
{
return
mRespectDocumentNoSniff
;
}
bool
UseH2Deps
(
)
{
return
mUseH2Deps
;
}
bool
IsH2WebsocketsEnabled
(
)
{
return
mEnableH2Websockets
;
}
uint32_t
MaxConnectionsPerOrigin
(
)
{
return
mMaxPersistentConnectionsPerServer
;
}
bool
UseRequestTokenBucket
(
)
{
return
mRequestTokenBucketEnabled
;
}
uint16_t
RequestTokenBucketMinParallelism
(
)
{
return
mRequestTokenBucketMinParallelism
;
}
uint32_t
RequestTokenBucketHz
(
)
{
return
mRequestTokenBucketHz
;
}
uint32_t
RequestTokenBucketBurst
(
)
{
return
mRequestTokenBucketBurst
;
}
bool
PromptTempRedirect
(
)
{
return
mPromptTempRedirect
;
}
bool
IsUrgentStartEnabled
(
)
{
return
mUrgentStartEnabled
;
}
bool
IsTailBlockingEnabled
(
)
{
return
mTailBlockingEnabled
;
}
uint32_t
TailBlockingDelayQuantum
(
bool
aAfterDOMContentLoaded
)
{
return
aAfterDOMContentLoaded
?
mTailDelayQuantumAfterDCL
:
mTailDelayQuantum
;
}
uint32_t
TailBlockingDelayMax
(
)
{
return
mTailDelayMax
;
}
uint32_t
TailBlockingTotalMax
(
)
{
return
mTailTotalMax
;
}
uint32_t
ThrottlingReadLimit
(
)
{
return
mThrottleVersion
=
=
1
?
0
:
mThrottleReadLimit
;
}
int32_t
SendWindowSize
(
)
{
return
mSendWindowSize
*
1024
;
}
bool
TCPKeepaliveEnabledForShortLivedConns
(
)
{
return
mTCPKeepaliveShortLivedEnabled
;
}
int32_t
GetTCPKeepaliveShortLivedTime
(
)
{
return
mTCPKeepaliveShortLivedTimeS
;
}
int32_t
GetTCPKeepaliveShortLivedIdleTime
(
)
{
return
mTCPKeepaliveShortLivedIdleTimeS
;
}
bool
TCPKeepaliveEnabledForLongLivedConns
(
)
{
return
mTCPKeepaliveLongLivedEnabled
;
}
int32_t
GetTCPKeepaliveLongLivedIdleTime
(
)
{
return
mTCPKeepaliveLongLivedIdleTimeS
;
}
bool
UseFastOpen
(
)
{
return
mUseFastOpen
&
&
mFastOpenSupported
&
&
(
mFastOpenStallsCounter
<
mFastOpenStallsLimit
)
&
&
(
mFastOpenConsecutiveFailureCounter
<
mFastOpenConsecutiveFailureLimit
)
;
}
void
SetFastOpenNotSupported
(
)
{
mFastOpenSupported
=
false
;
}
void
IncrementFastOpenConsecutiveFailureCounter
(
)
;
void
ResetFastOpenConsecutiveFailureCounter
(
)
{
mFastOpenConsecutiveFailureCounter
=
0
;
}
void
IncrementFastOpenStallsCounter
(
)
;
uint32_t
CheckIfConnectionIsStalledOnlyIfIdleForThisAmountOfSeconds
(
)
{
return
mFastOpenStallsIdleTime
;
}
uint32_t
FastOpenStallsTimeout
(
)
{
return
mFastOpenStallsTimeout
;
}
FrameCheckLevel
GetEnforceH1Framing
(
)
{
return
mEnforceH1Framing
;
}
nsHttpAuthCache
*
AuthCache
(
bool
aPrivate
)
{
return
aPrivate
?
&
mPrivateAuthCache
:
&
mAuthCache
;
}
nsHttpConnectionMgr
*
ConnMgr
(
)
{
return
mConnMgr
-
>
AsHttpConnectionMgr
(
)
;
}
AltSvcCache
*
AltServiceCache
(
)
const
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
mAltSvcCache
.
get
(
)
;
}
uint32_t
GenerateUniqueID
(
)
{
return
+
+
mLastUniqueID
;
}
uint32_t
SessionStartTime
(
)
{
return
mSessionStartTime
;
}
MOZ_MUST_USE
nsresult
InitiateTransaction
(
HttpTransactionShell
*
trans
int32_t
priority
)
;
MOZ_MUST_USE
nsresult
InitiateTransactionWithStickyConn
(
HttpTransactionShell
*
trans
int32_t
priority
HttpTransactionShell
*
transWithStickyConn
)
;
MOZ_MUST_USE
nsresult
RescheduleTransaction
(
HttpTransactionShell
*
trans
int32_t
priority
)
;
void
UpdateClassOfServiceOnTransaction
(
HttpTransactionShell
*
trans
uint32_t
classOfService
)
;
MOZ_MUST_USE
nsresult
CancelTransaction
(
HttpTransactionShell
*
trans
nsresult
reason
)
;
MOZ_MUST_USE
nsresult
ReclaimConnection
(
nsHttpConnection
*
conn
)
{
return
mConnMgr
-
>
ReclaimConnection
(
conn
)
;
}
MOZ_MUST_USE
nsresult
ProcessPendingQ
(
nsHttpConnectionInfo
*
cinfo
)
{
return
mConnMgr
-
>
ProcessPendingQ
(
cinfo
)
;
}
MOZ_MUST_USE
nsresult
ProcessPendingQ
(
)
{
return
mConnMgr
-
>
ProcessPendingQ
(
)
;
}
MOZ_MUST_USE
nsresult
GetSocketThreadTarget
(
nsIEventTarget
*
*
target
)
{
return
mConnMgr
-
>
GetSocketThreadTarget
(
target
)
;
}
MOZ_MUST_USE
nsresult
SpeculativeConnect
(
nsHttpConnectionInfo
*
ci
nsIInterfaceRequestor
*
callbacks
uint32_t
caps
=
0
)
{
TickleWifi
(
callbacks
)
;
RefPtr
<
nsHttpConnectionInfo
>
clone
=
ci
-
>
Clone
(
)
;
return
mConnMgr
-
>
SpeculativeConnect
(
clone
callbacks
caps
)
;
}
void
UpdateAltServiceMapping
(
AltSvcMapping
*
map
nsProxyInfo
*
proxyInfo
nsIInterfaceRequestor
*
callbacks
uint32_t
caps
const
OriginAttributes
&
originAttributes
)
{
mAltSvcCache
-
>
UpdateAltServiceMapping
(
map
proxyInfo
callbacks
caps
originAttributes
)
;
}
already_AddRefed
<
AltSvcMapping
>
GetAltServiceMapping
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
bool
pb
bool
isolated
const
nsACString
&
topWindowOrigin
const
OriginAttributes
&
originAttributes
)
{
return
mAltSvcCache
-
>
GetAltServiceMapping
(
scheme
host
port
pb
isolated
topWindowOrigin
originAttributes
)
;
}
MOZ_MUST_USE
nsresult
GetStreamConverterService
(
nsIStreamConverterService
*
*
)
;
MOZ_MUST_USE
nsresult
GetIOService
(
nsIIOService
*
*
service
)
;
nsICookieService
*
GetCookieService
(
)
;
nsISiteSecurityService
*
GetSSService
(
)
;
uint32_t
Get32BitsOfPseudoRandom
(
)
;
void
OnFailedOpeningRequest
(
nsIHttpChannel
*
chan
)
{
NotifyObservers
(
chan
NS_HTTP_ON_FAILED_OPENING_REQUEST_TOPIC
)
;
}
void
OnOpeningRequest
(
nsIHttpChannel
*
chan
)
{
NotifyObservers
(
chan
NS_HTTP_ON_OPENING_REQUEST_TOPIC
)
;
}
void
OnOpeningDocumentRequest
(
nsIIdentChannel
*
chan
)
{
NotifyObservers
(
chan
NS_DOCUMENT_ON_OPENING_REQUEST_TOPIC
)
;
}
void
OnModifyRequest
(
nsIHttpChannel
*
chan
)
{
NotifyObservers
(
chan
NS_HTTP_ON_MODIFY_REQUEST_TOPIC
)
;
}
void
OnStopRequest
(
nsIHttpChannel
*
chan
)
{
NotifyObservers
(
chan
NS_HTTP_ON_STOP_REQUEST_TOPIC
)
;
}
void
OnBeforeConnect
(
nsIHttpChannel
*
chan
)
{
NotifyObservers
(
chan
NS_HTTP_ON_BEFORE_CONNECT_TOPIC
)
;
}
void
OnExamineResponse
(
nsIHttpChannel
*
chan
)
{
NotifyObservers
(
chan
NS_HTTP_ON_EXAMINE_RESPONSE_TOPIC
)
;
}
void
OnExamineMergedResponse
(
nsIHttpChannel
*
chan
)
{
NotifyObservers
(
chan
NS_HTTP_ON_EXAMINE_MERGED_RESPONSE_TOPIC
)
;
}
void
OnBackgroundRevalidation
(
nsIHttpChannel
*
chan
)
{
NotifyObservers
(
chan
NS_HTTP_ON_BACKGROUND_REVALIDATION
)
;
}
MOZ_MUST_USE
nsresult
AsyncOnChannelRedirect
(
nsIChannel
*
oldChan
nsIChannel
*
newChan
uint32_t
flags
nsIEventTarget
*
mainThreadEventTarget
=
nullptr
)
;
void
OnExamineCachedResponse
(
nsIHttpChannel
*
chan
)
{
NotifyObservers
(
chan
NS_HTTP_ON_EXAMINE_CACHED_RESPONSE_TOPIC
)
;
}
static
MOZ_MUST_USE
nsresult
GenerateHostPort
(
const
nsCString
&
host
int32_t
port
nsACString
&
hostLine
)
;
SpdyInformation
*
SpdyInfo
(
)
{
return
&
mSpdyInfo
;
}
bool
IsH2MandatorySuiteEnabled
(
)
{
return
mH2MandatorySuiteEnabled
;
}
bool
Active
(
)
{
return
mHandlerActive
;
}
nsIRequestContextService
*
GetRequestContextService
(
)
{
return
mRequestContextService
.
get
(
)
;
}
void
ShutdownConnectionManager
(
)
;
uint32_t
DefaultHpackBuffer
(
)
const
{
return
mDefaultHpackBuffer
;
}
bool
Bug1563538
(
)
const
{
return
mBug1563538
;
}
bool
Bug1563695
(
)
const
{
return
mBug1563695
;
}
bool
Bug1556491
(
)
const
{
return
mBug1556491
;
}
bool
IsHttp3VersionSupportedHex
(
const
nsACString
&
version
)
;
nsCString
Http3Version
(
)
{
return
kHttp3Version
;
}
bool
IsHttp3Enabled
(
)
const
{
return
mHttp3Enabled
;
}
uint32_t
DefaultQpackTableSize
(
)
const
{
return
mQpackTableSize
;
}
uint16_t
DefaultHttp3MaxBlockedStreams
(
)
const
{
return
(
uint16_t
)
mHttp3MaxBlockedStreams
;
}
uint32_t
MaxHttpResponseHeaderSize
(
)
const
{
return
mMaxHttpResponseHeaderSize
;
}
float
FocusedWindowTransactionRatio
(
)
const
{
return
mFocusedWindowTransactionRatio
;
}
bool
ActiveTabPriority
(
)
const
{
return
mActiveTabPriority
;
}
void
NotifyActiveTabLoadOptimization
(
)
;
TimeStamp
const
GetLastActiveTabLoadOptimizationHit
(
)
;
void
SetLastActiveTabLoadOptimizationHit
(
TimeStamp
const
&
when
)
;
bool
IsBeforeLastActiveTabLoadOptimization
(
TimeStamp
const
&
when
)
;
bool
DumpHpackTables
(
)
{
return
mDumpHpackTables
;
}
HttpTrafficAnalyzer
*
GetHttpTrafficAnalyzer
(
)
;
bool
GetThroughCaptivePortal
(
)
{
return
mThroughCaptivePortal
;
}
private
:
nsHttpHandler
(
)
;
virtual
~
nsHttpHandler
(
)
;
MOZ_MUST_USE
nsresult
Init
(
)
;
void
BuildUserAgent
(
)
;
void
InitUserAgentComponents
(
)
;
static
void
PrefsChanged
(
const
char
*
pref
void
*
self
)
;
void
PrefsChanged
(
const
char
*
pref
)
;
MOZ_MUST_USE
nsresult
SetAcceptLanguages
(
)
;
MOZ_MUST_USE
nsresult
SetAcceptEncodings
(
const
char
*
bool
mIsSecure
)
;
MOZ_MUST_USE
nsresult
InitConnectionMgr
(
)
;
void
NotifyObservers
(
nsIChannel
*
chan
const
char
*
event
)
;
void
SetFastOpenOSSupport
(
)
;
void
MaybeEnableSpeculativeConnect
(
)
;
private
:
nsMainThreadPtrHandle
<
nsIIOService
>
mIOService
;
nsMainThreadPtrHandle
<
nsIStreamConverterService
>
mStreamConvSvc
;
nsMainThreadPtrHandle
<
nsICookieService
>
mCookieService
;
nsMainThreadPtrHandle
<
nsISiteSecurityService
>
mSSService
;
nsHttpAuthCache
mAuthCache
;
nsHttpAuthCache
mPrivateAuthCache
;
RefPtr
<
HttpConnectionMgrShell
>
mConnMgr
;
UniquePtr
<
AltSvcCache
>
mAltSvcCache
;
enum
HttpVersion
mHttpVersion
;
enum
HttpVersion
mProxyHttpVersion
;
uint32_t
mCapabilities
;
bool
mFastFallbackToIPv4
;
PRIntervalTime
mIdleTimeout
;
PRIntervalTime
mSpdyTimeout
;
PRIntervalTime
mResponseTimeout
;
bool
mResponseTimeoutEnabled
;
uint32_t
mNetworkChangedTimeout
;
uint16_t
mMaxRequestAttempts
;
uint16_t
mMaxRequestDelay
;
uint16_t
mIdleSynTimeout
;
uint16_t
mFallbackSynTimeout
;
bool
mH2MandatorySuiteEnabled
;
uint16_t
mMaxUrgentExcessiveConns
;
uint16_t
mMaxConnections
;
uint8_t
mMaxPersistentConnectionsPerServer
;
uint8_t
mMaxPersistentConnectionsPerProxy
;
bool
mThrottleEnabled
;
uint32_t
mThrottleVersion
;
uint32_t
mThrottleSuspendFor
;
uint32_t
mThrottleResumeFor
;
uint32_t
mThrottleReadLimit
;
uint32_t
mThrottleReadInterval
;
uint32_t
mThrottleHoldTime
;
uint32_t
mThrottleMaxTime
;
int32_t
mSendWindowSize
;
bool
mUrgentStartEnabled
;
bool
mTailBlockingEnabled
;
uint32_t
mTailDelayQuantum
;
uint32_t
mTailDelayQuantumAfterDCL
;
uint32_t
mTailDelayMax
;
uint32_t
mTailTotalMax
;
uint8_t
mRedirectionLimit
;
bool
mBeConservativeForProxy
;
uint8_t
mPhishyUserPassLength
;
uint8_t
mQoSBits
;
bool
mEnforceAssocReq
;
nsCString
mAcceptLanguages
;
nsCString
mHttpAcceptEncodings
;
nsCString
mHttpsAcceptEncodings
;
nsCString
mDefaultSocketType
;
uint32_t
mLastUniqueID
;
uint32_t
mSessionStartTime
;
nsCString
mLegacyAppName
;
nsCString
mLegacyAppVersion
;
nsCString
mPlatform
;
nsCString
mOscpu
;
nsCString
mMisc
;
nsCString
mProduct
;
nsCString
mProductSub
;
nsCString
mAppName
;
nsCString
mAppVersion
;
nsCString
mCompatFirefox
;
bool
mCompatFirefoxEnabled
;
nsCString
mCompatDevice
;
nsCString
mDeviceModelId
;
nsCString
mUserAgent
;
nsCString
mSpoofedUserAgent
;
nsCString
mUserAgentOverride
;
bool
mUserAgentIsDirty
;
bool
mAcceptLanguagesIsDirty
;
bool
mPromptTempRedirect
;
bool
mEnablePersistentHttpsCaching
;
bool
mSafeHintEnabled
;
bool
mParentalControlEnabled
;
Atomic
<
bool
Relaxed
>
mHandlerActive
;
uint32_t
mDebugObservations
:
1
;
uint32_t
mEnableSpdy
:
1
;
uint32_t
mHttp2Enabled
:
1
;
uint32_t
mUseH2Deps
:
1
;
uint32_t
mEnforceHttp2TlsProfile
:
1
;
uint32_t
mCoalesceSpdy
:
1
;
uint32_t
mSpdyPersistentSettings
:
1
;
uint32_t
mAllowPush
:
1
;
uint32_t
mEnableAltSvc
:
1
;
uint32_t
mEnableAltSvcOE
:
1
;
uint32_t
mEnableOriginExtension
:
1
;
uint32_t
mEnableH2Websockets
:
1
;
uint32_t
mDumpHpackTables
:
1
;
SpdyInformation
mSpdyInfo
;
uint32_t
mSpdySendingChunkSize
;
uint32_t
mSpdySendBufferSize
;
uint32_t
mSpdyPushAllowance
;
uint32_t
mSpdyPullAllowance
;
uint32_t
mDefaultSpdyConcurrent
;
PRIntervalTime
mSpdyPingThreshold
;
PRIntervalTime
mSpdyPingTimeout
;
uint32_t
mConnectTimeout
;
uint32_t
mTLSHandshakeTimeout
;
uint32_t
mParallelSpeculativeConnectLimit
;
bool
mRequestTokenBucketEnabled
;
uint16_t
mRequestTokenBucketMinParallelism
;
uint32_t
mRequestTokenBucketHz
;
uint32_t
mRequestTokenBucketBurst
;
bool
mCriticalRequestPrioritization
;
bool
mRespectDocumentNoSniff
;
bool
mTCPKeepaliveShortLivedEnabled
;
int32_t
mTCPKeepaliveShortLivedTimeS
;
int32_t
mTCPKeepaliveShortLivedIdleTimeS
;
bool
mTCPKeepaliveLongLivedEnabled
;
int32_t
mTCPKeepaliveLongLivedIdleTimeS
;
FrameCheckLevel
mEnforceH1Framing
;
nsCOMPtr
<
nsIRequestContextService
>
mRequestContextService
;
uint32_t
mDefaultHpackBuffer
;
Atomic
<
bool
Relaxed
>
mBug1563538
;
Atomic
<
bool
Relaxed
>
mBug1563695
;
Atomic
<
bool
Relaxed
>
mBug1556491
;
Atomic
<
bool
Relaxed
>
mHttp3Enabled
;
Atomic
<
uint32_t
Relaxed
>
mQpackTableSize
;
Atomic
<
uint32_t
Relaxed
>
mHttp3MaxBlockedStreams
;
uint32_t
mMaxHttpResponseHeaderSize
;
float
mFocusedWindowTransactionRatio
;
Atomic
<
bool
Relaxed
>
mSpeculativeConnectEnabled
;
Atomic
<
bool
Relaxed
>
mUseFastOpen
;
Atomic
<
bool
Relaxed
>
mFastOpenSupported
;
uint32_t
mFastOpenConsecutiveFailureLimit
;
uint32_t
mFastOpenConsecutiveFailureCounter
;
uint32_t
mFastOpenStallsLimit
;
uint32_t
mFastOpenStallsCounter
;
uint32_t
mFastOpenStallsIdleTime
;
uint32_t
mFastOpenStallsTimeout
;
bool
mActiveTabPriority
;
HttpTrafficAnalyzer
mHttpTrafficAnalyzer
;
private
:
void
MakeNewRequestTokenBucket
(
)
;
RefPtr
<
EventTokenBucket
>
mRequestTokenBucket
;
public
:
MOZ_MUST_USE
nsresult
SubmitPacedRequest
(
ATokenBucketEvent
*
event
nsICancelable
*
*
cancel
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
!
mRequestTokenBucket
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
mRequestTokenBucket
-
>
SubmitEvent
(
event
cancel
)
;
}
void
SetRequestTokenBucket
(
EventTokenBucket
*
aTokenBucket
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
mRequestTokenBucket
=
aTokenBucket
;
}
void
StopRequestTokenBucket
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
mRequestTokenBucket
)
{
mRequestTokenBucket
-
>
Stop
(
)
;
mRequestTokenBucket
=
nullptr
;
}
}
private
:
RefPtr
<
Tickler
>
mWifiTickler
;
void
TickleWifi
(
nsIInterfaceRequestor
*
cb
)
;
private
:
MOZ_MUST_USE
nsresult
SpeculativeConnectInternal
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIInterfaceRequestor
*
aCallbacks
bool
anonymous
)
;
uint32_t
mProcessId
;
uint32_t
mNextChannelId
;
Mutex
mLastActiveTabLoadOptimizationLock
;
TimeStamp
mLastActiveTabLoadOptimizationHit
;
Mutex
mSpdyBlacklistLock
;
public
:
MOZ_MUST_USE
nsresult
NewChannelId
(
uint64_t
&
channelId
)
;
void
BlacklistSpdy
(
const
nsHttpConnectionInfo
*
ci
)
;
MOZ_MUST_USE
bool
IsSpdyBlacklisted
(
const
nsHttpConnectionInfo
*
ci
)
;
private
:
nsTHashtable
<
nsCStringHashKey
>
mBlacklistedSpdyOrigins
;
bool
mThroughCaptivePortal
;
}
;
extern
StaticRefPtr
<
nsHttpHandler
>
gHttpHandler
;
class
nsHttpsHandler
:
public
nsIHttpProtocolHandler
public
nsSupportsWeakReference
public
nsISpeculativeConnect
{
virtual
~
nsHttpsHandler
(
)
=
default
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIPROTOCOLHANDLER
NS_FORWARD_NSIPROXIEDPROTOCOLHANDLER
(
gHttpHandler
-
>
)
NS_FORWARD_NSIHTTPPROTOCOLHANDLER
(
gHttpHandler
-
>
)
NS_FORWARD_NSISPECULATIVECONNECT
(
gHttpHandler
-
>
)
nsHttpsHandler
(
)
=
default
;
MOZ_MUST_USE
nsresult
Init
(
)
;
}
;
class
HSTSDataCallbackWrapper
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
HSTSDataCallbackWrapper
)
explicit
HSTSDataCallbackWrapper
(
std
:
:
function
<
void
(
bool
)
>
&
&
aCallback
)
:
mCallback
(
std
:
:
move
(
aCallback
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
DoCallback
(
bool
aResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mCallback
(
aResult
)
;
}
private
:
~
HSTSDataCallbackWrapper
(
)
=
default
;
std
:
:
function
<
void
(
bool
)
>
mCallback
;
}
;
}
}
#
endif
