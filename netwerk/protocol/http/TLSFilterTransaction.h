#
ifndef
mozilla_net_TLSFilterTransaction_h
#
define
mozilla_net_TLSFilterTransaction_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsAHttpTransaction
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsISocketTransport
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
NullHttpTransaction
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
prio
.
h
"
struct
PRSocketOptionData
;
namespace
mozilla
{
namespace
net
{
class
nsHttpRequestHead
;
class
NullHttpTransaction
;
class
TLSFilterTransaction
;
class
NudgeTunnelCallback
:
public
nsISupports
{
public
:
virtual
nsresult
OnTunnelNudged
(
TLSFilterTransaction
*
)
=
0
;
}
;
#
define
NS_DECL_NUDGETUNNELCALLBACK
\
nsresult
OnTunnelNudged
(
TLSFilterTransaction
*
)
override
;
class
TLSFilterTransaction
final
:
public
nsAHttpTransaction
public
nsAHttpSegmentReader
public
nsAHttpSegmentWriter
public
nsITimerCallback
public
nsINamed
{
~
TLSFilterTransaction
(
)
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSAHTTPTRANSACTION
NS_DECL_NSAHTTPSEGMENTREADER
NS_DECL_NSAHTTPSEGMENTWRITER
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
TLSFilterTransaction
(
nsAHttpTransaction
*
aWrappedTransaction
const
char
*
tlsHost
int32_t
tlsPort
nsAHttpSegmentReader
*
reader
nsAHttpSegmentWriter
*
writer
)
;
const
nsAHttpTransaction
*
Transaction
(
)
const
{
return
mTransaction
.
get
(
)
;
}
[
[
nodiscard
]
]
nsresult
CommitToSegmentSize
(
uint32_t
size
bool
forceCommitment
)
override
;
[
[
nodiscard
]
]
nsresult
GetTransactionSecurityInfo
(
nsISupports
*
*
)
override
;
[
[
nodiscard
]
]
nsresult
NudgeTunnel
(
NudgeTunnelCallback
*
callback
)
;
[
[
nodiscard
]
]
nsresult
SetProxiedTransaction
(
nsAHttpTransaction
*
aTrans
nsAHttpTransaction
*
aHttp2ConnectTransaction
=
nullptr
)
;
void
newIODriver
(
nsIAsyncInputStream
*
aSocketIn
nsIAsyncOutputStream
*
aSocketOut
nsIAsyncInputStream
*
*
outSocketIn
nsIAsyncOutputStream
*
*
outSocketOut
)
;
bool
IsNullTransaction
(
)
override
;
NullHttpTransaction
*
QueryNullTransaction
(
)
override
;
nsHttpTransaction
*
QueryHttpTransaction
(
)
override
;
Http2ConnectTransaction
*
QueryHttp2ConnectTransaction
(
)
override
;
[
[
nodiscard
]
]
nsresult
WriteSegmentsAgain
(
nsAHttpSegmentWriter
*
writer
uint32_t
count
uint32_t
*
countWritten
bool
*
again
)
override
;
bool
HasDataToRecv
(
)
;
private
:
[
[
nodiscard
]
]
nsresult
StartTimerCallback
(
)
;
void
Cleanup
(
)
;
int32_t
FilterOutput
(
const
char
*
aBuf
int32_t
aAmount
)
;
int32_t
FilterInput
(
char
*
aBuf
int32_t
aAmount
)
;
static
PRStatus
GetPeerName
(
PRFileDesc
*
fd
PRNetAddr
*
addr
)
;
static
PRStatus
GetSocketOption
(
PRFileDesc
*
fd
PRSocketOptionData
*
aOpt
)
;
static
PRStatus
SetSocketOption
(
PRFileDesc
*
fd
const
PRSocketOptionData
*
data
)
;
static
int32_t
FilterWrite
(
PRFileDesc
*
fd
const
void
*
buf
int32_t
amount
)
;
static
int32_t
FilterRead
(
PRFileDesc
*
fd
void
*
buf
int32_t
amount
)
;
static
int32_t
FilterSend
(
PRFileDesc
*
fd
const
void
*
buf
int32_t
amount
int
flags
PRIntervalTime
timeout
)
;
static
int32_t
FilterRecv
(
PRFileDesc
*
fd
void
*
buf
int32_t
amount
int
flags
PRIntervalTime
timeout
)
;
static
PRStatus
FilterClose
(
PRFileDesc
*
fd
)
;
private
:
RefPtr
<
nsAHttpTransaction
>
mTransaction
;
nsWeakPtr
mWeakTrans
;
nsCOMPtr
<
nsISupports
>
mSecInfo
;
nsCOMPtr
<
nsITimer
>
mTimer
;
RefPtr
<
NudgeTunnelCallback
>
mNudgeCallback
;
UniquePtr
<
char
[
]
>
mEncryptedText
;
uint32_t
mEncryptedTextUsed
;
uint32_t
mEncryptedTextSize
;
PRFileDesc
*
mFD
;
nsAHttpSegmentReader
*
mSegmentReader
;
nsAHttpSegmentWriter
*
mSegmentWriter
;
nsresult
mFilterReadCode
;
int32_t
mFilterReadAmount
;
bool
mInOnReadSegment
;
bool
mForce
;
nsresult
mReadSegmentReturnValue
;
nsresult
mCloseReason
;
uint32_t
mNudgeCounter
;
}
;
}
}
#
endif
