#
include
"
HttpLog
.
h
"
#
include
"
HttpBackgroundChannelChild
.
h
"
#
include
"
HttpChannelChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsSocketTransportService2
.
h
"
using
mozilla
:
:
ipc
:
:
BackgroundChild
;
using
mozilla
:
:
ipc
:
:
IPCResult
;
namespace
mozilla
{
namespace
net
{
HttpBackgroundChannelChild
:
:
HttpBackgroundChannelChild
(
)
=
default
;
HttpBackgroundChannelChild
:
:
~
HttpBackgroundChannelChild
(
)
=
default
;
nsresult
HttpBackgroundChannelChild
:
:
Init
(
HttpChannelChild
*
aChannelChild
)
{
LOG
(
(
"
HttpBackgroundChannelChild
:
:
Init
[
this
=
%
p
httpChannel
=
%
p
"
"
channelId
=
%
"
PRIu64
"
]
\
n
"
this
aChannelChild
aChannelChild
-
>
ChannelId
(
)
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
NS_ENSURE_ARG
(
aChannelChild
)
;
mChannelChild
=
aChannelChild
;
if
(
NS_WARN_IF
(
!
CreateBackgroundChannel
(
)
)
)
{
mChannelChild
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
HttpBackgroundChannelChild
:
:
OnChannelClosed
(
)
{
LOG
(
(
"
HttpBackgroundChannelChild
:
:
OnChannelClosed
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
mChannelChild
=
nullptr
;
mQueuedRunnables
.
Clear
(
)
;
}
void
HttpBackgroundChannelChild
:
:
OnStartRequestReceived
(
)
{
LOG
(
(
"
HttpBackgroundChannelChild
:
:
OnStartRequestReceived
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
MOZ_ASSERT
(
mChannelChild
)
;
MOZ_ASSERT
(
!
mStartReceived
)
;
mStartReceived
=
true
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
runnables
;
runnables
.
SwapElements
(
mQueuedRunnables
)
;
for
(
const
auto
&
event
:
runnables
)
{
event
-
>
Run
(
)
;
}
MOZ_ASSERT
(
mQueuedRunnables
.
IsEmpty
(
)
)
;
}
bool
HttpBackgroundChannelChild
:
:
CreateBackgroundChannel
(
)
{
LOG
(
(
"
HttpBackgroundChannelChild
:
:
CreateBackgroundChannel
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
MOZ_ASSERT
(
mChannelChild
)
;
PBackgroundChild
*
actorChild
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
actorChild
)
)
{
return
false
;
}
const
uint64_t
channelId
=
mChannelChild
-
>
ChannelId
(
)
;
if
(
!
actorChild
-
>
SendPHttpBackgroundChannelConstructor
(
this
channelId
)
)
{
return
false
;
}
mChannelChild
-
>
OnBackgroundChildReady
(
this
)
;
return
true
;
}
bool
HttpBackgroundChannelChild
:
:
IsWaitingOnStartRequest
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
return
(
mStartSent
&
&
!
mStartReceived
)
;
}
IPCResult
HttpBackgroundChannelChild
:
:
RecvOnStartRequestSent
(
)
{
LOG
(
(
"
HttpBackgroundChannelChild
:
:
RecvOnStartRequestSent
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
MOZ_ASSERT
(
!
mStartSent
)
;
mStartSent
=
true
;
return
IPC_OK
(
)
;
}
IPCResult
HttpBackgroundChannelChild
:
:
RecvOnTransportAndData
(
const
nsresult
&
aChannelStatus
const
nsresult
&
aTransportStatus
const
uint64_t
&
aOffset
const
uint32_t
&
aCount
const
nsCString
&
aData
)
{
LOG
(
(
"
HttpBackgroundChannelChild
:
:
RecvOnTransportAndData
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
if
(
NS_WARN_IF
(
!
mChannelChild
)
)
{
return
IPC_OK
(
)
;
}
if
(
IsWaitingOnStartRequest
(
)
)
{
LOG
(
(
"
>
pending
until
OnStartRequest
[
offset
=
%
"
PRIu64
"
count
=
%
"
PRIu32
"
]
\
n
"
aOffset
aCount
)
)
;
mQueuedRunnables
.
AppendElement
(
NewRunnableMethod
<
const
nsresult
const
nsresult
const
uint64_t
const
uint32_t
const
nsCString
>
(
"
HttpBackgroundChannelChild
:
:
RecvOnTransportAndData
"
this
&
HttpBackgroundChannelChild
:
:
RecvOnTransportAndData
aChannelStatus
aTransportStatus
aOffset
aCount
aData
)
)
;
return
IPC_OK
(
)
;
}
mChannelChild
-
>
ProcessOnTransportAndData
(
aChannelStatus
aTransportStatus
aOffset
aCount
aData
)
;
return
IPC_OK
(
)
;
}
IPCResult
HttpBackgroundChannelChild
:
:
RecvOnStopRequest
(
const
nsresult
&
aChannelStatus
const
ResourceTimingStruct
&
aTiming
const
TimeStamp
&
aLastActiveTabOptHit
const
nsHttpHeaderArray
&
aResponseTrailers
)
{
LOG
(
(
"
HttpBackgroundChannelChild
:
:
RecvOnStopRequest
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
gSocketTransportService
)
;
MOZ_ASSERT
(
gSocketTransportService
-
>
IsOnCurrentThreadInfallible
(
)
)
;
nsHttp
:
:
SetLastActiveTabLoadOptimizationHit
(
aLastActiveTabOptHit
)
;
if
(
NS_WARN_IF
(
!
mChannelChild
)
)
{
return
IPC_OK
(
)
;
}
if
(
IsWaitingOnStartRequest
(
)
)
{
LOG
(
(
"
>
pending
until
OnStartRequest
[
status
=
%
"
PRIx32
"
]
\
n
"
static_cast
<
uint32_t
>
(
aChannelStatus
)
)
)
;
mQueuedRunnables
.
AppendElement
(
NewRunnableMethod
<
const
nsresult
const
ResourceTimingStruct
const
TimeStamp
const
nsHttpHeaderArray
>
(
"
HttpBackgroundChannelChild
:
:
RecvOnStopRequest
"
this
&
HttpBackgroundChannelChild
:
:
RecvOnStopRequest
aChannelStatus
aTiming
aLastActiveTabOptHit
aResponseTrailers
)
)
;
return
IPC_OK
(
)
;
}
mChannelChild
-
>
ProcessOnStopRequest
(
aChannelStatus
aTiming
aResponseTrailers
)
;
return
IPC_OK
(
)
;
}
IPCResult
HttpBackgroundChannelChild
:
:
RecvFlushedForDiversion
(
)
{
LOG
(
(
"
HttpBackgroundChannelChild
:
:
RecvFlushedForDiversion
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
if
(
NS_WARN_IF
(
!
mChannelChild
)
)
{
return
IPC_OK
(
)
;
}
if
(
IsWaitingOnStartRequest
(
)
)
{
LOG
(
(
"
>
pending
until
OnStartRequest
\
n
"
)
)
;
mQueuedRunnables
.
AppendElement
(
NewRunnableMethod
(
"
HttpBackgroundChannelChild
:
:
RecvFlushedForDiversion
"
this
&
HttpBackgroundChannelChild
:
:
RecvFlushedForDiversion
)
)
;
return
IPC_OK
(
)
;
}
mChannelChild
-
>
ProcessFlushedForDiversion
(
)
;
return
IPC_OK
(
)
;
}
IPCResult
HttpBackgroundChannelChild
:
:
RecvDivertMessages
(
)
{
LOG
(
(
"
HttpBackgroundChannelChild
:
:
RecvDivertMessages
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
if
(
NS_WARN_IF
(
!
mChannelChild
)
)
{
return
IPC_OK
(
)
;
}
if
(
IsWaitingOnStartRequest
(
)
)
{
LOG
(
(
"
>
pending
until
OnStartRequest
\
n
"
)
)
;
mQueuedRunnables
.
AppendElement
(
NewRunnableMethod
(
"
HttpBackgroundChannelChild
:
:
RecvDivertMessages
"
this
&
HttpBackgroundChannelChild
:
:
RecvDivertMessages
)
)
;
return
IPC_OK
(
)
;
}
mChannelChild
-
>
ProcessDivertMessages
(
)
;
return
IPC_OK
(
)
;
}
void
HttpBackgroundChannelChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
LOG
(
(
"
HttpBackgroundChannelChild
:
:
ActorDestroy
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
gSocketTransportService
)
;
MOZ_ASSERT
(
gSocketTransportService
-
>
IsOnCurrentThreadInfallible
(
)
)
;
if
(
aWhy
=
=
Deletion
&
&
!
mQueuedRunnables
.
IsEmpty
(
)
)
{
LOG
(
(
"
>
pending
until
queued
messages
are
flushed
\
n
"
)
)
;
RefPtr
<
HttpBackgroundChannelChild
>
self
=
this
;
mQueuedRunnables
.
AppendElement
(
NS_NewRunnableFunction
(
"
HttpBackgroundChannelChild
:
:
ActorDestroy
"
[
self
]
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
RefPtr
<
HttpChannelChild
>
channelChild
=
self
-
>
mChannelChild
.
forget
(
)
;
if
(
channelChild
)
{
channelChild
-
>
OnBackgroundChildDestroyed
(
self
)
;
}
}
)
)
;
return
;
}
if
(
mChannelChild
)
{
RefPtr
<
HttpChannelChild
>
channelChild
=
mChannelChild
.
forget
(
)
;
channelChild
-
>
OnBackgroundChildDestroyed
(
this
)
;
}
}
}
}
