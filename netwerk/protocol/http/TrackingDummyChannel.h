#
ifndef
mozilla_net_TrackingDummyChannel_h
#
define
mozilla_net_TrackingDummyChannel_h
#
include
"
nsIChannel
.
h
"
#
include
<
functional
>
#
define
TRACKING_DUMMY_CHANNEL_IID
\
{
\
0x70ceb97d
0xbfa6
0x4255
{
\
0xb7
0x08
0xe1
0xb4
0x4a
0x1e
0x0e
0x9a
\
}
\
}
class
nsIChannel
;
namespace
mozilla
{
namespace
net
{
class
TrackingDummyChannel
final
:
public
nsIChannel
public
nsIHttpChannelInternal
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
TRACKING_DUMMY_CHANNEL_IID
)
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIREQUEST
NS_DECL_NSICHANNEL
NS_DECL_NSIHTTPCHANNELINTERNAL
enum
StorageAllowedState
{
eStorageGranted
eStorageDenied
eAsyncNeeded
}
;
static
StorageAllowedState
StorageAllowed
(
nsIChannel
*
aChannel
const
std
:
:
function
<
void
(
bool
)
>
&
aCallback
)
;
TrackingDummyChannel
(
nsIURI
*
aURI
nsIURI
*
aTopWindowURI
nsresult
aTopWindowURIResult
nsILoadInfo
*
aLoadInfo
)
;
bool
IsTrackingResource
(
)
const
;
void
SetIsTrackingResource
(
)
;
private
:
~
TrackingDummyChannel
(
)
;
nsCOMPtr
<
nsILoadInfo
>
mLoadInfo
;
nsCOMPtr
<
nsIURI
>
mURI
;
nsCOMPtr
<
nsIURI
>
mTopWindowURI
;
nsresult
mTopWindowURIResult
;
bool
mIsTrackingResource
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
TrackingDummyChannel
TRACKING_DUMMY_CHANNEL_IID
)
}
}
#
endif
