#
ifndef
mozilla_net_HttpChannelChild_h
#
define
mozilla_net_HttpChannelChild_h
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
net
/
HttpBaseChannel
.
h
"
#
include
"
mozilla
/
net
/
NeckoTargetHolder
.
h
"
#
include
"
mozilla
/
net
/
PHttpChannelChild
.
h
"
#
include
"
mozilla
/
net
/
ChannelEventQueue
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIProgressEventSink
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsIApplicationCache
.
h
"
#
include
"
nsIApplicationCacheChannel
.
h
"
#
include
"
nsIUploadChannel2
.
h
"
#
include
"
nsIResumableChannel
.
h
"
#
include
"
nsIProxiedChannel
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIChildChannel
.
h
"
#
include
"
nsIHttpChannelChild
.
h
"
#
include
"
nsIDivertableChannel
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
using
mozilla
:
:
Telemetry
:
:
LABELS_HTTP_CHILD_OMT_STATS
;
class
nsIEventTarget
;
class
nsInputStreamPump
;
class
nsIInterceptedBodyCallback
;
#
define
HTTP_CHANNEL_CHILD_IID
\
{
\
0x321bd99e
0x2242
0x4dc6
{
\
0xbb
0xec
0xd5
0x06
0x29
0x7c
0x39
0x83
\
}
\
}
namespace
mozilla
{
namespace
net
{
class
HttpBackgroundChannelChild
;
class
InterceptedChannelContent
;
class
InterceptStreamListener
;
class
SyntheticDiversionListener
;
class
HttpChannelChild
final
:
public
PHttpChannelChild
public
HttpBaseChannel
public
HttpAsyncAborter
<
HttpChannelChild
>
public
nsICacheInfoChannel
public
nsIProxiedChannel
public
nsIApplicationCacheChannel
public
nsIAsyncVerifyRedirectCallback
public
nsIChildChannel
public
nsIHttpChannelChild
public
nsIDivertableChannel
public
nsIThreadRetargetableRequest
public
NeckoTargetHolder
{
virtual
~
HttpChannelChild
(
)
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSICACHEINFOCHANNEL
NS_DECL_NSIPROXIEDCHANNEL
NS_DECL_NSIAPPLICATIONCACHECONTAINER
NS_DECL_NSIAPPLICATIONCACHECHANNEL
NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
NS_DECL_NSICHILDCHANNEL
NS_DECL_NSIHTTPCHANNELCHILD
NS_DECL_NSIDIVERTABLECHANNEL
NS_DECL_NSITHREADRETARGETABLEREQUEST
NS_DECLARE_STATIC_IID_ACCESSOR
(
HTTP_CHANNEL_CHILD_IID
)
HttpChannelChild
(
)
;
NS_IMETHOD
Cancel
(
nsresult
status
)
override
;
NS_IMETHOD
Suspend
(
)
override
;
NS_IMETHOD
Resume
(
)
override
;
NS_IMETHOD
GetSecurityInfo
(
nsISupports
*
*
aSecurityInfo
)
override
;
NS_IMETHOD
AsyncOpen
(
nsIStreamListener
*
listener
nsISupports
*
aContext
)
override
;
NS_IMETHOD
AsyncOpen2
(
nsIStreamListener
*
aListener
)
override
;
NS_IMETHOD
SetReferrerWithPolicy
(
nsIURI
*
referrer
uint32_t
referrerPolicy
)
override
;
NS_IMETHOD
SetRequestHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
bool
aMerge
)
override
;
NS_IMETHOD
SetEmptyRequestHeader
(
const
nsACString
&
aHeader
)
override
;
NS_IMETHOD
RedirectTo
(
nsIURI
*
newURI
)
override
;
NS_IMETHOD
UpgradeToSecure
(
)
override
;
NS_IMETHOD
GetProtocolVersion
(
nsACString
&
aProtocolVersion
)
override
;
NS_IMETHOD
SetupFallbackChannel
(
const
char
*
aFallbackKey
)
override
;
NS_IMETHOD
SetPriority
(
int32_t
value
)
override
;
NS_IMETHOD
SetClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
AddClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
ClearClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
ResumeAt
(
uint64_t
startPos
const
nsACString
&
entityID
)
override
;
void
AddIPDLReference
(
)
;
void
ReleaseIPDLReference
(
)
;
MOZ_MUST_USE
bool
IsSuspended
(
)
;
void
FlushedForDiversion
(
)
;
void
OnCopyComplete
(
nsresult
aStatus
)
override
;
void
OnBackgroundChildReady
(
HttpBackgroundChannelChild
*
aBgChild
)
;
void
OnBackgroundChildDestroyed
(
HttpBackgroundChannelChild
*
aBgChild
)
;
nsresult
CrossProcessRedirectFinished
(
nsresult
aStatus
)
;
protected
:
mozilla
:
:
ipc
:
:
IPCResult
RecvOnStartRequest
(
const
nsresult
&
channelStatus
const
nsHttpResponseHead
&
responseHead
const
bool
&
useResponseHead
const
nsHttpHeaderArray
&
requestHeaders
const
ParentLoadInfoForwarderArgs
&
loadInfoForwarder
const
bool
&
isFromCache
const
bool
&
cacheEntryAvailable
const
uint64_t
&
cacheEntryId
const
int32_t
&
cacheFetchCount
const
uint32_t
&
cacheExpirationTime
const
nsCString
&
cachedCharset
const
nsCString
&
securityInfoSerialization
const
NetAddr
&
selfAddr
const
NetAddr
&
peerAddr
const
int16_t
&
redirectCount
const
uint32_t
&
cacheKey
const
nsCString
&
altDataType
const
int64_t
&
altDataLen
const
bool
&
aApplyConversion
const
ResourceTimingStruct
&
aTiming
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvFailedAsyncOpen
(
const
nsresult
&
status
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvRedirect1Begin
(
const
uint32_t
&
registrarId
const
URIParams
&
newURI
const
uint32_t
&
newLoadFlags
const
uint32_t
&
redirectFlags
const
ParentLoadInfoForwarderArgs
&
loadInfoForwarder
const
nsHttpResponseHead
&
responseHead
const
nsCString
&
securityInfoSerialization
const
uint64_t
&
channelId
const
NetAddr
&
oldPeerAddr
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvRedirect3Complete
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAssociateApplicationCache
(
const
nsCString
&
groupID
const
nsCString
&
clientID
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvDeleteSelf
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvFinishInterceptedRedirect
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvReportSecurityMessage
(
const
nsString
&
messageTag
const
nsString
&
messageCategory
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvIssueDeprecationWarning
(
const
uint32_t
&
warning
const
bool
&
asError
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvSetPriority
(
const
int16_t
&
aPriority
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAttachStreamFilter
(
Endpoint
<
extensions
:
:
PStreamFilterParent
>
&
&
aEndpoint
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvCancelDiversion
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvCancelRedirected
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvOriginalCacheInputStreamAvailable
(
const
OptionalIPCStream
&
aStream
)
override
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
virtual
void
DoNotifyListenerCleanup
(
)
override
;
virtual
void
DoAsyncAbort
(
nsresult
aStatus
)
override
;
nsresult
AsyncCall
(
void
(
HttpChannelChild
:
:
*
funcPtr
)
(
)
nsRunnableMethod
<
HttpChannelChild
>
*
*
retval
=
nullptr
)
override
{
return
AsyncCallImpl
(
funcPtr
retval
)
;
}
;
already_AddRefed
<
nsIEventTarget
>
GetNeckoTarget
(
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvLogBlockedCORSRequest
(
const
nsString
&
aMessage
const
nsCString
&
aCategory
)
override
;
NS_IMETHOD
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvLogMimeTypeMismatch
(
const
nsCString
&
aMessageName
const
bool
&
aWarning
const
nsString
&
aURL
const
nsString
&
aContentType
)
override
;
NS_IMETHOD
LogMimeTypeMismatch
(
const
nsACString
&
aMessageName
bool
aWarning
const
nsAString
&
aURL
const
nsAString
&
aContentType
)
override
;
private
:
nsresult
AsyncCallImpl
(
void
(
HttpChannelChild
:
:
*
funcPtr
)
(
)
nsRunnableMethod
<
HttpChannelChild
>
*
*
retval
)
;
class
OverrideRunnable
:
public
Runnable
{
public
:
OverrideRunnable
(
HttpChannelChild
*
aChannel
HttpChannelChild
*
aNewChannel
InterceptStreamListener
*
aListener
nsIInputStream
*
aInput
nsIInterceptedBodyCallback
*
aCallback
nsAutoPtr
<
nsHttpResponseHead
>
&
aHead
nsICacheInfoChannel
*
aCacheInfo
)
;
NS_IMETHOD
Run
(
)
override
;
void
OverrideWithSynthesizedResponse
(
)
;
private
:
RefPtr
<
HttpChannelChild
>
mChannel
;
RefPtr
<
HttpChannelChild
>
mNewChannel
;
RefPtr
<
InterceptStreamListener
>
mListener
;
nsCOMPtr
<
nsIInputStream
>
mInput
;
nsCOMPtr
<
nsIInterceptedBodyCallback
>
mCallback
;
nsAutoPtr
<
nsHttpResponseHead
>
mHead
;
nsCOMPtr
<
nsICacheInfoChannel
>
mSynthesizedCacheInfo
;
}
;
void
SetEventTarget
(
)
;
already_AddRefed
<
nsIEventTarget
>
GetODATarget
(
)
;
MOZ_MUST_USE
nsresult
ContinueAsyncOpen
(
)
;
void
ProcessOnTransportAndData
(
const
nsresult
&
aChannelStatus
const
nsresult
&
aStatus
const
uint64_t
&
aOffset
const
uint32_t
&
aCount
const
nsCString
&
aData
)
;
void
ProcessOnStopRequest
(
const
nsresult
&
aStatusCode
const
ResourceTimingStruct
&
aTiming
const
nsHttpHeaderArray
&
aResponseTrailers
)
;
void
ProcessOnProgress
(
const
int64_t
&
aProgress
const
int64_t
&
aProgressMax
)
;
void
ProcessOnStatus
(
const
nsresult
&
aStatus
)
;
void
ProcessFlushedForDiversion
(
)
;
void
ProcessDivertMessages
(
)
;
void
ProcessNotifyChannelClassifierProtectionDisabled
(
uint32_t
aAcceptedReason
)
;
void
ProcessNotifyCookieAllowed
(
)
;
void
ProcessNotifyCookieBlocked
(
uint32_t
aRejectedReason
)
;
void
ProcessNotifyTrackingResource
(
bool
aIsThirdParty
)
;
void
ProcessNotifyFlashPluginStateChanged
(
nsIHttpChannel
:
:
FlashPluginState
aState
)
;
void
ProcessSetClassifierMatchedInfo
(
const
nsCString
&
aList
const
nsCString
&
aProvider
const
nsCString
&
aFullHash
)
;
bool
NeedToReportBytesRead
(
)
;
int32_t
mUnreportBytesRead
=
0
;
void
DoOnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
;
void
DoOnStatus
(
nsIRequest
*
aRequest
nsresult
status
)
;
void
DoOnProgress
(
nsIRequest
*
aRequest
int64_t
progress
int64_t
progressMax
)
;
void
DoOnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aStream
uint64_t
offset
uint32_t
count
)
;
void
DoPreOnStopRequest
(
nsresult
aStatus
)
;
void
DoOnStopRequest
(
nsIRequest
*
aRequest
nsresult
aChannelStatus
nsISupports
*
aContext
)
;
bool
ShouldInterceptURI
(
nsIURI
*
aURI
bool
&
aShouldUpgrade
)
;
void
ResetInterception
(
)
;
void
OverrideWithSynthesizedResponse
(
nsAutoPtr
<
nsHttpResponseHead
>
&
aResponseHead
nsIInputStream
*
aSynthesizedInput
nsIInterceptedBodyCallback
*
aSynthesizedCallback
InterceptStreamListener
*
aStreamListener
nsICacheInfoChannel
*
aCacheInfoChannel
)
;
void
ForceIntercepted
(
nsIInputStream
*
aSynthesizedInput
nsIInterceptedBodyCallback
*
aSynthesizedCallback
nsICacheInfoChannel
*
aCacheInfo
)
;
void
TrySendDeletingChannel
(
)
;
void
CancelOnMainThread
(
nsresult
aRv
)
;
void
MaybeCallSynthesizedCallback
(
)
;
private
:
nsCOMPtr
<
nsIChildChannel
>
mRedirectChannelChild
;
RefPtr
<
InterceptStreamListener
>
mInterceptListener
;
nsCOMPtr
<
nsIStreamListener
>
mInterceptedRedirectListener
;
nsCOMPtr
<
nsISupports
>
mInterceptedRedirectContext
;
void
ReleaseMainThreadOnlyReferences
(
)
;
private
:
nsCString
mCachedCharset
;
nsCString
mProtocolVersion
;
RequestHeaderTuples
mClientSetRequestHeaders
;
RefPtr
<
nsInputStreamPump
>
mSynthesizedResponsePump
;
nsCOMPtr
<
nsIInputStream
>
mSynthesizedInput
;
nsCOMPtr
<
nsIInterceptedBodyCallback
>
mSynthesizedCallback
;
nsCOMPtr
<
nsICacheInfoChannel
>
mSynthesizedCacheInfo
;
RefPtr
<
ChannelEventQueue
>
mEventQ
;
nsCOMPtr
<
nsIInputStreamReceiver
>
mInputStreamReceiver
;
Mutex
mBgChildMutex
;
RefPtr
<
HttpBackgroundChannelChild
>
mBgChild
;
nsCOMPtr
<
nsIRunnable
>
mBgInitFailCallback
;
void
CleanupBackgroundChannel
(
)
;
RefPtr
<
HttpChannelChild
>
mInterceptingChannel
;
RefPtr
<
OverrideRunnable
>
mOverrideRunnable
;
nsCOMPtr
<
nsIEventTarget
>
mODATarget
;
Mutex
mEventTargetMutex
;
nsTArray
<
UniquePtr
<
ChannelEvent
>
>
mUnknownDecoderEventQ
;
TimeStamp
mLastStatusReported
;
int64_t
mSynthesizedStreamLength
;
uint64_t
mCacheEntryId
;
LABELS_HTTP_CHILD_OMT_STATS
mOMTResult
=
LABELS_HTTP_CHILD_OMT_STATS
:
:
notRequested
;
uint32_t
mCacheKey
;
int32_t
mCacheFetchCount
;
uint32_t
mCacheExpirationTime
;
Atomic
<
bool
>
mDeletingChannelSent
;
Atomic
<
bool
>
mIPCOpen
;
Atomic
<
bool
ReleaseAcquire
>
mUnknownDecoderInvolved
;
Atomic
<
bool
ReleaseAcquire
>
mDivertingToParent
;
Atomic
<
bool
ReleaseAcquire
>
mFlushedForDiversion
;
Atomic
<
bool
SequentiallyConsistent
>
mIsFromCache
;
Atomic
<
bool
SequentiallyConsistent
>
mCacheNeedToReportBytesReadInitialized
;
Atomic
<
bool
SequentiallyConsistent
>
mNeedToReportBytesRead
;
uint8_t
mCacheEntryAvailable
:
1
;
uint8_t
mAltDataCacheEntryAvailable
:
1
;
uint8_t
mSendResumeAt
:
1
;
uint8_t
mKeptAlive
:
1
;
uint8_t
mSuspendSent
:
1
;
uint8_t
mSynthesizedResponse
:
1
;
uint8_t
mShouldInterceptSubsequentRedirect
:
1
;
uint8_t
mRedirectingForSubsequentSynthesizedResponse
:
1
;
uint8_t
mPostRedirectChannelShouldIntercept
:
1
;
uint8_t
mPostRedirectChannelShouldUpgrade
:
1
;
uint8_t
mShouldParentIntercept
:
1
;
uint8_t
mSuspendParentAfterSynthesizeResponse
:
1
;
void
FinishInterceptedRedirect
(
)
;
void
CleanupRedirectingChannel
(
nsresult
rv
)
;
bool
RemoteChannelExists
(
)
{
return
mIPCOpen
&
&
!
mKeptAlive
;
}
void
AssociateApplicationCache
(
const
nsCString
&
groupID
const
nsCString
&
clientID
)
;
void
OnStartRequest
(
const
nsresult
&
channelStatus
const
nsHttpResponseHead
&
responseHead
const
bool
&
useResponseHead
const
nsHttpHeaderArray
&
requestHeaders
const
ParentLoadInfoForwarderArgs
&
loadInfoForwarder
const
bool
&
isFromCache
const
bool
&
cacheEntryAvailable
const
uint64_t
&
cacheEntryId
const
int32_t
&
cacheFetchCount
const
uint32_t
&
cacheExpirationTime
const
nsCString
&
cachedCharset
const
nsCString
&
securityInfoSerialization
const
NetAddr
&
selfAddr
const
NetAddr
&
peerAddr
const
uint32_t
&
cacheKey
const
nsCString
&
altDataType
const
int64_t
&
altDataLen
const
bool
&
aApplyConversion
const
ResourceTimingStruct
&
aTiming
)
;
void
MaybeDivertOnData
(
const
nsCString
&
data
const
uint64_t
&
offset
const
uint32_t
&
count
)
;
void
OnTransportAndData
(
const
nsresult
&
channelStatus
const
nsresult
&
status
const
uint64_t
&
offset
const
uint32_t
&
count
const
nsCString
&
data
)
;
void
OnStopRequest
(
const
nsresult
&
channelStatus
const
ResourceTimingStruct
&
timing
const
nsHttpHeaderArray
&
aResponseTrailers
)
;
void
MaybeDivertOnStop
(
const
nsresult
&
aChannelStatus
)
;
void
OnProgress
(
const
int64_t
&
progress
const
int64_t
&
progressMax
)
;
void
OnStatus
(
const
nsresult
&
status
)
;
void
FailedAsyncOpen
(
const
nsresult
&
status
)
;
void
HandleAsyncAbort
(
)
;
void
Redirect1Begin
(
const
uint32_t
&
registrarId
const
URIParams
&
newUri
const
uint32_t
&
newLoadFlags
const
uint32_t
&
redirectFlags
const
ParentLoadInfoForwarderArgs
&
loadInfoForwarder
const
nsHttpResponseHead
&
responseHead
const
nsACString
&
securityInfoSerialization
const
uint64_t
&
channelId
)
;
bool
Redirect3Complete
(
OverrideRunnable
*
aRunnable
)
;
void
DeleteSelf
(
)
;
MOZ_MUST_USE
nsresult
SetupRedirect
(
nsIURI
*
uri
const
nsHttpResponseHead
*
responseHead
const
uint32_t
&
redirectFlags
nsIChannel
*
*
outChannel
)
;
void
BeginNonIPCRedirect
(
nsIURI
*
responseURI
const
nsHttpResponseHead
*
responseHead
bool
responseRedirected
)
;
void
OverrideSecurityInfoForNonIPCRedirect
(
nsISupports
*
securityInfo
)
;
void
CollectOMTTelemetry
(
)
;
friend
class
AssociateApplicationCacheEvent
;
friend
class
StartRequestEvent
;
friend
class
StopRequestEvent
;
friend
class
TransportAndDataEvent
;
friend
class
MaybeDivertOnDataHttpEvent
;
friend
class
MaybeDivertOnStopHttpEvent
;
friend
class
ProgressEvent
;
friend
class
StatusEvent
;
friend
class
FailedAsyncOpenEvent
;
friend
class
Redirect1Event
;
friend
class
Redirect3Event
;
friend
class
DeleteSelfEvent
;
friend
class
HttpFlushedForDiversionEvent
;
friend
class
CancelEvent
;
friend
class
HttpAsyncAborter
<
HttpChannelChild
>
;
friend
class
InterceptStreamListener
;
friend
class
InterceptedChannelContent
;
friend
class
SyntheticDiversionListener
;
friend
class
HttpBackgroundChannelChild
;
friend
class
NeckoTargetChannelEvent
<
HttpChannelChild
>
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
HttpChannelChild
HTTP_CHANNEL_CHILD_IID
)
class
InterceptStreamListener
:
public
nsIStreamListener
public
nsIProgressEventSink
{
RefPtr
<
HttpChannelChild
>
mOwner
;
nsCOMPtr
<
nsISupports
>
mContext
;
virtual
~
InterceptStreamListener
(
)
=
default
;
public
:
InterceptStreamListener
(
HttpChannelChild
*
aOwner
nsISupports
*
aContext
)
:
mOwner
(
aOwner
)
mContext
(
aContext
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIPROGRESSEVENTSINK
void
Cleanup
(
)
;
}
;
inline
bool
HttpChannelChild
:
:
IsSuspended
(
)
{
return
mSuspendCount
!
=
0
;
}
}
}
#
endif
