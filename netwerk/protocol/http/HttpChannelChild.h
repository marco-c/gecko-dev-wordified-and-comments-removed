#
ifndef
mozilla_net_HttpChannelChild_h
#
define
mozilla_net_HttpChannelChild_h
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
extensions
/
StreamFilterParent
.
h
"
#
include
"
mozilla
/
net
/
HttpBaseChannel
.
h
"
#
include
"
mozilla
/
net
/
NeckoTargetHolder
.
h
"
#
include
"
mozilla
/
net
/
PHttpChannelChild
.
h
"
#
include
"
mozilla
/
net
/
ChannelEventQueue
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIProgressEventSink
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsIResumableChannel
.
h
"
#
include
"
nsIProxiedChannel
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIChildChannel
.
h
"
#
include
"
nsIHttpChannelChild
.
h
"
#
include
"
nsIMultiPartChannel
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
using
mozilla
:
:
Telemetry
:
:
LABELS_HTTP_CHILD_OMT_STATS
;
class
nsIEventTarget
;
class
nsInputStreamPump
;
class
nsISerialEventTarget
;
class
nsIInterceptedBodyCallback
;
#
define
HTTP_CHANNEL_CHILD_IID
\
{
\
0x321bd99e
0x2242
0x4dc6
{
\
0xbb
0xec
0xd5
0x06
0x29
0x7c
0x39
0x83
\
}
\
}
namespace
mozilla
{
namespace
net
{
class
HttpBackgroundChannelChild
;
class
HttpChannelChild
final
:
public
PHttpChannelChild
public
HttpBaseChannel
public
HttpAsyncAborter
<
HttpChannelChild
>
public
nsICacheInfoChannel
public
nsIProxiedChannel
public
nsIAsyncVerifyRedirectCallback
public
nsIChildChannel
public
nsIHttpChannelChild
public
nsIMultiPartChannel
public
nsIThreadRetargetableRequest
public
NeckoTargetHolder
{
virtual
~
HttpChannelChild
(
)
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSICACHEINFOCHANNEL
NS_DECL_NSIPROXIEDCHANNEL
NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
NS_DECL_NSICHILDCHANNEL
NS_DECL_NSIHTTPCHANNELCHILD
NS_DECL_NSIMULTIPARTCHANNEL
NS_DECL_NSITHREADRETARGETABLEREQUEST
NS_DECLARE_STATIC_IID_ACCESSOR
(
HTTP_CHANNEL_CHILD_IID
)
HttpChannelChild
(
)
;
NS_IMETHOD
Cancel
(
nsresult
status
)
override
;
NS_IMETHOD
Suspend
(
)
override
;
NS_IMETHOD
Resume
(
)
override
;
NS_IMETHOD
GetSecurityInfo
(
nsISupports
*
*
aSecurityInfo
)
override
;
NS_IMETHOD
AsyncOpen
(
nsIStreamListener
*
aListener
)
override
;
NS_IMETHOD
SetRequestHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
bool
aMerge
)
override
;
NS_IMETHOD
SetEmptyRequestHeader
(
const
nsACString
&
aHeader
)
override
;
NS_IMETHOD
RedirectTo
(
nsIURI
*
newURI
)
override
;
NS_IMETHOD
UpgradeToSecure
(
)
override
;
NS_IMETHOD
GetProtocolVersion
(
nsACString
&
aProtocolVersion
)
override
;
void
DoDiagnosticAssertWhenOnStopNotCalledOnDestroy
(
)
override
;
NS_IMETHOD
GetIsAuthChannel
(
bool
*
aIsAuthChannel
)
override
;
NS_IMETHOD
SetEarlyHintObserver
(
nsIEarlyHintObserver
*
aObserver
)
override
;
NS_IMETHOD
SetPriority
(
int32_t
value
)
override
;
NS_IMETHOD
SetClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
AddClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
ClearClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
ResumeAt
(
uint64_t
startPos
const
nsACString
&
entityID
)
override
;
nsresult
SetReferrerHeader
(
const
nsACString
&
aReferrer
bool
aRespectBeforeConnect
)
override
;
[
[
nodiscard
]
]
bool
IsSuspended
(
)
;
void
OnCopyComplete
(
nsresult
aStatus
)
override
;
void
OnBackgroundChildReady
(
HttpBackgroundChannelChild
*
aBgChild
)
;
void
OnBackgroundChildDestroyed
(
HttpBackgroundChannelChild
*
aBgChild
)
;
nsresult
CrossProcessRedirectFinished
(
nsresult
aStatus
)
;
protected
:
mozilla
:
:
ipc
:
:
IPCResult
RecvOnStartRequestSent
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvFailedAsyncOpen
(
const
nsresult
&
status
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvRedirect1Begin
(
const
uint32_t
&
registrarId
const
URIParams
&
newURI
const
uint32_t
&
newLoadFlags
const
uint32_t
&
redirectFlags
const
ParentLoadInfoForwarderArgs
&
loadInfoForwarder
const
nsHttpResponseHead
&
responseHead
const
nsCString
&
securityInfoSerialization
const
uint64_t
&
channelId
const
NetAddr
&
oldPeerAddr
const
ResourceTimingStructArgs
&
aTiming
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvRedirect3Complete
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvDeleteSelf
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvReportSecurityMessage
(
const
nsString
&
messageTag
const
nsString
&
messageCategory
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvSetPriority
(
const
int16_t
&
aPriority
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvOriginalCacheInputStreamAvailable
(
const
Maybe
<
IPCStream
>
&
aStream
)
override
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
virtual
void
DoNotifyListenerCleanup
(
)
override
;
virtual
void
DoAsyncAbort
(
nsresult
aStatus
)
override
;
nsresult
AsyncCall
(
void
(
HttpChannelChild
:
:
*
funcPtr
)
(
)
nsRunnableMethod
<
HttpChannelChild
>
*
*
retval
=
nullptr
)
override
{
return
AsyncCallImpl
(
funcPtr
retval
)
;
}
;
already_AddRefed
<
nsISerialEventTarget
>
GetNeckoTarget
(
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvLogBlockedCORSRequest
(
const
nsString
&
aMessage
const
nsCString
&
aCategory
)
override
;
NS_IMETHOD
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvLogMimeTypeMismatch
(
const
nsCString
&
aMessageName
const
bool
&
aWarning
const
nsString
&
aURL
const
nsString
&
aContentType
)
override
;
NS_IMETHOD
LogMimeTypeMismatch
(
const
nsACString
&
aMessageName
bool
aWarning
const
nsAString
&
aURL
const
nsAString
&
aContentType
)
override
;
private
:
nsresult
AsyncOpenInternal
(
nsIStreamListener
*
aListener
)
;
nsresult
AsyncCallImpl
(
void
(
HttpChannelChild
:
:
*
funcPtr
)
(
)
nsRunnableMethod
<
HttpChannelChild
>
*
*
retval
)
;
void
SetEventTarget
(
)
;
already_AddRefed
<
nsIEventTarget
>
GetODATarget
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueAsyncOpen
(
)
;
void
ProcessOnStartRequest
(
const
nsHttpResponseHead
&
aResponseHead
const
bool
&
aUseResponseHead
const
nsHttpHeaderArray
&
aRequestHeaders
const
HttpChannelOnStartRequestArgs
&
aArgs
const
HttpChannelAltDataStream
&
aAltData
)
;
void
ProcessOnTransportAndData
(
const
nsresult
&
aChannelStatus
const
nsresult
&
aTransportStatus
const
uint64_t
&
aOffset
const
uint32_t
&
aCount
const
nsCString
&
aData
)
;
void
ProcessOnStopRequest
(
const
nsresult
&
aChannelStatus
const
ResourceTimingStructArgs
&
aTiming
const
nsHttpHeaderArray
&
aResponseTrailers
nsTArray
<
ConsoleReportCollected
>
&
&
aConsoleReports
bool
aFromSocketProcess
)
;
void
ProcessOnConsoleReport
(
nsTArray
<
ConsoleReportCollected
>
&
&
aConsoleReports
)
;
void
ProcessNotifyClassificationFlags
(
uint32_t
aClassificationFlags
bool
aIsThirdParty
)
;
void
ProcessNotifyFlashPluginStateChanged
(
nsIHttpChannel
:
:
FlashPluginState
aState
)
;
void
ProcessSetClassifierMatchedInfo
(
const
nsCString
&
aList
const
nsCString
&
aProvider
const
nsCString
&
aFullHash
)
;
void
ProcessSetClassifierMatchedTrackingInfo
(
const
nsCString
&
aLists
const
nsCString
&
aFullHashes
)
;
void
ProcessOnAfterLastPart
(
const
nsresult
&
aStatus
)
;
void
ProcessOnProgress
(
const
int64_t
&
aProgress
const
int64_t
&
aProgressMax
)
;
void
ProcessOnStatus
(
const
nsresult
&
aStatus
)
;
void
ProcessAttachStreamFilter
(
Endpoint
<
extensions
:
:
PStreamFilterParent
>
&
&
aEndpoint
)
;
bool
NeedToReportBytesRead
(
)
;
int32_t
mUnreportBytesRead
=
0
;
void
DoOnConsoleReport
(
nsTArray
<
ConsoleReportCollected
>
&
&
aConsoleReports
)
;
void
DoOnStartRequest
(
nsIRequest
*
aRequest
)
;
void
DoOnStatus
(
nsIRequest
*
aRequest
nsresult
status
)
;
void
DoOnProgress
(
nsIRequest
*
aRequest
int64_t
progress
int64_t
progressMax
)
;
void
DoOnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aStream
uint64_t
offset
uint32_t
count
)
;
void
DoPreOnStopRequest
(
nsresult
aStatus
)
;
void
DoOnStopRequest
(
nsIRequest
*
aRequest
nsresult
aChannelStatus
)
;
void
ContinueOnStopRequest
(
)
;
void
TrySendDeletingChannel
(
)
;
void
CancelOnMainThread
(
nsresult
aRv
)
;
nsresult
MaybeLogCOEPError
(
nsresult
aStatus
)
;
private
:
nsCOMPtr
<
nsIChildChannel
>
mRedirectChannelChild
;
void
ReleaseMainThreadOnlyReferences
(
)
;
private
:
nsCString
mProtocolVersion
;
RequestHeaderTuples
mClientSetRequestHeaders
;
RefPtr
<
ChannelEventQueue
>
mEventQ
;
nsCOMPtr
<
nsIInputStreamReceiver
>
mOriginalInputStreamReceiver
;
nsCOMPtr
<
nsIInputStream
>
mAltDataInputStream
;
Mutex
mBgChildMutex
MOZ_UNANNOTATED
{
"
HttpChannelChild
:
:
BgChildMutex
"
}
;
RefPtr
<
HttpBackgroundChannelChild
>
mBgChild
;
nsCOMPtr
<
nsIRunnable
>
mBgInitFailCallback
;
void
CleanupBackgroundChannel
(
)
;
nsCOMPtr
<
nsIEventTarget
>
mODATarget
;
Mutex
mEventTargetMutex
MOZ_UNANNOTATED
{
"
HttpChannelChild
:
:
EventTargetMutex
"
}
;
TimeStamp
mLastStatusReported
;
uint64_t
mCacheEntryId
{
0
}
;
LABELS_HTTP_CHILD_OMT_STATS
mOMTResult
=
LABELS_HTTP_CHILD_OMT_STATS
:
:
notRequested
;
uint32_t
mCacheKey
{
0
}
;
int32_t
mCacheFetchCount
{
0
}
;
uint32_t
mCacheExpirationTime
{
static_cast
<
uint32_t
>
(
nsICacheEntry
:
:
NO_EXPIRATION_TIME
)
}
;
Maybe
<
uint32_t
>
mMultiPartID
;
Atomic
<
bool
>
mDeletingChannelSent
{
false
}
;
Atomic
<
bool
SequentiallyConsistent
>
mIsFromCache
{
false
}
;
Atomic
<
bool
SequentiallyConsistent
>
mIsRacing
{
false
}
;
Atomic
<
bool
SequentiallyConsistent
>
mCacheNeedToReportBytesReadInitialized
{
false
}
;
Atomic
<
bool
SequentiallyConsistent
>
mNeedToReportBytesRead
{
true
}
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
bool
mDoDiagnosticAssertWhenOnStopNotCalledOnDestroy
=
false
;
bool
mAsyncOpenSucceeded
=
false
;
bool
mSuccesfullyRedirected
=
false
;
bool
mRemoteChannelExistedAtCancel
=
false
;
bool
mEverHadBgChildAtAsyncOpen
=
false
;
bool
mEverHadBgChildAtConnectParent
=
false
;
bool
mCreateBackgroundChannelFailed
=
false
;
bool
mBgInitFailCallbackTriggered
=
false
;
bool
mCanSendAtCancel
=
false
;
enum
BckChildQueueStatus
{
BCKCHILD_UNKNOWN
BCKCHILD_EMPTY
BCKCHILD_NON_EMPTY
}
;
Atomic
<
BckChildQueueStatus
>
mBackgroundChildQueueFinalState
{
BCKCHILD_UNKNOWN
}
;
Maybe
<
ActorDestroyReason
>
mActorDestroyReason
;
#
endif
uint8_t
mCacheEntryAvailable
:
1
;
uint8_t
mAltDataCacheEntryAvailable
:
1
;
uint8_t
mSendResumeAt
:
1
;
uint8_t
mKeptAlive
:
1
;
uint8_t
mIPCActorDeleted
:
1
;
uint8_t
mSuspendSent
:
1
;
uint8_t
mIsFirstPartOfMultiPart
:
1
;
uint8_t
mIsLastPartOfMultiPart
:
1
;
uint8_t
mSuspendForWaitCompleteRedirectSetup
:
1
;
uint8_t
mRecvOnStartRequestSentCalled
:
1
;
uint8_t
mSuspendedByWaitingForPermissionCookie
:
1
;
void
CleanupRedirectingChannel
(
nsresult
rv
)
;
void
NotifyOrReleaseListeners
(
nsresult
rv
)
;
bool
RemoteChannelExists
(
)
{
return
CanSend
(
)
&
&
!
mKeptAlive
;
}
void
OnStartRequest
(
const
nsHttpResponseHead
&
aResponseHead
const
bool
&
aUseResponseHead
const
nsHttpHeaderArray
&
aRequestHeaders
const
HttpChannelOnStartRequestArgs
&
aArgs
)
;
void
OnTransportAndData
(
const
nsresult
&
channelStatus
const
nsresult
&
status
const
uint64_t
&
offset
const
uint32_t
&
count
const
nsCString
&
data
)
;
void
OnStopRequest
(
const
nsresult
&
channelStatus
const
ResourceTimingStructArgs
&
timing
const
nsHttpHeaderArray
&
aResponseTrailers
)
;
void
FailedAsyncOpen
(
const
nsresult
&
status
)
;
void
HandleAsyncAbort
(
)
;
void
Redirect1Begin
(
const
uint32_t
&
registrarId
const
URIParams
&
newOriginalURI
const
uint32_t
&
newLoadFlags
const
uint32_t
&
redirectFlags
const
ParentLoadInfoForwarderArgs
&
loadInfoForwarder
const
nsHttpResponseHead
&
responseHead
const
nsACString
&
securityInfoSerialization
const
uint64_t
&
channelId
const
ResourceTimingStructArgs
&
timing
)
;
void
Redirect3Complete
(
)
;
void
DeleteSelf
(
)
;
void
DoNotifyListener
(
)
;
void
ContinueDoNotifyListener
(
)
;
void
OnAfterLastPart
(
const
nsresult
&
aStatus
)
;
void
MaybeConnectToSocketProcess
(
)
;
[
[
nodiscard
]
]
nsresult
SetupRedirect
(
nsIURI
*
uri
const
nsHttpResponseHead
*
responseHead
const
uint32_t
&
redirectFlags
nsIChannel
*
*
outChannel
)
;
void
CollectOMTTelemetry
(
)
;
friend
class
HttpAsyncAborter
<
HttpChannelChild
>
;
friend
class
InterceptStreamListener
;
friend
class
InterceptedChannelContent
;
friend
class
HttpBackgroundChannelChild
;
friend
class
NeckoTargetChannelFunctionEvent
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
HttpChannelChild
HTTP_CHANNEL_CHILD_IID
)
inline
bool
HttpChannelChild
:
:
IsSuspended
(
)
{
return
mSuspendCount
!
=
0
;
}
}
}
#
endif
