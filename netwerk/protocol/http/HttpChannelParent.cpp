#
include
"
HttpLog
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptorSetParent
.
h
"
#
include
"
mozilla
/
ipc
/
IPCStreamUtils
.
h
"
#
include
"
mozilla
/
net
/
HttpChannelParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
mozilla
/
net
/
NeckoParent
.
h
"
#
include
"
mozilla
/
InputStreamLengthHelper
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
HttpBackgroundChannelParent
.
h
"
#
include
"
HttpChannelParentListener
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsIAuthPromptProvider
.
h
"
#
include
"
mozilla
/
net
/
BackgroundChannelRegistrar
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
nsISerializable
.
h
"
#
include
"
nsIApplicationCacheService
.
h
"
#
include
"
mozilla
/
ipc
/
InputStreamUtils
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
SerializedLoadContext
.
h
"
#
include
"
nsIAuthInformation
.
h
"
#
include
"
nsIAuthPromptCallback
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
nsCORSListenerProxy
.
h
"
#
include
"
nsIIPCSerializableInputStream
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
mozilla
/
net
/
RedirectChannelRegistrar
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsISecureBrowserUI
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsIStorageStream
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsIURIClassifier
.
h
"
using
mozilla
:
:
BasePrincipal
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
{
namespace
net
{
HttpChannelParent
:
:
HttpChannelParent
(
const
PBrowserOrId
&
iframeEmbedding
nsILoadContext
*
aLoadContext
PBOverrideStatus
aOverrideStatus
)
:
mLoadContext
(
aLoadContext
)
mNestedFrameId
(
0
)
mIPCClosed
(
false
)
mPBOverride
(
aOverrideStatus
)
mStatus
(
NS_OK
)
mIgnoreProgress
(
false
)
mSentRedirect1BeginFailed
(
false
)
mReceivedRedirect2Verify
(
false
)
mHasSuspendedByBackPressure
(
false
)
mPendingDiversion
(
false
)
mDivertingFromChild
(
false
)
mDivertedOnStartRequest
(
false
)
mSuspendedForDiversion
(
false
)
mSuspendAfterSynthesizeResponse
(
false
)
mWillSynthesizeResponse
(
false
)
mCacheNeedFlowControlInitialized
(
false
)
mNeedFlowControl
(
true
)
mSuspendedForFlowControl
(
false
)
mDoingCrossProcessRedirect
(
false
)
{
LOG
(
(
"
Creating
HttpChannelParent
[
this
=
%
p
]
\
n
"
this
)
)
;
nsCOMPtr
<
nsIHttpProtocolHandler
>
dummyInitializer
=
do_GetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
http
"
)
;
MOZ_ASSERT
(
gHttpHandler
)
;
mHttpHandler
=
gHttpHandler
;
if
(
iframeEmbedding
.
type
(
)
=
=
PBrowserOrId
:
:
TPBrowserParent
)
{
mTabParent
=
static_cast
<
dom
:
:
TabParent
*
>
(
iframeEmbedding
.
get_PBrowserParent
(
)
)
;
}
else
{
mNestedFrameId
=
iframeEmbedding
.
get_TabId
(
)
;
}
mSendWindowSize
=
gHttpHandler
-
>
SendWindowSize
(
)
;
mEventQ
=
new
ChannelEventQueue
(
static_cast
<
nsIParentRedirectingChannel
*
>
(
this
)
)
;
}
HttpChannelParent
:
:
~
HttpChannelParent
(
)
{
LOG
(
(
"
Destroying
HttpChannelParent
[
this
=
%
p
]
\
n
"
this
)
)
;
CleanupBackgroundChannel
(
)
;
}
void
HttpChannelParent
:
:
ActorDestroy
(
ActorDestroyReason
why
)
{
mIPCClosed
=
true
;
if
(
mParentListener
)
{
mParentListener
-
>
ClearInterceptedChannel
(
this
)
;
}
CleanupBackgroundChannel
(
)
;
}
bool
HttpChannelParent
:
:
Init
(
const
HttpChannelCreationArgs
&
aArgs
)
{
LOG
(
(
"
HttpChannelParent
:
:
Init
[
this
=
%
p
]
\
n
"
this
)
)
;
AUTO_PROFILER_LABEL
(
"
HttpChannelParent
:
:
Init
"
NETWORK
)
;
switch
(
aArgs
.
type
(
)
)
{
case
HttpChannelCreationArgs
:
:
THttpChannelOpenArgs
:
{
const
HttpChannelOpenArgs
&
a
=
aArgs
.
get_HttpChannelOpenArgs
(
)
;
return
DoAsyncOpen
(
a
.
uri
(
)
a
.
original
(
)
a
.
doc
(
)
a
.
referrer
(
)
a
.
referrerPolicy
(
)
a
.
apiRedirectTo
(
)
a
.
topWindowURI
(
)
a
.
topWindowPrincipal
(
)
a
.
loadFlags
(
)
a
.
requestHeaders
(
)
a
.
requestMethod
(
)
a
.
uploadStream
(
)
a
.
uploadStreamHasHeaders
(
)
a
.
priority
(
)
a
.
classOfService
(
)
a
.
redirectionLimit
(
)
a
.
allowSTS
(
)
a
.
thirdPartyFlags
(
)
a
.
resumeAt
(
)
a
.
startPos
(
)
a
.
entityID
(
)
a
.
chooseApplicationCache
(
)
a
.
appCacheClientID
(
)
a
.
allowSpdy
(
)
a
.
allowAltSvc
(
)
a
.
beConservative
(
)
a
.
tlsFlags
(
)
a
.
loadInfo
(
)
a
.
synthesizedResponseHead
(
)
a
.
synthesizedSecurityInfoSerialization
(
)
a
.
cacheKey
(
)
a
.
requestContextID
(
)
a
.
preflightArgs
(
)
a
.
initialRwin
(
)
a
.
blockAuthPrompt
(
)
a
.
suspendAfterSynthesizeResponse
(
)
a
.
allowStaleCacheContent
(
)
a
.
contentTypeHint
(
)
a
.
corsMode
(
)
a
.
redirectMode
(
)
a
.
channelId
(
)
a
.
integrityMetadata
(
)
a
.
contentWindowId
(
)
a
.
preferredAlternativeTypes
(
)
a
.
topLevelOuterContentWindowId
(
)
a
.
launchServiceWorkerStart
(
)
a
.
launchServiceWorkerEnd
(
)
a
.
dispatchFetchEventStart
(
)
a
.
dispatchFetchEventEnd
(
)
a
.
handleFetchEventStart
(
)
a
.
handleFetchEventEnd
(
)
a
.
forceMainDocumentChannel
(
)
a
.
navigationStartTimeStamp
(
)
)
;
}
case
HttpChannelCreationArgs
:
:
THttpChannelConnectArgs
:
{
const
HttpChannelConnectArgs
&
cArgs
=
aArgs
.
get_HttpChannelConnectArgs
(
)
;
return
ConnectChannel
(
cArgs
.
registrarId
(
)
cArgs
.
shouldIntercept
(
)
)
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
open
type
"
)
;
return
false
;
}
}
void
HttpChannelParent
:
:
TryInvokeAsyncOpen
(
nsresult
aRv
)
{
LOG
(
(
"
HttpChannelParent
:
:
TryInvokeAsyncOpen
[
this
=
%
p
barrier
=
%
u
rv
=
%
"
PRIx32
"
]
\
n
"
this
mAsyncOpenBarrier
static_cast
<
uint32_t
>
(
aRv
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AUTO_PROFILER_LABEL
(
"
HttpChannelParent
:
:
TryInvokeAsyncOpen
"
NETWORK
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mAsyncOpenBarrier
>
0
)
;
if
(
NS_WARN_IF
(
!
mAsyncOpenBarrier
)
)
{
return
;
}
if
(
-
-
mAsyncOpenBarrier
>
0
&
&
NS_SUCCEEDED
(
aRv
)
)
{
return
;
}
InvokeAsyncOpen
(
aRv
)
;
}
void
HttpChannelParent
:
:
OnBackgroundParentReady
(
HttpBackgroundChannelParent
*
aBgParent
)
{
LOG
(
(
"
HttpChannelParent
:
:
OnBackgroundParentReady
[
this
=
%
p
bgParent
=
%
p
]
\
n
"
this
aBgParent
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mBgParent
)
;
mBgParent
=
aBgParent
;
mPromise
.
ResolveIfExists
(
true
__func__
)
;
}
void
HttpChannelParent
:
:
OnBackgroundParentDestroyed
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
OnBackgroundParentDestroyed
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mPromise
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
!
mBgParent
)
;
mPromise
.
Reject
(
NS_ERROR_FAILURE
__func__
)
;
return
;
}
if
(
!
mBgParent
)
{
return
;
}
mBgParent
=
nullptr
;
Delete
(
)
;
}
void
HttpChannelParent
:
:
CleanupBackgroundChannel
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
CleanupBackgroundChannel
[
this
=
%
p
bgParent
=
%
p
]
\
n
"
this
mBgParent
.
get
(
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mBgParent
)
{
RefPtr
<
HttpBackgroundChannelParent
>
bgParent
=
mBgParent
.
forget
(
)
;
bgParent
-
>
OnChannelClosed
(
)
;
return
;
}
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
mChannel
)
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
SetWarningReporter
(
nullptr
)
;
}
if
(
!
mPromise
.
IsEmpty
(
)
)
{
mRequest
.
DisconnectIfExists
(
)
;
mPromise
.
Reject
(
NS_ERROR_FAILURE
__func__
)
;
if
(
!
mChannel
)
{
return
;
}
nsCOMPtr
<
nsIBackgroundChannelRegistrar
>
registrar
=
BackgroundChannelRegistrar
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
registrar
)
;
registrar
-
>
DeleteChannel
(
mChannel
-
>
ChannelId
(
)
)
;
if
(
mAsyncOpenBarrier
)
{
TryInvokeAsyncOpen
(
NS_ERROR_FAILURE
)
;
}
}
}
base
:
:
ProcessId
HttpChannelParent
:
:
OtherPid
(
)
const
{
if
(
mIPCClosed
)
{
return
0
;
}
return
Manager
(
)
-
>
OtherPid
(
)
;
}
NS_IMPL_ADDREF
(
HttpChannelParent
)
NS_IMPL_RELEASE
(
HttpChannelParent
)
NS_INTERFACE_MAP_BEGIN
(
HttpChannelParent
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsIProgressEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIParentChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIAuthPromptProvider
)
NS_INTERFACE_MAP_ENTRY
(
nsIParentRedirectingChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIDeprecationWarner
)
NS_INTERFACE_MAP_ENTRY
(
nsIAsyncVerifyRedirectReadyCallback
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIParentRedirectingChannel
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
HttpChannelParent
)
NS_INTERFACE_MAP_END
NS_IMETHODIMP
HttpChannelParent
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
result
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPromptProvider
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsISecureBrowserUI
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsITabParent
)
)
)
{
if
(
mTabParent
)
{
return
mTabParent
-
>
QueryInterface
(
aIID
result
)
;
}
}
if
(
XRE_IsParentProcess
(
)
&
&
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPromptProvider
)
)
)
{
*
result
=
nullptr
;
return
NS_OK
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsILoadContext
)
)
&
&
mLoadContext
)
{
nsCOMPtr
<
nsILoadContext
>
copy
=
mLoadContext
;
copy
.
forget
(
result
)
;
return
NS_OK
;
}
if
(
mTabParent
&
&
aIID
.
Equals
(
NS_GET_IID
(
nsIPrompt
)
)
)
{
nsCOMPtr
<
Element
>
frameElement
=
mTabParent
-
>
GetOwnerElement
(
)
;
if
(
frameElement
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
frameElement
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
win
NS_ERROR_UNEXPECTED
)
;
nsresult
rv
;
nsCOMPtr
<
nsIWindowWatcher
>
wwatch
=
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
!
NS_SUCCEEDED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIPrompt
>
prompt
;
rv
=
wwatch
-
>
GetNewPrompter
(
win
getter_AddRefs
(
prompt
)
)
;
if
(
NS_WARN_IF
(
!
NS_SUCCEEDED
(
rv
)
)
)
{
return
rv
;
}
prompt
.
forget
(
result
)
;
return
NS_OK
;
}
}
return
QueryInterface
(
aIID
result
)
;
}
void
HttpChannelParent
:
:
AsyncOpenFailed
(
nsresult
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
NS_FAILED
(
aRv
)
)
;
mChannel
=
nullptr
;
mParentListener
=
nullptr
;
if
(
!
mIPCClosed
)
{
Unused
<
<
SendFailedAsyncOpen
(
aRv
)
;
}
}
void
HttpChannelParent
:
:
InvokeAsyncOpen
(
nsresult
rv
)
{
LOG
(
(
"
HttpChannelParent
:
:
InvokeAsyncOpen
[
this
=
%
p
rv
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
AsyncOpenFailed
(
rv
)
;
return
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
rv
=
mChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
AsyncOpenFailed
(
rv
)
;
return
;
}
rv
=
mChannel
-
>
AsyncOpen
(
mParentListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
AsyncOpenFailed
(
rv
)
;
}
}
bool
HttpChannelParent
:
:
DoAsyncOpen
(
const
URIParams
&
aURI
const
OptionalURIParams
&
aOriginalURI
const
OptionalURIParams
&
aDocURI
const
OptionalURIParams
&
aReferrerURI
const
uint32_t
&
aReferrerPolicy
const
OptionalURIParams
&
aAPIRedirectToURI
const
OptionalURIParams
&
aTopWindowURI
nsIPrincipal
*
aTopWindowPrincipal
const
uint32_t
&
aLoadFlags
const
RequestHeaderTuples
&
requestHeaders
const
nsCString
&
requestMethod
const
OptionalIPCStream
&
uploadStream
const
bool
&
uploadStreamHasHeaders
const
int16_t
&
priority
const
uint32_t
&
classOfService
const
uint8_t
&
redirectionLimit
const
bool
&
allowSTS
const
uint32_t
&
thirdPartyFlags
const
bool
&
doResumeAt
const
uint64_t
&
startPos
const
nsCString
&
entityID
const
bool
&
chooseApplicationCache
const
nsCString
&
appCacheClientID
const
bool
&
allowSpdy
const
bool
&
allowAltSvc
const
bool
&
beConservative
const
uint32_t
&
tlsFlags
const
OptionalLoadInfoArgs
&
aLoadInfoArgs
const
OptionalHttpResponseHead
&
aSynthesizedResponseHead
const
nsCString
&
aSecurityInfoSerialization
const
uint32_t
&
aCacheKey
const
uint64_t
&
aRequestContextID
const
OptionalCorsPreflightArgs
&
aCorsPreflightArgs
const
uint32_t
&
aInitialRwin
const
bool
&
aBlockAuthPrompt
const
bool
&
aSuspendAfterSynthesizeResponse
const
bool
&
aAllowStaleCacheContent
const
nsCString
&
aContentTypeHint
const
uint32_t
&
aCorsMode
const
uint32_t
&
aRedirectMode
const
uint64_t
&
aChannelId
const
nsString
&
aIntegrityMetadata
const
uint64_t
&
aContentWindowId
const
ArrayOfStringPairs
&
aPreferredAlternativeTypes
const
uint64_t
&
aTopLevelOuterContentWindowId
const
TimeStamp
&
aLaunchServiceWorkerStart
const
TimeStamp
&
aLaunchServiceWorkerEnd
const
TimeStamp
&
aDispatchFetchEventStart
const
TimeStamp
&
aDispatchFetchEventEnd
const
TimeStamp
&
aHandleFetchEventStart
const
TimeStamp
&
aHandleFetchEventEnd
const
bool
&
aForceMainDocumentChannel
const
TimeStamp
&
aNavigationStartTimeStamp
)
{
nsCOMPtr
<
nsIURI
>
uri
=
DeserializeURI
(
aURI
)
;
if
(
!
uri
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
originalUri
=
DeserializeURI
(
aOriginalURI
)
;
nsCOMPtr
<
nsIURI
>
docUri
=
DeserializeURI
(
aDocURI
)
;
nsCOMPtr
<
nsIURI
>
referrerUri
=
DeserializeURI
(
aReferrerURI
)
;
nsCOMPtr
<
nsIURI
>
apiRedirectToUri
=
DeserializeURI
(
aAPIRedirectToURI
)
;
nsCOMPtr
<
nsIURI
>
topWindowUri
=
DeserializeURI
(
aTopWindowURI
)
;
LOG
(
(
"
HttpChannelParent
RecvAsyncOpen
[
this
=
%
p
uri
=
%
s
gid
=
%
"
PRIu64
"
topwinid
=
%
"
PRIx64
"
]
\
n
"
this
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
aChannelId
aTopLevelOuterContentWindowId
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIIOService
>
ios
(
do_GetIOService
(
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
SendFailedAsyncOpen
(
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
rv
=
mozilla
:
:
ipc
:
:
LoadInfoArgsToLoadInfo
(
aLoadInfoArgs
getter_AddRefs
(
loadInfo
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
SendFailedAsyncOpen
(
rv
)
;
}
if
(
!
loadInfo
)
{
return
SendFailedAsyncOpen
(
NS_ERROR_UNEXPECTED
)
;
}
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
channel
)
uri
loadInfo
nullptr
nullptr
nullptr
aLoadFlags
ios
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
SendFailedAsyncOpen
(
rv
)
;
}
RefPtr
<
HttpBaseChannel
>
httpChannel
=
do_QueryObject
(
channel
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
SendFailedAsyncOpen
(
rv
)
;
}
httpChannel
-
>
SetCorsMode
(
aCorsMode
)
;
httpChannel
-
>
SetRedirectMode
(
aRedirectMode
)
;
httpChannel
-
>
SetChannelId
(
aChannelId
)
;
httpChannel
-
>
SetTopLevelContentWindowId
(
aContentWindowId
)
;
httpChannel
-
>
SetTopLevelOuterContentWindowId
(
aTopLevelOuterContentWindowId
)
;
httpChannel
-
>
SetIntegrityMetadata
(
aIntegrityMetadata
)
;
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
httpChannel
)
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
SetWarningReporter
(
this
)
;
}
httpChannel
-
>
SetTimingEnabled
(
true
)
;
if
(
mPBOverride
!
=
kPBOverride_Unset
)
{
httpChannel
-
>
SetPrivate
(
mPBOverride
=
=
kPBOverride_Private
?
true
:
false
)
;
}
if
(
doResumeAt
)
httpChannel
-
>
ResumeAt
(
startPos
entityID
)
;
if
(
originalUri
)
httpChannel
-
>
SetOriginalURI
(
originalUri
)
;
if
(
docUri
)
httpChannel
-
>
SetDocumentURI
(
docUri
)
;
if
(
referrerUri
)
{
rv
=
httpChannel
-
>
SetReferrerWithPolicyInternal
(
referrerUri
aReferrerPolicy
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
if
(
apiRedirectToUri
)
httpChannel
-
>
RedirectTo
(
apiRedirectToUri
)
;
if
(
topWindowUri
)
{
rv
=
httpChannel
-
>
SetTopWindowURI
(
topWindowUri
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
httpChannel
-
>
SetTopWindowPrincipal
(
aTopWindowPrincipal
)
;
if
(
aLoadFlags
!
=
nsIRequest
:
:
LOAD_NORMAL
)
httpChannel
-
>
SetLoadFlags
(
aLoadFlags
)
;
if
(
aForceMainDocumentChannel
)
{
httpChannel
-
>
SetIsMainDocumentChannel
(
true
)
;
}
for
(
uint32_t
i
=
0
;
i
<
requestHeaders
.
Length
(
)
;
i
+
+
)
{
if
(
requestHeaders
[
i
]
.
mEmpty
)
{
httpChannel
-
>
SetEmptyRequestHeader
(
requestHeaders
[
i
]
.
mHeader
)
;
}
else
{
httpChannel
-
>
SetRequestHeader
(
requestHeaders
[
i
]
.
mHeader
requestHeaders
[
i
]
.
mValue
requestHeaders
[
i
]
.
mMerge
)
;
}
}
RefPtr
<
HttpChannelParentListener
>
parentListener
=
new
HttpChannelParentListener
(
this
)
;
httpChannel
-
>
SetRequestMethod
(
nsDependentCString
(
requestMethod
.
get
(
)
)
)
;
if
(
aCorsPreflightArgs
.
type
(
)
=
=
OptionalCorsPreflightArgs
:
:
TCorsPreflightArgs
)
{
const
CorsPreflightArgs
&
args
=
aCorsPreflightArgs
.
get_CorsPreflightArgs
(
)
;
httpChannel
-
>
SetCorsPreflightParameters
(
args
.
unsafeHeaders
(
)
)
;
}
nsCOMPtr
<
nsIInputStream
>
stream
=
DeserializeIPCStream
(
uploadStream
)
;
if
(
stream
)
{
int64_t
length
;
if
(
InputStreamLengthHelper
:
:
GetSyncLength
(
stream
&
length
)
)
{
httpChannel
-
>
InternalSetUploadStreamLength
(
length
>
=
0
?
length
:
0
)
;
}
else
{
+
+
mAsyncOpenBarrier
;
RefPtr
<
HttpChannelParent
>
self
=
this
;
InputStreamLengthHelper
:
:
GetAsyncLength
(
stream
[
self
httpChannel
]
(
int64_t
aLength
)
{
httpChannel
-
>
InternalSetUploadStreamLength
(
aLength
>
=
0
?
aLength
:
0
)
;
self
-
>
TryInvokeAsyncOpen
(
NS_OK
)
;
}
)
;
}
httpChannel
-
>
InternalSetUploadStream
(
stream
)
;
httpChannel
-
>
SetUploadStreamHasHeaders
(
uploadStreamHasHeaders
)
;
}
if
(
aSynthesizedResponseHead
.
type
(
)
=
=
OptionalHttpResponseHead
:
:
TnsHttpResponseHead
)
{
parentListener
-
>
SetupInterception
(
aSynthesizedResponseHead
.
get_nsHttpResponseHead
(
)
)
;
mWillSynthesizeResponse
=
true
;
httpChannelImpl
-
>
SetCouldBeSynthesized
(
)
;
if
(
!
aSecurityInfoSerialization
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsISupports
>
secInfo
;
rv
=
NS_DeserializeObject
(
aSecurityInfoSerialization
getter_AddRefs
(
secInfo
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserializing
security
info
should
not
fail
"
)
;
rv
=
httpChannel
-
>
OverrideSecurityInfo
(
secInfo
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChannel
=
do_QueryInterface
(
static_cast
<
nsIChannel
*
>
(
httpChannel
.
get
(
)
)
)
;
if
(
cacheChannel
)
{
cacheChannel
-
>
SetCacheKey
(
aCacheKey
)
;
for
(
auto
&
pair
:
aPreferredAlternativeTypes
)
{
cacheChannel
-
>
PreferAlternativeDataType
(
mozilla
:
:
Get
<
0
>
(
pair
)
mozilla
:
:
Get
<
1
>
(
pair
)
)
;
}
cacheChannel
-
>
SetAllowStaleCacheContent
(
aAllowStaleCacheContent
)
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
SetAltDataForChild
(
true
)
;
}
}
httpChannel
-
>
SetContentType
(
aContentTypeHint
)
;
if
(
priority
!
=
nsISupportsPriority
:
:
PRIORITY_NORMAL
)
{
httpChannel
-
>
SetPriority
(
priority
)
;
}
if
(
classOfService
)
{
httpChannel
-
>
SetClassFlags
(
classOfService
)
;
}
httpChannel
-
>
SetRedirectionLimit
(
redirectionLimit
)
;
httpChannel
-
>
SetAllowSTS
(
allowSTS
)
;
httpChannel
-
>
SetThirdPartyFlags
(
thirdPartyFlags
)
;
httpChannel
-
>
SetAllowSpdy
(
allowSpdy
)
;
httpChannel
-
>
SetAllowAltSvc
(
allowAltSvc
)
;
httpChannel
-
>
SetBeConservative
(
beConservative
)
;
httpChannel
-
>
SetTlsFlags
(
tlsFlags
)
;
httpChannel
-
>
SetInitialRwin
(
aInitialRwin
)
;
httpChannel
-
>
SetBlockAuthPrompt
(
aBlockAuthPrompt
)
;
httpChannel
-
>
SetLaunchServiceWorkerStart
(
aLaunchServiceWorkerStart
)
;
httpChannel
-
>
SetLaunchServiceWorkerEnd
(
aLaunchServiceWorkerEnd
)
;
httpChannel
-
>
SetDispatchFetchEventStart
(
aDispatchFetchEventStart
)
;
httpChannel
-
>
SetDispatchFetchEventEnd
(
aDispatchFetchEventEnd
)
;
httpChannel
-
>
SetHandleFetchEventStart
(
aHandleFetchEventStart
)
;
httpChannel
-
>
SetHandleFetchEventEnd
(
aHandleFetchEventEnd
)
;
httpChannel
-
>
SetNavigationStartTimeStamp
(
aNavigationStartTimeStamp
)
;
nsCOMPtr
<
nsIApplicationCacheChannel
>
appCacheChan
=
do_QueryObject
(
httpChannel
)
;
nsCOMPtr
<
nsIApplicationCacheService
>
appCacheService
=
do_GetService
(
NS_APPLICATIONCACHESERVICE_CONTRACTID
)
;
bool
setChooseApplicationCache
=
chooseApplicationCache
;
if
(
appCacheChan
&
&
appCacheService
)
{
appCacheChan
-
>
SetInheritApplicationCache
(
false
)
;
if
(
!
appCacheClientID
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIApplicationCache
>
appCache
;
rv
=
appCacheService
-
>
GetApplicationCache
(
appCacheClientID
getter_AddRefs
(
appCache
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
appCacheChan
-
>
SetApplicationCache
(
appCache
)
;
setChooseApplicationCache
=
false
;
}
}
if
(
setChooseApplicationCache
)
{
OriginAttributes
attrs
;
NS_GetOriginAttributes
(
httpChannel
attrs
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateCodebasePrincipal
(
uri
attrs
)
;
bool
chooseAppCache
=
false
;
chooseAppCache
=
NS_ShouldCheckAppCache
(
principal
)
;
appCacheChan
-
>
SetChooseApplicationCache
(
chooseAppCache
)
;
}
}
httpChannel
-
>
SetRequestContextID
(
aRequestContextID
)
;
mChannel
=
httpChannel
.
forget
(
)
;
mParentListener
=
parentListener
.
forget
(
)
;
mChannel
-
>
SetNotificationCallbacks
(
mParentListener
)
;
mSuspendAfterSynthesizeResponse
=
aSuspendAfterSynthesizeResponse
;
MOZ_ASSERT
(
!
mBgParent
)
;
MOZ_ASSERT
(
mPromise
.
IsEmpty
(
)
)
;
+
+
mAsyncOpenBarrier
;
RefPtr
<
HttpChannelParent
>
self
=
this
;
WaitForBgParent
(
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
]
(
)
{
self
-
>
mRequest
.
Complete
(
)
;
self
-
>
TryInvokeAsyncOpen
(
NS_OK
)
;
}
[
self
]
(
nsresult
aStatus
)
{
self
-
>
mRequest
.
Complete
(
)
;
self
-
>
TryInvokeAsyncOpen
(
aStatus
)
;
}
)
-
>
Track
(
mRequest
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
HttpChannelParent
:
:
EnsureUploadStreamIsCloneable
"
[
self
]
(
)
{
self
-
>
TryInvokeAsyncOpen
(
NS_OK
)
;
}
)
;
+
+
mAsyncOpenBarrier
;
mChannel
-
>
EnsureUploadStreamIsCloneable
(
r
)
;
return
true
;
}
RefPtr
<
GenericNonExclusivePromise
>
HttpChannelParent
:
:
WaitForBgParent
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
WaitForBgParent
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
!
mBgParent
)
;
MOZ_ASSERT
(
mChannel
)
;
nsCOMPtr
<
nsIBackgroundChannelRegistrar
>
registrar
=
BackgroundChannelRegistrar
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
registrar
)
;
registrar
-
>
LinkHttpChannel
(
mChannel
-
>
ChannelId
(
)
this
)
;
if
(
mBgParent
)
{
return
GenericNonExclusivePromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
return
mPromise
.
Ensure
(
__func__
)
;
}
bool
HttpChannelParent
:
:
ConnectChannel
(
const
uint32_t
&
registrarId
const
bool
&
shouldIntercept
)
{
nsresult
rv
;
LOG
(
(
"
HttpChannelParent
:
:
ConnectChannel
:
Looking
for
a
registered
channel
"
"
[
this
=
%
p
id
=
%
"
PRIu32
"
]
\
n
"
this
registrarId
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_LinkRedirectChannels
(
registrarId
this
getter_AddRefs
(
channel
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
Could
not
find
the
http
channel
to
connect
its
IPC
parent
"
)
;
Delete
(
)
;
return
true
;
}
LOG
(
(
"
found
channel
%
p
rv
=
%
08
"
PRIx32
channel
.
get
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
mChannel
=
do_QueryObject
(
channel
)
;
if
(
!
mChannel
)
{
LOG
(
(
"
but
it
'
s
not
HttpBaseChannel
"
)
)
;
Delete
(
)
;
return
true
;
}
LOG
(
(
"
and
it
is
HttpBaseChannel
%
p
"
mChannel
.
get
(
)
)
)
;
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
mChannel
)
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
SetWarningReporter
(
this
)
;
}
nsCOMPtr
<
nsINetworkInterceptController
>
controller
;
NS_QueryNotificationCallbacks
(
channel
controller
)
;
RefPtr
<
HttpChannelParentListener
>
parentListener
=
do_QueryObject
(
controller
)
;
MOZ_ASSERT
(
parentListener
)
;
parentListener
-
>
SetupInterceptionAfterRedirect
(
shouldIntercept
)
;
if
(
mPBOverride
!
=
kPBOverride_Unset
)
{
nsCOMPtr
<
nsIPrivateBrowsingChannel
>
pbChannel
=
do_QueryObject
(
mChannel
)
;
if
(
pbChannel
)
{
pbChannel
-
>
SetPrivate
(
mPBOverride
=
=
kPBOverride_Private
?
true
:
false
)
;
}
}
MOZ_ASSERT
(
!
mBgParent
)
;
MOZ_ASSERT
(
mPromise
.
IsEmpty
(
)
)
;
RefPtr
<
HttpChannelParent
>
self
=
this
;
WaitForBgParent
(
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
]
(
)
{
self
-
>
mRequest
.
Complete
(
)
;
}
[
self
]
(
const
nsresult
&
aResult
)
{
NS_ERROR
(
"
failed
to
establish
the
background
channel
"
)
;
self
-
>
mRequest
.
Complete
(
)
;
}
)
-
>
Track
(
mRequest
)
;
return
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvSetPriority
(
const
int16_t
&
priority
)
{
LOG
(
(
"
HttpChannelParent
:
:
RecvSetPriority
[
this
=
%
p
priority
=
%
d
]
\
n
"
this
priority
)
)
;
AUTO_PROFILER_LABEL
(
"
HttpChannelParent
:
:
RecvSetPriority
"
NETWORK
)
;
if
(
mChannel
)
{
mChannel
-
>
SetPriority
(
priority
)
;
}
nsCOMPtr
<
nsISupportsPriority
>
priorityRedirectChannel
=
do_QueryInterface
(
mRedirectChannel
)
;
if
(
priorityRedirectChannel
)
priorityRedirectChannel
-
>
SetPriority
(
priority
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvSetClassOfService
(
const
uint32_t
&
cos
)
{
if
(
mChannel
)
{
mChannel
-
>
SetClassFlags
(
cos
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvSuspend
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
RecvSuspend
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mChannel
)
{
mChannel
-
>
Suspend
(
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvResume
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
RecvResume
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mChannel
)
{
mChannel
-
>
Resume
(
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvCancel
(
const
nsresult
&
status
)
{
LOG
(
(
"
HttpChannelParent
:
:
RecvCancel
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
status
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvSetCacheTokenCachedCharset
(
const
nsCString
&
charset
)
{
if
(
mCacheEntry
)
mCacheEntry
-
>
SetMetaDataElement
(
"
charset
"
charset
.
get
(
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvRedirect2Verify
(
const
nsresult
&
aResult
const
RequestHeaderTuples
&
changedHeaders
const
ChildLoadInfoForwarderArgs
&
aLoadInfoForwarder
const
uint32_t
&
loadFlags
const
uint32_t
&
referrerPolicy
const
OptionalURIParams
&
aReferrerURI
const
OptionalURIParams
&
aAPIRedirectURI
const
OptionalCorsPreflightArgs
&
aCorsPreflightArgs
const
bool
&
aChooseAppcache
)
{
LOG
(
(
"
HttpChannelParent
:
:
RecvRedirect2Verify
[
this
=
%
p
result
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
aResult
)
)
)
;
nsresult
result
=
aResult
;
nsresult
rv
;
if
(
NS_SUCCEEDED
(
result
)
)
{
nsCOMPtr
<
nsIHttpChannel
>
newHttpChannel
=
do_QueryInterface
(
mRedirectChannel
)
;
if
(
newHttpChannel
)
{
nsCOMPtr
<
nsIURI
>
apiRedirectUri
=
DeserializeURI
(
aAPIRedirectURI
)
;
if
(
apiRedirectUri
)
{
rv
=
newHttpChannel
-
>
RedirectTo
(
apiRedirectUri
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
changedHeaders
.
Length
(
)
;
i
+
+
)
{
if
(
changedHeaders
[
i
]
.
mEmpty
)
{
rv
=
newHttpChannel
-
>
SetEmptyRequestHeader
(
changedHeaders
[
i
]
.
mHeader
)
;
}
else
{
rv
=
newHttpChannel
-
>
SetRequestHeader
(
changedHeaders
[
i
]
.
mHeader
changedHeaders
[
i
]
.
mValue
changedHeaders
[
i
]
.
mMerge
)
;
}
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
MOZ_ASSERT
(
loadFlags
&
nsIChannel
:
:
LOAD_REPLACE
)
;
if
(
loadFlags
&
nsIChannel
:
:
LOAD_REPLACE
)
{
newHttpChannel
-
>
SetLoadFlags
(
loadFlags
)
;
}
if
(
aCorsPreflightArgs
.
type
(
)
=
=
OptionalCorsPreflightArgs
:
:
TCorsPreflightArgs
)
{
nsCOMPtr
<
nsIHttpChannelInternal
>
newInternalChannel
=
do_QueryInterface
(
newHttpChannel
)
;
MOZ_RELEASE_ASSERT
(
newInternalChannel
)
;
const
CorsPreflightArgs
&
args
=
aCorsPreflightArgs
.
get_CorsPreflightArgs
(
)
;
newInternalChannel
-
>
SetCorsPreflightParameters
(
args
.
unsafeHeaders
(
)
)
;
}
nsCOMPtr
<
nsIURI
>
referrerUri
=
DeserializeURI
(
aReferrerURI
)
;
rv
=
newHttpChannel
-
>
SetReferrerWithPolicy
(
referrerUri
referrerPolicy
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsIApplicationCacheChannel
>
appCacheChannel
=
do_QueryInterface
(
newHttpChannel
)
;
if
(
appCacheChannel
)
{
appCacheChannel
-
>
SetChooseApplicationCache
(
aChooseAppcache
)
;
}
nsCOMPtr
<
nsILoadInfo
>
newLoadInfo
;
Unused
<
<
newHttpChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
newLoadInfo
)
)
;
rv
=
MergeChildLoadInfoForwarder
(
aLoadInfoForwarder
newLoadInfo
)
;
if
(
NS_FAILED
(
rv
)
&
&
NS_SUCCEEDED
(
result
)
)
{
result
=
rv
;
}
}
}
if
(
NS_FAILED
(
result
)
)
{
ContinueRedirect2Verify
(
result
)
;
return
IPC_OK
(
)
;
}
nsCOMPtr
<
nsIRedirectChannelRegistrar
>
redirectReg
=
RedirectChannelRegistrar
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
redirectReg
)
;
nsCOMPtr
<
nsIParentChannel
>
redirectParentChannel
;
rv
=
redirectReg
-
>
GetParentChannel
(
mRedirectRegistrarId
getter_AddRefs
(
redirectParentChannel
)
)
;
MOZ_ASSERT
(
redirectParentChannel
)
;
if
(
!
redirectParentChannel
)
{
ContinueRedirect2Verify
(
rv
)
;
return
IPC_OK
(
)
;
}
nsCOMPtr
<
nsIParentRedirectingChannel
>
redirectedParent
=
do_QueryInterface
(
redirectParentChannel
)
;
if
(
!
redirectedParent
)
{
ContinueRedirect2Verify
(
result
)
;
return
IPC_OK
(
)
;
}
redirectedParent
-
>
ContinueVerification
(
this
)
;
return
IPC_OK
(
)
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
ContinueVerification
(
nsIAsyncVerifyRedirectReadyCallback
*
aCallback
)
{
LOG
(
(
"
HttpChannelParent
:
:
ContinueVerification
[
this
=
%
p
callback
=
%
p
]
\
n
"
this
aCallback
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aCallback
)
;
if
(
mBgParent
)
{
aCallback
-
>
ReadyToVerify
(
NS_OK
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
!
mPromise
.
IsEmpty
(
)
)
;
nsCOMPtr
<
nsIAsyncVerifyRedirectReadyCallback
>
callback
=
aCallback
;
WaitForBgParent
(
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
callback
]
(
)
{
callback
-
>
ReadyToVerify
(
NS_OK
)
;
}
[
callback
]
(
const
nsresult
&
aResult
)
{
NS_ERROR
(
"
failed
to
establish
the
background
channel
"
)
;
callback
-
>
ReadyToVerify
(
aResult
)
;
}
)
;
return
NS_OK
;
}
void
HttpChannelParent
:
:
ContinueRedirect2Verify
(
const
nsresult
&
aResult
)
{
LOG
(
(
"
HttpChannelParent
:
:
ContinueRedirect2Verify
[
this
=
%
p
result
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
aResult
)
)
)
;
if
(
!
mRedirectCallback
)
{
if
(
mReceivedRedirect2Verify
)
LOG
(
(
"
RecvRedirect2Verify
[
%
p
]
:
Duplicate
fire
"
this
)
)
;
if
(
mSentRedirect1BeginFailed
)
LOG
(
(
"
RecvRedirect2Verify
[
%
p
]
:
Send
to
child
failed
"
this
)
)
;
if
(
(
mRedirectRegistrarId
>
0
)
&
&
NS_FAILED
(
aResult
)
)
LOG
(
(
"
RecvRedirect2Verify
[
%
p
]
:
Redirect
failed
"
this
)
)
;
if
(
(
mRedirectRegistrarId
>
0
)
&
&
NS_SUCCEEDED
(
aResult
)
)
LOG
(
(
"
RecvRedirect2Verify
[
%
p
]
:
Redirect
succeeded
"
this
)
)
;
if
(
!
mRedirectChannel
)
LOG
(
(
"
RecvRedirect2Verify
[
%
p
]
:
Missing
redirect
channel
"
this
)
)
;
NS_ERROR
(
"
Unexpcted
call
to
HttpChannelParent
:
:
RecvRedirect2Verify
"
"
mRedirectCallback
null
"
)
;
}
mReceivedRedirect2Verify
=
true
;
if
(
mRedirectCallback
)
{
LOG
(
(
"
HttpChannelParent
:
:
ContinueRedirect2Verify
call
"
"
OnRedirectVerifyCallback
"
"
[
this
=
%
p
result
=
%
"
PRIx32
"
mRedirectCallback
=
%
p
]
\
n
"
this
static_cast
<
uint32_t
>
(
aResult
)
mRedirectCallback
.
get
(
)
)
)
;
mRedirectCallback
-
>
OnRedirectVerifyCallback
(
aResult
)
;
mRedirectCallback
=
nullptr
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvDocumentChannelCleanup
(
const
bool
&
clearCacheEntry
)
{
CleanupBackgroundChannel
(
)
;
mChannel
=
nullptr
;
if
(
clearCacheEntry
)
{
mCacheEntry
=
nullptr
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvMarkOfflineCacheEntryAsForeign
(
)
{
if
(
mOfflineForeignMarker
)
{
mOfflineForeignMarker
-
>
MarkAsForeign
(
)
;
mOfflineForeignMarker
=
nullptr
;
}
return
IPC_OK
(
)
;
}
class
DivertDataAvailableEvent
:
public
MainThreadChannelEvent
{
public
:
DivertDataAvailableEvent
(
HttpChannelParent
*
aParent
const
nsCString
&
data
const
uint64_t
&
offset
const
uint32_t
&
count
)
:
mParent
(
aParent
)
mData
(
data
)
mOffset
(
offset
)
mCount
(
count
)
{
}
void
Run
(
)
override
{
mParent
-
>
DivertOnDataAvailable
(
mData
mOffset
mCount
)
;
}
private
:
HttpChannelParent
*
mParent
;
nsCString
mData
;
uint64_t
mOffset
;
uint32_t
mCount
;
}
;
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvDivertOnDataAvailable
(
const
nsCString
&
data
const
uint64_t
&
offset
const
uint32_t
&
count
)
{
LOG
(
(
"
HttpChannelParent
:
:
RecvDivertOnDataAvailable
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
mParentListener
)
;
if
(
NS_WARN_IF
(
!
mDivertingFromChild
)
)
{
MOZ_ASSERT
(
mDivertingFromChild
"
Cannot
RecvDivertOnDataAvailable
if
diverting
is
not
set
!
"
)
;
FailDiversion
(
NS_ERROR_UNEXPECTED
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_FAILED
(
mStatus
)
)
{
return
IPC_OK
(
)
;
}
mEventQ
-
>
RunOrEnqueue
(
new
DivertDataAvailableEvent
(
this
data
offset
count
)
)
;
return
IPC_OK
(
)
;
}
void
HttpChannelParent
:
:
DivertOnDataAvailable
(
const
nsCString
&
data
const
uint64_t
&
offset
const
uint32_t
&
count
)
{
LOG
(
(
"
HttpChannelParent
:
:
DivertOnDataAvailable
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
mParentListener
)
;
if
(
NS_WARN_IF
(
!
mDivertingFromChild
)
)
{
MOZ_ASSERT
(
mDivertingFromChild
"
Cannot
DivertOnDataAvailable
if
diverting
is
not
set
!
"
)
;
FailDiversion
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
NS_FAILED
(
mStatus
)
)
{
return
;
}
nsCOMPtr
<
nsIInputStream
>
stringStream
;
nsresult
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stringStream
)
data
.
get
(
)
count
NS_ASSIGNMENT_DEPEND
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
rv
)
;
}
mStatus
=
rv
;
return
;
}
AutoEventEnqueuer
ensureSerialDispatch
(
mEventQ
)
;
rv
=
mParentListener
-
>
OnDataAvailable
(
mChannel
nullptr
stringStream
offset
count
)
;
stringStream
-
>
Close
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
rv
)
;
}
mStatus
=
rv
;
}
}
class
DivertStopRequestEvent
:
public
MainThreadChannelEvent
{
public
:
DivertStopRequestEvent
(
HttpChannelParent
*
aParent
const
nsresult
&
statusCode
)
:
mParent
(
aParent
)
mStatusCode
(
statusCode
)
{
}
void
Run
(
)
override
{
mParent
-
>
DivertOnStopRequest
(
mStatusCode
)
;
}
private
:
HttpChannelParent
*
mParent
;
nsresult
mStatusCode
;
}
;
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvDivertOnStopRequest
(
const
nsresult
&
statusCode
)
{
LOG
(
(
"
HttpChannelParent
:
:
RecvDivertOnStopRequest
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
mParentListener
)
;
if
(
NS_WARN_IF
(
!
mDivertingFromChild
)
)
{
MOZ_ASSERT
(
mDivertingFromChild
"
Cannot
RecvDivertOnStopRequest
if
diverting
is
not
set
!
"
)
;
FailDiversion
(
NS_ERROR_UNEXPECTED
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mEventQ
-
>
RunOrEnqueue
(
new
DivertStopRequestEvent
(
this
statusCode
)
)
;
return
IPC_OK
(
)
;
}
void
HttpChannelParent
:
:
DivertOnStopRequest
(
const
nsresult
&
statusCode
)
{
LOG
(
(
"
HttpChannelParent
:
:
DivertOnStopRequest
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
mParentListener
)
;
if
(
NS_WARN_IF
(
!
mDivertingFromChild
)
)
{
MOZ_ASSERT
(
mDivertingFromChild
"
Cannot
DivertOnStopRequest
if
diverting
is
not
set
!
"
)
;
FailDiversion
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
nsresult
status
=
NS_FAILED
(
mStatus
)
?
mStatus
:
statusCode
;
if
(
mChannel
)
{
mChannel
-
>
ForcePending
(
false
)
;
}
AutoEventEnqueuer
ensureSerialDispatch
(
mEventQ
)
;
mParentListener
-
>
OnStopRequest
(
mChannel
nullptr
status
)
;
}
class
DivertCompleteEvent
:
public
MainThreadChannelEvent
{
public
:
explicit
DivertCompleteEvent
(
HttpChannelParent
*
aParent
)
:
mParent
(
aParent
)
{
}
void
Run
(
)
override
{
mParent
-
>
DivertComplete
(
)
;
}
private
:
HttpChannelParent
*
mParent
;
}
;
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvDivertComplete
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
RecvDivertComplete
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
mParentListener
)
;
if
(
NS_WARN_IF
(
!
mDivertingFromChild
)
)
{
MOZ_ASSERT
(
mDivertingFromChild
"
Cannot
RecvDivertComplete
if
diverting
is
not
set
!
"
)
;
FailDiversion
(
NS_ERROR_UNEXPECTED
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mEventQ
-
>
RunOrEnqueue
(
new
DivertCompleteEvent
(
this
)
)
;
return
IPC_OK
(
)
;
}
void
HttpChannelParent
:
:
DivertComplete
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
DivertComplete
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
mParentListener
)
;
if
(
NS_WARN_IF
(
!
mDivertingFromChild
)
)
{
MOZ_ASSERT
(
mDivertingFromChild
"
Cannot
DivertComplete
if
diverting
is
not
set
!
"
)
;
FailDiversion
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
nsresult
rv
=
ResumeForDiversion
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailDiversion
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
mParentListener
=
nullptr
;
}
void
HttpChannelParent
:
:
MaybeFlushPendingDiversion
(
)
{
if
(
!
mPendingDiversion
)
{
return
;
}
mPendingDiversion
=
false
;
nsresult
rv
=
SuspendForDiversion
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
mDivertListener
)
{
DivertTo
(
mDivertListener
)
;
}
}
static
void
FinishCrossProcessRedirect
(
nsHttpChannel
*
channel
nsresult
status
)
{
if
(
NS_SUCCEEDED
(
status
)
)
{
nsCOMPtr
<
nsINetworkInterceptController
>
controller
;
NS_QueryNotificationCallbacks
(
channel
controller
)
;
RefPtr
<
HttpChannelParentListener
>
parentListener
=
do_QueryObject
(
controller
)
;
MOZ_ASSERT
(
parentListener
)
;
parentListener
-
>
OnRedirectResult
(
status
=
=
NS_OK
)
;
}
channel
-
>
OnRedirectVerifyCallback
(
status
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvCrossProcessRedirectDone
(
const
nsresult
&
aResult
)
{
RefPtr
<
nsHttpChannel
>
chan
=
do_QueryObject
(
mChannel
)
;
if
(
!
mBgParent
)
{
RefPtr
<
HttpChannelParent
>
self
=
this
;
WaitForBgParent
(
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
chan
aResult
]
(
)
{
FinishCrossProcessRedirect
(
chan
aResult
)
;
}
[
self
chan
]
(
const
nsresult
&
aRejectionRv
)
{
MOZ_ASSERT
(
NS_FAILED
(
aRejectionRv
)
"
This
should
be
an
error
code
"
)
;
FinishCrossProcessRedirect
(
chan
aRejectionRv
)
;
}
)
;
}
else
{
FinishCrossProcessRedirect
(
chan
aResult
)
;
}
return
IPC_OK
(
)
;
}
void
HttpChannelParent
:
:
ResponseSynthesized
(
)
{
if
(
mSuspendAfterSynthesizeResponse
)
{
mChannel
-
>
Suspend
(
)
;
}
mWillSynthesizeResponse
=
false
;
MaybeFlushPendingDiversion
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvRemoveCorsPreflightCacheEntry
(
const
URIParams
&
uri
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
requestingPrincipal
)
{
nsCOMPtr
<
nsIURI
>
deserializedURI
=
DeserializeURI
(
uri
)
;
if
(
!
deserializedURI
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
PrincipalInfoToPrincipal
(
requestingPrincipal
)
;
if
(
!
principal
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
nsCORSListenerProxy
:
:
RemoveFromCorsPreflightCache
(
deserializedURI
principal
)
;
return
IPC_OK
(
)
;
}
static
void
GetTimingAttributes
(
HttpBaseChannel
*
aChannel
ResourceTimingStruct
&
aTiming
)
{
aChannel
-
>
GetDomainLookupStart
(
&
aTiming
.
domainLookupStart
)
;
aChannel
-
>
GetDomainLookupEnd
(
&
aTiming
.
domainLookupEnd
)
;
aChannel
-
>
GetConnectStart
(
&
aTiming
.
connectStart
)
;
aChannel
-
>
GetTcpConnectEnd
(
&
aTiming
.
tcpConnectEnd
)
;
aChannel
-
>
GetSecureConnectionStart
(
&
aTiming
.
secureConnectionStart
)
;
aChannel
-
>
GetConnectEnd
(
&
aTiming
.
connectEnd
)
;
aChannel
-
>
GetRequestStart
(
&
aTiming
.
requestStart
)
;
aChannel
-
>
GetResponseStart
(
&
aTiming
.
responseStart
)
;
aChannel
-
>
GetResponseEnd
(
&
aTiming
.
responseEnd
)
;
aChannel
-
>
GetAsyncOpen
(
&
aTiming
.
fetchStart
)
;
aChannel
-
>
GetRedirectStart
(
&
aTiming
.
redirectStart
)
;
aChannel
-
>
GetRedirectEnd
(
&
aTiming
.
redirectEnd
)
;
aChannel
-
>
GetTransferSize
(
&
aTiming
.
transferSize
)
;
aChannel
-
>
GetEncodedBodySize
(
&
aTiming
.
encodedBodySize
)
;
aChannel
-
>
GetProtocolVersion
(
aTiming
.
protocolVersion
)
;
aChannel
-
>
GetCacheReadStart
(
&
aTiming
.
cacheReadStart
)
;
aChannel
-
>
GetCacheReadEnd
(
&
aTiming
.
cacheReadEnd
)
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
nsresult
rv
;
LOG
(
(
"
HttpChannelParent
:
:
OnStartRequest
[
this
=
%
p
aRequest
=
%
p
]
\
n
"
this
aRequest
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
mDivertingFromChild
"
Cannot
call
OnStartRequest
if
diverting
is
set
!
"
)
;
if
(
mDoingCrossProcessRedirect
)
{
LOG
(
(
"
Child
was
cancelled
for
cross
-
process
redirect
.
Bail
.
"
)
)
;
return
NS_OK
;
}
RefPtr
<
HttpBaseChannel
>
chan
=
do_QueryObject
(
aRequest
)
;
if
(
!
chan
)
{
LOG
(
(
"
aRequest
is
not
HttpBaseChannel
"
)
)
;
NS_ERROR
(
"
Expecting
only
HttpBaseChannel
as
aRequest
in
"
"
HttpChannelParent
:
:
OnStartRequest
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
mChannel
=
=
chan
"
HttpChannelParent
getting
OnStartRequest
from
a
different
"
"
HttpBaseChannel
instance
"
)
;
if
(
!
mIPCClosed
)
{
PContentParent
*
pcp
=
Manager
(
)
-
>
Manager
(
)
;
MOZ_ASSERT
(
pcp
"
We
should
have
a
manager
if
our
IPC
isn
'
t
closed
"
)
;
DebugOnly
<
nsresult
>
rv
=
static_cast
<
ContentParent
*
>
(
pcp
)
-
>
AboutToLoadHttpFtpWyciwygDocumentForChild
(
chan
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
bool
isFromCache
=
false
;
uint64_t
cacheEntryId
=
0
;
int32_t
fetchCount
=
0
;
uint32_t
expirationTime
=
nsICacheEntry
:
:
NO_EXPIRATION_TIME
;
nsCString
cachedCharset
;
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
chan
)
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
IsFromCache
(
&
isFromCache
)
;
httpChannelImpl
-
>
GetCacheEntryId
(
&
cacheEntryId
)
;
httpChannelImpl
-
>
GetCacheTokenFetchCount
(
&
fetchCount
)
;
httpChannelImpl
-
>
GetCacheTokenExpirationTime
(
&
expirationTime
)
;
httpChannelImpl
-
>
GetCacheTokenCachedCharset
(
cachedCharset
)
;
}
bool
loadedFromApplicationCache
=
false
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
GetLoadedFromApplicationCache
(
&
loadedFromApplicationCache
)
;
if
(
loadedFromApplicationCache
)
{
mOfflineForeignMarker
=
httpChannelImpl
-
>
GetOfflineCacheEntryAsForeignMarker
(
)
;
nsCOMPtr
<
nsIApplicationCache
>
appCache
;
httpChannelImpl
-
>
GetApplicationCache
(
getter_AddRefs
(
appCache
)
)
;
nsCString
appCacheGroupId
;
nsCString
appCacheClientId
;
appCache
-
>
GetGroupID
(
appCacheGroupId
)
;
appCache
-
>
GetClientID
(
appCacheClientId
)
;
if
(
mIPCClosed
|
|
!
SendAssociateApplicationCache
(
appCacheGroupId
appCacheClientId
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
}
bool
applyConversion
=
true
;
Unused
<
<
chan
-
>
GetApplyConversion
(
&
applyConversion
)
;
chan
-
>
SetApplyConversion
(
false
)
;
nsresult
channelStatus
=
NS_OK
;
chan
-
>
GetStatus
(
&
channelStatus
)
;
nsCOMPtr
<
nsISupports
>
cacheEntry
;
uint32_t
cacheKey
=
0
;
nsAutoCString
altDataType
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
GetCacheToken
(
getter_AddRefs
(
cacheEntry
)
)
;
mCacheEntry
=
do_QueryInterface
(
cacheEntry
)
;
httpChannelImpl
-
>
GetCacheKey
(
&
cacheKey
)
;
httpChannelImpl
-
>
GetAlternativeDataType
(
altDataType
)
;
}
nsCString
secInfoSerialization
;
UpdateAndSerializeSecurityInfo
(
secInfoSerialization
)
;
uint8_t
redirectCount
=
0
;
chan
-
>
GetRedirectCount
(
&
redirectCount
)
;
int64_t
altDataLen
=
chan
-
>
GetAltDataLength
(
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
Unused
<
<
chan
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
;
ParentLoadInfoForwarderArgs
loadInfoForwarderArg
;
mozilla
:
:
ipc
:
:
LoadInfoToParentLoadInfoForwarder
(
loadInfo
&
loadInfoForwarderArg
)
;
nsHttpResponseHead
*
responseHead
=
chan
-
>
GetResponseHead
(
)
;
bool
useResponseHead
=
!
!
responseHead
;
nsHttpResponseHead
cleanedUpResponseHead
;
if
(
responseHead
&
&
responseHead
-
>
HasHeader
(
nsHttp
:
:
Set_Cookie
)
)
{
cleanedUpResponseHead
=
*
responseHead
;
cleanedUpResponseHead
.
ClearHeader
(
nsHttp
:
:
Set_Cookie
)
;
responseHead
=
&
cleanedUpResponseHead
;
}
if
(
!
responseHead
)
{
responseHead
=
&
cleanedUpResponseHead
;
}
nsHttpRequestHead
*
requestHead
=
chan
-
>
GetRequestHead
(
)
;
requestHead
-
>
Enter
(
)
;
nsHttpHeaderArray
cleanedUpRequestHeaders
;
bool
cleanedUpRequest
=
false
;
if
(
requestHead
-
>
HasHeader
(
nsHttp
:
:
Cookie
)
)
{
cleanedUpRequestHeaders
=
requestHead
-
>
Headers
(
)
;
cleanedUpRequestHeaders
.
ClearHeader
(
nsHttp
:
:
Cookie
)
;
cleanedUpRequest
=
true
;
}
ResourceTimingStruct
timing
;
GetTimingAttributes
(
mChannel
timing
)
;
rv
=
NS_OK
;
if
(
mIPCClosed
|
|
!
SendOnStartRequest
(
channelStatus
*
responseHead
useResponseHead
cleanedUpRequest
?
cleanedUpRequestHeaders
:
requestHead
-
>
Headers
(
)
loadInfoForwarderArg
isFromCache
mCacheEntry
?
true
:
false
cacheEntryId
fetchCount
expirationTime
cachedCharset
secInfoSerialization
chan
-
>
GetSelfAddr
(
)
chan
-
>
GetPeerAddr
(
)
redirectCount
cacheKey
altDataType
altDataLen
applyConversion
timing
)
)
{
rv
=
NS_ERROR_UNEXPECTED
;
}
requestHead
-
>
Exit
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_ASSERT
(
mBgParent
)
;
if
(
!
mBgParent
-
>
OnStartRequestSent
(
)
)
{
rv
=
NS_ERROR_UNEXPECTED
;
}
}
return
rv
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
LOG
(
(
"
HttpChannelParent
:
:
OnStopRequest
:
[
this
=
%
p
aRequest
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
aRequest
static_cast
<
uint32_t
>
(
aStatusCode
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mDoingCrossProcessRedirect
)
{
LOG
(
(
"
Child
was
cancelled
for
cross
-
process
redirect
.
Bail
.
"
)
)
;
return
NS_OK
;
}
MOZ_RELEASE_ASSERT
(
!
mDivertingFromChild
"
Cannot
call
OnStopRequest
if
diverting
is
set
!
"
)
;
ResourceTimingStruct
timing
;
GetTimingAttributes
(
mChannel
timing
)
;
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
mChannel
)
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
SetWarningReporter
(
nullptr
)
;
}
nsHttpHeaderArray
*
responseTrailer
=
mChannel
-
>
GetResponseTrailers
(
)
;
MOZ_ASSERT
(
mIPCClosed
|
|
mBgParent
)
;
if
(
mIPCClosed
|
|
!
mBgParent
|
|
!
mBgParent
-
>
OnStopRequest
(
aStatusCode
timing
responseTrailer
?
*
responseTrailer
:
nsHttpHeaderArray
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
NeedFlowControl
(
)
)
{
bool
isLocal
=
false
;
NetAddr
peerAddr
=
mChannel
-
>
GetPeerAddr
(
)
;
#
if
defined
(
XP_UNIX
)
isLocal
=
(
peerAddr
.
raw
.
family
=
=
PR_AF_LOCAL
)
;
#
endif
isLocal
=
isLocal
|
|
IsLoopBackAddress
(
&
peerAddr
)
;
if
(
!
isLocal
)
{
if
(
!
mHasSuspendedByBackPressure
)
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_BACK_PRESSURE_SUSPENSION_RATE_V2
:
:
NotSuspended
)
;
}
else
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_BACK_PRESSURE_SUSPENSION_RATE_V2
:
:
Suspended
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
if
(
NS_SUCCEEDED
(
mChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
)
)
{
nsContentPolicyType
type
=
loadInfo
?
loadInfo
-
>
InternalContentPolicyType
(
)
:
nsIContentPolicy
:
:
TYPE_OTHER
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_BACK_PRESSURE_SUSPENSION_CP_TYPE
type
)
;
}
}
}
else
{
if
(
!
mHasSuspendedByBackPressure
)
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_BACK_PRESSURE_SUSPENSION_RATE_V2
:
:
NotSuspendedLocal
)
;
}
else
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_BACK_PRESSURE_SUSPENSION_RATE_V2
:
:
SuspendedLocal
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
LOG
(
(
"
HttpChannelParent
:
:
OnDataAvailable
[
this
=
%
p
aRequest
=
%
p
offset
=
%
"
PRIu64
"
count
=
%
"
PRIu32
"
]
\
n
"
this
aRequest
aOffset
aCount
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
mDivertingFromChild
"
Cannot
call
OnDataAvailable
if
diverting
is
set
!
"
)
;
nsresult
channelStatus
=
NS_OK
;
mChannel
-
>
GetStatus
(
&
channelStatus
)
;
nsresult
transportStatus
=
NS_NET_STATUS_RECEIVING_FROM
;
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
mChannel
)
;
if
(
httpChannelImpl
&
&
httpChannelImpl
-
>
IsReadingFromCache
(
)
)
{
transportStatus
=
NS_NET_STATUS_READING
;
}
static
uint32_t
const
kCopyChunkSize
=
128
*
1024
;
uint32_t
toRead
=
std
:
:
min
<
uint32_t
>
(
aCount
kCopyChunkSize
)
;
nsCString
data
;
int32_t
count
=
static_cast
<
int32_t
>
(
aCount
)
;
while
(
aCount
)
{
nsresult
rv
=
NS_ReadInputStreamToString
(
aInputStream
data
toRead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
mIPCClosed
|
|
mBgParent
)
;
if
(
mIPCClosed
|
|
!
mBgParent
|
|
mDoingCrossProcessRedirect
|
|
!
mBgParent
-
>
OnTransportAndData
(
channelStatus
transportStatus
aOffset
toRead
data
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
aOffset
+
=
toRead
;
aCount
-
=
toRead
;
toRead
=
std
:
:
min
<
uint32_t
>
(
aCount
kCopyChunkSize
)
;
}
if
(
NeedFlowControl
(
)
)
{
if
(
mSendWindowSize
>
0
&
&
mSendWindowSize
<
=
count
)
{
MOZ_ASSERT
(
!
mSuspendedForFlowControl
)
;
LOG
(
(
"
suspend
the
channel
due
to
e10s
backpressure
"
)
)
;
Unused
<
<
mChannel
-
>
Suspend
(
)
;
mSuspendedForFlowControl
=
true
;
mHasSuspendedByBackPressure
=
true
;
}
else
if
(
!
mResumedTimestamp
.
IsNull
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
NETWORK_BACK_PRESSURE_SUSPENSION_DELAY_TIME_MS
mResumedTimestamp
)
;
mResumedTimestamp
=
TimeStamp
(
)
;
}
mSendWindowSize
-
=
count
;
}
return
NS_OK
;
}
bool
HttpChannelParent
:
:
NeedFlowControl
(
)
{
if
(
mCacheNeedFlowControlInitialized
)
{
return
mNeedFlowControl
;
}
int64_t
contentLength
=
-
1
;
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
mChannel
)
;
if
(
gHttpHandler
-
>
SendWindowSize
(
)
=
=
0
|
|
!
httpChannelImpl
|
|
httpChannelImpl
-
>
IsReadingFromCache
(
)
|
|
NS_FAILED
(
httpChannelImpl
-
>
GetContentLength
(
&
contentLength
)
)
|
|
contentLength
<
gHttpHandler
-
>
SendWindowSize
(
)
)
{
mNeedFlowControl
=
false
;
}
mCacheNeedFlowControlInitialized
=
true
;
return
mNeedFlowControl
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvBytesRead
(
const
int32_t
&
aCount
)
{
if
(
!
NeedFlowControl
(
)
|
|
mDivertingFromChild
)
{
return
IPC_OK
(
)
;
}
LOG
(
(
"
HttpChannelParent
:
:
RecvBytesRead
[
this
=
%
p
count
=
%
"
PRId32
"
]
\
n
"
this
aCount
)
)
;
if
(
mSendWindowSize
<
=
0
&
&
mSendWindowSize
+
aCount
>
0
)
{
MOZ_ASSERT
(
mSuspendedForFlowControl
)
;
LOG
(
(
"
resume
the
channel
due
to
e10s
backpressure
relief
"
)
)
;
Unused
<
<
mChannel
-
>
Resume
(
)
;
mSuspendedForFlowControl
=
false
;
mResumedTimestamp
=
TimeStamp
:
:
Now
(
)
;
}
mSendWindowSize
+
=
aCount
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvOpenOriginalCacheInputStream
(
)
{
if
(
mIPCClosed
)
{
return
IPC_OK
(
)
;
}
AutoIPCStream
autoStream
;
if
(
mCacheEntry
)
{
nsCOMPtr
<
nsIInputStream
>
inputStream
;
nsresult
rv
=
mCacheEntry
-
>
OpenInputStream
(
0
getter_AddRefs
(
inputStream
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
PContentParent
*
pcp
=
Manager
(
)
-
>
Manager
(
)
;
Unused
<
<
autoStream
.
Serialize
(
inputStream
static_cast
<
ContentParent
*
>
(
pcp
)
)
;
}
}
Unused
<
<
SendOriginalCacheInputStreamAvailable
(
autoStream
.
TakeOptionalValue
(
)
)
;
return
IPC_OK
(
)
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
OnProgress
(
nsIRequest
*
aRequest
nsISupports
*
aContext
int64_t
aProgress
int64_t
aProgressMax
)
{
LOG
(
(
"
HttpChannelParent
:
:
OnStatus
[
this
=
%
p
progress
=
%
"
PRId64
"
max
=
%
"
PRId64
"
]
\
n
"
this
aProgress
aProgressMax
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mIgnoreProgress
)
{
mIgnoreProgress
=
false
;
return
NS_OK
;
}
MOZ_ASSERT
(
mIPCClosed
|
|
mBgParent
)
;
if
(
mIPCClosed
|
|
!
mBgParent
|
|
!
mBgParent
-
>
OnProgress
(
aProgress
aProgressMax
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
OnStatus
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
const
char16_t
*
aStatusArg
)
{
LOG
(
(
"
HttpChannelParent
:
:
OnStatus
[
this
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aStatus
=
=
NS_NET_STATUS_RECEIVING_FROM
|
|
aStatus
=
=
NS_NET_STATUS_READING
)
{
mIgnoreProgress
=
true
;
return
NS_OK
;
}
MOZ_ASSERT
(
mIPCClosed
|
|
mBgParent
)
;
if
(
mIPCClosed
|
|
!
mBgParent
|
|
!
mBgParent
-
>
OnStatus
(
aStatus
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
SetParentListener
(
HttpChannelParentListener
*
aListener
)
{
LOG
(
(
"
HttpChannelParent
:
:
SetParentListener
[
this
=
%
p
aListener
=
%
p
]
\
n
"
this
aListener
)
)
;
MOZ_ASSERT
(
aListener
)
;
MOZ_ASSERT
(
!
mParentListener
"
SetParentListener
should
only
be
called
for
"
"
new
HttpChannelParents
after
a
redirect
when
"
"
mParentListener
is
null
.
"
)
;
mParentListener
=
aListener
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
NotifyChannelClassifierProtectionDisabled
(
uint32_t
aAcceptedReason
)
{
LOG
(
(
"
HttpChannelParent
:
:
NotifyChannelClassifierProtectionDisabled
[
this
=
%
p
"
"
aAcceptedReason
=
%
"
PRIu32
"
]
\
n
"
this
aAcceptedReason
)
)
;
if
(
!
mIPCClosed
)
{
MOZ_ASSERT
(
mBgParent
)
;
Unused
<
<
NS_WARN_IF
(
!
mBgParent
-
>
OnNotifyChannelClassifierProtectionDisabled
(
aAcceptedReason
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
NotifyCookieAllowed
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
NotifyCookieAllowed
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
!
mIPCClosed
)
{
MOZ_ASSERT
(
mBgParent
)
;
Unused
<
<
NS_WARN_IF
(
!
mBgParent
-
>
OnNotifyCookieAllowed
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
NotifyCookieBlocked
(
uint32_t
aRejectedReason
)
{
LOG
(
(
"
HttpChannelParent
:
:
NotifyCookieBlocked
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
!
mIPCClosed
)
{
MOZ_ASSERT
(
mBgParent
)
;
Unused
<
<
NS_WARN_IF
(
!
mBgParent
-
>
OnNotifyCookieBlocked
(
aRejectedReason
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
SetClassifierMatchedInfo
(
const
nsACString
&
aList
const
nsACString
&
aProvider
const
nsACString
&
aFullHash
)
{
LOG
(
(
"
HttpChannelParent
:
:
SetClassifierMatchedInfo
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
!
mIPCClosed
)
{
MOZ_ASSERT
(
mBgParent
)
;
Unused
<
<
mBgParent
-
>
OnSetClassifierMatchedInfo
(
aList
aProvider
aFullHash
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
NotifyTrackingResource
(
bool
aIsThirdParty
)
{
LOG
(
(
"
HttpChannelParent
:
:
NotifyTrackingResource
thirdparty
=
%
d
[
this
=
%
p
]
\
n
"
static_cast
<
int
>
(
aIsThirdParty
)
this
)
)
;
if
(
!
mIPCClosed
)
{
MOZ_ASSERT
(
mBgParent
)
;
Unused
<
<
mBgParent
-
>
OnNotifyTrackingResource
(
aIsThirdParty
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
NotifyFlashPluginStateChanged
(
nsIHttpChannel
:
:
FlashPluginState
aState
)
{
LOG
(
(
"
HttpChannelParent
:
:
NotifyFlashPluginStateChanged
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
!
mIPCClosed
)
{
MOZ_ASSERT
(
mBgParent
)
;
Unused
<
<
mBgParent
-
>
OnNotifyFlashPluginStateChanged
(
aState
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
Delete
(
)
{
if
(
!
mIPCClosed
)
Unused
<
<
DoSendDeleteSelf
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
StartRedirect
(
uint32_t
registrarId
nsIChannel
*
newChannel
uint32_t
redirectFlags
nsIAsyncVerifyRedirectCallback
*
callback
)
{
nsresult
rv
;
LOG
(
(
"
HttpChannelParent
:
:
StartRedirect
[
this
=
%
p
registrarId
=
%
"
PRIu32
"
"
"
newChannel
=
%
p
callback
=
%
p
]
\
n
"
this
registrarId
newChannel
callback
)
)
;
if
(
mIPCClosed
)
{
return
NS_BINDING_ABORTED
;
}
if
(
redirectFlags
&
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
{
nsCOMPtr
<
nsIInterceptedChannel
>
oldIntercepted
=
do_QueryInterface
(
static_cast
<
nsIChannel
*
>
(
mChannel
.
get
(
)
)
)
;
nsCOMPtr
<
nsIInterceptedChannel
>
newIntercepted
=
do_QueryInterface
(
newChannel
)
;
if
(
!
oldIntercepted
&
&
newIntercepted
)
{
nsCOMPtr
<
nsILoadInfo
>
oldLoadInfo
;
Unused
<
<
mChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
oldLoadInfo
)
)
;
nsCOMPtr
<
nsILoadInfo
>
newLoadInfo
;
Unused
<
<
newChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
newLoadInfo
)
)
;
if
(
oldLoadInfo
&
&
newLoadInfo
)
{
Maybe
<
ClientInfo
>
reservedClientInfo
(
oldLoadInfo
-
>
GetReservedClientInfo
(
)
)
;
if
(
reservedClientInfo
.
isSome
(
)
)
{
newLoadInfo
-
>
SetReservedClientInfo
(
reservedClientInfo
.
ref
(
)
)
;
}
Maybe
<
ClientInfo
>
initialClientInfo
(
oldLoadInfo
-
>
GetInitialClientInfo
(
)
)
;
if
(
initialClientInfo
.
isSome
(
)
)
{
newLoadInfo
-
>
SetInitialClientInfo
(
initialClientInfo
.
ref
(
)
)
;
}
}
nsCOMPtr
<
nsIChannel
>
linkedChannel
;
rv
=
NS_LinkRedirectChannels
(
registrarId
this
getter_AddRefs
(
linkedChannel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
linkedChannel
=
=
newChannel
)
;
mChannel
=
do_QueryObject
(
newChannel
)
;
callback
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsIURI
>
newOriginalURI
;
newChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
newOriginalURI
)
)
;
URIParams
uriParams
;
SerializeURI
(
newOriginalURI
uriParams
)
;
uint32_t
newLoadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
MOZ_ALWAYS_SUCCEEDS
(
newChannel
-
>
GetLoadFlags
(
&
newLoadFlags
)
)
;
nsCString
secInfoSerialization
;
UpdateAndSerializeSecurityInfo
(
secInfoSerialization
)
;
uint64_t
channelId
=
0
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
newChannel
)
;
if
(
httpChannel
)
{
rv
=
httpChannel
-
>
GetChannelId
(
&
channelId
)
;
NS_ENSURE_SUCCESS
(
rv
NS_BINDING_ABORTED
)
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
Unused
<
<
mChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
;
ParentLoadInfoForwarderArgs
loadInfoForwarderArg
;
mozilla
:
:
ipc
:
:
LoadInfoToParentLoadInfoForwarder
(
loadInfo
&
loadInfoForwarderArg
)
;
nsHttpResponseHead
*
responseHead
=
mChannel
-
>
GetResponseHead
(
)
;
nsHttpResponseHead
cleanedUpResponseHead
;
if
(
responseHead
&
&
responseHead
-
>
HasHeader
(
nsHttp
:
:
Set_Cookie
)
)
{
cleanedUpResponseHead
=
*
responseHead
;
cleanedUpResponseHead
.
ClearHeader
(
nsHttp
:
:
Set_Cookie
)
;
responseHead
=
&
cleanedUpResponseHead
;
}
if
(
!
responseHead
)
{
responseHead
=
&
cleanedUpResponseHead
;
}
bool
result
=
false
;
if
(
!
mIPCClosed
)
{
result
=
SendRedirect1Begin
(
registrarId
uriParams
newLoadFlags
redirectFlags
loadInfoForwarderArg
*
responseHead
secInfoSerialization
channelId
mChannel
-
>
GetPeerAddr
(
)
)
;
}
if
(
!
result
)
{
mSentRedirect1BeginFailed
=
true
;
return
NS_BINDING_ABORTED
;
}
mRedirectRegistrarId
=
registrarId
;
mRedirectChannel
=
newChannel
;
mRedirectCallback
=
callback
;
return
NS_OK
;
}
void
HttpChannelParent
:
:
CancelChildCrossProcessRedirect
(
)
{
MOZ_ASSERT
(
!
mDoingCrossProcessRedirect
"
Already
redirected
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mDoingCrossProcessRedirect
=
true
;
if
(
!
mIPCClosed
)
{
Unused
<
<
SendCancelRedirected
(
)
;
}
}
already_AddRefed
<
HttpChannelParentListener
>
HttpChannelParent
:
:
GetParentListener
(
)
{
RefPtr
<
HttpChannelParentListener
>
listener
=
mParentListener
;
return
listener
.
forget
(
)
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
CompleteRedirect
(
bool
succeeded
)
{
LOG
(
(
"
HttpChannelParent
:
:
CompleteRedirect
[
this
=
%
p
succeeded
=
%
d
]
\
n
"
this
succeeded
)
)
;
if
(
mDoingCrossProcessRedirect
)
{
LOG
(
(
"
Child
was
cancelled
for
cross
-
process
redirect
.
Bail
.
"
)
)
;
return
NS_OK
;
}
if
(
!
mRedirectChannel
)
{
return
NS_OK
;
}
if
(
succeeded
&
&
!
mIPCClosed
)
{
Unused
<
<
SendRedirect3Complete
(
)
;
}
mRedirectChannel
=
nullptr
;
return
NS_OK
;
}
nsresult
HttpChannelParent
:
:
SuspendForDiversion
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
SuspendForDiversion
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
mChannel
)
;
MOZ_ASSERT
(
mParentListener
)
;
if
(
mWillSynthesizeResponse
)
{
mPendingDiversion
=
true
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
mDivertingFromChild
)
)
{
MOZ_ASSERT
(
!
mDivertingFromChild
"
Already
suspended
for
diversion
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIChannelWithDivertableParentListener
>
divertChannel
=
do_QueryInterface
(
static_cast
<
nsIChannel
*
>
(
mChannel
.
get
(
)
)
)
;
divertChannel
-
>
MessageDiversionStarted
(
this
)
;
nsresult
rv
=
NS_OK
;
if
(
!
mSuspendAfterSynthesizeResponse
)
{
rv
=
divertChannel
-
>
SuspendInternal
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
|
|
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
;
mSuspendedForDiversion
=
NS_SUCCEEDED
(
rv
)
;
}
else
{
mSuspendedForDiversion
=
true
;
mEventQ
-
>
Resume
(
)
;
}
rv
=
mParentListener
-
>
SuspendForDiversion
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
mSuspendedForFlowControl
)
{
Unused
<
<
mChannel
-
>
Resume
(
)
;
mSuspendedForFlowControl
=
false
;
}
mDivertingFromChild
=
true
;
return
NS_OK
;
}
nsresult
HttpChannelParent
:
:
SuspendMessageDiversion
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
SuspendMessageDiversion
[
this
=
%
p
]
"
this
)
)
;
mEventQ
-
>
Suspend
(
)
;
return
NS_OK
;
}
nsresult
HttpChannelParent
:
:
ResumeMessageDiversion
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
SuspendMessageDiversion
[
this
=
%
p
]
"
this
)
)
;
mEventQ
-
>
Resume
(
)
;
return
NS_OK
;
}
nsresult
HttpChannelParent
:
:
CancelDiversion
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
CancelDiversion
[
this
=
%
p
]
"
this
)
)
;
if
(
!
mIPCClosed
)
{
Unused
<
<
SendCancelDiversion
(
)
;
}
return
NS_OK
;
}
nsresult
HttpChannelParent
:
:
ResumeForDiversion
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
ResumeForDiversion
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
mChannel
)
;
if
(
NS_WARN_IF
(
!
mDivertingFromChild
)
)
{
MOZ_ASSERT
(
mDivertingFromChild
"
Cannot
ResumeForDiversion
if
not
diverting
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIChannelWithDivertableParentListener
>
divertChannel
=
do_QueryInterface
(
static_cast
<
nsIChannel
*
>
(
mChannel
.
get
(
)
)
)
;
divertChannel
-
>
MessageDiversionStop
(
)
;
if
(
mSuspendedForDiversion
)
{
nsresult
rv
=
divertChannel
-
>
ResumeInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mSuspendedForDiversion
=
false
;
}
if
(
NS_WARN_IF
(
mIPCClosed
|
|
!
DoSendDeleteSelf
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
void
HttpChannelParent
:
:
DivertTo
(
nsIStreamListener
*
aListener
)
{
LOG
(
(
"
HttpChannelParent
:
:
DivertTo
[
this
=
%
p
aListener
=
%
p
]
\
n
"
this
aListener
)
)
;
MOZ_ASSERT
(
mParentListener
)
;
if
(
mWillSynthesizeResponse
)
{
MOZ_ASSERT
(
mPendingDiversion
)
;
mDivertListener
=
aListener
;
return
;
}
if
(
NS_WARN_IF
(
!
mDivertingFromChild
)
)
{
MOZ_ASSERT
(
mDivertingFromChild
"
Cannot
DivertTo
new
listener
if
diverting
is
not
set
!
"
)
;
return
;
}
mDivertListener
=
aListener
;
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
net
:
:
HttpChannelParent
:
:
StartDiversion
"
this
&
HttpChannelParent
:
:
StartDiversion
)
)
;
}
void
HttpChannelParent
:
:
StartDiversion
(
)
{
LOG
(
(
"
HttpChannelParent
:
:
StartDiversion
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
NS_WARN_IF
(
!
mDivertingFromChild
)
)
{
MOZ_ASSERT
(
mDivertingFromChild
"
Cannot
StartDiversion
if
diverting
is
not
set
!
"
)
;
return
;
}
if
(
mChannel
)
{
mChannel
-
>
ForcePending
(
true
)
;
}
{
AutoEventEnqueuer
ensureSerialDispatch
(
mEventQ
)
;
nsresult
rv
=
mDivertListener
-
>
OnStartRequest
(
mChannel
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
rv
)
;
}
mStatus
=
rv
;
}
}
mDivertedOnStartRequest
=
true
;
nsCOMPtr
<
nsIStreamListener
>
converterListener
;
Unused
<
<
mChannel
-
>
DoApplyContentConversions
(
mDivertListener
getter_AddRefs
(
converterListener
)
)
;
if
(
converterListener
)
{
mDivertListener
=
converterListener
.
forget
(
)
;
}
DebugOnly
<
nsresult
>
rvdbg
=
mParentListener
-
>
DivertTo
(
mDivertListener
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rvdbg
)
)
;
mDivertListener
=
nullptr
;
MOZ_ASSERT
(
mIPCClosed
|
|
mBgParent
)
;
if
(
NS_WARN_IF
(
mIPCClosed
|
|
!
mBgParent
|
|
!
mBgParent
-
>
OnDiversion
(
)
)
)
{
FailDiversion
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
}
class
HTTPFailDiversionEvent
:
public
Runnable
{
public
:
HTTPFailDiversionEvent
(
HttpChannelParent
*
aChannelParent
nsresult
aErrorCode
)
:
Runnable
(
"
net
:
:
HTTPFailDiversionEvent
"
)
mChannelParent
(
aChannelParent
)
mErrorCode
(
aErrorCode
)
{
MOZ_RELEASE_ASSERT
(
aChannelParent
)
;
MOZ_RELEASE_ASSERT
(
NS_FAILED
(
aErrorCode
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
mChannelParent
-
>
NotifyDiversionFailed
(
mErrorCode
)
;
return
NS_OK
;
}
private
:
RefPtr
<
HttpChannelParent
>
mChannelParent
;
nsresult
mErrorCode
;
}
;
void
HttpChannelParent
:
:
FailDiversion
(
nsresult
aErrorCode
)
{
MOZ_RELEASE_ASSERT
(
NS_FAILED
(
aErrorCode
)
)
;
MOZ_RELEASE_ASSERT
(
mDivertingFromChild
)
;
MOZ_RELEASE_ASSERT
(
mParentListener
)
;
MOZ_RELEASE_ASSERT
(
mChannel
)
;
NS_DispatchToCurrentThread
(
new
HTTPFailDiversionEvent
(
this
aErrorCode
)
)
;
}
void
HttpChannelParent
:
:
NotifyDiversionFailed
(
nsresult
aErrorCode
)
{
LOG
(
(
"
HttpChannelParent
:
:
NotifyDiversionFailed
[
this
=
%
p
aErrorCode
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
aErrorCode
)
)
)
;
MOZ_RELEASE_ASSERT
(
NS_FAILED
(
aErrorCode
)
)
;
MOZ_RELEASE_ASSERT
(
mDivertingFromChild
)
;
MOZ_RELEASE_ASSERT
(
mParentListener
)
;
MOZ_RELEASE_ASSERT
(
mChannel
)
;
mChannel
-
>
Cancel
(
aErrorCode
)
;
mChannel
-
>
ForcePending
(
false
)
;
bool
isPending
=
false
;
nsresult
rv
=
mChannel
-
>
IsPending
(
&
isPending
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
mSuspendedForDiversion
)
{
nsCOMPtr
<
nsIChannelWithDivertableParentListener
>
divertChannel
=
do_QueryInterface
(
static_cast
<
nsIChannel
*
>
(
mChannel
.
get
(
)
)
)
;
divertChannel
-
>
ResumeInternal
(
)
;
}
if
(
!
mDivertedOnStartRequest
)
{
mChannel
-
>
ForcePending
(
true
)
;
mParentListener
-
>
OnStartRequest
(
mChannel
nullptr
)
;
mChannel
-
>
ForcePending
(
false
)
;
}
if
(
!
isPending
)
{
mParentListener
-
>
OnStopRequest
(
mChannel
nullptr
aErrorCode
)
;
}
if
(
!
mIPCClosed
)
{
Unused
<
<
DoSendDeleteSelf
(
)
;
}
mParentListener
=
nullptr
;
mChannel
=
nullptr
;
}
nsresult
HttpChannelParent
:
:
OpenAlternativeOutputStream
(
const
nsACString
&
type
int64_t
predictedSize
nsIOutputStream
*
*
_retval
)
{
if
(
!
mCacheEntry
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
mCacheEntry
-
>
OpenAlternativeOutputStream
(
type
predictedSize
_retval
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mCacheEntry
-
>
SetMetaDataElement
(
"
alt
-
data
-
from
-
child
"
"
1
"
)
;
}
return
rv
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
GetAuthPrompt
(
uint32_t
aPromptReason
const
nsIID
&
iid
void
*
*
aResult
)
{
nsCOMPtr
<
nsIAuthPrompt2
>
prompt
=
new
NeckoParent
:
:
NestedFrameAuthPrompt
(
Manager
(
)
mNestedFrameId
)
;
prompt
.
forget
(
aResult
)
;
return
NS_OK
;
}
void
HttpChannelParent
:
:
UpdateAndSerializeSecurityInfo
(
nsACString
&
aSerializedSecurityInfoOut
)
{
nsCOMPtr
<
nsISupports
>
secInfoSupp
;
mChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
secInfoSupp
)
)
;
if
(
secInfoSupp
)
{
nsCOMPtr
<
nsISerializable
>
secInfoSer
=
do_QueryInterface
(
secInfoSupp
)
;
if
(
secInfoSer
)
{
NS_SerializeToString
(
secInfoSer
aSerializedSecurityInfoOut
)
;
}
}
}
bool
HttpChannelParent
:
:
DoSendDeleteSelf
(
)
{
mIPCClosed
=
true
;
bool
rv
=
SendDeleteSelf
(
)
;
CleanupBackgroundChannel
(
)
;
return
rv
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvDeletingChannel
(
)
{
if
(
!
DoSendDeleteSelf
(
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelParent
:
:
RecvFinishInterceptedRedirect
(
)
{
mIPCClosed
=
true
;
if
(
!
SendFinishInterceptedRedirect
(
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
return
IPC_OK
(
)
;
}
nsresult
HttpChannelParent
:
:
ReportSecurityMessage
(
const
nsAString
&
aMessageTag
const
nsAString
&
aMessageCategory
)
{
if
(
mIPCClosed
|
|
NS_WARN_IF
(
!
SendReportSecurityMessage
(
nsString
(
aMessageTag
)
nsString
(
aMessageCategory
)
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
IssueWarning
(
uint32_t
aWarning
bool
aAsError
)
{
Unused
<
<
SendIssueDeprecationWarning
(
aWarning
aAsError
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParent
:
:
ReadyToVerify
(
nsresult
aResult
)
{
LOG
(
(
"
HttpChannelParent
:
:
ReadyToVerify
[
this
=
%
p
result
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
aResult
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ContinueRedirect2Verify
(
aResult
)
;
return
NS_OK
;
}
void
HttpChannelParent
:
:
DoSendSetPriority
(
int16_t
aValue
)
{
if
(
!
mIPCClosed
)
{
Unused
<
<
SendSetPriority
(
aValue
)
;
}
}
nsresult
HttpChannelParent
:
:
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
{
if
(
mIPCClosed
|
|
NS_WARN_IF
(
!
SendLogBlockedCORSRequest
(
nsString
(
aMessage
)
nsCString
(
aCategory
)
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
nsresult
HttpChannelParent
:
:
LogMimeTypeMismatch
(
const
nsACString
&
aMessageName
bool
aWarning
const
nsAString
&
aURL
const
nsAString
&
aContentType
)
{
if
(
mIPCClosed
|
|
NS_WARN_IF
(
!
SendLogMimeTypeMismatch
(
nsCString
(
aMessageName
)
aWarning
nsString
(
aURL
)
nsString
(
aContentType
)
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
}
}
