#
ifndef
mozilla_net_ClassifierDummyChannel_h
#
define
mozilla_net_ClassifierDummyChannel_h
#
include
"
nsIChannel
.
h
"
#
include
"
nsIClassifiedChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
<
functional
>
#
define
CLASSIFIER_DUMMY_CHANNEL_IID
\
{
\
0x70ceb97d
0xbfa6
0x4255
{
\
0xb7
0x08
0xe1
0xb4
0x4a
0x1e
0x0e
0x9a
\
}
\
}
namespace
mozilla
{
namespace
net
{
class
ClassifierDummyChannel
final
:
public
nsIChannel
public
nsIHttpChannelInternal
public
nsIClassifiedChannel
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
CLASSIFIER_DUMMY_CHANNEL_IID
)
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIREQUEST
NS_DECL_NSICHANNEL
NS_DECL_NSIHTTPCHANNELINTERNAL
NS_DECL_NSICLASSIFIEDCHANNEL
enum
StorageAllowedState
{
eStorageGranted
eStorageDenied
eAsyncNeeded
}
;
static
StorageAllowedState
StorageAllowed
(
nsIChannel
*
aChannel
const
std
:
:
function
<
void
(
bool
)
>
&
aCallback
)
;
ClassifierDummyChannel
(
nsIURI
*
aURI
nsIURI
*
aTopWindowURI
nsresult
aTopWindowURIResult
nsILoadInfo
*
aLoadInfo
)
;
void
AddClassificationFlags
(
uint32_t
aClassificationFlags
bool
aThirdParty
)
;
private
:
~
ClassifierDummyChannel
(
)
;
nsCOMPtr
<
nsILoadInfo
>
mLoadInfo
;
nsCOMPtr
<
nsIURI
>
mURI
;
nsCOMPtr
<
nsIURI
>
mTopWindowURI
;
nsresult
mTopWindowURIResult
;
uint32_t
mFirstPartyClassificationFlags
;
uint32_t
mThirdPartyClassificationFlags
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
ClassifierDummyChannel
CLASSIFIER_DUMMY_CHANNEL_IID
)
}
}
#
endif
