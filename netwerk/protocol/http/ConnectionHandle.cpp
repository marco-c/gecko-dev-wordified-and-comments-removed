#
include
"
HttpLog
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
#
include
"
ConnectionHandle
.
h
"
namespace
mozilla
{
namespace
net
{
ConnectionHandle
:
:
~
ConnectionHandle
(
)
{
if
(
mConn
)
{
nsresult
rv
=
gHttpHandler
-
>
ReclaimConnection
(
mConn
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ConnectionHandle
:
:
~
ConnectionHandle
\
n
"
"
failed
to
reclaim
connection
\
n
"
)
)
;
}
}
}
NS_IMPL_ISUPPORTS0
(
ConnectionHandle
)
nsresult
ConnectionHandle
:
:
OnHeadersAvailable
(
nsAHttpTransaction
*
trans
nsHttpRequestHead
*
req
nsHttpResponseHead
*
resp
bool
*
reset
)
{
return
mConn
-
>
OnHeadersAvailable
(
trans
req
resp
reset
)
;
}
void
ConnectionHandle
:
:
CloseTransaction
(
nsAHttpTransaction
*
trans
nsresult
reason
)
{
mConn
-
>
CloseTransaction
(
trans
reason
)
;
}
nsresult
ConnectionHandle
:
:
TakeTransport
(
nsISocketTransport
*
*
aTransport
nsIAsyncInputStream
*
*
aInputStream
nsIAsyncOutputStream
*
*
aOutputStream
)
{
return
mConn
-
>
TakeTransport
(
aTransport
aInputStream
aOutputStream
)
;
}
bool
ConnectionHandle
:
:
IsPersistent
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
return
mConn
-
>
IsPersistent
(
)
;
}
bool
ConnectionHandle
:
:
IsReused
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
return
mConn
-
>
IsReused
(
)
;
}
void
ConnectionHandle
:
:
DontReuse
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
mConn
-
>
DontReuse
(
)
;
}
nsresult
ConnectionHandle
:
:
PushBack
(
const
char
*
buf
uint32_t
bufLen
)
{
return
mConn
-
>
PushBack
(
buf
bufLen
)
;
}
already_AddRefed
<
HttpConnectionBase
>
ConnectionHandle
:
:
TakeHttpConnection
(
)
{
MOZ_ASSERT
(
mConn
)
;
return
mConn
.
forget
(
)
;
}
already_AddRefed
<
HttpConnectionBase
>
ConnectionHandle
:
:
HttpConnection
(
)
{
RefPtr
<
HttpConnectionBase
>
rv
(
mConn
)
;
return
rv
.
forget
(
)
;
}
void
ConnectionHandle
:
:
TopBrowsingContextIdChanged
(
uint64_t
id
)
{
}
}
}
