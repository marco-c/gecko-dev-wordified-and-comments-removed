#
include
"
HttpLog
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsHttpChannelAuthProvider
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsIHttpAuthenticator
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIAuthPrompt2
.
h
"
#
include
"
nsIAuthPromptProvider
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsAuthInformationHolder
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
netCore
.
h
"
#
include
"
nsIHttpAuthenticableChannel
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsHttpBasicAuth
.
h
"
#
include
"
nsHttpDigestAuth
.
h
"
#
include
"
nsHttpNegotiateAuth
.
h
"
#
include
"
nsHttpNTLMAuth
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsIProxiedChannel
.
h
"
#
include
"
nsIProxyInfo
.
h
"
namespace
mozilla
{
namespace
net
{
#
define
SUBRESOURCE_AUTH_DIALOG_DISALLOW_ALL
0
#
define
SUBRESOURCE_AUTH_DIALOG_DISALLOW_CROSS_ORIGIN
1
#
define
SUBRESOURCE_AUTH_DIALOG_ALLOW_ALL
2
#
define
HTTP_AUTH_DIALOG_TOP_LEVEL_DOC
29
#
define
HTTP_AUTH_DIALOG_SAME_ORIGIN_SUBRESOURCE
30
#
define
HTTP_AUTH_DIALOG_SAME_ORIGIN_XHR
31
#
define
HTTP_AUTH_DIALOG_NON_WEB_CONTENT
32
#
define
HTTP_AUTH_BASIC_INSECURE
0
#
define
HTTP_AUTH_BASIC_SECURE
1
#
define
HTTP_AUTH_DIGEST_INSECURE
2
#
define
HTTP_AUTH_DIGEST_SECURE
3
#
define
HTTP_AUTH_NTLM_INSECURE
4
#
define
HTTP_AUTH_NTLM_SECURE
5
#
define
HTTP_AUTH_NEGOTIATE_INSECURE
6
#
define
HTTP_AUTH_NEGOTIATE_SECURE
7
#
define
MAX_DISPLAYED_USER_LENGTH
64
#
define
MAX_DISPLAYED_HOST_LENGTH
64
static
void
GetOriginAttributesSuffix
(
nsIChannel
*
aChan
nsACString
&
aSuffix
)
{
OriginAttributes
oa
;
if
(
aChan
)
{
NS_GetOriginAttributes
(
aChan
oa
)
;
}
oa
.
CreateSuffix
(
aSuffix
)
;
}
nsHttpChannelAuthProvider
:
:
nsHttpChannelAuthProvider
(
)
:
mAuthChannel
(
nullptr
)
mPort
(
-
1
)
mUsingSSL
(
false
)
mProxyUsingSSL
(
false
)
mIsPrivate
(
false
)
mProxyAuthContinuationState
(
nullptr
)
mAuthContinuationState
(
nullptr
)
mProxyAuth
(
false
)
mTriedProxyAuth
(
false
)
mTriedHostAuth
(
false
)
mSuppressDefensiveAuth
(
false
)
mCrossOrigin
(
false
)
mConnectionBased
(
false
)
mHttpHandler
(
gHttpHandler
)
{
}
nsHttpChannelAuthProvider
:
:
~
nsHttpChannelAuthProvider
(
)
{
MOZ_ASSERT
(
!
mAuthChannel
"
Disconnect
wasn
'
t
called
"
)
;
}
NS_IMETHODIMP
nsHttpChannelAuthProvider
:
:
Init
(
nsIHttpAuthenticableChannel
*
channel
)
{
MOZ_ASSERT
(
channel
"
channel
expected
!
"
)
;
mAuthChannel
=
channel
;
nsresult
rv
=
mAuthChannel
-
>
GetURI
(
getter_AddRefs
(
mURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
mAuthChannel
-
>
GetIsSSL
(
&
mUsingSSL
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIProxiedChannel
>
proxied
(
channel
)
;
if
(
proxied
)
{
nsCOMPtr
<
nsIProxyInfo
>
pi
;
rv
=
proxied
-
>
GetProxyInfo
(
getter_AddRefs
(
pi
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
pi
)
{
nsAutoCString
proxyType
;
rv
=
pi
-
>
GetType
(
proxyType
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mProxyUsingSSL
=
proxyType
.
EqualsLiteral
(
"
https
"
)
;
}
}
rv
=
mURI
-
>
GetAsciiHost
(
mHost
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
mHost
.
IsEmpty
(
)
)
return
NS_ERROR_MALFORMED_URI
;
rv
=
mURI
-
>
GetPort
(
&
mPort
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIChannel
>
bareChannel
=
do_QueryInterface
(
channel
)
;
mIsPrivate
=
NS_UsePrivateBrowsing
(
bareChannel
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannelAuthProvider
:
:
ProcessAuthentication
(
uint32_t
httpStatus
bool
SSLConnectFailed
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
ProcessAuthentication
"
"
[
this
=
%
p
channel
=
%
p
code
=
%
u
SSLConnectFailed
=
%
d
]
\
n
"
this
mAuthChannel
httpStatus
SSLConnectFailed
)
)
;
MOZ_ASSERT
(
mAuthChannel
"
Channel
not
initialized
"
)
;
nsCOMPtr
<
nsIProxyInfo
>
proxyInfo
;
nsresult
rv
=
mAuthChannel
-
>
GetProxyInfo
(
getter_AddRefs
(
proxyInfo
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
proxyInfo
)
{
mProxyInfo
=
do_QueryInterface
(
proxyInfo
)
;
if
(
!
mProxyInfo
)
return
NS_ERROR_NO_INTERFACE
;
}
nsAutoCString
challenges
;
mProxyAuth
=
(
httpStatus
=
=
407
)
;
rv
=
PrepareForAuthentication
(
mProxyAuth
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
mProxyAuth
)
{
if
(
!
UsingHttpProxy
(
)
)
{
LOG
(
(
"
rejecting
407
when
proxy
server
not
configured
!
\
n
"
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
UsingSSL
(
)
&
&
!
SSLConnectFailed
)
{
LOG
(
(
"
rejecting
407
from
origin
server
!
\
n
"
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
rv
=
mAuthChannel
-
>
GetProxyChallenges
(
challenges
)
;
}
else
rv
=
mAuthChannel
-
>
GetWWWChallenges
(
challenges
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsAutoCString
creds
;
rv
=
GetCredentials
(
challenges
.
get
(
)
mProxyAuth
creds
)
;
if
(
rv
=
=
NS_ERROR_IN_PROGRESS
)
return
rv
;
if
(
NS_FAILED
(
rv
)
)
LOG
(
(
"
unable
to
authenticate
\
n
"
)
)
;
else
{
if
(
mProxyAuth
)
rv
=
mAuthChannel
-
>
SetProxyCredentials
(
creds
)
;
else
rv
=
mAuthChannel
-
>
SetWWWCredentials
(
creds
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsHttpChannelAuthProvider
:
:
AddAuthorizationHeaders
(
bool
aDontUseCachedWWWCreds
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
AddAuthorizationHeaders
?
"
"
[
this
=
%
p
channel
=
%
p
]
\
n
"
this
mAuthChannel
)
)
;
MOZ_ASSERT
(
mAuthChannel
"
Channel
not
initialized
"
)
;
nsCOMPtr
<
nsIProxyInfo
>
proxyInfo
;
nsresult
rv
=
mAuthChannel
-
>
GetProxyInfo
(
getter_AddRefs
(
proxyInfo
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
proxyInfo
)
{
mProxyInfo
=
do_QueryInterface
(
proxyInfo
)
;
if
(
!
mProxyInfo
)
return
NS_ERROR_NO_INTERFACE
;
}
uint32_t
loadFlags
;
rv
=
mAuthChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsHttpAuthCache
*
authCache
=
gHttpHandler
-
>
AuthCache
(
mIsPrivate
)
;
const
char
*
proxyHost
=
ProxyHost
(
)
;
if
(
proxyHost
&
&
UsingHttpProxy
(
)
)
{
SetAuthorizationHeader
(
authCache
nsHttp
:
:
Proxy_Authorization
"
http
"
proxyHost
ProxyPort
(
)
nullptr
mProxyIdent
)
;
}
if
(
loadFlags
&
nsIRequest
:
:
LOAD_ANONYMOUS
)
{
LOG
(
(
"
Skipping
Authorization
header
for
anonymous
load
\
n
"
)
)
;
return
NS_OK
;
}
if
(
aDontUseCachedWWWCreds
)
{
LOG
(
(
"
Authorization
header
already
present
:
"
"
skipping
adding
auth
header
from
cache
\
n
"
)
)
;
return
NS_OK
;
}
nsAutoCString
path
scheme
;
if
(
NS_SUCCEEDED
(
GetCurrentPath
(
path
)
)
&
&
NS_SUCCEEDED
(
mURI
-
>
GetScheme
(
scheme
)
)
)
{
SetAuthorizationHeader
(
authCache
nsHttp
:
:
Authorization
scheme
.
get
(
)
Host
(
)
Port
(
)
path
.
get
(
)
mIdent
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannelAuthProvider
:
:
CheckForSuperfluousAuth
(
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
CheckForSuperfluousAuth
?
"
"
[
this
=
%
p
channel
=
%
p
]
\
n
"
this
mAuthChannel
)
)
;
MOZ_ASSERT
(
mAuthChannel
"
Channel
not
initialized
"
)
;
if
(
!
ConfirmAuth
(
"
SuperfluousAuth
"
true
)
)
{
Unused
<
<
mAuthChannel
-
>
Cancel
(
NS_ERROR_ABORT
)
;
return
NS_ERROR_ABORT
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannelAuthProvider
:
:
Cancel
(
nsresult
status
)
{
MOZ_ASSERT
(
mAuthChannel
"
Channel
not
initialized
"
)
;
if
(
mAsyncPromptAuthCancelable
)
{
mAsyncPromptAuthCancelable
-
>
Cancel
(
status
)
;
mAsyncPromptAuthCancelable
=
nullptr
;
}
if
(
mGenerateCredentialsCancelable
)
{
mGenerateCredentialsCancelable
-
>
Cancel
(
status
)
;
mGenerateCredentialsCancelable
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannelAuthProvider
:
:
Disconnect
(
nsresult
status
)
{
mAuthChannel
=
nullptr
;
if
(
mAsyncPromptAuthCancelable
)
{
mAsyncPromptAuthCancelable
-
>
Cancel
(
status
)
;
mAsyncPromptAuthCancelable
=
nullptr
;
}
if
(
mGenerateCredentialsCancelable
)
{
mGenerateCredentialsCancelable
-
>
Cancel
(
status
)
;
mGenerateCredentialsCancelable
=
nullptr
;
}
NS_IF_RELEASE
(
mProxyAuthContinuationState
)
;
NS_IF_RELEASE
(
mAuthContinuationState
)
;
return
NS_OK
;
}
static
void
ParseUserDomain
(
char16_t
*
buf
const
char16_t
*
*
user
const
char16_t
*
*
domain
)
{
char16_t
*
p
=
buf
;
while
(
*
p
&
&
*
p
!
=
'
\
\
'
)
+
+
p
;
if
(
!
*
p
)
return
;
*
p
=
'
\
0
'
;
*
domain
=
buf
;
*
user
=
p
+
1
;
}
static
void
SetIdent
(
nsHttpAuthIdentity
&
ident
uint32_t
authFlags
char16_t
*
userBuf
char16_t
*
passBuf
)
{
const
char16_t
*
user
=
userBuf
;
const
char16_t
*
domain
=
nullptr
;
if
(
authFlags
&
nsIHttpAuthenticator
:
:
IDENTITY_INCLUDES_DOMAIN
)
ParseUserDomain
(
userBuf
&
user
&
domain
)
;
DebugOnly
<
nsresult
>
rv
=
ident
.
Set
(
domain
user
passBuf
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
static
void
GetAuthPrompt
(
nsIInterfaceRequestor
*
ifreq
bool
proxyAuth
nsIAuthPrompt2
*
*
result
)
{
if
(
!
ifreq
)
return
;
uint32_t
promptReason
;
if
(
proxyAuth
)
promptReason
=
nsIAuthPromptProvider
:
:
PROMPT_PROXY
;
else
promptReason
=
nsIAuthPromptProvider
:
:
PROMPT_NORMAL
;
nsCOMPtr
<
nsIAuthPromptProvider
>
promptProvider
=
do_GetInterface
(
ifreq
)
;
if
(
promptProvider
)
promptProvider
-
>
GetAuthPrompt
(
promptReason
NS_GET_IID
(
nsIAuthPrompt2
)
reinterpret_cast
<
void
*
*
>
(
result
)
)
;
else
NS_QueryAuthPrompt2
(
ifreq
result
)
;
}
nsresult
nsHttpChannelAuthProvider
:
:
GenCredsAndSetEntry
(
nsIHttpAuthenticator
*
auth
bool
proxyAuth
const
char
*
scheme
const
char
*
host
int32_t
port
const
char
*
directory
const
char
*
realm
const
char
*
challenge
const
nsHttpAuthIdentity
&
ident
nsCOMPtr
<
nsISupports
>
&
sessionState
char
*
*
result
)
{
nsresult
rv
;
nsISupports
*
ss
=
sessionState
;
nsISupports
*
*
continuationState
;
if
(
proxyAuth
)
{
continuationState
=
&
mProxyAuthContinuationState
;
}
else
{
continuationState
=
&
mAuthContinuationState
;
}
rv
=
auth
-
>
GenerateCredentialsAsync
(
mAuthChannel
this
challenge
proxyAuth
ident
.
Domain
(
)
ident
.
User
(
)
ident
.
Password
(
)
ss
*
continuationState
getter_AddRefs
(
mGenerateCredentialsCancelable
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
NS_ERROR_IN_PROGRESS
;
}
uint32_t
generateFlags
;
rv
=
auth
-
>
GenerateCredentials
(
mAuthChannel
challenge
proxyAuth
ident
.
Domain
(
)
ident
.
User
(
)
ident
.
Password
(
)
&
ss
&
*
continuationState
&
generateFlags
result
)
;
sessionState
.
swap
(
ss
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
#
ifdef
DEBUG
LOG
(
(
"
generated
creds
:
%
s
\
n
"
*
result
)
)
;
#
endif
return
UpdateCache
(
auth
scheme
host
port
directory
realm
challenge
ident
*
result
generateFlags
sessionState
proxyAuth
)
;
}
nsresult
nsHttpChannelAuthProvider
:
:
UpdateCache
(
nsIHttpAuthenticator
*
auth
const
char
*
scheme
const
char
*
host
int32_t
port
const
char
*
directory
const
char
*
realm
const
char
*
challenge
const
nsHttpAuthIdentity
&
ident
const
char
*
creds
uint32_t
generateFlags
nsISupports
*
sessionState
bool
aProxyAuth
)
{
nsresult
rv
;
uint32_t
authFlags
;
rv
=
auth
-
>
GetAuthFlags
(
&
authFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
bool
saveCreds
=
0
!
=
(
authFlags
&
nsIHttpAuthenticator
:
:
REUSABLE_CREDENTIALS
)
;
bool
saveChallenge
=
0
!
=
(
authFlags
&
nsIHttpAuthenticator
:
:
REUSABLE_CHALLENGE
)
;
bool
saveIdentity
=
0
=
=
(
generateFlags
&
nsIHttpAuthenticator
:
:
USING_INTERNAL_IDENTITY
)
;
nsHttpAuthCache
*
authCache
=
gHttpHandler
-
>
AuthCache
(
mIsPrivate
)
;
nsAutoCString
suffix
;
if
(
!
aProxyAuth
)
{
nsCOMPtr
<
nsIChannel
>
chan
=
do_QueryInterface
(
mAuthChannel
)
;
GetOriginAttributesSuffix
(
chan
suffix
)
;
}
rv
=
authCache
-
>
SetAuthEntry
(
scheme
host
port
directory
realm
saveCreds
?
creds
:
nullptr
saveChallenge
?
challenge
:
nullptr
suffix
saveIdentity
?
&
ident
:
nullptr
sessionState
)
;
return
rv
;
}
nsresult
nsHttpChannelAuthProvider
:
:
PrepareForAuthentication
(
bool
proxyAuth
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
PrepareForAuthentication
"
"
[
this
=
%
p
channel
=
%
p
]
\
n
"
this
mAuthChannel
)
)
;
if
(
!
proxyAuth
)
{
NS_IF_RELEASE
(
mProxyAuthContinuationState
)
;
LOG
(
(
"
proxy
continuation
state
has
been
reset
"
)
)
;
}
if
(
!
UsingHttpProxy
(
)
|
|
mProxyAuthType
.
IsEmpty
(
)
)
return
NS_OK
;
nsresult
rv
;
nsCOMPtr
<
nsIHttpAuthenticator
>
precedingAuth
;
nsCString
proxyAuthType
;
rv
=
GetAuthenticator
(
mProxyAuthType
.
get
(
)
proxyAuthType
getter_AddRefs
(
precedingAuth
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
uint32_t
precedingAuthFlags
;
rv
=
precedingAuth
-
>
GetAuthFlags
(
&
precedingAuthFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
!
(
precedingAuthFlags
&
nsIHttpAuthenticator
:
:
REQUEST_BASED
)
)
{
nsAutoCString
challenges
;
rv
=
mAuthChannel
-
>
GetProxyChallenges
(
challenges
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
mAuthChannel
-
>
SetProxyCredentials
(
EmptyCString
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
LOG
(
(
"
cleared
proxy
authorization
header
"
)
)
;
}
}
return
NS_OK
;
}
nsresult
nsHttpChannelAuthProvider
:
:
GetCredentials
(
const
char
*
challenges
bool
proxyAuth
nsCString
&
creds
)
{
nsCOMPtr
<
nsIHttpAuthenticator
>
auth
;
nsAutoCString
challenge
;
nsCString
authType
;
nsISupports
*
*
currentContinuationState
;
nsCString
*
currentAuthType
;
if
(
proxyAuth
)
{
currentContinuationState
=
&
mProxyAuthContinuationState
;
currentAuthType
=
&
mProxyAuthType
;
}
else
{
currentContinuationState
=
&
mAuthContinuationState
;
currentAuthType
=
&
mAuthType
;
}
nsresult
rv
=
NS_ERROR_NOT_AVAILABLE
;
bool
gotCreds
=
false
;
for
(
const
char
*
eol
=
challenges
-
1
;
eol
;
)
{
const
char
*
p
=
eol
+
1
;
if
(
(
eol
=
strchr
(
p
'
\
n
'
)
)
!
=
nullptr
)
challenge
.
Assign
(
p
eol
-
p
)
;
else
challenge
.
Assign
(
p
)
;
rv
=
GetAuthenticator
(
challenge
.
get
(
)
authType
getter_AddRefs
(
auth
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
!
currentAuthType
-
>
IsEmpty
(
)
&
&
authType
!
=
*
currentAuthType
)
continue
;
rv
=
GetCredentialsForChallenge
(
challenge
.
get
(
)
authType
.
get
(
)
proxyAuth
auth
creds
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
gotCreds
=
true
;
*
currentAuthType
=
authType
;
break
;
}
if
(
rv
=
=
NS_ERROR_IN_PROGRESS
)
{
mCurrentChallenge
=
challenge
;
mRemainingChallenges
=
eol
?
eol
+
1
:
nullptr
;
return
rv
;
}
NS_IF_RELEASE
(
*
currentContinuationState
)
;
currentAuthType
-
>
Truncate
(
)
;
}
}
if
(
!
gotCreds
&
&
!
currentAuthType
-
>
IsEmpty
(
)
)
{
currentAuthType
-
>
Truncate
(
)
;
NS_IF_RELEASE
(
*
currentContinuationState
)
;
rv
=
GetCredentials
(
challenges
proxyAuth
creds
)
;
}
return
rv
;
}
nsresult
nsHttpChannelAuthProvider
:
:
GetAuthorizationMembers
(
bool
proxyAuth
nsACString
&
scheme
const
char
*
&
host
int32_t
&
port
nsACString
&
path
nsHttpAuthIdentity
*
&
ident
nsISupports
*
*
&
continuationState
)
{
if
(
proxyAuth
)
{
MOZ_ASSERT
(
UsingHttpProxy
(
)
"
proxyAuth
is
true
but
no
HTTP
proxy
is
configured
!
"
)
;
host
=
ProxyHost
(
)
;
port
=
ProxyPort
(
)
;
ident
=
&
mProxyIdent
;
scheme
.
AssignLiteral
(
"
http
"
)
;
continuationState
=
&
mProxyAuthContinuationState
;
}
else
{
host
=
Host
(
)
;
port
=
Port
(
)
;
ident
=
&
mIdent
;
nsresult
rv
;
rv
=
GetCurrentPath
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
mURI
-
>
GetScheme
(
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
continuationState
=
&
mAuthContinuationState
;
}
return
NS_OK
;
}
nsresult
nsHttpChannelAuthProvider
:
:
GetCredentialsForChallenge
(
const
char
*
challenge
const
char
*
authType
bool
proxyAuth
nsIHttpAuthenticator
*
auth
nsCString
&
creds
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
GetCredentialsForChallenge
"
"
[
this
=
%
p
channel
=
%
p
proxyAuth
=
%
d
challenges
=
%
s
]
\
n
"
this
mAuthChannel
proxyAuth
challenge
)
)
;
nsHttpAuthCache
*
authCache
=
gHttpHandler
-
>
AuthCache
(
mIsPrivate
)
;
uint32_t
authFlags
;
nsresult
rv
=
auth
-
>
GetAuthFlags
(
&
authFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsAutoCString
realm
;
ParseRealm
(
challenge
realm
)
;
const
char
*
host
;
int32_t
port
;
nsHttpAuthIdentity
*
ident
;
nsAutoCString
path
scheme
;
bool
identFromURI
=
false
;
nsISupports
*
*
continuationState
;
rv
=
GetAuthorizationMembers
(
proxyAuth
scheme
host
port
path
ident
continuationState
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
uint32_t
loadFlags
;
rv
=
mAuthChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsAutoCString
suffix
;
if
(
!
proxyAuth
)
{
nsCOMPtr
<
nsIChannel
>
chan
=
do_QueryInterface
(
mAuthChannel
)
;
GetOriginAttributesSuffix
(
chan
suffix
)
;
if
(
mIdent
.
IsEmpty
(
)
)
{
GetIdentityFromURI
(
authFlags
mIdent
)
;
identFromURI
=
!
mIdent
.
IsEmpty
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_AUTH_USERINFO_URI
identFromURI
)
;
}
if
(
(
loadFlags
&
nsIRequest
:
:
LOAD_ANONYMOUS
)
&
&
!
identFromURI
)
{
LOG
(
(
"
Skipping
authentication
for
anonymous
non
-
proxy
request
\
n
"
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
}
else
if
(
(
loadFlags
&
nsIRequest
:
:
LOAD_ANONYMOUS
)
&
&
!
UsingHttpProxy
(
)
)
{
LOG
(
(
"
Skipping
authentication
for
anonymous
non
-
proxy
request
\
n
"
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsHttpAuthEntry
*
entry
=
nullptr
;
Unused
<
<
authCache
-
>
GetAuthEntryForDomain
(
scheme
.
get
(
)
host
port
realm
.
get
(
)
suffix
&
entry
)
;
nsCOMPtr
<
nsISupports
>
sessionStateGrip
;
if
(
entry
)
sessionStateGrip
=
entry
-
>
mMetaData
;
bool
authAtProgress
=
!
!
*
continuationState
;
bool
identityInvalid
;
nsISupports
*
sessionState
=
sessionStateGrip
;
rv
=
auth
-
>
ChallengeReceived
(
mAuthChannel
challenge
proxyAuth
&
sessionState
&
*
continuationState
&
identityInvalid
)
;
sessionStateGrip
.
swap
(
sessionState
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
LOG
(
(
"
identity
invalid
=
%
d
\
n
"
identityInvalid
)
)
;
if
(
mConnectionBased
&
&
identityInvalid
)
{
rv
=
mAuthChannel
-
>
CloseStickyConnection
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
proxyAuth
)
{
mProxyIdent
.
Clear
(
)
;
}
}
mConnectionBased
=
!
!
(
authFlags
&
nsIHttpAuthenticator
:
:
CONNECTION_BASED
)
;
mAuthChannel
-
>
ConnectionRestartable
(
!
authAtProgress
)
;
if
(
identityInvalid
)
{
if
(
entry
)
{
if
(
ident
-
>
Equals
(
entry
-
>
Identity
(
)
)
)
{
if
(
!
identFromURI
)
{
LOG
(
(
"
clearing
bad
auth
cache
entry
\
n
"
)
)
;
authCache
-
>
ClearAuthEntry
(
scheme
.
get
(
)
host
port
realm
.
get
(
)
suffix
)
;
entry
=
nullptr
;
ident
-
>
Clear
(
)
;
}
}
else
if
(
!
identFromURI
|
|
(
nsCRT
:
:
strcmp
(
ident
-
>
User
(
)
entry
-
>
Identity
(
)
.
User
(
)
)
=
=
0
&
&
!
(
loadFlags
&
(
nsIChannel
:
:
LOAD_ANONYMOUS
|
nsIChannel
:
:
LOAD_EXPLICIT_CREDENTIALS
)
)
)
)
{
LOG
(
(
"
taking
identity
from
auth
cache
\
n
"
)
)
;
rv
=
ident
-
>
Set
(
entry
-
>
Identity
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
identFromURI
=
false
;
if
(
entry
-
>
Creds
(
)
[
0
]
!
=
'
\
0
'
)
{
LOG
(
(
"
using
cached
credentials
!
\
n
"
)
)
;
creds
.
Assign
(
entry
-
>
Creds
(
)
)
;
return
entry
-
>
AddPath
(
path
.
get
(
)
)
;
}
}
}
else
if
(
!
identFromURI
)
{
ident
-
>
Clear
(
)
;
}
if
(
!
entry
&
&
ident
-
>
IsEmpty
(
)
)
{
uint32_t
level
=
nsIAuthPrompt2
:
:
LEVEL_NONE
;
if
(
(
!
proxyAuth
&
&
mUsingSSL
)
|
|
(
proxyAuth
&
&
mProxyUsingSSL
)
)
level
=
nsIAuthPrompt2
:
:
LEVEL_SECURE
;
else
if
(
authFlags
&
nsIHttpAuthenticator
:
:
IDENTITY_ENCRYPTED
)
level
=
nsIAuthPrompt2
:
:
LEVEL_PW_ENCRYPTED
;
if
(
Telemetry
:
:
CanRecordPrereleaseData
(
)
)
{
if
(
NS_LITERAL_CSTRING
(
"
basic
"
)
.
LowerCaseEqualsASCII
(
authType
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_AUTH_TYPE_STATS
UsingSSL
(
)
?
HTTP_AUTH_BASIC_SECURE
:
HTTP_AUTH_BASIC_INSECURE
)
;
}
else
if
(
NS_LITERAL_CSTRING
(
"
digest
"
)
.
LowerCaseEqualsASCII
(
authType
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_AUTH_TYPE_STATS
UsingSSL
(
)
?
HTTP_AUTH_DIGEST_SECURE
:
HTTP_AUTH_DIGEST_INSECURE
)
;
}
else
if
(
NS_LITERAL_CSTRING
(
"
ntlm
"
)
.
LowerCaseEqualsASCII
(
authType
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_AUTH_TYPE_STATS
UsingSSL
(
)
?
HTTP_AUTH_NTLM_SECURE
:
HTTP_AUTH_NTLM_INSECURE
)
;
}
else
if
(
NS_LITERAL_CSTRING
(
"
negotiate
"
)
.
LowerCaseEqualsASCII
(
authType
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_AUTH_TYPE_STATS
UsingSSL
(
)
?
HTTP_AUTH_NEGOTIATE_SECURE
:
HTTP_AUTH_NEGOTIATE_INSECURE
)
;
}
}
if
(
BlockPrompt
(
proxyAuth
)
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
GetCredentialsForChallenge
:
"
"
Prompt
is
blocked
[
this
=
%
p
pref
=
%
d
img
-
pref
=
%
d
"
"
non
-
web
-
content
-
triggered
-
pref
=
%
d
]
\
n
"
this
StaticPrefs
:
:
network_auth_subresource_http_auth_allow
(
)
StaticPrefs
:
:
network_auth_subresource_img_cross_origin_http_auth_allow
(
)
StaticPrefs
:
:
network_auth_non_web_content_triggered_resources_http_auth_allow
(
)
)
)
;
return
NS_ERROR_ABORT
;
}
rv
=
PromptForIdentity
(
level
proxyAuth
realm
.
get
(
)
authType
authFlags
*
ident
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
identFromURI
=
false
;
}
}
if
(
identFromURI
)
{
if
(
!
ConfirmAuth
(
"
AutomaticAuth
"
false
)
)
{
rv
=
mAuthChannel
-
>
Cancel
(
NS_ERROR_ABORT
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
NS_ERROR_ABORT
;
}
}
nsCString
result
;
rv
=
GenCredsAndSetEntry
(
auth
proxyAuth
scheme
.
get
(
)
host
port
path
.
get
(
)
realm
.
get
(
)
challenge
*
ident
sessionStateGrip
getter_Copies
(
result
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
creds
=
result
;
return
rv
;
}
bool
nsHttpChannelAuthProvider
:
:
BlockPrompt
(
bool
proxyAuth
)
{
nsCOMPtr
<
nsIHttpChannelInternal
>
chanInternal
=
do_QueryInterface
(
mAuthChannel
)
;
MOZ_ASSERT
(
chanInternal
)
;
if
(
chanInternal
-
>
GetBlockAuthPrompt
(
)
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
BlockPrompt
:
Prompt
is
blocked
"
"
[
this
=
%
p
channel
=
%
p
]
\
n
"
this
mAuthChannel
)
)
;
return
true
;
}
if
(
proxyAuth
)
{
return
false
;
}
nsCOMPtr
<
nsIChannel
>
chan
=
do_QueryInterface
(
mAuthChannel
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
chan
-
>
LoadInfo
(
)
;
bool
topDoc
=
true
;
bool
xhr
=
false
;
bool
nonWebContent
=
false
;
if
(
loadInfo
-
>
GetExternalContentPolicyType
(
)
!
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
{
topDoc
=
false
;
}
if
(
!
topDoc
)
{
nsCOMPtr
<
nsIPrincipal
>
triggeringPrinc
=
loadInfo
-
>
TriggeringPrincipal
(
)
;
if
(
triggeringPrinc
-
>
IsSystemPrincipal
(
)
)
{
nonWebContent
=
true
;
}
}
if
(
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
nsIContentPolicy
:
:
TYPE_XMLHTTPREQUEST
)
{
xhr
=
true
;
}
if
(
!
topDoc
&
&
!
xhr
)
{
nsCOMPtr
<
nsIURI
>
topURI
;
Unused
<
<
chanInternal
-
>
GetTopWindowURI
(
getter_AddRefs
(
topURI
)
)
;
if
(
!
topURI
)
{
nsCOMPtr
<
nsIPrincipal
>
loadingPrinc
=
loadInfo
-
>
LoadingPrincipal
(
)
;
if
(
loadingPrinc
)
{
loadingPrinc
-
>
GetURI
(
getter_AddRefs
(
topURI
)
)
;
}
}
if
(
!
NS_SecurityCompareURIs
(
topURI
mURI
true
)
)
{
mCrossOrigin
=
true
;
}
}
if
(
Telemetry
:
:
CanRecordPrereleaseData
(
)
)
{
if
(
topDoc
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_AUTH_DIALOG_STATS_3
HTTP_AUTH_DIALOG_TOP_LEVEL_DOC
)
;
}
else
if
(
nonWebContent
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_AUTH_DIALOG_STATS_3
HTTP_AUTH_DIALOG_NON_WEB_CONTENT
)
;
}
else
if
(
!
mCrossOrigin
)
{
if
(
xhr
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_AUTH_DIALOG_STATS_3
HTTP_AUTH_DIALOG_SAME_ORIGIN_XHR
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_AUTH_DIALOG_STATS_3
HTTP_AUTH_DIALOG_SAME_ORIGIN_SUBRESOURCE
)
;
}
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_AUTH_DIALOG_STATS_3
loadInfo
-
>
GetExternalContentPolicyType
(
)
)
;
}
}
if
(
!
topDoc
&
&
!
StaticPrefs
:
:
network_auth_non_web_content_triggered_resources_http_auth_allow
(
)
&
&
nonWebContent
)
{
return
true
;
}
switch
(
StaticPrefs
:
:
network_auth_subresource_http_auth_allow
(
)
)
{
case
SUBRESOURCE_AUTH_DIALOG_DISALLOW_ALL
:
return
!
topDoc
&
&
!
xhr
;
case
SUBRESOURCE_AUTH_DIALOG_DISALLOW_CROSS_ORIGIN
:
return
!
topDoc
&
&
!
xhr
&
&
mCrossOrigin
;
case
SUBRESOURCE_AUTH_DIALOG_ALLOW_ALL
:
if
(
mCrossOrigin
&
&
!
StaticPrefs
:
:
network_auth_subresource_img_cross_origin_http_auth_allow
(
)
&
&
loadInfo
&
&
(
(
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
nsIContentPolicy
:
:
TYPE_IMAGE
)
|
|
(
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
nsIContentPolicy
:
:
TYPE_IMAGESET
)
)
)
{
return
true
;
}
return
false
;
default
:
MOZ_ASSERT
(
false
"
A
non
valid
value
!
"
)
;
}
return
false
;
}
inline
void
GetAuthType
(
const
char
*
challenge
nsCString
&
authType
)
{
const
char
*
p
;
if
(
(
p
=
strchr
(
challenge
'
'
)
)
!
=
nullptr
)
authType
.
Assign
(
challenge
p
-
challenge
)
;
else
authType
.
Assign
(
challenge
)
;
}
nsresult
nsHttpChannelAuthProvider
:
:
GetAuthenticator
(
const
char
*
challenge
nsCString
&
authType
nsIHttpAuthenticator
*
*
auth
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
GetAuthenticator
[
this
=
%
p
channel
=
%
p
]
\
n
"
this
mAuthChannel
)
)
;
GetAuthType
(
challenge
authType
)
;
ToLowerCase
(
authType
)
;
nsCOMPtr
<
nsIHttpAuthenticator
>
authenticator
;
if
(
authType
.
EqualsLiteral
(
"
negotiate
"
)
)
{
authenticator
=
nsHttpNegotiateAuth
:
:
GetOrCreate
(
)
;
}
else
if
(
authType
.
EqualsLiteral
(
"
basic
"
)
)
{
authenticator
=
nsHttpBasicAuth
:
:
GetOrCreate
(
)
;
}
else
if
(
authType
.
EqualsLiteral
(
"
digest
"
)
)
{
authenticator
=
nsHttpDigestAuth
:
:
GetOrCreate
(
)
;
}
else
if
(
authType
.
EqualsLiteral
(
"
ntlm
"
)
)
{
authenticator
=
nsHttpNTLMAuth
:
:
GetOrCreate
(
)
;
}
else
{
return
NS_ERROR_FACTORY_NOT_REGISTERED
;
}
MOZ_ASSERT
(
authenticator
)
;
authenticator
.
forget
(
auth
)
;
return
NS_OK
;
}
void
nsHttpChannelAuthProvider
:
:
GetIdentityFromURI
(
uint32_t
authFlags
nsHttpAuthIdentity
&
ident
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
GetIdentityFromURI
[
this
=
%
p
channel
=
%
p
]
\
n
"
this
mAuthChannel
)
)
;
nsAutoString
userBuf
;
nsAutoString
passBuf
;
nsAutoCString
buf
;
mURI
-
>
GetUsername
(
buf
)
;
if
(
!
buf
.
IsEmpty
(
)
)
{
NS_UnescapeURL
(
buf
)
;
CopyUTF8toUTF16
(
buf
userBuf
)
;
mURI
-
>
GetPassword
(
buf
)
;
if
(
!
buf
.
IsEmpty
(
)
)
{
NS_UnescapeURL
(
buf
)
;
CopyUTF8toUTF16
(
buf
passBuf
)
;
}
}
if
(
!
userBuf
.
IsEmpty
(
)
)
{
SetIdent
(
ident
authFlags
(
char16_t
*
)
userBuf
.
get
(
)
(
char16_t
*
)
passBuf
.
get
(
)
)
;
}
}
void
nsHttpChannelAuthProvider
:
:
ParseRealm
(
const
char
*
challenge
nsACString
&
realm
)
{
const
char
*
p
=
PL_strcasestr
(
challenge
"
realm
=
"
)
;
if
(
p
)
{
bool
has_quote
=
false
;
p
+
=
6
;
if
(
*
p
=
=
'
"
'
)
{
has_quote
=
true
;
p
+
+
;
}
const
char
*
end
;
if
(
has_quote
)
{
end
=
p
;
while
(
*
end
)
{
if
(
*
end
=
=
'
\
\
'
)
{
if
(
!
*
+
+
end
)
break
;
}
else
if
(
*
end
=
=
'
\
"
'
)
break
;
realm
.
Append
(
*
end
)
;
+
+
end
;
}
}
else
{
end
=
strchr
(
p
'
'
)
;
if
(
end
)
realm
.
Assign
(
p
end
-
p
)
;
else
realm
.
Assign
(
p
)
;
}
}
}
class
nsHTTPAuthInformation
:
public
nsAuthInformationHolder
{
public
:
nsHTTPAuthInformation
(
uint32_t
aFlags
const
nsString
&
aRealm
const
nsCString
&
aAuthType
)
:
nsAuthInformationHolder
(
aFlags
aRealm
aAuthType
)
{
}
void
SetToHttpAuthIdentity
(
uint32_t
authFlags
nsHttpAuthIdentity
&
identity
)
;
}
;
void
nsHTTPAuthInformation
:
:
SetToHttpAuthIdentity
(
uint32_t
authFlags
nsHttpAuthIdentity
&
identity
)
{
DebugOnly
<
nsresult
>
rv
=
identity
.
Set
(
Domain
(
)
.
get
(
)
User
(
)
.
get
(
)
Password
(
)
.
get
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsresult
nsHttpChannelAuthProvider
:
:
PromptForIdentity
(
uint32_t
level
bool
proxyAuth
const
char
*
realm
const
char
*
authType
uint32_t
authFlags
nsHttpAuthIdentity
&
ident
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
PromptForIdentity
[
this
=
%
p
channel
=
%
p
]
\
n
"
this
mAuthChannel
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
rv
=
mAuthChannel
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
rv
=
mAuthChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIAuthPrompt2
>
authPrompt
;
GetAuthPrompt
(
callbacks
proxyAuth
getter_AddRefs
(
authPrompt
)
)
;
if
(
!
authPrompt
&
&
loadGroup
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
cbs
;
loadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
cbs
)
)
;
GetAuthPrompt
(
cbs
proxyAuth
getter_AddRefs
(
authPrompt
)
)
;
}
if
(
!
authPrompt
)
return
NS_ERROR_NO_INTERFACE
;
NS_ConvertASCIItoUTF16
realmU
(
realm
)
;
uint32_t
promptFlags
=
0
;
if
(
proxyAuth
)
{
promptFlags
|
=
nsIAuthInformation
:
:
AUTH_PROXY
;
if
(
mTriedProxyAuth
)
promptFlags
|
=
nsIAuthInformation
:
:
PREVIOUS_FAILED
;
mTriedProxyAuth
=
true
;
}
else
{
promptFlags
|
=
nsIAuthInformation
:
:
AUTH_HOST
;
if
(
mTriedHostAuth
)
promptFlags
|
=
nsIAuthInformation
:
:
PREVIOUS_FAILED
;
mTriedHostAuth
=
true
;
}
if
(
authFlags
&
nsIHttpAuthenticator
:
:
IDENTITY_INCLUDES_DOMAIN
)
promptFlags
|
=
nsIAuthInformation
:
:
NEED_DOMAIN
;
if
(
mCrossOrigin
)
{
promptFlags
|
=
nsIAuthInformation
:
:
CROSS_ORIGIN_SUB_RESOURCE
;
}
RefPtr
<
nsHTTPAuthInformation
>
holder
=
new
nsHTTPAuthInformation
(
promptFlags
realmU
nsDependentCString
(
authType
)
)
;
if
(
!
holder
)
return
NS_ERROR_OUT_OF_MEMORY
;
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
mAuthChannel
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
authPrompt
-
>
AsyncPromptAuth
(
channel
this
nullptr
level
holder
getter_AddRefs
(
mAsyncPromptAuthCancelable
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
NS_ERROR_IN_PROGRESS
;
}
else
{
bool
retval
=
false
;
rv
=
authPrompt
-
>
PromptAuth
(
channel
level
holder
&
retval
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
!
retval
)
rv
=
NS_ERROR_ABORT
;
else
holder
-
>
SetToHttpAuthIdentity
(
authFlags
ident
)
;
}
if
(
!
proxyAuth
)
mSuppressDefensiveAuth
=
true
;
if
(
mConnectionBased
)
{
{
DebugOnly
<
nsresult
>
rv
=
mAuthChannel
-
>
CloseStickyConnection
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsHttpChannelAuthProvider
:
:
OnAuthAvailable
(
nsISupports
*
aContext
nsIAuthInformation
*
aAuthInfo
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
OnAuthAvailable
[
this
=
%
p
channel
=
%
p
]
"
this
mAuthChannel
)
)
;
mAsyncPromptAuthCancelable
=
nullptr
;
if
(
!
mAuthChannel
)
return
NS_OK
;
nsresult
rv
;
const
char
*
host
;
int32_t
port
;
nsHttpAuthIdentity
*
ident
;
nsAutoCString
path
scheme
;
nsISupports
*
*
continuationState
;
rv
=
GetAuthorizationMembers
(
mProxyAuth
scheme
host
port
path
ident
continuationState
)
;
if
(
NS_FAILED
(
rv
)
)
OnAuthCancelled
(
aContext
false
)
;
nsAutoCString
realm
;
ParseRealm
(
mCurrentChallenge
.
get
(
)
realm
)
;
nsCOMPtr
<
nsIChannel
>
chan
=
do_QueryInterface
(
mAuthChannel
)
;
nsAutoCString
suffix
;
if
(
!
mProxyAuth
)
{
GetOriginAttributesSuffix
(
chan
suffix
)
;
}
nsHttpAuthCache
*
authCache
=
gHttpHandler
-
>
AuthCache
(
mIsPrivate
)
;
nsHttpAuthEntry
*
entry
=
nullptr
;
Unused
<
<
authCache
-
>
GetAuthEntryForDomain
(
scheme
.
get
(
)
host
port
realm
.
get
(
)
suffix
&
entry
)
;
nsCOMPtr
<
nsISupports
>
sessionStateGrip
;
if
(
entry
)
sessionStateGrip
=
entry
-
>
mMetaData
;
nsAuthInformationHolder
*
holder
=
static_cast
<
nsAuthInformationHolder
*
>
(
aAuthInfo
)
;
rv
=
ident
-
>
Set
(
holder
-
>
Domain
(
)
.
get
(
)
holder
-
>
User
(
)
.
get
(
)
holder
-
>
Password
(
)
.
get
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsAutoCString
unused
;
nsCOMPtr
<
nsIHttpAuthenticator
>
auth
;
rv
=
GetAuthenticator
(
mCurrentChallenge
.
get
(
)
unused
getter_AddRefs
(
auth
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
false
"
GetAuthenticator
failed
"
)
;
OnAuthCancelled
(
aContext
true
)
;
return
NS_OK
;
}
nsCString
creds
;
rv
=
GenCredsAndSetEntry
(
auth
mProxyAuth
scheme
.
get
(
)
host
port
path
.
get
(
)
realm
.
get
(
)
mCurrentChallenge
.
get
(
)
*
ident
sessionStateGrip
getter_Copies
(
creds
)
)
;
mCurrentChallenge
.
Truncate
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnAuthCancelled
(
aContext
true
)
;
return
NS_OK
;
}
return
ContinueOnAuthAvailable
(
creds
)
;
}
NS_IMETHODIMP
nsHttpChannelAuthProvider
:
:
OnAuthCancelled
(
nsISupports
*
aContext
bool
userCancel
)
{
LOG
(
(
"
nsHttpChannelAuthProvider
:
:
OnAuthCancelled
[
this
=
%
p
channel
=
%
p
]
"
this
mAuthChannel
)
)
;
mAsyncPromptAuthCancelable
=
nullptr
;
if
(
!
mAuthChannel
)
return
NS_OK
;
nsresult
rv
;
if
(
mConnectionBased
)
{
rv
=
mAuthChannel
-
>
CloseStickyConnection
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mConnectionBased
=
false
;
}
if
(
userCancel
)
{
if
(
!
mRemainingChallenges
.
IsEmpty
(
)
)
{
if
(
mProxyAuth
)
{
NS_IF_RELEASE
(
mProxyAuthContinuationState
)
;
}
else
{
NS_IF_RELEASE
(
mAuthContinuationState
)
;
}
nsAutoCString
creds
;
rv
=
GetCredentials
(
mRemainingChallenges
.
get
(
)
mProxyAuth
creds
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mRemainingChallenges
.
Truncate
(
)
;
return
ContinueOnAuthAvailable
(
creds
)
;
}
if
(
rv
=
=
NS_ERROR_IN_PROGRESS
)
{
return
NS_OK
;
}
}
mRemainingChallenges
.
Truncate
(
)
;
}
rv
=
mAuthChannel
-
>
OnAuthCancelled
(
userCancel
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannelAuthProvider
:
:
OnCredsGenerated
(
const
char
*
aGeneratedCreds
uint32_t
aFlags
nsresult
aResult
nsISupports
*
aSessionState
nsISupports
*
aContinuationState
)
{
nsresult
rv
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mAuthChannel
)
{
return
NS_OK
;
}
mGenerateCredentialsCancelable
=
nullptr
;
if
(
NS_FAILED
(
aResult
)
)
{
return
OnAuthCancelled
(
nullptr
true
)
;
}
nsCOMPtr
<
nsISupports
>
contState
(
aContinuationState
)
;
if
(
mProxyAuth
)
{
contState
.
swap
(
mProxyAuthContinuationState
)
;
}
else
{
contState
.
swap
(
mAuthContinuationState
)
;
}
nsCOMPtr
<
nsIHttpAuthenticator
>
auth
;
nsAutoCString
unused
;
rv
=
GetAuthenticator
(
mCurrentChallenge
.
get
(
)
unused
getter_AddRefs
(
auth
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
char
*
host
;
int32_t
port
;
nsHttpAuthIdentity
*
ident
;
nsAutoCString
directory
scheme
;
nsISupports
*
*
unusedContinuationState
;
nsAutoCString
realm
;
ParseRealm
(
mCurrentChallenge
.
get
(
)
realm
)
;
rv
=
GetAuthorizationMembers
(
mProxyAuth
scheme
host
port
directory
ident
unusedContinuationState
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
UpdateCache
(
auth
scheme
.
get
(
)
host
port
directory
.
get
(
)
realm
.
get
(
)
mCurrentChallenge
.
get
(
)
*
ident
aGeneratedCreds
aFlags
aSessionState
mProxyAuth
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mCurrentChallenge
.
Truncate
(
)
;
rv
=
ContinueOnAuthAvailable
(
nsDependentCString
(
aGeneratedCreds
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
NS_OK
;
}
nsresult
nsHttpChannelAuthProvider
:
:
ContinueOnAuthAvailable
(
const
nsACString
&
creds
)
{
nsresult
rv
;
if
(
mProxyAuth
)
rv
=
mAuthChannel
-
>
SetProxyCredentials
(
creds
)
;
else
rv
=
mAuthChannel
-
>
SetWWWCredentials
(
creds
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mRemainingChallenges
.
Truncate
(
)
;
Unused
<
<
mAuthChannel
-
>
OnAuthAvailable
(
)
;
return
NS_OK
;
}
void
nsHttpChannelAuthProvider
:
:
RecordConfirmAuthTelemetry
(
const
char
*
aType
)
{
if
(
nsCRT
:
:
strcmp
(
aType
"
SuperfluousAuth
"
)
)
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_HTTP_AUTH_CONFIRM_PROMPT
:
:
Superfluous
)
;
}
else
if
(
nsCRT
:
:
strcmp
(
aType
"
AutomaticAuth
"
)
)
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_HTTP_AUTH_CONFIRM_PROMPT
:
:
Automatic
)
;
}
}
bool
nsHttpChannelAuthProvider
:
:
ConfirmAuth
(
const
char
*
bundleKey
bool
doYesNoPrompt
)
{
uint32_t
loadFlags
;
nsresult
rv
=
mAuthChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
true
;
if
(
mSuppressDefensiveAuth
|
|
!
(
loadFlags
&
nsIChannel
:
:
LOAD_INITIAL_DOCUMENT_URI
)
)
return
true
;
nsAutoCString
userPass
;
rv
=
mURI
-
>
GetUserPass
(
userPass
)
;
if
(
NS_FAILED
(
rv
)
|
|
(
userPass
.
Length
(
)
<
gHttpHandler
-
>
PhishyUserPassLength
(
)
)
)
return
true
;
if
(
!
StaticPrefs
:
:
network_auth_confirmAuth_enabled
(
)
)
{
RecordConfirmAuthTelemetry
(
bundleKey
)
;
return
true
;
}
nsCOMPtr
<
nsIStringBundleService
>
bundleService
=
do_GetService
(
NS_STRINGBUNDLE_CONTRACTID
)
;
if
(
!
bundleService
)
return
true
;
nsCOMPtr
<
nsIStringBundle
>
bundle
;
bundleService
-
>
CreateBundle
(
NECKO_MSGS_URL
getter_AddRefs
(
bundle
)
)
;
if
(
!
bundle
)
return
true
;
nsAutoCString
host
;
rv
=
mURI
-
>
GetHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
return
true
;
nsAutoCString
user
;
rv
=
mURI
-
>
GetUsername
(
user
)
;
if
(
NS_FAILED
(
rv
)
)
return
true
;
NS_ConvertUTF8toUTF16
ucsHost
(
host
)
ucsUser
(
user
)
;
size_t
userLength
=
ucsUser
.
Length
(
)
;
if
(
userLength
>
MAX_DISPLAYED_USER_LENGTH
)
{
size_t
desiredLength
=
MAX_DISPLAYED_USER_LENGTH
;
if
(
NS_IS_LOW_SURROGATE
(
ucsUser
[
desiredLength
]
)
)
{
desiredLength
+
+
;
}
ucsUser
.
Replace
(
desiredLength
userLength
-
desiredLength
nsContentUtils
:
:
GetLocalizedEllipsis
(
)
)
;
}
size_t
hostLen
=
ucsHost
.
Length
(
)
;
if
(
hostLen
>
MAX_DISPLAYED_HOST_LENGTH
)
{
size_t
cutPoint
=
hostLen
-
MAX_DISPLAYED_HOST_LENGTH
;
if
(
NS_IS_LOW_SURROGATE
(
ucsHost
[
cutPoint
]
)
)
{
cutPoint
-
-
;
}
if
(
cutPoint
>
0
)
{
ucsHost
.
Replace
(
0
cutPoint
nsContentUtils
:
:
GetLocalizedEllipsis
(
)
)
;
}
}
AutoTArray
<
nsString
2
>
strs
=
{
ucsHost
ucsUser
}
;
nsAutoString
msg
;
rv
=
bundle
-
>
FormatStringFromName
(
bundleKey
strs
msg
)
;
if
(
NS_FAILED
(
rv
)
)
return
true
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
rv
=
mAuthChannel
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
true
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
rv
=
mAuthChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
true
;
nsCOMPtr
<
nsIPrompt
>
prompt
;
NS_QueryNotificationCallbacks
(
callbacks
loadGroup
NS_GET_IID
(
nsIPrompt
)
getter_AddRefs
(
prompt
)
)
;
if
(
!
prompt
)
return
true
;
mSuppressDefensiveAuth
=
true
;
bool
confirmed
;
if
(
doYesNoPrompt
)
{
int32_t
choice
;
bool
checkState
=
false
;
rv
=
prompt
-
>
ConfirmEx
(
nullptr
msg
.
get
(
)
nsIPrompt
:
:
BUTTON_POS_1_DEFAULT
+
nsIPrompt
:
:
STD_YES_NO_BUTTONS
nullptr
nullptr
nullptr
nullptr
&
checkState
&
choice
)
;
if
(
NS_FAILED
(
rv
)
)
return
true
;
confirmed
=
choice
=
=
0
;
}
else
{
rv
=
prompt
-
>
Confirm
(
nullptr
msg
.
get
(
)
&
confirmed
)
;
if
(
NS_FAILED
(
rv
)
)
return
true
;
}
RecordConfirmAuthTelemetry
(
bundleKey
)
;
return
confirmed
;
}
void
nsHttpChannelAuthProvider
:
:
SetAuthorizationHeader
(
nsHttpAuthCache
*
authCache
nsHttpAtom
header
const
char
*
scheme
const
char
*
host
int32_t
port
const
char
*
path
nsHttpAuthIdentity
&
ident
)
{
nsHttpAuthEntry
*
entry
=
nullptr
;
nsresult
rv
;
nsISupports
*
*
continuationState
;
nsAutoCString
suffix
;
if
(
header
=
=
nsHttp
:
:
Proxy_Authorization
)
{
continuationState
=
&
mProxyAuthContinuationState
;
if
(
mProxyInfo
)
{
nsAutoCString
type
;
mProxyInfo
-
>
GetType
(
type
)
;
if
(
type
.
EqualsLiteral
(
"
https
"
)
)
{
auto
const
&
pa
=
mProxyInfo
-
>
ProxyAuthorizationHeader
(
)
;
if
(
!
pa
.
IsEmpty
(
)
)
{
rv
=
mAuthChannel
-
>
SetProxyCredentials
(
pa
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
}
}
else
{
continuationState
=
&
mAuthContinuationState
;
nsCOMPtr
<
nsIChannel
>
chan
=
do_QueryInterface
(
mAuthChannel
)
;
GetOriginAttributesSuffix
(
chan
suffix
)
;
}
rv
=
authCache
-
>
GetAuthEntryForPath
(
scheme
host
port
path
suffix
&
entry
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
header
=
=
nsHttp
:
:
Authorization
&
&
entry
-
>
Domain
(
)
[
0
]
=
=
'
\
0
'
)
{
GetIdentityFromURI
(
0
ident
)
;
if
(
nsCRT
:
:
strcmp
(
ident
.
User
(
)
entry
-
>
User
(
)
)
=
=
0
)
{
uint32_t
loadFlags
;
if
(
NS_SUCCEEDED
(
mAuthChannel
-
>
GetLoadFlags
(
&
loadFlags
)
)
&
&
!
(
loadFlags
&
nsIChannel
:
:
LOAD_EXPLICIT_CREDENTIALS
)
)
{
ident
.
Clear
(
)
;
}
}
}
bool
identFromURI
;
if
(
ident
.
IsEmpty
(
)
)
{
rv
=
ident
.
Set
(
entry
-
>
Identity
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
identFromURI
=
false
;
}
else
identFromURI
=
true
;
nsCString
temp
;
const
char
*
creds
=
entry
-
>
Creds
(
)
;
const
char
*
challenge
=
entry
-
>
Challenge
(
)
;
if
(
(
!
creds
[
0
]
|
|
identFromURI
)
&
&
challenge
[
0
]
)
{
nsCOMPtr
<
nsIHttpAuthenticator
>
auth
;
nsAutoCString
unused
;
rv
=
GetAuthenticator
(
challenge
unused
getter_AddRefs
(
auth
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
proxyAuth
=
(
header
=
=
nsHttp
:
:
Proxy_Authorization
)
;
rv
=
GenCredsAndSetEntry
(
auth
proxyAuth
scheme
host
port
path
entry
-
>
Realm
(
)
challenge
ident
entry
-
>
mMetaData
getter_Copies
(
temp
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
creds
=
temp
.
get
(
)
;
NS_IF_RELEASE
(
*
continuationState
)
;
}
}
if
(
creds
[
0
]
)
{
LOG
(
(
"
adding
\
"
%
s
\
"
request
header
\
n
"
header
.
get
(
)
)
)
;
if
(
header
=
=
nsHttp
:
:
Proxy_Authorization
)
{
rv
=
mAuthChannel
-
>
SetProxyCredentials
(
nsDependentCString
(
creds
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
else
{
rv
=
mAuthChannel
-
>
SetWWWCredentials
(
nsDependentCString
(
creds
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
if
(
header
=
=
nsHttp
:
:
Authorization
)
mSuppressDefensiveAuth
=
true
;
}
else
ident
.
Clear
(
)
;
}
}
nsresult
nsHttpChannelAuthProvider
:
:
GetCurrentPath
(
nsACString
&
path
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURL
>
url
=
do_QueryInterface
(
mURI
)
;
if
(
url
)
rv
=
url
-
>
GetDirectory
(
path
)
;
else
rv
=
mURI
-
>
GetPathQueryRef
(
path
)
;
return
rv
;
}
NS_IMPL_ISUPPORTS
(
nsHttpChannelAuthProvider
nsICancelable
nsIHttpChannelAuthProvider
nsIAuthPromptCallback
nsIHttpAuthenticatorCallback
)
}
}
