#
ifndef
mozilla_net_PackagedAppService_h
#
define
mozilla_net_PackagedAppService_h
#
include
"
nsIPackagedAppService
.
h
"
#
include
"
nsILoadContextInfo
.
h
"
#
include
"
nsICacheStorage
.
h
"
#
include
"
PackagedAppVerifier
.
h
"
#
include
"
nsIMultiPartChannel
.
h
"
#
include
"
PackagedAppVerifier
.
h
"
namespace
mozilla
{
namespace
net
{
class
nsHttpResponseHead
;
class
PackagedAppService
final
:
public
nsIPackagedAppService
{
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIPACKAGEDAPPSERVICE
PackagedAppService
(
)
;
private
:
~
PackagedAppService
(
)
;
nsresult
NotifyPackageDownloaded
(
nsCString
aKey
)
;
static
nsresult
GetPackageURI
(
nsIURI
*
aUri
nsIURI
*
*
aPackageURI
)
;
class
CacheEntryWriter
final
:
public
nsIStreamListener
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
static
nsresult
Create
(
nsIURI
*
nsICacheStorage
*
CacheEntryWriter
*
*
)
;
nsCOMPtr
<
nsICacheEntry
>
mEntry
;
NS_METHOD
ConsumeData
(
const
char
*
aBuf
uint32_t
aCount
uint32_t
*
aWriteCount
)
;
private
:
CacheEntryWriter
(
)
{
}
~
CacheEntryWriter
(
)
{
}
nsresult
CopySecurityInfo
(
nsIChannel
*
aChannel
)
;
static
nsresult
CopyHeadersFromChannel
(
nsIChannel
*
aChannel
nsHttpResponseHead
*
aHead
)
;
nsCOMPtr
<
nsIOutputStream
>
mOutputStream
;
}
;
class
PackagedAppDownloader
final
:
public
nsIStreamListener
public
nsIPackagedAppVerifierListener
{
public
:
typedef
PackagedAppVerifier
:
:
ResourceCacheInfo
ResourceCacheInfo
;
private
:
enum
EErrorType
{
ERROR_MANIFEST_VERIFIED_FAILED
ERROR_RESOURCE_VERIFIED_FAILED
ERROR_GET_INSTALLER_FAILED
ERROR_INSTALL_RESOURCE_FAILED
}
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSIPACKAGEDAPPVERIFIERLISTENER
nsresult
Init
(
nsILoadContextInfo
*
aInfo
const
nsCString
&
aKey
const
nsACString
&
aPackageOrigin
)
;
nsresult
AddCallback
(
nsIURI
*
aURI
nsICacheEntryOpenCallback
*
aCallback
)
;
nsresult
RemoveCallbacks
(
nsICacheEntryOpenCallback
*
aCallback
)
;
void
SetIsFromCache
(
bool
aFromCache
)
{
mIsFromCache
=
aFromCache
;
}
void
NotifyOnStartSignedPackageRequest
(
const
nsACString
&
PackageOrigin
)
;
private
:
~
PackagedAppDownloader
(
)
{
}
static
NS_METHOD
ConsumeData
(
nsIInputStream
*
aStream
void
*
aClosure
const
char
*
aFromRawSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
;
virtual
void
OnManifestVerified
(
const
ResourceCacheInfo
*
aInfo
bool
aSuccess
)
;
virtual
void
OnResourceVerified
(
const
ResourceCacheInfo
*
aInfo
bool
aSuccess
)
;
void
OnError
(
EErrorType
aError
)
;
void
FinalizeDownload
(
nsresult
aStatusCode
)
;
nsCString
GetSignatureFromChannel
(
nsIMultiPartChannel
*
aChannel
)
;
nsresult
BeginHashComputation
(
nsIURI
*
aURI
nsIRequest
*
aRequest
)
;
void
EnsureVerifier
(
nsIRequest
*
aRequest
)
;
void
InstallSignedPackagedApp
(
const
ResourceCacheInfo
*
aInfo
)
;
nsresult
CallCallbacks
(
nsIURI
*
aURI
nsICacheEntry
*
aEntry
nsresult
aResult
)
;
nsresult
ClearCallbacks
(
nsresult
aResult
)
;
static
nsresult
GetSubresourceURI
(
nsIRequest
*
aRequest
nsIURI
*
*
aResult
)
;
nsRefPtr
<
CacheEntryWriter
>
mWriter
;
nsCOMPtr
<
nsICacheStorage
>
mCacheStorage
;
nsClassHashtable
<
nsCStringHashKey
nsCOMArray
<
nsICacheEntryOpenCallback
>
>
mCallbacks
;
nsCString
mPackageKey
;
bool
mIsFromCache
;
nsRefPtr
<
PackagedAppVerifier
>
mVerifier
;
nsCString
mPackageOrigin
;
uint32_t
mAppId
;
bool
mProcessingFirstRequest
;
nsCString
mManifestContent
;
}
;
class
PackagedAppChannelListener
final
:
public
nsIStreamListener
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
PackagedAppChannelListener
(
PackagedAppDownloader
*
aDownloader
nsIStreamListener
*
aListener
)
:
mDownloader
(
aDownloader
)
mListener
(
aListener
)
{
}
private
:
~
PackagedAppChannelListener
(
)
{
}
nsRefPtr
<
PackagedAppDownloader
>
mDownloader
;
nsCOMPtr
<
nsIStreamListener
>
mListener
;
}
;
nsRefPtrHashtable
<
nsCStringHashKey
PackagedAppDownloader
>
mDownloadingPackages
;
}
;
}
}
#
endif
