#
include
"
HttpLog
.
h
"
#
include
"
ConnectionHandle
.
h
"
#
include
"
HalfOpenSocket
.
h
"
#
include
"
TCPFastOpenLayer
.
h
"
#
include
"
nsHttpConnection
.
h
"
#
include
"
nsIDNSRecord
.
h
"
#
include
"
nsIDNSService
.
h
"
#
include
"
nsQueryObject
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
namespace
mozilla
{
namespace
net
{
NS_IMPL_ADDREF
(
HalfOpenSocket
)
NS_IMPL_RELEASE
(
HalfOpenSocket
)
NS_INTERFACE_MAP_BEGIN
(
HalfOpenSocket
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIOutputStreamCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsITransportEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsITimerCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsINamed
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
HalfOpenSocket
)
NS_INTERFACE_MAP_END
HalfOpenSocket
:
:
HalfOpenSocket
(
ConnectionEntry
*
ent
nsAHttpTransaction
*
trans
uint32_t
caps
bool
speculative
bool
isFromPredictor
bool
urgentStart
)
:
mTransaction
(
trans
)
mDispatchedMTransaction
(
false
)
mCaps
(
caps
)
mSpeculative
(
speculative
)
mUrgentStart
(
urgentStart
)
mIsFromPredictor
(
isFromPredictor
)
mAllow1918
(
true
)
mHasConnected
(
false
)
mPrimaryConnectedOK
(
false
)
mBackupConnectedOK
(
false
)
mBackupConnStatsSet
(
false
)
mFreeToUse
(
true
)
mPrimaryStreamStatus
(
NS_OK
)
mFastOpenInProgress
(
false
)
mEnt
(
ent
)
{
MOZ_ASSERT
(
ent
&
&
trans
"
constructor
with
null
arguments
"
)
;
LOG
(
(
"
Creating
HalfOpenSocket
[
this
=
%
p
trans
=
%
p
ent
=
%
s
key
=
%
s
]
\
n
"
this
trans
ent
-
>
mConnInfo
-
>
Origin
(
)
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
mIsHttp3
=
mEnt
-
>
mConnInfo
-
>
IsHttp3
(
)
;
if
(
speculative
)
{
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
HTTPCONNMGR_TOTAL_SPECULATIVE_CONN
>
totalSpeculativeConn
;
+
+
totalSpeculativeConn
;
if
(
isFromPredictor
)
{
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
PREDICTOR_TOTAL_PRECONNECTS_CREATED
>
totalPreconnectsCreated
;
+
+
totalPreconnectsCreated
;
}
}
if
(
mEnt
-
>
mConnInfo
-
>
FirstHopSSL
(
)
)
{
mFastOpenStatus
=
TFO_UNKNOWN
;
}
else
{
mFastOpenStatus
=
TFO_HTTP
;
}
MOZ_ASSERT
(
mEnt
)
;
}
HalfOpenSocket
:
:
~
HalfOpenSocket
(
)
{
MOZ_ASSERT
(
!
mStreamOut
)
;
MOZ_ASSERT
(
!
mBackupStreamOut
)
;
LOG
(
(
"
Destroying
HalfOpenSocket
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mEnt
)
{
mEnt
-
>
RemoveHalfOpen
(
this
)
;
}
}
nsresult
HalfOpenSocket
:
:
SetupStreams
(
nsISocketTransport
*
*
transport
nsIAsyncInputStream
*
*
instream
nsIAsyncOutputStream
*
*
outstream
bool
isBackup
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mEnt
)
;
nsresult
rv
;
nsTArray
<
nsCString
>
socketTypes
;
const
nsHttpConnectionInfo
*
ci
=
mEnt
-
>
mConnInfo
;
if
(
mIsHttp3
)
{
socketTypes
.
AppendElement
(
"
quic
"
_ns
)
;
}
else
{
if
(
ci
-
>
FirstHopSSL
(
)
)
{
socketTypes
.
AppendElement
(
"
ssl
"
_ns
)
;
}
else
{
const
nsCString
&
defaultType
=
gHttpHandler
-
>
DefaultSocketType
(
)
;
if
(
!
defaultType
.
IsVoid
(
)
)
{
socketTypes
.
AppendElement
(
defaultType
)
;
}
}
}
nsCOMPtr
<
nsISocketTransport
>
socketTransport
;
nsCOMPtr
<
nsISocketTransportService
>
sts
;
sts
=
services
:
:
GetSocketTransportService
(
)
;
if
(
!
sts
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
LOG
(
(
"
HalfOpenSocket
:
:
SetupStreams
[
this
=
%
p
ent
=
%
s
]
"
"
setup
routed
transport
to
origin
%
s
:
%
d
via
%
s
:
%
d
\
n
"
this
ci
-
>
HashKey
(
)
.
get
(
)
ci
-
>
Origin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
RoutedHost
(
)
ci
-
>
RoutedPort
(
)
)
)
;
nsCOMPtr
<
nsIRoutedSocketTransportService
>
routedSTS
(
do_QueryInterface
(
sts
)
)
;
if
(
routedSTS
)
{
rv
=
routedSTS
-
>
CreateRoutedTransport
(
socketTypes
ci
-
>
GetOrigin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
GetRoutedHost
(
)
ci
-
>
RoutedPort
(
)
ci
-
>
ProxyInfo
(
)
getter_AddRefs
(
socketTransport
)
)
;
}
else
{
if
(
!
ci
-
>
GetRoutedHost
(
)
.
IsEmpty
(
)
)
{
LOG
(
(
"
HalfOpenSocket
this
=
%
p
using
legacy
nsISocketTransportService
"
"
means
explicit
route
%
s
:
%
d
will
be
ignored
.
\
n
"
this
ci
-
>
RoutedHost
(
)
ci
-
>
RoutedPort
(
)
)
)
;
}
rv
=
sts
-
>
CreateTransport
(
socketTypes
ci
-
>
GetOrigin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
ProxyInfo
(
)
getter_AddRefs
(
socketTransport
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
tmpFlags
=
0
;
if
(
mCaps
&
NS_HTTP_REFRESH_DNS
)
{
tmpFlags
=
nsISocketTransport
:
:
BYPASS_CACHE
;
}
tmpFlags
|
=
nsISocketTransport
:
:
GetFlagsFromTRRMode
(
NS_HTTP_TRR_MODE_FROM_FLAGS
(
mCaps
)
)
;
if
(
mCaps
&
NS_HTTP_LOAD_ANONYMOUS
)
{
tmpFlags
|
=
nsISocketTransport
:
:
ANONYMOUS_CONNECT
;
}
if
(
ci
-
>
GetPrivate
(
)
|
|
ci
-
>
GetIsolated
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
NO_PERMANENT_STORAGE
;
}
if
(
ci
-
>
GetLessThanTls13
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DONT_TRY_ESNI_OR_ECH
;
}
if
(
(
(
mCaps
&
NS_HTTP_BE_CONSERVATIVE
)
|
|
ci
-
>
GetBeConservative
(
)
)
&
&
gHttpHandler
-
>
ConnMgr
(
)
-
>
BeConservativeIfProxied
(
ci
-
>
ProxyInfo
(
)
)
)
{
LOG
(
(
"
Setting
Socket
to
BE_CONSERVATIVE
"
)
)
;
tmpFlags
|
=
nsISocketTransport
:
:
BE_CONSERVATIVE
;
}
if
(
ci
-
>
HasIPHintAddress
(
)
)
{
nsCOMPtr
<
nsIDNSService
>
dns
=
do_GetService
(
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIDNSRecord
>
record
;
rv
=
dns
-
>
ResolveNative
(
ci
-
>
GetRoutedHost
(
)
nsIDNSService
:
:
RESOLVE_OFFLINE
mEnt
-
>
mConnInfo
-
>
GetOriginAttributes
(
)
getter_AddRefs
(
record
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
record
)
{
LOG
(
(
"
Setting
Socket
to
use
IP
hint
address
"
)
)
;
tmpFlags
|
=
nsISocketTransport
:
:
USE_IP_HINT_ADDRESS
;
}
}
if
(
mCaps
&
NS_HTTP_DISABLE_IPV4
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV4
;
}
else
if
(
mCaps
&
NS_HTTP_DISABLE_IPV6
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV6
;
}
else
if
(
mEnt
-
>
PreferenceKnown
(
)
)
{
if
(
mEnt
-
>
mPreferIPv6
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV4
;
}
else
if
(
mEnt
-
>
mPreferIPv4
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV6
;
}
tmpFlags
|
=
nsISocketTransport
:
:
RETRY_WITH_DIFFERENT_IP_FAMILY
;
uint16_t
fallbackTimeout
=
isBackup
?
gHttpHandler
-
>
GetFallbackSynTimeout
(
)
:
0
;
if
(
fallbackTimeout
)
{
socketTransport
-
>
SetTimeout
(
nsISocketTransport
:
:
TIMEOUT_CONNECT
fallbackTimeout
)
;
}
}
else
if
(
isBackup
&
&
gHttpHandler
-
>
FastFallbackToIPv4
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV6
;
}
if
(
!
Allow1918
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_RFC1918
;
}
if
(
(
mFastOpenStatus
!
=
TFO_HTTP
)
&
&
!
isBackup
)
{
if
(
mEnt
-
>
mUseFastOpen
)
{
socketTransport
-
>
SetFastOpenCallback
(
this
)
;
}
else
{
mFastOpenStatus
=
TFO_DISABLED
;
}
}
MOZ_ASSERT
(
!
(
tmpFlags
&
nsISocketTransport
:
:
DISABLE_IPV4
)
|
|
!
(
tmpFlags
&
nsISocketTransport
:
:
DISABLE_IPV6
)
"
Both
types
should
not
be
disabled
at
the
same
time
.
"
)
;
socketTransport
-
>
SetConnectionFlags
(
tmpFlags
)
;
socketTransport
-
>
SetTlsFlags
(
ci
-
>
GetTlsFlags
(
)
)
;
const
OriginAttributes
&
originAttributes
=
mEnt
-
>
mConnInfo
-
>
GetOriginAttributes
(
)
;
if
(
originAttributes
!
=
OriginAttributes
(
)
)
{
socketTransport
-
>
SetOriginAttributes
(
originAttributes
)
;
}
socketTransport
-
>
SetQoSBits
(
gHttpHandler
-
>
GetQoSBits
(
)
)
;
rv
=
socketTransport
-
>
SetEventSink
(
this
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
socketTransport
-
>
SetSecurityCallbacks
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
gHttpHandler
-
>
EchConfigEnabled
(
)
)
{
rv
=
socketTransport
-
>
SetEchConfig
(
ci
-
>
GetEchConfig
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_CONNECTION_ENTRY_CACHE_HIT_1
mEnt
-
>
mUsedForConnection
)
;
mEnt
-
>
mUsedForConnection
=
true
;
nsCOMPtr
<
nsIOutputStream
>
sout
;
rv
=
socketTransport
-
>
OpenOutputStream
(
nsITransport
:
:
OPEN_UNBUFFERED
0
0
getter_AddRefs
(
sout
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
sin
;
rv
=
socketTransport
-
>
OpenInputStream
(
nsITransport
:
:
OPEN_UNBUFFERED
0
0
getter_AddRefs
(
sin
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
socketTransport
.
forget
(
transport
)
;
CallQueryInterface
(
sin
instream
)
;
CallQueryInterface
(
sout
outstream
)
;
rv
=
(
*
outstream
)
-
>
AsyncWait
(
this
0
0
nullptr
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
StartedConnect
(
)
;
}
return
rv
;
}
nsresult
HalfOpenSocket
:
:
SetupPrimaryStreams
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
nsresult
rv
;
mPrimarySynStarted
=
TimeStamp
:
:
Now
(
)
;
rv
=
SetupStreams
(
getter_AddRefs
(
mSocketTransport
)
getter_AddRefs
(
mStreamIn
)
getter_AddRefs
(
mStreamOut
)
false
)
;
LOG
(
(
"
HalfOpenSocket
:
:
SetupPrimaryStream
[
this
=
%
p
ent
=
%
s
rv
=
%
"
PRIx32
"
]
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mStreamOut
)
{
mStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
}
if
(
mSocketTransport
)
{
mSocketTransport
-
>
SetFastOpenCallback
(
nullptr
)
;
}
mStreamOut
=
nullptr
;
mStreamIn
=
nullptr
;
mSocketTransport
=
nullptr
;
}
return
rv
;
}
nsresult
HalfOpenSocket
:
:
SetupBackupStreams
(
)
{
MOZ_ASSERT
(
mTransaction
)
;
mBackupSynStarted
=
TimeStamp
:
:
Now
(
)
;
nsresult
rv
=
SetupStreams
(
getter_AddRefs
(
mBackupTransport
)
getter_AddRefs
(
mBackupStreamIn
)
getter_AddRefs
(
mBackupStreamOut
)
true
)
;
LOG
(
(
"
HalfOpenSocket
:
:
SetupBackupStream
[
this
=
%
p
ent
=
%
s
rv
=
%
"
PRIx32
"
]
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mBackupStreamOut
)
{
mBackupStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
}
mBackupStreamOut
=
nullptr
;
mBackupStreamIn
=
nullptr
;
mBackupTransport
=
nullptr
;
}
return
rv
;
}
void
HalfOpenSocket
:
:
SetupBackupTimer
(
)
{
MOZ_ASSERT
(
mEnt
)
;
uint16_t
timeout
=
gHttpHandler
-
>
GetIdleSynTimeout
(
)
;
MOZ_ASSERT
(
!
mSynTimer
"
timer
already
initd
"
)
;
if
(
!
timeout
&
&
mFastOpenInProgress
)
{
timeout
=
250
;
}
if
(
mFastOpenInProgress
|
|
(
timeout
&
&
!
mSpeculative
)
)
{
NS_NewTimerWithCallback
(
getter_AddRefs
(
mSynTimer
)
this
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
LOG
(
(
"
HalfOpenSocket
:
:
SetupBackupTimer
(
)
[
this
=
%
p
]
"
this
)
)
;
}
else
if
(
timeout
)
{
LOG
(
(
"
HalfOpenSocket
:
:
SetupBackupTimer
(
)
[
this
=
%
p
]
did
not
arm
\
n
"
this
)
)
;
}
}
void
HalfOpenSocket
:
:
CancelBackupTimer
(
)
{
if
(
!
mSynTimer
)
{
return
;
}
LOG
(
(
"
HalfOpenSocket
:
:
CancelBackupTimer
(
)
"
)
)
;
mSynTimer
-
>
Cancel
(
)
;
}
void
HalfOpenSocket
:
:
Abandon
(
)
{
LOG
(
(
"
HalfOpenSocket
:
:
Abandon
[
this
=
%
p
ent
=
%
s
]
%
p
%
p
%
p
%
p
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
mSocketTransport
.
get
(
)
mBackupTransport
.
get
(
)
mStreamOut
.
get
(
)
mBackupStreamOut
.
get
(
)
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
RefPtr
<
HalfOpenSocket
>
deleteProtector
(
this
)
;
if
(
mSocketTransport
)
{
mSocketTransport
-
>
SetEventSink
(
nullptr
nullptr
)
;
mSocketTransport
-
>
SetSecurityCallbacks
(
nullptr
)
;
mSocketTransport
-
>
SetFastOpenCallback
(
nullptr
)
;
mSocketTransport
=
nullptr
;
}
if
(
mBackupTransport
)
{
mBackupTransport
-
>
SetEventSink
(
nullptr
nullptr
)
;
mBackupTransport
-
>
SetSecurityCallbacks
(
nullptr
)
;
mBackupTransport
=
nullptr
;
}
if
(
mStreamOut
)
{
if
(
!
mFastOpenInProgress
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
RecvdConnect
(
)
;
}
mStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mStreamOut
=
nullptr
;
}
if
(
mBackupStreamOut
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
RecvdConnect
(
)
;
mBackupStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mBackupStreamOut
=
nullptr
;
}
if
(
mStreamIn
)
{
mStreamIn
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mStreamIn
=
nullptr
;
}
if
(
mBackupStreamIn
)
{
mBackupStreamIn
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mBackupStreamIn
=
nullptr
;
}
CancelBackupTimer
(
)
;
if
(
mEnt
)
{
mEnt
-
>
mDoNotDestroy
=
false
;
mEnt
-
>
RemoveHalfOpen
(
this
)
;
}
mEnt
=
nullptr
;
}
double
HalfOpenSocket
:
:
Duration
(
TimeStamp
epoch
)
{
if
(
mPrimarySynStarted
.
IsNull
(
)
)
{
return
0
;
}
return
(
epoch
-
mPrimarySynStarted
)
.
ToMilliseconds
(
)
;
}
NS_IMETHODIMP
HalfOpenSocket
:
:
Notify
(
nsITimer
*
timer
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
timer
=
=
mSynTimer
"
wrong
timer
"
)
;
MOZ_ASSERT
(
!
mBackupTransport
)
;
MOZ_ASSERT
(
mSynTimer
)
;
MOZ_ASSERT
(
mEnt
)
;
DebugOnly
<
nsresult
>
rv
=
SetupBackupStreams
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HalfOpenSocket
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
HalfOpenSocket
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HalfOpenSocket
:
:
OnOutputStreamReady
(
nsIAsyncOutputStream
*
out
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mStreamOut
|
|
mBackupStreamOut
)
;
MOZ_ASSERT
(
out
=
=
mStreamOut
|
|
out
=
=
mBackupStreamOut
"
stream
mismatch
"
)
;
MOZ_ASSERT
(
mEnt
)
;
LOG
(
(
"
HalfOpenSocket
:
:
OnOutputStreamReady
[
this
=
%
p
ent
=
%
s
%
s
]
\
n
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
out
=
=
mStreamOut
?
"
primary
"
:
"
backup
"
)
)
;
mEnt
-
>
mDoNotDestroy
=
true
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
RecvdConnect
(
)
;
CancelBackupTimer
(
)
;
if
(
mFastOpenInProgress
)
{
LOG
(
(
"
HalfOpenSocket
:
:
OnOutputStreamReady
backup
stream
is
ready
"
"
close
the
fast
open
socket
%
p
[
this
=
%
p
ent
=
%
s
]
\
n
"
mSocketTransport
.
get
(
)
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
)
)
;
MOZ_ASSERT
(
(
out
=
=
mBackupStreamOut
)
&
&
mConnectionNegotiatingFastOpen
)
;
mSocketTransport
-
>
SetFastOpenCallback
(
nullptr
)
;
mConnectionNegotiatingFastOpen
-
>
SetFastOpen
(
false
)
;
mEnt
-
>
mHalfOpenFastOpenBackups
.
RemoveElement
(
this
)
;
RefPtr
<
nsAHttpTransaction
>
trans
=
mConnectionNegotiatingFastOpen
-
>
CloseConnectionFastOpenTakesTooLongOrError
(
true
)
;
mSocketTransport
=
nullptr
;
mStreamOut
=
nullptr
;
mStreamIn
=
nullptr
;
if
(
trans
&
&
trans
-
>
QueryHttpTransaction
(
)
)
{
RefPtr
<
PendingTransactionInfo
>
pendingTransInfo
=
new
PendingTransactionInfo
(
trans
-
>
QueryHttpTransaction
(
)
)
;
pendingTransInfo
-
>
mHalfOpen
=
do_GetWeakReference
(
static_cast
<
nsISupportsWeakReference
*
>
(
this
)
)
;
mEnt
-
>
InsertTransaction
(
pendingTransInfo
true
)
;
}
if
(
mEnt
-
>
mUseFastOpen
)
{
gHttpHandler
-
>
IncrementFastOpenConsecutiveFailureCounter
(
)
;
mEnt
-
>
mUseFastOpen
=
false
;
}
mFastOpenInProgress
=
false
;
mConnectionNegotiatingFastOpen
=
nullptr
;
if
(
mFastOpenStatus
=
=
TFO_NOT_TRIED
)
{
mFastOpenStatus
=
TFO_FAILED_BACKUP_CONNECTION_TFO_NOT_TRIED
;
}
else
if
(
mFastOpenStatus
=
=
TFO_TRIED
)
{
mFastOpenStatus
=
TFO_FAILED_BACKUP_CONNECTION_TFO_TRIED
;
}
else
if
(
mFastOpenStatus
=
=
TFO_DATA_SENT
)
{
mFastOpenStatus
=
TFO_FAILED_BACKUP_CONNECTION_TFO_DATA_SENT
;
}
else
{
mFastOpenStatus
=
TFO_FAILED_BACKUP_CONNECTION_TFO_DATA_COOKIE_NOT_ACCEPTED
;
}
}
if
(
(
(
mFastOpenStatus
=
=
TFO_DISABLED
)
|
|
(
mFastOpenStatus
=
=
TFO_HTTP
)
)
&
&
!
mBackupConnStatsSet
)
{
mBackupConnStatsSet
=
true
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_HTTP_BACKUP_CONN_WON_1
(
out
=
=
mBackupStreamOut
)
)
;
}
if
(
mFastOpenStatus
=
=
TFO_UNKNOWN
)
{
MOZ_ASSERT
(
out
=
=
mStreamOut
)
;
if
(
mPrimaryStreamStatus
=
=
NS_NET_STATUS_RESOLVING_HOST
)
{
mFastOpenStatus
=
TFO_UNKNOWN_RESOLVING
;
}
else
if
(
mPrimaryStreamStatus
=
=
NS_NET_STATUS_RESOLVED_HOST
)
{
mFastOpenStatus
=
TFO_UNKNOWN_RESOLVED
;
}
else
if
(
mPrimaryStreamStatus
=
=
NS_NET_STATUS_CONNECTING_TO
)
{
mFastOpenStatus
=
TFO_UNKNOWN_CONNECTING
;
}
else
if
(
mPrimaryStreamStatus
=
=
NS_NET_STATUS_CONNECTED_TO
)
{
mFastOpenStatus
=
TFO_UNKNOWN_CONNECTED
;
}
}
nsresult
rv
=
SetupConn
(
out
false
)
;
if
(
mEnt
)
{
mEnt
-
>
mDoNotDestroy
=
false
;
}
return
rv
;
}
bool
HalfOpenSocket
:
:
FastOpenEnabled
(
)
{
LOG
(
(
"
HalfOpenSocket
:
:
FastOpenEnabled
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
mEnt
)
;
if
(
!
mEnt
)
{
return
false
;
}
MOZ_ASSERT
(
mEnt
-
>
mConnInfo
-
>
FirstHopSSL
(
)
)
;
if
(
!
mEnt
-
>
mHalfOpens
.
Contains
(
this
)
)
{
return
false
;
}
if
(
!
gHttpHandler
-
>
UseFastOpen
(
)
)
{
LOG
(
(
"
HalfOpenSocket
:
:
FastEnabled
-
fast
open
was
turned
off
.
\
n
"
)
)
;
mEnt
-
>
mUseFastOpen
=
false
;
mFastOpenStatus
=
TFO_DISABLED
;
return
false
;
}
if
(
mEnt
-
>
mConnInfo
-
>
UsingConnect
(
)
)
{
LOG
(
(
"
HalfOpenSocket
:
:
FastOpenEnabled
-
It
is
using
Connect
.
"
)
)
;
mFastOpenStatus
=
TFO_DISABLED_CONNECT
;
return
false
;
}
return
true
;
}
nsresult
HalfOpenSocket
:
:
StartFastOpen
(
)
{
MOZ_ASSERT
(
mStreamOut
)
;
MOZ_ASSERT
(
!
mBackupTransport
)
;
MOZ_ASSERT
(
mEnt
)
;
MOZ_ASSERT
(
mFastOpenStatus
=
=
TFO_UNKNOWN
)
;
LOG
(
(
"
HalfOpenSocket
:
:
StartFastOpen
[
this
=
%
p
]
\
n
"
this
)
)
;
RefPtr
<
HalfOpenSocket
>
deleteProtector
(
this
)
;
mFastOpenInProgress
=
true
;
mEnt
-
>
mDoNotDestroy
=
true
;
if
(
!
mEnt
-
>
mHalfOpens
.
RemoveElement
(
this
)
)
{
MOZ_ASSERT
(
false
"
HalfOpen
is
not
in
mHalfOpens
!
"
)
;
mSocketTransport
-
>
SetFastOpenCallback
(
nullptr
)
;
CancelBackupTimer
(
)
;
mFastOpenInProgress
=
false
;
Abandon
(
)
;
mFastOpenStatus
=
TFO_INIT_FAILED
;
return
NS_ERROR_ABORT
;
}
MOZ_ASSERT
(
gHttpHandler
-
>
ConnMgr
(
)
-
>
mNumHalfOpenConns
)
;
if
(
gHttpHandler
-
>
ConnMgr
(
)
-
>
mNumHalfOpenConns
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
mNumHalfOpenConns
-
-
;
}
gHttpHandler
-
>
ConnMgr
(
)
-
>
RecvdConnect
(
)
;
mSocketTransport
-
>
SetEventSink
(
nullptr
nullptr
)
;
mSocketTransport
-
>
SetSecurityCallbacks
(
nullptr
)
;
mStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
nsresult
rv
=
SetupConn
(
mStreamOut
true
)
;
if
(
!
mConnectionNegotiatingFastOpen
)
{
LOG
(
(
"
HalfOpenSocket
:
:
StartFastOpen
SetupConn
failed
"
"
[
this
=
%
p
rv
=
%
x
]
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
NS_ERROR_ABORT
;
}
mSocketTransport
-
>
SetFastOpenCallback
(
nullptr
)
;
CancelBackupTimer
(
)
;
mFastOpenInProgress
=
false
;
Abandon
(
)
;
mFastOpenStatus
=
TFO_INIT_FAILED
;
}
else
{
LOG
(
(
"
HalfOpenSocket
:
:
StartFastOpen
[
this
=
%
p
conn
=
%
p
]
\
n
"
this
mConnectionNegotiatingFastOpen
.
get
(
)
)
)
;
mEnt
-
>
mHalfOpenFastOpenBackups
.
AppendElement
(
this
)
;
if
(
!
mSynTimer
)
{
SetupBackupTimer
(
)
;
}
}
if
(
mEnt
)
{
mEnt
-
>
mDoNotDestroy
=
false
;
}
return
rv
;
}
void
HalfOpenSocket
:
:
SetFastOpenConnected
(
nsresult
aError
bool
aWillRetry
)
{
MOZ_ASSERT
(
mFastOpenInProgress
)
;
MOZ_ASSERT
(
mEnt
)
;
LOG
(
(
"
HalfOpenSocket
:
:
SetFastOpenConnected
[
this
=
%
p
conn
=
%
p
error
=
%
x
]
\
n
"
this
mConnectionNegotiatingFastOpen
.
get
(
)
static_cast
<
uint32_t
>
(
aError
)
)
)
;
if
(
!
mConnectionNegotiatingFastOpen
)
{
return
;
}
MOZ_ASSERT
(
(
mFastOpenStatus
=
=
TFO_NOT_TRIED
)
|
|
(
mFastOpenStatus
=
=
TFO_DATA_SENT
)
|
|
(
mFastOpenStatus
=
=
TFO_TRIED
)
|
|
(
mFastOpenStatus
=
=
TFO_DATA_COOKIE_NOT_ACCEPTED
)
|
|
(
mFastOpenStatus
=
=
TFO_DISABLED
)
)
;
RefPtr
<
HalfOpenSocket
>
deleteProtector
(
this
)
;
mEnt
-
>
mDoNotDestroy
=
true
;
mEnt
-
>
mHalfOpenFastOpenBackups
.
RemoveElement
(
this
)
;
mSocketTransport
-
>
SetFastOpenCallback
(
nullptr
)
;
mConnectionNegotiatingFastOpen
-
>
SetFastOpen
(
false
)
;
if
(
aWillRetry
&
&
(
(
aError
=
=
NS_ERROR_CONNECTION_REFUSED
)
|
|
#
if
defined
(
_WIN64
)
&
&
defined
(
WIN95
)
(
aError
=
=
NS_ERROR_FAILURE
)
|
|
#
endif
(
aError
=
=
NS_ERROR_PROXY_CONNECTION_REFUSED
)
|
|
(
aError
=
=
NS_ERROR_NET_TIMEOUT
)
)
)
{
if
(
mEnt
-
>
mUseFastOpen
)
{
gHttpHandler
-
>
IncrementFastOpenConsecutiveFailureCounter
(
)
;
mEnt
-
>
mUseFastOpen
=
false
;
}
RefPtr
<
nsAHttpTransaction
>
trans
=
mConnectionNegotiatingFastOpen
-
>
CloseConnectionFastOpenTakesTooLongOrError
(
false
)
;
if
(
trans
&
&
trans
-
>
QueryHttpTransaction
(
)
)
{
RefPtr
<
PendingTransactionInfo
>
pendingTransInfo
=
new
PendingTransactionInfo
(
trans
-
>
QueryHttpTransaction
(
)
)
;
pendingTransInfo
-
>
mHalfOpen
=
do_GetWeakReference
(
static_cast
<
nsISupportsWeakReference
*
>
(
this
)
)
;
mEnt
-
>
InsertTransaction
(
pendingTransInfo
true
)
;
}
mEnt
-
>
mHalfOpens
.
AppendElement
(
this
)
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
mNumHalfOpenConns
+
+
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
StartedConnect
(
)
;
mStreamOut
-
>
AsyncWait
(
this
0
0
nullptr
)
;
mSocketTransport
-
>
SetEventSink
(
this
nullptr
)
;
mSocketTransport
-
>
SetSecurityCallbacks
(
this
)
;
mStreamIn
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
if
(
(
aError
=
=
NS_ERROR_CONNECTION_REFUSED
)
|
|
(
aError
=
=
NS_ERROR_PROXY_CONNECTION_REFUSED
)
)
{
mFastOpenStatus
=
TFO_FAILED_CONNECTION_REFUSED
;
}
else
{
mFastOpenStatus
=
TFO_FAILED_NET_TIMEOUT
;
}
}
else
{
CancelBackupTimer
(
)
;
if
(
NS_SUCCEEDED
(
aError
)
)
{
NetAddr
peeraddr
;
if
(
NS_SUCCEEDED
(
mSocketTransport
-
>
GetPeerAddr
(
&
peeraddr
)
)
)
{
mEnt
-
>
RecordIPFamilyPreference
(
peeraddr
.
raw
.
family
)
;
}
gHttpHandler
-
>
ResetFastOpenConsecutiveFailureCounter
(
)
;
}
mSocketTransport
=
nullptr
;
mStreamOut
=
nullptr
;
mStreamIn
=
nullptr
;
if
(
mBackupTransport
)
{
mFastOpenStatus
=
TFO_BACKUP_CONN
;
mEnt
-
>
mHalfOpens
.
AppendElement
(
this
)
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
mNumHalfOpenConns
+
+
;
}
}
mFastOpenInProgress
=
false
;
mConnectionNegotiatingFastOpen
=
nullptr
;
if
(
mEnt
)
{
mEnt
-
>
mDoNotDestroy
=
false
;
}
else
{
MOZ_ASSERT
(
!
mBackupTransport
)
;
MOZ_ASSERT
(
!
mBackupStreamOut
)
;
}
}
void
HalfOpenSocket
:
:
SetFastOpenStatus
(
uint8_t
tfoStatus
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mFastOpenInProgress
)
;
mFastOpenStatus
=
tfoStatus
;
mConnectionNegotiatingFastOpen
-
>
SetFastOpenStatus
(
tfoStatus
)
;
if
(
mConnectionNegotiatingFastOpen
-
>
Transaction
(
)
)
{
mConnectionNegotiatingFastOpen
-
>
Transaction
(
)
-
>
SetFastOpenStatus
(
tfoStatus
)
;
}
}
void
HalfOpenSocket
:
:
CancelFastOpenConnection
(
)
{
MOZ_ASSERT
(
mFastOpenInProgress
)
;
LOG
(
(
"
HalfOpenSocket
:
:
CancelFastOpenConnection
[
this
=
%
p
conn
=
%
p
]
\
n
"
this
mConnectionNegotiatingFastOpen
.
get
(
)
)
)
;
RefPtr
<
HalfOpenSocket
>
deleteProtector
(
this
)
;
mEnt
-
>
mHalfOpenFastOpenBackups
.
RemoveElement
(
this
)
;
mSocketTransport
-
>
SetFastOpenCallback
(
nullptr
)
;
mConnectionNegotiatingFastOpen
-
>
SetFastOpen
(
false
)
;
RefPtr
<
nsAHttpTransaction
>
trans
=
mConnectionNegotiatingFastOpen
-
>
CloseConnectionFastOpenTakesTooLongOrError
(
true
)
;
mSocketTransport
=
nullptr
;
mStreamOut
=
nullptr
;
mStreamIn
=
nullptr
;
if
(
trans
&
&
trans
-
>
QueryHttpTransaction
(
)
)
{
RefPtr
<
PendingTransactionInfo
>
pendingTransInfo
=
new
PendingTransactionInfo
(
trans
-
>
QueryHttpTransaction
(
)
)
;
mEnt
-
>
InsertTransaction
(
pendingTransInfo
true
)
;
}
mFastOpenInProgress
=
false
;
mConnectionNegotiatingFastOpen
=
nullptr
;
Abandon
(
)
;
MOZ_ASSERT
(
!
mBackupTransport
)
;
MOZ_ASSERT
(
!
mBackupStreamOut
)
;
}
void
HalfOpenSocket
:
:
FastOpenNotSupported
(
)
{
MOZ_ASSERT
(
mFastOpenInProgress
)
;
gHttpHandler
-
>
SetFastOpenNotSupported
(
)
;
}
nsresult
HalfOpenSocket
:
:
SetupConn
(
nsIAsyncOutputStream
*
out
bool
aFastOpen
)
{
MOZ_ASSERT
(
!
aFastOpen
|
|
(
out
=
=
mStreamOut
)
)
;
MOZ_ASSERT
(
!
(
mIsHttp3
&
&
aFastOpen
)
)
;
RefPtr
<
HttpConnectionBase
>
conn
;
if
(
!
mIsHttp3
)
{
conn
=
new
nsHttpConnection
(
)
;
}
else
{
conn
=
new
HttpConnectionUDP
(
)
;
}
LOG
(
(
"
HalfOpenSocket
:
:
SetupConn
"
"
Created
new
nshttpconnection
%
p
%
s
\
n
"
conn
.
get
(
)
mIsHttp3
?
"
using
http3
"
:
"
"
)
)
;
NullHttpTransaction
*
nullTrans
=
mTransaction
-
>
QueryNullTransaction
(
)
;
if
(
nullTrans
)
{
conn
-
>
BootstrapTimings
(
nullTrans
-
>
Timings
(
)
)
;
}
conn
-
>
SetTransactionCaps
(
mTransaction
-
>
Caps
(
)
)
;
NetAddr
peeraddr
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
mTransaction
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
nsresult
rv
;
if
(
out
=
=
mStreamOut
)
{
TimeDuration
rtt
=
TimeStamp
:
:
Now
(
)
-
mPrimarySynStarted
;
rv
=
conn
-
>
Init
(
mEnt
-
>
mConnInfo
gHttpHandler
-
>
ConnMgr
(
)
-
>
mMaxRequestDelay
mSocketTransport
mStreamIn
mStreamOut
mPrimaryConnectedOK
|
|
aFastOpen
callbacks
PR_MillisecondsToInterval
(
static_cast
<
uint32_t
>
(
rtt
.
ToMilliseconds
(
)
)
)
)
;
bool
resetPreference
=
false
;
mSocketTransport
-
>
GetResetIPFamilyPreference
(
&
resetPreference
)
;
if
(
resetPreference
)
{
mEnt
-
>
ResetIPFamilyPreference
(
)
;
}
if
(
!
aFastOpen
&
&
NS_SUCCEEDED
(
mSocketTransport
-
>
GetPeerAddr
(
&
peeraddr
)
)
)
{
mEnt
-
>
RecordIPFamilyPreference
(
peeraddr
.
raw
.
family
)
;
}
if
(
!
aFastOpen
)
{
mStreamOut
=
nullptr
;
mStreamIn
=
nullptr
;
mSocketTransport
=
nullptr
;
}
else
{
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
MOZ_ASSERT
(
connTCP
)
;
if
(
connTCP
)
{
connTCP
-
>
SetFastOpen
(
true
)
;
}
}
}
else
if
(
out
=
=
mBackupStreamOut
)
{
TimeDuration
rtt
=
TimeStamp
:
:
Now
(
)
-
mBackupSynStarted
;
rv
=
conn
-
>
Init
(
mEnt
-
>
mConnInfo
gHttpHandler
-
>
ConnMgr
(
)
-
>
mMaxRequestDelay
mBackupTransport
mBackupStreamIn
mBackupStreamOut
mBackupConnectedOK
callbacks
PR_MillisecondsToInterval
(
static_cast
<
uint32_t
>
(
rtt
.
ToMilliseconds
(
)
)
)
)
;
bool
resetPreference
=
false
;
mBackupTransport
-
>
GetResetIPFamilyPreference
(
&
resetPreference
)
;
if
(
resetPreference
)
{
mEnt
-
>
ResetIPFamilyPreference
(
)
;
}
if
(
NS_SUCCEEDED
(
mBackupTransport
-
>
GetPeerAddr
(
&
peeraddr
)
)
)
{
mEnt
-
>
RecordIPFamilyPreference
(
peeraddr
.
raw
.
family
)
;
}
mBackupStreamOut
=
nullptr
;
mBackupStreamIn
=
nullptr
;
mBackupTransport
=
nullptr
;
}
else
{
MOZ_ASSERT
(
false
"
unexpected
stream
"
)
;
rv
=
NS_ERROR_UNEXPECTED
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
HalfOpenSocket
:
:
SetupConn
"
"
conn
-
>
init
(
%
p
)
failed
%
"
PRIx32
"
\
n
"
conn
.
get
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
if
(
connTCP
)
{
if
(
(
mFastOpenStatus
=
=
TFO_HTTP
)
|
|
(
mFastOpenStatus
=
=
TFO_DISABLED
)
|
|
(
mFastOpenStatus
=
=
TFO_DISABLED_CONNECT
)
)
{
connTCP
-
>
SetFastOpenStatus
(
mFastOpenStatus
)
;
}
else
{
connTCP
-
>
SetFastOpenStatus
(
TFO_INIT_FAILED
)
;
}
}
if
(
nullTrans
)
{
nullTrans
-
>
Close
(
rv
)
;
}
else
if
(
nsHttpTransaction
*
trans
=
mTransaction
-
>
QueryHttpTransaction
(
)
)
{
if
(
mIsHttp3
)
{
trans
-
>
DisableHttp3
(
)
;
gHttpHandler
-
>
ExcludeHttp3
(
mEnt
-
>
mConnInfo
)
;
}
Unused
<
<
gHttpHandler
-
>
ConnMgr
(
)
-
>
CancelTransaction
(
trans
rv
)
;
}
return
rv
;
}
if
(
!
aFastOpen
)
{
mHasConnected
=
true
;
}
RefPtr
<
PendingTransactionInfo
>
pendingTransInfo
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
FindTransactionHelper
(
true
mEnt
mTransaction
)
;
if
(
pendingTransInfo
)
{
MOZ_ASSERT
(
!
mSpeculative
"
Speculative
Half
Open
found
mTransaction
"
)
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
AddActiveConn
(
conn
mEnt
)
;
if
(
mIsHttp3
)
{
RefPtr
<
ConnectionHandle
>
handle
=
new
ConnectionHandle
(
conn
)
;
pendingTransInfo
-
>
mTransaction
-
>
SetConnection
(
handle
)
;
}
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchTransaction
(
mEnt
pendingTransInfo
-
>
mTransaction
conn
)
;
}
else
{
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
if
(
connTCP
)
{
connTCP
-
>
SetIsReusedAfter
(
950
)
;
}
if
(
!
connTCP
|
|
(
mEnt
-
>
mConnInfo
-
>
FirstHopSSL
(
)
&
&
!
mEnt
-
>
UrgentStartQueueLength
(
)
&
&
!
mEnt
-
>
PendingQueueLength
(
)
&
&
!
mEnt
-
>
mConnInfo
-
>
UsingConnect
(
)
)
)
{
LOG
(
(
"
HalfOpenSocket
:
:
SetupConn
null
transaction
will
"
"
be
used
to
finish
SSL
handshake
on
conn
%
p
\
n
"
conn
.
get
(
)
)
)
;
RefPtr
<
nsAHttpTransaction
>
trans
;
if
(
mTransaction
-
>
IsNullTransaction
(
)
&
&
!
mDispatchedMTransaction
)
{
mDispatchedMTransaction
=
true
;
trans
=
mTransaction
;
}
else
{
trans
=
new
NullHttpTransaction
(
mEnt
-
>
mConnInfo
callbacks
mCaps
)
;
}
gHttpHandler
-
>
ConnMgr
(
)
-
>
AddActiveConn
(
conn
mEnt
)
;
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchAbstractTransaction
(
mEnt
trans
mCaps
conn
0
)
;
}
else
{
LOG
(
(
"
HalfOpenSocket
:
:
SetupConn
no
transaction
match
"
"
returning
conn
%
p
to
pool
\
n
"
conn
.
get
(
)
)
)
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
OnMsgReclaimConnection
(
conn
)
;
if
(
mEnt
&
&
mEnt
-
>
mConnInfo
-
>
FirstHopSSL
(
)
&
&
!
mEnt
-
>
mConnInfo
-
>
UsingConnect
(
)
)
{
int32_t
idx
=
mEnt
-
>
mIdleConns
.
IndexOf
(
conn
)
;
if
(
idx
!
=
-
1
)
{
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
MOZ_ASSERT
(
connTCP
)
;
if
(
connTCP
)
{
DebugOnly
<
nsresult
>
rvDeb
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
RemoveIdleConnection
(
connTCP
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rvDeb
)
)
;
connTCP
-
>
EndIdleMonitoring
(
)
;
}
RefPtr
<
nsAHttpTransaction
>
trans
;
if
(
mTransaction
-
>
IsNullTransaction
(
)
&
&
!
mDispatchedMTransaction
)
{
mDispatchedMTransaction
=
true
;
trans
=
mTransaction
;
}
else
{
trans
=
new
NullHttpTransaction
(
mEnt
-
>
mConnInfo
callbacks
mCaps
)
;
}
gHttpHandler
-
>
ConnMgr
(
)
-
>
AddActiveConn
(
conn
mEnt
)
;
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchAbstractTransaction
(
mEnt
trans
mCaps
conn
0
)
;
}
}
}
}
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
if
(
connTCP
)
{
if
(
aFastOpen
)
{
MOZ_ASSERT
(
mEnt
)
;
MOZ_ASSERT
(
static_cast
<
int32_t
>
(
mEnt
-
>
mIdleConns
.
IndexOf
(
connTCP
)
)
=
=
-
1
)
;
int32_t
idx
=
mEnt
-
>
mActiveConns
.
IndexOf
(
conn
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
idx
!
=
-
1
)
)
{
mConnectionNegotiatingFastOpen
=
connTCP
;
}
else
{
connTCP
-
>
SetFastOpen
(
false
)
;
connTCP
-
>
SetFastOpenStatus
(
TFO_INIT_FAILED
)
;
}
}
else
{
connTCP
-
>
SetFastOpenStatus
(
mFastOpenStatus
)
;
if
(
(
mFastOpenStatus
!
=
TFO_HTTP
)
&
&
(
mFastOpenStatus
!
=
TFO_DISABLED
)
&
&
(
mFastOpenStatus
!
=
TFO_DISABLED_CONNECT
)
)
{
mFastOpenStatus
=
TFO_BACKUP_CONN
;
}
}
}
if
(
conn
-
>
Transaction
(
)
&
&
!
conn
-
>
Transaction
(
)
-
>
IsNullTransaction
(
)
)
{
Claim
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
HalfOpenSocket
:
:
OnTransportStatus
(
nsITransport
*
trans
nsresult
status
int64_t
progress
int64_t
progressMax
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
(
trans
=
=
mSocketTransport
)
|
|
(
trans
=
=
mBackupTransport
)
)
;
MOZ_ASSERT
(
mEnt
)
;
if
(
mTransaction
)
{
if
(
(
trans
=
=
mSocketTransport
)
|
|
(
(
trans
=
=
mBackupTransport
)
&
&
(
status
=
=
NS_NET_STATUS_CONNECTED_TO
)
&
&
mSocketTransport
)
)
{
mTransaction
-
>
OnTransportStatus
(
trans
status
progress
)
;
}
}
MOZ_ASSERT
(
trans
=
=
mSocketTransport
|
|
trans
=
=
mBackupTransport
)
;
if
(
status
=
=
NS_NET_STATUS_CONNECTED_TO
)
{
if
(
trans
=
=
mSocketTransport
)
{
mPrimaryConnectedOK
=
true
;
}
else
{
mBackupConnectedOK
=
true
;
}
}
if
(
trans
!
=
mSocketTransport
)
{
return
NS_OK
;
}
mPrimaryStreamStatus
=
status
;
if
(
status
=
=
NS_NET_STATUS_CONNECTING_TO
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
&
&
gHttpHandler
-
>
CoalesceSpdy
(
)
&
&
mEnt
&
&
mEnt
-
>
mConnInfo
&
&
mEnt
-
>
mConnInfo
-
>
EndToEndSSL
(
)
&
&
mEnt
-
>
AllowHttp2
(
)
&
&
!
mEnt
-
>
mConnInfo
-
>
UsingProxy
(
)
&
&
mEnt
-
>
mCoalescingKeys
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIDNSAddrRecord
>
dnsRecord
(
do_GetInterface
(
mSocketTransport
)
)
;
nsTArray
<
NetAddr
>
addressSet
;
nsresult
rv
=
NS_ERROR_NOT_AVAILABLE
;
if
(
dnsRecord
)
{
rv
=
dnsRecord
-
>
GetAddresses
(
addressSet
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
addressSet
.
IsEmpty
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
addressSet
.
Length
(
)
;
+
+
i
)
{
nsCString
*
newKey
=
mEnt
-
>
mCoalescingKeys
.
AppendElement
(
nsCString
(
)
)
;
newKey
-
>
SetLength
(
kIPv6CStrBufSize
+
26
)
;
addressSet
[
i
]
.
ToStringBuffer
(
newKey
-
>
BeginWriting
(
)
kIPv6CStrBufSize
)
;
newKey
-
>
SetLength
(
strlen
(
newKey
-
>
BeginReading
(
)
)
)
;
if
(
mEnt
-
>
mConnInfo
-
>
GetAnonymous
(
)
)
{
newKey
-
>
AppendLiteral
(
"
~
A
:
"
)
;
}
else
{
newKey
-
>
AppendLiteral
(
"
~
.
:
"
)
;
}
newKey
-
>
AppendInt
(
mEnt
-
>
mConnInfo
-
>
OriginPort
(
)
)
;
newKey
-
>
AppendLiteral
(
"
/
[
"
)
;
nsAutoCString
suffix
;
mEnt
-
>
mConnInfo
-
>
GetOriginAttributes
(
)
.
CreateSuffix
(
suffix
)
;
newKey
-
>
Append
(
suffix
)
;
newKey
-
>
AppendLiteral
(
"
]
viaDNS
"
)
;
LOG
(
(
"
HalfOpenSocket
:
:
OnTransportStatus
"
"
STATUS_CONNECTING_TO
Established
New
Coalescing
Key
#
%
d
for
host
"
"
%
s
[
%
s
]
"
i
mEnt
-
>
mConnInfo
-
>
Origin
(
)
newKey
-
>
get
(
)
)
)
;
}
gHttpHandler
-
>
ConnMgr
(
)
-
>
ProcessSpdyPendingQ
(
mEnt
)
;
}
}
switch
(
status
)
{
case
NS_NET_STATUS_CONNECTING_TO
:
if
(
mEnt
&
&
!
mBackupTransport
&
&
!
mSynTimer
&
&
!
mIsHttp3
)
{
SetupBackupTimer
(
)
;
}
break
;
case
NS_NET_STATUS_CONNECTED_TO
:
CancelBackupTimer
(
)
;
break
;
default
:
break
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HalfOpenSocket
:
:
GetInterface
(
const
nsIID
&
iid
void
*
*
result
)
{
if
(
mTransaction
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
mTransaction
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
callbacks
)
{
return
callbacks
-
>
GetInterface
(
iid
result
)
;
}
}
return
NS_ERROR_NO_INTERFACE
;
}
bool
HalfOpenSocket
:
:
AcceptsTransaction
(
nsHttpTransaction
*
trans
)
{
return
!
mUrgentStart
|
|
(
trans
-
>
Caps
(
)
&
nsIClassOfService
:
:
UrgentStart
)
;
}
bool
HalfOpenSocket
:
:
Claim
(
)
{
if
(
mSpeculative
)
{
mSpeculative
=
false
;
uint32_t
flags
;
if
(
mSocketTransport
&
&
NS_SUCCEEDED
(
mSocketTransport
-
>
GetConnectionFlags
(
&
flags
)
)
)
{
flags
&
=
~
nsISocketTransport
:
:
DISABLE_RFC1918
;
mSocketTransport
-
>
SetConnectionFlags
(
flags
)
;
}
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
HTTPCONNMGR_USED_SPECULATIVE_CONN
>
usedSpeculativeConn
;
+
+
usedSpeculativeConn
;
if
(
mIsFromPredictor
)
{
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
PREDICTOR_TOTAL_PRECONNECTS_USED
>
totalPreconnectsUsed
;
+
+
totalPreconnectsUsed
;
}
if
(
(
mPrimaryStreamStatus
=
=
NS_NET_STATUS_CONNECTING_TO
)
&
&
mEnt
&
&
!
mBackupTransport
&
&
!
mSynTimer
&
&
!
mIsHttp3
)
{
SetupBackupTimer
(
)
;
}
}
if
(
mFreeToUse
)
{
mFreeToUse
=
false
;
return
true
;
}
return
false
;
}
void
HalfOpenSocket
:
:
Unclaim
(
)
{
MOZ_ASSERT
(
!
mSpeculative
&
&
!
mFreeToUse
)
;
mFreeToUse
=
true
;
}
}
}
