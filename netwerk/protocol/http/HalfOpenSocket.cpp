#
include
"
HttpLog
.
h
"
#
include
"
ConnectionHandle
.
h
"
#
include
"
HalfOpenSocket
.
h
"
#
include
"
nsHttpConnection
.
h
"
#
include
"
nsIDNSRecord
.
h
"
#
include
"
nsIDNSService
.
h
"
#
include
"
nsQueryObject
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
namespace
mozilla
{
namespace
net
{
NS_IMPL_ADDREF
(
HalfOpenSocket
)
NS_IMPL_RELEASE
(
HalfOpenSocket
)
NS_INTERFACE_MAP_BEGIN
(
HalfOpenSocket
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIOutputStreamCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsITransportEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsITimerCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsINamed
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
HalfOpenSocket
)
NS_INTERFACE_MAP_END
HalfOpenSocket
:
:
HalfOpenSocket
(
ConnectionEntry
*
ent
nsAHttpTransaction
*
trans
uint32_t
caps
bool
speculative
bool
isFromPredictor
bool
urgentStart
)
:
mTransaction
(
trans
)
mDispatchedMTransaction
(
false
)
mCaps
(
caps
)
mSpeculative
(
speculative
)
mUrgentStart
(
urgentStart
)
mIsFromPredictor
(
isFromPredictor
)
mAllow1918
(
true
)
mHasConnected
(
false
)
mPrimaryConnectedOK
(
false
)
mBackupConnectedOK
(
false
)
mBackupConnStatsSet
(
false
)
mFreeToUse
(
true
)
mPrimaryStreamStatus
(
NS_OK
)
mEnt
(
ent
)
{
MOZ_ASSERT
(
ent
&
&
trans
"
constructor
with
null
arguments
"
)
;
LOG
(
(
"
Creating
HalfOpenSocket
[
this
=
%
p
trans
=
%
p
ent
=
%
s
key
=
%
s
]
\
n
"
this
trans
ent
-
>
mConnInfo
-
>
Origin
(
)
ent
-
>
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
mIsHttp3
=
mEnt
-
>
mConnInfo
-
>
IsHttp3
(
)
;
if
(
speculative
)
{
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
HTTPCONNMGR_TOTAL_SPECULATIVE_CONN
>
totalSpeculativeConn
;
+
+
totalSpeculativeConn
;
if
(
isFromPredictor
)
{
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
PREDICTOR_TOTAL_PRECONNECTS_CREATED
>
totalPreconnectsCreated
;
+
+
totalPreconnectsCreated
;
}
}
MOZ_ASSERT
(
mEnt
)
;
}
HalfOpenSocket
:
:
~
HalfOpenSocket
(
)
{
MOZ_ASSERT
(
!
mStreamOut
)
;
MOZ_ASSERT
(
!
mBackupStreamOut
)
;
LOG
(
(
"
Destroying
HalfOpenSocket
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mEnt
)
{
bool
inqueue
=
mEnt
-
>
RemoveHalfOpen
(
this
)
;
LOG
(
(
"
Destroying
HalfOpenSocket
was
in
the
HalfOpenList
=
%
d
[
this
=
%
p
]
\
n
"
inqueue
this
)
)
;
}
}
nsresult
HalfOpenSocket
:
:
SetupStreams
(
nsISocketTransport
*
*
transport
nsIAsyncInputStream
*
*
instream
nsIAsyncOutputStream
*
*
outstream
bool
isBackup
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mEnt
)
;
nsresult
rv
;
nsTArray
<
nsCString
>
socketTypes
;
const
nsHttpConnectionInfo
*
ci
=
mEnt
-
>
mConnInfo
;
if
(
mIsHttp3
)
{
socketTypes
.
AppendElement
(
"
quic
"
_ns
)
;
}
else
{
if
(
ci
-
>
FirstHopSSL
(
)
)
{
socketTypes
.
AppendElement
(
"
ssl
"
_ns
)
;
}
else
{
const
nsCString
&
defaultType
=
gHttpHandler
-
>
DefaultSocketType
(
)
;
if
(
!
defaultType
.
IsVoid
(
)
)
{
socketTypes
.
AppendElement
(
defaultType
)
;
}
}
}
nsCOMPtr
<
nsISocketTransport
>
socketTransport
;
nsCOMPtr
<
nsISocketTransportService
>
sts
;
sts
=
services
:
:
GetSocketTransportService
(
)
;
if
(
!
sts
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
LOG
(
(
"
HalfOpenSocket
:
:
SetupStreams
[
this
=
%
p
ent
=
%
s
]
"
"
setup
routed
transport
to
origin
%
s
:
%
d
via
%
s
:
%
d
\
n
"
this
ci
-
>
HashKey
(
)
.
get
(
)
ci
-
>
Origin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
RoutedHost
(
)
ci
-
>
RoutedPort
(
)
)
)
;
nsCOMPtr
<
nsIRoutedSocketTransportService
>
routedSTS
(
do_QueryInterface
(
sts
)
)
;
if
(
routedSTS
)
{
rv
=
routedSTS
-
>
CreateRoutedTransport
(
socketTypes
ci
-
>
GetOrigin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
GetRoutedHost
(
)
ci
-
>
RoutedPort
(
)
ci
-
>
ProxyInfo
(
)
getter_AddRefs
(
socketTransport
)
)
;
}
else
{
if
(
!
ci
-
>
GetRoutedHost
(
)
.
IsEmpty
(
)
)
{
LOG
(
(
"
HalfOpenSocket
this
=
%
p
using
legacy
nsISocketTransportService
"
"
means
explicit
route
%
s
:
%
d
will
be
ignored
.
\
n
"
this
ci
-
>
RoutedHost
(
)
ci
-
>
RoutedPort
(
)
)
)
;
}
rv
=
sts
-
>
CreateTransport
(
socketTypes
ci
-
>
GetOrigin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
ProxyInfo
(
)
getter_AddRefs
(
socketTransport
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
tmpFlags
=
0
;
if
(
mCaps
&
NS_HTTP_REFRESH_DNS
)
{
tmpFlags
=
nsISocketTransport
:
:
BYPASS_CACHE
;
}
tmpFlags
|
=
nsISocketTransport
:
:
GetFlagsFromTRRMode
(
NS_HTTP_TRR_MODE_FROM_FLAGS
(
mCaps
)
)
;
if
(
mCaps
&
NS_HTTP_LOAD_ANONYMOUS
)
{
tmpFlags
|
=
nsISocketTransport
:
:
ANONYMOUS_CONNECT
;
}
if
(
ci
-
>
GetPrivate
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
NO_PERMANENT_STORAGE
;
}
Unused
<
<
socketTransport
-
>
SetIsPrivate
(
ci
-
>
GetPrivate
(
)
)
;
if
(
ci
-
>
GetLessThanTls13
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DONT_TRY_ECH
;
}
if
(
(
(
mCaps
&
NS_HTTP_BE_CONSERVATIVE
)
|
|
ci
-
>
GetBeConservative
(
)
)
&
&
gHttpHandler
-
>
ConnMgr
(
)
-
>
BeConservativeIfProxied
(
ci
-
>
ProxyInfo
(
)
)
)
{
LOG
(
(
"
Setting
Socket
to
BE_CONSERVATIVE
"
)
)
;
tmpFlags
|
=
nsISocketTransport
:
:
BE_CONSERVATIVE
;
}
if
(
ci
-
>
HasIPHintAddress
(
)
)
{
nsCOMPtr
<
nsIDNSService
>
dns
=
do_GetService
(
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIDNSRecord
>
record
;
rv
=
dns
-
>
ResolveNative
(
ci
-
>
GetRoutedHost
(
)
nsIDNSService
:
:
RESOLVE_OFFLINE
mEnt
-
>
mConnInfo
-
>
GetOriginAttributes
(
)
getter_AddRefs
(
record
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
record
)
{
LOG
(
(
"
Setting
Socket
to
use
IP
hint
address
"
)
)
;
tmpFlags
|
=
nsISocketTransport
:
:
USE_IP_HINT_ADDRESS
;
}
}
if
(
mCaps
&
NS_HTTP_DISABLE_IPV4
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV4
;
}
else
if
(
mCaps
&
NS_HTTP_DISABLE_IPV6
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV6
;
}
else
if
(
mEnt
-
>
PreferenceKnown
(
)
)
{
if
(
mEnt
-
>
mPreferIPv6
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV4
;
}
else
if
(
mEnt
-
>
mPreferIPv4
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV6
;
}
tmpFlags
|
=
nsISocketTransport
:
:
RETRY_WITH_DIFFERENT_IP_FAMILY
;
uint16_t
fallbackTimeout
=
isBackup
?
gHttpHandler
-
>
GetFallbackSynTimeout
(
)
:
0
;
if
(
fallbackTimeout
)
{
socketTransport
-
>
SetTimeout
(
nsISocketTransport
:
:
TIMEOUT_CONNECT
fallbackTimeout
)
;
}
}
else
if
(
isBackup
&
&
gHttpHandler
-
>
FastFallbackToIPv4
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_IPV6
;
}
if
(
!
Allow1918
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_RFC1918
;
}
MOZ_ASSERT
(
!
(
tmpFlags
&
nsISocketTransport
:
:
DISABLE_IPV4
)
|
|
!
(
tmpFlags
&
nsISocketTransport
:
:
DISABLE_IPV6
)
"
Both
types
should
not
be
disabled
at
the
same
time
.
"
)
;
socketTransport
-
>
SetConnectionFlags
(
tmpFlags
)
;
socketTransport
-
>
SetTlsFlags
(
ci
-
>
GetTlsFlags
(
)
)
;
const
OriginAttributes
&
originAttributes
=
mEnt
-
>
mConnInfo
-
>
GetOriginAttributes
(
)
;
if
(
originAttributes
!
=
OriginAttributes
(
)
)
{
socketTransport
-
>
SetOriginAttributes
(
originAttributes
)
;
}
socketTransport
-
>
SetQoSBits
(
gHttpHandler
-
>
GetQoSBits
(
)
)
;
rv
=
socketTransport
-
>
SetEventSink
(
this
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
socketTransport
-
>
SetSecurityCallbacks
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
gHttpHandler
-
>
EchConfigEnabled
(
)
)
{
rv
=
socketTransport
-
>
SetEchConfig
(
ci
-
>
GetEchConfig
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_CONNECTION_ENTRY_CACHE_HIT_1
mEnt
-
>
mUsedForConnection
)
;
mEnt
-
>
mUsedForConnection
=
true
;
nsCOMPtr
<
nsIOutputStream
>
sout
;
rv
=
socketTransport
-
>
OpenOutputStream
(
nsITransport
:
:
OPEN_UNBUFFERED
0
0
getter_AddRefs
(
sout
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
sin
;
rv
=
socketTransport
-
>
OpenInputStream
(
nsITransport
:
:
OPEN_UNBUFFERED
0
0
getter_AddRefs
(
sin
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
socketTransport
.
forget
(
transport
)
;
CallQueryInterface
(
sin
instream
)
;
CallQueryInterface
(
sout
outstream
)
;
rv
=
(
*
outstream
)
-
>
AsyncWait
(
this
0
0
nullptr
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
StartedConnect
(
)
;
}
return
rv
;
}
nsresult
HalfOpenSocket
:
:
SetupPrimaryStreams
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
nsresult
rv
;
mPrimarySynStarted
=
TimeStamp
:
:
Now
(
)
;
rv
=
SetupStreams
(
getter_AddRefs
(
mSocketTransport
)
getter_AddRefs
(
mStreamIn
)
getter_AddRefs
(
mStreamOut
)
false
)
;
LOG
(
(
"
HalfOpenSocket
:
:
SetupPrimaryStream
[
this
=
%
p
ent
=
%
s
rv
=
%
"
PRIx32
"
]
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mStreamOut
)
{
mStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
}
mStreamOut
=
nullptr
;
mStreamIn
=
nullptr
;
mSocketTransport
=
nullptr
;
}
return
rv
;
}
nsresult
HalfOpenSocket
:
:
SetupBackupStreams
(
)
{
MOZ_ASSERT
(
mTransaction
)
;
mBackupSynStarted
=
TimeStamp
:
:
Now
(
)
;
nsresult
rv
=
SetupStreams
(
getter_AddRefs
(
mBackupTransport
)
getter_AddRefs
(
mBackupStreamIn
)
getter_AddRefs
(
mBackupStreamOut
)
true
)
;
LOG
(
(
"
HalfOpenSocket
:
:
SetupBackupStream
[
this
=
%
p
ent
=
%
s
rv
=
%
"
PRIx32
"
]
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mBackupStreamOut
)
{
mBackupStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
}
mBackupStreamOut
=
nullptr
;
mBackupStreamIn
=
nullptr
;
mBackupTransport
=
nullptr
;
}
return
rv
;
}
void
HalfOpenSocket
:
:
SetupBackupTimer
(
)
{
MOZ_ASSERT
(
mEnt
)
;
uint16_t
timeout
=
gHttpHandler
-
>
GetIdleSynTimeout
(
)
;
MOZ_ASSERT
(
!
mSynTimer
"
timer
already
initd
"
)
;
if
(
timeout
&
&
!
mSpeculative
)
{
NS_NewTimerWithCallback
(
getter_AddRefs
(
mSynTimer
)
this
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
LOG
(
(
"
HalfOpenSocket
:
:
SetupBackupTimer
(
)
[
this
=
%
p
]
"
this
)
)
;
}
else
if
(
timeout
)
{
LOG
(
(
"
HalfOpenSocket
:
:
SetupBackupTimer
(
)
[
this
=
%
p
]
did
not
arm
\
n
"
this
)
)
;
}
}
void
HalfOpenSocket
:
:
CancelBackupTimer
(
)
{
if
(
!
mSynTimer
)
{
return
;
}
LOG
(
(
"
HalfOpenSocket
:
:
CancelBackupTimer
(
)
"
)
)
;
mSynTimer
-
>
Cancel
(
)
;
}
void
HalfOpenSocket
:
:
Abandon
(
)
{
LOG
(
(
"
HalfOpenSocket
:
:
Abandon
[
this
=
%
p
ent
=
%
s
]
%
p
%
p
%
p
%
p
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
mSocketTransport
.
get
(
)
mBackupTransport
.
get
(
)
mStreamOut
.
get
(
)
mBackupStreamOut
.
get
(
)
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
RefPtr
<
HalfOpenSocket
>
deleteProtector
(
this
)
;
if
(
mSocketTransport
)
{
mSocketTransport
-
>
SetEventSink
(
nullptr
nullptr
)
;
mSocketTransport
-
>
SetSecurityCallbacks
(
nullptr
)
;
mSocketTransport
=
nullptr
;
}
if
(
mBackupTransport
)
{
mBackupTransport
-
>
SetEventSink
(
nullptr
nullptr
)
;
mBackupTransport
-
>
SetSecurityCallbacks
(
nullptr
)
;
mBackupTransport
=
nullptr
;
}
if
(
mStreamOut
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
RecvdConnect
(
)
;
mStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mStreamOut
=
nullptr
;
}
if
(
mBackupStreamOut
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
RecvdConnect
(
)
;
mBackupStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mBackupStreamOut
=
nullptr
;
}
if
(
mStreamIn
)
{
mStreamIn
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mStreamIn
=
nullptr
;
}
if
(
mBackupStreamIn
)
{
mBackupStreamIn
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mBackupStreamIn
=
nullptr
;
}
CancelBackupTimer
(
)
;
if
(
mEnt
)
{
mEnt
-
>
mDoNotDestroy
=
false
;
mEnt
-
>
RemoveHalfOpen
(
this
)
;
}
mEnt
=
nullptr
;
}
double
HalfOpenSocket
:
:
Duration
(
TimeStamp
epoch
)
{
if
(
mPrimarySynStarted
.
IsNull
(
)
)
{
return
0
;
}
return
(
epoch
-
mPrimarySynStarted
)
.
ToMilliseconds
(
)
;
}
NS_IMETHODIMP
HalfOpenSocket
:
:
Notify
(
nsITimer
*
timer
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
timer
=
=
mSynTimer
"
wrong
timer
"
)
;
MOZ_ASSERT
(
!
mBackupTransport
)
;
MOZ_ASSERT
(
mSynTimer
)
;
MOZ_ASSERT
(
mEnt
)
;
DebugOnly
<
nsresult
>
rv
=
SetupBackupStreams
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HalfOpenSocket
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
HalfOpenSocket
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HalfOpenSocket
:
:
OnOutputStreamReady
(
nsIAsyncOutputStream
*
out
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mStreamOut
|
|
mBackupStreamOut
)
;
MOZ_ASSERT
(
out
=
=
mStreamOut
|
|
out
=
=
mBackupStreamOut
"
stream
mismatch
"
)
;
MOZ_ASSERT
(
mEnt
)
;
LOG
(
(
"
HalfOpenSocket
:
:
OnOutputStreamReady
[
this
=
%
p
ent
=
%
s
%
s
]
\
n
"
this
mEnt
-
>
mConnInfo
-
>
Origin
(
)
out
=
=
mStreamOut
?
"
primary
"
:
"
backup
"
)
)
;
mEnt
-
>
mDoNotDestroy
=
true
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
RecvdConnect
(
)
;
CancelBackupTimer
(
)
;
nsresult
rv
=
SetupConn
(
out
)
;
if
(
mEnt
)
{
mEnt
-
>
mDoNotDestroy
=
false
;
}
return
rv
;
}
nsresult
HalfOpenSocket
:
:
SetupConn
(
nsIAsyncOutputStream
*
out
)
{
RefPtr
<
HttpConnectionBase
>
conn
;
if
(
!
mIsHttp3
)
{
conn
=
new
nsHttpConnection
(
)
;
}
else
{
conn
=
new
HttpConnectionUDP
(
)
;
}
LOG
(
(
"
HalfOpenSocket
:
:
SetupConn
"
"
Created
new
nshttpconnection
%
p
%
s
\
n
"
conn
.
get
(
)
mIsHttp3
?
"
using
http3
"
:
"
"
)
)
;
NullHttpTransaction
*
nullTrans
=
mTransaction
-
>
QueryNullTransaction
(
)
;
if
(
nullTrans
)
{
conn
-
>
BootstrapTimings
(
nullTrans
-
>
Timings
(
)
)
;
}
conn
-
>
SetTransactionCaps
(
mTransaction
-
>
Caps
(
)
)
;
NetAddr
peeraddr
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
mTransaction
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
nsresult
rv
;
if
(
out
=
=
mStreamOut
)
{
TimeDuration
rtt
=
TimeStamp
:
:
Now
(
)
-
mPrimarySynStarted
;
rv
=
conn
-
>
Init
(
mEnt
-
>
mConnInfo
gHttpHandler
-
>
ConnMgr
(
)
-
>
mMaxRequestDelay
mSocketTransport
mStreamIn
mStreamOut
mPrimaryConnectedOK
callbacks
PR_MillisecondsToInterval
(
static_cast
<
uint32_t
>
(
rtt
.
ToMilliseconds
(
)
)
)
)
;
bool
resetPreference
=
false
;
mSocketTransport
-
>
GetResetIPFamilyPreference
(
&
resetPreference
)
;
if
(
resetPreference
)
{
mEnt
-
>
ResetIPFamilyPreference
(
)
;
}
if
(
NS_SUCCEEDED
(
mSocketTransport
-
>
GetPeerAddr
(
&
peeraddr
)
)
)
{
mEnt
-
>
RecordIPFamilyPreference
(
peeraddr
.
raw
.
family
)
;
}
mStreamOut
=
nullptr
;
mStreamIn
=
nullptr
;
mSocketTransport
=
nullptr
;
}
else
if
(
out
=
=
mBackupStreamOut
)
{
TimeDuration
rtt
=
TimeStamp
:
:
Now
(
)
-
mBackupSynStarted
;
rv
=
conn
-
>
Init
(
mEnt
-
>
mConnInfo
gHttpHandler
-
>
ConnMgr
(
)
-
>
mMaxRequestDelay
mBackupTransport
mBackupStreamIn
mBackupStreamOut
mBackupConnectedOK
callbacks
PR_MillisecondsToInterval
(
static_cast
<
uint32_t
>
(
rtt
.
ToMilliseconds
(
)
)
)
)
;
bool
resetPreference
=
false
;
mBackupTransport
-
>
GetResetIPFamilyPreference
(
&
resetPreference
)
;
if
(
resetPreference
)
{
mEnt
-
>
ResetIPFamilyPreference
(
)
;
}
if
(
NS_SUCCEEDED
(
mBackupTransport
-
>
GetPeerAddr
(
&
peeraddr
)
)
)
{
mEnt
-
>
RecordIPFamilyPreference
(
peeraddr
.
raw
.
family
)
;
}
mBackupStreamOut
=
nullptr
;
mBackupStreamIn
=
nullptr
;
mBackupTransport
=
nullptr
;
}
else
{
MOZ_ASSERT
(
false
"
unexpected
stream
"
)
;
rv
=
NS_ERROR_UNEXPECTED
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
HalfOpenSocket
:
:
SetupConn
"
"
conn
-
>
init
(
%
p
)
failed
%
"
PRIx32
"
\
n
"
conn
.
get
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
nsHttpTransaction
*
trans
=
mTransaction
-
>
QueryHttpTransaction
(
)
)
{
if
(
mIsHttp3
)
{
trans
-
>
DisableHttp3
(
)
;
gHttpHandler
-
>
ExcludeHttp3
(
mEnt
-
>
mConnInfo
)
;
}
mEnt
-
>
RemoveTransFromPendingQ
(
trans
)
;
}
mTransaction
-
>
Close
(
rv
)
;
return
rv
;
}
mHasConnected
=
true
;
RefPtr
<
PendingTransactionInfo
>
pendingTransInfo
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
FindTransactionHelper
(
true
mEnt
mTransaction
)
;
if
(
pendingTransInfo
)
{
MOZ_ASSERT
(
!
mSpeculative
"
Speculative
Half
Open
found
mTransaction
"
)
;
mEnt
-
>
InsertIntoActiveConns
(
conn
)
;
if
(
mIsHttp3
)
{
RefPtr
<
ConnectionHandle
>
handle
=
new
ConnectionHandle
(
conn
)
;
pendingTransInfo
-
>
Transaction
(
)
-
>
SetConnection
(
handle
)
;
}
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchTransaction
(
mEnt
pendingTransInfo
-
>
Transaction
(
)
conn
)
;
}
else
{
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
if
(
connTCP
)
{
connTCP
-
>
SetIsReusedAfter
(
950
)
;
}
if
(
!
connTCP
|
|
(
mEnt
-
>
mConnInfo
-
>
FirstHopSSL
(
)
&
&
!
mEnt
-
>
UrgentStartQueueLength
(
)
&
&
!
mEnt
-
>
PendingQueueLength
(
)
&
&
!
mEnt
-
>
mConnInfo
-
>
UsingConnect
(
)
)
)
{
LOG
(
(
"
HalfOpenSocket
:
:
SetupConn
null
transaction
will
"
"
be
used
to
finish
SSL
handshake
on
conn
%
p
\
n
"
conn
.
get
(
)
)
)
;
RefPtr
<
nsAHttpTransaction
>
trans
;
if
(
mTransaction
-
>
IsNullTransaction
(
)
&
&
!
mDispatchedMTransaction
)
{
mDispatchedMTransaction
=
true
;
trans
=
mTransaction
;
}
else
{
trans
=
new
NullHttpTransaction
(
mEnt
-
>
mConnInfo
callbacks
mCaps
)
;
}
mEnt
-
>
InsertIntoActiveConns
(
conn
)
;
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchAbstractTransaction
(
mEnt
trans
mCaps
conn
0
)
;
}
else
{
LOG
(
(
"
HalfOpenSocket
:
:
SetupConn
no
transaction
match
"
"
returning
conn
%
p
to
pool
\
n
"
conn
.
get
(
)
)
)
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
OnMsgReclaimConnection
(
conn
)
;
if
(
mEnt
&
&
mEnt
-
>
mConnInfo
-
>
FirstHopSSL
(
)
&
&
!
mEnt
-
>
mConnInfo
-
>
UsingConnect
(
)
)
{
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
if
(
connTCP
&
&
NS_SUCCEEDED
(
mEnt
-
>
RemoveIdleConnection
(
connTCP
)
)
)
{
RefPtr
<
nsAHttpTransaction
>
trans
;
if
(
mTransaction
-
>
IsNullTransaction
(
)
&
&
!
mDispatchedMTransaction
)
{
mDispatchedMTransaction
=
true
;
trans
=
mTransaction
;
}
else
{
trans
=
new
NullHttpTransaction
(
mEnt
-
>
mConnInfo
callbacks
mCaps
)
;
}
mEnt
-
>
InsertIntoActiveConns
(
conn
)
;
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchAbstractTransaction
(
mEnt
trans
mCaps
conn
0
)
;
}
}
}
}
if
(
conn
-
>
Transaction
(
)
&
&
!
conn
-
>
Transaction
(
)
-
>
IsNullTransaction
(
)
)
{
Claim
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
HalfOpenSocket
:
:
OnTransportStatus
(
nsITransport
*
trans
nsresult
status
int64_t
progress
int64_t
progressMax
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
(
trans
=
=
mSocketTransport
)
|
|
(
trans
=
=
mBackupTransport
)
)
;
MOZ_ASSERT
(
mEnt
)
;
if
(
mTransaction
)
{
if
(
(
trans
=
=
mSocketTransport
)
|
|
(
(
trans
=
=
mBackupTransport
)
&
&
(
status
=
=
NS_NET_STATUS_CONNECTED_TO
)
&
&
mSocketTransport
)
)
{
mTransaction
-
>
OnTransportStatus
(
trans
status
progress
)
;
}
}
MOZ_ASSERT
(
trans
=
=
mSocketTransport
|
|
trans
=
=
mBackupTransport
)
;
if
(
status
=
=
NS_NET_STATUS_CONNECTED_TO
)
{
if
(
trans
=
=
mSocketTransport
)
{
mPrimaryConnectedOK
=
true
;
}
else
{
mBackupConnectedOK
=
true
;
}
}
if
(
trans
!
=
mSocketTransport
)
{
return
NS_OK
;
}
mPrimaryStreamStatus
=
status
;
if
(
status
=
=
NS_NET_STATUS_CONNECTING_TO
&
&
gHttpHandler
-
>
IsSpdyEnabled
(
)
&
&
gHttpHandler
-
>
CoalesceSpdy
(
)
&
&
mEnt
&
&
mEnt
-
>
mConnInfo
&
&
mEnt
-
>
mConnInfo
-
>
EndToEndSSL
(
)
&
&
mEnt
-
>
AllowHttp2
(
)
&
&
!
mEnt
-
>
mConnInfo
-
>
UsingProxy
(
)
&
&
mEnt
-
>
mCoalescingKeys
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIDNSAddrRecord
>
dnsRecord
(
do_GetInterface
(
mSocketTransport
)
)
;
nsTArray
<
NetAddr
>
addressSet
;
nsresult
rv
=
NS_ERROR_NOT_AVAILABLE
;
if
(
dnsRecord
)
{
rv
=
dnsRecord
-
>
GetAddresses
(
addressSet
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
addressSet
.
IsEmpty
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
addressSet
.
Length
(
)
;
+
+
i
)
{
if
(
(
addressSet
[
i
]
.
raw
.
family
=
=
AF_INET
&
&
addressSet
[
i
]
.
inet
.
ip
=
=
0
)
|
|
(
addressSet
[
i
]
.
raw
.
family
=
=
AF_INET6
&
&
addressSet
[
i
]
.
inet6
.
ip
.
u64
[
0
]
=
=
0
&
&
addressSet
[
i
]
.
inet6
.
ip
.
u64
[
1
]
=
=
0
)
)
{
LOG
(
(
"
HalfOpenSocket
:
skip
creating
Coalescing
Key
for
host
[
%
s
]
"
mEnt
-
>
mConnInfo
-
>
Origin
(
)
)
)
;
continue
;
}
nsCString
*
newKey
=
mEnt
-
>
mCoalescingKeys
.
AppendElement
(
nsCString
(
)
)
;
newKey
-
>
SetLength
(
kIPv6CStrBufSize
+
26
)
;
addressSet
[
i
]
.
ToStringBuffer
(
newKey
-
>
BeginWriting
(
)
kIPv6CStrBufSize
)
;
newKey
-
>
SetLength
(
strlen
(
newKey
-
>
BeginReading
(
)
)
)
;
if
(
mEnt
-
>
mConnInfo
-
>
GetAnonymous
(
)
)
{
newKey
-
>
AppendLiteral
(
"
~
A
:
"
)
;
}
else
{
newKey
-
>
AppendLiteral
(
"
~
.
:
"
)
;
}
newKey
-
>
AppendInt
(
mEnt
-
>
mConnInfo
-
>
OriginPort
(
)
)
;
newKey
-
>
AppendLiteral
(
"
/
[
"
)
;
nsAutoCString
suffix
;
mEnt
-
>
mConnInfo
-
>
GetOriginAttributes
(
)
.
CreateSuffix
(
suffix
)
;
newKey
-
>
Append
(
suffix
)
;
newKey
-
>
AppendLiteral
(
"
]
viaDNS
"
)
;
LOG
(
(
"
HalfOpenSocket
:
:
OnTransportStatus
"
"
STATUS_CONNECTING_TO
Established
New
Coalescing
Key
#
%
d
for
host
"
"
%
s
[
%
s
]
"
i
mEnt
-
>
mConnInfo
-
>
Origin
(
)
newKey
-
>
get
(
)
)
)
;
}
gHttpHandler
-
>
ConnMgr
(
)
-
>
ProcessSpdyPendingQ
(
mEnt
)
;
}
}
switch
(
status
)
{
case
NS_NET_STATUS_CONNECTING_TO
:
if
(
mEnt
&
&
!
mBackupTransport
&
&
!
mSynTimer
&
&
!
mIsHttp3
)
{
SetupBackupTimer
(
)
;
}
break
;
case
NS_NET_STATUS_CONNECTED_TO
:
CancelBackupTimer
(
)
;
break
;
default
:
break
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HalfOpenSocket
:
:
GetInterface
(
const
nsIID
&
iid
void
*
*
result
)
{
if
(
mTransaction
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
mTransaction
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
callbacks
)
{
return
callbacks
-
>
GetInterface
(
iid
result
)
;
}
}
return
NS_ERROR_NO_INTERFACE
;
}
bool
HalfOpenSocket
:
:
AcceptsTransaction
(
nsHttpTransaction
*
trans
)
{
return
!
mUrgentStart
|
|
(
trans
-
>
Caps
(
)
&
nsIClassOfService
:
:
UrgentStart
)
;
}
bool
HalfOpenSocket
:
:
Claim
(
)
{
if
(
mSpeculative
)
{
mSpeculative
=
false
;
uint32_t
flags
;
if
(
mSocketTransport
&
&
NS_SUCCEEDED
(
mSocketTransport
-
>
GetConnectionFlags
(
&
flags
)
)
)
{
flags
&
=
~
nsISocketTransport
:
:
DISABLE_RFC1918
;
mSocketTransport
-
>
SetConnectionFlags
(
flags
)
;
}
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
HTTPCONNMGR_USED_SPECULATIVE_CONN
>
usedSpeculativeConn
;
+
+
usedSpeculativeConn
;
if
(
mIsFromPredictor
)
{
Telemetry
:
:
AutoCounter
<
Telemetry
:
:
PREDICTOR_TOTAL_PRECONNECTS_USED
>
totalPreconnectsUsed
;
+
+
totalPreconnectsUsed
;
}
if
(
(
mPrimaryStreamStatus
=
=
NS_NET_STATUS_CONNECTING_TO
)
&
&
mEnt
&
&
!
mBackupTransport
&
&
!
mSynTimer
&
&
!
mIsHttp3
)
{
SetupBackupTimer
(
)
;
}
}
if
(
mFreeToUse
)
{
mFreeToUse
=
false
;
return
true
;
}
return
false
;
}
void
HalfOpenSocket
:
:
Unclaim
(
)
{
MOZ_ASSERT
(
!
mSpeculative
&
&
!
mFreeToUse
)
;
mFreeToUse
=
true
;
}
}
}
