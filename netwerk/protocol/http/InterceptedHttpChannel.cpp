#
include
"
InterceptedHttpChannel
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceStorage
.
h
"
namespace
mozilla
{
namespace
net
{
NS_IMPL_ISUPPORTS_INHERITED
(
InterceptedHttpChannel
HttpBaseChannel
nsIInterceptedChannel
nsICacheInfoChannel
nsIAsyncVerifyRedirectCallback
nsIRequestObserver
nsIStreamListener
nsIChannelWithDivertableParentListener
nsIThreadRetargetableRequest
nsIThreadRetargetableStreamListener
)
InterceptedHttpChannel
:
:
InterceptedHttpChannel
(
PRTime
aCreationTime
const
TimeStamp
&
aCreationTimestamp
const
TimeStamp
&
aAsyncOpenTimestamp
)
:
HttpAsyncAborter
<
InterceptedHttpChannel
>
(
this
)
mProgress
(
0
)
mProgressReported
(
0
)
mSynthesizedStreamLength
(
-
1
)
mResumeStartPos
(
0
)
mSynthesizedOrReset
(
Invalid
)
mCallingStatusAndProgress
(
false
)
mDiverting
(
false
)
{
mChannelCreationTime
=
aCreationTime
;
mChannelCreationTimestamp
=
aCreationTimestamp
;
mAsyncOpenTime
=
aAsyncOpenTimestamp
;
}
void
InterceptedHttpChannel
:
:
ReleaseListeners
(
)
{
if
(
mLoadGroup
)
{
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
mStatus
)
;
}
HttpBaseChannel
:
:
ReleaseListeners
(
)
;
mSynthesizedResponseHead
.
reset
(
)
;
mRedirectChannel
=
nullptr
;
mBodyReader
=
nullptr
;
mReleaseHandle
=
nullptr
;
mProgressSink
=
nullptr
;
mBodyCallback
=
nullptr
;
mPump
=
nullptr
;
mParentChannel
=
nullptr
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsPending
)
;
}
nsresult
InterceptedHttpChannel
:
:
SetupReplacementChannel
(
nsIURI
*
aURI
nsIChannel
*
aChannel
bool
aPreserveMethod
uint32_t
aRedirectFlags
)
{
nsresult
rv
=
HttpBaseChannel
:
:
SetupReplacementChannel
(
aURI
aChannel
aPreserveMethod
aRedirectFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
CheckRedirectLimit
(
aRedirectFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mResumeStartPos
>
0
)
{
nsCOMPtr
<
nsIResumableChannel
>
resumable
=
do_QueryInterface
(
aChannel
)
;
if
(
!
resumable
)
{
return
NS_ERROR_NOT_RESUMABLE
;
}
resumable
-
>
ResumeAt
(
mResumeStartPos
mResumeEntityId
)
;
}
return
NS_OK
;
}
void
InterceptedHttpChannel
:
:
AsyncOpenInternal
(
)
{
nsresult
rv
=
NS_OK
;
if
(
mTimingEnabled
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mAsyncOpenTime
.
IsNull
(
)
)
;
}
mIsPending
=
true
;
mResponseCouldBeSynthesized
=
true
;
if
(
mLoadGroup
)
{
mLoadGroup
-
>
AddRequest
(
this
nullptr
)
;
}
if
(
mBodyReader
)
{
auto
autoCancel
=
MakeScopeExit
(
[
&
]
{
if
(
NS_FAILED
(
rv
)
)
{
Cancel
(
rv
)
;
}
}
)
;
if
(
ShouldRedirect
(
)
)
{
rv
=
FollowSyntheticRedirect
(
)
;
return
;
}
rv
=
StartPump
(
)
;
return
;
}
auto
autoReset
=
MakeScopeExit
(
[
&
]
{
if
(
NS_FAILED
(
rv
)
)
{
rv
=
ResetInterception
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Cancel
(
rv
)
;
}
}
}
)
;
nsCOMPtr
<
nsINetworkInterceptController
>
controller
;
GetCallback
(
controller
)
;
if
(
NS_WARN_IF
(
!
controller
)
)
{
rv
=
NS_ERROR_DOM_INVALID_STATE_ERR
;
return
;
}
rv
=
controller
-
>
ChannelIntercepted
(
this
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
bool
InterceptedHttpChannel
:
:
ShouldRedirect
(
)
const
{
return
nsHttpChannel
:
:
WillRedirect
(
mResponseHead
)
&
&
!
mLoadInfo
-
>
GetDontFollowRedirects
(
)
;
}
nsresult
InterceptedHttpChannel
:
:
FollowSyntheticRedirect
(
)
{
nsCOMPtr
<
nsIIOService
>
ioService
;
nsresult
rv
=
gHttpHandler
-
>
GetIOService
(
getter_AddRefs
(
ioService
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
location
;
rv
=
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Location
location
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
nsAutoCString
locationBuf
;
if
(
NS_EscapeURL
(
location
.
get
(
)
-
1
esc_OnlyNonASCII
|
esc_Spaces
locationBuf
)
)
{
location
=
locationBuf
;
}
nsCOMPtr
<
nsIURI
>
redirectURI
;
rv
=
ioService
-
>
NewURI
(
nsDependentCString
(
location
.
get
(
)
)
nullptr
mURI
getter_AddRefs
(
redirectURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_CORRUPTED_CONTENT
)
;
uint32_t
redirectFlags
=
nsIChannelEventSink
:
:
REDIRECT_TEMPORARY
;
if
(
nsHttp
:
:
IsPermanentRedirect
(
mResponseHead
-
>
Status
(
)
)
)
{
redirectFlags
=
nsIChannelEventSink
:
:
REDIRECT_PERMANENT
;
}
PropagateReferenceIfNeeded
(
mURI
redirectURI
)
;
bool
rewriteToGET
=
ShouldRewriteRedirectToGET
(
mResponseHead
-
>
Status
(
)
mRequestHead
.
ParsedMethod
(
)
)
;
nsCOMPtr
<
nsIChannel
>
newChannel
;
nsCOMPtr
<
nsILoadInfo
>
redirectLoadInfo
=
CloneLoadInfoForRedirect
(
redirectURI
redirectFlags
)
;
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
newChannel
)
redirectURI
redirectLoadInfo
nullptr
nullptr
nullptr
mLoadFlags
ioService
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupReplacementChannel
(
redirectURI
newChannel
!
rewriteToGET
redirectFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mRedirectChannel
=
newChannel
.
forget
(
)
;
rv
=
gHttpHandler
-
>
AsyncOnChannelRedirect
(
this
mRedirectChannel
redirectFlags
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
OnRedirectVerifyCallback
(
rv
)
;
}
return
rv
;
}
nsresult
InterceptedHttpChannel
:
:
RedirectForResponseURL
(
nsIURI
*
aResponseURI
bool
aResponseRedirected
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIInterceptedBodyCallback
>
bodyCallback
=
mBodyCallback
.
forget
(
)
;
RefPtr
<
InterceptedHttpChannel
>
newChannel
=
CreateForSynthesis
(
mResponseHead
mBodyReader
bodyCallback
mChannelCreationTime
mChannelCreationTimestamp
mAsyncOpenTime
)
;
rv
=
newChannel
-
>
Init
(
aResponseURI
mCaps
static_cast
<
nsProxyInfo
*
>
(
mProxyInfo
.
get
(
)
)
mProxyResolveFlags
mProxyURI
mChannelId
)
;
uint32_t
flags
=
aResponseRedirected
?
nsIChannelEventSink
:
:
REDIRECT_TEMPORARY
:
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
;
nsCOMPtr
<
nsILoadInfo
>
redirectLoadInfo
=
CloneLoadInfoForRedirect
(
aResponseURI
flags
)
;
newChannel
-
>
SetLoadInfo
(
redirectLoadInfo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
redirectLoadInfo
&
&
mLoadInfo
&
&
mLoadInfo
-
>
GetServiceWorkerTaintingSynthesized
(
)
)
{
redirectLoadInfo
-
>
SynthesizeServiceWorkerTainting
(
mLoadInfo
-
>
GetTainting
(
)
)
;
}
rv
=
SetupReplacementChannel
(
aResponseURI
newChannel
true
flags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mRedirectChannel
=
newChannel
;
rv
=
gHttpHandler
-
>
AsyncOnChannelRedirect
(
this
mRedirectChannel
flags
)
;
if
(
NS_FAILED
(
rv
)
)
{
bodyCallback
-
>
BodyComplete
(
rv
)
;
OnRedirectVerifyCallback
(
rv
)
;
}
return
rv
;
}
nsresult
InterceptedHttpChannel
:
:
StartPump
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mPump
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mBodyReader
)
;
if
(
mResumeStartPos
>
0
)
{
return
NS_ERROR_NOT_RESUMABLE
;
}
Unused
<
<
GetContentLength
(
&
mSynthesizedStreamLength
)
;
nsresult
rv
=
nsInputStreamPump
:
:
Create
(
getter_AddRefs
(
mPump
)
mBodyReader
0
0
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mPump
-
>
AsyncRead
(
this
mListenerContext
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
suspendCount
=
mSuspendCount
;
while
(
suspendCount
-
-
)
{
mPump
-
>
Suspend
(
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
mCanceled
)
;
return
rv
;
}
nsresult
InterceptedHttpChannel
:
:
OpenRedirectChannel
(
)
{
nsresult
rv
=
NS_OK
;
if
(
NS_FAILED
(
mStatus
)
)
{
return
mStatus
;
}
if
(
!
mRedirectChannel
)
{
return
NS_ERROR_DOM_ABORT_ERR
;
}
mRedirectChannel
-
>
SetOriginalURI
(
mOriginalURI
)
;
if
(
mLoadInfo
&
&
mLoadInfo
-
>
GetEnforceSecurity
(
)
)
{
MOZ_ASSERT
(
!
mListenerContext
"
mListenerContext
should
be
null
!
"
)
;
rv
=
mRedirectChannel
-
>
AsyncOpen2
(
mListener
)
;
}
else
{
rv
=
mRedirectChannel
-
>
AsyncOpen
(
mListener
mListenerContext
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mStatus
=
NS_BINDING_REDIRECTED
;
return
rv
;
}
void
InterceptedHttpChannel
:
:
MaybeCallStatusAndProgress
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
if
(
mCallingStatusAndProgress
)
{
return
;
}
mCallingStatusAndProgress
=
true
;
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
(
"
InterceptedHttpChannel
:
:
MaybeCallStatusAndProgress
"
this
&
InterceptedHttpChannel
:
:
MaybeCallStatusAndProgress
)
;
MOZ_ALWAYS_SUCCEEDS
(
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
)
;
return
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mCallingStatusAndProgress
=
false
;
int64_t
progress
=
mProgress
;
MOZ_DIAGNOSTIC_ASSERT
(
progress
>
=
mProgressReported
)
;
if
(
progress
<
=
mProgressReported
|
|
mCanceled
|
|
!
mProgressSink
|
|
(
mLoadFlags
&
HttpBaseChannel
:
:
LOAD_BACKGROUND
)
)
{
return
;
}
if
(
mProgressReported
=
=
0
)
{
nsAutoCString
host
;
MOZ_ALWAYS_SUCCEEDS
(
mURI
-
>
GetHost
(
host
)
)
;
CopyUTF8toUTF16
(
host
mStatusHost
)
;
}
mProgressSink
-
>
OnStatus
(
this
mListenerContext
NS_NET_STATUS_READING
mStatusHost
.
get
(
)
)
;
mProgressSink
-
>
OnProgress
(
this
mListenerContext
progress
mSynthesizedStreamLength
)
;
mProgressReported
=
progress
;
}
void
InterceptedHttpChannel
:
:
MaybeCallBodyCallback
(
)
{
nsCOMPtr
<
nsIInterceptedBodyCallback
>
callback
=
mBodyCallback
.
forget
(
)
;
if
(
callback
)
{
callback
-
>
BodyComplete
(
mStatus
)
;
}
}
already_AddRefed
<
InterceptedHttpChannel
>
InterceptedHttpChannel
:
:
CreateForInterception
(
PRTime
aCreationTime
const
TimeStamp
&
aCreationTimestamp
const
TimeStamp
&
aAsyncOpenTimestamp
)
{
RefPtr
<
InterceptedHttpChannel
>
ref
=
new
InterceptedHttpChannel
(
aCreationTime
aCreationTimestamp
aAsyncOpenTimestamp
)
;
return
ref
.
forget
(
)
;
}
already_AddRefed
<
InterceptedHttpChannel
>
InterceptedHttpChannel
:
:
CreateForSynthesis
(
const
nsHttpResponseHead
*
aHead
nsIInputStream
*
aBody
nsIInterceptedBodyCallback
*
aBodyCallback
PRTime
aCreationTime
const
TimeStamp
&
aCreationTimestamp
const
TimeStamp
&
aAsyncOpenTimestamp
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aHead
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBody
)
;
RefPtr
<
InterceptedHttpChannel
>
ref
=
new
InterceptedHttpChannel
(
aCreationTime
aCreationTimestamp
aAsyncOpenTimestamp
)
;
ref
-
>
mResponseHead
=
new
nsHttpResponseHead
(
*
aHead
)
;
ref
-
>
mBodyReader
=
aBody
;
ref
-
>
mBodyCallback
=
aBodyCallback
;
return
ref
.
forget
(
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
Cancel
(
nsresult
aStatus
)
{
if
(
mCanceled
)
{
return
NS_OK
;
}
mCanceled
=
true
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
aStatus
)
)
;
if
(
NS_SUCCEEDED
(
mStatus
)
)
{
mStatus
=
aStatus
;
}
if
(
mDiverting
)
{
Unused
<
<
mParentChannel
-
>
CancelDiversion
(
)
;
}
if
(
mPump
)
{
return
mPump
-
>
Cancel
(
mStatus
)
;
}
return
AsyncAbort
(
mStatus
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
Suspend
(
void
)
{
nsresult
rv
=
SuspendInternal
(
)
;
nsresult
rvParentChannel
=
NS_OK
;
if
(
mParentChannel
)
{
rvParentChannel
=
mParentChannel
-
>
SuspendMessageDiversion
(
)
;
}
return
NS_FAILED
(
rv
)
?
rv
:
rvParentChannel
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
Resume
(
void
)
{
nsresult
rv
=
ResumeInternal
(
)
;
nsresult
rvParentChannel
=
NS_OK
;
if
(
mParentChannel
)
{
rvParentChannel
=
mParentChannel
-
>
ResumeMessageDiversion
(
)
;
}
return
NS_FAILED
(
rv
)
?
rv
:
rvParentChannel
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetSecurityInfo
(
nsISupports
*
*
aSecurityInfo
)
{
nsCOMPtr
<
nsISupports
>
ref
(
mSecurityInfo
)
;
ref
.
forget
(
aSecurityInfo
)
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
AsyncOpen
(
nsIStreamListener
*
aListener
nsISupports
*
aContext
)
{
if
(
mCanceled
)
{
return
mStatus
;
}
mListener
=
aListener
;
AsyncOpenInternal
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
AsyncOpen2
(
nsIStreamListener
*
aListener
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
(
aListener
)
;
nsresult
rv
=
nsContentSecurityManager
:
:
doContentSecurityCheck
(
this
listener
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Cancel
(
rv
)
;
return
rv
;
}
return
AsyncOpen
(
listener
nullptr
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetupFallbackChannel
(
const
char
*
aFallbackKey
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetPriority
(
int32_t
aPriority
)
{
mPriority
=
clamped
<
int32_t
>
(
aPriority
INT16_MIN
INT16_MAX
)
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetClassFlags
(
uint32_t
aClassFlags
)
{
mClassOfService
=
aClassFlags
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
ClearClassFlags
(
uint32_t
aClassFlags
)
{
mClassOfService
&
=
~
aClassFlags
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
AddClassFlags
(
uint32_t
aClassFlags
)
{
mClassOfService
|
=
aClassFlags
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
ResumeAt
(
uint64_t
aStartPos
const
nsACString
&
aEntityId
)
{
mResumeStartPos
=
aStartPos
;
mResumeEntityId
=
aEntityId
;
return
NS_OK
;
}
void
InterceptedHttpChannel
:
:
DoNotifyListenerCleanup
(
)
{
}
void
InterceptedHttpChannel
:
:
DoAsyncAbort
(
nsresult
aStatus
)
{
Unused
<
<
AsyncAbort
(
aStatus
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
ResetInterception
(
void
)
{
if
(
mCanceled
)
{
return
mStatus
;
}
uint32_t
flags
=
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
;
nsCOMPtr
<
nsIChannel
>
newChannel
;
nsCOMPtr
<
nsILoadInfo
>
redirectLoadInfo
=
CloneLoadInfoForRedirect
(
mURI
flags
)
;
nsresult
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
newChannel
)
mURI
redirectLoadInfo
nullptr
nullptr
nullptr
mLoadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupReplacementChannel
(
mURI
newChannel
true
flags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsITimedChannel
>
newTimedChannel
=
do_QueryInterface
(
newChannel
)
;
if
(
newTimedChannel
)
{
if
(
!
mAsyncOpenTime
.
IsNull
(
)
)
{
newTimedChannel
-
>
SetAsyncOpen
(
mAsyncOpenTime
)
;
}
if
(
!
mChannelCreationTimestamp
.
IsNull
(
)
)
{
newTimedChannel
-
>
SetChannelCreation
(
mChannelCreationTimestamp
)
;
}
}
if
(
mRedirectMode
!
=
nsIHttpChannelInternal
:
:
REDIRECT_MODE_MANUAL
)
{
nsLoadFlags
loadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
rv
=
newChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
loadFlags
|
=
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
;
rv
=
newChannel
-
>
SetLoadFlags
(
loadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mRedirectChannel
=
newChannel
.
forget
(
)
;
rv
=
gHttpHandler
-
>
AsyncOnChannelRedirect
(
this
mRedirectChannel
flags
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnRedirectVerifyCallback
(
rv
)
;
}
return
rv
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SynthesizeStatus
(
uint16_t
aStatus
const
nsACString
&
aReason
)
{
if
(
mCanceled
)
{
return
mStatus
;
}
if
(
!
mSynthesizedResponseHead
)
{
mSynthesizedResponseHead
.
reset
(
new
nsHttpResponseHead
(
)
)
;
}
nsAutoCString
statusLine
;
statusLine
.
AppendLiteral
(
"
HTTP
/
1
.
1
"
)
;
statusLine
.
AppendInt
(
aStatus
)
;
statusLine
.
AppendLiteral
(
"
"
)
;
statusLine
.
Append
(
aReason
)
;
mSynthesizedResponseHead
-
>
ParseStatusLine
(
statusLine
)
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SynthesizeHeader
(
const
nsACString
&
aName
const
nsACString
&
aValue
)
{
if
(
mCanceled
)
{
return
mStatus
;
}
if
(
!
mSynthesizedResponseHead
)
{
mSynthesizedResponseHead
.
reset
(
new
nsHttpResponseHead
(
)
)
;
}
nsAutoCString
header
=
aName
+
NS_LITERAL_CSTRING
(
"
:
"
)
+
aValue
;
nsresult
rv
=
mSynthesizedResponseHead
-
>
ParseHeaderLine
(
header
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
StartSynthesizedResponse
(
nsIInputStream
*
aBody
nsIInterceptedBodyCallback
*
aBodyCallback
nsICacheInfoChannel
*
aSynthesizedCacheInfo
const
nsACString
&
aFinalURLSpec
bool
aResponseRedirected
)
{
nsresult
rv
=
NS_OK
;
auto
autoCleanup
=
MakeScopeExit
(
[
&
]
{
if
(
NS_FAILED
(
rv
)
)
{
Cancel
(
rv
)
;
}
if
(
aBodyCallback
)
{
aBodyCallback
-
>
BodyComplete
(
mStatus
)
;
}
}
)
;
if
(
NS_FAILED
(
mStatus
)
)
{
return
NS_OK
;
}
mBodyCallback
=
aBodyCallback
;
aBodyCallback
=
nullptr
;
mSynthesizedCacheInfo
=
aSynthesizedCacheInfo
;
if
(
!
mSynthesizedResponseHead
)
{
mSynthesizedResponseHead
.
reset
(
new
nsHttpResponseHead
(
)
)
;
}
mResponseHead
=
mSynthesizedResponseHead
.
release
(
)
;
if
(
ShouldRedirect
(
)
)
{
rv
=
FollowSyntheticRedirect
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
SetApplyConversion
(
false
)
;
mBodyReader
=
aBody
;
if
(
!
mBodyReader
)
{
rv
=
NS_NewCStringInputStream
(
getter_AddRefs
(
mBodyReader
)
EmptyCString
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIURI
>
responseURI
;
if
(
!
aFinalURLSpec
.
IsEmpty
(
)
)
{
rv
=
NS_NewURI
(
getter_AddRefs
(
responseURI
)
aFinalURLSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
responseURI
=
mURI
;
}
bool
equal
=
false
;
Unused
<
<
mURI
-
>
Equals
(
responseURI
&
equal
)
;
if
(
!
equal
)
{
rv
=
RedirectForResponseURL
(
responseURI
aResponseRedirected
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
rv
=
StartPump
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
FinishSynthesizedResponse
(
)
{
if
(
mCanceled
)
{
return
NS_OK
;
}
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
CancelInterception
(
nsresult
aStatus
)
{
return
Cancel
(
aStatus
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetChannel
(
nsIChannel
*
*
aChannel
)
{
nsCOMPtr
<
nsIChannel
>
ref
(
this
)
;
ref
.
forget
(
aChannel
)
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetSecureUpgradedChannelURI
(
nsIURI
*
*
aSecureUpgradedChannelURI
)
{
nsCOMPtr
<
nsIURI
>
ref
(
mURI
)
;
ref
.
forget
(
aSecureUpgradedChannelURI
)
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetChannelInfo
(
mozilla
:
:
dom
:
:
ChannelInfo
*
aChannelInfo
)
{
return
aChannelInfo
-
>
ResurrectInfoOnChannel
(
this
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetInternalContentPolicyType
(
nsContentPolicyType
*
aPolicyType
)
{
if
(
mLoadInfo
)
{
*
aPolicyType
=
mLoadInfo
-
>
InternalContentPolicyType
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetConsoleReportCollector
(
nsIConsoleReportCollector
*
*
aConsoleReportCollector
)
{
nsCOMPtr
<
nsIConsoleReportCollector
>
ref
(
this
)
;
ref
.
forget
(
aConsoleReportCollector
)
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetLaunchServiceWorkerStart
(
mozilla
:
:
TimeStamp
*
aTimeStamp
)
{
return
HttpBaseChannel
:
:
GetLaunchServiceWorkerStart
(
aTimeStamp
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetLaunchServiceWorkerStart
(
mozilla
:
:
TimeStamp
aTimeStamp
)
{
return
HttpBaseChannel
:
:
SetLaunchServiceWorkerStart
(
aTimeStamp
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetLaunchServiceWorkerEnd
(
mozilla
:
:
TimeStamp
*
aTimeStamp
)
{
return
HttpBaseChannel
:
:
GetLaunchServiceWorkerEnd
(
aTimeStamp
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetLaunchServiceWorkerEnd
(
mozilla
:
:
TimeStamp
aTimeStamp
)
{
return
HttpBaseChannel
:
:
SetLaunchServiceWorkerEnd
(
aTimeStamp
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetDispatchFetchEventStart
(
mozilla
:
:
TimeStamp
aTimeStamp
)
{
return
HttpBaseChannel
:
:
SetDispatchFetchEventStart
(
aTimeStamp
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetDispatchFetchEventEnd
(
mozilla
:
:
TimeStamp
aTimeStamp
)
{
return
HttpBaseChannel
:
:
SetDispatchFetchEventEnd
(
aTimeStamp
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetHandleFetchEventStart
(
mozilla
:
:
TimeStamp
aTimeStamp
)
{
return
HttpBaseChannel
:
:
SetHandleFetchEventStart
(
aTimeStamp
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetHandleFetchEventEnd
(
mozilla
:
:
TimeStamp
aTimeStamp
)
{
return
HttpBaseChannel
:
:
SetHandleFetchEventEnd
(
aTimeStamp
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetFinishResponseStart
(
mozilla
:
:
TimeStamp
aTimeStamp
)
{
mFinishResponseStart
=
aTimeStamp
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetFinishSynthesizedResponseEnd
(
mozilla
:
:
TimeStamp
aTimeStamp
)
{
MOZ_ASSERT
(
mSynthesizedOrReset
=
=
Invalid
)
;
mSynthesizedOrReset
=
Synthesized
;
mFinishResponseEnd
=
aTimeStamp
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetChannelResetEnd
(
mozilla
:
:
TimeStamp
aTimeStamp
)
{
MOZ_ASSERT
(
mSynthesizedOrReset
=
=
Invalid
)
;
mSynthesizedOrReset
=
Reset
;
mFinishResponseEnd
=
aTimeStamp
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SaveTimeStamps
(
void
)
{
if
(
mHandleFetchEventStart
.
IsNull
(
)
)
{
return
NS_OK
;
}
bool
isNonSubresourceRequest
=
nsContentUtils
:
:
IsNonSubresourceRequest
(
this
)
;
nsCString
navigationOrSubresource
=
isNonSubresourceRequest
?
NS_LITERAL_CSTRING
(
"
navigation
"
)
:
NS_LITERAL_CSTRING
(
"
subresource
"
)
;
nsAutoCString
subresourceKey
(
EmptyCString
(
)
)
;
GetSubresourceTimeStampKey
(
this
subresourceKey
)
;
if
(
!
mFinishResponseStart
.
IsNull
(
)
&
&
!
mFinishResponseEnd
.
IsNull
(
)
)
{
Telemetry
:
:
HistogramID
id
=
(
mSynthesizedOrReset
=
=
Synthesized
)
?
Telemetry
:
:
SERVICE_WORKER_FETCH_EVENT_FINISH_SYNTHESIZED_RESPONSE_MS
:
Telemetry
:
:
SERVICE_WORKER_FETCH_EVENT_CHANNEL_RESET_MS
;
Telemetry
:
:
Accumulate
(
id
navigationOrSubresource
static_cast
<
uint32_t
>
(
(
mFinishResponseEnd
-
mFinishResponseStart
)
.
ToMilliseconds
(
)
)
)
;
if
(
!
isNonSubresourceRequest
&
&
!
subresourceKey
.
IsEmpty
(
)
)
{
Telemetry
:
:
Accumulate
(
id
subresourceKey
static_cast
<
uint32_t
>
(
(
mFinishResponseEnd
-
mFinishResponseStart
)
.
ToMilliseconds
(
)
)
)
;
}
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SERVICE_WORKER_FETCH_EVENT_DISPATCH_MS
navigationOrSubresource
static_cast
<
uint32_t
>
(
(
mHandleFetchEventStart
-
mDispatchFetchEventStart
)
.
ToMilliseconds
(
)
)
)
;
if
(
!
isNonSubresourceRequest
&
&
!
subresourceKey
.
IsEmpty
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SERVICE_WORKER_FETCH_EVENT_DISPATCH_MS
subresourceKey
static_cast
<
uint32_t
>
(
(
mHandleFetchEventStart
-
mDispatchFetchEventStart
)
.
ToMilliseconds
(
)
)
)
;
}
if
(
!
mFinishResponseEnd
.
IsNull
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SERVICE_WORKER_FETCH_INTERCEPTION_DURATION_MS
navigationOrSubresource
static_cast
<
uint32_t
>
(
(
mFinishResponseEnd
-
mDispatchFetchEventStart
)
.
ToMilliseconds
(
)
)
)
;
if
(
!
isNonSubresourceRequest
&
&
!
subresourceKey
.
IsEmpty
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SERVICE_WORKER_FETCH_INTERCEPTION_DURATION_MS
subresourceKey
static_cast
<
uint32_t
>
(
(
mFinishResponseEnd
-
mDispatchFetchEventStart
)
.
ToMilliseconds
(
)
)
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetReleaseHandle
(
nsISupports
*
aHandle
)
{
mReleaseHandle
=
aHandle
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
OnRedirectVerifyCallback
(
nsresult
rv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
OpenRedirectChannel
(
)
;
}
nsCOMPtr
<
nsIRedirectResultListener
>
hook
;
GetCallback
(
hook
)
;
if
(
hook
)
{
hook
-
>
OnRedirectResult
(
NS_SUCCEEDED
(
rv
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
Cancel
(
rv
)
;
}
MaybeCallBodyCallback
(
)
;
mIsPending
=
false
;
ReleaseListeners
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mProgressSink
)
{
GetCallback
(
mProgressSink
)
;
}
if
(
mPump
&
&
mLoadFlags
&
LOAD_CALL_CONTENT_SNIFFERS
)
{
mPump
-
>
PeekStream
(
CallTypeSniffers
static_cast
<
nsIChannel
*
>
(
this
)
)
;
}
if
(
mListener
)
{
mListener
-
>
OnStartRequest
(
this
mListenerContext
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_SUCCEEDED
(
mStatus
)
)
{
mStatus
=
aStatus
;
}
MaybeCallBodyCallback
(
)
;
MaybeCallStatusAndProgress
(
)
;
mIsPending
=
false
;
MaybeReportTimingData
(
)
;
if
(
mListener
)
{
mListener
-
>
OnStopRequest
(
this
mListenerContext
mStatus
)
;
}
gHttpHandler
-
>
OnStopRequest
(
this
)
;
ReleaseListeners
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
if
(
mCanceled
|
|
!
mListener
)
{
uint32_t
unused
=
0
;
aInputStream
-
>
ReadSegments
(
NS_DiscardSegment
nullptr
aCount
&
unused
)
;
return
mStatus
;
}
if
(
mProgressSink
)
{
if
(
!
(
mLoadFlags
&
HttpBaseChannel
:
:
LOAD_BACKGROUND
)
)
{
mProgress
=
aOffset
+
aCount
;
MaybeCallStatusAndProgress
(
)
;
}
}
return
mListener
-
>
OnDataAvailable
(
this
mListenerContext
aInputStream
aOffset
aCount
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
MessageDiversionStarted
(
ADivertableParentChannel
*
aParentChannel
)
{
MOZ_ASSERT
(
!
mParentChannel
)
;
mParentChannel
=
aParentChannel
;
mDiverting
=
true
;
uint32_t
suspendCount
=
mSuspendCount
;
while
(
suspendCount
-
-
)
{
mParentChannel
-
>
SuspendMessageDiversion
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
MessageDiversionStop
(
)
{
MOZ_ASSERT
(
mParentChannel
)
;
mParentChannel
=
nullptr
;
mDiverting
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SuspendInternal
(
)
{
+
+
mSuspendCount
;
if
(
mPump
)
{
return
mPump
-
>
Suspend
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
ResumeInternal
(
)
{
-
-
mSuspendCount
;
if
(
mPump
)
{
return
mPump
-
>
Resume
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
RetargetDeliveryTo
(
nsIEventTarget
*
aNewTarget
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
aNewTarget
)
;
if
(
aNewTarget
-
>
IsOnCurrentThread
(
)
)
{
return
NS_OK
;
}
if
(
!
mPump
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
mPump
-
>
RetargetDeliveryTo
(
aNewTarget
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetDeliveryTarget
(
nsIEventTarget
*
*
aEventTarget
)
{
if
(
!
mPump
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
mPump
-
>
GetDeliveryTarget
(
aEventTarget
)
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
CheckListenerChain
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIThreadRetargetableStreamListener
>
retargetableListener
=
do_QueryInterface
(
mListener
&
rv
)
;
if
(
retargetableListener
)
{
rv
=
retargetableListener
-
>
CheckListenerChain
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
IsFromCache
(
bool
*
value
)
{
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
IsFromCache
(
value
)
;
}
*
value
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetCacheEntryId
(
uint64_t
*
aCacheEntryId
)
{
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
GetCacheEntryId
(
aCacheEntryId
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetCacheTokenFetchCount
(
int32_t
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
GetCacheTokenFetchCount
(
_retval
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetCacheTokenExpirationTime
(
uint32_t
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
GetCacheTokenExpirationTime
(
_retval
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetCacheTokenCachedCharset
(
nsACString
&
_retval
)
{
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
GetCacheTokenCachedCharset
(
_retval
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetCacheTokenCachedCharset
(
const
nsACString
&
aCharset
)
{
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
SetCacheTokenCachedCharset
(
aCharset
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetAllowStaleCacheContent
(
bool
aAllowStaleCacheContent
)
{
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
SetAllowStaleCacheContent
(
aAllowStaleCacheContent
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetAllowStaleCacheContent
(
bool
*
aAllowStaleCacheContent
)
{
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
GetAllowStaleCacheContent
(
aAllowStaleCacheContent
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
PreferAlternativeDataType
(
const
nsACString
&
aType
const
nsACString
&
aContentType
)
{
ENSURE_CALLED_BEFORE_ASYNC_OPEN
(
)
;
mPreferredCachedAltDataTypes
.
AppendElement
(
MakePair
(
nsCString
(
aType
)
nsCString
(
aContentType
)
)
)
;
return
NS_OK
;
}
const
nsTArray
<
mozilla
:
:
Tuple
<
nsCString
nsCString
>
>
&
InterceptedHttpChannel
:
:
PreferredAlternativeDataTypes
(
)
{
return
mPreferredCachedAltDataTypes
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetAlternativeDataType
(
nsACString
&
aType
)
{
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
GetAlternativeDataType
(
aType
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
OpenAlternativeOutputStream
(
const
nsACString
&
type
int64_t
predictedSize
nsIOutputStream
*
*
_retval
)
{
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
OpenAlternativeOutputStream
(
type
predictedSize
_retval
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
GetCacheKey
(
uint32_t
*
key
)
{
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
GetCacheKey
(
key
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
InterceptedHttpChannel
:
:
SetCacheKey
(
uint32_t
key
)
{
if
(
mSynthesizedCacheInfo
)
{
return
mSynthesizedCacheInfo
-
>
SetCacheKey
(
key
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
}
}
