#
ifndef
mozilla_net_HttpBackgroundChannelParent_h
#
define
mozilla_net_HttpBackgroundChannelParent_h
#
include
"
mozilla
/
net
/
PHttpBackgroundChannelParent
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsISupportsImpl
.
h
"
class
nsIEventTarget
;
namespace
mozilla
{
namespace
net
{
class
HttpChannelParent
;
class
HttpBackgroundChannelParent
final
:
public
PHttpBackgroundChannelParent
{
public
:
explicit
HttpBackgroundChannelParent
(
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
HttpBackgroundChannelParent
)
nsresult
Init
(
const
uint64_t
&
aChannelId
)
;
void
LinkToChannel
(
HttpChannelParent
*
aChannelParent
)
;
void
OnChannelClosed
(
)
;
bool
OnStartRequestSent
(
)
;
bool
OnTransportAndData
(
const
nsresult
&
aChannelStatus
const
nsresult
&
aTransportStatus
const
uint64_t
&
aOffset
const
uint32_t
&
aCount
const
nsCString
&
aData
)
;
bool
OnStopRequest
(
const
nsresult
&
aChannelStatus
const
ResourceTimingStruct
&
aTiming
const
nsHttpHeaderArray
&
aResponseTrailers
)
;
bool
OnProgress
(
const
int64_t
&
aProgress
const
int64_t
&
aProgressMax
)
;
bool
OnStatus
(
const
nsresult
&
aStatus
)
;
bool
OnDiversion
(
)
;
bool
OnNotifyTrackingProtectionDisabled
(
)
;
bool
OnNotifyTrackingResource
(
bool
aIsThirdParty
)
;
bool
OnSetClassifierMatchedInfo
(
const
nsACString
&
aList
const
nsACString
&
aProvider
const
nsACString
&
aFullHash
)
;
protected
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
private
:
virtual
~
HttpBackgroundChannelParent
(
)
;
Atomic
<
bool
>
mIPCOpened
;
Mutex
mBgThreadMutex
;
nsCOMPtr
<
nsIEventTarget
>
mBackgroundThread
;
RefPtr
<
HttpChannelParent
>
mChannelParent
;
}
;
}
}
#
endif
