#
include
"
HttpLog
.
h
"
#
include
"
HttpChannelParentListener
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerInterceptController
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
net
/
HttpChannelParent
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIAuthPrompt
.
h
"
#
include
"
nsIAuthPrompt2
.
h
"
#
include
"
nsIHttpHeaderVisitor
.
h
"
#
include
"
mozilla
/
net
/
RedirectChannelRegistrar
.
h
"
#
include
"
nsIPromptFactory
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsQueryObject
.
h
"
using
mozilla
:
:
Unused
;
using
mozilla
:
:
dom
:
:
ServiceWorkerInterceptController
;
using
mozilla
:
:
dom
:
:
ServiceWorkerParentInterceptEnabled
;
namespace
mozilla
{
namespace
net
{
HttpChannelParentListener
:
:
HttpChannelParentListener
(
HttpChannelParent
*
aInitialChannel
)
:
mNextListener
(
aInitialChannel
)
mRedirectChannelId
(
0
)
mSuspendedForDiversion
(
false
)
mShouldIntercept
(
false
)
mShouldSuspendIntercept
(
false
)
mInterceptCanceled
(
false
)
{
LOG
(
(
"
HttpChannelParentListener
:
:
HttpChannelParentListener
[
this
=
%
p
next
=
%
p
]
"
this
aInitialChannel
)
)
;
if
(
ServiceWorkerParentInterceptEnabled
(
)
)
{
mInterceptController
=
new
ServiceWorkerInterceptController
(
)
;
}
}
NS_IMPL_ADDREF
(
HttpChannelParentListener
)
NS_IMPL_RELEASE
(
HttpChannelParentListener
)
NS_INTERFACE_MAP_BEGIN
(
HttpChannelParentListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsIStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIChannelEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIRedirectResultListener
)
NS_INTERFACE_MAP_ENTRY
(
nsINetworkInterceptController
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
HttpChannelParentListener
)
NS_INTERFACE_MAP_END
NS_IMETHODIMP
HttpChannelParentListener
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
MOZ_RELEASE_ASSERT
(
!
mSuspendedForDiversion
"
Cannot
call
OnStartRequest
if
suspended
for
diversion
!
"
)
;
if
(
!
mNextListener
)
return
NS_ERROR_UNEXPECTED
;
LOG
(
(
"
HttpChannelParentListener
:
:
OnStartRequest
[
this
=
%
p
]
\
n
"
this
)
)
;
return
mNextListener
-
>
OnStartRequest
(
aRequest
aContext
)
;
}
NS_IMETHODIMP
HttpChannelParentListener
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
MOZ_RELEASE_ASSERT
(
!
mSuspendedForDiversion
"
Cannot
call
OnStopRequest
if
suspended
for
diversion
!
"
)
;
if
(
!
mNextListener
)
return
NS_ERROR_UNEXPECTED
;
LOG
(
(
"
HttpChannelParentListener
:
:
OnStopRequest
:
[
this
=
%
p
status
=
%
"
PRIu32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
aStatusCode
)
)
)
;
nsresult
rv
=
mNextListener
-
>
OnStopRequest
(
aRequest
aContext
aStatusCode
)
;
mNextListener
=
nullptr
;
return
rv
;
}
NS_IMETHODIMP
HttpChannelParentListener
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
MOZ_RELEASE_ASSERT
(
!
mSuspendedForDiversion
"
Cannot
call
OnDataAvailable
if
suspended
for
diversion
!
"
)
;
if
(
!
mNextListener
)
return
NS_ERROR_UNEXPECTED
;
LOG
(
(
"
HttpChannelParentListener
:
:
OnDataAvailable
[
this
=
%
p
]
\
n
"
this
)
)
;
return
mNextListener
-
>
OnDataAvailable
(
aRequest
aContext
aInputStream
aOffset
aCount
)
;
}
NS_IMETHODIMP
HttpChannelParentListener
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
result
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIChannelEventSink
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsINetworkInterceptController
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsIRedirectResultListener
)
)
)
{
return
QueryInterface
(
aIID
result
)
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
ir
;
if
(
mNextListener
&
&
NS_SUCCEEDED
(
CallQueryInterface
(
mNextListener
.
get
(
)
getter_AddRefs
(
ir
)
)
)
)
{
return
ir
-
>
GetInterface
(
aIID
result
)
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt2
)
)
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
wwatch
=
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
wwatch
-
>
GetPrompt
(
nullptr
aIID
reinterpret_cast
<
void
*
*
>
(
result
)
)
;
}
return
NS_NOINTERFACE
;
}
NS_IMETHODIMP
HttpChannelParentListener
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
oldChannel
nsIChannel
*
newChannel
uint32_t
redirectFlags
nsIAsyncVerifyRedirectCallback
*
callback
)
{
LOG
(
(
"
HttpChannelParentListener
:
:
AsyncOnChannelRedirect
[
this
=
%
p
old
=
%
p
new
=
%
p
flags
=
%
u
]
"
this
oldChannel
newChannel
redirectFlags
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIParentRedirectingChannel
>
activeRedirectingChannel
=
do_QueryInterface
(
mNextListener
)
;
if
(
!
activeRedirectingChannel
)
{
NS_ERROR
(
"
Channel
got
a
redirect
response
but
doesn
'
t
implement
"
"
nsIParentRedirectingChannel
to
handle
it
.
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsCOMPtr
<
nsIRedirectChannelRegistrar
>
registrar
=
RedirectChannelRegistrar
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
registrar
)
;
rv
=
registrar
-
>
RegisterChannel
(
newChannel
&
mRedirectChannelId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
Registered
%
p
channel
under
id
=
%
d
"
newChannel
mRedirectChannelId
)
)
;
return
activeRedirectingChannel
-
>
StartRedirect
(
mRedirectChannelId
newChannel
redirectFlags
callback
)
;
}
NS_IMETHODIMP
HttpChannelParentListener
:
:
OnRedirectResult
(
bool
succeeded
)
{
LOG
(
(
"
HttpChannelParentListener
:
:
OnRedirectResult
[
this
=
%
p
suc
=
%
d
]
"
this
succeeded
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIParentChannel
>
redirectChannel
;
if
(
mRedirectChannelId
)
{
nsCOMPtr
<
nsIRedirectChannelRegistrar
>
registrar
=
RedirectChannelRegistrar
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
registrar
)
;
rv
=
registrar
-
>
GetParentChannel
(
mRedirectChannelId
getter_AddRefs
(
redirectChannel
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
redirectChannel
)
{
LOG
(
(
"
Registered
parent
channel
not
found
under
id
=
%
d
"
mRedirectChannelId
)
)
;
nsCOMPtr
<
nsIChannel
>
newChannel
;
rv
=
registrar
-
>
GetRegisteredChannel
(
mRedirectChannelId
getter_AddRefs
(
newChannel
)
)
;
MOZ_ASSERT
(
newChannel
"
Already
registered
channel
not
found
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
newChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
registrar
-
>
DeregisterChannels
(
mRedirectChannelId
)
;
mRedirectChannelId
=
0
;
}
if
(
!
redirectChannel
)
{
succeeded
=
false
;
}
nsCOMPtr
<
nsIParentRedirectingChannel
>
activeRedirectingChannel
=
do_QueryInterface
(
mNextListener
)
;
MOZ_ASSERT
(
activeRedirectingChannel
"
Channel
finished
a
redirect
response
but
doesn
'
t
implement
"
"
nsIParentRedirectingChannel
to
complete
it
.
"
)
;
if
(
activeRedirectingChannel
)
{
activeRedirectingChannel
-
>
CompleteRedirect
(
succeeded
)
;
}
else
{
succeeded
=
false
;
}
if
(
succeeded
)
{
if
(
!
SameCOMIdentity
(
redirectChannel
mNextListener
)
)
{
nsCOMPtr
<
nsIParentChannel
>
parent
;
parent
=
do_QueryInterface
(
mNextListener
)
;
MOZ_ASSERT
(
parent
)
;
parent
-
>
Delete
(
)
;
mInterceptCanceled
=
false
;
mNextListener
=
do_QueryInterface
(
redirectChannel
)
;
MOZ_ASSERT
(
mNextListener
)
;
redirectChannel
-
>
SetParentListener
(
this
)
;
}
}
else
if
(
redirectChannel
)
{
redirectChannel
-
>
Delete
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelParentListener
:
:
ShouldPrepareForIntercept
(
nsIURI
*
aURI
nsIChannel
*
aChannel
bool
*
aShouldIntercept
)
{
if
(
mInterceptController
)
{
return
mInterceptController
-
>
ShouldPrepareForIntercept
(
aURI
aChannel
aShouldIntercept
)
;
}
*
aShouldIntercept
=
mShouldIntercept
;
return
NS_OK
;
}
class
HeaderVisitor
final
:
public
nsIHttpHeaderVisitor
{
nsCOMPtr
<
nsIInterceptedChannel
>
mChannel
;
~
HeaderVisitor
(
)
=
default
;
public
:
explicit
HeaderVisitor
(
nsIInterceptedChannel
*
aChannel
)
:
mChannel
(
aChannel
)
{
}
NS_DECL_ISUPPORTS
NS_IMETHOD
VisitHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
)
override
{
mChannel
-
>
SynthesizeHeader
(
aHeader
aValue
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
HeaderVisitor
nsIHttpHeaderVisitor
)
class
FinishSynthesizedResponse
:
public
Runnable
{
nsCOMPtr
<
nsIInterceptedChannel
>
mChannel
;
public
:
explicit
FinishSynthesizedResponse
(
nsIInterceptedChannel
*
aChannel
)
:
Runnable
(
"
net
:
:
FinishSynthesizedResponse
"
)
mChannel
(
aChannel
)
{
}
NS_IMETHOD
Run
(
)
override
{
mChannel
-
>
StartSynthesizedResponse
(
nullptr
nullptr
nullptr
EmptyCString
(
)
false
)
;
mChannel
-
>
FinishSynthesizedResponse
(
)
;
return
NS_OK
;
}
}
;
NS_IMETHODIMP
HttpChannelParentListener
:
:
ChannelIntercepted
(
nsIInterceptedChannel
*
aChannel
)
{
if
(
mInterceptController
)
{
return
mInterceptController
-
>
ChannelIntercepted
(
aChannel
)
;
}
if
(
mInterceptCanceled
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
<
nsresult
>
(
"
HttpChannelParentListener
:
:
CancelInterception
"
aChannel
&
nsIInterceptedChannel
:
:
CancelInterception
NS_BINDING_ABORTED
)
;
MOZ_ALWAYS_SUCCEEDS
(
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
)
;
return
NS_OK
;
}
if
(
mShouldSuspendIntercept
)
{
mInterceptedChannel
=
aChannel
;
return
NS_OK
;
}
nsAutoCString
statusText
;
mSynthesizedResponseHead
-
>
StatusText
(
statusText
)
;
aChannel
-
>
SynthesizeStatus
(
mSynthesizedResponseHead
-
>
Status
(
)
statusText
)
;
nsCOMPtr
<
nsIHttpHeaderVisitor
>
visitor
=
new
HeaderVisitor
(
aChannel
)
;
DebugOnly
<
nsresult
>
rv
=
mSynthesizedResponseHead
-
>
VisitHeaders
(
visitor
nsHttpHeaderArray
:
:
eFilterResponse
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
FinishSynthesizedResponse
(
aChannel
)
;
NS_DispatchToCurrentThread
(
event
)
;
mSynthesizedResponseHead
=
nullptr
;
MOZ_ASSERT
(
mNextListener
)
;
RefPtr
<
HttpChannelParent
>
channel
=
do_QueryObject
(
mNextListener
)
;
MOZ_ASSERT
(
channel
)
;
channel
-
>
ResponseSynthesized
(
)
;
return
NS_OK
;
}
nsresult
HttpChannelParentListener
:
:
SuspendForDiversion
(
)
{
if
(
NS_WARN_IF
(
mSuspendedForDiversion
)
)
{
MOZ_ASSERT
(
!
mSuspendedForDiversion
"
Cannot
SuspendForDiversion
twice
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
mSuspendedForDiversion
=
true
;
return
NS_OK
;
}
nsresult
HttpChannelParentListener
:
:
ResumeForDiversion
(
)
{
MOZ_RELEASE_ASSERT
(
mSuspendedForDiversion
"
Must
already
be
suspended
!
"
)
;
mSuspendedForDiversion
=
false
;
return
NS_OK
;
}
nsresult
HttpChannelParentListener
:
:
DivertTo
(
nsIStreamListener
*
aListener
)
{
MOZ_ASSERT
(
aListener
)
;
MOZ_RELEASE_ASSERT
(
mSuspendedForDiversion
"
Must
already
be
suspended
!
"
)
;
mInterceptCanceled
=
false
;
mNextListener
=
aListener
;
return
ResumeForDiversion
(
)
;
}
void
HttpChannelParentListener
:
:
SetupInterception
(
const
nsHttpResponseHead
&
aResponseHead
)
{
mSynthesizedResponseHead
=
new
nsHttpResponseHead
(
aResponseHead
)
;
mShouldIntercept
=
true
;
}
void
HttpChannelParentListener
:
:
SetupInterceptionAfterRedirect
(
bool
aShouldIntercept
)
{
mShouldIntercept
=
aShouldIntercept
;
if
(
mShouldIntercept
)
{
mShouldSuspendIntercept
=
true
;
}
}
void
HttpChannelParentListener
:
:
ClearInterceptedChannel
(
nsIStreamListener
*
aListener
)
{
if
(
!
SameCOMIdentity
(
mNextListener
aListener
)
)
{
return
;
}
if
(
mInterceptedChannel
)
{
mInterceptedChannel
-
>
CancelInterception
(
NS_ERROR_INTERCEPTION_FAILED
)
;
mInterceptedChannel
=
nullptr
;
}
mInterceptCanceled
=
true
;
}
}
}
