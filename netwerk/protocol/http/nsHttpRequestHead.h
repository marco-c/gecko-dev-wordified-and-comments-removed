#
ifndef
nsHttpRequestHead_h__
#
define
nsHttpRequestHead_h__
#
include
"
nsHttp
.
h
"
#
include
"
nsHttpHeaderArray
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
class
nsIHttpHeaderVisitor
;
namespace
IPC
{
template
<
typename
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
net
{
class
nsHttpRequestHead
{
public
:
nsHttpRequestHead
(
)
;
explicit
nsHttpRequestHead
(
const
nsHttpRequestHead
&
aRequestHead
)
;
nsHttpRequestHead
(
nsHttpRequestHead
&
&
aRequestHead
)
;
~
nsHttpRequestHead
(
)
;
nsHttpRequestHead
&
operator
=
(
const
nsHttpRequestHead
&
aRequestHead
)
;
const
nsHttpHeaderArray
&
Headers
(
)
const
;
void
Enter
(
)
const
CAPABILITY_ACQUIRE
(
mRecursiveMutex
)
{
mRecursiveMutex
.
Lock
(
)
;
}
void
Exit
(
)
const
CAPABILITY_RELEASE
(
mRecursiveMutex
)
{
mRecursiveMutex
.
Unlock
(
)
;
}
void
SetHeaders
(
const
nsHttpHeaderArray
&
aHeaders
)
;
void
SetMethod
(
const
nsACString
&
method
)
;
void
SetVersion
(
HttpVersion
version
)
;
void
SetRequestURI
(
const
nsACString
&
s
)
;
void
SetPath
(
const
nsACString
&
s
)
;
uint32_t
HeaderCount
(
)
;
[
[
nodiscard
]
]
nsresult
VisitHeaders
(
nsIHttpHeaderVisitor
*
visitor
nsHttpHeaderArray
:
:
VisitorFilter
filter
=
nsHttpHeaderArray
:
:
eFilterAll
)
;
void
Method
(
nsACString
&
aMethod
)
;
HttpVersion
Version
(
)
;
void
RequestURI
(
nsACString
&
RequestURI
)
;
void
Path
(
nsACString
&
aPath
)
;
void
SetHTTPS
(
bool
val
)
;
bool
IsHTTPS
(
)
;
void
SetOrigin
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
)
;
void
Origin
(
nsACString
&
aOrigin
)
;
[
[
nodiscard
]
]
nsresult
SetHeader
(
const
nsACString
&
h
const
nsACString
&
v
bool
m
=
false
)
;
[
[
nodiscard
]
]
nsresult
SetHeader
(
const
nsHttpAtom
&
h
const
nsACString
&
v
bool
m
=
false
)
;
[
[
nodiscard
]
]
nsresult
SetHeader
(
const
nsHttpAtom
&
h
const
nsACString
&
v
bool
m
nsHttpHeaderArray
:
:
HeaderVariety
variety
)
;
[
[
nodiscard
]
]
nsresult
SetEmptyHeader
(
const
nsACString
&
h
)
;
[
[
nodiscard
]
]
nsresult
GetHeader
(
const
nsHttpAtom
&
h
nsACString
&
v
)
;
[
[
nodiscard
]
]
nsresult
ClearHeader
(
const
nsHttpAtom
&
h
)
;
void
ClearHeaders
(
)
;
bool
HasHeaderValue
(
const
nsHttpAtom
&
h
const
char
*
v
)
;
bool
HasHeader
(
const
nsHttpAtom
&
h
)
;
void
Flatten
(
nsACString
&
bool
pruneProxyHeaders
=
false
)
;
[
[
nodiscard
]
]
nsresult
SetHeaderOnce
(
const
nsHttpAtom
&
h
const
char
*
v
bool
merge
=
false
)
;
bool
IsSafeMethod
(
)
;
enum
ParsedMethodType
{
kMethod_Custom
kMethod_Get
kMethod_Post
kMethod_Options
kMethod_Connect
kMethod_Head
kMethod_Put
kMethod_Trace
}
;
static
void
ParseMethod
(
const
nsCString
&
aRawMethod
ParsedMethodType
&
aParsedMethod
)
;
ParsedMethodType
ParsedMethod
(
)
;
bool
EqualsMethod
(
ParsedMethodType
aType
)
;
bool
IsGet
(
)
{
return
EqualsMethod
(
kMethod_Get
)
;
}
bool
IsPost
(
)
{
return
EqualsMethod
(
kMethod_Post
)
;
}
bool
IsOptions
(
)
{
return
EqualsMethod
(
kMethod_Options
)
;
}
bool
IsConnect
(
)
{
return
EqualsMethod
(
kMethod_Connect
)
;
}
bool
IsHead
(
)
{
return
EqualsMethod
(
kMethod_Head
)
;
}
bool
IsPut
(
)
{
return
EqualsMethod
(
kMethod_Put
)
;
}
bool
IsTrace
(
)
{
return
EqualsMethod
(
kMethod_Trace
)
;
}
void
ParseHeaderSet
(
const
char
*
buffer
)
;
private
:
nsHttpHeaderArray
mHeaders
GUARDED_BY
(
mRecursiveMutex
)
;
nsCString
mMethod
GUARDED_BY
(
mRecursiveMutex
)
{
"
GET
"
_ns
}
;
HttpVersion
mVersion
GUARDED_BY
(
mRecursiveMutex
)
{
HttpVersion
:
:
v1_1
}
;
nsCString
mRequestURI
GUARDED_BY
(
mRecursiveMutex
)
;
nsCString
mPath
GUARDED_BY
(
mRecursiveMutex
)
;
nsCString
mOrigin
GUARDED_BY
(
mRecursiveMutex
)
;
ParsedMethodType
mParsedMethod
GUARDED_BY
(
mRecursiveMutex
)
{
kMethod_Get
}
;
bool
mHTTPS
GUARDED_BY
(
mRecursiveMutex
)
{
false
}
;
mutable
RecursiveMutex
mRecursiveMutex
MOZ_UNANNOTATED
{
"
nsHttpRequestHead
.
mRecursiveMutex
"
}
;
bool
mInVisitHeaders
GUARDED_BY
(
mRecursiveMutex
)
{
false
}
;
friend
struct
IPC
:
:
ParamTraits
<
nsHttpRequestHead
>
;
}
;
}
}
#
endif
