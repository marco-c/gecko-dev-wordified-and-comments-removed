#
include
"
HttpLog
.
h
"
#
include
<
inttypes
.
h
>
#
include
"
DocumentChannelParent
.
h
"
#
include
"
mozilla
/
MozPromiseInlines
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPContext
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPService
.
h
"
#
include
"
mozilla
/
StoragePrincipalHelper
.
h
"
#
include
"
nsHttp
.
h
"
#
include
"
nsHttpChannel
.
h
"
#
include
"
nsHttpChannelAuthProvider
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsICacheStorageService
.
h
"
#
include
"
nsICacheStorage
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIHttpHeaderVisitor
.
h
"
#
include
"
nsINetworkInterceptController
.
h
"
#
include
"
nsINSSErrorsService
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIStreamListenerTee
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsIProtocolProxyService2
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIStreamTransportService
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsDNSPrefetch
.
h
"
#
include
"
nsChannelClassifier
.
h
"
#
include
"
nsIRedirectResultListener
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
mozilla
/
AntiTrackingRedirectHeuristic
.
h
"
#
include
"
mozilla
/
AntiTrackingUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
sslt
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsITransportSecurityInfo
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
LoadContextInfo
.
h
"
#
include
"
netCore
.
h
"
#
include
"
nsHttpTransaction
.
h
"
#
include
"
nsICancelable
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsInputStreamPump
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsISocketTransport
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
nsString
.
h
"
#
include
"
CacheObserver
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceStorage
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
AlternateServices
.
h
"
#
include
"
NetworkMarker
.
h
"
#
include
"
nsIHttpPushListener
.
h
"
#
include
"
nsIX509Cert
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
nsIDNSRecord
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsICompressConvStats
.
h
"
#
include
"
nsCORSListenerProxy
.
h
"
#
include
"
nsISocketProvider
.
h
"
#
include
"
mozilla
/
extensions
/
StreamFilterParent
.
h
"
#
include
"
mozilla
/
net
/
Predictor
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
CacheControlParser
.
h
"
#
include
"
nsMixedContentBlocker
.
h
"
#
include
"
CacheStorageService
.
h
"
#
include
"
HttpChannelParent
.
h
"
#
include
"
HttpTransactionParent
.
h
"
#
include
"
ParentChannelListener
.
h
"
#
include
"
ThirdPartyUtil
.
h
"
#
include
"
InterceptedHttpChannel
.
h
"
#
include
"
.
.
/
.
.
/
cache2
/
CacheFileUtils
.
h
"
#
include
"
nsIMultiplexInputStream
.
h
"
#
include
"
nsINetworkLinkService
.
h
"
#
include
"
mozilla
/
ContentBlockingAllowList
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
dom
/
nsHTTPSOnlyStreamListener
.
h
"
#
include
"
mozilla
/
dom
/
nsHTTPSOnlyUtils
.
h
"
#
include
"
mozilla
/
net
/
AsyncUrlChannelClassifier
.
h
"
#
include
"
mozilla
/
net
/
CookieJarSettings
.
h
"
#
include
"
mozilla
/
net
/
NeckoChannelParams
.
h
"
#
include
"
mozilla
/
net
/
OpaqueResponseUtils
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureFactory
.
h
"
#
include
"
HttpTrafficAnalyzer
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessParent
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
mozilla
/
dom
/
SecFetch
.
h
"
#
include
"
mozilla
/
net
/
TRRService
.
h
"
#
include
"
mozilla
/
URLQueryStringStripper
.
h
"
#
include
"
nsUnknownDecoder
.
h
"
#
ifdef
XP_WIN
#
include
"
HttpWinUtils
.
h
"
#
endif
#
ifdef
FUZZING
#
include
"
mozilla
/
StaticPrefs_fuzzing
.
h
"
#
endif
namespace
mozilla
{
using
namespace
dom
;
namespace
net
{
namespace
{
#
define
BYPASS_LOCAL_CACHE
(
loadFlags
isPreferCacheLoadOverBypass
)
\
(
(
loadFlags
)
&
(
nsIRequest
:
:
LOAD_BYPASS_CACHE
|
\
nsICachingChannel
:
:
LOAD_BYPASS_LOCAL_CACHE
)
&
&
\
!
(
(
(
loadFlags
)
&
nsIRequest
:
:
LOAD_FROM_CACHE
)
&
&
\
(
isPreferCacheLoadOverBypass
)
)
)
#
define
RECOVER_FROM_CACHE_FILE_ERROR
(
result
)
\
(
(
result
)
=
=
NS_ERROR_FILE_NOT_FOUND
|
|
\
(
result
)
=
=
NS_ERROR_FILE_CORRUPTED
|
|
(
result
)
=
=
NS_ERROR_OUT_OF_MEMORY
)
#
define
WRONG_RACING_RESPONSE_SOURCE
(
req
)
\
(
mRaceCacheWithNetwork
&
&
\
(
(
(
mFirstResponseSource
=
=
RESPONSE_FROM_CACHE
)
&
&
\
(
(
req
)
!
=
mCachePump
)
)
|
|
\
(
(
mFirstResponseSource
=
=
RESPONSE_FROM_NETWORK
)
&
&
\
(
(
req
)
!
=
mTransactionPump
)
)
)
)
static
NS_DEFINE_CID
(
kStreamListenerTeeCID
NS_STREAMLISTENERTEE_CID
)
;
void
AccumulateCacheHitTelemetry
(
CacheDisposition
hitOrMiss
nsIChannel
*
aChannel
)
{
nsCString
key
(
"
UNKNOWN
"
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
nsAutoCString
contentType
;
if
(
NS_SUCCEEDED
(
aChannel
-
>
GetContentType
(
contentType
)
)
)
{
if
(
nsContentUtils
:
:
IsJavascriptMIMEType
(
NS_ConvertUTF8toUTF16
(
contentType
)
)
)
{
key
.
AssignLiteral
(
"
JAVASCRIPT
"
)
;
}
else
if
(
StringBeginsWith
(
contentType
"
text
/
css
"
_ns
)
|
|
(
loadInfo
&
&
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
ExtContentPolicy
:
:
TYPE_STYLESHEET
)
)
{
key
.
AssignLiteral
(
"
STYLESHEET
"
)
;
}
else
if
(
StringBeginsWith
(
contentType
"
application
/
wasm
"
_ns
)
)
{
key
.
AssignLiteral
(
"
WASM
"
)
;
}
else
if
(
StringBeginsWith
(
contentType
"
image
/
"
_ns
)
)
{
key
.
AssignLiteral
(
"
IMAGE
"
)
;
}
else
if
(
StringBeginsWith
(
contentType
"
video
/
"
_ns
)
)
{
key
.
AssignLiteral
(
"
MEDIA
"
)
;
}
else
if
(
StringBeginsWith
(
contentType
"
audio
/
"
_ns
)
)
{
key
.
AssignLiteral
(
"
MEDIA
"
)
;
}
else
if
(
!
StringBeginsWith
(
contentType
nsLiteralCString
(
UNKNOWN_CONTENT_TYPE
)
)
)
{
key
.
AssignLiteral
(
"
OTHER
"
)
;
}
}
Telemetry
:
:
LABELS_HTTP_CACHE_DISPOSITION_3
label
=
Telemetry
:
:
LABELS_HTTP_CACHE_DISPOSITION_3
:
:
Unresolved
;
switch
(
hitOrMiss
)
{
case
kCacheUnresolved
:
label
=
Telemetry
:
:
LABELS_HTTP_CACHE_DISPOSITION_3
:
:
Unresolved
;
break
;
case
kCacheHit
:
label
=
Telemetry
:
:
LABELS_HTTP_CACHE_DISPOSITION_3
:
:
Hit
;
break
;
case
kCacheHitViaReval
:
label
=
Telemetry
:
:
LABELS_HTTP_CACHE_DISPOSITION_3
:
:
HitViaReval
;
break
;
case
kCacheMissedViaReval
:
label
=
Telemetry
:
:
LABELS_HTTP_CACHE_DISPOSITION_3
:
:
MissedViaReval
;
break
;
case
kCacheMissed
:
label
=
Telemetry
:
:
LABELS_HTTP_CACHE_DISPOSITION_3
:
:
Missed
;
break
;
case
kCacheUnknown
:
label
=
Telemetry
:
:
LABELS_HTTP_CACHE_DISPOSITION_3
:
:
Unknown
;
break
;
}
Telemetry
:
:
AccumulateCategoricalKeyed
(
key
label
)
;
Telemetry
:
:
AccumulateCategoricalKeyed
(
"
ALL
"
_ns
label
)
;
}
nsresult
Hash
(
const
char
*
buf
nsACString
&
hash
)
{
nsresult
rv
;
nsCOMPtr
<
nsICryptoHash
>
hasher
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hasher
-
>
Init
(
nsICryptoHash
:
:
SHA1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hasher
-
>
Update
(
reinterpret_cast
<
unsigned
const
char
*
>
(
buf
)
strlen
(
buf
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hasher
-
>
Finish
(
true
hash
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
}
bool
nsHttpChannel
:
:
WillRedirect
(
const
nsHttpResponseHead
&
response
)
{
return
IsRedirectStatus
(
response
.
Status
(
)
)
&
&
response
.
HasHeader
(
nsHttp
:
:
Location
)
;
}
nsresult
StoreAuthorizationMetaData
(
nsICacheEntry
*
entry
nsHttpRequestHead
*
requestHead
)
;
class
AutoRedirectVetoNotifier
{
public
:
explicit
AutoRedirectVetoNotifier
(
nsHttpChannel
*
channel
)
:
mChannel
(
channel
)
{
if
(
mChannel
-
>
LoadHasAutoRedirectVetoNotifier
(
)
)
{
MOZ_CRASH
(
"
Nested
AutoRedirectVetoNotifier
on
the
stack
"
)
;
mChannel
=
nullptr
;
return
;
}
mChannel
-
>
StoreHasAutoRedirectVetoNotifier
(
true
)
;
}
~
AutoRedirectVetoNotifier
(
)
{
ReportRedirectResult
(
false
)
;
}
void
RedirectSucceeded
(
)
{
ReportRedirectResult
(
true
)
;
}
private
:
nsHttpChannel
*
mChannel
;
void
ReportRedirectResult
(
bool
succeeded
)
;
}
;
void
AutoRedirectVetoNotifier
:
:
ReportRedirectResult
(
bool
succeeded
)
{
if
(
!
mChannel
)
return
;
mChannel
-
>
mRedirectChannel
=
nullptr
;
if
(
succeeded
)
{
mChannel
-
>
RemoveAsNonTailRequest
(
)
;
}
nsCOMPtr
<
nsIRedirectResultListener
>
vetoHook
;
NS_QueryNotificationCallbacks
(
mChannel
NS_GET_IID
(
nsIRedirectResultListener
)
getter_AddRefs
(
vetoHook
)
)
;
nsHttpChannel
*
channel
=
mChannel
;
mChannel
=
nullptr
;
if
(
vetoHook
)
vetoHook
-
>
OnRedirectResult
(
succeeded
)
;
channel
-
>
StoreHasAutoRedirectVetoNotifier
(
false
)
;
}
nsHttpChannel
:
:
nsHttpChannel
(
)
:
HttpAsyncAborter
<
nsHttpChannel
>
(
this
)
{
LOG
(
(
"
Creating
nsHttpChannel
[
this
=
%
p
]
\
n
"
this
)
)
;
mChannelCreationTime
=
PR_Now
(
)
;
mChannelCreationTimestamp
=
TimeStamp
:
:
Now
(
)
;
}
nsHttpChannel
:
:
~
nsHttpChannel
(
)
{
LOG
(
(
"
Destroying
nsHttpChannel
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
LOG_ENABLED
(
)
)
{
nsCString
webExtension
;
this
-
>
GetPropertyAsACString
(
u
"
cancelledByExtension
"
_ns
webExtension
)
;
if
(
!
webExtension
.
IsEmpty
(
)
)
{
LOG
(
(
"
channel
[
%
p
]
cancelled
by
extension
[
id
=
%
s
]
"
this
webExtension
.
get
(
)
)
)
;
}
}
if
(
mAuthProvider
)
{
DebugOnly
<
nsresult
>
rv
=
mAuthProvider
-
>
Disconnect
(
NS_ERROR_ABORT
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
ReleaseMainThreadOnlyReferences
(
)
;
if
(
gHttpHandler
)
{
gHttpHandler
-
>
RemoveHttpChannel
(
mChannelId
)
;
}
}
void
nsHttpChannel
:
:
ReleaseMainThreadOnlyReferences
(
)
{
if
(
NS_IsMainThread
(
)
)
{
return
;
}
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
arrayToRelease
;
arrayToRelease
.
AppendElement
(
mAuthProvider
.
forget
(
)
)
;
arrayToRelease
.
AppendElement
(
mRedirectChannel
.
forget
(
)
)
;
arrayToRelease
.
AppendElement
(
mPreflightChannel
.
forget
(
)
)
;
arrayToRelease
.
AppendElement
(
mDNSPrefetch
.
forget
(
)
)
;
NS_DispatchToMainThread
(
new
ProxyReleaseRunnable
(
std
:
:
move
(
arrayToRelease
)
)
)
;
}
nsresult
nsHttpChannel
:
:
Init
(
nsIURI
*
uri
uint32_t
caps
nsProxyInfo
*
proxyInfo
uint32_t
proxyResolveFlags
nsIURI
*
proxyURI
uint64_t
channelId
ExtContentPolicyType
aContentPolicyType
nsILoadInfo
*
aLoadInfo
)
{
nsresult
rv
=
HttpBaseChannel
:
:
Init
(
uri
caps
proxyInfo
proxyResolveFlags
proxyURI
channelId
aContentPolicyType
aLoadInfo
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
LOG1
(
(
"
nsHttpChannel
:
:
Init
[
this
=
%
p
]
\
n
"
this
)
)
;
return
rv
;
}
nsresult
nsHttpChannel
:
:
AddSecurityMessage
(
const
nsAString
&
aMessageTag
const
nsAString
&
aMessageCategory
)
{
if
(
mWarningReporter
)
{
return
mWarningReporter
-
>
ReportSecurityMessage
(
aMessageTag
aMessageCategory
)
;
}
return
HttpBaseChannel
:
:
AddSecurityMessage
(
aMessageTag
aMessageCategory
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
{
if
(
mWarningReporter
)
{
return
mWarningReporter
-
>
LogBlockedCORSRequest
(
aMessage
aCategory
)
;
}
return
NS_ERROR_UNEXPECTED
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
LogMimeTypeMismatch
(
const
nsACString
&
aMessageName
bool
aWarning
const
nsAString
&
aURL
const
nsAString
&
aContentType
)
{
if
(
mWarningReporter
)
{
return
mWarningReporter
-
>
LogMimeTypeMismatch
(
aMessageName
aWarning
aURL
aContentType
)
;
}
return
NS_ERROR_UNEXPECTED
;
}
nsresult
nsHttpChannel
:
:
PrepareToConnect
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
PrepareToConnect
[
this
=
%
p
]
\
n
"
this
)
)
;
gHttpHandler
-
>
OnModifyRequestBeforeCookies
(
this
)
;
AddCookiesToRequest
(
)
;
#
ifdef
XP_WIN
if
(
StaticPrefs
:
:
network_http_windows_sso_enabled
(
)
&
&
mURI
-
>
SchemeIs
(
"
https
"
)
&
&
!
(
mLoadFlags
&
LOAD_ANONYMOUS
)
&
&
!
mPrivateBrowsing
)
{
ExtContentPolicyType
type
=
mLoadInfo
-
>
GetExternalContentPolicyType
(
)
;
if
(
type
=
=
ExtContentPolicy
:
:
TYPE_DOCUMENT
|
|
type
=
=
ExtContentPolicy
:
:
TYPE_SUBDOCUMENT
)
{
AddWindowsSSO
(
this
)
;
}
}
#
endif
CallOnModifyRequestObservers
(
)
;
return
CallOrWaitForResume
(
[
]
(
auto
*
self
)
{
return
self
-
>
OnBeforeConnect
(
)
;
}
)
;
}
void
nsHttpChannel
:
:
HandleContinueCancellingByURLClassifier
(
nsresult
aErrorCode
)
{
MOZ_ASSERT
(
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aErrorCode
)
)
;
MOZ_ASSERT
(
!
mCallOnResume
"
How
did
that
happen
?
"
)
;
if
(
mSuspendCount
)
{
LOG
(
(
"
Waiting
until
resume
HandleContinueCancellingByURLClassifier
"
"
[
this
=
%
p
]
\
n
"
this
)
)
;
mCallOnResume
=
[
aErrorCode
]
(
nsHttpChannel
*
self
)
{
self
-
>
HandleContinueCancellingByURLClassifier
(
aErrorCode
)
;
return
NS_OK
;
}
;
return
;
}
LOG
(
(
"
nsHttpChannel
:
:
HandleContinueCancellingByURLClassifier
[
this
=
%
p
]
\
n
"
this
)
)
;
ContinueCancellingByURLClassifier
(
aErrorCode
)
;
}
nsresult
nsHttpChannel
:
:
OnBeforeConnect
(
)
{
nsresult
rv
;
if
(
mCanceled
)
{
return
mStatus
;
}
if
(
mAPIRedirectToURI
)
{
return
AsyncCall
(
&
nsHttpChannel
:
:
HandleAsyncAPIRedirect
)
;
}
if
(
ContentBlockingAllowList
:
:
Check
(
this
)
)
{
nsCOMPtr
<
nsIURI
>
unstrippedURI
;
mLoadInfo
-
>
GetUnstrippedURI
(
getter_AddRefs
(
unstrippedURI
)
)
;
if
(
unstrippedURI
)
{
return
AsyncCall
(
&
nsHttpChannel
:
:
HandleAsyncRedirectToUnstrippedURI
)
;
}
}
ExtContentPolicyType
type
=
mLoadInfo
-
>
GetExternalContentPolicyType
(
)
;
if
(
type
=
=
ExtContentPolicy
:
:
TYPE_DOCUMENT
|
|
type
=
=
ExtContentPolicy
:
:
TYPE_SUBDOCUMENT
)
{
rv
=
SetRequestHeader
(
"
Upgrade
-
Insecure
-
Requests
"
_ns
"
1
"
_ns
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
SecFetch
:
:
AddSecFetchHeader
(
this
)
;
nsCOMPtr
<
nsIPrincipal
>
resultPrincipal
;
if
(
!
mURI
-
>
SchemeIs
(
"
https
"
)
)
{
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
this
getter_AddRefs
(
resultPrincipal
)
)
;
}
StoreUpgradableToSecure
(
false
)
;
bool
shouldUpgrade
=
LoadUpgradeToSecure
(
)
;
if
(
mURI
-
>
SchemeIs
(
"
http
"
)
)
{
OriginAttributes
originAttributes
;
if
(
!
StoragePrincipalHelper
:
:
GetOriginAttributesForHSTS
(
this
originAttributes
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
shouldUpgrade
)
{
nsMainThreadPtrHandle
<
nsHttpChannel
>
self
(
new
nsMainThreadPtrHolder
<
nsHttpChannel
>
(
"
nsHttpChannel
:
:
OnBeforeConnect
:
:
self
"
this
)
)
;
auto
resultCallback
=
[
self
(
self
)
]
(
bool
aResult
nsresult
aStatus
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
self
-
>
MaybeUseHTTPSRRForUpgrade
(
aResult
aStatus
)
;
if
(
NS_FAILED
(
rv
)
)
{
self
-
>
CloseCacheEntry
(
false
)
;
Unused
<
<
self
-
>
AsyncAbort
(
rv
)
;
}
}
;
bool
willCallback
=
false
;
rv
=
NS_ShouldSecureUpgrade
(
mURI
mLoadInfo
resultPrincipal
LoadAllowSTS
(
)
originAttributes
shouldUpgrade
std
:
:
move
(
resultCallback
)
willCallback
)
;
uint32_t
httpOnlyStatus
=
mLoadInfo
-
>
GetHttpsOnlyStatus
(
)
;
if
(
httpOnlyStatus
&
nsILoadInfo
:
:
HTTPS_ONLY_UPGRADED_LISTENER_NOT_REGISTERED
)
{
RefPtr
<
nsHTTPSOnlyStreamListener
>
httpsOnlyListener
=
new
nsHTTPSOnlyStreamListener
(
mListener
mLoadInfo
)
;
mListener
=
httpsOnlyListener
;
httpOnlyStatus
^
=
nsILoadInfo
:
:
HTTPS_ONLY_UPGRADED_LISTENER_NOT_REGISTERED
;
httpOnlyStatus
|
=
nsILoadInfo
:
:
HTTPS_ONLY_UPGRADED_LISTENER_REGISTERED
;
mLoadInfo
-
>
SetHttpsOnlyStatus
(
httpOnlyStatus
)
;
}
LOG
(
(
"
nsHttpChannel
:
:
OnBeforeConnect
"
"
[
this
=
%
p
willCallback
=
%
d
rv
=
%
"
PRIx32
"
]
\
n
"
this
willCallback
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
MOZ_UNLIKELY
(
willCallback
)
)
{
return
rv
;
}
}
}
return
MaybeUseHTTPSRRForUpgrade
(
shouldUpgrade
NS_OK
)
;
}
nsresult
nsHttpChannel
:
:
MaybeUseHTTPSRRForUpgrade
(
bool
aShouldUpgrade
nsresult
aStatus
)
{
if
(
NS_FAILED
(
aStatus
)
)
{
return
aStatus
;
}
if
(
mURI
-
>
SchemeIs
(
"
https
"
)
|
|
aShouldUpgrade
|
|
!
LoadUseHTTPSSVC
(
)
)
{
return
ContinueOnBeforeConnect
(
aShouldUpgrade
aStatus
)
;
}
auto
shouldSkipUpgradeWithHTTPSRR
=
[
&
]
(
)
-
>
bool
{
if
(
(
mLoadInfo
-
>
GetExternalContentPolicyType
(
)
!
=
ExtContentPolicy
:
:
TYPE_DOCUMENT
)
&
&
(
mLoadInfo
-
>
GetLoadingPrincipal
(
)
&
&
mLoadInfo
-
>
GetLoadingPrincipal
(
)
-
>
SchemeIs
(
"
http
"
)
)
)
{
return
true
;
}
nsAutoCString
uriHost
;
mURI
-
>
GetAsciiHost
(
uriHost
)
;
if
(
gHttpHandler
-
>
IsHostExcludedForHTTPSRR
(
uriHost
)
)
{
return
true
;
}
if
(
nsHTTPSOnlyUtils
:
:
IsUpgradeDowngradeEndlessLoop
(
mURI
mLoadInfo
{
nsHTTPSOnlyUtils
:
:
UpgradeDowngradeEndlessLoopOptions
:
:
EnforceForHTTPSRR
}
)
)
{
gHttpHandler
-
>
ExcludeHTTPSRRHost
(
uriHost
)
;
LOG
(
(
"
[
%
p
]
skip
HTTPS
upgrade
for
host
[
%
s
]
"
this
uriHost
.
get
(
)
)
)
;
return
true
;
}
return
false
;
}
;
if
(
shouldSkipUpgradeWithHTTPSRR
(
)
)
{
StoreUseHTTPSSVC
(
false
)
;
mCaps
|
=
NS_HTTP_DISALLOW_HTTPS_RR
;
return
ContinueOnBeforeConnect
(
aShouldUpgrade
aStatus
)
;
}
if
(
mHTTPSSVCRecord
.
isSome
(
)
)
{
LOG
(
(
"
nsHttpChannel
:
:
MaybeUseHTTPSRRForUpgrade
[
%
p
]
mHTTPSSVCRecord
is
some
"
this
)
)
;
StoreWaitHTTPSSVCRecord
(
false
)
;
bool
hasHTTPSRR
=
(
mHTTPSSVCRecord
.
ref
(
)
!
=
nullptr
)
;
return
ContinueOnBeforeConnect
(
hasHTTPSRR
aStatus
hasHTTPSRR
)
;
}
auto
dnsStrategy
=
GetProxyDNSStrategy
(
)
;
if
(
!
(
dnsStrategy
&
DNS_PREFETCH_ORIGIN
)
)
{
return
ContinueOnBeforeConnect
(
aShouldUpgrade
aStatus
)
;
}
LOG
(
(
"
nsHttpChannel
:
:
MaybeUseHTTPSRRForUpgrade
[
%
p
]
wait
for
HTTPS
RR
"
this
)
)
;
OriginAttributes
originAttributes
;
StoragePrincipalHelper
:
:
GetOriginAttributesForHTTPSRR
(
this
originAttributes
)
;
RefPtr
<
nsDNSPrefetch
>
resolver
=
new
nsDNSPrefetch
(
mURI
originAttributes
nsIRequest
:
:
GetTRRMode
(
)
)
;
nsWeakPtr
weakPtrThis
(
do_GetWeakReference
(
static_cast
<
nsIHttpChannel
*
>
(
this
)
)
)
;
nsresult
rv
=
resolver
-
>
FetchHTTPSSVC
(
mCaps
&
NS_HTTP_REFRESH_DNS
!
LoadUseHTTPSSVC
(
)
[
weakPtrThis
]
(
nsIDNSHTTPSSVCRecord
*
aRecord
)
{
nsCOMPtr
<
nsIHttpChannel
>
channel
=
do_QueryReferent
(
weakPtrThis
)
;
RefPtr
<
nsHttpChannel
>
httpChannelImpl
=
do_QueryObject
(
channel
)
;
if
(
httpChannelImpl
)
{
httpChannelImpl
-
>
OnHTTPSRRAvailable
(
aRecord
)
;
}
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
FetchHTTPSSVC
failed
with
0x
%
08
"
PRIx32
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
ContinueOnBeforeConnect
(
aShouldUpgrade
aStatus
)
;
}
StoreWaitHTTPSSVCRecord
(
true
)
;
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
ContinueOnBeforeConnect
(
bool
aShouldUpgrade
nsresult
aStatus
bool
aUpgradeWithHTTPSRR
)
{
LOG
(
(
"
nsHttpChannel
:
:
ContinueOnBeforeConnect
"
"
[
this
=
%
p
aShouldUpgrade
=
%
d
rv
=
%
"
PRIx32
"
]
\
n
"
this
aShouldUpgrade
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
MOZ_ASSERT
(
!
LoadWaitHTTPSSVCRecord
(
)
)
;
if
(
NS_FAILED
(
aStatus
)
)
{
return
aStatus
;
}
if
(
aShouldUpgrade
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTPS_UPGRADE_WITH_HTTPS_RR
aUpgradeWithHTTPSRR
)
;
return
AsyncCall
(
&
nsHttpChannel
:
:
HandleAsyncRedirectChannelToHttps
)
;
}
if
(
!
net_IsValidHostName
(
nsDependentCString
(
mConnectionInfo
-
>
Origin
(
)
)
)
)
{
return
NS_ERROR_UNKNOWN_HOST
;
}
if
(
mUpgradeProtocolCallback
)
{
if
(
mUpgradeProtocol
.
EqualsLiteral
(
"
websocket
"
)
&
&
StaticPrefs
:
:
network_http_http2_websockets
(
)
)
{
mCaps
|
=
NS_HTTP_ALLOW_SPDY_WITHOUT_KEEPALIVE
;
}
else
{
mCaps
|
=
NS_HTTP_DISALLOW_SPDY
;
}
mCaps
|
=
NS_HTTP_DISALLOW_HTTP3
;
mCaps
|
=
NS_HTTP_DISALLOW_HTTPS_RR
;
}
if
(
LoadIsTRRServiceChannel
(
)
)
{
mCaps
|
=
NS_HTTP_LARGE_KEEPALIVE
;
mCaps
|
=
NS_HTTP_DISALLOW_HTTPS_RR
;
}
mCaps
|
=
NS_HTTP_TRR_FLAGS_FROM_MODE
(
nsIRequest
:
:
GetTRRMode
(
)
)
;
mConnectionInfo
-
>
SetAnonymous
(
(
mLoadFlags
&
LOAD_ANONYMOUS
)
!
=
0
)
;
mConnectionInfo
-
>
SetPrivate
(
mPrivateBrowsing
)
;
mConnectionInfo
-
>
SetNoSpdy
(
mCaps
&
NS_HTTP_DISALLOW_SPDY
)
;
mConnectionInfo
-
>
SetBeConservative
(
(
mCaps
&
NS_HTTP_BE_CONSERVATIVE
)
|
|
LoadBeConservative
(
)
)
;
mConnectionInfo
-
>
SetTlsFlags
(
mTlsFlags
)
;
mConnectionInfo
-
>
SetIsTrrServiceChannel
(
LoadIsTRRServiceChannel
(
)
)
;
mConnectionInfo
-
>
SetTRRMode
(
nsIRequest
:
:
GetTRRMode
(
)
)
;
mConnectionInfo
-
>
SetIPv4Disabled
(
mCaps
&
NS_HTTP_DISABLE_IPV4
)
;
mConnectionInfo
-
>
SetIPv6Disabled
(
mCaps
&
NS_HTTP_DISABLE_IPV6
)
;
mConnectionInfo
-
>
SetAnonymousAllowClientCert
(
(
mLoadFlags
&
LOAD_ANONYMOUS_ALLOW_CLIENT_CERT
)
!
=
0
)
;
gHttpHandler
-
>
OnBeforeConnect
(
this
)
;
return
CallOrWaitForResume
(
[
]
(
auto
*
self
)
{
return
self
-
>
Connect
(
)
;
}
)
;
}
nsresult
nsHttpChannel
:
:
Connect
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
Connect
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
LoadResuming
(
)
&
&
(
mLoadFlags
&
LOAD_ONLY_FROM_CACHE
)
)
{
LOG
(
(
"
Resuming
from
cache
is
not
supported
yet
"
)
)
;
return
NS_ERROR_DOCUMENT_NOT_CACHED
;
}
if
(
ShouldIntercept
(
)
)
{
return
RedirectToInterceptedChannel
(
)
;
}
bool
isTrackingResource
=
IsThirdPartyTrackingResource
(
)
;
LOG
(
(
"
nsHttpChannel
%
p
tracking
resource
=
%
d
cos
=
%
lu
inc
=
%
d
"
this
isTrackingResource
mClassOfService
.
Flags
(
)
mClassOfService
.
Incremental
(
)
)
)
;
if
(
isTrackingResource
)
{
AddClassFlags
(
nsIClassOfService
:
:
Tail
)
;
}
if
(
WaitingForTailUnblock
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mOnTailUnblock
)
;
mOnTailUnblock
=
&
nsHttpChannel
:
:
ConnectOnTailUnblock
;
return
NS_OK
;
}
return
ConnectOnTailUnblock
(
)
;
}
nsresult
nsHttpChannel
:
:
ConnectOnTailUnblock
(
)
{
nsresult
rv
;
LOG
(
(
"
nsHttpChannel
:
:
ConnectOnTailUnblock
[
this
=
%
p
]
\
n
"
this
)
)
;
SpeculativeConnect
(
)
;
rv
=
OpenCacheEntry
(
mURI
-
>
SchemeIs
(
"
https
"
)
)
;
if
(
AwaitingCacheCallbacks
(
)
)
{
LOG
(
(
"
nsHttpChannel
:
:
Connect
%
p
AwaitingCacheCallbacks
forces
async
\
n
"
this
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Unexpected
state
"
)
;
if
(
mNetworkTriggered
&
&
mWaitingForProxy
)
{
mWaitingForProxy
=
false
;
return
ContinueConnect
(
)
;
}
return
NS_OK
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
OpenCacheEntry
failed
[
rv
=
%
"
PRIx32
"
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
mLoadFlags
&
LOAD_ONLY_FROM_CACHE
)
{
return
NS_ERROR_DOCUMENT_NOT_CACHED
;
}
}
if
(
mRaceCacheWithNetwork
&
&
(
(
mCacheEntry
&
&
!
mCachedContentIsValid
&
&
(
mDidReval
|
|
LoadCachedContentIsPartial
(
)
)
)
|
|
mIgnoreCacheEntry
)
)
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_RACE_CACHE_VALIDATION
:
:
NotSent
)
;
}
if
(
mRaceCacheWithNetwork
&
&
mCachedContentIsValid
)
{
Unused
<
<
ReadFromCache
(
true
)
;
}
return
TriggerNetwork
(
)
;
}
nsresult
nsHttpChannel
:
:
ContinueConnect
(
)
{
if
(
!
LoadIsCorsPreflightDone
(
)
&
&
LoadRequireCORSPreflight
(
)
)
{
MOZ_ASSERT
(
!
mPreflightChannel
)
;
nsresult
rv
=
nsCORSListenerProxy
:
:
StartCORSPreflight
(
this
this
mUnsafeHeaders
getter_AddRefs
(
mPreflightChannel
)
)
;
return
rv
;
}
MOZ_RELEASE_ASSERT
(
!
LoadRequireCORSPreflight
(
)
|
|
LoadIsCorsPreflightDone
(
)
"
CORS
preflight
must
have
been
finished
by
the
time
we
"
"
do
the
rest
of
ContinueConnect
"
)
;
if
(
mCacheEntry
)
{
if
(
mCachedContentIsValid
)
{
nsRunnableMethod
<
nsHttpChannel
>
*
event
=
nullptr
;
nsresult
rv
;
if
(
!
LoadCachedContentIsPartial
(
)
)
{
rv
=
AsyncCall
(
&
nsHttpChannel
:
:
AsyncOnExamineCachedResponse
&
event
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
AsyncCall
failed
(
%
08x
)
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
rv
=
ReadFromCache
(
true
)
;
if
(
NS_FAILED
(
rv
)
&
&
event
)
{
event
-
>
Revoke
(
)
;
}
AccumulateCacheHitTelemetry
(
kCacheHit
this
)
;
mCacheDisposition
=
kCacheHit
;
return
rv
;
}
if
(
mLoadFlags
&
LOAD_ONLY_FROM_CACHE
)
{
LOG
(
(
"
!
mCachedContentIsValid
&
&
mLoadFlags
&
LOAD_ONLY_FROM_CACHE
"
)
)
;
return
NS_ERROR_DOCUMENT_NOT_CACHED
;
}
}
else
if
(
mLoadFlags
&
LOAD_ONLY_FROM_CACHE
)
{
LOG
(
(
"
!
mCacheEntry
&
&
mLoadFlags
&
LOAD_ONLY_FROM_CACHE
"
)
)
;
return
NS_ERROR_DOCUMENT_NOT_CACHED
;
}
if
(
mLoadFlags
&
LOAD_NO_NETWORK_IO
)
{
LOG
(
(
"
mLoadFlags
&
LOAD_NO_NETWORK_IO
"
)
)
;
return
NS_ERROR_DOCUMENT_NOT_CACHED
;
}
return
DoConnect
(
)
;
}
nsresult
nsHttpChannel
:
:
DoConnect
(
HttpTransactionShell
*
aTransWithStickyConn
)
{
LOG
(
(
"
nsHttpChannel
:
:
DoConnect
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
!
mDNSBlockingPromise
.
IsEmpty
(
)
)
{
LOG
(
(
"
waiting
for
DNS
prefetch
"
)
)
;
MOZ_ASSERT
(
!
aTransWithStickyConn
)
;
MOZ_ASSERT
(
mDNSBlockingThenable
)
;
nsCOMPtr
<
nsISerialEventTarget
>
target
(
do_GetMainThread
(
)
)
;
RefPtr
<
nsHttpChannel
>
self
(
this
)
;
mDNSBlockingThenable
-
>
Then
(
target
__func__
[
self
]
(
const
nsCOMPtr
<
nsIDNSRecord
>
&
aRec
)
{
nsresult
rv
=
self
-
>
DoConnectActual
(
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
self
-
>
CloseCacheEntry
(
false
)
;
Unused
<
<
self
-
>
AsyncAbort
(
rv
)
;
}
}
[
self
]
(
nsresult
err
)
{
self
-
>
CloseCacheEntry
(
false
)
;
Unused
<
<
self
-
>
AsyncAbort
(
err
)
;
}
)
;
return
NS_OK
;
}
return
DoConnectActual
(
aTransWithStickyConn
)
;
}
nsresult
nsHttpChannel
:
:
DoConnectActual
(
HttpTransactionShell
*
aTransWithStickyConn
)
{
LOG
(
(
"
nsHttpChannel
:
:
DoConnectActual
[
this
=
%
p
aTransWithStickyConn
=
%
p
]
\
n
"
this
aTransWithStickyConn
)
)
;
nsresult
rv
=
SetupTransaction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aTransWithStickyConn
)
{
rv
=
gHttpHandler
-
>
InitiateTransactionWithStickyConn
(
mTransaction
mPriority
aTransWithStickyConn
)
;
}
else
{
rv
=
gHttpHandler
-
>
InitiateTransaction
(
mTransaction
mPriority
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
mTransaction
-
>
AsyncRead
(
this
getter_AddRefs
(
mTransactionPump
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uint32_t
suspendCount
=
mSuspendCount
;
if
(
LoadAsyncResumePending
(
)
)
{
LOG
(
(
"
Suspend
(
)
'
ing
transaction
pump
once
because
of
async
resume
pending
"
"
sc
=
%
u
pump
=
%
p
this
=
%
p
"
suspendCount
mTransactionPump
.
get
(
)
this
)
)
;
+
+
suspendCount
;
}
while
(
suspendCount
-
-
)
{
mTransactionPump
-
>
Suspend
(
)
;
}
return
NS_OK
;
}
void
nsHttpChannel
:
:
SpeculativeConnect
(
)
{
if
(
gIOService
-
>
IsOffline
(
)
|
|
mUpgradeProtocolCallback
|
|
!
(
mCaps
&
NS_HTTP_ALLOW_KEEPALIVE
)
)
{
return
;
}
if
(
mLoadFlags
&
(
LOAD_ONLY_FROM_CACHE
|
LOAD_FROM_CACHE
|
LOAD_NO_NETWORK_IO
)
)
{
return
;
}
if
(
LoadAllowStaleCacheContent
(
)
)
{
return
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
NS_NewNotificationCallbacksAggregation
(
mCallbacks
mLoadGroup
getter_AddRefs
(
callbacks
)
)
;
if
(
!
callbacks
)
return
;
Unused
<
<
gHttpHandler
-
>
SpeculativeConnect
(
mConnectionInfo
callbacks
mCaps
&
(
NS_HTTP_DISALLOW_SPDY
|
NS_HTTP_TRR_MODE_MASK
|
NS_HTTP_DISABLE_IPV4
|
NS_HTTP_DISABLE_IPV6
|
NS_HTTP_DISALLOW_HTTP3
|
NS_HTTP_REFRESH_DNS
)
gHttpHandler
-
>
EchConfigEnabled
(
)
)
;
}
void
nsHttpChannel
:
:
DoNotifyListenerCleanup
(
)
{
CleanRedirectCacheChainIfNecessary
(
)
;
}
void
nsHttpChannel
:
:
ReleaseListeners
(
)
{
HttpBaseChannel
:
:
ReleaseListeners
(
)
;
mChannelClassifier
=
nullptr
;
mWarningReporter
=
nullptr
;
mEarlyHintObserver
=
nullptr
;
for
(
StreamFilterRequest
&
request
:
mStreamFilterRequests
)
{
request
.
mPromise
-
>
Reject
(
false
__func__
)
;
}
mStreamFilterRequests
.
Clear
(
)
;
}
void
nsHttpChannel
:
:
DoAsyncAbort
(
nsresult
aStatus
)
{
Unused
<
<
AsyncAbort
(
aStatus
)
;
}
void
nsHttpChannel
:
:
HandleAsyncRedirect
(
)
{
MOZ_ASSERT
(
!
mCallOnResume
"
How
did
that
happen
?
"
)
;
if
(
mSuspendCount
)
{
LOG
(
(
"
Waiting
until
resume
to
do
async
redirect
[
this
=
%
p
]
\
n
"
this
)
)
;
mCallOnResume
=
[
]
(
nsHttpChannel
*
self
)
{
self
-
>
HandleAsyncRedirect
(
)
;
return
NS_OK
;
}
;
return
;
}
nsresult
rv
=
NS_OK
;
LOG
(
(
"
nsHttpChannel
:
:
HandleAsyncRedirect
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
NS_SUCCEEDED
(
mStatus
)
)
{
PushRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueHandleAsyncRedirect
)
;
rv
=
AsyncProcessRedirection
(
mResponseHead
-
>
Status
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
PopRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueHandleAsyncRedirect
)
;
rv
=
ContinueHandleAsyncRedirect
(
rv
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
else
{
rv
=
ContinueHandleAsyncRedirect
(
mStatus
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
nsresult
nsHttpChannel
:
:
ContinueHandleAsyncRedirect
(
nsresult
rv
)
{
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ContinueHandleAsyncRedirect
got
failure
result
[
rv
=
%
"
PRIx32
"
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
bool
redirectsEnabled
=
!
mLoadInfo
-
>
GetDontFollowRedirects
(
)
;
if
(
redirectsEnabled
)
{
mStatus
=
rv
;
DoNotifyListener
(
)
;
if
(
mCacheEntry
)
{
mCacheEntry
-
>
AsyncDoom
(
nullptr
)
;
}
}
else
{
DoNotifyListener
(
)
;
}
}
CloseCacheEntry
(
true
)
;
StoreIsPending
(
false
)
;
if
(
mLoadGroup
)
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
mStatus
)
;
return
NS_OK
;
}
void
nsHttpChannel
:
:
HandleAsyncNotModified
(
)
{
MOZ_ASSERT
(
!
mCallOnResume
"
How
did
that
happen
?
"
)
;
if
(
mSuspendCount
)
{
LOG
(
(
"
Waiting
until
resume
to
do
async
not
-
modified
[
this
=
%
p
]
\
n
"
this
)
)
;
mCallOnResume
=
[
]
(
nsHttpChannel
*
self
)
{
self
-
>
HandleAsyncNotModified
(
)
;
return
NS_OK
;
}
;
return
;
}
LOG
(
(
"
nsHttpChannel
:
:
HandleAsyncNotModified
[
this
=
%
p
]
\
n
"
this
)
)
;
DoNotifyListener
(
)
;
CloseCacheEntry
(
false
)
;
StoreIsPending
(
false
)
;
if
(
mLoadGroup
)
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
mStatus
)
;
}
nsresult
nsHttpChannel
:
:
SetupTransaction
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetupTransaction
[
this
=
%
p
cos
=
%
lu
inc
=
%
d
prio
=
%
d
]
\
n
"
this
mClassOfService
.
Flags
(
)
mClassOfService
.
Incremental
(
)
mPriority
)
)
;
NS_ENSURE_TRUE
(
!
mTransaction
NS_ERROR_ALREADY_INITIALIZED
)
;
nsresult
rv
;
mozilla
:
:
MutexAutoLock
lock
(
mRCWNLock
)
;
if
(
mRaceCacheWithNetwork
&
&
AwaitingCacheCallbacks
(
)
)
{
if
(
mDidReval
)
{
LOG
(
(
"
Removing
conditional
request
headers
"
)
)
;
UntieValidationRequest
(
)
;
mDidReval
=
false
;
mIgnoreCacheEntry
=
true
;
}
if
(
LoadCachedContentIsPartial
(
)
)
{
LOG
(
(
"
Removing
byte
range
request
headers
"
)
)
;
UntieByteRangeRequest
(
)
;
StoreCachedContentIsPartial
(
false
)
;
mIgnoreCacheEntry
=
true
;
}
if
(
mIgnoreCacheEntry
)
{
mAvailableCachedAltDataType
.
Truncate
(
)
;
StoreDeliveringAltData
(
false
)
;
mAltDataLength
=
-
1
;
mCacheInputStream
.
CloseAndRelease
(
)
;
}
}
StoreUsedNetwork
(
1
)
;
if
(
!
LoadAllowSpdy
(
)
)
{
mCaps
|
=
NS_HTTP_DISALLOW_SPDY
;
}
if
(
!
LoadAllowHttp3
(
)
)
{
mCaps
|
=
NS_HTTP_DISALLOW_HTTP3
;
}
if
(
LoadBeConservative
(
)
)
{
mCaps
|
=
NS_HTTP_BE_CONSERVATIVE
;
}
if
(
mLoadFlags
&
LOAD_ANONYMOUS_ALLOW_CLIENT_CERT
)
{
mCaps
|
=
NS_HTTP_LOAD_ANONYMOUS_CONNECT_ALLOW_CLIENT_CERT
;
}
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
this
)
)
{
mCaps
|
=
NS_HTTP_USE_RFP
;
}
nsAutoCString
buf
path
;
nsCString
*
requestURI
;
rv
=
mURI
-
>
GetPathQueryRef
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
NS_EscapeURL
(
path
.
get
(
)
path
.
Length
(
)
esc_OnlyNonASCII
|
esc_Spaces
buf
)
)
{
requestURI
=
&
buf
;
}
else
{
requestURI
=
&
path
;
}
int32_t
ref1
=
requestURI
-
>
FindChar
(
'
#
'
)
;
if
(
ref1
!
=
kNotFound
)
{
requestURI
-
>
SetLength
(
ref1
)
;
}
if
(
mConnectionInfo
-
>
UsingConnect
(
)
|
|
!
mConnectionInfo
-
>
UsingHttpProxy
(
)
)
{
mRequestHead
.
SetVersion
(
gHttpHandler
-
>
HttpVersion
(
)
)
;
}
else
{
mRequestHead
.
SetPath
(
*
requestURI
)
;
rv
=
mURI
-
>
GetUserPass
(
buf
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
!
buf
.
IsEmpty
(
)
&
&
(
(
strncmp
(
mSpec
.
get
(
)
"
http
:
"
5
)
=
=
0
)
|
|
strncmp
(
mSpec
.
get
(
)
"
https
:
"
6
)
=
=
0
)
)
{
nsCOMPtr
<
nsIURI
>
tempURI
=
nsIOService
:
:
CreateExposableURI
(
mURI
)
;
rv
=
tempURI
-
>
GetAsciiSpec
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
requestURI
=
&
path
;
}
else
{
requestURI
=
&
mSpec
;
}
int32_t
ref2
=
requestURI
-
>
FindChar
(
'
#
'
)
;
if
(
ref2
!
=
kNotFound
)
{
requestURI
-
>
SetLength
(
ref2
)
;
}
mRequestHead
.
SetVersion
(
gHttpHandler
-
>
ProxyHttpVersion
(
)
)
;
}
mRequestHead
.
SetRequestURI
(
*
requestURI
)
;
mRequestTime
=
NowInSeconds
(
)
;
StoreRequestTimeInitialized
(
true
)
;
if
(
mLoadFlags
&
LOAD_BYPASS_CACHE
)
{
rv
=
mRequestHead
.
SetHeaderOnce
(
nsHttp
:
:
Pragma
"
no
-
cache
"
true
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
mRequestHead
.
Version
(
)
>
=
HttpVersion
:
:
v1_1
)
{
rv
=
mRequestHead
.
SetHeaderOnce
(
nsHttp
:
:
Cache_Control
"
no
-
cache
"
true
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
else
if
(
(
mLoadFlags
&
VALIDATE_ALWAYS
)
&
&
!
LoadCacheEntryIsWriteOnly
(
)
)
{
if
(
mRequestHead
.
Version
(
)
>
=
HttpVersion
:
:
v1_1
)
{
rv
=
mRequestHead
.
SetHeaderOnce
(
nsHttp
:
:
Cache_Control
"
max
-
age
=
0
"
true
)
;
}
else
{
rv
=
mRequestHead
.
SetHeaderOnce
(
nsHttp
:
:
Pragma
"
no
-
cache
"
true
)
;
}
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
if
(
LoadResuming
(
)
)
{
char
byteRange
[
32
]
;
SprintfLiteral
(
byteRange
"
bytes
=
%
"
PRIu64
"
-
"
mStartPos
)
;
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
Range
nsDependentCString
(
byteRange
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
mEntityID
.
IsEmpty
(
)
)
{
nsCString
:
:
const_iterator
start
end
slash
;
mEntityID
.
BeginReading
(
start
)
;
mEntityID
.
EndReading
(
end
)
;
mEntityID
.
BeginReading
(
slash
)
;
if
(
FindCharInReadable
(
'
/
'
slash
end
)
)
{
nsAutoCString
ifMatch
;
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
If_Match
NS_UnescapeURL
(
Substring
(
start
slash
)
0
ifMatch
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
+
+
slash
;
}
if
(
FindCharInReadable
(
'
/
'
slash
end
)
)
{
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
If_Unmodified_Since
Substring
(
+
+
slash
end
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
}
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
NS_NewNotificationCallbacksAggregation
(
mCallbacks
mLoadGroup
getter_AddRefs
(
callbacks
)
)
;
if
(
nsIOService
:
:
UseSocketProcess
(
)
)
{
if
(
NS_WARN_IF
(
!
gIOService
-
>
SocketProcessReady
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIParentChannel
>
parentChannel
;
NS_QueryNotificationCallbacks
(
this
parentChannel
)
;
RefPtr
<
DocumentLoadListener
>
documentChannelParent
=
do_QueryObject
(
parentChannel
)
;
RefPtr
<
HttpTransactionParent
>
transParent
=
new
HttpTransactionParent
(
!
!
documentChannelParent
)
;
LOG1
(
(
"
nsHttpChannel
%
p
created
HttpTransactionParent
%
p
\
n
"
this
transParent
.
get
(
)
)
)
;
transParent
-
>
SetRedirectTimestamp
(
mRedirectStartTimeStamp
mRedirectEndTimeStamp
)
;
SocketProcessParent
*
socketProcess
=
SocketProcessParent
:
:
GetSingleton
(
)
;
if
(
socketProcess
)
{
Unused
<
<
socketProcess
-
>
SendPHttpTransactionConstructor
(
transParent
)
;
}
mTransaction
=
transParent
;
}
else
{
mTransaction
=
new
nsHttpTransaction
(
)
;
LOG1
(
(
"
nsHttpChannel
%
p
created
nsHttpTransaction
%
p
\
n
"
this
mTransaction
.
get
(
)
)
)
;
}
gHttpHandler
-
>
AddHttpChannel
(
mChannelId
ToSupports
(
this
)
)
;
if
(
mLoadFlags
&
LOAD_ANONYMOUS
)
mCaps
|
=
NS_HTTP_LOAD_ANONYMOUS
;
if
(
LoadTimingEnabled
(
)
)
mCaps
|
=
NS_HTTP_TIMING_ENABLED
;
if
(
mUpgradeProtocolCallback
)
{
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
Upgrade
mUpgradeProtocol
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
mRequestHead
.
SetHeaderOnce
(
nsHttp
:
:
Connection
nsHttp
:
:
Upgrade
.
get
(
)
true
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mCaps
|
=
NS_HTTP_STICKY_CONNECTION
;
mCaps
&
=
~
NS_HTTP_ALLOW_KEEPALIVE
;
}
nsCOMPtr
<
nsIHttpPushListener
>
pushListener
;
NS_QueryNotificationCallbacks
(
mCallbacks
mLoadGroup
NS_GET_IID
(
nsIHttpPushListener
)
getter_AddRefs
(
pushListener
)
)
;
HttpTransactionShell
:
:
OnPushCallback
pushCallback
=
nullptr
;
if
(
pushListener
)
{
mCaps
|
=
NS_HTTP_ONPUSH_LISTENER
;
nsWeakPtr
weakPtrThis
(
do_GetWeakReference
(
static_cast
<
nsIHttpChannel
*
>
(
this
)
)
)
;
pushCallback
=
[
weakPtrThis
]
(
uint32_t
aPushedStreamId
const
nsACString
&
aUrl
const
nsACString
&
aRequestString
HttpTransactionShell
*
aTransaction
)
{
if
(
nsCOMPtr
<
nsIHttpChannel
>
channel
=
do_QueryReferent
(
weakPtrThis
)
)
{
return
static_cast
<
nsHttpChannel
*
>
(
channel
.
get
(
)
)
-
>
OnPush
(
aPushedStreamId
aUrl
aRequestString
aTransaction
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
;
}
EnsureTopBrowsingContextId
(
)
;
EnsureRequestContext
(
)
;
HttpTrafficCategory
category
=
CreateTrafficCategory
(
)
;
std
:
:
function
<
void
(
TransactionObserverResult
&
&
)
>
observer
;
if
(
mTransactionObserver
)
{
observer
=
[
transactionObserver
{
std
:
:
move
(
mTransactionObserver
)
}
]
(
TransactionObserverResult
&
&
aResult
)
{
transactionObserver
-
>
Complete
(
aResult
.
versionOk
(
)
aResult
.
authOk
(
)
aResult
.
closeReason
(
)
)
;
}
;
}
rv
=
mTransaction
-
>
Init
(
mCaps
mConnectionInfo
&
mRequestHead
mUploadStream
mReqContentLength
LoadUploadStreamHasHeaders
(
)
GetCurrentEventTarget
(
)
callbacks
this
mTopBrowsingContextId
category
mRequestContext
mClassOfService
mInitialRwin
LoadResponseTimeoutEnabled
(
)
mChannelId
std
:
:
move
(
observer
)
std
:
:
move
(
pushCallback
)
mTransWithPushedStream
mPushedStreamId
)
;
if
(
NS_FAILED
(
rv
)
)
{
mTransaction
=
nullptr
;
return
rv
;
}
return
rv
;
}
HttpTrafficCategory
nsHttpChannel
:
:
CreateTrafficCategory
(
)
{
MOZ_ASSERT
(
!
mFirstPartyClassificationFlags
|
|
!
mThirdPartyClassificationFlags
)
;
if
(
!
StaticPrefs
:
:
network_traffic_analyzer_enabled
(
)
)
{
return
HttpTrafficCategory
:
:
eInvalid
;
}
HttpTrafficAnalyzer
:
:
ClassOfService
cos
;
{
if
(
(
mClassOfService
.
Flags
(
)
&
nsIClassOfService
:
:
Leader
)
&
&
mLoadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
ExtContentPolicy
:
:
TYPE_SCRIPT
)
{
cos
=
HttpTrafficAnalyzer
:
:
ClassOfService
:
:
eLeader
;
}
else
if
(
mLoadFlags
&
nsIRequest
:
:
LOAD_BACKGROUND
)
{
cos
=
HttpTrafficAnalyzer
:
:
ClassOfService
:
:
eBackground
;
}
else
{
cos
=
HttpTrafficAnalyzer
:
:
ClassOfService
:
:
eOther
;
}
}
bool
isThirdParty
=
AntiTrackingUtils
:
:
IsThirdPartyChannel
(
this
)
;
HttpTrafficAnalyzer
:
:
TrackingClassification
tc
;
{
uint32_t
flags
=
isThirdParty
?
mThirdPartyClassificationFlags
:
mFirstPartyClassificationFlags
;
using
CF
=
nsIClassifiedChannel
:
:
ClassificationFlags
;
using
TC
=
HttpTrafficAnalyzer
:
:
TrackingClassification
;
if
(
flags
&
CF
:
:
CLASSIFIED_TRACKING_CONTENT
)
{
tc
=
TC
:
:
eContent
;
}
else
if
(
flags
&
CF
:
:
CLASSIFIED_FINGERPRINTING_CONTENT
)
{
tc
=
TC
:
:
eFingerprinting
;
}
else
if
(
flags
&
CF
:
:
CLASSIFIED_ANY_BASIC_TRACKING
)
{
tc
=
TC
:
:
eBasic
;
}
else
{
tc
=
TC
:
:
eNone
;
}
}
bool
isSystemPrincipal
=
mLoadInfo
-
>
GetLoadingPrincipal
(
)
&
&
mLoadInfo
-
>
GetLoadingPrincipal
(
)
-
>
IsSystemPrincipal
(
)
;
return
HttpTrafficAnalyzer
:
:
CreateTrafficCategory
(
NS_UsePrivateBrowsing
(
this
)
isSystemPrincipal
isThirdParty
cos
tc
)
;
}
void
nsHttpChannel
:
:
SetCachedContentType
(
)
{
if
(
!
mResponseHead
)
{
return
;
}
nsAutoCString
contentTypeStr
;
mResponseHead
-
>
ContentType
(
contentTypeStr
)
;
uint8_t
contentType
=
nsICacheEntry
:
:
CONTENT_TYPE_OTHER
;
if
(
nsContentUtils
:
:
IsJavascriptMIMEType
(
NS_ConvertUTF8toUTF16
(
contentTypeStr
)
)
)
{
contentType
=
nsICacheEntry
:
:
CONTENT_TYPE_JAVASCRIPT
;
}
else
if
(
StringBeginsWith
(
contentTypeStr
"
text
/
css
"
_ns
)
|
|
(
mLoadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
ExtContentPolicy
:
:
TYPE_STYLESHEET
)
)
{
contentType
=
nsICacheEntry
:
:
CONTENT_TYPE_STYLESHEET
;
}
else
if
(
StringBeginsWith
(
contentTypeStr
"
application
/
wasm
"
_ns
)
)
{
contentType
=
nsICacheEntry
:
:
CONTENT_TYPE_WASM
;
}
else
if
(
StringBeginsWith
(
contentTypeStr
"
image
/
"
_ns
)
)
{
contentType
=
nsICacheEntry
:
:
CONTENT_TYPE_IMAGE
;
}
else
if
(
StringBeginsWith
(
contentTypeStr
"
video
/
"
_ns
)
)
{
contentType
=
nsICacheEntry
:
:
CONTENT_TYPE_MEDIA
;
}
else
if
(
StringBeginsWith
(
contentTypeStr
"
audio
/
"
_ns
)
)
{
contentType
=
nsICacheEntry
:
:
CONTENT_TYPE_MEDIA
;
}
mCacheEntry
-
>
SetContentType
(
contentType
)
;
}
nsresult
nsHttpChannel
:
:
CallOnStartRequest
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
CallOnStartRequest
[
this
=
%
p
]
"
this
)
)
;
MOZ_RELEASE_ASSERT
(
!
LoadRequireCORSPreflight
(
)
|
|
LoadIsCorsPreflightDone
(
)
"
CORS
preflight
must
have
been
finished
by
the
time
we
"
"
call
OnStartRequest
"
)
;
mEarlyHintObserver
=
nullptr
;
if
(
LoadOnStartRequestCalled
(
)
)
{
MOZ_ASSERT
(
LoadConcurrentCacheAccess
(
)
)
;
LOG
(
(
"
CallOnStartRequest
already
invoked
before
"
)
)
;
return
mStatus
;
}
auto
onStartGuard
=
MakeScopeExit
(
[
&
]
{
LOG
(
(
"
calling
mListener
-
>
OnStartRequest
by
ScopeExit
[
this
=
%
p
"
"
listener
=
%
p
]
\
n
"
this
mListener
.
get
(
)
)
)
;
MOZ_ASSERT
(
!
LoadOnStartRequestCalled
(
)
)
;
if
(
mListener
)
{
nsCOMPtr
<
nsIStreamListener
>
deleteProtector
(
mListener
)
;
StoreOnStartRequestCalled
(
true
)
;
deleteProtector
-
>
OnStartRequest
(
this
)
;
}
StoreOnStartRequestCalled
(
true
)
;
}
)
;
nsresult
rv
=
ValidateMIMEType
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mStatus
=
rv
;
return
mStatus
;
}
if
(
!
EnsureOpaqueResponseIsAllowed
(
)
)
{
}
if
(
mLoadFlags
&
LOAD_CALL_CONTENT_SNIFFERS
)
{
nsIChannel
*
thisChannel
=
static_cast
<
nsIChannel
*
>
(
this
)
;
bool
typeSniffersCalled
=
false
;
if
(
mCachePump
)
{
typeSniffersCalled
=
NS_SUCCEEDED
(
mCachePump
-
>
PeekStream
(
CallTypeSniffers
thisChannel
)
)
;
}
if
(
!
typeSniffersCalled
&
&
mTransactionPump
)
{
RefPtr
<
nsInputStreamPump
>
pump
=
do_QueryObject
(
mTransactionPump
)
;
if
(
pump
)
{
pump
-
>
PeekStream
(
CallTypeSniffers
thisChannel
)
;
}
else
{
MOZ_ASSERT
(
nsIOService
:
:
UseSocketProcess
(
)
)
;
RefPtr
<
HttpTransactionParent
>
trans
=
do_QueryObject
(
mTransactionPump
)
;
MOZ_ASSERT
(
trans
)
;
trans
-
>
SetSniffedTypeToChannel
(
CallTypeSniffers
thisChannel
)
;
}
}
}
bool
unknownDecoderStarted
=
false
;
if
(
mResponseHead
&
&
!
mResponseHead
-
>
HasContentType
(
)
)
{
MOZ_ASSERT
(
mConnectionInfo
"
Should
have
connection
info
here
"
)
;
if
(
!
mContentTypeHint
.
IsEmpty
(
)
)
{
mResponseHead
-
>
SetContentType
(
mContentTypeHint
)
;
}
else
if
(
mResponseHead
-
>
Version
(
)
=
=
HttpVersion
:
:
v0_9
&
&
mConnectionInfo
-
>
OriginPort
(
)
!
=
mConnectionInfo
-
>
DefaultPort
(
)
)
{
mResponseHead
-
>
SetContentType
(
nsLiteralCString
(
TEXT_PLAIN
)
)
;
}
else
{
mListener
=
new
nsUnknownDecoder
(
mListener
)
;
unknownDecoderStarted
=
true
;
}
}
if
(
!
unknownDecoderStarted
)
{
auto
isAllowedOrErr
=
EnsureOpaqueResponseIsAllowedAfterSniff
(
)
;
if
(
isAllowedOrErr
.
isErr
(
)
|
|
!
isAllowedOrErr
.
inspect
(
)
)
{
}
}
bool
mustRunStreamFilterInParent
=
false
;
nsCOMPtr
<
nsIParentChannel
>
parentChannel
;
NS_QueryNotificationCallbacks
(
this
parentChannel
)
;
RefPtr
<
DocumentLoadListener
>
docListener
=
do_QueryObject
(
parentChannel
)
;
if
(
mResponseHead
&
&
docListener
&
&
docListener
-
>
GetChannel
(
)
=
=
this
)
{
nsAutoCString
contentType
;
mResponseHead
-
>
ContentType
(
contentType
)
;
if
(
contentType
.
Equals
(
"
multipart
/
x
-
mixed
-
replace
"
_ns
)
)
{
nsCOMPtr
<
nsIStreamConverterService
>
convServ
(
do_GetService
(
"
mozilla
.
org
/
streamConverters
;
1
"
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIStreamListener
>
toListener
(
mListener
)
;
nsCOMPtr
<
nsIStreamListener
>
fromListener
;
rv
=
convServ
-
>
AsyncConvertData
(
"
multipart
/
x
-
mixed
-
replace
"
"
*
/
*
"
toListener
nullptr
getter_AddRefs
(
fromListener
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mListener
=
fromListener
;
mustRunStreamFilterInParent
=
true
;
}
}
}
}
for
(
StreamFilterRequest
&
request
:
mStreamFilterRequests
)
{
if
(
mustRunStreamFilterInParent
)
{
mozilla
:
:
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterParent
>
parent
;
mozilla
:
:
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterChild
>
child
;
nsresult
rv
=
extensions
:
:
PStreamFilter
:
:
CreateEndpoints
(
&
parent
&
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
request
.
mPromise
-
>
Reject
(
false
__func__
)
;
}
else
{
extensions
:
:
StreamFilterParent
:
:
Attach
(
this
std
:
:
move
(
parent
)
)
;
request
.
mPromise
-
>
Resolve
(
std
:
:
move
(
child
)
__func__
)
;
}
}
else
{
if
(
docListener
)
{
docListener
-
>
AttachStreamFilter
(
)
-
>
ChainTo
(
request
.
mPromise
.
forget
(
)
__func__
)
;
}
else
{
request
.
mPromise
-
>
Reject
(
false
__func__
)
;
}
}
request
.
mPromise
=
nullptr
;
}
mStreamFilterRequests
.
Clear
(
)
;
StoreTracingEnabled
(
false
)
;
if
(
mResponseHead
&
&
!
mResponseHead
-
>
HasContentCharset
(
)
)
{
mResponseHead
-
>
SetContentCharset
(
mContentCharsetHint
)
;
}
if
(
mCacheEntry
&
&
LoadCacheEntryIsWriteOnly
(
)
)
{
SetCachedContentType
(
)
;
}
LOG
(
(
"
calling
mListener
-
>
OnStartRequest
[
this
=
%
p
listener
=
%
p
]
\
n
"
this
mListener
.
get
(
)
)
)
;
onStartGuard
.
release
(
)
;
if
(
mListener
)
{
MOZ_ASSERT
(
!
LoadOnStartRequestCalled
(
)
"
We
should
not
call
OsStartRequest
twice
"
)
;
nsCOMPtr
<
nsIStreamListener
>
deleteProtector
(
mListener
)
;
StoreOnStartRequestCalled
(
true
)
;
rv
=
deleteProtector
-
>
OnStartRequest
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
else
{
NS_WARNING
(
"
OnStartRequest
skipped
because
of
null
listener
"
)
;
StoreOnStartRequestCalled
(
true
)
;
}
if
(
!
unknownDecoderStarted
|
|
LoadListenerRequiresContentConversion
(
)
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
;
rv
=
DoApplyContentConversions
(
mListener
getter_AddRefs
(
listener
)
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
listener
)
{
MOZ_ASSERT
(
!
LoadDataSentToChildProcess
(
)
"
DataSentToChildProcess
being
true
means
ODAs
are
sent
to
"
"
the
child
process
directly
.
We
MUST
NOT
apply
content
"
"
converter
in
this
case
.
"
)
;
mListener
=
listener
;
mCompressListener
=
listener
;
StoreHasAppliedConversion
(
true
)
;
}
}
if
(
mCacheEntry
&
&
LoadChannelIsForDownload
(
)
)
{
mCacheEntry
-
>
AsyncDoom
(
nullptr
)
;
if
(
!
LoadCachedContentIsPartial
(
)
&
&
!
LoadConcurrentCacheAccess
(
)
&
&
!
(
mRaceCacheWithNetwork
&
&
mFirstResponseSource
=
=
RESPONSE_FROM_CACHE
)
)
{
CloseCacheEntry
(
false
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetHttpProxyConnectResponseCode
(
int32_t
*
aResponseCode
)
{
NS_ENSURE_ARG_POINTER
(
aResponseCode
)
;
if
(
mConnectionInfo
&
&
mConnectionInfo
-
>
UsingConnect
(
)
)
{
*
aResponseCode
=
mProxyConnectResponseCode
;
}
else
{
*
aResponseCode
=
-
1
;
}
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
ProcessFailedProxyConnect
(
uint32_t
httpStatus
)
{
MOZ_ASSERT
(
mConnectionInfo
-
>
UsingConnect
(
)
"
proxy
connect
failed
but
not
using
CONNECT
?
"
)
;
nsresult
rv
=
HttpProxyResponseToErrorCode
(
httpStatus
)
;
LOG
(
(
"
Cancelling
failed
proxy
CONNECT
[
this
=
%
p
httpStatus
=
%
u
]
\
n
"
this
httpStatus
)
)
;
MOZ_ASSERT
(
mTransaction
)
;
mTransaction
-
>
DontReuseConnection
(
)
;
Cancel
(
rv
)
;
{
nsresult
rv
=
CallOnStartRequest
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
CallOnStartRequest
failed
[
this
=
%
p
httpStatus
=
%
u
rv
=
%
08x
]
\
n
"
this
httpStatus
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
return
rv
;
}
static
void
GetSTSConsoleErrorTag
(
uint32_t
failureResult
nsAString
&
consoleErrorTag
)
{
switch
(
failureResult
)
{
case
nsISiteSecurityService
:
:
ERROR_UNTRUSTWORTHY_CONNECTION
:
consoleErrorTag
=
u
"
STSUntrustworthyConnection
"
_ns
;
break
;
case
nsISiteSecurityService
:
:
ERROR_COULD_NOT_PARSE_HEADER
:
consoleErrorTag
=
u
"
STSCouldNotParseHeader
"
_ns
;
break
;
case
nsISiteSecurityService
:
:
ERROR_NO_MAX_AGE
:
consoleErrorTag
=
u
"
STSNoMaxAge
"
_ns
;
break
;
case
nsISiteSecurityService
:
:
ERROR_MULTIPLE_MAX_AGES
:
consoleErrorTag
=
u
"
STSMultipleMaxAges
"
_ns
;
break
;
case
nsISiteSecurityService
:
:
ERROR_INVALID_MAX_AGE
:
consoleErrorTag
=
u
"
STSInvalidMaxAge
"
_ns
;
break
;
case
nsISiteSecurityService
:
:
ERROR_MULTIPLE_INCLUDE_SUBDOMAINS
:
consoleErrorTag
=
u
"
STSMultipleIncludeSubdomains
"
_ns
;
break
;
case
nsISiteSecurityService
:
:
ERROR_INVALID_INCLUDE_SUBDOMAINS
:
consoleErrorTag
=
u
"
STSInvalidIncludeSubdomains
"
_ns
;
break
;
case
nsISiteSecurityService
:
:
ERROR_COULD_NOT_SAVE_STATE
:
consoleErrorTag
=
u
"
STSCouldNotSaveState
"
_ns
;
break
;
default
:
consoleErrorTag
=
u
"
STSUnknownError
"
_ns
;
break
;
}
}
nsresult
nsHttpChannel
:
:
ProcessHSTSHeader
(
nsITransportSecurityInfo
*
aSecInfo
)
{
nsHttpAtom
atom
(
nsHttp
:
:
ResolveAtom
(
"
Strict
-
Transport
-
Security
"
_ns
)
)
;
nsAutoCString
securityHeader
;
nsresult
rv
=
mResponseHead
-
>
GetHeader
(
atom
securityHeader
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
LOG
(
(
"
nsHttpChannel
:
No
%
s
header
continuing
load
.
\
n
"
atom
.
get
(
)
)
)
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsISiteSecurityService
*
sss
=
gHttpHandler
-
>
GetSSService
(
)
;
NS_ENSURE_TRUE
(
sss
NS_ERROR_OUT_OF_MEMORY
)
;
OriginAttributes
originAttributes
;
if
(
NS_WARN_IF
(
!
StoragePrincipalHelper
:
:
GetOriginAttributesForHSTS
(
this
originAttributes
)
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
failureResult
;
rv
=
sss
-
>
ProcessHeader
(
mURI
securityHeader
aSecInfo
originAttributes
nullptr
nullptr
&
failureResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsAutoString
consoleErrorCategory
(
u
"
Invalid
HSTS
Headers
"
_ns
)
;
nsAutoString
consoleErrorTag
;
GetSTSConsoleErrorTag
(
failureResult
consoleErrorTag
)
;
Unused
<
<
AddSecurityMessage
(
consoleErrorTag
consoleErrorCategory
)
;
LOG
(
(
"
nsHttpChannel
:
Failed
to
parse
%
s
header
continuing
load
.
\
n
"
atom
.
get
(
)
)
)
;
}
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
ProcessSecurityHeaders
(
)
{
if
(
!
mURI
-
>
SchemeIs
(
"
https
"
)
)
{
return
NS_OK
;
}
if
(
IsBrowsingContextDiscarded
(
)
)
{
return
NS_OK
;
}
nsAutoCString
asciiHost
;
nsresult
rv
=
mURI
-
>
GetAsciiHost
(
asciiHost
)
;
NS_ENSURE_SUCCESS
(
rv
NS_OK
)
;
if
(
HostIsIPLiteral
(
asciiHost
)
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
mSecurityInfo
NS_OK
)
;
nsCOMPtr
<
nsITransportSecurityInfo
>
transSecInfo
=
do_QueryInterface
(
mSecurityInfo
)
;
NS_ENSURE_TRUE
(
transSecInfo
NS_ERROR_FAILURE
)
;
if
(
!
mLoadInfo
-
>
GetIsThirdPartyContextToTopWindow
(
)
)
{
rv
=
ProcessHSTSHeader
(
transSecInfo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
bool
nsHttpChannel
:
:
IsHTTPS
(
)
{
return
mURI
-
>
SchemeIs
(
"
https
"
)
;
}
void
nsHttpChannel
:
:
ProcessSSLInformation
(
)
{
if
(
mCanceled
|
|
NS_FAILED
(
mStatus
)
|
|
!
mSecurityInfo
|
|
!
IsHTTPS
(
)
|
|
mPrivateBrowsing
)
{
return
;
}
nsCOMPtr
<
nsITransportSecurityInfo
>
securityInfo
=
do_QueryInterface
(
mSecurityInfo
)
;
if
(
!
securityInfo
)
return
;
uint32_t
state
;
if
(
securityInfo
&
&
NS_SUCCEEDED
(
securityInfo
-
>
GetSecurityState
(
&
state
)
)
&
&
(
state
&
nsIWebProgressListener
:
:
STATE_IS_BROKEN
)
)
{
if
(
state
&
nsIWebProgressListener
:
:
STATE_USES_WEAK_CRYPTO
)
{
nsString
consoleErrorTag
=
u
"
WeakCipherSuiteWarning
"
_ns
;
nsString
consoleErrorCategory
=
u
"
SSL
"
_ns
;
Unused
<
<
AddSecurityMessage
(
consoleErrorTag
consoleErrorCategory
)
;
}
}
uint16_t
tlsVersion
;
nsresult
rv
=
securityInfo
-
>
GetProtocolVersion
(
&
tlsVersion
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
tlsVersion
!
=
nsITransportSecurityInfo
:
:
TLS_VERSION_1_2
&
&
tlsVersion
!
=
nsITransportSecurityInfo
:
:
TLS_VERSION_1_3
)
{
nsString
consoleErrorTag
=
u
"
DeprecatedTLSVersion2
"
_ns
;
nsString
consoleErrorCategory
=
u
"
TLS
"
_ns
;
Unused
<
<
AddSecurityMessage
(
consoleErrorTag
consoleErrorCategory
)
;
}
}
void
nsHttpChannel
:
:
ProcessAltService
(
)
{
if
(
!
LoadAllowAltSvc
(
)
)
{
return
;
}
if
(
!
gHttpHandler
-
>
AllowAltSvc
(
)
|
|
(
mCaps
&
NS_HTTP_DISALLOW_SPDY
)
)
{
return
;
}
if
(
IsBrowsingContextDiscarded
(
)
)
{
return
;
}
nsAutoCString
scheme
;
mURI
-
>
GetScheme
(
scheme
)
;
bool
isHttp
=
scheme
.
EqualsLiteral
(
"
http
"
)
;
if
(
!
isHttp
&
&
!
scheme
.
EqualsLiteral
(
"
https
"
)
)
{
return
;
}
nsAutoCString
altSvc
;
Unused
<
<
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Alternate_Service
altSvc
)
;
if
(
altSvc
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
nsHttp
:
:
IsReasonableHeaderValue
(
altSvc
)
)
{
LOG
(
(
"
Alt
-
Svc
Response
Header
seems
unreasonable
-
skipping
\
n
"
)
)
;
return
;
}
nsAutoCString
originHost
;
int32_t
originPort
=
80
;
mURI
-
>
GetPort
(
&
originPort
)
;
if
(
NS_FAILED
(
mURI
-
>
GetAsciiHost
(
originHost
)
)
)
{
return
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
nsCOMPtr
<
nsProxyInfo
>
proxyInfo
;
NS_NewNotificationCallbacksAggregation
(
mCallbacks
mLoadGroup
getter_AddRefs
(
callbacks
)
)
;
if
(
mProxyInfo
)
{
proxyInfo
=
do_QueryInterface
(
mProxyInfo
)
;
}
OriginAttributes
originAttributes
;
if
(
proxyInfo
&
&
!
StaticPrefs
:
:
privacy_partition_network_state_connection_with_proxy
(
)
)
{
StoragePrincipalHelper
:
:
GetOriginAttributes
(
this
originAttributes
StoragePrincipalHelper
:
:
eRegularPrincipal
)
;
}
else
{
StoragePrincipalHelper
:
:
GetOriginAttributesForNetworkState
(
this
originAttributes
)
;
}
AltSvcMapping
:
:
ProcessHeader
(
altSvc
scheme
originHost
originPort
mUsername
mPrivateBrowsing
callbacks
proxyInfo
mCaps
&
NS_HTTP_DISALLOW_SPDY
originAttributes
)
;
}
nsresult
nsHttpChannel
:
:
ProcessResponse
(
)
{
uint32_t
httpStatus
=
mResponseHead
-
>
Status
(
)
;
LOG
(
(
"
nsHttpChannel
:
:
ProcessResponse
[
this
=
%
p
httpStatus
=
%
u
]
\
n
"
this
httpStatus
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_TRANSACTION_IS_SSL
mConnectionInfo
-
>
EndToEndSSL
(
)
)
;
if
(
mLoadFlags
&
LOAD_INITIAL_DOCUMENT_URI
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_PAGELOAD_IS_SSL
mConnectionInfo
-
>
EndToEndSSL
(
)
)
;
}
if
(
Telemetry
:
:
CanRecordPrereleaseData
(
)
)
{
nsAutoCString
alt_service
;
Unused
<
<
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Alternate_Service
alt_service
)
;
uint32_t
saw_quic
=
0
;
if
(
!
alt_service
.
IsEmpty
(
)
)
{
if
(
strstr
(
alt_service
.
get
(
)
"
h3
-
"
)
)
{
saw_quic
=
1
;
}
else
if
(
strstr
(
alt_service
.
get
(
)
"
quic
"
)
)
{
saw_quic
=
2
;
}
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_SAW_QUIC_ALT_PROTOCOL_2
saw_quic
)
;
switch
(
httpStatus
)
{
case
200
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
0
)
;
break
;
case
301
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
1
)
;
break
;
case
302
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
2
)
;
break
;
case
304
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
3
)
;
break
;
case
307
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
4
)
;
break
;
case
308
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
5
)
;
break
;
case
400
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
6
)
;
break
;
case
401
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
7
)
;
break
;
case
403
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
8
)
;
break
;
case
404
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
9
)
;
break
;
case
500
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
10
)
;
break
;
default
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_STATUS_CODE
11
)
;
break
;
}
}
nsCOMPtr
<
nsIURI
>
referrer
=
GetReferringPage
(
)
;
if
(
!
referrer
&
&
mReferrerInfo
)
{
referrer
=
mReferrerInfo
-
>
GetOriginalReferrer
(
)
;
}
if
(
referrer
)
{
nsCOMPtr
<
nsILoadContextInfo
>
lci
=
GetLoadContextInfo
(
this
)
;
mozilla
:
:
net
:
:
Predictor
:
:
UpdateCacheability
(
referrer
mURI
httpStatus
mRequestHead
mResponseHead
.
get
(
)
lci
IsThirdPartyTrackingResource
(
)
)
;
}
if
(
mTransaction
&
&
mTransaction
-
>
ProxyConnectFailed
(
)
&
&
httpStatus
!
=
407
)
{
return
ProcessFailedProxyConnect
(
httpStatus
)
;
}
MOZ_ASSERT
(
!
mCachedContentIsValid
|
|
mRaceCacheWithNetwork
"
We
should
not
be
hitting
the
network
if
we
have
valid
cached
"
"
content
unless
we
are
racing
the
network
and
cache
"
)
;
ProcessSSLInformation
(
)
;
gHttpHandler
-
>
OnExamineResponse
(
this
)
;
return
ContinueProcessResponse1
(
)
;
}
void
nsHttpChannel
:
:
AsyncContinueProcessResponse
(
)
{
nsresult
rv
;
rv
=
ContinueProcessResponse1
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
Unused
<
<
Cancel
(
rv
)
;
}
}
nsresult
nsHttpChannel
:
:
ContinueProcessResponse1
(
)
{
MOZ_ASSERT
(
!
mCallOnResume
"
How
did
that
happen
?
"
)
;
nsresult
rv
=
NS_OK
;
if
(
mSuspendCount
)
{
LOG
(
(
"
Waiting
until
resume
to
finish
processing
response
[
this
=
%
p
]
\
n
"
this
)
)
;
mCallOnResume
=
[
]
(
nsHttpChannel
*
self
)
{
self
-
>
AsyncContinueProcessResponse
(
)
;
return
NS_OK
;
}
;
return
NS_OK
;
}
if
(
mCanceled
)
{
return
CallOnStartRequest
(
)
;
}
uint32_t
httpStatus
=
mResponseHead
-
>
Status
(
)
;
if
(
!
(
mTransaction
&
&
mTransaction
-
>
ProxyConnectFailed
(
)
)
&
&
(
httpStatus
!
=
407
)
)
{
if
(
nsAutoCString
cookie
;
NS_SUCCEEDED
(
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Set_Cookie
cookie
)
)
)
{
SetCookie
(
cookie
)
;
nsCOMPtr
<
nsIParentChannel
>
parentChannel
;
NS_QueryNotificationCallbacks
(
this
parentChannel
)
;
if
(
RefPtr
<
HttpChannelParent
>
httpParent
=
do_QueryObject
(
parentChannel
)
)
{
httpParent
-
>
SetCookie
(
std
:
:
move
(
cookie
)
)
;
}
}
DebugOnly
<
nsresult
>
rv
=
ProcessSecurityHeaders
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
ProcessSTSHeader
failed
continuing
load
.
"
)
;
if
(
(
httpStatus
<
500
)
&
&
(
httpStatus
!
=
421
)
)
{
ProcessAltService
(
)
;
}
}
if
(
LoadConcurrentCacheAccess
(
)
&
&
LoadCachedContentIsPartial
(
)
&
&
httpStatus
!
=
206
)
{
LOG
(
(
"
only
expecting
206
when
doing
partial
request
during
"
"
interrupted
cache
concurrent
read
"
)
)
;
return
NS_ERROR_CORRUPTED_CONTENT
;
}
if
(
httpStatus
!
=
401
&
&
httpStatus
!
=
407
)
{
if
(
!
mAuthRetryPending
)
{
rv
=
mAuthProvider
-
>
CheckForSuperfluousAuth
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
CheckForSuperfluousAuth
failed
(
%
08x
)
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
if
(
mCanceled
)
return
CallOnStartRequest
(
)
;
rv
=
mAuthProvider
-
>
Disconnect
(
NS_ERROR_ABORT
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Disconnect
failed
(
%
08x
)
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
mAuthProvider
=
nullptr
;
LOG
(
(
"
continuation
state
has
been
reset
"
)
)
;
}
return
ContinueProcessResponse2
(
rv
)
;
}
nsresult
nsHttpChannel
:
:
ContinueProcessResponse2
(
nsresult
rv
)
{
if
(
NS_FAILED
(
rv
)
&
&
!
mCanceled
)
{
Cancel
(
rv
)
;
return
CallOnStartRequest
(
)
;
}
if
(
mAPIRedirectToURI
&
&
!
mCanceled
)
{
MOZ_ASSERT
(
!
LoadOnStartRequestCalled
(
)
)
;
nsCOMPtr
<
nsIURI
>
redirectTo
;
mAPIRedirectToURI
.
swap
(
redirectTo
)
;
PushRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueProcessResponse3
)
;
rv
=
StartRedirectChannelToURI
(
redirectTo
nsIChannelEventSink
:
:
REDIRECT_TEMPORARY
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
NS_OK
;
}
PopRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueProcessResponse3
)
;
}
return
ContinueProcessResponse3
(
NS_BINDING_FAILED
)
;
}
nsresult
nsHttpChannel
:
:
ContinueProcessResponse3
(
nsresult
rv
)
{
LOG
(
(
"
nsHttpChannel
:
:
ContinueProcessResponse3
[
this
=
%
p
rv
=
%
"
PRIx32
"
]
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
NS_OK
;
}
rv
=
NS_OK
;
uint32_t
httpStatus
=
mResponseHead
-
>
Status
(
)
;
bool
transactionRestarted
=
mTransaction
-
>
TakeRestartedState
(
)
;
switch
(
httpStatus
)
{
case
200
:
case
203
:
if
(
LoadResuming
(
)
&
&
mStartPos
!
=
0
)
{
LOG
(
(
"
Server
ignored
our
Range
header
cancelling
[
this
=
%
p
]
\
n
"
this
)
)
;
Cancel
(
NS_ERROR_NOT_RESUMABLE
)
;
rv
=
CallOnStartRequest
(
)
;
break
;
}
rv
=
ProcessNormal
(
)
;
MaybeInvalidateCacheEntryForSubsequentGet
(
)
;
break
;
case
206
:
if
(
LoadCachedContentIsPartial
(
)
)
{
auto
func
=
[
]
(
auto
*
self
nsresult
aRv
)
{
return
self
-
>
ContinueProcessResponseAfterPartialContent
(
aRv
)
;
}
;
rv
=
ProcessPartialContent
(
func
)
;
if
(
!
mSuspendCount
|
|
NS_FAILED
(
rv
)
)
{
return
ContinueProcessResponseAfterPartialContent
(
rv
)
;
}
return
NS_OK
;
}
else
{
mCacheInputStream
.
CloseAndRelease
(
)
;
rv
=
ProcessNormal
(
)
;
}
break
;
case
300
:
case
301
:
case
302
:
case
307
:
case
308
:
case
303
:
#
if
0
case
305
:
#
endif
MaybeInvalidateCacheEntryForSubsequentGet
(
)
;
PushRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueProcessResponse4
)
;
rv
=
AsyncProcessRedirection
(
httpStatus
)
;
if
(
NS_FAILED
(
rv
)
)
{
PopRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueProcessResponse4
)
;
LOG
(
(
"
AsyncProcessRedirection
failed
[
rv
=
%
"
PRIx32
"
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
mCacheEntry
)
mCacheEntry
-
>
AsyncDoom
(
nullptr
)
;
if
(
DoNotRender3xxBody
(
rv
)
)
{
mStatus
=
rv
;
DoNotifyListener
(
)
;
}
else
{
rv
=
ContinueProcessResponse4
(
rv
)
;
}
}
break
;
case
304
:
if
(
!
ShouldBypassProcessNotModified
(
)
)
{
auto
func
=
[
]
(
auto
*
self
nsresult
aRv
)
{
return
self
-
>
ContinueProcessResponseAfterNotModified
(
aRv
)
;
}
;
rv
=
ProcessNotModified
(
func
)
;
if
(
!
mSuspendCount
|
|
NS_FAILED
(
rv
)
)
{
return
ContinueProcessResponseAfterNotModified
(
rv
)
;
}
return
NS_OK
;
}
if
(
LoadCustomConditionalRequest
(
)
)
{
CloseCacheEntry
(
false
)
;
}
if
(
ShouldBypassProcessNotModified
(
)
|
|
NS_FAILED
(
rv
)
)
{
rv
=
ProcessNormal
(
)
;
}
break
;
case
401
:
case
407
:
if
(
MOZ_UNLIKELY
(
httpStatus
=
=
407
&
&
transactionRestarted
)
)
{
mAuthProvider
-
>
ClearProxyIdent
(
)
;
}
if
(
MOZ_UNLIKELY
(
LoadCustomAuthHeader
(
)
)
&
&
httpStatus
=
=
401
)
{
rv
=
NS_ERROR_FAILURE
;
}
else
{
rv
=
mAuthProvider
-
>
ProcessAuthentication
(
httpStatus
mConnectionInfo
-
>
EndToEndSSL
(
)
&
&
mTransaction
&
&
mTransaction
-
>
ProxyConnectFailed
(
)
)
;
}
if
(
rv
=
=
NS_ERROR_IN_PROGRESS
)
{
mIsAuthChannel
=
true
;
mAuthRetryPending
=
true
;
if
(
httpStatus
=
=
407
|
|
(
mTransaction
&
&
mTransaction
-
>
ProxyConnectFailed
(
)
)
)
{
StoreProxyAuthPending
(
true
)
;
}
LOG
(
(
"
Suspending
the
transaction
asynchronously
prompting
for
"
"
credentials
"
)
)
;
mTransactionPump
-
>
Suspend
(
)
;
#
ifdef
DEBUG
gHttpHandler
-
>
OnTransactionSuspendedDueToAuthentication
(
this
)
;
#
endif
rv
=
NS_OK
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ProcessAuthentication
failed
[
rv
=
%
"
PRIx32
"
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
mTransaction
&
&
mTransaction
-
>
ProxyConnectFailed
(
)
)
{
return
ProcessFailedProxyConnect
(
httpStatus
)
;
}
if
(
!
mAuthRetryPending
)
{
rv
=
mAuthProvider
-
>
CheckForSuperfluousAuth
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
CheckForSuperfluousAuth
failed
[
rv
=
%
x
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
rv
=
ProcessNormal
(
)
;
}
else
{
mIsAuthChannel
=
true
;
mAuthRetryPending
=
true
;
}
break
;
case
408
:
case
425
:
case
429
:
CloseCacheEntry
(
false
)
;
[
[
fallthrough
]
]
;
default
:
rv
=
ProcessNormal
(
)
;
MaybeInvalidateCacheEntryForSubsequentGet
(
)
;
break
;
}
UpdateCacheDisposition
(
false
false
)
;
return
rv
;
}
nsresult
nsHttpChannel
:
:
ContinueProcessResponseAfterPartialContent
(
nsresult
aRv
)
{
LOG
(
(
"
nsHttpChannel
:
:
ContinueProcessResponseAfterPartialContent
"
"
[
this
=
%
p
rv
=
%
"
PRIx32
"
]
"
this
static_cast
<
uint32_t
>
(
aRv
)
)
)
;
UpdateCacheDisposition
(
false
NS_SUCCEEDED
(
aRv
)
)
;
return
aRv
;
}
nsresult
nsHttpChannel
:
:
ContinueProcessResponseAfterNotModified
(
nsresult
aRv
)
{
LOG
(
(
"
nsHttpChannel
:
:
ContinueProcessResponseAfterNotModified
"
"
[
this
=
%
p
rv
=
%
"
PRIx32
"
]
"
this
static_cast
<
uint32_t
>
(
aRv
)
)
)
;
if
(
NS_SUCCEEDED
(
aRv
)
)
{
StoreTransactionReplaced
(
true
)
;
UpdateCacheDisposition
(
true
false
)
;
return
NS_OK
;
}
LOG
(
(
"
ProcessNotModified
failed
[
rv
=
%
"
PRIx32
"
]
\
n
"
static_cast
<
uint32_t
>
(
aRv
)
)
)
;
mCacheInputStream
.
CloseAndRelease
(
)
;
if
(
mCacheEntry
)
{
mCacheEntry
-
>
AsyncDoom
(
nullptr
)
;
mCacheEntry
=
nullptr
;
}
nsresult
rv
=
StartRedirectChannelToURI
(
mURI
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
NS_OK
;
}
if
(
LoadCustomConditionalRequest
(
)
)
{
CloseCacheEntry
(
false
)
;
}
if
(
ShouldBypassProcessNotModified
(
)
|
|
NS_FAILED
(
rv
)
)
{
rv
=
ProcessNormal
(
)
;
}
UpdateCacheDisposition
(
false
false
)
;
return
rv
;
}
void
nsHttpChannel
:
:
UpdateCacheDisposition
(
bool
aSuccessfulReval
bool
aPartialContentUsed
)
{
if
(
mRaceDelay
&
&
!
mRaceCacheWithNetwork
&
&
(
LoadCachedContentIsPartial
(
)
|
|
mDidReval
)
)
{
if
(
aSuccessfulReval
|
|
aPartialContentUsed
)
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_RACE_CACHE_VALIDATION
:
:
CachedContentUsed
)
;
}
else
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_RACE_CACHE_VALIDATION
:
:
CachedContentNotUsed
)
;
}
}
if
(
Telemetry
:
:
CanRecordPrereleaseData
(
)
)
{
CacheDisposition
cacheDisposition
;
if
(
!
mDidReval
)
{
cacheDisposition
=
kCacheMissed
;
}
else
if
(
aSuccessfulReval
)
{
cacheDisposition
=
kCacheHitViaReval
;
}
else
{
cacheDisposition
=
kCacheMissedViaReval
;
}
AccumulateCacheHitTelemetry
(
cacheDisposition
this
)
;
mCacheDisposition
=
cacheDisposition
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_RESPONSE_VERSION
static_cast
<
uint32_t
>
(
mResponseHead
-
>
Version
(
)
)
)
;
if
(
mResponseHead
-
>
Version
(
)
=
=
HttpVersion
:
:
v0_9
)
{
uint32_t
v09Info
=
0
;
if
(
!
(
mLoadFlags
&
LOAD_INITIAL_DOCUMENT_URI
)
)
{
v09Info
+
=
1
;
}
if
(
mConnectionInfo
-
>
OriginPort
(
)
!
=
mConnectionInfo
-
>
DefaultPort
(
)
)
{
v09Info
+
=
2
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_09_INFO
v09Info
)
;
}
}
}
nsresult
nsHttpChannel
:
:
ContinueProcessResponse4
(
nsresult
rv
)
{
bool
doNotRender
=
DoNotRender3xxBody
(
rv
)
;
if
(
rv
=
=
NS_ERROR_DOM_BAD_URI
&
&
mRedirectURI
)
{
bool
isHTTP
=
mRedirectURI
-
>
SchemeIs
(
"
http
"
)
|
|
mRedirectURI
-
>
SchemeIs
(
"
https
"
)
;
if
(
!
isHTTP
)
{
LOG
(
(
"
ContinueProcessResponse4
detected
rejected
Non
-
HTTP
Redirection
"
)
)
;
doNotRender
=
true
;
rv
=
NS_ERROR_CORRUPTED_CONTENT
;
}
}
if
(
doNotRender
)
{
Cancel
(
rv
)
;
DoNotifyListener
(
)
;
return
rv
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
UpdateInhibitPersistentCachingFlag
(
)
;
MaybeCreateCacheEntryWhenRCWN
(
)
;
rv
=
InitCacheEntry
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ContinueProcessResponse4
"
"
failed
to
init
cache
entry
[
rv
=
%
x
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
CloseCacheEntry
(
false
)
;
return
NS_OK
;
}
LOG
(
(
"
ContinueProcessResponse4
got
failure
result
[
rv
=
%
"
PRIx32
"
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
mTransaction
&
&
mTransaction
-
>
ProxyConnectFailed
(
)
)
{
return
ProcessFailedProxyConnect
(
mRedirectType
)
;
}
return
ProcessNormal
(
)
;
}
nsresult
nsHttpChannel
:
:
ProcessNormal
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
ProcessNormal
[
this
=
%
p
]
\
n
"
this
)
)
;
return
ContinueProcessNormal
(
NS_OK
)
;
}
nsresult
nsHttpChannel
:
:
ContinueProcessNormal
(
nsresult
rv
)
{
LOG
(
(
"
nsHttpChannel
:
:
ContinueProcessNormal
[
this
=
%
p
]
"
this
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mStatus
=
rv
;
DoNotifyListener
(
)
;
return
rv
;
}
rv
=
ProcessCrossOriginSecurityHeaders
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mStatus
=
rv
;
HandleAsyncAbort
(
)
;
return
rv
;
}
StoreCachedContentIsPartial
(
false
)
;
ClearBogusContentEncodingIfNeeded
(
)
;
UpdateInhibitPersistentCachingFlag
(
)
;
MaybeCreateCacheEntryWhenRCWN
(
)
;
if
(
mCacheEntry
)
{
rv
=
InitCacheEntry
(
)
;
if
(
NS_FAILED
(
rv
)
)
CloseCacheEntry
(
true
)
;
}
if
(
LoadResuming
(
)
)
{
nsAutoCString
id
;
rv
=
GetEntityID
(
id
)
;
if
(
NS_FAILED
(
rv
)
)
{
Cancel
(
NS_ERROR_NOT_RESUMABLE
)
;
}
else
if
(
mResponseHead
-
>
Status
(
)
!
=
206
&
&
mResponseHead
-
>
Status
(
)
!
=
200
)
{
LOG
(
(
"
Unexpected
response
status
while
resuming
aborting
[
this
=
%
p
]
\
n
"
this
)
)
;
Cancel
(
NS_ERROR_ENTITY_CHANGED
)
;
}
else
if
(
!
mEntityID
.
IsEmpty
(
)
)
{
if
(
!
mEntityID
.
Equals
(
id
)
)
{
LOG
(
(
"
Entity
mismatch
expected
'
%
s
'
got
'
%
s
'
aborting
[
this
=
%
p
]
"
mEntityID
.
get
(
)
id
.
get
(
)
this
)
)
;
Cancel
(
NS_ERROR_ENTITY_CHANGED
)
;
}
}
}
rv
=
CallOnStartRequest
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
mCacheEntry
&
&
!
LoadCacheEntryIsReadOnly
(
)
)
{
rv
=
InstallCacheListener
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
PromptTempRedirect
(
)
{
if
(
!
gHttpHandler
-
>
PromptTempRedirect
(
)
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIStringBundleService
>
bundleService
=
do_GetService
(
NS_STRINGBUNDLE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIStringBundle
>
stringBundle
;
rv
=
bundleService
-
>
CreateBundle
(
NECKO_MSGS_URL
getter_AddRefs
(
stringBundle
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsAutoString
messageString
;
rv
=
stringBundle
-
>
GetStringFromName
(
"
RepostFormData
"
messageString
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
repost
=
false
;
nsCOMPtr
<
nsIPrompt
>
prompt
;
GetCallback
(
prompt
)
;
if
(
!
prompt
)
return
NS_ERROR_NO_INTERFACE
;
prompt
-
>
Confirm
(
nullptr
messageString
.
get
(
)
&
repost
)
;
if
(
!
repost
)
return
NS_ERROR_FAILURE
;
}
return
rv
;
}
nsresult
nsHttpChannel
:
:
ProxyFailover
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
ProxyFailover
[
this
=
%
p
]
\
n
"
this
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIProtocolProxyService
>
pps
=
do_GetService
(
NS_PROTOCOLPROXYSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIProxyInfo
>
pi
;
rv
=
pps
-
>
GetFailoverForProxy
(
mConnectionInfo
-
>
ProxyInfo
(
)
mURI
mStatus
getter_AddRefs
(
pi
)
)
;
#
ifdef
MOZ_PROXY_DIRECT_FAILOVER
if
(
NS_FAILED
(
rv
)
)
{
if
(
!
StaticPrefs
:
:
network_proxy_failover_direct
(
)
)
{
return
rv
;
}
if
(
LoadBeConservative
(
)
)
{
rv
=
pps
-
>
NewProxyInfo
(
"
direct
"
_ns
"
"
_ns
0
"
"
_ns
"
"
_ns
0
UINT32_MAX
nullptr
getter_AddRefs
(
pi
)
)
;
}
#
endif
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
#
ifdef
MOZ_PROXY_DIRECT_FAILOVER
}
#
endif
return
AsyncDoReplaceWithProxy
(
pi
)
;
}
void
nsHttpChannel
:
:
SetHTTPSSVCRecord
(
already_AddRefed
<
nsIDNSHTTPSSVCRecord
>
&
&
aRecord
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetHTTPSSVCRecord
[
this
=
%
p
]
\
n
"
this
)
)
;
nsCOMPtr
<
nsIDNSHTTPSSVCRecord
>
record
=
aRecord
;
MOZ_ASSERT
(
!
mHTTPSSVCRecord
)
;
mHTTPSSVCRecord
.
emplace
(
std
:
:
move
(
record
)
)
;
}
void
nsHttpChannel
:
:
HandleAsyncRedirectChannelToHttps
(
)
{
MOZ_ASSERT
(
!
mCallOnResume
"
How
did
that
happen
?
"
)
;
if
(
mSuspendCount
)
{
LOG
(
(
"
Waiting
until
resume
to
do
async
redirect
to
https
[
this
=
%
p
]
\
n
"
this
)
)
;
mCallOnResume
=
[
]
(
nsHttpChannel
*
self
)
{
self
-
>
HandleAsyncRedirectChannelToHttps
(
)
;
return
NS_OK
;
}
;
return
;
}
nsresult
rv
=
StartRedirectChannelToHttps
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
ContinueAsyncRedirectChannelToURI
(
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ContinueAsyncRedirectChannelToURI
failed
(
%
08x
)
[
this
=
%
p
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
this
)
)
;
}
}
}
nsresult
nsHttpChannel
:
:
StartRedirectChannelToHttps
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
HandleAsyncRedirectChannelToHttps
(
)
[
STS
]
\
n
"
)
)
;
nsCOMPtr
<
nsIURI
>
upgradedURI
;
nsresult
rv
=
NS_GetSecureUpgradedURI
(
mURI
getter_AddRefs
(
upgradedURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
StartRedirectChannelToURI
(
upgradedURI
nsIChannelEventSink
:
:
REDIRECT_PERMANENT
|
nsIChannelEventSink
:
:
REDIRECT_STS_UPGRADE
)
;
}
void
nsHttpChannel
:
:
HandleAsyncAPIRedirect
(
)
{
MOZ_ASSERT
(
!
mCallOnResume
"
How
did
that
happen
?
"
)
;
MOZ_ASSERT
(
mAPIRedirectToURI
"
How
did
that
happen
?
"
)
;
if
(
mSuspendCount
)
{
LOG
(
(
"
Waiting
until
resume
to
do
async
API
redirect
[
this
=
%
p
]
\
n
"
this
)
)
;
mCallOnResume
=
[
]
(
nsHttpChannel
*
self
)
{
self
-
>
HandleAsyncAPIRedirect
(
)
;
return
NS_OK
;
}
;
return
;
}
nsresult
rv
=
StartRedirectChannelToURI
(
mAPIRedirectToURI
nsIChannelEventSink
:
:
REDIRECT_PERMANENT
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
ContinueAsyncRedirectChannelToURI
(
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ContinueAsyncRedirectChannelToURI
failed
(
%
08x
)
[
this
=
%
p
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
this
)
)
;
}
}
}
void
nsHttpChannel
:
:
HandleAsyncRedirectToUnstrippedURI
(
)
{
MOZ_ASSERT
(
!
mCallOnResume
"
How
did
that
happen
?
"
)
;
if
(
mSuspendCount
)
{
LOG
(
(
"
Waiting
until
resume
to
do
async
redirect
to
unstripped
URI
"
"
[
this
=
%
p
]
\
n
"
this
)
)
;
mCallOnResume
=
[
]
(
nsHttpChannel
*
self
)
{
self
-
>
HandleAsyncRedirectToUnstrippedURI
(
)
;
return
NS_OK
;
}
;
return
;
}
nsCOMPtr
<
nsIURI
>
unstrippedURI
;
mLoadInfo
-
>
GetUnstrippedURI
(
getter_AddRefs
(
unstrippedURI
)
)
;
mLoadInfo
-
>
SetUnstrippedURI
(
nullptr
)
;
nsresult
rv
=
StartRedirectChannelToURI
(
unstrippedURI
nsIChannelEventSink
:
:
REDIRECT_PERMANENT
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
ContinueAsyncRedirectChannelToURI
(
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ContinueAsyncRedirectChannelToURI
failed
(
%
08x
)
[
this
=
%
p
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
this
)
)
;
}
}
}
nsresult
nsHttpChannel
:
:
StartRedirectChannelToURI
(
nsIURI
*
upgradedURI
uint32_t
flags
)
{
nsresult
rv
=
NS_OK
;
LOG
(
(
"
nsHttpChannel
:
:
StartRedirectChannelToURI
(
)
\
n
"
)
)
;
nsCOMPtr
<
nsIChannel
>
newChannel
;
nsCOMPtr
<
nsILoadInfo
>
redirectLoadInfo
=
CloneLoadInfoForRedirect
(
upgradedURI
flags
)
;
nsCOMPtr
<
nsIIOService
>
ioService
;
rv
=
gHttpHandler
-
>
GetIOService
(
getter_AddRefs
(
ioService
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
newChannel
)
upgradedURI
redirectLoadInfo
nullptr
nullptr
nullptr
nsIRequest
:
:
LOAD_NORMAL
ioService
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupReplacementChannel
(
upgradedURI
newChannel
true
flags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mHTTPSSVCRecord
)
{
RefPtr
<
nsHttpChannel
>
httpChan
=
do_QueryObject
(
newChannel
)
;
nsCOMPtr
<
nsIDNSHTTPSSVCRecord
>
rec
=
mHTTPSSVCRecord
.
ref
(
)
;
if
(
httpChan
&
&
rec
)
{
httpChan
-
>
SetHTTPSSVCRecord
(
rec
.
forget
(
)
)
;
}
}
mRedirectChannel
=
newChannel
;
PushRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueAsyncRedirectChannelToURI
)
;
rv
=
gHttpHandler
-
>
AsyncOnChannelRedirect
(
this
newChannel
flags
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
WaitForRedirectCallback
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
AutoRedirectVetoNotifier
notifier
(
this
)
;
PopRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueAsyncRedirectChannelToURI
)
;
}
return
rv
;
}
nsresult
nsHttpChannel
:
:
ContinueAsyncRedirectChannelToURI
(
nsresult
rv
)
{
LOG
(
(
"
nsHttpChannel
:
:
ContinueAsyncRedirectChannelToURI
[
this
=
%
p
]
"
this
)
)
;
mAPIRedirectToURI
=
nullptr
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
OpenRedirectChannel
(
rv
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
Cancel
(
rv
)
;
}
if
(
mLoadGroup
)
{
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
mStatus
)
;
}
if
(
NS_FAILED
(
rv
)
&
&
!
mCachePump
&
&
!
mTransactionPump
)
{
DoNotifyListener
(
)
;
}
return
rv
;
}
nsresult
nsHttpChannel
:
:
OpenRedirectChannel
(
nsresult
rv
)
{
AutoRedirectVetoNotifier
notifier
(
this
)
;
mRedirectChannel
-
>
SetOriginalURI
(
mOriginalURI
)
;
rv
=
mRedirectChannel
-
>
AsyncOpen
(
mListener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mStatus
=
NS_BINDING_REDIRECTED
;
notifier
.
RedirectSucceeded
(
)
;
ReleaseListeners
(
)
;
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
AsyncDoReplaceWithProxy
(
nsIProxyInfo
*
pi
)
{
LOG
(
(
"
nsHttpChannel
:
:
AsyncDoReplaceWithProxy
[
this
=
%
p
pi
=
%
p
]
"
this
pi
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIChannel
>
newChannel
;
rv
=
gHttpHandler
-
>
NewProxiedChannel
(
mURI
pi
mProxyResolveFlags
mProxyURI
mLoadInfo
getter_AddRefs
(
newChannel
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
uint32_t
flags
=
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
;
rv
=
SetupReplacementChannel
(
mURI
newChannel
true
flags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mRedirectChannel
=
newChannel
;
PushRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueDoReplaceWithProxy
)
;
rv
=
gHttpHandler
-
>
AsyncOnChannelRedirect
(
this
newChannel
flags
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
WaitForRedirectCallback
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
AutoRedirectVetoNotifier
notifier
(
this
)
;
PopRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueDoReplaceWithProxy
)
;
}
return
rv
;
}
nsresult
nsHttpChannel
:
:
ContinueDoReplaceWithProxy
(
nsresult
rv
)
{
AutoRedirectVetoNotifier
notifier
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
MOZ_ASSERT
(
mRedirectChannel
"
No
redirect
channel
?
"
)
;
mRedirectChannel
-
>
SetOriginalURI
(
mOriginalURI
)
;
rv
=
mRedirectChannel
-
>
AsyncOpen
(
mListener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mStatus
=
NS_BINDING_REDIRECTED
;
notifier
.
RedirectSucceeded
(
)
;
ReleaseListeners
(
)
;
return
rv
;
}
nsresult
nsHttpChannel
:
:
ResolveProxy
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
ResolveProxy
[
this
=
%
p
]
\
n
"
this
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIProtocolProxyService
>
pps
=
do_GetService
(
NS_PROTOCOLPROXYSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIProtocolProxyService2
>
pps2
=
do_QueryInterface
(
pps
)
;
if
(
pps2
)
{
rv
=
pps2
-
>
AsyncResolve2
(
this
mProxyResolveFlags
this
nullptr
getter_AddRefs
(
mProxyRequest
)
)
;
}
else
{
rv
=
pps
-
>
AsyncResolve
(
static_cast
<
nsIChannel
*
>
(
this
)
mProxyResolveFlags
this
nullptr
getter_AddRefs
(
mProxyRequest
)
)
;
}
return
rv
;
}
bool
nsHttpChannel
:
:
ResponseWouldVary
(
nsICacheEntry
*
entry
)
{
nsresult
rv
;
nsAutoCString
buf
metaKey
;
Unused
<
<
mCachedResponseHead
-
>
GetHeader
(
nsHttp
:
:
Vary
buf
)
;
constexpr
auto
prefix
=
"
request
-
"
_ns
;
for
(
const
nsACString
&
token
:
nsCCharSeparatedTokenizer
(
buf
NS_HTTP_HEADER_SEP
)
.
ToRange
(
)
)
{
LOG
(
(
"
nsHttpChannel
:
:
ResponseWouldVary
[
channel
=
%
p
]
"
"
processing
%
s
\
n
"
this
nsPromiseFlatCString
(
token
)
.
get
(
)
)
)
;
if
(
token
.
EqualsLiteral
(
"
*
"
)
)
{
return
true
;
}
metaKey
=
prefix
+
token
;
nsCString
lastVal
;
entry
-
>
GetMetaDataElement
(
metaKey
.
get
(
)
getter_Copies
(
lastVal
)
)
;
LOG
(
(
"
nsHttpChannel
:
:
ResponseWouldVary
[
channel
=
%
p
]
"
"
stored
value
=
\
"
%
s
\
"
\
n
"
this
lastVal
.
get
(
)
)
)
;
nsHttpAtom
atom
=
nsHttp
:
:
ResolveAtom
(
token
)
;
nsAutoCString
newVal
;
bool
hasHeader
=
NS_SUCCEEDED
(
mRequestHead
.
GetHeader
(
atom
newVal
)
)
;
if
(
!
lastVal
.
IsEmpty
(
)
)
{
if
(
!
hasHeader
)
{
return
true
;
}
nsAutoCString
hash
;
if
(
atom
=
=
nsHttp
:
:
Cookie
)
{
rv
=
Hash
(
newVal
.
get
(
)
hash
)
;
if
(
NS_FAILED
(
rv
)
)
return
true
;
newVal
=
hash
;
LOG
(
(
"
nsHttpChannel
:
:
ResponseWouldVary
[
this
=
%
p
]
"
"
set
-
cookie
value
hashed
to
%
s
\
n
"
this
newVal
.
get
(
)
)
)
;
}
if
(
!
newVal
.
Equals
(
lastVal
)
)
{
return
true
;
}
}
else
if
(
hasHeader
)
{
return
true
;
}
}
return
false
;
}
void
nsHttpChannel
:
:
HandleAsyncAbort
(
)
{
HttpAsyncAborter
<
nsHttpChannel
>
:
:
HandleAsyncAbort
(
)
;
}
bool
nsHttpChannel
:
:
IsResumable
(
int64_t
partialLen
int64_t
contentLength
bool
ignoreMissingPartialLen
)
const
{
bool
hasContentEncoding
=
mCachedResponseHead
-
>
HasHeader
(
nsHttp
:
:
Content_Encoding
)
;
nsAutoCString
etag
;
Unused
<
<
mCachedResponseHead
-
>
GetHeader
(
nsHttp
:
:
ETag
etag
)
;
bool
hasWeakEtag
=
!
etag
.
IsEmpty
(
)
&
&
StringBeginsWith
(
etag
"
W
/
"
_ns
)
;
return
(
partialLen
<
contentLength
)
&
&
(
partialLen
>
0
|
|
ignoreMissingPartialLen
)
&
&
!
hasContentEncoding
&
&
!
hasWeakEtag
&
&
mCachedResponseHead
-
>
IsResumable
(
)
&
&
!
LoadCustomConditionalRequest
(
)
&
&
!
mCachedResponseHead
-
>
NoStore
(
)
;
}
nsresult
nsHttpChannel
:
:
MaybeSetupByteRangeRequest
(
int64_t
partialLen
int64_t
contentLength
bool
ignoreMissingPartialLen
)
{
StoreIsPartialRequest
(
false
)
;
if
(
!
IsResumable
(
partialLen
contentLength
ignoreMissingPartialLen
)
)
{
return
NS_ERROR_NOT_RESUMABLE
;
}
nsresult
rv
=
SetupByteRangeRequest
(
partialLen
)
;
if
(
NS_FAILED
(
rv
)
)
{
UntieByteRangeRequest
(
)
;
}
return
rv
;
}
nsresult
nsHttpChannel
:
:
SetupByteRangeRequest
(
int64_t
partialLen
)
{
nsAutoCString
val
;
Unused
<
<
mCachedResponseHead
-
>
GetHeader
(
nsHttp
:
:
ETag
val
)
;
if
(
val
.
IsEmpty
(
)
)
{
Unused
<
<
mCachedResponseHead
-
>
GetHeader
(
nsHttp
:
:
Last_Modified
val
)
;
}
if
(
val
.
IsEmpty
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
no
cache
validator
"
)
;
StoreIsPartialRequest
(
false
)
;
return
NS_ERROR_FAILURE
;
}
char
buf
[
64
]
;
SprintfLiteral
(
buf
"
bytes
=
%
"
PRId64
"
-
"
partialLen
)
;
DebugOnly
<
nsresult
>
rv
{
}
;
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
Range
nsDependentCString
(
buf
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
If_Range
val
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
StoreIsPartialRequest
(
true
)
;
return
NS_OK
;
}
void
nsHttpChannel
:
:
UntieByteRangeRequest
(
)
{
DebugOnly
<
nsresult
>
rv
{
}
;
rv
=
mRequestHead
.
ClearHeader
(
nsHttp
:
:
Range
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
mRequestHead
.
ClearHeader
(
nsHttp
:
:
If_Range
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsresult
nsHttpChannel
:
:
ProcessPartialContent
(
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueProcessResponseFunc
)
{
LOG
(
(
"
nsHttpChannel
:
:
ProcessPartialContent
[
this
=
%
p
]
\
n
"
this
)
)
;
NS_ENSURE_TRUE
(
mCachedResponseHead
NS_ERROR_NOT_INITIALIZED
)
;
NS_ENSURE_TRUE
(
mCacheEntry
NS_ERROR_NOT_INITIALIZED
)
;
ClearBogusContentEncodingIfNeeded
(
)
;
nsAutoCString
contentEncoding
cachedContentEncoding
;
Unused
<
<
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Content_Encoding
contentEncoding
)
;
Unused
<
<
mCachedResponseHead
-
>
GetHeader
(
nsHttp
:
:
Content_Encoding
cachedContentEncoding
)
;
if
(
nsCRT
:
:
strcasecmp
(
contentEncoding
.
get
(
)
cachedContentEncoding
.
get
(
)
)
!
=
0
)
{
Cancel
(
NS_ERROR_INVALID_CONTENT_ENCODING
)
;
return
CallOnStartRequest
(
)
;
}
nsresult
rv
;
int64_t
cachedContentLength
=
mCachedResponseHead
-
>
ContentLength
(
)
;
int64_t
entitySize
=
mResponseHead
-
>
TotalEntitySize
(
)
;
nsAutoCString
contentRange
;
Unused
<
<
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Content_Range
contentRange
)
;
LOG
(
(
"
nsHttpChannel
:
:
ProcessPartialContent
[
this
=
%
p
trans
=
%
p
]
"
"
original
content
-
length
%
"
PRId64
"
entity
-
size
%
"
PRId64
"
content
-
range
%
s
\
n
"
this
mTransaction
.
get
(
)
cachedContentLength
entitySize
contentRange
.
get
(
)
)
)
;
if
(
(
entitySize
>
=
0
)
&
&
(
cachedContentLength
>
=
0
)
&
&
(
entitySize
!
=
cachedContentLength
)
)
{
LOG
(
(
"
nsHttpChannel
:
:
ProcessPartialContent
[
this
=
%
p
]
"
"
206
has
different
total
entity
size
than
the
content
length
"
"
of
the
original
partially
cached
entity
.
\
n
"
this
)
)
;
mCacheEntry
-
>
AsyncDoom
(
nullptr
)
;
Cancel
(
NS_ERROR_CORRUPTED_CONTENT
)
;
return
CallOnStartRequest
(
)
;
}
if
(
LoadConcurrentCacheAccess
(
)
)
{
rv
=
InstallCacheListener
(
mLogicalOffset
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
else
{
rv
=
mTransactionPump
-
>
Suspend
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
mCachedResponseHead
-
>
UpdateHeaders
(
mResponseHead
.
get
(
)
)
;
nsAutoCString
head
;
mCachedResponseHead
-
>
Flatten
(
head
true
)
;
rv
=
mCacheEntry
-
>
SetMetaDataElement
(
"
response
-
head
"
head
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mResponseHead
=
std
:
:
move
(
mCachedResponseHead
)
;
UpdateInhibitPersistentCachingFlag
(
)
;
rv
=
UpdateExpirationTime
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
gHttpHandler
-
>
OnExamineMergedResponse
(
this
)
;
if
(
LoadConcurrentCacheAccess
(
)
)
{
StoreCachedContentIsPartial
(
false
)
;
return
rv
;
}
mCachedContentIsValid
=
true
;
return
CallOrWaitForResume
(
[
aContinueProcessResponseFunc
]
(
auto
*
self
)
{
nsresult
rv
=
self
-
>
ReadFromCache
(
false
)
;
return
aContinueProcessResponseFunc
(
self
rv
)
;
}
)
;
}
nsresult
nsHttpChannel
:
:
OnDoneReadingPartialCacheEntry
(
bool
*
streamDone
)
{
nsresult
rv
;
LOG
(
(
"
nsHttpChannel
:
:
OnDoneReadingPartialCacheEntry
[
this
=
%
p
]
"
this
)
)
;
*
streamDone
=
true
;
int64_t
size
;
rv
=
mCacheEntry
-
>
GetDataSize
(
&
size
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
InstallCacheListener
(
size
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
mCacheEntry
-
>
SetValid
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mLogicalOffset
=
size
;
StoreCachedContentIsPartial
(
false
)
;
mCachePump
=
nullptr
;
if
(
mTransactionPump
)
{
rv
=
mTransactionPump
-
>
Resume
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
*
streamDone
=
false
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
no
transaction
"
)
;
}
return
rv
;
}
bool
nsHttpChannel
:
:
ShouldBypassProcessNotModified
(
)
{
if
(
LoadCustomConditionalRequest
(
)
)
{
LOG
(
(
"
Bypassing
ProcessNotModified
due
to
custom
conditional
headers
"
)
)
;
return
true
;
}
if
(
!
mDidReval
)
{
LOG
(
(
"
Server
returned
a
304
response
even
though
we
did
not
send
a
"
"
conditional
request
"
)
)
;
return
true
;
}
return
false
;
}
nsresult
nsHttpChannel
:
:
ProcessNotModified
(
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueProcessResponseFunc
)
{
nsresult
rv
;
LOG
(
(
"
nsHttpChannel
:
:
ProcessNotModified
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
!
ShouldBypassProcessNotModified
(
)
)
;
MOZ_ASSERT
(
mCachedResponseHead
)
;
MOZ_ASSERT
(
mCacheEntry
)
;
NS_ENSURE_TRUE
(
mCachedResponseHead
&
&
mCacheEntry
NS_ERROR_UNEXPECTED
)
;
nsAutoCString
lastModifiedCached
;
nsAutoCString
lastModified304
;
rv
=
mCachedResponseHead
-
>
GetHeader
(
nsHttp
:
:
Last_Modified
lastModifiedCached
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Last_Modified
lastModified304
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
lastModified304
.
Equals
(
lastModifiedCached
)
)
{
LOG
(
(
"
Cache
Entry
and
304
Last
-
Modified
Headers
Do
Not
Match
"
"
[
%
s
]
and
[
%
s
]
\
n
"
lastModifiedCached
.
get
(
)
lastModified304
.
get
(
)
)
)
;
mCacheEntry
-
>
AsyncDoom
(
nullptr
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CACHE_LM_INCONSISTENT
true
)
;
}
mCachedResponseHead
-
>
UpdateHeaders
(
mResponseHead
.
get
(
)
)
;
nsAutoCString
head
;
mCachedResponseHead
-
>
Flatten
(
head
true
)
;
rv
=
mCacheEntry
-
>
SetMetaDataElement
(
"
response
-
head
"
head
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mResponseHead
=
std
:
:
move
(
mCachedResponseHead
)
;
UpdateInhibitPersistentCachingFlag
(
)
;
rv
=
UpdateExpirationTime
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
AddCacheEntryHeaders
(
mCacheEntry
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
gHttpHandler
-
>
OnExamineMergedResponse
(
this
)
;
mCachedContentIsValid
=
true
;
rv
=
mCacheEntry
-
>
SetValid
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
CallOrWaitForResume
(
[
aContinueProcessResponseFunc
]
(
auto
*
self
)
{
nsresult
rv
=
self
-
>
ReadFromCache
(
false
)
;
return
aContinueProcessResponseFunc
(
self
rv
)
;
}
)
;
}
static
bool
IsSubRangeRequest
(
nsHttpRequestHead
&
aRequestHead
)
{
nsAutoCString
byteRange
;
if
(
NS_FAILED
(
aRequestHead
.
GetHeader
(
nsHttp
:
:
Range
byteRange
)
)
)
{
return
false
;
}
return
!
byteRange
.
EqualsLiteral
(
"
bytes
=
0
-
"
)
;
}
nsresult
nsHttpChannel
:
:
OpenCacheEntry
(
bool
isHttps
)
{
StoreConcurrentCacheAccess
(
0
)
;
LOG
(
(
"
nsHttpChannel
:
:
OpenCacheEntry
[
this
=
%
p
]
"
this
)
)
;
MOZ_ASSERT
(
!
mCacheEntry
"
cache
entry
already
open
"
)
;
if
(
mRequestHead
.
IsPost
(
)
)
{
if
(
mPostID
=
=
0
)
mPostID
=
gHttpHandler
-
>
GenerateUniqueID
(
)
;
}
else
if
(
!
mRequestHead
.
IsGet
(
)
&
&
!
mRequestHead
.
IsHead
(
)
)
{
return
NS_OK
;
}
return
OpenCacheEntryInternal
(
isHttps
)
;
}
nsresult
nsHttpChannel
:
:
OpenCacheEntryInternal
(
bool
isHttps
)
{
nsresult
rv
;
if
(
LoadResuming
(
)
)
{
return
NS_OK
;
}
if
(
IsSubRangeRequest
(
mRequestHead
)
)
{
return
NS_OK
;
}
AutoCacheWaitFlags
waitFlags
(
this
)
;
nsAutoCString
cacheKey
;
nsCOMPtr
<
nsICacheStorageService
>
cacheStorageService
(
components
:
:
CacheStorage
:
:
Service
(
)
)
;
if
(
!
cacheStorageService
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsICacheStorage
>
cacheStorage
;
mCacheEntryURI
=
mURI
;
RefPtr
<
LoadContextInfo
>
info
=
GetLoadContextInfo
(
this
)
;
if
(
!
info
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
cacheEntryOpenFlags
;
bool
offline
=
gIOService
-
>
IsOffline
(
)
;
bool
maybeRCWN
=
false
;
nsAutoCString
cacheControlRequestHeader
;
Unused
<
<
mRequestHead
.
GetHeader
(
nsHttp
:
:
Cache_Control
cacheControlRequestHeader
)
;
CacheControlParser
cacheControlRequest
(
cacheControlRequestHeader
)
;
if
(
cacheControlRequest
.
NoStore
(
)
)
{
return
NS_OK
;
}
if
(
offline
|
|
(
mLoadFlags
&
INHIBIT_CACHING
)
)
{
if
(
BYPASS_LOCAL_CACHE
(
mLoadFlags
LoadPreferCacheLoadOverBypass
(
)
)
&
&
!
offline
)
{
return
NS_OK
;
}
cacheEntryOpenFlags
=
nsICacheStorage
:
:
OPEN_READONLY
;
StoreCacheEntryIsReadOnly
(
true
)
;
}
else
if
(
BYPASS_LOCAL_CACHE
(
mLoadFlags
LoadPreferCacheLoadOverBypass
(
)
)
)
{
cacheEntryOpenFlags
=
nsICacheStorage
:
:
OPEN_TRUNCATE
;
}
else
{
cacheEntryOpenFlags
=
nsICacheStorage
:
:
OPEN_NORMALLY
|
nsICacheStorage
:
:
CHECK_MULTITHREADED
;
}
StoreCustomConditionalRequest
(
mRequestHead
.
HasHeader
(
nsHttp
:
:
If_Modified_Since
)
|
|
mRequestHead
.
HasHeader
(
nsHttp
:
:
If_None_Match
)
|
|
mRequestHead
.
HasHeader
(
nsHttp
:
:
If_Unmodified_Since
)
|
|
mRequestHead
.
HasHeader
(
nsHttp
:
:
If_Match
)
|
|
mRequestHead
.
HasHeader
(
nsHttp
:
:
If_Range
)
)
;
if
(
mLoadFlags
&
INHIBIT_PERSISTENT_CACHING
)
{
rv
=
cacheStorageService
-
>
MemoryCacheStorage
(
info
getter_AddRefs
(
cacheStorage
)
)
;
}
else
if
(
LoadPinCacheContent
(
)
)
{
rv
=
cacheStorageService
-
>
PinningCacheStorage
(
info
getter_AddRefs
(
cacheStorage
)
)
;
}
else
{
maybeRCWN
=
mRequestHead
.
IsSafeMethod
(
)
;
rv
=
cacheStorageService
-
>
DiskCacheStorage
(
info
getter_AddRefs
(
cacheStorage
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
(
mClassOfService
.
Flags
(
)
&
nsIClassOfService
:
:
Leader
)
|
|
(
mLoadFlags
&
LOAD_INITIAL_DOCUMENT_URI
)
)
{
cacheEntryOpenFlags
|
=
nsICacheStorage
:
:
OPEN_PRIORITY
;
}
if
(
mLoadFlags
&
LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
)
{
cacheEntryOpenFlags
|
=
nsICacheStorage
:
:
OPEN_BYPASS_IF_BUSY
;
}
if
(
mPostID
)
{
mCacheIdExtension
.
Append
(
nsPrintfCString
(
"
%
d
"
mPostID
)
)
;
}
if
(
LoadIsTRRServiceChannel
(
)
)
{
mCacheIdExtension
.
Append
(
"
TRR
"
)
;
}
if
(
mRequestHead
.
IsHead
(
)
)
{
mCacheIdExtension
.
Append
(
"
HEAD
"
)
;
}
mCacheOpenWithPriority
=
cacheEntryOpenFlags
&
nsICacheStorage
:
:
OPEN_PRIORITY
;
mCacheQueueSizeWhenOpen
=
CacheStorageService
:
:
CacheQueueSize
(
mCacheOpenWithPriority
)
;
if
(
StaticPrefs
:
:
network_http_rcwn_enabled
(
)
&
&
maybeRCWN
)
{
bool
hasAltData
=
false
;
uint32_t
sizeInKb
=
0
;
rv
=
cacheStorage
-
>
GetCacheIndexEntryAttrs
(
mCacheEntryURI
mCacheIdExtension
&
hasAltData
&
sizeInKb
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
hasAltData
&
&
sizeInKb
<
StaticPrefs
:
:
network_http_rcwn_small_resource_size_kb
(
)
)
{
MaybeRaceCacheWithNetwork
(
)
;
}
}
if
(
!
mCacheOpenDelay
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
called
on
the
main
thread
"
)
;
if
(
mNetworkTriggered
)
{
mRaceCacheWithNetwork
=
StaticPrefs
:
:
network_http_rcwn_enabled
(
)
;
}
rv
=
cacheStorage
-
>
AsyncOpenURI
(
mCacheEntryURI
mCacheIdExtension
cacheEntryOpenFlags
this
)
;
}
else
{
mCacheOpenFunc
=
[
cacheEntryOpenFlags
cacheStorage
]
(
nsHttpChannel
*
self
)
-
>
void
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
called
on
the
main
thread
"
)
;
cacheStorage
-
>
AsyncOpenURI
(
self
-
>
mCacheEntryURI
self
-
>
mCacheIdExtension
cacheEntryOpenFlags
self
)
;
}
;
auto
callback
=
MakeRefPtr
<
TimerCallback
>
(
this
)
;
NS_NewTimerWithCallback
(
getter_AddRefs
(
mCacheOpenTimer
)
callback
mCacheOpenDelay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
waitFlags
.
Keep
(
WAIT_FOR_CACHE_ENTRY
)
;
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
CheckPartial
(
nsICacheEntry
*
aEntry
int64_t
*
aSize
int64_t
*
aContentLength
)
{
return
nsHttp
:
:
CheckPartial
(
aEntry
aSize
aContentLength
mCachedResponseHead
?
mCachedResponseHead
.
get
(
)
:
mResponseHead
.
get
(
)
)
;
}
void
nsHttpChannel
:
:
UntieValidationRequest
(
)
{
DebugOnly
<
nsresult
>
rv
{
}
;
rv
=
mRequestHead
.
ClearHeader
(
nsHttp
:
:
If_Modified_Since
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
mRequestHead
.
ClearHeader
(
nsHttp
:
:
If_None_Match
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
mRequestHead
.
ClearHeader
(
nsHttp
:
:
ETag
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnCacheEntryCheck
(
nsICacheEntry
*
entry
uint32_t
*
aResult
)
{
nsresult
rv
=
NS_OK
;
LOG
(
(
"
nsHttpChannel
:
:
OnCacheEntryCheck
enter
[
channel
=
%
p
entry
=
%
p
]
"
this
entry
)
)
;
mozilla
:
:
MutexAutoLock
lock
(
mRCWNLock
)
;
if
(
mRaceCacheWithNetwork
&
&
mFirstResponseSource
=
=
RESPONSE_FROM_NETWORK
)
{
LOG
(
(
"
Not
using
cached
response
because
we
'
ve
already
got
one
from
the
"
"
network
\
n
"
)
)
;
*
aResult
=
ENTRY_NOT_WANTED
;
int64_t
savedTime
=
(
TimeStamp
:
:
Now
(
)
-
mOnStartRequestTimestamp
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_RACE_CACHE_WITH_NETWORK_SAVED_TIME
savedTime
)
;
return
NS_OK
;
}
if
(
mRaceCacheWithNetwork
&
&
mFirstResponseSource
=
=
RESPONSE_PENDING
)
{
mOnCacheEntryCheckTimestamp
=
TimeStamp
:
:
Now
(
)
;
}
nsAutoCString
cacheControlRequestHeader
;
Unused
<
<
mRequestHead
.
GetHeader
(
nsHttp
:
:
Cache_Control
cacheControlRequestHeader
)
;
CacheControlParser
cacheControlRequest
(
cacheControlRequestHeader
)
;
if
(
cacheControlRequest
.
NoStore
(
)
)
{
LOG
(
(
"
Not
using
cached
response
based
on
no
-
store
request
cache
"
"
directive
\
n
"
)
)
;
*
aResult
=
ENTRY_NOT_WANTED
;
return
NS_OK
;
}
*
aResult
=
ENTRY_WANTED
;
mCachedContentIsValid
=
false
;
nsCString
buf
;
rv
=
entry
-
>
GetMetaDataElement
(
"
request
-
method
"
getter_Copies
(
buf
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
methodWasHead
=
buf
.
EqualsLiteral
(
"
HEAD
"
)
;
bool
methodWasGet
=
buf
.
EqualsLiteral
(
"
GET
"
)
;
if
(
methodWasHead
)
{
if
(
!
mRequestHead
.
IsHead
(
)
)
{
*
aResult
=
ENTRY_NOT_WANTED
;
return
NS_OK
;
}
}
buf
.
Adopt
(
nullptr
)
;
uint32_t
lastModifiedTime
;
rv
=
entry
-
>
GetLastModified
(
&
lastModifiedTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
fromPreviousSession
=
(
gHttpHandler
-
>
SessionStartTime
(
)
>
lastModifiedTime
)
;
mCachedResponseHead
=
MakeUnique
<
nsHttpResponseHead
>
(
)
;
rv
=
nsHttp
:
:
GetHttpResponseHeadFromCacheEntry
(
entry
mCachedResponseHead
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isCachedRedirect
=
WillRedirect
(
*
mCachedResponseHead
)
;
NS_ENSURE_TRUE
(
(
mCachedResponseHead
-
>
Status
(
)
/
100
!
=
3
)
|
|
isCachedRedirect
NS_ERROR_ABORT
)
;
if
(
mCachedResponseHead
-
>
NoStore
(
)
&
&
LoadCacheEntryIsReadOnly
(
)
)
{
LOG
(
(
"
entry
loading
as
read
-
only
but
is
no
-
store
set
INHIBIT_CACHING
"
)
)
;
mLoadFlags
|
=
nsIRequest
:
:
INHIBIT_CACHING
;
}
if
(
(
LoadCacheEntryIsReadOnly
(
)
&
&
!
(
mLoadFlags
&
nsIRequest
:
:
INHIBIT_CACHING
)
)
)
{
int64_t
size
contentLength
;
rv
=
CheckPartial
(
entry
&
size
&
contentLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
contentLength
!
=
int64_t
(
-
1
)
&
&
contentLength
!
=
size
)
{
*
aResult
=
ENTRY_NOT_WANTED
;
return
NS_OK
;
}
rv
=
OpenCacheInputStream
(
entry
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mCachedContentIsValid
=
true
;
entry
-
>
MaybeMarkValid
(
)
;
}
return
rv
;
}
bool
wantCompleteEntry
=
false
;
if
(
!
methodWasHead
&
&
!
isCachedRedirect
)
{
int64_t
size
contentLength
;
rv
=
CheckPartial
(
entry
&
size
&
contentLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
size
=
=
int64_t
(
-
1
)
)
{
LOG
(
(
"
write
is
in
progress
"
)
)
;
if
(
mLoadFlags
&
LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
)
{
LOG
(
(
"
not
interested
in
the
entry
"
"
LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
specified
"
)
)
;
*
aResult
=
ENTRY_NOT_WANTED
;
return
NS_OK
;
}
if
(
!
IsResumable
(
size
contentLength
true
)
)
{
if
(
IsNavigation
(
)
)
{
LOG
(
(
"
bypassing
wait
for
the
entry
"
"
this
is
a
navigational
load
"
)
)
;
*
aResult
=
ENTRY_NOT_WANTED
;
return
NS_OK
;
}
LOG
(
(
"
wait
for
entry
completion
"
"
response
is
not
resumable
"
)
)
;
wantCompleteEntry
=
true
;
}
else
{
StoreConcurrentCacheAccess
(
1
)
;
}
}
else
if
(
contentLength
!
=
int64_t
(
-
1
)
&
&
contentLength
!
=
size
)
{
LOG
(
(
"
Cached
data
size
does
not
match
the
Content
-
Length
header
"
"
[
content
-
length
=
%
"
PRId64
"
size
=
%
"
PRId64
"
]
\
n
"
contentLength
size
)
)
;
rv
=
MaybeSetupByteRangeRequest
(
size
contentLength
)
;
StoreCachedContentIsPartial
(
NS_SUCCEEDED
(
rv
)
&
&
LoadIsPartialRequest
(
)
)
;
if
(
LoadCachedContentIsPartial
(
)
)
{
rv
=
OpenCacheInputStream
(
entry
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
UntieByteRangeRequest
(
)
;
return
rv
;
}
*
aResult
=
ENTRY_NEEDS_REVALIDATION
;
return
NS_OK
;
}
if
(
size
=
=
0
&
&
LoadCacheOnlyMetadata
(
)
)
{
MOZ_ASSERT
(
mLoadFlags
&
LOAD_ONLY_IF_MODIFIED
)
;
}
else
{
return
rv
;
}
}
}
bool
isHttps
=
mURI
-
>
SchemeIs
(
"
https
"
)
;
bool
doValidation
=
false
;
bool
doBackgroundValidation
=
false
;
bool
canAddImsHeader
=
true
;
bool
isForcedValid
=
false
;
entry
-
>
GetIsForcedValid
(
&
isForcedValid
)
;
auto
prefetchStatus
=
Telemetry
:
:
LABELS_PREDICTOR_PREFETCH_USE_STATUS
:
:
Used
;
bool
weaklyFramed
isImmutable
;
nsHttp
:
:
DetermineFramingAndImmutability
(
entry
mCachedResponseHead
.
get
(
)
isHttps
&
weaklyFramed
&
isImmutable
)
;
if
(
ResponseWouldVary
(
entry
)
)
{
LOG
(
(
"
Validating
based
on
Vary
headers
returning
TRUE
\
n
"
)
)
;
canAddImsHeader
=
false
;
doValidation
=
true
;
prefetchStatus
=
Telemetry
:
:
LABELS_PREDICTOR_PREFETCH_USE_STATUS
:
:
WouldVary
;
}
else
{
if
(
mCachedResponseHead
-
>
ExpiresInPast
(
)
|
|
mCachedResponseHead
-
>
MustValidateIfExpired
(
)
)
{
prefetchStatus
=
Telemetry
:
:
LABELS_PREDICTOR_PREFETCH_USE_STATUS
:
:
Expired
;
}
doValidation
=
nsHttp
:
:
ValidationRequired
(
isForcedValid
mCachedResponseHead
.
get
(
)
mLoadFlags
LoadAllowStaleCacheContent
(
)
LoadForceValidateCacheContent
(
)
isImmutable
LoadCustomConditionalRequest
(
)
mRequestHead
entry
cacheControlRequest
fromPreviousSession
&
doBackgroundValidation
)
;
}
nsAutoCString
requestedETag
;
if
(
!
doValidation
&
&
NS_SUCCEEDED
(
mRequestHead
.
GetHeader
(
nsHttp
:
:
If_Match
requestedETag
)
)
&
&
(
methodWasGet
|
|
methodWasHead
)
)
{
nsAutoCString
cachedETag
;
Unused
<
<
mCachedResponseHead
-
>
GetHeader
(
nsHttp
:
:
ETag
cachedETag
)
;
if
(
!
cachedETag
.
IsEmpty
(
)
&
&
(
StringBeginsWith
(
cachedETag
"
W
/
"
_ns
)
|
|
!
requestedETag
.
Equals
(
cachedETag
)
)
)
{
doValidation
=
true
;
}
}
rv
=
NS_OK
;
if
(
!
doValidation
)
{
entry
-
>
GetMetaDataElement
(
"
auth
"
getter_Copies
(
buf
)
)
;
doValidation
=
(
fromPreviousSession
&
&
!
buf
.
IsEmpty
(
)
)
|
|
(
buf
.
IsEmpty
(
)
&
&
mRequestHead
.
HasHeader
(
nsHttp
:
:
Authorization
)
)
;
if
(
doValidation
)
{
prefetchStatus
=
Telemetry
:
:
LABELS_PREDICTOR_PREFETCH_USE_STATUS
:
:
Auth
;
}
}
if
(
!
doValidation
&
&
isCachedRedirect
)
{
nsAutoCString
cacheKey
;
rv
=
GenerateCacheKey
(
mPostID
cacheKey
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
mRedirectedCachekeys
)
{
mRedirectedCachekeys
=
MakeUnique
<
nsTArray
<
nsCString
>
>
(
)
;
}
else
if
(
mRedirectedCachekeys
-
>
Contains
(
cacheKey
)
)
{
doValidation
=
true
;
}
LOG
(
(
"
Redirection
-
chain
%
s
key
%
s
\
n
"
doValidation
?
"
contains
"
:
"
does
not
contain
"
cacheKey
.
get
(
)
)
)
;
if
(
!
doValidation
)
{
mRedirectedCachekeys
-
>
AppendElement
(
cacheKey
)
;
}
else
{
prefetchStatus
=
Telemetry
:
:
LABELS_PREDICTOR_PREFETCH_USE_STATUS
:
:
Redirect
;
}
}
mCachedContentIsValid
=
!
doValidation
;
if
(
isForcedValid
)
{
if
(
!
doValidation
)
{
prefetchStatus
=
Telemetry
:
:
LABELS_PREDICTOR_PREFETCH_USE_STATUS
:
:
Used
;
entry
-
>
MarkForcedValidUse
(
)
;
}
Telemetry
:
:
AccumulateCategorical
(
prefetchStatus
)
;
}
if
(
doValidation
)
{
if
(
!
mCachedResponseHead
-
>
NoStore
(
)
&
&
(
mRequestHead
.
IsGet
(
)
|
|
mRequestHead
.
IsHead
(
)
)
&
&
!
LoadCustomConditionalRequest
(
)
&
&
!
weaklyFramed
&
&
!
isImmutable
&
&
(
mCachedResponseHead
-
>
Status
(
)
<
400
)
)
{
if
(
LoadConcurrentCacheAccess
(
)
)
{
StoreConcurrentCacheAccess
(
0
)
;
wantCompleteEntry
=
true
;
}
else
{
nsAutoCString
val
;
if
(
canAddImsHeader
)
{
Unused
<
<
mCachedResponseHead
-
>
GetHeader
(
nsHttp
:
:
Last_Modified
val
)
;
if
(
!
val
.
IsEmpty
(
)
)
{
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
If_Modified_Since
val
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
Unused
<
<
mCachedResponseHead
-
>
GetHeader
(
nsHttp
:
:
ETag
val
)
;
if
(
!
val
.
IsEmpty
(
)
)
{
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
If_None_Match
val
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
mDidReval
=
true
;
}
}
}
if
(
mCachedContentIsValid
|
|
mDidReval
)
{
rv
=
OpenCacheInputStream
(
entry
mCachedContentIsValid
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mDidReval
)
{
UntieValidationRequest
(
)
;
mDidReval
=
false
;
}
mCachedContentIsValid
=
false
;
}
}
if
(
mDidReval
)
{
*
aResult
=
ENTRY_NEEDS_REVALIDATION
;
}
else
if
(
wantCompleteEntry
)
{
*
aResult
=
RECHECK_AFTER_WRITE_FINISHED
;
}
else
{
*
aResult
=
ENTRY_WANTED
;
if
(
doBackgroundValidation
)
{
PerformBackgroundCacheRevalidation
(
)
;
}
}
if
(
mCachedContentIsValid
)
{
entry
-
>
MaybeMarkValid
(
)
;
}
LOG
(
(
"
nsHTTPChannel
:
:
OnCacheEntryCheck
exit
[
this
=
%
p
doValidation
=
%
d
"
"
result
=
%
d
]
\
n
"
this
doValidation
*
aResult
)
)
;
return
rv
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnCacheEntryAvailable
(
nsICacheEntry
*
entry
bool
aNew
nsresult
status
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
;
LOG
(
(
"
nsHttpChannel
:
:
OnCacheEntryAvailable
[
this
=
%
p
entry
=
%
p
"
"
new
=
%
d
status
=
%
"
PRIx32
"
]
\
n
"
this
entry
aNew
static_cast
<
uint32_t
>
(
status
)
)
)
;
if
(
!
LoadIsPending
(
)
)
{
mCacheInputStream
.
CloseAndRelease
(
)
;
return
NS_OK
;
}
rv
=
OnCacheEntryAvailableInternal
(
entry
aNew
status
)
;
if
(
NS_FAILED
(
rv
)
)
{
CloseCacheEntry
(
false
)
;
if
(
mRaceCacheWithNetwork
&
&
mNetworkTriggered
&
&
mFirstResponseSource
!
=
RESPONSE_FROM_CACHE
)
{
LOG
(
(
"
not
calling
AsyncAbort
(
)
because
we
'
re
racing
cache
with
"
"
network
"
)
)
;
}
else
{
Unused
<
<
AsyncAbort
(
rv
)
;
}
}
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
OnCacheEntryAvailableInternal
(
nsICacheEntry
*
entry
bool
aNew
nsresult
status
)
{
nsresult
rv
;
if
(
mCanceled
)
{
LOG
(
(
"
channel
was
canceled
[
this
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
static_cast
<
nsresult
>
(
mStatus
)
)
)
)
;
return
mStatus
;
}
if
(
mIgnoreCacheEntry
)
{
if
(
!
entry
|
|
aNew
)
{
mIgnoreCacheEntry
=
false
;
}
entry
=
nullptr
;
status
=
NS_ERROR_NOT_AVAILABLE
;
}
rv
=
OnNormalCacheEntryAvailable
(
entry
aNew
status
)
;
if
(
NS_FAILED
(
rv
)
&
&
(
mLoadFlags
&
LOAD_ONLY_FROM_CACHE
)
)
{
return
NS_ERROR_DOCUMENT_NOT_CACHED
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
AwaitingCacheCallbacks
(
)
)
{
return
NS_OK
;
}
if
(
mRaceCacheWithNetwork
&
&
(
(
mCacheEntry
&
&
!
mCachedContentIsValid
&
&
(
mDidReval
|
|
LoadCachedContentIsPartial
(
)
)
)
|
|
mIgnoreCacheEntry
)
)
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_RACE_CACHE_VALIDATION
:
:
NotSent
)
;
}
if
(
mRaceCacheWithNetwork
&
&
mCachedContentIsValid
)
{
Unused
<
<
ReadFromCache
(
true
)
;
}
return
TriggerNetwork
(
)
;
}
nsresult
nsHttpChannel
:
:
OnNormalCacheEntryAvailable
(
nsICacheEntry
*
aEntry
bool
aNew
nsresult
aEntryStatus
)
{
StoreWaitForCacheEntry
(
LoadWaitForCacheEntry
(
)
&
~
WAIT_FOR_CACHE_ENTRY
)
;
if
(
NS_FAILED
(
aEntryStatus
)
|
|
aNew
)
{
mCachedContentIsValid
=
false
;
if
(
mDidReval
)
{
LOG
(
(
"
Removing
conditional
request
headers
"
)
)
;
UntieValidationRequest
(
)
;
mDidReval
=
false
;
}
if
(
LoadCachedContentIsPartial
(
)
)
{
LOG
(
(
"
Removing
byte
range
request
headers
"
)
)
;
UntieByteRangeRequest
(
)
;
StoreCachedContentIsPartial
(
false
)
;
}
if
(
mLoadFlags
&
LOAD_ONLY_FROM_CACHE
)
{
return
NS_ERROR_DOCUMENT_NOT_CACHED
;
}
}
if
(
NS_SUCCEEDED
(
aEntryStatus
)
)
{
mCacheEntry
=
aEntry
;
StoreCacheEntryIsWriteOnly
(
aNew
)
;
if
(
!
aNew
&
&
!
mAsyncOpenTime
.
IsNull
(
)
)
{
uint32_t
duration
=
(
TimeStamp
:
:
Now
(
)
-
mAsyncOpenTime
)
.
ToMicroseconds
(
)
;
bool
isSlow
=
false
;
if
(
(
mCacheOpenWithPriority
&
&
mCacheQueueSizeWhenOpen
>
=
StaticPrefs
:
:
network_http_rcwn_cache_queue_priority_threshold
(
)
)
|
|
(
!
mCacheOpenWithPriority
&
&
mCacheQueueSizeWhenOpen
>
=
StaticPrefs
:
:
network_http_rcwn_cache_queue_normal_threshold
(
)
)
)
{
isSlow
=
true
;
}
CacheFileUtils
:
:
CachePerfStats
:
:
AddValue
(
CacheFileUtils
:
:
CachePerfStats
:
:
ENTRY_OPEN
duration
isSlow
)
;
}
if
(
mLoadFlags
&
LOAD_INITIAL_DOCUMENT_URI
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_OFFLINE_CACHE_DOCUMENT_LOAD
false
)
;
}
}
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
GenerateCacheKey
(
uint32_t
postID
nsACString
&
cacheKey
)
{
AssembleCacheKey
(
mSpec
.
get
(
)
postID
cacheKey
)
;
return
NS_OK
;
}
void
nsHttpChannel
:
:
AssembleCacheKey
(
const
char
*
spec
uint32_t
postID
nsACString
&
cacheKey
)
{
cacheKey
.
Truncate
(
)
;
if
(
mLoadFlags
&
LOAD_ANONYMOUS
)
{
cacheKey
.
AssignLiteral
(
"
anon
&
"
)
;
}
if
(
postID
)
{
char
buf
[
32
]
;
SprintfLiteral
(
buf
"
id
=
%
x
&
"
postID
)
;
cacheKey
.
Append
(
buf
)
;
}
if
(
!
cacheKey
.
IsEmpty
(
)
)
{
cacheKey
.
AppendLiteral
(
"
uri
=
"
)
;
}
const
char
*
p
=
strchr
(
spec
'
#
'
)
;
if
(
p
)
{
cacheKey
.
Append
(
spec
p
-
spec
)
;
}
else
{
cacheKey
.
Append
(
spec
)
;
}
}
nsresult
DoUpdateExpirationTime
(
nsHttpChannel
*
aSelf
nsICacheEntry
*
aCacheEntry
nsHttpResponseHead
*
aResponseHead
uint32_t
&
aExpirationTime
)
{
MOZ_ASSERT
(
aExpirationTime
=
=
0
)
;
NS_ENSURE_TRUE
(
aResponseHead
NS_ERROR_FAILURE
)
;
nsresult
rv
;
if
(
!
aResponseHead
-
>
MustValidate
(
)
)
{
uint32_t
now
=
NowInSeconds
(
)
;
aExpirationTime
=
now
;
uint32_t
freshnessLifetime
=
0
;
rv
=
aResponseHead
-
>
ComputeFreshnessLifetime
(
&
freshnessLifetime
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
freshnessLifetime
>
0
)
{
uint32_t
currentAge
=
0
;
rv
=
aResponseHead
-
>
ComputeCurrentAge
(
now
aSelf
-
>
GetRequestTime
(
)
&
currentAge
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
LOG
(
(
"
freshnessLifetime
=
%
u
currentAge
=
%
u
\
n
"
freshnessLifetime
currentAge
)
)
;
if
(
freshnessLifetime
>
currentAge
)
{
uint32_t
timeRemaining
=
freshnessLifetime
-
currentAge
;
if
(
now
+
timeRemaining
<
now
)
{
aExpirationTime
=
uint32_t
(
-
1
)
;
}
else
{
aExpirationTime
=
now
+
timeRemaining
;
}
}
}
}
rv
=
aCacheEntry
-
>
SetExpirationTime
(
aExpirationTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
nsresult
nsHttpChannel
:
:
UpdateExpirationTime
(
)
{
uint32_t
expirationTime
=
0
;
nsresult
rv
=
DoUpdateExpirationTime
(
this
mCacheEntry
mResponseHead
.
get
(
)
expirationTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
OpenCacheInputStream
(
nsICacheEntry
*
cacheEntry
bool
startBuffering
)
{
nsresult
rv
;
if
(
mURI
-
>
SchemeIs
(
"
https
"
)
)
{
rv
=
cacheEntry
-
>
GetSecurityInfo
(
getter_AddRefs
(
mCachedSecurityInfo
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
failed
to
parse
security
-
info
[
channel
=
%
p
entry
=
%
p
]
"
this
cacheEntry
)
)
;
NS_WARNING
(
"
failed
to
parse
security
-
info
"
)
;
cacheEntry
-
>
AsyncDoom
(
nullptr
)
;
return
rv
;
}
MOZ_ASSERT
(
mCachedSecurityInfo
)
;
if
(
!
mCachedSecurityInfo
)
{
LOG
(
(
"
mCacheEntry
-
>
GetSecurityInfo
returned
success
but
did
not
"
"
return
the
security
info
[
channel
=
%
p
entry
=
%
p
]
"
this
cacheEntry
)
)
;
cacheEntry
-
>
AsyncDoom
(
nullptr
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
rv
=
NS_OK
;
if
(
WillRedirect
(
*
mCachedResponseHead
)
)
{
LOG
(
(
"
Will
skip
read
of
cached
redirect
entity
\
n
"
)
)
;
return
NS_OK
;
}
if
(
(
mLoadFlags
&
nsICachingChannel
:
:
LOAD_ONLY_IF_MODIFIED
)
&
&
!
LoadCachedContentIsPartial
(
)
)
{
LOG
(
(
"
Will
skip
read
from
cache
based
on
LOAD_ONLY_IF_MODIFIED
"
"
load
flag
\
n
"
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
bool
altDataFromChild
=
false
;
{
nsCString
value
;
rv
=
cacheEntry
-
>
GetMetaDataElement
(
"
alt
-
data
-
from
-
child
"
getter_Copies
(
value
)
)
;
altDataFromChild
=
!
value
.
IsEmpty
(
)
;
}
nsAutoCString
altDataType
;
Unused
<
<
cacheEntry
-
>
GetAltDataType
(
altDataType
)
;
nsAutoCString
contentType
;
mCachedResponseHead
-
>
ContentType
(
contentType
)
;
bool
foundAltData
=
false
;
bool
deliverAltData
=
true
;
if
(
!
LoadDisableAltDataCache
(
)
&
&
!
altDataType
.
IsEmpty
(
)
&
&
!
mPreferredCachedAltDataTypes
.
IsEmpty
(
)
&
&
altDataFromChild
=
=
LoadAltDataForChild
(
)
)
{
for
(
auto
&
pref
:
mPreferredCachedAltDataTypes
)
{
if
(
pref
.
type
(
)
=
=
altDataType
&
&
(
pref
.
contentType
(
)
.
IsEmpty
(
)
|
|
pref
.
contentType
(
)
=
=
contentType
)
)
{
foundAltData
=
true
;
deliverAltData
=
pref
.
deliverAltData
(
)
=
=
nsICacheInfoChannel
:
:
PreferredAlternativeDataDeliveryType
:
:
ASYNC
;
break
;
}
}
}
nsCOMPtr
<
nsIInputStream
>
altData
;
int64_t
altDataSize
=
-
1
;
if
(
foundAltData
)
{
rv
=
cacheEntry
-
>
OpenAlternativeInputStream
(
altDataType
getter_AddRefs
(
altData
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mAvailableCachedAltDataType
=
altDataType
;
StoreDeliveringAltData
(
deliverAltData
)
;
Unused
<
<
cacheEntry
-
>
GetAltDataSize
(
&
altDataSize
)
;
mAltDataLength
=
altDataSize
;
LOG
(
(
"
Opened
alt
-
data
input
stream
[
type
=
%
s
size
=
%
"
PRId64
"
deliverAltData
=
%
d
]
"
altDataType
.
get
(
)
mAltDataLength
deliverAltData
)
)
;
if
(
deliverAltData
)
{
stream
=
altData
;
}
}
}
if
(
!
stream
)
{
rv
=
cacheEntry
-
>
OpenInputStream
(
0
getter_AddRefs
(
stream
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
open
cache
input
stream
[
channel
=
%
p
"
"
mCacheEntry
=
%
p
]
"
this
cacheEntry
)
)
;
return
rv
;
}
if
(
startBuffering
)
{
bool
nonBlocking
;
rv
=
stream
-
>
IsNonBlocking
(
&
nonBlocking
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
nonBlocking
)
startBuffering
=
false
;
}
if
(
!
startBuffering
)
{
LOG
(
(
"
Opened
cache
input
stream
without
buffering
[
channel
=
%
p
"
"
mCacheEntry
=
%
p
stream
=
%
p
]
"
this
cacheEntry
stream
.
get
(
)
)
)
;
mCacheInputStream
.
takeOver
(
stream
)
;
return
rv
;
}
nsCOMPtr
<
nsITransport
>
transport
;
nsCOMPtr
<
nsIInputStream
>
wrapper
;
nsCOMPtr
<
nsIStreamTransportService
>
sts
(
components
:
:
StreamTransport
:
:
Service
(
)
)
;
rv
=
sts
?
NS_OK
:
NS_ERROR_NOT_AVAILABLE
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
sts
-
>
CreateInputTransport
(
stream
true
getter_AddRefs
(
transport
)
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
transport
-
>
OpenInputStream
(
0
0
0
getter_AddRefs
(
wrapper
)
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
Opened
cache
input
stream
[
channel
=
%
p
wrapper
=
%
p
"
"
transport
=
%
p
stream
=
%
p
]
"
this
wrapper
.
get
(
)
transport
.
get
(
)
stream
.
get
(
)
)
)
;
}
else
{
LOG
(
(
"
Failed
to
open
cache
input
stream
[
channel
=
%
p
"
"
wrapper
=
%
p
transport
=
%
p
stream
=
%
p
]
"
this
wrapper
.
get
(
)
transport
.
get
(
)
stream
.
get
(
)
)
)
;
stream
-
>
Close
(
)
;
return
rv
;
}
mCacheInputStream
.
takeOver
(
wrapper
)
;
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
ReadFromCache
(
bool
alreadyMarkedValid
)
{
NS_ENSURE_TRUE
(
mCacheEntry
NS_ERROR_FAILURE
)
;
NS_ENSURE_TRUE
(
mCachedContentIsValid
NS_ERROR_FAILURE
)
;
NS_ENSURE_TRUE
(
!
mCachePump
NS_OK
)
;
LOG
(
(
"
nsHttpChannel
:
:
ReadFromCache
[
this
=
%
p
]
"
"
Using
cached
copy
of
:
%
s
\
n
"
this
mSpec
.
get
(
)
)
)
;
if
(
mNetworkTriggerTimer
)
{
mNetworkTriggerTimer
-
>
Cancel
(
)
;
mNetworkTriggerTimer
=
nullptr
;
}
if
(
mRaceCacheWithNetwork
)
{
MOZ_ASSERT
(
mFirstResponseSource
!
=
RESPONSE_FROM_CACHE
)
;
if
(
mFirstResponseSource
=
=
RESPONSE_PENDING
)
{
LOG
(
(
"
First
response
from
cache
\
n
"
)
)
;
mFirstResponseSource
=
RESPONSE_FROM_CACHE
;
CancelNetworkRequest
(
NS_BINDING_ABORTED
)
;
if
(
mTransactionPump
&
&
mSuspendCount
)
{
uint32_t
suspendCount
=
mSuspendCount
;
while
(
suspendCount
-
-
)
{
mTransactionPump
-
>
Resume
(
)
;
}
}
mTransaction
=
nullptr
;
mTransactionPump
=
nullptr
;
}
else
{
MOZ_ASSERT
(
mFirstResponseSource
=
=
RESPONSE_FROM_NETWORK
)
;
LOG
(
(
"
Skipping
read
from
cache
because
first
response
was
from
"
"
network
\
n
"
)
)
;
if
(
!
mOnCacheEntryCheckTimestamp
.
IsNull
(
)
)
{
TimeStamp
currentTime
=
TimeStamp
:
:
Now
(
)
;
int64_t
savedTime
=
(
currentTime
-
mOnStartRequestTimestamp
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_RACE_CACHE_WITH_NETWORK_SAVED_TIME
savedTime
)
;
int64_t
diffTime
=
(
currentTime
-
mOnCacheEntryCheckTimestamp
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_RACE_CACHE_WITH_NETWORK_OCEC_ON_START_DIFF
diffTime
)
;
}
return
NS_OK
;
}
}
if
(
mCachedResponseHead
)
mResponseHead
=
std
:
:
move
(
mCachedResponseHead
)
;
UpdateInhibitPersistentCachingFlag
(
)
;
if
(
!
mSecurityInfo
)
mSecurityInfo
=
mCachedSecurityInfo
;
if
(
!
alreadyMarkedValid
&
&
!
LoadCachedContentIsPartial
(
)
)
{
mCacheEntry
-
>
MaybeMarkValid
(
)
;
}
nsresult
rv
;
if
(
WillRedirect
(
*
mResponseHead
)
)
{
MOZ_ASSERT
(
!
mCacheInputStream
)
;
LOG
(
(
"
Skipping
skip
read
of
cached
redirect
entity
\
n
"
)
)
;
return
AsyncCall
(
&
nsHttpChannel
:
:
HandleAsyncRedirect
)
;
}
if
(
(
mLoadFlags
&
LOAD_ONLY_IF_MODIFIED
)
&
&
!
LoadCachedContentIsPartial
(
)
)
{
LOG
(
(
"
Skipping
read
from
cache
based
on
LOAD_ONLY_IF_MODIFIED
"
"
load
flag
\
n
"
)
)
;
MOZ_ASSERT
(
!
mCacheInputStream
)
;
return
AsyncCall
(
&
nsHttpChannel
:
:
HandleAsyncNotModified
)
;
}
MOZ_ASSERT
(
mCacheInputStream
)
;
if
(
!
mCacheInputStream
)
{
NS_ERROR
(
"
mCacheInputStream
is
null
but
we
'
re
expecting
to
"
"
be
able
to
read
from
it
.
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIInputStream
>
inputStream
=
mCacheInputStream
.
forget
(
)
;
rv
=
nsInputStreamPump
:
:
Create
(
getter_AddRefs
(
mCachePump
)
inputStream
0
0
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
inputStream
-
>
Close
(
)
;
return
rv
;
}
rv
=
mCachePump
-
>
AsyncRead
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
LoadTimingEnabled
(
)
)
mCacheReadStart
=
TimeStamp
:
:
Now
(
)
;
uint32_t
suspendCount
=
mSuspendCount
;
if
(
LoadAsyncResumePending
(
)
)
{
LOG
(
(
"
Suspend
(
)
'
ing
cache
pump
once
because
of
async
resume
pending
"
"
sc
=
%
u
pump
=
%
p
this
=
%
p
"
suspendCount
mCachePump
.
get
(
)
this
)
)
;
+
+
suspendCount
;
}
while
(
suspendCount
-
-
)
{
mCachePump
-
>
Suspend
(
)
;
}
return
NS_OK
;
}
void
nsHttpChannel
:
:
CloseCacheEntry
(
bool
doomOnFailure
)
{
mCacheInputStream
.
CloseAndRelease
(
)
;
if
(
!
mCacheEntry
)
return
;
LOG
(
(
"
nsHttpChannel
:
:
CloseCacheEntry
[
this
=
%
p
]
mStatus
=
%
"
PRIx32
"
CacheEntryIsWriteOnly
=
%
x
"
this
static_cast
<
uint32_t
>
(
static_cast
<
nsresult
>
(
mStatus
)
)
LoadCacheEntryIsWriteOnly
(
)
)
)
;
bool
doom
=
false
;
if
(
LoadInitedCacheEntry
(
)
)
{
MOZ_ASSERT
(
mResponseHead
"
oops
"
)
;
if
(
NS_FAILED
(
mStatus
)
&
&
doomOnFailure
&
&
LoadCacheEntryIsWriteOnly
(
)
&
&
!
mResponseHead
-
>
IsResumable
(
)
)
{
doom
=
true
;
}
}
else
if
(
LoadCacheEntryIsWriteOnly
(
)
)
{
doom
=
true
;
}
if
(
doom
)
{
LOG
(
(
"
dooming
cache
entry
!
!
"
)
)
;
mCacheEntry
-
>
AsyncDoom
(
nullptr
)
;
}
else
{
if
(
mSecurityInfo
)
mCacheEntry
-
>
SetSecurityInfo
(
mSecurityInfo
)
;
}
mCachedResponseHead
=
nullptr
;
mCachePump
=
nullptr
;
mCacheEntry
-
>
Dismiss
(
)
;
mCacheEntry
=
nullptr
;
StoreCacheEntryIsWriteOnly
(
false
)
;
StoreInitedCacheEntry
(
false
)
;
}
void
nsHttpChannel
:
:
MaybeCreateCacheEntryWhenRCWN
(
)
{
mozilla
:
:
MutexAutoLock
lock
(
mRCWNLock
)
;
if
(
mCacheEntry
|
|
!
mRaceCacheWithNetwork
|
|
mFirstResponseSource
!
=
RESPONSE_FROM_NETWORK
|
|
LoadCacheEntryIsReadOnly
(
)
)
{
return
;
}
LOG
(
(
"
nsHttpChannel
:
:
MaybeCreateCacheEntryWhenRCWN
[
this
=
%
p
]
"
this
)
)
;
nsCOMPtr
<
nsICacheStorageService
>
cacheStorageService
(
components
:
:
CacheStorage
:
:
Service
(
)
)
;
if
(
!
cacheStorageService
)
{
return
;
}
nsCOMPtr
<
nsICacheStorage
>
cacheStorage
;
RefPtr
<
LoadContextInfo
>
info
=
GetLoadContextInfo
(
this
)
;
Unused
<
<
cacheStorageService
-
>
DiskCacheStorage
(
info
getter_AddRefs
(
cacheStorage
)
)
;
if
(
!
cacheStorage
)
{
return
;
}
Unused
<
<
cacheStorage
-
>
OpenTruncate
(
mCacheEntryURI
mCacheIdExtension
getter_AddRefs
(
mCacheEntry
)
)
;
LOG
(
(
"
created
entry
%
p
"
mCacheEntry
.
get
(
)
)
)
;
if
(
AwaitingCacheCallbacks
(
)
)
{
mIgnoreCacheEntry
=
true
;
}
mAvailableCachedAltDataType
.
Truncate
(
)
;
StoreDeliveringAltData
(
false
)
;
mAltDataLength
=
-
1
;
mCacheInputStream
.
CloseAndRelease
(
)
;
mCachedContentIsValid
=
false
;
}
nsresult
nsHttpChannel
:
:
InitCacheEntry
(
)
{
nsresult
rv
;
NS_ENSURE_TRUE
(
mCacheEntry
NS_ERROR_UNEXPECTED
)
;
if
(
LoadCacheEntryIsReadOnly
(
)
)
return
NS_OK
;
if
(
mCachedContentIsValid
)
return
NS_OK
;
LOG
(
(
"
nsHttpChannel
:
:
InitCacheEntry
[
this
=
%
p
entry
=
%
p
]
\
n
"
this
mCacheEntry
.
get
(
)
)
)
;
bool
recreate
=
!
LoadCacheEntryIsWriteOnly
(
)
;
bool
dontPersist
=
mLoadFlags
&
INHIBIT_PERSISTENT_CACHING
;
if
(
!
recreate
&
&
dontPersist
)
{
rv
=
mCacheEntry
-
>
GetPersistent
(
&
recreate
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
if
(
recreate
)
{
LOG
(
(
"
we
have
a
ready
entry
but
reading
it
again
from
the
server
-
>
"
"
recreating
cache
entry
\
n
"
)
)
;
mAvailableCachedAltDataType
.
Truncate
(
)
;
StoreDeliveringAltData
(
false
)
;
nsCOMPtr
<
nsICacheEntry
>
currentEntry
;
currentEntry
.
swap
(
mCacheEntry
)
;
rv
=
currentEntry
-
>
Recreate
(
dontPersist
getter_AddRefs
(
mCacheEntry
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
recreation
failed
the
response
will
not
be
cached
"
)
)
;
return
NS_OK
;
}
StoreCacheEntryIsWriteOnly
(
true
)
;
}
rv
=
UpdateExpirationTime
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mCacheEntry
-
>
SetMetaDataElement
(
"
strongly
-
framed
"
"
0
"
)
;
rv
=
AddCacheEntryHeaders
(
mCacheEntry
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
StoreInitedCacheEntry
(
true
)
;
StoreConcurrentCacheAccess
(
0
)
;
return
NS_OK
;
}
void
nsHttpChannel
:
:
UpdateInhibitPersistentCachingFlag
(
)
{
if
(
mResponseHead
-
>
NoStore
(
)
)
mLoadFlags
|
=
INHIBIT_PERSISTENT_CACHING
;
if
(
!
gHttpHandler
-
>
IsPersistentHttpsCachingEnabled
(
)
&
&
mURI
-
>
SchemeIs
(
"
https
"
)
)
{
mLoadFlags
|
=
INHIBIT_PERSISTENT_CACHING
;
}
}
nsresult
DoAddCacheEntryHeaders
(
nsHttpChannel
*
self
nsICacheEntry
*
entry
nsHttpRequestHead
*
requestHead
nsHttpResponseHead
*
responseHead
nsISupports
*
securityInfo
)
{
nsresult
rv
;
LOG
(
(
"
nsHttpChannel
:
:
AddCacheEntryHeaders
[
this
=
%
p
]
begin
"
self
)
)
;
if
(
securityInfo
)
entry
-
>
SetSecurityInfo
(
securityInfo
)
;
nsAutoCString
method
;
requestHead
-
>
Method
(
method
)
;
rv
=
entry
-
>
SetMetaDataElement
(
"
request
-
method
"
method
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
StoreAuthorizationMetaData
(
entry
requestHead
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
{
nsAutoCString
buf
metaKey
;
Unused
<
<
responseHead
-
>
GetHeader
(
nsHttp
:
:
Vary
buf
)
;
constexpr
auto
prefix
=
"
request
-
"
_ns
;
for
(
const
nsACString
&
token
:
nsCCharSeparatedTokenizer
(
buf
NS_HTTP_HEADER_SEP
)
.
ToRange
(
)
)
{
LOG
(
(
"
nsHttpChannel
:
:
AddCacheEntryHeaders
[
this
=
%
p
]
"
"
processing
%
s
"
self
nsPromiseFlatCString
(
token
)
.
get
(
)
)
)
;
if
(
!
token
.
EqualsLiteral
(
"
*
"
)
)
{
nsHttpAtom
atom
=
nsHttp
:
:
ResolveAtom
(
token
)
;
nsAutoCString
val
;
nsAutoCString
hash
;
if
(
NS_SUCCEEDED
(
requestHead
-
>
GetHeader
(
atom
val
)
)
)
{
if
(
atom
=
=
nsHttp
:
:
Cookie
)
{
LOG
(
(
"
nsHttpChannel
:
:
AddCacheEntryHeaders
[
this
=
%
p
]
"
"
cookie
-
value
%
s
"
self
val
.
get
(
)
)
)
;
rv
=
Hash
(
val
.
get
(
)
hash
)
;
if
(
NS_FAILED
(
rv
)
)
{
val
=
"
<
hash
failed
>
"
_ns
;
}
else
{
val
=
hash
;
}
LOG
(
(
"
hashed
to
%
s
\
n
"
val
.
get
(
)
)
)
;
}
metaKey
=
prefix
+
token
;
entry
-
>
SetMetaDataElement
(
metaKey
.
get
(
)
val
.
get
(
)
)
;
}
else
{
LOG
(
(
"
nsHttpChannel
:
:
AddCacheEntryHeaders
[
this
=
%
p
]
"
"
clearing
metadata
for
%
s
"
self
nsPromiseFlatCString
(
token
)
.
get
(
)
)
)
;
metaKey
=
prefix
+
token
;
entry
-
>
SetMetaDataElement
(
metaKey
.
get
(
)
nullptr
)
;
}
}
}
}
nsAutoCString
head
;
responseHead
-
>
Flatten
(
head
true
)
;
rv
=
entry
-
>
SetMetaDataElement
(
"
response
-
head
"
head
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
head
.
Truncate
(
)
;
responseHead
-
>
FlattenNetworkOriginalHeaders
(
head
)
;
rv
=
entry
-
>
SetMetaDataElement
(
"
original
-
response
-
headers
"
head
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
entry
-
>
MetaDataReady
(
)
;
return
rv
;
}
nsresult
nsHttpChannel
:
:
AddCacheEntryHeaders
(
nsICacheEntry
*
entry
)
{
return
DoAddCacheEntryHeaders
(
this
entry
&
mRequestHead
mResponseHead
.
get
(
)
mSecurityInfo
)
;
}
inline
void
GetAuthType
(
const
char
*
challenge
nsCString
&
authType
)
{
const
char
*
p
;
if
(
(
p
=
strchr
(
challenge
'
'
)
)
!
=
nullptr
)
{
authType
.
Assign
(
challenge
p
-
challenge
)
;
}
else
{
authType
.
Assign
(
challenge
)
;
}
}
nsresult
StoreAuthorizationMetaData
(
nsICacheEntry
*
entry
nsHttpRequestHead
*
requestHead
)
{
nsAutoCString
val
;
if
(
NS_FAILED
(
requestHead
-
>
GetHeader
(
nsHttp
:
:
Authorization
val
)
)
)
{
return
NS_OK
;
}
nsAutoCString
buf
;
GetAuthType
(
val
.
get
(
)
buf
)
;
return
entry
-
>
SetMetaDataElement
(
"
auth
"
buf
.
get
(
)
)
;
}
nsresult
nsHttpChannel
:
:
FinalizeCacheEntry
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
FinalizeCacheEntry
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
LoadStronglyFramed
(
)
&
&
!
mCachedContentIsValid
&
&
mCacheEntry
)
{
LOG
(
(
"
nsHttpChannel
:
:
FinalizeCacheEntry
[
this
=
%
p
]
Is
Strongly
Framed
\
n
"
this
)
)
;
mCacheEntry
-
>
SetMetaDataElement
(
"
strongly
-
framed
"
"
1
"
)
;
}
if
(
mResponseHead
&
&
LoadResponseHeadersModified
(
)
)
{
nsresult
rv
=
UpdateExpirationTime
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
InstallCacheListener
(
int64_t
offset
)
{
nsresult
rv
;
LOG
(
(
"
Preparing
to
write
data
into
the
cache
[
uri
=
%
s
]
\
n
"
mSpec
.
get
(
)
)
)
;
MOZ_ASSERT
(
mCacheEntry
)
;
MOZ_ASSERT
(
LoadCacheEntryIsWriteOnly
(
)
|
|
LoadCachedContentIsPartial
(
)
|
|
mRaceCacheWithNetwork
)
;
MOZ_ASSERT
(
mListener
)
;
nsAutoCString
contentEncoding
contentType
;
Unused
<
<
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Content_Encoding
contentEncoding
)
;
mResponseHead
-
>
ContentType
(
contentType
)
;
if
(
contentEncoding
.
IsEmpty
(
)
&
&
(
contentType
.
EqualsLiteral
(
TEXT_HTML
)
|
|
contentType
.
EqualsLiteral
(
TEXT_PLAIN
)
|
|
contentType
.
EqualsLiteral
(
TEXT_CSS
)
|
|
contentType
.
EqualsLiteral
(
TEXT_JAVASCRIPT
)
|
|
contentType
.
EqualsLiteral
(
TEXT_ECMASCRIPT
)
|
|
contentType
.
EqualsLiteral
(
TEXT_XML
)
|
|
contentType
.
EqualsLiteral
(
APPLICATION_JAVASCRIPT
)
|
|
contentType
.
EqualsLiteral
(
APPLICATION_ECMASCRIPT
)
|
|
contentType
.
EqualsLiteral
(
APPLICATION_XJAVASCRIPT
)
|
|
contentType
.
EqualsLiteral
(
APPLICATION_XHTML_XML
)
)
)
{
rv
=
mCacheEntry
-
>
SetMetaDataElement
(
"
uncompressed
-
len
"
"
0
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
unable
to
mark
cache
entry
for
compression
"
)
)
;
}
}
LOG
(
(
"
Trading
cache
input
stream
for
output
stream
[
channel
=
%
p
]
"
this
)
)
;
mCacheInputStream
.
CloseAndRelease
(
)
;
int64_t
predictedSize
=
mResponseHead
-
>
TotalEntitySize
(
)
;
if
(
predictedSize
!
=
-
1
)
{
predictedSize
-
=
offset
;
}
nsCOMPtr
<
nsIOutputStream
>
out
;
rv
=
mCacheEntry
-
>
OpenOutputStream
(
offset
predictedSize
getter_AddRefs
(
out
)
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
LOG
(
(
"
entry
doomed
not
writing
it
[
channel
=
%
p
]
"
this
)
)
;
return
NS_OK
;
}
if
(
rv
=
=
NS_ERROR_FILE_TOO_BIG
)
{
LOG
(
(
"
entry
would
exceed
max
allowed
size
not
writing
it
[
channel
=
%
p
]
"
this
)
)
;
mCacheEntry
-
>
AsyncDoom
(
nullptr
)
;
return
NS_OK
;
}
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
LoadCacheOnlyMetadata
(
)
)
{
LOG
(
(
"
Not
storing
content
cacheOnlyMetadata
set
"
)
)
;
out
-
>
Close
(
)
;
return
NS_OK
;
}
#
if
0
rv
=
mCacheEntry
-
>
MarkValid
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
#
endif
nsCOMPtr
<
nsIStreamListenerTee
>
tee
=
do_CreateInstance
(
kStreamListenerTeeCID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
LOG
(
(
"
nsHttpChannel
:
:
InstallCacheListener
sync
tee
%
p
rv
=
%
"
PRIx32
tee
.
get
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
rv
=
tee
-
>
Init
(
mListener
out
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mListener
=
tee
;
return
NS_OK
;
}
void
nsHttpChannel
:
:
ClearBogusContentEncodingIfNeeded
(
)
{
if
(
!
StaticPrefs
:
:
network_http_clear_bogus_content_encoding
(
)
)
{
return
;
}
nsAutoCString
contentType
;
mResponseHead
-
>
ContentType
(
contentType
)
;
if
(
mResponseHead
-
>
HasHeaderValue
(
nsHttp
:
:
Content_Encoding
"
gzip
"
)
&
&
(
contentType
.
EqualsLiteral
(
APPLICATION_GZIP
)
|
|
contentType
.
EqualsLiteral
(
APPLICATION_GZIP2
)
|
|
contentType
.
EqualsLiteral
(
APPLICATION_GZIP3
)
)
)
{
mResponseHead
-
>
ClearHeader
(
nsHttp
:
:
Content_Encoding
)
;
}
else
if
(
mResponseHead
-
>
HasHeaderValue
(
nsHttp
:
:
Content_Encoding
"
compress
"
)
&
&
(
contentType
.
EqualsLiteral
(
APPLICATION_COMPRESS
)
|
|
contentType
.
EqualsLiteral
(
APPLICATION_COMPRESS2
)
)
)
{
mResponseHead
-
>
ClearHeader
(
nsHttp
:
:
Content_Encoding
)
;
}
}
nsresult
nsHttpChannel
:
:
SetupReplacementChannel
(
nsIURI
*
newURI
nsIChannel
*
newChannel
bool
preserveMethod
uint32_t
redirectFlags
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetupReplacementChannel
"
"
[
this
=
%
p
newChannel
=
%
p
preserveMethod
=
%
d
]
"
this
newChannel
preserveMethod
)
)
;
if
(
!
mEndMarkerAdded
&
&
profiler_thread_is_being_profiled_for_markers
(
)
)
{
mEndMarkerAdded
=
true
;
nsAutoCString
requestMethod
;
GetRequestMethod
(
requestMethod
)
;
int32_t
priority
=
PRIORITY_NORMAL
;
GetPriority
(
&
priority
)
;
TimingStruct
timings
;
if
(
mTransaction
)
{
timings
=
mTransaction
-
>
Timings
(
)
;
}
uint64_t
size
=
0
;
GetEncodedBodySize
(
&
size
)
;
nsAutoCString
contentType
;
if
(
mResponseHead
)
{
mResponseHead
-
>
ContentType
(
contentType
)
;
}
RefPtr
<
nsIIdentChannel
>
newIdentChannel
=
do_QueryObject
(
newChannel
)
;
uint64_t
channelId
=
0
;
if
(
newIdentChannel
)
{
channelId
=
newIdentChannel
-
>
ChannelId
(
)
;
}
profiler_add_network_marker
(
mURI
requestMethod
priority
mChannelId
NetworkLoadType
:
:
LOAD_REDIRECT
mLastStatusReported
TimeStamp
:
:
Now
(
)
size
mCacheDisposition
mLoadInfo
-
>
GetInnerWindowID
(
)
mLoadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
>
0
&
timings
std
:
:
move
(
mSource
)
Some
(
nsDependentCString
(
contentType
.
get
(
)
)
)
newURI
redirectFlags
channelId
)
;
}
nsresult
rv
=
HttpBaseChannel
:
:
SetupReplacementChannel
(
newURI
newChannel
preserveMethod
redirectFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
CheckRedirectLimit
(
redirectFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
newLoadInfo
=
newChannel
-
>
LoadInfo
(
)
;
nsHTTPSOnlyUtils
:
:
PotentiallyClearExemptFlag
(
newLoadInfo
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
newChannel
)
;
if
(
!
httpChannel
)
return
NS_OK
;
nsCOMPtr
<
nsIEncodedChannel
>
encodedChannel
=
do_QueryInterface
(
httpChannel
)
;
if
(
encodedChannel
)
encodedChannel
-
>
SetApplyConversion
(
LoadApplyConversion
(
)
)
;
if
(
LoadResuming
(
)
)
{
nsCOMPtr
<
nsIResumableChannel
>
resumableChannel
(
do_QueryInterface
(
newChannel
)
)
;
if
(
!
resumableChannel
)
{
NS_WARNING
(
"
Got
asked
to
resume
but
redirected
to
non
-
resumable
channel
!
"
)
;
return
NS_ERROR_NOT_RESUMABLE
;
}
resumableChannel
-
>
ResumeAt
(
mStartPos
mEntityID
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
newChannel
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
TimeStamp
timestamp
;
rv
=
GetNavigationStartTimeStamp
(
&
timestamp
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
timestamp
)
{
Unused
<
<
internalChannel
-
>
SetNavigationStartTimeStamp
(
timestamp
)
;
}
}
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
AsyncProcessRedirection
(
uint32_t
redirectType
)
{
LOG
(
(
"
nsHttpChannel
:
:
AsyncProcessRedirection
[
this
=
%
p
type
=
%
u
]
\
n
"
this
redirectType
)
)
;
nsresult
rv
=
ProcessCrossOriginSecurityHeaders
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mStatus
=
rv
;
HandleAsyncAbort
(
)
;
return
rv
;
}
nsAutoCString
location
;
if
(
NS_FAILED
(
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Location
location
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mLoadInfo
-
>
GetDontFollowRedirects
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
locationBuf
;
if
(
NS_EscapeURL
(
location
.
get
(
)
-
1
esc_OnlyNonASCII
|
esc_Spaces
locationBuf
)
)
{
location
=
locationBuf
;
}
mRedirectType
=
redirectType
;
LOG
(
(
"
redirecting
to
:
%
s
[
redirection
-
limit
=
%
u
]
\
n
"
location
.
get
(
)
uint32_t
(
mRedirectionLimit
)
)
)
;
rv
=
CreateNewURI
(
location
.
get
(
)
getter_AddRefs
(
mRedirectURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Invalid
URI
for
redirect
:
Location
:
%
s
\
n
"
location
.
get
(
)
)
)
;
return
NS_ERROR_CORRUPTED_CONTENT
;
}
if
(
StaticPrefs
:
:
privacy_query_stripping_redirect
(
)
)
{
ThirdPartyUtil
*
thirdPartyUtil
=
ThirdPartyUtil
:
:
GetInstance
(
)
;
bool
isThirdPartyRedirectURI
=
true
;
thirdPartyUtil
-
>
IsThirdPartyURI
(
mURI
mRedirectURI
&
isThirdPartyRedirectURI
)
;
if
(
isThirdPartyRedirectURI
&
&
mLoadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
ExtContentPolicy
:
:
TYPE_DOCUMENT
)
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_QUERY_STRIPPING_COUNT
:
:
Redirect
)
;
nsCOMPtr
<
nsIPrincipal
>
prin
;
ContentBlockingAllowList
:
:
RecomputePrincipal
(
mRedirectURI
mLoadInfo
-
>
GetOriginAttributes
(
)
getter_AddRefs
(
prin
)
)
;
bool
isRedirectURIInAllowList
=
false
;
if
(
prin
)
{
ContentBlockingAllowList
:
:
Check
(
prin
mPrivateBrowsing
isRedirectURIInAllowList
)
;
}
if
(
!
isRedirectURIInAllowList
)
{
nsCOMPtr
<
nsIURI
>
strippedURI
;
uint32_t
numStripped
=
URLQueryStringStripper
:
:
Strip
(
mRedirectURI
mPrivateBrowsing
strippedURI
)
;
if
(
numStripped
)
{
mUnstrippedRedirectURI
=
mRedirectURI
;
mRedirectURI
=
strippedURI
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_QUERY_STRIPPING_COUNT
:
:
StripForRedirect
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
QUERY_STRIPPING_PARAM_COUNT
numStripped
)
;
}
}
}
}
if
(
NS_WARN_IF
(
!
mRedirectURI
)
)
{
LOG
(
(
"
Invalid
redirect
URI
after
performaing
query
string
stripping
"
)
)
;
return
NS_ERROR_FAILURE
;
}
return
ContinueProcessRedirectionAfterFallback
(
NS_OK
)
;
}
nsresult
nsHttpChannel
:
:
ContinueProcessRedirectionAfterFallback
(
nsresult
rv
)
{
bool
redirectingBackToSameURI
=
false
;
if
(
mCacheEntry
&
&
LoadCacheEntryIsWriteOnly
(
)
&
&
NS_SUCCEEDED
(
mURI
-
>
Equals
(
mRedirectURI
&
redirectingBackToSameURI
)
)
&
&
redirectingBackToSameURI
)
{
mCacheEntry
-
>
AsyncDoom
(
nullptr
)
;
}
PropagateReferenceIfNeeded
(
mURI
mRedirectURI
)
;
bool
rewriteToGET
=
ShouldRewriteRedirectToGET
(
mRedirectType
mRequestHead
.
ParsedMethod
(
)
)
;
if
(
!
rewriteToGET
&
&
!
mRequestHead
.
IsSafeMethod
(
)
)
{
rv
=
PromptTempRedirect
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
uint32_t
redirectFlags
;
if
(
nsHttp
:
:
IsPermanentRedirect
(
mRedirectType
)
)
{
redirectFlags
=
nsIChannelEventSink
:
:
REDIRECT_PERMANENT
;
}
else
{
redirectFlags
=
nsIChannelEventSink
:
:
REDIRECT_TEMPORARY
;
}
nsCOMPtr
<
nsIIOService
>
ioService
;
rv
=
gHttpHandler
-
>
GetIOService
(
getter_AddRefs
(
ioService
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIChannel
>
newChannel
;
nsCOMPtr
<
nsILoadInfo
>
redirectLoadInfo
=
CloneLoadInfoForRedirect
(
mRedirectURI
redirectFlags
)
;
redirectLoadInfo
-
>
SetUnstrippedURI
(
mUnstrippedRedirectURI
)
;
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
newChannel
)
mRedirectURI
redirectLoadInfo
nullptr
nullptr
nullptr
nsIRequest
:
:
LOAD_NORMAL
ioService
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupReplacementChannel
(
mRedirectURI
newChannel
!
rewriteToGET
redirectFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mRedirectChannel
=
newChannel
;
PushRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueProcessRedirection
)
;
rv
=
gHttpHandler
-
>
AsyncOnChannelRedirect
(
this
newChannel
redirectFlags
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
WaitForRedirectCallback
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
AutoRedirectVetoNotifier
notifier
(
this
)
;
PopRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueProcessRedirection
)
;
}
return
rv
;
}
nsresult
nsHttpChannel
:
:
ContinueProcessRedirection
(
nsresult
rv
)
{
AutoRedirectVetoNotifier
notifier
(
this
)
;
LOG
(
(
"
nsHttpChannel
:
:
ContinueProcessRedirection
[
rv
=
%
"
PRIx32
"
this
=
%
p
]
\
n
"
static_cast
<
uint32_t
>
(
rv
)
this
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
MOZ_ASSERT
(
mRedirectChannel
"
No
redirect
channel
?
"
)
;
mRedirectChannel
-
>
SetOriginalURI
(
mOriginalURI
)
;
rv
=
mRedirectChannel
-
>
AsyncOpen
(
mListener
)
;
LOG
(
(
"
new
channel
AsyncOpen
returned
%
"
PRIX32
static_cast
<
uint32_t
>
(
rv
)
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Cancel
(
NS_BINDING_REDIRECTED
)
;
notifier
.
RedirectSucceeded
(
)
;
ReleaseListeners
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnAuthAvailable
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
OnAuthAvailable
[
this
=
%
p
]
"
this
)
)
;
mIsAuthChannel
=
true
;
mAuthRetryPending
=
true
;
StoreProxyAuthPending
(
false
)
;
LOG
(
(
"
Resuming
the
transaction
we
got
credentials
from
user
"
)
)
;
if
(
mTransactionPump
)
{
mTransactionPump
-
>
Resume
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnAuthCancelled
(
bool
userCancel
)
{
LOG
(
(
"
nsHttpChannel
:
:
OnAuthCancelled
[
this
=
%
p
]
"
this
)
)
;
if
(
mTransactionPump
)
{
if
(
LoadProxyAuthPending
(
)
)
Cancel
(
NS_ERROR_PROXY_CONNECTION_REFUSED
)
;
nsresult
rv
=
CallOnStartRequest
(
)
;
mAuthRetryPending
=
false
;
LOG
(
(
"
Resuming
the
transaction
user
cancelled
the
auth
dialog
"
)
)
;
mTransactionPump
-
>
Resume
(
)
;
if
(
NS_FAILED
(
rv
)
)
mTransactionPump
-
>
Cancel
(
rv
)
;
}
StoreProxyAuthPending
(
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
CloseStickyConnection
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
CloseStickyConnection
this
=
%
p
"
this
)
)
;
if
(
!
LoadIsPending
(
)
)
{
LOG
(
(
"
channel
not
pending
"
)
)
;
NS_ERROR
(
"
CloseStickyConnection
not
called
before
OnStopRequest
won
'
t
have
any
"
"
effect
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
mTransaction
)
;
if
(
!
mTransaction
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
(
mCaps
&
NS_HTTP_STICKY_CONNECTION
|
|
mTransaction
-
>
HasStickyConnection
(
)
)
)
{
LOG
(
(
"
not
sticky
"
)
)
;
return
NS_OK
;
}
mTransaction
-
>
DontReuseConnection
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
ConnectionRestartable
(
bool
aRestartable
)
{
LOG
(
(
"
nsHttpChannel
:
:
ConnectionRestartable
this
=
%
p
restartable
=
%
d
"
this
aRestartable
)
)
;
StoreAuthConnectionRestartable
(
aRestartable
)
;
return
NS_OK
;
}
NS_IMPL_ADDREF_INHERITED
(
nsHttpChannel
HttpBaseChannel
)
NS_IMPL_RELEASE_INHERITED
(
nsHttpChannel
HttpBaseChannel
)
NS_INTERFACE_MAP_BEGIN
(
nsHttpChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequest
)
NS_INTERFACE_MAP_ENTRY
(
nsIChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIHttpChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsICacheInfoChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsICachingChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIClassOfService
)
NS_INTERFACE_MAP_ENTRY
(
nsIUploadChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIFormPOSTActionChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIUploadChannel2
)
NS_INTERFACE_MAP_ENTRY
(
nsICacheEntryOpenCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsIHttpChannelInternal
)
NS_INTERFACE_MAP_ENTRY
(
nsIResumableChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsITransportEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsPriority
)
NS_INTERFACE_MAP_ENTRY
(
nsIProtocolProxyCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsIProxiedChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIHttpAuthenticableChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIAsyncVerifyRedirectCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsIThreadRetargetableRequest
)
NS_INTERFACE_MAP_ENTRY
(
nsIThreadRetargetableStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIDNSListener
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsICorsPreflightCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsIRaceCacheWithNetwork
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestTailUnblockCallback
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
nsHttpChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIEarlyHintObserver
)
NS_INTERFACE_MAP_END_INHERITING
(
HttpBaseChannel
)
NS_IMETHODIMP
nsHttpChannel
:
:
Cancel
(
nsresult
status
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT_IF
(
mPreflightChannel
!
mCachePump
)
;
#
ifdef
DEBUG
if
(
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
status
)
&
&
!
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
mStatus
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Blocking
classifier
error
%
"
PRIx32
"
need
to
be
handled
by
CancelByURLClassifier
(
)
"
static_cast
<
uint32_t
>
(
status
)
)
;
}
#
endif
LOG
(
(
"
nsHttpChannel
:
:
Cancel
[
this
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
status
)
)
)
;
MOZ_ASSERT_IF
(
!
(
mConnectionInfo
&
&
mConnectionInfo
-
>
UsingConnect
(
)
)
&
&
NS_SUCCEEDED
(
mStatus
)
!
AllowedErrorForHTTPSRRFallback
(
status
)
)
;
mEarlyHintObserver
=
nullptr
;
if
(
mCanceled
)
{
LOG
(
(
"
ignoring
;
already
canceled
\
n
"
)
)
;
return
NS_OK
;
}
LogCallingScriptLocation
(
this
)
;
if
(
LoadWaitingForRedirectCallback
(
)
)
{
LOG
(
(
"
channel
canceled
during
wait
for
redirect
callback
"
)
)
;
}
return
CancelInternal
(
status
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
CancelByURLClassifier
(
nsresult
aErrorCode
)
{
MOZ_ASSERT
(
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aErrorCode
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT_IF
(
mPreflightChannel
!
mCachePump
)
;
LOG
(
(
"
nsHttpChannel
:
:
CancelByURLClassifier
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mCanceled
)
{
LOG
(
(
"
ignoring
;
already
canceled
\
n
"
)
)
;
return
NS_OK
;
}
CallOnModifyRequestObservers
(
)
;
if
(
mCanceled
)
{
return
mStatus
;
}
if
(
mSuspendCount
)
{
LOG
(
(
"
Waiting
until
resume
in
Cancel
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
!
mCallOnResume
)
;
StoreChannelClassifierCancellationPending
(
1
)
;
mCallOnResume
=
[
aErrorCode
]
(
nsHttpChannel
*
self
)
{
self
-
>
HandleContinueCancellingByURLClassifier
(
aErrorCode
)
;
return
NS_OK
;
}
;
return
NS_OK
;
}
if
(
mAPIRedirectToURI
)
{
StoreChannelClassifierCancellationPending
(
1
)
;
return
AsyncCall
(
&
nsHttpChannel
:
:
HandleAsyncAPIRedirect
)
;
}
return
CancelInternal
(
aErrorCode
)
;
}
void
nsHttpChannel
:
:
ContinueCancellingByURLClassifier
(
nsresult
aErrorCode
)
{
MOZ_ASSERT
(
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aErrorCode
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT_IF
(
mPreflightChannel
!
mCachePump
)
;
LOG
(
(
"
nsHttpChannel
:
:
ContinueCancellingByURLClassifier
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mCanceled
)
{
LOG
(
(
"
ignoring
;
already
canceled
\
n
"
)
)
;
return
;
}
if
(
mAPIRedirectToURI
)
{
Unused
<
<
AsyncCall
(
&
nsHttpChannel
:
:
HandleAsyncAPIRedirect
)
;
return
;
}
Unused
<
<
CancelInternal
(
aErrorCode
)
;
}
nsresult
nsHttpChannel
:
:
CancelInternal
(
nsresult
status
)
{
LOG
(
(
"
nsHttpChannel
:
:
CancelInternal
[
this
=
%
p
]
\
n
"
this
)
)
;
bool
channelClassifierCancellationPending
=
!
!
LoadChannelClassifierCancellationPending
(
)
;
if
(
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
status
)
)
{
StoreChannelClassifierCancellationPending
(
0
)
;
}
mEarlyHintObserver
=
nullptr
;
mCanceled
=
true
;
mStatus
=
NS_FAILED
(
status
)
?
status
:
NS_ERROR_ABORT
;
if
(
mLastStatusReported
&
&
!
mEndMarkerAdded
&
&
profiler_thread_is_being_profiled_for_markers
(
)
)
{
mEndMarkerAdded
=
true
;
nsAutoCString
requestMethod
;
GetRequestMethod
(
requestMethod
)
;
int32_t
priority
=
PRIORITY_NORMAL
;
GetPriority
(
&
priority
)
;
uint64_t
size
=
0
;
GetEncodedBodySize
(
&
size
)
;
profiler_add_network_marker
(
mURI
requestMethod
priority
mChannelId
NetworkLoadType
:
:
LOAD_CANCEL
mLastStatusReported
TimeStamp
:
:
Now
(
)
size
mCacheDisposition
mLoadInfo
-
>
GetInnerWindowID
(
)
mLoadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
>
0
&
mTransactionTimings
std
:
:
move
(
mSource
)
)
;
}
if
(
mProxyRequest
)
mProxyRequest
-
>
Cancel
(
status
)
;
CancelNetworkRequest
(
status
)
;
mCacheInputStream
.
CloseAndRelease
(
)
;
if
(
mCachePump
)
mCachePump
-
>
Cancel
(
status
)
;
if
(
mAuthProvider
)
mAuthProvider
-
>
Cancel
(
status
)
;
if
(
mPreflightChannel
)
mPreflightChannel
-
>
Cancel
(
status
)
;
if
(
mRequestContext
&
&
mOnTailUnblock
)
{
mOnTailUnblock
=
nullptr
;
mRequestContext
-
>
CancelTailedRequest
(
this
)
;
CloseCacheEntry
(
false
)
;
Unused
<
<
AsyncAbort
(
status
)
;
}
else
if
(
channelClassifierCancellationPending
)
{
Unused
<
<
AsyncAbort
(
status
)
;
}
return
NS_OK
;
}
void
nsHttpChannel
:
:
CancelNetworkRequest
(
nsresult
aStatus
)
{
if
(
mTransaction
)
{
nsresult
rv
=
gHttpHandler
-
>
CancelTransaction
(
mTransaction
aStatus
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
failed
to
cancel
the
transaction
\
n
"
)
)
;
}
}
if
(
mTransactionPump
)
mTransactionPump
-
>
Cancel
(
aStatus
)
;
mEarlyHintObserver
=
nullptr
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
Suspend
(
)
{
NS_ENSURE_TRUE
(
LoadIsPending
(
)
NS_ERROR_NOT_AVAILABLE
)
;
LOG
(
(
"
nsHttpChannel
:
:
SuspendInternal
[
this
=
%
p
]
\
n
"
this
)
)
;
LogCallingScriptLocation
(
this
)
;
+
+
mSuspendCount
;
if
(
mSuspendCount
=
=
1
)
{
mSuspendTimestamp
=
TimeStamp
:
:
NowLoRes
(
)
;
}
nsresult
rvTransaction
=
NS_OK
;
if
(
mTransactionPump
)
{
rvTransaction
=
mTransactionPump
-
>
Suspend
(
)
;
}
nsresult
rvCache
=
NS_OK
;
if
(
mCachePump
)
{
rvCache
=
mCachePump
-
>
Suspend
(
)
;
}
return
NS_FAILED
(
rvTransaction
)
?
rvTransaction
:
rvCache
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
Resume
(
)
{
NS_ENSURE_TRUE
(
mSuspendCount
>
0
NS_ERROR_UNEXPECTED
)
;
LOG
(
(
"
nsHttpChannel
:
:
ResumeInternal
[
this
=
%
p
]
\
n
"
this
)
)
;
LogCallingScriptLocation
(
this
)
;
if
(
-
-
mSuspendCount
=
=
0
)
{
mSuspendTotalTime
+
=
(
TimeStamp
:
:
NowLoRes
(
)
-
mSuspendTimestamp
)
.
ToMilliseconds
(
)
;
if
(
mCallOnResume
)
{
MOZ_ASSERT
(
!
LoadAsyncResumePending
(
)
)
;
StoreAsyncResumePending
(
1
)
;
std
:
:
function
<
nsresult
(
nsHttpChannel
*
)
>
callOnResume
=
nullptr
;
std
:
:
swap
(
callOnResume
mCallOnResume
)
;
RefPtr
<
nsHttpChannel
>
self
(
this
)
;
nsCOMPtr
<
nsIRequest
>
transactionPump
=
mTransactionPump
;
RefPtr
<
nsInputStreamPump
>
cachePump
=
mCachePump
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
"
nsHttpChannel
:
:
CallOnResume
"
[
callOnResume
{
std
:
:
move
(
callOnResume
)
}
self
{
std
:
:
move
(
self
)
}
transactionPump
{
std
:
:
move
(
transactionPump
)
}
cachePump
{
std
:
:
move
(
cachePump
)
}
]
(
)
{
MOZ_ASSERT
(
self
-
>
LoadAsyncResumePending
(
)
)
;
nsresult
rv
=
self
-
>
CallOrWaitForResume
(
callOnResume
)
;
if
(
NS_FAILED
(
rv
)
)
{
self
-
>
CloseCacheEntry
(
false
)
;
Unused
<
<
self
-
>
AsyncAbort
(
rv
)
;
}
MOZ_ASSERT
(
self
-
>
LoadAsyncResumePending
(
)
)
;
self
-
>
StoreAsyncResumePending
(
0
)
;
if
(
transactionPump
)
{
LOG
(
(
"
nsHttpChannel
:
:
CallOnResume
resuming
previous
transaction
"
"
pump
%
p
this
=
%
p
"
transactionPump
.
get
(
)
self
.
get
(
)
)
)
;
transactionPump
-
>
Resume
(
)
;
}
if
(
cachePump
)
{
LOG
(
(
"
nsHttpChannel
:
:
CallOnResume
resuming
previous
cache
pump
"
"
%
p
this
=
%
p
"
cachePump
.
get
(
)
self
.
get
(
)
)
)
;
cachePump
-
>
Resume
(
)
;
}
if
(
transactionPump
!
=
self
-
>
mTransactionPump
&
&
self
-
>
mTransactionPump
)
{
LOG
(
(
"
nsHttpChannel
:
:
CallOnResume
async
-
resuming
new
"
"
transaction
"
"
pump
%
p
this
=
%
p
"
self
-
>
mTransactionPump
.
get
(
)
self
.
get
(
)
)
)
;
nsCOMPtr
<
nsIRequest
>
pump
=
self
-
>
mTransactionPump
;
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
"
nsHttpChannel
:
:
CallOnResume
new
transaction
"
[
pump
{
std
:
:
move
(
pump
)
}
]
(
)
{
pump
-
>
Resume
(
)
;
}
)
)
;
}
if
(
cachePump
!
=
self
-
>
mCachePump
&
&
self
-
>
mCachePump
)
{
LOG
(
(
"
nsHttpChannel
:
:
CallOnResume
async
-
resuming
new
cache
pump
"
"
%
p
this
=
%
p
"
self
-
>
mCachePump
.
get
(
)
self
.
get
(
)
)
)
;
RefPtr
<
nsInputStreamPump
>
pump
=
self
-
>
mCachePump
;
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
"
nsHttpChannel
:
:
CallOnResume
new
pump
"
[
pump
{
std
:
:
move
(
pump
)
}
]
(
)
{
pump
-
>
Resume
(
)
;
}
)
)
;
}
}
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
}
nsresult
rvTransaction
=
NS_OK
;
if
(
mTransactionPump
)
{
rvTransaction
=
mTransactionPump
-
>
Resume
(
)
;
}
nsresult
rvCache
=
NS_OK
;
if
(
mCachePump
)
{
rvCache
=
mCachePump
-
>
Resume
(
)
;
}
return
NS_FAILED
(
rvTransaction
)
?
rvTransaction
:
rvCache
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetSecurityInfo
(
nsISupports
*
*
securityInfo
)
{
NS_ENSURE_ARG_POINTER
(
securityInfo
)
;
*
securityInfo
=
do_AddRef
(
mSecurityInfo
)
.
take
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
AsyncOpen
(
nsIStreamListener
*
aListener
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
=
aListener
;
nsresult
rv
=
nsContentSecurityManager
:
:
doContentSecurityCheck
(
this
listener
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ReleaseListeners
(
)
;
return
rv
;
}
MOZ_ASSERT
(
mLoadInfo
-
>
GetSecurityMode
(
)
=
=
0
|
|
mLoadInfo
-
>
GetInitialSecurityCheckDone
(
)
|
|
(
mLoadInfo
-
>
GetSecurityMode
(
)
=
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
&
&
mLoadInfo
-
>
GetLoadingPrincipal
(
)
&
&
mLoadInfo
-
>
GetLoadingPrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
"
security
flags
in
loadInfo
but
doContentSecurityCheck
(
)
not
called
"
)
;
LOG
(
(
"
nsHttpChannel
:
:
AsyncOpen
[
this
=
%
p
]
\
n
"
this
)
)
;
mOpenerCallingScriptLocation
=
CallingScriptLocationString
(
)
;
LogCallingScriptLocation
(
this
mOpenerCallingScriptLocation
)
;
NS_CompareLoadInfoAndLoadContext
(
this
)
;
#
ifdef
DEBUG
AssertPrivateBrowsingId
(
)
;
#
endif
NS_ENSURE_ARG_POINTER
(
listener
)
;
NS_ENSURE_TRUE
(
!
LoadIsPending
(
)
NS_ERROR_IN_PROGRESS
)
;
NS_ENSURE_TRUE
(
!
LoadWasOpened
(
)
NS_ERROR_ALREADY_OPENED
)
;
if
(
mCanceled
)
{
ReleaseListeners
(
)
;
return
NS_FAILED
(
mStatus
)
?
mStatus
:
NS_ERROR_FAILURE
;
}
if
(
MaybeWaitForUploadStreamNormalization
(
listener
nullptr
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gHttpHandler
-
>
Active
(
)
)
{
LOG
(
(
"
after
HTTP
shutdown
.
.
.
"
)
)
;
ReleaseListeners
(
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
rv
=
NS_CheckPortSafety
(
mURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReleaseListeners
(
)
;
return
rv
;
}
UpdatePrivateBrowsing
(
)
;
AntiTrackingUtils
:
:
UpdateAntiTrackingInfoForChannel
(
this
)
;
if
(
WaitingForTailUnblock
(
)
)
{
mListener
=
listener
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mOnTailUnblock
)
;
mOnTailUnblock
=
&
nsHttpChannel
:
:
AsyncOpenOnTailUnblock
;
LOG
(
(
"
put
on
hold
until
tail
is
unblocked
"
)
)
;
return
NS_OK
;
}
nsAutoCString
cookieHeader
;
if
(
NS_SUCCEEDED
(
mRequestHead
.
GetHeader
(
nsHttp
:
:
Cookie
cookieHeader
)
)
)
{
mUserSetCookieHeader
=
cookieHeader
;
}
HttpBaseChannel
:
:
SetDocshellUserAgentOverride
(
)
;
if
(
!
(
mLoadFlags
&
LOAD_REPLACE
)
)
{
gHttpHandler
-
>
OnOpeningRequest
(
this
)
;
}
StoreIsPending
(
true
)
;
StoreWasOpened
(
true
)
;
mListener
=
listener
;
if
(
nsIOService
:
:
UseSocketProcess
(
)
&
&
!
gIOService
-
>
IsSocketProcessLaunchComplete
(
)
)
{
RefPtr
<
nsHttpChannel
>
self
=
this
;
gIOService
-
>
CallOrWaitForSocketProcess
(
[
self
]
(
)
{
self
-
>
AsyncOpenFinal
(
TimeStamp
:
:
Now
(
)
)
;
}
)
;
return
NS_OK
;
}
AsyncOpenFinal
(
TimeStamp
:
:
Now
(
)
)
;
return
NS_OK
;
}
void
nsHttpChannel
:
:
AsyncOpenFinal
(
TimeStamp
aTimeStamp
)
{
mLastStatusReported
=
TimeStamp
:
:
Now
(
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsAutoCString
requestMethod
;
GetRequestMethod
(
requestMethod
)
;
profiler_add_network_marker
(
mURI
requestMethod
mPriority
mChannelId
NetworkLoadType
:
:
LOAD_START
mChannelCreationTimestamp
mLastStatusReported
0
mCacheDisposition
mLoadInfo
-
>
GetInnerWindowID
(
)
mLoadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
>
0
)
;
}
if
(
mLoadGroup
)
mLoadGroup
-
>
AddRequest
(
this
nullptr
)
;
if
(
!
LoadAsyncOpenTimeOverriden
(
)
)
{
mAsyncOpenTime
=
aTimeStamp
;
}
StoreCustomAuthHeader
(
mRequestHead
.
HasHeader
(
nsHttp
:
:
Authorization
)
)
;
bool
willCallback
=
false
;
if
(
NS_ShouldClassifyChannel
(
this
)
)
{
RefPtr
<
nsHttpChannel
>
self
=
this
;
willCallback
=
NS_SUCCEEDED
(
AsyncUrlChannelClassifier
:
:
CheckChannel
(
this
[
self
]
(
)
-
>
void
{
nsCOMPtr
<
nsIURI
>
uri
;
self
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
MOZ_ASSERT
(
uri
)
;
FinishAntiTrackingRedirectHeuristic
(
self
uri
)
;
self
-
>
MaybeResolveProxyAndBeginConnect
(
)
;
}
)
)
;
}
if
(
!
willCallback
)
{
MaybeResolveProxyAndBeginConnect
(
)
;
}
}
void
nsHttpChannel
:
:
MaybeResolveProxyAndBeginConnect
(
)
{
nsresult
rv
;
if
(
!
mProxyInfo
&
&
!
(
mLoadFlags
&
(
LOAD_ONLY_FROM_CACHE
|
LOAD_NO_NETWORK_IO
)
)
&
&
!
BypassProxy
(
)
&
&
NS_SUCCEEDED
(
ResolveProxy
(
)
)
)
{
return
;
}
rv
=
BeginConnect
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
CloseCacheEntry
(
false
)
;
Unused
<
<
AsyncAbort
(
rv
)
;
}
}
nsresult
nsHttpChannel
:
:
AsyncOpenOnTailUnblock
(
)
{
return
AsyncOpen
(
mListener
)
;
}
already_AddRefed
<
nsChannelClassifier
>
nsHttpChannel
:
:
GetOrCreateChannelClassifier
(
)
{
if
(
!
mChannelClassifier
)
{
mChannelClassifier
=
new
nsChannelClassifier
(
this
)
;
LOG
(
(
"
nsHttpChannel
[
%
p
]
created
nsChannelClassifier
[
%
p
]
\
n
"
this
mChannelClassifier
.
get
(
)
)
)
;
}
RefPtr
<
nsChannelClassifier
>
classifier
=
mChannelClassifier
;
return
classifier
.
forget
(
)
;
}
uint16_t
nsHttpChannel
:
:
GetProxyDNSStrategy
(
)
{
if
(
!
mProxyInfo
)
{
return
DNS_PREFETCH_ORIGIN
;
}
nsAutoCString
type
;
mProxyInfo
-
>
GetType
(
type
)
;
if
(
!
StaticPrefs
:
:
network_proxy_socks_remote_dns
(
)
)
{
if
(
type
.
EqualsLiteral
(
"
socks
"
)
)
{
return
DNS_PREFETCH_ORIGIN
;
}
}
return
0
;
}
nsresult
nsHttpChannel
:
:
BeginConnect
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
BeginConnect
[
this
=
%
p
]
\
n
"
this
)
)
;
nsresult
rv
;
nsAutoCString
host
;
nsAutoCString
scheme
;
int32_t
port
=
-
1
;
bool
isHttps
=
mURI
-
>
SchemeIs
(
"
https
"
)
;
rv
=
mURI
-
>
GetScheme
(
scheme
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
mURI
-
>
GetAsciiHost
(
host
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
mURI
-
>
GetPort
(
&
port
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
mURI
-
>
GetAsciiSpec
(
mSpec
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
mURI
-
>
GetUsername
(
mUsername
)
)
)
;
if
(
host
.
IsEmpty
(
)
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
return
rv
;
}
LOG
(
(
"
host
=
%
s
port
=
%
d
\
n
"
host
.
get
(
)
port
)
)
;
LOG
(
(
"
uri
=
%
s
\
n
"
mSpec
.
get
(
)
)
)
;
nsCOMPtr
<
nsProxyInfo
>
proxyInfo
;
if
(
mProxyInfo
)
proxyInfo
=
do_QueryInterface
(
mProxyInfo
)
;
if
(
mCaps
&
NS_HTTP_CONNECT_ONLY
)
{
if
(
!
proxyInfo
)
{
LOG
(
(
"
return
failure
:
no
proxy
for
connect
-
only
channel
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
proxyInfo
-
>
IsHTTP
(
)
&
&
!
proxyInfo
-
>
IsHTTPS
(
)
)
{
LOG
(
(
"
return
failure
:
non
-
http
proxy
for
connect
-
only
channel
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
}
mRequestHead
.
SetHTTPS
(
isHttps
)
;
mRequestHead
.
SetOrigin
(
scheme
host
port
)
;
SetOriginHeader
(
)
;
SetDoNotTrack
(
)
;
SetGlobalPrivacyControl
(
)
;
OriginAttributes
originAttributes
;
if
(
proxyInfo
&
&
!
StaticPrefs
:
:
privacy_partition_network_state_connection_with_proxy
(
)
)
{
StoragePrincipalHelper
:
:
GetOriginAttributes
(
this
originAttributes
StoragePrincipalHelper
:
:
eRegularPrincipal
)
;
}
else
{
StoragePrincipalHelper
:
:
GetOriginAttributesForNetworkState
(
this
originAttributes
)
;
}
if
(
mRequestHead
.
HasHeaderValue
(
nsHttp
:
:
Connection
"
close
"
)
)
{
mCaps
&
=
~
(
NS_HTTP_ALLOW_KEEPALIVE
)
;
StoreAllowHttp3
(
false
)
;
}
gHttpHandler
-
>
MaybeAddAltSvcForTesting
(
mURI
mUsername
mPrivateBrowsing
mCallbacks
originAttributes
)
;
RefPtr
<
nsHttpConnectionInfo
>
connInfo
;
#
ifdef
FUZZING
if
(
StaticPrefs
:
:
fuzzing_necko_http3
(
)
)
{
connInfo
=
new
nsHttpConnectionInfo
(
host
port
"
h3
"
_ns
mUsername
proxyInfo
originAttributes
host
port
true
)
;
}
else
{
#
endif
connInfo
=
new
nsHttpConnectionInfo
(
host
port
"
"
_ns
mUsername
proxyInfo
originAttributes
isHttps
)
;
#
ifdef
FUZZING
}
#
endif
bool
http2Allowed
=
!
gHttpHandler
-
>
IsHttp2Excluded
(
connInfo
)
;
bool
http3Allowed
=
Http3Allowed
(
)
;
if
(
!
http3Allowed
)
{
mCaps
|
=
NS_HTTP_DISALLOW_HTTP3
;
}
RefPtr
<
AltSvcMapping
>
mapping
;
if
(
!
mConnectionInfo
&
&
LoadAllowAltSvc
(
)
&
&
(
http2Allowed
|
|
http3Allowed
)
&
&
!
(
mLoadFlags
&
LOAD_FRESH_CONNECTION
)
&
&
AltSvcMapping
:
:
AcceptableProxy
(
proxyInfo
)
&
&
(
scheme
.
EqualsLiteral
(
"
http
"
)
|
|
scheme
.
EqualsLiteral
(
"
https
"
)
)
&
&
(
mapping
=
gHttpHandler
-
>
GetAltServiceMapping
(
scheme
host
port
mPrivateBrowsing
originAttributes
http2Allowed
http3Allowed
)
)
)
{
LOG
(
(
"
nsHttpChannel
%
p
Alt
Service
Mapping
Found
%
s
:
/
/
%
s
:
%
d
[
%
s
]
\
n
"
this
scheme
.
get
(
)
mapping
-
>
AlternateHost
(
)
.
get
(
)
mapping
-
>
AlternatePort
(
)
mapping
-
>
HashKey
(
)
.
get
(
)
)
)
;
if
(
!
(
mLoadFlags
&
LOAD_ANONYMOUS
)
&
&
!
mPrivateBrowsing
)
{
nsAutoCString
altUsedLine
(
mapping
-
>
AlternateHost
(
)
)
;
bool
defaultPort
=
mapping
-
>
AlternatePort
(
)
=
=
(
isHttps
?
NS_HTTPS_DEFAULT_PORT
:
NS_HTTP_DEFAULT_PORT
)
;
if
(
!
defaultPort
)
{
altUsedLine
.
AppendLiteral
(
"
:
"
)
;
altUsedLine
.
AppendInt
(
mapping
-
>
AlternatePort
(
)
)
;
}
Unused
<
<
mRequestHead
.
ClearHeader
(
nsHttp
:
:
Alternate_Service_Used
)
;
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
Alternate_Service_Used
altUsedLine
false
nsHttpHeaderArray
:
:
eVarietyRequestDefault
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsCOMPtr
<
nsIConsoleService
>
consoleService
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
if
(
consoleService
&
&
!
host
.
Equals
(
mapping
-
>
AlternateHost
(
)
)
)
{
nsAutoString
message
(
u
"
Alternate
Service
Mapping
found
:
"
_ns
)
;
AppendASCIItoUTF16
(
scheme
message
)
;
message
.
AppendLiteral
(
u
"
:
/
/
"
)
;
AppendASCIItoUTF16
(
host
message
)
;
message
.
AppendLiteral
(
u
"
:
"
)
;
message
.
AppendInt
(
port
)
;
message
.
AppendLiteral
(
u
"
to
"
)
;
AppendASCIItoUTF16
(
scheme
message
)
;
message
.
AppendLiteral
(
u
"
:
/
/
"
)
;
AppendASCIItoUTF16
(
mapping
-
>
AlternateHost
(
)
message
)
;
message
.
AppendLiteral
(
u
"
:
"
)
;
message
.
AppendInt
(
mapping
-
>
AlternatePort
(
)
)
;
consoleService
-
>
LogStringMessage
(
message
.
get
(
)
)
;
}
LOG
(
(
"
nsHttpChannel
%
p
Using
connection
info
from
altsvc
mapping
"
this
)
)
;
mapping
-
>
GetConnectionInfo
(
getter_AddRefs
(
mConnectionInfo
)
proxyInfo
originAttributes
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_TRANSACTION_USE_ALTSVC
true
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_TRANSACTION_USE_ALTSVC_OE
!
isHttps
)
;
}
else
if
(
mConnectionInfo
)
{
LOG
(
(
"
nsHttpChannel
%
p
Using
channel
supplied
connection
info
"
this
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_TRANSACTION_USE_ALTSVC
false
)
;
}
else
{
LOG
(
(
"
nsHttpChannel
%
p
Using
default
connection
info
"
this
)
)
;
mConnectionInfo
=
connInfo
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_TRANSACTION_USE_ALTSVC
false
)
;
}
bool
httpsRRAllowed
=
!
LoadBeConservative
(
)
&
&
!
(
mCaps
&
NS_HTTP_BE_CONSERVATIVE
)
&
&
!
(
mLoadInfo
-
>
TriggeringPrincipal
(
)
-
>
IsSystemPrincipal
(
)
&
&
mLoadInfo
-
>
GetExternalContentPolicyType
(
)
!
=
ExtContentPolicy
:
:
TYPE_DOCUMENT
)
&
&
!
mConnectionInfo
-
>
UsingConnect
(
)
;
if
(
!
httpsRRAllowed
)
{
mCaps
|
=
NS_HTTP_DISALLOW_HTTPS_RR
;
}
StoreUseHTTPSSVC
(
StaticPrefs
:
:
network_dns_upgrade_with_https_rr
(
)
&
&
httpsRRAllowed
&
&
mHTTPSSVCRecord
.
isNothing
(
)
)
;
if
(
!
mConnectionInfo
-
>
IsHttp3
(
)
&
&
gHttpHandler
-
>
IsHttp2Excluded
(
mConnectionInfo
)
)
{
StoreAllowSpdy
(
0
)
;
mCaps
|
=
NS_HTTP_DISALLOW_SPDY
;
mConnectionInfo
-
>
SetNoSpdy
(
true
)
;
}
mAuthProvider
=
new
nsHttpChannelAuthProvider
(
)
;
rv
=
mAuthProvider
-
>
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
mAuthProvider
-
>
AddAuthorizationHeaders
(
LoadCustomAuthHeader
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpChannel
%
p
AddAuthorizationHeaders
failed
(
%
08x
)
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
if
(
!
LoadTimingEnabled
(
)
)
mAsyncOpenTime
=
TimeStamp
(
)
;
Unused
<
<
gHttpHandler
-
>
AddConnectionHeader
(
&
mRequestHead
mCaps
)
;
if
(
!
LoadIsTRRServiceChannel
(
)
&
&
(
mLoadFlags
&
VALIDATE_ALWAYS
|
|
BYPASS_LOCAL_CACHE
(
mLoadFlags
LoadPreferCacheLoadOverBypass
(
)
)
)
)
{
mCaps
|
=
NS_HTTP_REFRESH_DNS
;
}
if
(
gHttpHandler
-
>
CriticalRequestPrioritization
(
)
)
{
if
(
mClassOfService
.
Flags
(
)
&
nsIClassOfService
:
:
Leader
)
{
mCaps
|
=
NS_HTTP_LOAD_AS_BLOCKING
;
}
if
(
mClassOfService
.
Flags
(
)
&
nsIClassOfService
:
:
Unblocked
)
{
mCaps
|
=
NS_HTTP_LOAD_UNBLOCKED
;
}
if
(
mClassOfService
.
Flags
(
)
&
nsIClassOfService
:
:
UrgentStart
&
&
gHttpHandler
-
>
IsUrgentStartEnabled
(
)
)
{
mCaps
|
=
NS_HTTP_URGENT_START
;
SetPriority
(
nsISupportsPriority
:
:
PRIORITY_HIGHEST
)
;
}
}
if
(
mLoadFlags
&
LOAD_FRESH_CONNECTION
)
{
if
(
mLoadFlags
&
LOAD_INITIAL_DOCUMENT_URI
)
{
gHttpHandler
-
>
AltServiceCache
(
)
-
>
ClearAltServiceMappings
(
)
;
rv
=
gHttpHandler
-
>
DoShiftReloadConnectionCleanupWithConnInfo
(
mConnectionInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpChannel
:
:
BeginConnect
"
"
DoShiftReloadConnectionCleanupWithConnInfo
failed
:
%
08x
[
this
=
%
p
]
"
static_cast
<
uint32_t
>
(
rv
)
this
)
)
;
}
}
}
if
(
mCanceled
)
{
return
mStatus
;
}
bool
shouldBeClassified
=
NS_ShouldClassifyChannel
(
this
)
;
if
(
shouldBeClassified
)
{
if
(
LoadChannelClassifierCancellationPending
(
)
)
{
LOG
(
(
"
Waiting
for
safe
-
browsing
protection
cancellation
in
BeginConnect
"
"
[
this
=
%
p
]
\
n
"
this
)
)
;
return
NS_OK
;
}
ReEvaluateReferrerAfterTrackingStatusIsKnown
(
)
;
}
rv
=
MaybeStartDNSPrefetch
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
auto
dnsStrategy
=
GetProxyDNSStrategy
(
)
;
if
(
dnsStrategy
&
DNS_BLOCK_ON_ORIGIN_RESOLVE
)
{
return
rv
;
}
return
NS_OK
;
}
rv
=
CallOrWaitForResume
(
[
]
(
nsHttpChannel
*
self
)
{
return
self
-
>
PrepareToConnect
(
)
;
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
shouldBeClassified
)
{
RefPtr
<
nsChannelClassifier
>
channelClassifier
=
GetOrCreateChannelClassifier
(
)
;
LOG
(
(
"
nsHttpChannel
:
:
Starting
nsChannelClassifier
%
p
[
this
=
%
p
]
"
channelClassifier
.
get
(
)
this
)
)
;
channelClassifier
-
>
Start
(
)
;
}
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
MaybeStartDNSPrefetch
(
)
{
if
(
mLoadFlags
&
(
LOAD_NO_NETWORK_IO
|
LOAD_ONLY_FROM_CACHE
)
)
{
return
NS_OK
;
}
auto
dnsStrategy
=
GetProxyDNSStrategy
(
)
;
LOG
(
(
"
nsHttpChannel
:
:
MaybeStartDNSPrefetch
[
this
=
%
p
strategy
=
%
u
]
"
"
prefetching
%
s
\
n
"
this
dnsStrategy
mCaps
&
NS_HTTP_REFRESH_DNS
?
"
refresh
requested
"
:
"
"
)
)
;
if
(
dnsStrategy
&
DNS_PREFETCH_ORIGIN
)
{
OriginAttributes
originAttributes
;
StoragePrincipalHelper
:
:
GetOriginAttributesForNetworkState
(
this
originAttributes
)
;
mDNSPrefetch
=
new
nsDNSPrefetch
(
mURI
originAttributes
nsIRequest
:
:
GetTRRMode
(
)
this
LoadTimingEnabled
(
)
)
;
nsresult
rv
=
mDNSPrefetch
-
>
PrefetchHigh
(
mCaps
&
NS_HTTP_REFRESH_DNS
)
;
if
(
dnsStrategy
&
DNS_BLOCK_ON_ORIGIN_RESOLVE
)
{
LOG
(
(
"
blocking
on
prefetching
origin
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG
(
(
"
lookup
failed
with
0x
%
08
"
PRIx32
"
aborting
request
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
rv
;
}
mDNSBlockingThenable
=
mDNSBlockingPromise
.
Ensure
(
__func__
)
;
}
if
(
gHttpHandler
-
>
UseHTTPSRRAsAltSvcEnabled
(
)
&
&
!
mHTTPSSVCRecord
&
&
!
(
mCaps
&
NS_HTTP_DISALLOW_HTTPS_RR
)
)
{
MOZ_ASSERT
(
!
mHTTPSSVCRecord
)
;
OriginAttributes
originAttributes
;
StoragePrincipalHelper
:
:
GetOriginAttributesForHTTPSRR
(
this
originAttributes
)
;
RefPtr
<
nsDNSPrefetch
>
resolver
=
new
nsDNSPrefetch
(
mURI
originAttributes
nsIRequest
:
:
GetTRRMode
(
)
)
;
Unused
<
<
resolver
-
>
FetchHTTPSSVC
(
mCaps
&
NS_HTTP_REFRESH_DNS
true
[
]
(
nsIDNSHTTPSSVCRecord
*
)
{
}
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetEncodedBodySize
(
uint64_t
*
aEncodedBodySize
)
{
if
(
mCacheEntry
&
&
!
LoadCacheEntryIsWriteOnly
(
)
)
{
int64_t
dataSize
=
0
;
mCacheEntry
-
>
GetDataSize
(
&
dataSize
)
;
*
aEncodedBodySize
=
dataSize
;
}
else
{
*
aEncodedBodySize
=
mLogicalOffset
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetIsAuthChannel
(
bool
*
aIsAuthChannel
)
{
*
aIsAuthChannel
=
mIsAuthChannel
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetChannelIsForDownload
(
bool
aChannelIsForDownload
)
{
if
(
aChannelIsForDownload
)
{
AddClassFlags
(
nsIClassOfService
:
:
Throttleable
)
;
}
else
{
ClearClassFlags
(
nsIClassOfService
:
:
Throttleable
)
;
}
return
HttpBaseChannel
:
:
SetChannelIsForDownload
(
aChannelIsForDownload
)
;
}
base
:
:
ProcessId
nsHttpChannel
:
:
ProcessId
(
)
{
nsCOMPtr
<
nsIParentChannel
>
parentChannel
;
NS_QueryNotificationCallbacks
(
this
parentChannel
)
;
if
(
RefPtr
<
HttpChannelParent
>
httpParent
=
do_QueryObject
(
parentChannel
)
)
{
return
httpParent
-
>
OtherPid
(
)
;
}
if
(
RefPtr
<
DocumentLoadListener
>
docParent
=
do_QueryObject
(
parentChannel
)
)
{
return
docParent
-
>
OtherPid
(
)
;
}
return
base
:
:
GetCurrentProcId
(
)
;
}
auto
nsHttpChannel
:
:
AttachStreamFilter
(
)
-
>
RefPtr
<
ChildEndpointPromise
>
{
LOG
(
(
"
nsHttpChannel
:
:
AttachStreamFilter
[
this
=
%
p
]
"
this
)
)
;
MOZ_ASSERT
(
!
LoadOnStartRequestCalled
(
)
)
;
if
(
!
ProcessId
(
)
)
{
return
ChildEndpointPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
nsCOMPtr
<
nsIParentChannel
>
parentChannel
;
NS_QueryNotificationCallbacks
(
this
parentChannel
)
;
if
(
RefPtr
<
DocumentLoadListener
>
docParent
=
do_QueryObject
(
parentChannel
)
)
{
StreamFilterRequest
*
request
=
mStreamFilterRequests
.
AppendElement
(
)
;
request
-
>
mPromise
=
new
ChildEndpointPromise
:
:
Private
(
__func__
)
;
return
request
-
>
mPromise
;
}
mozilla
:
:
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterParent
>
parent
;
mozilla
:
:
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterChild
>
child
;
nsresult
rv
=
extensions
:
:
PStreamFilter
:
:
CreateEndpoints
(
&
parent
&
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ChildEndpointPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
if
(
RefPtr
<
HttpChannelParent
>
httpParent
=
do_QueryObject
(
parentChannel
)
)
{
return
httpParent
-
>
AttachStreamFilter
(
std
:
:
move
(
parent
)
std
:
:
move
(
child
)
)
;
}
extensions
:
:
StreamFilterParent
:
:
Attach
(
this
std
:
:
move
(
parent
)
)
;
return
ChildEndpointPromise
:
:
CreateAndResolve
(
std
:
:
move
(
child
)
__func__
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetNavigationStartTimeStamp
(
TimeStamp
*
aTimeStamp
)
{
LOG
(
(
"
nsHttpChannel
:
:
GetNavigationStartTimeStamp
[
this
=
%
p
]
"
this
)
)
;
MOZ_ASSERT
(
aTimeStamp
)
;
*
aTimeStamp
=
mNavigationStartTimeStamp
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetNavigationStartTimeStamp
(
TimeStamp
aTimeStamp
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetNavigationStartTimeStamp
[
this
=
%
p
]
"
this
)
)
;
mNavigationStartTimeStamp
=
aTimeStamp
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetPriority
(
int32_t
value
)
{
int16_t
newValue
=
clamped
<
int32_t
>
(
value
INT16_MIN
INT16_MAX
)
;
if
(
mPriority
=
=
newValue
)
return
NS_OK
;
LOG
(
(
"
nsHttpChannel
:
:
SetPriority
%
p
p
=
%
d
"
this
newValue
)
)
;
mPriority
=
newValue
;
if
(
mTransaction
)
{
nsresult
rv
=
gHttpHandler
-
>
RescheduleTransaction
(
mTransaction
mPriority
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetPriority
[
this
=
%
p
]
"
"
RescheduleTransaction
failed
(
%
08x
)
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
nsCOMPtr
<
nsIParentChannel
>
parentChannel
;
NS_QueryNotificationCallbacks
(
this
parentChannel
)
;
RefPtr
<
HttpChannelParent
>
httpParent
=
do_QueryObject
(
parentChannel
)
;
if
(
httpParent
)
{
httpParent
-
>
DoSendSetPriority
(
newValue
)
;
}
return
NS_OK
;
}
void
nsHttpChannel
:
:
OnClassOfServiceUpdated
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
OnClassOfServiceUpdated
this
=
%
p
cos
=
%
lu
inc
=
%
d
"
this
mClassOfService
.
Flags
(
)
mClassOfService
.
Incremental
(
)
)
)
;
if
(
mTransaction
)
{
gHttpHandler
-
>
UpdateClassOfServiceOnTransaction
(
mTransaction
mClassOfService
)
;
}
if
(
EligibleForTailing
(
)
)
{
RemoveAsNonTailRequest
(
)
;
}
else
{
AddAsNonTailRequest
(
)
;
}
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetClassFlags
(
uint32_t
inFlags
)
{
uint32_t
previous
=
mClassOfService
.
Flags
(
)
;
mClassOfService
.
SetFlags
(
inFlags
)
;
if
(
previous
!
=
mClassOfService
.
Flags
(
)
)
{
OnClassOfServiceUpdated
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
AddClassFlags
(
uint32_t
inFlags
)
{
uint32_t
previous
=
mClassOfService
.
Flags
(
)
;
mClassOfService
.
SetFlags
(
inFlags
|
mClassOfService
.
Flags
(
)
)
;
if
(
previous
!
=
mClassOfService
.
Flags
(
)
)
{
OnClassOfServiceUpdated
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
ClearClassFlags
(
uint32_t
inFlags
)
{
uint32_t
previous
=
mClassOfService
.
Flags
(
)
;
mClassOfService
.
SetFlags
(
~
inFlags
&
mClassOfService
.
Flags
(
)
)
;
if
(
previous
!
=
mClassOfService
.
Flags
(
)
)
{
OnClassOfServiceUpdated
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetClassOfService
(
ClassOfService
cos
)
{
ClassOfService
previous
=
mClassOfService
;
mClassOfService
=
cos
;
if
(
previous
!
=
mClassOfService
)
{
OnClassOfServiceUpdated
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetIncremental
(
bool
incremental
)
{
bool
previous
=
mClassOfService
.
Incremental
(
)
;
mClassOfService
.
SetIncremental
(
incremental
)
;
if
(
previous
!
=
mClassOfService
.
Incremental
(
)
)
{
OnClassOfServiceUpdated
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnProxyAvailable
(
nsICancelable
*
request
nsIChannel
*
channel
nsIProxyInfo
*
pi
nsresult
status
)
{
LOG
(
(
"
nsHttpChannel
:
:
OnProxyAvailable
[
this
=
%
p
pi
=
%
p
status
=
%
"
PRIx32
"
mStatus
=
%
"
PRIx32
"
]
\
n
"
this
pi
static_cast
<
uint32_t
>
(
status
)
static_cast
<
uint32_t
>
(
static_cast
<
nsresult
>
(
mStatus
)
)
)
)
;
mProxyRequest
=
nullptr
;
nsresult
rv
;
if
(
NS_SUCCEEDED
(
status
)
)
mProxyInfo
=
pi
;
if
(
!
gHttpHandler
-
>
Active
(
)
)
{
LOG
(
(
"
nsHttpChannel
:
:
OnProxyAvailable
[
this
=
%
p
]
"
"
Handler
no
longer
active
.
\
n
"
this
)
)
;
rv
=
NS_ERROR_NOT_AVAILABLE
;
}
else
{
rv
=
BeginConnect
(
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
CloseCacheEntry
(
false
)
;
Unused
<
<
AsyncAbort
(
rv
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetProxyInfo
(
nsIProxyInfo
*
*
result
)
{
if
(
!
mConnectionInfo
)
{
*
result
=
do_AddRef
(
mProxyInfo
)
.
take
(
)
;
}
else
{
*
result
=
do_AddRef
(
mConnectionInfo
-
>
ProxyInfo
(
)
)
.
take
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetDomainLookupStart
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
{
*
_retval
=
mTransaction
-
>
GetDomainLookupStart
(
)
;
}
else
{
*
_retval
=
mTransactionTimings
.
domainLookupStart
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetDomainLookupEnd
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
{
*
_retval
=
mTransaction
-
>
GetDomainLookupEnd
(
)
;
}
else
{
*
_retval
=
mTransactionTimings
.
domainLookupEnd
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetConnectStart
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
{
*
_retval
=
mTransaction
-
>
GetConnectStart
(
)
;
}
else
{
*
_retval
=
mTransactionTimings
.
connectStart
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetTcpConnectEnd
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
{
*
_retval
=
mTransaction
-
>
GetTcpConnectEnd
(
)
;
}
else
{
*
_retval
=
mTransactionTimings
.
tcpConnectEnd
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetSecureConnectionStart
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
{
*
_retval
=
mTransaction
-
>
GetSecureConnectionStart
(
)
;
}
else
{
*
_retval
=
mTransactionTimings
.
secureConnectionStart
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetConnectEnd
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
{
*
_retval
=
mTransaction
-
>
GetConnectEnd
(
)
;
}
else
{
*
_retval
=
mTransactionTimings
.
connectEnd
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetRequestStart
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
{
*
_retval
=
mTransaction
-
>
GetRequestStart
(
)
;
}
else
{
*
_retval
=
mTransactionTimings
.
requestStart
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetResponseStart
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
{
*
_retval
=
mTransaction
-
>
GetResponseStart
(
)
;
}
else
{
*
_retval
=
mTransactionTimings
.
responseStart
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetResponseEnd
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
{
*
_retval
=
mTransaction
-
>
GetResponseEnd
(
)
;
}
else
{
*
_retval
=
mTransactionTimings
.
responseEnd
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetIsSSL
(
bool
*
aIsSSL
)
{
return
mURI
-
>
SchemeIs
(
"
https
"
aIsSSL
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetProxyMethodIsConnect
(
bool
*
aProxyMethodIsConnect
)
{
*
aProxyMethodIsConnect
=
mConnectionInfo
-
>
UsingConnect
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetServerResponseHeader
(
nsACString
&
value
)
{
if
(
!
mResponseHead
)
return
NS_ERROR_NOT_AVAILABLE
;
return
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Server
value
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetProxyChallenges
(
nsACString
&
value
)
{
if
(
!
mResponseHead
)
return
NS_ERROR_UNEXPECTED
;
return
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Proxy_Authenticate
value
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetWWWChallenges
(
nsACString
&
value
)
{
if
(
!
mResponseHead
)
return
NS_ERROR_UNEXPECTED
;
return
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
WWW_Authenticate
value
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetProxyCredentials
(
const
nsACString
&
value
)
{
return
mRequestHead
.
SetHeader
(
nsHttp
:
:
Proxy_Authorization
value
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetWWWCredentials
(
const
nsACString
&
value
)
{
Unused
<
<
mRequestHead
.
ClearHeader
(
nsHttp
:
:
Authorization
)
;
return
mRequestHead
.
SetHeader
(
nsHttp
:
:
Authorization
value
false
nsHttpHeaderArray
:
:
eVarietyRequestDefault
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetLoadFlags
(
nsLoadFlags
*
aLoadFlags
)
{
return
HttpBaseChannel
:
:
GetLoadFlags
(
aLoadFlags
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetURI
(
nsIURI
*
*
aURI
)
{
return
HttpBaseChannel
:
:
GetURI
(
aURI
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetNotificationCallbacks
(
nsIInterfaceRequestor
*
*
aCallbacks
)
{
return
HttpBaseChannel
:
:
GetNotificationCallbacks
(
aCallbacks
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetLoadGroup
(
nsILoadGroup
*
*
aLoadGroup
)
{
return
HttpBaseChannel
:
:
GetLoadGroup
(
aLoadGroup
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetRequestMethod
(
nsACString
&
aMethod
)
{
return
HttpBaseChannel
:
:
GetRequestMethod
(
aMethod
)
;
}
static
void
RecordOnStartTelemetry
(
nsresult
aStatus
HttpTransactionShell
*
aTransaction
bool
aIsNavigation
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_CHANNEL_ONSTART_SUCCESS
NS_SUCCEEDED
(
aStatus
)
)
;
if
(
aTransaction
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP3_CHANNEL_ONSTART_SUCCESS
(
aTransaction
-
>
IsHttp3Used
(
)
)
?
"
http3
"
_ns
:
"
no_http3
"
_ns
NS_SUCCEEDED
(
aStatus
)
)
;
}
enum
class
HttpOnStartState
:
uint32_t
{
Success
=
0
DNSError
=
1
Others
=
2
}
;
if
(
StaticPrefs
:
:
network_trr_odoh_enabled
(
)
)
{
nsCOMPtr
<
nsIDNSService
>
dns
=
do_GetService
(
NS_DNSSERVICE_CONTRACTID
)
;
if
(
!
dns
)
{
return
;
}
bool
ODoHActivated
=
false
;
if
(
NS_SUCCEEDED
(
dns
-
>
GetODoHActivated
(
&
ODoHActivated
)
)
&
&
ODoHActivated
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_CHANNEL_ONSTART_SUCCESS_ODOH
NS_SUCCEEDED
(
aStatus
)
)
;
}
}
else
if
(
TRRService
:
:
Get
(
)
&
&
TRRService
:
:
Get
(
)
-
>
IsConfirmed
(
)
)
{
HttpOnStartState
state
=
HttpOnStartState
:
:
Others
;
if
(
NS_SUCCEEDED
(
aStatus
)
)
{
state
=
HttpOnStartState
:
:
Success
;
}
else
if
(
aStatus
=
=
NS_ERROR_UNKNOWN_HOST
|
|
aStatus
=
=
NS_ERROR_UNKNOWN_PROXY_HOST
)
{
state
=
HttpOnStartState
:
:
DNSError
;
}
if
(
aIsNavigation
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_CHANNEL_PAGE_ONSTART_SUCCESS_TRR3
TRRService
:
:
ProviderKey
(
)
static_cast
<
uint32_t
>
(
state
)
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_CHANNEL_SUB_ONSTART_SUCCESS_TRR3
TRRService
:
:
ProviderKey
(
)
static_cast
<
uint32_t
>
(
state
)
)
;
}
}
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnStartRequest
(
nsIRequest
*
request
)
{
nsresult
rv
;
MOZ_ASSERT
(
LoadRequestObserversCalled
(
)
)
;
AUTO_PROFILER_LABEL
(
"
nsHttpChannel
:
:
OnStartRequest
"
NETWORK
)
;
if
(
!
(
mCanceled
|
|
NS_FAILED
(
mStatus
)
)
&
&
!
WRONG_RACING_RESPONSE_SOURCE
(
request
)
)
{
nsresult
status
;
request
-
>
GetStatus
(
&
status
)
;
mStatus
=
status
;
}
if
(
mStatus
=
=
NS_ERROR_NON_LOCAL_CONNECTION_REFUSED
)
{
MOZ_CRASH_UNSAFE
(
nsPrintfCString
(
"
Attempting
to
connect
to
non
-
local
"
"
address
!
opener
is
[
%
s
]
uri
is
"
"
[
%
s
]
"
mOpenerCallingScriptLocation
?
mOpenerCallingScriptLocation
-
>
get
(
)
:
"
unknown
"
mURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
.
get
(
)
)
;
}
LOG
(
(
"
nsHttpChannel
:
:
OnStartRequest
[
this
=
%
p
request
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
request
static_cast
<
uint32_t
>
(
static_cast
<
nsresult
>
(
mStatus
)
)
)
)
;
RecordOnStartTelemetry
(
mStatus
mTransaction
IsNavigation
(
)
)
;
if
(
mRaceCacheWithNetwork
)
{
LOG
(
(
"
racingNetAndCache
-
mFirstResponseSource
:
%
d
fromCache
:
%
d
"
"
fromNet
:
%
d
\
n
"
static_cast
<
int32_t
>
(
mFirstResponseSource
)
request
=
=
mCachePump
request
=
=
mTransactionPump
)
)
;
if
(
mFirstResponseSource
=
=
RESPONSE_PENDING
)
{
MOZ_ASSERT
(
request
=
=
mTransactionPump
)
;
LOG
(
(
"
First
response
from
network
\
n
"
)
)
;
{
mozilla
:
:
MutexAutoLock
lock
(
mRCWNLock
)
;
mFirstResponseSource
=
RESPONSE_FROM_NETWORK
;
mOnStartRequestTimestamp
=
TimeStamp
:
:
Now
(
)
;
if
(
mDidReval
)
{
LOG
(
(
"
Removing
conditional
request
headers
"
)
)
;
UntieValidationRequest
(
)
;
mDidReval
=
false
;
}
if
(
LoadCachedContentIsPartial
(
)
)
{
LOG
(
(
"
Removing
byte
range
request
headers
"
)
)
;
UntieByteRangeRequest
(
)
;
StoreCachedContentIsPartial
(
false
)
;
}
}
mAvailableCachedAltDataType
.
Truncate
(
)
;
StoreDeliveringAltData
(
false
)
;
}
else
if
(
WRONG_RACING_RESPONSE_SOURCE
(
request
)
)
{
LOG
(
(
"
Early
return
when
racing
.
This
response
not
needed
.
"
)
)
;
return
NS_OK
;
}
}
MOZ_ASSERT
(
request
=
=
mCachePump
|
|
request
=
=
mTransactionPump
"
Unexpected
request
"
)
;
MOZ_ASSERT
(
mRaceCacheWithNetwork
|
|
!
(
mTransactionPump
&
&
mCachePump
)
|
|
LoadCachedContentIsPartial
(
)
|
|
LoadTransactionReplaced
(
)
"
If
we
have
both
pumps
we
'
re
racing
cache
with
network
the
cache
"
"
content
is
partial
or
the
cache
entry
was
revalidated
and
"
"
OnStopRequest
was
not
called
yet
for
the
transaction
pump
.
"
)
;
StoreAfterOnStartRequestBegun
(
true
)
;
if
(
mOnStartRequestTimestamp
.
IsNull
(
)
)
{
mOnStartRequestTimestamp
=
TimeStamp
:
:
Now
(
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_ONSTART_SUSPEND_TOTAL_TIME
mSuspendTotalTime
)
;
if
(
mTransaction
)
{
mProxyConnectResponseCode
=
mTransaction
-
>
GetProxyConnectResponseCode
(
)
;
if
(
request
=
=
mTransactionPump
)
{
StoreDataSentToChildProcess
(
mTransaction
-
>
DataSentToChildProcess
(
)
)
;
}
if
(
!
mSecurityInfo
&
&
!
mCachePump
)
{
mSecurityInfo
=
mTransaction
-
>
SecurityInfo
(
)
;
}
uint32_t
stage
=
mTransaction
-
>
HTTPSSVCReceivedStage
(
)
;
if
(
!
LoadHTTPSSVCTelemetryReported
(
)
&
&
stage
!
=
HTTPSSVC_NOT_USED
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
DNS_HTTPSSVC_RECORD_RECEIVING_STAGE
stage
)
;
}
if
(
HTTPS_RR_IS_USED
(
stage
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_CHANNEL_ONSTART_SUCCESS_HTTPS_RR
LoadEchConfigUsed
(
)
?
"
echConfig
-
used
"
_ns
:
"
echConfig
-
not
-
used
"
_ns
NS_SUCCEEDED
(
mStatus
)
)
;
StoreHasHTTPSRR
(
true
)
;
}
StoreLoadedBySocketProcess
(
mTransaction
-
>
AsHttpTransactionParent
(
)
!
=
nullptr
)
;
}
if
(
NS_SUCCEEDED
(
mStatus
)
&
&
!
mCachePump
&
&
mTransaction
)
{
mResponseHead
=
mTransaction
-
>
TakeResponseHead
(
)
;
mSupportsHTTP3
=
mTransaction
-
>
GetSupportsHTTP3
(
)
;
if
(
mResponseHead
)
return
ProcessResponse
(
)
;
NS_WARNING
(
"
No
response
head
in
OnStartRequest
"
)
;
}
if
(
mCacheEntry
&
&
mCachePump
&
&
RECOVER_FROM_CACHE_FILE_ERROR
(
mStatus
)
)
{
LOG
(
(
"
cache
file
error
reloading
from
server
"
)
)
;
mCacheEntry
-
>
AsyncDoom
(
nullptr
)
;
rv
=
StartRedirectChannelToURI
(
mURI
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
return
NS_OK
;
}
if
(
!
mListener
)
{
MOZ_ASSERT_UNREACHABLE
(
"
mListener
is
null
"
)
;
return
NS_OK
;
}
rv
=
ProcessCrossOriginSecurityHeaders
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mStatus
=
rv
;
HandleAsyncAbort
(
)
;
return
rv
;
}
return
ContinueOnStartRequest1
(
rv
)
;
}
nsresult
nsHttpChannel
:
:
ContinueOnStartRequest1
(
nsresult
result
)
{
nsresult
rv
;
if
(
NS_FAILED
(
result
)
&
&
!
mCanceled
)
{
Cancel
(
result
)
;
return
CallOnStartRequest
(
)
;
}
if
(
mAPIRedirectToURI
&
&
!
mCanceled
)
{
nsAutoCString
redirectToSpec
;
mAPIRedirectToURI
-
>
GetAsciiSpec
(
redirectToSpec
)
;
LOG
(
(
"
redirectTo
called
with
uri
=
%
s
"
redirectToSpec
.
BeginReading
(
)
)
)
;
MOZ_ASSERT
(
!
LoadOnStartRequestCalled
(
)
)
;
nsCOMPtr
<
nsIURI
>
redirectTo
;
mAPIRedirectToURI
.
swap
(
redirectTo
)
;
PushRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueOnStartRequest2
)
;
rv
=
StartRedirectChannelToURI
(
redirectTo
nsIChannelEventSink
:
:
REDIRECT_TEMPORARY
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
NS_OK
;
}
PopRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueOnStartRequest2
)
;
}
return
ContinueOnStartRequest2
(
NS_BINDING_FAILED
)
;
}
nsresult
nsHttpChannel
:
:
ContinueOnStartRequest2
(
nsresult
result
)
{
if
(
NS_SUCCEEDED
(
result
)
)
{
return
NS_OK
;
}
if
(
mConnectionInfo
-
>
ProxyInfo
(
)
&
&
(
mStatus
=
=
NS_ERROR_PROXY_CONNECTION_REFUSED
|
|
mStatus
=
=
NS_ERROR_UNKNOWN_PROXY_HOST
|
|
mStatus
=
=
NS_ERROR_NET_TIMEOUT
|
|
mStatus
=
=
NS_ERROR_NET_RESET
)
)
{
PushRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueOnStartRequest3
)
;
if
(
NS_SUCCEEDED
(
ProxyFailover
(
)
)
)
{
mProxyConnectResponseCode
=
0
;
return
NS_OK
;
}
PopRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueOnStartRequest3
)
;
}
return
ContinueOnStartRequest3
(
NS_BINDING_FAILED
)
;
}
nsresult
nsHttpChannel
:
:
ContinueOnStartRequest3
(
nsresult
result
)
{
if
(
NS_SUCCEEDED
(
result
)
)
{
return
NS_OK
;
}
return
ContinueOnStartRequest4
(
NS_OK
)
;
}
nsresult
nsHttpChannel
:
:
ContinueOnStartRequest4
(
nsresult
result
)
{
LOG
(
(
"
nsHttpChannel
:
:
ContinueOnStartRequest4
[
this
=
%
p
]
"
this
)
)
;
if
(
NS_SUCCEEDED
(
mStatus
)
&
&
mResponseHead
&
&
mAuthProvider
)
{
uint32_t
httpStatus
=
mResponseHead
-
>
Status
(
)
;
if
(
httpStatus
!
=
401
&
&
httpStatus
!
=
407
)
{
nsresult
rv
=
mAuthProvider
-
>
CheckForSuperfluousAuth
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
CheckForSuperfluousAuth
failed
(
%
08x
)
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
}
return
CallOnStartRequest
(
)
;
}
static
void
ReportHTTPSRRTelemetry
(
const
Maybe
<
nsCOMPtr
<
nsIDNSHTTPSSVCRecord
>
>
&
aMaybeRecord
)
{
bool
hasHTTPSRR
=
aMaybeRecord
&
&
(
aMaybeRecord
.
ref
(
)
!
=
nullptr
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTPS_RR_PRESENTED
hasHTTPSRR
)
;
if
(
!
hasHTTPSRR
)
{
return
;
}
const
nsCOMPtr
<
nsIDNSHTTPSSVCRecord
>
&
record
=
aMaybeRecord
.
ref
(
)
;
nsCOMPtr
<
nsISVCBRecord
>
svcbRecord
;
if
(
NS_SUCCEEDED
(
record
-
>
GetServiceModeRecord
(
false
false
getter_AddRefs
(
svcbRecord
)
)
)
)
{
MOZ_ASSERT
(
svcbRecord
)
;
Maybe
<
Tuple
<
nsCString
SupportedAlpnRank
>
>
alpn
=
svcbRecord
-
>
GetAlpn
(
)
;
bool
isHttp3
=
alpn
?
IsHttp3
(
Get
<
1
>
(
*
alpn
)
)
:
false
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTPS_RR_WITH_HTTP3_PRESENTED
isHttp3
)
;
}
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnStopRequest
(
nsIRequest
*
request
nsresult
status
)
{
AUTO_PROFILER_LABEL
(
"
nsHttpChannel
:
:
OnStopRequest
"
NETWORK
)
;
LOG
(
(
"
nsHttpChannel
:
:
OnStopRequest
[
this
=
%
p
request
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
request
static_cast
<
uint32_t
>
(
status
)
)
)
;
LOG
(
(
"
OnStopRequest
%
p
requestFromCache
:
%
d
mFirstResponseSource
:
%
d
\
n
"
this
request
=
=
mCachePump
static_cast
<
int32_t
>
(
mFirstResponseSource
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
OnStopRequest
should
only
be
called
from
the
main
thread
"
)
;
if
(
WRONG_RACING_RESPONSE_SOURCE
(
request
)
)
{
return
NS_OK
;
}
if
(
LoadUseHTTPSSVC
(
)
|
|
mHTTPSSVCRecord
)
{
ReportHTTPSRRTelemetry
(
mHTTPSSVCRecord
)
;
}
int32_t
nsprError
=
-
1
*
NS_ERROR_GET_CODE
(
status
)
;
if
(
mozilla
:
:
psm
:
:
IsNSSErrorCode
(
nsprError
)
&
&
IsHTTPS
(
)
)
{
gIOService
-
>
RecheckCaptivePortal
(
)
;
}
if
(
LoadTimingEnabled
(
)
&
&
request
=
=
mCachePump
)
{
mCacheReadEnd
=
TimeStamp
:
:
Now
(
)
;
ReportNetVSCacheTelemetry
(
)
;
}
bool
contentComplete
=
NS_SUCCEEDED
(
status
)
;
if
(
mCanceled
|
|
NS_FAILED
(
mStatus
)
)
status
=
mStatus
;
if
(
LoadCachedContentIsPartial
(
)
)
{
if
(
NS_SUCCEEDED
(
status
)
)
{
MOZ_ASSERT
(
request
!
=
mTransactionPump
"
byte
-
range
transaction
finished
prematurely
"
)
;
if
(
request
=
=
mCachePump
)
{
bool
streamDone
;
status
=
OnDoneReadingPartialCacheEntry
(
&
streamDone
)
;
if
(
NS_SUCCEEDED
(
status
)
&
&
!
streamDone
)
return
status
;
}
else
if
(
request
=
=
mTransactionPump
)
{
MOZ_ASSERT
(
LoadConcurrentCacheAccess
(
)
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
request
"
)
;
}
}
if
(
NS_FAILED
(
status
)
&
&
mTransaction
)
{
nsresult
rv
=
gHttpHandler
-
>
CancelTransaction
(
mTransaction
status
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
CancelTransaction
failed
(
%
08x
)
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
}
nsCOMPtr
<
nsICompressConvStats
>
conv
=
do_QueryInterface
(
mCompressListener
)
;
if
(
conv
)
{
conv
-
>
GetDecodedDataLength
(
&
mDecodedBodySize
)
;
}
bool
isFromNet
=
request
=
=
mTransactionPump
;
if
(
mTransaction
)
{
bool
authRetry
=
mAuthRetryPending
&
&
NS_SUCCEEDED
(
status
)
;
StoreStronglyFramed
(
mTransaction
-
>
ResponseIsComplete
(
)
)
;
LOG
(
(
"
nsHttpChannel
%
p
has
a
strongly
framed
transaction
:
%
d
"
this
LoadStronglyFramed
(
)
)
)
;
RefPtr
<
HttpTransactionShell
>
transactionWithStickyConn
;
if
(
mCaps
&
NS_HTTP_STICKY_CONNECTION
|
|
mTransaction
-
>
HasStickyConnection
(
)
)
{
transactionWithStickyConn
=
mTransaction
;
if
(
mTransaction
-
>
Http2Disabled
(
)
)
{
mCaps
|
=
NS_HTTP_DISALLOW_SPDY
;
}
if
(
mTransaction
-
>
Http3Disabled
(
)
)
{
mCaps
|
=
NS_HTTP_DISALLOW_HTTP3
;
}
mConnectionInfo
=
mTransaction
-
>
GetConnInfo
(
)
;
LOG
(
(
"
transaction
%
p
has
sticky
connection
"
transactionWithStickyConn
.
get
(
)
)
)
;
}
LOG
(
(
"
mAuthRetryPending
=
%
d
status
=
%
"
PRIx32
"
sticky
conn
cap
=
%
d
"
static_cast
<
bool
>
(
mAuthRetryPending
)
static_cast
<
uint32_t
>
(
status
)
mCaps
&
NS_HTTP_STICKY_CONNECTION
)
)
;
if
(
(
mAuthRetryPending
|
|
NS_FAILED
(
status
)
)
&
&
transactionWithStickyConn
)
{
if
(
NS_FAILED
(
status
)
)
{
if
(
!
LoadAuthConnectionRestartable
(
)
)
{
LOG
(
(
"
not
reusing
a
half
-
authenticated
sticky
connection
"
)
)
;
transactionWithStickyConn
-
>
DontReuseConnection
(
)
;
}
}
}
if
(
mCaps
&
NS_HTTP_STICKY_CONNECTION
)
{
mTransaction
-
>
SetH2WSConnRefTaken
(
)
;
}
mTransferSize
=
mTransaction
-
>
GetTransferSize
(
)
;
mRequestSize
=
mTransaction
-
>
GetRequestSize
(
)
;
if
(
request
=
=
mTransactionPump
&
&
mCacheEntry
&
&
!
mDidReval
&
&
!
LoadCustomConditionalRequest
(
)
&
&
!
mAsyncOpenTime
.
IsNull
(
)
&
&
!
mOnStartRequestTimestamp
.
IsNull
(
)
)
{
uint64_t
onStartTime
=
(
mOnStartRequestTimestamp
-
mAsyncOpenTime
)
.
ToMilliseconds
(
)
;
uint64_t
onStopTime
=
(
TimeStamp
:
:
Now
(
)
-
mAsyncOpenTime
)
.
ToMilliseconds
(
)
;
Unused
<
<
mCacheEntry
-
>
SetNetworkTimes
(
onStartTime
onStopTime
)
;
}
mResponseTrailers
=
mTransaction
-
>
TakeResponseTrailers
(
)
;
mTransactionTimings
=
mTransaction
-
>
Timings
(
)
;
mTransaction
=
nullptr
;
mTransactionPump
=
nullptr
;
if
(
mDNSPrefetch
&
&
mDNSPrefetch
-
>
TimingsValid
(
)
&
&
!
mTransactionTimings
.
requestStart
.
IsNull
(
)
&
&
!
mTransactionTimings
.
connectStart
.
IsNull
(
)
&
&
mDNSPrefetch
-
>
EndTimestamp
(
)
<
=
mTransactionTimings
.
connectStart
)
{
mTransactionTimings
.
domainLookupStart
=
mDNSPrefetch
-
>
StartTimestamp
(
)
;
mTransactionTimings
.
domainLookupEnd
=
mDNSPrefetch
-
>
EndTimestamp
(
)
;
}
mDNSPrefetch
=
nullptr
;
if
(
authRetry
)
{
mAuthRetryPending
=
false
;
auto
continueOSR
=
[
authRetry
isFromNet
contentComplete
transactionWithStickyConn
]
(
auto
*
self
nsresult
aStatus
)
{
return
self
-
>
ContinueOnStopRequestAfterAuthRetry
(
aStatus
authRetry
isFromNet
contentComplete
transactionWithStickyConn
)
;
}
;
status
=
DoAuthRetry
(
transactionWithStickyConn
continueOSR
)
;
if
(
NS_SUCCEEDED
(
status
)
)
{
return
NS_OK
;
}
}
return
ContinueOnStopRequestAfterAuthRetry
(
status
authRetry
isFromNet
contentComplete
transactionWithStickyConn
)
;
}
return
ContinueOnStopRequest
(
status
isFromNet
contentComplete
)
;
}
nsresult
nsHttpChannel
:
:
ContinueOnStopRequestAfterAuthRetry
(
nsresult
aStatus
bool
aAuthRetry
bool
aIsFromNet
bool
aContentComplete
HttpTransactionShell
*
aTransWithStickyConn
)
{
LOG
(
(
"
nsHttpChannel
:
:
ContinueOnStopRequestAfterAuthRetry
"
"
[
this
=
%
p
aStatus
=
%
"
PRIx32
"
aAuthRetry
=
%
d
aIsFromNet
=
%
d
aTransWithStickyConn
=
%
p
]
\
n
"
this
static_cast
<
uint32_t
>
(
aStatus
)
aAuthRetry
aIsFromNet
aTransWithStickyConn
)
)
;
if
(
aAuthRetry
&
&
NS_SUCCEEDED
(
aStatus
)
)
{
return
NS_OK
;
}
if
(
aAuthRetry
|
|
(
mAuthRetryPending
&
&
NS_FAILED
(
aStatus
)
)
)
{
MOZ_ASSERT
(
NS_FAILED
(
aStatus
)
"
should
have
a
failure
code
here
"
)
;
LOG
(
(
"
calling
mListener
-
>
OnStartRequest
[
this
=
%
p
listener
=
%
p
]
\
n
"
this
mListener
.
get
(
)
)
)
;
if
(
mListener
)
{
MOZ_ASSERT
(
!
LoadOnStartRequestCalled
(
)
"
We
should
not
call
OnStartRequest
twice
.
"
)
;
nsCOMPtr
<
nsIStreamListener
>
listener
(
mListener
)
;
StoreOnStartRequestCalled
(
true
)
;
listener
-
>
OnStartRequest
(
this
)
;
}
else
{
StoreOnStartRequestCalled
(
true
)
;
NS_WARNING
(
"
OnStartRequest
skipped
because
of
null
listener
"
)
;
}
}
if
(
LoadTransactionReplaced
(
)
)
{
LOG
(
(
"
Transaction
replaced
\
n
"
)
)
;
mFirstResponseSource
=
RESPONSE_PENDING
;
return
NS_OK
;
}
bool
upgradeWebsocket
=
mUpgradeProtocolCallback
&
&
aTransWithStickyConn
&
&
mResponseHead
&
&
(
(
mResponseHead
-
>
Status
(
)
=
=
101
&
&
mResponseHead
-
>
Version
(
)
=
=
HttpVersion
:
:
v1_1
)
|
|
(
mResponseHead
-
>
Status
(
)
=
=
200
&
&
mResponseHead
-
>
Version
(
)
=
=
HttpVersion
:
:
v2_0
)
)
;
bool
upgradeConnect
=
mUpgradeProtocolCallback
&
&
aTransWithStickyConn
&
&
(
mCaps
&
NS_HTTP_CONNECT_ONLY
)
&
&
mResponseHead
&
&
mResponseHead
-
>
Status
(
)
=
=
200
;
if
(
upgradeWebsocket
|
|
upgradeConnect
)
{
if
(
nsIOService
:
:
UseSocketProcess
(
)
&
&
upgradeConnect
)
{
Unused
<
<
mUpgradeProtocolCallback
-
>
OnUpgradeFailed
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
ContinueOnStopRequest
(
aStatus
aIsFromNet
aContentComplete
)
;
}
nsresult
rv
=
gHttpHandler
-
>
CompleteUpgrade
(
aTransWithStickyConn
mUpgradeProtocolCallback
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
CompleteUpgrade
failed
with
%
"
PRIx32
static_cast
<
uint32_t
>
(
rv
)
)
)
;
aStatus
=
rv
;
}
}
return
ContinueOnStopRequest
(
aStatus
aIsFromNet
aContentComplete
)
;
}
nsresult
nsHttpChannel
:
:
ContinueOnStopRequest
(
nsresult
aStatus
bool
aIsFromNet
bool
aContentComplete
)
{
LOG
(
(
"
nsHttpChannel
:
:
ContinueOnStopRequest
"
"
[
this
=
%
p
aStatus
=
%
"
PRIx32
"
aIsFromNet
=
%
d
]
\
n
"
this
static_cast
<
uint32_t
>
(
aStatus
)
aIsFromNet
)
)
;
enum
ChannelDisposition
{
kHttpCanceled
=
0
kHttpDisk
=
1
kHttpNetOK
=
2
kHttpNetEarlyFail
=
3
kHttpNetLateFail
=
4
kHttpsCanceled
=
8
kHttpsDisk
=
9
kHttpsNetOK
=
10
kHttpsNetEarlyFail
=
11
kHttpsNetLateFail
=
12
}
chanDisposition
=
kHttpCanceled
;
Telemetry
:
:
LABELS_HTTP_CHANNEL_DISPOSITION_UPGRADE
upgradeChanDisposition
=
Telemetry
:
:
LABELS_HTTP_CHANNEL_DISPOSITION_UPGRADE
:
:
cancel
;
if
(
mCanceled
)
{
chanDisposition
=
kHttpCanceled
;
upgradeChanDisposition
=
Telemetry
:
:
LABELS_HTTP_CHANNEL_DISPOSITION_UPGRADE
:
:
cancel
;
}
else
if
(
!
LoadUsedNetwork
(
)
|
|
(
mRaceCacheWithNetwork
&
&
mFirstResponseSource
=
=
RESPONSE_FROM_CACHE
)
)
{
chanDisposition
=
kHttpDisk
;
upgradeChanDisposition
=
Telemetry
:
:
LABELS_HTTP_CHANNEL_DISPOSITION_UPGRADE
:
:
disk
;
}
else
if
(
NS_SUCCEEDED
(
aStatus
)
&
&
mResponseHead
&
&
mResponseHead
-
>
Version
(
)
!
=
HttpVersion
:
:
v0_9
)
{
chanDisposition
=
kHttpNetOK
;
upgradeChanDisposition
=
Telemetry
:
:
LABELS_HTTP_CHANNEL_DISPOSITION_UPGRADE
:
:
netOk
;
}
else
if
(
!
mTransferSize
)
{
chanDisposition
=
kHttpNetEarlyFail
;
upgradeChanDisposition
=
Telemetry
:
:
LABELS_HTTP_CHANNEL_DISPOSITION_UPGRADE
:
:
netEarlyFail
;
}
else
{
chanDisposition
=
kHttpNetLateFail
;
upgradeChanDisposition
=
Telemetry
:
:
LABELS_HTTP_CHANNEL_DISPOSITION_UPGRADE
:
:
netLateFail
;
}
nsCString
upgradeKey
;
if
(
IsHTTPS
(
)
)
{
upgradeKey
=
"
disabledNoReason
"
_ns
;
if
(
StaticPrefs
:
:
security_mixed_content_upgrade_display_content
(
)
)
{
if
(
mLoadInfo
-
>
GetBrowserUpgradeInsecureRequests
(
)
)
{
upgradeKey
=
"
enabledUpgrade
"
_ns
;
}
else
{
upgradeKey
=
"
enabledNoReason
"
_ns
;
}
}
chanDisposition
=
static_cast
<
ChannelDisposition
>
(
chanDisposition
+
kHttpsCanceled
)
;
}
else
if
(
mLoadInfo
-
>
GetBrowserWouldUpgradeInsecureRequests
(
)
)
{
upgradeKey
=
"
disabledUpgrade
"
_ns
;
}
else
{
upgradeKey
=
StaticPrefs
:
:
security_mixed_content_upgrade_display_content
(
)
?
"
enabledWont
"
_ns
:
"
disabledWont
"
_ns
;
}
Telemetry
:
:
AccumulateCategoricalKeyed
(
upgradeKey
upgradeChanDisposition
)
;
LOG
(
(
"
nsHttpChannel
:
:
OnStopRequest
ChannelDisposition
%
d
\
n
"
chanDisposition
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_CHANNEL_DISPOSITION
chanDisposition
)
;
if
(
mLoadInfo
-
>
GetBrowserDidUpgradeInsecureRequests
(
)
)
{
bool
success
=
NS_SUCCEEDED
(
aStatus
)
;
nsContentPolicyType
type
;
mLoadInfo
-
>
GetInternalContentPolicyType
(
&
type
)
;
switch
(
type
)
{
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
:
Telemetry
:
:
AccumulateCategorical
(
success
?
Telemetry
:
:
LABELS_MIXED_CONTENT_UPGRADE_SUCCESS
:
:
ImageSuccess
:
Telemetry
:
:
LABELS_MIXED_CONTENT_UPGRADE_SUCCESS
:
:
ImageFailed
)
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_VIDEO
:
Telemetry
:
:
AccumulateCategorical
(
success
?
Telemetry
:
:
LABELS_MIXED_CONTENT_UPGRADE_SUCCESS
:
:
VideoSuccess
:
Telemetry
:
:
LABELS_MIXED_CONTENT_UPGRADE_SUCCESS
:
:
VideoFailed
)
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIO
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_TRACK
:
Telemetry
:
:
AccumulateCategorical
(
success
?
Telemetry
:
:
LABELS_MIXED_CONTENT_UPGRADE_SUCCESS
:
:
AudioSuccess
:
Telemetry
:
:
LABELS_MIXED_CONTENT_UPGRADE_SUCCESS
:
:
AudioFailed
)
;
break
;
default
:
MOZ_ASSERT
(
false
"
Unexpected
content
type
.
"
)
;
}
}
if
(
mCacheEntry
&
&
mCachePump
&
&
LoadConcurrentCacheAccess
(
)
&
&
aContentComplete
)
{
int64_t
size
contentLength
;
nsresult
rv
=
CheckPartial
(
mCacheEntry
&
size
&
contentLength
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
size
=
=
int64_t
(
-
1
)
)
{
MOZ_ASSERT
(
false
)
;
LOG
(
(
"
cache
entry
write
is
still
in
progress
but
we
just
"
"
finished
reading
the
cache
entry
"
)
)
;
}
else
if
(
contentLength
!
=
int64_t
(
-
1
)
&
&
contentLength
!
=
size
)
{
LOG
(
(
"
concurrent
cache
entry
write
has
been
interrupted
"
)
)
;
mCachedResponseHead
=
std
:
:
move
(
mResponseHead
)
;
rv
=
MaybeSetupByteRangeRequest
(
size
contentLength
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
LoadIsPartialRequest
(
)
)
{
mCachedContentIsValid
=
false
;
StoreCachedContentIsPartial
(
1
)
;
rv
=
ContinueConnect
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
performing
range
request
"
)
)
;
mCachePump
=
nullptr
;
return
NS_OK
;
}
LOG
(
(
"
but
range
request
perform
failed
0x
%
08
"
PRIx32
static_cast
<
uint32_t
>
(
rv
)
)
)
;
aStatus
=
NS_ERROR_NET_INTERRUPT
;
}
else
{
LOG
(
(
"
but
range
request
setup
failed
rv
=
0x
%
08
"
PRIx32
"
failing
load
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
}
}
StoreIsPending
(
false
)
;
mStatus
=
aStatus
;
if
(
mCacheEntry
&
&
LoadRequestTimeInitialized
(
)
)
{
bool
writeAccess
;
mCacheEntry
-
>
HasWriteAccess
(
!
LoadCacheEntryIsReadOnly
(
)
&
writeAccess
)
;
if
(
writeAccess
)
{
nsresult
rv
=
FinalizeCacheEntry
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
FinalizeCacheEntry
failed
(
%
08x
)
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
}
ReportRcwnStats
(
aIsFromNet
)
;
MaybeReportTimingData
(
)
;
MaybeFlushConsoleReports
(
)
;
if
(
!
mEndMarkerAdded
&
&
profiler_thread_is_being_profiled_for_markers
(
)
)
{
mEndMarkerAdded
=
true
;
nsAutoCString
requestMethod
;
GetRequestMethod
(
requestMethod
)
;
int32_t
priority
=
PRIORITY_NORMAL
;
GetPriority
(
&
priority
)
;
uint64_t
size
=
0
;
GetEncodedBodySize
(
&
size
)
;
nsAutoCString
contentType
;
if
(
mResponseHead
)
{
mResponseHead
-
>
ContentType
(
contentType
)
;
}
profiler_add_network_marker
(
mURI
requestMethod
priority
mChannelId
NetworkLoadType
:
:
LOAD_STOP
mLastStatusReported
TimeStamp
:
:
Now
(
)
size
mCacheDisposition
mLoadInfo
-
>
GetInnerWindowID
(
)
mLoadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
>
0
&
mTransactionTimings
std
:
:
move
(
mSource
)
Some
(
nsDependentCString
(
contentType
.
get
(
)
)
)
)
;
}
if
(
mListener
)
{
LOG
(
(
"
nsHttpChannel
%
p
calling
OnStopRequest
\
n
"
this
)
)
;
MOZ_ASSERT
(
LoadOnStartRequestCalled
(
)
"
OnStartRequest
should
be
called
before
OnStopRequest
"
)
;
MOZ_ASSERT
(
!
LoadOnStopRequestCalled
(
)
"
We
should
not
call
OnStopRequest
twice
"
)
;
StoreOnStopRequestCalled
(
true
)
;
mListener
-
>
OnStopRequest
(
this
aStatus
)
;
}
StoreOnStopRequestCalled
(
true
)
;
mDNSPrefetch
=
nullptr
;
gHttpHandler
-
>
OnStopRequest
(
this
)
;
RemoveAsNonTailRequest
(
)
;
if
(
!
mPreferredCachedAltDataTypes
.
IsEmpty
(
)
)
{
mAltDataCacheEntry
=
mCacheEntry
;
}
CloseCacheEntry
(
!
aContentComplete
)
;
if
(
mLoadGroup
)
{
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
aStatus
)
;
}
CleanRedirectCacheChainIfNecessary
(
)
;
ReleaseListeners
(
)
;
return
NS_OK
;
}
class
OnTransportStatusAsyncEvent
:
public
Runnable
{
public
:
OnTransportStatusAsyncEvent
(
nsITransportEventSink
*
aEventSink
nsresult
aTransportStatus
int64_t
aProgress
int64_t
aProgressMax
)
:
Runnable
(
"
net
:
:
OnTransportStatusAsyncEvent
"
)
mEventSink
(
aEventSink
)
mTransportStatus
(
aTransportStatus
)
mProgress
(
aProgress
)
mProgressMax
(
aProgressMax
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
Shouldn
'
t
be
created
on
main
thread
"
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
run
on
main
thread
"
)
;
if
(
mEventSink
)
{
mEventSink
-
>
OnTransportStatus
(
nullptr
mTransportStatus
mProgress
mProgressMax
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsITransportEventSink
>
mEventSink
;
nsresult
mTransportStatus
;
int64_t
mProgress
;
int64_t
mProgressMax
;
}
;
NS_IMETHODIMP
nsHttpChannel
:
:
OnDataAvailable
(
nsIRequest
*
request
nsIInputStream
*
input
uint64_t
offset
uint32_t
count
)
{
nsresult
rv
;
AUTO_PROFILER_LABEL
(
"
nsHttpChannel
:
:
OnDataAvailable
"
NETWORK
)
;
LOG
(
(
"
nsHttpChannel
:
:
OnDataAvailable
[
this
=
%
p
request
=
%
p
offset
=
%
"
PRIu64
"
count
=
%
"
PRIu32
"
]
\
n
"
this
request
offset
count
)
)
;
LOG
(
(
"
requestFromCache
:
%
d
mFirstResponseSource
:
%
d
\
n
"
request
=
=
mCachePump
static_cast
<
int32_t
>
(
mFirstResponseSource
)
)
)
;
if
(
mCanceled
)
return
mStatus
;
if
(
mAuthRetryPending
|
|
WRONG_RACING_RESPONSE_SOURCE
(
request
)
|
|
(
request
=
=
mTransactionPump
&
&
LoadTransactionReplaced
(
)
)
)
{
uint32_t
n
;
return
input
-
>
ReadSegments
(
NS_DiscardSegment
nullptr
count
&
n
)
;
}
MOZ_ASSERT
(
mResponseHead
"
No
response
head
in
ODA
!
!
"
)
;
MOZ_ASSERT
(
!
(
LoadCachedContentIsPartial
(
)
&
&
(
request
=
=
mTransactionPump
)
)
"
transaction
pump
not
suspended
"
)
;
mIsReadingFromCache
=
(
request
=
=
mCachePump
)
;
if
(
mListener
)
{
nsresult
transportStatus
;
if
(
request
=
=
mCachePump
)
{
transportStatus
=
NS_NET_STATUS_READING
;
}
else
{
transportStatus
=
NS_NET_STATUS_RECEIVING_FROM
;
}
int64_t
progressMax
=
-
1
;
rv
=
GetContentLength
(
&
progressMax
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
GetContentLength
failed
"
)
;
}
int64_t
progress
=
mLogicalOffset
+
count
;
if
(
(
progress
>
progressMax
)
&
&
(
progressMax
!
=
-
1
)
)
{
NS_WARNING
(
"
unexpected
progress
values
-
"
"
is
server
exceeding
content
length
?
"
)
;
}
if
(
!
InScriptableRange
(
progressMax
)
)
{
progressMax
=
-
1
;
}
if
(
!
InScriptableRange
(
progress
)
)
{
progress
=
-
1
;
}
if
(
NS_IsMainThread
(
)
)
{
OnTransportStatus
(
nullptr
transportStatus
progress
progressMax
)
;
}
else
{
rv
=
NS_DispatchToMainThread
(
new
OnTransportStatusAsyncEvent
(
this
transportStatus
progress
progressMax
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
int64_t
offsetBefore
=
0
;
nsCOMPtr
<
nsISeekableStream
>
seekable
=
do_QueryInterface
(
input
)
;
if
(
seekable
&
&
NS_FAILED
(
seekable
-
>
Tell
(
&
offsetBefore
)
)
)
{
seekable
=
nullptr
;
}
nsresult
rv
=
mListener
-
>
OnDataAvailable
(
this
input
mLogicalOffset
count
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
auto
isAllowedOrErr
=
EnsureOpaqueResponseIsAllowedAfterSniff
(
)
;
if
(
isAllowedOrErr
.
isErr
(
)
|
|
!
isAllowedOrErr
.
inspect
(
)
)
{
}
int64_t
offsetAfter
delta
;
if
(
seekable
&
&
NS_SUCCEEDED
(
seekable
-
>
Tell
(
&
offsetAfter
)
)
)
{
delta
=
offsetAfter
-
offsetBefore
;
if
(
delta
!
=
count
)
{
count
=
delta
;
NS_WARNING
(
"
Listener
OnDataAvailable
contract
violation
"
)
;
nsCOMPtr
<
nsIConsoleService
>
consoleService
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
nsAutoString
message
(
nsLiteralString
(
u
"
http
channel
Listener
OnDataAvailable
contract
violation
"
)
)
;
if
(
consoleService
)
{
consoleService
-
>
LogStringMessage
(
message
.
get
(
)
)
;
}
}
}
mLogicalOffset
+
=
count
;
}
return
rv
;
}
return
NS_ERROR_ABORT
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
RetargetDeliveryTo
(
nsIEventTarget
*
aNewTarget
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
called
on
main
thread
only
"
)
;
NS_ENSURE_ARG
(
aNewTarget
)
;
if
(
aNewTarget
-
>
IsOnCurrentThread
(
)
)
{
NS_WARNING
(
"
Retargeting
delivery
to
same
thread
"
)
;
return
NS_OK
;
}
if
(
!
mTransactionPump
&
&
!
mCachePump
)
{
LOG
(
(
"
nsHttpChannel
:
:
RetargetDeliveryTo
%
p
%
p
no
pump
available
\
n
"
this
aNewTarget
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIThreadRetargetableRequest
>
retargetableCachePump
;
nsCOMPtr
<
nsIThreadRetargetableRequest
>
retargetableTransactionPump
;
if
(
mCachePump
)
{
retargetableCachePump
=
do_QueryObject
(
mCachePump
)
;
MOZ_ASSERT
(
retargetableCachePump
)
;
rv
=
retargetableCachePump
-
>
RetargetDeliveryTo
(
aNewTarget
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
mTransactionPump
)
{
retargetableTransactionPump
=
do_QueryObject
(
mTransactionPump
)
;
MOZ_ASSERT
(
retargetableTransactionPump
)
;
rv
=
retargetableTransactionPump
-
>
RetargetDeliveryTo
(
aNewTarget
)
;
if
(
NS_FAILED
(
rv
)
&
&
retargetableCachePump
)
{
nsCOMPtr
<
nsIEventTarget
>
main
=
GetMainThreadEventTarget
(
)
;
NS_ENSURE_TRUE
(
main
NS_ERROR_UNEXPECTED
)
;
rv
=
retargetableCachePump
-
>
RetargetDeliveryTo
(
main
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetDeliveryTarget
(
nsIEventTarget
*
*
aEventTarget
)
{
if
(
mCachePump
)
{
return
mCachePump
-
>
GetDeliveryTarget
(
aEventTarget
)
;
}
if
(
mTransactionPump
)
{
nsCOMPtr
<
nsIThreadRetargetableRequest
>
request
=
do_QueryInterface
(
mTransactionPump
)
;
return
request
-
>
GetDeliveryTarget
(
aEventTarget
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
CheckListenerChain
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
main
thread
!
"
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIThreadRetargetableStreamListener
>
retargetableListener
=
do_QueryInterface
(
mListener
&
rv
)
;
if
(
retargetableListener
)
{
rv
=
retargetableListener
-
>
CheckListenerChain
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnTransportStatus
(
nsITransport
*
trans
nsresult
status
int64_t
progress
int64_t
progressMax
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
on
main
thread
only
"
)
;
if
(
!
mProgressSink
)
GetCallback
(
mProgressSink
)
;
if
(
status
=
=
NS_NET_STATUS_CONNECTED_TO
|
|
status
=
=
NS_NET_STATUS_WAITING_FOR
)
{
bool
isTrr
=
false
;
bool
echConfigUsed
=
false
;
if
(
mTransaction
)
{
mTransaction
-
>
GetNetworkAddresses
(
mSelfAddr
mPeerAddr
isTrr
echConfigUsed
)
;
}
else
{
nsCOMPtr
<
nsISocketTransport
>
socketTransport
=
do_QueryInterface
(
trans
)
;
if
(
socketTransport
)
{
socketTransport
-
>
GetSelfAddr
(
&
mSelfAddr
)
;
socketTransport
-
>
GetPeerAddr
(
&
mPeerAddr
)
;
socketTransport
-
>
ResolvedByTRR
(
&
isTrr
)
;
socketTransport
-
>
GetEchConfigUsed
(
&
echConfigUsed
)
;
}
}
StoreResolvedByTRR
(
isTrr
)
;
StoreEchConfigUsed
(
echConfigUsed
)
;
}
if
(
mProgressSink
&
&
NS_SUCCEEDED
(
mStatus
)
&
&
LoadIsPending
(
)
)
{
LOG
(
(
"
sending
progress
%
s
notification
[
this
=
%
p
status
=
%
"
PRIx32
"
progress
=
%
"
PRId64
"
/
%
"
PRId64
"
]
\
n
"
(
mLoadFlags
&
LOAD_BACKGROUND
)
?
"
"
:
"
and
status
"
this
static_cast
<
uint32_t
>
(
status
)
progress
progressMax
)
)
;
nsAutoCString
host
;
mURI
-
>
GetHost
(
host
)
;
if
(
!
(
mLoadFlags
&
LOAD_BACKGROUND
)
)
{
mProgressSink
-
>
OnStatus
(
this
status
NS_ConvertUTF8toUTF16
(
host
)
.
get
(
)
)
;
}
else
{
nsCOMPtr
<
nsIParentChannel
>
parentChannel
;
NS_QueryNotificationCallbacks
(
this
parentChannel
)
;
if
(
SameCOMIdentity
(
parentChannel
mProgressSink
)
)
{
mProgressSink
-
>
OnStatus
(
this
status
NS_ConvertUTF8toUTF16
(
host
)
.
get
(
)
)
;
}
}
if
(
progress
>
0
)
{
if
(
(
progress
>
progressMax
)
&
&
(
progressMax
!
=
-
1
)
)
{
NS_WARNING
(
"
unexpected
progress
values
"
)
;
}
if
(
!
mProgressSink
)
{
GetCallback
(
mProgressSink
)
;
}
if
(
mProgressSink
)
{
mProgressSink
-
>
OnProgress
(
this
progress
progressMax
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
IsFromCache
(
bool
*
value
)
{
if
(
!
LoadIsPending
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
if
(
!
mRaceCacheWithNetwork
)
{
*
value
=
(
mCachePump
|
|
(
mLoadFlags
&
LOAD_ONLY_IF_MODIFIED
)
)
&
&
mCachedContentIsValid
&
&
!
LoadCachedContentIsPartial
(
)
;
return
NS_OK
;
}
*
value
=
mFirstResponseSource
=
=
RESPONSE_FROM_CACHE
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetCacheEntryId
(
uint64_t
*
aCacheEntryId
)
{
bool
fromCache
=
false
;
if
(
NS_FAILED
(
IsFromCache
(
&
fromCache
)
)
|
|
!
fromCache
|
|
!
mCacheEntry
|
|
NS_FAILED
(
mCacheEntry
-
>
GetCacheEntryId
(
aCacheEntryId
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetCacheTokenFetchCount
(
uint32_t
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
nsCOMPtr
<
nsICacheEntry
>
cacheEntry
=
mCacheEntry
?
mCacheEntry
:
mAltDataCacheEntry
;
if
(
!
cacheEntry
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
cacheEntry
-
>
GetFetchCount
(
_retval
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetCacheTokenExpirationTime
(
uint32_t
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
!
mCacheEntry
)
return
NS_ERROR_NOT_AVAILABLE
;
return
mCacheEntry
-
>
GetExpirationTime
(
_retval
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetAllowStaleCacheContent
(
bool
aAllowStaleCacheContent
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetAllowStaleCacheContent
[
this
=
%
p
allow
=
%
d
]
"
this
aAllowStaleCacheContent
)
)
;
StoreAllowStaleCacheContent
(
aAllowStaleCacheContent
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetAllowStaleCacheContent
(
bool
*
aAllowStaleCacheContent
)
{
NS_ENSURE_ARG
(
aAllowStaleCacheContent
)
;
*
aAllowStaleCacheContent
=
LoadAllowStaleCacheContent
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetForceValidateCacheContent
(
bool
aForceValidateCacheContent
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetForceValidateCacheContent
[
this
=
%
p
allow
=
%
d
]
"
this
aForceValidateCacheContent
)
)
;
StoreForceValidateCacheContent
(
aForceValidateCacheContent
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetForceValidateCacheContent
(
bool
*
aForceValidateCacheContent
)
{
NS_ENSURE_ARG
(
aForceValidateCacheContent
)
;
*
aForceValidateCacheContent
=
LoadForceValidateCacheContent
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetPreferCacheLoadOverBypass
(
bool
aPreferCacheLoadOverBypass
)
{
StorePreferCacheLoadOverBypass
(
aPreferCacheLoadOverBypass
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetPreferCacheLoadOverBypass
(
bool
*
aPreferCacheLoadOverBypass
)
{
NS_ENSURE_ARG
(
aPreferCacheLoadOverBypass
)
;
*
aPreferCacheLoadOverBypass
=
LoadPreferCacheLoadOverBypass
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
PreferAlternativeDataType
(
const
nsACString
&
aType
const
nsACString
&
aContentType
PreferredAlternativeDataDeliveryType
aDeliverAltData
)
{
ENSURE_CALLED_BEFORE_ASYNC_OPEN
(
)
;
mPreferredCachedAltDataTypes
.
AppendElement
(
PreferredAlternativeDataTypeParams
(
nsCString
(
aType
)
nsCString
(
aContentType
)
aDeliverAltData
)
)
;
return
NS_OK
;
}
const
nsTArray
<
PreferredAlternativeDataTypeParams
>
&
nsHttpChannel
:
:
PreferredAlternativeDataTypes
(
)
{
return
mPreferredCachedAltDataTypes
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetAlternativeDataType
(
nsACString
&
aType
)
{
if
(
!
LoadAfterOnStartRequestBegun
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
aType
=
mAvailableCachedAltDataType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OpenAlternativeOutputStream
(
const
nsACString
&
type
int64_t
predictedSize
nsIAsyncOutputStream
*
*
_retval
)
{
nsCOMPtr
<
nsICacheEntry
>
cacheEntry
=
mCacheEntry
?
mCacheEntry
:
mAltDataCacheEntry
;
if
(
!
cacheEntry
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
cacheEntry
-
>
OpenAlternativeOutputStream
(
type
predictedSize
_retval
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
cacheEntry
-
>
SetMetaDataElement
(
"
alt
-
data
-
from
-
child
"
nullptr
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetOriginalInputStream
(
nsIInputStreamReceiver
*
aReceiver
)
{
if
(
aReceiver
=
=
nullptr
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIInputStream
>
inputStream
;
nsCOMPtr
<
nsICacheEntry
>
cacheEntry
=
mCacheEntry
?
mCacheEntry
:
mAltDataCacheEntry
;
if
(
cacheEntry
)
{
cacheEntry
-
>
OpenInputStream
(
0
getter_AddRefs
(
inputStream
)
)
;
}
aReceiver
-
>
OnInputStreamReady
(
inputStream
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetAlternativeDataInputStream
(
nsIInputStream
*
*
aInputStream
)
{
NS_ENSURE_ARG_POINTER
(
aInputStream
)
;
*
aInputStream
=
nullptr
;
nsCOMPtr
<
nsICacheEntry
>
cacheEntry
=
mCacheEntry
?
mCacheEntry
:
mAltDataCacheEntry
;
if
(
!
mAvailableCachedAltDataType
.
IsEmpty
(
)
&
&
cacheEntry
)
{
nsresult
rv
=
cacheEntry
-
>
OpenAlternativeInputStream
(
mAvailableCachedAltDataType
aInputStream
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
IsRacing
(
bool
*
aIsRacing
)
{
if
(
!
LoadAfterOnStartRequestBegun
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aIsRacing
=
mRaceCacheWithNetwork
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetCacheToken
(
nsISupports
*
*
token
)
{
NS_ENSURE_ARG_POINTER
(
token
)
;
if
(
!
mCacheEntry
)
return
NS_ERROR_NOT_AVAILABLE
;
return
CallQueryInterface
(
mCacheEntry
token
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetCacheToken
(
nsISupports
*
token
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetCacheKey
(
uint32_t
*
key
)
{
NS_ENSURE_ARG_POINTER
(
key
)
;
LOG
(
(
"
nsHttpChannel
:
:
GetCacheKey
[
this
=
%
p
]
\
n
"
this
)
)
;
*
key
=
mPostID
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetCacheKey
(
uint32_t
key
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetCacheKey
[
this
=
%
p
key
=
%
u
]
\
n
"
this
key
)
)
;
ENSURE_CALLED_BEFORE_CONNECT
(
)
;
mPostID
=
key
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetCacheOnlyMetadata
(
bool
*
aOnlyMetadata
)
{
NS_ENSURE_ARG
(
aOnlyMetadata
)
;
*
aOnlyMetadata
=
LoadCacheOnlyMetadata
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetCacheOnlyMetadata
(
bool
aOnlyMetadata
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetCacheOnlyMetadata
[
this
=
%
p
only
-
metadata
=
%
d
]
\
n
"
this
aOnlyMetadata
)
)
;
ENSURE_CALLED_BEFORE_ASYNC_OPEN
(
)
;
StoreCacheOnlyMetadata
(
aOnlyMetadata
)
;
if
(
aOnlyMetadata
)
{
mLoadFlags
|
=
LOAD_ONLY_IF_MODIFIED
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
GetPin
(
bool
*
aPin
)
{
NS_ENSURE_ARG
(
aPin
)
;
*
aPin
=
LoadPinCacheContent
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetPin
(
bool
aPin
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetPin
[
this
=
%
p
pin
=
%
d
]
\
n
"
this
aPin
)
)
;
ENSURE_CALLED_BEFORE_CONNECT
(
)
;
StorePinCacheContent
(
aPin
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
ForceCacheEntryValidFor
(
uint32_t
aSecondsToTheFuture
)
{
if
(
!
mCacheEntry
)
{
LOG
(
(
"
nsHttpChannel
:
:
ForceCacheEntryValidFor
found
no
cache
entry
"
"
for
this
channel
[
this
=
%
p
]
.
"
this
)
)
;
}
else
{
mCacheEntry
-
>
ForceValidFor
(
aSecondsToTheFuture
)
;
nsAutoCString
key
;
mCacheEntry
-
>
GetKey
(
key
)
;
LOG
(
(
"
nsHttpChannel
:
:
ForceCacheEntryValidFor
successfully
forced
valid
"
"
entry
with
key
%
s
for
%
d
seconds
.
[
this
=
%
p
]
"
key
.
get
(
)
aSecondsToTheFuture
this
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
ResumeAt
(
uint64_t
aStartPos
const
nsACString
&
aEntityID
)
{
LOG
(
(
"
nsHttpChannel
:
:
ResumeAt
[
this
=
%
p
startPos
=
%
"
PRIu64
"
id
=
'
%
s
'
]
\
n
"
this
aStartPos
PromiseFlatCString
(
aEntityID
)
.
get
(
)
)
)
;
mEntityID
=
aEntityID
;
mStartPos
=
aStartPos
;
StoreResuming
(
true
)
;
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
DoAuthRetry
(
HttpTransactionShell
*
aTransWithStickyConn
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueOnStopRequestFunc
)
{
LOG
(
(
"
nsHttpChannel
:
:
DoAuthRetry
[
this
=
%
p
aTransWithStickyConn
=
%
p
]
\
n
"
this
aTransWithStickyConn
)
)
;
MOZ_ASSERT
(
!
mTransaction
"
should
not
have
a
transaction
"
)
;
StoreRequestObserversCalled
(
false
)
;
AddCookiesToRequest
(
)
;
CallOnModifyRequestObservers
(
)
;
RefPtr
<
HttpTransactionShell
>
trans
(
aTransWithStickyConn
)
;
return
CallOrWaitForResume
(
[
trans
{
std
:
:
move
(
trans
)
}
aContinueOnStopRequestFunc
]
(
auto
*
self
)
{
return
self
-
>
ContinueDoAuthRetry
(
trans
aContinueOnStopRequestFunc
)
;
}
)
;
}
nsresult
nsHttpChannel
:
:
ContinueDoAuthRetry
(
HttpTransactionShell
*
aTransWithStickyConn
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueOnStopRequestFunc
)
{
LOG
(
(
"
nsHttpChannel
:
:
ContinueDoAuthRetry
[
this
=
%
p
]
\
n
"
this
)
)
;
StoreIsPending
(
true
)
;
mResponseHead
=
nullptr
;
if
(
mUploadStream
)
{
nsCOMPtr
<
nsISeekableStream
>
seekable
=
do_QueryInterface
(
mUploadStream
)
;
nsresult
rv
=
NS_ERROR_NO_INTERFACE
;
if
(
seekable
)
{
rv
=
seekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mCaps
|
=
NS_HTTP_STICKY_CONNECTION
;
if
(
LoadAuthConnectionRestartable
(
)
)
{
LOG
(
(
"
connection
made
restartable
"
)
)
;
mCaps
|
=
NS_HTTP_CONNECTION_RESTARTABLE
;
StoreAuthConnectionRestartable
(
false
)
;
}
else
{
LOG
(
(
"
connection
made
non
-
restartable
"
)
)
;
mCaps
&
=
~
NS_HTTP_CONNECTION_RESTARTABLE
;
}
gHttpHandler
-
>
OnBeforeConnect
(
this
)
;
RefPtr
<
HttpTransactionShell
>
trans
(
aTransWithStickyConn
)
;
return
CallOrWaitForResume
(
[
trans
{
std
:
:
move
(
trans
)
}
aContinueOnStopRequestFunc
]
(
auto
*
self
)
{
nsresult
rv
=
self
-
>
DoConnect
(
trans
)
;
return
aContinueOnStopRequestFunc
(
self
rv
)
;
}
)
;
}
nsresult
nsHttpChannel
:
:
WaitForRedirectCallback
(
)
{
nsresult
rv
;
LOG
(
(
"
nsHttpChannel
:
:
WaitForRedirectCallback
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mTransactionPump
)
{
rv
=
mTransactionPump
-
>
Suspend
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
mCachePump
)
{
rv
=
mCachePump
-
>
Suspend
(
)
;
if
(
NS_FAILED
(
rv
)
&
&
mTransactionPump
)
{
#
ifdef
DEBUG
nsresult
resume
=
#
endif
mTransactionPump
-
>
Resume
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
resume
)
"
Failed
to
resume
transaction
pump
"
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
StoreWaitingForRedirectCallback
(
true
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnRedirectVerifyCallback
(
nsresult
result
)
{
LOG
(
(
"
nsHttpChannel
:
:
OnRedirectVerifyCallback
[
this
=
%
p
]
"
"
result
=
%
"
PRIx32
"
stack
=
%
zu
WaitingForRedirectCallback
=
%
u
\
n
"
this
static_cast
<
uint32_t
>
(
result
)
mRedirectFuncStack
.
Length
(
)
LoadWaitingForRedirectCallback
(
)
)
)
;
MOZ_ASSERT
(
LoadWaitingForRedirectCallback
(
)
"
Someone
forgot
to
call
WaitForRedirectCallback
(
)
?
!
"
)
;
StoreWaitingForRedirectCallback
(
false
)
;
if
(
mCanceled
&
&
NS_SUCCEEDED
(
result
)
)
result
=
NS_BINDING_ABORTED
;
for
(
uint32_t
i
=
mRedirectFuncStack
.
Length
(
)
;
i
>
0
;
)
{
-
-
i
;
nsContinueRedirectionFunc
func
=
mRedirectFuncStack
.
PopLastElement
(
)
;
result
=
(
this
-
>
*
func
)
(
result
)
;
if
(
LoadWaitingForRedirectCallback
(
)
)
break
;
}
if
(
NS_FAILED
(
result
)
&
&
!
mCanceled
)
{
Cancel
(
result
)
;
}
if
(
!
LoadWaitingForRedirectCallback
(
)
)
{
mRedirectChannel
=
nullptr
;
}
if
(
mTransactionPump
)
mTransactionPump
-
>
Resume
(
)
;
if
(
mCachePump
)
mCachePump
-
>
Resume
(
)
;
return
result
;
}
void
nsHttpChannel
:
:
PushRedirectAsyncFunc
(
nsContinueRedirectionFunc
func
)
{
mRedirectFuncStack
.
AppendElement
(
func
)
;
}
void
nsHttpChannel
:
:
PopRedirectAsyncFunc
(
nsContinueRedirectionFunc
func
)
{
MOZ_ASSERT
(
func
=
=
mRedirectFuncStack
.
LastElement
(
)
"
Trying
to
pop
wrong
method
from
redirect
async
stack
!
"
)
;
mRedirectFuncStack
.
RemoveLastElement
(
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnLookupComplete
(
nsICancelable
*
request
nsIDNSRecord
*
rec
nsresult
status
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Expecting
DNS
callback
on
main
thread
.
"
)
;
LOG
(
(
"
nsHttpChannel
:
:
OnLookupComplete
[
this
=
%
p
]
prefetch
complete
%
s
:
"
"
%
s
status
[
0x
%
"
PRIx32
"
]
\
n
"
this
mCaps
&
NS_HTTP_REFRESH_DNS
?
"
refresh
requested
"
:
"
"
NS_SUCCEEDED
(
status
)
?
"
success
"
:
"
failure
"
static_cast
<
uint32_t
>
(
status
)
)
)
;
if
(
mCaps
&
NS_HTTP_REFRESH_DNS
)
{
mCaps
&
=
~
NS_HTTP_REFRESH_DNS
;
if
(
mTransaction
)
{
mTransaction
-
>
SetDNSWasRefreshed
(
)
;
}
}
if
(
!
mDNSBlockingPromise
.
IsEmpty
(
)
)
{
if
(
NS_SUCCEEDED
(
status
)
)
{
nsCOMPtr
<
nsIDNSRecord
>
record
(
rec
)
;
mDNSBlockingPromise
.
Resolve
(
record
__func__
)
;
}
else
{
mDNSBlockingPromise
.
Reject
(
status
__func__
)
;
}
}
return
NS_OK
;
}
void
nsHttpChannel
:
:
OnHTTPSRRAvailable
(
nsIDNSHTTPSSVCRecord
*
aRecord
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Expecting
DNS
callback
on
main
thread
.
"
)
;
LOG
(
(
"
nsHttpChannel
:
:
OnHTTPSRRAvailable
[
this
=
%
p
aRecord
=
%
p
]
\
n
"
this
aRecord
)
)
;
if
(
mHTTPSSVCRecord
)
{
MOZ_ASSERT
(
false
"
OnHTTPSRRAvailable
called
twice
!
"
)
;
return
;
}
nsCOMPtr
<
nsIDNSHTTPSSVCRecord
>
record
=
aRecord
;
mHTTPSSVCRecord
.
emplace
(
std
:
:
move
(
record
)
)
;
const
nsCOMPtr
<
nsIDNSHTTPSSVCRecord
>
&
httprr
=
mHTTPSSVCRecord
.
ref
(
)
;
if
(
LoadWaitHTTPSSVCRecord
(
)
)
{
MOZ_ASSERT
(
mURI
-
>
SchemeIs
(
"
http
"
)
)
;
StoreWaitHTTPSSVCRecord
(
false
)
;
nsresult
rv
=
ContinueOnBeforeConnect
(
!
!
httprr
mStatus
!
!
httprr
)
;
if
(
NS_FAILED
(
rv
)
)
{
CloseCacheEntry
(
false
)
;
Unused
<
<
AsyncAbort
(
rv
)
;
}
}
else
{
if
(
httprr
&
&
NS_SUCCEEDED
(
mStatus
)
&
&
!
mTransaction
&
&
(
mFirstResponseSource
!
=
RESPONSE_FROM_CACHE
)
)
{
bool
hasIPAddress
=
false
;
Unused
<
<
httprr
-
>
GetHasIPAddresses
(
&
hasIPAddress
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
DNS_HTTPSSVC_RECORD_RECEIVING_STAGE
hasIPAddress
?
HTTPSSVC_WITH_IPHINT_RECEIVED_STAGE_0
:
HTTPSSVC_WITHOUT_IPHINT_RECEIVED_STAGE_0
)
;
StoreHTTPSSVCTelemetryReported
(
true
)
;
}
}
}
nsresult
nsHttpChannel
:
:
CreateNewURI
(
const
char
*
loc
nsIURI
*
*
newURI
)
{
nsCOMPtr
<
nsIIOService
>
ioService
;
nsresult
rv
=
gHttpHandler
-
>
GetIOService
(
getter_AddRefs
(
ioService
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
ioService
-
>
NewURI
(
nsDependentCString
(
loc
)
nullptr
mURI
newURI
)
;
}
void
nsHttpChannel
:
:
MaybeInvalidateCacheEntryForSubsequentGet
(
)
{
if
(
mRequestHead
.
IsGet
(
)
|
|
mRequestHead
.
IsOptions
(
)
|
|
mRequestHead
.
IsHead
(
)
|
|
mRequestHead
.
IsTrace
(
)
|
|
mRequestHead
.
IsConnect
(
)
)
{
return
;
}
if
(
LOG_ENABLED
(
)
)
{
nsAutoCString
key
;
mURI
-
>
GetAsciiSpec
(
key
)
;
LOG
(
(
"
MaybeInvalidateCacheEntryForSubsequentGet
[
this
=
%
p
uri
=
%
s
]
\
n
"
this
key
.
get
(
)
)
)
;
}
DoInvalidateCacheEntry
(
mURI
)
;
nsAutoCString
location
;
Unused
<
<
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Location
location
)
;
if
(
!
location
.
IsEmpty
(
)
)
{
LOG
(
(
"
Location
-
header
=
%
s
\
n
"
location
.
get
(
)
)
)
;
InvalidateCacheEntryForLocation
(
location
.
get
(
)
)
;
}
Unused
<
<
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Content_Location
location
)
;
if
(
!
location
.
IsEmpty
(
)
)
{
LOG
(
(
"
Content
-
Location
-
header
=
%
s
\
n
"
location
.
get
(
)
)
)
;
InvalidateCacheEntryForLocation
(
location
.
get
(
)
)
;
}
}
void
nsHttpChannel
:
:
InvalidateCacheEntryForLocation
(
const
char
*
location
)
{
nsAutoCString
tmpCacheKey
tmpSpec
;
nsCOMPtr
<
nsIURI
>
resultingURI
;
nsresult
rv
=
CreateNewURI
(
location
getter_AddRefs
(
resultingURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
HostPartIsTheSame
(
resultingURI
)
)
{
DoInvalidateCacheEntry
(
resultingURI
)
;
}
else
{
LOG
(
(
"
hosts
not
matching
\
n
"
)
)
;
}
}
void
nsHttpChannel
:
:
DoInvalidateCacheEntry
(
nsIURI
*
aURI
)
{
nsresult
rv
;
nsAutoCString
key
;
if
(
LOG_ENABLED
(
)
)
{
aURI
-
>
GetAsciiSpec
(
key
)
;
}
LOG
(
(
"
DoInvalidateCacheEntry
[
channel
=
%
p
key
=
%
s
]
"
this
key
.
get
(
)
)
)
;
nsCOMPtr
<
nsICacheStorageService
>
cacheStorageService
(
components
:
:
CacheStorage
:
:
Service
(
)
)
;
rv
=
cacheStorageService
?
NS_OK
:
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsICacheStorage
>
cacheStorage
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
RefPtr
<
LoadContextInfo
>
info
=
GetLoadContextInfo
(
this
)
;
rv
=
cacheStorageService
-
>
DiskCacheStorage
(
info
getter_AddRefs
(
cacheStorage
)
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
cacheStorage
-
>
AsyncDoomURI
(
aURI
"
"
_ns
nullptr
)
;
}
LOG
(
(
"
DoInvalidateCacheEntry
[
channel
=
%
p
key
=
%
s
rv
=
%
d
]
"
this
key
.
get
(
)
int
(
rv
)
)
)
;
}
void
nsHttpChannel
:
:
AsyncOnExamineCachedResponse
(
)
{
gHttpHandler
-
>
OnExamineCachedResponse
(
this
)
;
}
void
nsHttpChannel
:
:
UpdateAggregateCallbacks
(
)
{
if
(
!
mTransaction
)
{
return
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
NS_NewNotificationCallbacksAggregation
(
mCallbacks
mLoadGroup
GetCurrentEventTarget
(
)
getter_AddRefs
(
callbacks
)
)
;
mTransaction
-
>
SetSecurityCallbacks
(
callbacks
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetLoadGroup
(
nsILoadGroup
*
aLoadGroup
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Wrong
thread
.
"
)
;
nsresult
rv
=
HttpBaseChannel
:
:
SetLoadGroup
(
aLoadGroup
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
UpdateAggregateCallbacks
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetNotificationCallbacks
(
nsIInterfaceRequestor
*
aCallbacks
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Wrong
thread
.
"
)
;
nsresult
rv
=
HttpBaseChannel
:
:
SetNotificationCallbacks
(
aCallbacks
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
UpdateAggregateCallbacks
(
)
;
}
return
rv
;
}
bool
nsHttpChannel
:
:
AwaitingCacheCallbacks
(
)
{
return
LoadWaitForCacheEntry
(
)
!
=
0
;
}
void
nsHttpChannel
:
:
SetPushedStreamTransactionAndId
(
HttpTransactionShell
*
aTransWithPushedStream
uint32_t
aPushedStreamId
)
{
MOZ_ASSERT
(
!
mTransWithPushedStream
)
;
LOG
(
(
"
nsHttpChannel
:
:
SetPushedStreamTransaction
[
this
=
%
p
]
trans
=
%
p
"
this
aTransWithPushedStream
)
)
;
mTransWithPushedStream
=
aTransWithPushedStream
;
mPushedStreamId
=
aPushedStreamId
;
}
nsresult
nsHttpChannel
:
:
OnPush
(
uint32_t
aPushedStreamId
const
nsACString
&
aUrl
const
nsACString
&
aRequestString
HttpTransactionShell
*
aTransaction
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aTransaction
)
;
LOG
(
(
"
nsHttpChannel
:
:
OnPush
[
this
=
%
p
trans
=
%
p
]
\
n
"
this
aTransaction
)
)
;
MOZ_ASSERT
(
mCaps
&
NS_HTTP_ONPUSH_LISTENER
)
;
nsCOMPtr
<
nsIHttpPushListener
>
pushListener
;
NS_QueryNotificationCallbacks
(
mCallbacks
mLoadGroup
NS_GET_IID
(
nsIHttpPushListener
)
getter_AddRefs
(
pushListener
)
)
;
if
(
!
pushListener
)
{
LOG
(
(
"
nsHttpChannel
:
:
OnPush
[
this
=
%
p
]
notification
callbacks
do
not
"
"
implement
nsIHttpPushListener
\
n
"
this
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIURI
>
pushResource
;
nsresult
rv
;
rv
=
NS_NewURI
(
getter_AddRefs
(
pushResource
)
aUrl
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIIOService
>
ioService
;
rv
=
gHttpHandler
-
>
GetIOService
(
getter_AddRefs
(
ioService
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIChannel
>
pushChannel
;
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
pushChannel
)
pushResource
mLoadInfo
nullptr
nullptr
nullptr
nsIRequest
:
:
LOAD_NORMAL
ioService
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
pushHttpChannel
=
do_QueryInterface
(
pushChannel
)
;
MOZ_ASSERT
(
pushHttpChannel
)
;
if
(
!
pushHttpChannel
)
{
return
NS_ERROR_UNEXPECTED
;
}
RefPtr
<
nsHttpChannel
>
channel
;
CallQueryInterface
(
pushHttpChannel
channel
.
StartAssignment
(
)
)
;
MOZ_ASSERT
(
channel
)
;
if
(
!
channel
)
{
return
NS_ERROR_UNEXPECTED
;
}
channel
-
>
mRequestHead
.
ParseHeaderSet
(
aRequestString
.
BeginReading
(
)
)
;
channel
-
>
mLoadGroup
=
mLoadGroup
;
channel
-
>
mLoadInfo
=
mLoadInfo
;
channel
-
>
mCallbacks
=
mCallbacks
;
channel
-
>
SetPushedStreamTransactionAndId
(
aTransaction
aPushedStreamId
)
;
rv
=
pushListener
-
>
OnPush
(
this
pushHttpChannel
)
;
return
rv
;
}
bool
nsHttpChannel
:
:
IsRedirectStatus
(
uint32_t
status
)
{
return
status
=
=
300
|
|
status
=
=
301
|
|
status
=
=
302
|
|
status
=
=
303
|
|
status
=
=
307
|
|
status
=
=
308
;
}
void
nsHttpChannel
:
:
SetCouldBeSynthesized
(
)
{
MOZ_ASSERT
(
!
BypassServiceWorker
(
)
)
;
StoreResponseCouldBeSynthesized
(
true
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnPreflightSucceeded
(
)
{
MOZ_ASSERT
(
LoadRequireCORSPreflight
(
)
"
Why
did
a
preflight
happen
?
"
)
;
StoreIsCorsPreflightDone
(
1
)
;
mPreflightChannel
=
nullptr
;
return
ContinueConnect
(
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnPreflightFailed
(
nsresult
aError
)
{
MOZ_ASSERT
(
LoadRequireCORSPreflight
(
)
"
Why
did
a
preflight
happen
?
"
)
;
StoreIsCorsPreflightDone
(
1
)
;
mPreflightChannel
=
nullptr
;
CloseCacheEntry
(
false
)
;
Unused
<
<
AsyncAbort
(
aError
)
;
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
CallOrWaitForResume
(
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
)
>
&
aFunc
)
{
if
(
mCanceled
)
{
MOZ_ASSERT
(
NS_FAILED
(
mStatus
)
)
;
return
mStatus
;
}
if
(
mSuspendCount
)
{
LOG
(
(
"
Waiting
until
resume
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
!
mCallOnResume
)
;
mCallOnResume
=
aFunc
;
return
NS_OK
;
}
return
aFunc
(
this
)
;
}
static
bool
HasNullRequestOrigin
(
nsHttpChannel
*
aChannel
nsIURI
*
aURI
bool
isAddonRequest
)
{
if
(
aChannel
-
>
HasRedirectTaintedOrigin
(
)
)
{
if
(
StaticPrefs
:
:
network_http_origin_redirectTainted
(
)
)
{
return
true
;
}
}
if
(
!
ReferrerInfo
:
:
IsReferrerSchemeAllowed
(
aURI
)
)
{
if
(
!
aURI
-
>
SchemeIs
(
"
moz
-
extension
"
)
|
|
!
isAddonRequest
)
{
return
true
;
}
}
if
(
StaticPrefs
:
:
network_http_referer_hideOnionSource
(
)
)
{
nsAutoCString
host
;
if
(
NS_SUCCEEDED
(
aURI
-
>
GetAsciiHost
(
host
)
)
&
&
StringEndsWith
(
host
"
.
onion
"
_ns
)
)
{
return
ReferrerInfo
:
:
IsCrossOriginRequest
(
aChannel
)
;
}
}
return
false
;
}
void
nsHttpChannel
:
:
SetOriginHeader
(
)
{
auto
*
triggeringPrincipal
=
BasePrincipal
:
:
Cast
(
mLoadInfo
-
>
TriggeringPrincipal
(
)
)
;
if
(
triggeringPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
;
}
bool
isAddonRequest
=
triggeringPrincipal
-
>
AddonPolicy
(
)
|
|
triggeringPrincipal
-
>
ContentScriptAddonPolicy
(
)
;
nsAutoCString
existingHeader
;
Unused
<
<
mRequestHead
.
GetHeader
(
nsHttp
:
:
Origin
existingHeader
)
;
if
(
!
existingHeader
.
IsEmpty
(
)
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetOriginHeader
Origin
header
already
present
"
)
)
;
auto
const
shouldNullifyOriginHeader
=
[
&
existingHeader
isAddonRequest
]
(
nsHttpChannel
*
aChannel
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
existingHeader
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
HasNullRequestOrigin
(
aChannel
uri
isAddonRequest
)
)
{
return
true
;
}
nsCOMPtr
<
nsILoadInfo
>
info
=
aChannel
-
>
LoadInfo
(
)
;
if
(
info
-
>
GetTainting
(
)
=
=
mozilla
:
:
LoadTainting
:
:
CORS
)
{
return
false
;
}
return
ReferrerInfo
:
:
ShouldSetNullOriginHeader
(
aChannel
uri
)
;
}
;
if
(
!
existingHeader
.
EqualsLiteral
(
"
null
"
)
&
&
shouldNullifyOriginHeader
(
this
)
)
{
LOG
(
(
"
nsHttpChannel
:
:
SetOriginHeader
null
Origin
by
Referrer
-
Policy
"
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
mRequestHead
.
SetHeader
(
nsHttp
:
:
Origin
"
null
"
_ns
false
)
)
;
}
return
;
}
if
(
StaticPrefs
:
:
network_http_sendOriginHeader
(
)
=
=
0
)
{
return
;
}
nsAutoCString
serializedOrigin
;
nsCOMPtr
<
nsIURI
>
uri
;
{
if
(
NS_FAILED
(
triggeringPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
)
)
{
return
;
}
if
(
!
uri
)
{
if
(
isAddonRequest
)
{
return
;
}
serializedOrigin
.
AssignLiteral
(
"
null
"
)
;
}
else
if
(
HasNullRequestOrigin
(
this
uri
isAddonRequest
)
)
{
serializedOrigin
.
AssignLiteral
(
"
null
"
)
;
}
else
{
nsContentUtils
:
:
GetASCIIOrigin
(
uri
serializedOrigin
)
;
}
}
if
(
mLoadInfo
-
>
GetTainting
(
)
=
=
mozilla
:
:
LoadTainting
:
:
CORS
)
{
MOZ_ALWAYS_SUCCEEDS
(
mRequestHead
.
SetHeader
(
nsHttp
:
:
Origin
serializedOrigin
false
)
)
;
return
;
}
if
(
mRequestHead
.
IsGet
(
)
|
|
mRequestHead
.
IsHead
(
)
)
{
return
;
}
if
(
!
serializedOrigin
.
EqualsLiteral
(
"
null
"
)
)
{
if
(
ReferrerInfo
:
:
ShouldSetNullOriginHeader
(
this
uri
)
)
{
serializedOrigin
.
AssignLiteral
(
"
null
"
)
;
}
else
if
(
StaticPrefs
:
:
network_http_sendOriginHeader
(
)
=
=
1
)
{
nsAutoCString
currentOrigin
;
nsContentUtils
:
:
GetASCIIOrigin
(
mURI
currentOrigin
)
;
if
(
!
serializedOrigin
.
EqualsIgnoreCase
(
currentOrigin
.
get
(
)
)
)
{
serializedOrigin
.
AssignLiteral
(
"
null
"
)
;
}
}
}
MOZ_ALWAYS_SUCCEEDS
(
mRequestHead
.
SetHeader
(
nsHttp
:
:
Origin
serializedOrigin
false
)
)
;
}
void
nsHttpChannel
:
:
SetDoNotTrack
(
)
{
nsCOMPtr
<
nsILoadContext
>
loadContext
;
NS_QueryNotificationCallbacks
(
this
loadContext
)
;
if
(
(
loadContext
&
&
loadContext
-
>
UseTrackingProtection
(
)
)
|
|
StaticPrefs
:
:
privacy_donottrackheader_enabled
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
DoNotTrack
"
1
"
_ns
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
void
nsHttpChannel
:
:
SetGlobalPrivacyControl
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
the
main
thread
"
)
;
if
(
StaticPrefs
:
:
privacy_globalprivacycontrol_enabled
(
)
&
&
StaticPrefs
:
:
privacy_globalprivacycontrol_functionality_enabled
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
GlobalPrivacyControl
"
1
"
_ns
false
)
;
}
}
void
nsHttpChannel
:
:
ReportRcwnStats
(
bool
isFromNet
)
{
if
(
!
StaticPrefs
:
:
network_http_rcwn_enabled
(
)
)
{
return
;
}
if
(
isFromNet
)
{
if
(
mRaceCacheWithNetwork
)
{
gIOService
-
>
IncrementNetWonRequestNumber
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_RACE_CACHE_BANDWIDTH_RACE_NETWORK_WIN
mTransferSize
)
;
if
(
mRaceDelay
)
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_RACE_CACHE_WITH_NETWORK_USAGE_2
:
:
NetworkDelayedRace
)
;
}
else
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_RACE_CACHE_WITH_NETWORK_USAGE_2
:
:
NetworkRace
)
;
}
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_RACE_CACHE_BANDWIDTH_NOT_RACE
mTransferSize
)
;
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_RACE_CACHE_WITH_NETWORK_USAGE_2
:
:
NetworkNoRace
)
;
}
}
else
{
if
(
mRaceCacheWithNetwork
|
|
mRaceDelay
)
{
gIOService
-
>
IncrementCacheWonRequestNumber
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_RACE_CACHE_BANDWIDTH_RACE_CACHE_WIN
mTransferSize
)
;
if
(
mRaceDelay
)
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_RACE_CACHE_WITH_NETWORK_USAGE_2
:
:
CacheDelayedRace
)
;
}
else
{
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_RACE_CACHE_WITH_NETWORK_USAGE_2
:
:
CacheRace
)
;
}
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
NETWORK_RACE_CACHE_BANDWIDTH_NOT_RACE
mTransferSize
)
;
AccumulateCategorical
(
Telemetry
:
:
LABELS_NETWORK_RACE_CACHE_WITH_NETWORK_USAGE_2
:
:
CacheNoRace
)
;
}
}
gIOService
-
>
IncrementRequestNumber
(
)
;
}
static
const
size_t
kPositiveBucketNumbers
=
34
;
static
const
int64_t
kPositiveBucketLevels
[
kPositiveBucketNumbers
]
=
{
0
10
20
30
40
50
60
70
80
90
100
200
300
400
500
600
700
800
900
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
20000
30000
40000
50000
60000
}
;
inline
int64_t
nsHttpChannel
:
:
ComputeTelemetryBucketNumber
(
int64_t
difftime_ms
)
{
int64_t
absBucketIndex
=
std
:
:
lower_bound
(
kPositiveBucketLevels
kPositiveBucketLevels
+
kPositiveBucketNumbers
static_cast
<
int64_t
>
(
mozilla
:
:
Abs
(
difftime_ms
)
)
)
-
kPositiveBucketLevels
;
return
difftime_ms
>
=
0
?
40
+
absBucketIndex
:
40
-
absBucketIndex
;
}
void
nsHttpChannel
:
:
ReportNetVSCacheTelemetry
(
)
{
nsresult
rv
;
if
(
!
mCacheEntry
)
{
return
;
}
bool
persistent
;
rv
=
mCacheEntry
-
>
GetPersistent
(
&
persistent
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
persistent
)
{
return
;
}
uint64_t
onStartNetTime
=
0
;
if
(
NS_FAILED
(
mCacheEntry
-
>
GetOnStartTime
(
&
onStartNetTime
)
)
)
{
return
;
}
uint64_t
onStopNetTime
=
0
;
if
(
NS_FAILED
(
mCacheEntry
-
>
GetOnStopTime
(
&
onStopNetTime
)
)
)
{
return
;
}
uint64_t
onStartCacheTime
=
(
mOnStartRequestTimestamp
-
mAsyncOpenTime
)
.
ToMilliseconds
(
)
;
int64_t
onStartDiff
=
onStartNetTime
-
onStartCacheTime
;
onStartDiff
=
ComputeTelemetryBucketNumber
(
onStartDiff
)
;
uint64_t
onStopCacheTime
=
(
mCacheReadEnd
-
mAsyncOpenTime
)
.
ToMilliseconds
(
)
;
int64_t
onStopDiff
=
onStopNetTime
-
onStopCacheTime
;
onStopDiff
=
ComputeTelemetryBucketNumber
(
onStopDiff
)
;
if
(
mDidReval
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTART_REVALIDATED_V2
onStartDiff
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTOP_REVALIDATED_V2
onStopDiff
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTART_NOTREVALIDATED_V2
onStartDiff
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTOP_NOTREVALIDATED_V2
onStopDiff
)
;
}
if
(
mDidReval
)
{
return
;
}
if
(
mCacheOpenWithPriority
)
{
if
(
mCacheQueueSizeWhenOpen
<
5
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTART_QSMALL_HIGHPRI_V2
onStartDiff
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTOP_QSMALL_HIGHPRI_V2
onStopDiff
)
;
}
else
if
(
mCacheQueueSizeWhenOpen
<
10
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTART_QMED_HIGHPRI_V2
onStartDiff
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTOP_QMED_HIGHPRI_V2
onStopDiff
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTART_QBIG_HIGHPRI_V2
onStartDiff
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTOP_QBIG_HIGHPRI_V2
onStopDiff
)
;
}
}
else
{
if
(
mCacheQueueSizeWhenOpen
<
10
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTART_QSMALL_NORMALPRI_V2
onStartDiff
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTOP_QSMALL_NORMALPRI_V2
onStopDiff
)
;
}
else
if
(
mCacheQueueSizeWhenOpen
<
50
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTART_QMED_NORMALPRI_V2
onStartDiff
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTOP_QMED_NORMALPRI_V2
onStopDiff
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTART_QBIG_NORMALPRI_V2
onStartDiff
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTOP_QBIG_NORMALPRI_V2
onStopDiff
)
;
}
}
uint32_t
diskStorageSizeK
=
0
;
rv
=
mCacheEntry
-
>
GetDiskStorageSizeInKB
(
&
diskStorageSizeK
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
diskStorageSizeK
<
256
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTOP_SMALL_V2
onStopDiff
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_NET_VS_CACHE_ONSTOP_LARGE_V2
onStopDiff
)
;
}
}
NS_IMETHODIMP
nsHttpChannel
:
:
Test_delayCacheEntryOpeningBy
(
int32_t
aTimeout
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
the
main
thread
"
)
;
mCacheOpenDelay
=
aTimeout
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
Test_triggerDelayedOpenCacheEntry
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
the
main
thread
"
)
;
nsresult
rv
;
if
(
!
mCacheOpenDelay
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
mCacheOpenFunc
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mCacheOpenTimer
)
{
rv
=
mCacheOpenTimer
-
>
Cancel
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mCacheOpenTimer
=
nullptr
;
}
mCacheOpenDelay
=
0
;
std
:
:
function
<
void
(
nsHttpChannel
*
)
>
cacheOpenFunc
=
nullptr
;
std
:
:
swap
(
cacheOpenFunc
mCacheOpenFunc
)
;
cacheOpenFunc
(
this
)
;
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
TriggerNetworkWithDelay
(
uint32_t
aDelay
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
the
main
thread
"
)
;
LOG
(
(
"
nsHttpChannel
:
:
TriggerNetworkWithDelay
[
this
=
%
p
delay
=
%
u
]
\
n
"
this
aDelay
)
)
;
if
(
mCanceled
)
{
LOG
(
(
"
channel
was
canceled
.
\
n
"
)
)
;
return
mStatus
;
}
if
(
mNetworkTriggered
)
{
LOG
(
(
"
network
already
triggered
.
Returning
.
\
n
"
)
)
;
return
NS_OK
;
}
if
(
!
aDelay
)
{
return
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
net
:
:
nsHttpChannel
:
:
TriggerNetworkWithDelay
"
this
&
nsHttpChannel
:
:
TriggerNetwork
)
NS_DISPATCH_NORMAL
)
;
}
if
(
!
mNetworkTriggerTimer
)
{
mNetworkTriggerTimer
=
NS_NewTimer
(
)
;
}
auto
callback
=
MakeRefPtr
<
TimerCallback
>
(
this
)
;
mNetworkTriggerTimer
-
>
InitWithCallback
(
callback
aDelay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
return
NS_OK
;
}
nsresult
nsHttpChannel
:
:
TriggerNetwork
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
the
main
thread
"
)
;
LOG
(
(
"
nsHttpChannel
:
:
TriggerNetwork
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mCanceled
)
{
LOG
(
(
"
channel
was
canceled
.
\
n
"
)
)
;
return
mStatus
;
}
if
(
mNetworkTriggered
)
{
LOG
(
(
"
network
already
triggered
.
Returning
.
\
n
"
)
)
;
return
NS_OK
;
}
mNetworkTriggered
=
true
;
if
(
mNetworkTriggerTimer
)
{
mNetworkTriggerTimer
-
>
Cancel
(
)
;
mNetworkTriggerTimer
=
nullptr
;
}
if
(
mProxyRequest
)
{
LOG
(
(
"
proxy
request
in
progress
.
Delaying
network
trigger
.
\
n
"
)
)
;
mWaitingForProxy
=
true
;
return
NS_OK
;
}
if
(
mCacheOpenFunc
)
{
mRaceCacheWithNetwork
=
true
;
}
else
if
(
AwaitingCacheCallbacks
(
)
)
{
mRaceCacheWithNetwork
=
StaticPrefs
:
:
network_http_rcwn_enabled
(
)
;
}
LOG
(
(
"
triggering
network
\
n
"
)
)
;
return
ContinueConnect
(
)
;
}
void
nsHttpChannel
:
:
MaybeRaceCacheWithNetwork
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsINetworkLinkService
>
netLinkSvc
=
do_GetService
(
NS_NETWORK_LINK_SERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
uint32_t
linkType
;
rv
=
netLinkSvc
-
>
GetLinkType
(
&
linkType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
!
(
linkType
=
=
nsINetworkLinkService
:
:
LINK_TYPE_ETHERNET
|
|
#
ifndef
MOZ_WIDGET_ANDROID
linkType
=
=
nsINetworkLinkService
:
:
LINK_TYPE_UNKNOWN
|
|
#
endif
linkType
=
=
nsINetworkLinkService
:
:
LINK_TYPE_USB
|
|
linkType
=
=
nsINetworkLinkService
:
:
LINK_TYPE_WIFI
)
)
{
return
;
}
if
(
mLoadFlags
&
(
LOAD_ONLY_FROM_CACHE
|
LOAD_NO_NETWORK_IO
)
)
{
return
;
}
if
(
NS_FAILED
(
mStatus
)
)
{
return
;
}
if
(
LoadRequireCORSPreflight
(
)
&
&
!
LoadIsCorsPreflightDone
(
)
)
{
return
;
}
if
(
CacheFileUtils
:
:
CachePerfStats
:
:
IsCacheSlow
(
)
)
{
mRaceDelay
=
0
;
}
else
{
mRaceDelay
=
CacheFileUtils
:
:
CachePerfStats
:
:
GetAverage
(
CacheFileUtils
:
:
CachePerfStats
:
:
ENTRY_OPEN
true
)
*
3
;
mRaceDelay
/
=
1000
;
}
mRaceDelay
=
clamped
<
uint32_t
>
(
mRaceDelay
StaticPrefs
:
:
network_http_rcwn_min_wait_before_racing_ms
(
)
StaticPrefs
:
:
network_http_rcwn_max_wait_before_racing_ms
(
)
)
;
MOZ_ASSERT
(
StaticPrefs
:
:
network_http_rcwn_enabled
(
)
"
The
pref
must
be
turned
on
.
"
)
;
LOG
(
(
"
nsHttpChannel
:
:
MaybeRaceCacheWithNetwork
[
this
=
%
p
delay
=
%
u
]
\
n
"
this
mRaceDelay
)
)
;
TriggerNetworkWithDelay
(
mRaceDelay
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
Test_triggerNetwork
(
int32_t
aTimeout
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
the
main
thread
"
)
;
return
TriggerNetworkWithDelay
(
aTimeout
)
;
}
nsHttpChannel
:
:
TimerCallback
:
:
TimerCallback
(
nsHttpChannel
*
aChannel
)
:
mChannel
(
aChannel
)
{
}
NS_IMPL_ISUPPORTS
(
nsHttpChannel
:
:
TimerCallback
nsITimerCallback
nsINamed
)
NS_IMETHODIMP
nsHttpChannel
:
:
TimerCallback
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
nsHttpChannel
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
TimerCallback
:
:
Notify
(
nsITimer
*
aTimer
)
{
if
(
aTimer
=
=
mChannel
-
>
mCacheOpenTimer
)
{
return
mChannel
-
>
Test_triggerDelayedOpenCacheEntry
(
)
;
}
if
(
aTimer
=
=
mChannel
-
>
mNetworkTriggerTimer
)
{
return
mChannel
-
>
TriggerNetwork
(
)
;
}
MOZ_CRASH
(
"
Unknown
timer
"
)
;
return
NS_OK
;
}
bool
nsHttpChannel
:
:
EligibleForTailing
(
)
{
if
(
!
(
mClassOfService
.
Flags
(
)
&
nsIClassOfService
:
:
Tail
)
)
{
return
false
;
}
if
(
mClassOfService
.
Flags
(
)
&
(
nsIClassOfService
:
:
UrgentStart
|
nsIClassOfService
:
:
Leader
|
nsIClassOfService
:
:
TailForbidden
)
)
{
return
false
;
}
if
(
mClassOfService
.
Flags
(
)
&
nsIClassOfService
:
:
Unblocked
&
&
!
(
mClassOfService
.
Flags
(
)
&
nsIClassOfService
:
:
TailAllowed
)
)
{
return
false
;
}
if
(
IsNavigation
(
)
)
{
return
false
;
}
return
true
;
}
bool
nsHttpChannel
:
:
WaitingForTailUnblock
(
)
{
nsresult
rv
;
if
(
!
gHttpHandler
-
>
IsTailBlockingEnabled
(
)
)
{
LOG
(
(
"
nsHttpChannel
%
p
tail
-
blocking
disabled
"
this
)
)
;
return
false
;
}
if
(
!
EligibleForTailing
(
)
)
{
LOG
(
(
"
nsHttpChannel
%
p
not
eligible
for
tail
-
blocking
"
this
)
)
;
AddAsNonTailRequest
(
)
;
return
false
;
}
if
(
!
EnsureRequestContext
(
)
)
{
LOG
(
(
"
nsHttpChannel
%
p
no
request
context
"
this
)
)
;
return
false
;
}
LOG
(
(
"
nsHttpChannel
:
:
WaitingForTailUnblock
this
=
%
p
rc
=
%
p
"
this
mRequestContext
.
get
(
)
)
)
;
bool
blocked
;
rv
=
mRequestContext
-
>
IsContextTailBlocked
(
this
&
blocked
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
LOG
(
(
"
blocked
=
%
d
"
blocked
)
)
;
return
blocked
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
OnTailUnblock
(
nsresult
rv
)
{
LOG
(
(
"
nsHttpChannel
:
:
OnTailUnblock
this
=
%
p
rv
=
%
"
PRIx32
"
rc
=
%
p
"
this
static_cast
<
uint32_t
>
(
rv
)
mRequestContext
.
get
(
)
)
)
;
MOZ_RELEASE_ASSERT
(
mOnTailUnblock
)
;
if
(
NS_FAILED
(
mStatus
)
)
{
rv
=
mStatus
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
auto
callback
=
mOnTailUnblock
;
mOnTailUnblock
=
nullptr
;
rv
=
(
this
-
>
*
callback
)
(
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
CloseCacheEntry
(
false
)
;
return
AsyncAbort
(
rv
)
;
}
return
NS_OK
;
}
void
nsHttpChannel
:
:
SetWarningReporter
(
HttpChannelSecurityWarningReporter
*
aReporter
)
{
LOG
(
(
"
nsHttpChannel
[
this
=
%
p
]
SetWarningReporter
[
%
p
]
"
this
aReporter
)
)
;
mWarningReporter
=
aReporter
;
}
HttpChannelSecurityWarningReporter
*
nsHttpChannel
:
:
GetWarningReporter
(
)
{
LOG
(
(
"
nsHttpChannel
[
this
=
%
p
]
GetWarningReporter
[
%
p
]
"
this
mWarningReporter
.
get
(
)
)
)
;
return
mWarningReporter
.
get
(
)
;
}
void
nsHttpChannel
:
:
DisableIsOpaqueResponseAllowedAfterSniffCheck
(
SnifferType
aType
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
mCheckIsOpaqueResponseAllowedAfterSniff
)
{
MOZ_ASSERT
(
mCachedOpaqueResponseBlockingPref
)
;
if
(
aType
=
=
SnifferType
:
:
Media
)
{
MOZ_ASSERT
(
mLoadInfo
)
;
bool
isMediaRequest
;
mLoadInfo
-
>
GetIsMediaRequest
(
&
isMediaRequest
)
;
if
(
isMediaRequest
)
{
bool
isInitialRequest
;
mLoadInfo
-
>
GetIsMediaInitialRequest
(
&
isInitialRequest
)
;
MOZ_ASSERT
(
isInitialRequest
)
;
if
(
!
isInitialRequest
)
{
mBlockOpaqueResponseAfterSniff
=
true
;
return
;
}
if
(
mResponseHead
-
>
Status
(
)
!
=
200
&
&
mResponseHead
-
>
Status
(
)
!
=
206
)
{
mBlockOpaqueResponseAfterSniff
=
true
;
return
;
}
if
(
mResponseHead
-
>
Status
(
)
=
=
206
&
&
!
IsFirstPartialResponse
(
*
mResponseHead
)
)
{
mBlockOpaqueResponseAfterSniff
=
true
;
return
;
}
}
}
mCheckIsOpaqueResponseAllowedAfterSniff
=
false
;
}
}
namespace
{
class
CopyNonDefaultHeaderVisitor
final
:
public
nsIHttpHeaderVisitor
{
nsCOMPtr
<
nsIHttpChannel
>
mTarget
;
~
CopyNonDefaultHeaderVisitor
(
)
=
default
;
NS_IMETHOD
VisitHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
)
override
{
if
(
aValue
.
IsEmpty
(
)
)
{
return
mTarget
-
>
SetEmptyRequestHeader
(
aHeader
)
;
}
return
mTarget
-
>
SetRequestHeader
(
aHeader
aValue
false
)
;
}
public
:
explicit
CopyNonDefaultHeaderVisitor
(
nsIHttpChannel
*
aTarget
)
:
mTarget
(
aTarget
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mTarget
)
;
}
NS_DECL_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS
(
CopyNonDefaultHeaderVisitor
nsIHttpHeaderVisitor
)
}
nsresult
nsHttpChannel
:
:
RedirectToInterceptedChannel
(
)
{
nsCOMPtr
<
nsINetworkInterceptController
>
controller
;
GetCallback
(
controller
)
;
RefPtr
<
InterceptedHttpChannel
>
intercepted
=
InterceptedHttpChannel
:
:
CreateForInterception
(
mChannelCreationTime
mChannelCreationTimestamp
mAsyncOpenTime
)
;
ExtContentPolicyType
type
=
mLoadInfo
-
>
GetExternalContentPolicyType
(
)
;
nsCOMPtr
<
nsILoadInfo
>
redirectLoadInfo
=
CloneLoadInfoForRedirect
(
mURI
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
;
nsresult
rv
=
intercepted
-
>
Init
(
mURI
mCaps
static_cast
<
nsProxyInfo
*
>
(
mProxyInfo
.
get
(
)
)
mProxyResolveFlags
mProxyURI
mChannelId
type
redirectLoadInfo
)
;
rv
=
SetupReplacementChannel
(
mURI
intercepted
true
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpHeaderVisitor
>
visitor
=
new
CopyNonDefaultHeaderVisitor
(
intercepted
)
;
rv
=
VisitNonDefaultRequestHeaders
(
visitor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mRedirectChannel
=
intercepted
;
PushRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueAsyncRedirectChannelToURI
)
;
rv
=
gHttpHandler
-
>
AsyncOnChannelRedirect
(
this
intercepted
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
WaitForRedirectCallback
(
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
AutoRedirectVetoNotifier
notifier
(
this
)
;
PopRedirectAsyncFunc
(
&
nsHttpChannel
:
:
ContinueAsyncRedirectChannelToURI
)
;
}
return
rv
;
}
void
nsHttpChannel
:
:
ReEvaluateReferrerAfterTrackingStatusIsKnown
(
)
{
nsCOMPtr
<
nsICookieJarSettings
>
cjs
;
if
(
mLoadInfo
)
{
Unused
<
<
mLoadInfo
-
>
GetCookieJarSettings
(
getter_AddRefs
(
cjs
)
)
;
}
if
(
!
cjs
)
{
cjs
=
net
:
:
CookieJarSettings
:
:
Create
(
mLoadInfo
-
>
GetLoadingPrincipal
(
)
)
;
}
if
(
cjs
-
>
GetRejectThirdPartyContexts
(
)
)
{
bool
isPrivate
=
mLoadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
>
0
;
if
(
mReferrerInfo
)
{
ReferrerInfo
*
referrerInfo
=
static_cast
<
ReferrerInfo
*
>
(
mReferrerInfo
.
get
(
)
)
;
if
(
referrerInfo
-
>
IsPolicyOverrided
(
)
&
&
referrerInfo
-
>
ReferrerPolicy
(
)
=
=
ReferrerInfo
:
:
GetDefaultReferrerPolicy
(
nullptr
nullptr
isPrivate
)
)
{
nsCOMPtr
<
nsIReferrerInfo
>
newReferrerInfo
=
referrerInfo
-
>
CloneWithNewPolicy
(
ReferrerInfo
:
:
GetDefaultReferrerPolicy
(
this
mURI
isPrivate
)
)
;
SetReferrerInfoInternal
(
newReferrerInfo
false
true
true
)
;
nsCOMPtr
<
nsIParentChannel
>
parentChannel
;
NS_QueryNotificationCallbacks
(
this
parentChannel
)
;
RefPtr
<
HttpChannelParent
>
httpParent
=
do_QueryObject
(
parentChannel
)
;
if
(
httpParent
)
{
httpParent
-
>
OverrideReferrerInfoDuringBeginConnect
(
newReferrerInfo
)
;
}
}
}
}
}
namespace
{
class
BackgroundRevalidatingListener
:
public
nsIStreamListener
{
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
private
:
virtual
~
BackgroundRevalidatingListener
(
)
=
default
;
}
;
NS_IMETHODIMP
BackgroundRevalidatingListener
:
:
OnStartRequest
(
nsIRequest
*
request
)
{
return
NS_OK
;
}
NS_IMETHODIMP
BackgroundRevalidatingListener
:
:
OnDataAvailable
(
nsIRequest
*
request
nsIInputStream
*
input
uint64_t
offset
uint32_t
count
)
{
uint32_t
bytesRead
=
0
;
return
input
-
>
ReadSegments
(
NS_DiscardSegment
nullptr
count
&
bytesRead
)
;
}
NS_IMETHODIMP
BackgroundRevalidatingListener
:
:
OnStopRequest
(
nsIRequest
*
request
nsresult
status
)
{
if
(
NS_FAILED
(
status
)
)
{
return
status
;
}
nsCOMPtr
<
nsIHttpChannel
>
channel
(
do_QueryInterface
(
request
)
)
;
if
(
gHttpHandler
)
{
gHttpHandler
-
>
OnBackgroundRevalidation
(
channel
)
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
BackgroundRevalidatingListener
nsIStreamListener
nsIRequestObserver
)
}
void
nsHttpChannel
:
:
PerformBackgroundCacheRevalidation
(
)
{
if
(
!
StaticPrefs
:
:
network_http_stale_while_revalidate_enabled
(
)
)
{
return
;
}
if
(
mStaleRevalidation
)
{
return
;
}
LOG
(
(
"
nsHttpChannel
:
:
PerformBackgroundCacheRevalidation
%
p
"
this
)
)
;
Unused
<
<
NS_DispatchToMainThreadQueue
(
NewIdleRunnableMethod
(
"
nsHttpChannel
:
:
PerformBackgroundCacheRevalidation
"
this
&
nsHttpChannel
:
:
PerformBackgroundCacheRevalidationNow
)
EventQueuePriority
:
:
Idle
)
;
}
void
nsHttpChannel
:
:
PerformBackgroundCacheRevalidationNow
(
)
{
LOG
(
(
"
nsHttpChannel
:
:
PerformBackgroundCacheRevalidationNow
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
;
nsLoadFlags
loadFlags
=
mLoadFlags
|
LOAD_ONLY_IF_MODIFIED
|
VALIDATE_ALWAYS
|
LOAD_BACKGROUND
|
LOAD_BYPASS_SERVICE_WORKER
;
nsCOMPtr
<
nsIChannel
>
validatingChannel
;
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
validatingChannel
)
mURI
mLoadInfo
nullptr
mLoadGroup
mCallbacks
loadFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
failed
to
created
the
channel
rv
=
0x
%
08x
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
;
}
nsCOMPtr
<
nsISupportsPriority
>
priority
(
do_QueryInterface
(
validatingChannel
)
)
;
if
(
priority
)
{
priority
-
>
SetPriority
(
nsISupportsPriority
:
:
PRIORITY_LOWEST
)
;
}
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
validatingChannel
)
)
;
if
(
cos
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Tail
)
;
}
RefPtr
<
nsHttpChannel
>
httpChan
=
do_QueryObject
(
validatingChannel
)
;
if
(
httpChan
)
{
httpChan
-
>
mStaleRevalidation
=
true
;
}
RefPtr
<
BackgroundRevalidatingListener
>
listener
=
new
BackgroundRevalidatingListener
(
)
;
rv
=
validatingChannel
-
>
AsyncOpen
(
listener
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
failed
to
open
the
channel
rv
=
0x
%
08x
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
;
}
LOG
(
(
"
%
p
is
re
-
validating
with
a
new
channel
%
p
"
this
validatingChannel
.
get
(
)
)
)
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
SetEarlyHintObserver
(
nsIEarlyHintObserver
*
aObserver
)
{
mEarlyHintObserver
=
aObserver
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpChannel
:
:
EarlyHint
(
const
nsACString
&
linkHeader
)
{
LOG
(
(
"
nsHttpChannel
:
:
EarlyHint
.
\
n
"
)
)
;
if
(
mEarlyHintObserver
&
&
nsContentUtils
:
:
ComputeIsSecureContext
(
this
)
)
{
LOG
(
(
"
nsHttpChannel
:
:
EarlyHint
propagated
.
\
n
"
)
)
;
mEarlyHintObserver
-
>
EarlyHint
(
linkHeader
)
;
}
return
NS_OK
;
}
}
}
