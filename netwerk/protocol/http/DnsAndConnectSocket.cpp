#
include
"
HttpLog
.
h
"
#
include
"
ConnectionHandle
.
h
"
#
include
"
DnsAndConnectSocket
.
h
"
#
include
"
nsHttpConnection
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIDNSRecord
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIHttpActivityObserver
.
h
"
#
include
"
nsSocketTransportService2
.
h
"
#
include
"
nsDNSService2
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
glean
/
NetwerkProtocolHttpMetrics
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
ConnectionEntry
.
h
"
#
include
"
HttpConnectionUDP
.
h
"
#
include
"
NullHttpTransaction
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
mozilla
/
net
/
NeckoChannelParams
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
namespace
mozilla
{
namespace
net
{
NS_IMPL_ADDREF
(
DnsAndConnectSocket
)
NS_IMPL_RELEASE
(
DnsAndConnectSocket
)
NS_INTERFACE_MAP_BEGIN
(
DnsAndConnectSocket
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIOutputStreamCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsITransportEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsITimerCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsINamed
)
NS_INTERFACE_MAP_ENTRY
(
nsIDNSListener
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
DnsAndConnectSocket
)
NS_INTERFACE_MAP_END
static
void
NotifyActivity
(
nsHttpConnectionInfo
*
aConnInfo
uint32_t
aSubtype
)
{
HttpConnectionActivity
activity
(
aConnInfo
-
>
HashKey
(
)
aConnInfo
-
>
GetOrigin
(
)
aConnInfo
-
>
OriginPort
(
)
aConnInfo
-
>
EndToEndSSL
(
)
!
aConnInfo
-
>
GetEchConfig
(
)
.
IsEmpty
(
)
aConnInfo
-
>
IsHttp3
(
)
)
;
gHttpHandler
-
>
ObserveHttpActivityWithArgs
(
activity
NS_ACTIVITY_TYPE_HTTP_CONNECTION
aSubtype
PR_Now
(
)
0
"
"
_ns
)
;
}
DnsAndConnectSocket
:
:
DnsAndConnectSocket
(
nsHttpConnectionInfo
*
ci
nsAHttpTransaction
*
trans
uint32_t
caps
bool
speculative
bool
isFromPredictor
bool
urgentStart
)
:
mTransaction
(
trans
)
mCaps
(
caps
)
mSpeculative
(
speculative
)
mUrgentStart
(
urgentStart
)
mIsFromPredictor
(
isFromPredictor
)
mConnInfo
(
ci
)
{
MOZ_ASSERT
(
ci
&
&
trans
"
constructor
with
null
arguments
"
)
;
LOG
(
(
"
Creating
DnsAndConnectSocket
[
this
=
%
p
trans
=
%
p
ent
=
%
s
key
=
%
s
]
\
n
"
this
trans
mConnInfo
-
>
Origin
(
)
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
if
(
mConnInfo
-
>
UsingProxy
(
)
)
{
mIsHttp3
=
mConnInfo
-
>
IsHttp3ProxyConnection
(
)
;
}
else
{
mIsHttp3
=
mConnInfo
-
>
IsHttp3
(
)
;
}
MOZ_ASSERT
(
mConnInfo
)
;
NotifyActivity
(
mConnInfo
mSpeculative
?
NS_HTTP_ACTIVITY_SUBTYPE_SPECULATIVE_DNSANDSOCKET_CREATED
:
NS_HTTP_ACTIVITY_SUBTYPE_DNSANDSOCKET_CREATED
)
;
}
void
DnsAndConnectSocket
:
:
CheckIsDone
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mPrimaryTransport
.
mSocketTransport
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mPrimaryTransport
.
mStreamOut
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mPrimaryTransport
.
mDNSRequest
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mBackupTransport
.
mSocketTransport
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mBackupTransport
.
mStreamOut
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mBackupTransport
.
mDNSRequest
)
;
}
DnsAndConnectSocket
:
:
~
DnsAndConnectSocket
(
)
{
LOG
(
(
"
Destroying
DnsAndConnectSocket
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
mState
=
=
DnsAndSocketState
:
:
DONE
)
;
CheckIsDone
(
)
;
mPrimaryTransport
.
MaybeSetConnectingDone
(
)
;
mBackupTransport
.
MaybeSetConnectingDone
(
)
;
}
nsresult
DnsAndConnectSocket
:
:
Init
(
ConnectionEntry
*
ent
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mState
=
=
DnsAndSocketState
:
:
INIT
)
;
if
(
mConnInfo
-
>
GetRoutedHost
(
)
.
IsEmpty
(
)
)
{
mPrimaryTransport
.
mHost
=
mConnInfo
-
>
GetOrigin
(
)
;
mBackupTransport
.
mHost
=
mConnInfo
-
>
GetOrigin
(
)
;
}
else
{
mPrimaryTransport
.
mHost
=
mConnInfo
-
>
GetRoutedHost
(
)
;
mBackupTransport
.
mHost
=
mConnInfo
-
>
GetRoutedHost
(
)
;
}
CheckProxyConfig
(
)
;
if
(
!
mSkipDnsResolution
)
{
nsresult
rv
=
SetupDnsFlags
(
ent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
SetupEvent
(
SetupEvents
:
:
INIT_EVENT
)
;
}
void
DnsAndConnectSocket
:
:
CheckProxyConfig
(
)
{
if
(
nsCOMPtr
<
nsProxyInfo
>
proxyInfo
=
mConnInfo
-
>
ProxyInfo
(
)
)
{
nsAutoCString
proxyType
(
proxyInfo
-
>
Type
(
)
)
;
bool
proxyTransparent
=
false
;
if
(
proxyType
.
EqualsLiteral
(
"
socks
"
)
|
|
proxyType
.
EqualsLiteral
(
"
socks4
"
)
)
{
proxyTransparent
=
true
;
if
(
proxyInfo
-
>
Flags
(
)
&
nsIProxyInfo
:
:
TRANSPARENT_PROXY_RESOLVES_HOST
)
{
mProxyTransparentResolvesHost
=
true
;
}
}
if
(
mProxyTransparentResolvesHost
)
{
mPrimaryTransport
.
mSkipDnsResolution
=
true
;
mBackupTransport
.
mSkipDnsResolution
=
true
;
mSkipDnsResolution
=
true
;
}
if
(
!
proxyTransparent
&
&
!
proxyInfo
-
>
Host
(
)
.
IsEmpty
(
)
)
{
mProxyNotTransparent
=
true
;
mPrimaryTransport
.
mHost
=
proxyInfo
-
>
Host
(
)
;
mBackupTransport
.
mHost
=
proxyInfo
-
>
Host
(
)
;
}
}
}
nsresult
DnsAndConnectSocket
:
:
SetupDnsFlags
(
ConnectionEntry
*
ent
)
{
LOG
(
(
"
DnsAndConnectSocket
:
:
SetupDnsFlags
[
this
=
%
p
]
"
this
)
)
;
nsIDNSService
:
:
DNSFlags
dnsFlags
=
nsIDNSService
:
:
RESOLVE_DEFAULT_FLAGS
;
bool
disableIpv6ForBackup
=
false
;
if
(
mCaps
&
NS_HTTP_REFRESH_DNS
)
{
dnsFlags
=
nsIDNSService
:
:
RESOLVE_BYPASS_CACHE
;
}
if
(
mCaps
&
NS_HTTP_DISABLE_IPV4
)
{
dnsFlags
|
=
nsIDNSService
:
:
RESOLVE_DISABLE_IPV4
;
}
else
if
(
mCaps
&
NS_HTTP_DISABLE_IPV6
)
{
dnsFlags
|
=
nsIDNSService
:
:
RESOLVE_DISABLE_IPV6
;
}
else
if
(
ent
-
>
PreferenceKnown
(
)
)
{
if
(
ent
-
>
mPreferIPv6
)
{
dnsFlags
|
=
nsIDNSService
:
:
RESOLVE_DISABLE_IPV4
;
}
else
if
(
ent
-
>
mPreferIPv4
)
{
dnsFlags
|
=
nsIDNSService
:
:
RESOLVE_DISABLE_IPV6
;
}
mPrimaryTransport
.
mRetryWithDifferentIPFamily
=
true
;
mBackupTransport
.
mRetryWithDifferentIPFamily
=
true
;
}
else
if
(
gHttpHandler
-
>
FastFallbackToIPv4
(
)
)
{
disableIpv6ForBackup
=
true
;
}
if
(
ent
-
>
mConnInfo
-
>
HasIPHintAddress
(
)
)
{
nsresult
rv
;
nsCOMPtr
<
nsIDNSService
>
dns
;
dns
=
mozilla
:
:
components
:
:
DNS
:
:
Service
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIDNSRecord
>
record
;
rv
=
dns
-
>
ResolveNative
(
mPrimaryTransport
.
mHost
nsIDNSService
:
:
RESOLVE_OFFLINE
mConnInfo
-
>
GetOriginAttributes
(
)
getter_AddRefs
(
record
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
record
)
{
LOG
(
(
"
Setting
Socket
to
use
IP
hint
address
"
)
)
;
dnsFlags
|
=
nsIDNSService
:
:
RESOLVE_IP_HINT
;
}
}
dnsFlags
|
=
nsIDNSService
:
:
GetFlagsFromTRRMode
(
NS_HTTP_TRR_MODE_FROM_FLAGS
(
mCaps
)
)
;
dnsFlags
|
=
nsIDNSService
:
:
RESOLVE_IGNORE_SOCKS_DNS
;
NS_ASSERTION
(
!
(
dnsFlags
&
nsIDNSService
:
:
RESOLVE_DISABLE_IPV6
)
|
|
!
(
dnsFlags
&
nsIDNSService
:
:
RESOLVE_DISABLE_IPV4
)
"
Setting
both
RESOLVE_DISABLE_IPV6
and
RESOLVE_DISABLE_IPV4
"
)
;
mPrimaryTransport
.
mDnsFlags
=
dnsFlags
;
mBackupTransport
.
mDnsFlags
=
dnsFlags
;
if
(
disableIpv6ForBackup
)
{
mBackupTransport
.
mDnsFlags
|
=
nsIDNSService
:
:
RESOLVE_DISABLE_IPV6
;
}
LOG
(
(
"
DnsAndConnectSocket
:
:
SetupDnsFlags
flags
=
%
u
flagsBackup
=
%
u
[
this
=
%
p
]
"
mPrimaryTransport
.
mDnsFlags
mBackupTransport
.
mDnsFlags
this
)
)
;
NS_ASSERTION
(
!
(
mBackupTransport
.
mDnsFlags
&
nsIDNSService
:
:
RESOLVE_DISABLE_IPV6
)
|
|
!
(
mBackupTransport
.
mDnsFlags
&
nsIDNSService
:
:
RESOLVE_DISABLE_IPV4
)
"
Setting
both
RESOLVE_DISABLE_IPV6
and
RESOLVE_DISABLE_IPV4
"
)
;
return
NS_OK
;
}
nsresult
DnsAndConnectSocket
:
:
SetupEvent
(
SetupEvents
event
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
DnsAndConnectSocket
:
:
SetupEvent
state
=
%
d
event
=
%
d
this
=
%
p
"
mState
event
this
)
)
;
nsresult
rv
=
NS_OK
;
switch
(
event
)
{
case
SetupEvents
:
:
INIT_EVENT
:
MOZ_ASSERT
(
mState
=
=
DnsAndSocketState
:
:
INIT
)
;
rv
=
mPrimaryTransport
.
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
mState
=
DnsAndSocketState
:
:
DONE
;
}
else
if
(
mPrimaryTransport
.
FirstResolving
(
)
)
{
mState
=
DnsAndSocketState
:
:
RESOLVING
;
}
else
if
(
!
mIsHttp3
&
&
mPrimaryTransport
.
ConnectingOrRetry
(
)
)
{
mState
=
DnsAndSocketState
:
:
CONNECTING
;
SetupBackupTimer
(
)
;
}
else
{
MOZ_ASSERT
(
false
)
;
mState
=
DnsAndSocketState
:
:
DONE
;
Abandon
(
)
;
rv
=
NS_ERROR_UNEXPECTED
;
}
break
;
case
SetupEvents
:
:
RESOLVED_PRIMARY_EVENT
:
if
(
!
mIsHttp3
&
&
(
mState
=
=
DnsAndSocketState
:
:
RESOLVING
)
)
{
mState
=
DnsAndSocketState
:
:
CONNECTING
;
SetupBackupTimer
(
)
;
}
break
;
case
SetupEvents
:
:
PRIMARY_DONE_EVENT
:
MOZ_ASSERT
(
(
mState
=
=
DnsAndSocketState
:
:
RESOLVING
)
|
|
(
mState
=
=
DnsAndSocketState
:
:
CONNECTING
)
|
|
(
mState
=
=
DnsAndSocketState
:
:
ONE_CONNECTED
)
)
;
CancelBackupTimer
(
)
;
mBackupTransport
.
CancelDnsResolution
(
)
;
if
(
mBackupTransport
.
ConnectingOrRetry
(
)
)
{
mState
=
DnsAndSocketState
:
:
ONE_CONNECTED
;
}
else
{
mState
=
DnsAndSocketState
:
:
DONE
;
}
break
;
case
SetupEvents
:
:
BACKUP_DONE_EVENT
:
MOZ_ASSERT
(
(
mState
=
=
DnsAndSocketState
:
:
CONNECTING
)
|
|
(
mState
=
=
DnsAndSocketState
:
:
ONE_CONNECTED
)
)
;
if
(
mPrimaryTransport
.
ConnectingOrRetry
(
)
)
{
mState
=
DnsAndSocketState
:
:
ONE_CONNECTED
;
}
else
{
mState
=
DnsAndSocketState
:
:
DONE
;
}
break
;
case
SetupEvents
:
:
BACKUP_TIMER_FIRED_EVENT
:
MOZ_ASSERT
(
mState
=
=
DnsAndSocketState
:
:
CONNECTING
)
;
mBackupTransport
.
Init
(
this
)
;
}
LOG
(
(
"
DnsAndConnectSocket
:
:
SetupEvent
state
=
%
d
"
mState
)
)
;
if
(
mState
=
=
DnsAndSocketState
:
:
DONE
)
{
CheckIsDone
(
)
;
RefPtr
<
DnsAndConnectSocket
>
self
(
this
)
;
RefPtr
<
ConnectionEntry
>
ent
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
FindConnectionEntry
(
mConnInfo
)
;
if
(
ent
)
{
ent
-
>
RemoveDnsAndConnectSocket
(
this
false
)
;
}
return
rv
;
}
return
NS_OK
;
}
void
DnsAndConnectSocket
:
:
SetupBackupTimer
(
)
{
uint16_t
timeout
=
gHttpHandler
-
>
GetIdleSynTimeout
(
)
;
MOZ_ASSERT
(
!
mSynTimer
"
timer
already
initd
"
)
;
if
(
timeout
&
&
(
!
mSpeculative
|
|
mConnInfo
-
>
GetFallbackConnection
(
)
)
&
&
!
mIsHttp3
)
{
NS_NewTimerWithCallback
(
getter_AddRefs
(
mSynTimer
)
this
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
LOG
(
(
"
DnsAndConnectSocket
:
:
SetupBackupTimer
(
)
[
this
=
%
p
]
"
this
)
)
;
}
else
if
(
timeout
)
{
LOG
(
(
"
DnsAndConnectSocket
:
:
SetupBackupTimer
(
)
[
this
=
%
p
]
did
not
arm
\
n
"
this
)
)
;
}
}
void
DnsAndConnectSocket
:
:
CancelBackupTimer
(
)
{
if
(
!
mSynTimer
)
{
return
;
}
LOG
(
(
"
DnsAndConnectSocket
:
:
CancelBackupTimer
(
)
"
)
)
;
mSynTimer
-
>
Cancel
(
)
;
}
void
DnsAndConnectSocket
:
:
Abandon
(
)
{
LOG
(
(
"
DnsAndConnectSocket
:
:
Abandon
[
this
=
%
p
ent
=
%
s
]
%
p
%
p
%
p
%
p
"
this
mConnInfo
-
>
Origin
(
)
mPrimaryTransport
.
mSocketTransport
.
get
(
)
mBackupTransport
.
mSocketTransport
.
get
(
)
mPrimaryTransport
.
mStreamOut
.
get
(
)
mBackupTransport
.
mStreamOut
.
get
(
)
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
mPrimaryTransport
.
Abandon
(
)
;
mBackupTransport
.
Abandon
(
)
;
CancelBackupTimer
(
)
;
mState
=
DnsAndSocketState
:
:
DONE
;
}
double
DnsAndConnectSocket
:
:
Duration
(
TimeStamp
epoch
)
{
if
(
mPrimaryTransport
.
mSynStarted
.
IsNull
(
)
)
{
return
0
;
}
return
(
epoch
-
mPrimaryTransport
.
mSynStarted
)
.
ToMilliseconds
(
)
;
}
NS_IMETHODIMP
DnsAndConnectSocket
:
:
Notify
(
nsITimer
*
timer
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
timer
=
=
mSynTimer
"
wrong
timer
"
)
;
MOZ_ASSERT
(
!
mBackupTransport
.
mDNSRequest
)
;
MOZ_ASSERT
(
!
mBackupTransport
.
mSocketTransport
)
;
MOZ_ASSERT
(
mSynTimer
)
;
DebugOnly
<
nsresult
>
rv
=
SetupEvent
(
BACKUP_TIMER_FIRED_EVENT
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DnsAndConnectSocket
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
DnsAndConnectSocket
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DnsAndConnectSocket
:
:
OnLookupComplete
(
nsICancelable
*
request
nsIDNSRecord
*
rec
nsresult
status
)
{
LOG
(
(
"
DnsAndConnectSocket
:
:
OnLookupComplete
:
this
=
%
p
mState
=
%
d
status
%
"
PRIx32
"
.
"
this
mState
static_cast
<
uint32_t
>
(
status
)
)
)
;
if
(
nsCOMPtr
<
nsIDNSAddrRecord
>
addrRecord
=
do_QueryInterface
(
(
rec
)
)
)
{
nsIRequest
:
:
TRRMode
effectivemode
=
nsIRequest
:
:
TRR_DEFAULT_MODE
;
addrRecord
-
>
GetEffectiveTRRMode
(
&
effectivemode
)
;
nsITRRSkipReason
:
:
value
skipReason
=
nsITRRSkipReason
:
:
TRR_UNSET
;
addrRecord
-
>
GetTrrSkipReason
(
&
skipReason
)
;
if
(
mTransaction
)
{
mTransaction
-
>
SetTRRInfo
(
effectivemode
skipReason
)
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
request
)
;
RefPtr
<
DnsAndConnectSocket
>
deleteProtector
(
this
)
;
if
(
!
request
|
|
(
!
IsPrimary
(
request
)
&
&
!
IsBackup
(
request
)
)
)
{
return
NS_OK
;
}
if
(
IsPrimary
(
request
)
&
&
NS_SUCCEEDED
(
status
)
)
{
mTransaction
-
>
OnTransportStatus
(
nullptr
NS_NET_STATUS_RESOLVED_HOST
0
)
;
}
if
(
mProxyNotTransparent
&
&
(
status
=
=
NS_ERROR_UNKNOWN_HOST
)
)
{
status
=
NS_ERROR_UNKNOWN_PROXY_HOST
;
}
nsresult
rv
;
bool
isPrimary
=
IsPrimary
(
request
)
;
if
(
isPrimary
)
{
rv
=
mPrimaryTransport
.
OnLookupComplete
(
this
rec
status
)
;
if
(
(
!
mIsHttp3
&
&
mPrimaryTransport
.
ConnectingOrRetry
(
)
)
|
|
(
mIsHttp3
&
&
mPrimaryTransport
.
Resolved
(
)
)
)
{
SetupEvent
(
SetupEvents
:
:
RESOLVED_PRIMARY_EVENT
)
;
}
}
else
{
rv
=
mBackupTransport
.
OnLookupComplete
(
this
rec
status
)
;
}
if
(
NS_FAILED
(
rv
)
|
|
mIsHttp3
)
{
if
(
mIsHttp3
&
&
mPrimaryTransport
.
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
RETRY_RESOLVING
)
{
LOG
(
(
"
Retry
DNS
for
Http3
"
)
)
;
return
NS_OK
;
}
SetupConn
(
isPrimary
rv
)
;
if
(
mState
!
=
DnsAndSocketState
:
:
DONE
)
{
if
(
isPrimary
)
{
SetupEvent
(
SetupEvents
:
:
PRIMARY_DONE_EVENT
)
;
}
else
{
SetupEvent
(
SetupEvents
:
:
BACKUP_DONE_EVENT
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
DnsAndConnectSocket
:
:
OnOutputStreamReady
(
nsIAsyncOutputStream
*
out
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPrimaryTransport
.
mSocketTransport
|
|
mBackupTransport
.
mSocketTransport
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsPrimary
(
out
)
|
|
IsBackup
(
out
)
"
stream
mismatch
"
)
;
RefPtr
<
ConnectionEntry
>
ent
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
FindConnectionEntry
(
mConnInfo
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ent
)
;
(
void
)
ent
;
RefPtr
<
DnsAndConnectSocket
>
deleteProtector
(
this
)
;
LOG
(
(
"
DnsAndConnectSocket
:
:
OnOutputStreamReady
[
this
=
%
p
ent
=
%
s
%
s
]
\
n
"
this
mConnInfo
-
>
Origin
(
)
IsPrimary
(
out
)
?
"
primary
"
:
"
backup
"
)
)
;
bool
isPrimary
=
IsPrimary
(
out
)
;
nsresult
rv
=
NS_OK
;
if
(
isPrimary
)
{
rv
=
mPrimaryTransport
.
CheckConnectedResult
(
this
)
;
if
(
!
mPrimaryTransport
.
DoneConnecting
(
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
(
NS_SUCCEEDED
(
rv
)
&
&
(
mPrimaryTransport
.
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
CONNECTING_DONE
)
&
&
mPrimaryTransport
.
mSocketTransport
)
|
|
(
NS_FAILED
(
rv
)
&
&
(
mPrimaryTransport
.
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
DONE
)
&
&
!
mPrimaryTransport
.
mSocketTransport
)
)
;
}
else
if
(
IsBackup
(
out
)
)
{
rv
=
mBackupTransport
.
CheckConnectedResult
(
this
)
;
if
(
!
mBackupTransport
.
DoneConnecting
(
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
(
NS_SUCCEEDED
(
rv
)
&
&
(
mBackupTransport
.
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
CONNECTING_DONE
)
&
&
mBackupTransport
.
mSocketTransport
)
|
|
(
NS_FAILED
(
rv
)
&
&
(
mBackupTransport
.
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
DONE
)
&
&
!
mBackupTransport
.
mSocketTransport
)
)
;
}
else
{
MOZ_ASSERT
(
false
"
unexpected
stream
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsresult
socketStatus
=
out
-
>
StreamStatus
(
)
;
if
(
StaticPrefs
:
:
network_http_retry_with_another_half_open
(
)
&
&
NS_FAILED
(
socketStatus
)
&
&
socketStatus
!
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
if
(
isPrimary
)
{
if
(
mBackupTransport
.
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
CONNECTING
)
{
mPrimaryTransport
.
Abandon
(
)
;
return
NS_OK
;
}
}
else
if
(
IsBackup
(
out
)
)
{
if
(
mPrimaryTransport
.
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
CONNECTING
)
{
mBackupTransport
.
Abandon
(
)
;
return
NS_OK
;
}
}
}
rv
=
SetupConn
(
isPrimary
rv
)
;
if
(
mState
!
=
DnsAndSocketState
:
:
DONE
)
{
if
(
isPrimary
)
{
SetupEvent
(
SetupEvents
:
:
PRIMARY_DONE_EVENT
)
;
}
else
{
SetupEvent
(
SetupEvents
:
:
BACKUP_DONE_EVENT
)
;
}
}
return
rv
;
}
nsresult
DnsAndConnectSocket
:
:
SetupConn
(
bool
isPrimary
nsresult
status
)
{
RefPtr
<
ConnectionEntry
>
ent
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
FindConnectionEntry
(
mConnInfo
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ent
)
;
if
(
!
ent
)
{
Abandon
(
)
;
return
NS_OK
;
}
RefPtr
<
HttpConnectionBase
>
conn
;
nsresult
rv
=
NS_OK
;
if
(
isPrimary
)
{
rv
=
mPrimaryTransport
.
SetupConn
(
this
mTransaction
ent
status
mCaps
getter_AddRefs
(
conn
)
)
;
}
else
{
rv
=
mBackupTransport
.
SetupConn
(
this
mTransaction
ent
status
mCaps
getter_AddRefs
(
conn
)
)
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
mTransaction
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
DnsAndConnectSocket
:
:
SetupConn
"
"
conn
-
>
init
(
%
p
)
failed
%
"
PRIx32
"
\
n
"
conn
.
get
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
nsHttpTransaction
*
trans
=
mTransaction
-
>
QueryHttpTransaction
(
)
)
{
if
(
mIsHttp3
&
&
!
mConnInfo
-
>
GetWebTransport
(
)
&
&
!
mConnInfo
-
>
IsHttp3ProxyConnection
(
)
)
{
trans
-
>
DisableHttp3
(
true
)
;
gHttpHandler
-
>
ExcludeHttp3
(
mConnInfo
)
;
}
ent
-
>
RemoveTransFromPendingQ
(
trans
)
;
}
mTransaction
-
>
Close
(
rv
)
;
return
rv
;
}
mHasConnected
=
true
;
RefPtr
<
PendingTransactionInfo
>
pendingTransInfo
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
FindTransactionHelper
(
true
ent
mTransaction
)
;
if
(
pendingTransInfo
)
{
MOZ_ASSERT
(
!
mSpeculative
"
Speculative
Half
Open
found
mTransaction
"
)
;
ent
-
>
InsertIntoActiveConns
(
conn
)
;
if
(
mIsHttp3
)
{
nsHttpTransaction
*
trans
=
pendingTransInfo
-
>
Transaction
(
)
;
if
(
trans
-
>
IsWebsocketUpgrade
(
)
)
{
LOG
(
(
"
DnsAndConnectSocket
:
:
SetupConn
WebSocket
through
HTTP
/
3
proxy
"
"
queueing
for
tunnel
creation
after
H3
connected
"
)
)
;
RefPtr
<
PendingTransactionInfo
>
newPendingInfo
=
new
PendingTransactionInfo
(
trans
)
;
ent
-
>
InsertTransaction
(
newPendingInfo
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
nullCallbacks
;
trans
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
nullCallbacks
)
)
;
RefPtr
<
nsAHttpTransaction
>
nullTrans
=
new
NullHttpTransaction
(
mConnInfo
nullCallbacks
mCaps
)
;
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchAbstractTransaction
(
ent
nullTrans
mCaps
conn
0
)
;
return
rv
;
}
RefPtr
<
ConnectionHandle
>
handle
=
new
ConnectionHandle
(
conn
)
;
pendingTransInfo
-
>
Transaction
(
)
-
>
SetConnection
(
handle
)
;
}
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchTransaction
(
ent
pendingTransInfo
-
>
Transaction
(
)
conn
)
;
}
else
{
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
if
(
connTCP
)
{
connTCP
-
>
SetIsReusedAfter
(
950
)
;
}
if
(
!
connTCP
|
|
ent
-
>
mConnInfo
-
>
GetFallbackConnection
(
)
|
|
(
ent
-
>
mConnInfo
-
>
FirstHopSSL
(
)
&
&
!
ent
-
>
UrgentStartQueueLength
(
)
&
&
!
ent
-
>
PendingQueueLength
(
)
&
&
!
ent
-
>
mConnInfo
-
>
UsingConnect
(
)
)
)
{
LOG
(
(
"
DnsAndConnectSocket
:
:
SetupConn
null
transaction
will
"
"
be
used
to
finish
SSL
handshake
on
conn
%
p
\
n
"
conn
.
get
(
)
)
)
;
RefPtr
<
nsAHttpTransaction
>
trans
;
if
(
mTransaction
-
>
IsNullTransaction
(
)
&
&
!
mDispatchedMTransaction
)
{
mDispatchedMTransaction
=
true
;
trans
=
mTransaction
;
}
else
{
trans
=
new
NullHttpTransaction
(
mConnInfo
callbacks
mCaps
)
;
}
ent
-
>
InsertIntoActiveConns
(
conn
)
;
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchAbstractTransaction
(
ent
trans
mCaps
conn
0
)
;
}
else
{
LOG
(
(
"
DnsAndConnectSocket
:
:
SetupConn
no
transaction
match
"
"
returning
conn
%
p
to
pool
\
n
"
conn
.
get
(
)
)
)
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
OnMsgReclaimConnection
(
conn
)
;
if
(
ent
-
>
mConnInfo
-
>
FirstHopSSL
(
)
&
&
!
ent
-
>
mConnInfo
-
>
UsingConnect
(
)
)
{
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
if
(
connTCP
&
&
NS_SUCCEEDED
(
ent
-
>
RemoveIdleConnection
(
connTCP
)
)
)
{
RefPtr
<
nsAHttpTransaction
>
trans
;
if
(
mTransaction
-
>
IsNullTransaction
(
)
&
&
!
mDispatchedMTransaction
)
{
mDispatchedMTransaction
=
true
;
trans
=
mTransaction
;
}
else
{
trans
=
new
NullHttpTransaction
(
ent
-
>
mConnInfo
callbacks
mCaps
)
;
}
ent
-
>
InsertIntoActiveConns
(
conn
)
;
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DispatchAbstractTransaction
(
ent
trans
mCaps
conn
0
)
;
}
}
}
}
if
(
conn
-
>
Transaction
(
)
&
&
!
conn
-
>
Transaction
(
)
-
>
IsNullTransaction
(
)
)
{
Claim
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
DnsAndConnectSocket
:
:
OnTransportStatus
(
nsITransport
*
trans
nsresult
status
int64_t
progress
int64_t
progressMax
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
IsPrimary
(
trans
)
|
|
IsBackup
(
trans
)
)
;
if
(
mTransaction
)
{
if
(
IsPrimary
(
trans
)
|
|
(
IsBackup
(
trans
)
&
&
(
status
=
=
NS_NET_STATUS_CONNECTED_TO
)
&
&
mPrimaryTransport
.
mSocketTransport
)
)
{
mTransaction
-
>
OnTransportStatus
(
trans
status
progress
)
;
}
}
if
(
status
=
=
NS_NET_STATUS_CONNECTED_TO
)
{
if
(
IsPrimary
(
trans
)
)
{
mPrimaryTransport
.
mConnectedOK
=
true
;
}
else
{
mBackupTransport
.
mConnectedOK
=
true
;
}
}
if
(
!
IsPrimary
(
trans
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDNSAddrRecord
>
dnsRecord
(
do_GetInterface
(
mPrimaryTransport
.
mSocketTransport
)
)
;
if
(
status
=
=
NS_NET_STATUS_CONNECTING_TO
&
&
StaticPrefs
:
:
network_http_http2_enabled
(
)
&
&
StaticPrefs
:
:
network_http_http2_coalesce_hostnames
(
)
)
{
RefPtr
<
ConnectionEntry
>
ent
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
FindConnectionEntry
(
mConnInfo
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ent
)
;
if
(
ent
)
{
if
(
ent
-
>
MaybeProcessCoalescingKeys
(
dnsRecord
)
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
ProcessSpdyPendingQ
(
ent
)
;
}
}
}
return
NS_OK
;
}
bool
DnsAndConnectSocket
:
:
IsPrimary
(
nsITransport
*
trans
)
{
return
trans
=
=
mPrimaryTransport
.
mSocketTransport
;
}
bool
DnsAndConnectSocket
:
:
IsPrimary
(
nsIAsyncOutputStream
*
out
)
{
return
out
=
=
mPrimaryTransport
.
mStreamOut
;
}
bool
DnsAndConnectSocket
:
:
IsPrimary
(
nsICancelable
*
dnsRequest
)
{
return
dnsRequest
=
=
mPrimaryTransport
.
mDNSRequest
;
}
bool
DnsAndConnectSocket
:
:
IsBackup
(
nsITransport
*
trans
)
{
return
trans
=
=
mBackupTransport
.
mSocketTransport
;
}
bool
DnsAndConnectSocket
:
:
IsBackup
(
nsIAsyncOutputStream
*
out
)
{
return
out
=
=
mBackupTransport
.
mStreamOut
;
}
bool
DnsAndConnectSocket
:
:
IsBackup
(
nsICancelable
*
dnsRequest
)
{
return
dnsRequest
=
=
mBackupTransport
.
mDNSRequest
;
}
NS_IMETHODIMP
DnsAndConnectSocket
:
:
GetInterface
(
const
nsIID
&
iid
void
*
*
result
)
{
if
(
mTransaction
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
mTransaction
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
callbacks
)
{
return
callbacks
-
>
GetInterface
(
iid
result
)
;
}
}
return
NS_ERROR_NO_INTERFACE
;
}
bool
DnsAndConnectSocket
:
:
AcceptsTransaction
(
nsHttpTransaction
*
trans
)
{
return
!
mUrgentStart
|
|
(
trans
-
>
Caps
(
)
&
nsIClassOfService
:
:
UrgentStart
)
;
}
bool
DnsAndConnectSocket
:
:
Claim
(
)
{
if
(
mSpeculative
)
{
mSpeculative
=
false
;
mAllow1918
=
true
;
auto
resetFlag
=
[
]
(
TransportSetup
&
transport
)
{
uint32_t
flags
;
if
(
transport
.
mSocketTransport
&
&
NS_SUCCEEDED
(
transport
.
mSocketTransport
-
>
GetConnectionFlags
(
&
flags
)
)
)
{
flags
&
=
~
nsISocketTransport
:
:
DISABLE_RFC1918
;
flags
&
=
~
nsISocketTransport
:
:
IS_SPECULATIVE_CONNECTION
;
transport
.
mSocketTransport
-
>
SetConnectionFlags
(
flags
)
;
}
}
;
resetFlag
(
mPrimaryTransport
)
;
resetFlag
(
mBackupTransport
)
;
if
(
mPrimaryTransport
.
ConnectingOrRetry
(
)
&
&
!
mBackupTransport
.
mSocketTransport
&
&
!
mSynTimer
&
&
!
mIsHttp3
)
{
SetupBackupTimer
(
)
;
}
}
if
(
mFreeToUse
)
{
mFreeToUse
=
false
;
if
(
mPrimaryTransport
.
mSocketTransport
)
{
nsCOMPtr
<
nsITLSSocketControl
>
tlsSocketControl
;
if
(
NS_SUCCEEDED
(
mPrimaryTransport
.
mSocketTransport
-
>
GetTlsSocketControl
(
getter_AddRefs
(
tlsSocketControl
)
)
)
&
&
tlsSocketControl
)
{
(
void
)
tlsSocketControl
-
>
Claim
(
)
;
}
}
return
true
;
}
return
false
;
}
void
DnsAndConnectSocket
:
:
Unclaim
(
)
{
MOZ_ASSERT
(
!
mSpeculative
&
&
!
mFreeToUse
)
;
mFreeToUse
=
true
;
}
void
DnsAndConnectSocket
:
:
CloseTransports
(
nsresult
error
)
{
if
(
mPrimaryTransport
.
mSocketTransport
)
{
mPrimaryTransport
.
mSocketTransport
-
>
Close
(
error
)
;
}
if
(
mBackupTransport
.
mSocketTransport
)
{
mBackupTransport
.
mSocketTransport
-
>
Close
(
error
)
;
}
}
DnsAndConnectSocket
:
:
TransportSetup
:
:
TransportSetup
(
bool
isBackup
)
:
mState
(
TransportSetup
:
:
TransportSetupState
:
:
INIT
)
mIsBackup
(
isBackup
)
{
}
nsresult
DnsAndConnectSocket
:
:
TransportSetup
:
:
Init
(
DnsAndConnectSocket
*
dnsAndSock
)
{
nsresult
rv
;
mSynStarted
=
TimeStamp
:
:
Now
(
)
;
if
(
mSkipDnsResolution
)
{
mState
=
TransportSetup
:
:
TransportSetupState
:
:
CONNECTING
;
rv
=
SetupStreams
(
dnsAndSock
)
;
}
else
{
mState
=
TransportSetup
:
:
TransportSetupState
:
:
RESOLVING
;
rv
=
ResolveHost
(
dnsAndSock
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
CloseAll
(
)
;
mState
=
TransportSetup
:
:
TransportSetupState
:
:
DONE
;
}
return
rv
;
}
void
DnsAndConnectSocket
:
:
TransportSetup
:
:
CancelDnsResolution
(
)
{
if
(
mDNSRequest
)
{
mDNSRequest
-
>
Cancel
(
NS_ERROR_ABORT
)
;
mDNSRequest
=
nullptr
;
}
if
(
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
RESOLVING
)
{
mState
=
TransportSetup
:
:
TransportSetupState
:
:
INIT
;
}
}
void
DnsAndConnectSocket
:
:
TransportSetup
:
:
Abandon
(
)
{
CloseAll
(
)
;
mState
=
TransportSetup
:
:
TransportSetupState
:
:
DONE
;
}
void
DnsAndConnectSocket
:
:
TransportSetup
:
:
SetConnecting
(
)
{
MOZ_ASSERT
(
!
mWaitingForConnect
)
;
mWaitingForConnect
=
true
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
StartedConnect
(
)
;
}
void
DnsAndConnectSocket
:
:
TransportSetup
:
:
MaybeSetConnectingDone
(
)
{
if
(
mWaitingForConnect
)
{
mWaitingForConnect
=
false
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
RecvdConnect
(
)
;
}
}
void
DnsAndConnectSocket
:
:
TransportSetup
:
:
CloseAll
(
)
{
MaybeSetConnectingDone
(
)
;
if
(
mSocketTransport
)
{
mSocketTransport
-
>
SetEventSink
(
nullptr
nullptr
)
;
mSocketTransport
-
>
SetSecurityCallbacks
(
nullptr
)
;
mSocketTransport
=
nullptr
;
}
if
(
mStreamOut
)
{
mStreamOut
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mStreamOut
=
nullptr
;
}
if
(
mStreamIn
)
{
mStreamIn
-
>
AsyncWait
(
nullptr
0
0
nullptr
)
;
mStreamIn
=
nullptr
;
}
if
(
mDNSRequest
)
{
mDNSRequest
-
>
Cancel
(
NS_ERROR_ABORT
)
;
mDNSRequest
=
nullptr
;
}
mConnectedOK
=
false
;
}
bool
DnsAndConnectSocket
:
:
TransportSetup
:
:
ToggleIpFamilyFlagsIfRetryEnabled
(
)
{
if
(
!
mRetryWithDifferentIPFamily
)
{
return
false
;
}
LOG
(
(
"
DnsAndConnectSocket
:
:
TransportSetup
:
:
ToggleIpFamilyFlagsIfRetryEnabled
"
"
[
this
=
%
p
dnsFlags
=
%
u
]
"
this
mDnsFlags
)
)
;
mRetryWithDifferentIPFamily
=
false
;
mDnsFlags
^
=
(
nsIDNSService
:
:
RESOLVE_DISABLE_IPV6
|
nsIDNSService
:
:
RESOLVE_DISABLE_IPV4
)
;
if
(
(
mDnsFlags
&
nsIDNSService
:
:
RESOLVE_DISABLE_IPV6
)
&
&
(
mDnsFlags
&
nsIDNSService
:
:
RESOLVE_DISABLE_IPV4
)
)
{
mDnsFlags
&
=
~
(
nsIDNSService
:
:
RESOLVE_DISABLE_IPV6
|
nsIDNSService
:
:
RESOLVE_DISABLE_IPV4
)
;
LOG
(
(
"
DnsAndConnectSocket
:
:
TransportSetup
:
:
"
"
ToggleIpFamilyFlagsIfRetryEnabled
"
"
[
this
=
%
p
]
both
v6
and
v4
are
disabled
"
this
)
)
;
MOZ_DIAGNOSTIC_CRASH
(
"
both
v6
and
v4
addresses
are
disabled
"
)
;
}
mResetFamilyPreference
=
true
;
return
true
;
}
nsresult
DnsAndConnectSocket
:
:
TransportSetup
:
:
CheckConnectedResult
(
DnsAndConnectSocket
*
dnsAndSock
)
{
mState
=
TransportSetup
:
:
TransportSetupState
:
:
CONNECTING_DONE
;
MaybeSetConnectingDone
(
)
;
if
(
mSkipDnsResolution
)
{
return
NS_OK
;
}
bool
retryDns
=
false
;
mSocketTransport
-
>
GetRetryDnsIfPossible
(
&
retryDns
)
;
if
(
!
retryDns
)
{
return
NS_OK
;
}
bool
retry
=
false
;
if
(
ToggleIpFamilyFlagsIfRetryEnabled
(
)
)
{
retry
=
true
;
}
else
if
(
!
(
mDnsFlags
&
nsIDNSService
:
:
RESOLVE_DISABLE_TRR
)
)
{
bool
trrEnabled
;
mDNSRecord
-
>
IsTRR
(
&
trrEnabled
)
;
if
(
trrEnabled
)
{
nsIRequest
:
:
TRRMode
trrMode
=
nsIRequest
:
:
TRR_DEFAULT_MODE
;
mDNSRecord
-
>
GetEffectiveTRRMode
(
&
trrMode
)
;
if
(
trrMode
!
=
nsIRequest
:
:
TRR_ONLY_MODE
)
{
LOG
(
(
"
failed
to
connect
with
TRR
enabled
try
w
/
o
\
n
"
)
)
;
mDnsFlags
|
=
nsIDNSService
:
:
RESOLVE_DISABLE_TRR
|
nsIDNSService
:
:
RESOLVE_BYPASS_CACHE
|
nsIDNSService
:
:
RESOLVE_REFRESH_CACHE
;
retry
=
true
;
}
}
}
if
(
retry
)
{
LOG
(
(
"
retry
DNS
mDnsFlags
=
%
u
"
mDnsFlags
)
)
;
CloseAll
(
)
;
mState
=
TransportSetup
:
:
TransportSetupState
:
:
RETRY_RESOLVING
;
nsresult
rv
=
ResolveHost
(
dnsAndSock
)
;
if
(
NS_FAILED
(
rv
)
)
{
CloseAll
(
)
;
mState
=
TransportSetup
:
:
TransportSetupState
:
:
DONE
;
}
return
rv
;
}
return
NS_OK
;
}
nsresult
DnsAndConnectSocket
:
:
TransportSetup
:
:
SetupConn
(
DnsAndConnectSocket
*
dnsAndSock
nsAHttpTransaction
*
transaction
ConnectionEntry
*
ent
nsresult
status
uint32_t
cap
HttpConnectionBase
*
*
connection
)
{
RefPtr
<
HttpConnectionBase
>
conn
;
if
(
!
dnsAndSock
-
>
mIsHttp3
)
{
conn
=
new
nsHttpConnection
(
)
;
}
else
{
conn
=
new
HttpConnectionUDP
(
)
;
}
NotifyActivity
(
ent
-
>
mConnInfo
NS_HTTP_ACTIVITY_SUBTYPE_CONNECTION_CREATED
)
;
LOG
(
(
"
DnsAndConnectSocket
:
:
SocketTransport
:
:
SetupConn
"
"
Created
new
nshttpconnection
%
p
%
s
\
n
"
conn
.
get
(
)
dnsAndSock
-
>
mIsHttp3
?
"
using
http3
"
:
"
"
)
)
;
NullHttpTransaction
*
nullTrans
=
transaction
-
>
QueryNullTransaction
(
)
;
if
(
nullTrans
)
{
conn
-
>
BootstrapTimings
(
nullTrans
-
>
Timings
(
)
)
;
}
conn
-
>
SetTransactionCaps
(
transaction
-
>
Caps
(
)
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
transaction
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
nsresult
rv
=
NS_OK
;
if
(
!
dnsAndSock
-
>
mIsHttp3
)
{
RefPtr
<
nsHttpConnection
>
connTCP
=
do_QueryObject
(
conn
)
;
rv
=
connTCP
-
>
Init
(
ent
-
>
mConnInfo
gHttpHandler
-
>
ConnMgr
(
)
-
>
mMaxRequestDelay
mSocketTransport
mStreamIn
mStreamOut
mConnectedOK
status
callbacks
PR_MillisecondsToInterval
(
static_cast
<
uint32_t
>
(
(
TimeStamp
:
:
Now
(
)
-
mSynStarted
)
.
ToMilliseconds
(
)
)
)
cap
&
NS_HTTP_ALLOW_SPDY_WITHOUT_KEEPALIVE
)
;
}
else
{
RefPtr
<
HttpConnectionUDP
>
connUDP
=
do_QueryObject
(
conn
)
;
rv
=
connUDP
-
>
Init
(
ent
-
>
mConnInfo
mDNSRecord
status
callbacks
cap
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
nsHttpHandler
:
:
IsHttp3Enabled
(
)
&
&
StaticPrefs
:
:
network_http_http2_coalesce_hostnames
(
)
)
{
if
(
ent
-
>
MaybeProcessCoalescingKeys
(
mDNSRecord
true
)
)
{
gHttpHandler
-
>
ConnMgr
(
)
-
>
ProcessSpdyPendingQ
(
ent
)
;
}
}
}
}
bool
resetPreference
=
false
;
if
(
mResetFamilyPreference
|
|
(
mSocketTransport
&
&
NS_SUCCEEDED
(
mSocketTransport
-
>
GetResetIPFamilyPreference
(
&
resetPreference
)
)
&
&
resetPreference
)
)
{
ent
-
>
ResetIPFamilyPreference
(
)
;
}
NetAddr
peeraddr
;
if
(
mSocketTransport
&
&
NS_SUCCEEDED
(
mSocketTransport
-
>
GetPeerAddr
(
&
peeraddr
)
)
)
{
ent
-
>
RecordIPFamilyPreference
(
peeraddr
.
raw
.
family
)
;
}
conn
.
forget
(
connection
)
;
mSocketTransport
=
nullptr
;
mStreamOut
=
nullptr
;
mStreamIn
=
nullptr
;
mState
=
TransportSetup
:
:
TransportSetupState
:
:
DONE
;
return
rv
;
}
nsresult
DnsAndConnectSocket
:
:
TransportSetup
:
:
SetupStreams
(
DnsAndConnectSocket
*
dnsAndSock
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mSocketTransport
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mStreamOut
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mDNSRequest
)
;
nsresult
rv
;
nsTArray
<
nsCString
>
socketTypes
;
const
nsHttpConnectionInfo
*
ci
=
dnsAndSock
-
>
mConnInfo
;
if
(
dnsAndSock
-
>
mIsHttp3
)
{
socketTypes
.
AppendElement
(
"
quic
"
_ns
)
;
}
else
{
if
(
ci
-
>
FirstHopSSL
(
)
)
{
socketTypes
.
AppendElement
(
"
ssl
"
_ns
)
;
}
else
{
const
nsCString
&
defaultType
=
gHttpHandler
-
>
DefaultSocketType
(
)
;
if
(
!
defaultType
.
IsVoid
(
)
)
{
socketTypes
.
AppendElement
(
defaultType
)
;
}
}
}
nsCOMPtr
<
nsISocketTransport
>
socketTransport
;
nsCOMPtr
<
nsISocketTransportService
>
sts
;
sts
=
components
:
:
SocketTransport
:
:
Service
(
)
;
if
(
!
sts
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
LOG
(
(
"
DnsAndConnectSocket
:
:
SetupStreams
[
this
=
%
p
ent
=
%
s
]
"
"
setup
routed
transport
to
origin
%
s
:
%
d
via
%
s
:
%
d
\
n
"
this
ci
-
>
HashKey
(
)
.
get
(
)
ci
-
>
Origin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
RoutedHost
(
)
ci
-
>
RoutedPort
(
)
)
)
;
nsCOMPtr
<
nsIRoutedSocketTransportService
>
routedSTS
(
do_QueryInterface
(
sts
)
)
;
if
(
routedSTS
)
{
rv
=
routedSTS
-
>
CreateRoutedTransport
(
socketTypes
ci
-
>
GetOrigin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
GetRoutedHost
(
)
ci
-
>
RoutedPort
(
)
ci
-
>
ProxyInfo
(
)
mDNSRecord
getter_AddRefs
(
socketTransport
)
)
;
}
else
{
if
(
!
ci
-
>
GetRoutedHost
(
)
.
IsEmpty
(
)
)
{
LOG
(
(
"
DnsAndConnectSocket
this
=
%
p
using
legacy
nsISocketTransportService
"
"
means
explicit
route
%
s
:
%
d
will
be
ignored
.
\
n
"
this
ci
-
>
RoutedHost
(
)
ci
-
>
RoutedPort
(
)
)
)
;
}
rv
=
sts
-
>
CreateTransport
(
socketTypes
ci
-
>
GetOrigin
(
)
ci
-
>
OriginPort
(
)
ci
-
>
ProxyInfo
(
)
mDNSRecord
getter_AddRefs
(
socketTransport
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
tmpFlags
=
0
;
if
(
dnsAndSock
-
>
mCaps
&
NS_HTTP_REFRESH_DNS
)
{
tmpFlags
=
nsISocketTransport
:
:
BYPASS_CACHE
;
}
tmpFlags
|
=
nsISocketTransport
:
:
GetFlagsFromTRRMode
(
NS_HTTP_TRR_MODE_FROM_FLAGS
(
dnsAndSock
-
>
mCaps
)
)
;
if
(
dnsAndSock
-
>
mCaps
&
NS_HTTP_LOAD_ANONYMOUS
)
{
tmpFlags
|
=
nsISocketTransport
:
:
ANONYMOUS_CONNECT
;
}
if
(
(
dnsAndSock
-
>
mCaps
&
NS_HTTP_LOAD_ANONYMOUS_CONNECT_ALLOW_CLIENT_CERT
)
|
|
ci
-
>
GetAnonymousAllowClientCert
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
ANONYMOUS_CONNECT_ALLOW_CLIENT_CERT
;
}
if
(
ci
-
>
GetPrivate
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
NO_PERMANENT_STORAGE
;
}
(
void
)
socketTransport
-
>
SetIsPrivate
(
ci
-
>
GetPrivate
(
)
)
;
if
(
dnsAndSock
-
>
mCaps
&
NS_HTTP_DISALLOW_ECH
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DONT_TRY_ECH
;
}
if
(
dnsAndSock
-
>
mCaps
&
NS_HTTP_IS_RETRY
)
{
tmpFlags
|
=
nsISocketTransport
:
:
IS_RETRY
;
}
if
(
(
(
dnsAndSock
-
>
mCaps
&
NS_HTTP_BE_CONSERVATIVE
)
|
|
ci
-
>
GetBeConservative
(
)
)
&
&
gHttpHandler
-
>
ConnMgr
(
)
-
>
BeConservativeIfProxied
(
ci
-
>
ProxyInfo
(
)
)
)
{
LOG
(
(
"
Setting
Socket
to
BE_CONSERVATIVE
"
)
)
;
tmpFlags
|
=
nsISocketTransport
:
:
BE_CONSERVATIVE
;
}
if
(
ci
-
>
HasIPHintAddress
(
)
)
{
nsCOMPtr
<
nsIDNSService
>
dns
;
dns
=
mozilla
:
:
components
:
:
DNS
:
:
Service
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDNSRecord
>
record
;
rv
=
dns
-
>
ResolveNative
(
mHost
nsIDNSService
:
:
RESOLVE_OFFLINE
dnsAndSock
-
>
mConnInfo
-
>
GetOriginAttributes
(
)
getter_AddRefs
(
record
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
record
)
{
LOG
(
(
"
Setting
Socket
to
use
IP
hint
address
"
)
)
;
tmpFlags
|
=
nsISocketTransport
:
:
USE_IP_HINT_ADDRESS
;
}
}
if
(
mRetryWithDifferentIPFamily
)
{
uint16_t
fallbackTimeout
=
mIsBackup
?
gHttpHandler
-
>
GetFallbackSynTimeout
(
)
:
0
;
if
(
fallbackTimeout
)
{
socketTransport
-
>
SetTimeout
(
nsISocketTransport
:
:
TIMEOUT_CONNECT
fallbackTimeout
)
;
}
}
if
(
!
dnsAndSock
-
>
Allow1918
(
)
)
{
tmpFlags
|
=
nsISocketTransport
:
:
DISABLE_RFC1918
;
}
if
(
dnsAndSock
-
>
mSpeculative
)
{
tmpFlags
|
=
nsISocketTransport
:
:
IS_SPECULATIVE_CONNECTION
;
}
socketTransport
-
>
SetConnectionFlags
(
tmpFlags
)
;
socketTransport
-
>
SetTlsFlags
(
ci
-
>
GetTlsFlags
(
)
)
;
const
OriginAttributes
&
originAttributes
=
dnsAndSock
-
>
mConnInfo
-
>
GetOriginAttributes
(
)
;
if
(
originAttributes
!
=
OriginAttributes
(
)
)
{
socketTransport
-
>
SetOriginAttributes
(
originAttributes
)
;
}
socketTransport
-
>
SetQoSBits
(
gHttpHandler
-
>
GetQoSBits
(
)
)
;
rv
=
socketTransport
-
>
SetEventSink
(
dnsAndSock
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
socketTransport
-
>
SetSecurityCallbacks
(
dnsAndSock
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
nsHttpHandler
:
:
EchConfigEnabled
(
)
&
&
!
ci
-
>
GetEchConfig
(
)
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
!
dnsAndSock
-
>
mIsHttp3
)
;
LOG
(
(
"
Setting
ECH
"
)
)
;
rv
=
socketTransport
-
>
SetEchConfig
(
ci
-
>
GetEchConfig
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NotifyActivity
(
dnsAndSock
-
>
mConnInfo
NS_HTTP_ACTIVITY_SUBTYPE_ECH_SET
)
;
}
RefPtr
<
ConnectionEntry
>
ent
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
FindConnectionEntry
(
ci
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ent
)
;
if
(
ent
)
{
glean
:
:
http
:
:
connection_entry_cache_hit
.
EnumGet
(
static_cast
<
glean
:
:
http
:
:
ConnectionEntryCacheHitLabel
>
(
ent
-
>
mUsedForConnection
)
)
.
Add
(
)
;
ent
-
>
mUsedForConnection
=
true
;
}
nsCOMPtr
<
nsIOutputStream
>
sout
;
rv
=
socketTransport
-
>
OpenOutputStream
(
nsITransport
:
:
OPEN_UNBUFFERED
0
0
getter_AddRefs
(
sout
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
sin
;
rv
=
socketTransport
-
>
OpenInputStream
(
nsITransport
:
:
OPEN_UNBUFFERED
0
0
getter_AddRefs
(
sin
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mSocketTransport
=
socketTransport
.
forget
(
)
;
mStreamIn
=
do_QueryInterface
(
sin
)
;
mStreamOut
=
do_QueryInterface
(
sout
)
;
rv
=
mStreamOut
-
>
AsyncWait
(
dnsAndSock
0
0
nullptr
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
SetConnecting
(
)
;
}
return
rv
;
}
nsresult
DnsAndConnectSocket
:
:
TransportSetup
:
:
ResolveHost
(
DnsAndConnectSocket
*
dnsAndSock
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mSocketTransport
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mStreamOut
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mDNSRequest
)
;
LOG
(
(
"
DnsAndConnectSocket
:
:
TransportSetup
:
:
ResolveHost
[
this
=
%
p
%
s
%
s
]
"
this
PromiseFlatCString
(
mHost
)
.
get
(
)
(
mDnsFlags
&
nsIDNSService
:
:
RESOLVE_BYPASS_CACHE
)
?
"
bypass
cache
"
:
"
"
)
)
;
nsCOMPtr
<
nsIDNSService
>
dns
=
GetOrInitDNSService
(
)
;
if
(
!
dns
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mIsBackup
)
{
dnsAndSock
-
>
mTransaction
-
>
OnTransportStatus
(
nullptr
NS_NET_STATUS_RESOLVING_HOST
0
)
;
}
nsresult
rv
=
NS_OK
;
do
{
rv
=
dns
-
>
AsyncResolveNative
(
mHost
nsIDNSService
:
:
RESOLVE_TYPE_DEFAULT
mDnsFlags
|
nsIDNSService
:
:
RESOLVE_WANT_RECORD_ON_ERROR
nullptr
dnsAndSock
gSocketTransportService
dnsAndSock
-
>
mConnInfo
-
>
GetOriginAttributes
(
)
getter_AddRefs
(
mDNSRequest
)
)
;
}
while
(
NS_FAILED
(
rv
)
&
&
ShouldRetryDNS
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mDNSRequest
=
nullptr
;
}
return
rv
;
}
bool
DnsAndConnectSocket
:
:
TransportSetup
:
:
ShouldRetryDNS
(
)
{
if
(
mDnsFlags
&
nsIDNSService
:
:
RESOLVE_IP_HINT
)
{
mDnsFlags
&
=
~
nsIDNSService
:
:
RESOLVE_IP_HINT
;
return
true
;
}
if
(
ToggleIpFamilyFlagsIfRetryEnabled
(
)
)
{
return
true
;
}
return
false
;
}
nsresult
DnsAndConnectSocket
:
:
TransportSetup
:
:
OnLookupComplete
(
DnsAndConnectSocket
*
dnsAndSock
nsIDNSRecord
*
rec
nsresult
status
)
{
mDNSRequest
=
nullptr
;
if
(
NS_SUCCEEDED
(
status
)
)
{
mDNSRecord
=
do_QueryInterface
(
rec
)
;
MOZ_ASSERT
(
mDNSRecord
)
;
if
(
dnsAndSock
-
>
mIsHttp3
)
{
mState
=
TransportSetup
:
:
TransportSetupState
:
:
RESOLVED
;
return
status
;
}
nsresult
rv
=
SetupStreams
(
dnsAndSock
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mState
=
TransportSetup
:
:
TransportSetupState
:
:
CONNECTING
;
}
else
{
CloseAll
(
)
;
mState
=
TransportSetup
:
:
TransportSetupState
:
:
DONE
;
}
return
rv
;
}
if
(
ShouldRetryDNS
(
)
)
{
mState
=
TransportSetup
:
:
TransportSetupState
:
:
RETRY_RESOLVING
;
nsresult
rv
=
ResolveHost
(
dnsAndSock
)
;
if
(
NS_FAILED
(
rv
)
)
{
CloseAll
(
)
;
mState
=
TransportSetup
:
:
TransportSetupState
:
:
DONE
;
}
return
rv
;
}
mState
=
TransportSetup
:
:
TransportSetupState
:
:
DONE
;
return
status
;
}
}
}
