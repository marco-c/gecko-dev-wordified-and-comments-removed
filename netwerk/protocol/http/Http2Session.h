#
ifndef
mozilla_net_Http2Session_h
#
define
mozilla_net_Http2Session_h
#
include
"
ASpdySession
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsAHttpConnection
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsHttpRequestHead
.
h
"
#
include
"
nsICacheEntryOpenCallback
.
h
"
#
include
"
Http2Compression
.
h
"
class
nsISocketTransport
;
namespace
mozilla
{
namespace
net
{
class
Http2PushedStream
;
class
Http2Stream
;
class
nsHttpTransaction
;
class
Http2Session
final
:
public
ASpdySession
public
nsAHttpConnection
public
nsAHttpSegmentReader
public
nsAHttpSegmentWriter
{
~
Http2Session
(
)
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSAHTTPTRANSACTION
NS_DECL_NSAHTTPCONNECTION
(
mConnection
)
NS_DECL_NSAHTTPSEGMENTREADER
NS_DECL_NSAHTTPSEGMENTWRITER
Http2Session
(
nsISocketTransport
*
enum
SpdyVersion
version
bool
attemptingEarlyData
)
;
MOZ_MUST_USE
bool
AddStream
(
nsAHttpTransaction
*
int32_t
bool
nsIInterfaceRequestor
*
)
override
;
bool
CanReuse
(
)
override
{
return
!
mShouldGoAway
&
&
!
mClosed
;
}
bool
RoomForMoreStreams
(
)
override
;
enum
SpdyVersion
SpdyVersion
(
)
override
;
bool
TestJoinConnection
(
const
nsACString
&
hostname
int32_t
port
)
override
;
bool
JoinConnection
(
const
nsACString
&
hostname
int32_t
port
)
override
;
uint32_t
ReadTimeoutTick
(
PRIntervalTime
now
)
override
;
PRIntervalTime
IdleTime
(
)
override
;
uint32_t
RegisterStreamID
(
Http2Stream
*
uint32_t
aNewID
=
0
)
;
enum
FrameType
{
FRAME_TYPE_DATA
=
0x0
FRAME_TYPE_HEADERS
=
0x1
FRAME_TYPE_PRIORITY
=
0x2
FRAME_TYPE_RST_STREAM
=
0x3
FRAME_TYPE_SETTINGS
=
0x4
FRAME_TYPE_PUSH_PROMISE
=
0x5
FRAME_TYPE_PING
=
0x6
FRAME_TYPE_GOAWAY
=
0x7
FRAME_TYPE_WINDOW_UPDATE
=
0x8
FRAME_TYPE_CONTINUATION
=
0x9
FRAME_TYPE_ALTSVC
=
0xA
FRAME_TYPE_UNUSED
=
0xB
FRAME_TYPE_ORIGIN
=
0xC
FRAME_TYPE_LAST
=
0xD
}
;
enum
errorType
{
NO_HTTP_ERROR
=
0
PROTOCOL_ERROR
=
1
INTERNAL_ERROR
=
2
FLOW_CONTROL_ERROR
=
3
SETTINGS_TIMEOUT_ERROR
=
4
STREAM_CLOSED_ERROR
=
5
FRAME_SIZE_ERROR
=
6
REFUSED_STREAM_ERROR
=
7
CANCEL_ERROR
=
8
COMPRESSION_ERROR
=
9
CONNECT_ERROR
=
10
ENHANCE_YOUR_CALM
=
11
INADEQUATE_SECURITY
=
12
HTTP_1_1_REQUIRED
=
13
UNASSIGNED
=
31
}
;
const
static
uint8_t
kFlag_END_STREAM
=
0x01
;
const
static
uint8_t
kFlag_END_HEADERS
=
0x04
;
const
static
uint8_t
kFlag_END_PUSH_PROMISE
=
0x04
;
const
static
uint8_t
kFlag_ACK
=
0x01
;
const
static
uint8_t
kFlag_PADDED
=
0x08
;
const
static
uint8_t
kFlag_PRIORITY
=
0x20
;
enum
{
SETTINGS_TYPE_HEADER_TABLE_SIZE
=
1
SETTINGS_TYPE_ENABLE_PUSH
=
2
SETTINGS_TYPE_MAX_CONCURRENT
=
3
SETTINGS_TYPE_INITIAL_WINDOW
=
4
SETTINGS_TYPE_MAX_FRAME_SIZE
=
5
}
;
const
static
uint32_t
kDefaultBufferSize
=
2048
;
const
static
uint32_t
kDefaultQueueSize
=
32768
;
const
static
uint32_t
kQueueMinimumCleanup
=
24576
;
const
static
uint32_t
kQueueTailRoom
=
4096
;
const
static
uint32_t
kQueueReserved
=
1024
;
const
static
uint32_t
kMaxStreamID
=
0x7800000
;
const
static
uint32_t
kDeadStreamID
=
0xffffdead
;
const
static
int32_t
kEmergencyWindowThreshold
=
96
*
1024
;
const
static
uint32_t
kMinimumToAck
=
4
*
1024
*
1024
;
const
static
uint32_t
kDefaultRwin
=
65535
;
const
static
uint32_t
kMaxFrameData
=
0x4000
;
const
static
uint8_t
kFrameLengthBytes
=
3
;
const
static
uint8_t
kFrameStreamIDBytes
=
4
;
const
static
uint8_t
kFrameFlagBytes
=
1
;
const
static
uint8_t
kFrameTypeBytes
=
1
;
const
static
uint8_t
kFrameHeaderBytes
=
kFrameLengthBytes
+
kFrameFlagBytes
+
kFrameTypeBytes
+
kFrameStreamIDBytes
;
enum
{
kLeaderGroupID
=
0x3
kOtherGroupID
=
0x5
kBackgroundGroupID
=
0x7
kSpeculativeGroupID
=
0x9
kFollowerGroupID
=
0xB
kUrgentStartGroupID
=
0xD
}
;
const
static
uint8_t
kPriorityGroupCount
=
6
;
static
nsresult
RecvHeaders
(
Http2Session
*
)
;
static
nsresult
RecvPriority
(
Http2Session
*
)
;
static
nsresult
RecvRstStream
(
Http2Session
*
)
;
static
nsresult
RecvSettings
(
Http2Session
*
)
;
static
nsresult
RecvPushPromise
(
Http2Session
*
)
;
static
nsresult
RecvPing
(
Http2Session
*
)
;
static
nsresult
RecvGoAway
(
Http2Session
*
)
;
static
nsresult
RecvWindowUpdate
(
Http2Session
*
)
;
static
nsresult
RecvContinuation
(
Http2Session
*
)
;
static
nsresult
RecvAltSvc
(
Http2Session
*
)
;
static
nsresult
RecvUnused
(
Http2Session
*
)
;
static
nsresult
RecvOrigin
(
Http2Session
*
)
;
char
*
EnsureOutputBuffer
(
uint32_t
needed
)
;
template
<
typename
charType
>
void
CreateFrameHeader
(
charType
dest
uint16_t
frameLength
uint8_t
frameType
uint8_t
frameFlags
uint32_t
streamID
)
;
static
void
LogIO
(
Http2Session
*
Http2Stream
*
const
char
*
const
char
*
uint32_t
)
;
void
TransactionHasDataToWrite
(
nsAHttpTransaction
*
)
override
;
void
TransactionHasDataToRecv
(
nsAHttpTransaction
*
)
override
;
void
TransactionHasDataToWrite
(
Http2Stream
*
)
;
virtual
MOZ_MUST_USE
nsresult
CommitToSegmentSize
(
uint32_t
size
bool
forceCommitment
)
override
;
MOZ_MUST_USE
nsresult
BufferOutput
(
const
char
*
uint32_t
uint32_t
*
)
;
void
FlushOutputQueue
(
)
;
uint32_t
AmountOfOutputBuffered
(
)
{
return
mOutputQueueUsed
-
mOutputQueueSent
;
}
uint32_t
GetServerInitialStreamWindow
(
)
{
return
mServerInitialStreamWindow
;
}
MOZ_MUST_USE
bool
TryToActivate
(
Http2Stream
*
stream
)
;
void
ConnectPushedStream
(
Http2Stream
*
stream
)
;
void
ConnectSlowConsumer
(
Http2Stream
*
stream
)
;
MOZ_MUST_USE
nsresult
ConfirmTLSProfile
(
)
;
static
MOZ_MUST_USE
bool
ALPNCallback
(
nsISupports
*
securityInfo
)
;
uint64_t
Serial
(
)
{
return
mSerial
;
}
void
PrintDiagnostics
(
nsCString
&
log
)
override
;
uint32_t
SendingChunkSize
(
)
{
return
mSendingChunkSize
;
}
uint32_t
PushAllowance
(
)
{
return
mPushAllowance
;
}
Http2Compressor
*
Compressor
(
)
{
return
&
mCompressor
;
}
nsISocketTransport
*
SocketTransport
(
)
{
return
mSocketTransport
;
}
int64_t
ServerSessionWindow
(
)
{
return
mServerSessionWindow
;
}
void
DecrementServerSessionWindow
(
uint32_t
bytes
)
{
mServerSessionWindow
-
=
bytes
;
}
uint32_t
InitialRwin
(
)
{
return
mInitialRwin
;
}
void
SendPing
(
)
override
;
MOZ_MUST_USE
bool
MaybeReTunnel
(
nsAHttpTransaction
*
)
override
;
bool
UseH2Deps
(
)
{
return
mUseH2Deps
;
}
MOZ_MUST_USE
nsresult
ReadSegmentsAgain
(
nsAHttpSegmentReader
*
uint32_t
uint32_t
*
bool
*
)
final
;
MOZ_MUST_USE
nsresult
WriteSegmentsAgain
(
nsAHttpSegmentWriter
*
uint32_t
uint32_t
*
bool
*
)
final
;
MOZ_MUST_USE
bool
Do0RTT
(
)
final
{
return
true
;
}
MOZ_MUST_USE
nsresult
Finish0RTT
(
bool
aRestart
bool
aAlpnChanged
)
final
;
void
SetFastOpenStatus
(
uint8_t
aStatus
)
final
;
void
Received421
(
nsHttpConnectionInfo
*
ci
)
;
void
SendPriorityFrame
(
uint32_t
streamID
uint32_t
dependsOn
uint8_t
weight
)
;
private
:
enum
internalStateType
{
BUFFERING_OPENING_SETTINGS
BUFFERING_FRAME_HEADER
BUFFERING_CONTROL_FRAME
PROCESSING_DATA_FRAME_PADDING_CONTROL
PROCESSING_DATA_FRAME
DISCARDING_DATA_FRAME_PADDING
DISCARDING_DATA_FRAME
PROCESSING_COMPLETE_HEADERS
PROCESSING_CONTROL_RST_STREAM
NOT_USING_NETWORK
}
;
static
const
uint8_t
kMagicHello
[
24
]
;
MOZ_MUST_USE
nsresult
ResponseHeadersComplete
(
)
;
uint32_t
GetWriteQueueSize
(
)
;
void
ChangeDownstreamState
(
enum
internalStateType
)
;
void
ResetDownstreamState
(
)
;
MOZ_MUST_USE
nsresult
ReadyToProcessDataFrame
(
enum
internalStateType
)
;
MOZ_MUST_USE
nsresult
UncompressAndDiscard
(
bool
)
;
void
GeneratePing
(
bool
)
;
void
GenerateSettingsAck
(
)
;
void
GeneratePriority
(
uint32_t
uint8_t
)
;
void
GenerateRstStream
(
uint32_t
uint32_t
)
;
void
GenerateGoAway
(
uint32_t
)
;
void
CleanupStream
(
Http2Stream
*
nsresult
errorType
)
;
void
CleanupStream
(
uint32_t
nsresult
errorType
)
;
void
CloseStream
(
Http2Stream
*
nsresult
)
;
void
SendHello
(
)
;
void
RemoveStreamFromQueues
(
Http2Stream
*
)
;
MOZ_MUST_USE
nsresult
ParsePadding
(
uint8_t
&
uint16_t
&
)
;
void
SetWriteCallbacks
(
)
;
void
RealignOutputQueue
(
)
;
void
ProcessPending
(
)
;
MOZ_MUST_USE
nsresult
ProcessConnectedPush
(
Http2Stream
*
nsAHttpSegmentWriter
*
uint32_t
uint32_t
*
)
;
MOZ_MUST_USE
nsresult
ProcessSlowConsumer
(
Http2Stream
*
nsAHttpSegmentWriter
*
uint32_t
uint32_t
*
)
;
MOZ_MUST_USE
nsresult
SetInputFrameDataStream
(
uint32_t
)
;
void
CreatePriorityNode
(
uint32_t
uint32_t
uint8_t
const
char
*
)
;
char
*
CreatePriorityFrame
(
uint32_t
uint32_t
uint8_t
)
;
bool
VerifyStream
(
Http2Stream
*
uint32_t
)
;
void
SetNeedsCleanup
(
)
;
void
UpdateLocalRwin
(
Http2Stream
*
stream
uint32_t
bytes
)
;
void
UpdateLocalStreamWindow
(
Http2Stream
*
stream
uint32_t
bytes
)
;
void
UpdateLocalSessionWindow
(
uint32_t
bytes
)
;
void
MaybeDecrementConcurrent
(
Http2Stream
*
stream
)
;
bool
RoomForMoreConcurrent
(
)
;
void
IncrementConcurrent
(
Http2Stream
*
stream
)
;
void
QueueStream
(
Http2Stream
*
stream
)
;
MOZ_MUST_USE
nsresult
NetworkRead
(
nsAHttpSegmentWriter
*
char
*
uint32_t
uint32_t
*
)
;
void
Shutdown
(
)
;
RefPtr
<
nsAHttpConnection
>
mConnection
;
nsISocketTransport
*
mSocketTransport
;
nsAHttpSegmentReader
*
mSegmentReader
;
nsAHttpSegmentWriter
*
mSegmentWriter
;
uint32_t
mSendingChunkSize
;
uint32_t
mNextStreamID
;
uint32_t
mLastPushedID
;
uint32_t
mConcurrentHighWater
;
uint32_t
mPushAllowance
;
internalStateType
mDownstreamState
;
nsDataHashtable
<
nsUint32HashKey
Http2Stream
*
>
mStreamIDHash
;
nsClassHashtable
<
nsPtrHashKey
<
nsAHttpTransaction
>
Http2Stream
>
mStreamTransactionHash
;
nsDeque
mReadyForWrite
;
nsDeque
mQueuedStreams
;
nsDeque
mPushesReadyForRead
;
nsDeque
mSlowConsumersReadyForRead
;
nsTArray
<
Http2PushedStream
*
>
mPushedStreams
;
Http2Compressor
mCompressor
;
Http2Decompressor
mDecompressor
;
nsCString
mDecompressBuffer
;
uint32_t
mInputFrameBufferSize
;
uint32_t
mInputFrameBufferUsed
;
UniquePtr
<
char
[
]
>
mInputFrameBuffer
;
uint32_t
mInputFrameDataSize
;
uint32_t
mInputFrameDataRead
;
bool
mInputFrameFinal
;
uint8_t
mInputFrameType
;
uint8_t
mInputFrameFlags
;
uint32_t
mInputFrameID
;
uint16_t
mPaddingLength
;
Http2Stream
*
mInputFrameDataStream
;
Http2Stream
*
mNeedsCleanup
;
uint32_t
mDownstreamRstReason
;
uint32_t
mExpectedHeaderID
;
uint32_t
mExpectedPushPromiseID
;
uint32_t
mContinuedPromiseStream
;
nsCString
mFlatHTTPResponseHeaders
;
uint32_t
mFlatHTTPResponseHeadersOut
;
bool
mShouldGoAway
;
bool
mClosed
;
bool
mCleanShutdown
;
bool
mReceivedSettings
;
bool
mTLSProfileConfirmed
;
errorType
mGoAwayReason
;
int32_t
mClientGoAwayReason
;
int32_t
mPeerGoAwayReason
;
uint32_t
mGoAwayID
;
uint32_t
mOutgoingGoAwayID
;
uint32_t
mMaxConcurrent
;
uint32_t
mConcurrent
;
uint32_t
mServerPushedResources
;
uint32_t
mServerInitialStreamWindow
;
int64_t
mLocalSessionWindow
;
int64_t
mServerSessionWindow
;
uint32_t
mInitialRwin
;
uint32_t
mOutputQueueSize
;
uint32_t
mOutputQueueUsed
;
uint32_t
mOutputQueueSent
;
UniquePtr
<
char
[
]
>
mOutputQueueBuffer
;
PRIntervalTime
mPingThreshold
;
PRIntervalTime
mLastReadEpoch
;
PRIntervalTime
mLastDataReadEpoch
;
PRIntervalTime
mPingSentEpoch
;
PRIntervalTime
mPreviousPingThreshold
;
bool
mPreviousUsed
;
nsDeque
mGoAwayStreamsToRestart
;
uint64_t
mSerial
;
uint32_t
mAggregatedHeaderSize
;
bool
mWaitingForSettingsAck
;
bool
mGoAwayOnPush
;
bool
mUseH2Deps
;
bool
mAttemptingEarlyData
;
nsTArray
<
WeakPtr
<
Http2Stream
>
>
m0RTTStreams
;
nsTArray
<
WeakPtr
<
Http2Stream
>
>
mCannotDo0RTTStreams
;
bool
RealJoinConnection
(
const
nsACString
&
hostname
int32_t
port
bool
jk
)
;
bool
TestOriginFrame
(
const
nsACString
&
name
int32_t
port
)
;
bool
mOriginFrameActivated
;
nsDataHashtable
<
nsCStringHashKey
bool
>
mOriginFrame
;
nsDataHashtable
<
nsCStringHashKey
bool
>
mJoinConnectionCache
;
uint64_t
mCurrentForegroundTabOuterContentWindowId
;
class
CachePushCheckCallback
final
:
public
nsICacheEntryOpenCallback
{
public
:
CachePushCheckCallback
(
Http2Session
*
session
uint32_t
promisedID
const
nsACString
&
requestString
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSICACHEENTRYOPENCALLBACK
private
:
~
CachePushCheckCallback
(
)
=
default
;
RefPtr
<
Http2Session
>
mSession
;
uint32_t
mPromisedID
;
nsHttpRequestHead
mRequestHead
;
}
;
RefPtr
<
nsHttpTransaction
>
mFirstHttpTransaction
;
bool
mTlsHandshakeFinished
;
bool
mCheckNetworkStallsWithTFO
;
PRIntervalTime
mLastRequestBytesSentTime
;
private
:
void
DispatchOnTunnel
(
nsAHttpTransaction
*
nsIInterfaceRequestor
*
)
;
void
CreateTunnel
(
nsHttpTransaction
*
nsHttpConnectionInfo
*
nsIInterfaceRequestor
*
)
;
void
RegisterTunnel
(
Http2Stream
*
)
;
void
UnRegisterTunnel
(
Http2Stream
*
)
;
uint32_t
FindTunnelCount
(
nsHttpConnectionInfo
*
)
;
nsDataHashtable
<
nsCStringHashKey
uint32_t
>
mTunnelHash
;
}
;
}
}
#
endif
