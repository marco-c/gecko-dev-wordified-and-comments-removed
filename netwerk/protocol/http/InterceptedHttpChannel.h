#
ifndef
mozilla_net_InterceptedHttpChannel_h
#
define
mozilla_net_InterceptedHttpChannel_h
#
include
"
HttpBaseChannel
.
h
"
#
include
"
nsINetworkInterceptController
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsIChannelWithDivertableParentListener
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
namespace
mozilla
{
namespace
net
{
class
InterceptedHttpChannel
final
:
public
HttpBaseChannel
public
HttpAsyncAborter
<
InterceptedHttpChannel
>
public
nsIInterceptedChannel
public
nsICacheInfoChannel
public
nsIAsyncVerifyRedirectCallback
public
nsIStreamListener
public
nsIChannelWithDivertableParentListener
public
nsIThreadRetargetableRequest
public
nsIThreadRetargetableStreamListener
{
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIINTERCEPTEDCHANNEL
NS_DECL_NSICACHEINFOCHANNEL
NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSICHANNELWITHDIVERTABLEPARENTLISTENER
NS_DECL_NSITHREADRETARGETABLEREQUEST
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
private
:
friend
class
HttpAsyncAborter
<
InterceptedHttpChannel
>
;
UniquePtr
<
nsHttpResponseHead
>
mSynthesizedResponseHead
;
nsCOMPtr
<
nsIChannel
>
mRedirectChannel
;
nsCOMPtr
<
nsIInputStream
>
mBodyReader
;
nsCOMPtr
<
nsISupports
>
mReleaseHandle
;
nsCOMPtr
<
nsIProgressEventSink
>
mProgressSink
;
nsCOMPtr
<
nsIInterceptedBodyCallback
>
mBodyCallback
;
nsCOMPtr
<
nsICacheInfoChannel
>
mSynthesizedCacheInfo
;
RefPtr
<
nsInputStreamPump
>
mPump
;
RefPtr
<
ADivertableParentChannel
>
mParentChannel
;
TimeStamp
mFinishResponseStart
;
TimeStamp
mFinishResponseEnd
;
Atomic
<
int64_t
>
mProgress
;
int64_t
mProgressReported
;
int64_t
mSynthesizedStreamLength
;
uint64_t
mResumeStartPos
;
nsCString
mResumeEntityId
;
nsString
mStatusHost
;
enum
{
Invalid
=
0
Synthesized
Reset
}
mSynthesizedOrReset
;
Atomic
<
bool
>
mCallingStatusAndProgress
;
bool
mDiverting
;
InterceptedHttpChannel
(
PRTime
aCreationTime
const
TimeStamp
&
aCreationTimestamp
const
TimeStamp
&
aAsyncOpenTimestamp
)
;
~
InterceptedHttpChannel
(
)
=
default
;
virtual
void
ReleaseListeners
(
)
override
;
virtual
MOZ_MUST_USE
nsresult
SetupReplacementChannel
(
nsIURI
*
aURI
nsIChannel
*
aChannel
bool
aPreserveMethod
uint32_t
aRedirectFlags
)
override
;
void
AsyncOpenInternal
(
)
;
bool
ShouldRedirect
(
)
const
;
nsresult
FollowSyntheticRedirect
(
)
;
nsresult
RedirectForResponseURL
(
nsIURI
*
aResponseURI
bool
aResponseRedirected
)
;
nsresult
StartPump
(
)
;
nsresult
OpenRedirectChannel
(
)
;
void
MaybeCallStatusAndProgress
(
)
;
void
MaybeCallBodyCallback
(
)
;
public
:
static
already_AddRefed
<
InterceptedHttpChannel
>
CreateForInterception
(
PRTime
aCreationTime
const
TimeStamp
&
aCreationTimestamp
const
TimeStamp
&
aAsyncOpenTimestamp
)
;
static
already_AddRefed
<
InterceptedHttpChannel
>
CreateForSynthesis
(
const
nsHttpResponseHead
*
aHead
nsIInputStream
*
aBody
nsIInterceptedBodyCallback
*
aBodyCallback
PRTime
aCreationTime
const
TimeStamp
&
aCreationTimestamp
const
TimeStamp
&
aAsyncOpenTimestamp
)
;
NS_IMETHOD
Cancel
(
nsresult
aStatus
)
override
;
NS_IMETHOD
Suspend
(
void
)
override
;
NS_IMETHOD
Resume
(
void
)
override
;
NS_IMETHOD
GetSecurityInfo
(
nsISupports
*
*
aSecurityInfo
)
override
;
NS_IMETHOD
AsyncOpen
(
nsIStreamListener
*
aListener
nsISupports
*
aContext
)
override
;
NS_IMETHOD
AsyncOpen2
(
nsIStreamListener
*
aListener
)
override
;
NS_IMETHOD
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
override
;
NS_IMETHOD
SetupFallbackChannel
(
const
char
*
aFallbackKey
)
override
;
NS_IMETHOD
SetPriority
(
int32_t
aPriority
)
override
;
NS_IMETHOD
SetClassFlags
(
uint32_t
aClassFlags
)
override
;
NS_IMETHOD
ClearClassFlags
(
uint32_t
flags
)
override
;
NS_IMETHOD
AddClassFlags
(
uint32_t
flags
)
override
;
NS_IMETHOD
ResumeAt
(
uint64_t
startPos
const
nsACString
&
entityID
)
override
;
void
DoNotifyListenerCleanup
(
)
override
;
void
DoAsyncAbort
(
nsresult
aStatus
)
override
;
}
;
}
}
#
endif
