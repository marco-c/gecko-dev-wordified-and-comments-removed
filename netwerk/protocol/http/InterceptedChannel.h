#
ifndef
InterceptedChannel_h
#
define
InterceptedChannel_h
#
include
"
nsINetworkInterceptController
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
class
nsICacheEntry
;
class
nsInputStreamPump
;
class
nsIStreamListener
;
namespace
mozilla
{
namespace
net
{
class
nsHttpChannel
;
class
HttpChannelChild
;
class
nsHttpResponseHead
;
class
InterceptStreamListener
;
class
InterceptedChannelBase
:
public
nsIInterceptedChannel
{
protected
:
nsCOMPtr
<
nsINetworkInterceptController
>
mController
;
nsCOMPtr
<
nsIOutputStream
>
mResponseBody
;
Maybe
<
nsAutoPtr
<
nsHttpResponseHead
>
>
mSynthesizedResponseHead
;
nsCOMPtr
<
nsIConsoleReportCollector
>
mReportCollector
;
void
EnsureSynthesizedResponse
(
)
;
void
DoNotifyController
(
)
;
nsresult
DoSynthesizeStatus
(
uint16_t
aStatus
const
nsACString
&
aReason
)
;
nsresult
DoSynthesizeHeader
(
const
nsACString
&
aName
const
nsACString
&
aValue
)
;
virtual
~
InterceptedChannelBase
(
)
;
public
:
explicit
InterceptedChannelBase
(
nsINetworkInterceptController
*
aController
)
;
virtual
void
NotifyController
(
)
=
0
;
NS_DECL_ISUPPORTS
NS_IMETHOD
GetResponseBody
(
nsIOutputStream
*
*
aOutput
)
override
;
NS_IMETHOD
GetConsoleReportCollector
(
nsIConsoleReportCollector
*
*
aCollectorOut
)
override
;
static
already_AddRefed
<
nsIURI
>
SecureUpgradeChannelURI
(
nsIChannel
*
aChannel
)
;
}
;
class
InterceptedChannelChrome
:
public
InterceptedChannelBase
{
RefPtr
<
nsHttpChannel
>
mChannel
;
nsCOMPtr
<
nsICacheEntry
>
mSynthesizedCacheEntry
;
bool
mOldApplyConversion
;
public
:
InterceptedChannelChrome
(
nsHttpChannel
*
aChannel
nsINetworkInterceptController
*
aController
nsICacheEntry
*
aEntry
)
;
NS_IMETHOD
ResetInterception
(
)
override
;
NS_IMETHOD
FinishSynthesizedResponse
(
const
nsACString
&
aFinalURLSpec
)
override
;
NS_IMETHOD
GetChannel
(
nsIChannel
*
*
aChannel
)
override
;
NS_IMETHOD
GetSecureUpgradedChannelURI
(
nsIURI
*
*
aURI
)
override
;
NS_IMETHOD
SynthesizeStatus
(
uint16_t
aStatus
const
nsACString
&
aReason
)
override
;
NS_IMETHOD
SynthesizeHeader
(
const
nsACString
&
aName
const
nsACString
&
aValue
)
override
;
NS_IMETHOD
Cancel
(
nsresult
aStatus
)
override
;
NS_IMETHOD
SetChannelInfo
(
mozilla
:
:
dom
:
:
ChannelInfo
*
aChannelInfo
)
override
;
NS_IMETHOD
GetInternalContentPolicyType
(
nsContentPolicyType
*
aInternalContentPolicyType
)
override
;
virtual
void
NotifyController
(
)
override
;
}
;
class
InterceptedChannelContent
:
public
InterceptedChannelBase
{
RefPtr
<
HttpChannelChild
>
mChannel
;
nsCOMPtr
<
nsIInputStream
>
mSynthesizedInput
;
RefPtr
<
InterceptStreamListener
>
mStreamListener
;
public
:
InterceptedChannelContent
(
HttpChannelChild
*
aChannel
nsINetworkInterceptController
*
aController
InterceptStreamListener
*
aListener
)
;
NS_IMETHOD
ResetInterception
(
)
override
;
NS_IMETHOD
FinishSynthesizedResponse
(
const
nsACString
&
aFinalURLSpec
)
override
;
NS_IMETHOD
GetChannel
(
nsIChannel
*
*
aChannel
)
override
;
NS_IMETHOD
GetSecureUpgradedChannelURI
(
nsIURI
*
*
aURI
)
override
;
NS_IMETHOD
SynthesizeStatus
(
uint16_t
aStatus
const
nsACString
&
aReason
)
override
;
NS_IMETHOD
SynthesizeHeader
(
const
nsACString
&
aName
const
nsACString
&
aValue
)
override
;
NS_IMETHOD
Cancel
(
nsresult
aStatus
)
override
;
NS_IMETHOD
SetChannelInfo
(
mozilla
:
:
dom
:
:
ChannelInfo
*
aChannelInfo
)
override
;
NS_IMETHOD
GetInternalContentPolicyType
(
nsContentPolicyType
*
aInternalContentPolicyType
)
override
;
virtual
void
NotifyController
(
)
override
;
}
;
}
}
#
endif
