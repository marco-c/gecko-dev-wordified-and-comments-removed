#
ifndef
InterceptedChannel_h
#
define
InterceptedChannel_h
#
include
"
nsINetworkInterceptController
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
class
nsICacheEntry
;
class
nsInputStreamPump
;
class
nsIStreamListener
;
namespace
mozilla
{
namespace
net
{
class
nsHttpChannel
;
class
HttpChannelChild
;
class
nsHttpResponseHead
;
class
InterceptStreamListener
;
class
InterceptedChannelBase
:
public
nsIInterceptedChannel
{
protected
:
nsCOMPtr
<
nsINetworkInterceptController
>
mController
;
Maybe
<
UniquePtr
<
nsHttpResponseHead
>
>
mSynthesizedResponseHead
;
nsCOMPtr
<
nsIConsoleReportCollector
>
mReportCollector
;
nsCOMPtr
<
nsISupports
>
mReleaseHandle
;
bool
mClosed
;
void
EnsureSynthesizedResponse
(
)
;
void
DoNotifyController
(
)
;
void
DoSynthesizeStatus
(
uint16_t
aStatus
const
nsACString
&
aReason
)
;
[
[
nodiscard
]
]
nsresult
DoSynthesizeHeader
(
const
nsACString
&
aName
const
nsACString
&
aValue
)
;
enum
{
Invalid
=
0
Synthesized
Reset
}
mSynthesizedOrReset
;
virtual
~
InterceptedChannelBase
(
)
=
default
;
public
:
explicit
InterceptedChannelBase
(
nsINetworkInterceptController
*
aController
)
;
virtual
void
NotifyController
(
)
=
0
;
NS_DECL_ISUPPORTS
NS_IMETHOD
GetConsoleReportCollector
(
nsIConsoleReportCollector
*
*
aCollectorOut
)
override
;
NS_IMETHOD
SetReleaseHandle
(
nsISupports
*
aHandle
)
override
;
static
already_AddRefed
<
nsIURI
>
SecureUpgradeChannelURI
(
nsIChannel
*
aChannel
)
;
}
;
}
}
#
endif
