#
include
"
mozilla
/
net
/
HttpAuthUtils
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsUnicharUtils
.
h
"
namespace
mozilla
{
namespace
net
{
namespace
auth
{
namespace
detail
{
bool
MatchesBaseURI
(
const
nsACString
&
matchScheme
const
nsACString
&
matchHost
int32_t
matchPort
nsDependentCSubstring
const
&
url
)
{
mozilla
:
:
Tokenizer
t
(
url
)
;
mozilla
:
:
Tokenizer
:
:
Token
token
;
t
.
SkipWhites
(
)
;
t
.
Record
(
)
;
mozilla
:
:
Unused
<
<
t
.
Next
(
token
)
;
bool
ipv6
=
false
;
if
(
token
.
Equals
(
mozilla
:
:
Tokenizer
:
:
Token
:
:
Char
(
'
[
'
)
)
)
{
nsDependentCSubstring
ipv6BareLiteral
;
if
(
!
t
.
ReadUntil
(
mozilla
:
:
Tokenizer
:
:
Token
:
:
Char
(
'
]
'
)
ipv6BareLiteral
)
)
{
return
false
;
}
nsDependentCSubstring
ipv6Literal
;
t
.
Claim
(
ipv6Literal
mozilla
:
:
Tokenizer
:
:
INCLUDE_LAST
)
;
if
(
!
matchHost
.
Equals
(
ipv6Literal
nsCaseInsensitiveUTF8StringComparator
(
)
)
&
&
!
matchHost
.
Equals
(
ipv6BareLiteral
nsCaseInsensitiveUTF8StringComparator
(
)
)
)
{
return
false
;
}
ipv6
=
true
;
}
else
if
(
t
.
CheckChar
(
'
:
'
)
&
&
t
.
CheckChar
(
'
/
'
)
&
&
t
.
CheckChar
(
'
/
'
)
)
{
if
(
!
matchScheme
.
Equals
(
token
.
Fragment
(
)
)
)
{
return
false
;
}
t
.
Record
(
)
;
}
while
(
t
.
Next
(
token
)
)
{
bool
eof
=
token
.
Equals
(
mozilla
:
:
Tokenizer
:
:
Token
:
:
EndOfFile
(
)
)
;
bool
port
=
token
.
Equals
(
mozilla
:
:
Tokenizer
:
:
Token
:
:
Char
(
'
:
'
)
)
;
if
(
eof
|
|
port
)
{
if
(
!
ipv6
)
{
nsDependentCSubstring
hostName
;
t
.
Claim
(
hostName
)
;
if
(
!
hostName
.
IsEmpty
(
)
)
{
if
(
!
StringEndsWith
(
matchHost
hostName
nsCaseInsensitiveUTF8StringComparator
(
)
)
)
{
return
false
;
}
if
(
matchHost
.
Length
(
)
>
hostName
.
Length
(
)
&
&
matchHost
[
matchHost
.
Length
(
)
-
hostName
.
Length
(
)
-
1
]
!
=
'
.
'
&
&
hostName
[
0
]
!
=
'
.
'
)
{
return
false
;
}
}
}
if
(
port
)
{
uint16_t
portNumber
;
if
(
!
t
.
ReadInteger
(
&
portNumber
)
)
{
return
false
;
}
if
(
matchPort
!
=
portNumber
)
{
return
false
;
}
if
(
!
t
.
CheckEOF
(
)
)
{
return
false
;
}
}
}
else
if
(
ipv6
)
{
return
false
;
}
}
return
true
;
}
}
bool
URIMatchesPrefPattern
(
nsIURI
*
uri
const
char
*
pref
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
!
prefs
)
{
return
false
;
}
nsAutoCString
scheme
host
;
int32_t
port
;
if
(
NS_FAILED
(
uri
-
>
GetScheme
(
scheme
)
)
)
{
return
false
;
}
if
(
NS_FAILED
(
uri
-
>
GetAsciiHost
(
host
)
)
)
{
return
false
;
}
port
=
NS_GetRealPort
(
uri
)
;
if
(
port
=
=
-
1
)
{
return
false
;
}
nsAutoCString
hostList
;
if
(
NS_FAILED
(
prefs
-
>
GetCharPref
(
pref
hostList
)
)
|
|
hostList
.
IsEmpty
(
)
)
{
return
false
;
}
mozilla
:
:
Tokenizer
t
(
hostList
)
;
while
(
!
t
.
CheckEOF
(
)
)
{
t
.
SkipWhites
(
)
;
nsDependentCSubstring
url
;
mozilla
:
:
Unused
<
<
t
.
ReadUntil
(
mozilla
:
:
Tokenizer
:
:
Token
:
:
Char
(
'
'
)
url
)
;
if
(
url
.
IsEmpty
(
)
)
{
continue
;
}
if
(
detail
:
:
MatchesBaseURI
(
scheme
host
port
url
)
)
{
return
true
;
}
}
return
false
;
}
}
}
}
