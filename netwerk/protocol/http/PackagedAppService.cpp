#
include
"
PackagedAppService
.
h
"
#
include
"
nsICacheStorage
.
h
"
#
include
"
LoadContextInfo
.
h
"
#
include
"
nsICacheStorageService
.
h
"
#
include
"
nsIResponseHeadProvider
.
h
"
#
include
"
nsIMultiPartChannel
.
h
"
#
include
"
.
.
/
.
.
/
cache2
/
CacheFileUtils
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsIHttpHeaderVisitor
.
h
"
#
include
"
mozilla
/
LoadContext
.
h
"
#
include
"
nsIInstallPackagedWebapp
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsHttpResponseHead
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsICacheEntryOpenCallback
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
#
include
"
nsMimeTypes
.
h
"
namespace
mozilla
{
namespace
net
{
static
PackagedAppService
*
gPackagedAppService
=
nullptr
;
static
LazyLogModule
gPASLog
(
"
PackagedAppService
"
)
;
#
define
LOG_PAS
(
args
)
MOZ_LOG
(
gPASLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
NS_IMPL_ISUPPORTS
(
PackagedAppService
nsIPackagedAppService
)
NS_IMPL_ISUPPORTS
(
PackagedAppService
:
:
CacheEntryWriter
nsIStreamListener
)
static
void
LogURI
(
const
char
*
aFunctionName
void
*
self
nsIURI
*
aURI
nsILoadContextInfo
*
aInfo
=
nullptr
)
{
if
(
MOZ_LOG_TEST
(
gPASLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
spec
;
if
(
aURI
)
{
aURI
-
>
GetAsciiSpec
(
spec
)
;
}
else
{
spec
=
"
(
null
)
"
;
}
nsAutoCString
prefix
;
if
(
aInfo
)
{
CacheFileUtils
:
:
AppendKeyPrefix
(
aInfo
prefix
)
;
prefix
+
=
"
:
"
;
}
LOG_PAS
(
(
"
[
%
p
]
%
s
>
%
s
%
s
\
n
"
self
aFunctionName
prefix
.
get
(
)
spec
.
get
(
)
)
)
;
}
}
nsresult
PackagedAppService
:
:
CacheEntryWriter
:
:
Create
(
nsIURI
*
aURI
nsICacheStorage
*
aStorage
CacheEntryWriter
*
*
aResult
)
{
RefPtr
<
CacheEntryWriter
>
writer
=
new
CacheEntryWriter
(
)
;
nsresult
rv
=
aStorage
-
>
OpenTruncate
(
aURI
EmptyCString
(
)
getter_AddRefs
(
writer
-
>
mEntry
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
writer
-
>
mEntry
-
>
ForceValidFor
(
PR_UINT32_MAX
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
writer
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
PackagedAppService
:
:
CacheEntryWriter
:
:
CopySecurityInfo
(
nsIChannel
*
aChannel
)
{
if
(
!
aChannel
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsISupports
>
securityInfo
;
aChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
securityInfo
)
)
;
if
(
securityInfo
)
{
mEntry
-
>
SetSecurityInfo
(
securityInfo
)
;
}
return
NS_OK
;
}
namespace
{
class
HeaderCopier
final
:
public
nsIHttpHeaderVisitor
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIHTTPHEADERVISITOR
explicit
HeaderCopier
(
nsHttpResponseHead
*
aHead
)
:
mHead
(
aHead
)
{
}
private
:
~
HeaderCopier
(
)
{
}
bool
ShouldCopy
(
const
nsACString
&
aHeader
)
const
;
nsHttpResponseHead
*
mHead
;
}
;
NS_IMPL_ISUPPORTS
(
HeaderCopier
nsIHttpHeaderVisitor
)
NS_IMETHODIMP
HeaderCopier
:
:
VisitHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
)
{
if
(
!
ShouldCopy
(
aHeader
)
)
{
return
NS_OK
;
}
return
mHead
-
>
SetHeader
(
nsHttp
:
:
ResolveAtom
(
aHeader
)
aValue
)
;
}
bool
HeaderCopier
:
:
ShouldCopy
(
const
nsACString
&
aHeader
)
const
{
nsHttpAtom
header
=
nsHttp
:
:
ResolveAtom
(
aHeader
)
;
if
(
mHead
-
>
HasHeader
(
header
)
)
{
return
false
;
}
static
const
nsHttpAtom
kHeadersCopyBlacklist
[
]
=
{
nsHttp
:
:
Authentication
nsHttp
:
:
Cache_Control
nsHttp
:
:
Connection
nsHttp
:
:
Content_Disposition
nsHttp
:
:
Content_Encoding
nsHttp
:
:
Content_Language
nsHttp
:
:
Content_Length
nsHttp
:
:
Content_Location
nsHttp
:
:
Content_MD5
nsHttp
:
:
Content_Range
nsHttp
:
:
Content_Type
nsHttp
:
:
ETag
nsHttp
:
:
Last_Modified
nsHttp
:
:
Proxy_Authenticate
nsHttp
:
:
Proxy_Connection
nsHttp
:
:
Set_Cookie
nsHttp
:
:
Set_Cookie2
nsHttp
:
:
TE
nsHttp
:
:
Trailer
nsHttp
:
:
Transfer_Encoding
nsHttp
:
:
Vary
nsHttp
:
:
WWW_Authenticate
}
;
for
(
uint32_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
kHeadersCopyBlacklist
)
;
i
+
+
)
{
if
(
header
=
=
kHeadersCopyBlacklist
[
i
]
)
{
return
false
;
}
}
return
true
;
}
static
already_AddRefed
<
nsICacheEntry
>
GetPackageCacheEntry
(
nsIRequest
*
aRequest
)
{
nsCOMPtr
<
nsIChannel
>
baseChannel
;
nsCOMPtr
<
nsIMultiPartChannel
>
multiChannel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
multiChannel
)
{
multiChannel
-
>
GetBaseChannel
(
getter_AddRefs
(
baseChannel
)
)
;
}
else
{
baseChannel
=
do_QueryInterface
(
aRequest
)
;
}
if
(
!
baseChannel
)
{
return
nullptr
;
}
nsCOMPtr
<
nsICachingChannel
>
cachingChannel
=
do_QueryInterface
(
baseChannel
)
;
if
(
!
cachingChannel
)
{
return
nullptr
;
}
nsCOMPtr
<
nsISupports
>
cacheToken
;
cachingChannel
-
>
GetCacheToken
(
getter_AddRefs
(
cacheToken
)
)
;
if
(
!
cacheToken
)
{
return
nullptr
;
}
nsCOMPtr
<
nsICacheEntry
>
entry
(
do_QueryInterface
(
cacheToken
)
)
;
return
entry
.
forget
(
)
;
}
static
already_AddRefed
<
nsIInputStream
>
CreateSharedStringStream
(
const
char
*
aData
uint32_t
aCount
)
{
nsresult
rv
;
nsCOMPtr
<
nsIStringInputStream
>
stream
=
do_CreateInstance
(
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
rv
=
stream
-
>
ShareData
(
(
char
*
)
aData
aCount
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
stream
.
forget
(
)
;
}
static
bool
GetOriginalResponseHeader
(
nsIRequest
*
aRequest
nsACString
&
aHeader
)
{
nsCOMPtr
<
nsIMultiPartChannel
>
multiPartChannel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
!
multiPartChannel
)
{
return
false
;
}
multiPartChannel
-
>
GetOriginalResponseHeader
(
aHeader
)
;
return
true
;
}
}
nsresult
PackagedAppService
:
:
CacheEntryWriter
:
:
CopyHeadersFromChannel
(
nsIChannel
*
aChannel
nsHttpResponseHead
*
aHead
)
{
if
(
!
aChannel
|
|
!
aHead
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChan
=
do_QueryInterface
(
aChannel
)
;
if
(
!
httpChan
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
HeaderCopier
>
headerCopier
=
new
HeaderCopier
(
aHead
)
;
return
httpChan
-
>
VisitResponseHeaders
(
headerCopier
)
;
}
nsresult
PackagedAppService
:
:
CacheEntryWriter
:
:
ConsumeData
(
const
char
*
aBuf
uint32_t
aCount
uint32_t
*
aWriteCount
)
{
MOZ_ASSERT
(
mOutputStream
"
The
stream
should
not
be
null
"
)
;
return
mOutputStream
-
>
Write
(
aBuf
aCount
aWriteCount
)
;
}
NS_IMETHODIMP
PackagedAppService
:
:
CacheEntryWriter
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
nsresult
rv
;
nsCOMPtr
<
nsIResponseHeadProvider
>
provider
(
do_QueryInterface
(
aRequest
)
)
;
if
(
!
provider
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsHttpResponseHead
*
responseHead
=
provider
-
>
GetResponseHead
(
)
;
if
(
!
responseHead
)
{
return
NS_ERROR_FAILURE
;
}
mEntry
-
>
SetPredictedDataSize
(
responseHead
-
>
TotalEntitySize
(
)
)
;
rv
=
mEntry
-
>
SetMetaDataElement
(
"
request
-
method
"
"
GET
"
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIMultiPartChannel
>
multiPartChannel
=
do_QueryInterface
(
aRequest
)
;
if
(
!
multiPartChannel
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIChannel
>
baseChannel
;
multiPartChannel
-
>
GetBaseChannel
(
getter_AddRefs
(
baseChannel
)
)
;
rv
=
CopySecurityInfo
(
baseChannel
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
CopyHeadersFromChannel
(
baseChannel
responseHead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
head
;
responseHead
-
>
Flatten
(
head
true
)
;
rv
=
mEntry
-
>
SetMetaDataElement
(
"
response
-
head
"
head
.
get
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mEntry
-
>
OpenOutputStream
(
0
getter_AddRefs
(
mOutputStream
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PackagedAppService
:
:
CacheEntryWriter
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
if
(
mOutputStream
)
{
mOutputStream
-
>
Close
(
)
;
mOutputStream
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PackagedAppService
:
:
CacheEntryWriter
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
MOZ_ASSERT_UNREACHABLE
(
"
This
function
should
never
ever
be
called
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMPL_ISUPPORTS
(
PackagedAppService
:
:
PackagedAppChannelListener
nsIStreamListener
)
NS_IMETHODIMP
PackagedAppService
:
:
PackagedAppChannelListener
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
bool
isFromCache
=
false
;
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChan
=
do_QueryInterface
(
aRequest
)
;
if
(
cacheChan
)
{
cacheChan
-
>
IsFromCache
(
&
isFromCache
)
;
}
mDownloader
-
>
SetIsFromCache
(
isFromCache
)
;
LOG_PAS
(
(
"
[
%
p
]
Downloader
isFromCache
:
%
d
\
n
"
mDownloader
.
get
(
)
isFromCache
)
)
;
return
mListener
-
>
OnStartRequest
(
aRequest
aContext
)
;
}
NS_IMETHODIMP
PackagedAppService
:
:
PackagedAppChannelListener
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
return
mListener
-
>
OnStopRequest
(
aRequest
aContext
aStatusCode
)
;
}
NS_IMETHODIMP
PackagedAppService
:
:
PackagedAppChannelListener
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
return
mListener
-
>
OnDataAvailable
(
aRequest
aContext
aInputStream
aOffset
aCount
)
;
}
NS_IMPL_ISUPPORTS
(
PackagedAppService
:
:
PackagedAppDownloader
nsIStreamListener
nsIPackagedAppVerifierListener
)
nsresult
PackagedAppService
:
:
PackagedAppDownloader
:
:
Init
(
nsILoadContextInfo
*
aInfo
const
nsCString
&
aKey
const
nsACString
&
aPackageOrigin
)
{
nsresult
rv
;
nsCOMPtr
<
nsICacheStorageService
>
cacheStorageService
=
do_GetService
(
"
mozilla
.
org
/
netwerk
/
cache
-
storage
-
service
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
cacheStorageService
-
>
DiskCacheStorage
(
aInfo
false
getter_AddRefs
(
mCacheStorage
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mPackageKey
=
aKey
;
mPackageOrigin
=
aPackageOrigin
;
mProcessingFirstRequest
=
true
;
return
NS_OK
;
}
void
PackagedAppService
:
:
PackagedAppDownloader
:
:
EnsureVerifier
(
nsIRequest
*
aRequest
)
{
if
(
mVerifier
)
{
return
;
}
LOG_PAS
(
(
"
Creating
PackagedAppVerifier
.
"
)
)
;
nsCOMPtr
<
nsIMultiPartChannel
>
multiChannel
(
do_QueryInterface
(
aRequest
)
)
;
nsCString
signature
=
GetSignatureFromChannel
(
multiChannel
)
;
nsCOMPtr
<
nsICacheEntry
>
packageCacheEntry
=
GetPackageCacheEntry
(
aRequest
)
;
mVerifier
=
new
PackagedAppVerifier
(
this
mPackageOrigin
signature
packageCacheEntry
)
;
}
NS_IMETHODIMP
PackagedAppService
:
:
PackagedAppDownloader
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
mWriter
=
nullptr
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
GetSubresourceURI
(
aRequest
getter_AddRefs
(
uri
)
)
;
LogURI
(
"
PackagedAppDownloader
:
:
OnStartRequest
"
this
uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
rv
=
CacheEntryWriter
:
:
Create
(
uri
mCacheStorage
getter_AddRefs
(
mWriter
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mWriter
)
;
rv
=
mWriter
-
>
OnStartRequest
(
aRequest
aContext
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
OnStartRequest
failed
"
)
;
EnsureVerifier
(
aRequest
)
;
if
(
!
mVerifier
-
>
WouldVerify
(
)
)
{
return
NS_OK
;
}
mVerifier
-
>
OnStartRequest
(
nullptr
uri
)
;
nsCString
header
;
if
(
!
GetOriginalResponseHeader
(
aRequest
header
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIInputStream
>
stream
=
CreateSharedStringStream
(
header
.
get
(
)
header
.
Length
(
)
)
;
return
mVerifier
-
>
OnDataAvailable
(
nullptr
nullptr
stream
0
header
.
Length
(
)
)
;
}
nsresult
PackagedAppService
:
:
PackagedAppDownloader
:
:
GetSubresourceURI
(
nsIRequest
*
aRequest
nsIURI
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIResponseHeadProvider
>
provider
(
do_QueryInterface
(
aRequest
)
)
;
nsCOMPtr
<
nsIChannel
>
chan
(
do_QueryInterface
(
aRequest
)
)
;
if
(
NS_WARN_IF
(
!
provider
|
|
!
chan
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsHttpResponseHead
*
responseHead
=
provider
-
>
GetResponseHead
(
)
;
if
(
NS_WARN_IF
(
!
responseHead
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
contentLocation
;
rv
=
responseHead
-
>
GetHeader
(
nsHttp
:
:
ResolveAtom
(
"
Content
-
Location
"
)
contentLocation
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
chan
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
path
;
rv
=
uri
-
>
GetPath
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
path
+
=
PACKAGED_APP_TOKEN
;
{
nsCOMPtr
<
nsIURI
>
tempURI
;
NS_NewURI
(
getter_AddRefs
(
tempURI
)
"
http
:
/
/
temp
-
domain
.
local
/
"
)
;
tempURI
-
>
SetPath
(
contentLocation
)
;
tempURI
-
>
GetPath
(
contentLocation
)
;
contentLocation
=
Substring
(
contentLocation
1
)
;
}
path
+
=
contentLocation
;
nsCOMPtr
<
nsIURI
>
partURI
;
rv
=
uri
-
>
CloneIgnoringRef
(
getter_AddRefs
(
partURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
partURI
-
>
SetPath
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
partURI
.
forget
(
aResult
)
;
return
NS_OK
;
}
void
PackagedAppService
:
:
PackagedAppDownloader
:
:
OnError
(
EErrorType
aError
)
{
LOG_PAS
(
(
"
PackagedAppDownloader
:
:
OnError
>
%
d
"
aError
)
)
;
FinalizeDownload
(
NS_ERROR_SIGNED_APP_MANIFEST_INVALID
)
;
}
void
PackagedAppService
:
:
PackagedAppDownloader
:
:
FinalizeDownload
(
nsresult
aStatusCode
)
{
if
(
NS_SUCCEEDED
(
aStatusCode
)
&
&
!
mIsFromCache
)
{
aStatusCode
=
NS_ERROR_FILE_NOT_FOUND
;
}
RefPtr
<
PackagedAppDownloader
>
kungFuDeathGrip
(
this
)
;
if
(
gPackagedAppService
)
{
gPackagedAppService
-
>
NotifyPackageDownloaded
(
mPackageKey
)
;
}
ClearCallbacks
(
aStatusCode
)
;
if
(
mVerifier
)
{
mVerifier
-
>
ClearListener
(
)
;
}
}
nsCString
PackagedAppService
:
:
PackagedAppDownloader
:
:
GetSignatureFromChannel
(
nsIMultiPartChannel
*
aMulitChannel
)
{
if
(
mIsFromCache
)
{
return
EmptyCString
(
)
;
}
if
(
!
aMulitChannel
)
{
LOG_PAS
(
(
"
The
package
is
either
not
loaded
from
cache
or
malformed
.
"
)
)
;
return
EmptyCString
(
)
;
}
nsCString
packageHeader
;
aMulitChannel
-
>
GetPreamble
(
packageHeader
)
;
return
packageHeader
;
}
NS_IMETHODIMP
PackagedAppService
:
:
PackagedAppDownloader
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
nsCOMPtr
<
nsIMultiPartChannel
>
multiChannel
(
do_QueryInterface
(
aRequest
)
)
;
nsresult
rv
;
LOG_PAS
(
(
"
[
%
p
]
PackagedAppDownloader
:
:
OnStopRequest
>
status
:
%
X
multiChannel
:
%
p
\
n
"
this
aStatusCode
multiChannel
.
get
(
)
)
)
;
mProcessingFirstRequest
=
false
;
bool
lastPart
=
true
;
if
(
multiChannel
)
{
multiChannel
-
>
GetIsLastPart
(
&
lastPart
)
;
}
if
(
!
multiChannel
|
|
!
mWriter
)
{
LOG_PAS
(
(
"
Either
the
package
was
loaded
from
cache
or
malformed
"
)
)
;
if
(
lastPart
)
{
if
(
!
mVerifier
|
|
!
mVerifier
-
>
WouldVerify
(
)
)
{
FinalizeDownload
(
aStatusCode
)
;
}
else
{
mVerifier
-
>
SetHasBrokenLastPart
(
aStatusCode
)
;
}
}
return
NS_OK
;
}
LOG_PAS
(
(
"
We
are
going
to
finish
the
resource
and
process
it
in
the
verifier
.
"
)
)
;
mWriter
-
>
OnStopRequest
(
aRequest
aContext
aStatusCode
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
GetSubresourceURI
(
aRequest
getter_AddRefs
(
uri
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsICacheEntry
>
entry
;
mWriter
-
>
mEntry
.
swap
(
entry
)
;
mWriter
=
nullptr
;
RefPtr
<
ResourceCacheInfo
>
info
=
new
ResourceCacheInfo
(
uri
entry
aStatusCode
lastPart
)
;
if
(
!
mVerifier
-
>
WouldVerify
(
)
)
{
OnResourceVerified
(
info
true
)
;
return
NS_OK
;
}
mVerifier
-
>
OnStopRequest
(
nullptr
info
aStatusCode
)
;
return
NS_OK
;
}
nsresult
PackagedAppService
:
:
PackagedAppDownloader
:
:
ConsumeData
(
nsIInputStream
*
aStream
void
*
aClosure
const
char
*
aFromRawSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
{
MOZ_ASSERT
(
aClosure
"
The
closure
must
not
be
null
"
)
;
if
(
!
aStream
)
{
return
NS_ERROR_INVALID_ARG
;
}
PackagedAppDownloader
*
self
=
static_cast
<
PackagedAppDownloader
*
>
(
aClosure
)
;
if
(
!
self
-
>
mWriter
)
{
*
aWriteCount
=
aCount
;
return
NS_OK
;
}
self
-
>
mWriter
-
>
ConsumeData
(
aFromRawSegment
aCount
aWriteCount
)
;
if
(
!
self
-
>
mVerifier
-
>
WouldVerify
(
)
)
{
return
NS_OK
;
}
if
(
self
-
>
mProcessingFirstRequest
)
{
self
-
>
mManifestContent
.
Append
(
aFromRawSegment
aCount
)
;
}
nsCOMPtr
<
nsIInputStream
>
stream
=
CreateSharedStringStream
(
aFromRawSegment
aCount
)
;
return
self
-
>
mVerifier
-
>
OnDataAvailable
(
nullptr
nullptr
stream
0
aCount
)
;
}
NS_IMETHODIMP
PackagedAppService
:
:
PackagedAppDownloader
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
uint32_t
n
;
return
aInputStream
-
>
ReadSegments
(
ConsumeData
this
aCount
&
n
)
;
}
nsresult
PackagedAppService
:
:
PackagedAppDownloader
:
:
AddCallback
(
nsIURI
*
aURI
nsICacheEntryOpenCallback
*
aCallback
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
mCallbacks
hashtable
is
not
thread
safe
"
)
;
nsAutoCString
spec
;
aURI
-
>
GetSpecIgnoringRef
(
spec
)
;
LogURI
(
"
PackagedAppDownloader
:
:
AddCallback
"
this
aURI
)
;
LOG_PAS
(
(
"
[
%
p
]
>
callback
:
%
p
\
n
"
this
aCallback
)
)
;
nsCOMArray
<
nsICacheEntryOpenCallback
>
*
array
=
mCallbacks
.
Get
(
spec
)
;
if
(
array
)
{
if
(
array
-
>
Length
(
)
=
=
0
)
{
LOG_PAS
(
(
"
[
%
p
]
>
already
downloaded
\
n
"
this
)
)
;
mCacheStorage
-
>
AsyncOpenURI
(
aURI
EmptyCString
(
)
nsICacheStorage
:
:
OPEN_READONLY
aCallback
)
;
}
else
{
LOG_PAS
(
(
"
[
%
p
]
>
adding
to
array
\
n
"
this
)
)
;
array
-
>
AppendObject
(
aCallback
)
;
}
}
else
{
LOG_PAS
(
(
"
[
%
p
]
>
creating
array
\
n
"
this
)
)
;
nsCOMArray
<
nsICacheEntryOpenCallback
>
*
newArray
=
new
nsCOMArray
<
nsICacheEntryOpenCallback
>
(
)
;
newArray
-
>
AppendObject
(
aCallback
)
;
mCallbacks
.
Put
(
spec
newArray
)
;
}
return
NS_OK
;
}
nsresult
PackagedAppService
:
:
PackagedAppDownloader
:
:
CallCallbacks
(
nsIURI
*
aURI
nsICacheEntry
*
aEntry
nsresult
aResult
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
mCallbacks
hashtable
is
not
thread
safe
"
)
;
nsCOMPtr
<
nsICacheEntry
>
handle
(
aEntry
)
;
LogURI
(
"
PackagedAppService
:
:
PackagedAppDownloader
:
:
CallCallbacks
"
this
aURI
)
;
LOG_PAS
(
(
"
[
%
p
]
>
status
:
%
X
\
n
"
this
aResult
)
)
;
nsAutoCString
spec
;
aURI
-
>
GetAsciiSpec
(
spec
)
;
nsCOMArray
<
nsICacheEntryOpenCallback
>
*
array
=
mCallbacks
.
Get
(
spec
)
;
if
(
array
)
{
uint32_t
callbacksNum
=
array
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
array
-
>
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsICacheEntryOpenCallback
>
callback
(
array
-
>
ObjectAt
(
i
)
)
;
mCacheStorage
-
>
AsyncOpenURI
(
aURI
EmptyCString
(
)
nsICacheStorage
:
:
OPEN_READONLY
callback
)
;
}
array
-
>
Clear
(
)
;
LOG_PAS
(
(
"
[
%
p
]
>
called
callbacks
(
%
d
)
\
n
"
this
callbacksNum
)
)
;
}
else
{
nsCOMArray
<
nsICacheEntryOpenCallback
>
*
newArray
=
new
nsCOMArray
<
nsICacheEntryOpenCallback
>
(
)
;
mCallbacks
.
Put
(
spec
newArray
)
;
LOG_PAS
(
(
"
[
%
p
]
>
created
array
\
n
"
this
)
)
;
}
aEntry
-
>
ForceValidFor
(
0
)
;
return
NS_OK
;
}
nsresult
PackagedAppService
:
:
PackagedAppDownloader
:
:
ClearCallbacks
(
nsresult
aResult
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
mCallbacks
hashtable
is
not
thread
safe
"
)
;
LOG_PAS
(
(
"
[
%
p
]
PackagedAppService
:
:
PackagedAppDownloader
:
:
ClearCallbacks
>
packageKey
:
%
s
status
:
%
X
\
n
"
this
mPackageKey
.
get
(
)
aResult
)
)
;
for
(
auto
iter
=
mCallbacks
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsACString
&
key
=
iter
.
Key
(
)
;
const
nsCOMArray
<
nsICacheEntryOpenCallback
>
*
callbackArray
=
iter
.
UserData
(
)
;
if
(
NS_SUCCEEDED
(
aResult
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
DebugOnly
<
nsresult
>
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
key
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
LOG_PAS
(
(
"
[
%
p
]
>
calling
AsyncOpenURI
for
%
s
\
n
"
this
key
.
BeginReading
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
callbackArray
-
>
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsICacheEntryOpenCallback
>
callback
=
callbackArray
-
>
ObjectAt
(
i
)
;
mCacheStorage
-
>
AsyncOpenURI
(
uri
EmptyCString
(
)
nsICacheStorage
:
:
OPEN_READONLY
callback
)
;
}
}
else
{
LOG_PAS
(
(
"
[
%
p
]
>
passing
NULL
cache
entry
for
%
s
\
n
"
this
key
.
BeginReading
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
callbackArray
-
>
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsICacheEntryOpenCallback
>
callback
=
callbackArray
-
>
ObjectAt
(
i
)
;
callback
-
>
OnCacheEntryAvailable
(
nullptr
false
nullptr
aResult
)
;
}
}
iter
.
Remove
(
)
;
}
return
NS_OK
;
}
static
bool
AddPackageIdToOrigin
(
nsACString
&
aOrigin
const
nsACString
&
aPackageId
)
{
nsAutoCString
originNoSuffix
;
mozilla
:
:
NeckoOriginAttributes
attrs
;
if
(
!
attrs
.
PopulateFromOrigin
(
aOrigin
originNoSuffix
)
)
{
return
false
;
}
attrs
.
mSignedPkg
=
NS_ConvertUTF8toUTF16
(
aPackageId
)
;
nsAutoCString
suffixWithPackageId
;
attrs
.
CreateSuffix
(
suffixWithPackageId
)
;
aOrigin
=
originNoSuffix
+
suffixWithPackageId
;
return
true
;
}
void
PackagedAppService
:
:
PackagedAppDownloader
:
:
InstallSignedPackagedApp
(
const
ResourceCacheInfo
*
aInfo
)
{
LOG_PAS
(
(
"
Install
this
packaged
app
.
"
)
)
;
bool
isSuccess
=
false
;
nsCOMPtr
<
nsIInstallPackagedWebapp
>
installer
=
do_GetService
(
"
mozilla
.
org
/
newapps
/
installpackagedwebapp
;
1
"
)
;
if
(
!
installer
)
{
LOG_PAS
(
(
"
InstallSignedPackagedApp
:
fail
to
get
InstallPackagedWebapp
service
"
)
)
;
return
OnError
(
ERROR_GET_INSTALLER_FAILED
)
;
}
nsCString
manifestURL
;
aInfo
-
>
mURI
-
>
GetAsciiSpec
(
manifestURL
)
;
nsCString
originWithPackageId
=
mPackageOrigin
;
if
(
!
AddPackageIdToOrigin
(
originWithPackageId
mVerifier
-
>
GetPackageIdentifier
(
)
)
)
{
NS_WARNING
(
"
mPackageOrigin
is
malformed
.
"
)
;
}
installer
-
>
InstallPackagedWebapp
(
mManifestContent
.
get
(
)
originWithPackageId
.
get
(
)
manifestURL
.
get
(
)
&
isSuccess
)
;
if
(
!
isSuccess
)
{
LOG_PAS
(
(
"
InstallSignedPackagedApp
:
failed
to
install
permissions
"
)
)
;
return
OnError
(
ERROR_INSTALL_RESOURCE_FAILED
)
;
}
LOG_PAS
(
(
"
InstallSignedPackagedApp
:
success
.
"
)
)
;
}
NS_IMETHODIMP
PackagedAppService
:
:
PackagedAppDownloader
:
:
OnVerified
(
bool
aIsManifest
nsIURI
*
aUri
nsICacheEntry
*
aCacheEntry
nsresult
aStatusCode
bool
aIsLastPart
bool
aVerificationSuccess
)
{
if
(
!
aUri
)
{
NS_WARNING
(
"
We
'
ve
got
a
broken
last
part
.
"
)
;
FinalizeDownload
(
aStatusCode
)
;
return
NS_OK
;
}
RefPtr
<
ResourceCacheInfo
>
info
=
new
ResourceCacheInfo
(
aUri
aCacheEntry
aStatusCode
aIsLastPart
)
;
aIsManifest
?
OnManifestVerified
(
info
aVerificationSuccess
)
:
OnResourceVerified
(
info
aVerificationSuccess
)
;
return
NS_OK
;
}
void
PackagedAppService
:
:
PackagedAppDownloader
:
:
OnManifestVerified
(
const
ResourceCacheInfo
*
aInfo
bool
aSuccess
)
{
if
(
!
aSuccess
)
{
return
OnError
(
ERROR_MANIFEST_VERIFIED_FAILED
)
;
}
CallCallbacks
(
aInfo
-
>
mURI
aInfo
-
>
mCacheEntry
aInfo
-
>
mStatusCode
)
;
if
(
aInfo
-
>
mIsLastPart
)
{
NS_WARNING
(
"
This
package
has
manifest
only
.
"
)
;
FinalizeDownload
(
aInfo
-
>
mStatusCode
)
;
return
;
}
bool
isPackagedSigned
;
mVerifier
-
>
GetIsPackageSigned
(
&
isPackagedSigned
)
;
if
(
!
isPackagedSigned
)
{
LOG_PAS
(
(
"
No
signature
in
the
package
.
Just
run
normally
.
"
)
)
;
return
;
}
InstallSignedPackagedApp
(
aInfo
)
;
}
void
PackagedAppService
:
:
PackagedAppDownloader
:
:
OnResourceVerified
(
const
ResourceCacheInfo
*
aInfo
bool
aSuccess
)
{
if
(
!
aSuccess
)
{
return
OnError
(
ERROR_RESOURCE_VERIFIED_FAILED
)
;
}
CallCallbacks
(
aInfo
-
>
mURI
aInfo
-
>
mCacheEntry
aInfo
-
>
mStatusCode
)
;
if
(
aInfo
-
>
mIsLastPart
)
{
LOG_PAS
(
(
"
This
is
the
last
part
.
FinalizeDownload
(
%
d
)
"
aInfo
-
>
mStatusCode
)
)
;
FinalizeDownload
(
aInfo
-
>
mStatusCode
)
;
}
}
PackagedAppService
:
:
PackagedAppService
(
)
{
gPackagedAppService
=
this
;
LOG_PAS
(
(
"
[
%
p
]
Created
PackagedAppService
\
n
"
this
)
)
;
}
PackagedAppService
:
:
~
PackagedAppService
(
)
{
LOG_PAS
(
(
"
[
%
p
]
Destroying
PackagedAppService
\
n
"
this
)
)
;
gPackagedAppService
=
nullptr
;
}
nsresult
PackagedAppService
:
:
GetPackageURI
(
nsIURI
*
aURI
nsIURI
*
*
aPackageURI
)
{
nsCOMPtr
<
nsIURL
>
url
=
do_QueryInterface
(
aURI
)
;
if
(
!
url
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
path
;
nsresult
rv
=
url
-
>
GetFilePath
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
int32_t
pos
=
path
.
Find
(
PACKAGED_APP_TOKEN
)
;
if
(
pos
=
=
kNotFound
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIURI
>
packageURI
;
rv
=
aURI
-
>
CloneIgnoringRef
(
getter_AddRefs
(
packageURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
packageURI
-
>
SetPath
(
Substring
(
path
0
pos
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
packageURI
.
forget
(
aPackageURI
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PackagedAppService
:
:
GetResource
(
nsIChannel
*
aChannel
nsICacheEntryOpenCallback
*
aCallback
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
mDownloadingPackages
hashtable
is
not
thread
safe
"
)
;
LOG_PAS
(
(
"
[
%
p
]
PackagedAppService
:
:
GetResource
(
aChannel
:
%
p
aCallback
:
%
p
)
\
n
"
this
aChannel
aCallback
)
)
;
if
(
!
aChannel
|
|
!
aCallback
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
;
nsIScriptSecurityManager
*
securityManager
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
if
(
!
securityManager
)
{
LOG_PAS
(
(
"
[
%
p
]
>
No
securityManager
\
n
"
this
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
securityManager
-
>
GetChannelURIPrincipal
(
aChannel
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
principal
)
{
LOG_PAS
(
(
"
[
%
p
]
>
Error
getting
principal
rv
=
%
X
principal
=
%
p
\
n
"
this
rv
principal
.
get
(
)
)
)
;
return
NS_FAILED
(
rv
)
?
rv
:
NS_ERROR_NULL_POINTER
;
}
nsCOMPtr
<
nsILoadContextInfo
>
loadContextInfo
=
GetLoadContextInfo
(
aChannel
)
;
if
(
!
loadContextInfo
)
{
LOG_PAS
(
(
"
[
%
p
]
>
Channel
has
no
loadContextInfo
\
n
"
this
)
)
;
return
NS_ERROR_NULL_POINTER
;
}
nsLoadFlags
loadFlags
=
0
;
rv
=
aChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG_PAS
(
(
"
[
%
p
]
>
Error
calling
GetLoadFlags
rv
=
%
X
\
n
"
this
rv
)
)
;
return
rv
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
GetLoadInfo
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG_PAS
(
(
"
[
%
p
]
>
Error
calling
GetURI
rv
=
%
X
\
n
"
this
rv
)
)
;
return
rv
;
}
LogURI
(
"
PackagedAppService
:
:
GetResource
"
this
uri
loadContextInfo
)
;
nsCOMPtr
<
nsIURI
>
packageURI
;
rv
=
GetPackageURI
(
uri
getter_AddRefs
(
packageURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
key
;
CacheFileUtils
:
:
AppendKeyPrefix
(
loadContextInfo
key
)
;
{
nsAutoCString
spec
;
packageURI
-
>
GetAsciiSpec
(
spec
)
;
key
+
=
"
:
"
;
key
+
=
spec
;
}
RefPtr
<
PackagedAppDownloader
>
downloader
;
if
(
mDownloadingPackages
.
Get
(
key
getter_AddRefs
(
downloader
)
)
)
{
downloader
-
>
AddCallback
(
uri
aCallback
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
channel
)
packageURI
loadInfo
nullptr
nullptr
loadFlags
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsICachingChannel
>
cacheChan
(
do_QueryInterface
(
channel
)
)
;
if
(
cacheChan
)
{
cacheChan
-
>
SetCacheOnlyMetadata
(
true
)
;
}
downloader
=
new
PackagedAppDownloader
(
)
;
nsCString
packageOrigin
;
principal
-
>
GetOrigin
(
packageOrigin
)
;
rv
=
downloader
-
>
Init
(
loadContextInfo
key
packageOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
downloader
-
>
AddCallback
(
uri
aCallback
)
;
nsCOMPtr
<
nsIStreamConverterService
>
streamconv
=
do_GetService
(
"
mozilla
.
org
/
streamConverters
;
1
"
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIStreamListener
>
mimeConverter
;
rv
=
streamconv
-
>
AsyncConvertData
(
APPLICATION_PACKAGE
"
*
/
*
"
downloader
nullptr
getter_AddRefs
(
mimeConverter
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mDownloadingPackages
.
Put
(
key
downloader
)
;
RefPtr
<
PackagedAppChannelListener
>
listener
=
new
PackagedAppChannelListener
(
downloader
mimeConverter
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
loadContext
;
aChannel
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
loadContext
)
)
;
if
(
loadContext
)
{
channel
-
>
SetNotificationCallbacks
(
loadContext
)
;
}
return
NS_MaybeOpenChannelUsingAsyncOpen2
(
channel
listener
)
;
}
nsresult
PackagedAppService
:
:
NotifyPackageDownloaded
(
nsCString
aKey
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
mDownloadingPackages
hashtable
is
not
thread
safe
"
)
;
mDownloadingPackages
.
Remove
(
aKey
)
;
LOG_PAS
(
(
"
[
%
p
]
PackagedAppService
:
:
NotifyPackageDownloaded
>
%
s
\
n
"
this
aKey
.
get
(
)
)
)
;
return
NS_OK
;
}
}
}
