#
ifndef
Http3Session_H__
#
define
Http3Session_H__
#
include
"
HttpTrafficAnalyzer
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
net
/
NeqoHttp3Conn
.
h
"
#
include
"
nsAHttpConnection
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIUDPSocket
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsWeakReference
.
h
"
namespace
mozilla
:
:
net
{
class
HttpConnectionUDP
;
class
Http3StreamBase
;
class
QuicSocketControl
;
#
define
NS_HTTP3SESSION_IID
\
{
\
0x8fc82aaf
0xc4ef
0x46ed
{
\
0x89
0x41
0x93
0x95
0x8f
0xac
0x4f
0x21
\
}
\
}
enum
class
EchExtensionStatus
{
kNotPresent
kGREASE
kReal
}
;
class
Http3Session
final
:
public
nsAHttpTransaction
public
nsAHttpConnection
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_HTTP3SESSION_IID
)
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSAHTTPTRANSACTION
NS_DECL_NSAHTTPCONNECTION
(
mConnection
)
Http3Session
(
)
;
nsresult
Init
(
const
nsHttpConnectionInfo
*
aConnInfo
nsINetAddr
*
selfAddr
nsINetAddr
*
peerAddr
HttpConnectionUDP
*
udpConn
uint32_t
controlFlags
nsIInterfaceRequestor
*
callbacks
)
;
bool
IsConnected
(
)
const
{
return
mState
=
=
CONNECTED
;
}
bool
CanSendData
(
)
const
{
return
(
mState
=
=
CONNECTED
)
|
|
(
mState
=
=
ZERORTT
)
;
}
bool
IsClosing
(
)
const
{
return
(
mState
=
=
CLOSING
|
|
mState
=
=
CLOSED
)
;
}
bool
IsClosed
(
)
const
{
return
mState
=
=
CLOSED
;
}
bool
AddStream
(
nsAHttpTransaction
*
aHttpTransaction
int32_t
aPriority
nsIInterfaceRequestor
*
aCallbacks
)
;
bool
CanReuse
(
)
;
nsresult
TryActivating
(
const
nsACString
&
aMethod
const
nsACString
&
aScheme
const
nsACString
&
aAuthorityHeader
const
nsACString
&
aPath
const
nsACString
&
aHeaders
uint64_t
*
aStreamId
Http3StreamBase
*
aStream
)
;
void
CloseSendingSide
(
uint64_t
aStreamId
)
;
nsresult
SendRequestBody
(
uint64_t
aStreamId
const
char
*
buf
uint32_t
count
uint32_t
*
countRead
)
;
nsresult
ReadResponseHeaders
(
uint64_t
aStreamId
nsTArray
<
uint8_t
>
&
aResponseHeaders
bool
*
aFin
)
;
nsresult
ReadResponseData
(
uint64_t
aStreamId
char
*
aBuf
uint32_t
aCount
uint32_t
*
aCountWritten
bool
*
aFin
)
;
nsresult
CloseWebTransport
(
uint64_t
aSessionId
uint32_t
aError
const
nsACString
&
aMessage
)
;
nsresult
CreateWebTransportStream
(
uint64_t
aSessionId
WebTransportStreamType
aStreamType
uint64_t
*
aStreamId
)
;
void
CloseStream
(
Http3StreamBase
*
aStream
nsresult
aResult
)
;
void
CloseStreamInternal
(
Http3StreamBase
*
aStream
nsresult
aResult
)
;
void
SetCleanShutdown
(
bool
aCleanShutdown
)
{
mCleanShutdown
=
aCleanShutdown
;
}
bool
TestJoinConnection
(
const
nsACString
&
hostname
int32_t
port
)
;
bool
JoinConnection
(
const
nsACString
&
hostname
int32_t
port
)
;
void
TransactionHasDataToWrite
(
nsAHttpTransaction
*
caller
)
override
;
void
TransactionHasDataToRecv
(
nsAHttpTransaction
*
caller
)
override
;
[
[
nodiscard
]
]
nsresult
GetTransactionTLSSocketControl
(
nsITLSSocketControl
*
*
)
override
;
void
Authenticated
(
int32_t
aError
)
;
nsresult
ProcessOutputAndEvents
(
nsIUDPSocket
*
socket
)
;
void
ReportHttp3Connection
(
)
;
int64_t
GetBytesWritten
(
)
{
return
mTotalBytesWritten
;
}
int64_t
BytesRead
(
)
{
return
mTotalBytesRead
;
}
nsresult
SendData
(
nsIUDPSocket
*
socket
)
;
nsresult
RecvData
(
nsIUDPSocket
*
socket
)
;
void
DoSetEchConfig
(
const
nsACString
&
aEchConfig
)
;
nsresult
SendPriorityUpdateFrame
(
uint64_t
aStreamId
uint8_t
aPriorityUrgency
bool
aPriorityIncremental
)
;
void
ConnectSlowConsumer
(
Http3StreamBase
*
stream
)
;
nsresult
TryActivatingWebTransportStream
(
uint64_t
*
aStreamId
Http3StreamBase
*
aStream
)
;
void
CloseWebTransportStream
(
Http3WebTransportStream
*
aStream
nsresult
aResult
)
;
void
StreamHasDataToWrite
(
Http3StreamBase
*
aStream
)
;
void
ResetWebTransportStream
(
Http3WebTransportStream
*
aStream
uint64_t
aErrorCode
)
;
void
StreamStopSending
(
Http3WebTransportStream
*
aStream
uint8_t
aErrorCode
)
;
void
SendDatagram
(
Http3WebTransportSession
*
aSession
nsTArray
<
uint8_t
>
&
aData
uint64_t
aTrackingId
)
;
uint64_t
MaxDatagramSize
(
uint64_t
aSessionId
)
;
void
SetSendOrder
(
Http3StreamBase
*
aStream
int64_t
aSendOrder
)
;
void
CloseWebTransportConn
(
)
;
private
:
~
Http3Session
(
)
;
void
CloseInternal
(
bool
aCallNeqoClose
)
;
void
Shutdown
(
)
;
bool
RealJoinConnection
(
const
nsACString
&
hostname
int32_t
port
bool
justKidding
)
;
nsresult
ProcessOutput
(
nsIUDPSocket
*
socket
)
;
void
ProcessInput
(
nsIUDPSocket
*
socket
)
;
nsresult
ProcessEvents
(
)
;
nsresult
ProcessTransactionRead
(
uint64_t
stream_id
)
;
nsresult
ProcessTransactionRead
(
Http3StreamBase
*
stream
)
;
nsresult
ProcessSlowConsumers
(
)
;
void
SetupTimer
(
uint64_t
aTimeout
)
;
enum
ResetType
{
RESET
STOP_SENDING
}
;
void
ResetOrStopSendingRecvd
(
uint64_t
aStreamId
uint64_t
aError
ResetType
aType
)
;
void
QueueStream
(
Http3StreamBase
*
stream
)
;
void
RemoveStreamFromQueues
(
Http3StreamBase
*
)
;
void
ProcessPending
(
)
;
void
CallCertVerification
(
Maybe
<
nsCString
>
aEchPublicName
)
;
void
SetSecInfo
(
)
;
void
EchOutcomeTelemetry
(
)
;
void
StreamReadyToWrite
(
Http3StreamBase
*
aStream
)
;
void
MaybeResumeSend
(
)
;
void
CloseConnectionTelemetry
(
CloseError
&
aError
bool
aClosing
)
;
void
Finish0Rtt
(
bool
aRestart
)
;
enum
ZeroRttOutcome
{
NOT_USED
USED_SUCCEEDED
USED_REJECTED
USED_CONN_ERROR
USED_CONN_CLOSED_BY_NECKO
}
;
void
ZeroRttTelemetry
(
ZeroRttOutcome
aOutcome
)
;
RefPtr
<
NeqoHttp3Conn
>
mHttp3Connection
;
RefPtr
<
nsAHttpConnection
>
mConnection
;
nsTHashMap
<
nsUint64HashKey
uint64_t
>
mWebTransportStreamToSessionMap
;
nsRefPtrHashtable
<
nsUint64HashKey
Http3StreamBase
>
mStreamIdHash
;
nsRefPtrHashtable
<
nsPtrHashKey
<
nsAHttpTransaction
>
Http3StreamBase
>
mStreamTransactionHash
;
nsRefPtrDeque
<
Http3StreamBase
>
mReadyForWrite
;
nsTArray
<
RefPtr
<
Http3StreamBase
>
>
mSlowConsumersReadyForRead
;
nsRefPtrDeque
<
Http3StreamBase
>
mQueuedStreams
;
enum
State
{
INITIALIZING
ZERORTT
CONNECTED
CLOSING
CLOSED
}
mState
{
INITIALIZING
}
;
bool
mAuthenticationStarted
{
false
}
;
bool
mCleanShutdown
{
false
}
;
bool
mGoawayReceived
{
false
}
;
bool
mShouldClose
{
false
}
;
bool
mIsClosedByNeqo
{
false
}
;
bool
mHttp3ConnectionReported
=
false
;
nsresult
mError
{
NS_OK
}
;
nsresult
mSocketError
{
NS_OK
}
;
bool
mBeforeConnectedError
{
false
}
;
uint64_t
mCurrentBrowserId
;
bool
mTimerActive
{
false
}
;
RefPtr
<
HttpConnectionUDP
>
mUdpConn
;
RefPtr
<
nsISocketTransport
>
mSocketTransport
;
nsCOMPtr
<
nsITimer
>
mTimer
;
nsTHashMap
<
nsCStringHashKey
bool
>
mJoinConnectionCache
;
RefPtr
<
QuicSocketControl
>
mSocketControl
;
uint64_t
mTransactionCount
=
0
;
nsTArray
<
WeakPtr
<
Http3StreamBase
>
>
m0RTTStreams
;
nsTArray
<
WeakPtr
<
Http3StreamBase
>
>
mCannotDo0RTTStreams
;
TimeStamp
mConnectionIdleStart
;
TimeStamp
mConnectionIdleEnd
;
Maybe
<
uint64_t
>
mFirstStreamIdReuseIdleConnection
;
TimeStamp
mTimerShouldTrigger
;
TimeStamp
mZeroRttStarted
;
uint64_t
mBlockedByStreamLimitCount
=
0
;
uint64_t
mTransactionsBlockedByStreamLimitCount
=
0
;
uint64_t
mTransactionsSenderBlockedByFlowControlCount
=
0
;
RefPtr
<
nsHttpTransaction
>
mFirstHttpTransaction
;
RefPtr
<
nsHttpConnectionInfo
>
mConnInfo
;
bool
mThroughCaptivePortal
=
false
;
int64_t
mTotalBytesRead
=
0
;
int64_t
mTotalBytesWritten
=
0
;
PRIntervalTime
mLastWriteTime
=
0
;
EchExtensionStatus
mEchExtensionStatus
=
EchExtensionStatus
:
:
kNotPresent
;
bool
mHandshakeSucceeded
=
false
;
nsCOMPtr
<
nsINetAddr
>
mNetAddr
;
enum
WebTransportNegotiation
{
DISABLED
NEGOTIATING
FAILED
SUCCEEDED
}
;
WebTransportNegotiation
mWebTransportNegotiationStatus
{
WebTransportNegotiation
:
:
DISABLED
}
;
nsTArray
<
WeakPtr
<
Http3StreamBase
>
>
mWaitingForWebTransportNegotiation
;
void
WebTransportNegotiationDone
(
)
;
nsTArray
<
RefPtr
<
Http3StreamBase
>
>
mWebTransportSessions
;
nsTArray
<
RefPtr
<
Http3StreamBase
>
>
mWebTransportStreams
;
bool
mHasWebTransportSession
=
false
;
bool
mDontExclude
=
false
;
nsIUDPSocket
*
mSocket
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
Http3Session
NS_HTTP3SESSION_IID
)
;
}
#
endif
