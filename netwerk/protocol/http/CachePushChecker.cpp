#
include
"
CachePushChecker
.
h
"
#
include
"
LoadContextInfo
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessChild
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICacheStorageService
.
h
"
#
include
"
nsICacheStorage
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
CacheControlParser
.
h
"
#
include
"
nsHttpHandler
.
h
"
namespace
mozilla
{
namespace
net
{
NS_IMPL_ISUPPORTS
(
CachePushChecker
nsICacheEntryOpenCallback
)
;
CachePushChecker
:
:
CachePushChecker
(
nsIURI
*
aPushedURL
const
OriginAttributes
&
aOriginAttributes
const
nsACString
&
aRequestString
std
:
:
function
<
void
(
bool
)
>
&
&
aCallback
)
:
mPushedURL
(
aPushedURL
)
mOriginAttributes
(
aOriginAttributes
)
mRequestString
(
aRequestString
)
mCallback
(
std
:
:
move
(
aCallback
)
)
mCurrentEventTarget
(
GetCurrentEventTarget
(
)
)
{
}
nsresult
CachePushChecker
:
:
DoCheck
(
)
{
if
(
XRE_IsSocketProcess
(
)
)
{
RefPtr
<
CachePushChecker
>
self
=
this
;
return
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
CachePushChecker
:
:
DoCheck
"
[
self
]
(
)
{
if
(
SocketProcessChild
*
child
=
SocketProcessChild
:
:
GetSingleton
(
)
)
{
child
-
>
SendCachePushCheck
(
self
-
>
mPushedURL
self
-
>
mOriginAttributes
self
-
>
mRequestString
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
]
(
bool
aResult
)
{
self
-
>
InvokeCallback
(
aResult
)
;
}
[
]
(
const
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
}
)
;
}
}
)
NS_DISPATCH_NORMAL
)
;
}
nsresult
rv
;
nsCOMPtr
<
nsICacheStorageService
>
css
=
do_GetService
(
"
mozilla
.
org
/
netwerk
/
cache
-
storage
-
service
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
RefPtr
<
LoadContextInfo
>
lci
=
GetLoadContextInfo
(
false
mOriginAttributes
)
;
nsCOMPtr
<
nsICacheStorage
>
ds
;
rv
=
css
-
>
DiskCacheStorage
(
lci
getter_AddRefs
(
ds
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
ds
-
>
AsyncOpenURI
(
mPushedURL
"
"
_ns
nsICacheStorage
:
:
OPEN_READONLY
|
nsICacheStorage
:
:
OPEN_SECRETLY
this
)
;
}
NS_IMETHODIMP
CachePushChecker
:
:
OnCacheEntryCheck
(
nsICacheEntry
*
entry
uint32_t
*
result
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
*
result
=
nsICacheEntryOpenCallback
:
:
ENTRY_NOT_WANTED
;
bool
isForcedValid
=
false
;
entry
-
>
GetIsForcedValid
(
&
isForcedValid
)
;
nsHttpRequestHead
requestHead
;
requestHead
.
ParseHeaderSet
(
mRequestString
.
BeginReading
(
)
)
;
nsHttpResponseHead
cachedResponseHead
;
bool
acceptPush
=
true
;
auto
onExitGuard
=
MakeScopeExit
(
[
&
]
{
InvokeCallback
(
acceptPush
)
;
}
)
;
nsresult
rv
=
nsHttp
:
:
GetHttpResponseHeadFromCacheEntry
(
entry
&
cachedResponseHead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
if
(
(
cachedResponseHead
.
Status
(
)
/
100
)
!
=
2
)
{
return
NS_OK
;
}
nsCString
buf
;
rv
=
entry
-
>
GetMetaDataElement
(
"
request
-
method
"
getter_Copies
(
buf
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
nsAutoCString
pushedMethod
;
requestHead
.
Method
(
pushedMethod
)
;
if
(
!
buf
.
Equals
(
pushedMethod
)
)
{
return
NS_OK
;
}
int64_t
size
contentLength
;
rv
=
nsHttp
:
:
CheckPartial
(
entry
&
size
&
contentLength
&
cachedResponseHead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
if
(
size
=
=
int64_t
(
-
1
)
|
|
contentLength
!
=
size
)
{
return
NS_OK
;
}
nsAutoCString
requestedETag
;
if
(
NS_FAILED
(
requestHead
.
GetHeader
(
nsHttp
:
:
If_Match
requestedETag
)
)
)
{
return
NS_OK
;
}
if
(
!
requestedETag
.
IsEmpty
(
)
)
{
nsAutoCString
cachedETag
;
if
(
NS_FAILED
(
cachedResponseHead
.
GetHeader
(
nsHttp
:
:
ETag
cachedETag
)
)
)
{
return
NS_OK
;
}
if
(
!
requestedETag
.
Equals
(
cachedETag
)
)
{
return
NS_OK
;
}
}
nsAutoCString
imsString
;
Unused
<
<
requestHead
.
GetHeader
(
nsHttp
:
:
If_Modified_Since
imsString
)
;
if
(
!
buf
.
IsEmpty
(
)
)
{
uint32_t
ims
=
buf
.
ToInteger
(
&
rv
)
;
uint32_t
lm
;
rv
=
cachedResponseHead
.
GetLastModifiedValue
(
&
lm
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
lm
&
&
lm
<
ims
)
{
return
NS_OK
;
}
}
nsAutoCString
cacheControlRequestHeader
;
Unused
<
<
requestHead
.
GetHeader
(
nsHttp
:
:
Cache_Control
cacheControlRequestHeader
)
;
CacheControlParser
cacheControlRequest
(
cacheControlRequestHeader
)
;
if
(
cacheControlRequest
.
NoStore
(
)
)
{
return
NS_OK
;
}
nsCString
cachedAuth
;
rv
=
entry
-
>
GetMetaDataElement
(
"
auth
"
getter_Copies
(
cachedAuth
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uint32_t
lastModifiedTime
;
rv
=
entry
-
>
GetLastModified
(
&
lastModifiedTime
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
(
gHttpHandler
-
>
SessionStartTime
(
)
>
lastModifiedTime
)
&
&
!
cachedAuth
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
cachedAuth
.
IsEmpty
(
)
&
&
requestHead
.
HasHeader
(
nsHttp
:
:
Authorization
)
)
{
return
NS_OK
;
}
}
}
bool
weaklyFramed
isImmutable
;
nsHttp
:
:
DetermineFramingAndImmutability
(
entry
&
cachedResponseHead
true
&
weaklyFramed
&
isImmutable
)
;
uint32_t
lastModifiedTime
;
rv
=
entry
-
>
GetLastModified
(
&
lastModifiedTime
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
bool
fromPreviousSession
=
(
gHttpHandler
-
>
SessionStartTime
(
)
>
lastModifiedTime
)
;
bool
validationRequired
=
nsHttp
:
:
ValidationRequired
(
isForcedValid
&
cachedResponseHead
0
false
isImmutable
false
requestHead
entry
cacheControlRequest
fromPreviousSession
)
;
if
(
validationRequired
)
{
return
NS_OK
;
}
acceptPush
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
CachePushChecker
:
:
OnCacheEntryAvailable
(
nsICacheEntry
*
entry
bool
isNew
nsresult
result
)
{
return
NS_OK
;
}
void
CachePushChecker
:
:
InvokeCallback
(
bool
aResult
)
{
RefPtr
<
CachePushChecker
>
self
=
this
;
auto
task
=
[
self
aResult
]
(
)
{
self
-
>
mCallback
(
aResult
)
;
}
;
if
(
!
mCurrentEventTarget
-
>
IsOnCurrentThread
(
)
)
{
mCurrentEventTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
CachePushChecker
:
:
InvokeCallback
"
std
:
:
move
(
task
)
)
NS_DISPATCH_NORMAL
)
;
return
;
}
task
(
)
;
}
}
}
