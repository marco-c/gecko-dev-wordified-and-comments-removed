#
include
"
HttpLog
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
#
include
"
nsHttpConnectionInfo
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIProtocolProxyService
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
prnetdb
.
h
"
static
nsresult
SHA256
(
const
char
*
aPlainText
nsAutoCString
&
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsICryptoHash
>
hasher
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpDigestAuth
:
no
crypto
hash
!
\
n
"
)
)
;
return
rv
;
}
rv
=
hasher
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hasher
-
>
Update
(
(
unsigned
char
*
)
aPlainText
strlen
(
aPlainText
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
hasher
-
>
Finish
(
false
aResult
)
;
}
namespace
mozilla
{
namespace
net
{
nsHttpConnectionInfo
:
:
nsHttpConnectionInfo
(
const
nsACString
&
originHost
int32_t
originPort
const
nsACString
&
npnToken
const
nsACString
&
username
const
nsACString
&
topWindowOrigin
nsProxyInfo
*
proxyInfo
const
OriginAttributes
&
originAttributes
bool
endToEndSSL
bool
isolated
bool
aIsHttp3
)
:
mRoutedPort
(
443
)
mIsolated
(
isolated
)
mLessThanTls13
(
false
)
{
Init
(
originHost
originPort
npnToken
username
topWindowOrigin
proxyInfo
originAttributes
endToEndSSL
aIsHttp3
)
;
}
nsHttpConnectionInfo
:
:
nsHttpConnectionInfo
(
const
nsACString
&
originHost
int32_t
originPort
const
nsACString
&
npnToken
const
nsACString
&
username
const
nsACString
&
topWindowOrigin
nsProxyInfo
*
proxyInfo
const
OriginAttributes
&
originAttributes
bool
endToEndSSL
bool
aIsHttp3
)
:
nsHttpConnectionInfo
(
originHost
originPort
npnToken
username
topWindowOrigin
proxyInfo
originAttributes
endToEndSSL
false
aIsHttp3
)
{
}
nsHttpConnectionInfo
:
:
nsHttpConnectionInfo
(
const
nsACString
&
originHost
int32_t
originPort
const
nsACString
&
npnToken
const
nsACString
&
username
const
nsACString
&
topWindowOrigin
nsProxyInfo
*
proxyInfo
const
OriginAttributes
&
originAttributes
const
nsACString
&
routedHost
int32_t
routedPort
bool
isolated
bool
aIsHttp3
)
:
mIsolated
(
isolated
)
mLessThanTls13
(
false
)
{
mEndToEndSSL
=
true
;
mRoutedPort
=
routedPort
=
=
-
1
?
DefaultPort
(
)
:
routedPort
;
if
(
!
originHost
.
Equals
(
routedHost
)
|
|
(
originPort
!
=
routedPort
)
)
{
mRoutedHost
=
routedHost
;
}
Init
(
originHost
originPort
npnToken
username
topWindowOrigin
proxyInfo
originAttributes
true
aIsHttp3
)
;
}
nsHttpConnectionInfo
:
:
nsHttpConnectionInfo
(
const
nsACString
&
originHost
int32_t
originPort
const
nsACString
&
npnToken
const
nsACString
&
username
const
nsACString
&
topWindowOrigin
nsProxyInfo
*
proxyInfo
const
OriginAttributes
&
originAttributes
const
nsACString
&
routedHost
int32_t
routedPort
bool
aIsHttp3
)
:
nsHttpConnectionInfo
(
originHost
originPort
npnToken
username
topWindowOrigin
proxyInfo
originAttributes
routedHost
routedPort
false
aIsHttp3
)
{
}
void
nsHttpConnectionInfo
:
:
Init
(
const
nsACString
&
host
int32_t
port
const
nsACString
&
npnToken
const
nsACString
&
username
const
nsACString
&
topWindowOrigin
nsProxyInfo
*
proxyInfo
const
OriginAttributes
&
originAttributes
bool
e2eSSL
bool
aIsHttp3
)
{
LOG
(
(
"
Init
nsHttpConnectionInfo
%
p
\
n
"
this
)
)
;
mUsername
=
username
;
mTopWindowOrigin
=
topWindowOrigin
;
mProxyInfo
=
proxyInfo
;
mEndToEndSSL
=
e2eSSL
;
mUsingConnect
=
false
;
mNPNToken
=
npnToken
;
mIsHttp3
=
aIsHttp3
;
mOriginAttributes
=
originAttributes
;
mTlsFlags
=
0x0
;
mIsTrrServiceChannel
=
false
;
mTRRMode
=
nsIRequest
:
:
TRR_DEFAULT_MODE
;
mIPv4Disabled
=
false
;
mIPv6Disabled
=
false
;
mUsingHttpsProxy
=
(
proxyInfo
&
&
proxyInfo
-
>
IsHTTPS
(
)
)
;
mUsingHttpProxy
=
mUsingHttpsProxy
|
|
(
proxyInfo
&
&
proxyInfo
-
>
IsHTTP
(
)
)
;
if
(
mUsingHttpProxy
)
{
mUsingConnect
=
mEndToEndSSL
;
uint32_t
resolveFlags
=
0
;
if
(
NS_SUCCEEDED
(
mProxyInfo
-
>
GetResolveFlags
(
&
resolveFlags
)
)
&
&
resolveFlags
&
nsIProtocolProxyService
:
:
RESOLVE_ALWAYS_TUNNEL
)
{
mUsingConnect
=
true
;
}
}
SetOriginServer
(
host
port
)
;
}
void
nsHttpConnectionInfo
:
:
BuildHashKey
(
)
{
const
char
*
keyHost
;
int32_t
keyPort
;
if
(
mUsingHttpProxy
&
&
!
mUsingConnect
)
{
keyHost
=
ProxyHost
(
)
;
keyPort
=
ProxyPort
(
)
;
}
else
{
keyHost
=
Origin
(
)
;
keyPort
=
OriginPort
(
)
;
}
mHashKey
.
AssignLiteral
(
"
.
.
.
.
.
.
.
.
[
tlsflags0x00000000
]
"
)
;
if
(
mIsolated
)
{
mHashKey
.
SetCharAt
(
'
i
'
7
)
;
}
mHashKey
.
Append
(
keyHost
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
AppendInt
(
keyPort
)
;
if
(
!
mUsername
.
IsEmpty
(
)
)
{
mHashKey
.
Append
(
'
[
'
)
;
mHashKey
.
Append
(
mUsername
)
;
mHashKey
.
Append
(
'
]
'
)
;
}
if
(
mUsingHttpsProxy
)
{
mHashKey
.
SetCharAt
(
'
T
'
0
)
;
}
else
if
(
mUsingHttpProxy
)
{
mHashKey
.
SetCharAt
(
'
P
'
0
)
;
}
if
(
mEndToEndSSL
)
{
mHashKey
.
SetCharAt
(
'
S
'
1
)
;
}
if
(
(
!
mUsingHttpProxy
&
&
ProxyHost
(
)
)
|
|
(
mUsingHttpProxy
&
&
mUsingConnect
)
)
{
mHashKey
.
AppendLiteral
(
"
(
"
)
;
mHashKey
.
Append
(
ProxyType
(
)
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
Append
(
ProxyHost
(
)
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
AppendInt
(
ProxyPort
(
)
)
;
mHashKey
.
Append
(
'
)
'
)
;
mHashKey
.
Append
(
'
[
'
)
;
mHashKey
.
Append
(
ProxyUsername
(
)
)
;
mHashKey
.
Append
(
'
:
'
)
;
const
char
*
password
=
ProxyPassword
(
)
;
if
(
strlen
(
password
)
>
0
)
{
nsAutoCString
digestedPassword
;
nsresult
rv
=
SHA256
(
password
digestedPassword
)
;
if
(
rv
=
=
NS_OK
)
{
mHashKey
.
Append
(
digestedPassword
)
;
}
}
mHashKey
.
Append
(
'
]
'
)
;
}
if
(
!
mRoutedHost
.
IsEmpty
(
)
)
{
mHashKey
.
AppendLiteral
(
"
<
ROUTE
-
via
"
)
;
mHashKey
.
Append
(
mRoutedHost
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
AppendInt
(
mRoutedPort
)
;
mHashKey
.
Append
(
'
>
'
)
;
}
if
(
!
mNPNToken
.
IsEmpty
(
)
)
{
mHashKey
.
AppendLiteral
(
"
{
NPN
-
TOKEN
"
)
;
mHashKey
.
Append
(
mNPNToken
)
;
mHashKey
.
AppendLiteral
(
"
}
"
)
;
}
if
(
GetTRRMode
(
)
!
=
nsIRequest
:
:
TRR_DEFAULT_MODE
)
{
mHashKey
.
AppendLiteral
(
"
[
TRR
:
"
)
;
mHashKey
.
AppendInt
(
GetTRRMode
(
)
)
;
mHashKey
.
AppendLiteral
(
"
]
"
)
;
}
if
(
GetIPv4Disabled
(
)
)
{
mHashKey
.
AppendLiteral
(
"
[
!
v4
]
"
)
;
}
if
(
GetIPv6Disabled
(
)
)
{
mHashKey
.
AppendLiteral
(
"
[
!
v6
]
"
)
;
}
if
(
mIsolated
&
&
!
mTopWindowOrigin
.
IsEmpty
(
)
)
{
mHashKey
.
Append
(
'
{
'
)
;
mHashKey
.
Append
(
'
{
'
)
;
mHashKey
.
Append
(
mTopWindowOrigin
)
;
mHashKey
.
Append
(
'
}
'
)
;
mHashKey
.
Append
(
'
}
'
)
;
}
if
(
mProxyInfo
)
{
const
nsCString
&
connectionIsolationKey
=
mProxyInfo
-
>
ConnectionIsolationKey
(
)
;
if
(
!
connectionIsolationKey
.
IsEmpty
(
)
)
{
mHashKey
.
AppendLiteral
(
"
{
CIK
"
)
;
mHashKey
.
Append
(
connectionIsolationKey
)
;
mHashKey
.
AppendLiteral
(
"
}
"
)
;
}
if
(
mProxyInfo
-
>
Flags
(
)
&
nsIProxyInfo
:
:
TRANSPARENT_PROXY_RESOLVES_HOST
)
{
mHashKey
.
AppendLiteral
(
"
{
TPRH
}
"
)
;
}
}
nsAutoCString
originAttributes
;
mOriginAttributes
.
CreateSuffix
(
originAttributes
)
;
mHashKey
.
Append
(
originAttributes
)
;
}
void
nsHttpConnectionInfo
:
:
RebuildHashKey
(
)
{
bool
isAnonymous
=
GetAnonymous
(
)
;
bool
isPrivate
=
GetPrivate
(
)
;
bool
isInsecureScheme
=
GetInsecureScheme
(
)
;
bool
isNoSpdy
=
GetNoSpdy
(
)
;
bool
isBeConservative
=
GetBeConservative
(
)
;
BuildHashKey
(
)
;
SetAnonymous
(
isAnonymous
)
;
SetPrivate
(
isPrivate
)
;
SetInsecureScheme
(
isInsecureScheme
)
;
SetNoSpdy
(
isNoSpdy
)
;
SetBeConservative
(
isBeConservative
)
;
}
void
nsHttpConnectionInfo
:
:
SetOriginServer
(
const
nsACString
&
host
int32_t
port
)
{
mOrigin
=
host
;
mOriginPort
=
port
=
=
-
1
?
DefaultPort
(
)
:
port
;
MOZ_DIAGNOSTIC_ASSERT
(
mHashKey
.
IsEmpty
(
)
)
;
BuildHashKey
(
)
;
}
already_AddRefed
<
nsHttpConnectionInfo
>
nsHttpConnectionInfo
:
:
Clone
(
)
const
{
RefPtr
<
nsHttpConnectionInfo
>
clone
;
if
(
mRoutedHost
.
IsEmpty
(
)
)
{
clone
=
new
nsHttpConnectionInfo
(
mOrigin
mOriginPort
mNPNToken
mUsername
mTopWindowOrigin
mProxyInfo
mOriginAttributes
mEndToEndSSL
mIsolated
mIsHttp3
)
;
}
else
{
MOZ_ASSERT
(
mEndToEndSSL
)
;
clone
=
new
nsHttpConnectionInfo
(
mOrigin
mOriginPort
mNPNToken
mUsername
mTopWindowOrigin
mProxyInfo
mOriginAttributes
mRoutedHost
mRoutedPort
mIsolated
mIsHttp3
)
;
}
clone
-
>
SetAnonymous
(
GetAnonymous
(
)
)
;
clone
-
>
SetPrivate
(
GetPrivate
(
)
)
;
clone
-
>
SetInsecureScheme
(
GetInsecureScheme
(
)
)
;
clone
-
>
SetNoSpdy
(
GetNoSpdy
(
)
)
;
clone
-
>
SetBeConservative
(
GetBeConservative
(
)
)
;
clone
-
>
SetTlsFlags
(
GetTlsFlags
(
)
)
;
clone
-
>
SetIsTrrServiceChannel
(
GetIsTrrServiceChannel
(
)
)
;
clone
-
>
SetTRRMode
(
GetTRRMode
(
)
)
;
clone
-
>
SetIPv4Disabled
(
GetIPv4Disabled
(
)
)
;
clone
-
>
SetIPv6Disabled
(
GetIPv6Disabled
(
)
)
;
MOZ_ASSERT
(
clone
-
>
Equals
(
this
)
)
;
return
clone
.
forget
(
)
;
}
void
nsHttpConnectionInfo
:
:
CloneAsDirectRoute
(
nsHttpConnectionInfo
*
*
outCI
)
{
if
(
mRoutedHost
.
IsEmpty
(
)
)
{
RefPtr
<
nsHttpConnectionInfo
>
clone
=
Clone
(
)
;
clone
.
forget
(
outCI
)
;
return
;
}
RefPtr
<
nsHttpConnectionInfo
>
clone
=
new
nsHttpConnectionInfo
(
mOrigin
mOriginPort
EmptyCString
(
)
mUsername
mTopWindowOrigin
mProxyInfo
mOriginAttributes
mEndToEndSSL
mIsolated
)
;
clone
-
>
SetAnonymous
(
GetAnonymous
(
)
)
;
clone
-
>
SetPrivate
(
GetPrivate
(
)
)
;
clone
-
>
SetInsecureScheme
(
GetInsecureScheme
(
)
)
;
clone
-
>
SetNoSpdy
(
GetNoSpdy
(
)
)
;
clone
-
>
SetBeConservative
(
GetBeConservative
(
)
)
;
clone
-
>
SetTlsFlags
(
GetTlsFlags
(
)
)
;
clone
-
>
SetIsTrrServiceChannel
(
GetIsTrrServiceChannel
(
)
)
;
clone
-
>
SetTRRMode
(
GetTRRMode
(
)
)
;
clone
-
>
SetIPv4Disabled
(
GetIPv4Disabled
(
)
)
;
clone
-
>
SetIPv6Disabled
(
GetIPv6Disabled
(
)
)
;
clone
.
forget
(
outCI
)
;
}
nsresult
nsHttpConnectionInfo
:
:
CreateWildCard
(
nsHttpConnectionInfo
*
*
outParam
)
{
if
(
!
mUsingHttpsProxy
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
RefPtr
<
nsHttpConnectionInfo
>
clone
;
clone
=
new
nsHttpConnectionInfo
(
NS_LITERAL_CSTRING
(
"
*
"
)
0
mNPNToken
mUsername
mTopWindowOrigin
mProxyInfo
mOriginAttributes
true
mIsHttp3
)
;
clone
-
>
SetAnonymous
(
GetAnonymous
(
)
)
;
clone
-
>
SetPrivate
(
GetPrivate
(
)
)
;
clone
.
forget
(
outParam
)
;
return
NS_OK
;
}
void
nsHttpConnectionInfo
:
:
SetTRRMode
(
nsIRequest
:
:
TRRMode
aTRRMode
)
{
if
(
mTRRMode
!
=
aTRRMode
)
{
mTRRMode
=
aTRRMode
;
RebuildHashKey
(
)
;
}
}
void
nsHttpConnectionInfo
:
:
SetIPv4Disabled
(
bool
aNoIPv4
)
{
if
(
mIPv4Disabled
!
=
aNoIPv4
)
{
mIPv4Disabled
=
aNoIPv4
;
RebuildHashKey
(
)
;
}
}
void
nsHttpConnectionInfo
:
:
SetIPv6Disabled
(
bool
aNoIPv6
)
{
if
(
mIPv6Disabled
!
=
aNoIPv6
)
{
mIPv6Disabled
=
aNoIPv6
;
RebuildHashKey
(
)
;
}
}
void
nsHttpConnectionInfo
:
:
SetTlsFlags
(
uint32_t
aTlsFlags
)
{
mTlsFlags
=
aTlsFlags
;
mHashKey
.
Replace
(
19
8
nsPrintfCString
(
"
%
08x
"
mTlsFlags
)
)
;
}
bool
nsHttpConnectionInfo
:
:
UsingProxy
(
)
{
if
(
!
mProxyInfo
)
return
false
;
return
!
mProxyInfo
-
>
IsDirect
(
)
;
}
bool
nsHttpConnectionInfo
:
:
HostIsLocalIPLiteral
(
)
const
{
PRNetAddr
prAddr
;
if
(
ProxyHost
(
)
)
{
if
(
PR_StringToNetAddr
(
ProxyHost
(
)
&
prAddr
)
!
=
PR_SUCCESS
)
{
return
false
;
}
}
else
if
(
PR_StringToNetAddr
(
Origin
(
)
&
prAddr
)
!
=
PR_SUCCESS
)
{
return
false
;
}
NetAddr
netAddr
;
PRNetAddrToNetAddr
(
&
prAddr
&
netAddr
)
;
return
IsIPAddrLocal
(
&
netAddr
)
;
}
}
}
