#
include
"
HttpLog
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
#
include
"
nsHttpConnectionInfo
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
mozilla
/
net
/
NeckoChannelParams
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIDNSByTypeRecord
.
h
"
#
include
"
nsIProtocolProxyService
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsProxyInfo
.
h
"
#
include
"
prnetdb
.
h
"
static
nsresult
ComputeHash
(
uint32_t
aAlgorithm
const
uint8_t
*
aInput
uint32_t
aLen
nsAutoCString
&
aResult
)
{
nsCOMPtr
<
nsICryptoHash
>
hasher
;
nsresult
rv
=
NS_NewCryptoHash
(
aAlgorithm
getter_AddRefs
(
hasher
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpDigestAuth
:
no
crypto
hash
!
\
n
"
)
)
;
return
rv
;
}
rv
=
hasher
-
>
Update
(
aInput
aLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
hasher
-
>
Finish
(
true
aResult
)
;
}
namespace
mozilla
{
namespace
net
{
nsHttpConnectionInfo
:
:
nsHttpConnectionInfo
(
const
nsACString
&
originHost
int32_t
originPort
const
nsACString
&
npnToken
const
nsACString
&
username
nsProxyInfo
*
proxyInfo
const
OriginAttributes
&
originAttributes
bool
endToEndSSL
bool
aIsHttp3
bool
aWebTransport
)
:
mRoutedPort
(
443
)
mLessThanTls13
(
false
)
{
Init
(
originHost
originPort
npnToken
username
proxyInfo
originAttributes
endToEndSSL
aIsHttp3
aWebTransport
)
;
}
nsHttpConnectionInfo
:
:
nsHttpConnectionInfo
(
const
nsACString
&
originHost
int32_t
originPort
const
nsACString
&
npnToken
const
nsACString
&
username
nsProxyInfo
*
proxyInfo
const
OriginAttributes
&
originAttributes
const
nsACString
&
routedHost
int32_t
routedPort
bool
aIsHttp3
bool
aWebTransport
)
:
mLessThanTls13
(
false
)
{
mEndToEndSSL
=
true
;
mRoutedPort
=
routedPort
=
=
-
1
?
DefaultPort
(
)
:
routedPort
;
if
(
!
originHost
.
Equals
(
routedHost
)
|
|
(
originPort
!
=
routedPort
)
|
|
aIsHttp3
)
{
mRoutedHost
=
routedHost
;
}
Init
(
originHost
originPort
npnToken
username
proxyInfo
originAttributes
true
aIsHttp3
aWebTransport
)
;
}
void
nsHttpConnectionInfo
:
:
Init
(
const
nsACString
&
host
int32_t
port
const
nsACString
&
npnToken
const
nsACString
&
username
nsProxyInfo
*
proxyInfo
const
OriginAttributes
&
originAttributes
bool
e2eSSL
bool
aIsHttp3
bool
aWebTransport
)
{
LOG
(
(
"
Init
nsHttpConnectionInfo
%
p
\
n
"
this
)
)
;
mUsername
=
username
;
mProxyInfo
=
proxyInfo
;
mEndToEndSSL
=
e2eSSL
;
mUsingConnect
=
false
;
mNPNToken
=
npnToken
;
mIsHttp3
=
aIsHttp3
;
mWebTransport
=
aWebTransport
;
mOriginAttributes
=
originAttributes
;
mTlsFlags
=
0x0
;
mIsTrrServiceChannel
=
false
;
mTRRMode
=
nsIRequest
:
:
TRR_DEFAULT_MODE
;
mIPv4Disabled
=
false
;
mIPv6Disabled
=
false
;
mHasIPHintAddress
=
false
;
mUsingHttpsProxy
=
(
proxyInfo
&
&
proxyInfo
-
>
IsHTTPS
(
)
)
;
mUsingHttpProxy
=
mUsingHttpsProxy
|
|
(
proxyInfo
&
&
proxyInfo
-
>
IsHTTP
(
)
)
;
if
(
mUsingHttpProxy
)
{
mUsingConnect
=
mEndToEndSSL
;
uint32_t
resolveFlags
=
0
;
if
(
NS_SUCCEEDED
(
mProxyInfo
-
>
GetResolveFlags
(
&
resolveFlags
)
)
&
&
resolveFlags
&
nsIProtocolProxyService
:
:
RESOLVE_ALWAYS_TUNNEL
)
{
mUsingConnect
=
true
;
}
}
SetOriginServer
(
host
port
)
;
}
void
nsHttpConnectionInfo
:
:
BuildHashKey
(
)
{
const
char
*
keyHost
;
int32_t
keyPort
;
if
(
mUsingHttpProxy
&
&
!
mUsingConnect
)
{
keyHost
=
ProxyHost
(
)
;
keyPort
=
ProxyPort
(
)
;
}
else
{
keyHost
=
Origin
(
)
;
keyPort
=
OriginPort
(
)
;
}
const
auto
keyTemplate
=
std
:
:
string
(
UnderlyingIndex
(
HashKeyIndex
:
:
End
)
'
.
'
)
+
std
:
:
string
(
"
[
tlsflags0x00000000
]
"
)
;
mHashKey
.
Assign
(
keyTemplate
.
c_str
(
)
)
;
mHashKey
.
Append
(
keyHost
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
AppendInt
(
keyPort
)
;
if
(
!
mUsername
.
IsEmpty
(
)
)
{
mHashKey
.
Append
(
'
[
'
)
;
mHashKey
.
Append
(
mUsername
)
;
mHashKey
.
Append
(
'
]
'
)
;
}
if
(
mUsingHttpsProxy
)
{
SetHashCharAt
(
'
T
'
HashKeyIndex
:
:
Proxy
)
;
}
else
if
(
mUsingHttpProxy
)
{
SetHashCharAt
(
'
P
'
HashKeyIndex
:
:
Proxy
)
;
}
if
(
mEndToEndSSL
)
{
SetHashCharAt
(
'
S
'
HashKeyIndex
:
:
EndToEndSSL
)
;
}
if
(
mWebTransport
)
{
SetHashCharAt
(
'
W
'
HashKeyIndex
:
:
WebTransport
)
;
}
if
(
(
!
mUsingHttpProxy
&
&
ProxyHost
(
)
)
|
|
(
mUsingHttpProxy
&
&
mUsingConnect
)
)
{
mHashKey
.
AppendLiteral
(
"
(
"
)
;
mHashKey
.
Append
(
ProxyType
(
)
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
Append
(
ProxyHost
(
)
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
AppendInt
(
ProxyPort
(
)
)
;
mHashKey
.
Append
(
'
)
'
)
;
mHashKey
.
Append
(
'
[
'
)
;
mHashKey
.
Append
(
ProxyUsername
(
)
)
;
mHashKey
.
Append
(
'
:
'
)
;
const
char
*
password
=
ProxyPassword
(
)
;
uint32_t
len
=
strlen
(
password
)
;
if
(
len
>
0
)
{
nsAutoCString
digestedPassword
;
nsresult
rv
=
ComputeHash
(
nsICryptoHash
:
:
SHA256
reinterpret_cast
<
const
uint8_t
*
>
(
password
)
len
digestedPassword
)
;
if
(
rv
=
=
NS_OK
)
{
mHashKey
.
Append
(
digestedPassword
)
;
}
}
mHashKey
.
Append
(
'
]
'
)
;
}
if
(
!
mRoutedHost
.
IsEmpty
(
)
)
{
mHashKey
.
AppendLiteral
(
"
<
ROUTE
-
via
"
)
;
mHashKey
.
Append
(
mRoutedHost
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
AppendInt
(
mRoutedPort
)
;
mHashKey
.
Append
(
'
>
'
)
;
}
if
(
!
mNPNToken
.
IsEmpty
(
)
)
{
mHashKey
.
AppendLiteral
(
"
{
NPN
-
TOKEN
"
)
;
mHashKey
.
Append
(
mNPNToken
)
;
mHashKey
.
AppendLiteral
(
"
}
"
)
;
}
if
(
GetTRRMode
(
)
!
=
nsIRequest
:
:
TRR_DEFAULT_MODE
)
{
mHashKey
.
AppendLiteral
(
"
[
TRR
:
"
)
;
mHashKey
.
AppendInt
(
GetTRRMode
(
)
)
;
mHashKey
.
AppendLiteral
(
"
]
"
)
;
}
if
(
GetIPv4Disabled
(
)
)
{
mHashKey
.
AppendLiteral
(
"
[
!
v4
]
"
)
;
}
if
(
GetIPv6Disabled
(
)
)
{
mHashKey
.
AppendLiteral
(
"
[
!
v6
]
"
)
;
}
if
(
mProxyInfo
)
{
const
nsCString
&
connectionIsolationKey
=
mProxyInfo
-
>
ConnectionIsolationKey
(
)
;
if
(
!
connectionIsolationKey
.
IsEmpty
(
)
)
{
mHashKey
.
AppendLiteral
(
"
{
CIK
"
)
;
mHashKey
.
Append
(
connectionIsolationKey
)
;
mHashKey
.
AppendLiteral
(
"
}
"
)
;
}
if
(
mProxyInfo
-
>
Flags
(
)
&
nsIProxyInfo
:
:
TRANSPARENT_PROXY_RESOLVES_HOST
)
{
mHashKey
.
AppendLiteral
(
"
{
TPRH
}
"
)
;
}
}
if
(
mWebTransportId
)
{
mHashKey
.
AppendLiteral
(
"
{
wId
"
)
;
mHashKey
.
AppendInt
(
mWebTransportId
16
)
;
mHashKey
.
AppendLiteral
(
"
}
"
)
;
}
if
(
!
mEchConfig
.
IsEmpty
(
)
)
{
nsAutoCString
digestedEch
;
nsresult
rv
=
ComputeHash
(
nsICryptoHash
:
:
SHA1
reinterpret_cast
<
const
uint8_t
*
>
(
mEchConfig
.
BeginReading
(
)
)
mEchConfig
.
Length
(
)
digestedEch
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mHashKey
.
AppendLiteral
(
"
{
ech
"
)
;
mHashKey
.
Append
(
digestedEch
)
;
mHashKey
.
AppendLiteral
(
"
}
"
)
;
}
}
nsAutoCString
originAttributes
;
mOriginAttributes
.
CreateSuffix
(
originAttributes
)
;
mHashKey
.
Append
(
originAttributes
)
;
}
void
nsHttpConnectionInfo
:
:
RebuildHashKey
(
)
{
bool
isAnonymous
=
GetAnonymous
(
)
;
bool
isPrivate
=
GetPrivate
(
)
;
bool
isInsecureScheme
=
GetInsecureScheme
(
)
;
bool
isNoSpdy
=
GetNoSpdy
(
)
;
bool
isBeConservative
=
GetBeConservative
(
)
;
bool
isAnonymousAllowClientCert
=
GetAnonymousAllowClientCert
(
)
;
bool
isFallback
=
GetFallbackConnection
(
)
;
BuildHashKey
(
)
;
SetAnonymous
(
isAnonymous
)
;
SetPrivate
(
isPrivate
)
;
SetInsecureScheme
(
isInsecureScheme
)
;
SetNoSpdy
(
isNoSpdy
)
;
SetBeConservative
(
isBeConservative
)
;
SetAnonymousAllowClientCert
(
isAnonymousAllowClientCert
)
;
SetFallbackConnection
(
isFallback
)
;
SetTlsFlags
(
mTlsFlags
)
;
}
void
nsHttpConnectionInfo
:
:
SetOriginServer
(
const
nsACString
&
host
int32_t
port
)
{
mOrigin
=
host
;
mOriginPort
=
port
=
=
-
1
?
DefaultPort
(
)
:
port
;
MOZ_DIAGNOSTIC_ASSERT
(
mHashKey
.
IsEmpty
(
)
)
;
BuildHashKey
(
)
;
}
already_AddRefed
<
nsHttpConnectionInfo
>
nsHttpConnectionInfo
:
:
Clone
(
)
const
{
RefPtr
<
nsHttpConnectionInfo
>
clone
;
if
(
mRoutedHost
.
IsEmpty
(
)
)
{
clone
=
new
nsHttpConnectionInfo
(
mOrigin
mOriginPort
mNPNToken
mUsername
mProxyInfo
mOriginAttributes
mEndToEndSSL
mIsHttp3
mWebTransport
)
;
}
else
{
MOZ_ASSERT
(
mEndToEndSSL
)
;
clone
=
new
nsHttpConnectionInfo
(
mOrigin
mOriginPort
mNPNToken
mUsername
mProxyInfo
mOriginAttributes
mRoutedHost
mRoutedPort
mIsHttp3
mWebTransport
)
;
}
clone
-
>
SetAnonymous
(
GetAnonymous
(
)
)
;
clone
-
>
SetPrivate
(
GetPrivate
(
)
)
;
clone
-
>
SetInsecureScheme
(
GetInsecureScheme
(
)
)
;
clone
-
>
SetNoSpdy
(
GetNoSpdy
(
)
)
;
clone
-
>
SetBeConservative
(
GetBeConservative
(
)
)
;
clone
-
>
SetAnonymousAllowClientCert
(
GetAnonymousAllowClientCert
(
)
)
;
clone
-
>
SetFallbackConnection
(
GetFallbackConnection
(
)
)
;
clone
-
>
SetTlsFlags
(
GetTlsFlags
(
)
)
;
clone
-
>
SetIsTrrServiceChannel
(
GetIsTrrServiceChannel
(
)
)
;
clone
-
>
SetTRRMode
(
GetTRRMode
(
)
)
;
clone
-
>
SetIPv4Disabled
(
GetIPv4Disabled
(
)
)
;
clone
-
>
SetIPv6Disabled
(
GetIPv6Disabled
(
)
)
;
clone
-
>
SetHasIPHintAddress
(
HasIPHintAddress
(
)
)
;
clone
-
>
SetEchConfig
(
GetEchConfig
(
)
)
;
clone
-
>
SetWebTransportId
(
GetWebTransportId
(
)
)
;
MOZ_ASSERT
(
clone
-
>
Equals
(
this
)
)
;
return
clone
.
forget
(
)
;
}
already_AddRefed
<
nsHttpConnectionInfo
>
nsHttpConnectionInfo
:
:
CloneAndAdoptHTTPSSVCRecord
(
nsISVCBRecord
*
aRecord
)
const
{
MOZ_ASSERT
(
aRecord
)
;
nsAutoCString
name
;
aRecord
-
>
GetName
(
name
)
;
Maybe
<
uint16_t
>
port
=
aRecord
-
>
GetPort
(
)
;
Maybe
<
std
:
:
tuple
<
nsCString
SupportedAlpnRank
>
>
alpn
=
aRecord
-
>
GetAlpn
(
)
;
bool
isHttp3
=
alpn
?
mozilla
:
:
net
:
:
IsHttp3
(
std
:
:
get
<
1
>
(
*
alpn
)
)
:
false
;
LOG
(
(
"
HTTPSSVC
:
use
new
routed
host
(
%
s
)
and
new
npnToken
(
%
s
)
"
name
.
get
(
)
alpn
?
std
:
:
get
<
0
>
(
*
alpn
)
.
get
(
)
:
"
None
"
)
)
;
RefPtr
<
nsHttpConnectionInfo
>
clone
;
if
(
name
.
IsEmpty
(
)
)
{
clone
=
new
nsHttpConnectionInfo
(
mOrigin
mOriginPort
alpn
?
std
:
:
get
<
0
>
(
*
alpn
)
:
EmptyCString
(
)
mUsername
mProxyInfo
mOriginAttributes
mEndToEndSSL
isHttp3
)
;
}
else
{
MOZ_ASSERT
(
mEndToEndSSL
)
;
clone
=
new
nsHttpConnectionInfo
(
mOrigin
mOriginPort
alpn
?
std
:
:
get
<
0
>
(
*
alpn
)
:
EmptyCString
(
)
mUsername
mProxyInfo
mOriginAttributes
name
port
?
*
port
:
mOriginPort
isHttp3
mWebTransport
)
;
}
clone
-
>
SetAnonymous
(
GetAnonymous
(
)
)
;
clone
-
>
SetPrivate
(
GetPrivate
(
)
)
;
clone
-
>
SetInsecureScheme
(
GetInsecureScheme
(
)
)
;
clone
-
>
SetNoSpdy
(
GetNoSpdy
(
)
)
;
clone
-
>
SetBeConservative
(
GetBeConservative
(
)
)
;
clone
-
>
SetAnonymousAllowClientCert
(
GetAnonymousAllowClientCert
(
)
)
;
clone
-
>
SetFallbackConnection
(
GetFallbackConnection
(
)
)
;
clone
-
>
SetTlsFlags
(
GetTlsFlags
(
)
)
;
clone
-
>
SetIsTrrServiceChannel
(
GetIsTrrServiceChannel
(
)
)
;
clone
-
>
SetTRRMode
(
GetTRRMode
(
)
)
;
clone
-
>
SetIPv4Disabled
(
GetIPv4Disabled
(
)
)
;
clone
-
>
SetIPv6Disabled
(
GetIPv6Disabled
(
)
)
;
bool
hasIPHint
=
false
;
Unused
<
<
aRecord
-
>
GetHasIPHintAddress
(
&
hasIPHint
)
;
if
(
hasIPHint
)
{
clone
-
>
SetHasIPHintAddress
(
hasIPHint
)
;
}
nsAutoCString
echConfig
;
Unused
<
<
aRecord
-
>
GetEchConfig
(
echConfig
)
;
clone
-
>
SetEchConfig
(
echConfig
)
;
return
clone
.
forget
(
)
;
}
void
nsHttpConnectionInfo
:
:
SerializeHttpConnectionInfo
(
nsHttpConnectionInfo
*
aInfo
HttpConnectionInfoCloneArgs
&
aArgs
)
{
aArgs
.
host
(
)
=
aInfo
-
>
GetOrigin
(
)
;
aArgs
.
port
(
)
=
aInfo
-
>
OriginPort
(
)
;
aArgs
.
npnToken
(
)
=
aInfo
-
>
GetNPNToken
(
)
;
aArgs
.
username
(
)
=
aInfo
-
>
GetUsername
(
)
;
aArgs
.
originAttributes
(
)
=
aInfo
-
>
GetOriginAttributes
(
)
;
aArgs
.
endToEndSSL
(
)
=
aInfo
-
>
EndToEndSSL
(
)
;
aArgs
.
routedHost
(
)
=
aInfo
-
>
GetRoutedHost
(
)
;
aArgs
.
routedPort
(
)
=
aInfo
-
>
RoutedPort
(
)
;
aArgs
.
anonymous
(
)
=
aInfo
-
>
GetAnonymous
(
)
;
aArgs
.
aPrivate
(
)
=
aInfo
-
>
GetPrivate
(
)
;
aArgs
.
insecureScheme
(
)
=
aInfo
-
>
GetInsecureScheme
(
)
;
aArgs
.
noSpdy
(
)
=
aInfo
-
>
GetNoSpdy
(
)
;
aArgs
.
beConservative
(
)
=
aInfo
-
>
GetBeConservative
(
)
;
aArgs
.
anonymousAllowClientCert
(
)
=
aInfo
-
>
GetAnonymousAllowClientCert
(
)
;
aArgs
.
tlsFlags
(
)
=
aInfo
-
>
GetTlsFlags
(
)
;
aArgs
.
isTrrServiceChannel
(
)
=
aInfo
-
>
GetTRRMode
(
)
;
aArgs
.
trrMode
(
)
=
aInfo
-
>
GetTRRMode
(
)
;
aArgs
.
isIPv4Disabled
(
)
=
aInfo
-
>
GetIPv4Disabled
(
)
;
aArgs
.
isIPv6Disabled
(
)
=
aInfo
-
>
GetIPv6Disabled
(
)
;
aArgs
.
isHttp3
(
)
=
aInfo
-
>
IsHttp3
(
)
;
aArgs
.
hasIPHintAddress
(
)
=
aInfo
-
>
HasIPHintAddress
(
)
;
aArgs
.
echConfig
(
)
=
aInfo
-
>
GetEchConfig
(
)
;
aArgs
.
webTransport
(
)
=
aInfo
-
>
GetWebTransport
(
)
;
aArgs
.
webTransportId
(
)
=
aInfo
-
>
GetWebTransportId
(
)
;
if
(
!
aInfo
-
>
ProxyInfo
(
)
)
{
return
;
}
nsTArray
<
ProxyInfoCloneArgs
>
proxyInfoArray
;
nsProxyInfo
:
:
SerializeProxyInfo
(
aInfo
-
>
ProxyInfo
(
)
proxyInfoArray
)
;
aArgs
.
proxyInfo
(
)
=
std
:
:
move
(
proxyInfoArray
)
;
}
already_AddRefed
<
nsHttpConnectionInfo
>
nsHttpConnectionInfo
:
:
DeserializeHttpConnectionInfoCloneArgs
(
const
HttpConnectionInfoCloneArgs
&
aInfoArgs
)
{
nsProxyInfo
*
pi
=
nsProxyInfo
:
:
DeserializeProxyInfo
(
aInfoArgs
.
proxyInfo
(
)
)
;
RefPtr
<
nsHttpConnectionInfo
>
cinfo
;
if
(
aInfoArgs
.
routedHost
(
)
.
IsEmpty
(
)
)
{
cinfo
=
new
nsHttpConnectionInfo
(
aInfoArgs
.
host
(
)
aInfoArgs
.
port
(
)
aInfoArgs
.
npnToken
(
)
aInfoArgs
.
username
(
)
pi
aInfoArgs
.
originAttributes
(
)
aInfoArgs
.
endToEndSSL
(
)
aInfoArgs
.
isHttp3
(
)
aInfoArgs
.
webTransport
(
)
)
;
}
else
{
MOZ_ASSERT
(
aInfoArgs
.
endToEndSSL
(
)
)
;
cinfo
=
new
nsHttpConnectionInfo
(
aInfoArgs
.
host
(
)
aInfoArgs
.
port
(
)
aInfoArgs
.
npnToken
(
)
aInfoArgs
.
username
(
)
pi
aInfoArgs
.
originAttributes
(
)
aInfoArgs
.
routedHost
(
)
aInfoArgs
.
routedPort
(
)
aInfoArgs
.
isHttp3
(
)
aInfoArgs
.
webTransport
(
)
)
;
}
cinfo
-
>
SetWebTransportId
(
aInfoArgs
.
webTransportId
(
)
)
;
cinfo
-
>
SetAnonymous
(
aInfoArgs
.
anonymous
(
)
)
;
cinfo
-
>
SetPrivate
(
aInfoArgs
.
aPrivate
(
)
)
;
cinfo
-
>
SetInsecureScheme
(
aInfoArgs
.
insecureScheme
(
)
)
;
cinfo
-
>
SetNoSpdy
(
aInfoArgs
.
noSpdy
(
)
)
;
cinfo
-
>
SetBeConservative
(
aInfoArgs
.
beConservative
(
)
)
;
cinfo
-
>
SetAnonymousAllowClientCert
(
aInfoArgs
.
anonymousAllowClientCert
(
)
)
;
cinfo
-
>
SetFallbackConnection
(
aInfoArgs
.
fallbackConnection
(
)
)
;
cinfo
-
>
SetTlsFlags
(
aInfoArgs
.
tlsFlags
(
)
)
;
cinfo
-
>
SetIsTrrServiceChannel
(
aInfoArgs
.
isTrrServiceChannel
(
)
)
;
cinfo
-
>
SetTRRMode
(
static_cast
<
nsIRequest
:
:
TRRMode
>
(
aInfoArgs
.
trrMode
(
)
)
)
;
cinfo
-
>
SetIPv4Disabled
(
aInfoArgs
.
isIPv4Disabled
(
)
)
;
cinfo
-
>
SetIPv6Disabled
(
aInfoArgs
.
isIPv6Disabled
(
)
)
;
cinfo
-
>
SetHasIPHintAddress
(
aInfoArgs
.
hasIPHintAddress
(
)
)
;
cinfo
-
>
SetEchConfig
(
aInfoArgs
.
echConfig
(
)
)
;
return
cinfo
.
forget
(
)
;
}
void
nsHttpConnectionInfo
:
:
CloneAsDirectRoute
(
nsHttpConnectionInfo
*
*
outCI
)
{
RefPtr
<
nsHttpConnectionInfo
>
clone
=
new
nsHttpConnectionInfo
(
mOrigin
mOriginPort
(
mRoutedHost
.
IsEmpty
(
)
&
&
!
mIsHttp3
)
?
mNPNToken
:
"
"
_ns
mUsername
mProxyInfo
mOriginAttributes
mEndToEndSSL
false
mWebTransport
)
;
clone
-
>
SetAnonymous
(
GetAnonymous
(
)
)
;
clone
-
>
SetPrivate
(
GetPrivate
(
)
)
;
clone
-
>
SetInsecureScheme
(
GetInsecureScheme
(
)
)
;
clone
-
>
SetNoSpdy
(
GetNoSpdy
(
)
)
;
clone
-
>
SetBeConservative
(
GetBeConservative
(
)
)
;
clone
-
>
SetAnonymousAllowClientCert
(
GetAnonymousAllowClientCert
(
)
)
;
clone
-
>
SetFallbackConnection
(
GetFallbackConnection
(
)
)
;
clone
-
>
SetTlsFlags
(
GetTlsFlags
(
)
)
;
clone
-
>
SetIsTrrServiceChannel
(
GetIsTrrServiceChannel
(
)
)
;
clone
-
>
SetTRRMode
(
GetTRRMode
(
)
)
;
clone
-
>
SetIPv4Disabled
(
GetIPv4Disabled
(
)
)
;
clone
-
>
SetIPv6Disabled
(
GetIPv6Disabled
(
)
)
;
clone
-
>
SetHasIPHintAddress
(
HasIPHintAddress
(
)
)
;
clone
-
>
SetEchConfig
(
GetEchConfig
(
)
)
;
clone
.
forget
(
outCI
)
;
}
nsresult
nsHttpConnectionInfo
:
:
CreateWildCard
(
nsHttpConnectionInfo
*
*
outParam
)
{
if
(
!
mUsingHttpsProxy
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
RefPtr
<
nsHttpConnectionInfo
>
clone
;
clone
=
new
nsHttpConnectionInfo
(
"
*
"
_ns
0
mNPNToken
mUsername
mProxyInfo
mOriginAttributes
true
mIsHttp3
mWebTransport
)
;
clone
-
>
SetAnonymous
(
GetAnonymous
(
)
)
;
clone
-
>
SetPrivate
(
GetPrivate
(
)
)
;
clone
.
forget
(
outParam
)
;
return
NS_OK
;
}
void
nsHttpConnectionInfo
:
:
SetTRRMode
(
nsIRequest
:
:
TRRMode
aTRRMode
)
{
if
(
mTRRMode
!
=
aTRRMode
)
{
mTRRMode
=
aTRRMode
;
RebuildHashKey
(
)
;
}
}
void
nsHttpConnectionInfo
:
:
SetIPv4Disabled
(
bool
aNoIPv4
)
{
if
(
mIPv4Disabled
!
=
aNoIPv4
)
{
mIPv4Disabled
=
aNoIPv4
;
RebuildHashKey
(
)
;
}
}
void
nsHttpConnectionInfo
:
:
SetIPv6Disabled
(
bool
aNoIPv6
)
{
if
(
mIPv6Disabled
!
=
aNoIPv6
)
{
mIPv6Disabled
=
aNoIPv6
;
RebuildHashKey
(
)
;
}
}
void
nsHttpConnectionInfo
:
:
SetWebTransport
(
bool
aWebTransport
)
{
if
(
mWebTransport
!
=
aWebTransport
)
{
mWebTransport
=
aWebTransport
;
RebuildHashKey
(
)
;
}
}
void
nsHttpConnectionInfo
:
:
SetWebTransportId
(
uint64_t
id
)
{
if
(
mWebTransportId
!
=
id
)
{
mWebTransportId
=
id
;
RebuildHashKey
(
)
;
}
}
void
nsHttpConnectionInfo
:
:
SetEchConfig
(
const
nsACString
&
aEchConfig
)
{
if
(
!
mEchConfig
.
Equals
(
aEchConfig
)
)
{
mEchConfig
=
aEchConfig
;
RebuildHashKey
(
)
;
}
}
void
nsHttpConnectionInfo
:
:
SetTlsFlags
(
uint32_t
aTlsFlags
)
{
mTlsFlags
=
aTlsFlags
;
const
uint32_t
tlsFlagsLength
=
8
;
const
uint32_t
tlsFlagsIndex
=
UnderlyingIndex
(
HashKeyIndex
:
:
End
)
+
strlen
(
"
[
tlsflags0x
"
)
;
mHashKey
.
Replace
(
tlsFlagsIndex
tlsFlagsLength
nsPrintfCString
(
"
%
08x
"
mTlsFlags
)
)
;
}
bool
nsHttpConnectionInfo
:
:
UsingProxy
(
)
{
if
(
!
mProxyInfo
)
return
false
;
return
!
mProxyInfo
-
>
IsDirect
(
)
;
}
bool
nsHttpConnectionInfo
:
:
HostIsLocalIPLiteral
(
)
const
{
NetAddr
netAddr
;
nsAutoCString
host
(
ProxyHost
(
)
?
ProxyHost
(
)
:
Origin
(
)
)
;
if
(
NS_FAILED
(
netAddr
.
InitFromString
(
host
)
)
)
{
return
false
;
}
return
netAddr
.
IsIPAddrLocal
(
)
;
}
}
}
