#
include
"
HttpLog
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
#
include
"
nsHttpConnectionInfo
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIProtocolProxyService
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
prnetdb
.
h
"
static
nsresult
SHA256
(
const
char
*
aPlainText
nsAutoCString
&
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsICryptoHash
>
hasher
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
nsHttpDigestAuth
:
no
crypto
hash
!
\
n
"
)
)
;
return
rv
;
}
rv
=
hasher
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hasher
-
>
Update
(
(
unsigned
char
*
)
aPlainText
strlen
(
aPlainText
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
hasher
-
>
Finish
(
false
aResult
)
;
}
namespace
mozilla
{
namespace
net
{
nsHttpConnectionInfo
:
:
nsHttpConnectionInfo
(
const
nsACString
&
originHost
int32_t
originPort
const
nsACString
&
npnToken
const
nsACString
&
username
nsProxyInfo
*
proxyInfo
const
OriginAttributes
&
originAttributes
bool
endToEndSSL
)
:
mRoutedPort
(
443
)
{
Init
(
originHost
originPort
npnToken
username
proxyInfo
originAttributes
endToEndSSL
)
;
}
nsHttpConnectionInfo
:
:
nsHttpConnectionInfo
(
const
nsACString
&
originHost
int32_t
originPort
const
nsACString
&
npnToken
const
nsACString
&
username
nsProxyInfo
*
proxyInfo
const
OriginAttributes
&
originAttributes
const
nsACString
&
routedHost
int32_t
routedPort
)
{
mEndToEndSSL
=
true
;
mRoutedPort
=
routedPort
=
=
-
1
?
DefaultPort
(
)
:
routedPort
;
if
(
!
originHost
.
Equals
(
routedHost
)
|
|
(
originPort
!
=
routedPort
)
)
{
mRoutedHost
=
routedHost
;
}
Init
(
originHost
originPort
npnToken
username
proxyInfo
originAttributes
true
)
;
}
void
nsHttpConnectionInfo
:
:
Init
(
const
nsACString
&
host
int32_t
port
const
nsACString
&
npnToken
const
nsACString
&
username
nsProxyInfo
*
proxyInfo
const
OriginAttributes
&
originAttributes
bool
e2eSSL
)
{
LOG
(
(
"
Init
nsHttpConnectionInfo
%
p
\
n
"
this
)
)
;
mUsername
=
username
;
mProxyInfo
=
proxyInfo
;
mEndToEndSSL
=
e2eSSL
;
mUsingConnect
=
false
;
mNPNToken
=
npnToken
;
mOriginAttributes
=
originAttributes
;
mTlsFlags
=
0x0
;
mUsingHttpsProxy
=
(
proxyInfo
&
&
proxyInfo
-
>
IsHTTPS
(
)
)
;
mUsingHttpProxy
=
mUsingHttpsProxy
|
|
(
proxyInfo
&
&
proxyInfo
-
>
IsHTTP
(
)
)
;
if
(
mUsingHttpProxy
)
{
mUsingConnect
=
mEndToEndSSL
;
uint32_t
resolveFlags
=
0
;
if
(
NS_SUCCEEDED
(
mProxyInfo
-
>
GetResolveFlags
(
&
resolveFlags
)
)
&
&
resolveFlags
&
nsIProtocolProxyService
:
:
RESOLVE_ALWAYS_TUNNEL
)
{
mUsingConnect
=
true
;
}
}
SetOriginServer
(
host
port
)
;
}
void
nsHttpConnectionInfo
:
:
BuildHashKey
(
)
{
const
char
*
keyHost
;
int32_t
keyPort
;
if
(
mUsingHttpProxy
&
&
!
mUsingConnect
)
{
keyHost
=
ProxyHost
(
)
;
keyPort
=
ProxyPort
(
)
;
}
else
{
keyHost
=
Origin
(
)
;
keyPort
=
OriginPort
(
)
;
}
mHashKey
.
AssignLiteral
(
"
.
.
.
.
.
.
.
[
tlsflags0x00000000
]
"
)
;
mHashKey
.
Append
(
keyHost
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
AppendInt
(
keyPort
)
;
if
(
!
mUsername
.
IsEmpty
(
)
)
{
mHashKey
.
Append
(
'
[
'
)
;
mHashKey
.
Append
(
mUsername
)
;
mHashKey
.
Append
(
'
]
'
)
;
}
if
(
mUsingHttpsProxy
)
{
mHashKey
.
SetCharAt
(
'
T
'
0
)
;
}
else
if
(
mUsingHttpProxy
)
{
mHashKey
.
SetCharAt
(
'
P
'
0
)
;
}
if
(
mEndToEndSSL
)
{
mHashKey
.
SetCharAt
(
'
S
'
1
)
;
}
if
(
(
!
mUsingHttpProxy
&
&
ProxyHost
(
)
)
|
|
(
mUsingHttpProxy
&
&
mUsingConnect
)
)
{
mHashKey
.
AppendLiteral
(
"
(
"
)
;
mHashKey
.
Append
(
ProxyType
(
)
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
Append
(
ProxyHost
(
)
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
AppendInt
(
ProxyPort
(
)
)
;
mHashKey
.
Append
(
'
)
'
)
;
mHashKey
.
Append
(
'
[
'
)
;
mHashKey
.
Append
(
ProxyUsername
(
)
)
;
mHashKey
.
Append
(
'
:
'
)
;
const
char
*
password
=
ProxyPassword
(
)
;
if
(
strlen
(
password
)
>
0
)
{
nsAutoCString
digestedPassword
;
nsresult
rv
=
SHA256
(
password
digestedPassword
)
;
if
(
rv
=
=
NS_OK
)
{
mHashKey
.
Append
(
digestedPassword
)
;
}
}
mHashKey
.
Append
(
'
]
'
)
;
}
if
(
!
mRoutedHost
.
IsEmpty
(
)
)
{
mHashKey
.
AppendLiteral
(
"
<
ROUTE
-
via
"
)
;
mHashKey
.
Append
(
mRoutedHost
)
;
mHashKey
.
Append
(
'
:
'
)
;
mHashKey
.
AppendInt
(
mRoutedPort
)
;
mHashKey
.
Append
(
'
>
'
)
;
}
if
(
!
mNPNToken
.
IsEmpty
(
)
)
{
mHashKey
.
AppendLiteral
(
"
{
NPN
-
TOKEN
"
)
;
mHashKey
.
Append
(
mNPNToken
)
;
mHashKey
.
AppendLiteral
(
"
}
"
)
;
}
nsAutoCString
originAttributes
;
mOriginAttributes
.
CreateSuffix
(
originAttributes
)
;
mHashKey
.
Append
(
originAttributes
)
;
}
void
nsHttpConnectionInfo
:
:
SetOriginServer
(
const
nsACString
&
host
int32_t
port
)
{
mOrigin
=
host
;
mOriginPort
=
port
=
=
-
1
?
DefaultPort
(
)
:
port
;
BuildHashKey
(
)
;
}
nsHttpConnectionInfo
*
nsHttpConnectionInfo
:
:
Clone
(
)
const
{
nsHttpConnectionInfo
*
clone
;
if
(
mRoutedHost
.
IsEmpty
(
)
)
{
clone
=
new
nsHttpConnectionInfo
(
mOrigin
mOriginPort
mNPNToken
mUsername
mProxyInfo
mOriginAttributes
mEndToEndSSL
)
;
}
else
{
MOZ_ASSERT
(
mEndToEndSSL
)
;
clone
=
new
nsHttpConnectionInfo
(
mOrigin
mOriginPort
mNPNToken
mUsername
mProxyInfo
mOriginAttributes
mRoutedHost
mRoutedPort
)
;
}
clone
-
>
SetAnonymous
(
GetAnonymous
(
)
)
;
clone
-
>
SetPrivate
(
GetPrivate
(
)
)
;
clone
-
>
SetInsecureScheme
(
GetInsecureScheme
(
)
)
;
clone
-
>
SetNoSpdy
(
GetNoSpdy
(
)
)
;
clone
-
>
SetBeConservative
(
GetBeConservative
(
)
)
;
clone
-
>
SetTlsFlags
(
GetTlsFlags
(
)
)
;
MOZ_ASSERT
(
clone
-
>
Equals
(
this
)
)
;
return
clone
;
}
void
nsHttpConnectionInfo
:
:
CloneAsDirectRoute
(
nsHttpConnectionInfo
*
*
outCI
)
{
if
(
mRoutedHost
.
IsEmpty
(
)
)
{
*
outCI
=
Clone
(
)
;
return
;
}
RefPtr
<
nsHttpConnectionInfo
>
clone
=
new
nsHttpConnectionInfo
(
mOrigin
mOriginPort
EmptyCString
(
)
mUsername
mProxyInfo
mOriginAttributes
mEndToEndSSL
)
;
clone
-
>
SetAnonymous
(
GetAnonymous
(
)
)
;
clone
-
>
SetPrivate
(
GetPrivate
(
)
)
;
clone
-
>
SetInsecureScheme
(
GetInsecureScheme
(
)
)
;
clone
-
>
SetNoSpdy
(
GetNoSpdy
(
)
)
;
clone
-
>
SetBeConservative
(
GetBeConservative
(
)
)
;
clone
-
>
SetTlsFlags
(
GetTlsFlags
(
)
)
;
clone
.
forget
(
outCI
)
;
}
nsresult
nsHttpConnectionInfo
:
:
CreateWildCard
(
nsHttpConnectionInfo
*
*
outParam
)
{
if
(
!
mUsingHttpsProxy
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
RefPtr
<
nsHttpConnectionInfo
>
clone
;
clone
=
new
nsHttpConnectionInfo
(
NS_LITERAL_CSTRING
(
"
*
"
)
0
mNPNToken
mUsername
mProxyInfo
mOriginAttributes
true
)
;
clone
-
>
SetAnonymous
(
GetAnonymous
(
)
)
;
clone
-
>
SetPrivate
(
GetPrivate
(
)
)
;
clone
.
forget
(
outParam
)
;
return
NS_OK
;
}
void
nsHttpConnectionInfo
:
:
SetTlsFlags
(
uint32_t
aTlsFlags
)
{
mTlsFlags
=
aTlsFlags
;
mHashKey
.
Replace
(
18
8
nsPrintfCString
(
"
%
08x
"
mTlsFlags
)
)
;
}
bool
nsHttpConnectionInfo
:
:
UsingProxy
(
)
{
if
(
!
mProxyInfo
)
return
false
;
return
!
mProxyInfo
-
>
IsDirect
(
)
;
}
bool
nsHttpConnectionInfo
:
:
HostIsLocalIPLiteral
(
)
const
{
PRNetAddr
prAddr
;
if
(
ProxyHost
(
)
)
{
if
(
PR_StringToNetAddr
(
ProxyHost
(
)
&
prAddr
)
!
=
PR_SUCCESS
)
{
return
false
;
}
}
else
if
(
PR_StringToNetAddr
(
Origin
(
)
&
prAddr
)
!
=
PR_SUCCESS
)
{
return
false
;
}
NetAddr
netAddr
;
PRNetAddrToNetAddr
(
&
prAddr
&
netAddr
)
;
return
IsIPAddrLocal
(
&
netAddr
)
;
}
}
}
