#
ifndef
mozilla_net_Http2Stream_h
#
define
mozilla_net_Http2Stream_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsAHttpTransaction
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
SimpleBuffer
.
h
"
#
include
"
nsISupportsImpl
.
h
"
class
nsIInputStream
;
class
nsIOutputStream
;
namespace
mozilla
{
class
OriginAttributes
;
}
namespace
mozilla
{
namespace
net
{
class
nsStandardURL
;
class
Http2Session
;
class
Http2Decompressor
;
class
Http2Stream
:
public
nsAHttpSegmentReader
public
nsAHttpSegmentWriter
public
SupportsWeakPtr
{
public
:
NS_DECL_NSAHTTPSEGMENTREADER
NS_DECL_NSAHTTPSEGMENTWRITER
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Http2Stream
override
)
enum
stateType
{
IDLE
RESERVED_BY_REMOTE
OPEN
CLOSED_BY_LOCAL
CLOSED_BY_REMOTE
CLOSED
}
;
const
static
int32_t
kNormalPriority
=
0x1000
;
const
static
int32_t
kWorstPriority
=
kNormalPriority
+
nsISupportsPriority
:
:
PRIORITY_LOWEST
;
const
static
int32_t
kBestPriority
=
kNormalPriority
+
nsISupportsPriority
:
:
PRIORITY_HIGHEST
;
Http2Stream
(
nsAHttpTransaction
*
Http2Session
*
int32_t
uint64_t
)
;
uint32_t
StreamID
(
)
{
return
mStreamID
;
}
Http2PushedStream
*
PushSource
(
)
{
return
mPushSource
;
}
void
ClearPushSource
(
)
;
stateType
HTTPState
(
)
{
return
mState
;
}
void
SetHTTPState
(
stateType
val
)
{
mState
=
val
;
}
[
[
nodiscard
]
]
virtual
nsresult
ReadSegments
(
nsAHttpSegmentReader
*
uint32_t
uint32_t
*
)
;
[
[
nodiscard
]
]
virtual
nsresult
WriteSegments
(
nsAHttpSegmentWriter
*
uint32_t
uint32_t
*
)
;
virtual
bool
DeferCleanup
(
nsresult
status
)
;
virtual
Http2Stream
*
GetConsumerStream
(
)
{
return
nullptr
;
}
;
const
nsCString
&
Origin
(
)
const
{
return
mOrigin
;
}
const
nsCString
&
Host
(
)
const
{
return
mHeaderHost
;
}
const
nsCString
&
Path
(
)
const
{
return
mHeaderPath
;
}
bool
RequestBlockedOnRead
(
)
{
return
static_cast
<
bool
>
(
mRequestBlockedOnRead
)
;
}
bool
HasRegisteredID
(
)
{
return
mStreamID
!
=
0
;
}
nsAHttpTransaction
*
Transaction
(
)
{
return
mTransaction
;
}
virtual
nsIRequestContext
*
RequestContext
(
)
{
return
mTransaction
?
mTransaction
-
>
RequestContext
(
)
:
nullptr
;
}
void
Close
(
nsresult
reason
)
;
void
SetResponseIsComplete
(
)
;
void
SetRecvdFin
(
bool
aStatus
)
;
bool
RecvdFin
(
)
{
return
mRecvdFin
;
}
void
SetRecvdData
(
bool
aStatus
)
{
mReceivedData
=
aStatus
?
1
:
0
;
}
bool
RecvdData
(
)
{
return
mReceivedData
;
}
void
SetSentFin
(
bool
aStatus
)
;
bool
SentFin
(
)
{
return
mSentFin
;
}
void
SetRecvdReset
(
bool
aStatus
)
;
bool
RecvdReset
(
)
{
return
mRecvdReset
;
}
void
SetSentReset
(
bool
aStatus
)
;
bool
SentReset
(
)
{
return
mSentReset
;
}
void
SetQueued
(
bool
aStatus
)
{
mQueued
=
aStatus
?
1
:
0
;
}
bool
Queued
(
)
{
return
mQueued
;
}
void
SetCountAsActive
(
bool
aStatus
)
{
mCountAsActive
=
aStatus
?
1
:
0
;
}
bool
CountAsActive
(
)
{
return
mCountAsActive
;
}
void
SetAllHeadersReceived
(
)
;
void
UnsetAllHeadersReceived
(
)
{
mAllHeadersReceived
=
0
;
}
bool
AllHeadersReceived
(
)
{
return
mAllHeadersReceived
;
}
void
UpdateTransportSendEvents
(
uint32_t
count
)
;
void
UpdateTransportReadEvents
(
uint32_t
count
)
;
[
[
nodiscard
]
]
nsresult
ConvertResponseHeaders
(
Http2Decompressor
*
nsACString
&
nsACString
&
int32_t
&
)
;
[
[
nodiscard
]
]
nsresult
ConvertPushHeaders
(
Http2Decompressor
*
nsACString
&
nsACString
&
)
;
[
[
nodiscard
]
]
nsresult
ConvertResponseTrailers
(
Http2Decompressor
*
nsACString
&
)
;
bool
AllowFlowControlledWrite
(
)
;
void
UpdateServerReceiveWindow
(
int32_t
delta
)
;
int64_t
ServerReceiveWindow
(
)
{
return
mServerReceiveWindow
;
}
void
DecrementClientReceiveWindow
(
uint32_t
delta
)
{
mClientReceiveWindow
-
=
delta
;
mLocalUnacked
+
=
delta
;
}
void
IncrementClientReceiveWindow
(
uint32_t
delta
)
{
mClientReceiveWindow
+
=
delta
;
mLocalUnacked
-
=
delta
;
}
uint64_t
LocalUnAcked
(
)
;
int64_t
ClientReceiveWindow
(
)
{
return
mClientReceiveWindow
;
}
bool
BlockedOnRwin
(
)
{
return
mBlockedOnRwin
;
}
uint32_t
Priority
(
)
{
return
mPriority
;
}
uint32_t
PriorityDependency
(
)
{
return
mPriorityDependency
;
}
uint8_t
PriorityWeight
(
)
{
return
mPriorityWeight
;
}
void
SetPriority
(
uint32_t
)
;
void
SetPriorityDependency
(
uint32_t
uint32_t
)
;
void
UpdatePriorityDependency
(
)
;
uint64_t
TransactionTabId
(
)
{
return
mTransactionTabId
;
}
virtual
bool
HasSink
(
)
{
return
true
;
}
virtual
void
SetPushComplete
(
)
{
}
;
Http2Session
*
Session
(
)
;
[
[
nodiscard
]
]
static
nsresult
MakeOriginURL
(
const
nsACString
&
origin
nsCOMPtr
<
nsIURI
>
&
url
)
;
[
[
nodiscard
]
]
static
nsresult
MakeOriginURL
(
const
nsACString
&
scheme
const
nsACString
&
origin
nsCOMPtr
<
nsIURI
>
&
url
)
;
bool
Do0RTT
(
)
;
nsresult
Finish0RTT
(
bool
aRestart
bool
aAlpnChanged
)
;
nsresult
GetOriginAttributes
(
mozilla
:
:
OriginAttributes
*
oa
)
;
virtual
void
TopBrowsingContextIdChanged
(
uint64_t
id
)
;
void
TopBrowsingContextIdChangedInternal
(
uint64_t
id
)
;
protected
:
virtual
~
Http2Stream
(
)
;
static
void
CreatePushHashKey
(
const
nsCString
&
scheme
const
nsCString
&
hostHeader
const
mozilla
:
:
OriginAttributes
&
originAttributes
uint64_t
serial
const
nsACString
&
pathInfo
nsCString
&
outOrigin
nsCString
&
outKey
)
;
enum
upstreamStateType
{
GENERATING_HEADERS
GENERATING_BODY
SENDING_BODY
SENDING_FIN_STREAM
UPSTREAM_COMPLETE
}
;
uint32_t
mStreamID
;
nsWeakPtr
mSession
;
RefPtr
<
nsAHttpSegmentReader
>
mSegmentReader
;
nsAHttpSegmentWriter
*
mSegmentWriter
;
nsCString
mOrigin
;
nsCString
mHeaderHost
;
nsCString
mHeaderScheme
;
nsCString
mHeaderPath
;
enum
upstreamStateType
mUpstreamState
;
enum
stateType
mState
;
uint32_t
mRequestHeadersDone
:
1
;
uint32_t
mOpenGenerated
:
1
;
uint32_t
mAllHeadersReceived
:
1
;
uint32_t
mQueued
:
1
;
void
ChangeState
(
enum
upstreamStateType
)
;
virtual
void
AdjustInitialWindow
(
)
;
[
[
nodiscard
]
]
nsresult
TransmitFrame
(
const
char
*
uint32_t
*
bool
forceCommitment
)
;
nsISocketTransport
*
mSocketTransport
;
uint8_t
mPriorityWeight
=
0
;
uint32_t
mPriorityDependency
=
0
;
uint64_t
mCurrentTopBrowsingContextId
;
uint64_t
mTransactionTabId
;
private
:
friend
class
mozilla
:
:
DefaultDelete
<
Http2Stream
>
;
[
[
nodiscard
]
]
nsresult
ParseHttpRequestHeaders
(
const
char
*
uint32_t
uint32_t
*
)
;
[
[
nodiscard
]
]
nsresult
GenerateOpen
(
)
;
void
AdjustPushedPriority
(
)
;
void
GenerateDataFrameHeader
(
uint32_t
bool
)
;
[
[
nodiscard
]
]
nsresult
BufferInput
(
uint32_t
uint32_t
*
)
;
RefPtr
<
nsAHttpTransaction
>
mTransaction
;
uint32_t
mChunkSize
;
uint32_t
mRequestBlockedOnRead
:
1
;
uint32_t
mRecvdFin
:
1
;
uint32_t
mReceivedData
:
1
;
uint32_t
mRecvdReset
:
1
;
uint32_t
mSentReset
:
1
;
uint32_t
mCountAsActive
:
1
;
uint32_t
mSentFin
:
1
;
uint32_t
mSentWaitingFor
:
1
;
uint32_t
mSetTCPSocketBuffer
:
1
;
uint32_t
mBypassInputBuffer
:
1
;
UniquePtr
<
uint8_t
[
]
>
mTxInlineFrame
;
uint32_t
mTxInlineFrameSize
;
uint32_t
mTxInlineFrameUsed
;
uint32_t
mTxStreamFrameSize
;
nsCString
mFlatHttpRequestHeaders
;
int64_t
mRequestBodyLenRemaining
;
uint32_t
mPriority
=
0
;
int64_t
mClientReceiveWindow
;
int64_t
mServerReceiveWindow
;
uint64_t
mLocalUnacked
;
bool
mBlockedOnRwin
;
uint64_t
mTotalSent
;
uint64_t
mTotalRead
;
Http2PushedStream
*
mPushSource
;
SimpleBuffer
mSimpleBuffer
;
bool
mAttempting0RTT
;
public
:
bool
IsTunnel
(
)
{
return
mIsTunnel
;
}
nsCString
&
RegistrationKey
(
)
;
private
:
void
ClearTransactionsBlockedOnTunnel
(
)
;
void
MapStreamToPlainText
(
)
;
bool
MapStreamToHttpConnection
(
const
nsACString
&
aFlat407Headers
int32_t
aHttpResponseCode
=
-
1
)
;
bool
mIsTunnel
;
bool
mPlainTextTunnel
;
nsCString
mRegistrationKey
;
public
:
bool
IsWebsocket
(
)
{
return
mIsWebsocket
;
}
private
:
bool
mIsWebsocket
;
}
;
}
}
#
endif
