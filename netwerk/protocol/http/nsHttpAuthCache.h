#
ifndef
nsHttpAuthCache_h__
#
define
nsHttpAuthCache_h__
#
include
"
nsError
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsIHttpAuthCache
.
h
"
#
include
"
nsIObserver
.
h
"
namespace
mozilla
{
class
OriginAttributesPattern
;
namespace
net
{
class
nsHttpAuthIdentity
{
public
:
nsHttpAuthIdentity
(
)
=
default
;
nsHttpAuthIdentity
(
const
nsAString
&
domain
const
nsAString
&
user
const
nsAString
&
password
)
:
mUser
(
user
)
mPass
(
password
)
mDomain
(
domain
)
{
}
~
nsHttpAuthIdentity
(
)
{
Clear
(
)
;
}
const
nsString
&
Domain
(
)
const
{
return
mDomain
;
}
const
nsString
&
User
(
)
const
{
return
mUser
;
}
const
nsString
&
Password
(
)
const
{
return
mPass
;
}
void
Clear
(
)
;
bool
Equals
(
const
nsHttpAuthIdentity
&
ident
)
const
;
bool
IsEmpty
(
)
const
{
return
mUser
.
IsEmpty
(
)
&
&
mPass
.
IsEmpty
(
)
&
&
mDomain
.
IsEmpty
(
)
;
}
private
:
nsString
mUser
;
nsString
mPass
;
nsString
mDomain
;
}
;
class
AuthIdentity
final
:
public
nsIHttpAuthIdentity
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIHTTPAUTHIDENTITY
explicit
AuthIdentity
(
const
nsHttpAuthIdentity
&
aIdent
)
:
mIdent
(
aIdent
)
{
}
private
:
virtual
~
AuthIdentity
(
)
=
default
;
nsHttpAuthIdentity
mIdent
;
}
;
class
nsHttpAuthEntry
:
public
nsIHttpAuthEntry
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIHTTPAUTHENTRY
nsHttpAuthEntry
(
const
nsACString
&
path
const
nsACString
&
realm
const
nsACString
&
creds
const
nsACString
&
challenge
const
nsHttpAuthIdentity
*
ident
nsISupports
*
metadata
)
{
DebugOnly
<
nsresult
>
rv
=
Set
(
path
realm
creds
challenge
ident
metadata
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
const
nsCString
&
Realm
(
)
const
{
return
mRealm
;
}
const
nsCString
&
Creds
(
)
const
{
return
mCreds
;
}
const
nsCString
&
Challenge
(
)
const
{
return
mChallenge
;
}
const
nsString
&
Domain
(
)
const
{
return
mIdent
.
Domain
(
)
;
}
const
nsString
&
User
(
)
const
{
return
mIdent
.
User
(
)
;
}
const
nsString
&
Pass
(
)
const
{
return
mIdent
.
Password
(
)
;
}
const
nsHttpAuthIdentity
&
Identity
(
)
const
{
return
mIdent
;
}
[
[
nodiscard
]
]
nsresult
AddPath
(
const
nsACString
&
aPath
)
;
nsCOMPtr
<
nsISupports
>
mMetaData
;
private
:
virtual
~
nsHttpAuthEntry
(
)
=
default
;
[
[
nodiscard
]
]
nsresult
Set
(
const
nsACString
&
path
const
nsACString
&
realm
const
nsACString
&
creds
const
nsACString
&
challenge
const
nsHttpAuthIdentity
*
ident
nsISupports
*
metadata
)
;
nsHttpAuthIdentity
mIdent
;
nsTArray
<
nsCString
>
mPaths
;
nsCString
mRealm
;
nsCString
mCreds
;
nsCString
mChallenge
;
friend
class
nsHttpAuthNode
;
friend
class
nsHttpAuthCache
;
friend
mozilla
:
:
DefaultDelete
<
nsHttpAuthEntry
>
;
}
;
class
nsHttpAuthNode
{
private
:
using
EntryList
=
nsTArray
<
RefPtr
<
nsHttpAuthEntry
>
>
;
nsHttpAuthNode
(
)
;
~
nsHttpAuthNode
(
)
;
nsHttpAuthEntry
*
LookupEntryByPath
(
const
nsACString
&
path
)
;
nsHttpAuthEntry
*
LookupEntryByRealm
(
const
nsACString
&
realm
)
;
EntryList
:
:
const_iterator
LookupEntryItrByRealm
(
const
nsACString
&
realm
)
const
;
[
[
nodiscard
]
]
nsresult
SetAuthEntry
(
const
nsACString
&
path
const
nsACString
&
realm
const
nsACString
&
creds
const
nsACString
&
challenge
const
nsHttpAuthIdentity
*
ident
nsISupports
*
metadata
)
;
void
ClearAuthEntry
(
const
nsACString
&
realm
)
;
uint32_t
EntryCount
(
)
{
return
mList
.
Length
(
)
;
}
private
:
EntryList
mList
;
friend
class
nsHttpAuthCache
;
friend
mozilla
:
:
DefaultDelete
<
nsHttpAuthNode
>
;
}
;
class
nsHttpAuthCache
:
public
nsIHttpAuthCache
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIHTTPAUTHCACHE
NS_DECL_NSIOBSERVER
nsHttpAuthCache
(
)
;
[
[
nodiscard
]
]
nsresult
GetAuthEntryForPath
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
const
nsACString
&
path
nsACString
const
&
originSuffix
RefPtr
<
nsHttpAuthEntry
>
&
entry
)
;
[
[
nodiscard
]
]
nsresult
GetAuthEntryForDomain
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
const
nsACString
&
realm
nsACString
const
&
originSuffix
RefPtr
<
nsHttpAuthEntry
>
&
entry
)
;
[
[
nodiscard
]
]
nsresult
SetAuthEntry
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
const
nsACString
&
path
const
nsACString
&
realm
const
nsACString
&
creds
const
nsACString
&
challenge
nsACString
const
&
originSuffix
const
nsHttpAuthIdentity
*
ident
nsISupports
*
metadata
)
;
void
ClearAuthEntry
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
const
nsACString
&
realm
nsACString
const
&
originSuffix
)
;
void
ClearAll
(
)
;
void
CollectKeys
(
nsTArray
<
nsCString
>
&
aValue
)
;
private
:
nsHttpAuthNode
*
LookupAuthNode
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
nsACString
const
&
originSuffix
nsCString
&
key
)
;
void
ClearOriginData
(
OriginAttributesPattern
const
&
pattern
)
;
private
:
virtual
~
nsHttpAuthCache
(
)
;
using
AuthNodeTable
=
nsClassHashtable
<
nsCStringHashKey
nsHttpAuthNode
>
;
AuthNodeTable
mDB
;
}
;
}
}
#
endif
