#
ifndef
nsHttpConnection_h__
#
define
nsHttpConnection_h__
#
include
<
functional
>
#
include
"
HttpConnectionBase
.
h
"
#
include
"
nsHttpConnectionInfo
.
h
"
#
include
"
nsHttpResponseHead
.
h
"
#
include
"
nsAHttpTransaction
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
TunnelUtils
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
ARefBase
.
h
"
#
include
"
TimingStruct
.
h
"
#
include
"
HttpTrafficAnalyzer
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsITlsHandshakeListener
.
h
"
class
nsISocketTransport
;
class
nsISSLSocketControl
;
namespace
mozilla
{
namespace
net
{
class
nsHttpHandler
;
class
ASpdySession
;
#
define
NS_HTTPCONNECTION_IID
\
{
\
0x1dcc863e
0xdb90
0x4652
{
\
0xa1
0xfe
0x13
0xfe
0xa0
0xb5
0x4e
0x46
\
}
\
}
class
nsHttpConnection
final
:
public
HttpConnectionBase
public
nsAHttpSegmentReader
public
nsAHttpSegmentWriter
public
nsIInputStreamCallback
public
nsIOutputStreamCallback
public
nsITransportEventSink
public
nsIInterfaceRequestor
public
nsITlsHandshakeCallbackListener
public
NudgeTunnelCallback
{
private
:
virtual
~
nsHttpConnection
(
)
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_HTTPCONNECTION_IID
)
NS_DECL_HTTPCONNECTIONBASE
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSAHTTPSEGMENTREADER
NS_DECL_NSAHTTPSEGMENTWRITER
NS_DECL_NSIINPUTSTREAMCALLBACK
NS_DECL_NSIOUTPUTSTREAMCALLBACK
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSITLSHANDSHAKECALLBACKLISTENER
NS_DECL_NUDGETUNNELCALLBACK
nsHttpConnection
(
)
;
[
[
nodiscard
]
]
virtual
nsresult
Init
(
nsHttpConnectionInfo
*
info
uint16_t
maxHangTime
nsISocketTransport
*
nsIAsyncInputStream
*
nsIAsyncOutputStream
*
bool
connectedTransport
nsresult
status
nsIInterfaceRequestor
*
PRIntervalTime
bool
forWebSocket
)
;
bool
IsKeepAlive
(
)
{
return
(
mUsingSpdyVersion
!
=
SpdyVersion
:
:
NONE
)
|
|
(
mKeepAliveMask
&
&
mKeepAlive
)
;
}
uint32_t
TimeToLive
(
)
;
bool
NeedSpdyTunnel
(
)
{
return
mConnInfo
-
>
UsingHttpsProxy
(
)
&
&
!
mTLSFilter
&
&
mConnInfo
-
>
UsingConnect
(
)
;
}
void
ForcePlainText
(
)
{
mForcePlainText
=
true
;
}
bool
IsUrgentStartPreferred
(
)
const
{
return
mUrgentStartPreferredKnown
&
&
mUrgentStartPreferred
;
}
void
SetUrgentStartPreferred
(
bool
urgent
)
;
void
SetIsReusedAfter
(
uint32_t
afterMilliseconds
)
;
int64_t
MaxBytesRead
(
)
{
return
mMaxBytesRead
;
}
HttpVersion
GetLastHttpResponseVersion
(
)
{
return
mLastHttpResponseVersion
;
}
friend
class
HttpConnectionForceIO
;
void
BeginIdleMonitoring
(
)
;
void
EndIdleMonitoring
(
)
;
bool
UsingSpdy
(
)
override
{
return
(
mUsingSpdyVersion
!
=
SpdyVersion
:
:
NONE
)
;
}
SpdyVersion
GetSpdyVersion
(
)
{
return
mUsingSpdyVersion
;
}
bool
EverUsedSpdy
(
)
{
return
mEverUsedSpdy
;
}
bool
UsingHttp3
(
)
override
{
return
false
;
}
bool
ReportedNPN
(
)
{
return
mReportedSpdy
;
}
uint32_t
ReadTimeoutTick
(
PRIntervalTime
now
)
;
static
void
UpdateTCPKeepalive
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
ReadTimeoutTick
(
)
;
int64_t
ContentBytesWritten
(
)
{
return
mContentBytesWritten
;
}
void
SetupSecondaryTLS
(
nsAHttpTransaction
*
aSpdyConnectTransaction
=
nullptr
)
;
void
SetInSpdyTunnel
(
bool
arg
)
;
void
CheckForTraffic
(
bool
check
)
;
bool
NoTraffic
(
)
{
return
mTrafficStamp
&
&
(
mTrafficCount
=
=
(
mTotalBytesWritten
+
mTotalBytesRead
)
)
;
}
bool
NoClientCertAuth
(
)
const
override
;
bool
CanAcceptWebsocket
(
)
override
;
int64_t
BytesWritten
(
)
override
{
return
mTotalBytesWritten
;
}
nsISocketTransport
*
Transport
(
)
override
{
return
mSocketTransport
;
}
nsresult
GetSelfAddr
(
NetAddr
*
addr
)
override
;
nsresult
GetPeerAddr
(
NetAddr
*
addr
)
override
;
bool
ResolvedByTRR
(
)
override
;
bool
GetEchConfigUsed
(
)
override
;
bool
IsForWebSocket
(
)
{
return
mForWebSocket
;
}
[
[
nodiscard
]
]
static
nsresult
MakeConnectString
(
nsAHttpTransaction
*
trans
nsHttpRequestHead
*
request
nsACString
&
result
bool
h2ws
)
;
[
[
nodiscard
]
]
static
nsresult
ReadFromStream
(
nsIInputStream
*
void
*
const
char
*
uint32_t
uint32_t
uint32_t
*
)
;
private
:
enum
HttpConnectionState
{
UNINITIALIZED
SETTING_UP_TUNNEL
TUNNEL_DONE
TUNNEL_NOT_USED
}
mState
{
HttpConnectionState
:
:
UNINITIALIZED
}
;
void
ChangeState
(
HttpConnectionState
newState
)
;
bool
TunnelSetupInProgress
(
)
{
return
mState
=
=
SETTING_UP_TUNNEL
;
}
bool
TunnelUsed
(
)
{
return
mState
=
=
SETTING_UP_TUNNEL
|
|
mState
=
=
TUNNEL_DONE
;
}
bool
TunnelCompleted
(
)
{
return
mState
=
=
TUNNEL_DONE
;
}
void
SetTunnelSetupDone
(
)
;
nsresult
CheckTunnelIsNeeded
(
)
;
nsresult
SetupProxyConnectStream
(
)
;
nsresult
SendConnectRequest
(
void
*
closure
uint32_t
*
transactionBytes
)
;
void
HandleTunnelResponse
(
uint16_t
responseStatus
bool
*
reset
)
;
void
HandleWebSocketResponse
(
nsHttpRequestHead
*
requestHead
nsHttpResponseHead
*
responseHead
uint16_t
responseStatus
)
;
enum
TCPKeepaliveConfig
{
kTCPKeepaliveDisabled
=
0
kTCPKeepaliveShortLivedConfig
kTCPKeepaliveLongLivedConfig
}
;
[
[
nodiscard
]
]
nsresult
InitSSLParams
(
bool
connectingToProxy
bool
ProxyStartSSL
)
;
[
[
nodiscard
]
]
nsresult
SetupNPNList
(
nsISSLSocketControl
*
ssl
uint32_t
caps
)
;
[
[
nodiscard
]
]
nsresult
OnTransactionDone
(
nsresult
reason
)
;
[
[
nodiscard
]
]
nsresult
OnSocketWritable
(
)
;
[
[
nodiscard
]
]
nsresult
OnSocketReadable
(
)
;
PRIntervalTime
IdleTime
(
)
;
bool
IsAlive
(
)
;
[
[
nodiscard
]
]
bool
EnsureNPNComplete
(
)
;
void
SetupSSL
(
)
;
void
StartSpdy
(
nsISSLSocketControl
*
ssl
SpdyVersion
spdyVersion
)
;
void
Start0RTTSpdy
(
SpdyVersion
spdyVersion
)
;
nsresult
TryTakeSubTransactions
(
nsTArray
<
RefPtr
<
nsAHttpTransaction
>
>
&
list
)
;
nsresult
MoveTransactionsToSpdy
(
nsresult
status
nsTArray
<
RefPtr
<
nsAHttpTransaction
>
>
&
list
)
;
[
[
nodiscard
]
]
nsresult
AddTransaction
(
nsAHttpTransaction
*
int32_t
)
;
[
[
nodiscard
]
]
nsresult
StartShortLivedTCPKeepalives
(
)
;
[
[
nodiscard
]
]
nsresult
StartLongLivedTCPKeepalives
(
)
;
[
[
nodiscard
]
]
nsresult
DisableTCPKeepalives
(
)
;
bool
CheckCanWrite0RTTData
(
)
;
void
Check0RttEnabled
(
nsISSLSocketControl
*
ssl
)
;
void
EarlyDataTelemetry
(
int16_t
tlsVersion
bool
earlyDataAccepted
)
;
void
FinishNPNSetup
(
bool
handshakeSucceeded
bool
hasSecurityInfo
)
;
void
Reset0RttForSpdy
(
)
;
void
HandshakeDoneInternal
(
)
;
private
:
RefPtr
<
nsAHttpTransaction
>
mTransaction
;
nsCOMPtr
<
nsIAsyncInputStream
>
mSocketIn
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mSocketOut
;
nsresult
mSocketInCondition
{
NS_ERROR_NOT_INITIALIZED
}
;
nsresult
mSocketOutCondition
{
NS_ERROR_NOT_INITIALIZED
}
;
RefPtr
<
TLSFilterTransaction
>
mTLSFilter
;
nsWeakPtr
mWeakTrans
;
RefPtr
<
nsHttpHandler
>
mHttpHandler
;
PRIntervalTime
mLastReadTime
{
0
}
;
PRIntervalTime
mLastWriteTime
{
0
}
;
PRIntervalTime
mMaxHangTime
{
0
}
;
PRIntervalTime
mIdleTimeout
;
PRIntervalTime
mConsiderReusedAfterInterval
{
0
}
;
PRIntervalTime
mConsiderReusedAfterEpoch
{
0
}
;
int64_t
mCurrentBytesRead
{
0
}
;
int64_t
mMaxBytesRead
{
0
}
;
int64_t
mTotalBytesRead
{
0
}
;
int64_t
mContentBytesWritten
{
0
}
;
RefPtr
<
nsIAsyncInputStream
>
mInputOverflow
;
bool
mUrgentStartPreferred
{
false
}
;
bool
mUrgentStartPreferredKnown
{
false
}
;
bool
mConnectedTransport
{
false
}
;
bool
mKeepAlive
{
true
}
;
bool
mKeepAliveMask
{
true
}
;
bool
mDontReuse
{
false
}
;
bool
mIsReused
{
false
}
;
bool
mLastTransactionExpectedNoContent
{
false
}
;
bool
mIdleMonitoring
{
false
}
;
bool
mInSpdyTunnel
{
false
}
;
bool
mForcePlainText
{
false
}
;
int64_t
mTrafficCount
{
0
}
;
bool
mTrafficStamp
{
false
}
;
uint32_t
mHttp1xTransactionCount
{
0
}
;
uint32_t
mRemainingConnectionUses
{
0xffffffff
}
;
bool
mNPNComplete
{
false
}
;
bool
mSetupSSLCalled
{
false
}
;
SpdyVersion
mUsingSpdyVersion
{
SpdyVersion
:
:
NONE
}
;
RefPtr
<
ASpdySession
>
mSpdySession
;
int32_t
mPriority
{
nsISupportsPriority
:
:
PRIORITY_NORMAL
}
;
bool
mReportedSpdy
{
false
}
;
bool
mEverUsedSpdy
{
false
}
;
HttpVersion
mLastHttpResponseVersion
{
HttpVersion
:
:
v1_1
}
;
uint32_t
mDefaultTimeoutFactor
{
1
}
;
bool
mResponseTimeoutEnabled
{
false
}
;
uint32_t
mTCPKeepaliveConfig
{
kTCPKeepaliveDisabled
}
;
nsCOMPtr
<
nsITimer
>
mTCPKeepaliveTransitionTimer
;
private
:
static
void
ForceSendIO
(
nsITimer
*
aTimer
void
*
aClosure
)
;
[
[
nodiscard
]
]
nsresult
MaybeForceSendIO
(
)
;
bool
mForceSendPending
{
false
}
;
nsCOMPtr
<
nsITimer
>
mForceSendTimer
;
bool
m0RTTChecked
{
false
}
;
enum
EarlyData
{
NOT_AVAILABLE
USED
CANNOT_BE_USED
DONE_NOT_AVAILABLE
DONE_USED
DONE_CANNOT_BE_USED
}
;
EarlyData
mEarlyDataState
{
EarlyData
:
:
NOT_AVAILABLE
}
;
bool
EarlyDataAvailable
(
)
const
{
return
mEarlyDataState
=
=
EarlyData
:
:
USED
|
|
mEarlyDataState
=
=
EarlyData
:
:
CANNOT_BE_USED
;
}
bool
EarlyDataWasAvailable
(
)
const
{
return
mEarlyDataState
!
=
EarlyData
:
:
NOT_AVAILABLE
&
&
mEarlyDataState
!
=
EarlyData
:
:
DONE_NOT_AVAILABLE
;
}
bool
EarlyDataUsed
(
)
const
{
return
mEarlyDataState
=
=
EarlyData
:
:
USED
;
}
void
EarlyDataDone
(
)
;
int64_t
mContentBytesWritten0RTT
{
0
}
;
nsCString
mEarlyNegotiatedALPN
;
bool
mDid0RTTSpdy
{
false
}
;
bool
mTlsHandshakeComplitionPending
{
false
}
;
nsresult
mErrorBeforeConnect
=
NS_OK
;
nsCOMPtr
<
nsISocketTransport
>
mSocketTransport
;
bool
mForWebSocket
{
false
}
;
std
:
:
function
<
void
(
)
>
mContinueHandshakeDone
{
nullptr
}
;
private
:
bool
mThroughCaptivePortal
;
int64_t
mTotalBytesWritten
=
0
;
nsCOMPtr
<
nsIInputStream
>
mProxyConnectStream
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsHttpConnection
NS_HTTPCONNECTION_IID
)
}
}
#
endif
