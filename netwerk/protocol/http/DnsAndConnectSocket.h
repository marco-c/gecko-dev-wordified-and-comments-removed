#
ifndef
DnsAndConnectSocket_h__
#
define
DnsAndConnectSocket_h__
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsAHttpConnection
.
h
"
#
include
"
nsHttpConnection
.
h
"
#
include
"
nsHttpTransaction
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsICancelable
.
h
"
#
include
"
nsIDNSListener
.
h
"
#
include
"
nsIDNSRecord
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsITransport
.
h
"
#
include
"
nsWeakReference
.
h
"
namespace
mozilla
{
namespace
net
{
#
define
NS_DNSANDCONNECTSOCKET_IID
\
{
\
0x8d411b53
0x54bc
0x4a99
{
\
0x8b
0x78
0xff
0x12
0x5e
0xab
0x15
0x64
\
}
\
}
class
PendingTransactionInfo
;
class
ConnectionEntry
;
class
DnsAndConnectSocket
final
:
public
nsIOutputStreamCallback
public
nsITransportEventSink
public
nsIInterfaceRequestor
public
nsITimerCallback
public
nsINamed
public
nsSupportsWeakReference
public
nsIDNSListener
{
~
DnsAndConnectSocket
(
)
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_DNSANDCONNECTSOCKET_IID
)
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOUTPUTSTREAMCALLBACK
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
NS_DECL_NSIDNSLISTENER
DnsAndConnectSocket
(
nsHttpConnectionInfo
*
ci
nsAHttpTransaction
*
trans
uint32_t
caps
bool
speculative
bool
isFromPredictor
bool
urgentStart
)
;
[
[
nodiscard
]
]
nsresult
Init
(
ConnectionEntry
*
ent
)
;
void
Abandon
(
)
;
double
Duration
(
TimeStamp
epoch
)
;
void
CloseTransports
(
nsresult
error
)
;
bool
IsSpeculative
(
)
{
return
mSpeculative
;
}
bool
Allow1918
(
)
{
return
mAllow1918
;
}
void
SetAllow1918
(
bool
val
)
{
mAllow1918
=
val
;
}
bool
HasConnected
(
)
{
return
mHasConnected
;
}
void
PrintDiagnostics
(
nsCString
&
log
)
;
bool
AcceptsTransaction
(
nsHttpTransaction
*
trans
)
;
bool
Claim
(
)
;
void
Unclaim
(
)
;
private
:
void
CheckIsDone
(
)
;
enum
DnsAndSocketState
{
INIT
RESOLVING
CONNECTING
ONE_CONNECTED
DONE
}
mState
=
INIT
;
enum
SetupEvents
{
INIT_EVENT
RESOLVED_PRIMARY_EVENT
PRIMARY_DONE_EVENT
BACKUP_DONE_EVENT
BACKUP_TIMER_FIRED_EVENT
}
;
struct
TransportSetup
{
enum
TransportSetupState
{
INIT
RESOLVING
RESOLVED
RETRY_RESOLVING
CONNECTING
CONNECTING_DONE
DONE
}
mState
;
bool
FirstResolving
(
)
{
return
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
RESOLVING
;
}
bool
ConnectingOrRetry
(
)
{
return
(
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
CONNECTING
)
|
|
(
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
RETRY_RESOLVING
)
|
|
(
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
CONNECTING_DONE
)
;
}
bool
Resolved
(
)
{
return
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
RESOLVED
;
}
bool
DoneConnecting
(
)
{
return
(
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
CONNECTING_DONE
)
|
|
(
mState
=
=
TransportSetup
:
:
TransportSetupState
:
:
DONE
)
;
}
nsCString
mHost
;
nsCOMPtr
<
nsICancelable
>
mDNSRequest
;
nsCOMPtr
<
nsIDNSAddrRecord
>
mDNSRecord
;
uint32_t
mDnsFlags
=
0
;
bool
mRetryWithDifferentIPFamily
=
false
;
bool
mResetFamilyPreference
=
false
;
bool
mSkipDnsResolution
=
false
;
nsCOMPtr
<
nsISocketTransport
>
mSocketTransport
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mStreamOut
;
nsCOMPtr
<
nsIAsyncInputStream
>
mStreamIn
;
TimeStamp
mSynStarted
;
bool
mConnectedOK
=
false
;
bool
mIsBackup
;
bool
mWaitingForConnect
=
false
;
void
SetConnecting
(
)
;
void
MaybeSetConnectingDone
(
)
;
explicit
TransportSetup
(
bool
isBackup
)
;
nsresult
Init
(
DnsAndConnectSocket
*
dnsAndSock
)
;
void
CancelDnsResolution
(
)
;
void
Abandon
(
)
;
void
CloseAll
(
)
;
nsresult
SetupConn
(
nsAHttpTransaction
*
transaction
ConnectionEntry
*
ent
nsresult
status
uint32_t
cap
HttpConnectionBase
*
*
connection
)
;
[
[
nodiscard
]
]
nsresult
SetupStreams
(
DnsAndConnectSocket
*
dnsAndSock
)
;
nsresult
ResolveHost
(
DnsAndConnectSocket
*
dnsAndSock
)
;
bool
ShouldRetryDNS
(
)
;
nsresult
OnLookupComplete
(
DnsAndConnectSocket
*
dnsAndSock
nsIDNSRecord
*
rec
nsresult
status
)
;
nsresult
CheckConnectedResult
(
DnsAndConnectSocket
*
dnsAndSock
)
;
}
;
nsresult
SetupConn
(
bool
isPrimary
nsresult
status
)
;
void
SetupBackupTimer
(
)
;
void
CancelBackupTimer
(
)
;
bool
IsPrimary
(
nsITransport
*
trans
)
;
bool
IsPrimary
(
nsIAsyncOutputStream
*
out
)
;
bool
IsPrimary
(
nsICancelable
*
dnsRequest
)
;
bool
IsBackup
(
nsITransport
*
trans
)
;
bool
IsBackup
(
nsIAsyncOutputStream
*
out
)
;
bool
IsBackup
(
nsICancelable
*
dnsRequest
)
;
already_AddRefed
<
PendingTransactionInfo
>
FindTransactionHelper
(
bool
removeWhenFound
)
;
void
CheckProxyConfig
(
)
;
nsresult
SetupDnsFlags
(
ConnectionEntry
*
ent
)
;
nsresult
SetupEvent
(
SetupEvents
event
)
;
RefPtr
<
nsAHttpTransaction
>
mTransaction
;
bool
mDispatchedMTransaction
=
false
;
TransportSetup
mPrimaryTransport
;
uint32_t
mCaps
;
bool
mSpeculative
;
bool
mUrgentStart
;
bool
mIsFromPredictor
;
bool
mAllow1918
=
true
;
bool
mHasConnected
=
false
;
bool
mBackupConnStatsSet
=
false
;
bool
mFreeToUse
=
true
;
RefPtr
<
nsHttpConnectionInfo
>
mConnInfo
;
nsCOMPtr
<
nsITimer
>
mSynTimer
;
TransportSetup
mBackupTransport
;
bool
mIsHttp3
;
bool
mSkipDnsResolution
=
false
;
bool
mProxyNotTransparent
=
false
;
bool
mProxyTransparentResolvesHost
=
false
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
DnsAndConnectSocket
NS_DNSANDCONNECTSOCKET_IID
)
}
}
#
endif
