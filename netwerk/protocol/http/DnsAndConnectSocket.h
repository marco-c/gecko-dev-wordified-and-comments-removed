#
ifndef
DnsAndConnectSocket_h__
#
define
DnsAndConnectSocket_h__
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsAHttpConnection
.
h
"
#
include
"
nsHttpConnection
.
h
"
#
include
"
nsHttpTransaction
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsITransport
.
h
"
#
include
"
nsWeakReference
.
h
"
namespace
mozilla
{
namespace
net
{
#
define
NS_DNSANDCONNECTSOCKET_IID
\
{
\
0x8d411b53
0x54bc
0x4a99
{
\
0x8b
0x78
0xff
0x12
0x5e
0xab
0x15
0x64
\
}
\
}
class
PendingTransactionInfo
;
class
ConnectionEntry
;
class
DnsAndConnectSocket
final
:
public
nsIOutputStreamCallback
public
nsITransportEventSink
public
nsIInterfaceRequestor
public
nsITimerCallback
public
nsINamed
public
nsSupportsWeakReference
{
~
DnsAndConnectSocket
(
)
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_DNSANDCONNECTSOCKET_IID
)
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOUTPUTSTREAMCALLBACK
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
DnsAndConnectSocket
(
ConnectionEntry
*
ent
nsAHttpTransaction
*
trans
uint32_t
caps
bool
speculative
bool
isFromPredictor
bool
urgentStart
)
;
[
[
nodiscard
]
]
nsresult
SetupPrimaryStreams
(
)
;
void
Abandon
(
)
;
double
Duration
(
TimeStamp
epoch
)
;
void
CloseTransports
(
nsresult
error
)
;
bool
IsSpeculative
(
)
{
return
mSpeculative
;
}
bool
IsFromPredictor
(
)
{
return
mIsFromPredictor
;
}
bool
Allow1918
(
)
{
return
mAllow1918
;
}
void
SetAllow1918
(
bool
val
)
{
mAllow1918
=
val
;
}
bool
HasConnected
(
)
{
return
mHasConnected
;
}
void
PrintDiagnostics
(
nsCString
&
log
)
;
bool
AcceptsTransaction
(
nsHttpTransaction
*
trans
)
;
bool
Claim
(
)
;
void
Unclaim
(
)
;
private
:
struct
SocketTransport
{
nsCOMPtr
<
nsISocketTransport
>
mSocketTransport
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mStreamOut
;
nsCOMPtr
<
nsIAsyncInputStream
>
mStreamIn
;
TimeStamp
mSynStarted
;
bool
mConnectedOK
=
false
;
void
Abandon
(
)
;
nsresult
SetupConn
(
nsAHttpTransaction
*
transaction
ConnectionEntry
*
ent
HttpConnectionBase
*
*
connection
)
;
}
;
[
[
nodiscard
]
]
nsresult
SetupBackupStreams
(
)
;
[
[
nodiscard
]
]
nsresult
SetupStreams
(
bool
isBackup
)
;
nsresult
SetupConn
(
nsIAsyncOutputStream
*
out
)
;
void
SetupBackupTimer
(
)
;
void
CancelBackupTimer
(
)
;
bool
IsPrimary
(
nsITransport
*
trans
)
;
bool
IsPrimary
(
nsIAsyncOutputStream
*
out
)
;
bool
IsBackup
(
nsITransport
*
trans
)
;
bool
IsBackup
(
nsIAsyncOutputStream
*
out
)
;
already_AddRefed
<
PendingTransactionInfo
>
FindTransactionHelper
(
bool
removeWhenFound
)
;
RefPtr
<
nsAHttpTransaction
>
mTransaction
;
bool
mDispatchedMTransaction
=
false
;
SocketTransport
mPrimaryTransport
;
uint32_t
mCaps
;
bool
mSpeculative
;
bool
mUrgentStart
;
bool
mIsFromPredictor
;
bool
mAllow1918
=
true
;
bool
mHasConnected
=
false
;
bool
mBackupConnStatsSet
=
false
;
bool
mFreeToUse
=
true
;
nsresult
mPrimaryStreamStatus
=
NS_OK
;
RefPtr
<
ConnectionEntry
>
mEnt
;
nsCOMPtr
<
nsITimer
>
mSynTimer
;
SocketTransport
mBackupTransport
;
bool
mIsHttp3
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
DnsAndConnectSocket
NS_DNSANDCONNECTSOCKET_IID
)
}
}
#
endif
