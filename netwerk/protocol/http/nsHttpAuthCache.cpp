#
include
"
HttpLog
.
h
"
#
include
"
nsHttpAuthCache
.
h
"
#
include
<
algorithm
>
#
include
<
stdlib
.
h
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsNetUtil
.
h
"
namespace
mozilla
{
namespace
net
{
static
inline
void
GetAuthKey
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
nsACString
const
&
originSuffix
nsCString
&
key
)
{
key
.
Truncate
(
)
;
key
.
Append
(
originSuffix
)
;
key
.
Append
(
'
:
'
)
;
key
.
Append
(
scheme
)
;
key
.
AppendLiteral
(
"
:
/
/
"
)
;
key
.
Append
(
host
)
;
key
.
Append
(
'
:
'
)
;
key
.
AppendInt
(
port
)
;
}
nsHttpAuthCache
:
:
nsHttpAuthCache
(
)
:
mDB
(
128
)
mObserver
(
new
OriginClearObserver
(
this
)
)
{
LOG
(
(
"
nsHttpAuthCache
:
:
nsHttpAuthCache
%
p
"
this
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
AddObserver
(
mObserver
"
clear
-
origin
-
attributes
-
data
"
false
)
;
}
}
nsHttpAuthCache
:
:
~
nsHttpAuthCache
(
)
{
LOG
(
(
"
nsHttpAuthCache
:
:
~
nsHttpAuthCache
%
p
"
this
)
)
;
ClearAll
(
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
RemoveObserver
(
mObserver
"
clear
-
origin
-
attributes
-
data
"
)
;
mObserver
-
>
mOwner
=
nullptr
;
}
}
nsresult
nsHttpAuthCache
:
:
GetAuthEntryForPath
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
const
nsACString
&
path
nsACString
const
&
originSuffix
nsHttpAuthEntry
*
*
entry
)
{
LOG
(
(
"
nsHttpAuthCache
:
:
GetAuthEntryForPath
%
p
[
path
=
%
s
]
\
n
"
this
path
.
BeginReading
(
)
)
)
;
nsAutoCString
key
;
nsHttpAuthNode
*
node
=
LookupAuthNode
(
scheme
host
port
originSuffix
key
)
;
if
(
!
node
)
return
NS_ERROR_NOT_AVAILABLE
;
*
entry
=
node
-
>
LookupEntryByPath
(
path
)
;
LOG
(
(
"
returning
%
p
"
*
entry
)
)
;
return
*
entry
?
NS_OK
:
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
nsHttpAuthCache
:
:
GetAuthEntryForDomain
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
const
nsACString
&
realm
nsACString
const
&
originSuffix
nsHttpAuthEntry
*
*
entry
)
{
LOG
(
(
"
nsHttpAuthCache
:
:
GetAuthEntryForDomain
%
p
[
realm
=
%
s
]
\
n
"
this
realm
.
BeginReading
(
)
)
)
;
nsAutoCString
key
;
nsHttpAuthNode
*
node
=
LookupAuthNode
(
scheme
host
port
originSuffix
key
)
;
if
(
!
node
)
return
NS_ERROR_NOT_AVAILABLE
;
*
entry
=
node
-
>
LookupEntryByRealm
(
realm
)
;
LOG
(
(
"
returning
%
p
"
*
entry
)
)
;
return
*
entry
?
NS_OK
:
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
nsHttpAuthCache
:
:
SetAuthEntry
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
const
nsACString
&
path
const
nsACString
&
realm
const
nsACString
&
creds
const
nsACString
&
challenge
nsACString
const
&
originSuffix
const
nsHttpAuthIdentity
*
ident
nsISupports
*
metadata
)
{
nsresult
rv
;
LOG
(
(
"
nsHttpAuthCache
:
:
SetAuthEntry
%
p
[
realm
=
%
s
path
=
%
s
metadata
=
%
p
]
\
n
"
this
realm
.
BeginReading
(
)
path
.
BeginReading
(
)
metadata
)
)
;
nsAutoCString
key
;
nsHttpAuthNode
*
node
=
LookupAuthNode
(
scheme
host
port
originSuffix
key
)
;
if
(
!
node
)
{
auto
node
=
UniquePtr
<
nsHttpAuthNode
>
(
new
nsHttpAuthNode
)
;
LOG
(
(
"
new
nsHttpAuthNode
%
p
for
key
=
'
%
s
'
"
node
.
get
(
)
key
.
get
(
)
)
)
;
rv
=
node
-
>
SetAuthEntry
(
path
realm
creds
challenge
ident
metadata
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mDB
.
InsertOrUpdate
(
key
std
:
:
move
(
node
)
)
;
return
NS_OK
;
}
return
node
-
>
SetAuthEntry
(
path
realm
creds
challenge
ident
metadata
)
;
}
void
nsHttpAuthCache
:
:
ClearAuthEntry
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
const
nsACString
&
realm
nsACString
const
&
originSuffix
)
{
nsAutoCString
key
;
GetAuthKey
(
scheme
host
port
originSuffix
key
)
;
LOG
(
(
"
nsHttpAuthCache
:
:
ClearAuthEntry
%
p
key
=
'
%
s
'
\
n
"
this
key
.
get
(
)
)
)
;
mDB
.
Remove
(
key
)
;
}
void
nsHttpAuthCache
:
:
ClearAll
(
)
{
LOG
(
(
"
nsHttpAuthCache
:
:
ClearAll
%
p
\
n
"
this
)
)
;
mDB
.
Clear
(
)
;
}
nsHttpAuthNode
*
nsHttpAuthCache
:
:
LookupAuthNode
(
const
nsACString
&
scheme
const
nsACString
&
host
int32_t
port
nsACString
const
&
originSuffix
nsCString
&
key
)
{
GetAuthKey
(
scheme
host
port
originSuffix
key
)
;
nsHttpAuthNode
*
result
=
mDB
.
Get
(
key
)
;
LOG
(
(
"
nsHttpAuthCache
:
:
LookupAuthNode
%
p
key
=
'
%
s
'
found
node
=
%
p
"
this
key
.
get
(
)
result
)
)
;
return
result
;
}
NS_IMPL_ISUPPORTS
(
nsHttpAuthCache
:
:
OriginClearObserver
nsIObserver
)
NS_IMETHODIMP
nsHttpAuthCache
:
:
OriginClearObserver
:
:
Observe
(
nsISupports
*
subject
const
char
*
topic
const
char16_t
*
data_unicode
)
{
NS_ENSURE_TRUE
(
mOwner
NS_ERROR_NOT_AVAILABLE
)
;
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
nsDependentString
(
data_unicode
)
)
)
{
NS_ERROR
(
"
Cannot
parse
origin
attributes
pattern
"
)
;
return
NS_ERROR_FAILURE
;
}
mOwner
-
>
ClearOriginData
(
pattern
)
;
return
NS_OK
;
}
void
nsHttpAuthCache
:
:
ClearOriginData
(
OriginAttributesPattern
const
&
pattern
)
{
LOG
(
(
"
nsHttpAuthCache
:
:
ClearOriginData
%
p
"
this
)
)
;
for
(
auto
iter
=
mDB
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsACString
&
key
=
iter
.
Key
(
)
;
int32_t
colon
=
key
.
FindChar
(
'
:
'
)
;
MOZ_ASSERT
(
colon
!
=
kNotFound
)
;
nsDependentCSubstring
oaSuffix
=
StringHead
(
key
colon
)
;
OriginAttributes
oa
;
DebugOnly
<
bool
>
rv
=
oa
.
PopulateFromSuffix
(
oaSuffix
)
;
MOZ_ASSERT
(
rv
)
;
if
(
pattern
.
Matches
(
oa
)
)
{
iter
.
Remove
(
)
;
}
}
}
void
nsHttpAuthCache
:
:
CollectKeys
(
nsTArray
<
nsCString
>
&
aValue
)
{
AppendToArray
(
aValue
mDB
.
Keys
(
)
)
;
}
void
nsHttpAuthIdentity
:
:
Clear
(
)
{
mUser
.
Truncate
(
)
;
mPass
.
Truncate
(
)
;
mDomain
.
Truncate
(
)
;
}
bool
nsHttpAuthIdentity
:
:
Equals
(
const
nsHttpAuthIdentity
&
ident
)
const
{
return
mUser
=
=
ident
.
mUser
&
&
mPass
=
=
ident
.
mPass
&
&
mDomain
=
=
ident
.
mDomain
;
}
nsHttpAuthEntry
:
:
~
nsHttpAuthEntry
(
)
{
while
(
mRoot
)
{
nsHttpAuthPath
*
ap
=
mRoot
;
mRoot
=
mRoot
-
>
mNext
;
free
(
ap
)
;
}
}
nsresult
nsHttpAuthEntry
:
:
AddPath
(
const
nsACString
&
aPath
)
{
nsHttpAuthPath
*
tempPtr
=
mRoot
;
while
(
tempPtr
)
{
if
(
StringBeginsWith
(
aPath
nsDependentCString
(
tempPtr
-
>
mPath
)
)
)
{
return
NS_OK
;
}
tempPtr
=
tempPtr
-
>
mNext
;
}
nsHttpAuthPath
*
newAuthPath
;
int
newpathLen
=
aPath
.
Length
(
)
;
newAuthPath
=
(
nsHttpAuthPath
*
)
malloc
(
sizeof
(
nsHttpAuthPath
)
+
newpathLen
)
;
if
(
!
newAuthPath
)
return
NS_ERROR_OUT_OF_MEMORY
;
memcpy
(
newAuthPath
-
>
mPath
aPath
.
BeginReading
(
)
newpathLen
)
;
newAuthPath
-
>
mPath
[
aPath
.
Length
(
)
]
=
'
\
0
'
;
newAuthPath
-
>
mNext
=
nullptr
;
if
(
!
mRoot
)
mRoot
=
newAuthPath
;
else
mTail
-
>
mNext
=
newAuthPath
;
mTail
=
newAuthPath
;
return
NS_OK
;
}
nsresult
nsHttpAuthEntry
:
:
Set
(
const
nsACString
&
path
const
nsACString
&
realm
const
nsACString
&
creds
const
nsACString
&
chall
const
nsHttpAuthIdentity
*
ident
nsISupports
*
metadata
)
{
if
(
ident
)
{
mIdent
=
*
ident
;
}
else
if
(
mIdent
.
IsEmpty
(
)
)
{
mIdent
.
Clear
(
)
;
}
nsresult
rv
=
AddPath
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mRealm
=
realm
;
mCreds
=
creds
;
mChallenge
=
chall
;
mMetaData
=
metadata
;
return
NS_OK
;
}
nsHttpAuthNode
:
:
nsHttpAuthNode
(
)
{
LOG
(
(
"
Creating
nsHttpAuthNode
%
p
\
n
"
this
)
)
;
}
nsHttpAuthNode
:
:
~
nsHttpAuthNode
(
)
{
LOG
(
(
"
Destroying
nsHttpAuthNode
%
p
\
n
"
this
)
)
;
mList
.
Clear
(
)
;
}
nsHttpAuthEntry
*
nsHttpAuthNode
:
:
LookupEntryByPath
(
const
nsACString
&
path
)
{
for
(
uint32_t
i
=
0
;
i
<
mList
.
Length
(
)
;
+
+
i
)
{
const
auto
&
entry
=
mList
[
i
]
;
nsHttpAuthPath
*
authPath
=
entry
-
>
RootPath
(
)
;
while
(
authPath
)
{
const
char
*
entryPath
=
authPath
-
>
mPath
;
if
(
entryPath
[
0
]
=
=
'
\
0
'
)
{
if
(
path
.
IsEmpty
(
)
)
{
return
entry
.
get
(
)
;
}
}
else
if
(
StringBeginsWith
(
path
nsDependentCString
(
entryPath
)
)
)
{
return
entry
.
get
(
)
;
}
authPath
=
authPath
-
>
mNext
;
}
}
return
nullptr
;
}
nsHttpAuthNode
:
:
EntryList
:
:
const_iterator
nsHttpAuthNode
:
:
LookupEntryItrByRealm
(
const
nsACString
&
realm
)
const
{
return
std
:
:
find_if
(
mList
.
cbegin
(
)
mList
.
cend
(
)
[
&
realm
]
(
const
auto
&
val
)
{
return
realm
.
Equals
(
val
-
>
Realm
(
)
)
;
}
)
;
}
nsHttpAuthEntry
*
nsHttpAuthNode
:
:
LookupEntryByRealm
(
const
nsACString
&
realm
)
{
auto
itr
=
LookupEntryItrByRealm
(
realm
)
;
if
(
itr
!
=
mList
.
cend
(
)
)
{
return
itr
-
>
get
(
)
;
}
return
nullptr
;
}
nsresult
nsHttpAuthNode
:
:
SetAuthEntry
(
const
nsACString
&
path
const
nsACString
&
realm
const
nsACString
&
creds
const
nsACString
&
challenge
const
nsHttpAuthIdentity
*
ident
nsISupports
*
metadata
)
{
nsHttpAuthEntry
*
entry
=
LookupEntryByRealm
(
realm
)
;
if
(
!
entry
)
{
mList
.
InsertElementAt
(
0
WrapUnique
(
new
nsHttpAuthEntry
(
path
realm
creds
challenge
ident
metadata
)
)
)
;
}
else
{
nsresult
rv
=
entry
-
>
Set
(
path
realm
creds
challenge
ident
metadata
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
void
nsHttpAuthNode
:
:
ClearAuthEntry
(
const
nsACString
&
realm
)
{
auto
idx
=
LookupEntryItrByRealm
(
realm
)
;
if
(
idx
!
=
mList
.
cend
(
)
)
{
mList
.
RemoveElementAt
(
idx
)
;
}
}
}
}
