#
include
"
HttpLog
.
h
"
#
include
"
nsHttpNTLMAuth
.
h
"
#
include
"
nsIAuthModule
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
plbase64
.
h
"
#
include
"
plstr
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIHttpAuthenticableChannel
.
h
"
#
include
"
nsIURI
.
h
"
#
ifdef
XP_WIN
#
include
"
nsIChannel
.
h
"
#
include
"
nsIX509Cert
.
h
"
#
include
"
nsITransportSecurityInfo
.
h
"
#
endif
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
mozilla
/
net
/
HttpAuthUtils
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
namespace
mozilla
{
namespace
net
{
static
const
char
kAllowProxies
[
]
=
"
network
.
automatic
-
ntlm
-
auth
.
allow
-
proxies
"
;
static
const
char
kAllowNonFqdn
[
]
=
"
network
.
automatic
-
ntlm
-
auth
.
allow
-
non
-
fqdn
"
;
static
const
char
kTrustedURIs
[
]
=
"
network
.
automatic
-
ntlm
-
auth
.
trusted
-
uris
"
;
static
const
char
kForceGeneric
[
]
=
"
network
.
auth
.
force
-
generic
-
ntlm
"
;
static
const
char
kSSOinPBmode
[
]
=
"
network
.
auth
.
private
-
browsing
-
sso
"
;
StaticRefPtr
<
nsHttpNTLMAuth
>
nsHttpNTLMAuth
:
:
gSingleton
;
static
bool
IsNonFqdn
(
nsIURI
*
uri
)
{
nsAutoCString
host
;
PRNetAddr
addr
;
if
(
NS_FAILED
(
uri
-
>
GetAsciiHost
(
host
)
)
)
return
false
;
return
!
host
.
IsEmpty
(
)
&
&
!
host
.
Contains
(
'
.
'
)
&
&
PR_StringToNetAddr
(
host
.
BeginReading
(
)
&
addr
)
!
=
PR_SUCCESS
;
}
static
bool
ForceGenericNTLM
(
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
!
prefs
)
return
false
;
bool
flag
=
false
;
if
(
NS_FAILED
(
prefs
-
>
GetBoolPref
(
kForceGeneric
&
flag
)
)
)
flag
=
false
;
LOG
(
(
"
Force
use
of
generic
ntlm
auth
module
:
%
d
\
n
"
flag
)
)
;
return
flag
;
}
static
bool
CanUseDefaultCredentials
(
nsIHttpAuthenticableChannel
*
channel
bool
isProxyAuth
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
!
prefs
)
{
return
false
;
}
if
(
isProxyAuth
)
{
bool
val
;
if
(
NS_FAILED
(
prefs
-
>
GetBoolPref
(
kAllowProxies
&
val
)
)
)
val
=
false
;
LOG
(
(
"
Default
credentials
allowed
for
proxy
:
%
d
\
n
"
val
)
)
;
return
val
;
}
nsCOMPtr
<
nsIChannel
>
bareChannel
=
do_QueryInterface
(
channel
)
;
MOZ_ASSERT
(
bareChannel
)
;
if
(
NS_UsePrivateBrowsing
(
bareChannel
)
)
{
bool
ssoInPb
;
if
(
NS_SUCCEEDED
(
prefs
-
>
GetBoolPref
(
kSSOinPBmode
&
ssoInPb
)
)
&
&
ssoInPb
)
{
return
true
;
}
bool
dontRememberHistory
;
if
(
NS_SUCCEEDED
(
prefs
-
>
GetBoolPref
(
"
browser
.
privatebrowsing
.
autostart
"
&
dontRememberHistory
)
)
&
&
!
dontRememberHistory
)
{
return
false
;
}
}
nsCOMPtr
<
nsIURI
>
uri
;
Unused
<
<
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
bool
allowNonFqdn
;
if
(
NS_FAILED
(
prefs
-
>
GetBoolPref
(
kAllowNonFqdn
&
allowNonFqdn
)
)
)
allowNonFqdn
=
false
;
if
(
allowNonFqdn
&
&
uri
&
&
IsNonFqdn
(
uri
)
)
{
LOG
(
(
"
Host
is
non
-
fqdn
default
credentials
are
allowed
\
n
"
)
)
;
return
true
;
}
bool
isTrustedHost
=
(
uri
&
&
auth
:
:
URIMatchesPrefPattern
(
uri
kTrustedURIs
)
)
;
LOG
(
(
"
Default
credentials
allowed
for
host
:
%
d
\
n
"
isTrustedHost
)
)
;
return
isTrustedHost
;
}
class
nsNTLMSessionState
final
:
public
nsISupports
{
~
nsNTLMSessionState
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS0
(
nsNTLMSessionState
)
already_AddRefed
<
nsIHttpAuthenticator
>
nsHttpNTLMAuth
:
:
GetOrCreate
(
)
{
nsCOMPtr
<
nsIHttpAuthenticator
>
authenticator
;
if
(
gSingleton
)
{
authenticator
=
gSingleton
;
}
else
{
gSingleton
=
new
nsHttpNTLMAuth
(
)
;
ClearOnShutdown
(
&
gSingleton
)
;
authenticator
=
gSingleton
;
}
return
authenticator
.
forget
(
)
;
}
NS_IMPL_ISUPPORTS
(
nsHttpNTLMAuth
nsIHttpAuthenticator
)
NS_IMETHODIMP
nsHttpNTLMAuth
:
:
ChallengeReceived
(
nsIHttpAuthenticableChannel
*
channel
const
nsACString
&
challenge
bool
isProxyAuth
nsISupports
*
*
sessionState
nsISupports
*
*
continuationState
bool
*
identityInvalid
)
{
LOG
(
(
"
nsHttpNTLMAuth
:
:
ChallengeReceived
[
ss
=
%
p
cs
=
%
p
]
\
n
"
*
sessionState
*
continuationState
)
)
;
mUseNative
=
true
;
*
identityInvalid
=
false
;
if
(
StringBeginsWith
(
challenge
"
NTLM
"
_ns
nsCaseInsensitiveCStringComparator
)
)
{
nsCOMPtr
<
nsIAuthModule
>
module
;
bool
forceGeneric
=
ForceGenericNTLM
(
)
;
if
(
!
forceGeneric
&
&
!
*
sessionState
)
{
if
(
!
*
continuationState
&
&
CanUseDefaultCredentials
(
channel
isProxyAuth
)
)
{
module
=
nsIAuthModule
:
:
CreateInstance
(
"
sys
-
ntlm
"
)
;
}
#
ifdef
XP_WIN
else
{
module
=
nsIAuthModule
:
:
CreateInstance
(
"
sys
-
ntlm
"
)
;
*
identityInvalid
=
true
;
}
#
endif
if
(
!
module
)
LOG
(
(
"
Native
sys
-
ntlm
auth
module
not
found
.
\
n
"
)
)
;
}
#
ifdef
XP_WIN
if
(
!
forceGeneric
&
&
!
module
)
return
NS_ERROR_UNEXPECTED
;
#
endif
if
(
!
module
)
{
if
(
!
*
sessionState
)
{
RefPtr
<
nsNTLMSessionState
>
state
=
new
nsNTLMSessionState
(
)
;
state
.
forget
(
sessionState
)
;
}
LOG
(
(
"
Trying
to
fall
back
on
internal
ntlm
auth
.
\
n
"
)
)
;
module
=
nsIAuthModule
:
:
CreateInstance
(
"
ntlm
"
)
;
mUseNative
=
false
;
*
identityInvalid
=
true
;
}
if
(
!
module
)
{
LOG
(
(
"
No
ntlm
auth
modules
available
.
\
n
"
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
module
.
forget
(
continuationState
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpNTLMAuth
:
:
GenerateCredentialsAsync
(
nsIHttpAuthenticableChannel
*
authChannel
nsIHttpAuthenticatorCallback
*
aCallback
const
nsACString
&
challenge
bool
isProxyAuth
const
nsAString
&
domain
const
nsAString
&
username
const
nsAString
&
password
nsISupports
*
sessionState
nsISupports
*
continuationState
nsICancelable
*
*
aCancellable
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsHttpNTLMAuth
:
:
GenerateCredentials
(
nsIHttpAuthenticableChannel
*
authChannel
const
nsACString
&
aChallenge
bool
isProxyAuth
const
nsAString
&
domain
const
nsAString
&
user
const
nsAString
&
pass
nsISupports
*
*
sessionState
nsISupports
*
*
continuationState
uint32_t
*
aFlags
nsACString
&
creds
)
{
LOG
(
(
"
nsHttpNTLMAuth
:
:
GenerateCredentials
\
n
"
)
)
;
creds
.
Truncate
(
)
;
*
aFlags
=
0
;
if
(
user
.
IsEmpty
(
)
|
|
pass
.
IsEmpty
(
)
)
*
aFlags
=
USING_INTERNAL_IDENTITY
;
nsresult
rv
;
nsCOMPtr
<
nsIAuthModule
>
module
=
do_QueryInterface
(
*
continuationState
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
void
*
inBuf
*
outBuf
;
uint32_t
inBufLen
outBufLen
;
Maybe
<
nsTArray
<
uint8_t
>
>
certArray
;
if
(
StringBeginsWith
(
aChallenge
"
NTLM
"
_ns
nsCaseInsensitiveCStringComparator
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
authChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsAutoCString
serviceName
host
;
rv
=
uri
-
>
GetAsciiHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
serviceName
.
AppendLiteral
(
"
HTTP
"
)
;
serviceName
.
Append
(
host
)
;
uint32_t
reqFlags
=
nsIAuthModule
:
:
REQ_DEFAULT
;
if
(
isProxyAuth
)
reqFlags
|
=
nsIAuthModule
:
:
REQ_PROXY_AUTH
;
rv
=
module
-
>
Init
(
serviceName
reqFlags
domain
user
pass
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
#
if
defined
(
XP_WIN
)
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
authChannel
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsISupports
>
security
;
rv
=
channel
-
>
GetSecurityInfo
(
getter_AddRefs
(
security
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsITransportSecurityInfo
>
secInfo
=
do_QueryInterface
(
security
)
;
if
(
mUseNative
&
&
secInfo
)
{
nsCOMPtr
<
nsIX509Cert
>
cert
;
rv
=
secInfo
-
>
GetServerCert
(
getter_AddRefs
(
cert
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
certArray
.
emplace
(
)
;
rv
=
cert
-
>
GetRawDER
(
*
certArray
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
inBufLen
=
certArray
-
>
Length
(
)
;
inBuf
=
certArray
-
>
Elements
(
)
;
}
else
{
inBufLen
=
0
;
inBuf
=
nullptr
;
}
#
else
inBufLen
=
0
;
inBuf
=
nullptr
;
#
endif
}
else
{
if
(
aChallenge
.
Length
(
)
<
6
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsDependentCSubstring
challenge
(
aChallenge
5
)
;
uint32_t
len
=
challenge
.
Length
(
)
;
while
(
len
>
0
&
&
challenge
[
len
-
1
]
=
=
'
=
'
)
{
len
-
-
;
}
rv
=
Base64Decode
(
challenge
.
BeginReading
(
)
len
(
char
*
*
)
&
inBuf
&
inBufLen
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
rv
=
module
-
>
GetNextToken
(
inBuf
inBufLen
&
outBuf
&
outBufLen
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CheckedUint32
credsLen
=
(
(
CheckedUint32
(
outBufLen
)
+
2
)
/
3
)
*
4
;
credsLen
+
=
5
;
credsLen
+
=
1
;
if
(
!
credsLen
.
isValid
(
)
)
{
rv
=
NS_ERROR_FAILURE
;
}
else
{
nsAutoCString
encoded
;
(
void
)
Base64Decode
(
nsDependentCSubstring
(
(
char
*
)
outBuf
outBufLen
)
encoded
)
;
creds
=
nsPrintfCString
(
"
NTLM
%
s
"
encoded
.
get
(
)
)
;
}
free
(
outBuf
)
;
}
if
(
inBuf
&
&
!
certArray
)
{
free
(
inBuf
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsHttpNTLMAuth
:
:
GetAuthFlags
(
uint32_t
*
flags
)
{
*
flags
=
CONNECTION_BASED
|
IDENTITY_INCLUDES_DOMAIN
|
IDENTITY_ENCRYPTED
;
return
NS_OK
;
}
}
}
