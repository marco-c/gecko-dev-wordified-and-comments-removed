#
include
"
HttpLog
.
h
"
#
include
"
nsHttpNTLMAuth
.
h
"
#
include
"
nsIAuthModule
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
plbase64
.
h
"
#
include
"
plstr
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIHttpAuthenticableChannel
.
h
"
#
include
"
nsIURI
.
h
"
#
ifdef
XP_WIN
#
include
"
nsIChannel
.
h
"
#
include
"
nsIX509Cert
.
h
"
#
include
"
nsISSLStatus
.
h
"
#
include
"
nsISSLStatusProvider
.
h
"
#
endif
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsUnicharUtils
.
h
"
namespace
mozilla
{
namespace
net
{
static
const
char
kAllowProxies
[
]
=
"
network
.
automatic
-
ntlm
-
auth
.
allow
-
proxies
"
;
static
const
char
kAllowNonFqdn
[
]
=
"
network
.
automatic
-
ntlm
-
auth
.
allow
-
non
-
fqdn
"
;
static
const
char
kTrustedURIs
[
]
=
"
network
.
automatic
-
ntlm
-
auth
.
trusted
-
uris
"
;
static
const
char
kForceGeneric
[
]
=
"
network
.
auth
.
force
-
generic
-
ntlm
"
;
static
const
char
kSSOinPBmode
[
]
=
"
network
.
auth
.
private
-
browsing
-
sso
"
;
static
bool
MatchesBaseURI
(
const
nsCSubstring
&
matchScheme
const
nsCSubstring
&
matchHost
int32_t
matchPort
nsDependentCSubstring
const
&
url
)
{
mozilla
:
:
Tokenizer
t
(
url
)
;
mozilla
:
:
Tokenizer
:
:
Token
token
;
t
.
SkipWhites
(
)
;
t
.
Record
(
)
;
mozilla
:
:
Unused
<
<
t
.
Next
(
token
)
;
bool
ipv6
=
false
;
if
(
token
.
Equals
(
mozilla
:
:
Tokenizer
:
:
Token
:
:
Char
(
'
[
'
)
)
)
{
nsDependentCSubstring
ipv6BareLiteral
;
if
(
!
t
.
ReadUntil
(
mozilla
:
:
Tokenizer
:
:
Token
:
:
Char
(
'
]
'
)
ipv6BareLiteral
)
)
{
return
false
;
}
nsDependentCSubstring
ipv6Literal
;
t
.
Claim
(
ipv6Literal
mozilla
:
:
Tokenizer
:
:
INCLUDE_LAST
)
;
if
(
!
matchHost
.
Equals
(
ipv6Literal
nsCaseInsensitiveUTF8StringComparator
(
)
)
&
&
!
matchHost
.
Equals
(
ipv6BareLiteral
nsCaseInsensitiveUTF8StringComparator
(
)
)
)
{
return
false
;
}
ipv6
=
true
;
}
else
if
(
t
.
CheckChar
(
'
:
'
)
&
&
t
.
CheckChar
(
'
/
'
)
&
&
t
.
CheckChar
(
'
/
'
)
)
{
if
(
!
matchScheme
.
Equals
(
token
.
Fragment
(
)
)
)
{
return
false
;
}
t
.
Record
(
)
;
}
while
(
t
.
Next
(
token
)
)
{
bool
eof
=
token
.
Equals
(
mozilla
:
:
Tokenizer
:
:
Token
:
:
EndOfFile
(
)
)
;
bool
port
=
token
.
Equals
(
mozilla
:
:
Tokenizer
:
:
Token
:
:
Char
(
'
:
'
)
)
;
if
(
eof
|
|
port
)
{
if
(
!
ipv6
)
{
nsDependentCSubstring
hostName
;
t
.
Claim
(
hostName
)
;
if
(
!
hostName
.
IsEmpty
(
)
)
{
if
(
hostName
.
First
(
)
=
=
'
.
'
)
{
if
(
!
StringEndsWith
(
matchHost
hostName
nsCaseInsensitiveUTF8StringComparator
(
)
)
)
{
return
false
;
}
}
else
{
if
(
!
matchHost
.
Equals
(
hostName
nsCaseInsensitiveUTF8StringComparator
(
)
)
)
{
return
false
;
}
}
}
}
if
(
port
)
{
uint16_t
portNumber
;
if
(
!
t
.
ReadInteger
(
&
portNumber
)
)
{
return
false
;
}
if
(
matchPort
!
=
portNumber
)
{
return
false
;
}
if
(
!
t
.
CheckEOF
(
)
)
{
return
false
;
}
}
}
else
if
(
ipv6
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsNonFqdn
(
nsIURI
*
uri
)
{
nsAutoCString
host
;
PRNetAddr
addr
;
if
(
NS_FAILED
(
uri
-
>
GetAsciiHost
(
host
)
)
)
return
false
;
return
!
host
.
IsEmpty
(
)
&
&
!
host
.
Contains
(
'
.
'
)
&
&
PR_StringToNetAddr
(
host
.
BeginReading
(
)
&
addr
)
!
=
PR_SUCCESS
;
}
static
bool
TestPref
(
nsIURI
*
uri
const
char
*
pref
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
!
prefs
)
return
false
;
nsAutoCString
scheme
host
;
int32_t
port
;
if
(
NS_FAILED
(
uri
-
>
GetScheme
(
scheme
)
)
)
return
false
;
if
(
NS_FAILED
(
uri
-
>
GetAsciiHost
(
host
)
)
)
return
false
;
if
(
NS_FAILED
(
uri
-
>
GetPort
(
&
port
)
)
)
return
false
;
char
*
hostList
;
if
(
NS_FAILED
(
prefs
-
>
GetCharPref
(
pref
&
hostList
)
)
|
|
!
hostList
)
return
false
;
struct
FreePolicy
{
void
operator
(
)
(
void
*
p
)
{
free
(
p
)
;
}
}
;
mozilla
:
:
UniquePtr
<
char
[
]
FreePolicy
>
hostListScope
;
hostListScope
.
reset
(
hostList
)
;
mozilla
:
:
Tokenizer
t
(
hostList
)
;
while
(
!
t
.
CheckEOF
(
)
)
{
t
.
SkipWhites
(
)
;
nsDependentCSubstring
url
;
mozilla
:
:
Unused
<
<
t
.
ReadUntil
(
mozilla
:
:
Tokenizer
:
:
Token
:
:
Char
(
'
'
)
url
)
;
if
(
url
.
IsEmpty
(
)
)
{
continue
;
}
if
(
MatchesBaseURI
(
scheme
host
port
url
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
ForceGenericNTLM
(
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
!
prefs
)
return
false
;
bool
flag
=
false
;
if
(
NS_FAILED
(
prefs
-
>
GetBoolPref
(
kForceGeneric
&
flag
)
)
)
flag
=
false
;
LOG
(
(
"
Force
use
of
generic
ntlm
auth
module
:
%
d
\
n
"
flag
)
)
;
return
flag
;
}
static
bool
CanUseDefaultCredentials
(
nsIHttpAuthenticableChannel
*
channel
bool
isProxyAuth
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
!
prefs
)
{
return
false
;
}
if
(
isProxyAuth
)
{
bool
val
;
if
(
NS_FAILED
(
prefs
-
>
GetBoolPref
(
kAllowProxies
&
val
)
)
)
val
=
false
;
LOG
(
(
"
Default
credentials
allowed
for
proxy
:
%
d
\
n
"
val
)
)
;
return
val
;
}
nsCOMPtr
<
nsIChannel
>
bareChannel
=
do_QueryInterface
(
channel
)
;
MOZ_ASSERT
(
bareChannel
)
;
if
(
NS_UsePrivateBrowsing
(
bareChannel
)
)
{
bool
ssoInPb
;
if
(
NS_SUCCEEDED
(
prefs
-
>
GetBoolPref
(
kSSOinPBmode
&
ssoInPb
)
)
&
&
ssoInPb
)
{
return
true
;
}
bool
dontRememberHistory
;
if
(
NS_SUCCEEDED
(
prefs
-
>
GetBoolPref
(
"
browser
.
privatebrowsing
.
autostart
"
&
dontRememberHistory
)
)
&
&
!
dontRememberHistory
)
{
return
false
;
}
}
nsCOMPtr
<
nsIURI
>
uri
;
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
bool
allowNonFqdn
;
if
(
NS_FAILED
(
prefs
-
>
GetBoolPref
(
kAllowNonFqdn
&
allowNonFqdn
)
)
)
allowNonFqdn
=
false
;
if
(
allowNonFqdn
&
&
uri
&
&
IsNonFqdn
(
uri
)
)
{
LOG
(
(
"
Host
is
non
-
fqdn
default
credentials
are
allowed
\
n
"
)
)
;
return
true
;
}
bool
isTrustedHost
=
(
uri
&
&
TestPref
(
uri
kTrustedURIs
)
)
;
LOG
(
(
"
Default
credentials
allowed
for
host
:
%
d
\
n
"
isTrustedHost
)
)
;
return
isTrustedHost
;
}
class
nsNTLMSessionState
final
:
public
nsISupports
{
~
nsNTLMSessionState
(
)
{
}
public
:
NS_DECL_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS0
(
nsNTLMSessionState
)
NS_IMPL_ISUPPORTS
(
nsHttpNTLMAuth
nsIHttpAuthenticator
)
NS_IMETHODIMP
nsHttpNTLMAuth
:
:
ChallengeReceived
(
nsIHttpAuthenticableChannel
*
channel
const
char
*
challenge
bool
isProxyAuth
nsISupports
*
*
sessionState
nsISupports
*
*
continuationState
bool
*
identityInvalid
)
{
LOG
(
(
"
nsHttpNTLMAuth
:
:
ChallengeReceived
[
ss
=
%
p
cs
=
%
p
]
\
n
"
*
sessionState
*
continuationState
)
)
;
mUseNative
=
true
;
*
identityInvalid
=
false
;
if
(
PL_strcasecmp
(
challenge
"
NTLM
"
)
=
=
0
)
{
nsCOMPtr
<
nsISupports
>
module
;
bool
forceGeneric
=
ForceGenericNTLM
(
)
;
if
(
!
forceGeneric
&
&
!
*
sessionState
)
{
if
(
!
*
continuationState
&
&
CanUseDefaultCredentials
(
channel
isProxyAuth
)
)
{
module
=
do_CreateInstance
(
NS_AUTH_MODULE_CONTRACTID_PREFIX
"
sys
-
ntlm
"
)
;
}
#
ifdef
XP_WIN
else
{
module
=
do_CreateInstance
(
NS_AUTH_MODULE_CONTRACTID_PREFIX
"
sys
-
ntlm
"
)
;
*
identityInvalid
=
true
;
}
#
endif
if
(
!
module
)
LOG
(
(
"
Native
sys
-
ntlm
auth
module
not
found
.
\
n
"
)
)
;
}
#
ifdef
XP_WIN
if
(
!
forceGeneric
&
&
!
module
)
return
NS_ERROR_UNEXPECTED
;
#
endif
if
(
!
module
)
{
if
(
!
*
sessionState
)
{
*
sessionState
=
new
nsNTLMSessionState
(
)
;
if
(
!
*
sessionState
)
return
NS_ERROR_OUT_OF_MEMORY
;
NS_ADDREF
(
*
sessionState
)
;
}
LOG
(
(
"
Trying
to
fall
back
on
internal
ntlm
auth
.
\
n
"
)
)
;
module
=
do_CreateInstance
(
NS_AUTH_MODULE_CONTRACTID_PREFIX
"
ntlm
"
)
;
mUseNative
=
false
;
*
identityInvalid
=
true
;
}
if
(
!
module
)
{
LOG
(
(
"
No
ntlm
auth
modules
available
.
\
n
"
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
module
.
swap
(
*
continuationState
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHttpNTLMAuth
:
:
GenerateCredentialsAsync
(
nsIHttpAuthenticableChannel
*
authChannel
nsIHttpAuthenticatorCallback
*
aCallback
const
char
*
challenge
bool
isProxyAuth
const
char16_t
*
domain
const
char16_t
*
username
const
char16_t
*
password
nsISupports
*
sessionState
nsISupports
*
continuationState
nsICancelable
*
*
aCancellable
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsHttpNTLMAuth
:
:
GenerateCredentials
(
nsIHttpAuthenticableChannel
*
authChannel
const
char
*
challenge
bool
isProxyAuth
const
char16_t
*
domain
const
char16_t
*
user
const
char16_t
*
pass
nsISupports
*
*
sessionState
nsISupports
*
*
continuationState
uint32_t
*
aFlags
char
*
*
creds
)
{
LOG
(
(
"
nsHttpNTLMAuth
:
:
GenerateCredentials
\
n
"
)
)
;
*
creds
=
nullptr
;
*
aFlags
=
0
;
if
(
!
user
|
|
!
pass
)
*
aFlags
=
USING_INTERNAL_IDENTITY
;
nsresult
rv
;
nsCOMPtr
<
nsIAuthModule
>
module
=
do_QueryInterface
(
*
continuationState
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
void
*
inBuf
*
outBuf
;
uint32_t
inBufLen
outBufLen
;
if
(
PL_strcasecmp
(
challenge
"
NTLM
"
)
=
=
0
)
{
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
authChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsAutoCString
serviceName
host
;
rv
=
uri
-
>
GetAsciiHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
serviceName
.
AppendLiteral
(
"
HTTP
"
)
;
serviceName
.
Append
(
host
)
;
uint32_t
reqFlags
=
nsIAuthModule
:
:
REQ_DEFAULT
;
if
(
isProxyAuth
)
reqFlags
|
=
nsIAuthModule
:
:
REQ_PROXY_AUTH
;
rv
=
module
-
>
Init
(
serviceName
.
get
(
)
reqFlags
domain
user
pass
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
#
if
defined
(
XP_WIN
)
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
authChannel
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsISupports
>
security
;
rv
=
channel
-
>
GetSecurityInfo
(
getter_AddRefs
(
security
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsISSLStatusProvider
>
statusProvider
=
do_QueryInterface
(
security
)
;
if
(
mUseNative
&
&
statusProvider
)
{
nsCOMPtr
<
nsISSLStatus
>
status
;
rv
=
statusProvider
-
>
GetSSLStatus
(
getter_AddRefs
(
status
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIX509Cert
>
cert
;
rv
=
status
-
>
GetServerCert
(
getter_AddRefs
(
cert
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
uint32_t
length
;
uint8_t
*
certArray
;
cert
-
>
GetRawDER
(
&
length
&
certArray
)
;
inBufLen
=
length
;
inBuf
=
certArray
;
}
else
{
inBufLen
=
0
;
inBuf
=
nullptr
;
}
#
else
inBufLen
=
0
;
inBuf
=
nullptr
;
#
endif
}
else
{
int
len
=
strlen
(
challenge
)
;
if
(
len
<
6
)
return
NS_ERROR_UNEXPECTED
;
challenge
+
=
5
;
len
-
=
5
;
while
(
challenge
[
len
-
1
]
=
=
'
=
'
)
len
-
-
;
inBufLen
=
(
len
*
3
)
/
4
;
inBuf
=
moz_xmalloc
(
inBufLen
)
;
if
(
!
inBuf
)
return
NS_ERROR_OUT_OF_MEMORY
;
if
(
PL_Base64Decode
(
challenge
len
(
char
*
)
inBuf
)
=
=
nullptr
)
{
free
(
inBuf
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
rv
=
module
-
>
GetNextToken
(
inBuf
inBufLen
&
outBuf
&
outBufLen
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
int
credsLen
=
5
+
(
(
outBufLen
+
2
)
/
3
)
*
4
;
*
creds
=
(
char
*
)
moz_xmalloc
(
credsLen
+
1
)
;
if
(
!
*
creds
)
rv
=
NS_ERROR_OUT_OF_MEMORY
;
else
{
memcpy
(
*
creds
"
NTLM
"
5
)
;
PL_Base64Encode
(
(
char
*
)
outBuf
outBufLen
*
creds
+
5
)
;
(
*
creds
)
[
credsLen
]
=
'
\
0
'
;
}
free
(
outBuf
)
;
}
if
(
inBuf
)
free
(
inBuf
)
;
return
rv
;
}
NS_IMETHODIMP
nsHttpNTLMAuth
:
:
GetAuthFlags
(
uint32_t
*
flags
)
{
*
flags
=
CONNECTION_BASED
|
IDENTITY_INCLUDES_DOMAIN
|
IDENTITY_ENCRYPTED
;
return
NS_OK
;
}
}
}
