#
include
"
HttpLog
.
h
"
#
include
"
TlsHandshaker
.
h
"
#
include
"
nsHttpConnectionInfo
.
h
"
#
include
"
nsHttpConnection
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsISSLSocketControl
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
define
TLS_EARLY_DATA_NOT_AVAILABLE
0
#
define
TLS_EARLY_DATA_AVAILABLE_BUT_NOT_USED
1
#
define
TLS_EARLY_DATA_AVAILABLE_AND_USED
2
namespace
mozilla
:
:
net
{
NS_IMPL_ISUPPORTS
(
TlsHandshaker
nsITlsHandshakeCallbackListener
)
TlsHandshaker
:
:
TlsHandshaker
(
nsHttpConnectionInfo
*
aInfo
nsHttpConnection
*
aOwner
)
:
mConnInfo
(
aInfo
)
mOwner
(
aOwner
)
{
LOG
(
(
"
TlsHandshaker
ctor
%
p
"
this
)
)
;
}
TlsHandshaker
:
:
~
TlsHandshaker
(
)
{
LOG
(
(
"
TlsHandshaker
dtor
%
p
"
this
)
)
;
}
NS_IMETHODIMP
TlsHandshaker
:
:
HandshakeDone
(
)
{
LOG
(
(
"
TlsHandshaker
:
:
HandshakeDone
mOwner
=
%
p
"
mOwner
.
get
(
)
)
)
;
if
(
mOwner
)
{
mTlsHandshakeComplitionPending
=
true
;
RefPtr
<
TlsHandshaker
>
self
(
this
)
;
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
"
TlsHandshaker
:
:
HandshakeDoneInternal
"
[
self
{
std
:
:
move
(
self
)
}
]
(
)
{
if
(
self
-
>
mTlsHandshakeComplitionPending
&
&
self
-
>
mOwner
)
{
self
-
>
mOwner
-
>
HandshakeDoneInternal
(
)
;
self
-
>
mTlsHandshakeComplitionPending
=
false
;
}
}
)
)
;
}
return
NS_OK
;
}
void
TlsHandshaker
:
:
SetupSSL
(
bool
aInSpdyTunnel
bool
aForcePlainText
)
{
if
(
!
mOwner
)
{
return
;
}
LOG1
(
(
"
TlsHandshaker
:
:
SetupSSL
%
p
caps
=
0x
%
X
%
s
\
n
"
mOwner
.
get
(
)
mOwner
-
>
TransactionCaps
(
)
mConnInfo
-
>
HashKey
(
)
.
get
(
)
)
)
;
if
(
mSetupSSLCalled
)
{
return
;
}
mSetupSSLCalled
=
true
;
if
(
mNPNComplete
)
{
return
;
}
mNPNComplete
=
true
;
if
(
!
mConnInfo
-
>
FirstHopSSL
(
)
|
|
aForcePlainText
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
{
}
;
if
(
aInSpdyTunnel
)
{
rv
=
InitSSLParams
(
false
true
)
;
}
else
{
bool
usingHttpsProxy
=
mConnInfo
-
>
UsingHttpsProxy
(
)
;
rv
=
InitSSLParams
(
usingHttpsProxy
usingHttpsProxy
)
;
}
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsresult
TlsHandshaker
:
:
InitSSLParams
(
bool
connectingToProxy
bool
proxyStartSSL
)
{
LOG
(
(
"
TlsHandshaker
:
:
InitSSLParams
[
mOwner
=
%
p
]
connectingToProxy
=
%
d
\
n
"
mOwner
.
get
(
)
connectingToProxy
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
!
mOwner
)
{
return
NS_ERROR_ABORT
;
}
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
securityInfo
;
mOwner
-
>
GetSecurityInfo
(
getter_AddRefs
(
securityInfo
)
)
;
if
(
!
securityInfo
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISSLSocketControl
>
ssl
=
do_QueryInterface
(
securityInfo
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mConnInfo
-
>
UsingProxy
(
)
|
|
gHttpHandler
-
>
Is0RttTcpExcluded
(
mConnInfo
)
)
{
ssl
-
>
DisableEarlyData
(
)
;
}
if
(
proxyStartSSL
)
{
rv
=
ssl
-
>
ProxyStartSSL
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
NS_SUCCEEDED
(
SetupNPNList
(
ssl
mOwner
-
>
TransactionCaps
(
)
)
)
&
&
NS_SUCCEEDED
(
ssl
-
>
SetHandshakeCallbackListener
(
this
)
)
)
{
LOG
(
(
"
InitSSLParams
Setting
up
SPDY
Negotiation
OK
mOwner
=
%
p
"
mOwner
.
get
(
)
)
)
;
mNPNComplete
=
false
;
}
return
NS_OK
;
}
nsresult
TlsHandshaker
:
:
SetupNPNList
(
nsISSLSocketControl
*
ssl
uint32_t
caps
)
{
nsTArray
<
nsCString
>
protocolArray
;
protocolArray
.
AppendElement
(
"
http
/
1
.
1
"
_ns
)
;
if
(
StaticPrefs
:
:
network_http_http2_enabled
(
)
&
&
!
(
caps
&
NS_HTTP_DISALLOW_SPDY
)
)
{
LOG
(
(
"
nsHttpConnection
:
:
SetupSSL
Allow
SPDY
NPN
selection
"
)
)
;
const
SpdyInformation
*
info
=
gHttpHandler
-
>
SpdyInfo
(
)
;
if
(
info
-
>
ALPNCallbacks
(
ssl
)
)
{
protocolArray
.
AppendElement
(
info
-
>
VersionString
)
;
}
}
nsresult
rv
=
ssl
-
>
SetNPNList
(
protocolArray
)
;
LOG
(
(
"
TlsHandshaker
:
:
SetupNPNList
%
p
%
"
PRIx32
"
\
n
"
mOwner
.
get
(
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
rv
;
}
bool
TlsHandshaker
:
:
EnsureNPNComplete
(
)
{
if
(
!
mOwner
)
{
mNPNComplete
=
true
;
return
true
;
}
nsCOMPtr
<
nsISocketTransport
>
transport
=
mOwner
-
>
Transport
(
)
;
MOZ_ASSERT
(
transport
)
;
if
(
!
transport
)
{
mNPNComplete
=
true
;
return
true
;
}
if
(
mNPNComplete
)
{
return
true
;
}
if
(
mTlsHandshakeComplitionPending
)
{
return
false
;
}
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsISupports
>
securityInfo
;
mOwner
-
>
GetSecurityInfo
(
getter_AddRefs
(
securityInfo
)
)
;
if
(
!
securityInfo
)
{
FinishNPNSetup
(
false
false
)
;
return
true
;
}
nsCOMPtr
<
nsISSLSocketControl
>
ssl
=
do_QueryInterface
(
securityInfo
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
FinishNPNSetup
(
false
false
)
;
return
true
;
}
if
(
!
m0RTTChecked
)
{
RefPtr
<
nsAHttpTransaction
>
transaction
=
mOwner
-
>
Transaction
(
)
;
nsCOMPtr
<
nsISocketTransport
>
transport
=
mOwner
-
>
Transport
(
)
;
if
(
transaction
&
&
transport
)
{
transaction
-
>
OnTransportStatus
(
transport
NS_NET_STATUS_TLS_HANDSHAKE_STARTING
0
)
;
}
}
LOG
(
(
"
TlsHandshaker
:
:
EnsureNPNComplete
[
mOwner
=
%
p
]
drive
TLS
handshake
"
mOwner
.
get
(
)
)
)
;
rv
=
ssl
-
>
DriveHandshake
(
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
FinishNPNSetup
(
false
true
)
;
return
true
;
}
Check0RttEnabled
(
ssl
)
;
return
false
;
}
void
TlsHandshaker
:
:
EarlyDataDone
(
)
{
if
(
mEarlyDataState
=
=
EarlyData
:
:
USED
)
{
mEarlyDataState
=
EarlyData
:
:
DONE_USED
;
}
else
if
(
mEarlyDataState
=
=
EarlyData
:
:
CANNOT_BE_USED
)
{
mEarlyDataState
=
EarlyData
:
:
DONE_CANNOT_BE_USED
;
}
else
if
(
mEarlyDataState
=
=
EarlyData
:
:
NOT_AVAILABLE
)
{
mEarlyDataState
=
EarlyData
:
:
DONE_NOT_AVAILABLE
;
}
}
void
TlsHandshaker
:
:
FinishNPNSetup
(
bool
handshakeSucceeded
bool
hasSecurityInfo
)
{
LOG
(
(
"
TlsHandshaker
:
:
FinishNPNSetup
mOwner
=
%
p
"
mOwner
.
get
(
)
)
)
;
mNPNComplete
=
true
;
mOwner
-
>
PostProcessNPNSetup
(
handshakeSucceeded
hasSecurityInfo
EarlyDataUsed
(
)
)
;
EarlyDataDone
(
)
;
}
void
TlsHandshaker
:
:
Check0RttEnabled
(
nsISSLSocketControl
*
ssl
)
{
if
(
!
mOwner
)
{
return
;
}
if
(
m0RTTChecked
)
{
return
;
}
m0RTTChecked
=
true
;
if
(
mConnInfo
-
>
UsingProxy
(
)
)
{
return
;
}
if
(
NS_FAILED
(
ssl
-
>
GetAlpnEarlySelection
(
mEarlyNegotiatedALPN
)
)
)
{
LOG1
(
(
"
TlsHandshaker
:
:
Check0RttEnabled
%
p
-
"
"
early
selected
alpn
not
available
"
mOwner
.
get
(
)
)
)
;
}
else
{
LOG1
(
(
"
TlsHandshaker
:
:
Check0RttEnabled
%
p
-
"
"
early
selected
alpn
:
%
s
"
mOwner
.
get
(
)
mEarlyNegotiatedALPN
.
get
(
)
)
)
;
const
SpdyInformation
*
info
=
gHttpHandler
-
>
SpdyInfo
(
)
;
if
(
!
mEarlyNegotiatedALPN
.
Equals
(
info
-
>
VersionString
)
)
{
RefPtr
<
nsAHttpTransaction
>
transaction
=
mOwner
-
>
Transaction
(
)
;
if
(
transaction
&
&
transaction
-
>
Do0RTT
(
)
)
{
LOG
(
(
"
TlsHandshaker
:
:
Check0RttEnabled
[
mOwner
=
%
p
]
-
We
"
"
can
do
0RTT
(
http
/
1
)
!
"
mOwner
.
get
(
)
)
)
;
mEarlyDataState
=
EarlyData
:
:
USED
;
}
else
{
mEarlyDataState
=
EarlyData
:
:
CANNOT_BE_USED
;
Unused
<
<
mOwner
-
>
ResumeRecv
(
)
;
}
}
else
{
LOG
(
(
"
TlsHandshaker
:
:
Check0RttEnabled
[
mOwner
=
%
p
]
-
Starting
"
"
0RTT
for
h2
!
"
mOwner
.
get
(
)
)
)
;
mEarlyDataState
=
EarlyData
:
:
USED
;
mOwner
-
>
Start0RTTSpdy
(
info
-
>
Version
)
;
}
}
}
void
TlsHandshaker
:
:
EarlyDataTelemetry
(
int16_t
tlsVersion
bool
earlyDataAccepted
int64_t
aContentBytesWritten0RTT
)
{
if
(
tlsVersion
>
nsISSLSocketControl
:
:
TLS_VERSION_1_2
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
TLS_EARLY_DATA_NEGOTIATED
(
mEarlyDataState
=
=
EarlyData
:
:
NOT_AVAILABLE
)
?
TLS_EARLY_DATA_NOT_AVAILABLE
:
(
(
mEarlyDataState
=
=
EarlyData
:
:
USED
)
?
TLS_EARLY_DATA_AVAILABLE_AND_USED
:
TLS_EARLY_DATA_AVAILABLE_BUT_NOT_USED
)
)
;
if
(
EarlyDataUsed
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
TLS_EARLY_DATA_ACCEPTED
earlyDataAccepted
)
;
}
if
(
earlyDataAccepted
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
TLS_EARLY_DATA_BYTES_WRITTEN
aContentBytesWritten0RTT
)
;
}
}
}
}
