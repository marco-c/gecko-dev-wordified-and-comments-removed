#
ifndef
HttpTransactionChild_h__
#
define
HttpTransactionChild_h__
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
net
/
NeckoChannelParams
.
h
"
#
include
"
mozilla
/
net
/
PHttpTransactionChild
.
h
"
#
include
"
nsHttpRequestHead
.
h
"
#
include
"
nsIEarlyHintObserver
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIThreadRetargetableStreamListener
.
h
"
#
include
"
nsIThrottledInputChannel
.
h
"
#
include
"
nsITransport
.
h
"
class
nsInputStreamPump
;
namespace
mozilla
:
:
net
{
class
BackgroundDataBridgeParent
;
class
InputChannelThrottleQueueChild
;
class
nsHttpConnectionInfo
;
class
nsHttpTransaction
;
class
nsProxyInfo
;
class
HttpTransactionChild
final
:
public
PHttpTransactionChild
public
nsITransportEventSink
public
nsIThrottledInputChannel
public
nsIThreadRetargetableStreamListener
public
nsIEarlyHintObserver
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSITHROTTLEDINPUTCHANNEL
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
NS_DECL_NSIEARLYHINTOBSERVER
explicit
HttpTransactionChild
(
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvInit
(
const
uint32_t
&
aCaps
const
HttpConnectionInfoCloneArgs
&
aArgs
const
nsHttpRequestHead
&
aReqHeaders
const
Maybe
<
IPCStream
>
&
aRequestBody
const
uint64_t
&
aReqContentLength
const
bool
&
aReqBodyIncludesHeaders
const
uint64_t
&
aTopLevelOuterContentWindowId
const
uint8_t
&
aHttpTrafficCategory
const
uint64_t
&
aRequestContextID
const
ClassOfService
&
aClassOfService
const
uint32_t
&
aInitialRwin
const
bool
&
aResponseTimeoutEnabled
const
uint64_t
&
aChannelId
const
bool
&
aHasTransactionObserver
const
mozilla
:
:
Maybe
<
PInputChannelThrottleQueueChild
*
>
&
aThrottleQueue
const
bool
&
aIsDocumentLoad
const
TimeStamp
&
aRedirectStart
const
TimeStamp
&
aRedirectEnd
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvCancelPump
(
const
nsresult
&
aStatus
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvSuspendPump
(
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvResumePump
(
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvSetDNSWasRefreshed
(
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvDontReuseConnection
(
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvSetH2WSConnRefTaken
(
)
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
nsHttpTransaction
*
GetHttpTransaction
(
)
;
private
:
virtual
~
HttpTransactionChild
(
)
;
nsProxyInfo
*
ProxyInfoCloneArgsToProxyInfo
(
const
nsTArray
<
ProxyInfoCloneArgs
>
&
aArgs
)
;
already_AddRefed
<
nsHttpConnectionInfo
>
DeserializeHttpConnectionInfoCloneArgs
(
const
HttpConnectionInfoCloneArgs
&
aInfoArgs
)
;
[
[
nodiscard
]
]
nsresult
InitInternal
(
uint32_t
caps
const
HttpConnectionInfoCloneArgs
&
infoArgs
nsHttpRequestHead
*
requestHead
nsIInputStream
*
requestBody
uint64_t
requestContentLength
bool
requestBodyHasHeaders
uint64_t
topLevelOuterContentWindowId
uint8_t
httpTrafficCategory
uint64_t
requestContextID
ClassOfService
classOfService
uint32_t
initialRwin
bool
responseTimeoutEnabled
uint64_t
channelId
bool
aHasTransactionObserver
)
;
void
CancelInternal
(
nsresult
aStatus
)
;
bool
CanSendODAToContentProcessDirectly
(
const
Maybe
<
nsHttpResponseHead
>
&
aHead
)
;
ResourceTimingStructArgs
GetTimingAttributes
(
)
;
Atomic
<
bool
ReleaseAcquire
>
mCanceled
{
false
}
;
Atomic
<
nsresult
ReleaseAcquire
>
mStatus
{
NS_OK
}
;
uint64_t
mChannelId
{
0
}
;
nsHttpRequestHead
mRequestHead
;
bool
mIsDocumentLoad
{
false
}
;
uint64_t
mLogicalOffset
{
0
}
;
TimeStamp
mRedirectStart
;
TimeStamp
mRedirectEnd
;
nsCString
mProtocolVersion
;
nsCOMPtr
<
nsIInputStream
>
mUploadStream
;
RefPtr
<
nsHttpTransaction
>
mTransaction
;
nsCOMPtr
<
nsIRequest
>
mTransactionPump
;
Maybe
<
TransactionObserverResult
>
mTransactionObserverResult
;
RefPtr
<
InputChannelThrottleQueueChild
>
mThrottleQueue
;
RefPtr
<
BackgroundDataBridgeParent
>
mDataBridgeParent
;
}
;
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
net
:
:
HttpTransactionChild
*
p
)
{
return
static_cast
<
nsIStreamListener
*
>
(
p
)
;
}
#
endif
