#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
nsCORSListenerProxy
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
HttpChannelChild
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsWhitespaceTokenizer
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsAsyncRedirectVerifyHelper
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIDOMWindowUtils
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsINetworkInterceptController
.
h
"
#
include
"
nsICorsPreflightCallback
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsHttpChannel
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
nsIHttpHeaderVisitor
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
net
;
#
define
PREFLIGHT_CACHE_SIZE
100
static
bool
gDisableCORS
=
false
;
static
bool
gDisableCORSPrivateData
=
false
;
static
void
LogBlockedRequest
(
nsIRequest
*
aRequest
const
char
*
aProperty
const
char16_t
*
aParam
nsIHttpChannel
*
aCreatingChannel
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
nsCOMPtr
<
nsIURI
>
aUri
;
channel
-
>
GetURI
(
getter_AddRefs
(
aUri
)
)
;
nsAutoCString
spec
;
if
(
aUri
)
{
spec
=
aUri
-
>
GetSpecOrDefault
(
)
;
}
nsAutoString
blockedMessage
;
NS_ConvertUTF8toUTF16
specUTF16
(
spec
)
;
const
char16_t
*
params
[
]
=
{
specUTF16
.
get
(
)
aParam
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eSECURITY_PROPERTIES
aProperty
params
blockedMessage
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
log
blocked
cross
-
site
request
(
no
formalizedStr
"
)
;
return
;
}
nsAutoString
msg
(
blockedMessage
.
get
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
if
(
aCreatingChannel
)
{
rv
=
aCreatingChannel
-
>
LogBlockedCORSRequest
(
msg
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
;
}
}
NS_WARNING
(
"
Failed
to
log
blocked
cross
-
site
request
to
web
console
from
parent
-
>
child
falling
back
to
browser
console
"
)
;
}
bool
privateBrowsing
=
false
;
if
(
aRequest
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
rv
=
aRequest
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
privateBrowsing
=
nsContentUtils
:
:
IsInPrivateBrowsing
(
loadGroup
)
;
}
uint64_t
innerWindowID
=
nsContentUtils
:
:
GetInnerWindowID
(
aRequest
)
;
nsCORSListenerProxy
:
:
LogBlockedCORSRequest
(
innerWindowID
privateBrowsing
msg
)
;
}
class
nsPreflightCache
{
public
:
struct
TokenTime
{
nsCString
token
;
TimeStamp
expirationTime
;
}
;
struct
CacheEntry
:
public
LinkedListElement
<
CacheEntry
>
{
explicit
CacheEntry
(
nsCString
&
aKey
)
:
mKey
(
aKey
)
{
MOZ_COUNT_CTOR
(
nsPreflightCache
:
:
CacheEntry
)
;
}
~
CacheEntry
(
)
{
MOZ_COUNT_DTOR
(
nsPreflightCache
:
:
CacheEntry
)
;
}
void
PurgeExpired
(
TimeStamp
now
)
;
bool
CheckRequest
(
const
nsCString
&
aMethod
const
nsTArray
<
nsCString
>
&
aCustomHeaders
)
;
nsCString
mKey
;
nsTArray
<
TokenTime
>
mMethods
;
nsTArray
<
TokenTime
>
mHeaders
;
}
;
nsPreflightCache
(
)
{
MOZ_COUNT_CTOR
(
nsPreflightCache
)
;
}
~
nsPreflightCache
(
)
{
Clear
(
)
;
MOZ_COUNT_DTOR
(
nsPreflightCache
)
;
}
bool
Initialize
(
)
{
return
true
;
}
CacheEntry
*
GetEntry
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
bool
aWithCredentials
bool
aCreate
)
;
void
RemoveEntries
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
)
;
void
Clear
(
)
;
private
:
static
bool
GetCacheKey
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
bool
aWithCredentials
nsACString
&
_retval
)
;
nsClassHashtable
<
nsCStringHashKey
CacheEntry
>
mTable
;
LinkedList
<
CacheEntry
>
mList
;
}
;
static
nsPreflightCache
*
sPreflightCache
=
nullptr
;
static
bool
EnsurePreflightCache
(
)
{
if
(
sPreflightCache
)
return
true
;
nsAutoPtr
<
nsPreflightCache
>
newCache
(
new
nsPreflightCache
(
)
)
;
if
(
newCache
-
>
Initialize
(
)
)
{
sPreflightCache
=
newCache
.
forget
(
)
;
return
true
;
}
return
false
;
}
void
nsPreflightCache
:
:
CacheEntry
:
:
PurgeExpired
(
TimeStamp
now
)
{
for
(
uint32_t
i
=
0
len
=
mMethods
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
if
(
now
>
=
mMethods
[
i
]
.
expirationTime
)
{
mMethods
.
UnorderedRemoveElementAt
(
i
)
;
-
-
i
;
-
-
len
;
}
}
for
(
uint32_t
i
=
0
len
=
mHeaders
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
if
(
now
>
=
mHeaders
[
i
]
.
expirationTime
)
{
mHeaders
.
UnorderedRemoveElementAt
(
i
)
;
-
-
i
;
-
-
len
;
}
}
}
bool
nsPreflightCache
:
:
CacheEntry
:
:
CheckRequest
(
const
nsCString
&
aMethod
const
nsTArray
<
nsCString
>
&
aHeaders
)
{
PurgeExpired
(
TimeStamp
:
:
NowLoRes
(
)
)
;
if
(
!
aMethod
.
EqualsLiteral
(
"
GET
"
)
&
&
!
aMethod
.
EqualsLiteral
(
"
POST
"
)
)
{
struct
CheckToken
{
bool
Equals
(
const
TokenTime
&
e
const
nsCString
&
method
)
const
{
return
e
.
token
.
Equals
(
method
)
;
}
}
;
if
(
!
mMethods
.
Contains
(
aMethod
CheckToken
(
)
)
)
{
return
false
;
}
}
struct
CheckHeaderToken
{
bool
Equals
(
const
TokenTime
&
e
const
nsCString
&
header
)
const
{
return
e
.
token
.
Equals
(
header
comparator
)
;
}
const
nsCaseInsensitiveCStringComparator
comparator
;
}
checker
;
for
(
uint32_t
i
=
0
;
i
<
aHeaders
.
Length
(
)
;
+
+
i
)
{
if
(
!
mHeaders
.
Contains
(
aHeaders
[
i
]
checker
)
)
{
return
false
;
}
}
return
true
;
}
nsPreflightCache
:
:
CacheEntry
*
nsPreflightCache
:
:
GetEntry
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
bool
aWithCredentials
bool
aCreate
)
{
nsCString
key
;
if
(
!
GetCacheKey
(
aURI
aPrincipal
aWithCredentials
key
)
)
{
NS_WARNING
(
"
Invalid
cache
key
!
"
)
;
return
nullptr
;
}
CacheEntry
*
existingEntry
=
nullptr
;
if
(
mTable
.
Get
(
key
&
existingEntry
)
)
{
existingEntry
-
>
removeFrom
(
mList
)
;
mList
.
insertFront
(
existingEntry
)
;
return
existingEntry
;
}
if
(
!
aCreate
)
{
return
nullptr
;
}
CacheEntry
*
newEntry
=
new
CacheEntry
(
key
)
;
if
(
!
newEntry
)
{
NS_WARNING
(
"
Failed
to
allocate
new
cache
entry
!
"
)
;
return
nullptr
;
}
NS_ASSERTION
(
mTable
.
Count
(
)
<
=
PREFLIGHT_CACHE_SIZE
"
Something
is
borked
too
many
entries
in
the
cache
!
"
)
;
if
(
mTable
.
Count
(
)
=
=
PREFLIGHT_CACHE_SIZE
)
{
TimeStamp
now
=
TimeStamp
:
:
NowLoRes
(
)
;
for
(
auto
iter
=
mTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
CacheEntry
>
&
entry
=
iter
.
Data
(
)
;
entry
-
>
PurgeExpired
(
now
)
;
if
(
entry
-
>
mHeaders
.
IsEmpty
(
)
&
&
entry
-
>
mMethods
.
IsEmpty
(
)
)
{
entry
-
>
removeFrom
(
sPreflightCache
-
>
mList
)
;
iter
.
Remove
(
)
;
}
}
if
(
mTable
.
Count
(
)
=
=
PREFLIGHT_CACHE_SIZE
)
{
CacheEntry
*
lruEntry
=
static_cast
<
CacheEntry
*
>
(
mList
.
popLast
(
)
)
;
MOZ_ASSERT
(
lruEntry
)
;
mTable
.
Remove
(
lruEntry
-
>
mKey
)
;
NS_ASSERTION
(
mTable
.
Count
(
)
=
=
PREFLIGHT_CACHE_SIZE
-
1
"
Somehow
tried
to
remove
an
entry
that
was
never
added
!
"
)
;
}
}
mTable
.
Put
(
key
newEntry
)
;
mList
.
insertFront
(
newEntry
)
;
return
newEntry
;
}
void
nsPreflightCache
:
:
RemoveEntries
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
)
{
CacheEntry
*
entry
;
nsCString
key
;
if
(
GetCacheKey
(
aURI
aPrincipal
true
key
)
&
&
mTable
.
Get
(
key
&
entry
)
)
{
entry
-
>
removeFrom
(
mList
)
;
mTable
.
Remove
(
key
)
;
}
if
(
GetCacheKey
(
aURI
aPrincipal
false
key
)
&
&
mTable
.
Get
(
key
&
entry
)
)
{
entry
-
>
removeFrom
(
mList
)
;
mTable
.
Remove
(
key
)
;
}
}
void
nsPreflightCache
:
:
Clear
(
)
{
mList
.
clear
(
)
;
mTable
.
Clear
(
)
;
}
bool
nsPreflightCache
:
:
GetCacheKey
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
bool
aWithCredentials
nsACString
&
_retval
)
{
NS_ASSERTION
(
aURI
"
Null
uri
!
"
)
;
NS_ASSERTION
(
aPrincipal
"
Null
principal
!
"
)
;
NS_NAMED_LITERAL_CSTRING
(
space
"
"
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsAutoCString
scheme
host
port
;
if
(
uri
)
{
uri
-
>
GetScheme
(
scheme
)
;
uri
-
>
GetHost
(
host
)
;
port
.
AppendInt
(
NS_GetRealPort
(
uri
)
)
;
}
if
(
aWithCredentials
)
{
_retval
.
AssignLiteral
(
"
cred
"
)
;
}
else
{
_retval
.
AssignLiteral
(
"
nocred
"
)
;
}
nsAutoCString
spec
;
rv
=
aURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
_retval
.
Append
(
space
+
scheme
+
space
+
host
+
space
+
port
+
space
+
spec
)
;
return
true
;
}
NS_IMPL_ISUPPORTS
(
nsCORSListenerProxy
nsIStreamListener
nsIRequestObserver
nsIChannelEventSink
nsIInterfaceRequestor
nsIThreadRetargetableStreamListener
)
void
nsCORSListenerProxy
:
:
Startup
(
)
{
Preferences
:
:
AddBoolVarCache
(
&
gDisableCORS
"
content
.
cors
.
disable
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
gDisableCORSPrivateData
"
content
.
cors
.
no_private_data
"
)
;
}
void
nsCORSListenerProxy
:
:
Shutdown
(
)
{
delete
sPreflightCache
;
sPreflightCache
=
nullptr
;
}
nsCORSListenerProxy
:
:
nsCORSListenerProxy
(
nsIStreamListener
*
aOuter
nsIPrincipal
*
aRequestingPrincipal
bool
aWithCredentials
)
:
mOuterListener
(
aOuter
)
mRequestingPrincipal
(
aRequestingPrincipal
)
mOriginHeaderPrincipal
(
aRequestingPrincipal
)
mWithCredentials
(
aWithCredentials
&
&
!
gDisableCORSPrivateData
)
mRequestApproved
(
false
)
mHasBeenCrossSite
(
false
)
#
ifdef
DEBUG
mInited
(
false
)
#
endif
mMutex
(
"
nsCORSListenerProxy
"
)
{
}
nsresult
nsCORSListenerProxy
:
:
Init
(
nsIChannel
*
aChannel
DataURIHandling
aAllowDataURI
)
{
aChannel
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
mOuterNotificationCallbacks
)
)
;
aChannel
-
>
SetNotificationCallbacks
(
this
)
;
nsresult
rv
=
UpdateChannel
(
aChannel
aAllowDataURI
UpdateType
:
:
Default
)
;
if
(
NS_FAILED
(
rv
)
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
mOuterListener
=
nullptr
;
}
mRequestingPrincipal
=
nullptr
;
mOriginHeaderPrincipal
=
nullptr
;
mOuterNotificationCallbacks
=
nullptr
;
mHttpChannel
=
nullptr
;
}
#
ifdef
DEBUG
mInited
=
true
;
#
endif
return
rv
;
}
NS_IMETHODIMP
nsCORSListenerProxy
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
MOZ_ASSERT
(
mInited
"
nsCORSListenerProxy
has
not
been
initialized
properly
"
)
;
nsresult
rv
=
CheckRequestApproved
(
aRequest
)
;
mRequestApproved
=
NS_SUCCEEDED
(
rv
)
;
if
(
!
mRequestApproved
)
{
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
if
(
channel
)
{
nsCOMPtr
<
nsIURI
>
uri
;
NS_GetFinalChannelURI
(
channel
getter_AddRefs
(
uri
)
)
;
if
(
uri
)
{
if
(
sPreflightCache
)
{
sPreflightCache
-
>
RemoveEntries
(
uri
mRequestingPrincipal
)
;
}
else
{
nsCOMPtr
<
nsIHttpChannelChild
>
httpChannelChild
=
do_QueryInterface
(
channel
)
;
if
(
httpChannelChild
)
{
rv
=
httpChannelChild
-
>
RemoveCorsPreflightCacheEntry
(
uri
mRequestingPrincipal
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
remove
CORS
preflight
cache
entry
!
"
)
;
}
}
}
}
}
aRequest
-
>
Cancel
(
NS_ERROR_DOM_BAD_URI
)
;
nsCOMPtr
<
nsIStreamListener
>
listener
;
{
MutexAutoLock
lock
(
mMutex
)
;
listener
=
mOuterListener
;
}
listener
-
>
OnStartRequest
(
aRequest
aContext
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
nsCOMPtr
<
nsIStreamListener
>
listener
;
{
MutexAutoLock
lock
(
mMutex
)
;
listener
=
mOuterListener
;
}
return
listener
-
>
OnStartRequest
(
aRequest
aContext
)
;
}
namespace
{
class
CheckOriginHeader
final
:
public
nsIHttpHeaderVisitor
{
public
:
NS_DECL_ISUPPORTS
CheckOriginHeader
(
)
:
mHeaderCount
(
0
)
{
}
NS_IMETHOD
VisitHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
)
override
{
if
(
aHeader
.
EqualsLiteral
(
"
Access
-
Control
-
Allow
-
Origin
"
)
)
{
mHeaderCount
+
+
;
}
if
(
mHeaderCount
>
1
)
{
return
NS_ERROR_DOM_BAD_URI
;
}
return
NS_OK
;
}
private
:
uint32_t
mHeaderCount
;
~
CheckOriginHeader
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
CheckOriginHeader
nsIHttpHeaderVisitor
)
}
nsresult
nsCORSListenerProxy
:
:
CheckRequestApproved
(
nsIRequest
*
aRequest
)
{
if
(
!
mHasBeenCrossSite
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIHttpChannel
>
topChannel
;
topChannel
.
swap
(
mHttpChannel
)
;
if
(
gDisableCORS
)
{
LogBlockedRequest
(
aRequest
"
CORSDisabled
"
nullptr
topChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
nsresult
status
;
nsresult
rv
=
aRequest
-
>
GetStatus
(
&
status
)
;
if
(
NS_FAILED
(
rv
)
)
{
LogBlockedRequest
(
aRequest
"
CORSDidNotSucceed
"
nullptr
topChannel
)
;
return
rv
;
}
if
(
NS_FAILED
(
status
)
)
{
LogBlockedRequest
(
aRequest
"
CORSDidNotSucceed
"
nullptr
topChannel
)
;
return
status
;
}
nsCOMPtr
<
nsIHttpChannel
>
http
=
do_QueryInterface
(
aRequest
)
;
if
(
!
http
)
{
LogBlockedRequest
(
aRequest
"
CORSRequestNotHttp
"
nullptr
topChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
http
-
>
GetLoadInfo
(
)
;
if
(
loadInfo
&
&
loadInfo
-
>
GetServiceWorkerTaintingSynthesized
(
)
)
{
return
NS_OK
;
}
RefPtr
<
CheckOriginHeader
>
visitor
=
new
CheckOriginHeader
(
)
;
nsAutoCString
allowedOriginHeader
;
rv
=
http
-
>
VisitOriginalResponseHeaders
(
visitor
)
;
if
(
NS_FAILED
(
rv
)
)
{
LogBlockedRequest
(
aRequest
"
CORSMultipleAllowOriginNotAllowed
"
nullptr
topChannel
)
;
return
rv
;
}
rv
=
http
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
Access
-
Control
-
Allow
-
Origin
"
)
allowedOriginHeader
)
;
if
(
NS_FAILED
(
rv
)
)
{
LogBlockedRequest
(
aRequest
"
CORSMissingAllowOrigin
"
nullptr
topChannel
)
;
return
rv
;
}
if
(
mWithCredentials
&
&
allowedOriginHeader
.
EqualsLiteral
(
"
*
"
)
)
{
LogBlockedRequest
(
aRequest
"
CORSNotSupportingCredentials
"
nullptr
topChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
if
(
mWithCredentials
|
|
!
allowedOriginHeader
.
EqualsLiteral
(
"
*
"
)
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsExpandedPrincipal
(
mOriginHeaderPrincipal
)
)
;
nsAutoCString
origin
;
nsContentUtils
:
:
GetASCIIOrigin
(
mOriginHeaderPrincipal
origin
)
;
if
(
!
allowedOriginHeader
.
Equals
(
origin
)
)
{
LogBlockedRequest
(
aRequest
"
CORSAllowOriginNotMatchingOrigin
"
NS_ConvertUTF8toUTF16
(
allowedOriginHeader
)
.
get
(
)
topChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
}
if
(
mWithCredentials
)
{
nsAutoCString
allowCredentialsHeader
;
rv
=
http
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
Access
-
Control
-
Allow
-
Credentials
"
)
allowCredentialsHeader
)
;
if
(
!
allowCredentialsHeader
.
EqualsLiteral
(
"
true
"
)
)
{
LogBlockedRequest
(
aRequest
"
CORSMissingAllowCredentials
"
nullptr
topChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCORSListenerProxy
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
MOZ_ASSERT
(
mInited
"
nsCORSListenerProxy
has
not
been
initialized
properly
"
)
;
nsCOMPtr
<
nsIStreamListener
>
listener
;
{
MutexAutoLock
lock
(
mMutex
)
;
listener
=
mOuterListener
.
forget
(
)
;
}
nsresult
rv
=
listener
-
>
OnStopRequest
(
aRequest
aContext
aStatusCode
)
;
mOuterNotificationCallbacks
=
nullptr
;
mHttpChannel
=
nullptr
;
return
rv
;
}
NS_IMETHODIMP
nsCORSListenerProxy
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
MOZ_ASSERT
(
mInited
"
nsCORSListenerProxy
has
not
been
initialized
properly
"
)
;
if
(
!
mRequestApproved
)
{
return
NS_ERROR_DOM_BAD_URI
;
}
nsCOMPtr
<
nsIStreamListener
>
listener
;
{
MutexAutoLock
lock
(
mMutex
)
;
listener
=
mOuterListener
;
}
return
listener
-
>
OnDataAvailable
(
aRequest
aContext
aInputStream
aOffset
aCount
)
;
}
void
nsCORSListenerProxy
:
:
SetInterceptController
(
nsINetworkInterceptController
*
aInterceptController
)
{
mInterceptController
=
aInterceptController
;
}
NS_IMETHODIMP
nsCORSListenerProxy
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIChannelEventSink
)
)
)
{
*
aResult
=
static_cast
<
nsIChannelEventSink
*
>
(
this
)
;
NS_ADDREF_THIS
(
)
;
return
NS_OK
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsINetworkInterceptController
)
)
&
&
mInterceptController
)
{
nsCOMPtr
<
nsINetworkInterceptController
>
copy
(
mInterceptController
)
;
*
aResult
=
copy
.
forget
(
)
.
take
(
)
;
return
NS_OK
;
}
return
mOuterNotificationCallbacks
?
mOuterNotificationCallbacks
-
>
GetInterface
(
aIID
aResult
)
:
NS_ERROR_NO_INTERFACE
;
}
NS_IMETHODIMP
nsCORSListenerProxy
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
aCb
)
{
nsresult
rv
;
if
(
NS_IsInternalSameURIRedirect
(
aOldChannel
aNewChannel
aFlags
)
|
|
NS_IsHSTSUpgradeRedirect
(
aOldChannel
aNewChannel
aFlags
)
)
{
rv
=
UpdateChannel
(
aNewChannel
DataURIHandling
:
:
Allow
UpdateType
:
:
InternalOrHSTSRedirect
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsCORSListenerProxy
:
:
AsyncOnChannelRedirect
:
"
"
internal
redirect
UpdateChannel
(
)
returned
failure
"
)
;
aOldChannel
-
>
Cancel
(
rv
)
;
return
rv
;
}
}
else
{
rv
=
CheckRequestApproved
(
aOldChannel
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsCOMPtr
<
nsIURI
>
oldURI
;
NS_GetFinalChannelURI
(
aOldChannel
getter_AddRefs
(
oldURI
)
)
;
if
(
oldURI
)
{
if
(
sPreflightCache
)
{
sPreflightCache
-
>
RemoveEntries
(
oldURI
mRequestingPrincipal
)
;
}
else
{
nsCOMPtr
<
nsIHttpChannelChild
>
httpChannelChild
=
do_QueryInterface
(
aOldChannel
)
;
if
(
httpChannelChild
)
{
rv
=
httpChannelChild
-
>
RemoveCorsPreflightCacheEntry
(
oldURI
mRequestingPrincipal
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
remove
CORS
preflight
cache
entry
!
"
)
;
}
}
}
}
aOldChannel
-
>
Cancel
(
NS_ERROR_DOM_BAD_URI
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
if
(
mHasBeenCrossSite
)
{
nsCOMPtr
<
nsIPrincipal
>
oldChannelPrincipal
;
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelURIPrincipal
(
aOldChannel
getter_AddRefs
(
oldChannelPrincipal
)
)
;
nsCOMPtr
<
nsIPrincipal
>
newChannelPrincipal
;
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelURIPrincipal
(
aNewChannel
getter_AddRefs
(
newChannelPrincipal
)
)
;
if
(
!
oldChannelPrincipal
|
|
!
newChannelPrincipal
)
{
rv
=
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
equal
;
rv
=
oldChannelPrincipal
-
>
Equals
(
newChannelPrincipal
&
equal
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
equal
)
{
mOriginHeaderPrincipal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
oldChannelPrincipal
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
aOldChannel
-
>
Cancel
(
rv
)
;
return
rv
;
}
}
rv
=
UpdateChannel
(
aNewChannel
DataURIHandling
:
:
Disallow
UpdateType
:
:
Default
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsCORSListenerProxy
:
:
AsyncOnChannelRedirect
:
"
"
UpdateChannel
(
)
returned
failure
"
)
;
aOldChannel
-
>
Cancel
(
rv
)
;
return
rv
;
}
}
nsCOMPtr
<
nsIChannelEventSink
>
outer
=
do_GetInterface
(
mOuterNotificationCallbacks
)
;
if
(
outer
)
{
return
outer
-
>
AsyncOnChannelRedirect
(
aOldChannel
aNewChannel
aFlags
aCb
)
;
}
aCb
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCORSListenerProxy
:
:
CheckListenerChain
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIThreadRetargetableStreamListener
>
retargetableListener
;
{
MutexAutoLock
lock
(
mMutex
)
;
retargetableListener
=
do_QueryInterface
(
mOuterListener
)
;
}
if
(
!
retargetableListener
)
{
return
NS_ERROR_NO_INTERFACE
;
}
return
retargetableListener
-
>
CheckListenerChain
(
)
;
}
bool
CheckUpgradeInsecureRequestsPreventsCORS
(
nsIPrincipal
*
aRequestingPrincipal
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsIURI
>
channelURI
;
nsresult
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
bool
isHttpScheme
=
false
;
rv
=
channelURI
-
>
SchemeIs
(
"
http
"
&
isHttpScheme
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
isHttpScheme
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
principalURI
;
rv
=
aRequestingPrincipal
-
>
GetURI
(
getter_AddRefs
(
principalURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
principalURI
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
originalURI
;
rv
=
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsAutoCString
principalHost
channelHost
origChannelHost
;
if
(
NS_FAILED
(
principalURI
-
>
GetAsciiHost
(
principalHost
)
)
|
|
NS_FAILED
(
channelURI
-
>
GetAsciiHost
(
channelHost
)
)
|
|
NS_FAILED
(
originalURI
-
>
GetAsciiHost
(
origChannelHost
)
)
)
{
return
false
;
}
if
(
!
principalHost
.
EqualsIgnoreCase
(
channelHost
.
get
(
)
)
)
{
return
false
;
}
if
(
!
channelHost
.
EqualsIgnoreCase
(
origChannelHost
.
get
(
)
)
)
{
return
false
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
rv
=
aChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
loadInfo
)
{
return
false
;
}
return
loadInfo
-
>
GetUpgradeInsecureRequests
(
)
|
|
loadInfo
-
>
GetBrowserUpgradeInsecureRequests
(
)
;
}
nsresult
nsCORSListenerProxy
:
:
UpdateChannel
(
nsIChannel
*
aChannel
DataURIHandling
aAllowDataURI
UpdateType
aUpdateType
)
{
nsCOMPtr
<
nsIURI
>
uri
originalURI
;
nsresult
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
GetLoadInfo
(
)
;
if
(
aAllowDataURI
=
=
DataURIHandling
:
:
Allow
&
&
originalURI
=
=
uri
)
{
bool
dataScheme
=
false
;
rv
=
uri
-
>
SchemeIs
(
"
data
"
&
dataScheme
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
dataScheme
)
{
return
NS_OK
;
}
if
(
loadInfo
&
&
loadInfo
-
>
GetAboutBlankInherits
(
)
&
&
NS_IsAboutBlank
(
uri
)
)
{
return
NS_OK
;
}
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internal
=
do_QueryInterface
(
aChannel
)
;
if
(
internal
)
{
rv
=
internal
-
>
SetCorsMode
(
nsIHttpChannelInternal
:
:
CORS_MODE_CORS
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
internal
-
>
SetCorsIncludeCredentials
(
mWithCredentials
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
CheckLoadURIWithPrincipal
(
mRequestingPrincipal
uri
nsIScriptSecurityManager
:
:
STANDARD
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
originalURI
!
=
uri
)
{
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
CheckLoadURIWithPrincipal
(
mRequestingPrincipal
originalURI
nsIScriptSecurityManager
:
:
STANDARD
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
mHasBeenCrossSite
&
&
NS_SUCCEEDED
(
mRequestingPrincipal
-
>
CheckMayLoad
(
uri
false
false
)
)
&
&
(
originalURI
=
=
uri
|
|
NS_SUCCEEDED
(
mRequestingPrincipal
-
>
CheckMayLoad
(
originalURI
false
false
)
)
)
)
{
return
NS_OK
;
}
if
(
CheckUpgradeInsecureRequestsPreventsCORS
(
mRequestingPrincipal
aChannel
)
)
{
return
NS_OK
;
}
rv
=
CheckPreflightNeeded
(
aChannel
aUpdateType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mHasBeenCrossSite
=
true
;
nsCString
userpass
;
uri
-
>
GetUserPass
(
userpass
)
;
NS_ENSURE_TRUE
(
userpass
.
IsEmpty
(
)
NS_ERROR_DOM_BAD_URI
)
;
if
(
nsContentUtils
:
:
IsExpandedPrincipal
(
mOriginHeaderPrincipal
)
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
LogBlockedRequest
(
aChannel
"
CORSOriginHeaderNotAdded
"
nullptr
httpChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
nsAutoCString
origin
;
rv
=
nsContentUtils
:
:
GetASCIIOrigin
(
mOriginHeaderPrincipal
origin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
http
=
do_QueryInterface
(
aChannel
)
;
NS_ENSURE_TRUE
(
http
NS_ERROR_FAILURE
)
;
rv
=
http
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Origin
"
)
origin
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mWithCredentials
&
&
(
!
loadInfo
|
|
!
loadInfo
-
>
GetEnforceSecurity
(
)
)
)
{
nsLoadFlags
flags
;
rv
=
http
-
>
GetLoadFlags
(
&
flags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
flags
|
=
nsIRequest
:
:
LOAD_ANONYMOUS
;
rv
=
http
-
>
SetLoadFlags
(
flags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mHttpChannel
=
http
;
return
NS_OK
;
}
nsresult
nsCORSListenerProxy
:
:
CheckPreflightNeeded
(
nsIChannel
*
aChannel
UpdateType
aUpdateType
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
GetLoadInfo
(
)
;
if
(
!
loadInfo
|
|
loadInfo
-
>
GetSecurityMode
(
)
!
=
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
|
|
loadInfo
-
>
GetIsPreflight
(
)
)
{
return
NS_OK
;
}
bool
doPreflight
=
loadInfo
-
>
GetForcePreflight
(
)
;
nsCOMPtr
<
nsIHttpChannel
>
http
=
do_QueryInterface
(
aChannel
)
;
if
(
!
http
)
{
LogBlockedRequest
(
aChannel
"
CORSRequestNotHttp
"
nullptr
mHttpChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
nsAutoCString
method
;
Unused
<
<
http
-
>
GetRequestMethod
(
method
)
;
if
(
!
method
.
LowerCaseEqualsLiteral
(
"
get
"
)
&
&
!
method
.
LowerCaseEqualsLiteral
(
"
post
"
)
&
&
!
method
.
LowerCaseEqualsLiteral
(
"
head
"
)
)
{
doPreflight
=
true
;
}
const
nsTArray
<
nsCString
>
&
loadInfoHeaders
=
loadInfo
-
>
CorsUnsafeHeaders
(
)
;
if
(
!
loadInfoHeaders
.
IsEmpty
(
)
)
{
doPreflight
=
true
;
}
nsTArray
<
nsCString
>
headers
;
nsAutoCString
contentTypeHeader
;
nsresult
rv
=
http
-
>
GetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Content
-
Type
"
)
contentTypeHeader
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
nsContentUtils
:
:
IsAllowedNonCorsContentType
(
contentTypeHeader
)
&
&
!
loadInfoHeaders
.
Contains
(
NS_LITERAL_CSTRING
(
"
content
-
type
"
)
nsCaseInsensitiveCStringArrayComparator
(
)
)
)
{
headers
.
AppendElements
(
loadInfoHeaders
)
;
headers
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
content
-
type
"
)
)
;
doPreflight
=
true
;
}
if
(
!
doPreflight
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internal
=
do_QueryInterface
(
http
)
;
if
(
!
internal
)
{
LogBlockedRequest
(
aChannel
"
CORSDidNotSucceed
"
nullptr
mHttpChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
internal
-
>
SetCorsPreflightParameters
(
headers
.
IsEmpty
(
)
?
loadInfoHeaders
:
headers
)
;
return
NS_OK
;
}
class
nsCORSPreflightListener
final
:
public
nsIStreamListener
public
nsIInterfaceRequestor
public
nsIChannelEventSink
{
public
:
nsCORSPreflightListener
(
nsIPrincipal
*
aReferrerPrincipal
nsICorsPreflightCallback
*
aCallback
nsILoadContext
*
aLoadContext
bool
aWithCredentials
const
nsCString
&
aPreflightMethod
const
nsTArray
<
nsCString
>
&
aPreflightHeaders
)
:
mPreflightMethod
(
aPreflightMethod
)
mPreflightHeaders
(
aPreflightHeaders
)
mReferrerPrincipal
(
aReferrerPrincipal
)
mCallback
(
aCallback
)
mLoadContext
(
aLoadContext
)
mWithCredentials
(
aWithCredentials
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSICHANNELEVENTSINK
nsresult
CheckPreflightRequestApproved
(
nsIRequest
*
aRequest
)
;
private
:
~
nsCORSPreflightListener
(
)
=
default
;
void
AddResultToCache
(
nsIRequest
*
aRequest
)
;
nsCString
mPreflightMethod
;
nsTArray
<
nsCString
>
mPreflightHeaders
;
nsCOMPtr
<
nsIPrincipal
>
mReferrerPrincipal
;
nsCOMPtr
<
nsICorsPreflightCallback
>
mCallback
;
nsCOMPtr
<
nsILoadContext
>
mLoadContext
;
bool
mWithCredentials
;
}
;
NS_IMPL_ISUPPORTS
(
nsCORSPreflightListener
nsIStreamListener
nsIRequestObserver
nsIInterfaceRequestor
nsIChannelEventSink
)
void
nsCORSPreflightListener
:
:
AddResultToCache
(
nsIRequest
*
aRequest
)
{
nsCOMPtr
<
nsIHttpChannel
>
http
=
do_QueryInterface
(
aRequest
)
;
NS_ASSERTION
(
http
"
Request
was
not
http
"
)
;
nsAutoCString
headerVal
;
Unused
<
<
http
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
Access
-
Control
-
Max
-
Age
"
)
headerVal
)
;
if
(
headerVal
.
IsEmpty
(
)
)
{
return
;
}
uint32_t
age
=
0
;
nsACString
:
:
const_char_iterator
iter
end
;
headerVal
.
BeginReading
(
iter
)
;
headerVal
.
EndReading
(
end
)
;
while
(
iter
!
=
end
)
{
if
(
*
iter
<
'
0
'
|
|
*
iter
>
'
9
'
)
{
return
;
}
age
=
age
*
10
+
(
*
iter
-
'
0
'
)
;
age
=
std
:
:
min
(
age
86400U
)
;
+
+
iter
;
}
if
(
!
age
|
|
!
EnsurePreflightCache
(
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
NS_GetFinalChannelURI
(
http
getter_AddRefs
(
uri
)
)
;
TimeStamp
expirationTime
=
TimeStamp
:
:
NowLoRes
(
)
+
TimeDuration
:
:
FromSeconds
(
age
)
;
nsPreflightCache
:
:
CacheEntry
*
entry
=
sPreflightCache
-
>
GetEntry
(
uri
mReferrerPrincipal
mWithCredentials
true
)
;
if
(
!
entry
)
{
return
;
}
Unused
<
<
http
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
Access
-
Control
-
Allow
-
Methods
"
)
headerVal
)
;
nsCCharSeparatedTokenizer
methods
(
headerVal
'
'
)
;
while
(
methods
.
hasMoreTokens
(
)
)
{
const
nsDependentCSubstring
&
method
=
methods
.
nextToken
(
)
;
if
(
method
.
IsEmpty
(
)
)
{
continue
;
}
uint32_t
i
;
for
(
i
=
0
;
i
<
entry
-
>
mMethods
.
Length
(
)
;
+
+
i
)
{
if
(
entry
-
>
mMethods
[
i
]
.
token
.
Equals
(
method
)
)
{
entry
-
>
mMethods
[
i
]
.
expirationTime
=
expirationTime
;
break
;
}
}
if
(
i
=
=
entry
-
>
mMethods
.
Length
(
)
)
{
nsPreflightCache
:
:
TokenTime
*
newMethod
=
entry
-
>
mMethods
.
AppendElement
(
)
;
if
(
!
newMethod
)
{
return
;
}
newMethod
-
>
token
=
method
;
newMethod
-
>
expirationTime
=
expirationTime
;
}
}
Unused
<
<
http
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
Access
-
Control
-
Allow
-
Headers
"
)
headerVal
)
;
nsCCharSeparatedTokenizer
headers
(
headerVal
'
'
)
;
while
(
headers
.
hasMoreTokens
(
)
)
{
const
nsDependentCSubstring
&
header
=
headers
.
nextToken
(
)
;
if
(
header
.
IsEmpty
(
)
)
{
continue
;
}
uint32_t
i
;
for
(
i
=
0
;
i
<
entry
-
>
mHeaders
.
Length
(
)
;
+
+
i
)
{
if
(
entry
-
>
mHeaders
[
i
]
.
token
.
Equals
(
header
)
)
{
entry
-
>
mHeaders
[
i
]
.
expirationTime
=
expirationTime
;
break
;
}
}
if
(
i
=
=
entry
-
>
mHeaders
.
Length
(
)
)
{
nsPreflightCache
:
:
TokenTime
*
newHeader
=
entry
-
>
mHeaders
.
AppendElement
(
)
;
if
(
!
newHeader
)
{
return
;
}
newHeader
-
>
token
=
header
;
newHeader
-
>
expirationTime
=
expirationTime
;
}
}
}
NS_IMETHODIMP
nsCORSPreflightListener
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
?
channel
-
>
GetLoadInfo
(
)
:
nullptr
;
MOZ_ASSERT
(
!
loadInfo
|
|
!
loadInfo
-
>
GetServiceWorkerTaintingSynthesized
(
)
)
;
}
#
endif
nsresult
rv
=
CheckPreflightRequestApproved
(
aRequest
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
AddResultToCache
(
aRequest
)
;
mCallback
-
>
OnPreflightSucceeded
(
)
;
}
else
{
mCallback
-
>
OnPreflightFailed
(
rv
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsCORSPreflightListener
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
)
{
mCallback
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCORSPreflightListener
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
ctxt
nsIInputStream
*
inStr
uint64_t
sourceOffset
uint32_t
count
)
{
uint32_t
totalRead
;
return
inStr
-
>
ReadSegments
(
NS_DiscardSegment
nullptr
count
&
totalRead
)
;
}
NS_IMETHODIMP
nsCORSPreflightListener
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
callback
)
{
if
(
!
NS_IsInternalSameURIRedirect
(
aOldChannel
aNewChannel
aFlags
)
&
&
!
NS_IsHSTSUpgradeRedirect
(
aOldChannel
aNewChannel
aFlags
)
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aOldChannel
)
;
LogBlockedRequest
(
aOldChannel
"
CORSExternalRedirectNotAllowed
"
nullptr
httpChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
callback
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
nsresult
nsCORSPreflightListener
:
:
CheckPreflightRequestApproved
(
nsIRequest
*
aRequest
)
{
nsresult
status
;
nsresult
rv
=
aRequest
-
>
GetStatus
(
&
status
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_SUCCESS
(
status
status
)
;
nsCOMPtr
<
nsIHttpChannel
>
http
=
do_QueryInterface
(
aRequest
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
internal
=
do_QueryInterface
(
aRequest
)
;
NS_ENSURE_STATE
(
internal
)
;
nsCOMPtr
<
nsIHttpChannel
>
parentHttpChannel
=
do_QueryInterface
(
mCallback
)
;
bool
succeedded
;
rv
=
http
-
>
GetRequestSucceeded
(
&
succeedded
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
succeedded
)
{
LogBlockedRequest
(
aRequest
"
CORSPreflightDidNotSucceed
"
nullptr
parentHttpChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
nsAutoCString
headerVal
;
Unused
<
<
http
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
Access
-
Control
-
Allow
-
Methods
"
)
headerVal
)
;
bool
foundMethod
=
mPreflightMethod
.
EqualsLiteral
(
"
GET
"
)
|
|
mPreflightMethod
.
EqualsLiteral
(
"
HEAD
"
)
|
|
mPreflightMethod
.
EqualsLiteral
(
"
POST
"
)
;
nsCCharSeparatedTokenizer
methodTokens
(
headerVal
'
'
)
;
while
(
methodTokens
.
hasMoreTokens
(
)
)
{
const
nsDependentCSubstring
&
method
=
methodTokens
.
nextToken
(
)
;
if
(
method
.
IsEmpty
(
)
)
{
continue
;
}
if
(
!
NS_IsValidHTTPToken
(
method
)
)
{
LogBlockedRequest
(
aRequest
"
CORSInvalidAllowMethod
"
NS_ConvertUTF8toUTF16
(
method
)
.
get
(
)
parentHttpChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
foundMethod
|
=
mPreflightMethod
.
Equals
(
method
)
;
}
if
(
!
foundMethod
)
{
LogBlockedRequest
(
aRequest
"
CORSMethodNotFound
"
nullptr
parentHttpChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
Unused
<
<
http
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
Access
-
Control
-
Allow
-
Headers
"
)
headerVal
)
;
nsTArray
<
nsCString
>
headers
;
nsCCharSeparatedTokenizer
headerTokens
(
headerVal
'
'
)
;
while
(
headerTokens
.
hasMoreTokens
(
)
)
{
const
nsDependentCSubstring
&
header
=
headerTokens
.
nextToken
(
)
;
if
(
header
.
IsEmpty
(
)
)
{
continue
;
}
if
(
!
NS_IsValidHTTPToken
(
header
)
)
{
LogBlockedRequest
(
aRequest
"
CORSInvalidAllowHeader
"
NS_ConvertUTF8toUTF16
(
header
)
.
get
(
)
parentHttpChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
headers
.
AppendElement
(
header
)
;
}
for
(
uint32_t
i
=
0
;
i
<
mPreflightHeaders
.
Length
(
)
;
+
+
i
)
{
const
auto
&
comparator
=
nsCaseInsensitiveCStringArrayComparator
(
)
;
if
(
!
headers
.
Contains
(
mPreflightHeaders
[
i
]
comparator
)
)
{
LogBlockedRequest
(
aRequest
"
CORSMissingAllowHeaderFromPreflight
"
NS_ConvertUTF8toUTF16
(
mPreflightHeaders
[
i
]
)
.
get
(
)
parentHttpChannel
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCORSPreflightListener
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsILoadContext
)
)
&
&
mLoadContext
)
{
nsCOMPtr
<
nsILoadContext
>
copy
=
mLoadContext
;
copy
.
forget
(
aResult
)
;
return
NS_OK
;
}
return
QueryInterface
(
aIID
aResult
)
;
}
void
nsCORSListenerProxy
:
:
RemoveFromCorsPreflightCache
(
nsIURI
*
aURI
nsIPrincipal
*
aRequestingPrincipal
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
sPreflightCache
)
{
sPreflightCache
-
>
RemoveEntries
(
aURI
aRequestingPrincipal
)
;
}
}
nsresult
nsCORSListenerProxy
:
:
StartCORSPreflight
(
nsIChannel
*
aRequestChannel
nsICorsPreflightCallback
*
aCallback
nsTArray
<
nsCString
>
&
aUnsafeHeaders
nsIChannel
*
*
aPreflightChannel
)
{
*
aPreflightChannel
=
nullptr
;
if
(
gDisableCORS
)
{
nsCOMPtr
<
nsIHttpChannel
>
http
=
do_QueryInterface
(
aRequestChannel
)
;
LogBlockedRequest
(
aRequestChannel
"
CORSDisabled
"
nullptr
http
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
nsAutoCString
method
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aRequestChannel
)
)
;
NS_ENSURE_TRUE
(
httpChannel
NS_ERROR_UNEXPECTED
)
;
Unused
<
<
httpChannel
-
>
GetRequestMethod
(
method
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_GetFinalChannelURI
(
aRequestChannel
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
originalLoadInfo
=
aRequestChannel
-
>
GetLoadInfo
(
)
;
MOZ_ASSERT
(
originalLoadInfo
"
can
not
perform
CORS
preflight
without
a
loadInfo
"
)
;
if
(
!
originalLoadInfo
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
originalLoadInfo
-
>
GetSecurityMode
(
)
=
=
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
"
how
did
we
end
up
here
?
"
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
originalLoadInfo
-
>
LoadingPrincipal
(
)
;
MOZ_ASSERT
(
principal
&
&
originalLoadInfo
-
>
GetExternalContentPolicyType
(
)
!
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
"
Should
not
do
CORS
loads
for
top
-
level
loads
so
a
loadingPrincipal
should
always
exist
.
"
)
;
bool
withCredentials
=
originalLoadInfo
-
>
GetCookiePolicy
(
)
=
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
nsPreflightCache
:
:
CacheEntry
*
entry
=
sPreflightCache
?
sPreflightCache
-
>
GetEntry
(
uri
principal
withCredentials
false
)
:
nullptr
;
if
(
entry
&
&
entry
-
>
CheckRequest
(
method
aUnsafeHeaders
)
)
{
aCallback
-
>
OnPreflightSucceeded
(
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
static_cast
<
mozilla
:
:
net
:
:
LoadInfo
*
>
(
originalLoadInfo
.
get
(
)
)
-
>
CloneForNewRequest
(
)
;
static_cast
<
mozilla
:
:
net
:
:
LoadInfo
*
>
(
loadInfo
.
get
(
)
)
-
>
SetIsPreflight
(
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
rv
=
aRequestChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
rv
=
aRequestChannel
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
do_GetInterface
(
callbacks
)
;
nsLoadFlags
loadFlags
;
rv
=
aRequestChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
loadFlags
|
=
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
|
nsIRequest
:
:
LOAD_ANONYMOUS
;
nsCOMPtr
<
nsIChannel
>
preflightChannel
;
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
preflightChannel
)
uri
loadInfo
nullptr
loadGroup
nullptr
loadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
preHttp
=
do_QueryInterface
(
preflightChannel
)
;
NS_ASSERTION
(
preHttp
"
Failed
to
QI
to
nsIHttpChannel
!
"
)
;
rv
=
preHttp
-
>
SetRequestMethod
(
NS_LITERAL_CSTRING
(
"
OPTIONS
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
preHttp
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Access
-
Control
-
Request
-
Method
"
)
method
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
nsHttpChannel
>
reqCh
=
do_QueryObject
(
aRequestChannel
)
;
RefPtr
<
nsHttpChannel
>
preCh
=
do_QueryObject
(
preHttp
)
;
if
(
preCh
&
&
reqCh
)
{
preCh
-
>
SetWarningReporter
(
reqCh
-
>
GetWarningReporter
(
)
)
;
}
nsTArray
<
nsCString
>
preflightHeaders
;
if
(
!
aUnsafeHeaders
.
IsEmpty
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
aUnsafeHeaders
.
Length
(
)
;
+
+
i
)
{
preflightHeaders
.
AppendElement
(
)
;
ToLowerCase
(
aUnsafeHeaders
[
i
]
preflightHeaders
[
i
]
)
;
}
preflightHeaders
.
Sort
(
)
;
nsAutoCString
headers
;
for
(
uint32_t
i
=
0
;
i
<
preflightHeaders
.
Length
(
)
;
+
+
i
)
{
if
(
i
!
=
0
)
{
headers
+
=
'
'
;
}
headers
+
=
preflightHeaders
[
i
]
;
}
rv
=
preHttp
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Access
-
Control
-
Request
-
Headers
"
)
headers
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
RefPtr
<
nsCORSPreflightListener
>
preflightListener
=
new
nsCORSPreflightListener
(
principal
aCallback
loadContext
withCredentials
method
preflightHeaders
)
;
rv
=
preflightChannel
-
>
SetNotificationCallbacks
(
preflightListener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
preflightChannel
-
>
AsyncOpen2
(
preflightListener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
preflightChannel
.
forget
(
aPreflightChannel
)
;
return
NS_OK
;
}
void
nsCORSListenerProxy
:
:
LogBlockedCORSRequest
(
uint64_t
aInnerWindowID
bool
aPrivateBrowsing
const
nsAString
&
aMessage
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
log
blocked
cross
-
site
request
(
no
console
)
"
)
;
return
;
}
nsCOMPtr
<
nsIScriptError
>
scriptError
=
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
log
blocked
cross
-
site
request
(
no
scriptError
)
"
)
;
return
;
}
if
(
aInnerWindowID
>
0
)
{
rv
=
scriptError
-
>
InitWithSanitizedSource
(
aMessage
EmptyString
(
)
EmptyString
(
)
0
0
nsIScriptError
:
:
warningFlag
"
CORS
"
aInnerWindowID
)
;
}
else
{
rv
=
scriptError
-
>
Init
(
aMessage
EmptyString
(
)
EmptyString
(
)
0
0
nsIScriptError
:
:
warningFlag
"
CORS
"
aPrivateBrowsing
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
log
blocked
cross
-
site
request
(
scriptError
init
failed
)
"
)
;
return
;
}
console
-
>
LogMessage
(
scriptError
)
;
}
