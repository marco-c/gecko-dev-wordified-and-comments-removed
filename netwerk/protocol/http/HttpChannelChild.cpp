#
include
"
HttpLog
.
h
"
#
include
"
nsHttp
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
PerfStats
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
extensions
/
StreamFilterParent
.
h
"
#
include
"
mozilla
/
ipc
/
IPCStreamUtils
.
h
"
#
include
"
mozilla
/
net
/
NeckoChild
.
h
"
#
include
"
mozilla
/
net
/
HttpChannelChild
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierCommon
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureFactory
.
h
"
#
include
"
AltDataOutputStreamChild
.
h
"
#
include
"
CookieServiceChild
.
h
"
#
include
"
HttpBackgroundChannelChild
.
h
"
#
include
"
NetworkMarker
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsHttpChannel
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceStorage
.
h
"
#
include
"
mozilla
/
ipc
/
InputStreamUtils
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessBridgeChild
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
StoragePrincipalHelper
.
h
"
#
include
"
SerializedLoadContext
.
h
"
#
include
"
nsInputStreamPump
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsICompressConvStats
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsRedirectHistoryEntry
.
h
"
#
include
"
nsSocketTransportService2
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsCORSListenerProxy
.
h
"
#
include
"
ClassifierDummyChannel
.
h
"
#
include
"
nsIOService
.
h
"
#
include
<
functional
>
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
:
:
net
{
HttpChannelChild
:
:
HttpChannelChild
(
)
:
HttpAsyncAborter
<
HttpChannelChild
>
(
this
)
NeckoTargetHolder
(
nullptr
)
mCacheEntryAvailable
(
false
)
mAltDataCacheEntryAvailable
(
false
)
mSendResumeAt
(
false
)
mKeptAlive
(
false
)
mIPCActorDeleted
(
false
)
mSuspendSent
(
false
)
mIsFirstPartOfMultiPart
(
false
)
mIsLastPartOfMultiPart
(
false
)
mSuspendForWaitCompleteRedirectSetup
(
false
)
mRecvOnStartRequestSentCalled
(
false
)
mSuspendedByWaitingForPermissionCookie
(
false
)
{
LOG
(
(
"
Creating
HttpChannelChild
%
p
\
n
"
this
)
)
;
mChannelCreationTime
=
PR_Now
(
)
;
mChannelCreationTimestamp
=
TimeStamp
:
:
Now
(
)
;
mLastStatusReported
=
mChannelCreationTimestamp
;
mAsyncOpenTime
=
TimeStamp
:
:
Now
(
)
;
mEventQ
=
new
ChannelEventQueue
(
static_cast
<
nsIHttpChannel
*
>
(
this
)
)
;
RefPtr
<
CookieServiceChild
>
cookieService
=
CookieServiceChild
:
:
GetSingleton
(
)
;
}
HttpChannelChild
:
:
~
HttpChannelChild
(
)
{
LOG
(
(
"
Destroying
HttpChannelChild
%
p
\
n
"
this
)
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
if
(
mDoDiagnosticAssertWhenOnStopNotCalledOnDestroy
&
&
mAsyncOpenSucceeded
&
&
!
mSuccesfullyRedirected
&
&
!
LoadOnStopRequestCalled
(
)
)
{
bool
emptyBgChildQueue
nullBgChild
;
{
MutexAutoLock
lock
(
mBgChildMutex
)
;
nullBgChild
=
!
mBgChild
;
emptyBgChildQueue
=
!
nullBgChild
&
&
mBgChild
-
>
IsQueueEmpty
(
)
;
}
uint32_t
flags
=
(
mRedirectChannelChild
?
1
<
<
0
:
0
)
|
(
mEventQ
-
>
IsEmpty
(
)
?
1
<
<
1
:
0
)
|
(
nullBgChild
?
1
<
<
2
:
0
)
|
(
emptyBgChildQueue
?
1
<
<
3
:
0
)
|
(
LoadOnStartRequestCalled
(
)
?
1
<
<
4
:
0
)
|
(
mBackgroundChildQueueFinalState
=
=
BCKCHILD_EMPTY
?
1
<
<
5
:
0
)
|
(
mBackgroundChildQueueFinalState
=
=
BCKCHILD_NON_EMPTY
?
1
<
<
6
:
0
)
|
(
mRemoteChannelExistedAtCancel
?
1
<
<
7
:
0
)
|
(
mEverHadBgChildAtAsyncOpen
?
1
<
<
8
:
0
)
|
(
mEverHadBgChildAtConnectParent
?
1
<
<
9
:
0
)
|
(
mCreateBackgroundChannelFailed
?
1
<
<
10
:
0
)
|
(
mBgInitFailCallbackTriggered
?
1
<
<
11
:
0
)
|
(
mCanSendAtCancel
?
1
<
<
12
:
0
)
|
(
!
!
mSuspendCount
?
1
<
<
13
:
0
)
|
(
!
!
mCallOnResume
?
1
<
<
14
:
0
)
;
MOZ_CRASH_UNSAFE_PRINTF
(
"
~
HttpChannelChild
LoadOnStopRequestCalled
(
)
=
false
mStatus
=
0x
%
08x
"
"
mActorDestroyReason
=
%
d
20200717
flags
=
%
u
"
static_cast
<
uint32_t
>
(
nsresult
(
mStatus
)
)
static_cast
<
int32_t
>
(
mActorDestroyReason
?
*
mActorDestroyReason
:
-
1
)
flags
)
;
}
#
endif
mEventQ
-
>
NotifyReleasingOwner
(
)
;
ReleaseMainThreadOnlyReferences
(
)
;
}
void
HttpChannelChild
:
:
ReleaseMainThreadOnlyReferences
(
)
{
if
(
NS_IsMainThread
(
)
)
{
return
;
}
NS_ReleaseOnMainThread
(
"
HttpChannelChild
:
:
mRedirectChannelChild
"
mRedirectChannelChild
.
forget
(
)
)
;
}
NS_IMPL_ADDREF
(
HttpChannelChild
)
NS_IMETHODIMP_
(
MozExternalRefCountType
)
HttpChannelChild
:
:
Release
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsrefcnt
count
=
mRefCnt
;
nsresult
rv
=
NS_DispatchToMainThread
(
NewNonOwningRunnableMethod
(
"
HttpChannelChild
:
:
Release
"
this
&
HttpChannelChild
:
:
Release
)
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
count
-
1
;
}
}
nsrefcnt
count
=
-
-
mRefCnt
;
MOZ_ASSERT
(
int32_t
(
count
)
>
=
0
"
dup
release
"
)
;
if
(
mKeptAlive
&
&
count
=
=
1
&
&
CanSend
(
)
)
{
NS_LOG_RELEASE
(
this
1
"
HttpChannelChild
"
)
;
mKeptAlive
=
false
;
TrySendDeletingChannel
(
)
;
return
1
;
}
if
(
count
=
=
0
)
{
mRefCnt
=
1
;
if
(
MOZ_LIKELY
(
LoadOnStartRequestCalled
(
)
&
&
LoadOnStopRequestCalled
(
)
)
|
|
!
mListener
)
{
NS_LOG_RELEASE
(
this
0
"
HttpChannelChild
"
)
;
delete
this
;
return
0
;
}
if
(
NS_SUCCEEDED
(
mStatus
)
)
{
mStatus
=
NS_ERROR_ABORT
;
}
NS_LOG_ADDREF
(
this
2
"
HttpChannelChild
"
sizeof
(
*
this
)
)
;
NS_LOG_RELEASE
(
this
1
"
HttpChannelChild
"
)
;
RefPtr
<
HttpChannelChild
>
channel
=
dont_AddRef
(
this
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
~
HttpChannelChild
>
DoNotifyListener
"
channel
&
HttpChannelChild
:
:
DoNotifyListener
)
)
;
MOZ_ASSERT
(
!
mKeptAlive
|
|
!
CanSend
(
)
)
;
channel
=
nullptr
;
return
mRefCnt
;
}
NS_LOG_RELEASE
(
this
count
"
HttpChannelChild
"
)
;
return
count
;
}
NS_INTERFACE_MAP_BEGIN
(
HttpChannelChild
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequest
)
NS_INTERFACE_MAP_ENTRY
(
nsIChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIHttpChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIHttpChannelInternal
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
nsICacheInfoChannel
!
mMultiPartID
.
isSome
(
)
)
NS_INTERFACE_MAP_ENTRY
(
nsIResumableChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsPriority
)
NS_INTERFACE_MAP_ENTRY
(
nsIClassOfService
)
NS_INTERFACE_MAP_ENTRY
(
nsIProxiedChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsITraceableChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIAsyncVerifyRedirectCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsIChildChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIHttpChannelChild
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
nsIMultiPartChannel
mMultiPartID
.
isSome
(
)
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
nsIThreadRetargetableRequest
!
mMultiPartID
.
isSome
(
)
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
HttpChannelChild
)
NS_INTERFACE_MAP_END_INHERITING
(
HttpBaseChannel
)
void
HttpChannelChild
:
:
OnBackgroundChildReady
(
HttpBackgroundChannelChild
*
aBgChild
)
{
LOG
(
(
"
HttpChannelChild
:
:
OnBackgroundChildReady
[
this
=
%
p
bgChild
=
%
p
]
\
n
"
this
aBgChild
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
{
MutexAutoLock
lock
(
mBgChildMutex
)
;
if
(
mBgChild
!
=
aBgChild
)
{
return
;
}
MOZ_ASSERT
(
mBgInitFailCallback
)
;
mBgInitFailCallback
=
nullptr
;
}
}
void
HttpChannelChild
:
:
OnBackgroundChildDestroyed
(
HttpBackgroundChannelChild
*
aBgChild
)
{
LOG
(
(
"
HttpChannelChild
:
:
OnBackgroundChildDestroyed
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
gSocketTransportService
)
;
MOZ_ASSERT
(
gSocketTransportService
-
>
IsOnCurrentThreadInfallible
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
callback
;
{
MutexAutoLock
lock
(
mBgChildMutex
)
;
if
(
aBgChild
!
=
mBgChild
)
{
return
;
}
mBgChild
=
nullptr
;
callback
=
std
:
:
move
(
mBgInitFailCallback
)
;
}
if
(
callback
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mBgInitFailCallbackTriggered
=
true
;
#
endif
nsCOMPtr
<
nsISerialEventTarget
>
neckoTarget
=
GetNeckoTarget
(
)
;
neckoTarget
-
>
Dispatch
(
callback
NS_DISPATCH_NORMAL
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelChild
:
:
RecvOnStartRequestSent
(
)
{
LOG
(
(
"
HttpChannelChild
:
:
RecvOnStartRequestSent
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mRecvOnStartRequestSentCalled
)
;
mRecvOnStartRequestSentCalled
=
true
;
if
(
mSuspendedByWaitingForPermissionCookie
)
{
mSuspendedByWaitingForPermissionCookie
=
false
;
mEventQ
-
>
Resume
(
)
;
}
return
IPC_OK
(
)
;
}
void
HttpChannelChild
:
:
ProcessOnStartRequest
(
const
nsHttpResponseHead
&
aResponseHead
const
bool
&
aUseResponseHead
const
nsHttpHeaderArray
&
aRequestHeaders
const
HttpChannelOnStartRequestArgs
&
aArgs
const
HttpChannelAltDataStream
&
aAltData
)
{
LOG
(
(
"
HttpChannelChild
:
:
ProcessOnStartRequest
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
#
ifdef
NIGHTLY_BUILD
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
#
endif
mAltDataInputStream
=
DeserializeIPCStream
(
aAltData
.
altDataInputStream
(
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
aResponseHead
#
ifdef
NIGHTLY_BUILD
aUseResponseHead
aRequestHeaders
aArgs
start
]
(
)
{
if
(
self
-
>
mLoadFlags
&
nsIRequest
:
:
LOAD_RECORD_START_REQUEST_DELAY
)
{
TimeDuration
delay
=
TimeStamp
:
:
Now
(
)
-
start
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_PRELOAD_IMAGE_STARTREQUEST_DELAY
static_cast
<
uint32_t
>
(
delay
.
ToMilliseconds
(
)
)
)
;
}
#
else
aUseResponseHead
aRequestHeaders
aArgs
]
(
)
{
#
endif
self
-
>
OnStartRequest
(
aResponseHead
aUseResponseHead
aRequestHeaders
aArgs
)
;
}
)
)
;
}
static
void
ResourceTimingStructArgsToTimingsStruct
(
const
ResourceTimingStructArgs
&
aArgs
TimingStruct
&
aTimings
)
{
aTimings
.
domainLookupStart
=
aArgs
.
domainLookupStart
(
)
;
aTimings
.
domainLookupEnd
=
aArgs
.
domainLookupEnd
(
)
;
aTimings
.
connectStart
=
aArgs
.
connectStart
(
)
;
aTimings
.
tcpConnectEnd
=
aArgs
.
tcpConnectEnd
(
)
;
aTimings
.
secureConnectionStart
=
aArgs
.
secureConnectionStart
(
)
;
aTimings
.
connectEnd
=
aArgs
.
connectEnd
(
)
;
aTimings
.
requestStart
=
aArgs
.
requestStart
(
)
;
aTimings
.
responseStart
=
aArgs
.
responseStart
(
)
;
aTimings
.
responseEnd
=
aArgs
.
responseEnd
(
)
;
}
void
HttpChannelChild
:
:
OnStartRequest
(
const
nsHttpResponseHead
&
aResponseHead
const
bool
&
aUseResponseHead
const
nsHttpHeaderArray
&
aRequestHeaders
const
HttpChannelOnStartRequestArgs
&
aArgs
)
{
LOG
(
(
"
HttpChannelChild
:
:
OnStartRequest
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
LoadOnStartRequestCalled
(
)
&
&
mIPCActorDeleted
)
{
return
;
}
mComputedCrossOriginOpenerPolicy
=
aArgs
.
openerPolicy
(
)
;
if
(
!
mCanceled
&
&
NS_SUCCEEDED
(
mStatus
)
)
{
mStatus
=
aArgs
.
channelStatus
(
)
;
}
MOZ_ASSERT
(
!
aRequestHeaders
.
HasHeader
(
nsHttp
:
:
Cookie
)
)
;
MOZ_ASSERT
(
!
nsHttpResponseHead
(
aResponseHead
)
.
HasHeader
(
nsHttp
:
:
Set_Cookie
)
)
;
if
(
aUseResponseHead
&
&
!
mCanceled
)
{
mResponseHead
=
MakeUnique
<
nsHttpResponseHead
>
(
aResponseHead
)
;
}
if
(
!
aArgs
.
securityInfoSerialization
(
)
.
IsEmpty
(
)
)
{
[
[
maybe_unused
]
]
nsresult
rv
=
NS_DeserializeObject
(
aArgs
.
securityInfoSerialization
(
)
getter_AddRefs
(
mSecurityInfo
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserializing
security
info
should
not
fail
"
)
;
}
ipc
:
:
MergeParentLoadInfoForwarder
(
aArgs
.
loadInfoForwarder
(
)
mLoadInfo
)
;
mIsFromCache
=
aArgs
.
isFromCache
(
)
;
mIsRacing
=
aArgs
.
isRacing
(
)
;
mCacheEntryAvailable
=
aArgs
.
cacheEntryAvailable
(
)
;
mCacheEntryId
=
aArgs
.
cacheEntryId
(
)
;
mCacheFetchCount
=
aArgs
.
cacheFetchCount
(
)
;
mCacheExpirationTime
=
aArgs
.
cacheExpirationTime
(
)
;
mSelfAddr
=
aArgs
.
selfAddr
(
)
;
mPeerAddr
=
aArgs
.
peerAddr
(
)
;
mRedirectCount
=
aArgs
.
redirectCount
(
)
;
mAvailableCachedAltDataType
=
aArgs
.
altDataType
(
)
;
StoreDeliveringAltData
(
aArgs
.
deliveringAltData
(
)
)
;
mAltDataLength
=
aArgs
.
altDataLength
(
)
;
StoreResolvedByTRR
(
aArgs
.
isResolvedByTRR
(
)
)
;
SetApplyConversion
(
aArgs
.
applyConversion
(
)
)
;
StoreAfterOnStartRequestBegun
(
true
)
;
StoreHasHTTPSRR
(
aArgs
.
hasHTTPSRR
(
)
)
;
AutoEventEnqueuer
ensureSerialDispatch
(
mEventQ
)
;
mCacheKey
=
aArgs
.
cacheKey
(
)
;
mRequestHead
.
SetHeaders
(
aRequestHeaders
)
;
ResourceTimingStructArgsToTimingsStruct
(
aArgs
.
timing
(
)
mTransactionTimings
)
;
StoreAllRedirectsSameOrigin
(
aArgs
.
allRedirectsSameOrigin
(
)
)
;
mMultiPartID
=
aArgs
.
multiPartID
(
)
;
mIsFirstPartOfMultiPart
=
aArgs
.
isFirstPartOfMultiPart
(
)
;
mIsLastPartOfMultiPart
=
aArgs
.
isLastPartOfMultiPart
(
)
;
if
(
aArgs
.
overrideReferrerInfo
(
)
)
{
Unused
<
<
SetReferrerInfoInternal
(
aArgs
.
overrideReferrerInfo
(
)
false
true
false
)
;
}
if
(
!
aArgs
.
cookie
(
)
.
IsEmpty
(
)
)
{
SetCookie
(
aArgs
.
cookie
(
)
)
;
}
if
(
aArgs
.
shouldWaitForOnStartRequestSent
(
)
&
&
!
mRecvOnStartRequestSentCalled
)
{
LOG
(
(
"
>
pending
DoOnStartRequest
until
RecvOnStartRequestSent
\
n
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mEventQ
-
>
Suspend
(
)
;
mSuspendedByWaitingForPermissionCookie
=
true
;
mEventQ
-
>
PrependEvent
(
MakeUnique
<
NeckoTargetChannelFunctionEvent
>
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
]
(
)
{
self
-
>
DoOnStartRequest
(
self
)
;
}
)
)
;
return
;
}
if
(
mResponseHead
)
{
mSupportsHTTP3
=
nsHttpHandler
:
:
IsHttp3SupportedByServer
(
mResponseHead
.
get
(
)
)
;
}
DoOnStartRequest
(
this
)
;
}
void
HttpChannelChild
:
:
ProcessOnAfterLastPart
(
const
nsresult
&
aStatus
)
{
LOG
(
(
"
HttpChannelChild
:
:
ProcessOnAfterLastPart
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
aStatus
]
(
)
{
self
-
>
OnAfterLastPart
(
aStatus
)
;
}
)
)
;
}
void
HttpChannelChild
:
:
OnAfterLastPart
(
const
nsresult
&
aStatus
)
{
if
(
LoadOnStopRequestCalled
(
)
)
{
return
;
}
StoreOnStopRequestCalled
(
true
)
;
gHttpHandler
-
>
OnStopRequest
(
this
)
;
ReleaseListeners
(
)
;
if
(
!
mPreferredCachedAltDataTypes
.
IsEmpty
(
)
)
{
mAltDataCacheEntryAvailable
=
mCacheEntryAvailable
;
}
mCacheEntryAvailable
=
false
;
if
(
mLoadGroup
)
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
mStatus
)
;
CleanupBackgroundChannel
(
)
;
if
(
mLoadFlags
&
LOAD_DOCUMENT_URI
)
{
if
(
CanSend
(
)
)
{
mKeptAlive
=
true
;
SendDocumentChannelCleanup
(
true
)
;
}
}
else
{
TrySendDeletingChannel
(
)
;
}
}
void
HttpChannelChild
:
:
DoOnStartRequest
(
nsIRequest
*
aRequest
)
{
nsresult
rv
;
LOG
(
(
"
HttpChannelChild
:
:
DoOnStartRequest
[
this
=
%
p
]
\
n
"
this
)
)
;
StoreTracingEnabled
(
false
)
;
MOZ_ASSERT
(
mListener
|
|
LoadOnStartRequestCalled
(
)
)
;
if
(
!
mListener
)
{
Cancel
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
mListener
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
(
mListener
)
;
StoreOnStartRequestCalled
(
true
)
;
rv
=
listener
-
>
OnStartRequest
(
aRequest
)
;
}
else
{
rv
=
NS_ERROR_UNEXPECTED
;
}
StoreOnStartRequestCalled
(
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
Cancel
(
rv
)
;
return
;
}
nsCOMPtr
<
nsIStreamListener
>
listener
;
rv
=
DoApplyContentConversions
(
mListener
getter_AddRefs
(
listener
)
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
Cancel
(
rv
)
;
}
else
if
(
listener
)
{
mListener
=
listener
;
mCompressListener
=
listener
;
}
}
void
HttpChannelChild
:
:
ProcessOnTransportAndData
(
const
nsresult
&
aChannelStatus
const
nsresult
&
aTransportStatus
const
uint64_t
&
aOffset
const
uint32_t
&
aCount
const
nsACString
&
aData
)
{
LOG
(
(
"
HttpChannelChild
:
:
ProcessOnTransportAndData
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
ChannelFunctionEvent
(
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
]
(
)
{
return
self
-
>
GetODATarget
(
)
;
}
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
aChannelStatus
aTransportStatus
aOffset
aCount
aData
=
nsCString
(
aData
)
]
(
)
{
self
-
>
OnTransportAndData
(
aChannelStatus
aTransportStatus
aOffset
aCount
aData
)
;
}
)
)
;
}
void
HttpChannelChild
:
:
OnTransportAndData
(
const
nsresult
&
aChannelStatus
const
nsresult
&
aTransportStatus
const
uint64_t
&
aOffset
const
uint32_t
&
aCount
const
nsACString
&
aData
)
{
LOG
(
(
"
HttpChannelChild
:
:
OnTransportAndData
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
!
mCanceled
&
&
NS_SUCCEEDED
(
mStatus
)
)
{
mStatus
=
aChannelStatus
;
}
if
(
mCanceled
|
|
NS_FAILED
(
mStatus
)
)
{
return
;
}
AutoEventEnqueuer
ensureSerialDispatch
(
mEventQ
)
;
int64_t
progressMax
;
if
(
NS_FAILED
(
GetContentLength
(
&
progressMax
)
)
)
{
progressMax
=
-
1
;
}
const
int64_t
progress
=
aOffset
+
aCount
;
if
(
NS_IsMainThread
(
)
)
{
DoOnStatus
(
this
aTransportStatus
)
;
DoOnProgress
(
this
progress
progressMax
)
;
}
else
{
RefPtr
<
HttpChannelChild
>
self
=
this
;
nsCOMPtr
<
nsISerialEventTarget
>
neckoTarget
=
GetNeckoTarget
(
)
;
MOZ_ASSERT
(
neckoTarget
)
;
DebugOnly
<
nsresult
>
rv
=
neckoTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
net
:
:
HttpChannelChild
:
:
OnTransportAndData
"
[
self
aTransportStatus
progress
progressMax
]
(
)
{
self
-
>
DoOnStatus
(
self
aTransportStatus
)
;
self
-
>
DoOnProgress
(
self
progress
progressMax
)
;
}
)
NS_DISPATCH_NORMAL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsCOMPtr
<
nsIInputStream
>
stringStream
;
nsresult
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stringStream
)
Span
(
aData
)
.
To
(
aCount
)
NS_ASSIGNMENT_DEPEND
)
;
if
(
NS_FAILED
(
rv
)
)
{
Cancel
(
rv
)
;
return
;
}
DoOnDataAvailable
(
this
stringStream
aOffset
aCount
)
;
stringStream
-
>
Close
(
)
;
if
(
NeedToReportBytesRead
(
)
)
{
mUnreportBytesRead
+
=
aCount
;
if
(
mUnreportBytesRead
>
=
gHttpHandler
-
>
SendWindowSize
(
)
>
>
2
)
{
if
(
NS_IsMainThread
(
)
)
{
Unused
<
<
SendBytesRead
(
mUnreportBytesRead
)
;
}
else
{
RefPtr
<
HttpChannelChild
>
self
=
this
;
int32_t
bytesRead
=
mUnreportBytesRead
;
nsCOMPtr
<
nsISerialEventTarget
>
neckoTarget
=
GetNeckoTarget
(
)
;
MOZ_ASSERT
(
neckoTarget
)
;
DebugOnly
<
nsresult
>
rv
=
neckoTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
net
:
:
HttpChannelChild
:
:
SendBytesRead
"
[
self
bytesRead
]
(
)
{
Unused
<
<
self
-
>
SendBytesRead
(
bytesRead
)
;
}
)
NS_DISPATCH_NORMAL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
mUnreportBytesRead
=
0
;
}
}
}
bool
HttpChannelChild
:
:
NeedToReportBytesRead
(
)
{
if
(
mCacheNeedToReportBytesReadInitialized
)
{
return
mNeedToReportBytesRead
;
}
int64_t
contentLength
=
-
1
;
if
(
gHttpHandler
-
>
SendWindowSize
(
)
=
=
0
|
|
mIsFromCache
|
|
NS_FAILED
(
GetContentLength
(
&
contentLength
)
)
|
|
contentLength
<
gHttpHandler
-
>
SendWindowSize
(
)
)
{
mNeedToReportBytesRead
=
false
;
}
mCacheNeedToReportBytesReadInitialized
=
true
;
return
mNeedToReportBytesRead
;
}
void
HttpChannelChild
:
:
DoOnStatus
(
nsIRequest
*
aRequest
nsresult
status
)
{
LOG
(
(
"
HttpChannelChild
:
:
DoOnStatus
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mCanceled
)
return
;
if
(
!
mProgressSink
)
GetCallback
(
mProgressSink
)
;
if
(
mProgressSink
&
&
NS_SUCCEEDED
(
mStatus
)
&
&
LoadIsPending
(
)
&
&
!
(
mLoadFlags
&
LOAD_BACKGROUND
)
)
{
nsAutoCString
host
;
mURI
-
>
GetHost
(
host
)
;
mProgressSink
-
>
OnStatus
(
aRequest
status
NS_ConvertUTF8toUTF16
(
host
)
.
get
(
)
)
;
}
}
void
HttpChannelChild
:
:
DoOnProgress
(
nsIRequest
*
aRequest
int64_t
progress
int64_t
progressMax
)
{
LOG
(
(
"
HttpChannelChild
:
:
DoOnProgress
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mCanceled
)
return
;
if
(
!
mProgressSink
)
GetCallback
(
mProgressSink
)
;
if
(
mProgressSink
&
&
NS_SUCCEEDED
(
mStatus
)
&
&
LoadIsPending
(
)
)
{
if
(
progress
>
0
)
{
mProgressSink
-
>
OnProgress
(
aRequest
progress
progressMax
)
;
}
}
}
void
HttpChannelChild
:
:
DoOnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aStream
uint64_t
aOffset
uint32_t
aCount
)
{
AUTO_PROFILER_LABEL
(
"
HttpChannelChild
:
:
DoOnDataAvailable
"
NETWORK
)
;
LOG
(
(
"
HttpChannelChild
:
:
DoOnDataAvailable
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mCanceled
)
return
;
if
(
mListener
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
(
mListener
)
;
nsresult
rv
=
listener
-
>
OnDataAvailable
(
aRequest
aStream
aOffset
aCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
CancelOnMainThread
(
rv
)
;
}
}
}
void
HttpChannelChild
:
:
ProcessOnStopRequest
(
const
nsresult
&
aChannelStatus
const
ResourceTimingStructArgs
&
aTiming
const
nsHttpHeaderArray
&
aResponseTrailers
nsTArray
<
ConsoleReportCollected
>
&
&
aConsoleReports
bool
aFromSocketProcess
)
{
LOG
(
(
"
HttpChannelChild
:
:
ProcessOnStopRequest
[
this
=
%
p
"
"
aFromSocketProcess
=
%
d
]
\
n
"
this
aFromSocketProcess
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
aChannelStatus
aTiming
aResponseTrailers
consoleReports
=
CopyableTArray
{
aConsoleReports
.
Clone
(
)
}
aFromSocketProcess
]
(
)
mutable
{
self
-
>
OnStopRequest
(
aChannelStatus
aTiming
aResponseTrailers
)
;
if
(
!
aFromSocketProcess
)
{
self
-
>
DoOnConsoleReport
(
std
:
:
move
(
consoleReports
)
)
;
self
-
>
ContinueOnStopRequest
(
)
;
}
}
)
)
;
}
void
HttpChannelChild
:
:
ProcessOnConsoleReport
(
nsTArray
<
ConsoleReportCollected
>
&
&
aConsoleReports
)
{
LOG
(
(
"
HttpChannelChild
:
:
ProcessOnConsoleReport
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
consoleReports
=
CopyableTArray
{
aConsoleReports
.
Clone
(
)
}
]
(
)
mutable
{
self
-
>
DoOnConsoleReport
(
std
:
:
move
(
consoleReports
)
)
;
self
-
>
ContinueOnStopRequest
(
)
;
}
)
)
;
}
void
HttpChannelChild
:
:
DoOnConsoleReport
(
nsTArray
<
ConsoleReportCollected
>
&
&
aConsoleReports
)
{
if
(
aConsoleReports
.
IsEmpty
(
)
)
{
return
;
}
for
(
ConsoleReportCollected
&
report
:
aConsoleReports
)
{
if
(
report
.
propertiesFile
(
)
<
nsContentUtils
:
:
PropertiesFile
:
:
PropertiesFile_COUNT
)
{
AddConsoleReport
(
report
.
errorFlags
(
)
report
.
category
(
)
nsContentUtils
:
:
PropertiesFile
(
report
.
propertiesFile
(
)
)
report
.
sourceFileURI
(
)
report
.
lineNumber
(
)
report
.
columnNumber
(
)
report
.
messageName
(
)
report
.
stringParams
(
)
)
;
}
}
MaybeFlushConsoleReports
(
)
;
}
void
HttpChannelChild
:
:
OnStopRequest
(
const
nsresult
&
aChannelStatus
const
ResourceTimingStructArgs
&
aTiming
const
nsHttpHeaderArray
&
aResponseTrailers
)
{
LOG
(
(
"
HttpChannelChild
:
:
OnStopRequest
[
this
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
aChannelStatus
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
LoadOnStopRequestCalled
(
)
&
&
mIPCActorDeleted
)
{
return
;
}
nsCOMPtr
<
nsICompressConvStats
>
conv
=
do_QueryInterface
(
mCompressListener
)
;
if
(
conv
)
{
conv
-
>
GetDecodedDataLength
(
&
mDecodedBodySize
)
;
}
ResourceTimingStructArgsToTimingsStruct
(
aTiming
mTransactionTimings
)
;
mRedirectStartTimeStamp
=
aTiming
.
redirectStart
(
)
;
mRedirectEndTimeStamp
=
aTiming
.
redirectEnd
(
)
;
mTransferSize
=
aTiming
.
transferSize
(
)
;
mEncodedBodySize
=
aTiming
.
encodedBodySize
(
)
;
mProtocolVersion
=
aTiming
.
protocolVersion
(
)
;
mCacheReadStart
=
aTiming
.
cacheReadStart
(
)
;
mCacheReadEnd
=
aTiming
.
cacheReadEnd
(
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsAutoCString
requestMethod
;
GetRequestMethod
(
requestMethod
)
;
nsAutoCString
contentType
;
if
(
mResponseHead
)
{
mResponseHead
-
>
ContentType
(
contentType
)
;
}
int32_t
priority
=
PRIORITY_NORMAL
;
GetPriority
(
&
priority
)
;
profiler_add_network_marker
(
mURI
requestMethod
priority
mChannelId
NetworkLoadType
:
:
LOAD_STOP
mLastStatusReported
TimeStamp
:
:
Now
(
)
mTransferSize
kCacheUnknown
mLoadInfo
-
>
GetInnerWindowID
(
)
mLoadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
>
0
&
mTransactionTimings
std
:
:
move
(
mSource
)
Some
(
nsDependentCString
(
contentType
.
get
(
)
)
)
)
;
}
TimeDuration
channelCompletionDuration
=
TimeStamp
:
:
Now
(
)
-
mAsyncOpenTime
;
if
(
mIsFromCache
)
{
PerfStats
:
:
RecordMeasurement
(
PerfStats
:
:
Metric
:
:
HttpChannelCompletion_Cache
channelCompletionDuration
)
;
}
else
{
PerfStats
:
:
RecordMeasurement
(
PerfStats
:
:
Metric
:
:
HttpChannelCompletion_Network
channelCompletionDuration
)
;
}
PerfStats
:
:
RecordMeasurement
(
PerfStats
:
:
Metric
:
:
HttpChannelCompletion
channelCompletionDuration
)
;
mResponseTrailers
=
MakeUnique
<
nsHttpHeaderArray
>
(
aResponseTrailers
)
;
DoPreOnStopRequest
(
aChannelStatus
)
;
{
AutoEventEnqueuer
ensureSerialDispatch
(
mEventQ
)
;
DoOnStopRequest
(
this
aChannelStatus
)
;
}
}
void
HttpChannelChild
:
:
ContinueOnStopRequest
(
)
{
if
(
mMultiPartID
)
{
LOG
(
(
"
HttpChannelChild
:
:
OnStopRequest
-
Expecting
future
parts
on
a
"
"
multipart
channel
postpone
cleaning
up
.
"
)
)
;
return
;
}
CleanupBackgroundChannel
(
)
;
if
(
NS_SUCCEEDED
(
mStatus
)
&
&
!
mPreferredCachedAltDataTypes
.
IsEmpty
(
)
)
{
mKeptAlive
=
true
;
SendDocumentChannelCleanup
(
false
)
;
return
;
}
if
(
mLoadFlags
&
LOAD_DOCUMENT_URI
)
{
if
(
CanSend
(
)
)
{
mKeptAlive
=
true
;
SendDocumentChannelCleanup
(
true
)
;
}
}
else
{
TrySendDeletingChannel
(
)
;
}
}
void
HttpChannelChild
:
:
DoPreOnStopRequest
(
nsresult
aStatus
)
{
AUTO_PROFILER_LABEL
(
"
HttpChannelChild
:
:
DoPreOnStopRequest
"
NETWORK
)
;
LOG
(
(
"
HttpChannelChild
:
:
DoPreOnStopRequest
[
this
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
StoreIsPending
(
false
)
;
MaybeReportTimingData
(
)
;
if
(
!
mCanceled
&
&
NS_SUCCEEDED
(
mStatus
)
)
{
mStatus
=
aStatus
;
}
CollectOMTTelemetry
(
)
;
}
void
HttpChannelChild
:
:
CollectOMTTelemetry
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mCanceled
|
|
NS_FAILED
(
mStatus
)
)
{
return
;
}
nsAutoCString
key
(
NS_CP_ContentTypeName
(
mLoadInfo
-
>
InternalContentPolicyType
(
)
)
)
;
Telemetry
:
:
AccumulateCategoricalKeyed
(
key
mOMTResult
)
;
}
void
HttpChannelChild
:
:
DoOnStopRequest
(
nsIRequest
*
aRequest
nsresult
aChannelStatus
)
{
AUTO_PROFILER_LABEL
(
"
HttpChannelChild
:
:
DoOnStopRequest
"
NETWORK
)
;
LOG
(
(
"
HttpChannelChild
:
:
DoOnStopRequest
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
LoadIsPending
(
)
)
;
auto
checkForBlockedContent
=
[
&
]
(
)
{
if
(
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aChannelStatus
)
|
|
aChannelStatus
=
=
NS_ERROR_MALWARE_URI
|
|
aChannelStatus
=
=
NS_ERROR_UNWANTED_URI
|
|
aChannelStatus
=
=
NS_ERROR_BLOCKED_URI
|
|
aChannelStatus
=
=
NS_ERROR_HARMFUL_URI
|
|
aChannelStatus
=
=
NS_ERROR_PHISHING_URI
)
{
nsCString
list
provider
fullhash
;
nsresult
rv
=
GetMatchedList
(
list
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
rv
=
GetMatchedProvider
(
provider
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
rv
=
GetMatchedFullHash
(
fullhash
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
UrlClassifierCommon
:
:
SetBlockedContent
(
this
aChannelStatus
list
provider
fullhash
)
;
}
}
;
checkForBlockedContent
(
)
;
MaybeLogCOEPError
(
aChannelStatus
)
;
MOZ_ASSERT
(
mListener
|
|
!
LoadWasOpened
(
)
)
;
if
(
!
mListener
)
{
return
;
}
MOZ_ASSERT
(
!
LoadOnStopRequestCalled
(
)
"
We
should
not
call
OnStopRequest
twice
"
)
;
if
(
mListener
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
(
mListener
)
;
StoreOnStopRequestCalled
(
true
)
;
listener
-
>
OnStopRequest
(
aRequest
mStatus
)
;
}
StoreOnStopRequestCalled
(
true
)
;
if
(
mMultiPartID
)
{
LOG
(
(
"
HttpChannelChild
:
:
DoOnStopRequest
-
Expecting
future
parts
on
a
"
"
multipart
channel
not
releasing
listeners
.
"
)
)
;
StoreOnStopRequestCalled
(
false
)
;
StoreOnStartRequestCalled
(
false
)
;
return
;
}
gHttpHandler
-
>
OnStopRequest
(
this
)
;
ReleaseListeners
(
)
;
if
(
!
mPreferredCachedAltDataTypes
.
IsEmpty
(
)
)
{
mAltDataCacheEntryAvailable
=
mCacheEntryAvailable
;
}
mCacheEntryAvailable
=
false
;
if
(
mLoadGroup
)
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
mStatus
)
;
}
void
HttpChannelChild
:
:
ProcessOnProgress
(
const
int64_t
&
aProgress
const
int64_t
&
aProgressMax
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
LOG
(
(
"
HttpChannelChild
:
:
ProcessOnProgress
[
this
=
%
p
]
\
n
"
this
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
aProgress
aProgressMax
]
(
)
{
AutoEventEnqueuer
ensureSerialDispatch
(
self
-
>
mEventQ
)
;
self
-
>
DoOnProgress
(
self
aProgress
aProgressMax
)
;
}
)
)
;
}
void
HttpChannelChild
:
:
ProcessOnStatus
(
const
nsresult
&
aStatus
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
LOG
(
(
"
HttpChannelChild
:
:
ProcessOnStatus
[
this
=
%
p
]
\
n
"
this
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
aStatus
]
(
)
{
AutoEventEnqueuer
ensureSerialDispatch
(
self
-
>
mEventQ
)
;
self
-
>
DoOnStatus
(
self
aStatus
)
;
}
)
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelChild
:
:
RecvFailedAsyncOpen
(
const
nsresult
&
aStatus
)
{
LOG
(
(
"
HttpChannelChild
:
:
RecvFailedAsyncOpen
[
this
=
%
p
]
\
n
"
this
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
aStatus
]
(
)
{
self
-
>
FailedAsyncOpen
(
aStatus
)
;
}
)
)
;
return
IPC_OK
(
)
;
}
void
HttpChannelChild
:
:
HandleAsyncAbort
(
)
{
HttpAsyncAborter
<
HttpChannelChild
>
:
:
HandleAsyncAbort
(
)
;
CleanupBackgroundChannel
(
)
;
}
void
HttpChannelChild
:
:
FailedAsyncOpen
(
const
nsresult
&
status
)
{
LOG
(
(
"
HttpChannelChild
:
:
FailedAsyncOpen
[
this
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
status
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
LoadOnStartRequestCalled
(
)
)
{
return
;
}
if
(
NS_SUCCEEDED
(
mStatus
)
)
{
mStatus
=
status
;
}
HandleAsyncAbort
(
)
;
if
(
CanSend
(
)
)
{
TrySendDeletingChannel
(
)
;
}
}
void
HttpChannelChild
:
:
CleanupBackgroundChannel
(
)
{
MutexAutoLock
lock
(
mBgChildMutex
)
;
AUTO_PROFILER_LABEL
(
"
HttpChannelChild
:
:
CleanupBackgroundChannel
"
NETWORK
)
;
LOG
(
(
"
HttpChannelChild
:
:
CleanupBackgroundChannel
[
this
=
%
p
bgChild
=
%
p
]
\
n
"
this
mBgChild
.
get
(
)
)
)
;
mBgInitFailCallback
=
nullptr
;
if
(
!
mBgChild
)
{
return
;
}
RefPtr
<
HttpBackgroundChannelChild
>
bgChild
=
std
:
:
move
(
mBgChild
)
;
MOZ_RELEASE_ASSERT
(
gSocketTransportService
)
;
if
(
!
OnSocketThread
(
)
)
{
gSocketTransportService
-
>
Dispatch
(
NewRunnableMethod
(
"
HttpBackgroundChannelChild
:
:
OnChannelClosed
"
bgChild
&
HttpBackgroundChannelChild
:
:
OnChannelClosed
)
NS_DISPATCH_NORMAL
)
;
}
else
{
bgChild
-
>
OnChannelClosed
(
)
;
}
}
void
HttpChannelChild
:
:
DoNotifyListenerCleanup
(
)
{
LOG
(
(
"
HttpChannelChild
:
:
DoNotifyListenerCleanup
[
this
=
%
p
]
\
n
"
this
)
)
;
}
void
HttpChannelChild
:
:
DoAsyncAbort
(
nsresult
aStatus
)
{
Unused
<
<
AsyncAbort
(
aStatus
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelChild
:
:
RecvDeleteSelf
(
)
{
LOG
(
(
"
HttpChannelChild
:
:
RecvDeleteSelf
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mSuspendForWaitCompleteRedirectSetup
)
{
mSuspendForWaitCompleteRedirectSetup
=
false
;
mEventQ
-
>
Resume
(
)
;
}
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
]
(
)
{
self
-
>
DeleteSelf
(
)
;
}
)
)
;
return
IPC_OK
(
)
;
}
void
HttpChannelChild
:
:
DeleteSelf
(
)
{
Send__delete__
(
this
)
;
}
void
HttpChannelChild
:
:
NotifyOrReleaseListeners
(
nsresult
rv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
|
|
(
LoadOnStartRequestCalled
(
)
&
&
LoadOnStopRequestCalled
(
)
)
)
{
ReleaseListeners
(
)
;
return
;
}
if
(
NS_SUCCEEDED
(
mStatus
)
)
{
mStatus
=
rv
;
}
DoNotifyListener
(
)
;
}
void
HttpChannelChild
:
:
DoNotifyListener
(
)
{
LOG
(
(
"
HttpChannelChild
:
:
DoNotifyListener
this
=
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
LoadAfterOnStartRequestBegun
(
)
)
{
StoreAfterOnStartRequestBegun
(
true
)
;
}
if
(
mListener
&
&
!
LoadOnStartRequestCalled
(
)
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
=
mListener
;
StoreOnStartRequestCalled
(
true
)
;
listener
-
>
OnStartRequest
(
this
)
;
}
StoreOnStartRequestCalled
(
true
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
]
{
self
-
>
ContinueDoNotifyListener
(
)
;
}
)
)
;
}
void
HttpChannelChild
:
:
ContinueDoNotifyListener
(
)
{
LOG
(
(
"
HttpChannelChild
:
:
ContinueDoNotifyListener
this
=
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StoreIsPending
(
false
)
;
if
(
mListener
&
&
!
LoadOnStopRequestCalled
(
)
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
=
mListener
;
StoreOnStopRequestCalled
(
true
)
;
listener
-
>
OnStopRequest
(
this
mStatus
)
;
}
StoreOnStopRequestCalled
(
true
)
;
gHttpHandler
-
>
OnStopRequest
(
this
)
;
RemoveAsNonTailRequest
(
)
;
ReleaseListeners
(
)
;
DoNotifyListenerCleanup
(
)
;
if
(
!
IsNavigation
(
)
)
{
if
(
mLoadGroup
)
{
FlushConsoleReports
(
mLoadGroup
)
;
}
else
{
RefPtr
<
dom
:
:
Document
>
doc
;
mLoadInfo
-
>
GetLoadingDocument
(
getter_AddRefs
(
doc
)
)
;
FlushConsoleReports
(
doc
)
;
}
}
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelChild
:
:
RecvReportSecurityMessage
(
const
nsAString
&
messageTag
const
nsAString
&
messageCategory
)
{
DebugOnly
<
nsresult
>
rv
=
AddSecurityMessage
(
messageTag
messageCategory
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelChild
:
:
RecvRedirect1Begin
(
const
uint32_t
&
aRegistrarId
const
URIParams
&
aNewUri
const
uint32_t
&
aNewLoadFlags
const
uint32_t
&
aRedirectFlags
const
ParentLoadInfoForwarderArgs
&
aLoadInfoForwarder
const
nsHttpResponseHead
&
aResponseHead
const
nsACString
&
aSecurityInfoSerialization
const
uint64_t
&
aChannelId
const
NetAddr
&
aOldPeerAddr
const
ResourceTimingStructArgs
&
aTiming
)
{
LOG
(
(
"
HttpChannelChild
:
:
RecvRedirect1Begin
[
this
=
%
p
]
\
n
"
this
)
)
;
mPeerAddr
=
aOldPeerAddr
;
MOZ_ASSERT
(
!
nsHttpResponseHead
(
aResponseHead
)
.
HasHeader
(
nsHttp
:
:
Set_Cookie
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
aRegistrarId
aNewUri
aNewLoadFlags
aRedirectFlags
aLoadInfoForwarder
aResponseHead
aSecurityInfoSerialization
=
nsCString
(
aSecurityInfoSerialization
)
aChannelId
aTiming
]
(
)
{
self
-
>
Redirect1Begin
(
aRegistrarId
aNewUri
aNewLoadFlags
aRedirectFlags
aLoadInfoForwarder
aResponseHead
aSecurityInfoSerialization
aChannelId
aTiming
)
;
}
)
)
;
return
IPC_OK
(
)
;
}
nsresult
HttpChannelChild
:
:
SetupRedirect
(
nsIURI
*
uri
const
nsHttpResponseHead
*
responseHead
const
uint32_t
&
redirectFlags
nsIChannel
*
*
outChannel
)
{
LOG
(
(
"
HttpChannelChild
:
:
SetupRedirect
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mCanceled
)
{
return
NS_ERROR_ABORT
;
}
nsresult
rv
;
nsCOMPtr
<
nsIIOService
>
ioService
;
rv
=
gHttpHandler
-
>
GetIOService
(
getter_AddRefs
(
ioService
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIChannel
>
newChannel
;
nsCOMPtr
<
nsILoadInfo
>
redirectLoadInfo
=
CloneLoadInfoForRedirect
(
uri
redirectFlags
)
;
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
newChannel
)
uri
redirectLoadInfo
nullptr
nullptr
nullptr
nsIRequest
:
:
LOAD_NORMAL
ioService
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mResponseHead
=
MakeUnique
<
nsHttpResponseHead
>
(
*
responseHead
)
;
bool
rewriteToGET
=
HttpBaseChannel
:
:
ShouldRewriteRedirectToGET
(
mResponseHead
-
>
Status
(
)
mRequestHead
.
ParsedMethod
(
)
)
;
rv
=
SetupReplacementChannel
(
uri
newChannel
!
rewriteToGET
redirectFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mRedirectChannelChild
=
do_QueryInterface
(
newChannel
)
;
newChannel
.
forget
(
outChannel
)
;
return
NS_OK
;
}
void
HttpChannelChild
:
:
Redirect1Begin
(
const
uint32_t
&
registrarId
const
URIParams
&
newOriginalURI
const
uint32_t
&
newLoadFlags
const
uint32_t
&
redirectFlags
const
ParentLoadInfoForwarderArgs
&
loadInfoForwarder
const
nsHttpResponseHead
&
responseHead
const
nsACString
&
securityInfoSerialization
const
uint64_t
&
channelId
const
ResourceTimingStructArgs
&
timing
)
{
nsresult
rv
;
LOG
(
(
"
HttpChannelChild
:
:
Redirect1Begin
[
this
=
%
p
]
\
n
"
this
)
)
;
ipc
:
:
MergeParentLoadInfoForwarder
(
loadInfoForwarder
mLoadInfo
)
;
nsCOMPtr
<
nsIURI
>
uri
=
DeserializeURI
(
newOriginalURI
)
;
ResourceTimingStructArgsToTimingsStruct
(
timing
mTransactionTimings
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsAutoCString
requestMethod
;
GetRequestMethod
(
requestMethod
)
;
nsAutoCString
contentType
;
responseHead
.
ContentType
(
contentType
)
;
profiler_add_network_marker
(
mURI
requestMethod
mPriority
mChannelId
NetworkLoadType
:
:
LOAD_REDIRECT
mLastStatusReported
TimeStamp
:
:
Now
(
)
0
kCacheUnknown
mLoadInfo
-
>
GetInnerWindowID
(
)
mLoadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
>
0
&
mTransactionTimings
std
:
:
move
(
mSource
)
Some
(
nsDependentCString
(
contentType
.
get
(
)
)
)
uri
redirectFlags
channelId
)
;
}
if
(
!
securityInfoSerialization
.
IsEmpty
(
)
)
{
rv
=
NS_DeserializeObject
(
securityInfoSerialization
getter_AddRefs
(
mSecurityInfo
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserializing
security
info
should
not
fail
"
)
;
}
nsCOMPtr
<
nsIChannel
>
newChannel
;
rv
=
SetupRedirect
(
uri
&
responseHead
redirectFlags
getter_AddRefs
(
newChannel
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
newChannel
-
>
SetLoadFlags
(
newLoadFlags
)
)
;
if
(
mRedirectChannelChild
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
mRedirectChannelChild
)
;
if
(
httpChannel
)
{
rv
=
httpChannel
-
>
SetChannelId
(
channelId
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
mRedirectChannelChild
-
>
ConnectParent
(
registrarId
)
;
}
nsCOMPtr
<
nsISerialEventTarget
>
target
=
GetNeckoTarget
(
)
;
MOZ_ASSERT
(
target
)
;
rv
=
gHttpHandler
-
>
AsyncOnChannelRedirect
(
this
newChannel
redirectFlags
target
)
;
}
if
(
NS_FAILED
(
rv
)
)
OnRedirectVerifyCallback
(
rv
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelChild
:
:
RecvRedirect3Complete
(
)
{
LOG
(
(
"
HttpChannelChild
:
:
RecvRedirect3Complete
[
this
=
%
p
]
\
n
"
this
)
)
;
nsCOMPtr
<
nsIChannel
>
redirectChannel
=
do_QueryInterface
(
mRedirectChannelChild
)
;
MOZ_ASSERT
(
redirectChannel
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
redirectChannel
]
(
)
{
nsresult
rv
=
NS_OK
;
Unused
<
<
self
-
>
GetStatus
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
self
-
>
HandleAsyncAbort
(
)
;
nsCOMPtr
<
nsIHttpChannelChild
>
chan
=
do_QueryInterface
(
redirectChannel
)
;
RefPtr
<
HttpChannelChild
>
httpChannelChild
=
static_cast
<
HttpChannelChild
*
>
(
chan
.
get
(
)
)
;
if
(
httpChannelChild
)
{
Unused
<
<
httpChannelChild
-
>
Cancel
(
rv
)
;
httpChannelChild
-
>
DoNotifyListener
(
)
;
}
return
;
}
self
-
>
Redirect3Complete
(
)
;
}
)
)
;
return
IPC_OK
(
)
;
}
void
HttpChannelChild
:
:
ProcessNotifyClassificationFlags
(
uint32_t
aClassificationFlags
bool
aIsThirdParty
)
{
LOG
(
(
"
HttpChannelChild
:
:
ProcessNotifyClassificationFlags
thirdparty
=
%
d
"
"
flags
=
%
"
PRIu32
"
[
this
=
%
p
]
\
n
"
static_cast
<
int
>
(
aIsThirdParty
)
aClassificationFlags
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
aClassificationFlags
aIsThirdParty
]
(
)
{
self
-
>
AddClassificationFlags
(
aClassificationFlags
aIsThirdParty
)
;
}
)
)
;
}
void
HttpChannelChild
:
:
ProcessSetClassifierMatchedInfo
(
const
nsACString
&
aList
const
nsACString
&
aProvider
const
nsACString
&
aFullHash
)
{
LOG
(
(
"
HttpChannelChild
:
:
ProcessSetClassifierMatchedInfo
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
aList
=
nsCString
(
aList
)
aProvider
=
nsCString
(
aProvider
)
aFullHash
=
nsCString
(
aFullHash
)
]
(
)
{
self
-
>
SetMatchedInfo
(
aList
aProvider
aFullHash
)
;
}
)
)
;
}
void
HttpChannelChild
:
:
ProcessSetClassifierMatchedTrackingInfo
(
const
nsACString
&
aLists
const
nsACString
&
aFullHashes
)
{
LOG
(
(
"
HttpChannelChild
:
:
ProcessSetClassifierMatchedTrackingInfo
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
nsTArray
<
nsCString
>
lists
fullhashes
;
for
(
const
nsACString
&
token
:
aLists
.
Split
(
'
'
)
)
{
lists
.
AppendElement
(
token
)
;
}
for
(
const
nsACString
&
token
:
aFullHashes
.
Split
(
'
'
)
)
{
fullhashes
.
AppendElement
(
token
)
;
}
mEventQ
-
>
RunOrEnqueue
(
new
NeckoTargetChannelFunctionEvent
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
lists
=
CopyableTArray
{
std
:
:
move
(
lists
)
}
fullhashes
=
CopyableTArray
{
std
:
:
move
(
fullhashes
)
}
]
(
)
{
self
-
>
SetMatchedTrackingInfo
(
lists
fullhashes
)
;
}
)
)
;
}
void
HttpChannelChild
:
:
Redirect3Complete
(
)
{
LOG
(
(
"
HttpChannelChild
:
:
Redirect3Complete
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
NS_BINDING_ABORTED
;
nsCOMPtr
<
nsIRedirectResultListener
>
vetoHook
;
GetCallback
(
vetoHook
)
;
if
(
vetoHook
)
{
vetoHook
-
>
OnRedirectResult
(
true
)
;
}
if
(
mRedirectChannelChild
)
{
rv
=
mRedirectChannelChild
-
>
CompleteRedirectSetup
(
mListener
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mSuccesfullyRedirected
=
NS_SUCCEEDED
(
rv
)
;
#
endif
}
CleanupRedirectingChannel
(
rv
)
;
}
void
HttpChannelChild
:
:
CleanupRedirectingChannel
(
nsresult
rv
)
{
if
(
mLoadGroup
)
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
NS_BINDING_ABORTED
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mLoadInfo
-
>
AppendRedirectHistoryEntry
(
this
false
)
;
}
else
{
NS_WARNING
(
"
CompleteRedirectSetup
failed
HttpChannelChild
already
open
?
"
)
;
}
mRedirectChannelChild
=
nullptr
;
NotifyOrReleaseListeners
(
rv
)
;
CleanupBackgroundChannel
(
)
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
ConnectParent
(
uint32_t
registrarId
)
{
LOG
(
(
"
HttpChannelChild
:
:
ConnectParent
[
this
=
%
p
id
=
%
"
PRIu32
"
]
\
n
"
this
registrarId
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mozilla
:
:
dom
:
:
BrowserChild
*
browserChild
=
nullptr
;
nsCOMPtr
<
nsIBrowserChild
>
iBrowserChild
;
GetCallback
(
iBrowserChild
)
;
if
(
iBrowserChild
)
{
browserChild
=
static_cast
<
mozilla
:
:
dom
:
:
BrowserChild
*
>
(
iBrowserChild
.
get
(
)
)
;
}
if
(
browserChild
&
&
!
browserChild
-
>
IPCOpen
(
)
)
{
return
NS_ERROR_FAILURE
;
}
ContentChild
*
cc
=
static_cast
<
ContentChild
*
>
(
gNeckoChild
-
>
Manager
(
)
)
;
if
(
cc
-
>
IsShuttingDown
(
)
)
{
return
NS_ERROR_FAILURE
;
}
HttpBaseChannel
:
:
SetDocshellUserAgentOverride
(
)
;
SetEventTarget
(
)
;
if
(
browserChild
)
{
MOZ_ASSERT
(
browserChild
-
>
WebNavigation
(
)
)
;
if
(
BrowsingContext
*
bc
=
browserChild
-
>
GetBrowsingContext
(
)
)
{
mTopBrowsingContextId
=
bc
-
>
Top
(
)
-
>
Id
(
)
;
}
}
HttpChannelConnectArgs
connectArgs
(
registrarId
)
;
if
(
!
gNeckoChild
-
>
SendPHttpChannelConstructor
(
this
browserChild
IPC
:
:
SerializedLoadContext
(
this
)
connectArgs
)
)
{
return
NS_ERROR_FAILURE
;
}
{
MutexAutoLock
lock
(
mBgChildMutex
)
;
MOZ_ASSERT
(
!
mBgChild
)
;
MOZ_ASSERT
(
!
mBgInitFailCallback
)
;
mBgInitFailCallback
=
NewRunnableMethod
<
nsresult
>
(
"
HttpChannelChild
:
:
OnRedirectVerifyCallback
"
this
&
HttpChannelChild
:
:
OnRedirectVerifyCallback
NS_ERROR_FAILURE
)
;
RefPtr
<
HttpBackgroundChannelChild
>
bgChild
=
new
HttpBackgroundChannelChild
(
)
;
MOZ_RELEASE_ASSERT
(
gSocketTransportService
)
;
RefPtr
<
HttpChannelChild
>
self
=
this
;
nsresult
rv
=
gSocketTransportService
-
>
Dispatch
(
NewRunnableMethod
<
RefPtr
<
HttpChannelChild
>
>
(
"
HttpBackgroundChannelChild
:
:
Init
"
bgChild
&
HttpBackgroundChannelChild
:
:
Init
std
:
:
move
(
self
)
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mBgChild
=
std
:
:
move
(
bgChild
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mEverHadBgChildAtConnectParent
=
true
;
#
endif
}
mEventQ
-
>
Suspend
(
)
;
MOZ_ASSERT
(
!
mSuspendForWaitCompleteRedirectSetup
)
;
mSuspendForWaitCompleteRedirectSetup
=
true
;
MaybeConnectToSocketProcess
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
CompleteRedirectSetup
(
nsIStreamListener
*
aListener
)
{
LOG
(
(
"
HttpChannelChild
:
:
CompleteRedirectSetup
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_TRUE
(
!
LoadIsPending
(
)
NS_ERROR_IN_PROGRESS
)
;
NS_ENSURE_TRUE
(
!
LoadWasOpened
(
)
NS_ERROR_ALREADY_OPENED
)
;
auto
eventQueueResumeGuard
=
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
mSuspendForWaitCompleteRedirectSetup
)
;
mEventQ
-
>
Resume
(
)
;
mSuspendForWaitCompleteRedirectSetup
=
false
;
}
)
;
mLastStatusReported
=
TimeStamp
:
:
Now
(
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsAutoCString
requestMethod
;
GetRequestMethod
(
requestMethod
)
;
profiler_add_network_marker
(
mURI
requestMethod
mPriority
mChannelId
NetworkLoadType
:
:
LOAD_START
mChannelCreationTimestamp
mLastStatusReported
0
kCacheUnknown
mLoadInfo
-
>
GetInnerWindowID
(
)
mLoadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
>
0
)
;
}
StoreIsPending
(
true
)
;
StoreWasOpened
(
true
)
;
mListener
=
aListener
;
if
(
mLoadGroup
)
mLoadGroup
-
>
AddRequest
(
this
nullptr
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
OnRedirectVerifyCallback
(
nsresult
aResult
)
{
LOG
(
(
"
HttpChannelChild
:
:
OnRedirectVerifyCallback
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Maybe
<
URIParams
>
redirectURI
;
nsresult
rv
;
nsCOMPtr
<
nsIHttpChannel
>
newHttpChannel
=
do_QueryInterface
(
mRedirectChannelChild
)
;
if
(
NS_SUCCEEDED
(
aResult
)
&
&
!
mRedirectChannelChild
)
{
LOG
(
(
"
redirecting
to
a
protocol
that
doesn
'
t
implement
nsIChildChannel
"
)
)
;
aResult
=
NS_ERROR_DOM_BAD_URI
;
}
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
;
if
(
newHttpChannel
)
{
newHttpChannel
-
>
SetOriginalURI
(
mOriginalURI
)
;
referrerInfo
=
newHttpChannel
-
>
GetReferrerInfo
(
)
;
}
RequestHeaderTuples
emptyHeaders
;
RequestHeaderTuples
*
headerTuples
=
&
emptyHeaders
;
nsLoadFlags
loadFlags
=
0
;
Maybe
<
CorsPreflightArgs
>
corsPreflightArgs
;
nsCOMPtr
<
nsIHttpChannelChild
>
newHttpChannelChild
=
do_QueryInterface
(
mRedirectChannelChild
)
;
if
(
newHttpChannelChild
&
&
NS_SUCCEEDED
(
aResult
)
)
{
rv
=
newHttpChannelChild
-
>
AddCookiesToRequest
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
newHttpChannelChild
-
>
GetClientSetRequestHeaders
(
&
headerTuples
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
newHttpChannelChild
-
>
GetClientSetCorsPreflightParameters
(
corsPreflightArgs
)
;
}
SerializeURI
(
nullptr
redirectURI
)
;
if
(
NS_SUCCEEDED
(
aResult
)
)
{
nsCOMPtr
<
nsIHttpChannelInternal
>
newHttpChannelInternal
=
do_QueryInterface
(
mRedirectChannelChild
)
;
if
(
newHttpChannelInternal
)
{
nsCOMPtr
<
nsIURI
>
apiRedirectURI
;
rv
=
newHttpChannelInternal
-
>
GetApiRedirectToURI
(
getter_AddRefs
(
apiRedirectURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
apiRedirectURI
)
{
SerializeURI
(
apiRedirectURI
redirectURI
)
;
}
}
nsCOMPtr
<
nsIRequest
>
request
=
do_QueryInterface
(
mRedirectChannelChild
)
;
if
(
request
)
{
request
-
>
GetLoadFlags
(
&
loadFlags
)
;
}
}
uint32_t
sourceRequestBlockingReason
=
0
;
mLoadInfo
-
>
GetRequestBlockingReason
(
&
sourceRequestBlockingReason
)
;
Maybe
<
ChildLoadInfoForwarderArgs
>
targetLoadInfoForwarder
;
nsCOMPtr
<
nsIChannel
>
newChannel
=
do_QueryInterface
(
mRedirectChannelChild
)
;
if
(
newChannel
)
{
ChildLoadInfoForwarderArgs
args
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
newChannel
-
>
LoadInfo
(
)
;
LoadInfoToChildLoadInfoForwarder
(
loadInfo
&
args
)
;
targetLoadInfoForwarder
.
emplace
(
args
)
;
}
if
(
CanSend
(
)
)
{
SendRedirect2Verify
(
aResult
*
headerTuples
sourceRequestBlockingReason
targetLoadInfoForwarder
loadFlags
referrerInfo
redirectURI
corsPreflightArgs
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
Cancel
(
nsresult
aStatus
)
{
LOG
(
(
"
HttpChannelChild
:
:
Cancel
[
this
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
Maybe
<
nsCString
>
logStack
=
CallingScriptLocationString
(
)
;
Maybe
<
nsCString
>
logOnParent
;
if
(
logStack
.
isSome
(
)
)
{
logOnParent
=
Some
(
"
"
_ns
)
;
logOnParent
-
>
AppendPrintf
(
"
[
this
=
%
p
]
cancelled
call
in
child
process
from
script
:
%
s
"
this
logStack
-
>
get
(
)
)
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mCanceled
)
{
mCanceled
=
true
;
mStatus
=
aStatus
;
bool
remoteChannelExists
=
RemoteChannelExists
(
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mCanSendAtCancel
=
CanSend
(
)
;
mRemoteChannelExistedAtCancel
=
remoteChannelExists
;
#
endif
if
(
remoteChannelExists
)
{
SendCancel
(
aStatus
mLoadInfo
-
>
GetRequestBlockingReason
(
)
logOnParent
)
;
}
else
if
(
MOZ_UNLIKELY
(
!
LoadOnStartRequestCalled
(
)
|
|
!
LoadOnStopRequestCalled
(
)
)
)
{
Unused
<
<
AsyncAbort
(
mStatus
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
Suspend
(
)
{
LOG
(
(
"
HttpChannelChild
:
:
Suspend
[
this
=
%
p
mSuspendCount
=
%
"
PRIu32
"
\
n
"
this
mSuspendCount
+
1
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LogCallingScriptLocation
(
this
)
;
if
(
!
mSuspendCount
+
+
)
{
if
(
RemoteChannelExists
(
)
)
{
SendSuspend
(
)
;
mSuspendSent
=
true
;
}
}
mEventQ
-
>
Suspend
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
Resume
(
)
{
LOG
(
(
"
HttpChannelChild
:
:
Resume
[
this
=
%
p
mSuspendCount
=
%
"
PRIu32
"
\
n
"
this
mSuspendCount
-
1
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_TRUE
(
mSuspendCount
>
0
NS_ERROR_UNEXPECTED
)
;
LogCallingScriptLocation
(
this
)
;
nsresult
rv
=
NS_OK
;
if
(
!
-
-
mSuspendCount
)
{
if
(
RemoteChannelExists
(
)
&
&
mSuspendSent
)
{
SendResume
(
)
;
}
if
(
mCallOnResume
)
{
nsCOMPtr
<
nsISerialEventTarget
>
neckoTarget
=
GetNeckoTarget
(
)
;
MOZ_ASSERT
(
neckoTarget
)
;
RefPtr
<
HttpChannelChild
>
self
=
this
;
std
:
:
function
<
nsresult
(
HttpChannelChild
*
)
>
callOnResume
=
nullptr
;
std
:
:
swap
(
callOnResume
mCallOnResume
)
;
rv
=
neckoTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
net
:
:
HttpChannelChild
:
:
mCallOnResume
"
[
callOnResume
self
{
std
:
:
move
(
self
)
}
]
(
)
{
callOnResume
(
self
)
;
}
)
NS_DISPATCH_NORMAL
)
;
}
}
mEventQ
-
>
Resume
(
)
;
return
rv
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetSecurityInfo
(
nsISupports
*
*
aSecurityInfo
)
{
NS_ENSURE_ARG_POINTER
(
aSecurityInfo
)
;
*
aSecurityInfo
=
do_AddRef
(
mSecurityInfo
)
.
take
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
AsyncOpen
(
nsIStreamListener
*
aListener
)
{
LOG
(
(
"
HttpChannelChild
:
:
AsyncOpen
[
this
=
%
p
uri
=
%
s
]
\
n
"
this
mSpec
.
get
(
)
)
)
;
nsresult
rv
=
AsyncOpenInternal
(
aListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
uint32_t
blockingReason
=
0
;
mLoadInfo
-
>
GetRequestBlockingReason
(
&
blockingReason
)
;
LOG
(
(
"
HttpChannelChild
:
:
AsyncOpen
failed
[
this
=
%
p
rv
=
0x
%
08x
"
"
blocking
-
reason
=
%
u
]
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
blockingReason
)
)
;
gHttpHandler
-
>
OnFailedOpeningRequest
(
this
)
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mAsyncOpenSucceeded
=
NS_SUCCEEDED
(
rv
)
;
#
endif
return
rv
;
}
nsresult
HttpChannelChild
:
:
AsyncOpenInternal
(
nsIStreamListener
*
aListener
)
{
nsresult
rv
;
nsCOMPtr
<
nsIStreamListener
>
listener
=
aListener
;
rv
=
nsContentSecurityManager
:
:
doContentSecurityCheck
(
this
listener
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ReleaseListeners
(
)
;
return
rv
;
}
MOZ_ASSERT
(
mLoadInfo
-
>
GetSecurityMode
(
)
=
=
0
|
|
mLoadInfo
-
>
GetInitialSecurityCheckDone
(
)
|
|
(
mLoadInfo
-
>
GetSecurityMode
(
)
=
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
&
&
mLoadInfo
-
>
GetLoadingPrincipal
(
)
&
&
mLoadInfo
-
>
GetLoadingPrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
"
security
flags
in
loadInfo
but
doContentSecurityCheck
(
)
not
called
"
)
;
LogCallingScriptLocation
(
this
)
;
if
(
!
mLoadGroup
&
&
!
mCallbacks
)
{
UpdatePrivateBrowsing
(
)
;
}
#
ifdef
DEBUG
AssertPrivateBrowsingId
(
)
;
#
endif
if
(
mCanceled
)
{
ReleaseListeners
(
)
;
return
mStatus
;
}
NS_ENSURE_TRUE
(
gNeckoChild
!
=
nullptr
NS_ERROR_FAILURE
)
;
NS_ENSURE_ARG_POINTER
(
listener
)
;
NS_ENSURE_TRUE
(
!
LoadIsPending
(
)
NS_ERROR_IN_PROGRESS
)
;
NS_ENSURE_TRUE
(
!
LoadWasOpened
(
)
NS_ERROR_ALREADY_OPENED
)
;
if
(
MaybeWaitForUploadStreamNormalization
(
listener
nullptr
)
)
{
return
NS_OK
;
}
if
(
!
LoadAsyncOpenTimeOverriden
(
)
)
{
mAsyncOpenTime
=
TimeStamp
:
:
Now
(
)
;
}
rv
=
NS_CheckPortSafety
(
mURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReleaseListeners
(
)
;
return
rv
;
}
nsAutoCString
cookie
;
if
(
NS_SUCCEEDED
(
mRequestHead
.
GetHeader
(
nsHttp
:
:
Cookie
cookie
)
)
)
{
mUserSetCookieHeader
=
cookie
;
}
DebugOnly
<
nsresult
>
check
=
AddCookiesToRequest
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
check
)
)
;
gHttpHandler
-
>
OnOpeningRequest
(
this
)
;
mLastStatusReported
=
TimeStamp
:
:
Now
(
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsAutoCString
requestMethod
;
GetRequestMethod
(
requestMethod
)
;
profiler_add_network_marker
(
mURI
requestMethod
mPriority
mChannelId
NetworkLoadType
:
:
LOAD_START
mChannelCreationTimestamp
mLastStatusReported
0
kCacheUnknown
mLoadInfo
-
>
GetInnerWindowID
(
)
mLoadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
>
0
)
;
}
StoreIsPending
(
true
)
;
StoreWasOpened
(
true
)
;
mListener
=
listener
;
if
(
mLoadGroup
)
mLoadGroup
-
>
AddRequest
(
this
nullptr
)
;
if
(
mCanceled
)
{
ReleaseListeners
(
)
;
return
mStatus
;
}
HttpBaseChannel
:
:
SetDocshellUserAgentOverride
(
)
;
rv
=
ContinueAsyncOpen
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReleaseListeners
(
)
;
}
return
rv
;
}
void
HttpChannelChild
:
:
SetEventTarget
(
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
LoadInfo
(
)
;
nsCOMPtr
<
nsISerialEventTarget
>
target
=
nsContentUtils
:
:
GetEventTargetByLoadInfo
(
loadInfo
TaskCategory
:
:
Network
)
;
if
(
!
target
)
{
return
;
}
{
MutexAutoLock
lock
(
mEventTargetMutex
)
;
mNeckoTarget
=
target
;
}
}
already_AddRefed
<
nsISerialEventTarget
>
HttpChannelChild
:
:
GetNeckoTarget
(
)
{
nsCOMPtr
<
nsISerialEventTarget
>
target
;
{
MutexAutoLock
lock
(
mEventTargetMutex
)
;
target
=
mNeckoTarget
;
}
if
(
!
target
)
{
target
=
GetMainThreadSerialEventTarget
(
)
;
}
return
target
.
forget
(
)
;
}
already_AddRefed
<
nsIEventTarget
>
HttpChannelChild
:
:
GetODATarget
(
)
{
nsCOMPtr
<
nsIEventTarget
>
target
;
{
MutexAutoLock
lock
(
mEventTargetMutex
)
;
if
(
mODATarget
)
{
target
=
mODATarget
;
}
else
{
target
=
mNeckoTarget
;
}
}
if
(
!
target
)
{
target
=
GetMainThreadEventTarget
(
)
;
}
return
target
.
forget
(
)
;
}
nsresult
HttpChannelChild
:
:
ContinueAsyncOpen
(
)
{
nsresult
rv
;
mozilla
:
:
dom
:
:
BrowserChild
*
browserChild
=
nullptr
;
nsCOMPtr
<
nsIBrowserChild
>
iBrowserChild
;
GetCallback
(
iBrowserChild
)
;
if
(
iBrowserChild
)
{
browserChild
=
static_cast
<
mozilla
:
:
dom
:
:
BrowserChild
*
>
(
iBrowserChild
.
get
(
)
)
;
}
uint64_t
contentWindowId
=
0
;
TimeStamp
navigationStartTimeStamp
;
if
(
browserChild
)
{
MOZ_ASSERT
(
browserChild
-
>
WebNavigation
(
)
)
;
if
(
RefPtr
<
Document
>
document
=
browserChild
-
>
GetTopLevelDocument
(
)
)
{
contentWindowId
=
document
-
>
InnerWindowID
(
)
;
nsDOMNavigationTiming
*
navigationTiming
=
document
-
>
GetNavigationTiming
(
)
;
if
(
navigationTiming
)
{
navigationStartTimeStamp
=
navigationTiming
-
>
GetNavigationStartTimeStamp
(
)
;
}
}
if
(
BrowsingContext
*
bc
=
browserChild
-
>
GetBrowsingContext
(
)
)
{
mTopBrowsingContextId
=
bc
-
>
Top
(
)
-
>
Id
(
)
;
}
}
SetTopLevelContentWindowId
(
contentWindowId
)
;
HttpChannelOpenArgs
openArgs
;
SerializeURI
(
mURI
openArgs
.
uri
(
)
)
;
SerializeURI
(
mOriginalURI
openArgs
.
original
(
)
)
;
SerializeURI
(
mDocumentURI
openArgs
.
doc
(
)
)
;
SerializeURI
(
mAPIRedirectToURI
openArgs
.
apiRedirectTo
(
)
)
;
openArgs
.
loadFlags
(
)
=
mLoadFlags
;
openArgs
.
requestHeaders
(
)
=
mClientSetRequestHeaders
;
mRequestHead
.
Method
(
openArgs
.
requestMethod
(
)
)
;
openArgs
.
preferredAlternativeTypes
(
)
=
mPreferredCachedAltDataTypes
.
Clone
(
)
;
openArgs
.
referrerInfo
(
)
=
mReferrerInfo
;
if
(
mUploadStream
)
{
MOZ_ALWAYS_TRUE
(
SerializeIPCStream
(
do_AddRef
(
mUploadStream
)
openArgs
.
uploadStream
(
)
false
)
)
;
}
Maybe
<
CorsPreflightArgs
>
optionalCorsPreflightArgs
;
GetClientSetCorsPreflightParameters
(
optionalCorsPreflightArgs
)
;
nsCOMPtr
<
nsIURI
>
uri
;
GetTopWindowURI
(
mURI
getter_AddRefs
(
uri
)
)
;
SerializeURI
(
mTopWindowURI
openArgs
.
topWindowURI
(
)
)
;
openArgs
.
preflightArgs
(
)
=
optionalCorsPreflightArgs
;
openArgs
.
uploadStreamHasHeaders
(
)
=
LoadUploadStreamHasHeaders
(
)
;
openArgs
.
priority
(
)
=
mPriority
;
openArgs
.
classOfService
(
)
=
mClassOfService
;
openArgs
.
redirectionLimit
(
)
=
mRedirectionLimit
;
openArgs
.
allowSTS
(
)
=
LoadAllowSTS
(
)
;
openArgs
.
thirdPartyFlags
(
)
=
LoadThirdPartyFlags
(
)
;
openArgs
.
resumeAt
(
)
=
mSendResumeAt
;
openArgs
.
startPos
(
)
=
mStartPos
;
openArgs
.
entityID
(
)
=
mEntityID
;
openArgs
.
allowSpdy
(
)
=
LoadAllowSpdy
(
)
;
openArgs
.
allowHttp3
(
)
=
LoadAllowHttp3
(
)
;
openArgs
.
allowAltSvc
(
)
=
LoadAllowAltSvc
(
)
;
openArgs
.
beConservative
(
)
=
LoadBeConservative
(
)
;
openArgs
.
bypassProxy
(
)
=
BypassProxy
(
)
;
openArgs
.
tlsFlags
(
)
=
mTlsFlags
;
openArgs
.
initialRwin
(
)
=
mInitialRwin
;
openArgs
.
cacheKey
(
)
=
mCacheKey
;
openArgs
.
blockAuthPrompt
(
)
=
LoadBlockAuthPrompt
(
)
;
openArgs
.
allowStaleCacheContent
(
)
=
LoadAllowStaleCacheContent
(
)
;
openArgs
.
preferCacheLoadOverBypass
(
)
=
LoadPreferCacheLoadOverBypass
(
)
;
openArgs
.
contentTypeHint
(
)
=
mContentTypeHint
;
rv
=
mozilla
:
:
ipc
:
:
LoadInfoToLoadInfoArgs
(
mLoadInfo
&
openArgs
.
loadInfo
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EnsureRequestContextID
(
)
;
openArgs
.
requestContextID
(
)
=
mRequestContextID
;
openArgs
.
requestMode
(
)
=
mRequestMode
;
openArgs
.
redirectMode
(
)
=
mRedirectMode
;
openArgs
.
channelId
(
)
=
mChannelId
;
openArgs
.
integrityMetadata
(
)
=
mIntegrityMetadata
;
openArgs
.
contentWindowId
(
)
=
contentWindowId
;
openArgs
.
topBrowsingContextId
(
)
=
mTopBrowsingContextId
;
LOG
(
(
"
HttpChannelChild
:
:
ContinueAsyncOpen
this
=
%
p
gid
=
%
"
PRIu64
"
top
bid
=
%
"
PRIx64
this
mChannelId
mTopBrowsingContextId
)
)
;
if
(
browserChild
&
&
!
browserChild
-
>
IPCOpen
(
)
)
{
return
NS_ERROR_FAILURE
;
}
ContentChild
*
cc
=
static_cast
<
ContentChild
*
>
(
gNeckoChild
-
>
Manager
(
)
)
;
if
(
cc
-
>
IsShuttingDown
(
)
)
{
return
NS_ERROR_FAILURE
;
}
openArgs
.
launchServiceWorkerStart
(
)
=
mLaunchServiceWorkerStart
;
openArgs
.
launchServiceWorkerEnd
(
)
=
mLaunchServiceWorkerEnd
;
openArgs
.
dispatchFetchEventStart
(
)
=
mDispatchFetchEventStart
;
openArgs
.
dispatchFetchEventEnd
(
)
=
mDispatchFetchEventEnd
;
openArgs
.
handleFetchEventStart
(
)
=
mHandleFetchEventStart
;
openArgs
.
handleFetchEventEnd
(
)
=
mHandleFetchEventEnd
;
openArgs
.
forceMainDocumentChannel
(
)
=
LoadForceMainDocumentChannel
(
)
;
openArgs
.
navigationStartTimeStamp
(
)
=
navigationStartTimeStamp
;
SetEventTarget
(
)
;
if
(
!
gNeckoChild
-
>
SendPHttpChannelConstructor
(
this
browserChild
IPC
:
:
SerializedLoadContext
(
this
)
openArgs
)
)
{
return
NS_ERROR_FAILURE
;
}
{
MutexAutoLock
lock
(
mBgChildMutex
)
;
MOZ_RELEASE_ASSERT
(
gSocketTransportService
)
;
if
(
mBgChild
)
{
RefPtr
<
HttpBackgroundChannelChild
>
prevBgChild
=
std
:
:
move
(
mBgChild
)
;
gSocketTransportService
-
>
Dispatch
(
NewRunnableMethod
(
"
HttpBackgroundChannelChild
:
:
OnChannelClosed
"
prevBgChild
&
HttpBackgroundChannelChild
:
:
OnChannelClosed
)
NS_DISPATCH_NORMAL
)
;
}
MOZ_ASSERT
(
!
mBgInitFailCallback
)
;
mBgInitFailCallback
=
NewRunnableMethod
<
nsresult
>
(
"
HttpChannelChild
:
:
FailedAsyncOpen
"
this
&
HttpChannelChild
:
:
FailedAsyncOpen
NS_ERROR_FAILURE
)
;
RefPtr
<
HttpBackgroundChannelChild
>
bgChild
=
new
HttpBackgroundChannelChild
(
)
;
RefPtr
<
HttpChannelChild
>
self
=
this
;
nsresult
rv
=
gSocketTransportService
-
>
Dispatch
(
NewRunnableMethod
<
RefPtr
<
HttpChannelChild
>
>
(
"
HttpBackgroundChannelChild
:
:
Init
"
bgChild
&
HttpBackgroundChannelChild
:
:
Init
self
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mBgChild
=
std
:
:
move
(
bgChild
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mEverHadBgChildAtAsyncOpen
=
true
;
#
endif
}
MaybeConnectToSocketProcess
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
SetRequestHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
bool
aMerge
)
{
LOG
(
(
"
HttpChannelChild
:
:
SetRequestHeader
[
this
=
%
p
]
\
n
"
this
)
)
;
nsresult
rv
=
HttpBaseChannel
:
:
SetRequestHeader
(
aHeader
aValue
aMerge
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
RequestHeaderTuple
*
tuple
=
mClientSetRequestHeaders
.
AppendElement
(
)
;
if
(
!
tuple
)
return
NS_ERROR_OUT_OF_MEMORY
;
tuple
-
>
mHeader
=
aHeader
;
tuple
-
>
mValue
=
aValue
;
tuple
-
>
mMerge
=
aMerge
;
tuple
-
>
mEmpty
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
SetEmptyRequestHeader
(
const
nsACString
&
aHeader
)
{
LOG
(
(
"
HttpChannelChild
:
:
SetEmptyRequestHeader
[
this
=
%
p
]
\
n
"
this
)
)
;
nsresult
rv
=
HttpBaseChannel
:
:
SetEmptyRequestHeader
(
aHeader
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
RequestHeaderTuple
*
tuple
=
mClientSetRequestHeaders
.
AppendElement
(
)
;
if
(
!
tuple
)
return
NS_ERROR_OUT_OF_MEMORY
;
tuple
-
>
mHeader
=
aHeader
;
tuple
-
>
mMerge
=
false
;
tuple
-
>
mEmpty
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
RedirectTo
(
nsIURI
*
newURI
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
UpgradeToSecure
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetProtocolVersion
(
nsACString
&
aProtocolVersion
)
{
aProtocolVersion
=
mProtocolVersion
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetIsAuthChannel
(
bool
*
aIsAuthChannel
)
{
DROP_DEAD
(
)
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetCacheTokenFetchCount
(
uint32_t
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mCacheEntryAvailable
&
&
!
mAltDataCacheEntryAvailable
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
_retval
=
mCacheFetchCount
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetCacheTokenExpirationTime
(
uint32_t
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mCacheEntryAvailable
)
return
NS_ERROR_NOT_AVAILABLE
;
*
_retval
=
mCacheExpirationTime
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
IsFromCache
(
bool
*
value
)
{
if
(
!
LoadIsPending
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
*
value
=
mIsFromCache
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetCacheEntryId
(
uint64_t
*
aCacheEntryId
)
{
bool
fromCache
=
false
;
if
(
NS_FAILED
(
IsFromCache
(
&
fromCache
)
)
|
|
!
fromCache
|
|
!
mCacheEntryAvailable
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aCacheEntryId
=
mCacheEntryId
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
IsRacing
(
bool
*
aIsRacing
)
{
if
(
!
LoadAfterOnStartRequestBegun
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aIsRacing
=
mIsRacing
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetCacheKey
(
uint32_t
*
cacheKey
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
*
cacheKey
=
mCacheKey
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
SetCacheKey
(
uint32_t
cacheKey
)
{
ENSURE_CALLED_BEFORE_ASYNC_OPEN
(
)
;
mCacheKey
=
cacheKey
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
SetAllowStaleCacheContent
(
bool
aAllowStaleCacheContent
)
{
StoreAllowStaleCacheContent
(
aAllowStaleCacheContent
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetAllowStaleCacheContent
(
bool
*
aAllowStaleCacheContent
)
{
NS_ENSURE_ARG
(
aAllowStaleCacheContent
)
;
*
aAllowStaleCacheContent
=
LoadAllowStaleCacheContent
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
SetForceValidateCacheContent
(
bool
aForceValidateCacheContent
)
{
StoreForceValidateCacheContent
(
aForceValidateCacheContent
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetForceValidateCacheContent
(
bool
*
aForceValidateCacheContent
)
{
NS_ENSURE_ARG
(
aForceValidateCacheContent
)
;
*
aForceValidateCacheContent
=
LoadForceValidateCacheContent
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
SetPreferCacheLoadOverBypass
(
bool
aPreferCacheLoadOverBypass
)
{
StorePreferCacheLoadOverBypass
(
aPreferCacheLoadOverBypass
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetPreferCacheLoadOverBypass
(
bool
*
aPreferCacheLoadOverBypass
)
{
NS_ENSURE_ARG
(
aPreferCacheLoadOverBypass
)
;
*
aPreferCacheLoadOverBypass
=
LoadPreferCacheLoadOverBypass
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
PreferAlternativeDataType
(
const
nsACString
&
aType
const
nsACString
&
aContentType
PreferredAlternativeDataDeliveryType
aDeliverAltData
)
{
ENSURE_CALLED_BEFORE_ASYNC_OPEN
(
)
;
mPreferredCachedAltDataTypes
.
AppendElement
(
PreferredAlternativeDataTypeParams
(
nsCString
(
aType
)
nsCString
(
aContentType
)
aDeliverAltData
)
)
;
return
NS_OK
;
}
const
nsTArray
<
PreferredAlternativeDataTypeParams
>
&
HttpChannelChild
:
:
PreferredAlternativeDataTypes
(
)
{
return
mPreferredCachedAltDataTypes
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetAlternativeDataType
(
nsACString
&
aType
)
{
if
(
!
LoadAfterOnStartRequestBegun
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
aType
=
mAvailableCachedAltDataType
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
OpenAlternativeOutputStream
(
const
nsACString
&
aType
int64_t
aPredictedSize
nsIAsyncOutputStream
*
*
_retval
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
only
"
)
;
if
(
!
CanSend
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
static_cast
<
ContentChild
*
>
(
gNeckoChild
-
>
Manager
(
)
)
-
>
IsShuttingDown
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsISerialEventTarget
>
neckoTarget
=
GetNeckoTarget
(
)
;
MOZ_ASSERT
(
neckoTarget
)
;
RefPtr
<
AltDataOutputStreamChild
>
stream
=
new
AltDataOutputStreamChild
(
)
;
stream
-
>
AddIPDLReference
(
)
;
if
(
!
gNeckoChild
-
>
SendPAltDataOutputStreamConstructor
(
stream
nsCString
(
aType
)
aPredictedSize
this
)
)
{
return
NS_ERROR_FAILURE
;
}
stream
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetOriginalInputStream
(
nsIInputStreamReceiver
*
aReceiver
)
{
if
(
aReceiver
=
=
nullptr
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
CanSend
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mOriginalInputStreamReceiver
=
aReceiver
;
Unused
<
<
SendOpenOriginalCacheInputStream
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetAlternativeDataInputStream
(
nsIInputStream
*
*
aInputStream
)
{
NS_ENSURE_ARG_POINTER
(
aInputStream
)
;
nsCOMPtr
<
nsIInputStream
>
is
=
mAltDataInputStream
;
is
.
forget
(
aInputStream
)
;
return
NS_OK
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelChild
:
:
RecvOriginalCacheInputStreamAvailable
(
const
Maybe
<
IPCStream
>
&
aStream
)
{
nsCOMPtr
<
nsIInputStream
>
stream
=
DeserializeIPCStream
(
aStream
)
;
nsCOMPtr
<
nsIInputStreamReceiver
>
receiver
;
receiver
.
swap
(
mOriginalInputStreamReceiver
)
;
if
(
receiver
)
{
receiver
-
>
OnInputStreamReady
(
stream
)
;
}
return
IPC_OK
(
)
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
ResumeAt
(
uint64_t
startPos
const
nsACString
&
entityID
)
{
LOG
(
(
"
HttpChannelChild
:
:
ResumeAt
[
this
=
%
p
]
\
n
"
this
)
)
;
ENSURE_CALLED_BEFORE_CONNECT
(
)
;
mStartPos
=
startPos
;
mEntityID
=
entityID
;
mSendResumeAt
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
SetPriority
(
int32_t
aPriority
)
{
LOG
(
(
"
HttpChannelChild
:
:
SetPriority
%
p
p
=
%
d
"
this
aPriority
)
)
;
int16_t
newValue
=
clamped
<
int32_t
>
(
aPriority
INT16_MIN
INT16_MAX
)
;
if
(
mPriority
=
=
newValue
)
return
NS_OK
;
mPriority
=
newValue
;
if
(
RemoteChannelExists
(
)
)
SendSetPriority
(
mPriority
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
SetClassFlags
(
uint32_t
inFlags
)
{
if
(
mClassOfService
.
Flags
(
)
=
=
inFlags
)
{
return
NS_OK
;
}
mClassOfService
.
SetFlags
(
inFlags
)
;
LOG
(
(
"
HttpChannelChild
%
p
ClassOfService
flags
=
%
lu
inc
=
%
d
"
this
mClassOfService
.
Flags
(
)
mClassOfService
.
Incremental
(
)
)
)
;
if
(
RemoteChannelExists
(
)
)
{
SendSetClassOfService
(
mClassOfService
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
AddClassFlags
(
uint32_t
inFlags
)
{
mClassOfService
.
SetFlags
(
inFlags
|
mClassOfService
.
Flags
(
)
)
;
LOG
(
(
"
HttpChannelChild
%
p
ClassOfService
flags
=
%
lu
inc
=
%
d
"
this
mClassOfService
.
Flags
(
)
mClassOfService
.
Incremental
(
)
)
)
;
if
(
RemoteChannelExists
(
)
)
{
SendSetClassOfService
(
mClassOfService
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
ClearClassFlags
(
uint32_t
inFlags
)
{
mClassOfService
.
SetFlags
(
~
inFlags
&
mClassOfService
.
Flags
(
)
)
;
LOG
(
(
"
HttpChannelChild
%
p
ClassOfService
=
%
lu
"
this
mClassOfService
.
Flags
(
)
)
)
;
if
(
RemoteChannelExists
(
)
)
{
SendSetClassOfService
(
mClassOfService
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
SetClassOfService
(
ClassOfService
inCos
)
{
mClassOfService
=
inCos
;
LOG
(
(
"
HttpChannelChild
%
p
ClassOfService
flags
=
%
lu
inc
=
%
d
"
this
mClassOfService
.
Flags
(
)
mClassOfService
.
Incremental
(
)
)
)
;
if
(
RemoteChannelExists
(
)
)
{
SendSetClassOfService
(
mClassOfService
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
SetIncremental
(
bool
inIncremental
)
{
mClassOfService
.
SetIncremental
(
inIncremental
)
;
LOG
(
(
"
HttpChannelChild
%
p
ClassOfService
flags
=
%
lu
inc
=
%
d
"
this
mClassOfService
.
Flags
(
)
mClassOfService
.
Incremental
(
)
)
)
;
if
(
RemoteChannelExists
(
)
)
{
SendSetClassOfService
(
mClassOfService
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetProxyInfo
(
nsIProxyInfo
*
*
aProxyInfo
)
{
DROP_DEAD
(
)
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetHttpProxyConnectResponseCode
(
int32_t
*
aResponseCode
)
{
DROP_DEAD
(
)
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
AddCookiesToRequest
(
)
{
HttpBaseChannel
:
:
AddCookiesToRequest
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetClientSetRequestHeaders
(
RequestHeaderTuples
*
*
aRequestHeaders
)
{
*
aRequestHeaders
=
&
mClientSetRequestHeaders
;
return
NS_OK
;
}
void
HttpChannelChild
:
:
GetClientSetCorsPreflightParameters
(
Maybe
<
CorsPreflightArgs
>
&
aArgs
)
{
if
(
LoadRequireCORSPreflight
(
)
)
{
CorsPreflightArgs
args
;
args
.
unsafeHeaders
(
)
=
mUnsafeHeaders
.
Clone
(
)
;
aArgs
.
emplace
(
args
)
;
}
else
{
aArgs
=
Nothing
(
)
;
}
}
NS_IMETHODIMP
HttpChannelChild
:
:
RemoveCorsPreflightCacheEntry
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
const
OriginAttributes
&
aOriginAttributes
)
{
URIParams
uri
;
SerializeURI
(
aURI
uri
)
;
PrincipalInfo
principalInfo
;
nsresult
rv
=
PrincipalToPrincipalInfo
(
aPrincipal
&
principalInfo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
result
=
false
;
if
(
CanSend
(
)
)
{
result
=
SendRemoveCorsPreflightCacheEntry
(
uri
principalInfo
aOriginAttributes
)
;
}
return
result
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetBaseChannel
(
nsIChannel
*
*
aBaseChannel
)
{
if
(
!
mMultiPartID
)
{
MOZ_ASSERT
(
false
"
Not
a
multipart
channel
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIChannel
>
channel
=
this
;
channel
.
forget
(
aBaseChannel
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetPartID
(
uint32_t
*
aPartID
)
{
if
(
!
mMultiPartID
)
{
MOZ_ASSERT
(
false
"
Not
a
multipart
channel
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aPartID
=
*
mMultiPartID
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetIsFirstPart
(
bool
*
aIsFirstPart
)
{
if
(
!
mMultiPartID
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aIsFirstPart
=
mIsFirstPartOfMultiPart
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetIsLastPart
(
bool
*
aIsLastPart
)
{
if
(
!
mMultiPartID
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aIsLastPart
=
mIsLastPartOfMultiPart
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
RetargetDeliveryTo
(
nsIEventTarget
*
aNewTarget
)
{
LOG
(
(
"
HttpChannelChild
:
:
RetargetDeliveryTo
[
this
=
%
p
aNewTarget
=
%
p
]
"
this
aNewTarget
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
called
on
main
thread
only
"
)
;
MOZ_ASSERT
(
aNewTarget
)
;
NS_ENSURE_ARG
(
aNewTarget
)
;
if
(
aNewTarget
-
>
IsOnCurrentThread
(
)
)
{
NS_WARNING
(
"
Retargeting
delivery
to
same
thread
"
)
;
mOMTResult
=
LABELS_HTTP_CHILD_OMT_STATS
:
:
successMainThread
;
return
NS_OK
;
}
if
(
mMultiPartID
)
{
mOMTResult
=
LABELS_HTTP_CHILD_OMT_STATS
:
:
failListener
;
return
NS_ERROR_NO_INTERFACE
;
}
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIThreadRetargetableStreamListener
>
retargetableListener
=
do_QueryInterface
(
mListener
&
rv
)
;
if
(
!
retargetableListener
|
|
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Listener
is
not
retargetable
"
)
;
mOMTResult
=
LABELS_HTTP_CHILD_OMT_STATS
:
:
failListener
;
return
NS_ERROR_NO_INTERFACE
;
}
rv
=
retargetableListener
-
>
CheckListenerChain
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Subsequent
listeners
are
not
retargetable
"
)
;
mOMTResult
=
LABELS_HTTP_CHILD_OMT_STATS
:
:
failListenerChain
;
return
rv
;
}
{
MutexAutoLock
lock
(
mEventTargetMutex
)
;
MOZ_ASSERT
(
!
mODATarget
)
;
mODATarget
=
aNewTarget
;
}
mOMTResult
=
LABELS_HTTP_CHILD_OMT_STATS
:
:
success
;
return
NS_OK
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
GetDeliveryTarget
(
nsIEventTarget
*
*
aEventTarget
)
{
MutexAutoLock
lock
(
mEventTargetMutex
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
mODATarget
;
if
(
!
mODATarget
)
{
target
=
GetCurrentEventTarget
(
)
;
}
target
.
forget
(
aEventTarget
)
;
return
NS_OK
;
}
void
HttpChannelChild
:
:
TrySendDeletingChannel
(
)
{
AUTO_PROFILER_LABEL
(
"
HttpChannelChild
:
:
TrySendDeletingChannel
"
NETWORK
)
;
if
(
!
mDeletingChannelSent
.
compareExchange
(
false
true
)
)
{
return
;
}
if
(
NS_IsMainThread
(
)
)
{
if
(
NS_WARN_IF
(
!
CanSend
(
)
)
)
{
return
;
}
Unused
<
<
PHttpChannelChild
:
:
SendDeletingChannel
(
)
;
return
;
}
nsCOMPtr
<
nsISerialEventTarget
>
neckoTarget
=
GetNeckoTarget
(
)
;
MOZ_ASSERT
(
neckoTarget
)
;
DebugOnly
<
nsresult
>
rv
=
neckoTarget
-
>
Dispatch
(
NewNonOwningRunnableMethod
(
"
net
:
:
HttpChannelChild
:
:
TrySendDeletingChannel
"
this
&
HttpChannelChild
:
:
TrySendDeletingChannel
)
NS_DISPATCH_NORMAL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsresult
HttpChannelChild
:
:
AsyncCallImpl
(
void
(
HttpChannelChild
:
:
*
funcPtr
)
(
)
nsRunnableMethod
<
HttpChannelChild
>
*
*
retval
)
{
nsresult
rv
;
RefPtr
<
nsRunnableMethod
<
HttpChannelChild
>
>
event
=
NewRunnableMethod
(
"
net
:
:
HttpChannelChild
:
:
AsyncCall
"
this
funcPtr
)
;
nsCOMPtr
<
nsISerialEventTarget
>
neckoTarget
=
GetNeckoTarget
(
)
;
MOZ_ASSERT
(
neckoTarget
)
;
rv
=
neckoTarget
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
retval
)
{
*
retval
=
event
;
}
return
rv
;
}
nsresult
HttpChannelChild
:
:
SetReferrerHeader
(
const
nsACString
&
aReferrer
bool
aRespectBeforeConnect
)
{
if
(
aRespectBeforeConnect
)
{
ENSURE_CALLED_BEFORE_ASYNC_OPEN
(
)
;
}
mClientSetRequestHeaders
.
RemoveElementsBy
(
[
]
(
const
auto
&
header
)
{
return
"
Referer
"
_ns
.
Equals
(
header
.
mHeader
)
;
}
)
;
return
HttpBaseChannel
:
:
SetReferrerHeader
(
aReferrer
aRespectBeforeConnect
)
;
}
void
HttpChannelChild
:
:
CancelOnMainThread
(
nsresult
aRv
)
{
LOG
(
(
"
HttpChannelChild
:
:
CancelOnMainThread
[
this
=
%
p
]
"
this
)
)
;
if
(
NS_IsMainThread
(
)
)
{
Cancel
(
aRv
)
;
return
;
}
mEventQ
-
>
Suspend
(
)
;
mEventQ
-
>
PrependEvent
(
MakeUnique
<
NeckoTargetChannelFunctionEvent
>
(
this
[
self
=
UnsafePtr
<
HttpChannelChild
>
(
this
)
aRv
]
(
)
{
self
-
>
Cancel
(
aRv
)
;
}
)
)
;
mEventQ
-
>
Resume
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelChild
:
:
RecvSetPriority
(
const
int16_t
&
aPriority
)
{
mPriority
=
aPriority
;
return
IPC_OK
(
)
;
}
class
AttachStreamFilterEvent
:
public
ChannelEvent
{
public
:
AttachStreamFilterEvent
(
HttpChannelChild
*
aChild
already_AddRefed
<
nsIEventTarget
>
aTarget
Endpoint
<
extensions
:
:
PStreamFilterParent
>
&
&
aEndpoint
)
:
mChild
(
aChild
)
mTarget
(
aTarget
)
mEndpoint
(
std
:
:
move
(
aEndpoint
)
)
{
}
already_AddRefed
<
nsIEventTarget
>
GetEventTarget
(
)
override
{
nsCOMPtr
<
nsIEventTarget
>
target
=
mTarget
;
return
target
.
forget
(
)
;
}
void
Run
(
)
override
{
extensions
:
:
StreamFilterParent
:
:
Attach
(
mChild
std
:
:
move
(
mEndpoint
)
)
;
}
private
:
HttpChannelChild
*
mChild
;
nsCOMPtr
<
nsIEventTarget
>
mTarget
;
Endpoint
<
extensions
:
:
PStreamFilterParent
>
mEndpoint
;
}
;
void
HttpChannelChild
:
:
ProcessAttachStreamFilter
(
Endpoint
<
extensions
:
:
PStreamFilterParent
>
&
&
aEndpoint
)
{
LOG
(
(
"
HttpChannelChild
:
:
ProcessAttachStreamFilter
[
this
=
%
p
]
\
n
"
this
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
mEventQ
-
>
RunOrEnqueue
(
new
AttachStreamFilterEvent
(
this
GetNeckoTarget
(
)
std
:
:
move
(
aEndpoint
)
)
)
;
}
void
HttpChannelChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mActorDestroyReason
.
emplace
(
aWhy
)
;
#
endif
if
(
aWhy
!
=
Deletion
)
{
AutoEventEnqueuer
ensureSerialDispatch
(
mEventQ
)
;
mStatus
=
NS_ERROR_DOCSHELL_DYING
;
HandleAsyncAbort
(
)
;
CleanupBackgroundChannel
(
)
;
mIPCActorDeleted
=
true
;
mCanceled
=
true
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelChild
:
:
RecvLogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
{
Unused
<
<
LogBlockedCORSRequest
(
aMessage
aCategory
)
;
return
IPC_OK
(
)
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
{
uint64_t
innerWindowID
=
mLoadInfo
-
>
GetInnerWindowID
(
)
;
bool
privateBrowsing
=
!
!
mLoadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
;
bool
fromChromeContext
=
mLoadInfo
-
>
TriggeringPrincipal
(
)
-
>
IsSystemPrincipal
(
)
;
nsCORSListenerProxy
:
:
LogBlockedCORSRequest
(
innerWindowID
privateBrowsing
fromChromeContext
aMessage
aCategory
)
;
return
NS_OK
;
}
mozilla
:
:
ipc
:
:
IPCResult
HttpChannelChild
:
:
RecvLogMimeTypeMismatch
(
const
nsACString
&
aMessageName
const
bool
&
aWarning
const
nsAString
&
aURL
const
nsAString
&
aContentType
)
{
Unused
<
<
LogMimeTypeMismatch
(
aMessageName
aWarning
aURL
aContentType
)
;
return
IPC_OK
(
)
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
LogMimeTypeMismatch
(
const
nsACString
&
aMessageName
bool
aWarning
const
nsAString
&
aURL
const
nsAString
&
aContentType
)
{
RefPtr
<
Document
>
doc
;
mLoadInfo
-
>
GetLoadingDocument
(
getter_AddRefs
(
doc
)
)
;
AutoTArray
<
nsString
2
>
params
;
params
.
AppendElement
(
aURL
)
;
params
.
AppendElement
(
aContentType
)
;
nsContentUtils
:
:
ReportToConsole
(
aWarning
?
nsIScriptError
:
:
warningFlag
:
nsIScriptError
:
:
errorFlag
"
MIMEMISMATCH
"
_ns
doc
nsContentUtils
:
:
eSECURITY_PROPERTIES
nsCString
(
aMessageName
)
.
get
(
)
params
)
;
return
NS_OK
;
}
nsresult
HttpChannelChild
:
:
MaybeLogCOEPError
(
nsresult
aStatus
)
{
if
(
aStatus
=
=
NS_ERROR_DOM_CORP_FAILED
)
{
RefPtr
<
Document
>
doc
;
mLoadInfo
-
>
GetLoadingDocument
(
getter_AddRefs
(
doc
)
)
;
nsAutoCString
url
;
mURI
-
>
GetSpec
(
url
)
;
AutoTArray
<
nsString
2
>
params
;
params
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
url
)
)
;
params
.
AppendElement
(
u
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Web
/
HTTP
/
Cross
-
Origin_Resource_Policy_
(
CORP
)
#
"
_ns
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
"
COEP
"
_ns
doc
nsContentUtils
:
:
eNECKO_PROPERTIES
"
CORPBlocked
"
params
)
;
}
return
NS_OK
;
}
nsresult
HttpChannelChild
:
:
CrossProcessRedirectFinished
(
nsresult
aStatus
)
{
if
(
!
CanSend
(
)
)
{
return
NS_BINDING_FAILED
;
}
if
(
!
mCanceled
&
&
NS_SUCCEEDED
(
mStatus
)
)
{
mStatus
=
aStatus
;
}
return
mStatus
;
}
void
HttpChannelChild
:
:
DoDiagnosticAssertWhenOnStopNotCalledOnDestroy
(
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mDoDiagnosticAssertWhenOnStopNotCalledOnDestroy
=
true
;
#
endif
}
void
HttpChannelChild
:
:
MaybeConnectToSocketProcess
(
)
{
if
(
!
nsIOService
:
:
UseSocketProcess
(
)
)
{
return
;
}
if
(
!
StaticPrefs
:
:
network_send_ODA_to_content_directly
(
)
)
{
return
;
}
RefPtr
<
HttpBackgroundChannelChild
>
bgChild
;
{
MutexAutoLock
lock
(
mBgChildMutex
)
;
bgChild
=
mBgChild
;
}
SocketProcessBridgeChild
:
:
GetSocketProcessBridge
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
bgChild
]
(
)
{
gSocketTransportService
-
>
Dispatch
(
NewRunnableMethod
(
"
HttpBackgroundChannelChild
:
:
CreateDataBridge
"
bgChild
&
HttpBackgroundChannelChild
:
:
CreateDataBridge
)
NS_DISPATCH_NORMAL
)
;
}
[
]
(
)
{
NS_WARNING
(
"
Failed
to
create
SocketProcessBridgeChild
"
)
;
}
)
;
}
NS_IMETHODIMP
HttpChannelChild
:
:
SetEarlyHintObserver
(
nsIEarlyHintObserver
*
aObserver
)
{
return
NS_OK
;
}
}
