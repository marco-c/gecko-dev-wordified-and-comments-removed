#
include
"
HttpLog
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
#
include
<
algorithm
>
#
include
"
Http2Compression
.
h
"
#
include
"
Http2Session
.
h
"
#
include
"
Http2StreamBase
.
h
"
#
include
"
Http2Stream
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
glean
/
NetwerkProtocolHttpMetrics
.
h
"
#
include
"
nsHttp
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsHttpRequestHead
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
prnetdb
.
h
"
namespace
mozilla
:
:
net
{
NS_IMPL_ADDREF
(
Http2StreamBase
)
NS_IMETHODIMP_
(
MozExternalRefCountType
)
Http2StreamBase
:
:
Release
(
)
{
nsrefcnt
count
;
MOZ_ASSERT
(
0
!
=
mRefCnt
"
dup
release
"
)
;
count
=
-
-
mRefCnt
;
NS_LOG_RELEASE
(
this
count
"
Http2StreamBase
"
)
;
if
(
0
=
=
count
)
{
mRefCnt
=
1
;
DeleteSelfOnSocketThread
(
)
;
return
0
;
}
return
count
;
}
NS_IMPL_QUERY_INTERFACE0
(
Http2StreamBase
)
class
DeleteHttp2StreamBase
:
public
Runnable
{
public
:
explicit
DeleteHttp2StreamBase
(
Http2StreamBase
*
aStream
)
:
Runnable
(
"
net
:
:
DeleteHttp2StreamBase
"
)
mStream
(
aStream
)
{
}
NS_IMETHOD
Run
(
)
override
{
delete
mStream
;
return
NS_OK
;
}
private
:
Http2StreamBase
*
mStream
;
}
;
void
Http2StreamBase
:
:
DeleteSelfOnSocketThread
(
)
{
if
(
OnSocketThread
(
)
)
{
delete
this
;
return
;
}
nsCOMPtr
<
nsIEventTarget
>
sts
=
mozilla
:
:
components
:
:
SocketTransport
:
:
Service
(
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
DeleteHttp2StreamBase
(
this
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
sts
-
>
Dispatch
(
event
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
)
;
}
Http2StreamBase
:
:
Http2StreamBase
(
uint64_t
aTransactionBrowserId
Http2Session
*
session
int32_t
priority
uint64_t
currentBrowserId
)
:
mSession
(
do_GetWeakReference
(
static_cast
<
nsISupportsWeakReference
*
>
(
session
)
)
)
mRequestHeadersDone
(
0
)
mOpenGenerated
(
0
)
mAllHeadersReceived
(
0
)
mQueued
(
0
)
mInWriteQueue
(
0
)
mInReadQueue
(
0
)
mSocketTransport
(
session
-
>
SocketTransport
(
)
)
mCurrentBrowserId
(
currentBrowserId
)
mTransactionBrowserId
(
aTransactionBrowserId
)
mTxInlineFrameSize
(
Http2Session
:
:
kDefaultBufferSize
)
mChunkSize
(
session
-
>
SendingChunkSize
(
)
)
mRequestBlockedOnRead
(
0
)
mRecvdFin
(
0
)
mReceivedData
(
0
)
mRecvdReset
(
0
)
mSentReset
(
0
)
mCountAsActive
(
0
)
mSentFin
(
0
)
mSentWaitingFor
(
0
)
mSetTCPSocketBuffer
(
0
)
mBypassInputBuffer
(
0
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG1
(
(
"
Http2StreamBase
:
:
Http2StreamBase
%
p
"
this
)
)
;
mServerReceiveWindow
=
session
-
>
GetServerInitialStreamWindow
(
)
;
mClientReceiveWindow
=
session
-
>
PushAllowance
(
)
;
mTxInlineFrame
=
MakeUnique
<
uint8_t
[
]
>
(
mTxInlineFrameSize
)
;
static_assert
(
nsISupportsPriority
:
:
PRIORITY_LOWEST
<
=
kNormalPriority
"
Lowest
Priority
should
be
less
than
kNormalPriority
"
)
;
int32_t
httpPriority
;
if
(
priority
>
=
nsISupportsPriority
:
:
PRIORITY_LOWEST
)
{
httpPriority
=
kWorstPriority
;
}
else
if
(
priority
<
=
nsISupportsPriority
:
:
PRIORITY_HIGHEST
)
{
httpPriority
=
kBestPriority
;
}
else
{
httpPriority
=
kNormalPriority
+
priority
;
}
MOZ_ASSERT
(
httpPriority
>
=
0
)
;
SetPriority
(
static_cast
<
uint32_t
>
(
httpPriority
)
)
;
}
Http2StreamBase
:
:
~
Http2StreamBase
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
OnSocketThread
(
)
)
;
mStreamID
=
Http2Session
:
:
kDeadStreamID
;
LOG3
(
(
"
Http2StreamBase
:
:
~
Http2StreamBase
%
p
"
this
)
)
;
}
already_AddRefed
<
Http2Session
>
Http2StreamBase
:
:
Session
(
)
{
RefPtr
<
Http2Session
>
session
=
do_QueryReferent
(
mSession
)
;
return
session
.
forget
(
)
;
}
nsresult
Http2StreamBase
:
:
ReadSegments
(
nsAHttpSegmentReader
*
reader
uint32_t
count
uint32_t
*
countRead
)
{
LOG3
(
(
"
Http2StreamBase
%
p
ReadSegments
reader
=
%
p
count
=
%
d
state
=
%
x
"
this
reader
count
mUpstreamState
)
)
;
RefPtr
<
Http2Session
>
session
=
Session
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
reader
|
|
(
reader
=
=
session
)
|
|
(
IsTunnel
(
)
&
&
NS_FAILED
(
Condition
(
)
)
)
)
;
if
(
NS_FAILED
(
Condition
(
)
)
)
{
return
Condition
(
)
;
}
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
nsresult
rv
=
NS_ERROR_UNEXPECTED
;
mRequestBlockedOnRead
=
0
;
if
(
mRecvdFin
|
|
mRecvdReset
)
{
LOG3
(
(
"
Http2StreamBase
%
p
ReadSegments
request
stream
aborted
due
to
"
"
response
side
closure
\
n
"
this
)
)
;
return
NS_ERROR_ABORT
;
}
if
(
count
>
(
mChunkSize
+
8
)
)
{
uint32_t
numchunks
=
count
/
(
mChunkSize
+
8
)
;
count
=
numchunks
*
(
mChunkSize
+
8
)
;
}
switch
(
mUpstreamState
)
{
case
GENERATING_HEADERS
:
case
GENERATING_BODY
:
case
SENDING_BODY
:
mSegmentReader
=
reader
;
rv
=
CallToReadData
(
count
countRead
)
;
mSegmentReader
=
nullptr
;
LOG3
(
(
"
Http2StreamBase
:
:
ReadSegments
%
p
trans
readsegments
rv
%
"
PRIx32
"
read
=
%
d
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
*
countRead
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mUpstreamState
=
=
GENERATING_HEADERS
&
&
!
mRequestHeadersDone
)
{
session
-
>
TransactionHasDataToWrite
(
this
)
;
}
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
&
&
!
mTxInlineFrameUsed
)
{
LOG
(
(
"
Http2StreamBase
%
p
mRequestBlockedOnRead
=
1
"
this
)
)
;
mRequestBlockedOnRead
=
1
;
}
if
(
mUpstreamState
=
=
GENERATING_HEADERS
&
&
(
NS_SUCCEEDED
(
rv
)
|
|
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
)
{
LOG3
(
(
"
Http2StreamBase
%
p
ReadSegments
forcing
OnReadSegment
call
\
n
"
this
)
)
;
uint32_t
wasted
=
0
;
mSegmentReader
=
reader
;
nsresult
rv2
=
OnReadSegment
(
"
"
0
&
wasted
)
;
mSegmentReader
=
nullptr
;
LOG3
(
(
"
OnReadSegment
returned
0x
%
08
"
PRIx32
static_cast
<
uint32_t
>
(
rv2
)
)
)
;
if
(
NS_SUCCEEDED
(
rv2
)
)
{
mRequestBlockedOnRead
=
0
;
}
}
if
(
!
mBlockedOnRwin
&
&
mOpenGenerated
&
&
!
mTxInlineFrameUsed
&
&
NS_SUCCEEDED
(
rv
)
&
&
(
!
*
countRead
)
&
&
CloseSendStreamWhenDone
(
)
)
{
MOZ_ASSERT
(
!
mQueued
)
;
MOZ_ASSERT
(
mRequestHeadersDone
)
;
LOG3
(
(
"
Http2StreamBase
:
:
ReadSegments
%
p
0x
%
X
:
Sending
request
data
"
"
complete
"
"
mUpstreamState
=
%
x
\
n
"
this
mStreamID
mUpstreamState
)
)
;
if
(
mSentFin
)
{
ChangeState
(
UPSTREAM_COMPLETE
)
;
}
else
{
GenerateDataFrameHeader
(
0
true
)
;
ChangeState
(
SENDING_FIN_STREAM
)
;
session
-
>
TransactionHasDataToWrite
(
this
)
;
rv
=
NS_BASE_STREAM_WOULD_BLOCK
;
}
}
break
;
case
SENDING_FIN_STREAM
:
if
(
!
mSentFin
)
{
mSegmentReader
=
reader
;
rv
=
TransmitFrame
(
nullptr
nullptr
false
)
;
mSegmentReader
=
nullptr
;
MOZ_ASSERT
(
NS_FAILED
(
rv
)
|
|
!
mTxInlineFrameUsed
"
Transmit
Frame
should
be
all
or
nothing
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
ChangeState
(
UPSTREAM_COMPLETE
)
;
}
else
{
rv
=
NS_OK
;
mTxInlineFrameUsed
=
0
;
ChangeState
(
UPSTREAM_COMPLETE
)
;
}
*
countRead
=
0
;
break
;
case
UPSTREAM_COMPLETE
:
*
countRead
=
0
;
rv
=
NS_OK
;
break
;
default
:
MOZ_ASSERT
(
false
"
Http2StreamBase
:
:
ReadSegments
unknown
state
"
)
;
break
;
}
return
rv
;
}
uint64_t
Http2StreamBase
:
:
LocalUnAcked
(
)
{
uint64_t
undelivered
=
mSimpleBuffer
.
Available
(
)
;
if
(
undelivered
>
mLocalUnacked
)
{
return
0
;
}
return
mLocalUnacked
-
undelivered
;
}
nsresult
Http2StreamBase
:
:
BufferInput
(
uint32_t
count
uint32_t
*
countWritten
)
{
char
buf
[
SimpleBufferPage
:
:
kSimpleBufferPageSize
]
;
if
(
SimpleBufferPage
:
:
kSimpleBufferPageSize
<
count
)
{
count
=
SimpleBufferPage
:
:
kSimpleBufferPageSize
;
}
mBypassInputBuffer
=
1
;
nsresult
rv
=
mSegmentWriter
-
>
OnWriteSegment
(
buf
count
countWritten
)
;
mBypassInputBuffer
=
0
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
mSimpleBuffer
.
Write
(
buf
*
countWritten
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
rv
=
=
NS_ERROR_OUT_OF_MEMORY
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
rv
;
}
bool
Http2StreamBase
:
:
DeferCleanup
(
nsresult
status
)
{
return
(
NS_SUCCEEDED
(
status
)
&
&
mSimpleBuffer
.
Available
(
)
)
;
}
nsresult
Http2StreamBase
:
:
WriteSegments
(
nsAHttpSegmentWriter
*
writer
uint32_t
count
uint32_t
*
countWritten
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
!
mSegmentWriter
"
segment
writer
in
progress
"
)
;
LOG3
(
(
"
Http2StreamBase
:
:
WriteSegments
%
p
count
=
%
d
state
=
%
x
"
this
count
mUpstreamState
)
)
;
mSegmentWriter
=
writer
;
nsresult
rv
=
CallToWriteData
(
count
countWritten
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
rv
=
BufferInput
(
count
countWritten
)
;
LOG3
(
(
"
Http2StreamBase
:
:
WriteSegments
%
p
Buffered
%
"
PRIX32
"
%
d
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
*
countWritten
)
)
;
}
LOG3
(
(
"
Http2StreamBase
:
:
WriteSegments
%
"
PRIX32
"
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
mSegmentWriter
=
nullptr
;
return
rv
;
}
nsresult
Http2StreamBase
:
:
ParseHttpRequestHeaders
(
const
char
*
buf
uint32_t
avail
uint32_t
*
countUsed
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mUpstreamState
=
=
GENERATING_HEADERS
)
;
MOZ_ASSERT
(
!
mRequestHeadersDone
)
;
LOG3
(
(
"
Http2StreamBase
:
:
ParseHttpRequestHeaders
%
p
avail
=
%
d
state
=
%
x
"
this
avail
mUpstreamState
)
)
;
mFlatHttpRequestHeaders
.
Append
(
buf
avail
)
;
int32_t
endHeader
=
mFlatHttpRequestHeaders
.
Find
(
"
\
r
\
n
\
r
\
n
"
)
;
if
(
endHeader
=
=
kNotFound
)
{
LOG3
(
(
"
Http2StreamBase
:
:
ParseHttpRequestHeaders
%
p
"
"
Need
more
header
bytes
.
Len
=
%
zd
"
this
mFlatHttpRequestHeaders
.
Length
(
)
)
)
;
*
countUsed
=
avail
;
return
NS_OK
;
}
uint32_t
oldLen
=
mFlatHttpRequestHeaders
.
Length
(
)
;
mFlatHttpRequestHeaders
.
SetLength
(
endHeader
+
2
)
;
*
countUsed
=
avail
-
(
oldLen
-
endHeader
)
+
4
;
mRequestHeadersDone
=
1
;
return
NS_OK
;
}
nsresult
Http2StreamBase
:
:
GenerateOpen
(
)
{
RefPtr
<
Http2Session
>
session
=
Session
(
)
;
mStreamID
=
session
-
>
RegisterStreamID
(
this
)
;
MOZ_ASSERT
(
mStreamID
&
1
"
Http2
Stream
Channel
ID
must
be
odd
"
)
;
MOZ_ASSERT
(
!
mOpenGenerated
)
;
mOpenGenerated
=
1
;
LOG3
(
(
"
Http2StreamBase
%
p
Stream
ID
0x
%
X
[
session
=
%
p
]
\
n
"
this
mStreamID
session
.
get
(
)
)
)
;
if
(
mStreamID
>
=
0x80000000
)
{
LOG3
(
(
"
Stream
assigned
out
of
range
ID
:
0x
%
X
"
mStreamID
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsCString
compressedData
;
uint8_t
firstFrameFlags
=
Http2Session
:
:
kFlag_PRIORITY
;
nsresult
rv
=
GenerateHeaders
(
compressedData
firstFrameFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
firstFrameFlags
&
Http2Session
:
:
kFlag_END_STREAM
)
{
SetSentFin
(
true
)
;
}
MOZ_ASSERT
(
!
mTxInlineFrameUsed
)
;
uint32_t
dataLength
=
compressedData
.
Length
(
)
;
uint32_t
maxFrameData
=
Http2Session
:
:
kMaxFrameData
-
5
;
uint32_t
numFrames
=
1
;
if
(
dataLength
>
maxFrameData
)
{
numFrames
+
=
(
(
dataLength
-
maxFrameData
)
+
Http2Session
:
:
kMaxFrameData
-
1
)
/
Http2Session
:
:
kMaxFrameData
;
MOZ_ASSERT
(
numFrames
>
1
)
;
}
uint32_t
messageSize
=
dataLength
;
messageSize
+
=
Http2Session
:
:
kFrameHeaderBytes
+
5
;
messageSize
+
=
(
numFrames
-
1
)
*
Http2Session
:
:
kFrameHeaderBytes
;
EnsureBuffer
(
mTxInlineFrame
messageSize
mTxInlineFrameUsed
mTxInlineFrameSize
)
;
mTxInlineFrameUsed
+
=
messageSize
;
UpdatePriorityDependency
(
)
;
LOG1
(
(
"
Http2StreamBase
%
p
Generating
%
d
bytes
of
HEADERS
for
stream
0x
%
X
with
"
"
priority
weight
%
u
dep
0x
%
X
frames
%
u
\
n
"
this
mTxInlineFrameUsed
mStreamID
mPriorityWeight
mPriorityDependency
numFrames
)
)
;
uint32_t
outputOffset
=
0
;
uint32_t
compressedDataOffset
=
0
;
for
(
uint32_t
idx
=
0
;
idx
<
numFrames
;
+
+
idx
)
{
uint32_t
flags
frameLen
;
bool
lastFrame
=
(
idx
=
=
numFrames
-
1
)
;
flags
=
0
;
frameLen
=
maxFrameData
;
if
(
!
idx
)
{
flags
|
=
firstFrameFlags
;
maxFrameData
=
Http2Session
:
:
kMaxFrameData
;
}
if
(
lastFrame
)
{
frameLen
=
dataLength
;
flags
|
=
Http2Session
:
:
kFlag_END_HEADERS
;
}
dataLength
-
=
frameLen
;
session
-
>
CreateFrameHeader
(
mTxInlineFrame
.
get
(
)
+
outputOffset
frameLen
+
(
idx
?
0
:
5
)
(
idx
)
?
Http2Session
:
:
FRAME_TYPE_CONTINUATION
:
Http2Session
:
:
FRAME_TYPE_HEADERS
flags
mStreamID
)
;
outputOffset
+
=
Http2Session
:
:
kFrameHeaderBytes
;
if
(
!
idx
)
{
uint32_t
wireDep
=
PR_htonl
(
mPriorityDependency
)
;
memcpy
(
mTxInlineFrame
.
get
(
)
+
outputOffset
&
wireDep
4
)
;
memcpy
(
mTxInlineFrame
.
get
(
)
+
outputOffset
+
4
&
mPriorityWeight
1
)
;
outputOffset
+
=
5
;
}
memcpy
(
mTxInlineFrame
.
get
(
)
+
outputOffset
compressedData
.
BeginReading
(
)
+
compressedDataOffset
frameLen
)
;
compressedDataOffset
+
=
frameLen
;
outputOffset
+
=
frameLen
;
}
glean
:
:
spdy
:
:
syn_size
.
Accumulate
(
compressedData
.
Length
(
)
)
;
mFlatHttpRequestHeaders
.
Truncate
(
)
;
return
NS_OK
;
}
void
Http2StreamBase
:
:
AdjustInitialWindow
(
)
{
uint32_t
wireStreamId
=
GetWireStreamId
(
)
;
if
(
wireStreamId
=
=
0
)
{
return
;
}
uint32_t
bump
=
0
;
RefPtr
<
Http2Session
>
session
=
Session
(
)
;
nsHttpTransaction
*
trans
=
HttpTransaction
(
)
;
if
(
trans
&
&
trans
-
>
InitialRwin
(
)
)
{
bump
=
(
trans
-
>
InitialRwin
(
)
>
mClientReceiveWindow
)
?
(
trans
-
>
InitialRwin
(
)
-
mClientReceiveWindow
)
:
0
;
}
else
{
MOZ_ASSERT
(
session
-
>
InitialRwin
(
)
>
=
mClientReceiveWindow
)
;
bump
=
session
-
>
InitialRwin
(
)
-
mClientReceiveWindow
;
}
LOG3
(
(
"
AdjustInitialwindow
increased
flow
control
window
%
p
0x
%
X
%
u
\
n
"
this
wireStreamId
bump
)
)
;
if
(
!
bump
)
{
return
;
}
EnsureBuffer
(
mTxInlineFrame
mTxInlineFrameUsed
+
Http2Session
:
:
kFrameHeaderBytes
+
4
mTxInlineFrameUsed
mTxInlineFrameSize
)
;
uint8_t
*
packet
=
mTxInlineFrame
.
get
(
)
+
mTxInlineFrameUsed
;
mTxInlineFrameUsed
+
=
Http2Session
:
:
kFrameHeaderBytes
+
4
;
session
-
>
CreateFrameHeader
(
packet
4
Http2Session
:
:
FRAME_TYPE_WINDOW_UPDATE
0
wireStreamId
)
;
mClientReceiveWindow
+
=
bump
;
bump
=
PR_htonl
(
bump
)
;
memcpy
(
packet
+
Http2Session
:
:
kFrameHeaderBytes
&
bump
4
)
;
}
void
Http2StreamBase
:
:
UpdateTransportReadEvents
(
uint32_t
count
)
{
mTotalRead
+
=
count
;
if
(
!
mSocketTransport
)
{
return
;
}
if
(
Transaction
(
)
)
{
Transaction
(
)
-
>
OnTransportStatus
(
mSocketTransport
NS_NET_STATUS_RECEIVING_FROM
mTotalRead
)
;
}
}
void
Http2StreamBase
:
:
UpdateTransportSendEvents
(
uint32_t
count
)
{
mTotalSent
+
=
count
;
uint32_t
bufferSize
=
gHttpHandler
-
>
SpdySendBufferSize
(
)
;
if
(
StaticPrefs
:
:
network_http_http2_send_buffer_size
(
)
>
0
&
&
(
mTotalSent
>
bufferSize
)
&
&
!
mSetTCPSocketBuffer
)
{
mSetTCPSocketBuffer
=
1
;
mSocketTransport
-
>
SetSendBufferSize
(
bufferSize
)
;
}
if
(
(
mUpstreamState
!
=
SENDING_FIN_STREAM
)
&
&
Transaction
(
)
)
{
Transaction
(
)
-
>
OnTransportStatus
(
mSocketTransport
NS_NET_STATUS_SENDING_TO
mTotalSent
)
;
}
if
(
!
mSentWaitingFor
&
&
!
mRequestBodyLenRemaining
)
{
mSentWaitingFor
=
1
;
if
(
Transaction
(
)
)
{
Transaction
(
)
-
>
OnTransportStatus
(
mSocketTransport
NS_NET_STATUS_WAITING_FOR
0
)
;
}
}
}
nsresult
Http2StreamBase
:
:
TransmitFrame
(
const
char
*
buf
uint32_t
*
countUsed
bool
forceCommitment
)
{
LOG3
(
(
"
Http2StreamBase
:
:
TransmitFrame
%
p
inline
=
%
d
stream
=
%
d
"
this
mTxInlineFrameUsed
mTxStreamFrameSize
)
)
;
if
(
countUsed
)
*
countUsed
=
0
;
if
(
!
mTxInlineFrameUsed
)
{
MOZ_ASSERT
(
!
buf
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
mTxInlineFrameUsed
"
empty
stream
frame
in
transmit
"
)
;
MOZ_ASSERT
(
mSegmentReader
"
TransmitFrame
with
null
mSegmentReader
"
)
;
MOZ_ASSERT
(
(
buf
&
&
countUsed
)
|
|
(
!
buf
&
&
!
countUsed
)
"
TransmitFrame
arguments
inconsistent
"
)
;
uint32_t
transmittedCount
;
nsresult
rv
;
RefPtr
<
Http2Session
>
session
=
Session
(
)
;
if
(
mTxStreamFrameSize
&
&
mTxInlineFrameUsed
&
&
mTxStreamFrameSize
<
Http2Session
:
:
kDefaultBufferSize
&
&
mTxInlineFrameUsed
+
mTxStreamFrameSize
<
mTxInlineFrameSize
)
{
LOG3
(
(
"
Coalesce
Transmit
"
)
)
;
memcpy
(
&
mTxInlineFrame
[
mTxInlineFrameUsed
]
buf
mTxStreamFrameSize
)
;
if
(
countUsed
)
*
countUsed
+
=
mTxStreamFrameSize
;
mTxInlineFrameUsed
+
=
mTxStreamFrameSize
;
mTxStreamFrameSize
=
0
;
}
rv
=
mSegmentReader
-
>
CommitToSegmentSize
(
mTxStreamFrameSize
+
mTxInlineFrameUsed
forceCommitment
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
MOZ_ASSERT
(
!
forceCommitment
"
forceCommitment
with
WOULD_BLOCK
"
)
;
session
-
>
TransactionHasDataToWrite
(
this
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
session
-
>
BufferOutput
(
reinterpret_cast
<
char
*
>
(
mTxInlineFrame
.
get
(
)
)
mTxInlineFrameUsed
&
transmittedCount
)
;
LOG3
(
(
"
Http2StreamBase
:
:
TransmitFrame
for
inline
BufferOutput
session
=
%
p
"
"
stream
=
%
p
result
%
"
PRIx32
"
len
=
%
d
"
session
.
get
(
)
this
static_cast
<
uint32_t
>
(
rv
)
transmittedCount
)
)
;
MOZ_ASSERT
(
rv
!
=
NS_BASE_STREAM_WOULD_BLOCK
"
inconsistent
inline
commitment
result
"
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
MOZ_ASSERT
(
transmittedCount
=
=
mTxInlineFrameUsed
"
inconsistent
inline
commitment
count
"
)
;
Http2Session
:
:
LogIO
(
session
this
"
Writing
from
Inline
Buffer
"
reinterpret_cast
<
char
*
>
(
mTxInlineFrame
.
get
(
)
)
transmittedCount
)
;
if
(
mTxStreamFrameSize
)
{
if
(
!
buf
)
{
MOZ_ASSERT
(
false
"
Stream
transmit
with
null
buf
argument
to
"
"
TransmitFrame
(
)
"
)
;
LOG3
(
(
"
Stream
transmit
with
null
buf
argument
to
TransmitFrame
(
)
\
n
"
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
session
-
>
AmountOfOutputBuffered
(
)
)
{
rv
=
session
-
>
BufferOutput
(
buf
mTxStreamFrameSize
&
transmittedCount
)
;
}
else
{
rv
=
session
-
>
OnReadSegment
(
buf
mTxStreamFrameSize
&
transmittedCount
)
;
}
LOG3
(
(
"
Http2StreamBase
:
:
TransmitFrame
for
regular
session
=
%
p
"
"
stream
=
%
p
result
%
"
PRIx32
"
len
=
%
d
"
session
.
get
(
)
this
static_cast
<
uint32_t
>
(
rv
)
transmittedCount
)
)
;
MOZ_ASSERT
(
rv
!
=
NS_BASE_STREAM_WOULD_BLOCK
"
inconsistent
stream
commitment
result
"
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
MOZ_ASSERT
(
transmittedCount
=
=
mTxStreamFrameSize
"
inconsistent
stream
commitment
count
"
)
;
Http2Session
:
:
LogIO
(
session
this
"
Writing
from
Transaction
Buffer
"
buf
transmittedCount
)
;
*
countUsed
+
=
mTxStreamFrameSize
;
}
if
(
!
mAttempting0RTT
)
{
session
-
>
FlushOutputQueue
(
)
;
}
UpdateTransportSendEvents
(
mTxInlineFrameUsed
+
mTxStreamFrameSize
)
;
mTxInlineFrameUsed
=
0
;
mTxStreamFrameSize
=
0
;
return
NS_OK
;
}
void
Http2StreamBase
:
:
ChangeState
(
enum
upstreamStateType
newState
)
{
LOG3
(
(
"
Http2StreamBase
:
:
ChangeState
(
)
%
p
from
%
X
to
%
X
"
this
mUpstreamState
newState
)
)
;
mUpstreamState
=
newState
;
}
void
Http2StreamBase
:
:
GenerateDataFrameHeader
(
uint32_t
dataLength
bool
lastFrame
)
{
LOG3
(
(
"
Http2StreamBase
:
:
GenerateDataFrameHeader
%
p
len
=
%
d
last
=
%
d
"
this
dataLength
lastFrame
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
!
mTxInlineFrameUsed
"
inline
frame
not
empty
"
)
;
MOZ_ASSERT
(
!
mTxStreamFrameSize
"
stream
frame
not
empty
"
)
;
uint8_t
frameFlags
=
0
;
if
(
lastFrame
)
{
frameFlags
|
=
Http2Session
:
:
kFlag_END_STREAM
;
if
(
dataLength
)
SetSentFin
(
true
)
;
}
RefPtr
<
Http2Session
>
session
=
Session
(
)
;
session
-
>
CreateFrameHeader
(
mTxInlineFrame
.
get
(
)
dataLength
Http2Session
:
:
FRAME_TYPE_DATA
frameFlags
mStreamID
)
;
mTxInlineFrameUsed
=
Http2Session
:
:
kFrameHeaderBytes
;
mTxStreamFrameSize
=
dataLength
;
}
nsresult
Http2StreamBase
:
:
ConvertResponseHeaders
(
Http2Decompressor
*
decompressor
nsACString
&
aHeadersIn
nsACString
&
aHeadersOut
int32_t
&
httpResponseCode
)
{
nsresult
rv
=
decompressor
-
>
DecodeHeaderBlock
(
reinterpret_cast
<
const
uint8_t
*
>
(
aHeadersIn
.
BeginReading
(
)
)
aHeadersIn
.
Length
(
)
aHeadersOut
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2StreamBase
:
:
ConvertResponseHeaders
%
p
decode
Error
\
n
"
this
)
)
;
return
rv
;
}
nsAutoCString
statusString
;
decompressor
-
>
GetStatus
(
statusString
)
;
if
(
statusString
.
IsEmpty
(
)
)
{
LOG3
(
(
"
Http2StreamBase
:
:
ConvertResponseHeaders
%
p
Error
-
no
status
\
n
"
this
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
nsresult
errcode
;
httpResponseCode
=
statusString
.
ToInteger
(
&
errcode
)
;
nsAutoCString
parsedStatusString
;
parsedStatusString
.
AppendInt
(
httpResponseCode
)
;
if
(
!
parsedStatusString
.
Equals
(
statusString
)
)
{
LOG3
(
(
"
Http2StreamBase
:
:
ConvertResposeHeaders
%
p
status
%
s
is
not
just
a
"
"
code
"
this
statusString
.
BeginReading
(
)
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
LOG3
(
(
"
Http2StreamBase
:
:
ConvertResponseHeaders
%
p
response
code
%
d
\
n
"
this
httpResponseCode
)
)
;
if
(
httpResponseCode
=
=
421
)
{
RefPtr
<
Http2Session
>
session
=
Session
(
)
;
session
-
>
Received421
(
ConnectionInfo
(
)
)
;
}
if
(
aHeadersIn
.
Length
(
)
&
&
aHeadersOut
.
Length
(
)
)
{
glean
:
:
spdy
:
:
syn_reply_size
.
Accumulate
(
aHeadersIn
.
Length
(
)
)
;
uint32_t
ratio
=
aHeadersIn
.
Length
(
)
*
100
/
aHeadersOut
.
Length
(
)
;
glean
:
:
spdy
:
:
syn_reply_ratio
.
AccumulateSingleSample
(
ratio
)
;
}
aHeadersIn
.
Truncate
(
)
;
aHeadersOut
.
AppendLiteral
(
"
X
-
Firefox
-
Spdy
:
h2
"
)
;
aHeadersOut
.
AppendLiteral
(
"
\
r
\
n
\
r
\
n
"
)
;
LOG
(
(
"
decoded
response
headers
are
:
\
n
%
s
"
aHeadersOut
.
BeginReading
(
)
)
)
;
HandleResponseHeaders
(
aHeadersOut
httpResponseCode
)
;
return
NS_OK
;
}
nsresult
Http2StreamBase
:
:
ConvertResponseTrailers
(
Http2Decompressor
*
decompressor
nsACString
&
aTrailersIn
)
{
LOG3
(
(
"
Http2StreamBase
:
:
ConvertResponseTrailers
%
p
"
this
)
)
;
nsAutoCString
flatTrailers
;
nsresult
rv
=
decompressor
-
>
DecodeHeaderBlock
(
reinterpret_cast
<
const
uint8_t
*
>
(
aTrailersIn
.
BeginReading
(
)
)
aTrailersIn
.
Length
(
)
flatTrailers
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2StreamBase
:
:
ConvertResponseTrailers
%
p
decode
Error
"
this
)
)
;
return
rv
;
}
nsHttpTransaction
*
trans
=
HttpTransaction
(
)
;
if
(
trans
)
{
trans
-
>
SetHttpTrailers
(
flatTrailers
)
;
}
else
{
LOG3
(
(
"
Http2StreamBase
:
:
ConvertResponseTrailers
%
p
no
trans
"
this
)
)
;
}
return
NS_OK
;
}
void
Http2StreamBase
:
:
SetResponseIsComplete
(
)
{
nsHttpTransaction
*
trans
=
HttpTransaction
(
)
;
if
(
trans
)
{
trans
-
>
SetResponseIsComplete
(
)
;
}
}
void
Http2StreamBase
:
:
SetAllHeadersReceived
(
)
{
if
(
mAllHeadersReceived
)
{
return
;
}
if
(
mState
=
=
RESERVED_BY_REMOTE
)
{
LOG3
(
(
"
Http2StreamBase
:
:
SetAllHeadersReceived
%
p
state
OPEN
from
reserved
\
n
"
this
)
)
;
mState
=
OPEN
;
AdjustInitialWindow
(
)
;
}
mAllHeadersReceived
=
1
;
}
bool
Http2StreamBase
:
:
AllowFlowControlledWrite
(
)
{
RefPtr
<
Http2Session
>
session
=
Session
(
)
;
return
(
session
-
>
ServerSessionWindow
(
)
>
0
)
&
&
(
mServerReceiveWindow
>
0
)
;
}
void
Http2StreamBase
:
:
UpdateServerReceiveWindow
(
int32_t
delta
)
{
mServerReceiveWindow
+
=
delta
;
if
(
mBlockedOnRwin
&
&
AllowFlowControlledWrite
(
)
)
{
LOG3
(
(
"
Http2StreamBase
:
:
UpdateServerReceived
UnPause
%
p
0x
%
X
"
"
Open
stream
window
\
n
"
this
mStreamID
)
)
;
RefPtr
<
Http2Session
>
session
=
Session
(
)
;
session
-
>
TransactionHasDataToWrite
(
this
)
;
}
}
void
Http2StreamBase
:
:
SetPriority
(
uint32_t
newPriority
)
{
int32_t
httpPriority
=
static_cast
<
int32_t
>
(
newPriority
)
;
if
(
httpPriority
>
kWorstPriority
)
{
httpPriority
=
kWorstPriority
;
}
else
if
(
httpPriority
<
kBestPriority
)
{
httpPriority
=
kBestPriority
;
}
mRFC7540Priority
=
static_cast
<
uint32_t
>
(
httpPriority
)
;
mPriorityWeight
=
(
nsISupportsPriority
:
:
PRIORITY_LOWEST
+
1
)
-
(
httpPriority
-
kNormalPriority
)
;
mPriorityDependency
=
0
;
}
void
Http2StreamBase
:
:
SetPriorityDependency
(
uint32_t
newPriority
uint32_t
newDependency
)
{
SetPriority
(
newPriority
)
;
mPriorityDependency
=
newDependency
;
}
static
uint32_t
GetPriorityDependencyFromTransaction
(
nsHttpTransaction
*
trans
)
{
MOZ_ASSERT
(
trans
)
;
uint32_t
classFlags
=
trans
-
>
GetClassOfService
(
)
.
Flags
(
)
;
if
(
classFlags
&
nsIClassOfService
:
:
UrgentStart
)
{
return
Http2Session
:
:
kUrgentStartGroupID
;
}
if
(
classFlags
&
nsIClassOfService
:
:
Leader
)
{
return
Http2Session
:
:
kLeaderGroupID
;
}
if
(
classFlags
&
nsIClassOfService
:
:
Follower
)
{
return
Http2Session
:
:
kFollowerGroupID
;
}
if
(
classFlags
&
nsIClassOfService
:
:
Speculative
)
{
return
Http2Session
:
:
kSpeculativeGroupID
;
}
if
(
classFlags
&
nsIClassOfService
:
:
Background
)
{
return
Http2Session
:
:
kBackgroundGroupID
;
}
if
(
classFlags
&
nsIClassOfService
:
:
Unblocked
)
{
return
Http2Session
:
:
kOtherGroupID
;
}
return
Http2Session
:
:
kFollowerGroupID
;
}
void
Http2StreamBase
:
:
UpdatePriorityDependency
(
)
{
RefPtr
<
Http2Session
>
session
=
Session
(
)
;
if
(
!
session
-
>
UseH2Deps
(
)
)
{
return
;
}
nsHttpTransaction
*
trans
=
HttpTransaction
(
)
;
if
(
!
trans
)
{
return
;
}
mPriorityDependency
=
GetPriorityDependencyFromTransaction
(
trans
)
;
if
(
StaticPrefs
:
:
network_http_active_tab_priority
(
)
&
&
mTransactionBrowserId
!
=
mCurrentBrowserId
&
&
mPriorityDependency
!
=
Http2Session
:
:
kUrgentStartGroupID
)
{
LOG3
(
(
"
Http2StreamBase
:
:
UpdatePriorityDependency
%
p
"
"
depends
on
background
group
for
trans
%
p
\
n
"
this
trans
)
)
;
mPriorityDependency
=
Http2Session
:
:
kBackgroundGroupID
;
nsHttp
:
:
NotifyActiveTabLoadOptimization
(
)
;
}
LOG1
(
(
"
Http2StreamBase
:
:
UpdatePriorityDependency
%
p
"
"
depends
on
stream
0x
%
X
\
n
"
this
mPriorityDependency
)
)
;
}
void
Http2StreamBase
:
:
CurrentBrowserIdChanged
(
uint64_t
id
)
{
if
(
!
mStreamID
)
{
return
;
}
CurrentBrowserIdChangedInternal
(
id
)
;
}
void
Http2StreamBase
:
:
CurrentBrowserIdChangedInternal
(
uint64_t
id
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
network_http_active_tab_priority
(
)
)
;
RefPtr
<
Http2Session
>
session
=
Session
(
)
;
LOG3
(
(
"
Http2StreamBase
:
:
CurrentBrowserIdChangedInternal
"
"
%
p
browserId
=
%
"
PRIx64
"
\
n
"
this
id
)
)
;
mCurrentBrowserId
=
id
;
if
(
mPriorityDependency
=
=
Http2Session
:
:
kUrgentStartGroupID
)
{
return
;
}
if
(
session
-
>
UseH2Deps
(
)
)
{
UpdatePriorityRFC7540
(
session
)
;
}
else
{
UpdatePriority
(
session
)
;
}
}
void
Http2StreamBase
:
:
UpdatePriority
(
Http2Session
*
session
)
{
MOZ_ASSERT
(
!
session
-
>
UseH2Deps
(
)
)
;
bool
isInBackground
=
mTransactionBrowserId
!
=
mCurrentBrowserId
;
if
(
isInBackground
)
{
LOG3
(
(
"
Http2StreamBase
:
:
CurrentBrowserIdChangedInternal
%
p
"
"
move
into
background
group
.
\
n
"
this
)
)
;
nsHttp
:
:
NotifyActiveTabLoadOptimization
(
)
;
}
if
(
!
StaticPrefs
:
:
network_http_http2_priority_updates
(
)
)
{
return
;
}
nsHttpTransaction
*
trans
=
HttpTransaction
(
)
;
if
(
!
trans
)
{
return
;
}
uint8_t
urgency
=
nsHttpHandler
:
:
UrgencyFromCoSFlags
(
trans
-
>
GetClassOfService
(
)
.
Flags
(
)
trans
-
>
Priority
(
)
)
;
bool
incremental
=
trans
-
>
GetClassOfService
(
)
.
Incremental
(
)
;
uint32_t
streamID
=
GetWireStreamId
(
)
;
if
(
isInBackground
&
&
urgency
<
6
)
{
urgency
+
+
;
}
if
(
streamID
)
{
session
-
>
SendPriorityUpdateFrame
(
streamID
urgency
incremental
)
;
}
}
void
Http2StreamBase
:
:
UpdatePriorityRFC7540
(
Http2Session
*
session
)
{
MOZ_ASSERT
(
session
-
>
UseH2Deps
(
)
)
;
if
(
mTransactionBrowserId
!
=
mCurrentBrowserId
)
{
mPriorityDependency
=
Http2Session
:
:
kBackgroundGroupID
;
LOG3
(
(
"
Http2StreamBase
:
:
CurrentBrowserIdChangedInternal
%
p
"
"
move
into
background
group
.
\
n
"
this
)
)
;
nsHttp
:
:
NotifyActiveTabLoadOptimization
(
)
;
}
else
{
nsHttpTransaction
*
trans
=
HttpTransaction
(
)
;
if
(
!
trans
)
{
return
;
}
mPriorityDependency
=
GetPriorityDependencyFromTransaction
(
trans
)
;
LOG3
(
(
"
Http2StreamBase
:
:
CurrentBrowserIdChangedInternal
%
p
"
"
depends
on
stream
0x
%
X
\
n
"
this
mPriorityDependency
)
)
;
}
uint32_t
modifyStreamID
=
GetWireStreamId
(
)
;
if
(
modifyStreamID
)
{
session
-
>
SendPriorityFrame
(
modifyStreamID
mPriorityDependency
mPriorityWeight
)
;
}
}
void
Http2StreamBase
:
:
SetRecvdFin
(
bool
aStatus
)
{
mRecvdFin
=
aStatus
?
1
:
0
;
if
(
!
aStatus
)
return
;
if
(
mState
=
=
OPEN
|
|
mState
=
=
RESERVED_BY_REMOTE
)
{
mState
=
CLOSED_BY_REMOTE
;
}
else
if
(
mState
=
=
CLOSED_BY_LOCAL
)
{
mState
=
CLOSED
;
}
}
void
Http2StreamBase
:
:
SetSentFin
(
bool
aStatus
)
{
mSentFin
=
aStatus
?
1
:
0
;
if
(
!
aStatus
)
return
;
if
(
mState
=
=
OPEN
|
|
mState
=
=
RESERVED_BY_REMOTE
)
{
mState
=
CLOSED_BY_LOCAL
;
}
else
if
(
mState
=
=
CLOSED_BY_REMOTE
)
{
mState
=
CLOSED
;
}
}
void
Http2StreamBase
:
:
SetRecvdReset
(
bool
aStatus
)
{
mRecvdReset
=
aStatus
?
1
:
0
;
if
(
!
aStatus
)
return
;
mState
=
CLOSED
;
}
void
Http2StreamBase
:
:
SetSentReset
(
bool
aStatus
)
{
mSentReset
=
aStatus
?
1
:
0
;
if
(
!
aStatus
)
return
;
mState
=
CLOSED
;
}
nsresult
Http2StreamBase
:
:
OnReadSegment
(
const
char
*
buf
uint32_t
count
uint32_t
*
countRead
)
{
LOG3
(
(
"
Http2StreamBase
:
:
OnReadSegment
%
p
count
=
%
d
state
=
%
x
"
this
count
mUpstreamState
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
!
mSegmentReader
)
{
return
NS_BASE_STREAM_WOULD_BLOCK
;
}
nsresult
rv
=
NS_ERROR_UNEXPECTED
;
uint32_t
dataLength
;
RefPtr
<
Http2Session
>
session
=
Session
(
)
;
switch
(
mUpstreamState
)
{
case
GENERATING_HEADERS
:
if
(
!
mRequestHeadersDone
)
{
if
(
NS_FAILED
(
rv
=
ParseHttpRequestHeaders
(
buf
count
countRead
)
)
)
{
return
rv
;
}
}
if
(
mRequestHeadersDone
&
&
!
mOpenGenerated
)
{
if
(
!
session
-
>
TryToActivate
(
this
)
)
{
LOG3
(
(
"
Http2StreamBase
:
:
OnReadSegment
%
p
cannot
activate
now
.
"
"
queued
.
\
n
"
this
)
)
;
return
*
countRead
?
NS_OK
:
NS_BASE_STREAM_WOULD_BLOCK
;
}
if
(
NS_FAILED
(
rv
=
GenerateOpen
(
)
)
)
{
return
rv
;
}
}
LOG3
(
(
"
ParseHttpRequestHeaders
%
p
used
%
d
of
%
d
.
"
"
requestheadersdone
=
%
d
mOpenGenerated
=
%
d
\
n
"
this
*
countRead
count
mRequestHeadersDone
mOpenGenerated
)
)
;
if
(
mOpenGenerated
)
{
SetHTTPState
(
OPEN
)
;
AdjustInitialWindow
(
)
;
rv
=
TransmitFrame
(
nullptr
nullptr
true
)
;
ChangeState
(
GENERATING_BODY
)
;
break
;
}
MOZ_ASSERT
(
*
countRead
=
=
count
"
Header
parsing
not
complete
but
unused
data
"
)
;
break
;
case
GENERATING_BODY
:
if
(
!
AllowFlowControlledWrite
(
)
)
{
*
countRead
=
0
;
LOG3
(
(
"
Http2StreamBase
this
=
%
p
id
0x
%
X
request
body
suspended
because
"
"
remote
window
is
stream
=
%
"
PRId64
"
session
=
%
"
PRId64
"
.
\
n
"
this
mStreamID
mServerReceiveWindow
session
-
>
ServerSessionWindow
(
)
)
)
;
mBlockedOnRwin
=
true
;
return
NS_BASE_STREAM_WOULD_BLOCK
;
}
mBlockedOnRwin
=
false
;
dataLength
=
std
:
:
min
(
count
mChunkSize
)
;
if
(
dataLength
>
Http2Session
:
:
kMaxFrameData
)
{
dataLength
=
Http2Session
:
:
kMaxFrameData
;
}
if
(
dataLength
>
session
-
>
ServerSessionWindow
(
)
)
{
dataLength
=
static_cast
<
uint32_t
>
(
session
-
>
ServerSessionWindow
(
)
)
;
}
if
(
dataLength
>
mServerReceiveWindow
)
{
dataLength
=
static_cast
<
uint32_t
>
(
mServerReceiveWindow
)
;
}
LOG3
(
(
"
Http2StreamBase
this
=
%
p
id
0x
%
X
send
calculation
"
"
avail
=
%
d
chunksize
=
%
d
stream
window
=
%
"
PRId64
"
session
window
=
%
"
PRId64
"
"
"
max
frame
=
%
d
USING
=
%
u
\
n
"
this
mStreamID
count
mChunkSize
mServerReceiveWindow
session
-
>
ServerSessionWindow
(
)
Http2Session
:
:
kMaxFrameData
dataLength
)
)
;
session
-
>
DecrementServerSessionWindow
(
dataLength
)
;
mServerReceiveWindow
-
=
dataLength
;
LOG3
(
(
"
Http2StreamBase
%
p
id
0x
%
x
request
len
remaining
%
"
PRId64
"
"
"
count
avail
%
u
chunk
used
%
u
"
this
mStreamID
mRequestBodyLenRemaining
count
dataLength
)
)
;
if
(
!
dataLength
&
&
mRequestBodyLenRemaining
)
{
return
NS_BASE_STREAM_WOULD_BLOCK
;
}
if
(
dataLength
>
mRequestBodyLenRemaining
)
{
return
NS_ERROR_UNEXPECTED
;
}
mRequestBodyLenRemaining
-
=
dataLength
;
GenerateDataFrameHeader
(
dataLength
!
mRequestBodyLenRemaining
)
;
ChangeState
(
SENDING_BODY
)
;
[
[
fallthrough
]
]
;
case
SENDING_BODY
:
MOZ_ASSERT
(
mTxInlineFrameUsed
"
OnReadSegment
Send
Data
Header
0b
"
)
;
rv
=
TransmitFrame
(
buf
countRead
false
)
;
MOZ_ASSERT
(
NS_FAILED
(
rv
)
|
|
!
mTxInlineFrameUsed
"
Transmit
Frame
should
be
all
or
nothing
"
)
;
LOG3
(
(
"
TransmitFrame
(
)
rv
=
%
"
PRIx32
"
returning
%
d
data
bytes
.
"
"
Header
is
%
d
Body
is
%
d
.
"
static_cast
<
uint32_t
>
(
rv
)
*
countRead
mTxInlineFrameUsed
mTxStreamFrameSize
)
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
&
&
*
countRead
)
rv
=
NS_OK
;
if
(
!
mTxInlineFrameUsed
)
ChangeState
(
GENERATING_BODY
)
;
break
;
case
SENDING_FIN_STREAM
:
MOZ_ASSERT
(
false
"
resuming
partial
fin
stream
out
of
OnReadSegment
"
)
;
break
;
case
UPSTREAM_COMPLETE
:
{
MOZ_ASSERT
(
this
-
>
GetHttp2Stream
(
)
)
;
rv
=
TransmitFrame
(
nullptr
nullptr
true
)
;
break
;
}
default
:
MOZ_ASSERT
(
false
"
Http2StreamBase
:
:
OnReadSegment
non
-
write
state
"
)
;
break
;
}
return
rv
;
}
nsresult
Http2StreamBase
:
:
OnWriteSegment
(
char
*
buf
uint32_t
count
uint32_t
*
countWritten
)
{
LOG3
(
(
"
Http2StreamBase
:
:
OnWriteSegment
%
p
count
=
%
d
state
=
%
x
0x
%
X
\
n
"
this
count
mUpstreamState
mStreamID
)
)
;
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
!
mSegmentWriter
)
{
return
NS_BASE_STREAM_WOULD_BLOCK
;
}
if
(
!
mBypassInputBuffer
&
&
mSimpleBuffer
.
Available
(
)
)
{
*
countWritten
=
mSimpleBuffer
.
Read
(
buf
count
)
;
MOZ_ASSERT
(
*
countWritten
)
;
LOG3
(
(
"
Http2StreamBase
:
:
OnWriteSegment
read
from
flow
control
buffer
%
p
%
x
"
"
%
d
\
n
"
this
mStreamID
*
countWritten
)
)
;
return
NS_OK
;
}
return
mSegmentWriter
-
>
OnWriteSegment
(
buf
count
countWritten
)
;
}
bool
Http2StreamBase
:
:
Do0RTT
(
)
{
MOZ_ASSERT
(
Transaction
(
)
)
;
mAttempting0RTT
=
false
;
nsAHttpTransaction
*
trans
=
Transaction
(
)
;
if
(
trans
)
{
mAttempting0RTT
=
trans
-
>
Do0RTT
(
)
;
}
return
mAttempting0RTT
;
}
nsresult
Http2StreamBase
:
:
Finish0RTT
(
bool
aRestart
bool
aAlpnChanged
)
{
MOZ_ASSERT
(
Transaction
(
)
)
;
mAttempting0RTT
=
false
;
nsresult
rv
=
NS_OK
;
nsAHttpTransaction
*
trans
=
Transaction
(
)
;
if
(
trans
)
{
rv
=
trans
-
>
Finish0RTT
(
aAlpnChanged
aAlpnChanged
)
;
if
(
aRestart
)
{
nsHttpTransaction
*
hTrans
=
trans
-
>
QueryHttpTransaction
(
)
;
if
(
hTrans
)
{
hTrans
-
>
Refused0RTT
(
)
;
}
}
}
return
rv
;
}
nsresult
Http2StreamBase
:
:
GetOriginAttributes
(
mozilla
:
:
OriginAttributes
*
oa
)
{
if
(
!
mSocketTransport
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
mSocketTransport
-
>
GetOriginAttributes
(
oa
)
;
}
nsHttpTransaction
*
Http2StreamBase
:
:
HttpTransaction
(
)
{
return
(
Transaction
(
)
)
?
Transaction
(
)
-
>
QueryHttpTransaction
(
)
:
nullptr
;
}
nsHttpConnectionInfo
*
Http2StreamBase
:
:
ConnectionInfo
(
)
{
if
(
Transaction
(
)
)
{
return
Transaction
(
)
-
>
ConnectionInfo
(
)
;
}
return
nullptr
;
}
}
