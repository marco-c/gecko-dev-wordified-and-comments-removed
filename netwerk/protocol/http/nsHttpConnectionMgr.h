#
ifndef
nsHttpConnectionMgr_h__
#
define
nsHttpConnectionMgr_h__
#
include
"
DnsAndConnectSocket
.
h
"
#
include
"
HttpConnectionBase
.
h
"
#
include
"
HttpConnectionMgrShell
.
h
"
#
include
"
nsHttpConnection
.
h
"
#
include
"
nsHttpTransaction
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
ARefBase
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
ConnectionEntry
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsITimer
.
h
"
class
nsIHttpUpgradeListener
;
namespace
mozilla
:
:
net
{
class
EventTokenBucket
;
class
NullHttpTransaction
;
struct
HttpRetParams
;
class
nsHttpConnectionMgr
;
using
nsConnEventHandler
=
void
(
nsHttpConnectionMgr
:
:
*
)
(
int32_t
ARefBase
*
)
;
class
nsHttpConnectionMgr
final
:
public
HttpConnectionMgrShell
public
nsIObserver
nsINamed
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_HTTPCONNECTIONMGRSHELL
NS_DECL_NSIOBSERVER
NS_DECL_NSINAMED
nsHttpConnectionMgr
(
)
;
[
[
nodiscard
]
]
nsresult
CancelTransactions
(
nsHttpConnectionInfo
*
nsresult
code
)
;
void
MoveToWildCardConnEntry
(
nsHttpConnectionInfo
*
specificCI
nsHttpConnectionInfo
*
wildcardCI
HttpConnectionBase
*
conn
)
;
bool
RemoveTransFromConnEntry
(
nsHttpTransaction
*
aTrans
const
nsACString
&
aHashKey
)
;
[
[
nodiscard
]
]
nsresult
ProcessNewTransaction
(
nsHttpTransaction
*
aTrans
)
;
[
[
nodiscard
]
]
nsresult
CloseIdleConnection
(
nsHttpConnection
*
)
;
[
[
nodiscard
]
]
nsresult
RemoveIdleConnection
(
nsHttpConnection
*
)
;
[
[
nodiscard
]
]
nsresult
DoSingleConnectionCleanup
(
nsHttpConnectionInfo
*
)
;
void
ReportSpdyConnection
(
nsHttpConnection
*
bool
usingSpdy
)
;
void
ReportHttp3Connection
(
HttpConnectionBase
*
)
;
bool
GetConnectionData
(
nsTArray
<
HttpRetParams
>
*
)
;
void
ResetIPFamilyPreference
(
nsHttpConnectionInfo
*
)
;
uint16_t
MaxRequestDelay
(
)
{
return
mMaxRequestDelay
;
}
void
AddActiveTransaction
(
nsHttpTransaction
*
aTrans
)
;
void
RemoveActiveTransaction
(
nsHttpTransaction
*
aTrans
Maybe
<
bool
>
const
&
aOverride
=
Nothing
(
)
)
;
void
UpdateActiveTransaction
(
nsHttpTransaction
*
aTrans
)
;
bool
ShouldThrottle
(
nsHttpTransaction
*
aTrans
)
;
void
TouchThrottlingTimeWindow
(
bool
aEnsureTicker
=
true
)
;
bool
IsConnEntryUnderPressure
(
nsHttpConnectionInfo
*
)
;
uint64_t
CurrentTopBrowsingContextId
(
)
{
return
mCurrentTopBrowsingContextId
;
}
void
DoFallbackConnection
(
SpeculativeTransaction
*
aTrans
bool
aFetchHTTPSRR
)
;
void
DoSpeculativeConnection
(
SpeculativeTransaction
*
aTrans
bool
aFetchHTTPSRR
)
;
HttpConnectionBase
*
GetH2orH3ActiveConn
(
ConnectionEntry
*
ent
bool
aNoHttp2
bool
aNoHttp3
)
;
void
IncreaseNumDnsAndConnectSockets
(
)
;
void
DecreaseNumDnsAndConnectSockets
(
)
;
void
NewIdleConnectionAdded
(
uint32_t
timeToLive
)
;
void
DecrementNumIdleConns
(
)
;
private
:
virtual
~
nsHttpConnectionMgr
(
)
;
void
PruneDeadConnectionsAfter
(
uint32_t
time
)
;
void
ConditionallyStopPruneDeadConnectionsTimer
(
)
;
void
ConditionallyStopTimeoutTick
(
)
;
[
[
nodiscard
]
]
nsresult
PruneNoTraffic
(
)
;
[
[
nodiscard
]
]
bool
ProcessPendingQForEntry
(
nsHttpConnectionInfo
*
)
;
void
ActivateTimeoutTick
(
)
;
already_AddRefed
<
PendingTransactionInfo
>
FindTransactionHelper
(
bool
removeWhenFound
ConnectionEntry
*
aEnt
nsAHttpTransaction
*
aTrans
)
;
void
DoSpeculativeConnectionInternal
(
ConnectionEntry
*
aEnt
SpeculativeTransaction
*
aTrans
bool
aFetchHTTPSRR
)
;
already_AddRefed
<
ConnectionEntry
>
FindConnectionEntry
(
const
nsHttpConnectionInfo
*
ci
)
;
public
:
static
nsAHttpConnection
*
MakeConnectionHandle
(
HttpConnectionBase
*
aWrapped
)
;
void
RegisterOriginCoalescingKey
(
HttpConnectionBase
*
const
nsACString
&
host
int32_t
port
)
;
bool
BeConservativeIfProxied
(
nsIProxyInfo
*
proxy
)
;
protected
:
friend
class
ConnectionEntry
;
void
IncrementActiveConnCount
(
)
;
void
DecrementActiveConnCount
(
HttpConnectionBase
*
)
;
private
:
friend
class
DnsAndConnectSocket
;
friend
class
PendingTransactionInfo
;
ReentrantMonitor
mReentrantMonitor
{
"
nsHttpConnectionMgr
.
mReentrantMonitor
"
}
;
nsCOMPtr
<
nsIEventTarget
>
mSocketThreadTarget
MOZ_GUARDED_BY
(
mReentrantMonitor
)
;
Atomic
<
bool
mozilla
:
:
Relaxed
>
mIsShuttingDown
{
false
}
;
uint16_t
mMaxUrgentExcessiveConns
{
0
}
;
uint16_t
mMaxConns
{
0
}
;
uint16_t
mMaxPersistConnsPerHost
{
0
}
;
uint16_t
mMaxPersistConnsPerProxy
{
0
}
;
uint16_t
mMaxRequestDelay
{
0
}
;
bool
mThrottleEnabled
{
false
}
;
uint32_t
mThrottleVersion
{
2
}
;
uint32_t
mThrottleSuspendFor
{
0
}
;
uint32_t
mThrottleResumeFor
{
0
}
;
uint32_t
mThrottleReadLimit
{
0
}
;
uint32_t
mThrottleReadInterval
{
0
}
;
uint32_t
mThrottleHoldTime
{
0
}
;
TimeDuration
mThrottleMaxTime
;
bool
mBeConservativeForProxy
{
true
}
;
[
[
nodiscard
]
]
bool
ProcessPendingQForEntry
(
ConnectionEntry
*
bool
considerAll
)
;
bool
DispatchPendingQ
(
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
&
pendingQ
ConnectionEntry
*
ent
bool
considerAll
)
;
void
PreparePendingQForDispatching
(
ConnectionEntry
*
ent
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
&
pendingQ
bool
considerAll
)
;
uint32_t
MaxPersistConnections
(
ConnectionEntry
*
ent
)
const
;
bool
AtActiveConnectionLimit
(
ConnectionEntry
*
uint32_t
caps
)
;
[
[
nodiscard
]
]
nsresult
TryDispatchTransaction
(
ConnectionEntry
*
ent
bool
onlyReusedConnection
PendingTransactionInfo
*
pendingTransInfo
)
;
[
[
nodiscard
]
]
nsresult
TryDispatchTransactionOnIdleConn
(
ConnectionEntry
*
ent
PendingTransactionInfo
*
pendingTransInfo
bool
respectUrgency
bool
*
allUrgent
=
nullptr
)
;
[
[
nodiscard
]
]
nsresult
DispatchTransaction
(
ConnectionEntry
*
nsHttpTransaction
*
HttpConnectionBase
*
)
;
[
[
nodiscard
]
]
nsresult
DispatchAbstractTransaction
(
ConnectionEntry
*
nsAHttpTransaction
*
uint32_t
HttpConnectionBase
*
int32_t
)
;
[
[
nodiscard
]
]
nsresult
EnsureSocketThreadTarget
(
)
;
void
ReportProxyTelemetry
(
ConnectionEntry
*
ent
)
;
void
StartedConnect
(
)
;
void
RecvdConnect
(
)
;
ConnectionEntry
*
GetOrCreateConnectionEntry
(
nsHttpConnectionInfo
*
bool
prohibitWildCard
bool
aNoHttp2
bool
aNoHttp3
bool
*
aIsWildcard
bool
*
aAvailableForDispatchNow
=
nullptr
)
;
[
[
nodiscard
]
]
nsresult
MakeNewConnection
(
ConnectionEntry
*
ent
PendingTransactionInfo
*
pendingTransInfo
)
;
nsClassHashtable
<
nsCStringHashKey
nsTArray
<
nsWeakPtr
>
>
mCoalescingHash
;
HttpConnectionBase
*
FindCoalescableConnection
(
ConnectionEntry
*
ent
bool
justKidding
bool
aNoHttp2
bool
aNoHttp3
)
;
HttpConnectionBase
*
FindCoalescableConnectionByHashKey
(
ConnectionEntry
*
ent
const
nsCString
&
key
bool
justKidding
bool
aNoHttp2
bool
aNoHttp3
)
;
void
UpdateCoalescingForNewConn
(
HttpConnectionBase
*
conn
ConnectionEntry
*
ent
)
;
void
ProcessSpdyPendingQ
(
ConnectionEntry
*
ent
)
;
void
DispatchSpdyPendingQ
(
nsTArray
<
RefPtr
<
PendingTransactionInfo
>
>
&
pendingQ
ConnectionEntry
*
ent
HttpConnectionBase
*
connH2
HttpConnectionBase
*
connH3
)
;
[
[
nodiscard
]
]
nsresult
PostEvent
(
nsConnEventHandler
handler
int32_t
iparam
=
0
ARefBase
*
vparam
=
nullptr
)
;
void
OnMsgReclaimConnection
(
HttpConnectionBase
*
)
;
void
OnMsgShutdown
(
int32_t
ARefBase
*
)
;
void
OnMsgShutdownConfirm
(
int32_t
ARefBase
*
)
;
void
OnMsgNewTransaction
(
int32_t
ARefBase
*
)
;
void
OnMsgNewTransactionWithStickyConn
(
int32_t
ARefBase
*
)
;
void
OnMsgReschedTransaction
(
int32_t
ARefBase
*
)
;
void
OnMsgUpdateClassOfServiceOnTransaction
(
ClassOfService
ARefBase
*
)
;
void
OnMsgCancelTransaction
(
int32_t
ARefBase
*
)
;
void
OnMsgCancelTransactions
(
int32_t
ARefBase
*
)
;
void
OnMsgProcessPendingQ
(
int32_t
ARefBase
*
)
;
void
OnMsgPruneDeadConnections
(
int32_t
ARefBase
*
)
;
void
OnMsgSpeculativeConnect
(
int32_t
ARefBase
*
)
;
void
OnMsgCompleteUpgrade
(
int32_t
ARefBase
*
)
;
void
OnMsgUpdateParam
(
int32_t
ARefBase
*
)
;
void
OnMsgDoShiftReloadConnectionCleanup
(
int32_t
ARefBase
*
)
;
void
OnMsgDoSingleConnectionCleanup
(
int32_t
ARefBase
*
)
;
void
OnMsgProcessFeedback
(
int32_t
ARefBase
*
)
;
void
OnMsgProcessAllSpdyPendingQ
(
int32_t
ARefBase
*
)
;
void
OnMsgUpdateRequestTokenBucket
(
int32_t
ARefBase
*
)
;
void
OnMsgVerifyTraffic
(
int32_t
ARefBase
*
)
;
void
OnMsgPruneNoTraffic
(
int32_t
ARefBase
*
)
;
void
OnMsgUpdateCurrentTopBrowsingContextId
(
int32_t
ARefBase
*
)
;
void
OnMsgClearConnectionHistory
(
int32_t
ARefBase
*
)
;
uint16_t
mNumActiveConns
{
0
}
;
uint16_t
mNumIdleConns
{
0
}
;
uint16_t
mNumSpdyHttp3ActiveConns
{
0
}
;
uint32_t
mNumDnsAndConnectSockets
{
0
}
;
uint64_t
mTimeOfNextWakeUp
{
UINT64_MAX
}
;
nsCOMPtr
<
nsITimer
>
mTimer
;
nsCOMPtr
<
nsITimer
>
mTrafficTimer
;
bool
mPruningNoTraffic
{
false
}
;
nsCOMPtr
<
nsITimer
>
mTimeoutTick
;
bool
mTimeoutTickArmed
{
false
}
;
uint32_t
mTimeoutTickNext
{
1
}
;
nsRefPtrHashtable
<
nsCStringHashKey
ConnectionEntry
>
mCT
;
void
TimeoutTick
(
)
;
void
OnMsgPrintDiagnostics
(
int32_t
ARefBase
*
)
;
nsCString
mLogData
;
uint64_t
mCurrentTopBrowsingContextId
{
0
}
;
void
SetThrottlingEnabled
(
bool
aEnable
)
;
bool
InThrottlingTimeWindow
(
)
;
nsClassHashtable
<
nsUint64HashKey
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
>
mActiveTransactions
[
2
]
;
bool
mThrottlingInhibitsReading
{
false
}
;
TimeStamp
mThrottlingWindowEndsAt
;
nsCOMPtr
<
nsITimer
>
mThrottleTicker
;
bool
IsThrottleTickerNeeded
(
)
;
void
EnsureThrottleTickerIfNeeded
(
)
;
void
DestroyThrottleTicker
(
)
;
void
ThrottlerTick
(
)
;
nsCOMPtr
<
nsITimer
>
mDelayedResumeReadTimer
;
void
DelayedResumeBackgroundThrottledTransactions
(
)
;
void
CancelDelayedResumeBackgroundThrottledTransactions
(
)
;
void
ResumeBackgroundThrottledTransactions
(
)
;
void
ResumeReadOf
(
nsClassHashtable
<
nsUint64HashKey
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
>
&
bool
excludeForActiveTab
=
false
)
;
void
ResumeReadOf
(
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
*
)
;
bool
mActiveTabTransactionsExist
{
false
}
;
bool
mActiveTabUnthrottledTransactionsExist
{
false
}
;
void
LogActiveTransactions
(
char
)
;
void
NotifyConnectionOfBrowsingContextIdChange
(
uint64_t
previousId
)
;
void
CheckTransInPendingQueue
(
nsHttpTransaction
*
aTrans
)
;
}
;
}
#
endif
