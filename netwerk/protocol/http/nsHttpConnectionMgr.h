#
ifndef
nsHttpConnectionMgr_h__
#
define
nsHttpConnectionMgr_h__
#
include
"
nsHttpConnection
.
h
"
#
include
"
nsHttpTransaction
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
AlternateServices
.
h
"
#
include
"
ARefBase
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsITimer
.
h
"
class
nsIHttpUpgradeListener
;
namespace
mozilla
{
namespace
net
{
class
EventTokenBucket
;
class
NullHttpTransaction
;
struct
HttpRetParams
;
class
nsHttpConnectionMgr
;
typedef
void
(
nsHttpConnectionMgr
:
:
*
nsConnEventHandler
)
(
int32_t
ARefBase
*
)
;
class
nsHttpConnectionMgr
final
:
public
nsIObserver
public
AltSvcCache
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
enum
nsParamName
{
MAX_CONNECTIONS
MAX_PERSISTENT_CONNECTIONS_PER_HOST
MAX_PERSISTENT_CONNECTIONS_PER_PROXY
MAX_REQUEST_DELAY
}
;
nsHttpConnectionMgr
(
)
;
nsresult
Init
(
uint16_t
maxConnections
uint16_t
maxPersistentConnectionsPerHost
uint16_t
maxPersistentConnectionsPerProxy
uint16_t
maxRequestDelay
)
;
nsresult
Shutdown
(
)
;
void
PruneDeadConnectionsAfter
(
uint32_t
time
)
;
void
ConditionallyStopPruneDeadConnectionsTimer
(
)
;
void
ConditionallyStopTimeoutTick
(
)
;
nsresult
AddTransaction
(
nsHttpTransaction
*
int32_t
priority
)
;
nsresult
RescheduleTransaction
(
nsHttpTransaction
*
int32_t
priority
)
;
nsresult
CancelTransaction
(
nsHttpTransaction
*
nsresult
reason
)
;
nsresult
CancelTransactions
(
nsHttpConnectionInfo
*
nsresult
reason
)
;
nsresult
PruneDeadConnections
(
)
;
nsresult
PruneNoTraffic
(
)
;
nsresult
VerifyTraffic
(
)
;
nsresult
DoShiftReloadConnectionCleanup
(
nsHttpConnectionInfo
*
)
;
nsresult
GetSocketThreadTarget
(
nsIEventTarget
*
*
)
;
nsresult
SpeculativeConnect
(
nsHttpConnectionInfo
*
nsIInterfaceRequestor
*
uint32_t
caps
=
0
NullHttpTransaction
*
=
nullptr
)
;
nsresult
ReclaimConnection
(
nsHttpConnection
*
conn
)
;
nsresult
CompleteUpgrade
(
nsAHttpConnection
*
aConn
nsIHttpUpgradeListener
*
aUpgradeListener
)
;
nsresult
UpdateParam
(
nsParamName
name
uint16_t
value
)
;
nsresult
UpdateRequestTokenBucket
(
EventTokenBucket
*
aBucket
)
;
nsresult
ClearConnectionHistory
(
)
;
void
ReportFailedToProcess
(
nsIURI
*
uri
)
;
void
PrintDiagnostics
(
)
;
void
MoveToWildCardConnEntry
(
nsHttpConnectionInfo
*
specificCI
nsHttpConnectionInfo
*
wildcardCI
nsHttpConnection
*
conn
)
;
nsresult
ProcessPendingQ
(
nsHttpConnectionInfo
*
)
;
bool
ProcessPendingQForEntry
(
nsHttpConnectionInfo
*
)
;
nsresult
ProcessPendingQ
(
)
;
nsresult
CloseIdleConnection
(
nsHttpConnection
*
)
;
void
ReportSpdyConnection
(
nsHttpConnection
*
bool
usingSpdy
)
;
bool
GetConnectionData
(
nsTArray
<
HttpRetParams
>
*
)
;
void
ResetIPFamilyPreference
(
nsHttpConnectionInfo
*
)
;
uint16_t
MaxRequestDelay
(
)
{
return
mMaxRequestDelay
;
}
void
ActivateTimeoutTick
(
)
;
private
:
virtual
~
nsHttpConnectionMgr
(
)
;
class
nsHalfOpenSocket
;
class
nsConnectionEntry
{
public
:
explicit
nsConnectionEntry
(
nsHttpConnectionInfo
*
ci
)
;
~
nsConnectionEntry
(
)
;
RefPtr
<
nsHttpConnectionInfo
>
mConnInfo
;
nsTArray
<
RefPtr
<
nsHttpTransaction
>
>
mPendingQ
;
nsTArray
<
RefPtr
<
nsHttpConnection
>
>
mActiveConns
;
nsTArray
<
RefPtr
<
nsHttpConnection
>
>
mIdleConns
;
nsTArray
<
nsHalfOpenSocket
*
>
mHalfOpens
;
bool
AvailableForDispatchNow
(
)
;
uint32_t
UnconnectedHalfOpens
(
)
;
void
RemoveHalfOpen
(
nsHalfOpenSocket
*
)
;
nsTArray
<
nsCString
>
mCoalescingKeys
;
bool
mUsingSpdy
:
1
;
bool
mInPreferredHash
:
1
;
bool
mPreferIPv4
:
1
;
bool
mPreferIPv6
:
1
;
bool
mUsedForConnection
:
1
;
void
RecordIPFamilyPreference
(
uint16_t
family
)
;
void
ResetIPFamilyPreference
(
)
;
}
;
public
:
static
nsAHttpConnection
*
MakeConnectionHandle
(
nsHttpConnection
*
aWrapped
)
;
private
:
class
nsHalfOpenSocket
final
:
public
nsIOutputStreamCallback
public
nsITransportEventSink
public
nsIInterfaceRequestor
public
nsITimerCallback
{
~
nsHalfOpenSocket
(
)
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOUTPUTSTREAMCALLBACK
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSITIMERCALLBACK
nsHalfOpenSocket
(
nsConnectionEntry
*
ent
nsAHttpTransaction
*
trans
uint32_t
caps
)
;
nsresult
SetupStreams
(
nsISocketTransport
*
*
nsIAsyncInputStream
*
*
nsIAsyncOutputStream
*
*
bool
isBackup
)
;
nsresult
SetupPrimaryStreams
(
)
;
nsresult
SetupBackupStreams
(
)
;
void
SetupBackupTimer
(
)
;
void
CancelBackupTimer
(
)
;
void
Abandon
(
)
;
double
Duration
(
TimeStamp
epoch
)
;
nsISocketTransport
*
SocketTransport
(
)
{
return
mSocketTransport
;
}
nsISocketTransport
*
BackupTransport
(
)
{
return
mBackupTransport
;
}
nsAHttpTransaction
*
Transaction
(
)
{
return
mTransaction
;
}
bool
IsSpeculative
(
)
{
return
mSpeculative
;
}
void
SetSpeculative
(
bool
val
)
{
mSpeculative
=
val
;
}
bool
IsFromPredictor
(
)
{
return
mIsFromPredictor
;
}
void
SetIsFromPredictor
(
bool
val
)
{
mIsFromPredictor
=
val
;
}
bool
Allow1918
(
)
{
return
mAllow1918
;
}
void
SetAllow1918
(
bool
val
)
{
mAllow1918
=
val
;
}
bool
HasConnected
(
)
{
return
mHasConnected
;
}
void
PrintDiagnostics
(
nsCString
&
log
)
;
private
:
nsConnectionEntry
*
mEnt
;
RefPtr
<
nsAHttpTransaction
>
mTransaction
;
bool
mDispatchedMTransaction
;
nsCOMPtr
<
nsISocketTransport
>
mSocketTransport
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mStreamOut
;
nsCOMPtr
<
nsIAsyncInputStream
>
mStreamIn
;
uint32_t
mCaps
;
bool
mSpeculative
;
bool
mIsFromPredictor
;
bool
mAllow1918
;
TimeStamp
mPrimarySynStarted
;
TimeStamp
mBackupSynStarted
;
nsCOMPtr
<
nsITimer
>
mSynTimer
;
nsCOMPtr
<
nsISocketTransport
>
mBackupTransport
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mBackupStreamOut
;
nsCOMPtr
<
nsIAsyncInputStream
>
mBackupStreamIn
;
bool
mHasConnected
;
bool
mPrimaryConnectedOK
;
bool
mBackupConnectedOK
;
}
;
friend
class
nsHalfOpenSocket
;
ReentrantMonitor
mReentrantMonitor
;
nsCOMPtr
<
nsIEventTarget
>
mSocketThreadTarget
;
uint16_t
mMaxConns
;
uint16_t
mMaxPersistConnsPerHost
;
uint16_t
mMaxPersistConnsPerProxy
;
uint16_t
mMaxRequestDelay
;
Atomic
<
bool
mozilla
:
:
Relaxed
>
mIsShuttingDown
;
bool
ProcessPendingQForEntry
(
nsConnectionEntry
*
bool
considerAll
)
;
bool
AtActiveConnectionLimit
(
nsConnectionEntry
*
uint32_t
caps
)
;
nsresult
TryDispatchTransaction
(
nsConnectionEntry
*
ent
bool
onlyReusedConnection
nsHttpTransaction
*
trans
)
;
nsresult
DispatchTransaction
(
nsConnectionEntry
*
nsHttpTransaction
*
nsHttpConnection
*
)
;
nsresult
DispatchAbstractTransaction
(
nsConnectionEntry
*
nsAHttpTransaction
*
uint32_t
nsHttpConnection
*
int32_t
)
;
bool
RestrictConnections
(
nsConnectionEntry
*
)
;
nsresult
ProcessNewTransaction
(
nsHttpTransaction
*
)
;
nsresult
EnsureSocketThreadTarget
(
)
;
void
ClosePersistentConnections
(
nsConnectionEntry
*
ent
)
;
void
ReportProxyTelemetry
(
nsConnectionEntry
*
ent
)
;
nsresult
CreateTransport
(
nsConnectionEntry
*
nsAHttpTransaction
*
uint32_t
bool
bool
bool
)
;
void
AddActiveConn
(
nsHttpConnection
*
nsConnectionEntry
*
)
;
void
DecrementActiveConnCount
(
nsHttpConnection
*
)
;
void
StartedConnect
(
)
;
void
RecvdConnect
(
)
;
nsConnectionEntry
*
GetOrCreateConnectionEntry
(
nsHttpConnectionInfo
*
bool
allowWildCard
)
;
nsresult
MakeNewConnection
(
nsConnectionEntry
*
ent
nsHttpTransaction
*
trans
)
;
nsConnectionEntry
*
GetSpdyPreferredEnt
(
nsConnectionEntry
*
aOriginalEntry
)
;
nsConnectionEntry
*
LookupPreferredHash
(
nsConnectionEntry
*
ent
)
;
void
StorePreferredHash
(
nsConnectionEntry
*
ent
)
;
void
RemovePreferredHash
(
nsConnectionEntry
*
ent
)
;
nsHttpConnection
*
GetSpdyPreferredConn
(
nsConnectionEntry
*
ent
)
;
nsDataHashtable
<
nsCStringHashKey
nsConnectionEntry
*
>
mSpdyPreferredHash
;
nsConnectionEntry
*
LookupConnectionEntry
(
nsHttpConnectionInfo
*
ci
nsHttpConnection
*
conn
nsHttpTransaction
*
trans
)
;
void
ProcessSpdyPendingQ
(
nsConnectionEntry
*
ent
)
;
nsresult
PostEvent
(
nsConnEventHandler
handler
int32_t
iparam
=
0
ARefBase
*
vparam
=
nullptr
)
;
void
OnMsgShutdown
(
int32_t
ARefBase
*
)
;
void
OnMsgShutdownConfirm
(
int32_t
ARefBase
*
)
;
void
OnMsgNewTransaction
(
int32_t
ARefBase
*
)
;
void
OnMsgReschedTransaction
(
int32_t
ARefBase
*
)
;
void
OnMsgCancelTransaction
(
int32_t
ARefBase
*
)
;
void
OnMsgCancelTransactions
(
int32_t
ARefBase
*
)
;
void
OnMsgProcessPendingQ
(
int32_t
ARefBase
*
)
;
void
OnMsgPruneDeadConnections
(
int32_t
ARefBase
*
)
;
void
OnMsgSpeculativeConnect
(
int32_t
ARefBase
*
)
;
void
OnMsgReclaimConnection
(
int32_t
ARefBase
*
)
;
void
OnMsgCompleteUpgrade
(
int32_t
ARefBase
*
)
;
void
OnMsgUpdateParam
(
int32_t
ARefBase
*
)
;
void
OnMsgDoShiftReloadConnectionCleanup
(
int32_t
ARefBase
*
)
;
void
OnMsgProcessFeedback
(
int32_t
ARefBase
*
)
;
void
OnMsgProcessAllSpdyPendingQ
(
int32_t
ARefBase
*
)
;
void
OnMsgUpdateRequestTokenBucket
(
int32_t
ARefBase
*
)
;
void
OnMsgVerifyTraffic
(
int32_t
ARefBase
*
)
;
void
OnMsgPruneNoTraffic
(
int32_t
ARefBase
*
)
;
uint16_t
mNumActiveConns
;
uint16_t
mNumIdleConns
;
uint16_t
mNumSpdyActiveConns
;
uint32_t
mNumHalfOpenConns
;
uint64_t
mTimeOfNextWakeUp
;
nsCOMPtr
<
nsITimer
>
mTimer
;
nsCOMPtr
<
nsITimer
>
mTrafficTimer
;
bool
mPruningNoTraffic
;
nsCOMPtr
<
nsITimer
>
mTimeoutTick
;
bool
mTimeoutTickArmed
;
uint32_t
mTimeoutTickNext
;
nsClassHashtable
<
nsCStringHashKey
nsConnectionEntry
>
mCT
;
void
TimeoutTick
(
)
;
void
OnMsgPrintDiagnostics
(
int32_t
ARefBase
*
)
;
nsCString
mLogData
;
}
;
}
}
#
endif
