#
ifndef
HalfOpenSocket_h__
#
define
HalfOpenSocket_h__
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsAHttpConnection
.
h
"
#
include
"
nsHttpConnection
.
h
"
#
include
"
nsHttpTransaction
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsITransport
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
TCPFastOpen
.
h
"
namespace
mozilla
{
namespace
net
{
#
define
NS_HALFOPENSOCKET_IID
\
{
\
0x8d411b53
0x54bc
0x4a99
{
\
0x8b
0x78
0xff
0x12
0x5e
0xab
0x15
0x64
\
}
\
}
class
PendingTransactionInfo
;
class
ConnectionEntry
;
class
HalfOpenSocket
final
:
public
nsIOutputStreamCallback
public
nsITransportEventSink
public
nsIInterfaceRequestor
public
nsITimerCallback
public
nsINamed
public
nsSupportsWeakReference
public
TCPFastOpen
{
~
HalfOpenSocket
(
)
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_HALFOPENSOCKET_IID
)
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOUTPUTSTREAMCALLBACK
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
HalfOpenSocket
(
ConnectionEntry
*
ent
nsAHttpTransaction
*
trans
uint32_t
caps
bool
speculative
bool
isFromPredictor
bool
urgentStart
)
;
[
[
nodiscard
]
]
nsresult
SetupStreams
(
nsISocketTransport
*
*
nsIAsyncInputStream
*
*
nsIAsyncOutputStream
*
*
bool
isBackup
)
;
[
[
nodiscard
]
]
nsresult
SetupPrimaryStreams
(
)
;
[
[
nodiscard
]
]
nsresult
SetupBackupStreams
(
)
;
void
SetupBackupTimer
(
)
;
void
CancelBackupTimer
(
)
;
void
Abandon
(
)
;
double
Duration
(
TimeStamp
epoch
)
;
nsISocketTransport
*
SocketTransport
(
)
{
return
mSocketTransport
;
}
nsISocketTransport
*
BackupTransport
(
)
{
return
mBackupTransport
;
}
nsAHttpTransaction
*
Transaction
(
)
{
return
mTransaction
;
}
bool
IsSpeculative
(
)
{
return
mSpeculative
;
}
bool
IsFromPredictor
(
)
{
return
mIsFromPredictor
;
}
bool
Allow1918
(
)
{
return
mAllow1918
;
}
void
SetAllow1918
(
bool
val
)
{
mAllow1918
=
val
;
}
bool
HasConnected
(
)
{
return
mHasConnected
;
}
void
PrintDiagnostics
(
nsCString
&
log
)
;
bool
AcceptsTransaction
(
nsHttpTransaction
*
trans
)
;
bool
Claim
(
)
;
void
Unclaim
(
)
;
bool
FastOpenEnabled
(
)
override
;
nsresult
StartFastOpen
(
)
override
;
void
SetFastOpenConnected
(
nsresult
bool
aWillRetry
)
override
;
void
FastOpenNotSupported
(
)
override
;
void
SetFastOpenStatus
(
uint8_t
tfoStatus
)
override
;
void
CancelFastOpenConnection
(
)
;
private
:
nsresult
SetupConn
(
nsIAsyncOutputStream
*
out
bool
aFastOpen
)
;
already_AddRefed
<
PendingTransactionInfo
>
FindTransactionHelper
(
bool
removeWhenFound
)
;
RefPtr
<
nsAHttpTransaction
>
mTransaction
;
bool
mDispatchedMTransaction
;
nsCOMPtr
<
nsISocketTransport
>
mSocketTransport
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mStreamOut
;
nsCOMPtr
<
nsIAsyncInputStream
>
mStreamIn
;
uint32_t
mCaps
;
bool
mSpeculative
;
bool
mUrgentStart
;
bool
mIsFromPredictor
;
bool
mAllow1918
;
TimeStamp
mPrimarySynStarted
;
TimeStamp
mBackupSynStarted
;
bool
mHasConnected
;
bool
mPrimaryConnectedOK
;
bool
mBackupConnectedOK
;
bool
mBackupConnStatsSet
;
bool
mFreeToUse
;
nsresult
mPrimaryStreamStatus
;
bool
mFastOpenInProgress
;
RefPtr
<
nsHttpConnection
>
mConnectionNegotiatingFastOpen
;
uint8_t
mFastOpenStatus
;
RefPtr
<
ConnectionEntry
>
mEnt
;
nsCOMPtr
<
nsITimer
>
mSynTimer
;
nsCOMPtr
<
nsISocketTransport
>
mBackupTransport
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mBackupStreamOut
;
nsCOMPtr
<
nsIAsyncInputStream
>
mBackupStreamIn
;
bool
mIsHttp3
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
HalfOpenSocket
NS_HALFOPENSOCKET_IID
)
}
}
#
endif
