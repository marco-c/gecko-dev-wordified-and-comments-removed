#
ifndef
TlsHandshaker_h__
#
define
TlsHandshaker_h__
#
include
"
nsITlsHandshakeListener
.
h
"
class
nsISocketTransport
;
class
nsITLSSocketControl
;
namespace
mozilla
:
:
net
{
class
nsHttpConnection
;
class
nsHttpConnectionInfo
;
class
TlsHandshaker
:
public
nsITlsHandshakeCallbackListener
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITLSHANDSHAKECALLBACKLISTENER
TlsHandshaker
(
nsHttpConnectionInfo
*
aInfo
nsHttpConnection
*
aOwner
)
;
void
SetupSSL
(
bool
aInSpdyTunnel
bool
aForcePlainText
)
;
[
[
nodiscard
]
]
nsresult
InitSSLParams
(
bool
connectingToProxy
bool
ProxyStartSSL
)
;
[
[
nodiscard
]
]
nsresult
SetupNPNList
(
nsITLSSocketControl
*
ssl
uint32_t
caps
bool
connectingToProxy
)
;
[
[
nodiscard
]
]
bool
EnsureNPNComplete
(
)
;
void
FinishNPNSetup
(
bool
handshakeSucceeded
bool
hasSecurityInfo
)
;
bool
EarlyDataAvailable
(
)
const
{
return
mEarlyDataState
=
=
EarlyData
:
:
USED
|
|
mEarlyDataState
=
=
EarlyData
:
:
CANNOT_BE_USED
;
}
bool
EarlyDataWasAvailable
(
)
const
{
return
mEarlyDataState
!
=
EarlyData
:
:
NOT_AVAILABLE
&
&
mEarlyDataState
!
=
EarlyData
:
:
DONE_NOT_AVAILABLE
;
}
bool
EarlyDataUsed
(
)
const
{
return
mEarlyDataState
=
=
EarlyData
:
:
USED
;
}
bool
EarlyDataCanNotBeUsed
(
)
const
{
return
mEarlyDataState
=
=
EarlyData
:
:
CANNOT_BE_USED
;
}
void
EarlyDataDone
(
)
;
#
ifndef
ANDROID
void
EarlyDataTelemetry
(
int16_t
tlsVersion
bool
earlyDataAccepted
int64_t
aContentBytesWritten0RTT
)
;
#
endif
bool
NPNComplete
(
)
const
{
return
mNPNComplete
;
}
bool
SetupSSLCalled
(
)
const
{
return
mSetupSSLCalled
;
}
bool
TlsHandshakeComplitionPending
(
)
const
{
return
mTlsHandshakeComplitionPending
;
}
const
nsCString
&
EarlyNegotiatedALPN
(
)
const
{
return
mEarlyNegotiatedALPN
;
}
void
SetNPNComplete
(
)
{
mNPNComplete
=
true
;
}
void
NotifyClose
(
)
{
mTlsHandshakeComplitionPending
=
false
;
mOwner
=
nullptr
;
}
private
:
virtual
~
TlsHandshaker
(
)
;
void
Check0RttEnabled
(
nsITLSSocketControl
*
ssl
)
;
void
ReportSecureConnectionStart
(
)
;
bool
mSetupSSLCalled
{
false
}
;
bool
mNPNComplete
{
false
}
;
bool
mSecureConnectionStartReported
{
false
}
;
bool
mTlsHandshakeComplitionPending
{
false
}
;
bool
m0RTTChecked
{
false
}
;
enum
EarlyData
{
NOT_AVAILABLE
USED
CANNOT_BE_USED
DONE_NOT_AVAILABLE
DONE_USED
DONE_CANNOT_BE_USED
}
;
EarlyData
mEarlyDataState
{
EarlyData
:
:
NOT_AVAILABLE
}
;
nsCString
mEarlyNegotiatedALPN
;
RefPtr
<
nsHttpConnectionInfo
>
mConnInfo
;
RefPtr
<
nsHttpConnection
>
mOwner
;
}
;
}
#
endif
