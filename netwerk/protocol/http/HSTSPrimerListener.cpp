#
include
"
nsHttp
.
h
"
#
include
"
HSTSPrimerListener
.
h
"
#
include
"
nsIHstsPrimingCallback
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsSecurityHeaderParser
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
nsISocketProvider
.
h
"
#
include
"
nsISSLStatus
.
h
"
#
include
"
nsISSLStatusProvider
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsStreamListenerWrapper
.
h
"
#
include
"
nsHttpChannel
.
h
"
#
include
"
LoadInfo
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsQueryObject
.
h
"
namespace
mozilla
{
namespace
net
{
using
namespace
mozilla
;
NS_IMPL_ISUPPORTS
(
HSTSPrimingListener
nsIStreamListener
nsIRequestObserver
nsIInterfaceRequestor
nsITimerCallback
)
uint32_t
HSTSPrimingListener
:
:
sHSTSPrimingTimeout
=
3000
;
HSTSPrimingListener
:
:
HSTSPrimingListener
(
nsIHstsPrimingCallback
*
aCallback
)
:
mCallback
(
aCallback
)
{
static
nsresult
rv
=
Preferences
:
:
AddUintVarCache
(
&
sHSTSPrimingTimeout
"
security
.
mixed_content
.
hsts_priming_request_timeout
"
)
;
Unused
<
<
rv
;
}
NS_IMETHODIMP
HSTSPrimingListener
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
return
QueryInterface
(
aIID
aResult
)
;
}
void
HSTSPrimingListener
:
:
ReportTiming
(
nsresult
aResult
)
{
nsCOMPtr
<
nsITimedChannel
>
timingChannel
=
do_QueryInterface
(
mCallback
)
;
if
(
timingChannel
)
{
TimeStamp
channelCreationTime
;
nsresult
rv
=
timingChannel
-
>
GetChannelCreation
(
&
channelCreationTime
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
channelCreationTime
.
IsNull
(
)
)
{
PRUint32
interval
=
(
PRUint32
)
(
TimeStamp
:
:
Now
(
)
-
channelCreationTime
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HSTS_PRIMING_REQUEST_DURATION
(
NS_SUCCEEDED
(
aResult
)
)
?
NS_LITERAL_CSTRING
(
"
success
"
)
:
NS_LITERAL_CSTRING
(
"
failure
"
)
interval
)
;
}
}
}
NS_IMETHODIMP
HSTSPrimingListener
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
nsCOMPtr
<
nsIHstsPrimingCallback
>
callback
;
callback
.
swap
(
mCallback
)
;
if
(
mHSTSPrimingTimer
)
{
Unused
<
<
mHSTSPrimingTimer
-
>
Cancel
(
)
;
mHSTSPrimingTimer
=
nullptr
;
}
if
(
!
callback
)
{
return
NS_OK
;
}
nsresult
primingResult
=
CheckHSTSPrimingRequestStatus
(
aRequest
)
;
ReportTiming
(
primingResult
)
;
if
(
NS_FAILED
(
primingResult
)
)
{
LOG
(
(
"
HSTS
Priming
Failed
(
request
was
not
approved
)
"
)
)
;
return
callback
-
>
OnHSTSPrimingFailed
(
primingResult
false
)
;
}
LOG
(
(
"
HSTS
Priming
Succeeded
(
request
was
approved
)
"
)
)
;
return
callback
-
>
OnHSTSPrimingSucceeded
(
false
)
;
}
NS_IMETHODIMP
HSTSPrimingListener
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
)
{
return
NS_OK
;
}
nsresult
HSTSPrimingListener
:
:
CheckHSTSPrimingRequestStatus
(
nsIRequest
*
aRequest
)
{
nsresult
status
;
nsresult
rv
=
aRequest
-
>
GetStatus
(
&
status
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
NS_FAILED
(
status
)
)
{
return
NS_ERROR_CONTENT_BLOCKED
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aRequest
)
;
NS_ENSURE_STATE
(
httpChannel
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
internal
=
do_QueryInterface
(
aRequest
)
;
NS_ENSURE_STATE
(
internal
)
;
bool
succeedded
;
rv
=
httpChannel
-
>
GetRequestSucceeded
(
&
succeedded
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
succeedded
)
{
return
NS_ERROR_CONTENT_BLOCKED
;
}
bool
synthesized
=
false
;
RefPtr
<
nsHttpChannel
>
rawHttpChannel
=
do_QueryObject
(
httpChannel
)
;
NS_ENSURE_STATE
(
rawHttpChannel
)
;
rv
=
rawHttpChannel
-
>
GetResponseSynthesized
(
&
synthesized
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
synthesized
)
{
return
NS_ERROR_CONTENT_BLOCKED
;
}
nsCOMPtr
<
nsISiteSecurityService
>
sss
=
do_GetService
(
NS_SSSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
httpChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
uri
NS_ERROR_CONTENT_BLOCKED
)
;
bool
hsts
;
rv
=
sss
-
>
IsSecureURI
(
nsISiteSecurityService
:
:
HEADER_HSTS
uri
0
nullptr
&
hsts
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
hsts
)
{
return
NS_OK
;
}
return
NS_ERROR_CONTENT_BLOCKED
;
}
NS_IMETHODIMP
HSTSPrimingListener
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
ctxt
nsIInputStream
*
inStr
uint64_t
sourceOffset
uint32_t
count
)
{
uint32_t
totalRead
;
return
inStr
-
>
ReadSegments
(
NS_DiscardSegment
nullptr
count
&
totalRead
)
;
}
NS_IMETHODIMP
HSTSPrimingListener
:
:
Notify
(
nsITimer
*
timer
)
{
nsresult
rv
;
nsCOMPtr
<
nsIHstsPrimingCallback
>
callback
;
callback
.
swap
(
mCallback
)
;
if
(
!
callback
)
{
return
NS_OK
;
}
ReportTiming
(
NS_ERROR_HSTS_PRIMING_TIMEOUT
)
;
if
(
mPrimingChannel
)
{
rv
=
mPrimingChannel
-
>
Cancel
(
NS_ERROR_HSTS_PRIMING_TIMEOUT
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
HSTS
Priming
timed
out
and
we
got
an
error
canceling
the
priming
channel
.
"
)
;
}
}
rv
=
callback
-
>
OnHSTSPrimingFailed
(
NS_ERROR_HSTS_PRIMING_TIMEOUT
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
HSTS
Priming
timed
out
and
we
got
an
error
reporting
the
failure
.
"
)
;
}
return
NS_OK
;
}
nsresult
HSTSPrimingListener
:
:
StartHSTSPriming
(
nsIChannel
*
aRequestChannel
nsIHstsPrimingCallback
*
aCallback
)
{
nsCOMPtr
<
nsIURI
>
finalChannelURI
;
nsresult
rv
=
NS_GetFinalChannelURI
(
aRequestChannel
getter_AddRefs
(
finalChannelURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_GetSecureUpgradedURI
(
finalChannelURI
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hsts
;
bool
cached
;
nsCOMPtr
<
nsISiteSecurityService
>
sss
=
do_GetService
(
NS_SSSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
sss
-
>
IsSecureURI
(
nsISiteSecurityService
:
:
HEADER_HSTS
uri
0
&
cached
&
hsts
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
hsts
)
{
return
aCallback
-
>
OnHSTSPrimingSucceeded
(
true
)
;
}
if
(
cached
)
{
return
aCallback
-
>
OnHSTSPrimingFailed
(
NS_ERROR_CONTENT_BLOCKED
true
)
;
}
nsCOMPtr
<
nsILoadInfo
>
originalLoadInfo
=
aRequestChannel
-
>
GetLoadInfo
(
)
;
MOZ_ASSERT
(
originalLoadInfo
"
can
not
perform
HSTS
priming
without
a
loadInfo
"
)
;
if
(
!
originalLoadInfo
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
static_cast
<
mozilla
:
:
LoadInfo
*
>
(
originalLoadInfo
.
get
(
)
)
-
>
CloneForNewRequest
(
)
;
nsSecurityFlags
securityMode
=
loadInfo
-
>
GetSecurityMode
(
)
;
if
(
securityMode
!
=
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
&
&
securityMode
!
=
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
&
&
securityMode
!
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
&
&
securityMode
!
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
&
&
securityMode
!
=
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
)
{
return
aCallback
-
>
OnHSTSPrimingFailed
(
NS_ERROR_CONTENT_BLOCKED
true
)
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
rv
=
aRequestChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsLoadFlags
loadFlags
;
rv
=
aRequestChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
loadFlags
&
=
HttpBaseChannel
:
:
INHIBIT_CACHING
|
HttpBaseChannel
:
:
INHIBIT_PERSISTENT_CACHING
|
HttpBaseChannel
:
:
LOAD_BYPASS_CACHE
|
HttpBaseChannel
:
:
LOAD_FROM_CACHE
|
HttpBaseChannel
:
:
VALIDATE_ALWAYS
;
loadFlags
|
=
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
|
nsIRequest
:
:
LOAD_ANONYMOUS
;
nsCOMPtr
<
nsIChannel
>
primingChannel
;
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
primingChannel
)
uri
loadInfo
loadGroup
nullptr
loadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
primingChannel
)
;
if
(
!
httpChannel
)
{
NS_ERROR
(
"
HSTSPrimingListener
:
Failed
to
QI
to
nsIHttpChannel
!
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internal
=
do_QueryInterface
(
primingChannel
)
;
NS_ENSURE_STATE
(
internal
)
;
rv
=
httpChannel
-
>
SetRequestMethod
(
NS_LITERAL_CSTRING
(
"
HEAD
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
httpChannel
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Upgrade
-
Insecure
-
Requests
"
)
NS_LITERAL_CSTRING
(
"
1
"
)
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIClassOfService
>
requestClass
=
do_QueryInterface
(
aRequestChannel
)
;
if
(
!
requestClass
)
{
NS_ERROR
(
"
HSTSPrimingListener
:
aRequestChannel
is
not
an
nsIClassOfService
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIClassOfService
>
primingClass
=
do_QueryInterface
(
httpChannel
)
;
if
(
!
primingClass
)
{
NS_ERROR
(
"
HSTSPrimingListener
:
httpChannel
is
not
an
nsIClassOfService
"
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
classFlags
=
0
;
rv
=
requestClass
-
>
GetClassFlags
(
&
classFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
primingClass
-
>
SetClassFlags
(
classFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISupportsPriority
>
p
=
do_QueryInterface
(
primingChannel
)
;
if
(
p
)
{
uint32_t
priority
=
nsISupportsPriority
:
:
PRIORITY_HIGHEST
;
p
-
>
SetPriority
(
priority
)
;
}
HSTSPrimingListener
*
listener
=
new
HSTSPrimingListener
(
aCallback
)
;
rv
=
primingChannel
-
>
AsyncOpen2
(
listener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
listener
-
>
mPrimingChannel
.
swap
(
primingChannel
)
;
nsCOMPtr
<
nsITimer
>
timer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
;
NS_ENSURE_STATE
(
timer
)
;
rv
=
timer
-
>
InitWithCallback
(
listener
sHSTSPrimingTimeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
HSTS
Priming
failed
to
initialize
channel
cancellation
timer
"
)
;
}
listener
-
>
mHSTSPrimingTimer
.
swap
(
timer
)
;
return
NS_OK
;
}
}
}
