#
ifndef
nsHttpChannel_h__
#
define
nsHttpChannel_h__
#
include
"
DelayHttpChannelQueue
.
h
"
#
include
"
HttpBaseChannel
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICacheEntryOpenCallback
.
h
"
#
include
"
nsIDNSListener
.
h
"
#
include
"
nsIApplicationCacheChannel
.
h
"
#
include
"
nsIProtocolProxyCallback
.
h
"
#
include
"
nsIHttpAuthenticableChannel
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsIThreadRetargetableStreamListener
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
TimingStruct
.
h
"
#
include
"
AutoClose
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsICorsPreflightCallback
.
h
"
#
include
"
AlternateServices
.
h
"
#
include
"
nsIRaceCacheWithNetwork
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
extensions
/
PStreamFilterParent
.
h
"
#
include
"
mozilla
/
net
/
DocumentLoadListener
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
class
nsDNSPrefetch
;
class
nsICancelable
;
class
nsIDNSRecord
;
class
nsIDNSHTTPSSVCRecord
;
class
nsIHttpChannelAuthProvider
;
class
nsInputStreamPump
;
class
nsITransportSecurityInfo
;
namespace
mozilla
{
namespace
net
{
class
nsChannelClassifier
;
class
HttpChannelSecurityWarningReporter
;
using
DNSPromise
=
MozPromise
<
nsCOMPtr
<
nsIDNSRecord
>
nsresult
false
>
;
#
define
NS_HTTPCHANNEL_IID
\
{
\
0x301bf95b
0x7bb3
0x4ae1
{
\
0xa9
0x71
0x40
0xbc
0xfa
0x81
0xde
0x12
\
}
\
}
class
nsHttpChannel
final
:
public
HttpBaseChannel
public
HttpAsyncAborter
<
nsHttpChannel
>
public
nsIStreamListener
public
nsICachingChannel
public
nsICacheEntryOpenCallback
public
nsITransportEventSink
public
nsIProtocolProxyCallback
public
nsIHttpAuthenticableChannel
public
nsIApplicationCacheChannel
public
nsIAsyncVerifyRedirectCallback
public
nsIThreadRetargetableRequest
public
nsIThreadRetargetableStreamListener
public
nsIDNSListener
public
nsSupportsWeakReference
public
nsICorsPreflightCallback
public
nsIRaceCacheWithNetwork
public
nsIRequestTailUnblockCallback
public
nsITimerCallback
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
NS_DECL_NSICACHEINFOCHANNEL
NS_DECL_NSICACHINGCHANNEL
NS_DECL_NSICACHEENTRYOPENCALLBACK
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSIPROTOCOLPROXYCALLBACK
NS_DECL_NSIPROXIEDCHANNEL
NS_DECL_NSIAPPLICATIONCACHECONTAINER
NS_DECL_NSIAPPLICATIONCACHECHANNEL
NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
NS_DECL_NSITHREADRETARGETABLEREQUEST
NS_DECL_NSIDNSLISTENER
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_HTTPCHANNEL_IID
)
NS_DECL_NSIRACECACHEWITHNETWORK
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSIREQUESTTAILUNBLOCKCALLBACK
NS_IMETHOD
GetIsSSL
(
bool
*
aIsSSL
)
override
;
NS_IMETHOD
GetProxyMethodIsConnect
(
bool
*
aProxyMethodIsConnect
)
override
;
NS_IMETHOD
GetServerResponseHeader
(
nsACString
&
aServerResponseHeader
)
override
;
NS_IMETHOD
GetProxyChallenges
(
nsACString
&
aChallenges
)
override
;
NS_IMETHOD
GetWWWChallenges
(
nsACString
&
aChallenges
)
override
;
NS_IMETHOD
SetProxyCredentials
(
const
nsACString
&
aCredentials
)
override
;
NS_IMETHOD
SetWWWCredentials
(
const
nsACString
&
aCredentials
)
override
;
NS_IMETHOD
OnAuthAvailable
(
)
override
;
NS_IMETHOD
OnAuthCancelled
(
bool
userCancel
)
override
;
NS_IMETHOD
CloseStickyConnection
(
)
override
;
NS_IMETHOD
ConnectionRestartable
(
bool
)
override
;
NS_IMETHOD
GetLoadFlags
(
nsLoadFlags
*
aLoadFlags
)
override
;
NS_IMETHOD
GetURI
(
nsIURI
*
*
aURI
)
override
;
NS_IMETHOD
GetNotificationCallbacks
(
nsIInterfaceRequestor
*
*
aCallbacks
)
override
;
NS_IMETHOD
GetLoadGroup
(
nsILoadGroup
*
*
aLoadGroup
)
override
;
NS_IMETHOD
GetRequestMethod
(
nsACString
&
aMethod
)
override
;
nsHttpChannel
(
)
;
[
[
nodiscard
]
]
virtual
nsresult
Init
(
nsIURI
*
aURI
uint32_t
aCaps
nsProxyInfo
*
aProxyInfo
uint32_t
aProxyResolveFlags
nsIURI
*
aProxyURI
uint64_t
aChannelId
nsContentPolicyType
aContentPolicyType
)
override
;
[
[
nodiscard
]
]
nsresult
OnPush
(
uint32_t
aPushedStreamId
const
nsACString
&
aUrl
const
nsACString
&
aRequestString
HttpTransactionShell
*
aTransaction
)
;
static
bool
IsRedirectStatus
(
uint32_t
status
)
;
static
bool
WillRedirect
(
const
nsHttpResponseHead
&
response
)
;
NS_IMETHOD
Cancel
(
nsresult
status
)
override
;
NS_IMETHOD
Suspend
(
)
override
;
NS_IMETHOD
Resume
(
)
override
;
NS_IMETHOD
GetSecurityInfo
(
nsISupports
*
*
aSecurityInfo
)
override
;
NS_IMETHOD
AsyncOpen
(
nsIStreamListener
*
aListener
)
override
;
NS_IMETHOD
GetEncodedBodySize
(
uint64_t
*
aEncodedBodySize
)
override
;
NS_IMETHOD
SetupFallbackChannel
(
const
char
*
aFallbackKey
)
override
;
NS_IMETHOD
SetChannelIsForDownload
(
bool
aChannelIsForDownload
)
override
;
NS_IMETHOD
GetNavigationStartTimeStamp
(
TimeStamp
*
aTimeStamp
)
override
;
NS_IMETHOD
SetNavigationStartTimeStamp
(
TimeStamp
aTimeStamp
)
override
;
NS_IMETHOD
CancelByURLClassifier
(
nsresult
aErrorCode
)
override
;
NS_IMETHOD
SetPriority
(
int32_t
value
)
override
;
NS_IMETHOD
SetClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
AddClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
ClearClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
ResumeAt
(
uint64_t
startPos
const
nsACString
&
entityID
)
override
;
NS_IMETHOD
SetNotificationCallbacks
(
nsIInterfaceRequestor
*
aCallbacks
)
override
;
NS_IMETHOD
SetLoadGroup
(
nsILoadGroup
*
aLoadGroup
)
override
;
NS_IMETHOD
GetDomainLookupStart
(
mozilla
:
:
TimeStamp
*
aDomainLookupStart
)
override
;
NS_IMETHOD
GetDomainLookupEnd
(
mozilla
:
:
TimeStamp
*
aDomainLookupEnd
)
override
;
NS_IMETHOD
GetConnectStart
(
mozilla
:
:
TimeStamp
*
aConnectStart
)
override
;
NS_IMETHOD
GetTcpConnectEnd
(
mozilla
:
:
TimeStamp
*
aTcpConnectEnd
)
override
;
NS_IMETHOD
GetSecureConnectionStart
(
mozilla
:
:
TimeStamp
*
aSecureConnectionStart
)
override
;
NS_IMETHOD
GetConnectEnd
(
mozilla
:
:
TimeStamp
*
aConnectEnd
)
override
;
NS_IMETHOD
GetRequestStart
(
mozilla
:
:
TimeStamp
*
aRequestStart
)
override
;
NS_IMETHOD
GetResponseStart
(
mozilla
:
:
TimeStamp
*
aResponseStart
)
override
;
NS_IMETHOD
GetResponseEnd
(
mozilla
:
:
TimeStamp
*
aResponseEnd
)
override
;
NS_IMETHOD
OnPreflightSucceeded
(
)
override
;
NS_IMETHOD
OnPreflightFailed
(
nsresult
aError
)
override
;
[
[
nodiscard
]
]
nsresult
AddSecurityMessage
(
const
nsAString
&
aMessageTag
const
nsAString
&
aMessageCategory
)
override
;
NS_IMETHOD
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
override
;
NS_IMETHOD
LogMimeTypeMismatch
(
const
nsACString
&
aMessageName
bool
aWarning
const
nsAString
&
aURL
const
nsAString
&
aContentType
)
override
;
void
SetWarningReporter
(
HttpChannelSecurityWarningReporter
*
aReporter
)
;
HttpChannelSecurityWarningReporter
*
GetWarningReporter
(
)
;
bool
DataSentToChildProcess
(
)
{
return
mDataSentToChildProcess
;
}
public
:
uint32_t
GetRequestTime
(
)
const
{
return
mRequestTime
;
}
nsresult
AsyncOpenFinal
(
TimeStamp
aTimeStamp
)
;
[
[
nodiscard
]
]
nsresult
OpenCacheEntry
(
bool
usingSSL
)
;
[
[
nodiscard
]
]
nsresult
OpenCacheEntryInternal
(
bool
isHttps
nsIApplicationCache
*
applicationCache
bool
noAppCache
)
;
[
[
nodiscard
]
]
nsresult
ContinueConnect
(
)
;
[
[
nodiscard
]
]
nsresult
StartRedirectChannelToURI
(
nsIURI
*
uint32_t
)
;
class
OfflineCacheEntryAsForeignMarker
{
nsCOMPtr
<
nsIApplicationCache
>
mApplicationCache
;
nsCOMPtr
<
nsIURI
>
mCacheURI
;
public
:
OfflineCacheEntryAsForeignMarker
(
nsIApplicationCache
*
appCache
nsIURI
*
aURI
)
:
mApplicationCache
(
appCache
)
mCacheURI
(
aURI
)
{
}
nsresult
MarkAsForeign
(
)
;
}
;
OfflineCacheEntryAsForeignMarker
*
GetOfflineCacheEntryAsForeignMarker
(
)
;
class
AutoCacheWaitFlags
{
public
:
explicit
AutoCacheWaitFlags
(
nsHttpChannel
*
channel
)
:
mChannel
(
channel
)
mKeep
(
0
)
{
mChannel
-
>
mCacheEntriesToWaitFor
=
nsHttpChannel
:
:
WAIT_FOR_CACHE_ENTRY
|
nsHttpChannel
:
:
WAIT_FOR_OFFLINE_CACHE_ENTRY
;
}
void
Keep
(
uint32_t
flags
)
{
mKeep
|
=
flags
;
}
~
AutoCacheWaitFlags
(
)
{
mChannel
-
>
mCacheEntriesToWaitFor
&
=
mKeep
;
}
private
:
nsHttpChannel
*
mChannel
;
uint32_t
mKeep
:
2
;
}
;
bool
AwaitingCacheCallbacks
(
)
;
void
SetCouldBeSynthesized
(
)
;
bool
IsReadingFromCache
(
)
const
{
return
mIsReadingFromCache
;
}
base
:
:
ProcessId
ProcessId
(
)
;
using
ChildEndpointPromise
=
MozPromise
<
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterChild
>
bool
true
>
;
[
[
nodiscard
]
]
RefPtr
<
ChildEndpointPromise
>
AttachStreamFilter
(
base
:
:
ProcessId
aChildProcessId
)
;
private
:
RefPtr
<
TransactionObserver
>
mTransactionObserver
;
public
:
void
SetConnectionInfo
(
nsHttpConnectionInfo
*
)
;
void
SetTransactionObserver
(
TransactionObserver
*
arg
)
{
mTransactionObserver
=
arg
;
}
TransactionObserver
*
GetTransactionObserver
(
)
{
return
mTransactionObserver
;
}
CacheDisposition
mCacheDisposition
;
protected
:
virtual
~
nsHttpChannel
(
)
;
private
:
typedef
nsresult
(
nsHttpChannel
:
:
*
nsContinueRedirectionFunc
)
(
nsresult
result
)
;
nsresult
CallOrWaitForResume
(
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
)
>
&
aFunc
)
;
bool
RequestIsConditional
(
)
;
void
HandleContinueCancellingByURLClassifier
(
nsresult
aErrorCode
)
;
nsresult
CancelInternal
(
nsresult
status
)
;
void
ContinueCancellingByURLClassifier
(
nsresult
aErrorCode
)
;
nsresult
MaybeResolveProxyAndBeginConnect
(
)
;
nsresult
MaybeStartDNSPrefetch
(
)
;
static
uint16_t
const
DNS_PREFETCH_ORIGIN
=
1
<
<
0
;
static
uint16_t
const
DNS_PREFETCH_PROXY
=
1
<
<
1
;
static
uint16_t
const
DNS_PROXY_IS_HTTP
=
1
<
<
2
;
static
uint16_t
const
DNS_BLOCK_ON_ORIGIN_RESOLVE
=
1
<
<
3
;
uint16_t
GetProxyDNSStrategy
(
)
;
nsresult
BeginConnect
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueBeginConnectWithResult
(
)
;
void
ContinueBeginConnect
(
)
;
[
[
nodiscard
]
]
nsresult
PrepareToConnect
(
)
;
void
HandleOnBeforeConnect
(
)
;
[
[
nodiscard
]
]
nsresult
OnBeforeConnect
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnBeforeConnect
(
bool
aShouldUpgrade
nsresult
aStatus
)
;
void
OnBeforeConnectContinue
(
)
;
[
[
nodiscard
]
]
nsresult
Connect
(
)
;
void
SpeculativeConnect
(
)
;
[
[
nodiscard
]
]
nsresult
SetupTransaction
(
)
;
[
[
nodiscard
]
]
nsresult
CallOnStartRequest
(
)
;
[
[
nodiscard
]
]
nsresult
ProcessResponse
(
)
;
void
AsyncContinueProcessResponse
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponse1
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponse2
(
nsresult
)
;
public
:
void
UpdateCacheDisposition
(
bool
aSuccessfulReval
bool
aPartialContentUsed
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponse3
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponse4
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ProcessNormal
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessNormal
(
nsresult
)
;
void
ProcessAltService
(
)
;
bool
ShouldBypassProcessNotModified
(
)
;
[
[
nodiscard
]
]
nsresult
ProcessNotModified
(
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueProcessResponseFunc
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponseAfterNotModified
(
nsresult
aRv
)
;
[
[
nodiscard
]
]
nsresult
AsyncProcessRedirection
(
uint32_t
httpStatus
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessRedirection
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessRedirectionAfterFallback
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ProcessFailedProxyConnect
(
uint32_t
httpStatus
)
;
[
[
nodiscard
]
]
nsresult
ProcessFallback
(
bool
*
waitingForRedirectCallback
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessFallback
(
nsresult
)
;
void
HandleAsyncAbort
(
)
;
[
[
nodiscard
]
]
nsresult
EnsureAssocReq
(
)
;
void
ProcessSSLInformation
(
)
;
bool
IsHTTPS
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStartRequest1
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStartRequest2
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStartRequest3
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStartRequest4
(
nsresult
)
;
void
OnClassOfServiceUpdated
(
)
;
void
HandleAsyncRedirect
(
)
;
void
HandleAsyncAPIRedirect
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueHandleAsyncRedirect
(
nsresult
)
;
void
HandleAsyncNotModified
(
)
;
void
HandleAsyncFallback
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueHandleAsyncFallback
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
PromptTempRedirect
(
)
;
[
[
nodiscard
]
]
virtual
nsresult
SetupReplacementChannel
(
nsIURI
*
nsIChannel
*
bool
preserveMethod
uint32_t
redirectFlags
)
override
;
[
[
nodiscard
]
]
nsresult
ProxyFailover
(
)
;
[
[
nodiscard
]
]
nsresult
AsyncDoReplaceWithProxy
(
nsIProxyInfo
*
)
;
[
[
nodiscard
]
]
nsresult
ContinueDoReplaceWithProxy
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ResolveProxy
(
)
;
[
[
nodiscard
]
]
nsresult
OnOfflineCacheEntryAvailable
(
nsICacheEntry
*
aEntry
bool
aNew
nsIApplicationCache
*
aAppCache
nsresult
aResult
)
;
[
[
nodiscard
]
]
nsresult
OnNormalCacheEntryAvailable
(
nsICacheEntry
*
aEntry
bool
aNew
nsresult
aResult
)
;
[
[
nodiscard
]
]
nsresult
OpenOfflineCacheEntryForWriting
(
)
;
[
[
nodiscard
]
]
nsresult
OnOfflineCacheEntryForWritingAvailable
(
nsICacheEntry
*
aEntry
nsIApplicationCache
*
aAppCache
nsresult
aResult
)
;
[
[
nodiscard
]
]
nsresult
OnCacheEntryAvailableInternal
(
nsICacheEntry
*
entry
bool
aNew
nsIApplicationCache
*
aAppCache
nsresult
status
)
;
[
[
nodiscard
]
]
nsresult
GenerateCacheKey
(
uint32_t
postID
nsACString
&
key
)
;
[
[
nodiscard
]
]
nsresult
UpdateExpirationTime
(
)
;
[
[
nodiscard
]
]
nsresult
CheckPartial
(
nsICacheEntry
*
aEntry
int64_t
*
aSize
int64_t
*
aContentLength
)
;
bool
ShouldUpdateOfflineCacheEntry
(
)
;
[
[
nodiscard
]
]
nsresult
ReadFromCache
(
bool
alreadyMarkedValid
)
;
void
CloseCacheEntry
(
bool
doomOnFailure
)
;
void
CloseOfflineCacheEntry
(
)
;
[
[
nodiscard
]
]
nsresult
InitCacheEntry
(
)
;
void
UpdateInhibitPersistentCachingFlag
(
)
;
[
[
nodiscard
]
]
nsresult
InitOfflineCacheEntry
(
)
;
[
[
nodiscard
]
]
nsresult
AddCacheEntryHeaders
(
nsICacheEntry
*
entry
)
;
[
[
nodiscard
]
]
nsresult
FinalizeCacheEntry
(
)
;
[
[
nodiscard
]
]
nsresult
InstallCacheListener
(
int64_t
offset
=
0
)
;
[
[
nodiscard
]
]
nsresult
InstallOfflineCacheListener
(
int64_t
offset
=
0
)
;
void
MaybeInvalidateCacheEntryForSubsequentGet
(
)
;
void
AsyncOnExamineCachedResponse
(
)
;
void
ClearBogusContentEncodingIfNeeded
(
)
;
[
[
nodiscard
]
]
nsresult
ProcessPartialContent
(
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueProcessResponseFunc
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponseAfterPartialContent
(
nsresult
aRv
)
;
[
[
nodiscard
]
]
nsresult
OnDoneReadingPartialCacheEntry
(
bool
*
streamDone
)
;
[
[
nodiscard
]
]
nsresult
DoAuthRetry
(
HttpTransactionShell
*
aTransWithStickyConn
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueOnStopRequestFunc
)
;
[
[
nodiscard
]
]
nsresult
ContinueDoAuthRetry
(
HttpTransactionShell
*
aTransWithStickyConn
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueOnStopRequestFunc
)
;
[
[
nodiscard
]
]
MOZ_NEVER_INLINE
nsresult
DoConnect
(
HttpTransactionShell
*
aTransWithStickyConn
=
nullptr
)
;
[
[
nodiscard
]
]
nsresult
DoConnectActual
(
HttpTransactionShell
*
aTransWithStickyConn
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStopRequestAfterAuthRetry
(
nsresult
aStatus
bool
aAuthRetry
bool
aIsFromNet
bool
aContentComplete
HttpTransactionShell
*
aTransWithStickyConn
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStopRequest
(
nsresult
status
bool
aIsFromNet
bool
aContentComplete
)
;
void
HandleAsyncRedirectChannelToHttps
(
)
;
[
[
nodiscard
]
]
nsresult
StartRedirectChannelToHttps
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueAsyncRedirectChannelToURI
(
nsresult
rv
)
;
[
[
nodiscard
]
]
nsresult
OpenRedirectChannel
(
nsresult
rv
)
;
HttpTrafficCategory
CreateTrafficCategory
(
)
;
[
[
nodiscard
]
]
nsresult
ProcessSecurityHeaders
(
)
;
[
[
nodiscard
]
]
nsresult
ProcessContentSignatureHeader
(
nsHttpResponseHead
*
aResponseHead
)
;
void
ProcessSecurityReport
(
nsresult
status
)
;
[
[
nodiscard
]
]
nsresult
ProcessSingleSecurityHeader
(
uint32_t
aType
nsITransportSecurityInfo
*
aSecInfo
uint32_t
aFlags
)
;
void
InvalidateCacheEntryForLocation
(
const
char
*
location
)
;
void
AssembleCacheKey
(
const
char
*
spec
uint32_t
postID
nsACString
&
key
)
;
[
[
nodiscard
]
]
nsresult
CreateNewURI
(
const
char
*
loc
nsIURI
*
*
newURI
)
;
void
DoInvalidateCacheEntry
(
nsIURI
*
aURI
)
;
inline
bool
HostPartIsTheSame
(
nsIURI
*
uri
)
{
nsAutoCString
tmpHost1
tmpHost2
;
return
(
NS_SUCCEEDED
(
mURI
-
>
GetAsciiHost
(
tmpHost1
)
)
&
&
NS_SUCCEEDED
(
uri
-
>
GetAsciiHost
(
tmpHost2
)
)
&
&
(
tmpHost1
=
=
tmpHost2
)
)
;
}
inline
static
bool
DoNotRender3xxBody
(
nsresult
rv
)
{
return
rv
=
=
NS_ERROR_REDIRECT_LOOP
|
|
rv
=
=
NS_ERROR_CORRUPTED_CONTENT
|
|
rv
=
=
NS_ERROR_UNKNOWN_PROTOCOL
|
|
rv
=
=
NS_ERROR_MALFORMED_URI
|
|
rv
=
=
NS_ERROR_PORT_ACCESS_NOT_ALLOWED
;
}
void
ReportNetVSCacheTelemetry
(
)
;
int64_t
ComputeTelemetryBucketNumber
(
int64_t
difftime_ms
)
;
void
ReportRcwnStats
(
bool
isFromNet
)
;
void
UpdateAggregateCallbacks
(
)
;
static
bool
HasQueryString
(
nsHttpRequestHead
:
:
ParsedMethodType
method
nsIURI
*
uri
)
;
bool
ResponseWouldVary
(
nsICacheEntry
*
entry
)
;
bool
IsResumable
(
int64_t
partialLen
int64_t
contentLength
bool
ignoreMissingPartialLen
=
false
)
const
;
[
[
nodiscard
]
]
nsresult
MaybeSetupByteRangeRequest
(
int64_t
partialLen
int64_t
contentLength
bool
ignoreMissingPartialLen
=
false
)
;
[
[
nodiscard
]
]
nsresult
SetupByteRangeRequest
(
int64_t
partialLen
)
;
void
UntieByteRangeRequest
(
)
;
void
UntieValidationRequest
(
)
;
[
[
nodiscard
]
]
nsresult
OpenCacheInputStream
(
nsICacheEntry
*
cacheEntry
bool
startBuffering
bool
checkingAppCacheEntry
)
;
void
SetPushedStreamTransactionAndId
(
HttpTransactionShell
*
aTransWithPushedStream
uint32_t
aPushedStreamId
)
;
void
MaybeWarnAboutAppCache
(
)
;
void
SetOriginHeader
(
)
;
void
SetDoNotTrack
(
)
;
bool
IsIsolated
(
)
;
const
nsCString
&
GetTopWindowOrigin
(
)
;
already_AddRefed
<
nsChannelClassifier
>
GetOrCreateChannelClassifier
(
)
;
[
[
nodiscard
]
]
nsresult
RedirectToInterceptedChannel
(
)
;
void
SetCachedContentType
(
)
;
void
UpdateAntiTrackingInfo
(
)
;
private
:
nsCOMPtr
<
nsIApplicationCache
>
mApplicationCacheForWrite
;
nsCOMPtr
<
nsIHttpChannelAuthProvider
>
mAuthProvider
;
nsCOMPtr
<
nsIURI
>
mRedirectURI
;
nsCOMPtr
<
nsIChannel
>
mRedirectChannel
;
nsCOMPtr
<
nsIChannel
>
mPreflightChannel
;
RefPtr
<
nsChannelClassifier
>
mChannelClassifier
;
void
ReleaseMainThreadOnlyReferences
(
)
;
void
ReEvaluateReferrerAfterTrackingStatusIsKnown
(
)
;
void
PerformBackgroundCacheRevalidation
(
)
;
void
PerformBackgroundCacheRevalidationNow
(
)
;
private
:
nsCOMPtr
<
nsICancelable
>
mProxyRequest
;
nsCOMPtr
<
nsIRequest
>
mTransactionPump
;
RefPtr
<
HttpTransactionShell
>
mTransaction
;
uint64_t
mLogicalOffset
;
nsCOMPtr
<
nsICacheEntry
>
mCacheEntry
;
nsCOMPtr
<
nsICacheEntry
>
mAltDataCacheEntry
;
nsCOMPtr
<
nsIURI
>
mCacheEntryURI
;
nsCString
mCacheIdExtension
;
AutoClose
<
nsIInputStream
>
mCacheInputStream
;
RefPtr
<
nsInputStreamPump
>
mCachePump
;
UniquePtr
<
nsHttpResponseHead
>
mCachedResponseHead
;
nsCOMPtr
<
nsISupports
>
mCachedSecurityInfo
;
uint32_t
mPostID
;
uint32_t
mRequestTime
;
nsCOMPtr
<
nsICacheEntry
>
mOfflineCacheEntry
;
uint32_t
mOfflineCacheLastModifiedTime
;
nsTArray
<
StreamFilterRequest
>
mStreamFilterRequests
;
mozilla
:
:
TimeStamp
mOnStartRequestTimestamp
;
mozilla
:
:
TimeStamp
mSuspendTimestamp
;
mozilla
:
:
TimeStamp
mOnCacheEntryCheckTimestamp
;
#
ifdef
MOZ_GECKO_PROFILER
mozilla
:
:
TimeStamp
mLastStatusReported
;
#
endif
uint32_t
mSuspendTotalTime
;
nsCString
mFallbackKey
;
friend
class
AutoRedirectVetoNotifier
;
friend
class
HttpAsyncAborter
<
nsHttpChannel
>
;
uint32_t
mRedirectType
;
static
const
uint32_t
WAIT_FOR_CACHE_ENTRY
=
1
;
static
const
uint32_t
WAIT_FOR_OFFLINE_CACHE_ENTRY
=
2
;
bool
mCacheOpenWithPriority
;
uint32_t
mCacheQueueSizeWhenOpen
;
Atomic
<
bool
Relaxed
>
mCachedContentIsValid
;
Atomic
<
bool
>
mAuthRetryPending
;
uint32_t
mCachedContentIsPartial
:
1
;
uint32_t
mCacheOnlyMetadata
:
1
;
uint32_t
mTransactionReplaced
:
1
;
uint32_t
mProxyAuthPending
:
1
;
uint32_t
mCustomAuthHeader
:
1
;
uint32_t
mResuming
:
1
;
uint32_t
mInitedCacheEntry
:
1
;
uint32_t
mFallbackChannel
:
1
;
uint32_t
mCustomConditionalRequest
:
1
;
uint32_t
mFallingBack
:
1
;
uint32_t
mWaitingForRedirectCallback
:
1
;
uint32_t
mRequestTimeInitialized
:
1
;
uint32_t
mCacheEntryIsReadOnly
:
1
;
uint32_t
mCacheEntryIsWriteOnly
:
1
;
uint32_t
mCacheEntriesToWaitFor
:
2
;
uint32_t
mConcurrentCacheAccess
:
1
;
uint32_t
mIsPartialRequest
:
1
;
uint32_t
mHasAutoRedirectVetoNotifier
:
1
;
uint32_t
mPinCacheContent
:
1
;
uint32_t
mIsCorsPreflightDone
:
1
;
uint32_t
mStronglyFramed
:
1
;
uint32_t
mUsedNetwork
:
1
;
uint32_t
mAuthConnectionRestartable
:
1
;
uint32_t
mChannelClassifierCancellationPending
:
1
;
uint32_t
mAsyncResumePending
:
1
;
uint32_t
mHasBeenIsolatedChecked
:
1
;
uint32_t
mIsIsolated
:
1
;
uint32_t
mTopWindowOriginComputed
:
1
;
uint32_t
mDataSentToChildProcess
:
1
;
uint32_t
mUseHTTPSSVC
:
1
;
uint32_t
mWaitHTTPSSVCRecord
:
1
;
uint32_t
mHTTPSSVCTelemetryReported
:
1
;
nsCString
mTopWindowOrigin
;
nsTArray
<
nsContinueRedirectionFunc
>
mRedirectFuncStack
;
RefPtr
<
nsDNSPrefetch
>
mDNSPrefetch
;
uint32_t
mPushedStreamId
;
RefPtr
<
HttpTransactionShell
>
mTransWithPushedStream
;
bool
mLocalBlocklist
;
[
[
nodiscard
]
]
nsresult
WaitForRedirectCallback
(
)
;
void
PushRedirectAsyncFunc
(
nsContinueRedirectionFunc
func
)
;
void
PopRedirectAsyncFunc
(
nsContinueRedirectionFunc
func
)
;
bool
EligibleForTailing
(
)
;
bool
WaitingForTailUnblock
(
)
;
nsresult
(
nsHttpChannel
:
:
*
mOnTailUnblock
)
(
)
;
nsresult
AsyncOpenOnTailUnblock
(
)
;
nsresult
ConnectOnTailUnblock
(
)
;
nsCString
mUsername
;
RefPtr
<
HttpChannelSecurityWarningReporter
>
mWarningReporter
;
Atomic
<
bool
>
mIsReadingFromCache
;
nsCOMPtr
<
nsITimer
>
mCacheOpenTimer
;
std
:
:
function
<
void
(
nsHttpChannel
*
)
>
mCacheOpenFunc
;
uint32_t
mCacheOpenDelay
=
0
;
enum
ResponseSource
{
RESPONSE_PENDING
=
0
RESPONSE_FROM_CACHE
=
1
RESPONSE_FROM_NETWORK
=
2
}
;
Atomic
<
ResponseSource
Relaxed
>
mFirstResponseSource
;
nsresult
MaybeRaceCacheWithNetwork
(
)
;
void
MaybeCreateCacheEntryWhenRCWN
(
)
;
nsresult
TriggerNetworkWithDelay
(
uint32_t
aDelay
)
;
nsresult
TriggerNetwork
(
)
;
void
CancelNetworkRequest
(
nsresult
aStatus
)
;
void
SetHTTPSSVCRecord
(
nsIDNSHTTPSSVCRecord
*
aRecord
)
;
nsCOMPtr
<
nsITimer
>
mNetworkTriggerTimer
;
bool
mNetworkTriggered
=
false
;
bool
mWaitingForProxy
=
false
;
bool
mStaleRevalidation
=
false
;
Atomic
<
bool
>
mRaceCacheWithNetwork
;
uint32_t
mRaceDelay
;
bool
mIgnoreCacheEntry
;
mozilla
:
:
Mutex
mRCWNLock
;
TimeStamp
mNavigationStartTimeStamp
;
MozPromiseHolder
<
DNSPromise
>
mDNSBlockingPromise
;
RefPtr
<
DNSPromise
>
mDNSBlockingThenable
;
int32_t
mProxyConnectResponseCode
;
nsCOMPtr
<
nsIDNSHTTPSSVCRecord
>
mHTTPSSVCRecord
;
protected
:
virtual
void
DoNotifyListenerCleanup
(
)
override
;
virtual
void
ReleaseListeners
(
)
override
;
virtual
void
DoAsyncAbort
(
nsresult
aStatus
)
override
;
private
:
bool
mDidReval
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsHttpChannel
NS_HTTPCHANNEL_IID
)
}
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
net
:
:
nsHttpChannel
*
aChannel
)
{
return
static_cast
<
nsIHttpChannel
*
>
(
aChannel
)
;
}
#
endif
