#
ifndef
nsHttpChannel_h__
#
define
nsHttpChannel_h__
#
include
"
DelayHttpChannelQueue
.
h
"
#
include
"
HttpBaseChannel
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIApplicationCache
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICacheEntryOpenCallback
.
h
"
#
include
"
nsIDNSListener
.
h
"
#
include
"
nsIApplicationCacheChannel
.
h
"
#
include
"
nsIProtocolProxyCallback
.
h
"
#
include
"
nsIHttpAuthenticableChannel
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsIThreadRetargetableStreamListener
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
TimingStruct
.
h
"
#
include
"
AutoClose
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsICorsPreflightCallback
.
h
"
#
include
"
AlternateServices
.
h
"
#
include
"
nsIRaceCacheWithNetwork
.
h
"
#
include
"
mozilla
/
AtomicBitfields
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
extensions
/
PStreamFilterParent
.
h
"
#
include
"
mozilla
/
net
/
DocumentLoadListener
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
class
nsDNSPrefetch
;
class
nsICancelable
;
class
nsIDNSRecord
;
class
nsIDNSHTTPSSVCRecord
;
class
nsIHttpChannelAuthProvider
;
class
nsInputStreamPump
;
class
nsITransportSecurityInfo
;
namespace
mozilla
{
namespace
net
{
class
nsChannelClassifier
;
class
HttpChannelSecurityWarningReporter
;
using
DNSPromise
=
MozPromise
<
nsCOMPtr
<
nsIDNSRecord
>
nsresult
false
>
;
#
define
NS_HTTPCHANNEL_IID
\
{
\
0x301bf95b
0x7bb3
0x4ae1
{
\
0xa9
0x71
0x40
0xbc
0xfa
0x81
0xde
0x12
\
}
\
}
class
nsHttpChannel
final
:
public
HttpBaseChannel
public
HttpAsyncAborter
<
nsHttpChannel
>
public
nsIStreamListener
public
nsICachingChannel
public
nsICacheEntryOpenCallback
public
nsITransportEventSink
public
nsIProtocolProxyCallback
public
nsIHttpAuthenticableChannel
public
nsIAsyncVerifyRedirectCallback
public
nsIThreadRetargetableRequest
public
nsIThreadRetargetableStreamListener
public
nsIDNSListener
public
nsSupportsWeakReference
public
nsICorsPreflightCallback
public
nsIRaceCacheWithNetwork
public
nsIRequestTailUnblockCallback
public
nsITimerCallback
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
NS_DECL_NSICACHEINFOCHANNEL
NS_DECL_NSICACHINGCHANNEL
NS_DECL_NSICACHEENTRYOPENCALLBACK
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSIPROTOCOLPROXYCALLBACK
NS_DECL_NSIPROXIEDCHANNEL
NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
NS_DECL_NSITHREADRETARGETABLEREQUEST
NS_DECL_NSIDNSLISTENER
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_HTTPCHANNEL_IID
)
NS_DECL_NSIRACECACHEWITHNETWORK
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSIREQUESTTAILUNBLOCKCALLBACK
NS_IMETHOD
GetIsSSL
(
bool
*
aIsSSL
)
override
;
NS_IMETHOD
GetProxyMethodIsConnect
(
bool
*
aProxyMethodIsConnect
)
override
;
NS_IMETHOD
GetServerResponseHeader
(
nsACString
&
aServerResponseHeader
)
override
;
NS_IMETHOD
GetProxyChallenges
(
nsACString
&
aChallenges
)
override
;
NS_IMETHOD
GetWWWChallenges
(
nsACString
&
aChallenges
)
override
;
NS_IMETHOD
SetProxyCredentials
(
const
nsACString
&
aCredentials
)
override
;
NS_IMETHOD
SetWWWCredentials
(
const
nsACString
&
aCredentials
)
override
;
NS_IMETHOD
OnAuthAvailable
(
)
override
;
NS_IMETHOD
OnAuthCancelled
(
bool
userCancel
)
override
;
NS_IMETHOD
CloseStickyConnection
(
)
override
;
NS_IMETHOD
ConnectionRestartable
(
bool
)
override
;
NS_IMETHOD
GetLoadFlags
(
nsLoadFlags
*
aLoadFlags
)
override
;
NS_IMETHOD
GetURI
(
nsIURI
*
*
aURI
)
override
;
NS_IMETHOD
GetNotificationCallbacks
(
nsIInterfaceRequestor
*
*
aCallbacks
)
override
;
NS_IMETHOD
GetLoadGroup
(
nsILoadGroup
*
*
aLoadGroup
)
override
;
NS_IMETHOD
GetRequestMethod
(
nsACString
&
aMethod
)
override
;
nsHttpChannel
(
)
;
[
[
nodiscard
]
]
virtual
nsresult
Init
(
nsIURI
*
aURI
uint32_t
aCaps
nsProxyInfo
*
aProxyInfo
uint32_t
aProxyResolveFlags
nsIURI
*
aProxyURI
uint64_t
aChannelId
ExtContentPolicyType
aContentPolicyType
)
override
;
[
[
nodiscard
]
]
nsresult
OnPush
(
uint32_t
aPushedStreamId
const
nsACString
&
aUrl
const
nsACString
&
aRequestString
HttpTransactionShell
*
aTransaction
)
;
static
bool
IsRedirectStatus
(
uint32_t
status
)
;
static
bool
WillRedirect
(
const
nsHttpResponseHead
&
response
)
;
NS_IMETHOD
Cancel
(
nsresult
status
)
override
;
NS_IMETHOD
Suspend
(
)
override
;
NS_IMETHOD
Resume
(
)
override
;
NS_IMETHOD
GetSecurityInfo
(
nsISupports
*
*
aSecurityInfo
)
override
;
NS_IMETHOD
AsyncOpen
(
nsIStreamListener
*
aListener
)
override
;
NS_IMETHOD
GetEncodedBodySize
(
uint64_t
*
aEncodedBodySize
)
override
;
NS_IMETHOD
GetIsAuthChannel
(
bool
*
aIsAuthChannel
)
override
;
NS_IMETHOD
SetChannelIsForDownload
(
bool
aChannelIsForDownload
)
override
;
NS_IMETHOD
GetNavigationStartTimeStamp
(
TimeStamp
*
aTimeStamp
)
override
;
NS_IMETHOD
SetNavigationStartTimeStamp
(
TimeStamp
aTimeStamp
)
override
;
NS_IMETHOD
CancelByURLClassifier
(
nsresult
aErrorCode
)
override
;
NS_IMETHOD
SetPriority
(
int32_t
value
)
override
;
NS_IMETHOD
SetClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
AddClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
ClearClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
ResumeAt
(
uint64_t
startPos
const
nsACString
&
entityID
)
override
;
NS_IMETHOD
SetNotificationCallbacks
(
nsIInterfaceRequestor
*
aCallbacks
)
override
;
NS_IMETHOD
SetLoadGroup
(
nsILoadGroup
*
aLoadGroup
)
override
;
NS_IMETHOD
GetDomainLookupStart
(
mozilla
:
:
TimeStamp
*
aDomainLookupStart
)
override
;
NS_IMETHOD
GetDomainLookupEnd
(
mozilla
:
:
TimeStamp
*
aDomainLookupEnd
)
override
;
NS_IMETHOD
GetConnectStart
(
mozilla
:
:
TimeStamp
*
aConnectStart
)
override
;
NS_IMETHOD
GetTcpConnectEnd
(
mozilla
:
:
TimeStamp
*
aTcpConnectEnd
)
override
;
NS_IMETHOD
GetSecureConnectionStart
(
mozilla
:
:
TimeStamp
*
aSecureConnectionStart
)
override
;
NS_IMETHOD
GetConnectEnd
(
mozilla
:
:
TimeStamp
*
aConnectEnd
)
override
;
NS_IMETHOD
GetRequestStart
(
mozilla
:
:
TimeStamp
*
aRequestStart
)
override
;
NS_IMETHOD
GetResponseStart
(
mozilla
:
:
TimeStamp
*
aResponseStart
)
override
;
NS_IMETHOD
GetResponseEnd
(
mozilla
:
:
TimeStamp
*
aResponseEnd
)
override
;
NS_IMETHOD
OnPreflightSucceeded
(
)
override
;
NS_IMETHOD
OnPreflightFailed
(
nsresult
aError
)
override
;
[
[
nodiscard
]
]
nsresult
AddSecurityMessage
(
const
nsAString
&
aMessageTag
const
nsAString
&
aMessageCategory
)
override
;
NS_IMETHOD
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
override
;
NS_IMETHOD
LogMimeTypeMismatch
(
const
nsACString
&
aMessageName
bool
aWarning
const
nsAString
&
aURL
const
nsAString
&
aContentType
)
override
;
void
SetWarningReporter
(
HttpChannelSecurityWarningReporter
*
aReporter
)
;
HttpChannelSecurityWarningReporter
*
GetWarningReporter
(
)
;
bool
DataSentToChildProcess
(
)
{
return
LoadDataSentToChildProcess
(
)
;
}
enum
class
SnifferType
{
Media
Image
}
;
void
DisableIsOpaqueResponseAllowedAfterSniffCheck
(
SnifferType
aType
)
;
public
:
uint32_t
GetRequestTime
(
)
const
{
return
mRequestTime
;
}
void
AsyncOpenFinal
(
TimeStamp
aTimeStamp
)
;
[
[
nodiscard
]
]
nsresult
OpenCacheEntry
(
bool
usingSSL
)
;
[
[
nodiscard
]
]
nsresult
OpenCacheEntryInternal
(
bool
isHttps
)
;
[
[
nodiscard
]
]
nsresult
ContinueConnect
(
)
;
[
[
nodiscard
]
]
nsresult
StartRedirectChannelToURI
(
nsIURI
*
uint32_t
)
;
SnifferCategoryType
GetSnifferCategoryType
(
)
const
{
return
mSnifferCategoryType
;
}
class
AutoCacheWaitFlags
{
public
:
explicit
AutoCacheWaitFlags
(
nsHttpChannel
*
channel
)
:
mChannel
(
channel
)
mKeep
(
0
)
{
mChannel
-
>
StoreWaitForCacheEntry
(
nsHttpChannel
:
:
WAIT_FOR_CACHE_ENTRY
)
;
}
void
Keep
(
uint32_t
flags
)
{
mKeep
|
=
flags
;
}
~
AutoCacheWaitFlags
(
)
{
mChannel
-
>
StoreWaitForCacheEntry
(
mChannel
-
>
LoadWaitForCacheEntry
(
)
&
mKeep
)
;
}
private
:
nsHttpChannel
*
mChannel
;
uint32_t
mKeep
:
1
;
}
;
bool
AwaitingCacheCallbacks
(
)
;
void
SetCouldBeSynthesized
(
)
;
bool
IsReadingFromCache
(
)
const
{
return
mIsReadingFromCache
;
}
base
:
:
ProcessId
ProcessId
(
)
;
using
ChildEndpointPromise
=
MozPromise
<
mozilla
:
:
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterChild
>
bool
true
>
;
[
[
nodiscard
]
]
RefPtr
<
ChildEndpointPromise
>
AttachStreamFilter
(
base
:
:
ProcessId
aChildProcessId
)
;
private
:
RefPtr
<
TransactionObserver
>
mTransactionObserver
;
public
:
void
SetConnectionInfo
(
nsHttpConnectionInfo
*
)
;
void
SetTransactionObserver
(
TransactionObserver
*
arg
)
{
mTransactionObserver
=
arg
;
}
TransactionObserver
*
GetTransactionObserver
(
)
{
return
mTransactionObserver
;
}
CacheDisposition
mCacheDisposition
;
protected
:
virtual
~
nsHttpChannel
(
)
;
private
:
typedef
nsresult
(
nsHttpChannel
:
:
*
nsContinueRedirectionFunc
)
(
nsresult
result
)
;
nsresult
CallOrWaitForResume
(
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
)
>
&
aFunc
)
;
bool
RequestIsConditional
(
)
;
void
HandleContinueCancellingByURLClassifier
(
nsresult
aErrorCode
)
;
nsresult
CancelInternal
(
nsresult
status
)
;
void
ContinueCancellingByURLClassifier
(
nsresult
aErrorCode
)
;
void
MaybeResolveProxyAndBeginConnect
(
)
;
nsresult
MaybeStartDNSPrefetch
(
)
;
static
uint16_t
const
DNS_PREFETCH_ORIGIN
=
1
<
<
0
;
static
uint16_t
const
DNS_PREFETCH_PROXY
=
1
<
<
1
;
static
uint16_t
const
DNS_PROXY_IS_HTTP
=
1
<
<
2
;
static
uint16_t
const
DNS_BLOCK_ON_ORIGIN_RESOLVE
=
1
<
<
3
;
uint16_t
GetProxyDNSStrategy
(
)
;
nsresult
BeginConnect
(
)
;
[
[
nodiscard
]
]
nsresult
PrepareToConnect
(
)
;
[
[
nodiscard
]
]
nsresult
OnBeforeConnect
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnBeforeConnect
(
bool
aShouldUpgrade
nsresult
aStatus
bool
aUpgradeWithHTTPSRR
=
false
)
;
nsresult
MaybeUseHTTPSRRForUpgrade
(
bool
aShouldUpgrade
nsresult
aStatus
)
;
void
OnHTTPSRRAvailable
(
nsIDNSHTTPSSVCRecord
*
aRecord
)
;
[
[
nodiscard
]
]
nsresult
Connect
(
)
;
void
SpeculativeConnect
(
)
;
[
[
nodiscard
]
]
nsresult
SetupTransaction
(
)
;
[
[
nodiscard
]
]
nsresult
CallOnStartRequest
(
)
;
[
[
nodiscard
]
]
nsresult
ProcessResponse
(
)
;
void
AsyncContinueProcessResponse
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponse1
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponse2
(
nsresult
)
;
public
:
void
UpdateCacheDisposition
(
bool
aSuccessfulReval
bool
aPartialContentUsed
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponse3
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponse4
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ProcessNormal
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessNormal
(
nsresult
)
;
void
ProcessAltService
(
)
;
bool
ShouldBypassProcessNotModified
(
)
;
[
[
nodiscard
]
]
nsresult
ProcessNotModified
(
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueProcessResponseFunc
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponseAfterNotModified
(
nsresult
aRv
)
;
[
[
nodiscard
]
]
nsresult
AsyncProcessRedirection
(
uint32_t
httpStatus
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessRedirection
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessRedirectionAfterFallback
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ProcessFailedProxyConnect
(
uint32_t
httpStatus
)
;
void
HandleAsyncAbort
(
)
;
[
[
nodiscard
]
]
nsresult
EnsureAssocReq
(
)
;
void
ProcessSSLInformation
(
)
;
bool
IsHTTPS
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStartRequest1
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStartRequest2
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStartRequest3
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStartRequest4
(
nsresult
)
;
void
OnClassOfServiceUpdated
(
)
;
void
HandleAsyncRedirect
(
)
;
void
HandleAsyncAPIRedirect
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueHandleAsyncRedirect
(
nsresult
)
;
void
HandleAsyncNotModified
(
)
;
void
HandleAsyncFallback
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueHandleAsyncFallback
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
PromptTempRedirect
(
)
;
[
[
nodiscard
]
]
virtual
nsresult
SetupReplacementChannel
(
nsIURI
*
nsIChannel
*
bool
preserveMethod
uint32_t
redirectFlags
)
override
;
[
[
nodiscard
]
]
nsresult
ProxyFailover
(
)
;
[
[
nodiscard
]
]
nsresult
AsyncDoReplaceWithProxy
(
nsIProxyInfo
*
)
;
[
[
nodiscard
]
]
nsresult
ContinueDoReplaceWithProxy
(
nsresult
)
;
[
[
nodiscard
]
]
nsresult
ResolveProxy
(
)
;
[
[
nodiscard
]
]
nsresult
OnNormalCacheEntryAvailable
(
nsICacheEntry
*
aEntry
bool
aNew
nsresult
aResult
)
;
[
[
nodiscard
]
]
nsresult
OnCacheEntryAvailableInternal
(
nsICacheEntry
*
entry
bool
aNew
nsIApplicationCache
*
aAppCache
nsresult
status
)
;
[
[
nodiscard
]
]
nsresult
GenerateCacheKey
(
uint32_t
postID
nsACString
&
key
)
;
[
[
nodiscard
]
]
nsresult
UpdateExpirationTime
(
)
;
[
[
nodiscard
]
]
nsresult
CheckPartial
(
nsICacheEntry
*
aEntry
int64_t
*
aSize
int64_t
*
aContentLength
)
;
[
[
nodiscard
]
]
nsresult
ReadFromCache
(
bool
alreadyMarkedValid
)
;
void
CloseCacheEntry
(
bool
doomOnFailure
)
;
[
[
nodiscard
]
]
nsresult
InitCacheEntry
(
)
;
void
UpdateInhibitPersistentCachingFlag
(
)
;
[
[
nodiscard
]
]
nsresult
AddCacheEntryHeaders
(
nsICacheEntry
*
entry
)
;
[
[
nodiscard
]
]
nsresult
FinalizeCacheEntry
(
)
;
[
[
nodiscard
]
]
nsresult
InstallCacheListener
(
int64_t
offset
=
0
)
;
void
MaybeInvalidateCacheEntryForSubsequentGet
(
)
;
void
AsyncOnExamineCachedResponse
(
)
;
void
ClearBogusContentEncodingIfNeeded
(
)
;
[
[
nodiscard
]
]
nsresult
ProcessPartialContent
(
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueProcessResponseFunc
)
;
[
[
nodiscard
]
]
nsresult
ContinueProcessResponseAfterPartialContent
(
nsresult
aRv
)
;
[
[
nodiscard
]
]
nsresult
OnDoneReadingPartialCacheEntry
(
bool
*
streamDone
)
;
[
[
nodiscard
]
]
nsresult
DoAuthRetry
(
HttpTransactionShell
*
aTransWithStickyConn
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueOnStopRequestFunc
)
;
[
[
nodiscard
]
]
nsresult
ContinueDoAuthRetry
(
HttpTransactionShell
*
aTransWithStickyConn
const
std
:
:
function
<
nsresult
(
nsHttpChannel
*
nsresult
)
>
&
aContinueOnStopRequestFunc
)
;
[
[
nodiscard
]
]
MOZ_NEVER_INLINE
nsresult
DoConnect
(
HttpTransactionShell
*
aTransWithStickyConn
=
nullptr
)
;
[
[
nodiscard
]
]
nsresult
DoConnectActual
(
HttpTransactionShell
*
aTransWithStickyConn
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStopRequestAfterAuthRetry
(
nsresult
aStatus
bool
aAuthRetry
bool
aIsFromNet
bool
aContentComplete
HttpTransactionShell
*
aTransWithStickyConn
)
;
[
[
nodiscard
]
]
nsresult
ContinueOnStopRequest
(
nsresult
status
bool
aIsFromNet
bool
aContentComplete
)
;
void
HandleAsyncRedirectChannelToHttps
(
)
;
[
[
nodiscard
]
]
nsresult
StartRedirectChannelToHttps
(
)
;
[
[
nodiscard
]
]
nsresult
ContinueAsyncRedirectChannelToURI
(
nsresult
rv
)
;
[
[
nodiscard
]
]
nsresult
OpenRedirectChannel
(
nsresult
rv
)
;
HttpTrafficCategory
CreateTrafficCategory
(
)
;
[
[
nodiscard
]
]
nsresult
ProcessSecurityHeaders
(
)
;
[
[
nodiscard
]
]
nsresult
ProcessContentSignatureHeader
(
nsHttpResponseHead
*
aResponseHead
)
;
[
[
nodiscard
]
]
nsresult
ProcessSingleSecurityHeader
(
uint32_t
aType
nsITransportSecurityInfo
*
aSecInfo
uint32_t
aFlags
)
;
void
InvalidateCacheEntryForLocation
(
const
char
*
location
)
;
void
AssembleCacheKey
(
const
char
*
spec
uint32_t
postID
nsACString
&
key
)
;
[
[
nodiscard
]
]
nsresult
CreateNewURI
(
const
char
*
loc
nsIURI
*
*
newURI
)
;
void
DoInvalidateCacheEntry
(
nsIURI
*
aURI
)
;
inline
bool
HostPartIsTheSame
(
nsIURI
*
uri
)
{
nsAutoCString
tmpHost1
tmpHost2
;
return
(
NS_SUCCEEDED
(
mURI
-
>
GetAsciiHost
(
tmpHost1
)
)
&
&
NS_SUCCEEDED
(
uri
-
>
GetAsciiHost
(
tmpHost2
)
)
&
&
(
tmpHost1
=
=
tmpHost2
)
)
;
}
inline
static
bool
DoNotRender3xxBody
(
nsresult
rv
)
{
return
rv
=
=
NS_ERROR_REDIRECT_LOOP
|
|
rv
=
=
NS_ERROR_CORRUPTED_CONTENT
|
|
rv
=
=
NS_ERROR_UNKNOWN_PROTOCOL
|
|
rv
=
=
NS_ERROR_MALFORMED_URI
|
|
rv
=
=
NS_ERROR_PORT_ACCESS_NOT_ALLOWED
;
}
void
ReportNetVSCacheTelemetry
(
)
;
int64_t
ComputeTelemetryBucketNumber
(
int64_t
difftime_ms
)
;
void
ReportRcwnStats
(
bool
isFromNet
)
;
void
UpdateAggregateCallbacks
(
)
;
static
bool
HasQueryString
(
nsHttpRequestHead
:
:
ParsedMethodType
method
nsIURI
*
uri
)
;
bool
ResponseWouldVary
(
nsICacheEntry
*
entry
)
;
bool
IsResumable
(
int64_t
partialLen
int64_t
contentLength
bool
ignoreMissingPartialLen
=
false
)
const
;
[
[
nodiscard
]
]
nsresult
MaybeSetupByteRangeRequest
(
int64_t
partialLen
int64_t
contentLength
bool
ignoreMissingPartialLen
=
false
)
;
[
[
nodiscard
]
]
nsresult
SetupByteRangeRequest
(
int64_t
partialLen
)
;
void
UntieByteRangeRequest
(
)
;
void
UntieValidationRequest
(
)
;
[
[
nodiscard
]
]
nsresult
OpenCacheInputStream
(
nsICacheEntry
*
cacheEntry
bool
startBuffering
bool
checkingAppCacheEntry
)
;
void
SetPushedStreamTransactionAndId
(
HttpTransactionShell
*
aTransWithPushedStream
uint32_t
aPushedStreamId
)
;
void
SetOriginHeader
(
)
;
void
SetDoNotTrack
(
)
;
already_AddRefed
<
nsChannelClassifier
>
GetOrCreateChannelClassifier
(
)
;
[
[
nodiscard
]
]
nsresult
RedirectToInterceptedChannel
(
)
;
void
SetCachedContentType
(
)
;
private
:
nsCOMPtr
<
nsIHttpChannelAuthProvider
>
mAuthProvider
;
nsCOMPtr
<
nsIURI
>
mRedirectURI
;
nsCOMPtr
<
nsIChannel
>
mRedirectChannel
;
nsCOMPtr
<
nsIChannel
>
mPreflightChannel
;
RefPtr
<
nsChannelClassifier
>
mChannelClassifier
;
void
ReleaseMainThreadOnlyReferences
(
)
;
void
ReEvaluateReferrerAfterTrackingStatusIsKnown
(
)
;
void
PerformBackgroundCacheRevalidation
(
)
;
void
PerformBackgroundCacheRevalidationNow
(
)
;
private
:
nsCOMPtr
<
nsICancelable
>
mProxyRequest
;
nsCOMPtr
<
nsIRequest
>
mTransactionPump
;
RefPtr
<
HttpTransactionShell
>
mTransaction
;
uint64_t
mLogicalOffset
;
nsCOMPtr
<
nsICacheEntry
>
mCacheEntry
;
nsCOMPtr
<
nsICacheEntry
>
mAltDataCacheEntry
;
nsCOMPtr
<
nsIURI
>
mCacheEntryURI
;
nsCString
mCacheIdExtension
;
AutoClose
<
nsIInputStream
>
mCacheInputStream
;
RefPtr
<
nsInputStreamPump
>
mCachePump
;
UniquePtr
<
nsHttpResponseHead
>
mCachedResponseHead
;
nsCOMPtr
<
nsISupports
>
mCachedSecurityInfo
;
uint32_t
mPostID
;
uint32_t
mRequestTime
;
nsTArray
<
StreamFilterRequest
>
mStreamFilterRequests
;
mozilla
:
:
TimeStamp
mOnStartRequestTimestamp
;
mozilla
:
:
TimeStamp
mSuspendTimestamp
;
mozilla
:
:
TimeStamp
mOnCacheEntryCheckTimestamp
;
#
ifdef
MOZ_GECKO_PROFILER
mozilla
:
:
TimeStamp
mLastStatusReported
;
#
endif
uint32_t
mSuspendTotalTime
;
friend
class
AutoRedirectVetoNotifier
;
friend
class
HttpAsyncAborter
<
nsHttpChannel
>
;
uint32_t
mRedirectType
;
static
const
uint32_t
WAIT_FOR_CACHE_ENTRY
=
1
;
bool
mCacheOpenWithPriority
;
uint32_t
mCacheQueueSizeWhenOpen
;
Atomic
<
bool
Relaxed
>
mCachedContentIsValid
;
Atomic
<
bool
>
mIsAuthChannel
;
Atomic
<
bool
>
mAuthRetryPending
;
MOZ_ATOMIC_BITFIELDS
(
mAtomicBitfields5
32
(
(
uint32_t
CachedContentIsPartial
1
)
(
uint32_t
CacheOnlyMetadata
1
)
(
uint32_t
TransactionReplaced
1
)
(
uint32_t
ProxyAuthPending
1
)
(
uint32_t
CustomAuthHeader
1
)
(
uint32_t
Resuming
1
)
(
uint32_t
InitedCacheEntry
1
)
(
uint32_t
CustomConditionalRequest
1
)
(
uint32_t
WaitingForRedirectCallback
1
)
(
uint32_t
RequestTimeInitialized
1
)
(
uint32_t
CacheEntryIsReadOnly
1
)
(
uint32_t
CacheEntryIsWriteOnly
1
)
(
uint32_t
WaitForCacheEntry
1
)
(
uint32_t
ConcurrentCacheAccess
1
)
(
uint32_t
IsPartialRequest
1
)
(
uint32_t
HasAutoRedirectVetoNotifier
1
)
(
uint32_t
PinCacheContent
1
)
(
uint32_t
IsCorsPreflightDone
1
)
(
uint32_t
StronglyFramed
1
)
(
uint32_t
UsedNetwork
1
)
(
uint32_t
AuthConnectionRestartable
1
)
(
uint32_t
ChannelClassifierCancellationPending
1
)
(
uint32_t
AsyncResumePending
1
)
(
uint32_t
DataSentToChildProcess
1
)
(
uint32_t
UseHTTPSSVC
1
)
(
uint32_t
WaitHTTPSSVCRecord
1
)
)
)
MOZ_ATOMIC_BITFIELDS
(
mAtomicBitfields6
32
(
(
uint32_t
HTTPSSVCTelemetryReported
1
)
(
uint32_t
EchConfigUsed
1
)
)
)
nsTArray
<
nsContinueRedirectionFunc
>
mRedirectFuncStack
;
RefPtr
<
nsDNSPrefetch
>
mDNSPrefetch
;
uint32_t
mPushedStreamId
;
RefPtr
<
HttpTransactionShell
>
mTransWithPushedStream
;
bool
mLocalBlocklist
;
[
[
nodiscard
]
]
nsresult
WaitForRedirectCallback
(
)
;
void
PushRedirectAsyncFunc
(
nsContinueRedirectionFunc
func
)
;
void
PopRedirectAsyncFunc
(
nsContinueRedirectionFunc
func
)
;
bool
EligibleForTailing
(
)
;
bool
WaitingForTailUnblock
(
)
;
nsresult
(
nsHttpChannel
:
:
*
mOnTailUnblock
)
(
)
;
nsresult
AsyncOpenOnTailUnblock
(
)
;
nsresult
ConnectOnTailUnblock
(
)
;
nsCString
mUsername
;
RefPtr
<
HttpChannelSecurityWarningReporter
>
mWarningReporter
;
Atomic
<
bool
>
mIsReadingFromCache
;
nsCOMPtr
<
nsITimer
>
mCacheOpenTimer
;
std
:
:
function
<
void
(
nsHttpChannel
*
)
>
mCacheOpenFunc
;
uint32_t
mCacheOpenDelay
=
0
;
enum
ResponseSource
{
RESPONSE_PENDING
=
0
RESPONSE_FROM_CACHE
=
1
RESPONSE_FROM_NETWORK
=
2
}
;
Atomic
<
ResponseSource
Relaxed
>
mFirstResponseSource
;
void
MaybeRaceCacheWithNetwork
(
)
;
void
MaybeCreateCacheEntryWhenRCWN
(
)
;
nsresult
TriggerNetworkWithDelay
(
uint32_t
aDelay
)
;
nsresult
TriggerNetwork
(
)
;
void
CancelNetworkRequest
(
nsresult
aStatus
)
;
void
SetHTTPSSVCRecord
(
already_AddRefed
<
nsIDNSHTTPSSVCRecord
>
&
&
aRecord
)
;
nsCOMPtr
<
nsITimer
>
mNetworkTriggerTimer
;
bool
mNetworkTriggered
=
false
;
bool
mWaitingForProxy
=
false
;
bool
mStaleRevalidation
=
false
;
Atomic
<
bool
>
mRaceCacheWithNetwork
;
uint32_t
mRaceDelay
;
bool
mIgnoreCacheEntry
;
mozilla
:
:
Mutex
mRCWNLock
;
TimeStamp
mNavigationStartTimeStamp
;
MozPromiseHolder
<
DNSPromise
>
mDNSBlockingPromise
;
RefPtr
<
DNSPromise
>
mDNSBlockingThenable
;
int32_t
mProxyConnectResponseCode
;
Maybe
<
nsCOMPtr
<
nsIDNSHTTPSSVCRecord
>
>
mHTTPSSVCRecord
;
protected
:
virtual
void
DoNotifyListenerCleanup
(
)
override
;
virtual
void
ReleaseListeners
(
)
override
;
virtual
void
DoAsyncAbort
(
nsresult
aStatus
)
override
;
private
:
bool
mDidReval
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsHttpChannel
NS_HTTPCHANNEL_IID
)
}
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
net
:
:
nsHttpChannel
*
aChannel
)
{
return
static_cast
<
nsIHttpChannel
*
>
(
aChannel
)
;
}
#
endif
