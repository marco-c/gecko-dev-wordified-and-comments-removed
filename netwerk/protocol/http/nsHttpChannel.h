#
ifndef
nsHttpChannel_h__
#
define
nsHttpChannel_h__
#
include
"
HttpBaseChannel
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsICacheEntryOpenCallback
.
h
"
#
include
"
nsIDNSListener
.
h
"
#
include
"
nsIApplicationCacheChannel
.
h
"
#
include
"
nsIChannelWithDivertableParentListener
.
h
"
#
include
"
nsIProtocolProxyCallback
.
h
"
#
include
"
nsIStreamTransportService
.
h
"
#
include
"
nsIHttpAuthenticableChannel
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsIThreadRetargetableStreamListener
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
TimingStruct
.
h
"
#
include
"
ADivertableParentChannel
.
h
"
#
include
"
AutoClose
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsICorsPreflightCallback
.
h
"
#
include
"
AlternateServices
.
h
"
#
include
"
nsIHstsPrimingCallback
.
h
"
#
include
"
nsIRaceCacheWithNetwork
.
h
"
class
nsDNSPrefetch
;
class
nsICancelable
;
class
nsIHttpChannelAuthProvider
;
class
nsInputStreamPump
;
class
nsISSLStatus
;
namespace
mozilla
{
namespace
net
{
class
nsChannelClassifier
;
class
Http2PushedStream
;
class
HttpChannelSecurityWarningReporter
{
public
:
virtual
MOZ_MUST_USE
nsresult
ReportSecurityMessage
(
const
nsAString
&
aMessageTag
const
nsAString
&
aMessageCategory
)
=
0
;
}
;
#
define
NS_HTTPCHANNEL_IID
\
{
\
0x301bf95b
\
0x7bb3
\
0x4ae1
\
{
0xa9
0x71
0x40
0xbc
0xfa
0x81
0xde
0x12
}
\
}
class
nsHttpChannel
final
:
public
HttpBaseChannel
public
HttpAsyncAborter
<
nsHttpChannel
>
public
nsIStreamListener
public
nsICachingChannel
public
nsICacheEntryOpenCallback
public
nsITransportEventSink
public
nsIProtocolProxyCallback
public
nsIInputAvailableCallback
public
nsIHttpAuthenticableChannel
public
nsIApplicationCacheChannel
public
nsIAsyncVerifyRedirectCallback
public
nsIThreadRetargetableRequest
public
nsIThreadRetargetableStreamListener
public
nsIDNSListener
public
nsSupportsWeakReference
public
nsICorsPreflightCallback
public
nsIChannelWithDivertableParentListener
public
nsIHstsPrimingCallback
public
nsIRaceCacheWithNetwork
public
nsITimerCallback
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
NS_DECL_NSICACHEINFOCHANNEL
NS_DECL_NSICACHINGCHANNEL
NS_DECL_NSICACHEENTRYOPENCALLBACK
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSIPROTOCOLPROXYCALLBACK
NS_DECL_NSIINPUTAVAILABLECALLBACK
NS_DECL_NSIPROXIEDCHANNEL
NS_DECL_NSIAPPLICATIONCACHECONTAINER
NS_DECL_NSIAPPLICATIONCACHECHANNEL
NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
NS_DECL_NSIHSTSPRIMINGCALLBACK
NS_DECL_NSITHREADRETARGETABLEREQUEST
NS_DECL_NSIDNSLISTENER
NS_DECL_NSICHANNELWITHDIVERTABLEPARENTLISTENER
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_HTTPCHANNEL_IID
)
NS_DECL_NSIRACECACHEWITHNETWORK
NS_DECL_NSITIMERCALLBACK
NS_IMETHOD
GetIsSSL
(
bool
*
aIsSSL
)
override
;
NS_IMETHOD
GetProxyMethodIsConnect
(
bool
*
aProxyMethodIsConnect
)
override
;
NS_IMETHOD
GetServerResponseHeader
(
nsACString
&
aServerResponseHeader
)
override
;
NS_IMETHOD
GetProxyChallenges
(
nsACString
&
aChallenges
)
override
;
NS_IMETHOD
GetWWWChallenges
(
nsACString
&
aChallenges
)
override
;
NS_IMETHOD
SetProxyCredentials
(
const
nsACString
&
aCredentials
)
override
;
NS_IMETHOD
SetWWWCredentials
(
const
nsACString
&
aCredentials
)
override
;
NS_IMETHOD
OnAuthAvailable
(
)
override
;
NS_IMETHOD
OnAuthCancelled
(
bool
userCancel
)
override
;
NS_IMETHOD
CloseStickyConnection
(
)
override
;
NS_IMETHOD
ConnectionRestartable
(
bool
)
override
;
NS_IMETHOD
GetLoadFlags
(
nsLoadFlags
*
aLoadFlags
)
override
;
NS_IMETHOD
GetURI
(
nsIURI
*
*
aURI
)
override
;
NS_IMETHOD
GetNotificationCallbacks
(
nsIInterfaceRequestor
*
*
aCallbacks
)
override
;
NS_IMETHOD
GetLoadGroup
(
nsILoadGroup
*
*
aLoadGroup
)
override
;
NS_IMETHOD
GetRequestMethod
(
nsACString
&
aMethod
)
override
;
nsHttpChannel
(
)
;
virtual
MOZ_MUST_USE
nsresult
Init
(
nsIURI
*
aURI
uint32_t
aCaps
nsProxyInfo
*
aProxyInfo
uint32_t
aProxyResolveFlags
nsIURI
*
aProxyURI
uint64_t
aChannelId
)
override
;
MOZ_MUST_USE
nsresult
OnPush
(
const
nsACString
&
uri
Http2PushedStream
*
pushedStream
)
;
static
bool
IsRedirectStatus
(
uint32_t
status
)
;
static
bool
WillRedirect
(
nsHttpResponseHead
*
response
)
;
NS_IMETHOD
Cancel
(
nsresult
status
)
override
;
NS_IMETHOD
Suspend
(
)
override
;
NS_IMETHOD
Resume
(
)
override
;
NS_IMETHOD
GetSecurityInfo
(
nsISupports
*
*
aSecurityInfo
)
override
;
NS_IMETHOD
AsyncOpen
(
nsIStreamListener
*
listener
nsISupports
*
aContext
)
override
;
NS_IMETHOD
AsyncOpen2
(
nsIStreamListener
*
aListener
)
override
;
NS_IMETHOD
GetEncodedBodySize
(
uint64_t
*
aEncodedBodySize
)
override
;
NS_IMETHOD
SetupFallbackChannel
(
const
char
*
aFallbackKey
)
override
;
NS_IMETHOD
ForceIntercepted
(
uint64_t
aInterceptionID
)
override
;
NS_IMETHOD
SetChannelIsForDownload
(
bool
aChannelIsForDownload
)
override
;
NS_IMETHOD
SetPriority
(
int32_t
value
)
override
;
NS_IMETHOD
SetClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
AddClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
ClearClassFlags
(
uint32_t
inFlags
)
override
;
NS_IMETHOD
ResumeAt
(
uint64_t
startPos
const
nsACString
&
entityID
)
override
;
NS_IMETHOD
SetNotificationCallbacks
(
nsIInterfaceRequestor
*
aCallbacks
)
override
;
NS_IMETHOD
SetLoadGroup
(
nsILoadGroup
*
aLoadGroup
)
override
;
NS_IMETHOD
GetDomainLookupStart
(
mozilla
:
:
TimeStamp
*
aDomainLookupStart
)
override
;
NS_IMETHOD
GetDomainLookupEnd
(
mozilla
:
:
TimeStamp
*
aDomainLookupEnd
)
override
;
NS_IMETHOD
GetConnectStart
(
mozilla
:
:
TimeStamp
*
aConnectStart
)
override
;
NS_IMETHOD
GetConnectEnd
(
mozilla
:
:
TimeStamp
*
aConnectEnd
)
override
;
NS_IMETHOD
GetRequestStart
(
mozilla
:
:
TimeStamp
*
aRequestStart
)
override
;
NS_IMETHOD
GetResponseStart
(
mozilla
:
:
TimeStamp
*
aResponseStart
)
override
;
NS_IMETHOD
GetResponseEnd
(
mozilla
:
:
TimeStamp
*
aResponseEnd
)
override
;
NS_IMETHOD
OnPreflightSucceeded
(
)
override
;
NS_IMETHOD
OnPreflightFailed
(
nsresult
aError
)
override
;
MOZ_MUST_USE
nsresult
AddSecurityMessage
(
const
nsAString
&
aMessageTag
const
nsAString
&
aMessageCategory
)
override
;
void
SetWarningReporter
(
HttpChannelSecurityWarningReporter
*
aReporter
)
{
mWarningReporter
=
aReporter
;
}
public
:
using
InitLocalBlockListCallback
=
std
:
:
function
<
void
(
bool
)
>
;
void
InternalSetUploadStream
(
nsIInputStream
*
uploadStream
)
{
mUploadStream
=
uploadStream
;
}
void
SetUploadStreamHasHeaders
(
bool
hasHeaders
)
{
mUploadStreamHasHeaders
=
hasHeaders
;
}
MOZ_MUST_USE
nsresult
SetReferrerWithPolicyInternal
(
nsIURI
*
referrer
uint32_t
referrerPolicy
)
{
nsAutoCString
spec
;
nsresult
rv
=
referrer
-
>
GetAsciiSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mReferrer
=
referrer
;
mReferrerPolicy
=
referrerPolicy
;
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
Referer
spec
)
;
return
rv
;
}
MOZ_MUST_USE
nsresult
SetTopWindowURI
(
nsIURI
*
aTopWindowURI
)
{
mTopWindowURI
=
aTopWindowURI
;
return
NS_OK
;
}
uint32_t
GetRequestTime
(
)
const
{
return
mRequestTime
;
}
MOZ_MUST_USE
nsresult
OpenCacheEntry
(
bool
usingSSL
)
;
MOZ_MUST_USE
nsresult
ContinueConnect
(
)
;
MOZ_MUST_USE
nsresult
TryHSTSPriming
(
)
;
MOZ_MUST_USE
nsresult
StartRedirectChannelToURI
(
nsIURI
*
uint32_t
)
;
class
OfflineCacheEntryAsForeignMarker
{
nsCOMPtr
<
nsIApplicationCache
>
mApplicationCache
;
nsCOMPtr
<
nsIURI
>
mCacheURI
;
public
:
OfflineCacheEntryAsForeignMarker
(
nsIApplicationCache
*
appCache
nsIURI
*
aURI
)
:
mApplicationCache
(
appCache
)
mCacheURI
(
aURI
)
{
}
nsresult
MarkAsForeign
(
)
;
}
;
OfflineCacheEntryAsForeignMarker
*
GetOfflineCacheEntryAsForeignMarker
(
)
;
class
AutoCacheWaitFlags
{
public
:
explicit
AutoCacheWaitFlags
(
nsHttpChannel
*
channel
)
:
mChannel
(
channel
)
mKeep
(
0
)
{
mChannel
-
>
mCacheEntriesToWaitFor
=
nsHttpChannel
:
:
WAIT_FOR_CACHE_ENTRY
|
nsHttpChannel
:
:
WAIT_FOR_OFFLINE_CACHE_ENTRY
;
}
void
Keep
(
uint32_t
flags
)
{
mKeep
|
=
flags
;
}
~
AutoCacheWaitFlags
(
)
{
mChannel
-
>
mCacheEntriesToWaitFor
&
=
mKeep
;
}
private
:
nsHttpChannel
*
mChannel
;
uint32_t
mKeep
:
2
;
}
;
void
MarkIntercepted
(
)
;
NS_IMETHOD
GetResponseSynthesized
(
bool
*
aSynthesized
)
override
;
bool
AwaitingCacheCallbacks
(
)
;
void
SetCouldBeSynthesized
(
)
;
bool
IsReadingFromCache
(
)
const
{
return
mIsReadingFromCache
;
}
private
:
RefPtr
<
TransactionObserver
>
mTransactionObserver
;
public
:
void
SetConnectionInfo
(
nsHttpConnectionInfo
*
)
;
void
SetTransactionObserver
(
TransactionObserver
*
arg
)
{
mTransactionObserver
=
arg
;
}
TransactionObserver
*
GetTransactionObserver
(
)
{
return
mTransactionObserver
;
}
protected
:
virtual
~
nsHttpChannel
(
)
;
private
:
typedef
nsresult
(
nsHttpChannel
:
:
*
nsContinueRedirectionFunc
)
(
nsresult
result
)
;
bool
RequestIsConditional
(
)
;
nsresult
BeginConnectActual
(
)
;
nsresult
BeginConnect
(
)
;
void
HandleBeginConnectContinue
(
)
;
MOZ_MUST_USE
nsresult
BeginConnectContinue
(
)
;
MOZ_MUST_USE
nsresult
ContinueBeginConnectWithResult
(
)
;
void
ContinueBeginConnect
(
)
;
MOZ_MUST_USE
nsresult
Connect
(
)
;
void
SpeculativeConnect
(
)
;
MOZ_MUST_USE
nsresult
SetupTransaction
(
)
;
void
SetupTransactionRequestContext
(
)
;
MOZ_MUST_USE
nsresult
CallOnStartRequest
(
)
;
MOZ_MUST_USE
nsresult
ProcessResponse
(
)
;
void
AsyncContinueProcessResponse
(
)
;
MOZ_MUST_USE
nsresult
ContinueProcessResponse1
(
)
;
MOZ_MUST_USE
nsresult
ContinueProcessResponse2
(
nsresult
)
;
MOZ_MUST_USE
nsresult
ContinueProcessResponse3
(
nsresult
)
;
MOZ_MUST_USE
nsresult
ProcessNormal
(
)
;
MOZ_MUST_USE
nsresult
ContinueProcessNormal
(
nsresult
)
;
void
ProcessAltService
(
)
;
bool
ShouldBypassProcessNotModified
(
)
;
MOZ_MUST_USE
nsresult
ProcessNotModified
(
)
;
MOZ_MUST_USE
nsresult
AsyncProcessRedirection
(
uint32_t
httpStatus
)
;
MOZ_MUST_USE
nsresult
ContinueProcessRedirection
(
nsresult
)
;
MOZ_MUST_USE
nsresult
ContinueProcessRedirectionAfterFallback
(
nsresult
)
;
MOZ_MUST_USE
nsresult
ProcessFailedProxyConnect
(
uint32_t
httpStatus
)
;
MOZ_MUST_USE
nsresult
ProcessFallback
(
bool
*
waitingForRedirectCallback
)
;
MOZ_MUST_USE
nsresult
ContinueProcessFallback
(
nsresult
)
;
void
HandleAsyncAbort
(
)
;
MOZ_MUST_USE
nsresult
EnsureAssocReq
(
)
;
void
ProcessSSLInformation
(
)
;
bool
IsHTTPS
(
)
;
MOZ_MUST_USE
nsresult
ContinueOnStartRequest1
(
nsresult
)
;
MOZ_MUST_USE
nsresult
ContinueOnStartRequest2
(
nsresult
)
;
MOZ_MUST_USE
nsresult
ContinueOnStartRequest3
(
nsresult
)
;
void
OnClassOfServiceUpdated
(
)
;
bool
InitLocalBlockList
(
const
InitLocalBlockListCallback
&
aCallback
)
;
void
HandleAsyncRedirect
(
)
;
void
HandleAsyncAPIRedirect
(
)
;
MOZ_MUST_USE
nsresult
ContinueHandleAsyncRedirect
(
nsresult
)
;
void
HandleAsyncNotModified
(
)
;
void
HandleAsyncFallback
(
)
;
MOZ_MUST_USE
nsresult
ContinueHandleAsyncFallback
(
nsresult
)
;
MOZ_MUST_USE
nsresult
PromptTempRedirect
(
)
;
virtual
MOZ_MUST_USE
nsresult
SetupReplacementChannel
(
nsIURI
*
nsIChannel
*
bool
preserveMethod
uint32_t
redirectFlags
)
override
;
MOZ_MUST_USE
nsresult
ProxyFailover
(
)
;
MOZ_MUST_USE
nsresult
AsyncDoReplaceWithProxy
(
nsIProxyInfo
*
)
;
MOZ_MUST_USE
nsresult
ContinueDoReplaceWithProxy
(
nsresult
)
;
MOZ_MUST_USE
nsresult
ResolveProxy
(
)
;
MOZ_MUST_USE
nsresult
OnOfflineCacheEntryAvailable
(
nsICacheEntry
*
aEntry
bool
aNew
nsIApplicationCache
*
aAppCache
nsresult
aResult
)
;
MOZ_MUST_USE
nsresult
OnNormalCacheEntryAvailable
(
nsICacheEntry
*
aEntry
bool
aNew
nsresult
aResult
)
;
MOZ_MUST_USE
nsresult
OpenOfflineCacheEntryForWriting
(
)
;
MOZ_MUST_USE
nsresult
OnOfflineCacheEntryForWritingAvailable
(
nsICacheEntry
*
aEntry
nsIApplicationCache
*
aAppCache
nsresult
aResult
)
;
MOZ_MUST_USE
nsresult
OnCacheEntryAvailableInternal
(
nsICacheEntry
*
entry
bool
aNew
nsIApplicationCache
*
aAppCache
nsresult
status
)
;
MOZ_MUST_USE
nsresult
GenerateCacheKey
(
uint32_t
postID
nsACString
&
key
)
;
MOZ_MUST_USE
nsresult
UpdateExpirationTime
(
)
;
MOZ_MUST_USE
nsresult
CheckPartial
(
nsICacheEntry
*
aEntry
int64_t
*
aSize
int64_t
*
aContentLength
)
;
bool
ShouldUpdateOfflineCacheEntry
(
)
;
MOZ_MUST_USE
nsresult
ReadFromCache
(
bool
alreadyMarkedValid
)
;
void
CloseCacheEntry
(
bool
doomOnFailure
)
;
void
CloseOfflineCacheEntry
(
)
;
MOZ_MUST_USE
nsresult
InitCacheEntry
(
)
;
void
UpdateInhibitPersistentCachingFlag
(
)
;
MOZ_MUST_USE
nsresult
InitOfflineCacheEntry
(
)
;
MOZ_MUST_USE
nsresult
AddCacheEntryHeaders
(
nsICacheEntry
*
entry
)
;
MOZ_MUST_USE
nsresult
FinalizeCacheEntry
(
)
;
MOZ_MUST_USE
nsresult
InstallCacheListener
(
int64_t
offset
=
0
)
;
MOZ_MUST_USE
nsresult
InstallOfflineCacheListener
(
int64_t
offset
=
0
)
;
void
MaybeInvalidateCacheEntryForSubsequentGet
(
)
;
void
AsyncOnExamineCachedResponse
(
)
;
void
ClearBogusContentEncodingIfNeeded
(
)
;
MOZ_MUST_USE
nsresult
ProcessPartialContent
(
)
;
MOZ_MUST_USE
nsresult
OnDoneReadingPartialCacheEntry
(
bool
*
streamDone
)
;
MOZ_MUST_USE
nsresult
DoAuthRetry
(
nsAHttpConnection
*
)
;
void
HandleAsyncRedirectChannelToHttps
(
)
;
MOZ_MUST_USE
nsresult
StartRedirectChannelToHttps
(
)
;
MOZ_MUST_USE
nsresult
ContinueAsyncRedirectChannelToURI
(
nsresult
rv
)
;
MOZ_MUST_USE
nsresult
OpenRedirectChannel
(
nsresult
rv
)
;
void
DetermineContentLength
(
)
;
MOZ_MUST_USE
nsresult
ProcessSecurityHeaders
(
)
;
MOZ_MUST_USE
nsresult
ProcessContentSignatureHeader
(
nsHttpResponseHead
*
aResponseHead
)
;
void
ProcessSecurityReport
(
nsresult
status
)
;
MOZ_MUST_USE
nsresult
ProcessSingleSecurityHeader
(
uint32_t
aType
nsISSLStatus
*
aSSLStatus
uint32_t
aFlags
)
;
void
InvalidateCacheEntryForLocation
(
const
char
*
location
)
;
void
AssembleCacheKey
(
const
char
*
spec
uint32_t
postID
nsACString
&
key
)
;
MOZ_MUST_USE
nsresult
CreateNewURI
(
const
char
*
loc
nsIURI
*
*
newURI
)
;
void
DoInvalidateCacheEntry
(
nsIURI
*
aURI
)
;
inline
bool
HostPartIsTheSame
(
nsIURI
*
uri
)
{
nsAutoCString
tmpHost1
tmpHost2
;
return
(
NS_SUCCEEDED
(
mURI
-
>
GetAsciiHost
(
tmpHost1
)
)
&
&
NS_SUCCEEDED
(
uri
-
>
GetAsciiHost
(
tmpHost2
)
)
&
&
(
tmpHost1
=
=
tmpHost2
)
)
;
}
inline
static
bool
DoNotRender3xxBody
(
nsresult
rv
)
{
return
rv
=
=
NS_ERROR_REDIRECT_LOOP
|
|
rv
=
=
NS_ERROR_CORRUPTED_CONTENT
|
|
rv
=
=
NS_ERROR_UNKNOWN_PROTOCOL
|
|
rv
=
=
NS_ERROR_MALFORMED_URI
;
}
void
ReportNetVSCacheTelemetry
(
)
;
int64_t
ComputeTelemetryBucketNumber
(
int64_t
difftime_ms
)
;
void
ReportRcwnStats
(
nsIRequest
*
firstResponseRequest
)
;
void
UpdateAggregateCallbacks
(
)
;
static
bool
HasQueryString
(
nsHttpRequestHead
:
:
ParsedMethodType
method
nsIURI
*
uri
)
;
bool
ResponseWouldVary
(
nsICacheEntry
*
entry
)
;
bool
IsResumable
(
int64_t
partialLen
int64_t
contentLength
bool
ignoreMissingPartialLen
=
false
)
const
;
MOZ_MUST_USE
nsresult
MaybeSetupByteRangeRequest
(
int64_t
partialLen
int64_t
contentLength
bool
ignoreMissingPartialLen
=
false
)
;
MOZ_MUST_USE
nsresult
SetupByteRangeRequest
(
int64_t
partialLen
)
;
void
UntieByteRangeRequest
(
)
;
void
UntieValidationRequest
(
)
;
MOZ_MUST_USE
nsresult
OpenCacheInputStream
(
nsICacheEntry
*
cacheEntry
bool
startBuffering
bool
checkingAppCacheEntry
)
;
void
SetPushedStream
(
Http2PushedStream
*
stream
)
;
void
MaybeWarnAboutAppCache
(
)
;
void
SetLoadGroupUserAgentOverride
(
)
;
void
SetDoNotTrack
(
)
;
already_AddRefed
<
nsChannelClassifier
>
GetOrCreateChannelClassifier
(
)
;
private
:
nsCOMPtr
<
nsIApplicationCache
>
mApplicationCacheForWrite
;
nsCOMPtr
<
nsIHttpChannelAuthProvider
>
mAuthProvider
;
nsCOMPtr
<
nsIURI
>
mRedirectURI
;
nsCOMPtr
<
nsIChannel
>
mRedirectChannel
;
nsCOMPtr
<
nsIChannel
>
mPreflightChannel
;
RefPtr
<
nsChannelClassifier
>
mChannelClassifier
;
void
ReleaseMainThreadOnlyReferences
(
)
;
private
:
nsCOMPtr
<
nsICancelable
>
mProxyRequest
;
RefPtr
<
nsInputStreamPump
>
mTransactionPump
;
RefPtr
<
nsHttpTransaction
>
mTransaction
;
uint64_t
mLogicalOffset
;
nsCOMPtr
<
nsICacheEntry
>
mCacheEntry
;
nsCOMPtr
<
nsICacheEntry
>
mAltDataCacheEntry
;
AutoClose
<
nsIInputStream
>
mCacheInputStream
;
RefPtr
<
nsInputStreamPump
>
mCachePump
;
nsAutoPtr
<
nsHttpResponseHead
>
mCachedResponseHead
;
nsCOMPtr
<
nsISupports
>
mCachedSecurityInfo
;
uint32_t
mPostID
;
uint32_t
mRequestTime
;
nsCOMPtr
<
nsICacheEntry
>
mOfflineCacheEntry
;
uint32_t
mOfflineCacheLastModifiedTime
;
mozilla
:
:
TimeStamp
mOnStartRequestTimestamp
;
mozilla
:
:
TimeStamp
mSuspendTimestamp
;
mozilla
:
:
TimeStamp
mOnCacheEntryCheckTimestamp
;
uint32_t
mSuspendTotalTime
;
enum
{
DO_NOT_INTERCEPT
MAYBE_INTERCEPT
INTERCEPTED
}
mInterceptCache
;
uint64_t
mInterceptionID
;
bool
PossiblyIntercepted
(
)
{
return
mInterceptCache
!
=
DO_NOT_INTERCEPT
;
}
nsCString
mFallbackKey
;
friend
class
AutoRedirectVetoNotifier
;
friend
class
HttpAsyncAborter
<
nsHttpChannel
>
;
uint32_t
mRedirectType
;
static
const
uint32_t
WAIT_FOR_CACHE_ENTRY
=
1
;
static
const
uint32_t
WAIT_FOR_OFFLINE_CACHE_ENTRY
=
2
;
bool
mCacheOpenWithPriority
;
uint32_t
mCacheQueueSizeWhenOpen
;
uint32_t
mCachedContentIsValid
:
1
;
uint32_t
mCachedContentIsPartial
:
1
;
uint32_t
mCacheOnlyMetadata
:
1
;
uint32_t
mTransactionReplaced
:
1
;
uint32_t
mAuthRetryPending
:
1
;
uint32_t
mProxyAuthPending
:
1
;
uint32_t
mCustomAuthHeader
:
1
;
uint32_t
mResuming
:
1
;
uint32_t
mInitedCacheEntry
:
1
;
uint32_t
mFallbackChannel
:
1
;
uint32_t
mCustomConditionalRequest
:
1
;
uint32_t
mFallingBack
:
1
;
uint32_t
mWaitingForRedirectCallback
:
1
;
uint32_t
mRequestTimeInitialized
:
1
;
uint32_t
mCacheEntryIsReadOnly
:
1
;
uint32_t
mCacheEntryIsWriteOnly
:
1
;
uint32_t
mCacheEntriesToWaitFor
:
2
;
uint32_t
mHasQueryString
:
1
;
uint32_t
mConcurrentCacheAccess
:
1
;
uint32_t
mIsPartialRequest
:
1
;
uint32_t
mHasAutoRedirectVetoNotifier
:
1
;
uint32_t
mPinCacheContent
:
1
;
uint32_t
mIsCorsPreflightDone
:
1
;
uint32_t
mStronglyFramed
:
1
;
uint32_t
mUsedNetwork
:
1
;
uint32_t
mAuthConnectionRestartable
:
1
;
uint32_t
mReqContentLengthDetermined
:
1
;
uint64_t
mReqContentLength
;
nsTArray
<
nsContinueRedirectionFunc
>
mRedirectFuncStack
;
RefPtr
<
nsDNSPrefetch
>
mDNSPrefetch
;
Http2PushedStream
*
mPushedStream
;
bool
mLocalBlocklist
;
MOZ_MUST_USE
nsresult
WaitForRedirectCallback
(
)
;
void
PushRedirectAsyncFunc
(
nsContinueRedirectionFunc
func
)
;
void
PopRedirectAsyncFunc
(
nsContinueRedirectionFunc
func
)
;
nsCString
mUsername
;
HttpChannelSecurityWarningReporter
*
mWarningReporter
;
RefPtr
<
ADivertableParentChannel
>
mParentChannel
;
Atomic
<
bool
>
mIsReadingFromCache
;
nsCOMPtr
<
nsITimer
>
mCacheOpenTimer
;
std
:
:
function
<
void
(
nsHttpChannel
*
)
>
mCacheOpenFunc
;
uint32_t
mCacheOpenDelay
=
0
;
enum
{
RESPONSE_PENDING
RESPONSE_FROM_CACHE
RESPONSE_FROM_NETWORK
}
mFirstResponseSource
=
RESPONSE_PENDING
;
nsresult
MaybeRaceCacheWithNetwork
(
)
;
nsresult
TriggerNetwork
(
int32_t
aTimeout
)
;
void
CancelNetworkRequest
(
nsresult
aStatus
)
;
nsCOMPtr
<
nsITimer
>
mNetworkTriggerTimer
;
bool
mNetworkTriggered
=
false
;
bool
mWaitingForProxy
=
false
;
Atomic
<
bool
>
mOnCacheAvailableCalled
;
Atomic
<
bool
>
mRaceCacheWithNetwork
;
protected
:
virtual
void
DoNotifyListenerCleanup
(
)
override
;
virtual
void
ReleaseListeners
(
)
override
;
private
:
bool
mDidReval
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsHttpChannel
NS_HTTPCHANNEL_IID
)
}
}
#
endif
