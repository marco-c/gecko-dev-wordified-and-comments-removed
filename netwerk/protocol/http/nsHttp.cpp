#
include
"
HttpLog
.
h
"
#
include
"
nsHttp
.
h
"
#
include
"
CacheControlParser
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsHttpRequestHead
.
h
"
#
include
"
nsHttpResponseHead
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsICacheEntry
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
<
errno
.
h
>
#
include
<
functional
>
namespace
mozilla
{
namespace
net
{
namespace
nsHttp
{
#
define
HTTP_ATOM
(
_name
_value
)
nsHttpAtom
_name
=
{
_value
}
;
#
include
"
nsHttpAtomList
.
h
"
#
undef
HTTP_ATOM
}
#
define
HTTP_ATOM
(
_name
_value
)
Unused_
#
#
_name
enum
{
#
include
"
nsHttpAtomList
.
h
"
NUM_HTTP_ATOMS
}
;
#
undef
HTTP_ATOM
struct
HttpHeapAtom
{
struct
HttpHeapAtom
*
next
;
char
value
[
1
]
;
}
;
static
PLDHashTable
*
sAtomTable
;
static
struct
HttpHeapAtom
*
sHeapAtoms
=
nullptr
;
static
Mutex
*
sLock
=
nullptr
;
HttpHeapAtom
*
NewHeapAtom
(
const
char
*
value
)
{
int
len
=
strlen
(
value
)
;
HttpHeapAtom
*
a
=
reinterpret_cast
<
HttpHeapAtom
*
>
(
malloc
(
sizeof
(
*
a
)
+
len
)
)
;
if
(
!
a
)
return
nullptr
;
memcpy
(
a
-
>
value
value
len
+
1
)
;
a
-
>
next
=
sHeapAtoms
;
sHeapAtoms
=
a
;
return
a
;
}
static
PLDHashNumber
StringHash
(
const
void
*
key
)
{
PLDHashNumber
h
=
0
;
for
(
const
char
*
s
=
reinterpret_cast
<
const
char
*
>
(
key
)
;
*
s
;
+
+
s
)
h
=
AddToHash
(
h
nsCRT
:
:
ToLower
(
*
s
)
)
;
return
h
;
}
static
bool
StringCompare
(
const
PLDHashEntryHdr
*
entry
const
void
*
testKey
)
{
const
void
*
entryKey
=
reinterpret_cast
<
const
PLDHashEntryStub
*
>
(
entry
)
-
>
key
;
return
PL_strcasecmp
(
reinterpret_cast
<
const
char
*
>
(
entryKey
)
reinterpret_cast
<
const
char
*
>
(
testKey
)
)
=
=
0
;
}
static
const
PLDHashTableOps
ops
=
{
StringHash
StringCompare
PLDHashTable
:
:
MoveEntryStub
PLDHashTable
:
:
ClearEntryStub
nullptr
}
;
namespace
nsHttp
{
nsresult
CreateAtomTable
(
)
{
MOZ_ASSERT
(
!
sAtomTable
"
atom
table
already
initialized
"
)
;
if
(
!
sLock
)
{
sLock
=
new
Mutex
(
"
nsHttp
.
sLock
"
)
;
}
sAtomTable
=
new
PLDHashTable
(
&
ops
sizeof
(
PLDHashEntryStub
)
NUM_HTTP_ATOMS
+
10
)
;
const
char
*
const
atoms
[
]
=
{
#
define
HTTP_ATOM
(
_name
_value
)
_name
.
_val
#
include
"
nsHttpAtomList
.
h
"
#
undef
HTTP_ATOM
nullptr
}
;
for
(
int
i
=
0
;
atoms
[
i
]
;
+
+
i
)
{
auto
stub
=
static_cast
<
PLDHashEntryStub
*
>
(
sAtomTable
-
>
Add
(
atoms
[
i
]
fallible
)
)
;
if
(
!
stub
)
return
NS_ERROR_OUT_OF_MEMORY
;
MOZ_ASSERT
(
!
stub
-
>
key
"
duplicate
static
atom
"
)
;
stub
-
>
key
=
atoms
[
i
]
;
}
return
NS_OK
;
}
void
DestroyAtomTable
(
)
{
delete
sAtomTable
;
sAtomTable
=
nullptr
;
while
(
sHeapAtoms
)
{
HttpHeapAtom
*
next
=
sHeapAtoms
-
>
next
;
free
(
sHeapAtoms
)
;
sHeapAtoms
=
next
;
}
delete
sLock
;
sLock
=
nullptr
;
}
Mutex
*
GetLock
(
)
{
return
sLock
;
}
nsHttpAtom
ResolveAtom
(
const
char
*
str
)
{
nsHttpAtom
atom
=
{
nullptr
}
;
if
(
!
str
|
|
!
sAtomTable
)
return
atom
;
MutexAutoLock
lock
(
*
sLock
)
;
auto
stub
=
static_cast
<
PLDHashEntryStub
*
>
(
sAtomTable
-
>
Add
(
str
fallible
)
)
;
if
(
!
stub
)
return
atom
;
if
(
stub
-
>
key
)
{
atom
.
_val
=
reinterpret_cast
<
const
char
*
>
(
stub
-
>
key
)
;
return
atom
;
}
HttpHeapAtom
*
heapAtom
=
NewHeapAtom
(
str
)
;
if
(
!
heapAtom
)
return
atom
;
stub
-
>
key
=
atom
.
_val
=
heapAtom
-
>
value
;
return
atom
;
}
static
const
char
kValidTokenMap
[
128
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
1
1
1
1
1
0
0
1
1
0
1
1
0
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
1
0
1
0
}
;
bool
IsValidToken
(
const
char
*
start
const
char
*
end
)
{
if
(
start
=
=
end
)
return
false
;
for
(
;
start
!
=
end
;
+
+
start
)
{
const
unsigned
char
idx
=
*
start
;
if
(
idx
>
127
|
|
!
kValidTokenMap
[
idx
]
)
return
false
;
}
return
true
;
}
const
char
*
GetProtocolVersion
(
HttpVersion
pv
)
{
switch
(
pv
)
{
case
HttpVersion
:
:
v3_0
:
return
"
h3
"
;
case
HttpVersion
:
:
v2_0
:
return
"
h2
"
;
case
HttpVersion
:
:
v1_0
:
return
"
http
/
1
.
0
"
;
case
HttpVersion
:
:
v1_1
:
return
"
http
/
1
.
1
"
;
default
:
NS_WARNING
(
nsPrintfCString
(
"
Unkown
protocol
version
:
0x
%
X
.
"
"
Please
file
a
bug
"
static_cast
<
uint32_t
>
(
pv
)
)
.
get
(
)
)
;
return
"
http
/
1
.
1
"
;
}
}
void
TrimHTTPWhitespace
(
const
nsACString
&
aSource
nsACString
&
aDest
)
{
nsAutoCString
str
(
aSource
)
;
static
const
char
kHTTPWhitespace
[
]
=
"
\
t
\
n
\
r
"
;
str
.
Trim
(
kHTTPWhitespace
)
;
aDest
.
Assign
(
str
)
;
}
bool
IsReasonableHeaderValue
(
const
nsACString
&
s
)
{
const
nsACString
:
:
char_type
*
end
=
s
.
EndReading
(
)
;
for
(
const
nsACString
:
:
char_type
*
i
=
s
.
BeginReading
(
)
;
i
!
=
end
;
+
+
i
)
{
if
(
*
i
=
=
'
\
r
'
|
|
*
i
=
=
'
\
n
'
|
|
*
i
=
=
'
\
0
'
)
{
return
false
;
}
}
return
true
;
}
const
char
*
FindToken
(
const
char
*
input
const
char
*
token
const
char
*
seps
)
{
if
(
!
input
)
return
nullptr
;
int
inputLen
=
strlen
(
input
)
;
int
tokenLen
=
strlen
(
token
)
;
if
(
inputLen
<
tokenLen
)
return
nullptr
;
const
char
*
inputTop
=
input
;
const
char
*
inputEnd
=
input
+
inputLen
-
tokenLen
;
for
(
;
input
<
=
inputEnd
;
+
+
input
)
{
if
(
PL_strncasecmp
(
input
token
tokenLen
)
=
=
0
)
{
if
(
input
>
inputTop
&
&
!
strchr
(
seps
*
(
input
-
1
)
)
)
continue
;
if
(
input
<
inputEnd
&
&
!
strchr
(
seps
*
(
input
+
tokenLen
)
)
)
continue
;
return
input
;
}
}
return
nullptr
;
}
bool
ParseInt64
(
const
char
*
input
const
char
*
*
next
int64_t
*
r
)
{
MOZ_ASSERT
(
input
)
;
MOZ_ASSERT
(
r
)
;
char
*
end
=
nullptr
;
errno
=
0
;
int64_t
value
=
strtoll
(
input
&
end
10
)
;
if
(
errno
!
=
0
|
|
end
=
=
input
|
|
value
<
0
)
{
LOG
(
(
"
nsHttp
:
:
ParseInt64
value
=
%
"
PRId64
"
errno
=
%
d
"
value
errno
)
)
;
return
false
;
}
if
(
next
)
{
*
next
=
end
;
}
*
r
=
value
;
return
true
;
}
bool
IsPermanentRedirect
(
uint32_t
httpStatus
)
{
return
httpStatus
=
=
301
|
|
httpStatus
=
=
308
;
}
bool
ValidationRequired
(
bool
isForcedValid
nsHttpResponseHead
*
cachedResponseHead
uint32_t
loadFlags
bool
allowStaleCacheContent
bool
isImmutable
bool
customConditionalRequest
nsHttpRequestHead
&
requestHead
nsICacheEntry
*
entry
CacheControlParser
&
cacheControlRequest
bool
fromPreviousSession
bool
*
performBackgroundRevalidation
)
{
if
(
performBackgroundRevalidation
)
{
*
performBackgroundRevalidation
=
false
;
}
if
(
isForcedValid
&
&
(
!
cachedResponseHead
-
>
ExpiresInPast
(
)
|
|
!
cachedResponseHead
-
>
MustValidateIfExpired
(
)
)
)
{
LOG
(
(
"
NOT
validating
based
on
isForcedValid
being
true
.
\
n
"
)
)
;
return
false
;
}
if
(
loadFlags
&
nsIRequest
:
:
LOAD_FROM_CACHE
|
|
allowStaleCacheContent
)
{
LOG
(
(
"
NOT
validating
based
on
LOAD_FROM_CACHE
load
flag
\
n
"
)
)
;
return
false
;
}
if
(
(
loadFlags
&
nsIRequest
:
:
VALIDATE_ALWAYS
)
&
&
!
isImmutable
)
{
LOG
(
(
"
Validating
based
on
VALIDATE_ALWAYS
load
flag
\
n
"
)
)
;
return
true
;
}
if
(
loadFlags
&
nsIRequest
:
:
VALIDATE_NEVER
)
{
LOG
(
(
"
VALIDATE_NEVER
set
\
n
"
)
)
;
if
(
cachedResponseHead
-
>
NoStore
(
)
)
{
LOG
(
(
"
Validating
based
on
no
-
store
logic
\
n
"
)
)
;
return
true
;
}
LOG
(
(
"
NOT
validating
based
on
VALIDATE_NEVER
load
flag
\
n
"
)
)
;
return
false
;
}
if
(
cachedResponseHead
-
>
MustValidate
(
)
)
{
LOG
(
(
"
Validating
based
on
MustValidate
(
)
returning
TRUE
\
n
"
)
)
;
return
true
;
}
if
(
customConditionalRequest
&
&
!
requestHead
.
HasHeader
(
nsHttp
:
:
If_Match
)
&
&
!
requestHead
.
HasHeader
(
nsHttp
:
:
If_Unmodified_Since
)
)
{
LOG
(
(
"
Validating
based
on
a
custom
conditional
request
\
n
"
)
)
;
return
true
;
}
bool
doValidation
=
true
;
uint32_t
now
=
NowInSeconds
(
)
;
uint32_t
age
=
0
;
nsresult
rv
=
cachedResponseHead
-
>
ComputeCurrentAge
(
now
now
&
age
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
uint32_t
freshness
=
0
;
rv
=
cachedResponseHead
-
>
ComputeFreshnessLifetime
(
&
freshness
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
uint32_t
expiration
=
0
;
rv
=
entry
-
>
GetExpirationTime
(
&
expiration
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
uint32_t
maxAgeRequest
maxStaleRequest
minFreshRequest
;
LOG
(
(
"
NowInSeconds
(
)
=
%
u
expiration
time
=
%
u
freshness
lifetime
=
%
u
age
=
%
u
"
now
expiration
freshness
age
)
)
;
if
(
cacheControlRequest
.
NoCache
(
)
)
{
LOG
(
(
"
validating
no
-
cache
request
"
)
)
;
doValidation
=
true
;
}
else
if
(
cacheControlRequest
.
MaxStale
(
&
maxStaleRequest
)
)
{
uint32_t
staleTime
=
age
>
freshness
?
age
-
freshness
:
0
;
doValidation
=
staleTime
>
maxStaleRequest
;
LOG
(
(
"
validating
=
%
d
max
-
stale
=
%
u
requested
"
doValidation
maxStaleRequest
)
)
;
}
else
if
(
cacheControlRequest
.
MaxAge
(
&
maxAgeRequest
)
)
{
doValidation
=
age
>
=
maxAgeRequest
;
LOG
(
(
"
validating
=
%
d
max
-
age
=
%
u
requested
"
doValidation
maxAgeRequest
)
)
;
}
else
if
(
cacheControlRequest
.
MinFresh
(
&
minFreshRequest
)
)
{
uint32_t
freshTime
=
freshness
>
age
?
freshness
-
age
:
0
;
doValidation
=
freshTime
<
minFreshRequest
;
LOG
(
(
"
validating
=
%
d
min
-
fresh
=
%
u
requested
"
doValidation
minFreshRequest
)
)
;
}
else
if
(
now
<
expiration
)
{
doValidation
=
false
;
LOG
(
(
"
not
validating
expire
time
not
in
the
past
"
)
)
;
}
else
if
(
cachedResponseHead
-
>
MustValidateIfExpired
(
)
)
{
doValidation
=
true
;
}
else
if
(
cachedResponseHead
-
>
StaleWhileRevalidate
(
now
expiration
)
)
{
LOG
(
(
"
not
validating
in
the
stall
-
while
-
revalidate
window
"
)
)
;
doValidation
=
false
;
if
(
performBackgroundRevalidation
)
{
*
performBackgroundRevalidation
=
true
;
}
}
else
if
(
loadFlags
&
nsIRequest
:
:
VALIDATE_ONCE_PER_SESSION
)
{
if
(
freshness
=
=
0
)
doValidation
=
true
;
else
doValidation
=
fromPreviousSession
;
}
else
{
doValidation
=
true
;
}
LOG
(
(
"
%
salidating
based
on
expiration
time
\
n
"
doValidation
?
"
V
"
:
"
Not
v
"
)
)
;
return
doValidation
;
}
nsresult
GetHttpResponseHeadFromCacheEntry
(
nsICacheEntry
*
entry
nsHttpResponseHead
*
cachedResponseHead
)
{
nsCString
buf
;
nsresult
rv
=
entry
-
>
GetMetaDataElement
(
"
original
-
response
-
headers
"
getter_Copies
(
buf
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
cachedResponseHead
-
>
ParseCachedOriginalHeaders
(
(
char
*
)
buf
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
failed
to
parse
original
-
response
-
headers
\
n
"
)
)
;
}
}
buf
.
Adopt
(
nullptr
)
;
rv
=
entry
-
>
GetMetaDataElement
(
"
response
-
head
"
getter_Copies
(
buf
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
cachedResponseHead
-
>
ParseCachedHead
(
buf
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
buf
.
Adopt
(
nullptr
)
;
return
NS_OK
;
}
nsresult
CheckPartial
(
nsICacheEntry
*
aEntry
int64_t
*
aSize
int64_t
*
aContentLength
nsHttpResponseHead
*
responseHead
)
{
nsresult
rv
;
rv
=
aEntry
-
>
GetDataSize
(
aSize
)
;
if
(
NS_ERROR_IN_PROGRESS
=
=
rv
)
{
*
aSize
=
-
1
;
rv
=
NS_OK
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
responseHead
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
aContentLength
=
responseHead
-
>
ContentLength
(
)
;
return
NS_OK
;
}
void
DetermineFramingAndImmutability
(
nsICacheEntry
*
entry
nsHttpResponseHead
*
responseHead
bool
isHttps
bool
*
weaklyFramed
bool
*
isImmutable
)
{
nsCString
framedBuf
;
nsresult
rv
=
entry
-
>
GetMetaDataElement
(
"
strongly
-
framed
"
getter_Copies
(
framedBuf
)
)
;
*
weaklyFramed
=
NS_SUCCEEDED
(
rv
)
&
&
framedBuf
.
EqualsLiteral
(
"
0
"
)
;
*
isImmutable
=
!
*
weaklyFramed
&
&
isHttps
&
&
responseHead
-
>
Immutable
(
)
;
}
bool
IsBeforeLastActiveTabLoadOptimization
(
TimeStamp
const
&
when
)
{
return
gHttpHandler
&
&
gHttpHandler
-
>
IsBeforeLastActiveTabLoadOptimization
(
when
)
;
}
void
NotifyActiveTabLoadOptimization
(
)
{
if
(
gHttpHandler
)
{
gHttpHandler
-
>
NotifyActiveTabLoadOptimization
(
)
;
}
}
TimeStamp
const
GetLastActiveTabLoadOptimizationHit
(
)
{
return
gHttpHandler
?
gHttpHandler
-
>
GetLastActiveTabLoadOptimizationHit
(
)
:
TimeStamp
(
)
;
}
void
SetLastActiveTabLoadOptimizationHit
(
TimeStamp
const
&
when
)
{
if
(
gHttpHandler
)
{
gHttpHandler
-
>
SetLastActiveTabLoadOptimizationHit
(
when
)
;
}
}
HttpVersion
GetHttpVersionFromSpdy
(
SpdyVersion
sv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sv
!
=
SpdyVersion
:
:
NONE
)
;
MOZ_ASSERT
(
sv
=
=
SpdyVersion
:
:
HTTP_2
)
;
return
HttpVersion
:
:
v2_0
;
}
}
template
<
typename
T
>
void
localEnsureBuffer
(
UniquePtr
<
T
[
]
>
&
buf
uint32_t
newSize
uint32_t
preserve
uint32_t
&
objSize
)
{
if
(
objSize
>
=
newSize
)
return
;
objSize
=
(
newSize
+
2048
+
4095
)
&
~
4095
;
static_assert
(
sizeof
(
T
)
=
=
1
"
sizeof
(
T
)
must
be
1
"
)
;
auto
tmp
=
MakeUnique
<
T
[
]
>
(
objSize
)
;
if
(
preserve
)
{
memcpy
(
tmp
.
get
(
)
buf
.
get
(
)
preserve
)
;
}
buf
=
std
:
:
move
(
tmp
)
;
}
void
EnsureBuffer
(
UniquePtr
<
char
[
]
>
&
buf
uint32_t
newSize
uint32_t
preserve
uint32_t
&
objSize
)
{
localEnsureBuffer
<
char
>
(
buf
newSize
preserve
objSize
)
;
}
void
EnsureBuffer
(
UniquePtr
<
uint8_t
[
]
>
&
buf
uint32_t
newSize
uint32_t
preserve
uint32_t
&
objSize
)
{
localEnsureBuffer
<
uint8_t
>
(
buf
newSize
preserve
objSize
)
;
}
static
bool
IsTokenSymbol
(
signed
char
chr
)
{
if
(
chr
<
33
|
|
chr
=
=
127
|
|
chr
=
=
'
(
'
|
|
chr
=
=
'
)
'
|
|
chr
=
=
'
<
'
|
|
chr
=
=
'
>
'
|
|
chr
=
=
'
'
|
|
chr
=
=
'
'
|
|
chr
=
=
'
;
'
|
|
chr
=
=
'
:
'
|
|
chr
=
=
'
"
'
|
|
chr
=
=
'
/
'
|
|
chr
=
=
'
[
'
|
|
chr
=
=
'
]
'
|
|
chr
=
=
'
?
'
|
|
chr
=
=
'
=
'
|
|
chr
=
=
'
{
'
|
|
chr
=
=
'
}
'
|
|
chr
=
=
'
\
\
'
)
{
return
false
;
}
return
true
;
}
ParsedHeaderPair
:
:
ParsedHeaderPair
(
const
char
*
name
int32_t
nameLen
const
char
*
val
int32_t
valLen
bool
isQuotedValue
)
:
mName
(
nsDependentCSubstring
(
nullptr
0u
)
)
mValue
(
nsDependentCSubstring
(
nullptr
0u
)
)
mIsQuotedValue
(
isQuotedValue
)
{
if
(
nameLen
>
0
)
{
mName
.
Rebind
(
name
name
+
nameLen
)
;
}
if
(
valLen
>
0
)
{
if
(
mIsQuotedValue
)
{
RemoveQuotedStringEscapes
(
val
valLen
)
;
mValue
.
Rebind
(
mUnquotedValue
.
BeginWriting
(
)
mUnquotedValue
.
Length
(
)
)
;
}
else
{
mValue
.
Rebind
(
val
val
+
valLen
)
;
}
}
}
void
ParsedHeaderPair
:
:
RemoveQuotedStringEscapes
(
const
char
*
val
int32_t
valLen
)
{
mUnquotedValue
.
Truncate
(
)
;
const
char
*
c
=
val
;
for
(
int32_t
i
=
0
;
i
<
valLen
;
+
+
i
)
{
if
(
c
[
i
]
=
=
'
\
\
'
&
&
c
[
i
+
1
]
)
{
+
+
i
;
}
mUnquotedValue
.
Append
(
c
[
i
]
)
;
}
}
static
void
Tokenize
(
const
char
*
input
uint32_t
inputLen
const
char
token
const
std
:
:
function
<
void
(
const
char
*
uint32_t
)
>
&
consumer
)
{
auto
trimWhitespace
=
[
]
(
const
char
*
in
uint32_t
inLen
const
char
*
*
out
uint32_t
*
outLen
)
{
*
out
=
in
;
*
outLen
=
inLen
;
if
(
inLen
=
=
0
)
{
return
;
}
while
(
nsCRT
:
:
IsAsciiSpace
(
*
*
out
)
)
{
(
*
out
)
+
+
;
-
-
(
*
outLen
)
;
}
for
(
const
char
*
i
=
*
out
+
*
outLen
-
1
;
i
>
=
*
out
;
-
-
i
)
{
if
(
!
nsCRT
:
:
IsAsciiSpace
(
*
i
)
)
{
break
;
}
-
-
(
*
outLen
)
;
}
}
;
const
char
*
first
=
input
;
bool
inQuote
=
false
;
const
char
*
result
=
nullptr
;
uint32_t
resultLen
=
0
;
for
(
uint32_t
index
=
0
;
index
<
inputLen
;
+
+
index
)
{
if
(
inQuote
&
&
input
[
index
]
=
=
'
\
\
'
&
&
input
[
index
+
1
]
)
{
index
+
+
;
continue
;
}
if
(
input
[
index
]
=
=
'
"
'
)
{
inQuote
=
!
inQuote
;
continue
;
}
if
(
inQuote
)
{
continue
;
}
if
(
input
[
index
]
=
=
token
)
{
trimWhitespace
(
first
(
input
+
index
)
-
first
&
result
&
resultLen
)
;
consumer
(
result
resultLen
)
;
first
=
input
+
index
+
1
;
}
}
trimWhitespace
(
first
(
input
+
inputLen
)
-
first
&
result
&
resultLen
)
;
consumer
(
result
resultLen
)
;
}
ParsedHeaderValueList
:
:
ParsedHeaderValueList
(
const
char
*
t
uint32_t
len
bool
allowInvalidValue
)
{
if
(
!
len
)
{
return
;
}
ParsedHeaderValueList
*
self
=
this
;
auto
consumer
=
[
=
]
(
const
char
*
output
uint32_t
outputLength
)
{
self
-
>
ParseNameAndValue
(
output
allowInvalidValue
)
;
}
;
Tokenize
(
t
len
'
;
'
consumer
)
;
}
void
ParsedHeaderValueList
:
:
ParseNameAndValue
(
const
char
*
input
bool
allowInvalidValue
)
{
const
char
*
nameStart
=
input
;
const
char
*
nameEnd
=
nullptr
;
const
char
*
valueStart
=
input
;
const
char
*
valueEnd
=
nullptr
;
bool
isQuotedString
=
false
;
bool
invalidValue
=
false
;
for
(
;
*
input
&
&
*
input
!
=
'
;
'
&
&
*
input
!
=
'
'
&
&
!
nsCRT
:
:
IsAsciiSpace
(
*
input
)
&
&
*
input
!
=
'
=
'
;
input
+
+
)
;
nameEnd
=
input
;
if
(
!
(
nameEnd
-
nameStart
)
)
{
return
;
}
for
(
const
char
*
c
=
nameStart
;
c
<
nameEnd
;
c
+
+
)
{
if
(
!
IsTokenSymbol
(
*
c
)
)
{
nameEnd
=
c
;
break
;
}
}
if
(
!
(
nameEnd
-
nameStart
)
)
{
return
;
}
while
(
nsCRT
:
:
IsAsciiSpace
(
*
input
)
)
{
+
+
input
;
}
if
(
!
*
input
|
|
*
input
+
+
!
=
'
=
'
)
{
mValues
.
AppendElement
(
ParsedHeaderPair
(
nameStart
nameEnd
-
nameStart
nullptr
0
false
)
)
;
return
;
}
while
(
nsCRT
:
:
IsAsciiSpace
(
*
input
)
)
{
+
+
input
;
}
if
(
*
input
!
=
'
"
'
)
{
valueStart
=
input
;
for
(
valueEnd
=
input
;
*
valueEnd
&
&
!
nsCRT
:
:
IsAsciiSpace
(
*
valueEnd
)
&
&
*
valueEnd
!
=
'
;
'
&
&
*
valueEnd
!
=
'
'
;
valueEnd
+
+
)
;
if
(
!
allowInvalidValue
)
{
for
(
const
char
*
c
=
valueStart
;
c
<
valueEnd
;
c
+
+
)
{
if
(
!
IsTokenSymbol
(
*
c
)
)
{
valueEnd
=
c
;
break
;
}
}
}
}
else
{
bool
foundQuotedEnd
=
false
;
isQuotedString
=
true
;
+
+
input
;
valueStart
=
input
;
for
(
valueEnd
=
input
;
*
valueEnd
;
+
+
valueEnd
)
{
if
(
*
valueEnd
=
=
'
\
\
'
&
&
*
(
valueEnd
+
1
)
)
{
+
+
valueEnd
;
}
else
if
(
*
valueEnd
=
=
'
"
'
)
{
foundQuotedEnd
=
true
;
break
;
}
}
if
(
!
foundQuotedEnd
)
{
invalidValue
=
true
;
}
input
=
valueEnd
;
if
(
*
valueEnd
)
{
input
+
+
;
}
}
if
(
invalidValue
)
{
valueEnd
=
valueStart
;
}
mValues
.
AppendElement
(
ParsedHeaderPair
(
nameStart
nameEnd
-
nameStart
valueStart
valueEnd
-
valueStart
isQuotedString
)
)
;
}
ParsedHeaderValueListList
:
:
ParsedHeaderValueListList
(
const
nsCString
&
fullHeader
bool
allowInvalidValue
)
:
mFull
(
fullHeader
)
{
auto
&
values
=
mValues
;
auto
consumer
=
[
&
values
allowInvalidValue
]
(
const
char
*
output
uint32_t
outputLength
)
{
values
.
AppendElement
(
ParsedHeaderValueList
(
output
outputLength
allowInvalidValue
)
)
;
}
;
Tokenize
(
mFull
.
BeginReading
(
)
mFull
.
Length
(
)
'
'
consumer
)
;
}
void
LogCallingScriptLocation
(
void
*
instance
)
{
if
(
!
LOG4_ENABLED
(
)
)
{
return
;
}
JSContext
*
cx
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
;
if
(
!
cx
)
{
return
;
}
nsAutoCString
fileNameString
;
uint32_t
line
=
0
col
=
0
;
if
(
!
nsJSUtils
:
:
GetCallingLocation
(
cx
fileNameString
&
line
&
col
)
)
{
return
;
}
LOG
(
(
"
%
p
called
from
script
:
%
s
:
%
u
:
%
u
"
instance
fileNameString
.
get
(
)
line
col
)
)
;
}
static
bool
sSanitize
=
true
;
static
bool
InitPreferences
(
)
{
Preferences
:
:
AddBoolVarCache
(
&
sSanitize
"
network
.
http
.
sanitize
-
headers
-
in
-
logs
"
true
)
;
return
true
;
}
void
LogHeaders
(
const
char
*
lineStart
)
{
static
bool
once
=
InitPreferences
(
)
;
Unused
<
<
once
;
nsAutoCString
buf
;
char
*
endOfLine
;
while
(
(
endOfLine
=
PL_strstr
(
lineStart
"
\
r
\
n
"
)
)
)
{
buf
.
Assign
(
lineStart
endOfLine
-
lineStart
)
;
if
(
sSanitize
&
&
(
PL_strcasestr
(
buf
.
get
(
)
"
authorization
:
"
)
|
|
PL_strcasestr
(
buf
.
get
(
)
"
proxy
-
authorization
:
"
)
)
)
{
char
*
p
=
PL_strchr
(
buf
.
get
(
)
'
'
)
;
while
(
p
&
&
*
+
+
p
)
{
*
p
=
'
*
'
;
}
}
LOG1
(
(
"
%
s
\
n
"
buf
.
get
(
)
)
)
;
lineStart
=
endOfLine
+
2
;
}
}
}
}
