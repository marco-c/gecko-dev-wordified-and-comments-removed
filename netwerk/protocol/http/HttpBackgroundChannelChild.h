#
ifndef
mozilla_net_HttpBackgroundChannelChild_h
#
define
mozilla_net_HttpBackgroundChannelChild_h
#
include
"
mozilla
/
net
/
PHttpBackgroundChannelChild
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsTArray
.
h
"
using
mozilla
:
:
ipc
:
:
IPCResult
;
using
mozilla
:
:
dom
:
:
ClassifierInfo
;
namespace
mozilla
{
namespace
net
{
class
HttpChannelChild
;
class
HttpBackgroundChannelChild
final
:
public
PHttpBackgroundChannelChild
{
friend
class
BackgroundChannelCreateCallback
;
public
:
explicit
HttpBackgroundChannelChild
(
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
HttpBackgroundChannelChild
)
nsresult
Init
(
HttpChannelChild
*
aChannelChild
)
;
void
OnChannelClosed
(
)
;
void
OnStartRequestReceived
(
)
;
protected
:
IPCResult
RecvOnTransportAndData
(
const
nsresult
&
aChannelStatus
const
nsresult
&
aTransportStatus
const
uint64_t
&
aOffset
const
uint32_t
&
aCount
const
nsCString
&
aData
)
override
;
IPCResult
RecvOnStopRequest
(
const
nsresult
&
aChannelStatus
const
ResourceTimingStruct
&
aTiming
const
TimeStamp
&
aLastActiveTabOptHit
const
nsHttpHeaderArray
&
aResponseTrailers
)
override
;
IPCResult
RecvOnProgress
(
const
int64_t
&
aProgress
const
int64_t
&
aProgressMax
)
override
;
IPCResult
RecvOnStatus
(
const
nsresult
&
aStatus
)
override
;
IPCResult
RecvFlushedForDiversion
(
)
override
;
IPCResult
RecvDivertMessages
(
)
override
;
IPCResult
RecvOnStartRequestSent
(
)
override
;
IPCResult
RecvNotifyTrackingProtectionDisabled
(
)
override
;
IPCResult
RecvNotifyTrackingResource
(
const
bool
&
aIsThirdParty
)
override
;
IPCResult
RecvSetClassifierMatchedInfo
(
const
ClassifierInfo
&
info
)
override
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
private
:
virtual
~
HttpBackgroundChannelChild
(
)
;
bool
CreateBackgroundChannel
(
)
;
bool
IsWaitingOnStartRequest
(
)
;
RefPtr
<
HttpChannelChild
>
mChannelChild
;
bool
mStartReceived
=
false
;
bool
mStartSent
=
false
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mQueuedRunnables
;
}
;
}
}
#
endif
