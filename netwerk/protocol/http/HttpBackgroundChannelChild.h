#
ifndef
mozilla_net_HttpBackgroundChannelChild_h
#
define
mozilla_net_HttpBackgroundChannelChild_h
#
include
"
mozilla
/
net
/
PHttpBackgroundChannelChild
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsTArray
.
h
"
using
mozilla
:
:
ipc
:
:
IPCResult
;
namespace
mozilla
{
namespace
net
{
class
BackgroundDataBridgeChild
;
class
HttpChannelChild
;
class
HttpBackgroundChannelChild
final
:
public
PHttpBackgroundChannelChild
{
friend
class
BackgroundChannelCreateCallback
;
friend
class
PHttpBackgroundChannelChild
;
friend
class
HttpChannelChild
;
friend
class
BackgroundDataBridgeChild
;
public
:
explicit
HttpBackgroundChannelChild
(
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
HttpBackgroundChannelChild
final
)
nsresult
Init
(
HttpChannelChild
*
aChannelChild
)
;
void
OnChannelClosed
(
)
;
void
OnStartRequestReceived
(
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
bool
IsQueueEmpty
(
)
const
{
return
mQueuedRunnables
.
IsEmpty
(
)
;
}
#
endif
protected
:
IPCResult
RecvOnTransportAndData
(
const
nsresult
&
aChannelStatus
const
nsresult
&
aTransportStatus
const
uint64_t
&
aOffset
const
uint32_t
&
aCount
const
nsCString
&
aData
const
bool
&
aDataFromSocketProcess
)
;
IPCResult
RecvOnStopRequest
(
const
nsresult
&
aChannelStatus
const
ResourceTimingStructArgs
&
aTiming
const
TimeStamp
&
aLastActiveTabOptHit
const
nsHttpHeaderArray
&
aResponseTrailers
const
nsTArray
<
ConsoleReportCollected
>
&
aConsoleReports
)
;
IPCResult
RecvFlushedForDiversion
(
)
;
IPCResult
RecvDivertMessages
(
)
;
IPCResult
RecvOnStartRequestSent
(
)
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
void
CreateDataBridge
(
)
;
private
:
virtual
~
HttpBackgroundChannelChild
(
)
;
bool
CreateBackgroundChannel
(
)
;
bool
IsWaitingOnStartRequest
(
bool
aDataFromSocketProcess
=
false
)
;
RefPtr
<
HttpChannelChild
>
mChannelChild
;
bool
mStartReceived
=
false
;
bool
mStartSent
=
false
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mQueuedRunnables
;
RefPtr
<
BackgroundDataBridgeChild
>
mDataBridgeChild
;
}
;
}
}
#
endif
