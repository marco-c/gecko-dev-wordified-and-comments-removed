#
include
"
mozilla
/
net
/
SimpleHttpChannel
.
h
"
#
include
"
HttpLog
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
nsDNSPrefetch
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsHttpTransaction
.
h
"
#
include
"
nsIHttpPushListener
.
h
"
#
include
"
nsIProtocolProxyService2
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsIURIFixup
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
ReferrerInfo
.
h
"
namespace
mozilla
{
namespace
net
{
NS_IMPL_ADDREF
(
SimpleHttpChannel
)
NS_IMPL_RELEASE
(
SimpleHttpChannel
)
NS_INTERFACE_MAP_BEGIN
(
SimpleHttpChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequest
)
NS_INTERFACE_MAP_ENTRY
(
nsIChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIHttpChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIHttpChannelInternal
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsPriority
)
NS_INTERFACE_MAP_ENTRY
(
nsIClassOfService
)
NS_INTERFACE_MAP_ENTRY
(
nsIProxiedChannel
)
NS_INTERFACE_MAP_ENTRY
(
nsIStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsITransportEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIDNSListener
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
SimpleHttpChannel
)
NS_INTERFACE_MAP_END_INHERITING
(
HttpBaseChannel
)
SimpleHttpChannel
:
:
SimpleHttpChannel
(
)
:
HttpAsyncAborter
<
SimpleHttpChannel
>
(
this
)
mTopWindowOriginComputed
(
false
)
mPushedStreamId
(
0
)
{
LOG
(
(
"
SimpleHttpChannel
ctor
[
this
=
%
p
]
\
n
"
this
)
)
;
}
SimpleHttpChannel
:
:
~
SimpleHttpChannel
(
)
{
LOG
(
(
"
SimpleHttpChannel
dtor
[
this
=
%
p
]
\
n
"
this
)
)
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
Cancel
(
nsresult
status
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
Cancel
[
this
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
static_cast
<
uint32_t
>
(
status
)
)
)
;
if
(
mCanceled
)
{
LOG
(
(
"
ignoring
;
already
canceled
\
n
"
)
)
;
return
NS_OK
;
}
mCanceled
=
true
;
mStatus
=
status
;
CancelNetworkRequest
(
status
)
;
return
NS_OK
;
}
void
SimpleHttpChannel
:
:
CancelNetworkRequest
(
nsresult
aStatus
)
{
if
(
mTransaction
)
{
nsresult
rv
=
gHttpHandler
-
>
CancelTransaction
(
mTransaction
aStatus
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
failed
to
cancel
the
transaction
\
n
"
)
)
;
}
}
if
(
mTransactionPump
)
mTransactionPump
-
>
Cancel
(
aStatus
)
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
Suspend
(
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
SuspendInternal
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mTransactionPump
)
{
return
mTransactionPump
-
>
Suspend
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
Resume
(
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
Resume
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
mTransactionPump
)
{
return
mTransactionPump
-
>
Resume
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetSecurityInfo
(
nsISupports
*
*
securityInfo
)
{
NS_ENSURE_ARG_POINTER
(
securityInfo
)
;
*
securityInfo
=
mSecurityInfo
;
NS_IF_ADDREF
(
*
securityInfo
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
AsyncOpen
(
nsIStreamListener
*
aListener
)
{
NS_ENSURE_ARG_POINTER
(
aListener
)
;
NS_ENSURE_TRUE
(
!
mIsPending
NS_ERROR_IN_PROGRESS
)
;
NS_ENSURE_TRUE
(
!
mWasOpened
NS_ERROR_ALREADY_OPENED
)
;
if
(
mCanceled
)
{
ReleaseListeners
(
)
;
return
mStatus
;
}
#
ifdef
NIGHTLY_BUILD
MOZ_ASSERT
(
!
mPendingInputStreamLengthOperation
)
;
#
endif
if
(
mPendingInputStreamLengthOperation
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
gHttpHandler
-
>
Active
(
)
)
{
LOG
(
(
"
after
HTTP
shutdown
.
.
.
"
)
)
;
ReleaseListeners
(
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
NS_CheckPortSafety
(
mURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReleaseListeners
(
)
;
return
rv
;
}
mIsPending
=
true
;
mWasOpened
=
true
;
mListener
=
aListener
;
mAsyncOpenTime
=
TimeStamp
:
:
Now
(
)
;
rv
=
BeginConnect
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
Unused
<
<
AsyncAbort
(
rv
)
;
}
return
NS_OK
;
}
const
nsCString
&
SimpleHttpChannel
:
:
GetTopWindowOrigin
(
)
{
if
(
mTopWindowOriginComputed
)
{
return
mTopWindowOrigin
;
}
nsCOMPtr
<
nsIURI
>
topWindowURI
;
nsresult
rv
=
GetTopWindowURI
(
getter_AddRefs
(
topWindowURI
)
)
;
bool
isDocument
=
false
;
if
(
NS_FAILED
(
rv
)
&
&
NS_SUCCEEDED
(
GetIsMainDocumentChannel
(
&
isDocument
)
)
&
&
isDocument
)
{
rv
=
NS_GetFinalChannelURI
(
this
getter_AddRefs
(
topWindowURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
mTopWindowOrigin
)
;
}
rv
=
nsContentUtils
:
:
GetASCIIOrigin
(
topWindowURI
?
topWindowURI
:
mURI
mTopWindowOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
mTopWindowOrigin
)
;
mTopWindowOriginComputed
=
true
;
return
mTopWindowOrigin
;
}
nsresult
SimpleHttpChannel
:
:
BeginConnect
(
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
BeginConnect
[
this
=
%
p
]
\
n
"
this
)
)
;
nsresult
rv
;
nsAutoCString
host
;
nsAutoCString
scheme
;
int32_t
port
=
-
1
;
bool
isHttps
=
mURI
-
>
SchemeIs
(
"
https
"
)
;
rv
=
mURI
-
>
GetScheme
(
scheme
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
mURI
-
>
GetAsciiHost
(
host
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
mURI
-
>
GetPort
(
&
port
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
mURI
-
>
GetUsername
(
mUsername
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
mURI
-
>
GetAsciiSpec
(
mSpec
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
host
.
IsEmpty
(
)
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
return
rv
;
}
LOG
(
(
"
host
=
%
s
port
=
%
d
\
n
"
host
.
get
(
)
port
)
)
;
LOG
(
(
"
uri
=
%
s
\
n
"
mSpec
.
get
(
)
)
)
;
nsCOMPtr
<
nsProxyInfo
>
proxyInfo
;
if
(
mProxyInfo
)
proxyInfo
=
do_QueryInterface
(
mProxyInfo
)
;
mRequestHead
.
SetHTTPS
(
isHttps
)
;
mRequestHead
.
SetOrigin
(
scheme
host
port
)
;
RefPtr
<
nsHttpConnectionInfo
>
connInfo
=
new
nsHttpConnectionInfo
(
host
port
EmptyCString
(
)
mUsername
GetTopWindowOrigin
(
)
proxyInfo
OriginAttributes
(
)
isHttps
)
;
mAllowAltSvc
=
(
mAllowAltSvc
&
&
!
gHttpHandler
-
>
IsSpdyBlacklisted
(
connInfo
)
)
;
RefPtr
<
AltSvcMapping
>
mapping
;
if
(
!
mConnectionInfo
&
&
mAllowAltSvc
&
&
!
(
mLoadFlags
&
LOAD_FRESH_CONNECTION
)
&
&
AltSvcMapping
:
:
AcceptableProxy
(
proxyInfo
)
&
&
(
scheme
.
EqualsLiteral
(
"
http
"
)
|
|
scheme
.
EqualsLiteral
(
"
https
"
)
)
&
&
(
mapping
=
gHttpHandler
-
>
GetAltServiceMapping
(
scheme
host
port
mPrivateBrowsing
IsIsolated
(
)
GetTopWindowOrigin
(
)
OriginAttributes
(
)
)
)
)
{
LOG
(
(
"
SimpleHttpChannel
%
p
Alt
Service
Mapping
Found
%
s
:
/
/
%
s
:
%
d
[
%
s
]
\
n
"
this
scheme
.
get
(
)
mapping
-
>
AlternateHost
(
)
.
get
(
)
mapping
-
>
AlternatePort
(
)
mapping
-
>
HashKey
(
)
.
get
(
)
)
)
;
if
(
!
(
mLoadFlags
&
LOAD_ANONYMOUS
)
&
&
!
mPrivateBrowsing
)
{
nsAutoCString
altUsedLine
(
mapping
-
>
AlternateHost
(
)
)
;
bool
defaultPort
=
mapping
-
>
AlternatePort
(
)
=
=
(
isHttps
?
NS_HTTPS_DEFAULT_PORT
:
NS_HTTP_DEFAULT_PORT
)
;
if
(
!
defaultPort
)
{
altUsedLine
.
AppendLiteral
(
"
:
"
)
;
altUsedLine
.
AppendInt
(
mapping
-
>
AlternatePort
(
)
)
;
}
rv
=
mRequestHead
.
SetHeader
(
nsHttp
:
:
Alternate_Service_Used
altUsedLine
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
LOG
(
(
"
SimpleHttpChannel
%
p
Using
connection
info
from
altsvc
mapping
"
this
)
)
;
mapping
-
>
GetConnectionInfo
(
getter_AddRefs
(
mConnectionInfo
)
proxyInfo
OriginAttributes
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_TRANSACTION_USE_ALTSVC
true
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_TRANSACTION_USE_ALTSVC_OE
!
isHttps
)
;
}
else
if
(
mConnectionInfo
)
{
LOG
(
(
"
SimpleHttpChannel
%
p
Using
channel
supplied
connection
info
"
this
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_TRANSACTION_USE_ALTSVC
false
)
;
}
else
{
LOG
(
(
"
SimpleHttpChannel
%
p
Using
default
connection
info
"
this
)
)
;
mConnectionInfo
=
connInfo
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP_TRANSACTION_USE_ALTSVC
false
)
;
}
if
(
gHttpHandler
-
>
IsSpdyBlacklisted
(
mConnectionInfo
)
)
{
mAllowSpdy
=
0
;
mCaps
|
=
NS_HTTP_DISALLOW_SPDY
;
mConnectionInfo
-
>
SetNoSpdy
(
true
)
;
}
if
(
!
mTimingEnabled
)
mAsyncOpenTime
=
TimeStamp
(
)
;
Unused
<
<
gHttpHandler
-
>
AddConnectionHeader
(
&
mRequestHead
mCaps
)
;
if
(
mRequestHead
.
HasHeaderValue
(
nsHttp
:
:
Connection
"
close
"
)
)
mCaps
&
=
~
(
NS_HTTP_ALLOW_KEEPALIVE
)
;
if
(
gHttpHandler
-
>
CriticalRequestPrioritization
(
)
)
{
if
(
mClassOfService
&
nsIClassOfService
:
:
Leader
)
{
mCaps
|
=
NS_HTTP_LOAD_AS_BLOCKING
;
}
if
(
mClassOfService
&
nsIClassOfService
:
:
Unblocked
)
{
mCaps
|
=
NS_HTTP_LOAD_UNBLOCKED
;
}
if
(
mClassOfService
&
nsIClassOfService
:
:
UrgentStart
&
&
gHttpHandler
-
>
IsUrgentStartEnabled
(
)
)
{
mCaps
|
=
NS_HTTP_URGENT_START
;
SetPriority
(
nsISupportsPriority
:
:
PRIORITY_HIGHEST
)
;
}
}
if
(
mLoadFlags
&
LOAD_FRESH_CONNECTION
)
{
if
(
mLoadFlags
&
LOAD_INITIAL_DOCUMENT_URI
)
{
gHttpHandler
-
>
AltServiceCache
(
)
-
>
ClearAltServiceMappings
(
)
;
rv
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
DoShiftReloadConnectionCleanup
(
mConnectionInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
BeginConnect
"
"
DoShiftReloadConnectionCleanup
failed
:
%
08x
[
this
=
%
p
]
"
static_cast
<
uint32_t
>
(
rv
)
this
)
)
;
}
}
}
MaybeStartDNSPrefetch
(
)
;
rv
=
ContinueOnBeforeConnect
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
SimpleHttpChannel
:
:
ContinueOnBeforeConnect
(
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
ContinueOnBeforeConnect
[
this
=
%
p
]
\
n
"
this
)
)
;
if
(
!
net_IsValidHostName
(
nsDependentCString
(
mConnectionInfo
-
>
Origin
(
)
)
)
)
return
NS_ERROR_UNKNOWN_HOST
;
if
(
mIsTRRServiceChannel
)
{
mCaps
|
=
NS_HTTP_LARGE_KEEPALIVE
;
}
mCaps
|
=
NS_HTTP_TRR_FLAGS_FROM_MODE
(
nsIRequest
:
:
GetTRRMode
(
)
)
;
mConnectionInfo
-
>
SetAnonymous
(
(
mLoadFlags
&
LOAD_ANONYMOUS
)
!
=
0
)
;
mConnectionInfo
-
>
SetPrivate
(
mPrivateBrowsing
)
;
mConnectionInfo
-
>
SetIsolated
(
IsIsolated
(
)
)
;
mConnectionInfo
-
>
SetNoSpdy
(
mCaps
&
NS_HTTP_DISALLOW_SPDY
)
;
mConnectionInfo
-
>
SetBeConservative
(
(
mCaps
&
NS_HTTP_BE_CONSERVATIVE
)
|
|
mBeConservative
)
;
mConnectionInfo
-
>
SetTlsFlags
(
mTlsFlags
)
;
mConnectionInfo
-
>
SetIsTrrServiceChannel
(
mIsTRRServiceChannel
)
;
mConnectionInfo
-
>
SetTRRMode
(
nsIRequest
:
:
GetTRRMode
(
)
)
;
mConnectionInfo
-
>
SetIPv4Disabled
(
mCaps
&
NS_HTTP_DISABLE_IPV4
)
;
mConnectionInfo
-
>
SetIPv6Disabled
(
mCaps
&
NS_HTTP_DISABLE_IPV6
)
;
return
Connect
(
)
;
}
nsresult
SimpleHttpChannel
:
:
Connect
(
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
Connect
[
this
=
%
p
]
\
n
"
this
)
)
;
nsresult
rv
=
SetupTransaction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
gHttpHandler
-
>
InitiateTransaction
(
mTransaction
mPriority
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
mTransaction
-
>
AsyncRead
(
this
getter_AddRefs
(
mTransactionPump
)
)
;
}
nsresult
SimpleHttpChannel
:
:
SetupTransaction
(
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
SetupTransaction
[
this
=
%
p
cos
=
%
u
prio
=
%
d
]
\
n
"
this
mClassOfService
mPriority
)
)
;
NS_ENSURE_TRUE
(
!
mTransaction
NS_ERROR_ALREADY_INITIALIZED
)
;
nsresult
rv
;
if
(
!
mAllowSpdy
)
{
mCaps
|
=
NS_HTTP_DISALLOW_SPDY
;
}
if
(
mBeConservative
)
{
mCaps
|
=
NS_HTTP_BE_CONSERVATIVE
;
}
nsAutoCString
buf
path
;
nsCString
*
requestURI
;
rv
=
mURI
-
>
GetPathQueryRef
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
NS_EscapeURL
(
path
.
get
(
)
path
.
Length
(
)
esc_OnlyNonASCII
|
esc_Spaces
buf
)
)
{
requestURI
=
&
buf
;
}
else
{
requestURI
=
&
path
;
}
int32_t
ref1
=
requestURI
-
>
FindChar
(
'
#
'
)
;
if
(
ref1
!
=
kNotFound
)
{
requestURI
-
>
SetLength
(
ref1
)
;
}
if
(
mConnectionInfo
-
>
UsingConnect
(
)
|
|
!
mConnectionInfo
-
>
UsingHttpProxy
(
)
)
{
mRequestHead
.
SetVersion
(
gHttpHandler
-
>
HttpVersion
(
)
)
;
}
else
{
mRequestHead
.
SetPath
(
*
requestURI
)
;
rv
=
mURI
-
>
GetUserPass
(
buf
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
!
buf
.
IsEmpty
(
)
&
&
(
(
strncmp
(
mSpec
.
get
(
)
"
http
:
"
5
)
=
=
0
)
|
|
strncmp
(
mSpec
.
get
(
)
"
https
:
"
6
)
=
=
0
)
)
{
nsCOMPtr
<
nsIURIFixup
>
urifixup
=
services
:
:
GetURIFixup
(
)
;
if
(
NS_WARN_IF
(
!
urifixup
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
tempURI
;
nsresult
rv
=
urifixup
-
>
CreateExposableURI
(
mURI
getter_AddRefs
(
tempURI
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
tempURI
-
>
GetAsciiSpec
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
requestURI
=
&
path
;
}
else
{
requestURI
=
&
mSpec
;
}
int32_t
ref2
=
requestURI
-
>
FindChar
(
'
#
'
)
;
if
(
ref2
!
=
kNotFound
)
{
requestURI
-
>
SetLength
(
ref2
)
;
}
mRequestHead
.
SetVersion
(
gHttpHandler
-
>
ProxyHttpVersion
(
)
)
;
}
mRequestHead
.
SetRequestURI
(
*
requestURI
)
;
rv
=
mRequestHead
.
SetHeaderOnce
(
nsHttp
:
:
Pragma
"
no
-
cache
"
true
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
mRequestHead
.
Version
(
)
>
=
HttpVersion
:
:
v1_1
)
{
rv
=
mRequestHead
.
SetHeaderOnce
(
nsHttp
:
:
Cache_Control
"
no
-
cache
"
true
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
NS_NewNotificationCallbacksAggregation
(
mCallbacks
mLoadGroup
getter_AddRefs
(
callbacks
)
)
;
mTransaction
=
new
nsHttpTransaction
(
)
;
LOG1
(
(
"
SimpleHttpChannel
%
p
created
nsHttpTransaction
%
p
\
n
"
this
mTransaction
.
get
(
)
)
)
;
if
(
mLoadFlags
&
LOAD_ANONYMOUS
)
mCaps
|
=
NS_HTTP_LOAD_ANONYMOUS
;
if
(
mLoadFlags
&
LOAD_CALL_CONTENT_SNIFFERS
)
{
mCaps
|
=
NS_HTTP_CALL_CONTENT_SNIFFER
;
}
if
(
mTimingEnabled
)
mCaps
|
=
NS_HTTP_TIMING_ENABLED
;
nsCOMPtr
<
nsIHttpPushListener
>
pushListener
;
NS_QueryNotificationCallbacks
(
mCallbacks
mLoadGroup
NS_GET_IID
(
nsIHttpPushListener
)
getter_AddRefs
(
pushListener
)
)
;
HttpTransactionShell
:
:
OnPushCallback
pushCallback
=
nullptr
;
if
(
pushListener
)
{
mCaps
|
=
NS_HTTP_ONPUSH_LISTENER
;
nsWeakPtr
weakPtrThis
(
do_GetWeakReference
(
static_cast
<
nsIHttpChannel
*
>
(
this
)
)
)
;
pushCallback
=
[
weakPtrThis
]
(
uint32_t
aPushedStreamId
const
nsACString
&
aUrl
const
nsACString
&
aRequestString
HttpTransactionShell
*
aTransaction
)
{
if
(
nsCOMPtr
<
nsIHttpChannel
>
channel
=
do_QueryReferent
(
weakPtrThis
)
)
{
return
static_cast
<
SimpleHttpChannel
*
>
(
channel
.
get
(
)
)
-
>
OnPush
(
aPushedStreamId
aUrl
aRequestString
aTransaction
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
;
}
EnsureRequestContext
(
)
;
rv
=
mTransaction
-
>
Init
(
mCaps
mConnectionInfo
&
mRequestHead
mUploadStream
mReqContentLength
mUploadStreamHasHeaders
GetCurrentThreadEventTarget
(
)
callbacks
this
mTopLevelOuterContentWindowId
HttpTrafficCategory
:
:
eInvalid
mRequestContext
mClassOfService
mInitialRwin
mResponseTimeoutEnabled
mChannelId
nullptr
std
:
:
move
(
pushCallback
)
mTransWithPushedStream
mPushedStreamId
)
;
mTransWithPushedStream
=
nullptr
;
if
(
NS_FAILED
(
rv
)
)
{
mTransaction
=
nullptr
;
return
rv
;
}
return
rv
;
}
void
SimpleHttpChannel
:
:
SetPushedStreamTransactionAndId
(
HttpTransactionShell
*
aTransWithPushedStream
uint32_t
aPushedStreamId
)
{
MOZ_ASSERT
(
!
mTransWithPushedStream
)
;
LOG
(
(
"
SimpleHttpChannel
:
:
SetPushedStreamTransaction
[
this
=
%
p
]
trans
=
%
p
"
this
aTransWithPushedStream
)
)
;
mTransWithPushedStream
=
aTransWithPushedStream
;
mPushedStreamId
=
aPushedStreamId
;
}
nsresult
SimpleHttpChannel
:
:
OnPush
(
uint32_t
aPushedStreamId
const
nsACString
&
aUrl
const
nsACString
&
aRequestString
HttpTransactionShell
*
aTransaction
)
{
MOZ_ASSERT
(
aTransaction
)
;
LOG
(
(
"
SimpleHttpChannel
:
:
OnPush
[
this
=
%
p
trans
=
%
p
]
\
n
"
this
aTransaction
)
)
;
MOZ_ASSERT
(
mCaps
&
NS_HTTP_ONPUSH_LISTENER
)
;
nsCOMPtr
<
nsIHttpPushListener
>
pushListener
;
NS_QueryNotificationCallbacks
(
mCallbacks
mLoadGroup
NS_GET_IID
(
nsIHttpPushListener
)
getter_AddRefs
(
pushListener
)
)
;
if
(
!
pushListener
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
OnPush
[
this
=
%
p
]
notification
callbacks
do
not
"
"
implement
nsIHttpPushListener
\
n
"
this
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIURI
>
pushResource
;
nsresult
rv
;
rv
=
NS_NewURI
(
getter_AddRefs
(
pushResource
)
aUrl
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIChannel
>
pushHttpChannel
;
rv
=
gHttpHandler
-
>
CreateSimpleHttpChannel
(
pushResource
nullptr
0
nullptr
nullptr
getter_AddRefs
(
pushHttpChannel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
pushHttpChannel
-
>
SetLoadFlags
(
mLoadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
SimpleHttpChannel
>
channel
;
CallQueryInterface
(
pushHttpChannel
channel
.
StartAssignment
(
)
)
;
MOZ_ASSERT
(
channel
)
;
if
(
!
channel
)
{
return
NS_ERROR_UNEXPECTED
;
}
channel
-
>
mRequestHead
.
ParseHeaderSet
(
aRequestString
.
BeginReading
(
)
)
;
channel
-
>
mLoadGroup
=
mLoadGroup
;
channel
-
>
mCallbacks
=
mCallbacks
;
channel
-
>
SetPushedStreamTransactionAndId
(
aTransaction
aPushedStreamId
)
;
rv
=
pushListener
-
>
OnPush
(
this
channel
)
;
return
rv
;
}
void
SimpleHttpChannel
:
:
MaybeStartDNSPrefetch
(
)
{
if
(
mConnectionInfo
-
>
UsingHttpProxy
(
)
|
|
(
mLoadFlags
&
(
nsICachingChannel
:
:
LOAD_NO_NETWORK_IO
|
nsICachingChannel
:
:
LOAD_ONLY_FROM_CACHE
)
)
)
{
return
;
}
LOG
(
(
"
SimpleHttpChannel
:
:
MaybeStartDNSPrefetch
[
this
=
%
p
]
"
"
prefetching
%
s
\
n
"
this
mCaps
&
NS_HTTP_REFRESH_DNS
?
"
refresh
requested
"
:
"
"
)
)
;
OriginAttributes
originAttributes
;
mDNSPrefetch
=
new
nsDNSPrefetch
(
mURI
originAttributes
nsIRequest
:
:
GetTRRMode
(
)
this
mTimingEnabled
)
;
mDNSPrefetch
-
>
PrefetchHigh
(
mCaps
&
NS_HTTP_REFRESH_DNS
)
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
OnTransportStatus
(
nsITransport
*
trans
nsresult
status
int64_t
progress
int64_t
progressMax
)
{
return
NS_OK
;
}
nsresult
SimpleHttpChannel
:
:
CallOnStartRequest
(
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
CallOnStartRequest
[
this
=
%
p
]
"
this
)
)
;
if
(
mOnStartRequestCalled
)
{
LOG
(
(
"
CallOnStartRequest
already
invoked
before
"
)
)
;
return
mStatus
;
}
nsresult
rv
=
NS_OK
;
mTracingEnabled
=
false
;
auto
onStartGuard
=
MakeScopeExit
(
[
&
]
{
LOG
(
(
"
calling
mListener
-
>
OnStartRequest
by
ScopeExit
[
this
=
%
p
"
"
listener
=
%
p
]
\
n
"
this
mListener
.
get
(
)
)
)
;
MOZ_ASSERT
(
!
mOnStartRequestCalled
)
;
if
(
mListener
)
{
nsCOMPtr
<
nsIStreamListener
>
deleteProtector
(
mListener
)
;
mOnStartRequestCalled
=
true
;
deleteProtector
-
>
OnStartRequest
(
this
)
;
}
mOnStartRequestCalled
=
true
;
}
)
;
if
(
mResponseHead
&
&
!
mResponseHead
-
>
HasContentCharset
(
)
)
mResponseHead
-
>
SetContentCharset
(
mContentCharsetHint
)
;
LOG
(
(
"
calling
mListener
-
>
OnStartRequest
[
this
=
%
p
listener
=
%
p
]
\
n
"
this
mListener
.
get
(
)
)
)
;
onStartGuard
.
release
(
)
;
if
(
mListener
)
{
MOZ_ASSERT
(
!
mOnStartRequestCalled
"
We
should
not
call
OsStartRequest
twice
"
)
;
nsCOMPtr
<
nsIStreamListener
>
deleteProtector
(
mListener
)
;
mOnStartRequestCalled
=
true
;
rv
=
deleteProtector
-
>
OnStartRequest
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
else
{
NS_WARNING
(
"
OnStartRequest
skipped
because
of
null
listener
"
)
;
mOnStartRequestCalled
=
true
;
}
return
NS_OK
;
}
void
SimpleHttpChannel
:
:
ProcessAltService
(
)
{
if
(
!
mAllowAltSvc
)
{
return
;
}
if
(
!
gHttpHandler
-
>
AllowAltSvc
(
)
|
|
(
mCaps
&
NS_HTTP_DISALLOW_SPDY
)
)
{
return
;
}
nsAutoCString
scheme
;
mURI
-
>
GetScheme
(
scheme
)
;
bool
isHttp
=
scheme
.
EqualsLiteral
(
"
http
"
)
;
if
(
!
isHttp
&
&
!
scheme
.
EqualsLiteral
(
"
https
"
)
)
{
return
;
}
nsAutoCString
altSvc
;
Unused
<
<
mResponseHead
-
>
GetHeader
(
nsHttp
:
:
Alternate_Service
altSvc
)
;
if
(
altSvc
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
nsHttp
:
:
IsReasonableHeaderValue
(
altSvc
)
)
{
LOG
(
(
"
Alt
-
Svc
Response
Header
seems
unreasonable
-
skipping
\
n
"
)
)
;
return
;
}
nsAutoCString
originHost
;
int32_t
originPort
=
80
;
mURI
-
>
GetPort
(
&
originPort
)
;
if
(
NS_FAILED
(
mURI
-
>
GetAsciiHost
(
originHost
)
)
)
{
return
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
nsCOMPtr
<
nsProxyInfo
>
proxyInfo
;
NS_NewNotificationCallbacksAggregation
(
mCallbacks
mLoadGroup
getter_AddRefs
(
callbacks
)
)
;
if
(
mProxyInfo
)
{
proxyInfo
=
do_QueryInterface
(
mProxyInfo
)
;
}
OriginAttributes
originAttributes
;
NS_GetOriginAttributes
(
this
originAttributes
)
;
AltSvcMapping
:
:
ProcessHeader
(
altSvc
scheme
originHost
originPort
mUsername
GetTopWindowOrigin
(
)
mPrivateBrowsing
IsIsolated
(
)
callbacks
proxyInfo
mCaps
&
NS_HTTP_DISALLOW_SPDY
originAttributes
)
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
OnStartRequest
(
nsIRequest
*
request
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
OnStartRequest
[
this
=
%
p
request
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
request
static_cast
<
uint32_t
>
(
static_cast
<
nsresult
>
(
mStatus
)
)
)
)
;
if
(
!
(
mCanceled
|
|
NS_FAILED
(
mStatus
)
)
)
{
nsresult
status
;
request
-
>
GetStatus
(
&
status
)
;
mStatus
=
status
;
}
MOZ_ASSERT
(
request
=
=
mTransactionPump
"
Unexpected
request
"
)
;
mAfterOnStartRequestBegun
=
true
;
if
(
mTransaction
)
{
if
(
!
mSecurityInfo
)
{
mSecurityInfo
=
mTransaction
-
>
SecurityInfo
(
)
;
}
}
if
(
NS_SUCCEEDED
(
mStatus
)
&
&
mTransaction
)
{
mResponseHead
=
mTransaction
-
>
TakeResponseHead
(
)
;
if
(
mResponseHead
)
{
uint32_t
httpStatus
=
mResponseHead
-
>
Status
(
)
;
if
(
(
httpStatus
<
500
)
&
&
(
httpStatus
!
=
421
)
&
&
(
httpStatus
!
=
407
)
)
{
ProcessAltService
(
)
;
}
}
else
{
NS_WARNING
(
"
No
response
head
in
OnStartRequest
"
)
;
}
}
if
(
!
mListener
)
{
MOZ_ASSERT_UNREACHABLE
(
"
mListener
is
null
"
)
;
return
NS_OK
;
}
return
CallOnStartRequest
(
)
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
OnDataAvailable
(
nsIRequest
*
request
nsIInputStream
*
input
uint64_t
offset
uint32_t
count
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
OnDataAvailable
[
this
=
%
p
request
=
%
p
offset
=
%
"
PRIu64
"
count
=
%
"
PRIu32
"
]
\
n
"
this
request
offset
count
)
)
;
if
(
mCanceled
)
return
mStatus
;
MOZ_ASSERT
(
mResponseHead
"
No
response
head
in
ODA
!
!
"
)
;
if
(
mListener
)
{
return
mListener
-
>
OnDataAvailable
(
this
input
offset
count
)
;
}
return
NS_ERROR_ABORT
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
OnStopRequest
(
nsIRequest
*
request
nsresult
status
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
OnStopRequest
[
this
=
%
p
request
=
%
p
status
=
%
"
PRIx32
"
]
\
n
"
this
request
static_cast
<
uint32_t
>
(
status
)
)
)
;
if
(
mCanceled
|
|
NS_FAILED
(
mStatus
)
)
status
=
mStatus
;
mTransactionTimings
=
mTransaction
-
>
Timings
(
)
;
mTransaction
=
nullptr
;
mTransactionPump
=
nullptr
;
if
(
mListener
)
{
LOG
(
(
"
SimpleHttpChannel
%
p
calling
OnStopRequest
\
n
"
this
)
)
;
MOZ_ASSERT
(
mOnStartRequestCalled
"
OnStartRequest
should
be
called
before
OnStopRequest
"
)
;
MOZ_ASSERT
(
!
mOnStopRequestCalled
"
We
should
not
call
OnStopRequest
twice
"
)
;
mOnStopRequestCalled
=
true
;
mListener
-
>
OnStopRequest
(
this
status
)
;
}
mOnStopRequestCalled
=
true
;
mDNSPrefetch
=
nullptr
;
if
(
mLoadGroup
)
{
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
status
)
;
}
ReleaseListeners
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
OnLookupComplete
(
nsICancelable
*
request
nsIDNSRecord
*
rec
nsresult
status
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
OnLookupComplete
[
this
=
%
p
]
prefetch
complete
%
s
:
"
"
%
s
status
[
0x
%
"
PRIx32
"
]
\
n
"
this
mCaps
&
NS_HTTP_REFRESH_DNS
?
"
refresh
requested
"
:
"
"
NS_SUCCEEDED
(
status
)
?
"
success
"
:
"
failure
"
static_cast
<
uint32_t
>
(
status
)
)
)
;
if
(
mDNSPrefetch
&
&
mDNSPrefetch
-
>
TimingsValid
(
)
&
&
mTransaction
)
{
TimeStamp
connectStart
=
mTransaction
-
>
GetConnectStart
(
)
;
TimeStamp
requestStart
=
mTransaction
-
>
GetRequestStart
(
)
;
if
(
requestStart
.
IsNull
(
)
&
&
connectStart
.
IsNull
(
)
)
{
mTransaction
-
>
SetDomainLookupStart
(
mDNSPrefetch
-
>
StartTimestamp
(
)
)
;
mTransaction
-
>
SetDomainLookupEnd
(
mDNSPrefetch
-
>
EndTimestamp
(
)
)
;
}
}
mDNSPrefetch
=
nullptr
;
if
(
mCaps
&
NS_HTTP_REFRESH_DNS
)
{
mCaps
&
=
~
NS_HTTP_REFRESH_DNS
;
if
(
mTransaction
)
{
mTransaction
-
>
SetDNSWasRefreshed
(
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
OnLookupByTypeComplete
(
nsICancelable
*
aRequest
nsIDNSByTypeRecord
*
aRes
nsresult
aStatus
)
{
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
LogBlockedCORSRequest
(
const
nsAString
&
aMessage
const
nsACString
&
aCategory
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
LogMimeTypeMismatch
(
const
nsACString
&
aMessageName
bool
aWarning
const
nsAString
&
aURL
const
nsAString
&
aContentType
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
SetupFallbackChannel
(
const
char
*
aFallbackKey
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
SetNotificationCallbacks
(
nsIInterfaceRequestor
*
aCallbacks
)
{
mCallbacks
=
aCallbacks
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
SetPriority
(
int32_t
value
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
void
SimpleHttpChannel
:
:
OnClassOfServiceUpdated
(
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
OnClassOfServiceUpdated
this
=
%
p
cos
=
%
u
"
this
mClassOfService
)
)
;
if
(
mTransaction
)
{
gHttpHandler
-
>
UpdateClassOfServiceOnTransaction
(
mTransaction
mClassOfService
)
;
}
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
SetClassFlags
(
uint32_t
inFlags
)
{
uint32_t
previous
=
mClassOfService
;
mClassOfService
=
inFlags
;
if
(
previous
!
=
mClassOfService
)
{
OnClassOfServiceUpdated
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
AddClassFlags
(
uint32_t
inFlags
)
{
uint32_t
previous
=
mClassOfService
;
mClassOfService
|
=
inFlags
;
if
(
previous
!
=
mClassOfService
)
{
OnClassOfServiceUpdated
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
ClearClassFlags
(
uint32_t
inFlags
)
{
uint32_t
previous
=
mClassOfService
;
mClassOfService
&
=
~
inFlags
;
if
(
previous
!
=
mClassOfService
)
{
OnClassOfServiceUpdated
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
ResumeAt
(
uint64_t
aStartPos
const
nsACString
&
aEntityID
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
void
SimpleHttpChannel
:
:
DoAsyncAbort
(
nsresult
aStatus
)
{
Unused
<
<
AsyncAbort
(
aStatus
)
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetProxyInfo
(
nsIProxyInfo
*
*
result
)
{
if
(
!
mConnectionInfo
)
*
result
=
mProxyInfo
;
else
*
result
=
mConnectionInfo
-
>
ProxyInfo
(
)
;
NS_IF_ADDREF
(
*
result
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetHttpProxyConnectResponseCode
(
int32_t
*
aResponseCode
)
{
NS_ENSURE_ARG_POINTER
(
aResponseCode
)
;
*
aResponseCode
=
-
1
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetLoadFlags
(
nsLoadFlags
*
aLoadFlags
)
{
return
HttpBaseChannel
:
:
GetLoadFlags
(
aLoadFlags
)
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
SetLoadFlags
(
nsLoadFlags
aLoadFlags
)
{
if
(
aLoadFlags
&
(
nsICachingChannel
:
:
LOAD_ONLY_FROM_CACHE
|
LOAD_FROM_CACHE
|
nsICachingChannel
:
:
LOAD_NO_NETWORK_IO
|
nsICachingChannel
:
:
LOAD_CHECK_OFFLINE_CACHE
)
)
{
MOZ_ASSERT
(
false
"
Wrong
load
flags
!
"
)
;
return
NS_ERROR_FAILURE
;
}
return
HttpBaseChannel
:
:
SetLoadFlags
(
aLoadFlags
)
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetURI
(
nsIURI
*
*
aURI
)
{
return
HttpBaseChannel
:
:
GetURI
(
aURI
)
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetNotificationCallbacks
(
nsIInterfaceRequestor
*
*
aCallbacks
)
{
return
HttpBaseChannel
:
:
GetNotificationCallbacks
(
aCallbacks
)
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetLoadGroup
(
nsILoadGroup
*
*
aLoadGroup
)
{
return
HttpBaseChannel
:
:
GetLoadGroup
(
aLoadGroup
)
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetRequestMethod
(
nsACString
&
aMethod
)
{
return
HttpBaseChannel
:
:
GetRequestMethod
(
aMethod
)
;
}
void
SimpleHttpChannel
:
:
DoNotifyListener
(
)
{
LOG
(
(
"
SimpleHttpChannel
:
:
DoNotifyListener
this
=
%
p
"
this
)
)
;
if
(
!
mAfterOnStartRequestBegun
)
{
mAfterOnStartRequestBegun
=
true
;
}
if
(
mListener
&
&
!
mOnStartRequestCalled
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
=
mListener
;
mOnStartRequestCalled
=
true
;
listener
-
>
OnStartRequest
(
this
)
;
}
mOnStartRequestCalled
=
true
;
mIsPending
=
false
;
if
(
mListener
&
&
!
mOnStopRequestCalled
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
=
mListener
;
mOnStopRequestCalled
=
true
;
listener
-
>
OnStopRequest
(
this
mStatus
)
;
}
mOnStopRequestCalled
=
true
;
ReleaseListeners
(
)
;
DoNotifyListenerCleanup
(
)
;
}
void
SimpleHttpChannel
:
:
DoNotifyListenerCleanup
(
)
{
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetDomainLookupStart
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
*
_retval
=
mTransaction
-
>
GetDomainLookupStart
(
)
;
else
*
_retval
=
mTransactionTimings
.
domainLookupStart
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetDomainLookupEnd
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
*
_retval
=
mTransaction
-
>
GetDomainLookupEnd
(
)
;
else
*
_retval
=
mTransactionTimings
.
domainLookupEnd
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetConnectStart
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
*
_retval
=
mTransaction
-
>
GetConnectStart
(
)
;
else
*
_retval
=
mTransactionTimings
.
connectStart
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetTcpConnectEnd
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
*
_retval
=
mTransaction
-
>
GetTcpConnectEnd
(
)
;
else
*
_retval
=
mTransactionTimings
.
tcpConnectEnd
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetSecureConnectionStart
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
*
_retval
=
mTransaction
-
>
GetSecureConnectionStart
(
)
;
else
*
_retval
=
mTransactionTimings
.
secureConnectionStart
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetConnectEnd
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
*
_retval
=
mTransaction
-
>
GetConnectEnd
(
)
;
else
*
_retval
=
mTransactionTimings
.
connectEnd
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetRequestStart
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
*
_retval
=
mTransaction
-
>
GetRequestStart
(
)
;
else
*
_retval
=
mTransactionTimings
.
requestStart
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetResponseStart
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
*
_retval
=
mTransaction
-
>
GetResponseStart
(
)
;
else
*
_retval
=
mTransactionTimings
.
responseStart
;
return
NS_OK
;
}
NS_IMETHODIMP
SimpleHttpChannel
:
:
GetResponseEnd
(
TimeStamp
*
_retval
)
{
if
(
mTransaction
)
*
_retval
=
mTransaction
-
>
GetResponseEnd
(
)
;
else
*
_retval
=
mTransactionTimings
.
responseEnd
;
return
NS_OK
;
}
}
}
