#
include
"
HttpLog
.
h
"
#
include
"
Http2Session
.
h
"
#
include
"
nsHttp
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsHttpRequestHead
.
h
"
#
include
"
nsISocketProvider
.
h
"
#
include
"
nsSocketProviderService
.
h
"
#
include
"
nsISSLSocketControl
.
h
"
#
include
"
nsISocketTransport
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsNetAddr
.
h
"
#
include
"
prerror
.
h
"
#
include
"
prio
.
h
"
#
include
"
SocketWrapper
.
h
"
#
include
"
TLSFilterTransaction
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsSocketTransport2
.
h
"
#
include
"
nsSocketTransportService2
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
if
defined
(
FUZZING
)
#
include
"
FuzzySecurityInfo
.
h
"
#
include
"
mozilla
/
StaticPrefs_fuzzing
.
h
"
#
endif
namespace
mozilla
{
namespace
net
{
static
PRDescIdentity
sLayerIdentity
;
static
PRIOMethods
sLayerMethods
;
static
PRIOMethods
*
sLayerMethodsPtr
=
nullptr
;
TLSFilterTransaction
:
:
TLSFilterTransaction
(
nsAHttpTransaction
*
aWrapped
const
char
*
aTLSHost
int32_t
aTLSPort
nsAHttpSegmentReader
*
aReader
nsAHttpSegmentWriter
*
aWriter
)
:
mTransaction
(
aWrapped
)
mEncryptedTextUsed
(
0
)
mEncryptedTextSize
(
0
)
mSegmentReader
(
aReader
)
mSegmentWriter
(
aWriter
)
mFilterReadCode
(
NS_ERROR_NOT_INITIALIZED
)
mFilterReadAmount
(
0
)
mInOnReadSegment
(
false
)
mForce
(
false
)
mReadSegmentReturnValue
(
NS_OK
)
mCloseReason
(
NS_ERROR_UNEXPECTED
)
mNudgeCounter
(
0
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
TLSFilterTransaction
ctor
%
p
\
n
"
this
)
)
;
nsCOMPtr
<
nsISocketProvider
>
provider
;
nsCOMPtr
<
nsISocketProviderService
>
spserv
=
nsSocketProviderService
:
:
GetOrCreate
(
)
;
if
(
spserv
)
{
spserv
-
>
GetSocketProvider
(
"
ssl
"
getter_AddRefs
(
provider
)
)
;
}
if
(
!
sLayerMethodsPtr
)
{
sLayerIdentity
=
PR_GetUniqueIdentity
(
"
TLSFilterTransaction
Layer
"
)
;
sLayerMethods
=
*
PR_GetDefaultIOMethods
(
)
;
sLayerMethods
.
getpeername
=
GetPeerName
;
sLayerMethods
.
getsocketoption
=
GetSocketOption
;
sLayerMethods
.
setsocketoption
=
SetSocketOption
;
sLayerMethods
.
read
=
FilterRead
;
sLayerMethods
.
write
=
FilterWrite
;
sLayerMethods
.
send
=
FilterSend
;
sLayerMethods
.
recv
=
FilterRecv
;
sLayerMethods
.
close
=
FilterClose
;
sLayerMethodsPtr
=
&
sLayerMethods
;
}
mFD
=
PR_CreateIOLayerStub
(
sLayerIdentity
&
sLayerMethods
)
;
bool
addTLSLayer
=
true
;
#
ifdef
FUZZING
addTLSLayer
=
!
StaticPrefs
:
:
fuzzing_necko_enabled
(
)
;
if
(
!
addTLSLayer
)
{
SOCKET_LOG
(
(
"
Skipping
TLS
layer
in
TLSFilterTransaction
for
fuzzing
.
\
n
"
)
)
;
mSecInfo
=
static_cast
<
nsISupports
*
>
(
static_cast
<
nsISSLSocketControl
*
>
(
new
FuzzySecurityInfo
(
)
)
)
;
}
#
endif
if
(
provider
&
&
mFD
)
{
mFD
-
>
secret
=
reinterpret_cast
<
PRFilePrivate
*
>
(
this
)
;
if
(
addTLSLayer
)
{
provider
-
>
AddToSocket
(
PR_AF_INET
aTLSHost
aTLSPort
nullptr
OriginAttributes
(
)
0
0
mFD
getter_AddRefs
(
mSecInfo
)
)
;
}
}
if
(
mTransaction
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
mTransaction
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
nsCOMPtr
<
nsISSLSocketControl
>
secCtrl
(
do_QueryInterface
(
mSecInfo
)
)
;
if
(
secCtrl
)
{
secCtrl
-
>
SetNotificationCallbacks
(
callbacks
)
;
}
}
}
TLSFilterTransaction
:
:
~
TLSFilterTransaction
(
)
{
LOG
(
(
"
TLSFilterTransaction
dtor
%
p
\
n
"
this
)
)
;
mInOnReadSegment
=
true
;
Cleanup
(
)
;
}
void
TLSFilterTransaction
:
:
Cleanup
(
)
{
LOG
(
(
"
TLSFilterTransaction
:
:
Cleanup
%
p
"
this
)
)
;
if
(
mTransaction
)
{
mTransaction
-
>
Close
(
NS_ERROR_ABORT
)
;
mTransaction
=
nullptr
;
}
if
(
mFD
)
{
PR_Close
(
mFD
)
;
mFD
=
nullptr
;
}
mSecInfo
=
nullptr
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
}
void
TLSFilterTransaction
:
:
Close
(
nsresult
aReason
)
{
LOG
(
(
"
TLSFilterTransaction
:
:
Close
%
p
%
"
PRIx32
this
static_cast
<
uint32_t
>
(
aReason
)
)
)
;
if
(
!
mTransaction
)
{
return
;
}
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
mTransaction
-
>
Close
(
aReason
)
;
mTransaction
=
nullptr
;
mCloseReason
=
NS_FAILED
(
aReason
)
?
aReason
:
NS_BASE_STREAM_CLOSED
;
}
nsresult
TLSFilterTransaction
:
:
OnReadSegment
(
const
char
*
aData
uint32_t
aCount
uint32_t
*
outCountRead
)
{
LOG
(
(
"
TLSFilterTransaction
%
p
OnReadSegment
%
d
(
buffered
%
d
)
\
n
"
this
aCount
mEncryptedTextUsed
)
)
;
mReadSegmentReturnValue
=
NS_OK
;
MOZ_ASSERT
(
mSegmentReader
)
;
if
(
!
mSecInfo
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
;
*
outCountRead
=
0
;
if
(
mEncryptedTextUsed
)
{
rv
=
mSegmentReader
-
>
CommitToSegmentSize
(
mEncryptedTextUsed
mForce
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
return
rv
;
}
uint32_t
amt
;
rv
=
mSegmentReader
-
>
OnReadSegment
(
mEncryptedText
.
get
(
)
mEncryptedTextUsed
&
amt
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mEncryptedTextUsed
-
=
amt
;
if
(
mEncryptedTextUsed
)
{
memmove
(
mEncryptedText
.
get
(
)
&
mEncryptedText
[
amt
]
mEncryptedTextUsed
)
;
return
NS_OK
;
}
}
EnsureBuffer
(
mEncryptedText
aCount
+
4096
0
mEncryptedTextSize
)
;
AutoRestore
<
bool
>
inOnReadSegment
(
mInOnReadSegment
)
;
mInOnReadSegment
=
true
;
while
(
aCount
>
0
)
{
int32_t
written
=
PR_Write
(
mFD
aData
aCount
)
;
LOG
(
(
"
TLSFilterTransaction
%
p
OnReadSegment
PRWrite
(
%
d
)
=
%
d
%
d
\
n
"
this
aCount
written
PR_GetError
(
)
=
=
PR_WOULD_BLOCK_ERROR
)
)
;
if
(
written
<
1
)
{
if
(
*
outCountRead
)
{
return
NS_OK
;
}
PRErrorCode
code
=
PR_GetError
(
)
;
mReadSegmentReturnValue
=
ErrorAccordingToNSPR
(
code
)
;
return
mReadSegmentReturnValue
;
}
aCount
-
=
written
;
aData
+
=
written
;
*
outCountRead
+
=
written
;
mNudgeCounter
=
0
;
}
LOG
(
(
"
TLSFilterTransaction
%
p
OnReadSegment2
(
buffered
%
d
)
\
n
"
this
mEncryptedTextUsed
)
)
;
uint32_t
amt
=
0
;
if
(
mEncryptedTextUsed
)
{
rv
=
mSegmentReader
-
>
CommitToSegmentSize
(
mEncryptedTextUsed
mForce
)
;
if
(
rv
!
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
rv
=
mSegmentReader
-
>
OnReadSegment
(
mEncryptedText
.
get
(
)
mEncryptedTextUsed
&
amt
)
;
}
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
if
(
Connection
(
)
)
{
Connection
(
)
-
>
TransactionHasDataToWrite
(
this
)
;
}
return
NS_OK
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
amt
=
=
mEncryptedTextUsed
)
{
mEncryptedText
=
nullptr
;
mEncryptedTextUsed
=
0
;
mEncryptedTextSize
=
0
;
}
else
{
memmove
(
mEncryptedText
.
get
(
)
&
mEncryptedText
[
amt
]
mEncryptedTextUsed
-
amt
)
;
mEncryptedTextUsed
-
=
amt
;
}
return
NS_OK
;
}
int32_t
TLSFilterTransaction
:
:
FilterOutput
(
const
char
*
aBuf
int32_t
aAmount
)
{
EnsureBuffer
(
mEncryptedText
mEncryptedTextUsed
+
aAmount
mEncryptedTextUsed
mEncryptedTextSize
)
;
memcpy
(
&
mEncryptedText
[
mEncryptedTextUsed
]
aBuf
aAmount
)
;
mEncryptedTextUsed
+
=
aAmount
;
LOG
(
(
"
TLSFilterTransaction
:
:
FilterOutput
%
p
%
d
buffered
=
%
u
mSegmentReader
=
%
p
"
this
aAmount
mEncryptedTextUsed
mSegmentReader
)
)
;
if
(
!
mInOnReadSegment
)
{
uint32_t
notUsed
;
Unused
<
<
OnReadSegment
(
"
"
0
&
notUsed
)
;
}
return
aAmount
;
}
nsresult
TLSFilterTransaction
:
:
CommitToSegmentSize
(
uint32_t
size
bool
forceCommitment
)
{
if
(
!
mSegmentReader
)
{
return
NS_ERROR_FAILURE
;
}
mForce
=
forceCommitment
;
return
mSegmentReader
-
>
CommitToSegmentSize
(
size
+
1024
forceCommitment
)
;
}
nsresult
TLSFilterTransaction
:
:
OnWriteSegment
(
char
*
aData
uint32_t
aCount
uint32_t
*
outCountRead
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mSegmentWriter
)
;
LOG
(
(
"
TLSFilterTransaction
:
:
OnWriteSegment
%
p
max
=
%
d
\
n
"
this
aCount
)
)
;
if
(
!
mSecInfo
)
{
return
NS_ERROR_FAILURE
;
}
mFilterReadCode
=
NS_OK
;
mFilterReadAmount
=
0
;
int32_t
bytesRead
=
PR_Read
(
mFD
aData
aCount
)
;
if
(
bytesRead
=
=
-
1
)
{
PRErrorCode
code
=
PR_GetError
(
)
;
if
(
code
=
=
PR_WOULD_BLOCK_ERROR
)
{
LOG
(
(
"
TLSFilterTransaction
:
:
OnWriteSegment
%
p
PR_Read
would
block
"
"
actual
read
:
%
d
\
n
"
this
mFilterReadAmount
)
)
;
if
(
mFilterReadAmount
=
=
0
&
&
NS_SUCCEEDED
(
mFilterReadCode
)
)
{
mFilterReadCode
=
NS_BASE_STREAM_WOULD_BLOCK
;
}
return
NS_BASE_STREAM_WOULD_BLOCK
;
}
if
(
NS_SUCCEEDED
(
mFilterReadCode
)
)
{
mFilterReadCode
=
ErrorAccordingToNSPR
(
code
)
;
LOG
(
(
"
TLSFilterTransaction
:
:
OnWriteSegment
%
p
nss
error
%
"
PRIx32
"
.
\
n
"
this
static_cast
<
uint32_t
>
(
mFilterReadCode
)
)
)
;
}
return
mFilterReadCode
;
}
*
outCountRead
=
bytesRead
;
if
(
NS_SUCCEEDED
(
mFilterReadCode
)
&
&
!
bytesRead
)
{
LOG
(
(
"
TLSFilterTransaction
:
:
OnWriteSegment
%
p
"
"
Second
layer
of
TLS
stripping
results
in
STREAM_CLOSED
\
n
"
this
)
)
;
mFilterReadCode
=
NS_BASE_STREAM_CLOSED
;
}
LOG
(
(
"
TLSFilterTransaction
:
:
OnWriteSegment
%
p
rv
=
%
"
PRIx32
"
didread
=
%
d
"
"
2
layers
of
ssl
stripped
to
plaintext
\
n
"
this
static_cast
<
uint32_t
>
(
mFilterReadCode
)
bytesRead
)
)
;
return
mFilterReadCode
;
}
int32_t
TLSFilterTransaction
:
:
FilterInput
(
char
*
aBuf
int32_t
aAmount
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mSegmentWriter
)
;
LOG
(
(
"
TLSFilterTransaction
:
:
FilterInput
max
=
%
d
\
n
"
aAmount
)
)
;
uint32_t
outCountRead
=
0
;
mFilterReadCode
=
mSegmentWriter
-
>
OnWriteSegment
(
aBuf
aAmount
&
outCountRead
)
;
if
(
NS_SUCCEEDED
(
mFilterReadCode
)
&
&
outCountRead
)
{
LOG
(
(
"
TLSFilterTransaction
:
:
FilterInput
rv
=
%
"
PRIx32
"
read
=
%
d
input
from
net
"
"
1
layer
stripped
1
still
on
\
n
"
static_cast
<
uint32_t
>
(
mFilterReadCode
)
outCountRead
)
)
;
if
(
mReadSegmentReturnValue
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
mNudgeCounter
=
0
;
}
mFilterReadAmount
+
=
outCountRead
;
}
if
(
mFilterReadCode
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
PR_SetError
(
PR_WOULD_BLOCK_ERROR
0
)
;
return
-
1
;
}
return
outCountRead
;
}
nsresult
TLSFilterTransaction
:
:
ReadSegments
(
nsAHttpSegmentReader
*
aReader
uint32_t
aCount
uint32_t
*
outCountRead
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
TLSFilterTransaction
:
:
ReadSegments
%
p
max
=
%
d
\
n
"
this
aCount
)
)
;
if
(
!
mTransaction
)
{
return
mCloseReason
;
}
mReadSegmentReturnValue
=
NS_OK
;
mSegmentReader
=
aReader
;
nsresult
rv
=
mTransaction
-
>
ReadSegments
(
this
aCount
outCountRead
)
;
LOG
(
(
"
TLSFilterTransaction
%
p
called
trans
-
>
ReadSegments
rv
=
%
"
PRIx32
"
%
d
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
*
outCountRead
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
mReadSegmentReturnValue
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
)
{
LOG
(
(
"
TLSFilterTransaction
%
p
read
segment
blocked
found
rv
=
%
"
PRIx32
"
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
Connection
(
)
)
{
Unused
<
<
Connection
(
)
-
>
ForceSend
(
)
;
}
}
return
NS_SUCCEEDED
(
rv
)
?
mReadSegmentReturnValue
:
rv
;
}
nsresult
TLSFilterTransaction
:
:
WriteSegmentsAgain
(
nsAHttpSegmentWriter
*
aWriter
uint32_t
aCount
uint32_t
*
outCountWritten
bool
*
again
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
TLSFilterTransaction
:
:
WriteSegmentsAgain
%
p
max
=
%
d
\
n
"
this
aCount
)
)
;
if
(
!
mTransaction
)
{
return
mCloseReason
;
}
mSegmentWriter
=
aWriter
;
nsresult
rv
=
mTransaction
-
>
WriteSegmentsAgain
(
this
aCount
outCountWritten
again
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
(
*
outCountWritten
)
&
&
NS_FAILED
(
mFilterReadCode
)
)
{
rv
=
mFilterReadCode
;
if
(
Connection
(
)
&
&
(
mFilterReadCode
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
)
{
Unused
<
<
Connection
(
)
-
>
ResumeRecv
(
)
;
}
}
LOG
(
(
"
TLSFilterTransaction
%
p
called
trans
-
>
WriteSegments
rv
=
%
"
PRIx32
"
%
d
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
*
outCountWritten
)
)
;
return
rv
;
}
nsresult
TLSFilterTransaction
:
:
WriteSegments
(
nsAHttpSegmentWriter
*
aWriter
uint32_t
aCount
uint32_t
*
outCountWritten
)
{
bool
again
=
false
;
return
WriteSegmentsAgain
(
aWriter
aCount
outCountWritten
&
again
)
;
}
nsresult
TLSFilterTransaction
:
:
GetTransactionSecurityInfo
(
nsISupports
*
*
outSecInfo
)
{
if
(
!
mSecInfo
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISupports
>
temp
(
mSecInfo
)
;
temp
.
forget
(
outSecInfo
)
;
return
NS_OK
;
}
nsresult
TLSFilterTransaction
:
:
NudgeTunnel
(
NudgeTunnelCallback
*
aCallback
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
TLSFilterTransaction
%
p
NudgeTunnel
\
n
"
this
)
)
;
mNudgeCallback
=
nullptr
;
if
(
!
mSecInfo
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISSLSocketControl
>
ssl
(
do_QueryInterface
(
mSecInfo
)
)
;
nsresult
rv
=
ssl
?
ssl
-
>
DriveHandshake
(
)
:
NS_ERROR_FAILURE
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
LOG
(
(
"
TLSFilterTransaction
%
p
Fatal
Handshake
Failure
:
%
d
\
n
"
this
PR_GetError
(
)
)
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
notUsed
;
Unused
<
<
OnReadSegment
(
"
"
0
&
notUsed
)
;
uint32_t
counter
=
mNudgeCounter
+
+
;
uint32_t
delay
;
if
(
!
counter
)
{
delay
=
0
;
}
else
if
(
counter
<
8
)
{
delay
=
6
;
}
else
if
(
counter
<
34
)
{
delay
=
17
;
}
else
{
delay
=
51
;
}
if
(
!
mTimer
)
{
mTimer
=
NS_NewTimer
(
)
;
}
mNudgeCallback
=
aCallback
;
if
(
!
mTimer
|
|
NS_FAILED
(
mTimer
-
>
InitWithCallback
(
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
)
)
)
{
return
StartTimerCallback
(
)
;
}
LOG
(
(
"
TLSFilterTransaction
%
p
NudgeTunnel
timer
started
\
n
"
this
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TLSFilterTransaction
:
:
Notify
(
nsITimer
*
timer
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG
(
(
"
TLSFilterTransaction
%
p
NudgeTunnel
notify
\
n
"
this
)
)
;
if
(
timer
!
=
mTimer
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
StartTimerCallback
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
Close
(
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TLSFilterTransaction
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
TLSFilterTransaction
"
)
;
return
NS_OK
;
}
nsresult
TLSFilterTransaction
:
:
StartTimerCallback
(
)
{
LOG
(
(
"
TLSFilterTransaction
%
p
NudgeTunnel
StartTimerCallback
%
p
\
n
"
this
mNudgeCallback
.
get
(
)
)
)
;
if
(
mNudgeCallback
)
{
RefPtr
<
NudgeTunnelCallback
>
cb
(
mNudgeCallback
)
;
mNudgeCallback
=
nullptr
;
return
cb
-
>
OnTunnelNudged
(
this
)
;
}
return
NS_OK
;
}
bool
TLSFilterTransaction
:
:
HasDataToRecv
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
!
mFD
)
{
return
false
;
}
int32_t
n
=
0
;
char
c
;
n
=
PR_Recv
(
mFD
&
c
1
PR_MSG_PEEK
0
)
;
return
n
>
0
;
}
PRStatus
TLSFilterTransaction
:
:
GetPeerName
(
PRFileDesc
*
aFD
PRNetAddr
*
addr
)
{
NetAddr
peeraddr
;
TLSFilterTransaction
*
self
=
reinterpret_cast
<
TLSFilterTransaction
*
>
(
aFD
-
>
secret
)
;
if
(
!
self
-
>
mTransaction
|
|
NS_FAILED
(
self
-
>
mTransaction
-
>
Connection
(
)
-
>
Transport
(
)
-
>
GetPeerAddr
(
&
peeraddr
)
)
)
{
return
PR_FAILURE
;
}
NetAddrToPRNetAddr
(
&
peeraddr
addr
)
;
return
PR_SUCCESS
;
}
PRStatus
TLSFilterTransaction
:
:
GetSocketOption
(
PRFileDesc
*
aFD
PRSocketOptionData
*
aOpt
)
{
if
(
aOpt
-
>
option
=
=
PR_SockOpt_Nonblocking
)
{
aOpt
-
>
value
.
non_blocking
=
PR_TRUE
;
return
PR_SUCCESS
;
}
return
PR_FAILURE
;
}
PRStatus
TLSFilterTransaction
:
:
SetSocketOption
(
PRFileDesc
*
aFD
const
PRSocketOptionData
*
aOpt
)
{
return
PR_FAILURE
;
}
PRStatus
TLSFilterTransaction
:
:
FilterClose
(
PRFileDesc
*
aFD
)
{
return
PR_SUCCESS
;
}
int32_t
TLSFilterTransaction
:
:
FilterWrite
(
PRFileDesc
*
aFD
const
void
*
aBuf
int32_t
aAmount
)
{
TLSFilterTransaction
*
self
=
reinterpret_cast
<
TLSFilterTransaction
*
>
(
aFD
-
>
secret
)
;
return
self
-
>
FilterOutput
(
static_cast
<
const
char
*
>
(
aBuf
)
aAmount
)
;
}
int32_t
TLSFilterTransaction
:
:
FilterSend
(
PRFileDesc
*
aFD
const
void
*
aBuf
int32_t
aAmount
int
PRIntervalTime
)
{
return
FilterWrite
(
aFD
aBuf
aAmount
)
;
}
int32_t
TLSFilterTransaction
:
:
FilterRead
(
PRFileDesc
*
aFD
void
*
aBuf
int32_t
aAmount
)
{
TLSFilterTransaction
*
self
=
reinterpret_cast
<
TLSFilterTransaction
*
>
(
aFD
-
>
secret
)
;
return
self
-
>
FilterInput
(
static_cast
<
char
*
>
(
aBuf
)
aAmount
)
;
}
int32_t
TLSFilterTransaction
:
:
FilterRecv
(
PRFileDesc
*
aFD
void
*
aBuf
int32_t
aAmount
int
PRIntervalTime
)
{
return
FilterRead
(
aFD
aBuf
aAmount
)
;
}
void
TLSFilterTransaction
:
:
SetConnection
(
nsAHttpConnection
*
aConnection
)
{
if
(
!
mTransaction
)
{
return
;
}
mTransaction
-
>
SetConnection
(
aConnection
)
;
}
nsAHttpConnection
*
TLSFilterTransaction
:
:
Connection
(
)
{
if
(
!
mTransaction
)
{
return
nullptr
;
}
return
mTransaction
-
>
Connection
(
)
;
}
void
TLSFilterTransaction
:
:
GetSecurityCallbacks
(
nsIInterfaceRequestor
*
*
outCB
)
{
if
(
!
mTransaction
)
{
return
;
}
mTransaction
-
>
GetSecurityCallbacks
(
outCB
)
;
}
void
TLSFilterTransaction
:
:
OnTransportStatus
(
nsITransport
*
aTransport
nsresult
aStatus
int64_t
aProgress
)
{
if
(
!
mTransaction
)
{
return
;
}
mTransaction
-
>
OnTransportStatus
(
aTransport
aStatus
aProgress
)
;
}
nsHttpConnectionInfo
*
TLSFilterTransaction
:
:
ConnectionInfo
(
)
{
if
(
!
mTransaction
)
{
return
nullptr
;
}
return
mTransaction
-
>
ConnectionInfo
(
)
;
}
bool
TLSFilterTransaction
:
:
IsDone
(
)
{
if
(
!
mTransaction
)
{
return
true
;
}
return
mTransaction
-
>
IsDone
(
)
;
}
nsresult
TLSFilterTransaction
:
:
Status
(
)
{
if
(
!
mTransaction
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
mTransaction
-
>
Status
(
)
;
}
uint32_t
TLSFilterTransaction
:
:
Caps
(
)
{
if
(
!
mTransaction
)
{
return
0
;
}
return
mTransaction
-
>
Caps
(
)
;
}
void
TLSFilterTransaction
:
:
SetProxyConnectFailed
(
)
{
if
(
!
mTransaction
)
{
return
;
}
mTransaction
-
>
SetProxyConnectFailed
(
)
;
}
nsHttpRequestHead
*
TLSFilterTransaction
:
:
RequestHead
(
)
{
if
(
!
mTransaction
)
{
return
nullptr
;
}
return
mTransaction
-
>
RequestHead
(
)
;
}
uint32_t
TLSFilterTransaction
:
:
Http1xTransactionCount
(
)
{
if
(
!
mTransaction
)
{
return
0
;
}
return
mTransaction
-
>
Http1xTransactionCount
(
)
;
}
nsresult
TLSFilterTransaction
:
:
TakeSubTransactions
(
nsTArray
<
RefPtr
<
nsAHttpTransaction
>
>
&
outTransactions
)
{
LOG
(
(
"
TLSFilterTransaction
:
:
TakeSubTransactions
[
this
=
%
p
]
mTransaction
%
p
\
n
"
this
mTransaction
.
get
(
)
)
)
;
if
(
!
mTransaction
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
mTransaction
-
>
TakeSubTransactions
(
outTransactions
)
=
=
NS_ERROR_NOT_IMPLEMENTED
)
{
outTransactions
.
AppendElement
(
mTransaction
)
;
}
mTransaction
=
nullptr
;
return
NS_OK
;
}
nsresult
TLSFilterTransaction
:
:
SetProxiedTransaction
(
nsAHttpTransaction
*
aTrans
nsAHttpTransaction
*
aHttp2ConnectTransaction
)
{
LOG
(
(
"
TLSFilterTransaction
:
:
SetProxiedTransaction
[
this
=
%
p
]
aTrans
=
%
p
"
"
aHttp2ConnectTransaction
=
%
p
\
n
"
this
aTrans
aHttp2ConnectTransaction
)
)
;
mTransaction
=
aTrans
;
mCloseReason
=
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
mTransaction
-
>
GetSecurityCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
nsCOMPtr
<
nsISSLSocketControl
>
secCtrl
(
do_QueryInterface
(
mSecInfo
)
)
;
if
(
secCtrl
&
&
callbacks
)
{
secCtrl
-
>
SetNotificationCallbacks
(
callbacks
)
;
}
mWeakTrans
=
do_GetWeakReference
(
aHttp2ConnectTransaction
)
;
return
NS_OK
;
}
bool
TLSFilterTransaction
:
:
IsNullTransaction
(
)
{
if
(
!
mTransaction
)
{
return
false
;
}
return
mTransaction
-
>
IsNullTransaction
(
)
;
}
NullHttpTransaction
*
TLSFilterTransaction
:
:
QueryNullTransaction
(
)
{
if
(
!
mTransaction
)
{
return
nullptr
;
}
return
mTransaction
-
>
QueryNullTransaction
(
)
;
}
nsHttpTransaction
*
TLSFilterTransaction
:
:
QueryHttpTransaction
(
)
{
if
(
!
mTransaction
)
{
return
nullptr
;
}
return
mTransaction
-
>
QueryHttpTransaction
(
)
;
}
void
TLSFilterTransaction
:
:
newIODriver
(
nsIAsyncInputStream
*
aSocketIn
nsIAsyncOutputStream
*
aSocketOut
nsIAsyncInputStream
*
*
outSocketIn
nsIAsyncOutputStream
*
*
outSocketOut
)
{
SocketInWrapper
*
inputWrapper
=
new
SocketInWrapper
(
aSocketIn
this
)
;
mSegmentWriter
=
inputWrapper
;
nsCOMPtr
<
nsIAsyncInputStream
>
newIn
(
inputWrapper
)
;
newIn
.
forget
(
outSocketIn
)
;
SocketOutWrapper
*
outputWrapper
=
new
SocketOutWrapper
(
aSocketOut
this
)
;
mSegmentReader
=
outputWrapper
;
nsCOMPtr
<
nsIAsyncOutputStream
>
newOut
(
outputWrapper
)
;
newOut
.
forget
(
outSocketOut
)
;
}
Http2ConnectTransaction
*
TLSFilterTransaction
:
:
QueryHttp2ConnectTransaction
(
)
{
if
(
!
mTransaction
)
{
return
nullptr
;
}
return
mTransaction
-
>
QueryHttp2ConnectTransaction
(
)
;
}
NS_IMPL_ISUPPORTS
(
TLSFilterTransaction
nsITimerCallback
nsINamed
)
}
}
