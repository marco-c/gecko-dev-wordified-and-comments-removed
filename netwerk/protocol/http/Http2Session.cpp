#
include
"
HttpLog
.
h
"
#
undef
LOG
#
define
LOG
(
args
)
LOG5
(
args
)
#
undef
LOG_ENABLED
#
define
LOG_ENABLED
(
)
LOG5_ENABLED
(
)
#
include
<
algorithm
>
#
include
"
AltServiceChild
.
h
"
#
include
"
Http2Session
.
h
"
#
include
"
Http2Stream
.
h
"
#
include
"
Http2StreamBase
.
h
"
#
include
"
Http2StreamTunnel
.
h
"
#
include
"
Http2StreamWebSocket
.
h
"
#
include
"
Http2Push
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsHttp
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsHttpConnection
.
h
"
#
include
"
nsIRequestContext
.
h
"
#
include
"
nsISSLSocketControl
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsStandardURL
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
sslerr
.
h
"
#
include
"
sslt
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsSocketTransportService2
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
CacheControlParser
.
h
"
#
include
"
CachePushChecker
.
h
"
#
include
"
LoadContextInfo
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
Http2ConnectTransaction
.
h
"
namespace
mozilla
{
namespace
net
{
NS_IMPL_ADDREF
(
Http2Session
)
NS_IMPL_RELEASE
(
Http2Session
)
NS_INTERFACE_MAP_BEGIN
(
Http2Session
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
Http2Session
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsAHttpConnection
)
NS_INTERFACE_MAP_END
static
void
RemoveStreamFromQueue
(
Http2StreamBase
*
aStream
nsTArray
<
WeakPtr
<
Http2StreamBase
>
>
&
queue
)
{
for
(
const
auto
&
stream
:
Reversed
(
queue
)
)
{
if
(
stream
=
=
aStream
)
{
queue
.
RemoveElement
(
stream
)
;
}
}
}
static
void
AddStreamToQueue
(
Http2StreamBase
*
aStream
nsTArray
<
WeakPtr
<
Http2StreamBase
>
>
&
queue
)
{
if
(
!
queue
.
Contains
(
aStream
)
)
{
queue
.
AppendElement
(
aStream
)
;
}
}
static
already_AddRefed
<
Http2StreamBase
>
GetNextStreamFromQueue
(
nsTArray
<
WeakPtr
<
Http2StreamBase
>
>
&
queue
)
{
while
(
!
queue
.
IsEmpty
(
)
&
&
!
queue
[
0
]
)
{
MOZ_ASSERT
(
false
)
;
queue
.
RemoveElementAt
(
0
)
;
}
if
(
queue
.
IsEmpty
(
)
)
{
return
nullptr
;
}
RefPtr
<
Http2StreamBase
>
stream
=
queue
[
0
]
.
get
(
)
;
queue
.
RemoveElementAt
(
0
)
;
return
stream
.
forget
(
)
;
}
const
uint8_t
Http2Session
:
:
kMagicHello
[
]
=
{
0x50
0x52
0x49
0x20
0x2a
0x20
0x48
0x54
0x54
0x50
0x2f
0x32
0x2e
0x30
0x0d
0x0a
0x0d
0x0a
0x53
0x4d
0x0d
0x0a
0x0d
0x0a
}
;
Http2Session
*
Http2Session
:
:
CreateSession
(
nsISocketTransport
*
aSocketTransport
enum
SpdyVersion
version
bool
attemptingEarlyData
)
{
if
(
!
gHttpHandler
)
{
RefPtr
<
nsHttpHandler
>
handler
=
nsHttpHandler
:
:
GetInstance
(
)
;
Unused
<
<
handler
.
get
(
)
;
}
Http2Session
*
session
=
new
Http2Session
(
aSocketTransport
version
attemptingEarlyData
)
;
session
-
>
SendHello
(
)
;
return
session
;
}
Http2Session
:
:
Http2Session
(
nsISocketTransport
*
aSocketTransport
enum
SpdyVersion
version
bool
attemptingEarlyData
)
:
mSocketTransport
(
aSocketTransport
)
mSegmentReader
(
nullptr
)
mSegmentWriter
(
nullptr
)
mNextStreamID
(
3
)
mLastPushedID
(
0
)
mConcurrentHighWater
(
0
)
mDownstreamState
(
BUFFERING_OPENING_SETTINGS
)
mInputFrameBufferSize
(
kDefaultBufferSize
)
mInputFrameBufferUsed
(
0
)
mInputFrameDataSize
(
0
)
mInputFrameDataRead
(
0
)
mInputFrameFinal
(
false
)
mInputFrameType
(
0
)
mInputFrameFlags
(
0
)
mInputFrameID
(
0
)
mPaddingLength
(
0
)
mInputFrameDataStream
(
nullptr
)
mNeedsCleanup
(
nullptr
)
mDownstreamRstReason
(
NO_HTTP_ERROR
)
mExpectedHeaderID
(
0
)
mExpectedPushPromiseID
(
0
)
mContinuedPromiseStream
(
0
)
mFlatHTTPResponseHeadersOut
(
0
)
mShouldGoAway
(
false
)
mClosed
(
false
)
mCleanShutdown
(
false
)
mReceivedSettings
(
false
)
mTLSProfileConfirmed
(
false
)
mGoAwayReason
(
NO_HTTP_ERROR
)
mClientGoAwayReason
(
UNASSIGNED
)
mPeerGoAwayReason
(
UNASSIGNED
)
mGoAwayID
(
0
)
mOutgoingGoAwayID
(
0
)
mConcurrent
(
0
)
mServerPushedResources
(
0
)
mServerInitialStreamWindow
(
kDefaultRwin
)
mLocalSessionWindow
(
kDefaultRwin
)
mServerSessionWindow
(
kDefaultRwin
)
mInitialRwin
(
ASpdySession
:
:
kInitialRwin
)
mOutputQueueSize
(
kDefaultQueueSize
)
mOutputQueueUsed
(
0
)
mOutputQueueSent
(
0
)
mLastReadEpoch
(
PR_IntervalNow
(
)
)
mPingSentEpoch
(
0
)
mPreviousUsed
(
false
)
mAggregatedHeaderSize
(
0
)
mWaitingForSettingsAck
(
false
)
mGoAwayOnPush
(
false
)
mUseH2Deps
(
false
)
mAttemptingEarlyData
(
attemptingEarlyData
)
mOriginFrameActivated
(
false
)
mCntActivated
(
0
)
mTlsHandshakeFinished
(
false
)
mPeerFailedHandshake
(
false
)
mTrrStreams
(
0
)
mEnableWebsockets
(
false
)
mPeerAllowsWebsockets
(
false
)
mProcessedWaitingWebsockets
(
false
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
static
uint64_t
sSerial
;
mSerial
=
+
+
sSerial
;
LOG3
(
(
"
Http2Session
:
:
Http2Session
%
p
serial
=
0x
%
"
PRIX64
"
\
n
"
this
mSerial
)
)
;
mInputFrameBuffer
=
MakeUnique
<
char
[
]
>
(
mInputFrameBufferSize
)
;
mOutputQueueBuffer
=
MakeUnique
<
char
[
]
>
(
mOutputQueueSize
)
;
mDecompressBuffer
.
SetCapacity
(
kDefaultBufferSize
)
;
mPushAllowance
=
gHttpHandler
-
>
SpdyPushAllowance
(
)
;
mInitialRwin
=
std
:
:
max
(
gHttpHandler
-
>
SpdyPullAllowance
(
)
mPushAllowance
)
;
mMaxConcurrent
=
gHttpHandler
-
>
DefaultSpdyConcurrent
(
)
;
mSendingChunkSize
=
gHttpHandler
-
>
SpdySendingChunkSize
(
)
;
mLastDataReadEpoch
=
mLastReadEpoch
;
mPingThreshold
=
gHttpHandler
-
>
SpdyPingThreshold
(
)
;
mPreviousPingThreshold
=
mPingThreshold
;
mCurrentTopBrowsingContextId
=
gHttpHandler
-
>
ConnMgr
(
)
-
>
CurrentTopBrowsingContextId
(
)
;
mEnableWebsockets
=
StaticPrefs
:
:
network_http_http2_websockets
(
)
;
bool
dumpHpackTables
=
StaticPrefs
:
:
network_http_http2_enable_hpack_dump
(
)
;
mCompressor
.
SetDumpTables
(
dumpHpackTables
)
;
mDecompressor
.
SetDumpTables
(
dumpHpackTables
)
;
}
void
Http2Session
:
:
Shutdown
(
nsresult
aReason
)
{
for
(
const
auto
&
stream
:
mStreamTransactionHash
.
Values
(
)
)
{
ShutdownStream
(
stream
aReason
)
;
}
for
(
auto
&
stream
:
mTunnelStreams
)
{
ShutdownStream
(
stream
aReason
)
;
}
}
void
Http2Session
:
:
ShutdownStream
(
Http2StreamBase
*
aStream
nsresult
aReason
)
{
if
(
mCleanShutdown
&
&
(
aStream
-
>
StreamID
(
)
>
mGoAwayID
|
|
!
aStream
-
>
HasRegisteredID
(
)
)
)
{
CloseStream
(
aStream
NS_ERROR_NET_RESET
)
;
}
else
if
(
aStream
-
>
RecvdData
(
)
)
{
CloseStream
(
aStream
NS_ERROR_NET_PARTIAL_TRANSFER
)
;
}
else
if
(
mGoAwayReason
=
=
INADEQUATE_SECURITY
)
{
CloseStream
(
aStream
NS_ERROR_NET_INADEQUATE_SECURITY
)
;
}
else
if
(
!
mCleanShutdown
&
&
(
mGoAwayReason
!
=
NO_HTTP_ERROR
)
)
{
CloseStream
(
aStream
NS_ERROR_NET_HTTP2_SENT_GOAWAY
)
;
}
else
if
(
!
mCleanShutdown
&
&
SecurityErrorThatMayNeedRestart
(
aReason
)
)
{
CloseStream
(
aStream
aReason
)
;
}
else
{
CloseStream
(
aStream
NS_ERROR_ABORT
)
;
}
}
Http2Session
:
:
~
Http2Session
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
OnSocketThread
(
)
)
;
LOG3
(
(
"
Http2Session
:
:
~
Http2Session
%
p
mDownstreamState
=
%
X
"
this
mDownstreamState
)
)
;
Shutdown
(
NS_OK
)
;
if
(
mTrrStreams
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
DNS_TRR_REQUEST_PER_CONN
mTrrStreams
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_PARALLEL_STREAMS
mConcurrentHighWater
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_REQUEST_PER_CONN_3
mCntActivated
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_SERVER_INITIATED_STREAMS
mServerPushedResources
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_GOAWAY_LOCAL
mClientGoAwayReason
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_GOAWAY_PEER
mPeerGoAwayReason
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTTP2_FAIL_BEFORE_SETTINGS
mPeerFailedHandshake
)
;
}
inline
nsresult
Http2Session
:
:
SessionError
(
enum
errorType
reason
)
{
LOG3
(
(
"
Http2Session
:
:
SessionError
%
p
reason
=
0x
%
x
mPeerGoAwayReason
=
0x
%
x
"
this
reason
mPeerGoAwayReason
)
)
;
mGoAwayReason
=
reason
;
if
(
reason
=
=
INADEQUATE_SECURITY
)
{
return
NS_ERROR_NET_INADEQUATE_SECURITY
;
}
return
NS_ERROR_NET_HTTP2_SENT_GOAWAY
;
}
void
Http2Session
:
:
LogIO
(
Http2Session
*
self
Http2StreamBase
*
stream
const
char
*
label
const
char
*
data
uint32_t
datalen
)
{
if
(
!
LOG5_ENABLED
(
)
)
return
;
LOG5
(
(
"
Http2Session
:
:
LogIO
%
p
stream
=
%
p
id
=
0x
%
X
[
%
s
]
"
self
stream
stream
?
stream
-
>
StreamID
(
)
:
0
label
)
)
;
char
linebuf
[
128
]
;
uint32_t
index
;
char
*
line
=
linebuf
;
linebuf
[
127
]
=
0
;
for
(
index
=
0
;
index
<
datalen
;
+
+
index
)
{
if
(
!
(
index
%
16
)
)
{
if
(
index
)
{
*
line
=
0
;
LOG5
(
(
"
%
s
"
linebuf
)
)
;
}
line
=
linebuf
;
snprintf
(
line
128
"
%
08X
:
"
index
)
;
line
+
=
10
;
}
snprintf
(
line
128
-
(
line
-
linebuf
)
"
%
02X
"
(
reinterpret_cast
<
const
uint8_t
*
>
(
data
)
)
[
index
]
)
;
line
+
=
3
;
}
if
(
index
)
{
*
line
=
0
;
LOG5
(
(
"
%
s
"
linebuf
)
)
;
}
}
using
Http2ControlFx
=
nsresult
(
*
)
(
Http2Session
*
)
;
static
Http2ControlFx
sControlFunctions
[
]
=
{
nullptr
Http2Session
:
:
RecvHeaders
Http2Session
:
:
RecvPriority
Http2Session
:
:
RecvRstStream
Http2Session
:
:
RecvSettings
Http2Session
:
:
RecvPushPromise
Http2Session
:
:
RecvPing
Http2Session
:
:
RecvGoAway
Http2Session
:
:
RecvWindowUpdate
Http2Session
:
:
RecvContinuation
Http2Session
:
:
RecvAltSvc
Http2Session
:
:
RecvUnused
Http2Session
:
:
RecvOrigin
}
;
bool
Http2Session
:
:
RoomForMoreConcurrent
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
return
(
mConcurrent
<
mMaxConcurrent
)
;
}
bool
Http2Session
:
:
RoomForMoreStreams
(
)
{
if
(
mNextStreamID
+
mStreamTransactionHash
.
Count
(
)
*
2
>
kMaxStreamID
)
{
return
false
;
}
return
!
mShouldGoAway
;
}
PRIntervalTime
Http2Session
:
:
IdleTime
(
)
{
return
PR_IntervalNow
(
)
-
mLastDataReadEpoch
;
}
uint32_t
Http2Session
:
:
ReadTimeoutTick
(
PRIntervalTime
now
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
ReadTimeoutTick
%
p
delta
since
last
read
%
ds
\
n
"
this
PR_IntervalToSeconds
(
now
-
mLastReadEpoch
)
)
)
;
if
(
!
mPingThreshold
)
{
return
UINT32_MAX
;
}
if
(
(
now
-
mLastReadEpoch
)
<
mPingThreshold
)
{
if
(
mPingSentEpoch
)
{
mPingSentEpoch
=
0
;
if
(
mPreviousUsed
)
{
mPingThreshold
=
mPreviousPingThreshold
;
mPreviousUsed
=
false
;
}
}
return
PR_IntervalToSeconds
(
mPingThreshold
)
-
PR_IntervalToSeconds
(
now
-
mLastReadEpoch
)
;
}
if
(
mPingSentEpoch
)
{
LOG3
(
(
"
Http2Session
:
:
ReadTimeoutTick
%
p
handle
outstanding
ping
\
n
"
this
)
)
;
if
(
(
now
-
mPingSentEpoch
)
>
=
gHttpHandler
-
>
SpdyPingTimeout
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
ReadTimeoutTick
%
p
Ping
Timer
Exhaustion
\
n
"
this
)
)
;
mPingSentEpoch
=
0
;
Close
(
NS_ERROR_NET_TIMEOUT
)
;
return
UINT32_MAX
;
}
return
1
;
}
LOG3
(
(
"
Http2Session
:
:
ReadTimeoutTick
%
p
generating
ping
\
n
"
this
)
)
;
mPingSentEpoch
=
PR_IntervalNow
(
)
;
if
(
!
mPingSentEpoch
)
{
mPingSentEpoch
=
1
;
}
GeneratePing
(
false
)
;
Unused
<
<
ResumeRecv
(
)
;
Http2PushedStream
*
deleteMe
;
TimeStamp
timestampNow
;
do
{
deleteMe
=
nullptr
;
for
(
uint32_t
index
=
mPushedStreams
.
Length
(
)
;
index
>
0
;
-
-
index
)
{
Http2PushedStream
*
pushedStream
=
mPushedStreams
[
index
-
1
]
;
if
(
timestampNow
.
IsNull
(
)
)
{
timestampNow
=
TimeStamp
:
:
Now
(
)
;
}
if
(
pushedStream
-
>
IsOrphaned
(
timestampNow
)
)
{
LOG3
(
(
"
Http2Session
Timeout
Pushed
Stream
%
p
0x
%
X
\
n
"
this
pushedStream
-
>
StreamID
(
)
)
)
;
deleteMe
=
pushedStream
;
break
;
}
}
if
(
deleteMe
)
CleanupStream
(
deleteMe
NS_ERROR_ABORT
CANCEL_ERROR
)
;
}
while
(
deleteMe
)
;
return
1
;
}
uint32_t
Http2Session
:
:
RegisterStreamID
(
Http2StreamBase
*
stream
uint32_t
aNewID
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mNextStreamID
<
0xfffffff0
"
should
have
stopped
admitting
streams
"
)
;
MOZ_ASSERT
(
!
(
aNewID
&
1
)
"
0
for
autoassign
pull
otherwise
explicit
even
push
assignment
"
)
;
if
(
!
aNewID
)
{
aNewID
=
mNextStreamID
;
MOZ_ASSERT
(
aNewID
&
1
"
pull
ID
must
be
odd
.
"
)
;
mNextStreamID
+
=
2
;
}
LOG1
(
(
"
Http2Session
:
:
RegisterStreamID
session
=
%
p
stream
=
%
p
id
=
0x
%
X
"
"
concurrent
=
%
d
"
this
stream
aNewID
mConcurrent
)
)
;
if
(
aNewID
>
=
kMaxStreamID
)
mShouldGoAway
=
true
;
if
(
mStreamIDHash
.
Contains
(
aNewID
)
)
{
LOG3
(
(
"
New
ID
already
present
\
n
"
)
)
;
MOZ_ASSERT
(
false
"
New
ID
already
present
in
mStreamIDHash
"
)
;
mShouldGoAway
=
true
;
return
kDeadStreamID
;
}
mStreamIDHash
.
InsertOrUpdate
(
aNewID
stream
)
;
if
(
aNewID
&
1
)
{
RefPtr
<
nsHttpConnectionInfo
>
ci
(
stream
-
>
ConnectionInfo
(
)
)
;
if
(
ci
&
&
ci
-
>
GetIsTrrServiceChannel
(
)
)
{
IncrementTrrCounter
(
)
;
}
}
return
aNewID
;
}
bool
Http2Session
:
:
AddStream
(
nsAHttpTransaction
*
aHttpTransaction
int32_t
aPriority
bool
aIsWebsocket
nsIInterfaceRequestor
*
aCallbacks
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
mStreamTransactionHash
.
Contains
(
aHttpTransaction
)
)
{
LOG3
(
(
"
New
transaction
already
present
\
n
"
)
)
;
MOZ_ASSERT
(
false
"
AddStream
duplicate
transaction
pointer
"
)
;
return
false
;
}
if
(
!
mConnection
)
{
mConnection
=
aHttpTransaction
-
>
Connection
(
)
;
}
if
(
!
mFirstHttpTransaction
&
&
!
mTlsHandshakeFinished
)
{
mFirstHttpTransaction
=
aHttpTransaction
-
>
QueryHttpTransaction
(
)
;
LOG3
(
(
"
Http2Session
:
:
AddStream
first
session
=
%
p
trans
=
%
p
"
this
mFirstHttpTransaction
.
get
(
)
)
)
;
}
if
(
mClosed
|
|
mShouldGoAway
)
{
nsHttpTransaction
*
trans
=
aHttpTransaction
-
>
QueryHttpTransaction
(
)
;
if
(
trans
)
{
RefPtr
<
Http2PushedStreamWrapper
>
pushedStreamWrapper
;
pushedStreamWrapper
=
trans
-
>
GetPushedStream
(
)
;
if
(
!
pushedStreamWrapper
|
|
!
pushedStreamWrapper
-
>
GetStream
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
AddStream
%
p
atrans
=
%
p
trans
=
%
p
session
unusable
-
"
"
resched
.
\
n
"
this
aHttpTransaction
trans
)
)
;
aHttpTransaction
-
>
SetConnection
(
nullptr
)
;
nsresult
rv
=
gHttpHandler
-
>
InitiateTransaction
(
trans
trans
-
>
Priority
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
AddStream
%
p
atrans
=
%
p
trans
=
%
p
failed
to
"
"
initiate
"
"
transaction
(
%
08x
)
.
\
n
"
this
aHttpTransaction
trans
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
return
true
;
}
}
}
aHttpTransaction
-
>
SetConnection
(
this
)
;
aHttpTransaction
-
>
OnActivated
(
)
;
if
(
aIsWebsocket
)
{
nsHttpTransaction
*
trans
=
aHttpTransaction
-
>
QueryHttpTransaction
(
)
;
MOZ_ASSERT
(
trans
"
Websocket
without
transaction
?
!
"
)
;
if
(
!
trans
)
{
LOG3
(
(
"
Http2Session
:
:
AddStream
%
p
websocket
without
transaction
.
WAT
?
!
"
this
)
)
;
return
true
;
}
if
(
!
mEnableWebsockets
)
{
LOG3
(
(
"
Http2Session
:
:
AddStream
%
p
Re
-
queuing
websocket
as
h1
due
to
"
"
mEnableWebsockets
=
false
"
this
)
)
;
aHttpTransaction
-
>
SetConnection
(
nullptr
)
;
aHttpTransaction
-
>
DisableSpdy
(
)
;
nsresult
rv
=
gHttpHandler
-
>
InitiateTransaction
(
trans
trans
-
>
Priority
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
AddStream
%
p
failed
to
reinitiate
websocket
"
"
transaction
(
0x
%
08x
)
.
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
return
true
;
}
if
(
!
mPeerAllowsWebsockets
)
{
LOG3
(
(
"
Http2Session
:
:
AddStream
%
p
mPeerAllowsWebsockets
=
false
"
this
)
)
;
if
(
!
mProcessedWaitingWebsockets
)
{
LOG3
(
(
"
Http2Session
:
:
AddStream
%
p
waiting
for
SETTINGS
to
determine
"
"
fate
of
websocket
"
this
)
)
;
mWaitingWebsockets
.
AppendElement
(
aHttpTransaction
)
;
mWaitingWebsocketCallbacks
.
AppendElement
(
aCallbacks
)
;
}
else
{
LOG3
(
(
"
Http2Session
:
:
AddStream
%
p
Re
-
queuing
websocket
as
h1
due
to
"
"
mPeerAllowsWebsockets
=
false
"
this
)
)
;
aHttpTransaction
-
>
SetConnection
(
nullptr
)
;
aHttpTransaction
-
>
DisableSpdy
(
)
;
if
(
trans
)
{
nsresult
rv
=
gHttpHandler
-
>
InitiateTransaction
(
trans
trans
-
>
Priority
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
AddStream
%
p
failed
to
reinitiate
websocket
"
"
transaction
(
%
08x
)
.
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
}
return
true
;
}
LOG3
(
(
"
Http2Session
:
:
AddStream
session
=
%
p
trans
=
%
p
websocket
"
this
aHttpTransaction
)
)
;
CreateWebsocketStream
(
aHttpTransaction
aCallbacks
)
;
return
true
;
}
CreateStream
(
aHttpTransaction
aPriority
Http2StreamBaseType
:
:
Normal
)
;
return
true
;
}
void
Http2Session
:
:
CreateStream
(
nsAHttpTransaction
*
aHttpTransaction
int32_t
aPriority
Http2StreamBaseType
streamType
)
{
RefPtr
<
Http2StreamBase
>
refStream
;
switch
(
streamType
)
{
case
Http2StreamBaseType
:
:
Normal
:
refStream
=
new
Http2Stream
(
aHttpTransaction
this
aPriority
mCurrentTopBrowsingContextId
)
;
break
;
case
Http2StreamBaseType
:
:
WebSocket
:
refStream
=
new
Http2StreamWebSocket
(
aHttpTransaction
this
aPriority
mCurrentTopBrowsingContextId
)
;
break
;
case
Http2StreamBaseType
:
:
Tunnel
:
case
Http2StreamBaseType
:
:
ServerPush
:
MOZ_RELEASE_ASSERT
(
false
)
;
return
;
}
LOG3
(
(
"
Http2Session
:
:
AddStream
session
=
%
p
stream
=
%
p
serial
=
%
"
PRIu64
"
"
"
NextID
=
0x
%
X
(
tentative
)
"
this
refStream
.
get
(
)
mSerial
mNextStreamID
)
)
;
RefPtr
<
Http2StreamBase
>
stream
=
refStream
;
mStreamTransactionHash
.
InsertOrUpdate
(
aHttpTransaction
std
:
:
move
(
refStream
)
)
;
AddStreamToQueue
(
stream
mReadyForWrite
)
;
SetWriteCallbacks
(
)
;
if
(
mSegmentReader
)
{
uint32_t
countRead
;
Unused
<
<
ReadSegments
(
nullptr
kDefaultBufferSize
&
countRead
)
;
}
if
(
!
(
aHttpTransaction
-
>
Caps
(
)
&
NS_HTTP_ALLOW_KEEPALIVE
)
&
&
!
aHttpTransaction
-
>
IsNullTransaction
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
AddStream
%
p
transaction
%
p
forces
keep
-
alive
off
.
\
n
"
this
aHttpTransaction
)
)
;
DontReuse
(
)
;
}
}
already_AddRefed
<
nsHttpConnection
>
Http2Session
:
:
CreateTunnelStream
(
nsAHttpTransaction
*
aHttpTransaction
nsIInterfaceRequestor
*
aCallbacks
PRIntervalTime
aRtt
)
{
RefPtr
<
Http2StreamTunnel
>
refStream
=
new
Http2StreamTunnel
(
this
nsISupportsPriority
:
:
PRIORITY_NORMAL
mCurrentTopBrowsingContextId
aHttpTransaction
-
>
ConnectionInfo
(
)
)
;
RefPtr
<
nsHttpConnection
>
newConn
=
refStream
-
>
CreateHttpConnection
(
aHttpTransaction
aCallbacks
aRtt
)
;
mTunnelStreams
.
AppendElement
(
std
:
:
move
(
refStream
)
)
;
return
newConn
.
forget
(
)
;
}
void
Http2Session
:
:
QueueStream
(
Http2StreamBase
*
stream
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
!
stream
-
>
CountAsActive
(
)
)
;
MOZ_ASSERT
(
!
stream
-
>
Queued
(
)
)
;
LOG3
(
(
"
Http2Session
:
:
QueueStream
%
p
stream
%
p
queued
.
"
this
stream
)
)
;
#
ifdef
DEBUG
for
(
const
auto
&
qStream
:
mQueuedStreams
)
{
MOZ_ASSERT
(
qStream
!
=
stream
)
;
MOZ_ASSERT
(
qStream
-
>
Queued
(
)
)
;
}
#
endif
stream
-
>
SetQueued
(
true
)
;
AddStreamToQueue
(
stream
mQueuedStreams
)
;
}
void
Http2Session
:
:
ProcessPending
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
RefPtr
<
Http2StreamBase
>
stream
;
while
(
RoomForMoreConcurrent
(
)
&
&
(
stream
=
GetNextStreamFromQueue
(
mQueuedStreams
)
)
)
{
LOG3
(
(
"
Http2Session
:
:
ProcessPending
%
p
stream
%
p
woken
from
queue
.
"
this
stream
.
get
(
)
)
)
;
MOZ_ASSERT
(
!
stream
-
>
CountAsActive
(
)
)
;
MOZ_ASSERT
(
stream
-
>
Queued
(
)
)
;
stream
-
>
SetQueued
(
false
)
;
AddStreamToQueue
(
stream
mReadyForWrite
)
;
SetWriteCallbacks
(
)
;
}
}
nsresult
Http2Session
:
:
NetworkRead
(
nsAHttpSegmentWriter
*
writer
char
*
buf
uint32_t
count
uint32_t
*
countWritten
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
!
count
)
{
*
countWritten
=
0
;
return
NS_OK
;
}
nsresult
rv
=
writer
-
>
OnWriteSegment
(
buf
count
countWritten
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
*
countWritten
>
0
)
{
mLastReadEpoch
=
PR_IntervalNow
(
)
;
}
return
rv
;
}
void
Http2Session
:
:
SetWriteCallbacks
(
)
{
if
(
mConnection
&
&
(
GetWriteQueueSize
(
)
|
|
(
mOutputQueueUsed
>
mOutputQueueSent
)
)
)
{
Unused
<
<
mConnection
-
>
ResumeSend
(
)
;
}
}
void
Http2Session
:
:
RealignOutputQueue
(
)
{
if
(
mAttemptingEarlyData
)
{
return
;
}
mOutputQueueUsed
-
=
mOutputQueueSent
;
memmove
(
mOutputQueueBuffer
.
get
(
)
mOutputQueueBuffer
.
get
(
)
+
mOutputQueueSent
mOutputQueueUsed
)
;
mOutputQueueSent
=
0
;
}
void
Http2Session
:
:
FlushOutputQueue
(
)
{
if
(
!
mSegmentReader
|
|
!
mOutputQueueUsed
)
return
;
nsresult
rv
;
uint32_t
countRead
;
uint32_t
avail
=
mOutputQueueUsed
-
mOutputQueueSent
;
if
(
!
avail
&
&
mAttemptingEarlyData
)
{
return
;
}
rv
=
mSegmentReader
-
>
OnReadSegment
(
mOutputQueueBuffer
.
get
(
)
+
mOutputQueueSent
avail
&
countRead
)
;
LOG3
(
(
"
Http2Session
:
:
FlushOutputQueue
%
p
sz
=
%
d
rv
=
%
"
PRIx32
"
actual
=
%
d
"
this
avail
static_cast
<
uint32_t
>
(
rv
)
countRead
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
mOutputQueueSent
+
=
countRead
;
if
(
mAttemptingEarlyData
)
{
return
;
}
if
(
countRead
=
=
avail
)
{
mOutputQueueUsed
=
0
;
mOutputQueueSent
=
0
;
return
;
}
if
(
(
mOutputQueueSent
>
=
kQueueMinimumCleanup
)
&
&
(
(
mOutputQueueSize
-
mOutputQueueUsed
)
<
kQueueTailRoom
)
)
{
RealignOutputQueue
(
)
;
}
}
void
Http2Session
:
:
DontReuse
(
)
{
LOG3
(
(
"
Http2Session
:
:
DontReuse
%
p
\
n
"
this
)
)
;
if
(
!
OnSocketThread
(
)
)
{
LOG3
(
(
"
Http2Session
%
p
not
on
socket
thread
\
n
"
this
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
Http2Session
:
:
DontReuse
"
this
&
Http2Session
:
:
DontReuse
)
;
gSocketTransportService
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
return
;
}
mShouldGoAway
=
true
;
if
(
!
mClosed
&
&
!
mStreamTransactionHash
.
Count
(
)
)
{
Close
(
NS_OK
)
;
}
}
enum
SpdyVersion
Http2Session
:
:
SpdyVersion
(
)
{
return
SpdyVersion
:
:
HTTP_2
;
}
uint32_t
Http2Session
:
:
GetWriteQueueSize
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
return
mReadyForWrite
.
Length
(
)
;
}
void
Http2Session
:
:
ChangeDownstreamState
(
enum
internalStateType
newState
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
ChangeDownstreamState
(
)
%
p
from
%
X
to
%
X
"
this
mDownstreamState
newState
)
)
;
mDownstreamState
=
newState
;
}
void
Http2Session
:
:
ResetDownstreamState
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
ResetDownstreamState
(
)
%
p
"
this
)
)
;
ChangeDownstreamState
(
BUFFERING_FRAME_HEADER
)
;
if
(
mInputFrameFinal
&
&
mInputFrameDataStream
)
{
mInputFrameFinal
=
false
;
LOG3
(
(
"
SetRecvdFin
id
=
0x
%
x
\
n
"
mInputFrameDataStream
-
>
StreamID
(
)
)
)
;
mInputFrameDataStream
-
>
SetRecvdFin
(
true
)
;
MaybeDecrementConcurrent
(
mInputFrameDataStream
)
;
}
mInputFrameFinal
=
false
;
mInputFrameBufferUsed
=
0
;
mInputFrameDataStream
=
nullptr
;
}
bool
Http2Session
:
:
TryToActivate
(
Http2StreamBase
*
aStream
)
{
if
(
aStream
-
>
Queued
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
TryToActivate
%
p
stream
=
%
p
already
queued
.
\
n
"
this
aStream
)
)
;
return
false
;
}
if
(
!
RoomForMoreConcurrent
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
TryToActivate
%
p
stream
=
%
p
no
room
for
more
concurrent
"
"
streams
\
n
"
this
aStream
)
)
;
QueueStream
(
aStream
)
;
return
false
;
}
LOG3
(
(
"
Http2Session
:
:
TryToActivate
%
p
stream
=
%
p
\
n
"
this
aStream
)
)
;
IncrementConcurrent
(
aStream
)
;
mCntActivated
+
+
;
return
true
;
}
void
Http2Session
:
:
IncrementConcurrent
(
Http2StreamBase
*
stream
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
!
stream
-
>
StreamID
(
)
|
|
(
stream
-
>
StreamID
(
)
&
1
)
"
Do
not
activate
pushed
streams
"
)
;
nsAHttpTransaction
*
trans
=
stream
-
>
Transaction
(
)
;
if
(
!
trans
|
|
!
trans
-
>
IsNullTransaction
(
)
|
|
trans
-
>
QueryHttp2ConnectTransaction
(
)
)
{
MOZ_ASSERT
(
!
stream
-
>
CountAsActive
(
)
)
;
stream
-
>
SetCountAsActive
(
true
)
;
+
+
mConcurrent
;
if
(
mConcurrent
>
mConcurrentHighWater
)
{
mConcurrentHighWater
=
mConcurrent
;
}
LOG3
(
(
"
Http2Session
:
:
IncrementCounter
%
p
counting
stream
%
p
Currently
%
d
"
"
streams
in
session
high
water
mark
is
%
d
\
n
"
this
stream
mConcurrent
mConcurrentHighWater
)
)
;
}
}
template
<
typename
charType
>
void
Http2Session
:
:
CreateFrameHeader
(
charType
dest
uint16_t
frameLength
uint8_t
frameType
uint8_t
frameFlags
uint32_t
streamID
)
{
MOZ_ASSERT
(
frameLength
<
=
kMaxFrameData
"
framelength
too
large
"
)
;
MOZ_ASSERT
(
!
(
streamID
&
0x80000000
)
)
;
MOZ_ASSERT
(
!
frameFlags
|
|
(
frameType
!
=
FRAME_TYPE_PRIORITY
&
&
frameType
!
=
FRAME_TYPE_RST_STREAM
&
&
frameType
!
=
FRAME_TYPE_GOAWAY
&
&
frameType
!
=
FRAME_TYPE_WINDOW_UPDATE
)
)
;
dest
[
0
]
=
0x00
;
NetworkEndian
:
:
writeUint16
(
dest
+
1
frameLength
)
;
dest
[
3
]
=
frameType
;
dest
[
4
]
=
frameFlags
;
NetworkEndian
:
:
writeUint32
(
dest
+
5
streamID
)
;
}
char
*
Http2Session
:
:
EnsureOutputBuffer
(
uint32_t
spaceNeeded
)
{
EnsureBuffer
(
mOutputQueueBuffer
mOutputQueueUsed
+
spaceNeeded
mOutputQueueUsed
mOutputQueueSize
)
;
return
mOutputQueueBuffer
.
get
(
)
+
mOutputQueueUsed
;
}
template
void
Http2Session
:
:
CreateFrameHeader
(
char
*
dest
uint16_t
frameLength
uint8_t
frameType
uint8_t
frameFlags
uint32_t
streamID
)
;
template
void
Http2Session
:
:
CreateFrameHeader
(
uint8_t
*
dest
uint16_t
frameLength
uint8_t
frameType
uint8_t
frameFlags
uint32_t
streamID
)
;
void
Http2Session
:
:
MaybeDecrementConcurrent
(
Http2StreamBase
*
aStream
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
MaybeDecrementConcurrent
%
p
id
=
0x
%
X
concurrent
=
%
d
active
=
%
d
\
n
"
this
aStream
-
>
StreamID
(
)
mConcurrent
aStream
-
>
CountAsActive
(
)
)
)
;
if
(
!
aStream
-
>
CountAsActive
(
)
)
return
;
MOZ_ASSERT
(
mConcurrent
)
;
aStream
-
>
SetCountAsActive
(
false
)
;
-
-
mConcurrent
;
ProcessPending
(
)
;
}
nsresult
Http2Session
:
:
UncompressAndDiscard
(
bool
isPush
)
{
nsresult
rv
;
nsAutoCString
trash
;
rv
=
mDecompressor
.
DecodeHeaderBlock
(
reinterpret_cast
<
const
uint8_t
*
>
(
mDecompressBuffer
.
BeginReading
(
)
)
mDecompressBuffer
.
Length
(
)
trash
isPush
)
;
mDecompressBuffer
.
Truncate
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
UncompressAndDiscard
%
p
Compression
Error
\
n
"
this
)
)
;
mGoAwayReason
=
COMPRESSION_ERROR
;
return
rv
;
}
return
NS_OK
;
}
void
Http2Session
:
:
GeneratePing
(
bool
isAck
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
GeneratePing
%
p
isAck
=
%
d
\
n
"
this
isAck
)
)
;
char
*
packet
=
EnsureOutputBuffer
(
kFrameHeaderBytes
+
8
)
;
mOutputQueueUsed
+
=
kFrameHeaderBytes
+
8
;
if
(
isAck
)
{
CreateFrameHeader
(
packet
8
FRAME_TYPE_PING
kFlag_ACK
0
)
;
memcpy
(
packet
+
kFrameHeaderBytes
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
8
)
;
}
else
{
CreateFrameHeader
(
packet
8
FRAME_TYPE_PING
0
0
)
;
memset
(
packet
+
kFrameHeaderBytes
0
8
)
;
}
LogIO
(
this
nullptr
"
Generate
Ping
"
packet
kFrameHeaderBytes
+
8
)
;
FlushOutputQueue
(
)
;
}
void
Http2Session
:
:
GenerateSettingsAck
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
GenerateSettingsAck
%
p
\
n
"
this
)
)
;
char
*
packet
=
EnsureOutputBuffer
(
kFrameHeaderBytes
)
;
mOutputQueueUsed
+
=
kFrameHeaderBytes
;
CreateFrameHeader
(
packet
0
FRAME_TYPE_SETTINGS
kFlag_ACK
0
)
;
LogIO
(
this
nullptr
"
Generate
Settings
ACK
"
packet
kFrameHeaderBytes
)
;
FlushOutputQueue
(
)
;
}
void
Http2Session
:
:
GeneratePriority
(
uint32_t
aID
uint8_t
aPriorityWeight
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
GeneratePriority
%
p
%
X
%
X
\
n
"
this
aID
aPriorityWeight
)
)
;
char
*
packet
=
CreatePriorityFrame
(
aID
0
aPriorityWeight
)
;
LogIO
(
this
nullptr
"
Generate
Priority
"
packet
kFrameHeaderBytes
+
5
)
;
FlushOutputQueue
(
)
;
}
void
Http2Session
:
:
GenerateRstStream
(
uint32_t
aStatusCode
uint32_t
aID
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
Http2StreamBase
*
stream
=
mStreamIDHash
.
Get
(
aID
)
;
if
(
stream
)
{
if
(
stream
-
>
SentReset
(
)
)
return
;
stream
-
>
SetSentReset
(
true
)
;
}
LOG3
(
(
"
Http2Session
:
:
GenerateRst
%
p
0x
%
X
%
d
\
n
"
this
aID
aStatusCode
)
)
;
uint32_t
frameSize
=
kFrameHeaderBytes
+
4
;
char
*
packet
=
EnsureOutputBuffer
(
frameSize
)
;
mOutputQueueUsed
+
=
frameSize
;
CreateFrameHeader
(
packet
4
FRAME_TYPE_RST_STREAM
0
aID
)
;
NetworkEndian
:
:
writeUint32
(
packet
+
kFrameHeaderBytes
aStatusCode
)
;
LogIO
(
this
nullptr
"
Generate
Reset
"
packet
frameSize
)
;
FlushOutputQueue
(
)
;
}
void
Http2Session
:
:
GenerateGoAway
(
uint32_t
aStatusCode
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
GenerateGoAway
%
p
code
=
%
X
\
n
"
this
aStatusCode
)
)
;
mClientGoAwayReason
=
aStatusCode
;
uint32_t
frameSize
=
kFrameHeaderBytes
+
8
;
char
*
packet
=
EnsureOutputBuffer
(
frameSize
)
;
mOutputQueueUsed
+
=
frameSize
;
CreateFrameHeader
(
packet
8
FRAME_TYPE_GOAWAY
0
0
)
;
NetworkEndian
:
:
writeUint32
(
packet
+
kFrameHeaderBytes
mOutgoingGoAwayID
)
;
NetworkEndian
:
:
writeUint32
(
packet
+
frameSize
-
4
aStatusCode
)
;
LogIO
(
this
nullptr
"
Generate
GoAway
"
packet
frameSize
)
;
FlushOutputQueue
(
)
;
}
void
Http2Session
:
:
SendHello
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
SendHello
%
p
\
n
"
this
)
)
;
static
const
uint32_t
maxSettings
=
5
;
static
const
uint32_t
prioritySize
=
kPriorityGroupCount
*
(
kFrameHeaderBytes
+
5
)
;
static
const
uint32_t
maxDataLen
=
24
+
kFrameHeaderBytes
+
maxSettings
*
6
+
13
+
prioritySize
;
char
*
packet
=
EnsureOutputBuffer
(
maxDataLen
)
;
memcpy
(
packet
kMagicHello
24
)
;
mOutputQueueUsed
+
=
24
;
LogIO
(
this
nullptr
"
Magic
Connection
Header
"
packet
24
)
;
packet
=
mOutputQueueBuffer
.
get
(
)
+
mOutputQueueUsed
;
memset
(
packet
0
maxDataLen
-
24
)
;
uint8_t
numberOfEntries
=
0
;
uint32_t
maxHpackBufferSize
=
gHttpHandler
-
>
DefaultHpackBuffer
(
)
;
mDecompressor
.
SetInitialMaxBufferSize
(
maxHpackBufferSize
)
;
NetworkEndian
:
:
writeUint16
(
packet
+
kFrameHeaderBytes
+
(
6
*
numberOfEntries
)
SETTINGS_TYPE_HEADER_TABLE_SIZE
)
;
NetworkEndian
:
:
writeUint32
(
packet
+
kFrameHeaderBytes
+
(
6
*
numberOfEntries
)
+
2
maxHpackBufferSize
)
;
numberOfEntries
+
+
;
if
(
!
StaticPrefs
:
:
network_http_http2_allow_push
(
)
)
{
NetworkEndian
:
:
writeUint16
(
packet
+
kFrameHeaderBytes
+
(
6
*
numberOfEntries
)
SETTINGS_TYPE_ENABLE_PUSH
)
;
numberOfEntries
+
+
;
NetworkEndian
:
:
writeUint16
(
packet
+
kFrameHeaderBytes
+
(
6
*
numberOfEntries
)
SETTINGS_TYPE_MAX_CONCURRENT
)
;
numberOfEntries
+
+
;
mWaitingForSettingsAck
=
true
;
}
NetworkEndian
:
:
writeUint16
(
packet
+
kFrameHeaderBytes
+
(
6
*
numberOfEntries
)
SETTINGS_TYPE_INITIAL_WINDOW
)
;
NetworkEndian
:
:
writeUint32
(
packet
+
kFrameHeaderBytes
+
(
6
*
numberOfEntries
)
+
2
mPushAllowance
)
;
numberOfEntries
+
+
;
NetworkEndian
:
:
writeUint16
(
packet
+
kFrameHeaderBytes
+
(
6
*
numberOfEntries
)
SETTINGS_TYPE_MAX_FRAME_SIZE
)
;
NetworkEndian
:
:
writeUint32
(
packet
+
kFrameHeaderBytes
+
(
6
*
numberOfEntries
)
+
2
kMaxFrameData
)
;
numberOfEntries
+
+
;
MOZ_ASSERT
(
numberOfEntries
<
=
maxSettings
)
;
uint32_t
dataLen
=
6
*
numberOfEntries
;
CreateFrameHeader
(
packet
dataLen
FRAME_TYPE_SETTINGS
0
0
)
;
mOutputQueueUsed
+
=
kFrameHeaderBytes
+
dataLen
;
LogIO
(
this
nullptr
"
Generate
Settings
"
packet
kFrameHeaderBytes
+
dataLen
)
;
uint32_t
sessionWindowBump
=
mInitialRwin
-
kDefaultRwin
;
if
(
kDefaultRwin
<
mInitialRwin
)
{
mLocalSessionWindow
=
mInitialRwin
;
packet
=
mOutputQueueBuffer
.
get
(
)
+
mOutputQueueUsed
;
CreateFrameHeader
(
packet
4
FRAME_TYPE_WINDOW_UPDATE
0
0
)
;
mOutputQueueUsed
+
=
kFrameHeaderBytes
+
4
;
NetworkEndian
:
:
writeUint32
(
packet
+
kFrameHeaderBytes
sessionWindowBump
)
;
LOG3
(
(
"
Session
Window
increase
at
start
of
session
%
p
%
u
\
n
"
this
sessionWindowBump
)
)
;
LogIO
(
this
nullptr
"
Session
Window
Bump
"
packet
kFrameHeaderBytes
+
4
)
;
}
if
(
StaticPrefs
:
:
network_http_http2_enabled_deps
(
)
&
&
gHttpHandler
-
>
CriticalRequestPrioritization
(
)
)
{
mUseH2Deps
=
true
;
MOZ_ASSERT
(
mNextStreamID
=
=
kLeaderGroupID
)
;
CreatePriorityNode
(
kLeaderGroupID
0
200
"
leader
"
)
;
mNextStreamID
+
=
2
;
MOZ_ASSERT
(
mNextStreamID
=
=
kOtherGroupID
)
;
CreatePriorityNode
(
kOtherGroupID
0
100
"
other
"
)
;
mNextStreamID
+
=
2
;
MOZ_ASSERT
(
mNextStreamID
=
=
kBackgroundGroupID
)
;
CreatePriorityNode
(
kBackgroundGroupID
0
0
"
background
"
)
;
mNextStreamID
+
=
2
;
MOZ_ASSERT
(
mNextStreamID
=
=
kSpeculativeGroupID
)
;
CreatePriorityNode
(
kSpeculativeGroupID
kBackgroundGroupID
0
"
speculative
"
)
;
mNextStreamID
+
=
2
;
MOZ_ASSERT
(
mNextStreamID
=
=
kFollowerGroupID
)
;
CreatePriorityNode
(
kFollowerGroupID
kLeaderGroupID
0
"
follower
"
)
;
mNextStreamID
+
=
2
;
MOZ_ASSERT
(
mNextStreamID
=
=
kUrgentStartGroupID
)
;
CreatePriorityNode
(
kUrgentStartGroupID
0
240
"
urgentStart
"
)
;
mNextStreamID
+
=
2
;
}
FlushOutputQueue
(
)
;
}
void
Http2Session
:
:
SendPriorityFrame
(
uint32_t
streamID
uint32_t
dependsOn
uint8_t
weight
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
SendPriorityFrame
%
p
Frame
0x
%
X
depends
on
0x
%
X
"
"
weight
%
d
\
n
"
this
streamID
dependsOn
weight
)
)
;
char
*
packet
=
CreatePriorityFrame
(
streamID
dependsOn
weight
)
;
LogIO
(
this
nullptr
"
SendPriorityFrame
"
packet
kFrameHeaderBytes
+
5
)
;
FlushOutputQueue
(
)
;
}
char
*
Http2Session
:
:
CreatePriorityFrame
(
uint32_t
streamID
uint32_t
dependsOn
uint8_t
weight
)
{
MOZ_ASSERT
(
streamID
"
Priority
on
stream
0
"
)
;
char
*
packet
=
EnsureOutputBuffer
(
kFrameHeaderBytes
+
5
)
;
CreateFrameHeader
(
packet
5
FRAME_TYPE_PRIORITY
0
streamID
)
;
mOutputQueueUsed
+
=
kFrameHeaderBytes
+
5
;
NetworkEndian
:
:
writeUint32
(
packet
+
kFrameHeaderBytes
dependsOn
)
;
packet
[
kFrameHeaderBytes
+
4
]
=
weight
;
return
packet
;
}
void
Http2Session
:
:
CreatePriorityNode
(
uint32_t
streamID
uint32_t
dependsOn
uint8_t
weight
const
char
*
label
)
{
char
*
packet
=
CreatePriorityFrame
(
streamID
dependsOn
weight
)
;
LOG3
(
(
"
Http2Session
%
p
generate
Priority
Frame
0x
%
X
depends
on
0x
%
X
"
"
weight
%
d
for
%
s
class
\
n
"
this
streamID
dependsOn
weight
label
)
)
;
LogIO
(
this
nullptr
"
Priority
dep
node
"
packet
kFrameHeaderBytes
+
5
)
;
}
bool
Http2Session
:
:
VerifyStream
(
Http2StreamBase
*
aStream
uint32_t
aOptionalID
=
0
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
#
ifndef
DEBUG
return
true
;
#
else
if
(
!
aStream
)
return
true
;
uint32_t
test
=
0
;
do
{
if
(
aStream
-
>
StreamID
(
)
=
=
kDeadStreamID
)
break
;
test
+
+
;
if
(
aStream
-
>
StreamID
(
)
)
{
Http2StreamBase
*
idStream
=
mStreamIDHash
.
Get
(
aStream
-
>
StreamID
(
)
)
;
test
+
+
;
if
(
idStream
!
=
aStream
)
break
;
if
(
aOptionalID
)
{
test
+
+
;
if
(
idStream
-
>
StreamID
(
)
!
=
aOptionalID
)
break
;
}
}
if
(
aStream
-
>
IsTunnel
(
)
)
{
return
true
;
}
nsAHttpTransaction
*
trans
=
aStream
-
>
Transaction
(
)
;
test
+
+
;
if
(
!
trans
)
break
;
test
+
+
;
if
(
mStreamTransactionHash
.
GetWeak
(
trans
)
!
=
aStream
)
break
;
return
true
;
}
while
(
false
)
;
LOG3
(
(
"
Http2Session
%
p
VerifyStream
Failure
%
p
stream
-
>
id
=
0x
%
X
"
"
optionalID
=
0x
%
X
trans
=
%
p
test
=
%
d
\
n
"
this
aStream
aStream
-
>
StreamID
(
)
aOptionalID
aStream
-
>
Transaction
(
)
test
)
)
;
MOZ_ASSERT
(
false
"
VerifyStream
"
)
;
return
false
;
#
endif
}
void
Http2Session
:
:
CleanupStream
(
Http2StreamBase
*
aStream
nsresult
aResult
errorType
aResetCode
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
CleanupStream
%
p
%
p
0x
%
X
%
"
PRIX32
"
\
n
"
this
aStream
aStream
?
aStream
-
>
StreamID
(
)
:
0
static_cast
<
uint32_t
>
(
aResult
)
)
)
;
if
(
!
aStream
)
{
return
;
}
Http2PushedStream
*
pushSource
=
nullptr
;
Http2Stream
*
h2Stream
=
aStream
-
>
GetHttp2Stream
(
)
;
if
(
h2Stream
)
{
pushSource
=
h2Stream
-
>
PushSource
(
)
;
if
(
pushSource
)
{
MOZ_ASSERT
(
pushSource
-
>
GetConsumerStream
(
)
=
=
aStream
)
;
MOZ_ASSERT
(
!
aStream
-
>
StreamID
(
)
)
;
MOZ_ASSERT
(
!
(
pushSource
-
>
StreamID
(
)
&
0x1
)
)
;
h2Stream
-
>
ClearPushSource
(
)
;
}
}
if
(
aStream
-
>
DeferCleanup
(
aResult
)
)
{
LOG3
(
(
"
Http2Session
:
:
CleanupStream
0x
%
X
deferred
\
n
"
aStream
-
>
StreamID
(
)
)
)
;
return
;
}
if
(
!
VerifyStream
(
aStream
)
)
{
LOG3
(
(
"
Http2Session
:
:
CleanupStream
failed
to
verify
stream
\
n
"
)
)
;
return
;
}
if
(
!
aStream
-
>
RecvdFin
(
)
&
&
!
aStream
-
>
RecvdReset
(
)
&
&
aStream
-
>
StreamID
(
)
&
&
!
(
mInputFrameFinal
&
&
(
aStream
=
=
mInputFrameDataStream
)
)
)
{
LOG3
(
(
"
Stream
0x
%
X
had
not
processed
recv
FIN
sending
RST
code
%
X
\
n
"
aStream
-
>
StreamID
(
)
aResetCode
)
)
;
GenerateRstStream
(
aResetCode
aStream
-
>
StreamID
(
)
)
;
}
CloseStream
(
aStream
aResult
)
;
uint32_t
id
=
aStream
-
>
StreamID
(
)
;
if
(
id
>
0
)
{
mStreamIDHash
.
Remove
(
id
)
;
if
(
!
(
id
&
1
)
)
{
mPushedStreams
.
RemoveElement
(
aStream
)
;
Http2PushedStream
*
pushStream
=
static_cast
<
Http2PushedStream
*
>
(
aStream
)
;
nsAutoCString
hashKey
;
DebugOnly
<
bool
>
rv
=
pushStream
-
>
GetHashKey
(
hashKey
)
;
MOZ_ASSERT
(
rv
)
;
nsIRequestContext
*
requestContext
=
aStream
-
>
RequestContext
(
)
;
if
(
requestContext
)
{
SpdyPushCache
*
cache
=
requestContext
-
>
GetSpdyPushCache
(
)
;
if
(
cache
)
{
Http2PushedStream
*
trash
=
cache
-
>
RemovePushedStreamHttp2ByID
(
hashKey
aStream
-
>
StreamID
(
)
)
;
LOG3
(
(
"
Http2Session
:
:
CleanupStream
%
p
aStream
=
%
p
pushStream
=
%
p
"
"
trash
=
%
p
"
this
aStream
pushStream
trash
)
)
;
}
}
}
}
RemoveStreamFromQueues
(
aStream
)
;
mStreamTransactionHash
.
Remove
(
aStream
-
>
Transaction
(
)
)
;
if
(
mShouldGoAway
&
&
!
mStreamTransactionHash
.
Count
(
)
)
Close
(
NS_OK
)
;
if
(
pushSource
)
{
pushSource
-
>
SetDeferCleanupOnSuccess
(
false
)
;
CleanupStream
(
pushSource
aResult
aResetCode
)
;
}
}
void
Http2Session
:
:
CleanupStream
(
uint32_t
aID
nsresult
aResult
errorType
aResetCode
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
Http2StreamBase
*
stream
=
mStreamIDHash
.
Get
(
aID
)
;
LOG3
(
(
"
Http2Session
:
:
CleanupStream
%
p
by
ID
0x
%
X
to
stream
%
p
\
n
"
this
aID
stream
)
)
;
if
(
!
stream
)
{
return
;
}
CleanupStream
(
stream
aResult
aResetCode
)
;
}
void
Http2Session
:
:
RemoveStreamFromQueues
(
Http2StreamBase
*
aStream
)
{
RemoveStreamFromQueue
(
aStream
mReadyForWrite
)
;
RemoveStreamFromQueue
(
aStream
mQueuedStreams
)
;
RemoveStreamFromQueue
(
aStream
mPushesReadyForRead
)
;
RemoveStreamFromQueue
(
aStream
mSlowConsumersReadyForRead
)
;
}
void
Http2Session
:
:
CloseStream
(
Http2StreamBase
*
aStream
nsresult
aResult
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
CloseStream
%
p
%
p
0x
%
x
%
"
PRIX32
"
\
n
"
this
aStream
aStream
-
>
StreamID
(
)
static_cast
<
uint32_t
>
(
aResult
)
)
)
;
MaybeDecrementConcurrent
(
aStream
)
;
if
(
aStream
=
=
mInputFrameDataStream
)
{
LOG3
(
(
"
Stream
had
active
partial
read
frame
on
close
"
)
)
;
ChangeDownstreamState
(
DISCARDING_DATA_FRAME
)
;
mInputFrameDataStream
=
nullptr
;
}
RemoveStreamFromQueues
(
aStream
)
;
aStream
-
>
CloseStream
(
aResult
)
;
}
nsresult
Http2Session
:
:
SetInputFrameDataStream
(
uint32_t
streamID
)
{
mInputFrameDataStream
=
mStreamIDHash
.
Get
(
streamID
)
;
if
(
VerifyStream
(
mInputFrameDataStream
streamID
)
)
return
NS_OK
;
LOG3
(
(
"
Http2Session
:
:
SetInputFrameDataStream
failed
to
verify
0x
%
X
\
n
"
streamID
)
)
;
mInputFrameDataStream
=
nullptr
;
return
NS_ERROR_UNEXPECTED
;
}
nsresult
Http2Session
:
:
ParsePadding
(
uint8_t
&
paddingControlBytes
uint16_t
&
paddingLength
)
{
if
(
mInputFrameFlags
&
kFlag_PADDED
)
{
paddingLength
=
*
reinterpret_cast
<
uint8_t
*
>
(
&
mInputFrameBuffer
[
kFrameHeaderBytes
]
)
;
paddingControlBytes
=
1
;
}
else
{
paddingLength
=
0
;
paddingControlBytes
=
0
;
}
if
(
static_cast
<
uint32_t
>
(
paddingLength
+
paddingControlBytes
)
>
mInputFrameDataSize
)
{
LOG3
(
(
"
Http2Session
:
:
ParsePadding
%
p
stream
0x
%
x
PROTOCOL_ERROR
"
"
paddingLength
%
d
>
frame
size
%
d
\
n
"
this
mInputFrameID
paddingLength
mInputFrameDataSize
)
)
;
return
SessionError
(
PROTOCOL_ERROR
)
;
}
return
NS_OK
;
}
nsresult
Http2Session
:
:
RecvHeaders
(
Http2Session
*
self
)
{
MOZ_ASSERT
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_HEADERS
|
|
self
-
>
mInputFrameType
=
=
FRAME_TYPE_CONTINUATION
)
;
bool
isContinuation
=
self
-
>
mExpectedHeaderID
!
=
0
;
bool
endHeadersFlag
=
self
-
>
mInputFrameFlags
&
kFlag_END_HEADERS
;
if
(
endHeadersFlag
)
{
self
-
>
mExpectedHeaderID
=
0
;
}
else
{
self
-
>
mExpectedHeaderID
=
self
-
>
mInputFrameID
;
}
uint32_t
priorityLen
=
0
;
if
(
self
-
>
mInputFrameFlags
&
kFlag_PRIORITY
)
{
priorityLen
=
5
;
}
nsresult
rv
=
self
-
>
SetInputFrameDataStream
(
self
-
>
mInputFrameID
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
uint16_t
paddingLength
=
0
;
uint8_t
paddingControlBytes
=
0
;
if
(
!
isContinuation
)
{
self
-
>
mDecompressBuffer
.
Truncate
(
)
;
rv
=
self
-
>
ParsePadding
(
paddingControlBytes
paddingLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
LOG3
(
(
"
Http2Session
:
:
RecvHeaders
%
p
stream
0x
%
X
priorityLen
=
%
d
stream
=
%
p
"
"
end_stream
=
%
d
end_headers
=
%
d
priority_group
=
%
d
"
"
paddingLength
=
%
d
padded
=
%
d
\
n
"
self
self
-
>
mInputFrameID
priorityLen
self
-
>
mInputFrameDataStream
self
-
>
mInputFrameFlags
&
kFlag_END_STREAM
self
-
>
mInputFrameFlags
&
kFlag_END_HEADERS
self
-
>
mInputFrameFlags
&
kFlag_PRIORITY
paddingLength
self
-
>
mInputFrameFlags
&
kFlag_PADDED
)
)
;
if
(
(
paddingControlBytes
+
priorityLen
+
paddingLength
)
>
self
-
>
mInputFrameDataSize
)
{
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
if
(
!
self
-
>
mInputFrameDataStream
)
{
LOG3
(
(
"
Http2Session
:
:
RecvHeaders
%
p
lookup
mInputFrameID
stream
"
"
0x
%
X
failed
.
NextStreamID
=
0x
%
X
\
n
"
self
self
-
>
mInputFrameID
self
-
>
mNextStreamID
)
)
;
if
(
self
-
>
mInputFrameID
>
=
self
-
>
mNextStreamID
)
{
self
-
>
GenerateRstStream
(
PROTOCOL_ERROR
self
-
>
mInputFrameID
)
;
}
self
-
>
mDecompressBuffer
.
Append
(
&
self
-
>
mInputFrameBuffer
[
kFrameHeaderBytes
+
paddingControlBytes
+
priorityLen
]
self
-
>
mInputFrameDataSize
-
paddingControlBytes
-
priorityLen
-
paddingLength
)
;
if
(
self
-
>
mInputFrameFlags
&
kFlag_END_HEADERS
)
{
rv
=
self
-
>
UncompressAndDiscard
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvHeaders
uncompress
failed
\
n
"
)
)
;
self
-
>
mGoAwayReason
=
COMPRESSION_ERROR
;
return
rv
;
}
}
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
self
-
>
mInputFrameDataStream
-
>
AllHeadersReceived
(
)
&
&
!
(
self
-
>
mInputFrameFlags
&
kFlag_END_STREAM
)
)
{
LOG3
(
(
"
Http2Session
:
:
Illegal
Extra
HeaderBlock
%
p
0x
%
X
\
n
"
self
self
-
>
mInputFrameID
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
self
-
>
mDecompressBuffer
.
Append
(
&
self
-
>
mInputFrameBuffer
[
kFrameHeaderBytes
+
paddingControlBytes
+
priorityLen
]
self
-
>
mInputFrameDataSize
-
paddingControlBytes
-
priorityLen
-
paddingLength
)
;
self
-
>
mInputFrameDataStream
-
>
UpdateTransportReadEvents
(
self
-
>
mInputFrameDataSize
)
;
self
-
>
mLastDataReadEpoch
=
self
-
>
mLastReadEpoch
;
if
(
!
isContinuation
)
{
self
-
>
mAggregatedHeaderSize
=
self
-
>
mInputFrameDataSize
-
paddingControlBytes
-
priorityLen
-
paddingLength
;
}
else
{
self
-
>
mAggregatedHeaderSize
+
=
self
-
>
mInputFrameDataSize
-
paddingControlBytes
-
priorityLen
-
paddingLength
;
}
if
(
!
endHeadersFlag
)
{
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
isContinuation
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_CONTINUED_HEADERS
self
-
>
mAggregatedHeaderSize
)
;
}
rv
=
self
-
>
ResponseHeadersComplete
(
)
;
if
(
rv
=
=
NS_ERROR_ILLEGAL_VALUE
)
{
LOG3
(
(
"
Http2Session
:
:
RecvHeaders
%
p
PROTOCOL_ERROR
detected
stream
0x
%
X
\
n
"
self
self
-
>
mInputFrameID
)
)
;
self
-
>
CleanupStream
(
self
-
>
mInputFrameDataStream
rv
PROTOCOL_ERROR
)
;
self
-
>
ResetDownstreamState
(
)
;
rv
=
NS_OK
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
self
-
>
mGoAwayReason
=
COMPRESSION_ERROR
;
}
return
rv
;
}
nsresult
Http2Session
:
:
ResponseHeadersComplete
(
)
{
LOG3
(
(
"
Http2Session
:
:
ResponseHeadersComplete
%
p
for
0x
%
X
fin
=
%
d
"
this
mInputFrameDataStream
-
>
StreamID
(
)
mInputFrameFinal
)
)
;
if
(
mInputFrameDataStream
-
>
AllHeadersReceived
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
ResponseHeadersComplete
processing
trailers
"
)
)
;
MOZ_ASSERT
(
mInputFrameFlags
&
kFlag_END_STREAM
)
;
nsresult
rv
=
mInputFrameDataStream
-
>
ConvertResponseTrailers
(
&
mDecompressor
mDecompressBuffer
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
ResponseHeadersComplete
trailer
conversion
failed
\
n
"
)
)
;
return
rv
;
}
mFlatHTTPResponseHeadersOut
=
0
;
mFlatHTTPResponseHeaders
.
Truncate
(
)
;
if
(
mInputFrameFinal
)
{
ChangeDownstreamState
(
PROCESSING_COMPLETE_HEADERS
)
;
}
else
{
ResetDownstreamState
(
)
;
}
return
NS_OK
;
}
bool
didFirstSetAllRecvd
=
!
mInputFrameDataStream
-
>
AllHeadersReceived
(
)
;
mInputFrameDataStream
-
>
SetAllHeadersReceived
(
)
;
nsresult
rv
;
int32_t
httpResponseCode
;
mFlatHTTPResponseHeadersOut
=
0
;
rv
=
mInputFrameDataStream
-
>
ConvertResponseHeaders
(
&
mDecompressor
mDecompressBuffer
mFlatHTTPResponseHeaders
httpResponseCode
)
;
if
(
rv
=
=
NS_ERROR_NET_RESET
)
{
LOG
(
(
"
Http2Session
:
:
ResponseHeadersComplete
%
p
ConvertResponseHeaders
"
"
reset
\
n
"
this
)
)
;
mInputFrameDataStream
-
>
Transaction
(
)
-
>
DisableSpdy
(
)
;
CleanupStream
(
mInputFrameDataStream
NS_ERROR_NET_RESET
CANCEL_ERROR
)
;
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
(
(
httpResponseCode
/
100
)
=
=
1
)
&
&
didFirstSetAllRecvd
)
{
mInputFrameDataStream
-
>
UnsetAllHeadersReceived
(
)
;
}
ChangeDownstreamState
(
PROCESSING_COMPLETE_HEADERS
)
;
return
NS_OK
;
}
nsresult
Http2Session
:
:
RecvPriority
(
Http2Session
*
self
)
{
MOZ_ASSERT
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_PRIORITY
)
;
if
(
self
-
>
mInputFrameDataSize
!
=
5
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPriority
%
p
wrong
length
data
=
%
d
\
n
"
self
self
-
>
mInputFrameDataSize
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
if
(
!
self
-
>
mInputFrameID
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPriority
%
p
stream
ID
of
0
.
\
n
"
self
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
nsresult
rv
=
self
-
>
SetInputFrameDataStream
(
self
-
>
mInputFrameID
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
uint32_t
newPriorityDependency
=
NetworkEndian
:
:
readUint32
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
)
;
bool
exclusive
=
!
!
(
newPriorityDependency
&
0x80000000
)
;
newPriorityDependency
&
=
0x7fffffff
;
uint8_t
newPriorityWeight
=
*
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
+
4
)
;
LOG3
(
(
"
Http2Session
:
:
RecvPriority
%
p
0x
%
X
received
dependency
=
0x
%
X
"
"
weight
=
%
u
exclusive
=
%
d
"
self
-
>
mInputFrameDataStream
self
-
>
mInputFrameID
newPriorityDependency
newPriorityWeight
exclusive
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
nsresult
Http2Session
:
:
RecvRstStream
(
Http2Session
*
self
)
{
MOZ_ASSERT
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_RST_STREAM
)
;
if
(
self
-
>
mInputFrameDataSize
!
=
4
)
{
LOG3
(
(
"
Http2Session
:
:
RecvRstStream
%
p
RST_STREAM
wrong
length
data
=
%
d
"
self
self
-
>
mInputFrameDataSize
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
if
(
!
self
-
>
mInputFrameID
)
{
LOG3
(
(
"
Http2Session
:
:
RecvRstStream
%
p
stream
ID
of
0
.
\
n
"
self
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
self
-
>
mDownstreamRstReason
=
NetworkEndian
:
:
readUint32
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
)
;
LOG3
(
(
"
Http2Session
:
:
RecvRstStream
%
p
RST_STREAM
Reason
Code
%
u
ID
%
x
\
n
"
self
self
-
>
mDownstreamRstReason
self
-
>
mInputFrameID
)
)
;
DebugOnly
<
nsresult
>
rv
=
self
-
>
SetInputFrameDataStream
(
self
-
>
mInputFrameID
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
self
-
>
mInputFrameDataStream
)
{
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
self
-
>
mInputFrameDataStream
-
>
SetRecvdReset
(
true
)
;
self
-
>
MaybeDecrementConcurrent
(
self
-
>
mInputFrameDataStream
)
;
self
-
>
ChangeDownstreamState
(
PROCESSING_CONTROL_RST_STREAM
)
;
return
NS_OK
;
}
nsresult
Http2Session
:
:
RecvSettings
(
Http2Session
*
self
)
{
MOZ_ASSERT
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_SETTINGS
)
;
if
(
self
-
>
mInputFrameID
)
{
LOG3
(
(
"
Http2Session
:
:
RecvSettings
%
p
needs
stream
ID
of
0
.
0x
%
X
\
n
"
self
self
-
>
mInputFrameID
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
if
(
self
-
>
mInputFrameDataSize
%
6
)
{
LOG3
(
(
"
Http2Session
:
:
RecvSettings
%
p
SETTINGS
wrong
length
data
=
%
d
"
self
self
-
>
mInputFrameDataSize
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
self
-
>
mReceivedSettings
=
true
;
uint32_t
numEntries
=
self
-
>
mInputFrameDataSize
/
6
;
LOG3
(
(
"
Http2Session
:
:
RecvSettings
%
p
SETTINGS
Control
Frame
"
"
with
%
d
entries
ack
=
%
X
"
self
numEntries
self
-
>
mInputFrameFlags
&
kFlag_ACK
)
)
;
if
(
(
self
-
>
mInputFrameFlags
&
kFlag_ACK
)
&
&
self
-
>
mInputFrameDataSize
)
{
LOG3
(
(
"
Http2Session
:
:
RecvSettings
%
p
ACK
with
non
zero
payload
is
err
\
n
"
self
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
for
(
uint32_t
index
=
0
;
index
<
numEntries
;
+
+
index
)
{
uint8_t
*
setting
=
reinterpret_cast
<
uint8_t
*
>
(
self
-
>
mInputFrameBuffer
.
get
(
)
)
+
kFrameHeaderBytes
+
index
*
6
;
uint16_t
id
=
NetworkEndian
:
:
readUint16
(
setting
)
;
uint32_t
value
=
NetworkEndian
:
:
readUint32
(
setting
+
2
)
;
LOG3
(
(
"
Settings
ID
%
u
Value
%
u
"
id
value
)
)
;
switch
(
id
)
{
case
SETTINGS_TYPE_HEADER_TABLE_SIZE
:
LOG3
(
(
"
Compression
header
table
setting
received
:
%
d
\
n
"
value
)
)
;
self
-
>
mCompressor
.
SetMaxBufferSize
(
value
)
;
break
;
case
SETTINGS_TYPE_ENABLE_PUSH
:
LOG3
(
(
"
Client
received
an
ENABLE
Push
SETTING
.
Odd
.
\
n
"
)
)
;
break
;
case
SETTINGS_TYPE_MAX_CONCURRENT
:
self
-
>
mMaxConcurrent
=
value
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_SETTINGS_MAX_STREAMS
value
)
;
self
-
>
ProcessPending
(
)
;
break
;
case
SETTINGS_TYPE_INITIAL_WINDOW
:
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_SETTINGS_IW
value
>
>
10
)
;
int32_t
delta
=
value
-
self
-
>
mServerInitialStreamWindow
;
self
-
>
mServerInitialStreamWindow
=
value
;
for
(
const
auto
&
stream
:
self
-
>
mStreamTransactionHash
.
Values
(
)
)
{
stream
-
>
UpdateServerReceiveWindow
(
delta
)
;
}
}
break
;
case
SETTINGS_TYPE_MAX_FRAME_SIZE
:
{
if
(
(
value
<
kMaxFrameData
)
|
|
(
value
>
=
0x01000000
)
)
{
LOG3
(
(
"
Received
invalid
max
frame
size
0x
%
X
"
value
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
}
break
;
case
SETTINGS_TYPE_ENABLE_CONNECT_PROTOCOL
:
{
if
(
value
=
=
1
)
{
LOG3
(
(
"
Enabling
extended
CONNECT
"
)
)
;
self
-
>
mPeerAllowsWebsockets
=
true
;
}
else
if
(
value
>
1
)
{
LOG3
(
(
"
Peer
sent
invalid
value
for
ENABLE_CONNECT_PROTOCOL
%
d
"
value
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
else
if
(
self
-
>
mPeerAllowsWebsockets
)
{
LOG3
(
(
"
Peer
tried
to
re
-
disable
extended
CONNECT
"
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
}
break
;
default
:
LOG3
(
(
"
Received
an
unknown
SETTING
id
%
d
.
Ignoring
.
"
id
)
)
;
break
;
}
}
self
-
>
ResetDownstreamState
(
)
;
if
(
!
(
self
-
>
mInputFrameFlags
&
kFlag_ACK
)
)
{
self
-
>
GenerateSettingsAck
(
)
;
}
else
if
(
self
-
>
mWaitingForSettingsAck
)
{
self
-
>
mGoAwayOnPush
=
true
;
}
if
(
!
self
-
>
mProcessedWaitingWebsockets
)
{
self
-
>
ProcessWaitingWebsockets
(
)
;
}
return
NS_OK
;
}
nsresult
Http2Session
:
:
RecvPushPromise
(
Http2Session
*
self
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_PUSH_PROMISE
|
|
self
-
>
mInputFrameType
=
=
FRAME_TYPE_CONTINUATION
)
;
uint16_t
paddingLength
=
0
;
uint8_t
paddingControlBytes
=
0
;
uint32_t
promiseLen
;
uint32_t
promisedID
;
if
(
self
-
>
mExpectedPushPromiseID
)
{
promiseLen
=
0
;
promisedID
=
self
-
>
mContinuedPromiseStream
;
}
else
{
self
-
>
mDecompressBuffer
.
Truncate
(
)
;
nsresult
rv
=
self
-
>
ParsePadding
(
paddingControlBytes
paddingLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
promiseLen
=
4
;
promisedID
=
NetworkEndian
:
:
readUint32
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
+
paddingControlBytes
)
;
promisedID
&
=
0x7fffffff
;
if
(
promisedID
<
=
self
-
>
mLastPushedID
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
ID
too
low
%
u
expected
>
%
u
.
\
n
"
self
promisedID
self
-
>
mLastPushedID
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
self
-
>
mLastPushedID
=
promisedID
;
}
uint32_t
associatedID
=
self
-
>
mInputFrameID
;
if
(
self
-
>
mInputFrameFlags
&
kFlag_END_PUSH_PROMISE
)
{
self
-
>
mExpectedPushPromiseID
=
0
;
self
-
>
mContinuedPromiseStream
=
0
;
}
else
{
self
-
>
mExpectedPushPromiseID
=
self
-
>
mInputFrameID
;
self
-
>
mContinuedPromiseStream
=
promisedID
;
}
if
(
(
paddingControlBytes
+
promiseLen
+
paddingLength
)
>
self
-
>
mInputFrameDataSize
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
ID
0x
%
X
assoc
ID
0x
%
X
"
"
PROTOCOL_ERROR
extra
%
d
>
frame
size
%
d
\
n
"
self
promisedID
associatedID
(
paddingControlBytes
+
promiseLen
+
paddingLength
)
self
-
>
mInputFrameDataSize
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
ID
0x
%
X
assoc
ID
0x
%
X
"
"
paddingLength
%
d
padded
%
d
\
n
"
self
promisedID
associatedID
paddingLength
self
-
>
mInputFrameFlags
&
kFlag_PADDED
)
)
;
if
(
!
associatedID
|
|
!
promisedID
|
|
(
promisedID
&
1
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
ID
invalid
.
\
n
"
self
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
nsresult
rv
=
self
-
>
SetInputFrameDataStream
(
associatedID
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
Http2StreamBase
*
associatedStream
=
self
-
>
mInputFrameDataStream
;
+
+
(
self
-
>
mServerPushedResources
)
;
if
(
promisedID
>
=
kMaxStreamID
)
self
-
>
mShouldGoAway
=
true
;
bool
resetStream
=
true
;
SpdyPushCache
*
cache
=
nullptr
;
if
(
self
-
>
mShouldGoAway
&
&
!
Http2PushedStream
:
:
TestOnPush
(
associatedStream
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
cache
push
while
in
GoAway
"
"
mode
refused
.
\
n
"
self
)
)
;
self
-
>
GenerateRstStream
(
REFUSED_STREAM_ERROR
promisedID
)
;
}
else
if
(
!
StaticPrefs
:
:
network_http_http2_allow_push
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
Push
Recevied
when
Disabled
\
n
"
)
)
;
if
(
self
-
>
mGoAwayOnPush
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
sending
GOAWAY
"
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
self
-
>
GenerateRstStream
(
REFUSED_STREAM_ERROR
promisedID
)
;
}
else
if
(
!
(
associatedID
&
1
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
assocated
=
0x
%
X
on
pushed
(
even
)
"
"
stream
not
allowed
\
n
"
self
associatedID
)
)
;
self
-
>
GenerateRstStream
(
PROTOCOL_ERROR
promisedID
)
;
}
else
if
(
!
associatedStream
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
lookup
associated
ID
failed
.
\
n
"
self
)
)
;
self
-
>
GenerateRstStream
(
PROTOCOL_ERROR
promisedID
)
;
}
else
if
(
Http2PushedStream
:
:
TestOnPush
(
associatedStream
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
will
be
handled
by
push
listener
.
"
self
)
)
;
resetStream
=
false
;
}
else
{
nsIRequestContext
*
requestContext
=
associatedStream
-
>
RequestContext
(
)
;
if
(
requestContext
)
{
cache
=
requestContext
-
>
GetSpdyPushCache
(
)
;
if
(
!
cache
)
{
cache
=
new
SpdyPushCache
(
)
;
requestContext
-
>
SetSpdyPushCache
(
cache
)
;
}
}
if
(
!
cache
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
Push
Recevied
without
push
cache
\
n
"
)
)
;
self
-
>
GenerateRstStream
(
REFUSED_STREAM_ERROR
promisedID
)
;
}
else
{
resetStream
=
false
;
}
}
if
(
resetStream
)
{
self
-
>
mDecompressBuffer
.
Append
(
&
self
-
>
mInputFrameBuffer
[
kFrameHeaderBytes
+
paddingControlBytes
+
promiseLen
]
self
-
>
mInputFrameDataSize
-
paddingControlBytes
-
promiseLen
-
paddingLength
)
;
if
(
self
-
>
mInputFrameFlags
&
kFlag_END_PUSH_PROMISE
)
{
rv
=
self
-
>
UncompressAndDiscard
(
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
uncompress
failed
\
n
"
)
)
;
self
-
>
mGoAwayReason
=
COMPRESSION_ERROR
;
return
rv
;
}
}
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
self
-
>
mDecompressBuffer
.
Append
(
&
self
-
>
mInputFrameBuffer
[
kFrameHeaderBytes
+
paddingControlBytes
+
promiseLen
]
self
-
>
mInputFrameDataSize
-
paddingControlBytes
-
promiseLen
-
paddingLength
)
;
if
(
self
-
>
mInputFrameType
!
=
FRAME_TYPE_CONTINUATION
)
{
self
-
>
mAggregatedHeaderSize
=
self
-
>
mInputFrameDataSize
-
paddingControlBytes
-
promiseLen
-
paddingLength
;
}
else
{
self
-
>
mAggregatedHeaderSize
+
=
self
-
>
mInputFrameDataSize
-
paddingControlBytes
-
promiseLen
-
paddingLength
;
}
if
(
!
(
self
-
>
mInputFrameFlags
&
kFlag_END_PUSH_PROMISE
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
not
finishing
processing
for
"
"
multi
-
frame
push
\
n
"
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_CONTINUATION
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_CONTINUED_HEADERS
self
-
>
mAggregatedHeaderSize
)
;
}
RefPtr
<
Http2PushTransactionBuffer
>
transactionBuffer
=
new
Http2PushTransactionBuffer
(
)
;
transactionBuffer
-
>
SetConnection
(
self
)
;
RefPtr
<
Http2PushedStream
>
pushedStream
(
new
Http2PushedStream
(
transactionBuffer
self
associatedStream
promisedID
self
-
>
mCurrentTopBrowsingContextId
)
)
;
rv
=
pushedStream
-
>
ConvertPushHeaders
(
&
self
-
>
mDecompressor
self
-
>
mDecompressBuffer
pushedStream
-
>
GetRequestString
(
)
)
;
if
(
rv
=
=
NS_ERROR_NOT_IMPLEMENTED
)
{
LOG3
(
(
"
Http2Session
:
:
PushPromise
Semantics
not
Implemented
\
n
"
)
)
;
self
-
>
GenerateRstStream
(
REFUSED_STREAM_ERROR
promisedID
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
rv
=
=
NS_ERROR_ILLEGAL_VALUE
)
{
self
-
>
GenerateRstStream
(
PROTOCOL_ERROR
promisedID
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
NS_FAILED
(
rv
)
)
{
self
-
>
mGoAwayReason
=
COMPRESSION_ERROR
;
return
rv
;
}
WeakPtr
<
Http2StreamBase
>
pushedWeak
=
pushedStream
.
get
(
)
;
self
-
>
mStreamTransactionHash
.
InsertOrUpdate
(
transactionBuffer
std
:
:
move
(
pushedStream
)
)
;
self
-
>
mPushedStreams
.
AppendElement
(
static_cast
<
Http2PushedStream
*
>
(
pushedWeak
.
get
(
)
)
)
;
if
(
self
-
>
RegisterStreamID
(
pushedWeak
promisedID
)
=
=
kDeadStreamID
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
registerstreamid
failed
\
n
"
)
)
;
self
-
>
mGoAwayReason
=
INTERNAL_ERROR
;
return
NS_ERROR_FAILURE
;
}
if
(
promisedID
>
self
-
>
mOutgoingGoAwayID
)
{
self
-
>
mOutgoingGoAwayID
=
promisedID
;
}
uint32_t
notUsed
;
Unused
<
<
pushedWeak
-
>
ReadSegments
(
nullptr
1
&
notUsed
)
;
nsAutoCString
key
;
if
(
!
static_cast
<
Http2PushedStream
*
>
(
pushedWeak
.
get
(
)
)
-
>
GetHashKey
(
key
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
one
of
:
authority
:
scheme
:
path
"
"
missing
from
push
\
n
"
)
)
;
self
-
>
CleanupStream
(
pushedWeak
NS_ERROR_FAILURE
PROTOCOL_ERROR
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
origin
check
%
s
"
self
pushedWeak
-
>
Origin
(
)
.
get
(
)
)
)
;
nsCOMPtr
<
nsIURI
>
pushedOrigin
;
rv
=
MakeOriginURL
(
pushedWeak
-
>
Origin
(
)
pushedOrigin
)
;
nsAutoCString
pushedHostName
;
int32_t
pushedPort
=
-
1
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
pushedOrigin
-
>
GetHost
(
pushedHostName
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
pushedOrigin
-
>
GetPort
(
&
pushedPort
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
pushedPort
=
=
-
1
)
{
if
(
pushedOrigin
-
>
SchemeIs
(
"
http
"
)
)
{
pushedPort
=
NS_HTTP_DEFAULT_PORT
;
}
else
{
pushedPort
=
NS_HTTPS_DEFAULT_PORT
;
}
}
}
if
(
NS_FAILED
(
rv
)
|
|
!
self
-
>
TestJoinConnection
(
pushedHostName
pushedPort
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
pushed
stream
mismatched
origin
%
s
\
n
"
self
pushedWeak
-
>
Origin
(
)
.
get
(
)
)
)
;
self
-
>
CleanupStream
(
pushedWeak
NS_ERROR_FAILURE
REFUSED_STREAM_ERROR
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
static_cast
<
Http2PushedStream
*
>
(
pushedWeak
.
get
(
)
)
-
>
TryOnPush
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
channel
implements
"
"
nsIHttpPushListener
"
"
stream
%
p
will
not
be
placed
into
session
cache
.
\
n
"
self
pushedWeak
.
get
(
)
)
)
;
}
else
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
place
stream
into
session
cache
\
n
"
self
)
)
;
if
(
!
cache
-
>
RegisterPushedStreamHttp2
(
key
static_cast
<
Http2PushedStream
*
>
(
pushedWeak
.
get
(
)
)
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
registerPushedStream
Failed
\
n
"
)
)
;
self
-
>
CleanupStream
(
pushedWeak
NS_ERROR_FAILURE
REFUSED_STREAM_ERROR
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
nsAutoCString
spec
;
spec
.
Assign
(
pushedWeak
-
>
Origin
(
)
)
;
spec
.
Append
(
pushedWeak
-
>
Path
(
)
)
;
nsCOMPtr
<
nsIURI
>
pushedURL
;
if
(
NS_SUCCEEDED
(
MakeOriginURL
(
spec
pushedURL
)
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
check
disk
cache
for
entry
"
self
)
)
;
mozilla
:
:
OriginAttributes
oa
;
pushedWeak
-
>
GetOriginAttributes
(
&
oa
)
;
RefPtr
<
Http2Session
>
session
=
self
;
auto
cachePushCheckCallback
=
[
session
promisedID
]
(
bool
aAccepted
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
)
;
if
(
!
aAccepted
)
{
session
-
>
CleanupStream
(
promisedID
NS_ERROR_FAILURE
Http2Session
:
:
REFUSED_STREAM_ERROR
)
;
}
}
;
RefPtr
<
CachePushChecker
>
checker
=
new
CachePushChecker
(
pushedURL
oa
static_cast
<
Http2PushedStream
*
>
(
pushedWeak
.
get
(
)
)
-
>
GetRequestString
(
)
std
:
:
move
(
cachePushCheckCallback
)
)
;
if
(
NS_FAILED
(
checker
-
>
DoCheck
(
)
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPushPromise
%
p
failed
to
open
cache
entry
for
"
"
push
check
"
self
)
)
;
}
}
}
if
(
!
pushedWeak
)
{
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
pushedWeak
-
>
SetHTTPState
(
Http2StreamBase
:
:
RESERVED_BY_REMOTE
)
;
static_assert
(
Http2StreamBase
:
:
kWorstPriority
>
=
0
"
kWorstPriority
out
of
range
"
)
;
uint32_t
priorityDependency
=
pushedWeak
-
>
PriorityDependency
(
)
;
uint8_t
priorityWeight
=
pushedWeak
-
>
PriorityWeight
(
)
;
self
-
>
SendPriorityFrame
(
promisedID
priorityDependency
priorityWeight
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
nsresult
Http2Session
:
:
RecvPing
(
Http2Session
*
self
)
{
MOZ_ASSERT
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_PING
)
;
LOG3
(
(
"
Http2Session
:
:
RecvPing
%
p
PING
Flags
0x
%
X
.
"
self
self
-
>
mInputFrameFlags
)
)
;
if
(
self
-
>
mInputFrameDataSize
!
=
8
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPing
%
p
PING
had
wrong
amount
of
data
%
d
"
self
self
-
>
mInputFrameDataSize
)
)
;
return
self
-
>
SessionError
(
FRAME_SIZE_ERROR
)
;
}
if
(
self
-
>
mInputFrameID
)
{
LOG3
(
(
"
Http2Session
:
:
RecvPing
%
p
PING
needs
stream
ID
of
0
.
0x
%
X
\
n
"
self
self
-
>
mInputFrameID
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
if
(
self
-
>
mInputFrameFlags
&
kFlag_ACK
)
{
self
-
>
mPingSentEpoch
=
0
;
}
else
{
self
-
>
GeneratePing
(
true
)
;
}
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
nsresult
Http2Session
:
:
RecvGoAway
(
Http2Session
*
self
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_GOAWAY
)
;
if
(
self
-
>
mInputFrameDataSize
<
8
)
{
LOG3
(
(
"
Http2Session
:
:
RecvGoAway
%
p
GOAWAY
had
wrong
amount
of
data
%
d
"
self
self
-
>
mInputFrameDataSize
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
if
(
self
-
>
mInputFrameID
)
{
LOG3
(
(
"
Http2Session
:
:
RecvGoAway
%
p
GOAWAY
had
non
zero
stream
ID
0x
%
X
\
n
"
self
self
-
>
mInputFrameID
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
self
-
>
mShouldGoAway
=
true
;
self
-
>
mGoAwayID
=
NetworkEndian
:
:
readUint32
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
)
;
self
-
>
mGoAwayID
&
=
0x7fffffff
;
self
-
>
mCleanShutdown
=
true
;
self
-
>
mPeerGoAwayReason
=
NetworkEndian
:
:
readUint32
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
+
4
)
;
for
(
const
auto
&
stream
:
self
-
>
mStreamTransactionHash
.
Values
(
)
)
{
if
(
(
stream
-
>
StreamID
(
)
>
self
-
>
mGoAwayID
&
&
(
stream
-
>
StreamID
(
)
&
1
)
)
|
|
!
stream
-
>
HasRegisteredID
(
)
)
{
self
-
>
mGoAwayStreamsToRestart
.
Push
(
stream
)
;
}
}
size_t
size
=
self
-
>
mGoAwayStreamsToRestart
.
GetSize
(
)
;
for
(
size_t
count
=
0
;
count
<
size
;
+
+
count
)
{
Http2StreamBase
*
stream
=
static_cast
<
Http2StreamBase
*
>
(
self
-
>
mGoAwayStreamsToRestart
.
PopFront
(
)
)
;
if
(
self
-
>
mPeerGoAwayReason
=
=
HTTP_1_1_REQUIRED
)
{
stream
-
>
Transaction
(
)
-
>
DisableSpdy
(
)
;
}
self
-
>
CloseStream
(
stream
NS_ERROR_NET_RESET
)
;
if
(
stream
-
>
HasRegisteredID
(
)
)
{
self
-
>
mStreamIDHash
.
Remove
(
stream
-
>
StreamID
(
)
)
;
}
self
-
>
mStreamTransactionHash
.
Remove
(
stream
-
>
Transaction
(
)
)
;
}
for
(
const
auto
&
stream
:
self
-
>
mQueuedStreams
)
{
MOZ_ASSERT
(
stream
-
>
Queued
(
)
)
;
stream
-
>
SetQueued
(
false
)
;
if
(
self
-
>
mPeerGoAwayReason
=
=
HTTP_1_1_REQUIRED
)
{
stream
-
>
Transaction
(
)
-
>
DisableSpdy
(
)
;
}
self
-
>
CloseStream
(
stream
NS_ERROR_NET_RESET
)
;
self
-
>
mStreamTransactionHash
.
Remove
(
stream
-
>
Transaction
(
)
)
;
}
self
-
>
mQueuedStreams
.
Clear
(
)
;
LOG3
(
(
"
Http2Session
:
:
RecvGoAway
%
p
GOAWAY
Last
-
Good
-
ID
0x
%
X
status
0x
%
X
"
"
live
streams
=
%
d
\
n
"
self
self
-
>
mGoAwayID
self
-
>
mPeerGoAwayReason
self
-
>
mStreamTransactionHash
.
Count
(
)
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
nsresult
Http2Session
:
:
RecvWindowUpdate
(
Http2Session
*
self
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_WINDOW_UPDATE
)
;
if
(
self
-
>
mInputFrameDataSize
!
=
4
)
{
LOG3
(
(
"
Http2Session
:
:
RecvWindowUpdate
%
p
Window
Update
wrong
length
%
d
\
n
"
self
self
-
>
mInputFrameDataSize
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
uint32_t
delta
=
NetworkEndian
:
:
readUint32
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
)
;
delta
&
=
0x7fffffff
;
LOG3
(
(
"
Http2Session
:
:
RecvWindowUpdate
%
p
len
=
%
d
Stream
0x
%
X
.
\
n
"
self
delta
self
-
>
mInputFrameID
)
)
;
if
(
self
-
>
mInputFrameID
)
{
nsresult
rv
=
self
-
>
SetInputFrameDataStream
(
self
-
>
mInputFrameID
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
!
self
-
>
mInputFrameDataStream
)
{
LOG3
(
(
"
Http2Session
:
:
RecvWindowUpdate
%
p
lookup
streamID
0x
%
X
failed
.
\
n
"
self
self
-
>
mInputFrameID
)
)
;
if
(
self
-
>
mInputFrameID
>
=
self
-
>
mNextStreamID
)
{
self
-
>
GenerateRstStream
(
PROTOCOL_ERROR
self
-
>
mInputFrameID
)
;
}
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
delta
=
=
0
)
{
LOG3
(
(
"
Http2Session
:
:
RecvWindowUpdate
%
p
received
0
stream
window
update
"
self
)
)
;
self
-
>
CleanupStream
(
self
-
>
mInputFrameDataStream
NS_ERROR_ILLEGAL_VALUE
PROTOCOL_ERROR
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
int64_t
oldRemoteWindow
=
self
-
>
mInputFrameDataStream
-
>
ServerReceiveWindow
(
)
;
self
-
>
mInputFrameDataStream
-
>
UpdateServerReceiveWindow
(
delta
)
;
if
(
self
-
>
mInputFrameDataStream
-
>
ServerReceiveWindow
(
)
>
=
0x80000000
)
{
LOG3
(
(
"
Http2Session
:
:
RecvWindowUpdate
%
p
stream
window
"
"
exceeds
2
^
31
-
1
\
n
"
self
)
)
;
self
-
>
CleanupStream
(
self
-
>
mInputFrameDataStream
NS_ERROR_ILLEGAL_VALUE
FLOW_CONTROL_ERROR
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
LOG3
(
(
"
Http2Session
:
:
RecvWindowUpdate
%
p
stream
0x
%
X
window
"
"
%
"
PRId64
"
increased
by
%
"
PRIu32
"
now
%
"
PRId64
"
.
\
n
"
self
self
-
>
mInputFrameID
oldRemoteWindow
delta
oldRemoteWindow
+
delta
)
)
;
}
else
{
if
(
delta
=
=
0
)
{
LOG3
(
(
"
Http2Session
:
:
RecvWindowUpdate
%
p
received
0
session
window
update
"
self
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
int64_t
oldRemoteWindow
=
self
-
>
mServerSessionWindow
;
self
-
>
mServerSessionWindow
+
=
delta
;
if
(
self
-
>
mServerSessionWindow
>
=
0x80000000
)
{
LOG3
(
(
"
Http2Session
:
:
RecvWindowUpdate
%
p
session
window
"
"
exceeds
2
^
31
-
1
\
n
"
self
)
)
;
return
self
-
>
SessionError
(
FLOW_CONTROL_ERROR
)
;
}
if
(
(
oldRemoteWindow
<
=
0
)
&
&
(
self
-
>
mServerSessionWindow
>
0
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvWindowUpdate
%
p
restart
session
window
\
n
"
self
)
)
;
for
(
const
auto
&
stream
:
self
-
>
mStreamTransactionHash
.
Values
(
)
)
{
MOZ_ASSERT
(
self
-
>
mServerSessionWindow
>
0
)
;
if
(
!
stream
-
>
BlockedOnRwin
(
)
|
|
stream
-
>
ServerReceiveWindow
(
)
<
=
0
)
{
continue
;
}
AddStreamToQueue
(
stream
self
-
>
mReadyForWrite
)
;
self
-
>
SetWriteCallbacks
(
)
;
}
}
LOG3
(
(
"
Http2Session
:
:
RecvWindowUpdate
%
p
session
window
"
"
%
"
PRId64
"
increased
by
%
d
now
%
"
PRId64
"
.
\
n
"
self
oldRemoteWindow
delta
oldRemoteWindow
+
delta
)
)
;
}
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
nsresult
Http2Session
:
:
RecvContinuation
(
Http2Session
*
self
)
{
MOZ_ASSERT
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_CONTINUATION
)
;
MOZ_ASSERT
(
self
-
>
mInputFrameID
)
;
MOZ_ASSERT
(
self
-
>
mExpectedPushPromiseID
|
|
self
-
>
mExpectedHeaderID
)
;
MOZ_ASSERT
(
!
(
self
-
>
mExpectedPushPromiseID
&
&
self
-
>
mExpectedHeaderID
)
)
;
LOG3
(
(
"
Http2Session
:
:
RecvContinuation
%
p
Flags
0x
%
X
id
0x
%
X
"
"
promise
id
0x
%
X
header
id
0x
%
X
\
n
"
self
self
-
>
mInputFrameFlags
self
-
>
mInputFrameID
self
-
>
mExpectedPushPromiseID
self
-
>
mExpectedHeaderID
)
)
;
DebugOnly
<
nsresult
>
rv
=
self
-
>
SetInputFrameDataStream
(
self
-
>
mInputFrameID
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
self
-
>
mInputFrameDataStream
)
{
LOG3
(
(
"
Http2Session
:
:
RecvContination
stream
ID
0x
%
X
not
found
.
"
self
-
>
mInputFrameID
)
)
;
return
self
-
>
SessionError
(
PROTOCOL_ERROR
)
;
}
if
(
self
-
>
mExpectedHeaderID
)
{
self
-
>
mInputFrameFlags
&
=
~
kFlag_PRIORITY
;
return
RecvHeaders
(
self
)
;
}
if
(
self
-
>
mInputFrameFlags
&
kFlag_END_HEADERS
)
{
self
-
>
mInputFrameFlags
&
=
~
kFlag_END_HEADERS
;
self
-
>
mInputFrameFlags
|
=
kFlag_END_PUSH_PROMISE
;
}
return
RecvPushPromise
(
self
)
;
}
class
UpdateAltSvcEvent
:
public
Runnable
{
public
:
UpdateAltSvcEvent
(
const
nsCString
&
header
const
nsCString
&
aOrigin
nsHttpConnectionInfo
*
aCI
nsIInterfaceRequestor
*
callbacks
)
:
Runnable
(
"
net
:
:
UpdateAltSvcEvent
"
)
mHeader
(
header
)
mOrigin
(
aOrigin
)
mCI
(
aCI
)
mCallbacks
(
callbacks
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCString
originScheme
;
nsCString
originHost
;
int32_t
originPort
=
-
1
;
nsCOMPtr
<
nsIURI
>
uri
;
if
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
uri
)
mOrigin
)
)
)
{
LOG
(
(
"
UpdateAltSvcEvent
origin
does
not
parse
%
s
\
n
"
mOrigin
.
get
(
)
)
)
;
return
NS_OK
;
}
uri
-
>
GetScheme
(
originScheme
)
;
uri
-
>
GetHost
(
originHost
)
;
uri
-
>
GetPort
(
&
originPort
)
;
if
(
XRE_IsSocketProcess
(
)
)
{
AltServiceChild
:
:
ProcessHeader
(
mHeader
originScheme
originHost
originPort
mCI
-
>
GetUsername
(
)
mCI
-
>
GetPrivate
(
)
mCallbacks
mCI
-
>
ProxyInfo
(
)
0
mCI
-
>
GetOriginAttributes
(
)
)
;
return
NS_OK
;
}
AltSvcMapping
:
:
ProcessHeader
(
mHeader
originScheme
originHost
originPort
mCI
-
>
GetUsername
(
)
mCI
-
>
GetPrivate
(
)
nullptr
mCI
-
>
ProxyInfo
(
)
0
mCI
-
>
GetOriginAttributes
(
)
)
;
return
NS_OK
;
}
private
:
nsCString
mHeader
;
nsCString
mOrigin
;
RefPtr
<
nsHttpConnectionInfo
>
mCI
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
}
;
nsresult
Http2Session
:
:
RecvAltSvc
(
Http2Session
*
self
)
{
MOZ_ASSERT
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_ALTSVC
)
;
LOG3
(
(
"
Http2Session
:
:
RecvAltSvc
%
p
Flags
0x
%
X
id
0x
%
X
\
n
"
self
self
-
>
mInputFrameFlags
self
-
>
mInputFrameID
)
)
;
if
(
self
-
>
mInputFrameDataSize
<
2
)
{
LOG3
(
(
"
Http2Session
:
:
RecvAltSvc
%
p
frame
too
small
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
uint16_t
originLen
=
NetworkEndian
:
:
readUint16
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
)
;
if
(
originLen
+
2U
>
self
-
>
mInputFrameDataSize
)
{
LOG3
(
(
"
Http2Session
:
:
RecvAltSvc
%
p
origin
len
too
big
for
frame
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
!
gHttpHandler
-
>
AllowAltSvc
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvAltSvc
%
p
frame
alt
service
pref
'
d
off
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
uint16_t
altSvcFieldValueLen
=
static_cast
<
uint16_t
>
(
self
-
>
mInputFrameDataSize
)
-
2U
-
originLen
;
LOG3
(
(
"
Http2Session
:
:
RecvAltSvc
%
p
frame
originLen
=
%
u
altSvcFieldValueLen
=
%
u
\
n
"
self
originLen
altSvcFieldValueLen
)
)
;
if
(
self
-
>
mInputFrameDataSize
>
2000
)
{
LOG3
(
(
"
Http2Session
:
:
RecvAltSvc
%
p
frame
too
large
to
parse
sensibly
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
nsAutoCString
origin
;
bool
impliedOrigin
=
true
;
if
(
originLen
)
{
origin
.
Assign
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
+
2
originLen
)
;
impliedOrigin
=
false
;
}
nsAutoCString
altSvcFieldValue
;
if
(
altSvcFieldValueLen
)
{
altSvcFieldValue
.
Assign
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
+
2
+
originLen
altSvcFieldValueLen
)
;
}
if
(
altSvcFieldValue
.
IsEmpty
(
)
|
|
!
nsHttp
:
:
IsReasonableHeaderValue
(
altSvcFieldValue
)
)
{
LOG
(
(
"
Http2Session
%
p
Alt
-
Svc
Response
Header
seems
unreasonable
-
"
"
skipping
\
n
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
self
-
>
mInputFrameID
&
1
)
{
if
(
!
origin
.
IsEmpty
(
)
)
{
LOG
(
(
"
Http2Session
%
p
Alt
-
Svc
pulled
stream
has
non
empty
origin
\
n
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
NS_FAILED
(
self
-
>
SetInputFrameDataStream
(
self
-
>
mInputFrameID
)
)
|
|
!
self
-
>
mInputFrameDataStream
|
|
!
self
-
>
mInputFrameDataStream
-
>
Transaction
(
)
|
|
!
self
-
>
mInputFrameDataStream
-
>
Transaction
(
)
-
>
RequestHead
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvAltSvc
%
p
got
frame
w
/
o
origin
on
invalid
stream
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
self
-
>
mInputFrameDataStream
-
>
Transaction
(
)
-
>
RequestHead
(
)
-
>
Origin
(
origin
)
;
}
else
if
(
!
self
-
>
mInputFrameID
)
{
if
(
origin
.
IsEmpty
(
)
)
{
LOG
(
(
"
Http2Session
%
p
Alt
-
Svc
Stream
0
has
empty
origin
\
n
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
}
else
{
LOG
(
(
"
Http2Session
%
p
Alt
-
Svc
received
on
pushed
stream
-
ignoring
\
n
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
RefPtr
<
nsHttpConnectionInfo
>
ci
(
self
-
>
ConnectionInfo
(
)
)
;
if
(
!
self
-
>
mConnection
|
|
!
ci
)
{
LOG3
(
(
"
Http2Session
:
:
RecvAltSvc
%
p
no
connection
or
conninfo
for
%
d
"
self
self
-
>
mInputFrameID
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
!
impliedOrigin
)
{
bool
okToReroute
=
true
;
nsCOMPtr
<
nsISSLSocketControl
>
ssl
;
self
-
>
mConnection
-
>
GetTLSSocketControl
(
getter_AddRefs
(
ssl
)
)
;
if
(
!
ssl
)
{
okToReroute
=
false
;
}
nsAutoCString
specifiedOriginHost
;
if
(
StringBeginsWith
(
origin
"
https
:
/
/
"
_ns
nsCaseInsensitiveCStringComparator
)
)
{
specifiedOriginHost
.
Assign
(
origin
.
get
(
)
+
8
origin
.
Length
(
)
-
8
)
;
}
else
if
(
StringBeginsWith
(
origin
"
http
:
/
/
"
_ns
nsCaseInsensitiveCStringComparator
)
)
{
specifiedOriginHost
.
Assign
(
origin
.
get
(
)
+
7
origin
.
Length
(
)
-
7
)
;
}
int32_t
colonOffset
=
specifiedOriginHost
.
FindCharInSet
(
"
:
"
0
)
;
if
(
colonOffset
!
=
kNotFound
)
{
specifiedOriginHost
.
Truncate
(
colonOffset
)
;
}
if
(
okToReroute
)
{
ssl
-
>
IsAcceptableForHost
(
specifiedOriginHost
&
okToReroute
)
;
}
if
(
!
okToReroute
)
{
LOG3
(
(
"
Http2Session
:
:
RecvAltSvc
%
p
can
'
t
reroute
non
-
authoritative
origin
"
"
%
s
"
self
origin
.
BeginReading
(
)
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsISSLSocketControl
>
tlsSocketControl
;
self
-
>
mConnection
-
>
GetTLSSocketControl
(
getter_AddRefs
(
tlsSocketControl
)
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
if
(
tlsSocketControl
)
{
tlsSocketControl
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
}
RefPtr
<
UpdateAltSvcEvent
>
event
=
new
UpdateAltSvcEvent
(
altSvcFieldValue
origin
ci
callbacks
)
;
NS_DispatchToMainThread
(
event
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
void
Http2Session
:
:
Received421
(
nsHttpConnectionInfo
*
ci
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
Recevied421
%
p
%
d
\
n
"
this
mOriginFrameActivated
)
)
;
if
(
!
mOriginFrameActivated
|
|
!
ci
)
{
return
;
}
nsAutoCString
key
(
ci
-
>
GetOrigin
(
)
)
;
key
.
Append
(
'
:
'
)
;
key
.
AppendInt
(
ci
-
>
OriginPort
(
)
)
;
mOriginFrame
.
Remove
(
key
)
;
LOG3
(
(
"
Http2Session
:
:
Received421
%
p
key
%
s
removed
\
n
"
this
key
.
get
(
)
)
)
;
}
nsresult
Http2Session
:
:
RecvUnused
(
Http2Session
*
self
)
{
LOG3
(
(
"
Http2Session
%
p
unknown
frame
type
%
x
ignored
\
n
"
self
self
-
>
mInputFrameType
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
nsresult
Http2Session
:
:
RecvOrigin
(
Http2Session
*
self
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
self
-
>
mInputFrameType
=
=
FRAME_TYPE_ORIGIN
)
;
LOG3
(
(
"
Http2Session
:
:
RecvOrigin
%
p
Flags
0x
%
X
id
0x
%
X
\
n
"
self
self
-
>
mInputFrameFlags
self
-
>
mInputFrameID
)
)
;
if
(
self
-
>
mInputFrameFlags
&
0x0F
)
{
LOG3
(
(
"
Http2Session
:
:
RecvOrigin
%
p
leading
flags
must
be
0
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
self
-
>
mInputFrameID
)
{
LOG3
(
(
"
Http2Session
:
:
RecvOrigin
%
p
not
stream
0
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
self
-
>
ConnectionInfo
(
)
-
>
UsingProxy
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvOrigin
%
p
must
not
use
proxy
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
if
(
!
gHttpHandler
-
>
AllowOriginExtension
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvOrigin
%
p
origin
extension
pref
'
d
off
"
self
)
)
;
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
uint32_t
offset
=
0
;
self
-
>
mOriginFrameActivated
=
true
;
while
(
self
-
>
mInputFrameDataSize
>
=
(
offset
+
2U
)
)
{
uint16_t
originLen
=
NetworkEndian
:
:
readUint16
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
+
offset
)
;
LOG3
(
(
"
Http2Session
:
:
RecvOrigin
%
p
origin
extension
defined
as
%
d
bytes
\
n
"
self
originLen
)
)
;
if
(
originLen
+
2U
+
offset
>
self
-
>
mInputFrameDataSize
)
{
LOG3
(
(
"
Http2Session
:
:
RecvOrigin
%
p
origin
len
too
big
for
frame
"
self
)
)
;
break
;
}
nsAutoCString
originString
;
nsCOMPtr
<
nsIURI
>
originURL
;
originString
.
Assign
(
self
-
>
mInputFrameBuffer
.
get
(
)
+
kFrameHeaderBytes
+
offset
+
2
originLen
)
;
offset
+
=
originLen
+
2
;
if
(
NS_FAILED
(
MakeOriginURL
(
originString
originURL
)
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvOrigin
%
p
origin
frame
string
%
s
failed
to
"
"
parse
\
n
"
self
originString
.
get
(
)
)
)
;
continue
;
}
LOG3
(
(
"
Http2Session
:
:
RecvOrigin
%
p
origin
frame
string
%
s
parsed
OK
\
n
"
self
originString
.
get
(
)
)
)
;
if
(
!
originURL
-
>
SchemeIs
(
"
https
"
)
)
{
LOG3
(
(
"
Http2Session
:
:
RecvOrigin
%
p
origin
frame
not
https
\
n
"
self
)
)
;
continue
;
}
int32_t
port
=
-
1
;
originURL
-
>
GetPort
(
&
port
)
;
if
(
port
=
=
-
1
)
{
port
=
443
;
}
nsAutoCString
host
;
originURL
-
>
GetHost
(
host
)
;
nsAutoCString
key
(
host
)
;
key
.
Append
(
'
:
'
)
;
key
.
AppendInt
(
port
)
;
self
-
>
mOriginFrame
.
WithEntryHandle
(
key
[
&
]
(
auto
&
&
entry
)
{
if
(
!
entry
)
{
entry
.
Insert
(
true
)
;
RefPtr
<
HttpConnectionBase
>
conn
(
self
-
>
HttpConnection
(
)
)
;
MOZ_ASSERT
(
conn
.
get
(
)
)
;
gHttpHandler
-
>
ConnMgr
(
)
-
>
RegisterOriginCoalescingKey
(
conn
host
port
)
;
}
else
{
LOG3
(
(
"
Http2Session
:
:
RecvOrigin
%
p
origin
frame
already
in
set
\
n
"
self
)
)
;
}
}
)
;
}
self
-
>
ResetDownstreamState
(
)
;
return
NS_OK
;
}
void
Http2Session
:
:
OnTransportStatus
(
nsITransport
*
aTransport
nsresult
aStatus
int64_t
aProgress
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
switch
(
aStatus
)
{
case
NS_NET_STATUS_RESOLVING_HOST
:
case
NS_NET_STATUS_RESOLVED_HOST
:
case
NS_NET_STATUS_CONNECTING_TO
:
case
NS_NET_STATUS_CONNECTED_TO
:
case
NS_NET_STATUS_TLS_HANDSHAKE_STARTING
:
case
NS_NET_STATUS_TLS_HANDSHAKE_ENDED
:
{
if
(
!
mFirstHttpTransaction
)
{
if
(
mConnection
)
{
RefPtr
<
HttpConnectionBase
>
conn
=
mConnection
-
>
HttpConnection
(
)
;
conn
-
>
SetEvent
(
aStatus
)
;
}
}
else
{
mFirstHttpTransaction
-
>
OnTransportStatus
(
aTransport
aStatus
aProgress
)
;
}
if
(
aStatus
=
=
NS_NET_STATUS_TLS_HANDSHAKE_ENDED
)
{
mFirstHttpTransaction
=
nullptr
;
mTlsHandshakeFinished
=
true
;
}
break
;
}
default
:
break
;
}
}
nsresult
Http2Session
:
:
ReadSegmentsAgain
(
nsAHttpSegmentReader
*
reader
uint32_t
count
uint32_t
*
countRead
bool
*
again
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mSegmentReader
|
|
!
reader
|
|
(
mSegmentReader
=
=
reader
)
"
Inconsistent
Write
Function
Callback
"
)
;
nsresult
rv
=
ConfirmTLSProfile
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mGoAwayReason
=
=
INADEQUATE_SECURITY
)
{
LOG3
(
(
"
Http2Session
:
:
ReadSegments
%
p
returning
INADEQUATE_SECURITY
"
"
%
"
PRIx32
this
static_cast
<
uint32_t
>
(
NS_ERROR_NET_INADEQUATE_SECURITY
)
)
)
;
rv
=
NS_ERROR_NET_INADEQUATE_SECURITY
;
}
return
rv
;
}
if
(
reader
)
mSegmentReader
=
reader
;
*
countRead
=
0
;
LOG3
(
(
"
Http2Session
:
:
ReadSegments
%
p
"
this
)
)
;
RefPtr
<
Http2StreamBase
>
stream
=
GetNextStreamFromQueue
(
mReadyForWrite
)
;
if
(
!
stream
)
{
LOG3
(
(
"
Http2Session
%
p
could
not
identify
a
stream
to
write
;
suspending
.
"
this
)
)
;
uint32_t
availBeforeFlush
=
mOutputQueueUsed
-
mOutputQueueSent
;
FlushOutputQueue
(
)
;
uint32_t
availAfterFlush
=
mOutputQueueUsed
-
mOutputQueueSent
;
if
(
availBeforeFlush
!
=
availAfterFlush
)
{
LOG3
(
(
"
Http2Session
%
p
ResumeRecv
After
early
flush
in
ReadSegments
"
this
)
)
;
Unused
<
<
ResumeRecv
(
)
;
}
SetWriteCallbacks
(
)
;
if
(
mAttemptingEarlyData
)
{
*
countRead
=
mOutputQueueUsed
-
mOutputQueueSent
;
LOG
(
(
"
Http2Session
%
p
nothing
to
send
because
of
0RTT
failed
"
this
)
)
;
Unused
<
<
ResumeRecv
(
)
;
}
return
*
countRead
?
NS_OK
:
NS_BASE_STREAM_WOULD_BLOCK
;
}
uint32_t
earlyDataUsed
=
0
;
if
(
mAttemptingEarlyData
)
{
if
(
!
stream
-
>
Do0RTT
(
)
)
{
LOG3
(
(
"
Http2Session
%
p
will
not
get
early
data
from
Http2StreamBase
%
p
"
"
0x
%
X
"
this
stream
.
get
(
)
stream
-
>
StreamID
(
)
)
)
;
FlushOutputQueue
(
)
;
SetWriteCallbacks
(
)
;
if
(
!
mCannotDo0RTTStreams
.
Contains
(
stream
)
)
{
mCannotDo0RTTStreams
.
AppendElement
(
stream
)
;
}
*
countRead
=
mOutputQueueUsed
-
mOutputQueueSent
;
return
*
countRead
?
NS_OK
:
NS_BASE_STREAM_WOULD_BLOCK
;
}
count
-
=
(
mOutputQueueUsed
-
mOutputQueueSent
)
;
earlyDataUsed
=
mOutputQueueUsed
-
mOutputQueueSent
;
}
LOG3
(
(
"
Http2Session
%
p
will
write
from
Http2StreamBase
%
p
0x
%
X
"
"
block
-
input
=
%
d
block
-
output
=
%
d
\
n
"
this
stream
.
get
(
)
stream
-
>
StreamID
(
)
stream
-
>
RequestBlockedOnRead
(
)
stream
-
>
BlockedOnRwin
(
)
)
)
;
rv
=
stream
-
>
ReadSegments
(
this
count
countRead
)
;
if
(
earlyDataUsed
)
{
*
countRead
+
=
earlyDataUsed
;
}
if
(
mAttemptingEarlyData
&
&
!
m0RTTStreams
.
Contains
(
stream
)
)
{
LOG3
(
(
"
Http2Session
:
:
ReadSegmentsAgain
adding
stream
%
d
to
m0RTTStreams
\
n
"
stream
-
>
StreamID
(
)
)
)
;
m0RTTStreams
.
AppendElement
(
stream
)
;
}
FlushOutputQueue
(
)
;
Unused
<
<
ResumeRecv
(
)
;
if
(
stream
-
>
RequestBlockedOnRead
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
ReadSegments
%
p
dealing
with
block
on
read
"
this
)
)
;
if
(
GetWriteQueueSize
(
)
)
{
rv
=
NS_OK
;
}
else
{
rv
=
NS_BASE_STREAM_WOULD_BLOCK
;
}
SetWriteCallbacks
(
)
;
return
rv
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
ReadSegments
%
p
may
return
FAIL
code
%
"
PRIX32
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
return
rv
;
}
CleanupStream
(
stream
rv
CANCEL_ERROR
)
;
if
(
SoftStreamError
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
ReadSegments
%
p
soft
error
override
\
n
"
this
)
)
;
*
again
=
false
;
SetWriteCallbacks
(
)
;
rv
=
NS_OK
;
}
return
rv
;
}
if
(
*
countRead
>
0
)
{
LOG3
(
(
"
Http2Session
:
:
ReadSegments
%
p
stream
=
%
p
countread
=
%
d
"
this
stream
.
get
(
)
*
countRead
)
)
;
AddStreamToQueue
(
stream
mReadyForWrite
)
;
SetWriteCallbacks
(
)
;
return
rv
;
}
if
(
stream
-
>
BlockedOnRwin
(
)
)
{
LOG3
(
(
"
Http2Session
%
p
will
stream
%
p
0x
%
X
suspended
for
flow
control
\
n
"
this
stream
.
get
(
)
stream
-
>
StreamID
(
)
)
)
;
return
NS_BASE_STREAM_WOULD_BLOCK
;
}
LOG3
(
(
"
Http2Session
:
:
ReadSegments
%
p
stream
=
%
p
stream
send
complete
"
this
stream
.
get
(
)
)
)
;
SetWriteCallbacks
(
)
;
return
rv
;
}
nsresult
Http2Session
:
:
ReadSegments
(
nsAHttpSegmentReader
*
reader
uint32_t
count
uint32_t
*
countRead
)
{
bool
again
=
false
;
return
ReadSegmentsAgain
(
reader
count
countRead
&
again
)
;
}
nsresult
Http2Session
:
:
ReadyToProcessDataFrame
(
enum
internalStateType
newState
)
{
MOZ_ASSERT
(
newState
=
=
PROCESSING_DATA_FRAME
|
|
newState
=
=
DISCARDING_DATA_FRAME_PADDING
)
;
ChangeDownstreamState
(
newState
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SPDY_CHUNK_RECVD
mInputFrameDataSize
>
>
10
)
;
mLastDataReadEpoch
=
mLastReadEpoch
;
if
(
!
mInputFrameID
)
{
LOG3
(
(
"
Http2Session
:
:
ReadyToProcessDataFrame
%
p
data
frame
stream
0
\
n
"
this
)
)
;
return
SessionError
(
PROTOCOL_ERROR
)
;
}
nsresult
rv
=
SetInputFrameDataStream
(
mInputFrameID
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
ReadyToProcessDataFrame
%
p
lookup
streamID
0x
%
X
"
"
failed
.
probably
due
to
verification
.
\
n
"
this
mInputFrameID
)
)
;
return
rv
;
}
if
(
!
mInputFrameDataStream
)
{
LOG3
(
(
"
Http2Session
:
:
ReadyToProcessDataFrame
%
p
lookup
streamID
0x
%
X
"
"
failed
.
Next
=
0x
%
X
"
this
mInputFrameID
mNextStreamID
)
)
;
if
(
mInputFrameID
>
=
mNextStreamID
)
{
GenerateRstStream
(
PROTOCOL_ERROR
mInputFrameID
)
;
}
ChangeDownstreamState
(
DISCARDING_DATA_FRAME
)
;
}
else
if
(
mInputFrameDataStream
-
>
RecvdFin
(
)
|
|
mInputFrameDataStream
-
>
RecvdReset
(
)
|
|
mInputFrameDataStream
-
>
SentReset
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
ReadyToProcessDataFrame
%
p
streamID
0x
%
X
"
"
Data
arrived
for
already
server
closed
stream
.
\
n
"
this
mInputFrameID
)
)
;
if
(
mInputFrameDataStream
-
>
RecvdFin
(
)
|
|
mInputFrameDataStream
-
>
RecvdReset
(
)
)
{
GenerateRstStream
(
STREAM_CLOSED_ERROR
mInputFrameID
)
;
}
ChangeDownstreamState
(
DISCARDING_DATA_FRAME
)
;
}
else
if
(
mInputFrameDataSize
=
=
0
&
&
!
mInputFrameFinal
)
{
LOG3
(
(
"
Http2Session
:
:
ReadyToProcessDataFrame
%
p
streamID
0x
%
X
"
"
Ignoring
0
-
length
non
-
terminal
data
frame
.
"
this
mInputFrameID
)
)
;
ChangeDownstreamState
(
DISCARDING_DATA_FRAME
)
;
}
else
if
(
newState
=
=
PROCESSING_DATA_FRAME
&
&
!
mInputFrameDataStream
-
>
AllHeadersReceived
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
ReadyToProcessDataFrame
%
p
streamID
0x
%
X
"
"
Receiving
data
frame
without
having
headers
.
"
this
mInputFrameID
)
)
;
CleanupStream
(
mInputFrameDataStream
NS_ERROR_NET_HTTP2_SENT_GOAWAY
PROTOCOL_ERROR
)
;
return
NS_OK
;
}
LOG3
(
(
"
Start
Processing
Data
Frame
.
"
"
Session
=
%
p
Stream
ID
0x
%
X
Stream
Ptr
%
p
Fin
=
%
d
Len
=
%
d
"
this
mInputFrameID
mInputFrameDataStream
mInputFrameFinal
mInputFrameDataSize
)
)
;
UpdateLocalRwin
(
mInputFrameDataStream
mInputFrameDataSize
)
;
if
(
mInputFrameDataStream
)
{
mInputFrameDataStream
-
>
SetRecvdData
(
true
)
;
}
return
NS_OK
;
}
nsresult
Http2Session
:
:
WriteSegmentsAgain
(
nsAHttpSegmentWriter
*
writer
uint32_t
count
uint32_t
*
countWritten
bool
*
again
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
WriteSegments
%
p
InternalState
%
X
\
n
"
this
mDownstreamState
)
)
;
*
countWritten
=
0
;
if
(
mClosed
)
{
LOG
(
(
"
Http2Session
:
:
WriteSegments
%
p
already
closed
"
this
)
)
;
return
NS_ERROR_ABORT
;
}
nsresult
rv
=
ConfirmTLSProfile
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
SetWriteCallbacks
(
)
;
RefPtr
<
Http2StreamBase
>
pushConnectedStream
=
GetNextStreamFromQueue
(
mPushesReadyForRead
)
;
if
(
pushConnectedStream
)
{
return
ProcessConnectedPush
(
pushConnectedStream
writer
count
countWritten
)
;
}
RefPtr
<
Http2StreamBase
>
slowConsumer
=
GetNextStreamFromQueue
(
mSlowConsumersReadyForRead
)
;
if
(
slowConsumer
)
{
internalStateType
savedState
=
mDownstreamState
;
mDownstreamState
=
NOT_USING_NETWORK
;
rv
=
ProcessSlowConsumer
(
slowConsumer
writer
count
countWritten
)
;
mDownstreamState
=
savedState
;
return
rv
;
}
if
(
mDownstreamState
=
=
BUFFERING_OPENING_SETTINGS
|
|
mDownstreamState
=
=
BUFFERING_FRAME_HEADER
)
{
MOZ_ASSERT
(
mInputFrameBufferUsed
<
kFrameHeaderBytes
"
Frame
Buffer
Used
Too
Large
for
State
"
)
;
rv
=
NetworkRead
(
writer
&
mInputFrameBuffer
[
mInputFrameBufferUsed
]
kFrameHeaderBytes
-
mInputFrameBufferUsed
countWritten
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
%
p
buffering
frame
header
read
failure
%
"
PRIx32
"
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
rv
=
NS_OK
;
return
rv
;
}
LogIO
(
this
nullptr
"
Reading
Frame
Header
"
&
mInputFrameBuffer
[
mInputFrameBufferUsed
]
*
countWritten
)
;
mInputFrameBufferUsed
+
=
*
countWritten
;
if
(
mInputFrameBufferUsed
<
kFrameHeaderBytes
)
{
LOG3
(
(
"
Http2Session
:
:
WriteSegments
%
p
"
"
BUFFERING
FRAME
HEADER
incomplete
size
=
%
d
"
this
mInputFrameBufferUsed
)
)
;
return
rv
;
}
uint8_t
totallyWastedByte
=
mInputFrameBuffer
.
get
(
)
[
0
]
;
mInputFrameDataSize
=
NetworkEndian
:
:
readUint16
(
mInputFrameBuffer
.
get
(
)
+
1
)
;
if
(
totallyWastedByte
|
|
(
mInputFrameDataSize
>
kMaxFrameData
)
)
{
LOG3
(
(
"
Got
frame
too
large
0x
%
02X
%
04X
"
totallyWastedByte
mInputFrameDataSize
)
)
;
return
SessionError
(
PROTOCOL_ERROR
)
;
}
mInputFrameType
=
*
reinterpret_cast
<
uint8_t
*
>
(
mInputFrameBuffer
.
get
(
)
+
kFrameLengthBytes
)
;
mInputFrameFlags
=
*
reinterpret_cast
<
uint8_t
*
>
(
mInputFrameBuffer
.
get
(
)
+
kFrameLengthBytes
+
kFrameTypeBytes
)
;
mInputFrameID
=
NetworkEndian
:
:
readUint32
(
mInputFrameBuffer
.
get
(
)
+
kFrameLengthBytes
+
kFrameTypeBytes
+
kFrameFlagBytes
)
;
mInputFrameID
&
=
0x7fffffff
;
mInputFrameDataRead
=
0
;
if
(
mInputFrameType
=
=
FRAME_TYPE_DATA
|
|
mInputFrameType
=
=
FRAME_TYPE_HEADERS
)
{
mInputFrameFinal
=
mInputFrameFlags
&
kFlag_END_STREAM
;
}
else
{
mInputFrameFinal
=
false
;
}
mPaddingLength
=
0
;
LOG3
(
(
"
Http2Session
:
:
WriteSegments
[
%
p
:
:
%
"
PRIu64
"
]
Frame
Header
Read
"
"
type
%
X
data
len
%
u
flags
%
x
id
0x
%
X
"
this
mSerial
mInputFrameType
mInputFrameDataSize
mInputFrameFlags
mInputFrameID
)
)
;
if
(
mExpectedHeaderID
&
&
(
(
mInputFrameType
!
=
FRAME_TYPE_CONTINUATION
)
|
|
(
mExpectedHeaderID
!
=
mInputFrameID
)
)
)
{
LOG3
(
(
"
Expected
CONINUATION
OF
HEADERS
for
ID
0x
%
X
\
n
"
mExpectedHeaderID
)
)
;
return
SessionError
(
PROTOCOL_ERROR
)
;
}
if
(
mExpectedPushPromiseID
&
&
(
(
mInputFrameType
!
=
FRAME_TYPE_CONTINUATION
)
|
|
(
mExpectedPushPromiseID
!
=
mInputFrameID
)
)
)
{
LOG3
(
(
"
Expected
CONTINUATION
of
PUSH
PROMISE
for
ID
0x
%
X
\
n
"
mExpectedPushPromiseID
)
)
;
return
SessionError
(
PROTOCOL_ERROR
)
;
}
if
(
mDownstreamState
=
=
BUFFERING_OPENING_SETTINGS
&
&
mInputFrameType
!
=
FRAME_TYPE_SETTINGS
)
{
LOG3
(
(
"
First
Frame
Type
Must
Be
Settings
\
n
"
)
)
;
mPeerFailedHandshake
=
true
;
RefPtr
<
nsHttpConnectionInfo
>
ci
=
ConnectionInfo
(
)
;
if
(
ci
)
{
gHttpHandler
-
>
ExcludeHttp2
(
ci
)
;
}
for
(
const
auto
&
stream
:
mStreamTransactionHash
.
Values
(
)
)
{
stream
-
>
Transaction
(
)
-
>
DisableSpdy
(
)
;
CloseStream
(
stream
NS_ERROR_NET_RESET
)
;
}
mStreamTransactionHash
.
Clear
(
)
;
return
SessionError
(
PROTOCOL_ERROR
)
;
}
if
(
mInputFrameType
!
=
FRAME_TYPE_DATA
)
{
EnsureBuffer
(
mInputFrameBuffer
mInputFrameDataSize
+
kFrameHeaderBytes
kFrameHeaderBytes
mInputFrameBufferSize
)
;
ChangeDownstreamState
(
BUFFERING_CONTROL_FRAME
)
;
}
else
if
(
mInputFrameFlags
&
kFlag_PADDED
)
{
ChangeDownstreamState
(
PROCESSING_DATA_FRAME_PADDING_CONTROL
)
;
}
else
{
rv
=
ReadyToProcessDataFrame
(
PROCESSING_DATA_FRAME
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
if
(
mDownstreamState
=
=
PROCESSING_DATA_FRAME_PADDING_CONTROL
)
{
MOZ_ASSERT
(
mInputFrameFlags
&
kFlag_PADDED
"
Processing
padding
control
on
unpadded
frame
"
)
;
MOZ_ASSERT
(
mInputFrameBufferUsed
<
(
kFrameHeaderBytes
+
1
)
"
Frame
buffer
used
too
large
for
state
"
)
;
rv
=
NetworkRead
(
writer
&
mInputFrameBuffer
[
mInputFrameBufferUsed
]
(
kFrameHeaderBytes
+
1
)
-
mInputFrameBufferUsed
countWritten
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
%
p
buffering
data
frame
padding
control
read
failure
"
"
%
"
PRIx32
"
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
rv
=
NS_OK
;
return
rv
;
}
LogIO
(
this
nullptr
"
Reading
Data
Frame
Padding
Control
"
&
mInputFrameBuffer
[
mInputFrameBufferUsed
]
*
countWritten
)
;
mInputFrameBufferUsed
+
=
*
countWritten
;
if
(
mInputFrameBufferUsed
-
kFrameHeaderBytes
<
1
)
{
LOG3
(
(
"
Http2Session
:
:
WriteSegments
%
p
"
"
BUFFERING
DATA
FRAME
CONTROL
PADDING
incomplete
size
=
%
d
"
this
mInputFrameBufferUsed
-
8
)
)
;
return
rv
;
}
+
+
mInputFrameDataRead
;
char
*
control
=
&
mInputFrameBuffer
[
kFrameHeaderBytes
]
;
mPaddingLength
=
static_cast
<
uint8_t
>
(
*
control
)
;
LOG3
(
(
"
Http2Session
:
:
WriteSegments
%
p
stream
0x
%
X
mPaddingLength
=
%
d
"
this
mInputFrameID
mPaddingLength
)
)
;
if
(
1U
+
mPaddingLength
>
mInputFrameDataSize
)
{
LOG3
(
(
"
Http2Session
:
:
WriteSegments
%
p
stream
0x
%
X
padding
too
large
for
"
"
frame
"
this
mInputFrameID
)
)
;
return
SessionError
(
PROTOCOL_ERROR
)
;
}
if
(
1U
+
mPaddingLength
=
=
mInputFrameDataSize
)
{
LOG3
(
(
"
Http2Session
:
:
WriteSegments
%
p
stream
0x
%
X
frame
with
only
padding
"
this
mInputFrameID
)
)
;
rv
=
ReadyToProcessDataFrame
(
DISCARDING_DATA_FRAME_PADDING
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
LOG3
(
(
"
Http2Session
:
:
WriteSegments
%
p
stream
0x
%
X
ready
to
read
HTTP
data
"
this
mInputFrameID
)
)
;
rv
=
ReadyToProcessDataFrame
(
PROCESSING_DATA_FRAME
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
if
(
mDownstreamState
=
=
PROCESSING_CONTROL_RST_STREAM
)
{
nsresult
streamCleanupCode
;
if
(
mDownstreamRstReason
=
=
REFUSED_STREAM_ERROR
)
{
streamCleanupCode
=
NS_ERROR_NET_RESET
;
mInputFrameDataStream
-
>
Transaction
(
)
-
>
ReuseConnectionOnRestartOK
(
true
)
;
}
else
if
(
mDownstreamRstReason
=
=
HTTP_1_1_REQUIRED
)
{
streamCleanupCode
=
NS_ERROR_NET_RESET
;
mInputFrameDataStream
-
>
Transaction
(
)
-
>
ReuseConnectionOnRestartOK
(
true
)
;
mInputFrameDataStream
-
>
Transaction
(
)
-
>
DisableSpdy
(
)
;
mInputFrameDataStream
-
>
Transaction
(
)
-
>
MakeNonSticky
(
)
;
}
else
{
streamCleanupCode
=
mInputFrameDataStream
-
>
RecvdData
(
)
?
NS_ERROR_NET_PARTIAL_TRANSFER
:
NS_ERROR_NET_INTERRUPT
;
}
if
(
mDownstreamRstReason
=
=
COMPRESSION_ERROR
)
{
mShouldGoAway
=
true
;
}
Http2StreamBase
*
stream
=
mInputFrameDataStream
;
ResetDownstreamState
(
)
;
LOG3
(
(
"
Http2Session
:
:
WriteSegments
cleanup
stream
on
recv
of
rst
"
"
session
=
%
p
stream
=
%
p
0x
%
X
\
n
"
this
stream
stream
?
stream
-
>
StreamID
(
)
:
0
)
)
;
CleanupStream
(
stream
streamCleanupCode
CANCEL_ERROR
)
;
return
NS_OK
;
}
if
(
mDownstreamState
=
=
PROCESSING_DATA_FRAME
|
|
mDownstreamState
=
=
PROCESSING_COMPLETE_HEADERS
)
{
MOZ_ASSERT
(
!
mNeedsCleanup
"
cleanup
stream
set
unexpectedly
"
)
;
mNeedsCleanup
=
nullptr
;
if
(
!
mInputFrameDataStream
)
{
return
NS_ERROR_UNEXPECTED
;
}
uint32_t
streamID
=
mInputFrameDataStream
-
>
StreamID
(
)
;
mSegmentWriter
=
writer
;
rv
=
mInputFrameDataStream
-
>
WriteSegments
(
this
count
countWritten
)
;
mSegmentWriter
=
nullptr
;
mLastDataReadEpoch
=
mLastReadEpoch
;
if
(
SoftStreamError
(
rv
)
)
{
mDownstreamState
=
PROCESSING_DATA_FRAME
;
if
(
mInputFrameDataRead
=
=
mInputFrameDataSize
)
ResetDownstreamState
(
)
;
LOG3
(
(
"
Http2Session
:
:
WriteSegments
session
=
%
p
id
0x
%
X
"
"
needscleanup
=
%
p
.
cleanup
stream
based
on
"
"
stream
-
>
writeSegments
returning
code
%
"
PRIx32
"
\
n
"
this
streamID
mNeedsCleanup
static_cast
<
uint32_t
>
(
rv
)
)
)
;
MOZ_ASSERT
(
!
mNeedsCleanup
|
|
mNeedsCleanup
-
>
StreamID
(
)
=
=
streamID
)
;
CleanupStream
(
streamID
(
rv
=
=
NS_BINDING_RETARGETED
)
?
NS_BINDING_RETARGETED
:
NS_OK
CANCEL_ERROR
)
;
mNeedsCleanup
=
nullptr
;
*
again
=
false
;
rv
=
ResumeRecv
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
ResumeRecv
returned
code
%
x
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
return
NS_OK
;
}
if
(
mNeedsCleanup
)
{
LOG3
(
(
"
Http2Session
:
:
WriteSegments
session
=
%
p
stream
=
%
p
0x
%
X
"
"
cleanup
stream
based
on
mNeedsCleanup
.
\
n
"
this
mNeedsCleanup
mNeedsCleanup
?
mNeedsCleanup
-
>
StreamID
(
)
:
0
)
)
;
CleanupStream
(
mNeedsCleanup
NS_OK
CANCEL_ERROR
)
;
mNeedsCleanup
=
nullptr
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
%
p
data
frame
read
failure
%
"
PRIx32
"
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
rv
=
NS_OK
;
}
return
rv
;
}
if
(
mDownstreamState
=
=
DISCARDING_DATA_FRAME
|
|
mDownstreamState
=
=
DISCARDING_DATA_FRAME_PADDING
)
{
char
trash
[
4096
]
;
uint32_t
discardCount
=
std
:
:
min
(
mInputFrameDataSize
-
mInputFrameDataRead
4096U
)
;
LOG3
(
(
"
Http2Session
:
:
WriteSegments
%
p
trying
to
discard
%
d
bytes
of
%
s
"
this
discardCount
mDownstreamState
=
=
DISCARDING_DATA_FRAME
?
"
data
"
:
"
padding
"
)
)
;
if
(
!
discardCount
&
&
mDownstreamState
=
=
DISCARDING_DATA_FRAME
)
{
ResetDownstreamState
(
)
;
Unused
<
<
ResumeRecv
(
)
;
return
NS_BASE_STREAM_WOULD_BLOCK
;
}
rv
=
NetworkRead
(
writer
trash
discardCount
countWritten
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
%
p
discard
frame
read
failure
%
"
PRIx32
"
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
rv
=
NS_OK
;
return
rv
;
}
LogIO
(
this
nullptr
"
Discarding
Frame
"
trash
*
countWritten
)
;
mInputFrameDataRead
+
=
*
countWritten
;
if
(
mInputFrameDataRead
=
=
mInputFrameDataSize
)
{
Http2StreamBase
*
streamToCleanup
=
nullptr
;
if
(
mInputFrameFinal
)
{
streamToCleanup
=
mInputFrameDataStream
;
}
bool
discardedPadding
=
(
mDownstreamState
=
=
DISCARDING_DATA_FRAME_PADDING
)
;
ResetDownstreamState
(
)
;
if
(
streamToCleanup
)
{
Http2PushedStream
*
pushed
=
streamToCleanup
-
>
GetHttp2PushedStream
(
)
;
if
(
discardedPadding
&
&
pushed
)
{
pushed
-
>
SetPushComplete
(
)
;
Http2StreamBase
*
pushSink
=
pushed
-
>
GetConsumerStream
(
)
;
if
(
pushSink
)
{
bool
enqueueSink
=
true
;
for
(
const
auto
&
s
:
mPushesReadyForRead
)
{
if
(
s
=
=
pushSink
)
{
enqueueSink
=
false
;
break
;
}
}
if
(
enqueueSink
)
{
AddStreamToQueue
(
pushSink
mPushesReadyForRead
)
;
streamToCleanup
=
nullptr
;
}
}
}
CleanupStream
(
streamToCleanup
NS_OK
CANCEL_ERROR
)
;
}
}
return
rv
;
}
if
(
mDownstreamState
!
=
BUFFERING_CONTROL_FRAME
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
mInputFrameBufferUsed
=
=
kFrameHeaderBytes
"
Frame
Buffer
Header
Not
Present
"
)
;
MOZ_ASSERT
(
mInputFrameDataSize
+
kFrameHeaderBytes
<
=
mInputFrameBufferSize
"
allocation
for
control
frame
insufficient
"
)
;
rv
=
NetworkRead
(
writer
&
mInputFrameBuffer
[
kFrameHeaderBytes
+
mInputFrameDataRead
]
mInputFrameDataSize
-
mInputFrameDataRead
countWritten
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
%
p
buffering
control
frame
read
failure
%
"
PRIx32
"
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
rv
=
NS_OK
;
return
rv
;
}
LogIO
(
this
nullptr
"
Reading
Control
Frame
"
&
mInputFrameBuffer
[
kFrameHeaderBytes
+
mInputFrameDataRead
]
*
countWritten
)
;
mInputFrameDataRead
+
=
*
countWritten
;
if
(
mInputFrameDataRead
!
=
mInputFrameDataSize
)
return
NS_OK
;
MOZ_ASSERT
(
mInputFrameType
!
=
FRAME_TYPE_DATA
)
;
if
(
mInputFrameType
<
FRAME_TYPE_LAST
)
{
rv
=
sControlFunctions
[
mInputFrameType
]
(
this
)
;
}
else
{
LOG3
(
(
"
Http2Session
%
p
unknown
frame
type
%
x
ignored
\
n
"
this
mInputFrameType
)
)
;
ResetDownstreamState
(
)
;
rv
=
NS_OK
;
}
MOZ_ASSERT
(
NS_FAILED
(
rv
)
|
|
mDownstreamState
!
=
BUFFERING_CONTROL_FRAME
"
Control
Handler
returned
OK
but
did
not
change
state
"
)
;
if
(
mShouldGoAway
&
&
!
mStreamTransactionHash
.
Count
(
)
)
Close
(
NS_OK
)
;
return
rv
;
}
nsresult
Http2Session
:
:
WriteSegments
(
nsAHttpSegmentWriter
*
writer
uint32_t
count
uint32_t
*
countWritten
)
{
bool
again
=
false
;
return
WriteSegmentsAgain
(
writer
count
countWritten
&
again
)
;
}
nsresult
Http2Session
:
:
Finish0RTT
(
bool
aRestart
bool
aAlpnChanged
)
{
MOZ_ASSERT
(
mAttemptingEarlyData
)
;
LOG3
(
(
"
Http2Session
:
:
Finish0RTT
%
p
aRestart
=
%
d
aAlpnChanged
=
%
d
"
this
aRestart
aAlpnChanged
)
)
;
for
(
size_t
i
=
0
;
i
<
m0RTTStreams
.
Length
(
)
;
+
+
i
)
{
if
(
m0RTTStreams
[
i
]
)
{
m0RTTStreams
[
i
]
-
>
Finish0RTT
(
aRestart
aAlpnChanged
)
;
}
}
if
(
aRestart
)
{
if
(
aAlpnChanged
)
{
mGoAwayID
=
0
;
mCleanShutdown
=
true
;
Close
(
NS_ERROR_NET_RESET
)
;
}
else
{
mOutputQueueSent
=
0
;
for
(
size_t
i
=
0
;
i
<
mCannotDo0RTTStreams
.
Length
(
)
;
+
+
i
)
{
if
(
mCannotDo0RTTStreams
[
i
]
&
&
VerifyStream
(
mCannotDo0RTTStreams
[
i
]
)
)
{
TransactionHasDataToWrite
(
mCannotDo0RTTStreams
[
i
]
)
;
}
}
}
}
else
{
for
(
size_t
i
=
0
;
i
<
mCannotDo0RTTStreams
.
Length
(
)
;
+
+
i
)
{
if
(
mCannotDo0RTTStreams
[
i
]
&
&
VerifyStream
(
mCannotDo0RTTStreams
[
i
]
)
)
{
TransactionHasDataToWrite
(
mCannotDo0RTTStreams
[
i
]
)
;
}
}
Unused
<
<
ResumeRecv
(
)
;
}
mAttemptingEarlyData
=
false
;
m0RTTStreams
.
Clear
(
)
;
mCannotDo0RTTStreams
.
Clear
(
)
;
RealignOutputQueue
(
)
;
return
NS_OK
;
}
nsresult
Http2Session
:
:
ProcessConnectedPush
(
Http2StreamBase
*
pushConnectedStream
nsAHttpSegmentWriter
*
writer
uint32_t
count
uint32_t
*
countWritten
)
{
LOG3
(
(
"
Http2Session
:
:
ProcessConnectedPush
%
p
0x
%
X
\
n
"
this
pushConnectedStream
-
>
StreamID
(
)
)
)
;
mSegmentWriter
=
writer
;
nsresult
rv
=
pushConnectedStream
-
>
WriteSegments
(
this
count
countWritten
)
;
mSegmentWriter
=
nullptr
;
Http2Stream
*
h2Stream
=
pushConnectedStream
-
>
GetHttp2Stream
(
)
;
MOZ_ASSERT
(
h2Stream
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
*
countWritten
&
&
h2Stream
&
&
h2Stream
-
>
PushSource
(
)
&
&
h2Stream
-
>
PushSource
(
)
-
>
GetPushComplete
(
)
)
{
rv
=
NS_BASE_STREAM_CLOSED
;
}
if
(
rv
=
=
NS_BASE_STREAM_CLOSED
)
{
CleanupStream
(
pushConnectedStream
NS_OK
CANCEL_ERROR
)
;
rv
=
NS_OK
;
}
if
(
NS_SUCCEEDED
(
rv
)
|
|
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
rv
=
NS_BASE_STREAM_WOULD_BLOCK
;
Unused
<
<
ResumeRecv
(
)
;
}
return
rv
;
}
nsresult
Http2Session
:
:
ProcessSlowConsumer
(
Http2StreamBase
*
slowConsumer
nsAHttpSegmentWriter
*
writer
uint32_t
count
uint32_t
*
countWritten
)
{
LOG3
(
(
"
Http2Session
:
:
ProcessSlowConsumer
%
p
0x
%
X
\
n
"
this
slowConsumer
-
>
StreamID
(
)
)
)
;
mSegmentWriter
=
writer
;
nsresult
rv
=
slowConsumer
-
>
WriteSegments
(
this
count
countWritten
)
;
mSegmentWriter
=
nullptr
;
LOG3
(
(
"
Http2Session
:
:
ProcessSlowConsumer
Writesegments
%
p
0x
%
X
rv
%
"
PRIX32
"
%
d
\
n
"
this
slowConsumer
-
>
StreamID
(
)
static_cast
<
uint32_t
>
(
rv
)
*
countWritten
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
*
countWritten
&
&
slowConsumer
-
>
RecvdFin
(
)
)
{
rv
=
NS_BASE_STREAM_CLOSED
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
*
countWritten
>
0
)
)
{
UpdateLocalRwin
(
slowConsumer
0
)
;
ConnectSlowConsumer
(
slowConsumer
)
;
}
if
(
rv
=
=
NS_BASE_STREAM_CLOSED
)
{
CleanupStream
(
slowConsumer
NS_OK
CANCEL_ERROR
)
;
rv
=
NS_OK
;
}
return
rv
;
}
void
Http2Session
:
:
UpdateLocalStreamWindow
(
Http2StreamBase
*
stream
uint32_t
bytes
)
{
if
(
!
stream
)
{
return
;
}
if
(
!
stream
|
|
stream
-
>
RecvdFin
(
)
|
|
stream
-
>
RecvdReset
(
)
|
|
mInputFrameFinal
)
{
return
;
}
stream
-
>
DecrementClientReceiveWindow
(
bytes
)
;
uint64_t
unacked
=
stream
-
>
LocalUnAcked
(
)
;
int64_t
localWindow
=
stream
-
>
ClientReceiveWindow
(
)
;
LOG3
(
(
"
Http2Session
:
:
UpdateLocalStreamWindow
this
=
%
p
id
=
0x
%
X
newbytes
=
%
u
"
"
unacked
=
%
"
PRIu64
"
localWindow
=
%
"
PRId64
"
\
n
"
this
stream
-
>
StreamID
(
)
bytes
unacked
localWindow
)
)
;
if
(
!
unacked
)
return
;
if
(
(
unacked
<
kMinimumToAck
)
&
&
(
localWindow
>
kEmergencyWindowThreshold
)
)
{
return
;
}
if
(
!
stream
-
>
HasSink
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
UpdateLocalStreamWindow
%
p
0x
%
X
Pushed
Stream
Has
No
"
"
Sink
\
n
"
this
stream
-
>
StreamID
(
)
)
)
;
return
;
}
uint32_t
toack
=
(
unacked
<
=
0x7fffffffU
)
?
unacked
:
0x7fffffffU
;
LOG3
(
(
"
Http2Session
:
:
UpdateLocalStreamWindow
Ack
this
=
%
p
id
=
0x
%
X
acksize
=
%
d
\
n
"
this
stream
-
>
StreamID
(
)
toack
)
)
;
stream
-
>
IncrementClientReceiveWindow
(
toack
)
;
if
(
toack
=
=
0
)
{
return
;
}
char
*
packet
=
mOutputQueueBuffer
.
get
(
)
+
mOutputQueueUsed
;
mOutputQueueUsed
+
=
kFrameHeaderBytes
+
4
;
MOZ_ASSERT
(
mOutputQueueUsed
<
=
mOutputQueueSize
)
;
CreateFrameHeader
(
packet
4
FRAME_TYPE_WINDOW_UPDATE
0
stream
-
>
StreamID
(
)
)
;
NetworkEndian
:
:
writeUint32
(
packet
+
kFrameHeaderBytes
toack
)
;
LogIO
(
this
stream
"
Stream
Window
Update
"
packet
kFrameHeaderBytes
+
4
)
;
}
void
Http2Session
:
:
UpdateLocalSessionWindow
(
uint32_t
bytes
)
{
if
(
!
bytes
)
return
;
mLocalSessionWindow
-
=
bytes
;
LOG3
(
(
"
Http2Session
:
:
UpdateLocalSessionWindow
this
=
%
p
newbytes
=
%
u
"
"
localWindow
=
%
"
PRId64
"
\
n
"
this
bytes
mLocalSessionWindow
)
)
;
if
(
(
mLocalSessionWindow
>
(
mInitialRwin
-
kMinimumToAck
)
)
&
&
(
mLocalSessionWindow
>
kEmergencyWindowThreshold
)
)
{
return
;
}
uint64_t
toack64
=
mInitialRwin
-
mLocalSessionWindow
;
uint32_t
toack
=
(
toack64
<
=
0x7fffffffU
)
?
toack64
:
0x7fffffffU
;
LOG3
(
(
"
Http2Session
:
:
UpdateLocalSessionWindow
Ack
this
=
%
p
acksize
=
%
u
\
n
"
this
toack
)
)
;
mLocalSessionWindow
+
=
toack
;
if
(
toack
=
=
0
)
{
return
;
}
char
*
packet
=
mOutputQueueBuffer
.
get
(
)
+
mOutputQueueUsed
;
mOutputQueueUsed
+
=
kFrameHeaderBytes
+
4
;
MOZ_ASSERT
(
mOutputQueueUsed
<
=
mOutputQueueSize
)
;
CreateFrameHeader
(
packet
4
FRAME_TYPE_WINDOW_UPDATE
0
0
)
;
NetworkEndian
:
:
writeUint32
(
packet
+
kFrameHeaderBytes
toack
)
;
LogIO
(
this
nullptr
"
Session
Window
Update
"
packet
kFrameHeaderBytes
+
4
)
;
}
void
Http2Session
:
:
UpdateLocalRwin
(
Http2StreamBase
*
stream
uint32_t
bytes
)
{
EnsureOutputBuffer
(
2
*
(
kFrameHeaderBytes
+
4
)
)
;
UpdateLocalStreamWindow
(
stream
bytes
)
;
UpdateLocalSessionWindow
(
bytes
)
;
FlushOutputQueue
(
)
;
}
void
Http2Session
:
:
Close
(
nsresult
aReason
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
mClosed
)
return
;
LOG3
(
(
"
Http2Session
:
:
Close
%
p
%
"
PRIX32
this
static_cast
<
uint32_t
>
(
aReason
)
)
)
;
mClosed
=
true
;
Shutdown
(
aReason
)
;
mStreamIDHash
.
Clear
(
)
;
mStreamTransactionHash
.
Clear
(
)
;
if
(
mWaitingWebsockets
.
Length
(
)
)
{
MOZ_ASSERT
(
!
mProcessedWaitingWebsockets
)
;
MOZ_ASSERT
(
mWaitingWebsockets
.
Length
(
)
=
=
mWaitingWebsocketCallbacks
.
Length
(
)
)
;
mProcessedWaitingWebsockets
=
true
;
for
(
size_t
i
=
0
;
i
<
mWaitingWebsockets
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
nsAHttpTransaction
>
httpTransaction
=
mWaitingWebsockets
[
i
]
;
LOG3
(
(
"
Http2Session
:
:
Close
%
p
Re
-
queuing
websocket
.
"
this
)
)
;
httpTransaction
-
>
SetConnection
(
nullptr
)
;
nsHttpTransaction
*
trans
=
httpTransaction
-
>
QueryHttpTransaction
(
)
;
if
(
trans
)
{
nsresult
rv
=
gHttpHandler
-
>
InitiateTransaction
(
trans
trans
-
>
Priority
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
Close
%
p
failed
to
reinitiate
websocket
"
"
transaction
(
%
08x
)
.
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
else
{
LOG3
(
(
"
Http2Session
:
:
Close
%
p
missing
transaction
?
!
"
this
)
)
;
}
}
mWaitingWebsockets
.
Clear
(
)
;
mWaitingWebsocketCallbacks
.
Clear
(
)
;
}
uint32_t
goAwayReason
;
if
(
mGoAwayReason
!
=
NO_HTTP_ERROR
)
{
goAwayReason
=
mGoAwayReason
;
}
else
if
(
NS_SUCCEEDED
(
aReason
)
)
{
goAwayReason
=
NO_HTTP_ERROR
;
}
else
if
(
aReason
=
=
NS_ERROR_NET_HTTP2_SENT_GOAWAY
)
{
goAwayReason
=
PROTOCOL_ERROR
;
}
else
if
(
mCleanShutdown
)
{
goAwayReason
=
NO_HTTP_ERROR
;
}
else
{
goAwayReason
=
INTERNAL_ERROR
;
}
if
(
!
mAttemptingEarlyData
)
{
GenerateGoAway
(
goAwayReason
)
;
}
mConnection
=
nullptr
;
mSegmentReader
=
nullptr
;
mSegmentWriter
=
nullptr
;
}
nsHttpConnectionInfo
*
Http2Session
:
:
ConnectionInfo
(
)
{
RefPtr
<
nsHttpConnectionInfo
>
ci
;
GetConnectionInfo
(
getter_AddRefs
(
ci
)
)
;
return
ci
.
get
(
)
;
}
void
Http2Session
:
:
CloseTransaction
(
nsAHttpTransaction
*
aTransaction
nsresult
aResult
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
CloseTransaction
%
p
%
p
%
"
PRIx32
this
aTransaction
static_cast
<
uint32_t
>
(
aResult
)
)
)
;
RefPtr
<
Http2StreamBase
>
stream
=
mStreamTransactionHash
.
Get
(
aTransaction
)
;
if
(
!
stream
)
{
LOG3
(
(
"
Http2Session
:
:
CloseTransaction
%
p
%
p
%
"
PRIx32
"
-
not
found
.
"
this
aTransaction
static_cast
<
uint32_t
>
(
aResult
)
)
)
;
return
;
}
LOG3
(
(
"
Http2Session
:
:
CloseTransaction
probably
a
cancel
.
"
"
this
=
%
p
trans
=
%
p
result
=
%
"
PRIx32
"
streamID
=
0x
%
X
stream
=
%
p
"
this
aTransaction
static_cast
<
uint32_t
>
(
aResult
)
stream
-
>
StreamID
(
)
stream
.
get
(
)
)
)
;
CleanupStream
(
stream
aResult
CANCEL_ERROR
)
;
nsresult
rv
=
ResumeRecv
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
CloseTransaction
%
p
%
p
%
x
ResumeRecv
returned
%
x
"
this
aTransaction
static_cast
<
uint32_t
>
(
aResult
)
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
nsresult
Http2Session
:
:
OnReadSegment
(
const
char
*
buf
uint32_t
count
uint32_t
*
countRead
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
nsresult
rv
;
if
(
mOutputQueueUsed
)
FlushOutputQueue
(
)
;
if
(
!
mOutputQueueUsed
&
&
mSegmentReader
)
{
rv
=
mSegmentReader
-
>
OnReadSegment
(
buf
count
countRead
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
*
countRead
=
0
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
*
countRead
<
count
)
{
uint32_t
required
=
count
-
*
countRead
;
EnsureBuffer
(
mOutputQueueBuffer
required
0
mOutputQueueSize
)
;
memcpy
(
mOutputQueueBuffer
.
get
(
)
buf
+
*
countRead
required
)
;
mOutputQueueUsed
=
required
;
}
*
countRead
=
count
;
return
NS_OK
;
}
if
(
(
mOutputQueueUsed
+
count
)
>
(
mOutputQueueSize
-
kQueueReserved
)
)
{
return
NS_BASE_STREAM_WOULD_BLOCK
;
}
memcpy
(
mOutputQueueBuffer
.
get
(
)
+
mOutputQueueUsed
buf
count
)
;
mOutputQueueUsed
+
=
count
;
*
countRead
=
count
;
FlushOutputQueue
(
)
;
return
NS_OK
;
}
nsresult
Http2Session
:
:
CommitToSegmentSize
(
uint32_t
count
bool
forceCommitment
)
{
if
(
mOutputQueueUsed
&
&
!
mAttemptingEarlyData
)
FlushOutputQueue
(
)
;
if
(
(
mOutputQueueUsed
+
count
)
<
=
(
mOutputQueueSize
-
kQueueReserved
)
)
{
return
NS_OK
;
}
if
(
mOutputQueueUsed
&
&
!
forceCommitment
)
return
NS_BASE_STREAM_WOULD_BLOCK
;
if
(
mOutputQueueUsed
)
{
RealignOutputQueue
(
)
;
if
(
(
mOutputQueueUsed
+
count
)
<
=
(
mOutputQueueSize
-
kQueueReserved
)
)
{
return
NS_OK
;
}
}
EnsureOutputBuffer
(
count
+
kQueueReserved
)
;
MOZ_ASSERT
(
(
mOutputQueueUsed
+
count
)
<
=
(
mOutputQueueSize
-
kQueueReserved
)
"
buffer
not
as
large
as
expected
"
)
;
return
NS_OK
;
}
nsresult
Http2Session
:
:
OnWriteSegment
(
char
*
buf
uint32_t
count
uint32_t
*
countWritten
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
nsresult
rv
;
if
(
!
mSegmentWriter
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mDownstreamState
=
=
NOT_USING_NETWORK
|
|
mDownstreamState
=
=
BUFFERING_FRAME_HEADER
|
|
mDownstreamState
=
=
DISCARDING_DATA_FRAME_PADDING
)
{
return
NS_BASE_STREAM_WOULD_BLOCK
;
}
if
(
mDownstreamState
=
=
PROCESSING_DATA_FRAME
)
{
if
(
mInputFrameFinal
&
&
mInputFrameDataRead
=
=
mInputFrameDataSize
)
{
*
countWritten
=
0
;
SetNeedsCleanup
(
)
;
return
NS_BASE_STREAM_CLOSED
;
}
count
=
std
:
:
min
(
count
mInputFrameDataSize
-
mInputFrameDataRead
)
;
rv
=
NetworkRead
(
mSegmentWriter
buf
count
countWritten
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
LogIO
(
this
mInputFrameDataStream
"
Reading
Data
Frame
"
buf
*
countWritten
)
;
mInputFrameDataRead
+
=
*
countWritten
;
if
(
mPaddingLength
&
&
(
mInputFrameDataSize
-
mInputFrameDataRead
<
=
mPaddingLength
)
)
{
if
(
mInputFrameDataSize
!
=
mInputFrameDataRead
)
{
ChangeDownstreamState
(
DISCARDING_DATA_FRAME_PADDING
)
;
}
uint32_t
paddingRead
=
mPaddingLength
-
(
mInputFrameDataSize
-
mInputFrameDataRead
)
;
LOG3
(
(
"
Http2Session
:
:
OnWriteSegment
%
p
stream
0x
%
X
len
=
%
d
read
=
%
d
"
"
crossed
from
HTTP
data
into
padding
(
%
d
of
%
d
)
countWritten
=
%
d
"
this
mInputFrameID
mInputFrameDataSize
mInputFrameDataRead
paddingRead
mPaddingLength
*
countWritten
)
)
;
*
countWritten
-
=
paddingRead
;
LOG3
(
(
"
Http2Session
:
:
OnWriteSegment
%
p
stream
0x
%
X
new
countWritten
=
%
d
"
this
mInputFrameID
*
countWritten
)
)
;
}
mInputFrameDataStream
-
>
UpdateTransportReadEvents
(
*
countWritten
)
;
if
(
(
mInputFrameDataRead
=
=
mInputFrameDataSize
)
&
&
!
mInputFrameFinal
)
{
ResetDownstreamState
(
)
;
}
return
rv
;
}
if
(
mDownstreamState
=
=
PROCESSING_COMPLETE_HEADERS
)
{
if
(
mFlatHTTPResponseHeaders
.
Length
(
)
=
=
mFlatHTTPResponseHeadersOut
&
&
mInputFrameFinal
)
{
*
countWritten
=
0
;
SetNeedsCleanup
(
)
;
return
NS_BASE_STREAM_CLOSED
;
}
count
=
std
:
:
min
<
uint32_t
>
(
count
mFlatHTTPResponseHeaders
.
Length
(
)
-
mFlatHTTPResponseHeadersOut
)
;
memcpy
(
buf
mFlatHTTPResponseHeaders
.
get
(
)
+
mFlatHTTPResponseHeadersOut
count
)
;
mFlatHTTPResponseHeadersOut
+
=
count
;
*
countWritten
=
count
;
if
(
mFlatHTTPResponseHeaders
.
Length
(
)
=
=
mFlatHTTPResponseHeadersOut
)
{
if
(
!
mInputFrameFinal
)
{
ResetDownstreamState
(
)
;
}
}
return
NS_OK
;
}
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_UNEXPECTED
;
}
void
Http2Session
:
:
SetNeedsCleanup
(
)
{
LOG3
(
(
"
Http2Session
:
:
SetNeedsCleanup
%
p
-
recorded
downstream
fin
of
"
"
stream
%
p
0x
%
X
"
this
mInputFrameDataStream
mInputFrameDataStream
-
>
StreamID
(
)
)
)
;
MOZ_ASSERT
(
!
mNeedsCleanup
"
mNeedsCleanup
unexpectedly
set
"
)
;
mInputFrameDataStream
-
>
SetResponseIsComplete
(
)
;
mNeedsCleanup
=
mInputFrameDataStream
;
ResetDownstreamState
(
)
;
}
void
Http2Session
:
:
ConnectPushedStream
(
Http2StreamBase
*
stream
)
{
AddStreamToQueue
(
stream
mPushesReadyForRead
)
;
Unused
<
<
ForceRecv
(
)
;
}
void
Http2Session
:
:
ConnectSlowConsumer
(
Http2StreamBase
*
stream
)
{
LOG3
(
(
"
Http2Session
:
:
ConnectSlowConsumer
%
p
0x
%
X
\
n
"
this
stream
-
>
StreamID
(
)
)
)
;
AddStreamToQueue
(
stream
mSlowConsumersReadyForRead
)
;
Unused
<
<
ForceRecv
(
)
;
}
nsresult
Http2Session
:
:
BufferOutput
(
const
char
*
buf
uint32_t
count
uint32_t
*
countRead
)
{
RefPtr
<
nsAHttpSegmentReader
>
old
;
mSegmentReader
.
swap
(
old
)
;
nsresult
rv
=
OnReadSegment
(
buf
count
countRead
)
;
mSegmentReader
.
swap
(
old
)
;
return
rv
;
}
bool
Http2Session
:
:
ALPNCallback
(
nsISupports
*
securityInfo
)
{
nsCOMPtr
<
nsISSLSocketControl
>
ssl
=
do_QueryInterface
(
securityInfo
)
;
LOG3
(
(
"
Http2Session
:
:
ALPNCallback
sslsocketcontrol
=
%
p
\
n
"
ssl
.
get
(
)
)
)
;
if
(
ssl
)
{
int16_t
version
=
ssl
-
>
GetSSLVersionOffered
(
)
;
LOG3
(
(
"
Http2Session
:
:
ALPNCallback
version
=
%
x
\
n
"
version
)
)
;
if
(
version
=
=
nsISSLSocketControl
:
:
TLS_VERSION_1_2
&
&
!
gHttpHandler
-
>
IsH2MandatorySuiteEnabled
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
ALPNCallback
Mandatory
Cipher
Suite
Unavailable
\
n
"
)
)
;
return
false
;
}
if
(
version
>
=
nsISSLSocketControl
:
:
TLS_VERSION_1_2
)
{
return
true
;
}
}
return
false
;
}
nsresult
Http2Session
:
:
ConfirmTLSProfile
(
)
{
if
(
mTLSProfileConfirmed
)
{
return
NS_OK
;
}
LOG3
(
(
"
Http2Session
:
:
ConfirmTLSProfile
%
p
mConnection
=
%
p
\
n
"
this
mConnection
.
get
(
)
)
)
;
if
(
mAttemptingEarlyData
)
{
LOG3
(
(
"
Http2Session
:
:
ConfirmTLSProfile
%
p
temporarily
passing
due
to
early
"
"
data
\
n
"
this
)
)
;
return
NS_OK
;
}
if
(
!
StaticPrefs
:
:
network_http_http2_enforce_tls_profile
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
ConfirmTLSProfile
%
p
passed
due
to
configuration
"
"
bypass
\
n
"
this
)
)
;
mTLSProfileConfirmed
=
true
;
return
NS_OK
;
}
if
(
!
mConnection
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsISSLSocketControl
>
ssl
;
mConnection
-
>
GetTLSSocketControl
(
getter_AddRefs
(
ssl
)
)
;
LOG3
(
(
"
Http2Session
:
:
ConfirmTLSProfile
%
p
sslsocketcontrol
=
%
p
\
n
"
this
ssl
.
get
(
)
)
)
;
if
(
!
ssl
)
return
NS_ERROR_FAILURE
;
int16_t
version
=
ssl
-
>
GetSSLVersionUsed
(
)
;
LOG3
(
(
"
Http2Session
:
:
ConfirmTLSProfile
%
p
version
=
%
x
\
n
"
this
version
)
)
;
if
(
version
<
nsISSLSocketControl
:
:
TLS_VERSION_1_2
)
{
LOG3
(
(
"
Http2Session
:
:
ConfirmTLSProfile
%
p
FAILED
due
to
lack
of
TLS1
.
2
\
n
"
this
)
)
;
return
SessionError
(
INADEQUATE_SECURITY
)
;
}
uint16_t
kea
=
ssl
-
>
GetKEAUsed
(
)
;
if
(
kea
!
=
ssl_kea_dh
&
&
kea
!
=
ssl_kea_ecdh
)
{
LOG3
(
(
"
Http2Session
:
:
ConfirmTLSProfile
%
p
FAILED
due
to
invalid
KEA
%
d
\
n
"
this
kea
)
)
;
return
SessionError
(
INADEQUATE_SECURITY
)
;
}
uint32_t
keybits
=
ssl
-
>
GetKEAKeyBits
(
)
;
if
(
kea
=
=
ssl_kea_dh
&
&
keybits
<
2048
)
{
LOG3
(
(
"
Http2Session
:
:
ConfirmTLSProfile
%
p
FAILED
due
to
DH
%
d
<
2048
\
n
"
this
keybits
)
)
;
return
SessionError
(
INADEQUATE_SECURITY
)
;
}
if
(
kea
=
=
ssl_kea_ecdh
&
&
keybits
<
224
)
{
LOG3
(
(
"
Http2Session
:
:
ConfirmTLSProfile
%
p
FAILED
due
to
ECDH
%
d
<
224
\
n
"
this
keybits
)
)
;
return
SessionError
(
INADEQUATE_SECURITY
)
;
}
int16_t
macAlgorithm
=
ssl
-
>
GetMACAlgorithmUsed
(
)
;
LOG3
(
(
"
Http2Session
:
:
ConfirmTLSProfile
%
p
MAC
Algortihm
(
aead
=
=
6
)
%
d
\
n
"
this
macAlgorithm
)
)
;
if
(
macAlgorithm
!
=
nsISSLSocketControl
:
:
SSL_MAC_AEAD
)
{
LOG3
(
(
"
Http2Session
:
:
ConfirmTLSProfile
%
p
FAILED
due
to
lack
of
AEAD
\
n
"
this
)
)
;
return
SessionError
(
INADEQUATE_SECURITY
)
;
}
mTLSProfileConfirmed
=
true
;
return
NS_OK
;
}
void
Http2Session
:
:
TransactionHasDataToWrite
(
nsAHttpTransaction
*
caller
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
TransactionHasDataToWrite
%
p
trans
=
%
p
"
this
caller
)
)
;
RefPtr
<
Http2StreamBase
>
stream
=
mStreamTransactionHash
.
Get
(
caller
)
;
if
(
!
stream
|
|
!
VerifyStream
(
stream
)
)
{
LOG3
(
(
"
Http2Session
:
:
TransactionHasDataToWrite
%
p
caller
%
p
not
found
"
this
caller
)
)
;
return
;
}
LOG3
(
(
"
Http2Session
:
:
TransactionHasDataToWrite
%
p
ID
is
0x
%
X
\
n
"
this
stream
-
>
StreamID
(
)
)
)
;
if
(
!
mClosed
)
{
AddStreamToQueue
(
stream
mReadyForWrite
)
;
SetWriteCallbacks
(
)
;
}
else
{
LOG3
(
(
"
Http2Session
:
:
TransactionHasDataToWrite
%
p
closed
so
not
setting
"
"
Ready4Write
\
n
"
this
)
)
;
}
Unused
<
<
ForceSend
(
)
;
}
void
Http2Session
:
:
TransactionHasDataToRecv
(
nsAHttpTransaction
*
caller
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
TransactionHasDataToRecv
%
p
trans
=
%
p
"
this
caller
)
)
;
RefPtr
<
Http2StreamBase
>
stream
=
mStreamTransactionHash
.
Get
(
caller
)
;
if
(
!
stream
|
|
!
VerifyStream
(
stream
)
)
{
LOG3
(
(
"
Http2Session
:
:
TransactionHasDataToRecv
%
p
caller
%
p
not
found
"
this
caller
)
)
;
return
;
}
LOG3
(
(
"
Http2Session
:
:
TransactionHasDataToRecv
%
p
ID
is
0x
%
X
\
n
"
this
stream
-
>
StreamID
(
)
)
)
;
TransactionHasDataToRecv
(
stream
)
;
}
void
Http2Session
:
:
TransactionHasDataToWrite
(
Http2StreamBase
*
stream
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
TransactionHasDataToWrite
%
p
stream
=
%
p
ID
=
0x
%
x
"
this
stream
stream
-
>
StreamID
(
)
)
)
;
AddStreamToQueue
(
stream
mReadyForWrite
)
;
SetWriteCallbacks
(
)
;
Unused
<
<
ForceSend
(
)
;
}
void
Http2Session
:
:
TransactionHasDataToRecv
(
Http2StreamBase
*
caller
)
{
ConnectSlowConsumer
(
caller
)
;
}
bool
Http2Session
:
:
IsPersistent
(
)
{
return
true
;
}
nsresult
Http2Session
:
:
TakeTransport
(
nsISocketTransport
*
*
nsIAsyncInputStream
*
*
nsIAsyncOutputStream
*
*
)
{
MOZ_ASSERT
(
false
"
TakeTransport
of
Http2Session
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
already_AddRefed
<
HttpConnectionBase
>
Http2Session
:
:
TakeHttpConnection
(
)
{
MOZ_ASSERT
(
false
"
TakeHttpConnection
of
Http2Session
"
)
;
return
nullptr
;
}
already_AddRefed
<
HttpConnectionBase
>
Http2Session
:
:
HttpConnection
(
)
{
if
(
mConnection
)
{
return
mConnection
-
>
HttpConnection
(
)
;
}
return
nullptr
;
}
void
Http2Session
:
:
GetSecurityCallbacks
(
nsIInterfaceRequestor
*
*
aOut
)
{
*
aOut
=
nullptr
;
}
void
Http2Session
:
:
SetConnection
(
nsAHttpConnection
*
aConn
)
{
mConnection
=
aConn
;
}
void
Http2Session
:
:
SetProxyConnectFailed
(
)
{
MOZ_ASSERT
(
false
"
Http2Session
:
:
SetProxyConnectFailed
(
)
"
)
;
}
bool
Http2Session
:
:
IsDone
(
)
{
return
!
mStreamTransactionHash
.
Count
(
)
;
}
nsresult
Http2Session
:
:
Status
(
)
{
MOZ_ASSERT
(
false
"
Http2Session
:
:
Status
(
)
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
uint32_t
Http2Session
:
:
Caps
(
)
{
MOZ_ASSERT
(
false
"
Http2Session
:
:
Caps
(
)
"
)
;
return
0
;
}
nsHttpRequestHead
*
Http2Session
:
:
RequestHead
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
false
"
Http2Session
:
:
RequestHead
(
)
"
"
should
not
be
called
after
http
/
2
is
setup
"
)
;
return
nullptr
;
}
uint32_t
Http2Session
:
:
Http1xTransactionCount
(
)
{
return
0
;
}
nsresult
Http2Session
:
:
TakeSubTransactions
(
nsTArray
<
RefPtr
<
nsAHttpTransaction
>
>
&
outTransactions
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
LOG3
(
(
"
Http2Session
:
:
TakeSubTransactions
%
p
\
n
"
this
)
)
;
if
(
mConcurrentHighWater
>
0
)
return
NS_ERROR_ALREADY_OPENED
;
LOG3
(
(
"
taking
%
d
\
n
"
mStreamTransactionHash
.
Count
(
)
)
)
;
for
(
auto
iter
=
mStreamTransactionHash
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
outTransactions
.
AppendElement
(
iter
.
Key
(
)
)
;
iter
.
Remove
(
)
;
}
return
NS_OK
;
}
nsAHttpConnection
*
Http2Session
:
:
Connection
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
return
mConnection
;
}
nsresult
Http2Session
:
:
OnHeadersAvailable
(
nsAHttpTransaction
*
transaction
nsHttpRequestHead
*
requestHead
nsHttpResponseHead
*
responseHead
bool
*
reset
)
{
return
NS_OK
;
}
bool
Http2Session
:
:
IsReused
(
)
{
if
(
!
mConnection
)
{
return
false
;
}
return
mConnection
-
>
IsReused
(
)
;
}
nsresult
Http2Session
:
:
PushBack
(
const
char
*
buf
uint32_t
len
)
{
return
mConnection
-
>
PushBack
(
buf
len
)
;
}
void
Http2Session
:
:
SendPing
(
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
if
(
mPreviousUsed
)
{
return
;
}
mPingSentEpoch
=
PR_IntervalNow
(
)
;
if
(
!
mPingSentEpoch
)
{
mPingSentEpoch
=
1
;
}
if
(
!
mPingThreshold
|
|
(
mPingThreshold
>
gHttpHandler
-
>
NetworkChangedTimeout
(
)
)
)
{
mPreviousPingThreshold
=
mPingThreshold
;
mPreviousUsed
=
true
;
mPingThreshold
=
gHttpHandler
-
>
NetworkChangedTimeout
(
)
;
}
GeneratePing
(
false
)
;
Unused
<
<
ResumeRecv
(
)
;
}
bool
Http2Session
:
:
TestOriginFrame
(
const
nsACString
&
hostname
int32_t
port
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
MOZ_ASSERT
(
mOriginFrameActivated
)
;
nsAutoCString
key
(
hostname
)
;
key
.
Append
(
'
:
'
)
;
key
.
AppendInt
(
port
)
;
bool
rv
=
mOriginFrame
.
Get
(
key
)
;
LOG3
(
(
"
TestOriginFrame
(
)
hash
.
get
%
p
%
s
%
d
\
n
"
this
key
.
get
(
)
rv
)
)
;
if
(
!
rv
&
&
ConnectionInfo
(
)
)
{
nsHttpConnectionInfo
*
ci
=
ConnectionInfo
(
)
;
rv
=
nsCString
(
hostname
)
.
EqualsIgnoreCase
(
ci
-
>
Origin
(
)
)
&
&
(
port
=
=
ci
-
>
OriginPort
(
)
)
;
LOG3
(
(
"
TestOriginFrame
(
)
%
p
sni
test
%
d
\
n
"
this
rv
)
)
;
}
return
rv
;
}
bool
Http2Session
:
:
TestJoinConnection
(
const
nsACString
&
hostname
int32_t
port
)
{
return
RealJoinConnection
(
hostname
port
true
)
;
}
bool
Http2Session
:
:
JoinConnection
(
const
nsACString
&
hostname
int32_t
port
)
{
return
RealJoinConnection
(
hostname
port
false
)
;
}
bool
Http2Session
:
:
RealJoinConnection
(
const
nsACString
&
hostname
int32_t
port
bool
justKidding
)
{
if
(
!
mConnection
|
|
mClosed
|
|
mShouldGoAway
)
{
return
false
;
}
nsHttpConnectionInfo
*
ci
=
ConnectionInfo
(
)
;
if
(
nsCString
(
hostname
)
.
EqualsIgnoreCase
(
ci
-
>
Origin
(
)
)
&
&
(
port
=
=
ci
-
>
OriginPort
(
)
)
)
{
return
true
;
}
if
(
!
mReceivedSettings
)
{
return
false
;
}
if
(
mOriginFrameActivated
)
{
bool
originFrameResult
=
TestOriginFrame
(
hostname
port
)
;
if
(
!
originFrameResult
)
{
return
false
;
}
}
else
{
LOG3
(
(
"
JoinConnection
%
p
no
origin
frame
check
used
.
\
n
"
this
)
)
;
}
nsAutoCString
key
(
hostname
)
;
key
.
Append
(
'
:
'
)
;
key
.
Append
(
justKidding
?
'
k
'
:
'
.
'
)
;
key
.
AppendInt
(
port
)
;
bool
cachedResult
;
if
(
mJoinConnectionCache
.
Get
(
key
&
cachedResult
)
)
{
LOG
(
(
"
joinconnection
[
%
p
%
s
]
%
s
result
=
%
d
cache
\
n
"
this
ConnectionInfo
(
)
-
>
HashKey
(
)
.
get
(
)
key
.
get
(
)
cachedResult
)
)
;
return
cachedResult
;
}
nsresult
rv
;
bool
isJoined
=
false
;
nsCOMPtr
<
nsISSLSocketControl
>
sslSocketControl
;
mConnection
-
>
GetTLSSocketControl
(
getter_AddRefs
(
sslSocketControl
)
)
;
if
(
!
sslSocketControl
)
{
return
false
;
}
const
SpdyInformation
*
info
=
gHttpHandler
-
>
SpdyInfo
(
)
;
bool
joinedReturn
=
false
;
if
(
StaticPrefs
:
:
network_http_http2_enabled
(
)
)
{
if
(
justKidding
)
{
rv
=
sslSocketControl
-
>
TestJoinConnection
(
info
-
>
VersionString
hostname
port
&
isJoined
)
;
}
else
{
rv
=
sslSocketControl
-
>
JoinConnection
(
info
-
>
VersionString
hostname
port
&
isJoined
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
isJoined
)
{
joinedReturn
=
true
;
}
}
LOG
(
(
"
joinconnection
[
%
p
%
s
]
%
s
result
=
%
d
lookup
\
n
"
this
ConnectionInfo
(
)
-
>
HashKey
(
)
.
get
(
)
key
.
get
(
)
joinedReturn
)
)
;
mJoinConnectionCache
.
InsertOrUpdate
(
key
joinedReturn
)
;
if
(
!
justKidding
)
{
nsAutoCString
key2
(
hostname
)
;
key2
.
Append
(
'
:
'
)
;
key2
.
Append
(
'
k
'
)
;
key2
.
AppendInt
(
port
)
;
if
(
!
mJoinConnectionCache
.
Get
(
key2
)
)
{
mJoinConnectionCache
.
InsertOrUpdate
(
key2
joinedReturn
)
;
}
}
return
joinedReturn
;
}
void
Http2Session
:
:
TopBrowsingContextIdChanged
(
uint64_t
id
)
{
MOZ_ASSERT
(
OnSocketThread
(
)
"
not
on
socket
thread
"
)
;
mCurrentTopBrowsingContextId
=
id
;
for
(
const
auto
&
stream
:
mStreamTransactionHash
.
Values
(
)
)
{
stream
-
>
TopBrowsingContextIdChanged
(
id
)
;
}
}
void
Http2Session
:
:
SetCleanShutdown
(
bool
aCleanShutdown
)
{
mCleanShutdown
=
aCleanShutdown
;
}
void
Http2Session
:
:
CreateWebsocketStream
(
nsAHttpTransaction
*
aOriginalTransaction
nsIInterfaceRequestor
*
aCallbacks
)
{
LOG
(
(
"
Http2Session
:
:
CreateWebsocketStream
%
p
%
p
\
n
"
this
aOriginalTransaction
)
)
;
nsHttpTransaction
*
trans
=
aOriginalTransaction
-
>
QueryHttpTransaction
(
)
;
MOZ_ASSERT
(
trans
)
;
nsHttpConnectionInfo
*
ci
=
aOriginalTransaction
-
>
ConnectionInfo
(
)
;
MOZ_ASSERT
(
ci
)
;
RefPtr
<
nsHttpConnectionInfo
>
clone
(
ci
-
>
Clone
(
)
)
;
RefPtr
<
Http2ConnectTransaction
>
connectTrans
=
new
Http2ConnectTransaction
(
clone
aCallbacks
trans
-
>
Caps
(
)
trans
this
true
)
;
CreateStream
(
connectTrans
nsISupportsPriority
:
:
PRIORITY_NORMAL
Http2StreamBaseType
:
:
WebSocket
)
;
}
void
Http2Session
:
:
ProcessWaitingWebsockets
(
)
{
MOZ_ASSERT
(
!
mProcessedWaitingWebsockets
)
;
MOZ_ASSERT
(
mWaitingWebsockets
.
Length
(
)
=
=
mWaitingWebsocketCallbacks
.
Length
(
)
)
;
mProcessedWaitingWebsockets
=
true
;
if
(
!
mWaitingWebsockets
.
Length
(
)
)
{
LOG3
(
(
"
Http2Session
:
:
ProcessWaitingWebsockets
%
p
nothing
to
do
"
this
)
)
;
return
;
}
for
(
size_t
i
=
0
;
i
<
mWaitingWebsockets
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
nsAHttpTransaction
>
httpTransaction
=
mWaitingWebsockets
[
i
]
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
=
mWaitingWebsocketCallbacks
[
i
]
;
if
(
mPeerAllowsWebsockets
)
{
LOG3
(
(
"
Http2Session
:
:
ProcessWaitingWebsockets
session
=
%
p
trans
=
%
p
"
"
websocket
"
this
httpTransaction
.
get
(
)
)
)
;
CreateWebsocketStream
(
httpTransaction
callbacks
)
;
}
else
{
LOG3
(
(
"
Http2Session
:
:
ProcessWaitingWebsockets
%
p
Re
-
queuing
websocket
as
"
"
h1
due
to
mPeerAllowsWebsockets
=
false
"
this
)
)
;
httpTransaction
-
>
SetConnection
(
nullptr
)
;
httpTransaction
-
>
DisableSpdy
(
)
;
nsHttpTransaction
*
trans
=
httpTransaction
-
>
QueryHttpTransaction
(
)
;
if
(
trans
)
{
nsresult
rv
=
gHttpHandler
-
>
InitiateTransaction
(
trans
trans
-
>
Priority
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG3
(
(
"
Http2Session
:
:
ProcessWaitingWebsockets
%
p
failed
to
reinitiate
"
"
websocket
transaction
(
%
08x
)
.
\
n
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
}
else
{
LOG3
(
(
"
Http2Session
:
:
ProcessWaitingWebsockets
%
p
missing
transaction
?
!
"
this
)
)
;
}
}
}
mWaitingWebsockets
.
Clear
(
)
;
mWaitingWebsocketCallbacks
.
Clear
(
)
;
}
bool
Http2Session
:
:
CanAcceptWebsocket
(
)
{
LOG3
(
(
"
Http2Session
:
:
CanAcceptWebsocket
%
p
enable
=
%
d
allow
=
%
d
processed
=
%
d
"
this
mEnableWebsockets
mPeerAllowsWebsockets
mProcessedWaitingWebsockets
)
)
;
return
mEnableWebsockets
&
&
(
mPeerAllowsWebsockets
|
|
!
mProcessedWaitingWebsockets
)
;
}
PRIntervalTime
Http2Session
:
:
LastWriteTime
(
)
{
return
mConnection
-
>
LastWriteTime
(
)
;
}
}
}
