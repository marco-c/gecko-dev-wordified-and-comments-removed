#
include
"
base
/
basictypes
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
nsAboutProtocolHandler
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIAboutModule
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsIWritablePropertyBag2
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
DefaultURI
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
namespace
mozilla
{
namespace
net
{
static
NS_DEFINE_CID
(
kNestedAboutURICID
NS_NESTEDABOUTURI_CID
)
;
static
bool
IsSafeToLinkForUntrustedContent
(
nsIURI
*
aURI
)
{
nsAutoCString
path
;
aURI
-
>
GetPathQueryRef
(
path
)
;
int32_t
f
=
path
.
FindChar
(
'
#
'
)
;
if
(
f
>
=
0
)
{
path
.
SetLength
(
f
)
;
}
f
=
path
.
FindChar
(
'
?
'
)
;
if
(
f
>
=
0
)
{
path
.
SetLength
(
f
)
;
}
ToLowerCase
(
path
)
;
return
path
.
EqualsLiteral
(
"
blank
"
)
|
|
path
.
EqualsLiteral
(
"
logo
"
)
|
|
path
.
EqualsLiteral
(
"
srcdoc
"
)
;
}
NS_IMPL_ISUPPORTS
(
nsAboutProtocolHandler
nsIProtocolHandler
nsIProtocolHandlerWithDynamicFlags
nsISupportsWeakReference
)
NS_IMETHODIMP
nsAboutProtocolHandler
:
:
GetScheme
(
nsACString
&
result
)
{
result
.
AssignLiteral
(
"
about
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAboutProtocolHandler
:
:
GetFlagsForURI
(
nsIURI
*
aURI
uint32_t
*
aFlags
)
{
*
aFlags
=
URI_NORELATIVE
|
URI_NOAUTH
|
URI_DANGEROUS_TO_LOAD
|
URI_SCHEME_NOT_SELF_LINKABLE
;
nsCOMPtr
<
nsIAboutModule
>
aboutMod
;
nsresult
rv
=
NS_GetAboutModule
(
aURI
getter_AddRefs
(
aboutMod
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
uint32_t
aboutModuleFlags
=
0
;
rv
=
aboutMod
-
>
GetURIFlags
(
aURI
&
aboutModuleFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aboutModuleFlags
&
nsIAboutModule
:
:
URI_SAFE_FOR_UNTRUSTED_CONTENT
)
{
*
aFlags
|
=
URI_IS_POTENTIALLY_TRUSTWORTHY
;
if
(
aboutModuleFlags
&
nsIAboutModule
:
:
MAKE_LINKABLE
)
{
*
aFlags
&
=
~
URI_DANGEROUS_TO_LOAD
;
*
aFlags
|
=
URI_LOADABLE_BY_ANYONE
;
}
}
return
NS_OK
;
}
nsresult
nsAboutProtocolHandler
:
:
CreateNewURI
(
const
nsACString
&
aSpec
const
char
*
aCharset
nsIURI
*
aBaseURI
nsIURI
*
*
aResult
)
{
*
aResult
=
nullptr
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
url
;
rv
=
NS_MutateURI
(
new
nsSimpleURI
:
:
Mutator
(
)
)
.
SetSpec
(
aSpec
)
.
Finalize
(
url
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
IsSafeToLinkForUntrustedContent
(
url
)
)
{
nsAutoCString
spec
;
rv
=
url
-
>
GetPathQueryRef
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
spec
.
InsertLiteral
(
"
moz
-
safe
-
about
:
"
0
)
;
nsCOMPtr
<
nsIURI
>
inner
;
rv
=
NS_NewURI
(
getter_AddRefs
(
inner
)
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
NS_MutateURI
(
new
nsNestedAboutURI
:
:
Mutator
(
)
)
.
Apply
(
&
nsINestedAboutURIMutator
:
:
InitWithBase
inner
aBaseURI
)
.
SetSpec
(
aSpec
)
.
Finalize
(
url
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
auto
pos
=
aSpec
.
Find
(
"
about
:
/
"
)
;
if
(
pos
!
=
kNotFound
)
{
rv
=
NS_MutateURI
(
new
mozilla
:
:
net
:
:
DefaultURI
:
:
Mutator
(
)
)
.
SetSpec
(
aSpec
)
.
Finalize
(
url
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
url
.
swap
(
*
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAboutProtocolHandler
:
:
NewChannel
(
nsIURI
*
uri
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
NS_ENSURE_ARG_POINTER
(
uri
)
;
nsCOMPtr
<
nsIAboutModule
>
aboutMod
;
nsresult
rv
=
NS_GetAboutModule
(
uri
getter_AddRefs
(
aboutMod
)
)
;
nsAutoCString
path
;
if
(
NS_SUCCEEDED
(
NS_GetAboutModuleName
(
uri
path
)
)
&
&
path
.
EqualsLiteral
(
"
srcdoc
"
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_FACTORY_NOT_REGISTERED
)
{
return
NS_ERROR_MALFORMED_URI
;
}
return
rv
;
}
uint32_t
flags
=
0
;
if
(
NS_FAILED
(
aboutMod
-
>
GetURIFlags
(
uri
&
flags
)
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
safeForUntrustedContent
=
(
flags
&
nsIAboutModule
:
:
URI_SAFE_FOR_UNTRUSTED_CONTENT
)
!
=
0
;
MOZ_DIAGNOSTIC_ASSERT
(
safeForUntrustedContent
|
|
(
flags
&
(
nsIAboutModule
:
:
URI_CAN_LOAD_IN_CHILD
|
nsIAboutModule
:
:
URI_MUST_LOAD_IN_CHILD
)
)
=
=
0
"
Only
unprivileged
content
should
be
loaded
in
child
processes
.
(
Did
"
"
you
forget
to
add
URI_SAFE_FOR_UNTRUSTED_CONTENT
to
your
about
:
"
"
page
?
)
"
)
;
rv
=
aboutMod
-
>
NewChannel
(
uri
aLoadInfo
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_FACTORY_NOT_REGISTERED
)
{
return
NS_ERROR_MALFORMED_URI
;
}
return
rv
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
(
*
result
)
-
>
LoadInfo
(
)
;
if
(
aLoadInfo
!
=
loadInfo
)
{
NS_ASSERTION
(
false
"
nsIAboutModule
-
>
newChannel
(
aURI
aLoadInfo
)
needs
to
"
"
set
LoadInfo
"
)
;
AutoTArray
<
nsString
2
>
params
=
{
u
"
nsIAboutModule
-
>
newChannel
(
aURI
)
"
_ns
u
"
nsIAboutModule
-
>
newChannel
(
aURI
aLoadInfo
)
"
_ns
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Security
by
Default
"
_ns
nullptr
nsContentUtils
:
:
eNECKO_PROPERTIES
"
APIDeprecationWarning
"
params
)
;
(
*
result
)
-
>
SetLoadInfo
(
aLoadInfo
)
;
}
if
(
safeForUntrustedContent
)
{
(
*
result
)
-
>
SetOwner
(
nullptr
)
;
}
RefPtr
<
nsNestedAboutURI
>
aboutURI
;
if
(
NS_SUCCEEDED
(
uri
-
>
QueryInterface
(
kNestedAboutURICID
getter_AddRefs
(
aboutURI
)
)
)
&
&
aboutURI
-
>
GetBaseURI
(
)
)
{
nsCOMPtr
<
nsIWritablePropertyBag2
>
writableBag
=
do_QueryInterface
(
*
result
)
;
if
(
writableBag
)
{
writableBag
-
>
SetPropertyAsInterface
(
u
"
baseURI
"
_ns
aboutURI
-
>
GetBaseURI
(
)
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsAboutProtocolHandler
:
:
AllowPort
(
int32_t
port
const
char
*
scheme
bool
*
_retval
)
{
*
_retval
=
false
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsSafeAboutProtocolHandler
nsIProtocolHandler
nsISupportsWeakReference
)
NS_IMETHODIMP
nsSafeAboutProtocolHandler
:
:
GetScheme
(
nsACString
&
result
)
{
result
.
AssignLiteral
(
"
moz
-
safe
-
about
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSafeAboutProtocolHandler
:
:
NewChannel
(
nsIURI
*
uri
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
*
result
=
nullptr
;
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
nsSafeAboutProtocolHandler
:
:
AllowPort
(
int32_t
port
const
char
*
scheme
bool
*
_retval
)
{
*
_retval
=
false
;
return
NS_OK
;
}
NS_IMPL_CLASSINFO
(
nsNestedAboutURI
nullptr
nsIClassInfo
:
:
THREADSAFE
NS_NESTEDABOUTURI_CID
)
;
NS_IMPL_CI_INTERFACE_GETTER0
(
nsNestedAboutURI
)
NS_INTERFACE_MAP_BEGIN
(
nsNestedAboutURI
)
if
(
aIID
.
Equals
(
kNestedAboutURICID
)
)
{
foundInterface
=
static_cast
<
nsIURI
*
>
(
this
)
;
}
else
NS_IMPL_QUERY_CLASSINFO
(
nsNestedAboutURI
)
NS_INTERFACE_MAP_END_INHERITING
(
nsSimpleNestedURI
)
NS_IMETHODIMP
nsNestedAboutURI
:
:
Read
(
nsIObjectInputStream
*
aStream
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Use
nsIURIMutator
.
read
(
)
instead
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
nsNestedAboutURI
:
:
ReadPrivate
(
nsIObjectInputStream
*
aStream
)
{
nsresult
rv
=
nsSimpleNestedURI
:
:
ReadPrivate
(
aStream
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
bool
haveBase
;
rv
=
aStream
-
>
ReadBoolean
(
&
haveBase
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
haveBase
)
{
nsCOMPtr
<
nsISupports
>
supports
;
rv
=
aStream
-
>
ReadObject
(
true
getter_AddRefs
(
supports
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mBaseURI
=
do_QueryInterface
(
supports
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNestedAboutURI
:
:
Write
(
nsIObjectOutputStream
*
aStream
)
{
nsresult
rv
=
nsSimpleNestedURI
:
:
Write
(
aStream
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
aStream
-
>
WriteBoolean
(
mBaseURI
!
=
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
mBaseURI
)
{
rv
=
aStream
-
>
WriteCompoundObject
(
mBaseURI
NS_GET_IID
(
nsISupports
)
true
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
nsNestedAboutURI
:
:
Serialize
(
mozilla
:
:
ipc
:
:
URIParams
&
aParams
)
{
using
namespace
mozilla
:
:
ipc
;
NestedAboutURIParams
params
;
URIParams
nestedParams
;
nsSimpleNestedURI
:
:
Serialize
(
nestedParams
)
;
params
.
nestedParams
(
)
=
nestedParams
;
if
(
mBaseURI
)
{
SerializeURI
(
mBaseURI
params
.
baseURI
(
)
)
;
}
aParams
=
params
;
}
bool
nsNestedAboutURI
:
:
Deserialize
(
const
mozilla
:
:
ipc
:
:
URIParams
&
aParams
)
{
using
namespace
mozilla
:
:
ipc
;
if
(
aParams
.
type
(
)
!
=
URIParams
:
:
TNestedAboutURIParams
)
{
NS_ERROR
(
"
Received
unknown
parameters
from
the
other
process
!
"
)
;
return
false
;
}
const
NestedAboutURIParams
&
params
=
aParams
.
get_NestedAboutURIParams
(
)
;
if
(
!
nsSimpleNestedURI
:
:
Deserialize
(
params
.
nestedParams
(
)
)
)
{
return
false
;
}
mBaseURI
=
nullptr
;
if
(
params
.
baseURI
(
)
)
{
mBaseURI
=
DeserializeURI
(
*
params
.
baseURI
(
)
)
;
}
return
true
;
}
nsSimpleURI
*
nsNestedAboutURI
:
:
StartClone
(
nsSimpleURI
:
:
RefHandlingEnum
aRefHandlingMode
const
nsACString
&
aNewRef
)
{
NS_ENSURE_TRUE
(
mInnerURI
nullptr
)
;
nsCOMPtr
<
nsIURI
>
innerClone
;
nsresult
rv
=
NS_OK
;
if
(
aRefHandlingMode
=
=
eHonorRef
)
{
innerClone
=
mInnerURI
;
}
else
if
(
aRefHandlingMode
=
=
eReplaceRef
)
{
rv
=
NS_GetURIWithNewRef
(
mInnerURI
aNewRef
getter_AddRefs
(
innerClone
)
)
;
}
else
{
rv
=
NS_GetURIWithoutRef
(
mInnerURI
getter_AddRefs
(
innerClone
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
nsNestedAboutURI
*
url
=
new
nsNestedAboutURI
(
innerClone
mBaseURI
)
;
SetRefOnClone
(
url
aRefHandlingMode
aNewRef
)
;
return
url
;
}
NS_IMPL_NSIURIMUTATOR_ISUPPORTS
(
nsNestedAboutURI
:
:
Mutator
nsIURISetters
nsIURIMutator
nsISerializable
nsINestedAboutURIMutator
)
NS_IMETHODIMP
nsNestedAboutURI
:
:
Mutate
(
nsIURIMutator
*
*
aMutator
)
{
RefPtr
<
nsNestedAboutURI
:
:
Mutator
>
mutator
=
new
nsNestedAboutURI
:
:
Mutator
(
)
;
nsresult
rv
=
mutator
-
>
InitFromURI
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mutator
.
forget
(
aMutator
)
;
return
NS_OK
;
}
}
}
