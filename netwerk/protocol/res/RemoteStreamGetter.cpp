#
include
"
RemoteStreamGetter
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
net
/
NeckoChild
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIInputStreamPump
.
h
"
namespace
mozilla
{
namespace
net
{
NS_IMPL_ISUPPORTS
(
RemoteStreamGetter
nsICancelable
)
RemoteStreamGetter
:
:
RemoteStreamGetter
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
)
:
mURI
(
aURI
)
mLoadInfo
(
aLoadInfo
)
{
MOZ_ASSERT
(
aURI
)
;
MOZ_ASSERT
(
aLoadInfo
)
;
}
RequestOrReason
RemoteStreamGetter
:
:
GetAsync
(
nsIStreamListener
*
aListener
nsIChannel
*
aChannel
Method
aMethod
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
MOZ_ASSERT
(
aMethod
)
;
mListener
=
aListener
;
mChannel
=
aChannel
;
nsCOMPtr
<
nsICancelable
>
cancelableRequest
(
this
)
;
RefPtr
<
RemoteStreamGetter
>
self
=
this
;
Maybe
<
LoadInfoArgs
>
loadInfoArgs
;
nsresult
rv
=
ipc
:
:
LoadInfoToLoadInfoArgs
(
mLoadInfo
&
loadInfoArgs
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
(
gNeckoChild
-
>
*
aMethod
)
(
mURI
loadInfoArgs
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
]
(
const
Maybe
<
RemoteStreamInfo
>
&
info
)
{
self
-
>
OnStream
(
info
)
;
}
[
self
]
(
const
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
self
-
>
OnStream
(
Nothing
(
)
)
;
}
)
;
return
RequestOrCancelable
(
WrapNotNull
(
cancelableRequest
)
)
;
}
NS_IMETHODIMP
RemoteStreamGetter
:
:
Cancel
(
nsresult
aStatus
)
{
if
(
mCanceled
)
{
return
NS_OK
;
}
mCanceled
=
true
;
mStatus
=
aStatus
;
if
(
mPump
)
{
mPump
-
>
Cancel
(
aStatus
)
;
mPump
=
nullptr
;
}
return
NS_OK
;
}
void
RemoteStreamGetter
:
:
CancelRequest
(
nsIStreamListener
*
aListener
nsIChannel
*
aChannel
nsresult
aResult
)
{
MOZ_ASSERT
(
aListener
)
;
MOZ_ASSERT
(
aChannel
)
;
aListener
-
>
OnStartRequest
(
aChannel
)
;
aListener
-
>
OnStopRequest
(
aChannel
aResult
)
;
aChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
void
RemoteStreamGetter
:
:
OnStream
(
const
Maybe
<
RemoteStreamInfo
>
&
aStreamInfo
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
MOZ_ASSERT
(
mChannel
)
;
MOZ_ASSERT
(
mListener
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
std
:
:
move
(
mChannel
)
;
nsCOMPtr
<
nsIStreamListener
>
listener
=
mListener
.
forget
(
)
;
if
(
aStreamInfo
.
isNothing
(
)
)
{
CancelRequest
(
listener
channel
NS_ERROR_FILE_ACCESS_DENIED
)
;
return
;
}
if
(
mCanceled
)
{
CancelRequest
(
listener
channel
mStatus
)
;
return
;
}
nsCOMPtr
<
nsIInputStream
>
stream
=
std
:
:
move
(
aStreamInfo
.
ref
(
)
.
inputStream
(
)
)
;
if
(
!
stream
)
{
CancelRequest
(
listener
channel
mStatus
)
;
return
;
}
nsCOMPtr
<
nsIInputStreamPump
>
pump
;
nsresult
rv
=
NS_NewInputStreamPump
(
getter_AddRefs
(
pump
)
stream
.
forget
(
)
0
0
false
GetMainThreadSerialEventTarget
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
CancelRequest
(
listener
channel
rv
)
;
return
;
}
channel
-
>
SetContentType
(
aStreamInfo
.
ref
(
)
.
contentType
(
)
)
;
channel
-
>
SetContentLength
(
aStreamInfo
.
ref
(
)
.
contentLength
(
)
)
;
rv
=
pump
-
>
AsyncRead
(
listener
)
;
if
(
NS_FAILED
(
rv
)
)
{
CancelRequest
(
listener
channel
rv
)
;
return
;
}
mPump
=
pump
;
}
}
}
