#
include
"
ExtensionProtocolHandler
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
ipc
/
IPCStreamUtils
.
h
"
#
include
"
mozilla
/
ipc
/
URIParams
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
mozilla
/
net
/
NeckoChild
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
FileDescriptor
.
h
"
#
include
"
FileDescriptorFile
.
h
"
#
include
"
LoadInfo
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileChannel
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
nsIJARChannel
.
h
"
#
include
"
nsIMIMEService
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIInputStreamPump
.
h
"
#
include
"
nsIJARURI
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
prio
.
h
"
#
include
"
SimpleChannel
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
nsILocalFileWin
.
h
"
#
include
"
WinUtils
.
h
"
#
endif
#
define
EXTENSION_SCHEME
"
moz
-
extension
"
using
mozilla
:
:
ipc
:
:
FileDescriptor
;
using
OptionalIPCStream
=
mozilla
:
:
ipc
:
:
OptionalIPCStream
;
namespace
mozilla
{
template
<
>
class
MOZ_MUST_USE_TYPE
GenericErrorResult
<
nsresult
>
{
nsresult
mErrorValue
;
template
<
typename
V
typename
E2
>
friend
class
Result
;
public
:
explicit
GenericErrorResult
(
nsresult
aErrorValue
)
:
mErrorValue
(
aErrorValue
)
{
}
operator
nsresult
(
)
{
return
mErrorValue
;
}
}
;
namespace
net
{
using
extensions
:
:
URLInfo
;
LazyLogModule
gExtProtocolLog
(
"
ExtProtocol
"
)
;
#
undef
LOG
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
gExtProtocolLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
StaticRefPtr
<
ExtensionProtocolHandler
>
ExtensionProtocolHandler
:
:
sSingleton
;
static
inline
Result
<
Ok
nsresult
>
WrapNSResult
(
PRStatus
aRv
)
{
if
(
aRv
!
=
PR_SUCCESS
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
Ok
(
)
;
}
static
inline
Result
<
Ok
nsresult
>
WrapNSResult
(
nsresult
aRv
)
{
if
(
NS_FAILED
(
aRv
)
)
{
return
Err
(
aRv
)
;
}
return
Ok
(
)
;
}
#
define
NS_TRY
(
expr
)
MOZ_TRY
(
WrapNSResult
(
expr
)
)
class
ExtensionStreamGetter
:
public
RefCounted
<
ExtensionStreamGetter
>
{
public
:
ExtensionStreamGetter
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
)
:
mURI
(
aURI
)
mLoadInfo
(
aLoadInfo
)
mIsJarChannel
(
false
)
{
MOZ_ASSERT
(
aURI
)
;
MOZ_ASSERT
(
aLoadInfo
)
;
SetupEventTarget
(
)
;
}
ExtensionStreamGetter
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
already_AddRefed
<
nsIJARChannel
>
&
&
aJarChannel
nsIFile
*
aJarFile
)
:
mURI
(
aURI
)
mLoadInfo
(
aLoadInfo
)
mJarChannel
(
Move
(
aJarChannel
)
)
mJarFile
(
aJarFile
)
mIsJarChannel
(
true
)
{
MOZ_ASSERT
(
aURI
)
;
MOZ_ASSERT
(
aLoadInfo
)
;
MOZ_ASSERT
(
mJarChannel
)
;
MOZ_ASSERT
(
aJarFile
)
;
SetupEventTarget
(
)
;
}
~
ExtensionStreamGetter
(
)
{
}
void
SetupEventTarget
(
)
{
mMainThreadEventTarget
=
nsContentUtils
:
:
GetEventTargetByLoadInfo
(
mLoadInfo
TaskCategory
:
:
Other
)
;
if
(
!
mMainThreadEventTarget
)
{
mMainThreadEventTarget
=
GetMainThreadSerialEventTarget
(
)
;
}
}
Result
<
Ok
nsresult
>
GetAsync
(
nsIStreamListener
*
aListener
nsIChannel
*
aChannel
)
;
void
OnStream
(
nsIInputStream
*
aStream
)
;
void
OnFD
(
const
FileDescriptor
&
aFD
)
;
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
ExtensionStreamGetter
)
private
:
nsCOMPtr
<
nsIURI
>
mURI
;
nsCOMPtr
<
nsILoadInfo
>
mLoadInfo
;
nsCOMPtr
<
nsIJARChannel
>
mJarChannel
;
nsCOMPtr
<
nsIFile
>
mJarFile
;
nsCOMPtr
<
nsIStreamListener
>
mListener
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsISerialEventTarget
>
mMainThreadEventTarget
;
bool
mIsJarChannel
;
}
;
class
ExtensionJARFileOpener
:
public
nsISupports
{
public
:
ExtensionJARFileOpener
(
nsIFile
*
aFile
NeckoParent
:
:
GetExtensionFDResolver
&
aResolve
)
:
mFile
(
aFile
)
mResolve
(
aResolve
)
{
MOZ_ASSERT
(
aFile
)
;
MOZ_ASSERT
(
aResolve
)
;
}
NS_IMETHOD
OpenFile
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
AutoFDClose
prFileDesc
;
#
if
defined
(
XP_WIN
)
nsresult
rv
;
nsCOMPtr
<
nsILocalFileWin
>
winFile
=
do_QueryInterface
(
mFile
&
rv
)
;
MOZ_ASSERT
(
winFile
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
winFile
-
>
OpenNSPRFileDescShareDelete
(
PR_RDONLY
0
&
prFileDesc
.
rwget
(
)
)
;
}
#
else
nsresult
rv
=
mFile
-
>
OpenNSPRFileDesc
(
PR_RDONLY
0
&
prFileDesc
.
rwget
(
)
)
;
#
endif
if
(
NS_SUCCEEDED
(
rv
)
)
{
mFD
=
FileDescriptor
(
FileDescriptor
:
:
PlatformHandleType
(
PR_FileDesc2NativeHandle
(
prFileDesc
)
)
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
mozilla
:
:
NewRunnableMethod
(
"
ExtensionJarFileFDResolver
"
this
&
ExtensionJARFileOpener
:
:
SendBackFD
)
;
rv
=
NS_DispatchToMainThread
(
event
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
NS_DispatchToMainThread
"
)
;
return
NS_OK
;
}
NS_IMETHOD
SendBackFD
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mResolve
(
mFD
)
;
return
NS_OK
;
}
NS_DECL_THREADSAFE_ISUPPORTS
private
:
virtual
~
ExtensionJARFileOpener
(
)
{
}
nsCOMPtr
<
nsIFile
>
mFile
;
NeckoParent
:
:
GetExtensionFDResolver
mResolve
;
FileDescriptor
mFD
;
}
;
NS_IMPL_ISUPPORTS
(
ExtensionJARFileOpener
nsISupports
)
#
define
DEFAULT_THREAD_TIMEOUT_MS
30000
Result
<
Ok
nsresult
>
ExtensionStreamGetter
:
:
GetAsync
(
nsIStreamListener
*
aListener
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
MOZ_ASSERT
(
mMainThreadEventTarget
)
;
mListener
=
aListener
;
mChannel
=
aChannel
;
mozilla
:
:
ipc
:
:
URIParams
uri
;
SerializeURI
(
mURI
uri
)
;
RefPtr
<
ExtensionStreamGetter
>
self
=
this
;
if
(
mIsJarChannel
)
{
gNeckoChild
-
>
SendGetExtensionFD
(
uri
)
-
>
Then
(
mMainThreadEventTarget
__func__
[
self
]
(
const
FileDescriptor
&
fd
)
{
self
-
>
OnFD
(
fd
)
;
}
[
self
]
(
const
mozilla
:
:
ipc
:
:
PromiseRejectReason
)
{
self
-
>
OnFD
(
FileDescriptor
(
)
)
;
}
)
;
return
Ok
(
)
;
}
gNeckoChild
-
>
SendGetExtensionStream
(
uri
)
-
>
Then
(
mMainThreadEventTarget
__func__
[
self
]
(
const
OptionalIPCStream
&
stream
)
{
nsCOMPtr
<
nsIInputStream
>
inputStream
;
if
(
stream
.
type
(
)
=
=
OptionalIPCStream
:
:
OptionalIPCStream
:
:
TIPCStream
)
{
inputStream
=
ipc
:
:
DeserializeIPCStream
(
stream
)
;
}
self
-
>
OnStream
(
inputStream
)
;
}
[
self
]
(
const
mozilla
:
:
ipc
:
:
PromiseRejectReason
)
{
self
-
>
OnStream
(
nullptr
)
;
}
)
;
return
Ok
(
)
;
}
void
ExtensionStreamGetter
:
:
OnStream
(
nsIInputStream
*
aStream
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
MOZ_ASSERT
(
mListener
)
;
MOZ_ASSERT
(
mMainThreadEventTarget
)
;
nsCOMPtr
<
nsIStreamListener
>
listener
=
mListener
.
forget
(
)
;
MOZ_ASSERT
(
mChannel
)
;
if
(
!
aStream
)
{
listener
-
>
OnStartRequest
(
mChannel
nullptr
)
;
listener
-
>
OnStopRequest
(
mChannel
nullptr
NS_ERROR_FILE_ACCESS_DENIED
)
;
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
return
;
}
nsCOMPtr
<
nsIInputStreamPump
>
pump
;
nsresult
rv
=
NS_NewInputStreamPump
(
getter_AddRefs
(
pump
)
aStream
-
1
-
1
0
0
false
mMainThreadEventTarget
)
;
if
(
NS_FAILED
(
rv
)
)
{
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
return
;
}
rv
=
pump
-
>
AsyncRead
(
listener
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
}
void
ExtensionStreamGetter
:
:
OnFD
(
const
FileDescriptor
&
aFD
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
MOZ_ASSERT
(
mListener
)
;
MOZ_ASSERT
(
mChannel
)
;
if
(
!
aFD
.
IsValid
(
)
)
{
OnStream
(
nullptr
)
;
return
;
}
nsCOMPtr
<
nsIStreamListener
>
listener
=
mListener
.
forget
(
)
;
RefPtr
<
FileDescriptorFile
>
fdFile
=
new
FileDescriptorFile
(
aFD
mJarFile
)
;
mJarChannel
-
>
SetJarFile
(
fdFile
)
;
nsresult
rv
=
mJarChannel
-
>
AsyncOpen2
(
listener
)
;
if
(
NS_FAILED
(
rv
)
)
{
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
}
NS_IMPL_QUERY_INTERFACE
(
ExtensionProtocolHandler
nsISubstitutingProtocolHandler
nsIProtocolHandler
nsIProtocolHandlerWithDynamicFlags
nsISupportsWeakReference
)
NS_IMPL_ADDREF_INHERITED
(
ExtensionProtocolHandler
SubstitutingProtocolHandler
)
NS_IMPL_RELEASE_INHERITED
(
ExtensionProtocolHandler
SubstitutingProtocolHandler
)
already_AddRefed
<
ExtensionProtocolHandler
>
ExtensionProtocolHandler
:
:
GetSingleton
(
)
{
if
(
!
sSingleton
)
{
sSingleton
=
new
ExtensionProtocolHandler
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
}
return
do_AddRef
(
sSingleton
.
get
(
)
)
;
}
ExtensionProtocolHandler
:
:
ExtensionProtocolHandler
(
)
:
SubstitutingProtocolHandler
(
EXTENSION_SCHEME
)
#
if
!
defined
(
XP_WIN
)
#
if
defined
(
XP_MACOSX
)
mAlreadyCheckedDevRepo
(
false
)
#
endif
mAlreadyCheckedAppDir
(
false
)
#
endif
{
mUseRemoteFileChannels
=
IsNeckoChild
(
)
&
&
Preferences
:
:
GetBool
(
"
extensions
.
webextensions
.
protocol
.
remote
"
)
;
}
static
inline
ExtensionPolicyService
&
EPS
(
)
{
return
ExtensionPolicyService
:
:
GetSingleton
(
)
;
}
nsresult
ExtensionProtocolHandler
:
:
GetFlagsForURI
(
nsIURI
*
aURI
uint32_t
*
aFlags
)
{
bool
loadableByAnyone
=
false
;
URLInfo
url
(
aURI
)
;
if
(
auto
*
policy
=
EPS
(
)
.
GetByURL
(
url
)
)
{
loadableByAnyone
=
policy
-
>
IsPathWebAccessible
(
url
.
FilePath
(
)
)
;
}
*
aFlags
=
URI_STD
|
URI_IS_LOCAL_RESOURCE
|
(
loadableByAnyone
?
(
URI_LOADABLE_BY_ANYONE
|
URI_FETCHABLE_BY_ANYONE
)
:
URI_DANGEROUS_TO_LOAD
)
;
return
NS_OK
;
}
bool
ExtensionProtocolHandler
:
:
ResolveSpecialCases
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aPathname
nsACString
&
aResult
)
{
if
(
!
SubstitutingProtocolHandler
:
:
HasSubstitution
(
aHost
)
)
{
return
false
;
}
if
(
aPathname
.
EqualsLiteral
(
"
/
_generated_background_page
.
html
"
)
)
{
Unused
<
<
EPS
(
)
.
GetGeneratedBackgroundPageUrl
(
aHost
aResult
)
;
return
!
aResult
.
IsEmpty
(
)
;
}
return
false
;
}
Result
<
Ok
nsresult
>
ExtensionProtocolHandler
:
:
SubstituteRemoteChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
aRetVal
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
NS_TRY
(
aURI
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
NS_TRY
(
aLoadInfo
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
nsAutoCString
unResolvedSpec
;
NS_TRY
(
aURI
-
>
GetSpec
(
unResolvedSpec
)
)
;
nsAutoCString
resolvedSpec
;
NS_TRY
(
ResolveURI
(
aURI
resolvedSpec
)
)
;
nsAutoCString
scheme
;
NS_TRY
(
net_ExtractURLScheme
(
resolvedSpec
scheme
)
)
;
if
(
scheme
.
EqualsLiteral
(
"
file
"
)
)
{
SubstituteRemoteFileChannel
(
aURI
aLoadInfo
resolvedSpec
aRetVal
)
;
return
Ok
(
)
;
}
if
(
scheme
.
EqualsLiteral
(
"
jar
"
)
)
{
return
SubstituteRemoteJarChannel
(
aURI
aLoadInfo
resolvedSpec
aRetVal
)
;
}
return
Ok
(
)
;
}
nsresult
ExtensionProtocolHandler
:
:
SubstituteChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURL
>
url
=
do_QueryInterface
(
aURI
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mUseRemoteFileChannels
)
{
MOZ_TRY
(
SubstituteRemoteChannel
(
aURI
aLoadInfo
result
)
)
;
}
nsAutoCString
ext
;
rv
=
url
-
>
GetFileExtension
(
ext
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
ext
.
LowerCaseEqualsLiteral
(
"
css
"
)
)
{
return
NS_OK
;
}
bool
haveLoadInfo
=
aLoadInfo
;
nsCOMPtr
<
nsIChannel
>
channel
=
NS_NewSimpleChannel
(
aURI
aLoadInfo
*
result
[
haveLoadInfo
]
(
nsIStreamListener
*
listener
nsIChannel
*
channel
nsIChannel
*
origChannel
)
-
>
RequestOrReason
{
nsresult
rv
;
nsCOMPtr
<
nsIStreamConverterService
>
convService
=
do_GetService
(
NS_STREAMCONVERTERSERVICE_CONTRACTID
&
rv
)
;
NS_TRY
(
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
NS_TRY
(
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
)
;
const
char
*
kFromType
=
"
application
/
vnd
.
mozilla
.
webext
.
unlocalized
"
;
const
char
*
kToType
=
"
text
/
css
"
;
nsCOMPtr
<
nsIStreamListener
>
converter
;
NS_TRY
(
convService
-
>
AsyncConvertData
(
kFromType
kToType
listener
uri
getter_AddRefs
(
converter
)
)
)
;
if
(
haveLoadInfo
)
{
NS_TRY
(
origChannel
-
>
AsyncOpen2
(
converter
)
)
;
}
else
{
NS_TRY
(
origChannel
-
>
AsyncOpen
(
converter
nullptr
)
)
;
}
return
RequestOrReason
(
origChannel
)
;
}
)
;
NS_ENSURE_TRUE
(
channel
NS_ERROR_OUT_OF_MEMORY
)
;
if
(
aLoadInfo
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
static_cast
<
LoadInfo
*
>
(
aLoadInfo
)
-
>
CloneForNewRequest
(
)
;
(
*
result
)
-
>
SetLoadInfo
(
loadInfo
)
;
}
channel
.
swap
(
*
result
)
;
return
NS_OK
;
}
Result
<
Ok
nsresult
>
ExtensionProtocolHandler
:
:
AllowExternalResource
(
nsIFile
*
aExtensionDir
nsIFile
*
aRequestedFile
bool
*
aResult
)
{
MOZ_ASSERT
(
!
IsNeckoChild
(
)
)
;
MOZ_ASSERT
(
aResult
)
;
*
aResult
=
false
;
#
if
defined
(
XP_WIN
)
return
Ok
(
)
;
#
else
if
(
!
mozilla
:
:
IsDevelopmentBuild
(
)
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
AppDirContains
(
aExtensionDir
aResult
)
)
;
if
(
!
*
aResult
)
{
return
Ok
(
)
;
}
#
if
defined
(
XP_MACOSX
)
MOZ_TRY
(
DevRepoContains
(
aRequestedFile
aResult
)
)
;
#
endif
return
Ok
(
)
;
#
endif
}
#
if
defined
(
XP_MACOSX
)
Result
<
Ok
nsresult
>
ExtensionProtocolHandler
:
:
DevRepoContains
(
nsIFile
*
aRequestedFile
bool
*
aResult
)
{
MOZ_ASSERT
(
mozilla
:
:
IsDevelopmentBuild
(
)
)
;
MOZ_ASSERT
(
!
IsNeckoChild
(
)
)
;
MOZ_ASSERT
(
aResult
)
;
*
aResult
=
false
;
if
(
!
mAlreadyCheckedDevRepo
)
{
mAlreadyCheckedDevRepo
=
true
;
NS_TRY
(
mozilla
:
:
GetRepoDir
(
getter_AddRefs
(
mDevRepo
)
)
)
;
if
(
MOZ_LOG_TEST
(
gExtProtocolLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
repoPath
;
Unused
<
<
mDevRepo
-
>
GetNativePath
(
repoPath
)
;
LOG
(
"
Repo
path
:
%
s
"
repoPath
.
get
(
)
)
;
}
}
if
(
mDevRepo
)
{
NS_TRY
(
mDevRepo
-
>
Contains
(
aRequestedFile
aResult
)
)
;
}
return
Ok
(
)
;
}
#
endif
#
if
!
defined
(
XP_WIN
)
Result
<
Ok
nsresult
>
ExtensionProtocolHandler
:
:
AppDirContains
(
nsIFile
*
aExtensionDir
bool
*
aResult
)
{
MOZ_ASSERT
(
mozilla
:
:
IsDevelopmentBuild
(
)
)
;
MOZ_ASSERT
(
!
IsNeckoChild
(
)
)
;
MOZ_ASSERT
(
aResult
)
;
*
aResult
=
false
;
if
(
!
mAlreadyCheckedAppDir
)
{
mAlreadyCheckedAppDir
=
true
;
NS_TRY
(
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
mAppDir
)
)
)
;
if
(
MOZ_LOG_TEST
(
gExtProtocolLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
appDirPath
;
Unused
<
<
mAppDir
-
>
GetNativePath
(
appDirPath
)
;
LOG
(
"
AppDir
path
:
%
s
"
appDirPath
.
get
(
)
)
;
}
}
if
(
mAppDir
)
{
NS_TRY
(
mAppDir
-
>
Contains
(
aExtensionDir
aResult
)
)
;
}
return
Ok
(
)
;
}
#
endif
static
void
LogExternalResourceError
(
nsIFile
*
aExtensionDir
nsIFile
*
aRequestedFile
)
{
MOZ_ASSERT
(
aExtensionDir
)
;
MOZ_ASSERT
(
aRequestedFile
)
;
nsAutoCString
extensionDirPath
requestedFilePath
;
Unused
<
<
aExtensionDir
-
>
GetNativePath
(
extensionDirPath
)
;
Unused
<
<
aRequestedFile
-
>
GetNativePath
(
requestedFilePath
)
;
LOG
(
"
Rejecting
external
unpacked
extension
resource
[
%
s
]
from
"
"
extension
directory
[
%
s
]
"
requestedFilePath
.
get
(
)
extensionDirPath
.
get
(
)
)
;
}
Result
<
nsCOMPtr
<
nsIInputStream
>
nsresult
>
ExtensionProtocolHandler
:
:
NewStream
(
nsIURI
*
aChildURI
bool
*
aTerminateSender
)
{
MOZ_ASSERT
(
!
IsNeckoChild
(
)
)
;
NS_TRY
(
aChildURI
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
NS_TRY
(
aTerminateSender
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
*
aTerminateSender
=
true
;
nsresult
rv
;
bool
isExtScheme
=
false
;
if
(
NS_FAILED
(
aChildURI
-
>
SchemeIs
(
EXTENSION_SCHEME
&
isExtScheme
)
)
|
|
!
isExtScheme
)
{
return
Err
(
NS_ERROR_UNKNOWN_PROTOCOL
)
;
}
*
aTerminateSender
=
false
;
nsAutoCString
host
;
NS_TRY
(
aChildURI
-
>
GetAsciiHost
(
host
)
)
;
nsCOMPtr
<
nsIURI
>
baseURI
;
NS_TRY
(
GetSubstitution
(
host
getter_AddRefs
(
baseURI
)
)
)
;
nsCOMPtr
<
nsIFileURL
>
fileURL
=
do_QueryInterface
(
baseURI
&
rv
)
;
NS_TRY
(
rv
)
;
nsCOMPtr
<
nsIFile
>
extensionDir
;
NS_TRY
(
fileURL
-
>
GetFile
(
getter_AddRefs
(
extensionDir
)
)
)
;
bool
isDirectory
=
false
;
NS_TRY
(
extensionDir
-
>
IsDirectory
(
&
isDirectory
)
)
;
if
(
!
isDirectory
)
{
return
Err
(
NS_ERROR_FILE_NOT_DIRECTORY
)
;
}
nsAutoCString
resolvedSpec
;
NS_TRY
(
ResolveURI
(
aChildURI
resolvedSpec
)
)
;
nsAutoCString
resolvedScheme
;
NS_TRY
(
net_ExtractURLScheme
(
resolvedSpec
resolvedScheme
)
)
;
if
(
!
resolvedScheme
.
EqualsLiteral
(
"
file
"
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
nsCOMPtr
<
nsIIOService
>
ioService
=
do_GetIOService
(
&
rv
)
;
NS_TRY
(
rv
)
;
nsCOMPtr
<
nsIURI
>
resolvedURI
;
NS_TRY
(
ioService
-
>
NewURI
(
resolvedSpec
nullptr
nullptr
getter_AddRefs
(
resolvedURI
)
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
NS_TRY
(
NS_NewChannel
(
getter_AddRefs
(
channel
)
resolvedURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
)
)
;
nsCOMPtr
<
nsIFileChannel
>
fileChannel
=
do_QueryInterface
(
channel
&
rv
)
;
NS_TRY
(
rv
)
;
nsCOMPtr
<
nsIFile
>
requestedFile
;
NS_TRY
(
fileChannel
-
>
GetFile
(
getter_AddRefs
(
requestedFile
)
)
)
;
NS_TRY
(
extensionDir
-
>
Normalize
(
)
)
;
NS_TRY
(
requestedFile
-
>
Normalize
(
)
)
;
#
if
defined
(
XP_WIN
)
if
(
!
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
extensionDir
)
|
|
!
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
requestedFile
)
)
{
return
Err
(
NS_ERROR_FILE_ACCESS_DENIED
)
;
}
#
endif
bool
isResourceFromExtensionDir
=
false
;
NS_TRY
(
extensionDir
-
>
Contains
(
requestedFile
&
isResourceFromExtensionDir
)
)
;
if
(
!
isResourceFromExtensionDir
)
{
bool
isAllowed
=
false
;
MOZ_TRY
(
AllowExternalResource
(
extensionDir
requestedFile
&
isAllowed
)
)
;
if
(
!
isAllowed
)
{
LogExternalResourceError
(
extensionDir
requestedFile
)
;
return
Err
(
NS_ERROR_FILE_ACCESS_DENIED
)
;
}
}
nsCOMPtr
<
nsIInputStream
>
inputStream
;
NS_TRY
(
NS_NewLocalFileInputStream
(
getter_AddRefs
(
inputStream
)
requestedFile
PR_RDONLY
-
1
nsIFileInputStream
:
:
DEFER_OPEN
)
)
;
return
inputStream
;
}
Result
<
Ok
nsresult
>
ExtensionProtocolHandler
:
:
NewFD
(
nsIURI
*
aChildURI
bool
*
aTerminateSender
NeckoParent
:
:
GetExtensionFDResolver
&
aResolve
)
{
MOZ_ASSERT
(
!
IsNeckoChild
(
)
)
;
NS_TRY
(
aChildURI
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
NS_TRY
(
aTerminateSender
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
*
aTerminateSender
=
true
;
nsresult
rv
;
bool
isExtScheme
=
false
;
if
(
NS_FAILED
(
aChildURI
-
>
SchemeIs
(
EXTENSION_SCHEME
&
isExtScheme
)
)
|
|
!
isExtScheme
)
{
return
Err
(
NS_ERROR_UNKNOWN_PROTOCOL
)
;
}
*
aTerminateSender
=
false
;
nsAutoCString
host
;
NS_TRY
(
aChildURI
-
>
GetAsciiHost
(
host
)
)
;
nsCOMPtr
<
nsIURI
>
subURI
;
NS_TRY
(
GetSubstitution
(
host
getter_AddRefs
(
subURI
)
)
)
;
nsCOMPtr
<
nsIJARURI
>
jarURI
=
do_QueryInterface
(
subURI
&
rv
)
;
NS_TRY
(
rv
)
;
nsCOMPtr
<
nsIURI
>
innerFileURI
;
NS_TRY
(
jarURI
-
>
GetJARFile
(
getter_AddRefs
(
innerFileURI
)
)
)
;
nsCOMPtr
<
nsIFileURL
>
innerFileURL
=
do_QueryInterface
(
innerFileURI
&
rv
)
;
NS_TRY
(
rv
)
;
nsCOMPtr
<
nsIFile
>
jarFile
;
NS_TRY
(
innerFileURL
-
>
GetFile
(
getter_AddRefs
(
jarFile
)
)
)
;
if
(
!
mFileOpenerThread
)
{
mFileOpenerThread
=
new
LazyIdleThread
(
DEFAULT_THREAD_TIMEOUT_MS
NS_LITERAL_CSTRING
(
"
ExtensionProtocolHandler
"
)
)
;
}
RefPtr
<
ExtensionJARFileOpener
>
fileOpener
=
new
ExtensionJARFileOpener
(
jarFile
aResolve
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
mozilla
:
:
NewRunnableMethod
(
"
ExtensionJarFileOpener
"
fileOpener
&
ExtensionJARFileOpener
:
:
OpenFile
)
;
NS_TRY
(
mFileOpenerThread
-
>
Dispatch
(
event
nsIEventTarget
:
:
DISPATCH_NORMAL
)
)
;
return
Ok
(
)
;
}
static
void
NewSimpleChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadinfo
ExtensionStreamGetter
*
aStreamGetter
nsIChannel
*
*
aRetVal
)
{
nsCOMPtr
<
nsIChannel
>
channel
=
NS_NewSimpleChannel
(
aURI
aLoadinfo
aStreamGetter
[
]
(
nsIStreamListener
*
listener
nsIChannel
*
channel
ExtensionStreamGetter
*
getter
)
-
>
RequestOrReason
{
MOZ_TRY
(
getter
-
>
GetAsync
(
listener
channel
)
)
;
return
RequestOrReason
(
nullptr
)
;
}
)
;
nsresult
rv
;
nsCOMPtr
<
nsIMIMEService
>
mime
=
do_GetService
(
"
mozilla
.
org
/
mime
;
1
"
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
contentType
;
rv
=
mime
-
>
GetTypeFromURI
(
aURI
contentType
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
Unused
<
<
channel
-
>
SetContentType
(
contentType
)
;
}
}
channel
.
swap
(
*
aRetVal
)
;
}
void
ExtensionProtocolHandler
:
:
SubstituteRemoteFileChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadinfo
nsACString
&
aResolvedFileSpec
nsIChannel
*
*
aRetVal
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
RefPtr
<
ExtensionStreamGetter
>
streamGetter
=
new
ExtensionStreamGetter
(
aURI
aLoadinfo
)
;
NewSimpleChannel
(
aURI
aLoadinfo
streamGetter
aRetVal
)
;
}
static
Result
<
Ok
nsresult
>
LogCacheCheck
(
const
nsIJARChannel
*
aJarChannel
nsIJARURI
*
aJarURI
bool
aIsCached
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
innerFileURI
;
NS_TRY
(
aJarURI
-
>
GetJARFile
(
getter_AddRefs
(
innerFileURI
)
)
)
;
nsCOMPtr
<
nsIFileURL
>
innerFileURL
=
do_QueryInterface
(
innerFileURI
&
rv
)
;
NS_TRY
(
rv
)
;
nsCOMPtr
<
nsIFile
>
jarFile
;
NS_TRY
(
innerFileURL
-
>
GetFile
(
getter_AddRefs
(
jarFile
)
)
)
;
nsAutoCString
uriSpec
jarSpec
;
Unused
<
<
aJarURI
-
>
GetSpec
(
uriSpec
)
;
Unused
<
<
innerFileURI
-
>
GetSpec
(
jarSpec
)
;
LOG
(
"
[
JARChannel
%
p
]
Cache
%
s
:
%
s
(
%
s
)
"
aJarChannel
aIsCached
?
"
hit
"
:
"
miss
"
uriSpec
.
get
(
)
jarSpec
.
get
(
)
)
;
return
Ok
(
)
;
}
Result
<
Ok
nsresult
>
ExtensionProtocolHandler
:
:
SubstituteRemoteJarChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadinfo
nsACString
&
aResolvedSpec
nsIChannel
*
*
aRetVal
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
;
NS_TRY
(
NS_NewURI
(
getter_AddRefs
(
uri
)
aResolvedSpec
)
)
;
nsCOMPtr
<
nsIJARURI
>
jarURI
=
do_QueryInterface
(
uri
&
rv
)
;
NS_TRY
(
rv
)
;
nsCOMPtr
<
nsIJARChannel
>
jarChannel
=
do_QueryInterface
(
*
aRetVal
&
rv
)
;
NS_TRY
(
rv
)
;
bool
isCached
=
false
;
NS_TRY
(
jarChannel
-
>
EnsureCached
(
&
isCached
)
)
;
if
(
MOZ_LOG_TEST
(
gExtProtocolLog
LogLevel
:
:
Debug
)
)
{
Unused
<
<
LogCacheCheck
(
jarChannel
jarURI
isCached
)
;
}
if
(
isCached
)
{
return
Ok
(
)
;
}
nsCOMPtr
<
nsIURI
>
innerFileURI
;
NS_TRY
(
jarURI
-
>
GetJARFile
(
getter_AddRefs
(
innerFileURI
)
)
)
;
nsCOMPtr
<
nsIFileURL
>
innerFileURL
=
do_QueryInterface
(
innerFileURI
&
rv
)
;
NS_TRY
(
rv
)
;
nsCOMPtr
<
nsIFile
>
jarFile
;
NS_TRY
(
innerFileURL
-
>
GetFile
(
getter_AddRefs
(
jarFile
)
)
)
;
RefPtr
<
ExtensionStreamGetter
>
streamGetter
=
new
ExtensionStreamGetter
(
aURI
aLoadinfo
jarChannel
.
forget
(
)
jarFile
)
;
NewSimpleChannel
(
aURI
aLoadinfo
streamGetter
aRetVal
)
;
return
Ok
(
)
;
}
#
undef
NS_TRY
}
}
