#
include
"
ExtensionProtocolHandler
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
Promise
-
inl
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
ipc
/
IPCStreamUtils
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
mozilla
/
net
/
NeckoChild
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
FileDescriptor
.
h
"
#
include
"
FileDescriptorFile
.
h
"
#
include
"
LoadInfo
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileChannel
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
nsIJARChannel
.
h
"
#
include
"
nsIMIMEService
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIInputStreamPump
.
h
"
#
include
"
nsIJARURI
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
prio
.
h
"
#
include
"
SimpleChannel
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
nsILocalFileWin
.
h
"
#
include
"
WinUtils
.
h
"
#
endif
#
if
defined
(
XP_MACOSX
)
#
include
"
nsMacUtilsImpl
.
h
"
#
endif
#
define
EXTENSION_SCHEME
"
moz
-
extension
"
using
mozilla
:
:
dom
:
:
Promise
;
using
mozilla
:
:
ipc
:
:
FileDescriptor
;
static
const
char
sStaticFileExtensions
[
]
[
5
]
=
{
"
bmp
"
"
gif
"
"
ico
"
"
jpeg
"
"
jpg
"
"
png
"
"
svg
"
}
;
namespace
mozilla
{
namespace
net
{
using
extensions
:
:
URLInfo
;
LazyLogModule
gExtProtocolLog
(
"
ExtProtocol
"
)
;
#
undef
LOG
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
gExtProtocolLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
StaticRefPtr
<
ExtensionProtocolHandler
>
ExtensionProtocolHandler
:
:
sSingleton
;
class
ExtensionStreamGetter
:
public
RefCounted
<
ExtensionStreamGetter
>
{
public
:
ExtensionStreamGetter
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
)
:
mURI
(
aURI
)
mLoadInfo
(
aLoadInfo
)
mIsJarChannel
(
false
)
{
MOZ_ASSERT
(
aURI
)
;
MOZ_ASSERT
(
aLoadInfo
)
;
SetupEventTarget
(
)
;
}
ExtensionStreamGetter
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
already_AddRefed
<
nsIJARChannel
>
&
&
aJarChannel
nsIFile
*
aJarFile
)
:
mURI
(
aURI
)
mLoadInfo
(
aLoadInfo
)
mJarChannel
(
std
:
:
move
(
aJarChannel
)
)
mJarFile
(
aJarFile
)
mIsJarChannel
(
true
)
{
MOZ_ASSERT
(
aURI
)
;
MOZ_ASSERT
(
aLoadInfo
)
;
MOZ_ASSERT
(
mJarChannel
)
;
MOZ_ASSERT
(
aJarFile
)
;
SetupEventTarget
(
)
;
}
~
ExtensionStreamGetter
(
)
=
default
;
void
SetupEventTarget
(
)
{
mMainThreadEventTarget
=
nsContentUtils
:
:
GetEventTargetByLoadInfo
(
mLoadInfo
TaskCategory
:
:
Other
)
;
if
(
!
mMainThreadEventTarget
)
{
mMainThreadEventTarget
=
GetMainThreadSerialEventTarget
(
)
;
}
}
Result
<
Ok
nsresult
>
GetAsync
(
nsIStreamListener
*
aListener
nsIChannel
*
aChannel
)
;
void
OnStream
(
already_AddRefed
<
nsIInputStream
>
aStream
)
;
void
OnFD
(
const
FileDescriptor
&
aFD
)
;
static
void
CancelRequest
(
nsIStreamListener
*
aListener
nsIChannel
*
aChannel
nsresult
aResult
)
;
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
ExtensionStreamGetter
)
private
:
nsCOMPtr
<
nsIURI
>
mURI
;
nsCOMPtr
<
nsILoadInfo
>
mLoadInfo
;
nsCOMPtr
<
nsIJARChannel
>
mJarChannel
;
nsCOMPtr
<
nsIFile
>
mJarFile
;
nsCOMPtr
<
nsIStreamListener
>
mListener
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsISerialEventTarget
>
mMainThreadEventTarget
;
bool
mIsJarChannel
;
}
;
class
ExtensionJARFileOpener
final
:
public
nsISupports
{
public
:
ExtensionJARFileOpener
(
nsIFile
*
aFile
NeckoParent
:
:
GetExtensionFDResolver
&
aResolve
)
:
mFile
(
aFile
)
mResolve
(
aResolve
)
{
MOZ_ASSERT
(
aFile
)
;
MOZ_ASSERT
(
aResolve
)
;
}
NS_IMETHOD
OpenFile
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
AutoFDClose
prFileDesc
;
#
if
defined
(
XP_WIN
)
nsresult
rv
;
nsCOMPtr
<
nsILocalFileWin
>
winFile
=
do_QueryInterface
(
mFile
&
rv
)
;
MOZ_ASSERT
(
winFile
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
winFile
-
>
OpenNSPRFileDescShareDelete
(
PR_RDONLY
0
&
prFileDesc
.
rwget
(
)
)
;
}
#
else
nsresult
rv
=
mFile
-
>
OpenNSPRFileDesc
(
PR_RDONLY
0
&
prFileDesc
.
rwget
(
)
)
;
#
endif
if
(
NS_SUCCEEDED
(
rv
)
)
{
mFD
=
FileDescriptor
(
FileDescriptor
:
:
PlatformHandleType
(
PR_FileDesc2NativeHandle
(
prFileDesc
)
)
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
mozilla
:
:
NewRunnableMethod
(
"
ExtensionJarFileFDResolver
"
this
&
ExtensionJARFileOpener
:
:
SendBackFD
)
;
rv
=
NS_DispatchToMainThread
(
event
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
NS_DispatchToMainThread
"
)
;
return
NS_OK
;
}
NS_IMETHOD
SendBackFD
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mResolve
(
mFD
)
;
mResolve
=
nullptr
;
return
NS_OK
;
}
NS_DECL_THREADSAFE_ISUPPORTS
private
:
virtual
~
ExtensionJARFileOpener
(
)
=
default
;
nsCOMPtr
<
nsIFile
>
mFile
;
NeckoParent
:
:
GetExtensionFDResolver
mResolve
;
FileDescriptor
mFD
;
}
;
NS_IMPL_ISUPPORTS
(
ExtensionJARFileOpener
nsISupports
)
#
define
DEFAULT_THREAD_TIMEOUT_MS
30000
Result
<
Ok
nsresult
>
ExtensionStreamGetter
:
:
GetAsync
(
nsIStreamListener
*
aListener
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
MOZ_ASSERT
(
mMainThreadEventTarget
)
;
mListener
=
aListener
;
mChannel
=
aChannel
;
RefPtr
<
ExtensionStreamGetter
>
self
=
this
;
if
(
mIsJarChannel
)
{
gNeckoChild
-
>
SendGetExtensionFD
(
mURI
)
-
>
Then
(
mMainThreadEventTarget
__func__
[
self
]
(
const
FileDescriptor
&
fd
)
{
self
-
>
OnFD
(
fd
)
;
}
[
self
]
(
const
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
self
-
>
OnFD
(
FileDescriptor
(
)
)
;
}
)
;
return
Ok
(
)
;
}
gNeckoChild
-
>
SendGetExtensionStream
(
mURI
)
-
>
Then
(
mMainThreadEventTarget
__func__
[
self
]
(
const
RefPtr
<
nsIInputStream
>
&
stream
)
{
self
-
>
OnStream
(
do_AddRef
(
stream
)
)
;
}
[
self
]
(
const
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
self
-
>
OnStream
(
nullptr
)
;
}
)
;
return
Ok
(
)
;
}
void
ExtensionStreamGetter
:
:
CancelRequest
(
nsIStreamListener
*
aListener
nsIChannel
*
aChannel
nsresult
aResult
)
{
MOZ_ASSERT
(
aListener
)
;
MOZ_ASSERT
(
aChannel
)
;
aListener
-
>
OnStartRequest
(
aChannel
)
;
aListener
-
>
OnStopRequest
(
aChannel
aResult
)
;
aChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
void
ExtensionStreamGetter
:
:
OnStream
(
already_AddRefed
<
nsIInputStream
>
aStream
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
MOZ_ASSERT
(
mListener
)
;
MOZ_ASSERT
(
mMainThreadEventTarget
)
;
nsCOMPtr
<
nsIInputStream
>
stream
=
std
:
:
move
(
aStream
)
;
nsCOMPtr
<
nsIStreamListener
>
listener
=
std
:
:
move
(
mListener
)
;
MOZ_ASSERT
(
mChannel
)
;
if
(
!
stream
)
{
CancelRequest
(
listener
mChannel
NS_ERROR_FILE_ACCESS_DENIED
)
;
return
;
}
nsCOMPtr
<
nsIInputStreamPump
>
pump
;
nsresult
rv
=
NS_NewInputStreamPump
(
getter_AddRefs
(
pump
)
stream
.
forget
(
)
0
0
false
mMainThreadEventTarget
)
;
if
(
NS_FAILED
(
rv
)
)
{
CancelRequest
(
listener
mChannel
rv
)
;
return
;
}
rv
=
pump
-
>
AsyncRead
(
listener
)
;
if
(
NS_FAILED
(
rv
)
)
{
CancelRequest
(
listener
mChannel
rv
)
;
}
}
void
ExtensionStreamGetter
:
:
OnFD
(
const
FileDescriptor
&
aFD
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
MOZ_ASSERT
(
mListener
)
;
MOZ_ASSERT
(
mChannel
)
;
if
(
!
aFD
.
IsValid
(
)
)
{
OnStream
(
nullptr
)
;
return
;
}
nsCOMPtr
<
nsIStreamListener
>
listener
=
std
:
:
move
(
mListener
)
;
RefPtr
<
FileDescriptorFile
>
fdFile
=
new
FileDescriptorFile
(
aFD
mJarFile
)
;
mJarChannel
-
>
SetJarFile
(
fdFile
)
;
nsresult
rv
=
mJarChannel
-
>
AsyncOpen
(
listener
)
;
if
(
NS_FAILED
(
rv
)
)
{
CancelRequest
(
listener
mChannel
rv
)
;
}
}
NS_IMPL_QUERY_INTERFACE
(
ExtensionProtocolHandler
nsISubstitutingProtocolHandler
nsIProtocolHandler
nsIProtocolHandlerWithDynamicFlags
nsISupportsWeakReference
)
NS_IMPL_ADDREF_INHERITED
(
ExtensionProtocolHandler
SubstitutingProtocolHandler
)
NS_IMPL_RELEASE_INHERITED
(
ExtensionProtocolHandler
SubstitutingProtocolHandler
)
already_AddRefed
<
ExtensionProtocolHandler
>
ExtensionProtocolHandler
:
:
GetSingleton
(
)
{
if
(
!
sSingleton
)
{
sSingleton
=
new
ExtensionProtocolHandler
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
}
return
do_AddRef
(
sSingleton
)
;
}
ExtensionProtocolHandler
:
:
ExtensionProtocolHandler
(
)
:
SubstitutingProtocolHandler
(
EXTENSION_SCHEME
)
#
if
!
defined
(
XP_WIN
)
#
if
defined
(
XP_MACOSX
)
mAlreadyCheckedDevRepo
(
false
)
#
endif
mAlreadyCheckedAppDir
(
false
)
#
endif
{
mUseRemoteFileChannels
=
IsNeckoChild
(
)
&
&
Preferences
:
:
GetBool
(
"
extensions
.
webextensions
.
protocol
.
remote
"
)
;
}
static
inline
ExtensionPolicyService
&
EPS
(
)
{
return
ExtensionPolicyService
:
:
GetSingleton
(
)
;
}
nsresult
ExtensionProtocolHandler
:
:
GetFlagsForURI
(
nsIURI
*
aURI
uint32_t
*
aFlags
)
{
uint32_t
flags
=
URI_STD
|
URI_IS_LOCAL_RESOURCE
|
URI_IS_POTENTIALLY_TRUSTWORTHY
;
URLInfo
url
(
aURI
)
;
if
(
auto
*
policy
=
EPS
(
)
.
GetByURL
(
url
)
)
{
if
(
policy
-
>
IsPathWebAccessible
(
url
.
FilePath
(
)
)
)
{
flags
|
=
URI_LOADABLE_BY_ANYONE
|
URI_FETCHABLE_BY_ANYONE
;
}
else
{
flags
|
=
URI_DANGEROUS_TO_LOAD
;
}
if
(
!
policy
-
>
PrivateBrowsingAllowed
(
)
)
{
flags
|
=
URI_DISALLOW_IN_PRIVATE_CONTEXT
;
}
}
else
{
flags
|
=
URI_DANGEROUS_TO_LOAD
;
}
*
aFlags
=
flags
;
return
NS_OK
;
}
bool
ExtensionProtocolHandler
:
:
ResolveSpecialCases
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aPathname
nsACString
&
aResult
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
"
The
ExtensionPolicyService
is
not
thread
safe
"
)
;
if
(
!
SubstitutingProtocolHandler
:
:
HasSubstitution
(
aHost
)
)
{
return
false
;
}
if
(
aPathname
.
EqualsLiteral
(
"
/
_generated_background_page
.
html
"
)
)
{
Unused
<
<
EPS
(
)
.
GetGeneratedBackgroundPageUrl
(
aHost
aResult
)
;
return
!
aResult
.
IsEmpty
(
)
;
}
return
false
;
}
Result
<
Ok
nsresult
>
ExtensionProtocolHandler
:
:
SubstituteRemoteChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
aRetVal
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
MOZ_TRY
(
aURI
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
MOZ_TRY
(
aLoadInfo
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
nsAutoCString
unResolvedSpec
;
MOZ_TRY
(
aURI
-
>
GetSpec
(
unResolvedSpec
)
)
;
nsAutoCString
resolvedSpec
;
MOZ_TRY
(
ResolveURI
(
aURI
resolvedSpec
)
)
;
nsAutoCString
scheme
;
MOZ_TRY
(
net_ExtractURLScheme
(
resolvedSpec
scheme
)
)
;
if
(
scheme
.
EqualsLiteral
(
"
file
"
)
)
{
SubstituteRemoteFileChannel
(
aURI
aLoadInfo
resolvedSpec
aRetVal
)
;
return
Ok
(
)
;
}
if
(
scheme
.
EqualsLiteral
(
"
jar
"
)
)
{
return
SubstituteRemoteJarChannel
(
aURI
aLoadInfo
resolvedSpec
aRetVal
)
;
}
return
Ok
(
)
;
}
void
OpenWhenReady
(
Promise
*
aPromise
nsIStreamListener
*
aListener
nsIChannel
*
aChannel
const
std
:
:
function
<
nsresult
(
nsIStreamListener
*
nsIChannel
*
)
>
&
aCallback
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
(
aListener
)
;
nsCOMPtr
<
nsIChannel
>
channel
(
aChannel
)
;
Unused
<
<
aPromise
-
>
ThenWithCycleCollectedArgs
(
[
channel
aCallback
]
(
JSContext
*
aCx
JS
:
:
HandleValue
aValue
nsIStreamListener
*
aListener
)
-
>
already_AddRefed
<
Promise
>
{
nsresult
rv
=
aCallback
(
aListener
channel
)
;
if
(
NS_FAILED
(
rv
)
)
{
ExtensionStreamGetter
:
:
CancelRequest
(
aListener
channel
rv
)
;
}
return
nullptr
;
}
listener
)
;
}
nsresult
ExtensionProtocolHandler
:
:
SubstituteChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
if
(
mUseRemoteFileChannels
)
{
MOZ_TRY
(
SubstituteRemoteChannel
(
aURI
aLoadInfo
result
)
)
;
}
auto
*
policy
=
EPS
(
)
.
GetByURL
(
aURI
)
;
NS_ENSURE_TRUE
(
policy
NS_ERROR_UNEXPECTED
)
;
RefPtr
<
dom
:
:
Promise
>
readyPromise
(
policy
-
>
ReadyPromise
(
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURL
>
url
=
do_QueryInterface
(
aURI
&
rv
)
;
MOZ_TRY
(
rv
)
;
nsAutoCString
ext
;
MOZ_TRY
(
url
-
>
GetFileExtension
(
ext
)
)
;
ToLowerCase
(
ext
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
ext
.
EqualsLiteral
(
"
css
"
)
)
{
static
const
auto
convert
=
[
]
(
nsIStreamListener
*
listener
nsIChannel
*
channel
nsIChannel
*
origChannel
)
-
>
nsresult
{
nsresult
rv
;
nsCOMPtr
<
nsIStreamConverterService
>
convService
=
do_GetService
(
NS_STREAMCONVERTERSERVICE_CONTRACTID
&
rv
)
;
MOZ_TRY
(
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_TRY
(
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
)
;
const
char
*
kFromType
=
"
application
/
vnd
.
mozilla
.
webext
.
unlocalized
"
;
const
char
*
kToType
=
"
text
/
css
"
;
nsCOMPtr
<
nsIStreamListener
>
converter
;
MOZ_TRY
(
convService
-
>
AsyncConvertData
(
kFromType
kToType
listener
uri
getter_AddRefs
(
converter
)
)
)
;
return
origChannel
-
>
AsyncOpen
(
converter
)
;
}
;
channel
=
NS_NewSimpleChannel
(
aURI
aLoadInfo
*
result
[
readyPromise
]
(
nsIStreamListener
*
listener
nsIChannel
*
channel
nsIChannel
*
origChannel
)
-
>
RequestOrReason
{
if
(
readyPromise
)
{
nsCOMPtr
<
nsIChannel
>
chan
(
channel
)
;
OpenWhenReady
(
readyPromise
listener
origChannel
[
chan
]
(
nsIStreamListener
*
aListener
nsIChannel
*
aChannel
)
{
return
convert
(
aListener
chan
aChannel
)
;
}
)
;
}
else
{
MOZ_TRY
(
convert
(
listener
channel
origChannel
)
)
;
}
return
RequestOrReason
(
origChannel
)
;
}
)
;
}
else
if
(
readyPromise
)
{
size_t
matchIdx
;
if
(
BinarySearchIf
(
sStaticFileExtensions
0
ArrayLength
(
sStaticFileExtensions
)
[
&
ext
]
(
const
char
*
aOther
)
{
return
ext
.
Compare
(
aOther
)
;
}
&
matchIdx
)
)
{
return
NS_OK
;
}
channel
=
NS_NewSimpleChannel
(
aURI
aLoadInfo
*
result
[
readyPromise
]
(
nsIStreamListener
*
listener
nsIChannel
*
channel
nsIChannel
*
origChannel
)
-
>
RequestOrReason
{
OpenWhenReady
(
readyPromise
listener
origChannel
[
]
(
nsIStreamListener
*
aListener
nsIChannel
*
aChannel
)
{
return
aChannel
-
>
AsyncOpen
(
aListener
)
;
}
)
;
return
RequestOrReason
(
origChannel
)
;
}
)
;
}
else
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
channel
NS_ERROR_OUT_OF_MEMORY
)
;
if
(
aLoadInfo
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
static_cast
<
LoadInfo
*
>
(
aLoadInfo
)
-
>
CloneForNewRequest
(
)
;
(
*
result
)
-
>
SetLoadInfo
(
loadInfo
)
;
}
channel
.
swap
(
*
result
)
;
return
NS_OK
;
}
Result
<
bool
nsresult
>
ExtensionProtocolHandler
:
:
AllowExternalResource
(
nsIFile
*
aExtensionDir
nsIFile
*
aRequestedFile
)
{
MOZ_ASSERT
(
!
IsNeckoChild
(
)
)
;
#
if
defined
(
XP_WIN
)
return
false
;
#
else
if
(
!
mozilla
:
:
IsDevelopmentBuild
(
)
)
{
return
false
;
}
bool
result
;
MOZ_TRY_VAR
(
result
AppDirContains
(
aExtensionDir
)
)
;
if
(
!
result
)
{
return
false
;
}
#
if
defined
(
XP_MACOSX
)
return
DevRepoContains
(
aRequestedFile
)
;
#
else
return
true
;
#
endif
#
endif
}
#
if
defined
(
XP_MACOSX
)
Result
<
bool
nsresult
>
ExtensionProtocolHandler
:
:
DevRepoContains
(
nsIFile
*
aRequestedFile
)
{
MOZ_ASSERT
(
mozilla
:
:
IsDevelopmentBuild
(
)
)
;
MOZ_ASSERT
(
!
IsNeckoChild
(
)
)
;
if
(
!
mAlreadyCheckedDevRepo
)
{
mAlreadyCheckedDevRepo
=
true
;
MOZ_TRY
(
nsMacUtilsImpl
:
:
GetRepoDir
(
getter_AddRefs
(
mDevRepo
)
)
)
;
if
(
MOZ_LOG_TEST
(
gExtProtocolLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
repoPath
;
Unused
<
<
mDevRepo
-
>
GetNativePath
(
repoPath
)
;
LOG
(
"
Repo
path
:
%
s
"
repoPath
.
get
(
)
)
;
}
}
bool
result
=
false
;
if
(
mDevRepo
)
{
MOZ_TRY
(
mDevRepo
-
>
Contains
(
aRequestedFile
&
result
)
)
;
}
return
result
;
}
#
endif
#
if
!
defined
(
XP_WIN
)
Result
<
bool
nsresult
>
ExtensionProtocolHandler
:
:
AppDirContains
(
nsIFile
*
aExtensionDir
)
{
MOZ_ASSERT
(
mozilla
:
:
IsDevelopmentBuild
(
)
)
;
MOZ_ASSERT
(
!
IsNeckoChild
(
)
)
;
if
(
!
mAlreadyCheckedAppDir
)
{
mAlreadyCheckedAppDir
=
true
;
MOZ_TRY
(
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
mAppDir
)
)
)
;
if
(
MOZ_LOG_TEST
(
gExtProtocolLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
appDirPath
;
Unused
<
<
mAppDir
-
>
GetNativePath
(
appDirPath
)
;
LOG
(
"
AppDir
path
:
%
s
"
appDirPath
.
get
(
)
)
;
}
}
bool
result
=
false
;
if
(
mAppDir
)
{
MOZ_TRY
(
mAppDir
-
>
Contains
(
aExtensionDir
&
result
)
)
;
}
return
result
;
}
#
endif
static
void
LogExternalResourceError
(
nsIFile
*
aExtensionDir
nsIFile
*
aRequestedFile
)
{
MOZ_ASSERT
(
aExtensionDir
)
;
MOZ_ASSERT
(
aRequestedFile
)
;
LOG
(
"
Rejecting
external
unpacked
extension
resource
[
%
s
]
from
"
"
extension
directory
[
%
s
]
"
aRequestedFile
-
>
HumanReadablePath
(
)
.
get
(
)
aExtensionDir
-
>
HumanReadablePath
(
)
.
get
(
)
)
;
}
Result
<
nsCOMPtr
<
nsIInputStream
>
nsresult
>
ExtensionProtocolHandler
:
:
NewStream
(
nsIURI
*
aChildURI
bool
*
aTerminateSender
)
{
MOZ_ASSERT
(
!
IsNeckoChild
(
)
)
;
MOZ_TRY
(
aChildURI
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
MOZ_TRY
(
aTerminateSender
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
*
aTerminateSender
=
true
;
nsresult
rv
;
if
(
!
aChildURI
-
>
SchemeIs
(
EXTENSION_SCHEME
)
)
{
return
Err
(
NS_ERROR_UNKNOWN_PROTOCOL
)
;
}
*
aTerminateSender
=
false
;
nsAutoCString
host
;
MOZ_TRY
(
aChildURI
-
>
GetAsciiHost
(
host
)
)
;
nsCOMPtr
<
nsIURI
>
baseURI
;
MOZ_TRY
(
GetSubstitution
(
host
getter_AddRefs
(
baseURI
)
)
)
;
nsCOMPtr
<
nsIFileURL
>
fileURL
=
do_QueryInterface
(
baseURI
&
rv
)
;
MOZ_TRY
(
rv
)
;
nsCOMPtr
<
nsIFile
>
extensionDir
;
MOZ_TRY
(
fileURL
-
>
GetFile
(
getter_AddRefs
(
extensionDir
)
)
)
;
bool
isDirectory
=
false
;
MOZ_TRY
(
extensionDir
-
>
IsDirectory
(
&
isDirectory
)
)
;
if
(
!
isDirectory
)
{
return
Err
(
NS_ERROR_FILE_NOT_DIRECTORY
)
;
}
nsAutoCString
resolvedSpec
;
MOZ_TRY
(
ResolveURI
(
aChildURI
resolvedSpec
)
)
;
nsAutoCString
resolvedScheme
;
MOZ_TRY
(
net_ExtractURLScheme
(
resolvedSpec
resolvedScheme
)
)
;
if
(
!
resolvedScheme
.
EqualsLiteral
(
"
file
"
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
nsCOMPtr
<
nsIIOService
>
ioService
=
do_GetIOService
(
&
rv
)
;
MOZ_TRY
(
rv
)
;
nsCOMPtr
<
nsIURI
>
resolvedURI
;
MOZ_TRY
(
ioService
-
>
NewURI
(
resolvedSpec
nullptr
nullptr
getter_AddRefs
(
resolvedURI
)
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
MOZ_TRY
(
NS_NewChannel
(
getter_AddRefs
(
channel
)
resolvedURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
)
)
;
nsCOMPtr
<
nsIFileChannel
>
fileChannel
=
do_QueryInterface
(
channel
&
rv
)
;
MOZ_TRY
(
rv
)
;
nsCOMPtr
<
nsIFile
>
requestedFile
;
MOZ_TRY
(
fileChannel
-
>
GetFile
(
getter_AddRefs
(
requestedFile
)
)
)
;
MOZ_TRY
(
extensionDir
-
>
Normalize
(
)
)
;
MOZ_TRY
(
requestedFile
-
>
Normalize
(
)
)
;
#
if
defined
(
XP_WIN
)
if
(
!
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
extensionDir
)
|
|
!
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
requestedFile
)
)
{
return
Err
(
NS_ERROR_FILE_ACCESS_DENIED
)
;
}
#
endif
bool
isResourceFromExtensionDir
=
false
;
MOZ_TRY
(
extensionDir
-
>
Contains
(
requestedFile
&
isResourceFromExtensionDir
)
)
;
if
(
!
isResourceFromExtensionDir
)
{
bool
isAllowed
;
MOZ_TRY_VAR
(
isAllowed
AllowExternalResource
(
extensionDir
requestedFile
)
)
;
if
(
!
isAllowed
)
{
LogExternalResourceError
(
extensionDir
requestedFile
)
;
return
Err
(
NS_ERROR_FILE_ACCESS_DENIED
)
;
}
}
nsCOMPtr
<
nsIInputStream
>
inputStream
;
MOZ_TRY_VAR
(
inputStream
NS_NewLocalFileInputStream
(
requestedFile
PR_RDONLY
-
1
nsIFileInputStream
:
:
DEFER_OPEN
)
)
;
return
inputStream
;
}
Result
<
Ok
nsresult
>
ExtensionProtocolHandler
:
:
NewFD
(
nsIURI
*
aChildURI
bool
*
aTerminateSender
NeckoParent
:
:
GetExtensionFDResolver
&
aResolve
)
{
MOZ_ASSERT
(
!
IsNeckoChild
(
)
)
;
MOZ_TRY
(
aChildURI
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
MOZ_TRY
(
aTerminateSender
?
NS_OK
:
NS_ERROR_INVALID_ARG
)
;
*
aTerminateSender
=
true
;
nsresult
rv
;
if
(
!
aChildURI
-
>
SchemeIs
(
EXTENSION_SCHEME
)
)
{
return
Err
(
NS_ERROR_UNKNOWN_PROTOCOL
)
;
}
*
aTerminateSender
=
false
;
nsAutoCString
host
;
MOZ_TRY
(
aChildURI
-
>
GetAsciiHost
(
host
)
)
;
nsCOMPtr
<
nsIURI
>
subURI
;
MOZ_TRY
(
GetSubstitution
(
host
getter_AddRefs
(
subURI
)
)
)
;
nsCOMPtr
<
nsIJARURI
>
jarURI
=
do_QueryInterface
(
subURI
&
rv
)
;
MOZ_TRY
(
rv
)
;
nsCOMPtr
<
nsIURI
>
innerFileURI
;
MOZ_TRY
(
jarURI
-
>
GetJARFile
(
getter_AddRefs
(
innerFileURI
)
)
)
;
nsCOMPtr
<
nsIFileURL
>
innerFileURL
=
do_QueryInterface
(
innerFileURI
&
rv
)
;
MOZ_TRY
(
rv
)
;
nsCOMPtr
<
nsIFile
>
jarFile
;
MOZ_TRY
(
innerFileURL
-
>
GetFile
(
getter_AddRefs
(
jarFile
)
)
)
;
if
(
!
mFileOpenerThread
)
{
mFileOpenerThread
=
new
LazyIdleThread
(
DEFAULT_THREAD_TIMEOUT_MS
"
ExtensionProtocolHandler
"
_ns
)
;
}
RefPtr
<
ExtensionJARFileOpener
>
fileOpener
=
new
ExtensionJARFileOpener
(
jarFile
aResolve
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
mozilla
:
:
NewRunnableMethod
(
"
ExtensionJarFileOpener
"
fileOpener
&
ExtensionJARFileOpener
:
:
OpenFile
)
;
MOZ_TRY
(
mFileOpenerThread
-
>
Dispatch
(
event
nsIEventTarget
:
:
DISPATCH_NORMAL
)
)
;
return
Ok
(
)
;
}
void
ExtensionProtocolHandler
:
:
SetContentType
(
nsIURI
*
aURI
nsIChannel
*
aChannel
)
{
nsresult
rv
;
nsCOMPtr
<
nsIMIMEService
>
mime
=
do_GetService
(
"
mozilla
.
org
/
mime
;
1
"
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
contentType
;
rv
=
mime
-
>
GetTypeFromURI
(
aURI
contentType
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
Unused
<
<
aChannel
-
>
SetContentType
(
contentType
)
;
}
}
}
void
ExtensionProtocolHandler
:
:
NewSimpleChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadinfo
ExtensionStreamGetter
*
aStreamGetter
nsIChannel
*
*
aRetVal
)
{
nsCOMPtr
<
nsIChannel
>
channel
=
NS_NewSimpleChannel
(
aURI
aLoadinfo
aStreamGetter
[
]
(
nsIStreamListener
*
listener
nsIChannel
*
simpleChannel
ExtensionStreamGetter
*
getter
)
-
>
RequestOrReason
{
MOZ_TRY
(
getter
-
>
GetAsync
(
listener
simpleChannel
)
)
;
return
RequestOrReason
(
nullptr
)
;
}
)
;
SetContentType
(
aURI
channel
)
;
channel
.
swap
(
*
aRetVal
)
;
}
void
ExtensionProtocolHandler
:
:
NewSimpleChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadinfo
nsIChannel
*
aChannel
nsIChannel
*
*
aRetVal
)
{
nsCOMPtr
<
nsIChannel
>
channel
=
NS_NewSimpleChannel
(
aURI
aLoadinfo
aChannel
[
]
(
nsIStreamListener
*
listener
nsIChannel
*
simpleChannel
nsIChannel
*
origChannel
)
-
>
RequestOrReason
{
nsresult
rv
=
origChannel
-
>
AsyncOpen
(
listener
)
;
if
(
NS_FAILED
(
rv
)
)
{
simpleChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
return
Err
(
rv
)
;
}
return
RequestOrReason
(
origChannel
)
;
}
)
;
SetContentType
(
aURI
channel
)
;
channel
.
swap
(
*
aRetVal
)
;
}
void
ExtensionProtocolHandler
:
:
SubstituteRemoteFileChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadinfo
nsACString
&
aResolvedFileSpec
nsIChannel
*
*
aRetVal
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
RefPtr
<
ExtensionStreamGetter
>
streamGetter
=
new
ExtensionStreamGetter
(
aURI
aLoadinfo
)
;
NewSimpleChannel
(
aURI
aLoadinfo
streamGetter
aRetVal
)
;
}
static
Result
<
Ok
nsresult
>
LogCacheCheck
(
const
nsIJARChannel
*
aJarChannel
nsIJARURI
*
aJarURI
bool
aIsCached
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
innerFileURI
;
MOZ_TRY
(
aJarURI
-
>
GetJARFile
(
getter_AddRefs
(
innerFileURI
)
)
)
;
nsCOMPtr
<
nsIFileURL
>
innerFileURL
=
do_QueryInterface
(
innerFileURI
&
rv
)
;
MOZ_TRY
(
rv
)
;
nsCOMPtr
<
nsIFile
>
jarFile
;
MOZ_TRY
(
innerFileURL
-
>
GetFile
(
getter_AddRefs
(
jarFile
)
)
)
;
nsAutoCString
uriSpec
jarSpec
;
Unused
<
<
aJarURI
-
>
GetSpec
(
uriSpec
)
;
Unused
<
<
innerFileURI
-
>
GetSpec
(
jarSpec
)
;
LOG
(
"
[
JARChannel
%
p
]
Cache
%
s
:
%
s
(
%
s
)
"
aJarChannel
aIsCached
?
"
hit
"
:
"
miss
"
uriSpec
.
get
(
)
jarSpec
.
get
(
)
)
;
return
Ok
(
)
;
}
Result
<
Ok
nsresult
>
ExtensionProtocolHandler
:
:
SubstituteRemoteJarChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadinfo
nsACString
&
aResolvedSpec
nsIChannel
*
*
aRetVal
)
{
MOZ_ASSERT
(
IsNeckoChild
(
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_TRY
(
NS_NewURI
(
getter_AddRefs
(
uri
)
aResolvedSpec
)
)
;
nsCOMPtr
<
nsIJARURI
>
jarURI
=
do_QueryInterface
(
uri
&
rv
)
;
MOZ_TRY
(
rv
)
;
nsCOMPtr
<
nsIJARChannel
>
jarChannel
=
do_QueryInterface
(
*
aRetVal
&
rv
)
;
MOZ_TRY
(
rv
)
;
bool
isCached
=
false
;
MOZ_TRY
(
jarChannel
-
>
EnsureCached
(
&
isCached
)
)
;
if
(
MOZ_LOG_TEST
(
gExtProtocolLog
LogLevel
:
:
Debug
)
)
{
Unused
<
<
LogCacheCheck
(
jarChannel
jarURI
isCached
)
;
}
if
(
isCached
)
{
NewSimpleChannel
(
aURI
aLoadinfo
jarChannel
.
get
(
)
aRetVal
)
;
return
Ok
(
)
;
}
nsCOMPtr
<
nsIURI
>
innerFileURI
;
MOZ_TRY
(
jarURI
-
>
GetJARFile
(
getter_AddRefs
(
innerFileURI
)
)
)
;
nsCOMPtr
<
nsIFileURL
>
innerFileURL
=
do_QueryInterface
(
innerFileURI
&
rv
)
;
MOZ_TRY
(
rv
)
;
nsCOMPtr
<
nsIFile
>
jarFile
;
MOZ_TRY
(
innerFileURL
-
>
GetFile
(
getter_AddRefs
(
jarFile
)
)
)
;
RefPtr
<
ExtensionStreamGetter
>
streamGetter
=
new
ExtensionStreamGetter
(
aURI
aLoadinfo
jarChannel
.
forget
(
)
jarFile
)
;
NewSimpleChannel
(
aURI
aLoadinfo
streamGetter
aRetVal
)
;
return
Ok
(
)
;
}
}
}
