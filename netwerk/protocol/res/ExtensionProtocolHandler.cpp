#
include
"
ExtensionProtocolHandler
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
LoadInfo
.
h
"
#
include
"
SimpleChannel
.
h
"
namespace
mozilla
{
namespace
net
{
using
extensions
:
:
URLInfo
;
NS_IMPL_QUERY_INTERFACE
(
ExtensionProtocolHandler
nsISubstitutingProtocolHandler
nsIProtocolHandler
nsIProtocolHandlerWithDynamicFlags
nsISupportsWeakReference
)
NS_IMPL_ADDREF_INHERITED
(
ExtensionProtocolHandler
SubstitutingProtocolHandler
)
NS_IMPL_RELEASE_INHERITED
(
ExtensionProtocolHandler
SubstitutingProtocolHandler
)
static
inline
ExtensionPolicyService
&
EPS
(
)
{
return
ExtensionPolicyService
:
:
GetSingleton
(
)
;
}
nsresult
ExtensionProtocolHandler
:
:
GetFlagsForURI
(
nsIURI
*
aURI
uint32_t
*
aFlags
)
{
bool
loadableByAnyone
=
false
;
URLInfo
url
(
aURI
)
;
if
(
auto
*
policy
=
EPS
(
)
.
GetByURL
(
url
)
)
{
loadableByAnyone
=
policy
-
>
IsPathWebAccessible
(
url
.
FilePath
(
)
)
;
}
*
aFlags
=
URI_STD
|
URI_IS_LOCAL_RESOURCE
|
(
loadableByAnyone
?
(
URI_LOADABLE_BY_ANYONE
|
URI_FETCHABLE_BY_ANYONE
)
:
URI_DANGEROUS_TO_LOAD
)
;
return
NS_OK
;
}
bool
ExtensionProtocolHandler
:
:
ResolveSpecialCases
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aPathname
nsACString
&
aResult
)
{
if
(
!
SubstitutingProtocolHandler
:
:
HasSubstitution
(
aHost
)
)
{
return
false
;
}
if
(
aPathname
.
EqualsLiteral
(
"
/
_blank
.
html
"
)
)
{
aResult
.
AssignLiteral
(
"
about
:
blank
"
)
;
return
true
;
}
if
(
aPathname
.
EqualsLiteral
(
"
/
_generated_background_page
.
html
"
)
)
{
Unused
<
<
EPS
(
)
.
GetGeneratedBackgroundPageUrl
(
aHost
aResult
)
;
return
!
aResult
.
IsEmpty
(
)
;
}
return
false
;
}
static
inline
Result
<
Ok
nsresult
>
WrapNSResult
(
nsresult
aRv
)
{
if
(
NS_FAILED
(
aRv
)
)
{
return
Err
(
aRv
)
;
}
return
Ok
(
)
;
}
#
define
NS_TRY
(
expr
)
MOZ_TRY
(
WrapNSResult
(
expr
)
)
nsresult
ExtensionProtocolHandler
:
:
SubstituteChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURL
>
url
=
do_QueryInterface
(
aURI
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
ext
;
rv
=
url
-
>
GetFileExtension
(
ext
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
ext
.
LowerCaseEqualsLiteral
(
"
css
"
)
)
{
return
NS_OK
;
}
bool
haveLoadInfo
=
aLoadInfo
;
nsCOMPtr
<
nsIChannel
>
channel
=
NS_NewSimpleChannel
(
aURI
aLoadInfo
*
result
[
haveLoadInfo
]
(
nsIStreamListener
*
listener
nsIChannel
*
channel
nsIChannel
*
origChannel
)
-
>
RequestOrReason
{
nsresult
rv
;
nsCOMPtr
<
nsIStreamConverterService
>
convService
=
do_GetService
(
NS_STREAMCONVERTERSERVICE_CONTRACTID
&
rv
)
;
NS_TRY
(
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
NS_TRY
(
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
)
;
const
char
*
kFromType
=
"
application
/
vnd
.
mozilla
.
webext
.
unlocalized
"
;
const
char
*
kToType
=
"
text
/
css
"
;
nsCOMPtr
<
nsIStreamListener
>
converter
;
NS_TRY
(
convService
-
>
AsyncConvertData
(
kFromType
kToType
listener
uri
getter_AddRefs
(
converter
)
)
)
;
if
(
haveLoadInfo
)
{
NS_TRY
(
origChannel
-
>
AsyncOpen2
(
converter
)
)
;
}
else
{
NS_TRY
(
origChannel
-
>
AsyncOpen
(
converter
nullptr
)
)
;
}
return
RequestOrReason
(
origChannel
)
;
}
)
;
NS_ENSURE_TRUE
(
channel
NS_ERROR_OUT_OF_MEMORY
)
;
if
(
aLoadInfo
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
static_cast
<
LoadInfo
*
>
(
aLoadInfo
)
-
>
CloneForNewRequest
(
)
;
(
*
result
)
-
>
SetLoadInfo
(
loadInfo
)
;
}
channel
.
swap
(
*
result
)
;
return
NS_OK
;
}
#
undef
NS_TRY
}
}
