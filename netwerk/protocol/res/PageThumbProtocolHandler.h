#
ifndef
PageThumbProtocolHandler_h___
#
define
PageThumbProtocolHandler_h___
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
SubstitutingProtocolHandler
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsWeakReference
.
h
"
namespace
mozilla
{
namespace
net
{
using
PageThumbStreamPromise
=
mozilla
:
:
MozPromise
<
nsCOMPtr
<
nsIInputStream
>
nsresult
false
>
;
class
PageThumbStreamGetter
;
class
PageThumbProtocolHandler
final
:
public
nsISubstitutingProtocolHandler
public
nsIProtocolHandlerWithDynamicFlags
public
SubstitutingProtocolHandler
public
nsSupportsWeakReference
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIPROTOCOLHANDLERWITHDYNAMICFLAGS
NS_FORWARD_NSIPROTOCOLHANDLER
(
SubstitutingProtocolHandler
:
:
)
NS_FORWARD_NSISUBSTITUTINGPROTOCOLHANDLER
(
SubstitutingProtocolHandler
:
:
)
static
already_AddRefed
<
PageThumbProtocolHandler
>
GetSingleton
(
)
;
RefPtr
<
PageThumbStreamPromise
>
NewStream
(
nsIURI
*
aChildURI
bool
*
aTerminateSender
)
;
protected
:
~
PageThumbProtocolHandler
(
)
=
default
;
private
:
explicit
PageThumbProtocolHandler
(
)
;
[
[
nodiscard
]
]
bool
ResolveSpecialCases
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aPathname
nsACString
&
aResult
)
override
;
[
[
nodiscard
]
]
virtual
nsresult
SubstituteChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
aRetVal
)
override
;
Result
<
Ok
nsresult
>
SubstituteRemoteChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
aRetVal
)
;
nsresult
GetThumbnailPath
(
const
nsACString
&
aPath
nsString
&
aThumbnailPath
)
;
static
StaticRefPtr
<
PageThumbProtocolHandler
>
sSingleton
;
static
void
SetContentType
(
nsIURI
*
aURI
nsIChannel
*
aChannel
)
;
static
void
NewSimpleChannel
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadinfo
PageThumbStreamGetter
*
aStreamGetter
nsIChannel
*
*
aRetVal
)
;
}
;
}
}
#
endif
