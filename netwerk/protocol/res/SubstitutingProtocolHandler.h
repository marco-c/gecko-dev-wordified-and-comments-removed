#
ifndef
SubstitutingProtocolHandler_h___
#
define
SubstitutingProtocolHandler_h___
#
include
"
nsISubstitutingProtocolHandler
.
h
"
#
include
"
nsInterfaceHashtable
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsStandardURL
.
h
"
#
include
"
mozilla
/
chrome
/
RegistryMessageUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
class
nsIIOService
;
namespace
mozilla
{
namespace
net
{
class
SubstitutingProtocolHandler
{
public
:
SubstitutingProtocolHandler
(
const
char
*
aScheme
uint32_t
aFlags
bool
aEnforceFileOrJar
=
true
)
;
explicit
SubstitutingProtocolHandler
(
const
char
*
aScheme
)
;
NS_INLINE_DECL_REFCOUNTING
(
SubstitutingProtocolHandler
)
;
NS_DECL_NON_VIRTUAL_NSIPROTOCOLHANDLER
;
NS_DECL_NON_VIRTUAL_NSISUBSTITUTINGPROTOCOLHANDLER
;
bool
HasSubstitution
(
const
nsACString
&
aRoot
)
const
{
return
mSubstitutions
.
Get
(
aRoot
nullptr
)
;
}
void
CollectSubstitutions
(
InfallibleTArray
<
SubstitutionMapping
>
&
aResources
)
;
protected
:
virtual
~
SubstitutingProtocolHandler
(
)
{
}
void
ConstructInternal
(
)
;
void
SendSubstitution
(
const
nsACString
&
aRoot
nsIURI
*
aBaseURI
)
;
virtual
nsresult
GetSubstitutionInternal
(
const
nsACString
&
aRoot
nsIURI
*
*
aResult
)
{
*
aResult
=
nullptr
;
return
NS_ERROR_NOT_AVAILABLE
;
}
virtual
bool
ResolveSpecialCases
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aPathname
nsACString
&
aResult
)
{
return
false
;
}
virtual
nsresult
SubstituteChannel
(
nsIURI
*
uri
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
return
NS_OK
;
}
nsIIOService
*
IOService
(
)
{
return
mIOService
;
}
private
:
nsCString
mScheme
;
Maybe
<
uint32_t
>
mFlags
;
nsInterfaceHashtable
<
nsCStringHashKey
nsIURI
>
mSubstitutions
;
nsCOMPtr
<
nsIIOService
>
mIOService
;
bool
mEnforceFileOrJar
;
}
;
class
SubstitutingURL
:
public
nsStandardURL
{
public
:
SubstitutingURL
(
)
:
nsStandardURL
(
true
)
{
}
virtual
nsStandardURL
*
StartClone
(
)
;
virtual
nsresult
EnsureFile
(
)
;
NS_IMETHOD
GetClassIDNoAlloc
(
nsCID
*
aCID
)
;
}
;
}
}
#
endif
