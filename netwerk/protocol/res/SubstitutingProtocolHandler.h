#
ifndef
SubstitutingProtocolHandler_h___
#
define
SubstitutingProtocolHandler_h___
#
include
"
nsISubstitutingProtocolHandler
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsStandardURL
.
h
"
#
include
"
nsJARURI
.
h
"
#
include
"
mozilla
/
chrome
/
RegistryMessageUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RWLock
.
h
"
class
nsIIOService
;
namespace
mozilla
{
namespace
net
{
class
SubstitutingProtocolHandler
{
public
:
SubstitutingProtocolHandler
(
const
char
*
aScheme
uint32_t
aFlags
bool
aEnforceFileOrJar
=
true
)
;
explicit
SubstitutingProtocolHandler
(
const
char
*
aScheme
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SubstitutingProtocolHandler
)
;
NS_DECL_NON_VIRTUAL_NSIPROTOCOLHANDLER
;
NS_DECL_NON_VIRTUAL_NSISUBSTITUTINGPROTOCOLHANDLER
;
bool
HasSubstitution
(
const
nsACString
&
aRoot
)
const
{
AutoReadLock
lock
(
const_cast
<
RWLock
&
>
(
mSubstitutionsLock
)
)
;
return
mSubstitutions
.
Get
(
aRoot
nullptr
)
;
}
nsresult
NewURI
(
const
nsACString
&
aSpec
const
char
*
aCharset
nsIURI
*
aBaseURI
nsIURI
*
*
aResult
)
;
[
[
nodiscard
]
]
nsresult
CollectSubstitutions
(
nsTArray
<
SubstitutionMapping
>
&
aMappings
)
;
protected
:
virtual
~
SubstitutingProtocolHandler
(
)
=
default
;
void
ConstructInternal
(
)
;
[
[
nodiscard
]
]
nsresult
SendSubstitution
(
const
nsACString
&
aRoot
nsIURI
*
aBaseURI
uint32_t
aFlags
)
;
nsresult
GetSubstitutionFlags
(
const
nsACString
&
root
uint32_t
*
flags
)
;
[
[
nodiscard
]
]
virtual
nsresult
GetSubstitutionInternal
(
const
nsACString
&
aRoot
nsIURI
*
*
aResult
uint32_t
*
aFlags
)
{
*
aResult
=
nullptr
;
*
aFlags
=
0
;
return
NS_ERROR_NOT_AVAILABLE
;
}
[
[
nodiscard
]
]
virtual
bool
ResolveSpecialCases
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aPathname
nsACString
&
aResult
)
{
return
false
;
}
[
[
nodiscard
]
]
virtual
bool
MustResolveJAR
(
const
nsACString
&
aRoot
)
{
return
false
;
}
[
[
nodiscard
]
]
virtual
nsresult
SubstituteChannel
(
nsIURI
*
uri
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
return
NS_OK
;
}
nsIIOService
*
IOService
(
)
{
return
mIOService
;
}
private
:
struct
SubstitutionEntry
{
nsCOMPtr
<
nsIURI
>
baseURI
;
uint32_t
flags
=
0
;
}
;
void
NotifyObservers
(
const
nsACString
&
aRoot
nsIURI
*
aBaseURI
)
;
nsCString
mScheme
;
Maybe
<
uint32_t
>
mFlags
;
RWLock
mSubstitutionsLock
;
nsTHashMap
<
nsCStringHashKey
SubstitutionEntry
>
mSubstitutions
GUARDED_BY
(
mSubstitutionsLock
)
;
nsCOMPtr
<
nsIIOService
>
mIOService
;
nsresult
ResolveJARURI
(
nsIURL
*
aURL
nsIURI
*
*
aResult
)
;
bool
mEnforceFileOrJar
;
}
;
}
}
#
endif
