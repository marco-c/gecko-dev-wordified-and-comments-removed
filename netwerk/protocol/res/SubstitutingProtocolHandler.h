#
ifndef
SubstitutingProtocolHandler_h___
#
define
SubstitutingProtocolHandler_h___
#
include
"
nsISubstitutingProtocolHandler
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsISubstitutionObserver
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsStandardURL
.
h
"
#
include
"
mozilla
/
chrome
/
RegistryMessageUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
class
nsIIOService
;
namespace
mozilla
{
namespace
net
{
class
SubstitutingProtocolHandler
{
public
:
SubstitutingProtocolHandler
(
const
char
*
aScheme
uint32_t
aFlags
bool
aEnforceFileOrJar
=
true
)
;
explicit
SubstitutingProtocolHandler
(
const
char
*
aScheme
)
;
NS_INLINE_DECL_REFCOUNTING
(
SubstitutingProtocolHandler
)
;
NS_DECL_NON_VIRTUAL_NSIPROTOCOLHANDLER
;
NS_DECL_NON_VIRTUAL_NSISUBSTITUTINGPROTOCOLHANDLER
;
bool
HasSubstitution
(
const
nsACString
&
aRoot
)
const
{
return
mSubstitutions
.
Get
(
aRoot
nullptr
)
;
}
MOZ_MUST_USE
nsresult
CollectSubstitutions
(
InfallibleTArray
<
SubstitutionMapping
>
&
aResources
)
;
protected
:
virtual
~
SubstitutingProtocolHandler
(
)
=
default
;
void
ConstructInternal
(
)
;
MOZ_MUST_USE
nsresult
SendSubstitution
(
const
nsACString
&
aRoot
nsIURI
*
aBaseURI
uint32_t
aFlags
)
;
nsresult
GetSubstitutionFlags
(
const
nsACString
&
root
uint32_t
*
flags
)
;
virtual
MOZ_MUST_USE
nsresult
GetSubstitutionInternal
(
const
nsACString
&
aRoot
nsIURI
*
*
aResult
uint32_t
*
aFlags
)
{
*
aResult
=
nullptr
;
*
aFlags
=
0
;
return
NS_ERROR_NOT_AVAILABLE
;
}
virtual
MOZ_MUST_USE
bool
ResolveSpecialCases
(
const
nsACString
&
aHost
const
nsACString
&
aPath
const
nsACString
&
aPathname
nsACString
&
aResult
)
{
return
false
;
}
virtual
MOZ_MUST_USE
nsresult
SubstituteChannel
(
nsIURI
*
uri
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
return
NS_OK
;
}
nsIIOService
*
IOService
(
)
{
return
mIOService
;
}
private
:
struct
SubstitutionEntry
{
SubstitutionEntry
(
)
:
flags
(
0
)
{
}
~
SubstitutionEntry
(
)
=
default
;
nsCOMPtr
<
nsIURI
>
baseURI
;
uint32_t
flags
;
}
;
void
NotifyObservers
(
const
nsACString
&
aRoot
nsIURI
*
aBaseURI
)
;
nsCString
mScheme
;
Maybe
<
uint32_t
>
mFlags
;
nsDataHashtable
<
nsCStringHashKey
SubstitutionEntry
>
mSubstitutions
;
nsCOMPtr
<
nsIIOService
>
mIOService
;
nsTArray
<
nsCOMPtr
<
nsISubstitutionObserver
>
>
mObservers
;
bool
mEnforceFileOrJar
;
}
;
class
SubstitutingURL
:
public
nsStandardURL
{
public
:
virtual
nsStandardURL
*
StartClone
(
)
override
;
virtual
MOZ_MUST_USE
nsresult
EnsureFile
(
)
override
;
NS_IMETHOD
GetClassIDNoAlloc
(
nsCID
*
aCID
)
override
;
private
:
explicit
SubstitutingURL
(
)
:
nsStandardURL
(
true
)
{
}
explicit
SubstitutingURL
(
bool
aSupportsFileURL
)
:
nsStandardURL
(
true
)
{
MOZ_ASSERT
(
aSupportsFileURL
)
;
}
virtual
nsresult
Clone
(
nsIURI
*
*
aURI
)
override
{
return
nsStandardURL
:
:
Clone
(
aURI
)
;
}
public
:
class
Mutator
:
public
TemplatedMutator
<
SubstitutingURL
>
{
NS_DECL_ISUPPORTS
public
:
explicit
Mutator
(
)
=
default
;
private
:
virtual
~
Mutator
(
)
=
default
;
SubstitutingURL
*
Create
(
)
override
{
return
new
SubstitutingURL
(
)
;
}
}
;
NS_IMETHOD
Mutate
(
nsIURIMutator
*
*
aMutator
)
override
{
RefPtr
<
SubstitutingURL
:
:
Mutator
>
mutator
=
new
SubstitutingURL
:
:
Mutator
(
)
;
nsresult
rv
=
mutator
-
>
InitFromURI
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mutator
.
forget
(
aMutator
)
;
return
NS_OK
;
}
friend
BaseURIMutator
<
SubstitutingURL
>
;
friend
TemplatedMutator
<
SubstitutingURL
>
;
}
;
}
}
#
endif
