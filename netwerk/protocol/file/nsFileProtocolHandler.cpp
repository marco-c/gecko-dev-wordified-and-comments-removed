#
include
"
nsIFile
.
h
"
#
include
"
nsFileProtocolHandler
.
h
"
#
include
"
nsFileChannel
.
h
"
#
include
"
nsStandardURL
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
FileChannelChild
.
h
"
#
ifdef
XP_WIN
#
include
<
shlobj
.
h
>
#
include
<
intshcut
.
h
>
#
include
"
nsIFileURL
.
h
"
#
ifdef
CompareString
#
undef
CompareString
#
endif
#
endif
#
ifdef
XP_UNIX
#
include
"
nsINIParser
.
h
"
#
define
DESKTOP_ENTRY_SECTION
"
Desktop
Entry
"
#
endif
nsresult
nsFileProtocolHandler
:
:
Init
(
)
{
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsFileProtocolHandler
nsIFileProtocolHandler
nsIProtocolHandler
nsISupportsWeakReference
)
#
if
defined
(
XP_WIN
)
NS_IMETHODIMP
nsFileProtocolHandler
:
:
ReadURLFile
(
nsIFile
*
aFile
nsIURI
*
*
aURI
)
{
nsAutoString
path
;
nsresult
rv
=
aFile
-
>
GetPath
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
path
.
Length
(
)
<
4
)
return
NS_ERROR_NOT_AVAILABLE
;
if
(
!
StringTail
(
path
4
)
.
LowerCaseEqualsLiteral
(
"
.
url
"
)
)
return
NS_ERROR_NOT_AVAILABLE
;
HRESULT
result
;
rv
=
NS_ERROR_NOT_AVAILABLE
;
IUniformResourceLocatorW
*
urlLink
=
nullptr
;
result
=
:
:
CoCreateInstance
(
CLSID_InternetShortcut
nullptr
CLSCTX_INPROC_SERVER
IID_IUniformResourceLocatorW
(
void
*
*
)
&
urlLink
)
;
if
(
SUCCEEDED
(
result
)
&
&
urlLink
)
{
IPersistFile
*
urlFile
=
nullptr
;
result
=
urlLink
-
>
QueryInterface
(
IID_IPersistFile
(
void
*
*
)
&
urlFile
)
;
if
(
SUCCEEDED
(
result
)
&
&
urlFile
)
{
result
=
urlFile
-
>
Load
(
path
.
get
(
)
STGM_READ
)
;
if
(
SUCCEEDED
(
result
)
)
{
LPWSTR
lpTemp
=
nullptr
;
result
=
urlLink
-
>
GetURL
(
&
lpTemp
)
;
if
(
SUCCEEDED
(
result
)
&
&
lpTemp
)
{
rv
=
NS_NewURI
(
aURI
nsDependentString
(
lpTemp
)
)
;
CoTaskMemFree
(
lpTemp
)
;
}
}
urlFile
-
>
Release
(
)
;
}
urlLink
-
>
Release
(
)
;
}
return
rv
;
}
#
elif
defined
(
XP_UNIX
)
NS_IMETHODIMP
nsFileProtocolHandler
:
:
ReadURLFile
(
nsIFile
*
aFile
nsIURI
*
*
aURI
)
{
nsAutoCString
leafName
;
nsresult
rv
=
aFile
-
>
GetNativeLeafName
(
leafName
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
StringEndsWith
(
leafName
NS_LITERAL_CSTRING
(
"
.
desktop
"
)
)
)
return
NS_ERROR_NOT_AVAILABLE
;
bool
isFile
=
false
;
rv
=
aFile
-
>
IsFile
(
&
isFile
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
isFile
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsINIParser
parser
;
rv
=
parser
.
Init
(
aFile
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsAutoCString
type
;
parser
.
GetString
(
DESKTOP_ENTRY_SECTION
"
Type
"
type
)
;
if
(
!
type
.
EqualsLiteral
(
"
Link
"
)
)
return
NS_ERROR_NOT_AVAILABLE
;
nsAutoCString
url
;
rv
=
parser
.
GetString
(
DESKTOP_ENTRY_SECTION
"
URL
"
url
)
;
if
(
NS_FAILED
(
rv
)
|
|
url
.
IsEmpty
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
return
NS_NewURI
(
aURI
url
)
;
}
#
else
NS_IMETHODIMP
nsFileProtocolHandler
:
:
ReadURLFile
(
nsIFile
*
aFile
nsIURI
*
*
aURI
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
#
endif
NS_IMETHODIMP
nsFileProtocolHandler
:
:
GetScheme
(
nsACString
&
result
)
{
result
.
AssignLiteral
(
"
file
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFileProtocolHandler
:
:
GetDefaultPort
(
int32_t
*
result
)
{
*
result
=
-
1
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFileProtocolHandler
:
:
GetProtocolFlags
(
uint32_t
*
result
)
{
*
result
=
URI_NOAUTH
|
URI_IS_LOCAL_FILE
|
URI_IS_LOCAL_RESOURCE
|
URI_IS_POTENTIALLY_TRUSTWORTHY
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFileProtocolHandler
:
:
NewURI
(
const
nsACString
&
spec
const
char
*
charset
nsIURI
*
aBaseURI
nsIURI
*
*
result
)
{
nsAutoCString
buf
(
spec
)
;
#
if
defined
(
XP_WIN
)
buf
.
Truncate
(
)
;
if
(
!
net_NormalizeFileURL
(
spec
buf
)
)
{
buf
=
spec
;
}
#
endif
nsCOMPtr
<
nsIURI
>
base
(
aBaseURI
)
;
return
NS_MutateURI
(
new
nsStandardURL
:
:
Mutator
(
)
)
.
Apply
(
NS_MutatorMethod
(
&
nsIFileURLMutator
:
:
MarkFileURL
)
)
.
Apply
(
NS_MutatorMethod
(
&
nsIStandardURLMutator
:
:
Init
nsIStandardURL
:
:
URLTYPE_NO_AUTHORITY
-
1
buf
charset
base
nullptr
)
)
.
Finalize
(
result
)
;
}
NS_IMETHODIMP
nsFileProtocolHandler
:
:
NewChannel
(
nsIURI
*
uri
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
nsresult
rv
;
nsFileChannel
*
chan
;
if
(
IsNeckoChild
(
)
)
{
chan
=
new
mozilla
:
:
net
:
:
FileChannelChild
(
uri
)
;
}
else
{
chan
=
new
nsFileChannel
(
uri
)
;
}
if
(
!
chan
)
return
NS_ERROR_OUT_OF_MEMORY
;
NS_ADDREF
(
chan
)
;
rv
=
chan
-
>
SetLoadInfo
(
aLoadInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_RELEASE
(
chan
)
;
return
rv
;
}
rv
=
chan
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_RELEASE
(
chan
)
;
return
rv
;
}
*
result
=
chan
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFileProtocolHandler
:
:
AllowPort
(
int32_t
port
const
char
*
scheme
bool
*
result
)
{
*
result
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFileProtocolHandler
:
:
NewFileURI
(
nsIFile
*
aFile
nsIURI
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aFile
)
;
RefPtr
<
nsIFile
>
file
(
aFile
)
;
return
NS_MutateURI
(
new
nsStandardURL
:
:
Mutator
(
)
)
.
Apply
(
NS_MutatorMethod
(
&
nsIFileURLMutator
:
:
SetFile
file
)
)
.
Finalize
(
aResult
)
;
}
NS_IMETHODIMP
nsFileProtocolHandler
:
:
NewFileURIMutator
(
nsIFile
*
aFile
nsIURIMutator
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aFile
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURIMutator
>
mutator
=
new
nsStandardURL
:
:
Mutator
(
)
;
nsCOMPtr
<
nsIFileURLMutator
>
fileMutator
=
do_QueryInterface
(
mutator
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
fileMutator
-
>
SetFile
(
aFile
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mutator
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFileProtocolHandler
:
:
GetURLSpecFromFile
(
nsIFile
*
file
nsACString
&
result
)
{
NS_ENSURE_ARG_POINTER
(
file
)
;
return
net_GetURLSpecFromFile
(
file
result
)
;
}
NS_IMETHODIMP
nsFileProtocolHandler
:
:
GetURLSpecFromActualFile
(
nsIFile
*
file
nsACString
&
result
)
{
NS_ENSURE_ARG_POINTER
(
file
)
;
return
net_GetURLSpecFromActualFile
(
file
result
)
;
}
NS_IMETHODIMP
nsFileProtocolHandler
:
:
GetURLSpecFromDir
(
nsIFile
*
file
nsACString
&
result
)
{
NS_ENSURE_ARG_POINTER
(
file
)
;
return
net_GetURLSpecFromDir
(
file
result
)
;
}
NS_IMETHODIMP
nsFileProtocolHandler
:
:
GetFileFromURLSpec
(
const
nsACString
&
spec
nsIFile
*
*
result
)
{
return
net_GetFileFromURLSpec
(
spec
result
)
;
}
