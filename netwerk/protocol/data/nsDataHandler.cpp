#
include
"
nsDataChannel
.
h
"
#
include
"
nsDataHandler
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsError
.
h
"
#
include
"
DataChannelChild
.
h
"
#
include
"
plstr
.
h
"
static
NS_DEFINE_CID
(
kSimpleURICID
NS_SIMPLEURI_CID
)
;
nsDataHandler
:
:
nsDataHandler
(
)
{
}
nsDataHandler
:
:
~
nsDataHandler
(
)
{
}
NS_IMPL_ISUPPORTS
(
nsDataHandler
nsIProtocolHandler
nsISupportsWeakReference
)
nsresult
nsDataHandler
:
:
Create
(
nsISupports
*
aOuter
const
nsIID
&
aIID
void
*
*
aResult
)
{
nsDataHandler
*
ph
=
new
nsDataHandler
(
)
;
if
(
ph
=
=
nullptr
)
return
NS_ERROR_OUT_OF_MEMORY
;
NS_ADDREF
(
ph
)
;
nsresult
rv
=
ph
-
>
QueryInterface
(
aIID
aResult
)
;
NS_RELEASE
(
ph
)
;
return
rv
;
}
NS_IMETHODIMP
nsDataHandler
:
:
GetScheme
(
nsACString
&
result
)
{
result
.
AssignLiteral
(
"
data
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDataHandler
:
:
GetDefaultPort
(
int32_t
*
result
)
{
*
result
=
-
1
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDataHandler
:
:
GetProtocolFlags
(
uint32_t
*
result
)
{
*
result
=
URI_NORELATIVE
|
URI_NOAUTH
|
URI_LOADABLE_BY_ANYONE
|
URI_NON_PERSISTABLE
|
URI_IS_LOCAL_RESOURCE
|
URI_SYNC_LOAD_IS_OK
;
if
(
nsIOService
:
:
IsInheritSecurityContextForDataURIEnabled
(
)
)
{
*
result
|
=
URI_INHERITS_SECURITY_CONTEXT
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDataHandler
:
:
NewURI
(
const
nsACString
&
aSpec
const
char
*
aCharset
nsIURI
*
aBaseURI
nsIURI
*
*
result
)
{
nsresult
rv
;
RefPtr
<
nsIURI
>
uri
;
nsCString
spec
(
aSpec
)
;
if
(
aBaseURI
&
&
!
spec
.
IsEmpty
(
)
&
&
spec
[
0
]
=
=
'
#
'
)
{
rv
=
aBaseURI
-
>
Clone
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
uri
-
>
SetRef
(
spec
)
;
}
else
{
nsAutoCString
contentType
;
bool
base64
;
rv
=
ParseURI
(
spec
contentType
nullptr
base64
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
base64
|
|
(
strncmp
(
contentType
.
get
(
)
"
text
/
"
5
)
!
=
0
&
&
contentType
.
Find
(
"
xml
"
)
=
=
kNotFound
)
)
{
spec
.
StripWhitespace
(
)
;
}
uri
=
do_CreateInstance
(
kSimpleURICID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
uri
-
>
SetSpec
(
spec
)
;
}
if
(
NS_FAILED
(
rv
)
)
return
rv
;
uri
.
forget
(
result
)
;
return
rv
;
}
NS_IMETHODIMP
nsDataHandler
:
:
NewChannel2
(
nsIURI
*
uri
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
NS_ENSURE_ARG_POINTER
(
uri
)
;
nsDataChannel
*
channel
;
if
(
XRE_IsParentProcess
(
)
)
{
channel
=
new
nsDataChannel
(
uri
)
;
}
else
{
channel
=
new
mozilla
:
:
net
:
:
DataChannelChild
(
uri
)
;
}
NS_ADDREF
(
channel
)
;
nsresult
rv
=
channel
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_RELEASE
(
channel
)
;
return
rv
;
}
rv
=
channel
-
>
SetLoadInfo
(
aLoadInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_RELEASE
(
channel
)
;
return
rv
;
}
*
result
=
channel
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDataHandler
:
:
NewChannel
(
nsIURI
*
uri
nsIChannel
*
*
result
)
{
return
NewChannel2
(
uri
nullptr
result
)
;
}
NS_IMETHODIMP
nsDataHandler
:
:
AllowPort
(
int32_t
port
const
char
*
scheme
bool
*
_retval
)
{
*
_retval
=
false
;
return
NS_OK
;
}
#
define
BASE64_EXTENSION
"
;
base64
"
nsresult
nsDataHandler
:
:
ParseURI
(
nsCString
&
spec
nsCString
&
contentType
nsCString
*
contentCharset
bool
&
isBase64
nsCString
*
dataBuffer
)
{
isBase64
=
false
;
const
char
*
roBuffer
=
(
const
char
*
)
PL_strcasestr
(
spec
.
get
(
)
"
data
:
"
)
;
if
(
!
roBuffer
)
{
return
NS_ERROR_MALFORMED_URI
;
}
roBuffer
+
=
sizeof
(
"
data
:
"
)
-
1
;
const
char
*
roComma
=
strchr
(
roBuffer
'
'
)
;
const
char
*
roHash
=
strchr
(
roBuffer
'
#
'
)
;
if
(
!
roComma
|
|
(
roHash
&
&
roHash
<
roComma
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
if
(
roComma
=
=
roBuffer
)
{
contentType
.
AssignLiteral
(
"
text
/
plain
"
)
;
if
(
contentCharset
)
{
contentCharset
-
>
AssignLiteral
(
"
US
-
ASCII
"
)
;
}
}
else
{
char
*
buffer
=
PL_strndup
(
roBuffer
roComma
-
roBuffer
)
;
char
*
base64
=
PL_strcasestr
(
buffer
BASE64_EXTENSION
)
;
if
(
base64
)
{
char
*
beyond
=
base64
+
sizeof
(
BASE64_EXTENSION
)
-
1
;
if
(
*
beyond
=
=
'
\
0
'
|
|
*
beyond
=
=
'
;
'
)
{
isBase64
=
true
;
*
base64
=
'
\
0
'
;
}
}
char
*
semiColon
=
(
char
*
)
strchr
(
buffer
'
;
'
)
;
if
(
semiColon
)
*
semiColon
=
'
\
0
'
;
if
(
semiColon
=
=
buffer
|
|
base64
=
=
buffer
)
{
contentType
.
AssignLiteral
(
"
text
/
plain
"
)
;
}
else
{
contentType
.
Assign
(
buffer
)
;
ToLowerCase
(
contentType
)
;
contentType
.
StripWhitespace
(
)
;
}
if
(
semiColon
&
&
contentCharset
)
{
char
*
charset
=
PL_strcasestr
(
semiColon
+
1
"
charset
=
"
)
;
if
(
charset
)
{
contentCharset
-
>
Assign
(
charset
+
sizeof
(
"
charset
=
"
)
-
1
)
;
contentCharset
-
>
StripWhitespace
(
)
;
}
}
free
(
buffer
)
;
}
if
(
dataBuffer
)
{
const
char
*
roData
=
roComma
+
1
;
bool
ok
=
!
roHash
?
dataBuffer
-
>
Assign
(
roData
mozilla
:
:
fallible
)
:
dataBuffer
-
>
Assign
(
roData
roHash
-
roData
mozilla
:
:
fallible
)
;
if
(
!
ok
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
NS_OK
;
}
