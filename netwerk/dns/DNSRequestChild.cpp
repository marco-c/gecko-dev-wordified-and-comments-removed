#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
net
/
ChildDNSService
.
h
"
#
include
"
mozilla
/
net
/
DNSRequestChild
.
h
"
#
include
"
mozilla
/
net
/
NeckoChild
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessChild
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIDNSRecord
.
h
"
#
include
"
nsIDNSByTypeRecord
.
h
"
#
include
"
nsHostResolver
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsNetAddr
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
{
namespace
net
{
class
ChildDNSRecord
:
public
nsIDNSRecord
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIDNSRECORD
ChildDNSRecord
(
const
DNSRecord
&
reply
uint16_t
flags
)
;
private
:
virtual
~
ChildDNSRecord
(
)
=
default
;
nsCString
mCanonicalName
;
nsTArray
<
NetAddr
>
mAddresses
;
uint32_t
mCurrent
;
uint32_t
mLength
;
uint16_t
mFlags
;
}
;
NS_IMPL_ISUPPORTS
(
ChildDNSRecord
nsIDNSRecord
)
ChildDNSRecord
:
:
ChildDNSRecord
(
const
DNSRecord
&
reply
uint16_t
flags
)
:
mCurrent
(
0
)
mFlags
(
flags
)
{
mCanonicalName
=
reply
.
canonicalName
(
)
;
const
nsTArray
<
NetAddr
>
&
addrs
=
reply
.
addrs
(
)
;
uint32_t
i
=
0
;
mLength
=
addrs
.
Length
(
)
;
for
(
;
i
<
mLength
;
i
+
+
)
{
mAddresses
.
AppendElement
(
addrs
[
i
]
)
;
}
}
NS_IMETHODIMP
ChildDNSRecord
:
:
GetCanonicalName
(
nsACString
&
result
)
{
if
(
!
(
mFlags
&
nsHostResolver
:
:
RES_CANON_NAME
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
result
=
mCanonicalName
;
return
NS_OK
;
}
NS_IMETHODIMP
ChildDNSRecord
:
:
IsTRR
(
bool
*
retval
)
{
*
retval
=
false
;
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
ChildDNSRecord
:
:
GetNextAddr
(
uint16_t
port
NetAddr
*
addr
)
{
if
(
mCurrent
>
=
mLength
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
memcpy
(
addr
&
mAddresses
[
mCurrent
+
+
]
sizeof
(
NetAddr
)
)
;
addr
-
>
inet
.
port
=
htons
(
port
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ChildDNSRecord
:
:
GetAddresses
(
nsTArray
<
NetAddr
>
&
aAddressArray
)
{
aAddressArray
=
mAddresses
;
return
NS_OK
;
}
NS_IMETHODIMP
ChildDNSRecord
:
:
GetScriptableNextAddr
(
uint16_t
port
nsINetAddr
*
*
result
)
{
NetAddr
addr
;
nsresult
rv
=
GetNextAddr
(
port
&
addr
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
NS_ADDREF
(
*
result
=
new
nsNetAddr
(
&
addr
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ChildDNSRecord
:
:
GetNextAddrAsString
(
nsACString
&
result
)
{
NetAddr
addr
;
nsresult
rv
=
GetNextAddr
(
0
&
addr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
char
buf
[
kIPv6CStrBufSize
]
;
if
(
NetAddrToString
(
&
addr
buf
sizeof
(
buf
)
)
)
{
result
.
Assign
(
buf
)
;
return
NS_OK
;
}
NS_ERROR
(
"
NetAddrToString
failed
unexpectedly
"
)
;
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
ChildDNSRecord
:
:
HasMore
(
bool
*
result
)
{
*
result
=
mCurrent
<
mLength
;
return
NS_OK
;
}
NS_IMETHODIMP
ChildDNSRecord
:
:
Rewind
(
)
{
mCurrent
=
0
;
return
NS_OK
;
}
NS_IMETHODIMP
ChildDNSRecord
:
:
ReportUnusable
(
uint16_t
aPort
)
{
return
NS_OK
;
}
class
ChildDNSByTypeRecord
:
public
nsIDNSByTypeRecord
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIDNSBYTYPERECORD
explicit
ChildDNSByTypeRecord
(
const
nsTArray
<
nsCString
>
&
reply
)
;
private
:
virtual
~
ChildDNSByTypeRecord
(
)
=
default
;
nsTArray
<
nsCString
>
mRecords
;
}
;
NS_IMPL_ISUPPORTS
(
ChildDNSByTypeRecord
nsIDNSByTypeRecord
)
ChildDNSByTypeRecord
:
:
ChildDNSByTypeRecord
(
const
nsTArray
<
nsCString
>
&
reply
)
{
mRecords
=
reply
;
}
NS_IMETHODIMP
ChildDNSByTypeRecord
:
:
GetRecords
(
nsTArray
<
nsCString
>
&
aRecords
)
{
aRecords
=
mRecords
;
return
NS_OK
;
}
NS_IMETHODIMP
ChildDNSByTypeRecord
:
:
GetRecordsAsOneString
(
nsACString
&
aRecords
)
{
for
(
uint32_t
i
=
0
;
i
<
mRecords
.
Length
(
)
;
i
+
+
)
{
aRecords
.
Append
(
mRecords
[
i
]
)
;
}
return
NS_OK
;
}
class
CancelDNSRequestEvent
:
public
Runnable
{
public
:
CancelDNSRequestEvent
(
DNSRequestChild
*
aDnsReq
nsresult
aReason
)
:
Runnable
(
"
net
:
:
CancelDNSRequestEvent
"
)
mDnsRequest
(
aDnsReq
)
mReasonForCancel
(
aReason
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mDnsRequest
-
>
CanSend
(
)
)
{
mDnsRequest
-
>
SendCancelDNSRequest
(
mDnsRequest
-
>
mHost
mDnsRequest
-
>
mType
mDnsRequest
-
>
mOriginAttributes
mDnsRequest
-
>
mFlags
mReasonForCancel
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
DNSRequestChild
>
mDnsRequest
;
nsresult
mReasonForCancel
;
}
;
DNSRequestChild
:
:
DNSRequestChild
(
const
nsACString
&
aHost
const
uint16_t
&
aType
const
OriginAttributes
&
aOriginAttributes
const
uint32_t
&
aFlags
nsIDNSListener
*
aListener
nsIEventTarget
*
target
)
:
mListener
(
aListener
)
mTarget
(
target
)
mResultStatus
(
NS_OK
)
mHost
(
aHost
)
mType
(
aType
)
mOriginAttributes
(
aOriginAttributes
)
mFlags
(
aFlags
)
{
}
void
DNSRequestChild
:
:
StartRequest
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
NewRunnableMethod
(
"
net
:
:
DNSRequestChild
:
:
StartRequest
"
this
&
DNSRequestChild
:
:
StartRequest
)
)
;
return
;
}
if
(
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIEventTarget
>
systemGroupEventTarget
=
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
;
gNeckoChild
-
>
SetEventTargetForActor
(
this
systemGroupEventTarget
)
;
mozilla
:
:
dom
:
:
ContentChild
*
cc
=
static_cast
<
mozilla
:
:
dom
:
:
ContentChild
*
>
(
gNeckoChild
-
>
Manager
(
)
)
;
if
(
cc
-
>
IsShuttingDown
(
)
)
{
return
;
}
gNeckoChild
-
>
SendPDNSRequestConstructor
(
this
mHost
mOriginAttributes
mFlags
)
;
}
else
if
(
XRE_IsSocketProcess
(
)
)
{
SocketProcessChild
*
child
=
SocketProcessChild
:
:
GetSingleton
(
)
;
if
(
!
child
-
>
CanSend
(
)
)
{
return
;
}
child
-
>
SendPDNSRequestConstructor
(
this
mHost
mOriginAttributes
mFlags
)
;
}
else
{
MOZ_ASSERT
(
false
"
Wrong
process
"
)
;
return
;
}
}
void
DNSRequestChild
:
:
CallOnLookupComplete
(
)
{
MOZ_ASSERT
(
mListener
)
;
mListener
-
>
OnLookupComplete
(
this
mResultRecord
mResultStatus
)
;
}
void
DNSRequestChild
:
:
CallOnLookupByTypeComplete
(
)
{
MOZ_ASSERT
(
mListener
)
;
MOZ_ASSERT
(
mType
!
=
nsIDNSService
:
:
RESOLVE_TYPE_DEFAULT
)
;
mListener
-
>
OnLookupByTypeComplete
(
this
mResultByTypeRecords
mResultStatus
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
DNSRequestChild
:
:
RecvLookupCompleted
(
const
DNSRequestResponse
&
reply
)
{
MOZ_ASSERT
(
mListener
)
;
switch
(
reply
.
type
(
)
)
{
case
DNSRequestResponse
:
:
TDNSRecord
:
{
mResultRecord
=
new
ChildDNSRecord
(
reply
.
get_DNSRecord
(
)
mFlags
)
;
break
;
}
case
DNSRequestResponse
:
:
Tnsresult
:
{
mResultStatus
=
reply
.
get_nsresult
(
)
;
break
;
}
case
DNSRequestResponse
:
:
TArrayOfnsCString
:
{
MOZ_ASSERT
(
mType
!
=
nsIDNSService
:
:
RESOLVE_TYPE_DEFAULT
)
;
mResultByTypeRecords
=
new
ChildDNSByTypeRecord
(
reply
.
get_ArrayOfnsCString
(
)
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
type
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
targetIsMain
=
false
;
if
(
!
mTarget
)
{
targetIsMain
=
true
;
}
else
{
mTarget
-
>
IsOnCurrentThread
(
&
targetIsMain
)
;
}
if
(
targetIsMain
)
{
if
(
mType
=
=
nsIDNSService
:
:
RESOLVE_TYPE_DEFAULT
)
{
CallOnLookupComplete
(
)
;
}
else
{
CallOnLookupByTypeComplete
(
)
;
}
}
else
{
if
(
mType
=
=
nsIDNSService
:
:
RESOLVE_TYPE_DEFAULT
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
net
:
:
DNSRequestChild
:
:
CallOnLookupComplete
"
this
&
DNSRequestChild
:
:
CallOnLookupComplete
)
;
mTarget
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
net
:
:
DNSRequestChild
:
:
CallOnLookupByTypeComplete
"
this
&
DNSRequestChild
:
:
CallOnLookupByTypeComplete
)
;
mTarget
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
}
Unused
<
<
Send__delete__
(
this
)
;
return
IPC_OK
(
)
;
}
void
DNSRequestChild
:
:
ActorDestroy
(
ActorDestroyReason
why
)
{
RefPtr
<
ChildDNSService
>
dnsServiceChild
=
dont_AddRef
(
ChildDNSService
:
:
GetSingleton
(
)
)
;
dnsServiceChild
-
>
NotifyRequestDone
(
this
)
;
}
NS_IMPL_ISUPPORTS
(
DNSRequestChild
nsICancelable
)
NS_IMETHODIMP
DNSRequestChild
:
:
Cancel
(
nsresult
reason
)
{
if
(
CanSend
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
CancelDNSRequestEvent
(
this
reason
)
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
return
NS_OK
;
}
}
}
