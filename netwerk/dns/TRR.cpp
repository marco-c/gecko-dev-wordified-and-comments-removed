#
include
"
DNS
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsHostResolver
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIUploadChannel2
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
TRR
.
h
"
#
include
"
TRRService
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
namespace
mozilla
{
namespace
net
{
#
undef
LOG
extern
mozilla
:
:
LazyLogModule
gHostResolverLog
;
#
define
LOG
(
args
)
MOZ_LOG
(
gHostResolverLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
mozilla
:
:
net
:
:
gHostResolverLog
mozilla
:
:
LogLevel
:
:
Debug
)
NS_IMPL_ISUPPORTS
(
TRR
nsIHttpPushListener
nsIInterfaceRequestor
nsIStreamListener
nsIRunnable
)
const
uint8_t
kDNS_CLASS_IN
=
1
;
NS_IMETHODIMP
TRR
:
:
Notify
(
nsITimer
*
aTimer
)
{
if
(
aTimer
=
=
mTimeout
)
{
mTimeout
=
nullptr
;
Cancel
(
)
;
}
else
{
MOZ_CRASH
(
"
Unknown
timer
"
)
;
}
return
NS_OK
;
}
nsresult
TRR
:
:
DohEncode
(
nsCString
&
aBody
bool
aDisableECS
)
{
aBody
.
Truncate
(
)
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
0x01
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
1
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
aDisableECS
?
1
:
'
\
0
'
;
int32_t
index
=
0
;
int32_t
offset
=
0
;
do
{
bool
dotFound
=
false
;
int32_t
labelLength
;
index
=
mHost
.
FindChar
(
'
.
'
offset
)
;
if
(
kNotFound
!
=
index
)
{
dotFound
=
true
;
labelLength
=
index
-
offset
;
}
else
{
labelLength
=
mHost
.
Length
(
)
-
offset
;
}
if
(
labelLength
>
63
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
aBody
+
=
static_cast
<
unsigned
char
>
(
labelLength
)
;
nsDependentCSubstring
label
=
Substring
(
mHost
offset
labelLength
)
;
aBody
.
Append
(
label
)
;
if
(
!
dotFound
)
{
aBody
+
=
'
\
0
'
;
break
;
}
offset
+
=
labelLength
+
1
;
}
while
(
true
)
;
aBody
+
=
'
\
0
'
;
aBody
+
=
static_cast
<
uint8_t
>
(
mType
)
;
aBody
+
=
'
\
0
'
;
aBody
+
=
kDNS_CLASS_IN
;
if
(
aDisableECS
)
{
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
41
;
aBody
+
=
16
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
8
;
aBody
+
=
'
\
0
'
;
aBody
+
=
8
;
aBody
+
=
'
\
0
'
;
aBody
+
=
4
;
aBody
+
=
'
\
0
'
;
aBody
+
=
1
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TRR
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
(
gTRRService
=
=
nullptr
)
|
|
NS_FAILED
(
SendHTTPRequest
(
)
)
)
{
FailData
(
NS_ERROR_FAILURE
)
;
}
return
NS_OK
;
}
nsresult
TRR
:
:
SendHTTPRequest
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
wrong
thread
"
)
;
if
(
(
mType
!
=
TRRTYPE_A
)
&
&
(
mType
!
=
TRRTYPE_AAAA
)
&
&
(
mType
!
=
TRRTYPE_NS
)
&
&
(
mType
!
=
TRRTYPE_TXT
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
(
mType
=
=
TRRTYPE_A
)
|
|
(
mType
=
=
TRRTYPE_AAAA
)
)
{
MOZ_ASSERT
(
mRec
)
;
if
(
gTRRService
-
>
IsTRRBlacklisted
(
mHost
mOriginSuffix
mPB
true
)
)
{
if
(
mType
=
=
TRRTYPE_A
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
DNS_TRR_BLACKLISTED
true
)
;
}
return
NS_ERROR_UNKNOWN_HOST
;
}
else
{
if
(
mType
=
=
TRRTYPE_A
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
DNS_TRR_BLACKLISTED
false
)
;
}
}
}
nsresult
rv
;
nsCOMPtr
<
nsIIOService
>
ios
(
do_GetIOService
(
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
useGet
=
gTRRService
-
>
UseGET
(
)
;
nsAutoCString
body
;
nsCOMPtr
<
nsIURI
>
dnsURI
;
bool
disableECS
=
gTRRService
-
>
DisableECS
(
)
;
LOG
(
(
"
TRR
:
:
SendHTTPRequest
resolve
%
s
type
%
u
\
n
"
mHost
.
get
(
)
mType
)
)
;
if
(
useGet
)
{
nsAutoCString
tmp
;
rv
=
DohEncode
(
tmp
disableECS
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
Base64URLEncode
(
tmp
.
Length
(
)
reinterpret_cast
<
const
unsigned
char
*
>
(
tmp
.
get
(
)
)
Base64URLEncodePaddingPolicy
:
:
Omit
body
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
uri
;
gTRRService
-
>
GetURI
(
uri
)
;
uri
.
Append
(
NS_LITERAL_CSTRING
(
"
?
dns
=
"
)
)
;
uri
.
Append
(
body
)
;
LOG
(
(
"
TRR
:
:
SendHTTPRequest
GET
dns
=
%
s
\
n
"
body
.
get
(
)
)
)
;
rv
=
NS_NewURI
(
getter_AddRefs
(
dnsURI
)
uri
)
;
}
else
{
rv
=
DohEncode
(
body
disableECS
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
uri
;
gTRRService
-
>
GetURI
(
uri
)
;
rv
=
NS_NewURI
(
getter_AddRefs
(
dnsURI
)
uri
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
SendHTTPRequest
:
NewURI
failed
!
\
n
"
)
)
;
return
rv
;
}
rv
=
NS_NewChannel
(
getter_AddRefs
(
mChannel
)
dnsURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
nullptr
nullptr
nullptr
this
nsIRequest
:
:
LOAD_ANONYMOUS
|
(
mPB
?
nsIRequest
:
:
INHIBIT_CACHING
:
0
)
ios
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
SendHTTPRequest
:
NewChannel
failed
!
\
n
"
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
mChannel
)
;
if
(
!
httpChannel
)
{
return
NS_ERROR_UNEXPECTED
;
}
rv
=
httpChannel
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Accept
"
)
NS_LITERAL_CSTRING
(
"
application
/
dns
-
message
"
)
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
cred
;
gTRRService
-
>
GetCredentials
(
cred
)
;
if
(
!
cred
.
IsEmpty
(
)
)
{
rv
=
httpChannel
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Authorization
"
)
cred
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
mChannel
)
;
if
(
!
internalChannel
)
{
return
NS_ERROR_UNEXPECTED
;
}
rv
=
internalChannel
-
>
SetInitialRwin
(
127
*
1024
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
internalChannel
-
>
SetTrr
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mAllowRFC1918
=
gTRRService
-
>
AllowRFC1918
(
)
;
if
(
useGet
)
{
rv
=
httpChannel
-
>
SetRequestMethod
(
NS_LITERAL_CSTRING
(
"
GET
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
httpChannel
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Cache
-
Control
"
)
NS_LITERAL_CSTRING
(
"
no
-
store
"
)
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIUploadChannel2
>
uploadChannel
=
do_QueryInterface
(
httpChannel
)
;
if
(
!
uploadChannel
)
{
return
NS_ERROR_UNEXPECTED
;
}
uint32_t
streamLength
=
body
.
Length
(
)
;
nsCOMPtr
<
nsIInputStream
>
uploadStream
;
rv
=
NS_NewCStringInputStream
(
getter_AddRefs
(
uploadStream
)
std
:
:
move
(
body
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
uploadChannel
-
>
ExplicitSetUploadStream
(
uploadStream
NS_LITERAL_CSTRING
(
"
application
/
dns
-
message
"
)
streamLength
NS_LITERAL_CSTRING
(
"
POST
"
)
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
NS_FAILED
(
httpChannel
-
>
SetContentType
(
NS_LITERAL_CSTRING
(
"
application
/
dns
-
message
"
)
)
)
)
{
LOG
(
(
"
TRR
:
:
SendHTTPRequest
:
couldn
'
t
set
content
-
type
!
\
n
"
)
)
;
}
if
(
NS_SUCCEEDED
(
httpChannel
-
>
AsyncOpen
(
this
)
)
)
{
NS_NewTimerWithCallback
(
getter_AddRefs
(
mTimeout
)
this
gTRRService
-
>
GetRequestTimeout
(
)
nsITimer
:
:
TYPE_ONE_SHOT
)
;
return
NS_OK
;
}
mChannel
=
nullptr
;
return
NS_ERROR_UNEXPECTED
;
}
NS_IMETHODIMP
TRR
:
:
GetInterface
(
const
nsIID
&
iid
void
*
*
result
)
{
if
(
!
iid
.
Equals
(
NS_GET_IID
(
nsIHttpPushListener
)
)
)
{
return
NS_ERROR_NO_INTERFACE
;
}
nsCOMPtr
<
nsIHttpPushListener
>
copy
(
this
)
;
*
result
=
copy
.
forget
(
)
.
take
(
)
;
return
NS_OK
;
}
nsresult
TRR
:
:
DohDecodeQuery
(
const
nsCString
&
query
nsCString
&
host
enum
TrrType
&
type
)
{
FallibleTArray
<
uint8_t
>
binary
;
bool
found_dns
=
false
;
LOG
(
(
"
TRR
:
:
DohDecodeQuery
%
s
!
\
n
"
query
.
get
(
)
)
)
;
nsCCharSeparatedTokenizer
tokenizer
(
query
'
&
'
)
;
nsAutoCString
data
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
const
nsACString
&
token
=
tokenizer
.
nextToken
(
)
;
nsDependentCSubstring
dns
=
Substring
(
token
0
4
)
;
nsAutoCString
check
(
dns
)
;
if
(
check
.
Equals
(
"
dns
=
"
)
)
{
nsDependentCSubstring
q
=
Substring
(
token
4
-
1
)
;
data
=
q
;
found_dns
=
true
;
break
;
}
}
if
(
!
found_dns
)
{
LOG
(
(
"
TRR
:
:
DohDecodeQuery
no
dns
=
in
pushed
URI
query
string
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
nsresult
rv
=
Base64URLDecode
(
data
Base64URLDecodePaddingPolicy
:
:
Ignore
binary
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
avail
=
binary
.
Length
(
)
;
if
(
avail
<
12
)
{
return
NS_ERROR_FAILURE
;
}
if
(
(
binary
[
2
]
&
0xf8
)
!
=
0
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
qdcount
=
(
binary
[
4
]
<
<
8
)
+
binary
[
5
]
;
if
(
!
qdcount
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
index
=
12
;
uint32_t
length
=
0
;
host
.
Truncate
(
)
;
do
{
if
(
avail
<
(
index
+
1
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
length
=
binary
[
index
]
;
if
(
length
)
{
if
(
host
.
Length
(
)
)
{
host
.
Append
(
"
.
"
)
;
}
if
(
avail
<
(
index
+
1
+
length
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
host
.
Append
(
(
const
char
*
)
(
&
binary
[
0
]
)
+
index
+
1
length
)
;
}
index
+
=
1
+
length
;
}
while
(
length
)
;
LOG
(
(
"
TRR
:
:
DohDecodeQuery
host
%
s
\
n
"
host
.
get
(
)
)
)
;
if
(
avail
<
(
index
+
2
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
uint16_t
i16
=
0
;
i16
+
=
binary
[
index
]
<
<
8
;
i16
+
=
binary
[
index
+
1
]
;
type
=
(
enum
TrrType
)
i16
;
LOG
(
(
"
TRR
:
:
DohDecodeQuery
type
%
d
\
n
"
(
int
)
type
)
)
;
return
NS_OK
;
}
nsresult
TRR
:
:
ReceivePush
(
nsIHttpChannel
*
pushed
nsHostRecord
*
pushedRec
)
{
if
(
!
mHostResolver
)
{
return
NS_ERROR_UNEXPECTED
;
}
LOG
(
(
"
TRR
:
:
ReceivePush
:
PUSH
incoming
!
\
n
"
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
pushed
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsAutoCString
query
;
if
(
uri
)
{
uri
-
>
GetQuery
(
query
)
;
}
PRNetAddr
tempAddr
;
if
(
NS_FAILED
(
DohDecodeQuery
(
query
mHost
mType
)
)
|
|
(
PR_StringToNetAddr
(
mHost
.
get
(
)
&
tempAddr
)
=
=
PR_SUCCESS
)
)
{
LOG
(
(
"
TRR
:
:
ReceivePush
failed
to
decode
%
s
\
n
"
mHost
.
get
(
)
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
(
mType
!
=
TRRTYPE_A
)
&
&
(
mType
!
=
TRRTYPE_AAAA
)
&
&
(
mType
!
=
TRRTYPE_TXT
)
)
{
LOG
(
(
"
TRR
:
:
ReceivePush
unknown
type
%
d
\
n
"
mType
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
RefPtr
<
nsHostRecord
>
hostRecord
;
nsresult
rv
;
rv
=
mHostResolver
-
>
GetHostRecord
(
mHost
(
mType
!
=
TRRTYPE_TXT
)
?
0
:
nsIDNSService
:
:
RESOLVE_TYPE_TXT
pushedRec
-
>
flags
pushedRec
-
>
af
pushedRec
-
>
pb
pushedRec
-
>
originSuffix
getter_AddRefs
(
hostRecord
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
mHostResolver
-
>
TrrLookup_unlocked
(
hostRecord
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
pushed
-
>
AsyncOpen
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mChannel
=
pushed
;
mRec
.
swap
(
hostRecord
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TRR
:
:
OnPush
(
nsIHttpChannel
*
associated
nsIHttpChannel
*
pushed
)
{
LOG
(
(
"
TRR
:
:
OnPush
entry
\
n
"
)
)
;
MOZ_ASSERT
(
associated
=
=
mChannel
)
;
if
(
!
mRec
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
TRR
>
trr
=
new
TRR
(
mHostResolver
mPB
)
;
return
trr
-
>
ReceivePush
(
pushed
mRec
)
;
}
NS_IMETHODIMP
TRR
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
LOG
(
(
"
TRR
:
:
OnStartRequest
%
p
%
s
%
d
\
n
"
this
mHost
.
get
(
)
mType
)
)
;
mStartTime
=
TimeStamp
:
:
Now
(
)
;
return
NS_OK
;
}
static
uint16_t
get16bit
(
unsigned
char
*
aData
int
index
)
{
return
(
(
aData
[
index
]
<
<
8
)
|
aData
[
index
+
1
]
)
;
}
static
uint32_t
get32bit
(
unsigned
char
*
aData
int
index
)
{
return
(
aData
[
index
]
<
<
24
)
|
(
aData
[
index
+
1
]
<
<
16
)
|
(
aData
[
index
+
2
]
<
<
8
)
|
aData
[
index
+
3
]
;
}
nsresult
TRR
:
:
PassQName
(
unsigned
int
&
index
)
{
uint8_t
length
;
do
{
if
(
mBodySize
<
(
index
+
1
)
)
{
LOG
(
(
"
TRR
:
PassQName
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
length
=
static_cast
<
uint8_t
>
(
mResponse
[
index
]
)
;
if
(
(
length
&
0xc0
)
=
=
0xc0
)
{
if
(
mBodySize
<
(
index
+
2
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
2
;
break
;
}
if
(
length
&
0xc0
)
{
LOG
(
(
"
TRR
:
illegal
label
length
byte
(
%
x
)
at
index
%
d
\
n
"
length
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
mBodySize
<
(
index
+
1
+
length
)
)
{
LOG
(
(
"
TRR
:
PassQName
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
1
+
length
;
}
while
(
length
)
;
return
NS_OK
;
}
nsresult
TRR
:
:
GetQname
(
nsAutoCString
&
aQname
unsigned
int
&
aIndex
)
{
uint8_t
clength
=
0
;
unsigned
int
cindex
=
aIndex
;
unsigned
int
loop
=
128
;
unsigned
int
endindex
=
0
;
do
{
if
(
cindex
>
=
mBodySize
)
{
LOG
(
(
"
TRR
:
bad
cname
packet
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
clength
=
static_cast
<
uint8_t
>
(
mResponse
[
cindex
]
)
;
if
(
(
clength
&
0xc0
)
=
=
0xc0
)
{
if
(
(
cindex
+
1
)
>
=
mBodySize
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
newpos
=
(
clength
&
0x3f
)
<
<
8
|
mResponse
[
cindex
+
1
]
;
if
(
!
endindex
)
{
endindex
=
cindex
+
2
;
}
cindex
=
newpos
;
continue
;
}
else
if
(
clength
&
0xc0
)
{
LOG
(
(
"
TRR
:
bad
cname
packet
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
else
{
cindex
+
+
;
}
if
(
clength
)
{
if
(
!
aQname
.
IsEmpty
(
)
)
{
aQname
.
Append
(
"
.
"
)
;
}
if
(
(
cindex
+
clength
)
>
mBodySize
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
aQname
.
Append
(
(
const
char
*
)
(
&
mResponse
[
cindex
]
)
clength
)
;
cindex
+
=
clength
;
}
}
while
(
clength
&
&
-
-
loop
)
;
if
(
!
loop
)
{
LOG
(
(
"
TRR
:
:
DohDecode
pointer
loop
error
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
!
endindex
)
{
endindex
=
cindex
;
}
aIndex
=
endindex
;
return
NS_OK
;
}
nsresult
TRR
:
:
DohDecode
(
nsCString
&
aHost
)
{
unsigned
int
index
=
12
;
uint8_t
length
;
nsAutoCString
host
;
nsresult
rv
;
LOG
(
(
"
doh
decode
%
s
%
d
bytes
\
n
"
aHost
.
get
(
)
mBodySize
)
)
;
mCname
.
Truncate
(
)
;
if
(
mBodySize
<
12
|
|
mResponse
[
0
]
|
|
mResponse
[
1
]
)
{
LOG
(
(
"
TRR
bad
incoming
DOH
eject
!
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint8_t
rcode
=
mResponse
[
3
]
&
0x0F
;
if
(
rcode
)
{
LOG
(
(
"
TRR
Decode
%
s
RCODE
%
d
\
n
"
aHost
.
get
(
)
rcode
)
)
;
return
NS_ERROR_FAILURE
;
}
uint16_t
questionRecords
=
get16bit
(
mResponse
4
)
;
while
(
questionRecords
)
{
do
{
if
(
mBodySize
<
(
index
+
1
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
length
=
static_cast
<
uint8_t
>
(
mResponse
[
index
]
)
;
if
(
length
)
{
if
(
host
.
Length
(
)
)
{
host
.
Append
(
"
.
"
)
;
}
if
(
mBodySize
<
(
index
+
1
+
length
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
host
.
Append
(
(
(
char
*
)
mResponse
)
+
index
+
1
length
)
;
}
index
+
=
1
+
length
;
}
while
(
length
)
;
if
(
mBodySize
<
(
index
+
4
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
4
;
questionRecords
-
-
;
}
uint16_t
answerRecords
=
get16bit
(
mResponse
6
)
;
LOG
(
(
"
TRR
Decode
:
%
d
answer
records
(
%
u
bytes
body
)
%
s
index
=
%
u
\
n
"
answerRecords
mBodySize
host
.
get
(
)
index
)
)
;
while
(
answerRecords
)
{
nsAutoCString
qname
;
rv
=
GetQname
(
qname
index
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mBodySize
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
+
2
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
TYPE
=
get16bit
(
mResponse
index
)
;
if
(
(
TYPE
!
=
TRRTYPE_CNAME
)
&
&
(
TYPE
!
=
static_cast
<
uint16_t
>
(
mType
)
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
asked
for
type
%
d
got
%
d
\
n
"
__LINE__
mType
TYPE
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
index
+
=
2
;
if
(
mBodySize
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
+
2
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
CLASS
=
get16bit
(
mResponse
index
)
;
if
(
kDNS_CLASS_IN
!
=
CLASS
)
{
LOG
(
(
"
TRR
bad
CLASS
(
%
u
)
at
index
%
d
\
n
"
CLASS
index
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
index
+
=
2
;
if
(
mBodySize
<
(
index
+
4
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint32_t
TTL
=
get32bit
(
mResponse
index
)
;
index
+
=
4
;
if
(
mBodySize
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
RDLENGTH
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
if
(
mBodySize
<
(
index
+
RDLENGTH
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
RDLENGTH
=
%
d
at
index
%
d
\
n
"
__LINE__
RDLENGTH
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
qname
.
Equals
(
aHost
)
)
{
switch
(
TYPE
)
{
case
TRRTYPE_A
:
if
(
RDLENGTH
!
=
4
)
{
LOG
(
(
"
TRR
bad
length
for
A
(
%
u
)
\
n
"
RDLENGTH
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
rv
=
mDNS
.
Add
(
TTL
mResponse
index
RDLENGTH
mAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
DohDecode
failed
:
local
IP
addresses
or
unknown
IP
"
"
family
\
n
"
)
)
;
return
rv
;
}
break
;
case
TRRTYPE_AAAA
:
if
(
RDLENGTH
!
=
16
)
{
LOG
(
(
"
TRR
bad
length
for
AAAA
(
%
u
)
\
n
"
RDLENGTH
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
rv
=
mDNS
.
Add
(
TTL
mResponse
index
RDLENGTH
mAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
got
unique
/
local
IPv6
address
!
\
n
"
)
)
;
return
rv
;
}
break
;
case
TRRTYPE_NS
:
break
;
case
TRRTYPE_CNAME
:
if
(
mCname
.
IsEmpty
(
)
)
{
nsAutoCString
qname
;
unsigned
int
qnameindex
=
index
;
rv
=
GetQname
(
qname
qnameindex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
qname
.
IsEmpty
(
)
)
{
mCname
=
qname
;
LOG
(
(
"
TRR
:
:
DohDecode
CNAME
host
%
s
=
>
%
s
\
n
"
host
.
get
(
)
mCname
.
get
(
)
)
)
;
}
else
{
LOG
(
(
"
TRR
:
:
DohDecode
empty
CNAME
for
host
%
s
!
\
n
"
host
.
get
(
)
)
)
;
}
}
else
{
LOG
(
(
"
TRR
:
:
DohDecode
CNAME
-
ignoring
another
entry
\
n
"
)
)
;
}
break
;
case
TRRTYPE_TXT
:
{
nsAutoCString
txt
;
unsigned
int
txtIndex
=
index
;
uint16_t
available
=
RDLENGTH
;
while
(
available
>
0
)
{
uint8_t
characterStringLen
=
mResponse
[
txtIndex
+
+
]
;
available
-
-
;
if
(
characterStringLen
>
available
)
{
LOG
(
(
"
TRR
:
:
DohDecode
MALFORMED
TXT
RECORD
\
n
"
)
)
;
break
;
}
txt
.
Append
(
(
const
char
*
)
(
&
mResponse
[
txtIndex
]
)
characterStringLen
)
;
txtIndex
+
=
characterStringLen
;
available
-
=
characterStringLen
;
}
mTxt
.
AppendElement
(
txt
)
;
if
(
mTxtTtl
>
TTL
)
{
mTxtTtl
=
TTL
;
}
LOG
(
(
"
TRR
:
:
DohDecode
TXT
host
%
s
=
>
%
s
\
n
"
host
.
get
(
)
txt
.
get
(
)
)
)
;
break
;
}
default
:
LOG
(
(
"
TRR
unsupported
TYPE
(
%
u
)
RDLENGTH
%
u
\
n
"
TYPE
RDLENGTH
)
)
;
break
;
}
}
else
{
LOG
(
(
"
TRR
asked
for
%
s
data
but
got
%
s
\
n
"
aHost
.
get
(
)
qname
.
get
(
)
)
)
;
}
index
+
=
RDLENGTH
;
LOG
(
(
"
done
with
record
type
%
u
len
%
u
index
now
%
u
of
%
u
\
n
"
TYPE
RDLENGTH
index
mBodySize
)
)
;
answerRecords
-
-
;
}
uint16_t
nsRecords
=
get16bit
(
mResponse
8
)
;
LOG
(
(
"
TRR
Decode
:
%
d
ns
records
(
%
u
bytes
body
)
\
n
"
nsRecords
mBodySize
)
)
;
while
(
nsRecords
)
{
rv
=
PassQName
(
index
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mBodySize
<
(
index
+
8
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
2
;
index
+
=
2
;
index
+
=
4
;
if
(
mBodySize
<
(
index
+
2
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
RDLENGTH
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
if
(
mBodySize
<
(
index
+
RDLENGTH
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
RDLENGTH
;
LOG
(
(
"
done
with
nsRecord
now
%
u
of
%
u
\
n
"
index
mBodySize
)
)
;
nsRecords
-
-
;
}
uint16_t
arRecords
=
get16bit
(
mResponse
10
)
;
LOG
(
(
"
TRR
Decode
:
%
d
additional
resource
records
(
%
u
bytes
body
)
\
n
"
arRecords
mBodySize
)
)
;
while
(
arRecords
)
{
rv
=
PassQName
(
index
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mBodySize
<
(
index
+
8
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
2
;
index
+
=
2
;
index
+
=
4
;
if
(
mBodySize
<
(
index
+
2
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
RDLENGTH
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
if
(
mBodySize
<
(
index
+
RDLENGTH
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
RDLENGTH
;
LOG
(
(
"
done
with
additional
rr
now
%
u
of
%
u
\
n
"
index
mBodySize
)
)
;
arRecords
-
-
;
}
if
(
index
!
=
mBodySize
)
{
LOG
(
(
"
DohDecode
failed
to
parse
entire
response
body
%
u
out
of
%
u
bytes
\
n
"
index
mBodySize
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
(
mType
!
=
TRRTYPE_NS
)
&
&
mCname
.
IsEmpty
(
)
&
&
!
mDNS
.
mAddresses
.
getFirst
(
)
&
&
mTxt
.
IsEmpty
(
)
)
{
LOG
(
(
"
TRR
:
No
entries
were
stored
!
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
TRR
:
:
ReturnData
(
)
{
if
(
mType
!
=
TRRTYPE_TXT
)
{
RefPtr
<
AddrInfo
>
ai
(
new
AddrInfo
(
mHost
mType
)
)
;
DOHaddr
*
item
;
uint32_t
ttl
=
AddrInfo
:
:
NO_TTL_DATA
;
while
(
(
item
=
static_cast
<
DOHaddr
*
>
(
mDNS
.
mAddresses
.
popFirst
(
)
)
)
)
{
PRNetAddr
prAddr
;
NetAddrToPRNetAddr
(
&
item
-
>
mNet
&
prAddr
)
;
auto
*
addrElement
=
new
NetAddrElement
(
&
prAddr
)
;
ai
-
>
AddAddress
(
addrElement
)
;
if
(
item
-
>
mTtl
<
ttl
)
{
ttl
=
item
-
>
mTtl
;
}
}
ai
-
>
ttl
=
ttl
;
if
(
!
mHostResolver
)
{
return
NS_ERROR_FAILURE
;
}
(
void
)
mHostResolver
-
>
CompleteLookup
(
mRec
NS_OK
ai
mPB
mOriginSuffix
)
;
mHostResolver
=
nullptr
;
mRec
=
nullptr
;
}
else
{
(
void
)
mHostResolver
-
>
CompleteLookupByType
(
mRec
NS_OK
&
mTxt
mTxtTtl
mPB
)
;
}
return
NS_OK
;
}
nsresult
TRR
:
:
FailData
(
nsresult
error
)
{
if
(
!
mHostResolver
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mType
=
=
TRRTYPE_TXT
)
{
(
void
)
mHostResolver
-
>
CompleteLookupByType
(
mRec
error
nullptr
0
mPB
)
;
}
else
{
RefPtr
<
AddrInfo
>
ai
=
new
AddrInfo
(
mHost
mType
)
;
(
void
)
mHostResolver
-
>
CompleteLookup
(
mRec
error
ai
mPB
mOriginSuffix
)
;
}
mHostResolver
=
nullptr
;
mRec
=
nullptr
;
return
NS_OK
;
}
nsresult
TRR
:
:
On200Response
(
)
{
nsresult
rv
=
DohDecode
(
mHost
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
!
mDNS
.
mAddresses
.
getFirst
(
)
&
&
!
mCname
.
IsEmpty
(
)
&
&
mType
!
=
TRRTYPE_TXT
)
{
nsCString
cname
=
mCname
;
LOG
(
(
"
TRR
:
check
for
CNAME
record
for
%
s
within
previous
response
\
n
"
cname
.
get
(
)
)
)
;
rv
=
DohDecode
(
cname
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mDNS
.
mAddresses
.
getFirst
(
)
)
{
LOG
(
(
"
TRR
:
Got
the
CNAME
record
without
asking
for
it
\
n
"
)
)
;
ReturnData
(
)
;
return
NS_OK
;
}
mCname
=
cname
;
if
(
!
-
-
mCnameLoop
)
{
LOG
(
(
"
TRR
:
:
On200Response
CNAME
loop
eject
!
\
n
"
)
)
;
}
else
{
LOG
(
(
"
TRR
:
:
On200Response
CNAME
%
s
=
>
%
s
(
%
u
)
\
n
"
mHost
.
get
(
)
mCname
.
get
(
)
mCnameLoop
)
)
;
RefPtr
<
TRR
>
trr
=
new
TRR
(
mHostResolver
mRec
mCname
mType
mCnameLoop
mPB
)
;
rv
=
NS_DispatchToMainThread
(
trr
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
rv
;
}
}
}
else
{
ReturnData
(
)
;
return
NS_OK
;
}
}
else
{
LOG
(
(
"
TRR
:
:
On200Response
DohDecode
%
x
\
n
"
(
int
)
rv
)
)
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
TRR
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatusCode
)
{
LOG
(
(
"
TRR
:
OnStopRequest
%
p
%
s
%
d
failed
=
%
d
code
=
%
X
\
n
"
this
mHost
.
get
(
)
mType
mFailed
(
unsigned
int
)
aStatusCode
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
channel
.
swap
(
mChannel
)
;
gTRRService
-
>
TRRIsOkay
(
NS_SUCCEEDED
(
aStatusCode
)
?
TRRService
:
:
OKAY_NORMAL
:
TRRService
:
:
OKAY_BAD
)
;
if
(
!
mFailed
&
&
NS_SUCCEEDED
(
aStatusCode
)
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aRequest
)
;
if
(
!
httpChannel
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
NS_OK
;
nsAutoCString
contentType
;
httpChannel
-
>
GetContentType
(
contentType
)
;
if
(
contentType
.
Length
(
)
&
&
!
contentType
.
LowerCaseEqualsLiteral
(
"
application
/
dns
-
message
"
)
)
{
LOG
(
(
"
TRR
:
OnStopRequest
%
p
%
s
%
d
wrong
content
type
%
s
\
n
"
this
mHost
.
get
(
)
mType
contentType
.
get
(
)
)
)
;
FailData
(
NS_ERROR_UNEXPECTED
)
;
return
NS_OK
;
}
uint32_t
httpStatus
;
rv
=
httpChannel
-
>
GetResponseStatus
(
&
httpStatus
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
httpStatus
=
=
200
)
{
rv
=
On200Response
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
rv
;
}
}
else
{
LOG
(
(
"
TRR
:
OnStopRequest
:
%
d
%
p
rv
%
x
httpStatus
%
d
\
n
"
__LINE__
this
(
int
)
rv
httpStatus
)
)
;
}
}
LOG
(
(
"
TRR
:
OnStopRequest
%
p
status
%
x
mFailed
%
d
\
n
"
this
(
int
)
aStatusCode
mFailed
)
)
;
FailData
(
NS_ERROR_UNKNOWN_HOST
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TRR
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aInputStream
uint64_t
aOffset
const
uint32_t
aCount
)
{
LOG
(
(
"
TRR
:
OnDataAvailable
%
p
%
s
%
d
failed
=
%
d
aCount
=
%
u
\
n
"
this
mHost
.
get
(
)
mType
mFailed
(
unsigned
int
)
aCount
)
)
;
if
(
mFailed
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aCount
+
mBodySize
>
kMaxSize
)
{
LOG
(
(
"
TRR
:
:
OnDataAvailable
:
%
d
fail
\
n
"
__LINE__
)
)
;
mFailed
=
true
;
return
NS_ERROR_FAILURE
;
}
uint32_t
count
;
nsresult
rv
=
aInputStream
-
>
Read
(
(
char
*
)
mResponse
+
mBodySize
aCount
&
count
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
:
OnDataAvailable
:
%
d
fail
\
n
"
__LINE__
)
)
;
mFailed
=
true
;
return
rv
;
}
MOZ_ASSERT
(
count
=
=
aCount
)
;
mBodySize
+
=
aCount
;
return
NS_OK
;
}
nsresult
DOHresp
:
:
Add
(
uint32_t
TTL
unsigned
char
*
dns
int
index
uint16_t
len
bool
aLocalAllowed
)
{
nsAutoPtr
<
DOHaddr
>
doh
(
new
DOHaddr
)
;
NetAddr
*
addr
=
&
doh
-
>
mNet
;
if
(
4
=
=
len
)
{
addr
-
>
inet
.
family
=
AF_INET
;
addr
-
>
inet
.
port
=
0
;
addr
-
>
inet
.
ip
=
ntohl
(
get32bit
(
dns
index
)
)
;
}
else
if
(
16
=
=
len
)
{
addr
-
>
inet6
.
family
=
AF_INET6
;
addr
-
>
inet6
.
port
=
0
;
addr
-
>
inet6
.
flowinfo
=
0
;
addr
-
>
inet6
.
scope_id
=
0
;
for
(
int
i
=
0
;
i
<
16
;
i
+
+
index
+
+
)
{
addr
-
>
inet6
.
ip
.
u8
[
i
]
=
dns
[
index
]
;
}
}
else
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
IsIPAddrLocal
(
addr
)
&
&
!
aLocalAllowed
)
{
return
NS_ERROR_FAILURE
;
}
doh
-
>
mTtl
=
TTL
;
if
(
LOG_ENABLED
(
)
)
{
char
buf
[
128
]
;
NetAddrToString
(
addr
buf
sizeof
(
buf
)
)
;
LOG
(
(
"
DOHresp
:
Add
%
s
\
n
"
buf
)
)
;
}
mAddresses
.
insertBack
(
doh
.
forget
(
)
)
;
return
NS_OK
;
}
class
ProxyCancel
:
public
Runnable
{
public
:
explicit
ProxyCancel
(
TRR
*
aTRR
)
:
Runnable
(
"
proxyTrrCancel
"
)
mTRR
(
aTRR
)
{
}
NS_IMETHOD
Run
(
)
override
{
mTRR
-
>
Cancel
(
)
;
mTRR
=
nullptr
;
return
NS_OK
;
}
private
:
RefPtr
<
TRR
>
mTRR
;
}
;
void
TRR
:
:
Cancel
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_DispatchToMainThread
(
new
ProxyCancel
(
this
)
)
;
return
;
}
if
(
mChannel
)
{
LOG
(
(
"
TRR
:
%
p
canceling
Channel
%
p
%
s
%
d
\
n
"
this
mChannel
.
get
(
)
mHost
.
get
(
)
mType
)
)
;
mChannel
-
>
Cancel
(
NS_ERROR_ABORT
)
;
gTRRService
-
>
TRRIsOkay
(
TRRService
:
:
OKAY_TIMEOUT
)
;
}
}
#
undef
LOG
}
}
