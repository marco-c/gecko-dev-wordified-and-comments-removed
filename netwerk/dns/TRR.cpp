#
include
"
DNS
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsHttpHandler
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsIUploadChannel2
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
TRR
.
h
"
#
include
"
TRRService
.
h
"
#
include
"
TRRServiceChannel
.
h
"
#
include
"
TRRLoadInfo
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
namespace
net
{
#
undef
LOG
extern
mozilla
:
:
LazyLogModule
gHostResolverLog
;
#
define
LOG
(
args
)
MOZ_LOG
(
gHostResolverLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
mozilla
:
:
net
:
:
gHostResolverLog
mozilla
:
:
LogLevel
:
:
Debug
)
NS_IMPL_ISUPPORTS
(
TRR
nsIHttpPushListener
nsIInterfaceRequestor
nsIStreamListener
nsIRunnable
)
const
uint8_t
kDNS_CLASS_IN
=
1
;
NS_IMETHODIMP
TRR
:
:
Notify
(
nsITimer
*
aTimer
)
{
if
(
aTimer
=
=
mTimeout
)
{
mTimeout
=
nullptr
;
Cancel
(
)
;
}
else
{
MOZ_CRASH
(
"
Unknown
timer
"
)
;
}
return
NS_OK
;
}
nsresult
TRR
:
:
DohEncode
(
nsCString
&
aBody
bool
aDisableECS
)
{
aBody
.
Truncate
(
)
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
0x01
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
1
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
aDisableECS
?
1
:
'
\
0
'
;
int32_t
index
=
0
;
int32_t
offset
=
0
;
do
{
bool
dotFound
=
false
;
int32_t
labelLength
;
index
=
mHost
.
FindChar
(
'
.
'
offset
)
;
if
(
kNotFound
!
=
index
)
{
dotFound
=
true
;
labelLength
=
index
-
offset
;
}
else
{
labelLength
=
mHost
.
Length
(
)
-
offset
;
}
if
(
labelLength
>
63
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
labelLength
>
0
)
{
aBody
+
=
static_cast
<
unsigned
char
>
(
labelLength
)
;
nsDependentCSubstring
label
=
Substring
(
mHost
offset
labelLength
)
;
aBody
.
Append
(
label
)
;
}
if
(
!
dotFound
)
{
aBody
+
=
'
\
0
'
;
break
;
}
offset
+
=
labelLength
+
1
;
}
while
(
true
)
;
aBody
+
=
static_cast
<
uint8_t
>
(
mType
>
>
8
)
;
aBody
+
=
static_cast
<
uint8_t
>
(
mType
)
;
aBody
+
=
'
\
0
'
;
aBody
+
=
kDNS_CLASS_IN
;
if
(
aDisableECS
)
{
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
41
;
aBody
+
=
16
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
8
;
aBody
+
=
'
\
0
'
;
aBody
+
=
8
;
aBody
+
=
'
\
0
'
;
aBody
+
=
4
;
aBody
+
=
'
\
0
'
;
aBody
+
=
1
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TRR
:
:
Run
(
)
{
MOZ_ASSERT_IF
(
XRE_IsParentProcess
(
)
&
&
gTRRService
NS_IsMainThread
(
)
|
|
gTRRService
-
>
IsOnTRRThread
(
)
)
;
MOZ_ASSERT_IF
(
XRE_IsSocketProcess
(
)
NS_IsMainThread
(
)
)
;
if
(
(
gTRRService
=
=
nullptr
)
|
|
NS_FAILED
(
SendHTTPRequest
(
)
)
)
{
RecordReason
(
nsHostRecord
:
:
TRR_SEND_FAILED
)
;
FailData
(
NS_ERROR_FAILURE
)
;
}
return
NS_OK
;
}
static
void
InitHttpHandler
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIIOService
>
ios
=
do_GetIOService
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
rv
=
ios
-
>
GetProtocolHandler
(
"
http
"
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
}
nsresult
TRR
:
:
CreateChannelHelper
(
nsIURI
*
aUri
nsIChannel
*
*
aResult
)
{
*
aResult
=
nullptr
;
if
(
NS_IsMainThread
(
)
&
&
!
XRE_IsSocketProcess
(
)
)
{
nsresult
rv
;
nsCOMPtr
<
nsIIOService
>
ios
(
do_GetIOService
(
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_NewChannel
(
aResult
aUri
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
nullptr
nullptr
nullptr
nullptr
nsIRequest
:
:
LOAD_NORMAL
ios
)
;
}
if
(
!
gHttpHandler
)
{
nsCOMPtr
<
nsIEventTarget
>
main
=
GetMainThreadEventTarget
(
)
;
if
(
main
)
{
SyncRunnable
:
:
DispatchToThread
(
main
new
SyncRunnable
(
NS_NewRunnableFunction
(
"
InitHttpHandler
"
[
]
(
)
{
InitHttpHandler
(
)
;
}
)
)
)
;
}
}
if
(
!
gHttpHandler
)
{
return
NS_ERROR_UNEXPECTED
;
}
RefPtr
<
TRRLoadInfo
>
loadInfo
=
new
TRRLoadInfo
(
aUri
nsIContentPolicy
:
:
TYPE_OTHER
)
;
return
gHttpHandler
-
>
CreateTRRServiceChannel
(
aUri
nullptr
0
nullptr
loadInfo
aResult
)
;
}
nsresult
TRR
:
:
SendHTTPRequest
(
)
{
if
(
(
mType
!
=
TRRTYPE_A
)
&
&
(
mType
!
=
TRRTYPE_AAAA
)
&
&
(
mType
!
=
TRRTYPE_NS
)
&
&
(
mType
!
=
TRRTYPE_TXT
)
&
&
(
mType
!
=
TRRTYPE_HTTPSSVC
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
(
(
mType
=
=
TRRTYPE_A
)
|
|
(
mType
=
=
TRRTYPE_AAAA
)
)
&
&
mRec
-
>
mEffectiveTRRMode
!
=
nsIRequest
:
:
TRR_ONLY_MODE
)
{
MOZ_ASSERT
(
mRec
)
;
if
(
UseDefaultServer
(
)
&
&
gTRRService
-
>
IsTemporarilyBlocked
(
mHost
mOriginSuffix
mPB
true
)
)
{
if
(
mType
=
=
TRRTYPE_A
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
DNS_TRR_BLACKLISTED2
TRRService
:
:
AutoDetectedKey
(
)
true
)
;
}
RecordReason
(
nsHostRecord
:
:
TRR_HOST_BLOCKED_TEMPORARY
)
;
return
NS_ERROR_UNKNOWN_HOST
;
}
if
(
gTRRService
-
>
IsExcludedFromTRR
(
mHost
)
)
{
RecordReason
(
nsHostRecord
:
:
TRR_EXCLUDED
)
;
return
NS_ERROR_UNKNOWN_HOST
;
}
if
(
UseDefaultServer
(
)
&
&
(
mType
=
=
TRRTYPE_A
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
DNS_TRR_BLACKLISTED2
TRRService
:
:
AutoDetectedKey
(
)
false
)
;
}
}
bool
useGet
=
StaticPrefs
:
:
network_trr_useGET
(
)
;
nsAutoCString
body
;
nsCOMPtr
<
nsIURI
>
dnsURI
;
bool
disableECS
=
StaticPrefs
:
:
network_trr_disable_ECS
(
)
;
nsresult
rv
;
LOG
(
(
"
TRR
:
:
SendHTTPRequest
resolve
%
s
type
%
u
\
n
"
mHost
.
get
(
)
mType
)
)
;
if
(
useGet
)
{
nsAutoCString
tmp
;
rv
=
DohEncode
(
tmp
disableECS
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
Base64URLEncode
(
tmp
.
Length
(
)
reinterpret_cast
<
const
unsigned
char
*
>
(
tmp
.
get
(
)
)
Base64URLEncodePaddingPolicy
:
:
Omit
body
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
uri
;
if
(
UseDefaultServer
(
)
)
{
gTRRService
-
>
GetURI
(
uri
)
;
}
else
{
uri
=
mRec
-
>
mTrrServer
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
dnsURI
)
uri
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
SendHTTPRequest
:
NewURI
failed
!
\
n
"
)
)
;
return
rv
;
}
nsAutoCString
query
;
rv
=
dnsURI
-
>
GetQuery
(
query
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
query
.
IsEmpty
(
)
)
{
query
.
Assign
(
"
?
dns
=
"
_ns
)
;
}
else
{
query
.
Append
(
"
&
dns
=
"
_ns
)
;
}
query
.
Append
(
body
)
;
rv
=
NS_MutateURI
(
dnsURI
)
.
SetQuery
(
query
)
.
Finalize
(
dnsURI
)
;
LOG
(
(
"
TRR
:
:
SendHTTPRequest
GET
dns
=
%
s
\
n
"
body
.
get
(
)
)
)
;
}
else
{
rv
=
DohEncode
(
body
disableECS
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
uri
;
if
(
UseDefaultServer
(
)
)
{
gTRRService
-
>
GetURI
(
uri
)
;
}
else
{
uri
=
mRec
-
>
mTrrServer
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
dnsURI
)
uri
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
SendHTTPRequest
:
NewURI
failed
!
\
n
"
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
CreateChannelHelper
(
dnsURI
getter_AddRefs
(
channel
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
channel
)
{
LOG
(
(
"
TRR
:
SendHTTPRequest
:
NewChannel
failed
!
\
n
"
)
)
;
return
rv
;
}
channel
-
>
SetLoadFlags
(
nsIRequest
:
:
LOAD_ANONYMOUS
|
nsIRequest
:
:
INHIBIT_CACHING
|
nsIRequest
:
:
LOAD_BYPASS_CACHE
|
nsIChannel
:
:
LOAD_BYPASS_URL_CLASSIFIER
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
channel
-
>
SetNotificationCallbacks
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
channel
)
;
if
(
!
httpChannel
)
{
return
NS_ERROR_UNEXPECTED
;
}
rv
=
httpChannel
-
>
SetTRRMode
(
nsIRequest
:
:
TRR_DISABLED_MODE
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
httpChannel
-
>
SetRequestHeader
(
"
Accept
"
_ns
"
application
/
dns
-
message
"
_ns
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
cred
;
if
(
UseDefaultServer
(
)
)
{
gTRRService
-
>
GetCredentials
(
cred
)
;
}
if
(
!
cred
.
IsEmpty
(
)
)
{
rv
=
httpChannel
-
>
SetRequestHeader
(
"
Authorization
"
_ns
cred
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
channel
)
;
if
(
!
internalChannel
)
{
return
NS_ERROR_UNEXPECTED
;
}
rv
=
internalChannel
-
>
SetInitialRwin
(
127
*
1024
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
internalChannel
-
>
SetIsTRRServiceChannel
(
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mAllowRFC1918
=
StaticPrefs
:
:
network_trr_allow_rfc1918
(
)
;
if
(
useGet
)
{
rv
=
httpChannel
-
>
SetRequestMethod
(
"
GET
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
nsIUploadChannel2
>
uploadChannel
=
do_QueryInterface
(
httpChannel
)
;
if
(
!
uploadChannel
)
{
return
NS_ERROR_UNEXPECTED
;
}
uint32_t
streamLength
=
body
.
Length
(
)
;
nsCOMPtr
<
nsIInputStream
>
uploadStream
;
rv
=
NS_NewCStringInputStream
(
getter_AddRefs
(
uploadStream
)
std
:
:
move
(
body
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
uploadChannel
-
>
ExplicitSetUploadStream
(
uploadStream
"
application
/
dns
-
message
"
_ns
streamLength
"
POST
"
_ns
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
SetupTRRServiceChannelInternal
(
httpChannel
useGet
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
httpChannel
-
>
AsyncOpen
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
RefPtr
<
AddrHostRecord
>
addrRec
=
do_QueryObject
(
mRec
)
;
if
(
addrRec
)
{
addrRec
-
>
mTRRUsed
=
true
;
}
NS_NewTimerWithCallback
(
getter_AddRefs
(
mTimeout
)
this
gTRRService
-
>
GetRequestTimeout
(
)
nsITimer
:
:
TYPE_ONE_SHOT
)
;
mChannel
=
channel
;
return
NS_OK
;
}
nsresult
TRR
:
:
SetupTRRServiceChannelInternal
(
nsIHttpChannel
*
aChannel
bool
aUseGet
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
aChannel
;
MOZ_ASSERT
(
httpChannel
)
;
nsresult
rv
=
NS_OK
;
if
(
!
aUseGet
)
{
rv
=
httpChannel
-
>
SetRequestHeader
(
"
Cache
-
Control
"
_ns
"
no
-
store
"
_ns
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
StaticPrefs
:
:
network_trr_send_accept_language_headers
(
)
)
{
rv
=
httpChannel
-
>
SetRequestHeader
(
"
Accept
-
Language
"
_ns
EmptyCString
(
)
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
StaticPrefs
:
:
network_trr_send_user_agent_headers
(
)
)
{
rv
=
httpChannel
-
>
SetRequestHeader
(
"
User
-
Agent
"
_ns
EmptyCString
(
)
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
StaticPrefs
:
:
network_trr_send_empty_accept_encoding_headers
(
)
)
{
rv
=
httpChannel
-
>
SetEmptyRequestHeader
(
"
Accept
-
Encoding
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
NS_FAILED
(
httpChannel
-
>
SetContentType
(
"
application
/
dns
-
message
"
_ns
)
)
)
{
LOG
(
(
"
TRR
:
:
SetupTRRServiceChannelInternal
:
couldn
'
t
set
content
-
type
!
\
n
"
)
)
;
}
nsCOMPtr
<
nsITimedChannel
>
timedChan
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
timedChan
)
{
timedChan
-
>
SetTimingEnabled
(
true
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TRR
:
:
GetInterface
(
const
nsIID
&
iid
void
*
*
result
)
{
if
(
!
iid
.
Equals
(
NS_GET_IID
(
nsIHttpPushListener
)
)
)
{
return
NS_ERROR_NO_INTERFACE
;
}
nsCOMPtr
<
nsIHttpPushListener
>
copy
(
this
)
;
*
result
=
copy
.
forget
(
)
.
take
(
)
;
return
NS_OK
;
}
nsresult
TRR
:
:
DohDecodeQuery
(
const
nsCString
&
query
nsCString
&
host
enum
TrrType
&
type
)
{
FallibleTArray
<
uint8_t
>
binary
;
bool
found_dns
=
false
;
LOG
(
(
"
TRR
:
:
DohDecodeQuery
%
s
!
\
n
"
query
.
get
(
)
)
)
;
nsCCharSeparatedTokenizer
tokenizer
(
query
'
&
'
)
;
nsAutoCString
data
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
const
nsACString
&
token
=
tokenizer
.
nextToken
(
)
;
nsDependentCSubstring
dns
=
Substring
(
token
0
4
)
;
nsAutoCString
check
(
dns
)
;
if
(
check
.
Equals
(
"
dns
=
"
)
)
{
nsDependentCSubstring
q
=
Substring
(
token
4
-
1
)
;
data
=
q
;
found_dns
=
true
;
break
;
}
}
if
(
!
found_dns
)
{
LOG
(
(
"
TRR
:
:
DohDecodeQuery
no
dns
=
in
pushed
URI
query
string
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
nsresult
rv
=
Base64URLDecode
(
data
Base64URLDecodePaddingPolicy
:
:
Ignore
binary
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
avail
=
binary
.
Length
(
)
;
if
(
avail
<
12
)
{
return
NS_ERROR_FAILURE
;
}
if
(
(
binary
[
2
]
&
0xf8
)
!
=
0
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
qdcount
=
(
binary
[
4
]
<
<
8
)
+
binary
[
5
]
;
if
(
!
qdcount
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
index
=
12
;
uint32_t
length
=
0
;
host
.
Truncate
(
)
;
do
{
if
(
avail
<
(
index
+
1
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
length
=
binary
[
index
]
;
if
(
length
)
{
if
(
host
.
Length
(
)
)
{
host
.
Append
(
"
.
"
)
;
}
if
(
avail
<
(
index
+
1
+
length
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
host
.
Append
(
(
const
char
*
)
(
&
binary
[
0
]
)
+
index
+
1
length
)
;
}
index
+
=
1
+
length
;
}
while
(
length
)
;
LOG
(
(
"
TRR
:
:
DohDecodeQuery
host
%
s
\
n
"
host
.
get
(
)
)
)
;
if
(
avail
<
(
index
+
2
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
uint16_t
i16
=
0
;
i16
+
=
binary
[
index
]
<
<
8
;
i16
+
=
binary
[
index
+
1
]
;
type
=
(
enum
TrrType
)
i16
;
LOG
(
(
"
TRR
:
:
DohDecodeQuery
type
%
d
\
n
"
(
int
)
type
)
)
;
return
NS_OK
;
}
nsresult
TRR
:
:
ReceivePush
(
nsIHttpChannel
*
pushed
nsHostRecord
*
pushedRec
)
{
if
(
!
mHostResolver
)
{
return
NS_ERROR_UNEXPECTED
;
}
LOG
(
(
"
TRR
:
:
ReceivePush
:
PUSH
incoming
!
\
n
"
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
pushed
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsAutoCString
query
;
if
(
uri
)
{
uri
-
>
GetQuery
(
query
)
;
}
PRNetAddr
tempAddr
;
if
(
NS_FAILED
(
DohDecodeQuery
(
query
mHost
mType
)
)
|
|
(
PR_StringToNetAddr
(
mHost
.
get
(
)
&
tempAddr
)
=
=
PR_SUCCESS
)
)
{
LOG
(
(
"
TRR
:
:
ReceivePush
failed
to
decode
%
s
\
n
"
mHost
.
get
(
)
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
(
mType
!
=
TRRTYPE_A
)
&
&
(
mType
!
=
TRRTYPE_AAAA
)
&
&
(
mType
!
=
TRRTYPE_TXT
)
&
&
(
mType
!
=
TRRTYPE_HTTPSSVC
)
)
{
LOG
(
(
"
TRR
:
:
ReceivePush
unknown
type
%
d
\
n
"
mType
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
gTRRService
-
>
IsExcludedFromTRR
(
mHost
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
type
=
nsIDNSService
:
:
RESOLVE_TYPE_DEFAULT
;
if
(
mType
=
=
TRRTYPE_TXT
)
{
type
=
nsIDNSService
:
:
RESOLVE_TYPE_TXT
;
}
else
if
(
mType
=
=
TRRTYPE_HTTPSSVC
)
{
type
=
nsIDNSService
:
:
RESOLVE_TYPE_HTTPSSVC
;
}
RefPtr
<
nsHostRecord
>
hostRecord
;
nsresult
rv
;
rv
=
mHostResolver
-
>
GetHostRecord
(
mHost
EmptyCString
(
)
type
pushedRec
-
>
flags
pushedRec
-
>
af
pushedRec
-
>
pb
pushedRec
-
>
originSuffix
getter_AddRefs
(
hostRecord
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
hostRecord
-
>
mEffectiveTRRMode
=
=
nsIRequest
:
:
TRR_DEFAULT_MODE
)
{
hostRecord
-
>
mEffectiveTRRMode
=
pushedRec
-
>
mEffectiveTRRMode
;
}
rv
=
mHostResolver
-
>
TrrLookup_unlocked
(
hostRecord
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
pushed
-
>
AsyncOpen
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mChannel
=
pushed
;
mRec
.
swap
(
hostRecord
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TRR
:
:
OnPush
(
nsIHttpChannel
*
associated
nsIHttpChannel
*
pushed
)
{
LOG
(
(
"
TRR
:
:
OnPush
entry
\
n
"
)
)
;
MOZ_ASSERT
(
associated
=
=
mChannel
)
;
if
(
!
mRec
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
UseDefaultServer
(
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
TRR
>
trr
=
new
TRR
(
mHostResolver
mPB
)
;
return
trr
-
>
ReceivePush
(
pushed
mRec
)
;
}
NS_IMETHODIMP
TRR
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
LOG
(
(
"
TRR
:
:
OnStartRequest
%
p
%
s
%
d
\
n
"
this
mHost
.
get
(
)
mType
)
)
;
nsresult
status
=
NS_OK
;
aRequest
-
>
GetStatus
(
&
status
)
;
if
(
NS_FAILED
(
status
)
)
{
if
(
NS_IsOffline
(
)
)
{
RecordReason
(
nsHostRecord
:
:
TRR_IS_OFFLINE
)
;
}
switch
(
status
)
{
case
NS_ERROR_UNKNOWN_HOST
:
RecordReason
(
nsHostRecord
:
:
TRR_CHANNEL_DNS_FAIL
)
;
break
;
case
NS_ERROR_OFFLINE
:
RecordReason
(
nsHostRecord
:
:
TRR_IS_OFFLINE
)
;
break
;
case
NS_ERROR_NET_RESET
:
RecordReason
(
nsHostRecord
:
:
TRR_NET_RESET
)
;
break
;
case
NS_ERROR_NET_TIMEOUT
:
RecordReason
(
nsHostRecord
:
:
TRR_NET_TIMEOUT
)
;
break
;
case
NS_ERROR_PROXY_CONNECTION_REFUSED
:
RecordReason
(
nsHostRecord
:
:
TRR_NET_REFUSED
)
;
break
;
case
NS_ERROR_NET_INTERRUPT
:
RecordReason
(
nsHostRecord
:
:
TRR_NET_INTERRUPT
)
;
break
;
case
NS_ERROR_NET_INADEQUATE_SECURITY
:
RecordReason
(
nsHostRecord
:
:
TRR_NET_INADEQ_SEQURITY
)
;
break
;
default
:
RecordReason
(
nsHostRecord
:
:
TRR_UNKNOWN_CHANNEL_FAILURE
)
;
}
}
return
NS_OK
;
}
static
uint16_t
get16bit
(
const
unsigned
char
*
aData
unsigned
int
index
)
{
return
(
(
aData
[
index
]
<
<
8
)
|
aData
[
index
+
1
]
)
;
}
static
uint32_t
get32bit
(
const
unsigned
char
*
aData
unsigned
int
index
)
{
return
(
aData
[
index
]
<
<
24
)
|
(
aData
[
index
+
1
]
<
<
16
)
|
(
aData
[
index
+
2
]
<
<
8
)
|
aData
[
index
+
3
]
;
}
nsresult
TRR
:
:
PassQName
(
unsigned
int
&
index
)
{
uint8_t
length
;
do
{
if
(
mBodySize
<
(
index
+
1
)
)
{
LOG
(
(
"
TRR
:
PassQName
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
length
=
static_cast
<
uint8_t
>
(
mResponse
[
index
]
)
;
if
(
(
length
&
0xc0
)
=
=
0xc0
)
{
if
(
mBodySize
<
(
index
+
2
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
2
;
break
;
}
if
(
length
&
0xc0
)
{
LOG
(
(
"
TRR
:
illegal
label
length
byte
(
%
x
)
at
index
%
d
\
n
"
length
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
mBodySize
<
(
index
+
1
+
length
)
)
{
LOG
(
(
"
TRR
:
PassQName
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
1
+
length
;
}
while
(
length
)
;
return
NS_OK
;
}
nsresult
TRR
:
:
GetQname
(
nsACString
&
aQname
unsigned
int
&
aIndex
)
{
uint8_t
clength
=
0
;
unsigned
int
cindex
=
aIndex
;
unsigned
int
loop
=
128
;
unsigned
int
endindex
=
0
;
do
{
if
(
cindex
>
=
mBodySize
)
{
LOG
(
(
"
TRR
:
bad
Qname
packet
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
clength
=
static_cast
<
uint8_t
>
(
mResponse
[
cindex
]
)
;
if
(
(
clength
&
0xc0
)
=
=
0xc0
)
{
if
(
(
cindex
+
1
)
>
=
mBodySize
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
newpos
=
(
clength
&
0x3f
)
<
<
8
|
mResponse
[
cindex
+
1
]
;
if
(
!
endindex
)
{
endindex
=
cindex
+
2
;
}
cindex
=
newpos
;
continue
;
}
if
(
clength
&
0xc0
)
{
LOG
(
(
"
TRR
:
bad
Qname
packet
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
cindex
+
+
;
if
(
clength
)
{
if
(
!
aQname
.
IsEmpty
(
)
)
{
aQname
.
Append
(
"
.
"
)
;
}
if
(
(
cindex
+
clength
)
>
mBodySize
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
aQname
.
Append
(
(
const
char
*
)
(
&
mResponse
[
cindex
]
)
clength
)
;
cindex
+
=
clength
;
}
}
while
(
clength
&
&
-
-
loop
)
;
if
(
!
loop
)
{
LOG
(
(
"
TRR
:
:
DohDecode
pointer
loop
error
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
!
endindex
)
{
endindex
=
cindex
;
}
aIndex
=
endindex
;
return
NS_OK
;
}
nsresult
TRR
:
:
DohDecode
(
nsCString
&
aHost
)
{
unsigned
int
index
=
12
;
uint8_t
length
;
nsAutoCString
host
;
nsresult
rv
;
LOG
(
(
"
doh
decode
%
s
%
d
bytes
\
n
"
aHost
.
get
(
)
mBodySize
)
)
;
mCname
.
Truncate
(
)
;
if
(
mBodySize
<
12
|
|
mResponse
[
0
]
|
|
mResponse
[
1
]
)
{
LOG
(
(
"
TRR
bad
incoming
DOH
eject
!
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint8_t
rcode
=
mResponse
[
3
]
&
0x0F
;
if
(
rcode
)
{
LOG
(
(
"
TRR
Decode
%
s
RCODE
%
d
\
n
"
aHost
.
get
(
)
rcode
)
)
;
return
NS_ERROR_FAILURE
;
}
uint16_t
questionRecords
=
get16bit
(
mResponse
4
)
;
while
(
questionRecords
)
{
do
{
if
(
mBodySize
<
(
index
+
1
)
)
{
LOG
(
(
"
TRR
Decode
1
index
:
%
u
size
:
%
u
"
index
mBodySize
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
length
=
static_cast
<
uint8_t
>
(
mResponse
[
index
]
)
;
if
(
length
)
{
if
(
host
.
Length
(
)
)
{
host
.
Append
(
"
.
"
)
;
}
if
(
mBodySize
<
(
index
+
1
+
length
)
)
{
LOG
(
(
"
TRR
Decode
2
index
:
%
u
size
:
%
u
len
:
%
u
"
index
mBodySize
length
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
host
.
Append
(
(
(
char
*
)
mResponse
)
+
index
+
1
length
)
;
}
index
+
=
1
+
length
;
}
while
(
length
)
;
if
(
mBodySize
<
(
index
+
4
)
)
{
LOG
(
(
"
TRR
Decode
3
index
:
%
u
size
:
%
u
"
index
mBodySize
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
4
;
questionRecords
-
-
;
}
uint16_t
answerRecords
=
get16bit
(
mResponse
6
)
;
LOG
(
(
"
TRR
Decode
:
%
d
answer
records
(
%
u
bytes
body
)
%
s
index
=
%
u
\
n
"
answerRecords
mBodySize
host
.
get
(
)
index
)
)
;
while
(
answerRecords
)
{
nsAutoCString
qname
;
rv
=
GetQname
(
qname
index
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mBodySize
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
+
2
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
TYPE
=
get16bit
(
mResponse
index
)
;
if
(
(
TYPE
!
=
TRRTYPE_CNAME
)
&
&
(
TYPE
!
=
TRRTYPE_HTTPSSVC
)
&
&
(
TYPE
!
=
static_cast
<
uint16_t
>
(
mType
)
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
asked
for
type
%
d
got
%
d
\
n
"
__LINE__
mType
TYPE
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
index
+
=
2
;
if
(
mBodySize
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
+
2
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
CLASS
=
get16bit
(
mResponse
index
)
;
if
(
kDNS_CLASS_IN
!
=
CLASS
)
{
LOG
(
(
"
TRR
bad
CLASS
(
%
u
)
at
index
%
d
\
n
"
CLASS
index
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
index
+
=
2
;
if
(
mBodySize
<
(
index
+
4
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint32_t
TTL
=
get32bit
(
mResponse
index
)
;
index
+
=
4
;
if
(
mBodySize
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
RDLENGTH
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
if
(
mBodySize
<
(
index
+
RDLENGTH
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
RDLENGTH
=
%
d
at
index
%
d
\
n
"
__LINE__
RDLENGTH
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
bool
responseMatchesQuestion
=
(
qname
.
Length
(
)
=
=
aHost
.
Length
(
)
|
|
(
aHost
.
Length
(
)
=
=
qname
.
Length
(
)
+
1
&
&
aHost
.
Last
(
)
=
=
'
.
'
)
)
&
&
qname
.
Compare
(
aHost
.
BeginReading
(
)
true
qname
.
Length
(
)
)
=
=
0
;
if
(
responseMatchesQuestion
)
{
switch
(
TYPE
)
{
case
TRRTYPE_A
:
if
(
RDLENGTH
!
=
4
)
{
LOG
(
(
"
TRR
bad
length
for
A
(
%
u
)
\
n
"
RDLENGTH
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
rv
=
mDNS
.
Add
(
TTL
mResponse
index
RDLENGTH
mAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
DohDecode
failed
:
local
IP
addresses
or
unknown
IP
"
"
family
\
n
"
)
)
;
return
rv
;
}
break
;
case
TRRTYPE_AAAA
:
if
(
RDLENGTH
!
=
16
)
{
LOG
(
(
"
TRR
bad
length
for
AAAA
(
%
u
)
\
n
"
RDLENGTH
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
rv
=
mDNS
.
Add
(
TTL
mResponse
index
RDLENGTH
mAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
got
unique
/
local
IPv6
address
!
\
n
"
)
)
;
return
rv
;
}
break
;
case
TRRTYPE_NS
:
break
;
case
TRRTYPE_CNAME
:
if
(
mCname
.
IsEmpty
(
)
)
{
nsAutoCString
qname
;
unsigned
int
qnameindex
=
index
;
rv
=
GetQname
(
qname
qnameindex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
qname
.
IsEmpty
(
)
)
{
ToLowerCase
(
qname
)
;
mCname
=
qname
;
LOG
(
(
"
TRR
:
:
DohDecode
CNAME
host
%
s
=
>
%
s
\
n
"
host
.
get
(
)
mCname
.
get
(
)
)
)
;
}
else
{
LOG
(
(
"
TRR
:
:
DohDecode
empty
CNAME
for
host
%
s
!
\
n
"
host
.
get
(
)
)
)
;
}
}
else
{
LOG
(
(
"
TRR
:
:
DohDecode
CNAME
-
ignoring
another
entry
\
n
"
)
)
;
}
break
;
case
TRRTYPE_TXT
:
{
nsAutoCString
txt
;
unsigned
int
txtIndex
=
index
;
uint16_t
available
=
RDLENGTH
;
while
(
available
>
0
)
{
uint8_t
characterStringLen
=
mResponse
[
txtIndex
+
+
]
;
available
-
-
;
if
(
characterStringLen
>
available
)
{
LOG
(
(
"
TRR
:
:
DohDecode
MALFORMED
TXT
RECORD
\
n
"
)
)
;
break
;
}
txt
.
Append
(
(
const
char
*
)
(
&
mResponse
[
txtIndex
]
)
characterStringLen
)
;
txtIndex
+
=
characterStringLen
;
available
-
=
characterStringLen
;
}
if
(
!
mResult
.
is
<
TypeRecordTxt
>
(
)
)
{
mResult
=
AsVariant
(
CopyableTArray
<
nsCString
>
(
)
)
;
}
{
auto
&
results
=
mResult
.
as
<
TypeRecordTxt
>
(
)
;
results
.
AppendElement
(
txt
)
;
}
if
(
mTTL
>
TTL
)
{
mTTL
=
TTL
;
}
LOG
(
(
"
TRR
:
:
DohDecode
TXT
host
%
s
=
>
%
s
\
n
"
host
.
get
(
)
txt
.
get
(
)
)
)
;
break
;
}
case
TRRTYPE_HTTPSSVC
:
{
struct
SVCB
parsed
;
int32_t
lastSvcParamKey
=
-
1
;
unsigned
int
svcbIndex
=
index
;
CheckedInt
<
uint16_t
>
available
=
RDLENGTH
;
if
(
available
.
value
(
)
<
3
)
{
return
NS_ERROR_UNEXPECTED
;
}
parsed
.
mSvcFieldPriority
=
get16bit
(
mResponse
svcbIndex
)
;
svcbIndex
+
=
2
;
rv
=
GetQname
(
parsed
.
mSvcDomainName
svcbIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
parsed
.
mSvcDomainName
.
IsEmpty
(
)
)
{
if
(
parsed
.
mSvcFieldPriority
=
=
0
)
{
continue
;
}
parsed
.
mSvcDomainName
=
qname
;
}
available
-
=
(
svcbIndex
-
index
)
;
if
(
!
available
.
isValid
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
while
(
available
.
value
(
)
>
=
4
)
{
struct
SvcFieldValue
value
;
uint16_t
key
=
get16bit
(
mResponse
svcbIndex
)
;
svcbIndex
+
=
2
;
if
(
key
<
=
lastSvcParamKey
)
{
LOG
(
(
"
SvcParamKeys
not
in
increasing
order
"
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
lastSvcParamKey
=
key
;
uint16_t
len
=
get16bit
(
mResponse
svcbIndex
)
;
svcbIndex
+
=
2
;
available
-
=
4
+
len
;
if
(
!
available
.
isValid
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
rv
=
ParseSvcParam
(
svcbIndex
key
value
len
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
svcbIndex
+
=
len
;
if
(
key
=
=
SvcParamKeyMandatory
|
|
key
>
SvcParamKeyLast
)
{
continue
;
}
parsed
.
mSvcFieldValue
.
AppendElement
(
value
)
;
}
if
(
mCname
.
IsEmpty
(
)
&
&
parsed
.
mSvcFieldPriority
=
=
0
)
{
if
(
parsed
.
mSvcDomainName
.
IsEmpty
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mCname
=
parsed
.
mSvcDomainName
;
ToLowerCase
(
mCname
)
;
LOG
(
(
"
TRR
:
:
DohDecode
HTTPSSVC
AliasForm
host
%
s
=
>
%
s
\
n
"
host
.
get
(
)
mCname
.
get
(
)
)
)
;
break
;
}
if
(
mType
!
=
TRRTYPE_HTTPSSVC
)
{
break
;
}
if
(
!
mResult
.
is
<
TypeRecordHTTPSSVC
>
(
)
)
{
mResult
=
mozilla
:
:
AsVariant
(
CopyableTArray
<
SVCB
>
(
)
)
;
}
{
auto
&
results
=
mResult
.
as
<
TypeRecordHTTPSSVC
>
(
)
;
results
.
AppendElement
(
parsed
)
;
}
break
;
}
default
:
LOG
(
(
"
TRR
unsupported
TYPE
(
%
u
)
RDLENGTH
%
u
\
n
"
TYPE
RDLENGTH
)
)
;
break
;
}
}
else
{
LOG
(
(
"
TRR
asked
for
%
s
data
but
got
%
s
\
n
"
aHost
.
get
(
)
qname
.
get
(
)
)
)
;
}
index
+
=
RDLENGTH
;
LOG
(
(
"
done
with
record
type
%
u
len
%
u
index
now
%
u
of
%
u
\
n
"
TYPE
RDLENGTH
index
mBodySize
)
)
;
answerRecords
-
-
;
}
uint16_t
nsRecords
=
get16bit
(
mResponse
8
)
;
LOG
(
(
"
TRR
Decode
:
%
d
ns
records
(
%
u
bytes
body
)
\
n
"
nsRecords
mBodySize
)
)
;
while
(
nsRecords
)
{
rv
=
PassQName
(
index
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mBodySize
<
(
index
+
8
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
2
;
index
+
=
2
;
index
+
=
4
;
if
(
mBodySize
<
(
index
+
2
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
RDLENGTH
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
if
(
mBodySize
<
(
index
+
RDLENGTH
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
RDLENGTH
;
LOG
(
(
"
done
with
nsRecord
now
%
u
of
%
u
\
n
"
index
mBodySize
)
)
;
nsRecords
-
-
;
}
uint16_t
arRecords
=
get16bit
(
mResponse
10
)
;
LOG
(
(
"
TRR
Decode
:
%
d
additional
resource
records
(
%
u
bytes
body
)
\
n
"
arRecords
mBodySize
)
)
;
while
(
arRecords
)
{
rv
=
PassQName
(
index
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mBodySize
<
(
index
+
8
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
2
;
index
+
=
2
;
index
+
=
4
;
if
(
mBodySize
<
(
index
+
2
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
RDLENGTH
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
if
(
mBodySize
<
(
index
+
RDLENGTH
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
RDLENGTH
;
LOG
(
(
"
done
with
additional
rr
now
%
u
of
%
u
\
n
"
index
mBodySize
)
)
;
arRecords
-
-
;
}
if
(
index
!
=
mBodySize
)
{
LOG
(
(
"
DohDecode
failed
to
parse
entire
response
body
%
u
out
of
%
u
bytes
\
n
"
index
mBodySize
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
(
mType
!
=
TRRTYPE_NS
)
&
&
mCname
.
IsEmpty
(
)
&
&
!
mDNS
.
mAddresses
.
getFirst
(
)
&
&
mResult
.
is
<
TypeRecordEmpty
>
(
)
)
{
LOG
(
(
"
TRR
:
No
entries
were
stored
!
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mResult
.
is
<
TypeRecordHTTPSSVC
>
(
)
)
{
auto
&
results
=
mResult
.
as
<
TypeRecordHTTPSSVC
>
(
)
;
results
.
Sort
(
)
;
}
return
NS_OK
;
}
nsresult
TRR
:
:
ParseSvcParam
(
unsigned
int
svcbIndex
uint16_t
key
SvcFieldValue
&
field
uint16_t
length
)
{
switch
(
key
)
{
case
SvcParamKeyMandatory
:
{
if
(
length
%
2
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
while
(
length
>
0
)
{
uint16_t
mandatoryKey
=
get16bit
(
mResponse
svcbIndex
)
;
length
-
=
2
;
svcbIndex
+
=
2
;
if
(
mandatoryKey
>
SvcParamKeyLast
)
{
LOG
(
(
"
The
mandatory
field
includes
a
key
we
don
'
t
support
%
u
"
mandatoryKey
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
break
;
}
case
SvcParamKeyAlpn
:
{
field
.
mValue
=
AsVariant
(
SvcParamAlpn
{
.
mValue
=
nsCString
(
(
const
char
*
)
(
&
mResponse
[
svcbIndex
]
)
length
)
}
)
;
break
;
}
case
SvcParamKeyNoDefaultAlpn
:
{
if
(
length
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamNoDefaultAlpn
{
}
)
;
break
;
}
case
SvcParamKeyPort
:
{
if
(
length
!
=
2
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamPort
{
.
mValue
=
get16bit
(
mResponse
svcbIndex
)
}
)
;
break
;
}
case
SvcParamKeyIpv4Hint
:
{
if
(
length
%
4
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamIpv4Hint
(
)
)
;
auto
&
ipv4array
=
field
.
mValue
.
as
<
SvcParamIpv4Hint
>
(
)
.
mValue
;
while
(
length
>
0
)
{
NetAddr
addr
=
{
.
inet
=
{
.
family
=
AF_INET
.
port
=
0
.
ip
=
ntohl
(
get32bit
(
mResponse
svcbIndex
)
)
}
}
;
ipv4array
.
AppendElement
(
addr
)
;
length
-
=
4
;
svcbIndex
+
=
4
;
}
break
;
}
case
SvcParamKeyEchConfig
:
{
field
.
mValue
=
AsVariant
(
SvcParamEchConfig
{
.
mValue
=
nsCString
(
(
const
char
*
)
(
&
mResponse
[
svcbIndex
]
)
length
)
}
)
;
break
;
}
case
SvcParamKeyIpv6Hint
:
{
if
(
length
%
16
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamIpv6Hint
(
)
)
;
auto
&
ipv6array
=
field
.
mValue
.
as
<
SvcParamIpv6Hint
>
(
)
.
mValue
;
while
(
length
>
0
)
{
NetAddr
addr
=
{
{
.
family
=
0
.
data
=
{
0
}
}
}
;
addr
.
inet6
.
family
=
AF_INET6
;
addr
.
inet6
.
port
=
0
;
addr
.
inet6
.
flowinfo
=
0
;
addr
.
inet6
.
scope_id
=
0
;
for
(
int
i
=
0
;
i
<
16
;
i
+
+
svcbIndex
+
+
)
{
addr
.
inet6
.
ip
.
u8
[
i
]
=
mResponse
[
svcbIndex
]
;
}
ipv6array
.
AppendElement
(
addr
)
;
length
-
=
16
;
}
break
;
}
default
:
{
return
NS_OK
;
break
;
}
}
return
NS_OK
;
}
nsresult
TRR
:
:
ReturnData
(
nsIChannel
*
aChannel
)
{
if
(
mType
!
=
TRRTYPE_TXT
&
&
mType
!
=
TRRTYPE_HTTPSSVC
)
{
RefPtr
<
AddrInfo
>
ai
(
new
AddrInfo
(
mHost
mType
)
)
;
DOHaddr
*
item
;
uint32_t
ttl
=
AddrInfo
:
:
NO_TTL_DATA
;
while
(
(
item
=
static_cast
<
DOHaddr
*
>
(
mDNS
.
mAddresses
.
popFirst
(
)
)
)
)
{
PRNetAddr
prAddr
;
NetAddrToPRNetAddr
(
&
item
-
>
mNet
&
prAddr
)
;
auto
*
addrElement
=
new
NetAddrElement
(
&
prAddr
)
;
ai
-
>
AddAddress
(
addrElement
)
;
if
(
item
-
>
mTtl
<
ttl
)
{
ttl
=
item
-
>
mTtl
;
}
}
ai
-
>
ttl
=
ttl
;
nsCOMPtr
<
nsITimedChannel
>
timedChan
=
do_QueryInterface
(
aChannel
)
;
if
(
timedChan
)
{
TimeStamp
asyncOpen
start
end
;
if
(
NS_SUCCEEDED
(
timedChan
-
>
GetAsyncOpen
(
&
asyncOpen
)
)
&
&
!
asyncOpen
.
IsNull
(
)
)
{
ai
-
>
SetTrrFetchDuration
(
(
TimeStamp
:
:
Now
(
)
-
asyncOpen
)
.
ToMilliseconds
(
)
)
;
}
if
(
NS_SUCCEEDED
(
timedChan
-
>
GetRequestStart
(
&
start
)
)
&
&
NS_SUCCEEDED
(
timedChan
-
>
GetResponseEnd
(
&
end
)
)
&
&
!
start
.
IsNull
(
)
&
&
!
end
.
IsNull
(
)
)
{
ai
-
>
SetTrrFetchDurationNetworkOnly
(
(
end
-
start
)
.
ToMilliseconds
(
)
)
;
}
}
if
(
!
mHostResolver
)
{
return
NS_ERROR_FAILURE
;
}
(
void
)
mHostResolver
-
>
CompleteLookup
(
mRec
NS_OK
ai
mPB
mOriginSuffix
mTRRSkippedReason
)
;
mHostResolver
=
nullptr
;
mRec
=
nullptr
;
}
else
{
(
void
)
mHostResolver
-
>
CompleteLookupByType
(
mRec
NS_OK
mResult
mTTL
mPB
)
;
}
return
NS_OK
;
}
nsresult
TRR
:
:
FailData
(
nsresult
error
)
{
if
(
!
mHostResolver
)
{
return
NS_ERROR_FAILURE
;
}
RecordReason
(
nsHostRecord
:
:
TRR_FAILED
)
;
if
(
mType
=
=
TRRTYPE_TXT
|
|
mType
=
=
TRRTYPE_HTTPSSVC
)
{
TypeRecordResultType
empty
(
Nothing
{
}
)
;
(
void
)
mHostResolver
-
>
CompleteLookupByType
(
mRec
error
empty
0
mPB
)
;
}
else
{
RefPtr
<
AddrInfo
>
ai
=
new
AddrInfo
(
mHost
mType
)
;
(
void
)
mHostResolver
-
>
CompleteLookup
(
mRec
error
ai
mPB
mOriginSuffix
mTRRSkippedReason
)
;
}
mHostResolver
=
nullptr
;
mRec
=
nullptr
;
return
NS_OK
;
}
nsresult
TRR
:
:
FollowCname
(
nsIChannel
*
aChannel
)
{
nsresult
rv
=
NS_OK
;
nsAutoCString
cname
;
while
(
NS_SUCCEEDED
(
rv
)
&
&
!
mDNS
.
mAddresses
.
getFirst
(
)
&
&
!
mCname
.
IsEmpty
(
)
&
&
mCnameLoop
>
0
)
{
mCnameLoop
-
-
;
LOG
(
(
"
TRR
:
:
On200Response
CNAME
%
s
=
>
%
s
(
%
u
)
\
n
"
mHost
.
get
(
)
mCname
.
get
(
)
mCnameLoop
)
)
;
cname
=
mCname
;
mCname
=
EmptyCString
(
)
;
LOG
(
(
"
TRR
:
check
for
CNAME
record
for
%
s
within
previous
response
\
n
"
cname
.
get
(
)
)
)
;
rv
=
DohDecode
(
cname
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
:
On200Response
DohDecode
%
x
\
n
"
(
int
)
rv
)
)
;
}
}
mCname
=
cname
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mDNS
.
mAddresses
.
getFirst
(
)
)
{
ReturnData
(
aChannel
)
;
return
NS_OK
;
}
if
(
!
mCnameLoop
)
{
LOG
(
(
"
TRR
:
:
On200Response
CNAME
loop
eject
!
\
n
"
)
)
;
return
NS_ERROR_REDIRECT_LOOP
;
}
LOG
(
(
"
TRR
:
:
On200Response
CNAME
%
s
=
>
%
s
(
%
u
)
\
n
"
mHost
.
get
(
)
mCname
.
get
(
)
mCnameLoop
)
)
;
RefPtr
<
TRR
>
trr
=
new
TRR
(
mHostResolver
mRec
mCname
mType
mCnameLoop
mPB
)
;
if
(
!
gTRRService
)
{
return
NS_ERROR_FAILURE
;
}
return
gTRRService
-
>
DispatchTRRRequest
(
trr
)
;
}
nsresult
TRR
:
:
On200Response
(
nsIChannel
*
aChannel
)
{
nsresult
rv
=
DohDecode
(
mHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
:
On200Response
DohDecode
%
x
\
n
"
(
int
)
rv
)
)
;
RecordReason
(
nsHostRecord
:
:
TRR_DECODE_FAILED
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mDNS
.
mAddresses
.
getFirst
(
)
|
|
mType
=
=
TRRTYPE_TXT
|
|
mCname
.
IsEmpty
(
)
)
{
ReturnData
(
aChannel
)
;
return
NS_OK
;
}
LOG
(
(
"
TRR
:
:
On200Response
trying
CNAME
%
s
"
mCname
.
get
(
)
)
)
;
return
FollowCname
(
aChannel
)
;
}
static
void
RecordProcessingTime
(
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsITimedChannel
>
timedChan
=
do_QueryInterface
(
aChannel
)
;
if
(
!
timedChan
)
{
return
;
}
TimeStamp
end
;
if
(
NS_FAILED
(
timedChan
-
>
GetResponseEnd
(
&
end
)
)
)
{
return
;
}
if
(
end
.
IsNull
(
)
)
{
return
;
}
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
DNS_TRR_PROCESSING_TIME
end
)
;
LOG
(
(
"
Processing
DoH
response
took
%
f
ms
"
(
TimeStamp
:
:
Now
(
)
-
end
)
.
ToMilliseconds
(
)
)
)
;
}
NS_IMETHODIMP
TRR
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatusCode
)
{
LOG
(
(
"
TRR
:
OnStopRequest
%
p
%
s
%
d
failed
=
%
d
code
=
%
X
\
n
"
this
mHost
.
get
(
)
mType
mFailed
(
unsigned
int
)
aStatusCode
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
channel
.
swap
(
mChannel
)
;
{
nsCOMPtr
<
nsITimer
>
timer
;
mTimeout
.
swap
(
timer
)
;
if
(
timer
)
{
timer
-
>
Cancel
(
)
;
}
}
if
(
UseDefaultServer
(
)
)
{
gTRRService
-
>
TRRIsOkay
(
NS_SUCCEEDED
(
aStatusCode
)
?
TRRService
:
:
OKAY_NORMAL
:
TRRService
:
:
OKAY_BAD
)
;
}
if
(
!
mFailed
&
&
NS_SUCCEEDED
(
aStatusCode
)
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aRequest
)
;
if
(
!
httpChannel
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
NS_OK
;
nsAutoCString
contentType
;
httpChannel
-
>
GetContentType
(
contentType
)
;
if
(
contentType
.
Length
(
)
&
&
!
contentType
.
LowerCaseEqualsLiteral
(
"
application
/
dns
-
message
"
)
)
{
LOG
(
(
"
TRR
:
OnStopRequest
%
p
%
s
%
d
wrong
content
type
%
s
\
n
"
this
mHost
.
get
(
)
mType
contentType
.
get
(
)
)
)
;
FailData
(
NS_ERROR_UNEXPECTED
)
;
return
NS_OK
;
}
uint32_t
httpStatus
;
rv
=
httpChannel
-
>
GetResponseStatus
(
&
httpStatus
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
httpStatus
=
=
200
)
{
rv
=
On200Response
(
channel
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
UseDefaultServer
(
)
)
{
RecordReason
(
nsHostRecord
:
:
TRR_OK
)
;
RecordProcessingTime
(
channel
)
;
return
rv
;
}
}
else
{
RecordReason
(
nsHostRecord
:
:
TRR_SERVER_RESPONSE_ERR
)
;
LOG
(
(
"
TRR
:
OnStopRequest
:
%
d
%
p
rv
%
x
httpStatus
%
d
\
n
"
__LINE__
this
(
int
)
rv
httpStatus
)
)
;
}
}
LOG
(
(
"
TRR
:
OnStopRequest
%
p
status
%
x
mFailed
%
d
\
n
"
this
(
int
)
aStatusCode
mFailed
)
)
;
FailData
(
NS_ERROR_UNKNOWN_HOST
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TRR
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aInputStream
uint64_t
aOffset
const
uint32_t
aCount
)
{
LOG
(
(
"
TRR
:
OnDataAvailable
%
p
%
s
%
d
failed
=
%
d
aCount
=
%
u
\
n
"
this
mHost
.
get
(
)
mType
mFailed
(
unsigned
int
)
aCount
)
)
;
if
(
mFailed
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aCount
+
mBodySize
>
kMaxSize
)
{
LOG
(
(
"
TRR
:
:
OnDataAvailable
:
%
d
fail
\
n
"
__LINE__
)
)
;
mFailed
=
true
;
return
NS_ERROR_FAILURE
;
}
uint32_t
count
;
nsresult
rv
=
aInputStream
-
>
Read
(
(
char
*
)
mResponse
+
mBodySize
aCount
&
count
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
:
OnDataAvailable
:
%
d
fail
\
n
"
__LINE__
)
)
;
mFailed
=
true
;
return
rv
;
}
MOZ_ASSERT
(
count
=
=
aCount
)
;
mBodySize
+
=
aCount
;
return
NS_OK
;
}
nsresult
DOHresp
:
:
Add
(
uint32_t
TTL
unsigned
char
*
dns
unsigned
int
index
uint16_t
len
bool
aLocalAllowed
)
{
auto
doh
=
MakeUnique
<
DOHaddr
>
(
)
;
NetAddr
*
addr
=
&
doh
-
>
mNet
;
if
(
4
=
=
len
)
{
addr
-
>
inet
.
family
=
AF_INET
;
addr
-
>
inet
.
port
=
0
;
addr
-
>
inet
.
ip
=
ntohl
(
get32bit
(
dns
index
)
)
;
}
else
if
(
16
=
=
len
)
{
addr
-
>
inet6
.
family
=
AF_INET6
;
addr
-
>
inet6
.
port
=
0
;
addr
-
>
inet6
.
flowinfo
=
0
;
addr
-
>
inet6
.
scope_id
=
0
;
for
(
int
i
=
0
;
i
<
16
;
i
+
+
index
+
+
)
{
addr
-
>
inet6
.
ip
.
u8
[
i
]
=
dns
[
index
]
;
}
}
else
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
IsIPAddrLocal
(
addr
)
&
&
!
aLocalAllowed
)
{
return
NS_ERROR_FAILURE
;
}
doh
-
>
mTtl
=
TTL
;
if
(
LOG_ENABLED
(
)
)
{
char
buf
[
128
]
;
NetAddrToString
(
addr
buf
sizeof
(
buf
)
)
;
LOG
(
(
"
DOHresp
:
Add
%
s
\
n
"
buf
)
)
;
}
mAddresses
.
insertBack
(
doh
.
release
(
)
)
;
return
NS_OK
;
}
class
ProxyCancel
:
public
Runnable
{
public
:
explicit
ProxyCancel
(
TRR
*
aTRR
)
:
Runnable
(
"
proxyTrrCancel
"
)
mTRR
(
aTRR
)
{
}
NS_IMETHOD
Run
(
)
override
{
mTRR
-
>
Cancel
(
)
;
mTRR
=
nullptr
;
return
NS_OK
;
}
private
:
RefPtr
<
TRR
>
mTRR
;
}
;
void
TRR
:
:
Cancel
(
)
{
RefPtr
<
TRRServiceChannel
>
trrServiceChannel
=
do_QueryObject
(
mChannel
)
;
if
(
trrServiceChannel
&
&
!
XRE_IsSocketProcess
(
)
)
{
if
(
gTRRService
)
{
nsCOMPtr
<
nsIThread
>
thread
=
gTRRService
-
>
TRRThread
(
)
;
if
(
thread
&
&
!
thread
-
>
IsOnCurrentThread
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
new
ProxyCancel
(
this
)
;
thread
-
>
Dispatch
(
r
.
forget
(
)
)
;
return
;
}
}
}
else
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_DispatchToMainThread
(
new
ProxyCancel
(
this
)
)
;
return
;
}
}
if
(
mChannel
)
{
RecordReason
(
nsHostRecord
:
:
TRR_TIMEOUT
)
;
LOG
(
(
"
TRR
:
%
p
canceling
Channel
%
p
%
s
%
d
\
n
"
this
mChannel
.
get
(
)
mHost
.
get
(
)
mType
)
)
;
mChannel
-
>
Cancel
(
NS_ERROR_ABORT
)
;
if
(
UseDefaultServer
(
)
)
{
gTRRService
-
>
TRRIsOkay
(
TRRService
:
:
OKAY_TIMEOUT
)
;
}
}
}
bool
TRR
:
:
UseDefaultServer
(
)
{
return
!
mRec
|
|
mRec
-
>
mTrrServer
.
IsEmpty
(
)
;
}
#
undef
LOG
}
}
