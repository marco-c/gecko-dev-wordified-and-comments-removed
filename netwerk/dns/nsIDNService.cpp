#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsIDNService
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
punycode
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
intl
/
FormatBuffer
.
h
"
#
include
"
mozilla
/
intl
/
UnicodeProperties
.
h
"
#
include
"
mozilla
/
intl
/
UnicodeScriptCodes
.
h
"
#
include
"
ICUUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
intl
;
using
namespace
mozilla
:
:
unicode
;
using
namespace
mozilla
:
:
net
;
using
mozilla
:
:
Preferences
;
const
intl
:
:
IDNA
:
:
ProcessingType
kIDNA2008_DefaultProcessingType
=
intl
:
:
IDNA
:
:
ProcessingType
:
:
NonTransitional
;
static
const
uint32_t
kMaxULabelSize
=
256
;
static
const
char
kACEPrefix
[
]
=
"
xn
-
-
"
;
#
define
NS_NET_PREF_EXTRAALLOWED
"
network
.
IDN
.
extra_allowed_chars
"
#
define
NS_NET_PREF_EXTRABLOCKED
"
network
.
IDN
.
extra_blocked_chars
"
#
define
NS_NET_PREF_IDNRESTRICTION
"
network
.
IDN
.
restriction_profile
"
static
inline
bool
isOnlySafeChars
(
const
nsString
&
in
const
nsTArray
<
BlocklistRange
>
&
aBlocklist
)
{
if
(
aBlocklist
.
IsEmpty
(
)
)
{
return
true
;
}
const
char16_t
*
cur
=
in
.
BeginReading
(
)
;
const
char16_t
*
end
=
in
.
EndReading
(
)
;
for
(
;
cur
<
end
;
+
+
cur
)
{
if
(
CharInBlocklist
(
*
cur
aBlocklist
)
)
{
return
false
;
}
}
return
true
;
}
NS_IMPL_ISUPPORTS
(
nsIDNService
nsIIDNService
)
static
const
char
*
gCallbackPrefs
[
]
=
{
NS_NET_PREF_EXTRAALLOWED
NS_NET_PREF_EXTRABLOCKED
NS_NET_PREF_IDNRESTRICTION
nullptr
}
;
nsresult
nsIDNService
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Preferences
:
:
RegisterPrefixCallbacks
(
PrefChanged
gCallbackPrefs
this
)
;
RunOnShutdown
(
[
self
=
RefPtr
{
this
}
]
(
)
mutable
{
Preferences
:
:
UnregisterPrefixCallbacks
(
PrefChanged
gCallbackPrefs
self
.
get
(
)
)
;
self
=
nullptr
;
}
ShutdownPhase
:
:
XPCOMWillShutdown
)
;
prefsChanged
(
nullptr
)
;
return
NS_OK
;
}
void
nsIDNService
:
:
prefsChanged
(
const
char
*
pref
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AutoWriteLock
lock
(
mLock
)
;
if
(
!
pref
|
|
nsLiteralCString
(
NS_NET_PREF_EXTRAALLOWED
)
.
Equals
(
pref
)
|
|
nsLiteralCString
(
NS_NET_PREF_EXTRABLOCKED
)
.
Equals
(
pref
)
)
{
InitializeBlocklist
(
mIDNBlocklist
)
;
}
if
(
!
pref
|
|
nsLiteralCString
(
NS_NET_PREF_IDNRESTRICTION
)
.
Equals
(
pref
)
)
{
nsAutoCString
profile
;
if
(
NS_FAILED
(
Preferences
:
:
GetCString
(
NS_NET_PREF_IDNRESTRICTION
profile
)
)
)
{
profile
.
Truncate
(
)
;
}
if
(
profile
.
EqualsLiteral
(
"
moderate
"
)
)
{
mRestrictionProfile
=
eModeratelyRestrictiveProfile
;
}
else
if
(
profile
.
EqualsLiteral
(
"
high
"
)
)
{
mRestrictionProfile
=
eHighlyRestrictiveProfile
;
}
else
{
mRestrictionProfile
=
eASCIIOnlyProfile
;
}
}
}
nsIDNService
:
:
nsIDNService
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
createResult
=
mozilla
:
:
intl
:
:
IDNA
:
:
TryCreate
(
kIDNA2008_DefaultProcessingType
)
;
MOZ_ASSERT
(
createResult
.
isOk
(
)
)
;
mIDNA
=
createResult
.
unwrap
(
)
;
}
nsIDNService
:
:
~
nsIDNService
(
)
=
default
;
nsresult
nsIDNService
:
:
IDNA2008ToUnicode
(
const
nsACString
&
input
nsAString
&
output
)
{
NS_ConvertUTF8toUTF16
inputStr
(
input
)
;
Span
<
const
char16_t
>
inputSpan
{
inputStr
}
;
intl
:
:
nsTStringToBufferAdapter
buffer
(
output
)
;
auto
result
=
mIDNA
-
>
LabelToUnicode
(
inputSpan
buffer
)
;
nsresult
rv
=
NS_OK
;
if
(
result
.
isErr
(
)
)
{
rv
=
ICUUtils
:
:
ICUErrorToNsResult
(
result
.
unwrapErr
(
)
)
;
if
(
rv
=
=
NS_ERROR_FAILURE
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
intl
:
:
IDNA
:
:
Info
info
=
result
.
unwrap
(
)
;
if
(
info
.
HasErrors
(
)
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
}
return
rv
;
}
nsresult
nsIDNService
:
:
IDNA2008StringPrep
(
const
nsAString
&
input
nsAString
&
output
stringPrepFlag
flag
)
{
Span
<
const
char16_t
>
inputSpan
{
input
}
;
intl
:
:
nsTStringToBufferAdapter
buffer
(
output
)
;
auto
result
=
mIDNA
-
>
LabelToUnicode
(
inputSpan
buffer
)
;
nsresult
rv
=
NS_OK
;
if
(
result
.
isErr
(
)
)
{
rv
=
ICUUtils
:
:
ICUErrorToNsResult
(
result
.
unwrapErr
(
)
)
;
if
(
rv
=
=
NS_ERROR_FAILURE
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
intl
:
:
IDNA
:
:
Info
info
=
result
.
unwrap
(
)
;
if
(
(
info
.
HasInvalidPunycode
(
)
|
|
info
.
HasInvalidAceLabel
(
)
)
&
&
!
output
.
IsEmpty
(
)
&
&
output
.
Last
(
)
=
=
0xfffd
)
{
output
.
Truncate
(
output
.
Length
(
)
-
1
)
;
}
if
(
flag
=
=
eStringPrepIgnoreErrors
)
{
return
NS_OK
;
}
if
(
flag
=
=
eStringPrepForDNS
)
{
if
(
!
output
.
IsEmpty
(
)
)
{
if
(
info
.
HasErrorsIgnoringInvalidHyphen
(
)
)
{
output
.
Truncate
(
)
;
rv
=
NS_ERROR_MALFORMED_URI
;
}
}
}
else
{
if
(
info
.
HasErrors
(
)
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsIDNService
:
:
ConvertUTF8toACE
(
const
nsACString
&
input
nsACString
&
ace
)
{
return
UTF8toACE
(
input
ace
eStringPrepForDNS
)
;
}
nsresult
nsIDNService
:
:
UTF8toACE
(
const
nsACString
&
input
nsACString
&
ace
stringPrepFlag
flag
)
{
nsresult
rv
;
NS_ConvertUTF8toUTF16
ustr
(
input
)
;
normalizeFullStops
(
ustr
)
;
uint32_t
len
offset
;
len
=
0
;
offset
=
0
;
nsAutoCString
encodedBuf
;
nsAString
:
:
const_iterator
start
end
;
ustr
.
BeginReading
(
start
)
;
ustr
.
EndReading
(
end
)
;
ace
.
Truncate
(
)
;
while
(
start
!
=
end
)
{
len
+
+
;
if
(
*
start
+
+
=
=
(
char16_t
)
'
.
'
)
{
rv
=
stringPrepAndACE
(
Substring
(
ustr
offset
len
-
1
)
encodedBuf
flag
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ace
.
Append
(
encodedBuf
)
;
ace
.
Append
(
'
.
'
)
;
offset
+
=
len
;
len
=
0
;
}
}
if
(
len
)
{
rv
=
stringPrepAndACE
(
Substring
(
ustr
offset
len
)
encodedBuf
flag
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ace
.
Append
(
encodedBuf
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIDNService
:
:
ConvertACEtoUTF8
(
const
nsACString
&
input
nsACString
&
_retval
)
{
return
ACEtoUTF8
(
input
_retval
eStringPrepForDNS
)
;
}
nsresult
nsIDNService
:
:
ACEtoUTF8
(
const
nsACString
&
input
nsACString
&
_retval
stringPrepFlag
flag
)
{
uint32_t
len
=
0
offset
=
0
;
nsAutoCString
decodedBuf
;
nsACString
:
:
const_iterator
start
end
;
input
.
BeginReading
(
start
)
;
input
.
EndReading
(
end
)
;
_retval
.
Truncate
(
)
;
if
(
input
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsAutoCString
tld
;
nsCString
:
:
const_iterator
it
=
end
tldEnd
=
end
;
-
-
it
;
if
(
it
!
=
start
&
&
*
it
=
=
(
char16_t
)
'
.
'
)
{
tldEnd
=
it
;
-
-
it
;
}
while
(
it
!
=
start
)
{
if
(
*
it
=
=
(
char16_t
)
'
.
'
)
{
+
+
it
;
tld
.
Assign
(
Substring
(
it
tldEnd
)
)
;
break
;
}
-
-
it
;
}
while
(
start
!
=
end
)
{
len
+
+
;
if
(
*
start
+
+
=
=
'
.
'
)
{
nsDependentCSubstring
origLabel
(
input
offset
len
-
1
)
;
if
(
NS_FAILED
(
decodeACE
(
origLabel
decodedBuf
flag
tld
)
)
)
{
_retval
.
Append
(
origLabel
)
;
}
else
{
_retval
.
Append
(
decodedBuf
)
;
}
_retval
.
Append
(
'
.
'
)
;
offset
+
=
len
;
len
=
0
;
}
}
if
(
len
)
{
nsDependentCSubstring
origLabel
(
input
offset
len
)
;
if
(
NS_FAILED
(
decodeACE
(
origLabel
decodedBuf
flag
tld
)
)
)
{
_retval
.
Append
(
origLabel
)
;
}
else
{
_retval
.
Append
(
decodedBuf
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIDNService
:
:
IsACE
(
const
nsACString
&
input
bool
*
_retval
)
{
if
(
!
IsAscii
(
input
)
)
{
*
_retval
=
false
;
return
NS_OK
;
}
auto
stringContains
=
[
]
(
const
nsACString
&
haystack
const
nsACString
&
needle
)
{
return
std
:
:
search
(
haystack
.
BeginReading
(
)
haystack
.
EndReading
(
)
needle
.
BeginReading
(
)
needle
.
EndReading
(
)
[
]
(
unsigned
char
ch1
unsigned
char
ch2
)
{
return
tolower
(
ch1
)
=
=
tolower
(
ch2
)
;
}
)
!
=
haystack
.
EndReading
(
)
;
}
;
*
_retval
=
StringBeginsWith
(
input
"
xn
-
-
"
_ns
nsCaseInsensitiveCStringComparator
)
|
|
(
!
input
.
IsEmpty
(
)
&
&
input
[
0
]
!
=
'
.
'
&
&
stringContains
(
input
"
.
xn
-
-
"
_ns
)
)
;
return
NS_OK
;
}
nsresult
nsIDNService
:
:
Normalize
(
const
nsACString
&
input
nsACString
&
output
)
{
NS_ENSURE_TRUE
(
IsUtf8
(
input
)
NS_ERROR_UNEXPECTED
)
;
NS_ConvertUTF8toUTF16
inUTF16
(
input
)
;
normalizeFullStops
(
inUTF16
)
;
nsAutoString
outUTF16
outLabel
;
uint32_t
len
=
0
offset
=
0
;
nsresult
rv
;
nsAString
:
:
const_iterator
start
end
;
inUTF16
.
BeginReading
(
start
)
;
inUTF16
.
EndReading
(
end
)
;
while
(
start
!
=
end
)
{
len
+
+
;
if
(
*
start
+
+
=
=
char16_t
(
'
.
'
)
)
{
rv
=
stringPrep
(
Substring
(
inUTF16
offset
len
-
1
)
outLabel
eStringPrepIgnoreErrors
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outUTF16
.
Append
(
outLabel
)
;
outUTF16
.
Append
(
char16_t
(
'
.
'
)
)
;
offset
+
=
len
;
len
=
0
;
}
}
if
(
len
)
{
rv
=
stringPrep
(
Substring
(
inUTF16
offset
len
)
outLabel
eStringPrepIgnoreErrors
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outUTF16
.
Append
(
outLabel
)
;
}
CopyUTF16toUTF8
(
outUTF16
output
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIDNService
:
:
ConvertToDisplayIDN
(
const
nsACString
&
input
bool
*
_isASCII
nsACString
&
_retval
)
{
nsresult
rv
=
NS_OK
;
bool
isACE
;
IsACE
(
input
&
isACE
)
;
if
(
IsAscii
(
input
)
)
{
_retval
=
input
;
ToLowerCase
(
_retval
)
;
if
(
isACE
&
&
!
StaticPrefs
:
:
network_IDN_show_punycode
(
)
)
{
nsAutoCString
temp
(
_retval
)
;
ACEtoUTF8
(
temp
_retval
eStringPrepForUI
)
;
*
_isASCII
=
IsAscii
(
_retval
)
;
}
else
{
*
_isASCII
=
true
;
}
}
else
{
if
(
isACE
)
{
nsAutoCString
temp
;
ACEtoUTF8
(
input
temp
eStringPrepIgnoreErrors
)
;
rv
=
Normalize
(
temp
_retval
)
;
}
else
{
rv
=
Normalize
(
input
_retval
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
StaticPrefs
:
:
network_IDN_show_punycode
(
)
&
&
NS_SUCCEEDED
(
UTF8toACE
(
_retval
_retval
eStringPrepIgnoreErrors
)
)
)
{
*
_isASCII
=
true
;
return
NS_OK
;
}
*
_isASCII
=
IsAscii
(
_retval
)
;
if
(
!
*
_isASCII
)
{
rv
=
UTF8toACE
(
_retval
_retval
eStringPrepForUI
)
;
*
_isASCII
=
IsAscii
(
_retval
)
;
return
rv
;
}
}
return
NS_OK
;
}
static
nsresult
utf16ToUcs4
(
const
nsAString
&
in
uint32_t
*
out
uint32_t
outBufLen
uint32_t
*
outLen
)
{
uint32_t
i
=
0
;
nsAString
:
:
const_iterator
start
end
;
in
.
BeginReading
(
start
)
;
in
.
EndReading
(
end
)
;
while
(
start
!
=
end
)
{
char16_t
curChar
;
curChar
=
*
start
+
+
;
if
(
start
!
=
end
&
&
NS_IS_SURROGATE_PAIR
(
curChar
*
start
)
)
{
out
[
i
]
=
SURROGATE_TO_UCS4
(
curChar
*
start
)
;
+
+
start
;
}
else
{
out
[
i
]
=
curChar
;
}
i
+
+
;
if
(
i
>
=
outBufLen
)
{
return
NS_ERROR_MALFORMED_URI
;
}
}
out
[
i
]
=
(
uint32_t
)
'
\
0
'
;
*
outLen
=
i
;
return
NS_OK
;
}
static
nsresult
punycode
(
const
nsAString
&
in
nsACString
&
out
)
{
uint32_t
ucs4Buf
[
kMaxULabelSize
+
1
]
;
uint32_t
ucs4Len
=
0u
;
nsresult
rv
=
utf16ToUcs4
(
in
ucs4Buf
kMaxULabelSize
&
ucs4Len
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
uint32_t
kEncodedBufSize
=
kMaxULabelSize
*
20
/
8
+
1
+
1
;
char
encodedBuf
[
kEncodedBufSize
]
;
punycode_uint
encodedLength
=
kEncodedBufSize
;
enum
punycode_status
status
=
punycode_encode
(
ucs4Len
ucs4Buf
nullptr
&
encodedLength
encodedBuf
)
;
if
(
punycode_success
!
=
status
|
|
encodedLength
>
=
kEncodedBufSize
)
{
return
NS_ERROR_MALFORMED_URI
;
}
encodedBuf
[
encodedLength
]
=
'
\
0
'
;
out
.
Assign
(
nsDependentCString
(
kACEPrefix
)
+
nsDependentCString
(
encodedBuf
)
)
;
return
rv
;
}
nsresult
nsIDNService
:
:
stringPrep
(
const
nsAString
&
in
nsAString
&
out
stringPrepFlag
flag
)
{
return
IDNA2008StringPrep
(
in
out
flag
)
;
}
nsresult
nsIDNService
:
:
stringPrepAndACE
(
const
nsAString
&
in
nsACString
&
out
stringPrepFlag
flag
)
{
nsresult
rv
=
NS_OK
;
out
.
Truncate
(
)
;
if
(
IsAscii
(
in
)
)
{
LossyCopyUTF16toASCII
(
in
out
)
;
if
(
!
StringBeginsWith
(
in
u
"
xn
-
-
"
_ns
nsCaseInsensitiveStringComparator
)
)
{
return
NS_OK
;
}
}
nsAutoString
strPrep
;
rv
=
stringPrep
(
in
strPrep
flag
)
;
if
(
flag
=
=
eStringPrepForDNS
)
{
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
IsAscii
(
strPrep
)
)
{
LossyCopyUTF16toASCII
(
strPrep
out
)
;
return
NS_OK
;
}
if
(
flag
=
=
eStringPrepForUI
&
&
NS_SUCCEEDED
(
rv
)
&
&
isLabelSafe
(
in
u
"
"
_ns
)
)
{
CopyUTF16toUTF8
(
strPrep
out
)
;
return
NS_OK
;
}
return
punycode
(
strPrep
out
)
;
}
void
nsIDNService
:
:
normalizeFullStops
(
nsAString
&
s
)
{
nsAString
:
:
const_iterator
start
end
;
s
.
BeginReading
(
start
)
;
s
.
EndReading
(
end
)
;
int32_t
index
=
0
;
while
(
start
!
=
end
)
{
switch
(
*
start
)
{
case
0x3002
:
case
0xFF0E
:
case
0xFF61
:
s
.
ReplaceLiteral
(
index
1
u
"
.
"
)
;
break
;
default
:
break
;
}
start
+
+
;
index
+
+
;
}
}
nsresult
nsIDNService
:
:
decodeACE
(
const
nsACString
&
in
nsACString
&
out
stringPrepFlag
flag
const
nsACString
&
aTLD
)
{
bool
isAce
;
IsACE
(
in
&
isAce
)
;
if
(
!
isAce
)
{
out
.
Assign
(
in
)
;
return
NS_OK
;
}
nsAutoString
utf16
;
nsresult
result
=
IDNA2008ToUnicode
(
in
utf16
)
;
NS_ENSURE_SUCCESS
(
result
result
)
;
NS_ConvertUTF8toUTF16
tld
(
aTLD
)
;
if
(
flag
!
=
eStringPrepForUI
|
|
isLabelSafe
(
utf16
tld
)
)
{
CopyUTF16toUTF8
(
utf16
out
)
;
}
else
{
out
.
Assign
(
in
)
;
return
NS_OK
;
}
nsAutoCString
ace
;
nsresult
rv
=
UTF8toACE
(
out
ace
flag
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
flag
=
=
eStringPrepForDNS
&
&
!
ace
.
Equals
(
in
nsCaseInsensitiveCStringComparator
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
return
NS_OK
;
}
namespace
mozilla
:
:
net
{
enum
ScriptCombo
:
int32_t
{
UNSET
=
-
1
BOPO
=
0
CYRL
=
1
GREK
=
2
HANG
=
3
HANI
=
4
HIRA
=
5
KATA
=
6
LATN
=
7
OTHR
=
8
JPAN
=
9
CHNA
=
10
KORE
=
11
HNLT
=
12
FAIL
=
13
}
;
}
bool
nsIDNService
:
:
isLabelSafe
(
const
nsAString
&
label
const
nsAString
&
tld
)
{
restrictionProfile
profile
{
eASCIIOnlyProfile
}
;
{
AutoReadLock
lock
(
mLock
)
;
if
(
!
isOnlySafeChars
(
PromiseFlatString
(
label
)
mIDNBlocklist
)
)
{
return
false
;
}
NS_ASSERTION
(
!
IsAscii
(
label
)
"
ASCII
label
in
IDN
checking
"
)
;
if
(
mRestrictionProfile
=
=
eASCIIOnlyProfile
)
{
return
false
;
}
profile
=
mRestrictionProfile
;
}
nsAString
:
:
const_iterator
current
end
;
label
.
BeginReading
(
current
)
;
label
.
EndReading
(
end
)
;
Script
lastScript
=
Script
:
:
INVALID
;
uint32_t
previousChar
=
0
;
uint32_t
baseChar
=
0
;
uint32_t
savedNumberingSystem
=
0
;
#
if
0
HanVariantType
savedHanVariant
=
HVT_NotHan
;
#
endif
ScriptCombo
savedScript
=
ScriptCombo
:
:
UNSET
;
while
(
current
!
=
end
)
{
uint32_t
ch
=
*
current
+
+
;
if
(
current
!
=
end
&
&
NS_IS_SURROGATE_PAIR
(
ch
*
current
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
current
+
+
)
;
}
IdentifierType
idType
=
GetIdentifierType
(
ch
)
;
if
(
idType
=
=
IDTYPE_RESTRICTED
)
{
return
false
;
}
MOZ_ASSERT
(
idType
=
=
IDTYPE_ALLOWED
)
;
Script
script
=
UnicodeProperties
:
:
GetScriptCode
(
ch
)
;
if
(
script
!
=
Script
:
:
COMMON
&
&
script
!
=
Script
:
:
INHERITED
&
&
script
!
=
lastScript
)
{
if
(
illegalScriptCombo
(
profile
script
savedScript
)
)
{
return
false
;
}
}
if
(
ch
=
=
0x30fc
&
&
lastScript
!
=
Script
:
:
HIRAGANA
&
&
lastScript
!
=
Script
:
:
KATAKANA
)
{
return
false
;
}
Script
nextScript
=
Script
:
:
INVALID
;
if
(
current
!
=
end
)
{
nextScript
=
UnicodeProperties
:
:
GetScriptCode
(
*
current
)
;
}
if
(
ch
=
=
0x30FB
&
&
(
lastScript
=
=
Script
:
:
LATIN
|
|
nextScript
=
=
Script
:
:
LATIN
)
)
{
return
false
;
}
if
(
ch
=
=
0x307
&
&
(
previousChar
=
=
'
i
'
|
|
previousChar
=
=
'
j
'
|
|
previousChar
=
=
'
l
'
)
)
{
return
false
;
}
if
(
ch
=
=
0xB7
&
&
(
!
tld
.
EqualsLiteral
(
"
cat
"
)
|
|
previousChar
!
=
'
l
'
|
|
current
=
=
end
|
|
*
current
!
=
'
l
'
)
)
{
return
false
;
}
if
(
(
ch
=
=
0xFE
|
|
ch
=
=
0xF0
)
&
&
!
tld
.
EqualsLiteral
(
"
is
"
)
&
&
!
tld
.
EqualsLiteral
(
"
fo
"
)
)
{
return
false
;
}
if
(
ch
=
=
0x2BB
|
|
ch
=
=
0x2BC
)
{
return
false
;
}
auto
genCat
=
GetGeneralCategory
(
ch
)
;
if
(
genCat
=
=
HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER
)
{
uint32_t
zeroCharacter
=
ch
-
mozilla
:
:
intl
:
:
UnicodeProperties
:
:
GetNumericValue
(
ch
)
;
if
(
savedNumberingSystem
=
=
0
)
{
savedNumberingSystem
=
zeroCharacter
;
}
else
if
(
zeroCharacter
!
=
savedNumberingSystem
)
{
return
false
;
}
}
if
(
genCat
=
=
HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK
)
{
if
(
previousChar
!
=
0
&
&
previousChar
=
=
ch
)
{
return
false
;
}
if
(
lastScript
!
=
Script
:
:
INVALID
)
{
UnicodeProperties
:
:
ScriptExtensionVector
scripts
;
auto
extResult
=
UnicodeProperties
:
:
GetExtensions
(
ch
scripts
)
;
MOZ_ASSERT
(
extResult
.
isOk
(
)
)
;
if
(
extResult
.
isErr
(
)
)
{
return
false
;
}
int
nScripts
=
AssertedCast
<
int
>
(
scripts
.
length
(
)
)
;
if
(
nScripts
>
1
|
|
(
Script
(
scripts
[
0
]
)
!
=
Script
:
:
COMMON
&
&
Script
(
scripts
[
0
]
)
!
=
Script
:
:
INHERITED
)
)
{
while
(
-
-
nScripts
>
=
0
)
{
if
(
Script
(
scripts
[
nScripts
]
)
=
=
lastScript
)
{
break
;
}
}
if
(
nScripts
=
=
-
1
)
{
return
false
;
}
}
}
if
(
baseChar
=
=
0x0131
&
&
(
(
ch
>
=
0x0300
&
&
ch
<
=
0x0314
)
|
|
ch
=
=
0x031a
)
)
{
return
false
;
}
}
else
{
baseChar
=
ch
;
}
if
(
script
!
=
Script
:
:
COMMON
&
&
script
!
=
Script
:
:
INHERITED
)
{
lastScript
=
script
;
}
#
if
0
HanVariantType
hanVariant
=
GetHanVariant
(
ch
)
;
if
(
hanVariant
=
=
HVT_SimplifiedOnly
|
|
hanVariant
=
=
HVT_TraditionalOnly
)
{
if
(
savedHanVariant
=
=
HVT_NotHan
)
{
savedHanVariant
=
hanVariant
;
}
else
if
(
hanVariant
!
=
savedHanVariant
)
{
return
false
;
}
}
#
endif
previousChar
=
ch
;
}
return
true
;
}
static
inline
ScriptCombo
findScriptIndex
(
Script
aScript
)
{
switch
(
aScript
)
{
case
Script
:
:
BOPOMOFO
:
return
ScriptCombo
:
:
BOPO
;
case
Script
:
:
CYRILLIC
:
return
ScriptCombo
:
:
CYRL
;
case
Script
:
:
GREEK
:
return
ScriptCombo
:
:
GREK
;
case
Script
:
:
HANGUL
:
return
ScriptCombo
:
:
HANG
;
case
Script
:
:
HAN
:
return
ScriptCombo
:
:
HANI
;
case
Script
:
:
HIRAGANA
:
return
ScriptCombo
:
:
HIRA
;
case
Script
:
:
KATAKANA
:
return
ScriptCombo
:
:
KATA
;
case
Script
:
:
LATIN
:
return
ScriptCombo
:
:
LATN
;
default
:
return
ScriptCombo
:
:
OTHR
;
}
}
static
const
ScriptCombo
scriptComboTable
[
13
]
[
9
]
=
{
{
BOPO
FAIL
FAIL
FAIL
CHNA
FAIL
FAIL
CHNA
FAIL
}
{
FAIL
CYRL
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
}
{
FAIL
FAIL
GREK
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
}
{
FAIL
FAIL
FAIL
HANG
KORE
FAIL
FAIL
KORE
FAIL
}
{
CHNA
FAIL
FAIL
KORE
HANI
JPAN
JPAN
HNLT
FAIL
}
{
FAIL
FAIL
FAIL
FAIL
JPAN
HIRA
JPAN
JPAN
FAIL
}
{
FAIL
FAIL
FAIL
FAIL
JPAN
JPAN
KATA
JPAN
FAIL
}
{
CHNA
FAIL
FAIL
KORE
HNLT
JPAN
JPAN
LATN
OTHR
}
{
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
OTHR
FAIL
}
{
FAIL
FAIL
FAIL
FAIL
JPAN
JPAN
JPAN
JPAN
FAIL
}
{
CHNA
FAIL
FAIL
FAIL
CHNA
FAIL
FAIL
CHNA
FAIL
}
{
FAIL
FAIL
FAIL
KORE
KORE
FAIL
FAIL
KORE
FAIL
}
{
CHNA
FAIL
FAIL
KORE
HNLT
JPAN
JPAN
HNLT
FAIL
}
}
;
bool
nsIDNService
:
:
illegalScriptCombo
(
restrictionProfile
profile
Script
script
ScriptCombo
&
savedScript
)
{
if
(
savedScript
=
=
ScriptCombo
:
:
UNSET
)
{
savedScript
=
findScriptIndex
(
script
)
;
return
false
;
}
savedScript
=
scriptComboTable
[
savedScript
]
[
findScriptIndex
(
script
)
]
;
return
(
(
savedScript
=
=
OTHR
&
&
profile
=
=
eHighlyRestrictiveProfile
)
|
|
savedScript
=
=
FAIL
)
;
}
