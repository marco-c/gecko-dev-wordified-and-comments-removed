#
include
"
nsIDNService
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsUnicodeScriptCodes
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
punycode
.
h
"
#
ifdef
IDNA2008
const
bool
kIDNA2008_TransitionalProcessing
=
false
;
#
include
"
ICUUtils
.
h
"
#
endif
using
namespace
mozilla
:
:
unicode
;
static
const
uint32_t
kMaxDNSNodeLen
=
63
;
static
const
char
kACEPrefix
[
]
=
"
xn
-
-
"
;
#
define
kACEPrefixLen
4
#
define
NS_NET_PREF_IDNBLACKLIST
"
network
.
IDN
.
blacklist_chars
"
#
define
NS_NET_PREF_SHOWPUNYCODE
"
network
.
IDN_show_punycode
"
#
define
NS_NET_PREF_IDNWHITELIST
"
network
.
IDN
.
whitelist
.
"
#
define
NS_NET_PREF_IDNUSEWHITELIST
"
network
.
IDN
.
use_whitelist
"
#
define
NS_NET_PREF_IDNRESTRICTION
"
network
.
IDN
.
restriction_profile
"
inline
bool
isOnlySafeChars
(
const
nsAFlatString
&
in
const
nsAFlatString
&
blacklist
)
{
return
(
blacklist
.
IsEmpty
(
)
|
|
in
.
FindCharInSet
(
blacklist
)
=
=
kNotFound
)
;
}
NS_IMPL_ISUPPORTS
(
nsIDNService
nsIIDNService
nsIObserver
nsISupportsWeakReference
)
nsresult
nsIDNService
:
:
Init
(
)
{
nsCOMPtr
<
nsIPrefService
>
prefs
(
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
)
;
if
(
prefs
)
prefs
-
>
GetBranch
(
NS_NET_PREF_IDNWHITELIST
getter_AddRefs
(
mIDNWhitelistPrefBranch
)
)
;
nsCOMPtr
<
nsIPrefBranch
>
prefInternal
(
do_QueryInterface
(
prefs
)
)
;
if
(
prefInternal
)
{
prefInternal
-
>
AddObserver
(
NS_NET_PREF_IDNBLACKLIST
this
true
)
;
prefInternal
-
>
AddObserver
(
NS_NET_PREF_SHOWPUNYCODE
this
true
)
;
prefInternal
-
>
AddObserver
(
NS_NET_PREF_IDNRESTRICTION
this
true
)
;
prefInternal
-
>
AddObserver
(
NS_NET_PREF_IDNUSEWHITELIST
this
true
)
;
prefsChanged
(
prefInternal
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIDNService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
(
do_QueryInterface
(
aSubject
)
)
;
if
(
prefBranch
)
prefsChanged
(
prefBranch
aData
)
;
}
return
NS_OK
;
}
void
nsIDNService
:
:
prefsChanged
(
nsIPrefBranch
*
prefBranch
const
char16_t
*
pref
)
{
if
(
!
pref
|
|
NS_LITERAL_STRING
(
NS_NET_PREF_IDNBLACKLIST
)
.
Equals
(
pref
)
)
{
nsCOMPtr
<
nsISupportsString
>
blacklist
;
nsresult
rv
=
prefBranch
-
>
GetComplexValue
(
NS_NET_PREF_IDNBLACKLIST
NS_GET_IID
(
nsISupportsString
)
getter_AddRefs
(
blacklist
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
blacklist
-
>
ToString
(
getter_Copies
(
mIDNBlacklist
)
)
;
else
mIDNBlacklist
.
Truncate
(
)
;
}
if
(
!
pref
|
|
NS_LITERAL_STRING
(
NS_NET_PREF_SHOWPUNYCODE
)
.
Equals
(
pref
)
)
{
bool
val
;
if
(
NS_SUCCEEDED
(
prefBranch
-
>
GetBoolPref
(
NS_NET_PREF_SHOWPUNYCODE
&
val
)
)
)
mShowPunycode
=
val
;
}
if
(
!
pref
|
|
NS_LITERAL_STRING
(
NS_NET_PREF_IDNUSEWHITELIST
)
.
Equals
(
pref
)
)
{
bool
val
;
if
(
NS_SUCCEEDED
(
prefBranch
-
>
GetBoolPref
(
NS_NET_PREF_IDNUSEWHITELIST
&
val
)
)
)
mIDNUseWhitelist
=
val
;
}
if
(
!
pref
|
|
NS_LITERAL_STRING
(
NS_NET_PREF_IDNRESTRICTION
)
.
Equals
(
pref
)
)
{
nsXPIDLCString
profile
;
if
(
NS_FAILED
(
prefBranch
-
>
GetCharPref
(
NS_NET_PREF_IDNRESTRICTION
getter_Copies
(
profile
)
)
)
)
{
profile
.
Truncate
(
)
;
}
if
(
profile
.
EqualsLiteral
(
"
moderate
"
)
)
{
mRestrictionProfile
=
eModeratelyRestrictiveProfile
;
}
else
if
(
profile
.
EqualsLiteral
(
"
high
"
)
)
{
mRestrictionProfile
=
eHighlyRestrictiveProfile
;
}
else
{
mRestrictionProfile
=
eASCIIOnlyProfile
;
}
}
}
nsIDNService
:
:
nsIDNService
(
)
:
mShowPunycode
(
false
)
mIDNUseWhitelist
(
false
)
{
#
ifdef
IDNA2008
uint32_t
IDNAOptions
=
UIDNA_CHECK_BIDI
|
UIDNA_CHECK_CONTEXTJ
;
if
(
!
kIDNA2008_TransitionalProcessing
)
{
IDNAOptions
|
=
UIDNA_NONTRANSITIONAL_TO_UNICODE
;
}
UErrorCode
errorCode
=
U_ZERO_ERROR
;
mIDNA
=
uidna_openUTS46
(
IDNAOptions
&
errorCode
)
;
#
else
if
(
idn_success
!
=
idn_nameprep_create
(
nullptr
&
mNamePrepHandle
)
)
mNamePrepHandle
=
nullptr
;
mNormalizer
=
do_GetService
(
NS_UNICODE_NORMALIZER_CONTRACTID
)
;
#
endif
}
nsIDNService
:
:
~
nsIDNService
(
)
{
#
ifdef
IDNA2008
uidna_close
(
mIDNA
)
;
#
else
idn_nameprep_destroy
(
mNamePrepHandle
)
;
#
endif
}
#
ifdef
IDNA2008
nsresult
nsIDNService
:
:
IDNA2008ToUnicode
(
const
nsACString
&
input
nsAString
&
output
)
{
NS_ConvertUTF8toUTF16
inputStr
(
input
)
;
UIDNAInfo
info
=
UIDNA_INFO_INITIALIZER
;
UErrorCode
errorCode
=
U_ZERO_ERROR
;
int32_t
inLen
=
inputStr
.
Length
(
)
;
int32_t
outMaxLen
=
kMaxDNSNodeLen
+
1
;
UChar
outputBuffer
[
kMaxDNSNodeLen
+
1
]
;
int32_t
outLen
=
uidna_labelToUnicode
(
mIDNA
(
const
UChar
*
)
inputStr
.
get
(
)
inLen
outputBuffer
outMaxLen
&
info
&
errorCode
)
;
if
(
info
.
errors
!
=
0
)
{
return
NS_ERROR_MALFORMED_URI
;
}
if
(
U_SUCCESS
(
errorCode
)
)
{
ICUUtils
:
:
AssignUCharArrayToString
(
outputBuffer
outLen
output
)
;
}
nsresult
rv
=
ICUUtils
:
:
UErrorToNsResult
(
errorCode
)
;
if
(
rv
=
=
NS_ERROR_FAILURE
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
}
return
rv
;
}
nsresult
nsIDNService
:
:
IDNA2008StringPrep
(
const
nsAString
&
input
nsAString
&
output
stringPrepFlag
flag
)
{
UIDNAInfo
info
=
UIDNA_INFO_INITIALIZER
;
UErrorCode
errorCode
=
U_ZERO_ERROR
;
int32_t
inLen
=
input
.
Length
(
)
;
int32_t
outMaxLen
=
kMaxDNSNodeLen
+
1
;
UChar
outputBuffer
[
kMaxDNSNodeLen
+
1
]
;
int32_t
outLen
=
uidna_labelToUnicode
(
mIDNA
(
const
UChar
*
)
PromiseFlatString
(
input
)
.
get
(
)
inLen
outputBuffer
outMaxLen
&
info
&
errorCode
)
;
nsresult
rv
=
ICUUtils
:
:
UErrorToNsResult
(
errorCode
)
;
if
(
rv
=
=
NS_ERROR_FAILURE
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ICUUtils
:
:
AssignUCharArrayToString
(
outputBuffer
outLen
output
)
;
if
(
flag
=
=
eStringPrepIgnoreErrors
)
{
return
NS_OK
;
}
if
(
info
.
errors
!
=
0
)
{
if
(
flag
=
=
eStringPrepForDNS
)
{
output
.
Truncate
(
)
;
}
rv
=
NS_ERROR_MALFORMED_URI
;
}
return
rv
;
}
#
endif
NS_IMETHODIMP
nsIDNService
:
:
ConvertUTF8toACE
(
const
nsACString
&
input
nsACString
&
ace
)
{
return
UTF8toACE
(
input
ace
eStringPrepForDNS
)
;
}
nsresult
nsIDNService
:
:
UTF8toACE
(
const
nsACString
&
input
nsACString
&
ace
stringPrepFlag
flag
)
{
nsresult
rv
;
NS_ConvertUTF8toUTF16
ustr
(
input
)
;
normalizeFullStops
(
ustr
)
;
uint32_t
len
offset
;
len
=
0
;
offset
=
0
;
nsAutoCString
encodedBuf
;
nsAString
:
:
const_iterator
start
end
;
ustr
.
BeginReading
(
start
)
;
ustr
.
EndReading
(
end
)
;
ace
.
Truncate
(
)
;
while
(
start
!
=
end
)
{
len
+
+
;
if
(
*
start
+
+
=
=
(
char16_t
)
'
.
'
)
{
rv
=
stringPrepAndACE
(
Substring
(
ustr
offset
len
-
1
)
encodedBuf
flag
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ace
.
Append
(
encodedBuf
)
;
ace
.
Append
(
'
.
'
)
;
offset
+
=
len
;
len
=
0
;
}
}
if
(
len
)
{
rv
=
stringPrepAndACE
(
Substring
(
ustr
offset
len
)
encodedBuf
flag
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ace
.
Append
(
encodedBuf
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIDNService
:
:
ConvertACEtoUTF8
(
const
nsACString
&
input
nsACString
&
_retval
)
{
return
ACEtoUTF8
(
input
_retval
eStringPrepForDNS
)
;
}
nsresult
nsIDNService
:
:
ACEtoUTF8
(
const
nsACString
&
input
nsACString
&
_retval
stringPrepFlag
flag
)
{
uint32_t
len
=
0
offset
=
0
;
nsAutoCString
decodedBuf
;
nsACString
:
:
const_iterator
start
end
;
input
.
BeginReading
(
start
)
;
input
.
EndReading
(
end
)
;
_retval
.
Truncate
(
)
;
while
(
start
!
=
end
)
{
len
+
+
;
if
(
*
start
+
+
=
=
'
.
'
)
{
if
(
NS_FAILED
(
decodeACE
(
Substring
(
input
offset
len
-
1
)
decodedBuf
flag
)
)
)
{
_retval
.
Assign
(
input
)
;
return
NS_OK
;
}
_retval
.
Append
(
decodedBuf
)
;
_retval
.
Append
(
'
.
'
)
;
offset
+
=
len
;
len
=
0
;
}
}
if
(
len
)
{
if
(
NS_FAILED
(
decodeACE
(
Substring
(
input
offset
len
)
decodedBuf
flag
)
)
)
_retval
.
Assign
(
input
)
;
else
_retval
.
Append
(
decodedBuf
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIDNService
:
:
IsACE
(
const
nsACString
&
input
bool
*
_retval
)
{
nsACString
:
:
const_iterator
begin
;
input
.
BeginReading
(
begin
)
;
const
char
*
data
=
begin
.
get
(
)
;
uint32_t
dataLen
=
begin
.
size_forward
(
)
;
const
char
*
p
=
PL_strncasestr
(
data
kACEPrefix
dataLen
)
;
*
_retval
=
p
&
&
(
p
=
=
data
|
|
*
(
p
-
1
)
=
=
'
.
'
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIDNService
:
:
Normalize
(
const
nsACString
&
input
nsACString
&
output
)
{
NS_ENSURE_TRUE
(
IsUTF8
(
input
)
NS_ERROR_UNEXPECTED
)
;
NS_ConvertUTF8toUTF16
inUTF16
(
input
)
;
normalizeFullStops
(
inUTF16
)
;
nsAutoString
outUTF16
outLabel
;
uint32_t
len
=
0
offset
=
0
;
nsresult
rv
;
nsAString
:
:
const_iterator
start
end
;
inUTF16
.
BeginReading
(
start
)
;
inUTF16
.
EndReading
(
end
)
;
while
(
start
!
=
end
)
{
len
+
+
;
if
(
*
start
+
+
=
=
char16_t
(
'
.
'
)
)
{
rv
=
stringPrep
(
Substring
(
inUTF16
offset
len
-
1
)
outLabel
eStringPrepIgnoreErrors
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outUTF16
.
Append
(
outLabel
)
;
outUTF16
.
Append
(
char16_t
(
'
.
'
)
)
;
offset
+
=
len
;
len
=
0
;
}
}
if
(
len
)
{
rv
=
stringPrep
(
Substring
(
inUTF16
offset
len
)
outLabel
eStringPrepIgnoreErrors
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outUTF16
.
Append
(
outLabel
)
;
}
CopyUTF16toUTF8
(
outUTF16
output
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIDNService
:
:
ConvertToDisplayIDN
(
const
nsACString
&
input
bool
*
_isASCII
nsACString
&
_retval
)
{
nsresult
rv
=
NS_OK
;
bool
isACE
;
IsACE
(
input
&
isACE
)
;
if
(
IsASCII
(
input
)
)
{
_retval
=
input
;
ToLowerCase
(
_retval
)
;
if
(
isACE
&
&
!
mShowPunycode
)
{
nsAutoCString
temp
(
_retval
)
;
ACEtoUTF8
(
temp
_retval
isInWhitelist
(
temp
)
?
eStringPrepIgnoreErrors
:
eStringPrepForUI
)
;
*
_isASCII
=
IsASCII
(
_retval
)
;
}
else
{
*
_isASCII
=
true
;
}
}
else
{
if
(
isACE
)
{
nsAutoCString
temp
;
ACEtoUTF8
(
input
temp
eStringPrepIgnoreErrors
)
;
rv
=
Normalize
(
temp
_retval
)
;
}
else
{
rv
=
Normalize
(
input
_retval
)
;
}
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
mShowPunycode
&
&
NS_SUCCEEDED
(
UTF8toACE
(
_retval
_retval
eStringPrepIgnoreErrors
)
)
)
{
*
_isASCII
=
true
;
return
NS_OK
;
}
*
_isASCII
=
IsASCII
(
_retval
)
;
if
(
!
*
_isASCII
&
&
!
isInWhitelist
(
_retval
)
)
{
rv
=
UTF8toACE
(
_retval
_retval
eStringPrepForUI
)
;
*
_isASCII
=
IsASCII
(
_retval
)
;
return
rv
;
}
}
return
NS_OK
;
}
static
nsresult
utf16ToUcs4
(
const
nsAString
&
in
uint32_t
*
out
uint32_t
outBufLen
uint32_t
*
outLen
)
{
uint32_t
i
=
0
;
nsAString
:
:
const_iterator
start
end
;
in
.
BeginReading
(
start
)
;
in
.
EndReading
(
end
)
;
while
(
start
!
=
end
)
{
char16_t
curChar
;
curChar
=
*
start
+
+
;
if
(
start
!
=
end
&
&
NS_IS_HIGH_SURROGATE
(
curChar
)
&
&
NS_IS_LOW_SURROGATE
(
*
start
)
)
{
out
[
i
]
=
SURROGATE_TO_UCS4
(
curChar
*
start
)
;
+
+
start
;
}
else
out
[
i
]
=
curChar
;
i
+
+
;
if
(
i
>
=
outBufLen
)
return
NS_ERROR_MALFORMED_URI
;
}
out
[
i
]
=
(
uint32_t
)
'
\
0
'
;
*
outLen
=
i
;
return
NS_OK
;
}
#
ifndef
IDNA2008
static
void
ucs4toUtf16
(
const
uint32_t
*
in
nsAString
&
out
)
{
while
(
*
in
)
{
if
(
!
IS_IN_BMP
(
*
in
)
)
{
out
.
Append
(
(
char16_t
)
H_SURROGATE
(
*
in
)
)
;
out
.
Append
(
(
char16_t
)
L_SURROGATE
(
*
in
)
)
;
}
else
out
.
Append
(
(
char16_t
)
*
in
)
;
in
+
+
;
}
}
#
endif
static
nsresult
punycode
(
const
nsAString
&
in
nsACString
&
out
)
{
uint32_t
ucs4Buf
[
kMaxDNSNodeLen
+
1
]
;
uint32_t
ucs4Len
;
nsresult
rv
=
utf16ToUcs4
(
in
ucs4Buf
kMaxDNSNodeLen
&
ucs4Len
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
uint32_t
kEncodedBufSize
=
kMaxDNSNodeLen
*
20
/
8
+
1
+
1
;
char
encodedBuf
[
kEncodedBufSize
]
;
punycode_uint
encodedLength
=
kEncodedBufSize
;
enum
punycode_status
status
=
punycode_encode
(
ucs4Len
ucs4Buf
nullptr
&
encodedLength
encodedBuf
)
;
if
(
punycode_success
!
=
status
|
|
encodedLength
>
=
kEncodedBufSize
)
return
NS_ERROR_MALFORMED_URI
;
encodedBuf
[
encodedLength
]
=
'
\
0
'
;
out
.
Assign
(
nsDependentCString
(
kACEPrefix
)
+
nsDependentCString
(
encodedBuf
)
)
;
return
rv
;
}
nsresult
nsIDNService
:
:
stringPrep
(
const
nsAString
&
in
nsAString
&
out
stringPrepFlag
flag
)
{
#
ifdef
IDNA2008
return
IDNA2008StringPrep
(
in
out
flag
)
;
#
else
if
(
!
mNamePrepHandle
|
|
!
mNormalizer
)
return
NS_ERROR_FAILURE
;
uint32_t
ucs4Buf
[
kMaxDNSNodeLen
+
1
]
;
uint32_t
ucs4Len
;
nsresult
rv
=
utf16ToUcs4
(
in
ucs4Buf
kMaxDNSNodeLen
&
ucs4Len
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
idn_result_t
idn_err
;
uint32_t
namePrepBuf
[
kMaxDNSNodeLen
*
3
]
;
idn_err
=
idn_nameprep_map
(
mNamePrepHandle
(
const
uint32_t
*
)
ucs4Buf
(
uint32_t
*
)
namePrepBuf
kMaxDNSNodeLen
*
3
)
;
NS_ENSURE_TRUE
(
idn_err
=
=
idn_success
NS_ERROR_MALFORMED_URI
)
;
nsAutoString
namePrepStr
;
ucs4toUtf16
(
namePrepBuf
namePrepStr
)
;
if
(
namePrepStr
.
Length
(
)
>
=
kMaxDNSNodeLen
)
return
NS_ERROR_MALFORMED_URI
;
nsAutoString
normlizedStr
;
rv
=
mNormalizer
-
>
NormalizeUnicodeNFKC
(
namePrepStr
normlizedStr
)
;
if
(
normlizedStr
.
Length
(
)
>
=
kMaxDNSNodeLen
)
return
NS_ERROR_MALFORMED_URI
;
out
.
Assign
(
normlizedStr
)
;
if
(
flag
=
=
eStringPrepIgnoreErrors
)
{
return
NS_OK
;
}
const
uint32_t
*
found
=
nullptr
;
idn_err
=
idn_nameprep_isprohibited
(
mNamePrepHandle
(
const
uint32_t
*
)
ucs4Buf
&
found
)
;
if
(
idn_err
!
=
idn_success
|
|
found
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
}
else
{
idn_err
=
idn_nameprep_isvalidbidi
(
mNamePrepHandle
(
const
uint32_t
*
)
ucs4Buf
&
found
)
;
if
(
idn_err
!
=
idn_success
|
|
found
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
}
else
if
(
flag
=
=
eStringPrepForUI
)
{
idn_err
=
idn_nameprep_isunassigned
(
mNamePrepHandle
(
const
uint32_t
*
)
ucs4Buf
&
found
)
;
if
(
idn_err
!
=
idn_success
|
|
found
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
}
}
}
if
(
flag
=
=
eStringPrepForDNS
&
&
NS_FAILED
(
rv
)
)
{
out
.
Truncate
(
)
;
}
return
rv
;
#
endif
}
nsresult
nsIDNService
:
:
stringPrepAndACE
(
const
nsAString
&
in
nsACString
&
out
stringPrepFlag
flag
)
{
nsresult
rv
=
NS_OK
;
out
.
Truncate
(
)
;
if
(
in
.
Length
(
)
>
kMaxDNSNodeLen
)
{
NS_WARNING
(
"
IDN
node
too
large
"
)
;
return
NS_ERROR_MALFORMED_URI
;
}
if
(
IsASCII
(
in
)
)
{
LossyCopyUTF16toASCII
(
in
out
)
;
return
NS_OK
;
}
nsAutoString
strPrep
;
rv
=
stringPrep
(
in
strPrep
flag
)
;
if
(
flag
=
=
eStringPrepForDNS
)
{
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
IsASCII
(
strPrep
)
)
{
LossyCopyUTF16toASCII
(
strPrep
out
)
;
return
NS_OK
;
}
if
(
flag
=
=
eStringPrepForUI
&
&
NS_SUCCEEDED
(
rv
)
&
&
isLabelSafe
(
in
)
)
{
CopyUTF16toUTF8
(
strPrep
out
)
;
return
NS_OK
;
}
rv
=
punycode
(
strPrep
out
)
;
if
(
out
.
Length
(
)
>
kMaxDNSNodeLen
)
{
NS_WARNING
(
"
IDN
node
too
large
"
)
;
return
NS_ERROR_MALFORMED_URI
;
}
return
rv
;
}
void
nsIDNService
:
:
normalizeFullStops
(
nsAString
&
s
)
{
nsAString
:
:
const_iterator
start
end
;
s
.
BeginReading
(
start
)
;
s
.
EndReading
(
end
)
;
int32_t
index
=
0
;
while
(
start
!
=
end
)
{
switch
(
*
start
)
{
case
0x3002
:
case
0xFF0E
:
case
0xFF61
:
s
.
Replace
(
index
1
NS_LITERAL_STRING
(
"
.
"
)
)
;
break
;
default
:
break
;
}
start
+
+
;
index
+
+
;
}
}
nsresult
nsIDNService
:
:
decodeACE
(
const
nsACString
&
in
nsACString
&
out
stringPrepFlag
flag
)
{
bool
isAce
;
IsACE
(
in
&
isAce
)
;
if
(
!
isAce
)
{
out
.
Assign
(
in
)
;
return
NS_OK
;
}
nsAutoString
utf16
;
#
ifdef
IDNA2008
nsresult
result
=
IDNA2008ToUnicode
(
in
utf16
)
;
NS_ENSURE_SUCCESS
(
result
result
)
;
#
else
punycode_uint
output_length
=
in
.
Length
(
)
-
kACEPrefixLen
+
1
;
punycode_uint
*
output
=
new
punycode_uint
[
output_length
]
;
NS_ENSURE_TRUE
(
output
NS_ERROR_OUT_OF_MEMORY
)
;
enum
punycode_status
status
=
punycode_decode
(
in
.
Length
(
)
-
kACEPrefixLen
PromiseFlatCString
(
in
)
.
get
(
)
+
kACEPrefixLen
&
output_length
output
nullptr
)
;
if
(
status
!
=
punycode_success
)
{
delete
[
]
output
;
return
NS_ERROR_MALFORMED_URI
;
}
output
[
output_length
]
=
0
;
ucs4toUtf16
(
output
utf16
)
;
delete
[
]
output
;
#
endif
if
(
flag
!
=
eStringPrepForUI
|
|
isLabelSafe
(
utf16
)
)
{
CopyUTF16toUTF8
(
utf16
out
)
;
}
else
{
out
.
Assign
(
in
)
;
return
NS_OK
;
}
nsAutoCString
ace
;
nsresult
rv
=
UTF8toACE
(
out
ace
flag
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
flag
=
=
eStringPrepForDNS
&
&
!
ace
.
Equals
(
in
nsCaseInsensitiveCStringComparator
(
)
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
return
NS_OK
;
}
bool
nsIDNService
:
:
isInWhitelist
(
const
nsACString
&
host
)
{
if
(
mIDNUseWhitelist
&
&
mIDNWhitelistPrefBranch
)
{
nsAutoCString
tld
(
host
)
;
if
(
!
IsASCII
(
tld
)
&
&
NS_FAILED
(
UTF8toACE
(
tld
tld
eStringPrepForDNS
)
)
)
{
return
false
;
}
tld
.
Trim
(
"
.
"
)
;
int32_t
pos
=
tld
.
RFind
(
"
.
"
)
;
if
(
pos
=
=
kNotFound
)
return
false
;
tld
.
Cut
(
0
pos
+
1
)
;
bool
safe
;
if
(
NS_SUCCEEDED
(
mIDNWhitelistPrefBranch
-
>
GetBoolPref
(
tld
.
get
(
)
&
safe
)
)
)
return
safe
;
}
return
false
;
}
bool
nsIDNService
:
:
isLabelSafe
(
const
nsAString
&
label
)
{
if
(
!
isOnlySafeChars
(
PromiseFlatString
(
label
)
mIDNBlacklist
)
)
{
return
false
;
}
NS_ASSERTION
(
!
IsASCII
(
label
)
"
ASCII
label
in
IDN
checking
"
)
;
if
(
mRestrictionProfile
=
=
eASCIIOnlyProfile
)
{
return
false
;
}
nsAString
:
:
const_iterator
current
end
;
label
.
BeginReading
(
current
)
;
label
.
EndReading
(
end
)
;
int32_t
lastScript
=
MOZ_SCRIPT_INVALID
;
uint32_t
previousChar
=
0
;
uint32_t
savedNumberingSystem
=
0
;
#
if
0
HanVariantType
savedHanVariant
=
HVT_NotHan
;
#
endif
int32_t
savedScript
=
-
1
;
while
(
current
!
=
end
)
{
uint32_t
ch
=
*
current
+
+
;
if
(
NS_IS_HIGH_SURROGATE
(
ch
)
&
&
current
!
=
end
&
&
NS_IS_LOW_SURROGATE
(
*
current
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
current
+
+
)
;
}
XidmodType
xm
=
GetIdentifierModification
(
ch
)
;
if
(
xm
!
=
XIDMOD_RECOMMENDED
&
&
xm
!
=
XIDMOD_INCLUSION
&
&
xm
!
=
XIDMOD_ASPIRATIONAL
)
{
return
false
;
}
int32_t
script
=
GetScriptCode
(
ch
)
;
if
(
script
!
=
MOZ_SCRIPT_COMMON
&
&
script
!
=
MOZ_SCRIPT_INHERITED
&
&
script
!
=
lastScript
)
{
if
(
illegalScriptCombo
(
script
savedScript
)
)
{
return
false
;
}
lastScript
=
script
;
}
if
(
GetGeneralCategory
(
ch
)
=
=
HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER
)
{
uint32_t
zeroCharacter
=
ch
-
GetNumericValue
(
ch
)
;
if
(
savedNumberingSystem
=
=
0
)
{
savedNumberingSystem
=
zeroCharacter
;
}
else
if
(
zeroCharacter
!
=
savedNumberingSystem
)
{
return
false
;
}
}
if
(
previousChar
!
=
0
&
&
previousChar
=
=
ch
&
&
GetGeneralCategory
(
ch
)
=
=
HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK
)
{
return
false
;
}
#
if
0
HanVariantType
hanVariant
=
GetHanVariant
(
ch
)
;
if
(
hanVariant
=
=
HVT_SimplifiedOnly
|
|
hanVariant
=
=
HVT_TraditionalOnly
)
{
if
(
savedHanVariant
=
=
HVT_NotHan
)
{
savedHanVariant
=
hanVariant
;
}
else
if
(
hanVariant
!
=
savedHanVariant
)
{
return
false
;
}
}
#
endif
previousChar
=
ch
;
}
return
true
;
}
static
const
int32_t
scriptTable
[
]
=
{
MOZ_SCRIPT_BOPOMOFO
MOZ_SCRIPT_CYRILLIC
MOZ_SCRIPT_GREEK
MOZ_SCRIPT_HANGUL
MOZ_SCRIPT_HAN
MOZ_SCRIPT_HIRAGANA
MOZ_SCRIPT_KATAKANA
MOZ_SCRIPT_LATIN
}
;
#
define
BOPO
0
#
define
CYRL
1
#
define
GREK
2
#
define
HANG
3
#
define
HANI
4
#
define
HIRA
5
#
define
KATA
6
#
define
LATN
7
#
define
OTHR
8
#
define
JPAN
9
/
/
Latin
+
Han
+
Hiragana
+
Katakana
#
define
CHNA
10
/
/
Latin
+
Han
+
Bopomofo
#
define
KORE
11
/
/
Latin
+
Han
+
Hangul
#
define
HNLT
12
/
/
Latin
+
Han
(
could
be
any
of
the
above
combinations
)
#
define
FAIL
13
static
inline
int32_t
findScriptIndex
(
int32_t
aScript
)
{
int32_t
tableLength
=
sizeof
(
scriptTable
)
/
sizeof
(
int32_t
)
;
for
(
int32_t
index
=
0
;
index
<
tableLength
;
+
+
index
)
{
if
(
aScript
=
=
scriptTable
[
index
]
)
{
return
index
;
}
}
return
OTHR
;
}
static
const
int32_t
scriptComboTable
[
13
]
[
9
]
=
{
{
BOPO
FAIL
FAIL
FAIL
CHNA
FAIL
FAIL
CHNA
FAIL
}
{
FAIL
CYRL
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
}
{
FAIL
FAIL
GREK
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
}
{
FAIL
FAIL
FAIL
HANG
KORE
FAIL
FAIL
KORE
FAIL
}
{
CHNA
FAIL
FAIL
KORE
HANI
JPAN
JPAN
HNLT
FAIL
}
{
FAIL
FAIL
FAIL
FAIL
JPAN
HIRA
JPAN
JPAN
FAIL
}
{
FAIL
FAIL
FAIL
FAIL
JPAN
JPAN
KATA
JPAN
FAIL
}
{
CHNA
FAIL
FAIL
KORE
HNLT
JPAN
JPAN
LATN
OTHR
}
{
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
OTHR
FAIL
}
{
FAIL
FAIL
FAIL
FAIL
JPAN
JPAN
JPAN
JPAN
FAIL
}
{
CHNA
FAIL
FAIL
FAIL
CHNA
FAIL
FAIL
CHNA
FAIL
}
{
FAIL
FAIL
FAIL
KORE
KORE
FAIL
FAIL
KORE
FAIL
}
{
CHNA
FAIL
FAIL
KORE
HNLT
JPAN
JPAN
HNLT
FAIL
}
}
;
bool
nsIDNService
:
:
illegalScriptCombo
(
int32_t
script
int32_t
&
savedScript
)
{
if
(
savedScript
=
=
-
1
)
{
savedScript
=
findScriptIndex
(
script
)
;
return
false
;
}
savedScript
=
scriptComboTable
[
savedScript
]
[
findScriptIndex
(
script
)
]
;
return
(
(
savedScript
=
=
OTHR
&
&
mRestrictionProfile
=
=
eHighlyRestrictiveProfile
)
|
|
savedScript
=
=
FAIL
)
;
}
#
undef
BOPO
#
undef
CYRL
#
undef
GREK
#
undef
HANG
#
undef
HANI
#
undef
HIRA
#
undef
KATA
#
undef
LATN
#
undef
OTHR
#
undef
JPAN
#
undef
CHNA
#
undef
KORE
#
undef
HNLT
#
undef
FAIL
