#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsIDNService
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsUnicodeScriptCodes
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
punycode
.
h
"
const
bool
kIDNA2008_TransitionalProcessing
=
false
;
#
include
"
ICUUtils
.
h
"
#
include
"
unicode
/
uscript
.
h
"
using
namespace
mozilla
:
:
unicode
;
using
mozilla
:
:
Preferences
;
static
const
uint32_t
kMaxDNSNodeLen
=
63
;
static
const
char
kACEPrefix
[
]
=
"
xn
-
-
"
;
#
define
kACEPrefixLen
4
#
define
NS_NET_PREF_IDNBLACKLIST
"
network
.
IDN
.
blacklist_chars
"
#
define
NS_NET_PREF_SHOWPUNYCODE
"
network
.
IDN_show_punycode
"
#
define
NS_NET_PREF_IDNWHITELIST
"
network
.
IDN
.
whitelist
.
"
#
define
NS_NET_PREF_IDNUSEWHITELIST
"
network
.
IDN
.
use_whitelist
"
#
define
NS_NET_PREF_IDNRESTRICTION
"
network
.
IDN
.
restriction_profile
"
inline
bool
isOnlySafeChars
(
const
nsString
&
in
const
nsString
&
blacklist
)
{
return
(
blacklist
.
IsEmpty
(
)
|
|
in
.
FindCharInSet
(
blacklist
)
=
=
kNotFound
)
;
}
NS_IMPL_ISUPPORTS
(
nsIDNService
nsIIDNService
nsISupportsWeakReference
)
static
const
char
*
gCallbackPrefs
[
]
=
{
NS_NET_PREF_IDNBLACKLIST
NS_NET_PREF_SHOWPUNYCODE
NS_NET_PREF_IDNRESTRICTION
NS_NET_PREF_IDNUSEWHITELIST
nullptr
}
;
nsresult
nsIDNService
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mLock
)
;
nsCOMPtr
<
nsIPrefService
>
prefs
(
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
)
;
if
(
prefs
)
prefs
-
>
GetBranch
(
NS_NET_PREF_IDNWHITELIST
getter_AddRefs
(
mIDNWhitelistPrefBranch
)
)
;
Preferences
:
:
RegisterPrefixCallbacks
(
PrefChanged
gCallbackPrefs
this
)
;
prefsChanged
(
nullptr
)
;
return
NS_OK
;
}
void
nsIDNService
:
:
prefsChanged
(
const
char
*
pref
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
!
pref
|
|
NS_LITERAL_CSTRING
(
NS_NET_PREF_IDNBLACKLIST
)
.
Equals
(
pref
)
)
{
nsAutoCString
blacklist
;
nsresult
rv
=
Preferences
:
:
GetCString
(
NS_NET_PREF_IDNBLACKLIST
blacklist
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF8toUTF16
(
blacklist
mIDNBlacklist
)
;
}
else
{
mIDNBlacklist
.
Truncate
(
)
;
}
}
if
(
!
pref
|
|
NS_LITERAL_CSTRING
(
NS_NET_PREF_SHOWPUNYCODE
)
.
Equals
(
pref
)
)
{
bool
val
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetBool
(
NS_NET_PREF_SHOWPUNYCODE
&
val
)
)
)
mShowPunycode
=
val
;
}
if
(
!
pref
|
|
NS_LITERAL_CSTRING
(
NS_NET_PREF_IDNUSEWHITELIST
)
.
Equals
(
pref
)
)
{
bool
val
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetBool
(
NS_NET_PREF_IDNUSEWHITELIST
&
val
)
)
)
mIDNUseWhitelist
=
val
;
}
if
(
!
pref
|
|
NS_LITERAL_CSTRING
(
NS_NET_PREF_IDNRESTRICTION
)
.
Equals
(
pref
)
)
{
nsAutoCString
profile
;
if
(
NS_FAILED
(
Preferences
:
:
GetCString
(
NS_NET_PREF_IDNRESTRICTION
profile
)
)
)
{
profile
.
Truncate
(
)
;
}
if
(
profile
.
EqualsLiteral
(
"
moderate
"
)
)
{
mRestrictionProfile
=
eModeratelyRestrictiveProfile
;
}
else
if
(
profile
.
EqualsLiteral
(
"
high
"
)
)
{
mRestrictionProfile
=
eHighlyRestrictiveProfile
;
}
else
{
mRestrictionProfile
=
eASCIIOnlyProfile
;
}
}
}
nsIDNService
:
:
nsIDNService
(
)
:
mLock
(
"
DNService
pref
value
lock
"
)
mShowPunycode
(
false
)
mRestrictionProfile
(
static_cast
<
restrictionProfile
>
(
0
)
)
mIDNUseWhitelist
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
uint32_t
IDNAOptions
=
UIDNA_CHECK_BIDI
|
UIDNA_CHECK_CONTEXTJ
;
if
(
!
kIDNA2008_TransitionalProcessing
)
{
IDNAOptions
|
=
UIDNA_NONTRANSITIONAL_TO_UNICODE
;
}
UErrorCode
errorCode
=
U_ZERO_ERROR
;
mIDNA
=
uidna_openUTS46
(
IDNAOptions
&
errorCode
)
;
}
nsIDNService
:
:
~
nsIDNService
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Preferences
:
:
UnregisterPrefixCallbacks
(
PrefChanged
gCallbackPrefs
this
)
;
uidna_close
(
mIDNA
)
;
}
nsresult
nsIDNService
:
:
IDNA2008ToUnicode
(
const
nsACString
&
input
nsAString
&
output
)
{
NS_ConvertUTF8toUTF16
inputStr
(
input
)
;
UIDNAInfo
info
=
UIDNA_INFO_INITIALIZER
;
UErrorCode
errorCode
=
U_ZERO_ERROR
;
int32_t
inLen
=
inputStr
.
Length
(
)
;
int32_t
outMaxLen
=
kMaxDNSNodeLen
+
1
;
UChar
outputBuffer
[
kMaxDNSNodeLen
+
1
]
;
int32_t
outLen
=
uidna_labelToUnicode
(
mIDNA
(
const
UChar
*
)
inputStr
.
get
(
)
inLen
outputBuffer
outMaxLen
&
info
&
errorCode
)
;
if
(
info
.
errors
!
=
0
)
{
return
NS_ERROR_MALFORMED_URI
;
}
if
(
U_SUCCESS
(
errorCode
)
)
{
ICUUtils
:
:
AssignUCharArrayToString
(
outputBuffer
outLen
output
)
;
}
nsresult
rv
=
ICUUtils
:
:
UErrorToNsResult
(
errorCode
)
;
if
(
rv
=
=
NS_ERROR_FAILURE
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
}
return
rv
;
}
nsresult
nsIDNService
:
:
IDNA2008StringPrep
(
const
nsAString
&
input
nsAString
&
output
stringPrepFlag
flag
)
{
UIDNAInfo
info
=
UIDNA_INFO_INITIALIZER
;
UErrorCode
errorCode
=
U_ZERO_ERROR
;
int32_t
inLen
=
input
.
Length
(
)
;
int32_t
outMaxLen
=
kMaxDNSNodeLen
+
1
;
UChar
outputBuffer
[
kMaxDNSNodeLen
+
1
]
;
int32_t
outLen
=
uidna_labelToUnicode
(
mIDNA
(
const
UChar
*
)
PromiseFlatString
(
input
)
.
get
(
)
inLen
outputBuffer
outMaxLen
&
info
&
errorCode
)
;
nsresult
rv
=
ICUUtils
:
:
UErrorToNsResult
(
errorCode
)
;
if
(
rv
=
=
NS_ERROR_FAILURE
)
{
rv
=
NS_ERROR_MALFORMED_URI
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
(
info
.
errors
&
UIDNA_ERROR_PUNYCODE
)
&
&
outLen
>
0
&
&
outputBuffer
[
outLen
-
1
]
=
=
0xfffd
)
{
-
-
outLen
;
}
ICUUtils
:
:
AssignUCharArrayToString
(
outputBuffer
outLen
output
)
;
if
(
flag
=
=
eStringPrepIgnoreErrors
)
{
return
NS_OK
;
}
if
(
info
.
errors
!
=
0
)
{
if
(
flag
=
=
eStringPrepForDNS
)
{
output
.
Truncate
(
)
;
}
rv
=
NS_ERROR_MALFORMED_URI
;
}
return
rv
;
}
NS_IMETHODIMP
nsIDNService
:
:
ConvertUTF8toACE
(
const
nsACString
&
input
nsACString
&
ace
)
{
return
UTF8toACE
(
input
ace
eStringPrepForDNS
)
;
}
nsresult
nsIDNService
:
:
UTF8toACE
(
const
nsACString
&
input
nsACString
&
ace
stringPrepFlag
flag
)
{
nsresult
rv
;
NS_ConvertUTF8toUTF16
ustr
(
input
)
;
normalizeFullStops
(
ustr
)
;
uint32_t
len
offset
;
len
=
0
;
offset
=
0
;
nsAutoCString
encodedBuf
;
nsAString
:
:
const_iterator
start
end
;
ustr
.
BeginReading
(
start
)
;
ustr
.
EndReading
(
end
)
;
ace
.
Truncate
(
)
;
while
(
start
!
=
end
)
{
len
+
+
;
if
(
*
start
+
+
=
=
(
char16_t
)
'
.
'
)
{
rv
=
stringPrepAndACE
(
Substring
(
ustr
offset
len
-
1
)
encodedBuf
flag
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ace
.
Append
(
encodedBuf
)
;
ace
.
Append
(
'
.
'
)
;
offset
+
=
len
;
len
=
0
;
}
}
if
(
len
)
{
rv
=
stringPrepAndACE
(
Substring
(
ustr
offset
len
)
encodedBuf
flag
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ace
.
Append
(
encodedBuf
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIDNService
:
:
ConvertACEtoUTF8
(
const
nsACString
&
input
nsACString
&
_retval
)
{
return
ACEtoUTF8
(
input
_retval
eStringPrepForDNS
)
;
}
nsresult
nsIDNService
:
:
ACEtoUTF8
(
const
nsACString
&
input
nsACString
&
_retval
stringPrepFlag
flag
)
{
uint32_t
len
=
0
offset
=
0
;
nsAutoCString
decodedBuf
;
nsACString
:
:
const_iterator
start
end
;
input
.
BeginReading
(
start
)
;
input
.
EndReading
(
end
)
;
_retval
.
Truncate
(
)
;
while
(
start
!
=
end
)
{
len
+
+
;
if
(
*
start
+
+
=
=
'
.
'
)
{
nsDependentCSubstring
origLabel
(
input
offset
len
-
1
)
;
if
(
NS_FAILED
(
decodeACE
(
origLabel
decodedBuf
flag
)
)
)
{
_retval
.
Append
(
origLabel
)
;
}
else
{
_retval
.
Append
(
decodedBuf
)
;
}
_retval
.
Append
(
'
.
'
)
;
offset
+
=
len
;
len
=
0
;
}
}
if
(
len
)
{
nsDependentCSubstring
origLabel
(
input
offset
len
)
;
if
(
NS_FAILED
(
decodeACE
(
origLabel
decodedBuf
flag
)
)
)
{
_retval
.
Append
(
origLabel
)
;
}
else
{
_retval
.
Append
(
decodedBuf
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsIDNService
:
:
IsACE
(
const
nsACString
&
input
bool
*
_retval
)
{
const
char
*
data
=
input
.
BeginReading
(
)
;
uint32_t
dataLen
=
input
.
Length
(
)
;
const
char
*
p
=
PL_strncasestr
(
data
kACEPrefix
dataLen
)
;
*
_retval
=
p
&
&
(
p
=
=
data
|
|
*
(
p
-
1
)
=
=
'
.
'
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIDNService
:
:
Normalize
(
const
nsACString
&
input
nsACString
&
output
)
{
NS_ENSURE_TRUE
(
IsUTF8
(
input
)
NS_ERROR_UNEXPECTED
)
;
NS_ConvertUTF8toUTF16
inUTF16
(
input
)
;
normalizeFullStops
(
inUTF16
)
;
nsAutoString
outUTF16
outLabel
;
uint32_t
len
=
0
offset
=
0
;
nsresult
rv
;
nsAString
:
:
const_iterator
start
end
;
inUTF16
.
BeginReading
(
start
)
;
inUTF16
.
EndReading
(
end
)
;
while
(
start
!
=
end
)
{
len
+
+
;
if
(
*
start
+
+
=
=
char16_t
(
'
.
'
)
)
{
rv
=
stringPrep
(
Substring
(
inUTF16
offset
len
-
1
)
outLabel
eStringPrepIgnoreErrors
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outUTF16
.
Append
(
outLabel
)
;
outUTF16
.
Append
(
char16_t
(
'
.
'
)
)
;
offset
+
=
len
;
len
=
0
;
}
}
if
(
len
)
{
rv
=
stringPrep
(
Substring
(
inUTF16
offset
len
)
outLabel
eStringPrepIgnoreErrors
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outUTF16
.
Append
(
outLabel
)
;
}
CopyUTF16toUTF8
(
outUTF16
output
)
;
return
NS_OK
;
}
namespace
{
class
MOZ_STACK_CLASS
MutexSettableAutoUnlock
final
{
Mutex
*
mMutex
;
public
:
MutexSettableAutoUnlock
(
)
:
mMutex
(
nullptr
)
{
}
void
Acquire
(
mozilla
:
:
Mutex
&
aMutex
)
{
MOZ_ASSERT
(
!
mMutex
)
;
mMutex
=
&
aMutex
;
mMutex
-
>
Lock
(
)
;
}
~
MutexSettableAutoUnlock
(
)
{
if
(
mMutex
)
{
mMutex
-
>
Unlock
(
)
;
}
}
}
;
}
NS_IMETHODIMP
nsIDNService
:
:
ConvertToDisplayIDN
(
const
nsACString
&
input
bool
*
_isASCII
nsACString
&
_retval
)
{
MutexSettableAutoUnlock
lock
;
if
(
!
NS_IsMainThread
(
)
)
{
lock
.
Acquire
(
mLock
)
;
}
nsresult
rv
=
NS_OK
;
bool
isACE
;
IsACE
(
input
&
isACE
)
;
if
(
IsASCII
(
input
)
)
{
_retval
=
input
;
ToLowerCase
(
_retval
)
;
if
(
isACE
&
&
!
mShowPunycode
)
{
nsAutoCString
temp
(
_retval
)
;
ACEtoUTF8
(
temp
_retval
isInWhitelist
(
temp
)
?
eStringPrepIgnoreErrors
:
eStringPrepForUI
)
;
*
_isASCII
=
IsASCII
(
_retval
)
;
}
else
{
*
_isASCII
=
true
;
}
}
else
{
if
(
isACE
)
{
nsAutoCString
temp
;
ACEtoUTF8
(
input
temp
eStringPrepIgnoreErrors
)
;
rv
=
Normalize
(
temp
_retval
)
;
}
else
{
rv
=
Normalize
(
input
_retval
)
;
}
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
mShowPunycode
&
&
NS_SUCCEEDED
(
UTF8toACE
(
_retval
_retval
eStringPrepIgnoreErrors
)
)
)
{
*
_isASCII
=
true
;
return
NS_OK
;
}
*
_isASCII
=
IsASCII
(
_retval
)
;
if
(
!
*
_isASCII
&
&
!
isInWhitelist
(
_retval
)
)
{
rv
=
UTF8toACE
(
_retval
_retval
eStringPrepForUI
)
;
*
_isASCII
=
IsASCII
(
_retval
)
;
return
rv
;
}
}
return
NS_OK
;
}
static
nsresult
utf16ToUcs4
(
const
nsAString
&
in
uint32_t
*
out
uint32_t
outBufLen
uint32_t
*
outLen
)
{
uint32_t
i
=
0
;
nsAString
:
:
const_iterator
start
end
;
in
.
BeginReading
(
start
)
;
in
.
EndReading
(
end
)
;
while
(
start
!
=
end
)
{
char16_t
curChar
;
curChar
=
*
start
+
+
;
if
(
start
!
=
end
&
&
NS_IS_HIGH_SURROGATE
(
curChar
)
&
&
NS_IS_LOW_SURROGATE
(
*
start
)
)
{
out
[
i
]
=
SURROGATE_TO_UCS4
(
curChar
*
start
)
;
+
+
start
;
}
else
out
[
i
]
=
curChar
;
i
+
+
;
if
(
i
>
=
outBufLen
)
return
NS_ERROR_MALFORMED_URI
;
}
out
[
i
]
=
(
uint32_t
)
'
\
0
'
;
*
outLen
=
i
;
return
NS_OK
;
}
static
nsresult
punycode
(
const
nsAString
&
in
nsACString
&
out
)
{
uint32_t
ucs4Buf
[
kMaxDNSNodeLen
+
1
]
;
uint32_t
ucs4Len
=
0u
;
nsresult
rv
=
utf16ToUcs4
(
in
ucs4Buf
kMaxDNSNodeLen
&
ucs4Len
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
uint32_t
kEncodedBufSize
=
kMaxDNSNodeLen
*
20
/
8
+
1
+
1
;
char
encodedBuf
[
kEncodedBufSize
]
;
punycode_uint
encodedLength
=
kEncodedBufSize
;
enum
punycode_status
status
=
punycode_encode
(
ucs4Len
ucs4Buf
nullptr
&
encodedLength
encodedBuf
)
;
if
(
punycode_success
!
=
status
|
|
encodedLength
>
=
kEncodedBufSize
)
return
NS_ERROR_MALFORMED_URI
;
encodedBuf
[
encodedLength
]
=
'
\
0
'
;
out
.
Assign
(
nsDependentCString
(
kACEPrefix
)
+
nsDependentCString
(
encodedBuf
)
)
;
return
rv
;
}
nsresult
nsIDNService
:
:
stringPrep
(
const
nsAString
&
in
nsAString
&
out
stringPrepFlag
flag
)
{
return
IDNA2008StringPrep
(
in
out
flag
)
;
}
nsresult
nsIDNService
:
:
stringPrepAndACE
(
const
nsAString
&
in
nsACString
&
out
stringPrepFlag
flag
)
{
nsresult
rv
=
NS_OK
;
out
.
Truncate
(
)
;
if
(
in
.
Length
(
)
>
kMaxDNSNodeLen
)
{
NS_WARNING
(
"
IDN
node
too
large
"
)
;
return
NS_ERROR_MALFORMED_URI
;
}
if
(
IsASCII
(
in
)
)
{
LossyCopyUTF16toASCII
(
in
out
)
;
return
NS_OK
;
}
nsAutoString
strPrep
;
rv
=
stringPrep
(
in
strPrep
flag
)
;
if
(
flag
=
=
eStringPrepForDNS
)
{
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
IsASCII
(
strPrep
)
)
{
LossyCopyUTF16toASCII
(
strPrep
out
)
;
return
NS_OK
;
}
if
(
flag
=
=
eStringPrepForUI
&
&
NS_SUCCEEDED
(
rv
)
&
&
isLabelSafe
(
in
)
)
{
CopyUTF16toUTF8
(
strPrep
out
)
;
return
NS_OK
;
}
rv
=
punycode
(
strPrep
out
)
;
if
(
out
.
Length
(
)
>
kMaxDNSNodeLen
)
{
NS_WARNING
(
"
IDN
node
too
large
"
)
;
return
NS_ERROR_MALFORMED_URI
;
}
return
rv
;
}
void
nsIDNService
:
:
normalizeFullStops
(
nsAString
&
s
)
{
nsAString
:
:
const_iterator
start
end
;
s
.
BeginReading
(
start
)
;
s
.
EndReading
(
end
)
;
int32_t
index
=
0
;
while
(
start
!
=
end
)
{
switch
(
*
start
)
{
case
0x3002
:
case
0xFF0E
:
case
0xFF61
:
s
.
ReplaceLiteral
(
index
1
u
"
.
"
)
;
break
;
default
:
break
;
}
start
+
+
;
index
+
+
;
}
}
nsresult
nsIDNService
:
:
decodeACE
(
const
nsACString
&
in
nsACString
&
out
stringPrepFlag
flag
)
{
bool
isAce
;
IsACE
(
in
&
isAce
)
;
if
(
!
isAce
)
{
out
.
Assign
(
in
)
;
return
NS_OK
;
}
nsAutoString
utf16
;
nsresult
result
=
IDNA2008ToUnicode
(
in
utf16
)
;
NS_ENSURE_SUCCESS
(
result
result
)
;
if
(
flag
!
=
eStringPrepForUI
|
|
isLabelSafe
(
utf16
)
)
{
CopyUTF16toUTF8
(
utf16
out
)
;
}
else
{
out
.
Assign
(
in
)
;
return
NS_OK
;
}
nsAutoCString
ace
;
nsresult
rv
=
UTF8toACE
(
out
ace
flag
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
flag
=
=
eStringPrepForDNS
&
&
!
ace
.
Equals
(
in
nsCaseInsensitiveCStringComparator
(
)
)
)
{
return
NS_ERROR_MALFORMED_URI
;
}
return
NS_OK
;
}
bool
nsIDNService
:
:
isInWhitelist
(
const
nsACString
&
host
)
{
if
(
!
NS_IsMainThread
(
)
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
}
if
(
mIDNUseWhitelist
&
&
mIDNWhitelistPrefBranch
)
{
nsAutoCString
tld
(
host
)
;
if
(
!
IsASCII
(
tld
)
&
&
NS_FAILED
(
UTF8toACE
(
tld
tld
eStringPrepForDNS
)
)
)
{
return
false
;
}
tld
.
Trim
(
"
.
"
)
;
int32_t
pos
=
tld
.
RFind
(
"
.
"
)
;
if
(
pos
=
=
kNotFound
)
return
false
;
tld
.
Cut
(
0
pos
+
1
)
;
bool
safe
;
if
(
NS_SUCCEEDED
(
mIDNWhitelistPrefBranch
-
>
GetBoolPref
(
tld
.
get
(
)
&
safe
)
)
)
return
safe
;
}
return
false
;
}
bool
nsIDNService
:
:
isLabelSafe
(
const
nsAString
&
label
)
{
if
(
!
NS_IsMainThread
(
)
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
}
if
(
!
isOnlySafeChars
(
PromiseFlatString
(
label
)
mIDNBlacklist
)
)
{
return
false
;
}
NS_ASSERTION
(
!
IsASCII
(
label
)
"
ASCII
label
in
IDN
checking
"
)
;
if
(
mRestrictionProfile
=
=
eASCIIOnlyProfile
)
{
return
false
;
}
nsAString
:
:
const_iterator
current
end
;
label
.
BeginReading
(
current
)
;
label
.
EndReading
(
end
)
;
Script
lastScript
=
Script
:
:
INVALID
;
uint32_t
previousChar
=
0
;
uint32_t
baseChar
=
0
;
uint32_t
savedNumberingSystem
=
0
;
#
if
0
HanVariantType
savedHanVariant
=
HVT_NotHan
;
#
endif
int32_t
savedScript
=
-
1
;
while
(
current
!
=
end
)
{
uint32_t
ch
=
*
current
+
+
;
if
(
NS_IS_HIGH_SURROGATE
(
ch
)
&
&
current
!
=
end
&
&
NS_IS_LOW_SURROGATE
(
*
current
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
current
+
+
)
;
}
IdentifierType
idType
=
GetIdentifierType
(
ch
)
;
if
(
idType
=
=
IDTYPE_RESTRICTED
)
{
return
false
;
}
MOZ_ASSERT
(
idType
=
=
IDTYPE_ALLOWED
)
;
Script
script
=
GetScriptCode
(
ch
)
;
if
(
script
!
=
Script
:
:
COMMON
&
&
script
!
=
Script
:
:
INHERITED
&
&
script
!
=
lastScript
)
{
if
(
illegalScriptCombo
(
script
savedScript
)
)
{
return
false
;
}
}
auto
genCat
=
GetGeneralCategory
(
ch
)
;
if
(
genCat
=
=
HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER
)
{
uint32_t
zeroCharacter
=
ch
-
GetNumericValue
(
ch
)
;
if
(
savedNumberingSystem
=
=
0
)
{
savedNumberingSystem
=
zeroCharacter
;
}
else
if
(
zeroCharacter
!
=
savedNumberingSystem
)
{
return
false
;
}
}
if
(
genCat
=
=
HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK
)
{
if
(
previousChar
!
=
0
&
&
previousChar
=
=
ch
)
{
return
false
;
}
if
(
lastScript
!
=
Script
:
:
INVALID
)
{
const
size_t
kMaxScripts
=
32
;
UScriptCode
scripts
[
kMaxScripts
]
;
UErrorCode
errorCode
=
U_ZERO_ERROR
;
int
nScripts
=
uscript_getScriptExtensions
(
ch
scripts
kMaxScripts
&
errorCode
)
;
MOZ_ASSERT
(
U_SUCCESS
(
errorCode
)
"
uscript_getScriptExtensions
failed
"
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
false
;
}
if
(
nScripts
>
1
|
|
(
Script
(
scripts
[
0
]
)
!
=
Script
:
:
COMMON
&
&
Script
(
scripts
[
0
]
)
!
=
Script
:
:
INHERITED
)
)
{
while
(
-
-
nScripts
>
=
0
)
{
if
(
Script
(
scripts
[
nScripts
]
)
=
=
lastScript
)
{
break
;
}
}
if
(
nScripts
=
=
-
1
)
{
return
false
;
}
}
}
if
(
baseChar
=
=
0x0131
&
&
(
(
ch
>
=
0x0300
&
&
ch
<
=
0x0314
)
|
|
ch
=
=
0x031a
)
)
{
return
false
;
}
}
else
{
baseChar
=
ch
;
}
if
(
script
!
=
Script
:
:
COMMON
&
&
script
!
=
Script
:
:
INHERITED
)
{
lastScript
=
script
;
}
#
if
0
HanVariantType
hanVariant
=
GetHanVariant
(
ch
)
;
if
(
hanVariant
=
=
HVT_SimplifiedOnly
|
|
hanVariant
=
=
HVT_TraditionalOnly
)
{
if
(
savedHanVariant
=
=
HVT_NotHan
)
{
savedHanVariant
=
hanVariant
;
}
else
if
(
hanVariant
!
=
savedHanVariant
)
{
return
false
;
}
}
#
endif
previousChar
=
ch
;
}
return
true
;
}
static
const
Script
scriptTable
[
]
=
{
Script
:
:
BOPOMOFO
Script
:
:
CYRILLIC
Script
:
:
GREEK
Script
:
:
HANGUL
Script
:
:
HAN
Script
:
:
HIRAGANA
Script
:
:
KATAKANA
Script
:
:
LATIN
}
;
#
define
BOPO
0
#
define
CYRL
1
#
define
GREK
2
#
define
HANG
3
#
define
HANI
4
#
define
HIRA
5
#
define
KATA
6
#
define
LATN
7
#
define
OTHR
8
#
define
JPAN
9
/
/
Latin
+
Han
+
Hiragana
+
Katakana
#
define
CHNA
10
/
/
Latin
+
Han
+
Bopomofo
#
define
KORE
11
/
/
Latin
+
Han
+
Hangul
#
define
HNLT
12
/
/
Latin
+
Han
(
could
be
any
of
the
above
combinations
)
#
define
FAIL
13
static
inline
int32_t
findScriptIndex
(
Script
aScript
)
{
int32_t
tableLength
=
mozilla
:
:
ArrayLength
(
scriptTable
)
;
for
(
int32_t
index
=
0
;
index
<
tableLength
;
+
+
index
)
{
if
(
aScript
=
=
scriptTable
[
index
]
)
{
return
index
;
}
}
return
OTHR
;
}
static
const
int32_t
scriptComboTable
[
13
]
[
9
]
=
{
{
BOPO
FAIL
FAIL
FAIL
CHNA
FAIL
FAIL
CHNA
FAIL
}
{
FAIL
CYRL
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
}
{
FAIL
FAIL
GREK
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
}
{
FAIL
FAIL
FAIL
HANG
KORE
FAIL
FAIL
KORE
FAIL
}
{
CHNA
FAIL
FAIL
KORE
HANI
JPAN
JPAN
HNLT
FAIL
}
{
FAIL
FAIL
FAIL
FAIL
JPAN
HIRA
JPAN
JPAN
FAIL
}
{
FAIL
FAIL
FAIL
FAIL
JPAN
JPAN
KATA
JPAN
FAIL
}
{
CHNA
FAIL
FAIL
KORE
HNLT
JPAN
JPAN
LATN
OTHR
}
{
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
FAIL
OTHR
FAIL
}
{
FAIL
FAIL
FAIL
FAIL
JPAN
JPAN
JPAN
JPAN
FAIL
}
{
CHNA
FAIL
FAIL
FAIL
CHNA
FAIL
FAIL
CHNA
FAIL
}
{
FAIL
FAIL
FAIL
KORE
KORE
FAIL
FAIL
KORE
FAIL
}
{
CHNA
FAIL
FAIL
KORE
HNLT
JPAN
JPAN
HNLT
FAIL
}
}
;
bool
nsIDNService
:
:
illegalScriptCombo
(
Script
script
int32_t
&
savedScript
)
{
if
(
!
NS_IsMainThread
(
)
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
}
if
(
savedScript
=
=
-
1
)
{
savedScript
=
findScriptIndex
(
script
)
;
return
false
;
}
savedScript
=
scriptComboTable
[
savedScript
]
[
findScriptIndex
(
script
)
]
;
return
(
(
savedScript
=
=
OTHR
&
&
mRestrictionProfile
=
=
eHighlyRestrictiveProfile
)
|
|
savedScript
=
=
FAIL
)
;
}
#
undef
BOPO
#
undef
CYRL
#
undef
GREK
#
undef
HANG
#
undef
HANI
#
undef
HIRA
#
undef
KATA
#
undef
LATN
#
undef
OTHR
#
undef
JPAN
#
undef
CHNA
#
undef
KORE
#
undef
HNLT
#
undef
FAIL
