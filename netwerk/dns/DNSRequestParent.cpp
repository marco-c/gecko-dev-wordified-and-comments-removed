#
include
"
mozilla
/
net
/
DNSRequestParent
.
h
"
#
include
"
nsIDNSService
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsICancelable
.
h
"
#
include
"
nsIDNSRecord
.
h
"
#
include
"
nsHostResolver
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
{
namespace
net
{
DNSRequestParent
:
:
DNSRequestParent
(
)
:
mFlags
(
0
)
mIPCClosed
(
false
)
{
}
void
DNSRequestParent
:
:
DoAsyncResolve
(
const
nsACString
&
hostname
const
OriginAttributes
&
originAttributes
uint32_t
flags
)
{
nsresult
rv
;
mFlags
=
flags
;
nsCOMPtr
<
nsIDNSService
>
dns
=
do_GetService
(
NS_DNSSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIEventTarget
>
main
=
GetMainThreadEventTarget
(
)
;
nsCOMPtr
<
nsICancelable
>
unused
;
rv
=
dns
-
>
AsyncResolveNative
(
hostname
flags
this
main
originAttributes
getter_AddRefs
(
unused
)
)
;
}
if
(
NS_FAILED
(
rv
)
&
&
!
mIPCClosed
)
{
mIPCClosed
=
true
;
Unused
<
<
SendLookupCompleted
(
DNSRequestResponse
(
rv
)
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
DNSRequestParent
:
:
RecvCancelDNSRequest
(
const
nsCString
&
hostName
const
uint16_t
&
type
const
OriginAttributes
&
originAttributes
const
uint32_t
&
flags
const
nsresult
&
reason
)
{
nsresult
rv
;
nsCOMPtr
<
nsIDNSService
>
dns
=
do_GetService
(
NS_DNSSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
type
=
=
nsIDNSService
:
:
RESOLVE_TYPE_DEFAULT
)
{
rv
=
dns
-
>
CancelAsyncResolveNative
(
hostName
flags
this
reason
originAttributes
)
;
}
else
{
rv
=
dns
-
>
CancelAsyncResolveByTypeNative
(
hostName
type
flags
this
reason
originAttributes
)
;
}
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
DNSRequestParent
:
:
Recv__delete__
(
)
{
mIPCClosed
=
true
;
return
IPC_OK
(
)
;
}
void
DNSRequestParent
:
:
ActorDestroy
(
ActorDestroyReason
why
)
{
mIPCClosed
=
true
;
}
NS_IMPL_ISUPPORTS
(
DNSRequestParent
nsIDNSListener
)
NS_IMETHODIMP
DNSRequestParent
:
:
OnLookupComplete
(
nsICancelable
*
request
nsIDNSRecord
*
rec
nsresult
status
)
{
if
(
mIPCClosed
)
{
return
NS_OK
;
}
if
(
NS_SUCCEEDED
(
status
)
)
{
MOZ_ASSERT
(
rec
)
;
nsAutoCString
cname
;
if
(
mFlags
&
nsHostResolver
:
:
RES_CANON_NAME
)
{
rec
-
>
GetCanonicalName
(
cname
)
;
}
NetAddrArray
array
;
NetAddr
addr
;
while
(
NS_SUCCEEDED
(
rec
-
>
GetNextAddr
(
80
&
addr
)
)
)
{
array
.
AppendElement
(
addr
)
;
}
Unused
<
<
SendLookupCompleted
(
DNSRequestResponse
(
DNSRecord
(
cname
array
)
)
)
;
}
else
{
Unused
<
<
SendLookupCompleted
(
DNSRequestResponse
(
status
)
)
;
}
mIPCClosed
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
DNSRequestParent
:
:
OnLookupByTypeComplete
(
nsICancelable
*
aRequest
nsIDNSByTypeRecord
*
aRes
nsresult
aStatus
)
{
if
(
mIPCClosed
)
{
return
NS_OK
;
}
if
(
NS_SUCCEEDED
(
aStatus
)
)
{
nsTArray
<
nsCString
>
rec
;
aRes
-
>
GetRecords
(
rec
)
;
Unused
<
<
SendLookupCompleted
(
DNSRequestResponse
(
rec
)
)
;
}
else
{
Unused
<
<
SendLookupCompleted
(
DNSRequestResponse
(
aStatus
)
)
;
}
mIPCClosed
=
true
;
return
NS_OK
;
}
}
}
