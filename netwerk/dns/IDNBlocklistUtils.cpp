#
include
"
IDNBlocklistUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsStringFwd
.
h
"
namespace
mozilla
{
namespace
net
{
static
constexpr
char16_t
sBlocklistPairs
[
]
[
2
]
=
{
#
include
"
IDNCharacterBlocklist
.
inc
"
}
;
void
RemoveCharFromBlocklist
(
char16_t
aChar
nsTArray
<
BlocklistRange
>
&
aBlocklist
)
{
auto
pos
=
aBlocklist
.
BinaryIndexOf
(
aChar
BlocklistPairToCharComparator
(
)
)
;
if
(
pos
=
=
nsTArray
<
BlocklistRange
>
:
:
NoIndex
)
{
return
;
}
auto
&
pair
=
aBlocklist
[
pos
]
;
if
(
pair
.
second
=
=
pair
.
first
)
{
aBlocklist
.
RemoveElementAt
(
pos
)
;
return
;
}
if
(
aChar
=
=
pair
.
first
)
{
pair
.
first
=
pair
.
first
+
1
;
return
;
}
if
(
aChar
=
=
pair
.
second
)
{
pair
.
second
=
pair
.
second
-
1
;
return
;
}
char16_t
lastElement
=
pair
.
second
;
pair
.
second
=
aChar
-
1
;
aBlocklist
.
InsertElementAt
(
pos
+
1
std
:
:
make_pair
(
char16_t
(
aChar
+
1
)
lastElement
)
)
;
}
void
InitializeBlocklist
(
nsTArray
<
BlocklistRange
>
&
aBlocklist
)
{
aBlocklist
.
Clear
(
)
;
for
(
auto
const
&
arr
:
sBlocklistPairs
)
{
aBlocklist
.
AppendElement
(
std
:
:
make_pair
(
arr
[
0
]
arr
[
1
]
)
)
;
}
nsAutoString
extraAllowed
;
nsresult
rv
=
Preferences
:
:
GetString
(
"
network
.
IDN
.
extra_allowed_chars
"
extraAllowed
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
extraAllowed
.
IsEmpty
(
)
)
{
const
char16_t
*
cur
=
extraAllowed
.
BeginReading
(
)
;
const
char16_t
*
end
=
extraAllowed
.
EndReading
(
)
;
for
(
;
cur
<
end
;
+
+
cur
)
{
RemoveCharFromBlocklist
(
*
cur
aBlocklist
)
;
}
}
nsAutoString
extraBlocked
;
rv
=
Preferences
:
:
GetString
(
"
network
.
IDN
.
extra_blocked_chars
"
extraBlocked
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
extraBlocked
.
IsEmpty
(
)
)
{
for
(
size_t
i
=
0
;
i
<
extraBlocked
.
Length
(
)
;
+
+
i
)
{
aBlocklist
.
AppendElement
(
std
:
:
make_pair
(
extraBlocked
[
i
]
extraBlocked
[
i
]
)
)
;
}
aBlocklist
.
Sort
(
BlocklistEntryComparator
(
)
)
;
}
}
}
}
