#
ifndef
TRRService_h_
#
define
TRRService_h_
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DataStorage
.
h
"
#
include
"
nsHostResolver
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsWeakReference
.
h
"
class
nsDNSService
;
class
nsIPrefBranch
;
namespace
mozilla
{
namespace
net
{
class
TRRService
:
public
nsIObserver
public
nsITimerCallback
public
nsSupportsWeakReference
public
AHostResolver
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSITIMERCALLBACK
TRRService
(
)
;
nsresult
Init
(
)
;
nsresult
Start
(
)
;
bool
Enabled
(
nsIRequest
:
:
TRRMode
aMode
)
;
uint32_t
Mode
(
)
{
return
mMode
;
}
bool
AllowRFC1918
(
)
{
return
mRfc1918
;
}
bool
UseGET
(
)
{
return
mUseGET
;
}
bool
EarlyAAAA
(
)
{
return
mEarlyAAAA
;
}
bool
CheckIPv6Connectivity
(
)
{
return
mCheckIPv6Connectivity
;
}
bool
WaitForAllResponses
(
)
{
return
mWaitForAllResponses
;
}
bool
DisableIPv6
(
)
{
return
mDisableIPv6
;
}
bool
DisableECS
(
)
{
return
mDisableECS
;
}
bool
SkipTRRWhenParentalControlEnabled
(
)
{
return
mSkipTRRWhenParentalControlEnabled
;
}
nsresult
GetURI
(
nsCString
&
result
)
;
nsresult
GetCredentials
(
nsCString
&
result
)
;
uint32_t
GetRequestTimeout
(
)
;
LookupStatus
CompleteLookup
(
nsHostRecord
*
nsresult
mozilla
:
:
net
:
:
AddrInfo
*
bool
pb
const
nsACString
&
aOriginSuffix
)
override
;
LookupStatus
CompleteLookupByType
(
nsHostRecord
*
nsresult
const
nsTArray
<
nsCString
>
*
uint32_t
bool
pb
)
override
;
void
TRRBlacklist
(
const
nsACString
&
host
const
nsACString
&
originSuffix
bool
privateBrowsing
bool
aParentsToo
)
;
bool
IsTRRBlacklisted
(
const
nsACString
&
aHost
const
nsACString
&
aOriginSuffix
bool
aPrivateBrowsing
bool
aParentsToo
)
;
bool
IsExcludedFromTRR
(
const
nsACString
&
aHost
)
;
bool
MaybeBootstrap
(
const
nsACString
&
possible
nsACString
&
result
)
;
enum
TrrOkay
{
OKAY_NORMAL
=
0
OKAY_TIMEOUT
=
1
OKAY_BAD
=
2
}
;
void
TRRIsOkay
(
enum
TrrOkay
aReason
)
;
bool
ParentalControlEnabled
(
)
const
{
return
mParentalControlEnabled
;
}
private
:
virtual
~
TRRService
(
)
;
nsresult
ReadPrefs
(
const
char
*
name
)
;
void
GetPrefBranch
(
nsIPrefBranch
*
*
result
)
;
void
MaybeConfirm
(
)
;
void
MaybeConfirm_locked
(
)
;
friend
class
:
:
nsDNSService
;
void
GetParentalControlEnabledInternal
(
)
;
bool
mInitialized
;
Atomic
<
uint32_t
Relaxed
>
mMode
;
Atomic
<
uint32_t
Relaxed
>
mTRRBlacklistExpireTime
;
Mutex
mLock
;
nsCString
mPrivateURI
;
nsCString
mPrivateCred
;
nsCString
mConfirmationNS
;
nsCString
mBootstrapAddr
;
Atomic
<
bool
Relaxed
>
mWaitForCaptive
;
Atomic
<
bool
Relaxed
>
mRfc1918
;
Atomic
<
bool
Relaxed
>
mCaptiveIsPassed
;
Atomic
<
bool
Relaxed
>
mUseGET
;
Atomic
<
bool
Relaxed
>
mEarlyAAAA
;
Atomic
<
bool
Relaxed
>
mCheckIPv6Connectivity
;
Atomic
<
bool
Relaxed
>
mWaitForAllResponses
;
Atomic
<
bool
Relaxed
>
mDisableIPv6
;
Atomic
<
bool
Relaxed
>
mDisableECS
;
Atomic
<
bool
Relaxed
>
mSkipTRRWhenParentalControlEnabled
;
Atomic
<
uint32_t
Relaxed
>
mDisableAfterFails
;
RefPtr
<
DataStorage
>
mTRRBLStorage
;
Atomic
<
bool
Relaxed
>
mClearTRRBLStorage
;
nsTHashtable
<
nsCStringHashKey
>
mExcludedDomains
;
nsTHashtable
<
nsCStringHashKey
>
mDNSSuffixDomains
;
enum
ConfirmationState
{
CONFIRM_INIT
=
0
CONFIRM_TRYING
=
1
CONFIRM_OK
=
2
CONFIRM_FAILED
=
3
}
;
Atomic
<
ConfirmationState
Relaxed
>
mConfirmationState
;
RefPtr
<
TRR
>
mConfirmer
;
nsCOMPtr
<
nsITimer
>
mRetryConfirmTimer
;
uint32_t
mRetryConfirmInterval
;
Atomic
<
uint32_t
Relaxed
>
mTRRFailures
;
bool
mParentalControlEnabled
;
}
;
extern
TRRService
*
gTRRService
;
}
}
#
endif
