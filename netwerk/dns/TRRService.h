#
ifndef
TRRService_h_
#
define
TRRService_h_
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
nsHostResolver
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
ODoHService
.
h
"
#
include
"
TRRServiceBase
.
h
"
#
include
"
nsICaptivePortalService
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
"
TRR
.
h
"
class
nsDNSService
;
class
nsIPrefBranch
;
class
nsINetworkLinkService
;
class
nsIObserverService
;
namespace
mozilla
{
namespace
net
{
class
TRRServiceChild
;
class
TRRServiceParent
;
class
TRRService
:
public
TRRServiceBase
public
nsIObserver
public
nsSupportsWeakReference
public
AHostResolver
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIOBSERVER
NS_DECL_NSIPROXYCONFIGCHANGEDCALLBACK
TRRService
(
)
;
static
TRRService
*
Get
(
)
;
nsresult
Init
(
)
;
nsresult
Start
(
)
;
bool
Enabled
(
nsIRequest
:
:
TRRMode
aRequestMode
=
nsIRequest
:
:
TRR_DEFAULT_MODE
)
;
bool
IsConfirmed
(
)
{
return
mConfirmation
.
State
(
)
=
=
CONFIRM_OK
;
}
uint32_t
ConfirmationState
(
)
{
return
mConfirmation
.
State
(
)
;
}
bool
DisableIPv6
(
)
{
return
mDisableIPv6
;
}
void
GetURI
(
nsACString
&
result
)
override
;
nsresult
GetCredentials
(
nsCString
&
result
)
;
uint32_t
GetRequestTimeout
(
)
;
void
StrictModeConfirm
(
)
;
LookupStatus
CompleteLookup
(
nsHostRecord
*
nsresult
mozilla
:
:
net
:
:
AddrInfo
*
bool
pb
const
nsACString
&
aOriginSuffix
TRRSkippedReason
aReason
TRR
*
aTrrRequest
)
override
;
LookupStatus
CompleteLookupByType
(
nsHostRecord
*
nsresult
mozilla
:
:
net
:
:
TypeRecordResultType
&
uint32_t
bool
pb
)
override
;
void
AddToBlocklist
(
const
nsACString
&
host
const
nsACString
&
originSuffix
bool
privateBrowsing
bool
aParentsToo
)
;
bool
IsTemporarilyBlocked
(
const
nsACString
&
aHost
const
nsACString
&
aOriginSuffix
bool
aPrivateBrowsing
bool
aParentsToo
)
;
bool
IsExcludedFromTRR
(
const
nsACString
&
aHost
)
;
bool
MaybeBootstrap
(
const
nsACString
&
possible
nsACString
&
result
)
;
void
RecordTRRStatus
(
nsresult
aChannelStatus
)
;
bool
ParentalControlEnabled
(
)
const
{
return
mParentalControlEnabled
;
}
nsresult
DispatchTRRRequest
(
TRR
*
aTrrRequest
)
;
already_AddRefed
<
nsIThread
>
TRRThread
(
)
;
bool
IsOnTRRThread
(
)
;
bool
IsUsingAutoDetectedURL
(
)
{
return
mURISetByDetection
;
}
static
const
nsCString
&
ProviderKey
(
)
;
void
InitTRRConnectionInfo
(
)
override
;
private
:
virtual
~
TRRService
(
)
;
friend
class
TRRServiceChild
;
friend
class
TRRServiceParent
;
friend
class
ODoHService
;
static
void
AddObserver
(
nsIObserver
*
aObserver
nsIObserverService
*
aObserverService
=
nullptr
)
;
static
bool
CheckCaptivePortalIsPassed
(
)
;
static
bool
GetParentalControlEnabledInternal
(
)
;
static
bool
CheckPlatformDNSStatus
(
nsINetworkLinkService
*
aLinkService
)
;
nsresult
ReadPrefs
(
const
char
*
name
)
;
void
GetPrefBranch
(
nsIPrefBranch
*
*
result
)
;
friend
class
:
:
nsDNSService
;
void
SetDetectedTrrURI
(
const
nsACString
&
aURI
)
;
bool
IsDomainBlocked
(
const
nsACString
&
aHost
const
nsACString
&
aOriginSuffix
bool
aPrivateBrowsing
)
;
bool
IsExcludedFromTRR_unlocked
(
const
nsACString
&
aHost
)
;
void
RebuildSuffixList
(
nsTArray
<
nsCString
>
&
&
aSuffixList
)
;
nsresult
DispatchTRRRequestInternal
(
TRR
*
aTrrRequest
bool
aWithLock
)
;
already_AddRefed
<
nsIThread
>
TRRThread_locked
(
)
;
already_AddRefed
<
nsIThread
>
MainThreadOrTRRThread
(
bool
aWithLock
=
true
)
;
bool
MaybeSetPrivateURI
(
const
nsACString
&
aURI
)
override
;
void
ClearEntireCache
(
)
;
virtual
void
ReadEtcHostsFile
(
)
override
;
void
AddEtcHosts
(
const
nsTArray
<
nsCString
>
&
)
;
bool
mInitialized
{
false
}
;
Atomic
<
uint32_t
Relaxed
>
mBlocklistDurationSeconds
{
60
}
;
Mutex
mLock
{
"
TRRService
"
}
;
nsCString
mPrivateCred
;
nsCString
mConfirmationNS
{
"
example
.
com
"
_ns
}
;
nsCString
mBootstrapAddr
;
Atomic
<
bool
Relaxed
>
mCaptiveIsPassed
{
false
}
;
Atomic
<
bool
Relaxed
>
mDisableIPv6
;
DataMutex
<
nsTHashMap
<
nsCStringHashKey
int32_t
>
>
mTRRBLStorage
{
"
DataMutex
:
:
TRRBlocklist
"
}
;
nsTHashSet
<
nsCString
>
mExcludedDomains
;
nsTHashSet
<
nsCString
>
mDNSSuffixDomains
;
nsTHashSet
<
nsCString
>
mEtcHostsDomains
;
enum
class
ConfirmationEvent
{
Init
PrefChange
Retry
FailedLookups
StrictMode
URIChange
CaptivePortalConnectivity
NetworkUp
ConfirmOK
ConfirmFail
}
;
enum
ConfirmationState
{
CONFIRM_OFF
=
0
CONFIRM_TRYING_OK
=
1
CONFIRM_OK
=
2
CONFIRM_FAILED
=
3
CONFIRM_TRYING_FAILED
=
4
CONFIRM_DISABLED
=
5
}
;
class
ConfirmationContext
final
:
public
nsITimerCallback
public
nsINamed
{
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
private
:
static
const
size_t
RESULTS_SIZE
=
32
;
RefPtr
<
TRR
>
mTask
;
nsCOMPtr
<
nsITimer
>
mTimer
;
uint32_t
mRetryInterval
=
125
;
Atomic
<
uint32_t
Relaxed
>
mTRRFailures
{
0
}
;
char
mFailureReasons
[
RESULTS_SIZE
]
=
{
0
}
;
uint32_t
mAttemptCount
=
0
;
char
mResults
[
RESULTS_SIZE
]
=
{
0
}
;
TimeStamp
mFirstRequestTime
;
nsCString
mNetworkId
;
int32_t
mCaptivePortalStatus
=
nsICaptivePortalService
:
:
UNKNOWN
;
nsCString
mContextChangeReason
;
nsCString
mTrigger
;
nsCString
mFailedLookups
;
public
:
void
RecordEvent
(
const
char
*
aReason
)
;
void
RequestCompleted
(
nsresult
aLookupStatus
nsresult
aChannelStatus
)
;
enum
ConfirmationState
State
(
)
{
return
mState
;
}
void
CompleteConfirmation
(
nsresult
aStatus
TRR
*
aTrrRequest
)
;
void
RecordTRRStatus
(
nsresult
aChannelStatus
)
;
void
HandleEvent
(
ConfirmationEvent
aEvent
)
;
void
HandleEvent
(
ConfirmationEvent
aEvent
const
MutexAutoLock
&
)
;
void
SetCaptivePortalStatus
(
int32_t
aStatus
)
{
mCaptivePortalStatus
=
aStatus
;
}
uintptr_t
TaskAddr
(
)
{
return
uintptr_t
(
mTask
.
get
(
)
)
;
}
private
:
TRRService
*
OwningObject
(
)
{
return
reinterpret_cast
<
TRRService
*
>
(
reinterpret_cast
<
uint8_t
*
>
(
this
)
-
offsetof
(
TRRService
mConfirmation
)
-
offsetof
(
ConfirmationWrapper
mConfirmation
)
)
;
}
Atomic
<
enum
ConfirmationState
Relaxed
>
mState
{
CONFIRM_OFF
}
;
friend
class
TRRService
;
~
ConfirmationContext
(
)
=
default
;
}
;
class
ConfirmationWrapper
{
public
:
void
RecordEvent
(
const
char
*
aReason
)
{
mConfirmation
.
RecordEvent
(
aReason
)
;
}
void
RequestCompleted
(
nsresult
aLookupStatus
nsresult
aChannelStatus
)
{
mConfirmation
.
RequestCompleted
(
aLookupStatus
aChannelStatus
)
;
}
enum
ConfirmationState
State
(
)
{
return
mConfirmation
.
State
(
)
;
}
void
CompleteConfirmation
(
nsresult
aStatus
TRR
*
aTrrRequest
)
{
mConfirmation
.
CompleteConfirmation
(
aStatus
aTrrRequest
)
;
}
void
RecordTRRStatus
(
nsresult
aChannelStatus
)
{
mConfirmation
.
RecordTRRStatus
(
aChannelStatus
)
;
}
void
HandleEvent
(
ConfirmationEvent
aEvent
)
{
mConfirmation
.
HandleEvent
(
aEvent
)
;
}
void
HandleEvent
(
ConfirmationEvent
aEvent
const
MutexAutoLock
&
lock
)
{
mConfirmation
.
HandleEvent
(
aEvent
lock
)
;
}
void
SetCaptivePortalStatus
(
int32_t
aStatus
)
{
mConfirmation
.
SetCaptivePortalStatus
(
aStatus
)
;
}
uintptr_t
TaskAddr
(
)
{
return
mConfirmation
.
TaskAddr
(
)
;
}
private
:
friend
TRRService
*
ConfirmationContext
:
:
OwningObject
(
)
;
ConfirmationContext
mConfirmation
;
}
;
ConfirmationWrapper
mConfirmation
;
bool
mParentalControlEnabled
{
false
}
;
RefPtr
<
ODoHService
>
mODoHService
;
nsCOMPtr
<
nsINetworkLinkService
>
mLinkService
;
}
;
}
}
#
endif
