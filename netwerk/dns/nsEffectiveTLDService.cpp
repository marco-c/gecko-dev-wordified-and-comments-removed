#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsEffectiveTLDService
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
namespace
etld_dafsa
{
#
include
"
etld_data
.
inc
"
}
using
namespace
mozilla
;
NS_IMPL_ISUPPORTS
(
nsEffectiveTLDService
nsIEffectiveTLDService
nsIMemoryReporter
)
static
nsEffectiveTLDService
*
gService
=
nullptr
;
nsEffectiveTLDService
:
:
nsEffectiveTLDService
(
)
:
mIDNService
(
)
mGraph
(
etld_dafsa
:
:
kDafsa
)
{
}
nsresult
nsEffectiveTLDService
:
:
Init
(
)
{
nsresult
rv
;
mIDNService
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
MOZ_ASSERT
(
!
gService
)
;
gService
=
this
;
RegisterWeakMemoryReporter
(
this
)
;
return
NS_OK
;
}
nsEffectiveTLDService
:
:
~
nsEffectiveTLDService
(
)
{
UnregisterWeakMemoryReporter
(
this
)
;
gService
=
nullptr
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
EffectiveTLDServiceMallocSizeOf
)
NS_IMETHODIMP
nsEffectiveTLDService
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
network
/
effective
-
TLD
-
service
"
KIND_HEAP
UNITS_BYTES
SizeOfIncludingThis
(
EffectiveTLDServiceMallocSizeOf
)
"
Memory
used
by
the
effective
TLD
service
.
"
)
;
return
NS_OK
;
}
size_t
nsEffectiveTLDService
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
return
n
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetPublicSuffix
(
nsIURI
*
aURI
nsACString
&
aPublicSuffix
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIURI
>
innerURI
=
NS_GetInnermostURI
(
aURI
)
;
NS_ENSURE_ARG_POINTER
(
innerURI
)
;
nsAutoCString
host
;
nsresult
rv
=
innerURI
-
>
GetAsciiHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
GetBaseDomainInternal
(
host
0
aPublicSuffix
)
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetBaseDomain
(
nsIURI
*
aURI
uint32_t
aAdditionalParts
nsACString
&
aBaseDomain
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
NS_ENSURE_TRUE
(
(
(
int32_t
)
aAdditionalParts
)
>
=
0
NS_ERROR_INVALID_ARG
)
;
nsCOMPtr
<
nsIURI
>
innerURI
=
NS_GetInnermostURI
(
aURI
)
;
NS_ENSURE_ARG_POINTER
(
innerURI
)
;
nsAutoCString
host
;
nsresult
rv
=
innerURI
-
>
GetAsciiHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
GetBaseDomainInternal
(
host
aAdditionalParts
+
1
aBaseDomain
)
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetPublicSuffixFromHost
(
const
nsACString
&
aHostname
nsACString
&
aPublicSuffix
)
{
nsAutoCString
normHostname
(
aHostname
)
;
nsresult
rv
=
NormalizeHostname
(
normHostname
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
GetBaseDomainInternal
(
normHostname
0
aPublicSuffix
)
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetBaseDomainFromHost
(
const
nsACString
&
aHostname
uint32_t
aAdditionalParts
nsACString
&
aBaseDomain
)
{
NS_ENSURE_TRUE
(
(
(
int32_t
)
aAdditionalParts
)
>
=
0
NS_ERROR_INVALID_ARG
)
;
nsAutoCString
normHostname
(
aHostname
)
;
nsresult
rv
=
NormalizeHostname
(
normHostname
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
GetBaseDomainInternal
(
normHostname
aAdditionalParts
+
1
aBaseDomain
)
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetNextSubDomain
(
const
nsACString
&
aHostname
nsACString
&
aBaseDomain
)
{
nsAutoCString
normHostname
(
aHostname
)
;
nsresult
rv
=
NormalizeHostname
(
normHostname
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
GetBaseDomainInternal
(
normHostname
-
1
aBaseDomain
)
;
}
nsresult
nsEffectiveTLDService
:
:
GetBaseDomainInternal
(
nsCString
&
aHostname
int32_t
aAdditionalParts
nsACString
&
aBaseDomain
)
{
const
int
kExceptionRule
=
1
;
const
int
kWildcardRule
=
2
;
if
(
aHostname
.
IsEmpty
(
)
)
return
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
;
bool
trailingDot
=
aHostname
.
Last
(
)
=
=
'
.
'
;
if
(
trailingDot
)
aHostname
.
Truncate
(
aHostname
.
Length
(
)
-
1
)
;
if
(
aHostname
.
IsEmpty
(
)
|
|
aHostname
.
Last
(
)
=
=
'
.
'
)
return
NS_ERROR_INVALID_ARG
;
PRNetAddr
addr
;
PRStatus
result
=
PR_StringToNetAddr
(
aHostname
.
get
(
)
&
addr
)
;
if
(
result
=
=
PR_SUCCESS
)
return
NS_ERROR_HOST_IS_IP_ADDRESS
;
TLDCacheEntry
*
entry
=
nullptr
;
if
(
aAdditionalParts
=
=
1
)
{
if
(
LookupForAdd
(
aHostname
&
entry
)
)
{
aBaseDomain
=
entry
-
>
mBaseDomain
;
if
(
trailingDot
)
{
aBaseDomain
.
Append
(
'
.
'
)
;
}
return
NS_OK
;
}
}
const
char
*
prevDomain
=
nullptr
;
const
char
*
currDomain
=
aHostname
.
get
(
)
;
const
char
*
nextDot
=
strchr
(
currDomain
'
.
'
)
;
const
char
*
end
=
currDomain
+
aHostname
.
Length
(
)
;
const
char
*
eTLD
=
nullptr
;
while
(
true
)
{
if
(
*
currDomain
=
=
'
.
'
)
return
NS_ERROR_INVALID_ARG
;
const
int
result
=
mGraph
.
Lookup
(
Substring
(
currDomain
end
)
)
;
if
(
result
!
=
Dafsa
:
:
kKeyNotFound
)
{
if
(
result
=
=
kWildcardRule
&
&
prevDomain
)
{
eTLD
=
prevDomain
;
break
;
}
if
(
(
result
=
=
kWildcardRule
|
|
result
!
=
kExceptionRule
)
|
|
!
nextDot
)
{
eTLD
=
currDomain
;
break
;
}
if
(
result
=
=
kExceptionRule
)
{
eTLD
=
nextDot
+
1
;
break
;
}
}
if
(
!
nextDot
)
{
eTLD
=
currDomain
;
break
;
}
prevDomain
=
currDomain
;
currDomain
=
nextDot
+
1
;
nextDot
=
strchr
(
currDomain
'
.
'
)
;
}
const
char
*
begin
*
iter
;
if
(
aAdditionalParts
<
0
)
{
NS_ASSERTION
(
aAdditionalParts
=
=
-
1
"
aAdditionalParts
can
'
t
be
negative
and
different
from
-
1
"
)
;
for
(
iter
=
aHostname
.
get
(
)
;
iter
!
=
eTLD
&
&
*
iter
!
=
'
.
'
;
iter
+
+
)
;
if
(
iter
!
=
eTLD
)
{
iter
+
+
;
}
if
(
iter
!
=
eTLD
)
{
aAdditionalParts
=
0
;
}
}
else
{
begin
=
aHostname
.
get
(
)
;
iter
=
eTLD
;
while
(
true
)
{
if
(
iter
=
=
begin
)
break
;
if
(
*
(
-
-
iter
)
=
=
'
.
'
&
&
aAdditionalParts
-
-
=
=
0
)
{
+
+
iter
;
+
+
aAdditionalParts
;
break
;
}
}
}
if
(
aAdditionalParts
!
=
0
)
return
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
;
aBaseDomain
=
Substring
(
iter
end
)
;
if
(
entry
)
{
entry
-
>
mHost
=
aHostname
;
entry
-
>
mBaseDomain
=
aBaseDomain
;
}
if
(
trailingDot
)
aBaseDomain
.
Append
(
'
.
'
)
;
return
NS_OK
;
}
nsresult
nsEffectiveTLDService
:
:
NormalizeHostname
(
nsCString
&
aHostname
)
{
if
(
!
IsASCII
(
aHostname
)
)
{
nsresult
rv
=
mIDNService
-
>
ConvertUTF8toACE
(
aHostname
aHostname
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
ToLowerCase
(
aHostname
)
;
return
NS_OK
;
}
bool
nsEffectiveTLDService
:
:
LookupForAdd
(
const
nsACString
&
aHost
TLDCacheEntry
*
*
aEntry
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
const
uint32_t
hash
=
HashString
(
aHost
.
BeginReading
(
)
aHost
.
Length
(
)
)
;
*
aEntry
=
&
mMruTable
[
hash
%
kTableSize
]
;
return
(
*
aEntry
)
-
>
mHost
=
=
aHost
;
}
