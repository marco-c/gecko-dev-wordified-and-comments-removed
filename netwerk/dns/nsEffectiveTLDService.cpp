#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsEffectiveTLDService
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
prnetdb
.
h
"
namespace
etld_dafsa
{
#
include
"
etld_data
.
inc
"
}
using
namespace
mozilla
;
NS_IMPL_ISUPPORTS
(
nsEffectiveTLDService
nsIEffectiveTLDService
nsIMemoryReporter
nsIObserver
)
static
nsEffectiveTLDService
*
gService
=
nullptr
;
nsEffectiveTLDService
:
:
nsEffectiveTLDService
(
)
:
mIDNService
(
)
mGraphLock
(
"
nsEffectiveTLDService
:
:
mGraph
"
)
{
mGraph
.
emplace
(
etld_dafsa
:
:
kDafsa
)
;
}
nsresult
nsEffectiveTLDService
:
:
Init
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
obs
-
>
AddObserver
(
this
"
public
-
suffix
-
list
-
updated
"
false
)
;
if
(
gService
)
{
return
NS_ERROR_ALREADY_INITIALIZED
;
}
nsresult
rv
;
mIDNService
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
gService
=
this
;
RegisterWeakMemoryReporter
(
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
aSubject
&
&
(
nsCRT
:
:
strcmp
(
aTopic
"
public
-
suffix
-
list
-
updated
"
)
=
=
0
)
)
{
nsCOMPtr
<
nsIFile
>
mDafsaBinFile
(
do_QueryInterface
(
aSubject
)
)
;
NS_ENSURE_TRUE
(
mDafsaBinFile
NS_ERROR_ILLEGAL_VALUE
)
;
AutoWriteLock
lock
(
mGraphLock
)
;
mGraph
.
reset
(
)
;
mGraph
.
emplace
(
etld_dafsa
:
:
kDafsa
)
;
mDafsaMap
.
reset
(
)
;
mMruTable
.
Clear
(
)
;
MOZ_TRY
(
mDafsaMap
.
init
(
mDafsaBinFile
)
)
;
size_t
size
=
mDafsaMap
.
size
(
)
;
const
uint8_t
*
remoteDafsaPtr
=
mDafsaMap
.
get
<
uint8_t
>
(
)
.
get
(
)
;
auto
remoteDafsa
=
mozilla
:
:
Span
(
remoteDafsaPtr
size
)
;
mGraph
.
reset
(
)
;
mGraph
.
emplace
(
remoteDafsa
)
;
}
return
NS_OK
;
}
nsEffectiveTLDService
:
:
~
nsEffectiveTLDService
(
)
{
UnregisterWeakMemoryReporter
(
this
)
;
if
(
mIDNService
)
{
gService
=
nullptr
;
}
}
nsEffectiveTLDService
*
nsEffectiveTLDService
:
:
GetInstance
(
)
{
if
(
gService
)
{
return
gService
;
}
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
if
(
!
tldService
)
{
return
nullptr
;
}
MOZ_ASSERT
(
gService
"
gService
must
have
been
initialized
in
nsEffectiveTLDService
:
:
Init
"
)
;
return
gService
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
EffectiveTLDServiceMallocSizeOf
)
NS_IMETHODIMP
nsEffectiveTLDService
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
network
/
effective
-
TLD
-
service
"
KIND_HEAP
UNITS_BYTES
SizeOfIncludingThis
(
EffectiveTLDServiceMallocSizeOf
)
"
Memory
used
by
the
effective
TLD
service
.
"
)
;
return
NS_OK
;
}
size_t
nsEffectiveTLDService
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
return
n
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetPublicSuffix
(
nsIURI
*
aURI
nsACString
&
aPublicSuffix
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsAutoCString
host
;
nsresult
rv
=
NS_GetInnermostURIHost
(
aURI
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
GetBaseDomainInternal
(
host
0
false
aPublicSuffix
)
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetKnownPublicSuffix
(
nsIURI
*
aURI
nsACString
&
aPublicSuffix
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsAutoCString
host
;
nsresult
rv
=
NS_GetInnermostURIHost
(
aURI
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
GetBaseDomainInternal
(
host
0
true
aPublicSuffix
)
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetBaseDomain
(
nsIURI
*
aURI
uint32_t
aAdditionalParts
nsACString
&
aBaseDomain
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
NS_ENSURE_TRUE
(
(
(
int32_t
)
aAdditionalParts
)
>
=
0
NS_ERROR_INVALID_ARG
)
;
nsAutoCString
host
;
nsresult
rv
=
NS_GetInnermostURIHost
(
aURI
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
GetBaseDomainInternal
(
host
aAdditionalParts
+
1
false
aBaseDomain
)
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetPublicSuffixFromHost
(
const
nsACString
&
aHostname
nsACString
&
aPublicSuffix
)
{
nsAutoCString
normHostname
(
aHostname
)
;
nsresult
rv
=
NormalizeHostname
(
normHostname
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
GetBaseDomainInternal
(
normHostname
0
false
aPublicSuffix
)
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetKnownPublicSuffixFromHost
(
const
nsACString
&
aHostname
nsACString
&
aPublicSuffix
)
{
nsAutoCString
normHostname
(
aHostname
)
;
nsresult
rv
=
NormalizeHostname
(
normHostname
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
GetBaseDomainInternal
(
normHostname
0
true
aPublicSuffix
)
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetBaseDomainFromHost
(
const
nsACString
&
aHostname
uint32_t
aAdditionalParts
nsACString
&
aBaseDomain
)
{
NS_ENSURE_TRUE
(
(
(
int32_t
)
aAdditionalParts
)
>
=
0
NS_ERROR_INVALID_ARG
)
;
nsAutoCString
normHostname
(
aHostname
)
;
nsresult
rv
=
NormalizeHostname
(
normHostname
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
GetBaseDomainInternal
(
normHostname
aAdditionalParts
+
1
false
aBaseDomain
)
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
GetNextSubDomain
(
const
nsACString
&
aHostname
nsACString
&
aBaseDomain
)
{
nsAutoCString
normHostname
(
aHostname
)
;
nsresult
rv
=
NormalizeHostname
(
normHostname
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
GetBaseDomainInternal
(
normHostname
-
1
false
aBaseDomain
)
;
}
nsresult
nsEffectiveTLDService
:
:
GetBaseDomainInternal
(
nsCString
&
aHostname
int32_t
aAdditionalParts
bool
aOnlyKnownPublicSuffix
nsACString
&
aBaseDomain
)
{
const
int
kExceptionRule
=
1
;
const
int
kWildcardRule
=
2
;
if
(
aHostname
.
IsEmpty
(
)
)
return
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
;
bool
trailingDot
=
aHostname
.
Last
(
)
=
=
'
.
'
;
if
(
trailingDot
)
aHostname
.
Truncate
(
aHostname
.
Length
(
)
-
1
)
;
if
(
aHostname
.
IsEmpty
(
)
|
|
aHostname
.
Last
(
)
=
=
'
.
'
)
return
NS_ERROR_INVALID_ARG
;
Maybe
<
TldCache
:
:
Entry
>
entry
;
if
(
aAdditionalParts
=
=
1
&
&
NS_IsMainThread
(
)
)
{
auto
p
=
mMruTable
.
Lookup
(
aHostname
)
;
if
(
p
)
{
if
(
NS_FAILED
(
p
.
Data
(
)
.
mResult
)
)
{
return
p
.
Data
(
)
.
mResult
;
}
aBaseDomain
=
p
.
Data
(
)
.
mBaseDomain
;
if
(
trailingDot
)
{
aBaseDomain
.
Append
(
'
.
'
)
;
}
return
NS_OK
;
}
entry
=
Some
(
p
)
;
}
PRNetAddr
addr
;
PRStatus
result
=
PR_StringToNetAddr
(
aHostname
.
get
(
)
&
addr
)
;
if
(
result
=
=
PR_SUCCESS
)
{
if
(
entry
)
{
entry
-
>
Set
(
TLDCacheEntry
{
aHostname
EmptyCString
(
)
NS_ERROR_HOST_IS_IP_ADDRESS
}
)
;
}
return
NS_ERROR_HOST_IS_IP_ADDRESS
;
}
const
char
*
prevDomain
=
nullptr
;
const
char
*
currDomain
=
aHostname
.
get
(
)
;
const
char
*
nextDot
=
strchr
(
currDomain
'
.
'
)
;
const
char
*
end
=
currDomain
+
aHostname
.
Length
(
)
;
const
char
*
eTLD
=
nullptr
;
bool
hasKnownPublicSuffix
=
false
;
while
(
true
)
{
if
(
*
currDomain
=
=
'
.
'
)
{
if
(
entry
)
{
entry
-
>
Set
(
TLDCacheEntry
{
aHostname
EmptyCString
(
)
NS_ERROR_INVALID_ARG
}
)
;
}
return
NS_ERROR_INVALID_ARG
;
}
int
result
;
{
AutoReadLock
lock
(
mGraphLock
)
;
result
=
mGraph
-
>
Lookup
(
Substring
(
currDomain
end
)
)
;
}
if
(
result
!
=
Dafsa
:
:
kKeyNotFound
)
{
hasKnownPublicSuffix
=
true
;
if
(
result
=
=
kWildcardRule
&
&
prevDomain
)
{
eTLD
=
prevDomain
;
break
;
}
if
(
(
result
=
=
kWildcardRule
|
|
result
!
=
kExceptionRule
)
|
|
!
nextDot
)
{
eTLD
=
currDomain
;
break
;
}
if
(
result
=
=
kExceptionRule
)
{
eTLD
=
nextDot
+
1
;
break
;
}
}
if
(
!
nextDot
)
{
eTLD
=
currDomain
;
break
;
}
prevDomain
=
currDomain
;
currDomain
=
nextDot
+
1
;
nextDot
=
strchr
(
currDomain
'
.
'
)
;
}
if
(
aOnlyKnownPublicSuffix
&
&
!
hasKnownPublicSuffix
)
{
aBaseDomain
.
Truncate
(
)
;
return
NS_OK
;
}
const
char
*
begin
*
iter
;
if
(
aAdditionalParts
<
0
)
{
NS_ASSERTION
(
aAdditionalParts
=
=
-
1
"
aAdditionalParts
can
'
t
be
negative
and
different
from
-
1
"
)
;
for
(
iter
=
aHostname
.
get
(
)
;
iter
!
=
eTLD
&
&
*
iter
!
=
'
.
'
;
iter
+
+
)
;
if
(
iter
!
=
eTLD
)
{
iter
+
+
;
}
if
(
iter
!
=
eTLD
)
{
aAdditionalParts
=
0
;
}
}
else
{
begin
=
aHostname
.
get
(
)
;
iter
=
eTLD
;
while
(
true
)
{
if
(
iter
=
=
begin
)
break
;
if
(
*
(
-
-
iter
)
=
=
'
.
'
&
&
aAdditionalParts
-
-
=
=
0
)
{
+
+
iter
;
+
+
aAdditionalParts
;
break
;
}
}
}
if
(
aAdditionalParts
!
=
0
)
{
if
(
entry
)
{
entry
-
>
Set
(
TLDCacheEntry
{
aHostname
EmptyCString
(
)
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
}
)
;
}
return
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
;
}
aBaseDomain
=
Substring
(
iter
end
)
;
if
(
entry
)
{
entry
-
>
Set
(
TLDCacheEntry
{
aHostname
nsCString
(
aBaseDomain
)
NS_OK
}
)
;
}
if
(
trailingDot
)
aBaseDomain
.
Append
(
'
.
'
)
;
return
NS_OK
;
}
nsresult
nsEffectiveTLDService
:
:
NormalizeHostname
(
nsCString
&
aHostname
)
{
if
(
!
IsAscii
(
aHostname
)
)
{
nsresult
rv
=
mIDNService
-
>
ConvertUTF8toACE
(
aHostname
aHostname
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
ToLowerCase
(
aHostname
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsEffectiveTLDService
:
:
HasRootDomain
(
const
nsACString
&
aInput
const
nsACString
&
aHost
bool
*
aResult
)
{
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aResult
=
false
;
if
(
aInput
=
=
aHost
)
{
*
aResult
=
true
;
return
NS_OK
;
}
int32_t
index
=
nsAutoCString
(
aInput
)
.
Find
(
aHost
.
BeginReading
(
)
)
;
if
(
index
=
=
kNotFound
)
{
return
NS_OK
;
}
*
aResult
=
index
>
0
&
&
(
uint32_t
)
index
=
=
aInput
.
Length
(
)
-
aHost
.
Length
(
)
&
&
(
aInput
[
index
-
1
]
=
=
'
.
'
|
|
aInput
[
index
-
1
]
=
=
'
/
'
)
;
return
NS_OK
;
}
