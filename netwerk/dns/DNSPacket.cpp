#
include
"
DNSPacket
.
h
"
#
include
"
DNS
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
ODoHService
.
h
"
#
include
"
DNSLogging
.
h
"
#
include
"
nsIInputStream
.
h
"
namespace
mozilla
{
namespace
net
{
static
uint16_t
get16bit
(
const
unsigned
char
*
aData
unsigned
int
index
)
{
return
(
(
aData
[
index
]
<
<
8
)
|
aData
[
index
+
1
]
)
;
}
static
bool
get16bit
(
const
Span
<
const
uint8_t
>
&
aData
Span
<
const
uint8_t
>
:
:
const_iterator
&
it
uint16_t
&
result
)
{
if
(
it
>
=
aData
.
cend
(
)
|
|
std
:
:
distance
(
it
aData
.
cend
(
)
)
<
2
)
{
return
false
;
}
result
=
(
*
it
<
<
8
)
|
*
(
it
+
1
)
;
it
+
=
2
;
return
true
;
}
static
uint32_t
get32bit
(
const
unsigned
char
*
aData
unsigned
int
index
)
{
return
(
aData
[
index
]
<
<
24
)
|
(
aData
[
index
+
1
]
<
<
16
)
|
(
aData
[
index
+
2
]
<
<
8
)
|
aData
[
index
+
3
]
;
}
bool
hardFail
(
uint16_t
code
)
{
const
uint16_t
noFallbackErrors
[
]
=
{
4
6
7
8
9
10
11
12
17
}
;
for
(
const
auto
&
err
:
noFallbackErrors
)
{
if
(
code
=
=
err
)
{
return
true
;
}
}
return
false
;
}
nsresult
DNSPacket
:
:
ParseSvcParam
(
unsigned
int
svcbIndex
uint16_t
key
SvcFieldValue
&
field
uint16_t
length
const
unsigned
char
*
aBuffer
)
{
switch
(
key
)
{
case
SvcParamKeyMandatory
:
{
if
(
length
%
2
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
while
(
length
>
0
)
{
uint16_t
mandatoryKey
=
get16bit
(
aBuffer
svcbIndex
)
;
length
-
=
2
;
svcbIndex
+
=
2
;
if
(
!
IsValidSvcParamKey
(
mandatoryKey
)
)
{
LOG
(
(
"
The
mandatory
field
includes
a
key
we
don
'
t
support
%
u
"
mandatoryKey
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
break
;
}
case
SvcParamKeyAlpn
:
{
field
.
mValue
=
AsVariant
(
SvcParamAlpn
(
)
)
;
auto
&
alpnArray
=
field
.
mValue
.
as
<
SvcParamAlpn
>
(
)
.
mValue
;
while
(
length
>
0
)
{
uint8_t
alpnIdLength
=
aBuffer
[
svcbIndex
+
+
]
;
length
-
=
1
;
if
(
alpnIdLength
>
length
)
{
return
NS_ERROR_UNEXPECTED
;
}
alpnArray
.
AppendElement
(
nsCString
(
(
const
char
*
)
&
aBuffer
[
svcbIndex
]
alpnIdLength
)
)
;
length
-
=
alpnIdLength
;
svcbIndex
+
=
alpnIdLength
;
}
break
;
}
case
SvcParamKeyNoDefaultAlpn
:
{
if
(
length
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamNoDefaultAlpn
{
}
)
;
break
;
}
case
SvcParamKeyPort
:
{
if
(
length
!
=
2
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamPort
{
.
mValue
=
get16bit
(
aBuffer
svcbIndex
)
}
)
;
break
;
}
case
SvcParamKeyIpv4Hint
:
{
if
(
length
%
4
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamIpv4Hint
(
)
)
;
auto
&
ipv4array
=
field
.
mValue
.
as
<
SvcParamIpv4Hint
>
(
)
.
mValue
;
while
(
length
>
0
)
{
NetAddr
addr
;
addr
.
inet
.
family
=
AF_INET
;
addr
.
inet
.
port
=
0
;
addr
.
inet
.
ip
=
ntohl
(
get32bit
(
aBuffer
svcbIndex
)
)
;
ipv4array
.
AppendElement
(
addr
)
;
length
-
=
4
;
svcbIndex
+
=
4
;
}
break
;
}
case
SvcParamKeyEchConfig
:
{
field
.
mValue
=
AsVariant
(
SvcParamEchConfig
{
.
mValue
=
nsCString
(
(
const
char
*
)
(
&
aBuffer
[
svcbIndex
]
)
length
)
}
)
;
break
;
}
case
SvcParamKeyIpv6Hint
:
{
if
(
length
%
16
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamIpv6Hint
(
)
)
;
auto
&
ipv6array
=
field
.
mValue
.
as
<
SvcParamIpv6Hint
>
(
)
.
mValue
;
while
(
length
>
0
)
{
NetAddr
addr
;
addr
.
inet6
.
family
=
AF_INET6
;
addr
.
inet6
.
port
=
0
;
addr
.
inet6
.
flowinfo
=
0
;
addr
.
inet6
.
scope_id
=
0
;
for
(
int
i
=
0
;
i
<
16
;
i
+
+
svcbIndex
+
+
)
{
addr
.
inet6
.
ip
.
u8
[
i
]
=
aBuffer
[
svcbIndex
]
;
}
ipv6array
.
AppendElement
(
addr
)
;
length
-
=
16
;
}
break
;
}
case
SvcParamKeyODoHConfig
:
{
field
.
mValue
=
AsVariant
(
SvcParamODoHConfig
{
.
mValue
=
nsCString
(
(
const
char
*
)
(
&
aBuffer
[
svcbIndex
]
)
length
)
}
)
;
break
;
}
default
:
{
return
NS_OK
;
break
;
}
}
return
NS_OK
;
}
nsresult
DNSPacket
:
:
PassQName
(
unsigned
int
&
index
const
unsigned
char
*
aBuffer
)
{
uint8_t
length
;
do
{
if
(
mBodySize
<
(
index
+
1
)
)
{
LOG
(
(
"
TRR
:
PassQName
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
length
=
static_cast
<
uint8_t
>
(
aBuffer
[
index
]
)
;
if
(
(
length
&
0xc0
)
=
=
0xc0
)
{
if
(
mBodySize
<
(
index
+
2
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
2
;
break
;
}
if
(
length
&
0xc0
)
{
LOG
(
(
"
TRR
:
illegal
label
length
byte
(
%
x
)
at
index
%
d
\
n
"
length
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
mBodySize
<
(
index
+
1
+
length
)
)
{
LOG
(
(
"
TRR
:
PassQName
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
1
+
length
;
}
while
(
length
)
;
return
NS_OK
;
}
nsresult
DNSPacket
:
:
GetQname
(
nsACString
&
aQname
unsigned
int
&
aIndex
const
unsigned
char
*
aBuffer
)
{
uint8_t
clength
=
0
;
unsigned
int
cindex
=
aIndex
;
unsigned
int
loop
=
128
;
unsigned
int
endindex
=
0
;
do
{
if
(
cindex
>
=
mBodySize
)
{
LOG
(
(
"
TRR
:
bad
Qname
packet
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
clength
=
static_cast
<
uint8_t
>
(
aBuffer
[
cindex
]
)
;
if
(
(
clength
&
0xc0
)
=
=
0xc0
)
{
if
(
(
cindex
+
1
)
>
=
mBodySize
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
newpos
=
(
clength
&
0x3f
)
<
<
8
|
aBuffer
[
cindex
+
1
]
;
if
(
!
endindex
)
{
endindex
=
cindex
+
2
;
}
cindex
=
newpos
;
continue
;
}
if
(
clength
&
0xc0
)
{
LOG
(
(
"
TRR
:
bad
Qname
packet
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
cindex
+
+
;
if
(
clength
)
{
if
(
!
aQname
.
IsEmpty
(
)
)
{
aQname
.
Append
(
"
.
"
)
;
}
if
(
(
cindex
+
clength
)
>
mBodySize
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
aQname
.
Append
(
(
const
char
*
)
(
&
aBuffer
[
cindex
]
)
clength
)
;
cindex
+
=
clength
;
}
}
while
(
clength
&
&
-
-
loop
)
;
if
(
!
loop
)
{
LOG
(
(
"
DNSPacket
:
:
DohDecode
pointer
loop
error
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
!
endindex
)
{
endindex
=
cindex
;
}
aIndex
=
endindex
;
return
NS_OK
;
}
nsresult
DOHresp
:
:
Add
(
uint32_t
TTL
unsigned
char
const
*
dns
unsigned
int
index
uint16_t
len
bool
aLocalAllowed
)
{
NetAddr
addr
;
if
(
4
=
=
len
)
{
addr
.
inet
.
family
=
AF_INET
;
addr
.
inet
.
port
=
0
;
addr
.
inet
.
ip
=
ntohl
(
get32bit
(
dns
index
)
)
;
}
else
if
(
16
=
=
len
)
{
addr
.
inet6
.
family
=
AF_INET6
;
addr
.
inet6
.
port
=
0
;
addr
.
inet6
.
flowinfo
=
0
;
addr
.
inet6
.
scope_id
=
0
;
for
(
int
i
=
0
;
i
<
16
;
i
+
+
index
+
+
)
{
addr
.
inet6
.
ip
.
u8
[
i
]
=
dns
[
index
]
;
}
}
else
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
addr
.
IsIPAddrLocal
(
)
&
&
!
aLocalAllowed
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mTtl
<
TTL
)
{
mTtl
=
TTL
;
}
if
(
LOG_ENABLED
(
)
)
{
char
buf
[
128
]
;
addr
.
ToStringBuffer
(
buf
sizeof
(
buf
)
)
;
LOG
(
(
"
DOHresp
:
Add
%
s
\
n
"
buf
)
)
;
}
mAddresses
.
AppendElement
(
addr
)
;
return
NS_OK
;
}
nsresult
DNSPacket
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aInputStream
uint64_t
aOffset
const
uint32_t
aCount
)
{
if
(
aCount
+
mBodySize
>
MAX_SIZE
)
{
LOG
(
(
"
DNSPacket
:
:
OnDataAvailable
:
%
d
fail
\
n
"
__LINE__
)
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
count
;
nsresult
rv
=
aInputStream
-
>
Read
(
(
char
*
)
mResponse
+
mBodySize
aCount
&
count
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
count
=
=
aCount
)
;
mBodySize
+
=
aCount
;
return
NS_OK
;
}
const
uint8_t
kDNS_CLASS_IN
=
1
;
nsresult
DNSPacket
:
:
EncodeRequest
(
nsCString
&
aBody
const
nsACString
&
aHost
uint16_t
aType
bool
aDisableECS
)
{
aBody
.
Truncate
(
)
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
0x01
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
1
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
char
additionalRecords
=
(
aDisableECS
|
|
StaticPrefs
:
:
network_trr_padding
(
)
)
?
1
:
0
;
aBody
+
=
'
\
0
'
;
aBody
+
=
additionalRecords
;
int32_t
index
=
0
;
int32_t
offset
=
0
;
do
{
bool
dotFound
=
false
;
int32_t
labelLength
;
index
=
aHost
.
FindChar
(
'
.
'
offset
)
;
if
(
kNotFound
!
=
index
)
{
dotFound
=
true
;
labelLength
=
index
-
offset
;
}
else
{
labelLength
=
aHost
.
Length
(
)
-
offset
;
}
if
(
labelLength
>
63
)
{
SetDNSPacketStatus
(
DNSPacketStatus
:
:
EncodeError
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
labelLength
>
0
)
{
aBody
+
=
static_cast
<
unsigned
char
>
(
labelLength
)
;
nsDependentCSubstring
label
=
Substring
(
aHost
offset
labelLength
)
;
aBody
.
Append
(
label
)
;
}
if
(
!
dotFound
)
{
aBody
+
=
'
\
0
'
;
break
;
}
offset
+
=
labelLength
+
1
;
}
while
(
true
)
;
aBody
+
=
static_cast
<
uint8_t
>
(
aType
>
>
8
)
;
aBody
+
=
static_cast
<
uint8_t
>
(
aType
)
;
aBody
+
=
'
\
0
'
;
aBody
+
=
kDNS_CLASS_IN
;
if
(
additionalRecords
)
{
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
41
;
aBody
+
=
16
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
unsigned
int
paddingLen
=
0
;
unsigned
int
rdlen
=
0
;
bool
padding
=
StaticPrefs
:
:
network_trr_padding
(
)
;
if
(
padding
)
{
unsigned
int
packetLen
=
aBody
.
Length
(
)
+
2
+
4
;
if
(
aDisableECS
)
{
packetLen
+
=
8
;
}
uint32_t
padTo
=
std
:
:
clamp
<
uint32_t
>
(
StaticPrefs
:
:
network_trr_padding_length
(
)
0
1024
)
;
if
(
padTo
>
0
)
{
paddingLen
=
(
padTo
-
(
packetLen
%
padTo
)
)
%
padTo
;
}
rdlen
+
=
4
+
paddingLen
;
}
if
(
aDisableECS
)
{
rdlen
+
=
8
;
}
aBody
+
=
(
char
)
(
(
rdlen
>
>
8
)
&
0xff
)
;
aBody
+
=
(
char
)
(
rdlen
&
0xff
)
;
if
(
aDisableECS
)
{
aBody
+
=
'
\
0
'
;
aBody
+
=
8
;
aBody
+
=
'
\
0
'
;
aBody
+
=
4
;
aBody
+
=
'
\
0
'
;
aBody
+
=
1
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
}
if
(
padding
)
{
aBody
+
=
'
\
0
'
;
aBody
+
=
12
;
aBody
+
=
(
char
)
(
(
paddingLen
>
>
8
)
&
0xff
)
;
aBody
+
=
(
char
)
(
paddingLen
&
0xff
)
;
for
(
unsigned
int
i
=
0
;
i
<
paddingLen
;
i
+
+
)
{
aBody
+
=
'
\
0
'
;
}
}
}
SetDNSPacketStatus
(
DNSPacketStatus
:
:
Success
)
;
return
NS_OK
;
}
Result
<
uint8_t
nsresult
>
DNSPacket
:
:
GetRCode
(
)
const
{
if
(
mBodySize
<
12
)
{
LOG
(
(
"
DNSPacket
:
:
GetRCode
-
packet
too
small
"
)
)
;
return
Err
(
NS_ERROR_ILLEGAL_VALUE
)
;
}
return
mResponse
[
3
]
&
0x0F
;
}
Result
<
bool
nsresult
>
DNSPacket
:
:
RecursionAvailable
(
)
const
{
if
(
mBodySize
<
12
)
{
LOG
(
(
"
DNSPacket
:
:
GetRCode
-
packet
too
small
"
)
)
;
return
Err
(
NS_ERROR_ILLEGAL_VALUE
)
;
}
return
mResponse
[
3
]
&
0x80
;
}
nsresult
DNSPacket
:
:
DecodeInternal
(
nsCString
&
aHost
enum
TrrType
aType
nsCString
&
aCname
bool
aAllowRFC1918
DOHresp
&
aResp
TypeRecordResultType
&
aTypeResult
nsClassHashtable
<
nsCStringHashKey
DOHresp
>
&
aAdditionalRecords
uint32_t
&
aTTL
const
unsigned
char
*
aBuffer
uint32_t
aLen
)
{
unsigned
int
index
=
12
;
uint8_t
length
;
nsAutoCString
host
;
nsresult
rv
;
uint16_t
extendedError
=
UINT16_MAX
;
LOG
(
(
"
doh
decode
%
s
%
d
bytes
\
n
"
aHost
.
get
(
)
aLen
)
)
;
aCname
.
Truncate
(
)
;
if
(
aLen
<
12
|
|
aBuffer
[
0
]
|
|
aBuffer
[
1
]
)
{
LOG
(
(
"
TRR
bad
incoming
DOH
eject
!
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint8_t
rcode
=
mResponse
[
3
]
&
0x0F
;
LOG
(
(
"
TRR
Decode
%
s
RCODE
%
d
\
n
"
PromiseFlatCString
(
aHost
)
.
get
(
)
rcode
)
)
;
uint16_t
questionRecords
=
get16bit
(
aBuffer
4
)
;
while
(
questionRecords
)
{
do
{
if
(
aLen
<
(
index
+
1
)
)
{
LOG
(
(
"
TRR
Decode
1
index
:
%
u
size
:
%
u
"
index
aLen
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
length
=
static_cast
<
uint8_t
>
(
aBuffer
[
index
]
)
;
if
(
length
)
{
if
(
host
.
Length
(
)
)
{
host
.
Append
(
"
.
"
)
;
}
if
(
aLen
<
(
index
+
1
+
length
)
)
{
LOG
(
(
"
TRR
Decode
2
index
:
%
u
size
:
%
u
len
:
%
u
"
index
aLen
length
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
host
.
Append
(
(
(
char
*
)
aBuffer
)
+
index
+
1
length
)
;
}
index
+
=
1
+
length
;
}
while
(
length
)
;
if
(
aLen
<
(
index
+
4
)
)
{
LOG
(
(
"
TRR
Decode
3
index
:
%
u
size
:
%
u
"
index
aLen
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
4
;
questionRecords
-
-
;
}
uint16_t
answerRecords
=
get16bit
(
aBuffer
6
)
;
LOG
(
(
"
TRR
Decode
:
%
d
answer
records
(
%
u
bytes
body
)
%
s
index
=
%
u
\
n
"
answerRecords
aLen
host
.
get
(
)
index
)
)
;
while
(
answerRecords
)
{
nsAutoCString
qname
;
rv
=
GetQname
(
qname
index
aBuffer
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aLen
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
+
2
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
TYPE
=
get16bit
(
aBuffer
index
)
;
if
(
(
TYPE
!
=
TRRTYPE_CNAME
)
&
&
(
TYPE
!
=
TRRTYPE_HTTPSSVC
)
&
&
(
TYPE
!
=
static_cast
<
uint16_t
>
(
aType
)
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
asked
for
type
%
d
got
%
d
\
n
"
__LINE__
aType
TYPE
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
index
+
=
2
;
if
(
aLen
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
+
2
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
CLASS
=
get16bit
(
aBuffer
index
)
;
if
(
kDNS_CLASS_IN
!
=
CLASS
)
{
LOG
(
(
"
TRR
bad
CLASS
(
%
u
)
at
index
%
d
\
n
"
CLASS
index
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
index
+
=
2
;
if
(
aLen
<
(
index
+
4
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint32_t
TTL
=
get32bit
(
aBuffer
index
)
;
index
+
=
4
;
if
(
aLen
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
RDLENGTH
=
get16bit
(
aBuffer
index
)
;
index
+
=
2
;
if
(
aLen
<
(
index
+
RDLENGTH
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
RDLENGTH
=
%
d
at
index
%
d
\
n
"
__LINE__
RDLENGTH
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
bool
responseMatchesQuestion
=
(
qname
.
Length
(
)
=
=
aHost
.
Length
(
)
|
|
(
aHost
.
Length
(
)
=
=
qname
.
Length
(
)
+
1
&
&
aHost
.
Last
(
)
=
=
'
.
'
)
)
&
&
StringBeginsWith
(
aHost
qname
nsCaseInsensitiveCStringComparator
)
;
if
(
responseMatchesQuestion
)
{
switch
(
TYPE
)
{
case
TRRTYPE_A
:
if
(
RDLENGTH
!
=
4
)
{
LOG
(
(
"
TRR
bad
length
for
A
(
%
u
)
\
n
"
RDLENGTH
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
rv
=
aResp
.
Add
(
TTL
aBuffer
index
RDLENGTH
aAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
DohDecode
failed
:
local
IP
addresses
or
unknown
IP
"
"
family
\
n
"
)
)
;
return
rv
;
}
break
;
case
TRRTYPE_AAAA
:
if
(
RDLENGTH
!
=
16
)
{
LOG
(
(
"
TRR
bad
length
for
AAAA
(
%
u
)
\
n
"
RDLENGTH
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
rv
=
aResp
.
Add
(
TTL
aBuffer
index
RDLENGTH
aAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
got
unique
/
local
IPv6
address
!
\
n
"
)
)
;
return
rv
;
}
break
;
case
TRRTYPE_NS
:
break
;
case
TRRTYPE_CNAME
:
if
(
aCname
.
IsEmpty
(
)
)
{
nsAutoCString
qname
;
unsigned
int
qnameindex
=
index
;
rv
=
GetQname
(
qname
qnameindex
aBuffer
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
qname
.
IsEmpty
(
)
)
{
ToLowerCase
(
qname
)
;
aCname
=
qname
;
LOG
(
(
"
DNSPacket
:
:
DohDecode
CNAME
host
%
s
=
>
%
s
\
n
"
host
.
get
(
)
aCname
.
get
(
)
)
)
;
}
else
{
LOG
(
(
"
DNSPacket
:
:
DohDecode
empty
CNAME
for
host
%
s
!
\
n
"
host
.
get
(
)
)
)
;
}
}
else
{
LOG
(
(
"
DNSPacket
:
:
DohDecode
CNAME
-
ignoring
another
entry
\
n
"
)
)
;
}
break
;
case
TRRTYPE_TXT
:
{
nsAutoCString
txt
;
unsigned
int
txtIndex
=
index
;
uint16_t
available
=
RDLENGTH
;
while
(
available
>
0
)
{
uint8_t
characterStringLen
=
aBuffer
[
txtIndex
+
+
]
;
available
-
-
;
if
(
characterStringLen
>
available
)
{
LOG
(
(
"
DNSPacket
:
:
DohDecode
MALFORMED
TXT
RECORD
\
n
"
)
)
;
break
;
}
txt
.
Append
(
(
const
char
*
)
(
&
aBuffer
[
txtIndex
]
)
characterStringLen
)
;
txtIndex
+
=
characterStringLen
;
available
-
=
characterStringLen
;
}
if
(
!
aTypeResult
.
is
<
TypeRecordTxt
>
(
)
)
{
aTypeResult
=
AsVariant
(
CopyableTArray
<
nsCString
>
(
)
)
;
}
{
auto
&
results
=
aTypeResult
.
as
<
TypeRecordTxt
>
(
)
;
results
.
AppendElement
(
txt
)
;
}
if
(
aTTL
>
TTL
)
{
aTTL
=
TTL
;
}
LOG
(
(
"
DNSPacket
:
:
DohDecode
TXT
host
%
s
=
>
%
s
\
n
"
host
.
get
(
)
txt
.
get
(
)
)
)
;
break
;
}
case
TRRTYPE_HTTPSSVC
:
{
struct
SVCB
parsed
;
int32_t
lastSvcParamKey
=
-
1
;
unsigned
int
svcbIndex
=
index
;
CheckedInt
<
uint16_t
>
available
=
RDLENGTH
;
if
(
available
.
value
(
)
<
3
)
{
return
NS_ERROR_UNEXPECTED
;
}
parsed
.
mSvcFieldPriority
=
get16bit
(
aBuffer
svcbIndex
)
;
svcbIndex
+
=
2
;
rv
=
GetQname
(
parsed
.
mSvcDomainName
svcbIndex
aBuffer
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
parsed
.
mSvcDomainName
.
IsEmpty
(
)
)
{
if
(
parsed
.
mSvcFieldPriority
=
=
0
)
{
continue
;
}
if
(
mOriginHost
)
{
parsed
.
mSvcDomainName
=
*
mOriginHost
;
}
else
{
parsed
.
mSvcDomainName
=
qname
;
}
}
available
-
=
(
svcbIndex
-
index
)
;
if
(
!
available
.
isValid
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
while
(
available
.
value
(
)
>
=
4
)
{
struct
SvcFieldValue
value
;
uint16_t
key
=
get16bit
(
aBuffer
svcbIndex
)
;
svcbIndex
+
=
2
;
if
(
key
<
=
lastSvcParamKey
)
{
LOG
(
(
"
SvcParamKeys
not
in
increasing
order
"
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
lastSvcParamKey
=
key
;
uint16_t
len
=
get16bit
(
aBuffer
svcbIndex
)
;
svcbIndex
+
=
2
;
available
-
=
4
+
len
;
if
(
!
available
.
isValid
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
rv
=
ParseSvcParam
(
svcbIndex
key
value
len
aBuffer
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
svcbIndex
+
=
len
;
if
(
key
=
=
SvcParamKeyMandatory
|
|
!
IsValidSvcParamKey
(
key
)
)
{
continue
;
}
if
(
value
.
mValue
.
is
<
SvcParamIpv4Hint
>
(
)
|
|
value
.
mValue
.
is
<
SvcParamIpv6Hint
>
(
)
)
{
parsed
.
mHasIPHints
=
true
;
}
if
(
value
.
mValue
.
is
<
SvcParamEchConfig
>
(
)
)
{
parsed
.
mHasEchConfig
=
true
;
parsed
.
mEchConfig
=
value
.
mValue
.
as
<
SvcParamEchConfig
>
(
)
.
mValue
;
}
if
(
value
.
mValue
.
is
<
SvcParamODoHConfig
>
(
)
)
{
parsed
.
mODoHConfig
=
value
.
mValue
.
as
<
SvcParamODoHConfig
>
(
)
.
mValue
;
}
parsed
.
mSvcFieldValue
.
AppendElement
(
value
)
;
}
if
(
aType
!
=
TRRTYPE_HTTPSSVC
)
{
break
;
}
if
(
aCname
.
IsEmpty
(
)
&
&
parsed
.
mSvcFieldPriority
=
=
0
)
{
if
(
parsed
.
mSvcDomainName
.
IsEmpty
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
aCname
=
parsed
.
mSvcDomainName
;
aTypeResult
=
mozilla
:
:
AsVariant
(
Nothing
(
)
)
;
ToLowerCase
(
aCname
)
;
LOG
(
(
"
DNSPacket
:
:
DohDecode
HTTPSSVC
AliasForm
host
%
s
=
>
%
s
\
n
"
host
.
get
(
)
aCname
.
get
(
)
)
)
;
break
;
}
if
(
!
aTypeResult
.
is
<
TypeRecordHTTPSSVC
>
(
)
)
{
aTypeResult
=
mozilla
:
:
AsVariant
(
CopyableTArray
<
SVCB
>
(
)
)
;
}
{
auto
&
results
=
aTypeResult
.
as
<
TypeRecordHTTPSSVC
>
(
)
;
results
.
AppendElement
(
parsed
)
;
}
aTTL
=
TTL
;
break
;
}
default
:
LOG
(
(
"
TRR
unsupported
TYPE
(
%
u
)
RDLENGTH
%
u
\
n
"
TYPE
RDLENGTH
)
)
;
break
;
}
}
else
{
LOG
(
(
"
TRR
asked
for
%
s
data
but
got
%
s
\
n
"
aHost
.
get
(
)
qname
.
get
(
)
)
)
;
}
index
+
=
RDLENGTH
;
LOG
(
(
"
done
with
record
type
%
u
len
%
u
index
now
%
u
of
%
u
\
n
"
TYPE
RDLENGTH
index
aLen
)
)
;
answerRecords
-
-
;
}
uint16_t
nsRecords
=
get16bit
(
aBuffer
8
)
;
LOG
(
(
"
TRR
Decode
:
%
d
ns
records
(
%
u
bytes
body
)
\
n
"
nsRecords
aLen
)
)
;
while
(
nsRecords
)
{
rv
=
PassQName
(
index
aBuffer
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aLen
<
(
index
+
8
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
2
;
index
+
=
2
;
index
+
=
4
;
if
(
aLen
<
(
index
+
2
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
RDLENGTH
=
get16bit
(
aBuffer
index
)
;
index
+
=
2
;
if
(
aLen
<
(
index
+
RDLENGTH
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
RDLENGTH
;
LOG
(
(
"
done
with
nsRecord
now
%
u
of
%
u
\
n
"
index
aLen
)
)
;
nsRecords
-
-
;
}
uint16_t
arRecords
=
get16bit
(
aBuffer
10
)
;
LOG
(
(
"
TRR
Decode
:
%
d
additional
resource
records
(
%
u
bytes
body
)
\
n
"
arRecords
aLen
)
)
;
while
(
arRecords
)
{
nsAutoCString
qname
;
rv
=
GetQname
(
qname
index
aBuffer
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Bad
qname
for
additional
record
"
)
)
;
return
rv
;
}
if
(
aLen
<
(
index
+
8
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
type
=
get16bit
(
aBuffer
index
)
;
index
+
=
2
;
uint16_t
cls
=
get16bit
(
aBuffer
index
)
;
index
+
=
2
;
uint32_t
ttl
=
get32bit
(
aBuffer
index
)
;
index
+
=
4
;
if
(
aLen
<
(
index
+
2
)
)
{
LOG
(
(
"
Record
too
small
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
rdlength
=
get16bit
(
aBuffer
index
)
;
index
+
=
2
;
if
(
aLen
<
(
index
+
rdlength
)
)
{
LOG
(
(
"
rdlength
too
big
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
auto
parseRecord
=
[
&
]
(
)
{
LOG
(
(
"
Parsing
additional
record
type
:
%
u
"
type
)
)
;
auto
*
entry
=
aAdditionalRecords
.
GetOrInsertNew
(
qname
)
;
switch
(
type
)
{
case
TRRTYPE_A
:
if
(
kDNS_CLASS_IN
!
=
cls
)
{
LOG
(
(
"
NOT
IN
-
returning
"
)
)
;
return
;
}
if
(
rdlength
!
=
4
)
{
LOG
(
(
"
TRR
bad
length
for
A
(
%
u
)
\
n
"
rdlength
)
)
;
return
;
}
rv
=
entry
-
>
Add
(
ttl
aBuffer
index
rdlength
aAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
DohDecode
failed
:
local
IP
addresses
or
unknown
IP
"
"
family
\
n
"
)
)
;
return
;
}
break
;
case
TRRTYPE_AAAA
:
if
(
kDNS_CLASS_IN
!
=
cls
)
{
LOG
(
(
"
NOT
IN
-
returning
"
)
)
;
return
;
}
if
(
rdlength
!
=
16
)
{
LOG
(
(
"
TRR
bad
length
for
AAAA
(
%
u
)
\
n
"
rdlength
)
)
;
return
;
}
rv
=
entry
-
>
Add
(
ttl
aBuffer
index
rdlength
aAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
got
unique
/
local
IPv6
address
!
\
n
"
)
)
;
return
;
}
break
;
case
TRRTYPE_OPT
:
{
LOG
(
(
"
Parsing
opt
rdlen
:
%
u
"
rdlength
)
)
;
unsigned
int
offset
=
0
;
while
(
offset
+
2
<
=
rdlength
)
{
uint16_t
optCode
=
get16bit
(
aBuffer
index
+
offset
)
;
LOG
(
(
"
optCode
:
%
u
"
optCode
)
)
;
offset
+
=
2
;
if
(
offset
+
2
>
rdlength
)
{
break
;
}
uint16_t
optLen
=
get16bit
(
aBuffer
index
+
offset
)
;
LOG
(
(
"
optLen
:
%
u
"
optLen
)
)
;
offset
+
=
2
;
if
(
offset
+
optLen
>
rdlength
)
{
LOG
(
(
"
offset
:
%
u
optLen
:
%
u
rdlen
:
%
u
"
offset
optLen
rdlength
)
)
;
break
;
}
LOG
(
(
"
OPT
:
code
:
%
u
len
:
%
u
"
optCode
optLen
)
)
;
if
(
optCode
!
=
15
)
{
offset
+
=
optLen
;
continue
;
}
if
(
offset
+
2
>
rdlength
|
|
optLen
<
2
)
{
break
;
}
extendedError
=
get16bit
(
aBuffer
index
+
offset
)
;
LOG
(
(
"
Extended
error
code
:
%
u
message
:
%
s
"
extendedError
nsAutoCString
(
(
char
*
)
aBuffer
+
index
+
offset
+
2
optLen
-
2
)
.
get
(
)
)
)
;
offset
+
=
optLen
;
}
break
;
}
default
:
break
;
}
}
;
parseRecord
(
)
;
index
+
=
rdlength
;
LOG
(
(
"
done
with
additional
rr
now
%
u
of
%
u
\
n
"
index
aLen
)
)
;
arRecords
-
-
;
}
if
(
index
!
=
aLen
)
{
LOG
(
(
"
DohDecode
failed
to
parse
entire
response
body
%
u
out
of
%
u
bytes
\
n
"
index
aLen
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
aType
=
=
TRRTYPE_NS
&
&
rcode
!
=
0
)
{
return
NS_ERROR_UNKNOWN_HOST
;
}
if
(
(
aType
!
=
TRRTYPE_NS
)
&
&
aCname
.
IsEmpty
(
)
&
&
aResp
.
mAddresses
.
IsEmpty
(
)
&
&
aTypeResult
.
is
<
TypeRecordEmpty
>
(
)
)
{
LOG
(
(
"
TRR
:
No
entries
were
stored
!
\
n
"
)
)
;
if
(
extendedError
!
=
UINT16_MAX
&
&
hardFail
(
extendedError
)
)
{
return
NS_ERROR_DEFINITIVE_UNKNOWN_HOST
;
}
return
NS_ERROR_UNKNOWN_HOST
;
}
if
(
aTypeResult
.
is
<
TypeRecordHTTPSSVC
>
(
)
)
{
auto
&
results
=
aTypeResult
.
as
<
TypeRecordHTTPSSVC
>
(
)
;
results
.
Sort
(
)
;
}
return
NS_OK
;
}
nsresult
DNSPacket
:
:
Decode
(
nsCString
&
aHost
enum
TrrType
aType
nsCString
&
aCname
bool
aAllowRFC1918
DOHresp
&
aResp
TypeRecordResultType
&
aTypeResult
nsClassHashtable
<
nsCStringHashKey
DOHresp
>
&
aAdditionalRecords
uint32_t
&
aTTL
)
{
nsresult
rv
=
DecodeInternal
(
aHost
aType
aCname
aAllowRFC1918
aResp
aTypeResult
aAdditionalRecords
aTTL
mResponse
mBodySize
)
;
SetDNSPacketStatus
(
NS_SUCCEEDED
(
rv
)
?
DNSPacketStatus
:
:
Success
:
DNSPacketStatus
:
:
DecodeError
)
;
return
rv
;
}
static
SECItem
*
CreateRawConfig
(
const
ObliviousDoHConfig
&
aConfig
)
{
SECItem
*
item
(
:
:
SECITEM_AllocItem
(
nullptr
nullptr
8
+
aConfig
.
mContents
.
mPublicKey
.
Length
(
)
)
)
;
if
(
!
item
)
{
return
nullptr
;
}
uint16_t
index
=
0
;
NetworkEndian
:
:
writeUint16
(
&
item
-
>
data
[
index
]
aConfig
.
mContents
.
mKemId
)
;
index
+
=
2
;
NetworkEndian
:
:
writeUint16
(
&
item
-
>
data
[
index
]
aConfig
.
mContents
.
mKdfId
)
;
index
+
=
2
;
NetworkEndian
:
:
writeUint16
(
&
item
-
>
data
[
index
]
aConfig
.
mContents
.
mAeadId
)
;
index
+
=
2
;
uint16_t
keyLength
=
aConfig
.
mContents
.
mPublicKey
.
Length
(
)
;
NetworkEndian
:
:
writeUint16
(
&
item
-
>
data
[
index
]
keyLength
)
;
index
+
=
2
;
memcpy
(
&
item
-
>
data
[
index
]
aConfig
.
mContents
.
mPublicKey
.
Elements
(
)
aConfig
.
mContents
.
mPublicKey
.
Length
(
)
)
;
return
item
;
}
static
bool
CreateConfigId
(
ObliviousDoHConfig
&
aConfig
)
{
SECStatus
rv
;
CK_HKDF_PARAMS
params
=
{
0
}
;
SECItem
paramsi
=
{
siBuffer
(
unsigned
char
*
)
&
params
sizeof
(
params
)
}
;
UniquePK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
if
(
!
slot
)
{
return
false
;
}
UniqueSECItem
rawConfig
(
CreateRawConfig
(
aConfig
)
)
;
if
(
!
rawConfig
)
{
return
false
;
}
UniquePK11SymKey
configKey
(
PK11_ImportDataKey
(
slot
.
get
(
)
CKM_HKDF_DATA
PK11_OriginUnwrap
CKA_DERIVE
rawConfig
.
get
(
)
nullptr
)
)
;
if
(
!
configKey
)
{
return
false
;
}
params
.
bExtract
=
CK_TRUE
;
params
.
bExpand
=
CK_TRUE
;
params
.
prfHashMechanism
=
CKM_SHA256
;
params
.
ulSaltType
=
CKF_HKDF_SALT_NULL
;
params
.
pInfo
=
(
unsigned
char
*
)
&
hODoHConfigID
[
0
]
;
params
.
ulInfoLen
=
strlen
(
hODoHConfigID
)
;
UniquePK11SymKey
derived
(
PK11_DeriveWithFlags
(
configKey
.
get
(
)
CKM_HKDF_DATA
&
paramsi
CKM_HKDF_DERIVE
CKA_DERIVE
SHA256_LENGTH
CKF_SIGN
|
CKF_VERIFY
)
)
;
rv
=
PK11_ExtractKeyValue
(
derived
.
get
(
)
)
;
if
(
rv
!
=
SECSuccess
)
{
return
false
;
}
SECItem
*
derivedItem
=
PK11_GetKeyData
(
derived
.
get
(
)
)
;
if
(
!
derivedItem
)
{
return
false
;
}
if
(
derivedItem
-
>
len
!
=
SHA256_LENGTH
)
{
return
false
;
}
aConfig
.
mConfigId
.
AppendElements
(
derivedItem
-
>
data
derivedItem
-
>
len
)
;
return
true
;
}
bool
ODoHDNSPacket
:
:
ParseODoHConfigs
(
Span
<
const
uint8_t
>
aData
nsTArray
<
ObliviousDoHConfig
>
&
aOut
)
{
Span
<
const
uint8_t
>
:
:
const_iterator
it
=
aData
.
begin
(
)
;
uint16_t
length
=
0
;
if
(
!
get16bit
(
aData
it
length
)
)
{
return
false
;
}
if
(
length
!
=
aData
.
Length
(
)
-
2
)
{
return
false
;
}
nsTArray
<
ObliviousDoHConfig
>
result
;
static
const
uint32_t
kMinimumConfigContentLength
=
12
;
while
(
std
:
:
distance
(
it
aData
.
cend
(
)
)
>
kMinimumConfigContentLength
)
{
ObliviousDoHConfig
config
;
if
(
!
get16bit
(
aData
it
config
.
mVersion
)
)
{
return
false
;
}
if
(
!
get16bit
(
aData
it
config
.
mLength
)
)
{
return
false
;
}
if
(
std
:
:
distance
(
it
aData
.
cend
(
)
)
<
config
.
mLength
)
{
return
false
;
}
if
(
!
get16bit
(
aData
it
config
.
mContents
.
mKemId
)
)
{
return
false
;
}
if
(
!
get16bit
(
aData
it
config
.
mContents
.
mKdfId
)
)
{
return
false
;
}
if
(
!
get16bit
(
aData
it
config
.
mContents
.
mAeadId
)
)
{
return
false
;
}
uint16_t
keyLength
=
0
;
if
(
!
get16bit
(
aData
it
keyLength
)
)
{
return
false
;
}
if
(
!
keyLength
|
|
std
:
:
distance
(
it
aData
.
cend
(
)
)
<
keyLength
)
{
return
false
;
}
config
.
mContents
.
mPublicKey
.
AppendElements
(
Span
(
it
it
+
keyLength
)
)
;
it
+
=
keyLength
;
CreateConfigId
(
config
)
;
if
(
config
.
mVersion
=
=
ODOH_VERSION
&
&
PK11_HPKE_ValidateParameters
(
static_cast
<
HpkeKemId
>
(
config
.
mContents
.
mKemId
)
static_cast
<
HpkeKdfId
>
(
config
.
mContents
.
mKdfId
)
static_cast
<
HpkeAeadId
>
(
config
.
mContents
.
mAeadId
)
)
=
=
SECSuccess
)
{
result
.
AppendElement
(
std
:
:
move
(
config
)
)
;
}
else
{
LOG
(
(
"
ODoHDNSPacket
:
:
ParseODoHConfigs
got
an
invalid
config
"
)
)
;
}
}
aOut
=
std
:
:
move
(
result
)
;
return
true
;
}
ODoHDNSPacket
:
:
~
ODoHDNSPacket
(
)
{
PK11_HPKE_DestroyContext
(
mContext
true
)
;
}
nsresult
ODoHDNSPacket
:
:
EncodeRequest
(
nsCString
&
aBody
const
nsACString
&
aHost
uint16_t
aType
bool
aDisableECS
)
{
nsAutoCString
queryBody
;
nsresult
rv
=
DNSPacket
:
:
EncodeRequest
(
queryBody
aHost
aType
aDisableECS
)
;
if
(
NS_FAILED
(
rv
)
)
{
SetDNSPacketStatus
(
DNSPacketStatus
:
:
EncodeError
)
;
return
rv
;
}
if
(
!
gODoHService
-
>
ODoHConfigs
(
)
)
{
SetDNSPacketStatus
(
DNSPacketStatus
:
:
KeyNotAvailable
)
;
return
NS_ERROR_FAILURE
;
}
if
(
gODoHService
-
>
ODoHConfigs
(
)
-
>
IsEmpty
(
)
)
{
SetDNSPacketStatus
(
DNSPacketStatus
:
:
KeyNotUsable
)
;
return
NS_ERROR_FAILURE
;
}
const
ObliviousDoHConfig
&
config
=
(
*
gODoHService
-
>
ODoHConfigs
(
)
)
[
0
]
;
ObliviousDoHMessage
message
;
if
(
!
EncryptDNSQuery
(
queryBody
0
config
message
)
)
{
SetDNSPacketStatus
(
DNSPacketStatus
:
:
EncryptError
)
;
return
NS_ERROR_FAILURE
;
}
aBody
.
Truncate
(
)
;
aBody
+
=
message
.
mType
;
uint16_t
keyIdLength
=
message
.
mKeyId
.
Length
(
)
;
aBody
+
=
static_cast
<
uint8_t
>
(
keyIdLength
>
>
8
)
;
aBody
+
=
static_cast
<
uint8_t
>
(
keyIdLength
)
;
aBody
.
Append
(
reinterpret_cast
<
const
char
*
>
(
message
.
mKeyId
.
Elements
(
)
)
keyIdLength
)
;
uint16_t
messageLen
=
message
.
mEncryptedMessage
.
Length
(
)
;
aBody
+
=
static_cast
<
uint8_t
>
(
messageLen
>
>
8
)
;
aBody
+
=
static_cast
<
uint8_t
>
(
messageLen
)
;
aBody
.
Append
(
reinterpret_cast
<
const
char
*
>
(
message
.
mEncryptedMessage
.
Elements
(
)
)
messageLen
)
;
SetDNSPacketStatus
(
DNSPacketStatus
:
:
Success
)
;
return
NS_OK
;
}
bool
ODoHDNSPacket
:
:
EncryptDNSQuery
(
const
nsACString
&
aQuery
uint16_t
aPaddingLen
const
ObliviousDoHConfig
&
aConfig
ObliviousDoHMessage
&
aOut
)
{
mContext
=
PK11_HPKE_NewContext
(
static_cast
<
HpkeKemId
>
(
aConfig
.
mContents
.
mKemId
)
static_cast
<
HpkeKdfId
>
(
aConfig
.
mContents
.
mKdfId
)
static_cast
<
HpkeAeadId
>
(
aConfig
.
mContents
.
mAeadId
)
nullptr
nullptr
)
;
if
(
!
mContext
)
{
LOG
(
(
"
ODoHDNSPacket
:
:
EncryptDNSQuery
create
context
failed
"
)
)
;
return
false
;
}
SECKEYPublicKey
*
pkR
;
SECStatus
rv
=
PK11_HPKE_Deserialize
(
mContext
aConfig
.
mContents
.
mPublicKey
.
Elements
(
)
aConfig
.
mContents
.
mPublicKey
.
Length
(
)
&
pkR
)
;
if
(
rv
!
=
SECSuccess
)
{
return
false
;
}
UniqueSECItem
hpkeInfo
(
:
:
SECITEM_AllocItem
(
nullptr
nullptr
strlen
(
kODoHQuery
)
)
)
;
if
(
!
hpkeInfo
)
{
return
false
;
}
memcpy
(
hpkeInfo
-
>
data
kODoHQuery
strlen
(
kODoHQuery
)
)
;
rv
=
PK11_HPKE_SetupS
(
mContext
nullptr
nullptr
pkR
hpkeInfo
.
get
(
)
)
;
if
(
rv
!
=
SECSuccess
)
{
LOG
(
(
"
ODoHDNSPacket
:
:
EncryptDNSQuery
setupS
failed
"
)
)
;
return
false
;
}
const
SECItem
*
hpkeEnc
=
PK11_HPKE_GetEncapPubKey
(
mContext
)
;
if
(
!
hpkeEnc
)
{
return
false
;
}
UniqueSECItem
aad
(
:
:
SECITEM_AllocItem
(
nullptr
nullptr
1
+
2
+
aConfig
.
mConfigId
.
Length
(
)
)
)
;
if
(
!
aad
)
{
return
false
;
}
aad
-
>
data
[
0
]
=
ODOH_QUERY
;
NetworkEndian
:
:
writeUint16
(
&
aad
-
>
data
[
1
]
aConfig
.
mConfigId
.
Length
(
)
)
;
memcpy
(
&
aad
-
>
data
[
3
]
aConfig
.
mConfigId
.
Elements
(
)
aConfig
.
mConfigId
.
Length
(
)
)
;
SECItem
*
odohPlainText
(
:
:
SECITEM_AllocItem
(
nullptr
nullptr
2
+
aQuery
.
Length
(
)
+
2
+
aPaddingLen
)
)
;
if
(
!
odohPlainText
)
{
return
false
;
}
mPlainQuery
.
reset
(
odohPlainText
)
;
memset
(
mPlainQuery
-
>
data
0
mPlainQuery
-
>
len
)
;
NetworkEndian
:
:
writeUint16
(
&
mPlainQuery
-
>
data
[
0
]
aQuery
.
Length
(
)
)
;
memcpy
(
&
mPlainQuery
-
>
data
[
2
]
aQuery
.
BeginReading
(
)
aQuery
.
Length
(
)
)
;
NetworkEndian
:
:
writeUint16
(
&
mPlainQuery
-
>
data
[
2
+
aQuery
.
Length
(
)
]
aPaddingLen
)
;
SECItem
*
chCt
=
nullptr
;
rv
=
PK11_HPKE_Seal
(
mContext
aad
.
get
(
)
mPlainQuery
.
get
(
)
&
chCt
)
;
if
(
rv
!
=
SECSuccess
)
{
LOG
(
(
"
ODoHDNSPacket
:
:
EncryptDNSQuery
seal
failed
"
)
)
;
return
false
;
}
UniqueSECItem
ct
(
chCt
)
;
aOut
.
mType
=
ODOH_QUERY
;
aOut
.
mKeyId
.
AppendElements
(
aConfig
.
mConfigId
)
;
aOut
.
mEncryptedMessage
.
AppendElements
(
Span
(
hpkeEnc
-
>
data
hpkeEnc
-
>
len
)
)
;
aOut
.
mEncryptedMessage
.
AppendElements
(
Span
(
ct
-
>
data
ct
-
>
len
)
)
;
return
true
;
}
nsresult
ODoHDNSPacket
:
:
Decode
(
nsCString
&
aHost
enum
TrrType
aType
nsCString
&
aCname
bool
aAllowRFC1918
DOHresp
&
aResp
TypeRecordResultType
&
aTypeResult
nsClassHashtable
<
nsCStringHashKey
DOHresp
>
&
aAdditionalRecords
uint32_t
&
aTTL
)
{
if
(
!
mDecryptedResponseRange
)
{
if
(
!
DecryptDNSResponse
(
)
)
{
SetDNSPacketStatus
(
DNSPacketStatus
:
:
DecryptError
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
index
=
0
;
uint16_t
responseLength
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
if
(
mBodySize
<
(
index
+
responseLength
)
)
{
SetDNSPacketStatus
(
DNSPacketStatus
:
:
DecryptError
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
DecryptedResponseRange
range
;
range
.
mStart
=
index
;
range
.
mLength
=
responseLength
;
index
+
=
responseLength
;
uint16_t
paddingLen
=
get16bit
(
mResponse
index
)
;
if
(
static_cast
<
unsigned
int
>
(
4
+
responseLength
+
paddingLen
)
!
=
mBodySize
)
{
SetDNSPacketStatus
(
DNSPacketStatus
:
:
DecryptError
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
mDecryptedResponseRange
.
emplace
(
range
)
;
}
nsresult
rv
=
DecodeInternal
(
aHost
aType
aCname
aAllowRFC1918
aResp
aTypeResult
aAdditionalRecords
aTTL
&
mResponse
[
mDecryptedResponseRange
-
>
mStart
]
mDecryptedResponseRange
-
>
mLength
)
;
SetDNSPacketStatus
(
NS_SUCCEEDED
(
rv
)
?
DNSPacketStatus
:
:
Success
:
DNSPacketStatus
:
:
DecodeError
)
;
return
rv
;
}
static
bool
CreateObliviousDoHMessage
(
const
unsigned
char
*
aData
unsigned
int
aLength
ObliviousDoHMessage
&
aOut
)
{
if
(
aLength
<
5
)
{
return
false
;
}
unsigned
int
index
=
0
;
aOut
.
mType
=
static_cast
<
ObliviousDoHMessageType
>
(
aData
[
index
+
+
]
)
;
uint16_t
keyIdLength
=
get16bit
(
aData
index
)
;
index
+
=
2
;
if
(
aLength
<
(
index
+
keyIdLength
)
)
{
return
false
;
}
aOut
.
mKeyId
.
AppendElements
(
Span
(
aData
+
index
keyIdLength
)
)
;
index
+
=
keyIdLength
;
uint16_t
messageLen
=
get16bit
(
aData
index
)
;
index
+
=
2
;
if
(
aLength
<
(
index
+
messageLen
)
)
{
return
false
;
}
aOut
.
mEncryptedMessage
.
AppendElements
(
Span
(
aData
+
index
messageLen
)
)
;
return
true
;
}
static
SECStatus
HKDFExtract
(
SECItem
*
aSalt
PK11SymKey
*
aIkm
UniquePK11SymKey
&
aOutKey
)
{
CK_HKDF_PARAMS
params
=
{
0
}
;
SECItem
paramsItem
=
{
siBuffer
(
unsigned
char
*
)
&
params
sizeof
(
params
)
}
;
params
.
bExtract
=
CK_TRUE
;
params
.
bExpand
=
CK_FALSE
;
params
.
prfHashMechanism
=
CKM_SHA256
;
params
.
ulSaltType
=
aSalt
?
CKF_HKDF_SALT_DATA
:
CKF_HKDF_SALT_NULL
;
params
.
pSalt
=
aSalt
?
(
CK_BYTE_PTR
)
aSalt
-
>
data
:
nullptr
;
params
.
ulSaltLen
=
aSalt
?
aSalt
-
>
len
:
0
;
UniquePK11SymKey
prk
(
PK11_Derive
(
aIkm
CKM_HKDF_DERIVE
&
paramsItem
CKM_HKDF_DERIVE
CKA_DERIVE
0
)
)
;
if
(
!
prk
)
{
return
SECFailure
;
}
aOutKey
.
swap
(
prk
)
;
return
SECSuccess
;
}
static
SECStatus
HKDFExpand
(
PK11SymKey
*
aPrk
const
SECItem
*
aInfo
int
aLen
bool
aKey
UniquePK11SymKey
&
aOutKey
)
{
CK_HKDF_PARAMS
params
=
{
0
}
;
SECItem
paramsItem
=
{
siBuffer
(
unsigned
char
*
)
&
params
sizeof
(
params
)
}
;
params
.
bExtract
=
CK_FALSE
;
params
.
bExpand
=
CK_TRUE
;
params
.
prfHashMechanism
=
CKM_SHA256
;
params
.
ulSaltType
=
CKF_HKDF_SALT_NULL
;
params
.
pInfo
=
(
CK_BYTE_PTR
)
aInfo
-
>
data
;
params
.
ulInfoLen
=
aInfo
-
>
len
;
CK_MECHANISM_TYPE
deriveMech
=
CKM_HKDF_DERIVE
;
CK_MECHANISM_TYPE
keyMech
=
aKey
?
CKM_AES_GCM
:
CKM_HKDF_DERIVE
;
UniquePK11SymKey
derivedKey
(
PK11_Derive
(
aPrk
deriveMech
&
paramsItem
keyMech
CKA_DERIVE
aLen
)
)
;
if
(
!
derivedKey
)
{
return
SECFailure
;
}
aOutKey
.
swap
(
derivedKey
)
;
return
SECSuccess
;
}
bool
ODoHDNSPacket
:
:
DecryptDNSResponse
(
)
{
ObliviousDoHMessage
message
;
if
(
!
CreateObliviousDoHMessage
(
mResponse
mBodySize
message
)
)
{
LOG
(
(
"
ODoHDNSPacket
:
:
DecryptDNSResponse
invalid
response
"
)
)
;
return
false
;
}
if
(
message
.
mType
!
=
ODOH_RESPONSE
)
{
return
false
;
}
const
unsigned
int
kResponseNonceLen
=
16
;
if
(
message
.
mKeyId
.
Length
(
)
!
=
kResponseNonceLen
)
{
return
false
;
}
const
SECItem
kODoHResponsetInfoItem
=
{
siBuffer
(
unsigned
char
*
)
kODoHResponse
static_cast
<
unsigned
int
>
(
strlen
(
kODoHResponse
)
)
}
;
const
unsigned
int
kAes128GcmKeyLen
=
16
;
const
unsigned
int
kAes128GcmNonceLen
=
12
;
PK11SymKey
*
tmp
=
nullptr
;
SECStatus
rv
=
PK11_HPKE_ExportSecret
(
mContext
&
kODoHResponsetInfoItem
kAes128GcmKeyLen
&
tmp
)
;
if
(
rv
!
=
SECSuccess
)
{
LOG
(
(
"
ODoHDNSPacket
:
:
DecryptDNSResponse
export
secret
failed
"
)
)
;
return
false
;
}
UniquePK11SymKey
odohSecret
(
tmp
)
;
SECItem
*
salt
(
:
:
SECITEM_AllocItem
(
nullptr
nullptr
mPlainQuery
-
>
len
+
2
+
kResponseNonceLen
)
)
;
memcpy
(
salt
-
>
data
mPlainQuery
-
>
data
mPlainQuery
-
>
len
)
;
NetworkEndian
:
:
writeUint16
(
&
salt
-
>
data
[
mPlainQuery
-
>
len
]
kResponseNonceLen
)
;
memcpy
(
salt
-
>
data
+
mPlainQuery
-
>
len
+
2
message
.
mKeyId
.
Elements
(
)
kResponseNonceLen
)
;
UniqueSECItem
st
(
salt
)
;
UniquePK11SymKey
odohPrk
;
rv
=
HKDFExtract
(
salt
odohSecret
.
get
(
)
odohPrk
)
;
if
(
rv
!
=
SECSuccess
)
{
LOG
(
(
"
ODoHDNSPacket
:
:
DecryptDNSResponse
extract
failed
"
)
)
;
return
false
;
}
SECItem
keyInfoItem
=
{
siBuffer
(
unsigned
char
*
)
&
kODoHKey
[
0
]
static_cast
<
unsigned
int
>
(
strlen
(
kODoHKey
)
)
}
;
UniquePK11SymKey
key
;
rv
=
HKDFExpand
(
odohPrk
.
get
(
)
&
keyInfoItem
kAes128GcmKeyLen
true
key
)
;
if
(
rv
!
=
SECSuccess
)
{
LOG
(
(
"
ODoHDNSPacket
:
:
DecryptDNSResponse
expand
key
failed
"
)
)
;
return
false
;
}
SECItem
nonceInfoItem
=
{
siBuffer
(
unsigned
char
*
)
&
kODoHNonce
[
0
]
static_cast
<
unsigned
int
>
(
strlen
(
kODoHNonce
)
)
}
;
UniquePK11SymKey
nonce
;
rv
=
HKDFExpand
(
odohPrk
.
get
(
)
&
nonceInfoItem
kAes128GcmNonceLen
false
nonce
)
;
if
(
rv
!
=
SECSuccess
)
{
LOG
(
(
"
ODoHDNSPacket
:
:
DecryptDNSResponse
expand
nonce
failed
"
)
)
;
return
false
;
}
rv
=
PK11_ExtractKeyValue
(
nonce
.
get
(
)
)
;
if
(
rv
!
=
SECSuccess
)
{
return
false
;
}
SECItem
*
derivedItem
=
PK11_GetKeyData
(
nonce
.
get
(
)
)
;
if
(
!
derivedItem
)
{
return
false
;
}
SECItem
*
aadItem
(
:
:
SECITEM_AllocItem
(
nullptr
nullptr
1
+
2
+
kResponseNonceLen
)
)
;
aadItem
-
>
data
[
0
]
=
ODOH_RESPONSE
;
NetworkEndian
:
:
writeUint16
(
&
aadItem
-
>
data
[
1
]
kResponseNonceLen
)
;
memcpy
(
&
aadItem
-
>
data
[
3
]
message
.
mKeyId
.
Elements
(
)
kResponseNonceLen
)
;
UniqueSECItem
aad
(
aadItem
)
;
SECItem
paramItem
;
CK_GCM_PARAMS
param
;
param
.
pIv
=
derivedItem
-
>
data
;
param
.
ulIvLen
=
derivedItem
-
>
len
;
param
.
ulIvBits
=
param
.
ulIvLen
*
8
;
param
.
ulTagBits
=
16
*
8
;
param
.
pAAD
=
(
CK_BYTE_PTR
)
aad
-
>
data
;
param
.
ulAADLen
=
aad
-
>
len
;
paramItem
.
type
=
siBuffer
;
paramItem
.
data
=
(
unsigned
char
*
)
(
&
param
)
;
paramItem
.
len
=
sizeof
(
CK_GCM_PARAMS
)
;
memset
(
mResponse
0
mBodySize
)
;
rv
=
PK11_Decrypt
(
key
.
get
(
)
CKM_AES_GCM
&
paramItem
mResponse
&
mBodySize
MAX_SIZE
message
.
mEncryptedMessage
.
Elements
(
)
message
.
mEncryptedMessage
.
Length
(
)
)
;
if
(
rv
!
=
SECSuccess
)
{
LOG
(
(
"
ODoHDNSPacket
:
:
DecryptDNSResponse
decrypt
failed
%
d
"
PORT_GetError
(
)
)
)
;
return
false
;
}
return
true
;
}
}
}
