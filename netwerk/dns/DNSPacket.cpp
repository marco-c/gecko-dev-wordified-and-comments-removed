#
include
"
DNSPacket
.
h
"
namespace
mozilla
{
namespace
net
{
extern
mozilla
:
:
LazyLogModule
gHostResolverLog
;
#
undef
LOG
#
undef
LOG_ENABLED
#
define
LOG
(
args
)
MOZ_LOG
(
gHostResolverLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
mozilla
:
:
net
:
:
gHostResolverLog
mozilla
:
:
LogLevel
:
:
Debug
)
static
uint16_t
get16bit
(
const
unsigned
char
*
aData
unsigned
int
index
)
{
return
(
(
aData
[
index
]
<
<
8
)
|
aData
[
index
+
1
]
)
;
}
static
uint32_t
get32bit
(
const
unsigned
char
*
aData
unsigned
int
index
)
{
return
(
aData
[
index
]
<
<
24
)
|
(
aData
[
index
+
1
]
<
<
16
)
|
(
aData
[
index
+
2
]
<
<
8
)
|
aData
[
index
+
3
]
;
}
bool
hardFail
(
uint16_t
code
)
{
const
uint16_t
noFallbackErrors
[
]
=
{
4
6
7
8
9
10
11
12
17
}
;
for
(
const
auto
&
err
:
noFallbackErrors
)
{
if
(
code
=
=
err
)
{
return
true
;
}
}
return
false
;
}
nsresult
DNSPacket
:
:
ParseSvcParam
(
unsigned
int
svcbIndex
uint16_t
key
SvcFieldValue
&
field
uint16_t
length
)
{
switch
(
key
)
{
case
SvcParamKeyMandatory
:
{
if
(
length
%
2
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
while
(
length
>
0
)
{
uint16_t
mandatoryKey
=
get16bit
(
mResponse
svcbIndex
)
;
length
-
=
2
;
svcbIndex
+
=
2
;
if
(
!
IsValidSvcParamKey
(
mandatoryKey
)
)
{
LOG
(
(
"
The
mandatory
field
includes
a
key
we
don
'
t
support
%
u
"
mandatoryKey
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
break
;
}
case
SvcParamKeyAlpn
:
{
field
.
mValue
=
AsVariant
(
SvcParamAlpn
(
)
)
;
auto
&
alpnArray
=
field
.
mValue
.
as
<
SvcParamAlpn
>
(
)
.
mValue
;
while
(
length
>
0
)
{
uint8_t
alpnIdLength
=
mResponse
[
svcbIndex
+
+
]
;
length
-
=
1
;
if
(
alpnIdLength
>
length
)
{
return
NS_ERROR_UNEXPECTED
;
}
alpnArray
.
AppendElement
(
nsCString
(
(
const
char
*
)
&
mResponse
[
svcbIndex
]
alpnIdLength
)
)
;
length
-
=
alpnIdLength
;
svcbIndex
+
=
alpnIdLength
;
}
break
;
}
case
SvcParamKeyNoDefaultAlpn
:
{
if
(
length
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamNoDefaultAlpn
{
}
)
;
break
;
}
case
SvcParamKeyPort
:
{
if
(
length
!
=
2
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamPort
{
.
mValue
=
get16bit
(
mResponse
svcbIndex
)
}
)
;
break
;
}
case
SvcParamKeyIpv4Hint
:
{
if
(
length
%
4
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamIpv4Hint
(
)
)
;
auto
&
ipv4array
=
field
.
mValue
.
as
<
SvcParamIpv4Hint
>
(
)
.
mValue
;
while
(
length
>
0
)
{
NetAddr
addr
;
addr
.
inet
.
family
=
AF_INET
;
addr
.
inet
.
port
=
0
;
addr
.
inet
.
ip
=
ntohl
(
get32bit
(
mResponse
svcbIndex
)
)
;
ipv4array
.
AppendElement
(
addr
)
;
length
-
=
4
;
svcbIndex
+
=
4
;
}
break
;
}
case
SvcParamKeyEchConfig
:
{
field
.
mValue
=
AsVariant
(
SvcParamEchConfig
{
.
mValue
=
nsCString
(
(
const
char
*
)
(
&
mResponse
[
svcbIndex
]
)
length
)
}
)
;
break
;
}
case
SvcParamKeyIpv6Hint
:
{
if
(
length
%
16
!
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
field
.
mValue
=
AsVariant
(
SvcParamIpv6Hint
(
)
)
;
auto
&
ipv6array
=
field
.
mValue
.
as
<
SvcParamIpv6Hint
>
(
)
.
mValue
;
while
(
length
>
0
)
{
NetAddr
addr
;
addr
.
inet6
.
family
=
AF_INET6
;
addr
.
inet6
.
port
=
0
;
addr
.
inet6
.
flowinfo
=
0
;
addr
.
inet6
.
scope_id
=
0
;
for
(
int
i
=
0
;
i
<
16
;
i
+
+
svcbIndex
+
+
)
{
addr
.
inet6
.
ip
.
u8
[
i
]
=
mResponse
[
svcbIndex
]
;
}
ipv6array
.
AppendElement
(
addr
)
;
length
-
=
16
;
}
break
;
}
case
SvcParamKeyODoHConfig
:
{
field
.
mValue
=
AsVariant
(
SvcParamODoHConfig
{
.
mValue
=
nsCString
(
(
const
char
*
)
(
&
mResponse
[
svcbIndex
]
)
length
)
}
)
;
break
;
}
default
:
{
return
NS_OK
;
break
;
}
}
return
NS_OK
;
}
nsresult
DNSPacket
:
:
PassQName
(
unsigned
int
&
index
)
{
uint8_t
length
;
do
{
if
(
mBodySize
<
(
index
+
1
)
)
{
LOG
(
(
"
TRR
:
PassQName
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
length
=
static_cast
<
uint8_t
>
(
mResponse
[
index
]
)
;
if
(
(
length
&
0xc0
)
=
=
0xc0
)
{
if
(
mBodySize
<
(
index
+
2
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
2
;
break
;
}
if
(
length
&
0xc0
)
{
LOG
(
(
"
TRR
:
illegal
label
length
byte
(
%
x
)
at
index
%
d
\
n
"
length
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
mBodySize
<
(
index
+
1
+
length
)
)
{
LOG
(
(
"
TRR
:
PassQName
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
1
+
length
;
}
while
(
length
)
;
return
NS_OK
;
}
nsresult
DNSPacket
:
:
GetQname
(
nsACString
&
aQname
unsigned
int
&
aIndex
)
{
uint8_t
clength
=
0
;
unsigned
int
cindex
=
aIndex
;
unsigned
int
loop
=
128
;
unsigned
int
endindex
=
0
;
do
{
if
(
cindex
>
=
mBodySize
)
{
LOG
(
(
"
TRR
:
bad
Qname
packet
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
clength
=
static_cast
<
uint8_t
>
(
mResponse
[
cindex
]
)
;
if
(
(
clength
&
0xc0
)
=
=
0xc0
)
{
if
(
(
cindex
+
1
)
>
=
mBodySize
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
newpos
=
(
clength
&
0x3f
)
<
<
8
|
mResponse
[
cindex
+
1
]
;
if
(
!
endindex
)
{
endindex
=
cindex
+
2
;
}
cindex
=
newpos
;
continue
;
}
if
(
clength
&
0xc0
)
{
LOG
(
(
"
TRR
:
bad
Qname
packet
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
cindex
+
+
;
if
(
clength
)
{
if
(
!
aQname
.
IsEmpty
(
)
)
{
aQname
.
Append
(
"
.
"
)
;
}
if
(
(
cindex
+
clength
)
>
mBodySize
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
aQname
.
Append
(
(
const
char
*
)
(
&
mResponse
[
cindex
]
)
clength
)
;
cindex
+
=
clength
;
}
}
while
(
clength
&
&
-
-
loop
)
;
if
(
!
loop
)
{
LOG
(
(
"
DNSPacket
:
:
DohDecode
pointer
loop
error
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
!
endindex
)
{
endindex
=
cindex
;
}
aIndex
=
endindex
;
return
NS_OK
;
}
nsresult
DOHresp
:
:
Add
(
uint32_t
TTL
unsigned
char
const
*
dns
unsigned
int
index
uint16_t
len
bool
aLocalAllowed
)
{
NetAddr
addr
;
if
(
4
=
=
len
)
{
addr
.
inet
.
family
=
AF_INET
;
addr
.
inet
.
port
=
0
;
addr
.
inet
.
ip
=
ntohl
(
get32bit
(
dns
index
)
)
;
}
else
if
(
16
=
=
len
)
{
addr
.
inet6
.
family
=
AF_INET6
;
addr
.
inet6
.
port
=
0
;
addr
.
inet6
.
flowinfo
=
0
;
addr
.
inet6
.
scope_id
=
0
;
for
(
int
i
=
0
;
i
<
16
;
i
+
+
index
+
+
)
{
addr
.
inet6
.
ip
.
u8
[
i
]
=
dns
[
index
]
;
}
}
else
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
addr
.
IsIPAddrLocal
(
)
&
&
!
aLocalAllowed
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mTtl
<
TTL
)
{
mTtl
=
TTL
;
}
if
(
LOG_ENABLED
(
)
)
{
char
buf
[
128
]
;
addr
.
ToStringBuffer
(
buf
sizeof
(
buf
)
)
;
LOG
(
(
"
DOHresp
:
Add
%
s
\
n
"
buf
)
)
;
}
mAddresses
.
AppendElement
(
addr
)
;
return
NS_OK
;
}
nsresult
DNSPacket
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aInputStream
uint64_t
aOffset
const
uint32_t
aCount
)
{
if
(
aCount
+
mBodySize
>
MAX_SIZE
)
{
LOG
(
(
"
DNSPacket
:
:
OnDataAvailable
:
%
d
fail
\
n
"
__LINE__
)
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
count
;
nsresult
rv
=
aInputStream
-
>
Read
(
(
char
*
)
mResponse
+
mBodySize
aCount
&
count
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
count
=
=
aCount
)
;
mBodySize
+
=
aCount
;
return
NS_OK
;
}
const
uint8_t
kDNS_CLASS_IN
=
1
;
nsresult
DNSPacket
:
:
EncodeRequest
(
nsCString
&
aBody
const
nsACString
&
aHost
uint16_t
aType
bool
aDisableECS
)
{
aBody
.
Truncate
(
)
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
0x01
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
1
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
aDisableECS
?
1
:
'
\
0
'
;
int32_t
index
=
0
;
int32_t
offset
=
0
;
do
{
bool
dotFound
=
false
;
int32_t
labelLength
;
index
=
aHost
.
FindChar
(
'
.
'
offset
)
;
if
(
kNotFound
!
=
index
)
{
dotFound
=
true
;
labelLength
=
index
-
offset
;
}
else
{
labelLength
=
aHost
.
Length
(
)
-
offset
;
}
if
(
labelLength
>
63
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
labelLength
>
0
)
{
aBody
+
=
static_cast
<
unsigned
char
>
(
labelLength
)
;
nsDependentCSubstring
label
=
Substring
(
aHost
offset
labelLength
)
;
aBody
.
Append
(
label
)
;
}
if
(
!
dotFound
)
{
aBody
+
=
'
\
0
'
;
break
;
}
offset
+
=
labelLength
+
1
;
}
while
(
true
)
;
aBody
+
=
static_cast
<
uint8_t
>
(
aType
>
>
8
)
;
aBody
+
=
static_cast
<
uint8_t
>
(
aType
)
;
aBody
+
=
'
\
0
'
;
aBody
+
=
kDNS_CLASS_IN
;
if
(
aDisableECS
)
{
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
41
;
aBody
+
=
16
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
aBody
+
=
8
;
aBody
+
=
'
\
0
'
;
aBody
+
=
8
;
aBody
+
=
'
\
0
'
;
aBody
+
=
4
;
aBody
+
=
'
\
0
'
;
aBody
+
=
1
;
aBody
+
=
'
\
0
'
;
aBody
+
=
'
\
0
'
;
}
return
NS_OK
;
}
nsresult
DNSPacket
:
:
Decode
(
nsCString
&
aHost
enum
TrrType
aType
nsCString
&
aCname
bool
aAllowRFC1918
nsHostRecord
:
:
TRRSkippedReason
&
aReason
DOHresp
&
aResp
TypeRecordResultType
&
aTypeResult
nsClassHashtable
<
nsCStringHashKey
DOHresp
>
&
aAdditionalRecords
uint32_t
&
aTTL
)
{
unsigned
int
index
=
12
;
uint8_t
length
;
nsAutoCString
host
;
nsresult
rv
;
uint16_t
extendedError
=
UINT16_MAX
;
LOG
(
(
"
doh
decode
%
s
%
d
bytes
\
n
"
aHost
.
get
(
)
mBodySize
)
)
;
aCname
.
Truncate
(
)
;
if
(
mBodySize
<
12
|
|
mResponse
[
0
]
|
|
mResponse
[
1
]
)
{
LOG
(
(
"
TRR
bad
incoming
DOH
eject
!
\
n
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint8_t
rcode
=
mResponse
[
3
]
&
0x0F
;
LOG
(
(
"
TRR
Decode
%
s
RCODE
%
d
\
n
"
aHost
.
get
(
)
rcode
)
)
;
if
(
rcode
)
{
if
(
aReason
=
=
nsHostRecord
:
:
TRR_UNSET
)
{
aReason
=
nsHostRecord
:
:
TRR_RCODE_FAIL
;
}
}
uint16_t
questionRecords
=
get16bit
(
mResponse
4
)
;
while
(
questionRecords
)
{
do
{
if
(
mBodySize
<
(
index
+
1
)
)
{
LOG
(
(
"
TRR
Decode
1
index
:
%
u
size
:
%
u
"
index
mBodySize
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
length
=
static_cast
<
uint8_t
>
(
mResponse
[
index
]
)
;
if
(
length
)
{
if
(
host
.
Length
(
)
)
{
host
.
Append
(
"
.
"
)
;
}
if
(
mBodySize
<
(
index
+
1
+
length
)
)
{
LOG
(
(
"
TRR
Decode
2
index
:
%
u
size
:
%
u
len
:
%
u
"
index
mBodySize
length
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
host
.
Append
(
(
(
char
*
)
mResponse
)
+
index
+
1
length
)
;
}
index
+
=
1
+
length
;
}
while
(
length
)
;
if
(
mBodySize
<
(
index
+
4
)
)
{
LOG
(
(
"
TRR
Decode
3
index
:
%
u
size
:
%
u
"
index
mBodySize
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
4
;
questionRecords
-
-
;
}
uint16_t
answerRecords
=
get16bit
(
mResponse
6
)
;
LOG
(
(
"
TRR
Decode
:
%
d
answer
records
(
%
u
bytes
body
)
%
s
index
=
%
u
\
n
"
answerRecords
mBodySize
host
.
get
(
)
index
)
)
;
while
(
answerRecords
)
{
nsAutoCString
qname
;
rv
=
GetQname
(
qname
index
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mBodySize
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
+
2
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
TYPE
=
get16bit
(
mResponse
index
)
;
if
(
(
TYPE
!
=
TRRTYPE_CNAME
)
&
&
(
TYPE
!
=
TRRTYPE_HTTPSSVC
)
&
&
(
TYPE
!
=
static_cast
<
uint16_t
>
(
aType
)
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
asked
for
type
%
d
got
%
d
\
n
"
__LINE__
aType
TYPE
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
index
+
=
2
;
if
(
mBodySize
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
+
2
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
CLASS
=
get16bit
(
mResponse
index
)
;
if
(
kDNS_CLASS_IN
!
=
CLASS
)
{
LOG
(
(
"
TRR
bad
CLASS
(
%
u
)
at
index
%
d
\
n
"
CLASS
index
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
index
+
=
2
;
if
(
mBodySize
<
(
index
+
4
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint32_t
TTL
=
get32bit
(
mResponse
index
)
;
index
+
=
4
;
if
(
mBodySize
<
(
index
+
2
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
at
index
%
d
\
n
"
__LINE__
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
RDLENGTH
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
if
(
mBodySize
<
(
index
+
RDLENGTH
)
)
{
LOG
(
(
"
TRR
:
Dohdecode
:
%
d
fail
RDLENGTH
=
%
d
at
index
%
d
\
n
"
__LINE__
RDLENGTH
index
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
bool
responseMatchesQuestion
=
(
qname
.
Length
(
)
=
=
aHost
.
Length
(
)
|
|
(
aHost
.
Length
(
)
=
=
qname
.
Length
(
)
+
1
&
&
aHost
.
Last
(
)
=
=
'
.
'
)
)
&
&
qname
.
Compare
(
aHost
.
BeginReading
(
)
true
qname
.
Length
(
)
)
=
=
0
;
if
(
responseMatchesQuestion
)
{
switch
(
TYPE
)
{
case
TRRTYPE_A
:
if
(
RDLENGTH
!
=
4
)
{
LOG
(
(
"
TRR
bad
length
for
A
(
%
u
)
\
n
"
RDLENGTH
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
rv
=
aResp
.
Add
(
TTL
mResponse
index
RDLENGTH
aAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
DohDecode
failed
:
local
IP
addresses
or
unknown
IP
"
"
family
\
n
"
)
)
;
return
rv
;
}
break
;
case
TRRTYPE_AAAA
:
if
(
RDLENGTH
!
=
16
)
{
LOG
(
(
"
TRR
bad
length
for
AAAA
(
%
u
)
\
n
"
RDLENGTH
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
rv
=
aResp
.
Add
(
TTL
mResponse
index
RDLENGTH
aAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
got
unique
/
local
IPv6
address
!
\
n
"
)
)
;
return
rv
;
}
break
;
case
TRRTYPE_NS
:
break
;
case
TRRTYPE_CNAME
:
if
(
aCname
.
IsEmpty
(
)
)
{
nsAutoCString
qname
;
unsigned
int
qnameindex
=
index
;
rv
=
GetQname
(
qname
qnameindex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
qname
.
IsEmpty
(
)
)
{
ToLowerCase
(
qname
)
;
aCname
=
qname
;
LOG
(
(
"
DNSPacket
:
:
DohDecode
CNAME
host
%
s
=
>
%
s
\
n
"
host
.
get
(
)
aCname
.
get
(
)
)
)
;
}
else
{
LOG
(
(
"
DNSPacket
:
:
DohDecode
empty
CNAME
for
host
%
s
!
\
n
"
host
.
get
(
)
)
)
;
}
}
else
{
LOG
(
(
"
DNSPacket
:
:
DohDecode
CNAME
-
ignoring
another
entry
\
n
"
)
)
;
}
break
;
case
TRRTYPE_TXT
:
{
nsAutoCString
txt
;
unsigned
int
txtIndex
=
index
;
uint16_t
available
=
RDLENGTH
;
while
(
available
>
0
)
{
uint8_t
characterStringLen
=
mResponse
[
txtIndex
+
+
]
;
available
-
-
;
if
(
characterStringLen
>
available
)
{
LOG
(
(
"
DNSPacket
:
:
DohDecode
MALFORMED
TXT
RECORD
\
n
"
)
)
;
break
;
}
txt
.
Append
(
(
const
char
*
)
(
&
mResponse
[
txtIndex
]
)
characterStringLen
)
;
txtIndex
+
=
characterStringLen
;
available
-
=
characterStringLen
;
}
if
(
!
aTypeResult
.
is
<
TypeRecordTxt
>
(
)
)
{
aTypeResult
=
AsVariant
(
CopyableTArray
<
nsCString
>
(
)
)
;
}
{
auto
&
results
=
aTypeResult
.
as
<
TypeRecordTxt
>
(
)
;
results
.
AppendElement
(
txt
)
;
}
if
(
aTTL
>
TTL
)
{
aTTL
=
TTL
;
}
LOG
(
(
"
DNSPacket
:
:
DohDecode
TXT
host
%
s
=
>
%
s
\
n
"
host
.
get
(
)
txt
.
get
(
)
)
)
;
break
;
}
case
TRRTYPE_HTTPSSVC
:
{
struct
SVCB
parsed
;
int32_t
lastSvcParamKey
=
-
1
;
unsigned
int
svcbIndex
=
index
;
CheckedInt
<
uint16_t
>
available
=
RDLENGTH
;
if
(
available
.
value
(
)
<
3
)
{
return
NS_ERROR_UNEXPECTED
;
}
parsed
.
mSvcFieldPriority
=
get16bit
(
mResponse
svcbIndex
)
;
svcbIndex
+
=
2
;
rv
=
GetQname
(
parsed
.
mSvcDomainName
svcbIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
parsed
.
mSvcDomainName
.
IsEmpty
(
)
)
{
if
(
parsed
.
mSvcFieldPriority
=
=
0
)
{
continue
;
}
parsed
.
mSvcDomainName
=
qname
;
}
available
-
=
(
svcbIndex
-
index
)
;
if
(
!
available
.
isValid
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
while
(
available
.
value
(
)
>
=
4
)
{
struct
SvcFieldValue
value
;
uint16_t
key
=
get16bit
(
mResponse
svcbIndex
)
;
svcbIndex
+
=
2
;
if
(
key
<
=
lastSvcParamKey
)
{
LOG
(
(
"
SvcParamKeys
not
in
increasing
order
"
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
lastSvcParamKey
=
key
;
uint16_t
len
=
get16bit
(
mResponse
svcbIndex
)
;
svcbIndex
+
=
2
;
available
-
=
4
+
len
;
if
(
!
available
.
isValid
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
rv
=
ParseSvcParam
(
svcbIndex
key
value
len
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
svcbIndex
+
=
len
;
if
(
key
=
=
SvcParamKeyMandatory
|
|
!
IsValidSvcParamKey
(
key
)
)
{
continue
;
}
if
(
value
.
mValue
.
is
<
SvcParamIpv4Hint
>
(
)
|
|
value
.
mValue
.
is
<
SvcParamIpv6Hint
>
(
)
)
{
parsed
.
mHasIPHints
=
true
;
}
if
(
value
.
mValue
.
is
<
SvcParamEchConfig
>
(
)
)
{
parsed
.
mHasEchConfig
=
true
;
parsed
.
mEchConfig
=
value
.
mValue
.
as
<
SvcParamEchConfig
>
(
)
.
mValue
;
}
if
(
value
.
mValue
.
is
<
SvcParamODoHConfig
>
(
)
)
{
parsed
.
mODoHConfig
=
value
.
mValue
.
as
<
SvcParamODoHConfig
>
(
)
.
mValue
;
}
parsed
.
mSvcFieldValue
.
AppendElement
(
value
)
;
}
if
(
aCname
.
IsEmpty
(
)
&
&
parsed
.
mSvcFieldPriority
=
=
0
)
{
if
(
parsed
.
mSvcDomainName
.
IsEmpty
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
aCname
=
parsed
.
mSvcDomainName
;
ToLowerCase
(
aCname
)
;
LOG
(
(
"
DNSPacket
:
:
DohDecode
HTTPSSVC
AliasForm
host
%
s
=
>
%
s
\
n
"
host
.
get
(
)
aCname
.
get
(
)
)
)
;
break
;
}
if
(
aType
!
=
TRRTYPE_HTTPSSVC
)
{
break
;
}
if
(
!
aTypeResult
.
is
<
TypeRecordHTTPSSVC
>
(
)
)
{
aTypeResult
=
mozilla
:
:
AsVariant
(
CopyableTArray
<
SVCB
>
(
)
)
;
}
{
auto
&
results
=
aTypeResult
.
as
<
TypeRecordHTTPSSVC
>
(
)
;
results
.
AppendElement
(
parsed
)
;
}
break
;
}
default
:
LOG
(
(
"
TRR
unsupported
TYPE
(
%
u
)
RDLENGTH
%
u
\
n
"
TYPE
RDLENGTH
)
)
;
break
;
}
}
else
{
LOG
(
(
"
TRR
asked
for
%
s
data
but
got
%
s
\
n
"
aHost
.
get
(
)
qname
.
get
(
)
)
)
;
}
index
+
=
RDLENGTH
;
LOG
(
(
"
done
with
record
type
%
u
len
%
u
index
now
%
u
of
%
u
\
n
"
TYPE
RDLENGTH
index
mBodySize
)
)
;
answerRecords
-
-
;
}
uint16_t
nsRecords
=
get16bit
(
mResponse
8
)
;
LOG
(
(
"
TRR
Decode
:
%
d
ns
records
(
%
u
bytes
body
)
\
n
"
nsRecords
mBodySize
)
)
;
while
(
nsRecords
)
{
rv
=
PassQName
(
index
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mBodySize
<
(
index
+
8
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
2
;
index
+
=
2
;
index
+
=
4
;
if
(
mBodySize
<
(
index
+
2
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
RDLENGTH
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
if
(
mBodySize
<
(
index
+
RDLENGTH
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
index
+
=
RDLENGTH
;
LOG
(
(
"
done
with
nsRecord
now
%
u
of
%
u
\
n
"
index
mBodySize
)
)
;
nsRecords
-
-
;
}
uint16_t
arRecords
=
get16bit
(
mResponse
10
)
;
LOG
(
(
"
TRR
Decode
:
%
d
additional
resource
records
(
%
u
bytes
body
)
\
n
"
arRecords
mBodySize
)
)
;
while
(
arRecords
)
{
nsAutoCString
qname
;
rv
=
GetQname
(
qname
index
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Bad
qname
for
additional
record
"
)
)
;
return
rv
;
}
if
(
mBodySize
<
(
index
+
8
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
type
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
uint16_t
cls
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
uint32_t
ttl
=
get32bit
(
mResponse
index
)
;
index
+
=
4
;
if
(
mBodySize
<
(
index
+
2
)
)
{
LOG
(
(
"
Record
too
small
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
uint16_t
rdlength
=
get16bit
(
mResponse
index
)
;
index
+
=
2
;
if
(
mBodySize
<
(
index
+
rdlength
)
)
{
LOG
(
(
"
rdlength
too
big
"
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
auto
parseRecord
=
[
&
]
(
)
{
LOG
(
(
"
Parsing
additional
record
type
:
%
u
"
type
)
)
;
auto
&
entry
=
aAdditionalRecords
.
GetOrInsert
(
qname
)
;
if
(
!
entry
)
{
entry
.
reset
(
new
DOHresp
(
)
)
;
}
switch
(
type
)
{
case
TRRTYPE_A
:
if
(
kDNS_CLASS_IN
!
=
cls
)
{
LOG
(
(
"
NOT
IN
-
returning
"
)
)
;
return
;
}
if
(
rdlength
!
=
4
)
{
LOG
(
(
"
TRR
bad
length
for
A
(
%
u
)
\
n
"
rdlength
)
)
;
return
;
}
rv
=
entry
-
>
Add
(
ttl
mResponse
index
rdlength
aAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
:
DohDecode
failed
:
local
IP
addresses
or
unknown
IP
"
"
family
\
n
"
)
)
;
return
;
}
break
;
case
TRRTYPE_AAAA
:
if
(
kDNS_CLASS_IN
!
=
cls
)
{
LOG
(
(
"
NOT
IN
-
returning
"
)
)
;
return
;
}
if
(
rdlength
!
=
16
)
{
LOG
(
(
"
TRR
bad
length
for
AAAA
(
%
u
)
\
n
"
rdlength
)
)
;
return
;
}
rv
=
entry
-
>
Add
(
ttl
mResponse
index
rdlength
aAllowRFC1918
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
TRR
got
unique
/
local
IPv6
address
!
\
n
"
)
)
;
return
;
}
break
;
case
TRRTYPE_OPT
:
{
LOG
(
(
"
Parsing
opt
rdlen
:
%
u
"
rdlength
)
)
;
unsigned
int
offset
=
0
;
while
(
offset
+
2
<
=
rdlength
)
{
uint16_t
optCode
=
get16bit
(
mResponse
index
+
offset
)
;
LOG
(
(
"
optCode
:
%
u
"
optCode
)
)
;
offset
+
=
2
;
if
(
offset
+
2
>
rdlength
)
{
break
;
}
uint16_t
optLen
=
get16bit
(
mResponse
index
+
offset
)
;
LOG
(
(
"
optLen
:
%
u
"
optLen
)
)
;
offset
+
=
2
;
if
(
offset
+
optLen
>
rdlength
)
{
LOG
(
(
"
offset
:
%
u
optLen
:
%
u
rdlen
:
%
u
"
offset
optLen
rdlength
)
)
;
break
;
}
LOG
(
(
"
OPT
:
code
:
%
u
len
:
%
u
"
optCode
optLen
)
)
;
if
(
optCode
!
=
15
)
{
offset
+
=
optLen
;
continue
;
}
if
(
offset
+
2
>
rdlength
|
|
optLen
<
2
)
{
break
;
}
extendedError
=
get16bit
(
mResponse
index
+
offset
)
;
LOG
(
(
"
Extended
error
code
:
%
u
message
:
%
s
"
extendedError
nsAutoCString
(
(
char
*
)
mResponse
+
index
+
offset
+
2
optLen
-
2
)
.
get
(
)
)
)
;
offset
+
=
optLen
;
}
break
;
}
default
:
break
;
}
}
;
parseRecord
(
)
;
index
+
=
rdlength
;
LOG
(
(
"
done
with
additional
rr
now
%
u
of
%
u
\
n
"
index
mBodySize
)
)
;
arRecords
-
-
;
}
if
(
index
!
=
mBodySize
)
{
LOG
(
(
"
DohDecode
failed
to
parse
entire
response
body
%
u
out
of
%
u
bytes
\
n
"
index
mBodySize
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
(
aType
!
=
TRRTYPE_NS
)
&
&
aCname
.
IsEmpty
(
)
&
&
aResp
.
mAddresses
.
IsEmpty
(
)
&
&
aTypeResult
.
is
<
TypeRecordEmpty
>
(
)
)
{
LOG
(
(
"
TRR
:
No
entries
were
stored
!
\
n
"
)
)
;
if
(
aReason
=
=
nsHostRecord
:
:
TRR_UNSET
)
{
aReason
=
nsHostRecord
:
:
TRR_NO_ANSWERS
;
}
if
(
extendedError
!
=
UINT16_MAX
&
&
hardFail
(
extendedError
)
)
{
return
NS_ERROR_DEFINITIVE_UNKNOWN_HOST
;
}
return
NS_ERROR_FAILURE
;
}
if
(
aTypeResult
.
is
<
TypeRecordHTTPSSVC
>
(
)
)
{
auto
&
results
=
aTypeResult
.
as
<
TypeRecordHTTPSSVC
>
(
)
;
results
.
Sort
(
)
;
}
return
NS_OK
;
}
}
}
