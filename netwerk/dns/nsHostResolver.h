#
ifndef
nsHostResolver_h__
#
define
nsHostResolver_h__
#
include
"
nscore
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIDNSListener
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
GetAddrInfo
.
h
"
#
include
"
HostRecordQueue
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
mozilla
/
net
/
DashboardTypes
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsHostRecord
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsIThreadPool
.
h
"
#
include
"
mozilla
/
net
/
NetworkConnectivityService
.
h
"
#
include
"
mozilla
/
net
/
DNSByTypeRecord
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
namespace
mozilla
{
namespace
net
{
class
TRR
;
class
TRRQuery
;
static
inline
uint32_t
MaxResolverThreadsAnyPriority
(
)
{
return
StaticPrefs
:
:
network_dns_max_any_priority_threads
(
)
;
}
static
inline
uint32_t
MaxResolverThreadsHighPriority
(
)
{
return
StaticPrefs
:
:
network_dns_max_high_priority_threads
(
)
;
}
static
inline
uint32_t
MaxResolverThreads
(
)
{
return
MaxResolverThreadsAnyPriority
(
)
+
MaxResolverThreadsHighPriority
(
)
;
}
}
}
#
define
TRR_DISABLED
(
x
)
\
(
(
(
x
)
=
=
nsIDNSService
:
:
MODE_NATIVEONLY
)
|
|
\
(
(
x
)
=
=
nsIDNSService
:
:
MODE_TRROFF
)
)
extern
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
gNativeIsLocalhost
;
#
define
MAX_NON_PRIORITY_REQUESTS
150
class
AHostResolver
{
public
:
AHostResolver
(
)
=
default
;
virtual
~
AHostResolver
(
)
=
default
;
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
enum
LookupStatus
{
LOOKUP_OK
LOOKUP_RESOLVEAGAIN
}
;
virtual
LookupStatus
CompleteLookup
(
nsHostRecord
*
nsresult
mozilla
:
:
net
:
:
AddrInfo
*
bool
pb
const
nsACString
&
aOriginsuffix
mozilla
:
:
net
:
:
TRRSkippedReason
aReason
mozilla
:
:
net
:
:
TRR
*
)
=
0
;
virtual
LookupStatus
CompleteLookupByType
(
nsHostRecord
*
nsresult
mozilla
:
:
net
:
:
TypeRecordResultType
&
aResult
mozilla
:
:
net
:
:
TRRSkippedReason
aReason
uint32_t
aTtl
bool
pb
)
=
0
;
virtual
nsresult
GetHostRecord
(
const
nsACString
&
host
const
nsACString
&
aTrrServer
uint16_t
type
nsIDNSService
:
:
DNSFlags
flags
uint16_t
af
bool
pb
const
nsCString
&
originSuffix
nsHostRecord
*
*
result
)
{
return
NS_ERROR_FAILURE
;
}
virtual
nsresult
TrrLookup_unlocked
(
nsHostRecord
*
mozilla
:
:
net
:
:
TRR
*
pushedTRR
=
nullptr
)
{
return
NS_ERROR_FAILURE
;
}
virtual
void
MaybeRenewHostRecord
(
nsHostRecord
*
aRec
)
{
}
}
;
class
nsHostResolver
:
public
nsISupports
public
AHostResolver
{
using
CondVar
=
mozilla
:
:
CondVar
;
using
Mutex
=
mozilla
:
:
Mutex
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
static
nsresult
Create
(
uint32_t
maxCacheEntries
uint32_t
defaultCacheEntryLifetime
uint32_t
defaultGracePeriod
nsHostResolver
*
*
result
)
;
void
SetCacheLimits
(
uint32_t
maxCacheEntries
uint32_t
defaultCacheEntryLifetime
uint32_t
defaultGracePeriod
)
;
void
Shutdown
(
)
;
nsresult
ResolveHost
(
const
nsACString
&
aHost
const
nsACString
&
trrServer
int32_t
aPort
uint16_t
type
const
mozilla
:
:
OriginAttributes
&
aOriginAttributes
nsIDNSService
:
:
DNSFlags
flags
uint16_t
af
nsResolveHostCallback
*
callback
)
;
nsHostRecord
*
InitRecord
(
const
nsHostKey
&
key
)
;
mozilla
:
:
net
:
:
NetworkConnectivityService
*
GetNCS
(
)
{
return
mNCS
;
}
already_AddRefed
<
nsHostRecord
>
InitLoopbackRecord
(
const
nsHostKey
&
key
nsresult
*
aRv
)
;
void
DetachCallback
(
const
nsACString
&
hostname
const
nsACString
&
trrServer
uint16_t
type
const
mozilla
:
:
OriginAttributes
&
aOriginAttributes
nsIDNSService
:
:
DNSFlags
flags
uint16_t
af
nsResolveHostCallback
*
callback
nsresult
status
)
;
void
CancelAsyncRequest
(
const
nsACString
&
host
const
nsACString
&
trrServer
uint16_t
type
const
mozilla
:
:
OriginAttributes
&
aOriginAttributes
nsIDNSService
:
:
DNSFlags
flags
uint16_t
af
nsIDNSListener
*
aListener
nsresult
status
)
;
enum
{
RES_BYPASS_CACHE
=
nsIDNSService
:
:
RESOLVE_BYPASS_CACHE
RES_CANON_NAME
=
nsIDNSService
:
:
RESOLVE_CANONICAL_NAME
RES_PRIORITY_MEDIUM
=
nsHostRecord
:
:
DNS_PRIORITY_MEDIUM
RES_PRIORITY_LOW
=
nsHostRecord
:
:
DNS_PRIORITY_LOW
RES_SPECULATE
=
nsIDNSService
:
:
RESOLVE_SPECULATE
RES_OFFLINE
=
nsIDNSService
:
:
RESOLVE_OFFLINE
RES_ALLOW_NAME_COLLISION
=
nsIDNSService
:
:
RESOLVE_ALLOW_NAME_COLLISION
RES_DISABLE_TRR
=
nsIDNSService
:
:
RESOLVE_DISABLE_TRR
RES_REFRESH_CACHE
=
nsIDNSService
:
:
RESOLVE_REFRESH_CACHE
RES_IP_HINT
=
nsIDNSService
:
:
RESOLVE_IP_HINT
}
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
void
FlushCache
(
bool
aTrrToo
)
;
LookupStatus
CompleteLookup
(
nsHostRecord
*
nsresult
mozilla
:
:
net
:
:
AddrInfo
*
bool
pb
const
nsACString
&
aOriginsuffix
mozilla
:
:
net
:
:
TRRSkippedReason
aReason
mozilla
:
:
net
:
:
TRR
*
aTRRRequest
)
override
;
LookupStatus
CompleteLookupByType
(
nsHostRecord
*
nsresult
mozilla
:
:
net
:
:
TypeRecordResultType
&
aResult
mozilla
:
:
net
:
:
TRRSkippedReason
aReason
uint32_t
aTtl
bool
pb
)
override
;
nsresult
GetHostRecord
(
const
nsACString
&
host
const
nsACString
&
trrServer
uint16_t
type
nsIDNSService
:
:
DNSFlags
flags
uint16_t
af
bool
pb
const
nsCString
&
originSuffix
nsHostRecord
*
*
result
)
override
;
nsresult
TrrLookup_unlocked
(
nsHostRecord
*
mozilla
:
:
net
:
:
TRR
*
pushedTRR
=
nullptr
)
override
;
static
nsIDNSService
:
:
ResolverMode
Mode
(
)
;
virtual
void
MaybeRenewHostRecord
(
nsHostRecord
*
aRec
)
override
;
bool
TRRServiceEnabledForRecord
(
nsHostRecord
*
aRec
)
MOZ_REQUIRES
(
mLock
)
;
private
:
explicit
nsHostResolver
(
uint32_t
maxCacheEntries
uint32_t
defaultCacheEntryLifetime
uint32_t
defaultGracePeriod
)
;
virtual
~
nsHostResolver
(
)
;
bool
DoRetryTRR
(
AddrHostRecord
*
aAddrRec
const
mozilla
:
:
MutexAutoLock
&
aLock
)
;
bool
MaybeRetryTRRLookup
(
AddrHostRecord
*
aAddrRec
nsresult
aFirstAttemptStatus
mozilla
:
:
net
:
:
TRRSkippedReason
aFirstAttemptSkipReason
nsresult
aChannelStatus
const
mozilla
:
:
MutexAutoLock
&
aLock
)
;
LookupStatus
CompleteLookupLocked
(
nsHostRecord
*
nsresult
mozilla
:
:
net
:
:
AddrInfo
*
bool
pb
const
nsACString
&
aOriginsuffix
mozilla
:
:
net
:
:
TRRSkippedReason
aReason
mozilla
:
:
net
:
:
TRR
*
aTRRRequest
const
mozilla
:
:
MutexAutoLock
&
aLock
)
MOZ_REQUIRES
(
mLock
)
;
LookupStatus
CompleteLookupByTypeLocked
(
nsHostRecord
*
nsresult
mozilla
:
:
net
:
:
TypeRecordResultType
&
aResult
mozilla
:
:
net
:
:
TRRSkippedReason
aReason
uint32_t
aTtl
bool
pb
const
mozilla
:
:
MutexAutoLock
&
aLock
)
MOZ_REQUIRES
(
mLock
)
;
nsresult
Init
(
)
;
static
void
ComputeEffectiveTRRMode
(
nsHostRecord
*
aRec
)
;
nsresult
NativeLookup
(
nsHostRecord
*
aRec
const
mozilla
:
:
MutexAutoLock
&
aLock
)
;
nsresult
TrrLookup
(
nsHostRecord
*
const
mozilla
:
:
MutexAutoLock
&
aLock
mozilla
:
:
net
:
:
TRR
*
pushedTRR
=
nullptr
)
;
nsresult
NameLookup
(
nsHostRecord
*
aRec
const
mozilla
:
:
MutexAutoLock
&
aLock
)
;
bool
GetHostToLookup
(
nsHostRecord
*
*
result
)
;
void
MaybeRenewHostRecordLocked
(
nsHostRecord
*
aRec
const
mozilla
:
:
MutexAutoLock
&
aLock
)
MOZ_REQUIRES
(
mLock
)
;
void
ClearPendingQueue
(
mozilla
:
:
LinkedList
<
RefPtr
<
nsHostRecord
>
>
&
aPendingQ
)
;
nsresult
ConditionallyCreateThread
(
nsHostRecord
*
rec
)
MOZ_REQUIRES
(
mLock
)
;
nsresult
ConditionallyRefreshRecord
(
nsHostRecord
*
rec
const
nsACString
&
host
const
mozilla
:
:
MutexAutoLock
&
aLock
)
MOZ_REQUIRES
(
mLock
)
;
void
OnResolveComplete
(
nsHostRecord
*
aRec
const
mozilla
:
:
MutexAutoLock
&
aLock
)
MOZ_REQUIRES
(
mLock
)
;
void
AddToEvictionQ
(
nsHostRecord
*
rec
const
mozilla
:
:
MutexAutoLock
&
aLock
)
MOZ_REQUIRES
(
mLock
)
;
void
ThreadFunc
(
)
;
already_AddRefed
<
nsHostRecord
>
FromCache
(
nsHostRecord
*
aRec
const
nsACString
&
aHost
uint16_t
aType
nsresult
&
aStatus
const
mozilla
:
:
MutexAutoLock
&
aLock
)
MOZ_REQUIRES
(
mLock
)
;
already_AddRefed
<
nsHostRecord
>
FromCachedIPLiteral
(
nsHostRecord
*
aRec
)
;
already_AddRefed
<
nsHostRecord
>
FromIPLiteral
(
AddrHostRecord
*
aAddrRec
const
mozilla
:
:
net
:
:
NetAddr
&
aAddr
)
;
already_AddRefed
<
nsHostRecord
>
FromUnspecEntry
(
nsHostRecord
*
aRec
const
nsACString
&
aHost
const
nsACString
&
aTrrServer
const
nsACString
&
aOriginSuffix
uint16_t
aType
nsIDNSService
:
:
DNSFlags
aFlags
uint16_t
af
bool
aPb
nsresult
&
aStatus
)
MOZ_REQUIRES
(
mLock
)
;
enum
{
METHOD_HIT
=
1
METHOD_RENEWAL
=
2
METHOD_NEGATIVE_HIT
=
3
METHOD_LITERAL
=
4
METHOD_OVERFLOW
=
5
METHOD_NETWORK_FIRST
=
6
METHOD_NETWORK_SHARED
=
7
}
;
uint32_t
mMaxCacheEntries
=
0
;
uint32_t
mDefaultCacheLifetime
=
0
;
uint32_t
mDefaultGracePeriod
=
0
;
mutable
Mutex
mLock
{
"
nsHostResolver
.
mLock
"
}
;
CondVar
mIdleTaskCV
;
nsRefPtrHashtable
<
nsGenericHashKey
<
nsHostKey
>
nsHostRecord
>
mRecordDB
MOZ_GUARDED_BY
(
mLock
)
;
PRTime
mCreationTime
;
mozilla
:
:
TimeDuration
mLongIdleTimeout
;
mozilla
:
:
TimeDuration
mShortIdleTimeout
;
RefPtr
<
nsIThreadPool
>
mResolverThreads
;
RefPtr
<
mozilla
:
:
net
:
:
NetworkConnectivityService
>
mNCS
;
mozilla
:
:
net
:
:
HostRecordQueue
mQueue
MOZ_GUARDED_BY
(
mLock
)
;
mozilla
:
:
Atomic
<
bool
>
mShutdown
MOZ_GUARDED_BY
(
mLock
)
{
true
}
;
mozilla
:
:
Atomic
<
uint32_t
>
mNumIdleTasks
MOZ_GUARDED_BY
(
mLock
)
{
0
}
;
mozilla
:
:
Atomic
<
uint32_t
>
mActiveTaskCount
MOZ_GUARDED_BY
(
mLock
)
{
0
}
;
mozilla
:
:
Atomic
<
uint32_t
>
mActiveAnyThreadCount
MOZ_GUARDED_BY
(
mLock
)
{
0
}
;
void
PrepareRecordExpirationAddrRecord
(
AddrHostRecord
*
rec
)
const
;
public
:
void
GetDNSCacheEntries
(
nsTArray
<
mozilla
:
:
net
:
:
DNSCacheEntries
>
*
)
;
}
;
#
endif
