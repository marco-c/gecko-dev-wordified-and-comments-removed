#
ifndef
mozilla_net_TRR_h
#
define
mozilla_net_TRR_h
#
include
"
mozilla
/
net
/
DNSByTypeRecord
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpPushListener
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsHostResolver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
namespace
net
{
enum
TrrType
{
TRRTYPE_A
=
1
TRRTYPE_NS
=
2
TRRTYPE_CNAME
=
5
TRRTYPE_AAAA
=
28
TRRTYPE_OPT
=
41
TRRTYPE_TXT
=
16
TRRTYPE_HTTPSSVC
=
nsIDNSService
:
:
RESOLVE_TYPE_HTTPSSVC
}
;
class
TRRService
;
class
TRRServiceChannel
;
extern
TRRService
*
gTRRService
;
class
DOHresp
{
public
:
nsresult
Add
(
uint32_t
TTL
unsigned
char
*
dns
unsigned
int
index
uint16_t
len
bool
aLocalAllowed
)
;
nsTArray
<
NetAddr
>
mAddresses
;
uint32_t
mTtl
=
UINT32_MAX
;
}
;
class
TRR
:
public
Runnable
public
nsITimerCallback
public
nsIHttpPushListener
public
nsIInterfaceRequestor
public
nsIStreamListener
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIHTTPPUSHLISTENER
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSITIMERCALLBACK
static
const
unsigned
int
kMaxSize
=
3200
;
static
const
unsigned
int
kCnameChaseMax
=
64
;
explicit
TRR
(
AHostResolver
*
aResolver
nsHostRecord
*
aRec
enum
TrrType
aType
)
:
mozilla
:
:
Runnable
(
"
TRR
"
)
mRec
(
aRec
)
mHostResolver
(
aResolver
)
mType
(
aType
)
mOriginSuffix
(
aRec
-
>
originSuffix
)
{
mHost
=
aRec
-
>
host
;
mPB
=
aRec
-
>
pb
;
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
"
TRR
must
be
in
parent
or
socket
process
"
)
;
}
explicit
TRR
(
AHostResolver
*
aResolver
nsHostRecord
*
aRec
nsCString
&
aHost
enum
TrrType
&
aType
unsigned
int
aLoopCount
bool
aPB
)
:
mozilla
:
:
Runnable
(
"
TRR
"
)
mHost
(
aHost
)
mRec
(
aRec
)
mHostResolver
(
aResolver
)
mType
(
aType
)
mPB
(
aPB
)
mCnameLoop
(
aLoopCount
)
mOriginSuffix
(
aRec
?
aRec
-
>
originSuffix
:
EmptyCString
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
"
TRR
must
be
in
parent
or
socket
process
"
)
;
}
explicit
TRR
(
AHostResolver
*
aResolver
bool
aPB
)
:
mozilla
:
:
Runnable
(
"
TRR
"
)
mHostResolver
(
aResolver
)
mType
(
TRRTYPE_A
)
mPB
(
aPB
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
"
TRR
must
be
in
parent
or
socket
process
"
)
;
}
explicit
TRR
(
AHostResolver
*
aResolver
nsACString
&
aHost
enum
TrrType
aType
const
nsACString
&
aOriginSuffix
bool
aPB
)
:
mozilla
:
:
Runnable
(
"
TRR
"
)
mHost
(
aHost
)
mRec
(
nullptr
)
mHostResolver
(
aResolver
)
mType
(
aType
)
mPB
(
aPB
)
mOriginSuffix
(
aOriginSuffix
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
"
TRR
must
be
in
parent
or
socket
process
"
)
;
}
NS_IMETHOD
Run
(
)
override
;
void
Cancel
(
)
;
enum
TrrType
Type
(
)
{
return
mType
;
}
nsCString
mHost
;
RefPtr
<
nsHostRecord
>
mRec
;
RefPtr
<
AHostResolver
>
mHostResolver
;
private
:
~
TRR
(
)
=
default
;
nsresult
SendHTTPRequest
(
)
;
nsresult
DohEncode
(
nsCString
&
aBody
bool
aDisableECS
)
;
nsresult
PassQName
(
unsigned
int
&
index
)
;
nsresult
GetQname
(
nsACString
&
aQname
unsigned
int
&
aIndex
)
;
nsresult
DohDecode
(
nsCString
&
aHost
)
;
nsresult
ReturnData
(
nsIChannel
*
aChannel
)
;
nsresult
FailData
(
nsresult
error
)
;
nsresult
DohDecodeQuery
(
const
nsCString
&
query
nsCString
&
host
enum
TrrType
&
type
)
;
nsresult
ReceivePush
(
nsIHttpChannel
*
pushed
nsHostRecord
*
pushedRec
)
;
nsresult
On200Response
(
nsIChannel
*
aChannel
)
;
nsresult
FollowCname
(
nsIChannel
*
aChannel
)
;
bool
UseDefaultServer
(
)
;
void
SaveAdditionalRecords
(
const
nsClassHashtable
<
nsCStringHashKey
DOHresp
>
&
aRecords
)
;
nsresult
CreateChannelHelper
(
nsIURI
*
aUri
nsIChannel
*
*
aResult
)
;
friend
class
TRRServiceChannel
;
static
nsresult
SetupTRRServiceChannelInternal
(
nsIHttpChannel
*
aChannel
bool
aUseGet
)
;
nsresult
ParseSvcParam
(
unsigned
int
svcbIndex
uint16_t
key
SvcFieldValue
&
field
uint16_t
length
)
;
void
StoreIPHintAsDNSRecord
(
const
struct
SVCB
&
aSVCBRecord
)
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
enum
TrrType
mType
;
unsigned
char
mResponse
[
kMaxSize
]
{
}
;
unsigned
int
mBodySize
=
0
;
bool
mFailed
=
false
;
bool
mPB
;
DOHresp
mDNS
;
nsCOMPtr
<
nsITimer
>
mTimeout
;
nsCString
mCname
;
uint32_t
mCnameLoop
=
kCnameChaseMax
;
bool
mAllowRFC1918
=
false
;
uint16_t
mExtendedError
=
UINT16_MAX
;
uint32_t
mTTL
=
UINT32_MAX
;
TypeRecordResultType
mResult
=
mozilla
:
:
AsVariant
(
Nothing
(
)
)
;
nsHostRecord
:
:
TRRSkippedReason
mTRRSkippedReason
=
nsHostRecord
:
:
TRR_UNSET
;
void
RecordReason
(
nsHostRecord
:
:
TRRSkippedReason
reason
)
{
if
(
mTRRSkippedReason
=
=
nsHostRecord
:
:
TRR_UNSET
)
{
mTRRSkippedReason
=
reason
;
}
}
const
nsCString
mOriginSuffix
;
}
;
}
}
#
endif
