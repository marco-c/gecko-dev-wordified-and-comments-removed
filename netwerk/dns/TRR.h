#
ifndef
mozilla_net_TRR_h
#
define
mozilla_net_TRR_h
#
include
"
mozilla
/
net
/
DNSByTypeRecord
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpPushListener
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsHostResolver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
DNSPacket
.
h
"
namespace
mozilla
{
namespace
net
{
class
TRRService
;
class
TRRServiceChannel
;
extern
TRRService
*
gTRRService
;
class
TRR
:
public
Runnable
public
nsITimerCallback
public
nsIHttpPushListener
public
nsIInterfaceRequestor
public
nsIStreamListener
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIHTTPPUSHLISTENER
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSITIMERCALLBACK
static
const
unsigned
int
kCnameChaseMax
=
64
;
explicit
TRR
(
AHostResolver
*
aResolver
nsHostRecord
*
aRec
enum
TrrType
aType
)
:
mozilla
:
:
Runnable
(
"
TRR
"
)
mRec
(
aRec
)
mHostResolver
(
aResolver
)
mType
(
aType
)
mOriginSuffix
(
aRec
-
>
originSuffix
)
{
mHost
=
aRec
-
>
host
;
mPB
=
aRec
-
>
pb
;
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
"
TRR
must
be
in
parent
or
socket
process
"
)
;
}
explicit
TRR
(
AHostResolver
*
aResolver
nsHostRecord
*
aRec
nsCString
&
aHost
enum
TrrType
&
aType
unsigned
int
aLoopCount
bool
aPB
)
:
mozilla
:
:
Runnable
(
"
TRR
"
)
mHost
(
aHost
)
mRec
(
aRec
)
mHostResolver
(
aResolver
)
mType
(
aType
)
mPB
(
aPB
)
mCnameLoop
(
aLoopCount
)
mOriginSuffix
(
aRec
?
aRec
-
>
originSuffix
:
"
"
_ns
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
"
TRR
must
be
in
parent
or
socket
process
"
)
;
}
explicit
TRR
(
AHostResolver
*
aResolver
bool
aPB
)
:
mozilla
:
:
Runnable
(
"
TRR
"
)
mHostResolver
(
aResolver
)
mType
(
TRRTYPE_A
)
mPB
(
aPB
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
"
TRR
must
be
in
parent
or
socket
process
"
)
;
}
explicit
TRR
(
AHostResolver
*
aResolver
nsACString
&
aHost
enum
TrrType
aType
const
nsACString
&
aOriginSuffix
bool
aPB
)
:
mozilla
:
:
Runnable
(
"
TRR
"
)
mHost
(
aHost
)
mRec
(
nullptr
)
mHostResolver
(
aResolver
)
mType
(
aType
)
mPB
(
aPB
)
mOriginSuffix
(
aOriginSuffix
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
"
TRR
must
be
in
parent
or
socket
process
"
)
;
}
NS_IMETHOD
Run
(
)
override
;
void
Cancel
(
nsresult
aStatus
)
;
enum
TrrType
Type
(
)
{
return
mType
;
}
nsCString
mHost
;
RefPtr
<
nsHostRecord
>
mRec
;
RefPtr
<
AHostResolver
>
mHostResolver
;
void
SetTimeout
(
uint32_t
aTimeoutMs
)
{
mTimeoutMs
=
aTimeoutMs
;
}
nsresult
ChannelStatus
(
)
{
return
mChannelStatus
;
}
protected
:
virtual
~
TRR
(
)
=
default
;
virtual
DNSPacket
*
GetOrCreateDNSPacket
(
)
;
virtual
nsresult
CreateQueryURI
(
nsIURI
*
*
aOutURI
)
;
virtual
const
char
*
ContentType
(
)
const
{
return
"
application
/
dns
-
message
"
;
}
virtual
DNSResolverType
ResolverType
(
)
const
{
return
DNSResolverType
:
:
TRR
;
}
virtual
bool
MaybeBlockRequest
(
)
;
virtual
void
RecordProcessingTime
(
nsIChannel
*
aChannel
)
;
virtual
void
ReportStatus
(
nsresult
aStatusCode
)
;
virtual
void
HandleTimeout
(
)
;
virtual
void
HandleEncodeError
(
nsresult
aStatusCode
)
{
}
virtual
void
HandleDecodeError
(
nsresult
aStatusCode
)
;
nsresult
SendHTTPRequest
(
)
;
nsresult
ReturnData
(
nsIChannel
*
aChannel
)
;
nsresult
FailData
(
nsresult
error
)
;
static
nsresult
DohDecodeQuery
(
const
nsCString
&
query
nsCString
&
host
enum
TrrType
&
type
)
;
nsresult
ReceivePush
(
nsIHttpChannel
*
pushed
nsHostRecord
*
pushedRec
)
;
nsresult
On200Response
(
nsIChannel
*
aChannel
)
;
nsresult
FollowCname
(
nsIChannel
*
aChannel
)
;
bool
UseDefaultServer
(
)
;
void
SaveAdditionalRecords
(
const
nsClassHashtable
<
nsCStringHashKey
DOHresp
>
&
aRecords
)
;
nsresult
CreateChannelHelper
(
nsIURI
*
aUri
nsIChannel
*
*
aResult
)
;
friend
class
TRRServiceChannel
;
static
nsresult
SetupTRRServiceChannelInternal
(
nsIHttpChannel
*
aChannel
bool
aUseGet
const
nsACString
&
aContentType
)
;
void
StoreIPHintAsDNSRecord
(
const
struct
SVCB
&
aSVCBRecord
)
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
enum
TrrType
mType
;
UniquePtr
<
DNSPacket
>
mPacket
;
bool
mFailed
=
false
;
bool
mPB
;
DOHresp
mDNS
;
nsresult
mChannelStatus
=
NS_OK
;
uint32_t
mTimeoutMs
=
0
;
nsCOMPtr
<
nsITimer
>
mTimeout
;
nsCString
mCname
;
uint32_t
mCnameLoop
=
kCnameChaseMax
;
uint32_t
mTTL
=
UINT32_MAX
;
TypeRecordResultType
mResult
=
mozilla
:
:
AsVariant
(
Nothing
(
)
)
;
nsHostRecord
:
:
TRRSkippedReason
mTRRSkippedReason
=
nsHostRecord
:
:
TRR_UNSET
;
void
RecordReason
(
nsHostRecord
:
:
TRRSkippedReason
reason
)
{
if
(
mTRRSkippedReason
=
=
nsHostRecord
:
:
TRR_UNSET
)
{
mTRRSkippedReason
=
reason
;
}
}
const
nsCString
mOriginSuffix
;
}
;
}
}
#
endif
