#
ifndef
mozilla_net_TRR_h
#
define
mozilla_net_TRR_h
#
include
"
mozilla
/
net
/
DNSByTypeRecord
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpPushListener
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
DNSPacket
.
h
"
#
include
"
TRRSkippedReason
.
h
"
class
AHostResolver
;
class
nsHostRecord
;
namespace
mozilla
{
namespace
net
{
class
TRRService
;
class
TRRServiceChannel
;
class
TRR
:
public
Runnable
public
nsITimerCallback
public
nsIHttpPushListener
public
nsIInterfaceRequestor
public
nsIStreamListener
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIHTTPPUSHLISTENER
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSITIMERCALLBACK
static
const
unsigned
int
kCnameChaseMax
=
64
;
explicit
TRR
(
AHostResolver
*
aResolver
nsHostRecord
*
aRec
enum
TrrType
aType
)
;
explicit
TRR
(
AHostResolver
*
aResolver
nsHostRecord
*
aRec
nsCString
&
aHost
enum
TrrType
&
aType
unsigned
int
aLoopCount
bool
aPB
)
;
explicit
TRR
(
AHostResolver
*
aResolver
bool
aPB
)
;
explicit
TRR
(
AHostResolver
*
aResolver
nsACString
&
aHost
enum
TrrType
aType
const
nsACString
&
aOriginSuffix
bool
aPB
bool
aUseFreshConnection
)
;
NS_IMETHOD
Run
(
)
override
;
void
Cancel
(
nsresult
aStatus
)
;
enum
TrrType
Type
(
)
{
return
mType
;
}
nsCString
mHost
;
RefPtr
<
nsHostRecord
>
mRec
;
RefPtr
<
AHostResolver
>
mHostResolver
;
void
SetTimeout
(
uint32_t
aTimeoutMs
)
{
mTimeoutMs
=
aTimeoutMs
;
}
nsresult
ChannelStatus
(
)
{
return
mChannelStatus
;
}
enum
RequestPurpose
{
Resolve
Confirmation
Blocklist
}
;
RequestPurpose
Purpose
(
)
{
return
mPurpose
;
}
void
SetPurpose
(
RequestPurpose
aPurpose
)
{
mPurpose
=
aPurpose
;
}
protected
:
virtual
~
TRR
(
)
=
default
;
virtual
DNSPacket
*
GetOrCreateDNSPacket
(
)
;
virtual
nsresult
CreateQueryURI
(
nsIURI
*
*
aOutURI
)
;
virtual
const
char
*
ContentType
(
)
const
{
return
"
application
/
dns
-
message
"
;
}
virtual
DNSResolverType
ResolverType
(
)
const
{
return
DNSResolverType
:
:
TRR
;
}
virtual
bool
MaybeBlockRequest
(
)
;
virtual
void
RecordProcessingTime
(
nsIChannel
*
aChannel
)
;
virtual
void
ReportStatus
(
nsresult
aStatusCode
)
;
virtual
void
HandleTimeout
(
)
;
virtual
void
HandleEncodeError
(
nsresult
aStatusCode
)
{
}
virtual
void
HandleDecodeError
(
nsresult
aStatusCode
)
;
nsresult
SendHTTPRequest
(
)
;
nsresult
ReturnData
(
nsIChannel
*
aChannel
)
;
nsresult
FailData
(
nsresult
error
)
;
static
nsresult
DohDecodeQuery
(
const
nsCString
&
query
nsCString
&
host
enum
TrrType
&
type
)
;
nsresult
ReceivePush
(
nsIHttpChannel
*
pushed
nsHostRecord
*
pushedRec
)
;
nsresult
On200Response
(
nsIChannel
*
aChannel
)
;
nsresult
FollowCname
(
nsIChannel
*
aChannel
)
;
bool
HasUsableResponse
(
)
;
bool
UseDefaultServer
(
)
;
void
SaveAdditionalRecords
(
const
nsClassHashtable
<
nsCStringHashKey
DOHresp
>
&
aRecords
)
;
friend
class
TRRServiceChannel
;
static
nsresult
SetupTRRServiceChannelInternal
(
nsIHttpChannel
*
aChannel
bool
aUseGet
const
nsACString
&
aContentType
)
;
void
StoreIPHintAsDNSRecord
(
const
struct
SVCB
&
aSVCBRecord
)
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
enum
TrrType
mType
{
TRRTYPE_A
}
;
UniquePtr
<
DNSPacket
>
mPacket
;
bool
mFailed
=
false
;
bool
mPB
=
false
;
DOHresp
mDNS
;
nsresult
mChannelStatus
=
NS_OK
;
RequestPurpose
mPurpose
=
Resolve
;
Atomic
<
bool
Relaxed
>
mCancelled
{
false
}
;
uint32_t
mTimeoutMs
=
0
;
nsCOMPtr
<
nsITimer
>
mTimeout
;
nsCString
mCname
;
uint32_t
mCnameLoop
=
kCnameChaseMax
;
uint32_t
mTTL
=
UINT32_MAX
;
TypeRecordResultType
mResult
=
mozilla
:
:
AsVariant
(
Nothing
(
)
)
;
TRRSkippedReason
mTRRSkippedReason
=
TRRSkippedReason
:
:
TRR_UNSET
;
void
RecordReason
(
TRRSkippedReason
reason
)
{
if
(
mTRRSkippedReason
=
=
TRRSkippedReason
:
:
TRR_UNSET
)
{
mTRRSkippedReason
=
reason
;
}
}
const
nsCString
mOriginSuffix
;
bool
mUseFreshConnection
=
false
;
}
;
}
}
#
endif
