#
include
"
HostRecordQueue
.
h
"
#
include
"
mozilla
/
glean
/
NetwerkDnsMetrics
.
h
"
#
include
"
nsQueryObject
.
h
"
namespace
mozilla
{
namespace
net
{
void
HostRecordQueue
:
:
InsertRecord
(
nsHostRecord
*
aRec
nsIDNSService
:
:
DNSFlags
aFlags
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
aRec
-
>
isInList
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mEvictionQ
.
contains
(
aRec
)
"
Already
in
eviction
queue
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mHighQ
.
contains
(
aRec
)
"
Already
in
high
queue
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mMediumQ
.
contains
(
aRec
)
"
Already
in
med
queue
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mLowQ
.
contains
(
aRec
)
"
Already
in
low
queue
"
)
;
MOZ_DIAGNOSTIC_CRASH
(
"
Already
on
some
other
queue
?
"
)
;
}
switch
(
AddrHostRecord
:
:
GetPriority
(
aFlags
)
)
{
case
AddrHostRecord
:
:
DNS_PRIORITY_HIGH
:
mHighQ
.
insertBack
(
aRec
)
;
break
;
case
AddrHostRecord
:
:
DNS_PRIORITY_MEDIUM
:
mMediumQ
.
insertBack
(
aRec
)
;
break
;
case
AddrHostRecord
:
:
DNS_PRIORITY_LOW
:
mLowQ
.
insertBack
(
aRec
)
;
break
;
}
mPendingCount
+
+
;
}
void
HostRecordQueue
:
:
MaybeAddToEvictionQ
(
nsHostRecord
*
aRec
uint32_t
aMaxCacheEntries
nsRefPtrHashtable
<
nsGenericHashKey
<
nsHostKey
>
nsHostRecord
>
&
aDB
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
aRec
-
>
isInList
(
)
)
{
return
;
}
AddToEvictionQ
(
aRec
aMaxCacheEntries
aDB
aProofOfLock
true
)
;
}
void
HostRecordQueue
:
:
AddToEvictionQ
(
nsHostRecord
*
aRec
uint32_t
aMaxCacheEntries
nsRefPtrHashtable
<
nsGenericHashKey
<
nsHostKey
>
nsHostRecord
>
&
aDB
const
MutexAutoLock
&
aProofOfLock
bool
aSkipCheck
)
{
if
(
aRec
-
>
isInList
(
)
&
&
!
aSkipCheck
)
{
bool
inEvictionQ
=
mEvictionQ
.
contains
(
aRec
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
inEvictionQ
"
Already
in
eviction
queue
"
)
;
bool
inHighQ
=
mHighQ
.
contains
(
aRec
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
inHighQ
"
Already
in
high
queue
"
)
;
bool
inMediumQ
=
mMediumQ
.
contains
(
aRec
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
inMediumQ
"
Already
in
med
queue
"
)
;
bool
inLowQ
=
mLowQ
.
contains
(
aRec
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
inLowQ
"
Already
in
low
queue
"
)
;
MOZ_DIAGNOSTIC_CRASH
(
"
Already
on
some
other
queue
?
"
)
;
aRec
-
>
remove
(
)
;
if
(
inEvictionQ
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mEvictionQSize
>
0
)
;
mEvictionQSize
-
-
;
}
else
if
(
inHighQ
|
|
inMediumQ
|
|
inLowQ
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPendingCount
>
0
)
;
mPendingCount
-
-
;
}
}
mEvictionQ
.
insertBack
(
aRec
)
;
if
(
mEvictionQSize
<
aMaxCacheEntries
)
{
mEvictionQSize
+
+
;
}
else
{
RefPtr
<
nsHostRecord
>
head
=
mEvictionQ
.
popFirst
(
)
;
aDB
.
Remove
(
*
static_cast
<
nsHostKey
*
>
(
head
.
get
(
)
)
)
;
if
(
!
head
-
>
negative
)
{
TimeDuration
age
=
TimeStamp
:
:
NowLoRes
(
)
-
head
-
>
mValidStart
;
if
(
aRec
-
>
IsAddrRecord
(
)
)
{
glean
:
:
dns
:
:
cleanup_age
.
AccumulateRawDuration
(
age
)
;
}
else
{
glean
:
:
dns
:
:
by_type_cleanup_age
.
AccumulateRawDuration
(
age
)
;
}
if
(
head
-
>
CheckExpiration
(
TimeStamp
:
:
Now
(
)
)
!
=
nsHostRecord
:
:
EXP_EXPIRED
)
{
if
(
aRec
-
>
IsAddrRecord
(
)
)
{
glean
:
:
dns
:
:
premature_eviction
.
AccumulateRawDuration
(
age
)
;
}
else
{
glean
:
:
dns
:
:
by_type_premature_eviction
.
AccumulateRawDuration
(
age
)
;
}
}
}
}
}
void
HostRecordQueue
:
:
MoveToEvictionQueueTail
(
nsHostRecord
*
aRec
const
MutexAutoLock
&
aProofOfLock
)
{
bool
inEvictionQ
=
mEvictionQ
.
contains
(
aRec
)
;
if
(
!
inEvictionQ
)
{
return
;
}
aRec
-
>
remove
(
)
;
mEvictionQ
.
insertBack
(
aRec
)
;
}
void
HostRecordQueue
:
:
MaybeRenewHostRecord
(
nsHostRecord
*
aRec
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
!
aRec
-
>
isInList
(
)
)
{
return
;
}
bool
inEvictionQ
=
mEvictionQ
.
contains
(
aRec
)
;
MOZ_DIAGNOSTIC_ASSERT
(
inEvictionQ
"
Should
be
in
eviction
queue
"
)
;
bool
inHighQ
=
mHighQ
.
contains
(
aRec
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
inHighQ
"
Already
in
high
queue
"
)
;
bool
inMediumQ
=
mMediumQ
.
contains
(
aRec
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
inMediumQ
"
Already
in
med
queue
"
)
;
bool
inLowQ
=
mLowQ
.
contains
(
aRec
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
inLowQ
"
Already
in
low
queue
"
)
;
aRec
-
>
remove
(
)
;
if
(
inEvictionQ
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mEvictionQSize
>
0
)
;
mEvictionQSize
-
-
;
}
else
if
(
inHighQ
|
|
inMediumQ
|
|
inLowQ
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPendingCount
>
0
)
;
mPendingCount
-
-
;
}
}
void
HostRecordQueue
:
:
FlushEvictionQ
(
nsRefPtrHashtable
<
nsGenericHashKey
<
nsHostKey
>
nsHostRecord
>
&
aDB
const
MutexAutoLock
&
aProofOfLock
)
{
mEvictionQSize
=
0
;
if
(
!
mEvictionQ
.
isEmpty
(
)
)
{
for
(
const
RefPtr
<
nsHostRecord
>
&
rec
:
mEvictionQ
)
{
rec
-
>
Cancel
(
)
;
aDB
.
Remove
(
*
static_cast
<
nsHostKey
*
>
(
rec
)
)
;
}
mEvictionQ
.
clear
(
)
;
}
}
void
HostRecordQueue
:
:
MaybeRemoveFromQ
(
nsHostRecord
*
aRec
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
!
aRec
-
>
isInList
(
)
)
{
return
;
}
if
(
mHighQ
.
contains
(
aRec
)
|
|
mMediumQ
.
contains
(
aRec
)
|
|
mLowQ
.
contains
(
aRec
)
)
{
mPendingCount
-
-
;
}
else
if
(
mEvictionQ
.
contains
(
aRec
)
)
{
mEvictionQSize
-
-
;
}
else
{
MOZ_ASSERT
(
false
"
record
is
in
other
queue
"
)
;
}
aRec
-
>
remove
(
)
;
}
void
HostRecordQueue
:
:
MoveToAnotherPendingQ
(
nsHostRecord
*
aRec
nsIDNSService
:
:
DNSFlags
aFlags
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
!
(
mHighQ
.
contains
(
aRec
)
|
|
mMediumQ
.
contains
(
aRec
)
|
|
mLowQ
.
contains
(
aRec
)
)
)
{
MOZ_ASSERT
(
false
"
record
is
not
in
the
pending
queue
"
)
;
return
;
}
aRec
-
>
remove
(
)
;
mPendingCount
-
-
;
InsertRecord
(
aRec
aFlags
aProofOfLock
)
;
}
already_AddRefed
<
nsHostRecord
>
HostRecordQueue
:
:
Dequeue
(
bool
aHighQOnly
const
MutexAutoLock
&
aProofOfLock
)
{
RefPtr
<
nsHostRecord
>
rec
;
if
(
!
mHighQ
.
isEmpty
(
)
)
{
rec
=
mHighQ
.
popFirst
(
)
;
}
else
if
(
!
mMediumQ
.
isEmpty
(
)
&
&
!
aHighQOnly
)
{
rec
=
mMediumQ
.
popFirst
(
)
;
}
else
if
(
!
mLowQ
.
isEmpty
(
)
&
&
!
aHighQOnly
)
{
rec
=
mLowQ
.
popFirst
(
)
;
}
if
(
rec
)
{
mPendingCount
-
-
;
}
return
rec
.
forget
(
)
;
}
void
HostRecordQueue
:
:
ClearAll
(
const
std
:
:
function
<
void
(
nsHostRecord
*
)
>
&
aCallback
const
MutexAutoLock
&
aProofOfLock
)
{
mPendingCount
=
0
;
auto
clearPendingQ
=
[
&
]
(
LinkedList
<
RefPtr
<
nsHostRecord
>
>
&
aPendingQ
)
{
if
(
aPendingQ
.
isEmpty
(
)
)
{
return
;
}
for
(
const
RefPtr
<
nsHostRecord
>
&
rec
:
aPendingQ
)
{
rec
-
>
Cancel
(
)
;
aCallback
(
rec
)
;
}
aPendingQ
.
clear
(
)
;
}
;
clearPendingQ
(
mHighQ
)
;
clearPendingQ
(
mMediumQ
)
;
clearPendingQ
(
mLowQ
)
;
mEvictionQSize
=
0
;
if
(
!
mEvictionQ
.
isEmpty
(
)
)
{
for
(
const
RefPtr
<
nsHostRecord
>
&
rec
:
mEvictionQ
)
{
rec
-
>
Cancel
(
)
;
}
}
mEvictionQ
.
clear
(
)
;
}
}
}
