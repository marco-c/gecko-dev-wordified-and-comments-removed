#
ifndef
__nsmultimixedconv__h__
#
define
__nsmultimixedconv__h__
#
include
"
nsIStreamConverter
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIByteRangeRequest
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsIMultiPartChannel
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
IncrementalTokenizer
.
h
"
#
include
"
nsHttpResponseHead
.
h
"
#
define
NS_MULTIMIXEDCONVERTER_CID
\
{
/
*
7584CE90
-
5B25
-
11d3
-
A175
-
0050041CAF44
*
/
\
0x7584ce90
\
0x5b25
\
0x11d3
\
{
0xa1
0x75
0x0
0x50
0x4
0x1c
0xaf
0x44
}
\
}
class
nsPartChannel
final
:
public
nsIChannel
public
nsIByteRangeRequest
public
nsIMultiPartChannel
{
public
:
nsPartChannel
(
nsIChannel
*
aMultipartChannel
uint32_t
aPartID
nsIStreamListener
*
aListener
)
;
void
InitializeByteRange
(
int64_t
aStart
int64_t
aEnd
)
;
void
SetIsLastPart
(
)
{
mIsLastPart
=
true
;
}
nsresult
SendOnStartRequest
(
nsISupports
*
aContext
)
;
nsresult
SendOnDataAvailable
(
nsISupports
*
aContext
nsIInputStream
*
aStream
uint64_t
aOffset
uint32_t
aLen
)
;
nsresult
SendOnStopRequest
(
nsISupports
*
aContext
nsresult
aStatus
)
;
void
SetContentDisposition
(
const
nsACString
&
aContentDispositionHeader
)
;
void
SetResponseHead
(
mozilla
:
:
net
:
:
nsHttpResponseHead
*
head
)
{
mResponseHead
=
head
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUEST
NS_DECL_NSICHANNEL
NS_DECL_NSIBYTERANGEREQUEST
NS_DECL_NSIMULTIPARTCHANNEL
protected
:
~
nsPartChannel
(
)
;
protected
:
nsCOMPtr
<
nsIChannel
>
mMultipartChannel
;
nsCOMPtr
<
nsIStreamListener
>
mListener
;
nsAutoPtr
<
mozilla
:
:
net
:
:
nsHttpResponseHead
>
mResponseHead
;
nsresult
mStatus
;
nsLoadFlags
mLoadFlags
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
nsCString
mContentType
;
nsCString
mContentCharset
;
uint32_t
mContentDisposition
;
nsString
mContentDispositionFilename
;
nsCString
mContentDispositionHeader
;
uint64_t
mContentLength
;
bool
mIsByteRangeRequest
;
int64_t
mByteRangeStart
;
int64_t
mByteRangeEnd
;
uint32_t
mPartID
;
bool
mIsLastPart
;
}
;
class
nsMultiMixedConv
:
public
nsIStreamConverter
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMCONVERTER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
explicit
nsMultiMixedConv
(
)
;
protected
:
typedef
mozilla
:
:
IncrementalTokenizer
:
:
Token
Token
;
virtual
~
nsMultiMixedConv
(
)
;
nsresult
SendStart
(
)
;
void
AccumulateData
(
Token
const
&
aToken
)
;
nsresult
SendData
(
)
;
nsresult
SendStop
(
nsresult
aStatus
)
;
nsCOMPtr
<
nsIStreamListener
>
mFinalListener
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
RefPtr
<
nsPartChannel
>
mPartChannel
;
nsCOMPtr
<
nsISupports
>
mContext
;
nsCString
mContentType
;
nsCString
mContentDisposition
;
uint64_t
mContentLength
;
uint64_t
mTotalSent
;
int64_t
mByteRangeStart
;
int64_t
mByteRangeEnd
;
bool
mIsByteRangeRequest
;
bool
mRequestListenerNotified
;
uint32_t
mCurrentPartID
;
bool
mInOnDataAvailable
;
enum
EParserState
{
PREAMBLE
BOUNDARY_CRLF
HEADER_NAME
HEADER_SEP
HEADER_VALUE
BODY_INIT
BODY
TRAIL_DASH1
TRAIL_DASH2
EPILOGUE
INIT
=
PREAMBLE
}
mParserState
;
enum
EHeader
:
uint32_t
{
HEADER_FIRST
HEADER_CONTENT_TYPE
=
HEADER_FIRST
HEADER_CONTENT_LENGTH
HEADER_CONTENT_DISPOSITION
HEADER_SET_COOKIE
HEADER_CONTENT_RANGE
HEADER_RANGE
HEADER_UNKNOWN
}
mResponseHeader
;
nsCString
mResponseHeaderValue
;
nsCString
mBoundary
;
mozilla
:
:
IncrementalTokenizer
mTokenizer
;
nsACString
:
:
const_char_iterator
mRawData
;
nsACString
:
:
size_type
mRawDataLength
;
Token
mBoundaryToken
;
Token
mBoundaryTokenWithDashes
;
Token
mLFToken
;
Token
mCRLFToken
;
Token
mHeaderTokens
[
HEADER_UNKNOWN
]
;
void
HeadersToDefault
(
)
;
nsresult
ProcessHeader
(
)
;
void
SwitchToBodyParsing
(
)
;
void
SwitchToControlParsing
(
)
;
void
SetHeaderTokensEnabled
(
bool
aEnable
)
;
nsresult
ConsumeToken
(
Token
const
&
token
)
;
}
;
#
endif
