async
function
captureNetworkRequest
(
commands
)
{
var
capture_network_request
=
[
]
;
var
capture_resource
=
await
commands
.
js
.
run
(
return
performance
.
getEntriesByType
(
"
resource
"
)
;
)
;
for
(
var
i
=
0
;
i
<
capture_resource
.
length
;
i
+
+
)
{
capture_network_request
.
push
(
capture_resource
[
i
]
.
name
)
;
}
return
capture_network_request
;
}
async
function
waitForScrollRequestsEnd
(
prevCount
maxStableCount
timeout
commands
context
)
{
let
starttime
=
await
commands
.
js
.
run
(
return
performance
.
now
(
)
;
)
;
let
endtime
=
await
commands
.
js
.
run
(
return
performance
.
now
(
)
;
)
;
let
changing
=
true
;
let
newCount
=
-
1
;
let
stableCount
=
0
;
while
(
(
(
await
commands
.
js
.
run
(
return
performance
.
now
(
)
;
)
)
-
starttime
<
timeout
)
&
changing
)
{
await
commands
.
wait
.
byTime
(
100
)
;
newCount
=
(
await
captureNetworkRequest
(
commands
)
)
.
length
;
context
.
log
.
debug
(
{
newCount
}
{
prevCount
}
{
stableCount
}
)
;
if
(
newCount
=
=
prevCount
)
{
if
(
stableCount
=
=
0
)
{
endtime
=
await
commands
.
js
.
run
(
return
performance
.
now
(
)
;
)
;
}
stableCount
+
+
;
}
else
{
prevCount
=
newCount
;
stableCount
=
0
;
}
if
(
stableCount
>
=
maxStableCount
)
{
changing
=
false
;
}
}
return
{
start
:
starttime
end
:
endtime
numResources
:
newCount
}
;
}
async
function
test
(
context
commands
)
{
let
rootUrl
=
"
https
:
/
/
www
.
facebook
.
com
/
lambofgod
/
"
;
let
waitTime
=
1000
;
let
numScrolls
=
5
;
const
average
=
arr
=
>
arr
.
reduce
(
(
p
c
)
=
>
p
+
c
0
)
/
arr
.
length
;
if
(
typeof
context
.
options
.
browsertime
!
=
=
"
undefined
"
)
{
if
(
typeof
context
.
options
.
browsertime
.
waitTime
!
=
=
"
undefined
"
)
{
waitTime
=
context
.
options
.
browsertime
.
waitTime
;
}
if
(
typeof
context
.
options
.
browsertime
.
numScrolls
!
=
=
"
undefined
"
)
{
numScrolls
=
context
.
options
.
browsertime
.
numScrolls
;
}
}
await
commands
.
navigate
(
rootUrl
)
;
let
cycles
=
1
;
for
(
let
cycle
=
0
;
cycle
<
cycles
;
cycle
+
+
)
{
await
commands
.
measure
.
start
(
"
pageload
"
)
;
await
commands
.
navigate
(
rootUrl
)
;
await
commands
.
measure
.
stop
(
)
;
await
commands
.
js
.
runAndWait
(
window
.
scrollTo
(
{
top
:
1000
behavior
:
'
smooth
'
}
)
)
;
await
commands
.
wait
.
byTime
(
1000
)
;
await
commands
.
click
.
byLinkTextAndWait
(
"
Not
Now
"
)
;
let
vals
=
[
]
;
let
badIterations
=
0
;
for
(
let
iteration
=
0
;
iteration
<
numScrolls
;
iteration
+
+
)
{
await
commands
.
js
.
run
(
performance
.
clearResourceTimings
(
)
;
)
;
let
currCount
=
(
await
captureNetworkRequest
(
commands
)
)
.
length
;
commands
.
js
.
runAndWait
(
window
.
scrollTo
(
{
top
:
100000000
}
)
)
;
let
newInfo
=
await
waitForScrollRequestsEnd
(
currCount
22
120000
commands
context
)
;
let
ndiff
=
newInfo
.
numResources
-
currCount
;
let
tdiff
=
(
newInfo
.
end
-
newInfo
.
start
)
/
1000
;
if
(
ndiff
=
=
0
)
{
context
.
log
.
info
(
"
Bad
iteration
redoing
.
.
.
"
)
;
iteration
-
-
;
badIterations
+
+
;
if
(
badIterations
=
=
5
)
{
throw
new
Error
(
"
Too
many
bad
scroll
iterations
occurred
"
)
;
}
continue
;
}
vals
.
push
(
ndiff
/
tdiff
)
;
await
commands
.
wait
.
byTime
(
waitTime
)
;
}
if
(
vals
.
length
=
=
0
)
{
throw
new
Error
(
"
No
requestsPerSecond
values
were
obtained
"
)
;
}
commands
.
measure
.
result
[
0
]
.
browserScripts
.
pageinfo
.
requestsPerSecond
=
average
(
vals
)
;
}
}
module
.
exports
=
{
test
owner
:
"
Network
Team
"
component
:
"
netwerk
"
name
:
"
facebook
-
scroll
"
description
:
"
Measures
the
number
of
requests
per
second
after
a
scroll
.
"
}
;
