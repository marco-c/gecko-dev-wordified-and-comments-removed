"
use
strict
"
;
const
{
sinon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
)
;
const
{
setTimeout
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
)
;
class
MockChannel
{
#
uri
=
null
;
constructor
(
uriString
)
{
let
uri
=
Services
.
io
.
newURI
(
uriString
)
;
this
.
#
uri
=
uri
;
this
.
originalURI
=
uri
;
}
contentType
=
"
application
/
x
-
mock
-
channel
-
content
"
;
loadAttributes
=
null
;
contentLength
=
0
;
owner
=
null
;
notificationCallbacks
=
null
;
securityInfo
=
null
;
originalURI
=
null
;
status
=
Cr
.
NS_OK
;
get
name
(
)
{
return
this
.
#
uri
;
}
get
URI
(
)
{
return
this
.
#
uri
;
}
get
loadGroup
(
)
{
return
null
;
}
set
loadGroup
(
_val
)
{
}
get
loadInfo
(
)
{
return
null
;
}
set
loadInfo
(
_val
)
{
}
open
(
)
{
throw
Components
.
Exception
(
{
this
.
constructor
.
name
}
.
open
not
implemented
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
asyncOpen
(
observer
)
{
observer
.
onStartRequest
(
this
null
)
;
}
asyncRead
(
listener
ctxt
)
{
return
listener
.
onStartRequest
(
this
ctxt
)
;
}
isPending
(
)
{
return
false
;
}
cancel
(
status
)
{
this
.
status
=
status
;
}
suspend
(
)
{
throw
Components
.
Exception
(
{
this
.
constructor
.
name
}
.
suspend
not
implemented
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
resume
(
)
{
throw
Components
.
Exception
(
{
this
.
constructor
.
name
}
.
resume
not
implemented
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIChannel
"
"
nsIRequest
"
"
nsIRegion
"
]
)
;
}
class
FakeStreamListener
{
onStartRequest
(
_request
)
{
}
onDataAvailable
(
_request
_stream
_offset
_count
)
{
}
onStopRequest
(
_request
_status
)
{
}
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIStreamListener
"
]
)
;
}
add_task
(
async
function
test_no_asyncOpen_inner
(
)
{
let
innerChannel
=
new
MockChannel
(
"
about
:
newtab
"
)
;
Assert
.
ok
(
innerChannel
.
QueryInterface
(
Ci
.
nsIChannel
)
)
;
let
suspendedChannel
=
Services
.
io
.
newSuspendableChannelWrapper
(
innerChannel
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
innerChannel
"
asyncOpen
"
)
;
suspendedChannel
.
suspend
(
)
;
let
fakeStreamListener
=
new
FakeStreamListener
(
)
;
suspendedChannel
.
asyncOpen
(
fakeStreamListener
)
;
Assert
.
ok
(
innerChannel
.
asyncOpen
.
notCalled
"
asyncOpen
not
called
on
inner
"
)
;
Assert
.
ok
(
suspendedChannel
.
isPending
(
)
"
suspended
channel
is
pending
"
)
;
suspendedChannel
.
resume
(
)
;
Assert
.
ok
(
innerChannel
.
asyncOpen
.
calledOnce
"
asyncOpen
called
on
inner
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_forwarding
(
)
{
let
innerChannel
=
new
MockChannel
(
"
about
:
newtab
"
)
;
let
suspendedChannel
=
Services
.
io
.
newSuspendableChannelWrapper
(
innerChannel
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
innerChannel
"
asyncOpen
"
)
;
let
nameSpy
=
sandbox
.
spy
(
innerChannel
"
name
"
[
"
get
"
]
)
;
suspendedChannel
.
name
;
Assert
.
ok
(
nameSpy
.
get
.
calledOnce
"
name
was
retreived
from
inner
"
)
;
sandbox
.
stub
(
innerChannel
"
suspend
"
)
;
suspendedChannel
.
suspend
(
)
;
Assert
.
ok
(
innerChannel
.
suspend
.
notCalled
"
suspend
not
called
on
inner
(
since
not
yet
opened
)
"
)
;
sandbox
.
stub
(
innerChannel
"
resume
"
)
;
suspendedChannel
.
resume
(
)
;
Assert
.
ok
(
innerChannel
.
resume
.
notCalled
"
resume
not
called
on
inner
(
since
not
yet
opened
)
"
)
;
let
loadGroupSpy
=
sandbox
.
spy
(
innerChannel
"
loadGroup
"
[
"
get
"
"
set
"
]
)
;
suspendedChannel
.
loadGroup
;
Assert
.
ok
(
loadGroupSpy
.
get
.
calledOnce
"
loadGroup
was
retreived
from
inner
"
)
;
suspendedChannel
.
loadGroup
=
null
;
Assert
.
ok
(
loadGroupSpy
.
set
.
calledOnce
"
loadGroup
was
set
on
inner
"
)
;
let
loadInfoSpy
=
sandbox
.
spy
(
innerChannel
"
loadInfo
"
[
"
get
"
"
set
"
]
)
;
suspendedChannel
.
loadInfo
;
Assert
.
ok
(
loadInfoSpy
.
get
.
calledOnce
"
loadInfo
was
retreived
from
inner
"
)
;
suspendedChannel
.
loadInfo
=
null
;
Assert
.
ok
(
loadInfoSpy
.
set
.
calledOnce
"
loadInfo
was
set
on
inner
"
)
;
let
URISpy
=
sandbox
.
spy
(
innerChannel
"
URI
"
[
"
get
"
]
)
;
suspendedChannel
.
URI
;
Assert
.
ok
(
URISpy
.
get
.
calledOnce
"
URI
was
retreived
from
inner
"
)
;
Assert
.
ok
(
innerChannel
.
asyncOpen
.
notCalled
"
asyncOpen
never
called
on
the
inner
channel
"
)
;
Assert
.
ok
(
innerChannel
.
QueryInterface
(
Ci
.
nsIRegion
)
"
Inner
QIs
to
nsIRegion
"
)
;
Assert
.
ok
(
suspendedChannel
.
QueryInterface
(
Ci
.
nsIRegion
)
"
Can
QI
to
something
the
inner
channel
implements
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_no_asyncOpen_on_resume
(
)
{
let
innerChannel
=
new
MockChannel
(
"
about
:
newtab
"
)
;
let
suspendedChannel
=
Services
.
io
.
newSuspendableChannelWrapper
(
innerChannel
)
;
suspendedChannel
.
suspend
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
innerChannel
"
asyncOpen
"
)
;
Assert
.
ok
(
innerChannel
.
asyncOpen
.
notCalled
"
asyncOpen
not
called
on
inner
"
)
;
Assert
.
ok
(
suspendedChannel
.
isPending
(
)
"
suspended
channel
is
pending
"
)
;
suspendedChannel
.
resume
(
)
;
Assert
.
ok
(
innerChannel
.
asyncOpen
.
notCalled
"
asyncOpen
not
called
on
inner
"
)
;
let
fakeStreamListener
=
new
FakeStreamListener
(
)
;
suspendedChannel
.
asyncOpen
(
fakeStreamListener
)
;
Assert
.
ok
(
innerChannel
.
asyncOpen
.
calledOnce
"
asyncOpen
called
on
inner
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_allow_data
(
)
{
let
innerChannel
=
Cc
[
"
mozilla
.
org
/
network
/
input
-
stream
-
channel
;
1
"
]
.
createInstance
(
Ci
.
nsIInputStreamChannel
)
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
suspendedChannel
=
Services
.
io
.
newSuspendableChannelWrapper
(
innerChannel
)
;
const
TEST_STRING
=
"
This
is
a
test
string
!
"
;
let
stringStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stringStream
.
setByteStringData
(
TEST_STRING
)
;
let
httpChan
=
NetUtil
.
newChannel
(
{
uri
:
"
http
:
/
/
localhost
"
loadUsingSystemPrincipal
:
true
}
)
;
innerChannel
.
contentStream
=
stringStream
;
innerChannel
.
contentType
=
"
text
/
plain
"
;
innerChannel
.
setURI
(
httpChan
.
URI
)
;
innerChannel
.
loadInfo
=
httpChan
.
loadInfo
;
suspendedChannel
.
suspend
(
)
;
let
completedFetch
=
false
;
let
fetchPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
NetUtil
.
asyncFetch
(
suspendedChannel
(
stream
result
)
=
>
{
if
(
!
Components
.
isSuccessCode
(
result
)
)
{
reject
(
new
Error
(
Failed
to
fetch
stream
)
)
;
return
;
}
completedFetch
=
true
;
resolve
(
stream
)
;
}
)
;
}
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
1000
)
)
;
Assert
.
ok
(
!
completedFetch
"
Should
not
have
completed
the
fetch
.
"
)
;
suspendedChannel
.
resume
(
)
;
let
resultStream
=
await
fetchPromise
;
Assert
.
ok
(
completedFetch
"
Should
have
completed
the
fetch
.
"
)
;
let
resultString
=
NetUtil
.
readInputStreamToString
(
resultStream
resultStream
.
available
(
)
)
;
Assert
.
equal
(
TEST_STRING
resultString
"
Got
back
the
expected
string
.
"
)
;
}
)
;
