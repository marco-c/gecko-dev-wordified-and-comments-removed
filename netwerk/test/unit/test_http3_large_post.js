registerCleanupFunction
(
async
(
)
=
>
{
http3_clear_prefs
(
)
;
}
)
;
add_task
(
async
function
setup
(
)
{
await
http3_setup_tests
(
"
h3
-
29
"
)
;
}
)
;
let
Http3Listener
=
function
(
amount
)
{
this
.
amount
=
amount
;
}
;
Http3Listener
.
prototype
=
{
expectedStatus
:
Cr
.
NS_OK
amount
:
0
onProgressMaxNotificationCount
:
0
onProgressNotificationCount
:
0
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIProgressEventSink
"
]
)
getInterface
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIProgressEventSink
)
)
{
return
this
;
}
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NO_INTERFACE
)
;
}
onProgress
(
request
progress
progressMax
)
{
if
(
progress
=
=
=
progressMax
)
{
this
.
onProgressMaxNotificationCount
+
=
1
;
}
this
.
onProgressNotificationCount
+
=
1
;
}
onStatus
(
)
{
}
onStartRequest
:
function
testOnStartRequest
(
request
)
{
Assert
.
equal
(
request
.
status
this
.
expectedStatus
)
;
if
(
Components
.
isSuccessCode
(
this
.
expectedStatus
)
)
{
Assert
.
equal
(
request
.
responseStatus
200
)
;
}
Assert
.
equal
(
this
.
amount
request
.
getResponseHeader
(
"
x
-
data
-
received
-
length
"
)
)
;
}
onDataAvailable
:
function
testOnDataAvailable
(
request
stream
off
cnt
)
{
read_stream
(
stream
cnt
)
;
}
onStopRequest
:
function
testOnStopRequest
(
request
)
{
let
httpVersion
=
"
"
;
try
{
httpVersion
=
request
.
protocolVersion
;
}
catch
(
e
)
{
}
Assert
.
equal
(
httpVersion
"
h3
-
29
"
)
;
Assert
.
equal
(
this
.
onProgressMaxNotificationCount
2
)
;
if
(
this
.
amount
>
500000
)
{
Assert
.
ok
(
this
.
onProgressNotificationCount
>
10
)
;
}
this
.
finish
(
)
;
}
}
;
function
chanPromise
(
chan
listener
)
{
return
new
Promise
(
resolve
=
>
{
function
finish
(
result
)
{
resolve
(
result
)
;
}
listener
.
finish
=
finish
;
chan
.
asyncOpen
(
listener
)
;
}
)
;
}
function
makeChan
(
uri
amount
)
{
let
chan
=
NetUtil
.
newChannel
(
{
uri
loadUsingSystemPrincipal
:
true
}
)
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
chan
.
loadFlags
=
Ci
.
nsIChannel
.
LOAD_INITIAL_DOCUMENT_URI
;
let
stream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stream
.
data
=
generateContent
(
amount
)
;
let
uchan
=
chan
.
QueryInterface
(
Ci
.
nsIUploadChannel
)
;
uchan
.
setUploadStream
(
stream
"
text
/
plain
"
stream
.
available
(
)
)
;
chan
.
requestMethod
=
"
POST
"
;
return
chan
;
}
function
generateContent
(
size
)
{
let
content
=
"
"
;
for
(
let
i
=
0
;
i
<
size
;
i
+
+
)
{
content
+
=
"
0
"
;
}
return
content
;
}
add_task
(
async
function
test_large_post
(
)
{
let
amount
=
1
<
<
16
;
let
listener
=
new
Http3Listener
(
amount
)
;
let
chan
=
makeChan
(
"
https
:
/
/
foo
.
example
.
com
/
post
"
amount
)
;
chan
.
notificationCallbacks
=
listener
;
await
chanPromise
(
chan
listener
)
;
}
)
;
add_task
(
async
function
test_large_post2
(
)
{
let
amount
=
1
<
<
23
;
let
listener
=
new
Http3Listener
(
amount
)
;
let
chan
=
makeChan
(
"
https
:
/
/
foo
.
example
.
com
/
post
"
amount
)
;
chan
.
notificationCallbacks
=
listener
;
await
chanPromise
(
chan
listener
)
;
}
)
;
add_task
(
async
function
test_bug1749957_bug1750056
(
)
{
let
amount
=
200
;
let
uri
=
"
https
:
/
/
foo
.
example
.
com
/
post
"
;
let
listener
=
new
Http3Listener
(
amount
)
;
let
chan
=
NetUtil
.
newChannel
(
{
uri
loadUsingSystemPrincipal
:
true
}
)
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
{
chan
.
requestMethod
=
"
POST
"
;
chan
.
setRequestHeader
(
"
content
-
length
"
"
"
+
amount
false
)
;
let
stream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stream
.
data
=
generateContent
(
amount
)
;
let
uchan
=
chan
.
QueryInterface
(
Ci
.
nsIUploadChannel2
)
;
uchan
.
explicitSetUploadStream
(
stream
"
"
-
1
"
POST
"
false
)
;
}
chan
.
notificationCallbacks
=
listener
;
await
chanPromise
(
chan
listener
)
;
}
)
;
