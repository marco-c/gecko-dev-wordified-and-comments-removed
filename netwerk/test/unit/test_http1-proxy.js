const
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
const
pps
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
-
proxy
-
service
;
1
"
]
.
getService
(
)
;
let
server_port
;
let
http_server
;
class
ProxyFilter
{
constructor
(
type
host
port
flags
)
{
this
.
_type
=
type
;
this
.
_host
=
host
;
this
.
_port
=
port
;
this
.
_flags
=
flags
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIProtocolProxyFilter
]
)
;
}
applyFilter
(
pps
uri
pi
cb
)
{
if
(
uri
.
spec
.
match
(
/
(
\
/
proxy
-
session
-
counter
)
/
)
)
{
cb
.
onProxyFilterResult
(
pi
)
;
return
;
}
cb
.
onProxyFilterResult
(
pps
.
newProxyInfo
(
this
.
_type
this
.
_host
this
.
_port
"
"
"
"
this
.
_flags
1000
null
)
)
;
}
}
class
UnxpectedAuthPrompt2
{
constructor
(
signal
)
{
this
.
signal
=
signal
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAuthPrompt2
]
)
;
}
asyncPromptAuth
(
)
{
this
.
signal
.
triggered
=
true
;
throw
Cr
.
ERROR_UNEXPECTED
;
}
}
class
AuthRequestor
{
constructor
(
prompt
)
{
this
.
prompt
=
prompt
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIInterfaceRequestor
]
)
;
}
getInterface
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIAuthPrompt2
)
)
{
return
this
.
prompt
(
)
;
}
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
}
function
make_channel
(
url
)
{
return
NetUtil
.
newChannel
(
{
uri
:
url
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
}
)
;
}
function
get_response
(
channel
flags
=
CL_ALLOW_UNKNOWN_CL
)
{
return
new
Promise
(
resolve
=
>
{
channel
.
asyncOpen
(
new
ChannelListener
(
(
request
data
)
=
>
{
request
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
const
status
=
request
.
status
;
const
http_code
=
status
?
undefined
:
request
.
responseStatus
;
resolve
(
{
status
http_code
data
}
)
;
}
null
flags
)
)
;
}
)
;
}
function
connect_handler
(
request
response
)
{
Assert
.
equal
(
request
.
method
"
CONNECT
"
)
;
switch
(
request
.
host
)
{
case
"
404
.
example
.
com
"
:
response
.
setStatusLine
(
request
.
httpVersion
404
"
Not
found
"
)
;
break
;
case
"
407
.
example
.
com
"
:
response
.
setStatusLine
(
request
.
httpVersion
407
"
Authenticate
"
)
;
break
;
case
"
429
.
example
.
com
"
:
response
.
setStatusLine
(
request
.
httpVersion
429
"
Too
Many
Requests
"
)
;
break
;
case
"
502
.
example
.
com
"
:
response
.
setStatusLine
(
request
.
httpVersion
502
"
Bad
Gateway
"
)
;
break
;
case
"
504
.
example
.
com
"
:
response
.
setStatusLine
(
request
.
httpVersion
504
"
Gateway
timeout
"
)
;
break
;
default
:
response
.
setStatusLine
(
request
.
httpVersion
500
"
I
am
dumb
"
)
;
}
}
add_task
(
async
function
setup
(
)
{
http_server
=
new
HttpServer
(
)
;
http_server
.
identity
.
add
(
"
https
"
"
404
.
example
.
com
"
443
)
;
http_server
.
identity
.
add
(
"
https
"
"
407
.
example
.
com
"
443
)
;
http_server
.
identity
.
add
(
"
https
"
"
429
.
example
.
com
"
443
)
;
http_server
.
identity
.
add
(
"
https
"
"
502
.
example
.
com
"
443
)
;
http_server
.
identity
.
add
(
"
https
"
"
504
.
example
.
com
"
443
)
;
http_server
.
registerPathHandler
(
"
CONNECT
"
connect_handler
)
;
http_server
.
start
(
-
1
)
;
server_port
=
http_server
.
identity
.
primaryPort
;
Services
.
prefs
.
setBoolPref
(
"
network
.
dns
.
native
-
is
-
localhost
"
true
)
;
pps
.
registerFilter
(
new
ProxyFilter
(
"
http
"
"
localhost
"
server_port
0
)
10
)
;
}
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
network
.
dns
.
native
-
is
-
localhost
"
)
;
}
)
;
add_task
(
async
function
proxy_auth_failure
(
)
{
const
chan
=
make_channel
(
https
:
/
/
407
.
example
.
com
/
)
;
const
auth_prompt
=
{
triggered
:
false
}
;
chan
.
notificationCallbacks
=
new
AuthRequestor
(
(
)
=
>
new
UnxpectedAuthPrompt2
(
auth_prompt
)
)
;
const
{
status
http_code
}
=
await
get_response
(
chan
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
status
Cr
.
NS_ERROR_PROXY_AUTHENTICATION_FAILED
)
;
Assert
.
equal
(
http_code
undefined
)
;
Assert
.
equal
(
auth_prompt
.
triggered
false
"
Auth
prompt
didn
'
t
trigger
"
)
;
}
)
;
add_task
(
async
function
proxy_bad_gateway_failure
(
)
{
const
{
status
http_code
}
=
await
get_response
(
make_channel
(
https
:
/
/
502
.
example
.
com
/
)
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
status
Cr
.
NS_ERROR_PROXY_BAD_GATEWAY
)
;
Assert
.
equal
(
http_code
undefined
)
;
}
)
;
add_task
(
async
function
proxy_gateway_timeout_failure
(
)
{
const
{
status
http_code
}
=
await
get_response
(
make_channel
(
https
:
/
/
504
.
example
.
com
/
)
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
status
Cr
.
NS_ERROR_PROXY_GATEWAY_TIMEOUT
)
;
Assert
.
equal
(
http_code
undefined
)
;
}
)
;
add_task
(
async
function
proxy_host_not_found_failure
(
)
{
const
{
status
http_code
}
=
await
get_response
(
make_channel
(
https
:
/
/
404
.
example
.
com
/
)
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
status
Cr
.
NS_ERROR_UNKNOWN_HOST
)
;
Assert
.
equal
(
http_code
undefined
)
;
}
)
;
add_task
(
async
function
proxy_too_many_requests_failure
(
)
{
const
{
status
http_code
}
=
await
get_response
(
make_channel
(
https
:
/
/
429
.
example
.
com
/
)
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
status
Cr
.
NS_ERROR_PROXY_TOO_MANY_REQUESTS
)
;
Assert
.
equal
(
http_code
undefined
)
;
}
)
;
add_task
(
async
function
shutdown
(
)
{
await
new
Promise
(
resolve
=
>
{
http_server
.
stop
(
resolve
)
;
}
)
;
}
)
;
