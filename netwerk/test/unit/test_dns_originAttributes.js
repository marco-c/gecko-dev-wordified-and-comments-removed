"
use
strict
"
;
var
dns
=
Cc
[
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
]
.
getService
(
Ci
.
nsIDNSService
)
;
var
threadManager
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIThreadManager
)
;
var
prefs
=
Cc
[
"
mozilla
.
org
/
preferences
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrefBranch
)
;
var
mainThread
=
threadManager
.
currentThread
;
var
listener1
=
{
onLookupComplete
(
inRequest
inRecord
inStatus
)
{
Assert
.
equal
(
inStatus
Cr
.
NS_OK
)
;
var
answer
=
inRecord
.
getNextAddrAsString
(
)
;
Assert
.
ok
(
answer
=
=
"
127
.
0
.
0
.
1
"
|
|
answer
=
=
"
:
:
1
"
)
;
test2
(
)
;
do_test_finished
(
)
;
}
}
;
var
listener2
=
{
onLookupComplete
(
inRequest
inRecord
inStatus
)
{
Assert
.
equal
(
inStatus
Cr
.
NS_OK
)
;
var
answer
=
inRecord
.
getNextAddrAsString
(
)
;
Assert
.
ok
(
answer
=
=
"
127
.
0
.
0
.
1
"
|
|
answer
=
=
"
:
:
1
"
)
;
test3
(
)
;
do_test_finished
(
)
;
}
}
;
var
listener3
=
{
onLookupComplete
(
inRequest
inRecord
inStatus
)
{
Assert
.
equal
(
inStatus
Cr
.
NS_ERROR_OFFLINE
)
;
do_test_finished
(
)
;
}
}
;
const
firstOriginAttributes
=
{
userContextId
:
1
}
;
const
secondOriginAttributes
=
{
userContextId
:
2
}
;
function
run_test
(
)
{
do_test_pending
(
)
;
dns
.
asyncResolve
(
"
localhost
"
0
listener1
mainThread
firstOriginAttributes
)
;
}
function
test2
(
)
{
do_test_pending
(
)
;
dns
.
asyncResolve
(
"
localhost
"
Ci
.
nsIDNSService
.
RESOLVE_OFFLINE
listener2
mainThread
firstOriginAttributes
)
;
}
function
test3
(
)
{
do_test_pending
(
)
;
prefs
.
setBoolPref
(
"
network
.
proxy
.
allow_hijacking_localhost
"
true
)
;
try
{
dns
.
asyncResolve
(
"
localhost
"
Ci
.
nsIDNSService
.
RESOLVE_OFFLINE
listener3
mainThread
secondOriginAttributes
)
;
}
catch
(
e
)
{
Assert
.
equal
(
e
.
result
Cr
.
NS_ERROR_OFFLINE
)
;
prefs
.
clearUserPref
(
"
network
.
proxy
.
allow_hijacking_localhost
"
)
;
do_test_finished
(
)
;
}
}
