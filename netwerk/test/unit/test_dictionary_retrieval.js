"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
test
/
head_cache
.
js
"
this
)
;
const
{
NodeHTTPSServer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
NodeServer
.
sys
.
mjs
"
)
;
const
RETRIEVAL_TEST_DICTIONARIES
=
{
api_v1
:
{
id
:
"
api
-
v1
-
dict
"
content
:
"
API_V1_COMMON_DATA
"
pattern
:
"
/
api
/
v1
/
*
"
type
:
"
raw
"
}
api_generic
:
{
id
:
"
api
-
generic
-
dict
"
content
:
"
API_GENERIC_DATA
"
pattern
:
"
/
api
/
*
"
type
:
"
raw
"
}
wildcard
:
{
id
:
"
wildcard
-
dict
"
content
:
"
WILDCARD_DATA
"
pattern
:
"
*
"
type
:
"
raw
"
}
js_files
:
{
id
:
"
js
-
dict
"
content
:
"
JS_COMMON_CODE
"
pattern
:
"
*
.
js
"
type
:
"
raw
"
}
}
;
let
server
=
null
;
let
requestLog
=
[
]
;
async
function
sync_to_server
(
)
{
if
(
server
.
processId
)
{
await
server
.
execute
(
global
.
requestLog
=
{
JSON
.
stringify
(
requestLog
)
}
;
)
;
}
else
{
dump
(
"
Server
not
running
?
\
n
"
)
;
}
}
async
function
sync_from_server
(
)
{
if
(
server
.
processId
)
{
requestLog
=
await
server
.
execute
(
global
.
requestLog
)
;
}
else
{
dump
(
"
Server
not
running
?
(
from
)
\
n
"
)
;
}
}
add_setup
(
async
function
(
)
{
if
(
!
server
)
{
server
=
await
setupServer
(
)
;
}
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
}
)
;
async
function
calculateDictionaryHash
(
content
)
{
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
Ci
.
nsICryptoHash
.
SHA256
)
;
let
bytes
=
new
TextEncoder
(
)
.
encode
(
content
)
;
hasher
.
update
(
bytes
bytes
.
length
)
;
let
hash
=
hasher
.
finish
(
false
)
;
return
btoa
(
hash
)
;
}
async
function
setupServer
(
)
{
if
(
!
server
)
{
server
=
new
NodeHTTPSServer
(
)
;
await
server
.
start
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
try
{
await
server
.
stop
(
)
;
}
catch
(
e
)
{
}
}
)
;
}
return
server
;
}
function
makeChan
(
url
)
{
let
chan
=
NetUtil
.
newChannel
(
{
uri
:
url
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
}
)
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
return
chan
;
}
function
channelOpenPromise
(
chan
)
{
return
new
Promise
(
resolve
=
>
{
function
finish
(
req
buffer
)
{
resolve
(
[
req
buffer
]
)
;
}
chan
.
asyncOpen
(
new
ChannelListener
(
finish
null
CL_ALLOW_UNKNOWN_CL
)
)
;
}
)
;
}
function
verifyDictionaryStored
(
url
shouldExist
callback
)
{
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
asyncCheckCacheEntryPresence
(
url
"
disk
"
shouldExist
lci
callback
)
;
}
async
function
registerDictionaryAwareEndpoint
(
httpServer
path
responseContent
)
{
let
func
=
/
/
Log
the
request
for
analysis
global
.
requestLog
[
global
.
requestLog
.
length
]
=
{
path
:
"
{
path
}
"
hasAvailableDict
:
request
.
headers
[
'
available
-
dictionary
'
]
!
=
=
undefined
availableDict
:
request
.
headers
[
'
available
-
dictionary
'
]
|
|
null
}
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
text
/
plain
"
}
)
;
response
.
end
(
"
{
responseContent
}
"
"
binary
"
)
;
;
let
handler
=
new
Function
(
"
request
"
"
response
"
func
)
;
return
httpServer
.
registerPathHandler
(
path
handler
)
;
}
async
function
setupRetrievalTestServer
(
)
{
await
setupServer
(
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
api
-
v1
"
function
(
request
response
)
{
const
RETRIEVAL_TEST_DICTIONARIES
=
{
api_v1
:
{
id
:
"
api
-
v1
-
dict
"
content
:
"
API_V1_COMMON_DATA
"
pattern
:
"
/
api
/
v1
/
*
"
type
:
"
raw
"
}
}
;
let
dict
=
RETRIEVAL_TEST_DICTIONARIES
.
api_v1
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
api
-
generic
"
function
(
request
response
)
{
const
RETRIEVAL_TEST_DICTIONARIES
=
{
api_generic
:
{
id
:
"
api
-
generic
-
dict
"
content
:
"
API_GENERIC_DATA
"
pattern
:
"
/
api
/
*
"
type
:
"
raw
"
}
}
;
let
dict
=
RETRIEVAL_TEST_DICTIONARIES
.
api_generic
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
wildcard
"
function
(
request
response
)
{
const
RETRIEVAL_TEST_DICTIONARIES
=
{
wildcard
:
{
id
:
"
wildcard
-
dict
"
content
:
"
WILDCARD_DATA
"
pattern
:
"
*
"
type
:
"
raw
"
}
}
;
let
dict
=
RETRIEVAL_TEST_DICTIONARIES
.
wildcard
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
js
"
function
(
request
response
)
{
const
RETRIEVAL_TEST_DICTIONARIES
=
{
js_files
:
{
id
:
"
js
-
dict
"
content
:
"
JS_COMMON_CODE
"
pattern
:
"
*
.
js
"
type
:
"
raw
"
}
}
;
let
dict
=
RETRIEVAL_TEST_DICTIONARIES
.
js_files
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
registerDictionaryAwareEndpoint
(
server
"
/
api
/
v1
/
users
"
"
API
V1
USERS
DATA
"
)
;
await
registerDictionaryAwareEndpoint
(
server
"
/
api
/
v2
/
posts
"
"
API
V2
POSTS
DATA
"
)
;
await
registerDictionaryAwareEndpoint
(
server
"
/
api
/
generic
"
"
GENERIC
API
DATA
"
)
;
await
registerDictionaryAwareEndpoint
(
server
"
/
web
/
page
"
"
WEB
PAGE
DATA
"
)
;
await
registerDictionaryAwareEndpoint
(
server
"
/
scripts
/
app
.
js
"
"
JAVASCRIPT
CODE
"
)
;
await
registerDictionaryAwareEndpoint
(
server
"
/
styles
/
main
.
css
"
"
CSS
STYLES
"
)
;
return
server
;
}
add_task
(
async
function
test_setup_dictionaries
(
)
{
await
setupRetrievalTestServer
(
)
;
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
const
dictPaths
=
[
"
/
dict
/
api
-
v1
"
"
/
dict
/
api
-
generic
"
"
/
dict
/
wildcard
"
"
/
dict
/
js
"
]
;
for
(
let
path
of
dictPaths
)
{
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
{
path
}
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
dump
(
*
*
*
*
Dictionary
loaded
:
{
path
}
data
length
:
{
data
.
length
}
\
n
)
;
await
new
Promise
(
resolve
=
>
{
verifyDictionaryStored
(
url
true
resolve
)
;
}
)
;
}
dump
(
"
*
*
*
*
Setup
complete
\
n
"
)
;
}
)
;
add_task
(
async
function
test_basic_dictionary_retrieval
(
)
{
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
api
/
v1
/
users
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
let
expectedHash
=
await
calculateDictionaryHash
(
RETRIEVAL_TEST_DICTIONARIES
.
api_v1
.
content
)
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
API
V1
USERS
DATA
"
"
Resource
content
matches
"
)
;
await
sync_from_server
(
)
;
let
logEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
"
/
api
/
v1
/
users
"
)
;
Assert
.
ok
(
logEntry
&
&
logEntry
.
hasAvailableDict
"
Has
Available
-
Dictionary
"
)
;
Assert
.
ok
(
logEntry
.
availableDict
.
includes
(
expectedHash
)
"
Available
-
Dictionary
header
should
contain
expected
hash
"
)
;
dump
(
"
*
*
*
*
Basic
retrieval
test
complete
\
n
"
)
;
}
)
;
add_task
(
async
function
test_dictionary_pattern_matching
(
)
{
const
patternMatchTests
=
[
{
url
:
"
/
api
/
v1
/
users
"
expectedPattern
:
"
/
api
/
v1
/
*
"
dictKey
:
"
api_v1
"
}
{
url
:
"
/
api
/
v2
/
posts
"
expectedPattern
:
"
/
api
/
*
"
dictKey
:
"
api_generic
"
}
{
url
:
"
/
api
/
generic
"
expectedPattern
:
"
/
api
/
*
"
dictKey
:
"
api_generic
"
}
{
url
:
"
/
scripts
/
app
.
js
"
expectedPattern
:
"
*
.
js
"
dictKey
:
"
js_files
"
}
{
url
:
"
/
web
/
page
"
expectedPattern
:
"
*
"
dictKey
:
"
wildcard
"
}
{
url
:
"
/
styles
/
main
.
css
"
expectedPattern
:
"
*
"
dictKey
:
"
wildcard
"
}
]
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
for
(
let
test
of
patternMatchTests
)
{
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
{
test
.
url
}
;
let
expectedDict
=
RETRIEVAL_TEST_DICTIONARIES
[
test
.
dictKey
]
;
let
expectedHash
=
await
calculateDictionaryHash
(
expectedDict
.
content
)
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
greater
(
data
.
length
0
Resource
{
test
.
url
}
should
have
content
)
;
await
sync_from_server
(
)
;
let
logEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
test
.
url
)
;
Assert
.
ok
(
logEntry
&
&
logEntry
.
hasAvailableDict
Available
-
Dictionary
header
should
be
present
for
{
test
.
url
}
)
;
if
(
logEntry
&
&
logEntry
.
hasAvailableDict
)
{
Assert
.
ok
(
logEntry
.
availableDict
.
includes
(
expectedHash
)
Available
-
Dictionary
header
should
contain
expected
hash
for
{
test
.
url
}
)
;
}
}
}
)
;
add_task
(
async
function
test_dictionary_precedence
(
)
{
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
api
/
v1
/
users
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
let
mostSpecificHash
=
await
calculateDictionaryHash
(
RETRIEVAL_TEST_DICTIONARIES
.
api_v1
.
content
)
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
API
V1
USERS
DATA
"
"
Content
should
match
"
)
;
await
sync_from_server
(
)
;
let
logEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
"
/
api
/
v1
/
users
"
)
;
Assert
.
ok
(
logEntry
&
&
logEntry
.
hasAvailableDict
"
Available
-
Dictionary
header
should
be
present
for
precedence
test
"
)
;
if
(
logEntry
&
&
logEntry
.
hasAvailableDict
)
{
Assert
.
ok
(
logEntry
.
availableDict
.
includes
(
mostSpecificHash
)
"
Available
-
Dictionary
header
should
contain
most
specific
pattern
hash
"
)
;
}
}
)
;
add_task
(
async
function
test_dictionary_cache_hit
(
)
{
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
api
/
generic
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
let
expectedHash
=
await
calculateDictionaryHash
(
RETRIEVAL_TEST_DICTIONARIES
.
api_generic
.
content
)
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
GENERIC
API
DATA
"
"
Content
should
match
"
)
;
await
sync_from_server
(
)
;
let
logEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
"
/
api
/
generic
"
)
;
Assert
.
ok
(
logEntry
&
&
logEntry
.
hasAvailableDict
"
Available
-
Dictionary
header
should
be
present
for
cache
hit
"
)
;
if
(
logEntry
&
&
logEntry
.
hasAvailableDict
)
{
Assert
.
ok
(
logEntry
.
availableDict
.
includes
(
expectedHash
)
"
Available
-
Dictionary
header
should
contain
expected
hash
for
cache
hit
"
)
;
}
}
)
;
add_task
(
async
function
test_dictionary_hash_format
(
)
{
let
testDict
=
RETRIEVAL_TEST_DICTIONARIES
.
api_v1
;
let
calculatedHash
=
await
calculateDictionaryHash
(
testDict
.
content
)
;
Assert
.
greater
(
calculatedHash
.
length
0
"
Hash
should
not
be
empty
"
)
;
let
base64Pattern
=
/
^
[
A
-
Za
-
z0
-
9
+
/
]
*
=
{
0
2
}
/
;
Assert
.
ok
(
base64Pattern
.
test
(
calculatedHash
)
"
Hash
should
be
valid
base64
"
)
;
let
structuredFieldFormat
=
:
{
calculatedHash
}
:
;
Assert
.
ok
(
structuredFieldFormat
.
includes
(
calculatedHash
)
"
Hash
should
follow
structured
field
format
"
)
;
}
)
;
add_task
(
async
function
test_multiple_dictionary_matches
(
)
{
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
api
/
test
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
await
registerDictionaryAwareEndpoint
(
server
"
/
api
/
test
"
"
API
TEST
DATA
"
)
;
let
apiGenericHash
=
await
calculateDictionaryHash
(
RETRIEVAL_TEST_DICTIONARIES
.
api_generic
.
content
)
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
API
TEST
DATA
"
"
Content
should
match
"
)
;
await
sync_from_server
(
)
;
let
logEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
"
/
api
/
test
"
)
;
Assert
.
ok
(
logEntry
&
&
logEntry
.
hasAvailableDict
"
Available
-
Dictionary
header
should
be
present
for
multiple
matches
"
)
;
if
(
logEntry
&
&
logEntry
.
hasAvailableDict
)
{
let
hasApiGenericHash
=
logEntry
.
availableDict
.
includes
(
apiGenericHash
)
;
Assert
.
ok
(
hasApiGenericHash
"
Available
-
Dictionary
header
should
contain
at
least
one
expected
hash
for
multiple
matches
"
)
;
}
}
)
;
add_task
(
async
function
cleanup
(
)
{
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
}
)
;
