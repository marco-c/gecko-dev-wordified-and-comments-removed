"
use
strict
"
;
var
{
setTimeout
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
)
;
const
earlyhintspath
=
"
/
103_response
"
;
add_setup
(
async
function
(
)
{
await
http3_setup_tests
(
"
h3
"
)
;
}
)
;
function
makeChan
(
url
)
{
let
chan
=
NetUtil
.
newChannel
(
{
uri
:
url
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
}
)
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
return
chan
;
}
function
channelOpenPromise
(
chan
flags
)
{
return
new
Promise
(
resolve
=
>
{
function
finish
(
req
buffer
)
{
resolve
(
[
req
buffer
]
)
;
}
chan
.
asyncOpen
(
new
ChannelListener
(
finish
null
flags
)
)
;
}
)
;
}
add_task
(
async
function
test_http3_no_interim_response
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
net
:
prune
-
all
-
connections
"
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
1000
)
)
;
let
chan
=
makeChan
(
https
:
/
/
foo
.
example
.
com
)
;
let
[
req
]
=
await
channelOpenPromise
(
chan
)
;
let
httpVersion
=
"
"
;
try
{
httpVersion
=
req
.
protocolVersion
;
}
catch
(
e
)
{
}
Assert
.
equal
(
httpVersion
"
h3
"
"
Request
should
use
HTTP
/
3
"
)
;
let
timing
=
req
.
QueryInterface
(
Ci
.
nsITimedChannel
)
;
let
firstInterimResponseStart
=
0
;
if
(
timing
.
responseStartTime
>
0
&
&
timing
.
finalResponseHeadersStartTime
>
0
&
&
timing
.
responseStartTime
<
timing
.
finalResponseHeadersStartTime
)
{
firstInterimResponseStart
=
timing
.
responseStartTime
;
}
Assert
.
equal
(
firstInterimResponseStart
0
"
firstInterimResponseStart
should
be
0
when
no
interim
response
"
)
;
Assert
.
greater
(
timing
.
responseStartTime
0
"
responseStart
should
be
set
"
)
;
Assert
.
greater
(
timing
.
finalResponseHeadersStartTime
0
"
finalResponseHeadersStart
should
be
set
"
)
;
let
timeDiff
=
Math
.
abs
(
timing
.
responseStartTime
-
timing
.
finalResponseHeadersStartTime
)
;
Assert
.
less
(
timeDiff
10
"
responseStart
and
finalResponseHeadersStart
should
be
approximately
equal
when
no
interim
response
"
)
;
}
)
;
add_task
(
async
function
test_http3_with_interim_response
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
net
:
prune
-
all
-
connections
"
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
1000
)
)
;
let
chan
=
makeChan
(
https
:
/
/
foo
.
example
.
com
{
earlyhintspath
}
)
;
chan
.
setRequestHeader
(
"
link
-
to
-
set
"
"
<
/
style
.
css
>
;
rel
=
preload
;
as
=
style
"
false
)
;
let
[
req
]
=
await
channelOpenPromise
(
chan
)
;
let
httpVersion
=
"
"
;
try
{
httpVersion
=
req
.
protocolVersion
;
}
catch
(
e
)
{
}
Assert
.
equal
(
httpVersion
"
h3
"
"
Request
should
use
HTTP
/
3
"
)
;
let
timing
=
req
.
QueryInterface
(
Ci
.
nsITimedChannel
)
;
let
firstInterimResponseStart
=
0
;
if
(
timing
.
responseStartTime
>
0
&
&
timing
.
finalResponseHeadersStartTime
>
0
&
&
timing
.
responseStartTime
<
timing
.
finalResponseHeadersStartTime
)
{
firstInterimResponseStart
=
timing
.
responseStartTime
;
}
Assert
.
greater
(
firstInterimResponseStart
0
"
firstInterimResponseStart
should
be
set
when
interim
response
received
"
)
;
Assert
.
greater
(
timing
.
responseStartTime
0
"
responseStart
should
be
set
"
)
;
Assert
.
greater
(
timing
.
finalResponseHeadersStartTime
0
"
finalResponseHeadersStart
should
be
set
"
)
;
Assert
.
equal
(
timing
.
responseStartTime
firstInterimResponseStart
"
responseStart
should
equal
firstInterimResponseStart
when
interim
response
received
"
)
;
Assert
.
lessOrEqual
(
firstInterimResponseStart
timing
.
finalResponseHeadersStartTime
"
firstInterimResponseStart
should
be
before
or
equal
to
finalResponseHeadersStart
"
)
;
}
)
;
add_task
(
async
function
test_http3_timing_order
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
net
:
prune
-
all
-
connections
"
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
1000
)
)
;
let
chan
=
makeChan
(
https
:
/
/
foo
.
example
.
com
{
earlyhintspath
}
)
;
chan
.
setRequestHeader
(
"
link
-
to
-
set
"
"
<
/
img
.
png
>
;
rel
=
preload
;
as
=
image
"
false
)
;
let
[
req
]
=
await
channelOpenPromise
(
chan
)
;
let
timing
=
req
.
QueryInterface
(
Ci
.
nsITimedChannel
)
;
let
firstInterimResponseStart
=
0
;
if
(
timing
.
responseStartTime
>
0
&
&
timing
.
finalResponseHeadersStartTime
>
0
&
&
timing
.
responseStartTime
<
timing
.
finalResponseHeadersStartTime
)
{
firstInterimResponseStart
=
timing
.
responseStartTime
;
}
Assert
.
greater
(
timing
.
requestStartTime
0
"
requestStart
should
be
set
"
)
;
Assert
.
lessOrEqual
(
timing
.
requestStartTime
firstInterimResponseStart
"
requestStart
should
be
before
or
equal
to
firstInterimResponseStart
"
)
;
Assert
.
lessOrEqual
(
firstInterimResponseStart
timing
.
finalResponseHeadersStartTime
"
firstInterimResponseStart
should
be
before
or
equal
to
finalResponseHeadersStart
"
)
;
Assert
.
lessOrEqual
(
timing
.
finalResponseHeadersStartTime
timing
.
responseEndTime
"
finalResponseHeadersStart
should
be
before
or
equal
to
responseEnd
"
)
;
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
http3_clear_prefs
(
)
;
}
)
;
