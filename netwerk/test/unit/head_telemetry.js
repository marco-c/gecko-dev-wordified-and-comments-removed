"
use
strict
"
;
const
{
TelemetryTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
)
;
var
HandshakeTelemetryHelpers
=
{
HISTOGRAMS
:
[
"
SSL_HANDSHAKE_RESULT
"
"
SSL_TIME_UNTIL_READY
"
]
FLAVORS
:
[
"
"
"
_FIRST_TRY
"
"
_CONSERVATIVE
"
"
_ECH
"
"
_ECH_GREASE
"
]
dumpHistogram
(
name
)
{
let
values
=
Services
.
telemetry
.
getHistogramById
(
name
)
.
snapshot
(
)
.
values
;
dump
(
{
name
}
:
{
JSON
.
stringify
(
values
)
}
\
n
)
;
}
countHistogramEntries
(
histObject
)
{
Assert
.
ok
(
!
mozinfo
.
socketprocess_networking
"
Histograms
don
'
t
populate
on
network
process
"
)
;
let
count
=
0
;
let
m
=
histObject
.
snapshot
(
)
.
values
;
for
(
let
k
in
m
)
{
count
+
=
m
[
k
]
;
}
return
count
;
}
assertHistogramMap
(
histogram
expectedEntries
)
{
Assert
.
ok
(
!
mozinfo
.
socketprocess_networking
"
Histograms
don
'
t
populate
on
network
process
"
)
;
let
snapshot
=
JSON
.
parse
(
JSON
.
stringify
(
histogram
.
snapshot
(
)
)
)
;
for
(
let
[
Tk
Tv
]
of
expectedEntries
.
entries
(
)
)
{
let
found
=
false
;
for
(
let
[
i
val
]
of
Object
.
entries
(
snapshot
.
values
)
)
{
if
(
i
=
=
Tk
)
{
found
=
true
;
Assert
.
equal
(
val
Tv
expected
counts
should
match
for
{
histogram
.
name
(
)
}
at
index
{
i
}
)
;
snapshot
.
values
[
i
]
=
0
;
}
}
Assert
.
ok
(
found
Should
have
found
an
entry
for
{
histogram
.
name
(
)
}
at
index
{
Tk
}
)
;
}
for
(
let
k
in
snapshot
.
values
)
{
Assert
.
equal
(
snapshot
.
values
[
k
]
0
Should
NOT
have
found
an
entry
for
{
histogram
.
name
(
)
}
at
index
{
k
}
of
value
{
snapshot
.
values
[
k
]
}
)
;
}
}
getHistogramNames
(
histogramList
flavorList
)
{
let
output
=
[
]
;
for
(
let
h
of
histogramList
)
{
Assert
.
ok
(
this
.
HISTOGRAMS
.
includes
(
h
)
"
Histogram
name
valid
"
)
;
for
(
let
f
of
flavorList
)
{
Assert
.
ok
(
this
.
FLAVORS
.
includes
(
f
)
"
Histogram
flavor
valid
"
)
;
output
.
push
(
h
.
concat
(
f
)
)
;
}
}
return
output
;
}
getHistograms
(
histogramList
flavorList
)
{
return
this
.
getHistogramNames
(
histogramList
flavorList
)
.
map
(
x
=
>
Services
.
telemetry
.
getHistogramById
(
x
)
)
;
}
resetHistograms
(
)
{
let
allHistograms
=
this
.
getHistograms
(
this
.
HISTOGRAMS
this
.
FLAVORS
)
;
for
(
let
h
of
allHistograms
)
{
h
.
clear
(
)
;
}
}
checkEntry
(
flavors
resultCode
resultCount
)
{
Assert
.
ok
(
!
mozinfo
.
socketprocess_networking
"
Histograms
don
'
t
populate
on
network
process
"
)
;
for
(
let
h
of
this
.
getHistograms
(
[
"
SSL_HANDSHAKE_RESULT
"
]
flavors
)
)
{
TelemetryTestUtils
.
assertHistogram
(
h
resultCode
resultCount
)
;
}
if
(
resultCode
=
=
=
0
)
{
for
(
let
h
of
this
.
getHistograms
(
[
"
SSL_TIME_UNTIL_READY
"
]
flavors
)
)
{
Assert
.
ok
(
this
.
countHistogramEntries
(
h
)
=
=
=
resultCount
"
Timing
entry
count
correct
"
)
;
}
}
else
{
for
(
let
h
of
this
.
getHistograms
(
[
"
SSL_TIME_UNTIL_READY
"
]
flavors
)
)
{
Assert
.
ok
(
this
.
countHistogramEntries
(
h
)
=
=
=
0
"
No
timing
entries
expected
"
)
;
}
}
}
checkSuccess
(
flavors
resultCount
=
1
)
{
this
.
checkEntry
(
flavors
0
resultCount
)
;
}
checkEmpty
(
flavors
)
{
for
(
let
h
of
this
.
getHistogramNames
(
this
.
HISTOGRAMS
flavors
)
)
{
let
hObj
=
Services
.
telemetry
.
getHistogramById
(
h
)
;
Assert
.
ok
(
this
.
countHistogramEntries
(
hObj
)
=
=
=
0
No
entries
expected
in
{
h
.
name
}
.
Contents
:
{
JSON
.
stringify
(
hObj
.
snapshot
(
)
)
}
)
;
}
}
}
;
