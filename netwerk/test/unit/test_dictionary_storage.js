"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
test
/
head_cache
.
js
"
this
)
;
const
{
NodeHTTPSServer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
NodeServer
.
sys
.
mjs
"
)
;
const
TEST_DICTIONARIES
=
{
small
:
{
id
:
"
test
-
dict
-
small
"
content
:
"
COMMON_PREFIX_DATA_FOR_COMPRESSION
"
pattern
:
"
/
api
/
v1
/
*
"
type
:
"
raw
"
}
large
:
{
id
:
"
test
-
dict
-
large
"
content
:
"
A
"
.
repeat
(
1024
*
100
)
pattern
:
"
*
.
html
"
type
:
"
raw
"
}
large_url
:
{
id
:
"
test
-
dict
-
large
-
url
"
content
:
"
large
URL
content
"
pattern
:
"
large
"
type
:
"
raw
"
}
too_large_url
:
{
id
:
"
test
-
dict
-
too
-
large
-
url
"
content
:
"
too
large
URL
content
"
pattern
:
"
too_large
"
type
:
"
raw
"
}
}
;
let
server
=
null
;
add_setup
(
async
function
(
)
{
if
(
!
server
)
{
server
=
await
setupServer
(
)
;
}
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
}
)
;
async
function
calculateSHA256
(
data
)
{
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
Ci
.
nsICryptoHash
.
SHA256
)
;
let
bytes
=
new
TextEncoder
(
)
.
encode
(
data
)
;
hasher
.
update
(
bytes
bytes
.
length
)
;
return
hasher
.
finish
(
false
)
;
}
async
function
setupServer
(
)
{
let
httpServer
=
new
NodeHTTPSServer
(
)
;
await
httpServer
.
start
(
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
small
"
function
(
request
response
)
{
const
TEST_DICTIONARIES
=
{
small
:
{
id
:
"
test
-
dict
-
small
"
content
:
"
COMMON_PREFIX_DATA_FOR_COMPRESSION
"
pattern
:
"
/
api
/
v1
/
*
"
type
:
"
raw
"
}
}
;
let
dict
=
TEST_DICTIONARIES
.
small
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
expires
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
expires
/
*
"
id
=
"
expires
-
dict
"
type
=
raw
"
Cache
-
Control
"
:
"
max
-
age
=
1
"
}
)
;
response
.
end
(
"
EXPIRING_DICTIONARY_DATA
"
"
binary
"
)
;
}
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
invalid
"
function
(
request
response
)
{
global
.
test
=
1
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
"
invalid
-
header
-
format
"
}
)
;
response
.
end
(
"
INVALID_DICTIONARY_DATA
"
"
binary
"
)
;
}
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
large
"
function
(
request
response
)
{
const
TEST_DICTIONARIES
=
{
large
:
{
id
:
"
test
-
dict
-
large
"
content
:
"
A
"
.
repeat
(
1024
*
100
)
pattern
:
"
*
.
html
"
type
:
"
raw
"
}
}
;
let
dict
=
TEST_DICTIONARIES
.
large
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
large
/
"
+
"
A
"
.
repeat
(
1024
*
20
)
function
(
request
response
)
{
const
TEST_DICTIONARIES
=
{
large_url
:
{
id
:
"
test
-
dict
-
large
-
url
"
content
:
"
large
URL
content
"
pattern
:
"
large
"
type
:
"
raw
"
}
}
;
let
dict
=
TEST_DICTIONARIES
.
large_url
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
large
/
"
+
"
B
"
.
repeat
(
1024
*
100
)
function
(
request
response
)
{
const
TEST_DICTIONARIES
=
{
too_large_url
:
{
id
:
"
test
-
dict
-
too
-
large
-
url
"
content
:
"
too
large
URL
content
"
pattern
:
"
too_large
"
type
:
"
raw
"
}
}
;
let
dict
=
TEST_DICTIONARIES
.
too_large_url
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
try
{
await
httpServer
.
stop
(
)
;
}
catch
(
e
)
{
}
}
)
;
return
httpServer
;
}
function
verifyDictionaryStored
(
url
shouldExist
callback
)
{
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
asyncCheckCacheEntryPresence
(
url
"
disk
"
shouldExist
lci
callback
)
;
}
function
makeChan
(
url
)
{
let
chan
=
NetUtil
.
newChannel
(
{
uri
:
url
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
}
)
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
return
chan
;
}
function
channelOpenPromise
(
chan
)
{
return
new
Promise
(
resolve
=
>
{
function
finish
(
req
buffer
)
{
resolve
(
[
req
buffer
]
)
;
}
chan
.
asyncOpen
(
new
ChannelListener
(
finish
null
CL_ALLOW_UNKNOWN_CL
)
)
;
}
)
;
}
add_task
(
async
function
test_basic_dictionary_storage
(
)
{
evict_cache_entries
(
"
all
"
)
;
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
small
;
let
dict
=
TEST_DICTIONARIES
.
small
;
let
chan
=
makeChan
(
url
)
;
let
[
req
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
dict
.
content
"
Dictionary
content
matches
"
)
;
try
{
let
headerValue
=
req
.
getResponseHeader
(
"
Use
-
As
-
Dictionary
"
)
;
Assert
.
ok
(
headerValue
.
includes
(
id
=
"
{
dict
.
id
}
"
)
"
Header
contains
correct
ID
"
)
;
Assert
.
ok
(
headerValue
.
includes
(
match
=
"
{
dict
.
pattern
}
"
)
"
Header
contains
correct
pattern
"
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
Use
-
As
-
Dictionary
header
should
be
present
"
)
;
}
await
new
Promise
(
resolve
=
>
{
verifyDictionaryStored
(
url
true
resolve
)
;
}
)
;
}
)
;
add_task
(
async
function
test_dictionary_header_parsing
(
)
{
const
headerTests
=
[
{
header
:
'
match
=
"
*
"
id
=
"
dict1
"
type
=
raw
'
valid
:
true
description
:
"
Basic
valid
header
"
}
{
header
:
'
match
=
"
/
api
/
*
"
id
=
"
api
-
dict
"
type
=
raw
'
valid
:
true
description
:
"
Path
pattern
header
"
}
{
header
:
'
match
=
"
*
.
js
"
id
=
"
js
-
dict
"
'
valid
:
true
description
:
"
Header
without
type
(
should
default
to
raw
)
"
}
{
header
:
'
id
=
"
dict1
"
type
=
raw
'
valid
:
false
description
:
"
Missing
match
parameter
"
}
{
header
:
'
match
=
"
*
"
'
valid
:
false
description
:
"
Missing
id
parameter
"
}
{
header
:
'
match
=
"
*
"
id
=
"
"
type
=
raw
'
valid
:
false
description
:
"
Empty
id
parameter
"
}
]
;
let
testIndex
=
0
;
for
(
let
test
of
headerTests
)
{
let
testPath
=
/
dict
/
header
-
test
-
{
testIndex
+
+
}
;
let
func
=
global
.
testIndex
=
0
;
let
test
=
{
JSON
.
stringify
(
test
)
}
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
test
.
header
}
)
;
/
/
We
won
'
t
be
using
this
so
it
doesn
'
t
really
matter
response
.
end
(
"
HEADER_TEST_DICT_
"
+
global
.
testIndex
+
+
"
binary
"
)
;
;
let
handler
=
new
Function
(
"
request
"
"
response
"
func
)
;
await
server
.
registerPathHandler
(
testPath
handler
)
;
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
{
testPath
}
;
let
chan
=
makeChan
(
url
)
;
await
channelOpenPromise
(
chan
)
;
await
new
Promise
(
resolve
=
>
{
verifyDictionaryStored
(
url
true
resolve
)
;
}
)
;
}
}
)
;
add_task
(
async
function
test_dictionary_hash_calculation
(
)
{
dump
(
"
*
*
*
*
testing
hashes
\
n
"
)
;
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
small
;
let
dict
=
TEST_DICTIONARIES
.
small
;
let
expectedHash
=
await
calculateSHA256
(
dict
.
content
)
;
Assert
.
greater
(
expectedHash
.
length
0
"
Hash
should
be
calculated
"
)
;
let
chan
=
makeChan
(
url
)
;
await
channelOpenPromise
(
chan
)
;
let
hashCalculatedHash
=
await
calculateSHA256
(
dict
.
content
)
;
Assert
.
greater
(
hashCalculatedHash
.
length
0
"
Hash
should
be
calculated
"
)
;
await
new
Promise
(
resolve
=
>
{
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
asyncOpenCacheEntry
(
url
"
disk
"
Ci
.
nsICacheStorage
.
OPEN_READONLY
lci
function
(
status
entry
)
{
Assert
.
equal
(
status
Cr
.
NS_OK
"
Cache
entry
should
exist
"
)
;
Assert
.
ok
(
entry
"
Entry
should
not
be
null
"
)
;
try
{
let
metaData
=
entry
.
getMetaDataElement
(
"
use
-
as
-
dictionary
"
)
;
Assert
.
ok
(
metaData
"
Dictionary
metadata
should
exist
"
)
;
Assert
.
ok
(
metaData
.
includes
(
dict
.
id
)
"
Metadata
should
contain
dictionary
ID
"
)
;
}
catch
(
e
)
{
dump
(
Dictionary
metadata
access
failed
:
{
e
}
\
n
)
;
}
resolve
(
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_dictionary_expiration
(
)
{
dump
(
"
*
*
*
*
testing
expiration
\
n
"
)
;
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
expires
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
EXPIRING_DICTIONARY_DATA
"
"
Dictionary
content
matches
"
)
;
}
)
;
add_task
(
async
function
test_multiple_dictionaries_per_origin
(
)
{
dump
(
"
*
*
*
*
test
multiple
dictionaries
per
origin
\
n
"
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
api
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
'
match
=
"
/
api
/
*
"
id
=
"
api
-
dict
"
type
=
raw
'
}
)
;
response
.
end
(
"
API_DICTIONARY_DATA
"
"
binary
"
)
;
}
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
web
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
'
match
=
"
/
web
/
*
"
id
=
"
web
-
dict
"
type
=
raw
'
}
)
;
response
.
end
(
"
WEB_DICTIONARY_DATA
"
"
binary
"
)
;
}
)
;
let
apiUrl
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
api
;
let
webUrl
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
web
;
let
apiChan
=
makeChan
(
apiUrl
)
;
let
[
apiData
]
=
await
channelOpenPromise
(
apiChan
)
;
Assert
.
equal
(
apiData
"
API_DICTIONARY_DATA
"
"
API
dictionary
content
matches
"
)
;
let
webChan
=
makeChan
(
webUrl
)
;
let
[
webData
]
=
await
channelOpenPromise
(
webChan
)
;
Assert
.
equal
(
webData
"
WEB_DICTIONARY_DATA
"
"
Web
dictionary
content
matches
"
)
;
await
new
Promise
(
resolve
=
>
{
verifyDictionaryStored
(
apiUrl
true
(
)
=
>
{
verifyDictionaryStored
(
webUrl
true
resolve
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_dictionary_size_limits
(
)
{
dump
(
"
*
*
*
*
test
size
limits
\
n
"
)
;
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
large
;
let
dict
=
TEST_DICTIONARIES
.
large
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
dict
.
content
"
Large
dictionary
content
matches
"
)
;
Assert
.
equal
(
data
.
length
dict
.
content
.
length
"
Dictionary
size
correct
"
)
;
await
new
Promise
(
resolve
=
>
{
verifyDictionaryStored
(
url
true
resolve
)
;
}
)
;
}
)
;
add_task
(
async
function
test_invalid_dictionary_headers
(
)
{
dump
(
"
*
*
*
*
test
error
handling
\
n
"
)
;
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
invalid
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
INVALID_DICTIONARY_DATA
"
"
Invalid
dictionary
content
received
"
)
;
await
new
Promise
(
resolve
=
>
{
asyncOpenCacheEntry
(
url
"
disk
"
Ci
.
nsICacheStorage
.
OPEN_READONLY
null
function
(
status
entry
)
{
if
(
status
=
=
=
Cr
.
NS_OK
&
&
entry
)
{
}
resolve
(
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_dictionary_cache_persistence
(
)
{
dump
(
"
*
*
*
*
test
persistence
\
n
"
)
;
await
new
Promise
(
resolve
=
>
{
syncWithCacheIOThread
(
resolve
true
)
;
}
)
;
await
new
Promise
(
resolve
=
>
{
get_device_entry_count
(
"
disk
"
null
entryCount
=
>
{
Assert
.
greater
(
entryCount
0
"
Cache
should
have
entries
"
)
;
resolve
(
)
;
}
)
;
}
)
;
let
smallUrl
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
small
;
let
chan
=
makeChan
(
smallUrl
)
;
await
channelOpenPromise
(
chan
)
;
await
new
Promise
(
resolve
=
>
{
verifyDictionaryStored
(
smallUrl
true
resolve
)
;
}
)
;
}
)
;
add_task
(
async
function
test_long_dictionary_url
(
)
{
evict_cache_entries
(
"
all
"
)
;
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
large
/
+
"
A
"
.
repeat
(
1024
*
20
)
;
let
dict
=
TEST_DICTIONARIES
.
large_url
;
let
chan
=
makeChan
(
url
)
;
let
[
req
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
dict
.
content
"
Dictionary
content
matches
"
)
;
await
new
Promise
(
resolve
=
>
{
verifyDictionaryStored
(
url
true
resolve
)
;
}
)
;
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
large
;
chan
=
makeChan
(
url
)
;
[
req
data
]
=
await
channelOpenPromise
(
chan
)
;
try
{
let
headerValue
=
req
.
getRequestHeader
(
"
Available
-
Dictionary
"
)
;
Assert
.
ok
(
headerValue
.
includes
(
:
)
"
Header
contains
a
hash
"
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
Available
-
Dictionary
header
should
be
present
with
long
URL
for
dictionary
"
)
;
}
}
)
;
add_task
(
async
function
test_too_long_dictionary_url
(
)
{
evict_cache_entries
(
"
all
"
)
;
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
large
/
+
"
B
"
.
repeat
(
1024
*
100
)
;
let
dict
=
TEST_DICTIONARIES
.
too_large_url
;
let
chan
=
makeChan
(
url
)
;
let
[
req
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
dict
.
content
"
Dictionary
content
matches
"
)
;
await
new
Promise
(
resolve
=
>
{
verifyDictionaryStored
(
url
true
resolve
)
;
}
)
;
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
too_large
;
chan
=
makeChan
(
url
)
;
[
req
data
]
=
await
channelOpenPromise
(
chan
)
;
try
{
let
headerValue
=
req
.
getRequestHeader
(
"
Available
-
Dictionary
"
)
;
Assert
.
ok
(
false
"
Too
-
long
dictionary
was
offered
in
Available
-
Dictionary
"
)
;
}
catch
(
e
)
{
Assert
.
ok
(
true
"
Available
-
Dictionary
header
should
not
be
present
with
a
too
-
long
URL
for
dictionary
"
)
;
}
}
)
;
add_task
(
async
function
cleanup
(
)
{
evict_cache_entries
(
"
all
"
)
;
dump
(
"
*
*
*
*
all
done
\
n
"
)
;
}
)
;
