add_setup
(
function
test_setup
(
)
{
Services
.
prefs
.
setIntPref
(
"
network
.
cookie
.
cookieBehavior
"
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
cookieJarSettings
.
unblocked_for_testing
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
cookie
.
cookieBehavior
.
optInPartitioning
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
cookie
.
CHIPS
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
cookie
.
chips
.
partitionLimitEnabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
cookie
.
chips
.
partitionLimitDryRun
"
false
)
;
Services
.
prefs
.
setIntPref
(
"
network
.
cookie
.
chips
.
partitionLimitByteCapacity
"
24
)
;
}
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
network
.
cookie
.
cookieBehavior
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
cookie
.
cookieBehavior
.
optInPartitioning
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
cookieJarSettings
.
unblocked_for_testing
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
cookie
.
CHIPS
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
cookie
.
chips
.
partitionLimitEnabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
cookie
.
chips
.
partitionLimitDryRun
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
cookie
.
chips
.
partitionLimitByteCapacity
"
)
;
Services
.
cookies
.
removeAll
(
)
;
}
)
;
function
addChipsCookie
(
name
value
host
expiry
lastAccessed
creationTime
db
)
{
let
cookie
=
new
Cookie
(
name
value
host
"
/
"
expiry
lastAccessed
creationTime
false
true
false
false
{
partitionKey
:
"
(
https
example
.
com
)
"
}
Ci
.
nsICookie
.
SAMESITE_UNSET
Ci
.
nsICookie
.
SCHEME_UNSET
true
)
;
db
.
insertCookie
(
cookie
)
;
}
add_task
(
async
function
test_purge_crash
(
)
{
let
profile
=
do_get_profile
(
)
;
let
dbFile
=
do_get_cookie_file
(
profile
)
;
Assert
.
ok
(
!
dbFile
.
exists
(
)
)
;
let
schemaDb
=
new
CookieDatabaseConnection
(
dbFile
15
)
;
let
now
=
Date
.
now
(
)
*
1000
;
let
past
=
Math
.
round
(
now
/
1e3
-
1000
)
;
let
future
=
Math
.
round
(
now
/
1e3
+
1000
)
+
20000
;
let
host
=
"
example
.
com
"
;
addChipsCookie
(
"
c4
"
"
4
"
host
future
past
+
4000
past
schemaDb
)
;
addChipsCookie
(
"
c5
"
"
5
"
host
future
past
+
4000
past
schemaDb
)
;
addChipsCookie
(
"
c6
"
"
6
"
host
future
past
+
4000
past
schemaDb
)
;
addChipsCookie
(
"
c7
"
"
7
"
host
future
past
+
4000
past
schemaDb
)
;
addChipsCookie
(
"
c8
"
"
8
"
host
future
past
+
4000
past
schemaDb
)
;
addChipsCookie
(
"
c1
"
"
1
"
host
future
past
past
schemaDb
)
;
addChipsCookie
(
"
c2
"
"
2
"
host
future
past
+
3000
past
schemaDb
)
;
addChipsCookie
(
"
c3
"
"
3
"
host
future
past
+
2000
past
schemaDb
)
;
Assert
.
equal
(
do_count_cookies_in_db
(
schemaDb
.
db
)
8
)
;
Assert
.
equal
(
do_count_cookies_in_db
(
schemaDb
.
db
"
example
.
com
"
)
8
)
;
const
PATH_EMPTY
=
"
/
"
;
const
FIRST_PARTY
=
"
example
.
com
"
;
const
URL_DOCUMENT_FIRSTPARTY
=
"
https
:
/
/
"
+
FIRST_PARTY
+
PATH_EMPTY
;
function
createPartitionKey
(
url
)
{
let
uri
=
NetUtil
.
newURI
(
url
)
;
return
(
{
uri
.
scheme
}
{
uri
.
host
}
)
;
}
function
createOriginAttributes
(
partitionKey
)
{
return
JSON
.
stringify
(
{
firstPartyDomain
:
"
"
geckoViewSessionContextId
:
"
"
inIsolatedMozBrowser
:
false
partitionKey
privateBrowsingId
:
0
userContextId
:
0
}
)
;
}
const
partitionedOAs
=
createOriginAttributes
(
createPartitionKey
(
URL_DOCUMENT_FIRSTPARTY
)
)
;
let
partitioned
=
Services
.
cookies
.
getCookiesWithOriginAttributes
(
partitionedOAs
FIRST_PARTY
)
;
Assert
.
equal
(
partitioned
.
length
8
)
;
const
cv
=
Services
.
cookies
.
add
(
host
"
/
"
"
cxxxxx
"
"
yyyyyy
"
true
false
true
future
{
partitionKey
:
"
(
https
example
.
com
)
"
}
Ci
.
nsICookie
.
SAMESITE_UNSET
Ci
.
nsICookie
.
SCHEME_HTTPS
true
)
;
Assert
.
equal
(
cv
.
result
Ci
.
nsICookieValidation
.
eOK
"
Valid
cookie
"
)
;
let
postPurgeCookies
=
Services
.
cookies
.
getCookiesWithOriginAttributes
(
partitionedOAs
FIRST_PARTY
)
;
Assert
.
equal
(
postPurgeCookies
.
length
5
)
;
schemaDb
.
close
(
)
;
}
)
;
