const
pps
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
-
proxy
-
service
;
1
"
]
.
getService
(
)
;
const
{
NodeServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
let
proxy_port
;
let
server_port
;
let
proxy_id
;
let
filter
;
const
proxy_auth
=
"
authorization
-
token
"
;
let
proxy_isolation
;
class
ProxyFilter
{
constructor
(
type
host
port
flags
)
{
this
.
_type
=
type
;
this
.
_host
=
host
;
this
.
_port
=
port
;
this
.
_flags
=
flags
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIProtocolProxyFilter
]
)
;
}
applyFilter
(
pps
uri
pi
cb
)
{
if
(
uri
.
pathQueryRef
=
=
"
/
execute
"
)
{
cb
.
onProxyFilterResult
(
pi
)
;
return
;
}
cb
.
onProxyFilterResult
(
pps
.
newProxyInfo
(
this
.
_type
this
.
_host
this
.
_port
proxy_auth
proxy_isolation
this
.
_flags
1000
null
)
)
;
}
}
class
UnxpectedAuthPrompt2
{
constructor
(
signal
)
{
this
.
signal
=
signal
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAuthPrompt2
]
)
;
}
asyncPromptAuth
(
)
{
this
.
signal
.
triggered
=
true
;
throw
Cr
.
ERROR_UNEXPECTED
;
}
}
class
AuthRequestor
{
constructor
(
prompt
)
{
this
.
prompt
=
prompt
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIInterfaceRequestor
]
)
;
}
getInterface
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIAuthPrompt2
)
)
{
return
this
.
prompt
(
)
;
}
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
}
function
make_channel
(
url
)
{
return
NetUtil
.
newChannel
(
{
uri
:
url
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
}
)
;
}
function
get_response
(
channel
flags
=
CL_ALLOW_UNKNOWN_CL
)
{
return
new
Promise
(
resolve
=
>
{
channel
.
asyncOpen
(
new
ChannelListener
(
(
request
data
)
=
>
{
request
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
const
status
=
request
.
status
;
const
http_code
=
status
?
undefined
:
request
.
responseStatus
;
resolve
(
{
status
http_code
data
}
)
;
}
null
flags
)
)
;
}
)
;
}
let
initial_session_count
=
0
;
function
proxy_session_counter
(
)
{
return
new
Promise
(
async
resolve
=
>
{
let
data
=
await
NodeServer
.
execute
(
proxySessionCount
(
"
{
proxy_id
}
"
)
)
;
resolve
(
parseInt
(
data
)
-
initial_session_count
)
;
}
)
;
}
add_task
(
async
function
setup
(
)
{
do_get_profile
(
)
;
let
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
addCertFromFile
(
certdb
"
http2
-
ca
.
pem
"
"
CTu
u
u
"
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
server_port
=
env
.
get
(
"
MOZHTTP2_PORT
"
)
;
Assert
.
notEqual
(
server_port
null
)
;
let
proxy
=
await
NodeServer
.
execute
(
startNewProxy
(
)
)
;
proxy_port
=
proxy
.
port
;
proxy_id
=
proxy
.
name
;
Assert
.
notEqual
(
proxy_port
null
)
;
Services
.
prefs
.
setStringPref
(
"
services
.
settings
.
server
"
http
:
/
/
localhost
:
{
proxy_port
+
1
}
/
remote
-
settings
-
dummy
/
v1
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
http
.
spdy
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
http
.
spdy
.
enabled
.
http2
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
dns
.
native
-
is
-
localhost
"
true
)
;
filter
=
new
ProxyFilter
(
"
https
"
"
localhost
"
proxy_port
0
)
;
pps
.
registerFilter
(
filter
10
)
;
initial_session_count
=
await
proxy_session_counter
(
)
;
info
(
Initial
proxy
session
count
=
{
initial_session_count
}
)
;
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
services
.
settings
.
server
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
http
.
spdy
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
http
.
spdy
.
enabled
.
http2
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
dns
.
native
-
is
-
localhost
"
)
;
pps
.
unregisterFilter
(
filter
)
;
await
NodeServer
.
execute
(
closeProxy
(
"
{
proxy_id
}
"
)
)
;
}
)
;
add_task
(
async
function
proxy_success_one_session
(
)
{
proxy_isolation
=
"
TOKEN1
"
;
const
foo
=
await
get_response
(
make_channel
(
https
:
/
/
foo
.
example
.
com
/
random
-
request
-
1
)
)
;
const
alt1
=
await
get_response
(
make_channel
(
https
:
/
/
alt1
.
example
.
com
/
random
-
request
-
2
)
)
;
Assert
.
equal
(
foo
.
status
Cr
.
NS_OK
)
;
Assert
.
equal
(
foo
.
http_code
200
)
;
Assert
.
ok
(
foo
.
data
.
match
(
"
random
-
request
-
1
"
)
)
;
Assert
.
ok
(
foo
.
data
.
match
(
"
You
Win
!
"
)
)
;
Assert
.
equal
(
alt1
.
status
Cr
.
NS_OK
)
;
Assert
.
equal
(
alt1
.
http_code
200
)
;
Assert
.
ok
(
alt1
.
data
.
match
(
"
random
-
request
-
2
"
)
)
;
Assert
.
ok
(
alt1
.
data
.
match
(
"
You
Win
!
"
)
)
;
Assert
.
equal
(
await
proxy_session_counter
(
)
1
"
Created
just
one
session
with
the
proxy
"
)
;
}
)
;
add_task
(
async
function
proxy_auth_failure
(
)
{
const
chan
=
make_channel
(
https
:
/
/
407
.
example
.
com
/
)
;
const
auth_prompt
=
{
triggered
:
false
}
;
chan
.
notificationCallbacks
=
new
AuthRequestor
(
(
)
=
>
new
UnxpectedAuthPrompt2
(
auth_prompt
)
)
;
const
{
status
http_code
}
=
await
get_response
(
chan
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
status
Cr
.
NS_ERROR_PROXY_AUTHENTICATION_FAILED
)
;
Assert
.
equal
(
http_code
undefined
)
;
Assert
.
equal
(
auth_prompt
.
triggered
false
"
Auth
prompt
didn
'
t
trigger
"
)
;
Assert
.
equal
(
await
proxy_session_counter
(
)
1
"
No
new
session
created
by
407
"
)
;
}
)
;
add_task
(
async
function
proxy_bad_gateway_failure
(
)
{
const
{
status
http_code
}
=
await
get_response
(
make_channel
(
https
:
/
/
502
.
example
.
com
/
)
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
status
Cr
.
NS_ERROR_PROXY_BAD_GATEWAY
)
;
Assert
.
equal
(
http_code
undefined
)
;
Assert
.
equal
(
await
proxy_session_counter
(
)
1
"
No
new
session
created
by
502
after
407
"
)
;
}
)
;
add_task
(
async
function
proxy_bad_gateway_failure_two
(
)
{
const
{
status
http_code
}
=
await
get_response
(
make_channel
(
https
:
/
/
502
.
example
.
com
/
)
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
status
Cr
.
NS_ERROR_PROXY_BAD_GATEWAY
)
;
Assert
.
equal
(
http_code
undefined
)
;
Assert
.
equal
(
await
proxy_session_counter
(
)
1
"
No
new
session
created
by
second
502
"
)
;
}
)
;
add_task
(
async
function
proxy_gateway_timeout_failure
(
)
{
const
{
status
http_code
}
=
await
get_response
(
make_channel
(
https
:
/
/
504
.
example
.
com
/
)
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
status
Cr
.
NS_ERROR_PROXY_GATEWAY_TIMEOUT
)
;
Assert
.
equal
(
http_code
undefined
)
;
Assert
.
equal
(
await
proxy_session_counter
(
)
1
"
No
new
session
created
by
504
after
502
"
)
;
}
)
;
add_task
(
async
function
proxy_host_not_found_failure
(
)
{
const
{
status
http_code
}
=
await
get_response
(
make_channel
(
https
:
/
/
404
.
example
.
com
/
)
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
status
Cr
.
NS_ERROR_UNKNOWN_HOST
)
;
Assert
.
equal
(
http_code
undefined
)
;
Assert
.
equal
(
await
proxy_session_counter
(
)
1
"
No
new
session
created
by
404
after
504
"
)
;
}
)
;
add_task
(
async
function
proxy_too_many_requests_failure
(
)
{
const
{
status
http_code
}
=
await
get_response
(
make_channel
(
https
:
/
/
429
.
example
.
com
/
)
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
status
Cr
.
NS_ERROR_TOO_MANY_REQUESTS
)
;
Assert
.
equal
(
http_code
undefined
)
;
Assert
.
equal
(
await
proxy_session_counter
(
)
1
"
No
new
session
created
by
429
after
504
"
)
;
}
)
;
add_task
(
async
function
proxy_success_still_one_session
(
)
{
const
foo
=
await
get_response
(
make_channel
(
https
:
/
/
foo
.
example
.
com
/
random
-
request
-
1
)
)
;
const
alt1
=
await
get_response
(
make_channel
(
https
:
/
/
alt1
.
example
.
com
/
random
-
request
-
2
)
)
;
Assert
.
equal
(
foo
.
status
Cr
.
NS_OK
)
;
Assert
.
equal
(
foo
.
http_code
200
)
;
Assert
.
ok
(
foo
.
data
.
match
(
"
random
-
request
-
1
"
)
)
;
Assert
.
equal
(
alt1
.
status
Cr
.
NS_OK
)
;
Assert
.
equal
(
alt1
.
http_code
200
)
;
Assert
.
ok
(
alt1
.
data
.
match
(
"
random
-
request
-
2
"
)
)
;
Assert
.
equal
(
await
proxy_session_counter
(
)
1
"
No
new
session
created
after
proxy
error
codes
"
)
;
}
)
;
add_task
(
async
function
proxy_success_isolated_session
(
)
{
Assert
.
notEqual
(
proxy_isolation
"
TOKEN2
"
)
;
proxy_isolation
=
"
TOKEN2
"
;
const
foo
=
await
get_response
(
make_channel
(
https
:
/
/
foo
.
example
.
com
/
random
-
request
-
1
)
)
;
const
alt1
=
await
get_response
(
make_channel
(
https
:
/
/
alt1
.
example
.
com
/
random
-
request
-
2
)
)
;
const
lh
=
await
get_response
(
make_channel
(
https
:
/
/
localhost
/
random
-
request
-
3
)
)
;
Assert
.
equal
(
foo
.
status
Cr
.
NS_OK
)
;
Assert
.
equal
(
foo
.
http_code
200
)
;
Assert
.
ok
(
foo
.
data
.
match
(
"
random
-
request
-
1
"
)
)
;
Assert
.
ok
(
foo
.
data
.
match
(
"
You
Win
!
"
)
)
;
Assert
.
equal
(
alt1
.
status
Cr
.
NS_OK
)
;
Assert
.
equal
(
alt1
.
http_code
200
)
;
Assert
.
ok
(
alt1
.
data
.
match
(
"
random
-
request
-
2
"
)
)
;
Assert
.
ok
(
alt1
.
data
.
match
(
"
You
Win
!
"
)
)
;
Assert
.
equal
(
lh
.
status
Cr
.
NS_OK
)
;
Assert
.
equal
(
lh
.
http_code
200
)
;
Assert
.
ok
(
lh
.
data
.
match
(
"
random
-
request
-
3
"
)
)
;
Assert
.
ok
(
lh
.
data
.
match
(
"
You
Win
!
"
)
)
;
Assert
.
equal
(
await
proxy_session_counter
(
)
2
"
Just
one
new
session
seen
after
changing
the
isolation
key
"
)
;
}
)
;
add_task
(
async
function
proxy_bad_gateway_failure_isolated
(
)
{
const
failure1
=
await
get_response
(
make_channel
(
https
:
/
/
502
.
example
.
com
/
)
CL_EXPECT_FAILURE
)
;
const
failure2
=
await
get_response
(
make_channel
(
https
:
/
/
502
.
example
.
com
/
)
CL_EXPECT_FAILURE
)
;
Assert
.
equal
(
failure1
.
status
Cr
.
NS_ERROR_PROXY_BAD_GATEWAY
)
;
Assert
.
equal
(
failure1
.
http_code
undefined
)
;
Assert
.
equal
(
failure2
.
status
Cr
.
NS_ERROR_PROXY_BAD_GATEWAY
)
;
Assert
.
equal
(
failure2
.
http_code
undefined
)
;
Assert
.
equal
(
await
proxy_session_counter
(
)
2
"
No
new
session
created
by
502
"
)
;
}
)
;
