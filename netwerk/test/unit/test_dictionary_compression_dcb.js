"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
test
/
head_cache
.
js
"
this
)
;
const
{
NodeHTTPSServer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
NodeServer
.
sys
.
mjs
"
)
;
const
DCB_TEST_DICTIONARIES
=
{
html_common
:
{
id
:
"
html
-
dict
"
content
:
'
<
html
>
<
head
>
<
title
>
Common
HTML
Template
<
/
title
>
<
/
head
>
<
body
>
<
div
class
=
"
container
"
>
<
p
>
'
expected_length
:
15
pattern
:
"
*
.
html
"
type
:
"
raw
"
}
html_common_no_dictionary
:
{
id
:
"
html
-
dict
"
content
:
'
<
html
>
<
head
>
<
title
>
Common
HTML
Template
<
/
title
>
<
/
head
>
<
body
>
<
div
class
=
"
container
"
>
<
p
>
'
expected_length
:
196
pattern
:
"
*
.
html
"
type
:
"
raw
"
}
api_json
:
{
id
:
"
api
-
dict
"
content
:
'
{
"
status
"
:
"
success
"
"
data
"
:
{
"
id
"
:
null
"
name
"
:
"
"
"
created_at
"
:
"
"
"
updated_at
"
:
"
"
}
"
message
"
:
"
"
"
errors
"
:
[
]
}
'
expected_length
:
15
pattern
:
"
/
api
/
*
"
type
:
"
raw
"
}
api_v1
:
{
id
:
"
longer
-
match
-
dict
"
content
:
'
{
"
status
"
:
"
success
"
"
data
"
:
{
"
id
"
:
null
"
name
"
:
"
"
"
created_at
"
:
"
"
"
updated_at
"
:
"
"
}
"
message
"
:
"
"
"
errors
"
:
[
]
}
'
expected_length
:
15
pattern
:
"
/
api
/
v1
/
*
"
type
:
"
raw
"
}
js_common
:
{
id
:
"
js
-
dict
"
content
:
"
function
(
)
{
return
this
;
}
;
var
=
function
(
)
;
const
=
function
(
)
;
let
=
function
(
)
;
"
expected_length
:
15
pattern
:
"
*
.
js
"
type
:
"
raw
"
}
large_dict
:
{
id
:
"
large
-
dict
"
content
:
"
REPEATED_PATTERN_
"
.
repeat
(
1000
)
expected_length
:
15
pattern
:
"
/
large
/
*
"
type
:
"
raw
"
}
}
;
const
DCB_TEST_CONTENT
=
{
html_page
:
'
<
html
>
<
head
>
<
title
>
Test
Page
<
/
title
>
<
/
head
>
<
body
>
<
div
class
=
"
container
"
>
<
p
>
This
is
test
content
that
should
compress
well
with
the
HTML
dictionary
.
<
/
p
>
<
p
>
More
content
here
.
<
/
p
>
<
/
div
>
<
/
body
>
<
/
html
>
'
api_response
:
'
{
"
status
"
:
"
success
"
"
data
"
:
{
"
id
"
:
12345
"
name
"
:
"
Test
User
"
"
created_at
"
:
"
2024
-
01
-
01T00
:
00
:
00Z
"
"
updated_at
"
:
"
2024
-
01
-
02T12
:
00
:
00Z
"
}
"
message
"
:
"
User
retrieved
successfully
"
"
errors
"
:
[
]
}
'
api_v1
:
'
{
"
status
"
:
"
success
"
"
data
"
:
{
"
id
"
:
12345
"
name
"
:
"
Test
User
"
"
created_at
"
:
"
2024
-
01
-
01T00
:
00
:
00Z
"
"
updated_at
"
:
"
2024
-
01
-
02T12
:
00
:
00Z
"
}
"
message
"
:
"
User
retrieved
successfully
"
"
errors
"
:
[
]
}
'
js_code
:
'
function
testFunction
(
)
{
return
this
.
value
;
}
;
var
result
=
function
(
)
{
console
.
log
(
"
test
"
)
;
}
;
const
API_URL
=
function
(
)
{
return
"
https
:
/
/
api
.
example
.
com
"
;
}
;
let
userData
=
function
(
)
{
return
{
id
:
1
name
:
"
test
"
}
;
}
'
large_content
:
"
REPEATED_PATTERN_DATA_CHUNK_
"
.
repeat
(
50000
)
jpeg
:
"
ARBITRARY_DATA_
"
.
repeat
(
1000
)
}
;
let
server
=
null
;
let
requestLog
=
[
]
;
function
makeChan
(
url
)
{
let
chan
=
NetUtil
.
newChannel
(
{
uri
:
url
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
}
)
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
return
chan
;
}
function
channelOpenPromise
(
chan
)
{
return
new
Promise
(
resolve
=
>
{
function
finish
(
req
buffer
)
{
resolve
(
[
req
buffer
]
)
;
}
chan
.
asyncOpen
(
new
ChannelListener
(
finish
null
CL_ALLOW_UNKNOWN_CL
|
CL_IGNORE_DELAYS
|
CL_EXPECT_GZIP
)
)
;
}
)
;
}
async
function
setupDCBTestServer
(
)
{
let
httpServer
=
new
NodeHTTPSServer
(
)
;
await
httpServer
.
start
(
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
html
"
function
(
request
response
)
{
const
DCB_TEST_DICTIONARIES
=
{
html_common
:
{
id
:
"
html
-
dict
"
content
:
'
<
html
>
<
head
>
<
title
>
Common
HTML
Template
<
/
title
>
<
/
head
>
<
body
>
<
div
class
=
"
container
"
>
<
p
>
'
pattern
:
"
*
.
html
"
type
:
"
raw
"
}
}
;
let
dict
=
DCB_TEST_DICTIONARIES
.
html_common
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
api
"
function
(
request
response
)
{
const
DCB_TEST_DICTIONARIES
=
{
api_json
:
{
id
:
"
api
-
dict
"
content
:
'
{
"
status
"
:
"
success
"
"
data
"
:
{
"
id
"
:
null
"
name
"
:
"
"
"
created_at
"
:
"
"
"
updated_at
"
:
"
"
}
"
message
"
:
"
"
"
errors
"
:
[
]
}
'
pattern
:
"
/
api
/
*
"
type
:
"
raw
"
}
}
;
let
dict
=
DCB_TEST_DICTIONARIES
.
api_json
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
js
"
function
(
request
response
)
{
const
DCB_TEST_DICTIONARIES
=
{
js_common
:
{
id
:
"
js
-
dict
"
content
:
"
function
(
)
{
return
this
;
}
;
var
=
function
(
)
;
const
=
function
(
)
;
let
=
function
(
)
;
"
pattern
:
"
*
.
js
"
type
:
"
raw
"
}
}
;
let
dict
=
DCB_TEST_DICTIONARIES
.
js_common
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
large
"
function
(
request
response
)
{
const
DCB_TEST_DICTIONARIES
=
{
large_dict
:
{
id
:
"
large
-
dict
"
content
:
"
REPEATED_PATTERN_
"
.
repeat
(
1000
)
pattern
:
"
/
large
/
*
"
type
:
"
raw
"
}
}
;
let
dict
=
DCB_TEST_DICTIONARIES
.
large_dict
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
basic
"
function
(
request
response
)
{
const
TEST_DICTIONARIES
=
{
basic
:
{
id
:
"
basic
-
dict
"
content
:
"
BASIC_DICTIONARY_DATA
"
pattern
:
"
/
api
/
*
"
type
:
"
raw
"
}
}
;
let
dict
=
TEST_DICTIONARIES
.
basic
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
await
httpServer
.
registerPathHandler
(
"
/
dict
/
longer
"
function
(
request
response
)
{
const
TEST_DICTIONARIES
=
{
specific
:
{
id
:
"
longer
-
match
-
dict
"
content
:
'
{
"
status
"
:
"
success
"
"
data
"
:
{
"
id
"
:
null
"
name
"
:
"
"
"
created_at
"
:
"
"
"
updated_at
"
:
"
"
}
"
message
"
:
"
"
"
errors
"
:
[
]
}
'
pattern
:
"
/
api
/
v1
/
*
"
type
:
"
raw
"
}
}
;
let
dict
=
TEST_DICTIONARIES
.
specific
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
{
dict
.
pattern
}
"
id
=
"
{
dict
.
id
}
"
type
=
{
dict
.
type
}
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
dict
.
content
"
binary
"
)
;
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
try
{
await
httpServer
.
stop
(
)
;
}
catch
(
e
)
{
}
}
)
;
return
httpServer
;
}
async
function
sync_to_server
(
)
{
if
(
server
.
processId
)
{
await
server
.
execute
(
global
.
requestLog
=
{
JSON
.
stringify
(
requestLog
)
}
;
)
;
}
else
{
dump
(
"
Server
not
running
?
\
n
"
)
;
}
}
async
function
sync_from_server
(
)
{
if
(
server
.
processId
)
{
dump
(
*
*
*
requestLog
:
{
JSON
.
stringify
(
requestLog
)
}
\
n
)
;
requestLog
=
await
server
.
execute
(
global
.
requestLog
)
;
}
else
{
dump
(
"
Server
not
running
?
(
from
)
\
n
"
)
;
}
}
async
function
calculateDictionaryHash
(
content
)
{
const
encoded
=
new
TextEncoder
(
)
.
encode
(
content
)
;
const
digest
=
await
crypto
.
subtle
.
digest
(
"
SHA
-
256
"
encoded
)
;
return
btoa
(
String
.
fromCharCode
(
.
.
.
new
Uint8Array
(
digest
)
)
)
;
}
function
verifyDCBResponse
(
channel
data
dictionary
)
{
Assert
.
equal
(
data
.
length
dictionary
.
expected_length
)
;
try
{
var
contentEncoding
;
channel
.
getOriginalResponseHeader
(
"
Content
-
Encoding
"
{
visitHeader
:
function
visitOrg
(
aName
aValue
)
{
contentEncoding
=
aValue
;
}
}
)
;
Assert
.
equal
;
if
(
contentEncoding
=
=
=
"
dcb
"
)
{
return
true
;
}
}
catch
(
e
)
{
}
return
false
;
}
async
function
registerDCBEndpoint
(
httpServer
path
dictionary
content
shouldCompress
=
true
)
{
let
func
=
let
path
=
"
{
path
}
"
;
let
dictionary
=
{
JSON
.
stringify
(
dictionary
)
}
;
let
content
=
'
{
content
}
'
;
let
shouldCompress
=
{
shouldCompress
}
;
let
availableDict
=
"
"
;
let
hasDictHeader
=
false
;
/
/
Get
content
type
based
on
file
path
function
getContentTypeForPath
(
path
)
{
if
(
path
.
endsWith
(
'
.
html
'
)
)
return
'
text
/
html
;
charset
=
utf
-
8
'
;
if
(
path
.
endsWith
(
'
.
js
'
)
)
return
'
application
/
javascript
'
;
if
(
path
.
includes
(
'
/
api
/
'
)
)
return
'
application
/
json
'
;
return
'
text
/
plain
;
charset
=
utf
-
8
'
;
}
/
/
Calculate
compression
ratio
function
calculateCompressionRatio
(
original
compressed
)
{
if
(
typeof
original
=
=
=
'
string
'
)
original
=
original
.
length
;
if
(
typeof
compressed
=
=
=
'
string
'
)
compressed
=
compressed
.
length
;
return
original
/
compressed
;
}
/
/
Simulate
dcb
compression
(
for
server
responses
)
function
simulateDCBCompression
(
content
dictionary
)
{
/
/
Note
:
Real
implementation
would
use
actual
Brotli
compression
/
/
For
testing
we
simulate
with
compression
markers
and
realistic
size
reduction
let
simulatedCompressedSize
=
Math
.
floor
(
content
.
length
*
0
.
4
)
;
/
/
Simulate
60
%
savings
/
/
This
needs
to
be
something
that
the
brotli
decoder
will
correctly
read
even
though
this
/
/
will
produce
the
wrong
output
let
compressedData
=
"
\
x21
\
x38
\
x00
\
x04COMPRESSED_DATA
\
x03
"
;
return
{
compressedData
:
"
\
xff
\
x44
\
x43
\
x42
"
+
"
12345678901234567890123456789012
"
+
compressedData
originalSize
:
content
.
length
compressedSize
:
compressedData
.
length
+
36
compressionRatio
:
calculateCompressionRatio
(
content
.
length
simulatedCompressedSize
+
36
)
}
;
}
if
(
request
.
headers
&
&
request
.
headers
[
'
available
-
dictionary
'
]
)
{
availableDict
=
request
.
headers
[
'
available
-
dictionary
'
]
;
hasDictHeader
=
true
;
}
else
{
shouldCompress
=
false
;
}
/
/
Log
the
request
for
analysis
global
.
requestLog
[
global
.
requestLog
.
length
]
=
{
path
:
path
hasAvailableDict
:
hasDictHeader
availableDict
:
availableDict
method
:
request
.
method
}
;
if
(
shouldCompress
&
&
hasDictHeader
&
&
availableDict
.
includes
(
dictionary
.
hash
)
)
{
/
/
Simulate
dcb
compression
let
compressed
=
simulateDCBCompression
(
content
dictionary
)
;
response
.
writeHead
(
200
{
"
Content
-
Encoding
"
:
"
dcb
"
"
Content
-
Type
"
:
getContentTypeForPath
(
path
)
"
Content
-
Length
"
:
compressed
.
compressedSize
.
toString
(
)
}
)
;
/
/
In
a
real
implementation
this
would
be
actual
compressed
brotli
data
/
/
For
testing
we
simulate
the
compressed
response
/
/
Note
:
these
aren
'
t
real
dictionaries
;
we
'
ve
prepended
a
dummy
header
/
/
to
pass
the
requirements
for
a
Brotli
dictionary
-
4
byte
magic
number
/
/
plus
32
bytes
of
hash
(
which
we
don
'
t
currently
check
nor
does
Brotli
)
.
response
.
end
(
compressed
.
compressedData
"
binary
"
)
;
}
else
{
/
/
Serve
uncompressed
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
getContentTypeForPath
(
path
)
"
Content
-
Length
"
:
content
.
length
}
)
;
response
.
end
(
content
"
binary
"
)
;
}
;
let
handler
=
new
Function
(
"
request
"
"
response
"
func
)
;
return
httpServer
.
registerPathHandler
(
path
handler
)
;
}
function
verifyDictionaryStored
(
url
shouldExist
callback
)
{
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
asyncCheckCacheEntryPresence
(
url
"
disk
"
shouldExist
lci
callback
)
;
}
async
function
setupDicts
(
)
{
requestLog
=
[
]
;
await
sync_to_server
(
)
;
const
dictPaths
=
[
"
/
dict
/
html
"
"
/
dict
/
api
"
"
/
dict
/
js
"
"
/
dict
/
large
"
"
/
dict
/
longer
"
]
;
const
dictKeys
=
[
"
html_common
"
"
api_json
"
"
js_common
"
"
large_dict
"
"
api_v1
"
]
;
for
(
let
i
=
0
;
i
<
dictPaths
.
length
;
i
+
+
)
{
let
path
=
dictPaths
[
i
]
;
let
dictKey
=
dictKeys
[
i
]
;
let
url
=
{
server
.
origin
(
)
}
{
path
}
;
dump
(
registering
dictionary
{
path
}
for
match
patter
{
DCB_TEST_DICTIONARIES
[
dictKey
]
.
patterh
}
\
n
)
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
DCB_TEST_DICTIONARIES
[
dictKey
]
.
hash
=
"
:
"
+
(
await
calculateDictionaryHash
(
DCB_TEST_DICTIONARIES
[
dictKey
]
.
content
)
)
+
"
:
"
;
Assert
.
equal
(
data
DCB_TEST_DICTIONARIES
[
dictKey
]
.
content
Dictionary
content
matches
)
;
await
new
Promise
(
resolve
=
>
{
verifyDictionaryStored
(
url
true
resolve
)
;
}
)
;
}
dump
(
*
*
*
*
DCB
test
setup
complete
.
Dictionaries
stored
with
hashes
.
\
n
)
;
}
add_setup
(
async
function
(
)
{
if
(
!
server
)
{
server
=
await
setupDCBTestServer
(
)
;
}
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
await
setupDicts
(
)
;
}
)
;
add_task
(
async
function
test_basic_dcb_compression
(
)
{
dump
(
"
*
*
*
*
test_basic_dcb_compression
\
n
"
)
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
let
dict
=
DCB_TEST_DICTIONARIES
.
html_common
;
let
content
=
DCB_TEST_CONTENT
.
html_page
;
await
registerDCBEndpoint
(
server
"
/
test
.
html
"
dict
content
true
)
;
let
url
=
{
server
.
origin
(
)
}
/
test
.
html
;
let
chan
=
makeChan
(
url
)
;
let
[
request
data
]
=
await
channelOpenPromise
(
chan
)
;
let
usedDCB
=
verifyDCBResponse
(
request
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
data
dict
)
;
Assert
.
ok
(
usedDCB
"
DCB
compression
should
be
used
"
)
;
}
)
;
add_task
(
async
function
test_dcb_dictionary_selection
(
)
{
requestLog
=
[
]
;
await
sync_to_server
(
)
;
dump
(
"
*
*
*
*
Testing
DCB
dictionary
selection
\
n
"
)
;
let
htmlDict
=
DCB_TEST_DICTIONARIES
.
html_common
;
let
apiDict
=
DCB_TEST_DICTIONARIES
.
api_json
;
await
registerDCBEndpoint
(
server
"
/
specific
-
test
.
html
"
htmlDict
DCB_TEST_CONTENT
.
html_page
true
)
;
await
registerDCBEndpoint
(
server
"
/
api
/
specific
-
test
"
apiDict
DCB_TEST_CONTENT
.
api_response
true
)
;
let
htmlUrl
=
{
server
.
origin
(
)
}
/
specific
-
test
.
html
;
let
htmlChan
=
makeChan
(
htmlUrl
)
;
let
[
htmlData
]
=
await
channelOpenPromise
(
htmlChan
)
;
Assert
.
greater
(
htmlData
.
length
0
"
HTML
dictionary
selection
test
should
have
content
"
)
;
await
sync_from_server
(
)
;
let
htmlLogEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
"
/
specific
-
test
.
html
"
)
;
Assert
.
ok
(
htmlLogEntry
&
&
htmlLogEntry
.
hasAvailableDict
"
Dictionary
selection
test
:
HTML
endpoint
received
Available
-
Dictionary
header
"
)
;
let
apiUrl
=
{
server
.
origin
(
)
}
/
api
/
specific
-
test
;
let
apiChan
=
makeChan
(
apiUrl
)
;
let
[
apiData
]
=
await
channelOpenPromise
(
apiChan
)
;
Assert
.
greater
(
apiData
.
length
0
"
API
dictionary
selection
test
should
have
content
"
)
;
await
sync_from_server
(
)
;
let
apiLogEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
"
/
api
/
specific
-
test
"
)
;
Assert
.
ok
(
apiLogEntry
&
&
apiLogEntry
.
hasAvailableDict
"
Dictionary
selection
test
:
API
endpoint
received
Available
-
Dictionary
header
"
)
;
}
)
;
add_task
(
async
function
test_dcb_missing_dictionary
(
)
{
requestLog
=
[
]
;
await
sync_to_server
(
)
;
dump
(
"
*
*
*
*
Testing
DCB
missing
dictionary
\
n
"
)
;
let
fakeDict
=
{
id
:
"
missing
-
dict
"
hash
:
"
fake_hash_that_does_not_exist
"
content
:
"
This
dictionary
was
not
stored
"
expected_length
:
DCB_TEST_CONTENT
.
jpeg
.
length
}
;
await
registerDCBEndpoint
(
server
"
/
missing
-
dict
-
test
.
jpeg
"
fakeDict
DCB_TEST_CONTENT
.
jpeg
false
)
;
let
url
=
{
server
.
origin
(
)
}
/
missing
-
dict
-
test
.
jpeg
;
let
chan
=
makeChan
(
url
)
;
let
[
request
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
greater
(
data
.
length
0
"
Missing
dictionary
test
should
still
return
content
"
)
;
let
usedDCB
=
verifyDCBResponse
(
request
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
data
fakeDict
)
;
Assert
.
ok
(
!
usedDCB
"
We
should
not
get
DCB
encoding
for
a
fake
item
"
)
;
}
)
;
add_task
(
async
function
test_dcb_header_compliance
(
)
{
requestLog
=
[
]
;
await
sync_to_server
(
)
;
dump
(
"
*
*
*
*
Testing
DCB
header
compliance
\
n
"
)
;
let
dict
=
DCB_TEST_DICTIONARIES
.
api_json
;
await
registerDCBEndpoint
(
server
"
/
api
/
compliance
-
test
"
dict
DCB_TEST_CONTENT
.
api_response
true
)
;
let
url
=
{
server
.
origin
(
)
}
/
api
/
compliance
-
test
;
let
chan
=
makeChan
(
url
)
;
let
[
request
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
greater
(
data
.
length
0
"
IETF
compliance
test
should
have
content
"
)
;
let
httpChannel
=
request
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
try
{
let
contentType
=
httpChannel
.
getResponseHeader
(
"
Content
-
Type
"
)
;
Assert
.
ok
(
contentType
.
includes
(
"
application
/
json
"
)
"
Content
-
Type
should
be
preserved
through
compression
"
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
Content
-
Type
header
should
be
present
"
)
;
}
await
sync_from_server
(
)
;
let
logEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
"
/
api
/
compliance
-
test
"
)
;
Assert
.
ok
(
logEntry
&
&
logEntry
.
hasAvailableDict
"
Must
have
available
-
dictionary
in
header
compliance
"
)
;
let
availableDict
=
logEntry
.
availableDict
;
Assert
.
ok
(
availableDict
.
startsWith
(
"
:
"
)
"
Available
-
Dictionary
should
start
with
'
:
'
(
IETF
Structured
Field
Byte
-
Sequence
format
)
"
)
;
Assert
.
ok
(
availableDict
.
endsWith
(
"
:
"
)
"
Available
-
Dictionary
should
end
with
'
:
'
(
IETF
Structured
Field
Byte
-
Sequence
format
)
"
)
;
Assert
.
greater
(
availableDict
.
length
2
"
Available
-
Dictionary
should
contain
base64
data
between
colons
"
)
;
let
base64Content
=
availableDict
.
slice
(
1
-
1
)
;
Assert
.
greater
(
base64Content
.
length
0
"
Available
-
Dictionary
should
have
base64
content
"
)
;
let
base64Regex
=
/
^
[
A
-
Za
-
z0
-
9
+
/
]
*
=
{
0
2
}
/
;
Assert
.
ok
(
base64Regex
.
test
(
base64Content
)
"
Available
-
Dictionary
content
should
be
valid
base64
"
)
;
dump
(
*
*
*
*
IETF
compliance
test
:
Available
-
Dictionary
=
{
availableDict
}
\
n
)
;
}
)
;
add_task
(
async
function
test_dcb_compression_after_cache_eviction
(
)
{
requestLog
=
[
]
;
await
sync_to_server
(
)
;
dump
(
"
*
*
*
*
Testing
DCB
compression
after
cache
eviction
\
n
"
)
;
let
dict
=
DCB_TEST_DICTIONARIES
.
html_common
;
let
dict2
=
DCB_TEST_DICTIONARIES
.
html_common_no_dictionary
;
let
testContent
=
DCB_TEST_CONTENT
.
html_page
;
let
testPath
=
"
/
cache
-
eviction
-
test
.
html
"
;
let
dictUrl
=
{
server
.
origin
(
)
}
/
dict
/
html
;
let
contentUrl
=
{
server
.
origin
(
)
}
{
testPath
}
;
dump
(
"
*
*
*
*
Step
1
:
Loading
dictionary
into
cache
\
n
"
)
;
let
dictChan
=
makeChan
(
dictUrl
)
;
let
[
dictData
]
=
await
channelOpenPromise
(
dictChan
)
;
Assert
.
equal
(
dictData
dict
.
content
"
Dictionary
loaded
successfully
"
)
;
await
new
Promise
(
resolve
=
>
{
verifyDictionaryStored
(
dictUrl
true
(
)
=
>
{
resolve
(
)
;
}
)
;
}
)
;
dump
(
"
*
*
*
*
Step
2
:
Testing
DCB
compression
with
cached
dictionary
\
n
"
)
;
await
registerDCBEndpoint
(
server
testPath
dict
testContent
true
)
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
let
chan1
=
makeChan
(
contentUrl
)
;
let
[
req1
data1
]
=
await
channelOpenPromise
(
chan1
)
;
Assert
.
greater
(
data1
.
length
0
"
Should
receive
content
before
eviction
"
)
;
let
usedDCB1
=
verifyDCBResponse
(
req1
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
data1
dict
)
;
Assert
.
ok
(
usedDCB1
"
DCB
compression
should
be
used
"
)
;
dump
(
"
*
*
*
*
Step
3
:
Evicting
dictionary
from
cache
\
n
"
)
;
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
await
new
Promise
(
resolve
=
>
{
syncWithCacheIOThread
(
resolve
true
)
;
}
)
;
dump
(
"
*
*
*
*
Step
3
.
5
:
verify
no
longer
cache
\
n
"
)
;
await
new
Promise
(
resolve
=
>
{
verifyDictionaryStored
(
dictUrl
false
(
)
=
>
{
resolve
(
)
;
}
)
;
}
)
;
dump
(
"
*
*
*
*
Step
4
:
Testing
DCB
compression
after
dictionary
eviction
\
n
"
)
;
let
chan2
=
makeChan
(
contentUrl
)
;
let
[
req2
data2
]
=
await
channelOpenPromise
(
chan2
)
;
Assert
.
greater
(
data2
.
length
0
"
Should
still
receive
content
after
eviction
"
)
;
Assert
.
ok
(
!
verifyDCBResponse
(
req2
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
data2
dict2
)
"
DCB
compression
should
not
be
used
without
dictionary
"
)
;
dump
(
"
*
*
*
*
Cache
eviction
test
completed
successfully
\
n
"
)
;
}
)
;
add_task
(
async
function
test_dcb_with_http_redirect
(
)
{
await
setupDicts
(
)
;
dump
(
"
*
*
*
*
Testing
HTTP
redirect
(
302
)
with
dictionary
-
compressed
content
\
n
"
)
;
let
dict
=
DCB_TEST_DICTIONARIES
.
html_common
;
let
content
=
DCB_TEST_CONTENT
.
html_page
;
await
registerDCBEndpoint
(
server
"
/
test
.
html
"
dict
content
true
)
;
let
originalPath
=
"
/
redirect
/
original
"
;
let
finalPath
=
"
/
test
.
html
"
;
let
originalUrl
=
{
server
.
origin
(
)
}
{
originalPath
}
;
let
finalUrl
=
{
server
.
origin
(
)
}
{
finalPath
}
;
let
redirectFunc
=
let
finalPath
=
"
{
finalPath
}
"
;
/
/
Log
the
request
for
analysis
global
.
requestLog
[
global
.
requestLog
.
length
]
=
{
path
:
"
{
originalPath
}
"
method
:
request
.
method
redirectTo
:
finalPath
hasAvailableDict
:
!
!
request
.
headers
[
'
available
-
dictionary
'
]
availableDict
:
request
.
headers
[
'
available
-
dictionary
'
]
|
|
null
}
;
response
.
writeHead
(
302
{
"
Location
"
:
finalPath
"
Cache
-
Control
"
:
"
no
-
cache
"
}
)
;
response
.
end
(
"
Redirecting
.
.
.
"
)
;
;
let
redirectHandler
=
new
Function
(
"
request
"
"
response
"
redirectFunc
)
;
await
server
.
registerPathHandler
(
originalPath
redirectHandler
)
;
await
registerDCBEndpoint
(
server
finalPath
dict
content
true
)
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
let
chan
=
makeChan
(
originalUrl
)
;
let
[
req
data
]
=
await
channelOpenPromise
(
chan
)
;
let
finalUri
=
req
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
.
URI
.
spec
;
Assert
.
equal
(
finalUri
finalUrl
"
Final
URI
should
match
the
redirected
URL
after
302
redirect
"
)
;
Assert
.
greater
(
data
.
length
0
"
Should
receive
content
after
redirect
"
)
;
await
sync_from_server
(
)
;
let
redirectEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
originalPath
)
;
let
finalEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
finalPath
)
;
Assert
.
ok
(
redirectEntry
"
Redirect
request
should
be
logged
"
)
;
Assert
.
ok
(
finalEntry
"
Final
request
should
be
logged
"
)
;
if
(
redirectEntry
.
hasAvailableDict
)
{
dump
(
*
*
*
*
Redirect
request
includes
Available
-
Dictionary
header
\
n
)
;
}
else
{
dump
(
*
*
*
*
Redirect
request
does
not
include
Available
-
Dictionary
header
(
expected
)
\
n
)
;
}
Assert
.
ok
(
finalEntry
.
hasAvailableDict
"
Final
request
includes
Available
-
Dictionary
header
"
)
;
Assert
.
ok
(
finalEntry
.
availableDict
.
includes
(
dict
.
hash
)
"
Final
request
Available
-
Dictionary
should
contain
correct
dictionary
hash
"
)
;
Assert
.
ok
(
verifyDCBResponse
(
req
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
data
dict
)
"
DCB
compression
successfully
applied
after
redirect
"
)
;
}
)
;
add_task
(
async
function
test_use_as_dictionary_invalid_missing_match
(
)
{
await
server
.
registerPathHandler
(
"
/
dict
/
invalid
-
missing
-
match
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
id
=
"
missing
-
match
-
dict
"
type
=
raw
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
"
INVALID_MISSING_MATCH_DATA
"
"
binary
"
)
;
}
)
;
let
url
=
{
server
.
origin
(
)
}
/
dict
/
invalid
-
missing
-
match
;
let
chan
=
makeChan
(
url
)
;
let
[
req
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
INVALID_MISSING_MATCH_DATA
"
"
Set
up
missing
match
dictionary
"
)
;
let
dict
=
DCB_TEST_DICTIONARIES
.
html_common_no_dictionary
;
let
content
=
DCB_TEST_CONTENT
.
html_page
;
await
registerDCBEndpoint
(
server
"
/
invalid
/
missing
-
match
"
dict
content
true
)
;
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
invalid
/
missing
-
match
;
chan
=
makeChan
(
url
)
;
[
req
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
content
"
Content
received
"
)
;
Assert
.
ok
(
!
verifyDCBResponse
(
req
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
data
dict
)
"
DCB
compression
should
not
be
used
when
dictionary
has
no
match
=
"
)
;
dump
(
"
*
*
*
*
Missing
match
parameter
test
complete
\
n
"
)
;
}
)
;
add_task
(
async
function
test_use_as_dictionary_invalid_empty_id
(
)
{
await
server
.
registerPathHandler
(
"
/
dict
/
invalid
-
empty
-
id
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
match
=
"
/
invalid
/
*
"
id
=
"
"
type
=
raw
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
"
INVALID_EMPTY_ID_DATA
"
"
binary
"
)
;
}
)
;
let
url
=
{
server
.
origin
(
)
}
/
dict
/
invalid
-
empty
-
id
;
let
chan
=
makeChan
(
url
)
;
let
[
req
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
INVALID_EMPTY_ID_DATA
"
"
Set
up
empty
id
dictionary
"
)
;
let
dict
=
DCB_TEST_DICTIONARIES
.
html_common_no_dictionary
;
let
content
=
DCB_TEST_CONTENT
.
html_page
;
await
registerDCBEndpoint
(
server
"
/
invalid
/
empty
-
id
"
dict
content
true
)
;
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
invalid
/
empty
-
id
;
chan
=
makeChan
(
url
)
;
[
req
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
content
"
non
-
compressed
content
received
"
)
;
Assert
.
ok
(
!
verifyDCBResponse
(
req
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
data
dict
)
"
DCB
compression
should
not
be
used
with
dictionary
with
empty
id
"
)
;
dump
(
"
*
*
*
*
Empty
id
parameter
test
complete
\
n
"
)
;
}
)
;
add_task
(
async
function
test_available_dictionary_header_generation
(
)
{
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
api
/
test
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
let
expectedHashB64
=
await
calculateDictionaryHash
(
DCB_TEST_DICTIONARIES
.
api_json
.
content
)
;
let
dict
=
DCB_TEST_DICTIONARIES
.
html_common
;
let
content
=
DCB_TEST_CONTENT
.
api_response
;
await
registerDCBEndpoint
(
server
"
/
api
/
test
"
dict
content
true
)
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
DCB_TEST_CONTENT
.
api_response
"
Resource
content
matches
"
)
;
await
sync_from_server
(
)
;
let
logEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
"
/
api
/
test
"
)
;
Assert
.
ok
(
logEntry
&
&
logEntry
.
availableDict
!
=
null
"
Available
-
Dictionary
header
should
be
present
"
)
;
if
(
logEntry
&
&
logEntry
.
availableDict
!
=
null
)
{
Assert
.
ok
(
logEntry
.
availableDict
.
startsWith
(
"
:
"
)
"
Available
-
Dictionary
should
start
with
'
:
'
(
IETF
Structured
Field
format
)
"
)
;
Assert
.
ok
(
logEntry
.
availableDict
.
endsWith
(
"
:
"
)
"
Available
-
Dictionary
should
end
with
'
:
'
(
IETF
Structured
Field
format
)
"
)
;
let
base64Content
=
logEntry
.
availableDict
.
slice
(
1
-
1
)
;
let
base64Regex
=
/
^
[
A
-
Za
-
z0
-
9
+
/
]
*
=
{
0
2
}
/
;
Assert
.
ok
(
base64Regex
.
test
(
base64Content
)
"
Available
-
Dictionary
content
should
be
valid
base64
"
)
;
Assert
.
equal
(
logEntry
.
availableDict
"
:
"
+
expectedHashB64
+
"
:
"
"
Available
-
Dictionary
has
the
right
hash
"
)
;
}
dump
(
"
*
*
*
*
Available
-
Dictionary
generation
test
complete
\
n
"
)
;
}
)
;
add_task
(
async
function
test_available_dictionary_specific_patterns
(
)
{
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
api
/
v1
/
test
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
let
dict
=
DCB_TEST_DICTIONARIES
.
api_v1
;
let
content
=
DCB_TEST_CONTENT
.
api_v1
;
await
registerDCBEndpoint
(
server
"
/
api
/
v1
/
test
"
dict
content
true
)
;
let
chan
=
makeChan
(
url
)
;
await
channelOpenPromise
(
chan
)
;
await
sync_from_server
(
)
;
let
logEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
"
/
api
/
v1
/
test
"
)
;
Assert
.
ok
(
logEntry
&
&
logEntry
.
availableDict
!
=
null
"
Available
-
Dictionary
header
should
be
present
for
/
api
/
v1
/
*
"
)
;
if
(
logEntry
&
&
logEntry
.
availableDict
!
=
null
)
{
Assert
.
equal
(
logEntry
.
availableDict
DCB_TEST_DICTIONARIES
.
api_v1
.
hash
"
Longer
match
pattern
for
a
dictionary
should
be
used
"
)
;
}
dump
(
"
*
*
*
*
Specific
pattern
matching
test
complete
\
n
"
)
;
}
)
;
add_task
(
async
function
test_available_dictionary_no_match
(
)
{
let
url
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
nomatch
/
test
;
requestLog
=
[
]
;
await
sync_to_server
(
)
;
let
dict
=
DCB_TEST_DICTIONARIES
.
html_common
;
let
content
=
"
NO
MATCH
TEST
DATA
"
;
await
registerDCBEndpoint
(
server
"
/
nomatch
/
test
"
dict
content
true
)
;
let
chan
=
makeChan
(
url
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
NO
MATCH
TEST
DATA
"
"
No
match
content
received
"
)
;
await
sync_from_server
(
)
;
let
logEntry
=
requestLog
.
find
(
entry
=
>
entry
.
path
=
=
=
"
/
nomatch
/
test
"
)
;
Assert
.
ok
(
logEntry
"
Request
should
be
logged
"
)
;
if
(
logEntry
)
{
Assert
.
equal
(
logEntry
.
availableDict
"
"
"
Available
-
Dictionary
should
be
null
for
no
match
"
)
;
}
dump
(
"
*
*
*
*
No
match
test
complete
\
n
"
)
;
}
)
;
add_task
(
async
function
cleanup
(
)
{
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
dump
(
"
*
*
*
*
DCB
compression
tests
completed
.
\
n
"
)
;
}
)
;
