const
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
const
pps
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
-
proxy
-
service
;
1
"
]
.
getService
(
)
;
class
TestFilter
{
constructor
(
type
host
port
flags
auth
)
{
this
.
_type
=
type
;
this
.
_host
=
host
;
this
.
_port
=
port
;
this
.
_flags
=
flags
;
this
.
_auth
=
auth
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIProtocolProxyFilter
]
)
;
}
applyFilter
(
pps
uri
pi
cb
)
{
cb
.
onProxyFilterResult
(
pps
.
newProxyInfo
(
this
.
_type
this
.
_host
this
.
_port
this
.
_auth
"
"
this
.
_flags
1000
null
)
)
;
}
}
;
let
httpServer
=
null
;
let
port
;
let
connectProcessesed
=
false
;
const
proxyAuthHeader
=
'
proxy
-
auth
-
header
-
value
'
;
function
make_channel
(
url
)
{
return
NetUtil
.
newChannel
(
{
uri
:
url
loadUsingSystemPrincipal
:
true
}
)
;
}
function
connect_handler
(
request
response
)
{
Assert
.
equal
(
request
.
method
"
CONNECT
"
)
;
Assert
.
ok
(
request
.
hasHeader
(
"
Proxy
-
Authorization
"
)
)
;
Assert
.
equal
(
request
.
getHeader
(
"
Proxy
-
Authorization
"
)
proxyAuthHeader
)
;
response
.
setStatusLine
(
request
.
httpVersion
500
"
STOP
"
)
;
connectProcessesed
=
true
;
}
function
finish_test
(
)
{
Assert
.
ok
(
connectProcessesed
)
;
httpServer
.
stop
(
do_test_finished
)
;
}
function
run_test
(
)
{
httpServer
=
new
HttpServer
(
)
;
httpServer
.
identity
.
add
(
"
https
"
"
mozilla
.
org
"
443
)
;
httpServer
.
registerPathHandler
(
"
CONNECT
"
connect_handler
)
;
httpServer
.
start
(
-
1
)
;
port
=
httpServer
.
identity
.
primaryPort
;
pps
.
registerFilter
(
new
TestFilter
(
"
http
"
"
localhost
"
port
0
proxyAuthHeader
)
10
)
;
let
chan
=
make_channel
(
"
https
:
/
/
mozilla
.
org
/
"
)
;
chan
.
asyncOpen
(
new
ChannelListener
(
finish_test
null
CL_EXPECT_FAILURE
)
)
;
do_test_pending
(
)
;
}
