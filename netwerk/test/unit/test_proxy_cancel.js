"
use
strict
"
;
Services
.
prefs
.
setBoolPref
(
"
network
.
proxy
.
allow_hijacking_localhost
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
network
.
proxy
.
allow_hijacking_localhost
"
)
;
}
)
;
const
{
TestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
)
;
const
{
NodeHTTPServer
NodeHTTPSServer
NodeHTTP2Server
NodeHTTPProxyServer
NodeHTTPSProxyServer
NodeHTTP2ProxyServer
with_node_servers
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
NodeServer
.
sys
.
mjs
"
)
;
function
makeChan
(
uri
)
{
let
chan
=
NetUtil
.
newChannel
(
{
uri
loadUsingSystemPrincipal
:
true
}
)
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
chan
.
loadFlags
=
Ci
.
nsIChannel
.
LOAD_INITIAL_DOCUMENT_URI
;
return
chan
;
}
add_setup
(
async
function
setup
(
)
{
Services
.
prefs
.
setIntPref
(
"
network
.
http
.
speculative
-
parallel
-
limit
"
0
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
network
.
http
.
speculative
-
parallel
-
limit
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_cancel_after_asyncOpen
(
)
{
let
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
addCertFromFile
(
certdb
"
http2
-
ca
.
pem
"
"
CTu
u
u
"
)
;
addCertFromFile
(
certdb
"
proxy
-
ca
.
pem
"
"
CTu
u
u
"
)
;
let
proxies
=
[
NodeHTTPProxyServer
NodeHTTPSProxyServer
NodeHTTP2ProxyServer
]
;
for
(
let
p
of
proxies
)
{
let
proxy
=
new
p
(
)
;
await
proxy
.
start
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
proxy
.
stop
(
)
;
}
)
;
await
with_node_servers
(
[
NodeHTTPServer
NodeHTTPSServer
NodeHTTP2Server
]
async
server
=
>
{
info
(
Testing
{
p
.
name
}
with
{
server
.
constructor
.
name
}
)
;
await
server
.
execute
(
global
.
server_name
=
"
{
server
.
constructor
.
name
}
"
;
)
;
await
server
.
registerPathHandler
(
"
/
test
"
(
req
resp
)
=
>
{
resp
.
writeHead
(
200
)
;
resp
.
end
(
global
.
server_name
)
;
}
)
;
let
chan
=
makeChan
(
{
server
.
origin
(
)
}
/
test
)
;
let
openPromise
=
new
Promise
(
resolve
=
>
{
chan
.
asyncOpen
(
new
ChannelListener
(
(
req
buff
)
=
>
resolve
(
{
req
buff
}
)
null
CL_EXPECT_FAILURE
)
)
;
}
)
;
chan
.
cancel
(
Cr
.
NS_ERROR_ABORT
)
;
let
{
req
}
=
await
openPromise
;
Assert
.
equal
(
req
.
status
Cr
.
NS_ERROR_ABORT
)
;
}
)
;
await
proxy
.
stop
(
)
;
}
}
)
;
const
NS_NET_STATUS_WAITING_FOR
=
0x4b000a
;
const
NS_NET_STATUS_RECEIVING_FROM
=
0x4b0006
;
add_task
(
async
function
test_cancel_after_connect_http2proxy
(
)
{
let
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
addCertFromFile
(
certdb
"
http2
-
ca
.
pem
"
"
CTu
u
u
"
)
;
addCertFromFile
(
certdb
"
proxy
-
ca
.
pem
"
"
CTu
u
u
"
)
;
await
with_node_servers
(
[
NodeHTTPServer
NodeHTTPSServer
NodeHTTP2Server
]
async
server
=
>
{
let
proxy
=
new
NodeHTTP2ProxyServer
(
)
;
await
proxy
.
start
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
proxy
.
stop
(
)
;
}
)
;
await
proxy
.
execute
(
global
.
session_counter
=
0
;
global
.
proxy
.
on
(
"
session
"
(
)
=
>
{
global
.
session_counter
+
+
;
}
)
;
)
;
info
(
Testing
{
proxy
.
constructor
.
name
}
with
{
server
.
constructor
.
name
}
)
;
await
server
.
execute
(
global
.
server_name
=
"
{
server
.
constructor
.
name
}
"
;
)
;
await
server
.
registerPathHandler
(
"
/
test
"
(
req
resp
)
=
>
{
global
.
reqCount
=
(
global
.
reqCount
|
|
0
)
+
1
;
resp
.
writeHead
(
200
)
;
resp
.
end
(
global
.
server_name
)
;
}
)
;
let
chan
=
makeChan
(
{
server
.
origin
(
)
}
/
test
)
;
chan
.
notificationCallbacks
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIInterfaceRequestor
"
"
nsIProgressEventSink
"
]
)
getInterface
(
iid
)
{
return
this
.
QueryInterface
(
iid
)
;
}
onProgress
(
)
{
}
onStatus
(
request
status
)
{
info
(
status
=
{
status
}
)
;
if
(
status
=
=
NS_NET_STATUS_WAITING_FOR
)
{
info
(
"
cancelling
connected
channel
"
)
;
chan
.
cancel
(
Cr
.
NS_ERROR_ABORT
)
;
}
}
}
;
let
openPromise
=
new
Promise
(
resolve
=
>
{
chan
.
asyncOpen
(
new
ChannelListener
(
(
req
buff
)
=
>
resolve
(
{
req
buff
}
)
null
CL_EXPECT_FAILURE
)
)
;
}
)
;
let
{
req
}
=
await
openPromise
;
Assert
.
equal
(
req
.
status
Cr
.
NS_ERROR_ABORT
)
;
Assert
.
equal
(
await
proxy
.
execute
(
global
.
session_counter
)
1
)
;
chan
=
makeChan
(
{
server
.
origin
(
)
}
/
test
)
;
await
new
Promise
(
resolve
=
>
{
chan
.
asyncOpen
(
new
ChannelListener
(
(
req
buff
)
=
>
resolve
(
{
req
buff
}
)
null
CL_ALLOW_UNKNOWN_CL
)
)
;
}
)
;
Assert
.
equal
(
await
proxy
.
execute
(
global
.
session_counter
)
1
)
;
await
proxy
.
stop
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_cancel_after_sending_request
(
)
{
let
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
addCertFromFile
(
certdb
"
http2
-
ca
.
pem
"
"
CTu
u
u
"
)
;
addCertFromFile
(
certdb
"
proxy
-
ca
.
pem
"
"
CTu
u
u
"
)
;
await
with_node_servers
(
[
NodeHTTPServer
NodeHTTPSServer
NodeHTTP2Server
]
async
server
=
>
{
let
proxies
=
[
NodeHTTPProxyServer
NodeHTTPSProxyServer
NodeHTTP2ProxyServer
]
;
for
(
let
p
of
proxies
)
{
let
proxy
=
new
p
(
)
;
await
proxy
.
start
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
proxy
.
stop
(
)
;
}
)
;
await
proxy
.
execute
(
global
.
session_counter
=
0
;
global
.
proxy
.
on
(
"
session
"
(
)
=
>
{
global
.
session_counter
+
+
;
}
)
;
)
;
info
(
Testing
{
p
.
name
}
with
{
server
.
constructor
.
name
}
)
;
await
server
.
execute
(
global
.
server_name
=
"
{
server
.
constructor
.
name
}
"
;
)
;
await
server
.
registerPathHandler
(
"
/
test
"
(
req
resp
)
=
>
{
global
.
request_count
=
(
global
.
request_count
|
|
0
)
+
1
;
setTimeout
(
(
)
=
>
{
resp
.
writeHead
(
200
)
;
resp
.
end
(
global
.
server_name
)
;
}
2000
)
;
}
)
;
await
server
.
registerPathHandler
(
"
/
instant
"
(
req
resp
)
=
>
{
resp
.
writeHead
(
200
)
;
resp
.
end
(
global
.
server_name
)
;
}
)
;
let
chan
=
makeChan
(
{
server
.
origin
(
)
}
/
instant
)
;
await
new
Promise
(
resolve
=
>
{
chan
.
asyncOpen
(
new
ChannelListener
(
resolve
null
CL_ALLOW_UNKNOWN_CL
)
)
;
}
)
;
chan
=
makeChan
(
{
server
.
origin
(
)
}
/
test
)
;
let
openPromise
=
new
Promise
(
resolve
=
>
{
chan
.
asyncOpen
(
new
ChannelListener
(
(
req
buff
)
=
>
resolve
(
{
req
buff
}
)
null
CL_EXPECT_FAILURE
)
)
;
}
)
;
await
TestUtils
.
waitForCondition
(
async
(
)
=
>
{
return
(
await
server
.
execute
(
"
global
.
request_count
"
)
)
>
0
;
}
)
;
chan
.
cancel
(
Cr
.
NS_ERROR_ABORT
)
;
let
{
req
}
=
await
openPromise
;
Assert
.
equal
(
req
.
status
Cr
.
NS_ERROR_ABORT
)
;
async
function
checkSessionCounter
(
)
{
if
(
p
.
name
=
=
"
NodeHTTP2ProxyServer
"
)
{
Assert
.
equal
(
await
proxy
.
execute
(
global
.
session_counter
)
1
)
;
}
}
await
checkSessionCounter
(
)
;
chan
=
makeChan
(
{
server
.
origin
(
)
}
/
instant
)
;
await
new
Promise
(
resolve
=
>
{
chan
.
asyncOpen
(
new
ChannelListener
(
(
req
buff
)
=
>
resolve
(
{
req
buff
}
)
null
CL_ALLOW_UNKNOWN_CL
)
)
;
}
)
;
await
checkSessionCounter
(
)
;
await
proxy
.
stop
(
)
;
}
}
)
;
}
)
;
add_task
(
async
function
test_cancel_during_response
(
)
{
let
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
addCertFromFile
(
certdb
"
http2
-
ca
.
pem
"
"
CTu
u
u
"
)
;
addCertFromFile
(
certdb
"
proxy
-
ca
.
pem
"
"
CTu
u
u
"
)
;
await
with_node_servers
(
[
NodeHTTPServer
NodeHTTPSServer
NodeHTTP2Server
]
async
server
=
>
{
let
proxies
=
[
NodeHTTPProxyServer
NodeHTTPSProxyServer
NodeHTTP2ProxyServer
]
;
for
(
let
p
of
proxies
)
{
let
proxy
=
new
p
(
)
;
await
proxy
.
start
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
proxy
.
stop
(
)
;
}
)
;
await
proxy
.
execute
(
global
.
session_counter
=
0
;
global
.
proxy
.
on
(
"
session
"
(
)
=
>
{
global
.
session_counter
+
+
;
}
)
;
)
;
info
(
Testing
{
p
.
name
}
with
{
server
.
constructor
.
name
}
)
;
await
server
.
execute
(
global
.
server_name
=
"
{
server
.
constructor
.
name
}
"
;
)
;
await
server
.
registerPathHandler
(
"
/
test
"
(
req
resp
)
=
>
{
resp
.
writeHead
(
200
)
;
resp
.
write
(
"
a
"
.
repeat
(
1000
)
)
;
setTimeout
(
(
)
=
>
{
resp
.
write
(
"
a
"
.
repeat
(
1000
)
)
;
resp
.
end
(
global
.
server_name
)
;
}
2000
)
;
}
)
;
await
server
.
registerPathHandler
(
"
/
instant
"
(
req
resp
)
=
>
{
resp
.
writeHead
(
200
)
;
resp
.
end
(
global
.
server_name
)
;
}
)
;
let
chan
=
makeChan
(
{
server
.
origin
(
)
}
/
test
)
;
chan
.
notificationCallbacks
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIInterfaceRequestor
"
"
nsIProgressEventSink
"
]
)
getInterface
(
iid
)
{
return
this
.
QueryInterface
(
iid
)
;
}
onProgress
(
request
progress
progressMax
)
{
info
(
progress
:
{
progress
}
/
{
progressMax
}
)
;
Assert
.
equal
(
progress
1000
)
;
}
onStatus
(
request
status
)
{
if
(
status
=
=
NS_NET_STATUS_RECEIVING_FROM
)
{
info
(
"
cancelling
when
receiving
request
"
)
;
chan
.
cancel
(
Cr
.
NS_ERROR_ABORT
)
;
}
}
}
;
let
openPromise
=
new
Promise
(
resolve
=
>
{
chan
.
asyncOpen
(
new
ChannelListener
(
(
req
buff
)
=
>
resolve
(
{
req
buff
}
)
null
CL_EXPECT_FAILURE
)
)
;
}
)
;
let
{
req
}
=
await
openPromise
;
Assert
.
equal
(
req
.
status
Cr
.
NS_ERROR_ABORT
)
;
async
function
checkSessionCounter
(
)
{
if
(
p
.
name
=
=
"
NodeHTTP2ProxyServer
"
)
{
Assert
.
equal
(
await
proxy
.
execute
(
global
.
session_counter
)
1
)
;
}
}
await
checkSessionCounter
(
)
;
chan
=
makeChan
(
{
server
.
origin
(
)
}
/
instant
)
;
await
new
Promise
(
resolve
=
>
{
chan
.
asyncOpen
(
new
ChannelListener
(
(
req
buff
)
=
>
resolve
(
{
req
buff
}
)
null
CL_ALLOW_UNKNOWN_CL
)
)
;
}
)
;
await
checkSessionCounter
(
)
;
await
proxy
.
stop
(
)
;
}
}
)
;
}
)
;
