"
use
strict
"
;
var
callbacks
=
[
]
;
const
NORMAL
=
0
;
const
NEW
=
1
<
<
0
;
const
NOTVALID
=
1
<
<
1
;
const
THROWAVAIL
=
1
<
<
2
;
const
READONLY
=
1
<
<
3
;
const
NOTFOUND
=
1
<
<
4
;
const
REVAL
=
1
<
<
5
;
const
PARTIAL
=
1
<
<
6
;
const
DOOMED
=
1
<
<
7
;
const
WAITFORWRITE
=
1
<
<
8
;
const
METAONLY
=
1
<
<
9
;
const
RECREATE
=
1
<
<
10
;
const
NOTWANTED
=
1
<
<
11
;
const
COMPLETE
=
1
<
<
12
;
const
DONTFILL
=
1
<
<
13
;
const
DONTSETVALID
=
1
<
<
14
;
const
NOTIFYBEFOREREAD
=
1
<
<
15
;
const
MAYBE_NEW
=
1
<
<
16
;
var
log_c2
=
true
;
function
LOG_C2
(
o
m
)
{
if
(
!
log_c2
)
{
return
;
}
if
(
!
m
)
{
dump
(
"
TEST
-
INFO
|
CACHE2
:
"
+
o
+
"
\
n
"
)
;
}
else
{
dump
(
"
TEST
-
INFO
|
CACHE2
:
callback
#
"
+
o
.
order
+
"
(
"
+
(
o
.
workingData
?
o
.
workingData
.
substr
(
0
10
)
:
"
-
-
-
"
)
+
"
)
"
+
m
+
"
\
n
"
)
;
}
}
function
pumpReadStream
(
inputStream
goon
)
{
if
(
inputStream
.
isNonBlocking
(
)
)
{
var
pump
=
Cc
[
"
mozilla
.
org
/
network
/
input
-
stream
-
pump
;
1
"
]
.
createInstance
(
Ci
.
nsIInputStreamPump
)
;
pump
.
init
(
inputStream
0
0
true
)
;
var
data
=
"
"
;
pump
.
asyncRead
(
{
onStartRequest
(
aRequest
)
{
}
onDataAvailable
(
aRequest
aInputStream
aOffset
aCount
)
{
var
wrapper
=
Cc
[
"
mozilla
.
org
/
scriptableinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptableInputStream
)
;
wrapper
.
init
(
aInputStream
)
;
var
str
=
wrapper
.
read
(
wrapper
.
available
(
)
)
;
LOG_C2
(
"
reading
data
'
"
+
str
.
substring
(
0
5
)
+
"
'
"
)
;
data
+
=
str
;
}
onStopRequest
(
aRequest
aStatusCode
)
{
LOG_C2
(
"
done
reading
data
:
"
+
aStatusCode
)
;
Assert
.
equal
(
aStatusCode
Cr
.
NS_OK
)
;
goon
(
data
)
;
}
}
)
;
}
else
{
var
data
=
read_stream
(
inputStream
inputStream
.
available
(
)
)
;
goon
(
data
)
;
}
}
OpenCallback
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICacheEntryOpenCallback
"
]
)
onCacheEntryCheck
(
entry
)
{
LOG_C2
(
this
"
onCacheEntryCheck
"
)
;
Assert
.
ok
(
!
this
.
onCheckPassed
)
;
this
.
onCheckPassed
=
true
;
if
(
this
.
behavior
&
NOTVALID
)
{
LOG_C2
(
this
"
onCacheEntryCheck
DONE
return
ENTRY_WANTED
"
)
;
return
Ci
.
nsICacheEntryOpenCallback
.
ENTRY_WANTED
;
}
if
(
this
.
behavior
&
NOTWANTED
)
{
LOG_C2
(
this
"
onCacheEntryCheck
DONE
return
ENTRY_NOT_WANTED
"
)
;
return
Ci
.
nsICacheEntryOpenCallback
.
ENTRY_NOT_WANTED
;
}
Assert
.
equal
(
entry
.
getMetaDataElement
(
"
meto
"
)
this
.
workingMetadata
)
;
Assert
.
notEqual
(
this
.
behavior
&
(
REVAL
|
PARTIAL
)
REVAL
|
PARTIAL
)
;
if
(
this
.
behavior
&
(
REVAL
|
PARTIAL
)
)
{
LOG_C2
(
this
"
onCacheEntryCheck
DONE
return
ENTRY_NEEDS_REVALIDATION
"
)
;
return
Ci
.
nsICacheEntryOpenCallback
.
ENTRY_NEEDS_REVALIDATION
;
}
if
(
this
.
behavior
&
COMPLETE
)
{
LOG_C2
(
this
"
onCacheEntryCheck
DONE
return
RECHECK_AFTER_WRITE_FINISHED
"
)
;
this
.
onCheckPassed
=
false
;
this
.
behavior
&
=
~
COMPLETE
;
return
Ci
.
nsICacheEntryOpenCallback
.
RECHECK_AFTER_WRITE_FINISHED
;
}
LOG_C2
(
this
"
onCacheEntryCheck
DONE
return
ENTRY_WANTED
"
)
;
return
Ci
.
nsICacheEntryOpenCallback
.
ENTRY_WANTED
;
}
onCacheEntryAvailable
(
entry
isnew
status
)
{
if
(
this
.
behavior
&
MAYBE_NEW
&
&
isnew
)
{
this
.
behavior
|
=
NEW
;
}
LOG_C2
(
this
"
onCacheEntryAvailable
"
+
this
.
behavior
)
;
Assert
.
ok
(
!
this
.
onAvailPassed
)
;
this
.
onAvailPassed
=
true
;
Assert
.
equal
(
isnew
!
!
(
this
.
behavior
&
NEW
)
)
;
if
(
this
.
behavior
&
(
NOTFOUND
|
NOTWANTED
)
)
{
Assert
.
equal
(
status
Cr
.
NS_ERROR_CACHE_KEY_NOT_FOUND
)
;
Assert
.
ok
(
!
entry
)
;
if
(
this
.
behavior
&
THROWAVAIL
)
{
this
.
throwAndNotify
(
entry
)
;
}
this
.
goon
(
entry
)
;
}
else
if
(
this
.
behavior
&
(
NEW
|
RECREATE
)
)
{
Assert
.
ok
(
!
!
entry
)
;
if
(
this
.
behavior
&
RECREATE
)
{
entry
=
entry
.
recreate
(
)
;
Assert
.
ok
(
!
!
entry
)
;
}
if
(
this
.
behavior
&
THROWAVAIL
)
{
this
.
throwAndNotify
(
entry
)
;
}
if
(
!
(
this
.
behavior
&
WAITFORWRITE
)
)
{
this
.
goon
(
entry
)
;
}
if
(
!
(
this
.
behavior
&
PARTIAL
)
)
{
try
{
entry
.
getMetaDataElement
(
"
meto
"
)
;
Assert
.
ok
(
false
)
;
}
catch
(
ex
)
{
}
}
if
(
this
.
behavior
&
DONTFILL
)
{
Assert
.
equal
(
false
this
.
behavior
&
WAITFORWRITE
)
;
return
;
}
var
self
=
this
;
executeSoon
(
function
(
)
{
entry
.
setMetaDataElement
(
"
meto
"
self
.
workingMetadata
)
;
entry
.
metaDataReady
(
)
;
if
(
self
.
behavior
&
METAONLY
)
{
if
(
!
(
self
.
behavior
&
DONTSETVALID
)
)
{
entry
.
setValid
(
)
;
}
entry
.
close
(
)
;
if
(
self
.
behavior
&
WAITFORWRITE
)
{
self
.
goon
(
entry
)
;
}
return
;
}
executeSoon
(
function
(
)
{
if
(
self
.
behavior
&
DOOMED
)
{
LOG_C2
(
self
"
checking
doom
state
"
)
;
try
{
var
os
=
entry
.
openOutputStream
(
0
-
1
)
;
os
.
close
(
)
;
Assert
.
ok
(
!
!
(
self
.
behavior
&
MAYBE_NEW
)
)
;
}
catch
(
ex
)
{
Assert
.
ok
(
true
)
;
}
if
(
self
.
behavior
&
WAITFORWRITE
)
{
self
.
goon
(
entry
)
;
}
return
;
}
var
offset
=
self
.
behavior
&
PARTIAL
?
entry
.
dataSize
:
0
;
LOG_C2
(
self
"
openOutputStream
"
+
offset
)
;
var
os
=
entry
.
openOutputStream
(
offset
-
1
)
;
LOG_C2
(
self
"
writing
data
"
)
;
var
wrt
=
os
.
write
(
self
.
workingData
self
.
workingData
.
length
)
;
Assert
.
equal
(
wrt
self
.
workingData
.
length
)
;
os
.
close
(
)
;
if
(
self
.
behavior
&
WAITFORWRITE
)
{
self
.
goon
(
entry
)
;
}
entry
.
close
(
)
;
}
)
;
}
)
;
}
else
{
Assert
.
ok
(
!
!
entry
)
;
Assert
.
equal
(
entry
.
getMetaDataElement
(
"
meto
"
)
this
.
workingMetadata
)
;
if
(
this
.
behavior
&
THROWAVAIL
)
{
this
.
throwAndNotify
(
entry
)
;
}
if
(
this
.
behavior
&
NOTIFYBEFOREREAD
)
{
this
.
goon
(
entry
true
)
;
}
var
self
=
this
;
pumpReadStream
(
entry
.
openInputStream
(
0
)
function
(
data
)
{
Assert
.
equal
(
data
self
.
workingData
)
;
self
.
onDataCheckPassed
=
true
;
LOG_C2
(
self
"
entry
read
done
"
)
;
self
.
goon
(
entry
)
;
entry
.
close
(
)
;
}
)
;
}
}
selfCheck
(
)
{
LOG_C2
(
this
"
selfCheck
"
)
;
Assert
.
ok
(
this
.
onCheckPassed
|
|
this
.
behavior
&
MAYBE_NEW
)
;
Assert
.
ok
(
this
.
onAvailPassed
)
;
Assert
.
ok
(
this
.
onDataCheckPassed
|
|
this
.
behavior
&
MAYBE_NEW
)
;
}
throwAndNotify
(
entry
)
{
LOG_C2
(
this
"
Throwing
"
)
;
var
self
=
this
;
executeSoon
(
function
(
)
{
LOG_C2
(
self
"
Notifying
"
)
;
self
.
goon
(
entry
)
;
}
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
;
function
OpenCallback
(
behavior
workingMetadata
workingData
goon
)
{
this
.
behavior
=
behavior
;
this
.
workingMetadata
=
workingMetadata
;
this
.
workingData
=
workingData
;
this
.
goon
=
goon
;
this
.
onCheckPassed
=
(
!
!
(
behavior
&
(
NEW
|
RECREATE
)
)
|
|
!
workingMetadata
)
&
&
!
(
behavior
&
NOTVALID
)
;
this
.
onAvailPassed
=
false
;
this
.
onDataCheckPassed
=
!
!
(
behavior
&
(
NEW
|
RECREATE
|
NOTWANTED
)
)
|
|
!
workingMetadata
;
callbacks
.
push
(
this
)
;
this
.
order
=
callbacks
.
length
;
}
VisitCallback
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICacheStorageVisitor
"
]
)
onCacheStorageInfo
(
num
consumption
)
{
LOG_C2
(
this
"
onCacheStorageInfo
:
num
=
"
+
num
+
"
size
=
"
+
consumption
)
;
Assert
.
equal
(
this
.
num
num
)
;
Assert
.
equal
(
this
.
consumption
consumption
)
;
if
(
!
this
.
entries
)
{
this
.
notify
(
)
;
}
}
onCacheEntryInfo
(
aURI
aIdEnhance
aDataSize
aAltDataSize
aFetchCount
aLastModifiedTime
aExpirationTime
aPinned
aInfo
)
{
var
key
=
(
aIdEnhance
?
aIdEnhance
+
"
:
"
:
"
"
)
+
aURI
.
asciiSpec
;
LOG_C2
(
this
"
onCacheEntryInfo
:
key
=
"
+
key
)
;
function
findCacheIndex
(
element
)
{
if
(
typeof
element
=
=
=
"
string
"
)
{
return
element
=
=
=
key
;
}
else
if
(
typeof
element
=
=
=
"
object
"
)
{
return
(
element
.
uri
=
=
=
key
&
&
element
.
lci
.
isAnonymous
=
=
=
aInfo
.
isAnonymous
&
&
ChromeUtils
.
isOriginAttributesEqual
(
element
.
lci
.
originAttributes
aInfo
.
originAttributes
)
)
;
}
return
false
;
}
Assert
.
ok
(
!
!
this
.
entries
)
;
var
index
=
this
.
entries
.
findIndex
(
findCacheIndex
)
;
Assert
.
ok
(
index
>
-
1
)
;
this
.
entries
.
splice
(
index
1
)
;
}
onCacheEntryVisitCompleted
(
)
{
LOG_C2
(
this
"
onCacheEntryVisitCompleted
"
)
;
if
(
this
.
entries
)
{
Assert
.
equal
(
this
.
entries
.
length
0
)
;
}
this
.
notify
(
)
;
}
notify
(
)
{
Assert
.
ok
(
!
!
this
.
goon
)
;
var
goon
=
this
.
goon
;
this
.
goon
=
null
;
executeSoon
(
goon
)
;
}
selfCheck
(
)
{
Assert
.
ok
(
!
this
.
entries
|
|
!
this
.
entries
.
length
)
;
}
}
;
function
VisitCallback
(
num
consumption
entries
goon
)
{
this
.
num
=
num
;
this
.
consumption
=
consumption
;
this
.
entries
=
entries
;
this
.
goon
=
goon
;
callbacks
.
push
(
this
)
;
this
.
order
=
callbacks
.
length
;
}
EvictionCallback
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICacheEntryDoomCallback
"
]
)
onCacheEntryDoomed
(
result
)
{
Assert
.
equal
(
this
.
expectedSuccess
result
=
=
Cr
.
NS_OK
)
;
this
.
goon
(
)
;
}
selfCheck
(
)
{
}
}
;
function
EvictionCallback
(
success
goon
)
{
this
.
expectedSuccess
=
success
;
this
.
goon
=
goon
;
callbacks
.
push
(
this
)
;
this
.
order
=
callbacks
.
length
;
}
MultipleCallbacks
.
prototype
=
{
fired
(
)
{
if
(
-
-
this
.
pending
=
=
0
)
{
var
self
=
this
;
if
(
this
.
delayed
)
{
executeSoon
(
function
(
)
{
self
.
goon
(
)
;
}
)
;
}
else
{
this
.
goon
(
)
;
}
}
}
add
(
)
{
+
+
this
.
pending
;
}
}
;
function
MultipleCallbacks
(
number
goon
delayed
)
{
this
.
pending
=
number
;
this
.
goon
=
goon
;
this
.
delayed
=
delayed
;
}
function
wait_for_cache_index
(
continue_func
)
{
Services
.
cache2
.
asyncGetDiskConsumption
(
{
onNetworkCacheDiskConsumption
(
)
{
continue_func
(
)
;
}
QueryInterface
(
)
{
return
this
;
}
}
)
;
}
function
finish_cache2_test
(
)
{
callbacks
.
forEach
(
function
(
callback
index
)
{
callback
.
selfCheck
(
)
;
}
)
;
do_test_finished
(
)
;
}
