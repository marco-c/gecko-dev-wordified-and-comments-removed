"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
FileTestUtils
:
"
resource
:
/
/
testing
-
common
/
FileTestUtils
.
sys
.
mjs
"
}
)
;
const
BackgroundFileSaverOutputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
network
/
background
-
file
-
saver
;
1
?
mode
=
outputstream
"
"
nsIBackgroundFileSaver
"
)
;
const
StringInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
"
nsIStringInputStream
"
"
setByteStringData
"
)
;
const
TEST_FILE_NAME_1
=
"
test
-
backgroundfilesaver
-
1
.
txt
"
;
function
getTempFile
(
leafName
)
{
return
FileTestUtils
.
getTempFile
(
leafName
)
;
}
function
promiseSaverComplete
(
aSaver
aOnTargetChangeFn
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
aSaver
.
observer
=
{
onTargetChange
:
function
BFSO_onSaveComplete
(
saver
aTarget
)
{
if
(
aOnTargetChangeFn
)
{
aOnTargetChangeFn
(
aTarget
)
;
}
}
onSaveComplete
:
function
BFSO_onSaveComplete
(
saver
aStatus
)
{
if
(
Components
.
isSuccessCode
(
aStatus
)
)
{
resolve
(
)
;
}
else
{
reject
(
new
Components
.
Exception
(
"
Saver
failed
.
"
aStatus
)
)
;
}
}
}
;
}
)
;
}
function
promiseCopyToSaver
(
aSourceString
aSaverOutputStream
aCloseWhenDone
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
inputStream
=
new
StringInputStream
(
aSourceString
)
;
let
copier
=
Cc
[
"
mozilla
.
org
/
network
/
async
-
stream
-
copier
;
1
"
]
.
createInstance
(
Ci
.
nsIAsyncStreamCopier
)
;
copier
.
init
(
inputStream
aSaverOutputStream
null
false
true
0x8000
true
aCloseWhenDone
)
;
copier
.
asyncCopy
(
{
onStartRequest
(
)
{
}
onStopRequest
(
aRequest
aContext
aStatusCode
)
{
if
(
Components
.
isSuccessCode
(
aStatusCode
)
)
{
resolve
(
)
;
}
else
{
reject
(
new
Components
.
Exception
(
aStatusCode
)
)
;
}
}
}
null
)
;
}
)
;
}
var
gStillRunning
=
true
;
add_task
(
function
test_setup
(
)
{
do_timeout
(
10
*
60
*
1000
function
(
)
{
if
(
gStillRunning
)
{
do_throw
(
"
Test
timed
out
.
"
)
;
}
}
)
;
}
)
;
function
readFileToString
(
aFilename
)
{
let
f
=
do_get_file
(
aFilename
)
;
let
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
stream
.
init
(
f
-
1
0
0
)
;
let
buf
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
return
buf
;
}
add_task
(
async
function
test_signature
(
)
{
let
destFile
=
getTempFile
(
TEST_FILE_NAME_1
)
;
let
data
=
readFileToString
(
"
data
/
signed_win
.
exe
"
)
;
let
saver
=
new
BackgroundFileSaverOutputStream
(
)
;
let
completionPromise
=
promiseSaverComplete
(
saver
)
;
try
{
saver
.
signatureInfo
;
do_throw
(
"
Can
'
t
get
signature
before
saver
is
complete
.
"
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
{
throw
ex
;
}
}
saver
.
enableSignatureInfo
(
)
;
saver
.
setTarget
(
destFile
false
)
;
await
promiseCopyToSaver
(
data
saver
true
)
;
saver
.
finish
(
Cr
.
NS_OK
)
;
await
completionPromise
;
Assert
.
equal
(
1
saver
.
signatureInfo
.
length
)
;
let
certLists
=
saver
.
signatureInfo
;
Assert
.
ok
(
certLists
.
length
=
=
=
1
)
;
let
certs
=
certLists
[
0
]
;
Assert
.
ok
(
certs
.
length
=
=
=
3
)
;
const
certDB
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
let
signer
=
certDB
.
constructX509
(
certs
[
0
]
)
;
let
issuer
=
certDB
.
constructX509
(
certs
[
1
]
)
;
let
root
=
certDB
.
constructX509
(
certs
[
2
]
)
;
let
organization
=
"
Microsoft
Corporation
"
;
Assert
.
equal
(
"
Microsoft
Corporation
"
signer
.
commonName
)
;
Assert
.
equal
(
organization
signer
.
organization
)
;
Assert
.
equal
(
"
Copyright
(
c
)
2002
Microsoft
Corp
.
"
signer
.
organizationalUnit
)
;
Assert
.
equal
(
"
Microsoft
Code
Signing
PCA
"
issuer
.
commonName
)
;
Assert
.
equal
(
organization
issuer
.
organization
)
;
Assert
.
equal
(
"
Copyright
(
c
)
2000
Microsoft
Corp
.
"
issuer
.
organizationalUnit
)
;
Assert
.
equal
(
"
Microsoft
Root
Authority
"
root
.
commonName
)
;
Assert
.
ok
(
!
root
.
organization
)
;
Assert
.
equal
(
"
Copyright
(
c
)
1997
Microsoft
Corp
.
"
root
.
organizationalUnit
)
;
destFile
.
remove
(
false
)
;
}
)
;
add_task
(
function
test_teardown
(
)
{
gStillRunning
=
false
;
}
)
;
