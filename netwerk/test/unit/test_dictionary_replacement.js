"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
test
/
head_cache
.
js
"
this
)
;
const
{
NodeHTTPSServer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
NodeServer
.
sys
.
mjs
"
)
;
const
DICTIONARY_CONTENT
=
"
DICTIONARY_CONTENT_FOR_COMPRESSION_TEST_DATA
"
;
const
REPLACEMENT_CONTENT
=
"
REPLACED_CONTENT_WITHOUT_DICTIONARY_HEADER
"
;
let
server
=
null
;
add_setup
(
async
function
(
)
{
Services
.
prefs
.
setBoolPref
(
"
network
.
http
.
dictionaries
.
enable
"
true
)
;
server
=
new
NodeHTTPSServer
(
)
;
await
server
.
start
(
)
;
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
registerCleanupFunction
(
async
(
)
=
>
{
try
{
await
server
.
stop
(
)
;
}
catch
(
e
)
{
}
}
)
;
}
)
;
function
makeChan
(
url
bypassCache
=
false
)
{
let
chan
=
NetUtil
.
newChannel
(
{
uri
:
url
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
}
)
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
bypassCache
)
{
chan
.
loadFlags
|
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
;
}
return
chan
;
}
function
channelOpenPromise
(
chan
intermittentFail
=
false
)
{
return
new
Promise
(
resolve
=
>
{
function
finish
(
req
buffer
)
{
resolve
(
[
req
buffer
]
)
;
}
if
(
intermittentFail
)
{
chan
.
asyncOpen
(
new
SimpleChannelListener
(
finish
null
CL_ALLOW_UNKNOWN_CL
)
)
;
}
else
{
chan
.
asyncOpen
(
new
ChannelListener
(
finish
null
CL_ALLOW_UNKNOWN_CL
)
)
;
}
}
)
;
}
function
verifyDictionaryStored
(
url
shouldExist
)
{
return
new
Promise
(
resolve
=
>
{
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
asyncCheckCacheEntryPresence
(
url
"
disk
"
shouldExist
lci
resolve
)
;
}
)
;
}
function
syncCache
(
)
{
return
new
Promise
(
resolve
=
>
{
syncWithCacheIOThread
(
resolve
true
)
;
}
)
;
}
async
function
clearDictionaryCacheAndPurgeMemory
(
)
{
let
testingInterface
=
Services
.
cache2
.
QueryInterface
(
Ci
.
nsICacheTesting
)
;
testingInterface
.
clearDictionaryCacheMemory
(
)
;
gc
(
)
;
}
add_task
(
async
function
test_dictionary_replacement_removes_metadata
(
)
{
let
receivedAvailableDictionary
=
null
;
await
server
.
registerPathHandler
(
"
/
dict
/
resource
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
'
match
=
"
/
matching
/
*
"
id
=
"
test
-
dict
"
type
=
raw
'
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
"
DICTIONARY_CONTENT_FOR_COMPRESSION_TEST_DATA
"
"
binary
"
)
;
}
)
;
await
server
.
registerPathHandler
(
"
/
matching
/
test
"
function
(
request
response
)
{
global
.
lastAvailableDictionary
=
request
.
headers
[
"
available
-
dictionary
"
]
|
|
null
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
text
/
plain
"
"
Cache
-
Control
"
:
"
no
-
cache
"
}
)
;
response
.
end
(
"
CONTENT_THAT_SHOULD_MATCH_DICTIONARY
"
"
binary
"
)
;
}
)
;
dump
(
"
*
*
*
*
Step
1
:
Load
dictionary
resource
with
Use
-
As
-
Dictionary
\
n
"
)
;
let
dictUrl
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
resource
;
let
chan
=
makeChan
(
dictUrl
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
DICTIONARY_CONTENT
"
Dictionary
content
should
match
"
)
;
await
verifyDictionaryStored
(
dictUrl
true
)
;
await
syncCache
(
)
;
dump
(
"
*
*
*
*
Step
1
.
5
:
Clear
in
-
memory
caches
to
force
reload
from
disk
\
n
"
)
;
await
clearDictionaryCacheAndPurgeMemory
(
)
;
dump
(
"
*
*
*
*
Step
2
:
Verify
Available
-
Dictionary
is
sent
for
matching
resource
\
n
"
)
;
let
matchingUrl
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
matching
/
test
;
chan
=
makeChan
(
matchingUrl
)
;
await
channelOpenPromise
(
chan
)
;
receivedAvailableDictionary
=
await
server
.
execute
(
"
global
.
lastAvailableDictionary
"
)
;
Assert
.
notStrictEqual
(
receivedAvailableDictionary
null
"
Available
-
Dictionary
header
should
be
sent
for
matching
resource
"
)
;
Assert
.
ok
(
receivedAvailableDictionary
.
includes
(
"
:
"
)
"
Available
-
Dictionary
should
contain
a
hash
"
)
;
dump
(
*
*
*
*
Received
Available
-
Dictionary
:
{
receivedAvailableDictionary
}
\
n
)
;
dump
(
"
*
*
*
*
Step
3
:
Force
-
reload
dictionary
resource
WITHOUT
Use
-
As
-
Dictionary
\
n
"
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
resource
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
"
REPLACED_CONTENT_WITHOUT_DICTIONARY_HEADER
"
"
binary
"
)
;
}
)
;
chan
=
makeChan
(
dictUrl
true
)
;
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
REPLACEMENT_CONTENT
"
Replacement
content
should
match
"
)
;
await
syncCache
(
)
;
dump
(
"
*
*
*
*
Step
4
:
Verify
Available
-
Dictionary
is
NOT
sent
anymore
\
n
"
)
;
await
server
.
execute
(
"
global
.
lastAvailableDictionary
=
null
"
)
;
chan
=
makeChan
(
matchingUrl
)
;
await
channelOpenPromise
(
chan
)
;
receivedAvailableDictionary
=
await
server
.
execute
(
"
global
.
lastAvailableDictionary
"
)
;
Assert
.
equal
(
receivedAvailableDictionary
null
"
Available
-
Dictionary
header
should
NOT
be
sent
after
dictionary
is
replaced
"
)
;
dump
(
"
*
*
*
*
Test
passed
:
Dictionary
metadata
was
properly
removed
\
n
"
)
;
}
)
;
add_task
(
async
function
test_dictionary_replacement_with_compressed_content
(
)
{
dump
(
"
*
*
*
*
Clear
cache
and
start
fresh
\
n
"
)
;
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
let
testingInterface
=
Services
.
cache2
.
QueryInterface
(
Ci
.
nsICacheTesting
)
;
testingInterface
.
clearDictionaryCacheMemory
(
)
;
await
syncCache
(
)
;
let
receivedAvailableDictionary
=
null
;
await
server
.
registerPathHandler
(
"
/
dict
/
compressed
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
'
match
=
"
/
compressed
-
match
/
*
"
id
=
"
compressed
-
dict
"
type
=
raw
'
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
"
DICTIONARY_FOR_COMPRESSED_TEST
"
"
binary
"
)
;
}
)
;
await
server
.
registerPathHandler
(
"
/
compressed
-
match
/
test
"
function
(
request
response
)
{
global
.
lastCompressedAvailDict
=
request
.
headers
[
"
available
-
dictionary
"
]
|
|
null
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
text
/
plain
"
"
Cache
-
Control
"
:
"
no
-
cache
"
}
)
;
response
.
end
(
"
MATCHING_CONTENT
"
"
binary
"
)
;
}
)
;
dump
(
"
*
*
*
*
Step
1
:
Load
dictionary
resource
with
Use
-
As
-
Dictionary
\
n
"
)
;
let
dictUrl
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
compressed
;
let
chan
=
makeChan
(
dictUrl
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
DICTIONARY_FOR_COMPRESSED_TEST
"
"
Dictionary
content
should
match
"
)
;
await
verifyDictionaryStored
(
dictUrl
true
)
;
await
syncCache
(
)
;
dump
(
"
*
*
*
*
Step
1
.
5
:
Clear
in
-
memory
caches
to
force
reload
from
disk
\
n
"
)
;
await
clearDictionaryCacheAndPurgeMemory
(
)
;
dump
(
"
*
*
*
*
Step
2
:
Verify
Available
-
Dictionary
is
sent
\
n
"
)
;
let
matchingUrl
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
compressed
-
match
/
test
;
chan
=
makeChan
(
matchingUrl
)
;
await
channelOpenPromise
(
chan
)
;
receivedAvailableDictionary
=
await
server
.
execute
(
"
global
.
lastCompressedAvailDict
"
)
;
Assert
.
notStrictEqual
(
receivedAvailableDictionary
null
"
Available
-
Dictionary
should
be
sent
initially
"
)
;
dump
(
"
*
*
*
*
Step
3
:
Force
-
reload
with
gzip
-
compressed
content
(
no
Use
-
As
-
Dictionary
)
\
n
"
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
compressed
"
function
(
request
response
)
{
const
zlib
=
require
(
"
zlib
"
)
;
const
compressed
=
zlib
.
gzipSync
(
"
GZIP_COMPRESSED_REPLACEMENT
"
)
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Content
-
Encoding
"
:
"
gzip
"
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
compressed
)
;
}
)
;
chan
=
makeChan
(
dictUrl
true
)
;
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
GZIP_COMPRESSED_REPLACEMENT
"
"
Decompressed
replacement
content
should
match
"
)
;
dump
(
"
*
*
*
*
Step
4
:
Verify
Available
-
Dictionary
is
NOT
sent
anymore
\
n
"
)
;
await
server
.
execute
(
"
global
.
lastCompressedAvailDict
=
null
"
)
;
chan
=
makeChan
(
matchingUrl
)
;
await
channelOpenPromise
(
chan
)
;
receivedAvailableDictionary
=
await
server
.
execute
(
"
global
.
lastCompressedAvailDict
"
)
;
Assert
.
equal
(
receivedAvailableDictionary
null
"
Available
-
Dictionary
should
NOT
be
sent
after
dictionary
replaced
with
compressed
content
"
)
;
dump
(
"
*
*
*
*
Test
passed
:
Dictionary
metadata
removed
even
with
compressed
replacement
\
n
"
)
;
}
)
;
add_task
(
async
function
test_dictionary_multiple_replacements
(
)
{
dump
(
"
*
*
*
*
Clear
cache
and
start
fresh
\
n
"
)
;
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
let
testingInterface
=
Services
.
cache2
.
QueryInterface
(
Ci
.
nsICacheTesting
)
;
testingInterface
.
clearDictionaryCacheMemory
(
)
;
await
syncCache
(
)
;
let
receivedAvailableDictionary
=
null
;
await
server
.
registerPathHandler
(
"
/
multi
-
match
/
test
"
function
(
request
response
)
{
global
.
lastMultiAvailDict
=
request
.
headers
[
"
available
-
dictionary
"
]
|
|
null
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
text
/
plain
"
"
Cache
-
Control
"
:
"
no
-
cache
"
}
)
;
response
.
end
(
"
MULTI_MATCHING_CONTENT
"
"
binary
"
)
;
}
)
;
let
dictUrl
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
multi
;
let
matchingUrl
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
multi
-
match
/
test
;
dump
(
"
*
*
*
*
Load
as
dictionary
(
first
time
)
\
n
"
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
multi
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
'
match
=
"
/
multi
-
match
/
*
"
id
=
"
multi
-
dict
-
1
"
type
=
raw
'
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
"
DICTIONARY_CONTENT_V1
"
"
binary
"
)
;
}
)
;
let
chan
=
makeChan
(
dictUrl
)
;
await
channelOpenPromise
(
chan
)
;
await
syncCache
(
)
;
await
clearDictionaryCacheAndPurgeMemory
(
)
;
chan
=
makeChan
(
matchingUrl
)
;
await
channelOpenPromise
(
chan
)
;
receivedAvailableDictionary
=
await
server
.
execute
(
"
global
.
lastMultiAvailDict
"
)
;
Assert
.
notStrictEqual
(
receivedAvailableDictionary
null
"
Available
-
Dictionary
should
be
sent
(
first
dictionary
)
"
)
;
dump
(
"
*
*
*
*
Replace
with
non
-
dictionary
\
n
"
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
multi
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
"
NON_DICTIONARY_CONTENT
"
"
binary
"
)
;
}
)
;
chan
=
makeChan
(
dictUrl
true
)
;
await
channelOpenPromise
(
chan
)
;
await
syncCache
(
)
;
await
new
Promise
(
resolve
=
>
do_timeout
(
200
resolve
)
)
;
await
server
.
execute
(
"
global
.
lastMultiAvailDict
=
null
"
)
;
chan
=
makeChan
(
matchingUrl
)
;
await
channelOpenPromise
(
chan
)
;
receivedAvailableDictionary
=
await
server
.
execute
(
"
global
.
lastMultiAvailDict
"
)
;
Assert
.
equal
(
receivedAvailableDictionary
null
"
Available
-
Dictionary
should
NOT
be
sent
(
after
first
replacement
)
"
)
;
dump
(
"
*
*
*
*
Load
as
dictionary
(
second
time
)
\
n
"
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
multi
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
'
match
=
"
/
multi
-
match
/
*
"
id
=
"
multi
-
dict
-
2
"
type
=
raw
'
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
"
DICTIONARY_CONTENT_V2
"
"
binary
"
)
;
}
)
;
chan
=
makeChan
(
dictUrl
true
)
;
await
channelOpenPromise
(
chan
)
;
await
syncCache
(
)
;
await
clearDictionaryCacheAndPurgeMemory
(
)
;
chan
=
makeChan
(
matchingUrl
)
;
await
channelOpenPromise
(
chan
)
;
receivedAvailableDictionary
=
await
server
.
execute
(
"
global
.
lastMultiAvailDict
"
)
;
Assert
.
notStrictEqual
(
receivedAvailableDictionary
null
"
Available
-
Dictionary
should
be
sent
(
second
dictionary
)
"
)
;
dump
(
"
*
*
*
*
Replace
with
non
-
dictionary
again
\
n
"
)
;
await
server
.
registerPathHandler
(
"
/
dict
/
multi
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
"
NON_DICTIONARY_CONTENT_V2
"
"
binary
"
)
;
}
)
;
chan
=
makeChan
(
dictUrl
true
)
;
await
channelOpenPromise
(
chan
)
;
await
syncCache
(
)
;
await
new
Promise
(
resolve
=
>
do_timeout
(
200
resolve
)
)
;
await
server
.
execute
(
"
global
.
lastMultiAvailDict
=
null
"
)
;
chan
=
makeChan
(
matchingUrl
)
;
await
channelOpenPromise
(
chan
)
;
receivedAvailableDictionary
=
await
server
.
execute
(
"
global
.
lastMultiAvailDict
"
)
;
Assert
.
equal
(
receivedAvailableDictionary
null
"
Available
-
Dictionary
should
NOT
be
sent
(
after
second
replacement
)
"
)
;
dump
(
"
*
*
*
*
Test
passed
:
Multiple
replacements
work
correctly
\
n
"
)
;
}
)
;
add_task
(
async
function
test_dictionary_hash_mismatch
(
)
{
dump
(
"
*
*
*
*
Clear
cache
and
start
fresh
\
n
"
)
;
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
let
testingInterface
=
Services
.
cache2
.
QueryInterface
(
Ci
.
nsICacheTesting
)
;
testingInterface
.
clearDictionaryCacheMemory
(
)
;
await
syncCache
(
)
;
let
receivedAvailableDictionary
=
null
;
await
server
.
registerPathHandler
(
"
/
dict
/
hash
-
test
"
function
(
request
response
)
{
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
"
Use
-
As
-
Dictionary
"
:
'
match
=
"
/
hash
-
match
/
*
"
id
=
"
hash
-
test
-
dict
"
type
=
raw
'
"
Cache
-
Control
"
:
"
max
-
age
=
3600
"
}
)
;
response
.
end
(
"
DICTIONARY_FOR_HASH_TEST
"
"
binary
"
)
;
}
)
;
await
server
.
registerPathHandler
(
"
/
hash
-
match
/
test
"
function
(
request
response
)
{
global
.
lastHashTestAvailDict
=
request
.
headers
[
"
available
-
dictionary
"
]
|
|
null
;
response
.
writeHead
(
200
{
"
Content
-
Type
"
:
"
text
/
plain
"
"
Cache
-
Control
"
:
"
no
-
cache
"
}
)
;
response
.
end
(
"
HASH_MATCHING_CONTENT
"
"
binary
"
)
;
}
)
;
dump
(
"
*
*
*
*
Step
1
:
Load
dictionary
resource
with
Use
-
As
-
Dictionary
\
n
"
)
;
let
dictUrl
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
dict
/
hash
-
test
;
let
chan
=
makeChan
(
dictUrl
)
;
let
[
data
]
=
await
channelOpenPromise
(
chan
)
;
Assert
.
equal
(
data
"
DICTIONARY_FOR_HASH_TEST
"
"
Dictionary
content
should
match
"
)
;
await
verifyDictionaryStored
(
dictUrl
true
)
;
await
syncCache
(
)
;
dump
(
"
*
*
*
*
Step
2
:
Verify
Available
-
Dictionary
is
sent
\
n
"
)
;
let
matchingUrl
=
https
:
/
/
localhost
:
{
server
.
port
(
)
}
/
hash
-
match
/
test
;
chan
=
makeChan
(
matchingUrl
)
;
await
channelOpenPromise
(
chan
)
;
receivedAvailableDictionary
=
await
server
.
execute
(
"
global
.
lastHashTestAvailDict
"
)
;
Assert
.
notStrictEqual
(
receivedAvailableDictionary
null
"
Available
-
Dictionary
should
be
sent
initially
"
)
;
dump
(
"
*
*
*
*
Step
3
:
Corrupt
the
dictionary
hash
\
n
"
)
;
testingInterface
.
corruptDictionaryHash
(
dictUrl
)
;
dump
(
"
*
*
*
*
Step
4
:
Clear
dictionary
data
to
force
reload
from
disk
\
n
"
)
;
testingInterface
.
clearDictionaryDataForTesting
(
dictUrl
)
;
dump
(
"
*
*
*
*
Step
5
:
Request
matching
resource
-
should
fail
due
to
hash
mismatch
\
n
"
)
;
await
server
.
execute
(
"
global
.
lastHashTestAvailDict
=
null
"
)
;
chan
=
makeChan
(
matchingUrl
)
;
try
{
await
channelOpenPromise
(
chan
true
)
;
}
catch
(
e
)
{
dump
(
*
*
*
*
Request
failed
with
:
{
e
}
\
n
)
;
}
dump
(
"
*
*
*
*
Step
6
:
Verify
dictionary
entry
was
removed
\
n
"
)
;
await
syncCache
(
)
;
await
server
.
execute
(
"
global
.
lastHashTestAvailDict
=
null
"
)
;
chan
=
makeChan
(
matchingUrl
)
;
await
channelOpenPromise
(
chan
)
;
receivedAvailableDictionary
=
await
server
.
execute
(
"
global
.
lastHashTestAvailDict
"
)
;
Assert
.
equal
(
receivedAvailableDictionary
null
"
Available
-
Dictionary
should
NOT
be
sent
after
dictionary
was
removed
due
to
hash
mismatch
"
)
;
dump
(
"
*
*
*
*
Test
passed
:
Hash
mismatch
properly
handled
\
n
"
)
;
}
)
;
add_task
(
async
function
cleanup
(
)
{
let
lci
=
Services
.
loadContextInfo
.
custom
(
false
{
partitionKey
:
(
https
localhost
)
}
)
;
evict_cache_entries
(
"
all
"
lci
)
;
dump
(
"
*
*
*
*
All
dictionary
replacement
tests
completed
\
n
"
)
;
}
)
;
