var
EXPORTED_SYMBOLS
=
[
"
HTTP_400
"
"
HTTP_401
"
"
HTTP_402
"
"
HTTP_403
"
"
HTTP_404
"
"
HTTP_405
"
"
HTTP_406
"
"
HTTP_407
"
"
HTTP_408
"
"
HTTP_409
"
"
HTTP_410
"
"
HTTP_411
"
"
HTTP_412
"
"
HTTP_413
"
"
HTTP_414
"
"
HTTP_415
"
"
HTTP_417
"
"
HTTP_500
"
"
HTTP_501
"
"
HTTP_502
"
"
HTTP_503
"
"
HTTP_504
"
"
HTTP_505
"
"
HttpError
"
"
HttpServer
"
"
NodeServer
"
]
;
const
CC
=
Components
.
Constructor
;
const
PR_UINT32_MAX
=
Math
.
pow
(
2
32
)
-
1
;
var
DEBUG
=
false
;
var
DEBUG_TIMESTAMP
=
false
;
var
gGlobalObject
=
Cu
.
getGlobalForObject
(
this
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
function
NS_ASSERT
(
cond
msg
)
{
if
(
DEBUG
&
&
!
cond
)
{
dumpn
(
"
#
#
#
!
!
!
"
)
;
dumpn
(
"
#
#
#
!
!
!
ASSERTION
"
+
(
msg
?
"
:
"
+
msg
:
"
!
"
)
)
;
dumpn
(
"
#
#
#
!
!
!
Stack
follows
:
"
)
;
var
stack
=
new
Error
(
)
.
stack
.
split
(
/
\
n
/
)
;
dumpn
(
stack
.
map
(
function
(
val
)
{
return
"
#
#
#
!
!
!
"
+
val
;
}
)
.
join
(
"
\
n
"
)
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_ABORT
)
;
}
}
function
HttpError
(
code
description
)
{
this
.
code
=
code
;
this
.
description
=
description
;
}
HttpError
.
prototype
=
{
toString
(
)
{
return
this
.
code
+
"
"
+
this
.
description
;
}
}
;
var
HTTP_400
=
new
HttpError
(
400
"
Bad
Request
"
)
;
var
HTTP_401
=
new
HttpError
(
401
"
Unauthorized
"
)
;
var
HTTP_402
=
new
HttpError
(
402
"
Payment
Required
"
)
;
var
HTTP_403
=
new
HttpError
(
403
"
Forbidden
"
)
;
var
HTTP_404
=
new
HttpError
(
404
"
Not
Found
"
)
;
var
HTTP_405
=
new
HttpError
(
405
"
Method
Not
Allowed
"
)
;
var
HTTP_406
=
new
HttpError
(
406
"
Not
Acceptable
"
)
;
var
HTTP_407
=
new
HttpError
(
407
"
Proxy
Authentication
Required
"
)
;
var
HTTP_408
=
new
HttpError
(
408
"
Request
Timeout
"
)
;
var
HTTP_409
=
new
HttpError
(
409
"
Conflict
"
)
;
var
HTTP_410
=
new
HttpError
(
410
"
Gone
"
)
;
var
HTTP_411
=
new
HttpError
(
411
"
Length
Required
"
)
;
var
HTTP_412
=
new
HttpError
(
412
"
Precondition
Failed
"
)
;
var
HTTP_413
=
new
HttpError
(
413
"
Request
Entity
Too
Large
"
)
;
var
HTTP_414
=
new
HttpError
(
414
"
Request
-
URI
Too
Long
"
)
;
var
HTTP_415
=
new
HttpError
(
415
"
Unsupported
Media
Type
"
)
;
var
HTTP_417
=
new
HttpError
(
417
"
Expectation
Failed
"
)
;
var
HTTP_500
=
new
HttpError
(
500
"
Internal
Server
Error
"
)
;
var
HTTP_501
=
new
HttpError
(
501
"
Not
Implemented
"
)
;
var
HTTP_502
=
new
HttpError
(
502
"
Bad
Gateway
"
)
;
var
HTTP_503
=
new
HttpError
(
503
"
Service
Unavailable
"
)
;
var
HTTP_504
=
new
HttpError
(
504
"
Gateway
Timeout
"
)
;
var
HTTP_505
=
new
HttpError
(
505
"
HTTP
Version
Not
Supported
"
)
;
function
array2obj
(
arr
)
{
var
obj
=
{
}
;
for
(
var
i
=
0
;
i
<
arr
.
length
;
i
+
+
)
{
obj
[
arr
[
i
]
]
=
arr
[
i
]
;
}
return
obj
;
}
function
range
(
x
y
)
{
var
arr
=
[
]
;
for
(
var
i
=
x
;
i
<
=
y
;
i
+
+
)
{
arr
.
push
(
i
)
;
}
return
arr
;
}
const
HTTP_ERROR_CODES
=
array2obj
(
range
(
400
417
)
.
concat
(
range
(
500
505
)
)
)
;
const
HIDDEN_CHAR
=
"
^
"
;
const
HEADERS_SUFFIX
=
HIDDEN_CHAR
+
"
headers
"
+
HIDDEN_CHAR
;
const
INFORMATIONAL_RESPONSE_SUFFIX
=
HIDDEN_CHAR
+
"
informationalResponse
"
+
HIDDEN_CHAR
;
const
SJS_TYPE
=
"
sjs
"
;
var
firstStamp
=
0
;
function
dumpn
(
str
)
{
if
(
DEBUG
)
{
var
prefix
=
"
HTTPD
-
INFO
|
"
;
if
(
DEBUG_TIMESTAMP
)
{
if
(
firstStamp
=
=
=
0
)
{
firstStamp
=
Date
.
now
(
)
;
}
var
elapsed
=
Date
.
now
(
)
-
firstStamp
;
var
min
=
Math
.
floor
(
elapsed
/
60000
)
;
var
sec
=
(
elapsed
%
60000
)
/
1000
;
if
(
sec
<
10
)
{
prefix
+
=
min
+
"
:
0
"
+
sec
.
toFixed
(
3
)
+
"
|
"
;
}
else
{
prefix
+
=
min
+
"
:
"
+
sec
.
toFixed
(
3
)
+
"
|
"
;
}
}
dump
(
prefix
+
str
+
"
\
n
"
)
;
}
}
function
dumpStack
(
)
{
var
stack
=
new
Error
(
)
.
stack
.
split
(
/
\
n
/
)
.
slice
(
2
)
;
stack
.
forEach
(
dumpn
)
;
}
var
gThreadManager
=
null
;
const
ServerSocket
=
CC
(
"
mozilla
.
org
/
network
/
server
-
socket
;
1
"
"
nsIServerSocket
"
"
init
"
)
;
const
ServerSocketIPv6
=
CC
(
"
mozilla
.
org
/
network
/
server
-
socket
;
1
"
"
nsIServerSocket
"
"
initIPv6
"
)
;
const
ScriptableInputStream
=
CC
(
"
mozilla
.
org
/
scriptableinputstream
;
1
"
"
nsIScriptableInputStream
"
"
init
"
)
;
const
Pipe
=
CC
(
"
mozilla
.
org
/
pipe
;
1
"
"
nsIPipe
"
"
init
"
)
;
const
FileInputStream
=
CC
(
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
"
nsIFileInputStream
"
"
init
"
)
;
const
ConverterInputStream
=
CC
(
"
mozilla
.
org
/
intl
/
converter
-
input
-
stream
;
1
"
"
nsIConverterInputStream
"
"
init
"
)
;
const
WritablePropertyBag
=
CC
(
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
"
nsIWritablePropertyBag2
"
)
;
const
SupportsString
=
CC
(
"
mozilla
.
org
/
supports
-
string
;
1
"
"
nsISupportsString
"
)
;
var
BinaryInputStream
=
CC
(
"
mozilla
.
org
/
binaryinputstream
;
1
"
"
nsIBinaryInputStream
"
"
setInputStream
"
)
;
var
BinaryOutputStream
=
CC
(
"
mozilla
.
org
/
binaryoutputstream
;
1
"
"
nsIBinaryOutputStream
"
"
setOutputStream
"
)
;
function
toDateString
(
date
)
{
const
wkdayStrings
=
[
"
Sun
"
"
Mon
"
"
Tue
"
"
Wed
"
"
Thu
"
"
Fri
"
"
Sat
"
]
;
const
monthStrings
=
[
"
Jan
"
"
Feb
"
"
Mar
"
"
Apr
"
"
May
"
"
Jun
"
"
Jul
"
"
Aug
"
"
Sep
"
"
Oct
"
"
Nov
"
"
Dec
"
]
;
function
toTime
(
date
)
{
var
hrs
=
date
.
getUTCHours
(
)
;
var
rv
=
hrs
<
10
?
"
0
"
+
hrs
:
hrs
;
var
mins
=
date
.
getUTCMinutes
(
)
;
rv
+
=
"
:
"
;
rv
+
=
mins
<
10
?
"
0
"
+
mins
:
mins
;
var
secs
=
date
.
getUTCSeconds
(
)
;
rv
+
=
"
:
"
;
rv
+
=
secs
<
10
?
"
0
"
+
secs
:
secs
;
return
rv
;
}
function
toDate1
(
date
)
{
var
day
=
date
.
getUTCDate
(
)
;
var
month
=
date
.
getUTCMonth
(
)
;
var
year
=
date
.
getUTCFullYear
(
)
;
var
rv
=
day
<
10
?
"
0
"
+
day
:
day
;
rv
+
=
"
"
+
monthStrings
[
month
]
;
rv
+
=
"
"
+
year
;
return
rv
;
}
date
=
new
Date
(
date
)
;
const
fmtString
=
"
%
wkday
%
%
date1
%
%
time
%
GMT
"
;
var
rv
=
fmtString
.
replace
(
"
%
wkday
%
"
wkdayStrings
[
date
.
getUTCDay
(
)
]
)
;
rv
=
rv
.
replace
(
"
%
time
%
"
toTime
(
date
)
)
;
return
rv
.
replace
(
"
%
date1
%
"
toDate1
(
date
)
)
;
}
function
printObj
(
o
showMembers
)
{
var
s
=
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
;
s
+
=
"
o
=
{
\
n
"
;
for
(
var
i
in
o
)
{
if
(
typeof
i
!
=
"
string
"
|
|
showMembers
|
|
(
i
.
length
>
0
&
&
i
[
0
]
!
=
"
_
"
)
)
{
s
+
=
"
"
+
i
+
"
:
"
+
o
[
i
]
+
"
\
n
"
;
}
}
s
+
=
"
}
;
\
n
"
;
s
+
=
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
"
;
dumpn
(
s
)
;
}
function
nsHttpServer
(
)
{
if
(
!
gThreadManager
)
{
gThreadManager
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
)
;
}
this
.
_port
=
undefined
;
this
.
_socket
=
null
;
this
.
_handler
=
new
ServerHandler
(
this
)
;
this
.
_identity
=
new
ServerIdentity
(
)
;
this
.
_doQuit
=
false
;
this
.
_socketClosed
=
true
;
this
.
_connectionGen
=
0
;
this
.
_connections
=
{
}
;
}
nsHttpServer
.
prototype
=
{
onSocketAccepted
(
socket
trans
)
{
dumpn
(
"
*
*
*
onSocketAccepted
(
socket
=
"
+
socket
+
"
trans
=
"
+
trans
+
"
)
"
)
;
dumpn
(
"
>
>
>
new
connection
on
"
+
trans
.
host
+
"
:
"
+
trans
.
port
)
;
const
SEGMENT_SIZE
=
8192
;
const
SEGMENT_COUNT
=
1024
;
try
{
var
input
=
trans
.
openInputStream
(
0
SEGMENT_SIZE
SEGMENT_COUNT
)
.
QueryInterface
(
Ci
.
nsIAsyncInputStream
)
;
var
output
=
trans
.
openOutputStream
(
0
0
0
)
;
}
catch
(
e
)
{
dumpn
(
"
*
*
*
error
opening
transport
streams
:
"
+
e
)
;
trans
.
close
(
Cr
.
NS_BINDING_ABORTED
)
;
return
;
}
var
connectionNumber
=
+
+
this
.
_connectionGen
;
try
{
var
conn
=
new
Connection
(
input
output
this
socket
.
port
trans
.
port
connectionNumber
trans
)
;
var
reader
=
new
RequestReader
(
conn
)
;
input
.
asyncWait
(
reader
0
0
gThreadManager
.
mainThread
)
;
}
catch
(
e
)
{
dumpn
(
"
*
*
*
error
in
initial
request
-
processing
stages
:
"
+
e
)
;
trans
.
close
(
Cr
.
NS_BINDING_ABORTED
)
;
return
;
}
this
.
_connections
[
connectionNumber
]
=
conn
;
dumpn
(
"
*
*
*
starting
connection
"
+
connectionNumber
)
;
}
onStopListening
(
socket
status
)
{
dumpn
(
"
>
>
>
shutting
down
server
on
port
"
+
socket
.
port
)
;
for
(
var
n
in
this
.
_connections
)
{
if
(
!
this
.
_connections
[
n
]
.
_requestStarted
)
{
this
.
_connections
[
n
]
.
close
(
)
;
}
}
this
.
_socketClosed
=
true
;
if
(
this
.
_hasOpenConnections
(
)
)
{
dumpn
(
"
*
*
*
open
connections
!
!
!
"
)
;
}
if
(
!
this
.
_hasOpenConnections
(
)
)
{
dumpn
(
"
*
*
*
no
open
connections
notifying
async
from
onStopListening
"
)
;
var
self
=
this
;
var
stopEvent
=
{
run
(
)
{
dumpn
(
"
*
*
*
_notifyStopped
async
callback
"
)
;
self
.
_notifyStopped
(
)
;
}
}
;
gThreadManager
.
currentThread
.
dispatch
(
stopEvent
Ci
.
nsIThread
.
DISPATCH_NORMAL
)
;
}
}
start
(
port
)
{
this
.
_start
(
port
"
localhost
"
)
;
}
start_ipv6
(
port
)
{
this
.
_start
(
port
"
[
:
:
1
]
"
)
;
}
_start
(
port
host
)
{
if
(
this
.
_socket
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_ALREADY_INITIALIZED
)
;
}
this
.
_port
=
port
;
this
.
_doQuit
=
this
.
_socketClosed
=
false
;
this
.
_host
=
host
;
var
maxConnections
=
5
+
Math
.
max
(
Services
.
prefs
.
getIntPref
(
"
network
.
http
.
max
-
persistent
-
connections
-
per
-
server
"
)
Services
.
prefs
.
getIntPref
(
"
network
.
http
.
max
-
persistent
-
connections
-
per
-
proxy
"
)
)
;
try
{
var
loopback
=
true
;
if
(
this
.
_host
!
=
"
127
.
0
.
0
.
1
"
&
&
this
.
_host
!
=
"
localhost
"
&
&
this
.
_host
!
=
"
[
:
:
1
]
"
)
{
loopback
=
false
;
}
var
socket
;
for
(
var
i
=
100
;
i
;
i
-
-
)
{
var
temp
=
null
;
if
(
this
.
_host
.
includes
(
"
:
"
)
)
{
temp
=
new
ServerSocketIPv6
(
this
.
_port
loopback
maxConnections
)
;
}
else
{
temp
=
new
ServerSocket
(
this
.
_port
loopback
maxConnections
)
;
}
var
allowed
=
Services
.
io
.
allowPort
(
temp
.
port
"
http
"
)
;
if
(
!
allowed
)
{
dumpn
(
"
>
>
>
Warning
:
obtained
ServerSocket
listens
on
a
blocked
"
+
"
port
:
"
+
temp
.
port
)
;
}
if
(
!
allowed
&
&
this
.
_port
=
=
-
1
)
{
dumpn
(
"
>
>
>
Throwing
away
ServerSocket
with
bad
port
.
"
)
;
temp
.
close
(
)
;
continue
;
}
socket
=
temp
;
break
;
}
if
(
!
socket
)
{
throw
new
Error
(
"
No
socket
server
available
.
Are
there
no
available
ports
?
"
)
;
}
socket
.
asyncListen
(
this
)
;
this
.
_port
=
socket
.
port
;
this
.
_identity
.
_initialize
(
socket
.
port
host
true
)
;
this
.
_socket
=
socket
;
dumpn
(
"
>
>
>
listening
on
port
"
+
socket
.
port
+
"
"
+
maxConnections
+
"
pending
connections
"
)
;
}
catch
(
e
)
{
dump
(
"
\
n
!
!
!
could
not
start
server
on
port
"
+
port
+
"
:
"
+
e
+
"
\
n
\
n
"
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
}
stop
(
callback
)
{
if
(
!
this
.
_socket
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
let
returnValue
=
undefined
;
if
(
!
callback
)
{
returnValue
=
new
Promise
(
resolve
=
>
{
callback
=
resolve
;
}
)
;
}
this
.
_stopCallback
=
typeof
callback
=
=
=
"
function
"
?
callback
:
function
(
)
{
callback
.
onStopped
(
)
;
}
;
dumpn
(
"
>
>
>
stopping
listening
on
port
"
+
this
.
_socket
.
port
)
;
this
.
_socket
.
close
(
)
;
this
.
_socket
=
null
;
this
.
_identity
.
_teardown
(
)
;
this
.
_doQuit
=
false
;
return
returnValue
;
}
registerFile
(
path
file
handler
)
{
if
(
file
&
&
(
!
file
.
exists
(
)
|
|
file
.
isDirectory
(
)
)
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
_handler
.
registerFile
(
path
file
handler
)
;
}
registerDirectory
(
path
directory
)
{
if
(
path
.
charAt
(
0
)
!
=
"
/
"
|
|
path
.
charAt
(
path
.
length
-
1
)
!
=
"
/
"
|
|
(
directory
&
&
(
!
directory
.
exists
(
)
|
|
!
directory
.
isDirectory
(
)
)
)
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
_handler
.
registerDirectory
(
path
directory
)
;
}
registerPathHandler
(
path
handler
)
{
this
.
_handler
.
registerPathHandler
(
path
handler
)
;
}
registerPrefixHandler
(
prefix
handler
)
{
this
.
_handler
.
registerPrefixHandler
(
prefix
handler
)
;
}
registerErrorHandler
(
code
handler
)
{
this
.
_handler
.
registerErrorHandler
(
code
handler
)
;
}
setIndexHandler
(
handler
)
{
this
.
_handler
.
setIndexHandler
(
handler
)
;
}
registerContentType
(
ext
type
)
{
this
.
_handler
.
registerContentType
(
ext
type
)
;
}
get
connectionNumber
(
)
{
return
this
.
_connectionGen
;
}
get
identity
(
)
{
return
this
.
_identity
;
}
getState
(
path
k
)
{
return
this
.
_handler
.
_getState
(
path
k
)
;
}
setState
(
path
k
v
)
{
return
this
.
_handler
.
_setState
(
path
k
v
)
;
}
getSharedState
(
k
)
{
return
this
.
_handler
.
_getSharedState
(
k
)
;
}
setSharedState
(
k
v
)
{
return
this
.
_handler
.
_setSharedState
(
k
v
)
;
}
getObjectState
(
k
)
{
return
this
.
_handler
.
_getObjectState
(
k
)
;
}
setObjectState
(
k
v
)
{
return
this
.
_handler
.
_setObjectState
(
k
v
)
;
}
get
wrappedJSObject
(
)
{
return
this
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIHttpServer
"
"
nsIServerSocketListener
"
]
)
isStopped
(
)
{
return
this
.
_socketClosed
&
&
!
this
.
_hasOpenConnections
(
)
;
}
_hasOpenConnections
(
)
{
for
(
var
n
in
this
.
_connections
)
{
return
true
;
}
return
false
;
}
_notifyStopped
(
)
{
NS_ASSERT
(
this
.
_stopCallback
!
=
=
null
"
double
-
notifying
?
"
)
;
NS_ASSERT
(
!
this
.
_hasOpenConnections
(
)
"
should
be
done
serving
by
now
"
)
;
var
callback
=
this
.
_stopCallback
;
this
.
_stopCallback
=
null
;
try
{
callback
(
)
;
}
catch
(
e
)
{
dump
(
"
!
!
!
error
running
onStopped
callback
:
"
+
e
+
"
\
n
"
)
;
}
}
_connectionClosed
(
connection
)
{
NS_ASSERT
(
connection
.
number
in
this
.
_connections
"
closing
a
connection
"
+
this
+
"
that
we
never
added
to
the
"
+
"
set
of
open
connections
?
"
)
;
NS_ASSERT
(
this
.
_connections
[
connection
.
number
]
=
=
=
connection
"
connection
number
mismatch
?
"
+
this
.
_connections
[
connection
.
number
]
)
;
delete
this
.
_connections
[
connection
.
number
]
;
if
(
!
this
.
_hasOpenConnections
(
)
&
&
this
.
_socketClosed
)
{
this
.
_notifyStopped
(
)
;
}
}
_requestQuit
(
)
{
dumpn
(
"
>
>
>
requesting
a
quit
"
)
;
dumpStack
(
)
;
this
.
_doQuit
=
true
;
}
}
;
var
HttpServer
=
nsHttpServer
;
class
NodeServer
{
static
fork
(
)
{
return
this
.
sendCommand
(
"
"
"
/
fork
"
)
;
}
static
execute
(
id
command
)
{
return
this
.
sendCommand
(
command
/
execute
/
{
id
}
)
;
}
static
kill
(
id
)
{
return
this
.
sendCommand
(
"
"
/
kill
/
{
id
}
)
;
}
static
sendCommand
(
command
path
)
{
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
h2Port
=
env
.
get
(
"
MOZNODE_EXEC_PORT
"
)
;
if
(
!
h2Port
)
{
throw
new
Error
(
"
Could
not
find
MOZNODE_EXEC_PORT
"
)
;
}
let
req
=
new
XMLHttpRequest
(
)
;
const
serverIP
=
AppConstants
.
platform
=
=
"
android
"
?
"
10
.
0
.
2
.
2
"
:
"
127
.
0
.
0
.
1
"
;
req
.
open
(
"
POST
"
http
:
/
/
{
serverIP
}
:
{
h2Port
}
{
path
}
)
;
let
isFunction
=
function
(
obj
)
{
return
!
!
(
obj
&
&
obj
.
constructor
&
&
obj
.
call
&
&
obj
.
apply
)
;
}
;
let
payload
=
command
;
if
(
isFunction
(
command
)
)
{
payload
=
{
command
.
name
}
=
{
command
.
toString
(
)
}
;
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
req
.
onload
=
(
)
=
>
{
let
x
=
null
;
if
(
req
.
statusText
!
=
"
OK
"
)
{
reject
(
XHR
request
failed
:
{
req
.
statusText
}
)
;
return
;
}
try
{
x
=
JSON
.
parse
(
req
.
responseText
)
;
}
catch
(
e
)
{
reject
(
Failed
to
parse
{
req
.
responseText
}
-
{
e
}
)
;
return
;
}
if
(
x
.
error
)
{
let
e
=
new
Error
(
x
.
error
"
"
0
)
;
e
.
stack
=
x
.
errorStack
;
reject
(
e
)
;
return
;
}
resolve
(
x
.
result
)
;
}
;
req
.
onerror
=
e
=
>
{
reject
(
e
)
;
}
;
req
.
send
(
payload
.
toString
(
)
)
;
}
)
;
}
}
const
HOST_REGEX
=
new
RegExp
(
"
^
(
?
:
"
+
"
(
?
:
[
a
-
z0
-
9
]
(
?
:
[
a
-
z0
-
9
-
]
*
[
a
-
z0
-
9
]
)
?
\
\
.
)
*
"
+
"
[
a
-
z
]
(
?
:
[
a
-
z0
-
9
-
]
*
[
a
-
z0
-
9
]
)
?
"
+
"
|
"
+
"
\
\
d
+
\
\
.
\
\
d
+
\
\
.
\
\
d
+
\
\
.
\
\
d
+
"
+
"
)
"
"
i
"
)
;
function
ServerIdentity
(
)
{
this
.
_primaryScheme
=
"
http
"
;
this
.
_primaryHost
=
"
127
.
0
.
0
.
1
"
;
this
.
_primaryPort
=
-
1
;
this
.
_defaultPort
=
-
1
;
this
.
_locations
=
{
xlocalhost
:
{
}
}
;
}
ServerIdentity
.
prototype
=
{
get
primaryScheme
(
)
{
if
(
this
.
_primaryPort
=
=
=
-
1
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
return
this
.
_primaryScheme
;
}
get
primaryHost
(
)
{
if
(
this
.
_primaryPort
=
=
=
-
1
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
return
this
.
_primaryHost
;
}
get
primaryPort
(
)
{
if
(
this
.
_primaryPort
=
=
=
-
1
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
return
this
.
_primaryPort
;
}
add
(
scheme
host
port
)
{
this
.
_validate
(
scheme
host
port
)
;
var
entry
=
this
.
_locations
[
"
x
"
+
host
]
;
if
(
!
entry
)
{
this
.
_locations
[
"
x
"
+
host
]
=
entry
=
{
}
;
}
entry
[
port
]
=
scheme
;
}
remove
(
scheme
host
port
)
{
this
.
_validate
(
scheme
host
port
)
;
var
entry
=
this
.
_locations
[
"
x
"
+
host
]
;
if
(
!
entry
)
{
return
false
;
}
var
present
=
port
in
entry
;
delete
entry
[
port
]
;
if
(
this
.
_primaryScheme
=
=
scheme
&
&
this
.
_primaryHost
=
=
host
&
&
this
.
_primaryPort
=
=
port
&
&
this
.
_defaultPort
!
=
=
-
1
)
{
this
.
_primaryPort
=
-
1
;
this
.
_initialize
(
this
.
_defaultPort
host
false
)
;
}
return
present
;
}
has
(
scheme
host
port
)
{
this
.
_validate
(
scheme
host
port
)
;
return
(
"
x
"
+
host
in
this
.
_locations
&
&
scheme
=
=
=
this
.
_locations
[
"
x
"
+
host
]
[
port
]
)
;
}
getScheme
(
host
port
)
{
this
.
_validate
(
"
http
"
host
port
)
;
var
entry
=
this
.
_locations
[
"
x
"
+
host
]
;
if
(
!
entry
)
{
return
"
"
;
}
return
entry
[
port
]
|
|
"
"
;
}
setPrimary
(
scheme
host
port
)
{
this
.
_validate
(
scheme
host
port
)
;
this
.
add
(
scheme
host
port
)
;
this
.
_primaryScheme
=
scheme
;
this
.
_primaryHost
=
host
;
this
.
_primaryPort
=
port
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIHttpServerIdentity
"
]
)
_initialize
(
port
host
addSecondaryDefault
)
{
this
.
_host
=
host
;
if
(
this
.
_primaryPort
!
=
=
-
1
)
{
this
.
add
(
"
http
"
host
port
)
;
}
else
{
this
.
setPrimary
(
"
http
"
"
localhost
"
port
)
;
}
this
.
_defaultPort
=
port
;
if
(
addSecondaryDefault
&
&
host
!
=
"
127
.
0
.
0
.
1
"
)
{
if
(
host
.
includes
(
"
:
"
)
)
{
this
.
add
(
"
http
"
"
[
:
:
1
]
"
port
)
;
}
else
{
this
.
add
(
"
http
"
"
127
.
0
.
0
.
1
"
port
)
;
}
}
}
_teardown
(
)
{
if
(
this
.
_host
!
=
"
127
.
0
.
0
.
1
"
)
{
this
.
remove
(
"
http
"
"
127
.
0
.
0
.
1
"
this
.
_defaultPort
)
;
}
if
(
this
.
_primaryScheme
=
=
"
http
"
&
&
this
.
_primaryHost
=
=
this
.
_host
&
&
this
.
_primaryPort
=
=
this
.
_defaultPort
)
{
var
port
=
this
.
_defaultPort
;
this
.
_defaultPort
=
-
1
;
this
.
remove
(
"
http
"
this
.
_host
port
)
;
this
.
_primaryPort
=
-
1
;
}
else
{
this
.
remove
(
"
http
"
this
.
_host
this
.
_defaultPort
)
;
}
}
_validate
(
scheme
host
port
)
{
if
(
scheme
!
=
=
"
http
"
&
&
scheme
!
=
=
"
https
"
)
{
dumpn
(
"
*
*
*
server
only
supports
http
/
https
schemes
:
'
"
+
scheme
+
"
'
"
)
;
dumpStack
(
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
if
(
!
HOST_REGEX
.
test
(
host
)
&
&
host
!
=
"
[
:
:
1
]
"
)
{
dumpn
(
"
*
*
*
unexpected
host
:
'
"
+
host
+
"
'
"
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
if
(
port
<
0
|
|
port
>
65535
)
{
dumpn
(
"
*
*
*
unexpected
port
:
'
"
+
port
+
"
'
"
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
}
}
;
function
Connection
(
input
output
server
port
outgoingPort
number
transport
)
{
dumpn
(
"
*
*
*
opening
new
connection
"
+
number
+
"
on
port
"
+
outgoingPort
)
;
this
.
input
=
input
;
this
.
output
=
output
;
this
.
server
=
server
;
this
.
port
=
port
;
this
.
_outgoingPort
=
outgoingPort
;
this
.
number
=
number
;
this
.
transport
=
transport
;
this
.
request
=
null
;
this
.
_closed
=
false
;
this
.
_processed
=
false
;
this
.
_requestStarted
=
false
;
}
Connection
.
prototype
=
{
close
(
)
{
if
(
this
.
_closed
)
{
return
;
}
dumpn
(
"
*
*
*
closing
connection
"
+
this
.
number
+
"
on
port
"
+
this
.
_outgoingPort
)
;
this
.
input
.
close
(
)
;
this
.
output
.
close
(
)
;
this
.
_closed
=
true
;
var
server
=
this
.
server
;
server
.
_connectionClosed
(
this
)
;
if
(
server
.
_doQuit
)
{
server
.
stop
(
function
(
)
{
}
)
;
}
}
process
(
request
)
{
NS_ASSERT
(
!
this
.
_closed
&
&
!
this
.
_processed
)
;
this
.
_processed
=
true
;
this
.
request
=
request
;
this
.
server
.
_handler
.
handleResponse
(
this
)
;
}
processError
(
code
request
)
{
NS_ASSERT
(
!
this
.
_closed
&
&
!
this
.
_processed
)
;
this
.
_processed
=
true
;
this
.
request
=
request
;
this
.
server
.
_handler
.
handleError
(
code
this
)
;
}
toString
(
)
{
return
(
"
<
Connection
(
"
+
this
.
number
+
(
this
.
request
?
"
"
+
this
.
request
.
path
:
"
"
)
+
"
)
:
"
+
(
this
.
_closed
?
"
closed
"
:
"
open
"
)
+
"
>
"
)
;
}
requestStarted
(
)
{
this
.
_requestStarted
=
true
;
}
}
;
function
readBytes
(
inputStream
count
)
{
return
new
BinaryInputStream
(
inputStream
)
.
readByteArray
(
count
)
;
}
const
READER_IN_REQUEST_LINE
=
0
;
const
READER_IN_HEADERS
=
1
;
const
READER_IN_BODY
=
2
;
const
READER_FINISHED
=
3
;
function
RequestReader
(
connection
)
{
this
.
_connection
=
connection
;
this
.
_data
=
new
LineData
(
)
;
this
.
_contentLength
=
0
;
this
.
_state
=
READER_IN_REQUEST_LINE
;
this
.
_metadata
=
new
Request
(
connection
.
port
)
;
this
.
_lastHeaderName
=
this
.
_lastHeaderValue
=
undefined
;
}
RequestReader
.
prototype
=
{
onInputStreamReady
(
input
)
{
dumpn
(
"
*
*
*
onInputStreamReady
(
input
=
"
+
input
+
"
)
on
thread
"
+
gThreadManager
.
currentThread
+
"
(
main
is
"
+
gThreadManager
.
mainThread
+
"
)
"
)
;
dumpn
(
"
*
*
*
this
.
_state
=
=
"
+
this
.
_state
)
;
var
data
=
this
.
_data
;
if
(
!
data
)
{
return
;
}
try
{
data
.
appendBytes
(
readBytes
(
input
input
.
available
(
)
)
)
;
}
catch
(
e
)
{
if
(
streamClosed
(
e
)
)
{
dumpn
(
"
*
*
*
WARNING
:
unexpected
error
when
reading
from
socket
;
will
"
+
"
be
treated
as
if
the
input
stream
had
been
closed
"
)
;
dumpn
(
"
*
*
*
WARNING
:
actual
error
was
:
"
+
e
)
;
}
dumpn
(
"
*
*
*
onInputStreamReady
called
on
a
closed
input
destroying
"
+
"
connection
"
)
;
this
.
_connection
.
close
(
)
;
return
;
}
switch
(
this
.
_state
)
{
default
:
NS_ASSERT
(
false
"
invalid
state
:
"
+
this
.
_state
)
;
break
;
case
READER_IN_REQUEST_LINE
:
if
(
!
this
.
_processRequestLine
(
)
)
{
break
;
}
case
READER_IN_HEADERS
:
if
(
!
this
.
_processHeaders
(
)
)
{
break
;
}
case
READER_IN_BODY
:
this
.
_processBody
(
)
;
}
if
(
this
.
_state
!
=
READER_FINISHED
)
{
input
.
asyncWait
(
this
0
0
gThreadManager
.
currentThread
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIInputStreamCallback
"
]
)
_processRequestLine
(
)
{
NS_ASSERT
(
this
.
_state
=
=
READER_IN_REQUEST_LINE
)
;
var
data
=
this
.
_data
;
var
line
=
{
}
;
var
readSuccess
;
while
(
(
readSuccess
=
data
.
readLine
(
line
)
)
&
&
line
.
value
=
=
"
"
)
{
dumpn
(
"
*
*
*
ignoring
beginning
blank
line
.
.
.
"
)
;
}
if
(
!
readSuccess
)
{
return
false
;
}
try
{
this
.
_parseRequestLine
(
line
.
value
)
;
this
.
_state
=
READER_IN_HEADERS
;
this
.
_connection
.
requestStarted
(
)
;
return
true
;
}
catch
(
e
)
{
this
.
_handleError
(
e
)
;
return
false
;
}
}
_processHeaders
(
)
{
NS_ASSERT
(
this
.
_state
=
=
READER_IN_HEADERS
)
;
try
{
var
done
=
this
.
_parseHeaders
(
)
;
if
(
done
)
{
var
request
=
this
.
_metadata
;
this
.
_contentLength
=
request
.
hasHeader
(
"
Content
-
Length
"
)
?
parseInt
(
request
.
getHeader
(
"
Content
-
Length
"
)
10
)
:
0
;
dumpn
(
"
_processHeaders
Content
-
length
=
"
+
this
.
_contentLength
)
;
this
.
_state
=
READER_IN_BODY
;
}
return
done
;
}
catch
(
e
)
{
this
.
_handleError
(
e
)
;
return
false
;
}
}
_processBody
(
)
{
NS_ASSERT
(
this
.
_state
=
=
READER_IN_BODY
)
;
try
{
if
(
this
.
_contentLength
>
0
)
{
var
data
=
this
.
_data
.
purge
(
)
;
var
count
=
Math
.
min
(
data
.
length
this
.
_contentLength
)
;
dumpn
(
"
*
*
*
loading
data
=
"
+
data
+
"
len
=
"
+
data
.
length
+
"
excess
=
"
+
(
data
.
length
-
count
)
)
;
data
.
length
=
count
;
var
bos
=
new
BinaryOutputStream
(
this
.
_metadata
.
_bodyOutputStream
)
;
bos
.
writeByteArray
(
data
)
;
this
.
_contentLength
-
=
count
;
}
dumpn
(
"
*
*
*
remaining
body
data
len
=
"
+
this
.
_contentLength
)
;
if
(
this
.
_contentLength
=
=
0
)
{
this
.
_validateRequest
(
)
;
this
.
_state
=
READER_FINISHED
;
this
.
_handleResponse
(
)
;
return
true
;
}
return
false
;
}
catch
(
e
)
{
this
.
_handleError
(
e
)
;
return
false
;
}
}
_validateRequest
(
)
{
NS_ASSERT
(
this
.
_state
=
=
READER_IN_BODY
)
;
dumpn
(
"
*
*
*
_validateRequest
"
)
;
var
metadata
=
this
.
_metadata
;
var
headers
=
metadata
.
_headers
;
var
identity
=
this
.
_connection
.
server
.
identity
;
if
(
metadata
.
_httpVersion
.
atLeast
(
nsHttpVersion
.
HTTP_1_1
)
)
{
if
(
!
headers
.
hasHeader
(
"
Host
"
)
)
{
dumpn
(
"
*
*
*
malformed
HTTP
/
1
.
1
or
greater
request
with
no
Host
header
!
"
)
;
throw
HTTP_400
;
}
if
(
!
metadata
.
_host
)
{
var
host
port
;
var
hostPort
=
headers
.
getHeader
(
"
Host
"
)
;
var
colon
=
hostPort
.
lastIndexOf
(
"
:
"
)
;
if
(
hostPort
.
lastIndexOf
(
"
]
"
)
>
colon
)
{
colon
=
-
1
;
}
if
(
colon
<
0
)
{
host
=
hostPort
;
port
=
"
"
;
}
else
{
host
=
hostPort
.
substring
(
0
colon
)
;
port
=
hostPort
.
substring
(
colon
+
1
)
;
}
if
(
(
!
HOST_REGEX
.
test
(
host
)
&
&
host
!
=
"
[
:
:
1
]
"
)
|
|
!
/
^
\
d
*
/
.
test
(
port
)
)
{
dumpn
(
"
*
*
*
malformed
hostname
(
"
+
hostPort
+
"
)
in
Host
"
+
"
header
400
time
"
)
;
throw
HTTP_400
;
}
port
=
+
port
|
|
80
;
var
scheme
=
identity
.
getScheme
(
host
port
)
;
if
(
!
scheme
)
{
dumpn
(
"
*
*
*
unrecognized
hostname
(
"
+
hostPort
+
"
)
in
Host
"
+
"
header
400
time
"
)
;
throw
HTTP_400
;
}
metadata
.
_scheme
=
scheme
;
metadata
.
_host
=
host
;
metadata
.
_port
=
port
;
}
}
else
{
NS_ASSERT
(
metadata
.
_host
=
=
=
undefined
"
HTTP
/
1
.
0
doesn
'
t
allow
absolute
paths
in
the
request
line
!
"
)
;
metadata
.
_scheme
=
identity
.
primaryScheme
;
metadata
.
_host
=
identity
.
primaryHost
;
metadata
.
_port
=
identity
.
primaryPort
;
}
NS_ASSERT
(
identity
.
has
(
metadata
.
_scheme
metadata
.
_host
metadata
.
_port
)
"
must
have
a
location
we
recognize
by
now
!
"
)
;
}
_handleError
(
e
)
{
this
.
_state
=
READER_FINISHED
;
var
server
=
this
.
_connection
.
server
;
if
(
e
instanceof
HttpError
)
{
var
code
=
e
.
code
;
}
else
{
dumpn
(
"
!
!
!
UNEXPECTED
ERROR
:
"
+
e
+
(
e
.
lineNumber
?
"
line
"
+
e
.
lineNumber
:
"
"
)
)
;
code
=
500
;
server
.
_requestQuit
(
)
;
}
this
.
_data
=
null
;
this
.
_connection
.
processError
(
code
this
.
_metadata
)
;
}
_handleResponse
(
)
{
NS_ASSERT
(
this
.
_state
=
=
READER_FINISHED
)
;
this
.
_data
=
null
;
this
.
_connection
.
process
(
this
.
_metadata
)
;
}
_parseRequestLine
(
line
)
{
NS_ASSERT
(
this
.
_state
=
=
READER_IN_REQUEST_LINE
)
;
dumpn
(
"
*
*
*
_parseRequestLine
(
'
"
+
line
+
"
'
)
"
)
;
var
metadata
=
this
.
_metadata
;
var
request
=
line
.
split
(
/
[
\
t
]
+
/
)
;
if
(
!
request
|
|
request
.
length
!
=
3
)
{
dumpn
(
"
*
*
*
No
request
in
line
"
)
;
throw
HTTP_400
;
}
metadata
.
_method
=
request
[
0
]
;
var
ver
=
request
[
2
]
;
var
match
=
ver
.
match
(
/
^
HTTP
\
/
(
\
d
+
\
.
\
d
+
)
/
)
;
if
(
!
match
)
{
dumpn
(
"
*
*
*
No
HTTP
version
in
line
"
)
;
throw
HTTP_400
;
}
try
{
metadata
.
_httpVersion
=
new
nsHttpVersion
(
match
[
1
]
)
;
if
(
!
metadata
.
_httpVersion
.
atLeast
(
nsHttpVersion
.
HTTP_1_0
)
)
{
throw
new
Error
(
"
unsupported
HTTP
version
"
)
;
}
}
catch
(
e
)
{
throw
HTTP_501
;
}
var
fullPath
=
request
[
1
]
;
if
(
metadata
.
_method
=
=
"
CONNECT
"
)
{
metadata
.
_path
=
"
CONNECT
"
;
metadata
.
_scheme
=
"
https
"
;
[
metadata
.
_host
metadata
.
_port
]
=
fullPath
.
split
(
"
:
"
)
;
return
;
}
var
serverIdentity
=
this
.
_connection
.
server
.
identity
;
var
scheme
host
port
;
if
(
fullPath
.
charAt
(
0
)
!
=
"
/
"
)
{
if
(
!
metadata
.
_httpVersion
.
atLeast
(
nsHttpVersion
.
HTTP_1_1
)
)
{
dumpn
(
"
*
*
*
Metadata
version
too
low
"
)
;
throw
HTTP_400
;
}
try
{
var
uri
=
Services
.
io
.
newURI
(
fullPath
)
;
fullPath
=
uri
.
pathQueryRef
;
scheme
=
uri
.
scheme
;
host
=
metadata
.
_host
=
uri
.
asciiHost
;
port
=
uri
.
port
;
if
(
port
=
=
=
-
1
)
{
if
(
scheme
=
=
=
"
http
"
)
{
port
=
80
;
}
else
if
(
scheme
=
=
=
"
https
"
)
{
port
=
443
;
}
else
{
dumpn
(
"
*
*
*
Unknown
scheme
:
"
+
scheme
)
;
throw
HTTP_400
;
}
}
}
catch
(
e
)
{
dumpn
(
"
*
*
*
Threw
when
dealing
with
URI
:
"
+
e
)
;
throw
HTTP_400
;
}
if
(
!
serverIdentity
.
has
(
scheme
host
port
)
|
|
fullPath
.
charAt
(
0
)
!
=
"
/
"
)
{
dumpn
(
"
*
*
*
serverIdentity
unknown
or
path
does
not
start
with
'
/
'
"
)
;
throw
HTTP_400
;
}
}
var
splitter
=
fullPath
.
indexOf
(
"
?
"
)
;
if
(
splitter
<
0
)
{
metadata
.
_path
=
fullPath
;
}
else
{
metadata
.
_path
=
fullPath
.
substring
(
0
splitter
)
;
metadata
.
_queryString
=
fullPath
.
substring
(
splitter
+
1
)
;
}
metadata
.
_scheme
=
scheme
;
metadata
.
_host
=
host
;
metadata
.
_port
=
port
;
}
_parseHeaders
(
)
{
NS_ASSERT
(
this
.
_state
=
=
READER_IN_HEADERS
)
;
dumpn
(
"
*
*
*
_parseHeaders
"
)
;
var
data
=
this
.
_data
;
var
headers
=
this
.
_metadata
.
_headers
;
var
lastName
=
this
.
_lastHeaderName
;
var
lastVal
=
this
.
_lastHeaderValue
;
var
line
=
{
}
;
while
(
true
)
{
dumpn
(
"
*
*
*
Last
name
:
'
"
+
lastName
+
"
'
"
)
;
dumpn
(
"
*
*
*
Last
val
:
'
"
+
lastVal
+
"
'
"
)
;
NS_ASSERT
(
!
(
(
lastVal
=
=
=
undefined
)
^
(
lastName
=
=
=
undefined
)
)
lastName
=
=
=
undefined
?
"
lastVal
without
lastName
?
lastVal
:
'
"
+
lastVal
+
"
'
"
:
"
lastName
without
lastVal
?
lastName
:
'
"
+
lastName
+
"
'
"
)
;
if
(
!
data
.
readLine
(
line
)
)
{
this
.
_lastHeaderName
=
lastName
;
this
.
_lastHeaderValue
=
lastVal
;
return
false
;
}
var
lineText
=
line
.
value
;
dumpn
(
"
*
*
*
Line
text
:
'
"
+
lineText
+
"
'
"
)
;
var
firstChar
=
lineText
.
charAt
(
0
)
;
if
(
lineText
=
=
"
"
)
{
if
(
lastName
)
{
try
{
headers
.
setHeader
(
lastName
lastVal
true
)
;
}
catch
(
e
)
{
dumpn
(
"
*
*
*
setHeader
threw
on
last
header
e
=
=
"
+
e
)
;
throw
HTTP_400
;
}
}
else
{
}
this
.
_state
=
READER_IN_BODY
;
return
true
;
}
else
if
(
firstChar
=
=
"
"
|
|
firstChar
=
=
"
\
t
"
)
{
if
(
!
lastName
)
{
dumpn
(
"
We
don
'
t
have
a
header
to
continue
!
"
)
;
throw
HTTP_400
;
}
lastVal
+
=
lineText
;
}
else
{
if
(
lastName
)
{
try
{
headers
.
setHeader
(
lastName
lastVal
true
)
;
}
catch
(
e
)
{
dumpn
(
"
*
*
*
setHeader
threw
on
a
header
e
=
=
"
+
e
)
;
throw
HTTP_400
;
}
}
var
colon
=
lineText
.
indexOf
(
"
:
"
)
;
if
(
colon
<
1
)
{
dumpn
(
"
*
*
*
No
colon
or
missing
header
field
-
name
"
)
;
throw
HTTP_400
;
}
lastName
=
lineText
.
substring
(
0
colon
)
;
lastVal
=
lineText
.
substring
(
colon
+
1
)
;
}
}
}
}
;
const
CR
=
0x0d
LF
=
0x0a
;
function
findCRLF
(
array
start
)
{
for
(
var
i
=
array
.
indexOf
(
CR
start
)
;
i
>
=
0
;
i
=
array
.
indexOf
(
CR
i
+
1
)
)
{
if
(
array
[
i
+
1
]
=
=
LF
)
{
return
i
;
}
}
return
-
1
;
}
function
LineData
(
)
{
this
.
_data
=
[
]
;
this
.
_start
=
0
;
}
LineData
.
prototype
=
{
appendBytes
(
bytes
)
{
var
count
=
bytes
.
length
;
var
quantum
=
262144
;
if
(
count
<
quantum
)
{
Array
.
prototype
.
push
.
apply
(
this
.
_data
bytes
)
;
return
;
}
for
(
var
start
=
0
;
start
<
count
;
start
+
=
quantum
)
{
var
slice
=
bytes
.
slice
(
start
Math
.
min
(
start
+
quantum
count
)
)
;
Array
.
prototype
.
push
.
apply
(
this
.
_data
slice
)
;
}
}
readLine
(
out
)
{
var
data
=
this
.
_data
;
var
length
=
findCRLF
(
data
this
.
_start
)
;
if
(
length
<
0
)
{
this
.
_start
=
data
.
length
;
if
(
data
.
length
>
0
&
&
data
[
data
.
length
-
1
]
=
=
=
CR
)
{
-
-
this
.
_start
;
}
return
false
;
}
this
.
_start
=
0
;
var
leading
=
data
.
splice
(
0
length
+
2
)
;
var
quantum
=
262144
;
var
line
=
"
"
;
for
(
var
start
=
0
;
start
<
length
;
start
+
=
quantum
)
{
var
slice
=
leading
.
slice
(
start
Math
.
min
(
start
+
quantum
length
)
)
;
line
+
=
String
.
fromCharCode
.
apply
(
null
slice
)
;
}
out
.
value
=
line
;
return
true
;
}
purge
(
)
{
var
data
=
this
.
_data
;
this
.
_data
=
[
]
;
return
data
;
}
}
;
function
createHandlerFunc
(
handler
)
{
return
function
(
metadata
response
)
{
handler
.
handle
(
metadata
response
)
;
}
;
}
function
defaultIndexHandler
(
metadata
response
)
{
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
;
charset
=
utf
-
8
"
false
)
;
var
path
=
htmlEscape
(
decodeURI
(
metadata
.
path
)
)
;
var
body
=
"
<
html
>
\
<
head
>
\
<
title
>
"
+
path
+
"
<
/
title
>
\
<
/
head
>
\
<
body
>
\
<
h1
>
"
+
path
+
'
<
/
h1
>
\
<
ol
style
=
"
list
-
style
-
type
:
none
"
>
'
;
var
directory
=
metadata
.
getProperty
(
"
directory
"
)
;
NS_ASSERT
(
directory
&
&
directory
.
isDirectory
(
)
)
;
var
fileList
=
[
]
;
var
files
=
directory
.
directoryEntries
;
while
(
files
.
hasMoreElements
(
)
)
{
var
f
=
files
.
nextFile
;
let
name
=
f
.
leafName
;
if
(
!
f
.
isHidden
(
)
&
&
(
name
.
charAt
(
name
.
length
-
1
)
!
=
HIDDEN_CHAR
|
|
name
.
charAt
(
name
.
length
-
2
)
=
=
HIDDEN_CHAR
)
)
{
fileList
.
push
(
f
)
;
}
}
fileList
.
sort
(
fileSort
)
;
for
(
var
i
=
0
;
i
<
fileList
.
length
;
i
+
+
)
{
var
file
=
fileList
[
i
]
;
try
{
let
name
=
file
.
leafName
;
if
(
name
.
charAt
(
name
.
length
-
1
)
=
=
HIDDEN_CHAR
)
{
name
=
name
.
substring
(
0
name
.
length
-
1
)
;
}
var
sep
=
file
.
isDirectory
(
)
?
"
/
"
:
"
"
;
var
item
=
'
<
li
>
<
a
href
=
"
'
+
encodeURIComponent
(
name
)
+
sep
+
'
"
>
'
+
htmlEscape
(
name
)
+
sep
+
"
<
/
a
>
<
/
li
>
"
;
body
+
=
item
;
}
catch
(
e
)
{
}
}
body
+
=
"
<
/
ol
>
\
<
/
body
>
\
<
/
html
>
"
;
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
}
function
fileSort
(
a
b
)
{
var
dira
=
a
.
isDirectory
(
)
dirb
=
b
.
isDirectory
(
)
;
if
(
dira
&
&
!
dirb
)
{
return
-
1
;
}
if
(
dirb
&
&
!
dira
)
{
return
1
;
}
var
namea
=
a
.
leafName
.
toLowerCase
(
)
nameb
=
b
.
leafName
.
toLowerCase
(
)
;
return
nameb
>
namea
?
-
1
:
1
;
}
function
toInternalPath
(
path
encoded
)
{
if
(
encoded
)
{
path
=
decodeURI
(
path
)
;
}
var
comps
=
path
.
split
(
"
/
"
)
;
for
(
var
i
=
0
sz
=
comps
.
length
;
i
<
sz
;
i
+
+
)
{
var
comp
=
comps
[
i
]
;
if
(
comp
.
charAt
(
comp
.
length
-
1
)
=
=
HIDDEN_CHAR
)
{
comps
[
i
]
=
comp
+
HIDDEN_CHAR
;
}
}
return
comps
.
join
(
"
/
"
)
;
}
const
PERMS_READONLY
=
(
4
<
<
6
)
|
(
4
<
<
3
)
|
4
;
function
maybeAddHeadersInternal
(
file
metadata
response
informationalResponse
)
{
var
name
=
file
.
leafName
;
if
(
name
.
charAt
(
name
.
length
-
1
)
=
=
HIDDEN_CHAR
)
{
name
=
name
.
substring
(
0
name
.
length
-
1
)
;
}
var
headerFile
=
file
.
parent
;
if
(
!
informationalResponse
)
{
headerFile
.
append
(
name
+
HEADERS_SUFFIX
)
;
}
else
{
headerFile
.
append
(
name
+
INFORMATIONAL_RESPONSE_SUFFIX
)
;
}
if
(
!
headerFile
.
exists
(
)
)
{
return
;
}
const
PR_RDONLY
=
0x01
;
var
fis
=
new
FileInputStream
(
headerFile
PR_RDONLY
PERMS_READONLY
Ci
.
nsIFileInputStream
.
CLOSE_ON_EOF
)
;
try
{
var
lis
=
new
ConverterInputStream
(
fis
"
UTF
-
8
"
1024
0x0
)
;
lis
.
QueryInterface
(
Ci
.
nsIUnicharLineInputStream
)
;
var
line
=
{
value
:
"
"
}
;
var
more
=
lis
.
readLine
(
line
)
;
if
(
!
more
&
&
line
.
value
=
=
"
"
)
{
return
;
}
var
status
=
line
.
value
;
if
(
status
.
indexOf
(
"
HTTP
"
)
=
=
0
)
{
status
=
status
.
substring
(
5
)
;
var
space
=
status
.
indexOf
(
"
"
)
;
var
code
description
;
if
(
space
<
0
)
{
code
=
status
;
description
=
"
"
;
}
else
{
code
=
status
.
substring
(
0
space
)
;
description
=
status
.
substring
(
space
+
1
status
.
length
)
;
}
if
(
!
informationalResponse
)
{
response
.
setStatusLine
(
metadata
.
httpVersion
parseInt
(
code
10
)
description
)
;
}
else
{
response
.
setInformationalResponseStatusLine
(
metadata
.
httpVersion
parseInt
(
code
10
)
description
)
;
}
line
.
value
=
"
"
;
more
=
lis
.
readLine
(
line
)
;
}
else
if
(
informationalResponse
)
{
return
;
}
while
(
more
|
|
line
.
value
!
=
"
"
)
{
var
header
=
line
.
value
;
var
colon
=
header
.
indexOf
(
"
:
"
)
;
if
(
!
informationalResponse
)
{
response
.
setHeader
(
header
.
substring
(
0
colon
)
header
.
substring
(
colon
+
1
header
.
length
)
false
)
;
}
else
{
response
.
setInformationalResponseHeader
(
header
.
substring
(
0
colon
)
header
.
substring
(
colon
+
1
header
.
length
)
false
)
;
}
line
.
value
=
"
"
;
more
=
lis
.
readLine
(
line
)
;
}
}
catch
(
e
)
{
dumpn
(
"
WARNING
:
error
in
headers
for
"
+
metadata
.
path
+
"
:
"
+
e
)
;
throw
HTTP_500
;
}
finally
{
fis
.
close
(
)
;
}
}
function
maybeAddHeaders
(
file
metadata
response
)
{
maybeAddHeadersInternal
(
file
metadata
response
false
)
;
}
function
maybeAddInformationalResponse
(
file
metadata
response
)
{
maybeAddHeadersInternal
(
file
metadata
response
true
)
;
}
function
ServerHandler
(
server
)
{
this
.
_server
=
server
;
this
.
_pathDirectoryMap
=
new
FileMap
(
)
;
this
.
_overridePaths
=
{
}
;
this
.
_overridePrefixes
=
{
}
;
this
.
_overrideErrors
=
{
}
;
this
.
_mimeMappings
=
{
}
;
this
.
_indexHandler
=
defaultIndexHandler
;
this
.
_state
=
{
}
;
this
.
_sharedState
=
{
}
;
this
.
_objectState
=
{
}
;
}
ServerHandler
.
prototype
=
{
handleResponse
(
connection
)
{
var
request
=
connection
.
request
;
var
response
=
new
Response
(
connection
)
;
var
path
=
request
.
path
;
dumpn
(
"
*
*
*
path
=
=
"
+
path
)
;
try
{
try
{
if
(
path
in
this
.
_overridePaths
)
{
dumpn
(
"
calling
override
for
"
+
path
)
;
this
.
_overridePaths
[
path
]
(
request
response
)
;
}
else
{
var
longestPrefix
=
"
"
;
for
(
let
prefix
in
this
.
_overridePrefixes
)
{
if
(
prefix
.
length
>
longestPrefix
.
length
&
&
path
.
substr
(
0
prefix
.
length
)
=
=
prefix
)
{
longestPrefix
=
prefix
;
}
}
if
(
longestPrefix
.
length
>
0
)
{
dumpn
(
"
calling
prefix
override
for
"
+
longestPrefix
)
;
this
.
_overridePrefixes
[
longestPrefix
]
(
request
response
)
;
}
else
{
this
.
_handleDefault
(
request
response
)
;
}
}
}
catch
(
e
)
{
if
(
response
.
partiallySent
(
)
)
{
response
.
abort
(
e
)
;
return
;
}
if
(
!
(
e
instanceof
HttpError
)
)
{
dumpn
(
"
*
*
*
unexpected
error
:
e
=
=
"
+
e
)
;
throw
HTTP_500
;
}
if
(
e
.
code
!
=
=
404
)
{
throw
e
;
}
dumpn
(
"
*
*
*
default
:
"
+
(
path
in
this
.
_defaultPaths
)
)
;
response
=
new
Response
(
connection
)
;
if
(
path
in
this
.
_defaultPaths
)
{
this
.
_defaultPaths
[
path
]
(
request
response
)
;
}
else
{
throw
HTTP_404
;
}
}
}
catch
(
e
)
{
if
(
response
.
partiallySent
(
)
)
{
response
.
abort
(
e
)
;
return
;
}
var
errorCode
=
"
internal
"
;
try
{
if
(
!
(
e
instanceof
HttpError
)
)
{
throw
e
;
}
errorCode
=
e
.
code
;
dumpn
(
"
*
*
*
errorCode
=
=
"
+
errorCode
)
;
response
=
new
Response
(
connection
)
;
if
(
e
.
customErrorHandling
)
{
e
.
customErrorHandling
(
response
)
;
}
this
.
_handleError
(
errorCode
request
response
)
;
return
;
}
catch
(
e2
)
{
dumpn
(
"
*
*
*
error
handling
"
+
errorCode
+
"
error
:
"
+
"
e2
=
=
"
+
e2
+
"
shutting
down
server
"
)
;
connection
.
server
.
_requestQuit
(
)
;
response
.
abort
(
e2
)
;
return
;
}
}
response
.
complete
(
)
;
}
registerFile
(
path
file
handler
)
{
if
(
!
file
)
{
dumpn
(
"
*
*
*
unregistering
'
"
+
path
+
"
'
mapping
"
)
;
delete
this
.
_overridePaths
[
path
]
;
return
;
}
dumpn
(
"
*
*
*
registering
'
"
+
path
+
"
'
as
mapping
to
"
+
file
.
path
)
;
file
=
file
.
clone
(
)
;
var
self
=
this
;
this
.
_overridePaths
[
path
]
=
function
(
request
response
)
{
if
(
!
file
.
exists
(
)
)
{
throw
HTTP_404
;
}
dumpn
(
"
*
*
*
responding
'
"
+
path
+
"
'
as
mapping
to
"
+
file
.
path
)
;
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
if
(
typeof
handler
=
=
=
"
function
"
)
{
handler
(
request
response
)
;
}
self
.
_writeFileResponse
(
request
file
response
0
file
.
fileSize
)
;
}
;
}
registerPathHandler
(
path
handler
)
{
if
(
path
.
length
=
=
0
)
{
throw
Components
.
Exception
(
"
Handler
path
cannot
be
empty
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
path
.
charAt
(
0
)
!
=
"
/
"
&
&
path
!
=
"
CONNECT
"
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
_handlerToField
(
handler
this
.
_overridePaths
path
)
;
}
registerPrefixHandler
(
path
handler
)
{
if
(
path
.
charAt
(
0
)
!
=
"
/
"
|
|
path
.
charAt
(
path
.
length
-
1
)
!
=
"
/
"
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
this
.
_handlerToField
(
handler
this
.
_overridePrefixes
path
)
;
}
registerDirectory
(
path
directory
)
{
var
key
=
path
.
length
=
=
1
?
"
"
:
path
.
substring
(
1
path
.
length
-
1
)
;
if
(
key
.
charAt
(
0
)
=
=
"
/
"
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
key
=
toInternalPath
(
key
false
)
;
if
(
directory
)
{
dumpn
(
"
*
*
*
mapping
'
"
+
path
+
"
'
to
the
location
"
+
directory
.
path
)
;
this
.
_pathDirectoryMap
.
put
(
key
directory
)
;
}
else
{
dumpn
(
"
*
*
*
removing
mapping
for
'
"
+
path
+
"
'
"
)
;
this
.
_pathDirectoryMap
.
put
(
key
null
)
;
}
}
registerErrorHandler
(
err
handler
)
{
if
(
!
(
err
in
HTTP_ERROR_CODES
)
)
{
dumpn
(
"
*
*
*
WARNING
:
registering
non
-
HTTP
/
1
.
1
error
code
"
+
"
(
"
+
err
+
"
)
handler
-
-
was
this
intentional
?
"
)
;
}
this
.
_handlerToField
(
handler
this
.
_overrideErrors
err
)
;
}
setIndexHandler
(
handler
)
{
if
(
!
handler
)
{
handler
=
defaultIndexHandler
;
}
else
if
(
typeof
handler
!
=
"
function
"
)
{
handler
=
createHandlerFunc
(
handler
)
;
}
this
.
_indexHandler
=
handler
;
}
registerContentType
(
ext
type
)
{
if
(
!
type
)
{
delete
this
.
_mimeMappings
[
ext
]
;
}
else
{
this
.
_mimeMappings
[
ext
]
=
headerUtils
.
normalizeFieldValue
(
type
)
;
}
}
_handlerToField
(
handler
dict
key
)
{
if
(
typeof
handler
=
=
"
function
"
)
{
dict
[
key
]
=
handler
;
}
else
if
(
handler
)
{
dict
[
key
]
=
createHandlerFunc
(
handler
)
;
}
else
{
delete
dict
[
key
]
;
}
}
_handleDefault
(
metadata
response
)
{
dumpn
(
"
*
*
*
_handleDefault
(
)
"
)
;
response
.
setStatusLine
(
metadata
.
httpVersion
200
"
OK
"
)
;
var
path
=
metadata
.
path
;
NS_ASSERT
(
path
.
charAt
(
0
)
=
=
"
/
"
"
invalid
path
:
<
"
+
path
+
"
>
"
)
;
var
file
=
this
.
_getFileForPath
(
path
)
;
if
(
file
.
exists
(
)
&
&
file
.
isDirectory
(
)
)
{
file
.
append
(
"
index
.
html
"
)
;
if
(
!
file
.
exists
(
)
|
|
file
.
isDirectory
(
)
)
{
metadata
.
_ensurePropertyBag
(
)
;
metadata
.
_bag
.
setPropertyAsInterface
(
"
directory
"
file
.
parent
)
;
this
.
_indexHandler
(
metadata
response
)
;
return
;
}
}
if
(
!
file
.
exists
(
)
)
{
throw
HTTP_404
;
}
var
start
end
;
if
(
metadata
.
_httpVersion
.
atLeast
(
nsHttpVersion
.
HTTP_1_1
)
&
&
metadata
.
hasHeader
(
"
Range
"
)
&
&
this
.
_getTypeFromFile
(
file
)
!
=
=
SJS_TYPE
)
{
var
rangeMatch
=
metadata
.
getHeader
(
"
Range
"
)
.
match
(
/
^
bytes
=
(
\
d
+
)
?
-
(
\
d
+
)
?
/
)
;
if
(
!
rangeMatch
)
{
dumpn
(
"
*
*
*
Range
header
bogosity
:
'
"
+
metadata
.
getHeader
(
"
Range
"
)
+
"
'
"
)
;
throw
HTTP_400
;
}
if
(
rangeMatch
[
1
]
!
=
=
undefined
)
{
start
=
parseInt
(
rangeMatch
[
1
]
10
)
;
}
if
(
rangeMatch
[
2
]
!
=
=
undefined
)
{
end
=
parseInt
(
rangeMatch
[
2
]
10
)
;
}
if
(
start
=
=
=
undefined
&
&
end
=
=
=
undefined
)
{
dumpn
(
"
*
*
*
More
Range
header
bogosity
:
'
"
+
metadata
.
getHeader
(
"
Range
"
)
+
"
'
"
)
;
throw
HTTP_400
;
}
if
(
start
=
=
=
undefined
)
{
start
=
Math
.
max
(
0
file
.
fileSize
-
end
)
;
end
=
file
.
fileSize
-
1
;
}
if
(
end
=
=
=
undefined
|
|
end
>
=
file
.
fileSize
)
{
end
=
file
.
fileSize
-
1
;
}
if
(
start
!
=
=
undefined
&
&
start
>
=
file
.
fileSize
)
{
var
HTTP_416
=
new
HttpError
(
416
"
Requested
Range
Not
Satisfiable
"
)
;
HTTP_416
.
customErrorHandling
=
function
(
errorResponse
)
{
maybeAddHeaders
(
file
metadata
errorResponse
)
;
}
;
throw
HTTP_416
;
}
if
(
end
<
start
)
{
response
.
setStatusLine
(
metadata
.
httpVersion
200
"
OK
"
)
;
start
=
0
;
end
=
file
.
fileSize
-
1
;
}
else
{
response
.
setStatusLine
(
metadata
.
httpVersion
206
"
Partial
Content
"
)
;
var
contentRange
=
"
bytes
"
+
start
+
"
-
"
+
end
+
"
/
"
+
file
.
fileSize
;
response
.
setHeader
(
"
Content
-
Range
"
contentRange
)
;
}
}
else
{
start
=
0
;
end
=
file
.
fileSize
-
1
;
}
dumpn
(
"
*
*
*
handling
'
"
+
path
+
"
'
as
mapping
to
"
+
file
.
path
+
"
from
"
+
start
+
"
to
"
+
end
+
"
inclusive
"
)
;
this
.
_writeFileResponse
(
metadata
file
response
start
end
-
start
+
1
)
;
}
_writeFileResponse
(
metadata
file
response
offset
count
)
{
const
PR_RDONLY
=
0x01
;
var
type
=
this
.
_getTypeFromFile
(
file
)
;
if
(
type
=
=
=
SJS_TYPE
)
{
let
fis
=
new
FileInputStream
(
file
PR_RDONLY
PERMS_READONLY
Ci
.
nsIFileInputStream
.
CLOSE_ON_EOF
)
;
try
{
var
s
=
Cu
.
Sandbox
(
gGlobalObject
)
;
s
.
importFunction
(
dump
"
dump
"
)
;
s
.
importFunction
(
atob
"
atob
"
)
;
s
.
importFunction
(
btoa
"
btoa
"
)
;
s
.
importFunction
(
ChromeUtils
"
ChromeUtils
"
)
;
var
self
=
this
;
var
path
=
metadata
.
path
;
s
.
importFunction
(
function
getState
(
k
)
{
return
self
.
_getState
(
path
k
)
;
}
)
;
s
.
importFunction
(
function
setState
(
k
v
)
{
self
.
_setState
(
path
k
v
)
;
}
)
;
s
.
importFunction
(
function
getSharedState
(
k
)
{
return
self
.
_getSharedState
(
k
)
;
}
)
;
s
.
importFunction
(
function
setSharedState
(
k
v
)
{
self
.
_setSharedState
(
k
v
)
;
}
)
;
s
.
importFunction
(
function
getObjectState
(
k
callback
)
{
callback
(
self
.
_getObjectState
(
k
)
)
;
}
)
;
s
.
importFunction
(
function
setObjectState
(
k
v
)
{
self
.
_setObjectState
(
k
v
)
;
}
)
;
s
.
importFunction
(
function
registerPathHandler
(
p
h
)
{
self
.
registerPathHandler
(
p
h
)
;
}
)
;
this
.
_setState
(
path
"
__LOCATION__
"
file
.
path
)
;
try
{
var
line
=
new
Error
(
)
.
lineNumber
;
let
uri
=
Services
.
io
.
newFileURI
(
file
)
;
Services
.
scriptloader
.
loadSubScript
(
uri
.
spec
s
)
;
}
catch
(
e
)
{
dumpn
(
"
*
*
*
syntax
error
in
SJS
at
"
+
file
.
path
+
"
:
"
+
e
)
;
throw
HTTP_500
;
}
try
{
s
.
handleRequest
(
metadata
response
)
;
}
catch
(
e
)
{
dump
(
"
*
*
*
error
running
SJS
at
"
+
file
.
path
+
"
:
"
+
e
+
"
on
line
"
+
(
e
instanceof
Error
?
e
.
lineNumber
+
"
in
httpd
.
js
"
:
e
.
lineNumber
-
line
)
+
"
\
n
"
)
;
throw
HTTP_500
;
}
}
finally
{
fis
.
close
(
)
;
}
}
else
{
try
{
response
.
setHeader
(
"
Last
-
Modified
"
toDateString
(
file
.
lastModifiedTime
)
false
)
;
}
catch
(
e
)
{
}
response
.
setHeader
(
"
Content
-
Type
"
type
false
)
;
maybeAddInformationalResponse
(
file
metadata
response
)
;
maybeAddHeaders
(
file
metadata
response
)
;
response
.
setHeader
(
"
Content
-
Length
"
"
"
+
count
false
)
;
let
fis
=
new
FileInputStream
(
file
PR_RDONLY
PERMS_READONLY
Ci
.
nsIFileInputStream
.
CLOSE_ON_EOF
)
;
offset
=
offset
|
|
0
;
count
=
count
|
|
file
.
fileSize
;
NS_ASSERT
(
offset
=
=
=
0
|
|
offset
<
file
.
fileSize
"
bad
offset
"
)
;
NS_ASSERT
(
count
>
=
0
"
bad
count
"
)
;
NS_ASSERT
(
offset
+
count
<
=
file
.
fileSize
"
bad
total
data
size
"
)
;
try
{
if
(
offset
!
=
=
0
)
{
if
(
fis
instanceof
Ci
.
nsISeekableStream
)
{
fis
.
seek
(
Ci
.
nsISeekableStream
.
NS_SEEK_SET
offset
)
;
}
else
{
new
ScriptableInputStream
(
fis
)
.
read
(
offset
)
;
}
}
}
catch
(
e
)
{
fis
.
close
(
)
;
throw
e
;
}
let
writeMore
=
function
(
)
{
gThreadManager
.
currentThread
.
dispatch
(
writeData
Ci
.
nsIThread
.
DISPATCH_NORMAL
)
;
}
;
var
input
=
new
BinaryInputStream
(
fis
)
;
var
output
=
new
BinaryOutputStream
(
response
.
bodyOutputStream
)
;
var
writeData
=
{
run
(
)
{
var
chunkSize
=
Math
.
min
(
65536
count
)
;
count
-
=
chunkSize
;
NS_ASSERT
(
count
>
=
0
"
underflow
"
)
;
try
{
var
data
=
input
.
readByteArray
(
chunkSize
)
;
NS_ASSERT
(
data
.
length
=
=
=
chunkSize
"
incorrect
data
returned
?
got
"
+
data
.
length
+
"
expected
"
+
chunkSize
)
;
output
.
writeByteArray
(
data
)
;
if
(
count
=
=
=
0
)
{
fis
.
close
(
)
;
response
.
finish
(
)
;
}
else
{
writeMore
(
)
;
}
}
catch
(
e
)
{
try
{
fis
.
close
(
)
;
}
finally
{
response
.
finish
(
)
;
}
throw
e
;
}
}
}
;
writeMore
(
)
;
response
.
processAsync
(
)
;
}
}
_getState
(
path
k
)
{
var
state
=
this
.
_state
;
if
(
path
in
state
&
&
k
in
state
[
path
]
)
{
return
state
[
path
]
[
k
]
;
}
return
"
"
;
}
_setState
(
path
k
v
)
{
if
(
typeof
v
!
=
=
"
string
"
)
{
throw
new
Error
(
"
non
-
string
value
passed
"
)
;
}
var
state
=
this
.
_state
;
if
(
!
(
path
in
state
)
)
{
state
[
path
]
=
{
}
;
}
state
[
path
]
[
k
]
=
v
;
}
_getSharedState
(
k
)
{
var
state
=
this
.
_sharedState
;
if
(
k
in
state
)
{
return
state
[
k
]
;
}
return
"
"
;
}
_setSharedState
(
k
v
)
{
if
(
typeof
v
!
=
=
"
string
"
)
{
throw
new
Error
(
"
non
-
string
value
passed
"
)
;
}
this
.
_sharedState
[
k
]
=
v
;
}
_getObjectState
(
k
)
{
if
(
typeof
k
!
=
=
"
string
"
)
{
throw
new
Error
(
"
non
-
string
key
passed
"
)
;
}
return
this
.
_objectState
[
k
]
|
|
null
;
}
_setObjectState
(
k
v
)
{
if
(
typeof
k
!
=
=
"
string
"
)
{
throw
new
Error
(
"
non
-
string
key
passed
"
)
;
}
if
(
typeof
v
!
=
=
"
object
"
)
{
throw
new
Error
(
"
non
-
object
value
passed
"
)
;
}
if
(
v
&
&
!
(
"
QueryInterface
"
in
v
)
)
{
throw
new
Error
(
"
must
pass
an
nsISupports
;
use
wrappedJSObject
to
ease
"
+
"
pain
when
using
the
server
from
JS
"
)
;
}
this
.
_objectState
[
k
]
=
v
;
}
_getTypeFromFile
(
file
)
{
try
{
var
name
=
file
.
leafName
;
var
dot
=
name
.
lastIndexOf
(
"
.
"
)
;
if
(
dot
>
0
)
{
var
ext
=
name
.
slice
(
dot
+
1
)
;
if
(
ext
in
this
.
_mimeMappings
)
{
return
this
.
_mimeMappings
[
ext
]
;
}
}
return
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
.
getTypeFromFile
(
file
)
;
}
catch
(
e
)
{
return
"
application
/
octet
-
stream
"
;
}
}
_getFileForPath
(
path
)
{
try
{
path
=
toInternalPath
(
path
true
)
;
}
catch
(
e
)
{
dumpn
(
"
*
*
*
toInternalPath
threw
"
+
e
)
;
throw
HTTP_400
;
}
var
pathMap
=
this
.
_pathDirectoryMap
;
var
tmp
=
path
.
substring
(
1
)
;
while
(
true
)
{
var
file
=
pathMap
.
get
(
tmp
)
;
if
(
file
)
{
if
(
tmp
=
=
path
.
substring
(
1
)
&
&
tmp
.
length
!
=
0
&
&
tmp
.
charAt
(
tmp
.
length
-
1
)
!
=
"
/
"
)
{
file
=
null
;
}
else
{
break
;
}
}
if
(
tmp
=
=
"
"
)
{
break
;
}
tmp
=
tmp
.
substring
(
0
tmp
.
lastIndexOf
(
"
/
"
)
)
;
}
if
(
!
file
)
{
throw
HTTP_404
;
}
var
parentFolder
=
file
.
parent
;
var
dirIsRoot
=
parentFolder
=
=
null
;
var
leafPath
=
path
.
substring
(
tmp
.
length
+
1
)
;
var
comps
=
leafPath
.
split
(
"
/
"
)
;
for
(
var
i
=
0
sz
=
comps
.
length
;
i
<
sz
;
i
+
+
)
{
var
comp
=
comps
[
i
]
;
if
(
comp
=
=
"
.
.
"
)
{
file
=
file
.
parent
;
}
else
if
(
comp
=
=
"
.
"
|
|
comp
=
=
"
"
)
{
continue
;
}
else
{
file
.
append
(
comp
)
;
}
if
(
!
dirIsRoot
&
&
file
.
equals
(
parentFolder
)
)
{
throw
HTTP_403
;
}
}
return
file
;
}
handleError
(
errorCode
connection
)
{
var
response
=
new
Response
(
connection
)
;
dumpn
(
"
*
*
*
error
in
request
:
"
+
errorCode
)
;
this
.
_handleError
(
errorCode
new
Request
(
connection
.
port
)
response
)
;
}
_handleError
(
errorCode
metadata
response
)
{
if
(
!
metadata
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NULL_POINTER
)
;
}
var
errorX00
=
errorCode
-
(
errorCode
%
100
)
;
try
{
if
(
!
(
errorCode
in
HTTP_ERROR_CODES
)
)
{
dumpn
(
"
*
*
*
WARNING
:
requested
invalid
error
:
"
+
errorCode
)
;
}
try
{
if
(
errorCode
in
this
.
_overrideErrors
)
{
this
.
_overrideErrors
[
errorCode
]
(
metadata
response
)
;
}
else
{
this
.
_defaultErrors
[
errorCode
]
(
metadata
response
)
;
}
}
catch
(
e
)
{
if
(
response
.
partiallySent
(
)
)
{
response
.
abort
(
e
)
;
return
;
}
if
(
errorX00
=
=
errorCode
)
{
throw
HTTP_500
;
}
dumpn
(
"
*
*
*
error
in
handling
for
error
code
"
+
errorCode
+
"
"
+
"
falling
back
to
"
+
errorX00
+
"
.
.
.
"
)
;
response
=
new
Response
(
response
.
_connection
)
;
if
(
errorX00
in
this
.
_overrideErrors
)
{
this
.
_overrideErrors
[
errorX00
]
(
metadata
response
)
;
}
else
if
(
errorX00
in
this
.
_defaultErrors
)
{
this
.
_defaultErrors
[
errorX00
]
(
metadata
response
)
;
}
else
{
throw
HTTP_500
;
}
}
}
catch
(
e
)
{
if
(
response
.
partiallySent
(
)
)
{
response
.
abort
(
)
;
return
;
}
dumpn
(
"
*
*
*
error
in
handling
for
error
code
"
+
errorX00
+
"
falling
"
+
"
back
to
500
.
.
.
"
)
;
try
{
response
=
new
Response
(
response
.
_connection
)
;
if
(
500
in
this
.
_overrideErrors
)
{
this
.
_overrideErrors
[
500
]
(
metadata
response
)
;
}
else
{
this
.
_defaultErrors
[
500
]
(
metadata
response
)
;
}
}
catch
(
e2
)
{
dumpn
(
"
*
*
*
multiple
errors
in
default
error
handlers
!
"
)
;
dumpn
(
"
*
*
*
e
=
=
"
+
e
+
"
e2
=
=
"
+
e2
)
;
response
.
abort
(
e2
)
;
return
;
}
}
response
.
complete
(
)
;
}
_defaultErrors
:
{
400
(
metadata
response
)
{
response
.
setStatusLine
(
"
1
.
1
"
400
"
Bad
Request
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
;
charset
=
utf
-
8
"
false
)
;
var
body
=
"
Bad
request
\
n
"
;
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
}
403
(
metadata
response
)
{
response
.
setStatusLine
(
metadata
.
httpVersion
403
"
Forbidden
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
;
charset
=
utf
-
8
"
false
)
;
var
body
=
"
<
html
>
\
<
head
>
<
title
>
403
Forbidden
<
/
title
>
<
/
head
>
\
<
body
>
\
<
h1
>
403
Forbidden
<
/
h1
>
\
<
/
body
>
\
<
/
html
>
"
;
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
}
404
(
metadata
response
)
{
response
.
setStatusLine
(
metadata
.
httpVersion
404
"
Not
Found
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
;
charset
=
utf
-
8
"
false
)
;
var
body
=
"
<
html
>
\
<
head
>
<
title
>
404
Not
Found
<
/
title
>
<
/
head
>
\
<
body
>
\
<
h1
>
404
Not
Found
<
/
h1
>
\
<
p
>
\
<
span
style
=
'
font
-
family
:
monospace
;
'
>
"
+
htmlEscape
(
metadata
.
path
)
+
"
<
/
span
>
was
not
found
.
\
<
/
p
>
\
<
/
body
>
\
<
/
html
>
"
;
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
}
416
(
metadata
response
)
{
response
.
setStatusLine
(
metadata
.
httpVersion
416
"
Requested
Range
Not
Satisfiable
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
;
charset
=
utf
-
8
"
false
)
;
var
body
=
"
<
html
>
\
<
head
>
\
<
title
>
416
Requested
Range
Not
Satisfiable
<
/
title
>
<
/
head
>
\
<
body
>
\
<
h1
>
416
Requested
Range
Not
Satisfiable
<
/
h1
>
\
<
p
>
The
byte
range
was
not
valid
for
the
\
requested
resource
.
\
<
/
p
>
\
<
/
body
>
\
<
/
html
>
"
;
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
}
500
(
metadata
response
)
{
response
.
setStatusLine
(
metadata
.
httpVersion
500
"
Internal
Server
Error
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
;
charset
=
utf
-
8
"
false
)
;
var
body
=
"
<
html
>
\
<
head
>
<
title
>
500
Internal
Server
Error
<
/
title
>
<
/
head
>
\
<
body
>
\
<
h1
>
500
Internal
Server
Error
<
/
h1
>
\
<
p
>
Something
'
s
broken
in
this
server
and
\
needs
to
be
fixed
.
<
/
p
>
\
<
/
body
>
\
<
/
html
>
"
;
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
}
501
(
metadata
response
)
{
response
.
setStatusLine
(
metadata
.
httpVersion
501
"
Not
Implemented
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
;
charset
=
utf
-
8
"
false
)
;
var
body
=
"
<
html
>
\
<
head
>
<
title
>
501
Not
Implemented
<
/
title
>
<
/
head
>
\
<
body
>
\
<
h1
>
501
Not
Implemented
<
/
h1
>
\
<
p
>
This
server
is
not
(
yet
)
Apache
.
<
/
p
>
\
<
/
body
>
\
<
/
html
>
"
;
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
}
505
(
metadata
response
)
{
response
.
setStatusLine
(
"
1
.
1
"
505
"
HTTP
Version
Not
Supported
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
;
charset
=
utf
-
8
"
false
)
;
var
body
=
"
<
html
>
\
<
head
>
<
title
>
505
HTTP
Version
Not
Supported
<
/
title
>
<
/
head
>
\
<
body
>
\
<
h1
>
505
HTTP
Version
Not
Supported
<
/
h1
>
\
<
p
>
This
server
only
supports
HTTP
/
1
.
0
and
HTTP
/
1
.
1
\
connections
.
<
/
p
>
\
<
/
body
>
\
<
/
html
>
"
;
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
}
}
_defaultPaths
:
{
"
/
"
:
function
(
metadata
response
)
{
response
.
setStatusLine
(
metadata
.
httpVersion
200
"
OK
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
;
charset
=
utf
-
8
"
false
)
;
var
body
=
"
<
html
>
\
<
head
>
<
title
>
httpd
.
js
<
/
title
>
<
/
head
>
\
<
body
>
\
<
h1
>
httpd
.
js
<
/
h1
>
\
<
p
>
If
you
'
re
seeing
this
page
httpd
.
js
is
up
and
\
serving
requests
!
Now
set
a
base
path
and
serve
some
\
files
!
<
/
p
>
\
<
/
body
>
\
<
/
html
>
"
;
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
}
"
/
trace
"
:
function
(
metadata
response
)
{
response
.
setStatusLine
(
metadata
.
httpVersion
200
"
OK
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
;
charset
=
utf
-
8
"
false
)
;
var
body
=
"
Request
-
URI
:
"
+
metadata
.
scheme
+
"
:
/
/
"
+
metadata
.
host
+
"
:
"
+
metadata
.
port
+
metadata
.
path
+
"
\
n
\
n
"
;
body
+
=
"
Request
(
semantically
equivalent
slightly
reformatted
)
:
\
n
\
n
"
;
body
+
=
metadata
.
method
+
"
"
+
metadata
.
path
;
if
(
metadata
.
queryString
)
{
body
+
=
"
?
"
+
metadata
.
queryString
;
}
body
+
=
"
HTTP
/
"
+
metadata
.
httpVersion
+
"
\
r
\
n
"
;
var
headEnum
=
metadata
.
headers
;
while
(
headEnum
.
hasMoreElements
(
)
)
{
var
fieldName
=
headEnum
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsISupportsString
)
.
data
;
body
+
=
fieldName
+
"
:
"
+
metadata
.
getHeader
(
fieldName
)
+
"
\
r
\
n
"
;
}
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
}
}
}
;
function
FileMap
(
)
{
this
.
_map
=
{
}
;
}
FileMap
.
prototype
=
{
put
(
key
value
)
{
if
(
value
)
{
this
.
_map
[
key
]
=
value
.
clone
(
)
;
}
else
{
delete
this
.
_map
[
key
]
;
}
}
get
(
key
)
{
var
val
=
this
.
_map
[
key
]
;
return
val
?
val
.
clone
(
)
:
null
;
}
}
;
const
IS_TOKEN_ARRAY
=
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
1
1
1
1
1
0
0
1
1
0
1
1
0
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
1
0
1
]
;
function
isCTL
(
code
)
{
return
(
code
>
=
0
&
&
code
<
=
31
)
|
|
code
=
=
127
;
}
function
Response
(
connection
)
{
this
.
_connection
=
connection
;
this
.
_httpVersion
=
nsHttpVersion
.
HTTP_1_1
;
this
.
_httpCode
=
200
;
this
.
_httpDescription
=
"
OK
"
;
this
.
_headers
=
new
nsHttpHeaders
(
)
;
this
.
_informationalResponseHttpVersion
=
nsHttpVersion
.
HTTP_1_1
;
this
.
_informationalResponseHttpCode
=
0
;
this
.
_informationalResponseHttpDescription
=
"
"
;
this
.
_informationalResponseHeaders
=
new
nsHttpHeaders
(
)
;
this
.
_informationalResponseSet
=
false
;
this
.
_ended
=
false
;
this
.
_bodyOutputStream
=
null
;
this
.
_bodyInputStream
=
null
;
this
.
_asyncCopier
=
null
;
this
.
_processAsync
=
false
;
this
.
_finished
=
false
;
this
.
_powerSeized
=
false
;
}
Response
.
prototype
=
{
get
bodyOutputStream
(
)
{
if
(
this
.
_finished
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
!
this
.
_bodyOutputStream
)
{
var
pipe
=
new
Pipe
(
true
false
Response
.
SEGMENT_SIZE
PR_UINT32_MAX
null
)
;
this
.
_bodyOutputStream
=
pipe
.
outputStream
;
this
.
_bodyInputStream
=
pipe
.
inputStream
;
if
(
this
.
_processAsync
|
|
this
.
_powerSeized
)
{
this
.
_startAsyncProcessor
(
)
;
}
}
return
this
.
_bodyOutputStream
;
}
write
(
data
)
{
if
(
this
.
_finished
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
var
dataAsString
=
String
(
data
)
;
this
.
bodyOutputStream
.
write
(
dataAsString
dataAsString
.
length
)
;
}
setStatusLineInternal
(
httpVersion
code
description
informationalResponse
)
{
if
(
this
.
_finished
|
|
this
.
_powerSeized
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
!
informationalResponse
)
{
if
(
!
this
.
_headers
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
}
else
if
(
!
this
.
_informationalResponseHeaders
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
this
.
_ensureAlive
(
)
;
if
(
!
(
code
>
=
0
&
&
code
<
1000
)
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
try
{
var
httpVer
;
if
(
!
httpVersion
|
|
httpVersion
=
=
"
1
.
1
"
)
{
httpVer
=
nsHttpVersion
.
HTTP_1_1
;
}
else
if
(
httpVersion
=
=
"
1
.
0
"
)
{
httpVer
=
nsHttpVersion
.
HTTP_1_0
;
}
else
{
httpVer
=
new
nsHttpVersion
(
httpVersion
)
;
}
}
catch
(
e
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
description
)
{
description
=
"
"
;
}
for
(
var
i
=
0
;
i
<
description
.
length
;
i
+
+
)
{
if
(
isCTL
(
description
.
charCodeAt
(
i
)
)
&
&
description
.
charAt
(
i
)
!
=
"
\
t
"
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
}
if
(
!
informationalResponse
)
{
this
.
_httpDescription
=
description
;
this
.
_httpCode
=
code
;
this
.
_httpVersion
=
httpVer
;
}
else
{
this
.
_informationalResponseSet
=
true
;
this
.
_informationalResponseHttpDescription
=
description
;
this
.
_informationalResponseHttpCode
=
code
;
this
.
_informationalResponseHttpVersion
=
httpVer
;
}
}
setStatusLine
(
httpVersion
code
description
)
{
this
.
setStatusLineInternal
(
httpVersion
code
description
false
)
;
}
setInformationalResponseStatusLine
(
httpVersion
code
description
)
{
this
.
setStatusLineInternal
(
httpVersion
code
description
true
)
;
}
setHeader
(
name
value
merge
)
{
if
(
!
this
.
_headers
|
|
this
.
_finished
|
|
this
.
_powerSeized
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
this
.
_ensureAlive
(
)
;
this
.
_headers
.
setHeader
(
name
value
merge
)
;
}
setInformationalResponseHeader
(
name
value
merge
)
{
if
(
!
this
.
_informationalResponseHeaders
|
|
this
.
_finished
|
|
this
.
_powerSeized
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
this
.
_ensureAlive
(
)
;
this
.
_informationalResponseHeaders
.
setHeader
(
name
value
merge
)
;
}
setHeaderNoCheck
(
name
value
)
{
if
(
!
this
.
_headers
|
|
this
.
_finished
|
|
this
.
_powerSeized
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
this
.
_ensureAlive
(
)
;
this
.
_headers
.
setHeaderNoCheck
(
name
value
)
;
}
setInformationalHeaderNoCheck
(
name
value
)
{
if
(
!
this
.
_headers
|
|
this
.
_finished
|
|
this
.
_powerSeized
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
this
.
_ensureAlive
(
)
;
this
.
_informationalResponseHeaders
.
setHeaderNoCheck
(
name
value
)
;
}
processAsync
(
)
{
if
(
this
.
_finished
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
if
(
this
.
_powerSeized
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
this
.
_processAsync
)
{
return
;
}
this
.
_ensureAlive
(
)
;
dumpn
(
"
*
*
*
processing
connection
"
+
this
.
_connection
.
number
+
"
async
"
)
;
this
.
_processAsync
=
true
;
if
(
this
.
_bodyOutputStream
&
&
!
this
.
_asyncCopier
)
{
this
.
_startAsyncProcessor
(
)
;
}
}
seizePower
(
)
{
if
(
this
.
_processAsync
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
this
.
_finished
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
if
(
this
.
_powerSeized
)
{
return
;
}
this
.
_ensureAlive
(
)
;
dumpn
(
"
*
*
*
forcefully
seizing
power
over
connection
"
+
this
.
_connection
.
number
+
"
.
.
.
"
)
;
if
(
this
.
_asyncCopier
)
{
this
.
_asyncCopier
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
}
this
.
_asyncCopier
=
null
;
if
(
this
.
_bodyOutputStream
)
{
var
input
=
new
BinaryInputStream
(
this
.
_bodyInputStream
)
;
var
avail
;
while
(
(
avail
=
input
.
available
(
)
)
>
0
)
{
input
.
readByteArray
(
avail
)
;
}
}
this
.
_powerSeized
=
true
;
if
(
this
.
_bodyOutputStream
)
{
this
.
_startAsyncProcessor
(
)
;
}
}
finish
(
)
{
if
(
!
this
.
_processAsync
&
&
!
this
.
_powerSeized
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
if
(
this
.
_finished
)
{
return
;
}
dumpn
(
"
*
*
*
finishing
connection
"
+
this
.
_connection
.
number
)
;
this
.
_startAsyncProcessor
(
)
;
if
(
this
.
_bodyOutputStream
)
{
this
.
_bodyOutputStream
.
close
(
)
;
}
this
.
_finished
=
true
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIHttpResponse
"
]
)
get
httpVersion
(
)
{
this
.
_ensureAlive
(
)
;
return
this
.
_httpVersion
.
toString
(
)
;
}
get
httpCode
(
)
{
this
.
_ensureAlive
(
)
;
var
codeString
=
(
this
.
_httpCode
<
10
?
"
0
"
:
"
"
)
+
(
this
.
_httpCode
<
100
?
"
0
"
:
"
"
)
+
this
.
_httpCode
;
return
codeString
;
}
get
httpDescription
(
)
{
this
.
_ensureAlive
(
)
;
return
this
.
_httpDescription
;
}
get
headers
(
)
{
this
.
_ensureAlive
(
)
;
return
this
.
_headers
;
}
getHeader
(
name
)
{
this
.
_ensureAlive
(
)
;
return
this
.
_headers
.
getHeader
(
name
)
;
}
partiallySent
(
)
{
dumpn
(
"
*
*
*
partiallySent
(
)
"
)
;
return
this
.
_processAsync
|
|
this
.
_powerSeized
;
}
complete
(
)
{
dumpn
(
"
*
*
*
complete
(
)
"
)
;
if
(
this
.
_processAsync
|
|
this
.
_powerSeized
)
{
NS_ASSERT
(
this
.
_processAsync
^
this
.
_powerSeized
"
can
'
t
both
send
async
and
relinquish
power
"
)
;
return
;
}
NS_ASSERT
(
!
this
.
partiallySent
(
)
"
completing
a
partially
-
sent
response
?
"
)
;
this
.
_startAsyncProcessor
(
)
;
if
(
this
.
_bodyOutputStream
)
{
this
.
_bodyOutputStream
.
close
(
)
;
}
}
abort
(
e
truncateConnection
=
false
)
{
dumpn
(
"
*
*
*
abort
(
<
"
+
e
+
"
>
)
"
)
;
if
(
truncateConnection
)
{
dumpn
(
"
*
*
*
truncate
connection
"
)
;
this
.
_connection
.
transport
.
setLinger
(
true
0
)
;
}
var
copier
=
this
.
_asyncCopier
;
if
(
copier
)
{
gThreadManager
.
currentThread
.
dispatch
(
{
run
(
)
{
dumpn
(
"
*
*
*
canceling
copy
asynchronously
.
.
.
"
)
;
copier
.
cancel
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
}
Ci
.
nsIThread
.
DISPATCH_NORMAL
)
;
}
else
{
this
.
end
(
)
;
}
}
end
(
)
{
NS_ASSERT
(
!
this
.
_ended
"
ending
this
response
twice
?
!
?
!
"
)
;
this
.
_connection
.
close
(
)
;
if
(
this
.
_bodyOutputStream
)
{
this
.
_bodyOutputStream
.
close
(
)
;
}
this
.
_finished
=
true
;
this
.
_ended
=
true
;
}
_startAsyncProcessor
(
)
{
dumpn
(
"
*
*
*
_startAsyncProcessor
(
)
"
)
;
if
(
this
.
_asyncCopier
|
|
this
.
_ended
)
{
dumpn
(
"
*
*
*
ignoring
second
call
to
_startAsyncProcessor
"
)
;
return
;
}
if
(
this
.
_headers
&
&
!
this
.
_powerSeized
)
{
this
.
_sendHeaders
(
)
;
return
;
}
this
.
_headers
=
null
;
this
.
_sendBody
(
)
;
}
_sendHeaders
(
)
{
dumpn
(
"
*
*
*
_sendHeaders
(
)
"
)
;
NS_ASSERT
(
this
.
_headers
)
;
NS_ASSERT
(
this
.
_informationalResponseHeaders
)
;
NS_ASSERT
(
!
this
.
_powerSeized
)
;
var
preambleData
=
[
]
;
if
(
this
.
_informationalResponseSet
)
{
let
statusLine
=
"
HTTP
/
"
+
this
.
_informationalResponseHttpVersion
+
"
"
+
this
.
_informationalResponseHttpCode
+
"
"
+
this
.
_informationalResponseHttpDescription
+
"
\
r
\
n
"
;
preambleData
.
push
(
statusLine
)
;
let
headEnum
=
this
.
_informationalResponseHeaders
.
enumerator
;
while
(
headEnum
.
hasMoreElements
(
)
)
{
let
fieldName
=
headEnum
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsISupportsString
)
.
data
;
let
values
=
this
.
_informationalResponseHeaders
.
getHeaderValues
(
fieldName
)
;
for
(
let
i
=
0
sz
=
values
.
length
;
i
<
sz
;
i
+
+
)
{
preambleData
.
push
(
fieldName
+
"
:
"
+
values
[
i
]
+
"
\
r
\
n
"
)
;
}
}
preambleData
.
push
(
"
\
r
\
n
"
)
;
}
var
statusLine
=
"
HTTP
/
"
+
this
.
httpVersion
+
"
"
+
this
.
httpCode
+
"
"
+
this
.
httpDescription
+
"
\
r
\
n
"
;
var
headers
=
this
.
_headers
;
headers
.
setHeader
(
"
Connection
"
"
close
"
false
)
;
headers
.
setHeader
(
"
Server
"
"
httpd
.
js
"
false
)
;
if
(
!
headers
.
hasHeader
(
"
Date
"
)
)
{
headers
.
setHeader
(
"
Date
"
toDateString
(
Date
.
now
(
)
)
false
)
;
}
if
(
!
this
.
_processAsync
)
{
dumpn
(
"
*
*
*
non
-
async
response
set
Content
-
Length
"
)
;
var
bodyStream
=
this
.
_bodyInputStream
;
var
avail
=
bodyStream
?
bodyStream
.
available
(
)
:
0
;
headers
.
setHeader
(
"
Content
-
Length
"
"
"
+
avail
false
)
;
}
dumpn
(
"
*
*
*
header
post
-
processing
completed
sending
response
head
.
.
.
"
)
;
preambleData
.
push
(
statusLine
)
;
var
headEnum
=
headers
.
enumerator
;
while
(
headEnum
.
hasMoreElements
(
)
)
{
var
fieldName
=
headEnum
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsISupportsString
)
.
data
;
var
values
=
headers
.
getHeaderValues
(
fieldName
)
;
for
(
var
i
=
0
sz
=
values
.
length
;
i
<
sz
;
i
+
+
)
{
preambleData
.
push
(
fieldName
+
"
:
"
+
values
[
i
]
+
"
\
r
\
n
"
)
;
}
}
preambleData
.
push
(
"
\
r
\
n
"
)
;
var
preamble
=
preambleData
.
join
(
"
"
)
;
var
responseHeadPipe
=
new
Pipe
(
true
false
0
PR_UINT32_MAX
null
)
;
responseHeadPipe
.
outputStream
.
write
(
preamble
preamble
.
length
)
;
var
response
=
this
;
var
copyObserver
=
{
onStartRequest
(
request
)
{
dumpn
(
"
*
*
*
preamble
copying
started
"
)
;
}
onStopRequest
(
request
statusCode
)
{
dumpn
(
"
*
*
*
preamble
copying
complete
"
+
"
[
status
=
0x
"
+
statusCode
.
toString
(
16
)
+
"
]
"
)
;
if
(
!
Components
.
isSuccessCode
(
statusCode
)
)
{
dumpn
(
"
!
!
!
header
copying
problems
:
non
-
success
statusCode
"
+
"
ending
response
"
)
;
response
.
end
(
)
;
}
else
{
response
.
_sendBody
(
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIRequestObserver
"
]
)
}
;
this
.
_asyncCopier
=
new
WriteThroughCopier
(
responseHeadPipe
.
inputStream
this
.
_connection
.
output
copyObserver
null
)
;
responseHeadPipe
.
outputStream
.
close
(
)
;
this
.
_headers
=
null
;
}
_sendBody
(
)
{
dumpn
(
"
*
*
*
_sendBody
"
)
;
NS_ASSERT
(
!
this
.
_headers
"
still
have
headers
around
but
sending
body
?
"
)
;
if
(
!
this
.
_bodyInputStream
)
{
dumpn
(
"
*
*
*
empty
body
response
finished
"
)
;
this
.
end
(
)
;
return
;
}
var
response
=
this
;
var
copyObserver
=
{
onStartRequest
(
request
)
{
dumpn
(
"
*
*
*
onStartRequest
"
)
;
}
onStopRequest
(
request
statusCode
)
{
dumpn
(
"
*
*
*
onStopRequest
[
status
=
0x
"
+
statusCode
.
toString
(
16
)
+
"
]
"
)
;
if
(
statusCode
=
=
=
Cr
.
NS_BINDING_ABORTED
)
{
dumpn
(
"
*
*
*
terminating
copy
observer
without
ending
the
response
"
)
;
}
else
{
if
(
!
Components
.
isSuccessCode
(
statusCode
)
)
{
dumpn
(
"
*
*
*
WARNING
:
non
-
success
statusCode
in
onStopRequest
"
)
;
}
response
.
end
(
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIRequestObserver
"
]
)
}
;
dumpn
(
"
*
*
*
starting
async
copier
of
body
data
.
.
.
"
)
;
this
.
_asyncCopier
=
new
WriteThroughCopier
(
this
.
_bodyInputStream
this
.
_connection
.
output
copyObserver
null
)
;
}
_ensureAlive
(
)
{
NS_ASSERT
(
!
this
.
_ended
"
not
handling
response
lifetime
correctly
"
)
;
}
}
;
Response
.
SEGMENT_SIZE
=
8192
;
function
notImplemented
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
function
streamClosed
(
e
)
{
return
(
e
=
=
=
Cr
.
NS_BASE_STREAM_CLOSED
|
|
(
typeof
e
=
=
=
"
object
"
&
&
e
.
result
=
=
=
Cr
.
NS_BASE_STREAM_CLOSED
)
)
;
}
function
wouldBlock
(
e
)
{
return
(
e
=
=
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
|
|
(
typeof
e
=
=
=
"
object
"
&
&
e
.
result
=
=
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
)
)
;
}
function
WriteThroughCopier
(
source
sink
observer
context
)
{
if
(
!
source
|
|
!
sink
|
|
!
observer
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NULL_POINTER
)
;
}
this
.
_source
=
source
;
this
.
_sink
=
sink
;
this
.
_observer
=
observer
;
this
.
_context
=
context
;
this
.
_canceled
=
false
;
this
.
_completed
=
false
;
this
.
loadFlags
=
0
;
this
.
loadGroup
=
null
;
this
.
name
=
"
response
-
body
-
copy
"
;
this
.
status
=
Cr
.
NS_OK
;
this
.
_pendingData
=
[
]
;
try
{
observer
.
onStartRequest
(
this
)
;
this
.
_waitToReadData
(
)
;
this
.
_waitForSinkClosure
(
)
;
}
catch
(
e
)
{
dumpn
(
"
!
!
!
error
starting
copy
:
"
+
e
+
(
"
lineNumber
"
in
e
?
"
line
"
+
e
.
lineNumber
:
"
"
)
)
;
dumpn
(
e
.
stack
)
;
this
.
cancel
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
}
WriteThroughCopier
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIInputStreamCallback
"
"
nsIOutputStreamCallback
"
"
nsIRequest
"
]
)
onInputStreamReady
(
input
)
{
if
(
this
.
_source
=
=
=
null
)
{
return
;
}
dumpn
(
"
*
*
*
onInputStreamReady
"
)
;
var
bytesWanted
=
0
bytesConsumed
=
-
1
;
try
{
input
=
new
BinaryInputStream
(
input
)
;
bytesWanted
=
Math
.
min
(
input
.
available
(
)
Response
.
SEGMENT_SIZE
)
;
dumpn
(
"
*
*
*
input
wanted
:
"
+
bytesWanted
)
;
if
(
bytesWanted
>
0
)
{
var
data
=
input
.
readByteArray
(
bytesWanted
)
;
bytesConsumed
=
data
.
length
;
this
.
_pendingData
.
push
(
String
.
fromCharCode
.
apply
(
String
data
)
)
;
}
dumpn
(
"
*
*
*
"
+
bytesConsumed
+
"
bytes
read
"
)
;
if
(
bytesWanted
=
=
=
0
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_BASE_STREAM_CLOSED
)
;
}
}
catch
(
e
)
{
let
rv
;
if
(
streamClosed
(
e
)
)
{
dumpn
(
"
*
*
*
input
stream
closed
"
)
;
rv
=
bytesWanted
=
=
=
0
?
Cr
.
NS_OK
:
Cr
.
NS_ERROR_UNEXPECTED
;
}
else
{
dumpn
(
"
!
!
!
unexpected
error
reading
from
input
canceling
:
"
+
e
)
;
rv
=
Cr
.
NS_ERROR_UNEXPECTED
;
}
this
.
_doneReadingSource
(
rv
)
;
return
;
}
var
pendingData
=
this
.
_pendingData
;
NS_ASSERT
(
bytesConsumed
>
0
)
;
NS_ASSERT
(
pendingData
.
length
>
0
"
no
pending
data
somehow
?
"
)
;
NS_ASSERT
(
pendingData
[
pendingData
.
length
-
1
]
.
length
>
0
"
buffered
zero
bytes
of
data
?
"
)
;
NS_ASSERT
(
this
.
_source
!
=
=
null
)
;
if
(
this
.
_sink
=
=
=
null
)
{
pendingData
.
length
=
0
;
this
.
_doneReadingSource
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
return
;
}
try
{
if
(
pendingData
.
length
=
=
=
1
)
{
this
.
_waitToWriteData
(
)
;
}
}
catch
(
e
)
{
dumpn
(
"
!
!
!
error
waiting
to
write
data
just
read
swallowing
and
"
+
"
writing
only
what
we
already
have
:
"
+
e
)
;
this
.
_doneWritingToSink
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
return
;
}
try
{
this
.
_waitToReadData
(
)
;
}
catch
(
e
)
{
dumpn
(
"
!
!
!
error
waiting
to
read
more
data
:
"
+
e
)
;
this
.
_doneReadingSource
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
}
onOutputStreamReady
(
output
)
{
if
(
this
.
_sink
=
=
=
null
)
{
return
;
}
dumpn
(
"
*
*
*
onOutputStreamReady
"
)
;
var
pendingData
=
this
.
_pendingData
;
if
(
pendingData
.
length
=
=
=
0
)
{
dumpn
(
"
!
!
!
output
stream
closed
prematurely
ending
copy
"
)
;
this
.
_doneWritingToSink
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
return
;
}
NS_ASSERT
(
pendingData
[
0
]
.
length
>
0
"
queued
up
an
empty
quantum
?
"
)
;
try
{
var
quantum
=
pendingData
[
0
]
;
var
bytesWritten
=
output
.
write
(
quantum
quantum
.
length
)
;
if
(
bytesWritten
=
=
=
quantum
.
length
)
{
pendingData
.
shift
(
)
;
}
else
{
pendingData
[
0
]
=
quantum
.
substring
(
bytesWritten
)
;
}
dumpn
(
"
*
*
*
wrote
"
+
bytesWritten
+
"
bytes
of
data
"
)
;
}
catch
(
e
)
{
if
(
wouldBlock
(
e
)
)
{
NS_ASSERT
(
pendingData
.
length
>
0
"
stream
-
blocking
exception
with
no
data
to
write
?
"
)
;
NS_ASSERT
(
pendingData
[
0
]
.
length
>
0
"
stream
-
blocking
exception
with
empty
quantum
?
"
)
;
this
.
_waitToWriteData
(
)
;
return
;
}
if
(
streamClosed
(
e
)
)
{
dumpn
(
"
!
!
!
output
stream
prematurely
closed
signaling
error
.
.
.
"
)
;
}
else
{
dumpn
(
"
!
!
!
unknown
error
:
"
+
e
+
"
quantum
=
"
+
quantum
)
;
}
this
.
_doneWritingToSink
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
return
;
}
try
{
if
(
pendingData
.
length
>
0
)
{
this
.
_waitToWriteData
(
)
;
return
;
}
}
catch
(
e
)
{
dumpn
(
"
!
!
!
unexpected
error
waiting
to
write
pending
data
:
"
+
e
)
;
this
.
_doneWritingToSink
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
this
.
_source
!
=
=
null
)
{
this
.
_waitForSinkClosure
(
)
;
}
else
{
this
.
_sink
=
null
;
this
.
_cancelOrDispatchCancelCallback
(
Cr
.
NS_OK
)
;
}
}
isPending
(
)
{
return
!
this
.
_completed
;
}
suspend
:
notImplemented
resume
:
notImplemented
cancel
(
status
)
{
dumpn
(
"
*
*
*
cancel
(
"
+
status
.
toString
(
16
)
+
"
)
"
)
;
if
(
this
.
_canceled
)
{
dumpn
(
"
*
*
*
suppressing
a
late
cancel
"
)
;
return
;
}
this
.
_canceled
=
true
;
this
.
status
=
status
;
this
.
_doneReadingSource
(
status
)
;
}
_doneReadingSource
(
e
)
{
dumpn
(
"
*
*
*
_doneReadingSource
(
0x
"
+
e
.
toString
(
16
)
+
"
)
"
)
;
this
.
_finishSource
(
e
)
;
if
(
this
.
_pendingData
.
length
=
=
=
0
)
{
this
.
_sink
=
null
;
}
else
{
NS_ASSERT
(
this
.
_sink
!
=
=
null
"
null
output
?
"
)
;
}
if
(
this
.
_sink
=
=
=
null
)
{
NS_ASSERT
(
this
.
_pendingData
.
length
=
=
=
0
"
pending
data
still
?
"
)
;
this
.
_cancelOrDispatchCancelCallback
(
e
)
;
}
}
_doneWritingToSink
(
e
)
{
dumpn
(
"
*
*
*
_doneWritingToSink
(
0x
"
+
e
.
toString
(
16
)
+
"
)
"
)
;
this
.
_pendingData
.
length
=
0
;
this
.
_sink
=
null
;
this
.
_doneReadingSource
(
e
)
;
}
_cancelOrDispatchCancelCallback
(
status
)
{
dumpn
(
"
*
*
*
_cancelOrDispatchCancelCallback
(
"
+
status
+
"
)
"
)
;
NS_ASSERT
(
this
.
_source
=
=
=
null
"
should
have
finished
input
"
)
;
NS_ASSERT
(
this
.
_sink
=
=
=
null
"
should
have
finished
output
"
)
;
NS_ASSERT
(
this
.
_pendingData
.
length
=
=
=
0
"
should
have
no
pending
data
"
)
;
if
(
!
this
.
_canceled
)
{
this
.
cancel
(
status
)
;
return
;
}
var
self
=
this
;
var
event
=
{
run
(
)
{
dumpn
(
"
*
*
*
onStopRequest
async
callback
"
)
;
self
.
_completed
=
true
;
try
{
self
.
_observer
.
onStopRequest
(
self
self
.
status
)
;
}
catch
(
e
)
{
NS_ASSERT
(
false
"
how
are
we
throwing
an
exception
here
?
we
control
"
+
"
all
the
callers
!
"
+
e
)
;
}
}
}
;
gThreadManager
.
currentThread
.
dispatch
(
event
Ci
.
nsIThread
.
DISPATCH_NORMAL
)
;
}
_waitToReadData
(
)
{
dumpn
(
"
*
*
*
_waitToReadData
"
)
;
this
.
_source
.
asyncWait
(
this
0
Response
.
SEGMENT_SIZE
gThreadManager
.
mainThread
)
;
}
_waitToWriteData
(
)
{
dumpn
(
"
*
*
*
_waitToWriteData
"
)
;
var
pendingData
=
this
.
_pendingData
;
NS_ASSERT
(
pendingData
.
length
>
0
"
no
pending
data
to
write
?
"
)
;
NS_ASSERT
(
pendingData
[
0
]
.
length
>
0
"
buffered
an
empty
write
?
"
)
;
this
.
_sink
.
asyncWait
(
this
0
pendingData
[
0
]
.
length
gThreadManager
.
mainThread
)
;
}
_waitForSinkClosure
(
)
{
dumpn
(
"
*
*
*
_waitForSinkClosure
"
)
;
this
.
_sink
.
asyncWait
(
this
Ci
.
nsIAsyncOutputStream
.
WAIT_CLOSURE_ONLY
0
gThreadManager
.
mainThread
)
;
}
_finishSource
(
status
)
{
dumpn
(
"
*
*
*
_finishSource
(
"
+
status
.
toString
(
16
)
+
"
)
"
)
;
if
(
this
.
_source
!
=
=
null
)
{
this
.
_source
.
closeWithStatus
(
status
)
;
this
.
_source
=
null
;
}
}
}
;
const
headerUtils
=
{
normalizeFieldName
(
fieldName
)
{
if
(
fieldName
=
=
"
"
)
{
dumpn
(
"
*
*
*
Empty
fieldName
"
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
for
(
var
i
=
0
sz
=
fieldName
.
length
;
i
<
sz
;
i
+
+
)
{
if
(
!
IS_TOKEN_ARRAY
[
fieldName
.
charCodeAt
(
i
)
]
)
{
dumpn
(
fieldName
+
"
is
not
a
valid
header
field
name
!
"
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
}
return
fieldName
.
toLowerCase
(
)
;
}
normalizeFieldValue
(
fieldValue
)
{
var
val
=
fieldValue
.
replace
(
/
(
?
:
(
?
:
\
r
\
n
)
?
[
\
t
]
+
)
+
/
g
"
"
)
;
val
=
val
.
replace
(
/
^
+
/
"
"
)
.
replace
(
/
+
/
"
"
)
;
dumpn
(
"
*
*
*
Normalized
value
:
'
"
+
val
+
"
'
"
)
;
for
(
var
i
=
0
len
=
val
.
length
;
i
<
len
;
i
+
+
)
{
if
(
isCTL
(
val
.
charCodeAt
(
i
)
)
)
{
dump
(
"
*
*
*
Char
"
+
i
+
"
has
charcode
"
+
val
.
charCodeAt
(
i
)
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
}
return
val
;
}
}
;
function
htmlEscape
(
str
)
{
var
s
=
"
"
;
for
(
var
i
=
0
;
i
<
str
.
length
;
i
+
+
)
{
s
+
=
"
&
#
"
+
str
.
charCodeAt
(
i
)
+
"
;
"
;
}
return
s
;
}
function
nsHttpVersion
(
versionString
)
{
var
matches
=
/
^
(
\
d
+
)
\
.
(
\
d
+
)
/
.
exec
(
versionString
)
;
if
(
!
matches
)
{
throw
new
Error
(
"
Not
a
valid
HTTP
version
!
"
)
;
}
this
.
major
=
parseInt
(
matches
[
1
]
10
)
;
this
.
minor
=
parseInt
(
matches
[
2
]
10
)
;
if
(
isNaN
(
this
.
major
)
|
|
isNaN
(
this
.
minor
)
|
|
this
.
major
<
0
|
|
this
.
minor
<
0
)
{
throw
new
Error
(
"
Not
a
valid
HTTP
version
!
"
)
;
}
}
nsHttpVersion
.
prototype
=
{
toString
(
)
{
return
this
.
major
+
"
.
"
+
this
.
minor
;
}
equals
(
otherVersion
)
{
return
this
.
major
=
=
otherVersion
.
major
&
&
this
.
minor
=
=
otherVersion
.
minor
;
}
atLeast
(
otherVersion
)
{
return
(
this
.
major
>
otherVersion
.
major
|
|
(
this
.
major
=
=
otherVersion
.
major
&
&
this
.
minor
>
=
otherVersion
.
minor
)
)
;
}
}
;
nsHttpVersion
.
HTTP_1_0
=
new
nsHttpVersion
(
"
1
.
0
"
)
;
nsHttpVersion
.
HTTP_1_1
=
new
nsHttpVersion
(
"
1
.
1
"
)
;
function
nsHttpHeaders
(
)
{
this
.
_headers
=
{
}
;
}
nsHttpHeaders
.
prototype
=
{
setHeader
(
fieldName
fieldValue
merge
)
{
var
name
=
headerUtils
.
normalizeFieldName
(
fieldName
)
;
var
value
=
headerUtils
.
normalizeFieldValue
(
fieldValue
)
;
if
(
merge
&
&
name
in
this
.
_headers
)
{
if
(
name
=
=
=
"
www
-
authenticate
"
|
|
name
=
=
=
"
proxy
-
authenticate
"
|
|
name
=
=
=
"
set
-
cookie
"
)
{
this
.
_headers
[
name
]
.
push
(
value
)
;
}
else
{
this
.
_headers
[
name
]
[
0
]
+
=
"
"
+
value
;
NS_ASSERT
(
this
.
_headers
[
name
]
.
length
=
=
=
1
"
how
'
d
a
non
-
special
header
have
multiple
values
?
"
)
;
}
}
else
{
this
.
_headers
[
name
]
=
[
value
]
;
}
}
setHeaderNoCheck
(
fieldName
fieldValue
)
{
var
name
=
headerUtils
.
normalizeFieldName
(
fieldName
)
;
var
value
=
headerUtils
.
normalizeFieldValue
(
fieldValue
)
;
if
(
name
in
this
.
_headers
)
{
this
.
_headers
[
name
]
.
push
(
value
)
;
}
else
{
this
.
_headers
[
name
]
=
[
value
]
;
}
}
getHeader
(
fieldName
)
{
return
this
.
getHeaderValues
(
fieldName
)
.
join
(
"
\
n
"
)
;
}
getHeaderValues
(
fieldName
)
{
var
name
=
headerUtils
.
normalizeFieldName
(
fieldName
)
;
if
(
name
in
this
.
_headers
)
{
return
this
.
_headers
[
name
]
;
}
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
hasHeader
(
fieldName
)
{
var
name
=
headerUtils
.
normalizeFieldName
(
fieldName
)
;
return
name
in
this
.
_headers
;
}
get
enumerator
(
)
{
var
headers
=
[
]
;
for
(
var
i
in
this
.
_headers
)
{
var
supports
=
new
SupportsString
(
)
;
supports
.
data
=
i
;
headers
.
push
(
supports
)
;
}
return
new
nsSimpleEnumerator
(
headers
)
;
}
}
;
function
nsSimpleEnumerator
(
items
)
{
this
.
_items
=
items
;
this
.
_nextIndex
=
0
;
}
nsSimpleEnumerator
.
prototype
=
{
hasMoreElements
(
)
{
return
this
.
_nextIndex
<
this
.
_items
.
length
;
}
getNext
(
)
{
if
(
!
this
.
hasMoreElements
(
)
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
return
this
.
_items
[
this
.
_nextIndex
+
+
]
;
}
[
Symbol
.
iterator
]
(
)
{
return
this
.
_items
.
values
(
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsISimpleEnumerator
"
]
)
}
;
function
Request
(
port
)
{
this
.
_method
=
"
"
;
this
.
_path
=
"
"
;
this
.
_queryString
=
"
"
;
this
.
_scheme
=
"
http
"
;
this
.
_host
=
undefined
;
this
.
_port
=
port
;
var
bodyPipe
=
new
Pipe
(
false
false
0
PR_UINT32_MAX
null
)
;
this
.
_bodyInputStream
=
bodyPipe
.
inputStream
;
this
.
_bodyOutputStream
=
bodyPipe
.
outputStream
;
this
.
_headers
=
new
nsHttpHeaders
(
)
;
this
.
_bag
=
null
;
}
Request
.
prototype
=
{
get
scheme
(
)
{
return
this
.
_scheme
;
}
get
host
(
)
{
return
this
.
_host
;
}
get
port
(
)
{
return
this
.
_port
;
}
get
method
(
)
{
return
this
.
_method
;
}
get
httpVersion
(
)
{
return
this
.
_httpVersion
.
toString
(
)
;
}
get
path
(
)
{
return
this
.
_path
;
}
get
queryString
(
)
{
return
this
.
_queryString
;
}
getHeader
(
name
)
{
return
this
.
_headers
.
getHeader
(
name
)
;
}
hasHeader
(
name
)
{
return
this
.
_headers
.
hasHeader
(
name
)
;
}
get
headers
(
)
{
return
this
.
_headers
.
enumerator
;
}
get
enumerator
(
)
{
this
.
_ensurePropertyBag
(
)
;
return
this
.
_bag
.
enumerator
;
}
get
bodyInputStream
(
)
{
return
this
.
_bodyInputStream
;
}
getProperty
(
name
)
{
this
.
_ensurePropertyBag
(
)
;
return
this
.
_bag
.
getProperty
(
name
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIHttpRequest
"
]
)
_ensurePropertyBag
(
)
{
if
(
!
this
.
_bag
)
{
this
.
_bag
=
new
WritablePropertyBag
(
)
;
}
}
}
;
function
server
(
port
basePath
)
{
if
(
basePath
)
{
var
lp
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
lp
.
initWithPath
(
basePath
)
;
}
DEBUG
=
true
;
var
srv
=
new
nsHttpServer
(
)
;
if
(
lp
)
{
srv
.
registerDirectory
(
"
/
"
lp
)
;
}
srv
.
registerContentType
(
"
sjs
"
SJS_TYPE
)
;
srv
.
identity
.
setPrimary
(
"
http
"
"
localhost
"
port
)
;
srv
.
start
(
port
)
;
var
thread
=
gThreadManager
.
currentThread
;
while
(
!
srv
.
isStopped
(
)
)
{
thread
.
processNextEvent
(
true
)
;
}
while
(
thread
.
hasPendingEvents
(
)
)
{
thread
.
processNextEvent
(
true
)
;
}
DEBUG
=
false
;
}
