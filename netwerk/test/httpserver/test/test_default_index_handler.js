var
srv
dir
dirEntries
;
XPCOMUtils
.
defineLazyGetter
(
this
'
BASE_URL
'
function
(
)
{
return
"
http
:
/
/
localhost
:
"
+
srv
.
identity
.
primaryPort
+
"
/
"
;
}
)
;
Cu
.
importGlobalProperties
(
[
"
DOMParser
"
]
)
;
function
run_test
(
)
{
createTestDirectory
(
)
;
srv
=
createServer
(
)
;
srv
.
registerDirectory
(
"
/
"
dir
)
;
var
nameDir
=
do_get_file
(
"
data
/
name
-
scheme
/
"
)
;
srv
.
registerDirectory
(
"
/
bar
/
"
nameDir
)
;
srv
.
start
(
-
1
)
;
function
done
(
)
{
do_test_pending
(
)
;
destroyTestDirectory
(
)
;
srv
.
stop
(
function
(
)
{
do_test_finished
(
)
;
}
)
;
}
runHttpTests
(
tests
done
)
;
}
function
createTestDirectory
(
)
{
dir
=
Cc
[
"
mozilla
.
org
/
file
/
directory_service
;
1
"
]
.
getService
(
Ci
.
nsIProperties
)
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
dir
.
append
(
"
index_handler_test_
"
+
Math
.
random
(
)
)
;
dir
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o744
)
;
var
files
=
[
]
;
makeFile
(
"
aa_directory
"
true
dir
files
)
;
makeFile
(
"
Ba_directory
"
true
dir
files
)
;
makeFile
(
"
bb_directory
"
true
dir
files
)
;
makeFile
(
"
foo
"
true
dir
files
)
;
makeFile
(
"
a_file
"
false
dir
files
)
;
makeFile
(
"
B_file
"
false
dir
files
)
;
makeFile
(
"
za
'
z
"
false
dir
files
)
;
makeFile
(
"
zb
&
z
"
false
dir
files
)
;
makeFile
(
"
zc
<
q
"
false
dir
files
)
;
makeFile
(
'
zd
"
q
'
false
dir
files
)
;
makeFile
(
"
ze
%
g
"
false
dir
files
)
;
makeFile
(
"
zf
%
200h
"
false
dir
files
)
;
makeFile
(
"
zg
>
m
"
false
dir
files
)
;
dirEntries
=
[
files
]
;
var
subdir
=
dir
.
clone
(
)
;
subdir
.
append
(
"
foo
"
)
;
files
=
[
]
;
makeFile
(
"
aa_dir
"
true
subdir
files
)
;
makeFile
(
"
b_dir
"
true
subdir
files
)
;
makeFile
(
"
AA_file
.
txt
"
false
subdir
files
)
;
makeFile
(
"
test
.
txt
"
false
subdir
files
)
;
dirEntries
.
push
(
files
)
;
}
function
destroyTestDirectory
(
)
{
dir
.
remove
(
true
)
;
}
function
hiddenDataCheck
(
bytes
uri
path
)
{
var
data
=
String
.
fromCharCode
.
apply
(
null
bytes
)
;
var
parser
=
new
DOMParser
(
)
;
try
{
var
doc
=
parser
.
parseFromString
(
data
"
application
/
xml
"
)
;
}
catch
(
e
)
{
do_throw
(
"
document
failed
to
parse
as
XML
"
)
;
}
var
body
=
doc
.
documentElement
.
getElementsByTagName
(
"
body
"
)
;
Assert
.
equal
(
body
.
length
1
)
;
body
=
body
[
0
]
;
var
header
=
body
.
getElementsByTagName
(
"
h1
"
)
;
Assert
.
equal
(
header
.
length
1
)
;
Assert
.
equal
(
header
[
0
]
.
textContent
path
)
;
var
lst
=
body
.
getElementsByTagName
(
"
ol
"
)
;
Assert
.
equal
(
lst
.
length
1
)
;
var
items
=
lst
[
0
]
.
getElementsByTagName
(
"
li
"
)
;
var
ios
=
Cc
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIOService
)
;
var
top
=
ios
.
newURI
(
uri
)
;
var
dirEntries
=
[
{
name
:
"
file
.
txt
"
isDirectory
:
false
}
{
name
:
"
SHOULD_SEE_THIS
.
txt
^
"
isDirectory
:
false
}
]
;
for
(
var
i
=
0
;
i
<
items
.
length
;
i
+
+
)
{
var
link
=
items
[
i
]
.
childNodes
[
0
]
;
var
f
=
dirEntries
[
i
]
;
var
sep
=
f
.
isDirectory
?
"
/
"
:
"
"
;
Assert
.
equal
(
link
.
textContent
f
.
name
+
sep
)
;
uri
=
ios
.
newURI
(
link
.
getAttribute
(
"
href
"
)
null
top
)
;
Assert
.
equal
(
decodeURIComponent
(
uri
.
pathQueryRef
)
path
+
f
.
name
+
sep
)
;
}
}
function
dataCheck
(
bytes
uri
path
dirEntries
)
{
var
data
=
String
.
fromCharCode
.
apply
(
null
bytes
)
;
var
parser
=
new
DOMParser
(
)
;
try
{
var
doc
=
parser
.
parseFromString
(
data
"
application
/
xml
"
)
;
}
catch
(
e
)
{
do_throw
(
"
document
failed
to
parse
as
XML
"
)
;
}
var
body
=
doc
.
documentElement
.
getElementsByTagName
(
"
body
"
)
;
Assert
.
equal
(
body
.
length
1
)
;
body
=
body
[
0
]
;
var
header
=
body
.
getElementsByTagName
(
"
h1
"
)
;
Assert
.
equal
(
header
.
length
1
)
;
Assert
.
equal
(
header
[
0
]
.
textContent
path
)
;
var
lst
=
body
.
getElementsByTagName
(
"
ol
"
)
;
Assert
.
equal
(
lst
.
length
1
)
;
var
items
=
lst
[
0
]
.
getElementsByTagName
(
"
li
"
)
;
var
ios
=
Cc
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIOService
)
;
var
dirURI
=
ios
.
newURI
(
uri
)
;
for
(
var
i
=
0
;
i
<
items
.
length
;
i
+
+
)
{
var
link
=
items
[
i
]
.
childNodes
[
0
]
;
var
f
=
dirEntries
[
i
]
;
var
sep
=
f
.
isDirectory
?
"
/
"
:
"
"
;
Assert
.
equal
(
link
.
textContent
f
.
name
+
sep
)
;
uri
=
ios
.
newURI
(
link
.
getAttribute
(
"
href
"
)
null
top
)
;
Assert
.
equal
(
decodeURIComponent
(
uri
.
pathQueryRef
)
path
+
f
.
name
+
sep
)
;
}
}
function
makeFile
(
name
isDirectory
parentDir
lst
)
{
var
type
=
Ci
.
nsIFile
[
isDirectory
?
"
DIRECTORY_TYPE
"
:
"
NORMAL_FILE_TYPE
"
]
;
var
file
=
parentDir
.
clone
(
)
;
try
{
file
.
append
(
name
)
;
file
.
create
(
type
0o755
)
;
lst
.
push
(
{
name
:
name
isDirectory
:
isDirectory
}
)
;
}
catch
(
e
)
{
}
}
XPCOMUtils
.
defineLazyGetter
(
this
"
tests
"
function
(
)
{
return
[
new
Test
(
BASE_URL
null
start
stopRootDirectory
)
new
Test
(
BASE_URL
+
"
foo
/
"
null
start
stopFooDirectory
)
new
Test
(
BASE_URL
+
"
bar
/
folder
^
/
"
null
start
stopTrailingCaretDirectory
)
]
;
}
)
;
function
start
(
ch
)
{
Assert
.
equal
(
ch
.
getResponseHeader
(
"
Content
-
Type
"
)
"
text
/
html
;
charset
=
utf
-
8
"
)
;
}
function
stopRootDirectory
(
ch
cx
status
data
)
{
dataCheck
(
data
BASE_URL
"
/
"
dirEntries
[
0
]
)
;
}
function
stopFooDirectory
(
ch
cx
status
data
)
{
dataCheck
(
data
BASE_URL
+
"
foo
/
"
"
/
foo
/
"
dirEntries
[
1
]
)
;
}
function
stopTrailingCaretDirectory
(
ch
cx
status
data
)
{
hiddenDataCheck
(
data
BASE_URL
+
"
bar
/
folder
^
/
"
"
/
bar
/
folder
^
/
"
)
;
}
